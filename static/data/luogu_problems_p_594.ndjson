{"pid": "P13055", "type": "P", "difficulty": 5, "samples": [["4\n1 1\n15\n3 3\n1 1 1\n1 2 1\n1 1 1\n1 3\n3 1 2\n1 3\n1 2 3", "Case #1: 15\nCase #2: 16\nCase #3: 14\nCase #4: 14"]], "limits": {"time": [40000, 40000, 40000], "memory": [1048576, 1048576, 1048576]}, "tags": ["模拟", "2020", "广度优先搜索 BFS", "Google Code Jam"], "title": "[GCJ 2020 #1A] Square Dance", "background": "", "description": "You are organizing an international dancing competition. You have already obtained all of the following:\n\n* A dance floor with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns, consisting of unit square cells;\n* $\\mathbf{R} \\times \\mathbf{C}$ competitors;\n* A cutting-edge automated judge for the competition.\n\nBut you are still missing an audience! You are worried that the competition might not be interesting enough, so you have come up with a way to calculate the interest level for the competition.\n\nEach competitor occupies one square unit cell of the floor and stays there until they are eliminated. A compass neighbor of a competitor $\\mathrm{x}$ is another competitor $\\mathrm{y}$ chosen such that $\\mathrm{y}$ shares a row or column with $\\mathrm{x}$, and there are no competitors still standing in cells in between $\\mathrm{x}$ and $\\mathrm{y}$. Each competitor may have between 0 and 4 compass neighbors, inclusive, and the number may decrease if all the other competitors in one orthogonal direction are eliminated.\n\nThe competition runs one round at a time. In between rounds $\\mathrm{i}$ and $\\mathrm{i}+1$, if a competitor $\\mathrm{d}$ had at least one compass neighbor during round $\\mathrm{i}$, and $\\mathrm{d}$ 's skill level is strictly less than the average skill level of all of $\\mathrm{d}$ 's compass neighbors, $\\mathrm{d}$ is eliminated and is not part of the competition for rounds $\\mathrm{i}+1, \\mathrm{i}+2, \\mathrm{i}+3$, etc. Notice that $\\mathrm{d}$ still counts as a neighbor of their other compass neighbors for the purpose of other eliminations that may also happen between rounds $\\mathrm{i}$ and $\\mathrm{i}+1$. Competitors that do not have any compass neighbors are never eliminated. If after a round no competitor is eliminated, then the competition ends.\n\nThe interest level of a round is the sum of skill levels of the competitors dancing in that round (even any competitors that are to be eliminated between that round and the next). The interest level of the competition is the sum of the interest levels of all of the rounds.\n\nGiven the skill levels of the dancers that are on the floor for the first round, what is the interest level of the competition?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each test case begins with a line containing two integers $\\mathbf{R}$ and $\\mathbf{C}$. Then, there are $\\mathbf{R}$ more lines containing $\\mathbf{C}$ integers each. The $\\mathrm{j}$-th value on the $\\mathrm{i}$-th of these lines, $\\mathrm{S}_{\\mathrm{i}, \\mathrm{j}}$, represents the skill level of the dancer in the cell in the $\\mathrm{i}$-th row and $\\mathrm{j}$-th column of the floor.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the interest level of the competition.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, only one competitor is on the floor. Since the competitor does not have any compass neighbors, they dance in one round, and then the competition is over. Thus the answer is equal to the dancer's skill level, 15.\n\nIn Sample Case #2, the interest level of the first round is $1+1+1+1+2+1+1+1+1=10$.\n\nThe competitors that are not in the center nor in a corner have a skill level of 1 , but the average of their compass neighbors is $4 / 3$, which is greater than 1 , so they are eliminated. The floor during the second round looks like this:\n\n```\n1 . 1\n. 2 .\n1 . 1\n```\n\nThis round is the last one. The competitors in the corner have two compass neighbors each, but the average of their skill level is equal to their own. The competitor in the center has no compass neighbor. The interest level of the round is $1+1+2+1+1=6$. This means the interest level of the competition is $10+6=16$.\n\nIn Sample Case #3, the competitor with skill level 1 is eliminated after the first round, while the other two remain. In the second round, the two other competitors become compass neighbors, and this causes the competitor with skill level 2 to be eliminated. There is a single competitor in the third round, which makes it the last one. The interest levels of the rounds are 6, 5 and 3, making the interest level of the competition 14.\n\n**Limits**\n\n- $1 \\leqslant S_{i, j} \\leqslant 10^{6}$, for all $i$ and $j$.\n\n**Test set 1 (9 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $1 \\leqslant \\mathrm{R} \\times \\mathrm{C} \\leqslant 100$.\n\n**Test set 2 (28 Pts, Hidden Verdict)**\n\n- $10 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $1000<\\mathrm{R} \\times \\mathrm{C} \\leqslant 10^{5}$, in exactly 10 cases.\n- $1 \\leqslant \\mathrm{R} \\times \\mathrm{C} \\leqslant 1000$, in exactly $\\mathrm{T}-10$ cases.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1A] Square Dance", "background": "", "description": "You are organizing an international dancing competition. You have already obtained all of the following:\n\n* A dance floor with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns, consisting of unit square cells;\n* $\\mathbf{R} \\times \\mathbf{C}$ competitors;\n* A cutting-edge automated judge for the competition.\n\nBut you are still missing an audience! You are worried that the competition might not be interesting enough, so you have come up with a way to calculate the interest level for the competition.\n\nEach competitor occupies one square unit cell of the floor and stays there until they are eliminated. A compass neighbor of a competitor $\\mathrm{x}$ is another competitor $\\mathrm{y}$ chosen such that $\\mathrm{y}$ shares a row or column with $\\mathrm{x}$, and there are no competitors still standing in cells in between $\\mathrm{x}$ and $\\mathrm{y}$. Each competitor may have between 0 and 4 compass neighbors, inclusive, and the number may decrease if all the other competitors in one orthogonal direction are eliminated.\n\nThe competition runs one round at a time. In between rounds $\\mathrm{i}$ and $\\mathrm{i}+1$, if a competitor $\\mathrm{d}$ had at least one compass neighbor during round $\\mathrm{i}$, and $\\mathrm{d}$ 's skill level is strictly less than the average skill level of all of $\\mathrm{d}$ 's compass neighbors, $\\mathrm{d}$ is eliminated and is not part of the competition for rounds $\\mathrm{i}+1, \\mathrm{i}+2, \\mathrm{i}+3$, etc. Notice that $\\mathrm{d}$ still counts as a neighbor of their other compass neighbors for the purpose of other eliminations that may also happen between rounds $\\mathrm{i}$ and $\\mathrm{i}+1$. Competitors that do not have any compass neighbors are never eliminated. If after a round no competitor is eliminated, then the competition ends.\n\nThe interest level of a round is the sum of skill levels of the competitors dancing in that round (even any competitors that are to be eliminated between that round and the next). The interest level of the competition is the sum of the interest levels of all of the rounds.\n\nGiven the skill levels of the dancers that are on the floor for the first round, what is the interest level of the competition?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each test case begins with a line containing two integers $\\mathbf{R}$ and $\\mathbf{C}$. Then, there are $\\mathbf{R}$ more lines containing $\\mathbf{C}$ integers each. The $\\mathrm{j}$-th value on the $\\mathrm{i}$-th of these lines, $\\mathrm{S}_{\\mathrm{i}, \\mathrm{j}}$, represents the skill level of the dancer in the cell in the $\\mathrm{i}$-th row and $\\mathrm{j}$-th column of the floor.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the interest level of the competition.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, only one competitor is on the floor. Since the competitor does not have any compass neighbors, they dance in one round, and then the competition is over. Thus the answer is equal to the dancer's skill level, 15.\n\nIn Sample Case #2, the interest level of the first round is $1+1+1+1+2+1+1+1+1=10$.\n\nThe competitors that are not in the center nor in a corner have a skill level of 1 , but the average of their compass neighbors is $4 / 3$, which is greater than 1 , so they are eliminated. The floor during the second round looks like this:\n\n```\n1 . 1\n. 2 .\n1 . 1\n```\n\nThis round is the last one. The competitors in the corner have two compass neighbors each, but the average of their skill level is equal to their own. The competitor in the center has no compass neighbor. The interest level of the round is $1+1+2+1+1=6$. This means the interest level of the competition is $10+6=16$.\n\nIn Sample Case #3, the competitor with skill level 1 is eliminated after the first round, while the other two remain. In the second round, the two other competitors become compass neighbors, and this causes the competitor with skill level 2 to be eliminated. There is a single competitor in the third round, which makes it the last one. The interest levels of the rounds are 6, 5 and 3, making the interest level of the competition 14.\n\n**Limits**\n\n- $1 \\leqslant S_{i, j} \\leqslant 10^{6}$, for all $i$ and $j$.\n\n**Test set 1 (9 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $1 \\leqslant \\mathrm{R} \\times \\mathrm{C} \\leqslant 100$.\n\n**Test set 2 (28 Pts, Hidden Verdict)**\n\n- $10 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $1000<\\mathrm{R} \\times \\mathrm{C} \\leqslant 10^{5}$, in exactly 10 cases.\n- $1 \\leqslant \\mathrm{R} \\times \\mathrm{C} \\leqslant 1000$, in exactly $\\mathrm{T}-10$ cases.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1A] Square Dance", "background": "", "description": "你正在组织一场国际舞蹈比赛。目前已经准备好以下内容：\n\n* 一个由 $\\mathbf{R}$ 行 $\\mathbf{C}$ 列单位方格组成的舞池；\n* $\\mathbf{R} \\times \\mathbf{C}$ 名参赛选手；\n* 一套先进的自动评分系统。\n\n但你还缺少观众！担心比赛可能不够精彩，你设计了一种计算比赛**精彩度**的方法。\n\n每名选手占据舞池的一个单位方格，直到被淘汰为止。选手 $\\mathrm{x}$ 的**罗盘邻居**是指满足以下条件的另一选手 $\\mathrm{y}$：$\\mathrm{y}$ 与 $\\mathrm{x}$ 同行或同列，且 $\\mathrm{x}$ 与 $\\mathrm{y}$ 之间没有其他未被淘汰的选手。每名选手可能有 0 到 4 个罗盘邻居（包含边界），且数量会因某一方向上选手被淘汰而减少。\n\n比赛按轮次进行。在第 $\\mathrm{i}$ 轮和第 $\\mathrm{i}+1$ 轮之间，若选手 $\\mathrm{d}$ 在第 $\\mathrm{i}$ 轮时有至少一个罗盘邻居，且 $\\mathrm{d}$ 的技能值**严格小于**其所有罗盘邻居技能值的平均值，则 $\\mathrm{d}$ 被淘汰，不再参与后续轮次。注意：$\\mathrm{d}$ 在被淘汰前仍会作为其他选手的罗盘邻居参与淘汰判定。没有罗盘邻居的选手永远不会被淘汰。若某一轮后无人被淘汰，则比赛结束。\n\n每一轮的精彩度是该轮所有参赛选手（包括即将被淘汰者）技能值之和。比赛的**总精彩度**是所有轮次精彩度的总和。\n\n给定第一轮所有选手的技能值，求比赛的总精彩度。", "inputFormat": "输入第一行包含测试用例数量 $\\mathrm{T}$。随后是 $\\mathrm{T}$ 个测试用例，每个用例格式如下：\n- 第一行：两个整数 $\\mathbf{R}$ 和 $\\mathbf{C}$；\n- 接下来 $\\mathbf{R}$ 行：每行 $\\mathbf{C}$ 个整数，其中第 $\\mathrm{i}$ 行第 $\\mathrm{j}$ 列的 $\\mathrm{S}_{\\mathrm{i}, \\mathrm{j}}$ 表示初始位于第 $\\mathrm{i}$ 行第 $\\mathrm{j}$ 列选手的技能值。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $\\mathrm{x}$ 为测试用例编号（从 1 开始），$\\mathrm{y}$ 为比赛的总精彩度。\n", "hint": "**样例解释**\n\n- **样例 #1**：仅有一名选手。因其无罗盘邻居，比赛仅进行一轮，总精彩度为该选手技能值 15。\n  \n- **样例 #2**：\n  - 第一轮精彩度：$1+1+1+1+2+1+1+1+1=10$。\n  - 非中心且非角落的选手（技能值 1）因邻居平均值 $4/3 > 1$ 被淘汰。第二轮舞池如下：\n    ```\n    1 . 1\n    . 2 .\n    1 . 1\n    ```\n  - 角落选手的邻居平均值等于自身技能值，中心选手无邻居，比赛结束。第二轮精彩度 $1+1+2+1+1=6$，总精彩度 $10+6=16$。\n\n- **样例 #3**：\n  - 第一轮后技能值 1 的选手被淘汰，剩余两人。\n  - 第二轮中，技能值 2 的选手因邻居平均值 $3/1 > 2$ 被淘汰。\n  - 第三轮仅剩一人，比赛结束。各轮精彩度分别为 6、5、3，总精彩度 14。\n\n**数据范围**\n\n- $\\forall i,j$，$1 \\leqslant S_{i, j} \\leqslant 10^{6}$。\n\n**测试集 1（9 分，可见评测结果）**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$；\n- $1 \\leqslant \\mathrm{R} \\times \\mathrm{C} \\leqslant 100$。\n\n**测试集 2（28 分，隐藏评测结果）**\n\n- $10 \\leqslant \\mathrm{T} \\leqslant 100$；\n- 恰好 10 个用例满足 $1000 < \\mathrm{R} \\times \\mathrm{C} \\leqslant 10^{5}$；\n- 其余 $\\mathrm{T}-10$ 个用例满足 $1 \\leqslant \\mathrm{R} \\times \\mathrm{C} \\leqslant 1000$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13056", "type": "P", "difficulty": 4, "samples": [["4\n2 3\n-2 -3\n3 0\n-1 1", "Case #1: SEN\nCase #2: NWS\nCase #3: EE\nCase #4: IMPOSSIBLE"]], "limits": {"time": [20000, 20000, 20000, 20000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2020", "位运算", "Google Code Jam"], "title": "[GCJ 2020 #1B] Expogo", "background": "", "description": "You have just received the best gift ever: an Expogo stick. You can stand on it and use it to make increasingly large jumps.\n\nYou are currently standing on point $(0,0)$ in your infinite two-dimensional backyard, and you are trying to reach a goal point $(\\mathrm{X}, \\mathrm{Y})$, with integer coordinates, in as few jumps as possible. You must land exactly on the goal point; it is not sufficient to pass over it on a jump.\n\nEach time you use your Expogo stick to jump, you pick a cardinal direction: north, south, east, or west. The $i$-th jump with your Expogo stick moves you $2^{(i-1)}$ units in the chosen direction, so your first jump takes you 1 unit, your second jump takes you 2 units, your third jump takes you 4 units, and so on.\n\nGiven a goal point $(\\mathrm{X}, \\mathrm{Y})$, determine whether it is possible to get there, and if so, demonstrate how to do it using as few jumps as possible.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each consists of a single line with two integers $\\mathrm{X}$ and $\\mathrm{Y}$ : the coordinates of the goal point.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if the goal point cannot be reached. Otherwise, $y$ must be a string of one or more characters, each of which is either $\\mathrm{N}$ (north), $\\mathrm{S}$ (south), $\\mathrm{E}$ (east), or $\\mathrm{W}$ (west), representing the directions of the jumps that you will make, in order. This sequence of jumps must reach the goal point at the end of the final jump, and it must be as short as possible.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you can jump south from $(0, 0)$ to $(0, -1)$, then jump east to $(2, -1)$, then jump north to $(2, 3)$.\n\nWe can be sure there is not a more efficient solution (two moves or fewer) because at least $2 + 3 = 5$ units of distance are needed to reach the goal point, but the first two jumps combined only give us $3$ units of distance.\n\nNotice that Sample Case #2 is like Sample Case #1 but reflected across both axes, and so the answer comes from reflecting all directions in Sample Case #1's answer.\n\nIn Sample Case #3, notice that EWE would not be a valid answer, even though it reaches the target, because there is a way to get there using fewer jumps.\n\nWe leave it to you to determine why it is impossible to reach the target in Sample Case #4.\n\n**Limits**\n\n- $(\\text{X}, \\text{Y}) \\neq (0, 0)$.\n\n**Test set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\text{T} \\leqslant 80$.\n- $-4 \\leqslant \\text{X} \\leqslant 4$.\n- $-4 \\leqslant \\text{Y} \\leqslant 4$.\n\n**Test set 2 (8 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\text{T} \\leqslant 100$.\n- $-100 \\leqslant \\text{X} \\leqslant 100$.\n- $-100 \\leqslant \\text{Y} \\leqslant 100$.\n\n**Test set 3 (16 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\text{T} \\leqslant 100$.\n- $-10^{9} \\leqslant \\text{X} \\leqslant 10^{9}$.\n- $-10^{9} \\leqslant \\text{Y} \\leqslant 10^{9}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1B] Expogo", "background": "", "description": "You have just received the best gift ever: an Expogo stick. You can stand on it and use it to make increasingly large jumps.\n\nYou are currently standing on point $(0,0)$ in your infinite two-dimensional backyard, and you are trying to reach a goal point $(\\mathrm{X}, \\mathrm{Y})$, with integer coordinates, in as few jumps as possible. You must land exactly on the goal point; it is not sufficient to pass over it on a jump.\n\nEach time you use your Expogo stick to jump, you pick a cardinal direction: north, south, east, or west. The $i$-th jump with your Expogo stick moves you $2^{(i-1)}$ units in the chosen direction, so your first jump takes you 1 unit, your second jump takes you 2 units, your third jump takes you 4 units, and so on.\n\nGiven a goal point $(\\mathrm{X}, \\mathrm{Y})$, determine whether it is possible to get there, and if so, demonstrate how to do it using as few jumps as possible.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each consists of a single line with two integers $\\mathrm{X}$ and $\\mathrm{Y}$ : the coordinates of the goal point.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if the goal point cannot be reached. Otherwise, $y$ must be a string of one or more characters, each of which is either $\\mathrm{N}$ (north), $\\mathrm{S}$ (south), $\\mathrm{E}$ (east), or $\\mathrm{W}$ (west), representing the directions of the jumps that you will make, in order. This sequence of jumps must reach the goal point at the end of the final jump, and it must be as short as possible.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you can jump south from $(0, 0)$ to $(0, -1)$, then jump east to $(2, -1)$, then jump north to $(2, 3)$.\n\nWe can be sure there is not a more efficient solution (two moves or fewer) because at least $2 + 3 = 5$ units of distance are needed to reach the goal point, but the first two jumps combined only give us $3$ units of distance.\n\nNotice that Sample Case #2 is like Sample Case #1 but reflected across both axes, and so the answer comes from reflecting all directions in Sample Case #1's answer.\n\nIn Sample Case #3, notice that EWE would not be a valid answer, even though it reaches the target, because there is a way to get there using fewer jumps.\n\nWe leave it to you to determine why it is impossible to reach the target in Sample Case #4.\n\n**Limits**\n\n- $(\\text{X}, \\text{Y}) \\neq (0, 0)$.\n\n**Test set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\text{T} \\leqslant 80$.\n- $-4 \\leqslant \\text{X} \\leqslant 4$.\n- $-4 \\leqslant \\text{Y} \\leqslant 4$.\n\n**Test set 2 (8 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\text{T} \\leqslant 100$.\n- $-100 \\leqslant \\text{X} \\leqslant 100$.\n- $-100 \\leqslant \\text{Y} \\leqslant 100$.\n\n**Test set 3 (16 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\text{T} \\leqslant 100$.\n- $-10^{9} \\leqslant \\text{X} \\leqslant 10^{9}$.\n- $-10^{9} \\leqslant \\text{Y} \\leqslant 10^{9}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1B] Expogo", "background": "", "description": "你刚刚收到了有史以来最棒的礼物：一根 **Expogo** 跳跃棒。你可以站在上面，用它进行越来越大的跳跃。\n\n你目前站在无限大的二维后院中的点 $(0, 0)$ 处，并试图以尽可能少的跳跃次数到达目标点 $(\\mathrm{X}, \\mathrm{Y})$（坐标为整数）。你必须恰好落在目标点上，仅从上方经过是不够的。\n\n每次使用 **Expogo** 跳跃棒跳跃时，你需要选择一个基本方向：北（north）、南（south）、东（east）或西（west）。第 $i$ 次跳跃会将你移动 $2^{(i-1)}$ 个单位，因此第一次跳跃移动 1 个单位，第二次跳跃移动 2 个单位，第三次跳跃移动 4 个单位，以此类推。\n\n给定目标点 $(\\mathrm{X}, \\mathrm{Y})$，判断是否可以到达该点。如果可以，请展示如何以最少的跳跃次数实现。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathrm{T}$。接下来是 $\\mathrm{T}$ 个测试用例，每个测试用例占一行，包含两个整数 $\\mathrm{X}$ 和 $\\mathrm{Y}$，表示目标点的坐标。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 **IMPOSSIBLE**（如果无法到达目标点）。否则，$y$ 应为一个由若干字符组成的字符串，每个字符为 $\\mathrm{N}$（北）、$\\mathrm{S}$（南）、$\\mathrm{E}$（东）或 $\\mathrm{W}$（西），表示按顺序跳跃的方向。此跳跃序列必须在最后一次跳跃结束时到达目标点，且必须是最短的可能序列。\n", "hint": "**样例解释**\n\n在样例 #1 中，你可以从 $(0, 0)$ 向南跳到 $(0, -1)$，然后向东跳到 $(2, -1)$，最后向北跳到 $(2, 3)$。\n\n我们可以确定没有更高效的解决方案（两次或更少跳跃），因为到达目标点至少需要 $2 + 3 = 5$ 个单位的距离，而前两次跳跃总共只能提供 $3$ 个单位的距离。\n\n注意，样例 #2 是样例 #1 关于两个坐标轴的镜像，因此答案也是样例 #1 答案中所有方向的镜像。\n\n在样例 #3 中，注意 **EWE** 不是一个有效答案，尽管它能到达目标点，因为存在使用更少跳跃次数的方案。\n\n我们留给你思考为什么在样例 #4 中无法到达目标点。\n\n**数据范围**\n\n- $(\\text{X}, \\text{Y}) \\neq (0, 0)$。\n\n**测试集 1（5 分，可见判定）**\n\n- $1 \\leqslant \\text{T} \\leqslant 80$。\n- $-4 \\leqslant \\text{X} \\leqslant 4$。\n- $-4 \\leqslant \\text{Y} \\leqslant 4$。\n\n**测试集 2（8 分，可见判定）**\n\n- $1 \\leqslant \\text{T} \\leqslant 100$。\n- $-100 \\leqslant \\text{X} \\leqslant 100$。\n- $-100 \\leqslant \\text{Y} \\leqslant 100$。\n\n**测试集 3（16 分，可见判定）**\n\n- $1 \\leqslant \\text{T} \\leqslant 100$。\n- $-10^{9} \\leqslant \\text{X} \\leqslant 10^{9}$。\n- $-10^{9} \\leqslant \\text{Y} \\leqslant 10^{9}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13057", "type": "P", "difficulty": 5, "samples": [["", ""]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["计算几何", "2020", "二分", "交互题", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2020 #1B] Blindfolded Bullseye", "background": "", "description": "Gary has a large square wall that is exactly $2 \\times 10^{9}$ nanometers tall and $2 \\times 10^{9}$ nanometers wide. Gary has a dartboard placed on the wall. The dartboard is circular and its radius is between A and B nanometers, inclusive. The dartboard is fully contained within the wall, but it may touch its edges. The center of the dartboard is an integer number of nanometers from each edge of the wall.\n\nGary invited his friend Mika over to play an interesting game. Gary blindfolds Mika and challenges her to throw a dart at the center of the dartboard. To help her, whenever Mika throws a dart at the wall, Gary will tell her whether the dart hit the dartboard.\n\nMika does not know where on the wall the dartboard is, but since Mika is very skilled at darts, she can throw darts with nanometer precision. That is, she can aim and hit exactly any point that is an integer number of nanometers away from each edge of the wall. Immediately after throwing each dart, Gary tells her whether she hit the center of the dartboard, some other part of it, or missed it completely and hit the bare wall.\n\nCan you help Mika hit the center of the dartboard, without throwing more than 300 darts?\n\n### Interactive Protocol\n\nInitially, your program should read a single line containing three integers $\\mathbf{T}$, $\\mathbf{A}$ and $\\mathbf{B}$, indicating the number of test cases and the inclusive minimum and maximum values for the dartboard's radius, in nanometers, respectively. (Notice that $\\mathbf{A}$ and $\\mathbf{B}$ are the same for every test case within a test set.) Then, you need to process $\\mathbf{T}$ test cases.\n\nWe represent the points that darts can be aimed at as pairs $(x, y)$, where $x$ and $y$ are integers between $-10^{9}$ and $10^{9}$, inclusive. The pair $(x, y)$ is the point that is $x + 10^{9}$ nanometers away from the left edge of the wall and $y + 10^{9}$ nanometers away from the bottom edge of the wall. Point $(0, 0)$ is therefore at the exact center of the wall.\n\nFor each test case, there is a secretly chosen radius $R$ for the dartboard, and a secretly chosen center of the dartboard $(X, Y)$. $R$, $X$, and $Y$ are integers chosen for each test case by the judges in a designed (not random) way, within the limits. For each test case you need to process up to 300 exchanges with the judge. Your program represents Mika and the judge program represents Gary. Each exchange consists of Mika (your program) choosing where to throw a dart and Gary (the judging program) giving information about that position.\n\nThe $i$-th exchange consists of your program first outputting a single line containing two integers $X_{i}$ and $Y_{i}$, both between $-10^{9}$ and $10^{9}$, inclusive, and the judge responding with a single line containing either:\n\n* `CENTER` if $X_{i} = X$ and $Y_{i} = Y$\n* `HIT` if $0 < (X - X_{i})^{2} + (Y - Y_{i})^{2} \\leq R^{2}$\n* `MISS` in all other cases.\n\nAfter sending CENTER, the judge will start waiting for the first exchange of the next test case, if there is any.\n\nIf you output a line that is incorrectly formatted or with an out of bounds value, the judge will respond with a single line containing WRONG. If 300 exchanges occur (including 300 responses from the judge) without you receiving CENTER, or if you ever receive WRONG, the judge will finish all communication, wait for your own program to also finish, and give a Wrong Answer verdict. After sending the $T$-th CENTER, on the other hand, the judge will finish all communication, wait for your own program to finish, and give a Correct verdict. If, while waiting for your program to finish, time or memory limits are exceeded, the corresponding verdict will be assigned instead. (Note that verdicts are not messages sent to your program.)", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nThe following sample interaction uses the limits of Test Set 1.\n\n```\n  // The following reads 20 into t and 999999995 into a and b.\n  t, a, b = readline_int_list()\n  // The judge secretly picks R = 999999995 (it had no choice) and X = -1,\n  // Y = 3 (it did have a choice here). (Note: the actual Test Set 1 will\n  // not necessarily use the values in this example.)\n  // We try to throw at the upper left corner of the wall, and the dartboard\n  // does not overlap with that point.\n  printline -1000000000 1000000000 to stdout\n  flush stdout\n  r = readline_string()  // reads MISS.\n  // We try to throw at the center of the wall. That does hit the dartboard,\n  // but not the center.\n  printline 0 0 to stdout\n  flush stdout\n  r = readline_string()  // reads HIT.\n  // We make a super lucky choice and throw at the center of the dartboard.\n  printline -1 3 to stdout\n  flush stdout\n  r = readline_string()  // reads CENTER.\n  // The judge begins the next test case. It secretly picks R = 999999995\n  // and X = 5, Y = 5.\n  // We accidentally throw a dart out of the allowed range.\n  printline -1234567890 1234567890 to stdout\n  flush stdout\n  r = readline_string()  // reads WRONG.\n  exit  // exits to avoid an ambiguous TLE error.\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 20$.\n- $\\mathbf{A} \\leqslant \\mathbf{R} \\leqslant \\mathbf{B}$.\n- $-10^{9} + \\mathbf{R} \\leqslant \\mathbf{X} \\leqslant 10^{9} - \\mathbf{R}$.\n- $-10^{9} + \\mathbf{R} \\leqslant \\mathbf{Y} \\leqslant 10^{9} - \\mathbf{R}$.\n\n**Test set 1 (3 Pts, Visible Verdict)**\n\n- $\\mathbf{A} = \\mathbf{B} = 10^{9} - 5$.\n\n**Test set 2 (12 Pts, Visible Verdict)**\n\n- $\\mathbf{A} = \\mathbf{B} = 10^{9} - 50$.\n\n**Test set 3 (19 Pts, Hidden Verdict)**\n\n- $\\mathbf{A} = 10^{9} / 2$.\n- $\\mathbf{B} = 10^{9}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1B] Blindfolded Bullseye", "background": "", "description": "Gary has a large square wall that is exactly $2 \\times 10^{9}$ nanometers tall and $2 \\times 10^{9}$ nanometers wide. Gary has a dartboard placed on the wall. The dartboard is circular and its radius is between A and B nanometers, inclusive. The dartboard is fully contained within the wall, but it may touch its edges. The center of the dartboard is an integer number of nanometers from each edge of the wall.\n\nGary invited his friend Mika over to play an interesting game. Gary blindfolds Mika and challenges her to throw a dart at the center of the dartboard. To help her, whenever Mika throws a dart at the wall, Gary will tell her whether the dart hit the dartboard.\n\nMika does not know where on the wall the dartboard is, but since Mika is very skilled at darts, she can throw darts with nanometer precision. That is, she can aim and hit exactly any point that is an integer number of nanometers away from each edge of the wall. Immediately after throwing each dart, Gary tells her whether she hit the center of the dartboard, some other part of it, or missed it completely and hit the bare wall.\n\nCan you help Mika hit the center of the dartboard, without throwing more than 300 darts?\n\n### Interactive Protocol\n\nInitially, your program should read a single line containing three integers $\\mathbf{T}$, $\\mathbf{A}$ and $\\mathbf{B}$, indicating the number of test cases and the inclusive minimum and maximum values for the dartboard's radius, in nanometers, respectively. (Notice that $\\mathbf{A}$ and $\\mathbf{B}$ are the same for every test case within a test set.) Then, you need to process $\\mathbf{T}$ test cases.\n\nWe represent the points that darts can be aimed at as pairs $(x, y)$, where $x$ and $y$ are integers between $-10^{9}$ and $10^{9}$, inclusive. The pair $(x, y)$ is the point that is $x + 10^{9}$ nanometers away from the left edge of the wall and $y + 10^{9}$ nanometers away from the bottom edge of the wall. Point $(0, 0)$ is therefore at the exact center of the wall.\n\nFor each test case, there is a secretly chosen radius $R$ for the dartboard, and a secretly chosen center of the dartboard $(X, Y)$. $R$, $X$, and $Y$ are integers chosen for each test case by the judges in a designed (not random) way, within the limits. For each test case you need to process up to 300 exchanges with the judge. Your program represents Mika and the judge program represents Gary. Each exchange consists of Mika (your program) choosing where to throw a dart and Gary (the judging program) giving information about that position.\n\nThe $i$-th exchange consists of your program first outputting a single line containing two integers $X_{i}$ and $Y_{i}$, both between $-10^{9}$ and $10^{9}$, inclusive, and the judge responding with a single line containing either:\n\n* `CENTER` if $X_{i} = X$ and $Y_{i} = Y$\n* `HIT` if $0 < (X - X_{i})^{2} + (Y - Y_{i})^{2} \\leq R^{2}$\n* `MISS` in all other cases.\n\nAfter sending CENTER, the judge will start waiting for the first exchange of the next test case, if there is any.\n\nIf you output a line that is incorrectly formatted or with an out of bounds value, the judge will respond with a single line containing WRONG. If 300 exchanges occur (including 300 responses from the judge) without you receiving CENTER, or if you ever receive WRONG, the judge will finish all communication, wait for your own program to also finish, and give a Wrong Answer verdict. After sending the $T$-th CENTER, on the other hand, the judge will finish all communication, wait for your own program to finish, and give a Correct verdict. If, while waiting for your program to finish, time or memory limits are exceeded, the corresponding verdict will be assigned instead. (Note that verdicts are not messages sent to your program.)", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nThe following sample interaction uses the limits of Test Set 1.\n\n```\n  // The following reads 20 into t and 999999995 into a and b.\n  t, a, b = readline_int_list()\n  // The judge secretly picks R = 999999995 (it had no choice) and X = -1,\n  // Y = 3 (it did have a choice here). (Note: the actual Test Set 1 will\n  // not necessarily use the values in this example.)\n  // We try to throw at the upper left corner of the wall, and the dartboard\n  // does not overlap with that point.\n  printline -1000000000 1000000000 to stdout\n  flush stdout\n  r = readline_string()  // reads MISS.\n  // We try to throw at the center of the wall. That does hit the dartboard,\n  // but not the center.\n  printline 0 0 to stdout\n  flush stdout\n  r = readline_string()  // reads HIT.\n  // We make a super lucky choice and throw at the center of the dartboard.\n  printline -1 3 to stdout\n  flush stdout\n  r = readline_string()  // reads CENTER.\n  // The judge begins the next test case. It secretly picks R = 999999995\n  // and X = 5, Y = 5.\n  // We accidentally throw a dart out of the allowed range.\n  printline -1234567890 1234567890 to stdout\n  flush stdout\n  r = readline_string()  // reads WRONG.\n  exit  // exits to avoid an ambiguous TLE error.\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 20$.\n- $\\mathbf{A} \\leqslant \\mathbf{R} \\leqslant \\mathbf{B}$.\n- $-10^{9} + \\mathbf{R} \\leqslant \\mathbf{X} \\leqslant 10^{9} - \\mathbf{R}$.\n- $-10^{9} + \\mathbf{R} \\leqslant \\mathbf{Y} \\leqslant 10^{9} - \\mathbf{R}$.\n\n**Test set 1 (3 Pts, Visible Verdict)**\n\n- $\\mathbf{A} = \\mathbf{B} = 10^{9} - 5$.\n\n**Test set 2 (12 Pts, Visible Verdict)**\n\n- $\\mathbf{A} = \\mathbf{B} = 10^{9} - 50$.\n\n**Test set 3 (19 Pts, Hidden Verdict)**\n\n- $\\mathbf{A} = 10^{9} / 2$.\n- $\\mathbf{B} = 10^{9}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1B] Blindfolded Bullseye", "background": "", "description": "Gary 有一面巨大的正方形墙，高度和宽度均为 $2 \\times 10^{9}$ 纳米。Gary 在墙上放置了一个圆形飞镖靶。飞镖靶的半径 $R$ 介于 $\\mathbf{A}$ 和 $\\mathbf{B}$ 纳米之间（含端点），且完全位于墙内（允许接触边缘）。飞镖靶的中心与墙的每条边的距离均为整数纳米。\n\nGary 邀请了他的朋友 Mika 来玩一个有趣的游戏。Gary 蒙住 Mika 的眼睛，并挑战她向飞镖靶的中心投掷飞镖。为了帮助她，每当 Mika 向墙上投掷飞镖时，Gary 会告诉她飞镖是否击中了飞镖靶。\n\nMika 不知道飞镖靶在墙上的具体位置，但由于她投掷飞镖的技术非常高超，可以精确到纳米级别。也就是说，她可以瞄准并击中墙上任意一个与边缘距离为整数纳米的点。每次投掷后，Gary 会立即告诉她是否击中了飞镖靶的中心、飞镖靶的其他部分，或者完全未击中飞镖靶（即击中墙面）。\n\n你能帮助 Mika 在不超过 300 次投掷的情况下击中飞镖靶的中心吗？\n\n### 交互协议\n\n初始时，你的程序应读取一行，包含三个整数 $\\mathbf{T}$、$\\mathbf{A}$ 和 $\\mathbf{B}$，分别表示测试用例的数量以及飞镖靶半径的最小值和最大值（单位为纳米）。（注意，$\\mathbf{A}$ 和 $\\mathbf{B}$ 在同一测试集中对所有测试用例相同。）然后，你需要处理 $\\mathbf{T}$ 个测试用例。\n\n我们将可投掷的点表示为 $(x, y)$，其中 $x$ 和 $y$ 是介于 $-10^{9}$ 和 $10^{9}$ 之间的整数。点 $(x, y)$ 表示该点距离墙的左边缘 $x + 10^{9}$ 纳米，距离墙的底边缘 $y + 10^{9}$ 纳米。因此，点 $(0, 0)$ 位于墙的正中心。\n\n对于每个测试用例，裁判会秘密选择一个飞镖靶的半径 $R$ 和中心 $(X, Y)$。$R$、$X$ 和 $Y$ 是裁判为每个测试用例设计的整数（非随机），且满足题目限制。对于每个测试用例，你最多可以与裁判进行 300 次交互。你的程序代表 Mika，裁判程序代表 Gary。每次交互包含以下步骤：\n\n1. 你的程序输出一行，包含两个整数 $X_{i}$ 和 $Y_{i}$（均在 $-10^{9}$ 到 $10^{9}$ 之间），表示投掷的坐标。\n2. 裁判会响应一行，内容为以下之一：\n   - `CENTER`：如果 $X_{i} = X$ 且 $Y_{i} = Y$（即击中中心）。\n   - `HIT`：如果 $0 < (X - X_{i})^{2} + (Y - Y_{i})^{2} \\leq R^{2}$（即击中飞镖靶但未击中中心）。\n   - `MISS`：其他情况（未击中飞镖靶）。\n\n当裁判返回 `CENTER` 后，它会开始等待下一个测试用例的交互（如果有）。\n\n如果你的输出格式错误或超出范围，裁判会返回 `WRONG`。如果在 300 次交互内未收到 `CENTER`，或者收到 `WRONG`，裁判会终止通信并判定为错误答案。如果成功在第 $T$ 个测试用例返回 `CENTER`，裁判会终止通信并判定为正确。如果程序超时或内存超限，会相应判定。\n", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "**样例解释**\n\n以下是一个使用测试集 1 限制的样例交互：\n\n```\n// 读取 t = 20, a = 999999995, b = 999999995\nt, a, b = readline_int_list()\n// 裁判秘密选择 R = 999999995 和 X = -1, Y = 3\n// 尝试投掷到墙的左上角，未击中飞镖靶\nprintline -1000000000 1000000000 to stdout\nflush stdout\nr = readline_string() // 返回 MISS\n// 尝试投掷到墙的中心，击中飞镖靶但未击中中心\nprintline 0 0 to stdout\nflush stdout\nr = readline_string() // 返回 HIT\n// 幸运地直接投掷到飞镖靶中心\nprintline -1 3 to stdout\nflush stdout\nr = readline_string() // 返回 CENTER\n// 裁判开始下一个测试用例，选择 R = 999999995, X = 5, Y = 5\n// 尝试投掷超出允许范围\nprintline -1234567890 1234567890 to stdout\nflush stdout\nr = readline_string() // 返回 WRONG\nexit // 退出以避免超时错误\n```\n\n你可以使用[交互测试工具](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)在本地或平台上测试。工具的使用说明包含在注释中。请注意，该工具并非真实裁判系统，行为可能有所不同。\n\n**数据范围**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 20$。\n- $\\mathbf{A} \\leqslant \\mathbf{R} \\leqslant \\mathbf{B}$。\n- $-10^{9} + \\mathbf{R} \\leqslant \\mathbf{X} \\leqslant 10^{9} - \\mathbf{R}$。\n- $-10^{9} + \\mathbf{R} \\leqslant \\mathbf{Y} \\leqslant 10^{9} - \\mathbf{R}$。\n\n**测试集 1（3 分，可见判定）**\n\n- $\\mathbf{A} = \\mathbf{B} = 10^{9} - 5$。\n\n**测试集 2（12 分，可见判定）**\n\n- $\\mathbf{A} = \\mathbf{B} = 10^{9} - 50$。\n\n**测试集 3（19 分，隐藏判定）**\n\n- $\\mathbf{A} = 10^{9} / 2$。\n- $\\mathbf{B} = 10^{9}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13058", "type": "P", "difficulty": 5, "samples": [["3\n2 2\n3 2\n2 3", "Case #1: 1\n2 1\nCase #2: 2\n3 2\n2 1\nCase #3: 2\n2 3\n2 2"]], "limits": {"time": [30000, 30000, 60000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2020", "Special Judge", "Ad-hoc", "Google Code Jam"], "title": "[GCJ 2020 #1B] Join the Ranks\t", "background": "", "description": "You recently acquired a new deck of cards. Each card displays a rank, which is an integer between 1 and $\\mathbf{R}$, and a suit, which is an integer between 1 and $\\mathbf{S}$. For each combination of a rank and a suit, there is exactly one card that displays it, meaning that the deck has $\\mathbf{R} \\times \\mathbf{S}$ cards in total. We will denote a card with rank $r$ and suit $s$ as $(r, s)$.\n\nBeing brand new, the deck is sorted from top to bottom by suit in increasing order, with ties being broken by ranks in increasing order. That is, $(1, 1)$ comes first, then $(2, 1)$, ..., $(\\mathbf{R}, 1)$, then $(1, 2)$, $(2, 2)$, ..., $(\\mathbf{R}, 2)$, and so on up to $(\\mathbf{R}, \\mathbf{S})$. For example, with $\\mathbf{R} = 4$ ranks and $\\mathbf{S} = 2$ suits, the initial ordering would be: $(1, 1)$, $(2, 1)$, $(3, 1)$, $(4, 1)$, $(1, 2)$, $(2, 2)$, $(3, 2)$, $(4, 2)$.\n\nYou want to reorder the deck to be sorted by rank. That is, you want to put all the cards of the same rank together, and have the ranks be in increasing order. You do not care, however, about the order of the suits within each rank. For example, with $\\mathbf{R} = 4$ and $\\mathbf{S} = 2$, one of the various possible valid new orderings would be: $(1, 2)$, $(1, 1)$, $(2, 1)$, $(2, 2)$, $(3, 1)$, $(3, 2)$, $(4, 2)$, $(4, 1)$.\n\nYou have been learning how to cook, so you want to reorder the deck without putting your spatulas down. You decided to sort the deck using only the following multi-part operation:\n\n* First, take one or more cards from the top of the deck, and set that selection aside as pile A.\n* Next, take one or more cards from the new top of the deck, and set that selection aside as pile B.\n* Finally, put pile A on top of the deck, and then put pile B on top of the new deck.\n\nNotice that the operation exchanges the pile A part of the deck and the pile B part of the deck, without affecting any other cards deeper in the deck (if there are any).\n\nContinuing with our $\\mathbf{R} = 4$, $\\mathbf{S} = 2$ example, if your first move is to choose 3 cards from the top for pile A and 2 cards for pile B, then these are the cards you get:\n\n- A: $(1, 1)$, $(2, 1)$, $(3, 1)$,\n- B: $(4, 1)$, $(1, 2)$, and\n- Remainder of deck: $(2, 2)$, $(3, 2)$, $(4, 2)$.\n\nAfter putting A on the deck and then B on top of that, the new deck is ordered like this:\n\n$(4, 1)$, $(1, 2)$, $(1, 1)$, $(2, 1)$, $(3, 1)$, $(2, 2)$, $(3, 2)$, $(4, 2)$.\n\nGiven $\\mathbf{R}$ and $\\mathbf{S}$, find a sequence of operations that reorders the deck to be sorted by rank, as described above, and uses the minimum possible number of operations to do so.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each of these lines describes a single test case with two integers $\\mathbf{R}$ and $\\mathbf{S}$, the number of ranks and suits in the deck, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of operations needed to reorder the deck as explained above. Then, print $y$ more lines containing $a_{i}$ $b_{i}$, meaning that in the $i$-th operation in a sequence of moves that reorders the deck, you take $a_{i}$ cards first to form pile A and then $b_{i}$ cards after that to form pile B.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the initial order is $(1, 1)$, $(2, 1)$, $(1, 2)$, $(2, 2)$. After swapping $A = (1, 1)$, $(2, 1)$ and $B = (1, 2)$ the deck is left as $(1, 2)$, $(1, 1)$, $(2, 1)$, $(2, 2)$, which is sorted by rank as needed. Notice that the suits are in different orders within each rank, which is allowed.\n\nIn Sample Case #2, the initial order is $(1, 1)$, $(2, 1)$, $(3, 1)$, $(1, 2)$, $(2, 2)$, $(3, 2)$. After swapping $A = (1, 1)$, $(2, 1)$, $(3, 1)$ and $B = (1, 2)$, $(2, 2)$ the deck is left as $(1, 2)$, $(2, 2)$, $(1, 1)$, $(2, 1)$, $(3, 1)$, $(3, 2)$. In a second move, we can do $A = (1, 2)$, $(2, 2)$ and $B = (1, 1)$ to get $(1, 1)$, $(1, 2)$, $(2, 2)$, $(2, 1)$, $(3, 1)$, $(3, 2)$.\n\nIn Sample Case #3, another valid solution is $a_{1} = 4$, $b_{1} = 1$ first, and then $a_{2} = 3$ and $b_{2} = 1$.\n\n**Limits**\n\n**Test set 1 (14 Pts, Visible Verdict)**\n\n- Time limit: 30 seconds.\n- $\\mathbf{T} = 12$.\n- $2 \\leq \\mathbf{R} \\leq 5$.\n- $2 \\leq \\mathbf{S} \\leq 7$.\n- $\\mathbf{R} \\times \\mathbf{S} \\leq 14$.\n\n**Test set 2 (23 Pts, Hidden Verdict)**\n\n- Time limit: 60 seconds.\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{R} \\leq 40$.\n- $2 \\leq \\mathbf{S} \\leq 40$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1B] Join the Ranks\t", "background": "", "description": "You recently acquired a new deck of cards. Each card displays a rank, which is an integer between 1 and $\\mathbf{R}$, and a suit, which is an integer between 1 and $\\mathbf{S}$. For each combination of a rank and a suit, there is exactly one card that displays it, meaning that the deck has $\\mathbf{R} \\times \\mathbf{S}$ cards in total. We will denote a card with rank $r$ and suit $s$ as $(r, s)$.\n\nBeing brand new, the deck is sorted from top to bottom by suit in increasing order, with ties being broken by ranks in increasing order. That is, $(1, 1)$ comes first, then $(2, 1)$, ..., $(\\mathbf{R}, 1)$, then $(1, 2)$, $(2, 2)$, ..., $(\\mathbf{R}, 2)$, and so on up to $(\\mathbf{R}, \\mathbf{S})$. For example, with $\\mathbf{R} = 4$ ranks and $\\mathbf{S} = 2$ suits, the initial ordering would be: $(1, 1)$, $(2, 1)$, $(3, 1)$, $(4, 1)$, $(1, 2)$, $(2, 2)$, $(3, 2)$, $(4, 2)$.\n\nYou want to reorder the deck to be sorted by rank. That is, you want to put all the cards of the same rank together, and have the ranks be in increasing order. You do not care, however, about the order of the suits within each rank. For example, with $\\mathbf{R} = 4$ and $\\mathbf{S} = 2$, one of the various possible valid new orderings would be: $(1, 2)$, $(1, 1)$, $(2, 1)$, $(2, 2)$, $(3, 1)$, $(3, 2)$, $(4, 2)$, $(4, 1)$.\n\nYou have been learning how to cook, so you want to reorder the deck without putting your spatulas down. You decided to sort the deck using only the following multi-part operation:\n\n* First, take one or more cards from the top of the deck, and set that selection aside as pile A.\n* Next, take one or more cards from the new top of the deck, and set that selection aside as pile B.\n* Finally, put pile A on top of the deck, and then put pile B on top of the new deck.\n\nNotice that the operation exchanges the pile A part of the deck and the pile B part of the deck, without affecting any other cards deeper in the deck (if there are any).\n\nContinuing with our $\\mathbf{R} = 4$, $\\mathbf{S} = 2$ example, if your first move is to choose 3 cards from the top for pile A and 2 cards for pile B, then these are the cards you get:\n\n- A: $(1, 1)$, $(2, 1)$, $(3, 1)$,\n- B: $(4, 1)$, $(1, 2)$, and\n- Remainder of deck: $(2, 2)$, $(3, 2)$, $(4, 2)$.\n\nAfter putting A on the deck and then B on top of that, the new deck is ordered like this:\n\n$(4, 1)$, $(1, 2)$, $(1, 1)$, $(2, 1)$, $(3, 1)$, $(2, 2)$, $(3, 2)$, $(4, 2)$.\n\nGiven $\\mathbf{R}$ and $\\mathbf{S}$, find a sequence of operations that reorders the deck to be sorted by rank, as described above, and uses the minimum possible number of operations to do so.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each of these lines describes a single test case with two integers $\\mathbf{R}$ and $\\mathbf{S}$, the number of ranks and suits in the deck, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of operations needed to reorder the deck as explained above. Then, print $y$ more lines containing $a_{i}$ $b_{i}$, meaning that in the $i$-th operation in a sequence of moves that reorders the deck, you take $a_{i}$ cards first to form pile A and then $b_{i}$ cards after that to form pile B.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the initial order is $(1, 1)$, $(2, 1)$, $(1, 2)$, $(2, 2)$. After swapping $A = (1, 1)$, $(2, 1)$ and $B = (1, 2)$ the deck is left as $(1, 2)$, $(1, 1)$, $(2, 1)$, $(2, 2)$, which is sorted by rank as needed. Notice that the suits are in different orders within each rank, which is allowed.\n\nIn Sample Case #2, the initial order is $(1, 1)$, $(2, 1)$, $(3, 1)$, $(1, 2)$, $(2, 2)$, $(3, 2)$. After swapping $A = (1, 1)$, $(2, 1)$, $(3, 1)$ and $B = (1, 2)$, $(2, 2)$ the deck is left as $(1, 2)$, $(2, 2)$, $(1, 1)$, $(2, 1)$, $(3, 1)$, $(3, 2)$. In a second move, we can do $A = (1, 2)$, $(2, 2)$ and $B = (1, 1)$ to get $(1, 1)$, $(1, 2)$, $(2, 2)$, $(2, 1)$, $(3, 1)$, $(3, 2)$.\n\nIn Sample Case #3, another valid solution is $a_{1} = 4$, $b_{1} = 1$ first, and then $a_{2} = 3$ and $b_{2} = 1$.\n\n**Limits**\n\n**Test set 1 (14 Pts, Visible Verdict)**\n\n- Time limit: 30 seconds.\n- $\\mathbf{T} = 12$.\n- $2 \\leq \\mathbf{R} \\leq 5$.\n- $2 \\leq \\mathbf{S} \\leq 7$.\n- $\\mathbf{R} \\times \\mathbf{S} \\leq 14$.\n\n**Test set 2 (23 Pts, Hidden Verdict)**\n\n- Time limit: 60 seconds.\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{R} \\leq 40$.\n- $2 \\leq \\mathbf{S} \\leq 40$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1B] Join the Ranks", "background": "", "description": "你最近获得了一副新卡牌。每张卡牌显示一个**点数**（介于 1 和 $\\mathbf{R}$ 之间的整数）和一个**花色**（介于 1 和 $\\mathbf{S}$ 之间的整数）。对于每个点数和花色的组合，恰好有一张对应的卡牌，这意味着这副牌共有 $\\mathbf{R} \\times \\mathbf{S}$ 张。我们将点数为 $r$、花色为 $s$ 的卡牌记为 $(r, s)$。\n\n由于是全新的牌组，初始时卡牌按花色从小到大排序，相同花色时按点数从小到大排序。也就是说，$(1, 1)$ 在最上面，接着是 $(2, 1)$，……，$(\\mathbf{R}, 1)$，然后是 $(1, 2)$，$(2, 2)$，……，$(\\mathbf{R}, 2)$，依此类推直到 $(\\mathbf{R}, \\mathbf{S})$。例如，$\\mathbf{R} = 4$ 点、$\\mathbf{S} = 2$ 花色时，初始顺序为：$(1, 1)$，$(2, 1)$，$(3, 1)$，$(4, 1)$，$(1, 2)$，$(2, 2)$，$(3, 2)$，$(4, 2)$。\n\n你希望重新排列牌组，使其按点数排序。也就是说，你想将所有相同点数的卡牌放在一起，并按点数升序排列。但你不在乎每个点数内部花色的顺序。例如，$\\mathbf{R} = 4$ 和 $\\mathbf{S} = 2$ 时，一种可能的有效新顺序是：$(1, 2)$，$(1, 1)$，$(2, 1)$，$(2, 2)$，$(3, 1)$，$(3, 2)$，$(4, 2)$，$(4, 1)$。\n\n你最近在学习烹饪，因此希望在不放下锅铲的情况下完成牌组排序。你决定仅使用以下多步操作来排序牌组：\n\n1. 首先，从牌组顶部取一张或多张卡牌，作为堆叠 A。\n2. 接着，从新的牌组顶部再取一张或多张卡牌，作为堆叠 B。\n3. 最后，将堆叠 A 放回牌组顶部，再将堆叠 B 放在新的牌组顶部。\n\n注意，该操作交换了牌组的堆叠 A 部分和堆叠 B 部分，而不会影响更深层的卡牌（如果有的话）。\n\n继续以 $\\mathbf{R} = 4$、$\\mathbf{S} = 2$ 为例，如果第一次操作选择 3 张卡牌作为堆叠 A，2 张作为堆叠 B，则得到：\n\n- A：$(1, 1)$，$(2, 1)$，$(3, 1)$，\n- B：$(4, 1)$，$(1, 2)$，\n- 剩余牌组：$(2, 2)$，$(3, 2)$，$(4, 2)$。\n\n将 A 放回牌组后再放上 B，新的牌组顺序为：\n\n$(4, 1)$，$(1, 2)$，$(1, 1)$，$(2, 1)$，$(3, 1)$，$(2, 2)$，$(3, 2)$，$(4, 2)$。\n\n给定 $\\mathbf{R}$ 和 $\\mathbf{S}$，找到一系列操作，将牌组重新排序为按点数排序（如上所述），并使用尽可能少的操作次数完成。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。接下来的 $\\mathbf{T}$ 行每行描述一个测试用例，包含两个整数 $\\mathbf{R}$ 和 $\\mathbf{S}$，分别表示牌组的点数和花色数量。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是重新排序牌组所需的最少操作次数。然后，输出 $y$ 行，每行包含 $a_{i}$ $b_{i}$，表示在第 $i$ 次操作中，先取 $a_{i}$ 张卡牌作为堆叠 A，再取 $b_{i}$ 张卡牌作为堆叠 B。\n", "hint": "**样例解释**\n\n在样例 #1 中，初始顺序为 $(1, 1)$，$(2, 1)$，$(1, 2)$，$(2, 2)$。交换 $A = (1, 1)$，$(2, 1)$ 和 $B = (1, 2)$ 后，牌组变为 $(1, 2)$，$(1, 1)$，$(2, 1)$，$(2, 2)$，满足按点数排序的要求。注意，每个点数内部的花色顺序可以不同，这是允许的。\n\n在样例 #2 中，初始顺序为 $(1, 1)$，$(2, 1)$，$(3, 1)$，$(1, 2)$，$(2, 2)$，$(3, 2)$。第一次操作交换 $A = (1, 1)$，$(2, 1)$，$(3, 1)$ 和 $B = (1, 2)$，$(2, 2)$ 后，牌组变为 $(1, 2)$，$(2, 2)$，$(1, 1)$，$(2, 1)$，$(3, 1)$，$(3, 2)$。第二次操作交换 $A = (1, 2)$，$(2, 2)$ 和 $B = (1, 1)$ 后，牌组变为 $(1, 1)$，$(1, 2)$，$(2, 2)$，$(2, 1)$，$(3, 1)$，$(3, 2)$。\n\n在样例 #3 中，另一种有效解法是第一次操作 $a_{1} = 4$，$b_{1} = 1$，第二次操作 $a_{2} = 3$，$b_{2} = 1$。\n\n**数据范围**\n\n**测试集 1（14 分，可见判定）**\n\n- 时间限制：30 秒。\n- $\\mathbf{T} = 12$。\n- $2 \\leq \\mathbf{R} \\leq 5$。\n- $2 \\leq \\mathbf{S} \\leq 7$。\n- $\\mathbf{R} \\times \\mathbf{S} \\leq 14$。\n\n**测试集 2（23 分，隐藏判定）**\n\n- 时间限制：60 秒。\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{R} \\leq 40$。\n- $2 \\leq \\mathbf{S} \\leq 40$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13059", "type": "P", "difficulty": 2, "samples": [["5\n4 4 SSSS\n3 0 SNSS\n2 10 NSNNSN\n0 1 S\n2 7 SSSSSSSS", "Case #1: 4\nCase #2: IMPOSSIBLE\nCase #3: IMPOSSIBLE\nCase #4: 1\nCase #5: 5"]], "limits": {"time": [20000, 20000, 20000, 20000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["字符串", "2020", "Google Code Jam"], "title": "[GCJ 2020 #1C] Overexcited Fan", "background": "", "description": "Today will be the day—today will be the day that you finally get a picture with Peppurr the cat!\n\nIt has just been announced that Peppurr will be touring your city. The city has infinitely many infinitely-long streets running north-south and infinitely many infinitely-long streets running east-west. An intersection is any point at which a north-south street and an east-west street meet. From any given intersection, the closest intersection in each of the four directions (north, east, south and west) is exactly one block away.\n\nYou know the exact path that Peppurr's tour will take along those streets. Your goal is to be at one of the intersections on Peppurr's tour at the same time that Peppurr is there, and you want to do so as fast as possible. This is how you will get your picture with Peppurr!\n\nPeppurr's tour starts at an intersection that is $\\mathbf{X}$ blocks east and $\\mathbf{Y}$ blocks north of the intersection where you are currently located. Both you and Peppurr take exactly one minute to walk one full block, and must finish each minute at an intersection; neither of you can walk partial blocks.\n\nPeppurr moves along a predefined path. Every minute, you can choose to stand still for the minute, or use it to walk a single block in any of the 4 directions (north, east, south or west). Both you and Peppurr only walk along the streets.\n\nIf you and Peppurr are at the same intersection at the same time, you can take a picture, even at the last intersection of the tour. However, Peppurr is unavailable for pictures after the tour ends, so arriving at the tour's final intersection even a single minute after the tour finishes means you will not get a picture.\n\nIs it possible to get a picture with Peppurr? If so, how soon can you do it?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case consists of one line containing two integers, $\\mathbf{X}$ and $\\mathbf{Y}$, and a string of characters $\\mathbf{M}$. This represents that Peppurr's tour starts exactly $\\mathbf{X}$ blocks east and $\\mathbf{Y}$ blocks north of you. The string $\\mathbf{M}$ is the sequence of moves that Peppurr will make. The $i$-th character in $\\mathbf{M}$ is one of $\\mathbf{N}$, $\\mathbf{E}$, $\\mathbf{S}$ or $\\mathbf{W}$, and corresponds to the direction (north, east, south, or west, respectively) in which Peppurr will walk one block during the tour's $i$-th minute.", "outputFormat": "For each test case, output one line with `Case #x: y`, where $x$ is the test case number (starting from 1). If there is no way to get a picture with Peppurr, $y$ is $\\text{IMPOSSIBLE}$. Otherwise, $y$ is the smallest number of minutes from the start of the tour needed to get a picture with Peppurr.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you can walk east four blocks and you will be able to take a picture with Peppurr on the tour's last intersection.\n\nIn Sample Case #2, the tour starts off exactly three blocks to the east of you. No matter how you move, you cannot get a picture with Peppurr.\n\nIn Sample Case #3, the tour is too far north for you to get the picture before the tour ends.\n\nIn Sample Case #4, the tour will come to you after one minute, so you don't even have to move! Enjoy the picture with Peppurr! Remember that you can only take pictures in intersections, so if you moved north while the tour moved south, which would cause you to cross paths with Peppurr outside of an intersection, you could not get your picture in 0.5 minutes.\n\nIn Sample Case #5, you can move north twice, then east twice. Then, you can stay still and you will be able to take a picture with Peppurr in the next minute. There are other paths you can take which can get you a picture with Peppurr in 5 minutes, but none which can do it sooner than that.\n\nThe following two cases could not appear in Test Set 1 or Test Set 2, but could appear in Test Set 3:\n\n```\n2\n3 2 SSSW\n4 0 NESW\n```\n\nThe correct output for these two cases would be:\n\n```\nCase #1: 4\nCase #2: 4\n```\n\nNote that in Case #1, you can take a picture with Peppurr one block to the south and two blocks to the east of your original starting point.\n\nIn Case #2, Peppurr travels in a small square. You can take a picture when Peppurr returns to the starting point of that square.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $(\\mathbf{X}, \\mathbf{Y}) \\neq (0, 0)$. (The tour does not start in the same intersection as you.)\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 10$.\n- $0 \\leqslant \\mathbf{Y} \\leqslant 10$.\n- $1 \\leqslant \\text{length of } \\mathbf{M} \\leqslant 8$.\n- Each character in $\\mathbf{M}$ is an uppercase letter — either $\\mathbf{N}$ or $\\mathbf{s}$.\n\n**Test Set 2 (6 Pts, Visible Verdict)**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 1000$.\n- $0 \\leqslant \\mathbf{Y} \\leqslant 1000$.\n- $1 \\leqslant \\text{length of } \\mathbf{M} \\leqslant 1000$.\n- Each character in $\\mathbf{M}$ is an uppercase letter — either $\\mathbf{N}$ or $\\mathbf{s}$.\n\n**Test Set 3 (12 Pts, Visible Verdict)**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 1000$.\n- $0 \\leqslant \\mathbf{Y} \\leqslant 1000$.\n- $1 \\leqslant \\text{length of } \\mathbf{M} \\leqslant 1000$.\n- Each character in $\\mathbf{M}$ is an uppercase letter — either $\\mathbf{N}$, $\\mathbf{E}$, $\\mathbf{s}$ or $\\mathbf{w}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1C] Overexcited Fan", "background": "", "description": "Today will be the day—today will be the day that you finally get a picture with Peppurr the cat!\n\nIt has just been announced that Peppurr will be touring your city. The city has infinitely many infinitely-long streets running north-south and infinitely many infinitely-long streets running east-west. An intersection is any point at which a north-south street and an east-west street meet. From any given intersection, the closest intersection in each of the four directions (north, east, south and west) is exactly one block away.\n\nYou know the exact path that Peppurr's tour will take along those streets. Your goal is to be at one of the intersections on Peppurr's tour at the same time that Peppurr is there, and you want to do so as fast as possible. This is how you will get your picture with Peppurr!\n\nPeppurr's tour starts at an intersection that is $\\mathbf{X}$ blocks east and $\\mathbf{Y}$ blocks north of the intersection where you are currently located. Both you and Peppurr take exactly one minute to walk one full block, and must finish each minute at an intersection; neither of you can walk partial blocks.\n\nPeppurr moves along a predefined path. Every minute, you can choose to stand still for the minute, or use it to walk a single block in any of the 4 directions (north, east, south or west). Both you and Peppurr only walk along the streets.\n\nIf you and Peppurr are at the same intersection at the same time, you can take a picture, even at the last intersection of the tour. However, Peppurr is unavailable for pictures after the tour ends, so arriving at the tour's final intersection even a single minute after the tour finishes means you will not get a picture.\n\nIs it possible to get a picture with Peppurr? If so, how soon can you do it?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case consists of one line containing two integers, $\\mathbf{X}$ and $\\mathbf{Y}$, and a string of characters $\\mathbf{M}$. This represents that Peppurr's tour starts exactly $\\mathbf{X}$ blocks east and $\\mathbf{Y}$ blocks north of you. The string $\\mathbf{M}$ is the sequence of moves that Peppurr will make. The $i$-th character in $\\mathbf{M}$ is one of $\\mathbf{N}$, $\\mathbf{E}$, $\\mathbf{S}$ or $\\mathbf{W}$, and corresponds to the direction (north, east, south, or west, respectively) in which Peppurr will walk one block during the tour's $i$-th minute.", "outputFormat": "For each test case, output one line with `Case #x: y`, where $x$ is the test case number (starting from 1). If there is no way to get a picture with Peppurr, $y$ is $\\text{IMPOSSIBLE}$. Otherwise, $y$ is the smallest number of minutes from the start of the tour needed to get a picture with Peppurr.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you can walk east four blocks and you will be able to take a picture with Peppurr on the tour's last intersection.\n\nIn Sample Case #2, the tour starts off exactly three blocks to the east of you. No matter how you move, you cannot get a picture with Peppurr.\n\nIn Sample Case #3, the tour is too far north for you to get the picture before the tour ends.\n\nIn Sample Case #4, the tour will come to you after one minute, so you don't even have to move! Enjoy the picture with Peppurr! Remember that you can only take pictures in intersections, so if you moved north while the tour moved south, which would cause you to cross paths with Peppurr outside of an intersection, you could not get your picture in 0.5 minutes.\n\nIn Sample Case #5, you can move north twice, then east twice. Then, you can stay still and you will be able to take a picture with Peppurr in the next minute. There are other paths you can take which can get you a picture with Peppurr in 5 minutes, but none which can do it sooner than that.\n\nThe following two cases could not appear in Test Set 1 or Test Set 2, but could appear in Test Set 3:\n\n```\n2\n3 2 SSSW\n4 0 NESW\n```\n\nThe correct output for these two cases would be:\n\n```\nCase #1: 4\nCase #2: 4\n```\n\nNote that in Case #1, you can take a picture with Peppurr one block to the south and two blocks to the east of your original starting point.\n\nIn Case #2, Peppurr travels in a small square. You can take a picture when Peppurr returns to the starting point of that square.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $(\\mathbf{X}, \\mathbf{Y}) \\neq (0, 0)$. (The tour does not start in the same intersection as you.)\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 10$.\n- $0 \\leqslant \\mathbf{Y} \\leqslant 10$.\n- $1 \\leqslant \\text{length of } \\mathbf{M} \\leqslant 8$.\n- Each character in $\\mathbf{M}$ is an uppercase letter — either $\\mathbf{N}$ or $\\mathbf{s}$.\n\n**Test Set 2 (6 Pts, Visible Verdict)**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 1000$.\n- $0 \\leqslant \\mathbf{Y} \\leqslant 1000$.\n- $1 \\leqslant \\text{length of } \\mathbf{M} \\leqslant 1000$.\n- Each character in $\\mathbf{M}$ is an uppercase letter — either $\\mathbf{N}$ or $\\mathbf{s}$.\n\n**Test Set 3 (12 Pts, Visible Verdict)**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 1000$.\n- $0 \\leqslant \\mathbf{Y} \\leqslant 1000$.\n- $1 \\leqslant \\text{length of } \\mathbf{M} \\leqslant 1000$.\n- Each character in $\\mathbf{M}$ is an uppercase letter — either $\\mathbf{N}$, $\\mathbf{E}$, $\\mathbf{s}$ or $\\mathbf{w}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1C] Overexcited Fan", "background": "", "description": "今天将是你终于能和猫咪 Peppurr 合影的日子！\n\nPeppurr 即将在你的城市巡游。这座城市有无限多条南北走向和东西走向的无限长街道。任意两条垂直街道的交点称为**十字路口**。从任意一个十字路口出发，往四个方向（北、东、南、西）最近的十字路口都恰好相隔一个街区。\n\n你已知 Peppurr 巡游的完整路径。你的目标是**在 Peppurr 到达某个巡游路线的十字路口的同时**，你也到达该路口，并且希望尽可能快地完成这件事。这就是你与 Peppurr 合影的方式！\n\nPeppurr 的巡游起点位于你当前位置以东 $\\mathbf{X}$ 个街区、以北 $\\mathbf{Y}$ 个街区的十字路口。你和 Peppurr 每走完一个完整街区都需要恰好一分钟，且每分钟结束时必须到达一个十字路口；你们都不能走部分街区。\n\nPeppurr 沿着预定路径移动。每分钟，你可以选择**静止不动**，或者选择向四个方向之一（北、东、南、西）移动一个街区。你和 Peppurr 都只沿街道行走。\n\n如果你和 Peppurr **同时到达同一个十字路口**，你就能成功合影（包括巡游的最后一个路口）。但 Peppurr 在巡游结束后不再接受合影，因此即使只晚一分钟到达巡游终点，也无法合影。\n\n你有可能和 Peppurr 合影吗？如果可能，最快需要多少分钟？", "inputFormat": "输入的第一行包含测试用例数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例，每个用例占一行，包含两个整数 $\\mathbf{X}$、$\\mathbf{Y}$ 和一个字符串 $\\mathbf{M}$。表示 Peppurr 的巡游起点位于你当前位置以东 $\\mathbf{X}$ 个街区、以北 $\\mathbf{Y}$ 个街区的十字路口。字符串 $\\mathbf{M}$ 是 Peppurr 的移动序列，其中第 $i$ 个字符为 $\\mathbf{N}$（北）、$\\mathbf{E}$（东）、$\\mathbf{S}$（南）或 $\\mathbf{W}$（西），对应巡游第 $i$ 分钟 Peppurr 移动的方向。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始）。如果无法与 Peppurr 合影，$y$ 为 `IMPOSSIBLE`；否则 $y$ 为从巡游开始到成功合影所需的最少分钟数。", "hint": "**样例解释**\n\n在样例 #1 中，你可以向东走 4 个街区，在巡游的最后一个十字路口与 Peppurr 合影。\n\n在样例 #2 中，巡游起点位于你以东 3 个街区。无论如何移动，你都无法与 Peppurr 合影。\n\n在样例 #3 中，巡游路线距离你太远，无法在巡游结束前合影。\n\n在样例 #4 中，Peppurr 会在 1 分钟后到达你的位置，因此你甚至不需要移动！注意只能在十字路口合影，如果你向北移动而 Peppurr 向南移动，虽然会在非路口处相遇，但无法在 0.5 分钟时合影。\n\n在样例 #5 中，你可以先向北走 2 次，再向东走 2 次，然后静止不动，下一分钟即可合影。其他路径也可能在 5 分钟时合影，但无法更快。\n\n以下两个样例不会出现在测试集 1 或 2 中，但可能出现在测试集 3：\n\n```\n2\n3 2 SSSW\n4 0 NESW\n```\n\n正确输出应为：\n\n```\nCase #1: 4\nCase #2: 4\n```\n\n注意在样例 #1 中，你可以在起点以南 1 个街区、以东 2 个街区的十字路口与 Peppurr 合影。在样例 #2 中，Peppurr 沿小正方形移动，当其返回起点时即可合影。\n\n**数据范围**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $(\\mathbf{X}, \\mathbf{Y}) \\neq (0, 0)$（巡游起点与你不在同一路口）。\n\n**测试集 1（4 分，可见判定）**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 10$。\n- $0 \\leqslant \\mathbf{Y} \\leqslant 10$。\n- $1 \\leqslant \\mathbf{M} \\text{ 的长度} \\leqslant 8$。\n- $\\mathbf{M}$ 仅包含 $\\mathbf{N}$ 或 $\\mathbf{S}$。\n\n**测试集 2（6 分，可见判定）**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 1000$。\n- $0 \\leqslant \\mathbf{Y} \\leqslant 1000$。\n- $1 \\leqslant \\mathbf{M} \\text{ 的长度} \\leqslant 1000$。\n- $\\mathbf{M}$ 仅包含 $\\mathbf{N}$ 或 $\\mathbf{S}$。\n\n**测试集 3（12 分，可见判定）**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 1000$。\n- $0 \\leqslant \\mathbf{Y} \\leqslant 1000$。\n- $1 \\leqslant \\mathbf{M} \\text{ 的长度} \\leqslant 1000$。\n- $\\mathbf{M}$ 可包含 $\\mathbf{N}$、$\\mathbf{E}$、$\\mathbf{S}$ 或 $\\mathbf{W}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13060", "type": "P", "difficulty": 4, "samples": [["", ""]], "limits": {"time": [20000, 20000, 20000, 20000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2020", "概率论", "Google Code Jam"], "title": "[GCJ 2020 #1C] Overrandomized", "background": "", "description": "Note: Every time this statement says something is randomly chosen, it means \"chosen uniformly at random across all valid possibilities, and independently from all other choices\".\n\nThe company Banana Rocks Inc. just wrote a premium cloud-based random number generation service that is destined to be the new gold standard of randomness.\n\nThe original design was that a group of servers would receive a request in the form of a single positive integer M of up to $\\mathbf{U}$ decimal digits and then respond with an integer from the range 1 through M, inclusive, chosen at random. However, instead of simply having the output written with digits 0 through 9 as usual, the servers were \"overrandomized\". Each server has a random subset of 10 distinct uppercase English letters to use as digits, and a random mapping from those letters to unique values between 0 and 9.\n\nThe formal description of the current situation is as follows: each server has a digit string D composed of exactly 10 different uppercase English letters. The digit string defines the mapping between letters and the base 10 digits: D's j-th character from the left (counting from 0) is the base 10 digit of value j. For example, if D were CODEJAMFUN then c would represent digit 0, o would represent digit 1 and n would represent digit 9. The number 379009 would be encoded as EFNCCN when using that digit string.\n\nWhen receiving the i-th query with an integer parameter $M_i$, the server:\n\n* chooses an integer $N_i$ at random from the inclusive range 1 through $M_i$,\n* writes it as a base 10 string with no leading zeroes using the j-th character of D (counting starting from 0) as the digit of value j, and\n* returns the resulting string as the response $R_i$.\n\nWe collected some data that we believe we can use to recover the secret digit string D from each server. We sent $10^4$ queries to each server. For each query, we chose a value $M_i$ at random from the range 1 through $10^{\\mathbf{U}} - 1$, inclusive, and received the response $R_i$, a string of up to $\\mathbf{U}$ uppercase English letters. We recorded the pairs $(M_i, R_i)$. As we were moving these records to a new data storage device, the values of all the integers $M_i$ within the records of some servers became corrupted and unreadable.\n\nCan you help us find each server's digit string D?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case contains the records for one server and starts with a line containing a single integer $\\mathbf{U}$, representing that $10^{\\mathbf{U}} - 1$ is the inclusive upper bound for the range in which we chose the integers $M_i$ to query that server. Then, exactly $10^4$ lines follow. Each of these lines contains an integer $\\mathbf{Q}_i$ (in base 10 using digits 0 through 9, as usual) and a string $\\mathbf{R}_i$, representing the i-th query and response, respectively. If $\\mathbf{Q}_i = -1$, then the integer $M_i$ used for the i-th query is unknown. Otherwise, $\\mathbf{Q}_i = M_i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where x is the test case number (starting from 1) and y is the digit string D for the server examined in test case x.", "hint": "**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 10$.\n- $\\mathbf{D}$ is a string of exactly 10 different uppercase English letters, chosen independently and uniformly at random from the set of all such strings.\n- $\\mathbf{M}_i$ is chosen independently and uniformly at random from the range 1 through $10^{\\mathbf{U}} - 1$, inclusive, for all i.\n- $\\mathbf{N}_i$ is chosen independently and uniformly at random from the range 1 through $\\mathbf{M}_i$, inclusive, for all i.\n- $\\mathbf{R}_i$ is the base 10 representation of $\\mathbf{N}_i$, using the j-th digit from the left of $\\mathbf{D}$ (counting starting from 0) as the digit of value j, for all i.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $\\mathbf{Q}_i = \\mathbf{M}_i$, for all i.\n- $\\mathbf{U} = 2$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $\\mathbf{Q}_i = \\mathbf{M}_i$, for all i.\n- $\\mathbf{U} = 16$.\n\n**Test Set 3 (17 Pts, Visible Verdict)**\n\n- $\\mathbf{Q}_i = -1$, for all i.\n- $\\mathbf{U} = 16$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1C] Overrandomized", "background": "", "description": "Note: Every time this statement says something is randomly chosen, it means \"chosen uniformly at random across all valid possibilities, and independently from all other choices\".\n\nThe company Banana Rocks Inc. just wrote a premium cloud-based random number generation service that is destined to be the new gold standard of randomness.\n\nThe original design was that a group of servers would receive a request in the form of a single positive integer M of up to $\\mathbf{U}$ decimal digits and then respond with an integer from the range 1 through M, inclusive, chosen at random. However, instead of simply having the output written with digits 0 through 9 as usual, the servers were \"overrandomized\". Each server has a random subset of 10 distinct uppercase English letters to use as digits, and a random mapping from those letters to unique values between 0 and 9.\n\nThe formal description of the current situation is as follows: each server has a digit string D composed of exactly 10 different uppercase English letters. The digit string defines the mapping between letters and the base 10 digits: D's j-th character from the left (counting from 0) is the base 10 digit of value j. For example, if D were CODEJAMFUN then c would represent digit 0, o would represent digit 1 and n would represent digit 9. The number 379009 would be encoded as EFNCCN when using that digit string.\n\nWhen receiving the i-th query with an integer parameter $M_i$, the server:\n\n* chooses an integer $N_i$ at random from the inclusive range 1 through $M_i$,\n* writes it as a base 10 string with no leading zeroes using the j-th character of D (counting starting from 0) as the digit of value j, and\n* returns the resulting string as the response $R_i$.\n\nWe collected some data that we believe we can use to recover the secret digit string D from each server. We sent $10^4$ queries to each server. For each query, we chose a value $M_i$ at random from the range 1 through $10^{\\mathbf{U}} - 1$, inclusive, and received the response $R_i$, a string of up to $\\mathbf{U}$ uppercase English letters. We recorded the pairs $(M_i, R_i)$. As we were moving these records to a new data storage device, the values of all the integers $M_i$ within the records of some servers became corrupted and unreadable.\n\nCan you help us find each server's digit string D?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case contains the records for one server and starts with a line containing a single integer $\\mathbf{U}$, representing that $10^{\\mathbf{U}} - 1$ is the inclusive upper bound for the range in which we chose the integers $M_i$ to query that server. Then, exactly $10^4$ lines follow. Each of these lines contains an integer $\\mathbf{Q}_i$ (in base 10 using digits 0 through 9, as usual) and a string $\\mathbf{R}_i$, representing the i-th query and response, respectively. If $\\mathbf{Q}_i = -1$, then the integer $M_i$ used for the i-th query is unknown. Otherwise, $\\mathbf{Q}_i = M_i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where x is the test case number (starting from 1) and y is the digit string D for the server examined in test case x.", "hint": "**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 10$.\n- $\\mathbf{D}$ is a string of exactly 10 different uppercase English letters, chosen independently and uniformly at random from the set of all such strings.\n- $\\mathbf{M}_i$ is chosen independently and uniformly at random from the range 1 through $10^{\\mathbf{U}} - 1$, inclusive, for all i.\n- $\\mathbf{N}_i$ is chosen independently and uniformly at random from the range 1 through $\\mathbf{M}_i$, inclusive, for all i.\n- $\\mathbf{R}_i$ is the base 10 representation of $\\mathbf{N}_i$, using the j-th digit from the left of $\\mathbf{D}$ (counting starting from 0) as the digit of value j, for all i.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $\\mathbf{Q}_i = \\mathbf{M}_i$, for all i.\n- $\\mathbf{U} = 2$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $\\mathbf{Q}_i = \\mathbf{M}_i$, for all i.\n- $\\mathbf{U} = 16$.\n\n**Test Set 3 (17 Pts, Visible Verdict)**\n\n- $\\mathbf{Q}_i = -1$, for all i.\n- $\\mathbf{U} = 16$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1C] Overrandomized", "background": "", "description": "**注意**：每当题目描述中提到\"随机选择\"时，均表示\"在所有有效可能性中均匀随机且独立地选择\"。\n\nBanana Rocks 公司开发了一款基于云计算的优质随机数生成服务，旨在成为随机性领域的新黄金标准。\n\n最初的设计是：一组服务器接收一个最多包含 $\\mathbf{U}$ 位十进制数字的正整数 $\\mathbf{M}$ 作为请求，然后返回一个在 1 到 $\\mathbf{M}$ 之间（含端点）随机选择的整数。然而，这些服务器被\"过度随机化\"了——它们没有使用常规的 0-9 数字输出结果，而是每个服务器都随机选取了 10 个不同的大写英文字母作为数字，并随机将这些字母映射到 0-9 的唯一值。\n\n当前情况的正式描述如下：\n- 每个服务器有一个由恰好 10 个不同大写字母组成的**数字字符串 $\\mathbf{D}$**\n- 该字符串定义了字母与十进制数字的映射关系：$\\mathbf{D}$ 中从左数第 $j$ 个字符（从 0 开始计数）代表数值为 $j$ 的数字\n- 例如，若 $\\mathbf{D}$ 为 `CODEJAMFUN`，则 `C` 代表数字 0，`O` 代表数字 1，`N` 代表数字 9。数字 379009 将被编码为 `EFNCCN`\n\n当服务器收到第 $i$ 个参数为 $M_i$ 的查询时，会：\n1. 从 1 到 $M_i$ 的范围内随机选择一个整数 $N_i$\n2. 使用 $\\mathbf{D}$ 中的字母数字表示法将其转换为无前导零的十进制字符串\n3. 返回结果字符串 $R_i$ 作为响应\n\n我们收集了一些数据，认为可以用来恢复每个服务器的秘密数字字符串 $\\mathbf{D}$。我们向每个服务器发送了 $10^4$ 次查询：\n- 每次查询的 $M_i$ 是从 1 到 $10^{\\mathbf{U}}-1$ 范围内随机选择的\n- 收到的响应 $R_i$ 是一个最多包含 $\\mathbf{U}$ 个大写字母的字符串\n- 我们记录了这些 $(M_i, R_i)$ 对\n\n但在将这些记录转移到新存储设备时，部分服务器记录中的所有 $M_i$ 整数值都损坏无法读取了。你能帮我们找出每个服务器的数字字符串 $\\mathbf{D}$ 吗？", "inputFormat": "输入第一行包含测试用例数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例，每个用例包含一个服务器的记录：\n- 第一行是整数 $\\mathbf{U}$，表示查询参数 $M_i$ 的选择范围上限为 $10^{\\mathbf{U}}-1$\n- 接下来是恰好 $10^4$ 行，每行包含一个十进制整数 $\\mathbf{Q}_i$ 和字符串 $\\mathbf{R}_i$\n  - 若 $\\mathbf{Q}_i = -1$，表示该次查询的 $M_i$ 未知\n  - 否则 $\\mathbf{Q}_i = M_i$", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是该服务器对应的数字字符串 $\\mathbf{D}$。\n", "hint": "**数据范围**\n- $1 \\leqslant \\mathbf{T} \\leqslant 10$\n- $\\mathbf{D}$ 是恰好 10 个不同大写字母组成的字符串，从所有可能组合中独立均匀随机选取\n- 对所有 $i$，$M_i$ 从 1 到 $10^{\\mathbf{U}}-1$ 范围内独立均匀随机选取\n- 对所有 $i$，$N_i$ 从 1 到 $M_i$ 范围内独立均匀随机选取\n- 对所有 $i$，$R_i$ 是 $N_i$ 的十进制表示，使用 $\\mathbf{D}$ 中第 $j$ 个字母代表数字 $j$\n\n**测试集 1（9 分，可见判定）**\n- 对所有 $i$，$\\mathbf{Q}_i = M_i$\n- $\\mathbf{U} = 2$\n\n**测试集 2（10 分，可见判定）**\n- 对所有 $i$，$\\mathbf{Q}_i = M_i$\n- $\\mathbf{U} = 16$\n\n**测试集 3（17 分，可见判定）**\n- 对所有 $i$，$\\mathbf{Q}_i = -1$\n- $\\mathbf{U} = 16$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13061", "type": "P", "difficulty": 6, "samples": [["4\n1 3\n1\n5 2\n10 5 359999999999 123456789 10\n2 3\n8 4\n3 2\n1 2 3", "Case #1: 2\nCase #2: 0\nCase #3: 1\nCase #4: 1"]], "limits": {"time": [20000, 20000, 20000, 60000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "贪心", "2020", "Google Code Jam"], "title": "[GCJ 2020 #1C] Oversized Pancake Choppers", "background": "", "description": "You just showed up to your job as the head chef of the Infinite House of Pancakes, and as usual, you found a disaster in progress! The other chefs accidentally created some enormous circular pancakes, all of the same size. These pancakes are too large to serve whole, so they have already started to chop them up into slices (which, in this problem, are circular sectors). You currently have $\\mathbf{N}$ slices, the i-th of which is a sector with an internal (central) angle of $\\mathbf{A}_i$ nanodegrees (a nanodegree is $10^{-9}$ degrees).\n\nYou have $\\mathbf{D}$ diners waiting for their food. Each diner wants a single slice that is the same size as every other diner's slice, although they do not care what that size is. But it may not be possible to do this using the current slices, so you may need to make one or more radial cuts.\n\nA cut changes an existing slice with internal angle $X$ into two new slices with internal angles $Y$ and $X - Y$. You can do this for any $0 < Y < X$, and these values do not need to be integers. You may apply further cuts to either or both of these new slices, and so on.\n\nIt is OK to have one or more leftover slices (of any size) that are not given to the diners; you can eat those later, since this disaster is making you miss your own breakfast!\n\nDetermine the smallest total number of cuts you need to make to satisfy the diners.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line containing two integers $\\mathbf{N}$ and $\\mathbf{D}$: the number of slices you currently have and the number of diners. Then, there is one more line containing $\\mathbf{N}$ integers $\\mathbf{A}_1, \\mathbf{A}_2, ..., \\mathbf{A}_\\mathbf{N}$; the i-th of these represents the internal angle (in nanodegrees) of the i-th slice.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the smallest number of cuts you need, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you only have one tiny slice to start with. The optimal solution is to use one cut to change it into two slices with angles of $1/3$ nanodegree and $2/3$ nanodegrees, and then further cut the latter slice into two more slices with angles of $1/3$ nanodegree.\n\nIn Sample Case #2, you already have two slices of the same size, so you can give those to the two diners, and you do not need to make any cuts.\n\nIn Sample Case #3, the optimal solution is to cut the slice with internal angle 8 nanodegrees in half. After that operation, you have exactly 3 slices of internal angle 4 nanodegrees, with no leftovers.\n\nIn Sample Case #4, remember that every diner must receive a single slice. You cannot give one diner the \"3\" slice and the other diner the \"1\" and \"2\" slices, even though the total areas are the same. You must make at least one cut in this case to satisfy the requirements.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq A_i < 360 \\times 10^9$, for all $i$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $1 \\leq N \\leq 300$.\n- $2 \\leq D \\leq 3$.\n\n**Test Set 2 (16 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $1 \\leq N \\leq 300$.\n- $2 \\leq D \\leq 50$.\n\n**Test Set 3 (16 Pts, Hidden Verdict)**\n\n- Time limit: 60 seconds.\n- For exactly 21 cases, $9000 \\leq N \\leq 10000$.\n- For exactly $T-21$ cases, $1 \\leq N \\leq 1000$.\n- $2 \\leq D \\leq 50$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1C] Oversized Pancake Choppers", "background": "", "description": "You just showed up to your job as the head chef of the Infinite House of Pancakes, and as usual, you found a disaster in progress! The other chefs accidentally created some enormous circular pancakes, all of the same size. These pancakes are too large to serve whole, so they have already started to chop them up into slices (which, in this problem, are circular sectors). You currently have $\\mathbf{N}$ slices, the i-th of which is a sector with an internal (central) angle of $\\mathbf{A}_i$ nanodegrees (a nanodegree is $10^{-9}$ degrees).\n\nYou have $\\mathbf{D}$ diners waiting for their food. Each diner wants a single slice that is the same size as every other diner's slice, although they do not care what that size is. But it may not be possible to do this using the current slices, so you may need to make one or more radial cuts.\n\nA cut changes an existing slice with internal angle $X$ into two new slices with internal angles $Y$ and $X - Y$. You can do this for any $0 < Y < X$, and these values do not need to be integers. You may apply further cuts to either or both of these new slices, and so on.\n\nIt is OK to have one or more leftover slices (of any size) that are not given to the diners; you can eat those later, since this disaster is making you miss your own breakfast!\n\nDetermine the smallest total number of cuts you need to make to satisfy the diners.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line containing two integers $\\mathbf{N}$ and $\\mathbf{D}$: the number of slices you currently have and the number of diners. Then, there is one more line containing $\\mathbf{N}$ integers $\\mathbf{A}_1, \\mathbf{A}_2, ..., \\mathbf{A}_\\mathbf{N}$; the i-th of these represents the internal angle (in nanodegrees) of the i-th slice.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the smallest number of cuts you need, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you only have one tiny slice to start with. The optimal solution is to use one cut to change it into two slices with angles of $1/3$ nanodegree and $2/3$ nanodegrees, and then further cut the latter slice into two more slices with angles of $1/3$ nanodegree.\n\nIn Sample Case #2, you already have two slices of the same size, so you can give those to the two diners, and you do not need to make any cuts.\n\nIn Sample Case #3, the optimal solution is to cut the slice with internal angle 8 nanodegrees in half. After that operation, you have exactly 3 slices of internal angle 4 nanodegrees, with no leftovers.\n\nIn Sample Case #4, remember that every diner must receive a single slice. You cannot give one diner the \"3\" slice and the other diner the \"1\" and \"2\" slices, even though the total areas are the same. You must make at least one cut in this case to satisfy the requirements.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq A_i < 360 \\times 10^9$, for all $i$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $1 \\leq N \\leq 300$.\n- $2 \\leq D \\leq 3$.\n\n**Test Set 2 (16 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $1 \\leq N \\leq 300$.\n- $2 \\leq D \\leq 50$.\n\n**Test Set 3 (16 Pts, Hidden Verdict)**\n\n- Time limit: 60 seconds.\n- For exactly 21 cases, $9000 \\leq N \\leq 10000$.\n- For exactly $T-21$ cases, $1 \\leq N \\leq 1000$.\n- $2 \\leq D \\leq 50$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1C] Oversized Pancake Choppers", "background": "", "description": "当你作为\"无限煎饼屋\"的主厨刚上班时，又一次发现灾难现场！其他厨师不小心做出了一些巨大的圆形煎饼，且所有煎饼大小相同。这些煎饼太大无法整块供应，于是他们已经开始将煎饼切成扇形切片（在本问题中即为圆形扇形）。你现在有 $\\mathbf{N}$ 块切片，其中第 $i$ 块是中心角为 $\\mathbf{A}_i$ 纳度（1 纳度 = $10^{-9}$ 度）的扇形。\n\n现在有 $\\mathbf{D}$ 位顾客等待用餐。每位顾客需要**一块**与其他顾客**大小完全相同**的切片（具体大小不限）。但现有切片可能无法满足需求，因此你可能需要进行若干次径向切割。\n\n一次切割操作可以将一个中心角为 $X$ 的切片分成两个新切片，其中心角分别为 $Y$ 和 $X - Y$。其中 $0 < Y < X$ 且不需要为整数。你可以对这两个新切片继续切割，以此类推。\n\n允许存在任意大小的剩余切片（不供应给顾客）——毕竟这场灾难让你错过了早餐！\n\n请计算满足顾客需求所需的最少切割次数。", "inputFormat": "输入第一行包含测试用例数量 $\\mathbf{T}$。随后每个测试用例包含：\n- 第一行：两个整数 $\\mathbf{N}$（现有切片数）和 $\\mathbf{D}$（顾客数）\n- 第二行：$\\mathbf{N}$ 个整数 $\\mathbf{A}_1, \\mathbf{A}_2, ..., \\mathbf{A}_\\mathbf{N}$，表示每块切片的中心角（纳度）\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为所需的最少切割次数。\n", "hint": "**样例解释**\n\n样例 #1：初始只有 1 块极小切片。最优方案是：\n1. 第一次切割得到 $1/3$ 纳度和 $2/3$ 纳度的切片\n2. 将后者再次切割为两块 $1/3$ 纳度的切片\n最终得到 3 块相同切片，共需 2 次切割。\n\n样例 #2：已有两块相同大小的切片可直接供应，无需切割。\n\n样例 #3：最优方案是将 8 纳度的切片对半切割，得到 3 块 4 纳度的切片且无剩余。\n\n样例 #4：注意每位顾客必须获得**单块**切片。即使 \"1+2\" 和 \"3\" 的总面积相同，也不符合要求。此时至少需要进行 1 次切割。\n\n**数据范围**\n- $1 \\leq T \\leq 100$\n- $1 \\leq A_i < 360 \\times 10^9$（所有 $i$）\n\n**测试集 1（10 分，可见判定）**\n- 时间限制：20 秒\n- $1 \\leq N \\leq 300$\n- $2 \\leq D \\leq 3$\n\n**测试集 2（16 分，可见判定）**\n- 时间限制：20 秒\n- $1 \\leq N \\leq 300$\n- $2 \\leq D \\leq 50$\n\n**测试集 3（16 分，隐藏判定）**\n- 时间限制：60 秒\n- 其中 21 个用例满足 $9000 \\leq N \\leq 10000$\n- 其余 $T-21$ 个用例满足 $1 \\leq N \\leq 1000$\n- $2 \\leq D \\leq 50$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13062", "type": "P", "difficulty": 4, "samples": [["3\n1 2\n2 2\n8 11", "Case #1: 1 1 1\nCase #2: 2 1 0\nCase #3: 5 0 4"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2020", "二分", "Google Code Jam"], "title": "[GCJ 2020 #2] Incremental House of Pancakes", "background": "", "description": "Every morning at The Incremental House of Pancakes, the kitchen staff prepares all of its pancakes for the day and arranges them into two stacks. Initially, the stack on the left has $L$ pancakes, and the stack on the right has $R$ pancakes.\n\nThis restaurant's customers behave very consistently: the i-th customer to arrive (counting starting from 1) always orders $i$ pancakes. When the i-th customer places their order of $i$ pancakes, you take $i$ pancakes from the stack that has the most pancakes remaining (or from the left stack if both have the same amount). If neither stack has at least $i$ pancakes, the restaurant closes and the $i$-th customer does not get served any pancakes. You never complete an order using pancakes from both stacks.\n\nGiven the initial numbers of pancakes in each stack, you want to know how many customers will be served, and how many pancakes will remain in each stack when the restaurant closes.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of a single line containing two integers $L$ and $R$: the initial numbers of pancakes in the left and right stacks, respectively, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: n l r`, where $x$ is the test case number (starting from 1), $n$ is the number of customers who will be served, and $l$ and $r$ are the numbers of pancakes that will remain in the left and right stacks, respectively, when the restaurant closes.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the first customer gets 1 pancake from the right stack, leaving 1 pancake in each stack. The second customer wants 2 pancakes, but neither stack has enough for them, even though there are 2 pancakes in total.\n\nIn Sample Case #2, the first customer gets 1 pancake from the left stack, because both stacks have the same amount. This leaves 1 pancake in the left stack and 2 in the right stack. The second customer wants 2 pancakes, which you serve to them from the right stack, emptying it. When the third customer arrives, neither stack has 3 pancakes, so no more orders are fulfilled.\n\nIn Sample Case #3, the first customer is served from the right stack, leaving 8 pancakes in the left stack and 10 in the right stack. The second customer is also served from the right stack, leaving 8 pancakes in each stack. The third customer is served from the left stack, leaving 5 pancakes there and 8 in the right stack. The fourth customer is then served from the right stack, leaving 4 pancakes there. Serving the fifth customer empties the left stack, and then there are not enough pancakes remaining in either stack to serve a sixth customer.\n\n**Limits**\n\n- $1 \\leq T \\leq 1000$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq L \\leq 1000$.\n- $1 \\leq R \\leq 1000$.\n\n**Test Set 2 (14 Pts, Hidden Verdict)**\n\n- $1 \\leq L \\leq 10^{18}$.\n- $1 \\leq R \\leq 10^{18}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #2] Incremental House of Pancakes", "background": "", "description": "Every morning at The Incremental House of Pancakes, the kitchen staff prepares all of its pancakes for the day and arranges them into two stacks. Initially, the stack on the left has $L$ pancakes, and the stack on the right has $R$ pancakes.\n\nThis restaurant's customers behave very consistently: the i-th customer to arrive (counting starting from 1) always orders $i$ pancakes. When the i-th customer places their order of $i$ pancakes, you take $i$ pancakes from the stack that has the most pancakes remaining (or from the left stack if both have the same amount). If neither stack has at least $i$ pancakes, the restaurant closes and the $i$-th customer does not get served any pancakes. You never complete an order using pancakes from both stacks.\n\nGiven the initial numbers of pancakes in each stack, you want to know how many customers will be served, and how many pancakes will remain in each stack when the restaurant closes.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of a single line containing two integers $L$ and $R$: the initial numbers of pancakes in the left and right stacks, respectively, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: n l r`, where $x$ is the test case number (starting from 1), $n$ is the number of customers who will be served, and $l$ and $r$ are the numbers of pancakes that will remain in the left and right stacks, respectively, when the restaurant closes.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the first customer gets 1 pancake from the right stack, leaving 1 pancake in each stack. The second customer wants 2 pancakes, but neither stack has enough for them, even though there are 2 pancakes in total.\n\nIn Sample Case #2, the first customer gets 1 pancake from the left stack, because both stacks have the same amount. This leaves 1 pancake in the left stack and 2 in the right stack. The second customer wants 2 pancakes, which you serve to them from the right stack, emptying it. When the third customer arrives, neither stack has 3 pancakes, so no more orders are fulfilled.\n\nIn Sample Case #3, the first customer is served from the right stack, leaving 8 pancakes in the left stack and 10 in the right stack. The second customer is also served from the right stack, leaving 8 pancakes in each stack. The third customer is served from the left stack, leaving 5 pancakes there and 8 in the right stack. The fourth customer is then served from the right stack, leaving 4 pancakes there. Serving the fifth customer empties the left stack, and then there are not enough pancakes remaining in either stack to serve a sixth customer.\n\n**Limits**\n\n- $1 \\leq T \\leq 1000$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq L \\leq 1000$.\n- $1 \\leq R \\leq 1000$.\n\n**Test Set 2 (14 Pts, Hidden Verdict)**\n\n- $1 \\leq L \\leq 10^{18}$.\n- $1 \\leq R \\leq 10^{18}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #2] Incremental House of Pancakes", "background": "", "description": "每天早晨，增量煎饼屋的厨房员工会准备好当天所有的煎饼，并将它们分成两堆。初始时，左边的煎饼堆有 $L$ 个煎饼，右边的煎饼堆有 $R$ 个煎饼。\n\n这家餐厅的顾客行为非常一致：第 $i$ 个到达的顾客（从 $1$ 开始计数）总是会点 $i$ 个煎饼。当第 $i$ 个顾客下单 $i$ 个煎饼时，你会从当前煎饼数量较多的那一堆中取出 $i$ 个煎饼（如果两堆煎饼数量相同，则从左边的那一堆中取）。如果两堆煎饼的数量都不足 $i$ 个，餐厅将关闭，且第 $i$ 个顾客不会得到任何煎饼。你**不会**从两堆煎饼中各取一部分来完成一个订单。\n\n给定两堆煎饼的初始数量，你需要计算有多少顾客会被服务，以及餐厅关闭时两堆煎饼的剩余数量。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来是 $T$ 个测试用例。每个测试用例占一行，包含两个整数 $L$ 和 $R$，分别表示左边和右边煎饼堆的初始数量，如上所述。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: n l r`，其中 $x$ 是测试用例编号（从 $1$ 开始），$n$ 是被服务的顾客数量，$l$ 和 $r$ 分别是餐厅关闭时左边和右边煎饼堆的剩余数量。\n", "hint": "**样例解释**\n\n在样例 #1 中，第一个顾客从右边的煎饼堆中取走 $1$ 个煎饼，剩下每堆各有 $1$ 个煎饼。第二个顾客想要 $2$ 个煎饼，但两堆煎饼都不够，尽管总共有 $2$ 个煎饼。\n\n在样例 #2 中，第一个顾客从左边的煎饼堆中取走 $1$ 个煎饼，因为两堆煎饼数量相同。这样左边剩下 $1$ 个煎饼，右边剩下 $2$ 个煎饼。第二个顾客想要 $2$ 个煎饼，你从右边的煎饼堆中取给他，清空了右边的堆。当第三个顾客到来时，两堆煎饼都不足 $3$ 个，因此不再完成订单。\n\n在样例 #3 中，第一个顾客从右边的煎饼堆中取走 $1$ 个煎饼，左边剩下 $8$ 个煎饼，右边剩下 $10$ 个煎饼。第二个顾客也从右边的煎饼堆中取走 $2$ 个煎饼，此时两堆各有 $8$ 个煎饼。第三个顾客从左边的煎饼堆中取走 $3$ 个煎饼，左边剩下 $5$ 个煎饼，右边剩下 $8$ 个煎饼。第四个顾客从右边的煎饼堆中取走 $4$ 个煎饼，右边剩下 $4$ 个煎饼。第五个顾客取走 $5$ 个煎饼后清空了左边的堆，此时两堆煎饼都不足以满足第六个顾客的需求。\n\n**数据范围**\n\n- $1 \\leq T \\leq 1000$。\n\n**测试集 1（5 分，可见评测结果）**\n\n- $1 \\leq L \\leq 1000$。\n- $1 \\leq R \\leq 1000$。\n\n**测试集 2（14 分，隐藏评测结果）**\n\n- $1 \\leq L \\leq 10^{18}$。\n- $1 \\leq R \\leq 10^{18}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13063", "type": "P", "difficulty": 4, "samples": [["3\n4 4\n-1 -3 -2\n1 2\n1 3\n2 4\n3 4\n4 4\n-1 -1 -1\n1 4\n1 2\n1 3\n2 3\n3 2\n-2 -1\n2 3\n1 3", "Case #1: 5 10 1 5\nCase #2: 2020 2020 2020 2020\nCase #3: 1000000 1000000"], ["1\n6 9\n10 -2 -5 15 20\n1 2\n1 3\n2 3\n2 4\n2 5\n3 5\n3 6\n4 5\n5 6", "Case #1: 10 12 4 15 8 3 9 7 5"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2020", "Special Judge", "Google Code Jam"], "title": "[GCJ 2020 #2] Security Update", "background": "", "description": "The Apricot Rules company just installed a critical security update on its network. The network has one source computer, and all other computers in the network are connected to the source computer via a sequence of one or more direct bidirectional connections.\n\nThis kind of update propagates itself: once a computer receives the update for the first time, that computer immediately begins to transmit the update to all of the computers that are directly connected to it. Each of the direct connections has a latency value: the number of seconds needed for that connection to transmit the update (which is the same in either direction). Therefore, the update does not spread to all computers instantly.\n\nThe Apricot Rules engineers do not know any of these latency values, but they know that they are all positive integers. They would like your help in figuring out what these latency values could be, based on how they saw the update spread in a recent experiment.\n\nThe Apricot Rules engineers installed the update only on the source computer and then waited for it to propagate throughout the system until every computer was updated. They recorded some information about how the update spread. Specifically, for every computer $K$ other than the source computer, you know exactly one of two things.\n\n- The exact time in seconds between the time when the source computer received the update and the time when $K$ first received the update.\n- The number of other computers (including the source computer) that first got the update strictly before $K$.\n\nNotice that multiple computers may have received the update at the exact same time.\n\nYou are required to compute a latency in seconds for each of the direct connections between two computers. Each latency value must be a positive integer no greater than $10^6$. The set of latencies that you provide must be consistent with all of the known information. It is guaranteed that there is at least one consistent way to assign latencies.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line containing two integers $C$ and $D$: the number of computers and the number of direct connections, respectively. The computers are numbered from 1 to $C$, with computer 1 being the source computer.\n\nThe next line contains $C-1$ integers $X_2$, $X_3$, $\\dots$, $X_C$. A positive $X_i$ value indicates that computer $i$ received the update $X_i$ seconds after computer 1. A negative $X_i$ value indicates that $-X_i$ other computers received the update strictly before computer $i$; this value includes the source computer.\n\nAfter that, there are $D$ more lines that represent the $D$ direct connections in the network. The $i$-th of these lines contains two integers $U_i$ and $V_i$, indicating that computers $U_i$ and $V_i$ are directly connected to each other.\n", "outputFormat": "For each test case, output one line containing `Case #x: y_1 y_2 ... y_D`, where $x$ is the test case number (starting from 1) and $y_i$ is a positive integer not more than $10^6$ representing the latency, in seconds, assigned to the $i$-th direct connection.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the following picture represents the computer network that is illustrated by the sample output. The $i$-th computer is represented by the circle with the label $i$. A line linking two circles represents a direct connection. The number on each line represents the latency of the direct connection.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uvr9sjli.png)\n\nIn Sample Case #2, the first three connections need to have the same latency, while the fourth can have any valid latency. Note that $-2, 0, 1000001$, and $3.14$ are examples of invalid latencies.\n\nIn Sample Case #3, remember that the connections are bidirectional, and so the update can travel from computer $3$ to computer $2$. Any two valid latency values work here.\n\nSample Test Set 2 could not appear in Test Set 1, but could appear in Test Set 2.\n\nOne of the correct outputs is $10\\ 12\\ 4\\ 15\\ 8\\ 3\\ 9\\ 7\\ 5$, as illustrated by the picture below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x60u5h9g.png)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq C \\leq 100$.\n- $C - 1 \\leq D \\leq 1000$.\n- $1 \\leq U_i < V_i \\leq C$, for all $i$.\n- $(U_i, V_i) \\neq (U_j, V_j)$, for all $i \\neq j$.\n- All computers (except the source computer) are connected to the source computer through a sequence of one or more direct connections.\n- There exists at least one way of assigning latency values that is consistent with the input.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $-C < X_i < 0$, for all $i$. (You get the second type of information for all computers.)\n\n**Test Set 2 (11 Pts, Hidden Verdict)**\n\n- $-C < X_i \\leq 1000$, for all $i$.\n- $X_i \\neq 0$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #2] Security Update", "background": "", "description": "The Apricot Rules company just installed a critical security update on its network. The network has one source computer, and all other computers in the network are connected to the source computer via a sequence of one or more direct bidirectional connections.\n\nThis kind of update propagates itself: once a computer receives the update for the first time, that computer immediately begins to transmit the update to all of the computers that are directly connected to it. Each of the direct connections has a latency value: the number of seconds needed for that connection to transmit the update (which is the same in either direction). Therefore, the update does not spread to all computers instantly.\n\nThe Apricot Rules engineers do not know any of these latency values, but they know that they are all positive integers. They would like your help in figuring out what these latency values could be, based on how they saw the update spread in a recent experiment.\n\nThe Apricot Rules engineers installed the update only on the source computer and then waited for it to propagate throughout the system until every computer was updated. They recorded some information about how the update spread. Specifically, for every computer $K$ other than the source computer, you know exactly one of two things.\n\n- The exact time in seconds between the time when the source computer received the update and the time when $K$ first received the update.\n- The number of other computers (including the source computer) that first got the update strictly before $K$.\n\nNotice that multiple computers may have received the update at the exact same time.\n\nYou are required to compute a latency in seconds for each of the direct connections between two computers. Each latency value must be a positive integer no greater than $10^6$. The set of latencies that you provide must be consistent with all of the known information. It is guaranteed that there is at least one consistent way to assign latencies.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line containing two integers $C$ and $D$: the number of computers and the number of direct connections, respectively. The computers are numbered from 1 to $C$, with computer 1 being the source computer.\n\nThe next line contains $C-1$ integers $X_2$, $X_3$, $\\dots$, $X_C$. A positive $X_i$ value indicates that computer $i$ received the update $X_i$ seconds after computer 1. A negative $X_i$ value indicates that $-X_i$ other computers received the update strictly before computer $i$; this value includes the source computer.\n\nAfter that, there are $D$ more lines that represent the $D$ direct connections in the network. The $i$-th of these lines contains two integers $U_i$ and $V_i$, indicating that computers $U_i$ and $V_i$ are directly connected to each other.\n", "outputFormat": "For each test case, output one line containing `Case #x: y_1 y_2 ... y_D`, where $x$ is the test case number (starting from 1) and $y_i$ is a positive integer not more than $10^6$ representing the latency, in seconds, assigned to the $i$-th direct connection.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the following picture represents the computer network that is illustrated by the sample output. The $i$-th computer is represented by the circle with the label $i$. A line linking two circles represents a direct connection. The number on each line represents the latency of the direct connection.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uvr9sjli.png)\n\nIn Sample Case #2, the first three connections need to have the same latency, while the fourth can have any valid latency. Note that $-2, 0, 1000001$, and $3.14$ are examples of invalid latencies.\n\nIn Sample Case #3, remember that the connections are bidirectional, and so the update can travel from computer $3$ to computer $2$. Any two valid latency values work here.\n\nSample Test Set 2 could not appear in Test Set 1, but could appear in Test Set 2.\n\nOne of the correct outputs is $10\\ 12\\ 4\\ 15\\ 8\\ 3\\ 9\\ 7\\ 5$, as illustrated by the picture below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x60u5h9g.png)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq C \\leq 100$.\n- $C - 1 \\leq D \\leq 1000$.\n- $1 \\leq U_i < V_i \\leq C$, for all $i$.\n- $(U_i, V_i) \\neq (U_j, V_j)$, for all $i \\neq j$.\n- All computers (except the source computer) are connected to the source computer through a sequence of one or more direct connections.\n- There exists at least one way of assigning latency values that is consistent with the input.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $-C < X_i < 0$, for all $i$. (You get the second type of information for all computers.)\n\n**Test Set 2 (11 Pts, Hidden Verdict)**\n\n- $-C < X_i \\leq 1000$, for all $i$.\n- $X_i \\neq 0$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #2] Security Update", "background": "", "description": "**Apricot Rules** 公司刚刚在其网络上安装了一个关键的安全更新。该网络有一台源计算机，其他所有计算机都通过一条或多条直接双向连接与源计算机相连。\n\n这种更新会自行传播：一旦某台计算机首次接收到更新，它会立即开始向所有直接连接的计算机传输更新。每条直接连接都有一个延迟值：表示该连接传输更新所需的秒数（双向传输的延迟相同）。因此，更新不会瞬间传播到所有计算机。\n\n**Apricot Rules** 的工程师不知道这些延迟的具体值，但他们知道这些值都是正整数。他们希望你能根据最近一次实验中观察到的更新传播情况，推断出这些延迟的可能取值。\n\n工程师仅在源计算机上安装了更新，然后等待更新传播到整个系统，直到所有计算机都完成更新。他们记录了更新传播的一些信息。具体来说，对于除源计算机外的每台计算机 $K$，你确切知道以下两种情况之一：\n\n- 源计算机接收到更新的时间与 $K$ 首次接收到更新的时间之间的精确秒数。\n- 在 $K$ 首次接收到更新之前，严格比 $K$ 更早接收到更新的其他计算机（包括源计算机）的数量。\n\n注意，多台计算机可能在同一时间接收到更新。\n\n你需要为每对直接连接的计算机计算一个延迟值（单位为秒）。每个延迟值必须是一个不超过 $10^6$ 的正整数。你提供的延迟值集合必须与所有已知信息一致。题目保证至少存在一种一致的延迟分配方式。\n", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来是 $T$ 个测试用例。每个测试用例的第一行包含两个整数 $C$ 和 $D$，分别表示计算机的数量和直接连接的数量。计算机编号为 $1$ 到 $C$，其中计算机 $1$ 是源计算机。\n\n第二行包含 $C-1$ 个整数 $X_2$, $X_3$, $\\dots$, $X_C$。如果 $X_i$ 为正，表示计算机 $i$ 在计算机 $1$ 接收到更新后的 $X_i$ 秒接收到更新；如果 $X_i$ 为负，表示 $-X_i$ 台其他计算机（包括源计算机）在计算机 $i$ 之前严格更早接收到更新。\n\n接下来的 $D$ 行表示网络中的 $D$ 条直接连接。第 $i$ 行包含两个整数 $U_i$ 和 $V_i$，表示计算机 $U_i$ 和 $V_i$ 直接相连。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y_1 y_2 ... y_D`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y_i$ 是一个不超过 $10^6$ 的正整数，表示分配给第 $i$ 条直接连接的延迟值（单位为秒）。\n", "hint": "**样例解释**\n\n在样例 #1 中，下图展示了样例输出对应的计算机网络。标有 $i$ 的圆圈表示第 $i$ 台计算机，连接两个圆圈的线表示直接连接，线上的数字表示该连接的延迟值。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uvr9sjli.png)\n\n在样例 #2 中，前三条连接的延迟必须相同，而第四条连接的延迟可以是任意有效值。注意，$-2$、$0$、$1000001$ 和 $3.14$ 都是无效的延迟值。\n\n在样例 #3 中，由于连接是双向的，更新可以从计算机 $3$ 传输到计算机 $2$。任意两个有效的延迟值均可满足条件。\n\n样例测试集 #2 不会出现在测试集 #1 中，但可能出现在测试集 #2 中。\n\n其中一个正确的输出是 $10\\ 12\\ 4\\ 15\\ 8\\ 3\\ 9\\ 7\\ 5$，如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x60u5h9g.png)\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq C \\leq 100$。\n- $C - 1 \\leq D \\leq 1000$。\n- 对于所有 $i$，$1 \\leq U_i < V_i \\leq C$。\n- 对于所有 $i \\neq j$，$(U_i, V_i) \\neq (U_j, V_j)$。\n- 所有计算机（除源计算机外）都通过一条或多条直接连接与源计算机相连。\n- 至少存在一种与输入一致的延迟分配方式。\n\n**测试集 1（9 分，可见评测结果）**\n\n- 对于所有 $i$，$-C < X_i < 0$（即所有计算机的信息均为第二种类型）。\n\n**测试集 2（11 分，隐藏评测结果）**\n\n- 对于所有 $i$，$-C < X_i \\leq 1000$。\n- 对于所有 $i$，$X_i \\neq 0$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13064", "type": "P", "difficulty": 5, "samples": [["5\n2\n0 0\n5 5\n3\n0 0\n5 5\n5 0\n5\n0 0\n5 5\n5 0\n3 2\n2 4\n7\n0 0\n1 1\n2 1\n3 1\n8 2\n11 2\n14 2\n1\n-1000000000 1000000000", "Case #1: 2\nCase #2: 3\nCase #3: 4\nCase #4: 7\nCase #5: 1"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "2020", "组合数学", "Google Code Jam"], "title": "[GCJ 2020 #2] Wormhole in One", "background": "", "description": "You are participating in an inter-galactic hyperspace golf competition, and you have advanced to the final round! You are really determined to triumph, and so you want to prepare a winning strategy.\n\nIn hyperspace golf, just as in conventional golf, you hit a ball with a club, which sends the ball in a direction chosen by you. The playing field in hyperspace golf is a 2-dimensional plane with points representing the different holes. The ball is also represented by a point, and you get to choose where the ball starts, as long as it is not in the same place as a hole.\n\nSince this is hyperspace golf, the players are allowed to turn some pairs of holes into wormholes by linking them together. Each hole can be either left as a normal hole, or linked to at most one other hole (never to itself). Wormholes are undirected links, and can be traversed in either direction.\n\nBecause the environment is frictionless, when you hit the ball, it moves in a straight direction that it maintains forever unless it reaches a hole; call that hole $h$. Upon touching hole $h$, the ball stops if $h$ is not connected to another hole. If $h$ is connected to another hole $h'$, then the ball immediately comes out of $h'$ and continues moving in the same direction as before.\n\nYou know the location of each hole. You want to maximize the number of distinct holes you can touch with a single hit. With that goal in mind, you want to pick the ball's starting location, the direction in which to send the ball, and which pairs of holes, if any, to link together as wormholes. The ball cannot start in the same place as a wormhole. When the ball goes through a wormhole, both the hole it goes into and the hole it comes out of are counted towards your total. Each hole is only counted once, even if the ball goes into it or comes out of it (or both) multiple times. If the ball stops in a hole, that hole also counts toward your total.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line containing a single integer $N$: the total number of holes. The following $N$ lines contain two integers each: $X_i$ and $Y_i$, representing the $X$ and $Y$ coordinates, respectively, of the $i$-th hole.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of distinct holes you can touch if you make optimal decisions as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we can connect the two holes with a wormhole so that we could touch both of them by sending the ball into either one. Notice that without the wormhole, the ball would just stay in the first hole it touches, so it would be impossible to touch more than one hole.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/ts9ilei7)\n\nIn Sample Case #2, we can connect the holes at $(0, 0)$ and at $(5, 5)$. We can then hit the ball from position $(4.9, 5)$, for example, in the positive horizontal direction so that it first touches the hole at $(5, 5)$. It goes into that hole and comes out of the hole at $(0, 0)$, retaining its positive horizontal direction of movement. Finally, it touches the hole at $(5, 0)$, and stops (since there is no wormhole linked to that hole).\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/28bszlac)\n\nIn Sample Case #3, we can connect the pair of holes at positions $(0, 0)$ and $(5, 0)$, and also the pair of holes at positions $(3, 2)$ and $(5, 5)$. Hitting the ball from $(4, -1)$ towards the hole at $(5, 0)$ makes it touch the holes at positions $(5, 0), (0, 0), (5, 5)$ and $(3, 2)$, in that order.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/1peglhnt)\n\nIn Sample Case #4, we can connect the pairs of holes at positions $(0, 0)$ and $(1, 1)$, the pair of holes at positions $(2, 1)$ and $(11, 2)$, and also the pair of holes at positions $(8, 2)$ and $(14, 2)$. Hitting the ball from $(-1, 0)$ towards the hole at $(0, 0)$ makes it touch the holes at the following positions, in this order: $(0, 0), (1, 1), (2, 1), (11, 2), (14, 2), (8, 2), (11, 2), (2, 1)$, and $(3, 1)$. Note that although the holes at positions $(11, 2)$ and $(2, 1)$ are touched twice, they are only counted once each for the answer, since the problem asks for a count of distinct holes.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/qrzd1ajh)\n\nIn Sample Case #5, there is only one hole, and we can hit the ball into it without needing to consider wormholes at all. (For what it's worth, we can choose any starting location we want, even outside of the allowable range of coordinates for holes.)\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/1sb96cjz)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $-10^9 \\leq X_i \\leq 10^9$, for all $i$.\n- $-10^9 \\leq Y_i \\leq 10^9$, for all $i$.\n- $(X_i, Y_i) \\neq (X_j, Y_j)$, for all $i \\neq j$. (No two holes are at the same coordinates.)\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq N \\leq 7$.\n\n**Test Set 2 (16 Pts, Hidden Verdict)**\n\n- $1 \\leq N \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #2] Wormhole in One", "background": "", "description": "You are participating in an inter-galactic hyperspace golf competition, and you have advanced to the final round! You are really determined to triumph, and so you want to prepare a winning strategy.\n\nIn hyperspace golf, just as in conventional golf, you hit a ball with a club, which sends the ball in a direction chosen by you. The playing field in hyperspace golf is a 2-dimensional plane with points representing the different holes. The ball is also represented by a point, and you get to choose where the ball starts, as long as it is not in the same place as a hole.\n\nSince this is hyperspace golf, the players are allowed to turn some pairs of holes into wormholes by linking them together. Each hole can be either left as a normal hole, or linked to at most one other hole (never to itself). Wormholes are undirected links, and can be traversed in either direction.\n\nBecause the environment is frictionless, when you hit the ball, it moves in a straight direction that it maintains forever unless it reaches a hole; call that hole $h$. Upon touching hole $h$, the ball stops if $h$ is not connected to another hole. If $h$ is connected to another hole $h'$, then the ball immediately comes out of $h'$ and continues moving in the same direction as before.\n\nYou know the location of each hole. You want to maximize the number of distinct holes you can touch with a single hit. With that goal in mind, you want to pick the ball's starting location, the direction in which to send the ball, and which pairs of holes, if any, to link together as wormholes. The ball cannot start in the same place as a wormhole. When the ball goes through a wormhole, both the hole it goes into and the hole it comes out of are counted towards your total. Each hole is only counted once, even if the ball goes into it or comes out of it (or both) multiple times. If the ball stops in a hole, that hole also counts toward your total.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line containing a single integer $N$: the total number of holes. The following $N$ lines contain two integers each: $X_i$ and $Y_i$, representing the $X$ and $Y$ coordinates, respectively, of the $i$-th hole.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of distinct holes you can touch if you make optimal decisions as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we can connect the two holes with a wormhole so that we could touch both of them by sending the ball into either one. Notice that without the wormhole, the ball would just stay in the first hole it touches, so it would be impossible to touch more than one hole.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/ts9ilei7)\n\nIn Sample Case #2, we can connect the holes at $(0, 0)$ and at $(5, 5)$. We can then hit the ball from position $(4.9, 5)$, for example, in the positive horizontal direction so that it first touches the hole at $(5, 5)$. It goes into that hole and comes out of the hole at $(0, 0)$, retaining its positive horizontal direction of movement. Finally, it touches the hole at $(5, 0)$, and stops (since there is no wormhole linked to that hole).\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/28bszlac)\n\nIn Sample Case #3, we can connect the pair of holes at positions $(0, 0)$ and $(5, 0)$, and also the pair of holes at positions $(3, 2)$ and $(5, 5)$. Hitting the ball from $(4, -1)$ towards the hole at $(5, 0)$ makes it touch the holes at positions $(5, 0), (0, 0), (5, 5)$ and $(3, 2)$, in that order.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/1peglhnt)\n\nIn Sample Case #4, we can connect the pairs of holes at positions $(0, 0)$ and $(1, 1)$, the pair of holes at positions $(2, 1)$ and $(11, 2)$, and also the pair of holes at positions $(8, 2)$ and $(14, 2)$. Hitting the ball from $(-1, 0)$ towards the hole at $(0, 0)$ makes it touch the holes at the following positions, in this order: $(0, 0), (1, 1), (2, 1), (11, 2), (14, 2), (8, 2), (11, 2), (2, 1)$, and $(3, 1)$. Note that although the holes at positions $(11, 2)$ and $(2, 1)$ are touched twice, they are only counted once each for the answer, since the problem asks for a count of distinct holes.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/qrzd1ajh)\n\nIn Sample Case #5, there is only one hole, and we can hit the ball into it without needing to consider wormholes at all. (For what it's worth, we can choose any starting location we want, even outside of the allowable range of coordinates for holes.)\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/1sb96cjz)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $-10^9 \\leq X_i \\leq 10^9$, for all $i$.\n- $-10^9 \\leq Y_i \\leq 10^9$, for all $i$.\n- $(X_i, Y_i) \\neq (X_j, Y_j)$, for all $i \\neq j$. (No two holes are at the same coordinates.)\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq N \\leq 7$.\n\n**Test Set 2 (16 Pts, Hidden Verdict)**\n\n- $1 \\leq N \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #2] Wormhole in One", "background": "", "description": "你正在参加一场星际超空间高尔夫比赛，并成功晋级决赛！为了确保胜利，你决定制定一个完美的策略。\n\n在超空间高尔夫中，和传统高尔夫一样，你需要用球杆击球，使球朝你选择的方向飞行。比赛场地是一个二维平面，平面上的点代表不同的球洞。球本身也用一个点表示，你可以自由选择球的起始位置，只要不和任何球洞重合即可。\n\n由于这是超空间高尔夫，选手可以将某些球洞对连接起来形成虫洞。每个球洞可以选择保持普通状态，或者最多与另一个球洞相连（不能自连）。虫洞是无向连接，可以双向穿越。\n\n由于环境无摩擦，当你击球后，球会沿直线永远飞行，除非碰到球洞 $h$。当球碰到球洞 $h$ 时：\n- 如果 $h$ 没有连接其他球洞，球会停止；\n- 如果 $h$ 连接了另一个球洞 $h'$，球会立即从 $h'$ 飞出，并保持原来的飞行方向继续移动。\n\n你已知所有球洞的位置。你的目标是通过一次击球，最大化触碰到的不同球洞数量。为此，你需要选择：\n1. 球的起始位置\n2. 球的飞行方向\n3. 要连接成虫洞的球洞对（可选）\n\n注意：\n- 球不能从虫洞位置开始\n- 当球穿过虫洞时，进入和穿出的两个球洞都计入总数\n- 每个球洞只计一次，即使多次进入或穿出\n- 如果球停在某个球洞，该球洞也会被计入", "inputFormat": "输入第一行是测试用例数量 $T$。每个测试用例包含：\n- 第一行：整数 $N$ 表示球洞数量\n- 接下来 $N$ 行：每行两个整数 $X_i$ 和 $Y_i$，表示第 $i$ 个球洞的坐标", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中：\n- $x$ 是测试用例编号（从 1 开始）\n- $y$ 是在最优策略下能触碰到的最大不同球洞数量", "hint": "**样例解释**\n\n样例 #1：连接两个球洞形成虫洞，可以让球穿过两个球洞。如果不连接虫洞，球碰到第一个球洞就会停止，无法触碰多个球洞。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/ts9ilei7)\n\n样例 #2：连接 $(0, 0)$ 和 $(5, 5)$ 的球洞。从 $(4.9, 5)$ 水平向右击球，依次经过 $(5, 5)$ → $(0, 0)$ → $(5, 0)$ 后停止。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/28bszlac)\n\n样例 #3：连接 $(0, 0)-(5, 0)$ 和 $(3, 2)-(5, 5)$ 两对球洞。从 $(4, -1)$ 向 $(5, 0)$ 击球，依次经过 $(5, 0)$ → $(0, 0)$ → $(5, 5)$ → $(3, 2)$。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/1peglhnt)\n\n样例 #4：连接 $(0, 0)-(1, 1)$、$(2, 1)-(11, 2)$ 和 $(8, 2)-(14, 2)$ 三对球洞。从 $(-1, 0)$ 向 $(0, 0)$ 击球，可以经过所有 7 个球洞（某些球洞会被多次经过但只计一次）。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/qrzd1ajh)\n\n样例 #5：只有一个球洞时，直接击球入洞即可。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/1sb96cjz)\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$\n- 球洞坐标范围：$-10^9 \\leq X_i, Y_i \\leq 10^9$\n- 所有球洞坐标互不相同\n\n**测试集 1（10 分，可见评测结果）**\n\n- $1 \\leq N \\leq 7$\n\n**测试集 2（16 分，隐藏评测结果）**\n\n- $1 \\leq N \\leq 100$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13065", "type": "P", "difficulty": 7, "samples": [["1\n12 5\n(()(((()))))\n1 1 1 1 1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1 1 1 1 1\n7 4 4 12 5\n12 11 10 1 6", "Case #1: 10"]], "limits": {"time": [60000, 60000, 60000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2020", "倍增", "最短路", "最近公共祖先 LCA", "Google Code Jam"], "title": "[GCJ 2020 #2] Emacs++", "background": "", "description": "In 2016's Distributed Code Jam, we introduced the Lisp++ language for Lisp fans who prefer a higher density of parentheses. Here is a reminder of how the language's syntax works:\n\nA Lisp++ program is a string of balanced parentheses. More formally, a Lisp++ program consists of one of the following. (In this specification, C stands for some program code — not necessarily the same code each time.)\n\n- `()` Literally, just an opening parenthesis and a closing parenthesis. We say that this `(` matches this `)`, and vice versa.\n- `(C)` A program within a pair of enclosing parentheses. We say that this `(` matches this `)`, and vice versa.\n- `CC` Two programs (not necessarily the same), back to back.\n\nThis year, we are pleased to announce Emacs++, a text viewer for Lisp++. Emacs++ displays a Lisp++ program of length K as a single long line with a cursor that you can move around. The cursor is a \"block cursor\" that is always located on one of the K characters in the program, rather than between characters.\n\nAt any point, you can perform one of the following three actions to move the cursor. (i represents the current position of the cursor, counting starting from 1 for the leftmost position.)\n\n- Move the cursor one character to the left (or, if the cursor is already on the leftmost character, does nothing). This takes $L_i$ seconds.\n- Move the cursor one character to the right (or, if the cursor is already on the rightmost character, does nothing). This takes $R_i$ seconds.\n- Teleport the cursor to the parenthesis matching (as described above) the parenthesis that is the i-th character. This takes $P_i$ seconds.\n\nWe think Emacs++ will be simple for power users, but we still need to understand how efficient it is. We have a single Lisp++ program and list of Q queries about that program; each query consists of a start position $S_j$ and an end position $E_j$. To answer the j-th query, you must determine the smallest possible amount of time $N_j$ (in seconds) that it will take to take the cursor from position $S_j$ to position $E_j$, if you make optimal decisions.\n\nPlease output the sum of all of those $N_j$ values.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. The first line of a test case contains two integers $K$, which is the length of the Lisp++ program, and $Q$, which is the number of queries.\n\nThe second line of a test case contains a string $P$ of $K$ characters, each of which is either ( or ), representing a Lisp++ program (string of balanced parentheses), as described above.\n\nThe third, fourth, and fifth lines of a test case each contain $K$ integers. The $i$-th integers in these lines are the values $L_i$, $R_i$, and $P_i$, respectively, that are described above.\n\nThe sixth and seventh lines of a test case each contain $Q$ integers. The $j$-th integers in these lines are $S_j$ and $E_j$, respectively, that are described above.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the sum of the $N_j$ values that are described above.", "hint": "**Sample Explanation**\n\nIn the sample case, which obeys the limits for Test Set 1, all of the time costs are the same ($1$ second per move). The shortest times for the queries are as follows:\n\n1. Move right from $7$ five times to $12$ taking $5$ seconds.\n2. Teleport from $4$ to $11$ taking $1$ second.\n3. Teleport from $4$ to $11$, then move left to $10$ taking $2$ seconds.\n4. Teleport from $12$ to $1$, taking $1$ second.\n5. Move right from $5$ to $6$ taking $1$ second.\n\nThus, the sum of query times is $5+1+2+1+1 = 10$ seconds.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $K = 10^5$ and $Q = 10^5$, for at most 9 test cases.\n- $2 \\leq K \\leq 1000$ and $1 \\leq Q \\leq 1000$, in all other cases.\n- length of $P = K$ $P$ is a string of balanced parentheses, as described above.\n- $1 \\leq S_j \\leq K$, for all $j$.\n- $1 \\leq E_j \\leq K$, for all $j$.\n\n**Test Set 1 (12 Pts, Visible Verdict)**\n\n- $L_i = 1$, for all $i$.\n- $R_i = 1$, for all $i$.\n- $P_i = 1$, for all $i$.\n\n**Test Set 2 (23 Pts, Hidden Verdict)**\n\n- $1 \\leq L_i \\leq 10^6$, for all $i$.\n- $1 \\leq R_i \\leq 10^6$, for all $i$.\n- $1 \\leq P_i \\leq 10^6$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #2] Emacs++", "background": "", "description": "In 2016's Distributed Code Jam, we introduced the Lisp++ language for Lisp fans who prefer a higher density of parentheses. Here is a reminder of how the language's syntax works:\n\nA Lisp++ program is a string of balanced parentheses. More formally, a Lisp++ program consists of one of the following. (In this specification, C stands for some program code — not necessarily the same code each time.)\n\n- `()` Literally, just an opening parenthesis and a closing parenthesis. We say that this `(` matches this `)`, and vice versa.\n- `(C)` A program within a pair of enclosing parentheses. We say that this `(` matches this `)`, and vice versa.\n- `CC` Two programs (not necessarily the same), back to back.\n\nThis year, we are pleased to announce Emacs++, a text viewer for Lisp++. Emacs++ displays a Lisp++ program of length K as a single long line with a cursor that you can move around. The cursor is a \"block cursor\" that is always located on one of the K characters in the program, rather than between characters.\n\nAt any point, you can perform one of the following three actions to move the cursor. (i represents the current position of the cursor, counting starting from 1 for the leftmost position.)\n\n- Move the cursor one character to the left (or, if the cursor is already on the leftmost character, does nothing). This takes $L_i$ seconds.\n- Move the cursor one character to the right (or, if the cursor is already on the rightmost character, does nothing). This takes $R_i$ seconds.\n- Teleport the cursor to the parenthesis matching (as described above) the parenthesis that is the i-th character. This takes $P_i$ seconds.\n\nWe think Emacs++ will be simple for power users, but we still need to understand how efficient it is. We have a single Lisp++ program and list of Q queries about that program; each query consists of a start position $S_j$ and an end position $E_j$. To answer the j-th query, you must determine the smallest possible amount of time $N_j$ (in seconds) that it will take to take the cursor from position $S_j$ to position $E_j$, if you make optimal decisions.\n\nPlease output the sum of all of those $N_j$ values.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. The first line of a test case contains two integers $K$, which is the length of the Lisp++ program, and $Q$, which is the number of queries.\n\nThe second line of a test case contains a string $P$ of $K$ characters, each of which is either ( or ), representing a Lisp++ program (string of balanced parentheses), as described above.\n\nThe third, fourth, and fifth lines of a test case each contain $K$ integers. The $i$-th integers in these lines are the values $L_i$, $R_i$, and $P_i$, respectively, that are described above.\n\nThe sixth and seventh lines of a test case each contain $Q$ integers. The $j$-th integers in these lines are $S_j$ and $E_j$, respectively, that are described above.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the sum of the $N_j$ values that are described above.", "hint": "**Sample Explanation**\n\nIn the sample case, which obeys the limits for Test Set 1, all of the time costs are the same ($1$ second per move). The shortest times for the queries are as follows:\n\n1. Move right from $7$ five times to $12$ taking $5$ seconds.\n2. Teleport from $4$ to $11$ taking $1$ second.\n3. Teleport from $4$ to $11$, then move left to $10$ taking $2$ seconds.\n4. Teleport from $12$ to $1$, taking $1$ second.\n5. Move right from $5$ to $6$ taking $1$ second.\n\nThus, the sum of query times is $5+1+2+1+1 = 10$ seconds.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $K = 10^5$ and $Q = 10^5$, for at most 9 test cases.\n- $2 \\leq K \\leq 1000$ and $1 \\leq Q \\leq 1000$, in all other cases.\n- length of $P = K$ $P$ is a string of balanced parentheses, as described above.\n- $1 \\leq S_j \\leq K$, for all $j$.\n- $1 \\leq E_j \\leq K$, for all $j$.\n\n**Test Set 1 (12 Pts, Visible Verdict)**\n\n- $L_i = 1$, for all $i$.\n- $R_i = 1$, for all $i$.\n- $P_i = 1$, for all $i$.\n\n**Test Set 2 (23 Pts, Hidden Verdict)**\n\n- $1 \\leq L_i \\leq 10^6$, for all $i$.\n- $1 \\leq R_i \\leq 10^6$, for all $i$.\n- $1 \\leq P_i \\leq 10^6$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #2] Emacs++", "background": "", "description": "在 2016 年的 **Distributed Code Jam** 中，我们为偏爱更高密度括号的 Lisp 爱好者推出了 **Lisp++** 语言。以下是该语言语法规则的回顾：\n\n一个 Lisp++ 程序是一个由平衡括号组成的字符串。更正式地说，Lisp++ 程序由以下任意一种形式构成（在此规范中，$C$ 代表某段程序代码——每次出现时不一定相同）：\n\n- `()`：字面上仅包含一个左括号和一个右括号。我们说这个 `(` 匹配这个 `)`，反之亦然。\n- `(C)`：被一对括号包裹的程序。我们说这个 `(` 匹配这个 `)`，反之亦然。\n- $CC$：两个程序（不一定相同）连续拼接。\n\n今年，我们很高兴推出 **Emacs++**，一款专为 Lisp++ 设计的文本查看器。Emacs++ 将长度为 $K$ 的 Lisp++ 程序显示为一行长文本，并带有一个可移动的光标。光标是一个“块光标”，始终位于程序的 $K$ 个字符之一上，而非字符之间。\n\n在任何时刻，你可以执行以下三种操作之一来移动光标（$i$ 表示光标的当前位置，从最左侧位置开始计数为 1）：\n\n- 将光标向左移动一个字符（若光标已在最左侧字符则不做任何操作）。此操作耗时 $L_i$ 秒。\n- 将光标向右移动一个字符（若光标已在最右侧字符则不做任何操作）。此操作耗时 $R_i$ 秒。\n- 将光标传送到与第 $i$ 个字符的括号（如上所述）匹配的括号处。此操作耗时 $P_i$ 秒。\n\n我们认为 Emacs++ 对高级用户来说很简单，但仍需了解其效率。我们有一个 Lisp++ 程序和关于该程序的 $Q$ 个查询；每个查询包含一个起始位置 $S_j$ 和一个目标位置 $E_j$。为了回答第 $j$ 个查询，你需要确定在最优决策下，将光标从位置 $S_j$ 移动到位置 $E_j$ 所需的最小时间 $N_j$（以秒为单位）。\n\n请输出所有 $N_j$ 值的总和。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。随后是 $T$ 个测试用例。每个测试用例的第一行包含两个整数 $K$（表示 Lisp++ 程序的长度）和 $Q$（表示查询的数量）。\n\n每个测试用例的第二行包含一个长度为 $K$ 的字符串 $P$，每个字符为 `(` 或 `)`，表示一个 Lisp++ 程序（平衡括号字符串），如上所述。\n\n每个测试用例的第三、第四和第五行各包含 $K$ 个整数。这些行的第 $i$ 个整数分别为上述的 $L_i$、$R_i$ 和 $P_i$。\n\n每个测试用例的第六和第七行各包含 $Q$ 个整数。这些行的第 $j$ 个整数分别为上述的 $S_j$ 和 $E_j$。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是上述所有 $N_j$ 值的总和。\n", "hint": "**样例解释**\n\n在样例中（符合测试集 1 的限制），所有移动的时间成本相同（每次移动 1 秒）。各查询的最短时间如下：\n\n1. 从 $7$ 向右移动五次到 $12$，耗时 $5$ 秒。\n2. 从 $4$ 传送到 $11$，耗时 $1$ 秒。\n3. 从 $4$ 传送到 $11$，再向左移动到 $10$，耗时 $2$ 秒。\n4. 从 $12$ 传送到 $1$，耗时 $1$ 秒。\n5. 从 $5$ 向右移动到 $6$，耗时 $1$ 秒。\n\n因此，查询时间的总和为 $5 + 1 + 2 + 1 + 1 = 10$ 秒。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- 对于最多 9 个测试用例，$K = 10^5$ 且 $Q = 10^5$。\n- 其他所有情况下，$2 \\leq K \\leq 1000$ 且 $1 \\leq Q \\leq 1000$。\n- 字符串 $P$ 的长度为 $K$，且 $P$ 是一个平衡括号字符串，如上所述。\n- 对于所有 $j$，$1 \\leq S_j \\leq K$。\n- 对于所有 $j$，$1 \\leq E_j \\leq K$。\n\n**测试集 1（12 分，可见判定）**\n\n- 对于所有 $i$，$L_i = 1$。\n- 对于所有 $i$，$R_i = 1$。\n- 对于所有 $i$，$P_i = 1$。\n\n**测试集 2（23 分，隐藏判定）**\n\n- 对于所有 $i$，$1 \\leq L_i \\leq 10^6$。\n- 对于所有 $i$，$1 \\leq R_i \\leq 10^6$。\n- 对于所有 $i$，$1 \\leq P_i \\leq 10^6$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13066", "type": "P", "difficulty": 4, "samples": [["4\nXYZZY ZZYZX\nY Z\nYYXXYZ ZYYXXY\nXZXZXZ YZ", "Case #1: ZZY\nCase #2: Z\nCase #3: ZYYXXYZ\nCase #4: ZYZX"], ["1\nGCJ ABC", "Case #1: GC"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2020", "Special Judge", "Google Code Jam"], "title": "[GCJ 2020 #3] Naming Compromise", "background": "", "description": "Cameron and Jamie are about to welcome a second baby into their lives. They are already good at working together as parents, but right now they are disagreeing about one crucial thing! Cameron wants to name the baby one name (the string $\\mathbf{C}$), whereas Jamie wants to name the baby something else (the string $\\mathbf{J}$).\n\nYou want to help them find a compromise name that is as close as possible to what each of them wants. You think you can do this using the notion of edit distance. The edit distance between two strings $S_1$ and $S_2$ is the minimum number of operations required to transform $S_1$ into $S_2$, where the allowed operations are as follows:\n\n* Insert one character anywhere in the string.\n* Delete one character from anywhere in the string.\n* Change one character in the string to any other character.\n\nFor example, the edit distance between CAMERON and JAMIE is 5. One way to accomplish the transformation in 5 steps is the following: CAMERON to JAMERON (change) to JAMIERON (insert) to JAMIEON (delete) to JAMIEN (delete) to JAMIE (delete). Any transformation from CAMERON into JAMIE requires at least this many operations.\n\nTo make the compromise name $N$ as close as possible to the original desires of the parents, you want $N$ to be a non-empty string such that the sum of the edit distances between $\\mathbf{C}$ and $N$ and between $\\mathbf{J}$ and $N$ is as small as possible. Out of all those choices for $N$, to make sure the compromise is fair, you must choose an $N$ such that the difference between those two edit distances is also as small as possible. Please find a compromise name for Cameron and Jamie.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case consists of a single line with two strings $\\mathbf{C}$ and $\\mathbf{J}$: the names that Cameron and Jamie have proposed for the baby, respectively. Each of these names is made up of uppercase English alphabet letters.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a name that meets the requirements mentioned in the statement. Note that $y$ must contain only uppercase English letters.", "hint": "**Sample Explanation**\n\nSample Test Set 1 meets the limits for Test Set 1. Another sample case that does not meet those limits but could appear in Test Set 2.\n\nThe above cases meet the limits for Test Set 1. Another sample case that does not meet those limits appears at the end of this section.\n\nIn Sample Case #1, the edit distance from `XYZZY` to `ZZY` is 2 (delete the first two letters), and the edit distance from `ZZYZX` to `ZZY` is 2 (delete the last two letters). `XZZX` and `ZYYZY` would also work. No possible name has a sum of edit distances that is less than 4.\n\n`ZY`, for example, has the same edit distance to `C` as to `J` (3, in each case). However the sum of those distances would be 6, which is not minimal, so it would not be an acceptable answer.\n\n`XZZY` is also unacceptable. Its edit distances to `C` and `J`, respectively, are 1 and 3. The sum of those edit distances is minimal, but the difference between the two ($|1-3| = 2$) is not minimal, since we have shown that it is possible to achieve a difference of 0.\n\nIn Sample Case #2, `Y` and `Z` are the only acceptable answers.\n\nIn Sample Case #3, notice that input length restrictions do not apply to the output, so the shown answer is acceptable in either test set. Another possible answer is `YYXXY`.\n\nIn Sample Case #4, the edit distance between `XZXZXZ` and `ZYZX` is 3, and the edit distance between `YZ` and `ZYZX` is 2. The sum of those edit distances is 5, and their difference is 1; these values are optimal for this case.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $\\mathbf{C} \\neq \\mathbf{J}$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $1 \\leq \\text{length of } \\mathbf{C} \\leq 6$.\n- $1 \\leq \\text{length of } \\mathbf{J} \\leq 6$.\n- The i-th letter of $\\mathbf{C}$ is an uppercase x, y, or z, for all i.\n- The i-th letter of $\\mathbf{J}$ is an uppercase x, y, or z, for all i.\n\n**Test Set 2 (8 Pts, Hidden Verdict)**\n\n- $1 \\leq \\text{length of } \\mathbf{C} \\leq 60$.\n- $1 \\leq \\text{length of } \\mathbf{J} \\leq 60$.\n- The $i$-th letter of $\\mathbf{C}$ is an uppercase English alphabet letter, for all i.\n- The $i$-th letter of $\\mathbf{J}$ is an uppercase English alphabet letter, for all i.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #3] Naming Compromise", "background": "", "description": "Cameron and Jamie are about to welcome a second baby into their lives. They are already good at working together as parents, but right now they are disagreeing about one crucial thing! Cameron wants to name the baby one name (the string $\\mathbf{C}$), whereas Jamie wants to name the baby something else (the string $\\mathbf{J}$).\n\nYou want to help them find a compromise name that is as close as possible to what each of them wants. You think you can do this using the notion of edit distance. The edit distance between two strings $S_1$ and $S_2$ is the minimum number of operations required to transform $S_1$ into $S_2$, where the allowed operations are as follows:\n\n* Insert one character anywhere in the string.\n* Delete one character from anywhere in the string.\n* Change one character in the string to any other character.\n\nFor example, the edit distance between CAMERON and JAMIE is 5. One way to accomplish the transformation in 5 steps is the following: CAMERON to JAMERON (change) to JAMIERON (insert) to JAMIEON (delete) to JAMIEN (delete) to JAMIE (delete). Any transformation from CAMERON into JAMIE requires at least this many operations.\n\nTo make the compromise name $N$ as close as possible to the original desires of the parents, you want $N$ to be a non-empty string such that the sum of the edit distances between $\\mathbf{C}$ and $N$ and between $\\mathbf{J}$ and $N$ is as small as possible. Out of all those choices for $N$, to make sure the compromise is fair, you must choose an $N$ such that the difference between those two edit distances is also as small as possible. Please find a compromise name for Cameron and Jamie.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case consists of a single line with two strings $\\mathbf{C}$ and $\\mathbf{J}$: the names that Cameron and Jamie have proposed for the baby, respectively. Each of these names is made up of uppercase English alphabet letters.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a name that meets the requirements mentioned in the statement. Note that $y$ must contain only uppercase English letters.", "hint": "**Sample Explanation**\n\nSample Test Set 1 meets the limits for Test Set 1. Another sample case that does not meet those limits but could appear in Test Set 2.\n\nThe above cases meet the limits for Test Set 1. Another sample case that does not meet those limits appears at the end of this section.\n\nIn Sample Case #1, the edit distance from `XYZZY` to `ZZY` is 2 (delete the first two letters), and the edit distance from `ZZYZX` to `ZZY` is 2 (delete the last two letters). `XZZX` and `ZYYZY` would also work. No possible name has a sum of edit distances that is less than 4.\n\n`ZY`, for example, has the same edit distance to `C` as to `J` (3, in each case). However the sum of those distances would be 6, which is not minimal, so it would not be an acceptable answer.\n\n`XZZY` is also unacceptable. Its edit distances to `C` and `J`, respectively, are 1 and 3. The sum of those edit distances is minimal, but the difference between the two ($|1-3| = 2$) is not minimal, since we have shown that it is possible to achieve a difference of 0.\n\nIn Sample Case #2, `Y` and `Z` are the only acceptable answers.\n\nIn Sample Case #3, notice that input length restrictions do not apply to the output, so the shown answer is acceptable in either test set. Another possible answer is `YYXXY`.\n\nIn Sample Case #4, the edit distance between `XZXZXZ` and `ZYZX` is 3, and the edit distance between `YZ` and `ZYZX` is 2. The sum of those edit distances is 5, and their difference is 1; these values are optimal for this case.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $\\mathbf{C} \\neq \\mathbf{J}$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $1 \\leq \\text{length of } \\mathbf{C} \\leq 6$.\n- $1 \\leq \\text{length of } \\mathbf{J} \\leq 6$.\n- The i-th letter of $\\mathbf{C}$ is an uppercase x, y, or z, for all i.\n- The i-th letter of $\\mathbf{J}$ is an uppercase x, y, or z, for all i.\n\n**Test Set 2 (8 Pts, Hidden Verdict)**\n\n- $1 \\leq \\text{length of } \\mathbf{C} \\leq 60$.\n- $1 \\leq \\text{length of } \\mathbf{J} \\leq 60$.\n- The $i$-th letter of $\\mathbf{C}$ is an uppercase English alphabet letter, for all i.\n- The $i$-th letter of $\\mathbf{J}$ is an uppercase English alphabet letter, for all i.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #3] Naming Compromise", "background": "", "description": "Cameron 和 Jamie 即将迎来他们的第二个孩子。他们在育儿方面已经配合得很好了，但此刻却在一个关键问题上产生了分歧！Cameron 想给孩子取名为 $\\mathbf{C}$，而 Jamie 则想取名为 $\\mathbf{J}$。\n\n你希望帮助他们找到一个折中的名字，使其尽可能接近双方的想法。你认为可以通过**编辑距离**的概念来实现这一点。两个字符串 $S_1$ 和 $S_2$ 之间的编辑距离是指将 $S_1$ 转换为 $S_2$ 所需的最少操作次数，允许的操作包括：\n\n* 在字符串任意位置插入一个字符。\n* 删除字符串中的任意一个字符。\n* 将字符串中的一个字符替换为其他任意字符。\n\n例如，CAMERON 和 JAMIE 之间的编辑距离为 5。一种用 5 步完成转换的方式如下：CAMERON → JAMERON（替换）→ JAMIERON（插入）→ JAMIEON（删除）→ JAMIEN（删除）→ JAMIE（删除）。从 CAMERON 转换到 JAMIE 至少需要这么多操作。\n\n为了使折中名字 $N$ 尽可能接近父母的原始意愿，你需要选择一个非空字符串 $N$，使得 $\\mathbf{C}$ 与 $N$ 的编辑距离和 $\\mathbf{J}$ 与 $N$ 的编辑距离之和最小。在所有满足这一条件的 $N$ 中，为了确保公平性，你还必须选择一个使得这两个编辑距离之差也尽可能小的 $N$。请为 Cameron 和 Jamie 找到一个折中名字。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含一行，其中有两个字符串 $\\mathbf{C}$ 和 $\\mathbf{J}$，分别表示 Cameron 和 Jamie 提议的婴儿名字。这些名字均由大写英文字母组成。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是满足题目要求的名字。注意，$y$ 必须仅包含大写英文字母。\n", "hint": "**样例解释**\n\n样例测试集 1 符合测试集 1 的限制。另一个不符合这些限制但可能出现在测试集 2 中的样例见下文。\n\n在样例 #1 中，从 `XYZZY` 到 `ZZY` 的编辑距离为 2（删除前两个字母），从 `ZZYZX` 到 `ZZY` 的编辑距离为 2（删除最后两个字母）。`XZZX` 和 `ZYYZY` 也是可行的解。没有其他名字能使编辑距离之和小于 4。\n\n例如，`ZY` 到 `C` 和 `J` 的编辑距离相同（均为 3），但编辑距离之和为 6，并非最小值，因此不是可接受的答案。\n\n`XZZY` 也不符合要求。它到 `C` 和 `J` 的编辑距离分别为 1 和 3。虽然编辑距离之和是最小的，但两者之差（$|1-3| = 2$）并非最小，因为我们已经证明可以找到差值为 0 的解。\n\n在样例 #2 中，`Y` 和 `Z` 是唯一可接受的答案。\n\n在样例 #3 中，注意输入的长度限制不适用于输出，因此所示答案在任一测试集中均可接受。另一个可能的答案是 `YYXXY`。\n\n在样例 #4 中，`XZXZXZ` 到 `ZYZX` 的编辑距离为 3，`YZ` 到 `ZYZX` 的编辑距离为 2。编辑距离之和为 5，差值为 1；这些值是该情况下的最优解。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $\\mathbf{C} \\neq \\mathbf{J}$。\n\n**测试集 1（4 分，可见判定）**\n\n- $1 \\leq \\text{C 的长度} \\leq 6$。\n- $1 \\leq \\text{J 的长度} \\leq 6$。\n- $\\mathbf{C}$ 的第 $i$ 个字母是大写 X、Y 或 Z。\n- $\\mathbf{J}$ 的第 $i$ 个字母是大写 X、Y 或 Z。\n\n**测试集 2（8 分，隐藏判定）**\n\n- $1 \\leq \\text{C 的长度} \\leq 60$。\n- $1 \\leq \\text{J 的长度} \\leq 60$。\n- $\\mathbf{C}$ 的第 $i$ 个字母是大写英文字母。\n- $\\mathbf{J}$ 的第 $i$ 个字母是大写英文字母。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13067", "type": "P", "difficulty": 6, "samples": [["3\n2 2\n0 1\n184 330\n3 2\n0 1\n184 330\n10 3\n1 5 9\n184 200 330\n", "Case #1: 2\nCase #2: 3\nCase #3: 3"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2020", "Google Code Jam"], "title": "[GCJ 2020 #3] Thermometers", "background": "", "description": "You are part of a team of researchers investigating the climate along the coast of an island. The island's coast is modeled as a circle with a circumference of $K$ kilometers. There is a lighthouse on the coast which occupies a single point on the circle's circumference. Each point on the coast is mapped to a real number in the range $[0, K)$; formally, point $x$ is the point on the coast that is $x$ kilometers away from the lighthouse when walking clockwise along the coast. For example, if $K = 5$, point $0$ is the point where the lighthouse is, point $1.5$ is the point that is $1.5$ kilometers away from the lighthouse in the clockwise direction, and point $2.5$ is the point that is located at the diametrical opposite of the lighthouse.\n\nYou are in charge of studying coastal temperatures. Another team installed a coastal temperature measuring system that works as follows: a number of thermometers were deployed at specific points to measure the temperature at those points. No two thermometers were placed at the same point. In that team's model, points without thermometers are assumed to have the same temperature as the one measured by the closest thermometer. For points that are equidistant from two thermometers, the thermometer in the clockwise direction is used (the first one you would encounter if walking clockwise from the point).\n\nUnfortunately, you do not know how many thermometers the system used or where they were placed, but you do have access to the system's temperature data. It is given as two lists of $N$ values each $X_1$, $X_2$, $\\dots$, $X_N$ and $T_1$, $T_2$, $\\dots$, $T_N$, representing that each point $x$ where $X_i \\leq x < X_{i+1}$ is assigned temperature $T_i$, for each $1 \\leq i < N$, and each point $x$ where $0 \\leq x < X_1$ or $X_N \\leq x < K$ is assigned temperature $T_N$. The points are enumerated in the clockwise direction, so $X_i < X_{i+1}$, for all $i$.\n\nYou want to determine the smallest number of thermometers that, when placed in some set of locations, could have produced the observed data.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of three lines. The first line of a test case contains two integers $K$ and $N$: the circumference of the island and the size of the lists representing the temperature data. The second line contains $N$ integers $X_1$, $X_2$, $\\dots$, $X_N$. The third line contains $N$ integers $T_1$, $T_2$, $\\dots$, $T_N$. The way in which the integers in the second and third line represent the temperatures is explained above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of thermometers that could have produced the observed input data, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, at least 2 thermometers are needed because there are two different temperatures measured. It is possible to produce the data using exactly 2 thermometers, with one thermometer (measuring 184) at point 0.5 and another (measuring 330) at point 1.5. Note that point 0 and point 1 are equidistant from both thermometers, so the thermometer in the clockwise direction is used. The temperature measured at point 0 comes from the thermometer at point 0.5 and the temperature measured at point 1 comes from the thermometer at point 1.5.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/dk7alwgf)\n\nThe data from Sample Case #2 could not be produced with just 2 thermometers. It could be produced with 3 thermometers if they were placed at point 0.2, point 1.8, and point 2.8, measuring 184, 330 and 330, respectively. There are other ways to place 3 thermometers that would also yield the input data.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/i379fxtz)\n\nIn Sample Case #3, one way to produce the data with 3 thermometers is to place them at point 0, point 2 and point 8, measuring 330, 184 and 200, respectively.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/mrnq6cjj)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq \\min(100, K)$.\n- $0 \\leq X_1$.\n- $X_i < X_{i+1}$, for all $i$.\n- $X_N < K$.\n- $184 \\leq T_i \\leq 330$, for all $i$.\n- $T_i \\neq T_{i+1}$, for all $i$.\n- $T_1 \\neq T_N$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $2 \\leq K \\leq 10$.\n\n**Test Set 2 (19 Pts, Hidden Verdict)**\n\n- $2 \\leq K \\leq 10^9$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #3] Thermometers", "background": "", "description": "You are part of a team of researchers investigating the climate along the coast of an island. The island's coast is modeled as a circle with a circumference of $K$ kilometers. There is a lighthouse on the coast which occupies a single point on the circle's circumference. Each point on the coast is mapped to a real number in the range $[0, K)$; formally, point $x$ is the point on the coast that is $x$ kilometers away from the lighthouse when walking clockwise along the coast. For example, if $K = 5$, point $0$ is the point where the lighthouse is, point $1.5$ is the point that is $1.5$ kilometers away from the lighthouse in the clockwise direction, and point $2.5$ is the point that is located at the diametrical opposite of the lighthouse.\n\nYou are in charge of studying coastal temperatures. Another team installed a coastal temperature measuring system that works as follows: a number of thermometers were deployed at specific points to measure the temperature at those points. No two thermometers were placed at the same point. In that team's model, points without thermometers are assumed to have the same temperature as the one measured by the closest thermometer. For points that are equidistant from two thermometers, the thermometer in the clockwise direction is used (the first one you would encounter if walking clockwise from the point).\n\nUnfortunately, you do not know how many thermometers the system used or where they were placed, but you do have access to the system's temperature data. It is given as two lists of $N$ values each $X_1$, $X_2$, $\\dots$, $X_N$ and $T_1$, $T_2$, $\\dots$, $T_N$, representing that each point $x$ where $X_i \\leq x < X_{i+1}$ is assigned temperature $T_i$, for each $1 \\leq i < N$, and each point $x$ where $0 \\leq x < X_1$ or $X_N \\leq x < K$ is assigned temperature $T_N$. The points are enumerated in the clockwise direction, so $X_i < X_{i+1}$, for all $i$.\n\nYou want to determine the smallest number of thermometers that, when placed in some set of locations, could have produced the observed data.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of three lines. The first line of a test case contains two integers $K$ and $N$: the circumference of the island and the size of the lists representing the temperature data. The second line contains $N$ integers $X_1$, $X_2$, $\\dots$, $X_N$. The third line contains $N$ integers $T_1$, $T_2$, $\\dots$, $T_N$. The way in which the integers in the second and third line represent the temperatures is explained above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of thermometers that could have produced the observed input data, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, at least 2 thermometers are needed because there are two different temperatures measured. It is possible to produce the data using exactly 2 thermometers, with one thermometer (measuring 184) at point 0.5 and another (measuring 330) at point 1.5. Note that point 0 and point 1 are equidistant from both thermometers, so the thermometer in the clockwise direction is used. The temperature measured at point 0 comes from the thermometer at point 0.5 and the temperature measured at point 1 comes from the thermometer at point 1.5.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/dk7alwgf)\n\nThe data from Sample Case #2 could not be produced with just 2 thermometers. It could be produced with 3 thermometers if they were placed at point 0.2, point 1.8, and point 2.8, measuring 184, 330 and 330, respectively. There are other ways to place 3 thermometers that would also yield the input data.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/i379fxtz)\n\nIn Sample Case #3, one way to produce the data with 3 thermometers is to place them at point 0, point 2 and point 8, measuring 330, 184 and 200, respectively.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/mrnq6cjj)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq \\min(100, K)$.\n- $0 \\leq X_1$.\n- $X_i < X_{i+1}$, for all $i$.\n- $X_N < K$.\n- $184 \\leq T_i \\leq 330$, for all $i$.\n- $T_i \\neq T_{i+1}$, for all $i$.\n- $T_1 \\neq T_N$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $2 \\leq K \\leq 10$.\n\n**Test Set 2 (19 Pts, Hidden Verdict)**\n\n- $2 \\leq K \\leq 10^9$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #3] Thermometers", "background": "", "description": "你是一个研究岛屿海岸气候的团队成员。该岛屿的海岸被建模为一个周长为 $K$ 公里的圆。海岸上有一座灯塔，占据圆周上的一个点。海岸上的每个点都被映射到 $[0, K)$ 范围内的一个实数；形式上，点 $x$ 表示从灯塔出发沿顺时针方向行走 $x$ 公里后到达的海岸点。例如，若 $K = 5$，点 $0$ 是灯塔所在位置，点 $1.5$ 是从灯塔出发顺时针方向 $1.5$ 公里的点，而点 $2.5$ 是灯塔的直径对称点。\n\n你负责研究海岸温度。另一个团队安装了一套海岸温度测量系统，其工作原理如下：在特定位置部署了若干温度计以测量这些点的温度。没有两个温度计被放置在同一个点。在该团队的模型中，没有温度计的点被认为与最近温度计测量的温度相同。对于与两个温度计等距的点，使用顺时针方向的温度计（即从该点出发顺时针行走时最先遇到的温度计）。\n\n遗憾的是，你不知道系统使用了多少个温度计或它们的具体位置，但你可以访问系统的温度数据。数据以两个长度为 $N$ 的列表给出：$X_1, X_2, \\dots, X_N$ 和 $T_1, T_2, \\dots, T_N$，表示对于每个 $1 \\leq i < N$，满足 $X_i \\leq x < X_{i+1}$ 的点 $x$ 被分配温度 $T_i$，而满足 $0 \\leq x < X_1$ 或 $X_N \\leq x < K$ 的点 $x$ 被分配温度 $T_N$。这些点按顺时针方向排列，因此对所有 $i$ 有 $X_i < X_{i+1}$。\n\n你需要确定能够产生观测数据的最小温度计数量。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。随后是 $T$ 个测试用例；每个测试用例包含三行。第一行包含两个整数 $K$ 和 $N$：岛屿的周长和表示温度数据的列表大小。第二行包含 $N$ 个整数 $X_1, X_2, \\dots, X_N$。第三行包含 $N$ 个整数 $T_1, T_2, \\dots, T_N$。第二行和第三行的整数表示温度的方式如上所述。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是能够产生输入数据的最小温度计数量。\n", "hint": "**样例解释**\n\n在样例 #1 中，至少需要 2 个温度计，因为测量到了两种不同的温度。可以通过在点 0.5 放置一个温度计（测量值为 184）和在点 1.5 放置另一个温度计（测量值为 330）来生成数据。注意，点 0 和点 1 与两个温度计的距离相等，因此使用顺时针方向的温度计。点 0 的温度来自点 0.5 的温度计，点 1 的温度来自点 1.5 的温度计。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/dk7alwgf)\n\n样例 #2 的数据无法仅用 2 个温度计生成。可以通过在点 0.2、点 1.8 和点 2.8 分别放置测量值为 184、330 和 330 的 3 个温度计来生成数据。还有其他放置 3 个温度计的方式也能生成输入数据。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/i379fxtz)\n\n在样例 #3 中，一种生成数据的方式是在点 0、点 2 和点 8 分别放置测量值为 330、184 和 200 的 3 个温度计。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/mrnq6cjj)\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq N \\leq \\min(100, K)$。\n- $0 \\leq X_1$。\n- 对所有 $i$，$X_i < X_{i+1}$。\n- $X_N < K$。\n- 对所有 $i$，$184 \\leq T_i \\leq 330$。\n- 对所有 $i$，$T_i \\neq T_{i+1}$。\n- $T_1 \\neq T_N$。\n\n**测试集 1（5 分，可见判定）**\n\n- $2 \\leq K \\leq 10$。\n\n**测试集 2（19 分，隐藏判定）**\n\n- $2 \\leq K \\leq 10^9$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13068", "type": "P", "difficulty": 6, "samples": [["2 5 1\n\n1 0\n\n0 1\n\n0 1", "\n4 5\n\n4 3\n\n0 2\n\n0 0\n3 4 3 4"]], "limits": {"time": [90000, 90000, 90000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2020", "交互题", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2020 #3] Pen Testing", "background": "", "description": "You have $N$ ballpoint pens. You know that each has a distinct integer number of units of ink between $0$ and $N-1$, but the pens are given to you in random order, and therefore you do not know which pen is which.\n\nYou are about to go on a trip to the South Pole (where there are no pens), and your luggage only has room for two pens, but you know you will need to do a lot of important postcard writing. Specifically, the two pens you choose must have a total of at least $N$ ink units.\n\nYour only way to get information about the pens is to choose one and try writing something with it. You will either succeed, in which case the pen will now have one unit of ink less (and is now possibly empty), or fail, which means that the pen already had no ink left. You can repeat this multiple times, with the same pen or different pens.\n\nEventually, you must select the two pens to take on your trip, and you succeed if the total amount of ink remaining in those two pens is at least $N$ units.\n\nYou will be given $T$ test cases, and you must succeed in at least $C$ of them. Note that all test sets in this problem are Visible.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing three integers $\\mathbf{T}$, $\\mathbf{N}$, and $\\mathbf{C}$: the number of test cases, the number of pens, and the minimum number of test cases you must succeed in. (Note that the value of $\\mathbf{N}$ is the same for all test sets, and is provided as input only for convenience; see the Limits section for more details.)\n\nThen, your program needs to process all $\\mathbf{T}$ test cases at the same time (this is done to reduce the number of roundtrips between your solution and the judging program). The interaction is organized into rounds.\n\nAt the beginning of each round, your program must print one line containing $\\mathbf{T}$ integers: the i-th integer is the number of the pen you want to try writing with in the i-th test case, or 0 if you do not want to write with any pen in this test case in this round. The pens are numbered from 1 to $\\mathbf{N}$.\n\nBe aware that flushing the output buffer after each one of these integers, instead of only once after printing all $\\mathbf{T}$, could cause a Time Limit Exceeded error because of the time consumed by the flushing itself.\n\nThe judge responds with one line containing $\\mathbf{T}$ integers: the i-th integer is the amount of ink spent in the i-th test case in this round. It will be equal to 1 if the writing in the i-th test case was successful. Otherwise, it will be equal to 0, which could mean that you tried to write in the i-th test case but the pen you chose had no ink left, or that you did not try to write in the i-th test case at all.\n\nYou may participate in at most $\\mathbf{N} \\times (\\mathbf{N}+1)/2$ rounds. Note that this is enough to be confident that all pens are empty.\n\nWhen your program is ready to submit an answer for all test cases, it must print a line containing the number 0 $\\mathbf{T}$ times. This line is not counted towards the limit on the number of rounds, and the judge will not send a response.\n\nThen, your program must print another line with $2 \\times \\mathbf{T}$ integers: the $(2 \\times \\mathbf{i}-1)$-th and the $(2 \\times \\mathbf{i})$-th integers in this line are the distinct numbers of the pens that you take to the South Pole in the i-th test case. The judge will not send a response, and your program must then terminate with no error.\n\nIf the judge receives unexpected output from your program at any moment, the judge will print a single number -1 and not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n\nYou can assume that the pens are given to you in random order. These orders are chosen uniformly at random and independently for each test case and for each submission. Therefore even if you submit exactly the same code twice the judge will use different random orders.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nHere is the same interaction, explained:\n\n```\n  // The following reads 2 into t, 5 into n and 1 into c.\n  t, n, c = readline_int_list()\n  // The judge secretly picks the number of units for each pen:\n  // in test case 1: 2 0 4 1 3\n  // in test case 2: 1 3 2 4 0\n  // We write with the 4-th pen in test case 1, and with the 5-th pen in test case 2.\n  printline 4 5 to stdout\n  flush stdout\n  // Reads 1 0, as the 4-th pen in test case 1 still had ink left,\n  // but the 5-th pen in test case 2 did not.\n  a1, a2 = readline_int_list()\n  // We write with the 4-th pen in test case 1 again, and with the 3-rd pen in test case 2.\n  printline 4 3 to stdout\n  flush stdout\n  // Reads 0 1.\n  a1, a2 = readline_int_list()\n  // We only write in test case 2 this time, with the 2-nd pen.\n  printline 0 2 to stdout\n  flush stdout\n  // Reads 0 1.\n  a1, a2 = readline_int_list()\n  // We decide we are ready to answer.\n  printline 0 0 to stdout\n  flush stdout\n  // We take the 3-rd and the 4-th pens to the South Pole in both test cases.\n  printline 3 4 3 4 to stdout\n  flush stdout\n  // In test case 1, the remaining amounts in the 3-rd and the 4-th pens are 4 and 0, and 4+0<5,\n  // so we did not succeed.\n  // In test case 2, the remaining amounts in the 3-rd and the 4-th pens are 1 and 4, and 1+4≥5,\n  // so we succeeded.\n  // We have succeeded in 1 out of 2 test cases, which is good enough since c=1.\n  exit\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $\\mathbf{N} = 15$.\n\n**Test Set 1 (6 Pts, Visible Verdict)**\n\n- $\\mathbf{T} = 20000$.\n- $\\mathbf{C} = 10900$ ($\\mathbf{C} = 0.545 \\times \\mathbf{T}$).\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $\\mathbf{T} = 20000$.\n- $\\mathbf{C} = 12000$ ($\\mathbf{C} = 0.6 \\times \\mathbf{T}$).\n\n**Test Set 3 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{T} = 100000$.\n- $\\mathbf{C} = 63600$ ($\\mathbf{C} = 0.636 \\times \\mathbf{T}$).", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #3] Pen Testing", "background": "", "description": "You have $N$ ballpoint pens. You know that each has a distinct integer number of units of ink between $0$ and $N-1$, but the pens are given to you in random order, and therefore you do not know which pen is which.\n\nYou are about to go on a trip to the South Pole (where there are no pens), and your luggage only has room for two pens, but you know you will need to do a lot of important postcard writing. Specifically, the two pens you choose must have a total of at least $N$ ink units.\n\nYour only way to get information about the pens is to choose one and try writing something with it. You will either succeed, in which case the pen will now have one unit of ink less (and is now possibly empty), or fail, which means that the pen already had no ink left. You can repeat this multiple times, with the same pen or different pens.\n\nEventually, you must select the two pens to take on your trip, and you succeed if the total amount of ink remaining in those two pens is at least $N$ units.\n\nYou will be given $T$ test cases, and you must succeed in at least $C$ of them. Note that all test sets in this problem are Visible.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing three integers $\\mathbf{T}$, $\\mathbf{N}$, and $\\mathbf{C}$: the number of test cases, the number of pens, and the minimum number of test cases you must succeed in. (Note that the value of $\\mathbf{N}$ is the same for all test sets, and is provided as input only for convenience; see the Limits section for more details.)\n\nThen, your program needs to process all $\\mathbf{T}$ test cases at the same time (this is done to reduce the number of roundtrips between your solution and the judging program). The interaction is organized into rounds.\n\nAt the beginning of each round, your program must print one line containing $\\mathbf{T}$ integers: the i-th integer is the number of the pen you want to try writing with in the i-th test case, or 0 if you do not want to write with any pen in this test case in this round. The pens are numbered from 1 to $\\mathbf{N}$.\n\nBe aware that flushing the output buffer after each one of these integers, instead of only once after printing all $\\mathbf{T}$, could cause a Time Limit Exceeded error because of the time consumed by the flushing itself.\n\nThe judge responds with one line containing $\\mathbf{T}$ integers: the i-th integer is the amount of ink spent in the i-th test case in this round. It will be equal to 1 if the writing in the i-th test case was successful. Otherwise, it will be equal to 0, which could mean that you tried to write in the i-th test case but the pen you chose had no ink left, or that you did not try to write in the i-th test case at all.\n\nYou may participate in at most $\\mathbf{N} \\times (\\mathbf{N}+1)/2$ rounds. Note that this is enough to be confident that all pens are empty.\n\nWhen your program is ready to submit an answer for all test cases, it must print a line containing the number 0 $\\mathbf{T}$ times. This line is not counted towards the limit on the number of rounds, and the judge will not send a response.\n\nThen, your program must print another line with $2 \\times \\mathbf{T}$ integers: the $(2 \\times \\mathbf{i}-1)$-th and the $(2 \\times \\mathbf{i})$-th integers in this line are the distinct numbers of the pens that you take to the South Pole in the i-th test case. The judge will not send a response, and your program must then terminate with no error.\n\nIf the judge receives unexpected output from your program at any moment, the judge will print a single number -1 and not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n\nYou can assume that the pens are given to you in random order. These orders are chosen uniformly at random and independently for each test case and for each submission. Therefore even if you submit exactly the same code twice the judge will use different random orders.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nHere is the same interaction, explained:\n\n```\n  // The following reads 2 into t, 5 into n and 1 into c.\n  t, n, c = readline_int_list()\n  // The judge secretly picks the number of units for each pen:\n  // in test case 1: 2 0 4 1 3\n  // in test case 2: 1 3 2 4 0\n  // We write with the 4-th pen in test case 1, and with the 5-th pen in test case 2.\n  printline 4 5 to stdout\n  flush stdout\n  // Reads 1 0, as the 4-th pen in test case 1 still had ink left,\n  // but the 5-th pen in test case 2 did not.\n  a1, a2 = readline_int_list()\n  // We write with the 4-th pen in test case 1 again, and with the 3-rd pen in test case 2.\n  printline 4 3 to stdout\n  flush stdout\n  // Reads 0 1.\n  a1, a2 = readline_int_list()\n  // We only write in test case 2 this time, with the 2-nd pen.\n  printline 0 2 to stdout\n  flush stdout\n  // Reads 0 1.\n  a1, a2 = readline_int_list()\n  // We decide we are ready to answer.\n  printline 0 0 to stdout\n  flush stdout\n  // We take the 3-rd and the 4-th pens to the South Pole in both test cases.\n  printline 3 4 3 4 to stdout\n  flush stdout\n  // In test case 1, the remaining amounts in the 3-rd and the 4-th pens are 4 and 0, and 4+0<5,\n  // so we did not succeed.\n  // In test case 2, the remaining amounts in the 3-rd and the 4-th pens are 1 and 4, and 1+4≥5,\n  // so we succeeded.\n  // We have succeeded in 1 out of 2 test cases, which is good enough since c=1.\n  exit\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $\\mathbf{N} = 15$.\n\n**Test Set 1 (6 Pts, Visible Verdict)**\n\n- $\\mathbf{T} = 20000$.\n- $\\mathbf{C} = 10900$ ($\\mathbf{C} = 0.545 \\times \\mathbf{T}$).\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $\\mathbf{T} = 20000$.\n- $\\mathbf{C} = 12000$ ($\\mathbf{C} = 0.6 \\times \\mathbf{T}$).\n\n**Test Set 3 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{T} = 100000$.\n- $\\mathbf{C} = 63600$ ($\\mathbf{C} = 0.636 \\times \\mathbf{T}$).", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #3] Pen Testing", "background": "", "description": "你有 $N$ 支圆珠笔。已知每支笔的墨水单位数都是 $0$ 到 $N-1$ 之间互不相同的整数，但这些笔是随机顺序给你的，因此你不知道哪支笔对应多少墨水。\n\n你即将前往南极（那里没有笔），而你的行李只能装两支笔。你知道需要写很多重要的明信片，因此选择的两支笔的墨水总量必须至少为 $N$ 单位。\n\n获取笔信息的唯一方法是选择一支笔尝试写字。尝试结果有两种：成功（该笔墨水减少 1 单位，可能用完）或失败（该笔已无墨水）。你可以重复测试同一支笔或不同笔。\n\n最终，你必须选择两支笔带去南极。若这两支笔剩余墨水的总量不少于 $N$ 单位，则视为成功。\n\n本题包含 $T$ 个测试用例，你需要在至少 $C$ 个用例中成功。注意本题所有测试集都是可见的。\n\n### 交互协议\n\n这是一个交互题。\n\n初始时，你的程序应读取一行包含三个整数 $\\mathbf{T}$、$\\mathbf{N}$ 和 $\\mathbf{C}$：测试用例数量、笔的数量和需要成功的最少用例数。（注意 $\\mathbf{N}$ 在所有测试集中相同，详见数据范围部分。）\n\n然后，你的程序需要同时处理所有 $\\mathbf{T}$ 个测试用例（这是为了减少交互次数）。交互以轮次进行。\n\n每轮开始时，你的程序需输出一行 $\\mathbf{T}$ 个整数：第 $i$ 个整数表示在第 $i$ 个测试用例中要测试的笔编号（1 到 $\\mathbf{N}$），若该轮不测试则输出 0。\n\n注意：如果在每个整数后立即刷新输出缓冲区（而非整行输出后刷新），可能导致超时错误。\n\n评测机将返回一行 $\\mathbf{T}$ 个整数：第 $i$ 个整数表示该轮第 $i$ 个测试用例的耗墨量。1 表示测试成功（耗墨 1 单位），0 表示测试失败（笔已无墨）或未测试。\n\n最多可进行 $\\mathbf{N} \\times (\\mathbf{N}+1)/2$ 轮交互（足以耗尽所有墨水）。\n\n当准备提交答案时，输出一行包含 $\\mathbf{T}$ 个 0。此行不计入交互轮次限制，评测机不会回复。\n\n接着输出一行 $2 \\times \\mathbf{T}$ 个整数：第 $(2i-1)$ 和第 $2i$ 个整数表示第 $i$ 个测试用例选择的两支笔编号。输出后程序应立即终止。\n\n若评测机收到意外输出，将返回 -1 并终止交互。程序需及时退出以避免超时错误。\n\n注意：每次提交时，笔的初始顺序都是独立随机生成的。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "**样例解释**\n\n交互过程解析：\n\n```\n// 读取 T=2, N=5, C=1\nt, n, c = readline_int_list()\n// 评测机秘密生成墨水分布：\n// 测试用例1: [2,0,4,1,3]\n// 测试用例2: [1,3,2,4,0]\n// 第一轮：测试用例1用笔4，测试用例2用笔5\nprintline 4 5\n// 返回1 0（笔4有墨，笔5无墨）\na1, a2 = readline_int_list()\n// 第二轮：测试用例1用笔4，测试用例2用笔3\nprintline 4 3\n// 返回0 1（笔4已无墨，笔3有墨）\na1, a2 = readline_int_list()\n// 第三轮：仅测试用例2用笔2\nprintline 0 2\n// 返回0 1\na1, a2 = readline_int_list()\n// 准备提交答案\nprintline 0 0\n// 选择笔3和笔4\nprintline 3 4 3 4\n// 测试用例1：4+0<5（失败）\n// 测试用例2：1+4≥5（成功）\n// 成功数1≥C，通过\nexit\n```\n\n可使用本地测试工具进行调试。建议配合[交互运行器](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)使用。注意测试工具与真实评测系统可能存在差异。\n\n**数据范围**\n\n- $\\mathbf{N} = 15$\n\n**测试集 1（6 分，可见判定）**\n\n- $\\mathbf{T} = 20000$\n- $\\mathbf{C} = 10900$（$\\mathbf{C} = 0.545 \\times \\mathbf{T}$）\n\n**测试集 2（11 分，可见判定）**\n\n- $\\mathbf{T} = 20000$\n- $\\mathbf{C} = 12000$（$\\mathbf{C} = 0.6 \\times \\mathbf{T}$）\n\n**测试集 3（15 分，可见判定）**\n\n- $\\mathbf{T} = 100000$\n- $\\mathbf{C} = 63600$（$\\mathbf{C} = 0.636 \\times \\mathbf{T}$）\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13069", "type": "P", "difficulty": 6, "samples": [["4\n2 4\n0 0\n5 0\n2 1\n0 0\n5 0\n2 4\n0 0\n4 4\n2 4\n0 0\n5 1", "Case #1: 27 119\nCase #2: 0 1\nCase #3: 0 1\nCase #4: 1 5"], ["1\n3 4\n0 0\n1 1\n2 3", "Case #1: 101 109"]], "limits": {"time": [20000, 20000, 60000, 120000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "线段树", "扫描线", "Google Code Jam"], "title": "[GCJ 2020 #3] Recalculating", "background": "", "description": "You are working for the Driverless Direct Delivery Drone Directions Design Division of Apricot Rules LLC. The company is about to take its first drone \"Principia\" to market. You are tasked with designing backup systems for Principia, in case it loses access to its primary geolocation systems (like GPS), but it still needs a way to get directions. Principia is designed for use on a flat region; formally, the region is a Cartesian plane in which the coordinates are in meters. One or more points on this plane are drone repair centers. No two drone repair centers are at the same location.\n\nPrincipia has a system that can retrieve the relative locations of drone repair centers that are within an $L_1$ distance (which is also known as Manhattan distance) of at most $\\mathbf{D}$ meters of its location. The information retrieved is a set of repair center locations relative to Principia's current location. For example: \"there is a repair center 4 meters north and 3.5 meters west, and another one 2.5 meters east\". Notice that the information does not identify repair centers; it gives their locations relative to Principia.\n\nYou quickly realized that there may be points on the map where this information may not be enough for Principia to uniquely determine its current location. This is because there might be two (or more) different points from which the information looks the same. Points with this property are called non-distinguishable, while all other points are called distinguishable.\n\nFormally, the information retrieved by Principia when located at point $(x, y)$ is $\\text{Info}(x, y) :=$ the set of all points $(z - x, w - y)$, where $(z, w)$ is the location of a repair center and $|z - x| + |w - y| \\leq \\mathbf{D}$. Here $|z - x|$ and $|w - y|$ denote the absolute values of $z - x$ and $w - y$, respectively. A point $(x_1, y_1)$ is non-distinguishable if and only if there exists another point $(x_2, y_2)$ such that $\\text{Info}(x_1, y_1) = \\text{Info}(x_2, y_2)$.\n\nFor example, suppose $\\mathbf{D} = 4$ and there are repair centers at points $(0, 0)$ and $(5, 0)$. The point $(0, 0)$ is non-distinguishable because $\\text{Info}(0, 0) = \\{(0, 0)\\} = \\text{Info}(5, 0)$. This means that point $(5, 0)$ is also non-distinguishable. On the other hand, $\\text{Info}(3.5, 0.1) = \\{(-3.5, -0.1), (1.5, -0.1)\\}$ is not equal to the information from any other point, which means that point $(3.5, 0.1)$ is distinguishable. The following picture illustrates the regions of distinguishable points (in red) and non-distinguishable points (in blue):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lejki1zk.png)\n\nPrincipia is deployed to a point that is chosen uniformly at random from the set of all points that are within $\\mathbf{D}$ meters (using $L_1$ distance) of at least one repair center — that is, the set of all points $(x, y)$ such that $\\text{Info}(x, y)$ is non-empty. The probability of that choice belonging to a given continuous set of points $S$ is proportional to the number of square meters of $S$'s area. In the example above, each red square has an area of 4.5 square meters, while each blue section has an area of 23 square meters. Therefore, the probability of Principia being deployed within each red square is $4.5 / (3 \\times 4.5 + 2 \\times 23)$ and the probability of it being deployed within each blue section is $23 / (3 \\times 4.5 + 2 \\times 23)$. Since the border between adjacent differently-colored sections has area equal to 0, the probability of Principia being deployed exactly on the border is exactly 0.\n\nGiven the locations of all repair centers, what is the probability that the point to which Principia is deployed is distinguishable?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{N}$ and $\\mathbf{D}$ representing (respectively) the number of repair centers and the maximum $L_1$ distance from which Principia can retrieve information from a repair center, as described above. Then, $\\mathbf{N}$ lines follow. The $i$-th of these contains two integers $\\mathbf{X_i}$ and $\\mathbf{Y_i}$ representing the coordinates of the $i$-th repair center. The unit of measurement for all coordinates and $\\mathbf{D}$ is meters.\n", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1) and $y$ and $z$ are non-negative integers. The fraction $y/z$ must represent the probability of Principia being at a distinguishable location, if one is chosen uniformly at random from all locations that are within $\\mathbf{D}$ meters of at least one repair center (using $L_1$ distance). If there are multiple acceptable values for $y$ and $z$, choose the one such that $z$ is minimized.", "hint": "**Sample Explanation**\n\nSample Test Set 1 meets the limits for Test Set 1. Another sample case that does not meet those limits could appear in any of the other test sets.\n\nSample Case #1 is described and depicted in the statement.\n\nThe points in the middle red region are all distinguishable points because they are the only points that retrieve information from both repair centers, and each point in that region retrieves a distinct set of information.\n\nThe points in the left and right red region each receive information from only one repair center, but that information is always unique, so these are all distinguishable points. For example, if Principia knows it is $3$ meters east of a repair center, it can be sure it is not $3$ meters east of the repair center at $(0, 0)$, because then it would have retrieved information from both repair centers. So it must be $3$ meters east of the repair center at $(5, 0)$.\n\nThe points in the blue regions are all non-distinguishable points. Choose any point in one of those regions, and consider the information that Principia would get from that point. It contains only the one repair center in range. But, there is a corresponding point in the other blue region from which Principia would get exactly the same information.\n\nAs explained above, the probability of Principia being deployed to one of the red sections is $4.5/59.5$, so the total probability of it being deployed to any of them is $3\\times 4.5/59.5 = 27/119$.\n\nThe following picture illustrates Sample Case #2. There is no way to retrieve information from more than one repair center, so every point close enough to one of them is non-distinguishable; the same information is retrieved from an equivalent point near the other one. Remember that $z$ (the denominator) must be minimal, so $0\\ 1$ is the only acceptable answer.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uxwv3yho.png)\n\nThe following picture illustrates Sample Case #3. Notice that the border between the two blue squares consists of distinguishable points. However, since its area is $0$, the probability of Principia being deployed there is $0$. All other points where Principia can be deployed are non-distinguishable.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sh8ma8rw.png)\n\nThe following picture illustrates Sample Case #4.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ibxhmn7j.png)\n\nThe following picture illustrates the additional case.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0hdmx3av.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D} \\leq 10^7$.\n- $-10^9 \\leq \\mathbf{X_i} \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y_i} \\leq 10^9$, for all $i$.\n- $(\\mathbf{X_i}, \\mathbf{Y_i}) \\neq (\\mathbf{X_j}, \\mathbf{Y_j})$ for all $i \\neq j$. (No two repair centers share the same location.)\n\n**Test Set 1 (6 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $\\mathbf{N} = 2$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- Time limit: 60 seconds.\n- $2 \\leq \\mathbf{N} \\leq 10$.\n\n**Test Set 3 (15 Pts, Visible Verdict)**\n\n- Time limit: 120 seconds.\n- For 6 cases, $\\mathbf{N} = 1687$.\n- For $\\mathbf{T}-6$ cases, $2 \\leq \\mathbf{N} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #3] Recalculating", "background": "", "description": "You are working for the Driverless Direct Delivery Drone Directions Design Division of Apricot Rules LLC. The company is about to take its first drone \"Principia\" to market. You are tasked with designing backup systems for Principia, in case it loses access to its primary geolocation systems (like GPS), but it still needs a way to get directions. Principia is designed for use on a flat region; formally, the region is a Cartesian plane in which the coordinates are in meters. One or more points on this plane are drone repair centers. No two drone repair centers are at the same location.\n\nPrincipia has a system that can retrieve the relative locations of drone repair centers that are within an $L_1$ distance (which is also known as Manhattan distance) of at most $\\mathbf{D}$ meters of its location. The information retrieved is a set of repair center locations relative to Principia's current location. For example: \"there is a repair center 4 meters north and 3.5 meters west, and another one 2.5 meters east\". Notice that the information does not identify repair centers; it gives their locations relative to Principia.\n\nYou quickly realized that there may be points on the map where this information may not be enough for Principia to uniquely determine its current location. This is because there might be two (or more) different points from which the information looks the same. Points with this property are called non-distinguishable, while all other points are called distinguishable.\n\nFormally, the information retrieved by Principia when located at point $(x, y)$ is $\\text{Info}(x, y) :=$ the set of all points $(z - x, w - y)$, where $(z, w)$ is the location of a repair center and $|z - x| + |w - y| \\leq \\mathbf{D}$. Here $|z - x|$ and $|w - y|$ denote the absolute values of $z - x$ and $w - y$, respectively. A point $(x_1, y_1)$ is non-distinguishable if and only if there exists another point $(x_2, y_2)$ such that $\\text{Info}(x_1, y_1) = \\text{Info}(x_2, y_2)$.\n\nFor example, suppose $\\mathbf{D} = 4$ and there are repair centers at points $(0, 0)$ and $(5, 0)$. The point $(0, 0)$ is non-distinguishable because $\\text{Info}(0, 0) = \\{(0, 0)\\} = \\text{Info}(5, 0)$. This means that point $(5, 0)$ is also non-distinguishable. On the other hand, $\\text{Info}(3.5, 0.1) = \\{(-3.5, -0.1), (1.5, -0.1)\\}$ is not equal to the information from any other point, which means that point $(3.5, 0.1)$ is distinguishable. The following picture illustrates the regions of distinguishable points (in red) and non-distinguishable points (in blue):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lejki1zk.png)\n\nPrincipia is deployed to a point that is chosen uniformly at random from the set of all points that are within $\\mathbf{D}$ meters (using $L_1$ distance) of at least one repair center — that is, the set of all points $(x, y)$ such that $\\text{Info}(x, y)$ is non-empty. The probability of that choice belonging to a given continuous set of points $S$ is proportional to the number of square meters of $S$'s area. In the example above, each red square has an area of 4.5 square meters, while each blue section has an area of 23 square meters. Therefore, the probability of Principia being deployed within each red square is $4.5 / (3 \\times 4.5 + 2 \\times 23)$ and the probability of it being deployed within each blue section is $23 / (3 \\times 4.5 + 2 \\times 23)$. Since the border between adjacent differently-colored sections has area equal to 0, the probability of Principia being deployed exactly on the border is exactly 0.\n\nGiven the locations of all repair centers, what is the probability that the point to which Principia is deployed is distinguishable?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{N}$ and $\\mathbf{D}$ representing (respectively) the number of repair centers and the maximum $L_1$ distance from which Principia can retrieve information from a repair center, as described above. Then, $\\mathbf{N}$ lines follow. The $i$-th of these contains two integers $\\mathbf{X_i}$ and $\\mathbf{Y_i}$ representing the coordinates of the $i$-th repair center. The unit of measurement for all coordinates and $\\mathbf{D}$ is meters.\n", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1) and $y$ and $z$ are non-negative integers. The fraction $y/z$ must represent the probability of Principia being at a distinguishable location, if one is chosen uniformly at random from all locations that are within $\\mathbf{D}$ meters of at least one repair center (using $L_1$ distance). If there are multiple acceptable values for $y$ and $z$, choose the one such that $z$ is minimized.", "hint": "**Sample Explanation**\n\nSample Test Set 1 meets the limits for Test Set 1. Another sample case that does not meet those limits could appear in any of the other test sets.\n\nSample Case #1 is described and depicted in the statement.\n\nThe points in the middle red region are all distinguishable points because they are the only points that retrieve information from both repair centers, and each point in that region retrieves a distinct set of information.\n\nThe points in the left and right red region each receive information from only one repair center, but that information is always unique, so these are all distinguishable points. For example, if Principia knows it is $3$ meters east of a repair center, it can be sure it is not $3$ meters east of the repair center at $(0, 0)$, because then it would have retrieved information from both repair centers. So it must be $3$ meters east of the repair center at $(5, 0)$.\n\nThe points in the blue regions are all non-distinguishable points. Choose any point in one of those regions, and consider the information that Principia would get from that point. It contains only the one repair center in range. But, there is a corresponding point in the other blue region from which Principia would get exactly the same information.\n\nAs explained above, the probability of Principia being deployed to one of the red sections is $4.5/59.5$, so the total probability of it being deployed to any of them is $3\\times 4.5/59.5 = 27/119$.\n\nThe following picture illustrates Sample Case #2. There is no way to retrieve information from more than one repair center, so every point close enough to one of them is non-distinguishable; the same information is retrieved from an equivalent point near the other one. Remember that $z$ (the denominator) must be minimal, so $0\\ 1$ is the only acceptable answer.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uxwv3yho.png)\n\nThe following picture illustrates Sample Case #3. Notice that the border between the two blue squares consists of distinguishable points. However, since its area is $0$, the probability of Principia being deployed there is $0$. All other points where Principia can be deployed are non-distinguishable.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sh8ma8rw.png)\n\nThe following picture illustrates Sample Case #4.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ibxhmn7j.png)\n\nThe following picture illustrates the additional case.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0hdmx3av.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D} \\leq 10^7$.\n- $-10^9 \\leq \\mathbf{X_i} \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y_i} \\leq 10^9$, for all $i$.\n- $(\\mathbf{X_i}, \\mathbf{Y_i}) \\neq (\\mathbf{X_j}, \\mathbf{Y_j})$ for all $i \\neq j$. (No two repair centers share the same location.)\n\n**Test Set 1 (6 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $\\mathbf{N} = 2$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- Time limit: 60 seconds.\n- $2 \\leq \\mathbf{N} \\leq 10$.\n\n**Test Set 3 (15 Pts, Visible Verdict)**\n\n- Time limit: 120 seconds.\n- For 6 cases, $\\mathbf{N} = 1687$.\n- For $\\mathbf{T}-6$ cases, $2 \\leq \\mathbf{N} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #3] Recalculating", "background": "", "description": "你为 Apricot Rules LLC 公司的**无人驾驶直送无人机导航设计部**工作。公司即将推出首款无人机\"Principia\"，你需要为其设计备用导航系统，以防其失去主要定位系统（如 GPS）后仍能获取方向指引。Principia 设计用于平面区域，该区域被建模为笛卡尔坐标系（单位为米），坐标系中分布着一个或多个无人机维修中心，且任意两个维修中心位置不同。\n\nPrincipia 配备的系统可获取其当前位置 $L_1$ 距离（曼哈顿距离）不超过 $\\mathbf{D}$ 米范围内的维修中心相对位置信息。例如：\"有一个维修中心在正北 4 米、正西 3.5 米处，另一个在正东 2.5 米处\"。注意这些信息不标识具体维修中心，仅提供相对于 Principia 的位置。\n\n你很快意识到，地图上可能存在某些点无法通过这些信息唯一确定当前位置，因为不同位置可能产生相同的相对信息集。这类点称为**不可区分点**，其余点称为**可区分点**。\n\n形式化定义：当 Principia 位于 $(x, y)$ 时，获取的信息 $\\text{Info}(x, y)$ 是所有满足 $|z - x| + |w - y| \\leq \\mathbf{D}$ 的维修中心坐标 $(z, w)$ 对应的相对位置 $(z - x, w - y)$ 的集合。若存在另一个点 $(x_2, y_2)$ 使得 $\\text{Info}(x_1, y_1) = \\text{Info}(x_2, y_2)$，则 $(x_1, y_1)$ 是不可区分点。\n\n例如：设 $\\mathbf{D} = 4$，维修中心位于 $(0, 0)$ 和 $(5, 0)$。点 $(0, 0)$ 不可区分，因为 $\\text{Info}(0, 0) = \\{(0, 0)\\} = \\text{Info}(5, 0)$。而 $(3.5, 0.1)$ 是可区分点，因其信息集 $\\{(-3.5, -0.1), (1.5, -0.1)\\}$ 唯一。下图展示了可区分点（红色）与不可区分点（蓝色）的分布：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lejki1zk.png)\n\nPrincipia 的部署位置从所有满足 $\\text{Info}(x, y)$ 非空的点中均匀随机选择。连续点集 $S$ 的被选概率与其面积（平方米）成正比。上例中每个红色区域面积为 4.5 平方米，蓝色区域为 23 平方米，因此部署到红色区域的概率为 $4.5 / (3 \\times 4.5 + 2 \\times 23)$，蓝色区域为 $23 / (3 \\times 4.5 + 2 \\times 23)$。边界区域面积为 0，被选概率严格为 0。\n\n给定所有维修中心坐标，求 Principia 被部署到可区分点的概率。", "inputFormat": "第一行输入测试用例数 $\\mathbf{T}$。每个测试用例包含：\n- 两个整数 $\\mathbf{N}$（维修中心数量）和 $\\mathbf{D}$（最大 $L_1$ 距离）\n- $\\mathbf{N}$ 行，每行两个整数 $\\mathbf{X_i}, \\mathbf{Y_i}$ 表示维修中心坐标（单位：米）", "outputFormat": "对每个测试用例，输出 `Case #x: y z`，其中 $y/z$ 为最简分数形式的概率（$z$ 取最小可能值）。\n", "hint": "**样例解释**\n\n样例测试集 1 符合测试集 1 的限制条件。其他不符合该限制的样例可能出现在任意其他测试集中。\n\n样例 #1 已在题目描述中详细说明并配有图示。\n\n中间红色区域的所有点都是可区分点，因为它们是唯一能同时获取两个维修中心信息的点，且该区域内每个点获取的信息集都是唯一的。\n\n左右两侧红色区域的点各自只能获取一个维修中心的信息，但这些信息始终是唯一的，因此也都是可区分点。例如，若 Principia 知道自己在某个维修中心东侧 $3$ 米处，可以确定这不是 $(0, 0)$ 维修中心的东侧 $3$ 米（否则会同时获取两个维修中心的信息），因此必定是 $(5, 0)$ 维修中心的东侧 $3$ 米。\n\n蓝色区域的所有点都是不可区分点。任选其中一个区域内的点，Principia 获取的信息仅包含范围内单个维修中心的数据，但在另一个蓝色区域存在对应点会生成完全相同的信息集。\n\n如前所述，Principia 部署到单个红色区域的概率为 $4.5/59.5$，因此部署到任意红色区域的总概率为 $3\\times 4.5/59.5 = 27/119$。\n\n下图展示样例 #2。由于无法获取超过一个维修中心的信息，所有靠近维修中心的点都是不可区分的——从另一个维修中心附近的对应点会获取完全相同的信息。注意分母 $z$ 必须取最小值，因此 $0\\ 1$ 是唯一可接受的答案。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uxwv3yho.png)\n\n下图展示样例 #3。注意两个蓝色方形交界处的边界点属于可区分点，但由于其面积为 $0$，被部署到该处的概率为 $0$。其余所有可部署点都是不可区分的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sh8ma8rw.png)\n\n下图展示样例 #4。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ibxhmn7j.png)\n\n下图展示附加测试用例。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0hdmx3av.png)\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$\n- $1 \\leq \\mathbf{D} \\leq 10^7$\n- 对所有 $i$，$-10^9 \\leq \\mathbf{X_i} \\leq 10^9$\n- 对所有 $i$，$-10^9 \\leq \\mathbf{Y_i} \\leq 10^9$\n- 对所有 $i \\neq j$，$(\\mathbf{X_i}, \\mathbf{Y_i}) \\neq (\\mathbf{X_j}, \\mathbf{Y_j})$（任意两个维修中心位置不同）\n\n**测试集 1（6 分，可见判定）**\n\n- 时间限制：20 秒\n- $\\mathbf{N} = 2$\n\n**测试集 2（11 分，可见判定）**\n\n- 时间限制：60 秒\n- $2 \\leq \\mathbf{N} \\leq 10$\n\n**测试集 3（15 分，可见判定）**\n\n- 时间限制：120 秒\n- 其中 6 个用例 $\\mathbf{N} = 1687$\n- 其余 $\\mathbf{T}-6$ 个用例 $2 \\leq \\mathbf{N} \\leq 100$\n\n翻译由 DeepSeek V3 完成\n", "locale": "zh-CN"}}}
{"pid": "P13070", "type": "P", "difficulty": 5, "samples": [["2\n4\n1 2 2 5\n1 3 2 5\n3 4 1 -2\n7\n4 7 2 2\n1 3 5 5\n1 4 2 -1\n3 2 3 -2\n3 5 2 -1\n3 6 2 2", "Case #1: 4 18\nCase #2: 7 15"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "2020", "线段树", "树链剖分", "启发式合并", "Google Code Jam"], "title": "[GCJ 2020 Finals] Pack the Slopes", "background": "", "description": "You are trying to organize a group of skiers. The skiers are taking a trip to a large mountain, which has been rented for the day.\n\nThere are $\\mathbf{N}$ rest points numbered from 1 to $\\mathbf{N}$ on the mountain, and they are connected by $\\mathbf{N}-1$ slopes. Each slope starts at some rest point and goes directly to another rest point, with no intermediate slopes or rest points. A slope can be traversed in only one direction.\n\nEach skier starts at the summit rest point and traverses a slope to reach another rest point. From there, the skier can traverse another slope to reach another rest point, and so on. Once a skier reaches their destination rest point, they stop skiing for the day and head to the ski lodge for hot cocoa. The destination rest point cannot be the summit rest point. However, notice that a skier's destination rest point can be the start of zero or more slopes; that is, a skier does not necessarily have to keep using available slopes until there are none available: they can always walk carefully down the rest of the mountain! For all rest points, there is exactly one sequence of slopes that a skier can use to reach it from the summit rest point.\n\nEach slope can accommodate only a certain total number of skiers in a day, after which the snow gets too choppy to ski. In addition, the ski resort can charge or reward each skier for each slope that they ski on. Each slope may have a different price, and each skier must pay the price for each slope they ski on. A slope's price can be positive, zero, or even negative; a negative price represents a bounty awarded for testing that slope. As the organizer, you pay all the slope prices and collect all the bounties on behalf of your group of skiers. Notice that if multiple skiers use the same slope, you pay that slope's price or collect the slope's bounty multiple times. The sum of all costs you pay minus the sum of all bounties you collect is the total expense for the trip. The expense can be positive, zero, or negative. A negative expense means that you actually made money on the trip!\n\nAs the organizer, you want to figure out the maximum number of skiers that you can put on the mountain. Also, you would like to figure out the minimum possible expense for a trip with that maximum number of skiers.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains a single integer $\\mathbf{N}$: the number of rest points on the mountain.\n\nEach of the final $\\mathbf{N}-1$ lines of a test case describes a slope via four integers $\\mathbf{U_i}$, $\\mathbf{V_i}$, $\\mathbf{S_i}$, and $\\mathbf{C_i}$. These are the slope's starting rest point, the slope's ending rest point, the maximum number of skiers the slope can accommodate, and the slope's price per skier, respectively.\n\nThe summit rest point where the skiers start from is always numbered 1.", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), $y$ is the maximum number of skiers, and $z$ is the minimum expense for having $y$ skiers ski at least one slope each.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we can send one skier to rest point 4, one skier to rest point 3, and two skiers to rest point 2.\n\nIn Sample Case #2, we can send three skiers to rest point 2, two skiers to rest point 5, and two skiers to rest point 4.\n\nNotice that the first slope listed in a test case does not need to start at the summit rest point, and that slopes can have $\\mathbf{U_i} > \\mathbf{V_i}$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{U_i} \\leqslant \\mathbf{N}$, for all $i$.\n- $2 \\leqslant \\mathbf{V_i} \\leqslant \\mathbf{N}$, for all $i$. (No slope can end at the summit rest point.)\n- $\\mathbf{U_i} \\neq \\mathbf{V_i}$, for all $i$.\n- $1 \\leqslant \\mathbf{S_i} \\leqslant 10^5$, for all $i$.\n- $-10^5 \\leqslant \\mathbf{C_i} \\leqslant 10^5$, for all $i$.\n- There is exactly one sequence of slopes that a skier can use to reach rest point $r$ from the summit rest point, for all $r$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $2 \\leqslant \\mathbf{N} \\leqslant 1000$.\n\n**Test Set 2 (22 Pts, Hidden Verdict)**\n\n- $\\mathbf{T} = 17$.\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Finals] Pack the Slopes", "background": "", "description": "You are trying to organize a group of skiers. The skiers are taking a trip to a large mountain, which has been rented for the day.\n\nThere are $\\mathbf{N}$ rest points numbered from 1 to $\\mathbf{N}$ on the mountain, and they are connected by $\\mathbf{N}-1$ slopes. Each slope starts at some rest point and goes directly to another rest point, with no intermediate slopes or rest points. A slope can be traversed in only one direction.\n\nEach skier starts at the summit rest point and traverses a slope to reach another rest point. From there, the skier can traverse another slope to reach another rest point, and so on. Once a skier reaches their destination rest point, they stop skiing for the day and head to the ski lodge for hot cocoa. The destination rest point cannot be the summit rest point. However, notice that a skier's destination rest point can be the start of zero or more slopes; that is, a skier does not necessarily have to keep using available slopes until there are none available: they can always walk carefully down the rest of the mountain! For all rest points, there is exactly one sequence of slopes that a skier can use to reach it from the summit rest point.\n\nEach slope can accommodate only a certain total number of skiers in a day, after which the snow gets too choppy to ski. In addition, the ski resort can charge or reward each skier for each slope that they ski on. Each slope may have a different price, and each skier must pay the price for each slope they ski on. A slope's price can be positive, zero, or even negative; a negative price represents a bounty awarded for testing that slope. As the organizer, you pay all the slope prices and collect all the bounties on behalf of your group of skiers. Notice that if multiple skiers use the same slope, you pay that slope's price or collect the slope's bounty multiple times. The sum of all costs you pay minus the sum of all bounties you collect is the total expense for the trip. The expense can be positive, zero, or negative. A negative expense means that you actually made money on the trip!\n\nAs the organizer, you want to figure out the maximum number of skiers that you can put on the mountain. Also, you would like to figure out the minimum possible expense for a trip with that maximum number of skiers.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains a single integer $\\mathbf{N}$: the number of rest points on the mountain.\n\nEach of the final $\\mathbf{N}-1$ lines of a test case describes a slope via four integers $\\mathbf{U_i}$, $\\mathbf{V_i}$, $\\mathbf{S_i}$, and $\\mathbf{C_i}$. These are the slope's starting rest point, the slope's ending rest point, the maximum number of skiers the slope can accommodate, and the slope's price per skier, respectively.\n\nThe summit rest point where the skiers start from is always numbered 1.", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), $y$ is the maximum number of skiers, and $z$ is the minimum expense for having $y$ skiers ski at least one slope each.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we can send one skier to rest point 4, one skier to rest point 3, and two skiers to rest point 2.\n\nIn Sample Case #2, we can send three skiers to rest point 2, two skiers to rest point 5, and two skiers to rest point 4.\n\nNotice that the first slope listed in a test case does not need to start at the summit rest point, and that slopes can have $\\mathbf{U_i} > \\mathbf{V_i}$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{U_i} \\leqslant \\mathbf{N}$, for all $i$.\n- $2 \\leqslant \\mathbf{V_i} \\leqslant \\mathbf{N}$, for all $i$. (No slope can end at the summit rest point.)\n- $\\mathbf{U_i} \\neq \\mathbf{V_i}$, for all $i$.\n- $1 \\leqslant \\mathbf{S_i} \\leqslant 10^5$, for all $i$.\n- $-10^5 \\leqslant \\mathbf{C_i} \\leqslant 10^5$, for all $i$.\n- There is exactly one sequence of slopes that a skier can use to reach rest point $r$ from the summit rest point, for all $r$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $2 \\leqslant \\mathbf{N} \\leqslant 1000$.\n\n**Test Set 2 (22 Pts, Hidden Verdict)**\n\n- $\\mathbf{T} = 17$.\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Finals] Pack the Slopes", "background": "", "description": "你正在组织一群滑雪者。滑雪者们将前往一座被全天租用的大型雪山。\n\n雪山上有编号为 $1$ 到 $\\mathbf{N}$ 的 $\\mathbf{N}$ 个休息点，它们通过 $\\mathbf{N}-1$ 条滑雪道相连。每条滑雪道从一个休息点出发，直接通向另一个休息点，中途没有其他滑雪道或休息点。滑雪道只能单向通行。\n\n每位滑雪者从山顶休息点（编号 $1$）出发，沿一条滑雪道到达另一个休息点。之后，滑雪者可以继续沿另一条滑雪道前往下一个休息点，以此类推。当滑雪者到达目标休息点时，他们会结束当天的滑雪并前往滑雪小屋享用热可可。目标休息点不能是山顶休息点。但注意，滑雪者的目标休息点可以是零条或多条滑雪道的起点——即滑雪者不一定要用完所有可用滑雪道：他们可以小心地步行下山！对于所有休息点，从山顶休息点出发到达它的滑雪道序列是唯一的。\n\n每条滑雪道每天仅能容纳一定数量的滑雪者，超过后雪道会因积雪过乱而无法使用。此外，滑雪场会根据滑雪者使用的每条滑雪道收取费用或发放奖励。每条滑雪道的价格可能不同，每位滑雪者需支付其使用的每条滑雪道的价格。价格可以是正数、零甚至负数（负数代表测试该滑雪道的奖励）。作为组织者，你需要代表滑雪者支付所有费用并收取所有奖励。注意，若多名滑雪者使用同一条滑雪道，该滑雪道的费用或奖励会被多次计算。你$ $支付的总费用减去收取的总奖励即为本次旅行的总支出。支出可能为正、零或负（负支出表示你实际上赚了钱）。\n\n作为组织者，你需要计算能安排到雪山上的最大滑雪者数量，并求出在该最大数量下的最小可能支出。", "inputFormat": "输入第一行给出测试用例数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含一个整数 $\\mathbf{N}$，表示雪山上的休息点数量。\n\n接下来的 $\\mathbf{N}-1$ 行每行描述一条滑雪道，包含四个整数 $\\mathbf{U_i}$、$\\mathbf{V_i}$、$\\mathbf{S_i}$ 和 $\\mathbf{C_i}$，分别表示滑雪道的起点休息点、终点休息点、最大承载滑雪者数量以及每位滑雪者的使用价格。\n\n山顶休息点（滑雪者起点）始终编号为 $1$。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y z`，其中 $x$ 为测试用例编号（从 $1$ 开始），$y$ 为最大滑雪者数量，$z$ 为安排 $y$ 名滑雪者（每人至少使用一条滑雪道）的最小支出。\n", "hint": "**样例解释**\n\n在样例 #1 中，可以安排 $1$ 名滑雪者前往休息点 $4$，$1$ 名前往休息点 $3$，$2$ 名前往休息点 $2$。\n\n在样例 #2 中，可以安排 $3$ 名滑雪者前往休息点 $2$，$2$ 名前往休息点 $5$，$2$ 名前往休息点 $4$。\n\n注意：测试用例中第一条滑雪道的起点不一定是山顶休息点，且可能存在 $\\mathbf{U_i} > \\mathbf{V_i}$ 的情况。\n\n**数据范围**\n\n- 对所有 $i$，满足 $1 \\leqslant \\mathbf{U_i} \\leqslant \\mathbf{N}$。\n- 对所有 $i$，满足 $2 \\leqslant \\mathbf{V_i} \\leqslant \\mathbf{N}$（没有滑雪道以山顶休息点为终点）。\n- 对所有 $i$，满足 $\\mathbf{U_i} \\neq \\mathbf{V_i}$。\n- 对所有 $i$，满足 $1 \\leqslant \\mathbf{S_i} \\leqslant 10^5$。\n- 对所有 $i$，满足 $-10^5 \\leqslant \\mathbf{C_i} \\leqslant 10^5$。\n- 对所有休息点 $r$，从山顶休息点到 $r$ 的滑雪道序列唯一。\n\n**测试集 1（10 分，可见判定）**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $2 \\leqslant \\mathbf{N} \\leqslant 1000$。\n\n**测试集 2（22 分，隐藏判定）**\n\n- $\\mathbf{T} = 17$。\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13071", "type": "P", "difficulty": 6, "samples": [["3\n6\n2 2\n3 5\n4 3\n6 6\n1 4\n5 1\n4\n4 1\n1 3\n3 4\n2 2\n4\n3 1\n2 2\n4 3\n1 4", "Case #1: 2 1\nCase #2: 0 0\nCase #3: 0 0"]], "limits": {"time": [40000, 40000, 40000], "memory": [1048576, 1048576, 1048576]}, "tags": ["博弈论", "2020", "记忆化搜索", "Google Code Jam"], "title": "[GCJ 2020 Finals] Adjacent and Consecutive", "background": "", "description": "Two players, A and B, are playing a game. The game uses $\\mathbf{N}$ tiles numbered 1 through $\\mathbf{N}$, and a board consisting of a single horizontal row of $\\mathbf{N}$ empty cells.\n\nPlayers alternate turns, with Player A going first. On a turn, a player picks an unused tile and an empty cell and places the tile in the cell. At the end of the game, Player A wins if there are two tiles with consecutive numbers in adjacent cells (regardless of who put them there). Otherwise, Player B wins. For example, final boards of 1 2 3 4 and 4 1 3 2 are examples of wins for Player A, and a final board of 3 1 4 2 is an example of a win for Player B. (Notice that consecutive numbers may appear in either order.)\n\nYou just watched two players play a game, but you could not understand their strategy. They may not have played rationally! You decide to compare their moves against an optimal strategy.\n\nA winning state is a state of the game from which the player whose turn it is can guarantee a win if they play optimally, regardless of what the opponent does. A mistake is a move made while in a winning state that results in the opponent having a winning state on their next turn. (Notice that it is not possible to make a mistake on the last turn of the game, since if the last turn begins with a winning state for that player, it must be because that player's only move results in a win.)\n\nGiven the $\\mathbf{N}$ moves, count the number of mistakes made by each player.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line containing an integer $\\mathbf{N}$: the number of tiles in the game (which is also the number of turns, and the number of cells on the board).\n\nThen, $\\mathbf{N}$ more lines follow. The $i$-th of these (counting starting from 1) has two integers $\\mathbf{M_i}$ and $\\mathbf{C_i}$. Respectively, these represent the tile chosen on the $i$-th turn, and the index of the cell (counting from 1 at the left end to $\\mathbf{N}$ at the right end) where that tile is placed.\n\nNote that it is Player A's turn whenever $i$ is odd, and Player B's turn whenever $i$ is even.", "outputFormat": "For each test case, output one line containing `Case #x: a b`, where $x$ is the test case number (starting from 1), $a$ is the total number of mistakes made by Player A, and $b$ is the total number of mistakes made by Player B.", "hint": "**Sample Explanation**\n\nNotice that any game always begins in a winning state for Player A. For example, Player A can play tile 2 in cell 2 (i.e. the second cell from the left). No matter what Player B does on their turn, at least one of tiles 1 and 3 will be unused, and at least one of cells 1 and 3 will be empty. Then Player A can play one of those tiles in one of those cells, and this secures a win for Player A regardless of what happens in the rest of the game.\n\nIn Sample Case #1, the game plays out as follows:\n\n* _ _ _ _ _ _. This is a winning state for Player A, as explained above.\n* Turn 1: Player A plays tile 2 in cell 2.\n* _ 2 _ _ _ _. This is not a winning state for Player B, as explained above; Player B cannot guarantee a win, regardless of their remaining choices in the game.\n* Turn 2: Player B plays tile 3 in cell 5.\n* _ 2 _ _ 3 _. This is a winning state for Player A; for example, they could play tile 1 in cell 3.\n* Turn 3: Player A plays tile 4 in cell 3.\n* _ 2 4 _ 3 _. This is a winning state for Player B; for example, they could play tile 5 in cell 1, and then they would be guaranteed to win no matter what Player A did. So Player A's last move was a mistake!\n* Turn 4: Player B plays tile 6 in cell 6.\n* _ 2 4 _ 3 6. This is a winning state for Player A, since Player A could play tile 1 in cell 1. So Player B's last move was a mistake!\n* Turn 5: Player A plays tile 1 in cell 4.\n* _ 2 4 1 3 6. This is a winning state for Player B, so Player A's last move was a mistake!\n* Turn 6: Player B plays tile 5 in cell 1.\n* 5 2 4 1 3 6. The game is over, and Player B has won.\n\nIn total, Player A made 2 mistakes and Player B made 1 mistake.\n\nIn Sample Case #2, although some of the moves may look risky, neither player made a mistake as defined in this problem. Player A never gave up a winning state to Player B, and Player B had no opportunity to make a mistake because they were never in a winning state.\n\nIn Sample Case #3, notice that even though the outcome of the game is determined after the second move (since that move creates a pair of adjacent and consecutive tiles), all tiles must be placed in each game. Moreover, although the second move assures Player A's victory, it is not a mistake for Player B because Player B was not in a winning state at the time.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $1 \\leq M_i \\leq N,$ for all $i.$\n- $M_i \\neq M_j,$ for all $i \\neq j.$\n- $1 \\leq C_i \\leq N,$ for all $i.$\n- $C_i \\neq C_j,$ for all $i \\neq j.$\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $4 \\leq N \\leq 10.$\n\n**Test Set 2 (32 Pts, Hidden Verdict)**\n\n- $4 \\leq N \\leq 50.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Finals] Adjacent and Consecutive", "background": "", "description": "Two players, A and B, are playing a game. The game uses $\\mathbf{N}$ tiles numbered 1 through $\\mathbf{N}$, and a board consisting of a single horizontal row of $\\mathbf{N}$ empty cells.\n\nPlayers alternate turns, with Player A going first. On a turn, a player picks an unused tile and an empty cell and places the tile in the cell. At the end of the game, Player A wins if there are two tiles with consecutive numbers in adjacent cells (regardless of who put them there). Otherwise, Player B wins. For example, final boards of 1 2 3 4 and 4 1 3 2 are examples of wins for Player A, and a final board of 3 1 4 2 is an example of a win for Player B. (Notice that consecutive numbers may appear in either order.)\n\nYou just watched two players play a game, but you could not understand their strategy. They may not have played rationally! You decide to compare their moves against an optimal strategy.\n\nA winning state is a state of the game from which the player whose turn it is can guarantee a win if they play optimally, regardless of what the opponent does. A mistake is a move made while in a winning state that results in the opponent having a winning state on their next turn. (Notice that it is not possible to make a mistake on the last turn of the game, since if the last turn begins with a winning state for that player, it must be because that player's only move results in a win.)\n\nGiven the $\\mathbf{N}$ moves, count the number of mistakes made by each player.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line containing an integer $\\mathbf{N}$: the number of tiles in the game (which is also the number of turns, and the number of cells on the board).\n\nThen, $\\mathbf{N}$ more lines follow. The $i$-th of these (counting starting from 1) has two integers $\\mathbf{M_i}$ and $\\mathbf{C_i}$. Respectively, these represent the tile chosen on the $i$-th turn, and the index of the cell (counting from 1 at the left end to $\\mathbf{N}$ at the right end) where that tile is placed.\n\nNote that it is Player A's turn whenever $i$ is odd, and Player B's turn whenever $i$ is even.", "outputFormat": "For each test case, output one line containing `Case #x: a b`, where $x$ is the test case number (starting from 1), $a$ is the total number of mistakes made by Player A, and $b$ is the total number of mistakes made by Player B.", "hint": "**Sample Explanation**\n\nNotice that any game always begins in a winning state for Player A. For example, Player A can play tile 2 in cell 2 (i.e. the second cell from the left). No matter what Player B does on their turn, at least one of tiles 1 and 3 will be unused, and at least one of cells 1 and 3 will be empty. Then Player A can play one of those tiles in one of those cells, and this secures a win for Player A regardless of what happens in the rest of the game.\n\nIn Sample Case #1, the game plays out as follows:\n\n* _ _ _ _ _ _. This is a winning state for Player A, as explained above.\n* Turn 1: Player A plays tile 2 in cell 2.\n* _ 2 _ _ _ _. This is not a winning state for Player B, as explained above; Player B cannot guarantee a win, regardless of their remaining choices in the game.\n* Turn 2: Player B plays tile 3 in cell 5.\n* _ 2 _ _ 3 _. This is a winning state for Player A; for example, they could play tile 1 in cell 3.\n* Turn 3: Player A plays tile 4 in cell 3.\n* _ 2 4 _ 3 _. This is a winning state for Player B; for example, they could play tile 5 in cell 1, and then they would be guaranteed to win no matter what Player A did. So Player A's last move was a mistake!\n* Turn 4: Player B plays tile 6 in cell 6.\n* _ 2 4 _ 3 6. This is a winning state for Player A, since Player A could play tile 1 in cell 1. So Player B's last move was a mistake!\n* Turn 5: Player A plays tile 1 in cell 4.\n* _ 2 4 1 3 6. This is a winning state for Player B, so Player A's last move was a mistake!\n* Turn 6: Player B plays tile 5 in cell 1.\n* 5 2 4 1 3 6. The game is over, and Player B has won.\n\nIn total, Player A made 2 mistakes and Player B made 1 mistake.\n\nIn Sample Case #2, although some of the moves may look risky, neither player made a mistake as defined in this problem. Player A never gave up a winning state to Player B, and Player B had no opportunity to make a mistake because they were never in a winning state.\n\nIn Sample Case #3, notice that even though the outcome of the game is determined after the second move (since that move creates a pair of adjacent and consecutive tiles), all tiles must be placed in each game. Moreover, although the second move assures Player A's victory, it is not a mistake for Player B because Player B was not in a winning state at the time.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $1 \\leq M_i \\leq N,$ for all $i.$\n- $M_i \\neq M_j,$ for all $i \\neq j.$\n- $1 \\leq C_i \\leq N,$ for all $i.$\n- $C_i \\neq C_j,$ for all $i \\neq j.$\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $4 \\leq N \\leq 10.$\n\n**Test Set 2 (32 Pts, Hidden Verdict)**\n\n- $4 \\leq N \\leq 50.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Finals] Adjacent and Consecutive", "background": "", "description": "两名玩家 A 和 B 正在玩一个游戏。游戏使用编号为 $1$ 到 $\\mathbf{N}$ 的 $\\mathbf{N}$ 个方块，以及一个由 $\\mathbf{N}$ 个空格组成的水平排列的游戏板。\n\n玩家轮流行动，玩家 A 先手。每回合，玩家选择一个未被使用的方块和一个空格，并将该方块放入空格中。游戏结束时，如果存在两个**相邻**的格子中的方块编号是**连续**的（无论顺序如何，例如 $1$ 和 $2$ 或 $2$ 和 $1$），则玩家 A 获胜；否则玩家 B 获胜。例如，最终游戏板为 $1\\ 2\\ 3\\ 4$ 或 $4\\ 1\\ 3\\ 2$ 时玩家 A 获胜，而 $3\\ 1\\ 4\\ 2$ 时玩家 B 获胜。\n\n你刚刚观看了一局游戏，但无法理解他们的策略（他们可能没有采用最优策略）。现在，你需要将他们的操作与最优策略进行对比。\n\n**必胜状态** 是指当前回合的玩家在采取最优策略后，无论对手如何应对，都能确保自己最终获胜的游戏状态。**失误** 是指玩家在处于必胜状态时，做出了一个导致对手在下一回合进入必胜状态的操作（注意：游戏的最后一回合不可能出现失误，因为如果最后一回合开始时玩家处于必胜状态，那么他的唯一操作必然直接获胜）。\n\n给定 $\\mathbf{N}$ 个操作，计算每名玩家的失误次数。", "inputFormat": "输入第一行给出测试用例数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含一个整数 $\\mathbf{N}$，表示游戏中的方块数量（也是回合数和游戏板的格子数）。\n\n接下来的 $\\mathbf{N}$ 行，第 $i$ 行（从 $1$ 开始计数）包含两个整数 $\\mathbf{M_i}$ 和 $\\mathbf{C_i}$，分别表示第 $i$ 回合选择的方块编号和放置的格子索引（$1$ 表示最左端，$\\mathbf{N}$ 表示最右端）。\n\n注意：当 $i$ 为奇数时是玩家 A 的回合，偶数时是玩家 B 的回合。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: a b`，其中 $x$ 为测试用例编号（从 $1$ 开始），$a$ 是玩家 A 的失误总数，$b$ 是玩家 B 的失误总数。\n", "hint": "**样例解释**\n\n任何游戏的初始状态都是玩家 A 的必胜状态。例如，玩家 A 可以将方块 $2$ 放在格子 $2$（从左数第二个格子）。无论玩家 B 如何应对，至少方块 $1$ 或 $3$ 未被使用，且格子 $1$ 或 $3$ 为空。之后，玩家 A 可以将其中一个方块放入其中一个格子，从而确保自己最终获胜。\n\n在样例 #1 中，游戏过程如下：\n\n* _ _ _ _ _ _（初始状态，玩家 A 必胜）。\n* 回合 1：玩家 A 将方块 $2$ 放入格子 $2$。\n* _ 2 _ _ _ _（玩家 B 无法确保必胜）。\n* 回合 2：玩家 B 将方块 $3$ 放入格子 $5$。\n* _ 2 _ _ 3 _（玩家 A 仍可必胜，例如将方块 $1$ 放入格子 $3$）。\n* 回合 3：玩家 A 将方块 $4$ 放入格子 $3$。\n* _ 2 4 _ 3 _（此时玩家 B 进入必胜状态，例如下一步可将方块 $5$ 放入格子 $1$，确保最终获胜。因此玩家 A 的这一步是失误！）。\n* 回合 4：玩家 B 将方块 $6$ 放入格子 $6$。\n* _ 2 4 _ 3 6（玩家 A 可必胜，例如将方块 $1$ 放入格子 $1$。因此玩家 B 的这一步是失误！）。\n* 回合 5：玩家 A 将方块 $1$ 放入格子 $4$。\n* _ 2 4 1 3 6（玩家 B 进入必胜状态，因此玩家 A 的这一步是失误！）。\n* 回合 6：玩家 B 将方块 $5$ 放入格子 $1$。\n* 5 2 4 1 3 6（游戏结束，玩家 B 获胜）。\n\n总计：玩家 A 失误 $2$ 次，玩家 B 失误 $1$ 次。\n\n在样例 #2 中，尽管某些操作看起来有风险，但根据题目定义，双方均未失误。玩家 A 从未让玩家 B 进入必胜状态，而玩家 B 也从未有机会失误（因为他们从未处于必胜状态）。\n\n在样例 #3 中，尽管第二回合后游戏结果已确定（因为该操作创造了相邻连续的方块对），但游戏仍需放置所有方块。此外，虽然第二步确保了玩家 A 的胜利，但玩家 B 并未失误，因为当时玩家 B 并不处于必胜状态。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- 对所有 $i$，$1 \\leq M_i \\leq N$。\n- 对所有 $i \\neq j$，$M_i \\neq M_j$。\n- 对所有 $i$，$1 \\leq C_i \\leq N$。\n- 对所有 $i \\neq j$，$C_i \\neq C_j$。\n\n**测试集 1（10 分，可见判定）**\n\n- $4 \\leq N \\leq 10$。\n\n**测试集 2（32 分，隐藏判定）**\n\n- $4 \\leq N \\leq 50$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13072", "type": "P", "difficulty": 7, "samples": [["4\n2 2\n10 10\n00 FF\n2 2\n10 11\n00 FF\n4 3\nFFF FFF\n230 A10 010 F70\n4 3\nAFF FFF\n230 A10 010 F70", "Case #1: 7 120\nCase #2: 1 15\nCase #3: 0 1\nCase #4: 2731 8736"]], "limits": {"time": [90000, 90000, 90000, 90000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2020", "组合数学", "Google Code Jam"], "title": "[GCJ 2020 Finals] Hexacoin Jam", "background": "", "description": "The Code Jam team's first cryptocurrency, jamcoins, never caught on. This year, we are trying again with $hexacoins$, which are named for their use of base 16. To \"mine\" a $\\mathbf{D}$-digit hexacoin, one has to work with integers using exactly $\\mathbf{D}$ base 16 digits, including leading zeroes if needed. Each value represents an integer between 0 and $16^{\\mathbf{D}} - 1$, inclusive. Base 16 digits are represented by the numbers 0 through 9 and the uppercase letters A through F, as usual. For example, F2B, 0C8 and 000 are valid values when $\\mathbf{D}=3$, corresponding to the base 10 values 3883, 200 and 0. On the other hand, 1234, DF, C0DE and JAM are not valid values when $\\mathbf{D}=3$.\n\nWhen performing addition of $\\mathbf{D}$-digit base 16 values, any overflow digits are dropped. That is, the addition is performed modulo $16^{\\mathbf{D}}$. For example, F2B + 0C8 = FF3 (4083 in base 10) and F2B + F2B = E56 (3670 in base 10, because the sum's result is 7766, and taking modulo $16^3$ yields 3670).\n\nTo \"mine\" a $\\mathbf{D}$-digit hexacoin, a computer must perform the following steps:\n\n1. Choose a list $\\mathbf{L}$ of $\\mathbf{N}$ $\\mathbf{D}$-digit base 16 values $\\mathbf{L}_1, \\mathbf{L}_2, ..., \\mathbf{L}_\\mathbf{N}$.\n2. Choose a target range of $\\mathbf{D}$-digit base 16 values: the numbers from $\\mathbf{S}$ to $\\mathbf{E}$, inclusive.\n3. Choose a permutation $\\mathbf{P}$ of the base 16 digits 0 through F, uniformly at random from among all 16! such permutations.\n4. Apply $\\mathbf{P}$ to all digits of all numbers in the list, creating a new list $\\mathbf{L}'$ consisting of $\\mathbf{N}$ $\\mathbf{D}$-digit base 16 values. Formally, the $j$-th digit of the $i$-th element of $\\mathbf{L}'$ is the result of applying $\\mathbf{P}$ to the $j$-th digit of the $i$-th element of $\\mathbf{L}$.\n5. Choose a pair of elements from $\\mathbf{L}'$ without replacement, uniformly at random from among all such possible choices, and independently of the choice of permutation.\n6. Calculate the sum (dropping overflow digits) of the two chosen elements.\n\nIf the sum calculated in the last step is between $\\mathbf{S}$ and $\\mathbf{E}$, inclusive, then a hexacoin has been found! For example, suppose that:\n\n* $\\mathbf{L} = [134, 000, FFB, 000, AA9]$.\n* $\\mathbf{S} = 85C$ and $\\mathbf{E} = EDF$.\n* The computer happens to choose $\\mathbf{P} = (0 \\rightarrow 4, 1 \\rightarrow A, 2 \\rightarrow 2, 3 \\rightarrow 8, 4 \\rightarrow 9, 5 \\rightarrow B, 6 \\rightarrow C, 7 \\rightarrow 7, 8 \\rightarrow F, 9 \\rightarrow 1, A \\rightarrow 0, B \\rightarrow 3, C \\rightarrow 5, D \\rightarrow 6, E \\rightarrow E, F \\rightarrow D)$.\n\nThen, when $\\mathbf{P}$ is applied to $\\mathbf{L}$, the resulting $\\mathbf{L}'$ is [A89, 444, DD3, 444, 001]. Notice that $\\mathbf{P}$ is not applied to $\\mathbf{S}$ and $\\mathbf{E}$.\n\nThere are $(5 \\times 4) / 2 = 10$ pairs of values to choose, and each pair has a probability of $1/10$ of being chosen. The only sums that fall within the range are A89 + DD3 = 85C, 444 + 444 = 888, A89 + 001 = A8A, DD3 + 001 = DD4, and A89 + 444 = ECD (twice).\n\nThe first two steps are already computed and you know the list $\\mathbf{L}$ and the range $[\\mathbf{S}, \\mathbf{E}]$ that were chosen. What is the probability that a hexacoin is found after the rest of the process is performed?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of three lines. The first line contains two integers $\\mathbf{N}$ and $\\mathbf{D}$: the size of the given list and the number of digits to work with, respectively. The second line contains two $\\mathbf{D}$-digit base 16 numbers $\\mathbf{S}$ and $\\mathbf{E}$: the inclusive lower and upper bounds of the target range, respectively. Then there is one more line containing $\\mathbf{N}$ $\\mathbf{D}$-digit base 16 numbers $\\mathbf{L}_1, \\mathbf{L}_2, \\dots, \\mathbf{L}_\\mathbf{N}$, representing the values in the list.", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1) and $y$ and $z$ are non-negative integers, such that the fraction $y/z$ represents the probability of finding a hexacoin, under the conditions described above. All of $x$, $y$, and $z$ must be in base 10. If there are multiple acceptable values for $y$ and $z$, choose the ones such that $z$ is minimized.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the target range is just a single value $10$. Since the result ends with $0$, the sum of the values assigned to both last digits $0$ and $F$ must end in $0$ as well. Since $\\mathbf{P}[0]$ and $\\mathbf{P}[F]$ are different values, their sum cannot be exactly $0$. Therefore, $\\mathbf{P}[0] + \\mathbf{P}[F]$ must be $10$ (in base 16). There are $7$ pairs of different digits that accomplish that. $\\mathbf{P}[0]$ and $\\mathbf{P}[F]$ cannot both be $8$. All $7$ pairs lead to an overall sum of $10$ (after dropping an overflow $1$). Therefore, there are $14$ assignments of different digits to $0$ and $F$ that lead to a hexacoin. There are $16 \\times 15$ possible assignments to those digits, so the result is $14/240 = 7/120$.\n\nIn Sample Case #2, we need to add the probability of the result being exactly $11$ to the result of Sample Case #1. The only way that happens is if $0$ and $F$ are assigned to $0$ and $1$, in either order. That has a probability of $2/240 = 1/120$, leading to a total of $7/120 + 1/120 = 8/120 = 1/15$.\n\nIn Sample Case #3, notice that regardless of which permutation and pair of numbers the computer chooses from the list, we will add two numbers that end in the same digit. That produces an even result, even after taking it modulo $16^3$. Since the only value in range is odd, we have no hope of mining a hexacoin in this case. Notice that $0/2$ is an invalid representation of the answer because $z$ would not be minimum.\n\n**Limits**\n\n- $2 \\leq \\mathbf{N} \\leq 450$.\n- $\\mathbf{S}$ contains exactly $\\mathbf{D}$ characters.\n- Each character of $\\mathbf{S}$ is a base 16 digit.\n- $\\mathbf{E}$ contains exactly $\\mathbf{D}$ characters.\n- Each character of $\\mathbf{E}$ is a base 16 digit.\n- $\\mathbf{S} \\leq \\mathbf{E}$.\n- $\\mathbf{L}_i$ contains exactly $\\mathbf{D}$ characters, for all $i$.\n- Each character of $\\mathbf{L}_i$ is a base 16 digit, for all $i$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{D} \\leq 3$.\n\n**Test Set 2 (10 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{D} \\leq 4$.\n\n**Test Set 3 (22 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 10$.\n- $2 \\leq \\mathbf{D} \\leq 5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Finals] Hexacoin Jam", "background": "", "description": "The Code Jam team's first cryptocurrency, jamcoins, never caught on. This year, we are trying again with $hexacoins$, which are named for their use of base 16. To \"mine\" a $\\mathbf{D}$-digit hexacoin, one has to work with integers using exactly $\\mathbf{D}$ base 16 digits, including leading zeroes if needed. Each value represents an integer between 0 and $16^{\\mathbf{D}} - 1$, inclusive. Base 16 digits are represented by the numbers 0 through 9 and the uppercase letters A through F, as usual. For example, F2B, 0C8 and 000 are valid values when $\\mathbf{D}=3$, corresponding to the base 10 values 3883, 200 and 0. On the other hand, 1234, DF, C0DE and JAM are not valid values when $\\mathbf{D}=3$.\n\nWhen performing addition of $\\mathbf{D}$-digit base 16 values, any overflow digits are dropped. That is, the addition is performed modulo $16^{\\mathbf{D}}$. For example, F2B + 0C8 = FF3 (4083 in base 10) and F2B + F2B = E56 (3670 in base 10, because the sum's result is 7766, and taking modulo $16^3$ yields 3670).\n\nTo \"mine\" a $\\mathbf{D}$-digit hexacoin, a computer must perform the following steps:\n\n1. Choose a list $\\mathbf{L}$ of $\\mathbf{N}$ $\\mathbf{D}$-digit base 16 values $\\mathbf{L}_1, \\mathbf{L}_2, ..., \\mathbf{L}_\\mathbf{N}$.\n2. Choose a target range of $\\mathbf{D}$-digit base 16 values: the numbers from $\\mathbf{S}$ to $\\mathbf{E}$, inclusive.\n3. Choose a permutation $\\mathbf{P}$ of the base 16 digits 0 through F, uniformly at random from among all 16! such permutations.\n4. Apply $\\mathbf{P}$ to all digits of all numbers in the list, creating a new list $\\mathbf{L}'$ consisting of $\\mathbf{N}$ $\\mathbf{D}$-digit base 16 values. Formally, the $j$-th digit of the $i$-th element of $\\mathbf{L}'$ is the result of applying $\\mathbf{P}$ to the $j$-th digit of the $i$-th element of $\\mathbf{L}$.\n5. Choose a pair of elements from $\\mathbf{L}'$ without replacement, uniformly at random from among all such possible choices, and independently of the choice of permutation.\n6. Calculate the sum (dropping overflow digits) of the two chosen elements.\n\nIf the sum calculated in the last step is between $\\mathbf{S}$ and $\\mathbf{E}$, inclusive, then a hexacoin has been found! For example, suppose that:\n\n* $\\mathbf{L} = [134, 000, FFB, 000, AA9]$.\n* $\\mathbf{S} = 85C$ and $\\mathbf{E} = EDF$.\n* The computer happens to choose $\\mathbf{P} = (0 \\rightarrow 4, 1 \\rightarrow A, 2 \\rightarrow 2, 3 \\rightarrow 8, 4 \\rightarrow 9, 5 \\rightarrow B, 6 \\rightarrow C, 7 \\rightarrow 7, 8 \\rightarrow F, 9 \\rightarrow 1, A \\rightarrow 0, B \\rightarrow 3, C \\rightarrow 5, D \\rightarrow 6, E \\rightarrow E, F \\rightarrow D)$.\n\nThen, when $\\mathbf{P}$ is applied to $\\mathbf{L}$, the resulting $\\mathbf{L}'$ is [A89, 444, DD3, 444, 001]. Notice that $\\mathbf{P}$ is not applied to $\\mathbf{S}$ and $\\mathbf{E}$.\n\nThere are $(5 \\times 4) / 2 = 10$ pairs of values to choose, and each pair has a probability of $1/10$ of being chosen. The only sums that fall within the range are A89 + DD3 = 85C, 444 + 444 = 888, A89 + 001 = A8A, DD3 + 001 = DD4, and A89 + 444 = ECD (twice).\n\nThe first two steps are already computed and you know the list $\\mathbf{L}$ and the range $[\\mathbf{S}, \\mathbf{E}]$ that were chosen. What is the probability that a hexacoin is found after the rest of the process is performed?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of three lines. The first line contains two integers $\\mathbf{N}$ and $\\mathbf{D}$: the size of the given list and the number of digits to work with, respectively. The second line contains two $\\mathbf{D}$-digit base 16 numbers $\\mathbf{S}$ and $\\mathbf{E}$: the inclusive lower and upper bounds of the target range, respectively. Then there is one more line containing $\\mathbf{N}$ $\\mathbf{D}$-digit base 16 numbers $\\mathbf{L}_1, \\mathbf{L}_2, \\dots, \\mathbf{L}_\\mathbf{N}$, representing the values in the list.", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1) and $y$ and $z$ are non-negative integers, such that the fraction $y/z$ represents the probability of finding a hexacoin, under the conditions described above. All of $x$, $y$, and $z$ must be in base 10. If there are multiple acceptable values for $y$ and $z$, choose the ones such that $z$ is minimized.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the target range is just a single value $10$. Since the result ends with $0$, the sum of the values assigned to both last digits $0$ and $F$ must end in $0$ as well. Since $\\mathbf{P}[0]$ and $\\mathbf{P}[F]$ are different values, their sum cannot be exactly $0$. Therefore, $\\mathbf{P}[0] + \\mathbf{P}[F]$ must be $10$ (in base 16). There are $7$ pairs of different digits that accomplish that. $\\mathbf{P}[0]$ and $\\mathbf{P}[F]$ cannot both be $8$. All $7$ pairs lead to an overall sum of $10$ (after dropping an overflow $1$). Therefore, there are $14$ assignments of different digits to $0$ and $F$ that lead to a hexacoin. There are $16 \\times 15$ possible assignments to those digits, so the result is $14/240 = 7/120$.\n\nIn Sample Case #2, we need to add the probability of the result being exactly $11$ to the result of Sample Case #1. The only way that happens is if $0$ and $F$ are assigned to $0$ and $1$, in either order. That has a probability of $2/240 = 1/120$, leading to a total of $7/120 + 1/120 = 8/120 = 1/15$.\n\nIn Sample Case #3, notice that regardless of which permutation and pair of numbers the computer chooses from the list, we will add two numbers that end in the same digit. That produces an even result, even after taking it modulo $16^3$. Since the only value in range is odd, we have no hope of mining a hexacoin in this case. Notice that $0/2$ is an invalid representation of the answer because $z$ would not be minimum.\n\n**Limits**\n\n- $2 \\leq \\mathbf{N} \\leq 450$.\n- $\\mathbf{S}$ contains exactly $\\mathbf{D}$ characters.\n- Each character of $\\mathbf{S}$ is a base 16 digit.\n- $\\mathbf{E}$ contains exactly $\\mathbf{D}$ characters.\n- Each character of $\\mathbf{E}$ is a base 16 digit.\n- $\\mathbf{S} \\leq \\mathbf{E}$.\n- $\\mathbf{L}_i$ contains exactly $\\mathbf{D}$ characters, for all $i$.\n- Each character of $\\mathbf{L}_i$ is a base 16 digit, for all $i$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{D} \\leq 3$.\n\n**Test Set 2 (10 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{D} \\leq 4$.\n\n**Test Set 3 (22 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 10$.\n- $2 \\leq \\mathbf{D} \\leq 5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Finals] Hexacoin Jam", "background": "", "description": "Code Jam 团队的第一种加密货币 **jamcoins** 从未流行起来。今年，我们尝试推出基于 16 进制的 **十六进制币**（$hexacoins$）。要“挖矿”一个 $\\mathbf{D}$ 位十六进制币，需要处理恰好 $\\mathbf{D}$ 位的 16 进制数（必要时包含前导零）。每个数值代表 $0$ 到 $16^{\\mathbf{D}} - 1$（含）之间的整数。16 进制数字由数字 0 到 9 和大写字母 A 到 F 表示。例如，当 $\\mathbf{D}=3$ 时，F2B、0C8 和 000 是有效值，对应十进制值 3883、200 和 0。而 1234、DF、C0DE 和 JAM 不是 $\\mathbf{D}=3$ 时的有效值。\n\n执行 $\\mathbf{D}$ 位 16 进制数加法时，溢出的位数会被丢弃（即模 $16^{\\mathbf{D}}$ 加法）。例如，F2B + 0C8 = FF3（十进制 4083），F2B + F2B = E56（十进制 3670，因为和为 7766，模 $16^3$ 得 3670）。\n\n要“挖矿”一个 $\\mathbf{D}$ 位十六进制币，计算机需执行以下步骤：\n\n1. 选择一个包含 $\\mathbf{N}$ 个 $\\mathbf{D}$ 位 16 进制数的列表 $\\mathbf{L}$：$\\mathbf{L}_1, \\mathbf{L}_2, ..., \\mathbf{L}_\\mathbf{N}$。\n2. 选择一个目标范围 $\\mathbf{S}$ 到 $\\mathbf{E}$（含）的 $\\mathbf{D}$ 位 16 进制数。\n3. 从所有 16! 种排列中均匀随机选择一个 16 进制数字 0 到 F 的排列 $\\mathbf{P}$。\n4. 将 $\\mathbf{P}$ 应用于 $\\mathbf{L}$ 中所有数字的每一位，生成新列表 $\\mathbf{L}'$。形式化地，$\\mathbf{L}'$ 的第 $i$ 个元素的第 $j$ 位是 $\\mathbf{P}$ 作用于 $\\mathbf{L}$ 的第 $i$ 个元素的第 $j$ 位的结果。\n5. 从 $\\mathbf{L}'$ 中均匀随机且独立地选择一对元素（无放回）。\n6. 计算所选两个元素的和（丢弃溢出位）。\n\n如果最后一步的和在 $\\mathbf{S}$ 到 $\\mathbf{E}$（含）之间，则成功挖到一枚十六进制币！例如：\n\n- $\\mathbf{L} = [134, 000, FFB, 000, AA9]$。\n- $\\mathbf{S} = 85C$，$\\mathbf{E} = EDF$。\n- 计算机选择排列 $\\mathbf{P} = (0 \\rightarrow 4, 1 \\rightarrow A, 2 \\rightarrow 2, 3 \\rightarrow 8, 4 \\rightarrow 9, 5 \\rightarrow B, 6 \\rightarrow C, 7 \\rightarrow 7, 8 \\rightarrow F, 9 \\rightarrow 1, A \\rightarrow 0, B \\rightarrow 3, C \\rightarrow 5, D \\rightarrow 6, E \\rightarrow E, F \\rightarrow D)$。\n\n应用 $\\mathbf{P}$ 后，$\\mathbf{L}' = [A89, 444, DD3, 444, 001]$。注意 $\\mathbf{S}$ 和 $\\mathbf{E}$ 不受 $\\mathbf{P}$ 影响。\n\n共有 $(5 \\times 4) / 2 = 10$ 对可选，每对概率为 $1/10$。满足范围的求和结果为：A89 + DD3 = 85C、444 + 444 = 888、A89 + 001 = A8A、DD3 + 001 = DD4 和 A89 + 444 = ECD（两次）。\n\n已知前两步的 $\\mathbf{L}$ 和范围 $[\\mathbf{S}, \\mathbf{E}]$，求后续步骤成功挖矿的概率。", "inputFormat": "第一行输入测试用例数 $\\mathbf{T}$。随后每个测试用例包含三行：  \n第一行两个整数 $\\mathbf{N}$ 和 $\\mathbf{D}$：列表大小和数字位数。  \n第二行两个 $\\mathbf{D}$ 位 16 进制数 $\\mathbf{S}$ 和 $\\mathbf{E}$：目标范围的上下界。  \n第三行 $\\mathbf{N}$ 个 $\\mathbf{D}$ 位 16 进制数 $\\mathbf{L}_1, \\mathbf{L}_2, \\dots, \\mathbf{L}_\\mathbf{N}$。\n", "outputFormat": "对每个测试用例，输出一行 `Case #x: y z`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 和 $z$ 为非负整数，表示概率的最简分数 $y/z$。若存在多解，取 $z$ 最小者。\n", "hint": "**样例解释**\n\n样例 #1 中，目标范围仅为 $10$。由于结果末位需为 $0$，且 $\\mathbf{P}[0]$ 和 $\\mathbf{P}[F]$ 不同，它们的和必须为 $10$（16 进制）。共有 7 对不同的数字满足此条件（不能同为 8），对应 14 种赋值方式。总可能赋值数为 $16 \\times 15 = 240$，故概率为 $14/240 = 7/120$。\n\n样例 #2 需额外考虑和为 $11$ 的情况，仅当 $0$ 和 $F$ 被赋值为 $0$ 和 $1$（顺序不限）时成立，概率为 $2/240$。总概率为 $7/120 + 1/120 = 1/15$。\n\n样例 #3 中，无论选择哪对数字，和的末位均为偶数，而目标范围 $FFF$ 为奇数，故概率为 $0$。注意 $0/2$ 不是合法输出，因为 $z$ 未取最小。\n\n**数据范围**\n\n- $2 \\leq \\mathbf{N} \\leq 450$。\n- $\\mathbf{S}$ 和 $\\mathbf{E}$ 均为 $\\mathbf{D}$ 位 16 进制数，且 $\\mathbf{S} \\leq \\mathbf{E}$。\n- 每个 $\\mathbf{L}_i$ 为 $\\mathbf{D}$ 位 16 进制数。\n\n**测试集 1（10 分，可见判定）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{D} \\leq 3$。\n\n**测试集 2（10 分，隐藏判定）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{D} \\leq 4$。\n\n**测试集 3（22 分，隐藏判定）**\n\n- $1 \\leq \\mathbf{T} \\leq 10$。\n- $2 \\leq \\mathbf{D} \\leq 5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13073", "type": "P", "difficulty": 7, "samples": [["2\n5 2 1\n0 3\n1234567890 3\n3154510113 3\n180000000000 3\n359999999999 3\n5 10 1\n90000000000 8\n180000000000 7\n260000000000 9\n260000000001 1\n260000000002 1", "Case #1: 10.0000000000\nCase #2: 36.9238939618"], ["1\n6 1 10\n0 10\n15000000000 1\n30000000000 1\n45000000000 1\n60000000000 1\n75000000000 1", "Case #1: 12.2175228580 12.0000000000 11.7653668647 11.5176380902 11.2610523844 3.0000000000 2.7653668647 2.7653668647 2.5176380902 2.5176380902"]], "limits": {"time": [120000, 120000, 120000], "memory": [1048576, 1048576, 1048576]}, "tags": ["计算几何", "2020", "Special Judge", "Google Code Jam"], "title": "[GCJ 2020 Finals] Musical Cords", "background": "", "description": "Lauren is trying to play the most beautiful notes possible using a harp. The harp is a circle with a radius of $\\mathbf{R}$ centimeters. To play a note, a cord must be attached to the harp in a way that connects two different attachment points on the perimeter of the circle. Lauren then plucks this cord to play a note.\n\nThere are $\\mathbf{N}$ attachment points on the perimeter of the circular harp at which a cord can be attached. The $i$-th such attachment point is at a location that is $\\mathbf{D}_i$ nanodegrees (a nanodegree is $10^{-9}$ degrees) clockwise around the perimeter of the circular harp, starting from the rightmost point on the perimeter.\n\nNot all attachment points use the same technology to properly fix the cords onto them. The $i$-th attachment point requires $\\mathbf{L}_i$ centimeters of cord to be used for attaching. A cord fixed between two different attachment points $i$ and $j$ needs to be exactly $\\mathbf{L}_i + \\mathbf{L}_j + \\text{distance}(i, j)$ centimeters long. By $\\text{distance}(i, j)$ we mean the length of the geometric chord connecting the $i$-th and $j$-th attachment points, that is, the Euclidean distance between the two points.\n\nLauren thinks that notes sound better when they come from longer cords. What are the $\\mathbf{K}$ longest cords that can be used with Lauren's harp?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains three integers: $\\mathbf{N}$, $\\mathbf{R}$ and $\\mathbf{K}$: the number of attachment points, the radius of the circular harp in centimeters, and the number of lengths of cords that Lauren is interested in knowing.\n\nThe next $\\mathbf{N}$ lines describe the attachment points. The $i$-th of these lines contains two integers, $\\mathbf{D}_i$ and $\\mathbf{L}_i$, which describe the position (in number of nanodegrees clockwise from the rightmost point of the harp) and length of cord in centimeters needed at the $i$-th attachment point.\n", "outputFormat": "For each test case, output one line containing Case #x: $y_1$ $y_2$ ... $y_{\\mathbf{K}}$, where $x$ is the test case number (starting from 1), and $y_n$ is the $n$-th value in the list of lengths of all $\\mathbf{N} \\times (\\mathbf{N}-1)/2$ cords that can be used in Lauren's harp, sorted in non-increasing order.\n\nEach $y_n$ will be considered correct if it is within an absolute or relative error of $10^{-9}$ of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explanation**\n\nSample Test Set 1 meet the limits for Test Set 1. Another sample case that does not meet those limits could appear in Test Set 2.\n\nNote: the $\\mathbf{L}_i$ values in these sample cases for Test Set 1 were chosen for ease of understanding and were not randomly generated. Your solution will be run against these sample cases and must pass them.\n\nIn Sample Case #1, all of the attachment points have the same value, so we should pick the pair connected by the longest chord, which in this case is a horizontal diameter of the circle that has a length of 4 centimeters. So the total length needed is $4 + 3 + 3 = 10$ centimeters.\n\nIn Sample Case #2, the fourth and fifth points are extremely close to the third point, but have much smaller $\\mathbf{L}$ values. We can effectively rule them out and focus on the possible connections among the first three points, as follows:\n\n- first and second points: length $10\\sqrt{2} + 8 + 7 \\approx 29.142136$.\n- first and third points: length $\\approx 19.923894 + 8 + 9 \\approx 36.923894$.\n- second and third points: length $\\approx 12.855726 + 7 + 9 \\approx 28.855726$.\n\nUsing the first and third points gives us the greatest total length.\n\nSample Test Set 2: Notice that there are three possible pairs of points tied for producing the 9th longest cord. Also, it is fine if lines connecting different pairs of points intersect, since Lauren will only be playing one note at a time.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{N} = 150000$ in at most 10 cases.\n- $5 \\leq \\mathbf{N} \\leq 10^4$ in all cases with $\\mathbf{N} \\neq 150000$.\n- $1 \\leq \\mathbf{R} \\leq 10^9$.\n- $0 \\leq \\mathbf{D}_1$.\n- $\\mathbf{D}_i < \\mathbf{D}_{i+1}$, for all $i$.\n- $\\mathbf{D}_N < 360 \\times 10^9$.\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{L}_i$ is chosen independently and uniformly at random between 1 and $10^9$, inclusive, for each $i$.\n- $\\mathbf{K} = 1$.\n\n**Test Set 2 (27 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{L}_i \\leq 10^9$, for all $i$.\n- (There is no guarantee as to how each $\\mathbf{L}_i$ is generated.)\n- $\\mathbf{K} = 10$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Finals] Musical Cords", "background": "", "description": "Lauren is trying to play the most beautiful notes possible using a harp. The harp is a circle with a radius of $\\mathbf{R}$ centimeters. To play a note, a cord must be attached to the harp in a way that connects two different attachment points on the perimeter of the circle. Lauren then plucks this cord to play a note.\n\nThere are $\\mathbf{N}$ attachment points on the perimeter of the circular harp at which a cord can be attached. The $i$-th such attachment point is at a location that is $\\mathbf{D}_i$ nanodegrees (a nanodegree is $10^{-9}$ degrees) clockwise around the perimeter of the circular harp, starting from the rightmost point on the perimeter.\n\nNot all attachment points use the same technology to properly fix the cords onto them. The $i$-th attachment point requires $\\mathbf{L}_i$ centimeters of cord to be used for attaching. A cord fixed between two different attachment points $i$ and $j$ needs to be exactly $\\mathbf{L}_i + \\mathbf{L}_j + \\text{distance}(i, j)$ centimeters long. By $\\text{distance}(i, j)$ we mean the length of the geometric chord connecting the $i$-th and $j$-th attachment points, that is, the Euclidean distance between the two points.\n\nLauren thinks that notes sound better when they come from longer cords. What are the $\\mathbf{K}$ longest cords that can be used with Lauren's harp?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains three integers: $\\mathbf{N}$, $\\mathbf{R}$ and $\\mathbf{K}$: the number of attachment points, the radius of the circular harp in centimeters, and the number of lengths of cords that Lauren is interested in knowing.\n\nThe next $\\mathbf{N}$ lines describe the attachment points. The $i$-th of these lines contains two integers, $\\mathbf{D}_i$ and $\\mathbf{L}_i$, which describe the position (in number of nanodegrees clockwise from the rightmost point of the harp) and length of cord in centimeters needed at the $i$-th attachment point.\n", "outputFormat": "For each test case, output one line containing Case #x: $y_1$ $y_2$ ... $y_{\\mathbf{K}}$, where $x$ is the test case number (starting from 1), and $y_n$ is the $n$-th value in the list of lengths of all $\\mathbf{N} \\times (\\mathbf{N}-1)/2$ cords that can be used in Lauren's harp, sorted in non-increasing order.\n\nEach $y_n$ will be considered correct if it is within an absolute or relative error of $10^{-9}$ of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explanation**\n\nSample Test Set 1 meet the limits for Test Set 1. Another sample case that does not meet those limits could appear in Test Set 2.\n\nNote: the $\\mathbf{L}_i$ values in these sample cases for Test Set 1 were chosen for ease of understanding and were not randomly generated. Your solution will be run against these sample cases and must pass them.\n\nIn Sample Case #1, all of the attachment points have the same value, so we should pick the pair connected by the longest chord, which in this case is a horizontal diameter of the circle that has a length of 4 centimeters. So the total length needed is $4 + 3 + 3 = 10$ centimeters.\n\nIn Sample Case #2, the fourth and fifth points are extremely close to the third point, but have much smaller $\\mathbf{L}$ values. We can effectively rule them out and focus on the possible connections among the first three points, as follows:\n\n- first and second points: length $10\\sqrt{2} + 8 + 7 \\approx 29.142136$.\n- first and third points: length $\\approx 19.923894 + 8 + 9 \\approx 36.923894$.\n- second and third points: length $\\approx 12.855726 + 7 + 9 \\approx 28.855726$.\n\nUsing the first and third points gives us the greatest total length.\n\nSample Test Set 2: Notice that there are three possible pairs of points tied for producing the 9th longest cord. Also, it is fine if lines connecting different pairs of points intersect, since Lauren will only be playing one note at a time.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{N} = 150000$ in at most 10 cases.\n- $5 \\leq \\mathbf{N} \\leq 10^4$ in all cases with $\\mathbf{N} \\neq 150000$.\n- $1 \\leq \\mathbf{R} \\leq 10^9$.\n- $0 \\leq \\mathbf{D}_1$.\n- $\\mathbf{D}_i < \\mathbf{D}_{i+1}$, for all $i$.\n- $\\mathbf{D}_N < 360 \\times 10^9$.\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{L}_i$ is chosen independently and uniformly at random between 1 and $10^9$, inclusive, for each $i$.\n- $\\mathbf{K} = 1$.\n\n**Test Set 2 (27 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{L}_i \\leq 10^9$, for all $i$.\n- (There is no guarantee as to how each $\\mathbf{L}_i$ is generated.)\n- $\\mathbf{K} = 10$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Finals] Musical Cords", "background": "", "description": "Lauren 正尝试用竖琴演奏最美妙的音符。竖琴是一个半径为 $\\mathbf{R}$ 厘米的圆形乐器。要演奏一个音符，必须在圆周上两个不同的固定点之间连接一根琴弦，并通过拨动琴弦发声。\n\n圆周上共有 $\\mathbf{N}$ 个固定点可用于连接琴弦。第 $i$ 个固定点的位置为从圆周最右侧点顺时针方向 $\\mathbf{D}_i$ 纳度（1 纳度 = $10^{-9}$ 度）处。\n\n不同固定点使用的固定技术不同。第 $i$ 个固定点需要消耗 $\\mathbf{L}_i$ 厘米的琴弦用于固定。连接两个不同固定点 $i$ 和 $j$ 的琴弦总长度必须恰好为 $\\mathbf{L}_i + \\mathbf{L}_j + \\text{distance}(i, j)$ 厘米。其中 $\\text{distance}(i, j)$ 表示第 $i$ 个和第 $j$ 个固定点之间的几何弦长（即两点间的欧几里得距离）。\n\nLauren 认为琴弦越长，音符听起来越美妙。请问 Lauren 的竖琴可以使用的琴弦中，最长的 $\\mathbf{K}$ 个长度分别是多少？\n", "inputFormat": "第一行输入测试用例数 $\\mathbf{T}$。每个测试用例包含：  \n第一行三个整数 $\\mathbf{N}$、$\\mathbf{R}$ 和 $\\mathbf{K}$：固定点数量、竖琴半径（厘米）和 Lauren 需要查询的琴弦长度数量。  \n接下来 $\\mathbf{N}$ 行描述固定点，每行两个整数 $\\mathbf{D}_i$ 和 $\\mathbf{L}_i$，分别表示第 $i$ 个固定点的位置（纳度）和固定所需琴弦长度（厘米）。\n", "outputFormat": "对每个测试用例，输出一行 `Case #x: y1 y2 ... yK`，其中 $x$ 为测试用例编号（从 1 开始），$y_n$ 为所有 $\\mathbf{N} \\times (\\mathbf{N}-1)/2$ 根可能琴弦的长度按非递增排序后的第 $n$ 个值。\n\n每个 $y_n$ 允许存在绝对或相对误差不超过 $10^{-9}$。", "hint": "**样例解释**\n\n样例测试集 1 符合测试集 1 的限制条件。其他不符合该限制的样例可能出现在测试集 2 中。\n\n注意：测试集 1 的样例中 $\\mathbf{L}_i$ 值是为便于理解而设定的非随机值。您的解法必须通过这些样例。\n\n在样例 #1 中，所有固定点的 $\\mathbf{L}_i$ 值相同，因此应选择弦长最长的点对（即圆的水平直径，长度 4 厘米）。总长度为 $4 + 3 + 3 = 10$ 厘米。\n\n在样例 #2 中，第四和第五个点非常接近第三个点，但 $\\mathbf{L}$ 值较小。最优解来自前三个点的连接：  \n- 第一和第二个点：长度 $10\\sqrt{2} + 8 + 7 \\approx 29.142136$  \n- 第一和第三个点：长度 $\\approx 19.923894 + 8 + 9 \\approx 36.923894$  \n- 第二和第三个点：长度 $\\approx 12.855726 + 7 + 9 \\approx 28.855726$  \n因此选择第一和第三个点获得最大长度。\n\n样例测试集 2：注意存在三组点对并列产生第 9 长的琴弦。不同琴弦可以交叉，因为 Lauren 每次只演奏一个音符。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$  \n- $\\mathbf{N} = 150000$ 的用例不超过 10 个  \n- $5 \\leq \\mathbf{N} \\leq 10^4$（当 $\\mathbf{N} \\neq 150000$ 时）  \n- $1 \\leq \\mathbf{R} \\leq 10^9$  \n- $0 \\leq \\mathbf{D}_1$  \n- $\\mathbf{D}_i < \\mathbf{D}_{i+1}$（对所有 $i$）  \n- $\\mathbf{D}_N < 360 \\times 10^9$  \n\n**测试集 1（15 分，可见判定）**\n\n- $\\mathbf{L}_i$ 在 1 到 $10^9$ 之间独立均匀随机生成  \n- $\\mathbf{K} = 1$  \n\n**测试集 2（27 分，隐藏判定）**\n\n- $1 \\leq \\mathbf{L}_i \\leq 10^9$（生成方式无限制）  \n- $\\mathbf{K} = 10$  \n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13074", "type": "P", "difficulty": 6, "samples": [["4\nCODEJAMWORLDFINALS 2\nAO OY\nxyz 3\nxy zx yz\nCJ 4\n20 2O HC KS\nAB 2\nAb bA", "Case #1: 14\nCase #2: 2\nCase #3: 2\nCase #4: 2"], ["1\n1234 5\n12 2X X3 31 X2", "Case #1: 4"]], "limits": {"time": [60000, 60000, 60000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2020", "网络流", "二分图", "Google Code Jam"], "title": "[GCJ 2020 Finals] Replace All", "background": "", "description": "Banana Rocks Inc is coming up with a revolutionary technology to perform the common edit operation \"replace all\". Their implementation replaces every occurrence of a character within a given text with another character. (If the character does not appear in the text, then the operation occurs but has no effect.)\n\nFor example, if the starting text is `CODEJAMWORLDFINALS` and an operation is performed to replace A with o, the new text would be `CODEJOMWORLDFINOLS`. If another operation is performed on that result to replace o with y, the final text would be `CYDEJYMWYRLDFINYLS`.\n\nUnfortunately, the implementation is incomplete, so it can only perform replacements from a specific list of $\\mathbf{N}$ pairs of characters. Also, even if a replacement of a specific character $c_1$ with another character $c_2$ is implemented, the reverse replacement of $c_2$ with $c_1$ may or may not be implemented.\n\nYou want to try all the implemented replacements. You are given some initial string $\\mathbf{S}$ to use as the initial text. You can perform any number of replacements in sequential order: the first replacement is performed on $\\mathbf{S}$, and the (i+1)-th replacement is performed on the result of performing the i-th replacement. The only requirement is that each implemented replacement is performed at least once during this process. There is no upper limit on how many times you may perform each replacement.\n\nThe allowed characters are decimal digits and uppercase and lowercase English alphabet letters. In this problem, uppercase and lowercase versions of the same letter are treated as distinct characters.\n\nWhat is the maximum number of unique characters that can appear in a text that is the result of the last replacement performed?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line contains a string $\\mathbf{S}$ and an integer $\\mathbf{N}$: the initial text and the number of implemented replacements. The second line contains $\\mathbf{N}$ two-character strings $\\mathbf{R}_1$, $\\mathbf{R}_2$, ..., $\\mathbf{R}_\\mathbf{N}$, representing the implemented replacements. $\\mathbf{A}_i$ and $\\mathbf{B}_i$ are the first and second characters of $\\mathbf{R}_i$, respectively. The i-th implemented replacement corresponds to replacing all occurrences of $\\mathbf{A}_i$ with $\\mathbf{B}_i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where x is the test case number (starting from 1) and y is the maximum number of unique characters that can appear in a text that is the result of performing all implemented replacements to $\\mathbf{S}$ one or more times each, in some order.", "hint": "**Sample Explanation**\n\nSample Test Set 1 meets the limits for Test Set 1. Another sample case that does not meet those limits could appear in Test Set 2.\n\nSample Case #1 is the one in the statement. Notice that if we perform the replacements in the order mentioned in the statement, we get 13 different characters in the final text. If we perform them both once in the other order, however, we can get `CYDEJOMWYRLDFINOLS`, which has 14 different characters.\n\nIn Sample Case #2, one way to get 2 different characters in the final text is to perform the replacements in the order given from left to right, once each.\n\nIn Sample Case #3, none of the replacements affect the text at all, so it does not matter how we apply them. We will always be left with the original two letters. Notice that replacements can contain characters not appearing in the initial text, and the initial text can contain characters not appearing in the implemented replacements.\n\nIn Sample Case #4, remember that uppercase $\\mathbf{B}$ is not the same character as lowercase $\\mathbf{b}$.\n\nIn this additional sample case, one possibility is to perform the replacements in the following order: `X3 2X X2 2X 12 31`. This process goes through the following strings, starting with S: `1234 1234 1X34 1234 1X34 2X34 2X14`.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\text{length of } \\mathbf{S} \\leq 1000$, for all i.\n- Each character of $\\mathbf{S}$ is an uppercase or lowercase English alphabet letter or a decimal digit.\n- $\\mathbf{A}_i$ is an uppercase or lowercase English alphabet letter or a decimal digit, for all i.\n- $\\mathbf{B}_i$ is an uppercase or lowercase English alphabet letter or a decimal digit, for all i.\n- $\\mathbf{A}_i \\neq \\mathbf{B}_i$, for all i.\n- $(\\mathbf{A}_i, \\mathbf{B}_i) \\neq (\\mathbf{A}_j, \\mathbf{B}_j)$, for all $i \\neq j$. (Each replacement is unique.)\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 62$.\n- $\\mathbf{B}_i \\neq \\mathbf{B}_j$, for all $i \\neq j$.\n\n**Test Set 2 (27 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 62 \\times 61$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Finals] Replace All", "background": "", "description": "Banana Rocks Inc is coming up with a revolutionary technology to perform the common edit operation \"replace all\". Their implementation replaces every occurrence of a character within a given text with another character. (If the character does not appear in the text, then the operation occurs but has no effect.)\n\nFor example, if the starting text is `CODEJAMWORLDFINALS` and an operation is performed to replace A with o, the new text would be `CODEJOMWORLDFINOLS`. If another operation is performed on that result to replace o with y, the final text would be `CYDEJYMWYRLDFINYLS`.\n\nUnfortunately, the implementation is incomplete, so it can only perform replacements from a specific list of $\\mathbf{N}$ pairs of characters. Also, even if a replacement of a specific character $c_1$ with another character $c_2$ is implemented, the reverse replacement of $c_2$ with $c_1$ may or may not be implemented.\n\nYou want to try all the implemented replacements. You are given some initial string $\\mathbf{S}$ to use as the initial text. You can perform any number of replacements in sequential order: the first replacement is performed on $\\mathbf{S}$, and the (i+1)-th replacement is performed on the result of performing the i-th replacement. The only requirement is that each implemented replacement is performed at least once during this process. There is no upper limit on how many times you may perform each replacement.\n\nThe allowed characters are decimal digits and uppercase and lowercase English alphabet letters. In this problem, uppercase and lowercase versions of the same letter are treated as distinct characters.\n\nWhat is the maximum number of unique characters that can appear in a text that is the result of the last replacement performed?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line contains a string $\\mathbf{S}$ and an integer $\\mathbf{N}$: the initial text and the number of implemented replacements. The second line contains $\\mathbf{N}$ two-character strings $\\mathbf{R}_1$, $\\mathbf{R}_2$, ..., $\\mathbf{R}_\\mathbf{N}$, representing the implemented replacements. $\\mathbf{A}_i$ and $\\mathbf{B}_i$ are the first and second characters of $\\mathbf{R}_i$, respectively. The i-th implemented replacement corresponds to replacing all occurrences of $\\mathbf{A}_i$ with $\\mathbf{B}_i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where x is the test case number (starting from 1) and y is the maximum number of unique characters that can appear in a text that is the result of performing all implemented replacements to $\\mathbf{S}$ one or more times each, in some order.", "hint": "**Sample Explanation**\n\nSample Test Set 1 meets the limits for Test Set 1. Another sample case that does not meet those limits could appear in Test Set 2.\n\nSample Case #1 is the one in the statement. Notice that if we perform the replacements in the order mentioned in the statement, we get 13 different characters in the final text. If we perform them both once in the other order, however, we can get `CYDEJOMWYRLDFINOLS`, which has 14 different characters.\n\nIn Sample Case #2, one way to get 2 different characters in the final text is to perform the replacements in the order given from left to right, once each.\n\nIn Sample Case #3, none of the replacements affect the text at all, so it does not matter how we apply them. We will always be left with the original two letters. Notice that replacements can contain characters not appearing in the initial text, and the initial text can contain characters not appearing in the implemented replacements.\n\nIn Sample Case #4, remember that uppercase $\\mathbf{B}$ is not the same character as lowercase $\\mathbf{b}$.\n\nIn this additional sample case, one possibility is to perform the replacements in the following order: `X3 2X X2 2X 12 31`. This process goes through the following strings, starting with S: `1234 1234 1X34 1234 1X34 2X34 2X14`.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\text{length of } \\mathbf{S} \\leq 1000$, for all i.\n- Each character of $\\mathbf{S}$ is an uppercase or lowercase English alphabet letter or a decimal digit.\n- $\\mathbf{A}_i$ is an uppercase or lowercase English alphabet letter or a decimal digit, for all i.\n- $\\mathbf{B}_i$ is an uppercase or lowercase English alphabet letter or a decimal digit, for all i.\n- $\\mathbf{A}_i \\neq \\mathbf{B}_i$, for all i.\n- $(\\mathbf{A}_i, \\mathbf{B}_i) \\neq (\\mathbf{A}_j, \\mathbf{B}_j)$, for all $i \\neq j$. (Each replacement is unique.)\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 62$.\n- $\\mathbf{B}_i \\neq \\mathbf{B}_j$, for all $i \\neq j$.\n\n**Test Set 2 (27 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 62 \\times 61$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Finals] Replace All", "background": null, "description": "**Banana Rocks Inc** 正在研发一项革命性技术，用于执行常见的编辑操作“替换所有字符”。他们的实现会将给定文本中某个字符的所有出现替换为另一个字符。（如果该字符未出现在文本中，则操作会执行但无实际效果。）\n\n例如，如果初始文本为 `CODEJAMWORLDFINALS`，执行将 A 替换为 o 的操作后，新文本为 `CODEJOMWORLDFINOLS`。若在该结果上再执行将 o 替换为 y 的操作，最终文本为 `CYDEJYMWYRLDFINYLS`。\n\n遗憾的是，该实现尚未完成，因此只能执行特定列表中的 $\\mathbf{N}$ 对字符的替换。此外，即使实现了将某个字符 $c_1$ 替换为另一个字符 $c_2$ 的操作，反向将 $c_2$ 替换为 $c_1$ 的操作可能实现也可能未实现。\n\n你需要尝试所有已实现的替换操作。给定一个初始字符串 $\\mathbf{S}$ 作为初始文本，你可以按任意顺序执行任意次数的替换操作：第一次替换作用于 $\\mathbf{S}$，第 $(i+1)$ 次替换作用于第 $i$ 次替换后的结果。唯一的要求是在此过程中每个已实现的替换操作至少执行一次。每个替换操作的执行次数无上限。\n\n允许的字符包括十进制数字、大小写英文字母。在此问题中，同一字母的大小写被视为不同字符。\n\n在执行完最后一次替换操作后，最终文本中可能出现的**最大不同字符数**是多少？", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含两行：第一行是一个字符串 $\\mathbf{S}$ 和一个整数 $\\mathbf{N}$，分别表示初始文本和已实现的替换操作数量。第二行包含 $\\mathbf{N}$ 个两字符的字符串 $\\mathbf{R}_1, \\mathbf{R}_2, \\ldots, \\mathbf{R}_\\mathbf{N}$，表示已实现的替换操作。$\\mathbf{A}_i$ 和 $\\mathbf{B}_i$ 分别是 $\\mathbf{R}_i$ 的第一个和第二个字符。第 $i$ 个替换操作表示将所有 $\\mathbf{A}_i$ 替换为 $\\mathbf{B}_i$。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是在以某种顺序对 $\\mathbf{S}$ 执行所有已实现替换操作（每个至少一次）后，最终文本中可能出现的最大不同字符数。", "hint": "**样例解释**\n\n样例测试集 1 符合测试集 1 的限制。另一个不符合这些限制的样例可能出现在测试集 2 中。\n\n样例 #1 对应题目描述中的例子。注意，若按描述中的顺序执行替换操作，最终文本中有 13 个不同字符；但若以相反顺序各执行一次，则可得到 `CYDEJOMWYRLDFINOLS`，其中包含 14 个不同字符。\n\n在样例 #2 中，按从左到右的顺序各执行一次替换操作，最终文本中可得到 2 个不同字符。\n\n在样例 #3 中，所有替换操作均不影响文本，因此执行顺序无关紧要。最终文本始终为原始的两个字母。注意，替换操作可能包含初始文本中未出现的字符，且初始文本也可能包含替换操作中未出现的字符。\n\n在样例 #4 中，请记住大写 $\\mathbf{B}$ 与小写 $\\mathbf{b}$ 是不同的字符。\n\n在此附加样例中，一种可能的替换顺序为 `X3 2X X2 2X 12 31`。该过程从 $\\mathbf{S}$ 开始依次生成以下字符串：`1234 1234 1X34 1234 1X34 2X34 2X14`。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i$，$2 \\leq \\text{初始文本 } \\mathbf{S} \\text{ 的长度} \\leq 1000$。\n- $\\mathbf{S}$ 的每个字符为大写或小写英文字母或十进制数字。\n- 对于所有 $i$，$\\mathbf{A}_i$ 为大写或小写英文字母或十进制数字。\n- 对于所有 $i$，$\\mathbf{B}_i$ 为大写或小写英文字母或十进制数字。\n- 对于所有 $i$，$\\mathbf{A}_i \\neq \\mathbf{B}_i$。\n- 对于所有 $i \\neq j$，$(\\mathbf{A}_i, \\mathbf{B}_i) \\neq (\\mathbf{A}_j, \\mathbf{B}_j)$（每个替换操作唯一）。\n\n**测试集 1（15 分，可见判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 62$。\n- 对于所有 $i \\neq j$，$\\mathbf{B}_i \\neq \\mathbf{B}_j$。\n\n**测试集 2（27 分，隐藏判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 62 \\times 61$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
