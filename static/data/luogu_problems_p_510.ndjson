{"pid": "P11345", "type": "P", "difficulty": 6, "samples": [["5\n0 2 2\n2 1 3\n2 4 6\n0 3 5", "98"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["树上启发式合并", "2023", "交互题", "KOI（韩国）", "STL"], "title": "[KTSC 2023 R2] 基地简化", "background": "**请勿用 C++14 (GCC 9) 提交。**\n\n请在程序开头加入如下代码：\n\n```cpp\n#include<vector>\nint maintenance_costs_sum(std::vector<int> U, std::vector<int> V, std::vector<int> W);\n```", "description": "**题目译自 [2023년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2023/)  T1 「[기지 간소화](https://assets.ioikorea.kr/ioitst/2023/2/base/base_statement.pdf)」**\n\n在遥远的未来，人类已经扩展到许多外星行星。行星 X 是其中之一，宇宙探险公司 MR 在行星 X 上建立了基地，进行探险和资源采集活动。\n\n行星 X 上有 $N$ 个基地和连接这些基地的 $N-1$ 条双向通道，任意两个不同的基地都可以通过这些通道互相到达。也就是说，行星 X 的基地和通道构成了一棵树。\n\n每个基地都有一个编号，从 $0$ 到 $N-1$。对于每个 $i$ $(0 \\leq i \\leq N-2)$，第 $i$ 条通道连接 $U[i]$ 号基地和 $V[i]$ 号基地，通道的长度为 $W[i]$ 公里。\n\n随着行星 X 的开发逐渐稳定，维护所有基地和通道的成本变得很高，因此 MR 决定只保留部分基地，其他的将被停用。\n\n假设只保留编号为 $s$ 到 $e$ 的基地 $(0 \\leq s \\leq e \\leq N-1)$。此时的维护成本定义如下：\n\n- 选择 $0$ 条或更多的通道，使得以下条件得到满足，并且选择的通道长度之和最小（选择 $0$ 条通道时，长度之和为 $0$ 公里）。\n- 对于任意 $u, v$ $(s \\leq u < v \\leq e)$，$u$ 号基地和 $v$ 号基地可以通过选择的通道互相到达，中间经过停用的基地也没关系。\n- 选择的通道长度之和为 $C$ 公里时，维护成本为 $C$。\n\n由于尚未决定保留哪些基地，MR 希望知道所有可能的 $(i, j)$ $(0 \\leq i \\leq j \\leq N-1)$ 组合下，只保留编号为 $i$ 到 $j$ 的基地时的维护成本之和。你需要为 MR 计算这个值。由于结果可能非常大，请对 $1000000007$ 取模。\n\n你需要实现以下函数：\n\n```cpp\nint maintenance_costs_sum(vector<int> U, vector<int> V, vector<int> W);\n```\n\n- 该函数只会被调用一次。\n- `U, V, W`：大小为 $N-1$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq N-2)$，$U[i]$ 号基地和 $V[i]$ 号基地之间有一条长度为 $W[i]$ 公里的通道。\n- 该函数返回所有可能的 $(i, j)$ $(0 \\leq i \\leq j \\leq N-1)$ 组合下，只保留编号为 $i$ 到 $j$ 的基地时的维护成本之和，对 $1000000007$ 取模的结果。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2+i$ $(0 \\leq i \\leq N-2)$ 行：$U[i]\\,V[i]\\,W[i]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $1$ 行：函数 `maintenance_costs_sum` 返回的值", "hint": "对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 2.5\\cdot 10^5$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$0 \\leq U[i], V[i] \\leq N-1 ; U[i] \\neq V[i]$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$1 \\leq W[i] \\leq 10^9$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $5$ | $N \\leq 300$ |\n| $2$ | $6$ | $N \\leq 4000$ |\n| $3$ | $10$ | 基地的编号是以 $0$ 号基地为根的树的前序遍历顺序之一 |\n| $4$ | $26$ | 每个基地最多连接 $2$ 条通道 |\n| $5$ | $53$ | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2023 R2] 基地简化", "background": "**请勿用 C++14 (GCC 9) 提交。**\n\n请在程序开头加入如下代码：\n\n```cpp\n#include<vector>\nint maintenance_costs_sum(std::vector<int> U, std::vector<int> V, std::vector<int> W);\n```", "description": "**题目译自 [2023년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2023/)  T1 「[기지 간소화](https://assets.ioikorea.kr/ioitst/2023/2/base/base_statement.pdf)」**\n\n在遥远的未来，人类已经扩展到许多外星行星。行星 X 是其中之一，宇宙探险公司 MR 在行星 X 上建立了基地，进行探险和资源采集活动。\n\n行星 X 上有 $N$ 个基地和连接这些基地的 $N-1$ 条双向通道，任意两个不同的基地都可以通过这些通道互相到达。也就是说，行星 X 的基地和通道构成了一棵树。\n\n每个基地都有一个编号，从 $0$ 到 $N-1$。对于每个 $i$ $(0 \\leq i \\leq N-2)$，第 $i$ 条通道连接 $U[i]$ 号基地和 $V[i]$ 号基地，通道的长度为 $W[i]$ 公里。\n\n随着行星 X 的开发逐渐稳定，维护所有基地和通道的成本变得很高，因此 MR 决定只保留部分基地，其他的将被停用。\n\n假设只保留编号为 $s$ 到 $e$ 的基地 $(0 \\leq s \\leq e \\leq N-1)$。此时的维护成本定义如下：\n\n- 选择 $0$ 条或更多的通道，使得以下条件得到满足，并且选择的通道长度之和最小（选择 $0$ 条通道时，长度之和为 $0$ 公里）。\n- 对于任意 $u, v$ $(s \\leq u < v \\leq e)$，$u$ 号基地和 $v$ 号基地可以通过选择的通道互相到达，中间经过停用的基地也没关系。\n- 选择的通道长度之和为 $C$ 公里时，维护成本为 $C$。\n\n由于尚未决定保留哪些基地，MR 希望知道所有可能的 $(i, j)$ $(0 \\leq i \\leq j \\leq N-1)$ 组合下，只保留编号为 $i$ 到 $j$ 的基地时的维护成本之和。你需要为 MR 计算这个值。由于结果可能非常大，请对 $1000000007$ 取模。\n\n你需要实现以下函数：\n\n```cpp\nint maintenance_costs_sum(vector<int> U, vector<int> V, vector<int> W);\n```\n\n- 该函数只会被调用一次。\n- `U, V, W`：大小为 $N-1$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq N-2)$，$U[i]$ 号基地和 $V[i]$ 号基地之间有一条长度为 $W[i]$ 公里的通道。\n- 该函数返回所有可能的 $(i, j)$ $(0 \\leq i \\leq j \\leq N-1)$ 组合下，只保留编号为 $i$ 到 $j$ 的基地时的维护成本之和，对 $1000000007$ 取模的结果。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2+i$ $(0 \\leq i \\leq N-2)$ 行：$U[i]\\,V[i]\\,W[i]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $1$ 行：函数 `maintenance_costs_sum` 返回的值", "hint": "对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 2.5\\cdot 10^5$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$0 \\leq U[i], V[i] \\leq N-1 ; U[i] \\neq V[i]$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$1 \\leq W[i] \\leq 10^9$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $5$ | $N \\leq 300$ |\n| $2$ | $6$ | $N \\leq 4000$ |\n| $3$ | $10$ | 基地的编号是以 $0$ 号基地为根的树的前序遍历顺序之一 |\n| $4$ | $26$ | 每个基地最多连接 $2$ 条通道 |\n| $5$ | $53$ | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P11346", "type": "P", "difficulty": 7, "samples": [["4\n1 2\n3 4\n5 6\n7 8", "24"], ["10\n1 5\n2 3\n4 7\n6 11\n8 9\n10 15\n12 13\n14 20\n16 17\n18 19", "13280"], ["10\n1 20\n2 9\n3 4\n5 8\n6 7\n10 17\n11 16\n12 13\n14 15\n18 19", "845040"], ["10\n1 5\n2 9\n3 10\n4 12\n6 14\n7 16\n8 17\n11 18\n13 19\n15 20", "1797408"], ["10\n12 16\n5 7\n10 19\n2 3\n4 6\n17 20\n8 11\n1 15\n14 18\n9 13", "647760"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2023", "交互题", "KOI（韩国）"], "title": "[KTSC 2023 R2] 会议室 2", "background": "**请勿用 C++14 (GCC 9) 提交。**\n\n请在代码开头加入如下代码：\n\n```cpp\n#include<vector>\nint count_removals(std::vector<int> S, std::vector<int> E);\n```", "description": "**题目译自 [2023년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2023/)  T2 「[회의실 2](https://assets.ioikorea.kr/ioitst/2023/2/meeting2/meeting2_statement.pdf)」**\n\nKDH 公司每天会举行 $N$ 场会议。每场会议都有一个编号，从 $0$ 到 $N-1$。对于每个 $i$ $(0 \\leq i \\leq N-1)$，第 $i$ 场会议在时间 $S[i]$ 开始，在时间 $E[i]$ 结束。\n\nKDH 公司安排会议的方式很特别。如果某一天进行的两场不同会议 $i$ 和 $j$ 满足以下条件之一，则称这两场会议在该天是相关的：\n\n- 两场会议有重叠的时间段。\n- 存在第三场会议 $k$，使得 $i$ 和 $j$ 都与 $k$ 相关。\n\n如果两场会议 $i$ 和 $j$ 在该天不是相关的，则称它们在该天是无关的。KDH 公司在安排会议时，会将每场会议分配到特定的会议室。要求在同一天内，无关的会议不能分配到同一个会议室。KDH 公司会选择满足这些条件的分配方案中所需会议室数量最少的方案。所需的最少会议室数量称为会议的成本。\n\nKDH 公司认为目前的会议安排浪费了太多资源，决定将会议数量减少到只剩一场。为此，KDH 公司将在 $N-1$ 天内每天进行以下操作：\n\n- 选择一个尚未取消的会议。\n- 从当天起永久取消该会议。\n- 进行所有未取消的会议。\n\n当这个过程结束时，除了最后一场会议外，所有会议都被取消。最后剩下的会议是哪一场并不重要。\n\n为了进一步节省成本，KDH 公司希望找到一种方法，使得在 $N-1$ 天内每天的总成本最小。你需要计算出有多少种方法可以实现这一目标。两种方法相同的定义是：在 $N-1$ 天内每天选择取消的会议完全相同。即使剩下的会议分配方式不同，只要每天取消的会议相同，就认为是相同的方法。由于方法数量可能非常大，结果需要对 $1000000007$ 取模。\n\n你需要实现以下函数：\n\n```cpp\nint count_removals(vector<int> S, vector<int> E);\n```\n\n- `S, E`：大小为 $N$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq N-1)$，第 $i$ 场会议在时间 $S[i]$ 开始，在时间 $E[i]$ 结束。\n- 该函数返回在 $N-1$ 天内每天的总成本最小的情况下，选择取消会议的方法数量，对 $1000000007$ 取模。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2+i$ $(0 \\leq i \\leq N-1)$ 行：$S[i]\\,E[i]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $1$ 行：函数 `count_removals` 返回的值", "hint": "### 样例 1 解释\n\n考虑 $N=4, S=[1,3,5,7], E=[2,4,6,8]$ 的情况。\n\n评测程序将调用如下函数：\n\n```cpp\ncount_removals([1,3,5,7], [2,4,6,8]);\n```\n\n无论选择哪种方式取消会议，每天所需的会议室数量（即成本）依次为 $3$、$2$、$1$，总成本为 $6$。因此，所有方法都是可行的。\n\n函数应返回 `24`。\n\n### 数据范围\n\n对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 2000$\n- 对于每个 $i$ $(0 \\leq i \\leq N-1)$，$1 \\leq S[i] < E[i] \\leq 2N$\n- 对于每个 $i,j$ $(0 \\leq i < j \\leq N-1)$，$S[i] \\neq S[j], S[i] \\neq E[j], E[i] \\neq S[j], E[i] \\neq E[j]$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $3$ | $N \\leq 10$；$S[0]=1, E[0]=2N$ |\n| $2$ | $8$ | $N \\leq 20$ |\n| $3$ | $30$ | $N \\leq 300$ |\n| $4$ | $12$ | 任意时刻进行的会议最多为 $2$ 场 |\n| $5$ | $12$ | 对于每个 $i,j$ $(0 \\leq i, j \\leq N-1)$，不存在 $i \\neq j, S[i] < S[j] < E[i] < E[j]$ 的 $i, j$ 对 |\n| $6$ | $10$ | 对于每个 $i,j$ $(0 \\leq i, j \\leq N-1)$，不存在 $i \\neq j, S[i] < S[j] < E[j] < E[i]$ 的 $i, j$ 对 |\n| $7$ | $25$ | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2023 R2] 会议室 2", "background": "**请勿用 C++14 (GCC 9) 提交。**\n\n请在代码开头加入如下代码：\n\n```cpp\n#include<vector>\nint count_removals(std::vector<int> S, std::vector<int> E);\n```", "description": "**题目译自 [2023년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2023/)  T2 「[회의실 2](https://assets.ioikorea.kr/ioitst/2023/2/meeting2/meeting2_statement.pdf)」**\n\nKDH 公司每天会举行 $N$ 场会议。每场会议都有一个编号，从 $0$ 到 $N-1$。对于每个 $i$ $(0 \\leq i \\leq N-1)$，第 $i$ 场会议在时间 $S[i]$ 开始，在时间 $E[i]$ 结束。\n\nKDH 公司安排会议的方式很特别。如果某一天进行的两场不同会议 $i$ 和 $j$ 满足以下条件之一，则称这两场会议在该天是相关的：\n\n- 两场会议有重叠的时间段。\n- 存在第三场会议 $k$，使得 $i$ 和 $j$ 都与 $k$ 相关。\n\n如果两场会议 $i$ 和 $j$ 在该天不是相关的，则称它们在该天是无关的。KDH 公司在安排会议时，会将每场会议分配到特定的会议室。要求在同一天内，无关的会议不能分配到同一个会议室。KDH 公司会选择满足这些条件的分配方案中所需会议室数量最少的方案。所需的最少会议室数量称为会议的成本。\n\nKDH 公司认为目前的会议安排浪费了太多资源，决定将会议数量减少到只剩一场。为此，KDH 公司将在 $N-1$ 天内每天进行以下操作：\n\n- 选择一个尚未取消的会议。\n- 从当天起永久取消该会议。\n- 进行所有未取消的会议。\n\n当这个过程结束时，除了最后一场会议外，所有会议都被取消。最后剩下的会议是哪一场并不重要。\n\n为了进一步节省成本，KDH 公司希望找到一种方法，使得在 $N-1$ 天内每天的总成本最小。你需要计算出有多少种方法可以实现这一目标。两种方法相同的定义是：在 $N-1$ 天内每天选择取消的会议完全相同。即使剩下的会议分配方式不同，只要每天取消的会议相同，就认为是相同的方法。由于方法数量可能非常大，结果需要对 $1000000007$ 取模。\n\n你需要实现以下函数：\n\n```cpp\nint count_removals(vector<int> S, vector<int> E);\n```\n\n- `S, E`：大小为 $N$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq N-1)$，第 $i$ 场会议在时间 $S[i]$ 开始，在时间 $E[i]$ 结束。\n- 该函数返回在 $N-1$ 天内每天的总成本最小的情况下，选择取消会议的方法数量，对 $1000000007$ 取模。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2+i$ $(0 \\leq i \\leq N-1)$ 行：$S[i]\\,E[i]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $1$ 行：函数 `count_removals` 返回的值", "hint": "### 样例 1 解释\n\n考虑 $N=4, S=[1,3,5,7], E=[2,4,6,8]$ 的情况。\n\n评测程序将调用如下函数：\n\n```cpp\ncount_removals([1,3,5,7], [2,4,6,8]);\n```\n\n无论选择哪种方式取消会议，每天所需的会议室数量（即成本）依次为 $3$、$2$、$1$，总成本为 $6$。因此，所有方法都是可行的。\n\n函数应返回 `24`。\n\n### 数据范围\n\n对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 2000$\n- 对于每个 $i$ $(0 \\leq i \\leq N-1)$，$1 \\leq S[i] < E[i] \\leq 2N$\n- 对于每个 $i,j$ $(0 \\leq i < j \\leq N-1)$，$S[i] \\neq S[j], S[i] \\neq E[j], E[i] \\neq S[j], E[i] \\neq E[j]$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $3$ | $N \\leq 10$；$S[0]=1, E[0]=2N$ |\n| $2$ | $8$ | $N \\leq 20$ |\n| $3$ | $30$ | $N \\leq 300$ |\n| $4$ | $12$ | 任意时刻进行的会议最多为 $2$ 场 |\n| $5$ | $12$ | 对于每个 $i,j$ $(0 \\leq i, j \\leq N-1)$，不存在 $i \\neq j, S[i] < S[j] < E[i] < E[j]$ 的 $i, j$ 对 |\n| $6$ | $10$ | 对于每个 $i,j$ $(0 \\leq i, j \\leq N-1)$，不存在 $i \\neq j, S[i] < S[j] < E[j] < E[i]$ 的 $i, j$ 对 |\n| $7$ | $25$ | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P11347", "type": "P", "difficulty": 5, "samples": [["6 3\n1 4\n2 5\n3 3", "1\n3"], ["10 4\n1 4\n4 7\n8 9\n2 6", "2\n4 8 9"], ["5 1\n0 4", "1\n0 1 2 3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2023", "交互题", "KOI（韩国）"], "title": "[KTSC 2023 R2] 学生", "background": "**请勿用 C++14 (GCC 9) 提交。**\n\n```cpp\n#include<vector>\nstd::pair<int, std::vector<int>> complaint(int N, std::vector<int> L, std::vector<int> R);\n```", "description": "**题目译自 [2023년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2023/)  T3 「[학생들](https://assets.ioikorea.kr/ioitst/2023/2/students/students_statement.pdf)」**\n\n在 IOI 大学，学生们不是用名字，而是用考试排名来称呼彼此。这所大学有 $N$ 名学生，对于每个 $i$ $(0 \\leq i \\leq N-1)$，第 $i$ 名学生在期中考试中排名第 $i+1$。\n\n为了准备期末考试，学生们自发组成了辅导小组。每个辅导小组可以用两个整数 $0 \\leq L \\leq R \\leq N-1$ 表示，表示编号在 $L$ 到 $R$ 之间的学生不在这个小组中，其他学生都在这个小组中。\n\n某天早晨，IOI 大学的所有学生都收到了一封邮件，通知他们至少存在一个辅导小组。这一天被称为第 $1$ 天早晨。从第 $d \\geq 1$ 天晚上开始，以下情况会发生：\n\n- 如果某个学生在第 $d$ 天早晨之后推断出存在一个不包含自己的辅导小组，他会感到不公平，并在第 $d$ 天晚上结束前提交投诉。一旦投诉提交，所有辅导小组的活动将在第 $d+1$ 天早晨之前结束。\n- 如果没有学生推断出存在一个不包含自己的辅导小组，则没有投诉提交，辅导小组的活动会在第 $d+1$ 天早晨继续。所有学生都会意识到没有人在第 $d$ 天提交投诉。\n\n除此之外，学生们不会以任何方式共享信息。也就是说，他们只能知道自己所在的辅导小组及其成员，以及是否有投诉提交。学生们总是根据自己掌握的信息进行推断，不会推断出可能错误的结论。\n\n你是 IOI 大学所有学生的朋友，知道所有辅导小组及其成员。当给定 $M$ 个辅导小组的信息时，请编写一个程序，找出投诉提交的日期 $k$ 以及在第 $k$ 天提交投诉的学生编号。如果永远没有投诉提交，则返回 `-1`。\n\n请注意，只有你作为外部人知道所有辅导小组的信息，包括小组的数量 $M$、每个小组的成员、问题的整体限制和部分限制等。学生们对此一无所知。\n\n你需要实现以下函数：\n\n```cpp\npair<int, vector<int>> complaint(int N, vector<int> L, vector<int> R);\n```\n\n- `L, R`：大小为 $M$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq M-1)$，第 $i$ 个辅导小组由编号小于 $L[i]$ 或大于 $R[i]$ 的学生组成。\n- 该函数返回一个由整数 $k$ 和一个大小不超过 $N$ 的整数数组 $V$ 组成的对。$k$ 是投诉提交的日期，$V$ 是在第 $k$ 天提交投诉的学生编号，按升序排列。如果永远没有投诉提交，则 $k$ 为 $-1$，$V$ 为空数组。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,M$\n- 第 $2+i$ $(0 \\leq i \\leq M-1)$ 行：$L[i]\\,R[i]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $1$ 行：函数 `complaint` 返回的值 $k$\n- 第 $2$ 行：函数 `complaint` 返回的数组 $V$ 的元素，以空格分隔", "hint": "### 样例 1 解释\n\n考虑 $N=6, M=3, L=[1,2,3], R=[4,5,3]$ 的情况。\n\n评测程序将调用如下函数：\n\n```cpp\ncomplaint(6, [1, 2, 3], [4, 5, 3]);\n```\n\n由于第 $3$ 号学生被所有辅导小组排除在外，他会在第一天立即提交投诉。其他学生在第一天不会提交投诉。因此，函数应返回 `(1, [3])`。\n\n### 数据范围\n\n对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 2.5\\cdot 10^5$\n- $1 \\leq M \\leq 2.5\\cdot 10^5$\n- 对于每个 $i$ $(0 \\leq i \\leq M-1)$，$0 \\leq L[i] \\leq R[i] \\leq N-1$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $12$ | $N, M \\leq 10$ |\n| $2$ | $6$ | 对于每个 $i$ $(0 \\leq i \\leq M-1)$，$L[i]=R[i]$ |\n| $3$ | $15$ | $N, M \\leq 2500$ |\n| $4$ | $10$ | 对于每个 $i$ $(0 \\leq i, j \\leq M-1)$，区间 $[L[i], R[i]]$ 和 $[L[j], R[j]]$ 互不相交或包含彼此。即如果 $L[i] < L[j]$，则 $R[i] < L[j]$ 或 $R[j] \\leq R[i]$ |\n| $5$ | $18$ | 对于每个 $i$ $(0 \\leq i \\leq M-2)$，$L[i] < L[i+1], R[i] < R[i+1]$ |\n| $6$ | $39$ | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2023 R2] 学生", "background": "**请勿用 C++14 (GCC 9) 提交。**\n\n```cpp\n#include<vector>\nstd::pair<int, std::vector<int>> complaint(int N, std::vector<int> L, std::vector<int> R);\n```", "description": "**题目译自 [2023년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2023/)  T3 「[학생들](https://assets.ioikorea.kr/ioitst/2023/2/students/students_statement.pdf)」**\n\n在 IOI 大学，学生们不是用名字，而是用考试排名来称呼彼此。这所大学有 $N$ 名学生，对于每个 $i$ $(0 \\leq i \\leq N-1)$，第 $i$ 名学生在期中考试中排名第 $i+1$。\n\n为了准备期末考试，学生们自发组成了辅导小组。每个辅导小组可以用两个整数 $0 \\leq L \\leq R \\leq N-1$ 表示，表示编号在 $L$ 到 $R$ 之间的学生不在这个小组中，其他学生都在这个小组中。\n\n某天早晨，IOI 大学的所有学生都收到了一封邮件，通知他们至少存在一个辅导小组。这一天被称为第 $1$ 天早晨。从第 $d \\geq 1$ 天晚上开始，以下情况会发生：\n\n- 如果某个学生在第 $d$ 天早晨之后推断出存在一个不包含自己的辅导小组，他会感到不公平，并在第 $d$ 天晚上结束前提交投诉。一旦投诉提交，所有辅导小组的活动将在第 $d+1$ 天早晨之前结束。\n- 如果没有学生推断出存在一个不包含自己的辅导小组，则没有投诉提交，辅导小组的活动会在第 $d+1$ 天早晨继续。所有学生都会意识到没有人在第 $d$ 天提交投诉。\n\n除此之外，学生们不会以任何方式共享信息。也就是说，他们只能知道自己所在的辅导小组及其成员，以及是否有投诉提交。学生们总是根据自己掌握的信息进行推断，不会推断出可能错误的结论。\n\n你是 IOI 大学所有学生的朋友，知道所有辅导小组及其成员。当给定 $M$ 个辅导小组的信息时，请编写一个程序，找出投诉提交的日期 $k$ 以及在第 $k$ 天提交投诉的学生编号。如果永远没有投诉提交，则返回 `-1`。\n\n请注意，只有你作为外部人知道所有辅导小组的信息，包括小组的数量 $M$、每个小组的成员、问题的整体限制和部分限制等。学生们对此一无所知。\n\n你需要实现以下函数：\n\n```cpp\npair<int, vector<int>> complaint(int N, vector<int> L, vector<int> R);\n```\n\n- `L, R`：大小为 $M$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq M-1)$，第 $i$ 个辅导小组由编号小于 $L[i]$ 或大于 $R[i]$ 的学生组成。\n- 该函数返回一个由整数 $k$ 和一个大小不超过 $N$ 的整数数组 $V$ 组成的对。$k$ 是投诉提交的日期，$V$ 是在第 $k$ 天提交投诉的学生编号，按升序排列。如果永远没有投诉提交，则 $k$ 为 $-1$，$V$ 为空数组。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,M$\n- 第 $2+i$ $(0 \\leq i \\leq M-1)$ 行：$L[i]\\,R[i]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $1$ 行：函数 `complaint` 返回的值 $k$\n- 第 $2$ 行：函数 `complaint` 返回的数组 $V$ 的元素，以空格分隔", "hint": "### 样例 1 解释\n\n考虑 $N=6, M=3, L=[1,2,3], R=[4,5,3]$ 的情况。\n\n评测程序将调用如下函数：\n\n```cpp\ncomplaint(6, [1, 2, 3], [4, 5, 3]);\n```\n\n由于第 $3$ 号学生被所有辅导小组排除在外，他会在第一天立即提交投诉。其他学生在第一天不会提交投诉。因此，函数应返回 `(1, [3])`。\n\n### 数据范围\n\n对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 2.5\\cdot 10^5$\n- $1 \\leq M \\leq 2.5\\cdot 10^5$\n- 对于每个 $i$ $(0 \\leq i \\leq M-1)$，$0 \\leq L[i] \\leq R[i] \\leq N-1$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $12$ | $N, M \\leq 10$ |\n| $2$ | $6$ | 对于每个 $i$ $(0 \\leq i \\leq M-1)$，$L[i]=R[i]$ |\n| $3$ | $15$ | $N, M \\leq 2500$ |\n| $4$ | $10$ | 对于每个 $i$ $(0 \\leq i, j \\leq M-1)$，区间 $[L[i], R[i]]$ 和 $[L[j], R[j]]$ 互不相交或包含彼此。即如果 $L[i] < L[j]$，则 $R[i] < L[j]$ 或 $R[j] \\leq R[i]$ |\n| $5$ | $18$ | 对于每个 $i$ $(0 \\leq i \\leq M-2)$，$L[i] < L[i+1], R[i] < R[i+1]$ |\n| $6$ | $39$ | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P11348", "type": "P", "difficulty": 6, "samples": [["5 4\n2 10\n7 9\n8 8\n9 6\n10 1\n1 10\n3 8\n5 7\n9 5\n3\n0 4 1 3\n2 3 0 2\n1 1 0 0", "224\n195\n152"], ["4 2\n1 9\n6 5\n8 3\n10 1\n5 8\n6 7\n4\n0 0 0 1\n1 1 0 1\n2 2 0 1\n3 3 0 1", "112\n144\n143\n135"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2023", "交互题", "KOI（韩国）"], "title": "[KTSC 2023 R2] 团队建设", "background": "**请勿用 C++14 (GCC 9) 提交。**\n\n请在程序开头加入如下代码：\n\n```cpp\nstd::vector<long long> build_teams(std::vector<int> A1, std::vector<int> B1, std::vector<int> A2, std::vector<int> B2, std::vector<int> L1, std::vector<int> R1, std::vector<int> L2, std::vector<int> R2);\n```", "description": "**题目译自 [2023년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2023/)  T4 「[팀 만들기](https://assets.ioikorea.kr/ioitst/2023/2/teambuilding/teambuilding_statement.pdf)」**\n\n在 20XX 年的国际信息学奥林匹克竞赛中，新增了一个混合项目。在这个项目中，一名男生和一名女生将组成一个团队来解决问题。为了组建代表队参加混合项目，信息学奥林匹克竞赛委员会选拔了 $N$ 名男生候选人和 $M$ 名女生候选人。每个男生候选人从 $0$ 到 $N-1$ 编号，每个女生候选人从 $0$ 到 $M-1$ 编号。\n\n团队的实力取决于两名学生的思维能力和编程能力。学生的思维能力和编程能力可以用 $1$ 到 $10^9$ 之间的整数表示。第 $i$ 名男生的思维能力是 $A_1[i]$，编程能力是 $B_1[i]$。第 $j$ 名女生的思维能力是 $A_2[j]$，编程能力是 $B_2[j]$。如果第 $i$ 名男生和第 $j$ 名女生组成一个团队，那么这个团队的实力定义为 $\\left(A_1[i] + A_2[j]\\right) \\times \\left(B_1[i] + B_2[j]\\right)$。\n\n由于所有学生都是经过激烈竞争选拔出来的，因此不存在某个男生在思维能力和编程能力上都优于另一个男生的情况。更具体地说，男生的思维能力随着编号的增加而增加，编程能力随着编号的增加而减少。即，对于 $i$ $(0 \\leq i \\leq N-2)$，有 $A_1[i] < A_1[i+1]$ 和 $B_1[i] > B_1[i+1]$。女生也是如此，思维能力随着编号的增加而增加，编程能力随着编号的增加而减少。即，对于 $0 \\leq j \\leq M-2$，有 $A_2[j] < A_2[j+1]$ 和 $B_2[j] > B_2[j+1]$。\n\n信息学奥林匹克竞赛委员会希望根据不同的场景组建实力最强的团队。共有 $Q$ 个场景，每个场景编号从 $0$ 到 $Q-1$。在第 $k$ 个场景中，男生的编号必须在 $L_1[k]$ 到 $R_1[k]$ 之间，女生的编号必须在 $L_2[k]$ 到 $R_2[k]$ 之间。请编写一个程序，计算每个场景中可以组建的团队的最大实力。\n\n你需要实现以下函数：\n\n```cpp\nvector<long long> build_teams(vector<int> A1, vector<int> B1, vector<int> A2, vector<int> B2, vector<int> L1, vector<int> R1, vector<int> L2, vector<int> R2);\n```\n\n- `A1, B1`：长度为 $N$ 的数组。第 $i$ $(0 \\leq i \\leq N-1)$ 名男生的思维能力是 $A1[i]$，编程能力是 $B1[i]$。\n- `A2, B2`：长度为 $M$ 的数组。第 $j$ $(0 \\leq j \\leq M-1)$ 名女生的思维能力是 $A2[j]$，编程能力是 $B2[j]$。\n- `L1, R1, L2, R2`：长度为 $Q$ 的数组。在第 $k$ $(0 \\leq k \\leq Q-1)$ 个场景中，男生的编号必须在 $L1[k]$ 到 $R1[k]$ 之间，女生的编号必须在 $L2[k]$ 到 $R2[k]$ 之间。\n- 该函数返回一个长度为 $Q$ 的数组 $C$。$C[k]$ 是第 $k$ 个场景中可以组建的团队的最大实力。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,M$\n- 第 $2+i$ $(0 \\leq i \\leq N-1)$ 行：$A1[i]\\,B1[i]$\n- 第 $2+N+j$ $(0 \\leq j \\leq M-1)$ 行：$A2[j]\\,B2[j]$\n- 第 $2+N+M$ 行：$Q$\n- 第 $3+N+M+k$ $(0 \\leq k \\leq Q-1)$ 行：$L1[k]\\,R1[k]\\,L2[k]\\,R2[k]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $1+k$ $(0 \\leq k \\leq Q-1)$ 行：函数 `build_teams` 返回的数组的第 $k$ 个元素", "hint": "### 样例 1 解释\n\n考虑 $N=5, M=4, A1=[2,7,8,9,10], B1=[10,9,8,6,1], A2=[1,3,5,9], B2=[10,8,7,5], Q=3, L1=[0,2,1], R1=[4,3,1], L2=[1,0,0], R2=[3,2,0]$ 的情况。\n\n评测程序将调用如下函数：\n\n```cpp\nbuild_teams([2,7,8,9,10], [10,9,8,6,1], [1,3,5,9], [10,8,7,5], [0,2,1], [4,3,1], [1,0,0], [3,2,0]);\n```\n\n在第 $0$ 个场景中，男生的编号必须在 $0$ 到 $4$ 之间，女生的编号必须在 $1$ 到 $3$ 之间。选择 $1$ 号男生和 $3$ 号女生组成团队，团队的实力为 $(7+9) \\times (9+5) = 224$。这是满足条件的团队中实力最大的。\n\n在第 $1$ 个场景中，男生的编号必须在 $2$ 到 $3$ 之间，女生的编号必须在 $0$ 到 $2$ 之间。选择 $2$ 号男生和 $2$ 号女生组成团队，团队的实力为 $(8+5) \\times (8+7) = 195$。这是满足条件的团队中实力最大的。\n\n在第 $2$ 个场景中，男生的编号必须是 $1$，女生的编号必须是 $0$。团队的实力为 $(7+1) \\times (9+10) = 152$。\n\n因此，函数应返回 `[224,195,152]`。\n\n### 样例 2 解释\n\n考虑 $N=4, M=2, A1=[1,6,8,10], B1=[9,5,3,1], A2=[5,6], B2=[8,7], Q=4, L1=[0,1,2,3], R1=[0,1,2,3], L2=[0,0,0,0], R2=[1,1,1,1]$ 的情况。\n\n评测程序将调用如下函数：\n\n```cpp\nbuild_teams([1,6,8,10], [9,5,3,1], [5,6], [8,7], [0,1,2,3], [0,1,2,3], [0,0,0,0], [1,1,1,1]);\n```\n\n在第 $0$ 个场景中，选择 $0$ 号男生和 $1$ 号女生组成团队，团队的实力为 $(1+6) \\times (9+7) = 112$。\n\n在第 $1$ 个场景中，选择 $1$ 号男生和 $1$ 号女生组成团队，团队的实力为 $(6+6) \\times (5+7) = 144$。\n\n在第 $2$ 个场景中，选择 $2$ 号男生和 $0$ 号女生组成团队，团队的实力为 $(8+5) \\times (3+8) = 143$。\n\n在第 $3$ 个场景中，选择 $3$ 号男生和 $0$ 号女生组成团队，团队的实力为 $(10+5) \\times (1+8) = 135$。\n\n这些都是满足条件的团队中实力最大的。因此，函数应返回 `[112,144,143,135]`。\n\n### 数据范围\n\n对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 10^5$\n- $1 \\leq M \\leq 10^5$\n- 对于每个 $i$ $(0 \\leq i \\leq N-1)$，$1 \\leq A1[i], B1[i] \\leq 10^9$\n- 对于每个 $j$ $(0 \\leq j \\leq M-1)$，$1 \\leq A2[j], B2[j] \\leq 10^9$\n- 对于每个 $i$ $(0 \\leq i \\leq N-2)$，$A1[i] < A1[i+1], B1[i] > B1[i+1]$\n- 对于每个 $j$ $(0 \\leq j \\leq M-2)$，$A2[j] < A2[j+1], B2[j] > B2[j+1]$\n- $1 \\leq Q \\leq 10^5$\n- 对于每个 $k$ $(0 \\leq k \\leq Q-1)$，$0 \\leq L1[k] \\leq R1[k] \\leq N-1$\n- 对于每个 $k$ $(0 \\leq k \\leq Q-1)$，$0 \\leq L2[k] \\leq R2[k] \\leq M-1$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $5$ | $N \\leq 500, M \\leq 500, Q \\leq 500$ |\n| $2$ | $10$ | $Q \\leq 20$ |\n| $3$ | $10$ | 对于每个 $k$ $(0 \\leq k \\leq Q-1)$，$L2[k]=0, R2[k]=M-1$ |\n| $4$ | $35$ | 对于每个 $k$ $(0 \\leq k \\leq Q-1)$，$L2[k]=R2[k]$ |\n| $5$ | $40$ | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2023 R2] 团队建设", "background": "**请勿用 C++14 (GCC 9) 提交。**\n\n请在程序开头加入如下代码：\n\n```cpp\nstd::vector<long long> build_teams(std::vector<int> A1, std::vector<int> B1, std::vector<int> A2, std::vector<int> B2, std::vector<int> L1, std::vector<int> R1, std::vector<int> L2, std::vector<int> R2);\n```", "description": "**题目译自 [2023년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2023/)  T4 「[팀 만들기](https://assets.ioikorea.kr/ioitst/2023/2/teambuilding/teambuilding_statement.pdf)」**\n\n在 20XX 年的国际信息学奥林匹克竞赛中，新增了一个混合项目。在这个项目中，一名男生和一名女生将组成一个团队来解决问题。为了组建代表队参加混合项目，信息学奥林匹克竞赛委员会选拔了 $N$ 名男生候选人和 $M$ 名女生候选人。每个男生候选人从 $0$ 到 $N-1$ 编号，每个女生候选人从 $0$ 到 $M-1$ 编号。\n\n团队的实力取决于两名学生的思维能力和编程能力。学生的思维能力和编程能力可以用 $1$ 到 $10^9$ 之间的整数表示。第 $i$ 名男生的思维能力是 $A_1[i]$，编程能力是 $B_1[i]$。第 $j$ 名女生的思维能力是 $A_2[j]$，编程能力是 $B_2[j]$。如果第 $i$ 名男生和第 $j$ 名女生组成一个团队，那么这个团队的实力定义为 $\\left(A_1[i] + A_2[j]\\right) \\times \\left(B_1[i] + B_2[j]\\right)$。\n\n由于所有学生都是经过激烈竞争选拔出来的，因此不存在某个男生在思维能力和编程能力上都优于另一个男生的情况。更具体地说，男生的思维能力随着编号的增加而增加，编程能力随着编号的增加而减少。即，对于 $i$ $(0 \\leq i \\leq N-2)$，有 $A_1[i] < A_1[i+1]$ 和 $B_1[i] > B_1[i+1]$。女生也是如此，思维能力随着编号的增加而增加，编程能力随着编号的增加而减少。即，对于 $0 \\leq j \\leq M-2$，有 $A_2[j] < A_2[j+1]$ 和 $B_2[j] > B_2[j+1]$。\n\n信息学奥林匹克竞赛委员会希望根据不同的场景组建实力最强的团队。共有 $Q$ 个场景，每个场景编号从 $0$ 到 $Q-1$。在第 $k$ 个场景中，男生的编号必须在 $L_1[k]$ 到 $R_1[k]$ 之间，女生的编号必须在 $L_2[k]$ 到 $R_2[k]$ 之间。请编写一个程序，计算每个场景中可以组建的团队的最大实力。\n\n你需要实现以下函数：\n\n```cpp\nvector<long long> build_teams(vector<int> A1, vector<int> B1, vector<int> A2, vector<int> B2, vector<int> L1, vector<int> R1, vector<int> L2, vector<int> R2);\n```\n\n- `A1, B1`：长度为 $N$ 的数组。第 $i$ $(0 \\leq i \\leq N-1)$ 名男生的思维能力是 $A1[i]$，编程能力是 $B1[i]$。\n- `A2, B2`：长度为 $M$ 的数组。第 $j$ $(0 \\leq j \\leq M-1)$ 名女生的思维能力是 $A2[j]$，编程能力是 $B2[j]$。\n- `L1, R1, L2, R2`：长度为 $Q$ 的数组。在第 $k$ $(0 \\leq k \\leq Q-1)$ 个场景中，男生的编号必须在 $L1[k]$ 到 $R1[k]$ 之间，女生的编号必须在 $L2[k]$ 到 $R2[k]$ 之间。\n- 该函数返回一个长度为 $Q$ 的数组 $C$。$C[k]$ 是第 $k$ 个场景中可以组建的团队的最大实力。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,M$\n- 第 $2+i$ $(0 \\leq i \\leq N-1)$ 行：$A1[i]\\,B1[i]$\n- 第 $2+N+j$ $(0 \\leq j \\leq M-1)$ 行：$A2[j]\\,B2[j]$\n- 第 $2+N+M$ 行：$Q$\n- 第 $3+N+M+k$ $(0 \\leq k \\leq Q-1)$ 行：$L1[k]\\,R1[k]\\,L2[k]\\,R2[k]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $1+k$ $(0 \\leq k \\leq Q-1)$ 行：函数 `build_teams` 返回的数组的第 $k$ 个元素", "hint": "### 样例 1 解释\n\n考虑 $N=5, M=4, A1=[2,7,8,9,10], B1=[10,9,8,6,1], A2=[1,3,5,9], B2=[10,8,7,5], Q=3, L1=[0,2,1], R1=[4,3,1], L2=[1,0,0], R2=[3,2,0]$ 的情况。\n\n评测程序将调用如下函数：\n\n```cpp\nbuild_teams([2,7,8,9,10], [10,9,8,6,1], [1,3,5,9], [10,8,7,5], [0,2,1], [4,3,1], [1,0,0], [3,2,0]);\n```\n\n在第 $0$ 个场景中，男生的编号必须在 $0$ 到 $4$ 之间，女生的编号必须在 $1$ 到 $3$ 之间。选择 $1$ 号男生和 $3$ 号女生组成团队，团队的实力为 $(7+9) \\times (9+5) = 224$。这是满足条件的团队中实力最大的。\n\n在第 $1$ 个场景中，男生的编号必须在 $2$ 到 $3$ 之间，女生的编号必须在 $0$ 到 $2$ 之间。选择 $2$ 号男生和 $2$ 号女生组成团队，团队的实力为 $(8+5) \\times (8+7) = 195$。这是满足条件的团队中实力最大的。\n\n在第 $2$ 个场景中，男生的编号必须是 $1$，女生的编号必须是 $0$。团队的实力为 $(7+1) \\times (9+10) = 152$。\n\n因此，函数应返回 `[224,195,152]`。\n\n### 样例 2 解释\n\n考虑 $N=4, M=2, A1=[1,6,8,10], B1=[9,5,3,1], A2=[5,6], B2=[8,7], Q=4, L1=[0,1,2,3], R1=[0,1,2,3], L2=[0,0,0,0], R2=[1,1,1,1]$ 的情况。\n\n评测程序将调用如下函数：\n\n```cpp\nbuild_teams([1,6,8,10], [9,5,3,1], [5,6], [8,7], [0,1,2,3], [0,1,2,3], [0,0,0,0], [1,1,1,1]);\n```\n\n在第 $0$ 个场景中，选择 $0$ 号男生和 $1$ 号女生组成团队，团队的实力为 $(1+6) \\times (9+7) = 112$。\n\n在第 $1$ 个场景中，选择 $1$ 号男生和 $1$ 号女生组成团队，团队的实力为 $(6+6) \\times (5+7) = 144$。\n\n在第 $2$ 个场景中，选择 $2$ 号男生和 $0$ 号女生组成团队，团队的实力为 $(8+5) \\times (3+8) = 143$。\n\n在第 $3$ 个场景中，选择 $3$ 号男生和 $0$ 号女生组成团队，团队的实力为 $(10+5) \\times (1+8) = 135$。\n\n这些都是满足条件的团队中实力最大的。因此，函数应返回 `[112,144,143,135]`。\n\n### 数据范围\n\n对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 10^5$\n- $1 \\leq M \\leq 10^5$\n- 对于每个 $i$ $(0 \\leq i \\leq N-1)$，$1 \\leq A1[i], B1[i] \\leq 10^9$\n- 对于每个 $j$ $(0 \\leq j \\leq M-1)$，$1 \\leq A2[j], B2[j] \\leq 10^9$\n- 对于每个 $i$ $(0 \\leq i \\leq N-2)$，$A1[i] < A1[i+1], B1[i] > B1[i+1]$\n- 对于每个 $j$ $(0 \\leq j \\leq M-2)$，$A2[j] < A2[j+1], B2[j] > B2[j+1]$\n- $1 \\leq Q \\leq 10^5$\n- 对于每个 $k$ $(0 \\leq k \\leq Q-1)$，$0 \\leq L1[k] \\leq R1[k] \\leq N-1$\n- 对于每个 $k$ $(0 \\leq k \\leq Q-1)$，$0 \\leq L2[k] \\leq R2[k] \\leq M-1$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $5$ | $N \\leq 500, M \\leq 500, Q \\leq 500$ |\n| $2$ | $10$ | $Q \\leq 20$ |\n| $3$ | $10$ | 对于每个 $k$ $(0 \\leq k \\leq Q-1)$，$L2[k]=0, R2[k]=M-1$ |\n| $4$ | $35$ | 对于每个 $k$ $(0 \\leq k \\leq Q-1)$，$L2[k]=R2[k]$ |\n| $5$ | $40$ | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P11349", "type": "P", "difficulty": 3, "samples": [["3 3\n2 5\n1 1\n8 3\n3 2\n9 4\n1 3", "4"], ["3 4\n2 3\n1 1\n8 4\n2 0\n7 0\n1 0\n8 0", "11"], ["5 1\n3 4\n1 2\n5 6\n2 8\n4 0\n3 6", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2024", "双指针 two-pointer", "NOISG（新加坡）"], "title": "[NOISG 2024 Finals] Problem Setter", "background": "Stuart 是一名热衷于编程比赛的题目设计者，他为多个比赛设定了许多问题。他希望将自己的一些问题提交到编程比赛中，以获得更多的荣誉。", "description": "Stuart 可以将题目提交到 $c$ 个比赛中。如果将问题提交到第 $i$ 个比赛，他的满意度会增加 $s_i$。但由于比赛的结构和其他题目设计者的竞争，第 $i$ 个比赛只会接受质量至少为 $m_i$ 的题目。每个比赛可以接受多个问题，每个问题都会增加 $s_i$ 的满意度。\n\nStuart 总共设计了 $p$ 道问题，他认为第 $j$ 道问题的质量是 $q_j$。但由于问题准备过程的难度，提交第 $j$ 道问题到任何比赛会使他的满意度减少 $d_j$。显然，每个问题最多只能提交到一个比赛，或者可以选择不提交。\n\n请帮 Stuart 找到一个最优的提交方案，以使他的满意度最大化。如果所有提交方案都会导致负满意度，他可以选择不提交任何问题，最终满意度为 $0$。", "inputFormat": "- 第一行包含两个整数 $c$ 和 $p$，分别表示比赛数量和问题数量。\n- 接下来的 $c$ 行中，第 $i$ 行包含两个整数 $m_i$ 和 $s_i$，表示第 $i$ 个比赛的最低问题质量和增加的满意度。\n- 接下来的 $p$ 行中，第 $j$ 行包含两个整数 $q_j$ 和 $d_j$，表示第 $j$ 道问题的质量和提交所带来的满意度损失。", "outputFormat": "- 输出一个整数，表示 Stuart 可以获得的最大满意度。如果他选择不提交任何问题，输出 $0$。", "hint": "【样例解释】\n\n对于样例 #1：\n- 比赛 $1$ 的最低质量要求为 $2$，问题 $1$ 满足条件，提交后增加 $5 - 2 = 3$ 的满意度。\n- 比赛 $1$ 的最低质量要求为 $2$，问题 $2$ 满足条件，提交后增加 $5 - 4 = 1$ 的满意度。\n- 最终满意度为 $3 + 1 = 4$。\n- 问题 $3$ 和其他比赛没有提交。\n\n对于样例 #2：\n- 根据提交方案，最优满意度为 $11$。\n\n对于样例 #3：\n- 最优方案使满意度为 $2$。\n\n【数据范围】\n\n- $1 \\leq c, p \\leq 2\\times 10^5$\n- $0 \\leq m_i, s_i, q_j, d_j \\leq 10^6$\n\n| 子任务编号 | 分值 | 限制条件                     |\n|:---:|:---:|:---:|\n| $0$ | $0$  | 样例测试用例                     |\n| $1$ | $18$ | $1 \\leq c \\leq 1,000, p = 1$     |\n| $2$ | $16$ | $1 \\leq c, p \\leq 1,000$         |\n| $3$ | $26$ | $d_j = 0$                        |\n| $4$ | $40$ | 无额外限制                       |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2024 Finals] Problem Setter", "background": "Stuart 是一名热衷于编程比赛的题目设计者，他为多个比赛设定了许多问题。他希望将自己的一些问题提交到编程比赛中，以获得更多的荣誉。", "description": "Stuart 可以将题目提交到 $c$ 个比赛中。如果将问题提交到第 $i$ 个比赛，他的满意度会增加 $s_i$。但由于比赛的结构和其他题目设计者的竞争，第 $i$ 个比赛只会接受质量至少为 $m_i$ 的题目。每个比赛可以接受多个问题，每个问题都会增加 $s_i$ 的满意度。\n\nStuart 总共设计了 $p$ 道问题，他认为第 $j$ 道问题的质量是 $q_j$。但由于问题准备过程的难度，提交第 $j$ 道问题到任何比赛会使他的满意度减少 $d_j$。显然，每个问题最多只能提交到一个比赛，或者可以选择不提交。\n\n请帮 Stuart 找到一个最优的提交方案，以使他的满意度最大化。如果所有提交方案都会导致负满意度，他可以选择不提交任何问题，最终满意度为 $0$。", "inputFormat": "- 第一行包含两个整数 $c$ 和 $p$，分别表示比赛数量和问题数量。\n- 接下来的 $c$ 行中，第 $i$ 行包含两个整数 $m_i$ 和 $s_i$，表示第 $i$ 个比赛的最低问题质量和增加的满意度。\n- 接下来的 $p$ 行中，第 $j$ 行包含两个整数 $q_j$ 和 $d_j$，表示第 $j$ 道问题的质量和提交所带来的满意度损失。", "outputFormat": "- 输出一个整数，表示 Stuart 可以获得的最大满意度。如果他选择不提交任何问题，输出 $0$。", "hint": "【样例解释】\n\n对于样例 #1：\n- 比赛 $1$ 的最低质量要求为 $2$，问题 $1$ 满足条件，提交后增加 $5 - 2 = 3$ 的满意度。\n- 比赛 $1$ 的最低质量要求为 $2$，问题 $2$ 满足条件，提交后增加 $5 - 4 = 1$ 的满意度。\n- 最终满意度为 $3 + 1 = 4$。\n- 问题 $3$ 和其他比赛没有提交。\n\n对于样例 #2：\n- 根据提交方案，最优满意度为 $11$。\n\n对于样例 #3：\n- 最优方案使满意度为 $2$。\n\n【数据范围】\n\n- $1 \\leq c, p \\leq 2\\times 10^5$\n- $0 \\leq m_i, s_i, q_j, d_j \\leq 10^6$\n\n| 子任务编号 | 分值 | 限制条件                     |\n|:---:|:---:|:---:|\n| $0$ | $0$  | 样例测试用例                     |\n| $1$ | $18$ | $1 \\leq c \\leq 1,000, p = 1$     |\n| $2$ | $16$ | $1 \\leq c, p \\leq 1,000$         |\n| $3$ | $26$ | $d_j = 0$                        |\n| $4$ | $40$ | 无额外限制                       |", "locale": "zh-CN"}}}
{"pid": "P11350", "type": "P", "difficulty": 4, "samples": [["3 3\n1 2 3\n2 3 1\n1 3 2", "2\nBBD"], ["5 6\n3 2 3\n4 2 1\n5 3 9\n1 3 5\n1 4 2\n2 3 1", "9\nDBDDB"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "NOISG（新加坡）"], "title": "[NOISG 2024 Finals] Shops", "background": "", "description": "Yuland 是一个由 $n$ 个城市组成的小镇，城市之间通过 $m$ 条双向道路连接，每条道路有不同的长度。从任何城市可以通过道路到达其他城市，可能存在多条道路连接相同的城市对。\n\n每个城市可以建造一个兔子店或鸭子店，但不能同时建造两者。每个城市的居民希望能够收集到这两种动物。一个城市的不便程度定义为距离最近的兔子店和距离最近的鸭子店的距离之间的最大值。\n\n你需要帮助 Yuland 的市长决定在每个城市建造哪种店铺，以最小化所有城市中的最大不便程度。", "inputFormat": "- 第一行包含两个整数 $n$ 和 $m$，分别表示城市数量和道路数量。\n- 接下来的 $m$ 行，每行包含三个整数 $u_i$、$v_i$ 和 $w_i$，表示一条连接城市 $u_i$ 和 $v_i$ 的双向道路，其长度为 $w_i$。\n", "outputFormat": "- 第一行输出一个整数，表示最小可能的不便程度的最大值。\n- 第二行输出一个由 $n$ 个字符组成的字符串，其中第 $i$ 个字符表示第 $i$ 个城市建造的店铺类型：\n  - `B` 表示兔子店。\n  - `D` 表示鸭子店。\n- 如果有多个满足条件的方案，可以输出任意一个。\n", "hint": "【样例解释】\n\n对于样例 #1：\n- 城市 $1$ 和 $2$ 建造兔子店，城市 $3$ 建造鸭子店。\n- 对于城市 $1$，到最近的鸭子店的距离为 $2$，到最近的兔子店的距离为 $0$。\n- 对于城市 $2$，到最近的兔子店和鸭子店的距离均为 $1$。\n- 对于城市 $3$，到最近的兔子店的距离为 $1$，到最近的鸭子店的距离为 $0$。\n- 最大不便程度为 $2$。\n\n对于样例 #2：\n- 城市建造的店铺类型为 `DBDDB`，最大不便程度为 $9$。\n\n【数据范围】\n\n- $2 \\leq n, m \\leq 500,000$\n- $1 \\leq u_i, v_i \\leq n$\n- $1 \\leq w_i \\leq 10^9$\n\n| 子任务编号 | 分值 | 限制条件                     |\n|:---:|:---:|:---:|\n| $0$ | $0$  | 样例测试用例                     |\n| $1$ | $7$  | $n \\leq 16$                      |\n| $2$ | $13$ | $m = n-1$ 且 $u_i = i, v_i = i+1$ |\n| $3$ | $18$ | $m = n-1$                        |\n| $4$ | $24$ | $w_i = 1$                        |\n| $5$ | $38$ | 无额外限制                       |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2024 Finals] Shops", "background": "", "description": "Yuland 是一个由 $n$ 个城市组成的小镇，城市之间通过 $m$ 条双向道路连接，每条道路有不同的长度。从任何城市可以通过道路到达其他城市，可能存在多条道路连接相同的城市对。\n\n每个城市可以建造一个兔子店或鸭子店，但不能同时建造两者。每个城市的居民希望能够收集到这两种动物。一个城市的不便程度定义为距离最近的兔子店和距离最近的鸭子店的距离之间的最大值。\n\n你需要帮助 Yuland 的市长决定在每个城市建造哪种店铺，以最小化所有城市中的最大不便程度。", "inputFormat": "- 第一行包含两个整数 $n$ 和 $m$，分别表示城市数量和道路数量。\n- 接下来的 $m$ 行，每行包含三个整数 $u_i$、$v_i$ 和 $w_i$，表示一条连接城市 $u_i$ 和 $v_i$ 的双向道路，其长度为 $w_i$。\n", "outputFormat": "- 第一行输出一个整数，表示最小可能的不便程度的最大值。\n- 第二行输出一个由 $n$ 个字符组成的字符串，其中第 $i$ 个字符表示第 $i$ 个城市建造的店铺类型：\n  - `B` 表示兔子店。\n  - `D` 表示鸭子店。\n- 如果有多个满足条件的方案，可以输出任意一个。\n", "hint": "【样例解释】\n\n对于样例 #1：\n- 城市 $1$ 和 $2$ 建造兔子店，城市 $3$ 建造鸭子店。\n- 对于城市 $1$，到最近的鸭子店的距离为 $2$，到最近的兔子店的距离为 $0$。\n- 对于城市 $2$，到最近的兔子店和鸭子店的距离均为 $1$。\n- 对于城市 $3$，到最近的兔子店的距离为 $1$，到最近的鸭子店的距离为 $0$。\n- 最大不便程度为 $2$。\n\n对于样例 #2：\n- 城市建造的店铺类型为 `DBDDB`，最大不便程度为 $9$。\n\n【数据范围】\n\n- $2 \\leq n, m \\leq 500,000$\n- $1 \\leq u_i, v_i \\leq n$\n- $1 \\leq w_i \\leq 10^9$\n\n| 子任务编号 | 分值 | 限制条件                     |\n|:---:|:---:|:---:|\n| $0$ | $0$  | 样例测试用例                     |\n| $1$ | $7$  | $n \\leq 16$                      |\n| $2$ | $13$ | $m = n-1$ 且 $u_i = i, v_i = i+1$ |\n| $3$ | $18$ | $m = n-1$                        |\n| $4$ | $24$ | $w_i = 1$                        |\n| $5$ | $38$ | 无额外限制                       |", "locale": "zh-CN"}}}
{"pid": "P11352", "type": "P", "difficulty": 6, "samples": [["4 4\n2 4\n3 1\n4 1\n2 3", "3 4 -1 -1"], ["6 8\n1 5\n5 4\n6 2\n2 5\n4 3\n6 1\n6 5\n2 1", "8 8 5 5 5 6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "NOISG（新加坡）"], "title": "[NOISG 2024 Finals] Coin", "background": "", "description": "Benson 有 $n$ 枚不同重量的硬币和一个天平。每次将硬币 $x$ 和 $y$ 放在天平上，可以知道它们的相对重量，即 $x$ 是否比 $y$ 更重。\n\n硬币 $x$ 的排名（rank）定义为不比它更重的硬币数量（包括自身）。例如，最轻的硬币的排名是 $1$，次轻的是 $2$，最重的是 $n$。\n\n对于每个硬币，当且仅当基于已有的称量结果可以唯一确定其排名时，称其排名被“确定”（determined）。\n\n你的任务是帮助 Benson 找出每个硬币首次确定排名的称量序号，或者判断它的排名永远无法确定。", "inputFormat": "- 第一行包含两个用空格分隔的整数 $n$ 和 $m$，表示硬币的数量和称量的次数。\n- 接下来的 $m$ 行，每行包含两个整数 $x$ 和 $y$，表示硬币 $x$ 比硬币 $y$ 轻。", "outputFormat": "输出 $n$ 个整数。如果硬币 $i$ 的排名在所有 $m$ 次称量后仍未确定，输出 $-1$。否则，输出首次确定排名的称量序号 $k$（$1 \\leq k \\leq m$）。", "hint": "【样例解释】\n\n对于样例 #1：\n- 硬币 $1$ 的排名在第 $3$ 次称量后确定，输出 $3$。\n- 硬币 $2$ 的排名在第 $4$ 次称量后确定，输出 $4$。\n- 硬币 $3$ 和 $4$ 的排名无法确定，输出 $-1$。\n\n对于样例 #2：\n- 每个硬币的排名确定的时间点分别是 $8$，$8$，$5$，$5$，$5$ 和 $6$。\n\n【数据范围】\n\n- $2 \\leq n \\leq 200,000$\n- $1 \\leq m \\leq 800,000$\n- $1 \\leq x, y \\leq n$\n- 硬币之间的所有称量关系形成一个有效的偏序。\n\n| 子任务编号 | 分值 | 限制条件                     |\n|:---:|:---:|:---:|\n| $0$ | $0$  | 样例测试用例                     |\n| $1$ | $6$  | $1 \\leq n \\leq 7, 1 \\leq m \\leq 20$ |\n| $2$ | $16$ | $1 \\leq n \\leq 100, 1 \\leq m \\leq 400$ |\n| $3$ | $10$ | $1 \\leq n \\leq 1000, 1 \\leq m \\leq 4000$ |\n| $4$ | $68$ | 无额外限制                       |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2024 Finals] Coin", "background": "", "description": "Benson 有 $n$ 枚不同重量的硬币和一个天平。每次将硬币 $x$ 和 $y$ 放在天平上，可以知道它们的相对重量，即 $x$ 是否比 $y$ 更重。\n\n硬币 $x$ 的排名（rank）定义为不比它更重的硬币数量（包括自身）。例如，最轻的硬币的排名是 $1$，次轻的是 $2$，最重的是 $n$。\n\n对于每个硬币，当且仅当基于已有的称量结果可以唯一确定其排名时，称其排名被“确定”（determined）。\n\n你的任务是帮助 Benson 找出每个硬币首次确定排名的称量序号，或者判断它的排名永远无法确定。", "inputFormat": "- 第一行包含两个用空格分隔的整数 $n$ 和 $m$，表示硬币的数量和称量的次数。\n- 接下来的 $m$ 行，每行包含两个整数 $x$ 和 $y$，表示硬币 $x$ 比硬币 $y$ 轻。", "outputFormat": "输出 $n$ 个整数。如果硬币 $i$ 的排名在所有 $m$ 次称量后仍未确定，输出 $-1$。否则，输出首次确定排名的称量序号 $k$（$1 \\leq k \\leq m$）。", "hint": "【样例解释】\n\n对于样例 #1：\n- 硬币 $1$ 的排名在第 $3$ 次称量后确定，输出 $3$。\n- 硬币 $2$ 的排名在第 $4$ 次称量后确定，输出 $4$。\n- 硬币 $3$ 和 $4$ 的排名无法确定，输出 $-1$。\n\n对于样例 #2：\n- 每个硬币的排名确定的时间点分别是 $8$，$8$，$5$，$5$，$5$ 和 $6$。\n\n【数据范围】\n\n- $2 \\leq n \\leq 200,000$\n- $1 \\leq m \\leq 800,000$\n- $1 \\leq x, y \\leq n$\n- 硬币之间的所有称量关系形成一个有效的偏序。\n\n| 子任务编号 | 分值 | 限制条件                     |\n|:---:|:---:|:---:|\n| $0$ | $0$  | 样例测试用例                     |\n| $1$ | $6$  | $1 \\leq n \\leq 7, 1 \\leq m \\leq 20$ |\n| $2$ | $16$ | $1 \\leq n \\leq 100, 1 \\leq m \\leq 400$ |\n| $3$ | $10$ | $1 \\leq n \\leq 1000, 1 \\leq m \\leq 4000$ |\n| $4$ | $68$ | 无额外限制                       |", "locale": "zh-CN"}}}
{"pid": "P11353", "type": "P", "difficulty": 7, "samples": [["5 1 4\n-4 -3 -2 5\n-6 4 4 4\n1 2 0 6\n4 4 -1 4\n-2 6 -4 -2\n-1 2\n3 3\n0 6\n2 -3", "3\n8\n-1\n-1"], ["2 1 4\n-1000000000 -1 0 999999999\n0 999999999 -1000000000 -1\n1 1\n-1 1\n-1 -1\n1 -1", "2\n-1\n4000000002\n-1"], ["2 2 6\n-2 5 1 1\n0 1 -3 -2\n1\n2\n3\n4\n5\n6", "4\n8\n13\n21\n32\n48"], ["2 2 4\n0 9999999 -10000000 -1\n-10000000 -1 10000000 29999999\n12\n1234\n123456\n12345678", "235\n2285986\n22862261089\n231374765559370"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "NOISG（新加坡）"], "title": "[NOISG 2024 Finals] Field", "background": "", "description": "Stuart the Snail 住在一片田野上，这片田野可以被描述为一个无限的二维平面。在田野的每个整数坐标点上都有可以吃的植物，而 Stuart 的家位于原点 $(0, 0)$。\n\n下雨了，Stuart 能够轻松地在田野上移动。每小时他可以选择一个相邻的植物坐标移动过去并吃掉它。具体来说，如果他当前在 $(x, y)$，他可以移动到 $(x+1, y)$、$(x, y+1)$、$(x-1, y)$ 或 $(x, y-1)$。他可以在雨停前继续移动，也可以选择停止并停留在某个植物上，包括留在原地。\n\n然而，田野中有 $n$ 个深水坑，每个水坑覆盖一个矩形区域，Stuart 无法安全地通过。水坑 $i$ 的覆盖范围是满足 $a_i \\leq x \\leq b_i$ 且 $c_i \\leq y \\leq d_i$ 的所有整数坐标点。注意，水坑可能存在重叠。\n\n你需要回答 $q$ 个查询，每个查询的类型由 $t$ 指定：\n- 如果 $t = 1$，查询 Stuart 从原点移动到 $(x_j, y_j)$ 所需的最短时间（以小时为单位）。如果无法到达目的地，输出 $-1$。\n- 如果 $t = 2$，假设雨将持续 $m_j$ 小时，计算 Stuart 在最多 $m_j$ 小时内可以到达的不同位置数量。", "inputFormat": "- 第一行包含三个整数 $n$、$t$ 和 $q$，分别表示水坑数量、查询类型和查询数量。\n- 接下来的 $n$ 行中，每行包含四个整数 $a_i$、$b_i$、$c_i$ 和 $d_i$，表示水坑 $i$ 的范围。\n- 如果 $t = 1$，接下来的 $q$ 行每行包含两个整数 $x_j$ 和 $y_j$，表示查询的目标坐标。\n- 如果 $t = 2$，接下来的 $q$ 行每行包含一个整数 $m_j$，表示雨的持续时间。", "outputFormat": "- 对于每个查询，输出一个整数作为答案：\n  - 如果 $t = 1$，输出 Stuart 到达目标位置的最短时间；如果无法到达，输出 $-1$。\n  - 如果 $t = 2$，输出 Stuart 在最多 $m_j$ 小时内可以到达的不同位置数量。", "hint": "【样例解释】\n\n对于样例 #1：\n- Stuart 可以在 $3$ 小时内到达 $(3, 3)$。\n- Stuart 无法到达 $(2, -3)$，因为目标位置被水坑覆盖。\n\n对于样例 #2：\n- Stuart 在 $1$ 小时内可以到达 $4$ 个不同的位置。\n- 在 $2$ 小时内，可以到达 $8$ 个位置。\n\n【数据范围】\n\n- $1 \\leq n \\leq 400$\n- $1 \\leq t \\leq 2$\n- $1 \\leq q \\leq 200,000$\n- $-10^9 \\leq a_i \\leq b_i \\leq 10^9$\n- $-10^9 \\leq c_i \\leq d_i \\leq 10^9$\n- 原点 $(0, 0)$ 不被任何水坑覆盖。\n- 如果 $t = 1$，则 $-10^9 \\leq x_j, y_j \\leq 10^9$。\n- 如果 $t = 2$，则 $1 \\leq m_j \\leq 10^9$。\n\n| 子任务编号 | 分值 | $t=$ | $n\\le$ |  $q\\le$   |                  $a_i,b_i,c_i,d_i,x_i,y_i$                   |\n| :--------: | :--: | :--: | :----: | :-------: | :----------------------------------------------------------: |\n|    $0$     | $0$  | $/$  |  $/$   |    $/$    |                             $/$                              |\n|    $1$     | $5$  | $1$  | $100$  | $200,000$ |           $-400\\le a_i,b_i,c_i,d_i,x_i,y_i\\le400$            |\n|    $2$     | $17$ | $1$  | $100$  | $200,000$ | $a_i\\equiv c_i \\equiv 0,b_i\\equiv d_i \\equiv -1 \\pmod{10^7}$ |\n|    $3$     | $8$  | $1$  | $100$  | $200,000$ |                             $/$                              |\n|    $4$     | $8$  | $2$  | $100$  |   $400$   |           $-400\\le a_i,b_i,c_i,d_i,x_i,y_i\\le400$            |\n|    $5$     | $21$ | $2$  | $100$  |   $400$   | $a_i\\equiv c_i \\equiv 0,b_i\\equiv d_i \\equiv -1 \\pmod{10^7}$ |\n|    $6$     | $10$ | $2$  | $100$  |   $400$   |                             $/$                              |\n|    $7$     | $13$ | $2$  | $100$  |   $400$   |                             $/$                              |\n|    $8$     | $14$ | $2$  | $100$  | $200,000$ |                             $/$                              |\n|    $9$     | $4$  | $2$  | $400$  | $200,000$ |                             $/$                              |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2024 Finals] Field", "background": "", "description": "Stuart the Snail 住在一片田野上，这片田野可以被描述为一个无限的二维平面。在田野的每个整数坐标点上都有可以吃的植物，而 Stuart 的家位于原点 $(0, 0)$。\n\n下雨了，Stuart 能够轻松地在田野上移动。每小时他可以选择一个相邻的植物坐标移动过去并吃掉它。具体来说，如果他当前在 $(x, y)$，他可以移动到 $(x+1, y)$、$(x, y+1)$、$(x-1, y)$ 或 $(x, y-1)$。他可以在雨停前继续移动，也可以选择停止并停留在某个植物上，包括留在原地。\n\n然而，田野中有 $n$ 个深水坑，每个水坑覆盖一个矩形区域，Stuart 无法安全地通过。水坑 $i$ 的覆盖范围是满足 $a_i \\leq x \\leq b_i$ 且 $c_i \\leq y \\leq d_i$ 的所有整数坐标点。注意，水坑可能存在重叠。\n\n你需要回答 $q$ 个查询，每个查询的类型由 $t$ 指定：\n- 如果 $t = 1$，查询 Stuart 从原点移动到 $(x_j, y_j)$ 所需的最短时间（以小时为单位）。如果无法到达目的地，输出 $-1$。\n- 如果 $t = 2$，假设雨将持续 $m_j$ 小时，计算 Stuart 在最多 $m_j$ 小时内可以到达的不同位置数量。", "inputFormat": "- 第一行包含三个整数 $n$、$t$ 和 $q$，分别表示水坑数量、查询类型和查询数量。\n- 接下来的 $n$ 行中，每行包含四个整数 $a_i$、$b_i$、$c_i$ 和 $d_i$，表示水坑 $i$ 的范围。\n- 如果 $t = 1$，接下来的 $q$ 行每行包含两个整数 $x_j$ 和 $y_j$，表示查询的目标坐标。\n- 如果 $t = 2$，接下来的 $q$ 行每行包含一个整数 $m_j$，表示雨的持续时间。", "outputFormat": "- 对于每个查询，输出一个整数作为答案：\n  - 如果 $t = 1$，输出 Stuart 到达目标位置的最短时间；如果无法到达，输出 $-1$。\n  - 如果 $t = 2$，输出 Stuart 在最多 $m_j$ 小时内可以到达的不同位置数量。", "hint": "【样例解释】\n\n对于样例 #1：\n- Stuart 可以在 $3$ 小时内到达 $(3, 3)$。\n- Stuart 无法到达 $(2, -3)$，因为目标位置被水坑覆盖。\n\n对于样例 #2：\n- Stuart 在 $1$ 小时内可以到达 $4$ 个不同的位置。\n- 在 $2$ 小时内，可以到达 $8$ 个位置。\n\n【数据范围】\n\n- $1 \\leq n \\leq 400$\n- $1 \\leq t \\leq 2$\n- $1 \\leq q \\leq 200,000$\n- $-10^9 \\leq a_i \\leq b_i \\leq 10^9$\n- $-10^9 \\leq c_i \\leq d_i \\leq 10^9$\n- 原点 $(0, 0)$ 不被任何水坑覆盖。\n- 如果 $t = 1$，则 $-10^9 \\leq x_j, y_j \\leq 10^9$。\n- 如果 $t = 2$，则 $1 \\leq m_j \\leq 10^9$。\n\n| 子任务编号 | 分值 | $t=$ | $n\\le$ |  $q\\le$   |                  $a_i,b_i,c_i,d_i,x_i,y_i$                   |\n| :--------: | :--: | :--: | :----: | :-------: | :----------------------------------------------------------: |\n|    $0$     | $0$  | $/$  |  $/$   |    $/$    |                             $/$                              |\n|    $1$     | $5$  | $1$  | $100$  | $200,000$ |           $-400\\le a_i,b_i,c_i,d_i,x_i,y_i\\le400$            |\n|    $2$     | $17$ | $1$  | $100$  | $200,000$ | $a_i\\equiv c_i \\equiv 0,b_i\\equiv d_i \\equiv -1 \\pmod{10^7}$ |\n|    $3$     | $8$  | $1$  | $100$  | $200,000$ |                             $/$                              |\n|    $4$     | $8$  | $2$  | $100$  |   $400$   |           $-400\\le a_i,b_i,c_i,d_i,x_i,y_i\\le400$            |\n|    $5$     | $21$ | $2$  | $100$  |   $400$   | $a_i\\equiv c_i \\equiv 0,b_i\\equiv d_i \\equiv -1 \\pmod{10^7}$ |\n|    $6$     | $10$ | $2$  | $100$  |   $400$   |                             $/$                              |\n|    $7$     | $13$ | $2$  | $100$  |   $400$   |                             $/$                              |\n|    $8$     | $14$ | $2$  | $100$  | $200,000$ |                             $/$                              |\n|    $9$     | $4$  | $2$  | $400$  | $200,000$ |                             $/$                              |", "locale": "zh-CN"}}}
{"pid": "P11354", "type": "P", "difficulty": 5, "samples": [["5\n1 1 2 4\n\n1\n\n0\n ", " \n\n? 4\n\n? 5\n\n! 4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2023", "交互题", "Special Judge", "eJOI（欧洲）"], "title": "[eJOI 2023] Tree Search", "background": "本题对洛谷交互格式进行了适配，你可以在以下代码的基础上进行实现：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nextern \"C\" bool ask(int x);\nextern \"C\" int solve(int n,vector<int> p)\n{\n  \tassert(ask(1)==1);\n\treturn 20080520;\n}\n```", "description": "**这是一道交互题。**\n\n给定一棵 $N$ 个点的有根二叉树 $T$，保证根结点的编号为 $1$。\n\n树上恰有一个未知的结点是特殊的，你需要找出这个结点。\n\n你每次可以向交互库询问一棵子树中是否含有特殊结点，你可以询问至多 $35$ 次。\n\n**【实现细节】**\n\n你需要实现下列函数：\n\n``int solve(int N, std::vector < int > p)``\n\n- $N$：树的结点数量。\n- $p$：长度为 $N-1$ 的数组，描述树的形态。第 $i$ 个元素 $p_i$ 满足 $1\\leq p_i\\leq i+1$，代表编号为 $i+2$ 的结点的父亲编号。\n- $p$ 中的元素两两不同。\n- 你需要返回特殊结点的编号。\n- 这个函数只会被调用恰好一次。\n\n你可以调用以下函数：\n\n``int ask(int x)``\n\n- $x$：询问的子树根结点编号。\n- 你需要保证 $1\\leq x\\leq N$。\n- 如果子树包含特殊结点，返回值为 $1$，否则为 $0$。", "inputFormat": "**以下为下发 grader 的输入格式，你不应该从标准输入中读入任何信息。**\n\n第一行输入一个整数 $N$。\n\n第二行输入 $N-1$ 个整数 $p_i$。\n\n接下来对于每个询问，输入一个整数代表询问的返回值。", "outputFormat": "**以下为下发 grader 的输出格式，你不应该向标准输出中打印任何信息。**\n\n对于每个询问，输出一行 ``? x``，其中 $x$ 为询问的结点。\n\n最后输出一行 ``! x``，其中 $x$ 为猜测的结点编号。", "hint": "**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（20 pts）：$N\\leq 35$。\n- Subtask 2（30 pts）：$p_i=i+1$。\n- Subtask 3（15 pts）：$p_i=\\frac{i}{2}+1$。\n- Subtask 4（35 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，保证 $1\\leq N\\leq 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[eJOI 2023] Tree Search", "background": "本题对洛谷交互格式进行了适配，你可以在以下代码的基础上进行实现：\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nextern \"C\" bool ask(int x);\nextern \"C\" int solve(int n,vector<int> p)\n{\n  \tassert(ask(1)==1);\n\treturn 20080520;\n}\n```", "description": "**这是一道交互题。**\n\n给定一棵 $N$ 个点的有根二叉树 $T$，保证根结点的编号为 $1$。\n\n树上恰有一个未知的结点是特殊的，你需要找出这个结点。\n\n你每次可以向交互库询问一棵子树中是否含有特殊结点，你可以询问至多 $35$ 次。\n\n**【实现细节】**\n\n你需要实现下列函数：\n\n``int solve(int N, std::vector < int > p)``\n\n- $N$：树的结点数量。\n- $p$：长度为 $N-1$ 的数组，描述树的形态。第 $i$ 个元素 $p_i$ 满足 $1\\leq p_i\\leq i+1$，代表编号为 $i+2$ 的结点的父亲编号。\n- $p$ 中的元素两两不同。\n- 你需要返回特殊结点的编号。\n- 这个函数只会被调用恰好一次。\n\n你可以调用以下函数：\n\n``int ask(int x)``\n\n- $x$：询问的子树根结点编号。\n- 你需要保证 $1\\leq x\\leq N$。\n- 如果子树包含特殊结点，返回值为 $1$，否则为 $0$。", "inputFormat": "**以下为下发 grader 的输入格式，你不应该从标准输入中读入任何信息。**\n\n第一行输入一个整数 $N$。\n\n第二行输入 $N-1$ 个整数 $p_i$。\n\n接下来对于每个询问，输入一个整数代表询问的返回值。", "outputFormat": "**以下为下发 grader 的输出格式，你不应该向标准输出中打印任何信息。**\n\n对于每个询问，输出一行 ``? x``，其中 $x$ 为询问的结点。\n\n最后输出一行 ``! x``，其中 $x$ 为猜测的结点编号。", "hint": "**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（20 pts）：$N\\leq 35$。\n- Subtask 2（30 pts）：$p_i=i+1$。\n- Subtask 3（15 pts）：$p_i=\\frac{i}{2}+1$。\n- Subtask 4（35 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，保证 $1\\leq N\\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P11355", "type": "P", "difficulty": 6, "samples": [["4 3\n4 6 8 10\n7 1 9 4\n3 11 1 50\n3 11 1 5\n5 7 1 1", "2 3 -1"], ["3 3\n-2 1 -1\n10 1 3\n-6 6 20 20\n-6 6 1 20\n-6 6 2 20", "-1 2 7"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "eJOI（欧洲）", "整体二分"], "title": "[eJOI 2023] Teleporters", "background": "", "description": "dXqwq 和 Haitang 在数轴上的两个不同的点 $A,B$，他们想要见面，但是他们只能通过传送器移动。\n\n有 $N$ 个传送器，第 $i$ 个位于坐标轴 $c_i$ 位置，频率为 $f_i$。由于某种原因，只有频率 $\\in[L,R]$ 的传送器可以使用。\n\n使用一个传送器会将一个人传送到与其坐标对称的点。形式化地说，一个人传送前后的位置 $x_1,x_2$ 与传送器的位置 $c_i$ 满足 $\\frac{x_1+x_2}{2}=c_i$。\n\ndXqwq 和 Haitang 会不断**同时**各自选择一个传送器 $p,q$（不需要相同），进行传送并经历 $|f_p-f_q|$ 的**疲劳值**，直到他们抵达同一位置。整个过程的疲劳值为每次经历的疲劳值的最大值。\n\n给定 $Q$ 次询问，每次给定一组 $[L,R]$，求 dXqwq 和 Haitang 见面的总疲劳值的最小值，或报告他们不可能通过这些传送器见面。", "inputFormat": "第一行输入两个整数 $N,Q$。\n\n第二行输入 $N$ 个整数 $c_i$。\n\n第三行输入 $N$ 个整数 $f_i$。\n\n接下来 $Q$ 行，每行输入四个整数 $A,B,L,R$，保证 $A\\neq B$。", "outputFormat": "输出一行 $Q$ 个整数，代表每个询问总疲劳值的最小值。特别地，如果不可能见面，输出 ``-1``。", "hint": "**【样例解释】**\n\n下面为第一组样例的解释。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dfq3lesn.png)\n\n第一次询问中，如果 dXqwq 选择第二个传送器，Haitang 选择第四个传送器，可以在 $9$ 处见面，疲劳值为 $3$。但如果 dXqwq 选择第一个传送器，Haitang 选择第三个传送器，可以在 $5$ 处见面，疲劳值为 $2$。\n\n第二次询问中，上述的第二种方法由于 $[L,R]$ 的限制不合法。\n\n第三次询问中，只有一个可用的传送器，见面是不可能的。\n\n注意坐标可能是负数。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（11 pts）：$N,Q\\leq 10$，$|c_i|,f_i\\leq 50$。\n- Subtask 2（10 pts）：$N\\leq 100$，$L=1$，$R=10^9$，$|c_i|,f_i\\leq 100$。\n- Subtask 3（5 pts）：$N=2$，$L=1$，$R=10^9$。\n- Subtask 4（9 pts）：$N\\leq 10^3$，$L=1$，$R=10^9$，$f_i=1$。\n- Subtask 5（6 pts）：$L=1$，$R=10^9$，$f_i=1$。\n- Subtask 6（7 pts）：$N\\leq 10^3$，$L=1$，$R=10^9$。\n- Subtask 7（17 pts）：$L=1$，$R=10^9$。\n- Subtask 8（8 pts）：$L=1$。\n- Subtask 9（14 pts）：$N,Q\\leq 2\\times 10^4$。\n- Subtask 10（13 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，保证 $2\\leq N\\leq 5\\times 10^4$，$1\\leq Q\\leq 5\\times 10^4$，$1\\leq f_i\\leq 10^9$，$-10^9\\leq c_i,A,B\\leq 10^9$，$1\\leq L\\leq R\\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[eJOI 2023] Teleporters", "background": "", "description": "dXqwq 和 Haitang 在数轴上的两个不同的点 $A,B$，他们想要见面，但是他们只能通过传送器移动。\n\n有 $N$ 个传送器，第 $i$ 个位于坐标轴 $c_i$ 位置，频率为 $f_i$。由于某种原因，只有频率 $\\in[L,R]$ 的传送器可以使用。\n\n使用一个传送器会将一个人传送到与其坐标对称的点。形式化地说，一个人传送前后的位置 $x_1,x_2$ 与传送器的位置 $c_i$ 满足 $\\frac{x_1+x_2}{2}=c_i$。\n\ndXqwq 和 Haitang 会不断**同时**各自选择一个传送器 $p,q$（不需要相同），进行传送并经历 $|f_p-f_q|$ 的**疲劳值**，直到他们抵达同一位置。整个过程的疲劳值为每次经历的疲劳值的最大值。\n\n给定 $Q$ 次询问，每次给定一组 $[L,R]$，求 dXqwq 和 Haitang 见面的总疲劳值的最小值，或报告他们不可能通过这些传送器见面。", "inputFormat": "第一行输入两个整数 $N,Q$。\n\n第二行输入 $N$ 个整数 $c_i$。\n\n第三行输入 $N$ 个整数 $f_i$。\n\n接下来 $Q$ 行，每行输入四个整数 $A,B,L,R$，保证 $A\\neq B$。", "outputFormat": "输出一行 $Q$ 个整数，代表每个询问总疲劳值的最小值。特别地，如果不可能见面，输出 ``-1``。", "hint": "**【样例解释】**\n\n下面为第一组样例的解释。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dfq3lesn.png)\n\n第一次询问中，如果 dXqwq 选择第二个传送器，Haitang 选择第四个传送器，可以在 $9$ 处见面，疲劳值为 $3$。但如果 dXqwq 选择第一个传送器，Haitang 选择第三个传送器，可以在 $5$ 处见面，疲劳值为 $2$。\n\n第二次询问中，上述的第二种方法由于 $[L,R]$ 的限制不合法。\n\n第三次询问中，只有一个可用的传送器，见面是不可能的。\n\n注意坐标可能是负数。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（11 pts）：$N,Q\\leq 10$，$|c_i|,f_i\\leq 50$。\n- Subtask 2（10 pts）：$N\\leq 100$，$L=1$，$R=10^9$，$|c_i|,f_i\\leq 100$。\n- Subtask 3（5 pts）：$N=2$，$L=1$，$R=10^9$。\n- Subtask 4（9 pts）：$N\\leq 10^3$，$L=1$，$R=10^9$，$f_i=1$。\n- Subtask 5（6 pts）：$L=1$，$R=10^9$，$f_i=1$。\n- Subtask 6（7 pts）：$N\\leq 10^3$，$L=1$，$R=10^9$。\n- Subtask 7（17 pts）：$L=1$，$R=10^9$。\n- Subtask 8（8 pts）：$L=1$。\n- Subtask 9（14 pts）：$N,Q\\leq 2\\times 10^4$。\n- Subtask 10（13 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，保证 $2\\leq N\\leq 5\\times 10^4$，$1\\leq Q\\leq 5\\times 10^4$，$1\\leq f_i\\leq 10^9$，$-10^9\\leq c_i,A,B\\leq 10^9$，$1\\leq L\\leq R\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P11356", "type": "P", "difficulty": 6, "samples": [["2 3 2\n022\n031", "12"], ["2 3 3\n022\n031", "10"], ["2 3 1\n022\n031", "25"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2023", "eJOI（欧洲）"], "title": "[eJOI 2023] Opening Offices", "background": "", "description": "你的公司要在 $N\\times M$ 的网格图上建造办公室。如图所示，网格图上有横着和竖着的边，其边权均为 $1$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vfni68lx.png)\n\n在白天，所有道路都是可以走的。在晚上，只有 $N\\times M-1$ 条边有照明且可以走。\n\n你喜欢巡视办公室。每天，你都会以一个顺序从一个办公室开始，经过可用的边遍历每个办公室一次，最后回到起点。你希望选择网格图上一个点的子集 $S$，满足其在白天和晚上进行巡视所需走过的最短路径长度相等。\n\n你希望计算三种条件下，可能的 $S$ 的数量对 $10^9+7$ 取模的值：\n\n1. $|S|\\geq 2$。\n2. $|S|=2$。\n3. $|S|=3$。", "inputFormat": "第一行输入三个整数 $N,M,T$，其中 $T$ 代表你需要计算的问题编号。\n\n接下来 $N$ 行，每行输入一个长度为 $M$ 的字符串 $A_{i,j}$。\n\n- $A_{i,j}\\in\\{\\texttt{1},\\texttt{3}\\}$ 代表 $(i,j)$ 有连向 $(i-1,j)$ 的边。\n- $A_{i,j}\\in\\{\\texttt{2},\\texttt{3}\\}$ 代表 $(i,j)$ 有连向 $(i,j-1)$ 的边。\n\n保证输入的是一棵树。", "outputFormat": "输出一个整数，代表答案对 $10^9+7$ 取模的值。", "hint": "**【样例解释】**\n\n如上方示意图所示。\n\n以下为 $|S|=2$ 的方案：$\\{A,B\\}$，$\\{A,C\\}$，$\\{A,E\\}$，$\\{A,F\\}$，$\\{B,C\\}$，$\\{B,D\\}$，$\\{B,E\\}$，$\\{B,F\\}$，$\\{C,D\\}$，$\\{C,E\\}$，$\\{C,F\\}$，$\\{D,E\\}$。\n\n以下为 $|S|=3$ 的方案：$\\{A,B,C\\}$，$\\{A,B,E\\}$，$\\{A,B,F\\}$，$\\{A,C,E\\}$，$\\{A,C,F\\}$，$\\{B,C,D\\}$，$\\{B,C,E\\}$，$\\{B,C,F\\}$，$\\{B,D,E\\}$，$\\{C,D,E\\}$。\n\n以下为 $|S|=4$ 的方案：$\\{A,B,C,E\\}$，$\\{A,B,C,F\\}$，$\\{B,C,D,E\\}$。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（4 pts）：$N,M\\leq 2$。\n- Subtask 2（5 pts）：$N=1$。\n- Subtask 3（9 pts）：$T=2$，$N,M\\leq 50$。\n- Subtask 4（11 pts）：$T=2$。\n- Subtask 5（9 pts）：$T=3$，$N,M\\leq 20$。\n- Subtask 6（13 pts）：$T=3$。\n- Subtask 7（14 pts）：$T=1$，$N,M\\leq 4$。\n- Subtask 8（10 pts）：$T=1$，$N,M\\leq 50$。\n- Subtask 9（9 pts）：$T=1$，$A_{i,j}\\neq \\texttt{3}$。\n- Subtask 10（16 pts）：$T=1$。\n\n对于 $100\\%$ 的数据，保证 $1\\leq T\\leq 3$，$1\\leq N,M\\leq 10^3$，$A_{i,j}\\in\\{\\texttt{0},\\texttt{1},\\texttt{2},\\texttt{3}\\}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[eJOI 2023] Opening Offices", "background": "", "description": "你的公司要在 $N\\times M$ 的网格图上建造办公室。如图所示，网格图上有横着和竖着的边，其边权均为 $1$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vfni68lx.png)\n\n在白天，所有道路都是可以走的。在晚上，只有 $N\\times M-1$ 条边有照明且可以走。\n\n你喜欢巡视办公室。每天，你都会以一个顺序从一个办公室开始，经过可用的边遍历每个办公室一次，最后回到起点。你希望选择网格图上一个点的子集 $S$，满足其在白天和晚上进行巡视所需走过的最短路径长度相等。\n\n你希望计算三种条件下，可能的 $S$ 的数量对 $10^9+7$ 取模的值：\n\n1. $|S|\\geq 2$。\n2. $|S|=2$。\n3. $|S|=3$。", "inputFormat": "第一行输入三个整数 $N,M,T$，其中 $T$ 代表你需要计算的问题编号。\n\n接下来 $N$ 行，每行输入一个长度为 $M$ 的字符串 $A_{i,j}$。\n\n- $A_{i,j}\\in\\{\\texttt{1},\\texttt{3}\\}$ 代表 $(i,j)$ 有连向 $(i-1,j)$ 的边。\n- $A_{i,j}\\in\\{\\texttt{2},\\texttt{3}\\}$ 代表 $(i,j)$ 有连向 $(i,j-1)$ 的边。\n\n保证输入的是一棵树。", "outputFormat": "输出一个整数，代表答案对 $10^9+7$ 取模的值。", "hint": "**【样例解释】**\n\n如上方示意图所示。\n\n以下为 $|S|=2$ 的方案：$\\{A,B\\}$，$\\{A,C\\}$，$\\{A,E\\}$，$\\{A,F\\}$，$\\{B,C\\}$，$\\{B,D\\}$，$\\{B,E\\}$，$\\{B,F\\}$，$\\{C,D\\}$，$\\{C,E\\}$，$\\{C,F\\}$，$\\{D,E\\}$。\n\n以下为 $|S|=3$ 的方案：$\\{A,B,C\\}$，$\\{A,B,E\\}$，$\\{A,B,F\\}$，$\\{A,C,E\\}$，$\\{A,C,F\\}$，$\\{B,C,D\\}$，$\\{B,C,E\\}$，$\\{B,C,F\\}$，$\\{B,D,E\\}$，$\\{C,D,E\\}$。\n\n以下为 $|S|=4$ 的方案：$\\{A,B,C,E\\}$，$\\{A,B,C,F\\}$，$\\{B,C,D,E\\}$。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（4 pts）：$N,M\\leq 2$。\n- Subtask 2（5 pts）：$N=1$。\n- Subtask 3（9 pts）：$T=2$，$N,M\\leq 50$。\n- Subtask 4（11 pts）：$T=2$。\n- Subtask 5（9 pts）：$T=3$，$N,M\\leq 20$。\n- Subtask 6（13 pts）：$T=3$。\n- Subtask 7（14 pts）：$T=1$，$N,M\\leq 4$。\n- Subtask 8（10 pts）：$T=1$，$N,M\\leq 50$。\n- Subtask 9（9 pts）：$T=1$，$A_{i,j}\\neq \\texttt{3}$。\n- Subtask 10（16 pts）：$T=1$。\n\n对于 $100\\%$ 的数据，保证 $1\\leq T\\leq 3$，$1\\leq N,M\\leq 10^3$，$A_{i,j}\\in\\{\\texttt{0},\\texttt{1},\\texttt{2},\\texttt{3}\\}$。", "locale": "zh-CN"}}}
{"pid": "P11357", "type": "P", "difficulty": 0, "samples": [["3\n1 4 2\n3 7 5\n6 8 0\n\n", "4\nR 3 6 1\nD 2 3 4\nD 5 6 7\nR 2 5 8"], ["2\n2 1\n0 3", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "Special Judge", "eJOI（欧洲）"], "title": "[eJOI 2023] Square Grid Puzzle", "background": "", "description": "有一个 $N\\times N$ 的矩阵，元素从 $0\\sim N^2-1$ 编号。我们希望通过**小于** $3N$ 次操作将第 $i$ 行第 $j$ 列的元素变为 $i\\cdot N+j$。\n\n你可以对矩阵进行两种操作：\n\n- ``D a[0] a[1] ... a[N-1]``：对矩阵第一行重排，再将每一列向上循环位移一位，你需要保证给出的 $a$ 是矩阵第一行的一个重排。\n\n- ``R b[0] b[1] ... b[N-1]``：对矩阵第一列重排，再将每一行向左循环位移一位，你需要保证给出的 $b$ 是矩阵第一列的一个重排。\n\n例如，如果当前矩阵如下：\n\n|R/C|0|1|2|\n|:-:|:-:|:-:|:-:|\n|0|2|4|6|\n|1|8|1|5|\n|2|7|3|0|\n\n如果对原矩阵执行 ``D 2 6 4``，矩阵会变成下图：\n\n|R/C|0|1|2|\n|:-:|:-:|:-:|:-:|\n|0|8|1|5|\n|1|7|3|0|\n|2|**6**|**2**|**4**|\n\n如果对原矩阵执行 ``R 2 8 7``，矩阵会变成下图：\n\n|R/C|0|1|2|\n|:-:|:-:|:-:|:-:|\n|0|4|6|**2**|\n|1|1|5|**8**|\n|2|3|0|**7**|\n\n即使你使用了 $\\geq 3N$ 次操作，或者有一些数没有复原，你仍然可以得到一些部分分，见 **【评分方式】** 一栏。", "inputFormat": "第一行输入一个整数 $N$。\n\n接下来 $N$ 行每行输入 $N$ 个整数 $F_{i,j}$ 代表初始矩阵。", "outputFormat": "第一行输出一个整数 $M$，代表操作次数。\n\n接下来 $M$ 行每行输出一次操作，格式见上。", "hint": "**【评分方式】**\n\n令 $A=3N$，$B=2N^2$，$C$ 为操作后符合要求的位置个数。\n\n如果你的程序没有正常结束或格式错误或 $M>B$，该测试点不得分。\n\n\n否则，若 $C<N^2$，你获得该测试点 $50\\%\\cdot\\frac{C}{N^2}$ 的分数。\n\n否则，若 $A\\leq M\\leq B$，你获得该测试点 $(40\\cdot(\\frac{B-M}{B-A})^2+50)\\%$ 的分数。\n\n否则，你获得满分。\n\n**【样例解释】**\n\n第一个样例用了 $4$ 次操作复原了矩阵，可以获得 $100\\%$ 的分数。\n\n第二个样例用了 $0$ 次操作复原了 $\\frac{2}{4}=50\\%$ 的位置，可以获得该测试点 $25\\%$ 的分数。\n\n**【数据范围】**\n\n对于 $100\\%$ 的数据，保证 $2\\leq N\\leq 9$，且 $N$ 在测试点中均匀分布。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[eJOI 2023] Square Grid Puzzle", "background": "", "description": "有一个 $N\\times N$ 的矩阵，元素从 $0\\sim N^2-1$ 编号。我们希望通过**小于** $3N$ 次操作将第 $i$ 行第 $j$ 列的元素变为 $i\\cdot N+j$。\n\n你可以对矩阵进行两种操作：\n\n- ``D a[0] a[1] ... a[N-1]``：对矩阵第一行重排，再将每一列向上循环位移一位，你需要保证给出的 $a$ 是矩阵第一行的一个重排。\n\n- ``R b[0] b[1] ... b[N-1]``：对矩阵第一列重排，再将每一行向左循环位移一位，你需要保证给出的 $b$ 是矩阵第一列的一个重排。\n\n例如，如果当前矩阵如下：\n\n|R/C|0|1|2|\n|:-:|:-:|:-:|:-:|\n|0|2|4|6|\n|1|8|1|5|\n|2|7|3|0|\n\n如果对原矩阵执行 ``D 2 6 4``，矩阵会变成下图：\n\n|R/C|0|1|2|\n|:-:|:-:|:-:|:-:|\n|0|8|1|5|\n|1|7|3|0|\n|2|**6**|**2**|**4**|\n\n如果对原矩阵执行 ``R 2 8 7``，矩阵会变成下图：\n\n|R/C|0|1|2|\n|:-:|:-:|:-:|:-:|\n|0|4|6|**2**|\n|1|1|5|**8**|\n|2|3|0|**7**|\n\n即使你使用了 $\\geq 3N$ 次操作，或者有一些数没有复原，你仍然可以得到一些部分分，见 **【评分方式】** 一栏。", "inputFormat": "第一行输入一个整数 $N$。\n\n接下来 $N$ 行每行输入 $N$ 个整数 $F_{i,j}$ 代表初始矩阵。", "outputFormat": "第一行输出一个整数 $M$，代表操作次数。\n\n接下来 $M$ 行每行输出一次操作，格式见上。", "hint": "**【评分方式】**\n\n令 $A=3N$，$B=2N^2$，$C$ 为操作后符合要求的位置个数。\n\n如果你的程序没有正常结束或格式错误或 $M>B$，该测试点不得分。\n\n\n否则，若 $C<N^2$，你获得该测试点 $50\\%\\cdot\\frac{C}{N^2}$ 的分数。\n\n否则，若 $A\\leq M\\leq B$，你获得该测试点 $(40\\cdot(\\frac{B-M}{B-A})^2+50)\\%$ 的分数。\n\n否则，你获得满分。\n\n**【样例解释】**\n\n第一个样例用了 $4$ 次操作复原了矩阵，可以获得 $100\\%$ 的分数。\n\n第二个样例用了 $0$ 次操作复原了 $\\frac{2}{4}=50\\%$ 的位置，可以获得该测试点 $25\\%$ 的分数。\n\n**【数据范围】**\n\n对于 $100\\%$ 的数据，保证 $2\\leq N\\leq 9$，且 $N$ 在测试点中均匀分布。", "locale": "zh-CN"}}}
{"pid": "P11358", "type": "P", "difficulty": 0, "samples": [["13 2 2\n1 2 3 4 3 6 6 8 2 10 11 1", "16\n4\n15\n55\n66\n36\n66\n55\n66\n45\n55\n66\n66"], ["3 0 1\n1 2", "1\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "eJOI（欧洲）"], "title": "[eJOI 2023] Tree Infection", "background": "", "description": "给定一棵 $N$ 个点的有根树 $T$，保证根结点的编号为 $1$。\n\n树上的一个点 $s$ 会被选中，距离 $s$ **不超过** $R$ 的点会被感染，两个点的距离定义为其树上路径的边数。\n\n一对点是可达的当且仅当它们都没有被感染，且其树上路径经过被感染的点数**不超过** $M$。\n\n对于 $s=1,2,\\cdots,N$ 计算选中 $s$ 的可达点对数量。", "inputFormat": "第一行输入三个整数 $N,R,M$。\n\n第二行输入 $N-1$ 个整数 $p_2,p_3,\\cdots,p_N$，代表每个点的父亲。\n", "outputFormat": "输出 $N$ 行，每行一个整数，第 $s$ 行的整数代表选择 $s$ 的答案。", "hint": "**【样例解释】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/088jrf6x.png)\n\n$s=2$ 的树如图所示。\n\n所有可达点对为 $(1,13)$，$(7,8)$，$(7,9)$ 和 $(8,9)$。\n\n注意 $(1,2)$ 不可达，因为 $2$ 已经被感染；$(1,5)$ 不可达，因为路径上有三个被感染的点 $2,3,4$。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（20 pts）：$N\\leq 300$。\n- Subtask 2（14 pts）：$R=0$。\n- Subtask 3（15 pts）：$M=2R+1$。\n- Subtask 4（10 pts）：$M=2R-1$。\n- Subtask 5（16 pts）：$N\\leq 5\\times 10^3$。\n- Subtask 6（25 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，保证 $2\\leq N\\leq 5\\times 10^5$，$1\\leq p_i<i$，$0\\leq R\\leq N-1$，$0\\leq M\\leq 2R+1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[eJOI 2023] Tree Infection", "background": "", "description": "给定一棵 $N$ 个点的有根树 $T$，保证根结点的编号为 $1$。\n\n树上的一个点 $s$ 会被选中，距离 $s$ **不超过** $R$ 的点会被感染，两个点的距离定义为其树上路径的边数。\n\n一对点是可达的当且仅当它们都没有被感染，且其树上路径经过被感染的点数**不超过** $M$。\n\n对于 $s=1,2,\\cdots,N$ 计算选中 $s$ 的可达点对数量。", "inputFormat": "第一行输入三个整数 $N,R,M$。\n\n第二行输入 $N-1$ 个整数 $p_2,p_3,\\cdots,p_N$，代表每个点的父亲。\n", "outputFormat": "输出 $N$ 行，每行一个整数，第 $s$ 行的整数代表选择 $s$ 的答案。", "hint": "**【样例解释】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/088jrf6x.png)\n\n$s=2$ 的树如图所示。\n\n所有可达点对为 $(1,13)$，$(7,8)$，$(7,9)$ 和 $(8,9)$。\n\n注意 $(1,2)$ 不可达，因为 $2$ 已经被感染；$(1,5)$ 不可达，因为路径上有三个被感染的点 $2,3,4$。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（20 pts）：$N\\leq 300$。\n- Subtask 2（14 pts）：$R=0$。\n- Subtask 3（15 pts）：$M=2R+1$。\n- Subtask 4（10 pts）：$M=2R-1$。\n- Subtask 5（16 pts）：$N\\leq 5\\times 10^3$。\n- Subtask 6（25 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，保证 $2\\leq N\\leq 5\\times 10^5$，$1\\leq p_i<i$，$0\\leq R\\leq N-1$，$0\\leq M\\leq 2R+1$。", "locale": "zh-CN"}}}
{"pid": "P11359", "type": "P", "difficulty": 0, "samples": [["4 2\n2 0 2 3\n2 4\n4 0", "10\n14\n12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "eJOI（欧洲）"], "title": "[eJOI 2023] Team Building", "background": "", "description": "你需要集结一个 $N$ 人小队，第 $i$ 个人的能力值为 $s_i$，你可以逐一将每个人加入你的小队。\n\n在你的小队中，每个人拥有两个额外的属性：星语和可爱。加入一个人的过程分三步：\n\n- 这个人进入小队，其星语和可爱值均为 $0$。\n- 剩余所有人的星语值加上自己的可爱值。\n- 剩余所有人的可爱值加上新加入的人的能力值。\n\n最后，你的小队的总星语值定义为所有人的星语值之和，你需要最大化总星语值。\n\n例如，如果你按顺序加入了能力值为 $0,2,2,3$ 的人，所有人的属性变化如下：\n\n|行动|星语|可爱|\n|:-:|:-:|:-:|\n|加入第一个人|$0$|$0$|\n|加入第二个人|$0,0$|$0,0$|\n|更新星语值|$0,0$|$0,0$|\n|更新可爱值|$0,0$|$\\textbf{2},0$|\n|加入第三个人|$0,0,0$|$2,0,0$|\n|更新星语值|$\\textbf{2},\\textbf{0},0$|$2,0,0$|\n|更新可爱值|$2,0,0$|$\\textbf{4},\\textbf{2},0$|\n|加入第四个人|$2,0,0,0$|$4,2,0,0$|\n|更新星语值|$\\textbf{6},\\textbf{2},\\textbf{0},0$|$4,2,0,0$|\n|更新可爱值|$6,2,0,0$|$\\textbf{7},\\textbf{5},\\textbf{3},0$|\n\n此时总星语值为 $6+2+0+0=8$，但是将顺序改为 $2,2,3,0$ 就可以得到 $7+3+0+0=10$。\n\n你还需要处理 $Q$ 次修改，每次修改会将第 $x_i$ 个人的能力值改为 $y_i$，你需要求出每次修改后的最大总星语值，修改之间不独立，即每次修改在下一次保留。", "inputFormat": "第一行输入两个整数 $N,Q$。\n\n第二行输入 $N$ 个整数 $s_i$。\n\n接下来 $Q$ 行，每行输入两个整数 $x_i,y_i$。", "outputFormat": "输出 $Q+1$ 行，每行一个整数，代表初始序列和每次修改后的答案。", "hint": "**【样例解释】**\n\n原始序列的最优方案在题面中已经给出。\n\n第一次修改后的序列为 $(2,4,2,3)$。\n\n第二次修改后的序列为 $(2,4,2,0)$。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（11 pts）：$N\\leq 7$，$Q\\leq 100$。\n- Subtask 2（19 pts）：$N,Q\\leq 500$。\n- Subtask 3（15 pts）：$Q\\leq 10$。\n- Subtask 4（6 pts）：$s_i,y_i\\leq 1$。\n- Subtask 5（9 pts）：$s_i,y_i\\leq 500$。\n- Subtask 6（12 pts）：$x_i=1$。\n- Subtask 7（10 pts）：每次修改和原来的数之差不超过 $1$。\n- Subtask 8（18 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，保证 $2\\leq N\\leq 5\\times 10^4$，$1\\leq Q\\leq 10^5$，$0\\leq s_i\\leq 10^5$，$1\\leq x_i\\leq N$，$0\\leq y_i\\leq 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[eJOI 2023] Team Building", "background": "", "description": "你需要集结一个 $N$ 人小队，第 $i$ 个人的能力值为 $s_i$，你可以逐一将每个人加入你的小队。\n\n在你的小队中，每个人拥有两个额外的属性：星语和可爱。加入一个人的过程分三步：\n\n- 这个人进入小队，其星语和可爱值均为 $0$。\n- 剩余所有人的星语值加上自己的可爱值。\n- 剩余所有人的可爱值加上新加入的人的能力值。\n\n最后，你的小队的总星语值定义为所有人的星语值之和，你需要最大化总星语值。\n\n例如，如果你按顺序加入了能力值为 $0,2,2,3$ 的人，所有人的属性变化如下：\n\n|行动|星语|可爱|\n|:-:|:-:|:-:|\n|加入第一个人|$0$|$0$|\n|加入第二个人|$0,0$|$0,0$|\n|更新星语值|$0,0$|$0,0$|\n|更新可爱值|$0,0$|$\\textbf{2},0$|\n|加入第三个人|$0,0,0$|$2,0,0$|\n|更新星语值|$\\textbf{2},\\textbf{0},0$|$2,0,0$|\n|更新可爱值|$2,0,0$|$\\textbf{4},\\textbf{2},0$|\n|加入第四个人|$2,0,0,0$|$4,2,0,0$|\n|更新星语值|$\\textbf{6},\\textbf{2},\\textbf{0},0$|$4,2,0,0$|\n|更新可爱值|$6,2,0,0$|$\\textbf{7},\\textbf{5},\\textbf{3},0$|\n\n此时总星语值为 $6+2+0+0=8$，但是将顺序改为 $2,2,3,0$ 就可以得到 $7+3+0+0=10$。\n\n你还需要处理 $Q$ 次修改，每次修改会将第 $x_i$ 个人的能力值改为 $y_i$，你需要求出每次修改后的最大总星语值，修改之间不独立，即每次修改在下一次保留。", "inputFormat": "第一行输入两个整数 $N,Q$。\n\n第二行输入 $N$ 个整数 $s_i$。\n\n接下来 $Q$ 行，每行输入两个整数 $x_i,y_i$。", "outputFormat": "输出 $Q+1$ 行，每行一个整数，代表初始序列和每次修改后的答案。", "hint": "**【样例解释】**\n\n原始序列的最优方案在题面中已经给出。\n\n第一次修改后的序列为 $(2,4,2,3)$。\n\n第二次修改后的序列为 $(2,4,2,0)$。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（11 pts）：$N\\leq 7$，$Q\\leq 100$。\n- Subtask 2（19 pts）：$N,Q\\leq 500$。\n- Subtask 3（15 pts）：$Q\\leq 10$。\n- Subtask 4（6 pts）：$s_i,y_i\\leq 1$。\n- Subtask 5（9 pts）：$s_i,y_i\\leq 500$。\n- Subtask 6（12 pts）：$x_i=1$。\n- Subtask 7（10 pts）：每次修改和原来的数之差不超过 $1$。\n- Subtask 8（18 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，保证 $2\\leq N\\leq 5\\times 10^4$，$1\\leq Q\\leq 10^5$，$0\\leq s_i\\leq 10^5$，$1\\leq x_i\\leq N$，$0\\leq y_i\\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P11360", "type": "P", "difficulty": 6, "samples": [["10 11\n1 7\n1 8\n1 6\n2 8\n6 7\n5 8\n2 5\n2 3\n2 4\n3 4\n10 9", "1 8\n9 10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384]}, "tags": ["图论", "2015", "Special Judge", "CEOI（中欧）", "哈希 hashing"], "title": "[CEOI 2015] 管道", "background": "", "description": "**简要题意**：$\\,$ 给出一个 $N$ 点 $M$ 边的无向图，不保证连通。将每个联通块视为子图，请求出每一个子图中的桥。**你只有 16 MB 的内存空间**。\n\n---\n\n在 Cahoots 的国度里，Lomikel 是掌管管道的神。他管理水管、排水沟、下水道，甚至地铁隧道。人们在许许多多的圣泉旁敬拜他，这些圣泉由一个巨大的管道网络连接起来。每个管道直接连接两泓圣泉。\n\n每个假期，Supreme Plumber（Lomikel 的最高祭司）会进行一场十分复杂的仪式，包括以管道运送圣水。\n\n有时，Lomikel 的愤怒会导致管道破裂，所以 Plumber 不得不使用其他路径，使得圣水在破裂的管道周围流动。然而凡事总有不尽人意之处，对于某些管道，不存在不同的路径。这些管道被称为“关键管道”，Plumber 必须特别注意。您可以在下图中看到用粗线标出的关键管道。\n\n![](https://i.loli.net/2018/08/12/5b6f9bfa600d8.png)\n\n你的任务是为 Plumber 找到所有关键管道。然而，网络错综复杂，而你只有非常有限的内存。**空间限制仅为 16 MB**。", "inputFormat": "第一行，两个整数 $N$ 和 $M$，分别表示泉水的数量与管道的数量 $(1 \\leq N \\leq 100\\ 000,1 \\leq M \\leq 6\\ 000\\ 000)$。\n\n接下来 $M$ 行，每行两个整数 $u$ 和 $v$，表示有一条由 $u$ 连接 $v$ 的管道 $(1 \\leq u,v \\leq N)$。\n\n两泓圣泉可以由多个管道连接，但单个管道的端点总是不同的弹簧。\n\n技术提示：可以对标准输入进行查找（例如返回其起始位置），但查找并不是解决问题的关键。此外，若采用多次读取输入的方式效率可能会大幅下降。", "outputFormat": "输出若干行，每行两个整数，表示一条关键管道连接的两泓圣泉。\n\n关键管道可以以任意顺序列出，单个管道的端点也是如此。", "hint": "$N$ 和 $M$ 的上限如下表所示：\n\n|数据点|1|2|3|4|5|6|7|8|9|10|\n|-|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|$N\\le$|$100$|$5000$|$4000$|$10^5$|$3\\times 10^4$|$7\\times 10^4$|$8\\times 10^4$|$10^5$|$10^5$|$10^5$|\n|$M\\le$|$200$|$1.5\\times 10^4$|$6\\times 10^5$|$1.2\\times 10^6$|$1.5\\times 10^6$|$2\\times 10^6$|$3\\times 10^6$|$4\\times 10^6$|$5\\times 10^6$|$6\\times 10^6$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2015] 管道", "background": "", "description": "**简要题意**：$\\,$ 给出一个 $N$ 点 $M$ 边的无向图，不保证连通。将每个联通块视为子图，请求出每一个子图中的桥。**你只有 16 MB 的内存空间**。\n\n---\n\n在 Cahoots 的国度里，Lomikel 是掌管管道的神。他管理水管、排水沟、下水道，甚至地铁隧道。人们在许许多多的圣泉旁敬拜他，这些圣泉由一个巨大的管道网络连接起来。每个管道直接连接两泓圣泉。\n\n每个假期，Supreme Plumber（Lomikel 的最高祭司）会进行一场十分复杂的仪式，包括以管道运送圣水。\n\n有时，Lomikel 的愤怒会导致管道破裂，所以 Plumber 不得不使用其他路径，使得圣水在破裂的管道周围流动。然而凡事总有不尽人意之处，对于某些管道，不存在不同的路径。这些管道被称为“关键管道”，Plumber 必须特别注意。您可以在下图中看到用粗线标出的关键管道。\n\n![](https://i.loli.net/2018/08/12/5b6f9bfa600d8.png)\n\n你的任务是为 Plumber 找到所有关键管道。然而，网络错综复杂，而你只有非常有限的内存。**空间限制仅为 16 MB**。", "inputFormat": "第一行，两个整数 $N$ 和 $M$，分别表示泉水的数量与管道的数量 $(1 \\leq N \\leq 100\\ 000,1 \\leq M \\leq 6\\ 000\\ 000)$。\n\n接下来 $M$ 行，每行两个整数 $u$ 和 $v$，表示有一条由 $u$ 连接 $v$ 的管道 $(1 \\leq u,v \\leq N)$。\n\n两泓圣泉可以由多个管道连接，但单个管道的端点总是不同的弹簧。\n\n技术提示：可以对标准输入进行查找（例如返回其起始位置），但查找并不是解决问题的关键。此外，若采用多次读取输入的方式效率可能会大幅下降。", "outputFormat": "输出若干行，每行两个整数，表示一条关键管道连接的两泓圣泉。\n\n关键管道可以以任意顺序列出，单个管道的端点也是如此。", "hint": "$N$ 和 $M$ 的上限如下表所示：\n\n|数据点|1|2|3|4|5|6|7|8|9|10|\n|-|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|$N\\le$|$100$|$5000$|$4000$|$10^5$|$3\\times 10^4$|$7\\times 10^4$|$8\\times 10^4$|$10^5$|$10^5$|$10^5$|\n|$M\\le$|$200$|$1.5\\times 10^4$|$6\\times 10^5$|$1.2\\times 10^6$|$1.5\\times 10^6$|$2\\times 10^6$|$3\\times 10^6$|$4\\times 10^6$|$5\\times 10^6$|$6\\times 10^6$|", "locale": "zh-CN"}}}
{"pid": "P11361", "type": "P", "difficulty": 5, "samples": [["1\n6\n011101\n111010\n111010\n101101", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "贪心", "2024", "NOIP 提高组", "前缀和", "Ad-hoc"], "title": "[NOIP2024] 编辑字符串", "background": null, "description": "小 M 有两个长度为 $n$ 且字符集为 $\\{0, 1\\}$ 的字符串 $s_1, s_2$。\n\n小 M 希望两个字符串中对应位置字符相同的出现次数尽可能多，即满足 $s_{1,i} = s_{2,i}$ 的 $i(1 \\leq i \\leq n)$ 尽可能多。为此小 M 有一个字符串编辑工具，这个工具提供的基本操作是在一个字符串中交换两个**相邻**的字符。为了保持字符串的可辨识性，规定两个字符串中的部分字符不能参与交换。小 M 可以用工具对 $s_1$ 或 $s_2$ 进行多次字符交换，其中可以参与交换的字符能够交换任意多次。\n\n现在小 M 想知道，在使用编辑工具后，两个字符串中对应位置字符相同的出现次数最多能有多少。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含一个整数 $T$，表示测试数据的组数。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n\n- 第一行包含一个整数 $n$，表示字符串长度。\n- 第二行包含一个长度为 $n$ 且字符集为 $\\{0, 1\\}$ 的字符串 $s_1$。\n- 第三行包含一个长度为 $n$ 且字符集为 $\\{0, 1\\}$ 的字符串 $s_2$。\n- 第四行包含一个长度为 $n$ 且字符集为 $\\{0, 1\\}$ 的字符串 $t_1$，其中 $t_{1,i}$ 为 $1$ 表示 $s_{1,i}$ 可以参与交换，$t_{1,i}$ 为 $0$ 表示 $s_{1,i}$ 不可以参与交换。\n- 第五行包含一个长度为 $n$ 且字符集为 $\\{0, 1\\}$ 的字符串 $t_2$，其中 $t_{2,i}$ 为 $1$ 表示 $s_{2,i}$ 可以参与交换，$t_{2,i}$ 为 $0$ 表示 $s_{2,i}$ 不可以参与交换。", "outputFormat": "对于每组测试数据输出一行，包含一个整数，表示对应的答案。", "hint": "**【样例 1 解释】**\n\n最开始时，$s_1 = \\tt{011101}$，第 $4$ 和第 $6$ 个字符不能参与交换；$s_2 = \\tt{111010}$，第 $2$ 和第 $5$ 个字符不能参与交换。\n\n考虑如下操作：先交换 $s_{1,1}$ 与 $s_{1,2}$ 得到 $s_1 = \\tt{101101}$，再交换 $s_{1,2}$ 与 $s_{1,3}$ 得到 $s_1 = \\tt{110101}$，最后交换 $s_{2,3}$ 与 $s_{2,4}$ 得到 $s_2 = \\tt{110110}$。此时 $s_1$ 与 $s_2$ 的前 $4$ 个位置上的字符都是相同的。可以证明不存在更好的方案，故输出 $4$。\n\n**【样例 2 解释】**\n\n见附件的 edit/edit2.in 与 edit/edit2.ans。\n\n该样例共有 $10$ 组测试数据，其中第 $i(1 \\leq i \\leq 10)$ 组测试数据满足数据范围中描述的测试点 $2i - 1$ 的限制。\n\n**【数据范围】**\n\n对于所有的测试数据，保证：$1 \\leq T \\leq 10$，$1 \\leq n \\leq 10^5$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1\\sim 4$ | $10$ | 无 |\n| $5,6$ | $10^3$ | A |\n| $7,8$ | $10^5$ | ^ |\n| $9,10$ | $10^3$ | B |\n| $11,12$ | $10^5$ | ^ |\n| $13,14$ | $10^3$ | C |\n| $15,16$ | $10^5$ | ^ |\n| $17,18$ | $10^3$ | 无 |\n| $19,20$ | $10^5$ | ^ |\n\n\n- 特殊性质 A：保证 $s_1$ 的所有字符相同。\n- 特殊性质 B：保证 $t_1 = t_2$。\n- 特殊性质 C：保证 $t_1$ 和 $t_2$ 中各自恰有一个字符  $\\tt 0$。", "locale": "zh-CN", "translations": {"en": {"title": "Edit Strings", "background": "", "description": "Xiao M has two binary strings $s_1$ and $s_2$ of length $n$ (character set $\\{0, 1\\}$).\n\nXiao M wants to maximize the number of positions where the corresponding characters in the two strings are the same, i.e., maximize the count of indices $i$ ($1 \\leq i \\leq n$) satisfying $s_{1,i} = s_{2,i}$. To achieve this, Xiao M has a string editing tool that allows swapping two **adjacent** characters in a string. However, some characters in the strings are marked as non-swappable. Xiao M can perform multiple swap operations on $s_1$ or $s_2$, and swappable characters can be moved any number of times.\n\nNow, Xiao M wants to know the maximum number of matching positions that can be achieved after using the editing tool.", "inputFormat": "**The problem contains multiple test cases.**\n\nThe first line of input contains an integer $T$, representing the number of test cases.\n\nThis is followed by $T$ test cases, each formatted as follows:\n\n- The first line contains an integer $n$, the length of the strings.\n- The second line contains a binary string $s_1$ of length $n$.\n- The third line contains a binary string $s_2$ of length $n$.\n- The fourth line contains a binary string $t_1$ of length $n$, where $t_{1,i} = 1$ means $s_{1,i}$ is swappable, and $t_{1,i} = 0$ means it is not.\n- The fifth line contains a binary string $t_2$ of length $n$, where $t_{2,i} = 1$ means $s_{2,i}$ is swappable, and $t_{2,i} = 0$ means it is not.", "outputFormat": "For each test case, output one line containing an integer, the maximum number of matching positions.\n", "hint": "### Explanation for Sample #1\n\nInitially, $s_1 = \\tt{011101}$ (positions 4 and 6 are non-swappable), and $s_2 = \\tt{111010}$ (positions 2 and 5 are non-swappable).\n\nOne possible sequence of operations:\n1. Swap $s_{1,1}$ and $s_{1,2}$ to get $s_1 = \\tt{101101}$.\n2. Swap $s_{1,2}$ and $s_{1,3}$ to get $s_1 = \\tt{110101}$.\n3. Swap $s_{2,3}$ and $s_{2,4}$ to get $s_2 = \\tt{110110}$.\n\nNow, the first 4 positions of $s_1$ and $s_2$ match. It can be proven that no better solution exists, so the answer is 4.\n\n### Explanation for Sample #2\n\nSee files `edit/edit2.in` and `edit/edit2.ans` in the attachment.\n\nThis sample contains 10 test cases, where the $i$-th test case ($1 \\leq i \\leq 10$) satisfies the constraints described for test point $2i - 1$ in the data range.\n\n### Data Range\n\nFor all test data, it is guaranteed that: $1 \\leq T \\leq 10$, $1 \\leq n \\leq 10^5$.\n\n| Test Case Number | $n \\leq$ | Special Property |\n| :--------------: | :------: | :--------------: |\n|     1∼4          |   10     |       None       |\n|     5,6          |  $10^3$  |        A         |\n|     7,8          |  $10^5$  |        A         |\n|     9,10         |  $10^3$  |        B         |\n|     11,12        |  $10^5$  |        B         |\n|     13,14        |  $10^3$  |        C         |\n|     15,16        |  $10^5$  |        C         |\n|     17,18        |  $10^3$  |       None       |\n|     19,20        |  $10^5$  |       None       |\n\n- **Special Property A**: All characters in $s_1$ are the same.\n- **Special Property B**: $t_1 = t_2$.\n- **Special Property C**: Exactly one '0' exists in each of $t_1$ and $t_2$.\n\nTranslated by DeepSeek R1", "locale": "en"}, "zh-CN": {"title": "[NOIP2024] 编辑字符串", "background": null, "description": "小 M 有两个长度为 $n$ 且字符集为 $\\{0, 1\\}$ 的字符串 $s_1, s_2$。\n\n小 M 希望两个字符串中对应位置字符相同的出现次数尽可能多，即满足 $s_{1,i} = s_{2,i}$ 的 $i(1 \\leq i \\leq n)$ 尽可能多。为此小 M 有一个字符串编辑工具，这个工具提供的基本操作是在一个字符串中交换两个**相邻**的字符。为了保持字符串的可辨识性，规定两个字符串中的部分字符不能参与交换。小 M 可以用工具对 $s_1$ 或 $s_2$ 进行多次字符交换，其中可以参与交换的字符能够交换任意多次。\n\n现在小 M 想知道，在使用编辑工具后，两个字符串中对应位置字符相同的出现次数最多能有多少。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含一个整数 $T$，表示测试数据的组数。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n\n- 第一行包含一个整数 $n$，表示字符串长度。\n- 第二行包含一个长度为 $n$ 且字符集为 $\\{0, 1\\}$ 的字符串 $s_1$。\n- 第三行包含一个长度为 $n$ 且字符集为 $\\{0, 1\\}$ 的字符串 $s_2$。\n- 第四行包含一个长度为 $n$ 且字符集为 $\\{0, 1\\}$ 的字符串 $t_1$，其中 $t_{1,i}$ 为 $1$ 表示 $s_{1,i}$ 可以参与交换，$t_{1,i}$ 为 $0$ 表示 $s_{1,i}$ 不可以参与交换。\n- 第五行包含一个长度为 $n$ 且字符集为 $\\{0, 1\\}$ 的字符串 $t_2$，其中 $t_{2,i}$ 为 $1$ 表示 $s_{2,i}$ 可以参与交换，$t_{2,i}$ 为 $0$ 表示 $s_{2,i}$ 不可以参与交换。", "outputFormat": "对于每组测试数据输出一行，包含一个整数，表示对应的答案。", "hint": "**【样例 1 解释】**\n\n最开始时，$s_1 = \\tt{011101}$，第 $4$ 和第 $6$ 个字符不能参与交换；$s_2 = \\tt{111010}$，第 $2$ 和第 $5$ 个字符不能参与交换。\n\n考虑如下操作：先交换 $s_{1,1}$ 与 $s_{1,2}$ 得到 $s_1 = \\tt{101101}$，再交换 $s_{1,2}$ 与 $s_{1,3}$ 得到 $s_1 = \\tt{110101}$，最后交换 $s_{2,3}$ 与 $s_{2,4}$ 得到 $s_2 = \\tt{110110}$。此时 $s_1$ 与 $s_2$ 的前 $4$ 个位置上的字符都是相同的。可以证明不存在更好的方案，故输出 $4$。\n\n**【样例 2 解释】**\n\n见附件的 edit/edit2.in 与 edit/edit2.ans。\n\n该样例共有 $10$ 组测试数据，其中第 $i(1 \\leq i \\leq 10)$ 组测试数据满足数据范围中描述的测试点 $2i - 1$ 的限制。\n\n**【数据范围】**\n\n对于所有的测试数据，保证：$1 \\leq T \\leq 10$，$1 \\leq n \\leq 10^5$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1\\sim 4$ | $10$ | 无 |\n| $5,6$ | $10^3$ | A |\n| $7,8$ | $10^5$ | ^ |\n| $9,10$ | $10^3$ | B |\n| $11,12$ | $10^5$ | ^ |\n| $13,14$ | $10^3$ | C |\n| $15,16$ | $10^5$ | ^ |\n| $17,18$ | $10^3$ | 无 |\n| $19,20$ | $10^5$ | ^ |\n\n\n- 特殊性质 A：保证 $s_1$ 的所有字符相同。\n- 特殊性质 B：保证 $t_1 = t_2$。\n- 特殊性质 C：保证 $t_1$ 和 $t_2$ 中各自恰有一个字符  $\\tt 0$。", "locale": "zh-CN"}}}
{"pid": "P11362", "type": "P", "difficulty": 4, "samples": [["3\n2 1 2\n1 1\n2 2 2\n1 1\n2 2\n2 2 2\n1 1\n1 2\n", "4\n3\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "NOIP 提高组", "O2优化", "组合数学"], "title": "[NOIP2024] 遗失的赋值", "background": null, "description": "小 F 有 $n$ 个变量 $x_1, x_2, \\ldots , x_n$。每个变量可以取 $1$ 至 $v$ 的整数取值。\n\n小 F 在这 $n$ 个变量之间添加了 $n - 1$ 条二元限制，其中第 $i$（$1 \\leq i \\leq n - 1$）条限制为：若 $x_i = a_i$，则要求 $x_{i+1} = b_i$，**且 $a_i$ 与 $b_i$ 为 $1$ 到 $v$ 之间的整数**；当 $x_i \\neq a_i$ 时，第 $i$ 条限制对 $x_{i+1}$ 的值不做任何约束。除此之外，小 F 还添加了 $m$ 条一元限制，其中第 $j$（$1 \\leq j \\leq m$）条限制为：$x_{c_j} = d_j$。\n\n小 F 记住了所有 $c_j$ 和 $d_j$ 的值，但把所有 $a_i$ 和 $b_i$ 的值都忘了。同时小 F 知道：存在给每一个变量赋值的方案同时满足所有这些限制。\n\n现在小 F 想知道，有多少种 $a_i, b_i$（$1 \\leq i \\leq n - 1$）取值的组合，使得能够确保至少存在一种给每个变量 $x_i$ 赋值的方案可以同时满足所有限制。由于方案数可能很大，小 F 只需要你输出方案数对 $10^9 + 7$ 取模的结果。", "inputFormat": "**本题包含多组测试数据**。\n\n输入的第一行包含一个整数 $T$，表示测试数据的组数。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n\n第一行包含三个整数 $n, m, v$，分别表示变量个数、一元限制个数和变量的取值上限。\n\n接下来 $m$ 行，第 $j$ 行包含两个整数 $c_j, d_j$，描述一个一元限制。", "outputFormat": "对于每组测试数据输出一行，包含一个整数，表示方案数对 $10^9 + 7$ 取模的结果。", "hint": "**【样例 1 解释】**\n\n- 对于第一组测试数据，所有可能的 $(a_1, b_1)$ 取值的组合 $(1, 1), (1, 2), (2, 1), (2, 2)$ 都满足限制。例如，$(a_1, b_1) = (1, 1)$ 时，$(x_1, x_2) = (1, 1)$ 满足所有限制，而 $(a_1, b_1) = (2, 2)$ 时，$(x_1, x_2) = (1, 1)$ 与 $(x_1, x_2) = (1, 2)$ 均满足所有限制。\n- 对于第二组测试数据，只有 $(x_1, x_2) = (1, 2)$ 一种可能的变量赋值，因此只有 $(a_1, b_1) = (1, 1)$ 不满足限制，其余三种赋值均满足限制。\n- 对于第三组测试数据，不存在一种变量赋值同时满足 $x_1 = 1$ 和 $x_1 = 2$，因此也不存在满足限制的 $(a_1, b_1)$。\n\n**【样例 2】**\n\n见选手目录下的 `assign/assign2.in` 与 `assign/assign2.ans`。\n\n该样例共有 $10$ 组测试数据，其中第 $i$（$1 \\leq i \\leq 10$）组测试数据满足数据范围中描述的测试点 $i$ 的限制。\n\n**【样例 3】**\n\n见选手目录下的 `assign/assign3.in` 与 `assign/assign3.ans`。\n\n该样例共有 $10$ 组测试数据，其中第 $i$（$1 \\leq i \\leq 10$）组测试数据满足数据范围中描述的测试点 $i + 10$ 的限制。\n\n**【数据范围】**\n\n对于所有的测试数据，保证：\n\n- $1 \\leq T \\leq 10$，\n- $1 \\leq n \\leq 10^9$，$1 \\leq m \\leq 10^5$，$2 \\leq v \\leq 10^9$，\n- 对于任意的 $j$（$1 \\leq j \\leq m$），都有 $1 \\leq c_j \\leq n$，$1 \\leq d_j \\leq v$。\n\n::cute-table{tuack}\n\n| 测试点 | $n \\leq$ | $m \\leq$ | $v \\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1, 2$ | $6$ | $6$ | $2$ | 无 |\n| $3$ | $9$ | $9$ | ^ | ^ |\n| $4, 5$ | $12$ | $12$ | ^ | ^ |\n| $6$ | $10^3$ | $1$ | $10^3$ | ^ |\n| $7$ | $10^5$ | ^ | $10^5$ | ^ |\n| $8,9$ | $10^9$ | ^ | $10^9$ | ^ |\n| $10$ | $10^3$ | $10^3$ | $10^3$ | A |\n| $11$ | $10^4$ | $10^4$ | $10^4$ | ^ |\n| $12$ | $10^5$ | $10^5$ | $10^5$ | ^ |\n| $13$ | $10^4$ | $10^3$ | $10^4$ | B |\n| $14$ | $10^6$ | $10^4$ | $10^6$ | ^ |\n| $15, 16$ | $10^9$ | $10^5$ | $10^9$ | ^ |\n| $17$ | $10^4$ | $10^3$ | $10^4$ | 无 |\n| $18$ | $10^6$ | $10^4$ | $10^6$ | ^ |\n| $19, 20$ | $10^9$ | $10^5$ | $10^9$ | ^ |\n\n特殊性质 A：保证 $m = n$，且对于任意的 $j$（$1 \\leq j \\leq m$），都有 $c_j = j$。\n\n特殊性质 B：保证 $d_j = 1$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP2024] The Lost Assignment", "background": "", "description": "Xiao F has $n$ variables $x_1, x_2, \\ldots, x_n$. Each variable can take integer values from $1$ to $v$.\n\nXiao F added $n - 1$ binary constraints between these variables. The $i$-th constraint ($1 \\leq i \\leq n - 1$) is: if $x_i = a_i$, then $x_{i+1} = b_i$ must hold, **where $a_i$ and $b_i$ are integers between $1$ and $v$**. When $x_i \\neq a_i$, the $i$-th constraint imposes no restrictions on $x_{i+1}$. Additionally, Xiao F added $m$ unary constraints, where the $j$-th constraint ($1 \\leq j \\leq m$) states $x_{c_j} = d_j$.\n\nXiao F remembers all $c_j$ and $d_j$ values but has forgotten all $a_i$ and $b_i$ values. However, Xiao F knows that **there exists an assignment to all variables that satisfies all constraints**.\n\nNow, Xiao F wants to determine how many possible combinations of $a_i, b_i$ ($1 \\leq i \\leq n - 1$) exist such that there is **at least one valid assignment** satisfying all constraints. Since the number might be large, output the result modulo $10^9 + 7$.", "inputFormat": "**The problem contains multiple test cases.**\n\nThe first line of input contains an integer $T$, the number of test cases.\n\nThis is followed by $T$ test cases, each formatted as follows:\n\n- The first line contains three integers $n$, $m$, $v$, representing the number of variables, the number of unary constraints, and the upper bound of variable values.\n- The next $m$ lines each contain two integers $c_j$, $d_j$, describing a unary constraint.", "outputFormat": "For each test case, output one line containing an integer, the number of valid combinations modulo $10^9 + 7$.", "hint": "### Explanation for Sample #1\n\n- **First test case**: All possible $(a_1, b_1)$ combinations $(1,1)$, $(1,2)$, $(2,1)$, $(2,2)$ are valid. For example:\n  - When $(a_1, b_1) = (1,1)$, $(x_1, x_2) = (1,1)$ satisfies all constraints.\n  - When $(a_1, b_1) = (2,2)$, both $(x_1, x_2) = (1,1)$ and $(x_1, x_2) = (1,2)$ are valid.\n  \n- **Second test case**: The only valid assignment is $(x_1, x_2) = (1,2)$. Thus:\n  - $(a_1, b_1) = (1,1)$ is invalid (requires $x_2=1$), but the other three combinations are valid.\n  \n- **Third test case**: No assignment satisfies both $x_1=1$ and $x_1=2$, so no valid combinations exist.\n\n### Sample #2\n\nSee files `assign/assign2.in` and `assign/assign2.ans` in the problem directory.\n\nThis sample contains 10 test cases, where the $i$-th test case ($1 \\leq i \\leq 10$) satisfies the constraints for test point $i$ in the data range.\n\n### Sample #3\n\nSee files `assign/assign3.in` and `assign/assign3.ans` in the problem directory.\n\nThis sample contains 10 test cases, where the $i$-th test case ($1 \\leq i \\leq 10$) satisfies the constraints for test point $i + 10$ in the data range.\n\n### Data Range\n\nFor all test data, it is guaranteed that:\n- $1 \\leq T \\leq 10$,\n- $1 \\leq n \\leq 10^9$, $1 \\leq m \\leq 10^5$, $2 \\leq v \\leq 10^9$,\n- For all $j$ ($1 \\leq j \\leq m$), $1 \\leq c_j \\leq n$, $1 \\leq d_j \\leq v$.\n\n| Test Case | $n \\leq$ | $m \\leq$ | $v \\leq$ | Special Property |\n| :-------: | :------: | :------: | :------: | :--------------: |\n| 1, 2      | 6        | 6        | 2        | None             |\n| 3         | 9        | 9        | 2        | None             |\n| 4, 5      | 12       | 12       | 2        | None             |\n| 6         | $10^3$   | 1        | $10^3$   | None             |\n| 7         | $10^5$   | 1        | $10^5$   | None             |\n| 8, 9      | $10^9$   | 1        | $10^9$   | None             |\n| 10        | $10^3$   | $10^3$   | $10^3$   | A                |\n| 11        | $10^4$   | $10^4$   | $10^4$   | A                |\n| 12        | $10^5$   | $10^5$   | $10^5$   | A                |\n| 13        | $10^4$   | $10^3$   | $10^4$   | B                |\n| 14        | $10^6$   | $10^4$   | $10^6$   | B                |\n| 15, 16    | $10^9$   | $10^5$   | $10^9$   | B                |\n| 17        | $10^4$   | $10^3$   | $10^4$   | None             |\n| 18        | $10^6$   | $10^4$   | $10^6$   | None             |\n| 19, 20    | $10^9$   | $10^5$   | $10^9$   | None             |\n\n- **Special Property A**: $m = n$ and $c_j = j$ for all $j$ ($1 \\leq j \\leq m$).\n- **Special Property B**: $d_j = 1$ for all $j$ ($1 \\leq j \\leq m$).\n\nTranslated by DeepSeek R1", "locale": "en"}, "zh-CN": {"title": "[NOIP2024] 遗失的赋值", "background": null, "description": "小 F 有 $n$ 个变量 $x_1, x_2, \\ldots , x_n$。每个变量可以取 $1$ 至 $v$ 的整数取值。\n\n小 F 在这 $n$ 个变量之间添加了 $n - 1$ 条二元限制，其中第 $i$（$1 \\leq i \\leq n - 1$）条限制为：若 $x_i = a_i$，则要求 $x_{i+1} = b_i$，**且 $a_i$ 与 $b_i$ 为 $1$ 到 $v$ 之间的整数**；当 $x_i \\neq a_i$ 时，第 $i$ 条限制对 $x_{i+1}$ 的值不做任何约束。除此之外，小 F 还添加了 $m$ 条一元限制，其中第 $j$（$1 \\leq j \\leq m$）条限制为：$x_{c_j} = d_j$。\n\n小 F 记住了所有 $c_j$ 和 $d_j$ 的值，但把所有 $a_i$ 和 $b_i$ 的值都忘了。同时小 F 知道：存在给每一个变量赋值的方案同时满足所有这些限制。\n\n现在小 F 想知道，有多少种 $a_i, b_i$（$1 \\leq i \\leq n - 1$）取值的组合，使得能够确保至少存在一种给每个变量 $x_i$ 赋值的方案可以同时满足所有限制。由于方案数可能很大，小 F 只需要你输出方案数对 $10^9 + 7$ 取模的结果。", "inputFormat": "**本题包含多组测试数据**。\n\n输入的第一行包含一个整数 $T$，表示测试数据的组数。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n\n第一行包含三个整数 $n, m, v$，分别表示变量个数、一元限制个数和变量的取值上限。\n\n接下来 $m$ 行，第 $j$ 行包含两个整数 $c_j, d_j$，描述一个一元限制。", "outputFormat": "对于每组测试数据输出一行，包含一个整数，表示方案数对 $10^9 + 7$ 取模的结果。", "hint": "**【样例 1 解释】**\n\n- 对于第一组测试数据，所有可能的 $(a_1, b_1)$ 取值的组合 $(1, 1), (1, 2), (2, 1), (2, 2)$ 都满足限制。例如，$(a_1, b_1) = (1, 1)$ 时，$(x_1, x_2) = (1, 1)$ 满足所有限制，而 $(a_1, b_1) = (2, 2)$ 时，$(x_1, x_2) = (1, 1)$ 与 $(x_1, x_2) = (1, 2)$ 均满足所有限制。\n- 对于第二组测试数据，只有 $(x_1, x_2) = (1, 2)$ 一种可能的变量赋值，因此只有 $(a_1, b_1) = (1, 1)$ 不满足限制，其余三种赋值均满足限制。\n- 对于第三组测试数据，不存在一种变量赋值同时满足 $x_1 = 1$ 和 $x_1 = 2$，因此也不存在满足限制的 $(a_1, b_1)$。\n\n**【样例 2】**\n\n见选手目录下的 `assign/assign2.in` 与 `assign/assign2.ans`。\n\n该样例共有 $10$ 组测试数据，其中第 $i$（$1 \\leq i \\leq 10$）组测试数据满足数据范围中描述的测试点 $i$ 的限制。\n\n**【样例 3】**\n\n见选手目录下的 `assign/assign3.in` 与 `assign/assign3.ans`。\n\n该样例共有 $10$ 组测试数据，其中第 $i$（$1 \\leq i \\leq 10$）组测试数据满足数据范围中描述的测试点 $i + 10$ 的限制。\n\n**【数据范围】**\n\n对于所有的测试数据，保证：\n\n- $1 \\leq T \\leq 10$，\n- $1 \\leq n \\leq 10^9$，$1 \\leq m \\leq 10^5$，$2 \\leq v \\leq 10^9$，\n- 对于任意的 $j$（$1 \\leq j \\leq m$），都有 $1 \\leq c_j \\leq n$，$1 \\leq d_j \\leq v$。\n\n::cute-table{tuack}\n\n| 测试点 | $n \\leq$ | $m \\leq$ | $v \\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1, 2$ | $6$ | $6$ | $2$ | 无 |\n| $3$ | $9$ | $9$ | ^ | ^ |\n| $4, 5$ | $12$ | $12$ | ^ | ^ |\n| $6$ | $10^3$ | $1$ | $10^3$ | ^ |\n| $7$ | $10^5$ | ^ | $10^5$ | ^ |\n| $8,9$ | $10^9$ | ^ | $10^9$ | ^ |\n| $10$ | $10^3$ | $10^3$ | $10^3$ | A |\n| $11$ | $10^4$ | $10^4$ | $10^4$ | ^ |\n| $12$ | $10^5$ | $10^5$ | $10^5$ | ^ |\n| $13$ | $10^4$ | $10^3$ | $10^4$ | B |\n| $14$ | $10^6$ | $10^4$ | $10^6$ | ^ |\n| $15, 16$ | $10^9$ | $10^5$ | $10^9$ | ^ |\n| $17$ | $10^4$ | $10^3$ | $10^4$ | 无 |\n| $18$ | $10^6$ | $10^4$ | $10^6$ | ^ |\n| $19, 20$ | $10^9$ | $10^5$ | $10^9$ | ^ |\n\n特殊性质 A：保证 $m = n$，且对于任意的 $j$（$1 \\leq j \\leq m$），都有 $c_j = j$。\n\n特殊性质 B：保证 $d_j = 1$。", "locale": "zh-CN"}}}
{"pid": "P11363", "type": "P", "difficulty": 6, "samples": [["1 1\n4 1\n1 2\n2 3\n2 4\n1", "2"], ["7 1\n5 2\n1 2\n1 3\n2 4\n2 5\n1 3", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "NOIP 提高组", "树形 DP", "容斥原理"], "title": "[NOIP2024] 树的遍历", "background": null, "description": "小 Q 是一个算法竞赛初学者，正在学习图论知识中的树的遍历。一棵由 $n$ 个结点，$n - 1$ 条边构成的树，初始时所有结点都未被标记，它的遍历过程如下：\n\n1. 选择一个结点 $s$ 作为遍历起始结点，并把该结点打上标记。\n2. 假设当前访问的结点为 $u$，寻找任意一个与 $u$ 相邻且未标记的结点 $v$，将 $v$ 作为新的当前访问结点并打上标记。之后再次进入第 $2$ 步。\n3. 假设在第 $2$ 步中，与 $u$ 相邻的结点都已被标记，如果 $u = s$ 则遍历过程结束，否则将 $u$ 设为遍历 $u$ 之前的上一个结点并再进入第 $2$ 步。\n\n例如在下面的树中，一种可能的遍历过程如下：\n- 选取 $1$ 作为遍历起始结点，并把 $1$ 打上标记；\n- $2$ 与 $1$ 相邻且未标记，将 $2$ 设为当前访问结点，并把 $2$ 打上标记。\n- $2$ 与 $3$ 相邻且未标记，将 $3$ 设为当前访问结点，并把 $3$ 打上标记。\n- $3$ 所有相邻的结点都被标记，将当前访问结点设为遍历结点 $3$ 之前的结点 $2$。\n- $2$ 与 $4$ 相邻且未标记，将 $4$ 设为当前访问结点，并把 $4$ 打上标记。\n- $4$ 所有相邻的结点都被标记，将当前访问结点设为遍历结点 $4$ 之前的结点 $2$。\n- $2$ 所有相邻的结点都被标记，将当前访问结点设为遍历结点 $2$ 之前的结点 $1$。\n- $1$ 所有相邻的结点都被标记，且 $1$ 是遍历起始结点，故遍历结束。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qsjiky0g.png)\n\n作为一个奇思妙想的学生，小 Q 在学习完上述知识后不满足于以结点为基础的遍历方式，于是开始研究以边为基础的遍历方式。定义两条边**相邻**，当且仅当它们有一个公共的结点。初始时，所有的边都未被标记。这种以边为基础的遍历过程如下：\n\n1. 选择一条边 $b$ 作为遍历起始边，并把该边打上标记。\n2. 假设当前访问边为 $e$，寻找任意一条与 $e$ 相邻且未标记的边 $f$，将 $f$ 作为新的当前访问边并打上标记。之后再次进入第 $2$ 步。\n3. 假设在第 $2$ 步中，与 $e$ 相邻的边都已被标记，如果 $e = b$ 则遍历过程结束，否则将 $e$ 设为遍历 $e$ 之前的上一条边并再进入第 $2$ 步。\n\n例如在上面的树中，一种可能的遍历过程如下（定义 $\\{u, v\\}$ 表示连接结点 $u$ 和 $v$ 的边）：\n\n- 选取 $\\{1, 2\\}$ 作为遍历起始边，并把 $\\{1, 2\\}$ 打上标记；\n- $\\{1, 2\\}$ 与 $\\{2, 3\\}$ 相邻且未标记，将 $\\{2, 3\\}$ 设为当前访问边，并把 $\\{2, 3\\}$ 打上标记。\n- $\\{2, 3\\}$ 与 $\\{2, 4\\}$ 相邻且未标记，将 $\\{2, 4\\}$ 设为当前访问边，并把 $\\{2, 4\\}$ 打上标记。\n- $\\{2, 4\\}$ 所有相邻的边都被标记，将当前访问边设为遍历 $\\{2, 4\\}$ 之前的边 $\\{2, 3\\}$。\n- $\\{2, 3\\}$ 所有相邻的边都被标记，将当前访问边设为遍历 $\\{2, 3\\}$ 之前的边 $\\{1, 2\\}$。\n- $\\{1, 2\\}$ 所有相邻的边都被标记，且 $\\{1, 2\\}$ 是遍历起始边，故遍历结束。\n\n小 Q 惊奇的发现，在这个新的树的遍历过程中，如果将每条边看作一个新的结点，将步骤 $2$ 中的所有新结点 $e$ 和 $f$ 连接一条新边，就会生成一棵由 $n-1$ 个新结点和 $n-2$ 条新边连接成的新树。例如上述遍历过程得到的新树如下（新的结点和新边都用红色表示）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mld0xpqg.png)\n\n现在小 Q 在 $n - 1$ 条边中选择了 $k$ 条关键边。小 Q 想知道，以任意一条关键边作为起始遍历边，通过上述遍历过程能够生成多少种不同的新树。这里两棵树被认为是不同的，当且仅当至少存在某一对新的结点，它们仅在其中一棵树中连有新边。\n\n**由于结果可能很大，你只需要输出其对 $10^9+7$ 取模的结果即可。**", "inputFormat": "**本题有多组测试数据。**\n\n输入的第一行包含两个整数 $c, T$，表示测试点的编号和测试数据的组数。在样例中，$c$ 表示该样例与测试点 $c$ 的数据范围相同。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n- 第一行包含两个整数 $n, k$，表示树的结点数以及小 Q 选择的关键边的数量。\n- 接下来 $n - 1$ 行，第 $i$ 行包含两个整数 $u_i, v_i$，表示树上编号为 $i$ 的边连接结点 $u_i$ 和 $v_i$。\n- 接下来一行包含 $k$ 个整数 $e_1, e_2, \\dots, e_k$，表示小 Q 选择的关键边的编号。保证关键边的编号互不相同。", "outputFormat": "对于每组测试数据输出一行，包含一个整数，表示结果对 $10^9 + 7$ 取模的结果。", "hint": "**【样例 1 解释】**\n\n两种可能的新树如下：\n- 新结点 $\\{1, 2\\}$ 和新结点 $\\{2, 3\\}$ 连新边，新结点 $\\{2, 3\\}$ 和新结点 $\\{2, 4\\}$ 连新边。\n- 新结点 $\\{1, 2\\}$ 和新结点 $\\{2, 4\\}$ 连新边，新结点 $\\{2, 4\\}$ 和新结点 $\\{2, 3\\}$ 连新边。\n\n**【样例 2 解释】**\n\n三种可能的新树如下：\n- 新结点 $\\{1, 2\\}$ 和 $\\{1, 3\\}$，$\\{1, 2\\}$ 和 $\\{2, 4\\}$，$\\{2, 4\\}$ 和 $\\{2, 5\\}$ 之间分别连新边。该新树可以选择 $\\{1, 2\\}$ 作为起始遍历边得到。\n- 新结点 $\\{1, 2\\}$ 和 $\\{1, 3\\}$，$\\{1, 2\\}$ 和 $\\{2, 5\\}$，$\\{2, 5\\}$ 和 $\\{2, 4\\}$ 之间分别连新边。该新树可以选择 $\\{1, 2\\}$ 或 $\\{2, 4\\}$ 作为起始遍历边得到。\n- 新结点 $\\{1, 2\\}$ 和 $\\{1, 3\\}$，$\\{1, 2\\}$ 和 $\\{2, 4\\}$，$\\{1, 2\\}$ 和 $\\{2, 5\\}$ 之间分别连新边。该新树可以选择 $\\{2, 4\\}$ 作为起始遍历边得到。\n\n**【样例 3】**\n\n见附件的 traverse/traverse3.in 与 traverse/traverse3.ans。\n\n该组样例满足 $c = 4$。\n\n**【样例 4】**\n\n见附件的 traverse/traverse4.in 与 traverse/traverse4.ans。\n\n该组样例满足 $c = 7$。\n\n**【样例 5】**\n\n见附件的 traverse/traverse5.in 与 traverse/traverse5.ans。\n\n该组样例满足 $c = 11$。\n\n**【样例 6】**\n\n见附件的 traverse/traverse6.in 与 traverse/traverse6.ans。\n\n该组样例满足 $c = 13$。\n\n**【样例 7】**\n\n见附件的 traverse/traverse7.in 与 traverse/traverse7.ans。\n\n该组样例满足 $c = 15$。\n\n**【样例 8】**\n\n见附件的 traverse/traverse8.in 与 traverse/traverse8.ans。\n\n该组样例满足 $c = 16$。\n\n**【样例 9】**\n\n见附件的 traverse/traverse9.in 与 traverse/traverse9.ans。\n\n该组样例满足 $c = 18$。\n\n**【样例 10】**\n\n见附件的 traverse/traverse10.in 与 traverse/traverse10.ans。\n\n该组样例满足 $c = 19$。\n\n**【样例 11】**\n\n见附件的 traverse/traverse11.in 与 traverse/traverse11.ans。\n\n该组样例满足 $c = 22$。\n\n**【样例 12】**\n\n见附件的 traverse/traverse12.in 与 traverse/traverse12.ans。\n\n该组样例满足 $c = 24$。\n\n**【数据范围】**\n\n对于所有的测试数据，保证：\n- $1 \\leq T \\leq 10$；\n- $2 \\leq n \\leq 10^5$；\n- $1 \\leq k < n$；\n- 对于任意的 $i(1 \\leq i \\leq n - 1)$，都有 $1 \\leq u_i, v_i \\leq n$，且构成一颗合法的树。\n- 对于任意的 $i(1 \\leq i \\leq k)$，都有 $1 \\leq e_i < n$，且两两不同。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n$ | $k$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 3$ | $\\leq 5$ | $\\leq 1$ | 无 |\n| $4\\sim 6$ | $\\leq 10^5$ | ^ | ^ |\n| $7\\sim 10$ | ^ | $\\leq 2$ | ^ |\n| $11,12$ | $\\leq 500$ | $\\leq 8$ | ^ |\n| $13,14$ | $\\leq 10^2$ | $<n$ | ^ |\n| $15$ | $\\leq 500$ | ^ | ^ |\n| $16,17$ | $\\leq 10^5$ | $\\leq 500$ | ^ |\n| $18$ | ^ | $<n$ | A |\n| $19\\sim 21$ | ^ | ^ | B |\n| $22,23$ | $\\leq 2\\times 10^4$ | ^ | 无 |\n| $24,25$ | $\\leq 10^5$ | ^ | ^ |\n\n- 特殊性质 A：对于任意的 $i(1 \\leq i \\leq n - 1)$，都有 $u_i = i, v_i = i + 1$。\n- 特殊性质 B：对于任意的 $i(1 \\leq i \\leq n - 1)$，都有 $u_i = 1, v_i = i + 1$。\n\n**【提示】**\n\n数据输入的规模可能较大，请选手注意输入读取方式的效率。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP2024] Tree Traversal", "background": "", "description": "Xiao Q, a beginner in algorithmic competitions, is learning about tree traversal in graph theory. A tree with $n$ nodes and $n - 1$ edges initially has all nodes unmarked. Its traversal process is as follows:\n\n1. Select a node $s$ as the starting node for traversal and mark it.\n2. Suppose the currently visited node is $u$. Find any adjacent node $v$ to $u$ that is unmarked, set $v$ as the new current node, mark it, and repeat Step 2.\n3. If in Step 2, all adjacent nodes of $u$ are already marked: if $u = s$, the traversal ends; otherwise, set $u$ to the previous node before traversing $u$ and repeat Step 2.\n\nFor example, in the following tree, a possible traversal process is:\n- Select node $1$ as the starting node and mark it.\n- Node $2$ is adjacent to $1$ and unmarked. Set $2$ as the current node and mark it.\n- Node $3$ is adjacent to $2$ and unmarked. Set $3$ as the current node and mark it.\n- All adjacent nodes of $3$ are marked. Return to the previous node $2$.\n- Node $4$ is adjacent to $2$ and unmarked. Set $4$ as the current node and mark it.\n- All adjacent nodes of $4$ are marked. Return to the previous node $2$.\n- All adjacent nodes of $2$ are marked. Return to the previous node $1$.\n- All adjacent nodes of $1$ are marked, and since $1$ is the starting node, the traversal ends.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qsjiky0g.png)\n\n$$\\text{Pic1: The tree in sample 1}$$\n\nAs a creative student, Xiao Q is not satisfied with node-based traversal and begins researching edge-based traversal. Two edges are defined as **adjacent** if they share a common node. Initially, all edges are unmarked. The edge-based traversal process is:\n\n1. Select an edge $b$ as the starting edge for traversal and mark it.\n2. Suppose the currently visited edge is $e$. Find any adjacent edge $f$ to $e$ that is unmarked, set $f$ as the new current edge, mark it, and repeat Step 2.\n3. If in Step 2, all adjacent edges of $e$ are marked: if $e = b$, the traversal ends; otherwise, set $e$ to the previous edge before traversing $e$ and repeat Step 2.\n\nFor example, in the above tree, a possible traversal process (where $\\{u, v\\}$ denotes the edge connecting nodes $u$ and $v$) is:\n- Select $\\{1, 2\\}$ as the starting edge and mark it.\n- $\\{1, 2\\}$ is adjacent to $\\{2, 3\\}$, which is unmarked. Set $\\{2, 3\\}$ as the current edge and mark it.\n- $\\{2, 3\\}$ is adjacent to $\\{2, 4\\}$, which is unmarked. Set $\\{2, 4\\}$ as the current edge and mark it.\n- All adjacent edges of $\\{2, 4\\}$ are marked. Return to the previous edge $\\{2, 3\\}$.\n- All adjacent edges of $\\{2, 3\\}$ are marked. Return to the previous edge $\\{1, 2\\}$.\n- All adjacent edges of $\\{1, 2\\}$ are marked, and since $\\{1, 2\\}$ is the starting edge, the traversal ends.\n\nXiao Q discovers that if each edge is treated as a new node, and a new edge is created between every pair of edges $e$ and $f$ where $f$ is chosen in Step 2, this generates a new tree with $n-1$ new nodes and $n-2$ new edges. For example, the traversal above produces the following new tree (red nodes and edges):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mld0xpqg.png)\n\n$$\\text{Pic2: A possible new tree}$$\n\nNow, Xiao Q has selected $k$ **key edges** among the $n-1$ edges. He wants to know how many distinct new trees can be generated by starting the traversal from any key edge. Two trees are considered different if there exists at least one pair of new nodes connected by an edge in one tree but not in the other.\n\n**Since the result may be large, output the answer modulo $10^9+7$.**", "inputFormat": "**The problem contains multiple test cases.**\n\nThe first line of input contains two integers $c$ and $T$, representing the test case ID and the number of test cases. In sample inputs, $c$ indicates that the sample shares the same data range as test case $c$.\n\nThis is followed by $T$ test cases, each formatted as:\n- The first line contains two integers $n$ and $k$, representing the number of nodes in the tree and the number of key edges selected.\n- The next $n - 1$ lines each contain two integers $u_i$ and $v_i$, representing the nodes connected by the $i$-th edge in the tree.\n- The next line contains $k$ integers $e_1, e_2, \\dots, e_k$, representing the indices of the key edges. All key edge indices are distinct.", "outputFormat": "For each test case, output one line containing the result modulo $10^9 + 7$.", "hint": "### Explanation\n\n**【Sample 1 Explanation】**\n\nTwo possible new trees:\n1. New edges between $\\{1, 2\\}$ and $\\{2, 3\\}$, and between $\\{2, 3\\}$ and $\\{2, 4\\}$.\n2. New edges between $\\{1, 2\\}$ and $\\{2, 4\\}$, and between $\\{2, 4\\}$ and $\\{2, 3\\}$.\n\n**【Sample 2 Explanation】**\n\nThree possible new trees:\n1. New edges between $\\{1, 2\\}$ and $\\{1, 3\\}$, $\\{1, 2\\}$ and $\\{2, 4\\}$, $\\{2, 4\\}$ and $\\{2, 5\\}$ (starting from $\\{1, 2\\}$).\n2. New edges between $\\{1, 2\\}$ and $\\{1, 3\\}$, $\\{1, 2\\}$ and $\\{2, 5\\}$, $\\{2, 5\\}$ and $\\{2, 4\\}$ (starting from $\\{1, 2\\}$ or $\\{2, 4\\}$).\n3. New edges between $\\{1, 2\\}$ and $\\{1, 3\\}$, $\\{1, 2\\}$ and $\\{2, 4\\}$, $\\{1, 2\\}$ and $\\{2, 5\\}$ (starting from $\\{2, 4\\}$).\n\n**【Additional Samples】**\n\nSamples 3 to 12 are provided in attachments (traverse3.in to traverse12.ans), corresponding to test cases 4, 7, 11, 13, 15, 16, 18, 19, 22, and 24.\n\n**【Data Range】**\n\nFor all test data:\n- $1 \\leq T \\leq 10$;\n- $2 \\leq n \\leq 10^5$;\n- $1 \\leq k < n$;\n- For every $i$ ($1 \\leq i \\leq n - 1$), $1 \\leq u_i, v_i \\leq n$, forming a valid tree;\n- For every $i$ ($1 \\leq i \\leq k$), $1 \\leq e_i < n$, all distinct.\n\n| Test Case Range | $n$ | $k$ | Special Properties |\n| :--------------: | :--------------: | :--------------: | :--------------: |\n| $1\\sim 3$ | $\\leq 5$ | $\\leq 1$ | None |\n| $4\\sim 6$ | $\\leq 10^5$ | $\\leq 1$ | None |\n| $7\\sim 10$ | $\\leq 10^5$ | $\\leq 2$ | None |\n| $11,12$ | $\\leq 500$ | $\\leq 8$ | None |\n| $13,14$ | $\\leq 10^2$ | $<n$ | None |\n| $15$ | $\\leq 500$ | $<n$ | None |\n| $16,17$ | $\\leq 10^5$ | $\\leq 500$ | None |\n| $18$ | $\\leq 10^5$ | $<n$ | A |\n| $19\\sim 21$ | $\\leq 10^5$ | $<n$ | B |\n| $22,23$ | $\\leq 2\\times 10^4$ | $<n$ | None |\n| $24,25$ | $\\leq 10^5$ | $<n$ | None |\n\n- **Special Property A**: For every $i$ ($1 \\leq i \\leq n - 1$), $u_i = i$, $v_i = i + 1$.\n- **Special Property B**: For every $i$ ($1 \\leq i \\leq n - 1$), $u_i = 1$, $v_i = i + 1$.\n\n**【Note】**\n\nInput data may be large; ensure efficient reading methods.\n\n---\n\nTranslated by DeepSeek R1", "locale": "en"}, "zh-CN": {"title": "[NOIP2024] 树的遍历", "background": null, "description": "小 Q 是一个算法竞赛初学者，正在学习图论知识中的树的遍历。一棵由 $n$ 个结点，$n - 1$ 条边构成的树，初始时所有结点都未被标记，它的遍历过程如下：\n\n1. 选择一个结点 $s$ 作为遍历起始结点，并把该结点打上标记。\n2. 假设当前访问的结点为 $u$，寻找任意一个与 $u$ 相邻且未标记的结点 $v$，将 $v$ 作为新的当前访问结点并打上标记。之后再次进入第 $2$ 步。\n3. 假设在第 $2$ 步中，与 $u$ 相邻的结点都已被标记，如果 $u = s$ 则遍历过程结束，否则将 $u$ 设为遍历 $u$ 之前的上一个结点并再进入第 $2$ 步。\n\n例如在下面的树中，一种可能的遍历过程如下：\n- 选取 $1$ 作为遍历起始结点，并把 $1$ 打上标记；\n- $2$ 与 $1$ 相邻且未标记，将 $2$ 设为当前访问结点，并把 $2$ 打上标记。\n- $2$ 与 $3$ 相邻且未标记，将 $3$ 设为当前访问结点，并把 $3$ 打上标记。\n- $3$ 所有相邻的结点都被标记，将当前访问结点设为遍历结点 $3$ 之前的结点 $2$。\n- $2$ 与 $4$ 相邻且未标记，将 $4$ 设为当前访问结点，并把 $4$ 打上标记。\n- $4$ 所有相邻的结点都被标记，将当前访问结点设为遍历结点 $4$ 之前的结点 $2$。\n- $2$ 所有相邻的结点都被标记，将当前访问结点设为遍历结点 $2$ 之前的结点 $1$。\n- $1$ 所有相邻的结点都被标记，且 $1$ 是遍历起始结点，故遍历结束。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qsjiky0g.png)\n\n作为一个奇思妙想的学生，小 Q 在学习完上述知识后不满足于以结点为基础的遍历方式，于是开始研究以边为基础的遍历方式。定义两条边**相邻**，当且仅当它们有一个公共的结点。初始时，所有的边都未被标记。这种以边为基础的遍历过程如下：\n\n1. 选择一条边 $b$ 作为遍历起始边，并把该边打上标记。\n2. 假设当前访问边为 $e$，寻找任意一条与 $e$ 相邻且未标记的边 $f$，将 $f$ 作为新的当前访问边并打上标记。之后再次进入第 $2$ 步。\n3. 假设在第 $2$ 步中，与 $e$ 相邻的边都已被标记，如果 $e = b$ 则遍历过程结束，否则将 $e$ 设为遍历 $e$ 之前的上一条边并再进入第 $2$ 步。\n\n例如在上面的树中，一种可能的遍历过程如下（定义 $\\{u, v\\}$ 表示连接结点 $u$ 和 $v$ 的边）：\n\n- 选取 $\\{1, 2\\}$ 作为遍历起始边，并把 $\\{1, 2\\}$ 打上标记；\n- $\\{1, 2\\}$ 与 $\\{2, 3\\}$ 相邻且未标记，将 $\\{2, 3\\}$ 设为当前访问边，并把 $\\{2, 3\\}$ 打上标记。\n- $\\{2, 3\\}$ 与 $\\{2, 4\\}$ 相邻且未标记，将 $\\{2, 4\\}$ 设为当前访问边，并把 $\\{2, 4\\}$ 打上标记。\n- $\\{2, 4\\}$ 所有相邻的边都被标记，将当前访问边设为遍历 $\\{2, 4\\}$ 之前的边 $\\{2, 3\\}$。\n- $\\{2, 3\\}$ 所有相邻的边都被标记，将当前访问边设为遍历 $\\{2, 3\\}$ 之前的边 $\\{1, 2\\}$。\n- $\\{1, 2\\}$ 所有相邻的边都被标记，且 $\\{1, 2\\}$ 是遍历起始边，故遍历结束。\n\n小 Q 惊奇的发现，在这个新的树的遍历过程中，如果将每条边看作一个新的结点，将步骤 $2$ 中的所有新结点 $e$ 和 $f$ 连接一条新边，就会生成一棵由 $n-1$ 个新结点和 $n-2$ 条新边连接成的新树。例如上述遍历过程得到的新树如下（新的结点和新边都用红色表示）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mld0xpqg.png)\n\n现在小 Q 在 $n - 1$ 条边中选择了 $k$ 条关键边。小 Q 想知道，以任意一条关键边作为起始遍历边，通过上述遍历过程能够生成多少种不同的新树。这里两棵树被认为是不同的，当且仅当至少存在某一对新的结点，它们仅在其中一棵树中连有新边。\n\n**由于结果可能很大，你只需要输出其对 $10^9+7$ 取模的结果即可。**", "inputFormat": "**本题有多组测试数据。**\n\n输入的第一行包含两个整数 $c, T$，表示测试点的编号和测试数据的组数。在样例中，$c$ 表示该样例与测试点 $c$ 的数据范围相同。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n- 第一行包含两个整数 $n, k$，表示树的结点数以及小 Q 选择的关键边的数量。\n- 接下来 $n - 1$ 行，第 $i$ 行包含两个整数 $u_i, v_i$，表示树上编号为 $i$ 的边连接结点 $u_i$ 和 $v_i$。\n- 接下来一行包含 $k$ 个整数 $e_1, e_2, \\dots, e_k$，表示小 Q 选择的关键边的编号。保证关键边的编号互不相同。", "outputFormat": "对于每组测试数据输出一行，包含一个整数，表示结果对 $10^9 + 7$ 取模的结果。", "hint": "**【样例 1 解释】**\n\n两种可能的新树如下：\n- 新结点 $\\{1, 2\\}$ 和新结点 $\\{2, 3\\}$ 连新边，新结点 $\\{2, 3\\}$ 和新结点 $\\{2, 4\\}$ 连新边。\n- 新结点 $\\{1, 2\\}$ 和新结点 $\\{2, 4\\}$ 连新边，新结点 $\\{2, 4\\}$ 和新结点 $\\{2, 3\\}$ 连新边。\n\n**【样例 2 解释】**\n\n三种可能的新树如下：\n- 新结点 $\\{1, 2\\}$ 和 $\\{1, 3\\}$，$\\{1, 2\\}$ 和 $\\{2, 4\\}$，$\\{2, 4\\}$ 和 $\\{2, 5\\}$ 之间分别连新边。该新树可以选择 $\\{1, 2\\}$ 作为起始遍历边得到。\n- 新结点 $\\{1, 2\\}$ 和 $\\{1, 3\\}$，$\\{1, 2\\}$ 和 $\\{2, 5\\}$，$\\{2, 5\\}$ 和 $\\{2, 4\\}$ 之间分别连新边。该新树可以选择 $\\{1, 2\\}$ 或 $\\{2, 4\\}$ 作为起始遍历边得到。\n- 新结点 $\\{1, 2\\}$ 和 $\\{1, 3\\}$，$\\{1, 2\\}$ 和 $\\{2, 4\\}$，$\\{1, 2\\}$ 和 $\\{2, 5\\}$ 之间分别连新边。该新树可以选择 $\\{2, 4\\}$ 作为起始遍历边得到。\n\n**【样例 3】**\n\n见附件的 traverse/traverse3.in 与 traverse/traverse3.ans。\n\n该组样例满足 $c = 4$。\n\n**【样例 4】**\n\n见附件的 traverse/traverse4.in 与 traverse/traverse4.ans。\n\n该组样例满足 $c = 7$。\n\n**【样例 5】**\n\n见附件的 traverse/traverse5.in 与 traverse/traverse5.ans。\n\n该组样例满足 $c = 11$。\n\n**【样例 6】**\n\n见附件的 traverse/traverse6.in 与 traverse/traverse6.ans。\n\n该组样例满足 $c = 13$。\n\n**【样例 7】**\n\n见附件的 traverse/traverse7.in 与 traverse/traverse7.ans。\n\n该组样例满足 $c = 15$。\n\n**【样例 8】**\n\n见附件的 traverse/traverse8.in 与 traverse/traverse8.ans。\n\n该组样例满足 $c = 16$。\n\n**【样例 9】**\n\n见附件的 traverse/traverse9.in 与 traverse/traverse9.ans。\n\n该组样例满足 $c = 18$。\n\n**【样例 10】**\n\n见附件的 traverse/traverse10.in 与 traverse/traverse10.ans。\n\n该组样例满足 $c = 19$。\n\n**【样例 11】**\n\n见附件的 traverse/traverse11.in 与 traverse/traverse11.ans。\n\n该组样例满足 $c = 22$。\n\n**【样例 12】**\n\n见附件的 traverse/traverse12.in 与 traverse/traverse12.ans。\n\n该组样例满足 $c = 24$。\n\n**【数据范围】**\n\n对于所有的测试数据，保证：\n- $1 \\leq T \\leq 10$；\n- $2 \\leq n \\leq 10^5$；\n- $1 \\leq k < n$；\n- 对于任意的 $i(1 \\leq i \\leq n - 1)$，都有 $1 \\leq u_i, v_i \\leq n$，且构成一颗合法的树。\n- 对于任意的 $i(1 \\leq i \\leq k)$，都有 $1 \\leq e_i < n$，且两两不同。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n$ | $k$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 3$ | $\\leq 5$ | $\\leq 1$ | 无 |\n| $4\\sim 6$ | $\\leq 10^5$ | ^ | ^ |\n| $7\\sim 10$ | ^ | $\\leq 2$ | ^ |\n| $11,12$ | $\\leq 500$ | $\\leq 8$ | ^ |\n| $13,14$ | $\\leq 10^2$ | $<n$ | ^ |\n| $15$ | $\\leq 500$ | ^ | ^ |\n| $16,17$ | $\\leq 10^5$ | $\\leq 500$ | ^ |\n| $18$ | ^ | $<n$ | A |\n| $19\\sim 21$ | ^ | ^ | B |\n| $22,23$ | $\\leq 2\\times 10^4$ | ^ | 无 |\n| $24,25$ | $\\leq 10^5$ | ^ | ^ |\n\n- 特殊性质 A：对于任意的 $i(1 \\leq i \\leq n - 1)$，都有 $u_i = i, v_i = i + 1$。\n- 特殊性质 B：对于任意的 $i(1 \\leq i \\leq n - 1)$，都有 $u_i = 1, v_i = i + 1$。\n\n**【提示】**\n\n数据输入的规模可能较大，请选手注意输入读取方式的效率。", "locale": "zh-CN"}}}
{"pid": "P11364", "type": "P", "difficulty": 6, "samples": [["6\n5 6\n6 1\n6 2\n2 3\n2 4\n3\n2 5 2\n1 4 1\n1 6 3\n", "3\n4\n3\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2024", "NOIP 提高组", "最近公共祖先 LCA", "扫描线"], "title": "[NOIP2024] 树上查询", "background": null, "description": "有一天小 S 和她的朋友小 N 一起研究一棵包含了 $n$ 个结点的树。\n\n这是一棵有根树，根结点编号为 $1$，每个结点 $u$ 的深度 $\\text{dep}_ u$ 定义为 $u$ 到 $1$ 的简单路径上的**结点数量**。\n\n除此之外，再定义 $\\text{LCA*}(l, r)$ 为编号在 $[l, r]$ 中所有结点的最近公共祖先，即 $l, l + 1, \\dots , r$ 的公共祖先结点中深度最大的结点。\n\n小 N 对这棵树提出了 $q$ 个询问。在每个询问中，小 N 都会给出三个参数 $l, r, k$，表示他想知道 $[l, r]$ 中任意长度大于等于 $k$ 的连续子区间的最近公共祖先深度的最大值，即\n\n$$\\max_{l\\le l'\\le r'\\le r \\land r'-l'+1\\ge k}\\text{dep}_ {\\text{LCA*}(l', r')}$$\n\n你的任务是帮助小 S 来回答这些询问。", "inputFormat": "输入的第一行包含一个正整数 $n$，表示树的结点数。\n\n接下来 $n - 1$ 行，每行包含两个正整数 $u, v$，表示存在一条从结点 $u$ 到结点 $v$ 的边。\n\n第 $n + 1$ 行包含一个正整数 $q$，表示询问的数量。\n\n接下来 $q$ 行，每行包含三个正整数 $l, r, k$，描述了一次询问。", "outputFormat": "对于每次询问输出一行，包含一个整数，表示对应的答案。", "hint": "**【样例 1 解释】**\n\n![图 3](https://cdn.luogu.com.cn/upload/image_hosting/ktoq3ogh.png)\n\n+ 对于第一组询问，$\\text{LCA*}(2, 3) = 2, \\text{LCA*}(3, 4) = 2, \\text{LCA*}(4, 5) = 6$，$2$ 的深度为 $3$，$6$ 的深度为 $2$，因此答案为 $\\max\\{3, 3, 2\\} = 3$。\n\n+ 对于第二组询问，答案为 $1, 2, 3, 4$ 四个结点的最大深度，因此答案为 $4$。\n\n+ 对于第三组询问，$\\text{LCA*}(1, 3) = 1, \\text{LCA*}(2, 4) = 2, \\text{LCA*}(3, 5) = 6, \\text{LCA*}(4, 6) = 6$，依旧是 $2$ 的深度最大，因此答案为 $3$。\n\n**【样例 2】**\n\n见附件的 query/query2.in 与 query/query2.ans。\n\n该样例满足 $n, q ≤ 500$。\n\n**【样例 3】**\n\n见附件的 query/query3.in 与 query/query3.ans。\n\n该样例满足 $n, q ≤ 10^5$ 且树符合链的形态。\n\n**【样例 4】**\n\n见附件的 query/query4.in 与 query/query4.ans。\n\n该样例满足 $n, q ≤ 5 × 10^5$。\n\n**【数据范围】**\n\n对于所有的测试数据，保证：$1 ≤ n, q ≤ 5 × 10^5\n, 1 ≤ l ≤ r ≤ n, 1 ≤ k ≤ r - l + 1$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n,q\\le$ | 特殊限制 |\n| :-: | :-: | :-: |\n| $1\\sim2$ | $500$ | 无 |\n| $3\\sim5$ | $5000$ | ^ |\n| $6\\sim9$ | $10^5$ | 满足性质 A |\n| $10\\sim13$ | $5\\times10^5$ | ^ |\n| $14\\sim16$ | ^ | 满足性质 B |\n| $17\\sim20$ | $10^5$ | 无 |\n| $21\\sim25$ | $5\\times10^5$ | ^ |\n\n性质 A：保证输入的树符合链的形态，且根结点的度数为 $1$。\n\n性质 B：对于每个询问保证 $k = r - l + 1$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP2024] Tree Query", "background": "", "description": "One day, Xiao S and her friend Xiao N studied a tree with $n$ nodes.\n\nThis is a rooted tree with root node numbered $1$. The depth $\\text{dep}_u$ of a node $u$ is defined as the **number of nodes** on the simple path from $u$ to $1$.\n\nAdditionally, $\\text{LCA*}(l, r)$ is defined as the lowest common ancestor (LCA) of all nodes with numbers in $[l, r]$, i.e., the deepest node that is an ancestor of all nodes $l, l + 1, \\dots, r$.\n\nXiao N posed $q$ queries about this tree. For each query, he provides three parameters $l, r, k$, asking for the maximum depth among the LCAs of all continuous subintervals of $[l, r]$ with length at least $k$. Formally, compute:\n\n$$\n\\max_{l\\le l'\\le r'\\le r \\land r'-l'+1\\ge k}\\text{dep}_{\\text{LCA*}(l', r')}\n$$\n\nYour task is to help Xiao S answer these queries.", "inputFormat": "The first line contains a positive integer $n$, the number of nodes in the tree.\n\nThe next $n - 1$ lines each contain two positive integers $u$ and $v$, representing an edge between nodes $u$ and $v$.\n\nThe $(n + 1)$-th line contains a positive integer $q$, the number of queries.\n\nThe next $q$ lines each contain three positive integers $l, r, k$, describing a query.", "outputFormat": "For each query, output one line containing the answer.", "hint": "## Explanation\n\n**【Sample 1 Explanation】**\n\n![Figure 3](https://cdn.luogu.com.cn/upload/image_hosting/ktoq3ogh.png)\n\n$\\text{Pic 3: The tree in sample 1}$\n\n+ For the first query:\n  - $\\text{LCA*}(2, 3) = 2$, $\\text{LCA*}(3, 4) = 2$, $\\text{LCA*}(4, 5) = 6$.\n  - The depth of node $2$ is $3$, and the depth of node $6$ is $2$.\n  - Thus, the answer is $\\max\\{3, 3, 2\\} = 3$.\n\n+ For the second query:\n  - The answer is the maximum depth among nodes $1, 2, 3, 4$, which is $4$.\n\n+ For the third query:\n  - $\\text{LCA*}(1, 3) = 1$, $\\text{LCA*}(2, 4) = 2$, $\\text{LCA*}(3, 5) = 6$, $\\text{LCA*}(4, 6) = 6$.\n  - The depth of node $2$ is $3$, which remains the maximum, so the answer is $3$.\n\n**【Sample 2】**\n\nSee the attached files `query/query2.in` and `query/query2.ans`.\n\nThis sample satisfies $n, q \\leq 500$.\n\n**【Sample 3】**\n\nSee the attached files `query/query3.in` and `query/query3.ans`.\n\nThis sample satisfies $n, q \\leq 10^5$ and the tree forms a chain.\n\n**【Sample 4】**\n\nSee the attached files `query/query4.in` and `query/query4.ans`.\n\nThis sample satisfies $n, q \\leq 5 \\times 10^5$.\n\n**【Data Range】**\n\nFor all test data:\n- $1 \\leq n, q \\leq 5 \\times 10^5$\n- $1 \\leq l \\leq r \\leq n$\n- $1 \\leq k \\leq r - l + 1$\n\n| Test Case Range | $n, q \\leq$ | Special Constraints |\n| :-------------: | :-------------: | :-------------: |\n| $1\\sim2$ | $500$ | None |\n| $3\\sim5$ | $5000$ | None |\n| $6\\sim9$ | $10^5$ | Property A |\n| $10\\sim13$ | $5 \\times 10^5$ | Property A |\n| $14\\sim16$ | $5 \\times 10^5$ | Property B |\n| $17\\sim20$ | $10^5$ | None |\n| $21\\sim25$ | $5 \\times 10^5$ | None |\n\n- **Property A**: The tree is a chain (root has degree $1$).\n- **Property B**: For every query, $k = r - l + 1$.\n\n---\n\nTranslated by DeepSeek R1", "locale": "en"}, "zh-CN": {"title": "[NOIP2024] 树上查询", "background": null, "description": "有一天小 S 和她的朋友小 N 一起研究一棵包含了 $n$ 个结点的树。\n\n这是一棵有根树，根结点编号为 $1$，每个结点 $u$ 的深度 $\\text{dep}_ u$ 定义为 $u$ 到 $1$ 的简单路径上的**结点数量**。\n\n除此之外，再定义 $\\text{LCA*}(l, r)$ 为编号在 $[l, r]$ 中所有结点的最近公共祖先，即 $l, l + 1, \\dots , r$ 的公共祖先结点中深度最大的结点。\n\n小 N 对这棵树提出了 $q$ 个询问。在每个询问中，小 N 都会给出三个参数 $l, r, k$，表示他想知道 $[l, r]$ 中任意长度大于等于 $k$ 的连续子区间的最近公共祖先深度的最大值，即\n\n$$\\max_{l\\le l'\\le r'\\le r \\land r'-l'+1\\ge k}\\text{dep}_ {\\text{LCA*}(l', r')}$$\n\n你的任务是帮助小 S 来回答这些询问。", "inputFormat": "输入的第一行包含一个正整数 $n$，表示树的结点数。\n\n接下来 $n - 1$ 行，每行包含两个正整数 $u, v$，表示存在一条从结点 $u$ 到结点 $v$ 的边。\n\n第 $n + 1$ 行包含一个正整数 $q$，表示询问的数量。\n\n接下来 $q$ 行，每行包含三个正整数 $l, r, k$，描述了一次询问。", "outputFormat": "对于每次询问输出一行，包含一个整数，表示对应的答案。", "hint": "**【样例 1 解释】**\n\n![图 3](https://cdn.luogu.com.cn/upload/image_hosting/ktoq3ogh.png)\n\n+ 对于第一组询问，$\\text{LCA*}(2, 3) = 2, \\text{LCA*}(3, 4) = 2, \\text{LCA*}(4, 5) = 6$，$2$ 的深度为 $3$，$6$ 的深度为 $2$，因此答案为 $\\max\\{3, 3, 2\\} = 3$。\n\n+ 对于第二组询问，答案为 $1, 2, 3, 4$ 四个结点的最大深度，因此答案为 $4$。\n\n+ 对于第三组询问，$\\text{LCA*}(1, 3) = 1, \\text{LCA*}(2, 4) = 2, \\text{LCA*}(3, 5) = 6, \\text{LCA*}(4, 6) = 6$，依旧是 $2$ 的深度最大，因此答案为 $3$。\n\n**【样例 2】**\n\n见附件的 query/query2.in 与 query/query2.ans。\n\n该样例满足 $n, q ≤ 500$。\n\n**【样例 3】**\n\n见附件的 query/query3.in 与 query/query3.ans。\n\n该样例满足 $n, q ≤ 10^5$ 且树符合链的形态。\n\n**【样例 4】**\n\n见附件的 query/query4.in 与 query/query4.ans。\n\n该样例满足 $n, q ≤ 5 × 10^5$。\n\n**【数据范围】**\n\n对于所有的测试数据，保证：$1 ≤ n, q ≤ 5 × 10^5\n, 1 ≤ l ≤ r ≤ n, 1 ≤ k ≤ r - l + 1$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n,q\\le$ | 特殊限制 |\n| :-: | :-: | :-: |\n| $1\\sim2$ | $500$ | 无 |\n| $3\\sim5$ | $5000$ | ^ |\n| $6\\sim9$ | $10^5$ | 满足性质 A |\n| $10\\sim13$ | $5\\times10^5$ | ^ |\n| $14\\sim16$ | ^ | 满足性质 B |\n| $17\\sim20$ | $10^5$ | 无 |\n| $21\\sim25$ | $5\\times10^5$ | ^ |\n\n性质 A：保证输入的树符合链的形态，且根结点的度数为 $1$。\n\n性质 B：对于每个询问保证 $k = r - l + 1$。", "locale": "zh-CN"}}}
{"pid": "P11365", "type": "P", "difficulty": 6, "samples": [["5 2\n5 4 2 3 1\n3\n1 1\n2 3\n4 4\n2\n1 2\n3 4", "1\n0"]], "limits": {"time": [15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2024", "O2优化", "Ynoi"], "title": "[Ynoi2024] 新本格魔法少女りすか", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/pcokv5zr.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hasy3fee.png)", "description": "给定排列 $a_1,\\dots,a_n$，共 $m$ 次询问，第 $i$ 次询问给定 $m_i$ 个区间 $[l_j,r_j],\\;1\\le j\\le m_i$，满足 $1\\le l_j\\le r_j\\le n,\\;r_j<l_{j+1}$，你需要求出有几个二元组 $(p,q)$ 满足 $p<q,\\;a_p<a_q$，且存在 $1\\le u<v\\le m_i$ 使得 $l_u\\le p\\le r_u,\\;l_v\\le q\\le r_v$。", "inputFormat": "第一行两个数表示 $n,m$。\n\n接下来一行 $n$ 个数表示 $a_1,\\dots,a_n$。\n\n接下来，每个询问第一行为 $m_i$，接下来 $m_i$ 行为 $l_j,r_j$。", "outputFormat": "共 $m$ 行，依次为每个询问的答案。", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n对于 $100\\%$ 的数据，满足 $1\\le n\\le 5\\times 10^5$，$1\\le \\sum\\limits_{i=1}^m m_i\\le 5\\times 10^5$，$m_i\\ge 1$，$1\\le a_i\\le n$，所有数值为整数。\n\n对于 $0\\%$ 的数据，满足 $n\\le 10^3,\\;\\sum\\limits_{i=1}^m m_i\\le 10^3$。\n\n对于另外 $10\\%$ 的数据，满足 $m_i\\le 10$。\n\n对于另外 $10\\%$ 的数据，满足 $m\\le 5$。\n\n对于另外 $80\\%$ 的数据，无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2024] 新本格魔法少女りすか", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/pcokv5zr.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hasy3fee.png)", "description": "给定排列 $a_1,\\dots,a_n$，共 $m$ 次询问，第 $i$ 次询问给定 $m_i$ 个区间 $[l_j,r_j],\\;1\\le j\\le m_i$，满足 $1\\le l_j\\le r_j\\le n,\\;r_j<l_{j+1}$，你需要求出有几个二元组 $(p,q)$ 满足 $p<q,\\;a_p<a_q$，且存在 $1\\le u<v\\le m_i$ 使得 $l_u\\le p\\le r_u,\\;l_v\\le q\\le r_v$。", "inputFormat": "第一行两个数表示 $n,m$。\n\n接下来一行 $n$ 个数表示 $a_1,\\dots,a_n$。\n\n接下来，每个询问第一行为 $m_i$，接下来 $m_i$ 行为 $l_j,r_j$。", "outputFormat": "共 $m$ 行，依次为每个询问的答案。", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n对于 $100\\%$ 的数据，满足 $1\\le n\\le 5\\times 10^5$，$1\\le \\sum\\limits_{i=1}^m m_i\\le 5\\times 10^5$，$m_i\\ge 1$，$1\\le a_i\\le n$，所有数值为整数。\n\n对于 $0\\%$ 的数据，满足 $n\\le 10^3,\\;\\sum\\limits_{i=1}^m m_i\\le 10^3$。\n\n对于另外 $10\\%$ 的数据，满足 $m_i\\le 10$。\n\n对于另外 $10\\%$ 的数据，满足 $m\\le 5$。\n\n对于另外 $80\\%$ 的数据，无特殊限制。", "locale": "zh-CN"}}}
