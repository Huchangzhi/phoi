{"pid": "P6950", "type": "P", "difficulty": 7, "samples": [["6 6\n", "12\n"], ["8 3\n", "6\n"], ["7 20\n", "80\n"], ["2 6\n", "0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "ICPC", "WF"], "title": "[ICPC 2018 WF] Uncrossed Knight's Tour", "background": "", "description": "\n\nA well-known puzzle is to `tour` all the squares of an $8 \\times 8$ chessboard using a knight, which is a piece that can move only by jumping one square in one direction and two squares in an orthogonal direction. The knight must visit every square of the chessboard, without repeats, and then return to its starting square. There are many ways to do this, and the chessboard size is manageable, so it is a reasonable puzzle for a human to solve.\n\nHowever, you have access to a computer, and some coding skills! So, we will give you a harder version of this problem on a rectangular $m \\times n$ chessboard with an additional constraint: the knight may never cross its own path. If you imagine its path consisting of straight line segments connecting the centers of squares it jumps between, these segments must form a simple polygon; that is, no two segments intersect or touch, except that consecutive segments touch at their common end point. This constraint makes it impossible to visit every square, so instead you must maximize the number of squares the knight visits. We keep the constraint that the knight must return to its starting square. Figure J.1 shows an optimal solution for the first sample input, a $6 \\times 6$ board.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15698/1.png)\n\nFigure J.1 : An optimal solution for a $6 \\times 6$ board.\n\n", "inputFormat": "\n\nThe input consists of a single line containing two integers $m (1 \\le m \\le 8)$ and $n (1 \\le n \\le 10^{15}),$ giving the dimensions of the rectangular chessboard.\n\n", "outputFormat": "\n\nDisplay the largest number of squares that a knight can visit in a tour on an $m \\times n$ chessboard that does not cross its path. If no such tour exists, display $0$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 1024 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 WF] Uncrossed Knight's Tour", "background": "", "description": "\n\nA well-known puzzle is to `tour` all the squares of an $8 \\times 8$ chessboard using a knight, which is a piece that can move only by jumping one square in one direction and two squares in an orthogonal direction. The knight must visit every square of the chessboard, without repeats, and then return to its starting square. There are many ways to do this, and the chessboard size is manageable, so it is a reasonable puzzle for a human to solve.\n\nHowever, you have access to a computer, and some coding skills! So, we will give you a harder version of this problem on a rectangular $m \\times n$ chessboard with an additional constraint: the knight may never cross its own path. If you imagine its path consisting of straight line segments connecting the centers of squares it jumps between, these segments must form a simple polygon; that is, no two segments intersect or touch, except that consecutive segments touch at their common end point. This constraint makes it impossible to visit every square, so instead you must maximize the number of squares the knight visits. We keep the constraint that the knight must return to its starting square. Figure J.1 shows an optimal solution for the first sample input, a $6 \\times 6$ board.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15698/1.png)\n\nFigure J.1 : An optimal solution for a $6 \\times 6$ board.\n\n", "inputFormat": "\n\nThe input consists of a single line containing two integers $m (1 \\le m \\le 8)$ and $n (1 \\le n \\le 10^{15}),$ giving the dimensions of the rectangular chessboard.\n\n", "outputFormat": "\n\nDisplay the largest number of squares that a knight can visit in a tour on an $m \\times n$ chessboard that does not cross its path. If no such tour exists, display $0$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 1024 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 WF] Uncrossed Knight's Tour", "background": "", "description": "马在 $m$ $\\times$ $n$ 大小的矩形棋盘上跳跃（走日字）。求从棋盘上一点开始，在保证【性质】的情况下，它最多经过几个格子（包括起点，且终点不算），可以回到初始点？\n\n【性质】：想象马的路径由直线段组成，这些直线段连接着它所跳跃的正方形的中心（如图），这些直线段必须形成一个简单的多边形。也就是说，没有两个线段相交或接触，除非连续线段在其公共端点处接触。", "inputFormat": "一行，两个正整数 $m$ $(1 \\le m \\le 8)$ 和 $n$ $(1 \\le n \\le 10^{15})$。", "outputFormat": "一行，马最多经过的格子数。\n若没有这样的路径，输出 $0$ 。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6951", "type": "P", "difficulty": 4, "samples": [["7 11\n0 1\n0 2\n0 5\n0 6\n1 3\n2 4\n1 2\n1 2\n1 5\n2 6\n5 6\n", "3\n7 6\n0 1\n0 2\n0 5\n0 6\n3 6\n4 6\n"], ["4 3\n0 1\n2 1\n2 3\n", "0\n4 3\n2 1\n1 3\n0 2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "Special Judge", "ICPC", "WF"], "title": "[ICPC 2018 WF] Wireless is the New Fiber", "background": "", "description": "\n\nA new type of unbounded-bandwidth wireless communication has just been tested and proved to be a suitable replacement for the existing, fiber-based communications network, which is struggling to keep up with traffic growth. You have been charged with deciding the layout of the new communications network. The current communications network consists of a set of nodes (which route messages), and links of fiber, each of which connects two different nodes. For each pair of nodes, there exists at least one way (but possibly more, for bandwidth purposes) to travel along the fiber between the two.\n\nThe new communications network will not have any fiber. Instead, it will have wireless links, each connecting two nodes. These links have unbounded bandwidth but are expensive, so it has been decided that as few of these links will be built as possible to provide connectivity; for each pair of nodes there should be exactly one way to travel between them along the wireless links. Moreover, you discovered that the nodes have each been built with a particular number of connections in mind. For each node, if it will be connected to a different number of links than it is today, it will have to be reorganized, and that is costly.\n\nYour task is to design the new network so that it has precisely one path between each pair of nodes while minimizing the number of nodes that do not have the same number of connections as in the original network. Figure K.1 shows the original network and a solution for Sample Input $1$ .\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15699/1.png)\n\nFigure K.1 : Illustration of Sample Input $1$ .\n\n", "inputFormat": "\n\nThe input begins with a line containing two integers $n (2 \\le n \\le 10^{4})$ and $m (1 \\le m \\le 10^{5}),$ denoting the number of nodes and the number of fiber links in the existing network. The nodes are numbered from $0$ to $n − 1$ . Each of the next $m$ lines contains two distinct integers $a_{i}$ and $b_{i},$ denoting the fact that the $i^{th}$ fiber link connects nodes numbered $a_{i}$ and $b_{i}.$ It is guaranteed that for each pair of nodes there exists at least one path connecting the two nodes. Any pair of nodes may have more than one fiber link connecting them.\n\n", "outputFormat": "\n\nDisplay the smallest number of nodes for which the number of connected links needs to change. Starting on the next line, display a system of connections in the same format as the input. That is, display a line containing the number of nodes (this will be the same as in the input) and the number of wireless links, and then on subsequent lines descriptions of the links. If more than one layout is possible, any valid layout will be accepted.\n\n", "hint": "Time limit: 2 s, Memory limit: 1024 MB. \n\nSPJ provider: @[shenyouran](/user/137367).", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 WF] Wireless is the New Fiber", "background": "", "description": "\n\nA new type of unbounded-bandwidth wireless communication has just been tested and proved to be a suitable replacement for the existing, fiber-based communications network, which is struggling to keep up with traffic growth. You have been charged with deciding the layout of the new communications network. The current communications network consists of a set of nodes (which route messages), and links of fiber, each of which connects two different nodes. For each pair of nodes, there exists at least one way (but possibly more, for bandwidth purposes) to travel along the fiber between the two.\n\nThe new communications network will not have any fiber. Instead, it will have wireless links, each connecting two nodes. These links have unbounded bandwidth but are expensive, so it has been decided that as few of these links will be built as possible to provide connectivity; for each pair of nodes there should be exactly one way to travel between them along the wireless links. Moreover, you discovered that the nodes have each been built with a particular number of connections in mind. For each node, if it will be connected to a different number of links than it is today, it will have to be reorganized, and that is costly.\n\nYour task is to design the new network so that it has precisely one path between each pair of nodes while minimizing the number of nodes that do not have the same number of connections as in the original network. Figure K.1 shows the original network and a solution for Sample Input $1$ .\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15699/1.png)\n\nFigure K.1 : Illustration of Sample Input $1$ .\n\n", "inputFormat": "\n\nThe input begins with a line containing two integers $n (2 \\le n \\le 10^{4})$ and $m (1 \\le m \\le 10^{5}),$ denoting the number of nodes and the number of fiber links in the existing network. The nodes are numbered from $0$ to $n − 1$ . Each of the next $m$ lines contains two distinct integers $a_{i}$ and $b_{i},$ denoting the fact that the $i^{th}$ fiber link connects nodes numbered $a_{i}$ and $b_{i}.$ It is guaranteed that for each pair of nodes there exists at least one path connecting the two nodes. Any pair of nodes may have more than one fiber link connecting them.\n\n", "outputFormat": "\n\nDisplay the smallest number of nodes for which the number of connected links needs to change. Starting on the next line, display a system of connections in the same format as the input. That is, display a line containing the number of nodes (this will be the same as in the input) and the number of wireless links, and then on subsequent lines descriptions of the links. If more than one layout is possible, any valid layout will be accepted.\n\n", "hint": "Time limit: 2 s, Memory limit: 1024 MB. \n\nSPJ provider: @[shenyouran](/user/137367).", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 WF] Wireless is the New Fiber", "background": "", "description": "一种新型的无限带宽无线通信刚刚通过测试，并被证明可以替代现有的基于光纤的通信网络，后者正努力跟上流量增长的步伐。你被委托决定新通信网络的布局。当前的通信网络由一组节点（用于路由消息）和光纤链路组成，每条链路连接两个不同的节点。对于每对节点，至少存在一条（但可能更多，为了带宽目的）光纤路径。\n\n新的通信网络将不再使用光纤。相反，它将使用无线链路，每条链路连接两个节点。这些链路具有无限带宽，但成本昂贵，因此决定尽可能少地建设这些链路以提供连通性；对于每对节点，应该只有一条路径通过无线链路连接。此外，你发现每个节点的设计都考虑了特定数量的连接。如果每个节点的连接数与今天不同，则需要重新组织，这将非常昂贵。\n\n你的任务是设计新的网络，使其在每对节点之间恰好有一条路径，同时最小化与原始网络连接数不同的节点数量。图 K.1 显示了原始网络和样例输入 1 的解决方案。\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15699/1.png)\n\n图 K.1：样例输入 1 的示意图。", "inputFormat": "输入以一行两个整数 $n (2 \\le n \\le 10^{4})$ 和 $m (1 \\le m \\le 10^{5})$ 开始，表示现有网络中的节点数和光纤链路数。节点编号从 $0$ 到 $n - 1$。接下来的 $m$ 行中的每一行包含两个不同的整数 $a_{i}$ 和 $b_{i}$，表示第 $i$ 条光纤链路连接编号为 $a_{i}$ 和 $b_{i}$ 的节点。保证对于每对节点，至少存在一条路径连接这两个节点。任何一对节点之间可能有多条光纤链路连接。", "outputFormat": "显示需要更改连接数的最小节点数。从下一行开始，以与输入相同的格式显示连接系统。即，显示一行包含节点数（这将与输入相同）和无线链路数，然后在后续行中描述这些链路。如果有多种布局可能，任何有效的布局都将被接受。", "hint": "时间限制：2 秒，内存限制：1024 MB。\n\nSPJ 提供者：@[shenyouran](/user/137367)。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6952", "type": "P", "difficulty": 6, "samples": [["8\n1 0 12\n2 -11 22\n1 24 10\n1 12 3\n2 12 12\n2 16 14\n1 28 15\n2 3 6\n", "-1\n-1\n3\n1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Archery Tournament", "background": "", "description": "\n\nYou were invited to the annual archery tournament. You are going to compete against the best archers from all of the Northern Eurasia. This year, a new type of competition is introduced, where a shooting range is dynamic and new targets might appear at any second.\n\nAs the shooting range is far enough from you, it can be represented as a 2D plane, where $y = 0$ is the ground level. There are some targets in a shape of a circle, and all the targets are standing on the ground. That means, if a target's center is $(x , y) (y > 0)$ , then its radius is equal to $y$ , so that it touches the line $y = 0$ . No two targets simultaneously present at the range at any given time intersect (but they may touch).\n\nInitially, the shooting range is empty. Your participation in this competition can be described as $n$ events: either a new target appears at the range, or you shoot an arrow at some point at the range. To hit a target, you must shoot strictly inside the circle (hitting the border does not count). If you shoot and hit some target, then the target is removed from the range and you are awarded one point.\n\n", "inputFormat": "\n\nThe first line of the input contains integer $n (1 \\le n \\le 2·10^{5}).$ Next $n$ lines describe the events happening at the tournament. The i-th line contains three integers $t_{i}, x_{i},$ and $y_{i} (t_{i} = 1 , 2$ ; $−10^{9} \\le x_{i}, y_{i} \\le 10^{9}$ ; $y_{i} > 0)$ .\n\nIf $t_{i} = 1$ , then a new target with center $(x_{i}, y_{i})$ and radius $y_{i}$ appears at the range.\n\nIf $t_{i} = 2$ , then you perform a shot, which hits the range at $(x_{i}, y_{i}).$\n\n", "outputFormat": "\n\nFor each of your shots, output a separate line with the single integer. If the shot did not hit any target, print `-1`. If the shot hit a target, print the number of event when that target was added to the range. Events are numbered starting from $1$ .\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Archery Tournament", "background": "", "description": "\n\nYou were invited to the annual archery tournament. You are going to compete against the best archers from all of the Northern Eurasia. This year, a new type of competition is introduced, where a shooting range is dynamic and new targets might appear at any second.\n\nAs the shooting range is far enough from you, it can be represented as a 2D plane, where $y = 0$ is the ground level. There are some targets in a shape of a circle, and all the targets are standing on the ground. That means, if a target's center is $(x , y) (y > 0)$ , then its radius is equal to $y$ , so that it touches the line $y = 0$ . No two targets simultaneously present at the range at any given time intersect (but they may touch).\n\nInitially, the shooting range is empty. Your participation in this competition can be described as $n$ events: either a new target appears at the range, or you shoot an arrow at some point at the range. To hit a target, you must shoot strictly inside the circle (hitting the border does not count). If you shoot and hit some target, then the target is removed from the range and you are awarded one point.\n\n", "inputFormat": "\n\nThe first line of the input contains integer $n (1 \\le n \\le 2·10^{5}).$ Next $n$ lines describe the events happening at the tournament. The i-th line contains three integers $t_{i}, x_{i},$ and $y_{i} (t_{i} = 1 , 2$ ; $−10^{9} \\le x_{i}, y_{i} \\le 10^{9}$ ; $y_{i} > 0)$ .\n\nIf $t_{i} = 1$ , then a new target with center $(x_{i}, y_{i})$ and radius $y_{i}$ appears at the range.\n\nIf $t_{i} = 2$ , then you perform a shot, which hits the range at $(x_{i}, y_{i}).$\n\n", "outputFormat": "\n\nFor each of your shots, output a separate line with the single integer. If the shot did not hit any target, print `-1`. If the shot hit a target, print the number of event when that target was added to the range. Events are numbered starting from $1$ .\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Archery Tournament", "background": "", "description": "你被邀请参加一年一度的射箭比赛。你将与来自整个北欧亚的最佳射手竞争。今年引入了一种新的比赛类型，射击场是动态的，新的目标可能会在任何时候出现。\n\n由于射击场离你足够远，可以表示为一个二维平面，其中 $y = 0$ 是地面。有一些目标是圆形的，所有的目标都站在地面上。这意味着，如果一个目标的中心是 $(x, y) (y > 0)$，那么它的半径等于 $y$，以便它接触到 $y = 0$ 的线。在任何给定时刻，射击场上没有两个目标同时存在相交（但它们可能接触）。\n\n最初，射击场是空的。你在这次比赛中的参与可以描述为 $n$ 个事件：要么一个新目标出现在射击场上，要么你在射击场的某个点射出一箭。要击中目标，你必须严格射入圆内（击中边界不算）。如果你射中并击中某个目标，那么该目标将从射击场上移除，你将获得一分。", "inputFormat": "输入的第一行包含整数 $n (1 \\le n \\le 2 \\cdot 10^{5})$。接下来的 $n$ 行描述了比赛中发生的事件。第 $i$ 行包含三个整数 $t_{i}, x_{i},$ 和 $y_{i} (t_{i} = 1 , 2$；$-10^{9} \\le x_{i}, y_{i} \\le 10^{9}$；$y_{i} > 0)$。\n\n如果 $t_{i} = 1$，则一个中心为 $(x_{i}, y_{i})$，半径为 $y_{i}$ 的新目标出现在射击场上。\n\n如果 $t_{i} = 2$，则你进行一次射击，击中射击场的 $(x_{i}, y_{i})$。", "outputFormat": "对于你的每次射击，输出一个单独的行，包含一个整数。如果射击没有击中任何目标，打印 `-1`。如果射击击中了一个目标，打印该目标被添加到射击场时的事件编号。事件编号从 $1$ 开始。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6953", "type": "P", "difficulty": 4, "samples": [["1 2 3\n6 5\n", "Yes\n"], ["1 2 3\n5 5\n", "No\n"], ["1 1 1\n10 2\n", "Yes\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Box", "background": "", "description": "\n\nBella is working in a factory that produces boxes. All boxes are in a shape of rectangular parallelepipeds. A net of the corresponding parallelepiped is cut out of a flat rectangular piece of cardboard of size $w$ *h . This net is a polygon with sides parallel to the sides of the rectangle of the cardboard. The net is bent along several lines and is connected along the edges of the resulting parallelepiped to form a box. The net is bent only along the edges of the resulting box.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15284/1.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15284/2.png)\n\nThe first example\n\nThe third example\n\nBella is a software developer and her task is to check whether it is possible to make a box of size $a \\times b \\times c$ out of a cardboard of size $w \\times h$ . Bella did write a program and boxes are being produced. Can you do the same?\n\n", "inputFormat": "\n\nThe first line contains three integers a , $b$ , and $c$ -- the dimensions of the box.\n\nThe second line contains two integers $w$ and $h$ -- the width and the height of the cardboard.\n\nAll integers are positive and do not exceed $10^{8}.$\n\n", "outputFormat": "\n\nPrint `Yes` if it is possible to cut a box a $ \\times b \\times c$ out of a cardboard of size $w \\times h$ . Print `No` otherwise.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Box", "background": "", "description": "\n\nBella is working in a factory that produces boxes. All boxes are in a shape of rectangular parallelepipeds. A net of the corresponding parallelepiped is cut out of a flat rectangular piece of cardboard of size $w$ *h . This net is a polygon with sides parallel to the sides of the rectangle of the cardboard. The net is bent along several lines and is connected along the edges of the resulting parallelepiped to form a box. The net is bent only along the edges of the resulting box.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15284/1.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15284/2.png)\n\nThe first example\n\nThe third example\n\nBella is a software developer and her task is to check whether it is possible to make a box of size $a \\times b \\times c$ out of a cardboard of size $w \\times h$ . Bella did write a program and boxes are being produced. Can you do the same?\n\n", "inputFormat": "\n\nThe first line contains three integers a , $b$ , and $c$ -- the dimensions of the box.\n\nThe second line contains two integers $w$ and $h$ -- the width and the height of the cardboard.\n\nAll integers are positive and do not exceed $10^{8}.$\n\n", "outputFormat": "\n\nPrint `Yes` if it is possible to cut a box a $ \\times b \\times c$ out of a cardboard of size $w \\times h$ . Print `No` otherwise.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Box", "background": null, "description": "Bella 在一家生产盒子的工厂工作。所有盒子都是长方体形状。对应长方体的展开图是从一个大小为 $w \\times h$ 的平面矩形纸板上裁剪出来的。这个展开图是一个多边形，其边与纸板矩形的边平行。展开图沿着几条线折叠，并沿着最终长方体的边缘连接形成一个盒子。展开图仅沿着最终盒子的边缘折叠。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oxlybr7q.png)\n\n第一组样例\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vk9knsg7.png)\n\n\n第三组样例\n\nBella 是一名软件开发人员，她的任务是检查是否可以用一个大小为 $w \\times h$ 的纸板制作一个大小为 $a \\times b \\times c$ 的盒子。Bella 编写了一个程序，盒子正在生产。你能做到吗？", "inputFormat": "第一行包含三个整数 $a$、$b$ 和 $c$——盒子的尺寸。\n\n第二行包含两个整数 $w$ 和 $h$——纸板的宽度和高度。\n\n所有整数都是正数且不超过 $10^8$。", "outputFormat": "如果可以从大小为 $w \\times h$ 的纸板上裁剪出一个大小为 $a \\times b \\times c$ 的盒子，则打印 `Yes`。否则打印 `No`。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6954", "type": "P", "difficulty": 5, "samples": [["1\n4 9\n1 2\n1 3\n2 3\n2 4\n3 2\n3 4\n4 1\n4 2\n4 3\n", "1 3\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Connections", "background": "", "description": "\n\nHard times are coming to Byteland. Quantum computing is becoming mainstream and Qubitland is going to occupy Byteland. The main problem is that Byteland does not have enough money for this war, so the King of Byteland Byteman $0x0B$ had decided to reform its road system to reduce expenses.\n\nByteland has $n$ cities that are connected by $m$ one-way roads and it is possible to get from any city to any other city using these roads. No two roads intersect outside of the cities and no other roads exist. By the way, roads are one-way because every road has a halfway barrier that may be passed in one direction only. These barriers are intended to force enemies to waste their time if they choose the wrong way.\n\nThe idea of the upcoming road reform is to abandon some roads so that exactly $2n$ roads remain. Advisers of the King think that it should be enough to keep the ability to get from any city to any other city. (Maybe even less is enough? They do not know for sure. ) The problem is how to choose roads to abandon. Everyone in Byteland knows that you are the only one who can solve this problem.\n\n", "inputFormat": "\n\nInput consists of several test cases. The first line of the input contains the number of tests cases.\n\nThe first line of each test case contains $n$ and $m$ -- the number of cities and the number of roads correspondingly $(n \\ge 4 , m > 2n).$ Each of the next $m$ lines contains two numbers $x_i$ and $y_i$ denoting a road from city $x_{i}$ to city $y_{i} (1 \\le x_{i}, y_{i} \\le n , x_{i} ≠ y_{i}).$ It is guaranteed that it is possible to get from any city to any other city using existing roads only. For each pair $(x , y)$ of cities there is at most one road going from city $x$ to city $y$ and at most one road going from city $y$ to city $x$ . The solution is guaranteed to exist. The sum of $m$ over all test cases in a single input does not exceed $100 000$ .\n\n", "outputFormat": "\n\nFor each test case output $m − 2n$ lines. Each line describes a road that should be abandoned. Print the road in the same format as in the input: the number of the source city and the number of the destination city. The order of roads in the output does not matter, but each road from the input may appear in the output at most once and each road in the output must have been in the input. It still must be possible to get from any city to any other city using the remaining roads.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Connections", "background": "", "description": "\n\nHard times are coming to Byteland. Quantum computing is becoming mainstream and Qubitland is going to occupy Byteland. The main problem is that Byteland does not have enough money for this war, so the King of Byteland Byteman $0x0B$ had decided to reform its road system to reduce expenses.\n\nByteland has $n$ cities that are connected by $m$ one-way roads and it is possible to get from any city to any other city using these roads. No two roads intersect outside of the cities and no other roads exist. By the way, roads are one-way because every road has a halfway barrier that may be passed in one direction only. These barriers are intended to force enemies to waste their time if they choose the wrong way.\n\nThe idea of the upcoming road reform is to abandon some roads so that exactly $2n$ roads remain. Advisers of the King think that it should be enough to keep the ability to get from any city to any other city. (Maybe even less is enough? They do not know for sure. ) The problem is how to choose roads to abandon. Everyone in Byteland knows that you are the only one who can solve this problem.\n\n", "inputFormat": "\n\nInput consists of several test cases. The first line of the input contains the number of tests cases.\n\nThe first line of each test case contains $n$ and $m$ -- the number of cities and the number of roads correspondingly $(n \\ge 4 , m > 2n).$ Each of the next $m$ lines contains two numbers $x_i$ and $y_i$ denoting a road from city $x_{i}$ to city $y_{i} (1 \\le x_{i}, y_{i} \\le n , x_{i} ≠ y_{i}).$ It is guaranteed that it is possible to get from any city to any other city using existing roads only. For each pair $(x , y)$ of cities there is at most one road going from city $x$ to city $y$ and at most one road going from city $y$ to city $x$ . The solution is guaranteed to exist. The sum of $m$ over all test cases in a single input does not exceed $100 000$ .\n\n", "outputFormat": "\n\nFor each test case output $m − 2n$ lines. Each line describes a road that should be abandoned. Print the road in the same format as in the input: the number of the source city and the number of the destination city. The order of roads in the output does not matter, but each road from the input may appear in the output at most once and each road in the output must have been in the input. It still must be possible to get from any city to any other city using the remaining roads.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Connections", "background": "", "description": "艰难的时刻即将降临到 Byteland。量子计算正在成为主流，而 Qubitland 即将占领 Byteland。主要问题是 Byteland 没有足够的资金来进行这场战争，因此 Byteland 的国王 Byteman $0x0B$ 决定改革其道路系统以减少开支。\n\nByteland 有 $n$ 个城市，通过 $m$ 条单向道路连接，可以通过这些道路从任何城市到达其他城市。没有两条道路在城市外相交，也不存在其他道路。顺便说一下，道路是单向的，因为每条道路都有一个只能单向通过的中途障碍。这些障碍旨在迫使敌人在选择错误的方向时浪费时间。\n\n即将到来的道路改革的想法是废弃一些道路，使得恰好剩下 $2n$ 条道路。国王的顾问认为这应该足以保持从任何城市到任何其他城市的通行能力。（也许更少也够？他们不确定。）问题是如何选择要废弃的道路。Byteland 的每个人都知道你是唯一能解决这个问题的人。", "inputFormat": "输入由多个测试用例组成。输入的第一行包含测试用例的数量。\n\n每个测试用例的第一行包含 $n$ 和 $m$ —— 分别是城市的数量和道路的数量 $(n \\ge 4 , m > 2n)$。接下来的 $m$ 行中的每一行包含两个数字 $x_i$ 和 $y_i$，表示从城市 $x_{i}$ 到城市 $y_{i}$ 的一条道路 $(1 \\le x_{i}, y_{i} \\le n , x_{i} \neq y_{i})$。保证可以仅使用现有道路从任何城市到达任何其他城市。对于每对城市 $(x , y)$，最多只有一条从城市 $x$ 到城市 $y$ 的道路，以及最多一条从城市 $y$ 到城市 $x$ 的道路。保证解的存在。单个输入中所有测试用例的 $m$ 之和不超过 $100 000$。", "outputFormat": "对于每个测试用例输出 $m - 2n$ 行。每行描述一条应该废弃的道路。以与输入相同的格式打印道路：源城市的编号和目的城市的编号。输出中道路的顺序无关紧要，但输入中的每条道路在输出中最多出现一次，并且输出中的每条道路必须在输入中出现。仍然必须可以使用剩余的道路从任何城市到达任何其他城市。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6955", "type": "P", "difficulty": 4, "samples": [["4 3 5\n", "6\n0 0 0\n0 1 0\n0 2 0\n0 2 2\n1 2 2\n0 0 2\n"], ["100 1 1\n", "-1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Designing the Toy", "background": "", "description": "\n\nYou are the main toy producer in the city. Recently you bought a $3D-printer$ that provides you with an unprecedented opportunity for designing new fancy toys for children.\n\nIn a package with the $3D-printer$ there is a booklet containing several examples of what can be created with it. One of the examples is a figure that looks like a triangle, like a circle, or like a square depending on which of its sides you are looking at.\n\nUnfortunately, it turned out that the booklet describes the most recent version of your printer. Your printer is only able to create figures that consist of voxels (three-dimensional pixels), i.e . figures that look like a union of a unit-length cubes that are the cells of a three-dimensional grid. Thus, you are not able to print any `smooth` figures (like a sphere, for example) with it. On the other hand, important feature of your model is its ability to create figures whose parts are not even connected with each other by putting wires of a negligible thickness between them.\n\nYou like the idea of the figure in the booklet, so you decided to improve upon this idea. Instead of specifying shapes of figure projections from different perspectives, you would specify their areas. In this problem, a voxel is defined by a triple of integers $(x , y , z)$ , which corresponds to a unit cube [x , $x + 1] \\times $ [y , $y + 1] \\times $ [z , $z + 1].$\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15286/1.png)\n\nYou are given three positive integers a , $b$ and $c$ . Your task is to find a description of a figure $F$ consisting of one or more voxels, for which the area of its orthogonal projection onto the plane Oxy is a , the area of its orthogonal projection onto the plane Oxz is $b$ , and the area of its orthogonal projection onto the plane Oyz is $c$ , or to determine that it is impossible.\n\n", "inputFormat": "\n\nThe only line of the input contains three integers a , $b$ , and $c (1 \\le $ a , $b , c \\le 100)$ -- the desired area of orthogonal projections onto the planes Oxy, Oxz, and Oyz correspondingly.\n\n", "outputFormat": "\n\nIf it is impossible to find the desired figure, print only the integer $−1$ .\n\nOtherwise, in the first line print the integer $n$ , defining the number of voxels in the figure. Then print $n$ triples $x , y , z (−100 \\le x , y , z \\le 100)$ defining the voxels of the figure. Voxels may be printed in any order, but no voxel may be repeated twice.\n\nThe number of voxels $n$ should not exceed $10^{6}.$\n\nAny figure with the requested projection areas is accepted.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Designing the Toy", "background": "", "description": "\n\nYou are the main toy producer in the city. Recently you bought a $3D-printer$ that provides you with an unprecedented opportunity for designing new fancy toys for children.\n\nIn a package with the $3D-printer$ there is a booklet containing several examples of what can be created with it. One of the examples is a figure that looks like a triangle, like a circle, or like a square depending on which of its sides you are looking at.\n\nUnfortunately, it turned out that the booklet describes the most recent version of your printer. Your printer is only able to create figures that consist of voxels (three-dimensional pixels), i.e . figures that look like a union of a unit-length cubes that are the cells of a three-dimensional grid. Thus, you are not able to print any `smooth` figures (like a sphere, for example) with it. On the other hand, important feature of your model is its ability to create figures whose parts are not even connected with each other by putting wires of a negligible thickness between them.\n\nYou like the idea of the figure in the booklet, so you decided to improve upon this idea. Instead of specifying shapes of figure projections from different perspectives, you would specify their areas. In this problem, a voxel is defined by a triple of integers $(x , y , z)$ , which corresponds to a unit cube [x , $x + 1] \\times $ [y , $y + 1] \\times $ [z , $z + 1].$\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15286/1.png)\n\nYou are given three positive integers a , $b$ and $c$ . Your task is to find a description of a figure $F$ consisting of one or more voxels, for which the area of its orthogonal projection onto the plane Oxy is a , the area of its orthogonal projection onto the plane Oxz is $b$ , and the area of its orthogonal projection onto the plane Oyz is $c$ , or to determine that it is impossible.\n\n", "inputFormat": "\n\nThe only line of the input contains three integers a , $b$ , and $c (1 \\le $ a , $b , c \\le 100)$ -- the desired area of orthogonal projections onto the planes Oxy, Oxz, and Oyz correspondingly.\n\n", "outputFormat": "\n\nIf it is impossible to find the desired figure, print only the integer $−1$ .\n\nOtherwise, in the first line print the integer $n$ , defining the number of voxels in the figure. Then print $n$ triples $x , y , z (−100 \\le x , y , z \\le 100)$ defining the voxels of the figure. Voxels may be printed in any order, but no voxel may be repeated twice.\n\nThe number of voxels $n$ should not exceed $10^{6}.$\n\nAny figure with the requested projection areas is accepted.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Designing the Toy", "background": "", "description": "你是这里的玩具生产大佬。最近你买了一台 3D 打印机，它给你提供了一个~~大赚一笔~~创造新玩具的机会。\n\n你的打印机只能打印由一个个单位方块（棱长为 $1$ 的正方体）构成的几何体。因此，你不能打印出任何“光滑”的几何体（比如球体）。另外，这台打印机打印的几何体可以有完全不相连甚至浮空的部分。\n\n建立空间直角坐标系。一个 $[x , x + 1] $ $\\times $ $[y , y + 1]$ $\\times $ $[z , z + 1]$ 的方块用整数三元组 $(x , y , z)$ 表示。\n\n现在你想指定打印出的几何体在平面 $Oxy$，平面 $Oxz$ 和平面 $Oyz$ 上的投影面积。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/udemly1h.png)\n\n给出三个正整数 $a,b,c$，依次表示几何体在平面 $Oxy$，平面 $Oxz$ 和平面 $Oyz$ 上的投影面积。判断该集合体是否存在，若存在，找到满足条件的几何体。", "inputFormat": "一行，包含 $3$ 个正整数 $a,b,c$ $(1 \\le a , b , c \\le 100)$。", "outputFormat": "如果所求几何体不存在，输出 `-1` 。\n\n否则，输出的第一行包含一个整数 $n$，表示图中方块的数量。\n\n接下来 $n$ 行，每行 $3$ 个整数 $x,y,z$ 表示每个方块的位置。方块可以按任意顺序输出，但不能重复。\n\n$n$ 的值不应超过 $10^{6}$。\n\n任何满足条件的几何体都算作正确。", "hint": "时间限制：3s，内存限制：512MB。\n\nTranslated by Georiky", "locale": "zh-CN"}}}
{"pid": "P6956", "type": "P", "difficulty": 3, "samples": [["10\n1 0 -4 0 0 -1 -3 0 -1 -2\n", "Yes\n4 1 3 2\n"], ["5\n5 8 0 -6 -3\n", "No\n"], ["3\n2 -2 -2\n", "No\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Easy Quest", "background": "", "description": "\n\nA young hero is starting his heroic life. The wise wizard suggested him an easy first quest. During this quest our young hero meets $n$ magical creatures, in specific order. In order to help the young hero, the wizard gave him a clue -- a list of $n$ integers $a_{i}.$\n\nIf $a_{i}$ is positive, then the i-th magical creature is benevolent and gives to our hero one magical item of type $a_{i}.$ The hero can keep several items of the same type.\n\nIf $a_i$ is negative, then the i-th magical creature is evil and in order to defeat it the young hero needs one magical item of type $−a_{i}.$ All magical items are fragile and can be used only once.\n\nIf $a_{i}$ is zero, then the i-th creature is a unicorn. It gives the hero any magical item he asks for, but only one.\n\nYour task is to help the young hero to finish the first quest, defeating all enemies on the way, or say that it is impossible.\n\n", "inputFormat": "\n\nThe first line of input contains one integer $n (1 \\le n \\le 1000)$ . The second line contains $n$ integers $a_{i} (−1000 \\le a_{i} \\le 1000)$ .\n\n", "outputFormat": "\n\nIf it is impossible to defeat all enemies, then output one string `No`. If it is possible, then output string `Yes`, and in the next line output the types of items the hero should ask the unicorns for, in order they meet during the quest. Types must be integers in range from $1$ to $1000$ inclusive. If there are several solutions, output any of them.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Easy Quest", "background": "", "description": "\n\nA young hero is starting his heroic life. The wise wizard suggested him an easy first quest. During this quest our young hero meets $n$ magical creatures, in specific order. In order to help the young hero, the wizard gave him a clue -- a list of $n$ integers $a_{i}.$\n\nIf $a_{i}$ is positive, then the i-th magical creature is benevolent and gives to our hero one magical item of type $a_{i}.$ The hero can keep several items of the same type.\n\nIf $a_i$ is negative, then the i-th magical creature is evil and in order to defeat it the young hero needs one magical item of type $−a_{i}.$ All magical items are fragile and can be used only once.\n\nIf $a_{i}$ is zero, then the i-th creature is a unicorn. It gives the hero any magical item he asks for, but only one.\n\nYour task is to help the young hero to finish the first quest, defeating all enemies on the way, or say that it is impossible.\n\n", "inputFormat": "\n\nThe first line of input contains one integer $n (1 \\le n \\le 1000)$ . The second line contains $n$ integers $a_{i} (−1000 \\le a_{i} \\le 1000)$ .\n\n", "outputFormat": "\n\nIf it is impossible to defeat all enemies, then output one string `No`. If it is possible, then output string `Yes`, and in the next line output the types of items the hero should ask the unicorns for, in order they meet during the quest. Types must be integers in range from $1$ to $1000$ inclusive. If there are several solutions, output any of them.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Easy Quest", "background": "", "description": "一位年轻的英雄开始了他的英雄生涯。聪明的巫师给他建议了一个简单的第一个任务。在这个任务中，我们的年轻英雄遇到了 $n$ 个魔法生物，按特定顺序排列。为了帮助年轻英雄，巫师给了他一个线索——一个包含 $n$ 个整数 $a_{i}$ 的列表。\n\n如果 $a_{i}$ 是正数，那么第 $i$ 个魔法生物是仁慈的，并给我们的英雄一个类型为 $a_{i}$ 的魔法物品。英雄可以保留多个相同类型的物品。\n\n如果 $a_i$ 是负数，那么第 $i$ 个魔法生物是邪恶的，为了打败它，年轻英雄需要一个类型为 $-a_{i}$ 的魔法物品。所有魔法物品都是易碎的，只能使用一次。\n\n如果 $a_{i}$ 是零，那么第 $i$ 个生物是独角兽。它会给英雄他所要求的任何魔法物品，但只能给一个。\n\n你的任务是帮助年轻英雄完成第一个任务，击败途中所有的敌人，或者说这是不可能的。", "inputFormat": "输入的第一行包含一个整数 $n (1 \\le n \\le 1000)$。第二行包含 $n$ 个整数 $a_{i} (-1000 \\le a_{i} \\le 1000)$。", "outputFormat": "如果无法击败所有敌人，则输出字符串 `No`。如果可以，则输出字符串 `Yes`，并在下一行输出英雄在任务中遇到的独角兽时应该请求的物品类型。类型必须是从 $1$ 到 $1000$ 范围内的整数。如果有多种解决方案，输出其中任何一种即可。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\nspj 提供者：@[shenyouran](\\/user\\/137367)。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6957", "type": "P", "difficulty": 6, "samples": [["2\n2 3 2\n4 -1 3\n", "2\n1 1 0 0\n1 2 2 3\n2\n0 0 2 -2\n3 -3 5 -1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] The Final Level", "background": "", "description": "\n\nFiora is a game designer. Now she is designing the final level for her new game.\n\nA level for this game is a labyrinth on a rectangular grid with lots of enemies. Player starts her game at the square $(0 , 0)$ and her purpose is to get to the square $(a , b)$ . Fiora has lots of ideas on how to put enemies, but she does not like designing labyrinths. She needs your help here.\n\nFiora is drawing levels in a special level editor which supports one basic block to design a labyrinth. This block is an L-shaped corner, consisting of two perpendicular rectangles $1 \\times n$ squares in size intersecting at $1 \\times 1$ square. It is possible to rotate this block in four ways. Blocks cannot intersect, but they can touch each other. Player can move through all the squares lying in any block. She can move between two squares if they are sharing a side, even if they are in different blocks.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15288/1.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15288/2.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15288/3.png)\n\nBlocks with $n = 3$\n\nThe first example\n\nThe second example\n\nFiora wants to design the final level with the minimal possible number of blocks. Of course, it should be possible to move from square $(0 , 0)$ to square $(a , b)$ .\n\n", "inputFormat": "\n\nThe first line of the input consists of a single integer $m (1 \\le m \\le 100)$ -- the number of test cases. It is followed by $m$ test cases. Each test case is on a separate line and consists of three integers a , $b$ , and $n (−10^{8} \\le $ a , $b \\le 10^{8}; 2 \\le n \\le 10^{8})$ -- a is the coordinate of the final point along the horizontal axis, $b$ is the coordinate of the final point along the vertical axis, and $n$ is the size of the block. The final point is not same as the starting one (either a $≠ 0$ or $b ≠ 0)$ .\n\n", "outputFormat": "\n\nFor each test case, in the first line print the minimal number $k$ of blocks you need. In the following $k$ lines print description of these blocks. Each L-shaped corner block is described by coordinates of two cells. Print coordinates of the end of its vertical rectangle, followed by coordinates of the end of its horizontal rectangle. Specify the coordinates of the ends that are opposite to the intersection of the rectangles. Note that the order of cells in the block description matters, since a change of the order results in a reflected block. Coordinates of each end should be printed with the coordinate along the horizontal axis first, followed by the coordinate along the vertical axis.\n\nAll coordinates in the output should not exceed $10^{9}$ by absolute value.\n\nIt is guaranteed that the total number of blocks in the correct output does not exceed $10^{5}$ for all test cases combined.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] The Final Level", "background": "", "description": "\n\nFiora is a game designer. Now she is designing the final level for her new game.\n\nA level for this game is a labyrinth on a rectangular grid with lots of enemies. Player starts her game at the square $(0 , 0)$ and her purpose is to get to the square $(a , b)$ . Fiora has lots of ideas on how to put enemies, but she does not like designing labyrinths. She needs your help here.\n\nFiora is drawing levels in a special level editor which supports one basic block to design a labyrinth. This block is an L-shaped corner, consisting of two perpendicular rectangles $1 \\times n$ squares in size intersecting at $1 \\times 1$ square. It is possible to rotate this block in four ways. Blocks cannot intersect, but they can touch each other. Player can move through all the squares lying in any block. She can move between two squares if they are sharing a side, even if they are in different blocks.\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15288/1.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15288/2.png)\n\n![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15288/3.png)\n\nBlocks with $n = 3$\n\nThe first example\n\nThe second example\n\nFiora wants to design the final level with the minimal possible number of blocks. Of course, it should be possible to move from square $(0 , 0)$ to square $(a , b)$ .\n\n", "inputFormat": "\n\nThe first line of the input consists of a single integer $m (1 \\le m \\le 100)$ -- the number of test cases. It is followed by $m$ test cases. Each test case is on a separate line and consists of three integers a , $b$ , and $n (−10^{8} \\le $ a , $b \\le 10^{8}; 2 \\le n \\le 10^{8})$ -- a is the coordinate of the final point along the horizontal axis, $b$ is the coordinate of the final point along the vertical axis, and $n$ is the size of the block. The final point is not same as the starting one (either a $≠ 0$ or $b ≠ 0)$ .\n\n", "outputFormat": "\n\nFor each test case, in the first line print the minimal number $k$ of blocks you need. In the following $k$ lines print description of these blocks. Each L-shaped corner block is described by coordinates of two cells. Print coordinates of the end of its vertical rectangle, followed by coordinates of the end of its horizontal rectangle. Specify the coordinates of the ends that are opposite to the intersection of the rectangles. Note that the order of cells in the block description matters, since a change of the order results in a reflected block. Coordinates of each end should be printed with the coordinate along the horizontal axis first, followed by the coordinate along the vertical axis.\n\nAll coordinates in the output should not exceed $10^{9}$ by absolute value.\n\nIt is guaranteed that the total number of blocks in the correct output does not exceed $10^{5}$ for all test cases combined.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] The Final Level", "background": "", "description": "用长度为 $n$ 的 L 型方块摆在二维网格平面上，仅通过方块从 $(0,0)$ 走到 $(a,b)$。", "inputFormat": "第一行一个正整数 $m$ ，下面 $m$ 行每行 $3$ 个正整数 $a, b, n$。", "outputFormat": "对于每组数据，输出最小 L 型块数 $k$，下面 $k$ 行每行按先横坐标后纵坐标的顺序输出每个 L 型块两端的坐标。", "hint": "对于 $100\\%$ 的数据，$1 \\le m \\le 100, -10^8 \\le a, b  \\le 10^8, 2 \\le n \\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P6958", "type": "P", "difficulty": 6, "samples": [["4 2 1\n1 2 3 4\n3 3 5 5\n7 7 7 7\n", "16\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] The Great Wall", "background": "", "description": "\n\nRecently you had become an emperor of a small country of Sinai. You had decided to build a big wall at the border to save your country from barbarian raids. You had contacted `W Corp`, the only company in the world that builds non-penetrable walls.\n\n`W Corp` builds each wall using the same pattern. The length of the wall is $n$ meters. Each one-meter piece of the wall is numbered by an integer from $1$ to $n$ along its length and may have a different height. The height pattern is based on three fixed arrays a , $b$ , and $c$ of $n$ elements each, such that $a_{i} < b_{i} < c_{i}$ for all $1 \\le i \\le n$ , and an integer $r (1 \\le r < n)$ . These arrays and $r$ are the same for any wall that is built by `W Corp`.\n\nThe choice of the specific wall design is determined by two distinct integers $x$ and $y (1 \\le x < y \\le n−r+1)$ in the following way. Take two ranges of integers: [x , $x+r−1]$ and [y , $y+r−1]$ (these ranges are inclusive of their ends). Then the height of the wall at one meter piece $i$ for all $1 \\le i \\le n$ is equal to:\n\n$a_{i}$ if $i$ does not belong to any of the chosen ranges;\n\n$b_{i}$ if $i$ belongs to exactly one chosen range;\n\n$c_{i}$ if $i$ belongs to both chosen ranges.\n\nA strength of a wall is defined as the sum of all heights of its $n$ one meter pieces.\n\nThe arrays a , $b , c$ , and an integer $r$ are the same for any wall built by `W Corp`, so the company provides a price list with all the possible wall designs, sorted in non-decreasing order of their strength. You choose the k-th wall design from the list. The task is to find the strength of the chosen wall.\n\n", "inputFormat": "\n\nThe first line of the input contains three integers $n , r$ and $k (2 \\le n \\le 30 000 , 1 \\le r < n , 1 \\le k \\le (n−r)(n−r+1)/2)$ -- the length of the wall, the length of the segments to choose, and the position of the wall in the price list.\n\nThe second line of the input contains the elements of the array a $(1 \\le a_{i} \\le 10^{6}).$\n\nThe third line of the input contains the elements of the array $b (a_{i} < b_{i} \\le 10^{6}).$\n\nThe fourth line of the input contains the elements of the array $c (b_{i} < c_{i} \\le 10^{6}).$\n\n", "outputFormat": "\n\nPrint one integer -- the strength of the k-th wall from `W Corp` price list.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] The Great Wall", "background": "", "description": "\n\nRecently you had become an emperor of a small country of Sinai. You had decided to build a big wall at the border to save your country from barbarian raids. You had contacted `W Corp`, the only company in the world that builds non-penetrable walls.\n\n`W Corp` builds each wall using the same pattern. The length of the wall is $n$ meters. Each one-meter piece of the wall is numbered by an integer from $1$ to $n$ along its length and may have a different height. The height pattern is based on three fixed arrays a , $b$ , and $c$ of $n$ elements each, such that $a_{i} < b_{i} < c_{i}$ for all $1 \\le i \\le n$ , and an integer $r (1 \\le r < n)$ . These arrays and $r$ are the same for any wall that is built by `W Corp`.\n\nThe choice of the specific wall design is determined by two distinct integers $x$ and $y (1 \\le x < y \\le n−r+1)$ in the following way. Take two ranges of integers: [x , $x+r−1]$ and [y , $y+r−1]$ (these ranges are inclusive of their ends). Then the height of the wall at one meter piece $i$ for all $1 \\le i \\le n$ is equal to:\n\n$a_{i}$ if $i$ does not belong to any of the chosen ranges;\n\n$b_{i}$ if $i$ belongs to exactly one chosen range;\n\n$c_{i}$ if $i$ belongs to both chosen ranges.\n\nA strength of a wall is defined as the sum of all heights of its $n$ one meter pieces.\n\nThe arrays a , $b , c$ , and an integer $r$ are the same for any wall built by `W Corp`, so the company provides a price list with all the possible wall designs, sorted in non-decreasing order of their strength. You choose the k-th wall design from the list. The task is to find the strength of the chosen wall.\n\n", "inputFormat": "\n\nThe first line of the input contains three integers $n , r$ and $k (2 \\le n \\le 30 000 , 1 \\le r < n , 1 \\le k \\le (n−r)(n−r+1)/2)$ -- the length of the wall, the length of the segments to choose, and the position of the wall in the price list.\n\nThe second line of the input contains the elements of the array a $(1 \\le a_{i} \\le 10^{6}).$\n\nThe third line of the input contains the elements of the array $b (a_{i} < b_{i} \\le 10^{6}).$\n\nThe fourth line of the input contains the elements of the array $c (b_{i} < c_{i} \\le 10^{6}).$\n\n", "outputFormat": "\n\nPrint one integer -- the strength of the k-th wall from `W Corp` price list.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] The Great Wall", "background": "", "description": "最近你成为了西奈一个小国家的皇帝。你决定在边界建造一座长城保护你的国家不被野蛮人抢劫。你联系了“W Corp”——世界上唯一的建造坚不可摧的墙的公司。\n\n“W Corp”用相同的格式建造所有墙。墙的长度是 $n$ 米，每一米墙按顺序从 $1$ 到 $n$ 编号，它们可能有不同的高度。高度的格式取决于三个固定的数组 $a,b,c$，它们各有 $n$ 个元素，对于任意 $1\\le i\\le n$ 满足 $a_i < b_i < c_i$，还有一个整数 $r\\ (1\\le r < n)$。三个数组和 $r$ 对于“W Corp”建造的任何墙都是相同的。\n\n按照如下方式，具体的墙体设计的选择取决于两个不同的整数 $x,y\\ (1\\le x < y\\le n-r+1)$。取两个整数区间：$[x,x+r-1]$ 和 $[y,y+r-1]$（区间包括端点）。那么第 $i$ 米墙的高度是：\n\n- $a_i$，当 $i$ 不属于这两个区间\n- $b_i$，当 $i$ 属于这两个区间中的恰好一个\n- $c_i$，当 $i$ 属于这两个区间中的两个\n\n墙的**强度**定义为每一米墙高度的和。\n\n在“W Corp”建造的所有墙中，数组 $a,b,c$ 和整数 $r$ 都是固定的。公司提供了一份所有可能的墙体设计的列表，按照强度单调不减排序。你选择了其中第 $k$ 种墙体设计。你的任务是，求出你选择的墙的强度。", "inputFormat": "第一行包括三个整数 $n,r,k\\ (2\\le n\\le 30000,\\ 1\\le r < n,\\ 1\\le k\\le \\frac{(n-r)(n-r+1)}{2}\\ \\ )$，分别代表墙的长度，取的区间的长度，你的选择在列表中的位置。\n\n第二行包括了数组 $a$ 的元素，$1\\le a_i\\le 10^6$。\n\n第三行包括了数组 $b$ 的元素，$1\\le b_i\\le 10^6$。\n\n第四行包括了数组 $c$ 的元素，$1\\le c_i\\le 10^6$。", "outputFormat": "输出一个整数，“W Corp”的列表中第 $k$ 种墙的强度\n\n### 样例解释\n\n在样例中，能建造出的不同的墙有三种：\n\n- 选择 $x=1,y=2$，墙的高度是 $[3,7,5,4]$，强度是 $19$。\n- 选择 $x=1,y=3$，墙的高度是 $[3,3,5,5]$，强度是 $16$。\n- 选择 $x=2,y=3$，墙的高度是 $[1,3,7,5]$，强度是 $16$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6959", "type": "P", "difficulty": 7, "samples": [["15\n980\n293", "? 3\n? 8\n! 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2017", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Hack", "background": "", "description": "Heidi is analyzing a peculiar device. This device takes an a as input and computes $a^d(mod n)$ using thefollowing pseudocode and some integers $d$ and $n$ stored in this device:\n\n ```\nmodPow(a, d, n) {\n  r = 1;\n  for (i = 0; i < 60; ++i) {\n    if ((d & (1 << i)) != 0) {\n      r = r * a % n;\n    }\n  a = a * a % n;\n  }\n}\n```\n\nNote that the pseudocode assumes arbitrary sized integers, $<<$ denotes bitwise shift left, $&$ denotes bitwise\n\nand, and % denotes modulo.\n\nThe device does not tell Heidi the result of the computation. However, Heidi can measure how long does the computation take. She knows that only multiplication modulo $n$ (lines $5$ and $7$ in the above pseudocode) takes any measurable amount of time, all other lines can be assumed to take $0$ nanoseconds.\n\nMoreover, she knows that it takes $(bits(x) + 1) · (bits(y) + 1)$ nanoseconds to multiply $x$ by $y$ modulo $n$ , where $bits(x)$ is the number of bits in the binary representation of $x$ without leading zeros, or more formally $\\text{bits(x)} = ⌈\\log_2 (x + 1)⌉.\n\nHeidi knows the integer $n$ but does not know the integer $d$ . She wants to find $d$ by feeding the device different integers a as input and measuring the time the computation takes for each a .\n\nShe knows that $n$ and $d$ were chosen in the following way: first, two prime numbers $p$ and $q$ with $30$ bits in binary representation (in other words, between $229$ and $230 −1)$ were picked independently and uniformly at random. Then the number $n$ was computed as $n = p · q$ . Then the number $m = φ(n) = (p−1)·(q −1)$\n\nwas computed. Then $d$ was picked uniformly at random between $1$ and $m − 1$ inclusive, such that it is coprime with $m$ .\n\n# Interaction Protocol\n\nFirst, the testing system writes the integer $n$ -- the modulo used by the device. Note that $n$ and the hidden number $d$ are guaranteed to have been generated according to the procedure described above.\n\nYour solution shall print requests of two types:\n\n- “? a” tells to feed a as input to the device. a must be an integer between $0$ and $n−1$ inclusive. The testing system responds with the time it took the device to compute `modPow(a , d , n)` in nanoseconds.\n\n- “! d” tells the value of $d$ that your program has determined.\n\nDon't forget to flush the output after each request!\n\nYour solution must issue exactly one request of the second type, which must be the last request, and the solution must terminate gracefully after issuing it.\n\nYour solution is allowed to issue at most $30 000$ requests of the first type.\n\nYour solution will be run on $30$ testcases, working with one $(n , d)$ pair per run. For each testcase the numbers $n$ and $d$ are fixed and were generated using the procedure described above. The example below\n\nwas not generated in that manner and thus will not be used for testing your solution; it only serves to illustrate the input/output format and provide a sanity check for your calculation of the computation time. ", "inputFormat": "", "outputFormat": "", "hint": "", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Hack", "background": "", "description": "Heidi is analyzing a peculiar device. This device takes an a as input and computes $a^d(mod n)$ using thefollowing pseudocode and some integers $d$ and $n$ stored in this device:\n\n ```\nmodPow(a, d, n) {\n  r = 1;\n  for (i = 0; i < 60; ++i) {\n    if ((d & (1 << i)) != 0) {\n      r = r * a % n;\n    }\n  a = a * a % n;\n  }\n}\n```\n\nNote that the pseudocode assumes arbitrary sized integers, $<<$ denotes bitwise shift left, $&$ denotes bitwise\n\nand, and % denotes modulo.\n\nThe device does not tell Heidi the result of the computation. However, Heidi can measure how long does the computation take. She knows that only multiplication modulo $n$ (lines $5$ and $7$ in the above pseudocode) takes any measurable amount of time, all other lines can be assumed to take $0$ nanoseconds.\n\nMoreover, she knows that it takes $(bits(x) + 1) · (bits(y) + 1)$ nanoseconds to multiply $x$ by $y$ modulo $n$ , where $bits(x)$ is the number of bits in the binary representation of $x$ without leading zeros, or more formally $\\text{bits(x)} = ⌈\\log_2 (x + 1)⌉.\n\nHeidi knows the integer $n$ but does not know the integer $d$ . She wants to find $d$ by feeding the device different integers a as input and measuring the time the computation takes for each a .\n\nShe knows that $n$ and $d$ were chosen in the following way: first, two prime numbers $p$ and $q$ with $30$ bits in binary representation (in other words, between $229$ and $230 −1)$ were picked independently and uniformly at random. Then the number $n$ was computed as $n = p · q$ . Then the number $m = φ(n) = (p−1)·(q −1)$\n\nwas computed. Then $d$ was picked uniformly at random between $1$ and $m − 1$ inclusive, such that it is coprime with $m$ .\n\n# Interaction Protocol\n\nFirst, the testing system writes the integer $n$ -- the modulo used by the device. Note that $n$ and the hidden number $d$ are guaranteed to have been generated according to the procedure described above.\n\nYour solution shall print requests of two types:\n\n- “? a” tells to feed a as input to the device. a must be an integer between $0$ and $n−1$ inclusive. The testing system responds with the time it took the device to compute `modPow(a , d , n)` in nanoseconds.\n\n- “! d” tells the value of $d$ that your program has determined.\n\nDon't forget to flush the output after each request!\n\nYour solution must issue exactly one request of the second type, which must be the last request, and the solution must terminate gracefully after issuing it.\n\nYour solution is allowed to issue at most $30 000$ requests of the first type.\n\nYour solution will be run on $30$ testcases, working with one $(n , d)$ pair per run. For each testcase the numbers $n$ and $d$ are fixed and were generated using the procedure described above. The example below\n\nwas not generated in that manner and thus will not be used for testing your solution; it only serves to illustrate the input/output format and provide a sanity check for your calculation of the computation time. ", "inputFormat": "", "outputFormat": "", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Hack", "background": "", "description": "Heidi 正在分析一个特殊的设备。该设备以一个 $a$ 作为输入，并使用以下伪代码和存储在设备中的一些整数 $d$ 和 $n$ 计算 $a^d \\bmod n$：\n\n```\nmodPow(a, d, n) {\n  r = 1;\n  for (i = 0; i < 60; ++i) {\n    if ((d & (1 << i)) != 0) {\n      r = r * a % n;\n    }\n  a = a * a % n;\n  }\n}\n```\n\n注意，伪代码假设整数可以是任意大小，$<<$ 表示按位左移，$&$ 表示按位与，% 表示取模。\n\n设备不会告诉 Heidi 计算结果。然而，Heidi 可以测量计算所需的时间。她知道只有模 $n$ 的乘法（上述伪代码中的第 5 行和第 7 行）需要可测量的时间，其他所有行可以假设为 0 纳秒。\n\n此外，她知道将 $x$ 和 $y$ 模 $n$ 相乘需要 $(\\text{bits}(x) + 1) \\cdot (\\text{bits}(y) + 1)$ 纳秒，其中 $\\text{bits}(x)$ 是 $x$ 的二进制表示中不含前导零的位数，更正式地，$\\text{bits}(x) = \\lceil \\log_2 (x + 1) \\rceil$。\n\nHeidi 知道整数 $n$，但不知道整数 $d$。她想通过将不同的整数 $a$ 作为输入提供给设备，并测量每个 $a$ 的计算时间来找到 $d$。\n\n她知道 $n$ 和 $d$ 是通过以下方式选择的：首先，两个具有 30 位二进制表示的素数 $p$ 和 $q$（换句话说，在 $2^{29}$ 和 $2^{30} - 1$ 之间）被独立且均匀地随机选择。然后计算 $n = p \\cdot q$。然后计算 $m = \\varphi(n) = (p-1) \\cdot (q-1)$。然后在 $1$ 到 $m - 1$ 之间均匀随机选择 $d$，使其与 $m$ 互质。\n\n# 交互协议\n\n首先，测试系统写入整数 $n$——设备使用的模数。注意，$n$ 和隐藏的数字 $d$ 保证是按照上述过程生成的。\n\n你的解决方案应打印两种类型的请求：\n\n- “? a” 告诉设备以 $a$ 作为输入。$a$ 必须是 $0$ 到 $n-1$ 之间的整数。测试系统会返回设备计算 `modPow(a , d , n)` 所需的时间（以纳秒为单位）。\n\n- “! d” 告诉你的程序已确定的 $d$ 值。\n\n不要忘记在每次请求后刷新输出！\n\n你的解决方案必须发出恰好一个第二种类型的请求，该请求必须是最后一个请求，并且解决方案在发出该请求后必须正常终止。\n\n你的解决方案最多可以发出 $30,000$ 个第一种类型的请求。\n\n你的解决方案将在 $30$ 个测试用例上运行，每次运行处理一个 $(n , d)$ 对。对于每个测试用例，数字 $n$ 和 $d$ 是固定的，并且是使用上述过程生成的。下面的例子不是以这种方式生成的，因此不会用于测试你的解决方案；它仅用于说明输入/输出格式并为计算时间的合理性检查提供一个 sanity check。", "inputFormat": "", "outputFormat": "", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6960", "type": "P", "difficulty": 6, "samples": [["5\n>\n>\n<\n>\n<\n<\n", "? 1 1\n? 1 2\n? 1 3\n? 2 1\n? 2 2\n? 2 3\n! 4 2 1 3 5"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Interactive Sort", "background": "这是一道 IO 交互题。", "description": "Ivan wants to play a game with you. He took all integers from $1$ to $n$ inclusive, shuffled them and then put all even numbers into array $e$ and all odd numbers into array $o$ .\n\nYour task is to find arrays $e$ and $o$ .\n\nYou can ask Ivan questions of certain kind. Each question consists of two integers $i$ and $j$ . For each question Ivan says whether $e[i] < o[j]$ or not.\n\nYou can ask at most $300 000$ questions.\n\n# Interaction Protocol\n\nFirst, the testing system writes the integer $n (1 \\le n \\le 10 000)$ -- the number of integers Ivan used.\n\nYour solution shall print requests of two types:\n\n• “? i j”. $1 \\le i \\le ⌊n/2⌋, 1 \\le j \\le ⌈n/2⌉$. The testing system responds with the symbol $“<”$ if $e[i] < o[j]$ or with the symbol $“>”$ otherwise.\n\n• “!\\ $e_1\\ e_2\\ \\cdots e_{⌊n/2⌋}\\ o_1\\ o_2 \\cdots o_{⌈n/2⌉}$” tells the values of $e$ and $o$ that your program has determined.\n\nDon't forget to flush the output after each request!\n\nYour solution must issue exactly one request of the second type, which must be the last request, and thesolution must terminate gracefully after issuing it.\n\nYour solution is allowed to issue at most $300 000$ requests of the first type.\n\nFor each test case the number $n$ is fixed and the numbers are shuffled using Java built-in shuffle functionwith fixed seed.\n\n\n", "inputFormat": "", "outputFormat": "", "hint": "", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Interactive Sort", "background": "这是一道 IO 交互题。", "description": "Ivan wants to play a game with you. He took all integers from $1$ to $n$ inclusive, shuffled them and then put all even numbers into array $e$ and all odd numbers into array $o$ .\n\nYour task is to find arrays $e$ and $o$ .\n\nYou can ask Ivan questions of certain kind. Each question consists of two integers $i$ and $j$ . For each question Ivan says whether $e[i] < o[j]$ or not.\n\nYou can ask at most $300 000$ questions.\n\n# Interaction Protocol\n\nFirst, the testing system writes the integer $n (1 \\le n \\le 10 000)$ -- the number of integers Ivan used.\n\nYour solution shall print requests of two types:\n\n• “? i j”. $1 \\le i \\le ⌊n/2⌋, 1 \\le j \\le ⌈n/2⌉$. The testing system responds with the symbol $“<”$ if $e[i] < o[j]$ or with the symbol $“>”$ otherwise.\n\n• “!\\ $e_1\\ e_2\\ \\cdots e_{⌊n/2⌋}\\ o_1\\ o_2 \\cdots o_{⌈n/2⌉}$” tells the values of $e$ and $o$ that your program has determined.\n\nDon't forget to flush the output after each request!\n\nYour solution must issue exactly one request of the second type, which must be the last request, and thesolution must terminate gracefully after issuing it.\n\nYour solution is allowed to issue at most $300 000$ requests of the first type.\n\nFor each test case the number $n$ is fixed and the numbers are shuffled using Java built-in shuffle functionwith fixed seed.\n\n\n", "inputFormat": "", "outputFormat": "", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Interactive Sort", "background": null, "description": "Ivan 想和你玩一个游戏。他选取了从 $1$ 到 $n$ 的所有整数，打乱顺序后，将所有偶数放入数组 $e$，所有奇数放入数组 $o$。\n\n你的任务是找出数组 $e$ 和 $o$。\n\n你可以向 Ivan 提出特定类型的问题。每个问题包含两个整数 $i$ 和 $j$。对于每个问题，Ivan 会回答 $e[i] < o[j]$ 是否成立。\n\n你最多可以提出 $300,000$ 个问题。\n\n## 交互协议\n\n首先，测试系统会输入整数 $n (1 \\le n \\le 10,000)$ —— Ivan 使用的整数数量。\n\n你的解决方案应输出两种类型的请求：\n\n• “? i j”。其中 $1 \\le i \\le ⌊n/2⌋, 1 \\le j \\le ⌈n/2⌉$。测试系统会响应符号 $“<”$ 表示 $e[i] < o[j]$，否则响应符号 $“>”$。\n\n• “! $e_1\\ e_2\\ \\cdots e_{⌊n/2⌋}\\ o_1\\ o_2 \\cdots o_{⌈n/2⌉}$” 表示你的程序确定的 $e$ 和 $o$ 的值。\n\n在每次请求后不要忘记刷新输出缓冲区！\n\n你的解决方案必须恰好发出一次第二种类型的请求，且该请求必须是最后一个请求，并在发出后正常终止。\n\n你的解决方案最多可以发出 $300,000$ 次第一种类型的请求。\n\n每个测试用例的 $n$ 值是固定的，数字使用 Java 内置的洗牌函数（使用固定种子）进行打乱。", "inputFormat": null, "outputFormat": null, "hint": "题面翻译由 Deepseek 提供。", "locale": "zh-CN"}}}
{"pid": "P6961", "type": "P", "difficulty": 6, "samples": [["6 7 2\n1 2 6\n2 3 1\n2 4 3\n2 5 5\n3 6 10\n4 6 9\n5 6 8\n", "14\n"], ["5 5 3\n2 1 1\n3 2 1\n4 3 1\n4 5 1\n1 5 2\n", "2\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "最短路", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Journey from Petersburg to Moscow", "background": "", "description": "\n\nTo conduct The World Programming Cup $2112$ a network of wonderful toll roads was build in European part of Russia. This network consists of $m$ bidirectional roads that connect $n$ cities. Each road connects exactly two distinct cities, no two roads connect the same pair of cities, and it is possible to travel from any city to any other city using only this road network. Moreover, to ease the process of charging, no two roads intersect outside of the cities.\n\nEach road is assigned some individual positive cost. Normally, if a driver makes a trip using some of these toll roads, at the end of his journey he would be charged the total cost equal to the sum of individual costs of all roads he has used. To increase the popularity of car travels between two capitals, the operator company Radishchev Inc introduced a special offer: make a journey from Saint Petersburg to Moscow and pay for only $k$ most expensive roads along your path.\n\nFormally, let some path consists of $l$ roads. Denote as $c_{1}$ the cost of the most expensive road along this path, as $c_{2}$ the second most expensive and so on. Thus, we have a sequence $c_{1} \\ge c_{2} \\ge c_{3} \\ge $ . . . $ \\ge c_{l}$ of individual costs of all roads along the chosen path. If $l \\le k$ , then the path is too short and the driver pays the sum of all individual costs as usual, i.e . $Σ^{l}_{i=1}c_{i}.$ If $l > k$ , then the driver only pays for $k$ most expensive roads, that is $Σ^{k}_{i=1}c_{i}.$\n\nAs the chief analyst of Radishchev Inc you were assigned a task to compute the cheapest possible journey from Saint Petersburg to Moscow.\n\n", "inputFormat": "\n\nThe first line of the input contains three integers $n , m$ and $k (2 \\le n \\le 3000 , 1 \\le m \\le 3000 , 1 \\le k < n)$ -- the number of cities, the number of roads in the road network, and the maximum number of roads that one should pay for in a single journey.\n\nNext $m$ lines contain description of roads. Each road description contains three integers $u_{i}, v_{i},$ and $w_{i} (1 \\le u_{i}, v_{i} \\le n , u_{i} ≠ v_{i}, 1 \\le w_{i} \\le 10^{9})$ -- the i-th bidirectional road that connects cities $u_{i}$ and $v_{i}$ with the cost of $w_{i}$ for any direction. It is guaranteed that there is at most one road between each pair of cities and it is possible to get from any city to any other city using only these roads.\n\n", "outputFormat": "\n\nPrint one integer equal to the minimum possible cost of travel from the city number $1$ (Saint Petersburg) to the city number $n (Moscow).$\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Journey from Petersburg to Moscow", "background": "", "description": "\n\nTo conduct The World Programming Cup $2112$ a network of wonderful toll roads was build in European part of Russia. This network consists of $m$ bidirectional roads that connect $n$ cities. Each road connects exactly two distinct cities, no two roads connect the same pair of cities, and it is possible to travel from any city to any other city using only this road network. Moreover, to ease the process of charging, no two roads intersect outside of the cities.\n\nEach road is assigned some individual positive cost. Normally, if a driver makes a trip using some of these toll roads, at the end of his journey he would be charged the total cost equal to the sum of individual costs of all roads he has used. To increase the popularity of car travels between two capitals, the operator company Radishchev Inc introduced a special offer: make a journey from Saint Petersburg to Moscow and pay for only $k$ most expensive roads along your path.\n\nFormally, let some path consists of $l$ roads. Denote as $c_{1}$ the cost of the most expensive road along this path, as $c_{2}$ the second most expensive and so on. Thus, we have a sequence $c_{1} \\ge c_{2} \\ge c_{3} \\ge $ . . . $ \\ge c_{l}$ of individual costs of all roads along the chosen path. If $l \\le k$ , then the path is too short and the driver pays the sum of all individual costs as usual, i.e . $Σ^{l}_{i=1}c_{i}.$ If $l > k$ , then the driver only pays for $k$ most expensive roads, that is $Σ^{k}_{i=1}c_{i}.$\n\nAs the chief analyst of Radishchev Inc you were assigned a task to compute the cheapest possible journey from Saint Petersburg to Moscow.\n\n", "inputFormat": "\n\nThe first line of the input contains three integers $n , m$ and $k (2 \\le n \\le 3000 , 1 \\le m \\le 3000 , 1 \\le k < n)$ -- the number of cities, the number of roads in the road network, and the maximum number of roads that one should pay for in a single journey.\n\nNext $m$ lines contain description of roads. Each road description contains three integers $u_{i}, v_{i},$ and $w_{i} (1 \\le u_{i}, v_{i} \\le n , u_{i} ≠ v_{i}, 1 \\le w_{i} \\le 10^{9})$ -- the i-th bidirectional road that connects cities $u_{i}$ and $v_{i}$ with the cost of $w_{i}$ for any direction. It is guaranteed that there is at most one road between each pair of cities and it is possible to get from any city to any other city using only these roads.\n\n", "outputFormat": "\n\nPrint one integer equal to the minimum possible cost of travel from the city number $1$ (Saint Petersburg) to the city number $n (Moscow).$\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Journey from Petersburg to Moscow", "background": null, "description": "为了举办世界编程杯 $2112$，在俄罗斯的欧洲部分建造了一张奇妙的收费公路网络。这个网络由 $m$ 条双向道路组成，连接了 $n$ 座城市。每条道路连接恰好两座不同的城市，没有两条道路连接相同的城市对，并且可以仅使用这张公路网络从任何城市到达其他城市。此外，为了简化收费过程，没有两条道路在城市外相交。\n\n每条道路都有一个单独的正费用。通常情况下，如果司机使用这些收费公路进行旅行，在旅程结束时，他将支付等于所使用的所有道路的单个费用之和的总费用。为了增加两座首都之间汽车旅行的受欢迎程度，运营公司 Radishchev Inc 推出了一项特别优惠：从圣彼得堡到莫斯科的旅程只需支付路径上 $k$ 条最贵道路的费用。\n\n正式地，假设某条路径由 $l$ 条道路组成。记 $c_{1}$ 为该路径上最贵的道路的费用，$c_{2}$ 为第二贵的，以此类推。因此，我们有一个序列 $c_{1} \\ge c_{2} \\ge c_{3} \\ge \\ldots \\ge c_{l}$，表示所选路径上所有道路的单个费用。如果 $l \\le k$，则路径太短，司机按通常方式支付所有单个费用之和，即 $\\Sigma^{l}_{i=1}c_{i}$。如果 $l > k$，则司机只需支付 $k$ 条最贵道路的费用，即 $\\Sigma^{k}_{i=1}c_{i}$。\n\n作为 Radishchev Inc 的首席分析师，你的任务是计算从圣彼得堡到莫斯科的最低可能旅程费用。", "inputFormat": "输入的第一行包含三个整数 $n, m$ 和 $k$ $(2 \\le n \\le 3000, 1 \\le m \\le 3000, 1 \\le k < n)$——城市的数量、道路网络中的道路数量，以及单次旅程中需要支付的最多道路数量。\n\n接下来的 $m$ 行包含道路的描述。每条道路的描述包含三个整数 $u_{i}, v_{i},$ 和 $w_{i}$ $(1 \\le u_{i}, v_{i} \\le n, u_{i} \\neq v_{i}, 1 \\le w_{i} \\le 10^{9})$——第 $i$ 条双向道路连接城市 $u_{i}$ 和 $v_{i}$，费用为 $w_{i}$，无论方向如何。保证每对城市之间最多只有一条道路，并且仅使用这些道路可以从任何城市到达其他城市。", "outputFormat": "输出一个整数，表示从城市编号 $1$（圣彼得堡）到城市编号 $n$（莫斯科）的最低可能旅行费用。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6962", "type": "P", "difficulty": 7, "samples": [["5\n10\n20\n50\n140\n420\n440\n", "01001\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2017", "数论", "枚举", "分治", "逆元", "位运算", "构造", "ICPC", "折半搜索 meet in the middle", "NERC/NEERC"], "title": "[NEERC 2017] Knapsack Cryptosystem", "background": "", "description": "\n\nThe Merkle-Hellman Knapsack Cryptosystem was one of the earliest public key cryptosystems invented by Ralph Merkle and Martin Hellman in $1978$ . Here is its description\n\nAlice chooses $n$ positive integers ${a_{1}, . . . , a_{n}}$ such that each $a_{i} > \\sum^{i−1}_{j=1}a_{j},$ a positive integer $q$ which is greater than the sum of all $a_{i},$ and a positive integer $r$ which is coprime with $q$ . These $n + 2$ integers are Alice's private key.\n\nThen Alice calculates $b_i = (a_{i} · r)$ mod $q$ . These $n$ integers are Alice's public key.\n\nKnowing her public key, Bob can transmit a message of $n$ bits to Alice. To do that he calculates $s$ , the sum of $b_{i}$ with indices $i$ such that his message has bit $1$ in i-th position. This value $s$ is the encrypted message.\n\nNote that an eavesdropper Eve, who knows the encrypted message and the public key, has to solve a (presumably hard) instance of the knapsack problem to find the original message. Meanwhile, after receiving $s$ , Alice can calculate the original message in linear time; we leave it to you as an exercise.\n\nIn this problem you deal with the implementation of the Merkle-Hellman Knapsack Cryptosystem in which Alice chose $q = 2^{64},$ for obvious performance reasons, and published this information. Since everyone knows her $q$ , she asks Bob to send her the calculated value $s$ taken modulo $2^{64}$ for simplicity of communication.\n\nYou are to break this implementation. Given the public key and an encrypted message, restore the original message.\n\n", "inputFormat": "\n\nThe first line contains one integer $n (1 \\le n \\le 64)$ .\n\nEach of the next $n$ lines contains one integer $b_{i} (1 \\le b_{i} < 2^{64}).$\n\nThe last line contains one integer $s$ mod $q$ -- the encrypted message $s$ taken modulo $q (0 \\le s$ mod $q < 2^{64}).$\n\nThe given sequence $b_{i}$ is a valid public key in the described implementation, and the given value $s$ mod $q$ is a valid encrypted message.\n\n", "outputFormat": "\n\nOutput exactly $n$ bits ($0$ or $1$ digits) -- the original message.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Knapsack Cryptosystem", "background": "", "description": "\n\nThe Merkle-Hellman Knapsack Cryptosystem was one of the earliest public key cryptosystems invented by Ralph Merkle and Martin Hellman in $1978$ . Here is its description\n\nAlice chooses $n$ positive integers ${a_{1}, . . . , a_{n}}$ such that each $a_{i} > \\sum^{i−1}_{j=1}a_{j},$ a positive integer $q$ which is greater than the sum of all $a_{i},$ and a positive integer $r$ which is coprime with $q$ . These $n + 2$ integers are Alice's private key.\n\nThen Alice calculates $b_i = (a_{i} · r)$ mod $q$ . These $n$ integers are Alice's public key.\n\nKnowing her public key, Bob can transmit a message of $n$ bits to Alice. To do that he calculates $s$ , the sum of $b_{i}$ with indices $i$ such that his message has bit $1$ in i-th position. This value $s$ is the encrypted message.\n\nNote that an eavesdropper Eve, who knows the encrypted message and the public key, has to solve a (presumably hard) instance of the knapsack problem to find the original message. Meanwhile, after receiving $s$ , Alice can calculate the original message in linear time; we leave it to you as an exercise.\n\nIn this problem you deal with the implementation of the Merkle-Hellman Knapsack Cryptosystem in which Alice chose $q = 2^{64},$ for obvious performance reasons, and published this information. Since everyone knows her $q$ , she asks Bob to send her the calculated value $s$ taken modulo $2^{64}$ for simplicity of communication.\n\nYou are to break this implementation. Given the public key and an encrypted message, restore the original message.\n\n", "inputFormat": "\n\nThe first line contains one integer $n (1 \\le n \\le 64)$ .\n\nEach of the next $n$ lines contains one integer $b_{i} (1 \\le b_{i} < 2^{64}).$\n\nThe last line contains one integer $s$ mod $q$ -- the encrypted message $s$ taken modulo $q (0 \\le s$ mod $q < 2^{64}).$\n\nThe given sequence $b_{i}$ is a valid public key in the described implementation, and the given value $s$ mod $q$ is a valid encrypted message.\n\n", "outputFormat": "\n\nOutput exactly $n$ bits ($0$ or $1$ digits) -- the original message.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Knapsack Cryptosystem", "background": "", "description": "Merkle-Hellman 背包密码系统是由 Ralph Merkle 和 Martin Hellman 于 1978 年发明的最早的公钥密码系统之一。以下是其描述：\n\nAlice 选择 $n$ 个正整数 ${a_{1}, . . . , a_{n}}$，使得每个 $a_{i} > \\sum^{i-1}_{j=1}a_{j}$，一个大于所有 $a_{i}$ 之和的正整数 $q$，以及一个与 $q$ 互质的正整数 $r$。这 $n + 2$ 个整数是 Alice 的私钥。\n\n然后 Alice 计算 $b_i = (a_{i} \\cdot r)$ mod $q$。这 $n$ 个整数是 Alice 的公钥。\n\n知道她的公钥后，Bob 可以向 Alice 传输一个 $n$ 位的消息。为此，他计算 $s$，即在消息中第 $i$ 位为 1 的位置上对应的 $b_{i}$ 的和。这个值 $s$ 是加密后的消息。\n\n注意，窃听者 Eve 知道加密消息和公钥，必须解决一个（可能很难的）背包问题实例才能找到原始消息。同时，在收到 $s$ 后，Alice 可以在线性时间内计算出原始消息；我们将其留给你作为练习。\n\n在这个问题中，你需要处理 Merkle-Hellman 背包密码系统的实现，其中 Alice 选择了 $q = 2^{64}$，出于显而易见的性能原因，并公布了此信息。由于每个人都知道她的 $q$，她要求 Bob 发送给她取模 $2^{64}$ 的计算值 $s$ 以简化通信。\n\n你需要破解这个实现。给定公钥和一个加密消息，恢复原始消息。", "inputFormat": "第一行包含一个整数 $n (1 \\le n \\le 64)$。\n\n接下来的 $n$ 行中，每行包含一个整数 $b_{i} (1 \\le b_{i} < 2^{64})$。\n\n最后一行包含一个整数 $s$ mod $q$ —— 取模 $q$ 的加密消息 $s$，其中 $0 \\le s$ mod $q < 2^{64}$。\n\n给定的序列 $b_{i}$ 是描述的实现中的有效公钥，给定的值 $s$ mod $q$ 是有效的加密消息。", "outputFormat": "输出恰好 $n$ 位（$0$ 或 $1$ 数字）——原始消息。", "hint": "时间限制：3 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6963", "type": "P", "difficulty": 6, "samples": [["4 2\n1 2\n2 3\n2 4\n1 2\n4 2\n", "No\n"], ["6 5\n1 2\n2 3\n3 4\n5 6\n5 2\n2 1\n6 6\n1 4\n3 4\n4 1\n", "Yes\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "ICPC", "NERC/NEERC"], "title": "[NEERC 2017] Laminar Family", "background": "", "description": "\n\nWhile studying combinatorial optimization, Lucas came across the notion of `laminar set family`. A subset family $F$ of some set $Ω$ is called laminar if and only if it does not contain an empty set and for any two distinct sets A , $B ∈ F$ it is correct that either $A ⊂ B$ or $B ⊂ A$ or $A ∩ B = ∅$.\n\nAs an experienced problem setter Lucas always tries to apply each new piece of knowledge he gets as an idea for a programming competition problem. An area of his scientific interests covers recognition problems that usually sound like `Given some weird combinatorial property, check if the given structure satisfies it`.\n\nLucas believes that the perfect programming competition problem should contain a cactus a tree in it. Trying to put together laminar sets and trees into a recognition problem, he finally came up with the following problem: given an undirected tree on $n$ vertices and a family $F = {F_{1}, . . . , F_{k}}$ of sets, where $F_{i}$ consists of all vertices belonging to the simple path between some two vertices $a_{i}$ and $b_{i}$ of the tree, check if the family $F$ is a laminar family. Note that in this case $Ω = V$ , and each $F_{i} ⊆ V$ .\n\nAs you can see, Lucas had succeeded in suggesting this problem to the programming contest. Now it is up to you to solve it.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $n$ and $f (1 \\le n , f \\le 100 000)$ -- the number of vertices in the tree and the number of elements in a family $F$ .\n\nNext $n−1$ lines describe the tree structure. In the i-th line there are two integers $u_{i}$ and $v_{i} (1 \\le u_{i}, v_{i} \\le n , u_{i} ≠ v_{i})$ -- the indices of the vertices that are connected by the i-th edge of the tree.\n\nNext $f$ lines describe the sets forming the family $F$ . In the i-th line there are two integers $a_{i}$ and $b_{i} (1 \\le a_{i}, b_{i} \\le n)$ , such that $F_{i}$ consists of all vertices belonging to the simple path between vertices $a_{i}$ and $b_{i}$ in the tree (including $a_{i}$ and $b_{i}).$\n\n", "outputFormat": "\n\nOutput the only word `Yes` or `No` depending on whether or not the given set family is laminar.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2017] Laminar Family", "background": "", "description": "\n\nWhile studying combinatorial optimization, Lucas came across the notion of `laminar set family`. A subset family $F$ of some set $Ω$ is called laminar if and only if it does not contain an empty set and for any two distinct sets A , $B ∈ F$ it is correct that either $A ⊂ B$ or $B ⊂ A$ or $A ∩ B = ∅$.\n\nAs an experienced problem setter Lucas always tries to apply each new piece of knowledge he gets as an idea for a programming competition problem. An area of his scientific interests covers recognition problems that usually sound like `Given some weird combinatorial property, check if the given structure satisfies it`.\n\nLucas believes that the perfect programming competition problem should contain a cactus a tree in it. Trying to put together laminar sets and trees into a recognition problem, he finally came up with the following problem: given an undirected tree on $n$ vertices and a family $F = {F_{1}, . . . , F_{k}}$ of sets, where $F_{i}$ consists of all vertices belonging to the simple path between some two vertices $a_{i}$ and $b_{i}$ of the tree, check if the family $F$ is a laminar family. Note that in this case $Ω = V$ , and each $F_{i} ⊆ V$ .\n\nAs you can see, Lucas had succeeded in suggesting this problem to the programming contest. Now it is up to you to solve it.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $n$ and $f (1 \\le n , f \\le 100 000)$ -- the number of vertices in the tree and the number of elements in a family $F$ .\n\nNext $n−1$ lines describe the tree structure. In the i-th line there are two integers $u_{i}$ and $v_{i} (1 \\le u_{i}, v_{i} \\le n , u_{i} ≠ v_{i})$ -- the indices of the vertices that are connected by the i-th edge of the tree.\n\nNext $f$ lines describe the sets forming the family $F$ . In the i-th line there are two integers $a_{i}$ and $b_{i} (1 \\le a_{i}, b_{i} \\le n)$ , such that $F_{i}$ consists of all vertices belonging to the simple path between vertices $a_{i}$ and $b_{i}$ in the tree (including $a_{i}$ and $b_{i}).$\n\n", "outputFormat": "\n\nOutput the only word `Yes` or `No` depending on whether or not the given set family is laminar.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2017] Laminar Family", "background": "", "description": "在研究组合优化时，Lucas 遇到了“层状集合族”的概念。对于某个集合 $\\Omega$ 的子集族 $F$，如果它不包含空集，并且对于任何两个不同的集合 $A, B \\in F$，要么 $A \\subset B$，要么 $B \\subset A$，要么 $A \\cap B = \\emptyset$，则称其为层状集合族。\n\n作为一名经验丰富的题目设计者，Lucas 总是尝试将他获得的每一项新知识应用于编程竞赛题目。他的科学兴趣领域包括识别问题，这些问题通常听起来像是“给定某种奇怪的组合性质，检查给定结构是否满足它”。\n\nLucas 认为完美的编程竞赛题目应该包含一个仙人掌树。在尝试将层状集合和树结合成一个识别问题时，他最终提出了以下问题：给定一个有 $n$ 个顶点的无向树和一个集合族 $F = \\{F_{1}, \\ldots, F_{k}\\}$，其中 $F_{i}$ 包含树中某两个顶点 $a_{i}$ 和 $b_{i}$ 之间简单路径上的所有顶点，检查集合族 $F$ 是否为层状集合族。注意，在这种情况下 $\\Omega = V$，并且每个 $F_{i} \\subseteq V$。\n\n如你所见，Lucas 成功地将这个问题建议给了编程竞赛。现在轮到你来解决它了。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $f (1 \\le n, f \\le 100000)$ —— 树中的顶点数和集合族 $F$ 中的元素数。\n\n接下来的 $n-1$ 行描述了树的结构。在第 $i$ 行有两个整数 $u_{i}$ 和 $v_{i} (1 \\le u_{i}, v_{i} \\le n, u_{i} \neq v_{i})$ —— 由树的第 $i$ 条边连接的顶点的索引。\n\n接下来的 $f$ 行描述了构成集合族 $F$ 的集合。在第 $i$ 行有两个整数 $a_{i}$ 和 $b_{i} (1 \\le a_{i}, b_{i} \\le n)$，使得 $F_{i}$ 包含树中顶点 $a_{i}$ 和 $b_{i}$ 之间简单路径上的所有顶点（包括 $a_{i}$ 和 $b_{i}$）。", "outputFormat": "输出一个单词 `Yes` 或 `No`，取决于给定的集合族是否为层状集合族。", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6964", "type": "P", "difficulty": 4, "samples": [["This is ACM North Eastern European Regional Contest,\nsponsored by International Business Machines.\nThe. Best. Contest. Ever.\nA Great Opportunity for all contestants.\n", "This is ACM NEERC (North Eastern European Regional Contest),\nsponsored by IBM (International Business Machines).\nThe. Best. Contest. Ever.\nA GO (Great Opportunity) for all contestants.\n"], ["ab Ab A Abc AB Abcd ABc Abcde AbC\n", "ab Ab A Abc AB Abcd ABc Abcde AbC\n"], ["Oh  No  Extra Spaces.And,Punctuation Ruin Everything\n", "Oh  No  ES (Extra Spaces).And,PRE (Punctuation Ruin Everything)\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Abbreviation", "background": "", "description": "\n\nAn abbreviation (from Latin brevis, meaning short) is a shortened form of a word or phrase. In this problem you must write an automated tool that replaces a sequence of capitalized words with the corresponding abbreviation that consists of the first upper case letters only, followed by a full definition in parenthesis. See sample input and output.\n\nLet us make some formal definitions. A word in a text is a maximally long sequence of lower and upper case English letters. A capitalized word is a word that consists of an upper case letter followed by one or more lower case letters. For example, `Ab`, `Abc`, `Abcd`, and `Abcde` are all capitalized words, while `ab`, `A`, `AB`, `ABc` and `AbC` are not.\n\nAn abbreviatable sequence of words is a sequence of two or more capitalized words that are separated by exactly one space, no line breaks or punctuation are allowed inside it.\n\nAn abbreviation of an abbreviatable sequence of words is a sequence of the first (upper case) letters of each word, followed by a single space, an opening parenthesis, the original abbreviatable sequence, and a closing parenthesis.\n\n", "inputFormat": "\n\nThe input file consists of up to $1 000$ lines of text with up to $120$ characters on each line. Each line consists of spaces, upper and lower case letters, commas or dots. There are no leading or trailing spaces on lines and there are no empty lines. There is at least one line in the input file.\n\n", "outputFormat": "\n\nWrite to the output file the original text with every abbreviatable sequence of words replaced with the corresponding abbreviation.\n\n", "hint": "Time limit: 1 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Abbreviation", "background": "", "description": "\n\nAn abbreviation (from Latin brevis, meaning short) is a shortened form of a word or phrase. In this problem you must write an automated tool that replaces a sequence of capitalized words with the corresponding abbreviation that consists of the first upper case letters only, followed by a full definition in parenthesis. See sample input and output.\n\nLet us make some formal definitions. A word in a text is a maximally long sequence of lower and upper case English letters. A capitalized word is a word that consists of an upper case letter followed by one or more lower case letters. For example, `Ab`, `Abc`, `Abcd`, and `Abcde` are all capitalized words, while `ab`, `A`, `AB`, `ABc` and `AbC` are not.\n\nAn abbreviatable sequence of words is a sequence of two or more capitalized words that are separated by exactly one space, no line breaks or punctuation are allowed inside it.\n\nAn abbreviation of an abbreviatable sequence of words is a sequence of the first (upper case) letters of each word, followed by a single space, an opening parenthesis, the original abbreviatable sequence, and a closing parenthesis.\n\n", "inputFormat": "\n\nThe input file consists of up to $1 000$ lines of text with up to $120$ characters on each line. Each line consists of spaces, upper and lower case letters, commas or dots. There are no leading or trailing spaces on lines and there are no empty lines. There is at least one line in the input file.\n\n", "outputFormat": "\n\nWrite to the output file the original text with every abbreviatable sequence of words replaced with the corresponding abbreviation.\n\n", "hint": "Time limit: 1 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Abbreviation", "background": null, "description": "定义 word 为一个首字母大写、长度大于 $1$、 其他位为小写字母的单词，如 `Ab`、 `Abc`、 `Abcd` 和 `Abcde`，但 `ab`、`A`、 `AB`、 `ABc` 和 `AbC` 不是。\n\n定义一个 word 串为一个有大于 $1$ 个 word 、每两个 word 中有且只有一个空格的串，如 `International Business Machines`。\n\n现给你若干行，如遇到 word 串则让他变为缩写，缩写方式为：先提取首字母（大写），再加空格和 `(` ，再把全称写出来，最后加上 `)` ，如: `International Business Machines` 可缩写为 `IBM (International Business Machines)` 。", "inputFormat": "若干行（不超过 $1000$ 行）由大小写字母、标点和空格组成的的字符串（每行不超过 $120$ 个字符）。", "outputFormat": "缩写后的若干行字符串（无法缩写的不用缩写）。\n\n#### translate by:`ddgtang`", "hint": null, "locale": "zh-CN"}}}
{"pid": "P6965", "type": "P", "difficulty": 6, "samples": [["4\n00?\n0?00\n?1\n1?0\n", "YES\n000\n0100\n11\n100\n"], ["3\n0100\n01?0\n01?0\n", "NO\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2016", "Special Judge", "图论建模", "2-SAT", "字典树 Trie", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Binary Code", "background": "", "description": "\n\nBen has recently learned about binary prefix codes. A binary code is a set of $n$ distinct nonempty code words $s_{i}$ , each consisting of 0s and $1s.$ A code is called a prefix code if for every $i ≠ j$ neither $s_{i}$ is a prefix of $s_{j}$ nor $s_{j}$ is a prefix of $s_{i}$ . A word $x$ is called a prefix of a word $w$ if there exists a possibly empty word $y$ , such that xy $= w$ . For example, $x = 11$ is a prefix of $w = 110$ and $x = 0100$ is a prefix of $w = 0100$ .\n\nBen found a paper with $n$ lines of binary code in it. However, this paper is pretty old and there are some unreadable characters. Fortunately, each word contains at most one unreadable character.\n\nBen wants to know whether these $n$ lines could represent a binary prefix code. In other words, can he replace every unreadable character with $0$ or $1$ , so that the code becomes a prefix code?\n\n", "inputFormat": "\n\nThe first line contains integer $n$ -- the number of code words $(1 \\le n \\le 5 · 10^{5}).$\n\nNext $n$ lines contain nonempty code word records, one per line. Each code word record consists of `0`, `1` and `?` characters. Every code word record contains at most one `?` character that represents unreadable character.\n\nThe total length of words does not exceed $5 · 10^{5}$ .\n\n", "outputFormat": "\n\nOutput `NO` in the first line if the code cannot be a prefix code.\n\nOtherwise, output `YES` in the first line. Next $n$ lines shall contain code words in the same order as the corresponding code word records in the input.\n\nIf there are several prefix codes, that could have been written on the paper, output any one.\n\n", "hint": "Time limit: 2 s, Memory limit: 2048 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Binary Code", "background": "", "description": "\n\nBen has recently learned about binary prefix codes. A binary code is a set of $n$ distinct nonempty code words $s_{i}$ , each consisting of 0s and $1s.$ A code is called a prefix code if for every $i ≠ j$ neither $s_{i}$ is a prefix of $s_{j}$ nor $s_{j}$ is a prefix of $s_{i}$ . A word $x$ is called a prefix of a word $w$ if there exists a possibly empty word $y$ , such that xy $= w$ . For example, $x = 11$ is a prefix of $w = 110$ and $x = 0100$ is a prefix of $w = 0100$ .\n\nBen found a paper with $n$ lines of binary code in it. However, this paper is pretty old and there are some unreadable characters. Fortunately, each word contains at most one unreadable character.\n\nBen wants to know whether these $n$ lines could represent a binary prefix code. In other words, can he replace every unreadable character with $0$ or $1$ , so that the code becomes a prefix code?\n\n", "inputFormat": "\n\nThe first line contains integer $n$ -- the number of code words $(1 \\le n \\le 5 · 10^{5}).$\n\nNext $n$ lines contain nonempty code word records, one per line. Each code word record consists of `0`, `1` and `?` characters. Every code word record contains at most one `?` character that represents unreadable character.\n\nThe total length of words does not exceed $5 · 10^{5}$ .\n\n", "outputFormat": "\n\nOutput `NO` in the first line if the code cannot be a prefix code.\n\nOtherwise, output `YES` in the first line. Next $n$ lines shall contain code words in the same order as the corresponding code word records in the input.\n\nIf there are several prefix codes, that could have been written on the paper, output any one.\n\n", "hint": "Time limit: 2 s, Memory limit: 2048 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Binary Code", "background": "", "description": "给定 `n` 个01串，每个字符串至多有一位是未知的，可以填 `0` 或 `1` ，求是否存在一种方案，使得任意一个字符串不是其它任意一个字符串的前缀", "inputFormat": "第一行是一个正整数 `n` ，代表字符串的数量。 $(1 \\leq n \\leq 5 \\cdot 10^5)$\n\n接下来 `n` 行每行一个字符串，只可能由 `0` 、 `1` 或 `?` 组成。 `?` 代表未知的位置，每个字符串最多一个。\n\n保证字符串总长度不超过 $5 \\cdot 10^5$ 。", "outputFormat": "如果无解，只需要输出 `NO` 。\n\n如果有解，在第一行输出 `YES` ，接下来 `n` 行输出方案。\n\n如果有多组解，只需要输出任意一组。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6966", "type": "P", "difficulty": 6, "samples": [["8 2\n5 1 2 3 4 7\n5 4 5 6 1 8\n", "17\nr 2 1 2\nj 2 3\nc 2 1 2\nr 6 1 2\nj 5 6\nc 6 1 2\nr 4 1 3\nj 4 3\nj 4 6\nj 4 7\nc 4 3 1\nr 4 3 1\nr 8 1 2\nr 1 1 3\nj 1 8\nj 1 4\nc 1 3 2\n"], ["15 3\n9 1 2 3 4 5 6 7 8 3\n7 2 9 10 11 12 13 10\n5 2 14 9 15 10\n", "39\nr 7 1 2\nr 5 1 2\nj 7 8\nc 7 1 2\nj 5 4\nc 5 1 2\nr 6 1 3\nj 6 7\nj 6 5\nc 6 3 2\nr 3 1 4\nj 6 3\nc 6 4 1\nr 11 1 2\nr 13 1 2\nj 12 11\nj 12 13\nc 11 1 2\nr 10 1 3\nj 12 10\nc 10 2 3\nr 10 1 2\nr 10 4 2\nr 15 1 3\nj 15 10\nc 15 3 3\nj 9 10\nc 9 1 3\nr 9 3 2\nr 9 1 4\nr 14 1 4\nj 9 14\nc 9 4 4\nr 1 1 4\nr 3 1 2\nj 2 1\nj 2 14\nj 2 3\nc 2 1 4\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Cactus Construction", "background": "", "description": "\n\nLet us consider the following way of constructing graphs. Pick the number of colors $ˆc$ . Let $n$ be the number of vertices in a graph. To build a graph, we use a workspace with several graphs in it. Each vertex of each graph has a color. Colors are denoted by integers from $1$ to $ˆc$ . Initially, we have $n$ graphs in a workspace with one vertex in each graph, all colored with color $1$ , and no edges. The only vertex of i-th graph has number $i$ .\n\nThe following operations are permitted:\n\njoin a $b$ : join graphs containing vertices a and $b$ into one graph. No edges are added. Vertices a and $b$ must be in different graphs.\n\nrecolor a $c_{1 }c_{2}:$ in graph containing vertex a recolor all vertices of color $c_{1}$ with color $c_{2}.$\n\nconnect a $c_{1 }c_{2}:$ in graph containing vertex a create edges between all pairs of vertices where one vertex has color $c_{1}$ and the other has color $c_{2}.$ If $c_{1} = c_{2}$ loops are not created. If such an edge already exists, then the second parallel edge is created. Multi-edges are not allowed in this problem, so this case must not occur.\n\nAt the end we should have a single graph and colors of its vertices do not matter.\n\nThe minimal number of colors $ˆc$ , that can be used to construct a graph, is called a clique width of a graph. Clique width is one of the characteristics of graph complexity. Many NP-hard problems can be solved in polynomial time on graphs with bounded clique width, using dynamic programming on this process of building a graph. For a general graph, calculating the exact value of a clique width is known to be NP-hard. However, for some graph classes bounds on a clique width are known.\n\nCactus is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively cactus is a generalization of a tree where some cycles are allowed. Multi-edges (multiple edges between a pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus. It is known that a clique width of a cactus does not exceed $4$ .\n\nYou are given a cactus. Find out how to build it in the described way using at most $ˆc = 4$ colors.\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13991/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%207.31.10.png)\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13991/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%207.31.21.png)\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $m (1 \\le n \\le 50 000$ ; $0 \\le m \\le 50 000)$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ . Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths.\n\nEach of the following $m$ lines contains a path in the graph. A path starts with an integer $k_{i} (2 \\le k_{i } \\le 1000)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. Adjacent vertices in the path are distinct. The path can go to the same vertex multiple times, but every edge is traversed exactly once in the whole input file.\n\nThe graph in the input file is a cactus.\n\n", "outputFormat": "\n\nIn the first line print one integer $q$ -- the number of operations you need. This number should not be greater than $10^{6}$ . In the next $q$ lines print operations. Each operation is denoted by its first letter (`j` for join, `r` for recolor and `c` for connect) and its arguments in the order they are described in the problem statement.\n\nAt the end, after applying all these operations, one should have one graph, which is equal to the cactus in the input. This means that there should be exactly one edge between each pair of vertices connected in the input graph, and no edges between vertices not connected in the input graph.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Cactus Construction", "background": "", "description": "\n\nLet us consider the following way of constructing graphs. Pick the number of colors $ˆc$ . Let $n$ be the number of vertices in a graph. To build a graph, we use a workspace with several graphs in it. Each vertex of each graph has a color. Colors are denoted by integers from $1$ to $ˆc$ . Initially, we have $n$ graphs in a workspace with one vertex in each graph, all colored with color $1$ , and no edges. The only vertex of i-th graph has number $i$ .\n\nThe following operations are permitted:\n\njoin a $b$ : join graphs containing vertices a and $b$ into one graph. No edges are added. Vertices a and $b$ must be in different graphs.\n\nrecolor a $c_{1 }c_{2}:$ in graph containing vertex a recolor all vertices of color $c_{1}$ with color $c_{2}.$\n\nconnect a $c_{1 }c_{2}:$ in graph containing vertex a create edges between all pairs of vertices where one vertex has color $c_{1}$ and the other has color $c_{2}.$ If $c_{1} = c_{2}$ loops are not created. If such an edge already exists, then the second parallel edge is created. Multi-edges are not allowed in this problem, so this case must not occur.\n\nAt the end we should have a single graph and colors of its vertices do not matter.\n\nThe minimal number of colors $ˆc$ , that can be used to construct a graph, is called a clique width of a graph. Clique width is one of the characteristics of graph complexity. Many NP-hard problems can be solved in polynomial time on graphs with bounded clique width, using dynamic programming on this process of building a graph. For a general graph, calculating the exact value of a clique width is known to be NP-hard. However, for some graph classes bounds on a clique width are known.\n\nCactus is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively cactus is a generalization of a tree where some cycles are allowed. Multi-edges (multiple edges between a pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus. It is known that a clique width of a cactus does not exceed $4$ .\n\nYou are given a cactus. Find out how to build it in the described way using at most $ˆc = 4$ colors.\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13991/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%207.31.10.png)\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13991/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%207.31.21.png)\n\n", "inputFormat": "\n\nThe first line of the input file contains two integers $n$ and $m (1 \\le n \\le 50 000$ ; $0 \\le m \\le 50 000)$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ . Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths.\n\nEach of the following $m$ lines contains a path in the graph. A path starts with an integer $k_{i} (2 \\le k_{i } \\le 1000)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. Adjacent vertices in the path are distinct. The path can go to the same vertex multiple times, but every edge is traversed exactly once in the whole input file.\n\nThe graph in the input file is a cactus.\n\n", "outputFormat": "\n\nIn the first line print one integer $q$ -- the number of operations you need. This number should not be greater than $10^{6}$ . In the next $q$ lines print operations. Each operation is denoted by its first letter (`j` for join, `r` for recolor and `c` for connect) and its arguments in the order they are described in the problem statement.\n\nAt the end, after applying all these operations, one should have one graph, which is equal to the cactus in the input. This means that there should be exactly one edge between each pair of vertices connected in the input graph, and no edges between vertices not connected in the input graph.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Cactus Construction", "background": "", "description": "让我们考虑以下构建图的方法。选择颜色数 $\\hat{c}$。设 $n$ 为图中的顶点数。为了构建一个图，我们使用一个包含多个图的工作空间。每个图的每个顶点都有一个颜色。颜色由从 $1$ 到 $\\hat{c}$ 的整数表示。最初，我们在工作空间中有 $n$ 个图，每个图中有一个顶点，所有顶点都被涂成颜色 $1$，且没有边。第 $i$ 个图的唯一顶点编号为 $i$。\n\n允许以下操作：\n\njoin a $b$：将包含顶点 $a$ 和 $b$ 的图合并为一个图。不添加边。顶点 $a$ 和 $b$ 必须在不同的图中。\n\nrecolor a $c_{1}c_{2}$：在包含顶点 $a$ 的图中，将所有颜色为 $c_{1}$ 的顶点重新着色为颜色 $c_{2}$。\n\nconnect a $c_{1}c_{2}$：在包含顶点 $a$ 的图中，创建所有颜色为 $c_{1}$ 的顶点与颜色为 $c_{2}$ 的顶点之间的边。如果 $c_{1} = c_{2}$，则不创建自环。如果这样的边已经存在，则创建第二条平行边。在这个问题中不允许多重边，所以这种情况不应发生。\n\n最后，我们应该有一个单一的图，并且其顶点的颜色无关紧要。\n\n可以用来构建图的最小颜色数 $\\hat{c}$ 称为图的团宽。团宽是图复杂度的特征之一。许多 NP 难问题可以在团宽有界的图上通过动态规划在这个构建图的过程中以多项式时间解决。对于一般图，计算团宽的确切值已知是 NP 难的。然而，对于某些图类，已知团宽的界限。\n\n仙人掌图是一个连通的无向图，其中每条边最多位于一个简单环上。直观上，仙人掌图是树的推广，其中允许一些环。仙人掌图中不允许多重边（在一对顶点之间的多条边）和自环（连接顶点自身的边）。已知仙人掌图的团宽不超过 $4$。\n\n给定一个仙人掌图。找出如何用最多 $\\hat{c} = 4$ 种颜色以描述的方式构建它。\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13991/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%207.31.10.png)\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13991/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%207.31.21.png)", "inputFormat": "输入文件的第一行包含两个整数 $n$ 和 $m (1 \\le n \\le 50 000$；$0 \\le m \\le 50 000)$。这里 $n$ 是图中的顶点数。顶点从 $1$ 到 $n$ 编号。图的边由一组边不同的路径表示，其中 $m$ 是这样的路径数。\n\n接下来的 $m$ 行中的每一行包含图中的一条路径。路径以一个整数 $k_{i} (2 \\le k_{i} \\le 1000)$ 开头，后跟 $k_{i}$ 个从 $1$ 到 $n$ 的整数。这些 $k_{i}$ 个整数表示路径的顶点。路径中的相邻顶点是不同的。路径可以多次经过同一个顶点，但整个输入文件中每条边仅被遍历一次。\n\n输入文件中的图是一个仙人掌图。", "outputFormat": "在第一行打印一个整数 $q$——你需要的操作数。这个数字不应大于 $10^{6}$。在接下来的 $q$ 行中打印操作。每个操作由其首字母（`j` 表示 join，`r` 表示 recolor 和 `c` 表示 connect）及其参数按问题描述的顺序表示。\n\n最后，在应用所有这些操作后，应该得到一个图，它等于输入中的仙人掌图。这意味着在输入图中连接的每对顶点之间应该正好有一条边，而在输入图中未连接的顶点之间不应有边。", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6967", "type": "P", "difficulty": 6, "samples": [["10 4 1 2\n1 2 3 4 5 6 7 8 9 10\n10 9 8 7 6 5 4 3 2 1\n", "69\nEEESESEESS\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "网络流", "Special Judge", "图论建模", "线性规划", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Delight for a Cat", "background": "", "description": "\n\nA cat is going on an adventure.\n\nEach hour, the cat can be either sleeping or eating. The cat cannot be doing both actions at the same hour, and the cat is doing exactly one of these actions for the whole hour.\n\nFor each of the next $n$ hours, the amount of delight the cat is getting if it is sleeping or eating during that hour is known. These amounts can be different for each hour.\n\nAn integer time period $k$ is also known. Among every $k$ consecutive hours, there should be at least $m_{s}$ hours when the cat is sleeping, and at least $m_{e}$ hours when the cat is eating. So, there are exactly $n − k + 1$ segments of $k$ hours for which this condition must be satisfied.\n\nFind the maximum total amount of delight the cat can get during the next $n$ hours.\n\n", "inputFormat": "\n\nThe first line of the input contains four integers $n , k , m_{s},$ and $m_{e} (1 \\le k \\le n \\le 1000$ ; $0 \\le m_{s}, m_{e} \\le k$ ; $m_{s} + m_{e} \\le k)$ -- the number of upcoming hours, the length of the period (in hours), and the minimum number of hours the cat should be sleeping and eating out of every $k$ consecutive hours, respectively.\n\nThe second line contains $n$ integers $s_{1}, s_{2},$ . . . , $s_{n} (0 \\le s_{i } \\le 10^{9}$ ) -- the amount of delight the cat gets when it is sleeping during the first, the second, $ \\cdots ,$ the n-th hour.\n\nThe third line contains $n$ integers $e_{1}, e_{2},$ . . . , $e_{n} (0 \\le e_{i} \\le 10^{9}$ ) -- the amount of delight the cat gets when it is eating during the first, the second, $ \\cdots ,$ the n-th hour.\n\n", "outputFormat": "\n\nIn the first line, output a single integer -- the maximum total amount of delight the cat can get during the next $n$ hours.\n\nIn the second line, output a string of length $n$ consisting of characters `S` and `E`. The i-th character of this string should correspond to whether the cat should sleep $(`S`)$ or eat $(`E`)$ in the i-th hour to get the maximum total amount of delight out of these $n$ hours.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Delight for a Cat", "background": "", "description": "\n\nA cat is going on an adventure.\n\nEach hour, the cat can be either sleeping or eating. The cat cannot be doing both actions at the same hour, and the cat is doing exactly one of these actions for the whole hour.\n\nFor each of the next $n$ hours, the amount of delight the cat is getting if it is sleeping or eating during that hour is known. These amounts can be different for each hour.\n\nAn integer time period $k$ is also known. Among every $k$ consecutive hours, there should be at least $m_{s}$ hours when the cat is sleeping, and at least $m_{e}$ hours when the cat is eating. So, there are exactly $n − k + 1$ segments of $k$ hours for which this condition must be satisfied.\n\nFind the maximum total amount of delight the cat can get during the next $n$ hours.\n\n", "inputFormat": "\n\nThe first line of the input contains four integers $n , k , m_{s},$ and $m_{e} (1 \\le k \\le n \\le 1000$ ; $0 \\le m_{s}, m_{e} \\le k$ ; $m_{s} + m_{e} \\le k)$ -- the number of upcoming hours, the length of the period (in hours), and the minimum number of hours the cat should be sleeping and eating out of every $k$ consecutive hours, respectively.\n\nThe second line contains $n$ integers $s_{1}, s_{2},$ . . . , $s_{n} (0 \\le s_{i } \\le 10^{9}$ ) -- the amount of delight the cat gets when it is sleeping during the first, the second, $ \\cdots ,$ the n-th hour.\n\nThe third line contains $n$ integers $e_{1}, e_{2},$ . . . , $e_{n} (0 \\le e_{i} \\le 10^{9}$ ) -- the amount of delight the cat gets when it is eating during the first, the second, $ \\cdots ,$ the n-th hour.\n\n", "outputFormat": "\n\nIn the first line, output a single integer -- the maximum total amount of delight the cat can get during the next $n$ hours.\n\nIn the second line, output a string of length $n$ consisting of characters `S` and `E`. The i-th character of this string should correspond to whether the cat should sleep $(`S`)$ or eat $(`E`)$ in the i-th hour to get the maximum total amount of delight out of these $n$ hours.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Delight for a Cat", "background": "", "description": "一只猫正在进行一次冒险。\n\n每小时，猫可以选择睡觉或吃东西。猫不能在同一小时内同时进行这两种活动，并且猫在整小时内只能进行其中一种活动。\n\n对于接下来的 $n$ 小时，已知猫在每小时内睡觉或吃东西所获得的快乐值。这些值在每小时内可能不同。\n\n还知道一个整数时间段 $k$。在每 $k$ 个连续的小时中，至少有 $m_{s}$ 小时猫在睡觉，至少有 $m_{e}$ 小时猫在吃东西。因此，有正好 $n - k + 1$ 个 $k$ 小时的时间段需要满足这个条件。\n\n求猫在接下来的 $n$ 小时内所能获得的最大总快乐值。", "inputFormat": "输入的第一行包含四个整数 $n, k, m_{s},$ 和 $m_{e}$ $(1 \\le k \\le n \\le 1000$；$0 \\le m_{s}, m_{e} \\le k$；$m_{s} + m_{e} \\le k)$ ——即将到来的小时数、时间段的长度（以小时为单位），以及在每 $k$ 个连续小时中猫至少应该睡觉和吃东西的小时数。\n\n第二行包含 $n$ 个整数 $s_{1}, s_{2}, \\ldots, s_{n}$ $(0 \\le s_{i} \\le 10^{9})$ ——猫在第 1 小时、第 2 小时、$\\cdots$、第 $n$ 小时睡觉时获得的快乐值。\n\n第三行包含 $n$ 个整数 $e_{1}, e_{2}, \\ldots, e_{n}$ $(0 \\le e_{i} \\le 10^{9})$ ——猫在第 1 小时、第 2 小时、$\\cdots$、第 $n$ 小时吃东西时获得的快乐值。", "outputFormat": "在第一行输出一个整数——猫在接下来的 $n$ 小时内所能获得的最大总快乐值。\n\n在第二行输出一个长度为 $n$ 的字符串，由字符 `S` 和 `E` 组成。这个字符串的第 $i$ 个字符应对应于猫在第 $i$ 小时应该睡觉 $(`S`)$ 还是吃东西 $(`E`)$，以便在这 $n$ 小时内获得最大的总快乐值。", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6968", "type": "P", "difficulty": 0, "samples": [["5 4\n- 1 1\n- 2 2\n+ 4 1\n- 6 1\n+ 7 2\n0 3 1 2\n", "INFINITY\n0\n8\n3\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Expect to Wait", "background": "", "description": "\n\nMayor Adam East wants to improve the public transport network of Harshel city by introducing the network of stations with unicycles. Any person who owns a special card can come to a station and request a unicycle to ride or drop one.\n\nThe procedure of requesting a unicycle is simple. The person enters a queue. If there is a unicycle available, then the first person from the queue takes it immediately. Otherwise, people in the queue wait until someone drops a unicycle at the station.\n\nLet the wait time be the time that person spends between the request (entrance to the queue) and obtaining a unicycle. If the person does not receive a unicycle at all, then the wait time is infinity. The total wait time is the sum of wait times for each person.\n\nAdam already knows the schedule of all the people for every day. He knows at what times people request and drop unicycles at the Central Station that can hold any number of unicycles at the same time. The only thing he does not know is how many unicycles should be placed there at the start of each day. He asks you several questions to calculate the total wait time given the starting number of unicycles.\n\n", "inputFormat": "\n\nThe first line contains $n$ and $q (1 \\le n , q \\le 10^{5} ),$ where $n$ is the total number of unicycle requests and unicycle drops at the Central Station, and $q$ is the number of questions Adam asks you. The next $n$ lines describe operations at the Central Station. Each line contains one description of operation:\n\n$`+ t$ k` when $k$ unicycles are dropped at time $t$ ;\n\n$`- t$ k` when $k$ people request unicycles at time $t$ .\n\nFor each of the described operations $1 \\le t \\le 10^{9}$ and $1 \\le k \\le 10^{4}$ . The last line of the input contains $q$ different integers $b_{i} (0 \\le b_{i} \\le 10^{9}$ ) -- the number of unicycles at the start of the day.\n\nThe operations are given in the strongly increasing order of time.\n\n", "outputFormat": "\n\nThe output shall consist of $q$ lines. The i-th line shall display the total wait time for the case of $b_{i}$ unicycles at the start of the day. If the total wait time is infinite, then the corresponding line shall display the word `INFINITY`.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Expect to Wait", "background": "", "description": "\n\nMayor Adam East wants to improve the public transport network of Harshel city by introducing the network of stations with unicycles. Any person who owns a special card can come to a station and request a unicycle to ride or drop one.\n\nThe procedure of requesting a unicycle is simple. The person enters a queue. If there is a unicycle available, then the first person from the queue takes it immediately. Otherwise, people in the queue wait until someone drops a unicycle at the station.\n\nLet the wait time be the time that person spends between the request (entrance to the queue) and obtaining a unicycle. If the person does not receive a unicycle at all, then the wait time is infinity. The total wait time is the sum of wait times for each person.\n\nAdam already knows the schedule of all the people for every day. He knows at what times people request and drop unicycles at the Central Station that can hold any number of unicycles at the same time. The only thing he does not know is how many unicycles should be placed there at the start of each day. He asks you several questions to calculate the total wait time given the starting number of unicycles.\n\n", "inputFormat": "\n\nThe first line contains $n$ and $q (1 \\le n , q \\le 10^{5} ),$ where $n$ is the total number of unicycle requests and unicycle drops at the Central Station, and $q$ is the number of questions Adam asks you. The next $n$ lines describe operations at the Central Station. Each line contains one description of operation:\n\n$`+ t$ k` when $k$ unicycles are dropped at time $t$ ;\n\n$`- t$ k` when $k$ people request unicycles at time $t$ .\n\nFor each of the described operations $1 \\le t \\le 10^{9}$ and $1 \\le k \\le 10^{4}$ . The last line of the input contains $q$ different integers $b_{i} (0 \\le b_{i} \\le 10^{9}$ ) -- the number of unicycles at the start of the day.\n\nThe operations are given in the strongly increasing order of time.\n\n", "outputFormat": "\n\nThe output shall consist of $q$ lines. The i-th line shall display the total wait time for the case of $b_{i}$ unicycles at the start of the day. If the total wait time is infinite, then the corresponding line shall display the word `INFINITY`.\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Expect to Wait", "background": "", "description": "# [NEERC2016] Expect to Wait\n\n\n市长小A想要给H市添加独轮车车站，任何有“特殊的卡片”的人，都可以到车站请求骑车或停放。\n\n申请独轮车很简单，申请骑车的人到车站排队，如果那个站有独轮车停放，那么就让处于队头位置的人先骑，否则，排队的人会等到有人把独轮车送到车站。\n\n定义等待时间为从请求人开始排队到取到车所花的时间，如果一个人取不到独轮车，那么等待的时间是无限（infinity）的。总等待时间是每个人等待时间的总和。\n\n小A已经知道人们每天在什么时候向车站请求和放下独轮车，车站可以同时容纳无限独轮车。他会告诉你每天车站里人们的用车计划，然后对你进行n次询问，每次提问会告诉你一天开始时车站里有的独轮车数，请你来计算每个问题所对应的总等待时间。", "inputFormat": "第一行包含两个正整数 $n$ 和 $q (1 \\le n , q \\le 10^{5} ),$ $n$代表有n个用车计划, $q$代表小A会问你n个问题 接下来$n$行代表每个用车计划，每个计划包含一个操作说明：\n\n$+tk$ 代表人们在$t$时间要求停放$k$辆车;\n\n$- t k$ 代表人们在$t$时间要求取$k$辆车.\n\n对于每个用车计划： $1 \\le t \\le 10^{9}$ and $1 \\le k \\le 10^{4}$ . 输入的最后一行包含 $q$ 个不同的整数 $b_{i} (0 \\le b_{i} \\le 10^{9}$ ) -- 一天开始时独轮车的数量。\n\n操作的顺序是按时间复杂度从小到大的", "outputFormat": "输出应包括$q$行。第i行应显示当天开始时$b_{i}$独轮车的总等待时间。如果总等待时间是无限的，则相应的行应显示单词`INFINITY`。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n5 4\n- 1 1\n- 2 2\n+ 4 1\n- 6 1\n+ 7 2\n0 3 1 2\n```\n\n### 样例输出 #1\n\n```\nINFINITY\n0\n8\n3\n```", "hint": "时间限制: 2 s,空间限制: 512 MB.", "locale": "zh-CN"}}}
{"pid": "P6969", "type": "P", "difficulty": 0, "samples": [["CWCC\n", "1.0\n"], ["WWCWCCW\n", "2.333333333333\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NEERC 2016] Foreign Postcards", "background": "", "description": "\n\nFedor is an avid traveler. As a result of his hobby, he has gathered a big collection of postcards from all over the world. Each postcard has a unique picture on the front side and some fields for address information and text on the back side.\n\nDuring one of the parties at Fedor's house, he decided to show all his of postcards to the guests. To achieve that, he wants to lay them all out on the table. Initially, all of his postcards are arranged in a single stack that Fedor is holding in his hands. Unfortunately, some of the postcards in that stack can be turned incorrectly -- upside down. Ideally, Fedor would like all postcards on the table to lie with the picture on top, but looking at every postcard and turning it over individually can be very time-consuming. Instead, he came up with the following process:\n\nLet $n$ be the number of postcards remaining in the stack in his hands. Fedor chooses a random number $k$ uniformly between $1$ and $n$ and takes top $k$ postcards from the stack.\n\nHe looks at the topmost postcard among these $k$ postcards. If it is oriented in the wrong way, he turns the whole stack of $k$ postcards upside down together.\n\nHe then puts these $k$ postcards on the table without any further rotations.\n\nIf there are still some postcards remaining in the stack in his hands, Fedor goes back to step $1$ .\n\nOf course, after all the postcards are on the table, there might still be some that lie back side up. What is the expected number of such postcards?\n\n", "inputFormat": "\n\nThe input consists of a single line of `C` and `W` characters -- i-th character corresponds to i-th postcard in the stack, counting from the top of the stack. `C` means that i-th postcard is oriented correctly in the initial stack, and `W` means that i-th postcard is oriented in the wrong way. The number of characters is between $1$ and $10^{6}$ inclusive.\n\n", "outputFormat": "\n\nOutput one real number -- the expected number of incorrectly placed postcards on the table. The absolute or relative error should not exceed $10^{−9}$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\nspj 由 [tiger2005](https://www.luogu.com.cn/user/60864) 提供。", "locale": "en", "translations": {"en": {"title": "[NEERC 2016] Foreign Postcards", "background": "", "description": "\n\nFedor is an avid traveler. As a result of his hobby, he has gathered a big collection of postcards from all over the world. Each postcard has a unique picture on the front side and some fields for address information and text on the back side.\n\nDuring one of the parties at Fedor's house, he decided to show all his of postcards to the guests. To achieve that, he wants to lay them all out on the table. Initially, all of his postcards are arranged in a single stack that Fedor is holding in his hands. Unfortunately, some of the postcards in that stack can be turned incorrectly -- upside down. Ideally, Fedor would like all postcards on the table to lie with the picture on top, but looking at every postcard and turning it over individually can be very time-consuming. Instead, he came up with the following process:\n\nLet $n$ be the number of postcards remaining in the stack in his hands. Fedor chooses a random number $k$ uniformly between $1$ and $n$ and takes top $k$ postcards from the stack.\n\nHe looks at the topmost postcard among these $k$ postcards. If it is oriented in the wrong way, he turns the whole stack of $k$ postcards upside down together.\n\nHe then puts these $k$ postcards on the table without any further rotations.\n\nIf there are still some postcards remaining in the stack in his hands, Fedor goes back to step $1$ .\n\nOf course, after all the postcards are on the table, there might still be some that lie back side up. What is the expected number of such postcards?\n\n", "inputFormat": "\n\nThe input consists of a single line of `C` and `W` characters -- i-th character corresponds to i-th postcard in the stack, counting from the top of the stack. `C` means that i-th postcard is oriented correctly in the initial stack, and `W` means that i-th postcard is oriented in the wrong way. The number of characters is between $1$ and $10^{6}$ inclusive.\n\n", "outputFormat": "\n\nOutput one real number -- the expected number of incorrectly placed postcards on the table. The absolute or relative error should not exceed $10^{−9}$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\nspj 由 [tiger2005](https://www.luogu.com.cn/user/60864) 提供。", "locale": "en"}, "zh-CN": {"title": "[NEERC 2016] Foreign Postcards", "background": "", "description": "费多是个热心的旅行者。由于他的爱好，他收集了来自世界各地的大量明信片。每张明信片正面都有一张独特的图片，背面有一些地址信息和文本字段。\n\n在费多家的一次聚会上，他决定向客人展示他所有的明信片。为了实现这一目标，他想把它们全部摆在桌面上。起初，他所有的明信片都被安排在一个单叠里，费多拿在手里。不幸的是，这堆明信片中的一些可能会被错误地翻过来——颠倒过来。理想情况下，费多希望桌上的所有明信片都放在图片的上方，但查看每张明信片并逐个翻转可能非常耗时。相反，他提出了以下过程：\n\n让 $n$ 是他手中的那堆明信片的剩余数量。费多均匀地选择一个介于1和 $n$ 之间的随机数 $k$ ，并从堆栈中取出前 $k$ 张明信片。\n\n他看了看这 $k$ 张明信片中最上面的一张明信片。如果方向错误，他会将整叠明信片倒置在一起。\n\n然后，他把这 $k$ 张明信片放在桌子上，不再旋转。\n\n如果他手里还有一些明信片，费多会返回到步骤 $1$ 。\n\n当然，在所有的明信片都放在桌子上之后，可能仍然有一些明信片是倒着放的。这类明信片的预期数量是多少？", "inputFormat": "输入由一行 $C$ 和 $W$ 字符组成——第 $i$ 个字符对应于栈中的第 $i$ 个明信片，从栈顶部开始计数。$C$ 表示第 $i$ 张明信片在初始栈中的方向正确， $W$ 表示第 $i$ 张明信片的方向错误。字符数在 $1$ 到 $10^{6}$ 之间, $6$ 包括在内。", "outputFormat": "输出一个实数——表上错误放置的明信片的预期数量。绝对或相对误差不应超过 $10^{−9}$", "hint": "时间限制：2s，内存限制：512 MB。", "locale": "zh-CN"}}}
