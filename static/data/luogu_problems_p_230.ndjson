{"pid": "P5652", "type": "P", "difficulty": 5, "samples": [["5 2 3 0\n2 4 1 2 3\n1 5\n3 5\n3 4", "5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["洛谷月赛"], "title": "基础博弈练习题", "background": "YSGH is our red sun.", "description": "YSGH 和 YGSH 在打膈膜，YSGS 在旁边围观。\n\n规则是这样的，先给定一个正整数 $m$ 和一个 $n$ 个数的序列 $b$，一开始有一个棋子在 $b$ 的第一个位置，并将 $b_1$ 减去 $1$。此后双方轮流操作，每次操作，假设当前棋子在 $i$，可以把棋子移到一个位置 $j$，满足 $j \\in [i, \\min(i + m, n)]$ 且 $b_j > 0$，然后将 $b_j$ 减 $1$，YSGH 先手，谁先不能操作谁输。\n\n众所周知，YSGH 和 YGSH 都是绝顶聪明的，所以两人都会使用最优策略。\n\n而隔膜使用的序列 $b$ 是一个序列 $a$ 的一个连续非空子序列，当然序列 $a$ 和每次隔膜使用的序列 $b$ 都是 YSGS 定的。\n\n现在他们进行了 $q$ 轮游戏，给出每轮游戏使用的区间，请你判断每轮谁会赢。", "inputFormat": "由于本题数据规模较大，直接输入输出会占用比计算多数倍的时间，因此当询问过多时会对询问的输入输出进行了压缩。\n\n第一行四个正整数 $n, m, q, type$，$n, m, q$ 意义同题面描述，$type$ 表示当前数据的类型，$type = 1$ 说明该组数据进行了压缩，$type = 0$ 则说明没有，数据保证当 $q > {10}^6$ 时，$type=1$。\n\n第二行 $n$ 个正整数，第 $i$ 个正整数表示 $a_i$，意义同题面描述。\n\n如果 $type = 1$，第三行四个正整数 $A, B, C, P$，表示询问的生成方式。\n\n```cpp\nint A, B, C, P;\ninline int rnd() { return A = (A * B + C) % P; }\n```\n\n每次询问时的调用方法为：\n\n```cpp\nl = rnd() % n + 1, r = rnd() % n + 1;\n```\n\n如果生成的 $l > r$，则还需要交换 $l, r$。\n\n数据保证 $0 \\le A B < P$，$0 \\le C < P$，$P (B + 1) < 2^{31} - 1$。\n\n如果 $type=0$，接下来 $q$ 行，每行两个正整数 $l, r$，意义同题面描述。", "outputFormat": "令 ${ans}_i$ 表示第 $i$ 次询问中 YSGH 是否会赢，如果会赢则 ${ans}_i = 1$，否则 ${ans}_i = 0$。\n\n输出一行一个整数，表示 $\\displaystyle \\left( \\sum_{i = 1}^{q} i^2 \\cdot {ans}_i \\right)\\! \\bmod 2^{32}$。", "hint": "对于 $25\\%$ 的数据，$n, m, q \\le 10$，$a_i \\le 2$。  \n对于 $55\\%$ 的数据，$n, m, q \\le 5 \\times {10}^3$。  \n另有 $15\\%$ 的数据，$n \\le {10}^5$，$m \\le 5$。  \n对于 $90\\%$ 的数据，$n, m, q \\le {10}^6$。  \n对于 $100\\%$ 的数据，$1 \\le n, m \\le {10}^6$，$1 \\le q \\le {10}^7$，$1 \\le a_i \\le {10}^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Basic Game Theory Practice Problem.", "background": "YSGH is our red sun.", "description": "YSGH and YGSH are playing “ge mo” (pinyin: gémó), and YSGS is watching.\n\nThe rules are as follows. First, a positive integer $m$ and a sequence $b$ of $n$ numbers are given. Initially, there is a piece on the first position of $b$, and $b_1$ is decreased by $1$. After that, the two players take turns. On each move, suppose the current piece is at position $i$. The player may move the piece to a position $j$ such that $j \\in [i, \\min(i + m, n)]$ and $b_j > 0$, then decrease $b_j$ by $1$. YSGH moves first. Whoever cannot make a move loses.\n\nIt is well known that both YSGH and YGSH are extremely smart, so both will use optimal strategies.\n\nThe sequence $b$ used in “ge mo” is a non-empty contiguous subsequence of a sequence $a$. Of course, both the sequence $a$ and the sequence $b$ used in each round are chosen by YSGS.\n\nNow they play $q$ rounds of the game. Given the interval used in each round, please determine who will win each round.", "inputFormat": "Because the data size of this problem is large, direct input and output will take much more time than computation. Therefore, when there are too many queries, the input and output of the queries are compressed.\n\nThe first line contains four positive integers $n, m, q, type$. The meanings of $n, m, q$ are the same as in the statement. $type$ indicates the type of the current testdata. $type = 1$ means this testdata is compressed, and $type = 0$ means it is not. The testdata guarantees that when $q > {10}^6$, $type = 1$.\n\nThe second line contains $n$ positive integers. The $i$-th positive integer represents $a_i$, with the same meaning as in the statement.\n\nIf $type = 1$, the third line contains four positive integers $A, B, C, P$, describing how queries are generated.\n\n```cpp\nint A, B, C, P;\ninline int rnd() { return A = (A * B + C) % P; }\n```\n\nFor each query, call:\n\n```cpp\nl = rnd() % n + 1, r = rnd() % n + 1;\n```\n\nIf the generated $l > r$, then you also need to swap $l, r$.\n\nThe testdata guarantees $0 \\le A B < P$, $0 \\le C < P$, $P (B + 1) < 2^{31} - 1$.\n\nIf $type = 0$, the next $q$ lines each contain two positive integers $l, r$, with the same meaning as in the statement.", "outputFormat": "Let ${ans}_i$ indicate whether YSGH will win in the $i$-th query. If YSGH will win, then ${ans}_i = 1$, otherwise ${ans}_i = 0$.\n\nOutput one line with one integer, which is $\\displaystyle \\left( \\sum_{i = 1}^{q} i^2 \\cdot {ans}_i \\right)\\! \\bmod 2^{32}$.", "hint": "For $25\\%$ of the testdata, $n, m, q \\le 10$, $a_i \\le 2$.  \nFor $55\\%$ of the testdata, $n, m, q \\le 5 \\times {10}^3$.  \nFor another $15\\%$ of the testdata, $n \\le {10}^5$, $m \\le 5$.  \nFor $90\\%$ of the testdata, $n, m, q \\le {10}^6$.  \nFor $100\\%$ of the testdata, $1 \\le n, m \\le {10}^6$, $1 \\le q \\le {10}^7$, $1 \\le a_i \\le {10}^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "基础博弈练习题", "background": "YSGH is our red sun.", "description": "YSGH 和 YGSH 在打膈膜，YSGS 在旁边围观。\n\n规则是这样的，先给定一个正整数 $m$ 和一个 $n$ 个数的序列 $b$，一开始有一个棋子在 $b$ 的第一个位置，并将 $b_1$ 减去 $1$。此后双方轮流操作，每次操作，假设当前棋子在 $i$，可以把棋子移到一个位置 $j$，满足 $j \\in [i, \\min(i + m, n)]$ 且 $b_j > 0$，然后将 $b_j$ 减 $1$，YSGH 先手，谁先不能操作谁输。\n\n众所周知，YSGH 和 YGSH 都是绝顶聪明的，所以两人都会使用最优策略。\n\n而隔膜使用的序列 $b$ 是一个序列 $a$ 的一个连续非空子序列，当然序列 $a$ 和每次隔膜使用的序列 $b$ 都是 YSGS 定的。\n\n现在他们进行了 $q$ 轮游戏，给出每轮游戏使用的区间，请你判断每轮谁会赢。", "inputFormat": "由于本题数据规模较大，直接输入输出会占用比计算多数倍的时间，因此当询问过多时会对询问的输入输出进行了压缩。\n\n第一行四个正整数 $n, m, q, type$，$n, m, q$ 意义同题面描述，$type$ 表示当前数据的类型，$type = 1$ 说明该组数据进行了压缩，$type = 0$ 则说明没有，数据保证当 $q > {10}^6$ 时，$type=1$。\n\n第二行 $n$ 个正整数，第 $i$ 个正整数表示 $a_i$，意义同题面描述。\n\n如果 $type = 1$，第三行四个正整数 $A, B, C, P$，表示询问的生成方式。\n\n```cpp\nint A, B, C, P;\ninline int rnd() { return A = (A * B + C) % P; }\n```\n\n每次询问时的调用方法为：\n\n```cpp\nl = rnd() % n + 1, r = rnd() % n + 1;\n```\n\n如果生成的 $l > r$，则还需要交换 $l, r$。\n\n数据保证 $0 \\le A B < P$，$0 \\le C < P$，$P (B + 1) < 2^{31} - 1$。\n\n如果 $type=0$，接下来 $q$ 行，每行两个正整数 $l, r$，意义同题面描述。", "outputFormat": "令 ${ans}_i$ 表示第 $i$ 次询问中 YSGH 是否会赢，如果会赢则 ${ans}_i = 1$，否则 ${ans}_i = 0$。\n\n输出一行一个整数，表示 $\\displaystyle \\left( \\sum_{i = 1}^{q} i^2 \\cdot {ans}_i \\right)\\! \\bmod 2^{32}$。", "hint": "对于 $25\\%$ 的数据，$n, m, q \\le 10$，$a_i \\le 2$。  \n对于 $55\\%$ 的数据，$n, m, q \\le 5 \\times {10}^3$。  \n另有 $15\\%$ 的数据，$n \\le {10}^5$，$m \\le 5$。  \n对于 $90\\%$ 的数据，$n, m, q \\le {10}^6$。  \n对于 $100\\%$ 的数据，$1 \\le n, m \\le {10}^6$，$1 \\le q \\le {10}^7$，$1 \\le a_i \\le {10}^9$。", "locale": "zh-CN"}}}
{"pid": "P5653", "type": "P", "difficulty": 5, "samples": [["5 1\n4 3 2 3 2\n5 7 -5 9 -10", "24"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["洛谷月赛"], "title": "基础最优化练习题", "background": "YSGH is our red sun.", "description": "YSGH 有一个数 $x$，初值为 $0$。接下来 $n$ 分钟，每分钟 YSGH 可以给 $x$ 加上整数 $y$，其中 $y \\in [-k, k]$，同时 YSGH 需要保证第 $i$ 分钟结束时 $x \\le a_i$。\n\n设 $b_i$ 为第 $i$ 分钟结束时 $x$ 的值，现在 YSGH 给你一个 $n$ 个数的序列 $w$，你需要最大化 $\\displaystyle \\sum_{i = 1}^{n} b_i w_i$。\n\n你只需要输出最大值即可。", "inputFormat": "第一行两个正整数 $n, k$，意义同题面描述。\n\n第二行共 $n$ 个整数，第 $i$ 个表示 $a_i$，意义同题面描述。\n\n第三行共 $n$ 个整数，第 $i$ 个表示 $w_i$，意义同题面描述。\n\n保证输入数据使得至少存在一个序列 $b$ 满足条件。", "outputFormat": "第一行一个整数，表示答案。", "hint": "对于 $10\\%$ 的数据，$n \\le 10$，$k \\le 1$。  \n对于 $20\\%$ 的数据，$n \\le 100$。  \n对于 $30\\%$ 的数据，$n \\le {10}^3$。  \n对于 $50\\%$ 的数据，$n \\le {10}^4$。  \n另有 $10\\%$ 的数据，$w_i \\ge 0$。  \n对于 $100\\%$ 的数据，$1 \\le n \\le {10}^6$，$-{10}^6 \\le w_i \\le {10}^6$，$0 \\le a_i \\le {10}^8$，$1 \\le k \\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "Basic Optimization Practice Problem.", "background": "YSGH is our red sun.", "description": "YSGH has a number $x$ with initial value $0$. For the next $n$ minutes, each minute YSGH can add an integer $y$ to $x$, where $y \\in [-k, k]$. At the same time, YSGH must ensure that at the end of the $i$-th minute, $x \\le a_i$.\n\nLet $b_i$ be the value of $x$ at the end of the $i$-th minute. Now YSGH gives you a sequence $w$ of $n$ numbers. You need to maximize $\\displaystyle \\sum_{i = 1}^{n} b_i w_i$.\n\nYou only need to output the maximum value.", "inputFormat": "The first line contains two positive integers $n, k$, with the same meaning as in the statement.\n\nThe second line contains $n$ integers, where the $i$-th integer is $a_i$, with the same meaning as in the statement.\n\nThe third line contains $n$ integers, where the $i$-th integer is $w_i$, with the same meaning as in the statement.\n\nIt is guaranteed that the input ensures there exists at least one sequence $b$ that satisfies the conditions.", "outputFormat": "The first line contains one integer, which is the answer.", "hint": "For $10\\%$ of the data, $n \\le 10$, $k \\le 1$.  \nFor $20\\%$ of the data, $n \\le 100$.  \nFor $30\\%$ of the data, $n \\le 10^3$.  \nFor $50\\%$ of the data, $n \\le 10^4$.  \nThere is another $10\\%$ of the data where $w_i \\ge 0$.  \nFor $100\\%$ of the data, $1 \\le n \\le 10^6$, $-10^6 \\le w_i \\le 10^6$, $0 \\le a_i \\le 10^8$, $1 \\le k \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "基础最优化练习题", "background": "YSGH is our red sun.", "description": "YSGH 有一个数 $x$，初值为 $0$。接下来 $n$ 分钟，每分钟 YSGH 可以给 $x$ 加上整数 $y$，其中 $y \\in [-k, k]$，同时 YSGH 需要保证第 $i$ 分钟结束时 $x \\le a_i$。\n\n设 $b_i$ 为第 $i$ 分钟结束时 $x$ 的值，现在 YSGH 给你一个 $n$ 个数的序列 $w$，你需要最大化 $\\displaystyle \\sum_{i = 1}^{n} b_i w_i$。\n\n你只需要输出最大值即可。", "inputFormat": "第一行两个正整数 $n, k$，意义同题面描述。\n\n第二行共 $n$ 个整数，第 $i$ 个表示 $a_i$，意义同题面描述。\n\n第三行共 $n$ 个整数，第 $i$ 个表示 $w_i$，意义同题面描述。\n\n保证输入数据使得至少存在一个序列 $b$ 满足条件。", "outputFormat": "第一行一个整数，表示答案。", "hint": "对于 $10\\%$ 的数据，$n \\le 10$，$k \\le 1$。  \n对于 $20\\%$ 的数据，$n \\le 100$。  \n对于 $30\\%$ 的数据，$n \\le {10}^3$。  \n对于 $50\\%$ 的数据，$n \\le {10}^4$。  \n另有 $10\\%$ 的数据，$w_i \\ge 0$。  \n对于 $100\\%$ 的数据，$1 \\le n \\le {10}^6$，$-{10}^6 \\le w_i \\le {10}^6$，$0 \\le a_i \\le {10}^8$，$1 \\le k \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P5654", "type": "P", "difficulty": 6, "samples": [["5 2\n2 1 5 3 4\n2 5 1 2 4\n3 5\n1 1", "7\n2"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["洛谷月赛"], "title": "基础函数练习题", "background": "YSGH is our red sun.\n", "description": "YSGH 有一个 $1 \\sim n$ 的排列 $p$ 和一个长度为 $n$ 的整数序列 $w$。\n\n定义：\n\n$$ F(l, r) = \\begin{cases} \\max(F(l, m - 1), F(m + 1, r)) + w_m & , l \\le r \\\\ 0 & , l > r \\end{cases} $$\n\n其中 $m$ 为 $p$ 的区间 $[l, r]$ 的最大值的下标。\n\n$q$ 次询问 $F(l, r)$ 的值。", "inputFormat": "第一行两个正整数 $n, q$，意义同题目描述。\n\n第二行共 $n$ 个正整数，第 $i$ 个表示 $p_i$，意义同题目描述。\n\n第三行共 $n$ 个整数，第 $i$ 个表示 $w_i$，意义同题目描述。\n\n接下来共 $q$ 行，每行两个正整数 $l, r$（$1 \\le l \\le r \\le n$），表示询问 $F(l,r)$。", "outputFormat": "输出共 $q$ 行，每行一个整数，表示答案。", "hint": "**本题采用捆绑测试。**\n\n- Subtask 1（10 points）：$n, q \\le 5 \\times {10}^3$。\n- Subtask 2（10 points）：保证 $p$ 是随机的。\n- Subtask 3（20 points）：$n ,q \\le 5 \\times {10}^4$。\n- Subtask 4（20 points）：$n, q \\le {10}^5$。\n- Subtask 5（20 points）：$w_i \\ge 0$。\n- Subtask 6（20 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le n, q \\le 5 \\times {10}^5$，$|w_i| \\le 10^9$，$1 \\le p_i \\le n$，保证 $p$ 是一个 $1 \\sim n$ 的排列。", "locale": "zh-CN", "translations": {"en": {"title": "Basic Function Practice Problem", "background": "YSGH is our red sun.", "description": "YSGH has a permutation $p$ of $1 \\sim n$ and an integer sequence $w$ of length $n$.\n\nDefine:\n\n$$ F(l, r) = \\begin{cases} \\max(F(l, m - 1), F(m + 1, r)) + w_m & , l \\le r \\\\ 0 & , l > r \\end{cases} $$\n\nwhere $m$ is the index of the maximum value of $p$ in the interval $[l, r]$.\n\nThere are $q$ queries asking for the value of $F(l, r)$.", "inputFormat": "The first line contains two positive integers $n, q$, with the same meaning as in the statement.\n\nThe second line contains $n$ positive integers. The $i$-th integer is $p_i$, with the same meaning as in the statement.\n\nThe third line contains $n$ integers. The $i$-th integer is $w_i$, with the same meaning as in the statement.\n\nThe next $q$ lines each contain two positive integers $l, r$ ($1 \\le l \\le r \\le n$), representing a query for $F(l, r)$.", "outputFormat": "Output $q$ lines. Each line contains one integer, which is the answer.", "hint": "**This problem uses bundled testdata.**\n\n- Subtask 1 (10 points): $n, q \\le 5 \\times {10}^3$.\n- Subtask 2 (10 points): It is guaranteed that $p$ is random.\n- Subtask 3 (20 points): $n, q \\le 5 \\times {10}^4$.\n- Subtask 4 (20 points): $n, q \\le {10}^5$.\n- Subtask 5 (20 points): $w_i \\ge 0$.\n- Subtask 6 (20 points): No special constraints.\n\nFor $100\\%$ of the data, $1 \\le n, q \\le 5 \\times {10}^5$, $|w_i| \\le 10^9$, $1 \\le p_i \\le n$. It is guaranteed that $p$ is a permutation of $1 \\sim n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "基础函数练习题", "background": "YSGH is our red sun.\n", "description": "YSGH 有一个 $1 \\sim n$ 的排列 $p$ 和一个长度为 $n$ 的整数序列 $w$。\n\n定义：\n\n$$ F(l, r) = \\begin{cases} \\max(F(l, m - 1), F(m + 1, r)) + w_m & , l \\le r \\\\ 0 & , l > r \\end{cases} $$\n\n其中 $m$ 为 $p$ 的区间 $[l, r]$ 的最大值的下标。\n\n$q$ 次询问 $F(l, r)$ 的值。", "inputFormat": "第一行两个正整数 $n, q$，意义同题目描述。\n\n第二行共 $n$ 个正整数，第 $i$ 个表示 $p_i$，意义同题目描述。\n\n第三行共 $n$ 个整数，第 $i$ 个表示 $w_i$，意义同题目描述。\n\n接下来共 $q$ 行，每行两个正整数 $l, r$（$1 \\le l \\le r \\le n$），表示询问 $F(l,r)$。", "outputFormat": "输出共 $q$ 行，每行一个整数，表示答案。", "hint": "**本题采用捆绑测试。**\n\n- Subtask 1（10 points）：$n, q \\le 5 \\times {10}^3$。\n- Subtask 2（10 points）：保证 $p$ 是随机的。\n- Subtask 3（20 points）：$n ,q \\le 5 \\times {10}^4$。\n- Subtask 4（20 points）：$n, q \\le {10}^5$。\n- Subtask 5（20 points）：$w_i \\ge 0$。\n- Subtask 6（20 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le n, q \\le 5 \\times {10}^5$，$|w_i| \\le 10^9$，$1 \\le p_i \\le n$，保证 $p$ 是一个 $1 \\sim n$ 的排列。", "locale": "zh-CN"}}}
{"pid": "P5655", "type": "P", "difficulty": 7, "samples": [["1\n3 3\n63\n70\n112\n1 2\n1 3\n2 3", "630\n5040\n560"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "O2优化", "洛谷月赛"], "title": "基础数论函数练习题", "background": "YSGH 牛逼", "description": "给定长度为 $n$ 的数组 $a$，$Q$ 次询问 $\\operatorname{lcm}(a_l, a_{l + 1}, \\ldots , a_{r - 1}, a_r)$。\n\n由于输出较大，你只需要输出答案对 ${10}^9 + 7$ 取模的值。", "inputFormat": "本题有多组数据。\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据，第一行两个正整数 $n, Q$。\n\n接下来 $n$ 行，第 $i$ 行一个正整数表示 $a_i$。\n\n接下来 $Q$ 行，一行两个正整数 $l,r$（$1 \\le l \\le r \\le n$），表示一次询问。", "outputFormat": "对于每次询问，一行一个整数表示答案。", "hint": "| 数据点编号 | $n, Q, T \\le$ | $a_i \\le$ |\n| :--: | :--: | :--: |\n| $1$ | $10$ | $10$ |\n| $2$ | $20$ | $2^{60}$ |\n| $3$ | $50$ | $2^{60}$ |\n| $4$ | $100$ | $2^{60}$ |\n| $5$ | $150$ | $2^{60}$ |\n| $6$ | $200$ | $2^{60}$ |\n| $7$ | $240$ | $2^{60}$ |\n| $8$ | $260$ | $2^{60}$ |\n| $9$ | $280$ | $2^{60}$ |\n| $10$ | $300$ | $2^{60}$ |\n\n对于 $100\\%$ 的数据，$1 \\le n, Q, T \\le 300$，$1 \\le a_i \\le 2^{60}$。", "locale": "zh-CN", "translations": {"en": {"title": "Basic Number Theory Function Practice Problem.", "background": "YSGH is awesome.", "description": "Given an array $a$ of length $n$, answer $Q$ queries of $\\operatorname{lcm}(a_l, a_{l + 1}, \\ldots , a_{r - 1}, a_r)$.\n\nSince the output can be large, you only need to output the answer modulo ${10}^9 + 7$.", "inputFormat": "This problem contains multiple test cases.\n\nThe first line contains a positive integer $T$, indicating the number of test cases.\n\nFor each test case, the first line contains two positive integers $n, Q$.\n\nIn the next $n$ lines, the $i$-th line contains a positive integer $a_i$.\n\nIn the next $Q$ lines, each line contains two positive integers $l, r$ ($1 \\le l \\le r \\le n$), representing one query.", "outputFormat": "For each query, output one integer per line, representing the answer.", "hint": "| Test Point ID | $n, Q, T \\le$ | $a_i \\le$ |\n| :--: | :--: | :--: |\n| $1$ | $10$ | $10$ |\n| $2$ | $20$ | $2^{60}$ |\n| $3$ | $50$ | $2^{60}$ |\n| $4$ | $100$ | $2^{60}$ |\n| $5$ | $150$ | $2^{60}$ |\n| $6$ | $200$ | $2^{60}$ |\n| $7$ | $240$ | $2^{60}$ |\n| $8$ | $260$ | $2^{60}$ |\n| $9$ | $280$ | $2^{60}$ |\n| $10$ | $300$ | $2^{60}$ |\n\nFor $100\\%$ of the testdata, $1 \\le n, Q, T \\le 300$, $1 \\le a_i \\le 2^{60}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "基础数论函数练习题", "background": "YSGH 牛逼", "description": "给定长度为 $n$ 的数组 $a$，$Q$ 次询问 $\\operatorname{lcm}(a_l, a_{l + 1}, \\ldots , a_{r - 1}, a_r)$。\n\n由于输出较大，你只需要输出答案对 ${10}^9 + 7$ 取模的值。", "inputFormat": "本题有多组数据。\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据，第一行两个正整数 $n, Q$。\n\n接下来 $n$ 行，第 $i$ 行一个正整数表示 $a_i$。\n\n接下来 $Q$ 行，一行两个正整数 $l,r$（$1 \\le l \\le r \\le n$），表示一次询问。", "outputFormat": "对于每次询问，一行一个整数表示答案。", "hint": "| 数据点编号 | $n, Q, T \\le$ | $a_i \\le$ |\n| :--: | :--: | :--: |\n| $1$ | $10$ | $10$ |\n| $2$ | $20$ | $2^{60}$ |\n| $3$ | $50$ | $2^{60}$ |\n| $4$ | $100$ | $2^{60}$ |\n| $5$ | $150$ | $2^{60}$ |\n| $6$ | $200$ | $2^{60}$ |\n| $7$ | $240$ | $2^{60}$ |\n| $8$ | $260$ | $2^{60}$ |\n| $9$ | $280$ | $2^{60}$ |\n| $10$ | $300$ | $2^{60}$ |\n\n对于 $100\\%$ 的数据，$1 \\le n, Q, T \\le 300$，$1 \\le a_i \\le 2^{60}$。", "locale": "zh-CN"}}}
{"pid": "P5656", "type": "P", "difficulty": 5, "samples": [["7\n2 11 100\n3 18 6\n192 608 17\n19 2 60817\n11 45 14\n19 19 810\n98 76 5432", "4 6 2 39 8\n2 1\n-1\n1600 1 18 3199 30399\n34 3\n-1\n2 12 7 50 56"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384, 16384]}, "tags": ["数学", "最大公约数 gcd", "扩展欧几里德算法", "模板题"], "title": "【模板】二元一次不定方程 (exgcd)", "background": "", "description": "给定不定方程\n\n$$ax+by=c$$\n\n若该方程无整数解，输出 $-1$。  \n若该方程有整数解，且有正整数解，则输出其**正整数**解的数量，所有**正整数**解中 $x$ 的最小值，所有**正整数**解中 $y$ 的最小值，所有**正整数**解中 $x$ 的最大值，以及所有**正整数**解中 $y$ 的最大值。  \n若方程有整数解，但没有正整数解，你需要输出所有**整数解**中 $x$ 的最小正整数值， $y$ 的最小正整数值。\n\n正整数解即为 $x, y$ 均为正整数的解，$\\boldsymbol{0}$ **不是正整数**。  \n整数解即为 $x,y$ 均为整数的解。  \n$x$ 的最小正整数值即所有 $x$ 为正整数的整数解中 $x$ 的最小值，$y$ 同理。", "inputFormat": "第一行一个正整数 $T$，代表数据组数。\n\n接下来 $T$ 行，每行三个由空格隔开的正整数 $a, b, c$。", "outputFormat": "$T$ 行。\n\n若该行对应的询问无整数解，一个数字 $-1$。  \n若该行对应的询问有整数解但无正整数解，包含 $2$ 个由空格隔开的数字，依次代表整数解中，$x$ 的最小正整数值，$y$ 的最小正整数值。  \n否则包含 $5$ 个由空格隔开的数字，依次代表正整数解的数量，正整数解中，$x$ 的最小值，$y$ 的最小值，$x$ 的最大值，$y$ 的最大值。\n\n**读入输出量较大，注意使用较快的读入输出方式**", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 2 \\times {10}^5$，$1 \\le a, b, c \\le {10}^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Binary Linear Diophantine Equation (exgcd)", "background": "", "description": "Given the indeterminate equation\n\n$$ax+by=c$$\n\nIf this equation has no integer solution, output $-1$.  \nIf this equation has integer solutions and also has positive integer solutions, output: the number of **positive integer** solutions, the minimum value of $x$ among all **positive integer** solutions, the minimum value of $y$ among all **positive integer** solutions, the maximum value of $x$ among all **positive integer** solutions, and the maximum value of $y$ among all **positive integer** solutions.  \nIf the equation has integer solutions but has no positive integer solution, you need to output: the minimum positive integer value of $x$ among all **integer solutions**, and the minimum positive integer value of $y$ among all **integer solutions**.\n\nA positive integer solution means a solution where both $x$ and $y$ are positive integers, and $\\boldsymbol{0}$ **is not a positive integer**.  \nAn integer solution means a solution where both $x$ and $y$ are integers.  \nThe minimum positive integer value of $x$ means the minimum value of $x$ among all integer solutions with $x$ being a positive integer, and similarly for $y$.", "inputFormat": "The first line contains a positive integer $T$, representing the number of test cases.\n\nThe next $T$ lines each contain three positive integers $a, b, c$ separated by spaces.", "outputFormat": "Output $T$ lines.\n\nIf the corresponding query has no integer solution, output a single number $-1$.  \nIf the corresponding query has integer solutions but no positive integer solution, output $2$ numbers separated by spaces, representing the minimum positive integer value of $x$ and the minimum positive integer value of $y$ among integer solutions, in order.  \nOtherwise, output $5$ numbers separated by spaces, representing the number of positive integer solutions, the minimum $x$, the minimum $y$, the maximum $x$, and the maximum $y$ among positive integer solutions, in order.\n\nThe input and output sizes are large, so please use fast I/O methods.", "hint": "**Constraints**\n\nFor $100\\%$ of the testdata, $1 \\le T \\le 2 \\times {10}^5$, $1 \\le a, b, c \\le {10}^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】二元一次不定方程 (exgcd)", "background": "", "description": "给定不定方程\n\n$$ax+by=c$$\n\n若该方程无整数解，输出 $-1$。  \n若该方程有整数解，且有正整数解，则输出其**正整数**解的数量，所有**正整数**解中 $x$ 的最小值，所有**正整数**解中 $y$ 的最小值，所有**正整数**解中 $x$ 的最大值，以及所有**正整数**解中 $y$ 的最大值。  \n若方程有整数解，但没有正整数解，你需要输出所有**整数解**中 $x$ 的最小正整数值， $y$ 的最小正整数值。\n\n正整数解即为 $x, y$ 均为正整数的解，$\\boldsymbol{0}$ **不是正整数**。  \n整数解即为 $x,y$ 均为整数的解。  \n$x$ 的最小正整数值即所有 $x$ 为正整数的整数解中 $x$ 的最小值，$y$ 同理。", "inputFormat": "第一行一个正整数 $T$，代表数据组数。\n\n接下来 $T$ 行，每行三个由空格隔开的正整数 $a, b, c$。", "outputFormat": "$T$ 行。\n\n若该行对应的询问无整数解，一个数字 $-1$。  \n若该行对应的询问有整数解但无正整数解，包含 $2$ 个由空格隔开的数字，依次代表整数解中，$x$ 的最小正整数值，$y$ 的最小正整数值。  \n否则包含 $5$ 个由空格隔开的数字，依次代表正整数解的数量，正整数解中，$x$ 的最小值，$y$ 的最小值，$x$ 的最大值，$y$ 的最大值。\n\n**读入输出量较大，注意使用较快的读入输出方式**", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 2 \\times {10}^5$，$1 \\le a, b, c \\le {10}^9$。", "locale": "zh-CN"}}}
{"pid": "P5657", "type": "P", "difficulty": 2, "samples": [["2 3", "10"], ["3 5", "111"], ["44 1145141919810", "00011000111111010000001001001000000001100011"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["数学", "2019", "递归", "CSP-S 提高级"], "title": "[CSP-S 2019] 格雷码", "background": "", "description": "通常，人们习惯将所有 $n$ 位二进制串按照字典序排列，例如所有 2 位二进制串按字典序从小到大排列为：00，01，10，11。\n\n格雷码（Gray Code）是一种特殊的 $n$ 位二进制串排列法，它要求相邻的两个二进制串间**恰好**有一位**不同**，特别地，第一个串与最后一个串也算作相邻。\n\n所有 2 位二进制串按格雷码排列的一个例子为：00，01，11，10。\n\n$n$ 位格雷码不止一种，下面给出其中一种格雷码的生成算法：\n1. 1 位格雷码由两个 1 位二进制串组成，顺序为：0，1。\n2. $n + 1$ 位格雷码的前 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**顺序**排列，再在每个串前加一个前缀 0 构成。\n3. $n + 1$ 位格雷码的后 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**逆序**排列，再在每个串前加一个前缀 1 构成。\n\n综上，$n + 1$ 位格雷码，由 $n$ 位格雷码的 $2^n$ 个二进制串按顺序排列再加前缀 0，和按逆序排列再加前缀 1 构成，共 $2^{n+1}$ 个二进制串。另外，对于 $n$ 位格雷码中的 $2^n$ 个 二进制串，我们按上述算法得到的排列顺序将它们从 $0 \\sim 2^n - 1$ 编号。\n\n按该算法，2 位格雷码可以这样推出：\n\n1. 已知 1 位格雷码为 0，1。\n2. 前两个格雷码为 00，01。后两个格雷码为 11，10。合并得到 00，01，11，10，编号依次为 0 ~ 3。\n\n同理，3 位格雷码可以这样推出：\n\n1. 已知 2 位格雷码为：00，01，11，10。\n2. 前四个格雷码为：000，001，011，010。后四个格雷码为：110，111，101，100。合并得到：000，001，011，010，110，111，101，100，编号依次为 0 ~ 7。\n\n现在给出 $n$，$k$，请你求出按上述算法生成的 $n$ 位格雷码中的 $k$ 号二进制串。\n", "inputFormat": "仅一行两个整数 $n$，$k$，意义见题目描述。", "outputFormat": "仅一行一个 $n$ 位二进制串表示答案。", "hint": "【样例 1 解释】\n\n2 位格雷码为：00，01，11，10，编号从 0∼3，因此 3 号串是 10。\n\n【样例 2 解释】\n\n3 位格雷码为：000，001，011，010，110，111，101，100，编号从 0∼7，因此 5 号串是 111。\n\n【数据范围】\n\n对于 $50\\%$ 的数据：$n \\leq 10$\n\n对于 $80\\%$ 的数据：$k \\leq 5 \\times 10^6$\n\n对于 $95\\%$ 的数据：$k \\leq 2^{63} - 1$\n\n对于 $100\\%$ 的数据：$1 \\leq n \\leq 64$, $0 \\leq k \\lt 2^n$", "locale": "zh-CN", "translations": {"en": {"title": "[CSP-S 2019] Gray Code", "background": "", "description": "Usually, people are used to arranging all $n$-bit binary strings in lexicographical order. For example, all 2-bit binary strings in increasing lexicographical order are: 00, 01, 10, 11.\n\nGray Code is a special way to arrange $n$-bit binary strings. It requires that any two adjacent binary strings differ in **exactly** one bit. In particular, the first string and the last string are also considered adjacent.\n\nAn example of arranging all 2-bit binary strings in Gray Code order is: 00, 01, 11, 10.\n\nThere is more than one $n$-bit Gray Code. Below is one algorithm to generate a Gray Code:\n1. The 1-bit Gray Code consists of two 1-bit binary strings, in the order: 0, 1.\n2. The first $2^n$ binary strings of the $(n + 1)$-bit Gray Code can be formed by taking the $n$-bit Gray Code generated by this algorithm (a total of $2^n$ $n$-bit binary strings) in **order**, and adding a prefix 0 to each string.\n3. The last $2^n$ binary strings of the $(n + 1)$-bit Gray Code can be formed by taking the $n$-bit Gray Code generated by this algorithm (a total of $2^n$ $n$-bit binary strings) in **reverse order**, and adding a prefix 1 to each string.\n\nIn summary, the $(n + 1)$-bit Gray Code consists of the $2^n$ strings of the $n$-bit Gray Code in order with prefix 0, and the $2^n$ strings of the $n$-bit Gray Code in reverse order with prefix 1, making a total of $2^{n+1}$ binary strings. Also, for the $2^n$ binary strings in the $n$-bit Gray Code, we number them as $0 \\sim 2^n - 1$ according to the order produced by the above algorithm.\n\nWith this algorithm, the 2-bit Gray Code can be derived as follows:\n\n1. The 1-bit Gray Code is 0, 1.\n2. The first two Gray codes are 00, 01. The last two Gray codes are 11, 10. Merging them gives 00, 01, 11, 10, numbered from 0 to 3 in order.\n\nSimilarly, the 3-bit Gray Code can be derived as follows:\n\n1. The 2-bit Gray Code is: 00, 01, 11, 10.\n2. The first four Gray codes are: 000, 001, 011, 010. The last four Gray codes are: 110, 111, 101, 100. Merging them gives: 000, 001, 011, 010, 110, 111, 101, 100, numbered from 0 to 7 in order.\n\nNow you are given $n$ and $k$. Please find the $k$-th binary string in the $n$-bit Gray Code generated by the above algorithm.", "inputFormat": "A single line with two integers $n$ and $k$, as described in the statement.", "outputFormat": "A single line with an $n$-bit binary string representing the answer.", "hint": "[Sample 1 Explanation]\n\nThe 2-bit Gray Code is: 00, 01, 11, 10, numbered from $0 \\sim 3$, so string number 3 is 10.\n\n[Sample 2 Explanation]\n\nThe 3-bit Gray Code is: 000, 001, 011, 010, 110, 111, 101, 100, numbered from $0 \\sim 7$, so string number 5 is 111.\n\n[Constraints]\n\nFor $50\\%$ of the testdata: $n \\leq 10$.\n\nFor $80\\%$ of the testdata: $k \\leq 5 \\times 10^6$.\n\nFor $95\\%$ of the testdata: $k \\leq 2^{63} - 1$.\n\nFor $100\\%$ of the testdata: $1 \\leq n \\leq 64$, $0 \\leq k \\lt 2^n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSP-S 2019] 格雷码", "background": "", "description": "通常，人们习惯将所有 $n$ 位二进制串按照字典序排列，例如所有 2 位二进制串按字典序从小到大排列为：00，01，10，11。\n\n格雷码（Gray Code）是一种特殊的 $n$ 位二进制串排列法，它要求相邻的两个二进制串间**恰好**有一位**不同**，特别地，第一个串与最后一个串也算作相邻。\n\n所有 2 位二进制串按格雷码排列的一个例子为：00，01，11，10。\n\n$n$ 位格雷码不止一种，下面给出其中一种格雷码的生成算法：\n1. 1 位格雷码由两个 1 位二进制串组成，顺序为：0，1。\n2. $n + 1$ 位格雷码的前 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**顺序**排列，再在每个串前加一个前缀 0 构成。\n3. $n + 1$ 位格雷码的后 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**逆序**排列，再在每个串前加一个前缀 1 构成。\n\n综上，$n + 1$ 位格雷码，由 $n$ 位格雷码的 $2^n$ 个二进制串按顺序排列再加前缀 0，和按逆序排列再加前缀 1 构成，共 $2^{n+1}$ 个二进制串。另外，对于 $n$ 位格雷码中的 $2^n$ 个 二进制串，我们按上述算法得到的排列顺序将它们从 $0 \\sim 2^n - 1$ 编号。\n\n按该算法，2 位格雷码可以这样推出：\n\n1. 已知 1 位格雷码为 0，1。\n2. 前两个格雷码为 00，01。后两个格雷码为 11，10。合并得到 00，01，11，10，编号依次为 0 ~ 3。\n\n同理，3 位格雷码可以这样推出：\n\n1. 已知 2 位格雷码为：00，01，11，10。\n2. 前四个格雷码为：000，001，011，010。后四个格雷码为：110，111，101，100。合并得到：000，001，011，010，110，111，101，100，编号依次为 0 ~ 7。\n\n现在给出 $n$，$k$，请你求出按上述算法生成的 $n$ 位格雷码中的 $k$ 号二进制串。\n", "inputFormat": "仅一行两个整数 $n$，$k$，意义见题目描述。", "outputFormat": "仅一行一个 $n$ 位二进制串表示答案。", "hint": "【样例 1 解释】\n\n2 位格雷码为：00，01，11，10，编号从 0∼3，因此 3 号串是 10。\n\n【样例 2 解释】\n\n3 位格雷码为：000，001，011，010，110，111，101，100，编号从 0∼7，因此 5 号串是 111。\n\n【数据范围】\n\n对于 $50\\%$ 的数据：$n \\leq 10$\n\n对于 $80\\%$ 的数据：$k \\leq 5 \\times 10^6$\n\n对于 $95\\%$ 的数据：$k \\leq 2^{63} - 1$\n\n对于 $100\\%$ 的数据：$1 \\leq n \\leq 64$, $0 \\leq k \\lt 2^n$", "locale": "zh-CN"}}}
{"pid": "P5658", "type": "P", "difficulty": 4, "samples": [["5\n(()()\n1 1 2 2", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["树形数据结构", "2019", "树论", "栈", "CSP-S 提高级"], "title": "[CSP-S 2019] 括号树", "background": "本题中**合法括号串**的定义如下：\n1.\t`()` 是合法括号串。\n2.\t如果 `A` 是合法括号串，则 `(A)` 是合法括号串。\n3.\t如果 `A`，`B` 是合法括号串，则 `AB` 是合法括号串。\n\n本题中**子串**与**不同的子串**的定义如下：\n1.\t字符串 `S` 的子串是 `S` 中**连续**的任意个字符组成的字符串。`S` 的子串可用起始位置 $l$ 与终止位置 $r$ 来表示，记为 $S (l, r)$（$1 \\leq l \\leq r \\leq |S |$，$|S |$ 表示 S 的长度）。\n2.\t`S` 的两个子串视作不同**当且仅当**它们在 `S` 中的位置不同，即 $l$ 不同或 $r$ 不同。", "description": "一个大小为 $n$ 的树包含 $n$ 个结点和 $n - 1$ 条边，每条边连接两个结点，且任意两个结点间**有且仅有**一条简单路径互相可达。\n\n小 Q 是一个充满好奇心的小朋友，有一天他在上学的路上碰见了一个大小为 $n$ 的树，树上结点从 $1 \\sim n$ 编号，$1$ 号结点为树的根。除 $1$ 号结点外，每个结点有一个父亲结点，$u$（$2 \\leq u \\leq n$）号结点的父亲为 $f_u$（$1 ≤ f_u < u$）号结点。\n\n小 Q 发现这个树的每个结点上**恰有**一个括号，可能是`(` 或`)`。小 Q 定义 $s_i$ 为：将根结点到 $i$ 号结点的简单路径上的括号，按结点经过顺序依次排列组成的字符串。\n \n显然 $s_i$ 是个括号串，但不一定是合法括号串，因此现在小 Q 想对所有的 $i$（$1\\leq i\\leq n$）求出，$s_i$ 中有多少个**互不相同的子串**是**合法括号串**。\n \n这个问题难倒了小 Q，他只好向你求助。设 $s_i$ 共有 $k_i$ 个不同子串是合法括号串， 你只需要告诉小 Q 所有 $i \\times k_i$ 的异或和，即：\n$$ (1 \\times k_1)\\ \\text{xor}\\ (2 \\times k_2)\\ \\text{xor}\\ (3 \\times k_3)\\ \\text{xor}\\ \\cdots\\ \\text{xor}\\ (n \\times k_n) $$\n其中 $\\text{xor}$ 是位异或运算。", "inputFormat": "第一行一个整数 $n$，表示树的大小。\n\n第二行一个长为 $n$ 的由`(` 与`)` 组成的括号串，第 $i$ 个括号表示 $i$ 号结点上的括号。\n\n第三行包含 $n − 1$ 个整数，第 $i$（$1 \\leq i \\lt n$）个整数表示 $i + 1$ 号结点的父亲编号 $f_{i+1}$。", "outputFormat": "仅一行一个整数表示答案。", "hint": "**【样例 1 解释】**\n\n树的形态如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/10z2scex.png)\n\n将根到 1 号结点的简单路径上的括号，按经过顺序排列所组成的字符串为 `(`，子串是合法括号串的个数为 $0$。\n\n将根到 2 号结点的字符串为 `((`，子串是合法括号串的个数为 $0$。\n\n将根到 3 号结点的字符串为 `()`，子串是合法括号串的个数为 $1$。\n\n将根到 4 号结点的字符串为 `(((`，子串是合法括号串的个数为 $0$。\n\n将根到 5 号结点的字符串为 `(()`，子串是合法括号串的个数为 $1$。\n\n**【样例 2】**\n\n见选手目录下的 brackets/brackets2.in 与 brackets/brackets2.ans。\n\n**【数据范围】**\n\n::cute-table{tuack}\n\n| 测试点编号 | $n\\le$ | 特殊性质 |\n|:-:|:-:|:-:|\n| $1\\sim 2$ | $8$ | $f_i=i-1$ |\n| $3\\sim 4$ | $200$ | ^ |\n| $5\\sim 7$ | $2000$ | ^ |\n| $8\\sim 10$ | ^ | 无 |\n| $11\\sim 14$ | $10^5$ | $f_i=i-1$ |\n| $15\\sim 16$ | ^ | 无 |\n| $17\\sim 20$ | $5\\times 10^5$ | ^ |", "locale": "zh-CN", "translations": {"en": {"title": "[CSP-S 2019] Bracket Tree", "background": "In this problem, a **valid bracket sequence** is defined as follows:\n1. `()` is a valid bracket sequence.\n2. If `A` is a valid bracket sequence, then `(A)` is a valid bracket sequence.\n3. If `A` and `B` are valid bracket sequences, then `AB` is a valid bracket sequence.\n\nIn this problem, the definitions of a **substring** and **distinct substrings** are as follows:\n1. A substring of a string `S` is a string formed by any **continuous** characters in `S`. A substring of `S` can be represented by the starting position $l$ and the ending position $r$, denoted as $S (l, r)$ ($1 \\leq l \\leq r \\leq |S |$, where $|S |$ denotes the length of `S`).\n2. Two substrings of `S` are considered different **if and only if** their positions in `S` are different, i.e. $l$ is different or $r$ is different.", "description": "A tree of size $n$ contains $n$ nodes and $n - 1$ edges. Each edge connects two nodes, and between any two nodes there exists **exactly one** simple path.\n\nXiao Q is a curious kid. One day on his way to school, he encountered a tree of size $n$. The nodes of the tree are numbered from $1 \\sim n$, and node $1$ is the root. Except for node $1$, every node has a parent node. The parent of node $u$ ($2 \\leq u \\leq n$) is node $f_u$ ($1 \\le f_u < u$).\n\nXiao Q found that each node of the tree has **exactly** one bracket, either `(` or `)`. Xiao Q defines $s_i$ as follows: take the brackets on the simple path from the root to node $i$, and arrange them into a string in the order the nodes are visited.\n\nObviously, $s_i$ is a bracket string, but it is not necessarily a valid bracket sequence. Now Xiao Q wants, for all $i$ ($1 \\leq i \\leq n$), to find how many **distinct substrings** of $s_i$ are **valid bracket sequences**.\n\nThis problem stumped Xiao Q, so he asks you for help. Suppose $s_i$ has $k_i$ distinct substrings that are valid bracket sequences. You only need to tell Xiao Q the XOR sum of all $i \\times k_i$, namely:\n$$ (1 \\times k_1)\\ \\text{xor}\\ (2 \\times k_2)\\ \\text{xor}\\ (3 \\times k_3)\\ \\text{xor}\\ \\cdots\\ \\text{xor}\\ (n \\times k_n) $$\nwhere $\\text{xor}$ is the bitwise XOR operation.", "inputFormat": "The first line contains an integer $n$, denoting the size of the tree.\n\nThe second line contains a bracket string of length $n$ consisting of `(` and `)`. The $i$-th bracket denotes the bracket on node $i$.\n\nThe third line contains $n − 1$ integers. The $i$-th integer ($1 \\leq i \\lt n$) denotes the parent index $f_{i+1}$ of node $i + 1$.", "outputFormat": "Only one line containing one integer, denoting the answer.", "hint": "**[Sample 1 Explanation]**\n\nThe shape of the tree is shown in the figure below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/10z2scex.png)\n\nThe string formed by the brackets on the simple path from the root to node 1, arranged in order, is `(`, and the number of substrings that are valid bracket sequences is $0$.\n\nThe string from the root to node 2 is `((`, and the number of substrings that are valid bracket sequences is $0$.\n\nThe string from the root to node 3 is `()`, and the number of substrings that are valid bracket sequences is $1$.\n\nThe string from the root to node 4 is `(((`, and the number of substrings that are valid bracket sequences is $0$.\n\nThe string from the root to node 5 is `(()`, and the number of substrings that are valid bracket sequences is $1$.\n\n**[Sample 2]**\n\nSee `brackets/brackets2.in` and `brackets/brackets2.ans` under the contestant directory.\n\n**[Constraints]**\n\n::cute-table{tuack}\n\n| Test Point ID | $n\\le$ | Special Property |\n|:-:|:-:|:-:|\n| $1\\sim 2$ | $8$ | $f_i=i-1$ |\n| $3\\sim 4$ | $200$ | ^ |\n| $5\\sim 7$ | $2000$ | ^ |\n| $8\\sim 10$ | ^ | None |\n| $11\\sim 14$ | $10^5$ | $f_i=i-1$ |\n| $15\\sim 16$ | ^ | None |\n| $17\\sim 20$ | $5\\times 10^5$ | ^ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSP-S 2019] 括号树", "background": "本题中**合法括号串**的定义如下：\n1.\t`()` 是合法括号串。\n2.\t如果 `A` 是合法括号串，则 `(A)` 是合法括号串。\n3.\t如果 `A`，`B` 是合法括号串，则 `AB` 是合法括号串。\n\n本题中**子串**与**不同的子串**的定义如下：\n1.\t字符串 `S` 的子串是 `S` 中**连续**的任意个字符组成的字符串。`S` 的子串可用起始位置 $l$ 与终止位置 $r$ 来表示，记为 $S (l, r)$（$1 \\leq l \\leq r \\leq |S |$，$|S |$ 表示 S 的长度）。\n2.\t`S` 的两个子串视作不同**当且仅当**它们在 `S` 中的位置不同，即 $l$ 不同或 $r$ 不同。", "description": "一个大小为 $n$ 的树包含 $n$ 个结点和 $n - 1$ 条边，每条边连接两个结点，且任意两个结点间**有且仅有**一条简单路径互相可达。\n\n小 Q 是一个充满好奇心的小朋友，有一天他在上学的路上碰见了一个大小为 $n$ 的树，树上结点从 $1 \\sim n$ 编号，$1$ 号结点为树的根。除 $1$ 号结点外，每个结点有一个父亲结点，$u$（$2 \\leq u \\leq n$）号结点的父亲为 $f_u$（$1 ≤ f_u < u$）号结点。\n\n小 Q 发现这个树的每个结点上**恰有**一个括号，可能是`(` 或`)`。小 Q 定义 $s_i$ 为：将根结点到 $i$ 号结点的简单路径上的括号，按结点经过顺序依次排列组成的字符串。\n \n显然 $s_i$ 是个括号串，但不一定是合法括号串，因此现在小 Q 想对所有的 $i$（$1\\leq i\\leq n$）求出，$s_i$ 中有多少个**互不相同的子串**是**合法括号串**。\n \n这个问题难倒了小 Q，他只好向你求助。设 $s_i$ 共有 $k_i$ 个不同子串是合法括号串， 你只需要告诉小 Q 所有 $i \\times k_i$ 的异或和，即：\n$$ (1 \\times k_1)\\ \\text{xor}\\ (2 \\times k_2)\\ \\text{xor}\\ (3 \\times k_3)\\ \\text{xor}\\ \\cdots\\ \\text{xor}\\ (n \\times k_n) $$\n其中 $\\text{xor}$ 是位异或运算。", "inputFormat": "第一行一个整数 $n$，表示树的大小。\n\n第二行一个长为 $n$ 的由`(` 与`)` 组成的括号串，第 $i$ 个括号表示 $i$ 号结点上的括号。\n\n第三行包含 $n − 1$ 个整数，第 $i$（$1 \\leq i \\lt n$）个整数表示 $i + 1$ 号结点的父亲编号 $f_{i+1}$。", "outputFormat": "仅一行一个整数表示答案。", "hint": "**【样例 1 解释】**\n\n树的形态如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/10z2scex.png)\n\n将根到 1 号结点的简单路径上的括号，按经过顺序排列所组成的字符串为 `(`，子串是合法括号串的个数为 $0$。\n\n将根到 2 号结点的字符串为 `((`，子串是合法括号串的个数为 $0$。\n\n将根到 3 号结点的字符串为 `()`，子串是合法括号串的个数为 $1$。\n\n将根到 4 号结点的字符串为 `(((`，子串是合法括号串的个数为 $0$。\n\n将根到 5 号结点的字符串为 `(()`，子串是合法括号串的个数为 $1$。\n\n**【样例 2】**\n\n见选手目录下的 brackets/brackets2.in 与 brackets/brackets2.ans。\n\n**【数据范围】**\n\n::cute-table{tuack}\n\n| 测试点编号 | $n\\le$ | 特殊性质 |\n|:-:|:-:|:-:|\n| $1\\sim 2$ | $8$ | $f_i=i-1$ |\n| $3\\sim 4$ | $200$ | ^ |\n| $5\\sim 7$ | $2000$ | ^ |\n| $8\\sim 10$ | ^ | 无 |\n| $11\\sim 14$ | $10^5$ | $f_i=i-1$ |\n| $15\\sim 16$ | ^ | 无 |\n| $17\\sim 20$ | $5\\times 10^5$ | ^ |", "locale": "zh-CN"}}}
{"pid": "P5659", "type": "P", "difficulty": 7, "samples": [["4\n5\n2 1 3 5 4\n1 3\n1 4\n2 4\n4 5\n5\n3 4 2 1 5\n1 2\n2 3\n3 4\n4 5\n5\n1 2 5 3 4\n1 2\n1 3\n1 4\n1 5\n10\n1 2 3 4 5 7 8 9 10 6\n1 2\n1 3\n1 4\n1 5\n5 6\n6 7\n7 8\n8 9\n9 10", "1 3 4 2 5\n1 3 5 2 4\n2 3 1 4 5\n2 3 4 5 6 1 7 8 9 10"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["树形数据结构", "2019", "CSP-S 提高级"], "title": "[CSP-S 2019] 树上的数", "background": null, "description": "给定一个大小为 $n$ 的树，它共有 $n$ 个结点与 $n - 1$ 条边，结点从 $1 \\sim n$ 编号。初始时每个结点上都有一个 $1 \\sim n$ 的数字，且每个 $1 \\sim n$ 的数字都只在**恰好**一个结点上出现。\n\n接下来你需要进行**恰好** $n - 1$ 次删边操作，每次操作你需要选一条**未被删去**的边，此时这条边所连接的两个结点上的数字将会**交换**，然后这条边将被删去。\n\n$n - 1$ 次操作过后，所有的边都将被删去。此时，按数字从小到大的顺序，将数字 $1 \\sim n$ 所在的结点编号依次排列，就得到一个结点编号的排列 $P_i$。现在请你求出，在最优操作方案下能得到的**字典序最小**的 $P_i$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/flbxosct.png)\n\n如上图，蓝圈中的数字 $1 \\sim 5$ 一开始分别在结点②、①、③、⑤、④。按照 (1)(4)(3)(2) 的顺序删去所有边，树变为下图。按数字顺序得到的结点编号排列为①③④②⑤，该排列是所有可能的结果中字典序最小的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tu338qm9.png)", "inputFormat": "**本题输入包含多组测试数据。**\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组测试数据：\n\n第一行一个整数 $n$，表示树的大小。\n\n第二行 $n$ 个整数，第 $i (1 \\leq i \\leq n)$ 个整数表示数字 $i$ 初始时所在的结点编号。\n\n接下来 $n - 1$ 行每行两个整数 $x$, $y$，表示一条连接 $x$ 号结点与 $y$ 号结点的边。", "outputFormat": "对于每组测试数据，输出一行共 $n$ 个用空格隔开的整数，表示最优操作方案下所能得到的字典序最小的 $P_i$。", "hint": "【数据范围】\n\n| 测试点编号 | $n \\leq$ | 特殊性质 |\n| :----------- | :----------- | :----------- |\n| $1 \\sim 2$ | $10$ | 无 |\n| $3 \\sim 4$ | $160$ | 树的形态是一条链 |\n| $5 \\sim 7$ | $2000$ | 同上 |\n| $8 \\sim 9$ | $160$ | 存在度数为 $n - 1$ 的结点 |\n| $10 \\sim 12$ | $2000$ | 同上 |\n| $13 \\sim 16$ | $160$ | 无 |\n| $17 \\sim 20$ | $2000$ | 无 |\n\n对于所有测试点：$1 \\leq T \\leq 10$，保证给出的是一个树。", "locale": "zh-CN", "translations": {"en": {"title": "[CSP-S 2019] Numbers on a Tree.", "background": "", "description": "Given a tree of size $n$, it has $n$ nodes and $n - 1$ edges, with nodes numbered from $1 \\sim n$. Initially, each node contains a number from $1 \\sim n$, and each number from $1 \\sim n$ appears on **exactly** one node.\n\nNext, you need to perform **exactly** $n - 1$ edge-deletion operations. In each operation, you choose an edge that has **not been deleted**. The numbers on the two endpoints of this edge will **swap**, and then this edge will be deleted.\n\nAfter $n - 1$ operations, all edges will have been deleted. At this time, list the node indices where numbers $1 \\sim n$ are located in increasing order of the numbers, and you obtain a permutation of node indices $P_i$. Now, please find the **lexicographically smallest** $P_i$ that can be obtained under an optimal sequence of operations.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/flbxosct.png)\n\nAs shown above, the numbers $1 \\sim 5$ in the blue circles are initially on nodes ②, ①, ③, ⑤, ④ respectively. Delete all edges in the order (1)(4)(3)(2), and the tree becomes the figure below. The node index permutation obtained by the number order is ①③④②⑤, which is the lexicographically smallest among all possible results.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tu338qm9.png)", "inputFormat": "**This problem contains multiple test cases.**\n\nThe first line contains a positive integer $T$, indicating the number of test cases.\n\nFor each test case:\n\nThe first line contains an integer $n$, indicating the size of the tree.\n\nThe second line contains $n$ integers. The $i (1 \\leq i \\leq n)$-th integer indicates the node index where number $i$ is initially located.\n\nThe next $n - 1$ lines each contain two integers $x$, $y$, indicating an edge connecting node $x$ and node $y$.", "outputFormat": "For each test case, output one line with $n$ integers separated by spaces, representing the lexicographically smallest $P_i$ that can be obtained under an optimal sequence of operations.", "hint": "Constraints\n\n| Test Point ID | $n \\leq$ | Special Property |\n| :----------- | :----------- | :----------- |\n| $1 \\sim 2$ | $10$ | None |\n| $3 \\sim 4$ | $160$ | The tree is a chain |\n| $5 \\sim 7$ | $2000$ | Same as above |\n| $8 \\sim 9$ | $160$ | There exists a node with degree $n - 1$ |\n| $10 \\sim 12$ | $2000$ | Same as above |\n| $13 \\sim 16$ | $160$ | None |\n| $17 \\sim 20$ | $2000$ | None |\n\nFor all test points: $1 \\leq T \\leq 10$, and it is guaranteed that the input is a tree.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSP-S 2019] 树上的数", "background": null, "description": "给定一个大小为 $n$ 的树，它共有 $n$ 个结点与 $n - 1$ 条边，结点从 $1 \\sim n$ 编号。初始时每个结点上都有一个 $1 \\sim n$ 的数字，且每个 $1 \\sim n$ 的数字都只在**恰好**一个结点上出现。\n\n接下来你需要进行**恰好** $n - 1$ 次删边操作，每次操作你需要选一条**未被删去**的边，此时这条边所连接的两个结点上的数字将会**交换**，然后这条边将被删去。\n\n$n - 1$ 次操作过后，所有的边都将被删去。此时，按数字从小到大的顺序，将数字 $1 \\sim n$ 所在的结点编号依次排列，就得到一个结点编号的排列 $P_i$。现在请你求出，在最优操作方案下能得到的**字典序最小**的 $P_i$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/flbxosct.png)\n\n如上图，蓝圈中的数字 $1 \\sim 5$ 一开始分别在结点②、①、③、⑤、④。按照 (1)(4)(3)(2) 的顺序删去所有边，树变为下图。按数字顺序得到的结点编号排列为①③④②⑤，该排列是所有可能的结果中字典序最小的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tu338qm9.png)", "inputFormat": "**本题输入包含多组测试数据。**\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组测试数据：\n\n第一行一个整数 $n$，表示树的大小。\n\n第二行 $n$ 个整数，第 $i (1 \\leq i \\leq n)$ 个整数表示数字 $i$ 初始时所在的结点编号。\n\n接下来 $n - 1$ 行每行两个整数 $x$, $y$，表示一条连接 $x$ 号结点与 $y$ 号结点的边。", "outputFormat": "对于每组测试数据，输出一行共 $n$ 个用空格隔开的整数，表示最优操作方案下所能得到的字典序最小的 $P_i$。", "hint": "【数据范围】\n\n| 测试点编号 | $n \\leq$ | 特殊性质 |\n| :----------- | :----------- | :----------- |\n| $1 \\sim 2$ | $10$ | 无 |\n| $3 \\sim 4$ | $160$ | 树的形态是一条链 |\n| $5 \\sim 7$ | $2000$ | 同上 |\n| $8 \\sim 9$ | $160$ | 存在度数为 $n - 1$ 的结点 |\n| $10 \\sim 12$ | $2000$ | 同上 |\n| $13 \\sim 16$ | $160$ | 无 |\n| $17 \\sim 20$ | $2000$ | 无 |\n\n对于所有测试点：$1 \\leq T \\leq 10$，保证给出的是一个树。", "locale": "zh-CN"}}}
{"pid": "P5660", "type": "P", "difficulty": 1, "samples": [["00010100", "2"], ["11111111", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["字符串", "2019", "CSP-J 入门级"], "title": "[CSP-J 2019] 数字游戏", "background": "", "description": "小 K 同学向小 P 同学发送了一个长度为 $8$ 的 **01 字符串**来玩数字游戏，小 P 同学想要知道字符串中究竟有多少个 $1$。\n\n注意：01 字符串为每一个字符是 $0$ 或者 $1$ 的字符串，如 `101` 为一个长度为 $3$ 的 01 字符串。 ", "inputFormat": "输入文件只有一行，一个长度为 $8$ 的 01 字符串 $s$。", "outputFormat": "输出文件只有一行，包含一个整数，即 01 字符串中**字符 $\\mathbf 1$** 的个数。", "hint": "**样例 1 说明**\n\n该 01 字符串中有 $2$ 个字符 $1$。 \n\n\n**样例 2 说明**\n\n该 01 字符串中有 $8$ 个字符 $1$。\n\n**数据规模与约定** \n\n- 对于 $20\\%$ 的数据，保证输入的字符全部为 $0$。\n- 对于 $100\\%$ 的数据，输入只可能包含字符 $0$ 和字符 $1$，字符串长度固定为 $8$。", "locale": "zh-CN", "translations": {"en": {"title": "[CSP-J 2019] Number Game", "background": "", "description": "Student K sent Student P a **01 string** of length $8$ to play a number game. Student P wants to know how many $1$’s are in the string.\n\nNote: A 01 string is a string where every character is $0$ or $1$. For example, `101` is a 01 string of length $3$.", "inputFormat": "The input file contains only one line: a 01 string $s$ of length $8$.", "outputFormat": "The output file contains only one line containing an integer, which is the number of **character $\\mathbf 1$** in the 01 string.", "hint": "**Sample 1 Explanation**\n\nThere are $2$ characters $1$ in this 01 string.\n\n**Sample 2 Explanation**\n\nThere are $8$ characters $1$ in this 01 string.\n\n**Constraints**\n\n- For $20\\%$ of the testdata, all input characters are guaranteed to be $0$.\n- For $100\\%$ of the testdata, the input can only contain character $0$ and character $1$, and the string length is fixed at $8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSP-J 2019] 数字游戏", "background": "", "description": "小 K 同学向小 P 同学发送了一个长度为 $8$ 的 **01 字符串**来玩数字游戏，小 P 同学想要知道字符串中究竟有多少个 $1$。\n\n注意：01 字符串为每一个字符是 $0$ 或者 $1$ 的字符串，如 `101` 为一个长度为 $3$ 的 01 字符串。 ", "inputFormat": "输入文件只有一行，一个长度为 $8$ 的 01 字符串 $s$。", "outputFormat": "输出文件只有一行，包含一个整数，即 01 字符串中**字符 $\\mathbf 1$** 的个数。", "hint": "**样例 1 说明**\n\n该 01 字符串中有 $2$ 个字符 $1$。 \n\n\n**样例 2 说明**\n\n该 01 字符串中有 $8$ 个字符 $1$。\n\n**数据规模与约定** \n\n- 对于 $20\\%$ 的数据，保证输入的字符全部为 $0$。\n- 对于 $100\\%$ 的数据，输入只可能包含字符 $0$ 和字符 $1$，字符串长度固定为 $8$。", "locale": "zh-CN"}}}
{"pid": "P5661", "type": "P", "difficulty": 2, "samples": [["6\n0 10 3\n1 5 46\n0 12 50\n1 3 96\n0 5 110\n1 6 135", "36"], ["6\n0 5 1\n0 20 16\n0 7 23\n1 18 31\n1 4 38\n1 7 68 ", "32"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["模拟", "2019", "队列", "CSP-J 入门级"], "title": "[CSP-J 2019] 公交换乘", "background": "", "description": "著名旅游城市 B 市为了鼓励大家采用公共交通方式出行，推出了一种地铁换乘公交车的优惠方案：\n1. 在搭乘一次地铁后可以获得一张优惠票，有效期为 45 分钟，在有效期内可以消耗这张优惠票，免费搭乘一次票价不超过地铁票价的公交车。在有效期内指开始乘公交车的时间与开始乘地铁的时间之差小于等于 45 分钟，即：\n$t_{bus} - t_{subway} \\leq 45$。\n2. 搭乘地铁获得的优惠票可以累积，即可以连续搭乘若干次地铁后再连续使用优惠票搭乘公交车。\n3. 搭乘公交车时，如果可以使用优惠票一定会使用优惠票；如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。\n\n现在你得到了小轩最近的公共交通出行记录，你能帮他算算他的花费吗?", "inputFormat": "输入文件的第一行包含一个正整数 $n$，代表乘车记录的数量。\n\n接下来的 $n$ 行，每行包含 3 个整数，相邻两数之间以一个空格分隔。第 $i$ 行的第 1 个整数代表第 $i$ 条记录乘坐的交通工具，0 代表地铁，1 代表公交车；第 2 个整数代表第 $i$ 条记录乘车的票价 $price_i$ ；第三个整数代表第 $i$ 条记录开始乘车的时间 $t_i$（距 0 时刻的分钟数）。\n\n我们保证出行记录是按照开始乘车的时间顺序给出的，且不会有两次乘车记录出现在同一分钟。", "outputFormat": "输出文件有一行，包含一个正整数，代表小轩出行的总花费。", "hint": "**样例 1 说明**\n\n第一条记录，在第 3 分钟花费 10 元乘坐地铁。\n\n第二条记录，在第 46 分钟乘坐公交车，可以使用第一条记录中乘坐地铁获得的优惠票，因此没有花费。\n\n第三条记录，在第 50 分钟花费 12 元乘坐地铁。\n\n第四条记录，在第 96 分钟乘坐公交车，由于距离第三条记录中乘坐地铁已超过 45 分钟，所以优惠票已失效，花费 3 元乘坐公交车。\n\n第五条记录，在第 110 分钟花费 5 元乘坐地铁。\n\n第六条记录，在第 135 分钟乘坐公交车，由于此时手中只有第五条记录中乘坐地铁获得的优惠票有效，而本次公交车的票价为 6 元，高于第五条记录中地铁的票价 5 元，所以不能使用优惠票，花费 6 元乘坐公交车。\n\n总共花费 36 元。 \n\n**样例 2 说明**\n\n第一条记录，在第 1 分钟花费 5 元乘坐地铁。\n\n第二条记录，在第 16 分钟花费 20 元乘坐地铁。\n\n第三条记录，在第 23 分钟花费 7 元乘坐地铁。\n\n第四条记录，在第 31 分钟乘坐公交车，此时只有第二条记录中乘坐的地铁票价高于本次公交车票价，所以使用第二条记录中乘坐地铁获得的优惠票。\n\n第五条记录，在第 38 分钟乘坐公交车，此时第一条和第三条记录中乘坐地铁获得的优惠票都可以使用，使用获得最早的优惠票，即第一条记录中乘坐地铁获得的优惠票。\n\n第六条记录，在第 68 分钟乘坐公交车，使用第三条记录中乘坐地铁获得的优惠票。\n\n总共花费 32 元。 \n\n\n**数据规模与约定**\n\n对于 $30\\%$ 的数据，$n \\leq 1000$，$t_i \\leq 10^6$。\n\n另有 $15\\%$ 的数据，$t_i \\leq 10^7$，所有 $price_i$ 相等。\n\n另有 $15\\%$ 的数据，$t_i \\leq 10^9$，所有 $price_i$ 相等。\n\n对于 $100\\%$ 的数据，$n \\leq 10^5$，$t_i \\leq 10^9$，$1 \\leq price_i \\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CSP-J 2019] Public Transport Transfer", "background": "", "description": "Famous tourist city B, in order to encourage everyone to travel by public transport, has introduced a discount plan for transferring from the subway to the bus:\n\n1. After taking the subway once, you can obtain a discount ticket with a validity period of 45 minutes. Within the validity period, you may use this discount ticket to take one bus ride for free, as long as the bus fare does not exceed the subway fare. “Within the validity period” means that the difference between the start time of the bus ride and the start time of the subway ride is no more than 45 minutes, i.e. $t_{bus} - t_{subway} \\leq 45$.\n2. Discount tickets obtained from taking the subway can be accumulated, i.e. you can take the subway several times in a row and then use the discount tickets to take buses several times in a row.\n3. When taking a bus, if a discount ticket can be used, it will definitely be used. If multiple discount tickets satisfy the conditions, the earliest obtained discount ticket will be used first.\n\nNow you have obtained Xiaoxuan’s recent public transport travel records. Can you help compute his total cost?", "inputFormat": "The first line of the input file contains a positive integer $n$, representing the number of travel records.\n\nThe next $n$ lines each contain 3 integers, separated by a single space between adjacent numbers. In the $i$-th line, the first integer indicates the mode of transport for the $i$-th record: 0 represents subway, and 1 represents bus. The second integer indicates the fare for the $i$-th ride, $price_i$. The third integer indicates the start time of the $i$-th ride, $t_i$ (in minutes since time 0).\n\nIt is guaranteed that the travel records are given in increasing order of start time, and no two ride records occur in the same minute.", "outputFormat": "The output file contains one line with a positive integer, representing Xiaoxuan’s total travel cost.", "hint": "**Sample 1 Explanation**\n\nRecord 1: At minute 3, pay 10 yuan to take the subway.\n\nRecord 2: At minute 46, take the bus. You can use the discount ticket obtained from Record 1, so there is no cost.\n\nRecord 3: At minute 50, pay 12 yuan to take the subway.\n\nRecord 4: At minute 96, take the bus. Since it has been more than 45 minutes since the subway ride in Record 3, the discount ticket is no longer valid, so pay 3 yuan to take the bus.\n\nRecord 5: At minute 110, pay 5 yuan to take the subway.\n\nRecord 6: At minute 135, take the bus. At this time, only the discount ticket obtained from Record 5 is valid, but the bus fare is 6 yuan, which is higher than the subway fare 5 yuan from Record 5, so the discount ticket cannot be used. Pay 6 yuan to take the bus.\n\nThe total cost is 36 yuan.\n\n**Sample 2 Explanation**\n\nRecord 1: At minute 1, pay 5 yuan to take the subway.\n\nRecord 2: At minute 16, pay 20 yuan to take the subway.\n\nRecord 3: At minute 23, pay 7 yuan to take the subway.\n\nRecord 4: At minute 31, take the bus. At this time, only the subway fare in Record 2 is higher than the bus fare for this ride, so use the discount ticket obtained from Record 2.\n\nRecord 5: At minute 38, take the bus. At this time, both the discount tickets obtained from Record 1 and Record 3 can be used. Use the earliest obtained discount ticket, i.e. the one from Record 1.\n\nRecord 6: At minute 68, take the bus. Use the discount ticket obtained from Record 3.\n\nThe total cost is 32 yuan.\n\n**Constraints**\n\nFor $30\\%$ of the testdata, $n \\leq 1000$, $t_i \\leq 10^6$.\n\nFor another $15\\%$ of the testdata, $t_i \\leq 10^7$, and all $price_i$ are equal.\n\nFor another $15\\%$ of the testdata, $t_i \\leq 10^9$, and all $price_i$ are equal.\n\nFor $100\\%$ of the testdata, $n \\leq 10^5$, $t_i \\leq 10^9$, $1 \\leq price_i \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSP-J 2019] 公交换乘", "background": "", "description": "著名旅游城市 B 市为了鼓励大家采用公共交通方式出行，推出了一种地铁换乘公交车的优惠方案：\n1. 在搭乘一次地铁后可以获得一张优惠票，有效期为 45 分钟，在有效期内可以消耗这张优惠票，免费搭乘一次票价不超过地铁票价的公交车。在有效期内指开始乘公交车的时间与开始乘地铁的时间之差小于等于 45 分钟，即：\n$t_{bus} - t_{subway} \\leq 45$。\n2. 搭乘地铁获得的优惠票可以累积，即可以连续搭乘若干次地铁后再连续使用优惠票搭乘公交车。\n3. 搭乘公交车时，如果可以使用优惠票一定会使用优惠票；如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。\n\n现在你得到了小轩最近的公共交通出行记录，你能帮他算算他的花费吗?", "inputFormat": "输入文件的第一行包含一个正整数 $n$，代表乘车记录的数量。\n\n接下来的 $n$ 行，每行包含 3 个整数，相邻两数之间以一个空格分隔。第 $i$ 行的第 1 个整数代表第 $i$ 条记录乘坐的交通工具，0 代表地铁，1 代表公交车；第 2 个整数代表第 $i$ 条记录乘车的票价 $price_i$ ；第三个整数代表第 $i$ 条记录开始乘车的时间 $t_i$（距 0 时刻的分钟数）。\n\n我们保证出行记录是按照开始乘车的时间顺序给出的，且不会有两次乘车记录出现在同一分钟。", "outputFormat": "输出文件有一行，包含一个正整数，代表小轩出行的总花费。", "hint": "**样例 1 说明**\n\n第一条记录，在第 3 分钟花费 10 元乘坐地铁。\n\n第二条记录，在第 46 分钟乘坐公交车，可以使用第一条记录中乘坐地铁获得的优惠票，因此没有花费。\n\n第三条记录，在第 50 分钟花费 12 元乘坐地铁。\n\n第四条记录，在第 96 分钟乘坐公交车，由于距离第三条记录中乘坐地铁已超过 45 分钟，所以优惠票已失效，花费 3 元乘坐公交车。\n\n第五条记录，在第 110 分钟花费 5 元乘坐地铁。\n\n第六条记录，在第 135 分钟乘坐公交车，由于此时手中只有第五条记录中乘坐地铁获得的优惠票有效，而本次公交车的票价为 6 元，高于第五条记录中地铁的票价 5 元，所以不能使用优惠票，花费 6 元乘坐公交车。\n\n总共花费 36 元。 \n\n**样例 2 说明**\n\n第一条记录，在第 1 分钟花费 5 元乘坐地铁。\n\n第二条记录，在第 16 分钟花费 20 元乘坐地铁。\n\n第三条记录，在第 23 分钟花费 7 元乘坐地铁。\n\n第四条记录，在第 31 分钟乘坐公交车，此时只有第二条记录中乘坐的地铁票价高于本次公交车票价，所以使用第二条记录中乘坐地铁获得的优惠票。\n\n第五条记录，在第 38 分钟乘坐公交车，此时第一条和第三条记录中乘坐地铁获得的优惠票都可以使用，使用获得最早的优惠票，即第一条记录中乘坐地铁获得的优惠票。\n\n第六条记录，在第 68 分钟乘坐公交车，使用第三条记录中乘坐地铁获得的优惠票。\n\n总共花费 32 元。 \n\n\n**数据规模与约定**\n\n对于 $30\\%$ 的数据，$n \\leq 1000$，$t_i \\leq 10^6$。\n\n另有 $15\\%$ 的数据，$t_i \\leq 10^7$，所有 $price_i$ 相等。\n\n另有 $15\\%$ 的数据，$t_i \\leq 10^9$，所有 $price_i$ 相等。\n\n对于 $100\\%$ 的数据，$n \\leq 10^5$，$t_i \\leq 10^9$，$1 \\leq price_i \\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P5662", "type": "P", "difficulty": 4, "samples": [["6 1 100\n50\n20\n25\n20\n25\n50", "305"], ["3 3 100\n10 20 15\n15 17 13\n15 25 16", "217"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "2019", "背包 DP", "CSP-J 入门级"], "title": "[CSP-J 2019] 纪念品", "background": "", "description": "小伟突然获得一种超能力，他知道未来 $T$ 天 $N$ 种纪念品每天的价格。某个纪念品的价格是指购买一个该纪念品所需的金币数量，以及卖出一个该纪念品换回的金币数量。\n\n每天，小伟可以进行以下两种交易**无限次**：\n1. 任选一个纪念品，若手上有足够金币，以当日价格购买该纪念品；\n2. 卖出持有的任意一个纪念品，以当日价格换回金币。\n\n每天卖出纪念品换回的金币可以**立即**用于购买纪念品，当日购买的纪念品也可以**当日卖出**换回金币。当然，一直持有纪念品也是可以的。\n\n$T$ 天之后，小伟的超能力消失。因此他一定会在第 $T$ 天卖出**所有**纪念品换回金币。\n\n小伟现在有 $M$ 枚金币，他想要在超能力消失后拥有尽可能多的金币。 \n ", "inputFormat": "第一行包含三个正整数 $T, N, M$，相邻两数之间以一个空格分开，分别代表未来天数 $T$，纪念品数量 $N$，小伟现在拥有的金币数量 $M$。\n\n接下来 $T$ 行，每行包含 $N$ 个正整数，相邻两数之间以一个空格分隔。第 $i$ 行的 $N$ 个正整数分别为 $P_{i,1},P_{i,2},\\dots,P_{i,N}$，其中 $P_{i,j}$ 表示第 $i$ 天第 $j$ 种纪念品的价格。", "outputFormat": "输出仅一行，包含一个正整数，表示小伟在超能力消失后最多能拥有的金币数量。\n ", "hint": "**样例 1 说明**\n\n最佳策略是：\n\n第二天花光所有 $100$ 枚金币买入 $5$ 个纪念品 $1$；\n\n第三天卖出 $5$ 个纪念品 $1$，获得金币 $125$ 枚；\n\n第四天买入 $6$ 个纪念品 $1$，剩余 $5$ 枚金币；\n\n第六天必须卖出所有纪念品换回 $300$ 枚金币，第四天剩余 $5$ 枚金币，共 $305$ 枚金币。\n\n超能力消失后，小伟最多拥有 $305$ 枚金币。\n\n**样例 2 说明**\n\n最佳策略是：\n\n第一天花光所有金币买入 $10$ 个纪念品 $1$；\n\n第二天卖出全部纪念品 $1$ 得到 $150$ 枚金币并买入 $8$ 个纪念品 $2$ 和 $1$ 个纪念品 $3$，剩余 $1$ 枚金币；\n\n第三天必须卖出所有纪念品换回 $216$ 枚金币，第二天剩余 $1$ 枚金币，共 $217$ 枚金币。\n\n超能力消失后，小伟最多拥有 $217$ 枚金币。\n\n\n**数据规模与约定**\n\n对于 $10\\%$ 的数据，$T = 1$。\n\n对于 $30\\%$ 的数据，$T \\leq 4, N \\leq 4, M \\leq 100$，所有价格 $10 \\leq P_{i,j} \\leq 100$。\n\n另有 $15\\%$ 的数据，$T \\leq 100, N = 1$。\n\n另有 $15\\%$ 的数据，$T = 2, N \\leq 100$。\n\n对于 $100\\%$ 的数据，$T \\leq 100, N \\leq 100, M \\leq 10^3$，所有价格 $1 \\leq P_{i,j} \\leq 10^4$，数据保证任意时刻，小伟手上的金币数不可能超过 $10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[CSP-J 2019] Souvenirs", "background": "", "description": "Xiaowei suddenly gains a superpower: he knows the prices of $N$ kinds of souvenirs for each of the next $T$ days. The price of a souvenir means the number of coins needed to buy one unit of that souvenir, and also the number of coins you get back by selling one unit of that souvenir.\n\nEach day, Xiaowei can perform the following two types of transactions an **unlimited** number of times:\n1. Choose any souvenir; if he has enough coins, buy that souvenir at today’s price.\n2. Sell any souvenir he is holding, and exchange it for coins at today’s price.\n\nThe coins obtained from selling souvenirs can be used **immediately** to buy souvenirs. Souvenirs bought on the same day can also be **sold on the same day** for coins. Of course, he may also keep holding souvenirs.\n\nAfter $T$ days, Xiaowei’s superpower disappears. Therefore, he will definitely sell **all** souvenirs on day $T$ to get coins back.\n\nXiaowei currently has $M$ coins. He wants to have as many coins as possible after his superpower disappears.", "inputFormat": "The first line contains three positive integers $T, N, M$, separated by single spaces, representing the number of future days $T$, the number of souvenir types $N$, and the number of coins Xiaowei currently has $M$.\n\nThe next $T$ lines each contain $N$ positive integers, separated by single spaces. On line $i$, the $N$ integers are $P_{i,1}, P_{i,2}, \\dots, P_{i,N}$, where $P_{i,j}$ denotes the price of the $j$-th type of souvenir on day $i$.", "outputFormat": "Output only one line containing one positive integer, representing the maximum number of coins Xiaowei can have after his superpower disappears.", "hint": "**Sample 1 Explanation**\n\nThe best strategy is:\n\nOn day 2, spend all $100$ coins to buy $5$ units of souvenir $1$.\n\nOn day 3, sell the $5$ units of souvenir $1$ to get $125$ coins.\n\nOn day 4, buy $6$ units of souvenir $1$, with $5$ coins remaining.\n\nOn day 6, you must sell all souvenirs to get $300$ coins back; together with the $5$ coins left from day 4, this is a total of $305$ coins.\n\nAfter the superpower disappears, Xiaowei can have at most $305$ coins.\n\n**Sample 2 Explanation**\n\nThe best strategy is:\n\nOn day 1, spend all coins to buy $10$ units of souvenir $1$.\n\nOn day 2, sell all units of souvenir $1$ to get $150$ coins, then buy $8$ units of souvenir $2$ and $1$ unit of souvenir $3$, with $1$ coin remaining.\n\nOn day 3, you must sell all souvenirs to get $216$ coins back; together with the $1$ coin left from day 2, this is a total of $217$ coins.\n\nAfter the superpower disappears, Xiaowei can have at most $217$ coins.\n\n**Constraints**\n\nFor $10\\%$ of the testdata, $T = 1$.\n\nFor $30\\%$ of the testdata, $T \\leq 4$, $N \\leq 4$, $M \\leq 100$, and all prices satisfy $10 \\leq P_{i,j} \\leq 100$.\n\nFor another $15\\%$ of the testdata, $T \\leq 100$ and $N = 1$.\n\nFor another $15\\%$ of the testdata, $T = 2$ and $N \\leq 100$.\n\nFor $100\\%$ of the testdata, $T \\leq 100$, $N \\leq 100$, $M \\leq 10^3$, and all prices satisfy $1 \\leq P_{i,j} \\leq 10^4$. The testdata guarantees that at any moment, the number of coins Xiaowei has cannot exceed $10^4$.\n\n# Input Format\n\n\n\n# Output Format\n\n\n\n# Hint\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSP-J 2019] 纪念品", "background": "", "description": "小伟突然获得一种超能力，他知道未来 $T$ 天 $N$ 种纪念品每天的价格。某个纪念品的价格是指购买一个该纪念品所需的金币数量，以及卖出一个该纪念品换回的金币数量。\n\n每天，小伟可以进行以下两种交易**无限次**：\n1. 任选一个纪念品，若手上有足够金币，以当日价格购买该纪念品；\n2. 卖出持有的任意一个纪念品，以当日价格换回金币。\n\n每天卖出纪念品换回的金币可以**立即**用于购买纪念品，当日购买的纪念品也可以**当日卖出**换回金币。当然，一直持有纪念品也是可以的。\n\n$T$ 天之后，小伟的超能力消失。因此他一定会在第 $T$ 天卖出**所有**纪念品换回金币。\n\n小伟现在有 $M$ 枚金币，他想要在超能力消失后拥有尽可能多的金币。 \n ", "inputFormat": "第一行包含三个正整数 $T, N, M$，相邻两数之间以一个空格分开，分别代表未来天数 $T$，纪念品数量 $N$，小伟现在拥有的金币数量 $M$。\n\n接下来 $T$ 行，每行包含 $N$ 个正整数，相邻两数之间以一个空格分隔。第 $i$ 行的 $N$ 个正整数分别为 $P_{i,1},P_{i,2},\\dots,P_{i,N}$，其中 $P_{i,j}$ 表示第 $i$ 天第 $j$ 种纪念品的价格。", "outputFormat": "输出仅一行，包含一个正整数，表示小伟在超能力消失后最多能拥有的金币数量。\n ", "hint": "**样例 1 说明**\n\n最佳策略是：\n\n第二天花光所有 $100$ 枚金币买入 $5$ 个纪念品 $1$；\n\n第三天卖出 $5$ 个纪念品 $1$，获得金币 $125$ 枚；\n\n第四天买入 $6$ 个纪念品 $1$，剩余 $5$ 枚金币；\n\n第六天必须卖出所有纪念品换回 $300$ 枚金币，第四天剩余 $5$ 枚金币，共 $305$ 枚金币。\n\n超能力消失后，小伟最多拥有 $305$ 枚金币。\n\n**样例 2 说明**\n\n最佳策略是：\n\n第一天花光所有金币买入 $10$ 个纪念品 $1$；\n\n第二天卖出全部纪念品 $1$ 得到 $150$ 枚金币并买入 $8$ 个纪念品 $2$ 和 $1$ 个纪念品 $3$，剩余 $1$ 枚金币；\n\n第三天必须卖出所有纪念品换回 $216$ 枚金币，第二天剩余 $1$ 枚金币，共 $217$ 枚金币。\n\n超能力消失后，小伟最多拥有 $217$ 枚金币。\n\n\n**数据规模与约定**\n\n对于 $10\\%$ 的数据，$T = 1$。\n\n对于 $30\\%$ 的数据，$T \\leq 4, N \\leq 4, M \\leq 100$，所有价格 $10 \\leq P_{i,j} \\leq 100$。\n\n另有 $15\\%$ 的数据，$T \\leq 100, N = 1$。\n\n另有 $15\\%$ 的数据，$T = 2, N \\leq 100$。\n\n对于 $100\\%$ 的数据，$T \\leq 100, N \\leq 100, M \\leq 10^3$，所有价格 $1 \\leq P_{i,j} \\leq 10^4$，数据保证任意时刻，小伟手上的金币数不可能超过 $10^4$。", "locale": "zh-CN"}}}
{"pid": "P5663", "type": "P", "difficulty": 4, "samples": [["3 2 6\n1 2\n2 3\n1 1\n2 1\n3 1\n1 2\n2 2\n3 2", "No\nYes\nNo\nYes\nNo\nYes"], ["5 5 5\n1 2\n2 3\n3 4\n4 5\n1 5\n1 1\n1 2\n1 3\n1 4\n1 5", "No\nYes\nNo\nYes\nYes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2019", "广度优先搜索 BFS", "最短路", "CSP-J 入门级"], "title": "[CSP-J 2019] 加工零件", "background": "", "description": "凯凯的工厂正在有条不紊地生产一种神奇的零件，神奇的零件的生产过程自然也很神奇。工厂里有 $n$ 位工人，工人们从 $1 \\sim n$ 编号。某些工人之间存在双向的零件传送带。保证每两名工人之间最多只存在一条传送带。\n\n如果 $x$ 号工人想生产一个被加工到第 $L\\,(L \\gt 1)$ 阶段的零件，则**所有**与 $x$ 号工人有传送带**直接**相连的工人，都需要生产一个被加工到第 $L - 1$ 阶段的零件（但 $x$ 号工人自己**无需**生产第 $L - 1$ 阶段的零件）。\n\n如果 $x$ 号工人想生产一个被加工到第 $1$ 阶段的零件，则**所有**与 $x$ 号工人有传送带**直接**相连的工人，都需要为 $x$ 号工人提供一个原材料。\n\n轩轩是 $1$ 号工人。现在给出 $q$ 张工单，第 $i$ 张工单表示编号为 $a_i$ 的工人想生产一个第 $L_i$ 阶段的零件。轩轩想知道对于每张工单，他是否需要给别人提供原材料。他知道聪明的你一定可以帮他计算出来！", "inputFormat": "第一行三个正整数 $n$，$m$ 和 $q$，分别表示工人的数目、传送带的数目和工单的数目。\n\n接下来 $m$ 行，每行两个正整数 $u$ 和 $v$，表示编号为 $u$ 和 $v$ 的工人之间存在一条零件传输带。保证 $u \\neq v$。\n\n接下来 $q$ 行，每行两个正整数 $a$ 和 $L$，表示编号为 $a$ 的工人想生产一个第 $L$ 阶段的零件。", "outputFormat": "共 $q$ 行，每行一个字符串 `Yes` 或者 `No`。如果按照第 $i$ 张工单生产，需要编号为 1 的轩轩提供原材料，则在第 $i$ 行输出 `Yes`；否则在第 $i$ 行输出 `No`。", "hint": "**样例 1 说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5dbepjmh.png)\n\n编号为 1 的工人想生产第 1 阶段的零件，需要编号为 2 的工人提供原材料。\n\n编号为 2 的工人想生产第 1 阶段的零件，需要编号为 1 和 3 的工人提供原材料。\n\n编号为 3 的工人想生产第 1 阶段的零件，需要编号为 2 的工人提供原材料。\n\n编号为 1 的工人想生产第 2 阶段的零件，需要编号为 2 的工人生产第 1 阶段的零 件，需要编号为 1 和 3 的工人提供原材料。\n\n编号为 2 的工人想生产第 2 阶段的零件，需要编号为 1 和 3 的工人生产第 1 阶段的零件，他/她们都需要编号为 2 的工人提供原材料。\n\n编号为 3 的工人想生产第 2 阶段的零件，需要编号为 2 的工人生产第 1 阶段的零件，需要编号为 1 和 3 的工人提供原材料。\n\n**样例 2 说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tfom5z2s.png)\n\n编号为 1 的工人想生产第 1 阶段的零件，需要编号为 2 和 5 的工人提供原材料。\n\n编号为 1 的工人想生产第 2 阶段的零件，需要编号为 2 和 5 的工人生产第 1 阶段的零件，需要编号为 1,3,4 的工人提供原材料。\n\n编号为 1 的工人想生产第 3 阶段的零件，需要编号为 2 和 5 的工人生产第 2 阶段的零件，需要编号为 1,3,4 的工人生产第 1 阶段的零件，需要编号为 2,3,4,5 的工人提供原材料。\n\n编号为 1 的工人想生产第 4 阶段的零件，需要编号为 2 和 5 的工人生产第 3 阶段的零件，需要编号为 1,3,4 的工人生产第 2 阶段的零件，需要编号为 2,3,4,5 的工人生产第 1 阶段的零件，需要全部工人提供原材料。\n\n编号为 1 的工人想生产第 5 阶段的零件，需要编号为 2 和 5 的工人生产第 4 阶段的零件，需要编号为 1,3,4 的工人生产第 3 阶段的零件，需要编号为 2,3,4,5 的工人生产第 2 阶段的零件，需要全部工人生产第 1 阶段的零件，需要全部工人提供原材料。\n\n**数据规模与约定**\n\n共 $20$ 个测试点。\n\n对所有测试点保证 $1 \\leq u, v, a \\leq n$。\n\n测试点 $1\\sim4$，$1 \\leq n, m \\leq 1000$，$q = 3$，$L = 1$。\n\n测试点 $5\\sim8$，$1 \\leq n, m \\leq 1000$，$q = 3$，$1 \\leq L \\leq 10$。\n\n测试点 $9\\sim12$，$1 \\leq n, m, L \\leq 1000$，$1 \\leq q \\leq 100$。\n\n测试点 $13\\sim16$，$1 \\leq n, m, L \\leq 1000$，$1 \\leq q \\leq 10^5$。\n\n测试点 $17\\sim20$，$1 \\leq n, m, q \\leq 10^5$，$1 \\leq L \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[CSP-J 2019] Processing Parts", "background": "", "description": "Kaikai’s factory is producing a magical part in an orderly way, and of course the production process is also magical. There are $n$ workers in the factory, numbered from $1 \\sim n$. Between some pairs of workers, there are two-way conveyor belts for transporting parts. It is guaranteed that there is at most one conveyor belt between any two workers.\n\nIf worker $x$ wants to produce a part processed to stage $L\\,(L \\gt 1)$, then **all** workers that are **directly** connected to worker $x$ by a conveyor belt need to produce a part processed to stage $L - 1$ (but worker $x$ himself/herself does **not** need to produce a stage $L - 1$ part).\n\nIf worker $x$ wants to produce a part processed to stage $1$, then **all** workers that are **directly** connected to worker $x$ by a conveyor belt need to provide worker $x$ with one raw material.\n\nXuanxuan is worker $1$. Now $q$ work orders are given. The $i$-th work order means that the worker numbered $a_i$ wants to produce a part at stage $L_i$. For each work order, Xuanxuan wants to know whether he needs to provide raw materials for others. He knows that smart you can help him compute it.", "inputFormat": "The first line contains three positive integers $n$, $m$, and $q$, representing the number of workers, the number of conveyor belts, and the number of work orders.\n\nThe next $m$ lines each contain two positive integers $u$ and $v$, indicating that there is a conveyor belt between worker $u$ and worker $v$. It is guaranteed that $u \\neq v$.\n\nThe next $q$ lines each contain two positive integers $a$ and $L$, indicating that worker $a$ wants to produce a part at stage $L$.", "outputFormat": "Output $q$ lines, each containing a string `Yes` or `No`. If producing according to the $i$-th work order requires Xuanxuan (worker $1$) to provide raw materials, output `Yes` on the $i$-th line; otherwise output `No`.", "hint": "**Sample 1 Explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5dbepjmh.png)\n\nIf worker $1$ wants to produce a stage $1$ part, worker $2$ needs to provide raw materials.\n\nIf worker $2$ wants to produce a stage $1$ part, workers $1$ and $3$ need to provide raw materials.\n\nIf worker $3$ wants to produce a stage $1$ part, worker $2$ needs to provide raw materials.\n\nIf worker $1$ wants to produce a stage $2$ part, worker $2$ needs to produce a stage $1$ part, and workers $1$ and $3$ need to provide raw materials.\n\nIf worker $2$ wants to produce a stage $2$ part, workers $1$ and $3$ need to produce a stage $1$ part, and both of them need worker $2$ to provide raw materials.\n\nIf worker $3$ wants to produce a stage $2$ part, worker $2$ needs to produce a stage $1$ part, and workers $1$ and $3$ need to provide raw materials.\n\n**Sample 2 Explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tfom5z2s.png)\n\nIf worker $1$ wants to produce a stage $1$ part, workers $2$ and $5$ need to provide raw materials.\n\nIf worker $1$ wants to produce a stage $2$ part, workers $2$ and $5$ need to produce a stage $1$ part, and workers $1,3,4$ need to provide raw materials.\n\nIf worker $1$ wants to produce a stage $3$ part, workers $2$ and $5$ need to produce a stage $2$ part, workers $1,3,4$ need to produce a stage $1$ part, and workers $2,3,4,5$ need to provide raw materials.\n\nIf worker $1$ wants to produce a stage $4$ part, workers $2$ and $5$ need to produce a stage $3$ part, workers $1,3,4$ need to produce a stage $2$ part, workers $2,3,4,5$ need to produce a stage $1$ part, and all workers need to provide raw materials.\n\nIf worker $1$ wants to produce a stage $5$ part, workers $2$ and $5$ need to produce a stage $4$ part, workers $1,3,4$ need to produce a stage $3$ part, workers $2,3,4,5$ need to produce a stage $2$ part, all workers need to produce a stage $1$ part, and all workers need to provide raw materials.\n\n**Constraints**\n\nThere are $20$ test points in total.\n\nFor all test points, it is guaranteed that $1 \\leq u, v, a \\leq n$.\n\nFor test points $1\\sim4$, $1 \\leq n, m \\leq 1000$, $q = 3$, $L = 1$.\n\nFor test points $5\\sim8$, $1 \\leq n, m \\leq 1000$, $q = 3$, $1 \\leq L \\leq 10$.\n\nFor test points $9\\sim12$, $1 \\leq n, m, L \\leq 1000$, $1 \\leq q \\leq 100$.\n\nFor test points $13\\sim16$, $1 \\leq n, m, L \\leq 1000$, $1 \\leq q \\leq 10^5$.\n\nFor test points $17\\sim20$, $1 \\leq n, m, q \\leq 10^5$, $1 \\leq L \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSP-J 2019] 加工零件", "background": "", "description": "凯凯的工厂正在有条不紊地生产一种神奇的零件，神奇的零件的生产过程自然也很神奇。工厂里有 $n$ 位工人，工人们从 $1 \\sim n$ 编号。某些工人之间存在双向的零件传送带。保证每两名工人之间最多只存在一条传送带。\n\n如果 $x$ 号工人想生产一个被加工到第 $L\\,(L \\gt 1)$ 阶段的零件，则**所有**与 $x$ 号工人有传送带**直接**相连的工人，都需要生产一个被加工到第 $L - 1$ 阶段的零件（但 $x$ 号工人自己**无需**生产第 $L - 1$ 阶段的零件）。\n\n如果 $x$ 号工人想生产一个被加工到第 $1$ 阶段的零件，则**所有**与 $x$ 号工人有传送带**直接**相连的工人，都需要为 $x$ 号工人提供一个原材料。\n\n轩轩是 $1$ 号工人。现在给出 $q$ 张工单，第 $i$ 张工单表示编号为 $a_i$ 的工人想生产一个第 $L_i$ 阶段的零件。轩轩想知道对于每张工单，他是否需要给别人提供原材料。他知道聪明的你一定可以帮他计算出来！", "inputFormat": "第一行三个正整数 $n$，$m$ 和 $q$，分别表示工人的数目、传送带的数目和工单的数目。\n\n接下来 $m$ 行，每行两个正整数 $u$ 和 $v$，表示编号为 $u$ 和 $v$ 的工人之间存在一条零件传输带。保证 $u \\neq v$。\n\n接下来 $q$ 行，每行两个正整数 $a$ 和 $L$，表示编号为 $a$ 的工人想生产一个第 $L$ 阶段的零件。", "outputFormat": "共 $q$ 行，每行一个字符串 `Yes` 或者 `No`。如果按照第 $i$ 张工单生产，需要编号为 1 的轩轩提供原材料，则在第 $i$ 行输出 `Yes`；否则在第 $i$ 行输出 `No`。", "hint": "**样例 1 说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5dbepjmh.png)\n\n编号为 1 的工人想生产第 1 阶段的零件，需要编号为 2 的工人提供原材料。\n\n编号为 2 的工人想生产第 1 阶段的零件，需要编号为 1 和 3 的工人提供原材料。\n\n编号为 3 的工人想生产第 1 阶段的零件，需要编号为 2 的工人提供原材料。\n\n编号为 1 的工人想生产第 2 阶段的零件，需要编号为 2 的工人生产第 1 阶段的零 件，需要编号为 1 和 3 的工人提供原材料。\n\n编号为 2 的工人想生产第 2 阶段的零件，需要编号为 1 和 3 的工人生产第 1 阶段的零件，他/她们都需要编号为 2 的工人提供原材料。\n\n编号为 3 的工人想生产第 2 阶段的零件，需要编号为 2 的工人生产第 1 阶段的零件，需要编号为 1 和 3 的工人提供原材料。\n\n**样例 2 说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tfom5z2s.png)\n\n编号为 1 的工人想生产第 1 阶段的零件，需要编号为 2 和 5 的工人提供原材料。\n\n编号为 1 的工人想生产第 2 阶段的零件，需要编号为 2 和 5 的工人生产第 1 阶段的零件，需要编号为 1,3,4 的工人提供原材料。\n\n编号为 1 的工人想生产第 3 阶段的零件，需要编号为 2 和 5 的工人生产第 2 阶段的零件，需要编号为 1,3,4 的工人生产第 1 阶段的零件，需要编号为 2,3,4,5 的工人提供原材料。\n\n编号为 1 的工人想生产第 4 阶段的零件，需要编号为 2 和 5 的工人生产第 3 阶段的零件，需要编号为 1,3,4 的工人生产第 2 阶段的零件，需要编号为 2,3,4,5 的工人生产第 1 阶段的零件，需要全部工人提供原材料。\n\n编号为 1 的工人想生产第 5 阶段的零件，需要编号为 2 和 5 的工人生产第 4 阶段的零件，需要编号为 1,3,4 的工人生产第 3 阶段的零件，需要编号为 2,3,4,5 的工人生产第 2 阶段的零件，需要全部工人生产第 1 阶段的零件，需要全部工人提供原材料。\n\n**数据规模与约定**\n\n共 $20$ 个测试点。\n\n对所有测试点保证 $1 \\leq u, v, a \\leq n$。\n\n测试点 $1\\sim4$，$1 \\leq n, m \\leq 1000$，$q = 3$，$L = 1$。\n\n测试点 $5\\sim8$，$1 \\leq n, m \\leq 1000$，$q = 3$，$1 \\leq L \\leq 10$。\n\n测试点 $9\\sim12$，$1 \\leq n, m, L \\leq 1000$，$1 \\leq q \\leq 100$。\n\n测试点 $13\\sim16$，$1 \\leq n, m, L \\leq 1000$，$1 \\leq q \\leq 10^5$。\n\n测试点 $17\\sim20$，$1 \\leq n, m, q \\leq 10^5$，$1 \\leq L \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5664", "type": "P", "difficulty": 5, "samples": [["2 3 \n1 0 1\n0 1 1", "3"], ["3 3\n1 2 3\n4 5 0\n6 0 0", "190"], ["5 5\n1 0 0 1 1\n0 1 0 1 0\n1 1 1 1 0\n1 0 1 0 1\n0 1 1 0 1", "742"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "数学", "2019", "容斥原理", "CSP-S 提高级"], "title": "[CSP-S 2019] Emiya 家今天的饭", "background": "", "description": "Emiya 是个擅长做菜的高中生，他共掌握 $n$ 种**烹饪方法**，且会使用 $m$ 种**主要食材**做菜。为了方便叙述，我们对烹饪方法从 $1 \\sim n$ 编号，对主要食材从 $1 \\sim m$ 编号。\n\nEmiya 做的每道菜都将使用**恰好一种**烹饪方法与**恰好一种**主要食材。更具体地，Emiya 会做 $a_{i,j}$ 道不同的使用烹饪方法 $i$ 和主要食材 $j$ 的菜（$1 \\leq i \\leq n$、$1 \\leq j \\leq m$），这也意味着 Emiya 总共会做 $\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=1}^{m} a_{i,j}$ 道不同的菜。\n\nEmiya 今天要准备一桌饭招待 Yazid 和 Rin 这对好朋友，然而三个人对菜的搭配有不同的要求，更具体地，对于一种包含 $k$ 道菜的搭配方案而言：\n- Emiya 不会让大家饿肚子，所以将做**至少一道菜**，即 $k \\geq 1$\n- Rin 希望品尝不同烹饪方法做出的菜，因此她要求每道菜的**烹饪方法互不相同**\n- Yazid 不希望品尝太多同一食材做出的菜，因此他要求每种**主要食材**至多在**一半**的菜（即 $\\lfloor \\frac{k}{2} \\rfloor$ 道菜）中被使用\n\n这里的 $\\lfloor x \\rfloor$ 为下取整函数，表示不超过 $x$ 的最大整数。\n\n这些要求难不倒 Emiya，但他想知道共有多少种不同的符合要求的搭配方案。两种方案不同，当且仅当存在至少一道菜在一种方案中出现，而不在另一种方案中出现。\n\nEmiya 找到了你，请你帮他计算，你只需要告诉他符合所有要求的搭配方案数对质数 $998,244,353$ 取模的结果。", "inputFormat": "第 1 行两个用单个空格隔开的整数 $n,m$。\n\n第 2 行至第 $n + 1$ 行，每行 $m$ 个用单个空格隔开的整数，其中第 $i + 1$ 行的 $m$ 个数依次为 $a_{i,1}, a_{i,2}, \\cdots, a_{i,m}$。", "outputFormat": "仅一行一个整数，表示所求方案数对 $998,244,353$ 取模的结果。", "hint": "【样例 1 解释】\n\n由于在这个样例中，对于每组 $i, j$，Emiya 都最多只会做一道菜，因此我们直接通过给出烹饪方法、主要食材的编号来描述一道菜。\n\n符合要求的方案包括：\n- 做一道用烹饪方法 1、主要食材 1 的菜和一道用烹饪方法 2、主要食材 2 的菜\n- 做一道用烹饪方法 1、主要食材 1 的菜和一道用烹饪方法 2、主要食材 3 的菜\n- 做一道用烹饪方法 1、主要食材 3 的菜和一道用烹饪方法 2、主要食材 2 的菜\n\n因此输出结果为 $3 \\bmod 998,244,353 = 3$。 需要注意的是，所有只包含一道菜的方案都是不符合要求的，因为唯一的主要食材在超过一半的菜中出现，这不满足 Yazid 的要求。\n\n【样例 2 解释】\n\nEmiya 必须至少做 $2$ 道菜。\n\n做 $2$ 道菜的符合要求的方案数为 $100$。\n\n做 $3$ 道菜的符合要求的方案数为 $90$。\n\n因此符合要求的方案数为 $100 + 90 = 190$。\n\n【数据范围】\n\n::cute-table{tuack}\n\n| 测试点编号  |  $n=$ | $m=$  | $a_{i,j}<$  |\n|:-:|:-:|:-:|:-:|\n| $1$  | $2$ | $2$  | $2$  |\n| $2$  | ^  | $3$  | ^  |\n| $3$  |  $5$ | $2$  | ^  |\n| $4$  | ^  | $3$  |  ^ |\n| $5$  | $10$  | $2$  |^   |\n| $6$  | ^  | $3$  |  ^ |\n| $7$  | $10$  | $2$  | $1000$  |\n| $8$  | ^  | $3$  | ^  |\n| $9\\sim 12$  | $40$  | $2$  |   ^|\n| $13\\sim16$  | ^  | $3$  |   ^|\n| $17\\sim21$  |  ^ | $500$  |  ^ |\n| $22\\sim25$  | $100$  | $2000$  | $998,244,353$  |\n\n\n对于所有测试点，保证 $1 \\leq n \\leq 100$，$1 \\leq m \\leq 2000$，$0 \\leq a_{i,j} \\lt 998,244,353$。", "locale": "zh-CN", "translations": {"en": {"title": "[CSP-S 2019] Emiya’s Meal Today", "background": "", "description": "Emiya is a high school student who is good at cooking. He has mastered $n$ kinds of **cooking methods**, and uses $m$ kinds of **main ingredients**. For convenience, we number cooking methods from $1$ to $n$, and main ingredients from $1$ to $m$.\n\nEvery dish Emiya makes will use **exactly one** cooking method and **exactly one** main ingredient. More specifically, Emiya can make $a_{i,j}$ different dishes that use cooking method $i$ and main ingredient $j$ ($1 \\leq i \\leq n$, $1 \\leq j \\leq m$). This also means Emiya can make a total of $\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=1}^{m} a_{i,j}$ different dishes.\n\nToday, Emiya is going to prepare a meal to treat his good friends Yazid and Rin. However, the three of them have different requirements for how the dishes are combined. More specifically, for a plan (a selection) that contains $k$ dishes:\n- Emiya will not let everyone go hungry, so he will make **at least one dish**, i.e. $k \\geq 1$.\n- Rin wants to taste dishes made with different cooking methods, so she requires that the **cooking methods of all dishes are pairwise different**.\n- Yazid does not want to taste too many dishes made from the same ingredient, so he requires that each **main ingredient** is used in at most **half** of the dishes (i.e. at most $\\lfloor \\frac{k}{2} \\rfloor$ dishes).\n\nHere, $\\lfloor x \\rfloor$ is the floor function, meaning the greatest integer not exceeding $x$.\n\nThese requirements are not hard for Emiya, but he wants to know how many different plans satisfy them. Two plans are different if and only if there exists at least one dish that appears in one plan but not in the other.\n\nEmiya asks you for help. Please compute the number of valid plans, and output the result modulo the prime $998,244,353$.", "inputFormat": "The first line contains two integers $n, m$ separated by a single space.\n\nLines $2$ to $n + 1$ each contain $m$ integers separated by single spaces. On line $i + 1$, the $m$ numbers are $a_{i,1}, a_{i,2}, \\cdots, a_{i,m}$ in order.", "outputFormat": "Output a single integer: the number of valid plans modulo $998,244,353$.", "hint": "[Sample 1 Explanation]\n\nIn this sample, for every pair $i, j$, Emiya can make at most one dish, so we directly describe a dish by giving the indices of its cooking method and main ingredient.\n\nValid plans include:\n- Make one dish using cooking method $1$ and main ingredient $1$, and one dish using cooking method $2$ and main ingredient $2$.\n- Make one dish using cooking method $1$ and main ingredient $1$, and one dish using cooking method $2$ and main ingredient $3$.\n- Make one dish using cooking method $1$ and main ingredient $3$, and one dish using cooking method $2$ and main ingredient $2$.\n\nTherefore the output is $3 \\bmod 998,244,353 = 3$. Note that all plans that contain only one dish are invalid, because the only main ingredient appears in more than half of the dishes, which does not satisfy Yazid’s requirement.\n\n[Sample 2 Explanation]\n\nEmiya must make at least $2$ dishes.\n\nThe number of valid plans with $2$ dishes is $100$.\n\nThe number of valid plans with $3$ dishes is $90$.\n\nTherefore the total number of valid plans is $100 + 90 = 190$.\n\n[Constraints]\n\n::cute-table{tuack}\n\n| Test Point ID | $n=$ | $m=$ | $a_{i,j}<$ |\n|:-:|:-:|:-:|:-:|\n| $1$ | $2$ | $2$ | $2$ |\n| $2$ | ^ | $3$ | ^ |\n| $3$ | $5$ | $2$ | ^ |\n| $4$ | ^ | $3$ | ^ |\n| $5$ | $10$ | $2$ | ^ |\n| $6$ | ^ | $3$ | ^ |\n| $7$ | $10$ | $2$ | $1000$ |\n| $8$ | ^ | $3$ | ^ |\n| $9\\sim 12$ | $40$ | $2$ | ^ |\n| $13\\sim16$ | ^ | $3$ | ^ |\n| $17\\sim21$ | ^ | $500$ | ^ |\n| $22\\sim25$ | $100$ | $2000$ | $998,244,353$ |\n\nFor all test points, it is guaranteed that $1 \\leq n \\leq 100$, $1 \\leq m \\leq 2000$, $0 \\leq a_{i,j} \\lt 998,244,353$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSP-S 2019] Emiya 家今天的饭", "background": "", "description": "Emiya 是个擅长做菜的高中生，他共掌握 $n$ 种**烹饪方法**，且会使用 $m$ 种**主要食材**做菜。为了方便叙述，我们对烹饪方法从 $1 \\sim n$ 编号，对主要食材从 $1 \\sim m$ 编号。\n\nEmiya 做的每道菜都将使用**恰好一种**烹饪方法与**恰好一种**主要食材。更具体地，Emiya 会做 $a_{i,j}$ 道不同的使用烹饪方法 $i$ 和主要食材 $j$ 的菜（$1 \\leq i \\leq n$、$1 \\leq j \\leq m$），这也意味着 Emiya 总共会做 $\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=1}^{m} a_{i,j}$ 道不同的菜。\n\nEmiya 今天要准备一桌饭招待 Yazid 和 Rin 这对好朋友，然而三个人对菜的搭配有不同的要求，更具体地，对于一种包含 $k$ 道菜的搭配方案而言：\n- Emiya 不会让大家饿肚子，所以将做**至少一道菜**，即 $k \\geq 1$\n- Rin 希望品尝不同烹饪方法做出的菜，因此她要求每道菜的**烹饪方法互不相同**\n- Yazid 不希望品尝太多同一食材做出的菜，因此他要求每种**主要食材**至多在**一半**的菜（即 $\\lfloor \\frac{k}{2} \\rfloor$ 道菜）中被使用\n\n这里的 $\\lfloor x \\rfloor$ 为下取整函数，表示不超过 $x$ 的最大整数。\n\n这些要求难不倒 Emiya，但他想知道共有多少种不同的符合要求的搭配方案。两种方案不同，当且仅当存在至少一道菜在一种方案中出现，而不在另一种方案中出现。\n\nEmiya 找到了你，请你帮他计算，你只需要告诉他符合所有要求的搭配方案数对质数 $998,244,353$ 取模的结果。", "inputFormat": "第 1 行两个用单个空格隔开的整数 $n,m$。\n\n第 2 行至第 $n + 1$ 行，每行 $m$ 个用单个空格隔开的整数，其中第 $i + 1$ 行的 $m$ 个数依次为 $a_{i,1}, a_{i,2}, \\cdots, a_{i,m}$。", "outputFormat": "仅一行一个整数，表示所求方案数对 $998,244,353$ 取模的结果。", "hint": "【样例 1 解释】\n\n由于在这个样例中，对于每组 $i, j$，Emiya 都最多只会做一道菜，因此我们直接通过给出烹饪方法、主要食材的编号来描述一道菜。\n\n符合要求的方案包括：\n- 做一道用烹饪方法 1、主要食材 1 的菜和一道用烹饪方法 2、主要食材 2 的菜\n- 做一道用烹饪方法 1、主要食材 1 的菜和一道用烹饪方法 2、主要食材 3 的菜\n- 做一道用烹饪方法 1、主要食材 3 的菜和一道用烹饪方法 2、主要食材 2 的菜\n\n因此输出结果为 $3 \\bmod 998,244,353 = 3$。 需要注意的是，所有只包含一道菜的方案都是不符合要求的，因为唯一的主要食材在超过一半的菜中出现，这不满足 Yazid 的要求。\n\n【样例 2 解释】\n\nEmiya 必须至少做 $2$ 道菜。\n\n做 $2$ 道菜的符合要求的方案数为 $100$。\n\n做 $3$ 道菜的符合要求的方案数为 $90$。\n\n因此符合要求的方案数为 $100 + 90 = 190$。\n\n【数据范围】\n\n::cute-table{tuack}\n\n| 测试点编号  |  $n=$ | $m=$  | $a_{i,j}<$  |\n|:-:|:-:|:-:|:-:|\n| $1$  | $2$ | $2$  | $2$  |\n| $2$  | ^  | $3$  | ^  |\n| $3$  |  $5$ | $2$  | ^  |\n| $4$  | ^  | $3$  |  ^ |\n| $5$  | $10$  | $2$  |^   |\n| $6$  | ^  | $3$  |  ^ |\n| $7$  | $10$  | $2$  | $1000$  |\n| $8$  | ^  | $3$  | ^  |\n| $9\\sim 12$  | $40$  | $2$  |   ^|\n| $13\\sim16$  | ^  | $3$  |   ^|\n| $17\\sim21$  |  ^ | $500$  |  ^ |\n| $22\\sim25$  | $100$  | $2000$  | $998,244,353$  |\n\n\n对于所有测试点，保证 $1 \\leq n \\leq 100$，$1 \\leq m \\leq 2000$，$0 \\leq a_{i,j} \\lt 998,244,353$。", "locale": "zh-CN"}}}
{"pid": "P5665", "type": "P", "difficulty": 6, "samples": [["5 0\n5 1 7 9 9", "247"], ["10 0\n5 6 7 7 4 6 2 13 19 9", "1256"], ["10000000 1\n123 456 789 12345 6789 3\n2000000 123456789 987654321\n7000000 234567891 876543219\n10000000 456789123 567891234", "4972194419293431240859891640"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2019", "单调队列", "CSP-S 提高级"], "title": "[CSP-S 2019] 划分", "background": "", "description": "2048 年，第三十届 CSP 认证的考场上，作为选手的小明打开了第一题。这个题的样例有 $n$ 组数据，数据从 $1 \\sim n$ 编号，$i$ 号数据的规模为 $a_i$。\n\n小明对该题设计出了一个暴力程序，对于一组规模为 $u$ 的数据，该程序的**运行时间**为 $u^2$。然而这个程序运行完一组规模为 $u$ 的数据之后，它将在任何一组规模**小于** $u$ 的数据上运行错误。样例中的 $a_i$ 不一定递增，但小明又想在不修改程序的情况下正确运行样例，于是小明决定使用一种非常原始的解决方案：将所有数据划分成若干个数据段，段内数据编号**连续**，接着将同一段内的数据合并成新数据，其规模等于段内原数据的**规模之和**，小明将让新数据的规模能够递增。\n\n也就是说，小明需要找到一些分界点 $1 \\leq k_1 \\lt k_2 \\lt \\cdots \\lt k_p \\lt n$，使得\n\n$$ \\sum_{i=1}^{k_1} a_i \\leq \\sum_{i=k_1+1}^{k_2} a_i \\leq \\cdots \\leq \\sum_{i=k_p+1}^{n} a_i $$\n\n注意 $p$ 可以为 $0$ 且此时 $k_0 = 0$，也就是小明可以将所有数据合并在一起运行。\n\n小明希望他的程序在正确运行样例情况下，运行时间也能尽量小，也就是**最小化**：\n\n$$ \\left(\\sum_{i=1}^{k_1} a_i\\right)^2 + \\left(\\sum_{i=k_1+1}^{k_2} a_i\\right)^2 + \\cdots + \\left(\\sum_{i=k_p+1}^{n} a_i\\right)^2 $$\n\n小明觉得这个问题非常有趣，并向你请教：给定 $n$ 和 $a_i$，请你求出最优划分方案下，小明的程序的最小运行时间。", "inputFormat": "**由于本题的数据范围较大，部分测试点的 $a_i$ 将在程序内生成。**\n\n第一行两个整数 $n, type$。$n$ 的意义见题目描述，$type$ 表示输入方式。\n1. 若 $type = 0$，则该测试点的 $a_i$ **直接给出**。输入文件接下来：第二行 $n$ 个以空格分隔的整数 $a_i$，表示每组数据的规模。\n2. 若 $type = 1$，则该测试点的 $a_i$ 将**特殊生成**，生成方式见后文。输入文件接下来：第二行六个以空格分隔的整数 $x, y, z, b_1, b_2, m$。接下来 $m$ 行中，第 $i (1 \\leq i \\leq m)$ 行包含三个以空格分隔的正整数 $p_i, l_i, r_i$。\n\n对于 $type = 1$ 的 $23 \\sim 25$ 号测试点，$a_i$ 的生成方式如下：\n\n给定整数 $x, y, z, b_1, b_2, m$，以及 $m$ 个三元组 $(p_i, l_i, r_i)$。\n\n保证 $n \\geq 2$。若 $n \\gt 2$，则 $\\forall 3 \\leq i \\leq n, b_i = (x \\times b_{i−1} + y \\times b_{i−2} + z) \\bmod 2^{30}$。\n\n保证 $1 \\leq p_i \\leq n, p_m = n$。令 $p_0 = 0$，则 $p_i$ 还满足 $\\forall 0 \\leq i \\lt m$ 有 $p_i \\lt p_{i+1}$。\n\n对于所有 $1 \\leq j \\leq m$，若下标值 $i (1 \\leq i \\leq n)$ 满足 $p_{j−1} \\lt i \\leq p_j$，则有\n\n$$a_i = \\left(b_i \\bmod \\left( r_j − l_j + 1 \\right) \\right) + l_j$$\n\n**上述数据生成方式仅是为了减少输入量大小，标准算法不依赖于该生成方式。**", "outputFormat": "输出一行一个整数，表示答案。", "hint": "【样例 1 解释】\n\n最优的划分方案为 $\\{5,1\\}, \\{7\\}, \\{9\\}, \\{9\\}$。由 $5 + 1 \\leq 7 \\leq 9 \\leq 9$ 知该方案合法。\n\n答案为 $(5 + 1)^2 + 7^2 + 9^2 + 9^2 = 247$。\n\n虽然划分方案 $\\{5\\}, \\{1\\}, \\{7\\}, \\{9\\}, \\{9\\}$ 对应的运行时间比 $247$ 小，但它不是一组合法方案，因为 $5 \\gt 1$。\n\n虽然划分方案 $\\{5\\}, \\{1,7\\}, \\{9\\}, \\{9\\}$ 合法，但该方案对应的运行时间为 $251$，比 $247$ 大。\n\n【样例 2 解释】\n\n最优的划分方案为 $\\{5\\}, \\{6\\}, \\{7\\}, \\{7\\}, \\{4,6,2\\}, \\{13\\}, \\{19,9\\}$。\n\n【数据范围】\n\n::cute-table[]{tuack}\n| 测试点编号 | $n \\leq$ | $a_i \\leq$ | $type =$ |\n| :--: | :-: | :-: | :-: |\n| $1 \\sim 3$ | $10$ | $10$ | $0$ |\n| $4 \\sim 6$ | $50$ | $10^3$ | ^ |\n| $7 \\sim 9$ | $400$ | $10^4$ | ^ |\n| $10 \\sim 16$ | $5000$ | $10^5$ | ^ |\n| $17 \\sim 22$ | $5 \\times 10^5$ | $10^6$ | ^ |\n| $23 \\sim 25$ | $4 \\times 10^7$ | $10^9$ | $1$ |\n\n对于 $type=0$ 的所有测试点，保证最后输出的答案 $\\leq 4 \\times 10^{18}$。\n\n所有测试点满足：$type \\in \\{0,1\\}$，$2 \\leq n \\leq 4 \\times 10^7$，$1 \\leq a_i \\leq 10^9$，$1 \\leq m \\leq 10^5$，$1 \\leq l_i \\leq r_i \\leq 10^9$，$0 \\leq x,y,z,b_1,b_2 \\lt 2^{30}$。", "locale": "zh-CN", "translations": {"en": {"title": "[CSP-S 2019] Partition", "background": "", "description": "In 2048, at the exam site of the 30th CSP certification, contestant Xiaoming opened the first problem. The sample of this problem has $n$ groups of testdata, numbered from $1 \\sim n$, and the size of the $i$-th testdata is $a_i$.\n\nXiaoming designed a brute-force program for this problem. For a piece of testdata of size $u$, the **running time** of the program is $u^2$. However, after the program finishes running on a piece of testdata of size $u$, it will produce wrong results on any piece of testdata whose size is **less than** $u$. The $a_i$ in the sample are not necessarily increasing, but Xiaoming wants to run the sample correctly without modifying the program. So he decided to use a very primitive solution: divide all testdata into several segments, where the indices within each segment are **continuous**. Then, merge the testdata within the same segment into new testdata whose size equals the **sum of sizes** of the original testdata in that segment. Xiaoming will make the sizes of the new testdata non-decreasing.\n\nThat is, Xiaoming needs to find some split points $1 \\leq k_1 \\lt k_2 \\lt \\cdots \\lt k_p \\lt n$ such that\n\n$$ \\sum_{i=1}^{k_1} a_i \\leq \\sum_{i=k_1+1}^{k_2} a_i \\leq \\cdots \\leq \\sum_{i=k_p+1}^{n} a_i $$\n\nNote that $p$ can be $0$, and in this case $k_0 = 0$, meaning Xiaoming can merge all testdata together and run it once.\n\nXiaoming hopes that, while running the sample correctly, the running time can be as small as possible, i.e., **minimize**:\n\n$$ \\left(\\sum_{i=1}^{k_1} a_i\\right)^2 + \\left(\\sum_{i=k_1+1}^{k_2} a_i\\right)^2 + \\cdots + \\left(\\sum_{i=k_p+1}^{n} a_i\\right)^2 $$\n\nXiaoming finds this problem very interesting and asks you for help: given $n$ and $a_i$, please compute the minimum running time of Xiaoming's program under the optimal partition.", "inputFormat": "**Because the Constraints of this problem are large, for some test points, $a_i$ will be generated inside the program.**\n\nThe first line contains two integers $n, type$. The meaning of $n$ is described above, and $type$ indicates the input method.\n\n1. If $type = 0$, then $a_i$ for this test point are **given directly**. The input then contains: on the second line, $n$ integers $a_i$ separated by spaces, representing the size of each group of testdata.\n2. If $type = 1$, then $a_i$ for this test point will be **generated specially**; the generation method is given later. The input then contains: on the second line, six integers $x, y, z, b_1, b_2, m$ separated by spaces. In the next $m$ lines, the $i$-th line $(1 \\leq i \\leq m)$ contains three positive integers $p_i, l_i, r_i$ separated by spaces.\n\nFor test points $23 \\sim 25$ with $type = 1$, $a_i$ are generated as follows:\n\nGiven integers $x, y, z, b_1, b_2, m$, and $m$ triples $(p_i, l_i, r_i)$.\n\nIt is guaranteed that $n \\geq 2$. If $n \\gt 2$, then for all $3 \\leq i \\leq n$, $b_i = (x \\times b_{i−1} + y \\times b_{i−2} + z) \\bmod 2^{30}$.\n\nIt is guaranteed that $1 \\leq p_i \\leq n$ and $p_m = n$. Let $p_0 = 0$, then $p_i$ also satisfies: for all $0 \\leq i \\lt m$, $p_i \\lt p_{i+1}$.\n\nFor all $1 \\leq j \\leq m$, if the index $i (1 \\leq i \\leq n)$ satisfies $p_{j−1} \\lt i \\leq p_j$, then\n\n$$a_i = \\left(b_i \\bmod \\left( r_j − l_j + 1 \\right) \\right) + l_j$$\n\n**The above data generation method is only to reduce the input size; the standard algorithm does not depend on this generation method.**", "outputFormat": "Output one integer in one line, representing the answer.", "hint": "[Sample 1 Explanation]\n\nThe optimal partition is $\\{5,1\\}, \\{7\\}, \\{9\\}, \\{9\\}$. Since $5 + 1 \\leq 7 \\leq 9 \\leq 9$, this partition is valid.\n\nThe answer is $(5 + 1)^2 + 7^2 + 9^2 + 9^2 = 247$.\n\nAlthough the partition $\\{5\\}, \\{1\\}, \\{7\\}, \\{9\\}, \\{9\\}$ has a running time smaller than $247$, it is not valid because $5 \\gt 1$.\n\nAlthough the partition $\\{5\\}, \\{1,7\\}, \\{9\\}, \\{9\\}$ is valid, its running time is $251$, which is larger than $247$.\n\n[Sample 2 Explanation]\n\nThe optimal partition is $\\{5\\}, \\{6\\}, \\{7\\}, \\{7\\}, \\{4,6,2\\}, \\{13\\}, \\{19,9\\}$.\n\n[Constraints]\n\n::cute-table[]{tuack}\n| Test Point ID | $n \\leq$ | $a_i \\leq$ | $type =$ |\n| :--: | :-: | :-: | :-: |\n| $1 \\sim 3$ | $10$ | $10$ | $0$ |\n| $4 \\sim 6$ | $50$ | $10^3$ | ^ |\n| $7 \\sim 9$ | $400$ | $10^4$ | ^ |\n| $10 \\sim 16$ | $5000$ | $10^5$ | ^ |\n| $17 \\sim 22$ | $5 \\times 10^5$ | $10^6$ | ^ |\n| $23 \\sim 25$ | $4 \\times 10^7$ | $10^9$ | $1$ |\n\nFor all test points with $type=0$, it is guaranteed that the final output answer $\\leq 4 \\times 10^{18}$.\n\nAll test points satisfy: $type \\in \\{0,1\\}$, $2 \\leq n \\leq 4 \\times 10^7$, $1 \\leq a_i \\leq 10^9$, $1 \\leq m \\leq 10^5$, $1 \\leq l_i \\leq r_i \\leq 10^9$, $0 \\leq x,y,z,b_1,b_2 \\lt 2^{30}$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSP-S 2019] 划分", "background": "", "description": "2048 年，第三十届 CSP 认证的考场上，作为选手的小明打开了第一题。这个题的样例有 $n$ 组数据，数据从 $1 \\sim n$ 编号，$i$ 号数据的规模为 $a_i$。\n\n小明对该题设计出了一个暴力程序，对于一组规模为 $u$ 的数据，该程序的**运行时间**为 $u^2$。然而这个程序运行完一组规模为 $u$ 的数据之后，它将在任何一组规模**小于** $u$ 的数据上运行错误。样例中的 $a_i$ 不一定递增，但小明又想在不修改程序的情况下正确运行样例，于是小明决定使用一种非常原始的解决方案：将所有数据划分成若干个数据段，段内数据编号**连续**，接着将同一段内的数据合并成新数据，其规模等于段内原数据的**规模之和**，小明将让新数据的规模能够递增。\n\n也就是说，小明需要找到一些分界点 $1 \\leq k_1 \\lt k_2 \\lt \\cdots \\lt k_p \\lt n$，使得\n\n$$ \\sum_{i=1}^{k_1} a_i \\leq \\sum_{i=k_1+1}^{k_2} a_i \\leq \\cdots \\leq \\sum_{i=k_p+1}^{n} a_i $$\n\n注意 $p$ 可以为 $0$ 且此时 $k_0 = 0$，也就是小明可以将所有数据合并在一起运行。\n\n小明希望他的程序在正确运行样例情况下，运行时间也能尽量小，也就是**最小化**：\n\n$$ \\left(\\sum_{i=1}^{k_1} a_i\\right)^2 + \\left(\\sum_{i=k_1+1}^{k_2} a_i\\right)^2 + \\cdots + \\left(\\sum_{i=k_p+1}^{n} a_i\\right)^2 $$\n\n小明觉得这个问题非常有趣，并向你请教：给定 $n$ 和 $a_i$，请你求出最优划分方案下，小明的程序的最小运行时间。", "inputFormat": "**由于本题的数据范围较大，部分测试点的 $a_i$ 将在程序内生成。**\n\n第一行两个整数 $n, type$。$n$ 的意义见题目描述，$type$ 表示输入方式。\n1. 若 $type = 0$，则该测试点的 $a_i$ **直接给出**。输入文件接下来：第二行 $n$ 个以空格分隔的整数 $a_i$，表示每组数据的规模。\n2. 若 $type = 1$，则该测试点的 $a_i$ 将**特殊生成**，生成方式见后文。输入文件接下来：第二行六个以空格分隔的整数 $x, y, z, b_1, b_2, m$。接下来 $m$ 行中，第 $i (1 \\leq i \\leq m)$ 行包含三个以空格分隔的正整数 $p_i, l_i, r_i$。\n\n对于 $type = 1$ 的 $23 \\sim 25$ 号测试点，$a_i$ 的生成方式如下：\n\n给定整数 $x, y, z, b_1, b_2, m$，以及 $m$ 个三元组 $(p_i, l_i, r_i)$。\n\n保证 $n \\geq 2$。若 $n \\gt 2$，则 $\\forall 3 \\leq i \\leq n, b_i = (x \\times b_{i−1} + y \\times b_{i−2} + z) \\bmod 2^{30}$。\n\n保证 $1 \\leq p_i \\leq n, p_m = n$。令 $p_0 = 0$，则 $p_i$ 还满足 $\\forall 0 \\leq i \\lt m$ 有 $p_i \\lt p_{i+1}$。\n\n对于所有 $1 \\leq j \\leq m$，若下标值 $i (1 \\leq i \\leq n)$ 满足 $p_{j−1} \\lt i \\leq p_j$，则有\n\n$$a_i = \\left(b_i \\bmod \\left( r_j − l_j + 1 \\right) \\right) + l_j$$\n\n**上述数据生成方式仅是为了减少输入量大小，标准算法不依赖于该生成方式。**", "outputFormat": "输出一行一个整数，表示答案。", "hint": "【样例 1 解释】\n\n最优的划分方案为 $\\{5,1\\}, \\{7\\}, \\{9\\}, \\{9\\}$。由 $5 + 1 \\leq 7 \\leq 9 \\leq 9$ 知该方案合法。\n\n答案为 $(5 + 1)^2 + 7^2 + 9^2 + 9^2 = 247$。\n\n虽然划分方案 $\\{5\\}, \\{1\\}, \\{7\\}, \\{9\\}, \\{9\\}$ 对应的运行时间比 $247$ 小，但它不是一组合法方案，因为 $5 \\gt 1$。\n\n虽然划分方案 $\\{5\\}, \\{1,7\\}, \\{9\\}, \\{9\\}$ 合法，但该方案对应的运行时间为 $251$，比 $247$ 大。\n\n【样例 2 解释】\n\n最优的划分方案为 $\\{5\\}, \\{6\\}, \\{7\\}, \\{7\\}, \\{4,6,2\\}, \\{13\\}, \\{19,9\\}$。\n\n【数据范围】\n\n::cute-table[]{tuack}\n| 测试点编号 | $n \\leq$ | $a_i \\leq$ | $type =$ |\n| :--: | :-: | :-: | :-: |\n| $1 \\sim 3$ | $10$ | $10$ | $0$ |\n| $4 \\sim 6$ | $50$ | $10^3$ | ^ |\n| $7 \\sim 9$ | $400$ | $10^4$ | ^ |\n| $10 \\sim 16$ | $5000$ | $10^5$ | ^ |\n| $17 \\sim 22$ | $5 \\times 10^5$ | $10^6$ | ^ |\n| $23 \\sim 25$ | $4 \\times 10^7$ | $10^9$ | $1$ |\n\n对于 $type=0$ 的所有测试点，保证最后输出的答案 $\\leq 4 \\times 10^{18}$。\n\n所有测试点满足：$type \\in \\{0,1\\}$，$2 \\leq n \\leq 4 \\times 10^7$，$1 \\leq a_i \\leq 10^9$，$1 \\leq m \\leq 10^5$，$1 \\leq l_i \\leq r_i \\leq 10^9$，$0 \\leq x,y,z,b_1,b_2 \\lt 2^{30}$。", "locale": "zh-CN"}}}
{"pid": "P5666", "type": "P", "difficulty": 6, "samples": [["2\n5\n1 2\n2 3\n2 4\n3 5\n7\n1 2\n1 3\n1 4\n3 5\n3 6\n6 7", "32\n56"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2019", "树上启发式合并", "树形 DP", "CSP-S 提高级"], "title": "[CSP-S 2019] 树的重心", "background": "", "description": "小简单正在学习离散数学，今天的内容是图论基础，在课上他做了如下两条笔记：\n1. 一个大小为 $n$ 的树由 $n$ 个结点与 $n - 1$ 条无向边构成，且满足任意两个结点间**有且仅有**一条简单路径。在树中删去一个结点及与它关联的边，树将分裂为若干个子树；而在树中删去一条边（保留关联结点，下同），树将分裂为**恰好**两个子树。\n2. 对于一个大小为 $n$ 的树与任意一个树中结点 $c$，称 $c$ 是该树的**重心**当且仅当在树中删去 $c$ 及与它关联的边后，分裂出的所有子树的大小均**不超过** $\\lfloor \\frac{n}{2} \\rfloor$（其中 $\\lfloor x \\rfloor$ 是下取整函数）。对于包含至少一个结点的树，它的重心只可能有 1 或 2 个。\n\n课后老师给出了一个大小为 $n$ 的树 $S$，树中结点从 $1 \\sim n$ 编号。小简单的课后作业是求出 $S$ 单独删去每条边后，分裂出的两个子树的重心编号和之和。即：\n\n$$\n\\sum_{(u,v) \\in E} \\left( \\sum_{1 \\leq x \\leq n \\atop 且 x 号点是 S'_u 的重心} x + \\sum_{1 \\leq y \\leq n \\atop 且 y 号点是 S'_v 的重心} y \\right)\n$$\n\n上式中，$E$ 表示树 $S$ 的边集，$(u,v)$ 表示一条连接 $u$ 号点和 $v$ 号点的边。$S'_u$ 与 $S'_v$ 分别表示树 $S$ 删去边 $(u,v)$ 后，$u$ 号点与 $v$ 号点所在的被分裂出的子树。\n\n小简单觉得作业并不简单，只好向你求助，请你教教他。\n", "inputFormat": "**本题包含多组测试数据。**\n\n第一行一个整数 $T$ 表示数据组数。\n\n接下来依次给出每组输入数据，对于每组数据：\n\n第一行一个整数 $n$ 表示树 $S$ 的大小。\n\n接下来 $n − 1$ 行，每行两个以空格分隔的整数 $u_i$，$v_i$，表示树中的一条边 $(u_i,v_i)$。", "outputFormat": "共 $T$ 行，每行一个整数，第 $i$ 行的整数表示：第 $i$ 组数据给出的树单独删去每条边后，分裂出的两个子树的重心编号和之和。", "hint": "【样例 1 解释】\n\n对于第一组数据：\n\n删去边 $(1,2)$，1 号点所在子树重心编号为 $\\{1\\}$，2 号点所在子树重心编号为 $\\{2,3\\}$。\n\n删去边 $(2,3)$，2 号点所在子树重心编号为 $\\{2\\}$，3 号点所在子树重心编号为 $\\{3,5\\}$。\n\n删去边 $(2,4)$，2 号点所在子树重心编号为 $\\{2,3\\}$，4 号点所在子树重心编号为 $\\{4\\}$。\n\n删去边 $(3,5)$，3 号点所在子树重心编号为 $\\{2\\}$，5 号点所在子树重心编号为 $\\{5\\}$。\n\n因此答案为 $1 + 2 + 3 + 2 + 3 + 5 + 2 + 3 + 4 + 2 + 5 = 32$。\n\n【数据范围】\n\n| 测试点编号 | $n =$ | 特殊性质 |\n| :----------- | :----------- | :----------- |\n| $1 \\sim 2$ | $7$ | 无 |\n| $3 \\sim 5$ | $199$ | 无 |\n| $6 \\sim 8$ | $1999$ | 无 |\n| $9 \\sim 11$ | $49991$ | A |\n| $12 \\sim 15$ | $262143$ | B |\n| $16$ | $99995$ | 无 |\n| $17 \\sim 18$ | $199995$ | 无 |\n| $19 \\sim 20$ | $299995$ | 无 |\n\n\n表中特殊性质一栏，两个变量的含义为存在一个 $1 \\sim n$ 的排列  $p_i (1 \\leq i \\leq n)$，使得：\n- A：树的形态是一条链。即 $\\forall 1 \\leq i \\lt n$，存在一条边 $(p_i, p_{i + 1})$。\n- B：树的形态是一个完美二叉树。即 $\\forall 1 \\leq i \\leq \\frac{n-1}{2}$ ，存在两条边 $(p_i, p_{2i})$ 与 $(p_i, p_{2i+1})$。\n\n对于所有测试点：$1 \\leq T \\leq 5 , 1 \\leq u_i,v_i \\leq n$。保证给出的图是一个树。", "locale": "zh-CN", "translations": {"en": {"title": "[CSP-S 2019] Tree Centroid", "background": "", "description": "Xiaojiandan is learning discrete mathematics. Today’s topic is basic graph theory, and in class he wrote down the following two notes:\n\n1. A tree of size $n$ consists of $n$ nodes and $n - 1$ undirected edges, and between any two nodes there exists **exactly one** simple path. If you delete one node in a tree and all edges incident to it, the tree will split into several subtrees. If you delete one edge in a tree (keeping its incident nodes; same below), the tree will split into **exactly** two subtrees.\n2. For a tree of size $n$ and any node $c$ in the tree, $c$ is called a **centroid** of the tree if and only if, after deleting $c$ and all edges incident to it, the sizes of all resulting subtrees are **no more than** $\\lfloor \\frac{n}{2} \\rfloor$ (where $\\lfloor x \\rfloor$ is the floor function). For any tree with at least one node, it can have only 1 or 2 centroids.\n\nAfter class, the teacher gave a tree $S$ of size $n$, with nodes numbered from $1$ to $n$. Xiaojiandan’s homework is to compute, for every edge deleted individually from $S$, the sum of the centroid node labels of the two resulting subtrees. That is:\n\n$$\n\\sum_{(u,v) \\in E} \\left( \\sum_{1 \\leq x \\leq n \\atop 且 x 号点是 S'_u 的重心} x + \\sum_{1 \\leq y \\leq n \\atop 且 y 号点是 S'_v 的重心} y \\right)\n$$\n\nIn the expression above, $E$ denotes the edge set of tree $S$, and $(u,v)$ denotes an edge connecting node $u$ and node $v$. $S'_u$ and $S'_v$ denote, respectively, the two subtrees containing node $u$ and node $v$ after deleting edge $(u,v)$ from $S$.\n\nXiaojiandan finds this homework not simple at all, so he asks you for help. Please teach him.", "inputFormat": "**This problem contains multiple test cases.**\n\nThe first line contains an integer $T$, indicating the number of test cases.\n\nThen the input for each test case is given as follows:\n\nThe first line contains an integer $n$, indicating the size of the tree $S$.\n\nThe next $n - 1$ lines each contain two integers $u_i$ and $v_i$ separated by a space, representing an edge $(u_i,v_i)$ in the tree.", "outputFormat": "Output $T$ lines. Each line contains one integer. The integer on line $i$ means: for the tree given in test case $i$, after deleting each edge individually, the sum of the centroid node labels of the two resulting subtrees.", "hint": "[Sample 1 Explanation]\n\nFor the first test case:\n\nDelete edge $(1,2)$. The centroid labels of the subtree containing node 1 are $\\{1\\}$. The centroid labels of the subtree containing node 2 are $\\{2,3\\}$.\n\nDelete edge $(2,3)$. The centroid labels of the subtree containing node 2 are $\\{2\\}$. The centroid labels of the subtree containing node 3 are $\\{3,5\\}$.\n\nDelete edge $(2,4)$. The centroid labels of the subtree containing node 2 are $\\{2,3\\}$. The centroid labels of the subtree containing node 4 are $\\{4\\}$.\n\nDelete edge $(3,5)$. The centroid labels of the subtree containing node 3 are $\\{2\\}$. The centroid labels of the subtree containing node 5 are $\\{5\\}$.\n\nTherefore, the answer is $1 + 2 + 3 + 2 + 3 + 5 + 2 + 3 + 4 + 2 + 5 = 32$.\n\n[Constraints]\n\n| Test Point ID | $n =$ | Special Property |\n| :----------- | :----------- | :----------- |\n| $1 \\sim 2$ | $7$ | None |\n| $3 \\sim 5$ | $199$ | None |\n| $6 \\sim 8$ | $1999$ | None |\n| $9 \\sim 11$ | $49991$ | A |\n| $12 \\sim 15$ | $262143$ | B |\n| $16$ | $99995$ | None |\n| $17 \\sim 18$ | $199995$ | None |\n| $19 \\sim 20$ | $299995$ | None |\n\nIn the table, the meanings of the two special properties are that there exists a permutation $p_i (1 \\leq i \\leq n)$ of $1 \\sim n$ such that:\n\n- A: The tree is a chain. That is, $\\forall 1 \\leq i \\lt n$, there exists an edge $(p_i, p_{i + 1})$.\n- B: The tree is a perfect binary tree. That is, $\\forall 1 \\leq i \\leq \\frac{n-1}{2}$, there exist two edges $(p_i, p_{2i})$ and $(p_i, p_{2i+1})$.\n\nFor all test points: $1 \\leq T \\leq 5$, $1 \\leq u_i,v_i \\leq n$. It is guaranteed that the given graph is a tree.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CSP-S 2019] 树的重心", "background": "", "description": "小简单正在学习离散数学，今天的内容是图论基础，在课上他做了如下两条笔记：\n1. 一个大小为 $n$ 的树由 $n$ 个结点与 $n - 1$ 条无向边构成，且满足任意两个结点间**有且仅有**一条简单路径。在树中删去一个结点及与它关联的边，树将分裂为若干个子树；而在树中删去一条边（保留关联结点，下同），树将分裂为**恰好**两个子树。\n2. 对于一个大小为 $n$ 的树与任意一个树中结点 $c$，称 $c$ 是该树的**重心**当且仅当在树中删去 $c$ 及与它关联的边后，分裂出的所有子树的大小均**不超过** $\\lfloor \\frac{n}{2} \\rfloor$（其中 $\\lfloor x \\rfloor$ 是下取整函数）。对于包含至少一个结点的树，它的重心只可能有 1 或 2 个。\n\n课后老师给出了一个大小为 $n$ 的树 $S$，树中结点从 $1 \\sim n$ 编号。小简单的课后作业是求出 $S$ 单独删去每条边后，分裂出的两个子树的重心编号和之和。即：\n\n$$\n\\sum_{(u,v) \\in E} \\left( \\sum_{1 \\leq x \\leq n \\atop 且 x 号点是 S'_u 的重心} x + \\sum_{1 \\leq y \\leq n \\atop 且 y 号点是 S'_v 的重心} y \\right)\n$$\n\n上式中，$E$ 表示树 $S$ 的边集，$(u,v)$ 表示一条连接 $u$ 号点和 $v$ 号点的边。$S'_u$ 与 $S'_v$ 分别表示树 $S$ 删去边 $(u,v)$ 后，$u$ 号点与 $v$ 号点所在的被分裂出的子树。\n\n小简单觉得作业并不简单，只好向你求助，请你教教他。\n", "inputFormat": "**本题包含多组测试数据。**\n\n第一行一个整数 $T$ 表示数据组数。\n\n接下来依次给出每组输入数据，对于每组数据：\n\n第一行一个整数 $n$ 表示树 $S$ 的大小。\n\n接下来 $n − 1$ 行，每行两个以空格分隔的整数 $u_i$，$v_i$，表示树中的一条边 $(u_i,v_i)$。", "outputFormat": "共 $T$ 行，每行一个整数，第 $i$ 行的整数表示：第 $i$ 组数据给出的树单独删去每条边后，分裂出的两个子树的重心编号和之和。", "hint": "【样例 1 解释】\n\n对于第一组数据：\n\n删去边 $(1,2)$，1 号点所在子树重心编号为 $\\{1\\}$，2 号点所在子树重心编号为 $\\{2,3\\}$。\n\n删去边 $(2,3)$，2 号点所在子树重心编号为 $\\{2\\}$，3 号点所在子树重心编号为 $\\{3,5\\}$。\n\n删去边 $(2,4)$，2 号点所在子树重心编号为 $\\{2,3\\}$，4 号点所在子树重心编号为 $\\{4\\}$。\n\n删去边 $(3,5)$，3 号点所在子树重心编号为 $\\{2\\}$，5 号点所在子树重心编号为 $\\{5\\}$。\n\n因此答案为 $1 + 2 + 3 + 2 + 3 + 5 + 2 + 3 + 4 + 2 + 5 = 32$。\n\n【数据范围】\n\n| 测试点编号 | $n =$ | 特殊性质 |\n| :----------- | :----------- | :----------- |\n| $1 \\sim 2$ | $7$ | 无 |\n| $3 \\sim 5$ | $199$ | 无 |\n| $6 \\sim 8$ | $1999$ | 无 |\n| $9 \\sim 11$ | $49991$ | A |\n| $12 \\sim 15$ | $262143$ | B |\n| $16$ | $99995$ | 无 |\n| $17 \\sim 18$ | $199995$ | 无 |\n| $19 \\sim 20$ | $299995$ | 无 |\n\n\n表中特殊性质一栏，两个变量的含义为存在一个 $1 \\sim n$ 的排列  $p_i (1 \\leq i \\leq n)$，使得：\n- A：树的形态是一条链。即 $\\forall 1 \\leq i \\lt n$，存在一条边 $(p_i, p_{i + 1})$。\n- B：树的形态是一个完美二叉树。即 $\\forall 1 \\leq i \\leq \\frac{n-1}{2}$ ，存在两条边 $(p_i, p_{2i})$ 与 $(p_i, p_{2i+1})$。\n\n对于所有测试点：$1 \\leq T \\leq 5 , 1 \\leq u_i,v_i \\leq n$。保证给出的图是一个树。", "locale": "zh-CN"}}}
{"pid": "P5667", "type": "P", "difficulty": 6, "samples": [["5 6\n1 1 4 5 1 4", "54 232 673 1579 3232 6007"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["快速傅里叶变换 FFT", "快速数论变换 NTT", "拉格朗日插值法"], "title": "拉格朗日插值2", "background": "", "description": "给定一个不超过 $n$ 次的多项式的 $n+1$ 个点值 $f(0),f(1) \\dots f(n)$，和一个正整数 $m$，求 $f(m),f(m+1) \\dots f(m+n)$。\n\n答案对 $998244353$ 取模。", "inputFormat": "第一行两个正整数 $n,m$，意义如题目描述。  \n第二行 $n+1$ 个整数，表示 $f(0),f(1) \\dots f(n)$。", "outputFormat": "输出一行 $n+1$ 个整数，表示 $f(m),f(m+1) \\dots f(m+n)$。", "hint": "【数据范围】     \n对于 $100\\%$ 的数据：  \n$1 \\le n \\le 160000$，$n < m \\le 10^8$，$0 \\le f(i) < 998244353$。", "locale": "zh-CN", "translations": {"en": {"title": "Lagrange Interpolation 2", "background": "", "description": "Given the $n + 1$ point values $f(0), f(1) \\dots f(n)$ of a polynomial of degree at most $n$, and a positive integer $m$, find $f(m), f(m + 1) \\dots f(m + n)$.\n\nThe answer should be taken modulo $998244353$.", "inputFormat": "The first line contains two positive integers $n, m$, with the meanings as described above.  \nThe second line contains $n + 1$ integers, representing $f(0), f(1) \\dots f(n)$.", "outputFormat": "Output one line with $n + 1$ integers, representing $f(m), f(m + 1) \\dots f(m + n)$.", "hint": "Constraints  \nFor $100\\%$ of the testdata:  \n$1 \\le n \\le 160000$, $n < m \\le 10^8$, $0 \\le f(i) < 998244353$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "拉格朗日插值2", "background": "", "description": "给定一个不超过 $n$ 次的多项式的 $n+1$ 个点值 $f(0),f(1) \\dots f(n)$，和一个正整数 $m$，求 $f(m),f(m+1) \\dots f(m+n)$。\n\n答案对 $998244353$ 取模。", "inputFormat": "第一行两个正整数 $n,m$，意义如题目描述。  \n第二行 $n+1$ 个整数，表示 $f(0),f(1) \\dots f(n)$。", "outputFormat": "输出一行 $n+1$ 个整数，表示 $f(m),f(m+1) \\dots f(m+n)$。", "hint": "【数据范围】     \n对于 $100\\%$ 的数据：  \n$1 \\le n \\le 160000$，$n < m \\le 10^8$，$0 \\le f(i) < 998244353$。", "locale": "zh-CN"}}}
{"pid": "P5668", "type": "P", "difficulty": 7, "samples": [["2\n3 531441 330750\n5 304128 1", "27\n264 19947 39630 59313 78996 98679 118362 138045 157728 177411 197094 216777 236460 256143 275826 295509 315192 334875 354558 374241 393924 413607 433290 452973 472656 492339 512022\n5\n1 82945 138241 165889 193537"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "数论", "洛谷原创", "O2优化", "模板题"], "title": "【模板】N 次剩余", "background": "", "description": "你需要解方程 $x^n\\equiv k\\pmod m$，其中 $x\\in [0,m-1]$。", "inputFormat": "第一行正整数 $T$ 为数据组数。\n\n每组数据三个正整数 $n,m,k$。", "outputFormat": "每组数据一或两行：\n\n第一行为不同解的个数 $c$。\n\n若 $c\\neq 0$，接下来第二行共 $c$ 个整数，升序输出所有可能解，空格隔开。\n\n数据保证 $\\sum c_i \\le 10^6$。", "hint": "对于 $100 \\%$ 的数据，$1\\le T\\le 100$，$1\\le n\\le 10^9$，$0\\le k \\lt m\\le 10^9$。\n\n设 $m$ 的唯一分解形式为 $m=\\prod_{i=1}^s p_i^{q_i}$，保证方程 $x^n\\equiv k\\pmod{p_i^{q_i}}$ 在 $[0,p_i^{q_i})$ 中的解数 $\\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] $n$-th Power Residue", "background": "", "description": "You need to solve the equation $x^n\\equiv k\\pmod m$, where $x\\in [0,m-1]$.", "inputFormat": "The first line contains a positive integer $T$, the number of test cases.\n\nEach test case contains three positive integers $n, m, k$.", "outputFormat": "For each test case, output one or two lines:\n\nThe first line contains the number of distinct solutions $c$.\n\nIf $c\\neq 0$, then output a second line with $c$ integers, in increasing order, listing all possible solutions separated by spaces.\n\nIt is guaranteed that $\\sum c_i \\le 10^6$.", "hint": "For $100\\%$ of the testdata, $1\\le T\\le 100$, $1\\le n\\le 10^9$, $0\\le k \\lt m\\le 10^9$.\n\nLet the unique factorization of $m$ be $m=\\prod_{i=1}^s p_i^{q_i}$. It is guaranteed that the number of solutions to $x^n\\equiv k\\pmod{p_i^{q_i}}$ in $[0,p_i^{q_i})$ is $\\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】N 次剩余", "background": "", "description": "你需要解方程 $x^n\\equiv k\\pmod m$，其中 $x\\in [0,m-1]$。", "inputFormat": "第一行正整数 $T$ 为数据组数。\n\n每组数据三个正整数 $n,m,k$。", "outputFormat": "每组数据一或两行：\n\n第一行为不同解的个数 $c$。\n\n若 $c\\neq 0$，接下来第二行共 $c$ 个整数，升序输出所有可能解，空格隔开。\n\n数据保证 $\\sum c_i \\le 10^6$。", "hint": "对于 $100 \\%$ 的数据，$1\\le T\\le 100$，$1\\le n\\le 10^9$，$0\\le k \\lt m\\le 10^9$。\n\n设 $m$ 的唯一分解形式为 $m=\\prod_{i=1}^s p_i^{q_i}$，保证方程 $x^n\\equiv k\\pmod{p_i^{q_i}}$ 在 $[0,p_i^{q_i})$ 中的解数 $\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P5669", "type": "P", "difficulty": 7, "samples": [["5 3\n1 4 4 5 4\n1 2\n2 3\n3 4\n2 5\n1 2 3\n2 1 3\n1 3 2\n", "1\n5\n1"], ["10 5\n3 4 3 8 9 3 2 8 5 7\n1 2\n2 3\n3 4\n4 5\n5 6\n4 7\n4 8\n8 9\n8 10\n1 1 10\n2 3 5\n2 7 5\n2 5 4\n1 8 6", "4\n34\n61\n45\n3"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2018", "各省省选", "山东"], "title": "[SDOI2018] 原题识别-改", "background": "蒟蒻$\\color{grey}{\\text{suwakow}}$花了三天时间，研究出了[这道题](https://www.luogu.org/problem/P4618)的**线性空间**，且不依赖输入的随机性的一种优（du）秀（liu）做法。于是她决定拿出来毒瘤一下大家。", "description": "有一棵$n$个点的有根树，根节点编号为$1$，且编号为$i$的节点有颜色$a_i$。你需要支持$m$次询问。询问有以下两种格式：\n\n- $1~x~y$：询问树上编号为$x$的节点到编号为$y$的节点的最短路径中，不同的颜色有多少种。\n\n- $2~a~b$：在节点$a$到根节点的路径中随机选择一个点$x$，在节点$b$到根节点的路径中随机选择一个点$y$，求询问 $1~x~y$ 的答案期望。（路径包含$a$, $b$和根节点）\n\n对于询问$2$，设答案为$\\mathrm{ans}$，$a$到根节点的路径经过的点数为$\\mathrm{cnt_a}$，$b$到根节点的路径经过的点数为$\\mathrm{cnt_b}$，你只需要输出$\\mathrm{ans}\\cdot \\mathrm{cnt_a}\\cdot \\mathrm{cnt_b}$。\n", "inputFormat": "**注意：输入格式与原题不同**\n\n每个测试点仅包含一组数据。\n\n输入数据的第一行包含两个非负整数$n$, $m$，表示节点个数和询问次数。\n\n接下来一行包含$n$个正整数，第$i$个正整数为$a_i$，表示节点$i$的颜色。\n\n接下来$n-1$行，每行包含两个整数$u$, $v$，表示编号为$u$的节点和编号为$v$的节点之间存在一条边。保证输入的边构成一棵树。\n\n接下来$m$行，每行包含一个询问。询问的格式和意义见题目描述。", "outputFormat": "输出$m$行，第$i$行包含一个非负整数，表示第$i$次询问的答案。", "hint": "对于所有数据，保证$1\\leq a_1, a_2, \\ldots, a_n\\leq n\\leq 10^5$, $1\\leq m\\leq 2\\times 10^5$。保证输入的边构成一棵树。\n\n子任务$1$（$30$分）：保证不存在询问$2$。\n\n子任务$2$（$30$分）：保证对于每一条边都有$v=u+1$。\n\n子任务$3$（$40$分）：没有任何附加的限制。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2018] Original Problem Recognition - Modified.", "background": "Rookie $\\color{grey}{\\text{suwakow}}$ spent three days and came up with an excellent (but rather nasty) solution for **linear space** for [this problem](https://www.luogu.org/problem/P4618), which does not rely on randomness in the input. So she decided to use it to torture everyone.", "description": "There is a rooted tree with $n$ nodes. The root is node $1$, and node $i$ has color $a_i$. You need to handle $m$ queries of the following two types:\n\n- $1~x~y$: Query how many different colors appear on the shortest path from node $x$ to node $y$ in the tree.\n\n- $2~a~b$: Randomly choose a node $x$ on the path from node $a$ to the root, and randomly choose a node $y$ on the path from node $b$ to the root. Compute the expected value of the answer to query $1~x~y$. (The paths include $a$, $b$, and the root.)\n\nFor query type $2$, let the answer be $\\mathrm{ans}$. Let $\\mathrm{cnt_a}$ be the number of nodes on the path from $a$ to the root, and let $\\mathrm{cnt_b}$ be the number of nodes on the path from $b$ to the root. You only need to output $\\mathrm{ans}\\cdot \\mathrm{cnt_a}\\cdot \\mathrm{cnt_b}$.", "inputFormat": "**Note: The input format is different from the original problem.**\n\nEach test point contains only one test case.\n\nThe first line contains two non-negative integers $n$, $m$, representing the number of nodes and the number of queries.\n\nThe next line contains $n$ positive integers. The $i$-th positive integer is $a_i$, representing the color of node $i$.\n\nThe next $n-1$ lines each contain two integers $u$, $v$, indicating that there is an edge between node $u$ and node $v$. It is guaranteed that these edges form a tree.\n\nThe next $m$ lines each contain one query. The format and meaning of the queries are given in the description.", "outputFormat": "Output $m$ lines. The $i$-th line contains one non-negative integer, representing the answer to the $i$-th query.", "hint": "For all data, it is guaranteed that $1\\leq a_1, a_2, \\ldots, a_n\\leq n\\leq 10^5$, $1\\leq m\\leq 2\\times 10^5$. It is guaranteed that the input edges form a tree.\n\nSubtask $1$ ($30$ points): There are no type $2$ queries.\n\nSubtask $2$ ($30$ points): For every edge, $v=u+1$.\n\nSubtask $3$ ($40$ points): There are no additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2018] 原题识别-改", "background": "蒟蒻$\\color{grey}{\\text{suwakow}}$花了三天时间，研究出了[这道题](https://www.luogu.org/problem/P4618)的**线性空间**，且不依赖输入的随机性的一种优（du）秀（liu）做法。于是她决定拿出来毒瘤一下大家。", "description": "有一棵$n$个点的有根树，根节点编号为$1$，且编号为$i$的节点有颜色$a_i$。你需要支持$m$次询问。询问有以下两种格式：\n\n- $1~x~y$：询问树上编号为$x$的节点到编号为$y$的节点的最短路径中，不同的颜色有多少种。\n\n- $2~a~b$：在节点$a$到根节点的路径中随机选择一个点$x$，在节点$b$到根节点的路径中随机选择一个点$y$，求询问 $1~x~y$ 的答案期望。（路径包含$a$, $b$和根节点）\n\n对于询问$2$，设答案为$\\mathrm{ans}$，$a$到根节点的路径经过的点数为$\\mathrm{cnt_a}$，$b$到根节点的路径经过的点数为$\\mathrm{cnt_b}$，你只需要输出$\\mathrm{ans}\\cdot \\mathrm{cnt_a}\\cdot \\mathrm{cnt_b}$。\n", "inputFormat": "**注意：输入格式与原题不同**\n\n每个测试点仅包含一组数据。\n\n输入数据的第一行包含两个非负整数$n$, $m$，表示节点个数和询问次数。\n\n接下来一行包含$n$个正整数，第$i$个正整数为$a_i$，表示节点$i$的颜色。\n\n接下来$n-1$行，每行包含两个整数$u$, $v$，表示编号为$u$的节点和编号为$v$的节点之间存在一条边。保证输入的边构成一棵树。\n\n接下来$m$行，每行包含一个询问。询问的格式和意义见题目描述。", "outputFormat": "输出$m$行，第$i$行包含一个非负整数，表示第$i$次询问的答案。", "hint": "对于所有数据，保证$1\\leq a_1, a_2, \\ldots, a_n\\leq n\\leq 10^5$, $1\\leq m\\leq 2\\times 10^5$。保证输入的边构成一棵树。\n\n子任务$1$（$30$分）：保证不存在询问$2$。\n\n子任务$2$（$30$分）：保证对于每一条边都有$v=u+1$。\n\n子任务$3$（$40$分）：没有任何附加的限制。\n", "locale": "zh-CN"}}}
{"pid": "P5670", "type": "P", "difficulty": 6, "samples": [["10 2 10\n0 1 0 0 1 0 2 2 0 1 \n2 3 9\n2 1 5\n1 9 9 0\n1 3 7 2\n1 1 6 3\n2 1 10\n2 6 7\n2 3 6\n1 3 9 2\n1 3 9 3\n", "1\n0\n3\n1\n3\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["枚举", "分块", "位运算"], "title": "秘籍-反复异或", "background": "", "description": "给定一个长为 $n$ 的序列，支持操作：\n\n- `1 l r x`：将区间 $[l,r]$ 的所有元素加 $x$。\n- `2 l r` ：查询区间 $[l,r]$ 中所有元素异或和的后 $m$ 个二进制位的值。", "inputFormat": "第一行三个正整数 $n,m,q$，表示序列长度，位数，操作数。\n\n第二行 $n$ 个非负整数，表示原始序列 $a_i$。\n\n接下来 $q$ 行，每行若干个非负整数表示一个操作。", "outputFormat": "对于每个 $2$ 操作输出一行，一个非负整数表示答案。", "hint": "【数据范围】   \n本题共 $10$ 个测试点。\n\n对于测试点 $1 \\sim 3$，$1\\le n,q \\le 1000$；    \n对于测试点 $4,5$，$1 \\le m \\le 5$；   \n对于测试点 $6 \\sim 10$，设 $k$ 为测试点编号，有 $m=k$。  \n\n对于 $100\\%$ 的数据，$1 \\le n,q \\le 10^5$，$1\\le m \\le 10$，$0\\le a_i,x < 2^m$。\n\n**请注意常数优化。**", "locale": "zh-CN", "translations": {"en": {"title": "Secret Manual - Repeated XOR", "background": "", "description": "Given a sequence of length $n$, support the following operations:\n\n- `1 l r x`: Add $x$ to all elements in the interval $[l, r]$.\n- `2 l r`: Query the value of the last $m$ binary bits of the XOR sum of all elements in the interval $[l, r]$.", "inputFormat": "The first line contains three positive integers $n, m, q$, representing the sequence length, the number of bits, and the number of operations.\n\nThe second line contains $n$ non-negative integers, representing the original sequence $a_i$.\n\nThe next $q$ lines each contain several non-negative integers describing an operation.", "outputFormat": "For each operation of type `2`, output one line containing a non-negative integer representing the answer.", "hint": "Constraints  \nThis problem has $10$ test points.\n\nFor test points $1 \\sim 3$, $1 \\le n, q \\le 1000$.  \nFor test points $4, 5$, $1 \\le m \\le 5$.  \nFor test points $6 \\sim 10$, let $k$ be the test point index, then $m = k$.\n\nFor $100\\%$ of the testdata, $1 \\le n, q \\le 10^5$, $1 \\le m \\le 10$, and $0 \\le a_i, x < 2^m$.\n\n**Please pay attention to constant optimization.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "秘籍-反复异或", "background": "", "description": "给定一个长为 $n$ 的序列，支持操作：\n\n- `1 l r x`：将区间 $[l,r]$ 的所有元素加 $x$。\n- `2 l r` ：查询区间 $[l,r]$ 中所有元素异或和的后 $m$ 个二进制位的值。", "inputFormat": "第一行三个正整数 $n,m,q$，表示序列长度，位数，操作数。\n\n第二行 $n$ 个非负整数，表示原始序列 $a_i$。\n\n接下来 $q$ 行，每行若干个非负整数表示一个操作。", "outputFormat": "对于每个 $2$ 操作输出一行，一个非负整数表示答案。", "hint": "【数据范围】   \n本题共 $10$ 个测试点。\n\n对于测试点 $1 \\sim 3$，$1\\le n,q \\le 1000$；    \n对于测试点 $4,5$，$1 \\le m \\le 5$；   \n对于测试点 $6 \\sim 10$，设 $k$ 为测试点编号，有 $m=k$。  \n\n对于 $100\\%$ 的数据，$1 \\le n,q \\le 10^5$，$1\\le m \\le 10$，$0\\le a_i,x < 2^m$。\n\n**请注意常数优化。**", "locale": "zh-CN"}}}
{"pid": "P5671", "type": "P", "difficulty": 2, "samples": [["60 1 1", "30 60\n1.41421"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "「SWTR-2」Triangles", "background": "小 $\\mathrm{A}$ 在学数学。", "description": "他遇到了两个谜题：\n\n- 在一个平面内，**线段** $DE$ 与**直线** $FG$ 相交于点 $O$，已知 $\\angle DOF=x^{\\circ}$，请你在**直线** $FG$ 上找一点 $P$，使得 $\\triangle DOP$ 为**等腰**三角形，求 $\\angle D$ 的度数。（如果答案不是整数，则保留 $1$ 位小数）\n\n- 已知一个**直角三角形**的两条边分别为 $m,n$，求第三条边的长度（保留 $5$ 位小数）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qjle5b4c.png)\n\n写一个程序求出问题的答案。", "inputFormat": "一行三个**正整数**，分别为 $x,m,n$。", "outputFormat": "输出两行，第一行为第一问的答案，第二行为第二问的答案。\n\n如果有多解，请用**空格**隔开，且**从小到大**输出。", "hint": "---\n\n### 样例说明\n\n问题 $1$：\n\n- 当点 $P$ 在点 $O$ 左边时，形成的 $\\triangle DOP$ 为等边三角形，$\\angle D=60^{\\circ}$。\n\n- 当点 $P$ 在点 $O$ 右边时，形成的 $\\triangle DOP$ 中，$\\angle DOP=180^{\\circ}-60^{\\circ}=120^{\\circ}$，为顶角，$\\angle D=(180^{\\circ}-120^{\\circ})/2=30^{\\circ}$。\n\n问题 $2$：\n\n第三条边为斜边，长度为 $\\sqrt{1^2+1^2}=\\sqrt{2}=1.41421\\dots$。\n\n---\n\n### 数据范围与约定\n\n$x<90,m\\leq n\\leq 10^9$。\n\n---\n\n### 出题组提示：\n\n**方法千万条，审题第一条，多解不考虑，爆零两行泪。**", "locale": "zh-CN", "translations": {"en": {"title": "\"SWTR-2\" Triangles", "background": "Little $\\mathrm{A}$ is learning math.", "description": "He encountered two puzzles:\n\n- In a plane, the **line segment** $DE$ intersects the **line** $FG$ at point $O$. Given $\\angle DOF=x^{\\circ}$, find a point $P$ on the **line** $FG$ such that $\\triangle DOP$ is an **isosceles** triangle, and compute the measure of $\\angle D$. (If the answer is not an integer, keep $1$ decimal place.)\n\n- Given a **right triangle** with two sides $m,n$, find the length of the third side (keep $5$ decimal places).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qjle5b4c.png)\n\nWrite a program to compute the answers to the problems.", "inputFormat": "One line with three **positive integers**: $x,m,n$.", "outputFormat": "Output two lines. The first line is the answer to the first question, and the second line is the answer to the second question.\n\nIf there are multiple solutions, separate them with **spaces** and output them in **increasing** order.", "hint": "---\n\n### Sample Explanation\n\nProblem $1$:\n\n- When point $P$ is to the left of point $O$, the formed $\\triangle DOP$ is an equilateral triangle, so $\\angle D=60^{\\circ}$.\n\n- When point $P$ is to the right of point $O$, in the formed $\\triangle DOP$, $\\angle DOP=180^{\\circ}-60^{\\circ}=120^{\\circ}$ is the vertex angle, so $\\angle D=(180^{\\circ}-120^{\\circ})/2=30^{\\circ}$.\n\nProblem $2$:\n\nThe third side is the hypotenuse, with length $\\sqrt{1^2+1^2}=\\sqrt{2}=1.41421\\dots$.\n\n---\n\n### Constraints and Notes\n\n$x<90,m\\leq n\\leq 10^9$.\n\n---\n\n### Problem Setter's Hint\n\n**There are countless methods, but reading carefully comes first. Multiple solutions are not considered, and a wrong answer brings two lines of tears.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「SWTR-2」Triangles", "background": "小 $\\mathrm{A}$ 在学数学。", "description": "他遇到了两个谜题：\n\n- 在一个平面内，**线段** $DE$ 与**直线** $FG$ 相交于点 $O$，已知 $\\angle DOF=x^{\\circ}$，请你在**直线** $FG$ 上找一点 $P$，使得 $\\triangle DOP$ 为**等腰**三角形，求 $\\angle D$ 的度数。（如果答案不是整数，则保留 $1$ 位小数）\n\n- 已知一个**直角三角形**的两条边分别为 $m,n$，求第三条边的长度（保留 $5$ 位小数）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qjle5b4c.png)\n\n写一个程序求出问题的答案。", "inputFormat": "一行三个**正整数**，分别为 $x,m,n$。", "outputFormat": "输出两行，第一行为第一问的答案，第二行为第二问的答案。\n\n如果有多解，请用**空格**隔开，且**从小到大**输出。", "hint": "---\n\n### 样例说明\n\n问题 $1$：\n\n- 当点 $P$ 在点 $O$ 左边时，形成的 $\\triangle DOP$ 为等边三角形，$\\angle D=60^{\\circ}$。\n\n- 当点 $P$ 在点 $O$ 右边时，形成的 $\\triangle DOP$ 中，$\\angle DOP=180^{\\circ}-60^{\\circ}=120^{\\circ}$，为顶角，$\\angle D=(180^{\\circ}-120^{\\circ})/2=30^{\\circ}$。\n\n问题 $2$：\n\n第三条边为斜边，长度为 $\\sqrt{1^2+1^2}=\\sqrt{2}=1.41421\\dots$。\n\n---\n\n### 数据范围与约定\n\n$x<90,m\\leq n\\leq 10^9$。\n\n---\n\n### 出题组提示：\n\n**方法千万条，审题第一条，多解不考虑，爆零两行泪。**", "locale": "zh-CN"}}}
