{"pid": "P11408", "type": "P", "difficulty": 7, "samples": [["5\n0 0 1 1\n0 0 0 0\n10\n1 2\n2 2\n3 2\n4 2\n4 1\n3 1\n2 1\n1 1\n4 1000\n2 1000", "0\n2\n4\n8\n10\n12\n13\n14\n15\n2015\n3015"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2020", "RMI（罗马尼亚）"], "title": "[RMI 2020] 树咖 / Arboras", "background": "译自 [8th Romanian Master of Informatics, RMI 2020](https://rmi.lbi.ro/rmi_2020/) D2T3。$\\texttt{3s,0.25G}$。\n", "description": "\n有一棵 $N$ 个节点的有根树，边有边权。节点编号为 $0\\sim N-1$，$0$ 号点为根。\n\n定义 $f(u)$ 为 $u$ 子树内经过 $u$ 的最长链的长度。\n\n$Q$ 次操作，一次操作将一条边的边权**加上一个正数**。在第一次操作前，和每次操作后，求出 $\\displaystyle \\left(\\sum_{1\\le i\\le N} f(i)\\right)\\bmod (10^9+7)$。\n", "inputFormat": "\n第一行，一个正整数 $N$。\n\n第二行，$(N-1)$ 个整数 $p_1,\\cdots,p_{N-1}$，$p_i$ 表示 $i$ 号点的父亲为 $p_i$。\n\n第三行，$(N-1)$ 个正整数 $d_1,\\cdots,d_{N-1}$，$d_i$ 表示 $(i,p_i)$ 边边权为 $d_i$。\n\n第四行，一个正整数 $Q$。\n\n接下来 $Q$ 行，每行两个正整数 $x,v$，表示给 $(x,p_x)$ 边权增加 $v$。\n", "outputFormat": "\n输出 $(Q+1)$ 行，每行一个整数：\n\n- 第一行，输出第一次操作前的答案。\n- 接下来 $Q$ 行，输出每次操作后的答案。", "hint": "\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le N,Q\\le 10^5$；\n- $1\\le d_i\\le 10^9$；\n- $0\\le p_i\\lt i$；\n- $1\\le v\\le 10^9$；\n- $1\\le x\\lt N$。\n\n\n| 子任务编号 | $N,Q\\le$ |  特殊性质 | 得分 |  \n| :--: | :--: |  :--: |  :--: |\n| $ 1 $    | $ 10^3 $  |   | $11$ | \n| $ 2 $    | $ 10^5 $  | A | $13$ | \n| $ 3 $    | $ 10^5 $  | B | $31$ |\n| $ 4 $    | $ 10^5 $  |  | $45$ |\n\n\n- 特殊性质 A：树高不大于 $50$；\n- 特殊性质 B：$d_i=10^9$，$v=1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2020] 树咖 / Arboras", "background": "译自 [8th Romanian Master of Informatics, RMI 2020](https://rmi.lbi.ro/rmi_2020/) D2T3。$\\texttt{3s,0.25G}$。\n", "description": "\n有一棵 $N$ 个节点的有根树，边有边权。节点编号为 $0\\sim N-1$，$0$ 号点为根。\n\n定义 $f(u)$ 为 $u$ 子树内经过 $u$ 的最长链的长度。\n\n$Q$ 次操作，一次操作将一条边的边权**加上一个正数**。在第一次操作前，和每次操作后，求出 $\\displaystyle \\left(\\sum_{1\\le i\\le N} f(i)\\right)\\bmod (10^9+7)$。\n", "inputFormat": "\n第一行，一个正整数 $N$。\n\n第二行，$(N-1)$ 个整数 $p_1,\\cdots,p_{N-1}$，$p_i$ 表示 $i$ 号点的父亲为 $p_i$。\n\n第三行，$(N-1)$ 个正整数 $d_1,\\cdots,d_{N-1}$，$d_i$ 表示 $(i,p_i)$ 边边权为 $d_i$。\n\n第四行，一个正整数 $Q$。\n\n接下来 $Q$ 行，每行两个正整数 $x,v$，表示给 $(x,p_x)$ 边权增加 $v$。\n", "outputFormat": "\n输出 $(Q+1)$ 行，每行一个整数：\n\n- 第一行，输出第一次操作前的答案。\n- 接下来 $Q$ 行，输出每次操作后的答案。", "hint": "\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le N,Q\\le 10^5$；\n- $1\\le d_i\\le 10^9$；\n- $0\\le p_i\\lt i$；\n- $1\\le v\\le 10^9$；\n- $1\\le x\\lt N$。\n\n\n| 子任务编号 | $N,Q\\le$ |  特殊性质 | 得分 |  \n| :--: | :--: |  :--: |  :--: |\n| $ 1 $    | $ 10^3 $  |   | $11$ | \n| $ 2 $    | $ 10^5 $  | A | $13$ | \n| $ 3 $    | $ 10^5 $  | B | $31$ |\n| $ 4 $    | $ 10^5 $  |  | $45$ |\n\n\n- 特殊性质 A：树高不大于 $50$；\n- 特殊性质 B：$d_i=10^9$，$v=1$。", "locale": "zh-CN"}}}
{"pid": "P11409", "type": "P", "difficulty": 4, "samples": [["3 2 2\n0 1 \n1 1\n1 0\n0 0\n0 1\n0 1", "2"], ["3 2 2\n0 1\n1 0\n0 0\n0 1\n1 0\n0 0\n", "-1"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["二分图"], "title": "西湖有雅座", "background": ">江湖路上走走停停，翻开年少漂泊的回忆。\n如今走过这世间，万般留恋，风吹起了从前 。", "description": "孙亦谐准备建西湖雅座来开饭馆。\n\n他有 $n$ 个零件，零件的大小均为 $h\\times w$。零件从 $1 \\sim n$ 编号。\n\n对于一个大小为 $h \\times w$ 的零件，其可视为一个 $h$ 行 $w$ 列的矩阵 $w$。若用 $a_{i,j}$ 来表示这个矩阵中第 $i$ 行第 $j$ 列的元素。对于 $\\forall a_{i,j}$，都有 $a_{i,j}\\in \\left \\{  0,1\\right \\} $。\n\n则编号为 $i$ 的零件的面积为： $S\\left(i\\right) = \\sum_{i = 1}^{h}\\sum_{j = 1}^{w}a_{i,j} $。\n\n若编号为 $l$ 和 $r$ 的两个零件的分别表示为矩阵 $a$ 和 $b$，其在同一座楼的稳固程度可表示为： \n\n$$f\\left(l,r\\right) = \\sum_{i = 1}^{h} \\sum_{j = 1}^{w} \\left [ (a_{i,j} = 1) \\text{ and } (b_{i,j} = 1) \\right ]$$\n\n孙亦谐需要将这 $n$ 个零件先选取若干个按照任意顺序排列搭成大楼，然后把剩余的零件搭成小楼。若没有剩余零件，则可以不搭小楼。\n\n设 $U$ 表示某座楼选取的零件编号的集合，则这座楼能成功搭建的条件是：\n\n$$\\forall i,j \\in U,f\\left (i,j\\right) \\ge \\lceil \\frac{ \\min \\left ( S\\left(i \\right),S\\left(j\\right) \\right) }{2}\\rceil$$\n\n孙亦谐想知道在保证两座楼能成功搭建的条件下，让大楼使用的零件数尽量多。若无法成功搭建，则直接输出 `-1`。\n\n\n", "inputFormat": "第一行输入包含三个正整数 $n,h,w$，分别表示零件的个数、零件的行数、零件的列数。\n\n接下来输入 $n$ 个零件所表示的矩阵。\n\n对于每个零件的矩阵 $a$，输入的格式如下：\n\n共输入 $h$ 行，每行 $w$ 个元素。\n\n第 $i$ 行第 $j$ 列的元素 $a_{i,j}$，表示这个矩阵中第 $i$ 行第 $j$ 列的元素。\n\n", "outputFormat": "输出一个整数，表示在搭建成功的情况下，大楼最多能使用多少个零件。若无法成功搭建，则直接输出 `-1`。", "hint": "**【样例1解释】**\n\n可以证明最优方案是用第一个零件和第三个零件搭大楼，用第二个零件搭小楼。\n\n**【数据范围】**\n\n**本题采用捆绑测试**。\n\n- Subtask 1（30 points）：$n \\le 20$。\n- Subtask 2（5 points）：$w = h = 1$。\n- Subtask 3（65 points）：无特殊限制。\n\n对于所有测试数据，$1 \\le n \\le 1000$，$1 \\le w,h \\le 6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "西湖有雅座", "background": ">江湖路上走走停停，翻开年少漂泊的回忆。\n如今走过这世间，万般留恋，风吹起了从前 。", "description": "孙亦谐准备建西湖雅座来开饭馆。\n\n他有 $n$ 个零件，零件的大小均为 $h\\times w$。零件从 $1 \\sim n$ 编号。\n\n对于一个大小为 $h \\times w$ 的零件，其可视为一个 $h$ 行 $w$ 列的矩阵 $w$。若用 $a_{i,j}$ 来表示这个矩阵中第 $i$ 行第 $j$ 列的元素。对于 $\\forall a_{i,j}$，都有 $a_{i,j}\\in \\left \\{  0,1\\right \\} $。\n\n则编号为 $i$ 的零件的面积为： $S\\left(i\\right) = \\sum_{i = 1}^{h}\\sum_{j = 1}^{w}a_{i,j} $。\n\n若编号为 $l$ 和 $r$ 的两个零件的分别表示为矩阵 $a$ 和 $b$，其在同一座楼的稳固程度可表示为： \n\n$$f\\left(l,r\\right) = \\sum_{i = 1}^{h} \\sum_{j = 1}^{w} \\left [ (a_{i,j} = 1) \\text{ and } (b_{i,j} = 1) \\right ]$$\n\n孙亦谐需要将这 $n$ 个零件先选取若干个按照任意顺序排列搭成大楼，然后把剩余的零件搭成小楼。若没有剩余零件，则可以不搭小楼。\n\n设 $U$ 表示某座楼选取的零件编号的集合，则这座楼能成功搭建的条件是：\n\n$$\\forall i,j \\in U,f\\left (i,j\\right) \\ge \\lceil \\frac{ \\min \\left ( S\\left(i \\right),S\\left(j\\right) \\right) }{2}\\rceil$$\n\n孙亦谐想知道在保证两座楼能成功搭建的条件下，让大楼使用的零件数尽量多。若无法成功搭建，则直接输出 `-1`。\n\n\n", "inputFormat": "第一行输入包含三个正整数 $n,h,w$，分别表示零件的个数、零件的行数、零件的列数。\n\n接下来输入 $n$ 个零件所表示的矩阵。\n\n对于每个零件的矩阵 $a$，输入的格式如下：\n\n共输入 $h$ 行，每行 $w$ 个元素。\n\n第 $i$ 行第 $j$ 列的元素 $a_{i,j}$，表示这个矩阵中第 $i$ 行第 $j$ 列的元素。\n\n", "outputFormat": "输出一个整数，表示在搭建成功的情况下，大楼最多能使用多少个零件。若无法成功搭建，则直接输出 `-1`。", "hint": "**【样例1解释】**\n\n可以证明最优方案是用第一个零件和第三个零件搭大楼，用第二个零件搭小楼。\n\n**【数据范围】**\n\n**本题采用捆绑测试**。\n\n- Subtask 1（30 points）：$n \\le 20$。\n- Subtask 2（5 points）：$w = h = 1$。\n- Subtask 3（65 points）：无特殊限制。\n\n对于所有测试数据，$1 \\le n \\le 1000$，$1 \\le w,h \\le 6$。", "locale": "zh-CN"}}}
{"pid": "P11410", "type": "P", "difficulty": 5, "samples": [["2 1\n2\n11", "3"], ["10 3\n4\n1001\n8\n10110110\n3\n111", "84582\n5362\n163710"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "矩阵乘法"], "title": "闪耀之塔", "background": "", "description": "闪耀之塔是一棵节点结点从 $1\\sim 2^n -1$ 编号，以 $1$ 为根，共有 $n$ 层的满二叉树。\n\n非叶子节点节点 $i$ 的左右儿子的编号分别为 $i\\times2$ 和 $i \\times 2 +1$。\n\n多萝茜需要给这颗树上所有节点附上一个权值。\n\n每个节点的权值取值范围为 $[1,2^n-1]$，且要保证互不相同。\n\n定义 $S(u)$ 为 $u$ 节点的所有儿子的集合，$val_u$ 表示节点 $u$ 的权值。\n\n每个节点有一个能量值 $f(u)$，其可表示为：\n\n$$f(u)= val_u + \\sum_{v\\in S(u) }f(v) $$\n\n她想知道在保证 $ \\sum_{i = 1}^{2^n-1} f(i)$ 取得最大值时，对于编号为 $p$ 的节点其 $f(p)$ 的最大值是多少。\n询问的答案需要对 $10^9+7$ 取模。", "inputFormat": "第一行包含两个正整数 $n,q$，分别表示满二叉树的层数和询问的次数。\n\n接下来包含 $q$ 组询问，每组数据的格式如下：\n\n第一行包含一个整数 $k$，表示接下来输入的 01 串的长度。\n\n第二行包含一个的 01 串，为 $p$ 的二进制表示，保证 01 串的首位为 $1$，$p$ 表示所询问的节点编号。", "outputFormat": "对于每次询问：输出一行包含一个整数，表示询问的答案对 $10^9+7$ 取模的结果。", "hint": "**【数据范围】**\n\n对于所有测试数据，保证：\n\n- $1 \\leq k\\leq n \\leq 10^{12}$；\n- $1 \\leq q\\leq 1000$；\n- $1 \\leq k\\leq 10^4$。\n\n| 测试点 | $n\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $2$ | 无 |\n| $2$ | $10$ | 无 |\n| $3\\sim5$ | $5000$ | 无 |\n| $6$ | $10^5$ | 无 |\n| $7$ | $10^8$ | A |\n| $8 \\sim 10$ | $10^{12}$ | 无 |\n\n特殊性质 A：保证任意一组的询问都有 $k = 1$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "闪耀之塔", "background": "", "description": "闪耀之塔是一棵节点结点从 $1\\sim 2^n -1$ 编号，以 $1$ 为根，共有 $n$ 层的满二叉树。\n\n非叶子节点节点 $i$ 的左右儿子的编号分别为 $i\\times2$ 和 $i \\times 2 +1$。\n\n多萝茜需要给这颗树上所有节点附上一个权值。\n\n每个节点的权值取值范围为 $[1,2^n-1]$，且要保证互不相同。\n\n定义 $S(u)$ 为 $u$ 节点的所有儿子的集合，$val_u$ 表示节点 $u$ 的权值。\n\n每个节点有一个能量值 $f(u)$，其可表示为：\n\n$$f(u)= val_u + \\sum_{v\\in S(u) }f(v) $$\n\n她想知道在保证 $ \\sum_{i = 1}^{2^n-1} f(i)$ 取得最大值时，对于编号为 $p$ 的节点其 $f(p)$ 的最大值是多少。\n询问的答案需要对 $10^9+7$ 取模。", "inputFormat": "第一行包含两个正整数 $n,q$，分别表示满二叉树的层数和询问的次数。\n\n接下来包含 $q$ 组询问，每组数据的格式如下：\n\n第一行包含一个整数 $k$，表示接下来输入的 01 串的长度。\n\n第二行包含一个的 01 串，为 $p$ 的二进制表示，保证 01 串的首位为 $1$，$p$ 表示所询问的节点编号。", "outputFormat": "对于每次询问：输出一行包含一个整数，表示询问的答案对 $10^9+7$ 取模的结果。", "hint": "**【数据范围】**\n\n对于所有测试数据，保证：\n\n- $1 \\leq k\\leq n \\leq 10^{12}$；\n- $1 \\leq q\\leq 1000$；\n- $1 \\leq k\\leq 10^4$。\n\n| 测试点 | $n\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $2$ | 无 |\n| $2$ | $10$ | 无 |\n| $3\\sim5$ | $5000$ | 无 |\n| $6$ | $10^5$ | 无 |\n| $7$ | $10^8$ | A |\n| $8 \\sim 10$ | $10^{12}$ | 无 |\n\n特殊性质 A：保证任意一组的询问都有 $k = 1$。\n", "locale": "zh-CN"}}}
{"pid": "P11411", "type": "P", "difficulty": 6, "samples": [["3 2\n1 2 3", "0"], ["6 2\n3 2 7 99 10 15", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "树的直径", "笛卡尔树"], "title": "兰奇的卡牌游戏", "background": "", "description": "作为制卡大师的兰奇，发明了一种自助型卡牌游戏。\n\n给定 $n$ 张卡牌，第 $i$ 张卡牌编号为 $i$，其权值为 $a_i$，卡牌的权值互不相同。\n\n这个卡牌游戏的规则需要自己生成。一开始，所有的牌都在备选区。从备选区中选取一张编号最小的卡牌放到手牌区，便可进入规则生成阶段。\n\n规则生成阶段的步骤如下：\n\n1. 将手牌区的任意一张牌弃置到废牌区之中。\n\n1.  然后在备选区中选择一张编号和权值均大于当前弃牌的牌，加入手牌区。若存在这样的一张牌，则称这张牌与弃牌互为置换；若不存在这样的一张牌，则跳过当前步骤。\n\n1. 继续从备选区中选择一张编号大于当前弃牌且权值小于当前弃牌的牌，加入手牌区。若存在这样的一张牌，则同样可称这张牌与弃牌互为置换；若不存在这样的一张牌，则跳过当前步骤。\n\n1. 完成以上步骤后，若手牌区没有卡牌了，则规则生成阶段结束。若仍有卡牌，则继续重复上述步骤，直到手牌区没有卡牌。\n\n为了保证生成置换的唯一性，兰奇规定规则生成阶段合法当且仅当规则生成结束后，所有的牌都在废牌区。并且在正式游戏阶段一张编号较大的牌经过一系列操作后得到一张编号较小的牌后，该编号较大的牌，均要满足能够有机会按照在手牌区出现过的该张编号较小的牌的弃牌后生成的置换相同的步骤在规则生成阶段成为编号较小的牌的置换；若手牌区未出现该张编号较小的牌的弃牌后生成的置换，则无需考虑。否则，生成的置换是无效的。\n\n可以证明在规则生成阶段合法的情况下，每张卡牌可以与哪些卡牌互为置换的方案是唯一的。\n\n正式游戏阶段的步骤如下：\n\n1. 选择任意一张卡牌作为起始卡牌并加入手牌区，然后进入下一步骤。\n\n1. 将前手牌区的卡牌弃入废牌堆，然后从备选区中选择一张该卡牌的置换加入手牌区。若当前弃置的卡牌在备选区没有置换，则正式游戏阶段结束；反之，则得分增加 $1$ 分，然后继续重复步骤 2。\n\n游戏发售后，销量并不是很好。因为游戏规则太复杂了。玩家们希望删去一些卡牌，使得正式游戏阶段的最大得分不超过 $k$。\n\n而兰奇为了保证游戏的不做太大的改动，他要求删去一些卡牌后，保留下来的任意一张卡牌重新生成的置换要与原来未删去卡牌情况下的置换相同。\n\n删去后置换仍相同的定义是：设 $S$ 表示某一张卡牌，未删除任何一张卡牌时的置换集合；$T$ 表示该张卡牌，在删除了部分卡牌时的置换集合。此时，满足 $T \\subseteq S$。则称删去部分卡牌后，该卡牌的置换与原来未删去卡牌情况下的置换相同。\n\n兰奇想知道，在满足了玩家和自己的要求的前提下，他最少要删除几张卡片。\n", "inputFormat": "第一行输入两个正整数 $n$ 和 $k$，分别表示卡牌的数量和正式游戏阶段的最大得分不能超过的值。\n\n第二行输入 $n$ 个元素，第 $i$ 个元素 $a_i$，表示编号为 $i$ 的卡牌权值。", "outputFormat": "输出一个正整数，表示在满足玩家和自己的要求的前提下，最少要删除几张卡片。", "hint": "**【样例1解释】**\n\n编号为 $1$ 的卡牌与编号为 $2$ 的卡牌互为置换，编号为 $2$ 的卡牌与编号为 $3$ 的卡牌互为置换。\n\n所以，在不删去的情况下，获得最大得分的方案是：用编号为 $1$ 的卡牌作为起始卡牌置换出编号为 $2$ 的卡牌，然后再置换出编号为 $3$ 的卡牌。该方案的最大得分为 $2$，所以不需要删除任何一张卡牌。\n\n**【数据范围】**\n\n**本题采用捆绑测试**。\n\n- Subtask 1（15 points）：$n \\le 10$。\n- Subtask 2（5 points）：$k = n$。\n- Subtask 3（80 points）：无特殊限制。\n\n对于所有测试数据，$1 \\le n \\le 2000$，$1 \\le a_i \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "兰奇的卡牌游戏", "background": "", "description": "作为制卡大师的兰奇，发明了一种自助型卡牌游戏。\n\n给定 $n$ 张卡牌，第 $i$ 张卡牌编号为 $i$，其权值为 $a_i$，卡牌的权值互不相同。\n\n这个卡牌游戏的规则需要自己生成。一开始，所有的牌都在备选区。从备选区中选取一张编号最小的卡牌放到手牌区，便可进入规则生成阶段。\n\n规则生成阶段的步骤如下：\n\n1. 将手牌区的任意一张牌弃置到废牌区之中。\n\n1.  然后在备选区中选择一张编号和权值均大于当前弃牌的牌，加入手牌区。若存在这样的一张牌，则称这张牌与弃牌互为置换；若不存在这样的一张牌，则跳过当前步骤。\n\n1. 继续从备选区中选择一张编号大于当前弃牌且权值小于当前弃牌的牌，加入手牌区。若存在这样的一张牌，则同样可称这张牌与弃牌互为置换；若不存在这样的一张牌，则跳过当前步骤。\n\n1. 完成以上步骤后，若手牌区没有卡牌了，则规则生成阶段结束。若仍有卡牌，则继续重复上述步骤，直到手牌区没有卡牌。\n\n为了保证生成置换的唯一性，兰奇规定规则生成阶段合法当且仅当规则生成结束后，所有的牌都在废牌区。并且在正式游戏阶段一张编号较大的牌经过一系列操作后得到一张编号较小的牌后，该编号较大的牌，均要满足能够有机会按照在手牌区出现过的该张编号较小的牌的弃牌后生成的置换相同的步骤在规则生成阶段成为编号较小的牌的置换；若手牌区未出现该张编号较小的牌的弃牌后生成的置换，则无需考虑。否则，生成的置换是无效的。\n\n可以证明在规则生成阶段合法的情况下，每张卡牌可以与哪些卡牌互为置换的方案是唯一的。\n\n正式游戏阶段的步骤如下：\n\n1. 选择任意一张卡牌作为起始卡牌并加入手牌区，然后进入下一步骤。\n\n1. 将前手牌区的卡牌弃入废牌堆，然后从备选区中选择一张该卡牌的置换加入手牌区。若当前弃置的卡牌在备选区没有置换，则正式游戏阶段结束；反之，则得分增加 $1$ 分，然后继续重复步骤 2。\n\n游戏发售后，销量并不是很好。因为游戏规则太复杂了。玩家们希望删去一些卡牌，使得正式游戏阶段的最大得分不超过 $k$。\n\n而兰奇为了保证游戏的不做太大的改动，他要求删去一些卡牌后，保留下来的任意一张卡牌重新生成的置换要与原来未删去卡牌情况下的置换相同。\n\n删去后置换仍相同的定义是：设 $S$ 表示某一张卡牌，未删除任何一张卡牌时的置换集合；$T$ 表示该张卡牌，在删除了部分卡牌时的置换集合。此时，满足 $T \\subseteq S$。则称删去部分卡牌后，该卡牌的置换与原来未删去卡牌情况下的置换相同。\n\n兰奇想知道，在满足了玩家和自己的要求的前提下，他最少要删除几张卡片。\n", "inputFormat": "第一行输入两个正整数 $n$ 和 $k$，分别表示卡牌的数量和正式游戏阶段的最大得分不能超过的值。\n\n第二行输入 $n$ 个元素，第 $i$ 个元素 $a_i$，表示编号为 $i$ 的卡牌权值。", "outputFormat": "输出一个正整数，表示在满足玩家和自己的要求的前提下，最少要删除几张卡片。", "hint": "**【样例1解释】**\n\n编号为 $1$ 的卡牌与编号为 $2$ 的卡牌互为置换，编号为 $2$ 的卡牌与编号为 $3$ 的卡牌互为置换。\n\n所以，在不删去的情况下，获得最大得分的方案是：用编号为 $1$ 的卡牌作为起始卡牌置换出编号为 $2$ 的卡牌，然后再置换出编号为 $3$ 的卡牌。该方案的最大得分为 $2$，所以不需要删除任何一张卡牌。\n\n**【数据范围】**\n\n**本题采用捆绑测试**。\n\n- Subtask 1（15 points）：$n \\le 10$。\n- Subtask 2（5 points）：$k = n$。\n- Subtask 3（80 points）：无特殊限制。\n\n对于所有测试数据，$1 \\le n \\le 2000$，$1 \\le a_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P11412", "type": "P", "difficulty": 3, "samples": [["5 6\n5 6 abcab\n7 10 abcba\n4 3 abc\n3 6 ade\n2 4 cde\n2 abc\n4 abc\n5 abc\n6 a\n7 c\n8 ab", "0\n3\n9\n15\n4\n19"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["排序", "哈希 hashing", "字典树 Trie"], "title": "[EPXLQ2024 fall round] 风吹起了从前", "background": "对于过去，温昭雪有着断断续续的记忆。", "description": "具体地，她有 $n$ 条记忆，每条记忆是一个长度不超过 $100$ 的字符串。第 $i$ 条记忆 $S_i$ 位于她心灵的 $r_i$ 深处，对她有 $v_i$ 的价值。\n\n温昭雪正在试图恢复自己记忆中的美好，可记忆实在太多太复杂，她只能想到她记忆的一段前缀 $Q$ 和她能到达的最深位置 $d$。只有满足对应的 $Q$ 是 $S_i$ 的前缀且 $r_i \\le d$ 的记忆才能被温昭雪回想到。\n\n现在，温昭雪有 $m$ 次尝试。她想知道，对于每次尝试，她能获得的所有记忆价值之和是多少。", "inputFormat": "输入第一行包含 $n,m$。\n\n以下 $n$ 行，每行两个整数 $r_i,v_i$ 和一个字符串 $S_i$，空格分隔。\n\n以下 $m$ 行，每行一个整数 $d$ 和一个字符串 $Q$，空格分隔。保证 $Q$ 至少是某一个 $S_i$ 的前缀，**但不保证一定存在一个记忆能被回想到**。", "outputFormat": "输出 $m$ 行，每行表示对于每次尝试，她能获得的所有记忆价值之和是多少。", "hint": "### 提示\n\n本题对前缀的定义为：对于字符串 $S,P$，若 $|P| \\le |S|$ 且对所有 $1 \\le i \\le |P|$ 均有 $S_i=P_i$，则称 $P$ 是 $S$ 的前缀。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| $\\text{Subtask}$ | $n \\le$ | $ m\\le$ | 特殊性质 | 分值 |\n| :-: | :-: | :-: | :-: | :-: |\n| $0$ | $100$ | $100$ | | $11$ |\n| $1$ | $10^4$ | $10^5$ | $d = 10^9$ | $13$ |\n| $2$ | $10^4$ | $10^5$ | 字符串长度不超过 $2$ | $9$ |\n| $3$ | $10^4$ | $10^3$ | | $26$ |\n| $4$ | $10^4$ | $10^5$ | | $41$ |\n\n对于所有数据，保证 $1 \\le |S_i|,|Q| \\le100, 0 \\le r_i,v_i,d \\le 10^9$，所有字符串仅由小写字母组成。\n\n请注意时间复杂度常数因子带来的影响。\n\n请考虑使用较快的输入输出方式。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[EPXLQ2024 fall round] 风吹起了从前", "background": "对于过去，温昭雪有着断断续续的记忆。", "description": "具体地，她有 $n$ 条记忆，每条记忆是一个长度不超过 $100$ 的字符串。第 $i$ 条记忆 $S_i$ 位于她心灵的 $r_i$ 深处，对她有 $v_i$ 的价值。\n\n温昭雪正在试图恢复自己记忆中的美好，可记忆实在太多太复杂，她只能想到她记忆的一段前缀 $Q$ 和她能到达的最深位置 $d$。只有满足对应的 $Q$ 是 $S_i$ 的前缀且 $r_i \\le d$ 的记忆才能被温昭雪回想到。\n\n现在，温昭雪有 $m$ 次尝试。她想知道，对于每次尝试，她能获得的所有记忆价值之和是多少。", "inputFormat": "输入第一行包含 $n,m$。\n\n以下 $n$ 行，每行两个整数 $r_i,v_i$ 和一个字符串 $S_i$，空格分隔。\n\n以下 $m$ 行，每行一个整数 $d$ 和一个字符串 $Q$，空格分隔。保证 $Q$ 至少是某一个 $S_i$ 的前缀，**但不保证一定存在一个记忆能被回想到**。", "outputFormat": "输出 $m$ 行，每行表示对于每次尝试，她能获得的所有记忆价值之和是多少。", "hint": "### 提示\n\n本题对前缀的定义为：对于字符串 $S,P$，若 $|P| \\le |S|$ 且对所有 $1 \\le i \\le |P|$ 均有 $S_i=P_i$，则称 $P$ 是 $S$ 的前缀。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| $\\text{Subtask}$ | $n \\le$ | $ m\\le$ | 特殊性质 | 分值 |\n| :-: | :-: | :-: | :-: | :-: |\n| $0$ | $100$ | $100$ | | $11$ |\n| $1$ | $10^4$ | $10^5$ | $d = 10^9$ | $13$ |\n| $2$ | $10^4$ | $10^5$ | 字符串长度不超过 $2$ | $9$ |\n| $3$ | $10^4$ | $10^3$ | | $26$ |\n| $4$ | $10^4$ | $10^5$ | | $41$ |\n\n对于所有数据，保证 $1 \\le |S_i|,|Q| \\le100, 0 \\le r_i,v_i,d \\le 10^9$，所有字符串仅由小写字母组成。\n\n请注意时间复杂度常数因子带来的影响。\n\n请考虑使用较快的输入输出方式。", "locale": "zh-CN"}}}
{"pid": "P11413", "type": "P", "difficulty": 5, "samples": [["2\n3 1\n6 4", "1\n4\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 65536, 524288, 65536, 524288, 65536, 524288, 65536, 524288, 65536, 524288, 65536, 524288, 65536, 524288, 65536, 524288, 65536, 524288, 65536, 524288, 65536, 524288, 65536, 524288]}, "tags": ["模拟", "堆", "优先队列", "链表"], "title": "[EPXLQ2024 fall round] 好排列", "background": "温昭雪喜欢构造排列。", "description": "她的目标是构造一个由 $n$ 个数组成的排列 $A_1,A_2,\\dots,A_n$，初始时 $A$ 中的所有元素都是 $0$。\n\n接下来，对于数 $i$（$1 \\le i \\le n$），她通过下面方式由 $1$ 到 $n$ 确定其位置：\n\n- 如果 $i=1$，将其放到最左侧。\n\n- 如果 $i=2$，将其放到最右侧。\n\n- 如果都不是，定义 $f_0(x)$ 表示 $x$ 左侧（包含 $x$，下同）的连续的 $0$ 的个数，$g_0(x)$ 为 $x$ 右侧的连续的 $0$ 的个数。特别地，如果 $x \\le 0$ 或 $x > n$，$f_0(x)=g_0(x)=n+1$。\n- 定义 $f_1(x)$ 表示 $x$ 左侧的连续非 $0$ 位置的个数，$g_1(x)$ 表示 $x$ 右侧的连续非 $0$ 位置的个数。特别地，如果 $x \\le 0$ 或 $x > n$，$f_0(x)=g_0(x)=0$。\n- 如果存在位置 $j$，使得 $\\min(f_0(j), g_0(j)) > 1$，则选择位置 $j$ 最大化 $\\min(f_0(j), g_0(j))$。如果有多个位置的值相同，选择 $j$ 较小的。\n- 如果不存在这样的位置，则选择位置 $j$ 使得 $f_0(j)=1$ 并最小化 $f_1(j-1) + g_1(j+1)$。如果有多个位置的值相同，选择 $j$ 较小的。\n\n温昭雪的幸运数字是 $k$。为了避免输出过多，她只想知道数字 $k$ 处于排列的什么位置。", "inputFormat": "**本题单个测试点内有多组测试数据。**\n\n输入第一行 $T$，表示数据组数。\n\n以下 $T$ 行，每行两个正整数 $n,k$。", "outputFormat": "输出 $T$ 行，每行一个正整数 $x$，表示排列长度为 $n$ 时，$A_x=k$。", "hint": "### 样例解释\n\n第一组测试数据对应的排列为 $\\{1,3,2\\}$。\n\n第二组测试数据对应的排列为 $\\{1,5,3,4,6,2\\}$。\n\n### 数据规模与约定\n\n\n| 测试点编号 | $n$ | $k$ | $T$ | $\\sum n$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| $1,2$ | $\\le 10$ | $\\le 10$ | $\\le 10$ | $\\le 100$ | |\n| $3,4$ | $\\le 100$ | $\\le 100$ | $\\le 10$ | $\\le 1000$ | |\n| $5$ | $\\le 1000$ | $\\le 10$ | $\\le 10$ | $\\le 10^4$ | |\n| $6,7$ | $\\le 1000$ | $\\le 1000$ | $\\le 100$ | $\\le 10^5$ |\n| $8,9$ | $\\le 10^4$ | $\\le 10$ | $\\le 100$ | $\\le 10^5$ |\n| $10 \\sim 13$ | $\\le 10^4$ | $\\le 10^4$ | $\\le 100$ | $\\le 10^6$  | $n,k$ 均为奇数 |\n| $14 \\sim 17$ | $\\le 10^4$ | $\\le 10^4$ | $\\le 100$ | $\\le 10^6$ | $n,k$ 均为偶数 |\n| $18,19$ | $\\le 10^5$ | $\\le 10$ | $\\le 10$ | $\\le 10^5$ | |\n| $20,21$ | $\\le 10^5$ | $\\le 10^5$ | $\\le 100$ | $\\le 10^6$ | |\n| $22\\sim 25$ | $\\le 10^6$ | $\\le 10^6$ | $\\le 100$ | $\\le 10^6$ | |\n\n对于奇数编号的测试点，内存限制为 $\\text{512 MB}$；对于偶数编号的测试点，内存限制为 $\\text{64 MB}$。\n\n对于所有数据，保证 $1 \\le k \\le n \\le 10^6, \\sum n \\le 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[EPXLQ2024 fall round] 好排列", "background": "温昭雪喜欢构造排列。", "description": "她的目标是构造一个由 $n$ 个数组成的排列 $A_1,A_2,\\dots,A_n$，初始时 $A$ 中的所有元素都是 $0$。\n\n接下来，对于数 $i$（$1 \\le i \\le n$），她通过下面方式由 $1$ 到 $n$ 确定其位置：\n\n- 如果 $i=1$，将其放到最左侧。\n\n- 如果 $i=2$，将其放到最右侧。\n\n- 如果都不是，定义 $f_0(x)$ 表示 $x$ 左侧（包含 $x$，下同）的连续的 $0$ 的个数，$g_0(x)$ 为 $x$ 右侧的连续的 $0$ 的个数。特别地，如果 $x \\le 0$ 或 $x > n$，$f_0(x)=g_0(x)=n+1$。\n- 定义 $f_1(x)$ 表示 $x$ 左侧的连续非 $0$ 位置的个数，$g_1(x)$ 表示 $x$ 右侧的连续非 $0$ 位置的个数。特别地，如果 $x \\le 0$ 或 $x > n$，$f_0(x)=g_0(x)=0$。\n- 如果存在位置 $j$，使得 $\\min(f_0(j), g_0(j)) > 1$，则选择位置 $j$ 最大化 $\\min(f_0(j), g_0(j))$。如果有多个位置的值相同，选择 $j$ 较小的。\n- 如果不存在这样的位置，则选择位置 $j$ 使得 $f_0(j)=1$ 并最小化 $f_1(j-1) + g_1(j+1)$。如果有多个位置的值相同，选择 $j$ 较小的。\n\n温昭雪的幸运数字是 $k$。为了避免输出过多，她只想知道数字 $k$ 处于排列的什么位置。", "inputFormat": "**本题单个测试点内有多组测试数据。**\n\n输入第一行 $T$，表示数据组数。\n\n以下 $T$ 行，每行两个正整数 $n,k$。", "outputFormat": "输出 $T$ 行，每行一个正整数 $x$，表示排列长度为 $n$ 时，$A_x=k$。", "hint": "### 样例解释\n\n第一组测试数据对应的排列为 $\\{1,3,2\\}$。\n\n第二组测试数据对应的排列为 $\\{1,5,3,4,6,2\\}$。\n\n### 数据规模与约定\n\n\n| 测试点编号 | $n$ | $k$ | $T$ | $\\sum n$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| $1,2$ | $\\le 10$ | $\\le 10$ | $\\le 10$ | $\\le 100$ | |\n| $3,4$ | $\\le 100$ | $\\le 100$ | $\\le 10$ | $\\le 1000$ | |\n| $5$ | $\\le 1000$ | $\\le 10$ | $\\le 10$ | $\\le 10^4$ | |\n| $6,7$ | $\\le 1000$ | $\\le 1000$ | $\\le 100$ | $\\le 10^5$ |\n| $8,9$ | $\\le 10^4$ | $\\le 10$ | $\\le 100$ | $\\le 10^5$ |\n| $10 \\sim 13$ | $\\le 10^4$ | $\\le 10^4$ | $\\le 100$ | $\\le 10^6$  | $n,k$ 均为奇数 |\n| $14 \\sim 17$ | $\\le 10^4$ | $\\le 10^4$ | $\\le 100$ | $\\le 10^6$ | $n,k$ 均为偶数 |\n| $18,19$ | $\\le 10^5$ | $\\le 10$ | $\\le 10$ | $\\le 10^5$ | |\n| $20,21$ | $\\le 10^5$ | $\\le 10^5$ | $\\le 100$ | $\\le 10^6$ | |\n| $22\\sim 25$ | $\\le 10^6$ | $\\le 10^6$ | $\\le 100$ | $\\le 10^6$ | |\n\n对于奇数编号的测试点，内存限制为 $\\text{512 MB}$；对于偶数编号的测试点，内存限制为 $\\text{64 MB}$。\n\n对于所有数据，保证 $1 \\le k \\le n \\le 10^6, \\sum n \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P11414", "type": "P", "difficulty": 4, "samples": [["6 6\n1 1 4 5 1 4\n2 1 6\n1 1 3 2\n2 1 4\n2 1 6\n1 1 3 -2\n2 1 6", "19\n22\n28\n19"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "线段树"], "title": "[EPXLQ2024 fall round] 神奇磁铁", "background": "\nlzy 给了 Cute_QiQi 很多组神奇的磁铁。\n\n注：想拿到**快速 AK 变换奖**请在代码注释部分写明本题代码正确性证明。", "description": "一组神奇的磁铁由 $2x$ 个磁铁排成一排组成，编号 $1,2,\\dots,2x$，有激活和未激活两种状态。它们与普通的磁铁不同，不会简单地吸在一起。对于一组磁铁，当且仅当存在 $y \\in [1,x]$，使得不存在两个激活的磁铁满足两者之间的距离为 $y$，整组磁铁才会吸在一起。不同组的磁铁之间不相互影响。\n\n对于编号为 $i,j$ 的两个磁铁，它们之间的距离为 $|i-j|$。具体地，当 $x=2$ 时，磁铁组为 $\\{1,2,3,4\\}$。当激活的磁铁为 $\\{1,2\\}$ 时，整组磁铁可以吸在一起，因为对于 $y=2$，不存在两个磁铁之间的距离为 $2$。而激活的磁铁为 $\\{1,2,3\\}$ 时整组磁铁不能吸在一起。\n\nlzy 给了 Cute_QiQi $n$ 组磁铁。现在，Cute_QiQi 希望把这 $n$ 组磁铁排成一排作为装饰，同组磁铁堆在一起。未被吸在一起的磁铁不便于摆放，因此，Cute_QiQi 希望所有的磁铁组内的磁铁都吸在一起。在此基础上，Cute_QiQi 希望激活**尽可能多**的磁铁。\n\n另外，有时 lzy 会给 Cute_QiQi 一些额外的磁铁。\n\n磁铁实在是太多了，以至于 Cute_QiQi 计算不出她最多能激活多少磁铁。因此，她希望你帮她写一个程序，支持下面两种操作：\n\n- `1 l r x`，表示 lzy 给 $[l,r]$ 内所有的磁铁组添加了 $2x$ 个磁铁；\n- `2 l r`，表示 Cute_QiQi 想知道在激活最多磁铁的情况下，$[l,r]$ 内的磁铁组总共有多少个磁铁被激活。", "inputFormat": "输入第一行为 $n,q$，其中 $q$ 表示操作的个数。\n\n第二行为 $n$ 个整数 $a_1,a_2,.\\dots,a_n$，表示每个磁铁组中初始的磁铁数量 $2a_i$。\n\n以下 $q$ 行，每行一个操作，格式如下：\n\n- `1 l r x`，表示 lzy 给 $[l,r]$ 内所有的磁铁组添加了 $2x$ 个磁铁；\n- `2 l r`，表示 Cute_QiQi 想知道在激活最多磁铁的情况下，$[l,r]$ 内的磁铁组总共有多少个磁铁被激活。", "outputFormat": "对于每个 `2 l r` 操作，输出一行表示答案。", "hint": "### 样例解释\n\n初始时对应的激活磁铁的最大数量依次为 $1,1,5,6,1,5$。\n\n进行修改操作后，对应的激活磁铁最大数量依次为 $4,4,8,6,1,5$。\n\n可以证明，不可能再激活更多的磁铁。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n设 $v$ 表示任意时刻，磁铁数最多的磁铁组内磁铁的数量。\n\n| $\\text{Subtask}$ | $n \\le$ | $q \\le$ | $v \\le$ | 分值 |\n| :-: | :-: | :-: | :-: | :-: |\n| $0$ | $1000$ | $1000$ | $20$ | $10$ |\n| $1$ | $1000$ | $1000$ | $10^9$ | $15$ |\n| $2$ | $5 \\times 10^5$ | $5 \\times 10^5$ | $20$ | $10$ |\n| $3$ | $5 \\times 10^5$ | $5 \\times 10^5$ | $5000$ | $25$ |\n| $4$ | $5 \\times 10^5$ | $5 \\times 10^5$ | $10^9$ | $40$ |\n\n对于所有数据，保证 $1 \\le n,q \\le 5 \\times 10^5, 1 \\le l \\le r \\le n, 1 \\le v,a_i \\le 10^9, -10^9 \\le x \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[EPXLQ2024 fall round] 神奇磁铁", "background": "\nlzy 给了 Cute_QiQi 很多组神奇的磁铁。\n\n注：想拿到**快速 AK 变换奖**请在代码注释部分写明本题代码正确性证明。", "description": "一组神奇的磁铁由 $2x$ 个磁铁排成一排组成，编号 $1,2,\\dots,2x$，有激活和未激活两种状态。它们与普通的磁铁不同，不会简单地吸在一起。对于一组磁铁，当且仅当存在 $y \\in [1,x]$，使得不存在两个激活的磁铁满足两者之间的距离为 $y$，整组磁铁才会吸在一起。不同组的磁铁之间不相互影响。\n\n对于编号为 $i,j$ 的两个磁铁，它们之间的距离为 $|i-j|$。具体地，当 $x=2$ 时，磁铁组为 $\\{1,2,3,4\\}$。当激活的磁铁为 $\\{1,2\\}$ 时，整组磁铁可以吸在一起，因为对于 $y=2$，不存在两个磁铁之间的距离为 $2$。而激活的磁铁为 $\\{1,2,3\\}$ 时整组磁铁不能吸在一起。\n\nlzy 给了 Cute_QiQi $n$ 组磁铁。现在，Cute_QiQi 希望把这 $n$ 组磁铁排成一排作为装饰，同组磁铁堆在一起。未被吸在一起的磁铁不便于摆放，因此，Cute_QiQi 希望所有的磁铁组内的磁铁都吸在一起。在此基础上，Cute_QiQi 希望激活**尽可能多**的磁铁。\n\n另外，有时 lzy 会给 Cute_QiQi 一些额外的磁铁。\n\n磁铁实在是太多了，以至于 Cute_QiQi 计算不出她最多能激活多少磁铁。因此，她希望你帮她写一个程序，支持下面两种操作：\n\n- `1 l r x`，表示 lzy 给 $[l,r]$ 内所有的磁铁组添加了 $2x$ 个磁铁；\n- `2 l r`，表示 Cute_QiQi 想知道在激活最多磁铁的情况下，$[l,r]$ 内的磁铁组总共有多少个磁铁被激活。", "inputFormat": "输入第一行为 $n,q$，其中 $q$ 表示操作的个数。\n\n第二行为 $n$ 个整数 $a_1,a_2,.\\dots,a_n$，表示每个磁铁组中初始的磁铁数量 $2a_i$。\n\n以下 $q$ 行，每行一个操作，格式如下：\n\n- `1 l r x`，表示 lzy 给 $[l,r]$ 内所有的磁铁组添加了 $2x$ 个磁铁；\n- `2 l r`，表示 Cute_QiQi 想知道在激活最多磁铁的情况下，$[l,r]$ 内的磁铁组总共有多少个磁铁被激活。", "outputFormat": "对于每个 `2 l r` 操作，输出一行表示答案。", "hint": "### 样例解释\n\n初始时对应的激活磁铁的最大数量依次为 $1,1,5,6,1,5$。\n\n进行修改操作后，对应的激活磁铁最大数量依次为 $4,4,8,6,1,5$。\n\n可以证明，不可能再激活更多的磁铁。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n设 $v$ 表示任意时刻，磁铁数最多的磁铁组内磁铁的数量。\n\n| $\\text{Subtask}$ | $n \\le$ | $q \\le$ | $v \\le$ | 分值 |\n| :-: | :-: | :-: | :-: | :-: |\n| $0$ | $1000$ | $1000$ | $20$ | $10$ |\n| $1$ | $1000$ | $1000$ | $10^9$ | $15$ |\n| $2$ | $5 \\times 10^5$ | $5 \\times 10^5$ | $20$ | $10$ |\n| $3$ | $5 \\times 10^5$ | $5 \\times 10^5$ | $5000$ | $25$ |\n| $4$ | $5 \\times 10^5$ | $5 \\times 10^5$ | $10^9$ | $40$ |\n\n对于所有数据，保证 $1 \\le n,q \\le 5 \\times 10^5, 1 \\le l \\le r \\le n, 1 \\le v,a_i \\le 10^9, -10^9 \\le x \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P11415", "type": "P", "difficulty": 5, "samples": [["3 3 100 1 0\n5 10 15\n100 90 80\n70 100 80\n60 110 100", "decimal 2168.333333"], ["3 3 100 1 0\n5 10 15\n100 90 80\n70 100 80\n60 110 100", "inverse 332750286"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "矩阵运算", "Special Judge"], "title": "[EPXLQ2024 fall round] 如今走过这世间", "background": "温昭雪开始了上传视频，成为大 uploader 之路。\n\n这天，她所在的视频平台上线了一个激励计划。", "description": "温昭雪有 $n$ 个视频要发布，每个视频可以是 $t$ 个分类中的一种。初始时温昭雪有 $k$ 分。每当她发布一个类型为 $j$ 的视频，设她上一个发布的视频类型为 $i$，则她的分数会在发布这个视频后立刻乘上 $d_{i,j}$（如果是第 $1$ 个视频，分数不会变化）。**然后**，设当前有 $x$ 分，则会得 $b_j\\times x$ 的收益。\n\n温昭雪是个有点随意的人，所以她每次会**等概率随机选择**一个视频的类型（除了第一个视频的类型固定为 $v$）。现在她想知道在这样发视频的情况下，她能获得总收益的期望。", "inputFormat": "第一行五个整数 $n,t,k,v,g$，其中 $g$ 表示该数据所处的 Subtask 编号。\n\n第二行包含 $t$ 个整数 $b_i$。\n\n以下 $t$ 行，每行 $t$ 个整数 $D_{i,j}$，**满足 $d_{i,j} = {D_{i,j} \\over 100}$**。", "outputFormat": "仅一行表示答案。最终结果可以选择下列方式之一输出：\n\n- 用浮点数输出，输出格式 `decimal x`，$x$ 的误差不超过 $10^{-9}$（$\\text{误差}={ {|\\text{你的输出 - 答案}|} \\over \\text{答案}}$） 即为正确。**这种方式只能用于输出部分 Subtask 的答案，在其它 Subtask 这样输出会 WA。**\n\n\t供参考：答案文件中精确到了 18 位小数。\n\n- 用[乘法逆元](https://oiwiki.com/math/number-theory/inverse/)输出，输出格式 `inverse x`，答案对 $998244353$ 取模。\n", "hint": "### 样例解释\n\n显然，所有以 $v$ 开头的发布视频的序列具有相同的概率出现。\n\n当发布第 $2$ 个视频时，分数与获得收益的可能性如下表：\n\n| 视频类型 | 发布后分数 | 总收益 |\n| :-: | :-: | :-: |\n| $1$ | $100$ | $500+500=1000$ |\n| $2$ | $90$ | $500+900=1400$ |\n| $3$ | $80$ | $500+1200=1700$ |\n\n令 $F$ 表示发布第 $3$ 个视频前的分数，$P$ 表示发布第 $3$ 个视频前的收益，则：\n\n- 发布第 $3$ 个视频后的分数为：\n\n\n| 第 $3$ 个视频类型（行）/ 第 $2$ 个视频类型（列） | $1$（$F=100$） | $2$（$F=90$） | $3$（$F=80$） |\n| :-: | :-: | :-: | :-: |\n| $1$ | $100$ | $63$ | $48$ |\n| $2$ | $90$ | $90$ | $88$ |\n| $3$ | $80$ | $72$ | $80$ |\n\n- 发布第 $3$ 个视频后能获得的最终收益为：\n\n\n| 第 $3$ 个视频类型（行）/ 第 $2$ 个视频类型（列） | $1$（$P = 1000$） | $2$（$P=1400$） | $3$（$P=1700$） |\n| :-: | :-: | :-: | :-: |\n| $1$ | $1000 + 500$ | $1400+315$ | $1700+240$ |\n| $2$ | $1000 + 900$ | $1400+900$ | $1700+880$ |\n| $3$ | $1000 + 1200$ | $1400+1080$ | $1700+1200$ |\n\n因此，总收益期望为 ${19515 \\over 9}={6505 \\over 3} \\approx 2168.333333$。在本样例所示数据范围下，`decimal` 和 `inverse` 输出均可用，两种答案均正确。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| $\\text{Subtask}$ | $n \\le$ | $t \\le $ | 特殊性质 | 是否可使用 `decimal` | 分值 |\n| :-: | :-: | :-: | :-: | :-: | :-: |\n| $0$ | $8$ | $8$ | | 是 | $9$ |\n| $1$ | $18$ | $200$ | | 是 | $6$ |\n| $2$ | $10^9$ | $1$ | | 否 | $4$ |\n| $3$ | $100$ | $200$ | | 是 | $7$ |\n| $4$ | $100$ | $200$ | A | 是 | $10$ |\n| $5$ | $10^9$ | $200$ | B | 是 | $6$ |\n| $6$ | $10^9$ | $100$ | | 否 | $12$ |\n| $7$ | $10^4$ | $200$ | | 否 | $11$ |\n| $8$ | $10^9$ | $200$ | | 否 | $35$ |\n\n特殊性质 A：$d_{i,j} \\in \\{0,0.5,1\\}$。\n\n特殊性质 B：$d_{i,j}=1$。\n\n对于所有数据，保证 $1 \\le n \\le 10^9, 1 \\le t \\le 200, 0 \\le d \\le 2$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[EPXLQ2024 fall round] 如今走过这世间", "background": "温昭雪开始了上传视频，成为大 uploader 之路。\n\n这天，她所在的视频平台上线了一个激励计划。", "description": "温昭雪有 $n$ 个视频要发布，每个视频可以是 $t$ 个分类中的一种。初始时温昭雪有 $k$ 分。每当她发布一个类型为 $j$ 的视频，设她上一个发布的视频类型为 $i$，则她的分数会在发布这个视频后立刻乘上 $d_{i,j}$（如果是第 $1$ 个视频，分数不会变化）。**然后**，设当前有 $x$ 分，则会得 $b_j\\times x$ 的收益。\n\n温昭雪是个有点随意的人，所以她每次会**等概率随机选择**一个视频的类型（除了第一个视频的类型固定为 $v$）。现在她想知道在这样发视频的情况下，她能获得总收益的期望。", "inputFormat": "第一行五个整数 $n,t,k,v,g$，其中 $g$ 表示该数据所处的 Subtask 编号。\n\n第二行包含 $t$ 个整数 $b_i$。\n\n以下 $t$ 行，每行 $t$ 个整数 $D_{i,j}$，**满足 $d_{i,j} = {D_{i,j} \\over 100}$**。", "outputFormat": "仅一行表示答案。最终结果可以选择下列方式之一输出：\n\n- 用浮点数输出，输出格式 `decimal x`，$x$ 的误差不超过 $10^{-9}$（$\\text{误差}={ {|\\text{你的输出 - 答案}|} \\over \\text{答案}}$） 即为正确。**这种方式只能用于输出部分 Subtask 的答案，在其它 Subtask 这样输出会 WA。**\n\n\t供参考：答案文件中精确到了 18 位小数。\n\n- 用[乘法逆元](https://oiwiki.com/math/number-theory/inverse/)输出，输出格式 `inverse x`，答案对 $998244353$ 取模。\n", "hint": "### 样例解释\n\n显然，所有以 $v$ 开头的发布视频的序列具有相同的概率出现。\n\n当发布第 $2$ 个视频时，分数与获得收益的可能性如下表：\n\n| 视频类型 | 发布后分数 | 总收益 |\n| :-: | :-: | :-: |\n| $1$ | $100$ | $500+500=1000$ |\n| $2$ | $90$ | $500+900=1400$ |\n| $3$ | $80$ | $500+1200=1700$ |\n\n令 $F$ 表示发布第 $3$ 个视频前的分数，$P$ 表示发布第 $3$ 个视频前的收益，则：\n\n- 发布第 $3$ 个视频后的分数为：\n\n\n| 第 $3$ 个视频类型（行）/ 第 $2$ 个视频类型（列） | $1$（$F=100$） | $2$（$F=90$） | $3$（$F=80$） |\n| :-: | :-: | :-: | :-: |\n| $1$ | $100$ | $63$ | $48$ |\n| $2$ | $90$ | $90$ | $88$ |\n| $3$ | $80$ | $72$ | $80$ |\n\n- 发布第 $3$ 个视频后能获得的最终收益为：\n\n\n| 第 $3$ 个视频类型（行）/ 第 $2$ 个视频类型（列） | $1$（$P = 1000$） | $2$（$P=1400$） | $3$（$P=1700$） |\n| :-: | :-: | :-: | :-: |\n| $1$ | $1000 + 500$ | $1400+315$ | $1700+240$ |\n| $2$ | $1000 + 900$ | $1400+900$ | $1700+880$ |\n| $3$ | $1000 + 1200$ | $1400+1080$ | $1700+1200$ |\n\n因此，总收益期望为 ${19515 \\over 9}={6505 \\over 3} \\approx 2168.333333$。在本样例所示数据范围下，`decimal` 和 `inverse` 输出均可用，两种答案均正确。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| $\\text{Subtask}$ | $n \\le$ | $t \\le $ | 特殊性质 | 是否可使用 `decimal` | 分值 |\n| :-: | :-: | :-: | :-: | :-: | :-: |\n| $0$ | $8$ | $8$ | | 是 | $9$ |\n| $1$ | $18$ | $200$ | | 是 | $6$ |\n| $2$ | $10^9$ | $1$ | | 否 | $4$ |\n| $3$ | $100$ | $200$ | | 是 | $7$ |\n| $4$ | $100$ | $200$ | A | 是 | $10$ |\n| $5$ | $10^9$ | $200$ | B | 是 | $6$ |\n| $6$ | $10^9$ | $100$ | | 否 | $12$ |\n| $7$ | $10^4$ | $200$ | | 否 | $11$ |\n| $8$ | $10^9$ | $200$ | | 否 | $35$ |\n\n特殊性质 A：$d_{i,j} \\in \\{0,0.5,1\\}$。\n\n特殊性质 B：$d_{i,j}=1$。\n\n对于所有数据，保证 $1 \\le n \\le 10^9, 1 \\le t \\le 200, 0 \\le d \\le 2$。", "locale": "zh-CN"}}}
{"pid": "P11416", "type": "P", "difficulty": 3, "samples": [["2\n114\n1919", "13\n4"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": [], "title": "[EPXLQ2024 fall round] Simple Math Problem", "background": "\n![](https://cdn.luogu.com.cn/upload/image_hosting/v0535jal.png)\n\n于是原先的 C 变成了 A，原先的 D 变成了 B，原先的 F 变成了 E，然后就有了这道题。\n\n注：想拿到**快速 AK 变换奖**请在代码注释部分写明本题代码复杂度证明。", "description": "Cute_QiQi 有一个可爱的整数 $n$。\n\n现在，Cute_QiQi 想知道有多少个 $m \\in (0,n)$，满足 $nm$ 能被 $n-m$ 整除。", "inputFormat": "**本题单个测试点内有多组测试数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n以下 $T$ 行，每行一个整数 $n$。", "outputFormat": "输出 $T$ 行，每行一个整数表示答案。", "hint": "### 样例解释\n\n当 $n = 114$ 时，可有 $m \\in \\{38,57,76,78,95,96,102,105,108,110,111,112,113\\}$。\n\n当 $n = 1919$ 时，可有 $m \\in \\{1558,1818,1900,1918\\}$。\n\n### 数据规模与约定\n\n**本题采用捆绑测试与子任务依赖。**\n\n设 $p$ 为 $n$ 质因数分解后最大的质数，$p,q$ 均为质数。\n\n| $\\text{Subtask}$ | $n \\le$ | 特殊性质 | 分值 | 依赖子任务\n| :-: | :-: | :-: | :-: | :-: |\n| $0$ | $10^{14}$ | $n = p$ | $2$ | |\n| $1$ | $10^3$ | |  $7$ | |\n| $2$ | $10^6$ | |$11$ | $1$ |\n| $3$ | $10^9$ | |$24$ | $1,2$ |\n| $4$ | $10^{14}$ | $n = pq$ |  $12$ | |\n| $5$ | $10^{14}$ | $p \\le 10^6$ |   $15$ | |\n| $6$ | $10^{14}$ | |  $29$ | $0,1,2,3,4,5$ |\n\n对于所有数据，$1 \\le n \\le 10^{14}, 1 \\le T \\le 10$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[EPXLQ2024 fall round] Simple Math Problem", "background": "\n![](https://cdn.luogu.com.cn/upload/image_hosting/v0535jal.png)\n\n于是原先的 C 变成了 A，原先的 D 变成了 B，原先的 F 变成了 E，然后就有了这道题。\n\n注：想拿到**快速 AK 变换奖**请在代码注释部分写明本题代码复杂度证明。", "description": "Cute_QiQi 有一个可爱的整数 $n$。\n\n现在，Cute_QiQi 想知道有多少个 $m \\in (0,n)$，满足 $nm$ 能被 $n-m$ 整除。", "inputFormat": "**本题单个测试点内有多组测试数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n以下 $T$ 行，每行一个整数 $n$。", "outputFormat": "输出 $T$ 行，每行一个整数表示答案。", "hint": "### 样例解释\n\n当 $n = 114$ 时，可有 $m \\in \\{38,57,76,78,95,96,102,105,108,110,111,112,113\\}$。\n\n当 $n = 1919$ 时，可有 $m \\in \\{1558,1818,1900,1918\\}$。\n\n### 数据规模与约定\n\n**本题采用捆绑测试与子任务依赖。**\n\n设 $p$ 为 $n$ 质因数分解后最大的质数，$p,q$ 均为质数。\n\n| $\\text{Subtask}$ | $n \\le$ | 特殊性质 | 分值 | 依赖子任务\n| :-: | :-: | :-: | :-: | :-: |\n| $0$ | $10^{14}$ | $n = p$ | $2$ | |\n| $1$ | $10^3$ | |  $7$ | |\n| $2$ | $10^6$ | |$11$ | $1$ |\n| $3$ | $10^9$ | |$24$ | $1,2$ |\n| $4$ | $10^{14}$ | $n = pq$ |  $12$ | |\n| $5$ | $10^{14}$ | $p \\le 10^6$ |   $15$ | |\n| $6$ | $10^{14}$ | |  $29$ | $0,1,2,3,4,5$ |\n\n对于所有数据，$1 \\le n \\le 10^{14}, 1 \\le T \\le 10$。", "locale": "zh-CN"}}}
{"pid": "P11417", "type": "P", "difficulty": 5, "samples": [["5", "78"], ["142857", "67850062"], ["10000000", "505679580"]], "limits": {"time": [800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800], "memory": [51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200]}, "tags": ["数论", "深度优先搜索 DFS", "素数判断,质数,筛法"], "title": "[Sloi 2024]D1T1 精卫", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/p38htsuu.png)", "description": "$f(x)$ 为积性函数，且满足 $f(p^k)=p^{2k}+k$（$p$ 为素数）。\n\n令 $g(x)=\\prod\\limits_{d|x}f(d)\\space \\bmod\\space (10^9+7)$ ，请计算 $g(i)\\space (1\\le i \\le n)$ 的异或和。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "一行一个非负整数。", "hint": "**本题采用捆绑测试**\n\n| Subtask | n | Score |\n| :----------: | :----------: | :----------: |\n| $1$ | $\\le10^4$ | $10$ |\n| $2$ | $\\le 5\\times 10^6$ | $30$ |\n| $3$ | $\\le 2\\times 10^7$ | $30$ |\n| $4$ | $\\le 5\\times10^7$ | $30$ |\n\n对 $100\\%$ 的数据，$1\\le n \\le 5\\times10^{7} $。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Sloi 2024]D1T1 精卫", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/p38htsuu.png)", "description": "$f(x)$ 为积性函数，且满足 $f(p^k)=p^{2k}+k$（$p$ 为素数）。\n\n令 $g(x)=\\prod\\limits_{d|x}f(d)\\space \\bmod\\space (10^9+7)$ ，请计算 $g(i)\\space (1\\le i \\le n)$ 的异或和。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "一行一个非负整数。", "hint": "**本题采用捆绑测试**\n\n| Subtask | n | Score |\n| :----------: | :----------: | :----------: |\n| $1$ | $\\le10^4$ | $10$ |\n| $2$ | $\\le 5\\times 10^6$ | $30$ |\n| $3$ | $\\le 2\\times 10^7$ | $30$ |\n| $4$ | $\\le 5\\times10^7$ | $30$ |\n\n对 $100\\%$ 的数据，$1\\le n \\le 5\\times10^{7} $。\n", "locale": "zh-CN"}}}
{"pid": "P11418", "type": "P", "difficulty": 7, "samples": [["10\n", "12"], ["20", "27"], ["2347", "6126"], ["9234799", "43445933"], ["99234799", "524524311"], ["1000000000", "5844921982"], ["23477145069", "154961952468"]], "limits": {"time": [1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "数学", "数论"], "title": "[Sloi 2024]D1T2 简单的反链求和问题", "background": "本题 **idea from**：[Projecteuler P386](https://pe-cn.github.io/386/).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0yeo7vce.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8r5uh8th.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h7syotrv.png)\n\n图源：[zhihu](https://www.zhihu.com/question/19813666/answer/45229974).", "description": "反链是序理论中的一个极其优美的结构。\n\n---\n\n给定正整数 $n$，记 $S(n)$ 为 $n$ 的约数构成的集合。\n\n若 $S(n)$ 的子集 $A$ 只包含一个元素，或者 $A$ 中任意一个元素均不能整除其它元素，则称 $A$ 为 $S(n)$ 的**反链**。\n\n例如：$S(30) = \\{1, 2, 3, 5, 6, 10, 15, 30\\}$。\n\n- $\\{2, 5, 6\\}$ 不是 $S(30)$ 的反链。\n\n- $\\{2, 3, 5\\}$ 是 $S(30)$ 的反链。\n\n**hhoppitree** 喜欢长的反链，记 $f(n)$ 表示 $S(n)$ 的最长反链长度，她需要你帮忙求出 $ans=\\sum\\limits_{k=1}^n f(k)$。\n\n~~如果做不出来，她就会喵的一声扑向你~~", "inputFormat": "一行一个正整数表示 $n$。", "outputFormat": "一行一个正整数表示 $ans$。\n\n**可以证明答案一定在 `long long` 范围内。**", "hint": "样例 $1$：除了 $f(6)=f(10)=2$，其余 $f(k)=1(1\\le k\\le 10)$。\n\n样例 $2$：除了 $f(6)=f(10)=f(12)=f(14)=f(15)=f(18)=f(20)=2$，其余 $f(k)=1(1\\le k\\le 20)$。\n\n---\n\n**本题采用捆绑测试**\n\n对于所有测试数据，保证 $1\\le n\\le 123477145069\\approx 1.2\\times 10^{11}$。\n\n**可以证明答案一定在 `long long` 范围内。**\n\n|Subtask\t| $n \\le$ | Score |\n| :--: | :--: | :--: |\n|$1$ | $10$ | $5$ |\n|$2$ | $2500$ | $5$ |\n|$3$ | $10^6$ | $10$ |\n|$4$ | $10^7$ | $10$ |\n|$5$ | $10^8$ | $10$ |\n|$6$ | $10^9$ | $20$ |\n|$7$ | $23477145069$ | $20$ |\n|$8$ | $123477145069$ | $20$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Sloi 2024]D1T2 简单的反链求和问题", "background": "本题 **idea from**：[Projecteuler P386](https://pe-cn.github.io/386/).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0yeo7vce.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8r5uh8th.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h7syotrv.png)\n\n图源：[zhihu](https://www.zhihu.com/question/19813666/answer/45229974).", "description": "反链是序理论中的一个极其优美的结构。\n\n---\n\n给定正整数 $n$，记 $S(n)$ 为 $n$ 的约数构成的集合。\n\n若 $S(n)$ 的子集 $A$ 只包含一个元素，或者 $A$ 中任意一个元素均不能整除其它元素，则称 $A$ 为 $S(n)$ 的**反链**。\n\n例如：$S(30) = \\{1, 2, 3, 5, 6, 10, 15, 30\\}$。\n\n- $\\{2, 5, 6\\}$ 不是 $S(30)$ 的反链。\n\n- $\\{2, 3, 5\\}$ 是 $S(30)$ 的反链。\n\n**hhoppitree** 喜欢长的反链，记 $f(n)$ 表示 $S(n)$ 的最长反链长度，她需要你帮忙求出 $ans=\\sum\\limits_{k=1}^n f(k)$。\n\n~~如果做不出来，她就会喵的一声扑向你~~", "inputFormat": "一行一个正整数表示 $n$。", "outputFormat": "一行一个正整数表示 $ans$。\n\n**可以证明答案一定在 `long long` 范围内。**", "hint": "样例 $1$：除了 $f(6)=f(10)=2$，其余 $f(k)=1(1\\le k\\le 10)$。\n\n样例 $2$：除了 $f(6)=f(10)=f(12)=f(14)=f(15)=f(18)=f(20)=2$，其余 $f(k)=1(1\\le k\\le 20)$。\n\n---\n\n**本题采用捆绑测试**\n\n对于所有测试数据，保证 $1\\le n\\le 123477145069\\approx 1.2\\times 10^{11}$。\n\n**可以证明答案一定在 `long long` 范围内。**\n\n|Subtask\t| $n \\le$ | Score |\n| :--: | :--: | :--: |\n|$1$ | $10$ | $5$ |\n|$2$ | $2500$ | $5$ |\n|$3$ | $10^6$ | $10$ |\n|$4$ | $10^7$ | $10$ |\n|$5$ | $10^8$ | $10$ |\n|$6$ | $10^9$ | $20$ |\n|$7$ | $23477145069$ | $20$ |\n|$8$ | $123477145069$ | $20$ |", "locale": "zh-CN"}}}
{"pid": "P11419", "type": "P", "difficulty": 7, "samples": [["3\n1000\n1000000\n1000000000", "0\n0\n0"], ["1\n23571113171923", "1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数论", "素数判断,质数,筛法", "Stern-Brocot 树"], "title": "[Sloi 2024]D1T3 pi(n)", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/3zet5xqo.png)\n\n很多年前，zydy 突发奇想：只要算出 $\\pi(n)\\bmod2，\\pi(n)\\bmod3，\\pi(n)\\bmod5，···$，就能得到 $\\pi(n)$。很多年后，zydy 才意识到这其实是可行的，现在你只需要帮助他算出 $\\pi(n)\\bmod2$。", "description": "定义 $\\pi(n)$ 为不大于 $n$ 的素数的个数，给定 $n$，计算 $\\pi(n)\\bmod 2$ 。", "inputFormat": "输入第一行 $T$，表示数据组数。\n\n以下 $T$ 行，每行一个正整数 $n$。", "outputFormat": "输出 $T$ 行，每行一个非负整数，为 $\\pi(n)\\bmod 2$ 的值。", "hint": "**本题采用捆绑测试**\n| Subtask | T | n | Score |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $=1000$ | $\\le 10^8$ | $20$ |\n| $2$ | $=10$ | $\\le 10^{11}$ | $20$ |\n| $3$ | $=10$ | $\\le 10^{13}$ | $20$ |\n| $4$ | $=5$ | $\\le 10^{15}$ | $20$ |\n| $5$ | $=5$ | $\\le 10^{16}$ | $20$ |\n\n对 $100\\%$ 的数据，$T\\le 1000$，$1\\le n\\le 10^{16}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Sloi 2024]D1T3 pi(n)", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/3zet5xqo.png)\n\n很多年前，zydy 突发奇想：只要算出 $\\pi(n)\\bmod2，\\pi(n)\\bmod3，\\pi(n)\\bmod5，···$，就能得到 $\\pi(n)$。很多年后，zydy 才意识到这其实是可行的，现在你只需要帮助他算出 $\\pi(n)\\bmod2$。", "description": "定义 $\\pi(n)$ 为不大于 $n$ 的素数的个数，给定 $n$，计算 $\\pi(n)\\bmod 2$ 。", "inputFormat": "输入第一行 $T$，表示数据组数。\n\n以下 $T$ 行，每行一个正整数 $n$。", "outputFormat": "输出 $T$ 行，每行一个非负整数，为 $\\pi(n)\\bmod 2$ 的值。", "hint": "**本题采用捆绑测试**\n| Subtask | T | n | Score |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $=1000$ | $\\le 10^8$ | $20$ |\n| $2$ | $=10$ | $\\le 10^{11}$ | $20$ |\n| $3$ | $=10$ | $\\le 10^{13}$ | $20$ |\n| $4$ | $=5$ | $\\le 10^{15}$ | $20$ |\n| $5$ | $=5$ | $\\le 10^{16}$ | $20$ |\n\n对 $100\\%$ 的数据，$T\\le 1000$，$1\\le n\\le 10^{16}$。", "locale": "zh-CN"}}}
{"pid": "P11420", "type": "P", "difficulty": 7, "samples": [["3 2 2\n1 1\n", "1\n"], ["10 3 10\n1 2 3 4 5 6 7 8", "721023399"], ["20 12 98765\n9 8 7 6 5 4 3 2 1", "560770686"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2024", "O2优化", "CTT（清华集训/北大集训）"], "title": "[清华集训 2024] 乘积的期望", "background": "", "description": "有一个长度为 $n$ 的序列 $a_1, a_2, \\cdots , a_n$。初始序列的所有元素均为 $0$。再给定正整数\n$m$、$c$ 和 $(n - m + 1)$ 个正整数 $b_1, b_2, \\cdots , b_{n−m+1}$。\n\n对序列 $a_1, a_2, \\cdots , a_n$ 进行 $c$ 次操作，每次操作为：\n- 随机选择整数 $1 \\le x \\le n - m + 1$，其中选到 $y$（$1\\le y\\le n-m+1$）的概率为 $\\displaystyle \\frac{b_y}{\\sum_{i=1}^{n-m+1} b_i}$。将 $a_x, a_{x+1}, \\cdots, a_{x+m−1}$ 增加 $1$。\n\n$c$ 次操作中对 $x$ 的随机是独立的。\n\n求操作完成后序列中所有元素的乘积的期望。为了避免浮点数输出，你需要将答案对 $998244353$ 取模。", "inputFormat": "从标准输入读入数据。\n\n第一行三个整数 $n, m, c$，分别表示序列长度、操作区间长度和操作次数。\n\n第二行 $(n - m + 1)$ 个整数 $b_1, \\cdots , b_{n-m+1}$，描述随机的权重。", "outputFormat": "输出到标准输出。\n\n输出一行一个整数，表示 $c$ 次操作后序列中所有数的乘积的期望。", "hint": "#### 【样例 $1$ 解释】\n\n当两次操作选择的 $x$ 不同时，最终序列为 $[1,2,1]$，序列元素乘积为 $2$；否则序列为 $[2,2,0]$ 或 $[0,2,2]$，序列元素乘积均为 $0$。两次操作选择的 $x$ 不同的概率为 $\\frac{1}{2}$ ，因此输出 $2\\times \\frac{1}{2}=1$。\n\n#### 子任务\n\n对于所有测试数据，$2 \\le m \\le n \\le 50$，$1 \\le c < 998244353$，对于 $1 \\le i \\le n - m + 1$，$1 \\le b_i \\le 10^5$。\n\n- Subtask 1（$10\\%$）：$m \\le 8$。\n- Subtask 2（$20\\%$）：$m \\le 16$。\n- Subtask 3（$15\\%$）：$n \\le 20, c \\le n$。\n- Subtask 4（$15\\%$）：$n \\le 30, c \\le n$。\n- Subtask 5（$15\\%$）：$n \\le 40, c \\le n$。\n- Subtask 6（$15\\%$）：$c \\le n$。\n- Subtask 7（$10\\%$）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2024] 乘积的期望", "background": "", "description": "有一个长度为 $n$ 的序列 $a_1, a_2, \\cdots , a_n$。初始序列的所有元素均为 $0$。再给定正整数\n$m$、$c$ 和 $(n - m + 1)$ 个正整数 $b_1, b_2, \\cdots , b_{n−m+1}$。\n\n对序列 $a_1, a_2, \\cdots , a_n$ 进行 $c$ 次操作，每次操作为：\n- 随机选择整数 $1 \\le x \\le n - m + 1$，其中选到 $y$（$1\\le y\\le n-m+1$）的概率为 $\\displaystyle \\frac{b_y}{\\sum_{i=1}^{n-m+1} b_i}$。将 $a_x, a_{x+1}, \\cdots, a_{x+m−1}$ 增加 $1$。\n\n$c$ 次操作中对 $x$ 的随机是独立的。\n\n求操作完成后序列中所有元素的乘积的期望。为了避免浮点数输出，你需要将答案对 $998244353$ 取模。", "inputFormat": "从标准输入读入数据。\n\n第一行三个整数 $n, m, c$，分别表示序列长度、操作区间长度和操作次数。\n\n第二行 $(n - m + 1)$ 个整数 $b_1, \\cdots , b_{n-m+1}$，描述随机的权重。", "outputFormat": "输出到标准输出。\n\n输出一行一个整数，表示 $c$ 次操作后序列中所有数的乘积的期望。", "hint": "#### 【样例 $1$ 解释】\n\n当两次操作选择的 $x$ 不同时，最终序列为 $[1,2,1]$，序列元素乘积为 $2$；否则序列为 $[2,2,0]$ 或 $[0,2,2]$，序列元素乘积均为 $0$。两次操作选择的 $x$ 不同的概率为 $\\frac{1}{2}$ ，因此输出 $2\\times \\frac{1}{2}=1$。\n\n#### 子任务\n\n对于所有测试数据，$2 \\le m \\le n \\le 50$，$1 \\le c < 998244353$，对于 $1 \\le i \\le n - m + 1$，$1 \\le b_i \\le 10^5$。\n\n- Subtask 1（$10\\%$）：$m \\le 8$。\n- Subtask 2（$20\\%$）：$m \\le 16$。\n- Subtask 3（$15\\%$）：$n \\le 20, c \\le n$。\n- Subtask 4（$15\\%$）：$n \\le 30, c \\le n$。\n- Subtask 5（$15\\%$）：$n \\le 40, c \\le n$。\n- Subtask 6（$15\\%$）：$c \\le n$。\n- Subtask 7（$10\\%$）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P11421", "type": "P", "difficulty": 6, "samples": [["5 5\n1 2 1 1 2\n0 0 0 0 0\n2 2 1\n4 2 0\n4 2 1\n2 2 0\n1 1 1", "0\n1\n1\n2\n1\n1"], ["10 10\n2 1 2 2 2 2 1 2 2 2\n1 1 0 0 0 0 1 0 0 0\n3 2 0\n5 1 0\n9 1 1\n4 2 1\n8 1 1\n2 1 0\n1 2 1\n8 2 0\n1 1 1\n9 1 0", "1\n1\n1\n2\n3\n3\n4\n4\n3\n3\n2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["贪心", "线段树", "二分", "2024", "O2优化", "栈", "CTT（清华集训/北大集训）"], "title": "[清华集训 2024] 最大匹配 2", "background": "", "description": "\n给定长度为 $n$ 的整数序列 $a_1,a_2,\\cdots,a_n$ 和长度为 $n$ 的 $01$ 序列 $b_1, b_2, \\cdots , b_n$。\n\n对于 $1 \\le i < j \\le n$，称二元组 $(i, j)$ **构成匹配**当且仅当 $b_i = 0$ 且 $b_j = 1$。\n\n定义**极大匹配方案** $S_{\\max}$ 为满足以下所有条件的二元组集合：\n\n- 对于任意 $(u, v) \\in S_{\\max}$，$1 \\le u < v \\le n$ 且 $(u, v)$ 构成匹配；\n- 每一个整数 $1 \\le i \\le n$ 在 $S_{\\max}$ 中出现至多一次；\n- 在满足以上条件的前提下，满足 $a_u = a_v$ 的二元组 $(u, v)$ 数量最多，即 $\\displaystyle \\sum_{(u,v)\\in S_{\\max}}[a_u=a_v]$ 最大；\n- 在满足以上条件的前提下，$|S_{\\max}|$ 最大。\n\n给定 $m$ 次修改，每次修改给出 $x, p, q$，表示将 $(a_x, b_x)$ 修改为 $(p, q)$。\n\n你需要对于每个 $1 \\le i \\le m + 1$ 求出：按输入顺序依次进行前 $(i - 1)$ 次操作后，极大匹配方案 $S_{\\max}$ 的大小 $|S_{\\max}|$。\n", "inputFormat": "\n从标准输入读入数据。\n\n输入的第一行两个整数 $n, m$，表示序列长度和操作次数。\n\n第二行 $n$ 个整数 $a_1, a_2, \\cdots , a_n$ 描述序列 $a$。\n\n第三行 $n$ 个整数 $b_1, b_2, \\cdots , b_n$ 描述序列 $b$。\n\n接下来 $m$ 行每行三个整数 $x, p, q$，描述一次修改。", "outputFormat": "\n输出到标准输出。\n\n输出 $(m + 1)$ 行，每行一个整数，第 $i$ 行表示按输入顺序依次进行前 $(i - 1)$ 次操作后 $|S_{\\max}|$ 的值。", "hint": "\n#### 【样例 $1$ 解释】\n\n- 初始情况，由于所有的 $b_i$ 都等于 $0$，因此没有二元组构成匹配，极大匹配方案的大小为 $0$，故第一行输出 $0$。\n- 进行第一次修改后，$b_2 = 1$，极大匹配方案为 $\\{(1, 2)\\}$，故第二行输出 $1$。\n- 进行前三次修改后，序列 $a$ 为 $[1,2,1,2,2]$，序列 $b$ 为 $[0,1,0,1,0]$。极大匹配方案为 $\\{(1, 2), (3, 4)\\}$，故第四行输出 $2$。注意此时 $(4, 5)$ 有 $b_4 = 1$，$b_5 = 0$，并不构成匹配。\n\n#### 子任务\n\n对于所有测试数据，\n\n- $1 \\le n \\le 2 × 10^5$，$0 \\le m \\le 2 × 10^5$；\n- 对于 $1 \\le i \\le n$，$1 \\le a_i \\le n$，$0 \\le b_i \\le 1$；\n- 每次修改中有 $1 \\le x \\le n$，$1 \\le p \\le n$，$0 \\le q \\le 1$。\n\n---\n\n- Subtask 1（$10\\%$）：$n \\le 100$，$m = 0$。\n- Subtask 2（$15\\%$）：$n \\le 2 \\times 10^3$，$m = 0$。\n- Subtask 3（$20\\%$）：$m = 0$。\n- Subtask 4（$15\\%$）：$a_i, p \\le 2$。\n- Subtask 5（$20\\%$）：$n, m \\le 10^5$。\n- Subtask 6（$20\\%$）：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2024] 最大匹配 2", "background": "", "description": "\n给定长度为 $n$ 的整数序列 $a_1,a_2,\\cdots,a_n$ 和长度为 $n$ 的 $01$ 序列 $b_1, b_2, \\cdots , b_n$。\n\n对于 $1 \\le i < j \\le n$，称二元组 $(i, j)$ **构成匹配**当且仅当 $b_i = 0$ 且 $b_j = 1$。\n\n定义**极大匹配方案** $S_{\\max}$ 为满足以下所有条件的二元组集合：\n\n- 对于任意 $(u, v) \\in S_{\\max}$，$1 \\le u < v \\le n$ 且 $(u, v)$ 构成匹配；\n- 每一个整数 $1 \\le i \\le n$ 在 $S_{\\max}$ 中出现至多一次；\n- 在满足以上条件的前提下，满足 $a_u = a_v$ 的二元组 $(u, v)$ 数量最多，即 $\\displaystyle \\sum_{(u,v)\\in S_{\\max}}[a_u=a_v]$ 最大；\n- 在满足以上条件的前提下，$|S_{\\max}|$ 最大。\n\n给定 $m$ 次修改，每次修改给出 $x, p, q$，表示将 $(a_x, b_x)$ 修改为 $(p, q)$。\n\n你需要对于每个 $1 \\le i \\le m + 1$ 求出：按输入顺序依次进行前 $(i - 1)$ 次操作后，极大匹配方案 $S_{\\max}$ 的大小 $|S_{\\max}|$。\n", "inputFormat": "\n从标准输入读入数据。\n\n输入的第一行两个整数 $n, m$，表示序列长度和操作次数。\n\n第二行 $n$ 个整数 $a_1, a_2, \\cdots , a_n$ 描述序列 $a$。\n\n第三行 $n$ 个整数 $b_1, b_2, \\cdots , b_n$ 描述序列 $b$。\n\n接下来 $m$ 行每行三个整数 $x, p, q$，描述一次修改。", "outputFormat": "\n输出到标准输出。\n\n输出 $(m + 1)$ 行，每行一个整数，第 $i$ 行表示按输入顺序依次进行前 $(i - 1)$ 次操作后 $|S_{\\max}|$ 的值。", "hint": "\n#### 【样例 $1$ 解释】\n\n- 初始情况，由于所有的 $b_i$ 都等于 $0$，因此没有二元组构成匹配，极大匹配方案的大小为 $0$，故第一行输出 $0$。\n- 进行第一次修改后，$b_2 = 1$，极大匹配方案为 $\\{(1, 2)\\}$，故第二行输出 $1$。\n- 进行前三次修改后，序列 $a$ 为 $[1,2,1,2,2]$，序列 $b$ 为 $[0,1,0,1,0]$。极大匹配方案为 $\\{(1, 2), (3, 4)\\}$，故第四行输出 $2$。注意此时 $(4, 5)$ 有 $b_4 = 1$，$b_5 = 0$，并不构成匹配。\n\n#### 子任务\n\n对于所有测试数据，\n\n- $1 \\le n \\le 2 × 10^5$，$0 \\le m \\le 2 × 10^5$；\n- 对于 $1 \\le i \\le n$，$1 \\le a_i \\le n$，$0 \\le b_i \\le 1$；\n- 每次修改中有 $1 \\le x \\le n$，$1 \\le p \\le n$，$0 \\le q \\le 1$。\n\n---\n\n- Subtask 1（$10\\%$）：$n \\le 100$，$m = 0$。\n- Subtask 2（$15\\%$）：$n \\le 2 \\times 10^3$，$m = 0$。\n- Subtask 3（$20\\%$）：$m = 0$。\n- Subtask 4（$15\\%$）：$a_i, p \\le 2$。\n- Subtask 5（$20\\%$）：$n, m \\le 10^5$。\n- Subtask 6（$20\\%$）：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P11422", "type": "P", "difficulty": 7, "samples": [["0 3 20\n4 5 11 11 6\n4 ‐11 15 17 5\n4 2 15 4 5", "Correct.\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2024", "交互题", "O2优化", "CTT（清华集训/北大集训）"], "title": "[清华集训 2024] 平原", "background": "\n“只要你心里的念是真的，只要你心里的念是诚的，高山大海都会给你让路。”——《平原上的摩西》\n\n提交时，**不要 `#include \"plain.h\"`。** 将以下的代码粘贴到文件头。\n\n```cpp\n#include <tuple>\n#include <utility>\nbool query(int x, int y);\nstd::tuple<long long, int, long long, int> Find(int task_id, int V, int limit);\n```", "description": "\n**这是一道交互题。**\n\n在二维平面上有一条**未知**的、不与 $y$ 轴平行的直线 $L$。设 $L(x_0)$ 表示直线 $L$ 与 $x = x_0$ 的交点纵坐标。\n\n给定值域 $V$，$L$ 额外满足以下性质：\n- 对于任意整数 $0 \\le x, y \\le V $，$L(x)\\neq y$；\n- $0 \\le L(0), L(V ) \\le V $。\n\n此时 $L$ 将 $S = \\{0, 1, 2, \\cdots , V \\} × \\{0, 1, 2, \\cdots , V \\}$ 分割成两个点集 $S_L = \\{(x, y) \\in S \\vert\nL(x) > y\\}$ 和 $\\overline{S_L} = \\{(x, y) \\in S | L(x) < y\\}$，且它们都不是空集。\n\n你可以向交互库询问至多 $\\mathrm{limit}$ 次询问。每次询问给出整数 $0 \\le x, y \\le V$ ，你可以得到 $(x, y)$ 属于 $S_L$ 还是 $\\overline{S_L}$。\n\n你需要找到直线 $L'$，其不经过 $S$ 中任何一个点，且 $L'$ 和 $L$ 将 $S$ 划分为同样的两个点集。形式化地，$L'$ 需要满足 $\\forall(x, y) \\in S_L, L'(x) > y$ 且 $\\forall(x, y) \\in \\overline{S_L}, L'(x) < y$。\n\n### 实现细节\n\n在洛谷上提交时，请确保你的程序开头**没有** `#include \"plain.h\"`。\n\n你不需要也不应该实现主函数。你需要实现以下函数：\n\n- `std::tuple<long long, int, long long, int> Find(int task_id, int\nV, int limit);`\n    - 其中 `task_id` 表示子任务编号，`V` 表示值域，`limit` 表示最大询问次数。\n    - 你需要返回四元组 $ (k_u, k_v, b_u, b_v)$ 表示你给出的直线 $L'$ 的解析式为 $y = \\frac{k_u}{k_v} x + \\frac{b_u}{b_v} $。\n    - 你需要保证 $k_u$ 与 $b_u$ 在 `long long` 范围内，$k_v$ 与 $b_v$ 在 `int` 范围内，且 $k_v,b_v> 0$。你不需要保证给出的分数是既约分数。可以证明在本题的数据范围下，总是存在这样的 $(k_u, k_v, b_u, b_v)$ 满足条件。\n    - **在最终测试时，交互库将会调用 $T \\le 10^4$ 次 `Find` 函数**。\n\n你可以使用 `std::make_tuple(a,b,c,d)` 来将 $a,b,c,d$ 打包成一个 tuple。\n\n你可以调用如下函数进行一次询问：\n\n- `bool query(int x,int y)`;\n    - 你需要保证 $0 \\le x, y \\le V$ ，在单组测试数据内该函数的调用次数不超过 $\\mathrm{limit}$。\n    - 当 $(x, y) \\in S_L$ 时，函数返回 `true`，否则返回 `false`。\n\n保证在满足题目条件和数据范围的情况下，最终测试时交互库的运行时间不会超过 $\\text{200 ms}$，运行空间不会超过 $\\text{64 MiB}$。\n\n**交互库不是自适应的，即 $L$ 是固定的，不会随着交互过程改变。**\n\n### 测试程序方式\n\n**试题目录下的 `grader.cpp` 是我们提供的交互库参考实现。最终测试的交互库与样例交互库有一定不同，故你的实现不应该依赖样例交互库实现。**\n\n你需要在本题目录下使用如下命令编译得到可执行程序：\n\n```bash\ng++ plain.cpp grader.cpp ‐o plain ‐O2 ‐‐std=c++14 ‐lm\n```\n\n对于编译得到的可执行程序：\n- 可执行文件将从标准输入读入以下格式的数据：\n    - 第一行三个整数 $\\mathrm{task\\_id}, T, \\mathrm{limit}$，分别表示子任务编号，测试数据组数和每组测试数据的询问次数上限。接下来依次输入每组测试数据。\n    - 对于每组测试数据输入一行五个整数 $V, k_u, k_v, b_u, b_v$，其中 V 表示值域，$k_u, k_v, b_u, b_v$ 表示直线 L 的解析式为 $y = \\frac{k_u}{k_v} x + \\frac{b_u}{b_v}$。\n    - 你需要保证 $b_u$ 在 long long 范围内，$k_u, k_v, b_v$ 在 int 范围内，且 $k_v, b_v > 0$。\n\n对于所有测试数据，保证存在这样的 $(k_u, k_v, b_u, b_v)$ 满足题目条件。\n\n- 读入完成之后，交互库将会调用 $T$ 次 `Find` 函数。\n- 若每一组测试数据中你都在给定的询问次数内求出了正确的直线，交互库将在标准输出流输出两行，第一行一个字符串 $\\texttt{Correct.}$，第二行一个整数，表示 $T$ 组测试数据中 `query` 调用次数的最大值。否则交互库会输出对应错误信息，并立即停止程序。", "inputFormat": "见【测试程序方式】。", "outputFormat": "见【测试程序方式】。", "hint": "\n#### 【样例 $1$ 解释】\n$\\mathrm{task\\_id} = 0$ 表示该组数据为样例。\n\n下面三张图依次展示了三组数据对应的函数图像。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rtdb7wd4.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/o908iel6.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/8guqdxhd.png)\n\n#### 子任务\n\n对于所有测试数据，$2 \\le V \\le 10^9$，$1 \\le T \\le 10^4$，$100 \\le \\mathrm{limit} \\le 3, 666$。\n\n---\n\n| 子任务编号 | 分值 | $V $ | $T$ | $\\mathrm{limit}$ | 特殊性质 |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| 1 | $10$ | $\\le 10^2$ | $\\le 10$ | $=110$ | 无 | \n| 2 | $20$ | $\\le 10^9$ | $\\le 10^3$ | $=180$ | A | \n| 3 | $10$ | $\\le 10^5$ | $\\le 10$ | $=1,111$ | 无 | \n| 4 | $15$ | $\\le 10^9$ | $\\le 500$ | $=3,666$ | 无 | \n| 5 | $20$ | $\\le 10^5$ | $\\le 10$ | $=10^2$ | 无 | \n| 6 | $10$ | $\\le 10^9$ | $\\le 10$ | $=180$ | 无 | \n| 7 | $15$ | $\\le 10^9$ | $\\le 10^4$ | $=180$ | 无 | \n\n特殊性质 A：保证直线 $L$ 是由 $y = \\frac{a}{b}x$ 向上平移至多 $\\frac{1}{2b}$ 得到的，其中 $0 < b \\le V$。\n\n#### 评分方式\n\n**本题首先会受到和传统题相同的限制**。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制都会导致相应测试点得 $0$ 分。选手只能在程序中访问自己定义的和交互库给出的变量或数据，及其相应的内存空间。尝试访问其他位置空间将可能导致编译错误或运行错误。\n\n当你在每次 `Find` 调用中，程序调用的 `query` 函数次数不超过 `limit`，且返回的 $L'$ 均满足题目描述中的条件，即通过该测试点，否则该测试点不通过。只有你通过一个子任务的所有测试点时，才能获得该子任务的所有分数。\n\n**选手不应通过非法方式获取交互库的内部信息，如试图与标准输入、输出流进行交互。此类行为将被视为作弊。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2024] 平原", "background": "\n“只要你心里的念是真的，只要你心里的念是诚的，高山大海都会给你让路。”——《平原上的摩西》\n\n提交时，**不要 `#include \"plain.h\"`。** 将以下的代码粘贴到文件头。\n\n```cpp\n#include <tuple>\n#include <utility>\nbool query(int x, int y);\nstd::tuple<long long, int, long long, int> Find(int task_id, int V, int limit);\n```", "description": "\n**这是一道交互题。**\n\n在二维平面上有一条**未知**的、不与 $y$ 轴平行的直线 $L$。设 $L(x_0)$ 表示直线 $L$ 与 $x = x_0$ 的交点纵坐标。\n\n给定值域 $V$，$L$ 额外满足以下性质：\n- 对于任意整数 $0 \\le x, y \\le V $，$L(x)\\neq y$；\n- $0 \\le L(0), L(V ) \\le V $。\n\n此时 $L$ 将 $S = \\{0, 1, 2, \\cdots , V \\} × \\{0, 1, 2, \\cdots , V \\}$ 分割成两个点集 $S_L = \\{(x, y) \\in S \\vert\nL(x) > y\\}$ 和 $\\overline{S_L} = \\{(x, y) \\in S | L(x) < y\\}$，且它们都不是空集。\n\n你可以向交互库询问至多 $\\mathrm{limit}$ 次询问。每次询问给出整数 $0 \\le x, y \\le V$ ，你可以得到 $(x, y)$ 属于 $S_L$ 还是 $\\overline{S_L}$。\n\n你需要找到直线 $L'$，其不经过 $S$ 中任何一个点，且 $L'$ 和 $L$ 将 $S$ 划分为同样的两个点集。形式化地，$L'$ 需要满足 $\\forall(x, y) \\in S_L, L'(x) > y$ 且 $\\forall(x, y) \\in \\overline{S_L}, L'(x) < y$。\n\n### 实现细节\n\n在洛谷上提交时，请确保你的程序开头**没有** `#include \"plain.h\"`。\n\n你不需要也不应该实现主函数。你需要实现以下函数：\n\n- `std::tuple<long long, int, long long, int> Find(int task_id, int\nV, int limit);`\n    - 其中 `task_id` 表示子任务编号，`V` 表示值域，`limit` 表示最大询问次数。\n    - 你需要返回四元组 $ (k_u, k_v, b_u, b_v)$ 表示你给出的直线 $L'$ 的解析式为 $y = \\frac{k_u}{k_v} x + \\frac{b_u}{b_v} $。\n    - 你需要保证 $k_u$ 与 $b_u$ 在 `long long` 范围内，$k_v$ 与 $b_v$ 在 `int` 范围内，且 $k_v,b_v> 0$。你不需要保证给出的分数是既约分数。可以证明在本题的数据范围下，总是存在这样的 $(k_u, k_v, b_u, b_v)$ 满足条件。\n    - **在最终测试时，交互库将会调用 $T \\le 10^4$ 次 `Find` 函数**。\n\n你可以使用 `std::make_tuple(a,b,c,d)` 来将 $a,b,c,d$ 打包成一个 tuple。\n\n你可以调用如下函数进行一次询问：\n\n- `bool query(int x,int y)`;\n    - 你需要保证 $0 \\le x, y \\le V$ ，在单组测试数据内该函数的调用次数不超过 $\\mathrm{limit}$。\n    - 当 $(x, y) \\in S_L$ 时，函数返回 `true`，否则返回 `false`。\n\n保证在满足题目条件和数据范围的情况下，最终测试时交互库的运行时间不会超过 $\\text{200 ms}$，运行空间不会超过 $\\text{64 MiB}$。\n\n**交互库不是自适应的，即 $L$ 是固定的，不会随着交互过程改变。**\n\n### 测试程序方式\n\n**试题目录下的 `grader.cpp` 是我们提供的交互库参考实现。最终测试的交互库与样例交互库有一定不同，故你的实现不应该依赖样例交互库实现。**\n\n你需要在本题目录下使用如下命令编译得到可执行程序：\n\n```bash\ng++ plain.cpp grader.cpp ‐o plain ‐O2 ‐‐std=c++14 ‐lm\n```\n\n对于编译得到的可执行程序：\n- 可执行文件将从标准输入读入以下格式的数据：\n    - 第一行三个整数 $\\mathrm{task\\_id}, T, \\mathrm{limit}$，分别表示子任务编号，测试数据组数和每组测试数据的询问次数上限。接下来依次输入每组测试数据。\n    - 对于每组测试数据输入一行五个整数 $V, k_u, k_v, b_u, b_v$，其中 V 表示值域，$k_u, k_v, b_u, b_v$ 表示直线 L 的解析式为 $y = \\frac{k_u}{k_v} x + \\frac{b_u}{b_v}$。\n    - 你需要保证 $b_u$ 在 long long 范围内，$k_u, k_v, b_v$ 在 int 范围内，且 $k_v, b_v > 0$。\n\n对于所有测试数据，保证存在这样的 $(k_u, k_v, b_u, b_v)$ 满足题目条件。\n\n- 读入完成之后，交互库将会调用 $T$ 次 `Find` 函数。\n- 若每一组测试数据中你都在给定的询问次数内求出了正确的直线，交互库将在标准输出流输出两行，第一行一个字符串 $\\texttt{Correct.}$，第二行一个整数，表示 $T$ 组测试数据中 `query` 调用次数的最大值。否则交互库会输出对应错误信息，并立即停止程序。", "inputFormat": "见【测试程序方式】。", "outputFormat": "见【测试程序方式】。", "hint": "\n#### 【样例 $1$ 解释】\n$\\mathrm{task\\_id} = 0$ 表示该组数据为样例。\n\n下面三张图依次展示了三组数据对应的函数图像。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rtdb7wd4.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/o908iel6.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/8guqdxhd.png)\n\n#### 子任务\n\n对于所有测试数据，$2 \\le V \\le 10^9$，$1 \\le T \\le 10^4$，$100 \\le \\mathrm{limit} \\le 3, 666$。\n\n---\n\n| 子任务编号 | 分值 | $V $ | $T$ | $\\mathrm{limit}$ | 特殊性质 |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| 1 | $10$ | $\\le 10^2$ | $\\le 10$ | $=110$ | 无 | \n| 2 | $20$ | $\\le 10^9$ | $\\le 10^3$ | $=180$ | A | \n| 3 | $10$ | $\\le 10^5$ | $\\le 10$ | $=1,111$ | 无 | \n| 4 | $15$ | $\\le 10^9$ | $\\le 500$ | $=3,666$ | 无 | \n| 5 | $20$ | $\\le 10^5$ | $\\le 10$ | $=10^2$ | 无 | \n| 6 | $10$ | $\\le 10^9$ | $\\le 10$ | $=180$ | 无 | \n| 7 | $15$ | $\\le 10^9$ | $\\le 10^4$ | $=180$ | 无 | \n\n特殊性质 A：保证直线 $L$ 是由 $y = \\frac{a}{b}x$ 向上平移至多 $\\frac{1}{2b}$ 得到的，其中 $0 < b \\le V$。\n\n#### 评分方式\n\n**本题首先会受到和传统题相同的限制**。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制都会导致相应测试点得 $0$ 分。选手只能在程序中访问自己定义的和交互库给出的变量或数据，及其相应的内存空间。尝试访问其他位置空间将可能导致编译错误或运行错误。\n\n当你在每次 `Find` 调用中，程序调用的 `query` 函数次数不超过 `limit`，且返回的 $L'$ 均满足题目描述中的条件，即通过该测试点，否则该测试点不通过。只有你通过一个子任务的所有测试点时，才能获得该子任务的所有分数。\n\n**选手不应通过非法方式获取交互库的内部信息，如试图与标准输入、输出流进行交互。此类行为将被视为作弊。**", "locale": "zh-CN"}}}
{"pid": "P11423", "type": "P", "difficulty": 6, "samples": [["4\n0011\n1010\n0000\n0110\n", "Correct. 1\nYou report 2, with number of energy propagations to be 2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "交互题", "Special Judge", "O2优化", "随机化", "构造", "CTT（清华集训/北大集训）", "Ad-hoc"], "title": "[清华集训 2024] 阿尔塔尔 2", "background": "**这是一道交互题。**\n\n请在提交时不要引用 `altar.h`。\n\n---\n\n一年过去了，阿尔塔尔站在曾被他摧毁的祭坛面前。祭坛上的宝石早已失去了原有的光泽。\n\n“解铃还须系铃人，是这样吗？”他喃喃自语。", "description": "祭坛呈正 $n$ 边形，每个顶点上有一个未激活的宝石。我们用 $1$ 至 $n$ 的整数给每种宝石编号。\n\n宝石之间存在着能量流动关系，这使得激活一些宝石之后可以更容易地激活其他宝石。对于每一对宝石 $(i, j)$（$i\\neq  j$），要么从 $i$ 到 $j$ 存在流动，要么从 $j$ 到 $i$ 存在流动，即当我们把宝石看作点、从 $p$ 到 $q$ 的流动看作一条从 $p$ 到 $q$ 的有向边，得到的图是一个 $n$ 个点的**竞赛图**。阿尔塔尔并不知道宝石之间的能量流动关系如何。\n\n为了激活祭坛，阿尔塔尔需要激活所有的宝石。为此，阿尔塔尔需要首先选择 $n$ 个宝石中的一个将其初始激活，然后进行若干次**能量传递**。每一次**能量传递**的效果为：若这次**能量传递**前宝石 $y$ 未被激活，且存在一个激活的宝石 $x$ 到 $y$ 有流动，那么**能量传递**后 $y$ 就会被激活。在**能量传递**前就被激活的宝石在**能量传递**之后依然是被激活的。\n\n由于**能量传递**需要耗费大量体力，阿尔塔尔希望找到一个宝石，将其初始激活之后可以使用**最少次数的能量传递**激活所有宝石。为此，阿尔塔尔可以进行若干次**能量感知**：给出 $1 ≤ i, j ≤ n$ 且 $i\\neq j$，一次**能量感知**可以确定宝石 $i$ 和 $j$ 之间的能量流动关系。\n\n你需要帮助阿尔塔尔使用尽可能少的**能量感知**操作，确定初始激活的宝石编号。可以证明总是存在一个宝石，将其初始激活后使用有限次能量传递即可激活所有宝石。\n\n### 【实现细节】\n\n你不需要也不应该实现主函数。你需要实现以下函数：\n```cpp\nint altar(int n);\n```\n+ 其中 $n$ 表示祭坛上的宝石数量。\n\n+ 你需要返回一个整数 $x$，表示阿尔塔尔需要初始激活宝石 $x$。你需要保证 $1 ≤ x ≤n$，且在所有宝石中初始激活 $x$ 可以让阿尔塔尔使用最少次数的**能量传递**激活所有宝石。\n\n+ **在最终测试时，交互库会在一次运行中调用 $T = 300$ 次 `altar` 函数。**\n\n你可以调用以下函数进行**能量感知**：\n```cpp\nbool sense(int i, int j);\n```\n+ 你需要保证 $1 ≤ i, j ≤ n$ 且 $i\\neq j$。\n\n+ 若 $i$ 与 $j$ 的能量流动为 $i$ 向 $j$，其返回 `true`，否则返回 `false`。\n\n+ 你需要保证在一次 `altar` 的调用中 `sense` 的调用次数不超过 $4.5 × 10^4$。\n\n在满足题目条件和数据范围的情况下，最终测试时交互库的运行时间不会超过 $150\\text{ ms}$，运行空间不会超过 $256\\text{ MiB}$。\n\n**交互库不是自适应的，即能量流动关系是固定的，不会随着交互过程改变。**\n\n### 【测试程序方式】\n\n**试题目录下的 `grader.cpp` 是我们提供的交互库参考实现。最终测试的交互库与样例交互库有一定不同，故你的实现不应该依赖样例交互库实现。**\n\n你需要在本题目录下使用如下命令编译得到可执行程序：\n```\ng++ grader.cpp sample.cpp -o sample -O2 --std=c++14 -lm\n```\n对于编译得到的可执行程序：", "inputFormat": "可执行文件将从标准输入读入以下格式的数据：\n\n– 第一行一个整数 $n$ 表示祭坛上的宝石数，你需要保证 $3 ≤ n ≤ 300$。\n\n– 接下来 $n$ 行，第 $i$ 行一个长度为 $n$ 的 `01` 字符串，其中第 $j(j\\neq i)$ 个字符为 `1` 表示能量流动从 $i$ 到 $j$，否则表示能量流动从 $j$ 到 $i$。你需要保证第 $i$ 行第 $j$ 个字符和第 $j$ 行第 $i$ 个字符间恰好有一个为 `1` 另一个为 `0`，**样例交互库并不会判断输入是否满足条件。**\n\n读入完成之后，交互库将调用恰好一次函数 `altar`。", "outputFormat": "在 `altar` 函数退出后，如果你给出了正确的宝石编号，交互库将在标准输出流输出 `Correct. X`，其中 $X$ 表示 `sense` 的调用次数，并在标准错误流输出你返回的宝石编号以及对应的**能量传递**次数；否则交互库将在标准输出流输出 `Wrong Answer` 并在标准错误流输出对应错误信息。", "hint": "### 【样例 1 解释】\n\n该样例输出为下发的样例程序在该组样例下的输出。该样例中，`altar` 返回 $1$、$2$、$4$ 均满足条件。\n\n### 【子任务】\n\n对于所有测试数据，单个测试点中 `altar` 函数的调用次数 $T = 300$，每一次调用都有 $3 ≤ n ≤ 300$。\n\n子任务 $1$（$10$ 分，共 $1$ 个测试点）：$n = 300$，两个宝石之间的能量流动方向在两种可能间独立均匀随机。\\\n子任务 $2$（$10$ 分，共 $2$ 个测试点）：存在一个宝石流向所有其他宝石。\\\n子任务 $3$（$80$ 分，共 $7$ 个测试点）：没有特殊限制，依赖子任务 $1$、$2$。\n\n### 【评分方式】\n\n**本题首先会受到和传统题相同的限制**，例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制都会导致相应测试点得 $0$ 分。选手只能在程序中访问自己定义的和交互库给出的变量或数据，及其相应的内存空间。尝试访问其他位置空间将可能导致编译错误或运行错误。\n\n对于每个测试点，如果你的程序出现了非法的函数调用，或没有在所有测试数据中都返回正确的宝石，你将获得该测试点 $0\\%$ 的分数。否则你会按照在 $T$ 组 `altar` 调用中的 `sense` 调用次数的**平均值** $X$，依据如下公式计算该测试点的得分占比：\n\n+ 若 $45000 ≥ X ≥ 10^4$，你可以获得 $\\left(1 + 29 × \\frac{45000-X}{35000}\\right)\\%$ 的分数；\n\n+ 若 $10^4 > X ≥ 2100$，你可以获得 $\\left(30 + 30 ×\\frac{10^4-X}{7900}\\right)\\%$ 的分数；\n\n+ 若 $2100 > X ≥ 700$，你可以获得 $\\left(60 + 20 ×\\left(\\frac{2100}X - 1\\right)\\right)\\%$ 的分数；\n\n+ 若 $X ≤ 700$，你可以获得该测试点 $100\\%$ 的分数；\n\n每个子任务的分数为该子任务中所有测试点的得分占比的最小值与该子任务满分的乘积。\n\n**选手不应通过非法方式获取交互库的内部信息，如试图与标准输入、输出流进行交互。此类行为将被视为作弊。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2024] 阿尔塔尔 2", "background": "**这是一道交互题。**\n\n请在提交时不要引用 `altar.h`。\n\n---\n\n一年过去了，阿尔塔尔站在曾被他摧毁的祭坛面前。祭坛上的宝石早已失去了原有的光泽。\n\n“解铃还须系铃人，是这样吗？”他喃喃自语。", "description": "祭坛呈正 $n$ 边形，每个顶点上有一个未激活的宝石。我们用 $1$ 至 $n$ 的整数给每种宝石编号。\n\n宝石之间存在着能量流动关系，这使得激活一些宝石之后可以更容易地激活其他宝石。对于每一对宝石 $(i, j)$（$i\\neq  j$），要么从 $i$ 到 $j$ 存在流动，要么从 $j$ 到 $i$ 存在流动，即当我们把宝石看作点、从 $p$ 到 $q$ 的流动看作一条从 $p$ 到 $q$ 的有向边，得到的图是一个 $n$ 个点的**竞赛图**。阿尔塔尔并不知道宝石之间的能量流动关系如何。\n\n为了激活祭坛，阿尔塔尔需要激活所有的宝石。为此，阿尔塔尔需要首先选择 $n$ 个宝石中的一个将其初始激活，然后进行若干次**能量传递**。每一次**能量传递**的效果为：若这次**能量传递**前宝石 $y$ 未被激活，且存在一个激活的宝石 $x$ 到 $y$ 有流动，那么**能量传递**后 $y$ 就会被激活。在**能量传递**前就被激活的宝石在**能量传递**之后依然是被激活的。\n\n由于**能量传递**需要耗费大量体力，阿尔塔尔希望找到一个宝石，将其初始激活之后可以使用**最少次数的能量传递**激活所有宝石。为此，阿尔塔尔可以进行若干次**能量感知**：给出 $1 ≤ i, j ≤ n$ 且 $i\\neq j$，一次**能量感知**可以确定宝石 $i$ 和 $j$ 之间的能量流动关系。\n\n你需要帮助阿尔塔尔使用尽可能少的**能量感知**操作，确定初始激活的宝石编号。可以证明总是存在一个宝石，将其初始激活后使用有限次能量传递即可激活所有宝石。\n\n### 【实现细节】\n\n你不需要也不应该实现主函数。你需要实现以下函数：\n```cpp\nint altar(int n);\n```\n+ 其中 $n$ 表示祭坛上的宝石数量。\n\n+ 你需要返回一个整数 $x$，表示阿尔塔尔需要初始激活宝石 $x$。你需要保证 $1 ≤ x ≤n$，且在所有宝石中初始激活 $x$ 可以让阿尔塔尔使用最少次数的**能量传递**激活所有宝石。\n\n+ **在最终测试时，交互库会在一次运行中调用 $T = 300$ 次 `altar` 函数。**\n\n你可以调用以下函数进行**能量感知**：\n```cpp\nbool sense(int i, int j);\n```\n+ 你需要保证 $1 ≤ i, j ≤ n$ 且 $i\\neq j$。\n\n+ 若 $i$ 与 $j$ 的能量流动为 $i$ 向 $j$，其返回 `true`，否则返回 `false`。\n\n+ 你需要保证在一次 `altar` 的调用中 `sense` 的调用次数不超过 $4.5 × 10^4$。\n\n在满足题目条件和数据范围的情况下，最终测试时交互库的运行时间不会超过 $150\\text{ ms}$，运行空间不会超过 $256\\text{ MiB}$。\n\n**交互库不是自适应的，即能量流动关系是固定的，不会随着交互过程改变。**\n\n### 【测试程序方式】\n\n**试题目录下的 `grader.cpp` 是我们提供的交互库参考实现。最终测试的交互库与样例交互库有一定不同，故你的实现不应该依赖样例交互库实现。**\n\n你需要在本题目录下使用如下命令编译得到可执行程序：\n```\ng++ grader.cpp sample.cpp -o sample -O2 --std=c++14 -lm\n```\n对于编译得到的可执行程序：", "inputFormat": "可执行文件将从标准输入读入以下格式的数据：\n\n– 第一行一个整数 $n$ 表示祭坛上的宝石数，你需要保证 $3 ≤ n ≤ 300$。\n\n– 接下来 $n$ 行，第 $i$ 行一个长度为 $n$ 的 `01` 字符串，其中第 $j(j\\neq i)$ 个字符为 `1` 表示能量流动从 $i$ 到 $j$，否则表示能量流动从 $j$ 到 $i$。你需要保证第 $i$ 行第 $j$ 个字符和第 $j$ 行第 $i$ 个字符间恰好有一个为 `1` 另一个为 `0`，**样例交互库并不会判断输入是否满足条件。**\n\n读入完成之后，交互库将调用恰好一次函数 `altar`。", "outputFormat": "在 `altar` 函数退出后，如果你给出了正确的宝石编号，交互库将在标准输出流输出 `Correct. X`，其中 $X$ 表示 `sense` 的调用次数，并在标准错误流输出你返回的宝石编号以及对应的**能量传递**次数；否则交互库将在标准输出流输出 `Wrong Answer` 并在标准错误流输出对应错误信息。", "hint": "### 【样例 1 解释】\n\n该样例输出为下发的样例程序在该组样例下的输出。该样例中，`altar` 返回 $1$、$2$、$4$ 均满足条件。\n\n### 【子任务】\n\n对于所有测试数据，单个测试点中 `altar` 函数的调用次数 $T = 300$，每一次调用都有 $3 ≤ n ≤ 300$。\n\n子任务 $1$（$10$ 分，共 $1$ 个测试点）：$n = 300$，两个宝石之间的能量流动方向在两种可能间独立均匀随机。\\\n子任务 $2$（$10$ 分，共 $2$ 个测试点）：存在一个宝石流向所有其他宝石。\\\n子任务 $3$（$80$ 分，共 $7$ 个测试点）：没有特殊限制，依赖子任务 $1$、$2$。\n\n### 【评分方式】\n\n**本题首先会受到和传统题相同的限制**，例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制都会导致相应测试点得 $0$ 分。选手只能在程序中访问自己定义的和交互库给出的变量或数据，及其相应的内存空间。尝试访问其他位置空间将可能导致编译错误或运行错误。\n\n对于每个测试点，如果你的程序出现了非法的函数调用，或没有在所有测试数据中都返回正确的宝石，你将获得该测试点 $0\\%$ 的分数。否则你会按照在 $T$ 组 `altar` 调用中的 `sense` 调用次数的**平均值** $X$，依据如下公式计算该测试点的得分占比：\n\n+ 若 $45000 ≥ X ≥ 10^4$，你可以获得 $\\left(1 + 29 × \\frac{45000-X}{35000}\\right)\\%$ 的分数；\n\n+ 若 $10^4 > X ≥ 2100$，你可以获得 $\\left(30 + 30 ×\\frac{10^4-X}{7900}\\right)\\%$ 的分数；\n\n+ 若 $2100 > X ≥ 700$，你可以获得 $\\left(60 + 20 ×\\left(\\frac{2100}X - 1\\right)\\right)\\%$ 的分数；\n\n+ 若 $X ≤ 700$，你可以获得该测试点 $100\\%$ 的分数；\n\n每个子任务的分数为该子任务中所有测试点的得分占比的最小值与该子任务满分的乘积。\n\n**选手不应通过非法方式获取交互库的内部信息，如试图与标准输入、输出流进行交互。此类行为将被视为作弊。**", "locale": "zh-CN"}}}
{"pid": "P11424", "type": "P", "difficulty": 7, "samples": [["0\n1 4\n1 2\n1 3\n1 4\n", "2\n"], ["1\n1 4\n1 2\n2 3\n3 4\n", "16\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "O2优化", "CTT（清华集训/北大集训）"], "title": "[清华集训 2024] 颠倒歌", "background": "", "description": "对于树 $T(V, E)$ 和 $S ⊆ V$，记 $f(S, T)$ 表示 $T$ 的对 $S$ 的导出子图（即仅保留 $S$ 中的点和两端都在 $S$ 中的边得到的图）中度数小于等于 $1$ 的点的数量。\n\n对于两棵树 $T_1(V_1, E_1), T_2(V_2, E_2)$，若 $V_1 = V_2$，我们称 $T_1 ≼ T_2$ 当且仅当对于任意 $S_2 ⊆ V_2$，存在 $S_1$ 满足 $S_2 ⊆ S_1 ⊆ V_1$ 且 $f(S_1, T_1) ≤ f(S_2, T_2)$。\n\n称 $T_1, T_2$ 等价当 $T_1 ≼ T_2$ 且 $T_2 ≼ T_1$，记作 $T_1 ∼ T_2$。该等价关系将 $n$ 个点的有标号树划分成若干等价类。\n\n问：\n\n1. 给定 $k$ 棵 $n$ 个点的树 $T_1, T_2 \\dots , T_k$，求满足 $T ≼ T_i, ∀1 ≤ i ≤ k$ 的**有标号树 $T$ 构成的等价类**数量。\n\n2. 给定 $k$ 棵 $n$ 个点的树 $T_1, T_2 \\dots , T_k$，求满足 $T_i ≼ T, ∀1 ≤ i ≤ k$ 的**有标号树** $T$ 数量。\n\n注意两问的计数对象不同。两问答案均对 $998, 244, 353$ 取模。\n\n保证答案取模后非 $0$。", "inputFormat": "从标准输入读入数据。\n\n输入第一行一个整数 $p$，其中 $p ∈ \\{0, 1\\}$，$p = 0$ 表示询问第一问，否则表示询问第二问。\n\n接下来一行两个正整数 $k, n$，分别表示输入树的数量以及点数。\n\n接下来依次输入 $k$ 棵树，对于每棵树输入 $n - 1$ 行每行两个正整数 $u, v$ 描述树中的一条边。", "outputFormat": "输出到标准输出。\n\n输出一行一个整数表示答案对 $998, 244, 353$ 取模后的结果。", "hint": "### 【样例 1 解释】\n\n可以证明 $4$ 个点的有标号树被划分成了 $5$ 个等价类，所有的链在同一个等价类，而其它分别以每个点为菊花中心对应一个等价类。\n\n可以验证链对应的等价类和该树本身所在的等价类均满足要求，而其他等价类不满足要求。\n\n### 【样例 2 解释】\n\n可以验证所有 $4$ 个点的有标号树共 $16$ 个均满足要求。\n\n### 【样例 3 ~ 10】\n\n见题目目录下的 `3.in` ~ `10.in` 与 `3.ans` ~ `10.ans`。\n\n### 【子任务】\n\n对于所有数据，保证 $p ∈ \\{0, 1\\}$，$3 ≤ n ≤ 5000$，$1 ≤ k ≤ 1000$，$1 ≤ u, v ≤ n$，答案取模后不等于 $0$。\n\n| 子任务编号 | $p$ | $n$ | $k$ | 树形态 | 分数 |\n| :-: | :-: | :-: | :-: | :-: | :-: |\n| $1$ | $\\in\\{0,1\\}$ | $\\le8$ | $\\le4$ | 无特殊形态 | $10$ |\n| $2$ | $=0$ | $\\le200$ | $\\le1$ | 菊花 | $4$ |\n| $3$ | $=0$ | $\\le200$ | $\\le1$ | 无特殊形态 | $8$ |\n| $4$ | $=0$ | $\\le200$ | $\\le2$ | 无特殊形态 | $9$ |\n| $5$ | $=0$ | $\\le200$ | $\\le40$ | 无特殊形态 | $10$ |\n| $6$ | $=0$ | $\\le5000$ | $\\le10^3$ | 无特殊形态 | $14$ |\n| $7$ | $=1$ | $\\le200$ | $\\le1$ | 链 | $7$ |\n| $8$ | $=1$ | $\\le200$ | $\\le1$ | 无特殊形态 | $7$ |\n| $9$ | $=1$ | $\\le200$ | $\\le2$ | 无特殊形态 | $10$ |\n| $10$ | $=1$ | $\\le200$ | $\\le40$ | 无特殊形态 | $10$ |\n| $11$ | $=1$ | $\\le5000$ | $\\le10^3$ | 无特殊形态 | $11$ |\n\n“树形态”中，“菊花”指存在一个向所有点有直接连边的点，“链”指所有点度数不超过 $2$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2024] 颠倒歌", "background": "", "description": "对于树 $T(V, E)$ 和 $S ⊆ V$，记 $f(S, T)$ 表示 $T$ 的对 $S$ 的导出子图（即仅保留 $S$ 中的点和两端都在 $S$ 中的边得到的图）中度数小于等于 $1$ 的点的数量。\n\n对于两棵树 $T_1(V_1, E_1), T_2(V_2, E_2)$，若 $V_1 = V_2$，我们称 $T_1 ≼ T_2$ 当且仅当对于任意 $S_2 ⊆ V_2$，存在 $S_1$ 满足 $S_2 ⊆ S_1 ⊆ V_1$ 且 $f(S_1, T_1) ≤ f(S_2, T_2)$。\n\n称 $T_1, T_2$ 等价当 $T_1 ≼ T_2$ 且 $T_2 ≼ T_1$，记作 $T_1 ∼ T_2$。该等价关系将 $n$ 个点的有标号树划分成若干等价类。\n\n问：\n\n1. 给定 $k$ 棵 $n$ 个点的树 $T_1, T_2 \\dots , T_k$，求满足 $T ≼ T_i, ∀1 ≤ i ≤ k$ 的**有标号树 $T$ 构成的等价类**数量。\n\n2. 给定 $k$ 棵 $n$ 个点的树 $T_1, T_2 \\dots , T_k$，求满足 $T_i ≼ T, ∀1 ≤ i ≤ k$ 的**有标号树** $T$ 数量。\n\n注意两问的计数对象不同。两问答案均对 $998, 244, 353$ 取模。\n\n保证答案取模后非 $0$。", "inputFormat": "从标准输入读入数据。\n\n输入第一行一个整数 $p$，其中 $p ∈ \\{0, 1\\}$，$p = 0$ 表示询问第一问，否则表示询问第二问。\n\n接下来一行两个正整数 $k, n$，分别表示输入树的数量以及点数。\n\n接下来依次输入 $k$ 棵树，对于每棵树输入 $n - 1$ 行每行两个正整数 $u, v$ 描述树中的一条边。", "outputFormat": "输出到标准输出。\n\n输出一行一个整数表示答案对 $998, 244, 353$ 取模后的结果。", "hint": "### 【样例 1 解释】\n\n可以证明 $4$ 个点的有标号树被划分成了 $5$ 个等价类，所有的链在同一个等价类，而其它分别以每个点为菊花中心对应一个等价类。\n\n可以验证链对应的等价类和该树本身所在的等价类均满足要求，而其他等价类不满足要求。\n\n### 【样例 2 解释】\n\n可以验证所有 $4$ 个点的有标号树共 $16$ 个均满足要求。\n\n### 【样例 3 ~ 10】\n\n见题目目录下的 `3.in` ~ `10.in` 与 `3.ans` ~ `10.ans`。\n\n### 【子任务】\n\n对于所有数据，保证 $p ∈ \\{0, 1\\}$，$3 ≤ n ≤ 5000$，$1 ≤ k ≤ 1000$，$1 ≤ u, v ≤ n$，答案取模后不等于 $0$。\n\n| 子任务编号 | $p$ | $n$ | $k$ | 树形态 | 分数 |\n| :-: | :-: | :-: | :-: | :-: | :-: |\n| $1$ | $\\in\\{0,1\\}$ | $\\le8$ | $\\le4$ | 无特殊形态 | $10$ |\n| $2$ | $=0$ | $\\le200$ | $\\le1$ | 菊花 | $4$ |\n| $3$ | $=0$ | $\\le200$ | $\\le1$ | 无特殊形态 | $8$ |\n| $4$ | $=0$ | $\\le200$ | $\\le2$ | 无特殊形态 | $9$ |\n| $5$ | $=0$ | $\\le200$ | $\\le40$ | 无特殊形态 | $10$ |\n| $6$ | $=0$ | $\\le5000$ | $\\le10^3$ | 无特殊形态 | $14$ |\n| $7$ | $=1$ | $\\le200$ | $\\le1$ | 链 | $7$ |\n| $8$ | $=1$ | $\\le200$ | $\\le1$ | 无特殊形态 | $7$ |\n| $9$ | $=1$ | $\\le200$ | $\\le2$ | 无特殊形态 | $10$ |\n| $10$ | $=1$ | $\\le200$ | $\\le40$ | 无特殊形态 | $10$ |\n| $11$ | $=1$ | $\\le5000$ | $\\le10^3$ | 无特殊形态 | $11$ |\n\n“树形态”中，“菊花”指存在一个向所有点有直接连边的点，“链”指所有点度数不超过 $2$。", "locale": "zh-CN"}}}
{"pid": "P11425", "type": "P", "difficulty": 7, "samples": [["2\n5\n2 3\n3 1\n5 1\n5 4\n5\n1 4\n2 3\n3 1\n5 3\n", "2\n2 3 1 5 4\n4 5 1 3 2\n2\n4 1 5 3 2\n2 5 3 4 1\n"]], "limits": {"time": [1000, 1000], "memory": [524288, 524288]}, "tags": ["2024", "Special Judge", "O2优化", "CTT（清华集训/北大集训）"], "title": "[清华集训 2024] 路南柯", "background": "", "description": "称一个 $1 ∼ n$ 的排列 $\\{p\\} = \\{p_1, p_2,\\cdots, p_n\\}$ 是一棵 $n$ 个点、点编号为 $1$ 至 $n$ 的树 $T$ 的**拓扑序列**，当且仅当对于任意 $1 ≤ i < n$，恰好存在唯一的 $j > i$ 满足 $p_i$ 与 $p_j$ 之间有连边。\n\n给定树 $T$，你需要给出尽可能少的该树的拓扑序列 $\\{p_1\\}, \\{p_2\\}, \\cdots, \\{p_k\\}$，使得有且仅有树 $T$ 满足 $\\{p_1\\}, \\{p_2\\}, \\cdots, \\{p_k\\}$ 均为该树的合法拓扑序列。", "inputFormat": "从标准输入读入数据。\n\n**本题有多组测试数据**。输入第一行一个正整数 $T$，表示测试数据组数，接下来依次输入每组测试数据。\n\n对于每组数据，输入第一行一个正整数 $n$，表示给定树的大小。接下来 $n - 1$ 行，每行两个正整数 $u, v$ 描述树中存在的一条边。", "outputFormat": "输出到标准输出。\n\n对于每组数据，输出第一行一个正整数 $k$ 表示你给出的拓扑序列数量，接下来 $k$ 行，每行输出一个 $1 ∼ n$ 的排列，描述你给出的拓扑序列。你需要保证 $1 ≤ k ≤ n$，且这 $k$ 个拓扑序列均为对应输入的合法拓扑序列，且只有一棵树满足这些拓扑序列都是其合法拓扑序列。", "hint": "【子任务】\n\n对于所有测试数据，$1 ≤ T ≤ 100$，$3 ≤ n ≤ 100$，$1 ≤ u, v ≤ n$。\n\n本题共有两个测试点。\n\n| 测试点编号 | 分值 | $T$ | $n$ |\n| :-: | :-: | :-: | :-: |\n| $1$ | $20$ | $=10$ | $=10$ |\n| $2$ | $80$ | $=10^2$ | $=10^2$ |\n\n特别地，所有测试点中每组数据均为从所有 $n$ 个点的有标号树中等概率随机选择生成得到的。\n\n### 【评分方式】\n\n对于一个测试点内部的某组数据：\n\n1. 你需要保证 $k$ 以及你输出的序列中每个数都为 $[1, n]$ 范围内的正整数，否则**整个测试点**将会获得 $0$ 分。\n\n2. 若你给出的序列中存在一个不是输入给定树的拓扑序列，那么你**这组数据**的得分比例将会是 $0$。\n\n3. 若存在多棵树满足其这些序列都是其合法的拓扑序列，那么你**这组数据**的得分比例将会是 $0$。\n\n4. 否则如果最优解为 $K$，而你构造的序列数量为 $k$，那么你**这组数据**的得分比例将为 $0.97^{k-K}$。\n\n一个测试点的得分比例将会是该测试点内所有数据的得分比例的**平均值**，一个测试点的实际得分值将会是其总分乘以得分比例。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2024] 路南柯", "background": "", "description": "称一个 $1 ∼ n$ 的排列 $\\{p\\} = \\{p_1, p_2,\\cdots, p_n\\}$ 是一棵 $n$ 个点、点编号为 $1$ 至 $n$ 的树 $T$ 的**拓扑序列**，当且仅当对于任意 $1 ≤ i < n$，恰好存在唯一的 $j > i$ 满足 $p_i$ 与 $p_j$ 之间有连边。\n\n给定树 $T$，你需要给出尽可能少的该树的拓扑序列 $\\{p_1\\}, \\{p_2\\}, \\cdots, \\{p_k\\}$，使得有且仅有树 $T$ 满足 $\\{p_1\\}, \\{p_2\\}, \\cdots, \\{p_k\\}$ 均为该树的合法拓扑序列。", "inputFormat": "从标准输入读入数据。\n\n**本题有多组测试数据**。输入第一行一个正整数 $T$，表示测试数据组数，接下来依次输入每组测试数据。\n\n对于每组数据，输入第一行一个正整数 $n$，表示给定树的大小。接下来 $n - 1$ 行，每行两个正整数 $u, v$ 描述树中存在的一条边。", "outputFormat": "输出到标准输出。\n\n对于每组数据，输出第一行一个正整数 $k$ 表示你给出的拓扑序列数量，接下来 $k$ 行，每行输出一个 $1 ∼ n$ 的排列，描述你给出的拓扑序列。你需要保证 $1 ≤ k ≤ n$，且这 $k$ 个拓扑序列均为对应输入的合法拓扑序列，且只有一棵树满足这些拓扑序列都是其合法拓扑序列。", "hint": "【子任务】\n\n对于所有测试数据，$1 ≤ T ≤ 100$，$3 ≤ n ≤ 100$，$1 ≤ u, v ≤ n$。\n\n本题共有两个测试点。\n\n| 测试点编号 | 分值 | $T$ | $n$ |\n| :-: | :-: | :-: | :-: |\n| $1$ | $20$ | $=10$ | $=10$ |\n| $2$ | $80$ | $=10^2$ | $=10^2$ |\n\n特别地，所有测试点中每组数据均为从所有 $n$ 个点的有标号树中等概率随机选择生成得到的。\n\n### 【评分方式】\n\n对于一个测试点内部的某组数据：\n\n1. 你需要保证 $k$ 以及你输出的序列中每个数都为 $[1, n]$ 范围内的正整数，否则**整个测试点**将会获得 $0$ 分。\n\n2. 若你给出的序列中存在一个不是输入给定树的拓扑序列，那么你**这组数据**的得分比例将会是 $0$。\n\n3. 若存在多棵树满足其这些序列都是其合法的拓扑序列，那么你**这组数据**的得分比例将会是 $0$。\n\n4. 否则如果最优解为 $K$，而你构造的序列数量为 $k$，那么你**这组数据**的得分比例将为 $0.97^{k-K}$。\n\n一个测试点的得分比例将会是该测试点内所有数据的得分比例的**平均值**，一个测试点的实际得分值将会是其总分乘以得分比例。", "locale": "zh-CN"}}}
{"pid": "P11426", "type": "P", "difficulty": 7, "samples": [["3\nBRB", "0 0 1 1 0 0 0"], ["5\nRBBRR", "0 0 0 0 8 8 8 0 0 0 0"], ["见题目目录下的 3.in 与 3.ans。", "见题目目录下的 3.in 与 3.ans。"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "O2优化", "CTT（清华集训/北大集训）"], "title": "[清华集训 2024] 比赛", "background": "", "description": "有 $n$ 名选手，编号分别为 $1, 2, \\dots, n$。编号为 $i$ 的选手的实力值为 $i$。所有选手分为红、蓝两队，其中编号为 $i$ 的选手所在的队伍用字符 $s_i$ 描述。$s_i$ 为 `R` 表示他在红队，$s_i$ 为 `B` 表示他在蓝队。\n\n现在将所有选手排成一个环，每一对相邻且不属于同一队的选手会进行一场比赛，实力值较大的选手获胜，他所在的队伍的得分增加一。\n\n然而，蓝队的选手勾结了裁判，如果一场比赛中红队选手获胜，且他在蓝队选手的顺时针方向上，则这场比赛不计入得分。\n\n现在你想知道，对于每个 $k = -n, \\dots, -1, 0, 1, \\dots, n$，有多少种将选手排列的方法，使得红队得分恰好比蓝队得分大 $k$。两种方案不同，当且仅当存在某个选手，使得他顺时针方向的下一个选手在两个方案中不同。\n\n由于答案很大，你只需要输出答案对 $998,244,353$ 取模后的值。\n", "inputFormat": "从标准输入读入数据。\n\n\n第一行包含一个整数 $n$，表示选手个数。 \n\n第二行包含一个长度为 $n$ 的字符串 $s_1s_2 \\dots s_n$，表示每个选手所属的队伍。\n", "outputFormat": "输出到标准输出。\n\n输出一行 $2n + 1$ 个整数，分别表示 $k = -n, \\dots, 0, \\dots, n$ 的方案数对 $998,244,353$ 取模后的值。\n", "hint": "### 【样例 1 解释】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wanohjrm.png)\n\n如图所示，共有两种排列的方法。\n\n第一种排列中，选手 $1$ 与 $2$ 之间的比赛虽然选手 $2$ 获胜，但他属于红队，且在选手 $1$ 顺时针方向，故这场比赛不计入得分。而选手 $2$ 和 $3$ 之间的比赛蓝方获胜。因此红队得分为 $0$，蓝队得分为 $1$。\n\n第二种排列中，共进行两场比赛，且均计入得分。红队得分与蓝队得分均为 $1$。\n\n### 【子任务】\n\n对于所有数据，满足 $3 \\leq n \\leq 3000$，$s$ 为由 `B` 和 `R` 构成的字符串。\n\n| 子任务编号 | 分值 | $n$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $10$ | $\\le 17$ |\n|  $2$| $10$  |  $\\le 30$ |\n| $3$ | $10$  |  $\\le 50$ |\n|  $4$|  $10$ |  $\\le 200$ |\n| $5$ |  $45$ |  $\\le 500$ |\n| $6$ | $15$  |  $\\le 3000$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2024] 比赛", "background": "", "description": "有 $n$ 名选手，编号分别为 $1, 2, \\dots, n$。编号为 $i$ 的选手的实力值为 $i$。所有选手分为红、蓝两队，其中编号为 $i$ 的选手所在的队伍用字符 $s_i$ 描述。$s_i$ 为 `R` 表示他在红队，$s_i$ 为 `B` 表示他在蓝队。\n\n现在将所有选手排成一个环，每一对相邻且不属于同一队的选手会进行一场比赛，实力值较大的选手获胜，他所在的队伍的得分增加一。\n\n然而，蓝队的选手勾结了裁判，如果一场比赛中红队选手获胜，且他在蓝队选手的顺时针方向上，则这场比赛不计入得分。\n\n现在你想知道，对于每个 $k = -n, \\dots, -1, 0, 1, \\dots, n$，有多少种将选手排列的方法，使得红队得分恰好比蓝队得分大 $k$。两种方案不同，当且仅当存在某个选手，使得他顺时针方向的下一个选手在两个方案中不同。\n\n由于答案很大，你只需要输出答案对 $998,244,353$ 取模后的值。\n", "inputFormat": "从标准输入读入数据。\n\n\n第一行包含一个整数 $n$，表示选手个数。 \n\n第二行包含一个长度为 $n$ 的字符串 $s_1s_2 \\dots s_n$，表示每个选手所属的队伍。\n", "outputFormat": "输出到标准输出。\n\n输出一行 $2n + 1$ 个整数，分别表示 $k = -n, \\dots, 0, \\dots, n$ 的方案数对 $998,244,353$ 取模后的值。\n", "hint": "### 【样例 1 解释】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wanohjrm.png)\n\n如图所示，共有两种排列的方法。\n\n第一种排列中，选手 $1$ 与 $2$ 之间的比赛虽然选手 $2$ 获胜，但他属于红队，且在选手 $1$ 顺时针方向，故这场比赛不计入得分。而选手 $2$ 和 $3$ 之间的比赛蓝方获胜。因此红队得分为 $0$，蓝队得分为 $1$。\n\n第二种排列中，共进行两场比赛，且均计入得分。红队得分与蓝队得分均为 $1$。\n\n### 【子任务】\n\n对于所有数据，满足 $3 \\leq n \\leq 3000$，$s$ 为由 `B` 和 `R` 构成的字符串。\n\n| 子任务编号 | 分值 | $n$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $10$ | $\\le 17$ |\n|  $2$| $10$  |  $\\le 30$ |\n| $3$ | $10$  |  $\\le 50$ |\n|  $4$|  $10$ |  $\\le 200$ |\n| $5$ |  $45$ |  $\\le 500$ |\n| $6$ | $15$  |  $\\le 3000$ |\n", "locale": "zh-CN"}}}
{"pid": "P11427", "type": "P", "difficulty": 6, "samples": [["8 4\n3 4 1 2", "4\n4 6 7 8"], ["9495432940070937 8\n3000233914822387 2006732107970615 1954019279515031 3066501572807561 2123728203400817 2370011082783740 1927699386041907 2398543984293318\n", "5\n5006966022793002 6934665408834909 6960985302308033 8888684688349940 9084713505708850\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "2024", "O2优化", "剪枝", "差分约束", "CTT（清华集训/北大集训）", "状压 DP"], "title": "[清华集训 2024] 绝顶之战", "background": "", "description": "有一个长度为 $m$ 的一维空间，还有 $n$ 个物品，第 $i$ 个物品的长度为 $a_i$。现在按照编号从小到大的顺序依次将物品放入空间中，对于第 $i$ 个物品：\n\n- 如果当前空间中存在一段连续的长度至少为 $a_i$ 的空余，则你**必须**将第 $i$ 个物品放入一段连续的长度为 $a_i$ 的空余空间中。\n- 否则，第 $i$ 个物品无法被放入，跳过它。\n\n你需要输出：按照编号从小到大的顺序考虑完所有物品后，所有可能的**空间占用长度**，它的定义是所有被放入空间的物品的长度之和。\n", "inputFormat": "\n输入的第一行两个整数 $m,n$，分别表示空间长度和物品个数。\n\n第二行 $n$ 个整数 $a_1,\\cdots,a_n$，依次表示每个物品的长度。\n", "outputFormat": "输出两行，第一行一个整数 $S$，表示可能的空间占用长度的数量。\n\n第二行 $S$ 个整数 $b_1,\\ldots,b_S$，**从小到大**输出所有可能的空间占用长度。\n\n注意，你需要保证 $b_1,\\ldots,b_S$ 不重不漏。", "hint": "### 【样例 1 解释】\n\n下图分别展示了空间占用长度为 $4,6,7,8$ 的一种可能方式：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jbfoe06m.png)\n\n### 数据范围\n\n对于所有测试数据，$1\\leq m,a_i\\leq 10^{16}$，$\\ 1\\leq n\\leq 14$。\n\n| 子任务编号 | $n=$ | $m,a_i\\le$ | 分数 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $5$ | $10$  | $15$ |\n| $2$ | $2$ | $10^{16}$  | $5$ |\n| $3$ | $3$ | $10^{16}$  | $5$ |\n| $4$ | $5$ | $10^{16}$  | $5$ |\n| $5$ | $7$ | $10^{16}$  |  $5$|\n| $6$ | $9$ | $10^{16}$  | $5$ |\n| $7$ | $11$ | $10^{16}$ | $10$ |\n| $8$ | $12$ | $10^{16}$ | $10$ |\n| $9$ | $13$ | $10^{16}$ | $10$ |\n| $10$ | $14$ | $10^{16}$ | $30$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2024] 绝顶之战", "background": "", "description": "有一个长度为 $m$ 的一维空间，还有 $n$ 个物品，第 $i$ 个物品的长度为 $a_i$。现在按照编号从小到大的顺序依次将物品放入空间中，对于第 $i$ 个物品：\n\n- 如果当前空间中存在一段连续的长度至少为 $a_i$ 的空余，则你**必须**将第 $i$ 个物品放入一段连续的长度为 $a_i$ 的空余空间中。\n- 否则，第 $i$ 个物品无法被放入，跳过它。\n\n你需要输出：按照编号从小到大的顺序考虑完所有物品后，所有可能的**空间占用长度**，它的定义是所有被放入空间的物品的长度之和。\n", "inputFormat": "\n输入的第一行两个整数 $m,n$，分别表示空间长度和物品个数。\n\n第二行 $n$ 个整数 $a_1,\\cdots,a_n$，依次表示每个物品的长度。\n", "outputFormat": "输出两行，第一行一个整数 $S$，表示可能的空间占用长度的数量。\n\n第二行 $S$ 个整数 $b_1,\\ldots,b_S$，**从小到大**输出所有可能的空间占用长度。\n\n注意，你需要保证 $b_1,\\ldots,b_S$ 不重不漏。", "hint": "### 【样例 1 解释】\n\n下图分别展示了空间占用长度为 $4,6,7,8$ 的一种可能方式：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jbfoe06m.png)\n\n### 数据范围\n\n对于所有测试数据，$1\\leq m,a_i\\leq 10^{16}$，$\\ 1\\leq n\\leq 14$。\n\n| 子任务编号 | $n=$ | $m,a_i\\le$ | 分数 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $5$ | $10$  | $15$ |\n| $2$ | $2$ | $10^{16}$  | $5$ |\n| $3$ | $3$ | $10^{16}$  | $5$ |\n| $4$ | $5$ | $10^{16}$  | $5$ |\n| $5$ | $7$ | $10^{16}$  |  $5$|\n| $6$ | $9$ | $10^{16}$  | $5$ |\n| $7$ | $11$ | $10^{16}$ | $10$ |\n| $8$ | $12$ | $10^{16}$ | $10$ |\n| $9$ | $13$ | $10^{16}$ | $10$ |\n| $10$ | $14$ | $10^{16}$ | $30$ |\n", "locale": "zh-CN"}}}
