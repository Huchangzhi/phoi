{"pid": "P7254", "type": "P", "difficulty": 0, "samples": [["5 4 2\n1111\n2101\n2000\n0100\n0000\n7\n1 5 4 5 3 2 1", "1\n1 2 4 5 3 2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2012", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2012] 旋律 (Day2)", "background": "", "description": "有一种不为人知的乐器，这种乐器有 $S$ 个孔，可以通过十种不同的方式 $(0$ ～ $9)$ 覆盖这些孔来弹奏出 $N$ 个音符。你不能采取除了这 $N$ 个音符以外的孔的覆盖方式。\n\n现在你要弹奏一首乐曲，但是由于这种乐器每两个音符之间不能有超过 $G$ 个孔的覆盖方式不同，所以你可能不得不弹错一些音符。你希望最小化你弹错音符的数目。", "inputFormat": "第一行三个整数 $N, S, G\\ (0 \\le G < S \\le 100)$，含义如上文所述。\n\n接下来 $N$ 行，每行一个长度为 $S$ 的字符串（只包含数字），表示弹奏这个音符时孔的覆盖方式。\n\n接下来一行一个整数 $L$，表示乐曲中包含的音符的数目。\n\n最后一行 $L$ 个整数，表示乐曲中音符的编号。", "outputFormat": "第一行一个整数，表示你能取到的弹错音符数目的最小值。  \n\n接下来一行 $L$ 个整数，表示你的任意一种构造方案。", "hint": "**【样例解释】**\n\n音符 $1$ 和音符 $5$ 在四个孔上的弹奏方式都不同，所以你不能在弹奏完音符 $1$ 后弹奏音符 $5$。\n\n**【数据范围】**\n\n- 对于 $40\\%$ 的数据，$L \\leq 100$；\n- 对于 $65\\%$ 的数据，$L \\leq 5000$；\n- 对于 $100\\%$ 的数据，$1 \\leq N \\leq 100$，$1 \\le L \\le 10 ^ 5$。\n\n**【说明】**\n\n译自 [BalticOI 2012 Day2 T2. Melody](http://www.boi2012.lv/data/day2/eng/melody.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2012] 旋律 (Day2)", "background": "", "description": "有一种不为人知的乐器，这种乐器有 $S$ 个孔，可以通过十种不同的方式 $(0$ ～ $9)$ 覆盖这些孔来弹奏出 $N$ 个音符。你不能采取除了这 $N$ 个音符以外的孔的覆盖方式。\n\n现在你要弹奏一首乐曲，但是由于这种乐器每两个音符之间不能有超过 $G$ 个孔的覆盖方式不同，所以你可能不得不弹错一些音符。你希望最小化你弹错音符的数目。", "inputFormat": "第一行三个整数 $N, S, G\\ (0 \\le G < S \\le 100)$，含义如上文所述。\n\n接下来 $N$ 行，每行一个长度为 $S$ 的字符串（只包含数字），表示弹奏这个音符时孔的覆盖方式。\n\n接下来一行一个整数 $L$，表示乐曲中包含的音符的数目。\n\n最后一行 $L$ 个整数，表示乐曲中音符的编号。", "outputFormat": "第一行一个整数，表示你能取到的弹错音符数目的最小值。  \n\n接下来一行 $L$ 个整数，表示你的任意一种构造方案。", "hint": "**【样例解释】**\n\n音符 $1$ 和音符 $5$ 在四个孔上的弹奏方式都不同，所以你不能在弹奏完音符 $1$ 后弹奏音符 $5$。\n\n**【数据范围】**\n\n- 对于 $40\\%$ 的数据，$L \\leq 100$；\n- 对于 $65\\%$ 的数据，$L \\leq 5000$；\n- 对于 $100\\%$ 的数据，$1 \\leq N \\leq 100$，$1 \\le L \\le 10 ^ 5$。\n\n**【说明】**\n\n译自 [BalticOI 2012 Day2 T2. Melody](http://www.boi2012.lv/data/day2/eng/melody.pdf)。", "locale": "zh-CN"}}}
{"pid": "P7255", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["2012", "提交答案", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2012] 俄罗斯方块 (Day2)", "background": "", "description": "这是一个和俄罗斯方块较为类似的游戏。游戏中一共有一下几个碎片：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w1ggafuv.png)\n\n游戏有一个 $9 \\times 9$ 的区域。对于每个下落的碎片，你可以指定这个碎片最左边的方块（即图片中做标记的方块）下落的列。如果碎片没有完全落在区域内，游戏结束。此时如果有被方块完整填满的行，这一行的所有方块将被清除，上面的方块则相应向下移动。\n\n游戏一共有 $N$ 个碎片，你需要使尽量多的碎片成功下落。\n\n注意本游戏中碎片不能旋转。", "inputFormat": "输入文件请点击附件下载。\n\n第一行一个整数 $N$，代表游戏共有 $N$ 个碎片。\n\n接下来 $N$ 行每行一个整数，表示下落碎片的编号。\n\n数据保证有解。", "outputFormat": "对于输入文件请提交相应的输出文件。\n\n输出文件最多包含 $N$ 行，每行一个整数，表示该下落的碎片最左边方块落在的列的编号。", "hint": "**【提示】**\n\n每个测试点 $20$ 分。\n\n如果你能使 $A$ 个碎片正常下落，那你能够获得该测试点 $\\dfrac{A}{N}$ 的分数。\n\n**【说明】**\n\n译自 [BalticOI 2012 Day2 T3. Tiny](http://www.boi2012.lv/data/day2/eng/tiny.pdf)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2012] 俄罗斯方块 (Day2)", "background": "", "description": "这是一个和俄罗斯方块较为类似的游戏。游戏中一共有一下几个碎片：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w1ggafuv.png)\n\n游戏有一个 $9 \\times 9$ 的区域。对于每个下落的碎片，你可以指定这个碎片最左边的方块（即图片中做标记的方块）下落的列。如果碎片没有完全落在区域内，游戏结束。此时如果有被方块完整填满的行，这一行的所有方块将被清除，上面的方块则相应向下移动。\n\n游戏一共有 $N$ 个碎片，你需要使尽量多的碎片成功下落。\n\n注意本游戏中碎片不能旋转。", "inputFormat": "输入文件请点击附件下载。\n\n第一行一个整数 $N$，代表游戏共有 $N$ 个碎片。\n\n接下来 $N$ 行每行一个整数，表示下落碎片的编号。\n\n数据保证有解。", "outputFormat": "对于输入文件请提交相应的输出文件。\n\n输出文件最多包含 $N$ 行，每行一个整数，表示该下落的碎片最左边方块落在的列的编号。", "hint": "**【提示】**\n\n每个测试点 $20$ 分。\n\n如果你能使 $A$ 个碎片正常下落，那你能够获得该测试点 $\\dfrac{A}{N}$ 的分数。\n\n**【说明】**\n\n译自 [BalticOI 2012 Day2 T3. Tiny](http://www.boi2012.lv/data/day2/eng/tiny.pdf)", "locale": "zh-CN"}}}
{"pid": "P7257", "type": "P", "difficulty": 1, "samples": [["734 893\n", "437"], ["221 231\n", "132"], ["839 237\n", "938"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "数学", "2009", "COCI（克罗地亚）"], "title": "[COCI 2009/2010 #3] FILIP", "background": "", "description": "给你两个十进制正整数 $a, b$，输出将这两个数翻转后的较大数。\n\n**「翻转」在本题中的定义详见「说明 / 提示」部分。**\n\n\n", "inputFormat": "第一行，两个十进制正整数 $a, b$。", "outputFormat": "第一行，$a$ 和 $b$ 翻转后的较大数。", "hint": "#### 「翻转」在本题中的定义\n\n设原数有 $f$ 位，最高位为 $a_1$，第二位为 $a_2$，……，第 $f$ 位为 $a_f$。\n\n那么该数的翻转同样有 $f$ 位，最高位为为 $a_f$，第二位为 $a_{f - 1}$，……，第 $f$ 位为 $a_1$。\n\n#### 数据规模及约定\n\n对于 $100\\%$ 的数据，$100 \\le a, b \\le 999$，$a, b$ 不含 $0$ 或不为 $0$。\n\n#### 说明\n翻译自 [COCI 2009-2010 #3 T1 FILIP](https://hsin.hr/coci/archive/2009_2010/contest3_tasks.pdf)，满分 30，每个测试点 3 分，共 10 个测试点。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2009/2010 #3] FILIP", "background": "", "description": "给你两个十进制正整数 $a, b$，输出将这两个数翻转后的较大数。\n\n**「翻转」在本题中的定义详见「说明 / 提示」部分。**\n\n\n", "inputFormat": "第一行，两个十进制正整数 $a, b$。", "outputFormat": "第一行，$a$ 和 $b$ 翻转后的较大数。", "hint": "#### 「翻转」在本题中的定义\n\n设原数有 $f$ 位，最高位为 $a_1$，第二位为 $a_2$，……，第 $f$ 位为 $a_f$。\n\n那么该数的翻转同样有 $f$ 位，最高位为为 $a_f$，第二位为 $a_{f - 1}$，……，第 $f$ 位为 $a_1$。\n\n#### 数据规模及约定\n\n对于 $100\\%$ 的数据，$100 \\le a, b \\le 999$，$a, b$ 不含 $0$ 或不为 $0$。\n\n#### 说明\n翻译自 [COCI 2009-2010 #3 T1 FILIP](https://hsin.hr/coci/archive/2009_2010/contest3_tasks.pdf)，满分 30，每个测试点 3 分，共 10 个测试点。\n\n", "locale": "zh-CN"}}}
{"pid": "P7258", "type": "P", "difficulty": 2, "samples": [["184 1\n", "180"], ["123450995 1\n", "123451000"], ["182 2\n", "200"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "2009", "COCI（克罗地亚）"], "title": "[COCI 2009/2010 #3] SLATKISI", "background": "可爱的 Mirko 在糖果店买了很多糖果。", "description": "他不能总是支付准确的金额，所以店主和他达成了协议。\n\n他告诉店主他有的最小的钞票，店主就把他的金额四舍五入到他能支付的最接近的数字。\n\n例如，如果 Mirko 最小的钞票是 $100$ 元，他想买 $150$ 元的糖果，店主就把他的金额四舍五入到 $200$ 元。如果他想买 $149$ 元的糖果，店主就会把他的金额四舍五入到 $100$ 元。\n\n最近，Mirko 怀疑店主想骗他。请你判断店主有没有骗他。\n\nMirko 的妈妈只会给他 $1, 10, 100, 10^3, 10^4, 10^5, \\cdots, 10^9$ 元钞票，他有无限张这些钞票。", "inputFormat": "第一行，两个整数，$c, k$，表示 Mirko 要买的糖果的价格和 Mirko 最小的钞票上的零数，这里的「零数」指的是一个数 $0$ 的个数，在本题中，即 $10^t$ 中的 $t$。", "outputFormat": "第一行，一个整数，$c$ 四舍五入到最接近的 Mirko 可以的支付金额。 ", "hint": "#### 数据规模及约定\n\n对于 $100\\%$ 的数据，$1 \\le c \\le 10^9$，$0 \\le k \\le 9$。\n\n#### 说明\n翻译自 [COCI 2009-2010 #3 T2 SLATKISI](https://hsin.hr/coci/archive/2009_2010/contest3_tasks.pdf)，满分 50，每个测试点 5 分，共 10 个测试点。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2009/2010 #3] SLATKISI", "background": "可爱的 Mirko 在糖果店买了很多糖果。", "description": "他不能总是支付准确的金额，所以店主和他达成了协议。\n\n他告诉店主他有的最小的钞票，店主就把他的金额四舍五入到他能支付的最接近的数字。\n\n例如，如果 Mirko 最小的钞票是 $100$ 元，他想买 $150$ 元的糖果，店主就把他的金额四舍五入到 $200$ 元。如果他想买 $149$ 元的糖果，店主就会把他的金额四舍五入到 $100$ 元。\n\n最近，Mirko 怀疑店主想骗他。请你判断店主有没有骗他。\n\nMirko 的妈妈只会给他 $1, 10, 100, 10^3, 10^4, 10^5, \\cdots, 10^9$ 元钞票，他有无限张这些钞票。", "inputFormat": "第一行，两个整数，$c, k$，表示 Mirko 要买的糖果的价格和 Mirko 最小的钞票上的零数，这里的「零数」指的是一个数 $0$ 的个数，在本题中，即 $10^t$ 中的 $t$。", "outputFormat": "第一行，一个整数，$c$ 四舍五入到最接近的 Mirko 可以的支付金额。 ", "hint": "#### 数据规模及约定\n\n对于 $100\\%$ 的数据，$1 \\le c \\le 10^9$，$0 \\le k \\le 9$。\n\n#### 说明\n翻译自 [COCI 2009-2010 #3 T2 SLATKISI](https://hsin.hr/coci/archive/2009_2010/contest3_tasks.pdf)，满分 50，每个测试点 5 分，共 10 个测试点。", "locale": "zh-CN"}}}
{"pid": "P7259", "type": "P", "difficulty": 2, "samples": [["5 2\n2 1 2 1 2\n", "2 2 2 1 1\n"], ["9 3\n1 3 3 3 2 2 2 1 1\n", "1 1 1 3 3 3 2 2 2\n"], ["9 77\n11 33 11 77 54 11 25 25 33\n", "11 11 11 33 33 25 25 77 54"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2009", "排序", "COCI（克罗地亚）"], "title": "[COCI 2009/2010 #3] SORT", "background": "", "description": "Mirko 是一个伟大的密码破解者。他知道世界上任何密码都可以通过频率分析来破解。\n\n但他完全弄错了什么是频率分析。\n\n他截获了一个敌人的信息。这个信息由 $N$ 个小于等于 $C$ 的数字组成。 \n\nMirko 相信频率分析包括对这个序列进行排序，使频率较高的数字出现在频率较低的数字之前。\n\n给定任何两个数字 $x$ 和 $y$，如果 $x$ 在原始序列中出现的次数大于 $y$ 出现的次数，则 $x$ 出现在 $y$ 之前。如果出现的次数相等，则输入中谁的值出现的早，谁就应该在排序后的序列中出现靠前。\n\n请帮助 Mirko 制作一个「频率排序器」。\n", "inputFormat": "第一行，两个正整数 $N, C$，含义见题目描述。\n\n第二行，$N$ 个正整数 $a_i$，表示消息。", "outputFormat": "第一行，$N$ 个正整数，表示排序后的序列。\n", "hint": "#### 数据规模及约定\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^3$，$1 \\le C \\le 10^9$，$1\\le a_i \\le C$。\n\n#### 说明\n翻译自 [COCI 2009-2010 #3 T3 SORT](https://hsin.hr/coci/archive/2009_2010/contest3_tasks.pdf)，满分 70，每个测试点 7 分，共 10 个测试点。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2009/2010 #3] SORT", "background": "", "description": "Mirko 是一个伟大的密码破解者。他知道世界上任何密码都可以通过频率分析来破解。\n\n但他完全弄错了什么是频率分析。\n\n他截获了一个敌人的信息。这个信息由 $N$ 个小于等于 $C$ 的数字组成。 \n\nMirko 相信频率分析包括对这个序列进行排序，使频率较高的数字出现在频率较低的数字之前。\n\n给定任何两个数字 $x$ 和 $y$，如果 $x$ 在原始序列中出现的次数大于 $y$ 出现的次数，则 $x$ 出现在 $y$ 之前。如果出现的次数相等，则输入中谁的值出现的早，谁就应该在排序后的序列中出现靠前。\n\n请帮助 Mirko 制作一个「频率排序器」。\n", "inputFormat": "第一行，两个正整数 $N, C$，含义见题目描述。\n\n第二行，$N$ 个正整数 $a_i$，表示消息。", "outputFormat": "第一行，$N$ 个正整数，表示排序后的序列。\n", "hint": "#### 数据规模及约定\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^3$，$1 \\le C \\le 10^9$，$1\\le a_i \\le C$。\n\n#### 说明\n翻译自 [COCI 2009-2010 #3 T3 SORT](https://hsin.hr/coci/archive/2009_2010/contest3_tasks.pdf)，满分 70，每个测试点 7 分，共 10 个测试点。", "locale": "zh-CN"}}}
{"pid": "P7260", "type": "P", "difficulty": 3, "samples": [["3 4\n3 1\n2 2\n1 1\n", "2"], ["2 3\n1 23\n2 17\n", "23"], ["3 9\n7 2\n8 3\n3 4\n", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2009", "排序", "COCI（克罗地亚）"], "title": "[COCI 2009/2010 #3] RAZGOVOR", "background": "", "description": "可爱村只有一条长长的街道，从东向西延伸，有 $m$ 户人家。每栋房子都有一个单独的房号，从 $1$ 开始到 $m$ 结束。\n\n最近的暴风雪摧毁了大部分电话线，所以市长出资建造了一个新的电话线。Mirko 对这个新的电话网络的普及程度很感兴趣，所以他在一些点上安装了特殊的探测器。\n\n探测器可以检测到两栋房子之间的任何电话，一栋房子在探测器的 **东边**，一栋房子在探测器的 **西边**。\n\n在第一个月结束时，Mirko 撤掉了所有的探测器，现在想知道在这一个月里，可能打过的电话中，**最小** 的电话数量是多少。\n\n\n", "inputFormat": "第一行，两个正整数，$n, m$，分别表示探测器和房屋的数量。\n\n接下来，$n$ 行，每行两个正整数 $P_i$，和 $C_i$，编号为 $i$ 的探测器检测到的位置和电话总数。 我们说，如果且仅当一个探测器在编号为 $P_i$ 和 $P_i+1$ 的房屋之间时，他就在位置 $P_i$ 上。\n\n**同一位置上最多有一个探测器。**", "outputFormat": "输出一个正整数，表示最小的通话次数。\n", "hint": "#### 数据规模及约定\n\n- 对于 $50\\%$ 的数据，$1 \\le n \\le 10^3$，$1 \\le C_i \\le 10^3$，$n < m \\le 10^9$，$1 \\le P_i < M$。\n- 对于 $100\\%$ 的数据，$1 \\le n \\le 10^5$，$1 \\le C_i \\le 10^9$，$n < m \\le 10^9$，$1 \\le P_i < M$。\n\n#### 说明\n翻译自 [COCI 2009-2010 #3 T4 RAZGOVOR](https://hsin.hr/coci/archive/2009_2010/contest3_tasks.pdf)，满分 100，每个测试点 10 分，共 10 个测试点。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2009/2010 #3] RAZGOVOR", "background": "", "description": "可爱村只有一条长长的街道，从东向西延伸，有 $m$ 户人家。每栋房子都有一个单独的房号，从 $1$ 开始到 $m$ 结束。\n\n最近的暴风雪摧毁了大部分电话线，所以市长出资建造了一个新的电话线。Mirko 对这个新的电话网络的普及程度很感兴趣，所以他在一些点上安装了特殊的探测器。\n\n探测器可以检测到两栋房子之间的任何电话，一栋房子在探测器的 **东边**，一栋房子在探测器的 **西边**。\n\n在第一个月结束时，Mirko 撤掉了所有的探测器，现在想知道在这一个月里，可能打过的电话中，**最小** 的电话数量是多少。\n\n\n", "inputFormat": "第一行，两个正整数，$n, m$，分别表示探测器和房屋的数量。\n\n接下来，$n$ 行，每行两个正整数 $P_i$，和 $C_i$，编号为 $i$ 的探测器检测到的位置和电话总数。 我们说，如果且仅当一个探测器在编号为 $P_i$ 和 $P_i+1$ 的房屋之间时，他就在位置 $P_i$ 上。\n\n**同一位置上最多有一个探测器。**", "outputFormat": "输出一个正整数，表示最小的通话次数。\n", "hint": "#### 数据规模及约定\n\n- 对于 $50\\%$ 的数据，$1 \\le n \\le 10^3$，$1 \\le C_i \\le 10^3$，$n < m \\le 10^9$，$1 \\le P_i < M$。\n- 对于 $100\\%$ 的数据，$1 \\le n \\le 10^5$，$1 \\le C_i \\le 10^9$，$n < m \\le 10^9$，$1 \\le P_i < M$。\n\n#### 说明\n翻译自 [COCI 2009-2010 #3 T4 RAZGOVOR](https://hsin.hr/coci/archive/2009_2010/contest3_tasks.pdf)，满分 100，每个测试点 10 分，共 10 个测试点。", "locale": "zh-CN"}}}
{"pid": "P7261", "type": "P", "difficulty": 5, "samples": [["10 3\n1 2 1 2 1 2 3 2 3 3\n8\n1 2\n1 3\n1 4\n1 5\n2 5\n2 6\n6 9\n7 10\n", "no\nyes 1\nno\nyes 1\nno\nyes 2\nno\nyes 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2009", "莫队", "线段树", "平衡树", "可持久化线段树", "COCI（克罗地亚）"], "title": "[COCI 2009/2010 #3] PATULJCI", "background": "", "description": "白雪公主和 $n$ 个小矮人在森林里，当 $n$ 个小矮人在挖矿时，白雪公主在玩电脑。\n\n每天早上，小矮人排成长长的队伍，去矿山挖矿。白雪公主在他们身边跑来跑去，拍下照片上传到她最喜欢的 App 上。\n\n小矮人进入矿区后，白雪公主回到自己的房子里，翻看图片，挑选漂亮的图片。每个小矮人都有一顶彩色的帽子，有 $c$ 种不同的颜色。如果一张照片上有一半以上的帽子是同一种颜色，那就是漂亮的。换句话说，如果图片上有 $k$ 个小矮人，如果大于 $\\dfrac{k}{2}$ 个小矮人有相同颜色的帽子，那就是漂亮的图片。\n\n请求出第 $m$ 张图是否漂亮，如果漂亮，以什么颜色为主。", "inputFormat": "第一行，两个正整数 $n, c$，分别表示小矮人的数量和颜色的数量。\n\n第二行，$1$ 到 $c$ 之间的 $n$ 个整数，表示小矮人帽子的颜色，按照当天早上排队的方式排序。\n\n第三行，一个正整数 $m$，表示图片数量。\n\n接下来，$m$ 行，每行两个正整数 $a$ 和 $b$。每一行都描述了一幅画，上面有从 $a$ 开始一直到 $b$ 的所有小矮人。\n\n\n", "outputFormat": "$m$ 行。对于每张图片，如果白雪公主认为图片不漂亮，则输出 `no`，如果认为漂亮，则输出 `yes` 和 $x$，$x$ 是图片上的主要颜色。", "hint": "#### 数据规模及约定\n\n- 对于 $30\\%$ 的数据，$1 \\le m < 10$，$3 \\le n \\le 3 \\cdot 10^5$，$1 \\le c \\le 10^4$，$1 \\le a \\le b \\le n$。\n- 对于另外 $30\\%$ 的数据，$1 \\le m \\le 10^4$，$3 \\le n \\le 3 \\cdot 10^5$，$1 \\le c < 10$，$1 \\le a \\le b \\le n$。\n- 对于 $100\\%$ 的数据，$1 \\le m \\le 10^4$，$3 \\le n \\le 3 \\cdot 10^5$，$1 \\le c \\le 10^4$，$1 \\le a \\le b \\le n$。\n\n#### 说明\n翻译自 [COCI 2009-2010 #3 T5 PATULJCI](https://hsin.hr/coci/archive/2009_2010/contest3_tasks.pdf)，满分 120，每个测试点 12 分，共 10 个测试点。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2009/2010 #3] PATULJCI", "background": "", "description": "白雪公主和 $n$ 个小矮人在森林里，当 $n$ 个小矮人在挖矿时，白雪公主在玩电脑。\n\n每天早上，小矮人排成长长的队伍，去矿山挖矿。白雪公主在他们身边跑来跑去，拍下照片上传到她最喜欢的 App 上。\n\n小矮人进入矿区后，白雪公主回到自己的房子里，翻看图片，挑选漂亮的图片。每个小矮人都有一顶彩色的帽子，有 $c$ 种不同的颜色。如果一张照片上有一半以上的帽子是同一种颜色，那就是漂亮的。换句话说，如果图片上有 $k$ 个小矮人，如果大于 $\\dfrac{k}{2}$ 个小矮人有相同颜色的帽子，那就是漂亮的图片。\n\n请求出第 $m$ 张图是否漂亮，如果漂亮，以什么颜色为主。", "inputFormat": "第一行，两个正整数 $n, c$，分别表示小矮人的数量和颜色的数量。\n\n第二行，$1$ 到 $c$ 之间的 $n$ 个整数，表示小矮人帽子的颜色，按照当天早上排队的方式排序。\n\n第三行，一个正整数 $m$，表示图片数量。\n\n接下来，$m$ 行，每行两个正整数 $a$ 和 $b$。每一行都描述了一幅画，上面有从 $a$ 开始一直到 $b$ 的所有小矮人。\n\n\n", "outputFormat": "$m$ 行。对于每张图片，如果白雪公主认为图片不漂亮，则输出 `no`，如果认为漂亮，则输出 `yes` 和 $x$，$x$ 是图片上的主要颜色。", "hint": "#### 数据规模及约定\n\n- 对于 $30\\%$ 的数据，$1 \\le m < 10$，$3 \\le n \\le 3 \\cdot 10^5$，$1 \\le c \\le 10^4$，$1 \\le a \\le b \\le n$。\n- 对于另外 $30\\%$ 的数据，$1 \\le m \\le 10^4$，$3 \\le n \\le 3 \\cdot 10^5$，$1 \\le c < 10$，$1 \\le a \\le b \\le n$。\n- 对于 $100\\%$ 的数据，$1 \\le m \\le 10^4$，$3 \\le n \\le 3 \\cdot 10^5$，$1 \\le c \\le 10^4$，$1 \\le a \\le b \\le n$。\n\n#### 说明\n翻译自 [COCI 2009-2010 #3 T5 PATULJCI](https://hsin.hr/coci/archive/2009_2010/contest3_tasks.pdf)，满分 120，每个测试点 12 分，共 10 个测试点。", "locale": "zh-CN"}}}
{"pid": "P7262", "type": "P", "difficulty": 2, "samples": [["3 3 v\n.o.\n...\nxxx", "GG"], ["3 3 >\n...\no.x\n...", "GG"], ["3 3 ^\n.o.\n...\nxxx", "OK"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "2021"], "title": "Get Your Wish", "background": "![Get Your Wish](https://mivik.gitee.io/image/nurture/get_your_wish.png)\n\n> So, tell me how it felt when you walked on water\n>\n> Did you get your wish?", "description": "Porter 在浅水上完成了他的 MV，但他很快发现了事情不对：他的话筒进水了。\n\nPorter 的话筒内部的关键电子元件可以被看作一个 $n\\times m$ 的二维平面。我们用一张 $n\\times m$ 的字符画来表示 Porter 的话筒内部状况，其中有三种不同的字符：\n\n- `.`：表示空位\n\n- `x`：表示关键电子原件\n\n- `o`：表示水滴\n\n水滴会沿着重力方向一直流动，直到流出边界或者流到电子原件上。当水滴流到任意一个电子原件上时，Porter 的话筒就会坏掉。Porter 慌忙把话筒转过来，改变了话筒内部的重力方向。重力方向用四种字符之一表示：`^v<>`，分别对应上下左右。\n\nPorter 想知道，在这种重力方向下，他的话筒过一会儿会不会 GG。", "inputFormat": "第一行两个正整数和一个字符，分别代表 $n$、$m$ 和重力方向。\n\n接下来 $n$ 行，每行 $m$ 个字符，分别对应代表该点状态。", "outputFormat": "输出一行一个字符串。`GG` 代表 Porter 的话筒会坏掉，`OK` 代表不会。", "hint": "\n### 样例解释\n\n样例一：第一行第二列的水滴向下流到了最后一行第二列的电子原件上，因此话筒坏掉了。\n\n样例二：第二行第一列的水滴向右流到了第二行最后一列的电子原件上，因此话筒坏掉了。\n\n样例三：第一行第二列的水滴直接向上流出话筒，因此 Porter 的话筒不会坏掉。\n\n### 数据范围\n\n对于全部数据，保证 $1\\le n,m\\le 100$，且输入数据合法。\n\nSubtask 1 (10 pts)：话筒中没有 `x`（即电子原件）。\n\nSubtask 2 (10 pts)：话筒中没有 `o`（即水滴）。\n\nSubtask 3 (30 pts)：保证重力方向总是 `v`（向下）。\n\nSubtask 4 (50 pts)：无特殊限制。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Get Your Wish", "background": "![Get Your Wish](https://mivik.gitee.io/image/nurture/get_your_wish.png)\n\n> So, tell me how it felt when you walked on water\n>\n> Did you get your wish?", "description": "Porter 在浅水上完成了他的 MV，但他很快发现了事情不对：他的话筒进水了。\n\nPorter 的话筒内部的关键电子元件可以被看作一个 $n\\times m$ 的二维平面。我们用一张 $n\\times m$ 的字符画来表示 Porter 的话筒内部状况，其中有三种不同的字符：\n\n- `.`：表示空位\n\n- `x`：表示关键电子原件\n\n- `o`：表示水滴\n\n水滴会沿着重力方向一直流动，直到流出边界或者流到电子原件上。当水滴流到任意一个电子原件上时，Porter 的话筒就会坏掉。Porter 慌忙把话筒转过来，改变了话筒内部的重力方向。重力方向用四种字符之一表示：`^v<>`，分别对应上下左右。\n\nPorter 想知道，在这种重力方向下，他的话筒过一会儿会不会 GG。", "inputFormat": "第一行两个正整数和一个字符，分别代表 $n$、$m$ 和重力方向。\n\n接下来 $n$ 行，每行 $m$ 个字符，分别对应代表该点状态。", "outputFormat": "输出一行一个字符串。`GG` 代表 Porter 的话筒会坏掉，`OK` 代表不会。", "hint": "\n### 样例解释\n\n样例一：第一行第二列的水滴向下流到了最后一行第二列的电子原件上，因此话筒坏掉了。\n\n样例二：第二行第一列的水滴向右流到了第二行最后一列的电子原件上，因此话筒坏掉了。\n\n样例三：第一行第二列的水滴直接向上流出话筒，因此 Porter 的话筒不会坏掉。\n\n### 数据范围\n\n对于全部数据，保证 $1\\le n,m\\le 100$，且输入数据合法。\n\nSubtask 1 (10 pts)：话筒中没有 `x`（即电子原件）。\n\nSubtask 2 (10 pts)：话筒中没有 `o`（即水滴）。\n\nSubtask 3 (30 pts)：保证重力方向总是 `v`（向下）。\n\nSubtask 4 (50 pts)：无特殊限制。\n", "locale": "zh-CN"}}}
{"pid": "P7263", "type": "P", "difficulty": 4, "samples": [["1\n()", "1"], ["3\n()(())", "598946612"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["2021", "组合数学"], "title": "Something Comforting", "background": "![Something Comforting](https://mivik.gitee.io/image/nurture/something_comforting.png)\n\n> Cause getting made you want more\n>\n> And hoping made you hurt more\n>\n> Someone tell me\n>\n> Something comforting", "description": "Porter Robinson 花了五年的时间制作了 Something Comforting 这首歌，Mivik 花了五天时间造出了一道和括号序列相关的题。但 Mivik 并不开心，因为他发现他不会造数据了！\n\nMivik 需要随机生成一个 **合法** 的括号序列，于是 Mivik 想了一会，写出了下面的算法：\n\n```cpp\n#include <algorithm>\n#include <string>\n\nstd::string generate(int n) { // 生成一个长度为 n * 2 的括号序列\n\tconst int len = n * 2;\n\tbool arr[len]; // 0 代表左括号，1 代表右括号\n\tfor (int i = 0; i < n; ++i) arr[i] = 0;\n\tfor (int i = n; i < len; ++i) arr[i] = 1;\n\tstd::random_shuffle(arr, arr + len); // 随机打乱这个数组\n\tfor (int i = 0, j, sum = 0; i < len; ) {\n\t\tsum += arr[i]? -1: 1;\n\t\tif (sum < 0) { // 出现了不合法的位置\n\t\t\tfor (j = i + 1; j < len; ++j) {\n\t\t\t\tsum += arr[j]? -1: 1;\n\t\t\t\tif (sum == 0) break;\n\t\t\t}\n\t\t\t// 现在 i 是第一个不合法的位置，j 是 i 后面第一个合法的位置\n\t\t\t// ( ( ) ) ) ) ( ( ( ) ( )\n\t\t\t//         i     j\n\t\t\tfor (int k = i; k <= j; ++k)\n\t\t\t\tarr[k] ^= 1; // 把这段区间全部反转\n\t\t\ti = j + 1;\n\t\t} else ++i;\n\t}\n\tstd::string ret;\n\tfor (int i = 0; i < len; ++i)\n\t\tret += arr[i]? ')': '(';\n\treturn ret;\n}\n```\n\nP.S. 为了给其它语言用户带来做题体验，[这里](https://www.luogu.com.cn/paste/wof8zjn8) 提供了多种语言对该算法的描述。\n\nMivik 十分开心，因为这个算法总能生成合法的括号序列。但不一会儿他就发现这个算法生成的括号序列并不均匀，也就是说，当 $n$ 固定时，所有合法的括号序列出现的概率并不均等。例如，Mivik 发现当 $n=3$ 时，`()()()` 被生成的概率要远大于 `((()))`。\n\n现在 Mivik 给了你一个 $n$ 和一个长度为 $2n$ 的 **合法** 括号序列，假设 `std::random_shuffle` （对于其它语言来说，`shuffle`）能够均匀随机地打乱一个数组，他想问问你这个括号序列通过上文的算法被生成的概率是多少。由于 Mivik 不喜欢小数，你需要输出这个概率对 $998244353$ 取模的结果。如果你不知道如何将一个有理数对质数取模，可以参考 [有理数取模](https://www.luogu.com.cn/problem/P2613)。", "inputFormat": "第一行一个整数 $n$，意义同题面。\n\n接下来输入一个长度为 $2n$ 的合法括号序列，意义同题面。", "outputFormat": "输出一行一个整数，代表这个概率对 $998244353$ 取模的结果。", "hint": "\n### 样例解释\n\n样例一：$n$ 为 1 时，无论怎样都只可能会生成 `()` 这一种合法的括号序列，因此概率为 1。\n\n### 数据范围\n\n对于全部数据，有 $1\\le n\\le 5\\cdot 10^5$，且输入的括号序列合法。\n\nSubtask 1（20 pts）：保证 $1\\le n\\le 5$。\n\nSubtask 2（30 pts）：保证 $1\\le n\\le 1000$。\n\nSubtask 3（50 pts）：无特殊限制。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Something Comforting", "background": "![Something Comforting](https://mivik.gitee.io/image/nurture/something_comforting.png)\n\n> Cause getting made you want more\n>\n> And hoping made you hurt more\n>\n> Someone tell me\n>\n> Something comforting", "description": "Porter Robinson 花了五年的时间制作了 Something Comforting 这首歌，Mivik 花了五天时间造出了一道和括号序列相关的题。但 Mivik 并不开心，因为他发现他不会造数据了！\n\nMivik 需要随机生成一个 **合法** 的括号序列，于是 Mivik 想了一会，写出了下面的算法：\n\n```cpp\n#include <algorithm>\n#include <string>\n\nstd::string generate(int n) { // 生成一个长度为 n * 2 的括号序列\n\tconst int len = n * 2;\n\tbool arr[len]; // 0 代表左括号，1 代表右括号\n\tfor (int i = 0; i < n; ++i) arr[i] = 0;\n\tfor (int i = n; i < len; ++i) arr[i] = 1;\n\tstd::random_shuffle(arr, arr + len); // 随机打乱这个数组\n\tfor (int i = 0, j, sum = 0; i < len; ) {\n\t\tsum += arr[i]? -1: 1;\n\t\tif (sum < 0) { // 出现了不合法的位置\n\t\t\tfor (j = i + 1; j < len; ++j) {\n\t\t\t\tsum += arr[j]? -1: 1;\n\t\t\t\tif (sum == 0) break;\n\t\t\t}\n\t\t\t// 现在 i 是第一个不合法的位置，j 是 i 后面第一个合法的位置\n\t\t\t// ( ( ) ) ) ) ( ( ( ) ( )\n\t\t\t//         i     j\n\t\t\tfor (int k = i; k <= j; ++k)\n\t\t\t\tarr[k] ^= 1; // 把这段区间全部反转\n\t\t\ti = j + 1;\n\t\t} else ++i;\n\t}\n\tstd::string ret;\n\tfor (int i = 0; i < len; ++i)\n\t\tret += arr[i]? ')': '(';\n\treturn ret;\n}\n```\n\nP.S. 为了给其它语言用户带来做题体验，[这里](https://www.luogu.com.cn/paste/wof8zjn8) 提供了多种语言对该算法的描述。\n\nMivik 十分开心，因为这个算法总能生成合法的括号序列。但不一会儿他就发现这个算法生成的括号序列并不均匀，也就是说，当 $n$ 固定时，所有合法的括号序列出现的概率并不均等。例如，Mivik 发现当 $n=3$ 时，`()()()` 被生成的概率要远大于 `((()))`。\n\n现在 Mivik 给了你一个 $n$ 和一个长度为 $2n$ 的 **合法** 括号序列，假设 `std::random_shuffle` （对于其它语言来说，`shuffle`）能够均匀随机地打乱一个数组，他想问问你这个括号序列通过上文的算法被生成的概率是多少。由于 Mivik 不喜欢小数，你需要输出这个概率对 $998244353$ 取模的结果。如果你不知道如何将一个有理数对质数取模，可以参考 [有理数取模](https://www.luogu.com.cn/problem/P2613)。", "inputFormat": "第一行一个整数 $n$，意义同题面。\n\n接下来输入一个长度为 $2n$ 的合法括号序列，意义同题面。", "outputFormat": "输出一行一个整数，代表这个概率对 $998244353$ 取模的结果。", "hint": "\n### 样例解释\n\n样例一：$n$ 为 1 时，无论怎样都只可能会生成 `()` 这一种合法的括号序列，因此概率为 1。\n\n### 数据范围\n\n对于全部数据，有 $1\\le n\\le 5\\cdot 10^5$，且输入的括号序列合法。\n\nSubtask 1（20 pts）：保证 $1\\le n\\le 5$。\n\nSubtask 2（30 pts）：保证 $1\\le n\\le 1000$。\n\nSubtask 3（50 pts）：无特殊限制。\n", "locale": "zh-CN"}}}
{"pid": "P7264", "type": "P", "difficulty": 5, "samples": [["0\n0 0\n0 2", "2\n"], ["3\n0 0\n0 2\n1 2\n4 2\n3 4", "13\n110"], ["0\n12 34\n3 100", "85\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["递归", "2021"], "title": "Mirror", "background": "![Mirror](https://mivik.gitee.io/image/nurture/mirror.png)\n\n> And it’s not the voice of all the others\n>\n> You’ve only said it to yourself\n>\n> I know what you want from me, from me\n>\n> I know what you’re thinking", "description": "> Porter Robinson: We all have these avatars that we give to our critical inner voices - we might imagine a scornful parent telling us we’ll fail, or a critic telling us our work comes up short, or a society telling us that we aren’t good enough - it’s about recognizing that most of this criticism is self-inflicted.\n\nMivik 在镜中看见了自己的 Inner Voice ——不过是在一个镜子般对称的迷宫中。这个迷宫很特殊：它有无穷多行和无穷多列，行和列都从 $0$ 开始标号。一个格子 $(i,j)$ 能通过（没有障碍）当且仅当 $(i\\&j)=0$，其中 $\\&$ 指按位与运算（Bitwise And，[百度百科](https://baike.baidu.com/item/%E6%8C%89%E4%BD%8D%E4%B8%8E/9601818)）。下图给出了这个迷宫的 $0\\sim63$ 行和 $0\\sim 63$ 列的图像：\n\n![迷宫](https://cdn.luogu.com.cn/upload/image_hosting/das5c73w.png)\n\nMivik 想抓到并消灭那个给予自己负面声音的 Inner Voice，但他找不到路了。Mivik 和 Inner Voice 最初处在迷宫中的两点。Mivik 想知道，在 Mivik 的 Inner Voice 一直不移动的情况下，他至少需要走过多少个方格才能抓到他的 Inner Voice（Mivik 的起始格不算）。\n\n但是... 游戏并不会像 Mivik 想象的一样简单。邪恶的 ggy 在这个迷宫中的某些格子布下了许多炸弹，Mivik 需要拆除它们才能踏上这些格子。Mivik 需要你告诉他，在他走过的方格数最少的情况下，他至少需要拆除哪些炸弹。\n\n**请注意炸弹可能会重合，而你只有拆除一个格子上的所有炸弹才能通过这个格子。保障炸弹不与起点重合。**", "inputFormat": "第一行一个整数 $n$，代表 ggy 设下的炸弹个数。\n\n接下来 $n$ 行，**其中的**第 $i$ 行两个非负整数，代表 $i$ 号炸弹的坐标（从 1 开始编号）。\n\n接下来一行两个非负整数 $sx$ 和 $sy$，代表 Mivik 位于哪一行哪一列。\n\n接下来一行两个非负整数 $ex$ 和 $ey$，代表 Mivik 的 Inner Voice 位于哪一行哪一列。", "outputFormat": "第一行一个整数，代表 Mivik 至少需要走少格才能抓到他的 Inner Voice。\n\n接下来一行，给出一个长度为 $n$ 的 01 串，第 $i$ 个字符为 `1` 代表 Mivik 必须拆除第 $i$ 号炸弹，`0` 代表不需要。", "hint": "### 样例解释\n\n样例一：显然由于没有任何炸弹，Mivik 向右走两格就能抓到他的 Inner Voice。\n\n样例二：Mivik 的最短路径如图所示：\n\n![路径](https://cdn.luogu.com.cn/upload/image_hosting/mg0hmhgs.png)\n\n其中，图片左上角为 $(0,0)$，蓝色代表 Mivik 的起始位置，绿色代表 Inner Voice 的位置，红色代表 Mivik 的最短路径，黄色代表炸弹，橙色（其实是黄色 + 红色）代表 Mivik 必须拆除的炸弹。\n\n### 数据范围\n\n对于全部数据，有 $1\\le n\\le 2\\cdot 10^5$，$(sx,sy)\\ne(ex,ey)$，并保证对于给出的任何坐标 $(x,y)$ 都有 $x\\&y=0$ 且 $0\\le x,y\\le 10^{18}$。\n\nSubtask 1 (10 pts)：保证 Mivik 可以直线（只向 上/下/左/右 走）抓到他的 Inner Voice。\n\nSubtask 2 (15 pts)：保证 $sx=sy=0$。\n\nSubtask 3 (20 pts)：保证 $0\\le(\\text{任意 x,y 坐标})\\le 100$。\n\nSubtask 4 (25 pts)：保证 $n=0$。\n\nSubtask 5 (30 pts)：无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Mirror", "background": "![Mirror](https://mivik.gitee.io/image/nurture/mirror.png)\n\n> And it’s not the voice of all the others\n>\n> You’ve only said it to yourself\n>\n> I know what you want from me, from me\n>\n> I know what you’re thinking", "description": "> Porter Robinson: We all have these avatars that we give to our critical inner voices - we might imagine a scornful parent telling us we’ll fail, or a critic telling us our work comes up short, or a society telling us that we aren’t good enough - it’s about recognizing that most of this criticism is self-inflicted.\n\nMivik 在镜中看见了自己的 Inner Voice ——不过是在一个镜子般对称的迷宫中。这个迷宫很特殊：它有无穷多行和无穷多列，行和列都从 $0$ 开始标号。一个格子 $(i,j)$ 能通过（没有障碍）当且仅当 $(i\\&j)=0$，其中 $\\&$ 指按位与运算（Bitwise And，[百度百科](https://baike.baidu.com/item/%E6%8C%89%E4%BD%8D%E4%B8%8E/9601818)）。下图给出了这个迷宫的 $0\\sim63$ 行和 $0\\sim 63$ 列的图像：\n\n![迷宫](https://cdn.luogu.com.cn/upload/image_hosting/das5c73w.png)\n\nMivik 想抓到并消灭那个给予自己负面声音的 Inner Voice，但他找不到路了。Mivik 和 Inner Voice 最初处在迷宫中的两点。Mivik 想知道，在 Mivik 的 Inner Voice 一直不移动的情况下，他至少需要走过多少个方格才能抓到他的 Inner Voice（Mivik 的起始格不算）。\n\n但是... 游戏并不会像 Mivik 想象的一样简单。邪恶的 ggy 在这个迷宫中的某些格子布下了许多炸弹，Mivik 需要拆除它们才能踏上这些格子。Mivik 需要你告诉他，在他走过的方格数最少的情况下，他至少需要拆除哪些炸弹。\n\n**请注意炸弹可能会重合，而你只有拆除一个格子上的所有炸弹才能通过这个格子。保障炸弹不与起点重合。**", "inputFormat": "第一行一个整数 $n$，代表 ggy 设下的炸弹个数。\n\n接下来 $n$ 行，**其中的**第 $i$ 行两个非负整数，代表 $i$ 号炸弹的坐标（从 1 开始编号）。\n\n接下来一行两个非负整数 $sx$ 和 $sy$，代表 Mivik 位于哪一行哪一列。\n\n接下来一行两个非负整数 $ex$ 和 $ey$，代表 Mivik 的 Inner Voice 位于哪一行哪一列。", "outputFormat": "第一行一个整数，代表 Mivik 至少需要走少格才能抓到他的 Inner Voice。\n\n接下来一行，给出一个长度为 $n$ 的 01 串，第 $i$ 个字符为 `1` 代表 Mivik 必须拆除第 $i$ 号炸弹，`0` 代表不需要。", "hint": "### 样例解释\n\n样例一：显然由于没有任何炸弹，Mivik 向右走两格就能抓到他的 Inner Voice。\n\n样例二：Mivik 的最短路径如图所示：\n\n![路径](https://cdn.luogu.com.cn/upload/image_hosting/mg0hmhgs.png)\n\n其中，图片左上角为 $(0,0)$，蓝色代表 Mivik 的起始位置，绿色代表 Inner Voice 的位置，红色代表 Mivik 的最短路径，黄色代表炸弹，橙色（其实是黄色 + 红色）代表 Mivik 必须拆除的炸弹。\n\n### 数据范围\n\n对于全部数据，有 $1\\le n\\le 2\\cdot 10^5$，$(sx,sy)\\ne(ex,ey)$，并保证对于给出的任何坐标 $(x,y)$ 都有 $x\\&y=0$ 且 $0\\le x,y\\le 10^{18}$。\n\nSubtask 1 (10 pts)：保证 Mivik 可以直线（只向 上/下/左/右 走）抓到他的 Inner Voice。\n\nSubtask 2 (15 pts)：保证 $sx=sy=0$。\n\nSubtask 3 (20 pts)：保证 $0\\le(\\text{任意 x,y 坐标})\\le 100$。\n\nSubtask 4 (25 pts)：保证 $n=0$。\n\nSubtask 5 (30 pts)：无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P7265", "type": "P", "difficulty": 7, "samples": [["2 0", "3"], ["3 2", "13\n8\n6"], ["10 0", "83728116"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "O2优化", "快速数论变换 NTT"], "title": "Look At The Sky", "background": "![Look At The Sky](https://mivik.gitee.io/image/nurture/look_at_the_sky.jpeg)\n\n> Look at the sky, I'm still here\n>\n> I'll be alive next year\n>\n> I can make something good, oh\n>\n> Something good\n\n本题加强版：[U148588](https://www.luogu.com.cn/problem/U148588)", "description": "Mivik 又把 $(x+y)^2$ 当成 $(x^2+y^2)$ 来算了！蒟蒻的他望向天空，看见朵朵白云飘散又融合，忽然来了灵感，写下了一个序列 $S$ 的 $k$ 阶平均数的定义：\n$$\navg_k(S)=\\frac{\\sum_{i=1}^{|S|}{S_i^k}}{\\left(\\sum_{i=1}^{|S|}S_i\\right)^k}\n$$\nMivik 想起 2020 年发生的一切，对他而言很重要的一共有 $n$ 件。例如，举办了自己的第一场比赛、见证了 Porter Robinson 时隔一年后重新在音乐界活跃、和那个人相遇... 其中有一些事件之间相互有联系，也就是说它们形成了一张无向图。Mivik 把这个无向图的所有极大连通块的大小依次写在了一张白纸上，认为这代表了他 2020 年所经历的一切。或美好、或悲伤，Mivik 现在把这张白纸折成了纸飞机准备放飞它。不过在此之前，Mivik 想要求一下这个白纸上的数的 $k$ 阶平均数，并作为 2020 年的纪念记录在日记本上。\n\n可惜的是，Mivik 的记性不太好：他只记得一共发生了 $n$ 件大事，但却记不清它们之间的关系了。Mivik 干脆让你求出在所有可能的情况下，这个白纸上的数的 $k$ 阶平均数之和。实际上，Mivik 并不在意 $k$ 是什么，他只在意最终的答案写在日记本上是否美观，于是他干脆让你对所有 $k\\in [0,K]$ 算出上面的值，这样他好选出一个。\n\n两种情况本质不同，当且仅当存在两件事情，它们在一种情况中没有联系而在另一种情况中有。\n\n形式化题意：记一张无向图的连通块集合 $f(G)$ 为这张图所有极大连通块的大小形成的任意顺序的序列，要求对所有 $k\\in [0,K]$ 求：\n$$\n\\sum_{G\\in S(n)}\\frac{\\sum_{i=1}^{|f(G)|}{f(G)_i^k}}{\\left(\\sum_{i=1}^{|f(G)|}f(G)_i\\right)^k}\n$$\n$S(n)$ 为所有大小为 $n$ 的无向图形成的集合。答案对 $998244353$ 取模。如果你不知道如何将一个有理数对质数取模，可以参考 [有理数取模](https://www.luogu.com.cn/problem/P2613)。", "inputFormat": "一行两个正整数，代表 $n$ 和 $K$，意义同题面。", "outputFormat": "$K+1$ 行，第 $i$ 行一个整数，代表 $k=i-1$ 时的答案。", "hint": "\n### 样例解释\n\n样例一：两个点的无向图只有两种，即两个点之间有边和无边，那么 $k=0$ 时的答案为 $\\frac{1^0+1^0}{(1+1)^0}+\\frac{2^0}{(2)^0}=1+2=3$。\n\n样例二：三个点的无向图有以下 8 种：\n\n![样例二](https://cdn.luogu.com.cn/upload/image_hosting/bu2h64fw.png)\n\n$k=0$ 时，答案为 $\\frac{1^0+1^0+1^0}{(1+1+1)^0}+3\\times\\frac{1^0+2^0}{(1+2)^0}+4\\times\\frac{3^0}{(3)^0}=3+3\\times2+4\\times1=13$；\n\n$k=1$ 时，答案为 $\\frac{1^1+1^1+1^1}{(1+1+1)^1}+3\\times\\frac{1^1+2^1}{(1+2)^1}+4\\times\\frac{3^1}{(3)^1}=1+3\\times1+4\\times1=8$；\n\n$k=2$ 时，答案为 $\\frac{1^2+1^2+1^2}{(1+1+1)^2}+3\\times\\frac{1^2+2^2}{(1+2)^2}+4\\times\\frac{3^2}{(3)^2}=\\frac13+3\\times\\frac59+4\\times1=6$。\n\n### 数据范围\n\n对于全部数据，有 $1\\le n\\le 2\\cdot10^5$，$0\\le K\\le 5000$。\n\nSubtask 1 (5 pts)：保证 $n=1$。\n\nSubtask 2 (10 pts)：保证 $n=2$。\n\nSubtask 3 (25 pts)：保证 $K=0$。\n\nSubtask 4 (25 pts)：保证 $0\\le K\\le 10$。\n\nSubtask 5 (35 pts)：无特殊限制。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Look At The Sky", "background": "![Look At The Sky](https://mivik.gitee.io/image/nurture/look_at_the_sky.jpeg)\n\n> Look at the sky, I'm still here\n>\n> I'll be alive next year\n>\n> I can make something good, oh\n>\n> Something good\n\n本题加强版：[U148588](https://www.luogu.com.cn/problem/U148588)", "description": "Mivik 又把 $(x+y)^2$ 当成 $(x^2+y^2)$ 来算了！蒟蒻的他望向天空，看见朵朵白云飘散又融合，忽然来了灵感，写下了一个序列 $S$ 的 $k$ 阶平均数的定义：\n$$\navg_k(S)=\\frac{\\sum_{i=1}^{|S|}{S_i^k}}{\\left(\\sum_{i=1}^{|S|}S_i\\right)^k}\n$$\nMivik 想起 2020 年发生的一切，对他而言很重要的一共有 $n$ 件。例如，举办了自己的第一场比赛、见证了 Porter Robinson 时隔一年后重新在音乐界活跃、和那个人相遇... 其中有一些事件之间相互有联系，也就是说它们形成了一张无向图。Mivik 把这个无向图的所有极大连通块的大小依次写在了一张白纸上，认为这代表了他 2020 年所经历的一切。或美好、或悲伤，Mivik 现在把这张白纸折成了纸飞机准备放飞它。不过在此之前，Mivik 想要求一下这个白纸上的数的 $k$ 阶平均数，并作为 2020 年的纪念记录在日记本上。\n\n可惜的是，Mivik 的记性不太好：他只记得一共发生了 $n$ 件大事，但却记不清它们之间的关系了。Mivik 干脆让你求出在所有可能的情况下，这个白纸上的数的 $k$ 阶平均数之和。实际上，Mivik 并不在意 $k$ 是什么，他只在意最终的答案写在日记本上是否美观，于是他干脆让你对所有 $k\\in [0,K]$ 算出上面的值，这样他好选出一个。\n\n两种情况本质不同，当且仅当存在两件事情，它们在一种情况中没有联系而在另一种情况中有。\n\n形式化题意：记一张无向图的连通块集合 $f(G)$ 为这张图所有极大连通块的大小形成的任意顺序的序列，要求对所有 $k\\in [0,K]$ 求：\n$$\n\\sum_{G\\in S(n)}\\frac{\\sum_{i=1}^{|f(G)|}{f(G)_i^k}}{\\left(\\sum_{i=1}^{|f(G)|}f(G)_i\\right)^k}\n$$\n$S(n)$ 为所有大小为 $n$ 的无向图形成的集合。答案对 $998244353$ 取模。如果你不知道如何将一个有理数对质数取模，可以参考 [有理数取模](https://www.luogu.com.cn/problem/P2613)。", "inputFormat": "一行两个正整数，代表 $n$ 和 $K$，意义同题面。", "outputFormat": "$K+1$ 行，第 $i$ 行一个整数，代表 $k=i-1$ 时的答案。", "hint": "\n### 样例解释\n\n样例一：两个点的无向图只有两种，即两个点之间有边和无边，那么 $k=0$ 时的答案为 $\\frac{1^0+1^0}{(1+1)^0}+\\frac{2^0}{(2)^0}=1+2=3$。\n\n样例二：三个点的无向图有以下 8 种：\n\n![样例二](https://cdn.luogu.com.cn/upload/image_hosting/bu2h64fw.png)\n\n$k=0$ 时，答案为 $\\frac{1^0+1^0+1^0}{(1+1+1)^0}+3\\times\\frac{1^0+2^0}{(1+2)^0}+4\\times\\frac{3^0}{(3)^0}=3+3\\times2+4\\times1=13$；\n\n$k=1$ 时，答案为 $\\frac{1^1+1^1+1^1}{(1+1+1)^1}+3\\times\\frac{1^1+2^1}{(1+2)^1}+4\\times\\frac{3^1}{(3)^1}=1+3\\times1+4\\times1=8$；\n\n$k=2$ 时，答案为 $\\frac{1^2+1^2+1^2}{(1+1+1)^2}+3\\times\\frac{1^2+2^2}{(1+2)^2}+4\\times\\frac{3^2}{(3)^2}=\\frac13+3\\times\\frac59+4\\times1=6$。\n\n### 数据范围\n\n对于全部数据，有 $1\\le n\\le 2\\cdot10^5$，$0\\le K\\le 5000$。\n\nSubtask 1 (5 pts)：保证 $n=1$。\n\nSubtask 2 (10 pts)：保证 $n=2$。\n\nSubtask 3 (25 pts)：保证 $K=0$。\n\nSubtask 4 (25 pts)：保证 $0\\le K\\le 10$。\n\nSubtask 5 (35 pts)：无特殊限制。\n", "locale": "zh-CN"}}}
{"pid": "P7266", "type": "P", "difficulty": 3, "samples": [["3\n1 2 3\n3 2 2 1\n4 2 8 0 3\n5 3 1 2\n3 1 4", "22"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2000", "BalticOI（波罗的海）"], "title": "[BalticOI 2000] Honeycomb Problem", "background": "", "description": "如下图，是一个边长为 $3$ 的蜂窝图，每个点有点权：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/71c4lcqk.png)\n\n现在要从上面一行的某一点到最下面的一行某一点，每次只可以到达左下角的点和右下角的点，您最多可以交换选定的一行中的两个点的数值。\n\n求通过交换，从上面一行的某一点到最下面的一行某一点的点权之和的最大值是多少。", "inputFormat": "第一行一个整数 $n$ 代表蜂窝图的边长。     \n接下来 $2n-1$ 行每行若干个整数代表一个蜂窝图。", "outputFormat": "一行一个整数代表答案。", "hint": "#### 样例说明\n\n对于样例 $1$，交换第四行的 $5$ 和 $1$，然后我们就可以得到一条点权之和最大的路径：\n\n$$3 \\to 2 \\to 8 \\to 5 \\to 4$$\n\n最大值为 $22$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 99$，$0 \\le $ 蜂窝图中的每个图 $\\le 99$。\n\n#### 说明\n\n翻译自 [BalticOI 2000 Day1 A Honeycomb Problem](https://boi.cses.fi/files/boi2000_day1.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2000] Honeycomb Problem", "background": "", "description": "如下图，是一个边长为 $3$ 的蜂窝图，每个点有点权：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/71c4lcqk.png)\n\n现在要从上面一行的某一点到最下面的一行某一点，每次只可以到达左下角的点和右下角的点，您最多可以交换选定的一行中的两个点的数值。\n\n求通过交换，从上面一行的某一点到最下面的一行某一点的点权之和的最大值是多少。", "inputFormat": "第一行一个整数 $n$ 代表蜂窝图的边长。     \n接下来 $2n-1$ 行每行若干个整数代表一个蜂窝图。", "outputFormat": "一行一个整数代表答案。", "hint": "#### 样例说明\n\n对于样例 $1$，交换第四行的 $5$ 和 $1$，然后我们就可以得到一条点权之和最大的路径：\n\n$$3 \\to 2 \\to 8 \\to 5 \\to 4$$\n\n最大值为 $22$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 99$，$0 \\le $ 蜂窝图中的每个图 $\\le 99$。\n\n#### 说明\n\n翻译自 [BalticOI 2000 Day1 A Honeycomb Problem](https://boi.cses.fi/files/boi2000_day1.pdf)。", "locale": "zh-CN"}}}
{"pid": "P7267", "type": "P", "difficulty": 0, "samples": [["5\n0017\n0250\n0400\n0201\n0002", "3 1 0 2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2000", "BalticOI（波罗的海）"], "title": "[BalticOI 2000] Time Zones", "background": "", "description": "给定一个整数 $n$，现在将世界划分为 $n$ 个时区，分别编号为第 $0$ 时区到第 $n-1$ 时区，您在第 $0$ 时区。现在有 $n$ 个地方发来的一些时间，用 $hh$ 和 $mm$ 表示，代表小时和分钟。\n\n保证 $0 \\le hh \\le n-1$，$0 \\le mm \\le 59$。\n\n发来时间中间要跨时区，跨过一个时区 $hh$ 就要变化 $1$，因此最终第 $0$ 时区得到的时间信息是最后跨时区进行加减后的结果，跨时区之后不能使得 $hh$ 超出 $[0,n-1]$ 的范围。\n\n求这 $n$ 个时间信息分别来自哪几个时区。", "inputFormat": "第一行一个整数 $n$ 代表时区数和时间消息数。     \n接下来 $n$ 行每行两个整数 $hh$ 和 $mm$ 代表一个时间消息，注意 $hh$ 和 $mm$ 都要用两位整数的形式表示。    \n比如 $hh=5$，$mm=6$ 最终表示结果就是 $0506$。", "outputFormat": "一行 $n$ 个整数代表每个时间消息来自哪个时区。", "hint": "#### 样例说明\n\n注意样例 $1$ 的第 $3$ 个数据，该时间消息必须来自第 $0$ 时区，因为其他时区的时间消息到第 $0$ 时区都要至少经过 $1$ 小时，$hh$ 最小值为 $5$，就超过了 $[0,n-1]$ 的范围。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$5 \\le n \\le 60$，$0 \\le hh \\le n-1$，$0 \\le mm \\le 59$。\n\n#### 说明\n\n翻译自 [BalticOI 2000 Day1 B Time Zones](https://boi.cses.fi/files/boi2000_day1.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2000] Time Zones", "background": "", "description": "给定一个整数 $n$，现在将世界划分为 $n$ 个时区，分别编号为第 $0$ 时区到第 $n-1$ 时区，您在第 $0$ 时区。现在有 $n$ 个地方发来的一些时间，用 $hh$ 和 $mm$ 表示，代表小时和分钟。\n\n保证 $0 \\le hh \\le n-1$，$0 \\le mm \\le 59$。\n\n发来时间中间要跨时区，跨过一个时区 $hh$ 就要变化 $1$，因此最终第 $0$ 时区得到的时间信息是最后跨时区进行加减后的结果，跨时区之后不能使得 $hh$ 超出 $[0,n-1]$ 的范围。\n\n求这 $n$ 个时间信息分别来自哪几个时区。", "inputFormat": "第一行一个整数 $n$ 代表时区数和时间消息数。     \n接下来 $n$ 行每行两个整数 $hh$ 和 $mm$ 代表一个时间消息，注意 $hh$ 和 $mm$ 都要用两位整数的形式表示。    \n比如 $hh=5$，$mm=6$ 最终表示结果就是 $0506$。", "outputFormat": "一行 $n$ 个整数代表每个时间消息来自哪个时区。", "hint": "#### 样例说明\n\n注意样例 $1$ 的第 $3$ 个数据，该时间消息必须来自第 $0$ 时区，因为其他时区的时间消息到第 $0$ 时区都要至少经过 $1$ 小时，$hh$ 最小值为 $5$，就超过了 $[0,n-1]$ 的范围。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$5 \\le n \\le 60$，$0 \\le hh \\le n-1$，$0 \\le mm \\le 59$。\n\n#### 说明\n\n翻译自 [BalticOI 2000 Day1 B Time Zones](https://boi.cses.fi/files/boi2000_day1.pdf)。", "locale": "zh-CN"}}}
{"pid": "P7268", "type": "P", "difficulty": 0, "samples": [["6\n0 0 0 1 1 1\n0 0 0 0 1 0\n0 0 0 1 1 1\n0 0 0 0 0 0\n0 0 1 1 1 1\n0 0 0 1 0 1", "6\n11 E\n16 NWN\n17 SE\n27 S\n28 NWWSS\n29 S"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2000", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2000] Electronical Plate", "background": "", "description": "给定一个 $(n-1) \\times (n-1)$ 的网格，两条直线的交点有一个节点，则这个网格有 $n \\times n$ 个节点，从左往右，从上往下，这些节点依次编号为 $1$ 到 $n^2$。\n\n这些节点中有一些节点被称为「电源」，现在要连一些电路，要求以电源为起点，连向其他节点，要求不能经过其他电源，终点为网格上下左右四个边缘上的节点。\n\n比如说下面这个图，黑色的为电源，白色的为普通节点：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oxg2y2aq.png)\n\n因为有一些电源就在边缘上，我们不需要进行连接。有一种可行解即为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/th4jbsdg.png)\n\n如果有多组解，找出其中一组即可。", "inputFormat": "第一行一个整数 $n$ 代表网格的大小。     \n接下来 $n$ 行每行 $n$ 个整数代表每个节点，$0$ 或者 $1$。       \n$0$ 代表这个节点是普通节点，$1$ 代表这个节点是电源。", "outputFormat": "第一行一个整数 $k$ 代表至少需要多少个电源要连电线。（有一些在边缘的电源不需要连电线）      \n接下来 $k$ 行，每行首先第一个整数代表要连电线的电源的编号，接下来一个字符串代表电源要把电线连向边缘的路线，向左输出 `W`，向右输出 `E`，向上输出 `N`，向下输出 `S`，电源按照编号从小到大输出。        \n如果有多解，输出一组即可。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$3 \\le n \\le 15$。\n\n**本题使用 Special Judge。**\n\n感谢 spj 提供者 @[tiger2005](https://www.luogu.com.cn/user/60864)。\n\n#### 说明\n\n翻译自 [BalticOI 2000 Day1 C Electronical Plate](https://boi.cses.fi/files/boi2000_day1.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2000] Electronical Plate", "background": "", "description": "给定一个 $(n-1) \\times (n-1)$ 的网格，两条直线的交点有一个节点，则这个网格有 $n \\times n$ 个节点，从左往右，从上往下，这些节点依次编号为 $1$ 到 $n^2$。\n\n这些节点中有一些节点被称为「电源」，现在要连一些电路，要求以电源为起点，连向其他节点，要求不能经过其他电源，终点为网格上下左右四个边缘上的节点。\n\n比如说下面这个图，黑色的为电源，白色的为普通节点：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oxg2y2aq.png)\n\n因为有一些电源就在边缘上，我们不需要进行连接。有一种可行解即为：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/th4jbsdg.png)\n\n如果有多组解，找出其中一组即可。", "inputFormat": "第一行一个整数 $n$ 代表网格的大小。     \n接下来 $n$ 行每行 $n$ 个整数代表每个节点，$0$ 或者 $1$。       \n$0$ 代表这个节点是普通节点，$1$ 代表这个节点是电源。", "outputFormat": "第一行一个整数 $k$ 代表至少需要多少个电源要连电线。（有一些在边缘的电源不需要连电线）      \n接下来 $k$ 行，每行首先第一个整数代表要连电线的电源的编号，接下来一个字符串代表电源要把电线连向边缘的路线，向左输出 `W`，向右输出 `E`，向上输出 `N`，向下输出 `S`，电源按照编号从小到大输出。        \n如果有多解，输出一组即可。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$3 \\le n \\le 15$。\n\n**本题使用 Special Judge。**\n\n感谢 spj 提供者 @[tiger2005](https://www.luogu.com.cn/user/60864)。\n\n#### 说明\n\n翻译自 [BalticOI 2000 Day1 C Electronical Plate](https://boi.cses.fi/files/boi2000_day1.pdf)。", "locale": "zh-CN"}}}
{"pid": "P7269", "type": "P", "difficulty": 2, "samples": [["8 2\n(((((])] ", "1\n3\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "字符串", "2005", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2005] Magic Parenthesis (Day1)", "background": "合法括号串的定义：\n\n- `()` 是合法的；\n- 如果 `A` 是合法的，那么 `(A)` 是合法的；\n- 如果 `A` 和 `B` 是合法的，那么 `AB` 是合法的。", "description": "给定一个长为 $N$ 的字符串 $S$，由 `(`，`)` 和 `]` 组成。\n\n整个字符串中有 $M$ 个 `]`，其他全为左右括号。\n\n现在得知可以用若干个 `)` 来替换 `]`，求一种通过替换 $S$ 中的 `]` 得到合法括号串的做法。", "inputFormat": "第一行两个整数 $N,M$ 代表字符串的长度与 `]` 的个数。   \n接下来有若干行，每行最多 $72$ 个字符，总计 $N$ 个字符，代表字符串 $S$。", "outputFormat": "如果无解，输出 `0` 并结束程序。       \n如果有解，首先输出一个 `1`，然后接下来 $M$ 行每行一个整数代表每一个 `]` 要替换多少成个 `)`。", "hint": "#### 样例说明\n\n对于样例 $1$，按照输入替换后得到的 $S$ 为 `((((()))))`，为合法括号串。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^7$，$1 \\le M \\le 5 \\times 10^6$，$M \\le N$。\n\n**本题使用 Special Judge。**\n\n感谢 spj 提供者 @[tiger2005](https://www.luogu.com.cn/user/60864)。\n\n#### 说明\n\n翻译自 [BalticOI 2005 Day1 B Magic Parenthesis](https://boi.cses.fi/files/boi2005_day1.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2005] Magic Parenthesis (Day1)", "background": "合法括号串的定义：\n\n- `()` 是合法的；\n- 如果 `A` 是合法的，那么 `(A)` 是合法的；\n- 如果 `A` 和 `B` 是合法的，那么 `AB` 是合法的。", "description": "给定一个长为 $N$ 的字符串 $S$，由 `(`，`)` 和 `]` 组成。\n\n整个字符串中有 $M$ 个 `]`，其他全为左右括号。\n\n现在得知可以用若干个 `)` 来替换 `]`，求一种通过替换 $S$ 中的 `]` 得到合法括号串的做法。", "inputFormat": "第一行两个整数 $N,M$ 代表字符串的长度与 `]` 的个数。   \n接下来有若干行，每行最多 $72$ 个字符，总计 $N$ 个字符，代表字符串 $S$。", "outputFormat": "如果无解，输出 `0` 并结束程序。       \n如果有解，首先输出一个 `1`，然后接下来 $M$ 行每行一个整数代表每一个 `]` 要替换多少成个 `)`。", "hint": "#### 样例说明\n\n对于样例 $1$，按照输入替换后得到的 $S$ 为 `((((()))))`，为合法括号串。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^7$，$1 \\le M \\le 5 \\times 10^6$，$M \\le N$。\n\n**本题使用 Special Judge。**\n\n感谢 spj 提供者 @[tiger2005](https://www.luogu.com.cn/user/60864)。\n\n#### 说明\n\n翻译自 [BalticOI 2005 Day1 B Magic Parenthesis](https://boi.cses.fi/files/boi2005_day1.pdf)。", "locale": "zh-CN"}}}
{"pid": "P7270", "type": "P", "difficulty": 0, "samples": [["5\n-5 -3 6\n-1 -2 3\n0 0 2\n-2 2 1\n-4 -1 2 ", "24.5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2002", "BalticOI（波罗的海）"], "title": "[BalticOI 2002] Triangles (Day1)", "background": null, "description": "给定 $n$ 个等腰直角三角形，每个三角形由一个点 $(x_i,y_i)$ 向上向右延伸出长为 $m_i$ 的两条直角边生成。\n\n求这些三角形覆盖的面积之和。", "inputFormat": "第一行一个整数 $n$ 代表三角形的个数。     \n接下来 $n$ 行每行三个整数 $x_i,y_i,m_i$ 描述一个三角形。", "outputFormat": "一行一个实数代表答案。    \n只需要保留一位小数。", "hint": "#### 样例说明\n\n对于样例 $1$，$5$ 个三角形如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a49ow7cr.png)\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 2000$，$-10^7 \\le x_i,y_i \\le 10^7$，$0 \\le m \\le 1000$。\n\n#### 说明\n\n翻译自 [BalticOI 2002 Day1 C Triangles](https://boi.cses.fi/files/boi2002_day1.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2002] Triangles (Day1)", "background": null, "description": "给定 $n$ 个等腰直角三角形，每个三角形由一个点 $(x_i,y_i)$ 向上向右延伸出长为 $m_i$ 的两条直角边生成。\n\n求这些三角形覆盖的面积之和。", "inputFormat": "第一行一个整数 $n$ 代表三角形的个数。     \n接下来 $n$ 行每行三个整数 $x_i,y_i,m_i$ 描述一个三角形。", "outputFormat": "一行一个实数代表答案。    \n只需要保留一位小数。", "hint": "#### 样例说明\n\n对于样例 $1$，$5$ 个三角形如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/a49ow7cr.png)\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 2000$，$-10^7 \\le x_i,y_i \\le 10^7$，$0 \\le m \\le 1000$。\n\n#### 说明\n\n翻译自 [BalticOI 2002 Day1 C Triangles](https://boi.cses.fi/files/boi2002_day1.pdf)。", "locale": "zh-CN"}}}
{"pid": "P7271", "type": "P", "difficulty": 0, "samples": [["6 15 1\n0 1 25 68\n0 2 30 50\n0 5 0 101\n1 2 70 77\n1 3 35 42\n2 0 0 22\n2 1 40 86\n2 3 0 23\n2 4 45 40\n3 1 64 14\n3 5 0 23\n4 1 95 8\n5 1 0 84\n5 2 90 64\n5 3 36 40", "0 5 2 3 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2002", "BalticOI（波罗的海）"], "title": "[BalticOI 2002] Speed Limits (Day1)", "background": "", "description": "您现在在一张 $N$ 点 $M$ 边的无向图的点 $0$ 处，这 $N$ 个点编号为 $0$ 到 $N-1$。\n\n每条边从 $A$ 连向 $B$，速度限制为 $V$，长度为 $L$，经过这条边的时间的算法如下：\n\n$$T=\\begin{cases}\\dfrac{L}{V}\\ (V\\ne 0)\\\\\\dfrac{L}{V_\\text{old}}\\ (V=0)\\end{cases}$$\n\n其中 $V_\\text{old}$ 为您经过的上一条边的 $V$ 的值，最开始 $V_\\text{old}=70$。\n\n如果 $V=0$，这条边的 $V$ 的值在计算完 $T$ 后更新为 $V_\\text{old}$，$V_\\text{old}$ 更新为 $V$。\n\n您先在要从点 $0$ 到点 $D$，求一条从 $0$ 到 $D$ 的路径使得花的时间最少。", "inputFormat": "第一行三个整数 $N,M,D$ 代表点数，边数和终点。     \n接下来 $M$ 行每行四个整数 $A,B,V,L$ 代表一条边。", "outputFormat": "一行若干个整数代表花的时间最少的路径。", "hint": "#### 样例说明\n\n对于样例 $1$，输出这条路径花的时间最少，为 $2628$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$2 \\le M \\le N \\le 150$，$0 \\le V,L \\le 500$。\n\n#### 说明\n\n翻译自 [BalticOI 2002 Day1 A Speed Limits](https://boi.cses.fi/files/boi2002_day1.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2002] Speed Limits (Day1)", "background": "", "description": "您现在在一张 $N$ 点 $M$ 边的无向图的点 $0$ 处，这 $N$ 个点编号为 $0$ 到 $N-1$。\n\n每条边从 $A$ 连向 $B$，速度限制为 $V$，长度为 $L$，经过这条边的时间的算法如下：\n\n$$T=\\begin{cases}\\dfrac{L}{V}\\ (V\\ne 0)\\\\\\dfrac{L}{V_\\text{old}}\\ (V=0)\\end{cases}$$\n\n其中 $V_\\text{old}$ 为您经过的上一条边的 $V$ 的值，最开始 $V_\\text{old}=70$。\n\n如果 $V=0$，这条边的 $V$ 的值在计算完 $T$ 后更新为 $V_\\text{old}$，$V_\\text{old}$ 更新为 $V$。\n\n您先在要从点 $0$ 到点 $D$，求一条从 $0$ 到 $D$ 的路径使得花的时间最少。", "inputFormat": "第一行三个整数 $N,M,D$ 代表点数，边数和终点。     \n接下来 $M$ 行每行四个整数 $A,B,V,L$ 代表一条边。", "outputFormat": "一行若干个整数代表花的时间最少的路径。", "hint": "#### 样例说明\n\n对于样例 $1$，输出这条路径花的时间最少，为 $2628$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$2 \\le M \\le N \\le 150$，$0 \\le V,L \\le 500$。\n\n#### 说明\n\n翻译自 [BalticOI 2002 Day1 A Speed Limits](https://boi.cses.fi/files/boi2002_day1.pdf)。", "locale": "zh-CN"}}}
{"pid": "P7273", "type": "P", "difficulty": 4, "samples": [["6 1000\n1 2 999 4 72 6", "2"], ["10 2\n2 1 2 2 1 1 2 2 2 2", "3"], ["1 1\n1", "0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "O2优化", "剪枝"], "title": "ix35 的等差数列", "background": "等差数列是指从第二项起，每一项与它的前一项的差等于同一个常数的一种数列，并称这个常数为公差。特别地，认为只有一项的数列也是等差数列，其公差视为 $0$。", "description": "给定一包含 $n$ 项的正整数列 $a_1, a_2, \\ldots , a_n$，满足 $1 \\leq a_i \\leq w$。\n\n现可以进行若干次修改，一次修改可将数列的任意一项修改为任意 $\\leq w$ 的正整数。\n\n求：至少进行多少次修改，才能使得原数列变为一公差为非负整数的等差数列。", "inputFormat": "第一行两个整数 $n, w$。  \n接下来一行 $n$ 个整数 $a_1, a_2, \\ldots , a_n$。", "outputFormat": "一行一个整数，所求答案。", "hint": "**【样例解释 #1】**\n\n将 $a_3$ 修改为 $3$，$a_5$ 修改为 $5$。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（$20$ 分）：$n = 2$，$w = 2$。\n- Subtask 2（$20$ 分）：$n, w \\leq 100$。\n- Subtask 3（$10$ 分）：$a_i = 1$。\n- Subtask 4（$20$ 分）：$n, w \\leq 1000$。\n- Subtask 5（$30$ 分）：没有特殊限制。\n\n对于 $100 \\%$ 的数据，$1 \\leq n, w \\leq 3 \\times 10^5$。\n\n---\n\n原始 idea：ix35。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "ix35 的等差数列", "background": "等差数列是指从第二项起，每一项与它的前一项的差等于同一个常数的一种数列，并称这个常数为公差。特别地，认为只有一项的数列也是等差数列，其公差视为 $0$。", "description": "给定一包含 $n$ 项的正整数列 $a_1, a_2, \\ldots , a_n$，满足 $1 \\leq a_i \\leq w$。\n\n现可以进行若干次修改，一次修改可将数列的任意一项修改为任意 $\\leq w$ 的正整数。\n\n求：至少进行多少次修改，才能使得原数列变为一公差为非负整数的等差数列。", "inputFormat": "第一行两个整数 $n, w$。  \n接下来一行 $n$ 个整数 $a_1, a_2, \\ldots , a_n$。", "outputFormat": "一行一个整数，所求答案。", "hint": "**【样例解释 #1】**\n\n将 $a_3$ 修改为 $3$，$a_5$ 修改为 $5$。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 1（$20$ 分）：$n = 2$，$w = 2$。\n- Subtask 2（$20$ 分）：$n, w \\leq 100$。\n- Subtask 3（$10$ 分）：$a_i = 1$。\n- Subtask 4（$20$ 分）：$n, w \\leq 1000$。\n- Subtask 5（$30$ 分）：没有特殊限制。\n\n对于 $100 \\%$ 的数据，$1 \\leq n, w \\leq 3 \\times 10^5$。\n\n---\n\n原始 idea：ix35。", "locale": "zh-CN"}}}
{"pid": "P7274", "type": "P", "difficulty": 7, "samples": [["5 4\n1100\n1000\n0011\n0000\n0001", "1"], ["8 10\n0000000011\n0000000000\n0000000000\n0000000010\n0000000000\n0001010100\n0000000000\n0001000100", "3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化", "动态树 LCT", "整体二分"], "title": "草地", "background": "", "description": "给定一 $n \\times m$ 的网格，其中每个格子均有颜色，可以为黑色或白色。\n\n现可以进行若干次操作。一次操作中，你需选定上、下、左和右中的一个方向，然后，对于每个黑色的格子，若其指定方向上对应的位置不为网格的边界，则对应的那个格子变为黑色。\n\n求：至少进行几次操作，才能使任意两个黑色格子八连通。八连通的定义可参考【提示/说明】部分。", "inputFormat": "第一行两个整数 $n,m$（$1 \\leq n,m \\leq 10^3$），表示网格的大小。  \n接下来 $n$ 行，每行一个长为 $m$ 的 01 字符串，第 $i$ 个串的第 $j$ 位为 $1$ 则表示第 $i$ 行 $j$ 列的格子是黑色，否则是白色。", "outputFormat": "一行一个整数，最少的操作次数。", "hint": "----\n\n**【样例解释 #1】**\n\n对于第一组样例，一开始的网格如图（1）所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7amyon0v.png)\n\n（1）\n\n进行一次操作，选择下方向，网格会变为图（2）所示的样子（标红的是新变为黑色的格子），此时任意两个黑格都八连通。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9aszlhed.png)\n\n（2）\n\n----\n\n**【数据范围】**\n\n**本题采用捆绑测试**\n\n- Subtask 1（$10$ 分）：保证 $n, m\\leq 3$。\n- Subtask 2（$10$ 分）：保证 $n, m \\leq 80$。\n- Subtask 3（$5$ 分）：保证黑色格子的数量不超过 $20$。\n- Subtask 4（$5$ 分）：保证 $m = 1$。\n- Subtask 5（$25$ 分）：保证 $n, m \\leq 300$。\n- Subtask 6（$45$ 分）：没有特殊限制。\n\n对于 $100 \\%$ 的数据，保证 $1 \\leq n,m \\leq 10^3$，至少有一个黑色格子。\n\n**八连通的定义**\n\n两个黑色格子八连通，当且仅当在它们之间有公共顶点或公共边，或存在一个黑色格子同时与它们八连通。\n\n用比较通俗的话说，就是它们在只能向周围相邻的八个格子行走，且只能经过黑色格子的条件下相互可达。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "草地", "background": "", "description": "给定一 $n \\times m$ 的网格，其中每个格子均有颜色，可以为黑色或白色。\n\n现可以进行若干次操作。一次操作中，你需选定上、下、左和右中的一个方向，然后，对于每个黑色的格子，若其指定方向上对应的位置不为网格的边界，则对应的那个格子变为黑色。\n\n求：至少进行几次操作，才能使任意两个黑色格子八连通。八连通的定义可参考【提示/说明】部分。", "inputFormat": "第一行两个整数 $n,m$（$1 \\leq n,m \\leq 10^3$），表示网格的大小。  \n接下来 $n$ 行，每行一个长为 $m$ 的 01 字符串，第 $i$ 个串的第 $j$ 位为 $1$ 则表示第 $i$ 行 $j$ 列的格子是黑色，否则是白色。", "outputFormat": "一行一个整数，最少的操作次数。", "hint": "----\n\n**【样例解释 #1】**\n\n对于第一组样例，一开始的网格如图（1）所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7amyon0v.png)\n\n（1）\n\n进行一次操作，选择下方向，网格会变为图（2）所示的样子（标红的是新变为黑色的格子），此时任意两个黑格都八连通。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9aszlhed.png)\n\n（2）\n\n----\n\n**【数据范围】**\n\n**本题采用捆绑测试**\n\n- Subtask 1（$10$ 分）：保证 $n, m\\leq 3$。\n- Subtask 2（$10$ 分）：保证 $n, m \\leq 80$。\n- Subtask 3（$5$ 分）：保证黑色格子的数量不超过 $20$。\n- Subtask 4（$5$ 分）：保证 $m = 1$。\n- Subtask 5（$25$ 分）：保证 $n, m \\leq 300$。\n- Subtask 6（$45$ 分）：没有特殊限制。\n\n对于 $100 \\%$ 的数据，保证 $1 \\leq n,m \\leq 10^3$，至少有一个黑色格子。\n\n**八连通的定义**\n\n两个黑色格子八连通，当且仅当在它们之间有公共顶点或公共边，或存在一个黑色格子同时与它们八连通。\n\n用比较通俗的话说，就是它们在只能向周围相邻的八个格子行走，且只能经过黑色格子的条件下相互可达。", "locale": "zh-CN"}}}
{"pid": "P7275", "type": "P", "difficulty": 7, "samples": [["4", "4"], ["209", "21754876"], ["5", "11"], ["6", "56"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化"], "title": "计树", "background": "", "description": "求有多少不同的包含 $n$ 个点的有标号无根树，满足：对于任何一个点 $x$，都存在点 $y$ 使得 $x$ 和 $y$ 之间有一条边且 $|x - y| = 1$。答案对 $998244353$ 取模。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "一行一个整数，所求答案。", "hint": "**【样例解释 #1】**\n\n![无标题.png](https://i.loli.net/2020/12/28/1Cp3jLXaiOWmuPA.png)\n\n样例 #1 中符合题意的 $4$ 种树如上图所示。\n\n----\n\n**【数据范围】**\n\n本题包含 $20$ 个测试点，每个测试点 $5$ 分。\n\n| 测试点编号 | $n$ 的范围  |\n| :--------: | :---------: |\n|  $1 \\sim 2$  |  $\\leq 7$   |\n|  $3 \\sim 4$  |  $\\leq 14$  |\n|  $5 \\sim 8$  |  $\\leq 30$  |\n|  $9 \\sim 12$ | $\\leq 10^3$ |\n| $13 \\sim 20$ | $\\leq 10^5$ |\n\n对于所有测试点满足 $n$ 为正整数且 $2 \\leq n \\leq {10}^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "计树", "background": "", "description": "求有多少不同的包含 $n$ 个点的有标号无根树，满足：对于任何一个点 $x$，都存在点 $y$ 使得 $x$ 和 $y$ 之间有一条边且 $|x - y| = 1$。答案对 $998244353$ 取模。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "一行一个整数，所求答案。", "hint": "**【样例解释 #1】**\n\n![无标题.png](https://i.loli.net/2020/12/28/1Cp3jLXaiOWmuPA.png)\n\n样例 #1 中符合题意的 $4$ 种树如上图所示。\n\n----\n\n**【数据范围】**\n\n本题包含 $20$ 个测试点，每个测试点 $5$ 分。\n\n| 测试点编号 | $n$ 的范围  |\n| :--------: | :---------: |\n|  $1 \\sim 2$  |  $\\leq 7$   |\n|  $3 \\sim 4$  |  $\\leq 14$  |\n|  $5 \\sim 8$  |  $\\leq 30$  |\n|  $9 \\sim 12$ | $\\leq 10^3$ |\n| $13 \\sim 20$ | $\\leq 10^5$ |\n\n对于所有测试点满足 $n$ 为正整数且 $2 \\leq n \\leq {10}^5$。", "locale": "zh-CN"}}}
