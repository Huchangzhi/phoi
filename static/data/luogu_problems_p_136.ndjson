{"pid": "P3756", "type": "P", "difficulty": 7, "samples": [["2 2 4\n1 1 5 \n1 2 6 \n2 1 7 \n2 2 8 ", "5"], ["3 3 7 \n1 1 10 \n1 2 15 \n1 3 10 \n2 1 10 \n2 2 10 \n2 3 10 \n3 1 10 ", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "重庆", "各省省选", "网络流", "图论建模", "最小割"], "title": "[CQOI2017] 老C的方块", "background": "", "description": "老 C 是个程序员。\n\n作为一个懒惰的程序员，老 C 经常在电脑上玩方块游戏消磨时间。游戏被限定在一个由小方格排成的 $R$ 行 $C$ 列网格上，如果两个小方格有公共的边，就称它们是相邻的，而且有些相邻的小方格之间的公共边比较特殊。特殊的公共边排列得有很强的规律。首先规定，第 $1$ 行的前两个小方格之间的边是特殊边。然后，特殊边在水平方向上每 $4$ 个小方格为一个周期，在竖直方向上每 $2$ 个小方格为一个周期。所有的奇数列与下一列之间都有特殊边，且所在行的编号从左到右奇偶交替。\n\n下图所示是一个 $R=C=8$ 的网格，蓝色标注的边是特殊边。首先，在第 $1$ 行，第 $1$ 列和第 $2$ 列之间有一条特殊边。因为竖直方向周期为 $2$，所以所有的奇数行，第 $1$ 列和第 $2$ 列之间都有特殊边。因为水平方向周期为 $4$，所以所有奇数行的第 $5$ 列和第 $6$ 列之间也有特殊边，如果网格足够大，所有奇数行的第 $9$ 列和第 $10$ 列、第 $13$ 列和第 $14$ 列之间都有特殊边。因为所有的奇数列和下一列之间都有特殊边，所以第 $3$ 列和第 $4$ 列、第 $7$ 列和第 $8$ 列之间也有特殊边，而所在行的编号从左到右奇偶交替，所以它们的特殊边在偶数行。如果网格的规模更大，我们可以用同样的方法找出所有的特殊边。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5092.png) \n\n网格的每个小方格刚好可以放入一个小方块，在游戏的一开始，有些小方格已经放上了小方块，另外的小方格没有放。老 C 很讨厌下图所示的图形，如果他发现有一些小方块排列成了它讨厌的形状（特殊边的位置也要如图中所示），就很容易弃疗，即使是经过任意次旋转、翻转后排列成讨厌的形状，老 C 也同样容易弃疗。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5093.png) \n\n为了防止弃疗，老 C 决定趁自己还没有弃疗，赶紧移除一些格子里小方块，使得剩下的小方块不能构成它讨厌的形状。但是游戏里每移除一个方块都是要花费一些金币的，每个方块需要花费的金币有多有少参差不齐。老 C 当然希望尽可能少的使用游戏里的金币，但是最少要花费多少金币呢？老 C 懒得思考，就把这个问题交给你了。\n", "inputFormat": "第一行有 $3$ 个正整数 $C,R,n$，表示 $C$ 列 $R$ 行的网格中，有 $n$ 个小方格放了小方块。\n\n接下来 $n$ 行，每行 $3$ 个正整数 $x,y,w$，表示在第 $x$ 列第 $y$ 行的小方格里放了小方块，移除它需要花费 $w$ 个金币。保证不会重复，且都在网格范围内。\n", "outputFormat": "输出一行，包含一个整数，表示最少花费的金币数量。\n", "hint": "【输入输出样例 2 说明】 如图所示。容易发现，如果不移除第 $1$ 列第 $2$ 行的小方块，则至少要移除两个小方块，才能不包含老 C 讨厌的图形，花费至少 $20$ 个金币；而删除第 $1$ 列第 $2$ 行的小方块后，原有的讨厌图形全都不存在了，只需要花费 $15$ 个金币。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/5094.png) \n\n【数据规模与约定】\n\n对于第 $1\\sim 2$ 个测试点，$1\\le C, R \\le 100$，$1\\leq n \\leq 20$。\n\n对于第 $3\\sim 6$ 个测试点，$1 \\leq C, R\\leq 10^5$，$2000\\le n\\leq 5000$，数据有梯度。\n\n对于第 $7\\sim 10$ 个测试点，$1\\leq C, R\\leq 10^5$，$30000 \\leq n\\leq 10^5$，数据有梯度。\n\n对于所有测试点，$1 \\leq C, R, n \\leq 10^5$，$ 1 \\leq w \\leq 10^4$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2017] Old C's Blocks", "background": "", "description": "Old C (Lao C) is a programmer.\n\nAs a lazy programmer, Old C often plays a block game on his computer to kill time. The game is played on a grid with $R$ rows and $C$ columns of unit cells. Two cells are called adjacent if they share a side, and among adjacent pairs, some shared edges are marked as special. These special edges follow a very regular pattern. First, in row $1$, the edge between the first two cells is a special edge. Then, the special edges have period $4$ in the horizontal direction and period $2$ in the vertical direction. Between every odd-numbered column and the next column there are special edges, and the parity of the rows carrying these edges alternates from left to right.\n\nThe figure below shows a grid with $R = C = 8$, where the special edges are marked in blue. First, in row $1$, the edge between column $1$ and column $2$ is special. Because the vertical period is $2$, the edge between column $1$ and column $2$ is special in all odd-numbered rows. Because the horizontal period is $4$, the edge between column $5$ and column $6$ is also special in all odd-numbered rows; if the grid is large enough, so are the edges between columns $9$ and $10$, $13$ and $14$, etc. Because every odd-numbered column and the next column have special edges, the edges between columns $3$ and $4$, and between $7$ and $8$, are also special; since the row parity alternates from left to right, these special edges lie in even-numbered rows. If the grid is larger, we can find all special edges in the same way.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5092.png) \n\nEach cell can hold exactly one block. At the beginning of the game, some cells already contain blocks, while others are empty. Old C hates the pattern shown below. If he finds some blocks arranged in that hated shape (the positions of the special edges must also match those in the figure), he will immediately rage quit. Even if the hated shape appears after any number of rotations or reflections, he will still rage quit.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5093.png) \n\nTo avoid rage quitting, Old C decides to remove some blocks while he still can, so that the remaining blocks cannot form the hated shape. However, removing a block costs some coins, and the cost may differ from block to block. Of course, Old C wants to spend as few coins as possible. What is the minimum total number of coins needed? Old C is too lazy to think about it and leaves the problem to you.", "inputFormat": "The first line contains three positive integers $C, R, n$, meaning that in a grid with $C$ columns and $R$ rows, there are $n$ cells that contain blocks.\n\nEach of the next $n$ lines contains three positive integers $x, y, w$, meaning that the cell at column $x$, row $y$ contains a block, and removing it costs $w$ coins. All entries are distinct and within the grid.", "outputFormat": "Output one line containing a single integer, the minimum total number of coins required.", "hint": "[Explanation for Sample 2] As shown in the figure. It is easy to see that if we do not remove the block at column 1, row 2, then we must remove at least two blocks to avoid containing the hated shape, costing at least 20 coins; whereas after deleting the block at column 1, row 2, all existing hated shapes disappear, and we only need to spend 15 coins.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5094.png) \n\nConstraints\n\nFor test points $1 \\sim 2$, $1 \\leq C, R \\leq 100$, $1 \\leq n \\leq 20$.\n\nFor test points $3 \\sim 6$, $1 \\leq C, R \\leq 10^5$, $2000 \\leq n \\leq 5000$, with graded testdata.\n\nFor test points $7 \\sim 10$, $1 \\leq C, R \\leq 10^5$, $30000 \\leq n \\leq 10^5$, with graded testdata.\n\nFor all test points, $1 \\leq C, R, n \\leq 10^5$, $1 \\leq w \\leq 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2017] 老C的方块", "background": "", "description": "老 C 是个程序员。\n\n作为一个懒惰的程序员，老 C 经常在电脑上玩方块游戏消磨时间。游戏被限定在一个由小方格排成的 $R$ 行 $C$ 列网格上，如果两个小方格有公共的边，就称它们是相邻的，而且有些相邻的小方格之间的公共边比较特殊。特殊的公共边排列得有很强的规律。首先规定，第 $1$ 行的前两个小方格之间的边是特殊边。然后，特殊边在水平方向上每 $4$ 个小方格为一个周期，在竖直方向上每 $2$ 个小方格为一个周期。所有的奇数列与下一列之间都有特殊边，且所在行的编号从左到右奇偶交替。\n\n下图所示是一个 $R=C=8$ 的网格，蓝色标注的边是特殊边。首先，在第 $1$ 行，第 $1$ 列和第 $2$ 列之间有一条特殊边。因为竖直方向周期为 $2$，所以所有的奇数行，第 $1$ 列和第 $2$ 列之间都有特殊边。因为水平方向周期为 $4$，所以所有奇数行的第 $5$ 列和第 $6$ 列之间也有特殊边，如果网格足够大，所有奇数行的第 $9$ 列和第 $10$ 列、第 $13$ 列和第 $14$ 列之间都有特殊边。因为所有的奇数列和下一列之间都有特殊边，所以第 $3$ 列和第 $4$ 列、第 $7$ 列和第 $8$ 列之间也有特殊边，而所在行的编号从左到右奇偶交替，所以它们的特殊边在偶数行。如果网格的规模更大，我们可以用同样的方法找出所有的特殊边。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5092.png) \n\n网格的每个小方格刚好可以放入一个小方块，在游戏的一开始，有些小方格已经放上了小方块，另外的小方格没有放。老 C 很讨厌下图所示的图形，如果他发现有一些小方块排列成了它讨厌的形状（特殊边的位置也要如图中所示），就很容易弃疗，即使是经过任意次旋转、翻转后排列成讨厌的形状，老 C 也同样容易弃疗。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5093.png) \n\n为了防止弃疗，老 C 决定趁自己还没有弃疗，赶紧移除一些格子里小方块，使得剩下的小方块不能构成它讨厌的形状。但是游戏里每移除一个方块都是要花费一些金币的，每个方块需要花费的金币有多有少参差不齐。老 C 当然希望尽可能少的使用游戏里的金币，但是最少要花费多少金币呢？老 C 懒得思考，就把这个问题交给你了。\n", "inputFormat": "第一行有 $3$ 个正整数 $C,R,n$，表示 $C$ 列 $R$ 行的网格中，有 $n$ 个小方格放了小方块。\n\n接下来 $n$ 行，每行 $3$ 个正整数 $x,y,w$，表示在第 $x$ 列第 $y$ 行的小方格里放了小方块，移除它需要花费 $w$ 个金币。保证不会重复，且都在网格范围内。\n", "outputFormat": "输出一行，包含一个整数，表示最少花费的金币数量。\n", "hint": "【输入输出样例 2 说明】 如图所示。容易发现，如果不移除第 $1$ 列第 $2$ 行的小方块，则至少要移除两个小方块，才能不包含老 C 讨厌的图形，花费至少 $20$ 个金币；而删除第 $1$ 列第 $2$ 行的小方块后，原有的讨厌图形全都不存在了，只需要花费 $15$ 个金币。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/5094.png) \n\n【数据规模与约定】\n\n对于第 $1\\sim 2$ 个测试点，$1\\le C, R \\le 100$，$1\\leq n \\leq 20$。\n\n对于第 $3\\sim 6$ 个测试点，$1 \\leq C, R\\leq 10^5$，$2000\\le n\\leq 5000$，数据有梯度。\n\n对于第 $7\\sim 10$ 个测试点，$1\\leq C, R\\leq 10^5$，$30000 \\leq n\\leq 10^5$，数据有梯度。\n\n对于所有测试点，$1 \\leq C, R, n \\leq 10^5$，$ 1 \\leq w \\leq 10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P3757", "type": "P", "difficulty": 6, "samples": [["5 <>><", "3"], ["5 <<<<", "8"], ["5 <<>>", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2017", "重庆", "线段树", "各省省选", "树形 DP", "前缀和"], "title": "[CQOI2017] 老C的键盘", "background": "", "description": "老 C 是个程序员。\n\n作为一个优秀的程序员，老 C 拥有一个别具一格的键盘，据说这样可以大幅提升写程序的速度，还能让写出来的程序在某种神奇力量的驱使之下跑得非常快。\n\n小 Q 也是一个程序员。有一天他悄悄潜入了老 C 的家中，想要看看这个键盘究竟有何妙处。他发现，这个键盘共有 $n$ 个按键，这 $n$ 个按键虽然整齐的排成一列，但是每个键的高度却互不相同。聪明的小 Q 马上将每个键的高度用 $1 \\sim n$ 的整数表示了出来，得到一个 $1 \\sim n$ 的排列 $h_1,h_2, \\cdots ,h_n$。\n\n为了回去之后可以仿造一个新键盘（新键盘每个键的高度也是一个 $1 \\sim n$ 的排列），又不要和老 C 的键盘完全一样，小 Q 决定记录下若干对按键的高度关系。作为一个程序员，小 Q 当然不会随便选几对就记下来，而是选了非常有规律的一些按键对：对于 $i=2,3, \\cdots ,n$，小 Q 都记录下了一个字符 `<` 或者 `>`，表示 $h_{\\frac i2}<h_i$ 或者$h_{\\frac i2}>h_i$。于是，小 Q 得到了一个长度为 $n-1$ 的字符串，开开心心的回家了。\n\n现在，小 Q 想知道满足他所记录的高度关系的键盘有多少个。虽然小 Q 不希望自己的键盘和老 C 的完全相同，但是完全相同也算一个满足要求的键盘。答案可能很大，你只需要告诉小 Q 答案 $\\bmod ~ 1,000,000,007$ 之后的结果即可。\n", "inputFormat": "输入共一行，包含一个正整数 $n$ 和一个长度为 $n - 1$ 的只包含 `<` 和 `>` 的字符串，分别表示键盘上按键的数量，和小 Q 记录的信息，整数和字符串之间有一个空格间隔。\n", "outputFormat": "输出共一行，包含一个整数，表示答案 $\\bmod      ~ 1,000,000,007$ 后的结果。\n", "hint": "\n\n![](https://cdn.luogu.com.cn/upload/pic/5095.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2017] Lao C's Keyboard", "background": "", "description": "Lao C is a programmer.\n\nAs an excellent programmer, Lao C owns a distinctive keyboard, which is said to greatly increase the speed of writing programs and, driven by some mysterious power, make the programs run very fast.\n\nLittle Q is also a programmer. One day he sneaked into Lao C's home to see what was so special about the keyboard. He found that the keyboard has $n$ keys. Although these $n$ keys are neatly arranged in a single row, the height of each key is different. The clever Little Q immediately represented the height of each key with the integers $1 \\sim n$, obtaining a permutation $h_1, h_2, \\cdots , h_n$ of $1 \\sim n$.\n\nIn order to later build an imitation keyboard (the heights of its keys also form a permutation of $1 \\sim n$), and also to avoid being exactly the same as Lao C's keyboard, Little Q decided to record several pairs of height relations between keys. As a programmer, Little Q of course did not just pick a few pairs at random, but chose them in a very regular way: for $i=2,3, \\cdots ,n$, Little Q recorded a character '<' or '>', indicating $h_{\\frac i2}<h_i$ or $h_{\\frac i2}>h_i$. Thus, Little Q obtained a string of length $n-1$ and happily went home.\n\nNow Little Q wants to know how many keyboards satisfy the height relations he recorded. Although Little Q does not want his keyboard to be completely identical to Lao C's, the completely identical one also counts as satisfying the requirement. The answer may be large; you only need to tell Little Q the result modulo $1,000,000,007$.", "inputFormat": "The input consists of a single line containing a positive integer $n$ and a string of length $n - 1$ consisting only of '<' and '>', representing the number of keys on the keyboard and the information recorded by Little Q, separated by a space.", "outputFormat": "Output a single line containing an integer, the answer modulo $1,000,000,007$.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/5095.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2017] 老C的键盘", "background": "", "description": "老 C 是个程序员。\n\n作为一个优秀的程序员，老 C 拥有一个别具一格的键盘，据说这样可以大幅提升写程序的速度，还能让写出来的程序在某种神奇力量的驱使之下跑得非常快。\n\n小 Q 也是一个程序员。有一天他悄悄潜入了老 C 的家中，想要看看这个键盘究竟有何妙处。他发现，这个键盘共有 $n$ 个按键，这 $n$ 个按键虽然整齐的排成一列，但是每个键的高度却互不相同。聪明的小 Q 马上将每个键的高度用 $1 \\sim n$ 的整数表示了出来，得到一个 $1 \\sim n$ 的排列 $h_1,h_2, \\cdots ,h_n$。\n\n为了回去之后可以仿造一个新键盘（新键盘每个键的高度也是一个 $1 \\sim n$ 的排列），又不要和老 C 的键盘完全一样，小 Q 决定记录下若干对按键的高度关系。作为一个程序员，小 Q 当然不会随便选几对就记下来，而是选了非常有规律的一些按键对：对于 $i=2,3, \\cdots ,n$，小 Q 都记录下了一个字符 `<` 或者 `>`，表示 $h_{\\frac i2}<h_i$ 或者$h_{\\frac i2}>h_i$。于是，小 Q 得到了一个长度为 $n-1$ 的字符串，开开心心的回家了。\n\n现在，小 Q 想知道满足他所记录的高度关系的键盘有多少个。虽然小 Q 不希望自己的键盘和老 C 的完全相同，但是完全相同也算一个满足要求的键盘。答案可能很大，你只需要告诉小 Q 答案 $\\bmod ~ 1,000,000,007$ 之后的结果即可。\n", "inputFormat": "输入共一行，包含一个正整数 $n$ 和一个长度为 $n - 1$ 的只包含 `<` 和 `>` 的字符串，分别表示键盘上按键的数量，和小 Q 记录的信息，整数和字符串之间有一个空格间隔。\n", "outputFormat": "输出共一行，包含一个整数，表示答案 $\\bmod      ~ 1,000,000,007$ 后的结果。\n", "hint": "\n\n![](https://cdn.luogu.com.cn/upload/pic/5095.png)\n", "locale": "zh-CN"}}}
{"pid": "P3758", "type": "P", "difficulty": 4, "samples": [["3 2\n1 2\n2 3\n2", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2017", "倍增", "各省省选", "矩阵加速", "天津"], "title": "[TJOI2017] 可乐", "background": "", "description": "加里敦星球的人们特别喜欢喝可乐。因而，他们的敌对星球研发出了一个可乐机器人，并且放在了加里敦星球的 $1$ 号城市上。这个可乐机器人有三种行为： 停在原地，去下一个相邻的城市，自爆。它每一秒都会随机触发一种行为。现在给加里敦星球城市图，在第 $0$ 秒时可乐机器人在 $1$ 号城市，问经过了 $t$ 秒，可乐机器人的行为方案数是多少？\n", "inputFormat": "第一行输入两个正整数 $N$，$M$。$N$ 表示城市个数，$M$ 表示道路个数。\n\n接下来 $M$ 行每行两个整数 $u$，$v$，表示 $u$，$v$ 之间有一条道路。保证两座城市之间只有一条路相连，且没有任何一条道路连接两个相同的城市。\n\n最后一行是一个整数 $t$，表示经过的时间。", "outputFormat": "输出可乐机器人的行为方案数，答案可能很大，请输出对 $2017$ 取模后的结果。", "hint": "#### 样例输入输出 1 解释\n\n\n- $1$ ->爆炸。\n- $1$ -> $1$ ->爆炸。\n- $1$ -> $2$ ->爆炸。\n- $1$ -> $1$ -> $1$。\n- $1$ -> $1$ -> $2$。\n- $1$ -> $2$ -> $1$。\n- $1$ -> $2$ -> $2$。\n- $1$ -> $2$ -> $3$。\n\n---\n\n#### 数据范围与约定\n\n- 对于 $20\\%$ 的数据，保证 $t \\leq 1000$。\n- 对于$100\\%$的数据，保证 $1 < t \\leq 10^6$，$1 \\leq N \\leq30$，$0 < M < 100$，$1 \\leq u, v \\leq N$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2017] Cola", "background": "", "description": "The people on the planet Jialidun (pinyin) love drinking cola. Therefore, their enemy planet developed a cola robot and placed it in city $1$ of planet Jialidun. This cola robot has three possible actions: stay where it is, go to an adjacent city, or self-destruct. Every second, it randomly triggers one of these actions. Given the city graph of planet Jialidun, and that at time $0$ the cola robot is in city $1$, after $t$ seconds, how many behavior sequences could the cola robot have?", "inputFormat": "The first line contains two positive integers $N$, $M$. $N$ is the number of cities, and $M$ is the number of roads.\nThen $M$ lines follow, each containing two integers $u$, $v$, indicating there is a road between $u$ and $v$. There is at most one road between any pair of cities, and no road connects a city to itself.\nThe last line contains an integer $t$, the elapsed time.", "outputFormat": "Output the number of behavior sequences of the cola robot. Since the answer can be large, output the result modulo $2017$.", "hint": "#### Sample Input/Output 1 Explanation\n\n- $1$ -> self-destructs.\n- $1$ -> $1$ -> self-destructs.\n- $1$ -> $2$ -> self-destructs.\n- $1$ -> $1$ -> $1$.\n- $1$ -> $1$ -> $2$.\n- $1$ -> $2$ -> $1$.\n- $1$ -> $2$ -> $2$.\n- $1$ -> $2$ -> $3$.\n\n---\n\n#### Constraints\n\n- For $20\\%$ of the testdata, $t \\leq 1000$.\n- For $100\\%$ of the testdata, $1 < t \\leq 10^6$, $1 \\leq N \\leq 30$, $0 < M < 100$, $1 \\leq u, v \\leq N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2017] 可乐", "background": "", "description": "加里敦星球的人们特别喜欢喝可乐。因而，他们的敌对星球研发出了一个可乐机器人，并且放在了加里敦星球的 $1$ 号城市上。这个可乐机器人有三种行为： 停在原地，去下一个相邻的城市，自爆。它每一秒都会随机触发一种行为。现在给加里敦星球城市图，在第 $0$ 秒时可乐机器人在 $1$ 号城市，问经过了 $t$ 秒，可乐机器人的行为方案数是多少？\n", "inputFormat": "第一行输入两个正整数 $N$，$M$。$N$ 表示城市个数，$M$ 表示道路个数。\n\n接下来 $M$ 行每行两个整数 $u$，$v$，表示 $u$，$v$ 之间有一条道路。保证两座城市之间只有一条路相连，且没有任何一条道路连接两个相同的城市。\n\n最后一行是一个整数 $t$，表示经过的时间。", "outputFormat": "输出可乐机器人的行为方案数，答案可能很大，请输出对 $2017$ 取模后的结果。", "hint": "#### 样例输入输出 1 解释\n\n\n- $1$ ->爆炸。\n- $1$ -> $1$ ->爆炸。\n- $1$ -> $2$ ->爆炸。\n- $1$ -> $1$ -> $1$。\n- $1$ -> $1$ -> $2$。\n- $1$ -> $2$ -> $1$。\n- $1$ -> $2$ -> $2$。\n- $1$ -> $2$ -> $3$。\n\n---\n\n#### 数据范围与约定\n\n- 对于 $20\\%$ 的数据，保证 $t \\leq 1000$。\n- 对于$100\\%$的数据，保证 $1 < t \\leq 10^6$，$1 \\leq N \\leq30$，$0 < M < 100$，$1 \\leq u, v \\leq N$。", "locale": "zh-CN"}}}
{"pid": "P3759", "type": "P", "difficulty": 6, "samples": [["5 5\n1 1\n2 2\n3 3\n4 4\n5 5\n1 5\n1 5\n2 4\n5 3\n1 3", "42\n0\n18\n28\n48"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2017", "线段树", "各省省选", "cdq 分治", "枚举", "树套树", "天津"], "title": "[TJOI2017] 不勤劳的图书管理员", "background": "", "description": "加里敦大学有个帝国图书馆，小豆是图书馆阅览室的一个书籍管理员。\n\n他的任务是把书排成有序的，所以无序的书让他产生厌烦。\n\n两本乱序的书会让小豆产生这两本书页数的和的厌烦度。\n\n现在有 $n$ 本被打乱顺序的书，在接下来 $m$ 天中每天都会因为读者的阅览导致书籍顺序改变位置。\n\n因为小豆被要求在接下来的 $m$ 天中至少要整理一次图书。\n\n小豆想知道，如果他前 $i$ 天不去整理，第 $i$ 天他的厌烦度是多少，这样他好选择厌烦度最小的那天去整理。", "inputFormat": "第一行会有两个数，$n,m$ 分别表示有 $n$ 本书，$m$ 天。\n\n接下来 $n$ 行，每行两个数，$a_i,v_i$，分别表示第 $i$ 本书本来应该放在 $a_i$ 的位置，这本书有 $v_i$ 页，保证不会有放置同一个位置的书。\n\n接下来 $m$ 行，每行两个数，$x_j$ 和 $y_j$，表示在第 $j$ 天的第 $x_j$ 本书会和第 $y_j$ 本书会因为读者阅读交换位置。", "outputFormat": "一共 $m$ 行，每行一个数，第 $i$ 行表示前 $i$ 天不去整理，第 $i$ 天小豆的厌烦度，因为这个数可能很大，所以将结果模 $10^9 +7$ 后输出。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，$1\\le a_i,x_j,y_j\\le n \\le 5\\times 10^3$，$1\\le m\\le 5\\times 10^3$， $1\\le v_i\\le10^5$。\n- 对于 $100\\%$ 的数据，$1\\le a_i,x_j,y_j\\le n\\le 5\\times 10^4$，$1\\le m\\le 5\\times 10^4$，$1\\le v_i\\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2017] The Lazy Librarian", "background": "", "description": "At Jialidun University, there is an Imperial Library. Xiao Dou is a librarian in the library’s reading room.\nHis job is to keep the books in order, so disorder annoys him.\nA pair of books that are out of order causes an annoyance equal to the sum of their page counts.\nThere are $n$ books currently in a jumbled order. During the next $m$ days, readers’ use will cause the books’ positions to change each day.\nXiao Dou is required to tidy the books at least once during these $m$ days.\nHe wants to know, if he does not tidy during the first $i$ days, what his annoyance will be on day $i$, so that he can choose the day with the minimum annoyance to tidy.", "inputFormat": "The first line contains two integers $n,m$, denoting $n$ books and $m$ days.\nThe next $n$ lines each contain two integers $a_i,v_i$, meaning that book $i$ should be placed at position $a_i$, and this book has $v_i$ pages. It is guaranteed that no two books have the same intended position.\nThe next $m$ lines each contain two integers $x_j$ and $y_j$, meaning that on day $j$, book $x_j$ and book $y_j$ swap positions due to readers’ usage.", "outputFormat": "Output $m$ lines. The $i$-th line is the annoyance on day $i$ if he does not tidy during the first $i$ days. Since this number can be large, output the result modulo $10^9 +7$.", "hint": "#### Constraints\n\n- For $20\\%$ of the testdata, $1\\le a_i,x_j,y_j\\le n \\le 5\\times 10^3$, $1\\le m\\le 5\\times 10^3$, $1\\le v_i\\le10^5$.\n- For $100\\%$ of the testdata, $1\\le a_i,x_j,y_j\\le n\\le 5\\times 10^4$, $1\\le m\\le 5\\times 10^4$, $1\\le v_i\\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2017] 不勤劳的图书管理员", "background": "", "description": "加里敦大学有个帝国图书馆，小豆是图书馆阅览室的一个书籍管理员。\n\n他的任务是把书排成有序的，所以无序的书让他产生厌烦。\n\n两本乱序的书会让小豆产生这两本书页数的和的厌烦度。\n\n现在有 $n$ 本被打乱顺序的书，在接下来 $m$ 天中每天都会因为读者的阅览导致书籍顺序改变位置。\n\n因为小豆被要求在接下来的 $m$ 天中至少要整理一次图书。\n\n小豆想知道，如果他前 $i$ 天不去整理，第 $i$ 天他的厌烦度是多少，这样他好选择厌烦度最小的那天去整理。", "inputFormat": "第一行会有两个数，$n,m$ 分别表示有 $n$ 本书，$m$ 天。\n\n接下来 $n$ 行，每行两个数，$a_i,v_i$，分别表示第 $i$ 本书本来应该放在 $a_i$ 的位置，这本书有 $v_i$ 页，保证不会有放置同一个位置的书。\n\n接下来 $m$ 行，每行两个数，$x_j$ 和 $y_j$，表示在第 $j$ 天的第 $x_j$ 本书会和第 $y_j$ 本书会因为读者阅读交换位置。", "outputFormat": "一共 $m$ 行，每行一个数，第 $i$ 行表示前 $i$ 天不去整理，第 $i$ 天小豆的厌烦度，因为这个数可能很大，所以将结果模 $10^9 +7$ 后输出。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，$1\\le a_i,x_j,y_j\\le n \\le 5\\times 10^3$，$1\\le m\\le 5\\times 10^3$， $1\\le v_i\\le10^5$。\n- 对于 $100\\%$ 的数据，$1\\le a_i,x_j,y_j\\le n\\le 5\\times 10^4$，$1\\le m\\le 5\\times 10^4$，$1\\le v_i\\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3760", "type": "P", "difficulty": 5, "samples": [["3\n1 2 3", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "各省省选", "树状数组", "进制", "前缀和", "天津"], "title": "[TJOI2017] 异或和", "background": "", "description": "在加里敦中学的小明最近爱上了数学竞赛，很多数学竞赛的题都是与序列的连续和相关的。  所以对于一个序列，求出它们所有的连续和来说，小明觉得十分的简单。  \n\n但今天小明遇到了一个序列和的难题，这个题目不仅要求你快速的求出所有的连续和（即子串和），还要快速的求出这些连续和的异或值。  \n\n小明很快的就求出了所有的连续和，但是小明要考考你，在不告诉连续和的情况下，让你快速求是序列所有连续和的异或值。\n", "inputFormat": "第一行输入一个 $n$，表示这序列的数序列。\n\n第二行输入 $n$ 个非负整数 $a_1,a_2 \\dots a_n$ 代表这个序列。", "outputFormat": "输出这个序列所有的连续和的异或值。\n", "hint": "【样例解释】\n\n序列 $[1,2,3]$ 有 $6$ 个连续和，它们分别是 $1,2,3,3,5,6$，而 $1 \\text{ xor } 2 \\text{ xor } 3 \\text{ xor } 3 \\text{ xor } 5 \\text{ xor } 6 = 0$。\n\n【数据范围】\n\n- 对于 $20\\%$ 的数据，$1\\le n \\le 100$；\n- 对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$\\sum a_i \\le 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2017] XOR Sum", "background": "", "description": "Xiao Ming from Garidon High School has recently fallen in love with math contests. Many problems are related to the sums of contiguous segments of a sequence. For a sequence, computing all of its contiguous sums (i.e., subarray sums) is very easy for Xiao Ming.\n\nBut today he encountered a tougher problem: not only do you need to quickly obtain all subarray sums, you also need to quickly compute the XOR of these sums.\n\nXiao Ming has already computed all subarray sums. However, without telling you these sums, he challenges you to quickly compute the XOR of all subarray sums of the sequence.", "inputFormat": "The first line contains an integer $n$, indicating the length of the sequence.\n\nThe second line contains $n$ non-negative integers $a_1, a_2 \\dots a_n$ representing the sequence.", "outputFormat": "Output the XOR of all subarray sums of the sequence.", "hint": "Sample Explanation:\n\nThe sequence [1, 2, 3] has 6 subarray sums: 1, 2, 3, 3, 5, 6, and $1 \\text{ xor } 2 \\text{ xor } 3 \\text{ xor } 3 \\text{ xor } 5 \\text{ xor } 6 = 0$.\n\nConstraints:\n\n- For $20\\%$ of the testdata, $1 \\le n \\le 100$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $\\sum a_i \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2017] 异或和", "background": "", "description": "在加里敦中学的小明最近爱上了数学竞赛，很多数学竞赛的题都是与序列的连续和相关的。  所以对于一个序列，求出它们所有的连续和来说，小明觉得十分的简单。  \n\n但今天小明遇到了一个序列和的难题，这个题目不仅要求你快速的求出所有的连续和（即子串和），还要快速的求出这些连续和的异或值。  \n\n小明很快的就求出了所有的连续和，但是小明要考考你，在不告诉连续和的情况下，让你快速求是序列所有连续和的异或值。\n", "inputFormat": "第一行输入一个 $n$，表示这序列的数序列。\n\n第二行输入 $n$ 个非负整数 $a_1,a_2 \\dots a_n$ 代表这个序列。", "outputFormat": "输出这个序列所有的连续和的异或值。\n", "hint": "【样例解释】\n\n序列 $[1,2,3]$ 有 $6$ 个连续和，它们分别是 $1,2,3,3,5,6$，而 $1 \\text{ xor } 2 \\text{ xor } 3 \\text{ xor } 3 \\text{ xor } 5 \\text{ xor } 6 = 0$。\n\n【数据范围】\n\n- 对于 $20\\%$ 的数据，$1\\le n \\le 100$；\n- 对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$\\sum a_i \\le 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P3761", "type": "P", "difficulty": 5, "samples": [["5\n1 2 1\n2 3 2\n3 4 3\n4 5 4", "7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "各省省选", "枚举", "树的直径", "天津"], "title": "[TJOI2017] 城市", "background": null, "description": "从加里敦大学城市规划专业毕业的小明来到了一个地区城市规划局工作。这个地区一共有 $n$ 座城市，$n-1$ 条高速公路，保证了任意两座城市之间都可以通过高速公路相互可达，但是通过一条高速公路需要收取一定的交通费用。小明对这个地区深入研究后，觉得这个地区的交通费用太贵。\n\n小明想彻底改造这个地区，但是由于上司给他的资源有限，因而小明现在只能对一条高速公路进行改造，改造的方式就是去掉一条高速公路，并且重新修建一条一样的高速公路（即交通费用一样），使得这个地区的两个城市之间的最大交通费用最小（即使得交通费用最大的两座城市之间的交通费用最小），并且保证修建完之后任意两座城市相互可达。如果你是小明，你怎么解决这个问题？", "inputFormat": "输入数据的第一行为一个整数 $n$，代表城市个数。\n\n接下来的 $n - 1$ 行分别代表了最初的 $n-1$ 条公路情况。每一行都有三个整数 $u,v,d$。$u,v$ 代表这条公路的两端城市标号，$d$ 代表这条公路的交通费用。\n\n$1 \\leq u,v \\leq n$，$1\\leq d \\leq 2000$。", "outputFormat": "输出数据仅有一行，一个整数，表示进行了最优的改造之后，该地区两城市 之间最大交通费用。", "hint": "对于 $30\\%$ 的数据，$1\\leq n\\leq 500$。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 5000$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2017] City", "background": "", "description": "After graduating from the Urban Planning program at Gariton University, Xiao Ming joined a regional Urban Planning Bureau. This region has $n$ cities and $n-1$ highways, ensuring that any two cities are mutually reachable via highways. However, traveling through a highway requires paying a transportation cost. After careful study, Xiao Ming thinks the transportation cost in this region is too high.\n\nXiao Ming wants to completely overhaul the region, but due to limited resources from his supervisor, he can only modify exactly one highway. The modification is to remove one highway and rebuild one identical highway (i.e., with the same transportation cost), so that the maximum transportation cost between any two cities is minimized (that is, the transportation cost between the pair of cities with the largest cost is as small as possible), and it must still be guaranteed that any two cities remain mutually reachable after reconstruction. If you were Xiao Ming, how would you solve this problem?", "inputFormat": "The first line contains an integer $n$, the number of cities.\n\nThe next $n-1$ lines describe the initial $n-1$ highways. Each line contains three integers $u, v, d$. Here $u, v$ are the labels of the two endpoint cities of this highway, and $d$ is its transportation cost.\n\n$1 \\leq u, v \\leq n$, $1 \\leq d \\leq 2000$.", "outputFormat": "Output a single integer: after the optimal reconstruction, the maximum transportation cost between any two cities.", "hint": "For 30% of the testdata, $1 \\leq n \\leq 500$.\n\nFor 100% of the testdata, $1 \\leq n \\leq 5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2017] 城市", "background": null, "description": "从加里敦大学城市规划专业毕业的小明来到了一个地区城市规划局工作。这个地区一共有 $n$ 座城市，$n-1$ 条高速公路，保证了任意两座城市之间都可以通过高速公路相互可达，但是通过一条高速公路需要收取一定的交通费用。小明对这个地区深入研究后，觉得这个地区的交通费用太贵。\n\n小明想彻底改造这个地区，但是由于上司给他的资源有限，因而小明现在只能对一条高速公路进行改造，改造的方式就是去掉一条高速公路，并且重新修建一条一样的高速公路（即交通费用一样），使得这个地区的两个城市之间的最大交通费用最小（即使得交通费用最大的两座城市之间的交通费用最小），并且保证修建完之后任意两座城市相互可达。如果你是小明，你怎么解决这个问题？", "inputFormat": "输入数据的第一行为一个整数 $n$，代表城市个数。\n\n接下来的 $n - 1$ 行分别代表了最初的 $n-1$ 条公路情况。每一行都有三个整数 $u,v,d$。$u,v$ 代表这条公路的两端城市标号，$d$ 代表这条公路的交通费用。\n\n$1 \\leq u,v \\leq n$，$1\\leq d \\leq 2000$。", "outputFormat": "输出数据仅有一行，一个整数，表示进行了最优的改造之后，该地区两城市 之间最大交通费用。", "hint": "对于 $30\\%$ 的数据，$1\\leq n\\leq 500$。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 5000$。", "locale": "zh-CN"}}}
{"pid": "P3762", "type": "P", "difficulty": 6, "samples": [["2 3 3\n5 2 3\n3 2 3\n2 3 2\n1 4\n2 4\n1 7", "3\n-1\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 5000, 5000, 5000, 5000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "各省省选", "天津"], "title": "[TJOI2017] 龙舟", "background": "", "description": "加里敦大学有一个龙舟队，龙舟队有 $n$ 支队伍，每只队伍有 $m$ 个划手。龙舟比赛是一个集体项目，和每个人的能力息息相关，但由于龙舟讲究配合，所以评价队伍的能力的是一个值 $C=\\frac{b_1 \\times b_2 \\times \\cdots \\times b_m}{a_1 \\times a_2 \\times \\cdots \\times a_m}$，其中 $b_i$ 表示第 $i$ 个位置的标准能力值，$a_i$ 表示在队伍中第 $i$ 个位置的划手的能力值。最后通过约分，我们会得到 $C=\\frac{B}{A}$，其中 $\\gcd(B,A)=1$，即 $A,B$ 互质。\n\n但是由于比赛现场的情况不一样，我们认为在现场压力为 $M$ 的情况下，队伍最后的表现情况是 $C^{-1}\\mod M$。我们规定在模 $M$ 的条件下 $\\frac{1}{x}=y$，其中 $y$ 满足 $xy \\equiv 1\\pmod M$，并且 $y$ 大于等于 $0$ 小于 $M$。如果不存在这样的 $y$ 我们就认为在压力为 $M$ 的条件下这支队伍会发挥失常（即 $y$ 是 $x$ 在模 $M$ 意义下的逆元，如果不存在逆元我们认为队伍发挥失常）。给出这个赛季的比赛安排情况，现在教练组想知道各队在比赛中的表现情况。", "inputFormat": "\n第一行输入三个整数 $n,m,k$，表示有 $n$ 支队伍，每支队伍由 $m$ 个人组成，有 $k$ 场比赛。\n\n第二行输入 $m$ 个整数，第 $i$ 个整数表示第 $i$ 个位置的标准能力值为 $b_i$。\n\n第三行到第 $n+2$ 行，共 $n$ 行，每行有 $m$ 个数，第 $2+i$ 行第 $j$ 个数表示第 $i$ 支队伍第 $j$ 个位置划手的能力值。\n\n第 $n+3$ 行到第 $n+k+2$ 行，共 $k$ 行，每行有两个数 $x,M$，分别表示第 $x$ 支队伍会在压力为 $M$ 的比赛中出战。", "outputFormat": "共 $k$ 行，第 $i$ 行表示在第 $i$ 个参赛安排中队伍的现场表现情况 $C$，如果出现队伍发挥失常，输出 `-1`。", "hint": "对于 $20\\%$ 的数据，$1<M,a_i,b_i<10^8$，$m \\le 100$。\n\n对于 $100\\%$ 的数据，$1<M,a_i,b_i<2 \\times 10^{18}$，$m \\le 10000$，$n \\le 20$，$k \\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2017] Dragon Boat", "background": "# Description\n\nJialidun University has a dragon boat club with $n$ teams, each consisting of $m$ paddlers. Dragon boat racing is a team sport, and while it depends on each individual’s ability, coordination is crucial. Therefore, the ability of a team is evaluated by the value $C=\\frac{b_1 \\times b_2 \\times \\cdots \\times b_m}{a_1 \\times a_2 \\times \\cdots \\times a_m}$, where $b_i$ is the standard ability value for position $i$, and $a_i$ is the ability value of the paddler in position $i$ in the team. After cancellation, we obtain $C=\\frac{B}{A}$ with $\\gcd(B,A)=1$, i.e., $A$ and $B$ are coprime.\n\nHowever, due to varying conditions at the venue, we consider that under pressure $M$, the team’s final performance is $C^{-1} \\bmod M$. We define that under modulo $M$, $\\frac{1}{x}=y$, where $y$ satisfies $xy \\equiv 1\\pmod M$ and $0 \\le y < M$. If no such $y$ exists, we say the team will underperform under pressure $M$ (that is, $y$ is the modular inverse of $x$ modulo $M$; if the inverse does not exist, the team underperforms). Given this season’s schedule, the coaching staff wants to know each team’s performance in the matches.", "description": "", "inputFormat": "", "outputFormat": "Output $k$ lines. For the $i$-th scheduled match, output the team’s on-site performance value $C^{-1} \\bmod M$. If the team underperforms (i.e., the inverse does not exist), output `-1`.", "hint": "For $20\\%$ of the testdata, $1<M,a_i,b_i<10^8$, $m \\le 100$.\n\nFor $100\\%$ of the testdata, $1<M,a_i,b_i<2 \\times 10^{18}$, $m \\le 10000$, $n \\le 20$, $k \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2017] 龙舟", "background": "", "description": "加里敦大学有一个龙舟队，龙舟队有 $n$ 支队伍，每只队伍有 $m$ 个划手。龙舟比赛是一个集体项目，和每个人的能力息息相关，但由于龙舟讲究配合，所以评价队伍的能力的是一个值 $C=\\frac{b_1 \\times b_2 \\times \\cdots \\times b_m}{a_1 \\times a_2 \\times \\cdots \\times a_m}$，其中 $b_i$ 表示第 $i$ 个位置的标准能力值，$a_i$ 表示在队伍中第 $i$ 个位置的划手的能力值。最后通过约分，我们会得到 $C=\\frac{B}{A}$，其中 $\\gcd(B,A)=1$，即 $A,B$ 互质。\n\n但是由于比赛现场的情况不一样，我们认为在现场压力为 $M$ 的情况下，队伍最后的表现情况是 $C^{-1}\\mod M$。我们规定在模 $M$ 的条件下 $\\frac{1}{x}=y$，其中 $y$ 满足 $xy \\equiv 1\\pmod M$，并且 $y$ 大于等于 $0$ 小于 $M$。如果不存在这样的 $y$ 我们就认为在压力为 $M$ 的条件下这支队伍会发挥失常（即 $y$ 是 $x$ 在模 $M$ 意义下的逆元，如果不存在逆元我们认为队伍发挥失常）。给出这个赛季的比赛安排情况，现在教练组想知道各队在比赛中的表现情况。", "inputFormat": "\n第一行输入三个整数 $n,m,k$，表示有 $n$ 支队伍，每支队伍由 $m$ 个人组成，有 $k$ 场比赛。\n\n第二行输入 $m$ 个整数，第 $i$ 个整数表示第 $i$ 个位置的标准能力值为 $b_i$。\n\n第三行到第 $n+2$ 行，共 $n$ 行，每行有 $m$ 个数，第 $2+i$ 行第 $j$ 个数表示第 $i$ 支队伍第 $j$ 个位置划手的能力值。\n\n第 $n+3$ 行到第 $n+k+2$ 行，共 $k$ 行，每行有两个数 $x,M$，分别表示第 $x$ 支队伍会在压力为 $M$ 的比赛中出战。", "outputFormat": "共 $k$ 行，第 $i$ 行表示在第 $i$ 个参赛安排中队伍的现场表现情况 $C$，如果出现队伍发挥失常，输出 `-1`。", "hint": "对于 $20\\%$ 的数据，$1<M,a_i,b_i<10^8$，$m \\le 100$。\n\n对于 $100\\%$ 的数据，$1<M,a_i,b_i<2 \\times 10^{18}$，$m \\le 10000$，$n \\le 20$，$k \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P3763", "type": "P", "difficulty": 6, "samples": [["1\nATCGCCCTA\nCTTCA", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "二分", "各省省选", "哈希 hashing", "后缀数组 SA", "快速傅里叶变换 FFT", "天津"], "title": "[TJOI2017] DNA", "background": "", "description": "加里敦大学的生物研究所，发现了决定人喜不喜欢吃藕的基因序列 $S$,有这个序列的碱基序列就会表现出喜欢吃藕的性状，但是研究人员发现对碱基序列 $S$，任意修改其中不超过 $3$ 个碱基，依然能够表现出吃藕的性状。现在研究人员想知道这个基因在 DNA 链 $S_0$ 上的位置。所以你需要统计在一个表现出吃藕性状的人的 DNA 序列 $S_0$ 上，有多少个连续子串可能是该基因，即有多少个 $S_0$ 的连续子串修改小于等于三个字母能够变成 $S$。\n", "inputFormat": "第一行有一个整数 $T$，表示有几组数据。\n\n每组数据第一行一个长度不超过 $10^5$ 的碱基序列 $S_0$。\n\n每组数据第二行一个长度不超过 $10^5$ 的吃藕基因序列 $S$。\n", "outputFormat": "共 $T$ 行，第 $i$ 行表示第 $i$ 组数据中，在 $S_0$中有多少个与 $S$ 等长的连续子串可能是表现吃藕性状的碱基序列。\n", "hint": "对于 $20\\%$ 的数据，$S_0,S$ 的长度不超过 $10^4$。\n\n对于 $100\\%$ 的数据，$S_0,S$ 的长度不超过 $10^5$，$0\\lt T\\leq 10$。\n\n注：DNA 碱基序列只有 ATCG 四种字符。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2017] DNA", "background": "", "description": "Researchers at the Biology Institute of Garitun University discovered a gene sequence $S$ that determines whether a person likes eating lotus root. Any DNA segment with this sequence exhibits the \"likes lotus root\" trait. Moreover, they found that for the base sequence $S$, modifying at most $3$ bases still results in the trait. Now the researchers want to locate this gene on a DNA strand $S_0$. Therefore, you need to count, on the DNA sequence $S_0$ of a person who exhibits the trait, how many contiguous substrings could be this gene, i.e., how many contiguous substrings of $S_0$ can be changed into $S$ by modifying at most three letters.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nFor each test case, the first line contains a base sequence $S_0$ of length not exceeding $10^5$.\n\nThe second line contains the \"lotus-root gene\" sequence $S$ of length not exceeding $10^5$.", "outputFormat": "Output $T$ lines. The $i$-th line indicates, in the $i$-th test case, how many contiguous substrings in $S_0$ of the same length as $S$ could be a base sequence exhibiting the \"likes lotus root\" trait.", "hint": "For $20\\%$ of the testdata, the lengths of $S_0$ and $S$ do not exceed $10^4$.\n\nFor $100\\%$ of the testdata, the lengths of $S_0$ and $S$ do not exceed $10^5$, $0\\lt T\\leq 10$.\n\nNote: DNA base sequences only contain the four characters A, T, C, and G.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2017] DNA", "background": "", "description": "加里敦大学的生物研究所，发现了决定人喜不喜欢吃藕的基因序列 $S$,有这个序列的碱基序列就会表现出喜欢吃藕的性状，但是研究人员发现对碱基序列 $S$，任意修改其中不超过 $3$ 个碱基，依然能够表现出吃藕的性状。现在研究人员想知道这个基因在 DNA 链 $S_0$ 上的位置。所以你需要统计在一个表现出吃藕性状的人的 DNA 序列 $S_0$ 上，有多少个连续子串可能是该基因，即有多少个 $S_0$ 的连续子串修改小于等于三个字母能够变成 $S$。\n", "inputFormat": "第一行有一个整数 $T$，表示有几组数据。\n\n每组数据第一行一个长度不超过 $10^5$ 的碱基序列 $S_0$。\n\n每组数据第二行一个长度不超过 $10^5$ 的吃藕基因序列 $S$。\n", "outputFormat": "共 $T$ 行，第 $i$ 行表示第 $i$ 组数据中，在 $S_0$中有多少个与 $S$ 等长的连续子串可能是表现吃藕性状的碱基序列。\n", "hint": "对于 $20\\%$ 的数据，$S_0,S$ 的长度不超过 $10^4$。\n\n对于 $100\\%$ 的数据，$S_0,S$ 的长度不超过 $10^5$，$0\\lt T\\leq 10$。\n\n注：DNA 碱基序列只有 ATCG 四种字符。", "locale": "zh-CN"}}}
{"pid": "P3764", "type": "P", "difficulty": 6, "samples": [["100", "1124"], ["2000", "68204"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递归", "洛谷原创", "O2优化", "枚举", "洛谷月赛"], "title": "签到题 III", "background": "pj 组选手 zzq 近日学会了求最大公约数的辗转相除法。", "description": "类比辗转相除法，zzq 定义了一个奇怪的函数：\n\n```cpp\ntypedef long long ll;\nll f(ll a,ll b)\n{\n    if(a==b) return 0;\n    if(a>b) return f(a-b,b+b)+1;\n    else return f(a+a,b-a)+1;\n}\n```\nzzq 定义完这个函数兴高采烈，随便输入了两个数，打算计算 $f$ 值，发现这个函数死循环了……于是 zzq 定义这个函数递归死循环的情况下 $f$ 值为 $0$。\n\n现在 zzq 输入了一个数 $n$，想要求出 $\\sum_{i=1}^n \\sum_{j=1}^n f(i,j)$。", "inputFormat": "一行一个数 $n$。", "outputFormat": "一行一个数 $\\sum_{i=1}^n \\sum_{j=1}^n f(i,j)$。", "hint": "对 $10\\%$ 的数据，$n \\leq 300$。\n\n对于 $40\\%$ 的数据，$n \\leq 2000$。\n\n对于 $70\\%$ 的数据，$n \\leq 5 \\times 10^5$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^{11}$。", "locale": "zh-CN", "translations": {"en": {"title": "Check-in Problem III", "background": "The Junior contestant zzq recently learned the Euclidean algorithm for computing the greatest common divisor (GCD).", "description": "By analogy with the Euclidean algorithm, zzq defined a strange function:\n\n```cpp\ntypedef long long ll;\nll f(ll a,ll b)\n{\n    if(a==b) return 0;\n    if(a>b) return f(a-b,b+b)+1;\n    else return f(a+a,b-a)+1;\n}\n```\nAfter defining this function, zzq excitedly entered two numbers to compute the value of $f$, but found that the function fell into an infinite recursion... Therefore, zzq defines the value of $f$ to be $0$ in cases where the recursion would loop infinitely.\n\nNow zzq inputs a number $n$, and wants to compute $\\sum_{i=1}^n \\sum_{j=1}^n f(i,j)$.", "inputFormat": "One line containing an integer $n$.", "outputFormat": "One line containing an integer $\\sum_{i=1}^n \\sum_{j=1}^n f(i,j)$.", "hint": "For 10% of the testdata, $n \\leq 300$.\n\nFor 40% of the testdata, $n \\leq 2000$.\n\nFor 70% of the testdata, $n \\leq 5 \\times 10^5$.\n\nFor 100% of the testdata, $1 \\leq n \\leq 5 \\times 10^{11}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "签到题 III", "background": "pj 组选手 zzq 近日学会了求最大公约数的辗转相除法。", "description": "类比辗转相除法，zzq 定义了一个奇怪的函数：\n\n```cpp\ntypedef long long ll;\nll f(ll a,ll b)\n{\n    if(a==b) return 0;\n    if(a>b) return f(a-b,b+b)+1;\n    else return f(a+a,b-a)+1;\n}\n```\nzzq 定义完这个函数兴高采烈，随便输入了两个数，打算计算 $f$ 值，发现这个函数死循环了……于是 zzq 定义这个函数递归死循环的情况下 $f$ 值为 $0$。\n\n现在 zzq 输入了一个数 $n$，想要求出 $\\sum_{i=1}^n \\sum_{j=1}^n f(i,j)$。", "inputFormat": "一行一个数 $n$。", "outputFormat": "一行一个数 $\\sum_{i=1}^n \\sum_{j=1}^n f(i,j)$。", "hint": "对 $10\\%$ 的数据，$n \\leq 300$。\n\n对于 $40\\%$ 的数据，$n \\leq 2000$。\n\n对于 $70\\%$ 的数据，$n \\leq 5 \\times 10^5$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^{11}$。", "locale": "zh-CN"}}}
{"pid": "P3765", "type": "P", "difficulty": 6, "samples": [["5 4\n1 2 3 4 5\n1 2 1 1 3\n5 5 1 2 2 4\n2 4 2 0\n3 4 2 1 4", "1\n5\n5\n2\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 3000, 3000, 3000, 3000, 5000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "平衡树", "洛谷原创", "O2优化", "枚举", "构造", "洛谷月赛"], "title": "总统选举", "background": "黑恶势力的反攻计划被小 C 成功摧毁，黑恶势力只好投降。秋之国的人民解放了，举国欢庆。此时，原秋之国总统因没能守护好国土，申请辞职，并请秋之国人民的大救星小 C 钦定下一任。\n\n作为一名民主人士，小 C 决定举行全民大选来决定下一任。为了使最后成为总统的人得到绝大多数人认同，小 C 认为，一个人必须获得超过全部人总数的一半的票数才能成为总统。如果不存在符合条件的候选人，小 C 只好自己来当临时大总统。为了尽可能避免这种情况，小 C 决定先进行几次小规模预选，根据预选的情况，选民可以重新决定自己选票的去向。\n\n由于秋之国人数较多，统计投票结果和选票变更也成为了麻烦的事情，小 C 找到了你，让你帮他解决这个问题。", "description": "秋之国共有 $n$ 个人，分别编号为 $1,2,…,n$，一开始每个人都投了一票，范围 $1 \\sim n$，表示支持对应编号的人当总统。\n\n共有 $m$ 次预选，每次选取编号 $[l_i,r_i]$ 内的选民展开小规模预选，在该区间内获得超过区间大小一半的票的人获胜。如果没有人获胜，则由小 C 钦定一位候选者获得此次预选的胜利（获胜者可以不在该区间内），每次预选的结果需要公布出来，并且每次会有 $k_i$ 个人决定将票改投向该次预选的获胜者。\n\n全部预选结束后，公布最后成为总统的候选人。", "inputFormat": "第一行两个整数 $n,m$，表示秋之国人数和预选次数。\n\n第二行 $n$ 个整数，分别表示编号 $1 \\sim n$ 的选民投的票。\n\n接下来 $m$ 行，每行先有四个整数，分别表示 $l_i,r_i,s_i,k_i$，$s_i$ 表示若此次预选无人胜选，视作编号为 $s_i$ 的人获得胜利，接下来 $k_i$ 个整数，分别表示决定改投的选民。", "outputFormat": "共 $m+1$ 行，前 $m$ 行表示各次预选的结果，最后一行表示最后成为总统的候选人，若最后仍无人胜选，输出 $-1$。", "hint": "对于前 $20 \\%$ 的数据，$1 \\leq n,m \\leq 5000$。\n\n对于前 $40 \\%$ 的数据，$1 \\leq n,m \\leq 50000$，$\\sum k_i \\leq 50000$。\n\n对于前 $50 \\%$ 的数据，$1 \\leq n,m \\leq {10}^5$，$\\sum k_i \\leq 2 \\times {10}^5$。\n\n对于数据点 6~7，保证所有选票始终在 $1 \\sim 10$ 之间。\n\n对于 $100 \\%$ 的数据，$1 \\leq n,m \\leq 5 \\times {10}^5$，$\\sum k_i \\leq 10^6$，$1 \\leq l_i \\leq r_i \\leq n$，$1 \\leq s_i \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "Presidential Election", "background": "The counterattack plan of the criminal forces was successfully crushed by Xiao C, and they had no choice but to surrender. The people of the State of Qiu were liberated, and the whole country celebrated. At this moment, the former president of Qiu, having failed to protect the nation, resigned and asked the great savior of the people, Xiao C, to designate the next president.\n\nAs a democrat, Xiao C decided to hold a nationwide election to determine the next president. To ensure the final president is recognized by the vast majority, Xiao C believes that one must receive more than half of all votes to become president. If no candidate meets this condition, Xiao C will have to serve as the interim president himself. To minimize this possibility, Xiao C decided to hold several small-scale primaries first; based on the results of these primaries, voters may change their votes.\n\nSince Qiu has a large population, tallying votes and tracking changes became troublesome. Xiao C turned to you for help to solve this problem.", "description": "There are $n$ people in the State of Qiu, numbered $1, 2, \\dots, n$. Initially, each person casts one vote in the range $1 \\sim n$, indicating support for the person with that ID to become president.\n\nThere are $m$ primaries. In each primary, voters with indices $[l_i, r_i]$ are selected for a small-scale primary. Within that interval, the person who gets more than half of the votes in the interval wins. If no one wins, Xiao C designates a candidate with ID $s_i$ as the winner (the winner may be outside the interval). The result of each primary must be announced, and after each primary, $k_i$ people decide to switch their votes to the winner of that primary.\n\nAfter all primaries end, announce the candidate who finally becomes president.", "inputFormat": "The first line contains two integers $n, m$, the population of Qiu and the number of primaries.\n\nThe second line contains $n$ integers, representing the votes cast by voters numbered $1 \\sim n$.\n\nThen follow $m$ lines. Each line first contains four integers $l_i, r_i, s_i, k_i$, where $s_i$ means that if no one wins this primary, the person with ID $s_i$ is considered the winner. Then follow $k_i$ integers, representing the voters who decide to switch their votes.", "outputFormat": "Output $m+1$ lines in total. The first $m$ lines represent the result of each primary. The last line represents the candidate who finally becomes president. If in the end no one still meets the winning condition, output $-1$.", "hint": "For the first $20 \\%$ of the testdata, $1 \\leq n, m \\leq 5000$.\n\nFor the first $40 \\%$ of the testdata, $1 \\leq n, m \\leq 50000$, $\\sum k_i \\leq 50000$.\n\nFor the first $50 \\%$ of the testdata, $1 \\leq n, m \\leq {10}^5$, $\\sum k_i \\leq 2 \\times {10}^5$.\n\nFor data points 6~7, it is guaranteed that all votes always remain in $1 \\sim 10$.\n\nFor $100 \\%$ of the testdata, $1 \\leq n, m \\leq 5 \\times {10}^5$, $\\sum k_i \\leq 10^6$, $1 \\leq l_i \\leq r_i \\leq n$, $1 \\leq s_i \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "总统选举", "background": "黑恶势力的反攻计划被小 C 成功摧毁，黑恶势力只好投降。秋之国的人民解放了，举国欢庆。此时，原秋之国总统因没能守护好国土，申请辞职，并请秋之国人民的大救星小 C 钦定下一任。\n\n作为一名民主人士，小 C 决定举行全民大选来决定下一任。为了使最后成为总统的人得到绝大多数人认同，小 C 认为，一个人必须获得超过全部人总数的一半的票数才能成为总统。如果不存在符合条件的候选人，小 C 只好自己来当临时大总统。为了尽可能避免这种情况，小 C 决定先进行几次小规模预选，根据预选的情况，选民可以重新决定自己选票的去向。\n\n由于秋之国人数较多，统计投票结果和选票变更也成为了麻烦的事情，小 C 找到了你，让你帮他解决这个问题。", "description": "秋之国共有 $n$ 个人，分别编号为 $1,2,…,n$，一开始每个人都投了一票，范围 $1 \\sim n$，表示支持对应编号的人当总统。\n\n共有 $m$ 次预选，每次选取编号 $[l_i,r_i]$ 内的选民展开小规模预选，在该区间内获得超过区间大小一半的票的人获胜。如果没有人获胜，则由小 C 钦定一位候选者获得此次预选的胜利（获胜者可以不在该区间内），每次预选的结果需要公布出来，并且每次会有 $k_i$ 个人决定将票改投向该次预选的获胜者。\n\n全部预选结束后，公布最后成为总统的候选人。", "inputFormat": "第一行两个整数 $n,m$，表示秋之国人数和预选次数。\n\n第二行 $n$ 个整数，分别表示编号 $1 \\sim n$ 的选民投的票。\n\n接下来 $m$ 行，每行先有四个整数，分别表示 $l_i,r_i,s_i,k_i$，$s_i$ 表示若此次预选无人胜选，视作编号为 $s_i$ 的人获得胜利，接下来 $k_i$ 个整数，分别表示决定改投的选民。", "outputFormat": "共 $m+1$ 行，前 $m$ 行表示各次预选的结果，最后一行表示最后成为总统的候选人，若最后仍无人胜选，输出 $-1$。", "hint": "对于前 $20 \\%$ 的数据，$1 \\leq n,m \\leq 5000$。\n\n对于前 $40 \\%$ 的数据，$1 \\leq n,m \\leq 50000$，$\\sum k_i \\leq 50000$。\n\n对于前 $50 \\%$ 的数据，$1 \\leq n,m \\leq {10}^5$，$\\sum k_i \\leq 2 \\times {10}^5$。\n\n对于数据点 6~7，保证所有选票始终在 $1 \\sim 10$ 之间。\n\n对于 $100 \\%$ 的数据，$1 \\leq n,m \\leq 5 \\times {10}^5$，$\\sum k_i \\leq 10^6$，$1 \\leq l_i \\leq r_i \\leq n$，$1 \\leq s_i \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P3766", "type": "P", "difficulty": 7, "samples": [["2\n5\n15", "0.25000000000000\n0.48611111111111"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "洛谷原创", "Special Judge", "O2优化", "优先队列", "微积分", "洛谷月赛"], "title": "核心密码B", "background": "懒得拷题目背景了，参见核心密码 A...\n\n请注意两道题的唯一差别。\n", "description": "令 $g(n)$ 表示 $n$ 能表示成几种不同的完全 $k$ 次方数（$k>1$），求 $f(n)=\\sum_{i=2}^n \\frac{g(i)}{i}$。\n\n例如，$64=2^6=4^3=8^2$，所以 $g(64)=3$。\n", "inputFormat": "多组询问，第一行一个整数 $T$ 表示询问组数。\n\n接下来 $T$ 行，每行一个整数 $n$，表示询问 $f(n)$。\n", "outputFormat": "$T$ 行，每行一个实数，表示 $f(n)$，保留十四位小数。\n\n**由于精度误差，你的答案和标准答案差的绝对值在 $2 \\times 10^{-14}$ 以内即可通过。**\n", "hint": "对于 $20\\%$ 的数据，$n \\leq 1000$。\n\n对于 $40\\%$ 的数据，$n \\leq 10^6$，$T \\leq 5$。\n\n对于 $100\\%$ 的数据，$2 \\leq n \\leq 10^{18}$，$1 \\leq T \\leq 50000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Core Cipher B", "background": "Please refer to \"Core Cipher A\" for the background. Note the only difference between the two problems.", "description": "Let $g(n)$ denote the number of different ways $n$ can be expressed as a perfect $k$-th power ($k > 1$). Compute $f(n)=\\sum_{i=2}^n \\frac{g(i)}{i}$.\n\nFor example, $64=2^6=4^3=8^2$, so $g(64)=3$.", "inputFormat": "Multiple queries. The first line contains an integer $T$ indicating the number of queries.\n\nEach of the next $T$ lines contains an integer $n$, asking for $f(n)$.", "outputFormat": "Output $T$ lines. Each line contains a real number representing $f(n)$, with fourteen decimal places.\n\nDue to precision error, your answer will be accepted if the absolute difference from the standard answer is within $2 \\times 10^{-14}$.", "hint": "For $20\\%$ of the testdata, $n \\leq 1000$.\n\nFor $40\\%$ of the testdata, $n \\leq 10^6$, $T \\leq 5$.\n\nFor $100\\%$ of the testdata, $2 \\leq n \\leq 10^{18}$, $1 \\leq T \\leq 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "核心密码B", "background": "懒得拷题目背景了，参见核心密码 A...\n\n请注意两道题的唯一差别。\n", "description": "令 $g(n)$ 表示 $n$ 能表示成几种不同的完全 $k$ 次方数（$k>1$），求 $f(n)=\\sum_{i=2}^n \\frac{g(i)}{i}$。\n\n例如，$64=2^6=4^3=8^2$，所以 $g(64)=3$。\n", "inputFormat": "多组询问，第一行一个整数 $T$ 表示询问组数。\n\n接下来 $T$ 行，每行一个整数 $n$，表示询问 $f(n)$。\n", "outputFormat": "$T$ 行，每行一个实数，表示 $f(n)$，保留十四位小数。\n\n**由于精度误差，你的答案和标准答案差的绝对值在 $2 \\times 10^{-14}$ 以内即可通过。**\n", "hint": "对于 $20\\%$ 的数据，$n \\leq 1000$。\n\n对于 $40\\%$ 的数据，$n \\leq 10^6$，$T \\leq 5$。\n\n对于 $100\\%$ 的数据，$2 \\leq n \\leq 10^{18}$，$1 \\leq T \\leq 50000$。\n", "locale": "zh-CN"}}}
{"pid": "P3767", "type": "P", "difficulty": 6, "samples": [["3 6  \n0 1 1 2  \n1 1 2 3  \n2 2 1 3  \n2 1 3 1  \n2 3 1  \n5 1 3 1", "excited  \nexcited  \nexcited  \nnaive  \nexcited  \nexcited  "]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "线段树", "并查集", "洛谷原创", "分治", "洛谷月赛"], "title": "魔法", "background": "小 Y 在 AK 曼哈顿 OI 之后，开始研究膜法。\n\n一个精心构造的魔法阵可以产生强大的魔力，但是也有非常严苛的要求。\n\n魔法阵的强度与咒语的数目相关，但是咒语太多可能会产生冲突，小Y当然会解决这个问题啦，但是他想考一考你。\n", "description": "魔法阵由 $N$ 个枢纽组成。\n\n每个枢纽可以有五种属性：金、木、水、火、土。它们之间满足相生相克的关系。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5349.png) \n\n一开始，魔法阵中没有咒语。\n\n每次，小 Y 会添加一条咒语，它会要求两个枢纽的属性满足相生/相克的关系。然后你需要回答：是否存在一种为每个枢纽分配一个属性的方案，满足所有的要求。\n\n为了调整法阵，小 Y 有时候需要删除一条写过的咒语。\n\n小 Y 觉得这个问题太简单了，于是他使用改变时间线的能力，让每一次操作在之前某一次操作后形成的魔法阵的基础上进行。", "inputFormat": "第一行两个正整数 $N,M$，表示枢纽的个数和操作个数。\n\n接下来 $M$ 行，每行四个数表示一次操作。\n\n第一个数 $k$ 表示这次操作在第 $k$ 次操作结束后的魔法阵上进行，如果 $k=0$，则表示在初始的魔法阵上进行。\n\n第二个数 $t$ 表示操作类型。\n\n- $t=1$：接下来输入 $u,v$，表示加入一条咒语，要求 $u$ 生 $v$。\n\n- $t=2$：接下来输入 $u,v$，表示加入一条咒语，要求 $u$ 克 $v$。\n\n- $t=3$: 接下来输入 $x$，表示删除第 $x$ 次操作加入的咒语。", "outputFormat": "对于每一次操作，如果操作后存在为每个枢纽分配一个属性的方案，满足所有的要求，输出 `excited`，否则输出 `naive`。\n", "hint": "对于 $30\\%$ 的数据，满足 $N,M\\leq 100$;\n\n对于另 $30\\%$ 的数据，满足 $k_i=i-1$;\n\n对于100%的数据，满足 $N,M \\leq 100000, 0\\leq k_i < i, u_i \\neq v_i, 1 \\leq u_i,v_i \\leq N$，保证所有删除操作都合法。\n", "locale": "zh-CN", "translations": {"en": {"title": "Magic", "background": "After Xiao Y AK'd Manhattan OI, he began to study magic.\n\nA carefully constructed magic array can generate great power, but it also has very strict requirements.\n\nThe strength of the magic array is related to the number of spells, but too many spells may cause conflicts. Of course Xiao Y can solve this, but he wants to test you.", "description": "The magic array consists of $N$ nodes.\n\nEach node can have one of five attributes: metal, wood, water, fire, earth. They satisfy the generate/overcome relationships.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5349.png) \n\nAt the beginning, there are no spells in the magic array.\n\nEach time, Xiao Y will add a spell that requires the attributes of two nodes to satisfy a generate/overcome relationship. Then you need to answer whether there exists an assignment of an attribute to each node that satisfies all the requirements.\n\nTo adjust the array, Xiao Y sometimes needs to delete a previously written spell.\n\nXiao Y thinks this problem is too easy, so he uses the ability to change the timeline, making each operation be applied on the magic array resulting right after some previous operation.", "inputFormat": "The first line contains two positive integers $N, M$, the number of nodes and the number of operations.\n\nThen follow $M$ lines, each containing four numbers describing one operation.\n\nThe first number $k$ means this operation is applied to the magic array obtained right after the $k$-th operation. If $k = 0$, it is applied to the initial magic array.\n\nThe second number $t$ indicates the operation type.\n\n- $t = 1$: then input $u, v$, meaning to add a spell requiring $u$ generates $v$.\n- $t = 2$: then input $u, v$, meaning to add a spell requiring $u$ overcomes $v$.\n- $t = 3$: then input $x$, meaning to delete the spell added by the $x$-th operation.", "outputFormat": "For each operation, if after the operation there exists an assignment of attributes to all nodes that satisfies all the requirements, output `excited`; otherwise, output `naive`.", "hint": "For $30\\%$ of the testdata, $N, M \\leq 100$.\n\nFor another $30\\%$ of the testdata, $k_i = i - 1$.\n\nFor $100\\%$ of the testdata, $N, M \\leq 100000$, $0 \\leq k_i < i$, $u_i \\neq v_i$, $1 \\leq u_i, v_i \\leq N$, and all delete operations are guaranteed to be valid.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "魔法", "background": "小 Y 在 AK 曼哈顿 OI 之后，开始研究膜法。\n\n一个精心构造的魔法阵可以产生强大的魔力，但是也有非常严苛的要求。\n\n魔法阵的强度与咒语的数目相关，但是咒语太多可能会产生冲突，小Y当然会解决这个问题啦，但是他想考一考你。\n", "description": "魔法阵由 $N$ 个枢纽组成。\n\n每个枢纽可以有五种属性：金、木、水、火、土。它们之间满足相生相克的关系。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5349.png) \n\n一开始，魔法阵中没有咒语。\n\n每次，小 Y 会添加一条咒语，它会要求两个枢纽的属性满足相生/相克的关系。然后你需要回答：是否存在一种为每个枢纽分配一个属性的方案，满足所有的要求。\n\n为了调整法阵，小 Y 有时候需要删除一条写过的咒语。\n\n小 Y 觉得这个问题太简单了，于是他使用改变时间线的能力，让每一次操作在之前某一次操作后形成的魔法阵的基础上进行。", "inputFormat": "第一行两个正整数 $N,M$，表示枢纽的个数和操作个数。\n\n接下来 $M$ 行，每行四个数表示一次操作。\n\n第一个数 $k$ 表示这次操作在第 $k$ 次操作结束后的魔法阵上进行，如果 $k=0$，则表示在初始的魔法阵上进行。\n\n第二个数 $t$ 表示操作类型。\n\n- $t=1$：接下来输入 $u,v$，表示加入一条咒语，要求 $u$ 生 $v$。\n\n- $t=2$：接下来输入 $u,v$，表示加入一条咒语，要求 $u$ 克 $v$。\n\n- $t=3$: 接下来输入 $x$，表示删除第 $x$ 次操作加入的咒语。", "outputFormat": "对于每一次操作，如果操作后存在为每个枢纽分配一个属性的方案，满足所有的要求，输出 `excited`，否则输出 `naive`。\n", "hint": "对于 $30\\%$ 的数据，满足 $N,M\\leq 100$;\n\n对于另 $30\\%$ 的数据，满足 $k_i=i-1$;\n\n对于100%的数据，满足 $N,M \\leq 100000, 0\\leq k_i < i, u_i \\neq v_i, 1 \\leq u_i,v_i \\leq N$，保证所有删除操作都合法。\n", "locale": "zh-CN"}}}
{"pid": "P3768", "type": "P", "difficulty": 6, "samples": [["998244353 2000", "883968974"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 3000, 3000, 4000, 4000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["洛谷原创", "O2优化", "莫比乌斯反演", "洛谷月赛", "杜教筛"], "title": "简单的数学题", "background": "", "description": "由于出题人懒得写背景了，题目还是简单一点好。\n\n\n输入一个整数 $n$ 和一个整数 $p$，你需要求出：\n\n$$\\left(\\sum_{i=1}^n\\sum_{j=1}^n ij \\gcd(i,j)\\right) \\bmod p$$\n\n其中 $\\gcd(a,b)$ 表示 $a$ 与 $b$ 的最大公约数。\n", "inputFormat": "一行两个整数 $p,n$。\n", "outputFormat": "一行一个整数表示答案。", "hint": "对于 $20\\%$ 的数据，$n \\leq 1000$。\n\n\n对于 $30\\%$ 的数据，$n \\leq 5000$。\n\n\n对于 $60\\%$ 的数据，$n \\leq 10^6$，时限 1s。\n\n\n对于另外 $20\\%$ 的数据，$n \\leq 10^9$，时限 3s。\n\n\n对于最后 $20\\%$ 的数据，$n \\leq 10^{10}$，时限 4s。\n\n\n对于 $100\\%$ 的数据，$5 \\times 10^8 \\leq p \\leq 1.1 \\times 10^9$ 且 $p$ 为质数。\n", "locale": "zh-CN", "translations": {"en": {"title": "A Simple Math Problem", "background": "", "description": "Since the problem setter is too lazy to write a background, let's keep the problem simple.\n\nGiven two integers $p$ and $n$, compute:\n$$\\left(\\sum_{i=1}^n\\sum_{j=1}^n ij \\gcd(i,j)\\right) \\bmod p$$\nHere $\\gcd(a,b)$ denotes the greatest common divisor of $a$ and $b$.", "inputFormat": "A single line containing two integers $p$ and $n$.", "outputFormat": "Output a single integer on one line, the answer.", "hint": "For 20% of the testdata, $n \\leq 1000$.\n\nFor 30% of the testdata, $n \\leq 5000$.\n\nFor 60% of the testdata, $n \\leq 10^6$, time limit 1 s.\n\nFor another 20% of the testdata, $n \\leq 10^9$, time limit 3 s.\n\nFor the last 20% of the testdata, $n \\leq 10^{10}$, time limit 4 s.\n\nFor 100% of the testdata, $5 \\times 10^8 \\leq p \\leq 1.1 \\times 10^9$ and $p$ is prime.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "简单的数学题", "background": "", "description": "由于出题人懒得写背景了，题目还是简单一点好。\n\n\n输入一个整数 $n$ 和一个整数 $p$，你需要求出：\n\n$$\\left(\\sum_{i=1}^n\\sum_{j=1}^n ij \\gcd(i,j)\\right) \\bmod p$$\n\n其中 $\\gcd(a,b)$ 表示 $a$ 与 $b$ 的最大公约数。\n", "inputFormat": "一行两个整数 $p,n$。\n", "outputFormat": "一行一个整数表示答案。", "hint": "对于 $20\\%$ 的数据，$n \\leq 1000$。\n\n\n对于 $30\\%$ 的数据，$n \\leq 5000$。\n\n\n对于 $60\\%$ 的数据，$n \\leq 10^6$，时限 1s。\n\n\n对于另外 $20\\%$ 的数据，$n \\leq 10^9$，时限 3s。\n\n\n对于最后 $20\\%$ 的数据，$n \\leq 10^{10}$，时限 4s。\n\n\n对于 $100\\%$ 的数据，$5 \\times 10^8 \\leq p \\leq 1.1 \\times 10^9$ 且 $p$ 为质数。\n", "locale": "zh-CN"}}}
{"pid": "P3769", "type": "P", "difficulty": 6, "samples": [["4\n2 3 33 2333\n2 3 33 2333\n2 3 33 2333\n2 3 33 2333\n", "4\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "平衡树", "cdq 分治", "分治", "排序", "K-D Tree"], "title": "[CH弱省胡策R2] TATT", "background": "", "description": "四维空间真是美妙。现在有 $n$ 个四维空间中的点，请求出一条最长的路径，满足任意一维坐标都是单调不降的。\n\n注意路径起点是任意选择的，并且路径与输入顺序无关（路径顺序不一定要满足在输入中是升序）。\n\n**路径的长度是经过的点的数量，任意点只能经过一次。**", "inputFormat": "第一行一个整数 $n$。接下来 $n$ 行，每行四个整数 $a_i,b_i,c_i,d_i$。表示四维坐标。", "outputFormat": "一行一个整数，表示最长路径的长度。", "hint": "记 $m_i=\\max(|a_i|,|b_i|,|c_i|,|d_i|),m=\\max(m_i)$\n|  测试点编号| $n\\le$ | $m\\le$ | 特殊说明 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2000$ | $10^9$ |  |\n| $2$ |$5\\times 10^4$  | $8$ |  |\n| $3\\sim 4$ | $5\\times 10^4$ | $10^5$ |  所有点的第三，四维坐标相同|\n| $5\\sim 6$| $5\\times 10^4$ | $10^5$ |  所有点的第四维坐标相同 |\n| $7\\sim 8$ | $5\\times 10^4$ |$100$  |  |\n|  $9\\sim 10$| $5\\times 10^4$ | $10^9$ |  |", "locale": "zh-CN", "translations": {"en": {"title": "[CH弱省胡策R2] TATT", "background": "", "description": "Four-dimensional space is truly wonderful. Now there are $n$ points in four-dimensional space. Find a longest path such that, along the path, each coordinate in every dimension is monotonically non-decreasing.\n\nNote that the starting point of the path can be chosen arbitrarily, and the path is independent of the input order (the order along the path does not need to be increasing in the input).\n\nThe length of a path is the number of points visited, and any point can be visited at most once.", "inputFormat": "The first line contains an integer $n$. The next $n$ lines each contain four integers $a_i,b_i,c_i,d_i$, representing a 4D coordinate.", "outputFormat": "Output one integer in a single line, the length of a longest path.", "hint": "Let $m_i=\\max(|a_i|,|b_i|,|c_i|,|d_i|),m=\\max(m_i)$.\n|  Test point index | $n\\le$ | $m\\le$ | Special note |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2000$ | $10^9$ |  |\n| $2$ | $5\\times 10^4$ | $8$ |  |\n| $3\\sim 4$ | $5\\times 10^4$ | $10^5$ | The 3rd and 4th coordinates of all points are the same |\n| $5\\sim 6$ | $5\\times 10^4$ | $10^5$ | The 4th coordinate of all points is the same |\n| $7\\sim 8$ | $5\\times 10^4$ | $100$ |  |\n| $9\\sim 10$ | $5\\times 10^4$ | $10^9$ |  |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CH弱省胡策R2] TATT", "background": "", "description": "四维空间真是美妙。现在有 $n$ 个四维空间中的点，请求出一条最长的路径，满足任意一维坐标都是单调不降的。\n\n注意路径起点是任意选择的，并且路径与输入顺序无关（路径顺序不一定要满足在输入中是升序）。\n\n**路径的长度是经过的点的数量，任意点只能经过一次。**", "inputFormat": "第一行一个整数 $n$。接下来 $n$ 行，每行四个整数 $a_i,b_i,c_i,d_i$。表示四维坐标。", "outputFormat": "一行一个整数，表示最长路径的长度。", "hint": "记 $m_i=\\max(|a_i|,|b_i|,|c_i|,|d_i|),m=\\max(m_i)$\n|  测试点编号| $n\\le$ | $m\\le$ | 特殊说明 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2000$ | $10^9$ |  |\n| $2$ |$5\\times 10^4$  | $8$ |  |\n| $3\\sim 4$ | $5\\times 10^4$ | $10^5$ |  所有点的第三，四维坐标相同|\n| $5\\sim 6$| $5\\times 10^4$ | $10^5$ |  所有点的第四维坐标相同 |\n| $7\\sim 8$ | $5\\times 10^4$ |$100$  |  |\n|  $9\\sim 10$| $5\\times 10^4$ | $10^9$ |  |", "locale": "zh-CN"}}}
{"pid": "P3770", "type": "P", "difficulty": 6, "samples": [["5\n3344\n2", "10\n1\n2"], ["500000\n4545\n234567", "999992\n246922\n753067"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "Special Judge", "枚举", "前缀和", "CTSC/CTS"], "title": "[CTSC2017] 密钥", "background": "", "description": "一个密钥是一个长度为 n = 2k + 1 的字符串，它包含 1 个字母 X、k 个字母 A 和k 个字母 B。例如 k = 3 时，BAXABAB 就是一个密钥。\n\n如下图所示，可以按顺时针顺序把这 2k+1 个字母排成一个圈：\n\n ![](https://cdn.luogu.com.cn/upload/pic/5481.png) \n\n在 k 个字母 A 中，有一部分可以定义为 “强的’’。具体来说，从 X 出发顺时针走到某个 A 时，如果途中 A 的数目**严格多于**B的数目，则称此字母 A 为强的。\n\n对于上面的例子来说，顺时针方向从字母 X 数起第 1 个和第 2 个字母 A 是强的，而第 3 个字母 A 不是强的。\n\n一个密钥的**特征值**就是其中包含的强的字母 A 的个数。\n\n天才小朋友 KT 给出了一个结论：\n\n假设 k 个字母 A 所在的位置已经固定，但是剩下的 k 个 B 和 1 个 X 的位置是未知的。（注意，满足这样要求的密钥一共有 k + 1 个，因为字母 X 还剩下 k + 1 个可能的位置。）\n\n可以证明：所有这 k + 1 个可能的密钥的特征值是各不相同的，它们恰好为0, 1, 2, …, k。\n\n下面的图是一个具体的示例，从左到右的四个子图中分别有 3 个，2 个，1 个，0个字母 A 是强的。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5482.png) \n\n类似地，如果固定 k 个字母 B 的位置，那满足条件的所有 k + 1 个密钥的特征值也各不相同，恰好为 0, 1, …, k。\n\n现在你需要解决以下三个问题：\n\n1. 给定密钥中所有 A 的位置，当密钥的特征值为 0 时，请问 X 在哪个位置。\n\n2. 给定密钥中所有 A 的位置，当密钥的特征值为 S 时，请问 X 在哪个位置。\n\n3. 给定密钥中所有 B 的位置，当密钥的特征值为 S 时，请问 X 在哪个位置。\n\n注意：字符串的 2k + 1 个字母的位置由 1 到 2k + 1 编号。\n\n\n【例子 1】\n\n假定 k = 3, S = 2。那么：\n\n当 A 的位置是 {2,4,6} 且特征值为 0 时，X 的位置在 7；\n\n当 A 的位置是 {2,4,6} 且特征值为 2 时，X 的位置在 3；\n\n当 B 的位置是 {2,4,6} 且特征值为 2 时，X 的位置在 5。\n\n【例子 2】\n\n假定 k=9。S=7。那么：\n\n当 A 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 0 时，X 的位置在 14；\n\n当 A 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 7 时，X 的位置在 18；\n\n当 B 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 7 时，X 的位置在 17。\n", "inputFormat": "只包含一组测试数据。\n\n第一行包含一个整数 k，意义如题所述。\n\n第二行包含一个整数 seed，这个数将用于生成一个 k 元集合 P。\n\n第三行包含一个整数 S，意义如题所述。\n\n保证 0 ≤ S ≤ k ≤ 10^7。1 ≤ seed ≤ 10000。\n\n在 cipher/下，包含两个用于生成输入数据的文件 cipher.cpp/pas。其中读入部分已经完成，在数组 p[] 中，若 p[i] = 0，表示 i 不属于集合 P，否则，i 属于集合P。\n\n[百度网盘链接>>   密码：9vr3](http://pan.baidu.com/s/1i55NdWx) 请自行编译\n\n```cpp\n#include <stdio.h>\n#include <string.h>\nint p[20000005];\nint seed, n, k, S;\nint getrand() {\n\tseed = ((seed * 12321) ^ 9999) % 32768;\n\treturn seed;\n}\nvoid generateData() {\n\tscanf( \"%d%d%d\", &k, &seed, &S );\n\tint t = 0;\n\tn = k * 2 + 1;\n\tmemset(p, 0, sizeof(p));\n\tfor( int i = 1; i <= n; ++i ) {\n\t\tp[i] = (getrand() / 128) % 2;\n\t\tt += p[i];\n\t}\n\tint i = 1;\n\twhile( t > k ) {\n\t\twhile ( p[i] == 0 ) ++i;\n\t\tp[i] = 0;\n\t\t--t;\n\t}\n\twhile( t < k ) {\n\t\twhile( p[i] == 1 ) ++i;\n\t\tp[i] = 1;\n\t\t++t;\n\t}\n}\nint main() {\n\tgenerateData();\n\treturn 0;\n}\n```\n", "outputFormat": "输出三行，每行一个数，依次对应问题描述中的三个子问题的答案。\n\n即：\n1. 第一个数表示当 k 元集合 P 代表 A 的位置且特征值为 0 时 X 的位置。\n\n2. 第二个数表示当 k 元集合 P 代表 A 的位置且特征值为 S 时 X 的位置。\n\n3. 第三个数表示当 k 元集合 P 代表 B 的位置且特征值为 S 时 X 的位置。\n", "hint": "【样例解释】\n\n第一个样例中, P 数组为 1 的元素的下标分别为 5, 6, 7, 8, 9。\n\n\n【数据范围与约定】\n\n对于 30% 的数据，k ≤ 10^3。\n\n对于 50% 的数据，k ≤ 10^5。\n\n对于 100% 的数据，k ≤ 10^7。\n\n对于每个测试点, 得分为以下三部分得分之和：\n\n1. 如果第一问回答正确，你将获得 3 分。\n\n2. 如果第二问回答正确，你将获得 4 分。\n\n3. 如果第三问回答正确，你将获得 3 分。\n\n**如果你仅仅知道部分答案，请也务必按此格式要求输出三个数。否则你可能会因格式错误无法得分。**\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2017] Key", "background": "", "description": "A key is a string of length $n = 2k + 1$ that contains 1 letter X, $k$ letters A, and $k$ letters B. For example, when $k = 3$, BAXABAB is a key.\n\nAs shown in the figure below, these $2k + 1$ letters can be arranged in a circle in clockwise order:\n\n ![](https://cdn.luogu.com.cn/upload/pic/5481.png) \n\nAmong the $k$ letters A, some can be defined as \"strong\". Specifically, starting from X and walking clockwise to some A, if along the way the number of A is strictly greater than the number of B, then that letter A is called strong.\n\nIn the above example, the 1st and 2nd letters A counted clockwise from X are strong, while the 3rd letter A is not strong.\n\nThe characteristic value of a key is the number of strong letters A it contains.\n\nThe genius child KT gave the following result:\n\nAssume the positions of the $k$ letters A are fixed, but the positions of the remaining $k$ letters B and 1 letter X are unknown. (Note that there are exactly $k + 1$ keys that meet this condition, because X still has $k + 1$ possible positions.)\n\nIt can be proved that the characteristic values of all these $k + 1$ possible keys are pairwise distinct and are exactly $0, 1, 2, \\dots, k$.\n\nThe following figure is a concrete example. From left to right, the four sub-figures have 3, 2, 1, and 0 strong letters A, respectively.\n\n ![](https://cdn.luogu.com.cn/upload/pic/5482.png) \n\nSimilarly, if the positions of the $k$ letters B are fixed, then the characteristic values of all $k + 1$ keys that meet the condition are also pairwise distinct and are exactly $0, 1, \\dots, k$.\n\nNow you need to solve the following three problems:\n\n1. Given the positions of all A in the key, when the characteristic value is $0$, where is X located?\n2. Given the positions of all A in the key, when the characteristic value is $S$, where is X located?\n3. Given the positions of all B in the key, when the characteristic value is $S$, where is X located?\n\nNote: The positions of the $2k + 1$ letters of the string are numbered from $1$ to $2k + 1$.\n\n[Example 1]\n\nAssume $k = 3$, $S = 2$. Then:\n\n- When the positions of A are {2, 4, 6} and the characteristic value is $0$, the position of X is $7$.\n- When the positions of A are {2, 4, 6} and the characteristic value is $2$, the position of X is $3$.\n- When the positions of B are {2, 4, 6} and the characteristic value is $2$, the position of X is $5$.\n\n[Example 2]\n\nAssume $k = 9$, $S = 7$. Then:\n\n- When the positions of A are {3, 4, 5, 9, 10, 12, 13, 16, 19} and the characteristic value is $0$, the position of X is $14$.\n- When the positions of A are {3, 4, 5, 9, 10, 12, 13, 16, 19} and the characteristic value is $7$, the position of X is $18$.\n- When the positions of B are {3, 4, 5, 9, 10, 12, 13, 16, 19} and the characteristic value is $7$, the position of X is $17$.", "inputFormat": "There is only one set of testdata.\n\nThe first line contains an integer $k$, as described above.\n\nThe second line contains an integer seed, which will be used to generate a $k$-element set $P$.\n\nThe third line contains an integer $S$, as described above.\n\nIt is guaranteed that $0 \\le S \\le k \\le 10^7$. $1 \\le \\text{seed} \\le 10000$.\n\nUnder cipher/, there are two files for generating the input data, cipher.cpp/pas. The reading part has been completed. In the array $p[]$, if $p[i] = 0$, it means $i$ is not in set $P$; otherwise, $i$ is in set $P$.\n\n[Baidu Netdisk link>>   Password: 9vr3](http://pan.baidu.com/s/1i55NdWx) Please compile it yourself.\n\n```cpp\n#include <stdio.h>\n#include <string.h>\nint p[20000005];\nint seed, n, k, S;\nint getrand() {\n\tseed = ((seed * 12321) ^ 9999) % 32768;\n\treturn seed;\n}\nvoid generateData() {\n\tscanf( \"%d%d%d\", &k, &seed, &S );\n\tint t = 0;\n\tn = k * 2 + 1;\n\tmemset(p, 0, sizeof(p));\n\tfor( int i = 1; i <= n; ++i ) {\n\t\tp[i] = (getrand() / 128) % 2;\n\t\tt += p[i];\n\t}\n\tint i = 1;\n\twhile( t > k ) {\n\t\twhile ( p[i] == 0 ) ++i;\n\t\tp[i] = 0;\n\t\t--t;\n\t}\n\twhile( t < k ) {\n\t\twhile( p[i] == 1 ) ++i;\n\t\tp[i] = 1;\n\t\t++t;\n\t}\n}\nint main() {\n\tgenerateData();\n\treturn 0;\n}\n```", "outputFormat": "Output three lines, one number per line, corresponding to the answers to the three subproblems in the description.\n\nThat is:\n1. The first number indicates the position of X when the $k$-element set $P$ represents the positions of A and the characteristic value is $0$.\n2. The second number indicates the position of X when the $k$-element set $P$ represents the positions of A and the characteristic value is $S$.\n3. The third number indicates the position of X when the $k$-element set $P$ represents the positions of B and the characteristic value is $S$.", "hint": "[Sample Explanation]\n\nIn the first sample, the indices of elements where array $P$ is $1$ are $5, 6, 7, 8, 9$.\n\n[Constraints and Conventions]\n\n- For 30% of the testdata, $k \\le 10^3$.\n- For 50% of the testdata, $k \\le 10^5$.\n- For 100% of the testdata, $k \\le 10^7$.\n\nFor each test point, the score is the sum of the following three parts:\n\n1. If you answer the first question correctly, you will get 3 points.\n2. If you answer the second question correctly, you will get 4 points.\n3. If you answer the third question correctly, you will get 3 points.\n\nIf you only know part of the answers, please still output three numbers in this required format. Otherwise, you may lose points due to formatting errors.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2017] 密钥", "background": "", "description": "一个密钥是一个长度为 n = 2k + 1 的字符串，它包含 1 个字母 X、k 个字母 A 和k 个字母 B。例如 k = 3 时，BAXABAB 就是一个密钥。\n\n如下图所示，可以按顺时针顺序把这 2k+1 个字母排成一个圈：\n\n ![](https://cdn.luogu.com.cn/upload/pic/5481.png) \n\n在 k 个字母 A 中，有一部分可以定义为 “强的’’。具体来说，从 X 出发顺时针走到某个 A 时，如果途中 A 的数目**严格多于**B的数目，则称此字母 A 为强的。\n\n对于上面的例子来说，顺时针方向从字母 X 数起第 1 个和第 2 个字母 A 是强的，而第 3 个字母 A 不是强的。\n\n一个密钥的**特征值**就是其中包含的强的字母 A 的个数。\n\n天才小朋友 KT 给出了一个结论：\n\n假设 k 个字母 A 所在的位置已经固定，但是剩下的 k 个 B 和 1 个 X 的位置是未知的。（注意，满足这样要求的密钥一共有 k + 1 个，因为字母 X 还剩下 k + 1 个可能的位置。）\n\n可以证明：所有这 k + 1 个可能的密钥的特征值是各不相同的，它们恰好为0, 1, 2, …, k。\n\n下面的图是一个具体的示例，从左到右的四个子图中分别有 3 个，2 个，1 个，0个字母 A 是强的。\n\n ![](https://cdn.luogu.com.cn/upload/pic/5482.png) \n\n类似地，如果固定 k 个字母 B 的位置，那满足条件的所有 k + 1 个密钥的特征值也各不相同，恰好为 0, 1, …, k。\n\n现在你需要解决以下三个问题：\n\n1. 给定密钥中所有 A 的位置，当密钥的特征值为 0 时，请问 X 在哪个位置。\n\n2. 给定密钥中所有 A 的位置，当密钥的特征值为 S 时，请问 X 在哪个位置。\n\n3. 给定密钥中所有 B 的位置，当密钥的特征值为 S 时，请问 X 在哪个位置。\n\n注意：字符串的 2k + 1 个字母的位置由 1 到 2k + 1 编号。\n\n\n【例子 1】\n\n假定 k = 3, S = 2。那么：\n\n当 A 的位置是 {2,4,6} 且特征值为 0 时，X 的位置在 7；\n\n当 A 的位置是 {2,4,6} 且特征值为 2 时，X 的位置在 3；\n\n当 B 的位置是 {2,4,6} 且特征值为 2 时，X 的位置在 5。\n\n【例子 2】\n\n假定 k=9。S=7。那么：\n\n当 A 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 0 时，X 的位置在 14；\n\n当 A 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 7 时，X 的位置在 18；\n\n当 B 的位置是 {3,4,5,9,10,12,13,16,19} 且特征值为 7 时，X 的位置在 17。\n", "inputFormat": "只包含一组测试数据。\n\n第一行包含一个整数 k，意义如题所述。\n\n第二行包含一个整数 seed，这个数将用于生成一个 k 元集合 P。\n\n第三行包含一个整数 S，意义如题所述。\n\n保证 0 ≤ S ≤ k ≤ 10^7。1 ≤ seed ≤ 10000。\n\n在 cipher/下，包含两个用于生成输入数据的文件 cipher.cpp/pas。其中读入部分已经完成，在数组 p[] 中，若 p[i] = 0，表示 i 不属于集合 P，否则，i 属于集合P。\n\n[百度网盘链接>>   密码：9vr3](http://pan.baidu.com/s/1i55NdWx) 请自行编译\n\n```cpp\n#include <stdio.h>\n#include <string.h>\nint p[20000005];\nint seed, n, k, S;\nint getrand() {\n\tseed = ((seed * 12321) ^ 9999) % 32768;\n\treturn seed;\n}\nvoid generateData() {\n\tscanf( \"%d%d%d\", &k, &seed, &S );\n\tint t = 0;\n\tn = k * 2 + 1;\n\tmemset(p, 0, sizeof(p));\n\tfor( int i = 1; i <= n; ++i ) {\n\t\tp[i] = (getrand() / 128) % 2;\n\t\tt += p[i];\n\t}\n\tint i = 1;\n\twhile( t > k ) {\n\t\twhile ( p[i] == 0 ) ++i;\n\t\tp[i] = 0;\n\t\t--t;\n\t}\n\twhile( t < k ) {\n\t\twhile( p[i] == 1 ) ++i;\n\t\tp[i] = 1;\n\t\t++t;\n\t}\n}\nint main() {\n\tgenerateData();\n\treturn 0;\n}\n```\n", "outputFormat": "输出三行，每行一个数，依次对应问题描述中的三个子问题的答案。\n\n即：\n1. 第一个数表示当 k 元集合 P 代表 A 的位置且特征值为 0 时 X 的位置。\n\n2. 第二个数表示当 k 元集合 P 代表 A 的位置且特征值为 S 时 X 的位置。\n\n3. 第三个数表示当 k 元集合 P 代表 B 的位置且特征值为 S 时 X 的位置。\n", "hint": "【样例解释】\n\n第一个样例中, P 数组为 1 的元素的下标分别为 5, 6, 7, 8, 9。\n\n\n【数据范围与约定】\n\n对于 30% 的数据，k ≤ 10^3。\n\n对于 50% 的数据，k ≤ 10^5。\n\n对于 100% 的数据，k ≤ 10^7。\n\n对于每个测试点, 得分为以下三部分得分之和：\n\n1. 如果第一问回答正确，你将获得 3 分。\n\n2. 如果第二问回答正确，你将获得 4 分。\n\n3. 如果第三问回答正确，你将获得 3 分。\n\n**如果你仅仅知道部分答案，请也务必按此格式要求输出三个数。否则你可能会因格式错误无法得分。**\n", "locale": "zh-CN"}}}
{"pid": "P3771", "type": "P", "difficulty": 7, "samples": [["7 1\n1 2 1\n2 3 1\n3 4 1\n4 5 1\n5 6 1\n6 7 1\n0 0", "3"], ["6 26\n1 2 66\n2 3 11\n3 4 73\n2 5 77\n3 6 33\n10 47\n1 2 86\n2 3 69\n3 4 41\n4 5 26\n5 6 41\n2 7 73\n3 8 77\n4 9 2\n5 10 65\n0 0", "143\n232"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "CTSC/CTS"], "title": "[CTSC2017] 网络", "background": null, "description": "一个一般的网络系统可以被描述成一张无向连通图。图上的每个节点为一个服务器，连接服务器与服务器的数据线则看作图上的一条边，边权为该数据线的长度。两个服务器之间的通讯距离定义为其对应节点之间最短路的长度。\n\n现在，考虑一个当前图结构为树的网络系统。你作为该网络系统的管理员，被要求在这个系统中新加入一条给定长度的数据线。数据线可以连在任意两个服务器上。你的任务是，求出在所有合法的方案中，通讯距离最远的两个服务器之间的最小距离。", "inputFormat": "输入包含多组数据。对于每组数据，输入的第一行包含二个正整数 $N,L$，其中 $N$ 表示服务器个数，$L$ 为新加入数据线的长度。\n\n接下来 $n-1$ 行，第 $i$ 行有三个正整数 $a_i, b_i, l_i$，表示有一条长度为 $l_i$ 的数据线连接服务器 $a_i,b_i$。服务器的编号为 $1\\sim N$。\n\n输入的末尾以 `0 0` 作为结束。", "outputFormat": "对于每组数据，输出一行一个整数，描述在所有合法的方案中，通讯距离最远的两个服务器之间的最小距离。", "hint": "一共有 $20$ 个测试点。编号为 $1 \\sim 20$。每个测试点为 $5$ 分。\n\n保证在任一测试点中，数据的组数不会超过 $15$，且所有数据的 $N$ 之和不超过数据范围中标明的 $N$ 的最大值的 $5$ 倍。\n\n保证所有的输入数据均为不超过 $2^{31} − 1$ 的非负整数，保证 $N \\geq 1$。\n\n保证数据合法。\n\n对于给定的测试点，其限制条件如下表所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/5483.png)", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2017] Network", "background": "", "description": "A general network system can be described as an undirected connected graph. Each node is a server; each edge represents a data cable connecting two servers, and the edge weight equals the length of that cable. The communication distance between two servers is defined as the length of the shortest path between their corresponding nodes.\n\nNow consider a network system whose current graph structure is a tree. As the administrator of this network system, you are required to add one new data cable of a given length to this system. The cable can connect any two servers. Your task is to find, among all valid plans, the minimum possible distance between the farthest pair of servers.", "inputFormat": "The input contains multiple test cases. For each test case, the first line contains two positive integers $N, L$, where $N$ is the number of servers and $L$ is the length of the new data cable.\n\nThe next $N - 1$ lines, the $i$-th line contains three positive integers $a_i, b_i, l_i$, indicating there is a data cable of length $l_i$ connecting servers $a_i$ and $b_i$. Servers are numbered $1 \\sim N$.\n\nThe input ends with `0 0`.", "outputFormat": "For each test case, output one line with a single integer: the minimum possible distance between the farthest pair of servers over all valid plans.", "hint": "There are $20$ test points, numbered $1 \\sim 20$. Each test point is worth $5$ points.\n\nIt is guaranteed that, within any single test point, the number of groups of testdata does not exceed $15$, and the sum of $N$ over all testdata does not exceed $5$ times the maximum $N$ specified in Constraints.\n\nAll input numbers are non-negative integers not exceeding $2^{31} - 1$, and $N \\geq 1$.\n\nAll testdata are valid.\n\nFor the given test points, their constraints are shown in the table below.\n\n![](https://cdn.luogu.com.cn/upload/pic/5483.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2017] 网络", "background": null, "description": "一个一般的网络系统可以被描述成一张无向连通图。图上的每个节点为一个服务器，连接服务器与服务器的数据线则看作图上的一条边，边权为该数据线的长度。两个服务器之间的通讯距离定义为其对应节点之间最短路的长度。\n\n现在，考虑一个当前图结构为树的网络系统。你作为该网络系统的管理员，被要求在这个系统中新加入一条给定长度的数据线。数据线可以连在任意两个服务器上。你的任务是，求出在所有合法的方案中，通讯距离最远的两个服务器之间的最小距离。", "inputFormat": "输入包含多组数据。对于每组数据，输入的第一行包含二个正整数 $N,L$，其中 $N$ 表示服务器个数，$L$ 为新加入数据线的长度。\n\n接下来 $n-1$ 行，第 $i$ 行有三个正整数 $a_i, b_i, l_i$，表示有一条长度为 $l_i$ 的数据线连接服务器 $a_i,b_i$。服务器的编号为 $1\\sim N$。\n\n输入的末尾以 `0 0` 作为结束。", "outputFormat": "对于每组数据，输出一行一个整数，描述在所有合法的方案中，通讯距离最远的两个服务器之间的最小距离。", "hint": "一共有 $20$ 个测试点。编号为 $1 \\sim 20$。每个测试点为 $5$ 分。\n\n保证在任一测试点中，数据的组数不会超过 $15$，且所有数据的 $N$ 之和不超过数据范围中标明的 $N$ 的最大值的 $5$ 倍。\n\n保证所有的输入数据均为不超过 $2^{31} − 1$ 的非负整数，保证 $N \\geq 1$。\n\n保证数据合法。\n\n对于给定的测试点，其限制条件如下表所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/5483.png)", "locale": "zh-CN"}}}
{"pid": "P3772", "type": "P", "difficulty": 7, "samples": [["3 3 A\n0.3\n0.5 0.2\n0.9 0.8\nadd 1 1\nadd 3 0\ndel 1", "2.350000\n1.333333\n0.432749"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "线段树", "Special Judge", "CTSC/CTS"], "title": "[CTSC2017] 游戏", "background": null, "description": "小 R 和室友小 B 在寝室里玩游戏。他们一共玩了 n 局游戏，每局游戏的结果要么是小 R 获胜，要么是小 B 获胜。\n\n第 1 局游戏小 R 获胜的概率是 $p_1$，小 B 获胜的概率是 $1-p_1$。除了第一局游戏之外，每一局游戏小 R 获胜的概率与上一局游戏小 R 是否获胜有关。\n\n具体来说：\n\n1. 如果第 $i − 1$（$1 < i ≤ n$）局游戏小 R 获胜，那么第 $i$ 局游戏小 R 获胜的概率为 $p_i$，小 B 获胜的概率为 $1 − p_i$。\n\n2. 如果第 $i − 1$（$1 < i ≤ n$）局游戏小 B 获胜，那么第 $i$ 局游戏小 R 获胜的概率为 $q_i$，小 B 获胜的概率为 $1 − q_i$。\n\n小 D 时常过来看小 R 和小 B 玩游戏，因此他知道某几局游戏的结果。他想知道在他已知信息的条件下，小 R 在 $n$ 局游戏中总共获胜的局数的期望是多少。\n\n小 D 记性不太好，有时他会回忆起某局游戏的结果，并把它加入到已知信息中；\n\n有时他会忘记之前某局游戏结果，并把它从已知信息中删除。你的任务是：每当小 D 在已知信息中增加或删除一条信息时，根据小 D 记得的已知信息，帮助小 D 计算小 R 在 $n$ 局游戏中总共获胜局数的期望是多少。\n\n需要注意的是：如果小 D 忘了一局游戏的结果，之后又重新记起，两次记忆中的游戏结果不一定是相同的。你不需要关心小 D 的记忆是否与实际情况相符，你只需要根据他的记忆计算相应的答案。", "inputFormat": "第一行两个正整数 $n, m$ 和一个字符串 $\\textrm{type}$。表示小 R 和小 B 一共玩了 $n$ 局游戏，\n\n小 D 一共进行了 $m$ 次修改已知信息的操作，该数据的类型为 $\\textrm{type}$。$\\textrm{type}$ 字符串是为了能让大家更方便地获得部分分，你可能不需要用到这个输入，其具体含义见【限制与约定】。\n\n接下来 $n$ 行，第 1 行包含一个实数 $p_1$，表示第一局比赛小 R 获胜的概率是 $p_1$。第 $i$（$1 < i ≤ n$）行包含两个实数 $p_i, q_i$。表示在第 $i − 1$ 局游戏小 R 获胜的情况下，第 $i$ 局游戏小 R 获胜的概率是 $p_i$；$q_i$ 表示在第 $i − 1$ 局游戏小 B 获胜的情况下，第 $i$ 局游戏小 R 获胜的概率是 $q_i$。\n\n接下来 $m$ 行，每行描述一个小 D 已知信息的变化，操作分为两类。\n\n1. `add i c` 表示小 D 回忆起了第 $i$ 局比赛的结果，并把它加入到已知信息中。若 $c = 0$ 表示第 $i$ 局比赛小 B 获胜，若 $c = 1$ 表示第 $i$ 局比赛小 R 获胜。数据保证 $i, c$ 均为整数且 $1 ≤ i ≤ n, 0 ≤ c ≤ 1$，如果这个操作不是第一个操作，保证在上一个操作结束后的已知信息中没有第 $i$ 局比赛的结果。\n\n2. `del i` 表示小 D 忘记了第 $i$ 局比赛的结果，并把它从已知信息中删除。数据保证 $i$ 是整数且 $1 ≤ i ≤ n$，保证在上一个操作结束后的已知信息中有第 $i$ 局比赛的结果。", "outputFormat": "对于每个操作，输出一行实数，表示操作结束后，在当前已知信息的条件下，小 R 在 $n$ 局游戏中总共获胜的局数的期望是多少。", "hint": "【评分标准】\n\n如果你的答案与正确答案的绝对误差在 $10^{-4}$ 以内，则被判定为正确。\n\n如果你的所有答案均为正确，则得满分，否则得 $0$ 分。\n\n请注意输出格式：每行输出一个答案，答案只能为一个实数。每行的长度不得超过 $50$。错误输出格式会被判定为 $0$ 分。\n\n\n【限制与约定】\n\n对于 $100\\%$ 的数据，$1 ≤ n ≤ 200000$，$1 ≤ m ≤ 200000$，$0 < p_i, q_i < 1$。\n\n对于 $100\\%$ 的数据，输入保留最多四位小数。\n\n本题共有 $20$ 个数据点，每个数据点 $5$ 分, 每个测试点的具体约定如下表：\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/5484.png) \n\n【小 R 教你学数学】\n\n你可. 能. 会用到以下公式\n\n1. 条件概率的计算方法\n\n我们记 $p(A|B)$ 表示在已知事件 $B$ 发生时事件 $A$ 发生的概率，条件概率可以用以下公式计算：\n\n$p(A|B)=\\frac {p(AB)}{p(B)}$\n\n其中 $p(AB)$ 表示事件 $B$ 和事件 $A$ 同时发生的概率，$p(B)$ 表示事件 $B$ 发生的概率。\n\n2. 贝叶斯公式 (bayes)\n\n由条件概率的计算方法，我们容易得到贝叶斯公式\n\n$p(A|B)=\\frac {p(B|A)p(A)}{p(B)}$\n\n3. 全概率公式\n\n如果随机变量 $x$ 有 $k$ 个取值，分别为 $x_1, x_2,\\ldots , x_k$ 那么\n\n$p(A)=\\sum^{k}_{i=1} {p(A|x=x_i)p(x=x_i)}$\n\n ![](https://cdn.luogu.com.cn/upload/pic/5486.png) \n\n【温馨提示】\n\n在本题中，如果你希望获得全部的分数，你可能需要考虑由于浮点数运算引入的误差。只使用加法和乘法运算不会引入太大的误差，但请谨慎使用减法和除法。\n\n1. 两个大小相近的数相减可以引入非常大的相对误差。\n\n2. 如果一个矩阵的行列式值非常小，那么求解该矩阵的逆可以带来相当大的误差。\n\n当然，如果你的算法在数学上是正确的，但没有考虑浮点数运算的误差问题，可能仍然可以获得一部分的分数。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2017] Game", "background": "", "description": "Xiao R and his roommate Xiao B are playing a game in their dorm. They play a total of $n$ games, and each game ends with either Xiao R winning or Xiao B winning.\n\nIn game 1, the probability that Xiao R wins is $p_1$, and the probability that Xiao B wins is $1 - p_1$. Except for the first game, in each game the probability that Xiao R wins depends on whether Xiao R won the previous game.\n\nSpecifically:\n\n1. If in game $i − 1$ ($1 < i ≤ n$) Xiao R won, then in game $i$ the probability that Xiao R wins is $p_i$, and the probability that Xiao B wins is $1 − p_i$.\n\n2. If in game $i − 1$ ($1 < i ≤ n$) Xiao B won, then in game $i$ the probability that Xiao R wins is $q_i$, and the probability that Xiao B wins is $1 − q_i$.\n\nXiao D often comes to watch Xiao R and Xiao B play, so he knows the outcomes of some games. He wants to know, under the information he currently knows, what the expected total number of games won by Xiao R is among the $n$ games.\n\nXiao D does not have a good memory: sometimes he recalls the outcome of some game and adds it to his known information; sometimes he forgets a previously remembered outcome and removes it from his known information. Your task is: whenever Xiao D adds or deletes one piece of information, compute, based on Xiao D’s current known information, the expected total number of games won by Xiao R among the $n$ games.\n\nNote: If Xiao D forgets the result of a game and later recalls it again, the two remembered outcomes are not necessarily the same. You do not need to care whether his memory matches the actual situation; you only need to compute the answers according to his memory.", "inputFormat": "The first line contains two positive integers $n, m$ and a string $\\textrm{type}$. They indicate that Xiao R and Xiao B play $n$ games in total, Xiao D performs $m$ operations of modifying his known information, and the data is of type $\\textrm{type}$. The string $\\textrm{type}$ is provided to help obtain partial scores; you may not need this input. See [Constraints] for its meaning.\n\nThe next $n$ lines: the 1st line contains a real number $p_1$, meaning that in the first game the probability that Xiao R wins is $p_1$. Line $i$ ($1 < i ≤ n$) contains two real numbers $p_i, q_i$. Here, $p_i$ means that if Xiao R won game $i − 1$, then in game $i$ the probability that Xiao R wins is $p_i$; $q_i$ means that if Xiao B won game $i − 1$, then in game $i$ the probability that Xiao R wins is $q_i$.\n\nThe next $m$ lines each describe one change to Xiao D’s known information. There are two types of operations.\n\n1. `add i c` means Xiao D recalls the outcome of game $i$ and adds it to his known information. If $c = 0$ it means Xiao B won game $i$; if $c = 1$ it means Xiao R won game $i$. It is guaranteed that $i, c$ are integers with $1 ≤ i ≤ n, 0 ≤ c ≤ 1$. If this is not the first operation, it is guaranteed that after the previous operation the known information does not contain the result of game $i$.\n\n2. `del i` means Xiao D forgets the outcome of game $i$ and removes it from his known information. It is guaranteed that $i$ is an integer with $1 ≤ i ≤ n$, and that after the previous operation the known information contains the result of game $i$.", "outputFormat": "For each operation, output one real number on a single line: after the operation, under the current known information, the expected total number of games won by Xiao R among the $n$ games.", "hint": "[Scoring]\n\nYour answer is judged correct if its absolute error from the correct answer is within $10^{-4}$.\n\nYou receive full score only if all your answers are correct; otherwise you receive $0$ points.\n\nPlease note the output format: output exactly one answer per line, and each answer must be a single real number. The length of each line must not exceed $50$. Wrong output formats will be judged as $0$ points.\n\n[Constraints]\n\nFor $100\\%$ of the data, $1 ≤ n ≤ 200000$, $1 ≤ m ≤ 200000$, $0 < p_i, q_i < 1$.\n\nFor $100\\%$ of the data, input values have at most four decimal places.\n\nThere are $20$ test data points in total, each worth $5$ points. The specific assumptions for each test point are shown in the table below:\n\n![](https://cdn.luogu.com.cn/upload/pic/5484.png) \n\n[Xiao R teaches you math]\n\nYou may use the following formulas.\n\n1. Conditional probability\n\nWe write $p(A|B)$ to denote the probability that event $A$ occurs given that event $B$ occurs. Conditional probability can be computed by:\n$p(A|B)=\\frac {p(AB)}{p(B)}$\nwhere $p(AB)$ denotes the probability that both event $B$ and event $A$ occur, and $p(B)$ denotes the probability that event $B$ occurs.\n\n2. Bayes’ formula (Bayes)\n\nFrom conditional probability, we can derive Bayes’ formula:\n$p(A|B)=\\frac {p(B|A)p(A)}{p(B)}$\n\n3. Law of total probability\n\nIf a random variable $x$ has $k$ possible values, namely $x_1, x_2,\\ldots , x_k$, then\n$p(A)=\\sum^{k}_{i=1} {p(A|x=x_i)p(x=x_i)}$\n\n![](https://cdn.luogu.com.cn/upload/pic/5486.png) \n\n[Warm reminder]\n\nIn this problem, if you want to get full score, you may need to consider errors introduced by floating-point arithmetic. Using only addition and multiplication will not introduce large errors, but please be cautious with subtraction and division.\n\n1. Subtracting two numbers that are close in value can introduce very large relative error.\n\n2. If the determinant of a matrix is very small, computing the inverse of that matrix can introduce considerable error.\n\nOf course, even if your algorithm is mathematically correct but does not consider floating-point errors, you may still obtain partial scores.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2017] 游戏", "background": null, "description": "小 R 和室友小 B 在寝室里玩游戏。他们一共玩了 n 局游戏，每局游戏的结果要么是小 R 获胜，要么是小 B 获胜。\n\n第 1 局游戏小 R 获胜的概率是 $p_1$，小 B 获胜的概率是 $1-p_1$。除了第一局游戏之外，每一局游戏小 R 获胜的概率与上一局游戏小 R 是否获胜有关。\n\n具体来说：\n\n1. 如果第 $i − 1$（$1 < i ≤ n$）局游戏小 R 获胜，那么第 $i$ 局游戏小 R 获胜的概率为 $p_i$，小 B 获胜的概率为 $1 − p_i$。\n\n2. 如果第 $i − 1$（$1 < i ≤ n$）局游戏小 B 获胜，那么第 $i$ 局游戏小 R 获胜的概率为 $q_i$，小 B 获胜的概率为 $1 − q_i$。\n\n小 D 时常过来看小 R 和小 B 玩游戏，因此他知道某几局游戏的结果。他想知道在他已知信息的条件下，小 R 在 $n$ 局游戏中总共获胜的局数的期望是多少。\n\n小 D 记性不太好，有时他会回忆起某局游戏的结果，并把它加入到已知信息中；\n\n有时他会忘记之前某局游戏结果，并把它从已知信息中删除。你的任务是：每当小 D 在已知信息中增加或删除一条信息时，根据小 D 记得的已知信息，帮助小 D 计算小 R 在 $n$ 局游戏中总共获胜局数的期望是多少。\n\n需要注意的是：如果小 D 忘了一局游戏的结果，之后又重新记起，两次记忆中的游戏结果不一定是相同的。你不需要关心小 D 的记忆是否与实际情况相符，你只需要根据他的记忆计算相应的答案。", "inputFormat": "第一行两个正整数 $n, m$ 和一个字符串 $\\textrm{type}$。表示小 R 和小 B 一共玩了 $n$ 局游戏，\n\n小 D 一共进行了 $m$ 次修改已知信息的操作，该数据的类型为 $\\textrm{type}$。$\\textrm{type}$ 字符串是为了能让大家更方便地获得部分分，你可能不需要用到这个输入，其具体含义见【限制与约定】。\n\n接下来 $n$ 行，第 1 行包含一个实数 $p_1$，表示第一局比赛小 R 获胜的概率是 $p_1$。第 $i$（$1 < i ≤ n$）行包含两个实数 $p_i, q_i$。表示在第 $i − 1$ 局游戏小 R 获胜的情况下，第 $i$ 局游戏小 R 获胜的概率是 $p_i$；$q_i$ 表示在第 $i − 1$ 局游戏小 B 获胜的情况下，第 $i$ 局游戏小 R 获胜的概率是 $q_i$。\n\n接下来 $m$ 行，每行描述一个小 D 已知信息的变化，操作分为两类。\n\n1. `add i c` 表示小 D 回忆起了第 $i$ 局比赛的结果，并把它加入到已知信息中。若 $c = 0$ 表示第 $i$ 局比赛小 B 获胜，若 $c = 1$ 表示第 $i$ 局比赛小 R 获胜。数据保证 $i, c$ 均为整数且 $1 ≤ i ≤ n, 0 ≤ c ≤ 1$，如果这个操作不是第一个操作，保证在上一个操作结束后的已知信息中没有第 $i$ 局比赛的结果。\n\n2. `del i` 表示小 D 忘记了第 $i$ 局比赛的结果，并把它从已知信息中删除。数据保证 $i$ 是整数且 $1 ≤ i ≤ n$，保证在上一个操作结束后的已知信息中有第 $i$ 局比赛的结果。", "outputFormat": "对于每个操作，输出一行实数，表示操作结束后，在当前已知信息的条件下，小 R 在 $n$ 局游戏中总共获胜的局数的期望是多少。", "hint": "【评分标准】\n\n如果你的答案与正确答案的绝对误差在 $10^{-4}$ 以内，则被判定为正确。\n\n如果你的所有答案均为正确，则得满分，否则得 $0$ 分。\n\n请注意输出格式：每行输出一个答案，答案只能为一个实数。每行的长度不得超过 $50$。错误输出格式会被判定为 $0$ 分。\n\n\n【限制与约定】\n\n对于 $100\\%$ 的数据，$1 ≤ n ≤ 200000$，$1 ≤ m ≤ 200000$，$0 < p_i, q_i < 1$。\n\n对于 $100\\%$ 的数据，输入保留最多四位小数。\n\n本题共有 $20$ 个数据点，每个数据点 $5$ 分, 每个测试点的具体约定如下表：\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/5484.png) \n\n【小 R 教你学数学】\n\n你可. 能. 会用到以下公式\n\n1. 条件概率的计算方法\n\n我们记 $p(A|B)$ 表示在已知事件 $B$ 发生时事件 $A$ 发生的概率，条件概率可以用以下公式计算：\n\n$p(A|B)=\\frac {p(AB)}{p(B)}$\n\n其中 $p(AB)$ 表示事件 $B$ 和事件 $A$ 同时发生的概率，$p(B)$ 表示事件 $B$ 发生的概率。\n\n2. 贝叶斯公式 (bayes)\n\n由条件概率的计算方法，我们容易得到贝叶斯公式\n\n$p(A|B)=\\frac {p(B|A)p(A)}{p(B)}$\n\n3. 全概率公式\n\n如果随机变量 $x$ 有 $k$ 个取值，分别为 $x_1, x_2,\\ldots , x_k$ 那么\n\n$p(A)=\\sum^{k}_{i=1} {p(A|x=x_i)p(x=x_i)}$\n\n ![](https://cdn.luogu.com.cn/upload/pic/5486.png) \n\n【温馨提示】\n\n在本题中，如果你希望获得全部的分数，你可能需要考虑由于浮点数运算引入的误差。只使用加法和乘法运算不会引入太大的误差，但请谨慎使用减法和除法。\n\n1. 两个大小相近的数相减可以引入非常大的相对误差。\n\n2. 如果一个矩阵的行列式值非常小，那么求解该矩阵的逆可以带来相当大的误差。\n\n当然，如果你的算法在数学上是正确的，但没有考虑浮点数运算的误差问题，可能仍然可以获得一部分的分数。", "locale": "zh-CN"}}}
{"pid": "P3773", "type": "P", "difficulty": 6, "samples": [["4\n15\n7\n3\n1", "11"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000, 500000]}, "tags": ["2017", "递归", "O2优化", "枚举", "进制", "组合数学", "CTSC/CTS"], "title": "[CTSC2017] 吉夫特", "background": "", "description": "简单的题目，既是礼物，也是毒药。\n\nB 君设计了一道简单的题目，准备作为 gift 送给大家。\n\n输入一个长度为  $n$  的数列  $a_1, a_2, \\cdots , a_n$  问有多少个长度大于等于  $2$  的不上升的子序列满足：\n\n $$\\prod _{i=2}^{k} \\binom{a_{b_{i-1}}}{a_{b_i}} \\bmod 2 = \\binom{a_{b_1}}{a_{b_2}} \\times \\binom{a_{b_2}}{a_{b_3}} \\times \\cdots \\binom{a_{b_{k-1}}}{a_{b_k}} \\bmod 2 > 0$$ \n\n输出这个个数对  $1000000007$  取模的结果。\n\nG 君看到题目后，为大家解释了一些基本概念。\n\n我们选择任意多个整数  $b_i$  满足\n\n $$1 \\leq b_1 < b_2 < \\dots < b_{k-1} < b_k \\leq n$$ \n\n我们称  $a_{b_1}, a_{b_2}, \\cdots, a_{b_k} $  是  $a$  的一个子序列。\n\n如果这个子序列同时还满足\n\n $$a_{b_1} \\geq a_{b_2} \\geq \\cdots \\geq a_{b_{k-1}}\\geq a_{b_k}$$ \n\n我们称这个子序列是不上升的。\n\n组合数  $\\binom {n} {m} $  是从  $n$  个互不相同的元素中取  $m$  个元素的方案数，具体计算方案如下：\n\n $$\\binom {n}{m}=\\frac{n!}{m!(n-m)!}=\\frac{n \\times (n-1) \\times \\cdots \\times 2 \\times 1}{(m \\times (m-1) \\cdots \\times 2 \\times 1)((n-m)\\times(n-m-1)\\times \\cdots \\times 2 \\times 1)}$$ \n\n这里要特别注意，因为我们只考虑不上升子序列，所以在求组合数的过程中，一定满足  $n \\geq m$ ，也就是 $\\binom {a_{b_{i-1}}}{a_{b_i}}$ 中一定有 $a_{b_{i-1}} \\geq a_{b_i}$ 。\n\n我们在这里强调取模  $x \\mod y$  的定义：\n\n $x \\bmod y = x -\\left \\lfloor \\frac{x}{y} \\right \\rfloor \\times y$ \n\n其中  $\\left \\lfloor n \\right \\rfloor$  表示小于等于  $n$  的最大整数。\n\n $x \\bmod 2 > 0$  ，就是在说  $x$  是奇数。\n\n与此同时，经验告诉我们一个长度为  $n$  的序列，子序列个数有  $O(2^n)$  个，所以我们通过对答案取模来避免输出过大。\n\nB 君觉得 G 君说的十分有道理，于是再次强调了这些基本概念。\n\n最后， G 君听说这个题是作为 gift 送给大家，她有一句忠告。\n\n“Vorsicht, Gift!”\n\n“小心. . . . . .剧毒！ ”", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行一个整数，这 $n$ 行中的第 $i$ 行，表示 $a_i$。\n", "outputFormat": "一行一个整数表示答案。\n", "hint": "对于前 $10\\%$ 的测试点，$n \\leq 9$，$1\\leq a_i\\leq 13$。\n\n对于前 $20\\%$ 的测试点，$n\\leq 17$，$1\\leq a_i\\leq 20$。\n\n对于前 $40\\%$ 的测试点，$n\\leq 1911$，$1\\leq a_i\\leq 4000$。\n\n对于前 $70\\%$ 的测试点，$n\\leq 2017$。\n\n对于前 $85\\%$ 的测试点，$n\\leq 100084$。\n\n对于 $100\\%$ 的测试点，$1\\leq n\\leq 211985$，$1\\leq a_i\\leq 233333$。所有的 $a_i$ 互不相同，也就是说不存在 $i, j$ 同时满足 $1\\leq i < j\\leq n$ 和 $a_i = a_j$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2017] Gift", "background": "", "description": "A simple problem, both a gift and a poison.\n\nB designed a simple problem to give as a \"gift\" to everyone.\n\nGiven a sequence of length $n$, $a_1, a_2, \\cdots , a_n$, ask how many non-increasing subsequences of length at least $2$ satisfy:\n $$\\prod _{i=2}^{k} \\binom{a_{b_{i-1}}}{a_{b_i}} \\bmod 2 = \\binom{a_{b_1}}{a_{b_2}} \\times \\binom{a_{b_2}}{a_{b_3}} \\times \\cdots \\binom{a_{b_{k-1}}}{a_{b_k}} \\bmod 2 > 0$$ \nOutput this count modulo $1000000007$.\n\nG, after seeing the problem, explained some basic concepts for everyone.\n\nWe choose any number of integers $b_i$ satisfying\n $$1 \\leq b_1 < b_2 < \\dots < b_{k-1} < b_k \\leq n$$ \nWe call $a_{b_1}, a_{b_2}, \\cdots, a_{b_k}$ a subsequence of $a$.\n\nIf this subsequence also satisfies\n $$a_{b_1} \\geq a_{b_2} \\geq \\cdots \\geq a_{b_{k-1}}\\geq a_{b_k}$$ \nwe call the subsequence non-increasing.\n\nThe binomial coefficient $\\binom {n} {m}$ is the number of ways to choose $m$ elements from $n$ distinct elements, computed as follows:\n $$\\binom {n}{m}=\\frac{n!}{m!(n-m)!}=\\frac{n \\times (n-1) \\times \\cdots \\times 2 \\times 1}{(m \\times (m-1) \\cdots \\times 2 \\times 1)((n-m)\\times(n-m-1)\\times \\cdots \\times 2 \\times 1)}$$ \nNote in particular that since we only consider non-increasing subsequences, it must hold during binomial computation that $n \\geq m$, i.e., in $\\binom {a_{b_{i-1}}}{a_{b_i}}$ we always have $a_{b_{i-1}} \\geq a_{b_i}$.\n\nWe emphasize the definition of $x \\mod y$:\n $x \\bmod y = x -\\left \\lfloor \\frac{x}{y} \\right \\rfloor \\times y$ \nwhere $\\left \\lfloor n \\right \\rfloor$ denotes the greatest integer less than or equal to $n$.\n\n$x \\bmod 2 > 0$ means that $x$ is odd.\n\nMeanwhile, experience tells us that a sequence of length $n$ has $O(2^n)$ subsequences, so we take the answer modulo to avoid an overly large output.\n\nB felt that G’s points were very reasonable and reiterated these basics.\n\nFinally, upon hearing that this problem is a \"gift\" to everyone, G had a piece of advice.\n\n“Vorsicht, Gift!”\n\n“Careful... highly toxic!”", "inputFormat": "The first line contains an integer $n$.\n\nThen follow $n$ lines, each containing one integer. The $i$-th of these $n$ lines is $a_i$.", "outputFormat": "Output a single integer, the answer.", "hint": "For the first $10\\%$ of the test points, $n \\leq 9$, $1\\leq a_i\\leq 13$.\n\nFor the first $20\\%$ of the test points, $n\\leq 17$, $1\\leq a_i\\leq 20$.\n\nFor the first $40\\%$ of the test points, $n\\leq 1911$, $1\\leq a_i\\leq 4000$.\n\nFor the first $70\\%$ of the test points, $n\\leq 2017$.\n\nFor the first $85\\%$ of the test points, $n\\leq 100084$.\n\nFor $100\\%$ of the test points, $1\\leq n\\leq 211985$, $1\\leq a_i\\leq 233333$. All $a_i$ are pairwise distinct, that is, there do not exist $i, j$ such that $1\\leq i < j\\leq n$ and $a_i = a_j$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2017] 吉夫特", "background": "", "description": "简单的题目，既是礼物，也是毒药。\n\nB 君设计了一道简单的题目，准备作为 gift 送给大家。\n\n输入一个长度为  $n$  的数列  $a_1, a_2, \\cdots , a_n$  问有多少个长度大于等于  $2$  的不上升的子序列满足：\n\n $$\\prod _{i=2}^{k} \\binom{a_{b_{i-1}}}{a_{b_i}} \\bmod 2 = \\binom{a_{b_1}}{a_{b_2}} \\times \\binom{a_{b_2}}{a_{b_3}} \\times \\cdots \\binom{a_{b_{k-1}}}{a_{b_k}} \\bmod 2 > 0$$ \n\n输出这个个数对  $1000000007$  取模的结果。\n\nG 君看到题目后，为大家解释了一些基本概念。\n\n我们选择任意多个整数  $b_i$  满足\n\n $$1 \\leq b_1 < b_2 < \\dots < b_{k-1} < b_k \\leq n$$ \n\n我们称  $a_{b_1}, a_{b_2}, \\cdots, a_{b_k} $  是  $a$  的一个子序列。\n\n如果这个子序列同时还满足\n\n $$a_{b_1} \\geq a_{b_2} \\geq \\cdots \\geq a_{b_{k-1}}\\geq a_{b_k}$$ \n\n我们称这个子序列是不上升的。\n\n组合数  $\\binom {n} {m} $  是从  $n$  个互不相同的元素中取  $m$  个元素的方案数，具体计算方案如下：\n\n $$\\binom {n}{m}=\\frac{n!}{m!(n-m)!}=\\frac{n \\times (n-1) \\times \\cdots \\times 2 \\times 1}{(m \\times (m-1) \\cdots \\times 2 \\times 1)((n-m)\\times(n-m-1)\\times \\cdots \\times 2 \\times 1)}$$ \n\n这里要特别注意，因为我们只考虑不上升子序列，所以在求组合数的过程中，一定满足  $n \\geq m$ ，也就是 $\\binom {a_{b_{i-1}}}{a_{b_i}}$ 中一定有 $a_{b_{i-1}} \\geq a_{b_i}$ 。\n\n我们在这里强调取模  $x \\mod y$  的定义：\n\n $x \\bmod y = x -\\left \\lfloor \\frac{x}{y} \\right \\rfloor \\times y$ \n\n其中  $\\left \\lfloor n \\right \\rfloor$  表示小于等于  $n$  的最大整数。\n\n $x \\bmod 2 > 0$  ，就是在说  $x$  是奇数。\n\n与此同时，经验告诉我们一个长度为  $n$  的序列，子序列个数有  $O(2^n)$  个，所以我们通过对答案取模来避免输出过大。\n\nB 君觉得 G 君说的十分有道理，于是再次强调了这些基本概念。\n\n最后， G 君听说这个题是作为 gift 送给大家，她有一句忠告。\n\n“Vorsicht, Gift!”\n\n“小心. . . . . .剧毒！ ”", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行一个整数，这 $n$ 行中的第 $i$ 行，表示 $a_i$。\n", "outputFormat": "一行一个整数表示答案。\n", "hint": "对于前 $10\\%$ 的测试点，$n \\leq 9$，$1\\leq a_i\\leq 13$。\n\n对于前 $20\\%$ 的测试点，$n\\leq 17$，$1\\leq a_i\\leq 20$。\n\n对于前 $40\\%$ 的测试点，$n\\leq 1911$，$1\\leq a_i\\leq 4000$。\n\n对于前 $70\\%$ 的测试点，$n\\leq 2017$。\n\n对于前 $85\\%$ 的测试点，$n\\leq 100084$。\n\n对于 $100\\%$ 的测试点，$1\\leq n\\leq 211985$，$1\\leq a_i\\leq 233333$。所有的 $a_i$ 互不相同，也就是说不存在 $i, j$ 同时满足 $1\\leq i < j\\leq n$ 和 $a_i = a_j$。\n", "locale": "zh-CN"}}}
{"pid": "P3774", "type": "P", "difficulty": 7, "samples": [["11 6\n9 6 3 1 5 12 8 4 2 2 2\n5 1\n7 2\n9 1\n9 2\n11 1\n11 11", "4 \n6 \n5 \n8 \n7\n11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "网络流", "O2优化", "杨表", "CTSC/CTS"], "title": "[CTSC2017] 最长上升子序列", "background": "", "description": "猪小侠最近学习了最长上升子序列的相关知识。对于一个整数序列 $A =(a_1, a_2,\\ldots , a_k)$，定义 $A$ 的子序列为：从 $A$ 中删除若干个元素后（允许不删，也允许将所有 $k$ 个元素都删除），剩下的元素按照原来的顺序所组成的序列。如果这个子序列的元素从左到右严格递增，则称它为 $A$ 的一个上升子序列。其中包含元素数量最多的上升子序列称为 $A$ 的最长上升子序列。例如，$(2, 4, 5, 6)$ 和 $(1, 4, 5, 6)$ 都是 $(2, 1, 1, 4, 7, 5, 6)$ 的最长上升子序列，长度都为 $4$。\n\n现在猪小侠遇到了这样一个问题：给定一个序列 $B_m = (b_1, b_2, \\ldots, b_m)$，设 $C$ 是 $B_m$ 的子序列，且 $C$ 的最长上升子序列的长度不超过 $k$，则 $C$ 的长度最大能是多少？\n\n猪小侠觉得这个问题太简单了，缺乏挑战，他决定提出一个更难的问题。于是他给了你这样一个序列 $B = (b_1, b_2,\\ldots , b_n)$，以及若干次询问。每次询问会给定两个整数 $m$ 和 $k$，你需要对于 $B$ 序列的前 $m$ 个元素构成的序列 $B_m = (b_1, b_2, \\ldots, b_m)$ 和 $k$ 回答上述问题。\n", "inputFormat": "第一行两个整数 $n, q$，其中 $n$ 是序列 $B$ 的长度，$q$ 是询问次数。\n\n第二行是空格隔开的 $n$ 个正整数 $b_1, b_2, \\ldots, b_n$。\n\n接下来 $q$ 行，其中第 $i$ 行包含两个整数 $m_i, k_i$，表示对 $m = m_i, k = k_i$ 进行询问。\n", "outputFormat": "输出共 $q$ 行，按顺序每行一个整数作为回答。\n", "hint": "【样例解释】\n\n询问 $1$：对于序列 $(9,6,3,1,5)$，可以选取子序列 $(9,6,3,1)$，它的最长上升子序列长度为 $1$。\n\n询问 $2$：对于序列 $(9,6,3,1,5,12,8)$，可以选取子序列 $(9,6,3,1,12,8)$，它的最长上升子序列长度为 $2$。\n\n询问 $3$：对于序列 $(9,6,3,1,5,12,8,4,2)$，可以选取子序列 $(9,6,5,4,2)$，它的最长上升子序列长度为 $1$。\n\n询问 $4$：对于序列 $(9,6,3,1,5,12,8,4,2)$，可以选取子序列 $(9,6,3,1,12,8,4,2)$，它的最长上升子序列长度为 $2$。\n\n询问 $5$：对于序列 $(9,6,3,1,5,12,8,4,2,2,2)$，可以选取子序列 $(9,6,5,4,2,2,2)$，它的最长上升子序列长度为 $1$。\n\n询问 $6$：对于序列 $(9,6,3,1,5,12,8,4,2,2,2)$，可以选取子序列 $(9,6,3,1,5,12,8,4,2,2,2)$，它的最长上升子序列长度为 $3$。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/5487.png) \n\n对于 $100\\%$ 的数据， $1\\leq n\\leq 5\\times 10^4$，$1\\leq b_i\\leq 5\\times 10^4$，$1\\leq q \\leq 2\\times 10^5$，$1\\leq k_i \\leq m_i \\leq n$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2017] Longest Increasing Subsequence", "background": "", "description": "Zhu Xiaoxia recently studied the longest increasing subsequence (LIS). For an integer sequence $A =(a_1, a_2,\\ldots , a_k)$, a subsequence of $A$ is defined as the sequence formed by deleting some elements from $A$ (deleting none or all $k$ elements is allowed) while keeping the remaining elements in their original order. If the elements of this subsequence are strictly increasing from left to right, it is called an increasing subsequence of $A$. Among them, an increasing subsequence with the largest number of elements is called a longest increasing subsequence of $A$. For example, $(2, 4, 5, 6)$ and $(1, 4, 5, 6)$ are both longest increasing subsequences of $(2, 1, 1, 4, 7, 5, 6)$, and their lengths are both $4$.\n\nNow Zhu Xiaoxia encounters the following problem: given a sequence $B_m = (b_1, b_2, \\ldots, b_m)$, let $C$ be a subsequence of $B_m$. If the length of the LIS of $C$ does not exceed $k$, what is the maximum possible length of $C$?\n\nZhu Xiaoxia thinks this problem is too easy and lacks challenge, so he proposes a harder one. He gives you a sequence $B = (b_1, b_2,\\ldots , b_n)$ and several queries. Each query gives two integers $m$ and $k$. For the sequence formed by the first $m$ elements of $B$, namely $B_m = (b_1, b_2, \\ldots, b_m)$, and the given $k$, you need to answer the problem above.", "inputFormat": "The first line contains two integers $n, q$, where $n$ is the length of the sequence $B$, and $q$ is the number of queries.\n\nThe second line contains $n$ space-separated positive integers $b_1, b_2, \\ldots, b_n$.\n\nThe next $q$ lines follow. The $i$-th line contains two integers $m_i, k_i$, representing a query with $m = m_i$ and $k = k_i$.", "outputFormat": "Output $q$ lines. For each query, print one integer as the answer, in order.", "hint": "Sample explanation:\n\nQuery $1$: For the sequence $(9,6,3,1,5)$, one may choose the subsequence $(9,6,3,1)$, whose LIS length is $1$.\n\nQuery $2$: For the sequence $(9,6,3,1,5,12,8)$, one may choose the subsequence $(9,6,3,1,12,8)$, whose LIS length is $2$.\n\nQuery $3$: For the sequence $(9,6,3,1,5,12,8,4,2)$, one may choose the subsequence $(9,6,5,4,2)$, whose LIS length is $1$.\n\nQuery $4$: For the sequence $(9,6,3,1,5,12,8,4,2)$, one may choose the subsequence $(9,6,3,1,12,8,4,2)$, whose LIS length is $2$.\n\nQuery $5$: For the sequence $(9,6,3,1,5,12,8,4,2,2,2)$, one may choose the subsequence $(9,6,5,4,2,2,2)$, whose LIS length is $1$.\n\nQuery $6$: For the sequence $(9,6,3,1,5,12,8,4,2,2,2)$, one may choose the subsequence $(9,6,3,1,5,12,8,4,2,2,2)$, whose LIS length is $3$.\n\n![](https://cdn.luogu.com.cn/upload/pic/5487.png)\n\nConstraints:\nFor $100\\%$ of the testdata, $1 \\le n \\le 5 \\times 10^4$, $1 \\le b_i \\le 5 \\times 10^4$, $1 \\le q \\le 2 \\times 10^5$, $1 \\le k_i \\le m_i \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2017] 最长上升子序列", "background": "", "description": "猪小侠最近学习了最长上升子序列的相关知识。对于一个整数序列 $A =(a_1, a_2,\\ldots , a_k)$，定义 $A$ 的子序列为：从 $A$ 中删除若干个元素后（允许不删，也允许将所有 $k$ 个元素都删除），剩下的元素按照原来的顺序所组成的序列。如果这个子序列的元素从左到右严格递增，则称它为 $A$ 的一个上升子序列。其中包含元素数量最多的上升子序列称为 $A$ 的最长上升子序列。例如，$(2, 4, 5, 6)$ 和 $(1, 4, 5, 6)$ 都是 $(2, 1, 1, 4, 7, 5, 6)$ 的最长上升子序列，长度都为 $4$。\n\n现在猪小侠遇到了这样一个问题：给定一个序列 $B_m = (b_1, b_2, \\ldots, b_m)$，设 $C$ 是 $B_m$ 的子序列，且 $C$ 的最长上升子序列的长度不超过 $k$，则 $C$ 的长度最大能是多少？\n\n猪小侠觉得这个问题太简单了，缺乏挑战，他决定提出一个更难的问题。于是他给了你这样一个序列 $B = (b_1, b_2,\\ldots , b_n)$，以及若干次询问。每次询问会给定两个整数 $m$ 和 $k$，你需要对于 $B$ 序列的前 $m$ 个元素构成的序列 $B_m = (b_1, b_2, \\ldots, b_m)$ 和 $k$ 回答上述问题。\n", "inputFormat": "第一行两个整数 $n, q$，其中 $n$ 是序列 $B$ 的长度，$q$ 是询问次数。\n\n第二行是空格隔开的 $n$ 个正整数 $b_1, b_2, \\ldots, b_n$。\n\n接下来 $q$ 行，其中第 $i$ 行包含两个整数 $m_i, k_i$，表示对 $m = m_i, k = k_i$ 进行询问。\n", "outputFormat": "输出共 $q$ 行，按顺序每行一个整数作为回答。\n", "hint": "【样例解释】\n\n询问 $1$：对于序列 $(9,6,3,1,5)$，可以选取子序列 $(9,6,3,1)$，它的最长上升子序列长度为 $1$。\n\n询问 $2$：对于序列 $(9,6,3,1,5,12,8)$，可以选取子序列 $(9,6,3,1,12,8)$，它的最长上升子序列长度为 $2$。\n\n询问 $3$：对于序列 $(9,6,3,1,5,12,8,4,2)$，可以选取子序列 $(9,6,5,4,2)$，它的最长上升子序列长度为 $1$。\n\n询问 $4$：对于序列 $(9,6,3,1,5,12,8,4,2)$，可以选取子序列 $(9,6,3,1,12,8,4,2)$，它的最长上升子序列长度为 $2$。\n\n询问 $5$：对于序列 $(9,6,3,1,5,12,8,4,2,2,2)$，可以选取子序列 $(9,6,5,4,2,2,2)$，它的最长上升子序列长度为 $1$。\n\n询问 $6$：对于序列 $(9,6,3,1,5,12,8,4,2,2,2)$，可以选取子序列 $(9,6,3,1,5,12,8,4,2,2,2)$，它的最长上升子序列长度为 $3$。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/5487.png) \n\n对于 $100\\%$ 的数据， $1\\leq n\\leq 5\\times 10^4$，$1\\leq b_i\\leq 5\\times 10^4$，$1\\leq q \\leq 2\\times 10^5$，$1\\leq k_i \\leq m_i \\leq n$。\n", "locale": "zh-CN"}}}
{"pid": "P3775", "type": "P", "difficulty": 7, "samples": [["2 1\n0 0 0\n1 1 0\n0 1 0\n1 0 0\n-1 -1", "0.70710678118655"], ["4 2\n0 0 0\n0 1 1\n1 0 1\n1 1 0\n0 0 1\n0 1 0\n1 0 0\n1 1 1\n-1 -1", "0.73883404559321"]], "limits": {"time": [1000, 1000, 2000, 2000, 3000, 3000, 4000, 4000, 5000, 5000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "Special Judge", "O2优化", "CTSC/CTS"], "title": "[CTSC2017] 投影", "background": "无", "description": "换一个角度看，世界可能就不同。 —— 小强\n\nk 维空间中有 n 个黑点与 n 个白点。我们为每一个黑点确定一个互不相同的对应的白点，这样一共有 n! 种对应方法。我们定义这 n 个黑点与 n 个白点之间的 “移动距离”为，在所有的对应方法中，对应的黑点与白点之间的 n 个欧几里德距离的和的最小值。\n\n例如; 考虑一维中的三个黑点 {1,5,6} 与三个白点 {2,3,4}，那么它们之间的移动距离为; |1 − 2| + |5 − 3| + |6 − 4| = 4。你可以验证一下这确实是距离和最小的一种对应方法。\n你得到了三维空间中的 n 个黑点与 n 个白点。你想把它们投影到一个 k(1 ≤ k ≤ 2)维子空间上。一维子空间就是三维空间中的一条直线，二维子空间则是三维空间中的一个平面。一个点在一个子空间中的投影点就是这个子空间中距离它最近的点。例如，(0, 0, 0), (1, 1, 0), (1, 0, 0), (0, 1, 0) 这四个点投影到 x − y = 0,z = 0 这条直线上之后，得到的投影点是 (0, 0, 0), (1, 1, 0), (0;5, 0;5, 0), (0;5, 0;5, 0)。\n\n你希望这 n 个黑点和 n 个白点投影到这个 k 维子空间之后的移动距离最大。请你计算这个最大值除以 n。\n", "inputFormat": "每个测试文件中可能有多个测试用例，每个测试用例的格式如下：\n\n第一行两个数 n 和 k，表示点数以及降到的维度。\n\n后面 2n 行，每行三个数，表示点的坐标。\n\n文件最后有一行包含两个数 −1 − 1。\n", "outputFormat": "对文件中的每个测试用例，输出一行一个数 (长度不要超过 30)，表示结果。\n\n你的答案与参考答案的相对误差不超过 10^−7 时被认为是正确的。\n\n只有一个文件中所有的测试用例的结果都是正确的才能获得这个测试文件所对应的分数。\n", "hint": "对于 30% 的数据， k = 1， n ≤ 1000, 所有的点的 z 都是 0。一个文件中最多包含一个测试用例。\n\n对于另外 40% 的数据， k = 1， n ≤ 1000，所有的点的坐标都是 [−1, 1] 之间均匀独立随机生成的，一个文件中最多包含十个测试用例。\n\n对于另外 30% 的数据， k = 2， n ≤ 20，所有的点的坐标都是 [−1, 1] 之间均匀独立随机生成的，一个文件中最多包含十个测试用例。\n\n对于 100% 的数据，点的坐标的范围都是 −1 到 +1 之间的，答案不小于 0.01。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2017] Projection", "background": "None.", "description": "", "inputFormat": "", "outputFormat": "For each test case in the file, output one number on a single line (its length should not exceed 30), representing the result.\n\nYour answer will be considered correct if its relative error does not exceed $10^{-7}$ compared to the reference answer.\n\nYou will receive points for a test file only if all test cases in that file are answered correctly.", "hint": "- For 30% of the testdata, $k = 1$, $n \\le 1000$, and all points have $z = 0$. At most one test case appears in a file.\n- For another 40% of the testdata, $k = 1$, $n \\le 1000$, and all point coordinates are independently and uniformly generated in $[-1, 1]$. At most ten test cases appear in a file.\n- For the remaining 30% of the testdata, $k = 2$, $n \\le 20$, and all point coordinates are independently and uniformly generated in $[-1, 1]$. At most ten test cases appear in a file.\n- For 100% of the testdata, all coordinates lie in $[-1, 1]$, and the answer is at least $0.01$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2017] 投影", "background": "无", "description": "换一个角度看，世界可能就不同。 —— 小强\n\nk 维空间中有 n 个黑点与 n 个白点。我们为每一个黑点确定一个互不相同的对应的白点，这样一共有 n! 种对应方法。我们定义这 n 个黑点与 n 个白点之间的 “移动距离”为，在所有的对应方法中，对应的黑点与白点之间的 n 个欧几里德距离的和的最小值。\n\n例如; 考虑一维中的三个黑点 {1,5,6} 与三个白点 {2,3,4}，那么它们之间的移动距离为; |1 − 2| + |5 − 3| + |6 − 4| = 4。你可以验证一下这确实是距离和最小的一种对应方法。\n你得到了三维空间中的 n 个黑点与 n 个白点。你想把它们投影到一个 k(1 ≤ k ≤ 2)维子空间上。一维子空间就是三维空间中的一条直线，二维子空间则是三维空间中的一个平面。一个点在一个子空间中的投影点就是这个子空间中距离它最近的点。例如，(0, 0, 0), (1, 1, 0), (1, 0, 0), (0, 1, 0) 这四个点投影到 x − y = 0,z = 0 这条直线上之后，得到的投影点是 (0, 0, 0), (1, 1, 0), (0;5, 0;5, 0), (0;5, 0;5, 0)。\n\n你希望这 n 个黑点和 n 个白点投影到这个 k 维子空间之后的移动距离最大。请你计算这个最大值除以 n。\n", "inputFormat": "每个测试文件中可能有多个测试用例，每个测试用例的格式如下：\n\n第一行两个数 n 和 k，表示点数以及降到的维度。\n\n后面 2n 行，每行三个数，表示点的坐标。\n\n文件最后有一行包含两个数 −1 − 1。\n", "outputFormat": "对文件中的每个测试用例，输出一行一个数 (长度不要超过 30)，表示结果。\n\n你的答案与参考答案的相对误差不超过 10^−7 时被认为是正确的。\n\n只有一个文件中所有的测试用例的结果都是正确的才能获得这个测试文件所对应的分数。\n", "hint": "对于 30% 的数据， k = 1， n ≤ 1000, 所有的点的 z 都是 0。一个文件中最多包含一个测试用例。\n\n对于另外 40% 的数据， k = 1， n ≤ 1000，所有的点的坐标都是 [−1, 1] 之间均匀独立随机生成的，一个文件中最多包含十个测试用例。\n\n对于另外 30% 的数据， k = 2， n ≤ 20，所有的点的坐标都是 [−1, 1] 之间均匀独立随机生成的，一个文件中最多包含十个测试用例。\n\n对于 100% 的数据，点的坐标的范围都是 −1 到 +1 之间的，答案不小于 0.01。\n", "locale": "zh-CN"}}}
