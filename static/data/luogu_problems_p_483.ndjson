{"pid": "P10795", "type": "P", "difficulty": 6, "samples": [["3\n1 2 3\n1 3 5\n1 2\n2 3", "10"], ["5\n1 3 5 8 10\n1 5 3 2 8\n2 1\n3 1\n4 1\n5 3", "22"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["点分治", "树上启发式合并", "Kruskal 重构树", "O2优化", "线段树合并"], "title": "『SpOI - R1』Lamborghini (Demo)", "background": "", "description": "给你一棵无根树，每个点 $i$ 有两个属性 $t_i,v_i$。\n\n定义有向路径 $i\\to j$ 的 $f_{i,j}$ 为：\n\n- 若 $i\\to j$ 上 $t_x$ 最小的点为 $x$ 且 $v_j\\leq v_x\\leq v_i$，则 $f_{i,j}=x$。\n- 否则，$f_{i,j}=0$。\n\n求 $\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^n f_{i,j}$。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个以空格分隔的整数，第 $i$ 项表示点 $i$ 的 $t_i$。\n\n第三行 $n$ 个以空格分隔的整数，第 $i$ 项表示点 $i$ 的 $v_i$。\n\n接下来 $n-1$ 行，每行两个整数 $a,b$，表示一条树边 $a\\leftrightarrow b$。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "#### 样例 #1 解释\n\n- $f(1,1)=1$。\n- $f(1,2)=0$。\n- $f(1,3)=0$。\n- $f(2,1)=1$。\n- $f(2,2)=2$。\n- $f(2,3)=0$。\n- $f(3,1)=1$。\n- $f(3,2)=2$。\n- $f(3,3)=3$。\n\n故 $\\sum\\limits_{i=1}^3\\sum\\limits_{j=1}^3 f(i,j)=10$。\n\n### 数据范围\n\n**本题开启子任务捆绑与子任务依赖。**\n\n对于 $100\\%$ 的数据，$t$ 互不相同，$1\\leq n\\leq 10^5$，$1\\leq t_i,v_i\\leq 10^9$。\n\n| Subtask | $n\\leq$ | $t_i,v_i\\leq$ | 特殊性质 | 得分 | 子任务依赖 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| 1 | $300$ | $10^5$ | 无 | $15$ | 无 |\n| 2 | $5000$ | $10^5$ | 无 | $15$ | 1 |\n| 3 | $10^5$ | $10^9$ | $A$ | $15$ | 无 |\n| 4 | $10^5$ | $10^9$ | $B$ | $15$ | 无 |\n| 5 | $10^5$ | $10^9$ | 无 | $40$ | 1,2,3,4 |\n\n特殊性质 $A$：**钦定 $1$ 号节点为树的根**，对于任意点对 $(x,y)$ 且 $x\\neq y$，若 $x$ 是 $y$ 的祖先，则 $t_x<t_y$。\n\n特殊性质 $B$：$\\forall i\\in[1,n),a_i=i,b_i=i+1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『SpOI - R1』Lamborghini (Demo)", "background": "", "description": "给你一棵无根树，每个点 $i$ 有两个属性 $t_i,v_i$。\n\n定义有向路径 $i\\to j$ 的 $f_{i,j}$ 为：\n\n- 若 $i\\to j$ 上 $t_x$ 最小的点为 $x$ 且 $v_j\\leq v_x\\leq v_i$，则 $f_{i,j}=x$。\n- 否则，$f_{i,j}=0$。\n\n求 $\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^n f_{i,j}$。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个以空格分隔的整数，第 $i$ 项表示点 $i$ 的 $t_i$。\n\n第三行 $n$ 个以空格分隔的整数，第 $i$ 项表示点 $i$ 的 $v_i$。\n\n接下来 $n-1$ 行，每行两个整数 $a,b$，表示一条树边 $a\\leftrightarrow b$。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "#### 样例 #1 解释\n\n- $f(1,1)=1$。\n- $f(1,2)=0$。\n- $f(1,3)=0$。\n- $f(2,1)=1$。\n- $f(2,2)=2$。\n- $f(2,3)=0$。\n- $f(3,1)=1$。\n- $f(3,2)=2$。\n- $f(3,3)=3$。\n\n故 $\\sum\\limits_{i=1}^3\\sum\\limits_{j=1}^3 f(i,j)=10$。\n\n### 数据范围\n\n**本题开启子任务捆绑与子任务依赖。**\n\n对于 $100\\%$ 的数据，$t$ 互不相同，$1\\leq n\\leq 10^5$，$1\\leq t_i,v_i\\leq 10^9$。\n\n| Subtask | $n\\leq$ | $t_i,v_i\\leq$ | 特殊性质 | 得分 | 子任务依赖 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| 1 | $300$ | $10^5$ | 无 | $15$ | 无 |\n| 2 | $5000$ | $10^5$ | 无 | $15$ | 1 |\n| 3 | $10^5$ | $10^9$ | $A$ | $15$ | 无 |\n| 4 | $10^5$ | $10^9$ | $B$ | $15$ | 无 |\n| 5 | $10^5$ | $10^9$ | 无 | $40$ | 1,2,3,4 |\n\n特殊性质 $A$：**钦定 $1$ 号节点为树的根**，对于任意点对 $(x,y)$ 且 $x\\neq y$，若 $x$ 是 $y$ 的祖先，则 $t_x<t_y$。\n\n特殊性质 $B$：$\\forall i\\in[1,n),a_i=i,b_i=i+1$。", "locale": "zh-CN"}}}
{"pid": "P10796", "type": "P", "difficulty": 6, "samples": [["3\n2 1 0\naa\n6 1\n2 -1\n3 2\n1 0 2\n19 0 0\nhappythbirthdayshun\n1000000000 8\n1000000000 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 0\n1 1\n1 0\n1 0\n5 6 1\nacbac\n1 3\n2 4\n1 -5\n3 6\n2 -3\n3 1\n11 10 12\n9 13 108\n8 12 8\n10 9 0\n6 1 4\n4 7 1", "1\n0\n17\n9\n8\n-9\n8\n-4\n-5\n-5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "线段树", "O2优化", "树链剖分", "KMP 算法"], "title": "『SpOI - R1』我看到了，谢谢你们", "background": "", "description": "**本题包含多组测试。**\n\n**特别注意：本题中，border 的定义有所不同。对于串 $s,t$，若同时存在 $s$ 的一对前缀后缀（可空也可为 $s$ 本身）等于 $t$，则 $t$ 是 $s$ 的 border。**\n\n有一个长度为 $n$ 的字符串 $S$。我们使用这个串上的信息来选举总统。\n\n令 $p_i$ 表示 $S$ 的 $i$ 长前缀，特别地，$p_0$ 表示包含第 $0$ 位的空前缀。现在有 $n+1$ 位候选人站在这 $n+1$ 个前缀上，编号为 $[0,n]$，编号为 $i$ 的人对应前缀 $i$。每个人有一个票数 $a_i$ 和花费 $w_i$。\n\n得票数量**严格**超过总票数一半的人可以当选总统。\n\n初始时所有人都处于**未被控制**状态。每一个时刻，任何一个**未被控制**且**之前一直在等待**的人 $i$ 都可以做出三种选择之一：\n\n1. 进行一次**对 $v$ 投票**操作：将自己的 $a_i$ 票花费 $w_i$ 的代价投给人 $v$。\n2. 进行一次**对 $v$ 揽票**操作：\n\t- 花费 $w_i$ 选中人 $v$，需要满足 $p_i$ 是 $p_v$ 的一个 border。\n\t- $\\forall j\\in[0,n]$，若 $p_v$ 是 $p_j$ 的一个 border，且 $j$ 在此时刻**未被控制**，则 $j$ 下一时刻变为**被控制**，他的 $a_j$ 票都花费 $w_j$ 投给 $i$。\n3. 等待下一个时刻。\n\n每个候选人都希望其他人不会成为总统，且都是绝顶聪明的。**特别地**，当他们的操作出现了交叉导致一个人的票需要投给多人时，被交叉者的票可以分别独立投出并都有效（你可以理解为他的票分裂了）。因此，总统可能有多个。\n\n你可以干涉这个过程。具体来说，你可以在 $0$ 时刻操作一个候选人 $x$，让 $x$ 进行指定的一种选择，并钦定选择涉及的所有变量。$x$ 此后不能再做任何选择，剩下的人必须从 $1$ 时刻再开始选择。你干涉的代价就是 $x$ 这次选择的总花费。\n\n票数 $a$ 和花费 $w$ 都会发生 $q$ 次变化。\n\n每一次变化会改变票数 $a$ 中的某一项或是花费 $w$ 中的某一项。票数 $a$ 可能会变为任意正整数，花费 $w$ 只会变小或者不变。\n\n在每次变化之后，你都需要找到这样一个人 $x$，满足你有一种干涉他的方案使得他一定可以成为总统，且你干涉的代价最小。你只需要输出这个最小代价。\n\n可以证明一定存在这样的人。\n\n本题**强制在线**。", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n一行三个整数 $n,q,type$，表示字符串长度、修改次数、是否强制在线。\n\n接下来一行一个长度为 $n$ 的字符串 $S$。保证 $S$ 中只含有小写英文字母。\n\n接下来 $n+1$ 行，每行两个整数 $a_i,w_i$，依次表示候选人 $0$ 到 $n$ 的初始票数和花费。\n\n接下来 $q$ 行，每行三个整数 $o',p',x'$。设 $lst$ 表示上一次输出的答案的绝对值，则 $o\\gets o'\\oplus(type\\times lst),p\\gets p'\\oplus(type\\times lst),x\\gets (|x'|\\oplus(type\\times lst))\\times (-1)^{[x'\\leq 0]}$（其中 $[x'\\leq 0]$ 为[艾佛森括号](https://baike.baidu.com/item/%E8%89%BE%E4%BD%9B%E6%A3%AE%E6%8B%AC%E5%8F%B7/22361197)），然后：\n\n1. $o=1$ 时，将 $a_p$ 修改为 $x$。\n2. $o=2$ 时，将 $w_p$ 修改为 $w_p'=x$。保证 $w_p\\geq w_p'$。", "outputFormat": "共 $q+1$ 行。\n\n第一行输出在初始状态下你干涉的最小代价。\n\n之后，在每次修改后输出你此时干涉的最小代价，共 $q$ 行。", "hint": "#### 样例 #1 解释\n\n对于第一组数据：\n\n考虑第一次修改之前。全场共有 $11$ 票，则当选总统需要 $>5.5$ 票。\n\n干涉 $0$ 号候选人，且选择第一种选择，使用 $w_0=1$ 的花费进行一次**对 $0$ 投票**操作后，$0$ 号候选人得到 $6$ 票，直接达到了总统要求，可以证明这是花费最小的答案。\n\n第一次修改后，全场共有 $7$ 票，则当选总统需要 $>3.5$ 票。\n\n干涉 $1$ 号候选人，且选择第二种选择，进行一次**对 $1$ 揽票**操作后，$1$ 号候选人将得到 $5$ 票，总花费为 $-1+(-1)+2=0$。他直接达到了总统要求，可以证明这是花费最小的答案。\n\n对于第三组数据，去掉强制在线后的修改操作为：\n\n- $o=2,p=3,x=5$；\n- $o=1,p=5,x=100$；\n- $o=1,p=5,x=1$；\n- $o=2,p=1,x=-8$；\n- $o=2,p=5,x=0$；\n- $o=1,p=2,x=4$。\n\n### 数据范围\n\n**请注意常数因子对程序效率的影响。**\n\n**本题开启子任务捆绑与子任务依赖。**\n\n对于 $100\\%$ 的数据，$1\\leq T\\leq 2000$，$1\\leq n\\leq 10^5$，$0\\leq q\\leq 10^5$，$0\\leq type\\leq 1$，且在任何时候都保证 $1\\leq a_i\\leq 2\\times 10^9$，$|w_i|\\leq 2\\times 10^9$。\n\n保证字符串中只含有小写字母。\n\n对于任意一次修改，保证 $o$ 为 $1$ 或 $2$，且 $0\\leq p\\leq n$。在 $o=1$ 时，$1\\leq x\\leq 2\\times 10^9$；$o=2$ 时，$0\\leq |x|\\leq 2\\times 10^9$。\n\n特别地，$w_i$ 中的每一项在被操作的过程中一定单调不递增。\n\n| Subtask | $T\\leq$ | $n,q\\leq$ | $a_i,\\lvert w_i\\rvert \\leq$ | 特殊性质 | 得分 | 子任务依赖 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| 1 | $2000$ | $20$ | $10^5$ | 无 | $5$ | 无 |\n| 2 | $2000$ | $200$ | $10^5$ | 无 | $10$ | 1 |\n| 3 | $3$ | $10^5$ | $2\\times 10^9$ | $A$ | $15$ | 无 |\n| 4 | $3$ | $10^5$ | $2\\times 10^9$ | $B$ | $5$ | 无 |\n| 5 | $3$ | $10^5$ | $2\\times 10^9$ | $C$ | $15$ | 无 |\n| 6 | $3$ | $10^5$ | $2\\times 10^9$ | $D$ | $20$ | 无 |\n| 7 | $3$ | $10^5$ | $2\\times 10^9$ | 无 | $30$ | 1,2,3,4,5,6 |\n\n特殊性质 $A$：保证 $o\\neq 2$。\n\n特殊性质 $B$：保证字符串中的每一个字符都在 $26$ 个小写字母中独立均匀随机。\n\n特殊性质 $C$：字符串中只含有 $\\texttt{a}$。\n\n特殊性质 $D$：保证 $type=0$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『SpOI - R1』我看到了，谢谢你们", "background": "", "description": "**本题包含多组测试。**\n\n**特别注意：本题中，border 的定义有所不同。对于串 $s,t$，若同时存在 $s$ 的一对前缀后缀（可空也可为 $s$ 本身）等于 $t$，则 $t$ 是 $s$ 的 border。**\n\n有一个长度为 $n$ 的字符串 $S$。我们使用这个串上的信息来选举总统。\n\n令 $p_i$ 表示 $S$ 的 $i$ 长前缀，特别地，$p_0$ 表示包含第 $0$ 位的空前缀。现在有 $n+1$ 位候选人站在这 $n+1$ 个前缀上，编号为 $[0,n]$，编号为 $i$ 的人对应前缀 $i$。每个人有一个票数 $a_i$ 和花费 $w_i$。\n\n得票数量**严格**超过总票数一半的人可以当选总统。\n\n初始时所有人都处于**未被控制**状态。每一个时刻，任何一个**未被控制**且**之前一直在等待**的人 $i$ 都可以做出三种选择之一：\n\n1. 进行一次**对 $v$ 投票**操作：将自己的 $a_i$ 票花费 $w_i$ 的代价投给人 $v$。\n2. 进行一次**对 $v$ 揽票**操作：\n\t- 花费 $w_i$ 选中人 $v$，需要满足 $p_i$ 是 $p_v$ 的一个 border。\n\t- $\\forall j\\in[0,n]$，若 $p_v$ 是 $p_j$ 的一个 border，且 $j$ 在此时刻**未被控制**，则 $j$ 下一时刻变为**被控制**，他的 $a_j$ 票都花费 $w_j$ 投给 $i$。\n3. 等待下一个时刻。\n\n每个候选人都希望其他人不会成为总统，且都是绝顶聪明的。**特别地**，当他们的操作出现了交叉导致一个人的票需要投给多人时，被交叉者的票可以分别独立投出并都有效（你可以理解为他的票分裂了）。因此，总统可能有多个。\n\n你可以干涉这个过程。具体来说，你可以在 $0$ 时刻操作一个候选人 $x$，让 $x$ 进行指定的一种选择，并钦定选择涉及的所有变量。$x$ 此后不能再做任何选择，剩下的人必须从 $1$ 时刻再开始选择。你干涉的代价就是 $x$ 这次选择的总花费。\n\n票数 $a$ 和花费 $w$ 都会发生 $q$ 次变化。\n\n每一次变化会改变票数 $a$ 中的某一项或是花费 $w$ 中的某一项。票数 $a$ 可能会变为任意正整数，花费 $w$ 只会变小或者不变。\n\n在每次变化之后，你都需要找到这样一个人 $x$，满足你有一种干涉他的方案使得他一定可以成为总统，且你干涉的代价最小。你只需要输出这个最小代价。\n\n可以证明一定存在这样的人。\n\n本题**强制在线**。", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n一行三个整数 $n,q,type$，表示字符串长度、修改次数、是否强制在线。\n\n接下来一行一个长度为 $n$ 的字符串 $S$。保证 $S$ 中只含有小写英文字母。\n\n接下来 $n+1$ 行，每行两个整数 $a_i,w_i$，依次表示候选人 $0$ 到 $n$ 的初始票数和花费。\n\n接下来 $q$ 行，每行三个整数 $o',p',x'$。设 $lst$ 表示上一次输出的答案的绝对值，则 $o\\gets o'\\oplus(type\\times lst),p\\gets p'\\oplus(type\\times lst),x\\gets (|x'|\\oplus(type\\times lst))\\times (-1)^{[x'\\leq 0]}$（其中 $[x'\\leq 0]$ 为[艾佛森括号](https://baike.baidu.com/item/%E8%89%BE%E4%BD%9B%E6%A3%AE%E6%8B%AC%E5%8F%B7/22361197)），然后：\n\n1. $o=1$ 时，将 $a_p$ 修改为 $x$。\n2. $o=2$ 时，将 $w_p$ 修改为 $w_p'=x$。保证 $w_p\\geq w_p'$。", "outputFormat": "共 $q+1$ 行。\n\n第一行输出在初始状态下你干涉的最小代价。\n\n之后，在每次修改后输出你此时干涉的最小代价，共 $q$ 行。", "hint": "#### 样例 #1 解释\n\n对于第一组数据：\n\n考虑第一次修改之前。全场共有 $11$ 票，则当选总统需要 $>5.5$ 票。\n\n干涉 $0$ 号候选人，且选择第一种选择，使用 $w_0=1$ 的花费进行一次**对 $0$ 投票**操作后，$0$ 号候选人得到 $6$ 票，直接达到了总统要求，可以证明这是花费最小的答案。\n\n第一次修改后，全场共有 $7$ 票，则当选总统需要 $>3.5$ 票。\n\n干涉 $1$ 号候选人，且选择第二种选择，进行一次**对 $1$ 揽票**操作后，$1$ 号候选人将得到 $5$ 票，总花费为 $-1+(-1)+2=0$。他直接达到了总统要求，可以证明这是花费最小的答案。\n\n对于第三组数据，去掉强制在线后的修改操作为：\n\n- $o=2,p=3,x=5$；\n- $o=1,p=5,x=100$；\n- $o=1,p=5,x=1$；\n- $o=2,p=1,x=-8$；\n- $o=2,p=5,x=0$；\n- $o=1,p=2,x=4$。\n\n### 数据范围\n\n**请注意常数因子对程序效率的影响。**\n\n**本题开启子任务捆绑与子任务依赖。**\n\n对于 $100\\%$ 的数据，$1\\leq T\\leq 2000$，$1\\leq n\\leq 10^5$，$0\\leq q\\leq 10^5$，$0\\leq type\\leq 1$，且在任何时候都保证 $1\\leq a_i\\leq 2\\times 10^9$，$|w_i|\\leq 2\\times 10^9$。\n\n保证字符串中只含有小写字母。\n\n对于任意一次修改，保证 $o$ 为 $1$ 或 $2$，且 $0\\leq p\\leq n$。在 $o=1$ 时，$1\\leq x\\leq 2\\times 10^9$；$o=2$ 时，$0\\leq |x|\\leq 2\\times 10^9$。\n\n特别地，$w_i$ 中的每一项在被操作的过程中一定单调不递增。\n\n| Subtask | $T\\leq$ | $n,q\\leq$ | $a_i,\\lvert w_i\\rvert \\leq$ | 特殊性质 | 得分 | 子任务依赖 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| 1 | $2000$ | $20$ | $10^5$ | 无 | $5$ | 无 |\n| 2 | $2000$ | $200$ | $10^5$ | 无 | $10$ | 1 |\n| 3 | $3$ | $10^5$ | $2\\times 10^9$ | $A$ | $15$ | 无 |\n| 4 | $3$ | $10^5$ | $2\\times 10^9$ | $B$ | $5$ | 无 |\n| 5 | $3$ | $10^5$ | $2\\times 10^9$ | $C$ | $15$ | 无 |\n| 6 | $3$ | $10^5$ | $2\\times 10^9$ | $D$ | $20$ | 无 |\n| 7 | $3$ | $10^5$ | $2\\times 10^9$ | 无 | $30$ | 1,2,3,4,5,6 |\n\n特殊性质 $A$：保证 $o\\neq 2$。\n\n特殊性质 $B$：保证字符串中的每一个字符都在 $26$ 个小写字母中独立均匀随机。\n\n特殊性质 $C$：字符串中只含有 $\\texttt{a}$。\n\n特殊性质 $D$：保证 $type=0$。", "locale": "zh-CN"}}}
{"pid": "P10797", "type": "P", "difficulty": 3, "samples": [["1\n2 1", "3"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "位运算"], "title": "「CZOI-R1」进制", "background": "", "description": "你有一个数 $x$，你需要对它进行 $n$ 次操作。\n\n每次操作，你可以选择 $y$ 进制下的数 $x$ 的某**一个**有效位上数值增加 $1$。  \n第一个非零数位及其后面的数位是有效位。\n\n注意：\n* **对于每次操作**，你可以任意取 $y\\in[2,+\\infty)$；\n* 你需保证增加操作不会使 $y$ 进制下的数 $x$ 产生进位。\n\n现在你需要求 $n$ 次操作后这个数最大是多少。\n\n答案以十进制输出，并对 $10^9+7$ 取模。你需要输出的是这个数的最大值对 $10^9+7$ 取模的结果，而并非对 $10^9+7$ 取模后的最大值。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行两个整数 $x,n$，分别表示初始数字、操作次数。", "outputFormat": "对于每组测试数据，输出一行一个整数，表示 $x$ 进行 $n$ 次操作后的最大值。", "hint": "**【样例解释】**\n\n很明显，$2$ 在二进制时为 $10$，在三或更高进制时为 $2$。\n\n二进制时，在第一位 $+1$ 会导致二进制产生进位，只能在第二位 $+1$，此时得到的结果为 $11$，转换为十进制为 $3$。\n\n在三或更高进制时，只能往末位 $+1$，三进制下会产生进位，舍去。四或更高进制时得到结果均为 $3$，转化为十进制的结果也是 $3$。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n- Subtask #1（$20\\text{ pts}$）：$x\\le 2$。\n- Subtask #2（$20\\text{ pts}$）：$n=1$。\n- Subtask #3（$60\\text{ pts}$）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le x,n\\le10^9$，$1\\le T\\le10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「CZOI-R1」进制", "background": "", "description": "你有一个数 $x$，你需要对它进行 $n$ 次操作。\n\n每次操作，你可以选择 $y$ 进制下的数 $x$ 的某**一个**有效位上数值增加 $1$。  \n第一个非零数位及其后面的数位是有效位。\n\n注意：\n* **对于每次操作**，你可以任意取 $y\\in[2,+\\infty)$；\n* 你需保证增加操作不会使 $y$ 进制下的数 $x$ 产生进位。\n\n现在你需要求 $n$ 次操作后这个数最大是多少。\n\n答案以十进制输出，并对 $10^9+7$ 取模。你需要输出的是这个数的最大值对 $10^9+7$ 取模的结果，而并非对 $10^9+7$ 取模后的最大值。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行两个整数 $x,n$，分别表示初始数字、操作次数。", "outputFormat": "对于每组测试数据，输出一行一个整数，表示 $x$ 进行 $n$ 次操作后的最大值。", "hint": "**【样例解释】**\n\n很明显，$2$ 在二进制时为 $10$，在三或更高进制时为 $2$。\n\n二进制时，在第一位 $+1$ 会导致二进制产生进位，只能在第二位 $+1$，此时得到的结果为 $11$，转换为十进制为 $3$。\n\n在三或更高进制时，只能往末位 $+1$，三进制下会产生进位，舍去。四或更高进制时得到结果均为 $3$，转化为十进制的结果也是 $3$。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n- Subtask #1（$20\\text{ pts}$）：$x\\le 2$。\n- Subtask #2（$20\\text{ pts}$）：$n=1$。\n- Subtask #3（$60\\text{ pts}$）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le x,n\\le10^9$，$1\\le T\\le10^6$。", "locale": "zh-CN"}}}
{"pid": "P10798", "type": "P", "difficulty": 4, "samples": [["8\n3 2 1 2 3 -1 3 3", "2"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "O2优化", "ST 表", "单调栈"], "title": "「CZOI-R1」消除威胁", "background": "**本题数据已修复。**", "description": "给定一个序列 $\\{A_n\\}$。\n\n我们称序列 $A$ 中的一个区间 $[l,r]$ 具有威胁，当且仅当 $1\\le l<r\\le n$ 且 $A_l=A_r$，且 $\\forall i\\in[l,r]$ 满足 $|A_i|\\le|A_l|$。\n\n你可以操作 $A$ 任意次，每次操作选择一个 $A_i$ 修改为 $-A_i$。请问最后序列 $A$ 中具有威胁的**不同**区间**最少**有多少个？\n\n\n\n两个区间 $[l_1,r_1]$ 和 $[l_2,r_2]$ 不同，当且仅当 $l_1 \\ne l_2$ 或 $r_1 \\ne r_2$。\n\n", "inputFormat": "第一行一个整数 $n$ ，表示 $A$ 的长度。\n\n第二行 $n$ 个整数，表示 $\\{A_n\\}$。", "outputFormat": "第一行一个正整数，表示**最少**的具有威胁的区间个数。", "hint": "**【数据范围】**\n\n**本题采用捆绑测试**。\n- Subtask #1（$10\\text{ pts}$）：$n\\le10$。\n- Subtask #2（$10\\text{ pts}$）：$n\\le10^3$。\n- Subtask #3（$10\\text{ pts}$）：$|A_i|\\le60$。\n- Subtask #4（$10\\text{ pts}$）：$|A_i|$ 均相等。\n- Subtask #5（$20\\text{ pts}$）：$n\\le10^5$。\n- Subtask #6（$40\\text{ pts}$）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le n\\le5\\times10^5$，$|A_i|\\le10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「CZOI-R1」消除威胁", "background": "**本题数据已修复。**", "description": "给定一个序列 $\\{A_n\\}$。\n\n我们称序列 $A$ 中的一个区间 $[l,r]$ 具有威胁，当且仅当 $1\\le l<r\\le n$ 且 $A_l=A_r$，且 $\\forall i\\in[l,r]$ 满足 $|A_i|\\le|A_l|$。\n\n你可以操作 $A$ 任意次，每次操作选择一个 $A_i$ 修改为 $-A_i$。请问最后序列 $A$ 中具有威胁的**不同**区间**最少**有多少个？\n\n\n\n两个区间 $[l_1,r_1]$ 和 $[l_2,r_2]$ 不同，当且仅当 $l_1 \\ne l_2$ 或 $r_1 \\ne r_2$。\n\n", "inputFormat": "第一行一个整数 $n$ ，表示 $A$ 的长度。\n\n第二行 $n$ 个整数，表示 $\\{A_n\\}$。", "outputFormat": "第一行一个正整数，表示**最少**的具有威胁的区间个数。", "hint": "**【数据范围】**\n\n**本题采用捆绑测试**。\n- Subtask #1（$10\\text{ pts}$）：$n\\le10$。\n- Subtask #2（$10\\text{ pts}$）：$n\\le10^3$。\n- Subtask #3（$10\\text{ pts}$）：$|A_i|\\le60$。\n- Subtask #4（$10\\text{ pts}$）：$|A_i|$ 均相等。\n- Subtask #5（$20\\text{ pts}$）：$n\\le10^5$。\n- Subtask #6（$40\\text{ pts}$）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le n\\le5\\times10^5$，$|A_i|\\le10^9$。", "locale": "zh-CN"}}}
{"pid": "P10799", "type": "P", "difficulty": 5, "samples": [["5 5\n1 2 3 4 5\n1 2\n1 3\n2 4\n2 5\n2 1 2\n2 3 4\n1 3 5 4\n2 2 3\n2 1 5", "0110"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "倍增", "树状数组", "O2优化", "最近公共祖先 LCA", "树链剖分"], "title": "「CZOI-R1」三角形与树", "background": "CaiZi 讨厌三角形，但是他喜欢树。\n\n2024.8.15 Update：增加了一组 hack 数据。", "description": "给定一颗有 $n$ 个点的树，节点编号为 $1\\sim n$，每个点有点权，开始时点 $i$ 的点权为 $a_i$。共有 $q$ 次操作。\n1. 将点 $x$ 到点 $y$ 的简单路径上的点的点权**异或** $k$。\n1. 判断能否在点 $x$ 到点 $y$ 的简单路径上选 $3$ 个**不同点**，并以这 $3$ 个点的点权为边长构成**三角形**。特别的，如果无法选出 $3$ 个点，也视为不能构成**三角形**。\n\n点 $x$ 到点 $y$ 的简单路径：点 $x$ 到点 $y$ 不重复走过任何一条边的路径。其上的所有点为这条路径上所有的点，**包括**点 $x$ 和点 $y$。\n\n**保证任何时刻不会有任何一个点的点权为 $0$。**", "inputFormat": "第一行输入 $2$ 个整数 $n,q$，分别表示这棵树点的个数、操作的个数。\n\n第二行输入 $n$ 个整数 $a_i$，表示开始时点 $i$ 的点权。\n\n接下来 $n-1$ 行，每行输入 $2$ 个整数 $u,v$，表示这棵树的一条边。\n\n接下来 $q$ 行，每行先输入 $1$ 个整数 $s$，表示操作类型。\n- 若 $s=1$，则再输入 $3$ 个整数 $u,v,w$，表示一次修改操作。\n- 若 $s=2$，则再输入 $2$ 个整数 $u,v$，表示一次询问操作。", "outputFormat": "对于每次询问操作，若能满足条件输出 $1$，否则输出 $0$，无需空格或换行。", "hint": "**【样例解释】**\n\n第 $1$ 次操作时简单路径上的点权少于 $3$ 个。  \n第 $2$ 次操作时简单路径上的点权分别为 $1,2,3,4$。  \n第 $3$ 次操作后点 $1\\sim n$ 的点权分别为 $5,6,7,4,1$。  \n第 $4$ 次操作时简单路径上的点权分别为 $5,6,7$。  \n第 $5$ 次操作时简单路径上的点权分别为 $1,5,6$。\n\n**【数据范围】**\n\n**本题采用捆绑测试**。\n- Subtask #1（$8\\text{ pts}$）：$n,q\\le3\\times10^3$。\n- Subtask #2（$8\\text{ pts}$）：保证这棵树是一朵菊花。\n- Subtask #3（$20\\text{ pts}$）：每次修改操作时 $x=y$。\n- Subtask #4（$24\\text{ pts}$）：保证这棵树是一条链。\n- Subtask #5（$40\\text{ pts}$）：无特殊性质。**依赖 Subtask #1 到 Subtask #4。**\n\n对于 $100\\%$ 的数据，$1\\le u,v\\le n\\le10^5$，$1\\le q\\le10^5$，$s\\in\\{1,2\\}$，$1\\le a_i,w\\le 2^{31}-1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「CZOI-R1」三角形与树", "background": "CaiZi 讨厌三角形，但是他喜欢树。\n\n2024.8.15 Update：增加了一组 hack 数据。", "description": "给定一颗有 $n$ 个点的树，节点编号为 $1\\sim n$，每个点有点权，开始时点 $i$ 的点权为 $a_i$。共有 $q$ 次操作。\n1. 将点 $x$ 到点 $y$ 的简单路径上的点的点权**异或** $k$。\n1. 判断能否在点 $x$ 到点 $y$ 的简单路径上选 $3$ 个**不同点**，并以这 $3$ 个点的点权为边长构成**三角形**。特别的，如果无法选出 $3$ 个点，也视为不能构成**三角形**。\n\n点 $x$ 到点 $y$ 的简单路径：点 $x$ 到点 $y$ 不重复走过任何一条边的路径。其上的所有点为这条路径上所有的点，**包括**点 $x$ 和点 $y$。\n\n**保证任何时刻不会有任何一个点的点权为 $0$。**", "inputFormat": "第一行输入 $2$ 个整数 $n,q$，分别表示这棵树点的个数、操作的个数。\n\n第二行输入 $n$ 个整数 $a_i$，表示开始时点 $i$ 的点权。\n\n接下来 $n-1$ 行，每行输入 $2$ 个整数 $u,v$，表示这棵树的一条边。\n\n接下来 $q$ 行，每行先输入 $1$ 个整数 $s$，表示操作类型。\n- 若 $s=1$，则再输入 $3$ 个整数 $u,v,w$，表示一次修改操作。\n- 若 $s=2$，则再输入 $2$ 个整数 $u,v$，表示一次询问操作。", "outputFormat": "对于每次询问操作，若能满足条件输出 $1$，否则输出 $0$，无需空格或换行。", "hint": "**【样例解释】**\n\n第 $1$ 次操作时简单路径上的点权少于 $3$ 个。  \n第 $2$ 次操作时简单路径上的点权分别为 $1,2,3,4$。  \n第 $3$ 次操作后点 $1\\sim n$ 的点权分别为 $5,6,7,4,1$。  \n第 $4$ 次操作时简单路径上的点权分别为 $5,6,7$。  \n第 $5$ 次操作时简单路径上的点权分别为 $1,5,6$。\n\n**【数据范围】**\n\n**本题采用捆绑测试**。\n- Subtask #1（$8\\text{ pts}$）：$n,q\\le3\\times10^3$。\n- Subtask #2（$8\\text{ pts}$）：保证这棵树是一朵菊花。\n- Subtask #3（$20\\text{ pts}$）：每次修改操作时 $x=y$。\n- Subtask #4（$24\\text{ pts}$）：保证这棵树是一条链。\n- Subtask #5（$40\\text{ pts}$）：无特殊性质。**依赖 Subtask #1 到 Subtask #4。**\n\n对于 $100\\%$ 的数据，$1\\le u,v\\le n\\le10^5$，$1\\le q\\le10^5$，$s\\in\\{1,2\\}$，$1\\le a_i,w\\le 2^{31}-1$。", "locale": "zh-CN"}}}
{"pid": "P10800", "type": "P", "difficulty": 7, "samples": [["5 5\n2 2 1 2\n3 4 2 4\n4 3 2 2\n1 4 2 3\n1 2 4 4\n", "32\n"], ["10 10\n7 8 5 2\n5 9 9 4\n3 8 4 3\n5 6 5 1\n5 5 2 4\n9 5 5 1\n3 7 2 5\n4 4 5 4\n9 6 1 5\n3 7 3 7\n", "243\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["线段树", "树状数组", "O2优化"], "title": "「CZOI-R1」卡牌", "background": "Alice 和 Bob 正在玩卡牌游戏。\n", "description": "每张卡牌有四个属性：攻击、防御、速度、血量。\n\n我们称一张卡牌能胜过另一张卡牌，当且仅当其至少有三个属性都大于另一张卡牌。\n\nBob 拥有 $m$ 张卡牌，而 Alice 拥有每个属性值在 $[1, n]$ 的所有 $n^4$ 张卡牌。\n\n现在 Alice 想知道：她有多少张卡牌可以胜过所有 Bob 的卡牌？", "inputFormat": "第一行包含两个整数 $n, m$，分别表示属性值上限和 Bob 的卡牌数量。\n\n接下来 $m$ 行，每行四个整数 $a_i, b_i, c_i, d_i$，表示 Bob 一张卡牌的属性。", "outputFormat": "输出一行一个整数，表示答案对 $2^{32}$ 取模后的结果。", "hint": "**【数据范围】**\n\n**本题采用捆绑测试**。\n\n- Subtask #1（$10\\text{ pts}$）：$n, m \\le 50$。\n- Subtask #2（$10\\text{ pts}$）：$n, m \\le 5 \\times 10^3$。\n- Subtask #3（$20\\text{ pts}$）：$d_i = 1$。\n- Subtask #4（$20\\text{ pts}$）：$n, m \\le 10^5$。\n- Subtask #5（$40\\text{ pts}$）：无特殊限制。\n\n对于所有测试数据，$1 \\le n, m \\le 5 \\times 10^5$，$1 \\le a_i, b_i, c_i, d_i \\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「CZOI-R1」卡牌", "background": "Alice 和 Bob 正在玩卡牌游戏。\n", "description": "每张卡牌有四个属性：攻击、防御、速度、血量。\n\n我们称一张卡牌能胜过另一张卡牌，当且仅当其至少有三个属性都大于另一张卡牌。\n\nBob 拥有 $m$ 张卡牌，而 Alice 拥有每个属性值在 $[1, n]$ 的所有 $n^4$ 张卡牌。\n\n现在 Alice 想知道：她有多少张卡牌可以胜过所有 Bob 的卡牌？", "inputFormat": "第一行包含两个整数 $n, m$，分别表示属性值上限和 Bob 的卡牌数量。\n\n接下来 $m$ 行，每行四个整数 $a_i, b_i, c_i, d_i$，表示 Bob 一张卡牌的属性。", "outputFormat": "输出一行一个整数，表示答案对 $2^{32}$ 取模后的结果。", "hint": "**【数据范围】**\n\n**本题采用捆绑测试**。\n\n- Subtask #1（$10\\text{ pts}$）：$n, m \\le 50$。\n- Subtask #2（$10\\text{ pts}$）：$n, m \\le 5 \\times 10^3$。\n- Subtask #3（$20\\text{ pts}$）：$d_i = 1$。\n- Subtask #4（$20\\text{ pts}$）：$n, m \\le 10^5$。\n- Subtask #5（$40\\text{ pts}$）：无特殊限制。\n\n对于所有测试数据，$1 \\le n, m \\le 5 \\times 10^5$，$1 \\le a_i, b_i, c_i, d_i \\le n$。", "locale": "zh-CN"}}}
{"pid": "P10801", "type": "P", "difficulty": 6, "samples": [["7\n0 6 E\n0 8 E\n2 4 E\n4 2 S\n6 0 S\n6 2 S\n6 4 S", "7"], ["5\n4 0 S\n0 2 E\n2 2 E\n4 4 N\n6 6 W", "2\n5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "CEOI（中欧）"], "title": "[CEOI 2024] 海战", "background": "", "description": "**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day1 T1「[Naval battle](https://ceoi2024.fi.muni.cz/page/tasks/statements/battle.pdf)」**\n\n捷克海军司令官翁德拉刚刚晋升为大元帅，正享受着新职位的安稳，却突然被政府通知海军将被裁撤。\n\n翁德拉决心证明捷克海军的重要性。他通过间谍得知，一场四国海军巨舰对决即将展开。如果能赢得这场战役，无疑能向政府有力地展示海军价值。\n\n然而，捷克海军既无战舰也无港口。但翁德拉想到，如果他的间谍能夺取几艘参战舰艇，或许还有一线生机。关键是，如何预知哪些船能在这场海战中幸存下来呢？\n\n海战规则如下：\n- 战前，第 $i$ 艘战舰位于坐标 $(x_i, y_i)$ 处，其中 $x_i$ 和 $y_i$ 均为偶数。每艘战舰隶属于北方、南方、东方或西方舰队之一。\n- 海战分回合进行。每回合：\n    - 每艘战舰同时向其所属舰队方向移动一格。\n    - 如果两艘或以上战舰占据同一格，它们将相撞沉没，从海图上消失。\n- 当不再发生碰撞时，海战结束。存活的战舰是指海战结束后仍留在海图上的战舰。\n\n各舰队战舰的移动方向及坐标变化如下：\n- 北方舰队：$y$ 坐标减 $1$\n- 南方舰队：$y$ 坐标加 $1$\n- 东方舰队：$x$ 坐标加 $1$\n- 西方舰队：$x$ 坐标减 $1$", "inputFormat": "第一行输入一个整数 $N$，代表参与海战的舰船总数。 接下来是 $N$ 行，每行包含三个用空格隔开的整数 $x_i, y_i, d_i$。$x_i$ 和 $y_i$ 表示第 $i$ 艘舰船的初始位置，字符 $d_i$ 表示第 $i$ 艘舰船所属舰队的方向，它可以是 `N`、`S`、`E` 或 `W` 之一。\n\n初始时没有两艘舰船的坐标相同。换句话说，对于任何两艘不同的舰船 $i$ 和 $j$，它们的横坐标 $x_i$ 和 $x_j$ 不可能同时相等，纵坐标 $y_i$ 和 $y_j$ 也不可能同时相等。", "outputFormat": "对于每艘存活的战舰，单独输出一行，包含该舰船的编号 $i\\ (1 \\leq i \\leq N)$。你可以按照任何顺序输出幸存舰船的编号。\n\n如果没有存活的战舰，则输出为空。", "hint": "**样例解释 1**\n\n初始战舰分布如下图：\n\n![battle-sample1-v2.svg](https://img.loj.ac.cn/2024/07/14/c9908b56ff284.svg)\n\n海战过程：\n- 第 $2$ 回合，战舰 $3$ 和 $4$ 在 $(4, 4)$ 处相撞。\n- 第 $6$ 回合，战舰 $1$ 和 $5$ 在 $(6, 6)$ 处相撞，战舰 $2$ 和 $6$ 在 $(6, 8)$ 处相撞。\n\n最终仅剩战舰 $7$ 存活。\n\n\n**样例解释 2**\n\n初始战舰分布如下图：\n\n![battle-sample2.svg](https://img.loj.ac.cn/2024/07/14/59d352521ca5d.svg)\n\n第 $2$ 回合，战舰 $1$、$3$、$4$ 在 $(2, 4)$ 处相撞，战舰 $2$ 和 $5$ 存活。\n\n**数据范围与提示**\n\n对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 2 \\cdot 10^5$\n- $0 \\leq x_i, y_i \\leq 10^9\\ (1 \\leq i \\leq N)$，且 $x_i, y_i$ 均为偶数\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :--: | :--: | :--: |\n|  $1$  | $N = 2$ | $6$  |\n|  $2$  | $N \\leq 100, x_i, y_i \\leq 100\\ (1\\leq i\\leq n)$ | $12$ |\n|  $3$  | $N \\leq 100, x_i, y_i \\leq 10^5\\ (1\\leq i\\leq n)$ | $8$ |\n|  $4$  | $N \\leq 200$ | $11$ |\n|  $5$  | $N \\leq 5\\,000$ | $9$ |\n|  $6$  | $d_i\\ (1 \\leq i \\leq N)$ 为 `S` 或 `E`  | $30$ |\n|  $7$  | 无附加限制| $24$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2024] 海战", "background": "", "description": "**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day1 T1「[Naval battle](https://ceoi2024.fi.muni.cz/page/tasks/statements/battle.pdf)」**\n\n捷克海军司令官翁德拉刚刚晋升为大元帅，正享受着新职位的安稳，却突然被政府通知海军将被裁撤。\n\n翁德拉决心证明捷克海军的重要性。他通过间谍得知，一场四国海军巨舰对决即将展开。如果能赢得这场战役，无疑能向政府有力地展示海军价值。\n\n然而，捷克海军既无战舰也无港口。但翁德拉想到，如果他的间谍能夺取几艘参战舰艇，或许还有一线生机。关键是，如何预知哪些船能在这场海战中幸存下来呢？\n\n海战规则如下：\n- 战前，第 $i$ 艘战舰位于坐标 $(x_i, y_i)$ 处，其中 $x_i$ 和 $y_i$ 均为偶数。每艘战舰隶属于北方、南方、东方或西方舰队之一。\n- 海战分回合进行。每回合：\n    - 每艘战舰同时向其所属舰队方向移动一格。\n    - 如果两艘或以上战舰占据同一格，它们将相撞沉没，从海图上消失。\n- 当不再发生碰撞时，海战结束。存活的战舰是指海战结束后仍留在海图上的战舰。\n\n各舰队战舰的移动方向及坐标变化如下：\n- 北方舰队：$y$ 坐标减 $1$\n- 南方舰队：$y$ 坐标加 $1$\n- 东方舰队：$x$ 坐标加 $1$\n- 西方舰队：$x$ 坐标减 $1$", "inputFormat": "第一行输入一个整数 $N$，代表参与海战的舰船总数。 接下来是 $N$ 行，每行包含三个用空格隔开的整数 $x_i, y_i, d_i$。$x_i$ 和 $y_i$ 表示第 $i$ 艘舰船的初始位置，字符 $d_i$ 表示第 $i$ 艘舰船所属舰队的方向，它可以是 `N`、`S`、`E` 或 `W` 之一。\n\n初始时没有两艘舰船的坐标相同。换句话说，对于任何两艘不同的舰船 $i$ 和 $j$，它们的横坐标 $x_i$ 和 $x_j$ 不可能同时相等，纵坐标 $y_i$ 和 $y_j$ 也不可能同时相等。", "outputFormat": "对于每艘存活的战舰，单独输出一行，包含该舰船的编号 $i\\ (1 \\leq i \\leq N)$。你可以按照任何顺序输出幸存舰船的编号。\n\n如果没有存活的战舰，则输出为空。", "hint": "**样例解释 1**\n\n初始战舰分布如下图：\n\n![battle-sample1-v2.svg](https://img.loj.ac.cn/2024/07/14/c9908b56ff284.svg)\n\n海战过程：\n- 第 $2$ 回合，战舰 $3$ 和 $4$ 在 $(4, 4)$ 处相撞。\n- 第 $6$ 回合，战舰 $1$ 和 $5$ 在 $(6, 6)$ 处相撞，战舰 $2$ 和 $6$ 在 $(6, 8)$ 处相撞。\n\n最终仅剩战舰 $7$ 存活。\n\n\n**样例解释 2**\n\n初始战舰分布如下图：\n\n![battle-sample2.svg](https://img.loj.ac.cn/2024/07/14/59d352521ca5d.svg)\n\n第 $2$ 回合，战舰 $1$、$3$、$4$ 在 $(2, 4)$ 处相撞，战舰 $2$ 和 $5$ 存活。\n\n**数据范围与提示**\n\n对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 2 \\cdot 10^5$\n- $0 \\leq x_i, y_i \\leq 10^9\\ (1 \\leq i \\leq N)$，且 $x_i, y_i$ 均为偶数\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :--: | :--: | :--: |\n|  $1$  | $N = 2$ | $6$  |\n|  $2$  | $N \\leq 100, x_i, y_i \\leq 100\\ (1\\leq i\\leq n)$ | $12$ |\n|  $3$  | $N \\leq 100, x_i, y_i \\leq 10^5\\ (1\\leq i\\leq n)$ | $8$ |\n|  $4$  | $N \\leq 200$ | $11$ |\n|  $5$  | $N \\leq 5\\,000$ | $9$ |\n|  $6$  | $d_i\\ (1 \\leq i \\leq N)$ 为 `S` 或 `E`  | $30$ |\n|  $7$  | 无附加限制| $24$ |", "locale": "zh-CN"}}}
{"pid": "P10802", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "交互题", "Special Judge", "CEOI（中欧）"], "title": "[CEOI 2024] 核酸检测", "background": "", "description": "**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day1 T2「[COVID tests](https://ceoi2024.fi.muni.cz/page/tasks/statements/covid.pdf)」**\n\n亚当的学校最近爆发了新一波 COVID 疫情。为了防止疫情进一步蔓延，学校决定用唾液抗原检测试剂对所有学生进行检测。\n\n由于老师们很久没用过这些试剂了，亚当自告奋勇地成为了检测志愿者。他拿到了来自 $N$ 个学生的唾液样本（出于隐私保护，他只能看到编号从 $0$ 到 $N-1$ 的标识符），他的任务是确定哪些样本呈阳性。\n\n然而，亚当很快意识到，挨个检测所有学生的样本实在太耗时费力了。他灵机一动，想到了一种比逐个检测更巧妙的方法。如果他将部分样本混合在一起进行检测，他就能知道整个混合物是全部阴性，还是至少有一个阳性。这样一来，他就可以通过这种方式减少所需的检测次数！\n\n每个样本的唾液量都足够进行多次检测。而且，这些检测试剂非常精准，同一个样本绝不会出现不同的检测结果。\n\n在这样的条件下，亚当希望优化检测流程，尽量减少使用的检测次数。但是他目前正在进行检测，所以优化过程就交给你啦！\n\n通过当地的统计数据，亚当了解到任何一个样本呈阳性的概率都等于 $P$，并且一个样本是阳性还是阴性不会影响其他样本的检测结果。也许你可以利用这些信息来帮助亚当优化检测方案？", "inputFormat": "这是一道交互题。\n\n你的程序将会处理若干个测试数据。每个测试数据（即程序的一次运行）中，你需要解决 $T$ 个不同的场景。所有场景中，学生数量 $N$ 和阳性样本概率 $P$ 都保持不变，但是哪些学生的样本呈阳性（很可能）在每个场景中都会不同。\n\n你可以自己实现交互协议，也可以使用提供的模板。你可以在「文件」中找到名为 `template.cpp` 的附件，它就是提供的模板。\n\n首先，你的程序应该从标准输入读取一行，包含空格隔开的三个整数 $N, P, T$，分别表示学生数量、阳性样本概率和场景数量。\n\n然后，程序可以向标准输出输出询问信息。每个询问信息应该单独占一行，格式为 `Q`、空格和一个长度为 $N$ 的字符串 $s$。字符串 $s$ 中的每个字符 $s_i$ 都为 `1` 或 `0`，`1` 表示应该将第 $i$ 个学生的样本加入混合物进行检测，`0` 表示不加入。输出完询问信息后，程序需要刷新标准输出缓冲区，然后从标准输入读取一个字符。这个字符会是 `P`（表示混合物中至少有一个样本呈阳性）或 `N`（表示混合物中所有样本均为阴性）。\n\n程序也可以输出最终答案。答案信息应该单独占一行，格式为 `A`、空格和一个长度为 $N$ 的字符串 $s$。字符串 $s$ 中的每个字符 $s_i$ 都为 `1` 或 `0`，`1` 表示第 $i$ 个学生的样本呈阳性，`0` 表示呈阴性。输出完答案信息后，程序同样需要刷新标准输出缓冲区，然后从标准输入读取一个字符。\n\n如果读取到的字符为 `C`，则表示你的答案正确。在这种情况下，程序可以开始处理下一个场景的询问，或者如果是第 $T$ 个场景的答案，则程序可以退出。\n\n如果读取到的字符为 `W`，则表示你的答案错误。程序应该立即退出。\n\n请注意，在收到 `W` 后退出对于交互器给出正确的反馈非常重要。如果你的程序继续运行，它可能会崩溃或收到其他错误的判定。\n\n交互器不会根据你的程序运行结果来动态调整测试数据。这意味着每个样本的阳性与否会在程序运行之前就确定好。并且，每个样本的阳性与否都是通过公平的随机数生成器，以概率 $P$ 独立决定的。\n\n如果你使用 `template.cpp` 中的交互协议实现，你需要实现函数 `std::vector<bool> find_positive()`。这个函数会在每个场景中被调用一次。它需要返回一个长度为 $N$ 的布尔型向量，其中第 $i$ 个元素为 `true` 当且仅当第 $i$ 个学生的样本呈阳性。\n\n实现过程中，你可以使用函数 `bool test_students(std::vector<bool> mask)`。这个函数可以对部分样本进行混合检测。它唯一的参数是一个长度为 $N$ 的布尔型数组，其中第 $i$ 个元素为 `true` 表示应该将第 $i$ 个样本加入混合物进行检测。该函数返回 `true` 当且仅当混合物中至少有一个样本呈阳性。\n\n你也可以使用全局变量 `N` 和 `P`，它们分别代表着总学生人数和阳性样本概率。你可以在 `main` 函数中，首次调用 `scanf` 之后进行初始化操作。\n\n| 示例输入 | 示例输出 |\n|------------|----------------|\n| `10 0.4 2` |                |\n|            | `Q 1000000000` |\n| `P`        |                |\n|            | `Q 0000001000` |\n| `P`        |                |\n|            | `Q 0000000001` |\n| `P`        |                |\n|            | `Q 0111110110` |\n| `N`        |                |\n|            | `A 1000001001` |\n| `C`        |                |\n|            | `A 0000000000` |\n| `W`        | &nbsp;         |\n", "outputFormat": "", "hint": "本题分为两个子任务。\n\n#### Subtask 1 (10 分)\n\n- 学生总数 $N = 1000$\n- 场景数 $T = 1$\n- 阳性样本概率 $P$ 在 $0$ 到 $1$ 之间\n\n如果程序能正确回答并且每个测试数据的询问次数不超过 $2$ 倍的总学生人数 $2N$，则认为该程序通过测试。\n\n#### Subtask2 (90 分)\n\n- 学生总数 $N = 1000$\n- 场景数 $T = 300$\n- 阳性样本概率 $P$ 在 $0.001$ 到 $0.2$ 之间\n\n该子任务具有部分分。\n\n如果你的程序在任何场景的回答错误，你将得 $0$ 分。否则，每个测试数据的得分将基于平均询问次数计算。一般来说，询问次数越少，得分越高。记作程序在所有场景的平均询问次数为 $Q$，四舍五入到小数点后一位。对于每个测试数据，我们计算了一个值 $F$（见下文）。给定测试数据的得分将根据以下规则计算：\n\n- 如果 $Q > 10$ 倍的 $F$，你将得 $0$ 分 (错误答案)。\n- 如果 $F < Q \\leq 10$ 倍的 $F$，得分由以下公式计算：\n  $$ 90 \\cdot \\frac{F}{F + 4 \\cdot (Q-F)} $$\n- 如果 $Q \\leq F$，你将获得满分 $90$ 分。\n\n你的程序将会在不同 $P$ 值的测试数据上进行评分。你将获得的总分是所有测试数据（所有概率 $P$）中的最低分。\n\n测试数据如下：\n\n| $P$ | $F$ |\n|-------|-------|\n| $0.001$ | $15.1$ |\n| $0.005256$ | $51.1$ |\n| $0.011546$ | $94.9$ |\n| $0.028545$ | $191.5$ |\n| $0.039856$ | $246.3$ |\n| $0.068648$ | $366.2$ |\n| $0.104571$ | $490.3$ |\n| $0.158765$ | $639.1$ |\n| $0.2$ | $731.4$ |\n\n交互器会为每个测试数据提供反馈。这些反馈将包括你在得分非零的测试数据上的平均询问次数 $Q$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2024] 核酸检测", "background": "", "description": "**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day1 T2「[COVID tests](https://ceoi2024.fi.muni.cz/page/tasks/statements/covid.pdf)」**\n\n亚当的学校最近爆发了新一波 COVID 疫情。为了防止疫情进一步蔓延，学校决定用唾液抗原检测试剂对所有学生进行检测。\n\n由于老师们很久没用过这些试剂了，亚当自告奋勇地成为了检测志愿者。他拿到了来自 $N$ 个学生的唾液样本（出于隐私保护，他只能看到编号从 $0$ 到 $N-1$ 的标识符），他的任务是确定哪些样本呈阳性。\n\n然而，亚当很快意识到，挨个检测所有学生的样本实在太耗时费力了。他灵机一动，想到了一种比逐个检测更巧妙的方法。如果他将部分样本混合在一起进行检测，他就能知道整个混合物是全部阴性，还是至少有一个阳性。这样一来，他就可以通过这种方式减少所需的检测次数！\n\n每个样本的唾液量都足够进行多次检测。而且，这些检测试剂非常精准，同一个样本绝不会出现不同的检测结果。\n\n在这样的条件下，亚当希望优化检测流程，尽量减少使用的检测次数。但是他目前正在进行检测，所以优化过程就交给你啦！\n\n通过当地的统计数据，亚当了解到任何一个样本呈阳性的概率都等于 $P$，并且一个样本是阳性还是阴性不会影响其他样本的检测结果。也许你可以利用这些信息来帮助亚当优化检测方案？", "inputFormat": "这是一道交互题。\n\n你的程序将会处理若干个测试数据。每个测试数据（即程序的一次运行）中，你需要解决 $T$ 个不同的场景。所有场景中，学生数量 $N$ 和阳性样本概率 $P$ 都保持不变，但是哪些学生的样本呈阳性（很可能）在每个场景中都会不同。\n\n你可以自己实现交互协议，也可以使用提供的模板。你可以在「文件」中找到名为 `template.cpp` 的附件，它就是提供的模板。\n\n首先，你的程序应该从标准输入读取一行，包含空格隔开的三个整数 $N, P, T$，分别表示学生数量、阳性样本概率和场景数量。\n\n然后，程序可以向标准输出输出询问信息。每个询问信息应该单独占一行，格式为 `Q`、空格和一个长度为 $N$ 的字符串 $s$。字符串 $s$ 中的每个字符 $s_i$ 都为 `1` 或 `0`，`1` 表示应该将第 $i$ 个学生的样本加入混合物进行检测，`0` 表示不加入。输出完询问信息后，程序需要刷新标准输出缓冲区，然后从标准输入读取一个字符。这个字符会是 `P`（表示混合物中至少有一个样本呈阳性）或 `N`（表示混合物中所有样本均为阴性）。\n\n程序也可以输出最终答案。答案信息应该单独占一行，格式为 `A`、空格和一个长度为 $N$ 的字符串 $s$。字符串 $s$ 中的每个字符 $s_i$ 都为 `1` 或 `0`，`1` 表示第 $i$ 个学生的样本呈阳性，`0` 表示呈阴性。输出完答案信息后，程序同样需要刷新标准输出缓冲区，然后从标准输入读取一个字符。\n\n如果读取到的字符为 `C`，则表示你的答案正确。在这种情况下，程序可以开始处理下一个场景的询问，或者如果是第 $T$ 个场景的答案，则程序可以退出。\n\n如果读取到的字符为 `W`，则表示你的答案错误。程序应该立即退出。\n\n请注意，在收到 `W` 后退出对于交互器给出正确的反馈非常重要。如果你的程序继续运行，它可能会崩溃或收到其他错误的判定。\n\n交互器不会根据你的程序运行结果来动态调整测试数据。这意味着每个样本的阳性与否会在程序运行之前就确定好。并且，每个样本的阳性与否都是通过公平的随机数生成器，以概率 $P$ 独立决定的。\n\n如果你使用 `template.cpp` 中的交互协议实现，你需要实现函数 `std::vector<bool> find_positive()`。这个函数会在每个场景中被调用一次。它需要返回一个长度为 $N$ 的布尔型向量，其中第 $i$ 个元素为 `true` 当且仅当第 $i$ 个学生的样本呈阳性。\n\n实现过程中，你可以使用函数 `bool test_students(std::vector<bool> mask)`。这个函数可以对部分样本进行混合检测。它唯一的参数是一个长度为 $N$ 的布尔型数组，其中第 $i$ 个元素为 `true` 表示应该将第 $i$ 个样本加入混合物进行检测。该函数返回 `true` 当且仅当混合物中至少有一个样本呈阳性。\n\n你也可以使用全局变量 `N` 和 `P`，它们分别代表着总学生人数和阳性样本概率。你可以在 `main` 函数中，首次调用 `scanf` 之后进行初始化操作。\n\n| 示例输入 | 示例输出 |\n|------------|----------------|\n| `10 0.4 2` |                |\n|            | `Q 1000000000` |\n| `P`        |                |\n|            | `Q 0000001000` |\n| `P`        |                |\n|            | `Q 0000000001` |\n| `P`        |                |\n|            | `Q 0111110110` |\n| `N`        |                |\n|            | `A 1000001001` |\n| `C`        |                |\n|            | `A 0000000000` |\n| `W`        | &nbsp;         |\n", "outputFormat": "", "hint": "本题分为两个子任务。\n\n#### Subtask 1 (10 分)\n\n- 学生总数 $N = 1000$\n- 场景数 $T = 1$\n- 阳性样本概率 $P$ 在 $0$ 到 $1$ 之间\n\n如果程序能正确回答并且每个测试数据的询问次数不超过 $2$ 倍的总学生人数 $2N$，则认为该程序通过测试。\n\n#### Subtask2 (90 分)\n\n- 学生总数 $N = 1000$\n- 场景数 $T = 300$\n- 阳性样本概率 $P$ 在 $0.001$ 到 $0.2$ 之间\n\n该子任务具有部分分。\n\n如果你的程序在任何场景的回答错误，你将得 $0$ 分。否则，每个测试数据的得分将基于平均询问次数计算。一般来说，询问次数越少，得分越高。记作程序在所有场景的平均询问次数为 $Q$，四舍五入到小数点后一位。对于每个测试数据，我们计算了一个值 $F$（见下文）。给定测试数据的得分将根据以下规则计算：\n\n- 如果 $Q > 10$ 倍的 $F$，你将得 $0$ 分 (错误答案)。\n- 如果 $F < Q \\leq 10$ 倍的 $F$，得分由以下公式计算：\n  $$ 90 \\cdot \\frac{F}{F + 4 \\cdot (Q-F)} $$\n- 如果 $Q \\leq F$，你将获得满分 $90$ 分。\n\n你的程序将会在不同 $P$ 值的测试数据上进行评分。你将获得的总分是所有测试数据（所有概率 $P$）中的最低分。\n\n测试数据如下：\n\n| $P$ | $F$ |\n|-------|-------|\n| $0.001$ | $15.1$ |\n| $0.005256$ | $51.1$ |\n| $0.011546$ | $94.9$ |\n| $0.028545$ | $191.5$ |\n| $0.039856$ | $246.3$ |\n| $0.068648$ | $366.2$ |\n| $0.104571$ | $490.3$ |\n| $0.158765$ | $639.1$ |\n| $0.2$ | $731.4$ |\n\n交互器会为每个测试数据提供反馈。这些反馈将包括你在得分非零的测试数据上的平均询问次数 $Q$。", "locale": "zh-CN"}}}
{"pid": "P10803", "type": "P", "difficulty": 6, "samples": [["5\n3 1\n2 8\n7 10 9 9 0", "3"], ["5\n1 20\n3 25\n25 10 40 35 0", "16"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["模拟", "2024", "CEOI（中欧）", "最短路"], "title": "[CEOI 2024] 文本编辑器", "background": "", "description": "**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day1 T3「[Text editor](https://ceoi2024.fi.muni.cz/page/tasks/statements/editor.pdf)」**\n\n罗伯特正在参加 2024 年 CEOI 编程竞赛。他几乎完成了当天最难的一道题的代码，而且他确信能拿满分！但问题出在一个小小的细节上：他打错了一个字！更糟糕的是，他从 2008 年就开始使用的那只心爱鼠标彻底罢工了，一点反应也没有。因此，他只能用键盘上的方向键移动光标去找到那个错别字。\n\n罗伯特的程序有 $N$ 行，每行的长度分别为 $l_1, l_2, \\ldots , l_N$。罗伯特总是以空行作为程序的结尾，所以 $l_N = 0$。光标可以放在两个字符之间，也可以放在行的开头或结尾。因此，第 $i$ 行有 $l_i + 1$ 个可用的光标位置（称为列），编号从 $1$ 到 $l_i + 1$。例如，下面是光标位于第 $2$ 行第 $6$ 列的情况：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4p5zr0jw.png)\n\n罗伯特想把光标从第 $s_l$ 行的第 $s_c$ 列移动到第 $e_l$ 行的第 $e_c$ 列。他想求出最少需要的按键次数。\n\n水平方向键的使用比较简单。按下 **左键** 会将光标移动到前一列，除非光标位于行首，则会移动到前一行的行尾。类似地，按下 **右键** 会将光标移动到后一列，或者如果光标位于行尾，则会移动到下一行的行首。\n\n例如，**左键** 的移动可以像这样：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lig1idke.png)\n\n而 **右键** 的移动可以像这样：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zy9hu3u5.png)\n\n在文件的最开头按下 **左键** 或在文件的最结尾按下 **右键** 都不会有任何效果。\n\n垂直方向键的使用稍微复杂一些。按下 **上键** 会将光标移动到上一行，按下 **下键** 会将光标移动到下一行，列数不会改变。但是，如果这样会使光标超出新行的结尾，光标则会跳到该行末尾。\n\n例如，**上键** 的移动可以像这样：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2zixw04v.png)\n\n而 **下键** 的移动可以像这样：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wr5ld99o.png)\n\n如果按下 **上键** 或 **下键** 会把光标移动到不存在的行，则光标根本不会移动。", "inputFormat": "输入的第一行包含一个整数 $N$，表示罗伯特程序的行数。\n\n第二行包含两个空格隔开的整数 $s_l$ 和 $s_c$，表示初始光标位置。\n\n类似地，第三行包含两个空格隔开的整数 $e_l$ 和 $e_c$，表示目标光标位置。\n\n第四行包含 $N$ 个空格隔开的整数 $l_1, l_2, \\ldots , l_N$，表示每行的长度。", "outputFormat": "输出一行包含一个整数，表示将光标从 $(s_l, s_c)$ 移动到 $(e_l, e_c)$ 最少的按键次数。", "hint": "**样例解释 1**\n\n罗伯特可以通过按顺序按 **上键**、**左键** 和 **下键**三个键来将光标移动到目标位置：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wsz8bcr4.png)\n\n或者，他也可以通过按 **左键**、**上键** 和 **下键** 来同样快速地将光标移动到目标位置。\n\n**样例解释 2**\n\n可以很容易地证明，不可能使用最多两个按键到达目标位置。\n\n最短的可能按键序列是按两次 **下键** 然后按十四次 **右键**。\n\n对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 10^6$\n- $0 \\leq l_i \\leq 10^9\\ (1\\leq i\\leq n)$\n- $l_N = 0$\n- $1 \\leq s_l, e_l \\leq N$\n- $1 \\leq s_c \\leq l_{s_l} + 1$\n- $1 \\leq e_c \\leq l_{e_l} + 1$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :--: | :--: | :--: |\n|  $1$  | $N \\leq 2$ | $5$  |\n|  $2$  | $N \\leq 1\\,000, l_i \\leq 5\\,000\\ (1 \\leq i \\leq N)$| $14$ |\n|  $3$  | $N \\leq 1\\,000$ | $26$ |\n|  $4$  | $l_i = l_j\\ (1 \\leq i, j \\leq N - 1)$ | $11$ |\n|  $5$  | 无附加限制| $44$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2024] 文本编辑器", "background": "", "description": "**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day1 T3「[Text editor](https://ceoi2024.fi.muni.cz/page/tasks/statements/editor.pdf)」**\n\n罗伯特正在参加 2024 年 CEOI 编程竞赛。他几乎完成了当天最难的一道题的代码，而且他确信能拿满分！但问题出在一个小小的细节上：他打错了一个字！更糟糕的是，他从 2008 年就开始使用的那只心爱鼠标彻底罢工了，一点反应也没有。因此，他只能用键盘上的方向键移动光标去找到那个错别字。\n\n罗伯特的程序有 $N$ 行，每行的长度分别为 $l_1, l_2, \\ldots , l_N$。罗伯特总是以空行作为程序的结尾，所以 $l_N = 0$。光标可以放在两个字符之间，也可以放在行的开头或结尾。因此，第 $i$ 行有 $l_i + 1$ 个可用的光标位置（称为列），编号从 $1$ 到 $l_i + 1$。例如，下面是光标位于第 $2$ 行第 $6$ 列的情况：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4p5zr0jw.png)\n\n罗伯特想把光标从第 $s_l$ 行的第 $s_c$ 列移动到第 $e_l$ 行的第 $e_c$ 列。他想求出最少需要的按键次数。\n\n水平方向键的使用比较简单。按下 **左键** 会将光标移动到前一列，除非光标位于行首，则会移动到前一行的行尾。类似地，按下 **右键** 会将光标移动到后一列，或者如果光标位于行尾，则会移动到下一行的行首。\n\n例如，**左键** 的移动可以像这样：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lig1idke.png)\n\n而 **右键** 的移动可以像这样：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zy9hu3u5.png)\n\n在文件的最开头按下 **左键** 或在文件的最结尾按下 **右键** 都不会有任何效果。\n\n垂直方向键的使用稍微复杂一些。按下 **上键** 会将光标移动到上一行，按下 **下键** 会将光标移动到下一行，列数不会改变。但是，如果这样会使光标超出新行的结尾，光标则会跳到该行末尾。\n\n例如，**上键** 的移动可以像这样：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2zixw04v.png)\n\n而 **下键** 的移动可以像这样：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wr5ld99o.png)\n\n如果按下 **上键** 或 **下键** 会把光标移动到不存在的行，则光标根本不会移动。", "inputFormat": "输入的第一行包含一个整数 $N$，表示罗伯特程序的行数。\n\n第二行包含两个空格隔开的整数 $s_l$ 和 $s_c$，表示初始光标位置。\n\n类似地，第三行包含两个空格隔开的整数 $e_l$ 和 $e_c$，表示目标光标位置。\n\n第四行包含 $N$ 个空格隔开的整数 $l_1, l_2, \\ldots , l_N$，表示每行的长度。", "outputFormat": "输出一行包含一个整数，表示将光标从 $(s_l, s_c)$ 移动到 $(e_l, e_c)$ 最少的按键次数。", "hint": "**样例解释 1**\n\n罗伯特可以通过按顺序按 **上键**、**左键** 和 **下键**三个键来将光标移动到目标位置：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wsz8bcr4.png)\n\n或者，他也可以通过按 **左键**、**上键** 和 **下键** 来同样快速地将光标移动到目标位置。\n\n**样例解释 2**\n\n可以很容易地证明，不可能使用最多两个按键到达目标位置。\n\n最短的可能按键序列是按两次 **下键** 然后按十四次 **右键**。\n\n对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 10^6$\n- $0 \\leq l_i \\leq 10^9\\ (1\\leq i\\leq n)$\n- $l_N = 0$\n- $1 \\leq s_l, e_l \\leq N$\n- $1 \\leq s_c \\leq l_{s_l} + 1$\n- $1 \\leq e_c \\leq l_{e_l} + 1$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :--: | :--: | :--: |\n|  $1$  | $N \\leq 2$ | $5$  |\n|  $2$  | $N \\leq 1\\,000, l_i \\leq 5\\,000\\ (1 \\leq i \\leq N)$| $14$ |\n|  $3$  | $N \\leq 1\\,000$ | $26$ |\n|  $4$  | $l_i = l_j\\ (1 \\leq i, j \\leq N - 1)$ | $11$ |\n|  $5$  | 无附加限制| $44$ |", "locale": "zh-CN"}}}
{"pid": "P10804", "type": "P", "difficulty": 4, "samples": [["4 3 2 2\n0 1 0 0\n.X.*\n....\n...X", "YES"], ["2 3 2 3\n0 1 0 0\n.X\n.*\n.X", "NO"]], "limits": {"time": [1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350, 1350], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["单调队列", "2024", "CEOI（中欧）", "广度优先搜索 BFS", "深度优先搜索 DFS", "前缀和"], "title": "[CEOI 2024] 玩具谜题", "background": "", "description": "**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day2 T1「[Toy](https://ceoi2024.fi.muni.cz/page/tasks/statements/toy.pdf)」**\n\nCEOI 2024 的命题人 Ben 从科学委员会收到了一份礼物——一个玩具。这个玩具是个谜题，可以想象成一个 $H$ 行 $W$ 列的网格，上面放着一个金属物体。这个金属物体由两部分组成：一个横向的 $1$ 行 $K$ 列的部分和一个纵向的 $L$ 行 $1$ 列的部分，这两部分松散地连接在一起。它们都不能旋转，但可以在网格内水平或垂直滑动，只要它们始终重叠在一个方格上。\n\n网格里还有一些障碍物。金属物体的任何部分都不能穿过障碍物，更糟糕的是，它们也不能（即使部分）移出网格。Ben 的任务是将金属物体从指定起始位置移动到（可能不同的）目标位置，使得两部分重叠在指定的目标方格上。\n\n然而，Ben 玩这个玩具已经有一段时间了，还没有解开谜题。事实上，他开始怀疑组织者在捉弄他，给了他一个无解的谜题。因此，他向你求助，想知道这个谜题是否有解。", "inputFormat": "输入的第一行包含四个空格分隔的整数 $W, H, K, L$，分别表示谜题的宽度、高度、横向部分的宽度和纵向部分的高度。第二行包含四个整数 $x_h, y_h, x_v, y_v$，表示横向部分最左上角方格的坐标和纵向部分最左上角方格的坐标。\n\n行从上到下编号为 $0$ 到 $H-1$，列从左到右编号为 $0$ 到 $W-1$。$x$ 坐标表示列号，$y$ 坐标表示行号。\n\n接下来的 $H$ 行每行包含 $W$ 个字符，表示网格。字符 `.` 表示空方格，字符 `X` 表示障碍物，字符 `*` 表示目标方格。\n\n保证金属物体的初始位置合法，即两部分重叠在一个方格上，并且两部分不与障碍物重叠也不超出网格。\n\n只有一个目标方格，即玩具中只有一个字符 `*`，它可能与金属物体的初始位置重叠。", "outputFormat": "如果可以将金属物体移动到目标方格，则输出一行 `YES`，否则输出 `NO`。", "hint": "**样例解释 1**\n\n初始状态如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/anp1jutg.png)\n\n我们可以先将纵向部分向下移动一格，然后尽可能地交替移动横向和纵向部分，直到无法继续。接着，我们可以将纵向部分向上并向右移动，到达目标方格，最后将横向部分向上移动，也到达目标方格。\n\n**样例解释 2**\n\n无法移动纵向部分而不碰到障碍物，因此永远无法到达目标方格。\n\n对于所有输入数据，满足：\n\n- $2 \\leq W, H \\leq 1\\,500$\n- $2 \\leq K \\leq W, 2 \\leq L \\leq H$\n- $0 \\leq x_h \\leq W - K, 0 \\leq y_h \\leq H - 1$\n- $0 \\leq x_v \\leq W - 1, 0 \\leq y_v \\leq H - L$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :--: | :--: | :--: |\n|  $1$  | $W, H \\le 50$ | $14$  |\n|  $2$  | $W, H \\le 90$| $21$ |\n|  $3$  | $W, H \\le 300, K, L \\le 10$ | $9$ |\n|  $4$  | $W, H \\le 360$ | $29$ |\n|  $5$  | 无附加限制| $27$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2024] 玩具谜题", "background": "", "description": "**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day2 T1「[Toy](https://ceoi2024.fi.muni.cz/page/tasks/statements/toy.pdf)」**\n\nCEOI 2024 的命题人 Ben 从科学委员会收到了一份礼物——一个玩具。这个玩具是个谜题，可以想象成一个 $H$ 行 $W$ 列的网格，上面放着一个金属物体。这个金属物体由两部分组成：一个横向的 $1$ 行 $K$ 列的部分和一个纵向的 $L$ 行 $1$ 列的部分，这两部分松散地连接在一起。它们都不能旋转，但可以在网格内水平或垂直滑动，只要它们始终重叠在一个方格上。\n\n网格里还有一些障碍物。金属物体的任何部分都不能穿过障碍物，更糟糕的是，它们也不能（即使部分）移出网格。Ben 的任务是将金属物体从指定起始位置移动到（可能不同的）目标位置，使得两部分重叠在指定的目标方格上。\n\n然而，Ben 玩这个玩具已经有一段时间了，还没有解开谜题。事实上，他开始怀疑组织者在捉弄他，给了他一个无解的谜题。因此，他向你求助，想知道这个谜题是否有解。", "inputFormat": "输入的第一行包含四个空格分隔的整数 $W, H, K, L$，分别表示谜题的宽度、高度、横向部分的宽度和纵向部分的高度。第二行包含四个整数 $x_h, y_h, x_v, y_v$，表示横向部分最左上角方格的坐标和纵向部分最左上角方格的坐标。\n\n行从上到下编号为 $0$ 到 $H-1$，列从左到右编号为 $0$ 到 $W-1$。$x$ 坐标表示列号，$y$ 坐标表示行号。\n\n接下来的 $H$ 行每行包含 $W$ 个字符，表示网格。字符 `.` 表示空方格，字符 `X` 表示障碍物，字符 `*` 表示目标方格。\n\n保证金属物体的初始位置合法，即两部分重叠在一个方格上，并且两部分不与障碍物重叠也不超出网格。\n\n只有一个目标方格，即玩具中只有一个字符 `*`，它可能与金属物体的初始位置重叠。", "outputFormat": "如果可以将金属物体移动到目标方格，则输出一行 `YES`，否则输出 `NO`。", "hint": "**样例解释 1**\n\n初始状态如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/anp1jutg.png)\n\n我们可以先将纵向部分向下移动一格，然后尽可能地交替移动横向和纵向部分，直到无法继续。接着，我们可以将纵向部分向上并向右移动，到达目标方格，最后将横向部分向上移动，也到达目标方格。\n\n**样例解释 2**\n\n无法移动纵向部分而不碰到障碍物，因此永远无法到达目标方格。\n\n对于所有输入数据，满足：\n\n- $2 \\leq W, H \\leq 1\\,500$\n- $2 \\leq K \\leq W, 2 \\leq L \\leq H$\n- $0 \\leq x_h \\leq W - K, 0 \\leq y_h \\leq H - 1$\n- $0 \\leq x_v \\leq W - 1, 0 \\leq y_v \\leq H - L$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :--: | :--: | :--: |\n|  $1$  | $W, H \\le 50$ | $14$  |\n|  $2$  | $W, H \\le 90$| $21$ |\n|  $3$  | $W, H \\le 300, K, L \\le 10$ | $9$ |\n|  $4$  | $W, H \\le 360$ | $29$ |\n|  $5$  | 无附加限制| $27$ |\n", "locale": "zh-CN"}}}
{"pid": "P10805", "type": "P", "difficulty": 6, "samples": [["3 1\n0 1 1\n1 2 1", "0\n2\n0"], ["6 2\n0 1 1\n1 2 1\n2 3 1\n3 4 2\n4 5 1", "0\n3\n3\n12\n8\n0"]], "limits": {"time": [3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "CEOI（中欧）"], "title": "[CEOI 2024] 加油站", "background": "", "description": "**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day2 T2「[Petrol stations](https://ceoi2024.fi.muni.cz/page/tasks/statements/stations.pdf)」**\n\n捷克的高速公路网络由 $N$ 个城市和 $N-1$ 条路组成，每条路的长度（公里）已知。我们知道任意两个城市之间只有一条路径。此外，每个城市恰好有一个加油站，其他地方没有。\n\n有一天，许多人决定开车旅行。总共有 $N^2$ 辆车在路上。奇怪的是，对于每个有序城市对 $(a, b)$，恰好有一辆车从城市 $a$ 开往城市 $b$，沿着这两个城市之间唯一的路径行驶。由于捷克人全都开斯柯达车，每辆车的油箱容量都是 $K$ 升，并且每公里消耗一升汽油。出发前，每辆车的油箱都是满的。此外，捷克人非常有规律。由于懒惰，他们只在汽油不足以到达下一个城市时才加油（油箱为空时可以进入城市）。一旦他们被迫停在加油站，他们总是把油箱加满。\n\n捷克税务部门想知道当天每个加油站停了多少辆车。鉴于这种可预测的行为，你应该能够轻松计算出来。", "inputFormat": "输入的第一行包含两个空格分隔的整数 $N$ 和 $K$，分别表示城市数量和每辆车的油箱容量。\n\n接下来的 $N-1$ 行描述道路。每行包含三个空格分隔的整数 $u_i, v_i, l_i$，其中 $u_i$ 和 $v_i$ 是第 $i$ 条路连接的城市编号，$l_i$ 是这条路的长度（公里）。城市从 $0$ 到 $N-1$ 编号。保证任意两个城市之间只有一条路径。", "outputFormat": "输出 $N$ 行，表示从城市 $0$ 到城市 $N-1$ 每个城市加油站停靠的汽车数。", "hint": "**样例解释 1**\n\n有 $3$ 座城市呈直线排列，连接它们的道路长度为 $1$，油箱容量为 $1$ 升。只有在两个外围城市之间行驶的汽车会在中间城市加油。\n\n**样例解释 2**\n\n有 $6$ 个城市呈直线排列，油箱容量为 $2$ 升。许多汽车需要在城市 $3$ 和城市 $4$ 加油。这是有道理的，因为城市 $3$ 和城市 $4$ 之间的道路长度为 $2$ 公里。\n\n对于所有输入数据，满足：\n- $2 \\leq N \\leq 70\\,000$\n- $1 \\leq K \\leq 10^9$\n- $0 \\leq l_i \\leq K\\ (0 \\leq i \\leq N-2)$\n\n令 $D$ 表示连接到单个城市的道路的最大数量。详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :--: | :--: | :--: |\n|  $1$  | $N \\leq 1\\,000, K \\leq 1\\,000$ | $18$  |\n|  $2$  | $D\\le 2$ 且 $l_i = 1\\ (0 \\leq i \\leq N-2)$ | $8$ |\n|  $3$  | $D\\le 2$| $10$ |\n|  $4$  | $K\\leq 10, D\\leq 10$ | $12$ |\n|  $5$  | $K\\leq 10$ | $17$ |\n|  $6$  | 无附加限制| $35$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2024] 加油站", "background": "", "description": "**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day2 T2「[Petrol stations](https://ceoi2024.fi.muni.cz/page/tasks/statements/stations.pdf)」**\n\n捷克的高速公路网络由 $N$ 个城市和 $N-1$ 条路组成，每条路的长度（公里）已知。我们知道任意两个城市之间只有一条路径。此外，每个城市恰好有一个加油站，其他地方没有。\n\n有一天，许多人决定开车旅行。总共有 $N^2$ 辆车在路上。奇怪的是，对于每个有序城市对 $(a, b)$，恰好有一辆车从城市 $a$ 开往城市 $b$，沿着这两个城市之间唯一的路径行驶。由于捷克人全都开斯柯达车，每辆车的油箱容量都是 $K$ 升，并且每公里消耗一升汽油。出发前，每辆车的油箱都是满的。此外，捷克人非常有规律。由于懒惰，他们只在汽油不足以到达下一个城市时才加油（油箱为空时可以进入城市）。一旦他们被迫停在加油站，他们总是把油箱加满。\n\n捷克税务部门想知道当天每个加油站停了多少辆车。鉴于这种可预测的行为，你应该能够轻松计算出来。", "inputFormat": "输入的第一行包含两个空格分隔的整数 $N$ 和 $K$，分别表示城市数量和每辆车的油箱容量。\n\n接下来的 $N-1$ 行描述道路。每行包含三个空格分隔的整数 $u_i, v_i, l_i$，其中 $u_i$ 和 $v_i$ 是第 $i$ 条路连接的城市编号，$l_i$ 是这条路的长度（公里）。城市从 $0$ 到 $N-1$ 编号。保证任意两个城市之间只有一条路径。", "outputFormat": "输出 $N$ 行，表示从城市 $0$ 到城市 $N-1$ 每个城市加油站停靠的汽车数。", "hint": "**样例解释 1**\n\n有 $3$ 座城市呈直线排列，连接它们的道路长度为 $1$，油箱容量为 $1$ 升。只有在两个外围城市之间行驶的汽车会在中间城市加油。\n\n**样例解释 2**\n\n有 $6$ 个城市呈直线排列，油箱容量为 $2$ 升。许多汽车需要在城市 $3$ 和城市 $4$ 加油。这是有道理的，因为城市 $3$ 和城市 $4$ 之间的道路长度为 $2$ 公里。\n\n对于所有输入数据，满足：\n- $2 \\leq N \\leq 70\\,000$\n- $1 \\leq K \\leq 10^9$\n- $0 \\leq l_i \\leq K\\ (0 \\leq i \\leq N-2)$\n\n令 $D$ 表示连接到单个城市的道路的最大数量。详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :--: | :--: | :--: |\n|  $1$  | $N \\leq 1\\,000, K \\leq 1\\,000$ | $18$  |\n|  $2$  | $D\\le 2$ 且 $l_i = 1\\ (0 \\leq i \\leq N-2)$ | $8$ |\n|  $3$  | $D\\le 2$| $10$ |\n|  $4$  | $K\\leq 10, D\\leq 10$ | $12$ |\n|  $5$  | $K\\leq 10$ | $17$ |\n|  $6$  | 无附加限制| $35$ |", "locale": "zh-CN"}}}
{"pid": "P10806", "type": "P", "difficulty": 5, "samples": [["3 3\n10 10 10\n5 11 16", "6\nLLR"], ["1 2\n1000\n1 2000", "-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "二分", "2024", "Special Judge", "CEOI（中欧）"], "title": "[CEOI 2024] 洒水器", "background": "", "description": "**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day2 T3「[Sprinklers](https://ceoi2024.fi.muni.cz/page/tasks/statements/sprinklers.pdf)」**\n\n瓦茨拉夫有一个美丽的花园，花园里种了一排 $M$ 朵花。在这一排上，瓦茨拉夫还放置了 $N$ 个洒水器来浇花。\n\n洒水器的位置由数字 $s_1, s_2, \\ldots , s_N$ 给出。花的位置由数字 $f_1, f_2, \\ldots , f_M$ 给出。两者都是非递减顺序，即：\n- $s_1 \\leq s_2 \\leq \\ldots \\leq s_N$\n- $f_1 \\leq f_2 \\leq \\ldots \\leq f_M$\n\n瓦茨拉夫很快就要去参加 CEOI 了。他想确保在他离开期间所有的花都能得到适当的浇水。为此，他可以单独将每个洒水器向左或向右旋转，并设置它们的喷水强度——所有洒水器共享同一个水管，因此喷射距离相同。\n\n如果喷水强度为 $K$，并且第 $i$ 个洒水器向左旋转，它将浇灌位置在 $s_i - K$ 到 $s_i$ 之间的所有花。类似地，如果第 $j$ 个洒水器向右旋转，它将浇灌位置在 $s_j$ 到 $s_j+K$ 之间的所有花。单个洒水器可以浇灌多朵花，一朵花也可以被多个洒水器浇灌。\n\n你的任务是决定是否可以浇灌所有的花。如果是，你应该找到最小的足够喷水强度，以及相应的洒水器配置。如果存在多个具有最小喷水强度的有效配置，输出其中任何一个。", "inputFormat": "输入的第一行包含两个用空格隔开的整数 $N$ 和 $M$。第二行包含 $N$ 个空格分隔的整数 $s_1, s_2, \\ldots , s_N$，表示洒水器的位置。第三行包含 $M$ 个空格分隔的整数 $f_1, f_2, \\ldots , f_M$，表示花的位置。", "outputFormat": "如果无法浇灌所有的花，则输出数字 $-1$。\n\n如果可以，输出应该包含两行。第一行输出数字 $K$，表示浇灌所有花所需的最小的喷水强度。在第二行，输出长度为 $N$ 的字符串 $c$，其中 $c_i$ 为 `L`，如果第 $i$ 个洒水器应该向左旋转，否则为 `R`。", "hint": "**样例解释 1**\n\n每朵花至少被一个洒水器浇水。喷水强度低于 $6$ 是不可能的，因为位置 $16$ 的花离最近的洒水器有 $6$ 个单位距离。\n\n**样例解释 2**\n\n无论洒水器的方向如何，一次最多只能浇灌一朵花。\n\n对于所有输入数据，满足：\n- $1 \\leq N,M \\leq 10^5$\n- $0 \\leq s_{i} \\leq 10^9\\ (1 \\leq i \\leq N)$\n- $0 \\leq f_{i} \\leq 10^9\\ (1 \\leq i \\leq M)$\n- $s_{i} \\leq s_{j}\\ (i \\leq j)$\n- $f_{i} \\leq f_{j}\\ (i \\leq j)$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :--: | :--: | :--: |\n|  $1$  | $N = 1$ | $3$  |\n|  $2$  | $N = 3x$，$x$ 是一个整数，$s_{3i+1}=s_{3i+2}=s_{3i+3}\\ (0 \\leq i \\leq x-1)$（即洒水器总是成组放置三个）| $6$ |\n|  $3$  | $N \\leq 10, M \\leq 1\\,000$| $17$ |\n|  $4$  | $K\\leq 8$（即在所有测试数据中，存在一种洒水器配置，使得喷水强度最多为 $8$ 就足以浇灌所有的花） | $27$ |\n|  $5$  | 无附加限制| $47$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2024] 洒水器", "background": "", "description": "**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day2 T3「[Sprinklers](https://ceoi2024.fi.muni.cz/page/tasks/statements/sprinklers.pdf)」**\n\n瓦茨拉夫有一个美丽的花园，花园里种了一排 $M$ 朵花。在这一排上，瓦茨拉夫还放置了 $N$ 个洒水器来浇花。\n\n洒水器的位置由数字 $s_1, s_2, \\ldots , s_N$ 给出。花的位置由数字 $f_1, f_2, \\ldots , f_M$ 给出。两者都是非递减顺序，即：\n- $s_1 \\leq s_2 \\leq \\ldots \\leq s_N$\n- $f_1 \\leq f_2 \\leq \\ldots \\leq f_M$\n\n瓦茨拉夫很快就要去参加 CEOI 了。他想确保在他离开期间所有的花都能得到适当的浇水。为此，他可以单独将每个洒水器向左或向右旋转，并设置它们的喷水强度——所有洒水器共享同一个水管，因此喷射距离相同。\n\n如果喷水强度为 $K$，并且第 $i$ 个洒水器向左旋转，它将浇灌位置在 $s_i - K$ 到 $s_i$ 之间的所有花。类似地，如果第 $j$ 个洒水器向右旋转，它将浇灌位置在 $s_j$ 到 $s_j+K$ 之间的所有花。单个洒水器可以浇灌多朵花，一朵花也可以被多个洒水器浇灌。\n\n你的任务是决定是否可以浇灌所有的花。如果是，你应该找到最小的足够喷水强度，以及相应的洒水器配置。如果存在多个具有最小喷水强度的有效配置，输出其中任何一个。", "inputFormat": "输入的第一行包含两个用空格隔开的整数 $N$ 和 $M$。第二行包含 $N$ 个空格分隔的整数 $s_1, s_2, \\ldots , s_N$，表示洒水器的位置。第三行包含 $M$ 个空格分隔的整数 $f_1, f_2, \\ldots , f_M$，表示花的位置。", "outputFormat": "如果无法浇灌所有的花，则输出数字 $-1$。\n\n如果可以，输出应该包含两行。第一行输出数字 $K$，表示浇灌所有花所需的最小的喷水强度。在第二行，输出长度为 $N$ 的字符串 $c$，其中 $c_i$ 为 `L`，如果第 $i$ 个洒水器应该向左旋转，否则为 `R`。", "hint": "**样例解释 1**\n\n每朵花至少被一个洒水器浇水。喷水强度低于 $6$ 是不可能的，因为位置 $16$ 的花离最近的洒水器有 $6$ 个单位距离。\n\n**样例解释 2**\n\n无论洒水器的方向如何，一次最多只能浇灌一朵花。\n\n对于所有输入数据，满足：\n- $1 \\leq N,M \\leq 10^5$\n- $0 \\leq s_{i} \\leq 10^9\\ (1 \\leq i \\leq N)$\n- $0 \\leq f_{i} \\leq 10^9\\ (1 \\leq i \\leq M)$\n- $s_{i} \\leq s_{j}\\ (i \\leq j)$\n- $f_{i} \\leq f_{j}\\ (i \\leq j)$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :--: | :--: | :--: |\n|  $1$  | $N = 1$ | $3$  |\n|  $2$  | $N = 3x$，$x$ 是一个整数，$s_{3i+1}=s_{3i+2}=s_{3i+3}\\ (0 \\leq i \\leq x-1)$（即洒水器总是成组放置三个）| $6$ |\n|  $3$  | $N \\leq 10, M \\leq 1\\,000$| $17$ |\n|  $4$  | $K\\leq 8$（即在所有测试数据中，存在一种洒水器配置，使得喷水强度最多为 $8$ 就足以浇灌所有的花） | $27$ |\n|  $5$  | 无附加限制| $47$ |", "locale": "zh-CN"}}}
{"pid": "P10807", "type": "P", "difficulty": 3, "samples": [["5\n0 3\n0 3\n1 6\n2 6\n2 6", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "O2优化"], "title": "[LMXOI Round 2] Disaster", "background": "LMX 和 HQZ 在一起研究点的划分。", "description": "给定 $n$ 个点，每个点给出了一组限制 $l_i,r_i(0 \\le l_i < i < r_i \\le n+1)$，定义一个划分是好的当且仅当对于每个点 $i$，$l_i,r_i$ 在划分后均不与 $i$ 在同一区间内，求好的划分的个数，答案对 $998244353$ 取模。\n\n补充：在本题中，一组划分表示将 $n$ 个点分为若干个区间，使得每个点恰好在一个区间内，$l_i=0$ 和 $r_i=n+1$ 可以视为无限制。", "inputFormat": "第一行一个整数 $n$ 表示点的个数。\n\n接下来 $n$ 行，第 $i$ 行两个整数 $l_i,r_i$。", "outputFormat": "第一行一个整数，表示答案对 $998244353$ 取模后的值。", "hint": "**样例解释 #1**\n\n样例的 $8$ 种合法划分区间分别是：\n\n$[1,2],[3,5]$\n\n$[1,1],[2,2],[3,5]$\n\n$[1,2],[3,3],[4,5]$\n\n$[1,1],[2,2],[3,3],[4,5]$\n\n$[1,2],[3,4],[5,5]$\n\n$[1,1],[2,2],[3,4],[5,5]$\n\n$[1,2],[3,3],[4,4],[5,5]$\n\n$[1,1],[2,2],[3,3],[4,4],[5,5]$\n\n\n\n\n对于所有数据，$1 \\le n\\le  2 \\times 10^6$，$0 \\le l_i < i < r_i \\le n+1$。\n\n| 子任务编号 |        $n$         |    特殊性质    | 分值 |\n| :--------: | :----------------: | :------------: | :--: |\n| Subtask #1 |      $\\le 20$      |       无       |  $5$   |\n| Subtask #2 |     $\\le 500$      |       无       |  $10$  |\n| Subtask #3 |     $\\le 5000$     |       无       |  $20$  |\n| Subtask #4 |     $\\le 5 \\times 10^5$     | $l_i=0$ |  $10$   |\n| Subtask #5 |     $\\le 5 \\times 10^5$     |无 |  $25$  |\n| Subtask #6 |     $\\le 2 \\times 10^6$     |无 |  $30$  |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[LMXOI Round 2] Disaster", "background": "LMX 和 HQZ 在一起研究点的划分。", "description": "给定 $n$ 个点，每个点给出了一组限制 $l_i,r_i(0 \\le l_i < i < r_i \\le n+1)$，定义一个划分是好的当且仅当对于每个点 $i$，$l_i,r_i$ 在划分后均不与 $i$ 在同一区间内，求好的划分的个数，答案对 $998244353$ 取模。\n\n补充：在本题中，一组划分表示将 $n$ 个点分为若干个区间，使得每个点恰好在一个区间内，$l_i=0$ 和 $r_i=n+1$ 可以视为无限制。", "inputFormat": "第一行一个整数 $n$ 表示点的个数。\n\n接下来 $n$ 行，第 $i$ 行两个整数 $l_i,r_i$。", "outputFormat": "第一行一个整数，表示答案对 $998244353$ 取模后的值。", "hint": "**样例解释 #1**\n\n样例的 $8$ 种合法划分区间分别是：\n\n$[1,2],[3,5]$\n\n$[1,1],[2,2],[3,5]$\n\n$[1,2],[3,3],[4,5]$\n\n$[1,1],[2,2],[3,3],[4,5]$\n\n$[1,2],[3,4],[5,5]$\n\n$[1,1],[2,2],[3,4],[5,5]$\n\n$[1,2],[3,3],[4,4],[5,5]$\n\n$[1,1],[2,2],[3,3],[4,4],[5,5]$\n\n\n\n\n对于所有数据，$1 \\le n\\le  2 \\times 10^6$，$0 \\le l_i < i < r_i \\le n+1$。\n\n| 子任务编号 |        $n$         |    特殊性质    | 分值 |\n| :--------: | :----------------: | :------------: | :--: |\n| Subtask #1 |      $\\le 20$      |       无       |  $5$   |\n| Subtask #2 |     $\\le 500$      |       无       |  $10$  |\n| Subtask #3 |     $\\le 5000$     |       无       |  $20$  |\n| Subtask #4 |     $\\le 5 \\times 10^5$     | $l_i=0$ |  $10$   |\n| Subtask #5 |     $\\le 5 \\times 10^5$     |无 |  $25$  |\n| Subtask #6 |     $\\le 2 \\times 10^6$     |无 |  $30$  |", "locale": "zh-CN"}}}
{"pid": "P10808", "type": "P", "difficulty": 6, "samples": [["3 1\n1 2\n2 3\n1 1 2\n1 1 2", "8 4 2"], ["4 1\n1 2\n2 4\n1 3\n1 1 2 1\n1 2 3 1", "19 5 3 1"], ["10 3\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n7 8\n5 9\n9 10\n1 3 7 3 6 6 6 9 4 8 \n450163553 649444963 324825063 696619525 758594756 594697697 750550965 907640826 118301481 755848673 \n", "475170649 914027313 64013204 696619525 210513956 594697697 111866638 907640826 0 0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "莫比乌斯反演", "线段树合并"], "title": "[LMXOI Round 2] Annihilation", "background": "LMX 和 HQZ 在研究上次被毙掉的题目 Impacter 时，他们提出了一个新的问题。", "description": "给定一棵 $n$ 个节点的，以 $1$ 为根的树，每个点有权值 $a_i$。\n\n对于一个点 $u$，定义函数 $f(u,v,d)$ 表示在 $u$ 的子树内选择一些点（至少需要选取一个点），选出的点中最大权值为 $v$，且它们编号的最大公约数为 $d$ 的方案数。\n\n给定一个常数 $k$ 和一个序列 $b$，对于每个点 $u$，你需要求出 $ \\sum\\limits_{k|i}^{n}\\sum\\limits_{j=1}^nf(u,i,j)\\times b_j$ 的值，其中 $k|i$ 表示 $k$ 可以整除 $i$。由于该值可能很大，所以你需要输出其对 $998244353$ 取模的结果。", "inputFormat": "第一行两个整数 $n,k$。\n\n接下来 $n-1$ 行，每行两个整数 $u,v$ 表示 $u$ 与 $v$ 之间有一条边。\n\n接下来一行 $n$ 个数，第 $i$ 个数字表示 $a_i$。\n\n接下来一行 $n$ 个数，第 $i$ 个数字表示 $b_i$。", "outputFormat": "一行 $n$ 个整数，分别表示 $u=1,2,\\ldots n$ 时的答案对 $998244353$ 取模的值。", "hint": "**样例解释 #1**\n\n节点 $3$ 可以选择 $\\{3\\}$，因为是求最大值为 $1$ 的倍数，所以贡献为 $2$。\n\n节点 $2$ 可以选择 $\\{2\\},\\{3\\},\\{2,3\\}$，因为是求最大值为 $1$ 的倍数，所以贡献是 $1+2+1=4$ 。\n\n节点 $1$ 可以选择 $\\{1\\},\\{2\\},\\{3\\},\\{1,2\\},\\{1,3\\},\\{2,3\\},\\{1,2,3\\}$，因为是求最大值为 $1$ 的倍数，所以贡献是 $1+1+2+1+1+1+1=8$ 。\n\n对于所有数据，$1 \\le a_i\\le n\\le  10^5$，$1\\le b_i\\le 10^9$。\n\n| 子任务编号 |        $n$         |    特殊性质    | 分值 |\n| :--------: | :----------------: | :------------: | :--: |\n| Subtask #1 |      $\\le 20$      |       无       |  $10$   |\n| Subtask #2 |     $\\le 200$      |       无       |  $10$  |\n| Subtask #3 |     $\\le 2000$     |       无       |  $10$  |\n| Subtask #4 |     $\\le 10^5$     | 树随机生成* |  $10$   |\n| Subtask #5 |     $\\le 10^5$     | $k=1$ |  $20$  |\n| Subtask #6 | $\\le 5\\times 10^4$ |       无       |  $20$  |\n| Subtask #7 |     $\\le 10^5$     |       无       |  $20$  |\n\n树随机生成*：指对于 $u=2,3,\\ldots n$ 每个点，其父亲从 $[1,u-1]$ 的整数中均匀随机选取。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[LMXOI Round 2] Annihilation", "background": "LMX 和 HQZ 在研究上次被毙掉的题目 Impacter 时，他们提出了一个新的问题。", "description": "给定一棵 $n$ 个节点的，以 $1$ 为根的树，每个点有权值 $a_i$。\n\n对于一个点 $u$，定义函数 $f(u,v,d)$ 表示在 $u$ 的子树内选择一些点（至少需要选取一个点），选出的点中最大权值为 $v$，且它们编号的最大公约数为 $d$ 的方案数。\n\n给定一个常数 $k$ 和一个序列 $b$，对于每个点 $u$，你需要求出 $ \\sum\\limits_{k|i}^{n}\\sum\\limits_{j=1}^nf(u,i,j)\\times b_j$ 的值，其中 $k|i$ 表示 $k$ 可以整除 $i$。由于该值可能很大，所以你需要输出其对 $998244353$ 取模的结果。", "inputFormat": "第一行两个整数 $n,k$。\n\n接下来 $n-1$ 行，每行两个整数 $u,v$ 表示 $u$ 与 $v$ 之间有一条边。\n\n接下来一行 $n$ 个数，第 $i$ 个数字表示 $a_i$。\n\n接下来一行 $n$ 个数，第 $i$ 个数字表示 $b_i$。", "outputFormat": "一行 $n$ 个整数，分别表示 $u=1,2,\\ldots n$ 时的答案对 $998244353$ 取模的值。", "hint": "**样例解释 #1**\n\n节点 $3$ 可以选择 $\\{3\\}$，因为是求最大值为 $1$ 的倍数，所以贡献为 $2$。\n\n节点 $2$ 可以选择 $\\{2\\},\\{3\\},\\{2,3\\}$，因为是求最大值为 $1$ 的倍数，所以贡献是 $1+2+1=4$ 。\n\n节点 $1$ 可以选择 $\\{1\\},\\{2\\},\\{3\\},\\{1,2\\},\\{1,3\\},\\{2,3\\},\\{1,2,3\\}$，因为是求最大值为 $1$ 的倍数，所以贡献是 $1+1+2+1+1+1+1=8$ 。\n\n对于所有数据，$1 \\le a_i\\le n\\le  10^5$，$1\\le b_i\\le 10^9$。\n\n| 子任务编号 |        $n$         |    特殊性质    | 分值 |\n| :--------: | :----------------: | :------------: | :--: |\n| Subtask #1 |      $\\le 20$      |       无       |  $10$   |\n| Subtask #2 |     $\\le 200$      |       无       |  $10$  |\n| Subtask #3 |     $\\le 2000$     |       无       |  $10$  |\n| Subtask #4 |     $\\le 10^5$     | 树随机生成* |  $10$   |\n| Subtask #5 |     $\\le 10^5$     | $k=1$ |  $20$  |\n| Subtask #6 | $\\le 5\\times 10^4$ |       无       |  $20$  |\n| Subtask #7 |     $\\le 10^5$     |       无       |  $20$  |\n\n树随机生成*：指对于 $u=2,3,\\ldots n$ 每个点，其父亲从 $[1,u-1]$ 的整数中均匀随机选取。", "locale": "zh-CN"}}}
{"pid": "P10809", "type": "P", "difficulty": 7, "samples": [["5 8 1 4\n1 2\n2 3\n3 4\n4 5\n1 3\n1 4\n2 4\n3 5", "665496236\n1 2\n00010000"], ["6 5 5 6\n1 2\n1 3\n1 4\n1 5\n1 6", "0\n3\n2 3 4"], ["9 9 1 7\n1 3\n2 3\n3 4\n3 5\n4 5\n4 6\n5 7\n4 8\n8 9", "0\n4\n2 6 8 9"]], "limits": {"time": [2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200, 2200], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["Special Judge", "O2优化", "双连通分量", "圆方树"], "title": "[LMXOI Round 2] Nirvana", "background": "HQZ 在摆弄 LMX 的一台机器。", "description": "\n定义一张无向连通图是**好的**，当且仅当存在一组定向方案使得原图可以通过对每条边定向使其成为仅有 $S$ 入度为 $0$，$T$ 出度为 $0$ 的**有向无环**图。\n\n给定一张 $n$ 个点 $m$ 条边**无自环**的**无向连通图**，定义一次操作为等概率选取两个**可重**的点 $x, y$ 且 $x \\le y$，连接 $x$ 和 $y$。求一次操作后的图是**好的**的概率 $P$ 对 $998244353$ 取模的值。\n\n若 $P > 0$，你需要在加入一条边后构造一组定向方案。\n\n若 $P = 0$，你需要构造一组删点数量最少的方案使得原图是好的。", "inputFormat": "第一行四个正整数 $n, m, S, T$，含义如题面所述。\n\n接下来 $m$ 行，第 $i$ 行两个正整数 $x_i,y_i$，表示 $x_i$ 和 $y_i$ 之间有一条无向边。", "outputFormat": "第一行一个非负整数 $P$。\n\n若 $P > 0$，接下来两行，第一行两个正整数 $u, v$ 表示你添加的边为 $u \\to v$（有向），第二行一个长度为 $m$ 的仅包含 $0$ 和 $1$ 的字符串 $s$，$s_i = 0$ 表示 $(x_i, y_i)$ 这条边的方向为 $x_i \\to y_i$，否则为 $y_i \\to x_i$。\n\n若 $P = 0$，接下来输出两行，第一行包含一个正整数 $c$，表示最少要删除多少个点。第二行包含 $c$ 个正整数，表示需要删掉的点。\n\n**评分方式：**\n\n**在输出格式正确的情况下**，若你的程序正确回答了概率 $P$，则你能获得该测试点 $30\\%$ 的分数。\n\n**在此基础上**，若你正确构造出了方案，则你能获得该测试点 $100\\%$ 的分数。\n\n**若你的程序输出格式错误，可能会出现不可预料的错误。**", "hint": "对于所有数据，$1 \\le n, m \\le 5 \\times 10^5$。\n\n**update 7/27: Subtask #7 为新的 Hack 数据。数据范围同 Subtask #6**。\n\n| 子任务编号 |         $n$         |         $m$         |        特殊性质        | 分值 |\n| :--------: | :-----------------: | :-----------------: | :--------------------: | :--: |\n| Subtask #1 |      $\\le 10$       |      $\\le 10$       |           无           | $25$ |\n| Subtask #2 |     $\\le 500$      |      $= n - 1$      | $x_i = i, y_i = i + 1$ | $10$ |\n| Subtask #3 |     $\\le 5 \\times 10^5$      |      $= n$      |      原图是一个环      | $5$  |\n| Subtask #4 |     $\\le 500$      |     $\\le 500$      |        无         | $20$ |\n| Subtask #5 | $\\le 5 \\times 10^5$ |      $= n - 1$      | $x_i = i, y_i = i + 1$ | $20$ |\n| Subtask #6 | $\\le 5 \\times 10^5$ | $\\le 5 \\times 10^5$ |        无         | $20$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[LMXOI Round 2] Nirvana", "background": "HQZ 在摆弄 LMX 的一台机器。", "description": "\n定义一张无向连通图是**好的**，当且仅当存在一组定向方案使得原图可以通过对每条边定向使其成为仅有 $S$ 入度为 $0$，$T$ 出度为 $0$ 的**有向无环**图。\n\n给定一张 $n$ 个点 $m$ 条边**无自环**的**无向连通图**，定义一次操作为等概率选取两个**可重**的点 $x, y$ 且 $x \\le y$，连接 $x$ 和 $y$。求一次操作后的图是**好的**的概率 $P$ 对 $998244353$ 取模的值。\n\n若 $P > 0$，你需要在加入一条边后构造一组定向方案。\n\n若 $P = 0$，你需要构造一组删点数量最少的方案使得原图是好的。", "inputFormat": "第一行四个正整数 $n, m, S, T$，含义如题面所述。\n\n接下来 $m$ 行，第 $i$ 行两个正整数 $x_i,y_i$，表示 $x_i$ 和 $y_i$ 之间有一条无向边。", "outputFormat": "第一行一个非负整数 $P$。\n\n若 $P > 0$，接下来两行，第一行两个正整数 $u, v$ 表示你添加的边为 $u \\to v$（有向），第二行一个长度为 $m$ 的仅包含 $0$ 和 $1$ 的字符串 $s$，$s_i = 0$ 表示 $(x_i, y_i)$ 这条边的方向为 $x_i \\to y_i$，否则为 $y_i \\to x_i$。\n\n若 $P = 0$，接下来输出两行，第一行包含一个正整数 $c$，表示最少要删除多少个点。第二行包含 $c$ 个正整数，表示需要删掉的点。\n\n**评分方式：**\n\n**在输出格式正确的情况下**，若你的程序正确回答了概率 $P$，则你能获得该测试点 $30\\%$ 的分数。\n\n**在此基础上**，若你正确构造出了方案，则你能获得该测试点 $100\\%$ 的分数。\n\n**若你的程序输出格式错误，可能会出现不可预料的错误。**", "hint": "对于所有数据，$1 \\le n, m \\le 5 \\times 10^5$。\n\n**update 7/27: Subtask #7 为新的 Hack 数据。数据范围同 Subtask #6**。\n\n| 子任务编号 |         $n$         |         $m$         |        特殊性质        | 分值 |\n| :--------: | :-----------------: | :-----------------: | :--------------------: | :--: |\n| Subtask #1 |      $\\le 10$       |      $\\le 10$       |           无           | $25$ |\n| Subtask #2 |     $\\le 500$      |      $= n - 1$      | $x_i = i, y_i = i + 1$ | $10$ |\n| Subtask #3 |     $\\le 5 \\times 10^5$      |      $= n$      |      原图是一个环      | $5$  |\n| Subtask #4 |     $\\le 500$      |     $\\le 500$      |        无         | $20$ |\n| Subtask #5 | $\\le 5 \\times 10^5$ |      $= n - 1$      | $x_i = i, y_i = i + 1$ | $20$ |\n| Subtask #6 | $\\le 5 \\times 10^5$ | $\\le 5 \\times 10^5$ |        无         | $20$ |", "locale": "zh-CN"}}}
{"pid": "P10810", "type": "P", "difficulty": 3, "samples": [["1\ntest\n", "4\n"], ["3\ntest\n", "1\n"], ["3\napollo\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "梦熊比赛"], "title": "【MX-S2-T1】 变", "background": "原题链接：<https://oier.team/problems/S2A>。", "description": "已知一个仅由小写英文字母构成的字符串 $s$。\n\n每次操作时，你可以任意选择 $s$ 中的一个字符，并将它修改为任意小写英文字母。\n\n你可以按任意顺序对其进行不超过 $k$ 次操作，以最小化 $s$ 的**严格循环节**的长度。当然，不进行操作也是可以的。\n\n请输出在进行完所有操作后，最小的可能的 $s$ 的严格循环节的长度。\n\n> 一个字符串 $t$ 被称为 $s$ 的严格循环节，当且仅当 $s$ 可以通过将 $t$ 重复若干次来构造。\n> \n> 例如：`mai` 是 `maimai` 的严格循环节，`dx` 是 `dx` 的严格循环节。但 `ov` 不是 `ovo` 的严格循环节。\n", "inputFormat": "第一行一个非负整数 $k$。\n\n第二行一个字符串 $s$，仅包含小写英文字母。\n", "outputFormat": "一行一个整数，表示答案。", "hint": "**【样例解释 \\#1】**\n\n可以证明：最多进行一次操作的情况下，严格循环节长度至少为 $4$。\n\n**【样例解释 \\#2】**\n\n可以通过 $3$ 次操作，将 `test` 修改为 `ssss`，严格循环节长度为 $1$。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 0（17 pts）：$k = 0$，$|s| \\leq 6$。\n- Subtask 1（14 pts）：$k = 1$，$|s| \\leq 20$。\n- Subtask 2（16 pts）：$k = 1$，$|s| \\leq 500$。\n- Subtask 3（32 pts）：$k < |s| \\leq 10^5$。\n- Subtask 4（21 pts）： 无特殊限制。\n\n对于所有测试数据，保证 $0 \\leq k < |s| \\leq 10^6$，$s$ 中仅包含小写英文字母。\n\n**2024.7.28：新增了一组 Hack 数据。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【MX-S2-T1】 变", "background": "原题链接：<https://oier.team/problems/S2A>。", "description": "已知一个仅由小写英文字母构成的字符串 $s$。\n\n每次操作时，你可以任意选择 $s$ 中的一个字符，并将它修改为任意小写英文字母。\n\n你可以按任意顺序对其进行不超过 $k$ 次操作，以最小化 $s$ 的**严格循环节**的长度。当然，不进行操作也是可以的。\n\n请输出在进行完所有操作后，最小的可能的 $s$ 的严格循环节的长度。\n\n> 一个字符串 $t$ 被称为 $s$ 的严格循环节，当且仅当 $s$ 可以通过将 $t$ 重复若干次来构造。\n> \n> 例如：`mai` 是 `maimai` 的严格循环节，`dx` 是 `dx` 的严格循环节。但 `ov` 不是 `ovo` 的严格循环节。\n", "inputFormat": "第一行一个非负整数 $k$。\n\n第二行一个字符串 $s$，仅包含小写英文字母。\n", "outputFormat": "一行一个整数，表示答案。", "hint": "**【样例解释 \\#1】**\n\n可以证明：最多进行一次操作的情况下，严格循环节长度至少为 $4$。\n\n**【样例解释 \\#2】**\n\n可以通过 $3$ 次操作，将 `test` 修改为 `ssss`，严格循环节长度为 $1$。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 0（17 pts）：$k = 0$，$|s| \\leq 6$。\n- Subtask 1（14 pts）：$k = 1$，$|s| \\leq 20$。\n- Subtask 2（16 pts）：$k = 1$，$|s| \\leq 500$。\n- Subtask 3（32 pts）：$k < |s| \\leq 10^5$。\n- Subtask 4（21 pts）： 无特殊限制。\n\n对于所有测试数据，保证 $0 \\leq k < |s| \\leq 10^6$，$s$ 中仅包含小写英文字母。\n\n**2024.7.28：新增了一组 Hack 数据。**", "locale": "zh-CN"}}}
{"pid": "P10811", "type": "P", "difficulty": 4, "samples": [["5\n7 5 -4 -6 3", "6"], ["10\n573 -1339 899 939 -26 1430 1324 -1150 1640 -45 ", "1625"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "bitset", "梦熊比赛"], "title": "【MX-S2-T2】 排", "background": "原题链接：<https://oier.team/problems/S2B>。", "description": "有 $n$ 个整数 $a_1,a_2,\\ldots,a_n$。$f_0=0,f_i= \\left\\{\n\\begin{aligned}\n& f_{i-1}   &  \\ f_{i-1}\\times a_i>0, \\\\\n& f_{i-1}+a_i &  \\ f_{i-1}\\times a_i\\le 0.\\\\ \n\\end{aligned}\n\\right.\n$\n\n重排 $a$ 使得得到的 $f_n$ 最大。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数 $a_1,\\dots,a_n$。", "outputFormat": "一行一个整数，表示答案。", "hint": "**【样例解释 \\#1】**\n\n考虑重排为 $-6,-4,5,7,3$，最终的 $f_n$ 为 $6$，可以证明不存在更优的方案。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 0（6 pts）：$n\\le10$。\n- Subtask 1（14 pts）：$n\\le 20$，$|a_i|\\le10$。\n- Subtask 2（8 pts）：$a$ 中全为正数或全为负数。\n- Subtask 3（19 pts）：$a$ 中有且只有一个正数（注意 $a$ 中可以有 $0$）。\n- Subtask 4（29 pts）：$n \\le 200$，$|a_i|\\le 200$。\n- Subtask 5（24 pts）：无特殊限制。\n\n对于所有测试数据，$1 \\le n \\le 2000$，$|a_i|\\le 2000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【MX-S2-T2】 排", "background": "原题链接：<https://oier.team/problems/S2B>。", "description": "有 $n$ 个整数 $a_1,a_2,\\ldots,a_n$。$f_0=0,f_i= \\left\\{\n\\begin{aligned}\n& f_{i-1}   &  \\ f_{i-1}\\times a_i>0, \\\\\n& f_{i-1}+a_i &  \\ f_{i-1}\\times a_i\\le 0.\\\\ \n\\end{aligned}\n\\right.\n$\n\n重排 $a$ 使得得到的 $f_n$ 最大。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数 $a_1,\\dots,a_n$。", "outputFormat": "一行一个整数，表示答案。", "hint": "**【样例解释 \\#1】**\n\n考虑重排为 $-6,-4,5,7,3$，最终的 $f_n$ 为 $6$，可以证明不存在更优的方案。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 0（6 pts）：$n\\le10$。\n- Subtask 1（14 pts）：$n\\le 20$，$|a_i|\\le10$。\n- Subtask 2（8 pts）：$a$ 中全为正数或全为负数。\n- Subtask 3（19 pts）：$a$ 中有且只有一个正数（注意 $a$ 中可以有 $0$）。\n- Subtask 4（29 pts）：$n \\le 200$，$|a_i|\\le 200$。\n- Subtask 5（24 pts）：无特殊限制。\n\n对于所有测试数据，$1 \\le n \\le 2000$，$|a_i|\\le 2000$。", "locale": "zh-CN"}}}
{"pid": "P10812", "type": "P", "difficulty": 5, "samples": [["3 1000000007", "3"], ["4 1000", "7"], ["100 511609", "272799"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "O2优化", "前缀和", "梦熊比赛"], "title": "【MX-S2-T3】 跳", "background": "原题链接：<https://oier.team/problems/S2C>。\n\n---\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kq7nqgu8.png)\n\n~~跳一跳世界第一。~~\n\n~~不处，不收徒，差距自己找。~~", "description": "给定一个坐标轴，范围是 $1\\sim n$。每个点 $i$ 可以跳到 $i+1$（$i+1\\le n$）或 $i-1$（$i-1\\ge 1$）或他的因子处。每个点只能到达一次。问从点 $n$ 到点 $1$ 一共有多少方案。答案对 $p$ 取模。\n\n两种方案不同当且仅当存在一次跳跃后的位置不同或存在一次跳跃的种类不同。", "inputFormat": "一行两个整数 $n,p$。", "outputFormat": "一行一个整数，表示答案对 $p$ 取模后的结果。", "hint": "**【样例解释 \\#1】**\n\n设 $\\rightarrow$ 表示向上或向下跳，$\\Rightarrow$ 表示跳因子。共三种方案如下。\n+ $3\\Rightarrow1$\n+ $3\\rightarrow2\\rightarrow1$\n+ $3\\rightarrow2\\Rightarrow1$\n\n**【样例解释 \\#2】**\n\n设 $\\rightarrow$ 表示向上或向下跳，$\\Rightarrow$ 表示跳因子。共七种方案如下。\n\n+ $4\\rightarrow3\\Rightarrow1$\n+ $4\\rightarrow3\\rightarrow2\\rightarrow1$\n+ $4\\rightarrow3\\rightarrow2\\Rightarrow1$\n+ $4\\Rightarrow2\\rightarrow3\\Rightarrow1$\n+ $4\\Rightarrow2\\rightarrow1$\n+ $4\\Rightarrow2\\Rightarrow1$\n+ $4\\Rightarrow1$\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 0（8 pts）：$n\\le20$。\n- Subtask 1（11 pts）：$n\\le150$。\n- Subtask 2（23 pts）：$n\\le300$。\n- Subtask 3（26 pts）：$n\\le1000$。\n- Subtask 4（32 pts）：无特殊限制。\n\n对于所有测试数据，$1\\le n\\le5\\times10^3$，$2\\le p\\le 10^9+7$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【MX-S2-T3】 跳", "background": "原题链接：<https://oier.team/problems/S2C>。\n\n---\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kq7nqgu8.png)\n\n~~跳一跳世界第一。~~\n\n~~不处，不收徒，差距自己找。~~", "description": "给定一个坐标轴，范围是 $1\\sim n$。每个点 $i$ 可以跳到 $i+1$（$i+1\\le n$）或 $i-1$（$i-1\\ge 1$）或他的因子处。每个点只能到达一次。问从点 $n$ 到点 $1$ 一共有多少方案。答案对 $p$ 取模。\n\n两种方案不同当且仅当存在一次跳跃后的位置不同或存在一次跳跃的种类不同。", "inputFormat": "一行两个整数 $n,p$。", "outputFormat": "一行一个整数，表示答案对 $p$ 取模后的结果。", "hint": "**【样例解释 \\#1】**\n\n设 $\\rightarrow$ 表示向上或向下跳，$\\Rightarrow$ 表示跳因子。共三种方案如下。\n+ $3\\Rightarrow1$\n+ $3\\rightarrow2\\rightarrow1$\n+ $3\\rightarrow2\\Rightarrow1$\n\n**【样例解释 \\#2】**\n\n设 $\\rightarrow$ 表示向上或向下跳，$\\Rightarrow$ 表示跳因子。共七种方案如下。\n\n+ $4\\rightarrow3\\Rightarrow1$\n+ $4\\rightarrow3\\rightarrow2\\rightarrow1$\n+ $4\\rightarrow3\\rightarrow2\\Rightarrow1$\n+ $4\\Rightarrow2\\rightarrow3\\Rightarrow1$\n+ $4\\Rightarrow2\\rightarrow1$\n+ $4\\Rightarrow2\\Rightarrow1$\n+ $4\\Rightarrow1$\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 0（8 pts）：$n\\le20$。\n- Subtask 1（11 pts）：$n\\le150$。\n- Subtask 2（23 pts）：$n\\le300$。\n- Subtask 3（26 pts）：$n\\le1000$。\n- Subtask 4（32 pts）：无特殊限制。\n\n对于所有测试数据，$1\\le n\\le5\\times10^3$，$2\\le p\\le 10^9+7$。", "locale": "zh-CN"}}}
{"pid": "P10813", "type": "P", "difficulty": 6, "samples": [["3 3 5\n3 2\n1 3\n1 2\n2 3\n2 1", "12"], ["8 900000754 20\n5 5\n1 2\n3 2\n1 8\n4 8\n5 8\n3 4\n3 7\n5 7\n3 4\n6 8\n1 5\n7 8\n7 8\n5 7\n1 8\n3 8\n3 8\n5 6\n3 8\n", "508510094"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "组合数学", "状压 DP", "梦熊比赛"], "title": "【MX-S2-T4】 换", "background": "原题链接：<https://oier.team/problems/S2D>。", "description": "给定 $n,V$ 和一个长为 $m$ 的序列 $(p_1,q_1),(p_2,q_2),\\dots,(p_m,q_m)$。\n\n请求出有多少长度为 $n$ 的正整数序列 $a$，其所有元素 $a_i$ 满足 $1\\le a_i\\le V$，将其按 $k=1,2,\\dots,m$ 依次执行如下操作后，$a$ 不降：  \n\n- 若 $a_{p_k}>a_{q_k}$，则交换 $a_{p_k}$ 与 $a_{q_k}$ 的值。\n\n答案对 $10^9+7$ 取模。", "inputFormat": "第一行三个整数 $n,V,m$。\n\n接下来 $m$ 行，每行两个整数 $p_k,q_k$。", "outputFormat": "一行一个整数，表示答案对 $10^9+7$ 取模后的结果。", "hint": "**【样例解释 \\#1】**\n\n对于第一组样例，有以下 $12$ 种符合条件的序列：\n\n$\\{1,1,1\\}$，$\\{1,1,2\\}$，$\\{1,1,3\\}$，$\\{1,2,1\\}$，$\\{1,3,1\\}$，$\\{2,1,1\\}$，$\\{2,2,2\\}$，$\\{2,2,3\\}$，$\\{2,3,2\\}$，$\\{3,1,1\\}$，$\\{3,2,2\\}$，$\\{3,3,3\\}$。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 0（8 pts）：$n\\le6$，$V\\le 8$，$m \\le 50$。\n- Subtask 1（31 pts）：$n \\le 8$。\n- Subtask 2（37 pts）：$n \\le 15$。\n- Subtask 3（24 pts）：无特殊限制。\n\n对于所有测试数据，$1\\le n\\le 18$，$1\\le V\\le 10^9$，$1\\le m\\le 500$，$1\\leq p_k,q_k\\leq n$，注意不保证 $p_k$ 和 $q_k$ 的大小关系，且数据可能存在 $p_k=q_k$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【MX-S2-T4】 换", "background": "原题链接：<https://oier.team/problems/S2D>。", "description": "给定 $n,V$ 和一个长为 $m$ 的序列 $(p_1,q_1),(p_2,q_2),\\dots,(p_m,q_m)$。\n\n请求出有多少长度为 $n$ 的正整数序列 $a$，其所有元素 $a_i$ 满足 $1\\le a_i\\le V$，将其按 $k=1,2,\\dots,m$ 依次执行如下操作后，$a$ 不降：  \n\n- 若 $a_{p_k}>a_{q_k}$，则交换 $a_{p_k}$ 与 $a_{q_k}$ 的值。\n\n答案对 $10^9+7$ 取模。", "inputFormat": "第一行三个整数 $n,V,m$。\n\n接下来 $m$ 行，每行两个整数 $p_k,q_k$。", "outputFormat": "一行一个整数，表示答案对 $10^9+7$ 取模后的结果。", "hint": "**【样例解释 \\#1】**\n\n对于第一组样例，有以下 $12$ 种符合条件的序列：\n\n$\\{1,1,1\\}$，$\\{1,1,2\\}$，$\\{1,1,3\\}$，$\\{1,2,1\\}$，$\\{1,3,1\\}$，$\\{2,1,1\\}$，$\\{2,2,2\\}$，$\\{2,2,3\\}$，$\\{2,3,2\\}$，$\\{3,1,1\\}$，$\\{3,2,2\\}$，$\\{3,3,3\\}$。\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n- Subtask 0（8 pts）：$n\\le6$，$V\\le 8$，$m \\le 50$。\n- Subtask 1（31 pts）：$n \\le 8$。\n- Subtask 2（37 pts）：$n \\le 15$。\n- Subtask 3（24 pts）：无特殊限制。\n\n对于所有测试数据，$1\\le n\\le 18$，$1\\le V\\le 10^9$，$1\\le m\\le 500$，$1\\leq p_k,q_k\\leq n$，注意不保证 $p_k$ 和 $q_k$ 的大小关系，且数据可能存在 $p_k=q_k$。", "locale": "zh-CN"}}}
{"pid": "P10814", "type": "P", "difficulty": 4, "samples": [["6 4\n1 1 4 5 1 4\n1 6 3\n1 6 4\n1 1 4\n1 5 4", "3\n5\n1\n4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["树状数组", "扫描线", "离线处理", "模板题"], "title": "【模板】离线二维数点", "background": "青蛙。", "description": "给你一个长为 $n$ 的序列 $a$，有 $m$ 次询问，每次询问给定 $l,r,x$，求 $[l,r]$ 区间中小于等于 $x$ 的元素个数。", "inputFormat": "第一行两个数 $n,m$。\n\n第二行 $n$ 个数表示序列 $a$。\n\n之后 $m$ 行，每行三个数 $l,r,x$ 表示一次询问。", "outputFormat": "对每个询问，输出一行一个数表示答案。", "hint": "对于 $20\\%$ 的数据，满足 $1\\le n,m,a_i,l,r,x\\le 100$。\n\n对于 $40\\%$ 的数据，满足 $1\\le n,m,a_i,l,r,x\\le 10^4$。\n\n对于 $60\\%$ 的数据，满足 $1\\le n,m,a_i,l,r,x\\le 10^5$。\n\n对于 $80\\%$ 的数据，满足 $1\\le n,m,a_i,l,r,x\\le 10^6$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m,a_i,l,r,x\\le 2\\times10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【模板】离线二维数点", "background": "青蛙。", "description": "给你一个长为 $n$ 的序列 $a$，有 $m$ 次询问，每次询问给定 $l,r,x$，求 $[l,r]$ 区间中小于等于 $x$ 的元素个数。", "inputFormat": "第一行两个数 $n,m$。\n\n第二行 $n$ 个数表示序列 $a$。\n\n之后 $m$ 行，每行三个数 $l,r,x$ 表示一次询问。", "outputFormat": "对每个询问，输出一行一个数表示答案。", "hint": "对于 $20\\%$ 的数据，满足 $1\\le n,m,a_i,l,r,x\\le 100$。\n\n对于 $40\\%$ 的数据，满足 $1\\le n,m,a_i,l,r,x\\le 10^4$。\n\n对于 $60\\%$ 的数据，满足 $1\\le n,m,a_i,l,r,x\\le 10^5$。\n\n对于 $80\\%$ 的数据，满足 $1\\le n,m,a_i,l,r,x\\le 10^6$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m,a_i,l,r,x\\le 2\\times10^6$。", "locale": "zh-CN"}}}
