{"pid": "P10959", "type": "P", "difficulty": 5, "samples": [["1 100 \n", "33"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "搜索", "记忆化搜索", "数位 DP"], "title": "月之谜", "background": "", "description": "如果一个十进制数能够被它的各位数字之和整除，则称这个数为“月之数”。\n\n给定整数 $L$ 和 $R$，你需要计算闭区间 $[L,R]$ 中有多少个“月之数”。", "inputFormat": "多组测试数据，每组输入占一行，包含两个整数 $L$ 和 $R$。\n", "outputFormat": "每组数据输出一行一个整数，表示月之数的个数。", "hint": "数据保证，$1 \\le L,R < 2^{31}$，单个测试点内不超过 $3000$ 组数据。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "月之谜", "background": "", "description": "如果一个十进制数能够被它的各位数字之和整除，则称这个数为“月之数”。\n\n给定整数 $L$ 和 $R$，你需要计算闭区间 $[L,R]$ 中有多少个“月之数”。", "inputFormat": "多组测试数据，每组输入占一行，包含两个整数 $L$ 和 $R$。\n", "outputFormat": "每组数据输出一行一个整数，表示月之数的个数。", "hint": "数据保证，$1 \\le L,R < 2^{31}$，单个测试点内不超过 $3000$ 组数据。", "locale": "zh-CN"}}}
{"pid": "P10960", "type": "P", "difficulty": 5, "samples": [["5 4\n12\n10\n4\n3\n5", "2\n3\n2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "Special Judge", "O2优化", "背包 DP", "构造"], "title": "SUBSTRACT", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/7iy6ncb0.png)![](https://cdn.luogu.com.cn/upload/image_hosting/4g4yijww.png)", "inputFormat": "![](https://cdn.luogu.com.cn/upload/image_hosting/kgtenidc.png)", "outputFormat": "![](https://cdn.luogu.com.cn/upload/image_hosting/5gdc86t2.png)", "hint": "Special Judge by @[w9095](luogu://user/569235)", "locale": "en", "translations": {"en": {"title": "SUBSTRACT", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/7iy6ncb0.png)![](https://cdn.luogu.com.cn/upload/image_hosting/4g4yijww.png)", "inputFormat": "![](https://cdn.luogu.com.cn/upload/image_hosting/kgtenidc.png)", "outputFormat": "![](https://cdn.luogu.com.cn/upload/image_hosting/5gdc86t2.png)", "hint": "Special Judge by @[w9095](luogu://user/569235)", "locale": "en"}, "zh-CN": {"title": "SUBSTRACT", "background": null, "description": "现有一个由 $n$ 个整数组成的序列 $a=[a_1,a_2,...,a_n]$，你需要对它进行 $n-1$ 次操作。其中第 $i$ 次操作是：\n\n1. 选择一个正整数 $t\\ (1 \\le t \\le n-i)$；\n2. 计算 $d=a_t-a_{t+1}$；\n3. 删除 $a_t,a_{t+1}$ 两项；\n4. 在原来 $a_t$ 的位置插入一项 $d$。\n\n试构造一种操作方案，使得 $n-1$ 次操作后序列中剩下的那个数恰好等于给定的数 $T\\ (|T| \\le 10^4)$（保证有解）。", "inputFormat": "第一行输入包含两个由空格分隔的整数：整数 $n$（原始序列中整数的个数，满足 $1 \\le n \\le 100$ ），以及目标整数 $T$（满足 $-10000 \\le T \\le 10000 $ ）。  \n接下来的 $n$ 行包含原始序列：对于每个 $i \\  (1 \\le i \\le n)$ ，输入文件的第 $i+1$ 行即为整数 $a_i$（满足 $1 \\le a_i \\le 100$ ）。", "outputFormat": "输出应包含 $n-1$ 行，描述将原始序列转换为仅包含数字 $T$ 的单元素序列的操作方案。输出文件的第 $i$ 行应包含一个整数，表示第 $i$ 次操作所选择的 $t$。  \n保证对于给定的输入，至少存在一个这样的操作方案。", "hint": "**样例解释：**\n\n| 操作次数 | 数列 |\n| :----------: | :----------: |\n| $0$ | $\\{12,10,4,3,5\\}$ |\n| $1$ | $\\{12,6,3,5\\}$ |\n| $2$ | $\\{12,6,-2\\}$ |\n| $3$ | $\\{12,8\\}$ |\n| $4$ | $\\{4\\}$ |", "locale": "zh-CN"}}}
{"pid": "P10961", "type": "P", "difficulty": 4, "samples": [["4 7 4 5 9 1\n9 8 1 7 2 4\n6 6 8 5 9 2\n1 6 6 1 0 7\n5 9 3 8 8 4\n0 0 0 0 0 0", "Can't\nCan\nCan't\nCan't\nCan"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "O2优化", "背包 DP", "动态规划优化"], "title": "划分大理石", "background": "", "description": "有价值分别为 $1,2,\\dots,6$ 的大理石各 $a_1,a_2,\\dots,a_6$ 块，现要将它们分成两部分，使得两部分价值之和相等，问是否可以实现。其中大理石的总数不超过 $20000$。 ", "inputFormat": "本题有多组数据，每组数据以单独的一行 $6$ 个整数呈现，分别表示 $a_1,a_2,\\dots,a_6$。如果一行中 $6$ 个整数均为 $0$，表示输入文件结束。\n\n对于每一个测试点，有效测试数据组数不超过 $100$ 组。", "outputFormat": "对于每一组数据，如果划分成功，输出 `Can`，否则输出 `Can't`。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "划分大理石", "background": "", "description": "有价值分别为 $1,2,\\dots,6$ 的大理石各 $a_1,a_2,\\dots,a_6$ 块，现要将它们分成两部分，使得两部分价值之和相等，问是否可以实现。其中大理石的总数不超过 $20000$。 ", "inputFormat": "本题有多组数据，每组数据以单独的一行 $6$ 个整数呈现，分别表示 $a_1,a_2,\\dots,a_6$。如果一行中 $6$ 个整数均为 $0$，表示输入文件结束。\n\n对于每一个测试点，有效测试数据组数不超过 $100$ 组。", "outputFormat": "对于每一组数据，如果划分成功，输出 `Can`，否则输出 `Can't`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10962", "type": "P", "difficulty": 4, "samples": [["5\n1 1\n2 1\n3 1\n1 1", "3\n2\n3\n4\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["树形 DP"], "title": "Computer", "background": "", "description": "A school bought the first computersome time ago(so this computer's id is 1). During the recent years the schol bought N-1 new computers. ach new computer wasconnected to one ofsetled eartier. Managers ofschool are anxious about slow finctioning ofthe net and want to know the maximum distance si for which i-thcomputer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2dycu3sg.png)\n\nHint: he example input is coresponding to this graph. And from the graph, you can se that the computer 4 is farthest one from 1, so S1 =3. Computer 4 and 5 are the farthest ones from 2, so S2=2. Computer 5 is the farthest one from3.so S3=3. We also get S4=4，S5-4.\n", "inputFormat": "Input file contains multiple test cases.in each case there is natural number N (N<=10000) in the first line, folowed by (N-1) lines with descriptions of computers. ithline contains two natural numbers - number of computer.to which i-th computer is conected and leneth ofcable used for connection. \"otaleneth of cable doe notexceed 10^9. Numbers in lines ofinput are separated by a space.\n", "outputFormat": "For each case output N lines. i-th line must contain number Si for i-th computer (1<-i<=N)\n", "hint": "", "locale": "en", "translations": {"en": {"title": "Computer", "background": "", "description": "A school bought the first computersome time ago(so this computer's id is 1). During the recent years the schol bought N-1 new computers. ach new computer wasconnected to one ofsetled eartier. Managers ofschool are anxious about slow finctioning ofthe net and want to know the maximum distance si for which i-thcomputer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2dycu3sg.png)\n\nHint: he example input is coresponding to this graph. And from the graph, you can se that the computer 4 is farthest one from 1, so S1 =3. Computer 4 and 5 are the farthest ones from 2, so S2=2. Computer 5 is the farthest one from3.so S3=3. We also get S4=4，S5-4.\n", "inputFormat": "Input file contains multiple test cases.in each case there is natural number N (N<=10000) in the first line, folowed by (N-1) lines with descriptions of computers. ithline contains two natural numbers - number of computer.to which i-th computer is conected and leneth ofcable used for connection. \"otaleneth of cable doe notexceed 10^9. Numbers in lines ofinput are separated by a space.\n", "outputFormat": "For each case output N lines. i-th line must contain number Si for i-th computer (1<-i<=N)\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "Computer", "background": "", "description": "某学校在一段时间前购买了第一台计算机（因此这台计算机的编号是 1）。在最近几年中，学校又购买了 $N-1$ 台新计算机。每台新计算机都连接到之前已经安装的计算机之一。学校的管理人员对网络运行缓慢感到担忧，想知道每台计算机需要发送信号的最大距离 $S_i$（即到最远计算机的电缆长度）。你需要提供这些信息。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2dycu3sg.png)\n\n提示：示例输入对应于此图。从图中可以看到，计算机 4 是距离计算机 1 最远的，因此 $S_1 = 3$。计算机 4 和 5 是距离计算机 2 最远的，因此 $S_2 = 2$。计算机 5 是距离计算机 3 最远的，因此 $S_3 = 3$。我们还得到 $S_4 = 4$，$S_5 = 4$。", "inputFormat": "输入文件包含多个测试用例。每个用例的第一行是自然数 $N$（$N \\leq 10000$），接下来的 $N-1$ 行描述了计算机的连接情况。第 $i$ 行包含两个自然数——第 $i$ 台计算机连接的计算机编号和用于连接的电缆长度。电缆的总长度不超过 $10^9$。输入行中的数字由空格分隔。\n", "outputFormat": "对于每个用例，输出 $N$ 行。第 $i$ 行必须包含第 $i$ 台计算机的数值 $S_i$（$1 \\leq i \\leq N$）。\n", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P10963", "type": "P", "difficulty": 5, "samples": [["2\n3 3\n2 2 2\n1 2\n2 3\n3 1 \n4 6\n1 2 3 4\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4", "22 3\n69 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2004", "上海", "ICPC"], "title": "[ICPC-Shanghai 2004] Islands and Bridges", "background": null, "description": "Given a map of islands and bridges that connect these islands, a Hamilton path, as we all know, is a path along the bridges such that it visits each island exactly once. On our map, there is also a positive integer value associated with each island. We call a Hamilton path the best triangular Hamilton path if it maximizes the value described below.\n\nSuppose there are $n$ islands. The value of a Hamilton path $C_1 C_2 \\dots C_n $ is calculated as the sum of three parts. Let Vi be the value for the island $C_i$. As the first part, we sum over all the Vi values for each island in the path. For the second part, for each edge $C_i C_{i+1}$ in the path, we add the product $V_i \\times V_{i+1}$. And for the third part, whenever three consecutive islands $C_i,C_{i+1},C_{i+2}$ in the path forms a triangle in the map, i.e. there is a bridge between $C_i$ and $C_{i+2}$, we add the product $V_i \\times V_{i+1} \\times V_{i+2}$.\n\nMost likely but not necessarily, the best triangular Hamilton path you are going to find contains many triangles. It is quite possible that there might be more than one best triangular Hamilton paths; your second task is to find the number of such paths.", "inputFormat": "The input file starts with a number $ q  (q \\le 20)$ on the first line, which is the number of test cases. Each test case starts with a line with two integers $n$ and $m$, which are the number of islands and the number of bridges in the map, respectively. The next line contains $n$ positive integers, the $i$-th number being the $V_i$ value of island $i$. Each value is no more than $100$. The following $m$ lines are in the form $x\\ y$, which indicates there is a (two way) bridge between island $x$ and island $y$. Islands are numbered from $1$ to $n$. You may assume there will be no more than $13$ islands.", "outputFormat": "For each test case, output a line with two numbers, separated by a space. The first number is the maximum value of a best triangular Hamilton path; the second number should be the number of different best triangular Hamilton paths. If the test case does not contain a Hamilton path, the output must be $0\\ 0$.\n\nNote: A path may be written down in the reversed order. We still think it is the same path.", "hint": null, "locale": "en", "translations": {"en": {"title": "[ICPC-Shanghai 2004] Islands and Bridges", "background": null, "description": "Given a map of islands and bridges that connect these islands, a Hamilton path, as we all know, is a path along the bridges such that it visits each island exactly once. On our map, there is also a positive integer value associated with each island. We call a Hamilton path the best triangular Hamilton path if it maximizes the value described below.\n\nSuppose there are $n$ islands. The value of a Hamilton path $C_1 C_2 \\dots C_n $ is calculated as the sum of three parts. Let Vi be the value for the island $C_i$. As the first part, we sum over all the Vi values for each island in the path. For the second part, for each edge $C_i C_{i+1}$ in the path, we add the product $V_i \\times V_{i+1}$. And for the third part, whenever three consecutive islands $C_i,C_{i+1},C_{i+2}$ in the path forms a triangle in the map, i.e. there is a bridge between $C_i$ and $C_{i+2}$, we add the product $V_i \\times V_{i+1} \\times V_{i+2}$.\n\nMost likely but not necessarily, the best triangular Hamilton path you are going to find contains many triangles. It is quite possible that there might be more than one best triangular Hamilton paths; your second task is to find the number of such paths.", "inputFormat": "The input file starts with a number $ q  (q \\le 20)$ on the first line, which is the number of test cases. Each test case starts with a line with two integers $n$ and $m$, which are the number of islands and the number of bridges in the map, respectively. The next line contains $n$ positive integers, the $i$-th number being the $V_i$ value of island $i$. Each value is no more than $100$. The following $m$ lines are in the form $x\\ y$, which indicates there is a (two way) bridge between island $x$ and island $y$. Islands are numbered from $1$ to $n$. You may assume there will be no more than $13$ islands.", "outputFormat": "For each test case, output a line with two numbers, separated by a space. The first number is the maximum value of a best triangular Hamilton path; the second number should be the number of different best triangular Hamilton paths. If the test case does not contain a Hamilton path, the output must be $0\\ 0$.\n\nNote: A path may be written down in the reversed order. We still think it is the same path.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[ICPC-Shanghai 2004] Islands and Bridges", "background": null, "description": "给定一张由岛屿和连接这些岛屿的桥梁构成的地图，众所周知，哈密顿路径是沿着桥梁的路径，能够恰好访问每个岛屿一次。在我们的地图中，每个岛屿还关联一个正整数值。我们定义一种哈密顿路径为 **最佳三角形哈密顿路径**，其最大化以下描述的值。\n\n假设有 $n$ 个岛屿。哈密顿路径 $C_1,C_2,\\dots,C_n$ 的值分为三部分计算。设 $V_i$ 为岛屿 $C_i$ 的值。第一部分为路径中每个岛屿的 $V_i$ 值的总和。第二部分，对于路径中的每条边 $C_i C_{i+1}$，加上 $V_i \\times V_{i+1}$ 的积。第三部分，对于路径中的每三个连续岛屿 $C_i, C_{i+1}, C_{i+2}$，如果它们在地图中形成一个三角形（即 $C_i$ 和 $C_{i+2}$ 之间有桥），加上 $V_i \\times V_{i+1} \\times V_{i+2}$ 的积。\n\n最佳三角形哈密顿路径很可能（但不一定）包含多个三角形。可能会存在多个最佳三角形哈密顿路径。你的第二个任务是找出这样的路径的数量。\n\n---", "inputFormat": "输入文件的第一行是一个整数 $q\\ (q \\le 20)$，表示测试用例的数量。\n\n每个测试用例的第一行有两个整数 $n$ 和 $m$，分别表示地图中岛屿的数量和桥梁的数量。\n\n接下来的第一行包含 $n$ 个正整数，第 $i$ 个数是岛屿 $i$ 的 $V_i$ 值。每个值不超过 $100$。\n\n接下来的 $m$ 行，每行的格式为 $x\\ y$，表示岛屿 $x$ 和岛屿 $y$ 之间有一座双向桥。岛屿从 $1$ 到 $n$ 编号。可以假设岛屿总数不超过 $13$。\n\n---", "outputFormat": "对于每个测试用例，输出一行，包含两个用空格分隔的数。第一个数是最佳三角形哈密顿路径的最大值；第二个数是不同最佳三角形哈密顿路径的数量。如果测试用例中不存在哈密顿路径，则输出 $0\\ 0$。\n\n注意：如果一条路径的顺序反转，仍认为它是相同的路径。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P10964", "type": "P", "difficulty": 5, "samples": [["4 0\n-2 1\n-1 2\n-3 0\n-2 1", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "线段树", "颜色段均摊（珂朵莉树 ODT）", "动态规划优化", "线性 DP"], "title": "Fence Obstacle Course", "background": "与原题相比，$N$ 的数据范围调整为了 $1\\leq N\\leq 100000$，其他数据范围并无变化。", "description": "Farmer John has constructed an obstacle course for the cow's enjoyment. The course consists of a sequence of $N$ fences ($1\\le N \\le 100000$) of varying lengths, each parallel to the x axis. Fence i's y coordinate is i.\n\nThe door to FJ's barn is at the origin (marked '`*`' below). The starting point of the course lies at coordinate ($S$,$N$).\n\n```\n   +--S--+-+-+\n+--+--+--+\n    ...\n   +--+--+-+\n      +--+-+-+\n|==|==|==*=|=|=|\n-3 -2 -1 0 1 2 3\n```\n\nFJ's original intention was for the cows to jump over the fences, but cows are much more comfortable keeping all four hooves on the ground. Thus, they will walk along the fence and, when the fence ends, they will turn towards the x axis and continue walking in a straight line until the hit another fence segment or the side of the barn. Then they decide to go left or right until they reach the end of the fence segment, and so on, until they finally reach the side of the barn and then, potentially after a short walk, the ending point.\n\nNaturally, the cows want to walk as little as possible. Find the minimum distance the cows have to travel back and forth to get from the starting point to the door of the barn.\n", "inputFormat": "- Line 1: Two space-separated integers: $N$ and $S$. ($-100000\\le S \\le 100000$)\n- Line 2~N+1: Each line contains two space-separated integers : $A_i$ and $B_i$ ($-100000\\le A_i < B_i \\le 100000 $) , the starting and ending x-coordinates of fence segment i. Line 2 describes fence #2; line 3 describes fence #2; and so on. The starting position will satisfy $A_N \\le S \\le B_N$. Note that the fences will be traversed in reverse order of the input sequence.\n", "outputFormat": "- Line 1: The minimum distance back and forth in the x direction required to get from the starting point to the ending point by walking around the fences. The distance in the y direction is not counted, since it is always precisely $N$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "Fence Obstacle Course", "background": "与原题相比，$N$ 的数据范围调整为了 $1\\leq N\\leq 100000$，其他数据范围并无变化。", "description": "Farmer John has constructed an obstacle course for the cow's enjoyment. The course consists of a sequence of $N$ fences ($1\\le N \\le 100000$) of varying lengths, each parallel to the x axis. Fence i's y coordinate is i.\n\nThe door to FJ's barn is at the origin (marked '`*`' below). The starting point of the course lies at coordinate ($S$,$N$).\n\n```\n   +--S--+-+-+\n+--+--+--+\n    ...\n   +--+--+-+\n      +--+-+-+\n|==|==|==*=|=|=|\n-3 -2 -1 0 1 2 3\n```\n\nFJ's original intention was for the cows to jump over the fences, but cows are much more comfortable keeping all four hooves on the ground. Thus, they will walk along the fence and, when the fence ends, they will turn towards the x axis and continue walking in a straight line until the hit another fence segment or the side of the barn. Then they decide to go left or right until they reach the end of the fence segment, and so on, until they finally reach the side of the barn and then, potentially after a short walk, the ending point.\n\nNaturally, the cows want to walk as little as possible. Find the minimum distance the cows have to travel back and forth to get from the starting point to the door of the barn.\n", "inputFormat": "- Line 1: Two space-separated integers: $N$ and $S$. ($-100000\\le S \\le 100000$)\n- Line 2~N+1: Each line contains two space-separated integers : $A_i$ and $B_i$ ($-100000\\le A_i < B_i \\le 100000 $) , the starting and ending x-coordinates of fence segment i. Line 2 describes fence #2; line 3 describes fence #2; and so on. The starting position will satisfy $A_N \\le S \\le B_N$. Note that the fences will be traversed in reverse order of the input sequence.\n", "outputFormat": "- Line 1: The minimum distance back and forth in the x direction required to get from the starting point to the ending point by walking around the fences. The distance in the y direction is not counted, since it is always precisely $N$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "Fence Obstacle Course", "background": null, "description": "农夫约翰为奶牛们建造了一条障碍赛道。赛道由一系列 $N$ 个长度不一的栅栏组成（$1 \\le N \\le 100000$），每个栅栏都与 x 轴平行。栅栏 $i$ 的 y 坐标为 $i$。\n\nFJ 的谷仓门位于原点（如下图中的 '`*`' 处）。赛道的起点位于坐标 ($S$,$N$)。\n\n```\n   +--S--+-+-+\n+--+--+--+\n    ...\n   +--+--+-+\n      +--+-+-+\n|==|==|==*=|=|=|\n-3 -2 -1 0 1 2 3\n```\n\nFJ 原本的意图是让奶牛跳过栅栏，但奶牛更喜欢四蹄着地。因此，它们会沿着栅栏行走，当栅栏结束时，它们会转向 x 轴并继续直线行走，直到碰到另一个栅栏段或谷仓的侧面。然后它们决定向左或向右走，直到到达栅栏段的末端，依此类推，直到最终到达谷仓的侧面，然后可能经过短暂的步行，达到终点。\n\n自然地，奶牛们希望尽可能少地行走。找出奶牛们从起点到谷仓门来回行走的最短距离。", "inputFormat": "- 第 1 行：两个用空格分隔的整数：$N$ 和 $S$。($-100000 \\le S \\le 100000$)\n- 第 2 行到第 $N+1$ 行：每行包含两个用空格分隔的整数：$A_i$ 和 $B_i$ ($-100000 \\le A_i < B_i \\le 100000$)，分别表示栅栏段 $i$ 的起始和结束 x 坐标。第 2 行描述栅栏 #1；第 3 行描述栅栏 #2；依此类推。起始位置将满足 $A_N \\le S \\le B_N$。注意，栅栏将按照输入序列的逆序遍历。", "outputFormat": "- 第 1 行：从起点到终点绕过栅栏所需的最小 x 方向来回距离。y 方向的距离不计入，因为它始终为 $N$。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P10965", "type": "P", "difficulty": 5, "samples": [["2 4\nabcw\nwxyz", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "O2优化", "单调栈"], "title": "Largest Submatrix", "background": "", "description": "Now here is a matrix with letter 'a','b','c','w','x','y','z' and you can change 'w' to 'a' or 'b', change 'x' to 'b' or 'c', change 'y' to 'a' or 'c', and change 'z' to 'a', 'b' or 'c'. After you changed it, what's the largest submatrix with the same letters you can make?", "inputFormat": "The input contains multiple test cases. Each test case begins with $m$ and $n (1 <m,n< 1000)$ on line. Then come the elements of a matrix in row-major order on m lines each with n letters. The input ends once EOF is met.", "outputFormat": "For each test case, output one line containing the number of elements of the largest submatrix of all same letters.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "Largest Submatrix", "background": "", "description": "Now here is a matrix with letter 'a','b','c','w','x','y','z' and you can change 'w' to 'a' or 'b', change 'x' to 'b' or 'c', change 'y' to 'a' or 'c', and change 'z' to 'a', 'b' or 'c'. After you changed it, what's the largest submatrix with the same letters you can make?", "inputFormat": "The input contains multiple test cases. Each test case begins with $m$ and $n (1 <m,n< 1000)$ on line. Then come the elements of a matrix in row-major order on m lines each with n letters. The input ends once EOF is met.", "outputFormat": "For each test case, output one line containing the number of elements of the largest submatrix of all same letters.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "Largest Submatrix", "background": null, "description": "现在你有一个有 $n$ 行，$m$ 列的矩阵，它的每个元素都是 `a`，`b`，`c`，`w`，`x`，`y`，`z`，中的一个。现在你可以进行无限次如下操作：\n\n- 将 `w` 替换为 `a` 或 `b`。\n- 将 `x` 替换为 `b` 或 `c`。\n- 将 `y` 替换为 `a` 或 `c`。\n- 将 `z` 替换为 `a` 或 `b` 或 `c`。\n\n在你操作结束后，这个矩阵最大的全部元素都相同的子矩阵的元素个数最多是多少？", "inputFormat": "**本题有多组测试数据。**\n\n对于每组测试数据，第一行是两个整数 $n,m  (1 <m,n< 1000) $，分别代表初始矩阵的行、列数。\n\n之后的 $n$ 行，每行 $m$ 个字符，表示初始的矩阵。", "outputFormat": "对于每组测试数据，输出一行，表示你操作结束后这个矩阵最大的全部元素都相同的子矩阵的元素个数的最大值。\n\n### 样例解释\n\n操作后的矩阵可以是这个样子：\n\n```\nabcw\nwccc\n```", "hint": null, "locale": "zh-CN"}}}
{"pid": "P10966", "type": "P", "difficulty": 6, "samples": [["2\n7 3\n2 2 3 4 4 5 5\n6 2\n0 3 3 4 8 9", "3\n5"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["动态规划 DP", "O2优化", "动态规划优化", "斜率优化", "四边形不等式", "线性 DP"], "title": "K-Anonymous Sequence", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/orua22pd.png)", "inputFormat": "![](https://cdn.luogu.com.cn/upload/image_hosting/lbo5vs9c.png)", "outputFormat": "For each test, output one line containing a single integer-the minimal cost", "hint": "", "locale": "en", "translations": {"en": {"title": "K-Anonymous Sequence", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/orua22pd.png)", "inputFormat": "![](https://cdn.luogu.com.cn/upload/image_hosting/lbo5vs9c.png)", "outputFormat": "For each test, output one line containing a single integer-the minimal cost", "hint": "", "locale": "en"}, "zh-CN": {"title": "K-Anonymous Sequence", "background": "", "description": "各种应用领域中爆炸式增长的网络数据引发了相关个人的隐私问题。最近的研究表明，在发布图形/社交网络数据之前简单地删除节点的身份并不能保证隐私。图本身的结构及其基本形式——节点度，可以揭示个体的身份。\n\n为了解决这个问题，我们研究了一个特定的图匿名化问题。如果对于每个节点 $v$，图中至少存在 $k-1$ 个与 $v$ 具有相同度数的其他节点，则称这个图为 $k$-anonymous。我们感兴趣的是在图上进行最少修改操作后实现 $k$-anonymous。  \n\n我们简化了这个问题。从整个图 $G$ 中选取 $n$ 个节点，并按升序列出它们的度数。我们定义一个序列是 $k$-anonymous，当且仅当对于每个元素 $s$，序列中至少存在 $k-1$ 个等于 $s$ 的其他元素。要让给定的序列 $k$-anonymous，你只能做一种操作——减少序列中的一些数字。我们定义修改的成本为你修改的所有数字的差值。例如，$k=3$ 的序列 $2,2,3,4,4,5,5$ 可以修改为 $2,2,2,4,4,4,4$，满足 $3$-anonymous，修改的成本为 $|3-2|+|5-4|+|5-4|=3$。  \n\n给出一个长为 $n$ 的按升序排列的序列和 $k$，我们想知道在所有使序列变为 $k$-anonymous 的修改方式中成本最小的一个。", "inputFormat": "**本题有多组数据**。\n\n第一行一个整数 $T$（$1\\le T\\le20$），表示数据组数。\n\n对于每组数据：\n\n第一行两个整数 $n,k$（$2\\le k\\le n\\le5\\times10^5$）。\n\n第二行 $n$ 个整数，即按升序排列的度数序列。序列中的每个数字 $s$ 都在 $\\left[0,5\\times10^5\\right]$ 范围内。", "outputFormat": "对于每个测试，输出一行一个整数，表示最小成本。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10967", "type": "P", "difficulty": 4, "samples": [["10 5\n1 2 3 6 7 9 11 22 44 50", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "递推", "2000", "IOI", "O2优化", "前缀和"], "title": "[IOI 2000] 邮局（原始版）", "background": null, "description": "高速公路旁边有一些村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标表示。没有两个在同样地方的村庄。两个位置之间的距离是其整数坐标差的绝对值。\n\n邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。\n\n你要编写一个程序，已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。", "inputFormat": "第一行包含两个整数：第一个是村庄 $V$ 的数量，第二个是邮局的数量 $P$。\n\n第二行包含 $V$ 个整数。这些整数是村庄的位置。", "outputFormat": "第一行包含一个整数 $S$，它是每个村庄与其最近的邮局之间的所有距离的总和。", "hint": "数据保证，$1 \\le V \\le 300$，$1 \\le P \\le 30$，$P \\le V$，$1 \\le X \\le 10000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2000] 邮局（原始版）", "background": null, "description": "高速公路旁边有一些村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标表示。没有两个在同样地方的村庄。两个位置之间的距离是其整数坐标差的绝对值。\n\n邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。\n\n你要编写一个程序，已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。", "inputFormat": "第一行包含两个整数：第一个是村庄 $V$ 的数量，第二个是邮局的数量 $P$。\n\n第二行包含 $V$ 个整数。这些整数是村庄的位置。", "outputFormat": "第一行包含一个整数 $S$，它是每个村庄与其最近的邮局之间的所有距离的总和。", "hint": "数据保证，$1 \\le V \\le 300$，$1 \\le P \\le 30$，$P \\le V$，$1 \\le X \\le 10000$。", "locale": "zh-CN"}}}
{"pid": "P10968", "type": "P", "difficulty": 5, "samples": [["5\n1 TC\n2 TC TS\n5 2C AD AC JC JH\n4 AC KC QC JC\n6 AC AD AS JC JD KD", "Case #1: 1 \nCase #2: 0 \nCase #3: 48 \nCase #4: 24 \nCase #5: 120"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["动态规划 DP"], "title": "扑克牌", "background": null, "description": "一副不含王的扑克牌由 $52$ 张牌组成，由红桃、黑桃、梅花、方块 $4$ 组牌组成，每组 $13$ 张不同的面值。现在给定 $52$ 张牌中的若干张，请计算将它们排成一列，相邻的牌面值不同的方案数。\n\n牌的表示方法为 $\\texttt{XY}$，其中 $\\texttt{X}$ 为面值，为 $\\texttt{2},\\texttt{3},\\texttt{4},\\texttt{5},\\texttt{6},\\texttt{7},\\texttt{8},\\texttt{9},\\texttt{T},\\texttt{J},\\texttt{Q},\\texttt{K},\\texttt{A}$ 中的一个。$\\texttt{Y}$ 为花色，为 $\\texttt{S},\\texttt{H},\\texttt{D},\\texttt{C}$ 中的一个。如 $\\texttt{2S},\\texttt{2H},\\texttt{TD}$ 等。", "inputFormat": "第一行为一个整数 $T$，为数据组数。\n\n之后每组数据占一行。这一行首先包含一个整数 $N$，表示给定的牌的张数，接下来 $N$ 个由空格分隔的字符串，每个字符串长度为 $2$，表示一张牌。每组数据中的扑克牌各不相同。", "outputFormat": "对于每组数据输出一行，形如 `Case #X: Y`。$X$ 为数据组数，从 $1$ 开始。$Y$ 为可能的方案数，由于答案可能很大，请输出模 $2^{64}$ 之后的值。", "hint": null, "locale": "zh-CN", "translations": {"zh-CN": {"title": "扑克牌", "background": null, "description": "一副不含王的扑克牌由 $52$ 张牌组成，由红桃、黑桃、梅花、方块 $4$ 组牌组成，每组 $13$ 张不同的面值。现在给定 $52$ 张牌中的若干张，请计算将它们排成一列，相邻的牌面值不同的方案数。\n\n牌的表示方法为 $\\texttt{XY}$，其中 $\\texttt{X}$ 为面值，为 $\\texttt{2},\\texttt{3},\\texttt{4},\\texttt{5},\\texttt{6},\\texttt{7},\\texttt{8},\\texttt{9},\\texttt{T},\\texttt{J},\\texttt{Q},\\texttt{K},\\texttt{A}$ 中的一个。$\\texttt{Y}$ 为花色，为 $\\texttt{S},\\texttt{H},\\texttt{D},\\texttt{C}$ 中的一个。如 $\\texttt{2S},\\texttt{2H},\\texttt{TD}$ 等。", "inputFormat": "第一行为一个整数 $T$，为数据组数。\n\n之后每组数据占一行。这一行首先包含一个整数 $N$，表示给定的牌的张数，接下来 $N$ 个由空格分隔的字符串，每个字符串长度为 $2$，表示一张牌。每组数据中的扑克牌各不相同。", "outputFormat": "对于每组数据输出一行，形如 `Case #X: Y`。$X$ 为数据组数，从 $1$ 开始。$Y$ 为可能的方案数，由于答案可能很大，请输出模 $2^{64}$ 之后的值。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P10969", "type": "P", "difficulty": 5, "samples": [["4 4\n0 1 1 AND\n1 2 1 OR\n3 2 0 AND\n3 0 0 XOR", "YES"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["2-SAT"], "title": "Katu Puzzle", "background": "", "description": "Katu Puzzle 以一个有向图 $G(V, E)$ 的形式给出，其中每条边 $e(a, b)$ 都被标记为一个布尔运算符 $\\text{op}$（AND, OR, XOR 之一）以及一个整数 $c$（$0 \\leq c \\leq 1$）。如果可以为每个顶点 $V_i$ 找到一个值 $X_i$（$0 \\leq X_i \\leq 1$），使得对于每条边 $e(a, b)$ 由 $\\text{op}$ 和 $c$ 标记的情况下，以下公式成立：\n\n$$X_a \\ \\text{op} \\ X_b = c$$\n\n那么这个 Katu 是可解的。\n\n给定一个 Katu Puzzle，你的任务是确定它是否可解。", "inputFormat": "第一行包含两个整数 $N$（$1 \\leq N \\leq 100$）和 $M$（$0 \\leq M \\leq 10,000$），分别表示顶点的数量和边的数量。\n\n接下来的 $M$ 行中，每行包含三个整数 $a$（$0 \\leq a < N$），$b$（$0 \\leq b < N$），$c$ 以及一个操作符 $\\text{op}$，描述这条边。", "outputFormat": "输出一行，包含 $\\texttt{YES}$ 或 $\\texttt{NO}$。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Katu Puzzle", "background": "", "description": "Katu Puzzle 以一个有向图 $G(V, E)$ 的形式给出，其中每条边 $e(a, b)$ 都被标记为一个布尔运算符 $\\text{op}$（AND, OR, XOR 之一）以及一个整数 $c$（$0 \\leq c \\leq 1$）。如果可以为每个顶点 $V_i$ 找到一个值 $X_i$（$0 \\leq X_i \\leq 1$），使得对于每条边 $e(a, b)$ 由 $\\text{op}$ 和 $c$ 标记的情况下，以下公式成立：\n\n$$X_a \\ \\text{op} \\ X_b = c$$\n\n那么这个 Katu 是可解的。\n\n给定一个 Katu Puzzle，你的任务是确定它是否可解。", "inputFormat": "第一行包含两个整数 $N$（$1 \\leq N \\leq 100$）和 $M$（$0 \\leq M \\leq 10,000$），分别表示顶点的数量和边的数量。\n\n接下来的 $M$ 行中，每行包含三个整数 $a$（$0 \\leq a < N$），$b$（$0 \\leq b < N$），$c$ 以及一个操作符 $\\text{op}$，描述这条边。", "outputFormat": "输出一行，包含 $\\texttt{YES}$ 或 $\\texttt{NO}$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10971", "type": "P", "difficulty": 5, "samples": [["3 20\n1 2 3", "2\n2 9 9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "贪心", "Special Judge"], "title": "Cookies", "background": "", "description": "圣诞老人共有 $M$ 个饼干，准备全部分给 $N$ 个孩子。\n\n每个孩子有一个贪婪度，第 $i$ 个孩子的贪婪度为 $g_i$。\n\n如果有 $a_i$ 个孩子拿到的饼干数比第 $i$ 个孩子多，那么第 $i$ 个孩子会产生 $g_i\\times a_i$ 的怨气。\n\n给定 $N$、$M$ 和序列 $g$，圣诞老人请你帮他安排一种分配方式，使得每个孩子至少分到一块饼干，并且所有孩子的怨气总和最小。", "inputFormat": "第一行包含两个整数 $N,M$。\n\n第二行包含 $N$ 个整数表示 $g_1,g_2,\\dots,g_n$。", "outputFormat": "第一行一个整数表示最小怨气总和。\n\n第二行 $N$ 个空格隔开的整数表示每个孩子分到的饼干数，若有多种方案，输出任意一种均可。", "hint": "数据保证，$1\\leq N\\leq 30$，$N\\leq M\\leq 5000$，$1\\leq g_i\\leq 10^7$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Cookies", "background": "", "description": "圣诞老人共有 $M$ 个饼干，准备全部分给 $N$ 个孩子。\n\n每个孩子有一个贪婪度，第 $i$ 个孩子的贪婪度为 $g_i$。\n\n如果有 $a_i$ 个孩子拿到的饼干数比第 $i$ 个孩子多，那么第 $i$ 个孩子会产生 $g_i\\times a_i$ 的怨气。\n\n给定 $N$、$M$ 和序列 $g$，圣诞老人请你帮他安排一种分配方式，使得每个孩子至少分到一块饼干，并且所有孩子的怨气总和最小。", "inputFormat": "第一行包含两个整数 $N,M$。\n\n第二行包含 $N$ 个整数表示 $g_1,g_2,\\dots,g_n$。", "outputFormat": "第一行一个整数表示最小怨气总和。\n\n第二行 $N$ 个空格隔开的整数表示每个孩子分到的饼干数，若有多种方案，输出任意一种均可。", "hint": "数据保证，$1\\leq N\\leq 30$，$N\\leq M\\leq 5000$，$1\\leq g_i\\leq 10^7$。", "locale": "zh-CN"}}}
{"pid": "P10972", "type": "P", "difficulty": 5, "samples": [["2 3 4\n10 20 30\n40 2 3", "Oil : 100\n1 1\n1 2\n1 3\n2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "Special Judge", "线性 DP"], "title": "I-Country", "background": "", "description": "根据绝密的 A 国计划，I 国被划分为 $N\\times M$ 个相等的正方形，每个正方形包含一些石油资源。他们希望占领整个 I 国的领土，但联合国只允许他们占领 $K$ 个正方形。\n\n当然，A 国希望控制尽可能多的石油，但是他们必须守卫他们的全部领土。因此，他们需要他们的领土易于控制，即从任何一个正方形到另一个正方形只能沿着两个方向移动（从下列列表中选择：左、右、上、下；对于不同的正方形对，方向可能不同）。\n\n你需要编写一个程序，确定 A 国将占领哪些正方形。如果有多个解决方案，你可以输出任意一个。", "inputFormat": "输入的第一行包含 3 个整数 $N$、$M$、$K$（$1≤N, M≤15$，$0≤K≤N\\times M$）。\n\n接下来的 $N$ 行包含每行 $M$ 个整数，表示该正方形上的石油资源数量。每个数字的范围在 $0$ 到 $1000$ 之间。", "outputFormat": "输出的第一行是字符串 Oil : X，其中 $X$ 是 A 国可以控制的最大石油数量。\n\n接下来，你应该输出 $K$ 对数字，表示 A 国将占领的正方形的坐标。第一个坐标是行号（从上到下，从 $1$ 开始），第二个是列号（从左到右，从 $1$ 开始）。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "I-Country", "background": "", "description": "根据绝密的 A 国计划，I 国被划分为 $N\\times M$ 个相等的正方形，每个正方形包含一些石油资源。他们希望占领整个 I 国的领土，但联合国只允许他们占领 $K$ 个正方形。\n\n当然，A 国希望控制尽可能多的石油，但是他们必须守卫他们的全部领土。因此，他们需要他们的领土易于控制，即从任何一个正方形到另一个正方形只能沿着两个方向移动（从下列列表中选择：左、右、上、下；对于不同的正方形对，方向可能不同）。\n\n你需要编写一个程序，确定 A 国将占领哪些正方形。如果有多个解决方案，你可以输出任意一个。", "inputFormat": "输入的第一行包含 3 个整数 $N$、$M$、$K$（$1≤N, M≤15$，$0≤K≤N\\times M$）。\n\n接下来的 $N$ 行包含每行 $M$ 个整数，表示该正方形上的石油资源数量。每个数字的范围在 $0$ 到 $1000$ 之间。", "outputFormat": "输出的第一行是字符串 Oil : X，其中 $X$ 是 A 国可以控制的最大石油数量。\n\n接下来，你应该输出 $K$ 对数字，表示 A 国将占领的正方形的坐标。第一个坐标是行号（从上到下，从 $1$ 开始），第二个是列号（从左到右，从 $1$ 开始）。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10973", "type": "P", "difficulty": 4, "samples": [["3 10\n1 2 4 2 1 1\n2 5\n1 4 2 1\n0 0", "8\n4"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["动态规划 DP", "背包 DP"], "title": "Coins", "background": "", "description": "银国的人们使用硬币。他们有面值分别为 $A_1, A_2, A_3, \\dots, A_n$ 的硬币。有一天，托尼打开了他的储蓄罐，发现里面有一些硬币。他决定去附近的商店购买一块非常漂亮的手表。他想要支付准确的价格（不找零），而他知道手表的价格不会超过 $m$ 。但他不知道手表的确切价格。\n\n你需要编写一个程序，读取 $n$、$m$、$A_1, A_2, A_3, \\dots, A_n$ 以及对应的数量 $C_1, C_2, C_3, \\dots, C_n$ （表示托尼拥有的每种面值的硬币数量），然后计算托尼可以用这些硬币支付的价格数量（从 1 到 $m$ 的所有价格）。", "inputFormat": "输入包含多个测试用例（不超过 $25$ 组）。每个测试用例的第一行包含两个整数 $n (1 ≤ n ≤ 100)$ 和 $m (m ≤ 100000)$。第二行包含 $2n$ 个整数，分别表示 $A_1, A_2, A_3, \\dots, A_n$ 和 $C_1, C_2, C_3, \\dots, C_n (1 ≤ A_i ≤ 100000, 1 ≤ C_i ≤ 1000)$。最后一个测试用例以两个零结尾。\n", "outputFormat": "对于每个测试用例，在单独的一行输出答案。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Coins", "background": "", "description": "银国的人们使用硬币。他们有面值分别为 $A_1, A_2, A_3, \\dots, A_n$ 的硬币。有一天，托尼打开了他的储蓄罐，发现里面有一些硬币。他决定去附近的商店购买一块非常漂亮的手表。他想要支付准确的价格（不找零），而他知道手表的价格不会超过 $m$ 。但他不知道手表的确切价格。\n\n你需要编写一个程序，读取 $n$、$m$、$A_1, A_2, A_3, \\dots, A_n$ 以及对应的数量 $C_1, C_2, C_3, \\dots, C_n$ （表示托尼拥有的每种面值的硬币数量），然后计算托尼可以用这些硬币支付的价格数量（从 1 到 $m$ 的所有价格）。", "inputFormat": "输入包含多个测试用例（不超过 $25$ 组）。每个测试用例的第一行包含两个整数 $n (1 ≤ n ≤ 100)$ 和 $m (m ≤ 100000)$。第二行包含 $2n$ 个整数，分别表示 $A_1, A_2, A_3, \\dots, A_n$ 和 $C_1, C_2, C_3, \\dots, C_n (1 ≤ A_i ≤ 100000, 1 ≤ C_i ≤ 1000)$。最后一个测试用例以两个零结尾。\n", "outputFormat": "对于每个测试用例，在单独的一行输出答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10974", "type": "P", "difficulty": 5, "samples": [["1\n5\n1 2 11\n1 4 13\n3 4 5\n4 5 10", "26"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2008", "树形 DP", "ICPC"], "title": "Accumulation Degree", "background": "树木是自然景观的重要组成部分，因为它们可以防止土壤侵蚀，并在其树叶中及其下方提供特定的气候庇护生态系统。研究表明，树木在生产氧气和减少大气中的二氧化碳方面起着重要作用，还可以调节地面温度。它们在园林设计和农业中也是重要的元素，既因为它们的美学吸引力，也因为它们的果园作物（如苹果）。木材也是常见的建筑材料。", "description": "树在许多世界神话中也扮演着亲密的角色。许多学者对树的一些特殊属性感兴趣，例如树的中心、树的计数、树的着色等。树的累积度 $A(x)$ 就是其中的一种属性。\n\n我们这么定义 $A(x)$：\n\n- 树的每一条边都有一个正容量。\n- 树中度为 $1$ 的节点被称为终端节点。\n- 每条边的流量不能超过其容量。\n- $A(x)$ 是节点 $x$ 可以流向其他终端节点的最大流量。\n\n树的累积度是指其节点中最大累积度的值。你的任务是找到给定树的累积度。", "inputFormat": "输入的第一行是一个整数 $T$，表示测试用例的数量。每个测试用例的第一行是一个正整数 $n$。接下来的 $n - 1$ 行中的每一行包含三个整数 $x,y,z$，用空格分隔，表示节点 $x$ 和节点 $y$ 之间有一条边，并且这条边的容量为 $z$。节点编号从 $1$ 到 $n$。所有元素都是不超过 $200000$ 的非负整数。可以假设测试数据都是树。", "outputFormat": "对于每个测试用例，在单独的一行输出结果。", "hint": "原题中没有提到的数据范围：$T \\le 4$，$\\sum n \\le 2\\times 10 ^ 5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Accumulation Degree", "background": "树木是自然景观的重要组成部分，因为它们可以防止土壤侵蚀，并在其树叶中及其下方提供特定的气候庇护生态系统。研究表明，树木在生产氧气和减少大气中的二氧化碳方面起着重要作用，还可以调节地面温度。它们在园林设计和农业中也是重要的元素，既因为它们的美学吸引力，也因为它们的果园作物（如苹果）。木材也是常见的建筑材料。", "description": "树在许多世界神话中也扮演着亲密的角色。许多学者对树的一些特殊属性感兴趣，例如树的中心、树的计数、树的着色等。树的累积度 $A(x)$ 就是其中的一种属性。\n\n我们这么定义 $A(x)$：\n\n- 树的每一条边都有一个正容量。\n- 树中度为 $1$ 的节点被称为终端节点。\n- 每条边的流量不能超过其容量。\n- $A(x)$ 是节点 $x$ 可以流向其他终端节点的最大流量。\n\n树的累积度是指其节点中最大累积度的值。你的任务是找到给定树的累积度。", "inputFormat": "输入的第一行是一个整数 $T$，表示测试用例的数量。每个测试用例的第一行是一个正整数 $n$。接下来的 $n - 1$ 行中的每一行包含三个整数 $x,y,z$，用空格分隔，表示节点 $x$ 和节点 $y$ 之间有一条边，并且这条边的容量为 $z$。节点编号从 $1$ 到 $n$。所有元素都是不超过 $200000$ 的非负整数。可以假设测试数据都是树。", "outputFormat": "对于每个测试用例，在单独的一行输出结果。", "hint": "原题中没有提到的数据范围：$T \\le 4$，$\\sum n \\le 2\\times 10 ^ 5$。", "locale": "zh-CN"}}}
{"pid": "P10975", "type": "P", "difficulty": 5, "samples": [["1 2\n1 3\n1 4\n2 2\n2 3\n2 4\n2 11\n4 11\n0 0", "1\n0\n1\n2\n3\n5\n144\n51205"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["轮廓线 DP", "状压 DP"], "title": "Mondriaan's Dream", "background": "", "description": "荷兰著名画家皮特·蒙德里安对正方形和矩形非常着迷。有一天晚上，在创作完他的“厕所系列”画作后（他不得不用厕纸画画，因为他所有的画纸都用完了），他梦见用宽度为 $2$、高度为 $1$ 的小矩形以不同的方式填充一个大矩形。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5b9lwj6n.png)\n\n作为这方面的专家，他一眼就看出需要使用计算机来计算填充这个大矩形的不同方式。请帮助他，以免他的梦想变成噩梦！", "inputFormat": "输入包含多个测试用例。每个测试用例由两个整数构成：大矩形的高度 $h$ 和宽度 $w$。当 $h = w = 0$ 时输入结束。否则，$1 \\leq h, w \\leq 11$。\n", "outputFormat": "对于每个测试用例，输出使用大小为 $2\\times 1$ 的小矩形填充给定大矩形的不同方式的数量。假设给定的大矩形是定向的，即对称的铺砌方式应多次计算。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Mondriaan's Dream", "background": "", "description": "荷兰著名画家皮特·蒙德里安对正方形和矩形非常着迷。有一天晚上，在创作完他的“厕所系列”画作后（他不得不用厕纸画画，因为他所有的画纸都用完了），他梦见用宽度为 $2$、高度为 $1$ 的小矩形以不同的方式填充一个大矩形。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5b9lwj6n.png)\n\n作为这方面的专家，他一眼就看出需要使用计算机来计算填充这个大矩形的不同方式。请帮助他，以免他的梦想变成噩梦！", "inputFormat": "输入包含多个测试用例。每个测试用例由两个整数构成：大矩形的高度 $h$ 和宽度 $w$。当 $h = w = 0$ 时输入结束。否则，$1 \\leq h, w \\leq 11$。\n", "outputFormat": "对于每个测试用例，输出使用大小为 $2\\times 1$ 的小矩形填充给定大矩形的不同方式的数量。假设给定的大矩形是定向的，即对称的铺砌方式应多次计算。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10976", "type": "P", "difficulty": 4, "samples": [["ab 2\nacb 4\nacb 1\nacb 1", "2\n1"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["模拟", "倍增", "动态规划优化", "线性 DP"], "title": "统计重复个数", "background": "", "description": "定义 $str = [s, n]$ 表示 $str$ 由 $n$ 个字符串 $s$ 连接构成。\n\n例如，$str == [\\texttt{abc}, 3] == \\texttt{abcabcabc}$。\n如果可以从 $s_2$ 中删除某些字符使其变为 $s_1$，则称字符串 $s_1$ 可以从字符串 $s_2$ 获得。\n\n例如，根据定义，$s1 = \\tt{abc}$ 可以从 $s2 = \\tt{ab\\red{dbe}c}$ 获得，仅需要删除红色标识的字符。\n\n现在给你两个字符串 $s_1$ 和 $s_2$ 和两个整数 $n_1$ 和 $n_2$。由此构造得到两个字符串，其中 $str_1 = [s_1, n_1]$、$str_2 = [s_2, n_2]$。\n\n请你找出一个最大整数 $m$，以满足 $str = [str_2, m]$ 可以从 $str_1$ 获得。", "inputFormat": "本题有多组测试数据。测试数据不超过 $100$ 组。\n\n对于每组测试数据，分为两行：\n- 第一行输入字符串 $s_2$ 和整数 $n_2$；\n- 第二行输入字符串 $s_1$ 和整数 $n_1$；", "outputFormat": "对于每组测试数据，输出整数 $m$ 表示答案。", "hint": "数据保证，$s_1,s_2$ 全为小写字母构成，且 $1\\leq |s_1|,|s_2| \\leq 100$，$0\\leq n_1,n_2\\leq 10^6$，每个测试点的测试数据不超过 $100$ 组。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "统计重复个数", "background": "", "description": "定义 $str = [s, n]$ 表示 $str$ 由 $n$ 个字符串 $s$ 连接构成。\n\n例如，$str == [\\texttt{abc}, 3] == \\texttt{abcabcabc}$。\n如果可以从 $s_2$ 中删除某些字符使其变为 $s_1$，则称字符串 $s_1$ 可以从字符串 $s_2$ 获得。\n\n例如，根据定义，$s1 = \\tt{abc}$ 可以从 $s2 = \\tt{ab\\red{dbe}c}$ 获得，仅需要删除红色标识的字符。\n\n现在给你两个字符串 $s_1$ 和 $s_2$ 和两个整数 $n_1$ 和 $n_2$。由此构造得到两个字符串，其中 $str_1 = [s_1, n_1]$、$str_2 = [s_2, n_2]$。\n\n请你找出一个最大整数 $m$，以满足 $str = [str_2, m]$ 可以从 $str_1$ 获得。", "inputFormat": "本题有多组测试数据。测试数据不超过 $100$ 组。\n\n对于每组测试数据，分为两行：\n- 第一行输入字符串 $s_2$ 和整数 $n_2$；\n- 第二行输入字符串 $s_1$ 和整数 $n_1$；", "outputFormat": "对于每组测试数据，输出整数 $m$ 表示答案。", "hint": "数据保证，$s_1,s_2$ 全为小写字母构成，且 $1\\leq |s_1|,|s_2| \\leq 100$，$0\\leq n_1,n_2\\leq 10^6$，每个测试点的测试数据不超过 $100$ 组。", "locale": "zh-CN"}}}
{"pid": "P10977", "type": "P", "difficulty": 5, "samples": [["8 17\n2 2 2 8 1 8 2 1", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "线段树", "单调队列", "动态规划优化", "线性 DP", "STL"], "title": "Cut the Sequence", "background": null, "description": "给定一个长度为 $N$ 的整数序列 $\\{a_N\\}$，你需要将这个序列划分成若干部分，满足每一部分都是原序列的一个连续子序列，且每个部分的整数之和均不超过 $M$。你的任务是求出在所有合法的划分方式中，每一部分的最大值之和的最小值。", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$（$1 \\le N \\le 10^5$，$1\\le M < 2^{31}$）。第二行包含 $N$ 个整数，依次为 $a_1,a_2,\\dots,a_N$（$0\\le a_i\\le 10^6$）。", "outputFormat": "输出一个整数，表示每一部分的最大值之和的最小值。如果不存在合法的划分方式，输出 $-1$。", "hint": "样例解释：\n\n将序列划分为三个部分：$\\{2,2,2\\},\\{8,1,8\\},\\{2,1\\}$，此时每一部分的最大值之和为 $2+8+2=12$。可以证明，不存在更优的方案。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Cut the Sequence", "background": null, "description": "给定一个长度为 $N$ 的整数序列 $\\{a_N\\}$，你需要将这个序列划分成若干部分，满足每一部分都是原序列的一个连续子序列，且每个部分的整数之和均不超过 $M$。你的任务是求出在所有合法的划分方式中，每一部分的最大值之和的最小值。", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$（$1 \\le N \\le 10^5$，$1\\le M < 2^{31}$）。第二行包含 $N$ 个整数，依次为 $a_1,a_2,\\dots,a_N$（$0\\le a_i\\le 10^6$）。", "outputFormat": "输出一个整数，表示每一部分的最大值之和的最小值。如果不存在合法的划分方式，输出 $-1$。", "hint": "样例解释：\n\n将序列划分为三个部分：$\\{2,2,2\\},\\{8,1,8\\},\\{2,1\\}$，此时每一部分的最大值之和为 $2+8+2=12$。可以证明，不存在更优的方案。", "locale": "zh-CN"}}}
{"pid": "P10978", "type": "P", "difficulty": 5, "samples": [["8 4\n3 2 2\n3 2 3\n3 3 5\n1 1 7 ", "17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "单调队列", "动态规划优化"], "title": "Fence", "background": null, "description": "一组由 $k$（$1 \\leq k \\leq 100$） 名工人组成的团队需要粉刷一堵包含 $N$ 个木板的围栏，这些木板从左到右编号为 $1$ 到 $N$（$1 \\leq N \\leq 16,000$）。每个工人 $i$（$1 \\leq i \\leq k$）应该坐在木板 $S_i$ 前，他只能粉刷一个连续的区间（这意味着区间内的木板应该是连续的）。这个区间必须包含木板 $S_i$（**特别地，这个区间也可以为空，即一个工人可以不工作**）。此外，每个工人粉刷的木板数量不能超过 $L_i$ 个，并且每粉刷一个木板他会得到 $P_i$ 美元（$1 \\leq P_i \\leq 10,000$）。每个木板最多只能由一个工人粉刷。所有的 $S_i$ 都是不同的。\n\n作为团队的领导者，你需要为每个工人确定他们应该粉刷的区间，并且确保总收入最大化。总收入代表工人个人收入的总和。\n\n编写一个程序来确定 $k$ 名工人获得的总最大收入。\n\n**注意：你不必粉刷整个木板。**", "inputFormat": "输入的第一行是是两个正整数 $N,k$。\n\n接下来 $k$ 行，每行三个正整数 $L_i,P_i,S_i$。", "outputFormat": "输出一个整数，表示总最大收入。", "hint": null, "locale": "zh-CN", "translations": {"zh-CN": {"title": "Fence", "background": null, "description": "一组由 $k$（$1 \\leq k \\leq 100$） 名工人组成的团队需要粉刷一堵包含 $N$ 个木板的围栏，这些木板从左到右编号为 $1$ 到 $N$（$1 \\leq N \\leq 16,000$）。每个工人 $i$（$1 \\leq i \\leq k$）应该坐在木板 $S_i$ 前，他只能粉刷一个连续的区间（这意味着区间内的木板应该是连续的）。这个区间必须包含木板 $S_i$（**特别地，这个区间也可以为空，即一个工人可以不工作**）。此外，每个工人粉刷的木板数量不能超过 $L_i$ 个，并且每粉刷一个木板他会得到 $P_i$ 美元（$1 \\leq P_i \\leq 10,000$）。每个木板最多只能由一个工人粉刷。所有的 $S_i$ 都是不同的。\n\n作为团队的领导者，你需要为每个工人确定他们应该粉刷的区间，并且确保总收入最大化。总收入代表工人个人收入的总和。\n\n编写一个程序来确定 $k$ 名工人获得的总最大收入。\n\n**注意：你不必粉刷整个木板。**", "inputFormat": "输入的第一行是是两个正整数 $N,k$。\n\n接下来 $k$ 行，每行三个正整数 $L_i,P_i,S_i$。", "outputFormat": "输出一个整数，表示总最大收入。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P10979", "type": "P", "difficulty": 6, "samples": [["5\n1\n1 3\n3 2\n4 3\n2 3\n1 4", "153"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "斜率优化"], "title": "任务安排 2", "background": "本题是 P2365 强化版，是 P5785 弱化版，用于让学生循序渐进地了解斜率优化 DP。", "description": "机器上有 $n$ 个需要处理的任务，它们构成了一个序列。这些任务被标号为 $1$ 到 $n$，因此序列的排列为 $1 , 2 , 3 \\cdots n$。这 $n$ 个任务被分成若干批，每批包含相邻的若干任务。从时刻 $0$ 开始，这些任务被分批加工，第 $i$ 个任务单独完成所需的时间是 $T_i$。在每批任务开始前，机器需要启动时间 $s$，而完成这批任务所需的时间是各个任务需要时间的总和。\n\n**注意，同一批任务将在同一时刻完成**。每个任务的费用是它的完成时刻乘以一个费用系数 $C_i$。\n\n请确定一个分组方案，使得总费用最小。", "inputFormat": "第一行一个整数 $n$。第二行一个整数 $s$。\n\n接下来 $n$ 行，每行有一对整数，分别为 $T_i$ 和 $C_i$，表示第 $i$ 个任务单独完成所需的时间是 $T_i$ 及其费用系数 $C_i$。", "outputFormat": "一行，一个整数，表示最小的总费用。", "hint": "对于 $100\\%$ 数据，$1 \\le n \\le 3 \\times 10^5$，$1 \\le s \\le 2^8$，$1\\le T_i \\le 2^8$，$0 \\le C_i \\le 2^8$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "任务安排 2", "background": "本题是 P2365 强化版，是 P5785 弱化版，用于让学生循序渐进地了解斜率优化 DP。", "description": "机器上有 $n$ 个需要处理的任务，它们构成了一个序列。这些任务被标号为 $1$ 到 $n$，因此序列的排列为 $1 , 2 , 3 \\cdots n$。这 $n$ 个任务被分成若干批，每批包含相邻的若干任务。从时刻 $0$ 开始，这些任务被分批加工，第 $i$ 个任务单独完成所需的时间是 $T_i$。在每批任务开始前，机器需要启动时间 $s$，而完成这批任务所需的时间是各个任务需要时间的总和。\n\n**注意，同一批任务将在同一时刻完成**。每个任务的费用是它的完成时刻乘以一个费用系数 $C_i$。\n\n请确定一个分组方案，使得总费用最小。", "inputFormat": "第一行一个整数 $n$。第二行一个整数 $s$。\n\n接下来 $n$ 行，每行有一对整数，分别为 $T_i$ 和 $C_i$，表示第 $i$ 个任务单独完成所需的时间是 $T_i$ 及其费用系数 $C_i$。", "outputFormat": "一行，一个整数，表示最小的总费用。", "hint": "对于 $100\\%$ 数据，$1 \\le n \\le 3 \\times 10^5$，$1 \\le s \\le 2^8$，$1\\le T_i \\le 2^8$，$0 \\le C_i \\le 2^8$。", "locale": "zh-CN"}}}
