{"pid": "P5812", "type": "P", "difficulty": 7, "samples": [["7 7\n0 8\n3 7\n5 9\n7 7\n10 6\n12 6\n14 9\n0 1 1\n0 2 6\n0 6 8\n2 3 1\n2 6 7\n3 4 2\n4 6 5\n1 5", "27\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2019", "IOI", "Special Judge"], "title": "[IOI 2019] 天桥", "background": "### 滥用本题评测将封号\n\n注：本题按照传统题方式进行评测，即，你的程序**需要包含 `main` 函数**。", "description": "Kenan 为沿着巴库大街某一侧的建筑和天桥绘制了一张规划图。规划图中有 $n$ 栋建筑，从 $0$ 到 $n-1$ 编号。还有 $m$ 座天桥，从 $0$ 到 $m-1$ 编号。这张规划图绘制在一张二维平面上，其中建筑和天桥分别是垂直和水平的线段。\n\n第 $i$（$0 \\le i \\le n-1$） 栋建筑的底部坐落在坐标 （$x[i],0$） 上，建筑的高度为 $h[i]$。因此，它对应一条连接点 （$x[i],0$） 和 （$x[i],h[i]$） 的线段。\n\n第 $j$（$0 \\le j \\le m-1$） 座天桥的两端分别在第 $l[j]$ 栋建筑和第 $r[j]$ 栋建筑上，并具有正的 $y$ 坐标 $y[j]$。因此，它对应一条连接点 （$x[l[j]],y[j]$） 和 （$x[r[j]],y[j]$） 的线段。\n\n称某座天桥和某栋建筑相交，如果它们有某个公共的点。因此，一座天桥在它的两个端点处与两栋建筑相交，同时还可能在中间和其他建筑相交。\n\nKenan 想要找出从第 $s$ 栋建筑的底部到第 $g$ 栋建筑的底部的最短路径长度，或者确认这样的路径不存在。在这里行人只能沿着建筑和天桥行走，并且不允许在地面上行走，也就是说不允许沿着 $y$ 坐标为 $0$ 的水平线行走。\n\n行人能够在任意交点从某座天桥走进某栋建筑，或者从某栋建筑走上某座天桥。如果两座天桥的端点之一在同一点上，行人也可以从其中一座天桥走上另一座天桥。\n\n你的任务是帮助 Kenan 回答他的问题。\n\n**实现细节**\n\n你需要实现下列函数。\n`int64 min_distance(int[] x,int[] h,int[] l,int[] r,int[] y,int s,int g)`\n\n- $x$ 和 $h$：长度为 $n$ 的整数数组。\n- $l$、$r$ 和 $y$：长度为 $m$ 的整数数组。\n- $s$ 和 $g$：两个整数。\n- 如果从第 $s$ 栋建筑的底部到第 $g$ 栋建筑的底部的最短路径存在，则该函数应该返回最短路径的长度。否则，该函数应该返回`-1`。", "inputFormat": "- 第 $1$ 行：$n$，$m$。\n- 第 $2+i$ 行（$0 \\le i \\le n-1$）：$x[i]$，$h[i]$。\n- 第 $n+2+j$ 行（$0 \\le j \\le m-1$）：$l[j]$，$r[j]$，$y[j]$。\n- 第 $n+m+2$ 行：$s$，$g$。", "outputFormat": "共一行，为函数 `min_distance` 的返回值。", "hint": "**样例说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t0lihb5c.png)\n\n**限制条件**\n\n- $1 \\le n,m \\le 10^5$。\n- $0 \\le x[0] < x[1] < \\cdots < x[n-1] \\le 10^9$。\n- $1 \\le h[i] \\le 10^9$（对于所有 $0 \\le i \\le n-1$）。\n- $0 \\le l[j] \\le r[j] \\le n-1$（对于所有 $0 \\le j \\le m-1$）。\n- $1 \\le y[j] \\le \\min(h[l[j]],h[r[j]])$（对于所有 $0 \\le j \\le m-1$）。\n- $0 \\le s,g \\le n-1$。\n- $s ≠ g$。\n- 除在端点处外，任意两座天桥不会有其他公共的点。\n\n**子任务**\n\n1. （$10$ 分）$n,m \\le 50$。\n2. （$14$ 分）每座天桥最多与 $10$ 栋建筑相交。\n3. （$15$ 分）$s=0$，$g=n-1$，且所有建筑的高度相等。\n4. （$18$ 分）$s=0$，$g=n-1$。\n5. （$43$ 分）没有任何附加限制。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2019] Skybridges", "background": "### Abuse of this problem’s judging system will result in account suspension.\n\nNote: This problem is judged in the traditional way, i.e., your program **must contain a `main` function**.", "description": "Kenan has drawn a plan of the buildings and skybridges along one side of Baku Avenue. The plan contains $n$ buildings, numbered from $0$ to $n-1$. It also contains $m$ skybridges, numbered from $0$ to $m-1$. The plan is drawn on a two-dimensional plane, where buildings and skybridges are vertical and horizontal line segments, respectively.\n\nThe bottom of building $i$ ($0 \\le i \\le n-1$) is located at coordinate $(x[i],0)$, and its height is $h[i]$. Therefore, it corresponds to the line segment connecting $(x[i],0)$ and $(x[i],h[i])$.\n\nSkybridge $j$ ($0 \\le j \\le m-1$) has its two endpoints on building $l[j]$ and building $r[j]$, and has a positive $y$-coordinate $y[j]$. Therefore, it corresponds to the line segment connecting $(x[l[j]],y[j])$ and $(x[r[j]],y[j])$.\n\nA skybridge and a building are said to intersect if they share at least one common point. Thus, a skybridge intersects the two buildings at its endpoints, and it may also intersect other buildings in between.\n\nKenan wants to find the length of the shortest path from the bottom of building $s$ to the bottom of building $g$, or determine that no such path exists. Pedestrians can only walk along buildings and skybridges, and are not allowed to walk on the ground, meaning they are not allowed to walk along the horizontal line with $y$-coordinate $0$.\n\nAt any intersection point, a pedestrian can move from a skybridge onto a building, or from a building onto a skybridge. If an endpoint of one skybridge is at the same point as an endpoint of another skybridge, the pedestrian can also move from one skybridge to the other.\n\nYour task is to help Kenan answer his question.\n\n**Implementation Details**\n\nYou need to implement the following function.  \n`int64 min_distance(int[] x,int[] h,int[] l,int[] r,int[] y,int s,int g)`\n\n- $x$ and $h$: integer arrays of length $n$.\n- $l$, $r$, and $y$: integer arrays of length $m$.\n- $s$ and $g$: two integers.\n- If the shortest path from the bottom of building $s$ to the bottom of building $g$ exists, the function should return the length of the shortest path. Otherwise, it should return `-1`.", "inputFormat": "- Line $1$: $n$, $m$.\n- Line $2+i$ ($0 \\le i \\le n-1$): $x[i]$, $h[i]$.\n- Line $n+2+j$ ($0 \\le j \\le m-1$): $l[j]$, $r[j]$, $y[j]$.\n- Line $n+m+2$: $s$, $g$.", "outputFormat": "A single line containing the return value of the function `min_distance`.", "hint": "**Sample Explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t0lihb5c.png)\n\n**Constraints**\n\n- $1 \\le n,m \\le 10^5$.\n- $0 \\le x[0] < x[1] < \\cdots < x[n-1] \\le 10^9$.\n- $1 \\le h[i] \\le 10^9$ (for all $0 \\le i \\le n-1$).\n- $0 \\le l[j] \\le r[j] \\le n-1$ (for all $0 \\le j \\le m-1$).\n- $1 \\le y[j] \\le \\min(h[l[j]],h[r[j]])$ (for all $0 \\le j \\le m-1$).\n- $0 \\le s,g \\le n-1$.\n- $s \\ne g$.\n- Except at endpoints, any two skybridges do not have any other common points.\n\n**Subtasks**\n\n1. ($10$ points) $n,m \\le 50$.\n2. ($14$ points) Each skybridge intersects at most $10$ buildings.\n3. ($15$ points) $s=0$, $g=n-1$, and all buildings have equal height.\n4. ($18$ points) $s=0$, $g=n-1$.\n5. ($43$ points) No additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2019] 天桥", "background": "### 滥用本题评测将封号\n\n注：本题按照传统题方式进行评测，即，你的程序**需要包含 `main` 函数**。", "description": "Kenan 为沿着巴库大街某一侧的建筑和天桥绘制了一张规划图。规划图中有 $n$ 栋建筑，从 $0$ 到 $n-1$ 编号。还有 $m$ 座天桥，从 $0$ 到 $m-1$ 编号。这张规划图绘制在一张二维平面上，其中建筑和天桥分别是垂直和水平的线段。\n\n第 $i$（$0 \\le i \\le n-1$） 栋建筑的底部坐落在坐标 （$x[i],0$） 上，建筑的高度为 $h[i]$。因此，它对应一条连接点 （$x[i],0$） 和 （$x[i],h[i]$） 的线段。\n\n第 $j$（$0 \\le j \\le m-1$） 座天桥的两端分别在第 $l[j]$ 栋建筑和第 $r[j]$ 栋建筑上，并具有正的 $y$ 坐标 $y[j]$。因此，它对应一条连接点 （$x[l[j]],y[j]$） 和 （$x[r[j]],y[j]$） 的线段。\n\n称某座天桥和某栋建筑相交，如果它们有某个公共的点。因此，一座天桥在它的两个端点处与两栋建筑相交，同时还可能在中间和其他建筑相交。\n\nKenan 想要找出从第 $s$ 栋建筑的底部到第 $g$ 栋建筑的底部的最短路径长度，或者确认这样的路径不存在。在这里行人只能沿着建筑和天桥行走，并且不允许在地面上行走，也就是说不允许沿着 $y$ 坐标为 $0$ 的水平线行走。\n\n行人能够在任意交点从某座天桥走进某栋建筑，或者从某栋建筑走上某座天桥。如果两座天桥的端点之一在同一点上，行人也可以从其中一座天桥走上另一座天桥。\n\n你的任务是帮助 Kenan 回答他的问题。\n\n**实现细节**\n\n你需要实现下列函数。\n`int64 min_distance(int[] x,int[] h,int[] l,int[] r,int[] y,int s,int g)`\n\n- $x$ 和 $h$：长度为 $n$ 的整数数组。\n- $l$、$r$ 和 $y$：长度为 $m$ 的整数数组。\n- $s$ 和 $g$：两个整数。\n- 如果从第 $s$ 栋建筑的底部到第 $g$ 栋建筑的底部的最短路径存在，则该函数应该返回最短路径的长度。否则，该函数应该返回`-1`。", "inputFormat": "- 第 $1$ 行：$n$，$m$。\n- 第 $2+i$ 行（$0 \\le i \\le n-1$）：$x[i]$，$h[i]$。\n- 第 $n+2+j$ 行（$0 \\le j \\le m-1$）：$l[j]$，$r[j]$，$y[j]$。\n- 第 $n+m+2$ 行：$s$，$g$。", "outputFormat": "共一行，为函数 `min_distance` 的返回值。", "hint": "**样例说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t0lihb5c.png)\n\n**限制条件**\n\n- $1 \\le n,m \\le 10^5$。\n- $0 \\le x[0] < x[1] < \\cdots < x[n-1] \\le 10^9$。\n- $1 \\le h[i] \\le 10^9$（对于所有 $0 \\le i \\le n-1$）。\n- $0 \\le l[j] \\le r[j] \\le n-1$（对于所有 $0 \\le j \\le m-1$）。\n- $1 \\le y[j] \\le \\min(h[l[j]],h[r[j]])$（对于所有 $0 \\le j \\le m-1$）。\n- $0 \\le s,g \\le n-1$。\n- $s ≠ g$。\n- 除在端点处外，任意两座天桥不会有其他公共的点。\n\n**子任务**\n\n1. （$10$ 分）$n,m \\le 50$。\n2. （$14$ 分）每座天桥最多与 $10$ 栋建筑相交。\n3. （$15$ 分）$s=0$，$g=n-1$，且所有建筑的高度相等。\n4. （$18$ 分）$s=0$，$g=n-1$。\n5. （$43$ 分）没有任何附加限制。", "locale": "zh-CN"}}}
{"pid": "P5813", "type": "P", "difficulty": 4, "samples": [["5 5\n3\n15 10 6 4\n70 100 7 2\n30 70 1 6\n", "93\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2001", "背包 DP", "WC"], "title": "[WC2001] 高性能计算机", "background": "", "description": "现在有一项时间紧迫的工程计算任务要交给你——国家高性能并行计算机的主管工程师——来完成。为了尽可能充分发挥并行计算机的优势，我们的计算任务应当划分成若干个小的子任务。\n\n这项大型计算任务包括 $A$ 和 $B$ 两个互不相关的较小的计算任务。为了充分发挥并行计算机的运算能力，这些任务需要进行分解。研究发现，$A$ 和 $B$ 都可以各自划分成很多较小的子任务，所有的 $A$ 类子任务的工作量都是一样的，所有的 $B$ 类子任务也是如此（$A$ 和 $B$ 类的子任务的工作量不一定相同）。$A$ 和 $B$ 两个计算任务之间，以及各子任务之间都没有执行顺序上的要求。\n\n这台超级计算机拥有 $p$ 个计算节点，每个节点都包括一个串行处理器、本地主存和高速 cache。然而由于常年使用和不连贯的升级，各个计算节点的计算能力并不对称。一个节点的计算能力包括如下几个方面：\n\n1. 就本任务来说，每个节点都有三种工作状态：待机、$A$ 类和 $B$ 类。其中，$A$ 类状态下执行 $A$ 类任务；$B$ 类状态下执行 $B$ 类任务；待机状态下不执行计算。所有的处理器在开始工作之前都处于待机状态，而从其它的状态转入 $A$ 或 $B$ 的工作状态（包括 $A$ 和 $B$ 之间相互转换），都要花费一定的启动时间。对于不同的处理节点，这个时间不一定相同。用两个正整数 $t_{i}^{A}$ ​和 $t_{i}^{B}$ ($i = 1,2,\\cdots,p$)分别表示节点 $i$ 转入工作状态 $A$ 和工作状态 $B$ 的启动时间（单位：ns）。\n\n2. 一个节点在连续处理同一类任务的时候，执行时间——不含状态转换的时间——随任务量（这一类子任务的数目）的平方增长，即：\n\n若节点 $i$ 连续处理 $x$ 个 $A$ 类子任务，则对应的执行时间为：$t = k_{i}^{A} x^2$；\n\n类似的，若节点 $i$ 连续处理 $x$ 个 $B$ 类子任务，对应的执行时间为：$t = k_{i}^{B} x^2$。\n\n其中，$k_{i}^{A}$ ​和 $k_{i}^{B} $ ​是系数，单位是 ns，$i=1,2,\\cdots,p$。\n\n任务分配必须在所有计算开始之前完成，所谓任务分配，即给每个计算节点设置一个任务队列，队列由一串 $A$ 类和 $B$ 类子任务组成。两类子任务可以交错排列。\n\n计算开始后，各计算节点分别从各自的子任务队列中顺序读取计算任务并执行，队列中连续的同类子任务将由该计算节点一次性读出，队列中一串连续的同类子任务不能被分成两部分执行。\n\n现在需要你编写程序，给这 $p$ 个节点安排计算任务，使得这个工程计算任务能够尽早完成。假定任务安排好后不再变动，而且所有的节点都同时开始运行，任务安排的目标是使最后结束计算的节点的完成时间尽可能早。", "inputFormat": "第一行是对计算任务的描述，包括两个正整数 $n_A$ 和 $n_B$，分别是 $A$ 类和 $B$ 类子任务的数目，两个整数之间由一个空格隔开。\n\n后面部分是对此计算机的描述：\n\n第二行是一个整数 $p$，即计算节点的数目。\n\n随后连续的 $p$ 行按顺序分别描述各个节点的信息，第 $i$ 个节点由第 $i+2$ 行描述，该行包括下述四个正整数（相邻两个整数之间有一个空格）：$t_{i}^{A},t_{i}^{B},k_{i}^{A},k_{i}^{B}$。", "outputFormat": "只有一行，包含有一个正整数，即从各节点开始计算到任务完成所用的时间。\n\n", "hint": "对于所有数据： $1 \\le n_A \\le 60$，$1 \\le n_B \\le 60$，$1 \\le p \\le 20$，$1 \\le t_{i}^{A} \\le 1000$，$1 \\le t_{i}^{B} \\le 1000$，$1 \\le k_{i}^{A} \\le 50$，$1 \\le k_{i}^{B} \\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[WC2001] High-Performance Computer", "background": "", "description": "You now have a time-critical engineering computation task to complete, as the chief engineer of a national high-performance parallel computer. To make full use of the advantages of parallel computing, the computation task should be split into several smaller subtasks.\n\nThis large computation task consists of two independent smaller computation tasks, $A$ and $B$. To fully use the computing power of the parallel computer, these tasks need to be decomposed. It is found that both $A$ and $B$ can each be divided into many smaller subtasks. The workload of all type $A$ subtasks is the same, and the workload of all type $B$ subtasks is also the same (the workloads of type $A$ and type $B$ subtasks are not necessarily the same). There is no required execution order between tasks $A$ and $B$, nor among the subtasks.\n\nThis supercomputer has $p$ computing nodes. Each node includes a serial processor, local main memory, and high-speed cache. However, due to long-term use and inconsistent upgrades, the computing abilities of the nodes are not symmetric. A node’s computing ability includes the following aspects:\n\n1. For this task, each node has three working states: standby, type $A$, and type $B$. In type $A$ state it executes type $A$ tasks; in type $B$ state it executes type $B$ tasks; in standby state it does not compute. All processors are in standby before starting work. Switching from any other state into working state $A$ or $B$ (including switching between $A$ and $B$) requires a certain startup time. This time may differ across nodes. Use two positive integers $t_{i}^{A}$ and $t_{i}^{B}$ ($i = 1,2,\\cdots,p$) to represent the startup time (in ns) for node $i$ to enter working state $A$ and working state $B$, respectively.\n\n2. When a node continuously processes tasks of the same type, the execution time (excluding state switching time) grows with the square of the task amount (the number of subtasks of that type), i.e.:\n\nIf node $i$ continuously processes $x$ type $A$ subtasks, the corresponding execution time is $t = k_{i}^{A} x^2$.\n\nSimilarly, if node $i$ continuously processes $x$ type $B$ subtasks, the corresponding execution time is $t = k_{i}^{B} x^2$.\n\nHere, $k_{i}^{A}$ and $k_{i}^{B}$ are coefficients in ns, for $i = 1,2,\\cdots,p$.\n\nTask assignment must be completed before any computation starts. “Task assignment” means setting a task queue for each computing node. The queue consists of a sequence of type $A$ and type $B$ subtasks. The two types of subtasks can be interleaved.\n\nAfter computation starts, each node reads computation tasks from its own task queue in order and executes them. A consecutive block of same-type subtasks in the queue will be read and executed by that node in one batch, and such a consecutive block cannot be split into two parts for execution.\n\nYou need to write a program to schedule the computation tasks for these $p$ nodes so that the engineering computation task can be completed as early as possible. Assume the schedule will not change after being set, and all nodes start running at the same time. The goal is to make the completion time of the last finishing node as early as possible.", "inputFormat": "The first line describes the computation tasks, containing two positive integers $n_A$ and $n_B$, which are the numbers of type $A$ and type $B$ subtasks, respectively. The two integers are separated by one space.\n\nThe following part describes the computer:\n\nThe second line contains an integer $p$, the number of computing nodes.\n\nThen follow $p$ lines describing the nodes in order. Node $i$ is described on line $i+2$, which contains four positive integers (separated by one space): $t_{i}^{A},t_{i}^{B},k_{i}^{A},k_{i}^{B}$.", "outputFormat": "Only one line containing one positive integer: the time from when all nodes start computing until the task is completed.", "hint": "For all testdata: $1 \\le n_A \\le 60$, $1 \\le n_B \\le 60$, $1 \\le p \\le 20$, $1 \\le t_{i}^{A} \\le 1000$, $1 \\le t_{i}^{B} \\le 1000$, $1 \\le k_{i}^{A} \\le 50$, $1 \\le k_{i}^{B} \\le 50$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2001] 高性能计算机", "background": "", "description": "现在有一项时间紧迫的工程计算任务要交给你——国家高性能并行计算机的主管工程师——来完成。为了尽可能充分发挥并行计算机的优势，我们的计算任务应当划分成若干个小的子任务。\n\n这项大型计算任务包括 $A$ 和 $B$ 两个互不相关的较小的计算任务。为了充分发挥并行计算机的运算能力，这些任务需要进行分解。研究发现，$A$ 和 $B$ 都可以各自划分成很多较小的子任务，所有的 $A$ 类子任务的工作量都是一样的，所有的 $B$ 类子任务也是如此（$A$ 和 $B$ 类的子任务的工作量不一定相同）。$A$ 和 $B$ 两个计算任务之间，以及各子任务之间都没有执行顺序上的要求。\n\n这台超级计算机拥有 $p$ 个计算节点，每个节点都包括一个串行处理器、本地主存和高速 cache。然而由于常年使用和不连贯的升级，各个计算节点的计算能力并不对称。一个节点的计算能力包括如下几个方面：\n\n1. 就本任务来说，每个节点都有三种工作状态：待机、$A$ 类和 $B$ 类。其中，$A$ 类状态下执行 $A$ 类任务；$B$ 类状态下执行 $B$ 类任务；待机状态下不执行计算。所有的处理器在开始工作之前都处于待机状态，而从其它的状态转入 $A$ 或 $B$ 的工作状态（包括 $A$ 和 $B$ 之间相互转换），都要花费一定的启动时间。对于不同的处理节点，这个时间不一定相同。用两个正整数 $t_{i}^{A}$ ​和 $t_{i}^{B}$ ($i = 1,2,\\cdots,p$)分别表示节点 $i$ 转入工作状态 $A$ 和工作状态 $B$ 的启动时间（单位：ns）。\n\n2. 一个节点在连续处理同一类任务的时候，执行时间——不含状态转换的时间——随任务量（这一类子任务的数目）的平方增长，即：\n\n若节点 $i$ 连续处理 $x$ 个 $A$ 类子任务，则对应的执行时间为：$t = k_{i}^{A} x^2$；\n\n类似的，若节点 $i$ 连续处理 $x$ 个 $B$ 类子任务，对应的执行时间为：$t = k_{i}^{B} x^2$。\n\n其中，$k_{i}^{A}$ ​和 $k_{i}^{B} $ ​是系数，单位是 ns，$i=1,2,\\cdots,p$。\n\n任务分配必须在所有计算开始之前完成，所谓任务分配，即给每个计算节点设置一个任务队列，队列由一串 $A$ 类和 $B$ 类子任务组成。两类子任务可以交错排列。\n\n计算开始后，各计算节点分别从各自的子任务队列中顺序读取计算任务并执行，队列中连续的同类子任务将由该计算节点一次性读出，队列中一串连续的同类子任务不能被分成两部分执行。\n\n现在需要你编写程序，给这 $p$ 个节点安排计算任务，使得这个工程计算任务能够尽早完成。假定任务安排好后不再变动，而且所有的节点都同时开始运行，任务安排的目标是使最后结束计算的节点的完成时间尽可能早。", "inputFormat": "第一行是对计算任务的描述，包括两个正整数 $n_A$ 和 $n_B$，分别是 $A$ 类和 $B$ 类子任务的数目，两个整数之间由一个空格隔开。\n\n后面部分是对此计算机的描述：\n\n第二行是一个整数 $p$，即计算节点的数目。\n\n随后连续的 $p$ 行按顺序分别描述各个节点的信息，第 $i$ 个节点由第 $i+2$ 行描述，该行包括下述四个正整数（相邻两个整数之间有一个空格）：$t_{i}^{A},t_{i}^{B},k_{i}^{A},k_{i}^{B}$。", "outputFormat": "只有一行，包含有一个正整数，即从各节点开始计算到任务完成所用的时间。\n\n", "hint": "对于所有数据： $1 \\le n_A \\le 60$，$1 \\le n_B \\le 60$，$1 \\le p \\le 20$，$1 \\le t_{i}^{A} \\le 1000$，$1 \\le t_{i}^{B} \\le 1000$，$1 \\le k_{i}^{A} \\le 50$，$1 \\le k_{i}^{B} \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P5814", "type": "P", "difficulty": 6, "samples": [["6 13\n0.9 0.7 0.8 0 0 0 2 6 8 0 0 0\n0 0 0 1 0 1\n1 4 0.5 2\n2 3 0.9 5\n2 5 0.8 2\n2 6 0.8 7\n3 5 0.8 2\n5 6 0.8 4\n-1 -1\n", "0.00021184\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2001", "网络流", "费用流", "CTSC/CTS"], "title": "[CTSC2001] 终极情报网", "background": "", "description": "在最后的诺曼底登陆战开始之前，盟军与德军的情报部门围绕着最终的登陆地点展开了一场规模空前的情报战。 这场情报战中，盟军的战术是利用那些潜伏在敌军内部的双重间谍，将假的登陆消息发布给敌军的情报机关的负责人。那些已经潜入敌后的间谍们都是盟军情报部的精英，忠实可靠；但是如何选择合适的人选，以及最佳的消息传递方法，才能保证假消息能够尽快而且安全准确地传递到德军指挥官们的耳朵里，成了困扰盟军情报部长的最大问题。他需要你的帮助。\n\n以下是情报部长提供的作战资料：\n\n在敌后一共潜伏着我方最优秀的 $N$ 名间谍，分别用数字 $1,2,\\cdots,N$ 编号。在给定的作战时间内，任意两人之间至多只进行一次点对点的双人联系。 我将给你一份表格，表格中将提供任意两位间谍 $i$ 和 $j$ 之间进行联系的安全程度，用一个 $[0,1]$ 的实数 $S_{i,j}$ 表示；以及他们这次联系时，能够互相传递的消息的最大数目，用一个正整数表示 $M_{i,j}$（如果在表格中没有被提及，那么间谍 $i$ 和 $j$ 之间不进行直接联系）。 假消息从盟军总部传递到每个间谍手里的渠道也不是绝对安全，我们用 $[0,1]$ 的实数 $AS_j$ 表示总部与间谍 $j$ 之间进行联系的安全程度，$AM_j $  则表示总部和间谍 $j$ 之间进行联系时传递的消息的最大数目。对于不和总部直接联系的间谍，他的  $AM_j = 0$（而表格中给出的他的 $AS_j$ 是没有意义的）。 当然，假消息从间谍手中交到敌军的情报部官员的办公桌上的过程是绝对安全的，也即是说，间谍与敌军情报部门之间要么不进行直接联系，要么其联系的安全程度是 $1$（即完全可靠）。\n\n现在情报部打算把 $K$ 条假消息“透露”到德军那里。消息先由总部一次性发给 $N$ 名间谍中的一些人，再通过他们之间的情报网传播，最终由这 $N$ 名间谍中的某些将情报送到德军手中。 对于一条消息，只有安全的通过了所有的中转过程到达敌军情报部，这个传递消息的过程才算是安全的；因此根据乘法原理，它的安全程度 $P$ 就是从总部出发，经多次传递直到到达德军那里，每一次传递该消息的安全程度的乘积。 而对于整个计划而言，只有当 $N$ 条消息都安全的通过情报网到达德军手中，没有一条引起怀疑时，才算是成功的。所以计划的可靠程度是所有消息的安全程度的乘积。 显然，计划的可靠性取决于这些消息在情报网中的传递方法。 我需要一个方案，确定消息应该从哪些人手中传递到哪些人手中，使得最终计划的可靠性最大。\n\n你可以利用计算机，来求得这个最可靠的消息传递方案。", "inputFormat": "输入包含了盟军的作战资料表格。\n\n第一行包括两个整数 $N$ 和 $K$ ，分别是间谍的总人数和计划包含的消息总数。\n\n第二行包括 $2N$ 个数，前 $N$ 个数是实数 $AS_1,AS_2,\\cdots,AS_N$ （范围在 $[0,1]$ 以内）；后 $N$ 个数是整数 $AM_1,AM_2,\\cdots,AM_N$ 。\n\n第三行包含了 $N$ 个整数，其中第 $i$（$i = 1,2,\\cdots,N$）个整数如果为 $0$ 表示间谍 $i$ 与德军情报部不进行联系，如果为 $1$ 则表示间谍 $i$ 与德军情报部进行联系。\n\n第四行开始，每行包括 $4$ 个数，依次分别是：代表间谍编号的正整数 $i$ 和 $j$ ，间谍 $i$ 和 $j$ 联系的安全性参数 $S_{i,j}$ ( $[0,1]$ 范围内的实数)，以及 $i,j$ 之间传递的最大消息数 $M_{i,j}$ (每一行的 $i$ 均小于 $j$)。\n\n最后的一行为 `-1 -1` ，表示输入数据的结束。", "outputFormat": "输出只有一行。这一行中包含一个实数 $P$ ，给出的是整个计划的可靠程度 $P$ ，**保留 $5$ 位有效数字**（四舍五入）。\n\n如果情报网根本不能将 $K$ 条消息传到德军手中，那么计划的可靠性为 $0$ 。\n\n(你可以假定，如果计划存在，那么它的可靠性大于 $10^{-12}$)", "hint": "$1 \\le N,K \\le 300$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2001] Ultimate Intelligence Network.", "background": "", "description": "Before the final Normandy landing battle began, the Allied and German intelligence agencies fought an unprecedented intelligence war over the final landing location. In this intelligence war, the Allied tactic was to use double agents hidden inside the enemy to release fake landing information to the heads of the German intelligence agencies. Those agents who had already infiltrated behind enemy lines were all elites of the Allied intelligence department, loyal and reliable. However, how to choose suitable people, and the best way to transmit messages, so that the fake information could be delivered to the German commanders as quickly, safely, and accurately as possible, became the biggest problem troubling the Allied intelligence minister. He needs your help.\n\nThe minister provides the following operational data:\n\nThere are a total of $N$ of our best spies behind enemy lines, numbered $1,2,\\cdots,N$. Within the given operation time, any two people can make at most one point-to-point two-person contact. You will be given a table. The table provides the security level of a contact between any two spies $i$ and $j$, represented by a real number $S_{i,j}$ in $[0,1]$; and the maximum number of messages they can exchange in this contact, represented by a positive integer $M_{i,j}$ (if it is not mentioned in the table, then spies $i$ and $j$ do not contact directly). The channel for sending fake messages from the Allied headquarters to each spy is also not absolutely safe. We use a real number $AS_j$ in $[0,1]$ to represent the security level of contact between the headquarters and spy $j$, and $AM_j$ to represent the maximum number of messages that can be transmitted when the headquarters contacts spy $j$. For spies that do not contact the headquarters directly, $AM_j = 0$ (and the given $AS_j$ is meaningless). Of course, the process of delivering a fake message from a spy to the German intelligence officer’s desk is absolutely safe; that is, a spy either does not contact the German intelligence department directly, or the security level of that contact is $1$ (completely reliable).\n\nNow the intelligence department plans to “leak” $K$ fake messages to the Germans. The messages are first sent by the headquarters in one batch to some of the $N$ spies, then spread through their intelligence network, and finally delivered to the Germans by some of these $N$ spies. For a single message, the transmission is considered safe only if it passes safely through all intermediate steps and reaches the German intelligence department. Therefore, by the multiplication rule, its security level $P$ is the product of the security levels of every transmission of that message, from the headquarters through multiple transfers until it reaches the Germans. For the whole plan, it is successful only when all $K$ messages pass safely through the network and reach the Germans, with none raising suspicion. So the reliability of the plan is the product of the security levels of all messages. Obviously, the reliability depends on how these messages are transmitted in the network. You need a scheme that decides from whom to whom each message should be passed, so that the final reliability is maximized.\n\nYou can use a computer to find the most reliable message transmission plan.", "inputFormat": "The input contains the Allied operational data table.\n\nThe first line contains two integers $N$ and $K$, which are the total number of spies and the total number of messages in the plan.\n\nThe second line contains $2N$ numbers. The first $N$ numbers are real numbers $AS_1,AS_2,\\cdots,AS_N$ (in the range $[0,1]$). The next $N$ numbers are integers $AM_1,AM_2,\\cdots,AM_N$.\n\nThe third line contains $N$ integers. The $i$-th integer ($i = 1,2,\\cdots,N$) is $0$ if spy $i$ does not contact the German intelligence department, and $1$ if spy $i$ does.\n\nStarting from the fourth line, each line contains $4$ numbers in order: the positive integers $i$ and $j$ representing spy IDs, the security parameter $S_{i,j}$ of the contact between spies $i$ and $j$ (a real number in $[0,1]$), and the maximum number of messages $M_{i,j}$ that can be transmitted between $i$ and $j$ (in each line, $i$ is less than $j$).\n\nThe last line is `-1 -1`, which indicates the end of input.", "outputFormat": "Output only one line. This line contains a real number $P$, which is the reliability $P$ of the whole plan, **rounded to $5$ significant digits**.\n\nIf the intelligence network cannot transmit $K$ messages to the Germans at all, then the plan reliability is $0$.\n\n(You may assume that if a plan exists, then its reliability is greater than $10^{-12}$.)", "hint": "$1 \\le N,K \\le 300$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2001] 终极情报网", "background": "", "description": "在最后的诺曼底登陆战开始之前，盟军与德军的情报部门围绕着最终的登陆地点展开了一场规模空前的情报战。 这场情报战中，盟军的战术是利用那些潜伏在敌军内部的双重间谍，将假的登陆消息发布给敌军的情报机关的负责人。那些已经潜入敌后的间谍们都是盟军情报部的精英，忠实可靠；但是如何选择合适的人选，以及最佳的消息传递方法，才能保证假消息能够尽快而且安全准确地传递到德军指挥官们的耳朵里，成了困扰盟军情报部长的最大问题。他需要你的帮助。\n\n以下是情报部长提供的作战资料：\n\n在敌后一共潜伏着我方最优秀的 $N$ 名间谍，分别用数字 $1,2,\\cdots,N$ 编号。在给定的作战时间内，任意两人之间至多只进行一次点对点的双人联系。 我将给你一份表格，表格中将提供任意两位间谍 $i$ 和 $j$ 之间进行联系的安全程度，用一个 $[0,1]$ 的实数 $S_{i,j}$ 表示；以及他们这次联系时，能够互相传递的消息的最大数目，用一个正整数表示 $M_{i,j}$（如果在表格中没有被提及，那么间谍 $i$ 和 $j$ 之间不进行直接联系）。 假消息从盟军总部传递到每个间谍手里的渠道也不是绝对安全，我们用 $[0,1]$ 的实数 $AS_j$ 表示总部与间谍 $j$ 之间进行联系的安全程度，$AM_j $  则表示总部和间谍 $j$ 之间进行联系时传递的消息的最大数目。对于不和总部直接联系的间谍，他的  $AM_j = 0$（而表格中给出的他的 $AS_j$ 是没有意义的）。 当然，假消息从间谍手中交到敌军的情报部官员的办公桌上的过程是绝对安全的，也即是说，间谍与敌军情报部门之间要么不进行直接联系，要么其联系的安全程度是 $1$（即完全可靠）。\n\n现在情报部打算把 $K$ 条假消息“透露”到德军那里。消息先由总部一次性发给 $N$ 名间谍中的一些人，再通过他们之间的情报网传播，最终由这 $N$ 名间谍中的某些将情报送到德军手中。 对于一条消息，只有安全的通过了所有的中转过程到达敌军情报部，这个传递消息的过程才算是安全的；因此根据乘法原理，它的安全程度 $P$ 就是从总部出发，经多次传递直到到达德军那里，每一次传递该消息的安全程度的乘积。 而对于整个计划而言，只有当 $N$ 条消息都安全的通过情报网到达德军手中，没有一条引起怀疑时，才算是成功的。所以计划的可靠程度是所有消息的安全程度的乘积。 显然，计划的可靠性取决于这些消息在情报网中的传递方法。 我需要一个方案，确定消息应该从哪些人手中传递到哪些人手中，使得最终计划的可靠性最大。\n\n你可以利用计算机，来求得这个最可靠的消息传递方案。", "inputFormat": "输入包含了盟军的作战资料表格。\n\n第一行包括两个整数 $N$ 和 $K$ ，分别是间谍的总人数和计划包含的消息总数。\n\n第二行包括 $2N$ 个数，前 $N$ 个数是实数 $AS_1,AS_2,\\cdots,AS_N$ （范围在 $[0,1]$ 以内）；后 $N$ 个数是整数 $AM_1,AM_2,\\cdots,AM_N$ 。\n\n第三行包含了 $N$ 个整数，其中第 $i$（$i = 1,2,\\cdots,N$）个整数如果为 $0$ 表示间谍 $i$ 与德军情报部不进行联系，如果为 $1$ 则表示间谍 $i$ 与德军情报部进行联系。\n\n第四行开始，每行包括 $4$ 个数，依次分别是：代表间谍编号的正整数 $i$ 和 $j$ ，间谍 $i$ 和 $j$ 联系的安全性参数 $S_{i,j}$ ( $[0,1]$ 范围内的实数)，以及 $i,j$ 之间传递的最大消息数 $M_{i,j}$ (每一行的 $i$ 均小于 $j$)。\n\n最后的一行为 `-1 -1` ，表示输入数据的结束。", "outputFormat": "输出只有一行。这一行中包含一个实数 $P$ ，给出的是整个计划的可靠程度 $P$ ，**保留 $5$ 位有效数字**（四舍五入）。\n\n如果情报网根本不能将 $K$ 条消息传到德军手中，那么计划的可靠性为 $0$ 。\n\n(你可以假定，如果计划存在，那么它的可靠性大于 $10^{-12}$)", "hint": "$1 \\le N,K \\le 300$。", "locale": "zh-CN"}}}
{"pid": "P5815", "type": "P", "difficulty": 4, "samples": [["3 4\n1 2 3\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2010", "重庆", "二分", "各省省选"], "title": "[CQOI2010] 扑克牌", "background": "", "description": "你有 $n$ 种牌，第 $i$ 种牌的数目为 $c_i$。另外有一种特殊的牌：joker，它的数目是 $m$。你可以用每种牌各一张来组成一套牌，也可以用一张 joker 和除了某一种牌以外的其他牌各一张组成 $1$ 套牌。比如，当 $n=3$ 时，一共有 $4$ 种合法的套牌：$\\{1,2,3\\}$，$\\{J,2,3\\}$，$\\{1,J,3\\}$，$\\{1,2,J\\}$。\n\n给出 $n$，$m$ 和 $c_i$，你的任务是组成尽量多的套牌。每张牌最多只能用在一副套牌里（可以有牌不使用）。", "inputFormat": "第一行包含两个整数 $n$，$m$，即牌的种数和 joker 的个数。\n\n第二行包含 $n$ 个整数 $c_i$，即每种牌的张数。\n", "outputFormat": "输出仅一个整数，即最多组成的套牌数目。\n", "hint": "**样例说明**\n\n输入数据表明：一共有 $1$ 个 $1$，$2$ 个 $2$，$3$ 个 $3$，$4$ 个 joker。最多可以组成三副套牌：$\\{1,J,3\\}$，$\\{J,2,3\\}$，$\\{J,2,3\\}$，joker 还剩一个，其余牌全部用完。\n\n**数据范围**\n\n对于 $50\\%$ 的数据，$2 \\le n \\le 5$，$0 \\le m \\le 10^6$，$0 \\le c_i \\le 200$。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 50$，$0 \\le m,c_i \\le 5 \\times 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2010] Playing Cards", "background": "", "description": "You have $n$ types of cards. The number of cards of type $i$ is $c_i$. There is also a special card type: joker, and its number is $m$.\n\nYou can form one set of cards by taking one card from each type. You can also form one set by taking one joker and one card from every other type except one specific type. For example, when $n=3$, there are $4$ valid sets in total: $\\{1,2,3\\}$, $\\{J,2,3\\}$, $\\{1,J,3\\}$, $\\{1,2,J\\}$.\n\nGiven $n$, $m$, and $c_i$, your task is to form as many sets as possible. Each card can be used in at most one set (you may leave some cards unused).", "inputFormat": "The first line contains two integers $n$, $m$, representing the number of card types and the number of jokers.\n\nThe second line contains $n$ integers $c_i$, representing the number of cards of each type.", "outputFormat": "Output only one integer: the maximum number of sets that can be formed.", "hint": "**Sample Explanation**\n\nThe input shows that there are $1$ card of type $1$, $2$ cards of type $2$, $3$ cards of type $3$, and $4$ jokers. At most three sets can be formed: $\\{1,J,3\\}$, $\\{J,2,3\\}$, $\\{J,2,3\\}$. One joker remains, and all other cards are used up.\n\n**Constraints**\n\nFor $50\\%$ of the testdata, $2 \\le n \\le 5$, $0 \\le m \\le 10^6$, $0 \\le c_i \\le 200$.\n\nFor $100\\%$ of the testdata, $2 \\le n \\le 50$, $0 \\le m,c_i \\le 5 \\times 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2010] 扑克牌", "background": "", "description": "你有 $n$ 种牌，第 $i$ 种牌的数目为 $c_i$。另外有一种特殊的牌：joker，它的数目是 $m$。你可以用每种牌各一张来组成一套牌，也可以用一张 joker 和除了某一种牌以外的其他牌各一张组成 $1$ 套牌。比如，当 $n=3$ 时，一共有 $4$ 种合法的套牌：$\\{1,2,3\\}$，$\\{J,2,3\\}$，$\\{1,J,3\\}$，$\\{1,2,J\\}$。\n\n给出 $n$，$m$ 和 $c_i$，你的任务是组成尽量多的套牌。每张牌最多只能用在一副套牌里（可以有牌不使用）。", "inputFormat": "第一行包含两个整数 $n$，$m$，即牌的种数和 joker 的个数。\n\n第二行包含 $n$ 个整数 $c_i$，即每种牌的张数。\n", "outputFormat": "输出仅一个整数，即最多组成的套牌数目。\n", "hint": "**样例说明**\n\n输入数据表明：一共有 $1$ 个 $1$，$2$ 个 $2$，$3$ 个 $3$，$4$ 个 joker。最多可以组成三副套牌：$\\{1,J,3\\}$，$\\{J,2,3\\}$，$\\{J,2,3\\}$，joker 还剩一个，其余牌全部用完。\n\n**数据范围**\n\n对于 $50\\%$ 的数据，$2 \\le n \\le 5$，$0 \\le m \\le 10^6$，$0 \\le c_i \\le 200$。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 50$，$0 \\le m,c_i \\le 5 \\times 10^8$。", "locale": "zh-CN"}}}
{"pid": "P5816", "type": "P", "difficulty": 5, "samples": [["4\n0 2\n2 0\n-2 0\n0 -2\n", "5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "重庆", "各省省选"], "title": "[CQOI2010] 内部白点", "background": "", "description": "无限大正方形网格里有 $n$ 个黑色的顶点，所有其他顶点都是白色的（网格的顶点即坐标为整数的点，又称整点）。每秒钟，所有内部白点同时变黑，直到不存在内部白点为止。你的任务是统计最后网格中的黑点个数。\n\n内部白点的定义：一个白色的整点 $P(x,y)$ 是内部白点当且仅当 $P$ 在水平线的左边和右边各至少有一个黑点（即存在$x_1 < x < x_2$ 使得 $(x_1,y)$ 和 $(x_2,y)$ 都是黑点），且在竖直线的上边和下边各至少有一个黑点（即存在 $y_1 < y < y_2$ 使得 $(x,y_1)$ 和 $(x,y_2)$ 都是黑点）。", "inputFormat": "输入第一行包含一个整数 $n$，即初始黑点个数。\n\n以下 $n$ 行每行包含两个整数 $x$，$y$，即一个黑点的坐标。没有两个黑点的坐标相同，坐标的绝对值均不超过 $10^9$。", "outputFormat": "输出仅一行，包含黑点的最终数目。\n\n如果变色过程永不终止，输出`-1`。\n", "hint": "**数据范围**\n\n对于 $36\\%$ 的数据，$n \\le 500$。\n\n对于 $64\\%$ 的数据，$n \\le 3 \\times 10^4$。\n\n对于 $100\\%$ 的数据，$n \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2010] Internal White Points", "background": "", "description": "On an infinite square grid, there are $n$ black vertices, and all other vertices are white (grid vertices are points with integer coordinates, also called lattice points). Every second, all internal white points turn black simultaneously, until there are no internal white points left. Your task is to count the number of black points in the grid at the end.\n\nDefinition of an internal white point: a white lattice point $P(x,y)$ is an internal white point if and only if there is at least one black point to the left and to the right of $P$ on the same horizontal line (i.e., there exist $x_1 < x < x_2$ such that $(x_1,y)$ and $(x_2,y)$ are both black), and at least one black point above and below $P$ on the same vertical line (i.e., there exist $y_1 < y < y_2$ such that $(x,y_1)$ and $(x,y_2)$ are both black).", "inputFormat": "The first line contains an integer $n$, the number of initial black points.\n\nThe next $n$ lines each contain two integers $x$, $y$, the coordinates of a black point. No two black points have the same coordinates, and the absolute value of each coordinate does not exceed $10^9$.", "outputFormat": "Output one line containing the final number of black points.\n\nIf the recoloring process never terminates, output `-1`.", "hint": "**Constraints**\n\nFor $36\\%$ of the testdata, $n \\le 500$.\n\nFor $64\\%$ of the testdata, $n \\le 3 \\times 10^4$.\n\nFor $100\\%$ of the testdata, $n \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2010] 内部白点", "background": "", "description": "无限大正方形网格里有 $n$ 个黑色的顶点，所有其他顶点都是白色的（网格的顶点即坐标为整数的点，又称整点）。每秒钟，所有内部白点同时变黑，直到不存在内部白点为止。你的任务是统计最后网格中的黑点个数。\n\n内部白点的定义：一个白色的整点 $P(x,y)$ 是内部白点当且仅当 $P$ 在水平线的左边和右边各至少有一个黑点（即存在$x_1 < x < x_2$ 使得 $(x_1,y)$ 和 $(x_2,y)$ 都是黑点），且在竖直线的上边和下边各至少有一个黑点（即存在 $y_1 < y < y_2$ 使得 $(x,y_1)$ 和 $(x,y_2)$ 都是黑点）。", "inputFormat": "输入第一行包含一个整数 $n$，即初始黑点个数。\n\n以下 $n$ 行每行包含两个整数 $x$，$y$，即一个黑点的坐标。没有两个黑点的坐标相同，坐标的绝对值均不超过 $10^9$。", "outputFormat": "输出仅一行，包含黑点的最终数目。\n\n如果变色过程永不终止，输出`-1`。\n", "hint": "**数据范围**\n\n对于 $36\\%$ 的数据，$n \\le 500$。\n\n对于 $64\\%$ 的数据，$n \\le 3 \\times 10^4$。\n\n对于 $100\\%$ 的数据，$n \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5817", "type": "P", "difficulty": 5, "samples": [["4\n1\n2\n5\n4\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2011", "重庆", "各省省选"], "title": "[CQOI2011] 分金币", "background": "", "description": "圆桌上坐着 $n$ 个人，每人有一定数量的金币，金币总数能被 $n$ 整除。每个人可以给他左右相邻的人一些金币，最终使\n得每个人的金币数目相等。\n\n你的任务是求出被转手的金币数量的最小值。", "inputFormat": "第一行为整数 $n$（$ n \\ge 3$）。\n\n以下 $n$ 行每行一个正整数，按逆时针顺序给出每个人拥有的金币数。\n", "outputFormat": "共一行，输出被转手金币数量的最小值。", "hint": "**样例说明**\n\n设四个人编号为 $1,2,3,4$。第 $3$ 个人给第 $2$ 个人 $2$ 个金币（变成 $1,4,3,4$），第 $2$ 个人和第 $4$ 个人分别给第 $1$ 个人 $1$ 个金币。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$3 \\le n \\le 10^5$，$总金币数 \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2011] Distributing Gold Coins", "background": "", "description": "There are $n$ people sitting around a round table. Each person has some number of gold coins, and the total number of coins is divisible by $n$. Each person can give some coins to their left and right neighbors, and in the end everyone must have the same number of coins.\n\nYour task is to find the minimum total number of coins that are passed from hand to hand.", "inputFormat": "The first line contains an integer $n$ ($n \\ge 3$).\n\nThe next $n$ lines each contain a positive integer, given in counterclockwise order, representing the number of coins each person has.", "outputFormat": "Output one line containing the minimum total number of coins that are passed from hand to hand.", "hint": "**Sample Explanation**\n\nSuppose the four people are numbered $1,2,3,4$. Person $3$ gives person $2$ $2$ coins (becoming $1,4,3,4$). Then person $2$ and person $4$ each give person $1$ $1$ coin.\n\n**Constraints**\n\nFor $100\\%$ of the testdata, $3 \\le n \\le 10^5$, and $total$ $coins \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2011] 分金币", "background": "", "description": "圆桌上坐着 $n$ 个人，每人有一定数量的金币，金币总数能被 $n$ 整除。每个人可以给他左右相邻的人一些金币，最终使\n得每个人的金币数目相等。\n\n你的任务是求出被转手的金币数量的最小值。", "inputFormat": "第一行为整数 $n$（$ n \\ge 3$）。\n\n以下 $n$ 行每行一个正整数，按逆时针顺序给出每个人拥有的金币数。\n", "outputFormat": "共一行，输出被转手金币数量的最小值。", "hint": "**样例说明**\n\n设四个人编号为 $1,2,3,4$。第 $3$ 个人给第 $2$ 个人 $2$ 个金币（变成 $1,4,3,4$），第 $2$ 个人和第 $4$ 个人分别给第 $1$ 个人 $1$ 个金币。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$3 \\le n \\le 10^5$，$总金币数 \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5818", "type": "P", "difficulty": 7, "samples": [["10 10 66103", "475"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "江苏"], "title": "[JSOI2011] 同分异构体计数", "background": "", "description": "Antonio 最近对有机化学比较感兴趣，他想请你帮助他快速计算出某种烃类的同分异构体的数目。 \n\n为了表述方便，我们作出如下定义： \n- 环烷烃： 具有 $n$ 个碳原子的环烷烃可以表示成一张具有 $n$ 个顶点 $n$ 条边的无向连通简单图(基环+外向树)。每个顶点的度数不超过 $4$。 \n- M-环烷烃：至多有 $m$ 个顶点在环上的环烷烃。（注意环上至少有 $3$ 个顶点，因为任意两个顶点之间至多只能有 $1$ 条边）。 \n- 同构：假设结构 $A$ 和结构 $B$ 均具有 $n$ 个碳原子，$A$ 和 $B$ 同构当且仅当能够对 $A$ 和 $B$ 中的每个碳原子都按照 $1~n$ 编号，使得对于编号为 $v_1$ 和 $v_2$ 的两个碳原子，他们在 $A$ 中存在边相连当且仅当他们在 $B$ 中存在边相连。（换言之，$A$ 和 $B$ 对应的图同构）。\n \n现在，给出 $n$，$m$，Antonio 希望你帮助他统计有多少种互不同构的含有 $n$ 个碳原子的 M-环烷烃。由于这个数量可能很大，你只需要输出它对 $p$ 的余数。（$p$ 是一个素数）。 \n\n在本题中，我们不考虑某结构在化学上是否能够稳定存在，也不考虑其他的异构方式。", "inputFormat": "输入文件只有一行，用空格隔开的三个整数 $n$，$m$，$p$ 。\n\n", "outputFormat": "输出文件有且仅有一行，表示具有 $n$ 个碳原子的互不同构的M-环烷烃 的数量，对 $p$ 取模。", "hint": "**数据范围**\n\n$3 \\le n \\le 1000$，$3 \\le m \\le 50$，$m \\le n$，$10^4 \\le p \\le 2 \\times 10^9$，保证 $p$ 为素数。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2011] Counting Structural Isomers", "background": "", "description": "Antonio has recently become interested in organic chemistry, and he wants you to help him quickly compute the number of structural isomers of a certain type of hydrocarbon.\n\nFor convenience, we define the following:\n\n- Cycloalkane: A cycloalkane with $n$ carbon atoms can be represented as an undirected connected simple graph with $n$ vertices and $n$ edges (a base cycle plus outward trees). The degree of each vertex is at most $4$.\n- M-cycloalkane: A cycloalkane in which at most $m$ vertices lie on the cycle. (Note that the cycle must contain at least $3$ vertices, because between any two vertices there can be at most $1$ edge.)\n- Isomorphism: Suppose structures $A$ and $B$ both have $n$ carbon atoms. $A$ and $B$ are isomorphic if and only if we can label every carbon atom in both $A$ and $B$ with numbers $1 \\sim n$ such that for two carbon atoms labeled $v_1$ and $v_2$, there is an edge between them in $A$ if and only if there is an edge between them in $B$. (In other words, the corresponding graphs of $A$ and $B$ are isomorphic.)\n\nNow, given $n$ and $m$, Antonio wants you to count how many pairwise non-isomorphic M-cycloalkanes with $n$ carbon atoms there are. Since this number may be very large, you only need to output it modulo $p$ ($p$ is a prime).\n\nIn this problem, we do not consider whether a structure can exist stably in chemistry, and we do not consider other types of isomerism.", "inputFormat": "The input contains only one line with three integers $n$, $m$, and $p$, separated by spaces.", "outputFormat": "Output exactly one line: the number of pairwise non-isomorphic M-cycloalkanes with $n$ carbon atoms, modulo $p$.", "hint": "**Constraints**\n\n$3 \\le n \\le 1000$, $3 \\le m \\le 50$, $m \\le n$, $10^4 \\le p \\le 2 \\times 10^9$, and $p$ is guaranteed to be prime.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2011] 同分异构体计数", "background": "", "description": "Antonio 最近对有机化学比较感兴趣，他想请你帮助他快速计算出某种烃类的同分异构体的数目。 \n\n为了表述方便，我们作出如下定义： \n- 环烷烃： 具有 $n$ 个碳原子的环烷烃可以表示成一张具有 $n$ 个顶点 $n$ 条边的无向连通简单图(基环+外向树)。每个顶点的度数不超过 $4$。 \n- M-环烷烃：至多有 $m$ 个顶点在环上的环烷烃。（注意环上至少有 $3$ 个顶点，因为任意两个顶点之间至多只能有 $1$ 条边）。 \n- 同构：假设结构 $A$ 和结构 $B$ 均具有 $n$ 个碳原子，$A$ 和 $B$ 同构当且仅当能够对 $A$ 和 $B$ 中的每个碳原子都按照 $1~n$ 编号，使得对于编号为 $v_1$ 和 $v_2$ 的两个碳原子，他们在 $A$ 中存在边相连当且仅当他们在 $B$ 中存在边相连。（换言之，$A$ 和 $B$ 对应的图同构）。\n \n现在，给出 $n$，$m$，Antonio 希望你帮助他统计有多少种互不同构的含有 $n$ 个碳原子的 M-环烷烃。由于这个数量可能很大，你只需要输出它对 $p$ 的余数。（$p$ 是一个素数）。 \n\n在本题中，我们不考虑某结构在化学上是否能够稳定存在，也不考虑其他的异构方式。", "inputFormat": "输入文件只有一行，用空格隔开的三个整数 $n$，$m$，$p$ 。\n\n", "outputFormat": "输出文件有且仅有一行，表示具有 $n$ 个碳原子的互不同构的M-环烷烃 的数量，对 $p$ 取模。", "hint": "**数据范围**\n\n$3 \\le n \\le 1000$，$3 \\le m \\le 50$，$m \\le n$，$10^4 \\le p \\le 2 \\times 10^9$，保证 $p$ 为素数。", "locale": "zh-CN"}}}
{"pid": "P5819", "type": "P", "difficulty": 6, "samples": [["5 6\n1 0.0 10.0\n1.5 0.0 10.0\n2.0 0.0 10.0\n2.5 0.0 10.0\n3.0 0.0 10.0\n0.0 5.0\n0.4 5.0\n1.3 5.0\n2.0 5.0\n2.7 5.0\n3.6 5.0", "1 2 2 3"], ["4 2\n0.1 0.0 3.0\n0.1 2.0 4.0\n0.0 3.0 8.0\n0.6 1.0 6.0\n0.6 6.0\n0.0 2.5", "3 0 1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "洛谷原创"], "title": "【L&K R-03】音游大计算", "background": "", "description": "小 K 喜欢玩音游，特别是一款叫做 dimou 的音游。dimou 的判定机制是这样的：dimou 是单面（不像某 dy 开头的东西）下落式音游。具体来说，在屏幕底端有一条判定线。一首曲子有若干打击点（即 key，可以看做一条与判定线平行的只有左右宽度的线段），每个 key 会在某个时刻从顶端匀速下落，而玩家需要尽量精准地在每个 key 与判定线重合时点击它。\n\n当然，玩家有可能在 key 接触判定线之前就点击了，也可能在 key 已经落到判定线之下时才点击。这时候，就需要考虑游戏的判定系统，以统计玩家完成一首曲子的情况。dimou 有三种判定：perfect，good 和 miss。总共有六种情况——\n\n情况 $1$：玩家点击的时间在某个 key 下落至其与判定线重合的时间的前 $1s$ 或更多（记为 $\\triangle t\\ge1$，下同），则不会产生任何判定效果（等于无意义点击）；\n\n情况 $2$：$0.6\\le\\triangle t<1$，则此 key 产生一次 miss 判定并消失；\n\n情况 $3$：$0.2\\le\\triangle t<0.6$，则此 key 产生一次 good 判定并消失；\n\n情况 $4$：$-0.2<\\triangle t<0.2$（负数代表在 key 到达判定线之后点击），则此 key 产生一次 perfect 判定并消失；\n\n情况 $5$：$-0.6<\\triangle t\\le-0.2$，则此 key 产生一次 good 判定并消失；\n\n情况 $6$：$\\triangle t\\le-0.6$，则此 key 在点击之前就会落出屏幕，记一次 miss 判定并消失（即在此 key 落于判定线之下 $0.6s$ 后自己产生一次 miss 判定），点击对此 key 不会产生任何判定效果。\n\n除此之外，dimou 还有最大连击判定（max combo）。一段连击（combo）是指从某一个非 miss 的判定开始，到某一个非 miss 的判定结束（在这段区间内 **（按时间顺序）** 没有任何 miss 判定），判定的总数量。而 max combo 则指的是所有 combo 的最大值。\n\n除此之外，dimou 还有一些判定规则。一次点击的位置可以看做判定线上的一个点，则过此点作判定线的垂线，只有与此垂线有交点（交点可在端点）的 key 才**可能**因此次点击产生判定效果。并且， **每次点击只会对可能产生判定效果的 key 中位置（纵向高度）最低（离屏幕顶端最远）的一个产生判定效果。** 形象地说，你只有点击某个 key 下方的位置才可能将其消除，并且若两个 key 有上下相对距离地一起下落，那么如果点击可以使下面的 key 消除，则一定不会使上面的 key 消除。特殊地，如果一次点击对两个或以上位置（高度）相同的 key 都可能产生判定效果，且没有更低的可能产生判定效果的 key，则这些 key 都会被消除。\n\n为了把一首曲子打好，小 K 决定背谱，即记住所有 key 的位置和它们下落到判定线的时间。当然，小 K 也会事先决定好自己的打法，即决定在什么时间在什么位置点击。可是小 K 并不会计算自己的打法可以得到的最终成绩。请你帮小 K 算算，他的打法会得到多少 perfect 判定，多少 good 判定，多少 miss 判定，以及 max combo。\n\n注意：小 K 不会在同一时间点击两次或以上。如果同一时间有多个判定，按 miss，good，perfect 的顺序依次处理。", "inputFormat": "第一行两个正整数 $n,m$，代表 key 数量与小 K 的点击数。\n\n紧接着 $n$ 行，每行三个浮点数（小数位数不超过 $5$ 位）$t_i,a_i,b_i$，分别表示每个 key 从曲子开始算起到达判定线的时间，其左端点位置，右端点位置。\n\n紧接着 $m$ 行，每行两个浮点数（小数位数不超过 $5$ 位）$T_i,x_i$，分别表示小 K 每次点击从曲子开始算起的时间和其位置。", "outputFormat": "一行，输出四个非负整数，两两用单个空格隔开，分别代表 perfect 数，good 数，miss 数和 max combo。", "hint": "样例 $3$：[输入](https://www.luogu.com.cn/paste/qrbt8fnq)，[输出](https://www.luogu.com.cn/paste/evke45h8)。\n\n样例 $4$：[输入](https://www.luogu.com.cn/paste/a71namso)，[输出](https://www.luogu.com.cn/paste/jgpcani2)。\n\n【样例解释】\n\n对于样例 $1$：$5$ 个 key 产生的判定按时间顺序分别为 \n miss，good，perfect，good，miss。第一次和最后一次点击不产生判定效果。\n\n对于样例 $2$：按时间顺序，第一次点击（$T=0.0$），可能产生判定效果的有（按输入顺序）第 $1,2,4$ 个 key。第 $1,2$ 个 key 同时到达判定线，第 $4$ 个 key 比第 $1,2$ 个 key 高。因此第一次点击只让第 $1,2$ 个 key 产生 perfect 判定。第二次点击（$T=0.6$），与其垂线有交点的有第 $3,4$ 个 key，但第 $3$ 个 key 此时已经产生 miss 判定并消失，因此这次点击让第 $4$ 个 key 产生一次 perfect 判定，此时在同一时间出现了两个判定 perfect，miss，按照规则先处理 miss 再处理 perfect。所以，所有判定按时间顺序分别是 perfect，perfect，miss，perfect。容易发现 miss 把判定序列分成了两段，第一段的 combo 为 $2$，第二段的 combo 为 $1$，所以 max combo 为 $2$。\n\n【数据范围】\n\n对于 $30\\%$ 数据，$n,m\\le5000$。\n\n对于另外 $20\\%$ 数据，$n\\le5000$，$m\\le114514$。\n\n对于另外 $10\\%$ 数据，所有 $a_i$ 相等，所有 $b_i$ 相等。\n\n对于另外 $10\\%$ 数据，$t_i,T_i,a_i,b_i,x_i$ 在 $[0,10^4]$ 中随机生成。\n\n对于 $100\\%$ 数据，$1\\le n,m\\le114514$，$0\\le t_i,T_i,a_i,b_i,x_i\\le 10^4$，$a_i\\le b_i$。", "locale": "zh-CN", "translations": {"en": {"title": "[L&K R-03] Rhythm Game Big Calculation.", "background": "", "description": "Xiao K likes playing rhythm games, especially one called dimou. The judgment system of dimou works like this: dimou is a single-sided falling rhythm game (unlike something starting with “dy”). Specifically, there is a judgment line at the bottom of the screen. A song has several hit objects (called keys; you can think of each as a line segment parallel to the judgment line, with only left-right width). Each key falls from the top at a constant speed at some time, and the player needs to click it as accurately as possible when it overlaps the judgment line.\n\nOf course, the player may click before a key touches the judgment line, or click only after the key has already fallen below the judgment line. In that case, we need to consider the game’s judgment system to count how the player finishes the song. dimou has three judgments: perfect, good, and miss. There are six cases in total.\n\nCase $1$: If the click time is $1s$ or more before the time when some key falls to overlap the judgment line (denote this as $\\triangle t\\ge1$, same below), then no judgment effect is produced (equivalent to a meaningless click).\n\nCase $2$: If $0.6\\le\\triangle t<1$, then this key produces one miss judgment and disappears.\n\nCase $3$: If $0.2\\le\\triangle t<0.6$, then this key produces one good judgment and disappears.\n\nCase $4$: If $-0.2<\\triangle t<0.2$ (a negative value means clicking after the key reaches the judgment line), then this key produces one perfect judgment and disappears.\n\nCase $5$: If $-0.6<\\triangle t\\le-0.2$, then this key produces one good judgment and disappears.\n\nCase $6$: If $\\triangle t\\le-0.6$, then this key will have already fallen out of the screen before the click, counting as one miss judgment and disappearing (that is, it produces one miss judgment by itself after it has been below the judgment line for $0.6s$). Clicking has no judgment effect on this key.\n\nIn addition, dimou has a maximum combo statistic (max combo). A combo segment is the total number of judgments from some non-miss judgment to some non-miss judgment (within this interval, in **time order**, there is no miss judgment). max combo is the maximum value among all combos.\n\nBesides, dimou has some additional rules. The position of a click can be considered as a point on the judgment line. Draw the perpendicular line to the judgment line through this point; only keys that intersect this perpendicular line (the intersection may be at an endpoint) **may** produce a judgment effect due to this click. Moreover, **each click only produces a judgment effect on the one key among those that may produce an effect whose position (vertical height) is the lowest (farthest from the top of the screen).** Intuitively, you can only remove a key by clicking somewhere below it, and if two keys fall together with some vertical distance between them, then if a click can remove the lower key, it will definitely not remove the upper key. Specially, if one click may produce a judgment effect on two or more keys with the same position (height), and there is no lower key that may produce a judgment effect, then all these keys will be removed.\n\nTo play a song well, Xiao K decides to memorize the chart, i.e., remember the position of every key and the time when it falls to the judgment line. Of course, Xiao K will also decide his play plan in advance, i.e., decide at what time and at what position to click. But Xiao K cannot compute the final score his plan will get. Please help Xiao K calculate how many perfect judgments, how many good judgments, how many miss judgments, and the max combo he will obtain.\n\nNote: Xiao K will not click two or more times at the same time. If there are multiple judgments at the same time, process them in the order miss, good, perfect.", "inputFormat": "The first line contains two positive integers $n,m$, representing the number of keys and the number of clicks by Xiao K.\n\nThen follow $n$ lines, each containing three floating-point numbers (with at most $5$ digits after the decimal point) $t_i,a_i,b_i$, representing, for each key, the time from the start of the song to when it reaches the judgment line, its left endpoint position, and its right endpoint position.\n\nThen follow $m$ lines, each containing two floating-point numbers (with at most $5$ digits after the decimal point) $T_i,x_i$, representing the time from the start of the song for each click and its position.", "outputFormat": "Output one line with four non-negative integers, separated pairwise by a single space, representing the number of perfect, the number of good, the number of miss, and the max combo.", "hint": "Sample $3$: [input](https://www.luogu.com.cn/paste/qrbt8fnq), [output](https://www.luogu.com.cn/paste/evke45h8).\n\nSample $4$: [input](https://www.luogu.com.cn/paste/a71namso), [output](https://www.luogu.com.cn/paste/jgpcani2).\n\n[Sample Explanation]\n\nFor sample $1$: The judgments produced by the $5$ keys, in time order, are miss, good, perfect, good, miss. The first and the last click do not produce any judgment effect.\n\nFor sample $2$: In time order, for the first click ($T=0.0$), the keys that may produce a judgment effect are keys $1,2,4$ (in input order). Keys $1,2$ reach the judgment line at the same time, and key $4$ is higher than keys $1,2$. Therefore, the first click only makes keys $1,2$ produce perfect judgments. For the second click ($T=0.6$), the keys intersecting its perpendicular line are keys $3,4$, but key $3$ has already produced a miss judgment and disappeared, so this click makes key $4$ produce one perfect judgment. At this time, there are two judgments at the same time: perfect and miss. According to the rule, process miss before perfect. Therefore, all judgments in time order are perfect, perfect, miss, perfect. It is easy to see that the miss splits the judgment sequence into two segments: the first segment has a combo of $2$, the second segment has a combo of $1$, so max combo is $2$.\n\n[Constraints]\n\nFor $30\\%$ of the data, $n,m\\le5000$.\n\nFor another $20\\%$ of the data, $n\\le5000$, $m\\le114514$.\n\nFor another $10\\%$ of the data, all $a_i$ are equal, and all $b_i$ are equal.\n\nFor another $10\\%$ of the data, $t_i,T_i,a_i,b_i,x_i$ are randomly generated in $[0,10^4]$.\n\nFor $100\\%$ of the data, $1\\le n,m\\le114514$, $0\\le t_i,T_i,a_i,b_i,x_i\\le 10^4$, and $a_i\\le b_i$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【L&K R-03】音游大计算", "background": "", "description": "小 K 喜欢玩音游，特别是一款叫做 dimou 的音游。dimou 的判定机制是这样的：dimou 是单面（不像某 dy 开头的东西）下落式音游。具体来说，在屏幕底端有一条判定线。一首曲子有若干打击点（即 key，可以看做一条与判定线平行的只有左右宽度的线段），每个 key 会在某个时刻从顶端匀速下落，而玩家需要尽量精准地在每个 key 与判定线重合时点击它。\n\n当然，玩家有可能在 key 接触判定线之前就点击了，也可能在 key 已经落到判定线之下时才点击。这时候，就需要考虑游戏的判定系统，以统计玩家完成一首曲子的情况。dimou 有三种判定：perfect，good 和 miss。总共有六种情况——\n\n情况 $1$：玩家点击的时间在某个 key 下落至其与判定线重合的时间的前 $1s$ 或更多（记为 $\\triangle t\\ge1$，下同），则不会产生任何判定效果（等于无意义点击）；\n\n情况 $2$：$0.6\\le\\triangle t<1$，则此 key 产生一次 miss 判定并消失；\n\n情况 $3$：$0.2\\le\\triangle t<0.6$，则此 key 产生一次 good 判定并消失；\n\n情况 $4$：$-0.2<\\triangle t<0.2$（负数代表在 key 到达判定线之后点击），则此 key 产生一次 perfect 判定并消失；\n\n情况 $5$：$-0.6<\\triangle t\\le-0.2$，则此 key 产生一次 good 判定并消失；\n\n情况 $6$：$\\triangle t\\le-0.6$，则此 key 在点击之前就会落出屏幕，记一次 miss 判定并消失（即在此 key 落于判定线之下 $0.6s$ 后自己产生一次 miss 判定），点击对此 key 不会产生任何判定效果。\n\n除此之外，dimou 还有最大连击判定（max combo）。一段连击（combo）是指从某一个非 miss 的判定开始，到某一个非 miss 的判定结束（在这段区间内 **（按时间顺序）** 没有任何 miss 判定），判定的总数量。而 max combo 则指的是所有 combo 的最大值。\n\n除此之外，dimou 还有一些判定规则。一次点击的位置可以看做判定线上的一个点，则过此点作判定线的垂线，只有与此垂线有交点（交点可在端点）的 key 才**可能**因此次点击产生判定效果。并且， **每次点击只会对可能产生判定效果的 key 中位置（纵向高度）最低（离屏幕顶端最远）的一个产生判定效果。** 形象地说，你只有点击某个 key 下方的位置才可能将其消除，并且若两个 key 有上下相对距离地一起下落，那么如果点击可以使下面的 key 消除，则一定不会使上面的 key 消除。特殊地，如果一次点击对两个或以上位置（高度）相同的 key 都可能产生判定效果，且没有更低的可能产生判定效果的 key，则这些 key 都会被消除。\n\n为了把一首曲子打好，小 K 决定背谱，即记住所有 key 的位置和它们下落到判定线的时间。当然，小 K 也会事先决定好自己的打法，即决定在什么时间在什么位置点击。可是小 K 并不会计算自己的打法可以得到的最终成绩。请你帮小 K 算算，他的打法会得到多少 perfect 判定，多少 good 判定，多少 miss 判定，以及 max combo。\n\n注意：小 K 不会在同一时间点击两次或以上。如果同一时间有多个判定，按 miss，good，perfect 的顺序依次处理。", "inputFormat": "第一行两个正整数 $n,m$，代表 key 数量与小 K 的点击数。\n\n紧接着 $n$ 行，每行三个浮点数（小数位数不超过 $5$ 位）$t_i,a_i,b_i$，分别表示每个 key 从曲子开始算起到达判定线的时间，其左端点位置，右端点位置。\n\n紧接着 $m$ 行，每行两个浮点数（小数位数不超过 $5$ 位）$T_i,x_i$，分别表示小 K 每次点击从曲子开始算起的时间和其位置。", "outputFormat": "一行，输出四个非负整数，两两用单个空格隔开，分别代表 perfect 数，good 数，miss 数和 max combo。", "hint": "样例 $3$：[输入](https://www.luogu.com.cn/paste/qrbt8fnq)，[输出](https://www.luogu.com.cn/paste/evke45h8)。\n\n样例 $4$：[输入](https://www.luogu.com.cn/paste/a71namso)，[输出](https://www.luogu.com.cn/paste/jgpcani2)。\n\n【样例解释】\n\n对于样例 $1$：$5$ 个 key 产生的判定按时间顺序分别为 \n miss，good，perfect，good，miss。第一次和最后一次点击不产生判定效果。\n\n对于样例 $2$：按时间顺序，第一次点击（$T=0.0$），可能产生判定效果的有（按输入顺序）第 $1,2,4$ 个 key。第 $1,2$ 个 key 同时到达判定线，第 $4$ 个 key 比第 $1,2$ 个 key 高。因此第一次点击只让第 $1,2$ 个 key 产生 perfect 判定。第二次点击（$T=0.6$），与其垂线有交点的有第 $3,4$ 个 key，但第 $3$ 个 key 此时已经产生 miss 判定并消失，因此这次点击让第 $4$ 个 key 产生一次 perfect 判定，此时在同一时间出现了两个判定 perfect，miss，按照规则先处理 miss 再处理 perfect。所以，所有判定按时间顺序分别是 perfect，perfect，miss，perfect。容易发现 miss 把判定序列分成了两段，第一段的 combo 为 $2$，第二段的 combo 为 $1$，所以 max combo 为 $2$。\n\n【数据范围】\n\n对于 $30\\%$ 数据，$n,m\\le5000$。\n\n对于另外 $20\\%$ 数据，$n\\le5000$，$m\\le114514$。\n\n对于另外 $10\\%$ 数据，所有 $a_i$ 相等，所有 $b_i$ 相等。\n\n对于另外 $10\\%$ 数据，$t_i,T_i,a_i,b_i,x_i$ 在 $[0,10^4]$ 中随机生成。\n\n对于 $100\\%$ 数据，$1\\le n,m\\le114514$，$0\\le t_i,T_i,a_i,b_i,x_i\\le 10^4$，$a_i\\le b_i$。", "locale": "zh-CN"}}}
{"pid": "P5820", "type": "P", "difficulty": 5, "samples": [["2\n1 1 1 1 1 1\n1 1 1 2 2 2", "YES\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "洛谷原创"], "title": "【L&K R-03】射击场决战", "background": "", "description": "【如果不想看题面请阅读分割线以下部分】\n\n小 L 与小 K 是两个帮派的首领，也是死敌。某年某月，两个帮派发生了大规模的冲突。小 K 因为实力不敌，被小 L 的爪牙团团包围，最终被逼近了一个大型射击场。小 K 自知大势已去，正准备与小 L 拼死一战时，却传来消息，说小 L 要邀请自己与他来玩一场游戏。小 K 知道其中有鬼，但却别无它计，只能只身前往小 L 指定的会面点。\n\n会面点在射击场旁。小 L 站在场上，满脸笑容地对走来的小 K 招手。“啊，小 K ，好久不见。我记得上次我们见面的时候，还是在那个小酒馆。当时，我与你谈笑风生，指点江山，不亦乐乎。没想到，如今，我们竟到此地步啊！”小 L 顿了顿，继续说道：“你是我曾经的兄弟，我不想以暴力的方式了解你我。正好，我有一个好方法：不如我们用游戏的方式来场决战吧！这样如何，小 K ？”小 K 知道，自己并没有否定小 L 的余地。于是，小 K 点了点头。小 L 看到小 K 点头，又露出了笑容，开始讲起了游戏的规则。\n\n“如你所见，我们的游戏要在这片射击场上进行。射击场总共有 $n$ 行 $m$  列，共 $n\\times m$ 个靶。为了方便，取行的方向为左右，列的方向为前后。这个射击场有一个特点：每个靶上都有一个计数器。击中一个靶，这个靶的计数器示数就会加一。但是，每个靶的示数有一个范围，只能是不小于 $0$，不大于 $k$ 的整数。倘若击中一个靶，而在未击中此靶前此靶计数器的示数已经为 $k$，那么击中时，此靶计数器示数就会溢出清 $0$，并产生溢出错误的信号，经电线开始传递。由于靶场电线的特殊布置，信号只会往右侧传递。信号传递过程中会影响若干其它同行靶的计数器。如果这些被影响到的靶计数器示数为 $k$，其同样会溢出清 $0$ 并产生溢出错误信号，与之前的信号叠加（但加一效果不会叠加）；否则，其示数会加一，并发出纠正讯息，截断信号传播，即在其右侧的靶不会继续被信号影响。当然，如果信号一直传递而未被截断，那么它最终会传入信息管理终端。由于信号在传递过程中不断叠加，再加之信息管理终端要处理庞大的信息，纠正错误信号的能力较差，可能会导致终端死机甚至发生爆炸的危险，这是违规的。\n\n“我与你会轮流选择其中一个靶进行一次射击，射击哪个靶由射击者自行决定。如果轮到某个人射击，但他无法进行不违规的射击，那么他就输了。因为这是我设计的游戏，先手当然是我。但是，我也会给你一些选择。靶场上每个靶计数器的初始示数不一定为 $0$，是可以被我设置的。我这里恰好有几种设置方案，但我不知道该选哪种好，可否请你帮我选一选？”\n\n小 L 从口袋里抽出了几张纸条。小 K 一看，每张纸条却没有写每个靶计数器的初始示数，只写着三个数字 $a,b,c$。小 L 所不知道的是，小 K 有着惊人的观察能力，在小 L 讲刚才那一番话之时，小 K 就已经通过分析靶上示数的变化以及电路的布置，得出了计数器初始示数生成的规律。靶场上靶的计数器初始示数是一个个按顺序生成的。并且，生成的顺序是按行优先，从左到右，从上到下。具体来说，是按照第 $1$ 行第 $1,2,\\ldots ,m$ 个，第 $2$ 行第 $1,2,\\ldots ,m$ 个，……，第 $n$ 行第 $1,2,\\ldots ,m$ 个的顺序生成。生成一个计数器的示数需要用到 $a,b,c$ 作为参数。并且，每生成一个计数器的示数，$a,b,c$ 都会产生变化。具体来说，每生成一个计数器的示数，便引用一次以下的函数：\n\n```\ntypedef unsigned long long ull; \ninline ull generate(ull&a,ull&b,ull&c,ull&k)\n{ \n\ta<<=19;a+=b+c;\n\ta<<=26;a^=c+=a+81;b--;\n\ta<<=7;a>>=(b^c^1145)&14;\n\tc*=a;a|=b+=c;a^=b&c;\n\treturn a%(k+1);\n}\n```\n\n函数的返回值即为生成的计数器示数。容易发现，初始示数均为不小于 $0$，不大于 $k$ 的整数，不违反规则。\n\n小 K 知道小 L 是绝顶聪明的人，且一定会以自己的胜利为目标进行游戏。当然，小 K 因为掌握了许多这个游戏的信息，水平不会落后于小 L。小 K 不能违反小 L 制定的规则，否则可能惹恼小 L，使冲突再次爆发。但是，小 K 可以通过计算，得出小 L 给出的方案中哪些是小 L 必胜，哪些是自己必胜的，并选择一个自己必胜的方案进行游戏。\n\n可惜时间不允许小 K 做太长时间的计算。恰好，会编程的你可以帮助小 K 在较短的时间内得出结果。请你帮小 K 算算，在小 L 给出的所有方案中，哪些小 L 必胜，哪些小 L 必败。\n\n-----------------------\n\n考虑到小 L 说的话可能太长以至于难以理解，小 K 决定更为简洁地叙述这个问题。小 L 提供了一个 $n$ 行 $m$ 列的数阵。小 L 与小 K 二人轮流操作，每次可以将数阵中的某个数加上 $1$。若加 $1$ 后此数大于 $k$，则此数清零，将加 $1$ 操作传递给其右侧的数。若某个数需要传递操作，但其右侧没有数，则这个操作对应的人的初始操作将不可进行。最后无法操作的人败。小 L 为先手，二人都绝顶聪明。若小 L 会赢则输出 `YES`，否则输出 `NO`。\n\n数阵里初始的数由小 L 提供。小 L 提供了若干个填充数阵的方案，每个方案中数阵里的数由上文的函数生成，生成顺序从左到右，从上到下。方案的互异性体现在参数 $a,b,c$ 的不同。请你对每种方案给出答案。 **保证生成方式与题目的正确解法无关。** 注意对于每种方案，小 L 实际上提供了六个参数 $k,n,m,a,b,c$，即 $k,n,m$ 在每种方案中也可能各不相同。", "inputFormat": "第一行为小 L 给出方案总数。\n\n对于每种方案，按顺序给出六个参数：$k,n,m,a,b,c$，其意义如题所示。", "outputFormat": "对于每种方案，如果小 L 会赢，输出 `YES`，否则输出 `NO`。", "hint": "【样例解释】\n\n两种方案中射击场上都只有一个靶。\n\n对于方案一，此靶计数器上的初始数值为 $0$。小 L 先手射击此靶使其计数器加 $1$。轮到小 K 时，计数器示数为 $1$，不存在不违规射击方案，小 K 输，小 L 赢。\n\n对于方案二，此靶计数器上的初始数值为 $1$，不存在不违规射击方案，小 L 输。\n\n【数据范围】\n\n最多 $20$ 种方案。\n\n| 数据编号 | $n$ 的范围 | $m$ 的范围 | $k$ 的范围 | 特殊性质 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $n=1$ | $1\\le m\\le5$ | $1\\le k\\le 5$ | 无 |\n| $2$ | $n=1$ | $1\\le m\\le20$ | $1\\le k\\le 5$ | 无 |\n| $3$ | $n=1$ | $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | 无 |\n| $4$ | $1\\le n \\le2$ | $1\\le m\\le100000$ |$1\\le k\\le 10^{18}$  | 无 |\n| $5$ | $1\\le n \\le100000$ | $m=1$ | $1\\le k\\le 10^{18}$ | 无 |\n| $6$ | $1\\le n \\le1000$ | $1\\le m\\le1000$ | $1\\le k\\le 10^{18}$ | $k$为偶数 |\n| $7$ | $1\\le n \\le50000$ | $1\\le m\\le20$ | $1\\le k\\le 10^{18}$ | $k$为偶数 |\n| $8$ | $1\\le n \\le10$ | $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | $k$为偶数 |\n| $9\\sim 11$ | $1\\le n \\le1000$ |$1\\le m\\le1000$  | $1\\le k\\le 10^{18}$ | 无 |\n| $12\\sim 14$ | $1\\le n \\le50000$ | $1\\le m\\le20$ | $1\\le k\\le 10^{18}$ | 无 |\n| $15\\sim 17$ | $1\\le n \\le10$| $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | 无 |\n\n对于所有数据，$k,n,m,a,b,c$ 均为正整数，$1\\le a,b,c\\le10^{18}$。各数据点分值分布如下：编号为 $1$ 的数据点分值为 $7$；编号为 $9$、$12$、$15$ 的数据点分值为 $5$；其余数据点分值为 $6$。", "locale": "zh-CN", "translations": {"en": {"title": "[L&K R-03] Final Duel at the Shooting Range", "background": "", "description": "[If you do not want to read the story, please read the part below the separator.]\n\nXiao L and Xiao K are the leaders of two gangs, and they are sworn enemies. One year, a large-scale conflict broke out between the two gangs. Xiao K, being weaker, was surrounded by Xiao L’s followers and was finally forced to retreat to a large shooting range. Xiao K knew the situation was hopeless. Just as he was about to fight Xiao L to the death, news came that Xiao L wanted to invite him to play a game. Xiao K knew there must be a trap, but he had no other choice, so he went alone to the meeting point Xiao L specified.\n\nThe meeting point was beside the shooting range. Xiao L stood in the field and waved to the approaching Xiao K with a smile. “Ah, Xiao K, long time no see. I remember the last time we met, it was in that small tavern. Back then, I chatted with you happily and talked about the world. Who would have thought we would end up like this today!” Xiao L paused and continued, “You used to be my brother. I do not want to end things between us with violence. Luckily, I have a good idea: how about we settle this with a game? What do you say, Xiao K?” Xiao K knew he had no room to refuse Xiao L, so he nodded. Seeing that, Xiao L smiled again and began to explain the rules of the game.\n\n“As you can see, our game will be played on this shooting range. The range has a total of $n$ rows and $m$ columns, i.e. $n\\times m$ targets. For convenience, let the row direction be left to right, and the column direction be front to back. This shooting range has a special feature: each target has a counter. If you hit a target, the displayed value of its counter increases by one. However, each counter value has a range: it can only be an integer not less than $0$ and not greater than $k$. If you hit a target when its counter value is already $k$ before the hit, then upon being hit, its counter overflows, resets to $0$, and emits an overflow error signal that starts to travel along wires. Due to the special wiring of the range, the signal only travels to the right. During the transmission, it affects some other counters in the same row. If an affected counter has value $k$, it will also overflow, reset to $0$, and emit an overflow error signal, which stacks with the previous signal (but the $+1$ effect does not stack). Otherwise, its value increases by one, and it sends a correction message that cuts off the signal propagation, meaning targets to its right will no longer be affected. Of course, if the signal keeps traveling without being cut off, it will eventually reach the information management terminal. Because signals keep stacking during transmission, and because the terminal has to process huge amounts of information, its ability to correct error signals is weak; this may cause the terminal to crash or even explode, which is against the rules.\n\n“You and I will take turns choosing one target to shoot once. The shooter decides which target to shoot. If it is someone’s turn to shoot but they cannot make a shot without breaking the rules, then they lose. Since I designed this game, I will go first. However, I will also give you some choices. The initial value of each target’s counter is not necessarily $0$; I can set it. I happen to have several setting plans, but I do not know which one to choose. Could you help me pick one?”\n\nXiao L took a few slips of paper out of his pocket. Xiao K looked and found that each slip did not list the initial values of all counters; it only had three numbers $a,b,c$. What Xiao L did not know was that Xiao K had amazing observation skills. While Xiao L was speaking, Xiao K had already analyzed how the displayed values changed and how the circuit was wired, and figured out the rule used to generate the initial counter values. The initial values of the counters are generated one by one in order. The order is row-major: from left to right, from top to bottom. Specifically, they are generated in the order of row $1$ column $1,2,\\ldots,m$, then row $2$ column $1,2,\\ldots,m$, ..., up to row $n$ column $1,2,\\ldots,m$. Generating one counter value uses $a,b,c$ as parameters, and after each generation, $a,b,c$ all change. Concretely, for each generated counter value, the following function is called once:\n\n```\ntypedef unsigned long long ull; \ninline ull generate(ull&a,ull&b,ull&c,ull&k)\n{ \n\ta<<=19;a+=b+c;\n\ta<<=26;a^=c+=a+81;b--;\n\ta<<=7;a>>=(b^c^1145)&14;\n\tc*=a;a|=b+=c;a^=b&c;\n\treturn a%(k+1);\n}\n```\n\nThe return value of the function is the generated counter value. It is easy to see that all initial values are integers between $0$ and $k$, so they do not violate the rules.\n\nXiao K knows Xiao L is extremely smart and will surely aim to win. Of course, since Xiao K also knows a lot about this game, his skill will not be worse than Xiao L’s. Xiao K cannot break the rules made by Xiao L, or he might anger Xiao L and cause the conflict to break out again. However, Xiao K can compute which of Xiao L’s plans guarantee a win for Xiao L, and which guarantee a win for himself, and then choose a plan where he is guaranteed to win.\n\nUnfortunately, time does not allow Xiao K to compute for too long. Luckily, you can program and help Xiao K get the result in a short time. Please help Xiao K determine, among all the plans Xiao L provides, which ones make Xiao L sure to win and which ones make Xiao L sure to lose.\n\n-----------------------\n\nSince what Xiao L said may be too long to understand, Xiao K decides to describe the problem more concisely. Xiao L provides a number matrix with $n$ rows and $m$ columns. Xiao L and Xiao K take turns operating. Each time, one number in the matrix can be increased by $1$. If after adding $1$ this number becomes greater than $k$, then it is reset to zero, and the $+1$ operation is passed to the number on its right. If a number needs to pass the operation but there is no number to its right, then the current player’s initial operation is not allowed. The player who cannot make a move loses. Xiao L moves first, and both players are extremely smart. If Xiao L will win, output `YES`; otherwise output `NO`.\n\nThe initial numbers in the matrix are provided by Xiao L. Xiao L provides several plans to fill the matrix; in each plan, the numbers in the matrix are generated by the function above, in order from left to right and from top to bottom. The difference between plans lies in different parameters $a,b,c$. **It is guaranteed that the generation method is irrelevant to the correct solution of this problem.** Note that for each plan, Xiao L actually provides six parameters $k,n,m,a,b,c$, meaning $k,n,m$ may also differ between plans.", "inputFormat": "The first line contains the total number of plans provided by Xiao L.\n\nFor each plan, six parameters are given in order: $k,n,m,a,b,c$, with meanings as described in the statement.", "outputFormat": "For each plan, if Xiao L will win, output `YES`; otherwise output `NO`.", "hint": "[Sample Explanation]\n\nIn both plans, there is only one target in the shooting range.\n\nFor plan 1, the initial value on this target’s counter is $0$. Xiao L, as the first player, shoots this target and makes its counter increase by $1$. When it is Xiao K’s turn, the counter value is $1$, and there is no legal shot, so Xiao K loses and Xiao L wins.\n\nFor plan 2, the initial value on this target’s counter is $1$, and there is no legal shot, so Xiao L loses.\n\n[Constraints]\n\nAt most $20$ plans.\n\n| Test ID | Range of $n$ | Range of $m$ | Range of $k$ | Special Property |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $n=1$ | $1\\le m\\le5$ | $1\\le k\\le 5$ | None |\n| $2$ | $n=1$ | $1\\le m\\le20$ | $1\\le k\\le 5$ | None |\n| $3$ | $n=1$ | $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | None |\n| $4$ | $1\\le n \\le2$ | $1\\le m\\le100000$ |$1\\le k\\le 10^{18}$  | None |\n| $5$ | $1\\le n \\le100000$ | $m=1$ | $1\\le k\\le 10^{18}$ | None |\n| $6$ | $1\\le n \\le1000$ | $1\\le m\\le1000$ | $1\\le k\\le 10^{18}$ | $k$ is even |\n| $7$ | $1\\le n \\le50000$ | $1\\le m\\le20$ | $1\\le k\\le 10^{18}$ | $k$ is even |\n| $8$ | $1\\le n \\le10$ | $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | $k$ is even |\n| $9\\sim 11$ | $1\\le n \\le1000$ |$1\\le m\\le1000$  | $1\\le k\\le 10^{18}$ | None |\n| $12\\sim 14$ | $1\\le n \\le50000$ | $1\\le m\\le20$ | $1\\le k\\le 10^{18}$ | None |\n| $15\\sim 17$ | $1\\le n \\le10$| $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | None |\n\nFor all testdata, $k,n,m,a,b,c$ are positive integers, and $1\\le a,b,c\\le10^{18}$. The score distribution is as follows: test ID $1$ is worth $7$ points; test IDs $9$, $12$, and $15$ are worth $5$ points; all others are worth $6$ points.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【L&K R-03】射击场决战", "background": "", "description": "【如果不想看题面请阅读分割线以下部分】\n\n小 L 与小 K 是两个帮派的首领，也是死敌。某年某月，两个帮派发生了大规模的冲突。小 K 因为实力不敌，被小 L 的爪牙团团包围，最终被逼近了一个大型射击场。小 K 自知大势已去，正准备与小 L 拼死一战时，却传来消息，说小 L 要邀请自己与他来玩一场游戏。小 K 知道其中有鬼，但却别无它计，只能只身前往小 L 指定的会面点。\n\n会面点在射击场旁。小 L 站在场上，满脸笑容地对走来的小 K 招手。“啊，小 K ，好久不见。我记得上次我们见面的时候，还是在那个小酒馆。当时，我与你谈笑风生，指点江山，不亦乐乎。没想到，如今，我们竟到此地步啊！”小 L 顿了顿，继续说道：“你是我曾经的兄弟，我不想以暴力的方式了解你我。正好，我有一个好方法：不如我们用游戏的方式来场决战吧！这样如何，小 K ？”小 K 知道，自己并没有否定小 L 的余地。于是，小 K 点了点头。小 L 看到小 K 点头，又露出了笑容，开始讲起了游戏的规则。\n\n“如你所见，我们的游戏要在这片射击场上进行。射击场总共有 $n$ 行 $m$  列，共 $n\\times m$ 个靶。为了方便，取行的方向为左右，列的方向为前后。这个射击场有一个特点：每个靶上都有一个计数器。击中一个靶，这个靶的计数器示数就会加一。但是，每个靶的示数有一个范围，只能是不小于 $0$，不大于 $k$ 的整数。倘若击中一个靶，而在未击中此靶前此靶计数器的示数已经为 $k$，那么击中时，此靶计数器示数就会溢出清 $0$，并产生溢出错误的信号，经电线开始传递。由于靶场电线的特殊布置，信号只会往右侧传递。信号传递过程中会影响若干其它同行靶的计数器。如果这些被影响到的靶计数器示数为 $k$，其同样会溢出清 $0$ 并产生溢出错误信号，与之前的信号叠加（但加一效果不会叠加）；否则，其示数会加一，并发出纠正讯息，截断信号传播，即在其右侧的靶不会继续被信号影响。当然，如果信号一直传递而未被截断，那么它最终会传入信息管理终端。由于信号在传递过程中不断叠加，再加之信息管理终端要处理庞大的信息，纠正错误信号的能力较差，可能会导致终端死机甚至发生爆炸的危险，这是违规的。\n\n“我与你会轮流选择其中一个靶进行一次射击，射击哪个靶由射击者自行决定。如果轮到某个人射击，但他无法进行不违规的射击，那么他就输了。因为这是我设计的游戏，先手当然是我。但是，我也会给你一些选择。靶场上每个靶计数器的初始示数不一定为 $0$，是可以被我设置的。我这里恰好有几种设置方案，但我不知道该选哪种好，可否请你帮我选一选？”\n\n小 L 从口袋里抽出了几张纸条。小 K 一看，每张纸条却没有写每个靶计数器的初始示数，只写着三个数字 $a,b,c$。小 L 所不知道的是，小 K 有着惊人的观察能力，在小 L 讲刚才那一番话之时，小 K 就已经通过分析靶上示数的变化以及电路的布置，得出了计数器初始示数生成的规律。靶场上靶的计数器初始示数是一个个按顺序生成的。并且，生成的顺序是按行优先，从左到右，从上到下。具体来说，是按照第 $1$ 行第 $1,2,\\ldots ,m$ 个，第 $2$ 行第 $1,2,\\ldots ,m$ 个，……，第 $n$ 行第 $1,2,\\ldots ,m$ 个的顺序生成。生成一个计数器的示数需要用到 $a,b,c$ 作为参数。并且，每生成一个计数器的示数，$a,b,c$ 都会产生变化。具体来说，每生成一个计数器的示数，便引用一次以下的函数：\n\n```\ntypedef unsigned long long ull; \ninline ull generate(ull&a,ull&b,ull&c,ull&k)\n{ \n\ta<<=19;a+=b+c;\n\ta<<=26;a^=c+=a+81;b--;\n\ta<<=7;a>>=(b^c^1145)&14;\n\tc*=a;a|=b+=c;a^=b&c;\n\treturn a%(k+1);\n}\n```\n\n函数的返回值即为生成的计数器示数。容易发现，初始示数均为不小于 $0$，不大于 $k$ 的整数，不违反规则。\n\n小 K 知道小 L 是绝顶聪明的人，且一定会以自己的胜利为目标进行游戏。当然，小 K 因为掌握了许多这个游戏的信息，水平不会落后于小 L。小 K 不能违反小 L 制定的规则，否则可能惹恼小 L，使冲突再次爆发。但是，小 K 可以通过计算，得出小 L 给出的方案中哪些是小 L 必胜，哪些是自己必胜的，并选择一个自己必胜的方案进行游戏。\n\n可惜时间不允许小 K 做太长时间的计算。恰好，会编程的你可以帮助小 K 在较短的时间内得出结果。请你帮小 K 算算，在小 L 给出的所有方案中，哪些小 L 必胜，哪些小 L 必败。\n\n-----------------------\n\n考虑到小 L 说的话可能太长以至于难以理解，小 K 决定更为简洁地叙述这个问题。小 L 提供了一个 $n$ 行 $m$ 列的数阵。小 L 与小 K 二人轮流操作，每次可以将数阵中的某个数加上 $1$。若加 $1$ 后此数大于 $k$，则此数清零，将加 $1$ 操作传递给其右侧的数。若某个数需要传递操作，但其右侧没有数，则这个操作对应的人的初始操作将不可进行。最后无法操作的人败。小 L 为先手，二人都绝顶聪明。若小 L 会赢则输出 `YES`，否则输出 `NO`。\n\n数阵里初始的数由小 L 提供。小 L 提供了若干个填充数阵的方案，每个方案中数阵里的数由上文的函数生成，生成顺序从左到右，从上到下。方案的互异性体现在参数 $a,b,c$ 的不同。请你对每种方案给出答案。 **保证生成方式与题目的正确解法无关。** 注意对于每种方案，小 L 实际上提供了六个参数 $k,n,m,a,b,c$，即 $k,n,m$ 在每种方案中也可能各不相同。", "inputFormat": "第一行为小 L 给出方案总数。\n\n对于每种方案，按顺序给出六个参数：$k,n,m,a,b,c$，其意义如题所示。", "outputFormat": "对于每种方案，如果小 L 会赢，输出 `YES`，否则输出 `NO`。", "hint": "【样例解释】\n\n两种方案中射击场上都只有一个靶。\n\n对于方案一，此靶计数器上的初始数值为 $0$。小 L 先手射击此靶使其计数器加 $1$。轮到小 K 时，计数器示数为 $1$，不存在不违规射击方案，小 K 输，小 L 赢。\n\n对于方案二，此靶计数器上的初始数值为 $1$，不存在不违规射击方案，小 L 输。\n\n【数据范围】\n\n最多 $20$ 种方案。\n\n| 数据编号 | $n$ 的范围 | $m$ 的范围 | $k$ 的范围 | 特殊性质 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $n=1$ | $1\\le m\\le5$ | $1\\le k\\le 5$ | 无 |\n| $2$ | $n=1$ | $1\\le m\\le20$ | $1\\le k\\le 5$ | 无 |\n| $3$ | $n=1$ | $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | 无 |\n| $4$ | $1\\le n \\le2$ | $1\\le m\\le100000$ |$1\\le k\\le 10^{18}$  | 无 |\n| $5$ | $1\\le n \\le100000$ | $m=1$ | $1\\le k\\le 10^{18}$ | 无 |\n| $6$ | $1\\le n \\le1000$ | $1\\le m\\le1000$ | $1\\le k\\le 10^{18}$ | $k$为偶数 |\n| $7$ | $1\\le n \\le50000$ | $1\\le m\\le20$ | $1\\le k\\le 10^{18}$ | $k$为偶数 |\n| $8$ | $1\\le n \\le10$ | $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | $k$为偶数 |\n| $9\\sim 11$ | $1\\le n \\le1000$ |$1\\le m\\le1000$  | $1\\le k\\le 10^{18}$ | 无 |\n| $12\\sim 14$ | $1\\le n \\le50000$ | $1\\le m\\le20$ | $1\\le k\\le 10^{18}$ | 无 |\n| $15\\sim 17$ | $1\\le n \\le10$| $1\\le m\\le100000$ | $1\\le k\\le 10^{18}$ | 无 |\n\n对于所有数据，$k,n,m,a,b,c$ 均为正整数，$1\\le a,b,c\\le10^{18}$。各数据点分值分布如下：编号为 $1$ 的数据点分值为 $7$；编号为 $9$、$12$、$15$ 的数据点分值为 $5$；其余数据点分值为 $6$。", "locale": "zh-CN"}}}
{"pid": "P5821", "type": "P", "difficulty": 6, "samples": [["8 5 3\niamangry\nanger\n1 4\n2 2 m\n1 2", "218\n238"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "洛谷原创"], "title": "【L&K R-03】密码串匹配", "background": "众所周知，小 L 很喜欢用 $123321$ 做密码。每次登陆 Codeforces，都会看见显眼的一行提示：\n\n```text\nYour password is extremely weak or has been leaked . Please, change it ASAP. \n(see https://haveibeenpwned.com/)\n```", "description": "在被机惨之后，小 L 痛定思痛，决定使用更安全的密码。小 L 设计出了一个可能长达 $200,000$ 位的仅由小写字母构成的密码，并保证没有人能记住，猜出或试出（包括小 L 自己）。\n\n为了防止自己忘记整串密码（不用防止了，已经忘记了），小 L 编写了一个程序，可以存储小 L 的密码串 $T$，但是不能直接输出（因为这个程序可能会被他人使用），小 L 第一次会根据记忆还原出长度为 $l$ 的一个字符串 $P$，后面会根据程序的输出修改 $P$ 的某一位，这个程序可以求出当前猜测串 $P$ 与密码串 $T$ 的相同长度的字串的 **失配度** 。\n\n定义字符 `a` 的值为 $1$，字符 `b` 的值为 $2$，以此类推，字符 `z` 的值为 $26$。定义两个字符串 $s,t$ 的失配度为对应位置上的值相减后的平方。\n\n现在，小 L 想知道他的程序是否正确，请你也编写一个类似的程序。", "inputFormat": "输入的第一行为三个数 $n,l,m$，分别表示密码串 $T$ 的长度 $n$，猜测串 $P$ 的长度 $l$，和操作次数 $m$。\n\n接下来的两行有两个字符串，分别为 $T$ 和 $P$。\n\n接下来的 $m$ 行，每行的第一个整数为 $op$，表示操作的类型：\n\n若 $op=1$，接下来有一个整数 $x$，表示要求 $P$ 和从 $T$ 的第 $x$ 位开始长度为 $l$ 的字串的失配度；\n\n若 $op=2$，接下来有一个整数 $x$ 和一个字符 $c$，表示修改 $P$ 的第 $x$ 位，使其等于 $c$。", "outputFormat": "对于每个 $1$ 操作，输出一行，为所求值。", "hint": "**请注意本题特殊的时间限制。**\n\n**本题数据规模大，请注意常数优化。**\n\n为了防止题目过于卡常，本题 **提供 [八聚氧](https://www.luogu.com.cn/paste/ky1fh8zk)** ，直接加在代码最前提交即可。\n\n本题中所有编号从 $1$ 开始。\n\n- Subtask \\#1：$30$ 分，保证 $n,m\\le 5\\times 10^3$；\n- Subtask \\#2：$30$ 分，保证没有 $2$ 操作；\n- Subtask \\#3：$40$ 分，保证 $n,m\\le 2\\times 10^5$。\n\n对于 $100\\%$ 的数据，保证 $1\\le l\\le n,1\\le x$。\n\n对于所有 $1$ 操作，保证 $x-1+l\\le n$。\n\n对于所有 $2$ 操作，保证 $x\\le l$。\n\n### 样例解释\n\n$(a-a)^2+(n-n)^2+(g-g)^2+(r-e)^2+(y-r)^2=13^2+7^2=218$。\n\n$(a-a)^2+(m-m)^2+(a-g)^2+(n-e)^2+(g-r)^2=6^2+9^2+11^2=238$。", "locale": "zh-CN", "translations": {"en": {"title": "[L&K R-03] Password String Matching", "background": "As everyone knows, Little L really likes to use $123321$ as a password. Every time he logs in to Codeforces, he sees a very eye-catching message:\n\n```text\nYour password is extremely weak or has been leaked . Please, change it ASAP. \n(see https://haveibeenpwned.com/)\n```", "description": "After getting destroyed by the judge, Little L reflected and decided to use a safer password. Little L designed a password that may be as long as $200{,}000$ characters and consists only of lowercase letters, and he guarantees that nobody can remember it, guess it, or brute-force it (including Little L himself).\n\nTo avoid forgetting the whole password string (no need to avoid it; he has already forgotten it), Little L wrote a program that can store his password string $T$, but cannot output it directly (because others might use this program). The first time, Little L reconstructs a string $P$ of length $l$ from memory. Later, he will modify one character of $P$ based on the program’s output. This program can compute the **mismatch degree** between the current guess string $P$ and the substring of $T$ with the same length.\n\nDefine the value of character `a` as $1$, character `b` as $2$, and so on, up to character `z` as $26$. Define the mismatch degree of two strings $s,t$ as the sum of the squares of the differences of their values at corresponding positions.\n\nNow, Little L wants to know whether his program is correct. Please write a similar program as well.", "inputFormat": "The first line contains three integers $n,l,m$, representing the length $n$ of the password string $T$, the length $l$ of the guess string $P$, and the number of operations $m$.\n\nThe next two lines contain two strings, which are $T$ and $P$.\n\nThe next $m$ lines each start with an integer $op$, indicating the type of operation:\n\n- If $op=1$, then an integer $x$ follows, meaning you need to query the mismatch degree between $P$ and the substring of $T$ of length $l$ starting from position $x$.\n- If $op=2$, then an integer $x$ and a character $c$ follow, meaning you modify the $x$-th character of $P$ to make it equal to $c$.", "outputFormat": "For each operation of type $1$, output one line containing the required value.", "hint": "**Please note the special time limit of this problem.**\n\n**The data size is large, so please optimize constants carefully.**\n\nTo prevent the problem from being too strict on runtime, this problem **provides [Bajuyang](https://www.luogu.com.cn/paste/ky1fh8zk)**. You can paste it directly at the very beginning of your code and submit.\n\nIn this problem, all indices start from $1$.\n\n- Subtask \\#1: $30$ points, guaranteed $n,m\\le 5\\times 10^3$.\n- Subtask \\#2: $30$ points, guaranteed there is no operation type $2$.\n- Subtask \\#3: $40$ points, guaranteed $n,m\\le 2\\times 10^5$.\n\nFor $100\\%$ of the testdata, it is guaranteed that $1\\le l\\le n$ and $1\\le x$.\n\nFor all operations of type $1$, it is guaranteed that $x-1+l\\le n$.\n\nFor all operations of type $2$, it is guaranteed that $x\\le l$.\n\n### Sample Explanation\n\n$(a-a)^2+(n-n)^2+(g-g)^2+(r-e)^2+(y-r)^2=13^2+7^2=218$.\n\n$(a-a)^2+(m-m)^2+(a-g)^2+(n-e)^2+(g-r)^2=6^2+9^2+11^2=238$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【L&K R-03】密码串匹配", "background": "众所周知，小 L 很喜欢用 $123321$ 做密码。每次登陆 Codeforces，都会看见显眼的一行提示：\n\n```text\nYour password is extremely weak or has been leaked . Please, change it ASAP. \n(see https://haveibeenpwned.com/)\n```", "description": "在被机惨之后，小 L 痛定思痛，决定使用更安全的密码。小 L 设计出了一个可能长达 $200,000$ 位的仅由小写字母构成的密码，并保证没有人能记住，猜出或试出（包括小 L 自己）。\n\n为了防止自己忘记整串密码（不用防止了，已经忘记了），小 L 编写了一个程序，可以存储小 L 的密码串 $T$，但是不能直接输出（因为这个程序可能会被他人使用），小 L 第一次会根据记忆还原出长度为 $l$ 的一个字符串 $P$，后面会根据程序的输出修改 $P$ 的某一位，这个程序可以求出当前猜测串 $P$ 与密码串 $T$ 的相同长度的字串的 **失配度** 。\n\n定义字符 `a` 的值为 $1$，字符 `b` 的值为 $2$，以此类推，字符 `z` 的值为 $26$。定义两个字符串 $s,t$ 的失配度为对应位置上的值相减后的平方。\n\n现在，小 L 想知道他的程序是否正确，请你也编写一个类似的程序。", "inputFormat": "输入的第一行为三个数 $n,l,m$，分别表示密码串 $T$ 的长度 $n$，猜测串 $P$ 的长度 $l$，和操作次数 $m$。\n\n接下来的两行有两个字符串，分别为 $T$ 和 $P$。\n\n接下来的 $m$ 行，每行的第一个整数为 $op$，表示操作的类型：\n\n若 $op=1$，接下来有一个整数 $x$，表示要求 $P$ 和从 $T$ 的第 $x$ 位开始长度为 $l$ 的字串的失配度；\n\n若 $op=2$，接下来有一个整数 $x$ 和一个字符 $c$，表示修改 $P$ 的第 $x$ 位，使其等于 $c$。", "outputFormat": "对于每个 $1$ 操作，输出一行，为所求值。", "hint": "**请注意本题特殊的时间限制。**\n\n**本题数据规模大，请注意常数优化。**\n\n为了防止题目过于卡常，本题 **提供 [八聚氧](https://www.luogu.com.cn/paste/ky1fh8zk)** ，直接加在代码最前提交即可。\n\n本题中所有编号从 $1$ 开始。\n\n- Subtask \\#1：$30$ 分，保证 $n,m\\le 5\\times 10^3$；\n- Subtask \\#2：$30$ 分，保证没有 $2$ 操作；\n- Subtask \\#3：$40$ 分，保证 $n,m\\le 2\\times 10^5$。\n\n对于 $100\\%$ 的数据，保证 $1\\le l\\le n,1\\le x$。\n\n对于所有 $1$ 操作，保证 $x-1+l\\le n$。\n\n对于所有 $2$ 操作，保证 $x\\le l$。\n\n### 样例解释\n\n$(a-a)^2+(n-n)^2+(g-g)^2+(r-e)^2+(y-r)^2=13^2+7^2=218$。\n\n$(a-a)^2+(m-m)^2+(a-g)^2+(n-e)^2+(g-r)^2=6^2+9^2+11^2=238$。", "locale": "zh-CN"}}}
{"pid": "P5822", "type": "P", "difficulty": 7, "samples": [["3 3 1 1 2\n100 200 300\n1 1 50\n1 2 2\n2 3 1", "545/2\n349\n300"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}, "tags": ["2019", "洛谷原创"], "title": "【L&K R-03】大航海时代", "background": "", "description": "【如果不想看题面请阅读分割线以下部分】\n\n$$\\text{Onde\\space a\\space terra\\space acaba\\space e\\space o\\space mar\\space começa}$$\n\n>_15 世纪末，是一个伟大时代的开始。自此之后，人们开始逐渐认识到大千世界的险恶与奇丽，开始前仆后继地展开一个又一个不可思议的冒险，开始缓缓地驾驭那波涛汹涌、变幻莫测的大海。_\n\n>_15 世纪末，是一个伟大时代的开始。为了征服海洋，人们集人类之智慧，制造出方舟巨轮；汇天地之灵怪，制造出罗盘、六分仪。海上的康庄大道从此建立，人们航行于各地，商贸随之诞生。_\n\n>_15 世纪末，是一个伟大时代的开始。商品与金钱象征着欲望，在海上流动了起来。原先分隔的黄金汇聚成大金库，让人们尝到了商业的甜头。贸易的花朵开遍整个欧洲，航线上船只往来不绝，财富源源不断地从海上涌出。_\n\n>_[更多](https://www.luogu.org/paste/k9bqwpps)_\n\n>……\n\n>_大航海时代，是人类文明崭新的起点。_\n\n海上经商，商人们必须对航路有充分的了解。欧洲的城市不计其数，航路更是数不胜数。当然，人们无需知晓所有城市的位置，更无需清楚所有航路的情况。人们只需要知道，有几个主要城市，并且有几条海上航路连接着它们即可，其他的城市与航路都是次要的，不会带来过多收益。\n\n商船沿着航路往来于城市之间。它们每到一个城市，卸下一些货品，城市里的商人便会根据货品的数目给出相应的报酬。这些报酬由船主收取，并将部分报酬分发给水手们。不过大家并不关心这件事，他们只会关心一艘船获得的总收益。\n\n商船的航行总会伴随着危险与损失。海上的天气难以预测，船只随时都可能会被大浪吞没，或者被飓风刮得千疮百孔。不过这些情况比较特殊，我们并不考虑。我们考虑的是，商船在航行过程中的必要支出。一趟航行往往需要几星期甚至几个月的时间。在这段时间里，船员需要淡水与食物，船也需要适当的维护。人们总结经验发现，一段航行的必要支出与航行距离和载货量有直接关系。\n\n大航海时代的人们就是在这些规律下生活的，考量着商船的支出与收益，缓行于茫茫大海之上，每日如此，单调而无趣。大航海时代，对于大部分人来说，或许并没有那么伟大。\n\n当然，生于现代的我们不必在意这些东西。这也是当然的，现代人怎么会为古代人考虑什么东西呢？\n\n然而，小 L 和小 K 发现他们必须开始考虑这些事物了，因为他们不小心掉进了虫洞，回到了大航海时代。回到过去的他们用唯一的财产：手机，换来了一艘船和一船货物。为了生存，他们要驾驶着这艘船航行于海上，用货物与商人们换取钱财。\n\n----------------------------------\n\n小 L 和小 K 通过调查了解了海上贸易的一些基本规律。共有 $n$ 个主要城市和 $m$ 条连接着它们的航道，船只能沿着这些航道航行。注意航道是单向的，因为如果是双向，航线就容易交叉，发生事故。第 $i$ 条航道的距离为 $dis_i$，若商船在经过此航道时载货量（下称货物量）为 $p$，则航行完此航道需花费 $p\\times dis_i$  的金币。商船到达一个城市，会卸下部分货物与商人交易。每座城市都有一个大商人，会根据 **船上卸下** 的货物量付给商船一定的金币。每座城市的大商人不同，标准也不一样。第 $i$ 座城市的大商人标准为 $mea_i$，若商船在 $i$ 号城市卸下量为 $p$ 的商品，大商人会付给商船 $p\\times mea_i$ 的金币。商船每到达一座城市，只会与大商人进行一次交易。当然，一座城市可以重复到达，每次到达都会与大商人进行交易。\n\n小 L 和小 K 需要遵循这些规律，沿着航道进行海上贸易。小 L 和小 K 在一开始总共有量为 $q$ 的货品。小 L 和小 K 本该精打细算，详细计算出他们在每座城市应该卸下的货物量。但是小 L 和小 K 是懒癌晚期患者，并不想这样做。他们随便想了两个正整数 $s,t$，于是如果需要卸下货物，他们便会卸下总货物量 $\\frac{s}{s+t}$ 的货物。\n\n在他们的商贸之旅开始之前，小 L 和小 K 就已经研究出了回到现代的方法。但是他们并不着急回去。因为回溯时间导致的时空错位，小 L 和小 K 身上的时间是静止的。也就是说他们拥有无限的时间。他们决定利用此原理在这个时代大赚一笔。小 L 和小 K 可以选择从任意一座城市出发。他们希望知道从每座城市出发，可以赚到的最大金币数量是多少。当然因为他们比较懒，这个问题由你来解决。\n\n需要注意的是，尽管在大航海时代分数的运算并没有普及，但小 L 和小 K 为了自己方便而将他们得到的信息部分用分数（有理数）来表示。也就是说，虽然 $dis_i,mea_i,q$ 是由当时的人们给出的，所以是整数，但是货物量和金币量可以是分数，即小 L 和小 K 用有理数的计算法则计算自己的收益。小 L 和小 K 在出发的城市也会进行交易。", "inputFormat": "第一行，五个正整数 $n,m,s,t,q$。\n\n第二行， $n$ 个正整数，第 $i$ 个数表示 $mea_i$。\n\n接下来 $m$ 行，每行三个正整数 $a,b,dis_i$，表示从城市 $a$ 到城市 $b$ 有一条长为 $dis_i$ 的单向航道。", "outputFormat": "共 $n$ 行，第 $i$ 行表示从 $i$ 号城市出发可以赚到的最大金币数量，输出格式见下文。\n\n关于分数的输出格式：\n\n可能以 ```a/b``` 的形式输出，表示分数 $\\frac{a}{b}$，其中 $a,b$ 为正整数。也可能以 ```-a/b``` 的形式输出，表示分数 $-\\frac{a}{b}$，其中 $a,b$ 为正整数。也可能以 ```a``` 的形式输出，表示**整数** $a$。注意 $\\gcd(a,b)$ 一定为 $1$。如果 $b$ 为 $1$，则必须以 ```a``` 的形式输出。", "hint": "【样例说明】\n\n$\\frac{s}{s+t}=\\frac{1}{2}$，小 L 和小 K 每次会卸下一半的货物进行交易。\n\n从 $1$ 号城市出发：先在 $1$ 号城市进行交易，用 $2\\times\\frac{1}{2}=1$ 的货物量交易，获得金币 $1\\times 100=100$，剩余货物量 $2-1=1$。之后如果走 $1\\rightarrow1$ 的航道，会再花费 $1\\times 50=50$ 的金币回到城市 $1$，很不划算。如果走 $1\\rightarrow2$ 的航道，只需要再花费 $1\\times 2=2$ 的金币就可以到达城市 $2$。到达城市 $2$ 进行交易，用 $1\\times\\frac{1}{2}=\\frac{1}{2}$ 的货物量交易，获得金币 $\\frac{1}{2}\\times 200=100$，剩余货物量 $1-\\frac{1}{2}=\\frac{1}{2}$。接下来走 $2\\rightarrow3$，花费 $\\frac{1}{2}\\times1=\\frac{1}{2}$ 的金币。到达城市 $3$，用 $\\frac{1}{2}\\times\\frac{1}{2}=\\frac{1}{4}$的货物量交易，交易获得金币 $\\frac{1}{4}\\times300=75$，剩余货物量 $\\frac{1}{2}-\\frac{1}{4}=\\frac{1}{4}$。总获利 $100-2+100-\\frac{1}{2}+75=\\frac{545}{2}$。\n\n从 $2$ 号城市出发：走 $2\\rightarrow3$，在 $2,3$ 号城市交易，获利 $200-1+150=349$。\n\n从 $3$ 号城市出发：在 $3$ 号城市交易，获利 $300$。\n\n【数据范围】\n\n对于 $10\\%$ 的数据，$n\\le 3,m\\le 9$，$s,t,q,mea_i,dis_i\\le10$。\n\n对于 $50\\%$ 的数据，$n\\le 10,m\\le 100$，$s,t,q,mea_i,dis_i\\le10$。\n\n对于另外 $10\\%$ 数据，$m=n$，且对于任意正整数 $i\\in[1,n]$，编号为 $i$ 的城市有一条到编号为 $(i\\mod n)+1$ 的城市的航道。\n\n对于另外 $10\\%$ 数据，对于任意正整数 $i\\in[1,n]$，若存在航道 \n $i\\rightarrow j$，则 $j>i$。\n\n对于 $100\\%$ 的数据，$n\\le 50,m\\le 500$，$s,t,q,mea_i,dis_i\\le10^4$。\n\n【补充说明】\n\n城市从 $1$ 到 $n$ 编号。\n\n请注意本题特殊的时空限制。\n\n为了防止题目过于卡常，本题 **提供 [八聚氧](https://www.luogu.com.cn/paste/ky1fh8zk)** ，直接加在代码最前提交即可。保证标程在加上八聚氧后通过每个数据点的最大用时小于时限的一半。请大胆尝试解法。", "locale": "zh-CN", "translations": {"en": {"title": "[L&K R-03] Age of Discovery", "background": "", "description": "[If you do not want to read the full statement, please read the part below the divider.]\n\n$$\\text{Onde\\space a\\space terra\\space acaba\\space e\\space o\\space mar\\space começa}$$\n\n>_At the end of the 15th century, a great era began. From then on, people gradually came to know the dangers and wonders of the world, started one incredible adventure after another, and slowly learned to navigate the rough and unpredictable sea._\n\n>_At the end of the 15th century, a great era began. To conquer the ocean, people gathered human wisdom to build giant ships; and drew on the mysteries of nature to create the compass and the sextant. From then on, smooth sea routes were established. People sailed to various places, and trade was born._\n\n>_At the end of the 15th century, a great era began. Goods and money, symbols of desire, began to flow across the sea. Gold that was once separated gathered into great vaults, letting people taste the sweetness of business. The flowers of trade bloomed all over Europe, ships traveled endlessly along routes, and wealth poured out from the sea._\n\n>_[More](https://www.luogu.org/paste/k9bqwpps)_\n\n>……\n\n>_The Age of Discovery was a brand-new starting point for human civilization._\n\nTo do business at sea, merchants must fully understand the routes. There are countless cities in Europe, and even more routes. Of course, people do not need to know the locations of all cities, nor the details of all routes. They only need to know that there are several major cities and several sea routes connecting them. Other cities and routes are secondary and will not bring much profit.\n\nMerchant ships travel between cities along routes. Each time a ship arrives at a city, it unloads some goods, and the merchants in the city pay a corresponding reward based on the amount of goods. The ship owner collects this reward and distributes part of it to the sailors. But nobody cares about that; they only care about the total profit a ship earns.\n\nSailing always comes with danger and loss. The weather at sea is hard to predict; ships may be swallowed by huge waves or torn apart by hurricanes. However, these are special cases and we will not consider them. What we consider is the necessary expenses during sailing. A voyage often takes weeks or even months. During this time, the crew needs fresh water and food, and the ship needs maintenance. From experience, people found that the necessary cost of a voyage is directly related to the sailing distance and the amount of cargo.\n\nPeople in the Age of Discovery lived under these rules, weighing a ship’s expenses and income, moving slowly across the vast sea day after day—monotonous and boring. For most people, the Age of Discovery might not have been that great.\n\nOf course, we who live in modern times do not need to care about these things. Naturally, why would modern people think about such things for ancient people?\n\nHowever, Little L and Little K found that they had to start caring about them, because they accidentally fell into a wormhole and returned to the Age of Discovery. After returning to the past, they traded their only property—a mobile phone—for a ship and a shipload of goods. To survive, they must sail this ship on the sea and exchange goods with merchants for money.\n\n----------------------------------\n\nLittle L and Little K investigated and learned some basic rules of maritime trade. There are $n$ major cities and $m$ sea routes connecting them, and ships can only sail along these routes. Note that routes are directed, because if they were bidirectional, routes would easily cross and accidents would happen. The distance of the $i$-th route is $dis_i$. If the cargo load (hereinafter called the amount of goods) is $p$ when the ship travels along this route, then completing this route costs $p\\times dis_i$ gold coins.\n\nWhen the ship arrives at a city, it unloads part of the goods to trade. Each city has a “big merchant”, who pays the ship a certain amount of gold coins based on the amount of goods **unloaded from the ship**. Big merchants differ from city to city, and so do their standards. The standard of the big merchant in city $i$ is $mea_i$. If the ship unloads $p$ goods in city $i$, the big merchant pays $p\\times mea_i$ gold coins. Each time the ship arrives at a city, it trades with the big merchant exactly once. Of course, a city may be visited repeatedly, and each visit triggers a trade with the big merchant.\n\nLittle L and Little K must follow these rules and conduct maritime trade along the routes. Initially, Little L and Little K have a total amount of goods $q$. They should have planned carefully and computed exactly how much to unload in each city. But they are extremely lazy and do not want to do that. They randomly chose two positive integers $s,t$. Therefore, whenever they need to unload goods, they will unload $\\frac{s}{s+t}$ of the total goods currently on the ship.\n\nBefore their trading journey began, Little L and Little K had already figured out how to return to modern times. But they were not in a hurry to go back. Due to time-space misalignment caused by traveling back in time, time is frozen for them. That is, they have unlimited time. They decided to use this principle to make a fortune in this era. They may choose to start from any city. They want to know, for each starting city, what is the maximum number of gold coins they can earn. Since they are lazy, you are asked to solve this problem.\n\nNote that although fraction arithmetic was not widely used in the Age of Discovery, Little L and Little K, for their own convenience, expressed part of the information they obtained using fractions (rational numbers). That is, although $dis_i,mea_i,q$ are integers given by people of that time, the amount of goods and the amount of gold coins may be fractions. Little L and Little K compute their profit using the rules of rational arithmetic. Little L and Little K will also trade in the city where they start.", "inputFormat": "The first line contains five positive integers $n,m,s,t,q$.\n\nThe second line contains $n$ positive integers; the $i$-th number denotes $mea_i$.\n\nThe next $m$ lines each contain three positive integers $a,b,dis_i$, indicating that there is a directed sea route of length $dis_i$ from city $a$ to city $b$.", "outputFormat": "Output $n$ lines. The $i$-th line denotes the maximum number of gold coins that can be earned starting from city $i$. The output format is described below.\n\nAbout the output format for fractions:\n\nIt may be printed as ```a/b```, representing the fraction $\\frac{a}{b}$, where $a,b$ are positive integers. It may also be printed as ```-a/b```, representing the fraction $-\\frac{a}{b}$, where $a,b$ are positive integers. It may also be printed as ```a```, representing the **integer** $a$. Note that $\\gcd(a,b)$ is guaranteed to be $1$. If $b$ is $1$, then it must be printed in the form ```a```.", "hint": "[Sample Explanation.]\n\n$\\frac{s}{s+t}=\\frac{1}{2}$, so each time Little L and Little K will unload half of the goods to trade.\n\nStarting from city $1$: first trade in city $1$, trade using $2\\times\\frac{1}{2}=1$ goods, obtain $1\\times 100=100$ gold coins, and the remaining goods are $2-1=1$. If they then take the route $1\\rightarrow1$, it will cost another $1\\times 50=50$ gold coins to return to city $1$, which is not worth it. If they take the route $1\\rightarrow2$, it only costs another $1\\times 2=2$ gold coins to reach city $2$. Arriving at city $2$ and trading, they trade using $1\\times\\frac{1}{2}=\\frac{1}{2}$ goods and obtain $\\frac{1}{2}\\times 200=100$ gold coins, leaving $1-\\frac{1}{2}=\\frac{1}{2}$ goods. Next, take $2\\rightarrow3$, costing $\\frac{1}{2}\\times1=\\frac{1}{2}$ gold coins. Arriving at city $3$, trade using $\\frac{1}{2}\\times\\frac{1}{2}=\\frac{1}{4}$ goods, obtain $\\frac{1}{4}\\times300=75$ gold coins, leaving $\\frac{1}{2}-\\frac{1}{4}=\\frac{1}{4}$ goods. Total profit is $100-2+100-\\frac{1}{2}+75=\\frac{545}{2}$.\n\nStarting from city $2$: take $2\\rightarrow3$, trade in cities $2$ and $3$, profit is $200-1+150=349$.\n\nStarting from city $3$: trade in city $3$, profit is $300$.\n\n[Constraints.]\n\nFor $10\\%$ of the testdata, $n\\le 3,m\\le 9$, and $s,t,q,mea_i,dis_i\\le10$.\n\nFor $50\\%$ of the testdata, $n\\le 10,m\\le 100$, and $s,t,q,mea_i,dis_i\\le10$.\n\nFor another $10\\%$ of the testdata, $m=n$, and for any positive integer $i\\in[1,n]$, city $i$ has a route to city $(i\\mod n)+1$.\n\nFor another $10\\%$ of the testdata, for any positive integer $i\\in[1,n]$, if there exists a route $i\\rightarrow j$, then $j>i$.\n\nFor $100\\%$ of the testdata, $n\\le 50,m\\le 500$, and $s,t,q,mea_i,dis_i\\le10^4$.\n\n[Additional Notes.]\n\nCities are numbered from $1$ to $n$.\n\nPlease note the special time limit of this problem.\n\nTo prevent the problem from being too time-tight, this problem **provides [Octaoxygen](https://www.luogu.com.cn/paste/ky1fh8zk)**. You can paste it directly at the very beginning of your code before submitting. It is guaranteed that, after adding Octaoxygen, the maximum running time of the official solution on each test point is less than half of the time limit. Feel free to try your approach.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【L&K R-03】大航海时代", "background": "", "description": "【如果不想看题面请阅读分割线以下部分】\n\n$$\\text{Onde\\space a\\space terra\\space acaba\\space e\\space o\\space mar\\space começa}$$\n\n>_15 世纪末，是一个伟大时代的开始。自此之后，人们开始逐渐认识到大千世界的险恶与奇丽，开始前仆后继地展开一个又一个不可思议的冒险，开始缓缓地驾驭那波涛汹涌、变幻莫测的大海。_\n\n>_15 世纪末，是一个伟大时代的开始。为了征服海洋，人们集人类之智慧，制造出方舟巨轮；汇天地之灵怪，制造出罗盘、六分仪。海上的康庄大道从此建立，人们航行于各地，商贸随之诞生。_\n\n>_15 世纪末，是一个伟大时代的开始。商品与金钱象征着欲望，在海上流动了起来。原先分隔的黄金汇聚成大金库，让人们尝到了商业的甜头。贸易的花朵开遍整个欧洲，航线上船只往来不绝，财富源源不断地从海上涌出。_\n\n>_[更多](https://www.luogu.org/paste/k9bqwpps)_\n\n>……\n\n>_大航海时代，是人类文明崭新的起点。_\n\n海上经商，商人们必须对航路有充分的了解。欧洲的城市不计其数，航路更是数不胜数。当然，人们无需知晓所有城市的位置，更无需清楚所有航路的情况。人们只需要知道，有几个主要城市，并且有几条海上航路连接着它们即可，其他的城市与航路都是次要的，不会带来过多收益。\n\n商船沿着航路往来于城市之间。它们每到一个城市，卸下一些货品，城市里的商人便会根据货品的数目给出相应的报酬。这些报酬由船主收取，并将部分报酬分发给水手们。不过大家并不关心这件事，他们只会关心一艘船获得的总收益。\n\n商船的航行总会伴随着危险与损失。海上的天气难以预测，船只随时都可能会被大浪吞没，或者被飓风刮得千疮百孔。不过这些情况比较特殊，我们并不考虑。我们考虑的是，商船在航行过程中的必要支出。一趟航行往往需要几星期甚至几个月的时间。在这段时间里，船员需要淡水与食物，船也需要适当的维护。人们总结经验发现，一段航行的必要支出与航行距离和载货量有直接关系。\n\n大航海时代的人们就是在这些规律下生活的，考量着商船的支出与收益，缓行于茫茫大海之上，每日如此，单调而无趣。大航海时代，对于大部分人来说，或许并没有那么伟大。\n\n当然，生于现代的我们不必在意这些东西。这也是当然的，现代人怎么会为古代人考虑什么东西呢？\n\n然而，小 L 和小 K 发现他们必须开始考虑这些事物了，因为他们不小心掉进了虫洞，回到了大航海时代。回到过去的他们用唯一的财产：手机，换来了一艘船和一船货物。为了生存，他们要驾驶着这艘船航行于海上，用货物与商人们换取钱财。\n\n----------------------------------\n\n小 L 和小 K 通过调查了解了海上贸易的一些基本规律。共有 $n$ 个主要城市和 $m$ 条连接着它们的航道，船只能沿着这些航道航行。注意航道是单向的，因为如果是双向，航线就容易交叉，发生事故。第 $i$ 条航道的距离为 $dis_i$，若商船在经过此航道时载货量（下称货物量）为 $p$，则航行完此航道需花费 $p\\times dis_i$  的金币。商船到达一个城市，会卸下部分货物与商人交易。每座城市都有一个大商人，会根据 **船上卸下** 的货物量付给商船一定的金币。每座城市的大商人不同，标准也不一样。第 $i$ 座城市的大商人标准为 $mea_i$，若商船在 $i$ 号城市卸下量为 $p$ 的商品，大商人会付给商船 $p\\times mea_i$ 的金币。商船每到达一座城市，只会与大商人进行一次交易。当然，一座城市可以重复到达，每次到达都会与大商人进行交易。\n\n小 L 和小 K 需要遵循这些规律，沿着航道进行海上贸易。小 L 和小 K 在一开始总共有量为 $q$ 的货品。小 L 和小 K 本该精打细算，详细计算出他们在每座城市应该卸下的货物量。但是小 L 和小 K 是懒癌晚期患者，并不想这样做。他们随便想了两个正整数 $s,t$，于是如果需要卸下货物，他们便会卸下总货物量 $\\frac{s}{s+t}$ 的货物。\n\n在他们的商贸之旅开始之前，小 L 和小 K 就已经研究出了回到现代的方法。但是他们并不着急回去。因为回溯时间导致的时空错位，小 L 和小 K 身上的时间是静止的。也就是说他们拥有无限的时间。他们决定利用此原理在这个时代大赚一笔。小 L 和小 K 可以选择从任意一座城市出发。他们希望知道从每座城市出发，可以赚到的最大金币数量是多少。当然因为他们比较懒，这个问题由你来解决。\n\n需要注意的是，尽管在大航海时代分数的运算并没有普及，但小 L 和小 K 为了自己方便而将他们得到的信息部分用分数（有理数）来表示。也就是说，虽然 $dis_i,mea_i,q$ 是由当时的人们给出的，所以是整数，但是货物量和金币量可以是分数，即小 L 和小 K 用有理数的计算法则计算自己的收益。小 L 和小 K 在出发的城市也会进行交易。", "inputFormat": "第一行，五个正整数 $n,m,s,t,q$。\n\n第二行， $n$ 个正整数，第 $i$ 个数表示 $mea_i$。\n\n接下来 $m$ 行，每行三个正整数 $a,b,dis_i$，表示从城市 $a$ 到城市 $b$ 有一条长为 $dis_i$ 的单向航道。", "outputFormat": "共 $n$ 行，第 $i$ 行表示从 $i$ 号城市出发可以赚到的最大金币数量，输出格式见下文。\n\n关于分数的输出格式：\n\n可能以 ```a/b``` 的形式输出，表示分数 $\\frac{a}{b}$，其中 $a,b$ 为正整数。也可能以 ```-a/b``` 的形式输出，表示分数 $-\\frac{a}{b}$，其中 $a,b$ 为正整数。也可能以 ```a``` 的形式输出，表示**整数** $a$。注意 $\\gcd(a,b)$ 一定为 $1$。如果 $b$ 为 $1$，则必须以 ```a``` 的形式输出。", "hint": "【样例说明】\n\n$\\frac{s}{s+t}=\\frac{1}{2}$，小 L 和小 K 每次会卸下一半的货物进行交易。\n\n从 $1$ 号城市出发：先在 $1$ 号城市进行交易，用 $2\\times\\frac{1}{2}=1$ 的货物量交易，获得金币 $1\\times 100=100$，剩余货物量 $2-1=1$。之后如果走 $1\\rightarrow1$ 的航道，会再花费 $1\\times 50=50$ 的金币回到城市 $1$，很不划算。如果走 $1\\rightarrow2$ 的航道，只需要再花费 $1\\times 2=2$ 的金币就可以到达城市 $2$。到达城市 $2$ 进行交易，用 $1\\times\\frac{1}{2}=\\frac{1}{2}$ 的货物量交易，获得金币 $\\frac{1}{2}\\times 200=100$，剩余货物量 $1-\\frac{1}{2}=\\frac{1}{2}$。接下来走 $2\\rightarrow3$，花费 $\\frac{1}{2}\\times1=\\frac{1}{2}$ 的金币。到达城市 $3$，用 $\\frac{1}{2}\\times\\frac{1}{2}=\\frac{1}{4}$的货物量交易，交易获得金币 $\\frac{1}{4}\\times300=75$，剩余货物量 $\\frac{1}{2}-\\frac{1}{4}=\\frac{1}{4}$。总获利 $100-2+100-\\frac{1}{2}+75=\\frac{545}{2}$。\n\n从 $2$ 号城市出发：走 $2\\rightarrow3$，在 $2,3$ 号城市交易，获利 $200-1+150=349$。\n\n从 $3$ 号城市出发：在 $3$ 号城市交易，获利 $300$。\n\n【数据范围】\n\n对于 $10\\%$ 的数据，$n\\le 3,m\\le 9$，$s,t,q,mea_i,dis_i\\le10$。\n\n对于 $50\\%$ 的数据，$n\\le 10,m\\le 100$，$s,t,q,mea_i,dis_i\\le10$。\n\n对于另外 $10\\%$ 数据，$m=n$，且对于任意正整数 $i\\in[1,n]$，编号为 $i$ 的城市有一条到编号为 $(i\\mod n)+1$ 的城市的航道。\n\n对于另外 $10\\%$ 数据，对于任意正整数 $i\\in[1,n]$，若存在航道 \n $i\\rightarrow j$，则 $j>i$。\n\n对于 $100\\%$ 的数据，$n\\le 50,m\\le 500$，$s,t,q,mea_i,dis_i\\le10^4$。\n\n【补充说明】\n\n城市从 $1$ 到 $n$ 编号。\n\n请注意本题特殊的时空限制。\n\n为了防止题目过于卡常，本题 **提供 [八聚氧](https://www.luogu.com.cn/paste/ky1fh8zk)** ，直接加在代码最前提交即可。保证标程在加上八聚氧后通过每个数据点的最大用时小于时限的一半。请大胆尝试解法。", "locale": "zh-CN"}}}
{"pid": "P5823", "type": "P", "difficulty": 3, "samples": [["3", "1 2 3 1 3 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "洛谷原创", "Special Judge", "构造"], "title": "【L&K R-03】课表的排列", "background": "小 L 早上来到教室，发现今天的课表非常有趣。", "description": "今天的课表是：\n\n    语文 数学 英语 语文 英语 数学\n\n今天的课表上一共有三个科目：语文、数学、英语。每个科目都有两节课。每科的两节课间隔的课程数分别为 $2,3,1$，从小到大排序后为 $1,2,3$，是一个公差为 $1$ 的等差数列。\n\n小 L 想知道，对于更多的科目，具有这样有趣性质的课表是否存在。换句话说，如果课表上一共有 $n$ 个科目，每个科目都有且仅有两节课，小 L 想知道是否存在一个课表，满足这 $n$ 科的两节课间隔的课程数从小到大排序后是一个公差为 $1$ 的等差数列。\n\n但是，小 L 只会写时间复杂度为 $O((2n)!\\times n\\log_2 n)$ 的算法，于是他求助于你，请你判断是否存在这样的课表，如果存在，还要输出一种可能的情况。", "inputFormat": "输入仅一行，一个 **奇数** $n$，表示课表上的课程数。", "outputFormat": "输出仅一行。\n\n如果不存在这样的课表，输出  `-1`；\n\n如果存在这样的课表，输出 $2n$ 个整数，表示课表。令 $1,2,\\ldots ,n$ 中的每一个整数对应一个科目，每个整数在课表中均会出现两次，且满足小 L 的性质。由于可能有多种可能的答案，你可以给出任意一种课表，刚到教室的小 K 会写出程序来检验你的课表是否满足小 L 的性质。", "hint": "**本题使用 Special Judge。**\n\n本题共 $20$ 个数据点，每个数据点 $5$ 分。\n\n| 数据编号$~x$ | $n=$ |\n| :-----------: | :-----------: |\n| $1\\sim 10$ | $2x+1$ |\n| $11\\sim 15$ | $200x+1$ |\n| $16\\sim 20$ | $100000x+1$ |", "locale": "zh-CN", "translations": {"en": {"title": "[L&K R-03] Timetable Arrangement", "background": "Little L came to the classroom in the morning and found today’s timetable very interesting.", "description": "Today’s timetable is:\n\n    Chinese Math English Chinese English Math\n\nThere are three subjects on today’s timetable: Chinese, Math, and English. Each subject has two classes. For each subject, the number of classes between its two occurrences is $2,3,1$. After sorting these numbers from small to large, we get $1,2,3$, which is an arithmetic sequence with common difference $1$.\n\nLittle L wants to know whether a timetable with the same interesting property exists for more subjects. In other words, if there are $n$ subjects on the timetable, and each subject appears exactly twice, Little L wants to know whether there exists a timetable such that, after sorting the numbers of classes between the two classes of each of the $n$ subjects from small to large, the result is an arithmetic sequence with common difference $1$.\n\nHowever, Little L can only write an algorithm with time complexity $O((2n)!\\times n\\log_2 n)$, so he asks you for help. You need to determine whether such a timetable exists. If it exists, you also need to output one possible timetable.", "inputFormat": "The input contains only one line: an **odd** integer $n$, representing the number of subjects on the timetable.", "outputFormat": "Output only one line.\n\nIf no such timetable exists, output `-1`.\n\nIf such a timetable exists, output $2n$ integers representing the timetable. Let each integer in $1,2,\\ldots,n$ correspond to one subject. Each integer appears exactly twice in the timetable, and the timetable must satisfy Little L’s property. Since there may be multiple valid answers, you may output any one. Little K, who has just arrived at the classroom, will write a program to check whether your timetable satisfies Little L’s property.", "hint": "**This problem uses Special Judge.**\n\nThere are $20$ test points in total, and each test point is worth $5$ points.\n\n| Data Index $~x$ | $n=$ |\n| :-----------: | :-----------: |\n| $1\\sim 10$ | $2x+1$ |\n| $11\\sim 15$ | $200x+1$ |\n| $16\\sim 20$ | $100000x+1$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【L&K R-03】课表的排列", "background": "小 L 早上来到教室，发现今天的课表非常有趣。", "description": "今天的课表是：\n\n    语文 数学 英语 语文 英语 数学\n\n今天的课表上一共有三个科目：语文、数学、英语。每个科目都有两节课。每科的两节课间隔的课程数分别为 $2,3,1$，从小到大排序后为 $1,2,3$，是一个公差为 $1$ 的等差数列。\n\n小 L 想知道，对于更多的科目，具有这样有趣性质的课表是否存在。换句话说，如果课表上一共有 $n$ 个科目，每个科目都有且仅有两节课，小 L 想知道是否存在一个课表，满足这 $n$ 科的两节课间隔的课程数从小到大排序后是一个公差为 $1$ 的等差数列。\n\n但是，小 L 只会写时间复杂度为 $O((2n)!\\times n\\log_2 n)$ 的算法，于是他求助于你，请你判断是否存在这样的课表，如果存在，还要输出一种可能的情况。", "inputFormat": "输入仅一行，一个 **奇数** $n$，表示课表上的课程数。", "outputFormat": "输出仅一行。\n\n如果不存在这样的课表，输出  `-1`；\n\n如果存在这样的课表，输出 $2n$ 个整数，表示课表。令 $1,2,\\ldots ,n$ 中的每一个整数对应一个科目，每个整数在课表中均会出现两次，且满足小 L 的性质。由于可能有多种可能的答案，你可以给出任意一种课表，刚到教室的小 K 会写出程序来检验你的课表是否满足小 L 的性质。", "hint": "**本题使用 Special Judge。**\n\n本题共 $20$ 个数据点，每个数据点 $5$ 分。\n\n| 数据编号$~x$ | $n=$ |\n| :-----------: | :-----------: |\n| $1\\sim 10$ | $2x+1$ |\n| $11\\sim 15$ | $200x+1$ |\n| $16\\sim 20$ | $100000x+1$ |", "locale": "zh-CN"}}}
{"pid": "P5824", "type": "P", "difficulty": 7, "samples": [["13 6", "83517427\n0\n721878522\n19628064\n0\n9321312\n8568\n0\n792\n71\n0\n14"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "O2优化", "组合数学", "生成函数", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "十二重计数法", "background": "组合数学是一门古老而迷人的学科。\n\n传说早在 $114514$ 年前，一位名为忆哀的神灵来到地球，发现了人类——另一种有智慧的物种。  \n\n她觉得这很有趣，为了加速人类文明的发展，她向人间传下了一类计数问题——十二重计数，这也正是组合数学的开端。  \n\n而只有搞明白这类问题，才能在组合数学上继续深入。", "description": "有 $n$ 个球和 $m$ 个盒子，球要全部装进盒子里。  \n还有一些限制条件，那么有多少种方法放球？（与放的先后顺序无关）  \n\n限制条件分别如下：    \n\n$\\text{I}$：球之间互不相同，盒子之间互不相同。    \n$\\text{II}$：球之间互不相同，盒子之间互不相同，每个盒子至多装一个球。   \n$\\text{III}$：球之间互不相同，盒子之间互不相同，每个盒子至少装一个球。  \n\n$\\text{IV}$：球之间互不相同，盒子全部相同。        \n$\\text{V}$：球之间互不相同，盒子全部相同，每个盒子至多装一个球。   \n$\\text{VI}$：球之间互不相同，盒子全部相同，每个盒子至少装一个球。\n\n$\\text{VII}$：球全部相同，盒子之间互不相同。  \n$\\text{VIII}$：球全部相同，盒子之间互不相同，每个盒子至多装一个球。  \n$\\text{IX}$：球全部相同，盒子之间互不相同，每个盒子至少装一个球。   \n\n$\\text{X}$：球全部相同，盒子全部相同。   \n$\\text{XI}$：球全部相同，盒子全部相同，每个盒子至多装一个球。  \n$\\text{XII}$：球全部相同，盒子全部相同，每个盒子至少装一个球。\n\n由于答案可能很大，所以要对 $998244353$ 取模。", "inputFormat": "仅一行两个正整数 $n,m$。", "outputFormat": "输出十二行，每行一个整数，对应每一种限制条件的答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n,m \\le 2\\times 10^5$。\n\norz $\\mathsf E \\color{red}\\mathsf{ntropyIncreaser}$。", "locale": "zh-CN", "translations": {"en": {"title": "Twelvefold Counting Method", "background": "Combinatorics is an old and fascinating subject.\n\nLegend has it that as early as $114514$ years ago, a deity named Yi Ai came to Earth and discovered humans—another intelligent species.\n\nShe found this very interesting. In order to speed up the development of human civilization, she passed down to the human world a type of counting problem—the twelvefold counting. This was also the beginning of combinatorics.\n\nOnly by figuring out this type of problem can one continue to go deeper in combinatorics.", "description": "There are $n$ balls and $m$ boxes, and all balls must be put into the boxes.\nThere are also some constraints. How many ways are there to place the balls? (The order of placing does not matter.)\n\nThe constraints are as follows:\n\n$\\text{I}$: All balls are distinct, and all boxes are distinct.  \n$\\text{II}$: All balls are distinct, and all boxes are distinct; each box holds at most one ball.  \n$\\text{III}$: All balls are distinct, and all boxes are distinct; each box holds at least one ball.\n\n$\\text{IV}$: All balls are distinct, and all boxes are identical.  \n$\\text{V}$: All balls are distinct, and all boxes are identical; each box holds at most one ball.  \n$\\text{VI}$: All balls are distinct, and all boxes are identical; each box holds at least one ball.\n\n$\\text{VII}$: All balls are identical, and all boxes are distinct.  \n$\\text{VIII}$: All balls are identical, and all boxes are distinct; each box holds at most one ball.  \n$\\text{IX}$: All balls are identical, and all boxes are distinct; each box holds at least one ball.\n\n$\\text{X}$: All balls are identical, and all boxes are identical.  \n$\\text{XI}$: All balls are identical, and all boxes are identical; each box holds at most one ball.  \n$\\text{XII}$: All balls are identical, and all boxes are identical; each box holds at least one ball.\n\nSince the answer may be very large, take it modulo $998244353$.", "inputFormat": "Only one line with two positive integers $n,m$.", "outputFormat": "Output twelve lines. Each line contains one integer, corresponding to the answer under each constraint.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1\\le n,m \\le 2\\times 10^5$.\n\norz $\\mathsf E \\color{red}\\mathsf{ntropyIncreaser}$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "十二重计数法", "background": "组合数学是一门古老而迷人的学科。\n\n传说早在 $114514$ 年前，一位名为忆哀的神灵来到地球，发现了人类——另一种有智慧的物种。  \n\n她觉得这很有趣，为了加速人类文明的发展，她向人间传下了一类计数问题——十二重计数，这也正是组合数学的开端。  \n\n而只有搞明白这类问题，才能在组合数学上继续深入。", "description": "有 $n$ 个球和 $m$ 个盒子，球要全部装进盒子里。  \n还有一些限制条件，那么有多少种方法放球？（与放的先后顺序无关）  \n\n限制条件分别如下：    \n\n$\\text{I}$：球之间互不相同，盒子之间互不相同。    \n$\\text{II}$：球之间互不相同，盒子之间互不相同，每个盒子至多装一个球。   \n$\\text{III}$：球之间互不相同，盒子之间互不相同，每个盒子至少装一个球。  \n\n$\\text{IV}$：球之间互不相同，盒子全部相同。        \n$\\text{V}$：球之间互不相同，盒子全部相同，每个盒子至多装一个球。   \n$\\text{VI}$：球之间互不相同，盒子全部相同，每个盒子至少装一个球。\n\n$\\text{VII}$：球全部相同，盒子之间互不相同。  \n$\\text{VIII}$：球全部相同，盒子之间互不相同，每个盒子至多装一个球。  \n$\\text{IX}$：球全部相同，盒子之间互不相同，每个盒子至少装一个球。   \n\n$\\text{X}$：球全部相同，盒子全部相同。   \n$\\text{XI}$：球全部相同，盒子全部相同，每个盒子至多装一个球。  \n$\\text{XII}$：球全部相同，盒子全部相同，每个盒子至少装一个球。\n\n由于答案可能很大，所以要对 $998244353$ 取模。", "inputFormat": "仅一行两个正整数 $n,m$。", "outputFormat": "输出十二行，每行一个整数，对应每一种限制条件的答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n,m \\le 2\\times 10^5$。\n\norz $\\mathsf E \\color{red}\\mathsf{ntropyIncreaser}$。", "locale": "zh-CN"}}}
{"pid": "P5825", "type": "P", "difficulty": 6, "samples": [["4", "1 11 11 1 0"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "组合数学", "Stirling 数", "生成函数", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "排列计数", "background": "", "description": "我们记一个排列 $P$ 的升高为 $k$ 当且仅当存在 $k$ 个位置 $i$ 使得 $P_i<P_{i+1}$。\n\n现在给定排列长度 $n$，对于所有整数 $k\\in [0,n]$ 求有多少个排列的升高为 $k$。", "inputFormat": "一个整数 $n$。", "outputFormat": "一行，$n+1$ 个整数，第 $i$ 个整数表示长度为 $n$ 且升高为 $i-1$ 个排列的个数，对 $998244353$ 取模。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 2\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Permutation Ascent Counting", "background": "", "description": "We say a permutation $P$ has $k$ ascents if and only if there exist $k$ positions $i$ such that $P_i < P_{i+1}$.\n\nNow given the permutation length $n$, for all integers $k \\in [0, n]$, find how many permutations have exactly $k$ ascents.", "inputFormat": "An integer $n$.", "outputFormat": "One line with $n + 1$ integers. The $i$-th integer indicates the number of permutations of length $n$ with exactly $i - 1$ ascents, taken modulo $998244353$.", "hint": "For $100\\%$ of the testdata, $1 \\leq n \\leq 2 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "排列计数", "background": "", "description": "我们记一个排列 $P$ 的升高为 $k$ 当且仅当存在 $k$ 个位置 $i$ 使得 $P_i<P_{i+1}$。\n\n现在给定排列长度 $n$，对于所有整数 $k\\in [0,n]$ 求有多少个排列的升高为 $k$。", "inputFormat": "一个整数 $n$。", "outputFormat": "一行，$n+1$ 个整数，第 $i$ 个整数表示长度为 $n$ 且升高为 $i-1$ 个排列的个数，对 $998244353$ 取模。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 2\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5826", "type": "P", "difficulty": 5, "samples": [["0 5 5 5\n1 3 2 2 4\n3 1 5 2\n2 3 2\n3 1 2 3\n3 1 2 4\n5 1 3 2 2 4\n", "No\nYes\nNo\nYes\nYes"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["字符串", "线段树", "O2优化", "可持久化", "有限状态自动机", "模板题"], "title": "【模板】子序列自动机", "background": "本题中，若 $x$ 是 $y$ 的子序列，则等价于存在一个**单调递增**序列 $z$，满足 $|z| = |x|$，$z_{|x|} \\leq |y|$，且 $\\forall i \\in [1, ~|x|],~y_{z_i} = x_i$。其中 $|x|,~|y|,~|z|$ 分别代表序列 $x,~y,~z$ 的长度，$x_i,~y_i,~z_i$ 分别代表序列 $x,~y,~z$ 的第 $i$ 项。\n\n这是一道在 ``yLOI2020`` 备选题里被毙掉的题目。", "description": "给定一个长度为 $n$ 的正整数序列 $a$ ，有 $q$ 次询问，第 $i$ 次询问给定一个长度为 $L_i$ 的序列 $b_i$，请你判断 $b_i$ 是不是 $a$ 的子序列。序列 $a$ 和所有 $b_i$ 中的元素都不大于一个给定的正整数 $m$。", "inputFormat": "每个测试点有且仅有一组数据。\n\n输入的第一行是四个用空格隔开的整数，分别代表 $type,~n,~q,~m$。其中 $type$ 代表测试点所在的子任务编号，其余变量的含义见【题目描述】。\n\n输入的第二行是 $n$ 个用空格隔开的整数，第 $i$ 个数字代表序列 $a$ 的第 $i$ 个元素 $a_i$。\n\n第 $3$ 行至第 $(q + 2)$ 行，每行代表一次询问。第 $(i + 2)$ 行的输入格式为：\n\n- 第 $(i + 2)$ 行的行首有一个整数 $l_i$，代表第 $i$ 次询问的序列长度。一个空格后有 $l_i$ 个用空格隔开的整数。该行的第 $(j + 1)$ 个整数代表序列 $b_i$ 的第 $j$ 个元素 $b_{i, j}$。", "outputFormat": "对于每次询问，输出一行一个字符串，若给定的序列是 $a$ 的子序列，则输出 `Yes`，否则输出 `No`。", "hint": "#### 样例 1 解释\n\n- 对于第一次询问，原序列中没有 $5$，所以给定序列显然不是原序列的子序列。\n- 对于第二次询问，存在两个合法的序列 $z$，分别是 $\\{2,~3\\}$ 和 $\\{2,~4\\}$。即 $a_{2} = b_{2, 1},~a_3 = b_{2, 2}$ 或 $a_2 = b_{2, 1},~a_{4} = b_{2, 2}$。这里 $b_{i, j}$ 代表序列 $b_i$ 的第 $j$ 个元素，序列 $z$ 的含义见【题目背景】，下同。\n- 对于第三次询问，不存在合法的序列 $z$。\n- 对于第四次询问，存在两个合法的序列 $z$，分别是 $\\{1,~3,~5\\}$ 和 $\\{1,~4,~5\\}$。\n- 对于第五次询问，存在一个合法的序列 $z$，为 $\\{1,~2,~3,~4,~5\\}$。\n\n#### 数据范围与约定\n\n**本题采用多测试点捆绑测试，共有 3 个子任务**。\n\n- Subtask 1（20 points）：$type = 1$，$n, q, m \\leq 100$，$\\sum_{i = 1}^{q} l_i \\leq 10^3$。\n- Subtask 2（35 points）：$type = 2$，$n,q \\leq 10^5$，$m \\leq 26$，$\\sum_{i = 1}^{q} l_i \\leq 10^6$。\n- Subtask 3（45 points）：$type = 3$，$n,q,m \\leq 10^5$，$\\sum_{i = 1}^q L_i \\leq 10^6$。\n\n对于全部的测试点，保证 $1 \\leq n, m, q \\leq 10^5$，$1 \\leq a_i, b_{i, j} \\leq m$，$1 \\leq l_i \\leq 10^6$，$\\sum_{i = 1}^{q} l_i \\leq 10^6$。\n\n\n### 提示\n\n- 请注意常数因子对程序效率造成的影响。\n- 本题输入规模较大，请注意数据读入对程序效率造成的影响。\n- 请注意输入第一行的顺序为先输入询问次数 $q$，再输入序列元素最大值 $m$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Subsequence Automaton.", "background": "In this problem, if $x$ is a subsequence of $y$, then it is equivalent to the existence of a **strictly increasing** sequence $z$ such that $|z| = |x|$, $z_{|x|} \\leq |y|$, and $\\forall i \\in [1, ~|x|],~y_{z_i} = x_i$. Here $|x|,~|y|,~|z|$ denote the lengths of sequences $x,~y,~z$, and $x_i,~y_i,~z_i$ denote the $i$-th element of sequences $x,~y,~z$.\n\nThis problem was rejected in the backup problem set of ``yLOI2020``.", "description": "Given a positive integer sequence $a$ of length $n$, there are $q$ queries. In the $i$-th query, a sequence $b_i$ of length $L_i$ is given. You need to determine whether $b_i$ is a subsequence of $a$. All elements in sequence $a$ and all $b_i$ are no greater than a given positive integer $m$.", "inputFormat": "Each test case contains exactly one dataset.\n\nThe first line contains four integers separated by spaces: $type,~n,~q,~m$. Here $type$ indicates the subtask number of the test point, and the meanings of the other variables are the same as in the Description.\n\nThe second line contains $n$ integers separated by spaces. The $i$-th number is the $i$-th element $a_i$ of sequence $a$.\n\nLines $3$ to $(q + 2)$ each represent a query. The input format of line $(i + 2)$ is:\n\n- At the beginning of line $(i + 2)$ there is an integer $l_i$, which is the length of the sequence in the $i$-th query. After one space, there are $l_i$ integers separated by spaces. The $(j + 1)$-th integer on this line is the $j$-th element $b_{i, j}$ of sequence $b_i$.", "outputFormat": "For each query, output one string per line. If the given sequence is a subsequence of $a$, output `Yes`; otherwise output `No`.", "hint": "#### Explanation for Sample 1\n\n- For the first query, there is no $5$ in the original sequence, so the given sequence is obviously not a subsequence of the original sequence.\n- For the second query, there are two valid sequences $z$, which are $\\{2,~3\\}$ and $\\{2,~4\\}$. That is, $a_{2} = b_{2, 1},~a_3 = b_{2, 2}$ or $a_2 = b_{2, 1},~a_{4} = b_{2, 2}$. Here $b_{i, j}$ denotes the $j$-th element of sequence $b_i$. The meaning of sequence $z$ is given in the Background, and the same below.\n- For the third query, there is no valid sequence $z$.\n- For the fourth query, there are two valid sequences $z$, which are $\\{1,~3,~5\\}$ and $\\{1,~4,~5\\}$.\n- For the fifth query, there is one valid sequence $z$, which is $\\{1,~2,~3,~4,~5\\}$.\n\n#### Constraints and Conventions\n\n**This problem uses bundled multi-point testing, with a total of 3 subtasks**.\n\n- Subtask 1 (20 points): $type = 1$, $n, q, m \\leq 100$, $\\sum_{i = 1}^{q} l_i \\leq 10^3$.\n- Subtask 2 (35 points): $type = 2$, $n,q \\leq 10^5$, $m \\leq 26$, $\\sum_{i = 1}^{q} l_i \\leq 10^6$.\n- Subtask 3 (45 points): $type = 3$, $n,q,m \\leq 10^5$, $\\sum_{i = 1}^q L_i \\leq 10^6$.\n\nFor all test points, it is guaranteed that $1 \\leq n, m, q \\leq 10^5$, $1 \\leq a_i, b_{i, j} \\leq m$, $1 \\leq l_i \\leq 10^6$, and $\\sum_{i = 1}^{q} l_i \\leq 10^6$.\n\n### Notes\n\n- Please pay attention to the impact of constant factors on program efficiency.\n- The input size of this problem is large, so please pay attention to input reading efficiency.\n- Please note that in the first line of input, the order is to input the number of queries $q$ first, and then the maximum value $m$ of sequence elements.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】子序列自动机", "background": "本题中，若 $x$ 是 $y$ 的子序列，则等价于存在一个**单调递增**序列 $z$，满足 $|z| = |x|$，$z_{|x|} \\leq |y|$，且 $\\forall i \\in [1, ~|x|],~y_{z_i} = x_i$。其中 $|x|,~|y|,~|z|$ 分别代表序列 $x,~y,~z$ 的长度，$x_i,~y_i,~z_i$ 分别代表序列 $x,~y,~z$ 的第 $i$ 项。\n\n这是一道在 ``yLOI2020`` 备选题里被毙掉的题目。", "description": "给定一个长度为 $n$ 的正整数序列 $a$ ，有 $q$ 次询问，第 $i$ 次询问给定一个长度为 $L_i$ 的序列 $b_i$，请你判断 $b_i$ 是不是 $a$ 的子序列。序列 $a$ 和所有 $b_i$ 中的元素都不大于一个给定的正整数 $m$。", "inputFormat": "每个测试点有且仅有一组数据。\n\n输入的第一行是四个用空格隔开的整数，分别代表 $type,~n,~q,~m$。其中 $type$ 代表测试点所在的子任务编号，其余变量的含义见【题目描述】。\n\n输入的第二行是 $n$ 个用空格隔开的整数，第 $i$ 个数字代表序列 $a$ 的第 $i$ 个元素 $a_i$。\n\n第 $3$ 行至第 $(q + 2)$ 行，每行代表一次询问。第 $(i + 2)$ 行的输入格式为：\n\n- 第 $(i + 2)$ 行的行首有一个整数 $l_i$，代表第 $i$ 次询问的序列长度。一个空格后有 $l_i$ 个用空格隔开的整数。该行的第 $(j + 1)$ 个整数代表序列 $b_i$ 的第 $j$ 个元素 $b_{i, j}$。", "outputFormat": "对于每次询问，输出一行一个字符串，若给定的序列是 $a$ 的子序列，则输出 `Yes`，否则输出 `No`。", "hint": "#### 样例 1 解释\n\n- 对于第一次询问，原序列中没有 $5$，所以给定序列显然不是原序列的子序列。\n- 对于第二次询问，存在两个合法的序列 $z$，分别是 $\\{2,~3\\}$ 和 $\\{2,~4\\}$。即 $a_{2} = b_{2, 1},~a_3 = b_{2, 2}$ 或 $a_2 = b_{2, 1},~a_{4} = b_{2, 2}$。这里 $b_{i, j}$ 代表序列 $b_i$ 的第 $j$ 个元素，序列 $z$ 的含义见【题目背景】，下同。\n- 对于第三次询问，不存在合法的序列 $z$。\n- 对于第四次询问，存在两个合法的序列 $z$，分别是 $\\{1,~3,~5\\}$ 和 $\\{1,~4,~5\\}$。\n- 对于第五次询问，存在一个合法的序列 $z$，为 $\\{1,~2,~3,~4,~5\\}$。\n\n#### 数据范围与约定\n\n**本题采用多测试点捆绑测试，共有 3 个子任务**。\n\n- Subtask 1（20 points）：$type = 1$，$n, q, m \\leq 100$，$\\sum_{i = 1}^{q} l_i \\leq 10^3$。\n- Subtask 2（35 points）：$type = 2$，$n,q \\leq 10^5$，$m \\leq 26$，$\\sum_{i = 1}^{q} l_i \\leq 10^6$。\n- Subtask 3（45 points）：$type = 3$，$n,q,m \\leq 10^5$，$\\sum_{i = 1}^q L_i \\leq 10^6$。\n\n对于全部的测试点，保证 $1 \\leq n, m, q \\leq 10^5$，$1 \\leq a_i, b_{i, j} \\leq m$，$1 \\leq l_i \\leq 10^6$，$\\sum_{i = 1}^{q} l_i \\leq 10^6$。\n\n\n### 提示\n\n- 请注意常数因子对程序效率造成的影响。\n- 本题输入规模较大，请注意数据读入对程序效率造成的影响。\n- 请注意输入第一行的顺序为先输入询问次数 $q$，再输入序列元素最大值 $m$。", "locale": "zh-CN"}}}
{"pid": "P5827", "type": "P", "difficulty": 7, "samples": [["1\n2\n3\n4\n5\n", "1\n1\n1\n10\n238\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "O2优化", "组合数学", "生成函数", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "点双连通图计数", "background": "", "description": "求 $n$ 个点的有标号点双连通图（简单无向图，整个图是一个点双连通分量）的个数，答案对 $998244353$ 取模。", "inputFormat": "共五行，每行一个整数 $n$，表示一次询问。", "outputFormat": "共五行，每行一个整数，表示一次询问的答案。", "hint": "$1 \\le n \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Counting Labeled Biconnected Graphs", "background": "　", "description": "Find the number of labeled vertex-biconnected graphs on $n$ vertices (a simple undirected graph, and the whole graph is one vertex-biconnected component). Output the answer modulo $998244353$.", "inputFormat": "There are five lines in total. Each line contains one integer $n$, representing one query.", "outputFormat": "There are five lines in total. Each line contains one integer, representing the answer to one query.", "hint": "Constraints: $1 \\le n \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "点双连通图计数", "background": "", "description": "求 $n$ 个点的有标号点双连通图（简单无向图，整个图是一个点双连通分量）的个数，答案对 $998244353$ 取模。", "inputFormat": "共五行，每行一个整数 $n$，表示一次询问。", "outputFormat": "共五行，每行一个整数，表示一次询问的答案。", "hint": "$1 \\le n \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5828", "type": "P", "difficulty": 7, "samples": [["1\n2\n3\n4\n5\n", "1\n0\n1\n10\n253\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "O2优化", "组合数学", "生成函数", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "边双连通图计数", "background": "", "description": "求 $n$ 个点的有标号边双连通图（简单无向图，整个图是一个边双连通分量）的个数，答案对 $998244353$ 取模。", "inputFormat": "共五行，每行一个整数 $n$，表示一次询问。", "outputFormat": "共五行，每行一个整数，表示一次询问的答案。", "hint": "$1 \\le n \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Counting Edge-Biconnected Graphs", "background": "", "description": "Find the number of labeled edge-biconnected graphs on $n$ vertices (simple undirected graphs where the whole graph is a single edge-biconnected component). Output the answer modulo $998244353$.", "inputFormat": "There are five lines in total. Each line contains one integer $n$, representing one query.", "outputFormat": "There are five lines in total. Each line contains one integer, representing the answer to one query.", "hint": "Constraints: $1 \\le n \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "边双连通图计数", "background": "", "description": "求 $n$ 个点的有标号边双连通图（简单无向图，整个图是一个边双连通分量）的个数，答案对 $998244353$ 取模。", "inputFormat": "共五行，每行一个整数 $n$，表示一次询问。", "outputFormat": "共五行，每行一个整数，表示一次询问的答案。", "hint": "$1 \\le n \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5829", "type": "P", "difficulty": 5, "samples": [["aaaabbabbaa\n5\n2 4\n7 10\n3 4\n1 2\n4 11\n", "1\n1\n2\n0\n2\n"], ["zzaaccaazzccaacczz\n3\n2 18\n10 18\n3 5\n", "1\n2\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "树形数据结构", "最近公共祖先 LCA", "KMP 算法", "模板题"], "title": "【模板】失配树", "background": "", "description": "给定一个字符串 $s$，定义它的 **$k$ 前缀** $\\mathit{pre}_k$ 为字符串 $s_{1\\dots k}$，**$k$ 后缀** $\\mathit{suf}_k$ 为字符串 $s_{|s|-k+1\\dots |s|}$，其中 $1 \\le k \\le |s|$。\n\n定义 $\\bold{Border}(s)$ 为**对于 $i \\in [1, |s|)$，满足 $\\mathit{pre}_i = \\mathit{suf}_i$** 的字符串 $\\mathit{pre}_i$ 的集合。$\\bold{Border}(s)$ 中的每个元素都称之为字符串 $s$ 的 $\\operatorname{border}$。\n\n有 $m$ 组询问，每组询问给定 $p,q$，求 $s$ 的 **$\\boldsymbol{p}$ 前缀** 和 **$\\boldsymbol{q}$ 前缀** 的 **最长公共 $\\operatorname{border}$**  的长度。", "inputFormat": "第一行一个字符串 $s$。\n\n第二行一个整数 $m$。\n\n接下来 $m$ 行，每行两个整数 $p,q$。", "outputFormat": "对于每组询问，一行一个整数，表示答案。若不存在公共 $\\operatorname{border}$，请输出 $0$。", "hint": "样例 $2$ 说明：\n\n对于第一个询问，$2$ 前缀和 $18$ 前缀分别是 ``zz`` 和 ``zzaaccaazzccaacczz``，由于 ``zz`` 只有一个 $\\operatorname{border}$，即 ``z``，故最长公共 $\\operatorname{border}$ 长度为 $1$。\n\n---\n\n对于 $16\\%$ 的数据，$s$ 中的字符全部相等。\n\n对于 $100\\%$ 的数据，$1\\leq p,q \\le |s|\\leq 10^6$，$1 \\leq m \\leq 10^5$，$s_i \\in [\\texttt{a}, \\texttt{z}]$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Failure Tree.", "background": "", "description": "Given a string $s$, define its **$k$-prefix** $\\mathit{pre}_k$ as the substring $s_{1\\dots k}$, and its **$k$-suffix** $\\mathit{suf}_k$ as the substring $s_{|s|-k+1\\dots |s|}$, where $1 \\le k \\le |s|$.\n\nDefine $\\bold{Border}(s)$ as the set of strings $\\mathit{pre}_i$ that satisfy **for $i \\in [1, |s|)$, $\\mathit{pre}_i = \\mathit{suf}_i$**. Each element in $\\bold{Border}(s)$ is called a $\\operatorname{border}$ of the string $s$.\n\nThere are $m$ queries. Each query gives $p, q$. Find the length of the **longest common $\\operatorname{border}$** of the **$\\boldsymbol{p}$-prefix** and the **$\\boldsymbol{q}$-prefix** of $s$.", "inputFormat": "The first line contains a string $s$.\n\nThe second line contains an integer $m$.\n\nThe next $m$ lines each contain two integers $p, q$.", "outputFormat": "For each query, output one integer per line, representing the answer. If there is no common $\\operatorname{border}$, output $0$.", "hint": "Explanation for Sample 2:\n\nFor the first query, the $2$-prefix and the $18$-prefix are ``zz`` and ``zzaaccaazzccaacczz``. Since ``zz`` has only one $\\operatorname{border}$, namely ``z``, the length of the longest common $\\operatorname{border}$ is $1$.\n\n---\n\nFor $16\\%$ of the testdata, all characters in $s$ are the same.\n\nFor $100\\%$ of the testdata, $1\\leq p,q \\le |s|\\leq 10^6$, $1 \\leq m \\leq 10^5$, and $s_i \\in [\\texttt{a}, \\texttt{z}]$.\n\nConstraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】失配树", "background": "", "description": "给定一个字符串 $s$，定义它的 **$k$ 前缀** $\\mathit{pre}_k$ 为字符串 $s_{1\\dots k}$，**$k$ 后缀** $\\mathit{suf}_k$ 为字符串 $s_{|s|-k+1\\dots |s|}$，其中 $1 \\le k \\le |s|$。\n\n定义 $\\bold{Border}(s)$ 为**对于 $i \\in [1, |s|)$，满足 $\\mathit{pre}_i = \\mathit{suf}_i$** 的字符串 $\\mathit{pre}_i$ 的集合。$\\bold{Border}(s)$ 中的每个元素都称之为字符串 $s$ 的 $\\operatorname{border}$。\n\n有 $m$ 组询问，每组询问给定 $p,q$，求 $s$ 的 **$\\boldsymbol{p}$ 前缀** 和 **$\\boldsymbol{q}$ 前缀** 的 **最长公共 $\\operatorname{border}$**  的长度。", "inputFormat": "第一行一个字符串 $s$。\n\n第二行一个整数 $m$。\n\n接下来 $m$ 行，每行两个整数 $p,q$。", "outputFormat": "对于每组询问，一行一个整数，表示答案。若不存在公共 $\\operatorname{border}$，请输出 $0$。", "hint": "样例 $2$ 说明：\n\n对于第一个询问，$2$ 前缀和 $18$ 前缀分别是 ``zz`` 和 ``zzaaccaazzccaacczz``，由于 ``zz`` 只有一个 $\\operatorname{border}$，即 ``z``，故最长公共 $\\operatorname{border}$ 长度为 $1$。\n\n---\n\n对于 $16\\%$ 的数据，$s$ 中的字符全部相等。\n\n对于 $100\\%$ 的数据，$1\\leq p,q \\le |s|\\leq 10^6$，$1 \\leq m \\leq 10^5$，$s_i \\in [\\texttt{a}, \\texttt{z}]$。", "locale": "zh-CN"}}}
{"pid": "P5830", "type": "P", "difficulty": 7, "samples": [["见附件", "见附件"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "各省省选", "浙江", "Special Judge"], "title": "[ZJOI2016] 随机树生成器", "background": "附加文件及样例可在页面底部「附件」中下载。", "description": "小 Y 最近有了一个随机数生成器 (random number generator)。小 Y 想用这个随机数生成器生成 $n$ 个节点的树。树为一种没有环的无向连通图。\n\n经过小 Y 的研究，她发现了 $4$ 种随机树生成方法。\n\n第一种方法为首先生成一个 $1$ 到 $n$ 的全排列 $p_1,p_2,…,p_n$。接着对于所有的节点 $i (2 \\leq i \\leq n)$，由 $p_i$ 向 $p_j$ 连一条边，其中 $j$ 是 $1$ 到 $i-1$ 中的随机整数。\n\n第二种方法为首先生成一个 $1$ 到 $n$ 的全排列 $p_1,p_2,…,p_n$。接着对于所有的节点 $i (2 \\leq i \\leq n)$，由 $p_i$ 向 $p_j$ 连一条边，其中 $j$ 是 $\\lfloor \\frac {i}{2} \\rfloor$ 到 $i-1$ 中的随机整数。\n\n第三种方法为首先有一个 $n$ 个点的图，里面没有边。接着等概率地随机生成点对 $u,v$ ，如果当前图中 $u,v$ 不连通，那么将边 $(u,v)$ 加入到图中。重复这个过程，直到这个图连通为止。\n\n第四种方法为在所有 $n$ 个点的不同的有标号的树中，等概率地随机选取一棵树。两个树是不同的当且仅当存在一条边 $(u,v)$ 只出现在其中一棵树中。比如 $(1,2),(1,3)$ 和 $(1,2),(2,3)$ 是两棵不同的树。\n\n小 Y 用这四种方法生成了很多棵 $n$ 个节点的树，但她忘记了这些树分别由哪种方法生成的。你能帮帮她辨认这些树由哪种随机方法生成吗？\n\n在这个题目中令 $n=1000$，也就是小 Y 生成的树的节点个数都为 $1000$。", "inputFormat": "第一行包含 $1$ 个正整数 $T$，表示是**第** $T$ 组测试数据。\n\n接下来一个正整数 $m$，表示有 $m$ 棵树。\n\n对于每棵树，共 $n-1$ 行。每行包含 $2$ 个正整数 $u,v$，表示这棵树中有一条节点 $u$ 与节点 $v$ 之间的边。", "outputFormat": "输出共 $m$ 行，每行一个 $1$ 到 $4$ 之间的正整数，表示这棵树随机生成的方式。", "hint": "对于所有的测试数据，保证输入的树是由上述四种方式随机生成。  \n\n各测试点满足以下约定：   \n\n| 测试点 | $m$ | 约定|\n| --- | --- | --- |\n| 1 | $=2000$ | 只会出现第 $1,2$ 种生成方式 |\n| 2 | $=3000$ | 只会出现第 $1,2,3$ 种生成方式 |\n| 3 | $=3000$ | 只会出现第 $1,3,4$ 种生成方式 |\n| 4 | $=4000$ | 无 |\n| 5 | $=4000$ | 无 |\n\n对于每个测试点，保证每种可能出现的生成方式恰好出现 $1000$ 次。\n\n#### 评分方式\n\n对于每个测试点，有 $10$ 个评分参数 $a_{10},a_9,a_8,…,a_1$。\n\n如果你的输出中错误的答案个数为 $x$, 那么你将获得 $2s$ 的分数，其中 $s$ 为满足 $x \\leq a_s$ 最大的整数。如果 $x>a_1$，那么你将获得 $0$ 分。\n\n如果输出格式有异常你将同样获得 $0$ 分，请确保你的输出中共有 $m$ 行，每行为一个 $1$ 到 $4$ 之间的正整数。\n\n对于每个测试点的具体评分参数见附加文件中的 `scores`。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2016] Random Tree Generator", "background": "The additional files and samples can be downloaded from “Attachments” at the bottom of the page.", "description": "Xiao Y recently got a random number generator (random number generator). Xiao Y wants to use this random number generator to generate a tree with $n$ nodes. A tree is an undirected connected graph with no cycles.\n\nAfter some research, Xiao Y found $4$ random tree generation methods.\n\nThe first method is: first generate a uniformly random permutation $p_1,p_2,\\ldots,p_n$ of $1$ to $n$. Then for every node $i$ $(2 \\leq i \\leq n)$, add an edge from $p_i$ to $p_j$, where $j$ is a random integer from $1$ to $i-1$.\n\nThe second method is: first generate a uniformly random permutation $p_1,p_2,\\ldots,p_n$ of $1$ to $n$. Then for every node $i$ $(2 \\leq i \\leq n)$, add an edge from $p_i$ to $p_j$, where $j$ is a random integer from $\\lfloor \\frac {i}{2} \\rfloor$ to $i-1$.\n\nThe third method is: first start with a graph of $n$ vertices with no edges. Then repeatedly generate a pair of vertices $u,v$ uniformly at random. If $u$ and $v$ are not connected in the current graph, add the edge $(u,v)$ to the graph. Repeat this process until the graph becomes connected.\n\nThe fourth method is: among all different labeled trees on $n$ vertices, choose one uniformly at random. Two trees are different if and only if there exists an edge $(u,v)$ that appears in exactly one of them. For example, $(1,2),(1,3)$ and $(1,2),(2,3)$ are two different trees.\n\nXiao Y generated many trees with $n$ nodes using these four methods, but she forgot which method generated each tree. Can you help her identify which random method generated each tree?\n\nIn this problem, let $n=1000$, meaning every tree generated by Xiao Y has $1000$ nodes.", "inputFormat": "The first line contains $1$ positive integer $T$, indicating the $T$-th set of testdata.\n\nThen an integer $m$, indicating there are $m$ trees.\n\nFor each tree, there are $n-1$ lines. Each line contains $2$ positive integers $u,v$, indicating there is an edge between node $u$ and node $v$ in this tree.", "outputFormat": "Output a total of $m$ lines. Each line contains a positive integer from $1$ to $4$, indicating the random generation method of the corresponding tree.", "hint": "For all testdata, it is guaranteed that the input trees are generated by the four methods above.\n\nEach test point satisfies the following rules.\n\n| Test Point | $m$ | Rule |\n| --- | --- | --- |\n| 1 | $=2000$ | Only methods $1,2$ will appear. |\n| 2 | $=3000$ | Only methods $1,2,3$ will appear. |\n| 3 | $=3000$ | Only methods $1,3,4$ will appear. |\n| 4 | $=4000$ | None. |\n| 5 | $=4000$ | None. |\n\nFor each test point, it is guaranteed that each possible appearing generation method appears exactly $1000$ times.\n\n#### Scoring\n\nFor each test point, there are $10$ scoring parameters $a_{10},a_9,a_8,\\ldots,a_1$.\n\nIf the number of wrong answers in your output is $x$, then you will get a score of $2s$, where $s$ is the largest integer satisfying $x \\leq a_s$. If $x>a_1$, then you will get $0$ points.\n\nIf the output format is abnormal, you will also get $0$ points. Please make sure your output has exactly $m$ lines, and each line is an integer from $1$ to $4$.\n\nFor the specific scoring parameters of each test point, see `scores` in the additional files.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2016] 随机树生成器", "background": "附加文件及样例可在页面底部「附件」中下载。", "description": "小 Y 最近有了一个随机数生成器 (random number generator)。小 Y 想用这个随机数生成器生成 $n$ 个节点的树。树为一种没有环的无向连通图。\n\n经过小 Y 的研究，她发现了 $4$ 种随机树生成方法。\n\n第一种方法为首先生成一个 $1$ 到 $n$ 的全排列 $p_1,p_2,…,p_n$。接着对于所有的节点 $i (2 \\leq i \\leq n)$，由 $p_i$ 向 $p_j$ 连一条边，其中 $j$ 是 $1$ 到 $i-1$ 中的随机整数。\n\n第二种方法为首先生成一个 $1$ 到 $n$ 的全排列 $p_1,p_2,…,p_n$。接着对于所有的节点 $i (2 \\leq i \\leq n)$，由 $p_i$ 向 $p_j$ 连一条边，其中 $j$ 是 $\\lfloor \\frac {i}{2} \\rfloor$ 到 $i-1$ 中的随机整数。\n\n第三种方法为首先有一个 $n$ 个点的图，里面没有边。接着等概率地随机生成点对 $u,v$ ，如果当前图中 $u,v$ 不连通，那么将边 $(u,v)$ 加入到图中。重复这个过程，直到这个图连通为止。\n\n第四种方法为在所有 $n$ 个点的不同的有标号的树中，等概率地随机选取一棵树。两个树是不同的当且仅当存在一条边 $(u,v)$ 只出现在其中一棵树中。比如 $(1,2),(1,3)$ 和 $(1,2),(2,3)$ 是两棵不同的树。\n\n小 Y 用这四种方法生成了很多棵 $n$ 个节点的树，但她忘记了这些树分别由哪种方法生成的。你能帮帮她辨认这些树由哪种随机方法生成吗？\n\n在这个题目中令 $n=1000$，也就是小 Y 生成的树的节点个数都为 $1000$。", "inputFormat": "第一行包含 $1$ 个正整数 $T$，表示是**第** $T$ 组测试数据。\n\n接下来一个正整数 $m$，表示有 $m$ 棵树。\n\n对于每棵树，共 $n-1$ 行。每行包含 $2$ 个正整数 $u,v$，表示这棵树中有一条节点 $u$ 与节点 $v$ 之间的边。", "outputFormat": "输出共 $m$ 行，每行一个 $1$ 到 $4$ 之间的正整数，表示这棵树随机生成的方式。", "hint": "对于所有的测试数据，保证输入的树是由上述四种方式随机生成。  \n\n各测试点满足以下约定：   \n\n| 测试点 | $m$ | 约定|\n| --- | --- | --- |\n| 1 | $=2000$ | 只会出现第 $1,2$ 种生成方式 |\n| 2 | $=3000$ | 只会出现第 $1,2,3$ 种生成方式 |\n| 3 | $=3000$ | 只会出现第 $1,3,4$ 种生成方式 |\n| 4 | $=4000$ | 无 |\n| 5 | $=4000$ | 无 |\n\n对于每个测试点，保证每种可能出现的生成方式恰好出现 $1000$ 次。\n\n#### 评分方式\n\n对于每个测试点，有 $10$ 个评分参数 $a_{10},a_9,a_8,…,a_1$。\n\n如果你的输出中错误的答案个数为 $x$, 那么你将获得 $2s$ 的分数，其中 $s$ 为满足 $x \\leq a_s$ 最大的整数。如果 $x>a_1$，那么你将获得 $0$ 分。\n\n如果输出格式有异常你将同样获得 $0$ 分，请确保你的输出中共有 $m$ 行，每行为一个 $1$ 到 $4$ 之间的正整数。\n\n对于每个测试点的具体评分参数见附加文件中的 `scores`。", "locale": "zh-CN"}}}
{"pid": "P5831", "type": "P", "difficulty": 1, "samples": [["3 4\n4 1 2 3\n4 1 3 2\n4 2 1 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "USACO", "枚举"], "title": "[USACO19DEC] Cow Gymnastics B", "background": "", "description": "为了提高健康水平，奶牛们开始进行体操训练了！Farmer John 选定了他最喜爱的奶牛 Bessie 来执教其他 $N$ 头奶牛，同时评估她们学习不同的体操技术的进度。\n\n$K$ 次训练课的每一次，Bessie 都会根据 $N$ 头奶牛的表现给她们进行排名。之后，她对这些排名的一致性产生了好奇。称一对不同的奶牛是**一致的**，如果其中一头奶牛在每次训练课中都表现得都比另一头要好。\n\n请帮助 Bessie 计算一致的奶牛的对数。", "inputFormat": "输入的第一行包含两个正整数 $K$ 和 $N$。以下 $K$ 行每行包含整数 $1 \\ldots N$ 的某种排列，表示奶牛们的排名（奶牛们用编号 $1 \\ldots N$ 进行区分）。如果在某一行中 $A$ 出现在 $B$ 之前，表示奶牛 $A$ 表现得比奶牛 $B$ 要好。", "outputFormat": "输出一行，包含一致的奶牛的对数。", "hint": "一致的奶牛对为 $(1,4)$、$(2,4)$、$(3,4)$ 和 $(1,3)$。\n\n$1 \\leq K \\leq 10$，$1 \\leq N \\leq 20$。\n\n供题：Nick Wu", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19DEC] Cow Gymnastics B", "background": "", "description": "To improve their health, the cows have started doing gymnastics training. Farmer John chose his favorite cow, Bessie, to coach the other $N$ cows, while also evaluating their progress in learning different gymnastics skills.\n\nIn each of the $K$ training sessions, Bessie ranks the $N$ cows based on their performance. Later, she became curious about how consistent these rankings are. A pair of different cows is called **consistent** if one cow performs better than the other in every training session.\n\nPlease help Bessie count the number of consistent cow pairs.", "inputFormat": "The first line contains two positive integers $K$ and $N$. The next $K$ lines each contain a permutation of the integers $1 \\ldots N$, representing the rankings of the cows (the cows are identified by numbers $1 \\ldots N$). If in a line $A$ appears before $B$, it means cow $A$ performed better than cow $B$.", "outputFormat": "Output one line containing the number of consistent cow pairs.", "hint": "The consistent cow pairs are $(1,4)$, $(2,4)$, $(3,4)$, and $(1,3)$.\n\n$1 \\leq K \\leq 10$, $1 \\leq N \\leq 20$.\n\nProblem by: Nick Wu.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO19DEC] Cow Gymnastics B", "background": "", "description": "为了提高健康水平，奶牛们开始进行体操训练了！Farmer John 选定了他最喜爱的奶牛 Bessie 来执教其他 $N$ 头奶牛，同时评估她们学习不同的体操技术的进度。\n\n$K$ 次训练课的每一次，Bessie 都会根据 $N$ 头奶牛的表现给她们进行排名。之后，她对这些排名的一致性产生了好奇。称一对不同的奶牛是**一致的**，如果其中一头奶牛在每次训练课中都表现得都比另一头要好。\n\n请帮助 Bessie 计算一致的奶牛的对数。", "inputFormat": "输入的第一行包含两个正整数 $K$ 和 $N$。以下 $K$ 行每行包含整数 $1 \\ldots N$ 的某种排列，表示奶牛们的排名（奶牛们用编号 $1 \\ldots N$ 进行区分）。如果在某一行中 $A$ 出现在 $B$ 之前，表示奶牛 $A$ 表现得比奶牛 $B$ 要好。", "outputFormat": "输出一行，包含一致的奶牛的对数。", "hint": "一致的奶牛对为 $(1,4)$、$(2,4)$、$(3,4)$ 和 $(1,3)$。\n\n$1 \\leq K \\leq 10$，$1 \\leq N \\leq 20$。\n\n供题：Nick Wu", "locale": "zh-CN"}}}
