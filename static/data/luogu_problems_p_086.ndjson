{"pid": "P2744", "type": "P", "difficulty": 5, "samples": [["16\r\n3\r\n3\r\n5\r\n7", "2 3 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "USACO", "深度优先搜索 DFS"], "title": "[USACO5.3] 量取牛奶Milk Measuring", "background": "", "description": "农夫约翰要量取 $Q$（$1 \\le Q \\le 20,000$）夸脱（译注：即 quarts，容积单位）他的最好的牛奶，并把它装入一个大瓶子中卖出。消费者要多少，他就给多少，从不有任何误差。\n\n农夫约翰总是很节约。他现在在奶牛五金商店购买一些桶，用来从他的巨大的牛奶池中量出 $Q$ 夸脱的牛奶。每个桶的价格一样。你的任务是计算出一个农夫约翰可以购买的最少的桶的集合，使得能够刚好用这些桶量出 $Q$ 夸脱的牛奶。另外，由于农夫约翰必须把这些桶搬回家，对于给出的两个极小桶集合，他会选择“更小的”一个，即：把这两个集合按升序排序，比较第一个桶，选择第一个桶容积较小的一个。如果第一个桶相同，比较第二个桶，也按上面的方法选择。否则继续这样的工作，直到相比较的两个桶不一致为止。例如，集合 $\\{3,5,7,100\\}$ 比集合 $\\{3,6,7,8\\}$ 要好。\n\n为了量出牛奶，农夫约翰可以从牛奶池把桶装满，然后倒进瓶子。他决不把瓶子里的牛奶倒出来或者把桶里的牛奶倒到别处。用一个容积为 $1$ 夸脱的桶，农夫约翰可以只用这个桶量出所有可能的夸脱数。其它的桶的组合没有这么方便。\n\n计算需要购买的最佳桶集，保证所有的测试数据都至少有一个解。", "inputFormat": "第一行一个整数 $Q$。\n\n第二行一个整数 $P\\ (1 \\le  P \\le 100)$，表示商店里桶的数量。\n\n第 $3$ 至第 $P+2$ 行，每行一个整数 $h_i$ 表示第 $i$ 个桶的容积。$(1\\le h_i\\le 10^4)$。\n", "outputFormat": "输出文件只有一行，由空格分开的整数组成：\n\n为了量出想要的夸脱数，需要购买的最少的桶的数量，接着是：\n\n一个排好序的列表（从小到大），表示需要购买的每个桶的容积\n", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 5.3\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO5.3] Milk Measuring", "background": "", "description": "Farmer John wants to measure $Q$ (1 ≤ Q ≤ 20,000) quarts of his finest milk and put it into a large bottle to sell. He always gives exactly what the customer wants, without any error.\n\nFarmer John is very frugal. He is now buying some buckets at the cow hardware store to measure out $Q$ quarts from his huge pool of milk. Each bucket costs the same. Your task is to compute the smallest set of buckets he can buy such that, using only these buckets, he can measure exactly $Q$ quarts. Additionally, because he must carry them home, among two minimal bucket sets, he chooses the “smaller” one: sort both sets in ascending order, compare the first bucket; choose the set whose first bucket has the smaller capacity. If the first bucket is equal, compare the second, and so on, until they differ. For example, the set $\\{3,5,7,100\\}$ is better than the set $\\{3,6,7,8\\}$.\n\nTo measure the milk, Farmer John may fill a bucket from the pool and pour it into the bottle. He never pours milk out of the bottle, nor does he pour a bucket’s milk anywhere else. With a $1$-quart bucket, Farmer John can measure all possible numbers of quarts using only that bucket. Other bucket combinations are not so convenient.\n\nCompute the best set of buckets to purchase. It is guaranteed that all testdata have at least one solution.", "inputFormat": "The first line contains an integer $Q$.\n\nThe second line contains an integer $P$ (1 ≤ P ≤ 100), the number of buckets available in the store.\n\nLines $3$ through $P+2$ each contain an integer $h_i$ representing the capacity of the $i$-th bucket. $(1\\le h_i\\le 10^4)$.", "outputFormat": "Output exactly one line of space-separated integers:\n\nFirst, the minimum number of buckets needed to measure the desired number of quarts, followed by:\n\na sorted list (in increasing order) of the capacities of the buckets to purchase.", "hint": "Translation source: NOCOW.\n\nUSACO Training Section 5.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO5.3] 量取牛奶Milk Measuring", "background": "", "description": "农夫约翰要量取 $Q$（$1 \\le Q \\le 20,000$）夸脱（译注：即 quarts，容积单位）他的最好的牛奶，并把它装入一个大瓶子中卖出。消费者要多少，他就给多少，从不有任何误差。\n\n农夫约翰总是很节约。他现在在奶牛五金商店购买一些桶，用来从他的巨大的牛奶池中量出 $Q$ 夸脱的牛奶。每个桶的价格一样。你的任务是计算出一个农夫约翰可以购买的最少的桶的集合，使得能够刚好用这些桶量出 $Q$ 夸脱的牛奶。另外，由于农夫约翰必须把这些桶搬回家，对于给出的两个极小桶集合，他会选择“更小的”一个，即：把这两个集合按升序排序，比较第一个桶，选择第一个桶容积较小的一个。如果第一个桶相同，比较第二个桶，也按上面的方法选择。否则继续这样的工作，直到相比较的两个桶不一致为止。例如，集合 $\\{3,5,7,100\\}$ 比集合 $\\{3,6,7,8\\}$ 要好。\n\n为了量出牛奶，农夫约翰可以从牛奶池把桶装满，然后倒进瓶子。他决不把瓶子里的牛奶倒出来或者把桶里的牛奶倒到别处。用一个容积为 $1$ 夸脱的桶，农夫约翰可以只用这个桶量出所有可能的夸脱数。其它的桶的组合没有这么方便。\n\n计算需要购买的最佳桶集，保证所有的测试数据都至少有一个解。", "inputFormat": "第一行一个整数 $Q$。\n\n第二行一个整数 $P\\ (1 \\le  P \\le 100)$，表示商店里桶的数量。\n\n第 $3$ 至第 $P+2$ 行，每行一个整数 $h_i$ 表示第 $i$ 个桶的容积。$(1\\le h_i\\le 10^4)$。\n", "outputFormat": "输出文件只有一行，由空格分开的整数组成：\n\n为了量出想要的夸脱数，需要购买的最少的桶的数量，接着是：\n\n一个排好序的列表（从小到大），表示需要购买的每个桶的容积\n", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 5.3\n", "locale": "zh-CN"}}}
{"pid": "P2745", "type": "P", "difficulty": 5, "samples": [["w(a,10,132,20,12)\r\nw(b,8,76,124,15)\r\ns(a)", "49.167"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["USACO"], "title": "[USACO5.3] 窗体面积Window Area", "background": null, "description": "你刚刚接手一项窗体界面工程。窗体界面还算简单，而且幸运的是，你不必显示实际的窗体。有 $5$ 种基本操作：\n- 创建一个新窗体；\n- 将窗体置顶；\n- 将窗体置底；\n- 删除一个窗体；\n- 输出窗体可见部分的百分比（就是，不被其它窗体覆盖的部分）。", "inputFormat": "在输入文件中，操作（不超过 $600$ 个）以如下的格式出现，每行一个。\n\n- 创建一个新窗体：`w(I,x,y,X,Y)`；\n- 将窗体置顶：`t(I)`；\n- 将窗体置底：`b(I)`；\n- 删除一个窗体：`d(I)`；\n- 输出窗体可见部分的百分比：`s(I)`。\n\n`I` 是每个窗体唯一的标识符，标识符可以是大小写字母或单个数字字符。输入文件中没有多余的空格。\n\n$(x,y)$ 和 $(X,Y)$ 是窗体的对角。当你创建一个窗体的时候，它自动被“置顶”。你不能用已经存在的标识符来创建窗体，但是你可以删除一个窗体后再用已删除窗体的标识符来创建窗体。坐标用正整数来表示，并且所有的窗体面积都不为 $0$（即 $x\\ne X$ 且 $y\\ne Y$）。$x$ 坐标和 $y$ 坐标在 $[1,2^{15}-1]$ 的范围内。\n\n当输入文件结束时，停止程序。", "outputFormat": "只对于 `s(I)` 命令进行输出。当然，输入文件可能有许多 `s(I)` 命令（不超过 $500$ 次），所以输出文件应该是一个百分比的序列，每行一个，百分比是窗体可见部分的百分比。百分比应该四舍五入到三位小数（不用输出百分号 `%`）。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 5.3。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO5.3] Window Area", "background": "", "description": "You have just taken over a window system project. The window system is fairly simple, and fortunately, you do not have to display the actual windows. There are $5$ basic operations:\n- Create a new window.\n- Bring a window to the top.\n- Send a window to the bottom.\n- Delete a window.\n- Output the percentage of the window that is visible (i.e., not covered by other windows).", "inputFormat": "In the input file, operations (no more than $600$ of them) appear one per line in the following formats:\n\n- Create a new window: `w(I,x,y,X,Y)`.\n- Bring a window to the top: `t(I)`.\n- Send a window to the bottom: `b(I)`.\n- Delete a window: `d(I)`.\n- Output the percentage of the window that is visible: `s(I)`.\n\n$I$ is the unique identifier of each window. An identifier is a letter (uppercase or lowercase) or a single digit. There are no extra spaces in the input file.\n\n$(x,y)$ and $(X,Y)$ are opposite corners of the window. When you create a window, it is automatically placed on the top. You cannot create a window using an existing identifier, but after deleting a window you may reuse its identifier. Coordinates are positive integers, and every window has nonzero area (i.e., $x \\ne X$ and $y \\ne Y$). The $x$- and $y$-coordinates are in the range $[1,2^{15}-1]$.\n\nStop processing at end of file.", "outputFormat": "Produce output only for the `s(I)` commands. There may be many `s(I)` commands (no more than $500$). Output a sequence of percentages, one per line, each being the percentage of the window that is visible. Percentages must be rounded to three decimal places (do not print the percent sign `%`).", "hint": "Translation from NOCOW.\n\nUSACO Training Section 5.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO5.3] 窗体面积Window Area", "background": null, "description": "你刚刚接手一项窗体界面工程。窗体界面还算简单，而且幸运的是，你不必显示实际的窗体。有 $5$ 种基本操作：\n- 创建一个新窗体；\n- 将窗体置顶；\n- 将窗体置底；\n- 删除一个窗体；\n- 输出窗体可见部分的百分比（就是，不被其它窗体覆盖的部分）。", "inputFormat": "在输入文件中，操作（不超过 $600$ 个）以如下的格式出现，每行一个。\n\n- 创建一个新窗体：`w(I,x,y,X,Y)`；\n- 将窗体置顶：`t(I)`；\n- 将窗体置底：`b(I)`；\n- 删除一个窗体：`d(I)`；\n- 输出窗体可见部分的百分比：`s(I)`。\n\n`I` 是每个窗体唯一的标识符，标识符可以是大小写字母或单个数字字符。输入文件中没有多余的空格。\n\n$(x,y)$ 和 $(X,Y)$ 是窗体的对角。当你创建一个窗体的时候，它自动被“置顶”。你不能用已经存在的标识符来创建窗体，但是你可以删除一个窗体后再用已删除窗体的标识符来创建窗体。坐标用正整数来表示，并且所有的窗体面积都不为 $0$（即 $x\\ne X$ 且 $y\\ne Y$）。$x$ 坐标和 $y$ 坐标在 $[1,2^{15}-1]$ 的范围内。\n\n当输入文件结束时，停止程序。", "outputFormat": "只对于 `s(I)` 命令进行输出。当然，输入文件可能有许多 `s(I)` 命令（不超过 $500$ 次），所以输出文件应该是一个百分比的序列，每行一个，百分比是窗体可见部分的百分比。百分比应该四舍五入到三位小数（不用输出百分号 `%`）。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 5.3。", "locale": "zh-CN"}}}
{"pid": "P2746", "type": "P", "difficulty": 4, "samples": [["5\n2 4 3 0\n4 5 0\n0\n0\n1 0", "1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["USACO", "IOI", "强连通分量", "Tarjan", "1996"], "title": "[IOI 1996 / USACO5.3] 校园网 Network of Schools", "background": null, "description": "有一些学校会向其他学校分享软件，即如果这个学校得到了软件，那么在分享列表中的学校也会得到软件。注意这种关系是单向的，即如果 $a$ 在 $b$ 的列表中，那么 $b$ 不一定在 $a$ 的列表中。\n\n现在，你需要向其中一些学校下发新软件。为了节约下发软件的成本，你需要回答以下两个问题。\n1. 至少需要向几个学校下发新软件，可以使得所有学校均获得新软件。\n2. 定义一次扩展为在某个学校的分享列表中增加一个学校。至少需要进行几次扩展，才可以使得无论对哪个学校**仅下发一次软件**就可以使得所有学校获得新软件。\n\n两个问题相互独立。", "inputFormat": "输入文件的第一行包括一个正整数 $N$，表示学校数目。学校的编号为数字 $1$ 到 $N$。\n\n接下来 $N$ 行，每行都表示一个分享列表，第 $i+1$ 行为学校 $i$ 的分享列表中的学校编号。每个列表用 $0$ 结束，空列表只用一个 $0$ 表示。", "outputFormat": "你的程序应该在输出文件中输出两行。\n\n第一行应该包括一个正整数，表示问题 $1$ 的解。\n\n第二行应该包括一个非负整数，表示问题 $2$ 的解。", "hint": "$2 \\le N \\le 100$。\n\n题目翻译来自 NOCOW。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1996 / USACO5.3] Network of Schools", "background": "", "description": "Some schools share software with other schools; that is, if a school obtains the software, then all schools in its sharing list will also obtain the software. Note that this relation is directed: if $a$ is in $b$'s list, then $b$ is not necessarily in $a$'s list.\n\nNow you need to distribute new software to some of the schools. To minimize the distribution cost, answer the following two questions.\n1. What is the minimum number of schools to which you must distribute the software so that all schools obtain the new software?\n2. Define one expansion as adding one school to the sharing list of some school. What is the minimum number of expansions needed so that, no matter which single school you initially distribute the software to, all schools will obtain the new software?\n\nThe two questions are independent.", "inputFormat": "The first line of input contains a positive integer $N$, the number of schools. The schools are numbered from $1$ to $N$.\n\nEach of the next $N$ lines describes a sharing list. Line $i+1$ lists the school IDs in the sharing list of school $i$. Each list is terminated by a $0$; an empty list is represented by a single $0$.", "outputFormat": "Output two lines.\n\nThe first line should contain a positive integer, the answer to Question 1.\n\nThe second line should contain a non-negative integer, the answer to Question 2.", "hint": "Constraints: $2 \\le N \\le 100$.\n\nThis translation is from NOCOW.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1996 / USACO5.3] 校园网 Network of Schools", "background": null, "description": "有一些学校会向其他学校分享软件，即如果这个学校得到了软件，那么在分享列表中的学校也会得到软件。注意这种关系是单向的，即如果 $a$ 在 $b$ 的列表中，那么 $b$ 不一定在 $a$ 的列表中。\n\n现在，你需要向其中一些学校下发新软件。为了节约下发软件的成本，你需要回答以下两个问题。\n1. 至少需要向几个学校下发新软件，可以使得所有学校均获得新软件。\n2. 定义一次扩展为在某个学校的分享列表中增加一个学校。至少需要进行几次扩展，才可以使得无论对哪个学校**仅下发一次软件**就可以使得所有学校获得新软件。\n\n两个问题相互独立。", "inputFormat": "输入文件的第一行包括一个正整数 $N$，表示学校数目。学校的编号为数字 $1$ 到 $N$。\n\n接下来 $N$ 行，每行都表示一个分享列表，第 $i+1$ 行为学校 $i$ 的分享列表中的学校编号。每个列表用 $0$ 结束，空列表只用一个 $0$ 表示。", "outputFormat": "你的程序应该在输出文件中输出两行。\n\n第一行应该包括一个正整数，表示问题 $1$ 的解。\n\n第二行应该包括一个非负整数，表示问题 $2$ 的解。", "hint": "$2 \\le N \\le 100$。\n\n题目翻译来自 NOCOW。", "locale": "zh-CN"}}}
{"pid": "P2747", "type": "P", "difficulty": 5, "samples": [["8 9\nVancouver\nYellowknife\nEdmonton\nCalgary\nWinnipeg\nToronto\nMontreal\nHalifax\nVancouver Edmonton\nVancouver Calgary\nCalgary Winnipeg\nWinnipeg Toronto\nToronto Halifax\nMontreal Halifax\nEdmonton Montreal\nEdmonton Yellowknife\nEdmonton Calgary", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "搜索", "USACO"], "title": "[USACO5.4] 周游加拿大 Canada Tour", "background": null, "description": "你赢得了一场航空公司举办的比赛，奖品是一张加拿大环游机票。旅行在这家航空公司开放的最西边的城市开始，然后一直自西向东旅行，直到你到达最东边的城市，再由东向西返回，直到你回到开始的城市。除了旅行开始的城市之外，每个城市只能访问一次，因为开始的城市必定要被访问两次（在旅行的开始和结束）。\n\n当然不允许使用其他公司的航线或者用其他的交通工具。\n\n给出这个航空公司开放的城市的列表，和两两城市之间的直达航线列表。找出能够访问尽可能多的城市的路线，这条路线必须满足上述条件，也就是从列表中的第一个城市开始旅行，访问到列表中最后一个城市之后再返回第一个城市。", "inputFormat": "第 $1$ 行：航空公司开放的城市数 $N$ 和将要列出的直达航线的数量 $V$。$N$ 是一个不大于 $100$ 的正整数。$V$ 是任意的正整数。\n\n第 $2\\sim N+1$ 行：每行包括一个航空公司开放的城市名称。城市名称按照自西向东排列。不会出现两个城市在同一条经线上的情况。每个城市的名称都是一个字符串，最多 $15$ 字节，由拉丁字母表上的字母组成；城市名称中没有空格。\n\n第 $N+2\\sim N+2+V-1$ 行：每行包括两个城市名称（由上面列表中的城市名称组成），用一个空格分开。这样就表示两个城市之间的直达双程航线。", "outputFormat": "第 $1$ 行：按照最佳路线访问的不同城市的数量 $M$。如果无法找到路线，输出 `1`。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 5.4", "locale": "zh-CN", "translations": {"en": {"title": "[USACO5.4] Canada Tour", "background": "", "description": "You have won a contest held by an airline, and the prize is a ticket for a tour of Canada. The trip starts at the westernmost city served by this airline, then you keep traveling from west to east until you reach the easternmost city, and then travel from east to west back to the starting city. Except for the starting city, each city may be visited at most once, because the starting city must be visited twice (at the beginning and at the end).\n\nYou are not allowed to use flights of other airlines or any other means of transportation.\n\nGiven the list of cities served by this airline and the list of direct flights between pairs of cities, find a route that visits as many cities as possible while satisfying the above conditions. In other words, you must start from the first city in the list, reach the last city in the list, and then return to the first city.", "inputFormat": "Line $1$: The number of cities served by the airline $N$ and the number of direct flights to be listed $V$. $N$ is a positive integer not greater than $100$. $V$ is any positive integer.\n\nLines $2 \\sim N+1$: Each line contains the name of a city served by the airline. The cities are listed from west to east. No two cities lie on the same meridian. Each city name is a string of at most $15$ bytes, consisting of letters of the Latin alphabet; city names contain no spaces.\n\nLines $N+2 \\sim N+2+V-1$: Each line contains two city names (chosen from the list above), separated by a space, indicating a bidirectional direct flight between the two cities.", "outputFormat": "Line $1$: $M$, the number of distinct cities visited by the optimal route. If no route can be found, output `1`.", "hint": "The problem statement is translated from NOCOW.\nUSACO Training Section 5.4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO5.4] 周游加拿大 Canada Tour", "background": null, "description": "你赢得了一场航空公司举办的比赛，奖品是一张加拿大环游机票。旅行在这家航空公司开放的最西边的城市开始，然后一直自西向东旅行，直到你到达最东边的城市，再由东向西返回，直到你回到开始的城市。除了旅行开始的城市之外，每个城市只能访问一次，因为开始的城市必定要被访问两次（在旅行的开始和结束）。\n\n当然不允许使用其他公司的航线或者用其他的交通工具。\n\n给出这个航空公司开放的城市的列表，和两两城市之间的直达航线列表。找出能够访问尽可能多的城市的路线，这条路线必须满足上述条件，也就是从列表中的第一个城市开始旅行，访问到列表中最后一个城市之后再返回第一个城市。", "inputFormat": "第 $1$ 行：航空公司开放的城市数 $N$ 和将要列出的直达航线的数量 $V$。$N$ 是一个不大于 $100$ 的正整数。$V$ 是任意的正整数。\n\n第 $2\\sim N+1$ 行：每行包括一个航空公司开放的城市名称。城市名称按照自西向东排列。不会出现两个城市在同一条经线上的情况。每个城市的名称都是一个字符串，最多 $15$ 字节，由拉丁字母表上的字母组成；城市名称中没有空格。\n\n第 $N+2\\sim N+2+V-1$ 行：每行包括两个城市名称（由上面列表中的城市名称组成），用一个空格分开。这样就表示两个城市之间的直达双程航线。", "outputFormat": "第 $1$ 行：按照最佳路线访问的不同城市的数量 $M$。如果无法找到路线，输出 `1`。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 5.4", "locale": "zh-CN"}}}
{"pid": "P2748", "type": "P", "difficulty": 5, "samples": [["4 100 200 1\n1 4\n2 3\n3 2\n4 0", "210"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["数学", "贪心", "2016", "USACO"], "title": "[USACO16OPEN] Landscaping P", "background": "*本题与 [2012 年 3 月月赛银组同名题目](/problem/P3049) 在题意上一致，唯一的差别是数据范围。*", "description": "Farmer John 打算修建一座花园，他需要移动不少泥土。\n\n花园由 $N$ 个花坛组成（$1 \\leq N \\leq 10^5$），其中花坛 $i$ 包含 $A_i$ 单位的泥土。FJ 希望花坛 $i$ 包含 $B_i$ 单位的泥土，保证 $0 \\leq A_i,B_i \\leq 10$。\n\n为了达到这个目标，他可以做这几件事情：\n\n- 购买一单位的泥土，放在指定的花坛中，费用为 $X$。\n- 从任意一个花坛中移走一单位泥土，费用为 $Y$。\n- 从花坛 $i$ 运送一单位泥土到花坛 $j$，费用为 $Z|i-j|$。\n\n请你帮 FJ 计算移动泥土的最小开销。", "inputFormat": "第一行四个整数 $N,X,Y,Z$（$0 \\leq X,Y \\leq 10^8$，$0 \\leq Z \\leq 1000$）。\n\n接下来 $N$ 行，第 $i$ 行两个整数 $A_i,B_i$。", "outputFormat": "输出移动泥土的最小开销。", "hint": "按下面的方案，最小花费为 $210$，可以证明不存在开销更小的方案。\n\n- 移除 $4$ 号花坛的一单位泥土，花费 $200$。\n- 将 $4$ 号花坛的三单位泥土移到 $1$ 号花坛，花费 $3 \\times 3=9$。\n- 将 $3$ 号花坛的一单位泥土移到 $2$ 号花坛，花费 $1 \\times 1=1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO16OPEN] Landscaping P", "background": "*本题与 [2012 年 3 月月赛银组同名题目](/problem/P3049) 在题意上一致，唯一的差别是数据范围。*", "description": "Farmer John 打算修建一座花园，他需要移动不少泥土。\n\n花园由 $N$ 个花坛组成（$1 \\leq N \\leq 10^5$），其中花坛 $i$ 包含 $A_i$ 单位的泥土。FJ 希望花坛 $i$ 包含 $B_i$ 单位的泥土，保证 $0 \\leq A_i,B_i \\leq 10$。\n\n为了达到这个目标，他可以做这几件事情：\n\n- 购买一单位的泥土，放在指定的花坛中，费用为 $X$。\n- 从任意一个花坛中移走一单位泥土，费用为 $Y$。\n- 从花坛 $i$ 运送一单位泥土到花坛 $j$，费用为 $Z|i-j|$。\n\n请你帮 FJ 计算移动泥土的最小开销。", "inputFormat": "第一行四个整数 $N,X,Y,Z$（$0 \\leq X,Y \\leq 10^8$，$0 \\leq Z \\leq 1000$）。\n\n接下来 $N$ 行，第 $i$ 行两个整数 $A_i,B_i$。", "outputFormat": "输出移动泥土的最小开销。", "hint": "按下面的方案，最小花费为 $210$，可以证明不存在开销更小的方案。\n\n- 移除 $4$ 号花坛的一单位泥土，花费 $200$。\n- 将 $4$ 号花坛的三单位泥土移到 $1$ 号花坛，花费 $3 \\times 3=9$。\n- 将 $3$ 号花坛的一单位泥土移到 $2$ 号花坛，花费 $1 \\times 1=1$。", "locale": "zh-CN"}}}
{"pid": "P2749", "type": "P", "difficulty": 4, "samples": [["23\n15\n10001000000000010000000\n01111100011111000101101\n01000000010001000111111\n00000000010101000101111\n00000111010001000000000\n00001001011111000000000\n10000001000000000000000\n00101000000111110010000\n00001000000100010011111\n00000001110101010100010\n00000100110100010000000\n00010001110111110000000\n00100001110000000100000\n00001000100001000100101\n00000001110001000111000", "a000a0000000000b0000000\n0aaaaa000ccccc000d0dd0d\n0a0000000c000c000dddddd\n000000000c0b0c000d0dddd\n00000eee0c000c000000000\n0000e00e0ccccc000000000\nb000000e000000000000000\n00b0f000000ccccc00a0000\n0000f000000c000c00aaaaa\n0000000ddd0c0b0c0a000a0\n00000b00dd0c000c0000000\n000g000ddd0ccccc0000000\n00g0000ddd0000000e00000\n0000b000d0000f000e00e0b\n0000000ddd000f000eee000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["1998", "USACO", "IOI", "枚举", "广度优先搜索 BFS"], "title": "[IOI 1998 / USACO5.1] 夜空繁星 Starry Night", "background": "高高的星空，簇簇闪耀的群星形态万千。一个星座 **(cluster)** 是一群连通的星组成的非空连通星系，这里的连通是指水平，垂直或者对角相邻的两个星星。一个星座不能是另一个更大星座的一部分，星座可以相似 **(similar)**。如果两个星座有相同的形状，而且包括相同数目的星体，那么不管其方向性如何，就算相似。一般而言，星座可能的方向有八个，如图 $1$ 所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/1970.png)", "description": "夜空可以表示为一份天体图 **(sky map)**，它是一个由字符 `0` 和 `1` 组成的二维矩阵，字符 `1` 表示所在的位置有一颗星；字符 `0` 表示该位置上是空的。\n\n给定一份天体图，用同一个小写英文标识 **(mark)** 相似的所有星座。\n\n相似的星座必须用相同的字母标识，不同的星座表示为不同的字母。标识一个星座，就是将其中各星体对应的字符 `1` 替换为相应的小写字母。", "inputFormat": "文件的前两行分别记录了天体图的宽度 $W$、深度 $H$。而天体图则是由接下来的 $H$ 行表示，每行包括 $W$ 个字符。", "outputFormat": "输出标记了星座后的天体图（与输入文件相似，不同之处在于，标识 **(mark)** 了各个星座）。\n\n对于同一个输入文件，可能会有很多不同的标识，此时，输出字典序最小的标识。", "hint": "### 样例解释\n\n此时的天体图是一个长 $23$ 宽 $15$ 的二维矩阵。\n\n输入对应 **(corresponds to)** 下面这个矩阵的图像。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1971.png) \n\n输出对应 **(corresponds to)** 下面的天空景象。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1972.png) \n\n### 数据范围\n\n- $0\\le$ 星空的长和宽 $\\le100$；\n- $0\\le$ 星座个数 $\\le500$；\n- $0\\le$ 不相似的星座个数 $\\le26$；\n- $1\\le$ 每个星座中星星个数 $\\le160$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1998 / USACO5.1] Starry Night", "background": "High in the night sky, clusters of shining stars form countless shapes. A cluster is a non-empty connected group of stars, where connectivity means two stars are adjacent horizontally, vertically, or diagonally (8-neighbor connectivity). A cluster cannot be part of a larger cluster. Clusters can be similar. If two clusters have the same shape and contain the same number of stars, then regardless of their orientation, they are considered similar. In general, there are eight possible orientations for a cluster, as shown in Figure $1$.\n\n![](https://cdn.luogu.com.cn/upload/pic/1970.png)", "description": "The night sky can be represented as a sky map, which is a 2D matrix of characters `0` and `1`. A character `1` indicates there is a star at that position; a character `0` indicates the position is empty.\n\nGiven a sky map, use the same lowercase English letter to mark all similar clusters.\n\nSimilar clusters must be marked with the same letter, and different clusters must be marked with different letters. To mark a cluster, replace each `1` corresponding to a star in that cluster with the appropriate lowercase letter.", "inputFormat": "The first two lines contain the width $W$ and the height $H$ of the sky map, respectively. The sky map then follows in the next $H$ lines, each containing $W$ characters.", "outputFormat": "Output the sky map after marking the clusters (in the same format as the input, except that clusters are marked).\n\nFor the same input, there may be many valid markings; in that case, output the lexicographically smallest marking.", "hint": "### Sample Explanation\n\nIn this case, the sky map is a 2D matrix with length $23$ and width $15$.\n\nThe input corresponds to the following image of the matrix.\n\n![](https://cdn.luogu.com.cn/upload/pic/1971.png)\n\nThe output corresponds to the following view of the night sky.\n\n![](https://cdn.luogu.com.cn/upload/pic/1972.png)\n\n### Constraints\n\n- $0 \\le$ the length and width of the sky map $\\le 100$.\n- $0 \\le$ the number of clusters $\\le 500$.\n- $0 \\le$ the number of dissimilar clusters $\\le 26$.\n- $1 \\le$ the number of stars in each cluster $\\le 160$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1998 / USACO5.1] 夜空繁星 Starry Night", "background": "高高的星空，簇簇闪耀的群星形态万千。一个星座 **(cluster)** 是一群连通的星组成的非空连通星系，这里的连通是指水平，垂直或者对角相邻的两个星星。一个星座不能是另一个更大星座的一部分，星座可以相似 **(similar)**。如果两个星座有相同的形状，而且包括相同数目的星体，那么不管其方向性如何，就算相似。一般而言，星座可能的方向有八个，如图 $1$ 所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/1970.png)", "description": "夜空可以表示为一份天体图 **(sky map)**，它是一个由字符 `0` 和 `1` 组成的二维矩阵，字符 `1` 表示所在的位置有一颗星；字符 `0` 表示该位置上是空的。\n\n给定一份天体图，用同一个小写英文标识 **(mark)** 相似的所有星座。\n\n相似的星座必须用相同的字母标识，不同的星座表示为不同的字母。标识一个星座，就是将其中各星体对应的字符 `1` 替换为相应的小写字母。", "inputFormat": "文件的前两行分别记录了天体图的宽度 $W$、深度 $H$。而天体图则是由接下来的 $H$ 行表示，每行包括 $W$ 个字符。", "outputFormat": "输出标记了星座后的天体图（与输入文件相似，不同之处在于，标识 **(mark)** 了各个星座）。\n\n对于同一个输入文件，可能会有很多不同的标识，此时，输出字典序最小的标识。", "hint": "### 样例解释\n\n此时的天体图是一个长 $23$ 宽 $15$ 的二维矩阵。\n\n输入对应 **(corresponds to)** 下面这个矩阵的图像。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1971.png) \n\n输出对应 **(corresponds to)** 下面的天空景象。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1972.png) \n\n### 数据范围\n\n- $0\\le$ 星空的长和宽 $\\le100$；\n- $0\\le$ 星座个数 $\\le500$；\n- $0\\le$ 不相似的星座个数 $\\le26$；\n- $1\\le$ 每个星座中星星个数 $\\le160$。", "locale": "zh-CN"}}}
{"pid": "P2750", "type": "P", "difficulty": 6, "samples": [["N\n2", "ABCDEFGHIJKLMNOPQRSUTVWXY"], ["W \nABCDEFGHIJKLMNOPQRSUTVWXY", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2001", "USACO", "IOI", "深度优先搜索 DFS"], "title": "[IOI 2001 / USACO5.5] 贰五语言 Two Five", "background": null, "description": "有一种奇怪的语言叫做“贰五语言”。它的每个单词都由 `A` 至 `Y` 这 $25$ 个字母各一个组成。但是，并不是任何一种排列都是一个合法的贰五语言单词。贰五语言的单词必须满足这样一个条件：把它的 $25$ 个字母排成一个 $5\\times 5$ 的矩阵，它的每一行和每一列都必须是递增的。比如单词 `ACEPTBDHQUFJMRWGKNSXILOVY`，它排成的矩阵如下所示：\n```plain\nACEPT\nBDHQU\nFJMRW\nGKNSX\nILOVY\n```\n\n因为它的每行每列都是递增的，所以它是一个合法的单词。而单词 `YXWVUTSRQPONMLKJIHGFEDCBA` 则显然不合法。由于单词太长存储不便，需要给每一个单词编一个码。编码方法如下：从左到右，再从上到下，可以由一个矩阵的得到一个单词，再把单词按照字典顺序排序。比如，单词 `ABCDEFGHIJKLMNOPQRSTUVWXY` 的编码为 $1$，而单词 `ABCDEFGHIJKLMNOPQRSUTVWXY` 的编码为 $2$。\n\n现在，你需要编一个程序，完成单词与编码间的转换。", "inputFormat": "第一行为一个字母 `N` 或 `W`。`N` 表示把编码转换为单词，`W` 表示把单词转换为编码。\n\n若第一行为 `N`，则第二行为一个整数，表示单词的编码。若第一行为 `W`，则第二行为一个合法的单词。", "outputFormat": "每行一个整数或单词。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 5.5。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2001 / USACO5.5] Two Five", "background": "", "description": "There is a strange language called the “Two Five” language. Each of its words consists of exactly one of each of the 25 letters from `A` to `Y`. However, not every permutation is a valid word in this language. A word is valid if, when its 25 letters are arranged into a $5\\times 5$ matrix, every row and every column is strictly increasing. For example, the word `ACEPTBDHQUFJMRWGKNSXILOVY` forms the following matrix:\n```plain\nACEPT\nBDHQU\nFJMRW\nGKNSX\nILOVY\n```\nSince every row and column is strictly increasing, it is a valid word. The word `YXWVUTSRQPONMLKJIHGFEDCBA` is clearly invalid.\n\nBecause words are too long to store conveniently, we assign a code to each word. The coding method is as follows: read a matrix from left to right and then from top to bottom to obtain a word; then sort the words in lexicographic order. For example, the word `ABCDEFGHIJKLMNOPQRSTUVWXY` has code $1$, and the word `ABCDEFGHIJKLMNOPQRSUTVWXY` has code $2$.\n\nNow you need to write a program to convert between words and their codes.", "inputFormat": "The first line contains a letter `N` or `W`. `N` means converting a code to a word, and `W` means converting a word to a code.\n\nIf the first line is `N`, then the second line contains an integer representing the word’s code. If the first line is `W`, then the second line contains a valid word.", "outputFormat": "Each line contains one integer or word.", "hint": "The statement is translated from NOCOW.\n\nUSACO Training Section 5.5.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2001 / USACO5.5] 贰五语言 Two Five", "background": null, "description": "有一种奇怪的语言叫做“贰五语言”。它的每个单词都由 `A` 至 `Y` 这 $25$ 个字母各一个组成。但是，并不是任何一种排列都是一个合法的贰五语言单词。贰五语言的单词必须满足这样一个条件：把它的 $25$ 个字母排成一个 $5\\times 5$ 的矩阵，它的每一行和每一列都必须是递增的。比如单词 `ACEPTBDHQUFJMRWGKNSXILOVY`，它排成的矩阵如下所示：\n```plain\nACEPT\nBDHQU\nFJMRW\nGKNSX\nILOVY\n```\n\n因为它的每行每列都是递增的，所以它是一个合法的单词。而单词 `YXWVUTSRQPONMLKJIHGFEDCBA` 则显然不合法。由于单词太长存储不便，需要给每一个单词编一个码。编码方法如下：从左到右，再从上到下，可以由一个矩阵的得到一个单词，再把单词按照字典顺序排序。比如，单词 `ABCDEFGHIJKLMNOPQRSTUVWXY` 的编码为 $1$，而单词 `ABCDEFGHIJKLMNOPQRSUTVWXY` 的编码为 $2$。\n\n现在，你需要编一个程序，完成单词与编码间的转换。", "inputFormat": "第一行为一个字母 `N` 或 `W`。`N` 表示把编码转换为单词，`W` 表示把单词转换为编码。\n\n若第一行为 `N`，则第二行为一个整数，表示单词的编码。若第一行为 `W`，则第二行为一个合法的单词。", "outputFormat": "每行一个整数或单词。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 5.5。", "locale": "zh-CN"}}}
{"pid": "P2751", "type": "P", "difficulty": 5, "samples": [["5 2 3\n1 1 3 1 4", "3 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "贪心", "USACO", "IOI", "枚举", "1996"], "title": "[IOI 1996 / USACO4.2] 工序安排 Job Processing", "background": null, "description": "一家工厂的流水线正在生产一种产品，这需要两种操作：操作 $A$ 和操作 $B$。每个操作只有一些机器能够完成。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1968.png) \n\n上图显示了按照下述方式工作的流水线的组织形式。$A$ 型机器从输入库接受工件，对其施加操作 $A$，得到的中间产品存放在缓冲库。$B$ 型机器从缓冲库接受中间产品，对其施加操作 $B$，得到的最终产品存放在输出库。所有的机器平行并且独立地工作，每个库的容量没有限制。每台机器的工作效率可能不同，一台机器完成一次操作需要一定的时间。\n\n给出每台机器完成一次操作的时间，计算完成 $A$ 操作的最晚时间点的最小值，和完成 $B$ 操作的最晚时间点的最小值。\n\n注：\n1. 机器在一次操作中干掉一个工件；", "inputFormat": "第一行：三个用空格分开的整数：$N$，工件数量（$1\\leq N\\leq1000$）；$M_1$，$A$ 型机器的数量（$1\\leq M_1\\leq30$）；$M_2$，$B$ 型机器的数量（$1\\leq M_2\\leq30$）。\n\n第二行：$M_1$ 个整数，表示 $A$ 型机器完成一次操作的时间；接着是 $M_2$ 个整数，$B$ 型机器完成一次操作的时间。（所有 $A$ 型机器与 $B$ 型机器完成一次操作的时间均为 $[1,20]$ 内的整数）", "outputFormat": "只有一行。输出两个整数：完成所有 $A$ 操作的最晚时间点的最小值，和完成所有 $B$ 操作的最晚时间点的最小值（$A$ 操作必须在 $B$ 操作之前完成）。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 4.2", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1996 / USACO4.2] Job Processing", "background": "", "description": "A factory production line is producing a product that requires two types of operations: operation $A$ and operation $B$. Only some machines can perform each operation.\n\n![](https://cdn.luogu.com.cn/upload/pic/1968.png)\n\nThe figure above shows the organization of a production line operating as described below. $A$-type machines take workpieces from the input buffer, apply operation $A$, and store the resulting intermediate products in the buffer. $B$-type machines take intermediate products from the buffer, apply operation $B$, and store the final products in the output buffer. All machines work in parallel and independently, and each buffer has unlimited capacity. Each machine may have a different efficiency; a machine requires a fixed amount of time to complete one operation.\n\nGiven the processing time of each machine for one operation, compute the minimal total time to finish all $A$ operations, and the minimal total time to finish all $B$ operations.\n\nNote:\n1. In one operation, a machine processes exactly one workpiece.\n2. “Total time” means the latest finishing time (makespan).", "inputFormat": "The first line contains three space-separated integers: $N$, the number of workpieces ($1 \\leq N \\leq 1000$); $M_1$, the number of $A$-type machines ($1 \\leq M_1 \\leq 30$); $M_2$, the number of $B$-type machines ($1 \\leq M_2 \\leq 30$).\n\nThe second line contains $M_1$ integers, the time each $A$-type machine takes to complete one operation; followed by $M_2$ integers, the time each $B$-type machine takes to complete one operation. All operation times for $A$-type and $B$-type machines are integers in $[1, 20]$.", "outputFormat": "Output a single line with two integers: the minimal total time to complete all $A$ operations, and the minimal total time to complete all $B$ operations ($A$ operations must be completed before $B$ operations).", "hint": "Problem translation from NOCOW.\n\nUSACO Training Section 4.2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1996 / USACO4.2] 工序安排 Job Processing", "background": null, "description": "一家工厂的流水线正在生产一种产品，这需要两种操作：操作 $A$ 和操作 $B$。每个操作只有一些机器能够完成。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1968.png) \n\n上图显示了按照下述方式工作的流水线的组织形式。$A$ 型机器从输入库接受工件，对其施加操作 $A$，得到的中间产品存放在缓冲库。$B$ 型机器从缓冲库接受中间产品，对其施加操作 $B$，得到的最终产品存放在输出库。所有的机器平行并且独立地工作，每个库的容量没有限制。每台机器的工作效率可能不同，一台机器完成一次操作需要一定的时间。\n\n给出每台机器完成一次操作的时间，计算完成 $A$ 操作的最晚时间点的最小值，和完成 $B$ 操作的最晚时间点的最小值。\n\n注：\n1. 机器在一次操作中干掉一个工件；", "inputFormat": "第一行：三个用空格分开的整数：$N$，工件数量（$1\\leq N\\leq1000$）；$M_1$，$A$ 型机器的数量（$1\\leq M_1\\leq30$）；$M_2$，$B$ 型机器的数量（$1\\leq M_2\\leq30$）。\n\n第二行：$M_1$ 个整数，表示 $A$ 型机器完成一次操作的时间；接着是 $M_2$ 个整数，$B$ 型机器完成一次操作的时间。（所有 $A$ 型机器与 $B$ 型机器完成一次操作的时间均为 $[1,20]$ 内的整数）", "outputFormat": "只有一行。输出两个整数：完成所有 $A$ 操作的最晚时间点的最小值，和完成所有 $B$ 操作的最晚时间点的最小值（$A$ 操作必须在 $B$ 操作之前完成）。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 4.2", "locale": "zh-CN"}}}
{"pid": "P2752", "type": "P", "difficulty": 3, "samples": [["1 2 -2\n3 -2\n3 -2\n5 4 -2\n6 4 -2\n6 -2\n7 8 -2\n9 -2\n5 9 -2\n-2\n-1", "2 3 6\n1 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["USACO", "枚举", "广度优先搜索 BFS", "Tarjan"], "title": "[USACO4.3] 街道赛跑Street Race", "background": "", "description": "图一表示一次街道赛跑的跑道。可以看出有一些路口（用 $0$ 到 $N$ 的整数标号），和连接这些路口的箭头。路口 $0$ 是跑道的起点，路口 $N$ 是跑道的终点。箭头表示单行道。运动员们可以顺着街道从一个路口移动到另一个路口（只能按照箭头所指的方向）。当运动员处于路口位置时，他可以选择任意一条由这个路口引出的街道。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1967.png) \n\n图一：有 $10$ 个路口的街道\n\n一个良好的跑道具有如下几个特点：\n\n1. 每一个路口都可以由起点到达。\n2. 从任意一个路口都可以到达终点。\n3. 终点不通往任何路口。\n\n运动员不必经过所有的路口来完成比赛。有些路口却是选择任意一条路线都必须到达的（称为“不可避免”的）。在上面的例子中，这些路口是 $0$，$3$，$6$，$9$。对于给出的良好的跑道，你的程序要确定“不可避免”的路口的集合，不包括起点和终点。\n\n假设比赛要分两天进行。为了达到这个目的，原来的跑道必须分为两个跑道，每天使用一个跑道。第一天，起点为路口 $0$，终点为一个“中间路口”；第二天，起点是那个中间路口，而终点为路口 $N$。对于给出的良好的跑道，你的程序要确定“中间路口”的集合。如果良好的跑道 $C$ 可以被路口 $S$ 分成两部分，这两部分都是良好的，并且 $S$ 不同于起点也不同于终点，同时被分割的两个部分满足下列条件：（1）它们之间没有共同的街道（2）$S$ 为它们唯一的公共点，并且 $S$ 作为其中一个的终点和另外一个的起点。那么我们称 $S$ 为“中间路口 ”。在例子中只有路口 $3$ 是中间路口。", "inputFormat": "输入文件包括一个良好的跑道，最多有 $50$ 个路口，$100$ 条单行道。\n\n共有 $N+2$ 行，前面 $N+1$ 行中第 $i$ 行表示以编号为 $i-1$ 的路口作为起点的街道，每个数字表示一个终点。行末用 `-2` 作为结束。最后一行只有一个数字 `-1`。", "outputFormat": "第一行：跑道中“不可避免的路口”的数量，接着是这些路口的序号，序号按照升序排列。\n\n第二行：跑道中“中间路口”的数量，接着是这些路口的序号，序号按照升序排列。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 4.3\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO4.3] Street Race", "background": "", "description": "Figure 1 shows a course for a street race. There are several intersections (labeled by the integers from $0$ to $N$) and arrows that connect these intersections. Intersection $0$ is the start, and intersection $N$ is the finish. The arrows indicate one-way streets. Runners can move from one intersection to another along the streets (only in the direction of the arrows). When a runner is at an intersection, they may choose any outgoing street from that intersection.\n\n ![](https://cdn.luogu.com.cn/upload/pic/1967.png) \n\nFigure 1: A street with $10$ intersections.\n\nA valid course has the following properties:\n1. Every intersection is reachable from the start.\n2. The finish is reachable from any intersection.\n3. The finish has no outgoing streets.\n\nRunners do not have to pass through all intersections to complete the race. However, some intersections must be passed on every possible route (called \"unavoidable\"). In the example above, these intersections are $0$, $3$, $6$, $9$. For a given valid course, your program must determine the set of unavoidable intersections, excluding the start and the finish.\n\nAssume the race is to be held over two days. To achieve this, the original course must be split into two courses, one for each day. On day 1, the start is intersection $0$ and the finish is an \"intermediate intersection\"; on day 2, the start is that intermediate intersection and the finish is intersection $N$. For a given valid course, your program must determine the set of \"splitting points\". If a valid course $C$ can be divided by an intersection $S$ into two parts that are both valid, $S$ is different from both the start and the finish, and the two parts satisfy the following conditions: (1) they share no streets; (2) their only common point is $S$, with $S$ serving as the finish of one and the start of the other; then $S$ is called a \"splitting point\". In the example, only intersection $3$ is a splitting point.", "inputFormat": "The input describes a valid course with at most $50$ intersections and $100$ one-way streets.\n\nThere are $N+2$ lines. In the first $N+1$ lines, line $i$ lists the streets that start from the intersection numbered $i-1$, and each number denotes a destination. Each line ends with `-2`. The last line contains a single number `-1`.", "outputFormat": "The first line: the number of unavoidable intersections, followed by their indices in increasing order.\n\nThe second line: the number of splitting points, followed by their indices in increasing order.", "hint": "Problem translation from NOCOW.\n\nUSACO Training Section 4.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO4.3] 街道赛跑Street Race", "background": "", "description": "图一表示一次街道赛跑的跑道。可以看出有一些路口（用 $0$ 到 $N$ 的整数标号），和连接这些路口的箭头。路口 $0$ 是跑道的起点，路口 $N$ 是跑道的终点。箭头表示单行道。运动员们可以顺着街道从一个路口移动到另一个路口（只能按照箭头所指的方向）。当运动员处于路口位置时，他可以选择任意一条由这个路口引出的街道。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1967.png) \n\n图一：有 $10$ 个路口的街道\n\n一个良好的跑道具有如下几个特点：\n\n1. 每一个路口都可以由起点到达。\n2. 从任意一个路口都可以到达终点。\n3. 终点不通往任何路口。\n\n运动员不必经过所有的路口来完成比赛。有些路口却是选择任意一条路线都必须到达的（称为“不可避免”的）。在上面的例子中，这些路口是 $0$，$3$，$6$，$9$。对于给出的良好的跑道，你的程序要确定“不可避免”的路口的集合，不包括起点和终点。\n\n假设比赛要分两天进行。为了达到这个目的，原来的跑道必须分为两个跑道，每天使用一个跑道。第一天，起点为路口 $0$，终点为一个“中间路口”；第二天，起点是那个中间路口，而终点为路口 $N$。对于给出的良好的跑道，你的程序要确定“中间路口”的集合。如果良好的跑道 $C$ 可以被路口 $S$ 分成两部分，这两部分都是良好的，并且 $S$ 不同于起点也不同于终点，同时被分割的两个部分满足下列条件：（1）它们之间没有共同的街道（2）$S$ 为它们唯一的公共点，并且 $S$ 作为其中一个的终点和另外一个的起点。那么我们称 $S$ 为“中间路口 ”。在例子中只有路口 $3$ 是中间路口。", "inputFormat": "输入文件包括一个良好的跑道，最多有 $50$ 个路口，$100$ 条单行道。\n\n共有 $N+2$ 行，前面 $N+1$ 行中第 $i$ 行表示以编号为 $i-1$ 的路口作为起点的街道，每个数字表示一个终点。行末用 `-2` 作为结束。最后一行只有一个数字 `-1`。", "outputFormat": "第一行：跑道中“不可避免的路口”的数量，接着是这些路口的序号，序号按照升序排列。\n\n第二行：跑道中“中间路口”的数量，接着是这些路口的序号，序号按照升序排列。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 4.3\n", "locale": "zh-CN"}}}
{"pid": "P2753", "type": "P", "difficulty": 5, "samples": [["prmgroa\nprofile\nprogram\nprom\nrag\nram\nrom\n.", "24\nprogram\nprom rag"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["USACO"], "title": "[USACO4.3] 字母游戏 Letter Game", "background": null, "description": "给定 $3 \\sim 7$ 张卡片和不超过 $4 \\times 10^4$ 个合法单词，请用卡片拼出（每张卡片只能用一次）一个或多个（即“词组”）合法单词，使得用到的卡片的价值之和最大，并输出所有方案。\n\n卡片的价值取决于卡片上的字母，其对应关系如下：\n\n```plain\n[Letter]  a b c d e f g h i j k l m n o p q r s t u v w x y z\n[Value]   2 5 4 4 1 6 5 5 1 7 6 3 5 2 3 5 7 2 1 2 4 6 6 7 5 7\n```\n\n![](https://cdn.luogu.com.cn/upload/pic/1969.png)", "inputFormat": "第一行 $3 \\sim 7$ 个小写字母，表示你手上的每张卡片都写着哪个字母。\n\n下面不超过 $4 \\times 10^4+1$ 行，每行 $3 \\sim 7$ 个小写字母表示一个合法单词，以 `.` 作为输入结束标志。\n\n保证所有合法单词不重复且按字典序升序给出。", "outputFormat": "第一行输出一个整数表示最大得分。\n\n下面若干行（按字典序升序排序），每行若干个单词（同样按字典序升序排序），表示每个最优解中拼出的单词或词组。\n\n两个只有单词出现顺序不同的词组应算作同一个词组，此时你应该按字典序升序输出该词组中的每个单词。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 4.3。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO4.3] Letter Game", "background": "", "description": "Given $3 \\sim 7$ cards and at most $4 \\times 10^4$ valid words, use the cards to form one or more valid words (i.e., a \"phrase\"), where each card can be used at most once, so that the sum of the values of the cards used is maximized, and output all optimal solutions.\n\nThe value of a card depends on the letter on it; the correspondence is as follows:\n\n```plain\n[Letter]  a b c d e f g h i j k l m n o p q r s t u v w x y z\n[Value]   2 5 4 4 1 6 5 5 1 7 6 3 5 2 3 5 7 2 1 2 4 6 6 7 5 7\n```\n\n![](https://cdn.luogu.com.cn/upload/pic/1969.png)", "inputFormat": "The first line contains $3 \\sim 7$ lowercase letters, indicating the letters on your cards.\n\nThe next up to $4 \\times 10^4 + 1$ lines each contain $3 \\sim 7$ lowercase letters representing a valid word, with `.` as the end-of-input marker.\n\nAll valid words are guaranteed to be distinct and given in ascending lexicographic order.", "outputFormat": "On the first line, output an integer representing the maximum score.\n\nThen output several lines (sorted in ascending lexicographic order). Each line contains one or more words (also sorted in ascending lexicographic order), representing the word or \"phrase\" formed in each optimal solution.\n\nTwo phrases that differ only in the order of words should be considered the same phrase. In that case, you should output the words within that phrase in ascending lexicographic order.", "hint": "The problem statement translation is from NOCOW.\n\nUSACO Training Section 4.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO4.3] 字母游戏 Letter Game", "background": null, "description": "给定 $3 \\sim 7$ 张卡片和不超过 $4 \\times 10^4$ 个合法单词，请用卡片拼出（每张卡片只能用一次）一个或多个（即“词组”）合法单词，使得用到的卡片的价值之和最大，并输出所有方案。\n\n卡片的价值取决于卡片上的字母，其对应关系如下：\n\n```plain\n[Letter]  a b c d e f g h i j k l m n o p q r s t u v w x y z\n[Value]   2 5 4 4 1 6 5 5 1 7 6 3 5 2 3 5 7 2 1 2 4 6 6 7 5 7\n```\n\n![](https://cdn.luogu.com.cn/upload/pic/1969.png)", "inputFormat": "第一行 $3 \\sim 7$ 个小写字母，表示你手上的每张卡片都写着哪个字母。\n\n下面不超过 $4 \\times 10^4+1$ 行，每行 $3 \\sim 7$ 个小写字母表示一个合法单词，以 `.` 作为输入结束标志。\n\n保证所有合法单词不重复且按字典序升序给出。", "outputFormat": "第一行输出一个整数表示最大得分。\n\n下面若干行（按字典序升序排序），每行若干个单词（同样按字典序升序排序），表示每个最优解中拼出的单词或词组。\n\n两个只有单词出现顺序不同的词组应算作同一个词组，此时你应该按字典序升序输出该词组中的每个单词。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 4.3。", "locale": "zh-CN"}}}
{"pid": "P2754", "type": "P", "difficulty": 6, "samples": [["2 2 1\n1 3 0 1 2\n1 3 1 2 -1\n", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["1999", "网络流", "O2优化", "网络流与线性规划 24 题", "CTSC/CTS"], "title": "[CTSC1999] 家园 / 星际转移问题", "background": "", "description": "由于人类对自然资源的消耗，人们意识到大约在 2300 年之后，地球就不能再居住了。于是在月球上建立了新的绿地，以便在需要时移民。令人意想不到的是，2177 年冬由于未知的原因，地球环境发生了连锁崩溃，人类必须在最短的时间内迁往月球。\n\n现有 $n$ 个太空站位于地球与月球之间，且有 $m$ 艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而太空船的容量是有限的，第 $i$ 艘太空船只可容纳  $h_i$ 个人。每艘太空船将周期性地停靠一系列的太空站，例如 $(1,3,4)$ 表示该太空船将周期性地停靠太空站 $134134134\\dots$。每一艘太空船从一个太空站驶往任一太空站耗时均为 $1$。人们只能在太空船停靠太空站(或月球、地球)时上、下船。\n\n初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。", "inputFormat": "输入的第一行是三个用空格隔开的整数，分别代表太空站个数 $n$，太空船个数 $m$ 和地球上的人数 $k$。\n\n第 $2$ 到第 $(m + 1)$ 行，每行给出一艘太空船的信息，第 $(i + 1)$ 行的第一个整数 $h_i$ 代表第 $i$ 艘太空船可容纳的人数。随后有一个整数 $r_i$，代表第 $i$ 艘太空船停靠的站点数。之后有 $r_i$ 个整数，依次代表该太空船停靠站点的编号 $S_{i, j}$，其中太空站自 $1$ 至 $n$ 编号，地球编号为 $0$，月球编号为 $-1$。", "outputFormat": "输出一行一个整数，代表将所有人转移到月球上的最短用时。若无解则输出 $0$。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n\n- $1 \\leq n \\leq 13$。\n- $1 \\leq m \\leq 20$。\n- $1 \\leq k \\leq 50$。\n- $1 \\leq r_i \\leq n + 2$。\n- $-1 \\leq S_{i, j}\\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC1999] Home / Interstellar Transfer Problem", "background": "", "description": "Due to humanity’s consumption of natural resources, people realized that around the year 2300, Earth would no longer be habitable. Therefore, new green zones were established on the Moon to enable migration when needed. Unexpectedly, in the winter of 2177, due to unknown reasons, Earth’s environment suffered a chain collapse, and humanity must migrate to the Moon as quickly as possible.\n\nThere are $n$ space stations located between Earth and the Moon, and there are $m$ public transport spacecraft shuttling back and forth among them. Each space station can hold an unlimited number of people, but each spacecraft has limited capacity: the $i$-th spacecraft can carry $h_i$ people. Each spacecraft periodically stops at a sequence of stations; for example, $(1,3,4)$ means the spacecraft will cyclically stop at stations $134134134\\dots$. It takes time $1$ for a spacecraft to travel from any station to any other station. People can board or disembark only when a spacecraft is docked at a station (or the Moon, or Earth).\n\nInitially, all people are on Earth, and all spacecraft are at their initial stops. Design an algorithm to find a transportation plan that transfers all people to the Moon in the shortest possible time.", "inputFormat": "The first line contains three integers separated by spaces, representing the number of space stations $n$, the number of spacecraft $m$, and the number of people on Earth $k$.\n\nLines $2$ through $(m + 1)$ each describe one spacecraft. On line $(i + 1)$, the first integer $h_i$ is the capacity of the $i$-th spacecraft. Then an integer $r_i$ follows, representing the number of stops of the $i$-th spacecraft. After that are $r_i$ integers, in order, representing the indices of the stops $S_{i, j}$, where the space stations are numbered from $1$ to $n$, Earth is indexed as $0$, and the Moon as $-1$.", "outputFormat": "Output a single integer representing the shortest time needed to transfer all people to the Moon. If there is no solution, output $0$.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that:\n- $1 \\leq n \\leq 13$.\n- $1 \\leq m \\leq 20$.\n- $1 \\leq k \\leq 50$.\n- $1 \\leq r_i \\leq n + 2$.\n- $-1 \\leq S_{i, j} \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC1999] 家园 / 星际转移问题", "background": "", "description": "由于人类对自然资源的消耗，人们意识到大约在 2300 年之后，地球就不能再居住了。于是在月球上建立了新的绿地，以便在需要时移民。令人意想不到的是，2177 年冬由于未知的原因，地球环境发生了连锁崩溃，人类必须在最短的时间内迁往月球。\n\n现有 $n$ 个太空站位于地球与月球之间，且有 $m$ 艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而太空船的容量是有限的，第 $i$ 艘太空船只可容纳  $h_i$ 个人。每艘太空船将周期性地停靠一系列的太空站，例如 $(1,3,4)$ 表示该太空船将周期性地停靠太空站 $134134134\\dots$。每一艘太空船从一个太空站驶往任一太空站耗时均为 $1$。人们只能在太空船停靠太空站(或月球、地球)时上、下船。\n\n初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。", "inputFormat": "输入的第一行是三个用空格隔开的整数，分别代表太空站个数 $n$，太空船个数 $m$ 和地球上的人数 $k$。\n\n第 $2$ 到第 $(m + 1)$ 行，每行给出一艘太空船的信息，第 $(i + 1)$ 行的第一个整数 $h_i$ 代表第 $i$ 艘太空船可容纳的人数。随后有一个整数 $r_i$，代表第 $i$ 艘太空船停靠的站点数。之后有 $r_i$ 个整数，依次代表该太空船停靠站点的编号 $S_{i, j}$，其中太空站自 $1$ 至 $n$ 编号，地球编号为 $0$，月球编号为 $-1$。", "outputFormat": "输出一行一个整数，代表将所有人转移到月球上的最短用时。若无解则输出 $0$。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n\n- $1 \\leq n \\leq 13$。\n- $1 \\leq m \\leq 20$。\n- $1 \\leq k \\leq 50$。\n- $1 \\leq r_i \\leq n + 2$。\n- $-1 \\leq S_{i, j}\\leq n$。", "locale": "zh-CN"}}}
{"pid": "P2755", "type": "P", "difficulty": 2, "samples": [["20", "20"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": [], "title": "洗牌问题", "background": "", "description": "有 $ 2n $ 张牌，编号为\n\n$$ 1,2,3 \\dots n,n+1, \\dots 2n$$\n\n这也是最初的牌的顺序。一次洗牌是把序列变为\n\n$$ n+1,1,n+2,2,n+3,3,n+4,4 \\dots 2n,n $$\n\n可以证明，对于任意自然数 $ n $，都可以在经过 $ m $ 次洗牌后第一次重新得到初始的顺序。\n\n现给定 $n$（$n \\le 10^8$），求出 $ m $ 的值。", "inputFormat": "一行，一个正整数 $n$。\n", "outputFormat": "一行，一个正整数 $m$。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "Shuffling Problem", "background": "", "description": "There are $ 2n $ cards, numbered as\n$$ 1,2,3 \\dots n,n+1, \\dots 2n $$\nwhich is also the initial order of the deck. One shuffle transforms the sequence into\n$$ n+1,1,n+2,2,n+3,3,n+4,4 \\dots 2n,n $$. \nIt can be proven that for any natural number $ n $, there exists a smallest positive integer $ m $ such that after performing the shuffle $ m $ times, the deck returns to its initial order for the first time.\n\nGiven $ n $ ($ n \\le 10^8 $), compute this $ m $.", "inputFormat": "One line containing a positive integer $ n $.", "outputFormat": "One line containing a positive integer $ m $.", "hint": "For $ 100\\% $ of the testdata, $ 1 \\le n \\le 10^8 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "洗牌问题", "background": "", "description": "有 $ 2n $ 张牌，编号为\n\n$$ 1,2,3 \\dots n,n+1, \\dots 2n$$\n\n这也是最初的牌的顺序。一次洗牌是把序列变为\n\n$$ n+1,1,n+2,2,n+3,3,n+4,4 \\dots 2n,n $$\n\n可以证明，对于任意自然数 $ n $，都可以在经过 $ m $ 次洗牌后第一次重新得到初始的顺序。\n\n现给定 $n$（$n \\le 10^8$），求出 $ m $ 的值。", "inputFormat": "一行，一个正整数 $n$。\n", "outputFormat": "一行，一个正整数 $m$。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P2756", "type": "P", "difficulty": 4, "samples": [["5 10\n1 7\n1 8\n2 6\n2 9\n2 10\n3 7\n3 8\n4 7\n4 8\n5 10\n-1 -1\n", "4\n1 7\n2 9\n3 8\n5 10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流", "Special Judge", "O2优化", "二分图", "网络流与线性规划 24 题"], "title": "飞行员配对方案问题", "background": "第二次世界大战期间，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的两名飞行员，其中一名是英国飞行员，另一名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。", "description": "一共有 $n$ 个飞行员，其中有 $m$ 个外籍飞行员和 $(n - m)$ 个英国飞行员，**外籍飞行员从 $1$ 到 $m$ 编号**，**英国飞行员从 $m + 1$ 到 $n$ 编号**。 对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。", "inputFormat": "输入的第一行是用空格隔开的两个正整数，分别代表外籍飞行员的个数 $m$ 和飞行员总数 $n$。  \n从第二行起到倒数第二行，每行有两个整数 $u, v$，代表外籍飞行员 $u$ 可以和英国飞行员 $v$ 配合。  \n输入的最后一行保证为 `-1 -1`，代表输入结束。", "outputFormat": "**本题存在 Special Judge**。  \n请输出能派出最多的飞机数量，并给出一种可行的方案。  \n输出的第一行是一个整数，代表一次能派出的最多飞机数量，设这个整数是 $k$。  \n第 $2$ 行到第 $k + 1$ 行，每行输出两个整数 $u, v$，代表在你给出的方案中，外籍飞行员 $u$ 和英国飞行员 $v$ 配合。这 $k$ 行的 $u$ 与 $v$ 应该互不相同。", "hint": "**【数据范围与约定】**\n\n- 对于 $100\\%$ 的数据，保证 $1 \\leq m \\leq n < 100$，$1 \\leq u \\leq m < v \\leq n$。\n\n::anti-ai[同一组配对关系只会给出一次。]\n\n**【提示】**\n\n- 请注意输入的第一行先读入 $m$，再读入 $n$。", "locale": "zh-CN", "translations": {"en": {"title": "Pilot Pairing Problem", "background": "During World War II, the Royal Air Force (RAF) recruited many foreign pilots from occupied countries. Each aircraft dispatched by the RAF must be staffed with two pilots who can cooperate in flight skills and language: one British pilot and one foreign pilot. Among the many pilots, each foreign pilot can work well with several British pilots.", "description": "There are $n$ pilots in total, including $m$ foreign pilots and $(n - m)$ British pilots. Foreign pilots are numbered from $1$ to $m$, and British pilots are numbered from $m + 1$ to $n$. Given the cooperation relations between foreign and British pilots, design an algorithm to find the optimal pairing scheme so that the RAF can dispatch the maximum number of aircraft at once.", "inputFormat": "The first line contains two positive integers separated by a space, representing the number of foreign pilots $m$ and the total number of pilots $n$.  \nFrom the second line to the second-to-last line, each line contains two integers $u, v$, meaning foreign pilot $u$ can cooperate with British pilot $v$.  \nThe last line is guaranteed to be `-1 -1`, indicating the end of input.", "outputFormat": "This problem uses a Special Judge.  \nOutput the maximum number of aircraft that can be dispatched, and provide one feasible pairing scheme.  \nThe first line contains an integer, the maximum number of aircraft that can be dispatched at once; denote this integer by $k$.  \nFrom line $2$ to line $k + 1$, each line contains two integers $u, v$, indicating that in your scheme, foreign pilot $u$ is paired with British pilot $v$. The pairs $(u, v)$ in these $k$ lines must be all distinct.", "hint": "- 【Constraints and Conventions】\n  - For $100\\%$ of the testdata, it is guaranteed that $1 \\leq m \\leq n < 100$, $1 \\leq u \\leq m < v \\leq n$.\n\n::anti-ai[The same pairing relation will be given at most once.]\n\n- 【Hint】\n  - Note that the first line reads $m$ first, then $n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "飞行员配对方案问题", "background": "第二次世界大战期间，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的两名飞行员，其中一名是英国飞行员，另一名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。", "description": "一共有 $n$ 个飞行员，其中有 $m$ 个外籍飞行员和 $(n - m)$ 个英国飞行员，**外籍飞行员从 $1$ 到 $m$ 编号**，**英国飞行员从 $m + 1$ 到 $n$ 编号**。 对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。", "inputFormat": "输入的第一行是用空格隔开的两个正整数，分别代表外籍飞行员的个数 $m$ 和飞行员总数 $n$。  \n从第二行起到倒数第二行，每行有两个整数 $u, v$，代表外籍飞行员 $u$ 可以和英国飞行员 $v$ 配合。  \n输入的最后一行保证为 `-1 -1`，代表输入结束。", "outputFormat": "**本题存在 Special Judge**。  \n请输出能派出最多的飞机数量，并给出一种可行的方案。  \n输出的第一行是一个整数，代表一次能派出的最多飞机数量，设这个整数是 $k$。  \n第 $2$ 行到第 $k + 1$ 行，每行输出两个整数 $u, v$，代表在你给出的方案中，外籍飞行员 $u$ 和英国飞行员 $v$ 配合。这 $k$ 行的 $u$ 与 $v$ 应该互不相同。", "hint": "**【数据范围与约定】**\n\n- 对于 $100\\%$ 的数据，保证 $1 \\leq m \\leq n < 100$，$1 \\leq u \\leq m < v \\leq n$。\n\n::anti-ai[同一组配对关系只会给出一次。]\n\n**【提示】**\n\n- 请注意输入的第一行先读入 $m$，再读入 $n$。", "locale": "zh-CN"}}}
{"pid": "P2757", "type": "P", "difficulty": 6, "samples": [["2\n3\n1 3 2\n3\n3 2 1", "N\nY"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "集训队互测", "O2优化", "哈希 hashing"], "title": "[国家集训队] 等差子序列", "background": "", "description": "给一个 $1$ 到 $N$ 的排列 $\\{A_i\\}$，询问是否存在\n\n$$1 \\le p_1<p_2<p_3<p_4<p_5<…<p_{Len} \\le N (Len \\ge 3)$$\n\n使得 $Ap_1,Ap_2,Ap_3,\\cdots,Ap_{Len}$ 是一个等差序列。\n", "inputFormat": "输入的第一行包含一个整数 $T$，表示组数。\n\n下接 $T$ 组数据，每组第一行一个整数 $N$，每组第二行为一个 $1$ 到 $N$ 的排列，数字两两之间用空格隔开。\n", "outputFormat": "对于每组数据，如果存在一个等差子序列，则输出一行 Y，否则输出一行 N。\n", "hint": "对于前 $5$ 个测试点的数据，$1 \\leq N \\leq 5\\times 10^5,T \\leq 5$，时限 5s。\n\n对于后 $21$ 个测试点的数据，$1 \\leq N \\leq10000,T\\leq 7$，时限 2s。", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] Arithmetic Subsequence", "background": "", "description": "Given a permutation $\\{A_i\\}$ of $1$ to $N$, determine whether there exist indices\n$$1 \\le p_1 < p_2 < p_3 < p_4 < p_5 < \\cdots < p_{Len} \\le N, \\quad Len \\ge 3,$$\nsuch that $A_{p_1}, A_{p_2}, A_{p_3}, \\cdots, A_{p_{Len}}$ form an arithmetic progression.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nThen follow $T$ test cases. For each test case, the first line contains an integer $N$, and the second line contains a permutation of $1$ to $N$, with numbers separated by single spaces.", "outputFormat": "For each test case, output a single line with Y if there exists an arithmetic subsequence, otherwise output N.", "hint": "For the first $5$ test points, $1 \\leq N \\leq 5 \\times 10^5$, $T \\leq 5$, time limit $5$ s.\n\nFor the remaining $21$ test points, $1 \\leq N \\leq 10000$, $T \\leq 7$, time limit $2$ s.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] 等差子序列", "background": "", "description": "给一个 $1$ 到 $N$ 的排列 $\\{A_i\\}$，询问是否存在\n\n$$1 \\le p_1<p_2<p_3<p_4<p_5<…<p_{Len} \\le N (Len \\ge 3)$$\n\n使得 $Ap_1,Ap_2,Ap_3,\\cdots,Ap_{Len}$ 是一个等差序列。\n", "inputFormat": "输入的第一行包含一个整数 $T$，表示组数。\n\n下接 $T$ 组数据，每组第一行一个整数 $N$，每组第二行为一个 $1$ 到 $N$ 的排列，数字两两之间用空格隔开。\n", "outputFormat": "对于每组数据，如果存在一个等差子序列，则输出一行 Y，否则输出一行 N。\n", "hint": "对于前 $5$ 个测试点的数据，$1 \\leq N \\leq 5\\times 10^5,T \\leq 5$，时限 5s。\n\n对于后 $21$ 个测试点的数据，$1 \\leq N \\leq10000,T\\leq 7$，时限 2s。", "locale": "zh-CN"}}}
{"pid": "P2758", "type": "P", "difficulty": 3, "samples": [["sfdqxbw\ngfdgw\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "数学"], "title": "编辑距离", "background": "", "description": "设 $A$ 和 $B$ 是两个字符串。我们要用最少的字符操作次数，将字符串 $A$ 转换为字符串 $B$。这里所说的字符操作共有三种：\n\n1. 删除一个字符；\n2. 插入一个字符；\n3. 将一个字符改为另一个字符。\n\n$A, B$ 均只包含小写字母。\n", "inputFormat": "第一行为字符串 $A$；第二行为字符串 $B$；字符串 $A, B$ 的长度均小于 $2000$。\n", "outputFormat": "只有一个正整数，为最少字符操作次数。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le |A|, |B| \\le 2000$。", "locale": "zh-CN", "translations": {"en": {"title": "Edit Distance", "background": "", "description": "Let $A$ and $B$ be two strings. We want to transform string $A$ into string $B$ using the minimum number of character operations. There are three types of operations:\n1. Delete one character.\n2. Insert one character.\n3. Replace one character with another.\n\nBoth $A$ and $B$ contain only lowercase letters.", "inputFormat": "The first line contains string $A$. The second line contains string $B$. Both have length at most $2000$.", "outputFormat": "Output a single positive integer, which is the minimum number of character operations.", "hint": "For $100 \\%$ of the testdata, $1 \\le |A|, |B| \\le 2000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "编辑距离", "background": "", "description": "设 $A$ 和 $B$ 是两个字符串。我们要用最少的字符操作次数，将字符串 $A$ 转换为字符串 $B$。这里所说的字符操作共有三种：\n\n1. 删除一个字符；\n2. 插入一个字符；\n3. 将一个字符改为另一个字符。\n\n$A, B$ 均只包含小写字母。\n", "inputFormat": "第一行为字符串 $A$；第二行为字符串 $B$；字符串 $A, B$ 的长度均小于 $2000$。\n", "outputFormat": "只有一个正整数，为最少字符操作次数。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le |A|, |B| \\le 2000$。", "locale": "zh-CN"}}}
{"pid": "P2759", "type": "P", "difficulty": 3, "samples": [["11", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "二分", "洛谷原创"], "title": "奇怪的函数", "background": "", "description": "使得 $x^x$ 达到或超过 $n$ 位数字的最小正整数 $x$ 是多少？\n", "inputFormat": "一个正整数 $n$。\n", "outputFormat": "使得 $x^x$ 达到 $n$ 位数字的最小正整数 $x$。\n", "hint": "对于全部数据，$1\\le n\\le 2\\times 10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Strange Function", "background": "", "description": "What is the smallest positive integer $x$ such that $x^x$ has at least $n$ digits?", "inputFormat": "A positive integer $n$.", "outputFormat": "Output the smallest positive integer $x$ such that $x^x$ has at least $n$ digits.", "hint": "For all testdata, $1 \\le n \\le 2 \\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "奇怪的函数", "background": "", "description": "使得 $x^x$ 达到或超过 $n$ 位数字的最小正整数 $x$ 是多少？\n", "inputFormat": "一个正整数 $n$。\n", "outputFormat": "使得 $x^x$ 达到 $n$ 位数字的最小正整数 $x$。\n", "hint": "对于全部数据，$1\\le n\\le 2\\times 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P2760", "type": "P", "difficulty": 4, "samples": [["4 4 13 20\n10 0  0  0\n0  0  10 0\n0  0  10 0\n0  0  0  0\n1 0 0 0\n0 0 2 0\n0 0 4 0\n0 0 0 0", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "科技庄园", "background": "", "description": "Life 种了一块田，里面种了有一些桃树。\n\nLife 对 PFT 说：“我给你一定的时间去摘桃，你必须在规定的时间之内回到我面前，否则你摘的桃都要归我吃！”  \n\nPFT 思考了一会，最终答应了！\n\n由于 PFT 的数学不好！它并不知道怎样才能在规定的时间获得最大的价值，  \n\n由于 PFT 不是机器人，所以他的体力并不是无限的，他不想摘很多的桃以至体力为 $0$，而白白把桃给 Life。同时 PFT 每次只能摘一棵桃树，每棵桃树都可以摘 $K$ 次（对于同一棵桃每次摘的桃数相同）。每次摘完后都要返回出发点（PFT 一次拿不了很多）即 Life 的所在地 $(0，0)$ （试验田左上角的桃坐标是 $(1，1)$）。  \n\nPFT 每秒只能移动一个单位，每移动一个单位耗费体力 $1$ （摘取不花费时间和体力，但只限上下左右移动）。", "inputFormat": "第一行：四个数为 $N$，$M$，$TI$，$A$ 分别表示试验田的长和宽，Life 给 PFT 的时间，和 PFT 的体力。  \n\n下面一个 $N$ 行 $M$ 列的矩阵桃田。表示每次每棵桃树上能摘的桃数。   \n\n接下来 $N$ 行 $M$ 列的矩阵，表示每棵桃最多可以采摘的次数 $K$。", "outputFormat": "一个数：PFT 可以获得的最大的桃个数。", "hint": "样例说明：\n\n可以摘到 1 次 $(1，1)$ 和 $1$ 次 $(2，3)$，体力和时间不满足再摘桃了。\n\n范围：  \n\n对于 $30\\%$ 的数据：$10\\le N,M,TI \\le 50$；\n\n对于 $100\\%$ 的数据：$10\\le N,M,TI\\le 100$。\n\n对于 $K$：$10\\le K\\le 100$。\n\n保证结果在 `long int` 范围内。", "locale": "zh-CN", "translations": {"en": {"title": "Tech Manor", "background": "", "description": "Life planted a field with some peach trees.\n\nLife said to PFT: \"I will give you a certain amount of time to pick peaches. You must return to me within the time limit, otherwise all the peaches you picked will be mine to eat!\"\n\nPFT thought for a while and agreed.\n\nBecause PFT is not good at math, he does not know how to obtain the maximum total within the time limit.\n\nPFT is not a robot, so his stamina is limited. He does not want to pick so many peaches that his stamina becomes $0$ and end up giving the peaches to Life for nothing. At the same time:\n- In each trip PFT can pick from exactly one peach tree.\n- Each tree can be picked at most $K$ times, and each pick from the same tree yields the same number of peaches.\n- After each pick he must return to the starting point, i.e., Life's location $(0, 0)$ (the coordinate of the top-left peach in the field is $(1, 1)$).\n\nMovement rules:\n- PFT can only move up, down, left, and right.\n- He moves $1$ unit per second.\n- Moving $1$ unit costs $1$ stamina.\n- Picking costs no time and no stamina.", "inputFormat": "The first line contains four integers $N$, $M$, $TI$, $A$, representing the length and width of the field, the time given by Life, and PFT's stamina.\n\nThen an $N \\times M$ matrix for the field, where each entry is the number of peaches obtained per pick from that tree.\n\nThen another $N \\times M$ matrix, where each entry is the maximum number of times $K$ that tree can be picked.", "outputFormat": "One integer: the maximum number of peaches PFT can obtain.", "hint": "Sample explanation:\n\nYou can pick $1$ time at $(1, 1)$ and $1$ time at $(2, 3)$. Time and stamina do not allow any more picking.\n\nConstraints:\n- For $30\\%$ of the testdata: $10 \\le N, M, TI \\le 50$.\n- For $10\\%$ of the testdata: $10 \\le N, M, TI \\le 100$.\n- For $K$: $10 \\le K \\le 100$.\nThe result is guaranteed to fit in the range of `long int`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "科技庄园", "background": "", "description": "Life 种了一块田，里面种了有一些桃树。\n\nLife 对 PFT 说：“我给你一定的时间去摘桃，你必须在规定的时间之内回到我面前，否则你摘的桃都要归我吃！”  \n\nPFT 思考了一会，最终答应了！\n\n由于 PFT 的数学不好！它并不知道怎样才能在规定的时间获得最大的价值，  \n\n由于 PFT 不是机器人，所以他的体力并不是无限的，他不想摘很多的桃以至体力为 $0$，而白白把桃给 Life。同时 PFT 每次只能摘一棵桃树，每棵桃树都可以摘 $K$ 次（对于同一棵桃每次摘的桃数相同）。每次摘完后都要返回出发点（PFT 一次拿不了很多）即 Life 的所在地 $(0，0)$ （试验田左上角的桃坐标是 $(1，1)$）。  \n\nPFT 每秒只能移动一个单位，每移动一个单位耗费体力 $1$ （摘取不花费时间和体力，但只限上下左右移动）。", "inputFormat": "第一行：四个数为 $N$，$M$，$TI$，$A$ 分别表示试验田的长和宽，Life 给 PFT 的时间，和 PFT 的体力。  \n\n下面一个 $N$ 行 $M$ 列的矩阵桃田。表示每次每棵桃树上能摘的桃数。   \n\n接下来 $N$ 行 $M$ 列的矩阵，表示每棵桃最多可以采摘的次数 $K$。", "outputFormat": "一个数：PFT 可以获得的最大的桃个数。", "hint": "样例说明：\n\n可以摘到 1 次 $(1，1)$ 和 $1$ 次 $(2，3)$，体力和时间不满足再摘桃了。\n\n范围：  \n\n对于 $30\\%$ 的数据：$10\\le N,M,TI \\le 50$；\n\n对于 $100\\%$ 的数据：$10\\le N,M,TI\\le 100$。\n\n对于 $K$：$10\\le K\\le 100$。\n\n保证结果在 `long int` 范围内。", "locale": "zh-CN"}}}
{"pid": "P2761", "type": "P", "difficulty": 4, "samples": [["3 3\n1 000 00-\n1 00- 0-+\n2 0-- -++\n", "8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化", "最短路", "网络流与线性规划 24 题", "状压 DP"], "title": "软件补丁问题", "background": "", "description": "T 公司发现其研制的一个软件中有 $n$ 个错误，随即为该软件发放了 $m$ 个补丁程序。\n\n每一个补丁程序都有其特定的适用环境，某个补丁只有在软件中包含某些错误而同时又不包含另一些错误时才可以使用。一个补丁在排除某些错误的同时，往往会加入另一些错误。\n\n换句话说，对于任意一个补丁 $i$，都有四个与之相应的集合 $B1_i,B2_i,F1_i$ 和 $F2_i$。仅当软件包含 $B1_i$ 中的所有错误，而不包含 $B2_i$ 中的任何错误时，才可以使用补丁 $i$。补丁 $i$ 将修复软件中的某些错误集合 $F1_i$，而同时加入另一些错误 $F2_i$。另外，运行每个补丁都耗费一定的时间。\n\n试设计一个算法，利用 T 公司提供的 $m$ 个补丁程序将原软件修复成一个没有错误的软件，并使修复后的软件耗时最少。对于给定的 $n$ 个错误和 $m$ 个补丁程序，找到总耗时最少的软件修复方案。", "inputFormat": "第一行有两个正整数 $n$ 和 $m$。$n$ 表示错误总数，$m$表示补丁总数。\n\n接下来 $m$ 行给出了 $m$ 个补丁的信息。每行包括一个正整数，表示运行补丁程序 $i$ 所需时间，以及两个长度为 $n$ 的字符串。中间用一个空格符隔开。\n\n第一个字符串中，如果第 $k$ 个字符为 ```+```，则表示第 $k$ 个错误属于 $B1_i$。若为 ```-```，则表示第 $k$ 个错误属于 $B2_i$。若为 ```0```，则第 $k$ 个错误既不属于 $B1_i$ 也不属于 $B2_i$，即软件中是否包含第 $k$ 个错误并不影响补丁 $i$ 的可用性。\n\n第二个字符串中，如果第 $k$ 个字符为 ```-```，则表示第 $k$ 个错误属于 $F1_i$。若为 ```+```，则表示第 $k$ 个错误属于 $F2_i$。若为 ```0```，则第 $k$ 个错误既不属于 $F1_i$ 也不属于 $F2_i$，即软件中是否包含第 $k$ 个错误不会因使用补丁 $i$ 而改变。", "outputFormat": "程序运行结束时，将总耗时数输出。如果问题无解，则输出 `0`。", "hint": "对于 $100\\%$ 的数据：$1\\le n\\le 20$，$1\\le m\\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "Software Patch Problem", "background": "", "description": "Company T discovered that there are $n$ bugs in one of its software products and then released $m$ patch programs for it.\n\nEach patch has its specific applicable environment: a patch can be used only when the software contains certain bugs and at the same time does not contain some other bugs. While removing some bugs, a patch may also introduce new bugs.\n\nIn other words, for any patch $i$, there are four associated sets $B1_i,B2_i,F1_i$ and $F2_i$. Patch $i$ can be applied only if the software contains all bugs in $B1_i$ and contains none of the bugs in $B2_i$. Patch $i$ will fix the set of bugs $F1_i$, and at the same time introduce the set of bugs $F2_i$. In addition, running each patch takes a certain amount of time.\n\nDesign an algorithm to use the $m$ patch programs provided by Company T to repair the original software into a bug-free state, while minimizing the total time. For the given $n$ bugs and $m$ patches, find a repair plan with the minimum total time.", "inputFormat": "The first line contains two positive integers $n$ and $m$. Here, $n$ is the total number of bugs, and $m$ is the total number of patches.\n\nThe next $m$ lines describe the $m$ patches. Each line contains a positive integer representing the time required to run patch $i$, followed by two strings of length $n$, separated by a space character.\n\nIn the first string, if the $k$-th character is ```+```, then the $k$-th bug belongs to $B1_i$. If it is ```-```, then the $k$-th bug belongs to $B2_i$. If it is ```0```, then the $k$-th bug belongs to neither $B1_i$ nor $B2_i$, i.e., whether the software contains the $k$-th bug does not affect the applicability of patch $i$.\n\nIn the second string, if the $k$-th character is ```-```, then the $k$-th bug belongs to $F1_i$. If it is ```+```, then the $k$-th bug belongs to $F2_i$. If it is ```0```, then the $k$-th bug belongs to neither $F1_i$ nor $F2_i$, i.e., whether the software contains the $k$-th bug will not change after applying patch $i$.", "outputFormat": "Output the minimum total time after the program finishes. If there is no solution, output `0`.", "hint": "Constraints: For $100\\%$ of the testdata: $1 \\le n \\le 20$, $1 \\le m \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "软件补丁问题", "background": "", "description": "T 公司发现其研制的一个软件中有 $n$ 个错误，随即为该软件发放了 $m$ 个补丁程序。\n\n每一个补丁程序都有其特定的适用环境，某个补丁只有在软件中包含某些错误而同时又不包含另一些错误时才可以使用。一个补丁在排除某些错误的同时，往往会加入另一些错误。\n\n换句话说，对于任意一个补丁 $i$，都有四个与之相应的集合 $B1_i,B2_i,F1_i$ 和 $F2_i$。仅当软件包含 $B1_i$ 中的所有错误，而不包含 $B2_i$ 中的任何错误时，才可以使用补丁 $i$。补丁 $i$ 将修复软件中的某些错误集合 $F1_i$，而同时加入另一些错误 $F2_i$。另外，运行每个补丁都耗费一定的时间。\n\n试设计一个算法，利用 T 公司提供的 $m$ 个补丁程序将原软件修复成一个没有错误的软件，并使修复后的软件耗时最少。对于给定的 $n$ 个错误和 $m$ 个补丁程序，找到总耗时最少的软件修复方案。", "inputFormat": "第一行有两个正整数 $n$ 和 $m$。$n$ 表示错误总数，$m$表示补丁总数。\n\n接下来 $m$ 行给出了 $m$ 个补丁的信息。每行包括一个正整数，表示运行补丁程序 $i$ 所需时间，以及两个长度为 $n$ 的字符串。中间用一个空格符隔开。\n\n第一个字符串中，如果第 $k$ 个字符为 ```+```，则表示第 $k$ 个错误属于 $B1_i$。若为 ```-```，则表示第 $k$ 个错误属于 $B2_i$。若为 ```0```，则第 $k$ 个错误既不属于 $B1_i$ 也不属于 $B2_i$，即软件中是否包含第 $k$ 个错误并不影响补丁 $i$ 的可用性。\n\n第二个字符串中，如果第 $k$ 个字符为 ```-```，则表示第 $k$ 个错误属于 $F1_i$。若为 ```+```，则表示第 $k$ 个错误属于 $F2_i$。若为 ```0```，则第 $k$ 个错误既不属于 $F1_i$ 也不属于 $F2_i$，即软件中是否包含第 $k$ 个错误不会因使用补丁 $i$ 而改变。", "outputFormat": "程序运行结束时，将总耗时数输出。如果问题无解，则输出 `0`。", "hint": "对于 $100\\%$ 的数据：$1\\le n\\le 20$，$1\\le m\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P2762", "type": "P", "difficulty": 6, "samples": [["2 3\n10 1 2\n25 2 3\n5 6 7", "1 2\n1 2 3\n17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流", "Special Judge", "O2优化", "网络流与线性规划 24 题"], "title": "太空飞行计划问题", "background": null, "description": "W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 $ E = \\{ E_1, E_2, \\cdots, E_m \\} $，和进行这些实验需要使用的全部仪器的集合 $ I = \\{ I_1, I_2, \\cdots, I_n \\} $。实验 $ E_j $ 需要用到的仪器是 $ I $ 的子集 $ R_j \\subseteq I $。\n\n配置仪器 $ I_k $ 的费用为 $ c_k $ 美元。实验 $ E_j $ 的赞助商已同意为该实验结果支付 $ p_j $ 美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。\n\n对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。", "inputFormat": "第 $ 1 $ 行有 $ 2 $ 个正整数 $ m $ 和 $ n $。$ m $ 是实验数，$ n $ 是仪器数。接下来的 $ m $ 行，每行是一个实验的有关数据。第一个数赞助商同意支付该实验的费用；接着是该实验需要用到的若干仪器的编号。最后一行的 $ n $ 个数是配置每个仪器的费用。", "outputFormat": "第 $ 1 $ 行是实验编号，第 $ 2 $ 行是仪器编号，最后一行是净收益。", "hint": "感谢 @FlierKing 提供 spj\n\n$1 \\leq n, m \\leq 50 ，1 \\leq c,p < 2^{31}  $。\n\n这道题数据是在 Windows 生成的，输入数据中所有的换行都是 `\\r\\n` 而不是 `\\n`  \n读入某实验需要用到的仪器编号的时候，可以这么读入。(感谢@zhouyonglong的提供)\n```cpp\nchar tools[10000];\nmemset(tools,0,sizeof tools);\ncin.getline(tools,10000);\nint ulen=0,tool;\nwhile (sscanf(tools+ulen,\"%d\",&tool)==1)//之前已经用scanf读完了赞助商同意支付该实验的费用\n{//tool是该实验所需仪器的其中一个      \n    //这一行，你可以将读进来的编号进行储存、处理，如连边。\n    if (tool==0) \n        ulen++;\n    else {\n        while (tool) {\n            tool/=10;\n            ulen++;\n        }\n    }\n    ulen++;\n}\n```", "locale": "zh-CN", "translations": {"en": {"title": "Space Flight Planning Problem", "background": "", "description": "Professor W is planning a series of space flights for the National Space Center. Each space flight can carry out a series of commercial experiments to earn profit. A set of optional experiments has been determined as $ E = \\{ E_1, E_2, \\cdots, E_m \\} $, and the set of all instruments required to conduct these experiments is $ I = \\{ I_1, I_2, \\cdots, I_n \\} $. The instruments required by experiment $ E_j $ form a subset $ R_j \\subseteq I $.\n\nThe cost to configure instrument $ I_k $ is $ c_k $ dollars. The sponsors of experiment $ E_j $ have agreed to pay $ p_j $ dollars for its results. Professor W’s task is to design an efficient algorithm to determine which experiments to conduct and thus which instruments to configure in a single space flight to maximize the net profit. Here, the net profit is defined as the total income from the experiments minus the total cost of configuring the instruments.\n\nGiven the experiments and instrument configuration information, write a program to find the plan with the maximum net profit.", "inputFormat": "The first line contains $ 2 $ positive integers $ m $ and $ n $. Here, $ m $ is the number of experiments and $ n $ is the number of instruments. The next $ m $ lines each describe one experiment. The first number is the payment the sponsor agrees to pay for that experiment, followed by the indices of the instruments required by that experiment. The last line contains $ n $ numbers, which are the configuration costs of each instrument.", "outputFormat": "The first line contains the indices of the selected experiments. The second line contains the indices of the selected instruments. The last line contains the net profit.", "hint": "Thanks to @FlierKing for providing the SPJ.\n\nConstraints: $ 1 \\leq n, m \\leq 50, 1 \\leq c, p < 2^{31} $.\n\nThe testdata for this problem was generated on Windows. All line breaks in the input are `\\r\\n` instead of `\\n` .\nWhen reading the indices of the instruments required by an experiment, you can read them as follows. (Thanks to @zhouyonglong.)\n```cpp\nchar tools[10000];\nmemset(tools,0,sizeof tools);\ncin.getline(tools,10000);\nint ulen=0,tool;\nwhile (sscanf(tools+ulen,\"%d\",&tool)==1)//之前已经用scanf读完了赞助商同意支付该实验的费用\n{//tool是该实验所需仪器的其中一个      \n    //这一行，你可以将读进来的编号进行储存、处理，如连边。\n    if (tool==0) \n        ulen++;\n    else {\n        while (tool) {\n            tool/=10;\n            ulen++;\n        }\n    }\n    ulen++;\n}\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "太空飞行计划问题", "background": null, "description": "W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 $ E = \\{ E_1, E_2, \\cdots, E_m \\} $，和进行这些实验需要使用的全部仪器的集合 $ I = \\{ I_1, I_2, \\cdots, I_n \\} $。实验 $ E_j $ 需要用到的仪器是 $ I $ 的子集 $ R_j \\subseteq I $。\n\n配置仪器 $ I_k $ 的费用为 $ c_k $ 美元。实验 $ E_j $ 的赞助商已同意为该实验结果支付 $ p_j $ 美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。\n\n对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。", "inputFormat": "第 $ 1 $ 行有 $ 2 $ 个正整数 $ m $ 和 $ n $。$ m $ 是实验数，$ n $ 是仪器数。接下来的 $ m $ 行，每行是一个实验的有关数据。第一个数赞助商同意支付该实验的费用；接着是该实验需要用到的若干仪器的编号。最后一行的 $ n $ 个数是配置每个仪器的费用。", "outputFormat": "第 $ 1 $ 行是实验编号，第 $ 2 $ 行是仪器编号，最后一行是净收益。", "hint": "感谢 @FlierKing 提供 spj\n\n$1 \\leq n, m \\leq 50 ，1 \\leq c,p < 2^{31}  $。\n\n这道题数据是在 Windows 生成的，输入数据中所有的换行都是 `\\r\\n` 而不是 `\\n`  \n读入某实验需要用到的仪器编号的时候，可以这么读入。(感谢@zhouyonglong的提供)\n```cpp\nchar tools[10000];\nmemset(tools,0,sizeof tools);\ncin.getline(tools,10000);\nint ulen=0,tool;\nwhile (sscanf(tools+ulen,\"%d\",&tool)==1)//之前已经用scanf读完了赞助商同意支付该实验的费用\n{//tool是该实验所需仪器的其中一个      \n    //这一行，你可以将读进来的编号进行储存、处理，如连边。\n    if (tool==0) \n        ulen++;\n    else {\n        while (tool) {\n            tool/=10;\n            ulen++;\n        }\n    }\n    ulen++;\n}\n```", "locale": "zh-CN"}}}
{"pid": "P2763", "type": "P", "difficulty": 5, "samples": [["3 15\n3 3 4\n2 1 2\n1 3\n1 3\n1 3\n1 3\n3 1 2 3\n2 2 3\n2 1 3\n1 2\n1 2\n2 1 2\n2 1 3\n2 1 2\n1 1\n3 1 2 3", "1: 1 6 8\n2: 7 9 10\n3: 2 3 4 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["网络流", "Special Judge", "网络流与线性规划 24 题"], "title": "试题库问题", "background": "", "description": "问题描述：\n\n假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。\n\n编程任务：\n\n对于给定的组卷要求，计算满足要求的组卷方案。", "inputFormat": "第一行有两个正整数 $k$ 和 $n$。$k$ 表示题库中试题类型总数，$n$ 表示题库中试题总数。\n\n第二行有 $k$ 个正整数，第 $i$ 个正整数表示要选出的类型 $i$ 的题数。这 $k$ 个数相加就是要选出的总题数 $m$。\n\n接下来的 $n$ 行给出了题库中每个试题的类型信息。每行的第一个正整数 $p$ 表明该题可以属于 $p$ 类，接着的 $p$ 个数是该题所属的类型号。", "outputFormat": "输出共 $k$ 行，第 $i$ 行输出 `i: ` 后接类型 $i$ 的题号。  \n如果有多个满足要求的方案，只要输出一个方案。  \n如果问题无解，则输出`No Solution!`。", "hint": "$2\\leq k \\leq 20$，$k \\leq n \\leq 10^3$。\n\n---\n\n感谢 @PhoenixEclipse 提供 spj\n", "locale": "zh-CN", "translations": {"en": {"title": "Question Bank Problem", "background": "", "description": "Problem description:\nAssume a question bank contains $n$ questions. Each question is labeled with one or more types. We need to select $m$ questions from the bank to form an exam paper, and the paper must include the specified numbers of questions of each type. Design an algorithm that meets this requirement.\n\nProgramming task:\nGiven the selection requirements, compute a selection plan that satisfies them.", "inputFormat": "The first line contains two positive integers $k$ and $n$. Here, $k$ is the total number of types in the question bank, and $n$ is the total number of questions.\n\nThe second line contains $k$ positive integers; the $i$-th integer is the required count of type $i$ questions. The sum of these $k$ numbers is the total number of questions to select, $m$.\n\nEach of the next $n$ lines gives the type information for one question. The first positive integer $p$ indicates that the question belongs to $p$ types, followed by $p$ integers that are the type IDs of the question.", "outputFormat": "Output $k$ lines. On the $i$-th line, print `i: ` followed by the indices of the selected questions of type $i$. If multiple valid solutions exist, output any one of them. If no solution exists, output `No Solution!`.", "hint": "$2 \\leq k \\leq 20$, $k \\leq n \\leq 10^3$.\n\nThanks to @PhoenixEclipse for providing the SPJ.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "试题库问题", "background": "", "description": "问题描述：\n\n假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。\n\n编程任务：\n\n对于给定的组卷要求，计算满足要求的组卷方案。", "inputFormat": "第一行有两个正整数 $k$ 和 $n$。$k$ 表示题库中试题类型总数，$n$ 表示题库中试题总数。\n\n第二行有 $k$ 个正整数，第 $i$ 个正整数表示要选出的类型 $i$ 的题数。这 $k$ 个数相加就是要选出的总题数 $m$。\n\n接下来的 $n$ 行给出了题库中每个试题的类型信息。每行的第一个正整数 $p$ 表明该题可以属于 $p$ 类，接着的 $p$ 个数是该题所属的类型号。", "outputFormat": "输出共 $k$ 行，第 $i$ 行输出 `i: ` 后接类型 $i$ 的题号。  \n如果有多个满足要求的方案，只要输出一个方案。  \n如果问题无解，则输出`No Solution!`。", "hint": "$2\\leq k \\leq 20$，$k \\leq n \\leq 10^3$。\n\n---\n\n感谢 @PhoenixEclipse 提供 spj\n", "locale": "zh-CN"}}}
