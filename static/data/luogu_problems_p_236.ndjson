{"pid": "P5772", "type": "P", "difficulty": 6, "samples": [["3 1\n100", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "各省省选", "江苏"], "title": "[JSOI2016] 位运算", "background": "", "description": "JYY 最近在研究位运算。他发现位运算中最有趣的就是异或 (xor) 运算。对于两个数的异或运算，JYY 发现了一个结论：两个数的异或值为 $0$ 当且仅当他们相等。于是 JYY 又开始思考，对于 $N$ 个数的异或值会有什么性质呢？\n\nJYY 想知道，如果在 $0$ 到 $R-1$ 的范围内，选出 $N$ 个不同的整数，并使得这 $N$ 个整数的异或值为 $0$，那么一共有多少种选择的方法呢？（选择的不同次序并不作重复统计，请参见样例）\n\nJYY 是一个计算机科学家，所以他脑海里的 $R$ 非常非常大。为了能够方便的表达，如果我们将 $R$ 写成一个 $01$ 串，那么 $R$ 是由一个较短的 $01$ 串 $S$ 重复 $K$ 次得到的。比如，若 $S=101$，$K=2$，那么 $R$ 的二进制表示则为 $101101$。由于计算的结果会非常大，JYY 只需要你告诉他选择的总数对 $10^9+7$ 取模的结果即可。", "inputFormat": "第一行包含两个正整数 $N$ 和 $K$；\n\n接下来一行包含一个由 $0$ 和 $1$ 组成的字符串 $S$；\n\n我们保证 $S$ 的第一个字符一定为 $1$。", "outputFormat": "一行一个整数，表示选择的方案数对 $10^9+7$ 取模的值。", "hint": "**样例说明**\n\n唯一的一种选择方法是选择 $\\{1,2,3\\}$。\n\n------\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$3 \\le N \\le 7$，$1 \\le k \\le 10^5$，$1 \\le |S| \\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2016] Bitwise Operations", "background": "", "description": "JYY has recently been studying bitwise operations. He found that the most interesting one is the xor operation. For the xor of two numbers, JYY discovered a fact: the xor of two numbers is $0$ if and only if they are equal. Then JYY started thinking: what properties does the xor of $N$ numbers have?\n\nJYY wants to know: within the range from $0$ to $R-1$, choose $N$ distinct integers such that the xor of these $N$ integers is $0$. How many different ways are there to choose them? (Different selection orders are not counted multiple times; see the sample.)\n\nJYY is a computer scientist, so the $R$ in his mind is extremely large. To describe it conveniently, if we write $R$ as a binary string, then $R$ is obtained by repeating a shorter binary string $S$ for $K$ times. For example, if $S=101$ and $K=2$, then the binary representation of $R$ is $101101$. Since the result can be very large, you only need to output the total number of ways modulo $10^9+7$.", "inputFormat": "The first line contains two positive integers $N$ and $K$.\n\nThe next line contains a string $S$ consisting of characters $0$ and $1$.\n\nIt is guaranteed that the first character of $S$ is $1$.", "outputFormat": "Output one integer in one line, the number of valid selections modulo $10^9+7$.", "hint": "**Sample Explanation**\n\nThe only valid selection is $\\{1,2,3\\}$.\n\n------\n\n**Constraints**\n\nFor $100\\%$ of the testdata, $3 \\le N \\le 7$, $1 \\le k \\le 10^5$, $1 \\le |S| \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2016] 位运算", "background": "", "description": "JYY 最近在研究位运算。他发现位运算中最有趣的就是异或 (xor) 运算。对于两个数的异或运算，JYY 发现了一个结论：两个数的异或值为 $0$ 当且仅当他们相等。于是 JYY 又开始思考，对于 $N$ 个数的异或值会有什么性质呢？\n\nJYY 想知道，如果在 $0$ 到 $R-1$ 的范围内，选出 $N$ 个不同的整数，并使得这 $N$ 个整数的异或值为 $0$，那么一共有多少种选择的方法呢？（选择的不同次序并不作重复统计，请参见样例）\n\nJYY 是一个计算机科学家，所以他脑海里的 $R$ 非常非常大。为了能够方便的表达，如果我们将 $R$ 写成一个 $01$ 串，那么 $R$ 是由一个较短的 $01$ 串 $S$ 重复 $K$ 次得到的。比如，若 $S=101$，$K=2$，那么 $R$ 的二进制表示则为 $101101$。由于计算的结果会非常大，JYY 只需要你告诉他选择的总数对 $10^9+7$ 取模的结果即可。", "inputFormat": "第一行包含两个正整数 $N$ 和 $K$；\n\n接下来一行包含一个由 $0$ 和 $1$ 组成的字符串 $S$；\n\n我们保证 $S$ 的第一个字符一定为 $1$。", "outputFormat": "一行一个整数，表示选择的方案数对 $10^9+7$ 取模的值。", "hint": "**样例说明**\n\n唯一的一种选择方法是选择 $\\{1,2,3\\}$。\n\n------\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$3 \\le N \\le 7$，$1 \\le k \\le 10^5$，$1 \\le |S| \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P5773", "type": "P", "difficulty": 6, "samples": [["8\n2 3\n4 5\n0 0\n6 7\n0 8\n0 0\n0 0\n0 0\n7\n6 7 8 5 4 2 3\n", "20\n21\n15\n7\n6\n2\n3\n0\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "各省省选", "江苏", "树链剖分"], "title": "[JSOI2016] 轻重路径", "background": "", "description": "JYY 最近学习了一种处理树形结构的高级技巧，叫「轻重路径剖分」。这种技术会将树中的边划分成轻边和重边。相连的重边会形成一些树上相离的路径。「轻重路径剖分」可以使得从树上任意一点走到根，都至多只会经过 $(\\log N)$ 条不同的重路径。\n\n如果你不了解轻重路径剖分，JYY 在这里简单介绍一下：对于一棵有根树中的任意一个点 $u$，我们用 $size(u)$ 表示其为根的子树中的点的数量。对于 $u$ 的所有孩子中，我们选出 $size$ 值最大的孩子 $v$，并将边 $(u,v)$ 设置成重边，$u$ 和其他孩子之间的边我们均设置为轻边。\n\n为了简化问题，这里 JYY 仅考虑一棵 $N$ 个点的有根二叉树。这 $N$ 个点由 $1$ 到 $N$ 编号。并且如果 $u$ 存在两个 $size$ 值一样的孩子，则我们默认 $u$ 和其左孩子的连边为重边。\n\n现在 JYY 希望执行额外 $Q$ 次删点操作，每次 JYY 会随机删掉一个当前二叉树的叶子节点，而你则需要动态的维护这棵树的轻重路径剖分。\n\n为了方便输出，你只需要在每次操作后输出所有重边指向的点的编号之和即可。\n\n如果删除一个点之后，存在一个点 $u$ 拥有两个 $size$ 值一样的孩子，则我们保持 $u$ 在该操作执行之前的重边划分。", "inputFormat": "第一行包含一个整数 $N$；\n\n接下来 $N$ 行，第 $i$ 行包含两个整数 $L_i,R_i$，表示编号为 $i$ 的点的左孩子编号和右孩子编号，$L_i=0$表示点 $i$ 没有左孩子， $R_i=0$表示点 $i$ 没有右孩子；\n\n第 $N+2$ 行包含一个整数 $Q$，表示 JYY 进行的删点操作；\n\n第 $N+3$ 行包含 $Q$ 个空格分开的正整数，表示 JYY 删去的叶子的编号。\n\n输入数据保证每次删除操作均删除了一个叶子。", "outputFormat": "输出 $Q+1$ 行，每行包含一个整数，表示在轻重路径剖分中所有重边指向的点的编号的和。其中第一行对应初始的路径剖分，之后的 $Q$ 行对应进行了相应删点操作之后路径划分。", "hint": "对于 $30\\%$ 的数据，满足 $N \\le 1000$；\n\n对于 $50\\%$ 的数据，满足 $N \\le 5 \\times 10^4$；\n\n对于全部数据，满足 $N \\le 2 \\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2016] Heavy-Light Paths", "background": "", "description": "JYY has recently learned an advanced technique for processing tree structures, called “heavy-light decomposition”. This technique divides the edges of a tree into light edges and heavy edges. Connected heavy edges form several vertex-disjoint paths on the tree. With heavy-light decomposition, starting from any node and walking to the root, you will pass through at most $(\\log N)$ different heavy paths.\n\nIf you are not familiar with heavy-light decomposition, JYY gives a brief introduction here. For any node $u$ in a rooted tree, let $size(u)$ denote the number of nodes in the subtree rooted at $u$. Among all children of $u$, choose the child $v$ with the largest $size$ value, and mark the edge $(u,v)$ as a heavy edge. All edges between $u$ and its other children are marked as light edges.\n\nTo simplify the problem, JYY only considers a rooted binary tree with $N$ nodes. The $N$ nodes are numbered from $1$ to $N$. If a node $u$ has two children with the same $size$ value, then by default the edge between $u$ and its left child is the heavy edge.\n\nNow JYY wants to perform an additional $Q$ node-deletion operations. Each time, JYY will randomly delete a current leaf node of the binary tree, and you need to dynamically maintain the heavy-light decomposition of this tree.\n\nFor convenient output, after each operation you only need to output the sum of the indices of all nodes pointed to by heavy edges.\n\nIf after deleting a node, there exists a node $u$ whose two children have the same $size$ value, then we keep the heavy-edge choice of $u$ the same as it was before this operation was performed.", "inputFormat": "The first line contains an integer $N$.\n\nThe next $N$ lines: the $i$-th line contains two integers $L_i, R_i$, representing the index of the left child and the right child of node $i$. $L_i = 0$ means node $i$ has no left child, and $R_i = 0$ means node $i$ has no right child.\n\nThe $(N+2)$-th line contains an integer $Q$, indicating the number of deletion operations performed by JYY.\n\nThe $(N+3)$-th line contains $Q$ space-separated positive integers, representing the indices of the leaves deleted by JYY.\n\nThe input guarantees that each deletion operation deletes a leaf.", "outputFormat": "Output $Q + 1$ lines. Each line contains one integer: the sum of the indices of all nodes pointed to by heavy edges in the heavy-light decomposition. The first line corresponds to the initial decomposition, and the following $Q$ lines correspond to the decomposition after each deletion operation.", "hint": "For $30\\%$ of the testdata, $N \\le 1000$.\n\nFor $50\\%$ of the testdata, $N \\le 5 \\times 10^4$.\n\nFor all testdata, $N \\le 2 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2016] 轻重路径", "background": "", "description": "JYY 最近学习了一种处理树形结构的高级技巧，叫「轻重路径剖分」。这种技术会将树中的边划分成轻边和重边。相连的重边会形成一些树上相离的路径。「轻重路径剖分」可以使得从树上任意一点走到根，都至多只会经过 $(\\log N)$ 条不同的重路径。\n\n如果你不了解轻重路径剖分，JYY 在这里简单介绍一下：对于一棵有根树中的任意一个点 $u$，我们用 $size(u)$ 表示其为根的子树中的点的数量。对于 $u$ 的所有孩子中，我们选出 $size$ 值最大的孩子 $v$，并将边 $(u,v)$ 设置成重边，$u$ 和其他孩子之间的边我们均设置为轻边。\n\n为了简化问题，这里 JYY 仅考虑一棵 $N$ 个点的有根二叉树。这 $N$ 个点由 $1$ 到 $N$ 编号。并且如果 $u$ 存在两个 $size$ 值一样的孩子，则我们默认 $u$ 和其左孩子的连边为重边。\n\n现在 JYY 希望执行额外 $Q$ 次删点操作，每次 JYY 会随机删掉一个当前二叉树的叶子节点，而你则需要动态的维护这棵树的轻重路径剖分。\n\n为了方便输出，你只需要在每次操作后输出所有重边指向的点的编号之和即可。\n\n如果删除一个点之后，存在一个点 $u$ 拥有两个 $size$ 值一样的孩子，则我们保持 $u$ 在该操作执行之前的重边划分。", "inputFormat": "第一行包含一个整数 $N$；\n\n接下来 $N$ 行，第 $i$ 行包含两个整数 $L_i,R_i$，表示编号为 $i$ 的点的左孩子编号和右孩子编号，$L_i=0$表示点 $i$ 没有左孩子， $R_i=0$表示点 $i$ 没有右孩子；\n\n第 $N+2$ 行包含一个整数 $Q$，表示 JYY 进行的删点操作；\n\n第 $N+3$ 行包含 $Q$ 个空格分开的正整数，表示 JYY 删去的叶子的编号。\n\n输入数据保证每次删除操作均删除了一个叶子。", "outputFormat": "输出 $Q+1$ 行，每行包含一个整数，表示在轻重路径剖分中所有重边指向的点的编号的和。其中第一行对应初始的路径剖分，之后的 $Q$ 行对应进行了相应删点操作之后路径划分。", "hint": "对于 $30\\%$ 的数据，满足 $N \\le 1000$；\n\n对于 $50\\%$ 的数据，满足 $N \\le 5 \\times 10^4$；\n\n对于全部数据，满足 $N \\le 2 \\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5774", "type": "P", "difficulty": 5, "samples": [["6\n40 200 1 300 2 10", "1950"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2016", "各省省选", "江苏", "区间 DP"], "title": "[JSOI2016] 病毒感染", "background": null, "description": "JOSI 的边陲小镇爆发了严重的 Jebola 病毒疫情，大批群众感染生命垂危。计算机科学家 JYY 采用最新的算法紧急研制出了 Jebola 疫苗，并火速前往灾区救治患者。\n\n一共有 $N$ 个小镇爆发了 Jebola 疫情。这些小镇由于地处边陲，仅仅通过一条长直公路连接。方便起见我们将这些小镇按照公路连接顺序由 $1$ 编号到 $N$。JYY 会在第一天一早抵达 $1$ 号小镇。\n\n一开始在 $i$ 号小镇，有 $a_i$ 名患者感染了 Jebola 病毒。\n\n每一天 JYY 可以选择：\n\n1. 花费一天时间彻底治愈 JYY 目前所在的村庄的所有 Jebola 患者。这一天不会有任何患者死去；\n2. 花费一天的时间前往一个相邻的村庄。\n\n当一天开始时，如果一个村庄里有 $k$ 个 Jebola 患者，那么这一天结束时，这 $k$ 个患者会感染另外 $k$ 个这个村子里的健康村民并死去。所以对于 $i$ 号村庄，只要这个村庄没有被 JYY 彻底消灭疫情，那么每一天都会有 $a_i$ 个村民死去。\n\nJYY 希望采用措施使得疫情被整体消灭时，总共死去的村民数量尽量少。\n\n为了达成这一目标，JYY 有时会选择抵达一个村庄但是并不对村民进行施救。这样的行为如果不加限制，往往会造成更加严重的后果。\n\n试想这样的情形：假设当 JYY 第一次抵达村庄 $i$，未作救治并直接前往了另一个村庄。那么由于 $i$ 村庄的人们求生心切，一旦当 JYY 朝向靠近 $i$ 村庄的方向前行时，$i$ 村庄的村民就会以为 JYY 是来救他们了，而产生巨大的期望。之后倘若 JYY 再次掉头朝着远离 $i$ 村庄的方向行进，那么 $i$ 村庄的村民就会因为巨大的失落而产生绝望的情绪。\n\n为了避免这种情况，JYY 对他的行程做了如下规定：\n\n假设 JYY 进入 $i$ 村庄并在第二天立即离开（村庄 $i$ 的疫情并未治愈）。如果在之后的某一天，JYY 从村庄 $j$ 前往村庄 $k$，并满足 $|k-i| \\lt |i-j|$。那么在之后的日子里 JYY 只能朝着 $i$ 村庄前进直到抵达 $i$ 村庄并立即治愈该村的患者。在前往 $i$ 村庄的过程中，JYY 可以选择将途经村庄的疫情治愈。\n\n比如，如果 JYY 有如下行程：\n\n第一天：从村庄 $1$ 前往村庄 $2$；\n\n第二天：从村庄 $2$ 前往村庄 $3$；\n\n第三天：治愈村庄 $3$；\n\n第四天：前往村庄 $2$。\n\n此时 JYY 对于之后三天的行程只有唯一一种选择：\n\n第五天：治愈村庄 $2$；\n\n第六天：前往村庄 $1$；\n\n第七天：治愈村庄 $1$。\n\nJYY 想知道在治愈所有村庄之前，至少会有多少村民因 Jebola 死去。", "inputFormat": "输入第一行包含一个正整数 $N$；\n\n接下来一行包含 $N$ 个整数，分别为 $a_1,a_2,...,a_N$。", "outputFormat": "输出一行一个整数，表示最优行程安排下会死去的村民数量。", "hint": "**样例说明**\n\n我们用 $C(k)$ 表示治愈 $k$ 号村庄，$i \\rightarrow j$ 表示从村庄 $i$ 前进到村庄 $j$，用逗号分隔每一天的行程安排，那么样例中的最优策略为：\n\n$1 \\rightarrow 2 , C(2),2 \\rightarrow 3 , 3 \\rightarrow 4 , C(4) , 4 \\rightarrow 3 , C(3) , 3 \\rightarrow 2 , 2 \\rightarrow 1 , C(1) , 1 \\rightarrow 2 , 2 \\rightarrow 3 , 3 \\rightarrow 4 , 4 \\rightarrow 5 , 5 \\rightarrow 6 , C(6) , 6 \\rightarrow 5 , C(5)$;\n\n整个过程耗时 $18$ 天。\n\n------\n\n**数据范围**\n\n对于 $10\\%$ 的数据，满足 $N \\le 10$；\n\n对于 $30\\%$ 的数据，满足 $N \\le 20$；\n\n对于 $50\\%$ 的数据，满足 $N \\le 60$；\n\n对于 $100\\%$ 的数据，满足 $1 \\le N \\le 3000$，$1 \\le a_i \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2016] Virus Infection", "background": "", "description": "A severe Jebola virus outbreak has occurred in a remote border town of JOSI, and many people are infected and in critical condition. Computer scientist JYY has urgently developed a Jebola vaccine using the latest algorithm and rushes to the disaster area to treat patients.\n\nThere are $N$ towns with Jebola outbreaks. Because these towns are located on the border, they are connected only by one long straight road. For convenience, we number the towns from $1$ to $N$ in the order along the road. JYY will arrive at town $1$ early on the first day.\n\nInitially, in town $i$, there are $a_i$ patients infected with the Jebola virus.\n\nEach day, JYY may choose one of the following:\n\n1. Spend one day to completely cure all Jebola patients in the town where JYY currently is. On this day, no patients will die.\n2. Spend one day to travel to an adjacent town.\n\nAt the start of a day, if there are $k$ Jebola patients in a town, then by the end of that day, these $k$ patients will infect another $k$ healthy villagers in that town and then die. Therefore, for town $i$, as long as its outbreak has not been completely eliminated by JYY, every day there will be $a_i$ villagers who die.\n\nJYY wants to take actions so that when the epidemic is completely eliminated overall, the total number of villagers who die is as small as possible.\n\nTo achieve this, JYY sometimes will arrive at a town but not treat the villagers. If such behavior is not restricted, it often leads to even more serious consequences.\n\nConsider this situation: suppose when JYY first arrives at town $i$, he does not treat anyone and goes directly to another town. Because the people in town $i$ are desperate to survive, once JYY moves in the direction closer to town $i$, the villagers of town $i$ will think JYY is coming to save them, and they will have great hope. Later, if JYY turns around again and moves in the direction farther away from town $i$, the villagers of town $i$ will fall into despair due to huge disappointment.\n\nTo avoid this, JYY sets the following rule for his trip:\n\nSuppose JYY enters town $i$ and leaves immediately on the second day (and the outbreak in town $i$ is not cured). If on some later day, JYY travels from town $j$ to town $k$ and satisfies $|k-i| \\lt |i-j|$, then in the days after that JYY may only move toward town $i$ until he reaches town $i$ and immediately cures the patients there. While traveling toward town $i$, JYY may choose to cure the outbreaks in towns he passes through.\n\nFor example, if JYY has the following schedule:\n\nDay 1: travel from town $1$ to town $2$.\n\nDay 2: travel from town $2$ to town $3$.\n\nDay 3: cure town $3$.\n\nDay 4: travel to town $2$.\n\nAt this time, for the next three days, JYY has only one possible choice:\n\nDay 5: cure town $2$.\n\nDay 6: travel to town $1$.\n\nDay 7: cure town $1$.\n\nJYY wants to know, before all towns are cured, at least how many villagers will die from Jebola.", "inputFormat": "The first line contains a positive integer $N$.\n\nThe next line contains $N$ integers, which are $a_1,a_2,...,a_N$.", "outputFormat": "Output one line with one integer, representing the number of villagers who will die under the optimal schedule.", "hint": "**Sample Explanation**\n\nWe use $C(k)$ to denote curing town $k$, and $i \\rightarrow j$ to denote traveling from town $i$ to town $j$. Using commas to separate the plan for each day, the optimal strategy in the sample is:\n\n$1 \\rightarrow 2 , C(2),2 \\rightarrow 3 , 3 \\rightarrow 4 , C(4) , 4 \\rightarrow 3 , C(3) , 3 \\rightarrow 2 , 2 \\rightarrow 1 , C(1) , 1 \\rightarrow 2 , 2 \\rightarrow 3 , 3 \\rightarrow 4 , 4 \\rightarrow 5 , 5 \\rightarrow 6 , C(6) , 6 \\rightarrow 5 , C(5)$;\n\nThe whole process takes $18$ days.\n\n------\n\n**Constraints**\n\nFor $10\\%$ of the testdata, $N \\le 10$.\n\nFor $30\\%$ of the testdata, $N \\le 20$.\n\nFor $50\\%$ of the testdata, $N \\le 60$.\n\nFor $100\\%$ of the testdata, $1 \\le N \\le 3000$, $1 \\le a_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2016] 病毒感染", "background": null, "description": "JOSI 的边陲小镇爆发了严重的 Jebola 病毒疫情，大批群众感染生命垂危。计算机科学家 JYY 采用最新的算法紧急研制出了 Jebola 疫苗，并火速前往灾区救治患者。\n\n一共有 $N$ 个小镇爆发了 Jebola 疫情。这些小镇由于地处边陲，仅仅通过一条长直公路连接。方便起见我们将这些小镇按照公路连接顺序由 $1$ 编号到 $N$。JYY 会在第一天一早抵达 $1$ 号小镇。\n\n一开始在 $i$ 号小镇，有 $a_i$ 名患者感染了 Jebola 病毒。\n\n每一天 JYY 可以选择：\n\n1. 花费一天时间彻底治愈 JYY 目前所在的村庄的所有 Jebola 患者。这一天不会有任何患者死去；\n2. 花费一天的时间前往一个相邻的村庄。\n\n当一天开始时，如果一个村庄里有 $k$ 个 Jebola 患者，那么这一天结束时，这 $k$ 个患者会感染另外 $k$ 个这个村子里的健康村民并死去。所以对于 $i$ 号村庄，只要这个村庄没有被 JYY 彻底消灭疫情，那么每一天都会有 $a_i$ 个村民死去。\n\nJYY 希望采用措施使得疫情被整体消灭时，总共死去的村民数量尽量少。\n\n为了达成这一目标，JYY 有时会选择抵达一个村庄但是并不对村民进行施救。这样的行为如果不加限制，往往会造成更加严重的后果。\n\n试想这样的情形：假设当 JYY 第一次抵达村庄 $i$，未作救治并直接前往了另一个村庄。那么由于 $i$ 村庄的人们求生心切，一旦当 JYY 朝向靠近 $i$ 村庄的方向前行时，$i$ 村庄的村民就会以为 JYY 是来救他们了，而产生巨大的期望。之后倘若 JYY 再次掉头朝着远离 $i$ 村庄的方向行进，那么 $i$ 村庄的村民就会因为巨大的失落而产生绝望的情绪。\n\n为了避免这种情况，JYY 对他的行程做了如下规定：\n\n假设 JYY 进入 $i$ 村庄并在第二天立即离开（村庄 $i$ 的疫情并未治愈）。如果在之后的某一天，JYY 从村庄 $j$ 前往村庄 $k$，并满足 $|k-i| \\lt |i-j|$。那么在之后的日子里 JYY 只能朝着 $i$ 村庄前进直到抵达 $i$ 村庄并立即治愈该村的患者。在前往 $i$ 村庄的过程中，JYY 可以选择将途经村庄的疫情治愈。\n\n比如，如果 JYY 有如下行程：\n\n第一天：从村庄 $1$ 前往村庄 $2$；\n\n第二天：从村庄 $2$ 前往村庄 $3$；\n\n第三天：治愈村庄 $3$；\n\n第四天：前往村庄 $2$。\n\n此时 JYY 对于之后三天的行程只有唯一一种选择：\n\n第五天：治愈村庄 $2$；\n\n第六天：前往村庄 $1$；\n\n第七天：治愈村庄 $1$。\n\nJYY 想知道在治愈所有村庄之前，至少会有多少村民因 Jebola 死去。", "inputFormat": "输入第一行包含一个正整数 $N$；\n\n接下来一行包含 $N$ 个整数，分别为 $a_1,a_2,...,a_N$。", "outputFormat": "输出一行一个整数，表示最优行程安排下会死去的村民数量。", "hint": "**样例说明**\n\n我们用 $C(k)$ 表示治愈 $k$ 号村庄，$i \\rightarrow j$ 表示从村庄 $i$ 前进到村庄 $j$，用逗号分隔每一天的行程安排，那么样例中的最优策略为：\n\n$1 \\rightarrow 2 , C(2),2 \\rightarrow 3 , 3 \\rightarrow 4 , C(4) , 4 \\rightarrow 3 , C(3) , 3 \\rightarrow 2 , 2 \\rightarrow 1 , C(1) , 1 \\rightarrow 2 , 2 \\rightarrow 3 , 3 \\rightarrow 4 , 4 \\rightarrow 5 , 5 \\rightarrow 6 , C(6) , 6 \\rightarrow 5 , C(5)$;\n\n整个过程耗时 $18$ 天。\n\n------\n\n**数据范围**\n\n对于 $10\\%$ 的数据，满足 $N \\le 10$；\n\n对于 $30\\%$ 的数据，满足 $N \\le 20$；\n\n对于 $50\\%$ 的数据，满足 $N \\le 60$；\n\n对于 $100\\%$ 的数据，满足 $1 \\le N \\le 3000$，$1 \\le a_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5775", "type": "P", "difficulty": 3, "samples": [["0 1 1 10\n10000\n", "89\n113"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2006", "各省省选", "安徽"], "title": "[AHOI2006] 斐波卡契的兔子", "background": "", "description": "卡卡开始养兔子了！妈妈给他买了一对刚出生的兔子，卡卡了解到兔子的繁殖规律是这样的：才出生的一对兔子在一个月后将第一次生出一胎 $a$ 对兔子，接着在出生后的二个月又将生出 $b$ 对兔子，在第三个月和以后每个月都会繁殖 $c$ 对兔子（$a \\le b \\le c$）。   由斐波纳契数列我们知道兔子的繁殖速度是很快的，然而卡卡有兔子一样多的好朋友，卡卡想在 $m$ 个月后有 $k$ 对兔子，以便分给他们的好友，他的愿望是否能够实现呢？\n\n[任务] 编写一个程序：从输入文件中读入输入信息；计算 $m$ 个月后卡卡将有多少对兔子，设之为 $P$；计算如果 $m$ 个月后卡卡要拥有至少 $k$ 对兔子，那么开始时妈妈至少应该为卡卡购买多少对兔子，设之为 $Q$ ；将结果输出至输出文件。", "inputFormat": "输入文件的第一行有四个正整数：$a$，$b$，$c$ 和 $m$；而第二行则仅含一个正整数 $k$。它们的含义见上文描述。", "outputFormat": "输出两行，第一行是一个整数 $P$ 而第二行是一个整数 $Q$。", "hint": "$0 \\le a \\le b \\le c \\le 100$，$1 \\le m \\le 3000$，$1 \\le k \\le 10^{6000}$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2006] Fibonacci-like Rabbits.", "background": "", "description": "Kaka has started raising rabbits. His mother bought him a pair of newborn rabbits. Kaka learned that the rabbits reproduce as follows: a pair of rabbits will give birth for the first time one month after birth, producing $a$ pairs of rabbits. Then, two months after birth, they will produce $b$ pairs of rabbits. In the third month and every month after that, they will reproduce $c$ pairs of rabbits each month ($a \\le b \\le c$). We know from the Fibonacci sequence that rabbits can reproduce very quickly. However, Kaka has as many good friends as rabbits, so he wants to have $k$ pairs of rabbits after $m$ months to give them to his friends. Can his wish come true?\n\n[Task] Write a program that reads the input information from the input file; computes how many pairs of rabbits Kaka will have after $m$ months, denoted as $P$; computes the minimum number of pairs of rabbits his mother must buy at the beginning so that Kaka will have at least $k$ pairs of rabbits after $m$ months, denoted as $Q$; and outputs the results to the output file.", "inputFormat": "The first line of the input file contains four positive integers: $a$, $b$, $c$, and $m$. The second line contains only one positive integer $k$. Their meanings are described above.", "outputFormat": "Output two lines. The first line contains an integer $P$, and the second line contains an integer $Q$.", "hint": "Constraints: $0 \\le a \\le b \\le c \\le 100$, $1 \\le m \\le 3000$, $1 \\le k \\le 10^{6000}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2006] 斐波卡契的兔子", "background": "", "description": "卡卡开始养兔子了！妈妈给他买了一对刚出生的兔子，卡卡了解到兔子的繁殖规律是这样的：才出生的一对兔子在一个月后将第一次生出一胎 $a$ 对兔子，接着在出生后的二个月又将生出 $b$ 对兔子，在第三个月和以后每个月都会繁殖 $c$ 对兔子（$a \\le b \\le c$）。   由斐波纳契数列我们知道兔子的繁殖速度是很快的，然而卡卡有兔子一样多的好朋友，卡卡想在 $m$ 个月后有 $k$ 对兔子，以便分给他们的好友，他的愿望是否能够实现呢？\n\n[任务] 编写一个程序：从输入文件中读入输入信息；计算 $m$ 个月后卡卡将有多少对兔子，设之为 $P$；计算如果 $m$ 个月后卡卡要拥有至少 $k$ 对兔子，那么开始时妈妈至少应该为卡卡购买多少对兔子，设之为 $Q$ ；将结果输出至输出文件。", "inputFormat": "输入文件的第一行有四个正整数：$a$，$b$，$c$ 和 $m$；而第二行则仅含一个正整数 $k$。它们的含义见上文描述。", "outputFormat": "输出两行，第一行是一个整数 $P$ 而第二行是一个整数 $Q$。", "hint": "$0 \\le a \\le b \\le c \\le 100$，$1 \\le m \\le 3000$，$1 \\le k \\le 10^{6000}$。", "locale": "zh-CN"}}}
{"pid": "P5776", "type": "P", "difficulty": 6, "samples": [["2\n4 6\n1 2 1\n1 3 2\n1 3 3\n2 4 2\n3 4 1\n2 3 1\n2 1\n1 2 3\n", "6\nimpossible\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "图论", "2013", "各省省选", "陕西"], "title": "[SNOI2013] Quare", "background": null, "description": "4.20 四川芦山地震发生后，抗震救灾委员会接到一个紧急任务，四川省给该委员会发了一份地图，这份地图给出了该省一些城市的情况：任两个城市是用一条或多条公路连接起来的，也可以没有公路连接，但是每个城市都可以直接或间接地到达另外的城市，注意这些公路是可以双向行驶的。由于最近余震、暴雨造成泥石流倾泻，使得车辆在这些公路上行驶很不安全，于是四川省决定尽快对部分公路进行抢修，以保障救援车辆行车安全。\n    \n该省对所有的公路情况都进行了勘察，分析估计了抢修某段公路所需要花费的时间，并记录在地图中。现在该省希望抗震救灾委员会能找到一个方案，该方案决定出哪些公路需要抢修，使得抢修后的公路仍能保证任意两个城市之间都能直接或间接地相连，同时为了安全起见，即使某一条抢修的公路被泥石流阻断了，任意两城市仍能保持这个性质。由于时间紧迫，抗震救灾委员会还需保证找到的这个方案总抢修时间最短。", "inputFormat": "第一行为一个整数 $T$，为数据总数，接下来按顺序给出每个数据的描述。\n\n首先是两个整数 $n, m$ 分别表示城市数量和公路数量，下面 $m$ 行每行三个整数 $x, y, c$ 描述了一条公路的情况：$x$ 城市与 $y$ 城市之间的一条公路，抢修该公路需要 $c$ 个单位时间。\n\n注意上面所说的两城市间可能有多条公路。", "outputFormat": "按顺序输出每个数据的结果，如果找不到一条合适的方案，则输出一行 `impossible`，否则输出一个整数，为抢修的最优方案所需要的总时间。", "hint": "对于 $100\\%$ 的数据，$1 \\leq T \\leq 3$，$1 \\leq n \\leq 12$，$1 \\leq m \\leq 40$，$1\\le c\\le 5\\times 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[SNOI2013] Quare", "background": null, "description": "4.20 四川芦山地震发生后，抗震救灾委员会接到一个紧急任务，四川省给该委员会发了一份地图，这份地图给出了该省一些城市的情况：任两个城市是用一条或多条公路连接起来的，也可以没有公路连接，但是每个城市都可以直接或间接地到达另外的城市，注意这些公路是可以双向行驶的。由于最近余震、暴雨造成泥石流倾泻，使得车辆在这些公路上行驶很不安全，于是四川省决定尽快对部分公路进行抢修，以保障救援车辆行车安全。\n    \n该省对所有的公路情况都进行了勘察，分析估计了抢修某段公路所需要花费的时间，并记录在地图中。现在该省希望抗震救灾委员会能找到一个方案，该方案决定出哪些公路需要抢修，使得抢修后的公路仍能保证任意两个城市之间都能直接或间接地相连，同时为了安全起见，即使某一条抢修的公路被泥石流阻断了，任意两城市仍能保持这个性质。由于时间紧迫，抗震救灾委员会还需保证找到的这个方案总抢修时间最短。", "inputFormat": "第一行为一个整数 $T$，为数据总数，接下来按顺序给出每个数据的描述。\n\n首先是两个整数 $n, m$ 分别表示城市数量和公路数量，下面 $m$ 行每行三个整数 $x, y, c$ 描述了一条公路的情况：$x$ 城市与 $y$ 城市之间的一条公路，抢修该公路需要 $c$ 个单位时间。\n\n注意上面所说的两城市间可能有多条公路。", "outputFormat": "按顺序输出每个数据的结果，如果找不到一条合适的方案，则输出一行 `impossible`，否则输出一个整数，为抢修的最优方案所需要的总时间。", "hint": "对于 $100\\%$ 的数据，$1 \\leq T \\leq 3$，$1 \\leq n \\leq 12$，$1 \\leq m \\leq 40$，$1\\le c\\le 5\\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P5777", "type": "P", "difficulty": 0, "samples": [["1\n5 0 1 0\n0 0 0 0 0 0 0 0\n1 0 0 0 1 0 0 0\n0 1 0 0 1 1 0 0\n1 1 0 0 0 1 0 0\n0 0 1 0 0 1 1 0\n1 0 1 0 1 1 1 0\n0 1 1 0 1 0 1 0\n1 1 1 0 0 0 1 0\n0 0 0 1 0 0 1 1\n1 0 0 1 1 0 1 1\n0 1 0 1 1 1 1 1\n1 1 0 1 0 1 1 1\n0 0 1 1 0 1 0 1\n1 0 1 1 1 1 0 1\n0 1 1 1 1 0 0 1\n1 1 1 1 0 0 0 1", "Yes\n3\n5 1 2 1\n6 1 3 2\n7 1 4 3\n5 6 7 4"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2001", "CTSC/CTS"], "title": "[CTSC2001] 逻辑电路最优设计", "background": "", "description": "W 教授在 T 大学计算机系里开了一门「数字逻辑」课，主要讲授如何设计逻辑电路。这一天，W 教授布置了一个实验：设计并实现一个 $4$ 端输入、$4$ 端输出的逻辑译码电路。设计这样的电路原本并不困难，但是，教授给出了如下的要求：\n1. 只允许使用 $2$ 端输入、$1$ 端输出的门电路作为实现电路的组件，而且可用门电路的种类和数目都已给定；\n2. 使用最少数目的门电路。\n\n这两个要求难倒了全系的同学，于是，Q 同学找到了正在参加 CTSC（中国队选拔赛）的你，希望你能帮忙编写一个程序，自动找出符合要求的连接方式。\n\n在数字逻辑中，所有信号都可以看作只有两个值：「高电平」和「低电平」，分别用 $1$ 和 $0$ 来表示。\n\n一个门电路元件的特性由其输入/输出功能表唯一给出，所谓功能表，就是输入信号电平与输出信号电平之间的关系表。比如，「与门」的符号和功能表如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b87mvx5h.png)\n\n|X|Y|S|\n|:-:|:-:|:-:|\n|0|0|0|\n|1|0|0|\n|0|1|0|\n|1|1|1|\n\n上图中，如果「与门」的两个输入端 X 和 Y 都是高电平 $1$，则输出端 S 也是高电平 $1$，否则，输出端 S 是低电平 $0$。\n\n假定，本次实验提供的门电路都具有输入对称性，即交换两个输入端的信号，输出不变。但是，如果门电路的输入端悬空（即没有加输入信号），则输出无意义。\n\n在连接电路的过程中，一个门电路的输出端可以将信号送到其他多个元件的输入端；而门电路的一个输入端则只能接收来自一个输出端的信号。如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7fp5byqu.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/8gad519v.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/5tg1p4j0.png)\n\n其中，前两个连接方式是允许的，最后一个是不允许的。\n\n另外，规定信号必须单向传输，即一个门电路的输出不能直接或间接通过其他门电路回到同一门电路的输入端。如下图所示即为两种不允许的连接方式：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vwlmk3nq.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/77boianl.png)\n\n要求你设计的译码电路是一个有四个输入端和四个输出端的逻辑电路，该译码电路的输入和输出关系通过功能表给出，即给出每种输入组合下的四个输出端的情况。显然，一共有 $2^4=16$ 种输入组合。比如，一个由前述「与门」构成的 $2$ 输入，$2$ 输出的简单译码电路如下图所示（其中，A1, A2 是输入端，Y1, Y2 是输出端）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ik5itzwc.png)\n\n|A1|A2|Y1|Y2|\n|:-:|:-:|:-:|:-:|\n|0|0|0|0|\n|1|0|0|0|\n|0|1|0|0|\n|1|1|1|1|", "inputFormat": "第一行为一个正整数 $n(n\\le 5)$，表示元件的种类数，其后有连续的 $n$ 行，每行描述一种元件。对正整数 $1\\le k\\le n$：\n\n第 $k+1$ 行有四个以空格隔开的整数，依次为：$m_k,Y_{00},Y_{01},Y_{11}$。\n \n其中，正整数 $m_k$ 表示第 $k$ 种元件的数目（$k$ 即这种元件的种类编号），所有元件的数目之和不会超过 $10$（用于实验的经费并不充足）。$Y_{ij}$ 表示两个输入端分别为 $i$ 和 $j$ 时的输出，即 $Y_{00},Y_{01},Y_{11}$ 是三个非 $0$ 即 $1$ 的数，分别表示在两个输入端均为 $0$；两个输入端一个为 $0$ 另一个为 $1$；以及两个输入端均为 $1$ 的时候，该元件的输出。\n\n第 $n+2$ 到第 $n+17$ 行，表示需组成的集成电路的功能表，每行有 $8$ 个数，分别为 $0$ 或 $1$。其中，前四个数依次对应四个输入端（编号为 $1\\sim 4$）的信号，不存在两行的前四个数完全相同；而后面四个数则对应在各输入端信号为前四个数时，四个输出端依次应输出的信号。", "outputFormat": "第一行为一个单词，`Yes` 或 `No`，如果存在符合要求的设计方案，则为 `Yes`，否则为 `No`。\n\n如果第一行是 `No`，则输出结束。\n\n否则第二行只有一个非负整数 $p$，表示最少需要的门电路数目。下面 $p$ 行分别给出每个门电路在电路中的连接情况的描述。每行有四个以空格隔开的正整数：$S ,K, A, B$，其中 $S$ 表示该门电路的编号（所有用到的门电路按 $5\\sim p+4$ 编号，$1\\sim 4$ 的编号用来表示四个输入端）；$K$ 表示该元件的种类编号（按照输入文件中的顺序由 $1\\sim n$ 编号）；$A$ 和 $B$ 分别表示接入该元件的两个输入端的门电路或译码电路输入端的编号（其中，$A<S,B<S$）。\n\n最后一行有四个正整数，表示组成的译码电路的四个输出端分别所接的元件的编号（在 $1\\sim p+4$ 之间）。", "hint": "#### 样例解释\n样例对应的电路连接方式如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/za2oqzvt.png)", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2001] Optimal Design of Logic Circuits", "background": "", "description": "Professor W teaches a “Digital Logic” course in the Department of Computer Science at University T, mainly about how to design logic circuits. One day, Professor W assigned a lab: design and implement a logic decoder circuit with $4$ inputs and $4$ outputs. Designing such a circuit is not difficult by itself, but the professor imposed the following requirements:\n\n1. You may only use gate components with $2$ inputs and $1$ output, and the available types and quantities of gates are given.\n2. Use as few gate components as possible.\n\nThese requirements stumped the whole department, so student Q came to you, who are participating in CTSC (China Team Selection Contest), and hopes you can write a program to automatically find a wiring scheme that satisfies the requirements.\n\nIn digital logic, all signals can be considered to have only two values: “high level” and “low level”, represented by $1$ and $0$, respectively.\n\nThe behavior of a gate component is uniquely determined by its input/output truth table. A truth table describes the relationship between input signal levels and the output signal level. For example, the symbol and truth table of an “AND gate” are shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b87mvx5h.png)\n\n|X|Y|S|\n|:-:|:-:|:-:|\n|0|0|0|\n|1|0|0|\n|0|1|0|\n|1|1|1|\n\nIn the figure above, if both inputs $X$ and $Y$ of the AND gate are at high level $1$, then the output $S$ is also high level $1$; otherwise, the output $S$ is low level $0$.\n\nAssume that all gate components provided in this lab have symmetric inputs, meaning that swapping the two inputs does not change the output. However, if an input pin of a gate is left floating (i.e., no input signal is connected), then the output is meaningless.\n\nWhen wiring the circuit, the output pin of a gate may send its signal to the input pins of multiple other components, but each input pin of a gate may receive a signal from only one output pin, as shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7fp5byqu.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/8gad519v.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/5tg1p4j0.png)\n\nAmong them, the first two wiring methods are allowed, while the last one is not allowed.\n\nIn addition, signals must be transmitted in only one direction. That is, the output of a gate cannot return (directly or indirectly through other gates) to an input of the same gate. The following figures show two forbidden wiring methods:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vwlmk3nq.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/77boianl.png)\n\nThe decoder circuit you are required to design is a logic circuit with four inputs and four outputs. The input-output relationship of this decoder is given by a truth table, i.e., for each input combination, the states of the four output pins are specified. Clearly, there are $2^4=16$ possible input combinations. For example, a simple $2$-input, $2$-output decoder circuit built from the AND gate above is shown below (where A1, A2 are inputs, and Y1, Y2 are outputs):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ik5itzwc.png)\n\n|A1|A2|Y1|Y2|\n|:-:|:-:|:-:|:-:|\n|0|0|0|0|\n|1|0|0|0|\n|0|1|0|0|\n|1|1|1|1|", "inputFormat": "The first line contains a positive integer $n(n\\le 5)$, the number of component types. The next $n$ consecutive lines each describe one type of component. For an integer $1\\le k\\le n$:\n\nLine $k+1$ contains four integers separated by spaces: $m_k,Y_{00},Y_{01},Y_{11}$.\n\nHere, the positive integer $m_k$ is the number of available components of type $k$ (where $k$ is the type index). The total number of all components will not exceed $10$ (the lab budget is limited). $Y_{ij}$ denotes the output when the two inputs are $i$ and $j$, respectively. That is, $Y_{00},Y_{01},Y_{11}$ are three values each being either $0$ or $1$, representing the output when both inputs are $0$; when one input is $0$ and the other is $1$; and when both inputs are $1$.\n\nLines $n+2$ to $n+17$ give the truth table of the integrated circuit to be constructed. Each line contains $8$ numbers, each either $0$ or $1$. The first four numbers correspond to the signals on the four input pins (numbered $1\\sim 4$) in order; no two lines have exactly the same first four numbers. The last four numbers correspond to the signals that the four output pins should produce (in order) when the inputs are the given first four numbers.", "outputFormat": "The first line contains one word, `Yes` or `No`. If there exists a design that satisfies the requirements, output `Yes`; otherwise output `No`.\n\nIf the first line is `No`, the output ends.\n\nOtherwise, the second line contains one non-negative integer $p$, the minimum number of gate components needed. The next $p$ lines each describe the wiring of one gate in the circuit. Each line contains four positive integers separated by spaces: $S ,K, A, B$. Here, $S$ is the index of this gate (all used gates are numbered $5\\sim p+4$, while $1\\sim 4$ are reserved for the four input pins). $K$ is the component type index (numbered $1\\sim n$ in the order of the input). $A$ and $B$ are the indices of the gate or decoder input pin connected to the two input pins of this component, respectively (where $A<S,B<S$).\n\nThe last line contains four positive integers, indicating the indices of the components connected to the four output pins of the decoder circuit, respectively (each between $1\\sim p+4$).", "hint": "#### Sample Explanation\n\nThe wiring scheme corresponding to the sample is shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/za2oqzvt.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2001] 逻辑电路最优设计", "background": "", "description": "W 教授在 T 大学计算机系里开了一门「数字逻辑」课，主要讲授如何设计逻辑电路。这一天，W 教授布置了一个实验：设计并实现一个 $4$ 端输入、$4$ 端输出的逻辑译码电路。设计这样的电路原本并不困难，但是，教授给出了如下的要求：\n1. 只允许使用 $2$ 端输入、$1$ 端输出的门电路作为实现电路的组件，而且可用门电路的种类和数目都已给定；\n2. 使用最少数目的门电路。\n\n这两个要求难倒了全系的同学，于是，Q 同学找到了正在参加 CTSC（中国队选拔赛）的你，希望你能帮忙编写一个程序，自动找出符合要求的连接方式。\n\n在数字逻辑中，所有信号都可以看作只有两个值：「高电平」和「低电平」，分别用 $1$ 和 $0$ 来表示。\n\n一个门电路元件的特性由其输入/输出功能表唯一给出，所谓功能表，就是输入信号电平与输出信号电平之间的关系表。比如，「与门」的符号和功能表如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b87mvx5h.png)\n\n|X|Y|S|\n|:-:|:-:|:-:|\n|0|0|0|\n|1|0|0|\n|0|1|0|\n|1|1|1|\n\n上图中，如果「与门」的两个输入端 X 和 Y 都是高电平 $1$，则输出端 S 也是高电平 $1$，否则，输出端 S 是低电平 $0$。\n\n假定，本次实验提供的门电路都具有输入对称性，即交换两个输入端的信号，输出不变。但是，如果门电路的输入端悬空（即没有加输入信号），则输出无意义。\n\n在连接电路的过程中，一个门电路的输出端可以将信号送到其他多个元件的输入端；而门电路的一个输入端则只能接收来自一个输出端的信号。如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7fp5byqu.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/8gad519v.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/5tg1p4j0.png)\n\n其中，前两个连接方式是允许的，最后一个是不允许的。\n\n另外，规定信号必须单向传输，即一个门电路的输出不能直接或间接通过其他门电路回到同一门电路的输入端。如下图所示即为两种不允许的连接方式：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vwlmk3nq.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/77boianl.png)\n\n要求你设计的译码电路是一个有四个输入端和四个输出端的逻辑电路，该译码电路的输入和输出关系通过功能表给出，即给出每种输入组合下的四个输出端的情况。显然，一共有 $2^4=16$ 种输入组合。比如，一个由前述「与门」构成的 $2$ 输入，$2$ 输出的简单译码电路如下图所示（其中，A1, A2 是输入端，Y1, Y2 是输出端）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ik5itzwc.png)\n\n|A1|A2|Y1|Y2|\n|:-:|:-:|:-:|:-:|\n|0|0|0|0|\n|1|0|0|0|\n|0|1|0|0|\n|1|1|1|1|", "inputFormat": "第一行为一个正整数 $n(n\\le 5)$，表示元件的种类数，其后有连续的 $n$ 行，每行描述一种元件。对正整数 $1\\le k\\le n$：\n\n第 $k+1$ 行有四个以空格隔开的整数，依次为：$m_k,Y_{00},Y_{01},Y_{11}$。\n \n其中，正整数 $m_k$ 表示第 $k$ 种元件的数目（$k$ 即这种元件的种类编号），所有元件的数目之和不会超过 $10$（用于实验的经费并不充足）。$Y_{ij}$ 表示两个输入端分别为 $i$ 和 $j$ 时的输出，即 $Y_{00},Y_{01},Y_{11}$ 是三个非 $0$ 即 $1$ 的数，分别表示在两个输入端均为 $0$；两个输入端一个为 $0$ 另一个为 $1$；以及两个输入端均为 $1$ 的时候，该元件的输出。\n\n第 $n+2$ 到第 $n+17$ 行，表示需组成的集成电路的功能表，每行有 $8$ 个数，分别为 $0$ 或 $1$。其中，前四个数依次对应四个输入端（编号为 $1\\sim 4$）的信号，不存在两行的前四个数完全相同；而后面四个数则对应在各输入端信号为前四个数时，四个输出端依次应输出的信号。", "outputFormat": "第一行为一个单词，`Yes` 或 `No`，如果存在符合要求的设计方案，则为 `Yes`，否则为 `No`。\n\n如果第一行是 `No`，则输出结束。\n\n否则第二行只有一个非负整数 $p$，表示最少需要的门电路数目。下面 $p$ 行分别给出每个门电路在电路中的连接情况的描述。每行有四个以空格隔开的正整数：$S ,K, A, B$，其中 $S$ 表示该门电路的编号（所有用到的门电路按 $5\\sim p+4$ 编号，$1\\sim 4$ 的编号用来表示四个输入端）；$K$ 表示该元件的种类编号（按照输入文件中的顺序由 $1\\sim n$ 编号）；$A$ 和 $B$ 分别表示接入该元件的两个输入端的门电路或译码电路输入端的编号（其中，$A<S,B<S$）。\n\n最后一行有四个正整数，表示组成的译码电路的四个输出端分别所接的元件的编号（在 $1\\sim p+4$ 之间）。", "hint": "#### 样例解释\n样例对应的电路连接方式如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/za2oqzvt.png)", "locale": "zh-CN"}}}
{"pid": "P5778", "type": "P", "difficulty": 0, "samples": [["4 2\n60 -1\n70 -1\n80 45\n-1 65", "4\n3\n2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2001", "CTSC/CTS"], "title": "[CTSC2001] GPA 排名系统", "background": "", "description": "目前，高等院校往往采用 GPA *(Grade Point Average)* 来评价学生的学术表现。传统的排名方式是求每一个学生的平均成绩，以平均成绩作为依据进行排名。\n\n但是这样的排名方法已经引起了教育界以及社会各界人士的争议。因为它存在着许多弊端。对于不同的课程，选课学生的平均成绩会不同程度地受到课程的难易程度和老师的严厉程度的制约。因而这样的排名系统无形中就鼓励了学生选择一些比较容易的课程，因为这样可以事半功倍地获得较高的平均分。\n\n为了克服这些弊端，我们需要对排名系统做一定的改进。\n\n一种改进的方案是对选第 $i$ 门课的每一个学生的成绩加上一个特定的修正值 $d_i$，例如编号为 $j$ 的学生该课的成绩 $G_{ij}$ 修改为 $G’_{ij}=G_{ij}+d_i$。最终使得经过调整后，该课的平均分等于选该课的所有学生的所有课的平均分。对每一门课都做这样的调整，使得上述条件对所有课程都满足。这种调整方案一定程度地避免了传统排名系统的不公正。而你的任务正是根据一个大学某一个年级学生某学年的成绩，给出他们的排名。假设每一个学生都至少选一门课。", "inputFormat": "第一行是两个正整数 $m$ 和 $n$，分别表示学生人数和课程数目。\n\n接下来 $m$ 行是一个矩阵，矩阵中第 $i$ 行的第 $j$ 个元素表示第 $i$ 个学生第 $j$ 门课的成绩 $G_{ij}$。如果该学生没有选这门课，那么 $G_{ij}＝-1$。由于该方案的施行只是为了获得更加科学的排名，因此调整后的成绩的数值大小本身没有什么意义，因此调整后的成绩可以不是 $0\\sim 100$ 之间的数。", "outputFormat": "输出采用改进方案后这些学生的排名。以学生编号的形式输出，每行是一个学生的编号。\n\n如果在上述调整后，有若干学生平均分相等（精确到小数点后的三位），则他们的名次相同，按照字典序输出。\n\n当然许多时候，上述调整无法顺利进行，即调整的目标无法达到。（因此，在实际问题中，我们往往在最小二乘意义下获得一种最接近目标的调整方案。）也有可能或者因调整不唯一而不能确定学生的名次。若以上两种情况发生，则输出 `fail`。", "hint": "#### 样例解释\n一种可行的调整方法是：\n\n第一门课每一个学生的成绩加上 $10$，第二门课每一个学生的成绩加上 $35$。\n调整后的情况是：\n```plain\n70 –1\n80 –1\n90 80\n-1 100\n```\n调整后第一门课的平均分为：$(70＋80+90)/3=80$，选第一门课的所有学生的所有课的平均分为：$(70+80+90+80)/4=80$。\n\n第二门课的平均分为：$(80+100)/2=90$，选第二门课的所有学生的所有课的平均分为：$(90+80+100)/3=90$。\n\n然后，计算每一个学生的平均分并且排名，即得到了输出的结果。\n\n#### 数据范围\n对于全部数据，$1\\le m\\le 500$，$1\\le n\\le 100$，$-1\\le G_{ij}\\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2001] GPA Ranking System", "background": "", "description": "At present, universities and colleges often use GPA *(Grade Point Average)* to evaluate students’ academic performance. The traditional ranking method is to compute each student’s average score and rank students based on that average.\n\nHowever, this ranking method has caused controversy in education and in society, because it has many drawbacks. For different courses, the average score of enrolled students is affected to different degrees by the difficulty of the course and how strict the instructor is. Therefore, this ranking system indirectly encourages students to choose easier courses, because they can get a higher average score with less effort.\n\nTo overcome these drawbacks, we need to improve the ranking system.\n\nOne improved approach is to add a specific adjustment value $d_i$ to the score of every student who takes course $i$. For example, the score $G_{ij}$ of student $j$ in this course is changed to $G’_{ij}=G_{ij}+d_i$. The goal is that, after adjustment, the average score of this course equals the average of all courses taken by all students who take this course. Perform such an adjustment for every course so that the above condition holds for all courses. This adjustment method can reduce the unfairness of the traditional ranking system to some extent. Your task is to produce the ranking based on the scores of students in one grade of a university for one academic year. Assume that every student takes at least one course.", "inputFormat": "The first line contains two positive integers $m$ and $n$, representing the number of students and the number of courses.\n\nThe next $m$ lines form a matrix. The element in row $i$, column $j$ represents the score $G_{ij}$ of student $i$ in course $j$. If the student did not take this course, then $G_{ij}=-1$. Since this approach is only used to obtain a more scientific ranking, the absolute values of the adjusted scores themselves are not meaningful, so the adjusted scores do not have to be within $0\\sim 100$.", "outputFormat": "Output the ranking of these students under the improved approach. Output student indices, one per line.\n\nIf, after the adjustment, several students have the same average score (accurate to three digits after the decimal point), then they share the same rank, and they should be output in lexicographical order.\n\nOf course, in many cases, the adjustment above cannot be carried out successfully, meaning the target cannot be achieved. (Therefore, in real problems, we often find an adjustment scheme that is closest to the target in the least-squares sense.) It is also possible that the students’ ranks cannot be determined because the adjustment is not unique. If either of the above two situations occurs, output `fail`.", "hint": "#### Sample Explanation\n\nOne feasible adjustment method is:\n\nAdd $10$ to each student’s score in the first course, and add $35$ to each student’s score in the second course. The adjusted results are:\n```plain\n70 –1\n80 –1\n90 80\n-1 100\n```\nAfter adjustment, the average score of the first course is: $(70＋80+90)/3=80$. The average of all courses taken by all students who take the first course is: $(70+80+90+80)/4=80$.\n\nThe average score of the second course is: $(80+100)/2=90$. The average of all courses taken by all students who take the second course is: $(90+80+100)/3=90$.\n\nThen, compute each student’s average score and rank them, and you obtain the output result.\n\n#### Constraints\n\nFor all testdata, $1\\le m\\le 500$, $1\\le n\\le 100$, $-1\\le G_{ij}\\le 100$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2001] GPA 排名系统", "background": "", "description": "目前，高等院校往往采用 GPA *(Grade Point Average)* 来评价学生的学术表现。传统的排名方式是求每一个学生的平均成绩，以平均成绩作为依据进行排名。\n\n但是这样的排名方法已经引起了教育界以及社会各界人士的争议。因为它存在着许多弊端。对于不同的课程，选课学生的平均成绩会不同程度地受到课程的难易程度和老师的严厉程度的制约。因而这样的排名系统无形中就鼓励了学生选择一些比较容易的课程，因为这样可以事半功倍地获得较高的平均分。\n\n为了克服这些弊端，我们需要对排名系统做一定的改进。\n\n一种改进的方案是对选第 $i$ 门课的每一个学生的成绩加上一个特定的修正值 $d_i$，例如编号为 $j$ 的学生该课的成绩 $G_{ij}$ 修改为 $G’_{ij}=G_{ij}+d_i$。最终使得经过调整后，该课的平均分等于选该课的所有学生的所有课的平均分。对每一门课都做这样的调整，使得上述条件对所有课程都满足。这种调整方案一定程度地避免了传统排名系统的不公正。而你的任务正是根据一个大学某一个年级学生某学年的成绩，给出他们的排名。假设每一个学生都至少选一门课。", "inputFormat": "第一行是两个正整数 $m$ 和 $n$，分别表示学生人数和课程数目。\n\n接下来 $m$ 行是一个矩阵，矩阵中第 $i$ 行的第 $j$ 个元素表示第 $i$ 个学生第 $j$ 门课的成绩 $G_{ij}$。如果该学生没有选这门课，那么 $G_{ij}＝-1$。由于该方案的施行只是为了获得更加科学的排名，因此调整后的成绩的数值大小本身没有什么意义，因此调整后的成绩可以不是 $0\\sim 100$ 之间的数。", "outputFormat": "输出采用改进方案后这些学生的排名。以学生编号的形式输出，每行是一个学生的编号。\n\n如果在上述调整后，有若干学生平均分相等（精确到小数点后的三位），则他们的名次相同，按照字典序输出。\n\n当然许多时候，上述调整无法顺利进行，即调整的目标无法达到。（因此，在实际问题中，我们往往在最小二乘意义下获得一种最接近目标的调整方案。）也有可能或者因调整不唯一而不能确定学生的名次。若以上两种情况发生，则输出 `fail`。", "hint": "#### 样例解释\n一种可行的调整方法是：\n\n第一门课每一个学生的成绩加上 $10$，第二门课每一个学生的成绩加上 $35$。\n调整后的情况是：\n```plain\n70 –1\n80 –1\n90 80\n-1 100\n```\n调整后第一门课的平均分为：$(70＋80+90)/3=80$，选第一门课的所有学生的所有课的平均分为：$(70+80+90+80)/4=80$。\n\n第二门课的平均分为：$(80+100)/2=90$，选第二门课的所有学生的所有课的平均分为：$(90+80+100)/3=90$。\n\n然后，计算每一个学生的平均分并且排名，即得到了输出的结果。\n\n#### 数据范围\n对于全部数据，$1\\le m\\le 500$，$1\\le n\\le 100$，$-1\\le G_{ij}\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P5779", "type": "P", "difficulty": 5, "samples": [["5 8\n3 2\n2 3\n-1 -1", "3\n2 8 6\n5 8 3\n6 8 2\n1\n1 1 2\n1\n2 3 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2001", "CTSC/CTS"], "title": "[CTSC2001] 聪明的学生", "background": "", "description": "一位教授逻辑学的教授有三名非常善于推理且精于心算的学生 A，B 和 C。有一天,教授给他们三人出了一道题：教授在每个人脑门上贴了一张纸条并告诉他们，每个人的纸条上都写了一个正整数，且某两个数的和等于第三个。于是，每个学生都能看见贴在另外两个同学头上的整数，但却看不见自己的数。\n\n这时，教授先对学生 A 发问了：「你能猜出自己的数吗？」A 回答：「不能。」\n\n教授又转身问学生 B：「你能猜出自己的数吗？」B 想了想，也回答：「不能。」\n\n教授再问学生 C 同样的问题，C 思考了片刻后，摇了摇头：「不能。」\n\n接着，教授又重新问 A 同样的问题，再问 B 和 C，……，经过若干轮的提问之后，当教授再次询问某人时，此人突然露出了得意的笑容，把贴在自己头上的那个数准确无误的报了出来。\n\n现在，如果告诉你：教授在第 $N$ 次提问时，轮到回答问题的那个人猜出了贴在自己头上的数是 $M$，你能推断出另外两个学生的头上贴的是什么数吗？\n\n#### 提示\n在没有人猜出自己头上的数之前，大家对教授提问的回答始终都是「不能」；而且除此之外在 A，B，C 之间是没有进行任何信息交流的。也就是说，每个人推断的依据仅仅是另外两个人的头上数，以及大家对教授的提问所做出的否定回答。\n\n教授总是从学生 A 开始提问的。\n\n你可以假定，这三个足够聪明的学生能够根据已知的条件在最早的轮次猜出自己的数，并且永远都不会猜错。\n\n稍经分析和推理，你将得出以下结论：**总是头上贴着最大的那个数的人最先猜出自己头上的数。**", "inputFormat": "输入包括若干组测试数据，其中的每一行代表一组测试数据。\n\n对于每组测试数据，由两个整数 $N$ 和 $M$ 组成，即在教授第 $N$ 次提问时，轮到回答问题的那个人猜出了贴在自己头上的数是 $M$。两个数之间用空格分隔开。\n\n最后，由 `-1 -1` 组成的一行标志着输入数据的结束。", "outputFormat": "按照输入中的顺序依次给出各组数据的结果。\n\n输出中对应每组数据的输出的第一行是一个整数 $p$，是可能情况的总数。接下来的 $p$ 行，每一行包括三个数，分别为贴在 A，B，C 头上的三个数。输出时，所有解按照 A 头上的数增序排列；在 A 头上的数相同的情况下，按照 B 头上的数增序排列。", "hint": "对于全部数据，$N<500$，$M<3\\times 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2001] Clever Students", "background": "", "description": "A professor who teaches logic has three students, A, B, and C, who are very good at reasoning and quick mental arithmetic. One day, the professor gives them a problem: he sticks a note on each person’s forehead and tells them that each note has a positive integer, and that the sum of two of the numbers equals the third. Therefore, each student can see the integers on the other two students’ foreheads, but cannot see their own number.\n\nThe professor first asks student A: “Can you guess your number?” A answers: “No.”\n\nThe professor then asks student B: “Can you guess your number?” B thinks for a while and also answers: “No.”\n\nThe professor asks student C the same question. After thinking for a moment, C shakes his head and answers: “No.”\n\nNext, the professor asks A the same question again, then asks B and C, and so on. After several rounds of questioning, when the professor asks someone again, that person suddenly smiles proudly and reports the exact number on their own forehead.\n\nNow, if you are told that: at the professor’s $N$-th question, the person whose turn it was guessed that the number on their forehead was $M$, can you infer what numbers are on the other two students’ foreheads?\n\n#### Hint\nBefore anyone guesses their own number, everyone’s answers to the professor’s questions are always “No.” Also, other than this, there is no information exchange among A, B, and C. That is, each person’s reasoning is based only on the numbers on the other two foreheads, and the negative answers everyone has given to the professor’s questions.\n\nThe professor always starts questioning from student A.\n\nYou may assume that these three sufficiently smart students can determine their own number at the earliest possible round based on the known conditions, and they will never be wrong.\n\nWith some analysis and reasoning, you will get the following conclusion: **the person with the largest number on their forehead always guesses their own number first.**", "inputFormat": "The input consists of multiple sets of testdata, where each line represents one set of testdata.\n\nFor each set of testdata, there are two integers $N$ and $M$, meaning that at the professor’s $N$-th question, the person whose turn it was guessed that the number on their forehead was $M$. The two numbers are separated by a space.\n\nThe input ends with a line `-1 -1`.", "outputFormat": "Output the results for each set of data in the order they appear in the input.\n\nFor each set of data, the first line of the output is an integer $p$, the total number of possible cases. The next $p$ lines each contain three numbers, which are the numbers on the foreheads of A, B, and C. All solutions should be output in increasing order of A’s number; if A’s numbers are the same, then sort by increasing order of B’s number.", "hint": "Before anyone guesses their own number, everyone’s answers to the professor’s questions are always “No.” Also, other than this, there is no information exchange among A, B, and C. That is, each person’s reasoning is based only on the numbers on the other two foreheads, and the negative answers everyone has given to the professor’s questions.\n\nThe professor always starts questioning from student A.\n\nYou may assume that these three sufficiently smart students can determine their own number at the earliest possible round based on the known conditions, and they will never be wrong.\n\nWith some analysis and reasoning, you will get the following conclusion: **the person with the largest number on their forehead always guesses their own number first.**\n\n# Input Format\n\nThe input consists of multiple sets of testdata, where each line represents one set of testdata.\n\nFor each set of testdata, there are two integers $N$ and $M$, meaning that at the professor’s $N$-th question, the person whose turn it was guessed that the number on their forehead was $M$. The two numbers are separated by a space.\n\nThe input ends with a line `-1 -1`.\n\n# Output Format\n\nOutput the results for each set of data in the order they appear in the input.\n\nFor each set of data, the first line of the output is an integer $p$, the total number of possible cases. The next $p$ lines each contain three numbers, which are the numbers on the foreheads of A, B, and C. All solutions should be output in increasing order of A’s number; if A’s numbers are the same, then sort by increasing order of B’s number.\n\n# Hint\n\nFor all data, $N<500$, $M<3\\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2001] 聪明的学生", "background": "", "description": "一位教授逻辑学的教授有三名非常善于推理且精于心算的学生 A，B 和 C。有一天,教授给他们三人出了一道题：教授在每个人脑门上贴了一张纸条并告诉他们，每个人的纸条上都写了一个正整数，且某两个数的和等于第三个。于是，每个学生都能看见贴在另外两个同学头上的整数，但却看不见自己的数。\n\n这时，教授先对学生 A 发问了：「你能猜出自己的数吗？」A 回答：「不能。」\n\n教授又转身问学生 B：「你能猜出自己的数吗？」B 想了想，也回答：「不能。」\n\n教授再问学生 C 同样的问题，C 思考了片刻后，摇了摇头：「不能。」\n\n接着，教授又重新问 A 同样的问题，再问 B 和 C，……，经过若干轮的提问之后，当教授再次询问某人时，此人突然露出了得意的笑容，把贴在自己头上的那个数准确无误的报了出来。\n\n现在，如果告诉你：教授在第 $N$ 次提问时，轮到回答问题的那个人猜出了贴在自己头上的数是 $M$，你能推断出另外两个学生的头上贴的是什么数吗？\n\n#### 提示\n在没有人猜出自己头上的数之前，大家对教授提问的回答始终都是「不能」；而且除此之外在 A，B，C 之间是没有进行任何信息交流的。也就是说，每个人推断的依据仅仅是另外两个人的头上数，以及大家对教授的提问所做出的否定回答。\n\n教授总是从学生 A 开始提问的。\n\n你可以假定，这三个足够聪明的学生能够根据已知的条件在最早的轮次猜出自己的数，并且永远都不会猜错。\n\n稍经分析和推理，你将得出以下结论：**总是头上贴着最大的那个数的人最先猜出自己头上的数。**", "inputFormat": "输入包括若干组测试数据，其中的每一行代表一组测试数据。\n\n对于每组测试数据，由两个整数 $N$ 和 $M$ 组成，即在教授第 $N$ 次提问时，轮到回答问题的那个人猜出了贴在自己头上的数是 $M$。两个数之间用空格分隔开。\n\n最后，由 `-1 -1` 组成的一行标志着输入数据的结束。", "outputFormat": "按照输入中的顺序依次给出各组数据的结果。\n\n输出中对应每组数据的输出的第一行是一个整数 $p$，是可能情况的总数。接下来的 $p$ 行，每一行包括三个数，分别为贴在 A，B，C 头上的三个数。输出时，所有解按照 A 头上的数增序排列；在 A 头上的数相同的情况下，按照 B 头上的数增序排列。", "hint": "对于全部数据，$N<500$，$M<3\\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P5780", "type": "P", "difficulty": 6, "samples": [["4 3 2\n", "4 2 1 3\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "Special Judge", "O2优化", "CTSC/CTS"], "title": "[CTSC2011] 排列", "background": "", "description": "沫沫很喜欢找规律填数字，譬如 $1,4,7,( ),\\cdots$，相邻的数相差为 $3$，括号中的数应为 $10$；又如 $3,6,12,( ),\\cdots$，每个数是前一个数的两倍，括号中的数应为 $24$。\n\n由于常年玩这种游戏，沫沫厌倦了等差数列与等比数列。当看到数列 $1,2,\\cdots,n$ 时，她想尽量小的改变其顺序使得不存在公差为 $A$ 或者公比为 $B$ 的子列。\n\n具体地，给定整数 $n,A,B$，求一个 $1$ 到 $n$ 的排列 $P = (P_1,P_2,\\cdots,P_n)$，满足 $\\forall i,j \\in \\{1,2,\\cdots,n \\}$，若 $i<j$ 且 $P_i<P_j$，则 $P_j \\neq P_i+A$ 且 $P_j \\neq P_i \\times B$。排列 $P$ 保留原有顺序的程度 $S$ 定义为：\n\n$$S = \\sum\\limits_{1 \\le i \\le j \\le n , P_i<P_j} (P_j-P_i)$$\n\n请你在满足前述要求的前提下，使得 $S$ 的值尽量大。", "inputFormat": "第一行包含三个正整数 $n,A,B$，意义如前所述。相邻的数之间用一个空格隔开。", "outputFormat": "第一行包含 $n$ 个整数，为你求得的排列 $P$，相邻的数之间用空格隔开。", "hint": "**样例说明**\n\n该排列对应的 $S = 3$，是 $n=4,A=3,B=2$ 时能取到的最大的 $S$。\n\n------\n\n**评分方式**\n\n每个测试点单独评分。\n\n对于每一个测试点，如果你的输出不合法，如文件格式错误、输出的解不符合要求等，该测试点得 $0$ 分。\n\n否则设你输出的排列对应 $S$ 值为 $a$，我们提供的排列对应 $S$ 值为 $b$，你在该测试点的得分如下：\n\n- 如果 $a \\le b$，得 $10$ 分；\n- 否则得分为：\n\n$\\max \\{ [10 \\times ( \\exp (\\frac{a}{b}-2)],1 \\}$\n\n------\n\n**数据规模**\n\n\n总共 $10$ 个测试点，数据范围满足：\n\n| 测试点编号 |   $n$    |        $A$        |   $B$   |\n| :--------: | :------: | :---------------: | :-----: |\n|    $1$     | $\\le 30$ |      $\\le n$      | $\\le n$ |\n|    $2$     | $\\le 60$ | $A\\bmod B\\not =0$ | $\\ge 4$ |\n|    $3$     | $\\le 70$ | $A\\bmod B\\not =0$ | $\\ge 5$ |\n|    $4$     | $\\le 80$ | $A\\bmod B\\not =0$ | $\\ge 6$ |\n|    $5$     | $\\le 90$ | $A\\bmod B\\not =0$ | $\\ge 7$ |\n|    $6$     | $\\le 90$ |      $\\le n$      |  $=1$   |\n|   $7,8$    | $\\le 90$ |      $\\le 5$      | $\\le n$ |\n|    $9$     |  $=60$   |       $=21$       |  $=3$   |\n|    $10$    |  $=90$   |       $=18$       |  $=2$   |\n\n在所有输入数据中，$A$ 与 $B$ 均为不超过 $n$ 的正整数。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2011] Permutation", "background": "", "description": "Momo really likes finding patterns and filling in numbers. For example, $1,4,7,( ),\\cdots$: the difference between adjacent numbers is $3$, so the number in the parentheses should be $10$. Another example is $3,6,12,( ),\\cdots$: each number is twice the previous one, so the number in the parentheses should be $24$.\n\nAfter playing this kind of game for many years, Momo got tired of arithmetic sequences and geometric sequences. When she sees the sequence $1,2,\\cdots,n$, she wants to change its order as little as possible so that there is no subsequence with common difference $A$ or common ratio $B$.\n\nMore specifically, given integers $n,A,B$, find a permutation $P=(P_1,P_2,\\cdots,P_n)$ of $1$ to $n$ such that $\\forall i,j \\in \\{1,2,\\cdots,n\\}$, if $i<j$ and $P_i<P_j$, then $P_j \\neq P_i+A$ and $P_j \\neq P_i \\times B$. The degree to which the permutation $P$ keeps the original order is defined as $S$:\n\n$$S = \\sum\\limits_{1 \\le i \\le j \\le n , P_i<P_j} (P_j-P_i)$$\n\nUnder the above constraints, please make the value of $S$ as large as possible.", "inputFormat": "The first line contains three positive integers $n,A,B$, with meanings as described above. Adjacent numbers are separated by one space.", "outputFormat": "The first line contains $n$ integers, the permutation $P$ you found. Adjacent numbers are separated by spaces.", "hint": "**Sample Explanation**\n\nFor this permutation, $S = 3$, which is the maximum possible $S$ when $n=4,A=3,B=2$.\n\n------\n\n**Scoring**\n\nEach test point is scored independently.\n\nFor each test point, if your output is invalid, such as wrong file format, or the output solution does not satisfy the requirements, then you get $0$ points for that test point.\n\nOtherwise, let the $S$ value of your permutation be $a$, and the $S$ value of the permutation we provide be $b$. Your score for that test point is:\n\n- If $a \\le b$, you get $10$ points.\n- Otherwise, the score is:\n\n$\\max \\{ [10 \\times ( \\exp (\\frac{a}{b}-2)],1 \\}$\n\n------\n\n**Constraints**\n\nThere are $10$ test points in total. The constraints are:\n\n| Test Point ID |   $n$    |        $A$        |   $B$   |\n| :-----------: | :------: | :---------------: | :-----: |\n|     $1$      | $\\le 30$ |      $\\le n$      | $\\le n$ |\n|     $2$      | $\\le 60$ | $A\\bmod B\\not =0$ | $\\ge 4$ |\n|     $3$      | $\\le 70$ | $A\\bmod B\\not =0$ | $\\ge 5$ |\n|     $4$      | $\\le 80$ | $A\\bmod B\\not =0$ | $\\ge 6$ |\n|     $5$      | $\\le 90$ | $A\\bmod B\\not =0$ | $\\ge 7$ |\n|     $6$      | $\\le 90$ |      $\\le n$      |  $=1$   |\n|    $7,8$     | $\\le 90$ |      $\\le 5$      | $\\le n$ |\n|     $9$      |  $=60$   |       $=21$       |  $=3$   |\n|     $10$     |  $=90$   |       $=18$       |  $=2$   |\n\nIn all input data, both $A$ and $B$ are positive integers not exceeding $n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2011] 排列", "background": "", "description": "沫沫很喜欢找规律填数字，譬如 $1,4,7,( ),\\cdots$，相邻的数相差为 $3$，括号中的数应为 $10$；又如 $3,6,12,( ),\\cdots$，每个数是前一个数的两倍，括号中的数应为 $24$。\n\n由于常年玩这种游戏，沫沫厌倦了等差数列与等比数列。当看到数列 $1,2,\\cdots,n$ 时，她想尽量小的改变其顺序使得不存在公差为 $A$ 或者公比为 $B$ 的子列。\n\n具体地，给定整数 $n,A,B$，求一个 $1$ 到 $n$ 的排列 $P = (P_1,P_2,\\cdots,P_n)$，满足 $\\forall i,j \\in \\{1,2,\\cdots,n \\}$，若 $i<j$ 且 $P_i<P_j$，则 $P_j \\neq P_i+A$ 且 $P_j \\neq P_i \\times B$。排列 $P$ 保留原有顺序的程度 $S$ 定义为：\n\n$$S = \\sum\\limits_{1 \\le i \\le j \\le n , P_i<P_j} (P_j-P_i)$$\n\n请你在满足前述要求的前提下，使得 $S$ 的值尽量大。", "inputFormat": "第一行包含三个正整数 $n,A,B$，意义如前所述。相邻的数之间用一个空格隔开。", "outputFormat": "第一行包含 $n$ 个整数，为你求得的排列 $P$，相邻的数之间用空格隔开。", "hint": "**样例说明**\n\n该排列对应的 $S = 3$，是 $n=4,A=3,B=2$ 时能取到的最大的 $S$。\n\n------\n\n**评分方式**\n\n每个测试点单独评分。\n\n对于每一个测试点，如果你的输出不合法，如文件格式错误、输出的解不符合要求等，该测试点得 $0$ 分。\n\n否则设你输出的排列对应 $S$ 值为 $a$，我们提供的排列对应 $S$ 值为 $b$，你在该测试点的得分如下：\n\n- 如果 $a \\le b$，得 $10$ 分；\n- 否则得分为：\n\n$\\max \\{ [10 \\times ( \\exp (\\frac{a}{b}-2)],1 \\}$\n\n------\n\n**数据规模**\n\n\n总共 $10$ 个测试点，数据范围满足：\n\n| 测试点编号 |   $n$    |        $A$        |   $B$   |\n| :--------: | :------: | :---------------: | :-----: |\n|    $1$     | $\\le 30$ |      $\\le n$      | $\\le n$ |\n|    $2$     | $\\le 60$ | $A\\bmod B\\not =0$ | $\\ge 4$ |\n|    $3$     | $\\le 70$ | $A\\bmod B\\not =0$ | $\\ge 5$ |\n|    $4$     | $\\le 80$ | $A\\bmod B\\not =0$ | $\\ge 6$ |\n|    $5$     | $\\le 90$ | $A\\bmod B\\not =0$ | $\\ge 7$ |\n|    $6$     | $\\le 90$ |      $\\le n$      |  $=1$   |\n|   $7,8$    | $\\le 90$ |      $\\le 5$      | $\\le n$ |\n|    $9$     |  $=60$   |       $=21$       |  $=3$   |\n|    $10$    |  $=90$   |       $=18$       |  $=2$   |\n\n在所有输入数据中，$A$ 与 $B$ 均为不超过 $n$ 的正整数。", "locale": "zh-CN"}}}
{"pid": "P5781", "type": "P", "difficulty": 6, "samples": [["6 5\n4 8 7 5 6\n7 4 10 3 5\n9 7 20 14 2\n9 14 7 3 6\n5 7 5 2 7\n4 5 13 5 6\n", "6\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2019", "IOI", "O2优化"], "title": "[IOI 2019] 矩形区域", "background": null, "description": "19 世纪初，统治者下令在俯瞰美丽河景的高原上建造一座宫殿。这块高原被看做是一个由正方形单元格组成的 $n \\times m$ 网格。网格的行从 $0$ 到 $n-1$ 编号，列从 $0$ 到 $m-1$ 编号。第 $i$ 行第 $j$ 列（$0 \\le i \\le n-1$，$0 \\le j \\le m-1$）的单元格记为单元格 $(i,j)$。每个单元格 $(i,j)$ 有特定的海拔高度，记为 $a_{i,j}$。\n\n统治者指示他的建筑师选择一个矩形区域来建造宫殿。该区域不能包含网格边界（第 $0$ 行，第 $n-1$ 行，第 $0$ 列，以及第 $m-1$ 列）上的任何单元格。为此，建筑师应选出四个整数 $r_1$，$r_2$，$c_1$ 和 $c_2$（$1 \\le r_1 \\le r_2 \\le n-2$ 且 $1 \\le c_1 \\le c_2 \\le m-2$)，对应于包括所有满足 $r_1 \\le i \\le r_2$ 且 $c_1 \\le j \\le c_2$ 的单元格 $(i,j)$ 的矩形区域。\n\n此外，一个区域被认为是合法的，当且仅当对于该区域中的每个单元格 $(i,j)$，以下条件成立：对于与该区域相邻的、位于第 $i$ 行的两个单元格（单元格 $(i,c_1-1)$ 和 $(i,c_2+1)$），以及与该区域相邻的、位于第 $j$ 列的两个单元格（单元格 $(r_1-1,j)$ 和 $(r_2+1,j)$），单元格 $(i,j)$ 的海拔高度必须严格小于这四个单元格的海拔高度。\n\n你的任务是帮助建筑师统计可建宫殿的合法区域的数量（也就是所对应区域为合法的 $r_1$，$r_2$，$c_1$ 和 $c_2$ 的数量）。", "inputFormat": "第一行，两个整数 $n$ 和 $m$，表示网格的长和宽。\n\n接下来 $n$ 行，第 $i$ 行 $m$ 个整数，为 $a_{i-1,0\\dots m-1}$。", "outputFormat": "一行，一个整数，表示合法区域的数量。", "hint": "**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p7kwnpod.png)\n\n一共有 $6$ 个合法区域，分别为：\n- $r_1=r_2=1, c_1=c_2=1$\n- $r_1=1, r_2=2, c_1=c_2=1$\n- $r_1=r_2=1, c_1=c_2=3$\n- $r_1=r_2=4, c_1=2,c_2=3$\n- $r_1=r_2=4, c_1=c_2=3$\n- $r_1=3,r_2=4,c_1=c_2=3$\n\n例如，$r_1=1, r_2=2, c_1=c_2=1$ 对应一个合法区域，原因是以下两个条件都成立：\n- $a_{1,1}=4$ 严格小于 $a_{0,1}=8$，$a_{3,1}=14$，$a_{1,0}=7$，和 $a_{1,2}=10$。\n- $a_{2,1}=7$ 严格小于 $a_{0,1}=8$，$a_{3,1}=14$，$a_{2,0}=9$，和 $a_{2,2}=20$。\n\n**数据范围**\n\n对于所有数据：\n- $1 \\le n, m \\le 2500$。\n- $0 \\le a_{i,j} \\le 7 \\times 10^6 (0 \\le i \\le n - 1, 0 \\le j \\le m - 1)$。\n\n详细子任务附加限制与分值如下表：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$n, m \\le 30$|$8$|\n|$2$|$n, m \\le 80$|$7$|\n|$3$|$n, m \\le 200$|$12$|\n|$4$|$n, m \\le 700$|$22$|\n|$5$|$n \\le 3$|$10$|\n|$6$|$0 \\le a_{i,j} \\le 1$|$13$|\n|$7$|没有任何附加限制|$28$|", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2019] Rectangular Regions", "background": "", "description": "In the early 19th century, a ruler ordered a palace to be built on a plateau overlooking a beautiful river view. The plateau can be seen as an $n \\times m$ grid made of square cells. The rows of the grid are numbered from $0$ to $n-1$, and the columns from $0$ to $m-1$. The cell in row $i$ and column $j$ ($0 \\le i \\le n-1$, $0 \\le j \\le m-1$) is denoted as cell $(i,j)$. Each cell $(i,j)$ has a specific elevation, denoted as $a_{i,j}$.\n\nThe ruler instructed his architect to choose a rectangular region to build the palace. This region cannot include any cells on the boundary of the grid (row $0$, row $n-1$, column $0$, and column $m-1$). To do this, the architect should choose four integers $r_1$, $r_2$, $c_1$, and $c_2$ ($1 \\le r_1 \\le r_2 \\le n-2$ and $1 \\le c_1 \\le c_2 \\le m-2$), corresponding to the rectangular region that includes all cells $(i,j)$ satisfying $r_1 \\le i \\le r_2$ and $c_1 \\le j \\le c_2$.\n\nIn addition, a region is considered valid if and only if, for every cell $(i,j)$ inside the region, the following condition holds: among the two cells adjacent to the region in row $i$ (cells $(i,c_1-1)$ and $(i,c_2+1)$), and the two cells adjacent to the region in column $j$ (cells $(r_1-1,j)$ and $(r_2+1,j)$), the elevation of cell $(i,j)$ must be strictly less than the elevations of all these four cells.\n\nYour task is to help the architect count the number of valid regions where the palace can be built (that is, the number of choices of $r_1$, $r_2$, $c_1$, and $c_2$ whose corresponding region is valid).", "inputFormat": "The first line contains two integers $n$ and $m$, representing the grid's height and width.\n\nThe next $n$ lines each contain $m$ integers, which are $a_{i-1,0\\dots m-1}$.", "outputFormat": "One line with one integer, representing the number of valid regions.", "hint": "**Sample Explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p7kwnpod.png)\n\nThere are $6$ valid regions in total:\n- $r_1=r_2=1, c_1=c_2=1$\n- $r_1=1, r_2=2, c_1=c_2=1$\n- $r_1=r_2=1, c_1=c_2=3$\n- $r_1=r_2=4, c_1=2,c_2=3$\n- $r_1=r_2=4, c_1=c_2=3$\n- $r_1=3,r_2=4,c_1=c_2=3$\n\nFor example, $r_1=1, r_2=2, c_1=c_2=1$ corresponds to a valid region because both of the following conditions hold:\n- $a_{1,1}=4$ is strictly less than $a_{0,1}=8$, $a_{3,1}=14$, $a_{1,0}=7$, and $a_{1,2}=10$.\n- $a_{2,1}=7$ is strictly less than $a_{0,1}=8$, $a_{3,1}=14$, $a_{2,0}=9$, and $a_{2,2}=20$.\n\n**Constraints**\n\nFor all testdata:\n- $1 \\le n, m \\le 2500$.\n- $0 \\le a_{i,j} \\le 7 \\times 10^6 (0 \\le i \\le n - 1, 0 \\le j \\le m - 1)$.\n\nThe detailed additional constraints and scores for subtasks are shown in the table below:\n\n|Subtask ID|Additional Constraints|Score|\n|:-:|:-:|:-:|\n|$1$|$n, m \\le 30$|$8$|\n|$2$|$n, m \\le 80$|$7$|\n|$3$|$n, m \\le 200$|$12$|\n|$4$|$n, m \\le 700$|$22$|\n|$5$|$n \\le 3$|$10$|\n|$6$|$0 \\le a_{i,j} \\le 1$|$13$|\n|$7$|No additional constraints|$28$|\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2019] 矩形区域", "background": null, "description": "19 世纪初，统治者下令在俯瞰美丽河景的高原上建造一座宫殿。这块高原被看做是一个由正方形单元格组成的 $n \\times m$ 网格。网格的行从 $0$ 到 $n-1$ 编号，列从 $0$ 到 $m-1$ 编号。第 $i$ 行第 $j$ 列（$0 \\le i \\le n-1$，$0 \\le j \\le m-1$）的单元格记为单元格 $(i,j)$。每个单元格 $(i,j)$ 有特定的海拔高度，记为 $a_{i,j}$。\n\n统治者指示他的建筑师选择一个矩形区域来建造宫殿。该区域不能包含网格边界（第 $0$ 行，第 $n-1$ 行，第 $0$ 列，以及第 $m-1$ 列）上的任何单元格。为此，建筑师应选出四个整数 $r_1$，$r_2$，$c_1$ 和 $c_2$（$1 \\le r_1 \\le r_2 \\le n-2$ 且 $1 \\le c_1 \\le c_2 \\le m-2$)，对应于包括所有满足 $r_1 \\le i \\le r_2$ 且 $c_1 \\le j \\le c_2$ 的单元格 $(i,j)$ 的矩形区域。\n\n此外，一个区域被认为是合法的，当且仅当对于该区域中的每个单元格 $(i,j)$，以下条件成立：对于与该区域相邻的、位于第 $i$ 行的两个单元格（单元格 $(i,c_1-1)$ 和 $(i,c_2+1)$），以及与该区域相邻的、位于第 $j$ 列的两个单元格（单元格 $(r_1-1,j)$ 和 $(r_2+1,j)$），单元格 $(i,j)$ 的海拔高度必须严格小于这四个单元格的海拔高度。\n\n你的任务是帮助建筑师统计可建宫殿的合法区域的数量（也就是所对应区域为合法的 $r_1$，$r_2$，$c_1$ 和 $c_2$ 的数量）。", "inputFormat": "第一行，两个整数 $n$ 和 $m$，表示网格的长和宽。\n\n接下来 $n$ 行，第 $i$ 行 $m$ 个整数，为 $a_{i-1,0\\dots m-1}$。", "outputFormat": "一行，一个整数，表示合法区域的数量。", "hint": "**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p7kwnpod.png)\n\n一共有 $6$ 个合法区域，分别为：\n- $r_1=r_2=1, c_1=c_2=1$\n- $r_1=1, r_2=2, c_1=c_2=1$\n- $r_1=r_2=1, c_1=c_2=3$\n- $r_1=r_2=4, c_1=2,c_2=3$\n- $r_1=r_2=4, c_1=c_2=3$\n- $r_1=3,r_2=4,c_1=c_2=3$\n\n例如，$r_1=1, r_2=2, c_1=c_2=1$ 对应一个合法区域，原因是以下两个条件都成立：\n- $a_{1,1}=4$ 严格小于 $a_{0,1}=8$，$a_{3,1}=14$，$a_{1,0}=7$，和 $a_{1,2}=10$。\n- $a_{2,1}=7$ 严格小于 $a_{0,1}=8$，$a_{3,1}=14$，$a_{2,0}=9$，和 $a_{2,2}=20$。\n\n**数据范围**\n\n对于所有数据：\n- $1 \\le n, m \\le 2500$。\n- $0 \\le a_{i,j} \\le 7 \\times 10^6 (0 \\le i \\le n - 1, 0 \\le j \\le m - 1)$。\n\n详细子任务附加限制与分值如下表：\n\n|子任务编号|附加限制|分值|\n|:-:|:-:|:-:|\n|$1$|$n, m \\le 30$|$8$|\n|$2$|$n, m \\le 80$|$7$|\n|$3$|$n, m \\le 200$|$12$|\n|$4$|$n, m \\le 700$|$22$|\n|$5$|$n \\le 3$|$10$|\n|$6$|$0 \\le a_{i,j} \\le 1$|$13$|\n|$7$|没有任何附加限制|$28$|", "locale": "zh-CN"}}}
{"pid": "P5782", "type": "P", "difficulty": 5, "samples": [["3 2\n1 3\n2 4\n", "1\n4\n5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2001", "POI（波兰）", "Special Judge", "2-SAT"], "title": "[POI 2001] 和平委员会", "background": "", "description": "根据宪法，Byteland 民主共和国的公众和平委员会应该在国会中通过立法程序来创立。 不幸的是，由于某些党派代表之间的不和睦而使得这件事存在障碍。 此委员会必须满足下列条件：\n\n- 每个党派都在委员会中恰有 $1$ 个代表。\n- 如果 $2$ 个代表彼此厌恶，则他们不能都属于委员会。\n\n每个党在议会中有 $2$ 个代表。代表从 $1$ 编号到 $2n$。 编号为 $2i-1$ 和   $2i$ 的代表属于第 $i$ 个党派。 \n\n任务：写一程序读入党派的数量和关系不友好的代表对，计算决定建立和平委员会是否可能，若行，则列出委员会的成员表。", "inputFormat": "第一行有两个非负整数 $n,m$。他们各自表示：党派的数量 $n$ 和不友好的代表对 $m$。\n\n接下来 $m$ 行，每行为一对整数 $a,b$，表示代表 $a$ 和 $b$ 互相厌恶。", "outputFormat": "如果不能创立委员会，则输出信息 `NIE`。\n\n若能够成立，则输出包括 $n$ 个从区间 $1$ 到 $2n$ 选出的整数，按升序写出，每行一个，这些数字为委员会中代表的编号。\n\n如果委员会能以多种方法形成，程序可以只输出它们的某一个。", "hint": "对于 $42\\%$ 的数据，$1 \\leq n \\leq 100$。\n\n对于 $70\\%$ 的数据，$1 \\leq n \\leq 1000$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 8000$，$0 \\leq m \\leq 20000$，$1 \\leq a < b \\leq 8000$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2001] Peace Committee", "background": "", "description": "According to the constitution, the Public Peace Committee of the Democratic Republic of Byteland should be established by a legislative procedure in the parliament. Unfortunately, conflicts between representatives of some parties make this difficult. The committee must satisfy the following conditions:\n\n- Each party has exactly $1$ representative in the committee.\n- If two representatives hate each other, then they cannot both be in the committee.\n\nEach party has $2$ representatives in the parliament. The representatives are numbered from $1$ to $2n$. Representatives numbered $2i-1$ and $2i$ belong to the $i$-th party.\n\nTask: Write a program that reads the number of parties and the pairs of representatives who are unfriendly to each other, determines whether it is possible to establish the Peace Committee, and if so, outputs the list of its members.", "inputFormat": "The first line contains two non-negative integers $n, m$. They represent the number of parties $n$ and the number of unfriendly representative pairs $m$, respectively.\n\nThe next $m$ lines each contain a pair of integers $a, b$, meaning that representatives $a$ and $b$ hate each other.", "outputFormat": "If it is impossible to establish the committee, output `NIE`.\n\nIf it is possible, output $n$ integers chosen from the range $1$ to $2n$, in increasing order, one per line. These numbers are the IDs of the representatives in the committee.\n\nIf the committee can be formed in multiple ways, your program may output any one of them.", "hint": "For $42\\%$ of the testdata, $1 \\leq n \\leq 100$.\n\nFor $70\\%$ of the testdata, $1 \\leq n \\leq 1000$.\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 8000$, $0 \\leq m \\leq 20000$, $1 \\leq a < b \\leq 8000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2001] 和平委员会", "background": "", "description": "根据宪法，Byteland 民主共和国的公众和平委员会应该在国会中通过立法程序来创立。 不幸的是，由于某些党派代表之间的不和睦而使得这件事存在障碍。 此委员会必须满足下列条件：\n\n- 每个党派都在委员会中恰有 $1$ 个代表。\n- 如果 $2$ 个代表彼此厌恶，则他们不能都属于委员会。\n\n每个党在议会中有 $2$ 个代表。代表从 $1$ 编号到 $2n$。 编号为 $2i-1$ 和   $2i$ 的代表属于第 $i$ 个党派。 \n\n任务：写一程序读入党派的数量和关系不友好的代表对，计算决定建立和平委员会是否可能，若行，则列出委员会的成员表。", "inputFormat": "第一行有两个非负整数 $n,m$。他们各自表示：党派的数量 $n$ 和不友好的代表对 $m$。\n\n接下来 $m$ 行，每行为一对整数 $a,b$，表示代表 $a$ 和 $b$ 互相厌恶。", "outputFormat": "如果不能创立委员会，则输出信息 `NIE`。\n\n若能够成立，则输出包括 $n$ 个从区间 $1$ 到 $2n$ 选出的整数，按升序写出，每行一个，这些数字为委员会中代表的编号。\n\n如果委员会能以多种方法形成，程序可以只输出它们的某一个。", "hint": "对于 $42\\%$ 的数据，$1 \\leq n \\leq 100$。\n\n对于 $70\\%$ 的数据，$1 \\leq n \\leq 1000$。\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 8000$，$0 \\leq m \\leq 20000$，$1 \\leq a < b \\leq 8000$。", "locale": "zh-CN"}}}
{"pid": "P5783", "type": "P", "difficulty": 5, "samples": [["3 5\n1 2 4\nQ 1\nQ 2\nC 1\nQ 1\nQ 2", "1\n1\n2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "重庆", "线段树", "各省省选", "位运算"], "title": "[CQOI2008] 位统计", "background": "", "description": "给出 $N$ 个 $[0, 65535]$ 的整数，编程支持以下操作：\n\n\n修改操作：```C d```，所有数增加 $d$。如果超过 $65535$，把结果模 $65536$。（$0\\le d\\le 65535$）\n\n查询操作：```Q i```，统计有多少整数的第 $i$ 位非 $0$，换句话说，有多少个整数与 $2^i$ 的“按位与”操作值为正。（$0\\le i\\le 15$）\n\n输出所有查询操作的统计值。", "inputFormat": "第一行为两个正整数 $N$ 和 $M$，即整数的个数和操作的个数。\n\n第二行包含 $N$ 个 $[0,65535]$ 的整数。\n\n以下 $M$ 行为各操作，格式如题所述。", "outputFormat": "输出所有 $Q$ 操作的统计值。", "hint": "| 测试点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $N$ | $3$ | $10$ | $100$ | $1000$ | $10000$ | $20000$ | $50000$ | $100000$ | $100000$ | $100000$ |\n| $M$ | $3$ | $10$ | $100$ | $1000$ | $10000$ | $20000$ | $50000$ | $50000$ | $100000$ | $200000$ |\n", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2008] Bit Statistics", "background": "", "description": "Given $N$ integers in $[0, 65535]$, write a program that supports the following operations:\n\nModification operation: ```C d```, add $d$ to every number. If the result exceeds $65535$, take the result modulo $65536$. ($0 \\le d \\le 65535$)\n\nQuery operation: ```Q i```, count how many integers have a nonzero $i$-th bit. In other words, count how many integers have a positive result when applying the bitwise AND with $2^i$. ($0 \\le i \\le 15$)\n\nOutput the counts for all query operations.", "inputFormat": "The first line contains two positive integers $N$ and $M$, which are the number of integers and the number of operations.\n\nThe second line contains $N$ integers in $[0, 65535]$.\n\nThe next $M$ lines each contain one operation, in the format described above.", "outputFormat": "Output the count for every ```Q``` operation.", "hint": "## Constraints\n\n| Test Point ID | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $N$ | $3$ | $10$ | $100$ | $1000$ | $10000$ | $20000$ | $50000$ | $100000$ | $100000$ | $100000$ |\n| $M$ | $3$ | $10$ | $100$ | $1000$ | $10000$ | $20000$ | $50000$ | $50000$ | $100000$ | $200000$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2008] 位统计", "background": "", "description": "给出 $N$ 个 $[0, 65535]$ 的整数，编程支持以下操作：\n\n\n修改操作：```C d```，所有数增加 $d$。如果超过 $65535$，把结果模 $65536$。（$0\\le d\\le 65535$）\n\n查询操作：```Q i```，统计有多少整数的第 $i$ 位非 $0$，换句话说，有多少个整数与 $2^i$ 的“按位与”操作值为正。（$0\\le i\\le 15$）\n\n输出所有查询操作的统计值。", "inputFormat": "第一行为两个正整数 $N$ 和 $M$，即整数的个数和操作的个数。\n\n第二行包含 $N$ 个 $[0,65535]$ 的整数。\n\n以下 $M$ 行为各操作，格式如题所述。", "outputFormat": "输出所有 $Q$ 操作的统计值。", "hint": "| 测试点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $N$ | $3$ | $10$ | $100$ | $1000$ | $10000$ | $20000$ | $50000$ | $100000$ | $100000$ | $100000$ |\n| $M$ | $3$ | $10$ | $100$ | $1000$ | $10000$ | $20000$ | $50000$ | $50000$ | $100000$ | $200000$ |\n", "locale": "zh-CN"}}}
{"pid": "P5784", "type": "P", "difficulty": 5, "samples": [["3 2 3 4\n1 2 6\n", "17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "重庆", "各省省选", "枚举"], "title": "[CQOI2008] 矩阵的个数", "background": "", "description": "给出一个 $n\\times 3$ 的非负整数矩阵的各行各列之和，统计有多少个矩阵满足此条件。输出答案模 $10^{17}$ 的值。", "inputFormat": "第一行包含四个正整数 $N$，$c_1$，$c_2$，$c_3$，即行数与三列之和。第二行包含 $N$ 个正整数，即各行三个数之和。每行每列之和均不超过 $125$。\n", "outputFormat": "仅一个数，满足条件的矩阵个数模 $10^{17}$ 的值。", "hint": "| 测试点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $N$ | $1$ | $2$ | $3$ | $10$ | $30$ | $50$ | $80$ | $120$ | $150$ | $200$ |\n", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2008] Number of Matrices", "background": "", "description": "Given the sums of each row and each column of an $n \\times 3$ non-negative integer matrix, count how many matrices satisfy these conditions. Output the answer modulo $10^{17}$.", "inputFormat": "The first line contains four positive integers $N$, $c_1$, $c_2$, $c_3$, representing the number of rows and the sums of the three columns. The second line contains $N$ positive integers, representing the sum of the three numbers in each row. The sum of each row and each column does not exceed $125$.", "outputFormat": "Output one number: the number of matrices satisfying the conditions modulo $10^{17}$.", "hint": "| Test Point ID | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $N$ | $1$ | $2$ | $3$ | $10$ | $30$ | $50$ | $80$ | $120$ | $150$ | $200$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2008] 矩阵的个数", "background": "", "description": "给出一个 $n\\times 3$ 的非负整数矩阵的各行各列之和，统计有多少个矩阵满足此条件。输出答案模 $10^{17}$ 的值。", "inputFormat": "第一行包含四个正整数 $N$，$c_1$，$c_2$，$c_3$，即行数与三列之和。第二行包含 $N$ 个正整数，即各行三个数之和。每行每列之和均不超过 $125$。\n", "outputFormat": "仅一个数，满足条件的矩阵个数模 $10^{17}$ 的值。", "hint": "| 测试点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $N$ | $1$ | $2$ | $3$ | $10$ | $30$ | $50$ | $80$ | $120$ | $150$ | $200$ |\n", "locale": "zh-CN"}}}
{"pid": "P5785", "type": "P", "difficulty": 6, "samples": [["5\n1\n1 3\n3 2\n4 3\n2 3\n1 4\n", "153\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2012", "二分", "各省省选", "单调队列", "山东", "斜率优化", "李超线段树"], "title": "[SDOI2012] 任务安排", "background": "", "description": "机器上有 $n$ 个需要处理的任务，它们构成了一个序列。这些任务被标号为 $1$ 到 $n$，因此序列的排列为 $1 , 2 , 3 \\cdots n$。这 $n$ 个任务被分成若干批，每批包含相邻的若干任务。从时刻 $0$ 开始，这些任务被分批加工，第 $i$ 个任务单独完成所需的时间是 $T_i$。在每批任务开始前，机器需要启动时间 $s$，而完成这批任务所需的时间是各个任务需要时间的总和。\n\n**注意，同一批任务将在同一时刻完成**。每个任务的费用是它的完成时刻乘以一个费用系数 $C_i$。\n\n请确定一个分组方案，使得总费用最小。", "inputFormat": "第一行一个整数 $n$。\n第二行一个整数 $s$。\n\n接下来 $n$ 行，每行有一对整数，分别为 $T_i$ 和 $C_i$，表示第 $i$ 个任务单独完成所需的时间是 $T_i$ 及其费用系数 $C_i$。", "outputFormat": "一行，一个整数，表示最小的总费用。", "hint": "对于 $100\\%$ 数据，$1 \\le n \\le 3 \\times 10^5$，$1 \\le s \\le 2^8$，$ \\left| T_i \\right| \\le 2^8$，$0 \\le C_i \\le 2^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2012] Task Scheduling", "background": "", "description": "There are $n$ tasks to be processed on a machine, and they form a sequence. These tasks are numbered from $1$ to $n$, so the order of the sequence is $1, 2, 3 \\cdots n$. The $n$ tasks are divided into several batches, and each batch contains several consecutive tasks. Starting from time $0$, the tasks are processed batch by batch. The time required to finish task $i$ alone is $T_i$. Before each batch starts, the machine needs a startup time $s$, and the time needed to finish this batch is the sum of the times of all tasks in the batch.\n\n**Note that tasks in the same batch will be completed at the same time.** The cost of each task is its completion time multiplied by a cost coefficient $C_i$.\n\nPlease determine a batching plan that minimizes the total cost.", "inputFormat": "The first line contains an integer $n$.\nThe second line contains an integer $s$.\n\nThe next $n$ lines each contain a pair of integers $T_i$ and $C_i$, meaning that the time required to finish task $i$ alone is $T_i$, and its cost coefficient is $C_i$.", "outputFormat": "One line containing an integer, representing the minimum total cost.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le n \\le 3 \\times 10^5$, $1 \\le s \\le 2^8$, $\\left| T_i \\right| \\le 2^8$, $0 \\le C_i \\le 2^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2012] 任务安排", "background": "", "description": "机器上有 $n$ 个需要处理的任务，它们构成了一个序列。这些任务被标号为 $1$ 到 $n$，因此序列的排列为 $1 , 2 , 3 \\cdots n$。这 $n$ 个任务被分成若干批，每批包含相邻的若干任务。从时刻 $0$ 开始，这些任务被分批加工，第 $i$ 个任务单独完成所需的时间是 $T_i$。在每批任务开始前，机器需要启动时间 $s$，而完成这批任务所需的时间是各个任务需要时间的总和。\n\n**注意，同一批任务将在同一时刻完成**。每个任务的费用是它的完成时刻乘以一个费用系数 $C_i$。\n\n请确定一个分组方案，使得总费用最小。", "inputFormat": "第一行一个整数 $n$。\n第二行一个整数 $s$。\n\n接下来 $n$ 行，每行有一对整数，分别为 $T_i$ 和 $C_i$，表示第 $i$ 个任务单独完成所需的时间是 $T_i$ 及其费用系数 $C_i$。", "outputFormat": "一行，一个整数，表示最小的总费用。", "hint": "对于 $100\\%$ 数据，$1 \\le n \\le 3 \\times 10^5$，$1 \\le s \\le 2^8$，$ \\left| T_i \\right| \\le 2^8$，$0 \\le C_i \\le 2^8$。", "locale": "zh-CN"}}}
{"pid": "P5786", "type": "P", "difficulty": 6, "samples": [["5\nYNNYN\nNNNNN\nYNNNY\nNNNYN\nNNNNN\nYNNYN", "5 4 3 5 0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "重庆", "各省省选"], "title": "[CQOI2008] 传感器网络", "background": null, "description": "一个无线传感器网络由若干独立采集数据的设备和一个控制中心组成。每个设备必须把采集到的数据传到控制中心处理，但由于设备限制，并不是每台设备都可以与控制中心直接相连。为了解决这一问题，你将传感器网络设计成树状结构。树根为控制中心，而每台设备恰好有一个父亲节点（要么为控制中心，要么为另一台设备）。一台设备的儿子设备个数称为它的负载级别。所有设备（注意，控制中心不是设备）的负载级别的最大值称为网络的负载级别。\n\n你的任务是让整个网络的负载级别尽量小。", "inputFormat": "第一行包含一个整数 $N$，即设备的个数。第二行包含 $N$ 个字符，表示每台设备是否能直接连接到控制中心。以下 $N$ 行每行 $N$ 个字符，其中第 $i$ 行第 $j$ 个字符为 `Y` 当且仅当设备 $i$ 可以作为设备 $j$ 的儿子。如果设备 $i$ 可以作为设备 $j$ 的儿子，那么在任何合法的网络中，设备 $j$ 一定不会是设备 $i$ 的后代。换句话说，如果把这 $N$ 行看作一个有向图的邻接矩阵，该图不存在有向环。", "outputFormat": "仅一行，包含 $N$ 个整数，即每个设备的父亲。设备按照输入顺序编号为 $0$ 至 $N-1$，控制中心用 $N$ 表示。如果有多组解，输出字典序最小解。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/k42z6mxl.png)\n\n对于 $50\\%$ 的数据，$2\\le N\\le 6$；对于另外 $50\\%$ 的数据，$N=50$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2008] Sensor Network.", "background": "", "description": "A wireless sensor network consists of several devices that collect data independently and a control center. Each device must send the collected data to the control center for processing, but due to device limitations, not every device can connect directly to the control center. To solve this, you design the sensor network as a tree structure. The root of the tree is the control center, and each device has exactly one parent node (either the control center or another device). The number of child devices of a device is called its load level. The maximum load level among all devices (note that the control center is not a device) is called the network load level.\n\nYour task is to make the network load level as small as possible.", "inputFormat": "The first line contains an integer $N$, the number of devices. The second line contains $N$ characters, indicating whether each device can connect directly to the control center. The next $N$ lines each contain $N$ characters, where the $j$-th character in the $i$-th line is `Y` if and only if device $i$ can be a child of device $j$. If device $i$ can be a child of device $j$, then in any valid network, device $j$ will definitely not be a descendant of device $i$. In other words, if you treat these $N$ lines as the adjacency matrix of a directed graph, the graph has no directed cycles.", "outputFormat": "Output exactly one line containing $N$ integers, the parent of each device. Devices are numbered from $0$ to $N-1$ in input order, and the control center is denoted by $N$. If there are multiple solutions, output the lexicographically smallest one.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/k42z6mxl.png)\n\nFor $50\\%$ of the testdata, $2 \\le N \\le 6$; for the other $50\\%$ of the testdata, $N = 50$.\n\nConstraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2008] 传感器网络", "background": null, "description": "一个无线传感器网络由若干独立采集数据的设备和一个控制中心组成。每个设备必须把采集到的数据传到控制中心处理，但由于设备限制，并不是每台设备都可以与控制中心直接相连。为了解决这一问题，你将传感器网络设计成树状结构。树根为控制中心，而每台设备恰好有一个父亲节点（要么为控制中心，要么为另一台设备）。一台设备的儿子设备个数称为它的负载级别。所有设备（注意，控制中心不是设备）的负载级别的最大值称为网络的负载级别。\n\n你的任务是让整个网络的负载级别尽量小。", "inputFormat": "第一行包含一个整数 $N$，即设备的个数。第二行包含 $N$ 个字符，表示每台设备是否能直接连接到控制中心。以下 $N$ 行每行 $N$ 个字符，其中第 $i$ 行第 $j$ 个字符为 `Y` 当且仅当设备 $i$ 可以作为设备 $j$ 的儿子。如果设备 $i$ 可以作为设备 $j$ 的儿子，那么在任何合法的网络中，设备 $j$ 一定不会是设备 $i$ 的后代。换句话说，如果把这 $N$ 行看作一个有向图的邻接矩阵，该图不存在有向环。", "outputFormat": "仅一行，包含 $N$ 个整数，即每个设备的父亲。设备按照输入顺序编号为 $0$ 至 $N-1$，控制中心用 $N$ 表示。如果有多组解，输出字典序最小解。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/k42z6mxl.png)\n\n对于 $50\\%$ 的数据，$2\\le N\\le 6$；对于另外 $50\\%$ 的数据，$N=50$。", "locale": "zh-CN"}}}
{"pid": "P5787", "type": "P", "difficulty": 5, "samples": [["3 3 3\n1 2 0 2\n2 3 0 3\n1 3 1 2\n", "Yes\nNo\nYes\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["并查集", "O2优化", "二分图", "线段树分治", "模板题"], "title": "【模板】线段树分治 / 二分图", "background": "", "description": "神犇有一个 $n$ 个节点的图。\n\n因为神犇是神犇，所以在 $k$ 时间内有 $m$ 条边会出现后消失。\n\n神犇要求出每一时间段内这个图是否是二分图。\n\n这么简单的问题神犇当然会做了，于是他想考考你。\n\n原 BZOJ4025。", "inputFormat": "第一行三个整数 $n,m,k$。\n\n接下来 $m$ 行，每行四个整数 $x,y,l,r$，表示有一条连接 $x,y$ 的边在 $l$ 时刻出现 $r$ 时刻消失。", "outputFormat": "$k$ 行，第 $i$ 行一个字符串 `Yes` 或 `No`，表示在第 $i$ 时间段内这个图是否是二分图。", "hint": "### 样例说明\n\n$0$ 时刻，出现两条边 $(1,2)$ 和 $(2,3)$。\n\n第 $1$ 时间段内，这个图是二分图，输出 `Yes`。\n\n$1$ 时刻，出现一条边 $(1,3)$。\n\n第 $2$ 时间段内，这个图不是二分图，输出 `No`。\n\n$2$ 时刻，$(1,2)$ 和 $(1,3)$ 两条边消失。\n\n第 $3$ 时间段内，只有一条边 $(2,3)$，这个图是二分图，输出 `Yes`。\n\n### 数据范围\n\n$n,k = 10^5$，$m = 2\\times 10^5$。$1 \\le x,y \\le n$，$0 \\le l \\le r \\le k$。\n\n### 注意\n\n本题设有 hack 数据（Subtask $2$），计 $0$ 分，但若没有通过 hack 数据则不算通过本题。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Segment Tree Divide and Conquer / Bipartite Graph.", "background": "", "description": "Shenben has a graph with $n$ nodes.\n\nBecause Shenben is Shenben, within time $k$, there will be $m$ edges that appear and then disappear.\n\nShenben asks you to determine whether the graph is a bipartite graph in each time period.\n\nSuch an easy problem is of course no problem for Shenben, so he wants to test you.\n\nOriginally BZOJ4025.", "inputFormat": "The first line contains three integers $n,m,k$.\n\nIn the next $m$ lines, each line contains four integers $x,y,l,r$, meaning there is an edge connecting $x,y$ that appears at time $l$ and disappears at time $r$.", "outputFormat": "Output $k$ lines. The $i$-th line contains a string `Yes` or `No`, indicating whether the graph is bipartite in the $i$-th time period.", "hint": "### Sample Explanation\n\nAt time $0$, two edges $(1,2)$ and $(2,3)$ appear.\n\nIn the $1$st time period, this graph is bipartite, so output `Yes`.\n\nAt time $1$, an edge $(1,3)$ appears.\n\nIn the $2$nd time period, this graph is not bipartite, so output `No`.\n\nAt time $2$, the two edges $(1,2)$ and $(1,3)$ disappear.\n\nIn the $3$rd time period, there is only one edge $(2,3)$, and this graph is bipartite, so output `Yes`.\n\n### Constraints\n\n$n,k = 10^5$, $m = 2\\times 10^5$. $1 \\le x,y \\le n$, $0 \\le l \\le r \\le k$.\n\n### Notes\n\nThis problem has hack testdata (Subtask $2$), worth $0$ points, but if you do not pass the hack testdata, it will not be considered accepted.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】线段树分治 / 二分图", "background": "", "description": "神犇有一个 $n$ 个节点的图。\n\n因为神犇是神犇，所以在 $k$ 时间内有 $m$ 条边会出现后消失。\n\n神犇要求出每一时间段内这个图是否是二分图。\n\n这么简单的问题神犇当然会做了，于是他想考考你。\n\n原 BZOJ4025。", "inputFormat": "第一行三个整数 $n,m,k$。\n\n接下来 $m$ 行，每行四个整数 $x,y,l,r$，表示有一条连接 $x,y$ 的边在 $l$ 时刻出现 $r$ 时刻消失。", "outputFormat": "$k$ 行，第 $i$ 行一个字符串 `Yes` 或 `No`，表示在第 $i$ 时间段内这个图是否是二分图。", "hint": "### 样例说明\n\n$0$ 时刻，出现两条边 $(1,2)$ 和 $(2,3)$。\n\n第 $1$ 时间段内，这个图是二分图，输出 `Yes`。\n\n$1$ 时刻，出现一条边 $(1,3)$。\n\n第 $2$ 时间段内，这个图不是二分图，输出 `No`。\n\n$2$ 时刻，$(1,2)$ 和 $(1,3)$ 两条边消失。\n\n第 $3$ 时间段内，只有一条边 $(2,3)$，这个图是二分图，输出 `Yes`。\n\n### 数据范围\n\n$n,k = 10^5$，$m = 2\\times 10^5$。$1 \\le x,y \\le n$，$0 \\le l \\le r \\le k$。\n\n### 注意\n\n本题设有 hack 数据（Subtask $2$），计 $0$ 分，但若没有通过 hack 数据则不算通过本题。", "locale": "zh-CN"}}}
{"pid": "P5788", "type": "P", "difficulty": 3, "samples": [["5\n1 4 2 3 5\n", "2 5 4 5 0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线性数据结构", "栈", "单调栈", "模板题"], "title": "【模板】单调栈", "background": "模板题，无背景。  \n\n2019.12.12 更新数据，放宽时限，现在不再卡常了。", "description": "给出项数为 $n$ 的整数数列 $a_{1 \\dots n}$。\n\n定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_i$ 的元素的**下标**，即 $f(i)=\\min_{i<j\\leq n, a_j > a_i} \\{j\\}$。若不存在，则 $f(i)=0$。\n\n试求出 $f(1\\dots n)$。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个正整数 $a_{1\\dots n}$。", "outputFormat": "一行 $n$ 个整数表示 $f(1), f(2), \\dots, f(n)$ 的值。  ", "hint": "【数据规模与约定】\n\n对于 $30\\%$ 的数据，$n\\leq 100$；\n\n对于 $60\\%$ 的数据，$n\\leq 5 \\times 10^3$ ；\n\n对于 $100\\%$ 的数据，$1 \\le n\\leq 3\\times 10^6$，$1\\leq a_i\\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Monotonic Stack", "background": "This is a template problem, with no background.\n\nTestdata was updated on 2019.12.12. The time limit was relaxed, and it no longer relies on constant-factor optimizations.", "description": "Given an integer sequence $a_{1 \\dots n}$ with $n$ terms.\n\nDefine a function $f(i)$ as the **index** of the first element after the $i$-th element in the sequence that is greater than $a_i$, that is,\n$f(i)=\\min_{i<j\\leq n, a_j > a_i} \\{j\\}$.\nIf it does not exist, then $f(i)=0$.\n\nFind $f(1\\dots n)$.", "inputFormat": "The first line contains a positive integer $n$.\n\nThe second line contains $n$ positive integers $a_{1\\dots n}$.", "outputFormat": "Output one line with $n$ integers representing the values of $f(1), f(2), \\dots, f(n)$.", "hint": "Constraints\n\nFor $30\\%$ of the testdata, $n\\leq 100$.\n\nFor $60\\%$ of the testdata, $n\\leq 5 \\times 10^3$.\n\nFor $100\\%$ of the testdata, $1 \\le n\\leq 3\\times 10^6$, $1\\leq a_i\\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】单调栈", "background": "模板题，无背景。  \n\n2019.12.12 更新数据，放宽时限，现在不再卡常了。", "description": "给出项数为 $n$ 的整数数列 $a_{1 \\dots n}$。\n\n定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_i$ 的元素的**下标**，即 $f(i)=\\min_{i<j\\leq n, a_j > a_i} \\{j\\}$。若不存在，则 $f(i)=0$。\n\n试求出 $f(1\\dots n)$。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个正整数 $a_{1\\dots n}$。", "outputFormat": "一行 $n$ 个整数表示 $f(1), f(2), \\dots, f(n)$ 的值。  ", "hint": "【数据规模与约定】\n\n对于 $30\\%$ 的数据，$n\\leq 100$；\n\n对于 $60\\%$ 的数据，$n\\leq 5 \\times 10^3$ ；\n\n对于 $100\\%$ 的数据，$1 \\le n\\leq 3\\times 10^6$，$1\\leq a_i\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5789", "type": "P", "difficulty": 5, "samples": [["3 2\n1 2\n2 3\n2", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "各省省选", "矩阵乘法", "天津"], "title": "[TJOI2017] 可乐（数据加强版）", "background": "[原题](https://www.luogu.org/problem/P3758) 数据很弱，这个加强版卡掉了暴力的 DP 做法，并且补充了原题题面中缺少的 $\\LaTeX$ 。", "description": "加里敦星球的人们特别喜欢喝可乐。因而，他们的敌对星球研发出了一个可乐机器人，并且放在了加里敦星球的 $1$ 号城市上。这个可乐机器人有三种行为： 停在原地，去下一个相邻的城市，自爆。它每一秒都会随机触发一种行为。现在给加里敦星球城市图，在第 $0$ 秒时可乐机器人在 $1$ 号城市，问经过了 $t$ 秒，可乐机器人的行为方案数是多少？", "inputFormat": "第一行输入两个正整数 $N,M$，$N$ 表示城市个数，$M$ 表示道路个数。\n\n接下来 $M$ 行输入 $u,v$，表示 $u,v$ 之间有一条双向道路。\n\n最后输入时间 $t$。", "outputFormat": "输出可乐机器人的行为方案数，答案可能很大，请输出对 $2017$ 取模后的结果。", "hint": "【数据规模与约定】\n\n对于 $20\\%$ 的数据，$n,m\\leq 30$，$t\\leq 1000$；\n\n对于 $50\\%$ 的数据，$t\\leq 10^6$；\n\n对于 $100\\%$ 的数据，$n,m\\leq 100$，$t\\leq 10^9$。\n\n【样例解释】\n\n$1$ $\\rightarrow$ 爆炸\n\n$1$ $\\rightarrow$ $1$ $\\rightarrow$ 爆炸\n\n$1$ $\\rightarrow$ $2$ $\\rightarrow$ 爆炸\n\n$1$ $\\rightarrow$ $1$ $\\rightarrow$ $1$\n\n$1$ $\\rightarrow$ $1$ $\\rightarrow$ $2$\n\n$1$ $\\rightarrow$ $2$ $\\rightarrow$ $1$\n\n$1$ $\\rightarrow$ $2$ $\\rightarrow$ $2$\n\n$1$ $\\rightarrow$ $2$ $\\rightarrow$ $3$", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2017] Cola (Enhanced Data Version).", "background": "The testdata of the [original problem](https://www.luogu.org/problem/P3758) is very weak. This enhanced version eliminates the brute-force DP solution and also adds the missing $\\LaTeX$ from the original statement.", "description": "People on the planet Gariton especially like drinking cola. Therefore, their enemy planet developed a cola robot and placed it in City $1$ on Gariton. This cola robot has three kinds of actions: stay where it is, go to the next adjacent city, and self-destruct. Every second it randomly triggers one action. Now you are given the city graph of Gariton. At time $0$, the cola robot is in City $1$. After $t$ seconds, how many possible action plans does the cola robot have?", "inputFormat": "The first line contains two positive integers $N, M$, where $N$ is the number of cities and $M$ is the number of roads.\n\nThe next $M$ lines each contain $u, v$, meaning there is a bidirectional road between $u$ and $v$.\n\nFinally, input the time $t$.", "outputFormat": "Output the number of possible action plans of the cola robot. The answer may be very large, so output the result modulo $2017$.", "hint": "Constraints\n\nFor $20\\%$ of the data, $n, m \\leq 30$, $t \\leq 1000$.\n\nFor $50\\%$ of the data, $t \\leq 10^6$.\n\nFor $100\\%$ of the data, $n, m \\leq 100$, $t \\leq 10^9$.\n\nSample Explanation\n\n$1$ $\\rightarrow$ explode.\n\n$1$ $\\rightarrow$ $1$ $\\rightarrow$ explode.\n\n$1$ $\\rightarrow$ $2$ $\\rightarrow$ explode.\n\n$1$ $\\rightarrow$ $1$ $\\rightarrow$ $1$.\n\n$1$ $\\rightarrow$ $1$ $\\rightarrow$ $2$.\n\n$1$ $\\rightarrow$ $2$ $\\rightarrow$ $1$.\n\n$1$ $\\rightarrow$ $2$ $\\rightarrow$ $2$.\n\n$1$ $\\rightarrow$ $2$ $\\rightarrow$ $3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2017] 可乐（数据加强版）", "background": "[原题](https://www.luogu.org/problem/P3758) 数据很弱，这个加强版卡掉了暴力的 DP 做法，并且补充了原题题面中缺少的 $\\LaTeX$ 。", "description": "加里敦星球的人们特别喜欢喝可乐。因而，他们的敌对星球研发出了一个可乐机器人，并且放在了加里敦星球的 $1$ 号城市上。这个可乐机器人有三种行为： 停在原地，去下一个相邻的城市，自爆。它每一秒都会随机触发一种行为。现在给加里敦星球城市图，在第 $0$ 秒时可乐机器人在 $1$ 号城市，问经过了 $t$ 秒，可乐机器人的行为方案数是多少？", "inputFormat": "第一行输入两个正整数 $N,M$，$N$ 表示城市个数，$M$ 表示道路个数。\n\n接下来 $M$ 行输入 $u,v$，表示 $u,v$ 之间有一条双向道路。\n\n最后输入时间 $t$。", "outputFormat": "输出可乐机器人的行为方案数，答案可能很大，请输出对 $2017$ 取模后的结果。", "hint": "【数据规模与约定】\n\n对于 $20\\%$ 的数据，$n,m\\leq 30$，$t\\leq 1000$；\n\n对于 $50\\%$ 的数据，$t\\leq 10^6$；\n\n对于 $100\\%$ 的数据，$n,m\\leq 100$，$t\\leq 10^9$。\n\n【样例解释】\n\n$1$ $\\rightarrow$ 爆炸\n\n$1$ $\\rightarrow$ $1$ $\\rightarrow$ 爆炸\n\n$1$ $\\rightarrow$ $2$ $\\rightarrow$ 爆炸\n\n$1$ $\\rightarrow$ $1$ $\\rightarrow$ $1$\n\n$1$ $\\rightarrow$ $1$ $\\rightarrow$ $2$\n\n$1$ $\\rightarrow$ $2$ $\\rightarrow$ $1$\n\n$1$ $\\rightarrow$ $2$ $\\rightarrow$ $2$\n\n$1$ $\\rightarrow$ $2$ $\\rightarrow$ $3$", "locale": "zh-CN"}}}
{"pid": "P5790", "type": "P", "difficulty": 0, "samples": [["3\n4 0 0 4 -1 5 4 0 4\n4 0 0 5 -1 8 3 0 3\n4 0 0 0 -8 3 -4 4 0", "Yes\n0 4 4 3 5 8 0 8\n5 8 4 3 8 0 8 8\n0 0 8 0 4 3 0 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "Special Judge", "CTSC/CTS"], "title": "[CTSC2006] 拼图「暂缺SPJ」", "background": "", "description": "$5$ 岁的小 $P$ 对剪纸很感兴趣，他总是喜欢把一个矩形的纸片剪成一个又一个的凸多边形。但是，每一次剪完后，他总是怀疑自己弄丢了一些纸片。聪明的他想到了一个方法来检测纸片是否弄丢：他将这些凸多边形拼起来，如果能够拼成一个矩形，他就认为纸片没有弄丢。由于纸片的数量不是很多，这个工作并不难。但是，久而久之，他对这项工作不感兴趣了，所以，他找到了你，希望你能够告诉他，这些凸多边形纸片能不能够拼成矩形。", "inputFormat": "第一行只有一个正整数 $n$，表示凸多边形的个数。\n\n以下 $n$ 行每一行描述一个凸多边形，格式如下：\n\n第 $i+1$ 行的第一个数 $m_i$ 表示凸多边形的点数，接下来有 $m_i$ 对实数，一对实数给出了一个点的坐标，这 $m_i$ 个顶点按照从任意一个顶点出发的逆时针顺序给出。且所有实数都在 $(-10^3,10^3)$ 的范围内，小数点后不超过 $8$ 位。", "outputFormat": "如果不能拼成矩形，输出只有一行 `No`。\n\n如果能拼成矩形，输出的第一行为 `Yes`。\n\n接下来的 $n$ 行描述拼法。\n\n如果能够拼成一个 $X\\times Y$ 的矩形，那么矩形的四个顶点的坐标是 $(0,0), (0,Y), (X,Y), (X,0)$。这 $n$ 行输出每一个凸多边形的顶点的坐标（拼成矩形后）。按照输入的顺序，即第一个输出的凸多边形对应输入的第一个凸多边形。对于每一个凸多边形，输出也按照输入的顺序，即一个多边形的第一个顶点对应输入的第一个顶点。这样，输出总共有 $n$ 行，第 $i$ 行有 $m_i$ 对数。", "hint": "#### 样例说明\n如下图，左上、右上和左下描述了输入的凸多边形，右下描述了输出的的矩形。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dmd58o3a.png)\n\n#### 注意\n由于矩形纸片的两面的颜色不同，所以纸片只能旋转和平移，不能翻转。所以，输出的 $m_i$ 个顶点也应该是逆时针顺序的。\n\n#### 数据范围\n对于 $100\\%$ 的数据，$1\\leq n\\leq 8$, $3\\leq m_i\\leq 8$。\n\n#### 评分说明\n两个实数之差的绝对值小于 $10^{-7}$ 时认为两个实数相等。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2006] Jigsaw Puzzle \"SPJ Missing\"", "background": "", "description": "Little $P$, who is $5$ years old, is very interested in paper cutting. He always likes to cut a rectangular piece of paper into one convex polygon after another. However, after each cutting, he always suspects that he has lost some pieces. Being smart, he came up with a way to check whether any pieces were lost: he puts these convex polygons together, and if they can form a rectangle, he believes that no piece was lost.\n\nSince the number of pieces is not large, this work is not difficult. But over time, he lost interest in doing it, so he came to you and hopes that you can tell him whether these convex polygon pieces can be assembled into a rectangle.", "inputFormat": "The first line contains one positive integer $n$, indicating the number of convex polygons.\n\nThe following $n$ lines each describe one convex polygon in the format below:\n\nOn line $i+1$, the first number $m_i$ is the number of vertices of the convex polygon. Then there are $m_i$ pairs of real numbers, where each pair gives the coordinates of a vertex. These $m_i$ vertices are given in counterclockwise order starting from any vertex. All real numbers are in the range $(-10^3,10^3)$, with at most $8$ digits after the decimal point.", "outputFormat": "If the polygons cannot be assembled into a rectangle, output one line containing `No`.\n\nIf they can be assembled into a rectangle, the first line should be `Yes`.\n\nThe next $n$ lines describe the assembly.\n\nIf they can form an $X\\times Y$ rectangle, then the coordinates of the rectangle’s four vertices are $(0,0), (0,Y), (X,Y), (X,0)$. In these $n$ lines, output the coordinates of the vertices of each convex polygon (after assembling into the rectangle). Output in the input order, i.e., the first polygon in the output corresponds to the first polygon in the input. For each polygon, the output order should also match the input order, i.e., the first output vertex corresponds to the first input vertex of that polygon. Therefore, there are $n$ output lines in total, and line $i$ contains $m_i$ pairs of numbers.", "hint": "#### Sample Explanation\n\nIn the figure below, the top-left, top-right, and bottom-left parts show the input convex polygons, and the bottom-right part shows the output rectangle.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dmd58o3a.png)\n\n#### Note\n\nBecause the two sides of the rectangular paper have different colors, each piece can only be rotated and translated, but cannot be flipped. Therefore, the output $m_i$ vertices should also be in counterclockwise order.\n\n#### Constraints\n\nFor $100\\%$ of the testdata, $1\\leq n\\leq 8$, $3\\leq m_i\\leq 8$.\n\n#### Scoring\n\nTwo real numbers are considered equal if the absolute value of their difference is less than $10^{-7}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2006] 拼图「暂缺SPJ」", "background": "", "description": "$5$ 岁的小 $P$ 对剪纸很感兴趣，他总是喜欢把一个矩形的纸片剪成一个又一个的凸多边形。但是，每一次剪完后，他总是怀疑自己弄丢了一些纸片。聪明的他想到了一个方法来检测纸片是否弄丢：他将这些凸多边形拼起来，如果能够拼成一个矩形，他就认为纸片没有弄丢。由于纸片的数量不是很多，这个工作并不难。但是，久而久之，他对这项工作不感兴趣了，所以，他找到了你，希望你能够告诉他，这些凸多边形纸片能不能够拼成矩形。", "inputFormat": "第一行只有一个正整数 $n$，表示凸多边形的个数。\n\n以下 $n$ 行每一行描述一个凸多边形，格式如下：\n\n第 $i+1$ 行的第一个数 $m_i$ 表示凸多边形的点数，接下来有 $m_i$ 对实数，一对实数给出了一个点的坐标，这 $m_i$ 个顶点按照从任意一个顶点出发的逆时针顺序给出。且所有实数都在 $(-10^3,10^3)$ 的范围内，小数点后不超过 $8$ 位。", "outputFormat": "如果不能拼成矩形，输出只有一行 `No`。\n\n如果能拼成矩形，输出的第一行为 `Yes`。\n\n接下来的 $n$ 行描述拼法。\n\n如果能够拼成一个 $X\\times Y$ 的矩形，那么矩形的四个顶点的坐标是 $(0,0), (0,Y), (X,Y), (X,0)$。这 $n$ 行输出每一个凸多边形的顶点的坐标（拼成矩形后）。按照输入的顺序，即第一个输出的凸多边形对应输入的第一个凸多边形。对于每一个凸多边形，输出也按照输入的顺序，即一个多边形的第一个顶点对应输入的第一个顶点。这样，输出总共有 $n$ 行，第 $i$ 行有 $m_i$ 对数。", "hint": "#### 样例说明\n如下图，左上、右上和左下描述了输入的凸多边形，右下描述了输出的的矩形。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dmd58o3a.png)\n\n#### 注意\n由于矩形纸片的两面的颜色不同，所以纸片只能旋转和平移，不能翻转。所以，输出的 $m_i$ 个顶点也应该是逆时针顺序的。\n\n#### 数据范围\n对于 $100\\%$ 的数据，$1\\leq n\\leq 8$, $3\\leq m_i\\leq 8$。\n\n#### 评分说明\n两个实数之差的绝对值小于 $10^{-7}$ 时认为两个实数相等。", "locale": "zh-CN"}}}
{"pid": "P5791", "type": "P", "difficulty": 0, "samples": [["3 3 2 2 3 3\n1 1\n1 1", "Yes\n1 -1 1\n-4 5 -4\n1 -1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2006", "Special Judge", "CTSC/CTS"], "title": "[CTSC2006] 方块填数", "background": null, "description": "最近，一个方块填数的游戏风靡全球：\n\n给定一个 $n\\times m$ 的方块。$n$ 行从上到下标号为 $1$ 到 $n$，$m$ 列从左到右标号为 $1$ 到 $m$。如果一个方格所在的行的标号和所在的列的标号都是奇数，那么该方格就称为奇方格。游戏的开始所有的奇方格中都填上了数。你需要在其他的方格里填数，如果填完数后，方块满足下面条件，你就赢得了这个游戏：\n\n1. 任意一个 $a_1\\times b_1$ 的子方块中所有数的和大于 $0$；\n2. 任意一个 $a_2\\times b_2$ 的子方块中所有数的和小于 $0$。\n\n其中，$a_1, b_1, a_2, b_2$ 都是在游戏的开始给定的。一个 $a\\times b$ 的子方块是指行标号在 $i\\ (1\\leq i\\leq n-a+1)$ 到 $i+a-1$ 之间，列标号在 $j\\ (1\\leq j\\leq m-b+1)$ 到 $j+b-1$ 之间的所有的方格的集合。\n\n小 P 很喜欢这种游戏，他希望你帮助写一个程序给出一种填数的方案，或者告诉他这样的方案不存在。", "inputFormat": "第一行为用空格分开的 $6$ 个正整数 $n, m, a_1, b_1, a_2, b_2$。\n\n接下来 $\\lfloor \\frac{n+1}{2} \\rfloor$ 行，每一行有 $\\lfloor \\frac{m+1}{2} \\rfloor$ 个整数，第 $i+1$ 行的第 $j\\ (j=1, 2, \\ldots, \\lfloor \\frac{m+1}{2} \\rfloor)$ 个数表示在游戏开始时方块的第 $2i-1$ 行，第 $2j-1$ 列的方格所填的整数。", "outputFormat": "如果填数方案不存在，仅输出一行 `No`。\n\n如果填数方案存在，先输出一行 `Yes`。接下来 $n$ 行，每一行为用空格分开的 $m$ 个整数，描述一个填数方案。输出的每一个整数必须在 $-10^9$ 到 $10^9$ 之间。", "hint": "#### 样例说明\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/genpecku.png)\n\n填完数后，任意 $2\\times 2$ 的方块中的数字之和是 $1$；$3\\times 3$ 的方块中的数字之和是 $-1$。\n\n#### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leq n, m, a_1, b_1, a_2, b_2\\leq 100$。方格里已经填的数都在 $-100$ 到 $100$ 之间。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2006] Filling Numbers in a Grid", "background": "", "description": "Recently, a game of filling numbers in a grid has become popular worldwide.\n\nYou are given an $n \\times m$ grid. The $n$ rows are numbered from $1$ to $n$ from top to bottom, and the $m$ columns are numbered from $1$ to $m$ from left to right. If both the row number and the column number of a cell are odd, then the cell is called an odd cell. At the start of the game, all odd cells are already filled with numbers. You need to fill numbers into the other cells. If after filling, the grid satisfies the following conditions, you win the game:\n\n1. In every $a_1 \\times b_1$ subgrid, the sum of all numbers is greater than $0$.\n2. In every $a_2 \\times b_2$ subgrid, the sum of all numbers is less than $0$.\n\nHere, $a_1, b_1, a_2, b_2$ are all given at the start of the game. An $a \\times b$ subgrid refers to the set of all cells whose row indices are from $i\\ (1 \\leq i \\leq n-a+1)$ to $i+a-1$, and whose column indices are from $j\\ (1 \\leq j \\leq m-b+1)$ to $j+b-1$.\n\nXiao P likes this game very much. He hopes you can help write a program to provide one way to fill the numbers, or tell him that such a way does not exist.", "inputFormat": "The first line contains $6$ positive integers separated by spaces: $n, m, a_1, b_1, a_2, b_2$.\n\nNext, there are $\\lfloor \\frac{n+1}{2} \\rfloor$ lines. Each line contains $\\lfloor \\frac{m+1}{2} \\rfloor$ integers. The $j\\ (j=1, 2, \\ldots, \\lfloor \\frac{m+1}{2} \\rfloor)$-th number on line $i+1$ represents the integer initially filled in the cell at row $2i-1$ and column $2j-1$ of the grid.", "outputFormat": "If no filling scheme exists, output only one line: `No`.\n\nIf a filling scheme exists, first output one line: `Yes`. Then output $n$ lines, each containing $m$ integers separated by spaces, describing a filling scheme. Each output integer must be between $-10^9$ and $10^9$.", "hint": "#### Sample Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/genpecku.png)\n\nAfter filling, the sum of the numbers in any $2 \\times 2$ block is $1$; the sum of the numbers in any $3 \\times 3$ block is $-1$.\n\n#### Constraints\n\nFor $100\\%$ of the testdata, $1 \\leq n, m, a_1, b_1, a_2, b_2 \\leq 100$. The numbers already filled in the grid are all between $-100$ and $100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2006] 方块填数", "background": null, "description": "最近，一个方块填数的游戏风靡全球：\n\n给定一个 $n\\times m$ 的方块。$n$ 行从上到下标号为 $1$ 到 $n$，$m$ 列从左到右标号为 $1$ 到 $m$。如果一个方格所在的行的标号和所在的列的标号都是奇数，那么该方格就称为奇方格。游戏的开始所有的奇方格中都填上了数。你需要在其他的方格里填数，如果填完数后，方块满足下面条件，你就赢得了这个游戏：\n\n1. 任意一个 $a_1\\times b_1$ 的子方块中所有数的和大于 $0$；\n2. 任意一个 $a_2\\times b_2$ 的子方块中所有数的和小于 $0$。\n\n其中，$a_1, b_1, a_2, b_2$ 都是在游戏的开始给定的。一个 $a\\times b$ 的子方块是指行标号在 $i\\ (1\\leq i\\leq n-a+1)$ 到 $i+a-1$ 之间，列标号在 $j\\ (1\\leq j\\leq m-b+1)$ 到 $j+b-1$ 之间的所有的方格的集合。\n\n小 P 很喜欢这种游戏，他希望你帮助写一个程序给出一种填数的方案，或者告诉他这样的方案不存在。", "inputFormat": "第一行为用空格分开的 $6$ 个正整数 $n, m, a_1, b_1, a_2, b_2$。\n\n接下来 $\\lfloor \\frac{n+1}{2} \\rfloor$ 行，每一行有 $\\lfloor \\frac{m+1}{2} \\rfloor$ 个整数，第 $i+1$ 行的第 $j\\ (j=1, 2, \\ldots, \\lfloor \\frac{m+1}{2} \\rfloor)$ 个数表示在游戏开始时方块的第 $2i-1$ 行，第 $2j-1$ 列的方格所填的整数。", "outputFormat": "如果填数方案不存在，仅输出一行 `No`。\n\n如果填数方案存在，先输出一行 `Yes`。接下来 $n$ 行，每一行为用空格分开的 $m$ 个整数，描述一个填数方案。输出的每一个整数必须在 $-10^9$ 到 $10^9$ 之间。", "hint": "#### 样例说明\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/genpecku.png)\n\n填完数后，任意 $2\\times 2$ 的方块中的数字之和是 $1$；$3\\times 3$ 的方块中的数字之和是 $-1$。\n\n#### 数据范围\n\n对于 $100\\%$ 的数据，$1\\leq n, m, a_1, b_1, a_2, b_2\\leq 100$。方格里已经填的数都在 $-100$ 到 $100$ 之间。", "locale": "zh-CN"}}}
