{"pid": "P10532", "type": "P", "difficulty": 4, "samples": [["2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2024", "O2优化", "高校校赛"], "title": "[XJTUPC 2024] 筛法", "background": "", "description": "在算法竞赛的数论知识中，我们接触过埃拉托斯特尼筛法、线性筛法、莫比乌斯反演、杜教筛、Powerful Number 筛、Min\\_25 筛、洲阁筛等算法来帮助我们优化一些求和/连乘的复杂度，那么现在问题来了，今天这道题将会使用到上述的哪个算法呢？\n\n现在给定正整数 $n$，需要你求 \n\n$$\n\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^n\\lfloor \\dfrac{n}{\\max(i,j)}\\rfloor [i \\perp j]\n$$\n\n其中 $[i \\perp j]$ 表示 $i,j$ 是否互素，即当 $\\gcd(i,j)=1$ 时，$[i \\perp j]$ 的值为 $1$，其余情况其值为 $0$。 ", "inputFormat": "输入一行一个正整数 $n$ ($1\\le n \\le 10^9$)。", "outputFormat": "输出一行一个整数，表示这个和式的结果。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[XJTUPC 2024] 筛法", "background": "", "description": "在算法竞赛的数论知识中，我们接触过埃拉托斯特尼筛法、线性筛法、莫比乌斯反演、杜教筛、Powerful Number 筛、Min\\_25 筛、洲阁筛等算法来帮助我们优化一些求和/连乘的复杂度，那么现在问题来了，今天这道题将会使用到上述的哪个算法呢？\n\n现在给定正整数 $n$，需要你求 \n\n$$\n\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^n\\lfloor \\dfrac{n}{\\max(i,j)}\\rfloor [i \\perp j]\n$$\n\n其中 $[i \\perp j]$ 表示 $i,j$ 是否互素，即当 $\\gcd(i,j)=1$ 时，$[i \\perp j]$ 的值为 $1$，其余情况其值为 $0$。 ", "inputFormat": "输入一行一个正整数 $n$ ($1\\le n \\le 10^9$)。", "outputFormat": "输出一行一个整数，表示这个和式的结果。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P10533", "type": "P", "difficulty": 3, "samples": [["4\n-1 -1\n1 0\n1 -2\n-2 2", "Yes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "搜索", "贪心", "O2优化"], "title": "[Opoi 2024] 热核武器", "background": "\n\n跳蚤国与蛐蛐国正在激战！\n\n![level](https://tse3-mm.cn.bing.net/th/id/OIP-C.ewEm2cQO23KvtiSwFQMFGQHaE8?w=293&h=195&c=7&r=0&o=5&pid=1.7)\n\n上面是战术核显卡，与题目没有关联。", "description": "跳蚤国的国土可以看作平面直角坐标系。\n\n跳蚤国有 $N+1$ 座城市，有 $1$ 座是首都，位于 $(0,0)$，另 $N$ 座是普通城市，在这里假设首都为 $0$ 号城市，其他城市编号为 $1$ 至 $N$，对于每一座普通城市，位于 $(x_i,y_i)$。\n\n\n由于跳蚤国财力有限，对于每一个不是首都的城市 $i$，它会选择一个城市 $j$ 修建一条双向公路。令 $dis(x,y)$ 为 $x$，$y$ 城市的欧几里得距离，**则对于每一个不是首都的城市 $i$，它所对应的 $j$ 则是满足 $dis(j,0) \\le dis(i,0)$ ，$j \\ne i$ 的所有点中 $dis(i,j)$ 最小的点，如有多个合法 $j$，取其中编号最小的一个。**\n\n定义一座城市的 $\\gamma$ 值为这个城市走到首都所需要的最小道路数 $+1$，**如果走不到首都，设 $\\gamma$ 值为 $0$。**\n\n蛐蛐国要对跳蚤国进行战术核显卡打击，这次行动分为两个组：洛伦兹组和安培组。每个组都要对跳蚤国的部分城市进行打击，其中两个组需要恰好把跳蚤国每个城市打击一遍。\n\n对于这两个组来说，名利是最重要的，而蛐蛐国的评功标准是按照本次行动所打击城市的 $\\gamma$ 值和。所以你需要求出：有没有一种划分方式使得洛伦兹组和安培组分别的打击城市的 $\\gamma$ 值和相等，可以，输出 ```Yes```，否则输出 ```No``` 。", "inputFormat": "第 $1$ 行输入一个整数 $N$，表示跳蚤国普通城市的数目。\n\n接下来第 $2 \\sim N+1$ 行，第 $i+1$ 行输入两个整数，表示第 $i$ 座城市的横纵坐标 $(x_i,y_i)$。", "outputFormat": "一行一个字符串，```Yes``` 或者 ```No```。表示是否会有一种方法使得洛伦兹组和安培组分别的打击城市的 $\\gamma$ 值和相等。", "hint": "### 样例解释\n\n这幅图是长这样的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dasec5pr.png)\n\n对于 $C1$，$C0$ 和 $C2$ 满足 $dis(j,0) \\le dis(C1,0)$，但是 $C0$ 离 $C1$ 距离更近，添加边 $(C1,C0)$。\n\n对于 $C2$，只有 $C0$ 满足 $dis(j,0) \\le dis(C2,0)$，添加边 $(C2,C0)$。\n\n对于 $C3$，$C0$，$C1$ 和 $C2$ 满足 $dis(j,0) \\le dis(C3,0)$，但是 $C2$ 离 $C3$ 距离最近，因此添加边 $(C3,C2)$。**注意这里是因为在 $C3$ 处考虑时，最优点为 $C2$，所以 $C3$ 才向 $C2$ 修建了一条公路，和公路 $(C2,C0)$ 完全独立。**\n\n对于 $C4$，其他所有点都满足 $dis(j,0) \\le dis(C4,0)$，但是 $C0$ 离 $C4$ 距离最近，添加边 $(C4,C0)$。\n\n得到下面的表：\n\n| 城市编号 | $\\gamma$ 值 |\n| :-----------: | :-----------: |\n| 0 | 1 |\n| 1 | 2 |\n| 2 | 2 |\n| 3 | 3 |\n| 4 | 2 |\n\n所以把 $0,1,2$ 分给洛伦兹组，$3,4$ 分给安培组即可。\n\n### 数据范围\n\n$1 \\le N \\le 500$，$-10^6 \\le x_i,y_i \\le 10^6$。\n\n### 特殊说明\n\n由于本题输出只有 ```Yes``` 和 ```No```，所以本题采用最小分值评测法，即取所有测试点的得分最小值作为结果。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Opoi 2024] 热核武器", "background": "\n\n跳蚤国与蛐蛐国正在激战！\n\n![level](https://tse3-mm.cn.bing.net/th/id/OIP-C.ewEm2cQO23KvtiSwFQMFGQHaE8?w=293&h=195&c=7&r=0&o=5&pid=1.7)\n\n上面是战术核显卡，与题目没有关联。", "description": "跳蚤国的国土可以看作平面直角坐标系。\n\n跳蚤国有 $N+1$ 座城市，有 $1$ 座是首都，位于 $(0,0)$，另 $N$ 座是普通城市，在这里假设首都为 $0$ 号城市，其他城市编号为 $1$ 至 $N$，对于每一座普通城市，位于 $(x_i,y_i)$。\n\n\n由于跳蚤国财力有限，对于每一个不是首都的城市 $i$，它会选择一个城市 $j$ 修建一条双向公路。令 $dis(x,y)$ 为 $x$，$y$ 城市的欧几里得距离，**则对于每一个不是首都的城市 $i$，它所对应的 $j$ 则是满足 $dis(j,0) \\le dis(i,0)$ ，$j \\ne i$ 的所有点中 $dis(i,j)$ 最小的点，如有多个合法 $j$，取其中编号最小的一个。**\n\n定义一座城市的 $\\gamma$ 值为这个城市走到首都所需要的最小道路数 $+1$，**如果走不到首都，设 $\\gamma$ 值为 $0$。**\n\n蛐蛐国要对跳蚤国进行战术核显卡打击，这次行动分为两个组：洛伦兹组和安培组。每个组都要对跳蚤国的部分城市进行打击，其中两个组需要恰好把跳蚤国每个城市打击一遍。\n\n对于这两个组来说，名利是最重要的，而蛐蛐国的评功标准是按照本次行动所打击城市的 $\\gamma$ 值和。所以你需要求出：有没有一种划分方式使得洛伦兹组和安培组分别的打击城市的 $\\gamma$ 值和相等，可以，输出 ```Yes```，否则输出 ```No``` 。", "inputFormat": "第 $1$ 行输入一个整数 $N$，表示跳蚤国普通城市的数目。\n\n接下来第 $2 \\sim N+1$ 行，第 $i+1$ 行输入两个整数，表示第 $i$ 座城市的横纵坐标 $(x_i,y_i)$。", "outputFormat": "一行一个字符串，```Yes``` 或者 ```No```。表示是否会有一种方法使得洛伦兹组和安培组分别的打击城市的 $\\gamma$ 值和相等。", "hint": "### 样例解释\n\n这幅图是长这样的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dasec5pr.png)\n\n对于 $C1$，$C0$ 和 $C2$ 满足 $dis(j,0) \\le dis(C1,0)$，但是 $C0$ 离 $C1$ 距离更近，添加边 $(C1,C0)$。\n\n对于 $C2$，只有 $C0$ 满足 $dis(j,0) \\le dis(C2,0)$，添加边 $(C2,C0)$。\n\n对于 $C3$，$C0$，$C1$ 和 $C2$ 满足 $dis(j,0) \\le dis(C3,0)$，但是 $C2$ 离 $C3$ 距离最近，因此添加边 $(C3,C2)$。**注意这里是因为在 $C3$ 处考虑时，最优点为 $C2$，所以 $C3$ 才向 $C2$ 修建了一条公路，和公路 $(C2,C0)$ 完全独立。**\n\n对于 $C4$，其他所有点都满足 $dis(j,0) \\le dis(C4,0)$，但是 $C0$ 离 $C4$ 距离最近，添加边 $(C4,C0)$。\n\n得到下面的表：\n\n| 城市编号 | $\\gamma$ 值 |\n| :-----------: | :-----------: |\n| 0 | 1 |\n| 1 | 2 |\n| 2 | 2 |\n| 3 | 3 |\n| 4 | 2 |\n\n所以把 $0,1,2$ 分给洛伦兹组，$3,4$ 分给安培组即可。\n\n### 数据范围\n\n$1 \\le N \\le 500$，$-10^6 \\le x_i,y_i \\le 10^6$。\n\n### 特殊说明\n\n由于本题输出只有 ```Yes``` 和 ```No```，所以本题采用最小分值评测法，即取所有测试点的得分最小值作为结果。\n", "locale": "zh-CN"}}}
{"pid": "P10534", "type": "P", "difficulty": 4, "samples": [["3\n3\n131011\n1\n5\n3\n2011\n", "Yes\nNo\nYes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "O2优化"], "title": "[Opoi 2024] 简谐振动", "background": "你说得对，但是简谐振动十分优美。\n\n![pic](https://ts1.cn.mm.bing.net/th?id=OIP-C.uGsZxikgYriy7OYxJsbm0AHaD1&w=174&h=150&c=8&rs=1&qlt=90&o=6&pid=3.1&rm=2)\n\n![cip](https://tse4-mm.cn.bing.net/th/id/OIP-C.yNecd9xmljOtND3V6b4gcAHaEW?w=278&h=180&c=7&r=0&o=5&pid=1.7)\n\n![jzp](https://tse2-mm.cn.bing.net/th/id/OIP-C.GSxOJQ3KlXRC9V_y_crpigHaFj?w=230&h=180&c=7&r=0&o=5&pid=1.7)\n\n但是我们不出多边形下海，所以你不需要维护一个质点的简谐振动。", "description": "已知一个数字串 $S$，请你判断是否存在一种长度为 $n$ **且 $n$ 为奇数**的整数序列 $A_i$，使得 $A_1+A_2,A_2+A_3,\\dots,A_{n-1}+A_n,A_n+A_1$ 的值按顺序依次拼接起来可以得到 $S$。\n\n特别的，如果存在一种方案使得拼接的时候两项中间用 $[0,\\infty)$ 个 $0$ 分隔仍然可以得到 $S$，该方案仍然合法。**所有数据保证最前面没有前导 $0$。**", "inputFormat": "第一行一个整数，表示数据组数 $T$。\n\n接下来每组数据：\n\n第一行一个整数 $n$。\n\n第二行一个字符串 $S$。", "outputFormat": "对于每组数据，如果有解，输出 `Yes`，否则输出 `No`，用换行符分隔。", "hint": "### 样例解释\n第一组样例解释：\n\n$\\begin{matrix}\n7&6&4\\cr\n+&+&+\\cr\n6&4&7\\cr\n||&||&||\\cr\n13&10&11\\end{matrix}$\n\n当然，你也可以说：\n\n$\\begin{matrix}\n71&60&-60\\cr\n+&+&+\\cr\n60&-60&71\\cr\n||&||&||\\cr\n131&0&11\\end{matrix}$\n\n构造方法不唯一。\n\n第二组样例解释：\n\n如果有解，$A_1=2.5$，而题目说了 $A$ 为整数序列，故无解。\n\n第三组样例解释：\n\n$\\begin{matrix}\n1&&1&0\\cr\n+&&+&+\\cr\n1&&0&1\\cr\n||&&||&||\\cr\n2&0&1&1\\end{matrix}$\n\n> 该方案中间用了 $1 \\in [0,\\infty)$ 个 $0$ 分隔，符合要求，输出 `Yes`。\n\n---\n### 数据范围\n对于 $50\\%$ 的数据，$1\\le T \\le 10$，$1\\le |S| \\le 10$，$1 \\le n \\le 3$。\n\n对于 $100\\%$ 的数据，$1\\le T \\le 100$。保证 $\\sum n\\le 10^6$ 且 $\\sum|S|\\le 10^6$，${\\tt 0} \\le S_i \\le {\\tt 9}$，**且 $n$ 为奇数**。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Opoi 2024] 简谐振动", "background": "你说得对，但是简谐振动十分优美。\n\n![pic](https://ts1.cn.mm.bing.net/th?id=OIP-C.uGsZxikgYriy7OYxJsbm0AHaD1&w=174&h=150&c=8&rs=1&qlt=90&o=6&pid=3.1&rm=2)\n\n![cip](https://tse4-mm.cn.bing.net/th/id/OIP-C.yNecd9xmljOtND3V6b4gcAHaEW?w=278&h=180&c=7&r=0&o=5&pid=1.7)\n\n![jzp](https://tse2-mm.cn.bing.net/th/id/OIP-C.GSxOJQ3KlXRC9V_y_crpigHaFj?w=230&h=180&c=7&r=0&o=5&pid=1.7)\n\n但是我们不出多边形下海，所以你不需要维护一个质点的简谐振动。", "description": "已知一个数字串 $S$，请你判断是否存在一种长度为 $n$ **且 $n$ 为奇数**的整数序列 $A_i$，使得 $A_1+A_2,A_2+A_3,\\dots,A_{n-1}+A_n,A_n+A_1$ 的值按顺序依次拼接起来可以得到 $S$。\n\n特别的，如果存在一种方案使得拼接的时候两项中间用 $[0,\\infty)$ 个 $0$ 分隔仍然可以得到 $S$，该方案仍然合法。**所有数据保证最前面没有前导 $0$。**", "inputFormat": "第一行一个整数，表示数据组数 $T$。\n\n接下来每组数据：\n\n第一行一个整数 $n$。\n\n第二行一个字符串 $S$。", "outputFormat": "对于每组数据，如果有解，输出 `Yes`，否则输出 `No`，用换行符分隔。", "hint": "### 样例解释\n第一组样例解释：\n\n$\\begin{matrix}\n7&6&4\\cr\n+&+&+\\cr\n6&4&7\\cr\n||&||&||\\cr\n13&10&11\\end{matrix}$\n\n当然，你也可以说：\n\n$\\begin{matrix}\n71&60&-60\\cr\n+&+&+\\cr\n60&-60&71\\cr\n||&||&||\\cr\n131&0&11\\end{matrix}$\n\n构造方法不唯一。\n\n第二组样例解释：\n\n如果有解，$A_1=2.5$，而题目说了 $A$ 为整数序列，故无解。\n\n第三组样例解释：\n\n$\\begin{matrix}\n1&&1&0\\cr\n+&&+&+\\cr\n1&&0&1\\cr\n||&&||&||\\cr\n2&0&1&1\\end{matrix}$\n\n> 该方案中间用了 $1 \\in [0,\\infty)$ 个 $0$ 分隔，符合要求，输出 `Yes`。\n\n---\n### 数据范围\n对于 $50\\%$ 的数据，$1\\le T \\le 10$，$1\\le |S| \\le 10$，$1 \\le n \\le 3$。\n\n对于 $100\\%$ 的数据，$1\\le T \\le 100$。保证 $\\sum n\\le 10^6$ 且 $\\sum|S|\\le 10^6$，${\\tt 0} \\le S_i \\le {\\tt 9}$，**且 $n$ 为奇数**。", "locale": "zh-CN"}}}
{"pid": "P10535", "type": "P", "difficulty": 3, "samples": [["4 4\n5 8 10\n7 8 2\n2 3 1\n5 6 5\n1 4", "8"], ["4 1\n2 3 1\n1 8", "I have no idea how to solve it."], ["4 1\n2 3 1\n1 5", "0"], ["5 10\n1 2 603124134\n2 3 373980902\n2 4 6578324\n3 5 936364479\n4 6 182080546\n4 7 340293479\n6 8 753053273\n1 9 274129271\n3 10 616764767\n4 6 255802600\n1 2", "3673658542"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "最短路"], "title": "[Opoi 2024] 数据转换", "background": "![](data:image/jpeg;base64,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)\n\n![](https://tse2-mm.cn.bing.net/th/id/OIP-C.ojcWO_62WQhtFFaZSdmbgAHaEo?w=244&h=180&c=7&r=0&o=5&pid=1.7)\n\nArrda 家里面有很多五花八门的用电器和数据线，而且很多用电器的插头种类都不一样，这导致每次 Arrda 想要共享两个用电器的数据时都要一半天用来买到合适的数据线，而且有的时候数据线很贵！\n\n于是 Arrda 想让你求出花钱最少的数据转换方案。", "description": "Arrda 家中有 $n$ 类，$2n$ 种数据线接头，每一类插头有 $2$ 种不同接头，种类分别为 $i$ 和 $n+i$，**有且只有同一类的不同接头可以互相连接（你可以理解为 $i$ 是凸出的接头，$n + i$ 是凹的接头，可以连接可以理解为插上）**。\n\n商城里售卖着 $m$ 种双向数据线，每根双向数据线两端各有一个接头，种类分别为为 $u_i,v_i$。同时，第 $i$ 种双向数据线有一个购买价格 $w_i$，每种数据线可以购买无限条。\n\nArrda 想要交换两个用电器的数据，其中两个用电器的接头种类编号为 $S,T$，求能使这两个用电器能直接或由若干条数据线相连的最小总价格（毕竟买数据线需要钱），如果无解，输出 `I have no idea how to solve it.`，注意，**两个用电器的接口不能直接连接数据线，因为它们在用电器上，而非数据线两端！**", "inputFormat": "第一行两个整数 $n,m$，意义见题面。\n\n接下来 $m$ 行，每行三个整数 $u_i,v_i,w_i$。\n\n接下来一行两个整数 $S,T$。", "outputFormat": "一个非负整数表示能使这两个用电器能直接或由若干条数据线相连的最小总价格。\n\n若无解，请输出 `I have no idea how to solve it.`。", "hint": "### 样例 1 解释：\n\n![picture](https://cdn.luogu.com.cn/upload/image_hosting/4j95t4xl.png)\n\n```\n1=5->6=2->3=7->8=4\n```\n\n可以证明，没有总代价更小的方案。\n\n### 样例 4 解释\n\n![222](https://cdn.luogu.com.cn/upload/image_hosting/k88cjz1t.png)\n\n```\n1=6->8=3->5=10->3=8->6=1->9=4->7=2\n```\n`4->6` 有两种数据线，我们选择代价为 $182080546$ 的那一根，因为其代价更小。\n\n可以证明，没有总代价更小的方案。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$1\\le n,m \\le 10^5$，$1\\le u_i,v_i,s,t \\le 2 \\times n$，$1\\le w_i \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Opoi 2024] 数据转换", "background": "![](data:image/jpeg;base64,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)\n\n![](https://tse2-mm.cn.bing.net/th/id/OIP-C.ojcWO_62WQhtFFaZSdmbgAHaEo?w=244&h=180&c=7&r=0&o=5&pid=1.7)\n\nArrda 家里面有很多五花八门的用电器和数据线，而且很多用电器的插头种类都不一样，这导致每次 Arrda 想要共享两个用电器的数据时都要一半天用来买到合适的数据线，而且有的时候数据线很贵！\n\n于是 Arrda 想让你求出花钱最少的数据转换方案。", "description": "Arrda 家中有 $n$ 类，$2n$ 种数据线接头，每一类插头有 $2$ 种不同接头，种类分别为 $i$ 和 $n+i$，**有且只有同一类的不同接头可以互相连接（你可以理解为 $i$ 是凸出的接头，$n + i$ 是凹的接头，可以连接可以理解为插上）**。\n\n商城里售卖着 $m$ 种双向数据线，每根双向数据线两端各有一个接头，种类分别为为 $u_i,v_i$。同时，第 $i$ 种双向数据线有一个购买价格 $w_i$，每种数据线可以购买无限条。\n\nArrda 想要交换两个用电器的数据，其中两个用电器的接头种类编号为 $S,T$，求能使这两个用电器能直接或由若干条数据线相连的最小总价格（毕竟买数据线需要钱），如果无解，输出 `I have no idea how to solve it.`，注意，**两个用电器的接口不能直接连接数据线，因为它们在用电器上，而非数据线两端！**", "inputFormat": "第一行两个整数 $n,m$，意义见题面。\n\n接下来 $m$ 行，每行三个整数 $u_i,v_i,w_i$。\n\n接下来一行两个整数 $S,T$。", "outputFormat": "一个非负整数表示能使这两个用电器能直接或由若干条数据线相连的最小总价格。\n\n若无解，请输出 `I have no idea how to solve it.`。", "hint": "### 样例 1 解释：\n\n![picture](https://cdn.luogu.com.cn/upload/image_hosting/4j95t4xl.png)\n\n```\n1=5->6=2->3=7->8=4\n```\n\n可以证明，没有总代价更小的方案。\n\n### 样例 4 解释\n\n![222](https://cdn.luogu.com.cn/upload/image_hosting/k88cjz1t.png)\n\n```\n1=6->8=3->5=10->3=8->6=1->9=4->7=2\n```\n`4->6` 有两种数据线，我们选择代价为 $182080546$ 的那一根，因为其代价更小。\n\n可以证明，没有总代价更小的方案。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$1\\le n,m \\le 10^5$，$1\\le u_i,v_i,s,t \\le 2 \\times n$，$1\\le w_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10536", "type": "P", "difficulty": 6, "samples": [["7\n2 1 1 9 8 5 1\nzzabcad\n1 2\n2 3\n3 4\n3 5\n5 6\n5 7", "3\n3\n3\n1\n1\n1\n1\n"], ["12\n1 2 2 4 1 3 4 3 1 4 3 1 \nbaabbbbbbbaa\n4 6\n5 7\n1 2\n12 10\n8 2\n10 11\n5 9\n10 3\n2 3\n4 3\n4 5\n", "5\n4\n3\n1\n2\n1\n1\n1\n1\n1\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "树上启发式合并", "O2优化", "树链剖分", "单调栈"], "title": "[Opoi 2024] 二十六点", "background": "二十六点：\n\n> 。 。 。 。 。 。 。 。 。 。 。 。 。\n>\n> 。 。 。 。 。 。 。 。 。 。 。 。 。\n\n凑二十六点真好玩，而为了凑四道题，就有了这道权值只有 $26$ 种的凑数题。", "description": "\n给你一棵有 $n$ 个结点的以 $1$ 为根的树 $T$，第 $i$ 个结点有一个颜色 $c_i$，${\\tt a} \\le c_i \\le {\\tt z}$，和一个值 $P_i$。\n\n对于每一个点 $x$，**从它到它子树中每一个点**（注意顺序是从它本身到子树中的点）都有一条路径，一共有子树的大小条路径。\n\n现在忽略掉这些路径中的第 $2$ 到第 $P_x$ 个的点，特别地，若 $P_x = 1$ 则不忽略任何点。将忽略后的路径当作一个序列，序列中每个点的权值为路径上点的 $c_i$，求**每一个点的所有序列最长不下降子序列长度的最大值**。\n\n注: 若有路径 $j$ 上的节点数 $len_j < P_x$，则相当于忽略这条路径上除第一个点外的所有点。\n", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数 $P_i$。\n\n第三行 $n$ 个小写字母 $c_i$，**字符与字符间没有空格**。\n\n接下来 $n - 1$ 行，描述树 $T$，每行两个整数 $u,v$，表示 $u,v$ 存在一条边。\n\n行末可能有多余空格（慎用 `getchar()`）。", "outputFormat": "输出 $n$ 行，表示每一个点的答案，按照编号从小到大输出。", "hint": "\n\n### 样例一解释：\n\n样例中树的形态：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6vbio7vo.png?x-oss-process=image/resize,h_450,m_lfit)\n\n对于 $1$ 号节点：\n$P_1=2$。\n\n|  序列| 权值 | 最长不下降子序列长度 | 最长不下降子序列 |\n| :----------: | :----------: | :----------: | :----------: |\n| 1 | z | 1 | z |\n| 1 3 | za | 1 |  z |\n| 1 3 4 |  zab | 2  | ab |\n| 1 3 5  |  zac | 2 |  ac   |\n| 1 3 5 6 |  zaca | 2  | ac |\n| 1 3 5 7 | zacd| 3 | acd  |\n\n长度最长的最长不降子序列：acd。\n\n$2$ 号节点和 $1$ 号节点同理。\n\n对于 $3$ 号节点：\n$P_3=1$。\n\n|  序列| 权值 | 最长不下降子序列长度 | 最长不下降子序列 |\n| :----------: | :----------: | :----------: | :----------: |\n| 3 | a | 1 | a |\n| 3 4 | ab | 1 |  ab |\n| 3 5  |  ac | 2  | ac |\n| 3 5 6  |  aca | 2 |  ac   |\n|3 5 7   |  acd | 3  |acd |\n\n长度最长的最长不降子序列：acd。\n\n对于 $4,5,6,7$，它的所有序列中都只有它自己一个点，所以输出 $1$。\n### 数据范围\n\n本题采用 Subtask 计分。\n\n| Subtask | Limit | Pts |\n| :-----------: | :-----------: | :-----------: |\n| 0 | $n \\le 100$ | 5 |\n| 1 | $n \\le 2000$ | 15 |\n| 2 | $\\forall 1 \\le i \\le n \\quad P_i=1$ | 30 |\n| 3 | Empty | 50 |\n\n对于 $100\\%$ 的数据：\n\n$1 \\le n \\le 10^5$。\n\n$\\forall 1 \\le i \\le n$， $c_i$ 为小写字母，$1 \\le P_i \\le n$。\n\n给出的树连通且合法。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Opoi 2024] 二十六点", "background": "二十六点：\n\n> 。 。 。 。 。 。 。 。 。 。 。 。 。\n>\n> 。 。 。 。 。 。 。 。 。 。 。 。 。\n\n凑二十六点真好玩，而为了凑四道题，就有了这道权值只有 $26$ 种的凑数题。", "description": "\n给你一棵有 $n$ 个结点的以 $1$ 为根的树 $T$，第 $i$ 个结点有一个颜色 $c_i$，${\\tt a} \\le c_i \\le {\\tt z}$，和一个值 $P_i$。\n\n对于每一个点 $x$，**从它到它子树中每一个点**（注意顺序是从它本身到子树中的点）都有一条路径，一共有子树的大小条路径。\n\n现在忽略掉这些路径中的第 $2$ 到第 $P_x$ 个的点，特别地，若 $P_x = 1$ 则不忽略任何点。将忽略后的路径当作一个序列，序列中每个点的权值为路径上点的 $c_i$，求**每一个点的所有序列最长不下降子序列长度的最大值**。\n\n注: 若有路径 $j$ 上的节点数 $len_j < P_x$，则相当于忽略这条路径上除第一个点外的所有点。\n", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数 $P_i$。\n\n第三行 $n$ 个小写字母 $c_i$，**字符与字符间没有空格**。\n\n接下来 $n - 1$ 行，描述树 $T$，每行两个整数 $u,v$，表示 $u,v$ 存在一条边。\n\n行末可能有多余空格（慎用 `getchar()`）。", "outputFormat": "输出 $n$ 行，表示每一个点的答案，按照编号从小到大输出。", "hint": "\n\n### 样例一解释：\n\n样例中树的形态：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6vbio7vo.png?x-oss-process=image/resize,h_450,m_lfit)\n\n对于 $1$ 号节点：\n$P_1=2$。\n\n|  序列| 权值 | 最长不下降子序列长度 | 最长不下降子序列 |\n| :----------: | :----------: | :----------: | :----------: |\n| 1 | z | 1 | z |\n| 1 3 | za | 1 |  z |\n| 1 3 4 |  zab | 2  | ab |\n| 1 3 5  |  zac | 2 |  ac   |\n| 1 3 5 6 |  zaca | 2  | ac |\n| 1 3 5 7 | zacd| 3 | acd  |\n\n长度最长的最长不降子序列：acd。\n\n$2$ 号节点和 $1$ 号节点同理。\n\n对于 $3$ 号节点：\n$P_3=1$。\n\n|  序列| 权值 | 最长不下降子序列长度 | 最长不下降子序列 |\n| :----------: | :----------: | :----------: | :----------: |\n| 3 | a | 1 | a |\n| 3 4 | ab | 1 |  ab |\n| 3 5  |  ac | 2  | ac |\n| 3 5 6  |  aca | 2 |  ac   |\n|3 5 7   |  acd | 3  |acd |\n\n长度最长的最长不降子序列：acd。\n\n对于 $4,5,6,7$，它的所有序列中都只有它自己一个点，所以输出 $1$。\n### 数据范围\n\n本题采用 Subtask 计分。\n\n| Subtask | Limit | Pts |\n| :-----------: | :-----------: | :-----------: |\n| 0 | $n \\le 100$ | 5 |\n| 1 | $n \\le 2000$ | 15 |\n| 2 | $\\forall 1 \\le i \\le n \\quad P_i=1$ | 30 |\n| 3 | Empty | 50 |\n\n对于 $100\\%$ 的数据：\n\n$1 \\le n \\le 10^5$。\n\n$\\forall 1 \\le i \\le n$， $c_i$ 为小写字母，$1 \\le P_i \\le n$。\n\n给出的树连通且合法。", "locale": "zh-CN"}}}
{"pid": "P10537", "type": "P", "difficulty": 4, "samples": [["1\n3 1\n0 0\n1 2", "2"], ["1\n5 2\n0 0 1 1 \n1 2 3 4\n4 1 2 3", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["贪心", "2024", "APIO", "交互题"], "title": "[APIO2024] 九月", "background": "## 请勿使用 C++14(GCC9) 提交\n\n你无需在程序开头引入库 `september.h`。", "description": "杭州市的中心广场有一棵著名的古树。这棵古树可以看作一棵 $N$ 个节点的有根树，节点编号从 $0$ 到 $N - 1$，其中 $0$ 号节点是根节点。\n\n称没有孩子的节点为叶子节点。古树每次落叶时，会选择一个当前的叶子节点删去。每一天中，古树可能会多次落叶。\n\n有 $M$ 位志愿者（编号从 $0$ 到 $M - 1$）负责看护古树。每一位志愿者将各自按照如下方式独立记录今年的落叶的情况：\n\n每一天，收集所有新的落叶的编号（即当天删除的节点的编号），然后将它们按任意顺序写在先前的落叶编号之后。\n\n例如：第一天，叶子 $3$ 和 $4$ 落下，于是他们写下 $3, 4$ 或 $4, 3$。第二天，叶子 $1$ 和 $2$ 落下，于是他们继续写下 $1, 2$ 或 $2, 1$。最终的记录可能为 $(3, 4, 1, 2)$，$(4, 3, 1, 2)$，$(3, 4, 2, 1)$ 或 $(4, 3, 2, 1)$ 中的任意一个。\n\n这个过程持续了 $K$ 天，每天都有新的叶子掉落，直到只剩根节点为止。\n\n你在旅途过程中经过了杭州。此刻已是寒冬，仰望古树光秃秃的枝干，你不禁想起落叶纷飞的美丽景象。\n\n你很想知道今年有几天能看见落叶，但你只能找到 $M$ 位志愿者的记录。尝试根据这些记录推断出 $K$ 可能的最大值。\n\n### 交互方式\n\n你只需要实现以下函数：\n\n```cpp\nint solve(int N, int M, std::vector<int> F,\n            std::vector<std::vector<int>> S);\n```\n\n+   $N$：古树的节点数量。\n+   $M$：志愿者的数量。\n+   $F$：一个长度为 $N$ 的数组。对于 $1 \\le i \\le N - 1$，$F[i]$ 表示节点 $i$ 的父亲节点的编号。$F[0]$ 始终为 $-1$。\n+   $S$：一个长度为 $M$ 的数组。$S$ 中的每个元素是一个长度为 $N - 1$ 的数组。$S[i][j]$ 表示志愿者 $i$ 记录的第 $j$ 个节点编号（从 $0$ 开始）。\n+   该函数必须返回一个整数，表示根据如上规则的 $K$ 可能的最大值（即，最大可能的落叶天数）。\n+   对于每个测试点，交互库可能调用该函数多于一次。每次调用都应该作为新的情况分别处理。\n\n注意：由于函数调用可能会发生多次，选手需要注意之前调用的残余数据对于后续调用的影响，尤其是全局变量的状态。", "inputFormat": "评测程序示例读取如下格式的输入：\n\n+   第 1 行：$T$\n\n对于接下来 $T$ 组数据中的每一组：\n\n+   第 $1$ 行：$N\\ M$\n+   第 $2$ 行：$F[1]\\ F[2]\\ \\ldots\\  F[N - 1]$\n+   第 $3 + i\\ (0 \\le i \\le M - 1)$ 行：$S[i][0]\\ S[i][1]\\ S[i][2]\\ \\ldots\\ S[i][N - 2]$", "outputFormat": "评测程序示例按照如下格式打印你的答案：\n\n对于每组测试数据：\n\n+   第 1 行：函数 `solve` 的返回值", "hint": "### 样例解释\n\n对于样例一，考虑如下调用：\n\n```cpp\nsolve(3, 1, {-1, 0, 0}, {{1, 2}});\n```\n\n对应的树如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i2lup6cf.png)\n\n叶子 $1$ 和 $2$ 可能在同一天落下，或者叶子 $1$ 在第一天先落下，然后叶子 $2$ 在第二天落下。落叶天数不超过 $2$。\n\n因此，程序应当返回 $2$。\n\n对于样例二，考虑如下调用：\n\n```cpp\nsolve(5, 2, {-1, 0, 0, 1, 1}, {{1, 2, 3, 4}, {4, 1, 2, 3}});\n```\n\n对应的树如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l50142xn.png)\n\n假设至少有 $2$ 天落叶，根据志愿者的记录，叶子 $4$ 将在不同的日子（第一天和最后一天）落下，这是矛盾的。\n\n因此，程序应当返回 $1$。\n\n### 数据范围\n\n+   $2 \\le N \\le 10^5$\n+   $1 \\le M \\le 5$\n+   $\\sum NM \\le 8 \\times 10^5$\n+   $F[0] = -1$ 且对于 $1 \\le i \\le N - 1$, $0 \\le F[i] \\le i - 1$\n+   对于 $1 \\le i \\le M - 1$, 数组 $S[i]$ 是一个 $1, 2, \\ldots , N - 1$ 的排列\n+   保证 $F$ 描述的是一棵以节点 $0$ 为根的有根树\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :---: | :---: |\n| 1 | $M=1,N\\le 10,\\sum N\\le 30$ | $11$ |\n| 2 | $N\\le 10,\\sum N\\le 30$ | $14$ |\n| 3 | $M=1,N\\le 1\\,000,\\sum N\\le 2\\,000,F[i]=i-1$ | $5$ |\n| 4 | $M=1,N\\le 1\\,000,\\sum N\\le 2\\,000$ | $9$ |\n| 5 | $N\\le 1\\,000,\\sum N\\le 2\\,000,F[i]=i-1$ | $5$ |\n| 6 | $N\\le 1\\,000,\\sum N\\le 2\\,000$ | $11$ |\n| 7 | $M=1,F[i]=i-1$ | $9$ |\n| 8 | $M=1$ | $11$ |\n| 9 | $F[i]=i-1$ | $9$ |\n| 10 | 没有额外的约束条件 | $16$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[APIO2024] 九月", "background": "## 请勿使用 C++14(GCC9) 提交\n\n你无需在程序开头引入库 `september.h`。", "description": "杭州市的中心广场有一棵著名的古树。这棵古树可以看作一棵 $N$ 个节点的有根树，节点编号从 $0$ 到 $N - 1$，其中 $0$ 号节点是根节点。\n\n称没有孩子的节点为叶子节点。古树每次落叶时，会选择一个当前的叶子节点删去。每一天中，古树可能会多次落叶。\n\n有 $M$ 位志愿者（编号从 $0$ 到 $M - 1$）负责看护古树。每一位志愿者将各自按照如下方式独立记录今年的落叶的情况：\n\n每一天，收集所有新的落叶的编号（即当天删除的节点的编号），然后将它们按任意顺序写在先前的落叶编号之后。\n\n例如：第一天，叶子 $3$ 和 $4$ 落下，于是他们写下 $3, 4$ 或 $4, 3$。第二天，叶子 $1$ 和 $2$ 落下，于是他们继续写下 $1, 2$ 或 $2, 1$。最终的记录可能为 $(3, 4, 1, 2)$，$(4, 3, 1, 2)$，$(3, 4, 2, 1)$ 或 $(4, 3, 2, 1)$ 中的任意一个。\n\n这个过程持续了 $K$ 天，每天都有新的叶子掉落，直到只剩根节点为止。\n\n你在旅途过程中经过了杭州。此刻已是寒冬，仰望古树光秃秃的枝干，你不禁想起落叶纷飞的美丽景象。\n\n你很想知道今年有几天能看见落叶，但你只能找到 $M$ 位志愿者的记录。尝试根据这些记录推断出 $K$ 可能的最大值。\n\n### 交互方式\n\n你只需要实现以下函数：\n\n```cpp\nint solve(int N, int M, std::vector<int> F,\n            std::vector<std::vector<int>> S);\n```\n\n+   $N$：古树的节点数量。\n+   $M$：志愿者的数量。\n+   $F$：一个长度为 $N$ 的数组。对于 $1 \\le i \\le N - 1$，$F[i]$ 表示节点 $i$ 的父亲节点的编号。$F[0]$ 始终为 $-1$。\n+   $S$：一个长度为 $M$ 的数组。$S$ 中的每个元素是一个长度为 $N - 1$ 的数组。$S[i][j]$ 表示志愿者 $i$ 记录的第 $j$ 个节点编号（从 $0$ 开始）。\n+   该函数必须返回一个整数，表示根据如上规则的 $K$ 可能的最大值（即，最大可能的落叶天数）。\n+   对于每个测试点，交互库可能调用该函数多于一次。每次调用都应该作为新的情况分别处理。\n\n注意：由于函数调用可能会发生多次，选手需要注意之前调用的残余数据对于后续调用的影响，尤其是全局变量的状态。", "inputFormat": "评测程序示例读取如下格式的输入：\n\n+   第 1 行：$T$\n\n对于接下来 $T$ 组数据中的每一组：\n\n+   第 $1$ 行：$N\\ M$\n+   第 $2$ 行：$F[1]\\ F[2]\\ \\ldots\\  F[N - 1]$\n+   第 $3 + i\\ (0 \\le i \\le M - 1)$ 行：$S[i][0]\\ S[i][1]\\ S[i][2]\\ \\ldots\\ S[i][N - 2]$", "outputFormat": "评测程序示例按照如下格式打印你的答案：\n\n对于每组测试数据：\n\n+   第 1 行：函数 `solve` 的返回值", "hint": "### 样例解释\n\n对于样例一，考虑如下调用：\n\n```cpp\nsolve(3, 1, {-1, 0, 0}, {{1, 2}});\n```\n\n对应的树如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i2lup6cf.png)\n\n叶子 $1$ 和 $2$ 可能在同一天落下，或者叶子 $1$ 在第一天先落下，然后叶子 $2$ 在第二天落下。落叶天数不超过 $2$。\n\n因此，程序应当返回 $2$。\n\n对于样例二，考虑如下调用：\n\n```cpp\nsolve(5, 2, {-1, 0, 0, 1, 1}, {{1, 2, 3, 4}, {4, 1, 2, 3}});\n```\n\n对应的树如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l50142xn.png)\n\n假设至少有 $2$ 天落叶，根据志愿者的记录，叶子 $4$ 将在不同的日子（第一天和最后一天）落下，这是矛盾的。\n\n因此，程序应当返回 $1$。\n\n### 数据范围\n\n+   $2 \\le N \\le 10^5$\n+   $1 \\le M \\le 5$\n+   $\\sum NM \\le 8 \\times 10^5$\n+   $F[0] = -1$ 且对于 $1 \\le i \\le N - 1$, $0 \\le F[i] \\le i - 1$\n+   对于 $1 \\le i \\le M - 1$, 数组 $S[i]$ 是一个 $1, 2, \\ldots , N - 1$ 的排列\n+   保证 $F$ 描述的是一棵以节点 $0$ 为根的有根树\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :---: | :---: |\n| 1 | $M=1,N\\le 10,\\sum N\\le 30$ | $11$ |\n| 2 | $N\\le 10,\\sum N\\le 30$ | $14$ |\n| 3 | $M=1,N\\le 1\\,000,\\sum N\\le 2\\,000,F[i]=i-1$ | $5$ |\n| 4 | $M=1,N\\le 1\\,000,\\sum N\\le 2\\,000$ | $9$ |\n| 5 | $N\\le 1\\,000,\\sum N\\le 2\\,000,F[i]=i-1$ | $5$ |\n| 6 | $N\\le 1\\,000,\\sum N\\le 2\\,000$ | $11$ |\n| 7 | $M=1,F[i]=i-1$ | $9$ |\n| 8 | $M=1$ | $11$ |\n| 9 | $F[i]=i-1$ | $9$ |\n| 10 | 没有额外的约束条件 | $16$ |", "locale": "zh-CN"}}}
{"pid": "P10538", "type": "P", "difficulty": 6, "samples": [["3 3 1 \n20 30 40\n0 1 1 15 10\n1 2 20 30 5\n0 2 18 40 40\n16 19", "40"], ["3 5 6\n30 38 33\n0 2 12 16 38\n1 0 48 50 6\n0 1 26 28 23\n0 2 6 7 94\n1 2 49 54 50\n32 36\n14 14\n42 45\n37 40\n2 5\n4 5", "197"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["动态规划 DP", "2024", "APIO", "交互题", "动态规划优化"], "title": "[APIO2024] 星际列车", "background": null, "description": "**请勿使用 C++14 (GCC 9) 提交。**\n\n在 2992 年，机器人已经取代了人类的大部分工作，大家都有着大量的空闲时间。因此你和家人决定利用这些时间来一场星际旅行。\n\n有 $N$ 个人类已经可以到达的行星，编号为 $0$ 到 $N - 1$，以及 $M$ 种不同的星际列车路线。第 $i$ 种列车路线 ($0 \\le i < M$) 在时间 $A[i]$ 从行星 $X[i]$ 出发，在时间 $B[i]$ 到达行星 $Y[i]$，票价为 $C[i]$。在行星之间，这些星际列车是仅有的交通方式。对于你搭乘的一列星际列车，你只能在它的终点站下车，并且你搭乘的下一趟列车的起点站必须和这趟列车的终点站相同（这里认为换乘不耗时）。形式化地，你可以依次乘坐第 $q[0], q[1], \\ldots, q[P]$ 次列车，当且仅当对任意 $1 \\le k \\le P$ 都有 $Y[q[k - 1]] = X[q[k]]$，$B[q[k - 1]] \\le A[q[k]]$。\n\n在不同行星之间移动是非常耗时的，所以除了车票钱，餐费支出也不可忽视。列车上免费提供不限量的食物，也就是在列车上吃饭不花钱：如果你决定乘坐第 $i$ 种星际列车，则在任何 $A[i]$ 到 $B[i]$ 之间的时刻（包括端点）你都可以免费吃任意多顿饭。但如果你决定在行星 $i$ 吃饭，每顿饭都需要 $T[i]$ 元。\n\n你和家人在旅途中总共需要吃 $W$ 顿饭，第 $i\\ (0 \\le i < W)$ 顿饭可以在 $L[i]$ 到 $R[i]$（包括端点）的任何时刻吃，吃饭不耗费时间。吃饭没有顺序要求，例如允许在吃完第 $1$ 顿饭后再吃第 $0$ 顿饭（见样例 $2$）。\n\n现在是 $0$ 时刻，你和家人正在 $0$ 号行星上。你需要求出到达 $N - 1$ 号行星的最小花费，花费定义为车票价格和餐费之和。如果无法到达 $N - 1$ 号行星，最小花费定义为 $-1$。\n\n### 实现细节\n\n你无需在程序开头引入库 `train.h`。\n\n你只需要实现以下函数：\n\n```cpp\nlong long solve(int N, int M, int W, std::vector<int> T,\n                std::vector<int> X, std::vector<int> Y,\n                std::vector<int> A, std::vector<int> B, std::vector<int> C,\n                std::vector<int> L, std::vector<int> R);\n```\n\n+   $N$：行星数量。\n+  $ M$：星际列车路线数量。\n+   $W$：需要用餐的次数。\n+   $T$：一个长度为 $N$ 的数组。$T[i]$ 表示在行星 $i$ 每次用餐的花费。\n+   $X, Y, A, B, C$：五个长为 $M$ 的数组。$(X[i], Y[i], A[i], B[i], C[i])$ 描述了第 $i$ 条列车路线。\n+   $L, R$：两个长为 $W$ 的数组。$(L[i], R[i])$ 描述了第 $i$ 顿饭的用餐时间。\n+   你需要返回从行星 $0$ 到达行星 $N - 1$ 的最小花费。如果行星 $N - 1$ 不可达，返回 $-1$。\n+   每个测试点中，该函数恰好被调用一次。", "inputFormat": "评测程序示例读取如下格式的输入：\n\n+   第 $1$ 行：$N\\ M\\ W$\n+   第 $2$ 行：$T[0]\\ T[1]\\ T[2]\\ \\ldots\\ T[N - 1]$\n+   第 $3 + i\\ (0 \\le i < M)$ 行：$X[i]\\ Y[i]\\ A[i]\\ B[i]\\ C[i]$\n+   第 $3 + M + i\\ (0 \\le i < W)$ 行：$L[i]\\ R[i]$", "outputFormat": "评测程序示例按照如下格式打印你的答案：\n\n+   第 $1$ 行：函数 `solve` 的返回值", "hint": "### 样例解释\n\n对于样例一，考虑如下调用：\n\n```cpp\nsolve(3, 3, 1, {20, 30, 40}, {0, 1, 0}, {1, 2, 2},\n        {1, 20, 18}, {15, 30, 40}, {10, 5, 40}, {16}, {19});\n```\n\n一种可行的方案是依次乘坐第 $0, 1$ 次列车，花费为 $45$，具体流程如下：\n\n| 时刻 | 你的行动 | 花费 |\n| :---: | :---: | :---: |\n| $1$ | 乘坐第 $0$ 次列车从 $0$ 号行星出发 | $10$ |\n| $15$ | 到达 $1$ 号行星 |  |\n| $16$ | 在 $1$ 号行星吃第 $0$ 顿饭 | $30$ |\n| $20$ | 乘坐第 $1$ 次列车从 $1$ 号行星出发 | $5$ |\n| $30$ | 到达 $2$ 号行星 |  |\n\n一种更优的方案是乘坐第 $2$ 次列车，花费为 $40$，具体流程如下：\n\n| 时刻 | 你的行动 | 花费 |\n| :---: | :---: | :---: |\n| $18$ | 乘坐第 $2$ 次列车从 $0$ 号行星出发 | $40$ |\n| $19$ | 在第 $2$ 次列车上吃第 $0$ 顿饭 |  |\n| $40$ | 到达 $2$ 号行星 |  |\n\n在这种方案中，在时刻 $18$ 在第 $2$ 次列车上吃第 $0$ 顿饭也是合法的。\n\n因此函数应该返回 $40$。\n\n对于样例二，考虑如下调用：\n\n```cpp\nsolve(3, 5, 6, {30, 38, 33}, {0, 1, 0, 0, 1}, {2, 0, 1, 2, 2},\n        {12, 48, 26, 6, 49}, {16, 50, 28, 7, 54}, {38, 6, 23, 94, 50},\n        {32, 14, 42, 37, 2, 4}, {36, 14, 45, 40, 5, 5});\n```\n\n最优解是：乘坐第 $0$ 次列车，车费为 $38$。在第 $0$ 次列车上免费吃第 $1$ 顿饭。第 $0, 2, 3$ 顿饭在行星 $2$ 上吃 ，花费 $33 \\times 3 = 99$。 第 $4, 5$ 顿饭在行星 $0$ 上吃，花费 $30 \\times 2 = 60$。总花费为 $38 + 99 + 60 = 197$。\n\n因此函数应该返回 $197$。\n\n### 数据范围\n\n+   $2 \\le N \\le 10^5$\n+   $0 \\le M, W \\le 10^5$\n+   $0 \\le X[i], Y [i] < N, X[i] \\neq Y[i]$\n+   $1 \\le A[i] < B[i] \\le 10^9$\n+   $1 \\le T[i], C[i] \\le 10^9$\n+   $1 \\le L[i] \\le R[i] \\le 10^9$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :---: | :---: |\n| $1$ | $N, M, A[i], B[i], L[i], R[i] \\le 10^3, W \\le 10$ | $5$ |\n| $2$ | $W = 0$ | $5$\n| $3$ | 每顿饭的用餐时间两两不交。形式化地，对于任何时刻 $z$ 满足 $1 \\le z \\le 10^9$，至多存在一个 $i\\ (0 \\le i < W)$ 使得 $L[i] \\le z \\le R[i]$。 | $30$ |\n| $4$ | 没有额外的约束条件 | $60$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[APIO2024] 星际列车", "background": null, "description": "**请勿使用 C++14 (GCC 9) 提交。**\n\n在 2992 年，机器人已经取代了人类的大部分工作，大家都有着大量的空闲时间。因此你和家人决定利用这些时间来一场星际旅行。\n\n有 $N$ 个人类已经可以到达的行星，编号为 $0$ 到 $N - 1$，以及 $M$ 种不同的星际列车路线。第 $i$ 种列车路线 ($0 \\le i < M$) 在时间 $A[i]$ 从行星 $X[i]$ 出发，在时间 $B[i]$ 到达行星 $Y[i]$，票价为 $C[i]$。在行星之间，这些星际列车是仅有的交通方式。对于你搭乘的一列星际列车，你只能在它的终点站下车，并且你搭乘的下一趟列车的起点站必须和这趟列车的终点站相同（这里认为换乘不耗时）。形式化地，你可以依次乘坐第 $q[0], q[1], \\ldots, q[P]$ 次列车，当且仅当对任意 $1 \\le k \\le P$ 都有 $Y[q[k - 1]] = X[q[k]]$，$B[q[k - 1]] \\le A[q[k]]$。\n\n在不同行星之间移动是非常耗时的，所以除了车票钱，餐费支出也不可忽视。列车上免费提供不限量的食物，也就是在列车上吃饭不花钱：如果你决定乘坐第 $i$ 种星际列车，则在任何 $A[i]$ 到 $B[i]$ 之间的时刻（包括端点）你都可以免费吃任意多顿饭。但如果你决定在行星 $i$ 吃饭，每顿饭都需要 $T[i]$ 元。\n\n你和家人在旅途中总共需要吃 $W$ 顿饭，第 $i\\ (0 \\le i < W)$ 顿饭可以在 $L[i]$ 到 $R[i]$（包括端点）的任何时刻吃，吃饭不耗费时间。吃饭没有顺序要求，例如允许在吃完第 $1$ 顿饭后再吃第 $0$ 顿饭（见样例 $2$）。\n\n现在是 $0$ 时刻，你和家人正在 $0$ 号行星上。你需要求出到达 $N - 1$ 号行星的最小花费，花费定义为车票价格和餐费之和。如果无法到达 $N - 1$ 号行星，最小花费定义为 $-1$。\n\n### 实现细节\n\n你无需在程序开头引入库 `train.h`。\n\n你只需要实现以下函数：\n\n```cpp\nlong long solve(int N, int M, int W, std::vector<int> T,\n                std::vector<int> X, std::vector<int> Y,\n                std::vector<int> A, std::vector<int> B, std::vector<int> C,\n                std::vector<int> L, std::vector<int> R);\n```\n\n+   $N$：行星数量。\n+  $ M$：星际列车路线数量。\n+   $W$：需要用餐的次数。\n+   $T$：一个长度为 $N$ 的数组。$T[i]$ 表示在行星 $i$ 每次用餐的花费。\n+   $X, Y, A, B, C$：五个长为 $M$ 的数组。$(X[i], Y[i], A[i], B[i], C[i])$ 描述了第 $i$ 条列车路线。\n+   $L, R$：两个长为 $W$ 的数组。$(L[i], R[i])$ 描述了第 $i$ 顿饭的用餐时间。\n+   你需要返回从行星 $0$ 到达行星 $N - 1$ 的最小花费。如果行星 $N - 1$ 不可达，返回 $-1$。\n+   每个测试点中，该函数恰好被调用一次。", "inputFormat": "评测程序示例读取如下格式的输入：\n\n+   第 $1$ 行：$N\\ M\\ W$\n+   第 $2$ 行：$T[0]\\ T[1]\\ T[2]\\ \\ldots\\ T[N - 1]$\n+   第 $3 + i\\ (0 \\le i < M)$ 行：$X[i]\\ Y[i]\\ A[i]\\ B[i]\\ C[i]$\n+   第 $3 + M + i\\ (0 \\le i < W)$ 行：$L[i]\\ R[i]$", "outputFormat": "评测程序示例按照如下格式打印你的答案：\n\n+   第 $1$ 行：函数 `solve` 的返回值", "hint": "### 样例解释\n\n对于样例一，考虑如下调用：\n\n```cpp\nsolve(3, 3, 1, {20, 30, 40}, {0, 1, 0}, {1, 2, 2},\n        {1, 20, 18}, {15, 30, 40}, {10, 5, 40}, {16}, {19});\n```\n\n一种可行的方案是依次乘坐第 $0, 1$ 次列车，花费为 $45$，具体流程如下：\n\n| 时刻 | 你的行动 | 花费 |\n| :---: | :---: | :---: |\n| $1$ | 乘坐第 $0$ 次列车从 $0$ 号行星出发 | $10$ |\n| $15$ | 到达 $1$ 号行星 |  |\n| $16$ | 在 $1$ 号行星吃第 $0$ 顿饭 | $30$ |\n| $20$ | 乘坐第 $1$ 次列车从 $1$ 号行星出发 | $5$ |\n| $30$ | 到达 $2$ 号行星 |  |\n\n一种更优的方案是乘坐第 $2$ 次列车，花费为 $40$，具体流程如下：\n\n| 时刻 | 你的行动 | 花费 |\n| :---: | :---: | :---: |\n| $18$ | 乘坐第 $2$ 次列车从 $0$ 号行星出发 | $40$ |\n| $19$ | 在第 $2$ 次列车上吃第 $0$ 顿饭 |  |\n| $40$ | 到达 $2$ 号行星 |  |\n\n在这种方案中，在时刻 $18$ 在第 $2$ 次列车上吃第 $0$ 顿饭也是合法的。\n\n因此函数应该返回 $40$。\n\n对于样例二，考虑如下调用：\n\n```cpp\nsolve(3, 5, 6, {30, 38, 33}, {0, 1, 0, 0, 1}, {2, 0, 1, 2, 2},\n        {12, 48, 26, 6, 49}, {16, 50, 28, 7, 54}, {38, 6, 23, 94, 50},\n        {32, 14, 42, 37, 2, 4}, {36, 14, 45, 40, 5, 5});\n```\n\n最优解是：乘坐第 $0$ 次列车，车费为 $38$。在第 $0$ 次列车上免费吃第 $1$ 顿饭。第 $0, 2, 3$ 顿饭在行星 $2$ 上吃 ，花费 $33 \\times 3 = 99$。 第 $4, 5$ 顿饭在行星 $0$ 上吃，花费 $30 \\times 2 = 60$。总花费为 $38 + 99 + 60 = 197$。\n\n因此函数应该返回 $197$。\n\n### 数据范围\n\n+   $2 \\le N \\le 10^5$\n+   $0 \\le M, W \\le 10^5$\n+   $0 \\le X[i], Y [i] < N, X[i] \\neq Y[i]$\n+   $1 \\le A[i] < B[i] \\le 10^9$\n+   $1 \\le T[i], C[i] \\le 10^9$\n+   $1 \\le L[i] \\le R[i] \\le 10^9$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :---: | :---: |\n| $1$ | $N, M, A[i], B[i], L[i], R[i] \\le 10^3, W \\le 10$ | $5$ |\n| $2$ | $W = 0$ | $5$\n| $3$ | 每顿饭的用餐时间两两不交。形式化地，对于任何时刻 $z$ 满足 $1 \\le z \\le 10^9$，至多存在一个 $i\\ (0 \\le i < W)$ 使得 $L[i] \\le z \\le R[i]$。 | $30$ |\n| $4$ | 没有额外的约束条件 | $60$ |", "locale": "zh-CN"}}}
{"pid": "P10539", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "APIO", "交互题", "Special Judge", "通信题"], "title": "[APIO2024] 魔术表演", "background": "在洛谷上提交时，只需要提交一个文件。\n\n不要引入 `alice.h` 和 `bob.h`。在文件头加入以下内容：\n\n```cpp\nlong long setN(int n);\n```\n\n只支持 C++17 / C++20 提交。", "description": "Alice 和 Bob 是著名的魔术师。Catherine 是一位富豪，她非常喜欢观看 Alice 和 Bob 的魔术。某一天，Catherine 决定向 Alice 和 Bob 发出挑战：只要他们能成功表演如下的魔术，Catherine 就将向他们提供巨额奖金！这个魔术的表演过程如下：\n\n- 步骤 $1$：Bob 进⼊⼀个密室中，在魔术的全程中，他只能与 Catherine 交流。接下来，Alice 告诉 Catherine ⼀个在 $2$ 到 $5000$ 之间的整数 $n$。\n- 步骤 $2$：Catherine 告诉 Alice ⼀个在 $1$ 到 $10^{18}$ 之间的整数 $X$。\n- 步骤 $3$：Alice 生成⼀个具有 $n$ 个节点的树，并告诉 Catherine。\n- 步骤 $4$：Catherine 删除树中的⼀些边（至多 $\\left\\lfloor\\dfrac{n-2}{2}\\right\\rfloor$ 条），并将剩余的边告诉 Bob。\n- 步骤 $5$：Bob 根据 Catherine 给出的信息，猜出 Catherine 告诉 Alice 的数是多少。\n\n然⽽，Alice 和 Bob 被这个魔术难倒了，于是他们不得不寻求你的帮助。请你写一段程序，实现 Alice 和 Bob 的策略，以帮助他们赢得 Catherine 的挑战。\n\n通信方式：\n\n你需要实现两个函数\n\n1. `std::vector<std::pair<int, int>> Alice();`\n- 对于每组测试数据，这个函数只会被调用⼀次。\n- 函数应当返回⼀个含有 `pair<int, int>` 类型的 `vector`，表示 Alice 在魔术的步骤 3 中生成的树的边集。\n  - 注意树中的节点应当从 1 开始编号。\n  - 你需要确保函数返回的树是符合规范的，也就是说，树中应当恰好包含 n − 1 条边，且所有节点彼此连通。\n  \n函数 `Alice()` 应当调用如下函数**恰好⼀次**：\n\n`long long setN(int n);`\n\n- 这个函数表示，在魔术的步骤 1 中，Alice 选择⼀个数 $n$ 告诉 Catherine。\n- 函数返回⼀个数 $X$，表示 Catherine 在魔术的步骤 2 中告诉 Alice 的数。\n---\n2. `long long Bob(std::vector<std::pair<int, int>> V);`\n\n- 对于每组测试数据，这个函数只会被调用⼀次，且⼀定是在调用 `Alice()` 之后。\n- $V$ 表⽰在魔术的步骤 4 中，Catherine 告诉 Bob 的边集。\n- 上述边集是有序的，具体而言：\n  - 对于⼀条边的两个端点而言，编号较⼩的端点靠前；\n  - 所有的边按照第⼀个端点为第⼀关键字、第⼆个端点为第⼆关键字的顺序升序排序。\n- 函数应当返回⼀个整数 $X$，表⽰ Bob 在魔术的步骤 5 中给出的回答。", "inputFormat": "无", "outputFormat": "无", "hint": "### 例子\n\n考虑下面的调用：\n调用函数| 返回值\n:-:|:-:\n`Alice()`|\n`setN(4)`| $3$\n||$\\{\\{1, 2\\}, \\{2, 3\\}, \\{2, 4\\}\\}$\n`Bob({{1,2},{2,4}})`| $3$\n该样例代表了以下场景：\n- 步骤 1：最开始，Alice 将数字 $4$ 告诉 Catherine。\n- 步骤 2：Catherine 将数字 $3$ 告诉 Alice。\n- 步骤 3：Alice 生成了⼀棵具有 $4$ 个节点的树，其边集为 $\\{\\{1, 2\\}, \\{2, 3\\}, \\{2, 4\\}\\}$，将这棵树告诉 Catherine。\n- 步骤 4：Catherine 删去了树中连接节点 $2$ 和 $3$ 的边，并把剩余的边 $\\{\\{1, 2\\}, \\{2, 4\\}\\}$ 告诉 Bob。\n- 步骤 5：Bob 给出数字 $3$ 作为回答。由于他给出了正确答案，他们的魔术表演⼤获成功。\n\n\n### 子任务\n\n1. (5 分)：$X\\leq 5, 000$。\n2. (30 分)：$X\\leq25, 000, 000$。\n3. (65 分)：没有特殊限制。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[APIO2024] 魔术表演", "background": "在洛谷上提交时，只需要提交一个文件。\n\n不要引入 `alice.h` 和 `bob.h`。在文件头加入以下内容：\n\n```cpp\nlong long setN(int n);\n```\n\n只支持 C++17 / C++20 提交。", "description": "Alice 和 Bob 是著名的魔术师。Catherine 是一位富豪，她非常喜欢观看 Alice 和 Bob 的魔术。某一天，Catherine 决定向 Alice 和 Bob 发出挑战：只要他们能成功表演如下的魔术，Catherine 就将向他们提供巨额奖金！这个魔术的表演过程如下：\n\n- 步骤 $1$：Bob 进⼊⼀个密室中，在魔术的全程中，他只能与 Catherine 交流。接下来，Alice 告诉 Catherine ⼀个在 $2$ 到 $5000$ 之间的整数 $n$。\n- 步骤 $2$：Catherine 告诉 Alice ⼀个在 $1$ 到 $10^{18}$ 之间的整数 $X$。\n- 步骤 $3$：Alice 生成⼀个具有 $n$ 个节点的树，并告诉 Catherine。\n- 步骤 $4$：Catherine 删除树中的⼀些边（至多 $\\left\\lfloor\\dfrac{n-2}{2}\\right\\rfloor$ 条），并将剩余的边告诉 Bob。\n- 步骤 $5$：Bob 根据 Catherine 给出的信息，猜出 Catherine 告诉 Alice 的数是多少。\n\n然⽽，Alice 和 Bob 被这个魔术难倒了，于是他们不得不寻求你的帮助。请你写一段程序，实现 Alice 和 Bob 的策略，以帮助他们赢得 Catherine 的挑战。\n\n通信方式：\n\n你需要实现两个函数\n\n1. `std::vector<std::pair<int, int>> Alice();`\n- 对于每组测试数据，这个函数只会被调用⼀次。\n- 函数应当返回⼀个含有 `pair<int, int>` 类型的 `vector`，表示 Alice 在魔术的步骤 3 中生成的树的边集。\n  - 注意树中的节点应当从 1 开始编号。\n  - 你需要确保函数返回的树是符合规范的，也就是说，树中应当恰好包含 n − 1 条边，且所有节点彼此连通。\n  \n函数 `Alice()` 应当调用如下函数**恰好⼀次**：\n\n`long long setN(int n);`\n\n- 这个函数表示，在魔术的步骤 1 中，Alice 选择⼀个数 $n$ 告诉 Catherine。\n- 函数返回⼀个数 $X$，表示 Catherine 在魔术的步骤 2 中告诉 Alice 的数。\n---\n2. `long long Bob(std::vector<std::pair<int, int>> V);`\n\n- 对于每组测试数据，这个函数只会被调用⼀次，且⼀定是在调用 `Alice()` 之后。\n- $V$ 表⽰在魔术的步骤 4 中，Catherine 告诉 Bob 的边集。\n- 上述边集是有序的，具体而言：\n  - 对于⼀条边的两个端点而言，编号较⼩的端点靠前；\n  - 所有的边按照第⼀个端点为第⼀关键字、第⼆个端点为第⼆关键字的顺序升序排序。\n- 函数应当返回⼀个整数 $X$，表⽰ Bob 在魔术的步骤 5 中给出的回答。", "inputFormat": "无", "outputFormat": "无", "hint": "### 例子\n\n考虑下面的调用：\n调用函数| 返回值\n:-:|:-:\n`Alice()`|\n`setN(4)`| $3$\n||$\\{\\{1, 2\\}, \\{2, 3\\}, \\{2, 4\\}\\}$\n`Bob({{1,2},{2,4}})`| $3$\n该样例代表了以下场景：\n- 步骤 1：最开始，Alice 将数字 $4$ 告诉 Catherine。\n- 步骤 2：Catherine 将数字 $3$ 告诉 Alice。\n- 步骤 3：Alice 生成了⼀棵具有 $4$ 个节点的树，其边集为 $\\{\\{1, 2\\}, \\{2, 3\\}, \\{2, 4\\}\\}$，将这棵树告诉 Catherine。\n- 步骤 4：Catherine 删去了树中连接节点 $2$ 和 $3$ 的边，并把剩余的边 $\\{\\{1, 2\\}, \\{2, 4\\}\\}$ 告诉 Bob。\n- 步骤 5：Bob 给出数字 $3$ 作为回答。由于他给出了正确答案，他们的魔术表演⼤获成功。\n\n\n### 子任务\n\n1. (5 分)：$X\\leq 5, 000$。\n2. (30 分)：$X\\leq25, 000, 000$。\n3. (65 分)：没有特殊限制。\n", "locale": "zh-CN"}}}
{"pid": "P10540", "type": "P", "difficulty": 7, "samples": [["6 5\n6 4\n2 6\n5 -5\n3 6\n1 2\n3 6\n1 6\n1 6\n2 6\n2 6\n5 6\n", "19\n19\n15\n15\n8\n"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 决赛] 古明地枣的袜子", "background": "", "description": "你需要维护一个序列 $a_1,\\dots,a_n$ 。\n\n给定一个操作序列 $(x_1,y_1),\\dots,(x_n,y_n)$ ，操作 $(x,y)$ 表示将 $a_1,\\dots,a_x$ 的值加上 $y$ 。\n\n共 $m$ 次查询，每次查询给出 $l,r$ ，问对初始值为 $0$ 的序列 $a$ 依次执行操作 $(x_l,y_l),\\dots,(x_r,y_r)$ ，最后 $\\max\\limits_{i=1}^n a_i$ 的值。", "inputFormat": "第一行两个整数 $n,m$ （$1\\le n,m\\le 5\\times 10^5$）；\n\n接下来 $n$ 行每行两个整数 $x_i,y_i$（$1\\le x_i\\le n, |y_i|\\le n$）；\n\n接下来 $m$ 行，每行两个整数 $l,r$（$1\\le l\\le r\\le n$）。", "outputFormat": "输出 $m$ 行，每行一个整数，表示每次查询的答案。\n\n", "hint": "**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 古明地枣的袜子", "background": "", "description": "你需要维护一个序列 $a_1,\\dots,a_n$ 。\n\n给定一个操作序列 $(x_1,y_1),\\dots,(x_n,y_n)$ ，操作 $(x,y)$ 表示将 $a_1,\\dots,a_x$ 的值加上 $y$ 。\n\n共 $m$ 次查询，每次查询给出 $l,r$ ，问对初始值为 $0$ 的序列 $a$ 依次执行操作 $(x_l,y_l),\\dots,(x_r,y_r)$ ，最后 $\\max\\limits_{i=1}^n a_i$ 的值。", "inputFormat": "第一行两个整数 $n,m$ （$1\\le n,m\\le 5\\times 10^5$）；\n\n接下来 $n$ 行每行两个整数 $x_i,y_i$（$1\\le x_i\\le n, |y_i|\\le n$）；\n\n接下来 $m$ 行，每行两个整数 $l,r$（$1\\le l\\le r\\le n$）。", "outputFormat": "输出 $m$ 行，每行一个整数，表示每次查询的答案。\n\n", "hint": "**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10541", "type": "P", "difficulty": 6, "samples": [["4 5 5 3\n2 10 6 7\n1 7 5 3\n2 2 3 8 8\n1 1\n2 2\n2 3\n3 4\n4 5\n1 2\n2 3\n3 4", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2024", "网络流", "图论建模", "THUPC"], "title": "[THUPC 2024 决赛] 研发计划", "background": "", "description": "看到近期若干家大模型创业公司获得高额融资，作为炼丹大师的你心痒难耐，决定入局，亲自下场搞产品。\n\n经过一段时间的梳理，你发现当前共有 $m$ 种产品推出后将会大卖，其中第 $i$ 个产品推出之后预期获得 $g_i$ 的收益。这 $m$ 种产品涉及 $n$ 种技术：共有 $p$ 条技术-产品依赖关系 $(u,v)$ ，表示第 $u$ 个技术是第 $v$ 个产品的前置技术。对于每个产品，你必须获得它的全部前置技术之后才能推出。\n\n对于第 $j$ 个技术，你可以选择花费 $f_j$ 的代价直接从其他公司购买获得，或者花费 $h_j$ 的代价通过研发获得。研发需要一定的条件：给出 $q$ 条技术-技术依赖关系 $(a,b)$ ，表示第 $a$ 个技术是第 $b$ 个技术的前置技术，那么必须在获得了技术 $j$ 的所有前置技术后才能通过研发获得技术 $j$ 。若某个技术没有前置技术，那么你可以直接通过研发获得。保证技术-技术依赖关系构成一个有向无环图，即不会发生循环依赖（自然不会有自环）。\n\n一个方案的收益为推出的产品的收益总和减去获得的技术的代价总和。现在，作为一个商人，你希望研究一些技术、推出一些产品，最大化你获得的收益。为简单起见，你只要输出最大的收益值。", "inputFormat": "输入的第一行包含四个正整数 $n,m,p,q$，保证 $2 \\le n \\le 100, 1 \\le m \\le 100, 1 \\le p\\leq nm, 1 \\le q\\leq \\frac{n(n-1)}{2}$ ，分别表示技术总数、产品总数、技术-产品依赖关系总数以及技术-技术依赖关系总数。\n\n接下来一行 $n$ 个整数 $f_i$ ，表示直接购买第 $i$ 个技术的代价。\n\n接下来一行 $n$ 个整数 $h_i$ ，表示在前置技术基础上研究第 $i$ 个技术的代价。\n\n接下来一行 $m$ 个整数 $g_i$，表示第 $i$ 个产品推出之后获得的收益。\n\n接下来 $p$ 行，第 $i$ 行两个整数 $u_i,v_i$ ，表示技术-产品依赖关系 $(u_i,v_i)$，保证 $1 \\le u_i \\le n$，$1 \\le v_i \\le m$，输入的所有 $(u_i,v_i)$ 两两不同。\n\n接下来 $q$ 行，第 $i$ 行两个整数 $a_i,b_i$ ，表示技术-技术依赖关系 $(a_i,b_i)$，保证 $1 \\le a_i \\ne b_i \\le n$，输入的所有 $(a_i,b_i)$ 两两不同，且不构成循环依赖。\n\n保证所有输入数字均为不超过 $10^9$ 的非负整数。", "outputFormat": "输出一个整数表示收益最大方案的收益。\n", "hint": "最优方案是依次研究技术 1，购买技术 3，研究技术 4，这时我们就能推出产品 1、4、5 了。此时收益为 $(2+8+8)-(1+6+3)=8$。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 研发计划", "background": "", "description": "看到近期若干家大模型创业公司获得高额融资，作为炼丹大师的你心痒难耐，决定入局，亲自下场搞产品。\n\n经过一段时间的梳理，你发现当前共有 $m$ 种产品推出后将会大卖，其中第 $i$ 个产品推出之后预期获得 $g_i$ 的收益。这 $m$ 种产品涉及 $n$ 种技术：共有 $p$ 条技术-产品依赖关系 $(u,v)$ ，表示第 $u$ 个技术是第 $v$ 个产品的前置技术。对于每个产品，你必须获得它的全部前置技术之后才能推出。\n\n对于第 $j$ 个技术，你可以选择花费 $f_j$ 的代价直接从其他公司购买获得，或者花费 $h_j$ 的代价通过研发获得。研发需要一定的条件：给出 $q$ 条技术-技术依赖关系 $(a,b)$ ，表示第 $a$ 个技术是第 $b$ 个技术的前置技术，那么必须在获得了技术 $j$ 的所有前置技术后才能通过研发获得技术 $j$ 。若某个技术没有前置技术，那么你可以直接通过研发获得。保证技术-技术依赖关系构成一个有向无环图，即不会发生循环依赖（自然不会有自环）。\n\n一个方案的收益为推出的产品的收益总和减去获得的技术的代价总和。现在，作为一个商人，你希望研究一些技术、推出一些产品，最大化你获得的收益。为简单起见，你只要输出最大的收益值。", "inputFormat": "输入的第一行包含四个正整数 $n,m,p,q$，保证 $2 \\le n \\le 100, 1 \\le m \\le 100, 1 \\le p\\leq nm, 1 \\le q\\leq \\frac{n(n-1)}{2}$ ，分别表示技术总数、产品总数、技术-产品依赖关系总数以及技术-技术依赖关系总数。\n\n接下来一行 $n$ 个整数 $f_i$ ，表示直接购买第 $i$ 个技术的代价。\n\n接下来一行 $n$ 个整数 $h_i$ ，表示在前置技术基础上研究第 $i$ 个技术的代价。\n\n接下来一行 $m$ 个整数 $g_i$，表示第 $i$ 个产品推出之后获得的收益。\n\n接下来 $p$ 行，第 $i$ 行两个整数 $u_i,v_i$ ，表示技术-产品依赖关系 $(u_i,v_i)$，保证 $1 \\le u_i \\le n$，$1 \\le v_i \\le m$，输入的所有 $(u_i,v_i)$ 两两不同。\n\n接下来 $q$ 行，第 $i$ 行两个整数 $a_i,b_i$ ，表示技术-技术依赖关系 $(a_i,b_i)$，保证 $1 \\le a_i \\ne b_i \\le n$，输入的所有 $(a_i,b_i)$ 两两不同，且不构成循环依赖。\n\n保证所有输入数字均为不超过 $10^9$ 的非负整数。", "outputFormat": "输出一个整数表示收益最大方案的收益。\n", "hint": "最优方案是依次研究技术 1，购买技术 3，研究技术 4，这时我们就能推出产品 1、4、5 了。此时收益为 $(2+8+8)-(1+6+3)=8$。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10542", "type": "P", "difficulty": 5, "samples": [["4 1 2 2\n10 1\n2 1\n1 1\n1 2\n2 2\n2 2 1000000000\n", "1000000002\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 决赛] RPG", "background": "", "description": "小 I 正在打一款回合制 RPG 的最终 boss 战。这一战中，主角和 TA 的 $(n-1)$ 个队友（也就是总共 $n$ 个人）会按照固定的顺序依次行动，目标是对 boss 产生尽可能高的总伤害。\n\n游戏设定中共有 $x$ 种攻击模式，第 $i (1 \\le i \\le x)$ 种攻击模式会对 boss 产生 $d_i$ 的基础伤害。\n\n在行动过程中可以对 boss 附着异常状态。异常状态共 $y$ 种，同一时刻 boss 不会陷入两种异常状态。当 boss 陷入特定的异常状态时，使用特定的攻击模式会触发暴击，产生更大的伤害。暴击的规则由 $m$ 个三元组 $(p_j, q_j, c_j)$ 给出，表示在附着第 $p_j (1 \\le p_j \\le y)$ 种异常状态时使用第 $q_j (1 \\le q_j \\le x)$ 种攻击模式会**额外**产生 $c_j$ 的伤害。\n\n对战开始时，boss 没有陷入任何的异常状态。按照行动顺序，第 $i (1 \\le i \\le n)$ 个人可以进行以下三种行动：\n\n- 使用法术使 boss 陷入第 $a_i$ 种异常状态，若 boss 之前陷入了其他异常状态，则之前的异常状态被移除。\n- 使用第 $b_i$ 种攻击模式对 boss 进行攻击，无论是否触发暴击，在产生伤害之后 **boss 的异常状态被移除**。\n- 摸鱼，即什么都不做，此时 boss 的异常状态被保留。\n\n作为剧情党，小 I 自然是不想自己算最优策略，于是他把问题丢给了你。于是你需要求出 $n$ 次行动内总共能产生最多多少伤害。\n", "inputFormat": "输入的第一行四个整数 $n, m, x, y (1 \\le n, m, x, y \\le 2 \\times 10^5)$，分别表示行动次数、暴击规则数、攻击模式种类数和异常状态种类数。\n\n第二行 $x$ 个整数 $d_1,d_2,\\cdots,d_x (1 \\le d_i \\le 10^9)$，依次描述每种攻击模式对 boss 产生的基础伤害量。\n\n接下来 $n$ 行第 $i$ 行两个整数 $a_i, b_i (1 \\le a_i \\le y, 1 \\le b_i \\le x)$，按照行动次序描述第 $i$ 个人的行动。\n\n接下来 $m$ 行第 $j$ 行三个整数 $p_j, q_j, c_j (1 \\le p_j \\le y, 1 \\le q_j \\le x, 1 \\le c_j \\le 10^9)$，描述第 $j$ 条暴击规则。保证 $(p_j, q_j)$ 两两不同。", "outputFormat": "输出一行一个整数，表示 $n$ 次行动对 boss 产生的伤害量总和的最大值。\n", "hint": "样例中共有两种攻击模式和两种异常状态，其中第一种攻击模式会造成 $10$ 的基础伤害，第二种攻击模式会造成 $1$ 的基础伤害。暴击规则仅有一条：在第二种异常状态下进行第二种攻击会额外造成 $10^9$ 的伤害。\n\n最优的行动策略如下：\n\n- 第一个人使用法术使 boss 陷入第二种异常状态；\n- 第二个人摸鱼，boss 仍然陷入第二种异常状态；\n- 第三个人使用第二种攻击模式，产生 $1$ 的基础伤害和 $10^9$ 的暴击伤害，boss 的异常状态被清除；\n- 第四个人使用第二种攻击模式，产生 $1$ 的基础伤害。\n\n总伤害量为 $1 + 10^9 + 1 = 10^9+2$。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] RPG", "background": "", "description": "小 I 正在打一款回合制 RPG 的最终 boss 战。这一战中，主角和 TA 的 $(n-1)$ 个队友（也就是总共 $n$ 个人）会按照固定的顺序依次行动，目标是对 boss 产生尽可能高的总伤害。\n\n游戏设定中共有 $x$ 种攻击模式，第 $i (1 \\le i \\le x)$ 种攻击模式会对 boss 产生 $d_i$ 的基础伤害。\n\n在行动过程中可以对 boss 附着异常状态。异常状态共 $y$ 种，同一时刻 boss 不会陷入两种异常状态。当 boss 陷入特定的异常状态时，使用特定的攻击模式会触发暴击，产生更大的伤害。暴击的规则由 $m$ 个三元组 $(p_j, q_j, c_j)$ 给出，表示在附着第 $p_j (1 \\le p_j \\le y)$ 种异常状态时使用第 $q_j (1 \\le q_j \\le x)$ 种攻击模式会**额外**产生 $c_j$ 的伤害。\n\n对战开始时，boss 没有陷入任何的异常状态。按照行动顺序，第 $i (1 \\le i \\le n)$ 个人可以进行以下三种行动：\n\n- 使用法术使 boss 陷入第 $a_i$ 种异常状态，若 boss 之前陷入了其他异常状态，则之前的异常状态被移除。\n- 使用第 $b_i$ 种攻击模式对 boss 进行攻击，无论是否触发暴击，在产生伤害之后 **boss 的异常状态被移除**。\n- 摸鱼，即什么都不做，此时 boss 的异常状态被保留。\n\n作为剧情党，小 I 自然是不想自己算最优策略，于是他把问题丢给了你。于是你需要求出 $n$ 次行动内总共能产生最多多少伤害。\n", "inputFormat": "输入的第一行四个整数 $n, m, x, y (1 \\le n, m, x, y \\le 2 \\times 10^5)$，分别表示行动次数、暴击规则数、攻击模式种类数和异常状态种类数。\n\n第二行 $x$ 个整数 $d_1,d_2,\\cdots,d_x (1 \\le d_i \\le 10^9)$，依次描述每种攻击模式对 boss 产生的基础伤害量。\n\n接下来 $n$ 行第 $i$ 行两个整数 $a_i, b_i (1 \\le a_i \\le y, 1 \\le b_i \\le x)$，按照行动次序描述第 $i$ 个人的行动。\n\n接下来 $m$ 行第 $j$ 行三个整数 $p_j, q_j, c_j (1 \\le p_j \\le y, 1 \\le q_j \\le x, 1 \\le c_j \\le 10^9)$，描述第 $j$ 条暴击规则。保证 $(p_j, q_j)$ 两两不同。", "outputFormat": "输出一行一个整数，表示 $n$ 次行动对 boss 产生的伤害量总和的最大值。\n", "hint": "样例中共有两种攻击模式和两种异常状态，其中第一种攻击模式会造成 $10$ 的基础伤害，第二种攻击模式会造成 $1$ 的基础伤害。暴击规则仅有一条：在第二种异常状态下进行第二种攻击会额外造成 $10^9$ 的伤害。\n\n最优的行动策略如下：\n\n- 第一个人使用法术使 boss 陷入第二种异常状态；\n- 第二个人摸鱼，boss 仍然陷入第二种异常状态；\n- 第三个人使用第二种攻击模式，产生 $1$ 的基础伤害和 $10^9$ 的暴击伤害，boss 的异常状态被清除；\n- 第四个人使用第二种攻击模式，产生 $1$ 的基础伤害。\n\n总伤害量为 $1 + 10^9 + 1 = 10^9+2$。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10543", "type": "P", "difficulty": 4, "samples": [["2\n2 2\nWB\nWW\n2 2\nWW\nWW\n", "J\nI\n"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["博弈论", "2024", "广度优先搜索 BFS", "最短路", "THUPC"], "title": "[THUPC 2024 决赛] 黑白", "background": "", "description": "小 I 和小 J 又在玩游戏。\n\n游戏在一个 $n \\times m$ 的网格上进行，我们用二元组 $(x,y)$ 描述第 $x$ 行第 $y$ 列的格子，其中 $1 \\le x \\le n, 1 \\le y \\le m$。初始时，网格上有至少一个格子是白色的，其他格子是黑色的。\n\n小 I 和小 J 轮流操作，小 I 先手。每次操作时，操作方必须选择恰好一个白色的格子并将其染黑。\n\n称两个格子相邻当且仅当它们共用一条边。若某次操作后，格子 $(1,1)$ 不是白的，或者格子 $(n,m)$ 不是白的，或者无法从 $(1,1)$ 出发，每次经过相邻的白色格子，最终到达 $(n,m)$（即 $(1,1)$ 和 $(n,m)$ 不在同一个白色格子构成的四连通块内），则当前操作方输，另一方胜利。\n\n你作为游戏的观众，想知道在小 I 和小 J 绝顶聪明的情况下，谁会获胜。", "inputFormat": "**本题有多组测试数据。** 输入的第一行一个整数 $T (1 \\le T \\le 100)$ 表示测试数据组数，接下来依次输入每组测试数据。对于每组测试数据，\n\n- 第一行两个整数 $n, m (2 \\le n, m \\le 1000)$，表示网格的大小。\n- 接下来 $n$ 行每行一个长度为 $m$、字符集为 `BW` 的字符串，描述网格初始时的染色情况。其中第 $i$ 行第 $j$ 个字符为 `B` 表示 $(i,j)$ 初始为黑色，否则为 `W` 表示 $(i,j)$ 初始为白色。保证初始棋盘上至少有一个白色格子。\n\n保证单个测试点中所有测试数据的 $n \\times m$ 的和不超过 $5 \\times 10^6$。", "outputFormat": "对于每组测试数据输出一行一个字符，若小 I 必胜输出 `I`，否则若小 J 必胜输出 `J`。\n", "hint": "\n对于第一组测试数据，小 I 只能染黑 $(2,1)$，但染黑 $(2,1)$ 会导致无法仅通过每次移动到相邻的白色格子从 $(1,1)$ 移动到 $(2,2)$，因此无论小 I 如何操作都将失败，故输出 `J`。\n\n对于第二组测试数据，小 I 可以染黑 $(1,2)$，然后无论小 J 如何操作都将失败，故输出 `I`。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 黑白", "background": "", "description": "小 I 和小 J 又在玩游戏。\n\n游戏在一个 $n \\times m$ 的网格上进行，我们用二元组 $(x,y)$ 描述第 $x$ 行第 $y$ 列的格子，其中 $1 \\le x \\le n, 1 \\le y \\le m$。初始时，网格上有至少一个格子是白色的，其他格子是黑色的。\n\n小 I 和小 J 轮流操作，小 I 先手。每次操作时，操作方必须选择恰好一个白色的格子并将其染黑。\n\n称两个格子相邻当且仅当它们共用一条边。若某次操作后，格子 $(1,1)$ 不是白的，或者格子 $(n,m)$ 不是白的，或者无法从 $(1,1)$ 出发，每次经过相邻的白色格子，最终到达 $(n,m)$（即 $(1,1)$ 和 $(n,m)$ 不在同一个白色格子构成的四连通块内），则当前操作方输，另一方胜利。\n\n你作为游戏的观众，想知道在小 I 和小 J 绝顶聪明的情况下，谁会获胜。", "inputFormat": "**本题有多组测试数据。** 输入的第一行一个整数 $T (1 \\le T \\le 100)$ 表示测试数据组数，接下来依次输入每组测试数据。对于每组测试数据，\n\n- 第一行两个整数 $n, m (2 \\le n, m \\le 1000)$，表示网格的大小。\n- 接下来 $n$ 行每行一个长度为 $m$、字符集为 `BW` 的字符串，描述网格初始时的染色情况。其中第 $i$ 行第 $j$ 个字符为 `B` 表示 $(i,j)$ 初始为黑色，否则为 `W` 表示 $(i,j)$ 初始为白色。保证初始棋盘上至少有一个白色格子。\n\n保证单个测试点中所有测试数据的 $n \\times m$ 的和不超过 $5 \\times 10^6$。", "outputFormat": "对于每组测试数据输出一行一个字符，若小 I 必胜输出 `I`，否则若小 J 必胜输出 `J`。\n", "hint": "\n对于第一组测试数据，小 I 只能染黑 $(2,1)$，但染黑 $(2,1)$ 会导致无法仅通过每次移动到相邻的白色格子从 $(1,1)$ 移动到 $(2,2)$，因此无论小 I 如何操作都将失败，故输出 `J`。\n\n对于第二组测试数据，小 I 可以染黑 $(1,2)$，然后无论小 J 如何操作都将失败，故输出 `I`。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10544", "type": "P", "difficulty": 6, "samples": [["4 4\n1 0 0 0\n1 2 2 4\n1 1 3\n2 1 4\n3 1 4\n", "1\n1\n1\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2024", "Tarjan", "THUPC"], "title": "[THUPC 2024 决赛] 转化", "background": "", "description": "有 $n$ 种物品和 $m$ 种转化方式。第 $i$ 种转化方式可以将一个第 $a_i$ 种物品转化成 $k_i$ 个互不相同的物品，其中第 $j$ 个的种类是 $b_{i,j}$。同一种转化方式可以使用任意多次。\n\n你有一些物品。你想知道，对于每一种特定的物品 $d$，你用这些你所拥有的物品可以分别转化出最多多少个该种物品。\n", "inputFormat": "第一行两个正整数 $n,m$。\n\n第二行 $n$ 个非负整数，其中第 $i$ 个为 $c_i$，表示你拥有的第 $i$ 种物品的数量。\n\n接下来 $m$ 行，其中第 $i$ 行表示第 $i$ 种转化方式。\n\n转化方式的格式为：一行 $k_i+2$ 个正整数，其中第一个为 $a_i$，第二个为 $k_i$，之后为 $k_i$ 个互不相同的正整数 $b_{i,1},b_{i,2},\\cdots,b_{i,k_i}$​​。\n\n保证 $1\\le n \\le 100$，$1\\le m \\le 1000$。\n\n保证 $1\\le a_i,k_i,b_{i,j} \\le n$。\n\n保证 $0\\le c_i \\le 1000$。", "outputFormat": "输出 $n$ 行，其中第 $d$ 行表示第 $d$ 种物品最多能有多少个。如果可以任意多，即对于任意的 $N$ 都存在一种方案使得有超过 $N$ 个第 $d$ 种物品，输出 `infinity`。\n", "hint": "不使用任何转化方式，可以得到一个物品 $1$。\n\n使用一次第一种转化方式，可以把物品 $1$ 变成物品 $2$ 和物品 $4$。这样可以得到一个物品 $2$。\n\n使用一次第二种转化方式，可以把物品 $1$ 变成物品 $3$。这样可以得到一个物品 $3$。\n\n使用一次第一种转化方式，可以把物品 $1$ 变成物品 $2$ 和物品 $4$。然后再使用一次第三种转化方式，可以把物品 $2$ 变成物品 $4$。这样可以得到两个物品 $4$。\n\n可以证明这四种方案分别是当 $d=1,2,3,4$ 时的最优方案。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 转化", "background": "", "description": "有 $n$ 种物品和 $m$ 种转化方式。第 $i$ 种转化方式可以将一个第 $a_i$ 种物品转化成 $k_i$ 个互不相同的物品，其中第 $j$ 个的种类是 $b_{i,j}$。同一种转化方式可以使用任意多次。\n\n你有一些物品。你想知道，对于每一种特定的物品 $d$，你用这些你所拥有的物品可以分别转化出最多多少个该种物品。\n", "inputFormat": "第一行两个正整数 $n,m$。\n\n第二行 $n$ 个非负整数，其中第 $i$ 个为 $c_i$，表示你拥有的第 $i$ 种物品的数量。\n\n接下来 $m$ 行，其中第 $i$ 行表示第 $i$ 种转化方式。\n\n转化方式的格式为：一行 $k_i+2$ 个正整数，其中第一个为 $a_i$，第二个为 $k_i$，之后为 $k_i$ 个互不相同的正整数 $b_{i,1},b_{i,2},\\cdots,b_{i,k_i}$​​。\n\n保证 $1\\le n \\le 100$，$1\\le m \\le 1000$。\n\n保证 $1\\le a_i,k_i,b_{i,j} \\le n$。\n\n保证 $0\\le c_i \\le 1000$。", "outputFormat": "输出 $n$ 行，其中第 $d$ 行表示第 $d$ 种物品最多能有多少个。如果可以任意多，即对于任意的 $N$ 都存在一种方案使得有超过 $N$ 个第 $d$ 种物品，输出 `infinity`。\n", "hint": "不使用任何转化方式，可以得到一个物品 $1$。\n\n使用一次第一种转化方式，可以把物品 $1$ 变成物品 $2$ 和物品 $4$。这样可以得到一个物品 $2$。\n\n使用一次第二种转化方式，可以把物品 $1$ 变成物品 $3$。这样可以得到一个物品 $3$。\n\n使用一次第一种转化方式，可以把物品 $1$ 变成物品 $2$ 和物品 $4$。然后再使用一次第三种转化方式，可以把物品 $2$ 变成物品 $4$。这样可以得到两个物品 $4$。\n\n可以证明这四种方案分别是当 $d=1,2,3,4$ 时的最优方案。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10545", "type": "P", "difficulty": 7, "samples": [["4 7\n1 3\n2 0\n3 0\n2 1\nSWAP 1 0 2\nSWAP 0 1 3\nSWAP 1 2 0\nMOVE 0 0 2\nSWAP 1 0 2\nSWAP 0 2 3\nMOVE 3 0 3\n", "MOVE 0 1\nSWAP\nTRIGGER SWAP: SWAP\nSWAP\n"], ["4 7\n1 2\n2 3\n3 1\n0 2\nTOGGLETRIGGERREPLACE 0 1\nSLACKOFF 3\nMOVE 0 1 3\nSWAP 1 2 3\nTOGGLETRIGGERREPLACE 3 2\nSLACKOFF 2\nSLACKOFF 3\n", "TOGGLETRIGGERREPLACE 0 MOVE MOVE 1 1\nTRIGGER SLACKOFF: SWAP\nTRIGGER SWAP: TOGGLETRIGGERREPLACE 1 TOGGLETRIGGERREPLACE SLACKOFF\nSLACKOFF\n"], ["4 4\n2 1\n1 2\n0 3\n1 3\nSLACKOFF 0\nSLACKOFF 1\nSLACKOFF 2\nSLACKOFF 3\n", "SLACKOFF\nTRIGGER SLACKOFF: SLACKOFF\nTRIGGER SLACKOFF: SLACKOFF\nTRIGGER TRIGGER: SLACKOFF\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["模拟", "2024", "Special Judge", "2-SAT", "THUPC"], "title": "[THUPC 2024 决赛] 机器人", "background": "注意本题的指令含义与初赛的略有不同。\n", "description": "有 $n$ 个机器人围成一圈，编号按照逆时针顺序分别为 $0\\sim n-1$。\n\n每个机器人有两只手。编号为 $i$ 的机器人初始「左手」指向编号 $l_i$ 的机器人，「右手」指向编号 $r_i$ 的机器人。\n\n所有的机器人内部都写有一条「指令」，「指令」有以下这些形式：\n\n### 指令\n\n下面介绍这些「指令」的格式以及它们被「执行」时的效果。文中的“自己”一词均指拥有这条「指令」的机器人。\n\n- `SLACKOFF`：**「摸鱼」**，即什么也不做。\n- `MOVE h z`：将第 $h$ 只手向逆时针方向 **「移动」** $z$ 个机器人的位置。当 $h=0$ 时表示「左手」，当 $h=1$ 时表示「右手」，下同。\n- `SWAP`：**「交换」** 双手指向的机器人的「指令」。\n- `TRIGGER <COMMANDNAME>: <COMMAND>`：其中 `<COMMANDNAME>` 为 `SLACKOFF`、`MOVE`、`SWAP`、`TRIGGER`、`TOGGLETRIGGERREPLACE` 之一；`<COMMAND>` 表示一条完整的非 `TRIGGER` 「指令」。`TRIGGER` 指令本身不会被「执行」，但是，当一个**其他**机器人「执行」完一条「指令」之后，且「右手」指向自己的时候，自己满足如下条件的 `TRIGGER` 指令（如果有）就会被 **「触发」**——「执行」一次对应的 `<COMMAND>`：\n  - `<COMMANDNAME>` 不为 `TRIGGER` 时，刚刚「执行」完毕的「指令」为 `<COMMANDNAME>` 指令；\n  - `<COMMANDNAME>` 为 `TRIGGER` 时，刚刚「执行」完毕的「指令」是一条 `TRIGGER` 指令被「触发」时，「执行」的 `<COMMAND>` 部分。\n- `TOGGLETRIGGERREPLACE h <COMMANDNAME> <NEWCOMMAND>`：如果第 $h$ 只手指向的机器人的「指令」是 `TRIGGER` 指令，则将其 **「切换」** 为该「指令」的 `<COMMAND>` 部分，即删去前面的 `TRIGGER` 及条件部分；如果这条「指令」不是 `TRIGGER` 指令，假设是 `<COMMAND>`，则将其「切换」为 `TRIGGER <COMMANDNAME>: <COMMAND>`。其中 `<COMMANDNAME>` 为 `SLACKOFF`、`MOVE`、`SWAP`、`TRIGGER`、`TOGGLETRIGGERREPLACE` 之一。然后将自己的「指令」（注意这可能不仅仅包含正在「执行」的那部分「指令」）修改为 `<NEWCOMMAND>`。其中，`<NEWCOMMAND>` 是一条完整的「指令」。\n\n机器人「执行」各「指令」时的输出格式如下：\n\n- 「摸鱼」时输出 `Robot <id> slacks off.`。其中 `<id>` 为一个整数，表示「执行」当前「指令」的机器人编号，下同。\n- 「移动」时输出 `Robot <id> moves its <side> hand towards Robot <id2>.`。其中 `<side>` 为 `left` 或 `right`，表示移动了哪只手（`left` 表示「左手」，`right` 表示「右手」）；`<id2>` 为一个整数，表示移动之后这只手指向的机器人的编号。\n- 「交换」时输出 `Robot <id> swaps the commands of Robot <id2> and Robot <id3>.`。其中 `<id2>` 和 `<id3>` 为整数，表示被「交换」「指令」的机器人编号，这两个数可以按任意顺序输出。\n- 「切换」时输出 `Robot <id> toggles the trigger property of the command of Robot <id2>`。\n- `TRIGGER` 指令不会被「执行」，但当它们被「触发」时，会按照上面的格式输出对应的「指令」被「执行」的信息。\n\n你按照一定顺序选择了一些机器人（可能重复选择）并「执行」了对应机器人的「指令」，得到了「执行」的**完整**输出，也就是说，在「执行」完输出中最后一条「指令」之后，没有其他「指令」被「触发」。但是，你忘记了你选择机器人的顺序，也忘了每个机器人开始时有什么「指令」。你只记得机器人的总数以及开始时每个机器人的手指向什么位置。\n\n你想通过已知的所有信息还原出最初所有机器人的「指令」都是什么。", "inputFormat": "第一行两个正整数 $n,k$，其中 $k$ 表示输出的总行数。\n\n接下来 $n$ 行，每行两个整数 $l_i,r_i$，按编号从小到大的顺序输入。\n\n接下来 $k$ 行，每行一条「执行」「指令」的输出信息。\n\n为了减轻处理输入的负担，输出信息被简化如下（没有特殊声明的参数信息含义同上）：\n\n- 「摸鱼」时输出 `SLACKOFF <id>`。\n- 「移动」时输出 `MOVE <id> <side> <id2>`。其中 `<side>` 为 `0` 或 `1`，表示移动了哪只手（`0` 表示「左手」，`1` 表示「右手」）。\n- 「交换」时输出 `SWAP <id> <id2> <id3>`。\n- 「切换」时输出 `TOGGLETRIGGERREPLACE <id> <id2>`。\n- `TRIGGER` 指令不会被「执行」，但当它们被「触发」时，会按照上面的格式输出对应的「指令」被「执行」的信息。\n\n输入保证存在一组初始的「指令」，使得存在一种选择机器人的方式，能够得到对应的输出。\n\n保证 $1\\le n,k \\le 500000$。\n\n保证 $0\\le l_i,r_i<n$。", "outputFormat": "输出 $n$ 行，按编号从小到大输出机器人最初的「指令」，每条一行。\n\n你需要保证「指令」格式正确，且 $0\\le z < n$。\n\n你需要保证你的输出文件不能过大。若你的输出文件大小不超过 $100\\texttt{MB}$，则一定能保证 Special Judge 能够正确返回结果。\n\n此外任何能够得到输入中 $k$ 行输出的答案均算作正确。", "hint": "**样例解释 1**\n\n选择机器人的顺序为 $1,1,0,1,3$，其中第二、六条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。\n\n注意 `TRIGGER` 指令「触发」的时机是在「执行」上一条「指令」之后，所以第一次「交换」之后由于 $1$ 号机器人的「右手」指向了写有 `TRIGGER SWAP: SWAP` 的 $0$ 号机器人，所以这条 `TRIGGER` 指令能被「触发」。\n\n**样例解释 2**\n\n选择机器人的顺序为 $0,3,0,1,3$，其中第五、六条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。\n\n第一次「执行」会使 $1$ 号机器人的「指令」变为 `SWAP`，$0$ 号机器人的「指令」变为 `MOVE 1 1`。\n\n第五次「执行」会使 $2$ 号机器人的「指令」由 `SLACKOFF` 变为 \n```\nTRIGGER TOGGLETRIGGERREPLACE: SLACKOFF\n```\n，$3$ 号机器人的「指令」由\n```\nTRIGGER SWAP: TOGGLETRIGGERREPLACE 1 TOGGLETRIGGERREPLACE SLACKOFF\n```\n会变为 `SLACKOFF` 而不是 `TRIGGER SWAP: SLACKOFF`。\n\n**样例解释 3**\n\n选择机器人的顺序为 $0$，其中第二、三、四条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。\n\n注意 $3$ 号机器人「执行」完「指令」后不会接着「触发」自己的 `TRIGGER` 「指令」，即使它的「右手」指向了自己。\n\n另外，选择一个写有 `TRIGGER` 指令的机器人不会产生任何输出，所以这么做没有意义。\n\n**样例解释 4**\n\n见题目目录下的 *4.in*。该样例不提供样例输出。\n\n**样例解释 5**\n\n见题目目录下的 *5.in*。该样例不提供样例输出。\n\n**提示**\n\n我们会下发一个可执行文件 `checker` 来帮助你检查你的输出是否正确。使用方式为在该文件所在目录下使用如下指令：\n\n```\n./checker <输入文件路径> <你的输出文件路径>\n```\n\n若你的输出正确，程序会输出 `Accepted.`；否则会提示「执行」结果与输入文件最早一次不匹配的地方。\n\n注意，若你使用的输入文件不是样例输入，该程序不会检查是否存在一组初始的「指令」，使得存在一种选择机器人的方式，能够得到对应的「执行」结果。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 机器人", "background": "注意本题的指令含义与初赛的略有不同。\n", "description": "有 $n$ 个机器人围成一圈，编号按照逆时针顺序分别为 $0\\sim n-1$。\n\n每个机器人有两只手。编号为 $i$ 的机器人初始「左手」指向编号 $l_i$ 的机器人，「右手」指向编号 $r_i$ 的机器人。\n\n所有的机器人内部都写有一条「指令」，「指令」有以下这些形式：\n\n### 指令\n\n下面介绍这些「指令」的格式以及它们被「执行」时的效果。文中的“自己”一词均指拥有这条「指令」的机器人。\n\n- `SLACKOFF`：**「摸鱼」**，即什么也不做。\n- `MOVE h z`：将第 $h$ 只手向逆时针方向 **「移动」** $z$ 个机器人的位置。当 $h=0$ 时表示「左手」，当 $h=1$ 时表示「右手」，下同。\n- `SWAP`：**「交换」** 双手指向的机器人的「指令」。\n- `TRIGGER <COMMANDNAME>: <COMMAND>`：其中 `<COMMANDNAME>` 为 `SLACKOFF`、`MOVE`、`SWAP`、`TRIGGER`、`TOGGLETRIGGERREPLACE` 之一；`<COMMAND>` 表示一条完整的非 `TRIGGER` 「指令」。`TRIGGER` 指令本身不会被「执行」，但是，当一个**其他**机器人「执行」完一条「指令」之后，且「右手」指向自己的时候，自己满足如下条件的 `TRIGGER` 指令（如果有）就会被 **「触发」**——「执行」一次对应的 `<COMMAND>`：\n  - `<COMMANDNAME>` 不为 `TRIGGER` 时，刚刚「执行」完毕的「指令」为 `<COMMANDNAME>` 指令；\n  - `<COMMANDNAME>` 为 `TRIGGER` 时，刚刚「执行」完毕的「指令」是一条 `TRIGGER` 指令被「触发」时，「执行」的 `<COMMAND>` 部分。\n- `TOGGLETRIGGERREPLACE h <COMMANDNAME> <NEWCOMMAND>`：如果第 $h$ 只手指向的机器人的「指令」是 `TRIGGER` 指令，则将其 **「切换」** 为该「指令」的 `<COMMAND>` 部分，即删去前面的 `TRIGGER` 及条件部分；如果这条「指令」不是 `TRIGGER` 指令，假设是 `<COMMAND>`，则将其「切换」为 `TRIGGER <COMMANDNAME>: <COMMAND>`。其中 `<COMMANDNAME>` 为 `SLACKOFF`、`MOVE`、`SWAP`、`TRIGGER`、`TOGGLETRIGGERREPLACE` 之一。然后将自己的「指令」（注意这可能不仅仅包含正在「执行」的那部分「指令」）修改为 `<NEWCOMMAND>`。其中，`<NEWCOMMAND>` 是一条完整的「指令」。\n\n机器人「执行」各「指令」时的输出格式如下：\n\n- 「摸鱼」时输出 `Robot <id> slacks off.`。其中 `<id>` 为一个整数，表示「执行」当前「指令」的机器人编号，下同。\n- 「移动」时输出 `Robot <id> moves its <side> hand towards Robot <id2>.`。其中 `<side>` 为 `left` 或 `right`，表示移动了哪只手（`left` 表示「左手」，`right` 表示「右手」）；`<id2>` 为一个整数，表示移动之后这只手指向的机器人的编号。\n- 「交换」时输出 `Robot <id> swaps the commands of Robot <id2> and Robot <id3>.`。其中 `<id2>` 和 `<id3>` 为整数，表示被「交换」「指令」的机器人编号，这两个数可以按任意顺序输出。\n- 「切换」时输出 `Robot <id> toggles the trigger property of the command of Robot <id2>`。\n- `TRIGGER` 指令不会被「执行」，但当它们被「触发」时，会按照上面的格式输出对应的「指令」被「执行」的信息。\n\n你按照一定顺序选择了一些机器人（可能重复选择）并「执行」了对应机器人的「指令」，得到了「执行」的**完整**输出，也就是说，在「执行」完输出中最后一条「指令」之后，没有其他「指令」被「触发」。但是，你忘记了你选择机器人的顺序，也忘了每个机器人开始时有什么「指令」。你只记得机器人的总数以及开始时每个机器人的手指向什么位置。\n\n你想通过已知的所有信息还原出最初所有机器人的「指令」都是什么。", "inputFormat": "第一行两个正整数 $n,k$，其中 $k$ 表示输出的总行数。\n\n接下来 $n$ 行，每行两个整数 $l_i,r_i$，按编号从小到大的顺序输入。\n\n接下来 $k$ 行，每行一条「执行」「指令」的输出信息。\n\n为了减轻处理输入的负担，输出信息被简化如下（没有特殊声明的参数信息含义同上）：\n\n- 「摸鱼」时输出 `SLACKOFF <id>`。\n- 「移动」时输出 `MOVE <id> <side> <id2>`。其中 `<side>` 为 `0` 或 `1`，表示移动了哪只手（`0` 表示「左手」，`1` 表示「右手」）。\n- 「交换」时输出 `SWAP <id> <id2> <id3>`。\n- 「切换」时输出 `TOGGLETRIGGERREPLACE <id> <id2>`。\n- `TRIGGER` 指令不会被「执行」，但当它们被「触发」时，会按照上面的格式输出对应的「指令」被「执行」的信息。\n\n输入保证存在一组初始的「指令」，使得存在一种选择机器人的方式，能够得到对应的输出。\n\n保证 $1\\le n,k \\le 500000$。\n\n保证 $0\\le l_i,r_i<n$。", "outputFormat": "输出 $n$ 行，按编号从小到大输出机器人最初的「指令」，每条一行。\n\n你需要保证「指令」格式正确，且 $0\\le z < n$。\n\n你需要保证你的输出文件不能过大。若你的输出文件大小不超过 $100\\texttt{MB}$，则一定能保证 Special Judge 能够正确返回结果。\n\n此外任何能够得到输入中 $k$ 行输出的答案均算作正确。", "hint": "**样例解释 1**\n\n选择机器人的顺序为 $1,1,0,1,3$，其中第二、六条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。\n\n注意 `TRIGGER` 指令「触发」的时机是在「执行」上一条「指令」之后，所以第一次「交换」之后由于 $1$ 号机器人的「右手」指向了写有 `TRIGGER SWAP: SWAP` 的 $0$ 号机器人，所以这条 `TRIGGER` 指令能被「触发」。\n\n**样例解释 2**\n\n选择机器人的顺序为 $0,3,0,1,3$，其中第五、六条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。\n\n第一次「执行」会使 $1$ 号机器人的「指令」变为 `SWAP`，$0$ 号机器人的「指令」变为 `MOVE 1 1`。\n\n第五次「执行」会使 $2$ 号机器人的「指令」由 `SLACKOFF` 变为 \n```\nTRIGGER TOGGLETRIGGERREPLACE: SLACKOFF\n```\n，$3$ 号机器人的「指令」由\n```\nTRIGGER SWAP: TOGGLETRIGGERREPLACE 1 TOGGLETRIGGERREPLACE SLACKOFF\n```\n会变为 `SLACKOFF` 而不是 `TRIGGER SWAP: SLACKOFF`。\n\n**样例解释 3**\n\n选择机器人的顺序为 $0$，其中第二、三、四条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。\n\n注意 $3$ 号机器人「执行」完「指令」后不会接着「触发」自己的 `TRIGGER` 「指令」，即使它的「右手」指向了自己。\n\n另外，选择一个写有 `TRIGGER` 指令的机器人不会产生任何输出，所以这么做没有意义。\n\n**样例解释 4**\n\n见题目目录下的 *4.in*。该样例不提供样例输出。\n\n**样例解释 5**\n\n见题目目录下的 *5.in*。该样例不提供样例输出。\n\n**提示**\n\n我们会下发一个可执行文件 `checker` 来帮助你检查你的输出是否正确。使用方式为在该文件所在目录下使用如下指令：\n\n```\n./checker <输入文件路径> <你的输出文件路径>\n```\n\n若你的输出正确，程序会输出 `Accepted.`；否则会提示「执行」结果与输入文件最早一次不匹配的地方。\n\n注意，若你使用的输入文件不是样例输入，该程序不会检查是否存在一组初始的「指令」，使得存在一种选择机器人的方式，能够得到对应的「执行」结果。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>\n", "locale": "zh-CN"}}}
{"pid": "P10546", "type": "P", "difficulty": 7, "samples": [["5\n\n1 4 1 2 3\n\n1 1 2 3 4", "\n? 0110\n\n? 0000\n\n! 1 4 2 3 2 4 4 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2024", "交互题", "Special Judge", "随机化", "构造", "THUPC"], "title": "[THUPC 2024 决赛] 采矿", "background": "在精心地规划完工人的移动路线，执行完所有计划之后，你终于有钱了。你承包下了一个更大的矿坑，并购买了更先进的设备。\n\n但是开始运行了你才发现，一部分运输矿物的通道居然装反了！还好它们本来就是可以反向的，并且中控的系统可以让你轻易地操作。\n\n然而，现在最大的问题是，你刚刚接手这个矿坑，你甚至连它长什么样都不知道，也就更不知道每个开关是对应哪一条运输通道的。\n\n时间就是金钱，你想要尽快摸清整个矿坑的结构以及所有开关与通道的对应关系。", "description": "**这是一道交互题。**\n\n已知你的矿坑有 $n$ 个节点，编号为 $1\\sim n$。它们通过 $n-1$ 条运输通道连成一个树形结构。\n\n运输通道都是单向的。对于一条从节点 $u$ 到节点 $v$ 的运输通道，可以将所有由节点 $u$ 产出的矿或运送到节点 $u$ 的矿以较快的速度运送到节点 $v$。如果一个节点有多条以其为起点的运输通道，那么会把这些矿平均分配给这些运输通道。\n\n中控的系统包含 $n-1$ 个开关和一个监视器。开关的编号为 $1\\sim n-1$，每个开关可以拨到 $0$ 或 $1$ 的位置。$n-1$ 个开关和 $n-1$ 条运输通道一一对应，但你并不知道它们的对应关系。你只知道，假设编号为 $i$ 的开关对应的运输通道在被装上去时是从 $u_i$ 到 $v_i$ 的，那么当开关拨到 $0$ 的时候，它的运输方向和它被装上去时相同；当开关拨到 $1$ 的时候，它的运输方向会变成从 $v_i$ 到 $u_i$。你的监视器可以监控到达每个节点的矿分别来自多少个不同的节点，也就是说，有多少个节点（包括其本身）能够通过运输通道把矿运输到这个节点。\n\n当你调整完开关的位置后，需要等一段时间，监视器的结果才会趋于稳定，这时你的读数才是有意义的。所以为了避免浪费太多时间，你希望在 $50$ 次读数之内确定你想知道的所有信息。", "inputFormat": "开始时你需要输入一个正整数 $n$。保证 $2\\le n \\le 10000$。\n\n之后的输入会基于你的输出生成读数。你的读数结果是一行 $n$ 个正整数，其中第 $i$ 个表示到达节点 $i$ 的矿来自多少个不同的节点。\n\n每个测试点中，矿坑的连接方式和所有运输通道刚装上去时的方向都是固定的，也就是说，这些不会因为你的输出而动态修改为另外一种符合之前所有回答的方案。", "outputFormat": "当你需要调整开关并等待读数时，输出一行 `? s`，其中 `s` 为一个长为 $n-1$ 的 `01` 串，其中第 $i$ 位表示编号为 $i$ 的开关拨到的位置。然后交互库会在你的标准输入中给出监视器趋于稳定之后的读数结果。你最多只能读数 $50$ 次。\n\n当你已经知道了所有通道的信息时，输出一行 `! u1 v1 ... un-1 vn-1`，其中 $u_i,v_i$ 表示编号为 $i$ 的开关对应的运输通道被装上去时的方向是从节点 $u_i$ 到节点 $v_i$ 的。\n\n在输出一行之后，你需要刷新输出缓冲区，否则评测结果可能会变成 `TLE`。刷新输出缓冲区的方式为：\n\n- C：`fflush(stdout);`\n\n- C++：`fflush(stdout);` 或 `std::cout.flush();` 或使用 `std::endl` 换行\n\n- Java：`System.out.flush();`\n\n- Python：`sys.stdout.flush()`\n", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/fuc2u4d1.png)\n\n通道的初始方向如上图所示。通道上的数字代表和通道对应的开关的编号。\n\n样例只是用来说明输入输出格式和读数结果，并不意味着这次读数能够推出答案。\n\n\n交互库的运行时间和内存不计入时间和内存限制。\n\n若超出读数次数限制、最后的回答错误或输出格式错误，评测结果均为 `WA`。\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 采矿", "background": "在精心地规划完工人的移动路线，执行完所有计划之后，你终于有钱了。你承包下了一个更大的矿坑，并购买了更先进的设备。\n\n但是开始运行了你才发现，一部分运输矿物的通道居然装反了！还好它们本来就是可以反向的，并且中控的系统可以让你轻易地操作。\n\n然而，现在最大的问题是，你刚刚接手这个矿坑，你甚至连它长什么样都不知道，也就更不知道每个开关是对应哪一条运输通道的。\n\n时间就是金钱，你想要尽快摸清整个矿坑的结构以及所有开关与通道的对应关系。", "description": "**这是一道交互题。**\n\n已知你的矿坑有 $n$ 个节点，编号为 $1\\sim n$。它们通过 $n-1$ 条运输通道连成一个树形结构。\n\n运输通道都是单向的。对于一条从节点 $u$ 到节点 $v$ 的运输通道，可以将所有由节点 $u$ 产出的矿或运送到节点 $u$ 的矿以较快的速度运送到节点 $v$。如果一个节点有多条以其为起点的运输通道，那么会把这些矿平均分配给这些运输通道。\n\n中控的系统包含 $n-1$ 个开关和一个监视器。开关的编号为 $1\\sim n-1$，每个开关可以拨到 $0$ 或 $1$ 的位置。$n-1$ 个开关和 $n-1$ 条运输通道一一对应，但你并不知道它们的对应关系。你只知道，假设编号为 $i$ 的开关对应的运输通道在被装上去时是从 $u_i$ 到 $v_i$ 的，那么当开关拨到 $0$ 的时候，它的运输方向和它被装上去时相同；当开关拨到 $1$ 的时候，它的运输方向会变成从 $v_i$ 到 $u_i$。你的监视器可以监控到达每个节点的矿分别来自多少个不同的节点，也就是说，有多少个节点（包括其本身）能够通过运输通道把矿运输到这个节点。\n\n当你调整完开关的位置后，需要等一段时间，监视器的结果才会趋于稳定，这时你的读数才是有意义的。所以为了避免浪费太多时间，你希望在 $50$ 次读数之内确定你想知道的所有信息。", "inputFormat": "开始时你需要输入一个正整数 $n$。保证 $2\\le n \\le 10000$。\n\n之后的输入会基于你的输出生成读数。你的读数结果是一行 $n$ 个正整数，其中第 $i$ 个表示到达节点 $i$ 的矿来自多少个不同的节点。\n\n每个测试点中，矿坑的连接方式和所有运输通道刚装上去时的方向都是固定的，也就是说，这些不会因为你的输出而动态修改为另外一种符合之前所有回答的方案。", "outputFormat": "当你需要调整开关并等待读数时，输出一行 `? s`，其中 `s` 为一个长为 $n-1$ 的 `01` 串，其中第 $i$ 位表示编号为 $i$ 的开关拨到的位置。然后交互库会在你的标准输入中给出监视器趋于稳定之后的读数结果。你最多只能读数 $50$ 次。\n\n当你已经知道了所有通道的信息时，输出一行 `! u1 v1 ... un-1 vn-1`，其中 $u_i,v_i$ 表示编号为 $i$ 的开关对应的运输通道被装上去时的方向是从节点 $u_i$ 到节点 $v_i$ 的。\n\n在输出一行之后，你需要刷新输出缓冲区，否则评测结果可能会变成 `TLE`。刷新输出缓冲区的方式为：\n\n- C：`fflush(stdout);`\n\n- C++：`fflush(stdout);` 或 `std::cout.flush();` 或使用 `std::endl` 换行\n\n- Java：`System.out.flush();`\n\n- Python：`sys.stdout.flush()`\n", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/fuc2u4d1.png)\n\n通道的初始方向如上图所示。通道上的数字代表和通道对应的开关的编号。\n\n样例只是用来说明输入输出格式和读数结果，并不意味着这次读数能够推出答案。\n\n\n交互库的运行时间和内存不计入时间和内存限制。\n\n若超出读数次数限制、最后的回答错误或输出格式错误，评测结果均为 `WA`。\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>\n\n", "locale": "zh-CN"}}}
{"pid": "P10547", "type": "P", "difficulty": 6, "samples": [["6\n2 1\n3 1\n5 2\n7 5\n10 20\n15 24\n", "1\n2\n7\n331\n1570446\n73880648\n"]], "limits": {"time": [3500, 3500, 3500, 3500, 3500, 3500], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 决赛] 排列游戏", "background": "提供了额外的 1 秒时限。", "description": "有 $n$ 个格子排成一行，从左到右依次编号为 $1,2,\\cdots,n$，每个格子上有一个数字卡片，初始状态下，格子 $i$ 上的卡片数字为 $i$。\n\n打乱者会进行 $n$ 次交换操作来排列这些卡片：每次选择两个格子 $i,j$（$i\\ne j$），然后交换格子 $i$ 和格子 $j$ 上的卡片。$n$ 次交换操作结束后，就完成了对卡片的排列。\n\n然后轮到玩家行动，玩家同样需要用交换操作，每次交换两张卡片，目标是将这些卡片的顺序还原到初始状态。\n\n交换格子 $i$ 和格子 $j$ 上的卡片所需的时间为 $|i-j|$，玩家打算用最短的时间还原该排列。问：有多少种可能的排列，玩家可以用不超过 $m$ 的总时间完成还原？两种排列不同，当且仅当至少有一张数字卡片在两种排列中所在的格子不同。", "inputFormat": "每个测试点由多组数据组成。\n\n第一行包含一个正整数 $T$，表示数据组数。保证 $T\\le1,000$。\n\n之后 $T$ 行，每行一组数据，包含两个正整数 $n$，$m$。保证 $2\\le n\\le500$，$m\\le5,000$。\n", "outputFormat": "每组数据输出一行，一个整数表示答案。\n\n由于答案可能很大，请输出答案对 $1,000,000,007$ 取模的结果。\n", "hint": "在第 $1$ 组数据中，打乱者的 $2$ 次操作均只可能是交换格子 $1$ 和格子 $2$ 上的卡片，只有 $1$ 种可能的排列，也就是初始状态 $[1,2]$。\n\n在第 $2$ 组数据中，有 $2$ 种可能的排列：$[1,3,2]$ 和 $[2,1,3]$。注意初始状态 $[1,2,3]$ 不是一种可能的排列，因为打乱者进行前 $2$ 次交换之后，所有卡片要么仍在初始状态（前 $2$ 次交换的是同一对卡片），要么均不在初始位置上（前 $2$ 次交换的不是同一对卡片），第 $3$ 次交换后不可能回到初始状态。\n\n在第 $3$ 组数据中，有 $7$ 种可能的排列：$[1,2,3,5,4]$，$[1,2,4,3,5]$，$[1,2,5,4,3]$，$[1,3,2,4,5]$，$[1,4,3,2,5]$，$[2,1,3,4,5]$，$[3,2,1,4,5]$。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 排列游戏", "background": "提供了额外的 1 秒时限。", "description": "有 $n$ 个格子排成一行，从左到右依次编号为 $1,2,\\cdots,n$，每个格子上有一个数字卡片，初始状态下，格子 $i$ 上的卡片数字为 $i$。\n\n打乱者会进行 $n$ 次交换操作来排列这些卡片：每次选择两个格子 $i,j$（$i\\ne j$），然后交换格子 $i$ 和格子 $j$ 上的卡片。$n$ 次交换操作结束后，就完成了对卡片的排列。\n\n然后轮到玩家行动，玩家同样需要用交换操作，每次交换两张卡片，目标是将这些卡片的顺序还原到初始状态。\n\n交换格子 $i$ 和格子 $j$ 上的卡片所需的时间为 $|i-j|$，玩家打算用最短的时间还原该排列。问：有多少种可能的排列，玩家可以用不超过 $m$ 的总时间完成还原？两种排列不同，当且仅当至少有一张数字卡片在两种排列中所在的格子不同。", "inputFormat": "每个测试点由多组数据组成。\n\n第一行包含一个正整数 $T$，表示数据组数。保证 $T\\le1,000$。\n\n之后 $T$ 行，每行一组数据，包含两个正整数 $n$，$m$。保证 $2\\le n\\le500$，$m\\le5,000$。\n", "outputFormat": "每组数据输出一行，一个整数表示答案。\n\n由于答案可能很大，请输出答案对 $1,000,000,007$ 取模的结果。\n", "hint": "在第 $1$ 组数据中，打乱者的 $2$ 次操作均只可能是交换格子 $1$ 和格子 $2$ 上的卡片，只有 $1$ 种可能的排列，也就是初始状态 $[1,2]$。\n\n在第 $2$ 组数据中，有 $2$ 种可能的排列：$[1,3,2]$ 和 $[2,1,3]$。注意初始状态 $[1,2,3]$ 不是一种可能的排列，因为打乱者进行前 $2$ 次交换之后，所有卡片要么仍在初始状态（前 $2$ 次交换的是同一对卡片），要么均不在初始位置上（前 $2$ 次交换的不是同一对卡片），第 $3$ 次交换后不可能回到初始状态。\n\n在第 $3$ 组数据中，有 $7$ 种可能的排列：$[1,2,3,5,4]$，$[1,2,4,3,5]$，$[1,2,5,4,3]$，$[1,3,2,4,5]$，$[1,4,3,2,5]$，$[2,1,3,4,5]$，$[3,2,1,4,5]$。\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10548", "type": "P", "difficulty": 6, "samples": [["2\n3 4\n5\n", "833333340\n"], ["3\n4 5 6\n7 8\n", "300000004\n"], ["4\n4 6 8 24\n20 22 1207\n", "250000119\n"], ["9\n88 225 365 687 4333 10759 30685 60189 90560\n306 241 336 406 342 86884 86885 86886\n", "94380764\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 决赛] 朔望", "background": "Syzygy，中文译作朔望，表示三个或三个以上的天体大致位于同一直线上。本题中主要探讨母恒星与至少两颗行星位于同一直线上的情况。\n", "description": "在一个理想的行星系中，所有行星在同一平面内围绕共同的单一母恒星作匀速圆周的公转运动，且公转方向相同（如同为逆时针）。我们定义这样的行星系的 Syzygy 指数为平均每年发生的所有（含母恒星的）朔望的稀有程度之和，其中单次朔望的稀有程度是与产生连线的**行星**数量 $x$ 有关的常数 $w_x$；如果在行星系中同时发生多个朔望但不位于同一直线上，则对每条直线上的行星分别统计稀有程度。\n\n现有一理想的包含 $n$ 颗行星的行星系，其中从内到外第 $i$ 颗行星绕母恒星公转周期为 $t_i$ 年（根据开普勒第三定律可知 $t_i$ 单调递增）。假设存在某一时刻，所有 $n$ 颗行星位于同一条以母恒星为端点的射线上。请求出该系统的 Syzygy  指数。", "inputFormat": "第一行输入一个正整数 $n$（$2\\le n\\le 20$），表示该单星系统中行星的数量。\n\n第二行输入 $n$ 个正整数 $t_1, t_2, \\cdots, t_n$，分别表示公转轨道从内到外各行星的公转周期。保证 $1\\le t_1 < t_2 < \\cdots < t_n\\le 10^9$。\n\n第三行输入 $(n-1)$ 个正整数 $w_2, w_3, \\cdots, w_n$（$1\\le w_i\\le 10^9$），分别表示发生不同数量的行星参与的朔望的稀有程度。", "outputFormat": "输出该行星系的 Syzygy 指数。显然 Syzygy 指数是一个有理数；不妨假设其化为最简分式后的形式为 $p/q$（即其中 $p, q$ 互质），请输出 $x$ 使得 $qx\\equiv p \\pmod{10^9 + 7}$ 且 $0\\le x<10^9 + 7$。可以证明，在本题数据范围下，$x$ 存在且唯一。\n", "hint": "**样例解释 1**\n\n不妨假设 $T=0$ 时刻两颗行星位于同一以母恒星为端点的射线上。由于两颗行星的公转周期的最小公倍数为 $12$ 年，且两颗行星的会合周期也恰为 $\\displaystyle\\frac{1}{\\displaystyle\\left|\\frac{1}{3}-\\frac{1}{4}\\right|}=12$ 年，故可取 $T\\in[0, 12)$ 年的行星系的运行情况作为研究对象。$T$ 取 $[0, 12)$ 中整数值时，行星系的运行情况分别如下各图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/okkdl28r.png)\n\n可以证明，在 $12$ 年的周期内，两颗行星仅发生如上图所示的 $2$ 次朔望（分别为 $T=0$ 时的内行星凌/外行星冲及 $T=6$ 年的合）。因此，该行星系的 Syzygy 指数为\n\n$$\n\\frac{2\\times 5}{12} = \\frac{5}{6} \\equiv 833333340 \\pmod{10^9 +7}.\n$$\n\n**样例解释 2**\n\n同理设 $T=0$ 时刻三颗行星位于同一以母恒星为端点的射线上。由 $\\mathrm{lcm}(4, 5, 6)=60$，可取 $T\\in[0,60)$ 年的行星系的运行情况作为研究对象。在这段时间内，发生的所有含母恒星的朔望如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/df7frwd2.png)\n\n\n因此，该行星系的 Syzygy 指数为\n\n$$\n\\frac{14\\times 7+2\\times 8}{60}=\\frac{19}{10}\\equiv300000004 \\pmod{10^9+7}.\n$$\n\n**样例解释 3**\n\n同理设 $T=0$ 时刻四颗行星位于同一以母恒星为端点的射线上。由 $\\mathrm{lcm}(4, 6, 8, 24)=24$，可取 $T\\in[0,24)$ 年的行星系的运行情况作为研究对象。在这段时间内，发生的所有含母恒星的朔望如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5930jff7.png)\n\n因此，该行星系的 Syzygy 指数为\n\n$$\n\\frac{20\\times 20+0\\times22+2\\times 1207}{24}=\\frac{1407}{12}\\equiv250000119 \\pmod{10^9+7}.\n$$\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 朔望", "background": "Syzygy，中文译作朔望，表示三个或三个以上的天体大致位于同一直线上。本题中主要探讨母恒星与至少两颗行星位于同一直线上的情况。\n", "description": "在一个理想的行星系中，所有行星在同一平面内围绕共同的单一母恒星作匀速圆周的公转运动，且公转方向相同（如同为逆时针）。我们定义这样的行星系的 Syzygy 指数为平均每年发生的所有（含母恒星的）朔望的稀有程度之和，其中单次朔望的稀有程度是与产生连线的**行星**数量 $x$ 有关的常数 $w_x$；如果在行星系中同时发生多个朔望但不位于同一直线上，则对每条直线上的行星分别统计稀有程度。\n\n现有一理想的包含 $n$ 颗行星的行星系，其中从内到外第 $i$ 颗行星绕母恒星公转周期为 $t_i$ 年（根据开普勒第三定律可知 $t_i$ 单调递增）。假设存在某一时刻，所有 $n$ 颗行星位于同一条以母恒星为端点的射线上。请求出该系统的 Syzygy  指数。", "inputFormat": "第一行输入一个正整数 $n$（$2\\le n\\le 20$），表示该单星系统中行星的数量。\n\n第二行输入 $n$ 个正整数 $t_1, t_2, \\cdots, t_n$，分别表示公转轨道从内到外各行星的公转周期。保证 $1\\le t_1 < t_2 < \\cdots < t_n\\le 10^9$。\n\n第三行输入 $(n-1)$ 个正整数 $w_2, w_3, \\cdots, w_n$（$1\\le w_i\\le 10^9$），分别表示发生不同数量的行星参与的朔望的稀有程度。", "outputFormat": "输出该行星系的 Syzygy 指数。显然 Syzygy 指数是一个有理数；不妨假设其化为最简分式后的形式为 $p/q$（即其中 $p, q$ 互质），请输出 $x$ 使得 $qx\\equiv p \\pmod{10^9 + 7}$ 且 $0\\le x<10^9 + 7$。可以证明，在本题数据范围下，$x$ 存在且唯一。\n", "hint": "**样例解释 1**\n\n不妨假设 $T=0$ 时刻两颗行星位于同一以母恒星为端点的射线上。由于两颗行星的公转周期的最小公倍数为 $12$ 年，且两颗行星的会合周期也恰为 $\\displaystyle\\frac{1}{\\displaystyle\\left|\\frac{1}{3}-\\frac{1}{4}\\right|}=12$ 年，故可取 $T\\in[0, 12)$ 年的行星系的运行情况作为研究对象。$T$ 取 $[0, 12)$ 中整数值时，行星系的运行情况分别如下各图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/okkdl28r.png)\n\n可以证明，在 $12$ 年的周期内，两颗行星仅发生如上图所示的 $2$ 次朔望（分别为 $T=0$ 时的内行星凌/外行星冲及 $T=6$ 年的合）。因此，该行星系的 Syzygy 指数为\n\n$$\n\\frac{2\\times 5}{12} = \\frac{5}{6} \\equiv 833333340 \\pmod{10^9 +7}.\n$$\n\n**样例解释 2**\n\n同理设 $T=0$ 时刻三颗行星位于同一以母恒星为端点的射线上。由 $\\mathrm{lcm}(4, 5, 6)=60$，可取 $T\\in[0,60)$ 年的行星系的运行情况作为研究对象。在这段时间内，发生的所有含母恒星的朔望如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/df7frwd2.png)\n\n\n因此，该行星系的 Syzygy 指数为\n\n$$\n\\frac{14\\times 7+2\\times 8}{60}=\\frac{19}{10}\\equiv300000004 \\pmod{10^9+7}.\n$$\n\n**样例解释 3**\n\n同理设 $T=0$ 时刻四颗行星位于同一以母恒星为端点的射线上。由 $\\mathrm{lcm}(4, 6, 8, 24)=24$，可取 $T\\in[0,24)$ 年的行星系的运行情况作为研究对象。在这段时间内，发生的所有含母恒星的朔望如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5930jff7.png)\n\n因此，该行星系的 Syzygy 指数为\n\n$$\n\\frac{20\\times 20+0\\times22+2\\times 1207}{24}=\\frac{1407}{12}\\equiv250000119 \\pmod{10^9+7}.\n$$\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10549", "type": "P", "difficulty": 5, "samples": [["1\n2 3\n1 1\n2 1\n2 2\n", "OvO"], ["1\n4 4\n1 1\n1 2\n4 2\n", "QAQ"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 决赛] 简单博弈", "background": "", "description": "有 $k$ 个棋盘。每个棋盘大小为 $n\\times m$ ，上面有 $3$ 个位置是 $0$，其他是 $1$。\n\n现在 A 和 B 轮流操作，每次操作需要指定一个棋盘，在该棋盘上选定一行或者选定一列或者选定一行一列，将其全部变成 $0$。但是要保证操作前后棋盘至少一个格子数字变了。\n\n不能操作就输了。问是否先手必胜。\n", "inputFormat": "输入的第一行包含一个正整数 $k$ 表示棋盘总数，保证 $1 \\le k \\le 10^5$。\n\n接下来 $k$ 组数据，第 $i$ 组数据共 4 行，描述第 $i$ 张棋盘的样子：\n\n* 第 1 行用空格隔开的两个正整数 $n,m$ 分别表示棋盘的行数和列数，保证 $1\\le n,m \\le 500$。\n* 第 2-4 行，每行用空格隔开的两个正整数 $x,y$ 表示该棋盘上为 $0$ 的位置，保证互不相同且 $1\\leq x\\leq n, 1\\leq y\\leq m$ 。", "outputFormat": "如果先手必胜，输出一个字符串 `OvO`，否则输出一个字符串 `QAQ`。\n", "hint": "一开始棋盘为：\n\n```\n011\n001\n```\n\n先手只需要选中第 1 行第 2 列即可全部清零，从而后手无法操作，先手获胜。\n\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 简单博弈", "background": "", "description": "有 $k$ 个棋盘。每个棋盘大小为 $n\\times m$ ，上面有 $3$ 个位置是 $0$，其他是 $1$。\n\n现在 A 和 B 轮流操作，每次操作需要指定一个棋盘，在该棋盘上选定一行或者选定一列或者选定一行一列，将其全部变成 $0$。但是要保证操作前后棋盘至少一个格子数字变了。\n\n不能操作就输了。问是否先手必胜。\n", "inputFormat": "输入的第一行包含一个正整数 $k$ 表示棋盘总数，保证 $1 \\le k \\le 10^5$。\n\n接下来 $k$ 组数据，第 $i$ 组数据共 4 行，描述第 $i$ 张棋盘的样子：\n\n* 第 1 行用空格隔开的两个正整数 $n,m$ 分别表示棋盘的行数和列数，保证 $1\\le n,m \\le 500$。\n* 第 2-4 行，每行用空格隔开的两个正整数 $x,y$ 表示该棋盘上为 $0$ 的位置，保证互不相同且 $1\\leq x\\leq n, 1\\leq y\\leq m$ 。", "outputFormat": "如果先手必胜，输出一个字符串 `OvO`，否则输出一个字符串 `QAQ`。\n", "hint": "一开始棋盘为：\n\n```\n011\n001\n```\n\n先手只需要选中第 1 行第 2 列即可全部清零，从而后手无法操作，先手获胜。\n\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10550", "type": "P", "difficulty": 5, "samples": [["10 5\n1 1 0 0 0 0 0 1 1 1 \n1 1 1 1 1 1 1 1 1 1 \n4 6\n2 4\n2 6\n7 10\n4 7\n", "0\n0\n0\n1\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 决赛] 贸易", "background": "", "description": "小 Z 生活的学校就像是一条链，直径很长，宽度很窄。\n\n具体来说，这里有一个长度为 $n$ 的序列，每个位置有一个属性 $a_i\\in \\{0/1\\}$ 和一个类型 $c_i$，在这里有一些贸易事件会发生。\n\n小 Z 从左往右通过这个序列，若当前遇到一个 $0$ 属性的节点，则小 Z 可以购入至多一个 $c_i$ 类型的物品，若当前遇到一个 $1$ 属性的节点，则小 Z 可以卖出至多一个 $c_i$ 类型的物品，显然，在小 Z 没有这种类型的物品时是不能卖出的。\n\n一次合法的交易定义为从某个节点买入，并在某个节点卖出，注意，你需要保证在最后小 Z 手里不存在任何东西。\n\n给出 $q$ 次询问，每次小 Z 从 $l_i$ 顺序走到 $r_i$，问：最大合法交易次数是多少。", "inputFormat": "第一行两个正整数 $n,q$。\n\n接下来一行 $n$ 个数，第 $i$ 个表示 $a_i$。\n\n接下来一行 $n$ 个数，第 $i$ 个表示 $c_i$。\n\n接下来 $q$ 行，每行两个数表示 $l_i,r_i$。\n", "outputFormat": "输出共 $q$ 行，每行一个数表示当前这个询问中的最大合法交易次数。", "hint": "对于所有数据，满足 $1\\le n,q\\le5\\times 10^5,1\\le c_i\\le n,1\\le l_i\\le r_i\\le n,a_i\\in\\{0,1\\}$。\n\n请注意输入输出效率。\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 贸易", "background": "", "description": "小 Z 生活的学校就像是一条链，直径很长，宽度很窄。\n\n具体来说，这里有一个长度为 $n$ 的序列，每个位置有一个属性 $a_i\\in \\{0/1\\}$ 和一个类型 $c_i$，在这里有一些贸易事件会发生。\n\n小 Z 从左往右通过这个序列，若当前遇到一个 $0$ 属性的节点，则小 Z 可以购入至多一个 $c_i$ 类型的物品，若当前遇到一个 $1$ 属性的节点，则小 Z 可以卖出至多一个 $c_i$ 类型的物品，显然，在小 Z 没有这种类型的物品时是不能卖出的。\n\n一次合法的交易定义为从某个节点买入，并在某个节点卖出，注意，你需要保证在最后小 Z 手里不存在任何东西。\n\n给出 $q$ 次询问，每次小 Z 从 $l_i$ 顺序走到 $r_i$，问：最大合法交易次数是多少。", "inputFormat": "第一行两个正整数 $n,q$。\n\n接下来一行 $n$ 个数，第 $i$ 个表示 $a_i$。\n\n接下来一行 $n$ 个数，第 $i$ 个表示 $c_i$。\n\n接下来 $q$ 行，每行两个数表示 $l_i,r_i$。\n", "outputFormat": "输出共 $q$ 行，每行一个数表示当前这个询问中的最大合法交易次数。", "hint": "对于所有数据，满足 $1\\le n,q\\le5\\times 10^5,1\\le c_i\\le n,1\\le l_i\\le r_i\\le n,a_i\\in\\{0,1\\}$。\n\n请注意输入输出效率。\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
{"pid": "P10551", "type": "P", "difficulty": 7, "samples": [["5\n3 4\n2 5\n1 6\n2 240117\n3 378140683\n", "280\n0\n4\n451142875\n980338319\n"]], "limits": {"time": [1000, 1000], "memory": [524288, 524288]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 决赛] 连向未来", "background": "1 是烟消云散的过去。\n\n2 是转瞬即逝的现在。\n\n3 是遥不可及的未来。\n\n过去的迷惘和烦恼连向了现在。如果梦想的热度至今不曾改变，那么不妨将迷惘和烦恼作为宝贵的经验。\n\n现在也终将连向未来。通往未来的大门必定藏在世界上的某个角落。虽然可能无法简单寻得，但若不向前伸出双手，就无从触及。\n\n想要创造从现在开始的崭新的时间，就需要将大家相连。1、2 和 3，缺一不可。只身一人所无法实现的目标，集齐众人的力量就必能跨过。就算形单影只时已足够努力奋斗，如果连在一起时都能各自加倍拼搏，那么不妨同舟共济，同音共律。", "description": "给定一个 $N\\times M$ 的网格。求在每个格子中分别填入 $1$，$2$ 或 $3$ 的方案数，使得填入后存在至少一种将具有公共边的格子分别相连的方案，满足：\n\n- 每个填有 $1$ 或 $3$ 的格子**恰好**与相邻的任意一个填有 $2$ 的格子相连；\n\n- 每个填有 $2$ 的格子**恰好**与相邻的任意一个填有 $1$ 的格子及任意一个填有 $3$ 的格子分别相连。", "inputFormat": "输入第一行包括一个正整数 $T$，表示该测试点中的数据组数。保证 $1\\le T\\le 100$。\n\n接下来 $T$ 行，每行包含两个由空格隔开的正整数 $N$ 和 $M$，表示网格的大小。保证 $1\\le N\\le 3$，$1\\le M\\le 10^9$。", "outputFormat": "对每组数据输出一行，每行包括一个非负整数，表示填数方案数对 $998,244,353$ 取模之后的结果。", "hint": "不是相遇会带来离别，而是离别会指引新的相遇。\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 决赛] 连向未来", "background": "1 是烟消云散的过去。\n\n2 是转瞬即逝的现在。\n\n3 是遥不可及的未来。\n\n过去的迷惘和烦恼连向了现在。如果梦想的热度至今不曾改变，那么不妨将迷惘和烦恼作为宝贵的经验。\n\n现在也终将连向未来。通往未来的大门必定藏在世界上的某个角落。虽然可能无法简单寻得，但若不向前伸出双手，就无从触及。\n\n想要创造从现在开始的崭新的时间，就需要将大家相连。1、2 和 3，缺一不可。只身一人所无法实现的目标，集齐众人的力量就必能跨过。就算形单影只时已足够努力奋斗，如果连在一起时都能各自加倍拼搏，那么不妨同舟共济，同音共律。", "description": "给定一个 $N\\times M$ 的网格。求在每个格子中分别填入 $1$，$2$ 或 $3$ 的方案数，使得填入后存在至少一种将具有公共边的格子分别相连的方案，满足：\n\n- 每个填有 $1$ 或 $3$ 的格子**恰好**与相邻的任意一个填有 $2$ 的格子相连；\n\n- 每个填有 $2$ 的格子**恰好**与相邻的任意一个填有 $1$ 的格子及任意一个填有 $3$ 的格子分别相连。", "inputFormat": "输入第一行包括一个正整数 $T$，表示该测试点中的数据组数。保证 $1\\le T\\le 100$。\n\n接下来 $T$ 行，每行包含两个由空格隔开的正整数 $N$ 和 $M$，表示网格的大小。保证 $1\\le N\\le 3$，$1\\le M\\le 10^9$。", "outputFormat": "对每组数据输出一行，每行包括一个非负整数，表示填数方案数对 $998,244,353$ 取模之后的结果。", "hint": "不是相遇会带来离别，而是离别会指引新的相遇。\n\n\n**来源与致谢**\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。\n\n数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>", "locale": "zh-CN"}}}
