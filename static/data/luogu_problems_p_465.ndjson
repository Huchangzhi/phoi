{"pid": "P10432", "type": "P", "difficulty": 6, "samples": [["5 2\n0 6\n1 1\n0 5\n2 1\n1 2", "8"], ["5 100000\n0 6\n1 1\n0 5\n2 1\n1 2", "100010"], ["8 8\n0 36\n1 47\n2 95\n0 59\n1 54\n0 95\n1 87\n2 92", "108"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 滑雪 2 / Ski 2", "background": "", "description": "JOI 先生管理着 IOI 高原上一家著名的滑雪度假村，他决定为滑雪度假村开业 15 周年庆祝活动而在相邻的 KOI 高原上建造一家新的滑雪度假村。\n\nKOI 高原有 $N$ 个点，编号从 $1$ 到 $N$。目前，第 $i$ 个点（$1 \\leq i \\leq N$）的海拔高度为 $H_i$ 米，并且高原上的每个点都没有连接起来的滑道。此外，每个点都配备了一个未使用的连接设施。\n\nJOI 先生的目标是在高原上的一个点上建造 KOI 酒店，然后建造一些滑道连接高原上的每个点，以便人们可以从任何一个点滑雪到酒店。具体来说，JOI 先生将按照以下步骤建造滑雪度假村：\n\n1. 进行以下筑堤工作任意次数（可能为零）：选择一个点 $i$，将点 $i$ 的海拔高度增加 1 米。此工作的成本为每次操作 $K$。\n\n2. 从 $N$ 个点中选择一个点，并在那里建造 KOI 酒店。\n\n3. 进行以下扩展工作任意次数（可能为零）：选择一个点 $i$，在点 $i$ 建造一个连接设施。此工作的成本为每次操作 $C_i$。\n\n4. 对于除了 KOI 酒店所在点之外的剩余 $N - 1$ 个点，执行以下构建：设 $i$ 为该点的编号。选择另一个海拔严格较低的点 $j$，并使用点 $j$ 的一个未使用的连接设施，从点 $i$ 向点 $j$ 构建单向滑道。注意，如果没有海拔严格较低且有未使用连接设施的点 $j$，则无法实现目标。\n\n滑雪度假村的建造成本是进行堤岸工作和扩展工作的成本之和。\n\n编写一个程序，给定 KOI 高原上每个点的信息和每次筑堤工作的成本 $K$，找到建造滑雪度假村的最小成本。\n", "inputFormat": "从标准输入中读取以下数据：\n\n- $N$ $K$\n- $H_1$ $C_1$\n- $H_2$ $C_2$\n- ...\n- $H_N$ $C_N$\n", "outputFormat": "\n输出一行，构建滑雪度假村的最小成本。", "hint": "#### 样例解释 1\n\n例如，可以按以下方式建造滑雪度假村：\n\n1. 在点 $1$ 进行两次筑堤工作，在点 $5$ 进行一次。这些筑堤工作的总成本为 $2 \\times (2 + 1) = 6$。每个点的海拔高度变为 $2, 1, 0, 2, 2$ 米。\n2. 在点 $3$ 建造 KOI 酒店。\n3. 在点 $2$ 进行两次扩展工作。这些扩展工作的总成本为 $1 \\times 2 = 2$。结果，从点 $1$ 开始，每个点的连接设施数量变为 $1, 3, 1, 1, 1$。\n4. 构建 $4$ 条滑道：一条从点 $1$ 到点 $2$，一条从点 $2$ 到点 $3$，一条从点 $4$ 到点 $2$，一条从点 $5$ 到点 $2$。\n\n因此，构建滑雪度假村的成本为 $6 + 2 = 8$。由于无法以不超过 $7$ 的成本建造滑雪度假村，因此输出 $8$。\n\n此样例输入满足子任务 $3,4,5,6$ 的约束条件。\n\n#### 样例解释 2\n\n这个样例输入与示例输入 1 的唯一区别在于 $K$ 的值。\n\n这个样例输入满足子任务 $1, 3, 4, 5, 6$ 的约束条件。\n\n#### 样例解释 3\n\n此示例输入满足子任务 $2, 3, 4, 5, 6$ 的约束条件。\n\n### 约束条件\n\n- $1 \\leq N \\leq 300$\n- $1 \\leq K \\leq 10^9$\n- $0 \\leq H_i \\leq 10^9$（$1 \\leq i \\leq N$）\n- $1 \\leq C_i \\leq 10^9$（$1 \\leq i \\leq N$）\n- 给定的值均为整数。\n\n### 子任务\n\n- (5 分) $K \\geq 100,000$，$H_i \\leq 300$，$C_i \\leq 100$（$1 \\leq i \\leq N$）\n- (12 分) $H_1 \\leq H_i$，$C_1 \\leq C_i$，$H_i \\leq 300$（$1 \\leq i \\leq N$）\n- (9 分) $N \\leq 10$，$H_i \\leq 10$（$1 \\leq i \\leq N$）\n- (33 分) $N \\leq 40$，$H_i \\leq 40$（$1 \\leq i \\leq N$）\n- (27 分) $H_i \\leq 300$（$1 \\leq i \\leq N$）\n- (14 分) 无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 滑雪 2 / Ski 2", "background": "", "description": "JOI 先生管理着 IOI 高原上一家著名的滑雪度假村，他决定为滑雪度假村开业 15 周年庆祝活动而在相邻的 KOI 高原上建造一家新的滑雪度假村。\n\nKOI 高原有 $N$ 个点，编号从 $1$ 到 $N$。目前，第 $i$ 个点（$1 \\leq i \\leq N$）的海拔高度为 $H_i$ 米，并且高原上的每个点都没有连接起来的滑道。此外，每个点都配备了一个未使用的连接设施。\n\nJOI 先生的目标是在高原上的一个点上建造 KOI 酒店，然后建造一些滑道连接高原上的每个点，以便人们可以从任何一个点滑雪到酒店。具体来说，JOI 先生将按照以下步骤建造滑雪度假村：\n\n1. 进行以下筑堤工作任意次数（可能为零）：选择一个点 $i$，将点 $i$ 的海拔高度增加 1 米。此工作的成本为每次操作 $K$。\n\n2. 从 $N$ 个点中选择一个点，并在那里建造 KOI 酒店。\n\n3. 进行以下扩展工作任意次数（可能为零）：选择一个点 $i$，在点 $i$ 建造一个连接设施。此工作的成本为每次操作 $C_i$。\n\n4. 对于除了 KOI 酒店所在点之外的剩余 $N - 1$ 个点，执行以下构建：设 $i$ 为该点的编号。选择另一个海拔严格较低的点 $j$，并使用点 $j$ 的一个未使用的连接设施，从点 $i$ 向点 $j$ 构建单向滑道。注意，如果没有海拔严格较低且有未使用连接设施的点 $j$，则无法实现目标。\n\n滑雪度假村的建造成本是进行堤岸工作和扩展工作的成本之和。\n\n编写一个程序，给定 KOI 高原上每个点的信息和每次筑堤工作的成本 $K$，找到建造滑雪度假村的最小成本。\n", "inputFormat": "从标准输入中读取以下数据：\n\n- $N$ $K$\n- $H_1$ $C_1$\n- $H_2$ $C_2$\n- ...\n- $H_N$ $C_N$\n", "outputFormat": "\n输出一行，构建滑雪度假村的最小成本。", "hint": "#### 样例解释 1\n\n例如，可以按以下方式建造滑雪度假村：\n\n1. 在点 $1$ 进行两次筑堤工作，在点 $5$ 进行一次。这些筑堤工作的总成本为 $2 \\times (2 + 1) = 6$。每个点的海拔高度变为 $2, 1, 0, 2, 2$ 米。\n2. 在点 $3$ 建造 KOI 酒店。\n3. 在点 $2$ 进行两次扩展工作。这些扩展工作的总成本为 $1 \\times 2 = 2$。结果，从点 $1$ 开始，每个点的连接设施数量变为 $1, 3, 1, 1, 1$。\n4. 构建 $4$ 条滑道：一条从点 $1$ 到点 $2$，一条从点 $2$ 到点 $3$，一条从点 $4$ 到点 $2$，一条从点 $5$ 到点 $2$。\n\n因此，构建滑雪度假村的成本为 $6 + 2 = 8$。由于无法以不超过 $7$ 的成本建造滑雪度假村，因此输出 $8$。\n\n此样例输入满足子任务 $3,4,5,6$ 的约束条件。\n\n#### 样例解释 2\n\n这个样例输入与示例输入 1 的唯一区别在于 $K$ 的值。\n\n这个样例输入满足子任务 $1, 3, 4, 5, 6$ 的约束条件。\n\n#### 样例解释 3\n\n此示例输入满足子任务 $2, 3, 4, 5, 6$ 的约束条件。\n\n### 约束条件\n\n- $1 \\leq N \\leq 300$\n- $1 \\leq K \\leq 10^9$\n- $0 \\leq H_i \\leq 10^9$（$1 \\leq i \\leq N$）\n- $1 \\leq C_i \\leq 10^9$（$1 \\leq i \\leq N$）\n- 给定的值均为整数。\n\n### 子任务\n\n- (5 分) $K \\geq 100,000$，$H_i \\leq 300$，$C_i \\leq 100$（$1 \\leq i \\leq N$）\n- (12 分) $H_1 \\leq H_i$，$C_1 \\leq C_i$，$H_i \\leq 300$（$1 \\leq i \\leq N$）\n- (9 分) $N \\leq 10$，$H_i \\leq 10$（$1 \\leq i \\leq N$）\n- (33 分) $N \\leq 40$，$H_i \\leq 40$（$1 \\leq i \\leq N$）\n- (27 分) $H_i \\leq 300$（$1 \\leq i \\leq N$）\n- (14 分) 无额外约束。", "locale": "zh-CN"}}}
{"pid": "P10433", "type": "P", "difficulty": 7, "samples": [["5 5 2\n1 2\n2 3\n2 4\n3 5\n4 5\n00000\n1 5", "0\n1\n2\n2\n3"], ["5 5 2\n1 2\n2 3\n2 4\n3 5\n4 5\n01000\n1 5", "0\n1\n4\n4\n5"], ["5 5 2\n1 2\n2 3\n2 4\n3 5\n4 5\n01100\n1 5\n", "0\n1\n3\n3\n4"], ["8 7 5\n1 3\n5 7\n4 6\n2 6\n2 3\n7 8\n1 5\n10011010\n4 6 4 7 1", "4\n2\n3\n0\n10\n1\n17\n24"], ["12 13 3\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 8\n8 9\n9 10\n1 10\n2 9\n7 12\n11 12\n110000011101\n1 9 11\n", "0\n1\n4\n5\n6\n7\n8\n8\n4\n1\n13\n9"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["图论", "2024", "最短路", "凸包", "Ad-hoc", "根号分治", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 棋盘游戏 / Board Game", "background": "", "description": "有一个供 $K$ 个玩家玩的棋盘游戏。该游戏的棋盘由 $N$ 个编号从 1 到 $N$ 的单元格和 $M$ 条编号从 1 到 $M$ 的路径组成，其中路径 $j$（$1 ≤ j ≤ M$）双向连接着单元格 $U_j$ 和 $V_j$。\n\n棋盘上有两种类型的单元格：重新激活单元格和停止单元格。\n\n这些信息由长度为 $N$ 的字符串 $S$ 给出，$S$ 由 $0$ 和 $1$ 组成，其中 $S$ 的第 $i$ 个字符（$1 ≤ i ≤ N$）是 '0' 表示单元格 $i$ 是重新激活单元格，是 '1' 表示单元格 $i$ 是停止单元格。\n\n这个棋盘游戏由编号从 $1$ 到 $K$ 的 $K$ 个玩家进行。每个玩家都有自己的棋子，游戏从每个玩家将其棋子放在特定的单元格上开始。一开始，玩家 $p$（$1 \\leq p \\leq K$）将其棋子放在单元格 $X_p$ 上。注意，多个玩家的棋子可以放在同一个单元格上。\n\n游戏随着每个玩家轮流进行而进行，从玩家 1 开始，按数字顺序进行。在玩家 $p$ 完成其回合后，玩家 $p + 1$ 开始回合（如果 $p = K$，则玩家 1 开始回合）。每个玩家在其回合上执行以下操作：\n\n1. 选择与其棋子所在的单元格通过一条路径相连的一个单元格，并将其棋子移动到所选择的单元格上。\n2. 如果目标单元格是重新激活单元格，则重复步骤 1 并继续其回合。如果目标单元格是停止单元格，则结束其回合。\n\n代表日本参加这个棋盘游戏的包括 JOI 君在内的由 $K$ 名成员组成的团队，正在研究协作策略，以快速征服这个游戏。他们目前正在研究以下问题：\n\n为了将玩家 1 的棋子放置在单元格 $T$ 上，$K$ 名玩家需要的最小总移动次数是多少？即使在回合中途，如果玩家 1 的棋子被放置在单元格 $T$ 上，也认为满足条件。\n\n给定关于游戏棋盘和每个玩家棋子的初始放置位置的信息，编写一个程序来计算每个 $T = 1, 2, \\ldots, N$ 对应的问题的答案。", "inputFormat": "从标准输入中读取以下数据：\n\n- $N$ $M$ $K$\n- $U_1$ $V_1$\n- $U_2$ $V_2$\n- ...\n- $U_M$ $V_M$\n- $S$\n- $X_1,X_2,...,X_K$\n", "outputFormat": "输出 $N$ 行。在第 $T$ 行（$1 ≤ T ≤ N$）上，输出 $K$ 个玩家将玩家 1 的棋子放在单元格 $T$ 上所需的最小总移动次数。\n", "hint": "#### 样例解释 1\n\n由于玩家 $1$ 的棋子从单元格 $1$ 开始，所以 $T = 1$ 的答案是 $0$。\n\n对于 $T = 2$，在第一步中，玩家 $1$ 可以将他的棋子从单元格 $1$ 移动到单元格 $2$。因此，$T = 2$ 的答案是 $1$。\n\n对于 $T = 3$，他们可以通过以下 $2$ 步将玩家 $1$ 的棋子放置在单元格 $3$ 上：\n\n- 在第一步中，玩家 $1$ 将他的棋子从单元格 $1$ 移动到单元格 $2$。由于单元格 $2$ 是一个激活单元格，因此玩家 $1$ 的回合继续。\n- 在第二步中，玩家 $1$ 将他的棋子从单元格 $2$ 移动到单元格 $3$。\n\n由于他们无法在 $1$ 步或更少的步骤中将玩家 $1$ 的棋子放置在单元格 $3$ 上，所以 $T = 3$ 的答案是 $2$。\n\n类似地，可以验证 $T = 4$ 的答案为 $2$，$T = 5$ 的答案为 $3$。\n\n这个样例输入满足子任务 $1,4,5,6,7,8$ 的约束。\n\n\n\n#### 样例解释 2\n\n对于 $T = 3$，他们可以通过以下 4 步将玩家 $1$ 的棋子放置在单元格 $3$ 上：\n\n- 在第一步中，玩家 $1$ 将他的棋子从单元格 $1$ 移动到单元格 $2$。由于单元格 $2$ 是一个停止单元格，接下来轮到玩家 $2$。\n- 在第二步中，玩家 $2$ 将他的棋子从单元格 $5$ 移动到单元格 $3$。由于单元格 $3$ 是一个激活单元格，玩家 $2$ 的回合继续。\n- 在第三步中，玩家 $2$ 将他的棋子从单元格 $3$ 移动到单元格 $2$。由于单元格 $2$ 是一个停止单元格，接下来轮到玩家 $1$。\n- 在第四步中，玩家 $1$ 将他的棋子从单元格 $2$ 移动到单元格 $3$。\n\n由于他们无法在 $3$ 步或更少的步骤中将玩家 $1$ 的棋子放置在单元格 $3$ 上，所以 $T = 3$ 的答案是 $4$。\n\n这个样例输入满足子任务 $2,4,5,6,7,8$ 的约束。\n\n#### 样例解释 3\n\n这个样例输入满足子任务 $3, 4, 5, 6, 7,8$ 的约束。\n\n#### 样例解释 4\n\n这个样例输入满足子任务 $4, 6, 7,8$ 的约束。\n\n#### 样例解释 5\n\n这个样例输入满足子任务 $4, 6, 7,8$ 的约束。\n\n### 约束条件\n\n- $2 \\leq N \\leq 50,000$\n- $1 \\leq M \\leq 50,000$\n- $2 \\leq K \\leq 50,000$\n- $1 \\leq U_j < V_j \\leq N$（$1 \\leq j \\leq M$）\n- $(U_j, V_j)$，$(U_k, V_k)$（$1 \\leq j < k \\leq M$）\n- 可以通过经过多条路径从任何单元格到达任何其他单元格。\n- $S$ 是长度为 $N$ 的由 '0' 和 '1' 组成的字符串。\n- $1 \\leq X_p \\leq N$（$1 \\leq p \\leq K$）\n- $N$、$M$ 和 $K$ 都是整数。\n- $U_j$ 和 $V_j$ 是整数（$1 \\leq j \\leq M$）。\n- $X_p$ 是整数（$1 \\leq p \\leq K$）。\n\n### 子任务\n\n1. (3 分) 没有终止单元格。\n2. (7 分) 恰好有一个终止单元格。\n3. (7 分) 恰好有两个终止单元格。\n4. (19 分) $N \\leq 3,000$，$M \\leq 3,000$，$K \\leq 3,000$\n5. (23 分) $K = 2$\n6. (9 分) $K \\leq 100$\n7. (23 分) $N \\leq 30,000$，$M \\leq 30,000$，$K \\leq 30,000$\n8. (9 分) 没有额外的约束。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 棋盘游戏 / Board Game", "background": "", "description": "有一个供 $K$ 个玩家玩的棋盘游戏。该游戏的棋盘由 $N$ 个编号从 1 到 $N$ 的单元格和 $M$ 条编号从 1 到 $M$ 的路径组成，其中路径 $j$（$1 ≤ j ≤ M$）双向连接着单元格 $U_j$ 和 $V_j$。\n\n棋盘上有两种类型的单元格：重新激活单元格和停止单元格。\n\n这些信息由长度为 $N$ 的字符串 $S$ 给出，$S$ 由 $0$ 和 $1$ 组成，其中 $S$ 的第 $i$ 个字符（$1 ≤ i ≤ N$）是 '0' 表示单元格 $i$ 是重新激活单元格，是 '1' 表示单元格 $i$ 是停止单元格。\n\n这个棋盘游戏由编号从 $1$ 到 $K$ 的 $K$ 个玩家进行。每个玩家都有自己的棋子，游戏从每个玩家将其棋子放在特定的单元格上开始。一开始，玩家 $p$（$1 \\leq p \\leq K$）将其棋子放在单元格 $X_p$ 上。注意，多个玩家的棋子可以放在同一个单元格上。\n\n游戏随着每个玩家轮流进行而进行，从玩家 1 开始，按数字顺序进行。在玩家 $p$ 完成其回合后，玩家 $p + 1$ 开始回合（如果 $p = K$，则玩家 1 开始回合）。每个玩家在其回合上执行以下操作：\n\n1. 选择与其棋子所在的单元格通过一条路径相连的一个单元格，并将其棋子移动到所选择的单元格上。\n2. 如果目标单元格是重新激活单元格，则重复步骤 1 并继续其回合。如果目标单元格是停止单元格，则结束其回合。\n\n代表日本参加这个棋盘游戏的包括 JOI 君在内的由 $K$ 名成员组成的团队，正在研究协作策略，以快速征服这个游戏。他们目前正在研究以下问题：\n\n为了将玩家 1 的棋子放置在单元格 $T$ 上，$K$ 名玩家需要的最小总移动次数是多少？即使在回合中途，如果玩家 1 的棋子被放置在单元格 $T$ 上，也认为满足条件。\n\n给定关于游戏棋盘和每个玩家棋子的初始放置位置的信息，编写一个程序来计算每个 $T = 1, 2, \\ldots, N$ 对应的问题的答案。", "inputFormat": "从标准输入中读取以下数据：\n\n- $N$ $M$ $K$\n- $U_1$ $V_1$\n- $U_2$ $V_2$\n- ...\n- $U_M$ $V_M$\n- $S$\n- $X_1,X_2,...,X_K$\n", "outputFormat": "输出 $N$ 行。在第 $T$ 行（$1 ≤ T ≤ N$）上，输出 $K$ 个玩家将玩家 1 的棋子放在单元格 $T$ 上所需的最小总移动次数。\n", "hint": "#### 样例解释 1\n\n由于玩家 $1$ 的棋子从单元格 $1$ 开始，所以 $T = 1$ 的答案是 $0$。\n\n对于 $T = 2$，在第一步中，玩家 $1$ 可以将他的棋子从单元格 $1$ 移动到单元格 $2$。因此，$T = 2$ 的答案是 $1$。\n\n对于 $T = 3$，他们可以通过以下 $2$ 步将玩家 $1$ 的棋子放置在单元格 $3$ 上：\n\n- 在第一步中，玩家 $1$ 将他的棋子从单元格 $1$ 移动到单元格 $2$。由于单元格 $2$ 是一个激活单元格，因此玩家 $1$ 的回合继续。\n- 在第二步中，玩家 $1$ 将他的棋子从单元格 $2$ 移动到单元格 $3$。\n\n由于他们无法在 $1$ 步或更少的步骤中将玩家 $1$ 的棋子放置在单元格 $3$ 上，所以 $T = 3$ 的答案是 $2$。\n\n类似地，可以验证 $T = 4$ 的答案为 $2$，$T = 5$ 的答案为 $3$。\n\n这个样例输入满足子任务 $1,4,5,6,7,8$ 的约束。\n\n\n\n#### 样例解释 2\n\n对于 $T = 3$，他们可以通过以下 4 步将玩家 $1$ 的棋子放置在单元格 $3$ 上：\n\n- 在第一步中，玩家 $1$ 将他的棋子从单元格 $1$ 移动到单元格 $2$。由于单元格 $2$ 是一个停止单元格，接下来轮到玩家 $2$。\n- 在第二步中，玩家 $2$ 将他的棋子从单元格 $5$ 移动到单元格 $3$。由于单元格 $3$ 是一个激活单元格，玩家 $2$ 的回合继续。\n- 在第三步中，玩家 $2$ 将他的棋子从单元格 $3$ 移动到单元格 $2$。由于单元格 $2$ 是一个停止单元格，接下来轮到玩家 $1$。\n- 在第四步中，玩家 $1$ 将他的棋子从单元格 $2$ 移动到单元格 $3$。\n\n由于他们无法在 $3$ 步或更少的步骤中将玩家 $1$ 的棋子放置在单元格 $3$ 上，所以 $T = 3$ 的答案是 $4$。\n\n这个样例输入满足子任务 $2,4,5,6,7,8$ 的约束。\n\n#### 样例解释 3\n\n这个样例输入满足子任务 $3, 4, 5, 6, 7,8$ 的约束。\n\n#### 样例解释 4\n\n这个样例输入满足子任务 $4, 6, 7,8$ 的约束。\n\n#### 样例解释 5\n\n这个样例输入满足子任务 $4, 6, 7,8$ 的约束。\n\n### 约束条件\n\n- $2 \\leq N \\leq 50,000$\n- $1 \\leq M \\leq 50,000$\n- $2 \\leq K \\leq 50,000$\n- $1 \\leq U_j < V_j \\leq N$（$1 \\leq j \\leq M$）\n- $(U_j, V_j)$，$(U_k, V_k)$（$1 \\leq j < k \\leq M$）\n- 可以通过经过多条路径从任何单元格到达任何其他单元格。\n- $S$ 是长度为 $N$ 的由 '0' 和 '1' 组成的字符串。\n- $1 \\leq X_p \\leq N$（$1 \\leq p \\leq K$）\n- $N$、$M$ 和 $K$ 都是整数。\n- $U_j$ 和 $V_j$ 是整数（$1 \\leq j \\leq M$）。\n- $X_p$ 是整数（$1 \\leq p \\leq K$）。\n\n### 子任务\n\n1. (3 分) 没有终止单元格。\n2. (7 分) 恰好有一个终止单元格。\n3. (7 分) 恰好有两个终止单元格。\n4. (19 分) $N \\leq 3,000$，$M \\leq 3,000$，$K \\leq 3,000$\n5. (23 分) $K = 2$\n6. (9 分) $K \\leq 100$\n7. (23 分) $N \\leq 30,000$，$M \\leq 30,000$，$K \\leq 30,000$\n8. (9 分) 没有额外的约束。\n\n", "locale": "zh-CN"}}}
{"pid": "P10434", "type": "P", "difficulty": 7, "samples": [["3 3\n1 2 1\n0 2 2\n0 1 3\n2\n2 1\n2\n0 1", ""]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "交互题", "Special Judge", "最短路", "虚树", "Catalan 数", "通信题", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 间谍 3 / Spy 3", "background": "在本题中，你需要将两个文件合并成一个文件提交。\n\n**不要引入任何头文件**，并在文件头加入如下的内容：\n\n```cpp\n#include <vector>\nvoid answer(const std::vector<int> &);\n```", "description": "\n\n Aoi 和 Bitaro 是 JOI 国 国家情报局的间谍。这次他们的任务是对 IOI 国 进行潜入调查。Bitaro 潜入 IOI 国，而 Aoi 在 JOI 国 向 Bitaro 发出指示。\n\n潜入前，Aoi 和 Bitaro 得到了 IOI 国 的一张地图。IOI 国 有 $N$ 个城市，编号为 $0$ 到 $N-1$。此外，IOI 国 有 $M$ 条道路，编号为 $0$ 到 $M-1$。第 $i$ 条道路（$0 \\le i \\le M-1$）双向连接城市 $A_i$ 和城市 $B_i$，长度为 $C_i$。通过若干条道路可以在任意两座城市之间往来。Bitaro 在 IOI 国 内通过这些道路在城市间移动。另外，共有 $Q$ 个调查计划。第 $j$ 个计划（$0 \\le j \\le Q-1$）要调查 IOI 国 的城市 $T_j$。\n\n以上信息最初同时告知了 Aoi 和 Bitaro。随后，Bitaro 开始潜入 IOI 国。\n\nBitaro 设法甩开了无数追兵，击败了刺客，最终成功潜入 IOI 国 的城市 $0$。然而，由于潜入行动极其艰难，Bitaro 遗失了关于 IOI 国 的部分信息。具体而言，Bitaro 丢失了 $K$ 条道路的长度信息，即道路 $X_0, X_1, \\dots, X_{K-1}$。换言之，Bitaro 已不知道 $C_{X_0}, C_{X_1}, \\dots, C_{X_{K-1}}$ 的数值。注意，尽管 Bitaro 丢失了这些信息，Aoi 仍然掌握它们。\n\nBitaro 立刻向 Aoi 报告了他所遗失的道路长度信息是哪些。\n\n为了完成任务，Bitaro 希望从城市 $0$ 出发，分别找到到每个被 $Q$ 个调查计划锁定的城市的最短路径。\n\nAoi 将向 Bitaro 发送一个只包含字符 ‘0’ 或 ‘1’ 的字符串以协助他。由于存在被截获的风险，Aoi 希望尽量减少发送的内容。\n\n给定关于 IOI 国 的信息、调查计划以及 Bitaro 所遗失信息的道路，请编写程序实现 Aoi 的发送策略；同时，编写程序实现 Bitaro 在其掌握的信息与 Aoi 发送的字符串下寻找最短路径的策略。\n\n### 实现细节\n\n你需要提交 $2$ 个文件。\n\n第一个文件为 `Aoi.cpp`。该文件用于实现 Aoi 的策略，并应实现以下函数。程序需通过预处理指令 `#include` 包含 `Aoi.h`。\n\n* `std::string aoi(int N, int M, int Q, int K, std::vector<int> A, std::vector<int> B, std::vector<long long> C, std::vector<int> T, std::vector<int> X)`\n\n此函数在每个测试用例中只被调用一次。\n* 参数 $N$ 是 IOI 国 中的城市数量。\n* 参数 $M$ 是 IOI 国 中的道路数量。\n* 参数 $Q$ 是调查计划的数量。\n* 参数 $K$ 是 Bitaro 遗失长度信息的道路条数。\n* 参数 $A, B, C$ 为长度为 $M$ 的数组。表示第 $i$ 条道路（$0 \\le i \\le M-1$）双向连接城市 $A[i]$ 与城市 $B[i]$，长度为 $C[i]$。\n* 参数 $T$ 为长度为 $Q$ 的数组。表示第 $j$ 个计划（$0 \\le j \\le Q-1$）要调查的城市为 $T[j]$。\n* 参数 $X$ 为长度为 $K$ 的数组。表示 Bitaro 遗失长度信息的道路为 $X[0], X[1], \\dots, X[K-1]$。\n* 返回值为 Aoi 向 Bitaro 发送的字符串 $s$。\n* 字符串 $s$ 的每个字符必须是 ‘0’ 或 ‘1’。若不满足此条件，你的程序将被判定为 **Wrong Answer [1]**。\n* 字符串 $s$ 的长度最多为 $12000$。若不满足此条件，你的程序将被判定为 **Wrong Answer [2]**。\n\n第二个文件为 `Bitaro.cpp`。该文件用于实现 Bitaro 的策略，并应实现以下函数。程序需通过预处理指令 `#include` 包含 `Bitaro.h`。\n\n* `void bitaro(int N, int M, int Q, int K, std::vector<int> A, std::vector<int> B, std::vector<long long> C, std::vector<int> T, std::vector<int> X, std::string s)`\n\n此函数会在 `aoi` 函数被调用之后且仅被调用一次。\n* 参数 $N$ 是 IOI 国 中的城市数量。\n* 参数 $M$ 是 IOI 国 中的道路数量。\n* 参数 $Q$ 是调查计划的数量。\n* 参数 $K$ 是 Bitaro 遗失长度信息的道路条数。\n* 参数 $A, B, C$ 为长度为 $M$ 的数组。表示第 $i$ 条道路（$0 \\le i \\le M-1$）双向连接城市 $A[i]$ 与城市 $B[i]$，长度为 $C[i]$。\n* 参数 $T$ 为长度为 $Q$ 的数组。表示第 $j$ 个计划（$0 \\le j \\le Q-1$）要调查的城市为 $T[j]$。\n* 参数 $X$ 为长度为 $K$ 的数组。表示 Bitaro 遗失长度信息的道路为 $X[0], X[1], \\dots, X[K-1]$。\n* 参数 $s$ 是一个每个字符均为 ‘0’ 或 ‘1’ 的字符串，表示 Aoi 发送给 Bitaro 的字符串。\n\n在 `Bitaro.cpp` 中，你的程序可以调用如下函数。\n\n```cpp\nvoid answer(const std::vector<int> &e)\n```\n\n* 在第 $(j+1)$ 次调用（$0 \\le j \\le Q-1$）该函数时，你需要回答从城市 $0$ 到第 $j$ 个调查计划目标城市 $T_j$ 的最短路径。\n* 参数 `e` 是一个数组，表示从城市 $0$ 到城市 $T_j$ 的最短路径所经过的道路序列。\n* 设数组 `e` 的长度为 $n$。元素 `e[0], e[1], \\ldots, e[n-1]` 是该最短路径上按行进顺序经过的道路的编号。\n* 若存在多条最短路径，任选其一作为答案即可。\n* 参数 `e` 的每个元素必须在 $0$ 到 $M-1$ 之间。若不满足此条件，你的程序将被判定为 **Wrong Answer [3]**。\n* 参数 `e` 所指示的道路序列必须构成一条从城市 $0$ 到城市 $T_j$ 的路径。更正式地，它必须满足以下条件。\n    * 存在一列数字 $u_0, u_1, \\ldots, u_n$ 使得\n        * $u_0 = 0$。\n        * $u_n = T_j$。\n        * 道路 $e[k]$（$0 \\le k \\le n-1$）连接城市 $u_k$ 与城市 $u_{k+1}$。\n    * 若不满足这些条件，你的程序将被判定为 **Wrong Answer [4]**。\n* 若参数 `e` 指示的道路序列并非所有从城市 $0$ 到城市 $T_j$ 的路径中长度最短的一条，你的程序将被判定为 **Wrong Answer [5]**。这里，路径长度定义为所用道路长度之和。\n* 函数 `answer` 必须被调用恰好 $Q$ 次。若在 `bitaro` 函数结束时，对 `answer` 的调用次数不等于 $Q$，你的程序将被判定为 **Wrong Answer [6]**。\n\n### 重要注意事项\n\n* 你的程序可以为内部使用实现其他函数，或使用全局变量。提交的文件将与评测程序一起编译，形成单个可执行文件。所有全局变量与内部函数应声明在未命名命名空间中，以避免与其他文件冲突。评测时会分别以 Aoi 进程与 Bitaro 进程运行。Aoi 进程与 Bitaro 进程不能共享全局变量。\n* 你的程序不得使用标准输入与标准输出。你的程序不得以任何方式与其他文件通信。但你可以向标准错误输出调试信息。\n\n### 编译与测试运行\n\n你可以从比赛网页下载包含样例评测器的压缩包，用于本地测试。压缩包中也包含你程序的样例源文件。\n\n样例评测器文件为 `grader.cpp`。为测试你的程序，请将 `grader.cpp`、`Aoi.cpp`、`Bitaro.cpp`、`Aoi.h`、`Bitaro.h` 放在同一目录下，并运行以下命令进行编译。你也可以运行压缩包内的 `compile.sh`。\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp Aoi.cpp Bitaro.cpp\n```\n\n当编译成功时，将生成可执行文件 `grader`。\n\n注意，实际评测器不同于样例评测器。样例评测器作为单进程执行，从标准输入读取数据，并向标准输出与标准错误输出写出结果。\n", "inputFormat": "\n样例评测器从标准输入读取如下数据。\n\n> $N$ $M$\\\n> $A_0$ $B_0$ $C_0$\\\n> $A_1$ $B_1$ $C_1$\\\n> $A_{M-1}$ $B_{M-1}$ $C_{M-1}$\\\n> $Q$\\\n> $T_0$ $T_1$ $\\cdots$ $T_{Q-1}$\\\n> $K$\\\n> $X_0$ $X_1$ $\\cdots$ $X_{K-1}$\n", "outputFormat": "\n样例评测器向标准输出与标准错误输出输出如下信息（引号仅为说明）。\n\n* 若你的程序被判为 **Wrong Answer [1], [2], [3], [4], 或 [6]**，样例评测器会在标准错误输出写出其类型，如 “Wrong Answer [1]”。标准输出不会输出任何内容。\n* 否则，`aoi` 函数返回的字符串 $s$ 的长度会以 “Accepted: 2024” 的格式输出到标准错误输出。此外，在第 $(j+1)$ 次（$0 \\le j \\le Q-1$）对 `answer` 的调用中，路径长度会输出到标准输出的第 $(j+1)$ 行。样例评测程序 **不会检查** 该路径是否最短。\n\n若你的程序同时满足多种 Wrong Answer 的条件，样例评测器仅报告其中一种。", "hint": "\n### 示例通信\n\n下面给出一个样例评测器的输入及相应的函数调用。\n\n| 样例输入 1 | 调用 | 返回值 |\n|---|---|---|\n| $$\\texttt{3 3}\\\\ \\texttt{1 2 1} \\\\ \\texttt{0 2 2} \\\\ \\texttt{0 1 3} \\\\ \\texttt{2} \\\\ \\texttt{2 1} \\\\ \\texttt{2} \\\\ \\texttt{0 1}$$ | `aoi(3, 3, 2, 2, [1, 0, 0], [2, 2, 1], [1, 2, 3], [2, 1], [0, 1])` |  |\n| ^ | | `\"101001\"` |\n| ^ | `bitaro(3, 3, 2, 2, [1, 0, 0], [2, 2, 1], [-1, -1, 3], [2, 1], [0, 1], \"101001\")` | |\n| ^ | `answer([1])` | |\n| ^ | `answer([1, 0])` | |\n\n从城市 $0$ 到城市 $1$ 的最短路径，可以按顺序经过道路 $1$ 和 $0$，或者仅经过道路 $2$。因此，在本样例的第二次对 `answer` 的调用中，调用 `answer([2])` 也是可以接受的。\n\n从比赛网站下载的文件 `sample-01-in.txt` 与输入样例 $1$ 相对应。压缩包中的 `sample-01-in.txt` 与 `sample-02-in.txt` 可作为样例评测器的输入。\n\n### 约束\n\n所有输入数据均满足以下条件：\n\n* $2 \\le N \\le 10000$。\n* $1 \\le M \\le 20000$。\n* $1 \\le Q \\le 16$。\n* $1 \\le K \\le 300$。\n* $0 \\le A_i < B_i \\le N-1$（$0 \\le i \\le M-1$）。\n* $(A_i, B_i) \\ne (A_j, B_j)$（$0 \\le i < j \\le M-1$）。\n* $1 \\le C_i \\le 10^{12}$（$0 \\le i \\le M-1$）。\n* $1 \\le T_j \\le N-1$（$0 \\le j \\le Q-1$）。\n* $T_j \\ne T_k$（$0 \\le j < k \\le Q-1$）。\n* $0 \\le X_k \\le M-1$（$0 \\le k \\le K-1$）。\n* $X_k \\ne X_l$（$0 \\le k < l \\le K-1$）。\n* 通过若干条道路可以在任意两座城市之间往来。\n* 所有输入值均为整数。\n\n### 评分\n\n若你的程序在任意测试用例中被判定为 **Wrong Answer [1] - [6]**（见实现细节）或出现任意类型的运行时错误（TLE、MLE、异常结束等），你的得分为 $0$ 分。\n\n否则，评分依据为在本题所有测试用例中，函数 `aoi` 返回的字符串 $s$ 的最大长度 $L$。\n\n* 若 $1561 \\le L \\le 12000$，得分为 $\\left\\lfloor \\dfrac{100\\,000}{L-560} \\right\\rfloor$。\n* 若 $0 \\le L \\le 1560$，得分为 $100$ 分。\n\n其中，$\\lfloor x \\rfloor$ 表示不超过 $x$ 的最大整数。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[JOIST 2024] Spy 3", "background": "", "description": "\nAoi and Bitaro are spies belonging to the National Information Bureau of JOI country. Their mission this time is to conduct undercover investigation into the IOI country. Bitaro infiltrates into the IOI country, while Aoi gives instructions to Bitaro from the JOI country.\n\nBefore the infiltration, Aoi and Bitaro obtained a map of the IOI country. The IOI country has $N$ cities, numbered from $0$ to $N-1$. Moreover, there are $M$ roads in the IOI country, numbered from $0$ to $M-1$. Road $i$ ($0 \\le i \\le M-1$) connects city $A_i$ and city $B_i$ bidirectionally, with a length of $C_i$. It is possible to travel between any pair of cities by passing some roads. Bitaro moves between cities in the IOI country by passing these roads. Additionally, there are $Q$ investigation plans. The $j$-th plan ($0 \\le j \\le Q-1$) involves investigating city $T_j$ in the IOI country.\n\nAll the information above were first given to both Aoi and Bitaro. Then, Bitaro proceeded with the infiltration into the IOI country.\n\nBitaro successfully evaded numerous pursuers, defeated assassins, and finally managed to infiltrate into city $0$ of the IOI country. However, due to the extremely difficult nature of the infiltration operation, Bitaro lost some of the information about the IOI country. Specifically, Bitaro lost information about the length of $K$ roads, namely the roads $X_0, X_1, \\dots, X_{K-1}$. In other words, Bitaro no longer knows the values of $C_{X_0}, C_{X_1}, \\dots, C_{X_{K-1}}$. Note that while Bitaro lost this information, Aoi still retains it.\n\nBitaro immediately reported to Aoi which road lengths' information he had lost.\n\nTo accomplish the mission, Bitaro wants to find a shortest path from city $0$ to each of the cities targeted by the $Q$ investigation plans.\n\nAoi will send Bitaro a string where each character is either '0' or '1' to assist him. Due to the risk of interception, Aoi wants to minimize the content sent to Bitaro.\n\nWrite a program to implement Aoi's strategy for sending a string to Bitaro, given the information about the IOI country, the investigation plans, and the roads Bitaro lost information about. Also, write a program to implement Bitaro's strategy for finding the shortest paths given the information he possesses and the string sent by Aoi.\n\n### Implementation Details\n\nYou should submit $2$ files.\n\nThe first file is `Aoi.cpp`. This file is intended to implement Aoi's strategy and should implement the following functions. The program should include `Aoi.h` using the preprocessor directive `#include`.\n\n*   `std::string aoi(int N, int M, int Q, int K, std::vector<int> A, std::vector<int> B, std::vector<long long> C, std::vector<int> T, std::vector<int> X)`\n\nThis function is called only once for each test case.\n*   The parameter $N$ is the number of cities in IOI Kingdom $N$.\n*   The parameter $M$ is the number of roads in IOI Kingdom $M$.\n*   The parameter $Q$ is the number of investigation plans $Q$.\n*   The parameter $K$ is the number of roads that Bitaro lost the length information of, denoted by $K$.\n*   The parameters $A, B, C$ are arrays of length $M$. They mean the road $i$ ($0 \\le i \\le M-1$) connects the city $A[i]$ and the city $B[i]$ bidirectionally, with a length of $C[i]$.\n*   The parameter $T$ is an array of length $Q$. It means the $j$-th plan ($0 \\le j \\le Q-1$) involves investigating city $T[j]$.\n*   The parameter $X$ is an array of length $K$. It indicates that Bitaro lost the length information of roads $X[0], X[1], \\dots, X[K-1]$.\n*   The return value is the string $s$ that Aoi sends to Bitaro.\n*   Each character of the string $s$ must be either '0' or '1'. If this condition is not met, your program will be judged as **Wrong Answer [1]**.\n*   The length of string $s$ must be at most $12000$. If this condition is not met, your program will be judged as **Wrong Answer [2]**.\n\nThe second file is `Bitaro.cpp`. This file is intended to implement Bitaro's strategy and should implement the following functions. The program should include `Bitaro.h` using the preprocessor directive `#include`.\n\n*   `void bitaro(int N, int M, int Q, int K, std::vector<int> A, std::vector<int> B, std::vector<long long> C, std::vector<int> T, std::vector<int> X, std::string s)`\n\nThis function is called only once after the function `aoi` is called.\n*   The parameter $N$ is the number of cities in IOI Kingdom $N$.\n*   The parameter $M$ is the number of roads in IOI Kingdom $M$.\n*   The parameter $Q$ is the number of investigation plans $Q$.\n*   The parameter $K$ is the number of roads that Bitaro lost the length information of, denoted by $K$.\n*   The parameters $A, B, C$ are arrays of length $M$. They mean the road $i$ ($0 \\le i \\le M-1$) connects the city $A[i]$ and the city $B[i]$ bidirectionally, with a length of $C[i]$.\n*   The parameter $T$ is an array of length $Q$. It means the $j$-th plan ($0 \\le j \\le Q-1$) involves investigating city $T[j]$.\n*   The parameter $X$ is an array of length $K$. It indicates that Bitaro lost the length information of roads $X[0], X[1], \\dots, X[K-1]$.\n*   The argument $s$ is a string where each character is either '0' or '1', representing the string sent by Aoi to Bitaro.\n\n Within Bitaro.cpp, your program can call the following function.\n\n```cpp\nvoid answer(const std::vector<int> &e)\n```\n\n* In the $(j+1)$-th call ($0 \\le j \\le Q-1$) to this function, you have to answer the shortest path from city 0 to city $T_j$, which is the target of the $j$-th investigation plan.\n* The parameter `e` is an array that represents the shortest path from city 0 to city $T_j$.\n* Let $n$ be the length of the array `e`. The elements $e[0], e[1], \\ldots, e[n-1]$ are the indices of roads in the shortest path from city 0 to city $T_j$, in the order of traversal.\n* If there are multiple possible shortest paths, any of them can be chosen as the answer.\n* Each element of the parameter `e` must be between 0 and $M-1$. If this condition is not met, your program will be judged as **Wrong Answer [3]**.\n* The sequence of roads indicated by the argument `e` must form a path from city 0 to city $T_j$. More formally, it must satisfy the following conditions.\n    * There exists a sequence of numbers $u_0, u_1, \\ldots, u_n$ such that\n        * $u_0 = 0$.\n        * $u_n = T_j$.\n        * The road $e[k]$ (where $0 \\le k \\le n-1$) connects city $u_k$ and city $u_{k+1}$.\n    * If these conditions are not met, your program will be judged as **Wrong Answer [4]**.\n* If the sequence of roads indicated by the argument `e` is not the shortest path from city 0 to city $T_j$ among all paths starting from city 0 and ending at city $T_j$, your program will be judged as **Wrong Answer [5]**. Here, the length of the path is defined as the sum of the lengths of the roads used.\n* The function `answer` must be called exactly $Q$ times. If the number of calls to the function `answer` is not equal to $Q$ at the end of the execution of the function `bitaro`, your program will be judged as **Wrong Answer [6]**.\n\n### Important Notices\n\n* Your program can implement other functions for internal use, or use global variables. Submitted files will be compiled with the grader, and become a single executable file. All global variables and internal functions should be declared in an unnamed namespace to avoid confliction with other files. When it is graded, it will be executed as two processes of Aoi and Bitaro. The process of Aoi and the process of Bitaro cannot share global variables.\n* Your program must not use the standard input and the standard output. Your program must not communicate with other files by any methods. However, your program may output debugging information to the standard error.\n\n### Compilation and Test Run\n\nYou can download an archive file from the contest webpage which contains the sample grader to test your program. The archive file also contains a sample source file of your program.\n\nThe sample grader is the file `grader.cpp`. In order to test your program, put `grader.cpp`, `Aoi.cpp`, `Bitaro.cpp`, `Aoi.h`, `Bitaro.h` in the same directory, and run the following command to compile your programs. Instead, you may run `compile.sh` contained in the archive file.\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp Aoi.cpp Bitaro.cpp\n```\n\nWhen the compilation succeeds, the executable file `grader` is generated.\n\nNote that the actual grader is different from the sample grader. The sample grader will be executed as a single process, which will read input data from the standard input and write the results to the standard output and the standard error output.\n", "inputFormat": "\nThe sample grader reads the following data from the standard input.\n\n\n> $N$ $M$\\\n> $A_0$ $B_0$ $C_0$\\\n> $A_1$ $B_1$ $C_1$\\\n> $A_{M-1}$ $B_{M-1}$ $C_{M-1}$\\\n> $Q$\\\n> $T_0$ $T_1$ $\\cdots$ $T_{Q-1}$\\\n> $K$\\\n> $X_0$ $X_1$ $\\cdots$ $X_{K-1}$\n", "outputFormat": "\nThe sample grader outputs the following information to the standard output and the standard error output (quotes for clarity).\n\n* If your program is judged as **Wrong Answer [1], [2], [3], [4], or [6]**, the sample grader writes its type as \"Wrong Answer [1]\" in the standard error output. Nothing will be output to the standard output.\n* If not, the length of the returned string $s$ from the function `aoi` will be output to the standard error output in the format \"Accepted: 2024\". Additionally, the length of the path in the $(j+1)$-th call ($0 \\le j \\le Q-1$) to the `answer` function will be output to $(j+1)$-th line of the standard output. The sample grading program **does not check** whether the path is the shortest.\n\nIf your program meets the conditions of several types of Wrong Answer, the sample grader reports only one of them.\n", "hint": "### Sample Communication\n\nHere is a sample input for the sample grader and corresponding function calls.\n\n| Sample Input 1 | Call | Return value |\n|---|---|---|\n| $$\\texttt{3 3}\\\\ \\texttt{1 2 1} \\\\ \\texttt{0 2 2} \\\\ \\texttt{0 1 3} \\\\ \\texttt{2} \\\\ \\texttt{2 1} \\\\ \\texttt{2} \\\\ \\texttt{0 1}$$ | `aoi(3, 3, 2, 2, [1, 0, 0], [2, 2, 1], [1, 2, 3], [2, 1], [0, 1])` |  |\n| ^ | | `\"101001\"` |\n| ^ | `bitaro(3, 3, 2, 2, [1, 0, 0], [2, 2, 1], [-1, -1, 3], [2, 1], [0, 1], \"101001\")` | |\n| ^ | `answer([1])` | |\n| ^| `answer([1, 0])` | |\n\nThe shortest path from city 0 to city 1, is achieved either by traversing roads 1 and 0 in this order, or simply passing through road 2. Therefore, for the second call to the `answer` function in this sample, it is also acceptable to call `answer([2])`.\n\nThe file that can be downloaded from the contest site, `sample-01-in.txt`, corresponds to input example 1.\nThe files `sample-01-in.txt` and `sample-02-in.txt` included in the downloadable files from the contest site can be used as input for the sample grader.\n\n\n### Constraints\n\nAll input data satisfies the following conditions:\n\n* $2 \\le N \\le 10000$.\n* $1 \\le M \\le 20000$.\n* $1 \\le Q \\le 16$.\n* $1 \\le K \\le 300$.\n* $0 \\le A_i < B_i \\le N-1$ ($0 \\le i \\le M-1$).\n* $(A_i, B_i) \\ne (A_j, B_j)$ ($0 \\le i < j \\le M-1$).\n* $1 \\le C_i \\le 10^{12}$ ($0 \\le i \\le M-1$).\n* $1 \\le T_j \\le N-1$ ($0 \\le j \\le Q-1$).\n* $T_j \\ne T_k$ ($0 \\le j < k \\le Q-1$).\n* $0 \\le X_k \\le M-1$ ($0 \\le k \\le K-1$).\n* $X_k \\ne X_l$ ($0 \\le k < l \\le K-1$).\n* You can travel from any city to any other city by traversing some roads.\n* All input values are integers.\n\n### Grading\n\nIf your program is judged as any type of **Wrong Answer [1] - [6]** (see Implementation Details) or any type of runtime errors (TLE (Time Limit Exceeded), MLE (Memory Limit Exceeded), Abnormal End, etc.) in any of the test cases, your score is 0 points.\n\nOtherwise, the grading is based on the maximum length of the returned string $s$ from the function `aoi`, denoted as $L$, across all test cases for this task.\n\n* If $1561 \\le L \\le 12000$, the score is $\\left\\lfloor \\frac{100\\,000}{L-560} \\right\\rfloor$ points.\n* If $0 \\le L \\le 1560$, the score is 100 points.\n\nHere, $\\lfloor x \\rfloor$ represents the largest integer that is not greater than $x$.\n\n", "locale": "en"}, "zh-CN": {"title": "[JOIST 2024] 间谍 3 / Spy 3", "background": "在本题中，你需要将两个文件合并成一个文件提交。\n\n**不要引入任何头文件**，并在文件头加入如下的内容：\n\n```cpp\n#include <vector>\nvoid answer(const std::vector<int> &);\n```", "description": "\n\n Aoi 和 Bitaro 是 JOI 国 国家情报局的间谍。这次他们的任务是对 IOI 国 进行潜入调查。Bitaro 潜入 IOI 国，而 Aoi 在 JOI 国 向 Bitaro 发出指示。\n\n潜入前，Aoi 和 Bitaro 得到了 IOI 国 的一张地图。IOI 国 有 $N$ 个城市，编号为 $0$ 到 $N-1$。此外，IOI 国 有 $M$ 条道路，编号为 $0$ 到 $M-1$。第 $i$ 条道路（$0 \\le i \\le M-1$）双向连接城市 $A_i$ 和城市 $B_i$，长度为 $C_i$。通过若干条道路可以在任意两座城市之间往来。Bitaro 在 IOI 国 内通过这些道路在城市间移动。另外，共有 $Q$ 个调查计划。第 $j$ 个计划（$0 \\le j \\le Q-1$）要调查 IOI 国 的城市 $T_j$。\n\n以上信息最初同时告知了 Aoi 和 Bitaro。随后，Bitaro 开始潜入 IOI 国。\n\nBitaro 设法甩开了无数追兵，击败了刺客，最终成功潜入 IOI 国 的城市 $0$。然而，由于潜入行动极其艰难，Bitaro 遗失了关于 IOI 国 的部分信息。具体而言，Bitaro 丢失了 $K$ 条道路的长度信息，即道路 $X_0, X_1, \\dots, X_{K-1}$。换言之，Bitaro 已不知道 $C_{X_0}, C_{X_1}, \\dots, C_{X_{K-1}}$ 的数值。注意，尽管 Bitaro 丢失了这些信息，Aoi 仍然掌握它们。\n\nBitaro 立刻向 Aoi 报告了他所遗失的道路长度信息是哪些。\n\n为了完成任务，Bitaro 希望从城市 $0$ 出发，分别找到到每个被 $Q$ 个调查计划锁定的城市的最短路径。\n\nAoi 将向 Bitaro 发送一个只包含字符 ‘0’ 或 ‘1’ 的字符串以协助他。由于存在被截获的风险，Aoi 希望尽量减少发送的内容。\n\n给定关于 IOI 国 的信息、调查计划以及 Bitaro 所遗失信息的道路，请编写程序实现 Aoi 的发送策略；同时，编写程序实现 Bitaro 在其掌握的信息与 Aoi 发送的字符串下寻找最短路径的策略。\n\n### 实现细节\n\n你需要提交 $2$ 个文件。\n\n第一个文件为 `Aoi.cpp`。该文件用于实现 Aoi 的策略，并应实现以下函数。程序需通过预处理指令 `#include` 包含 `Aoi.h`。\n\n* `std::string aoi(int N, int M, int Q, int K, std::vector<int> A, std::vector<int> B, std::vector<long long> C, std::vector<int> T, std::vector<int> X)`\n\n此函数在每个测试用例中只被调用一次。\n* 参数 $N$ 是 IOI 国 中的城市数量。\n* 参数 $M$ 是 IOI 国 中的道路数量。\n* 参数 $Q$ 是调查计划的数量。\n* 参数 $K$ 是 Bitaro 遗失长度信息的道路条数。\n* 参数 $A, B, C$ 为长度为 $M$ 的数组。表示第 $i$ 条道路（$0 \\le i \\le M-1$）双向连接城市 $A[i]$ 与城市 $B[i]$，长度为 $C[i]$。\n* 参数 $T$ 为长度为 $Q$ 的数组。表示第 $j$ 个计划（$0 \\le j \\le Q-1$）要调查的城市为 $T[j]$。\n* 参数 $X$ 为长度为 $K$ 的数组。表示 Bitaro 遗失长度信息的道路为 $X[0], X[1], \\dots, X[K-1]$。\n* 返回值为 Aoi 向 Bitaro 发送的字符串 $s$。\n* 字符串 $s$ 的每个字符必须是 ‘0’ 或 ‘1’。若不满足此条件，你的程序将被判定为 **Wrong Answer [1]**。\n* 字符串 $s$ 的长度最多为 $12000$。若不满足此条件，你的程序将被判定为 **Wrong Answer [2]**。\n\n第二个文件为 `Bitaro.cpp`。该文件用于实现 Bitaro 的策略，并应实现以下函数。程序需通过预处理指令 `#include` 包含 `Bitaro.h`。\n\n* `void bitaro(int N, int M, int Q, int K, std::vector<int> A, std::vector<int> B, std::vector<long long> C, std::vector<int> T, std::vector<int> X, std::string s)`\n\n此函数会在 `aoi` 函数被调用之后且仅被调用一次。\n* 参数 $N$ 是 IOI 国 中的城市数量。\n* 参数 $M$ 是 IOI 国 中的道路数量。\n* 参数 $Q$ 是调查计划的数量。\n* 参数 $K$ 是 Bitaro 遗失长度信息的道路条数。\n* 参数 $A, B, C$ 为长度为 $M$ 的数组。表示第 $i$ 条道路（$0 \\le i \\le M-1$）双向连接城市 $A[i]$ 与城市 $B[i]$，长度为 $C[i]$。\n* 参数 $T$ 为长度为 $Q$ 的数组。表示第 $j$ 个计划（$0 \\le j \\le Q-1$）要调查的城市为 $T[j]$。\n* 参数 $X$ 为长度为 $K$ 的数组。表示 Bitaro 遗失长度信息的道路为 $X[0], X[1], \\dots, X[K-1]$。\n* 参数 $s$ 是一个每个字符均为 ‘0’ 或 ‘1’ 的字符串，表示 Aoi 发送给 Bitaro 的字符串。\n\n在 `Bitaro.cpp` 中，你的程序可以调用如下函数。\n\n```cpp\nvoid answer(const std::vector<int> &e)\n```\n\n* 在第 $(j+1)$ 次调用（$0 \\le j \\le Q-1$）该函数时，你需要回答从城市 $0$ 到第 $j$ 个调查计划目标城市 $T_j$ 的最短路径。\n* 参数 `e` 是一个数组，表示从城市 $0$ 到城市 $T_j$ 的最短路径所经过的道路序列。\n* 设数组 `e` 的长度为 $n$。元素 `e[0], e[1], \\ldots, e[n-1]` 是该最短路径上按行进顺序经过的道路的编号。\n* 若存在多条最短路径，任选其一作为答案即可。\n* 参数 `e` 的每个元素必须在 $0$ 到 $M-1$ 之间。若不满足此条件，你的程序将被判定为 **Wrong Answer [3]**。\n* 参数 `e` 所指示的道路序列必须构成一条从城市 $0$ 到城市 $T_j$ 的路径。更正式地，它必须满足以下条件。\n    * 存在一列数字 $u_0, u_1, \\ldots, u_n$ 使得\n        * $u_0 = 0$。\n        * $u_n = T_j$。\n        * 道路 $e[k]$（$0 \\le k \\le n-1$）连接城市 $u_k$ 与城市 $u_{k+1}$。\n    * 若不满足这些条件，你的程序将被判定为 **Wrong Answer [4]**。\n* 若参数 `e` 指示的道路序列并非所有从城市 $0$ 到城市 $T_j$ 的路径中长度最短的一条，你的程序将被判定为 **Wrong Answer [5]**。这里，路径长度定义为所用道路长度之和。\n* 函数 `answer` 必须被调用恰好 $Q$ 次。若在 `bitaro` 函数结束时，对 `answer` 的调用次数不等于 $Q$，你的程序将被判定为 **Wrong Answer [6]**。\n\n### 重要注意事项\n\n* 你的程序可以为内部使用实现其他函数，或使用全局变量。提交的文件将与评测程序一起编译，形成单个可执行文件。所有全局变量与内部函数应声明在未命名命名空间中，以避免与其他文件冲突。评测时会分别以 Aoi 进程与 Bitaro 进程运行。Aoi 进程与 Bitaro 进程不能共享全局变量。\n* 你的程序不得使用标准输入与标准输出。你的程序不得以任何方式与其他文件通信。但你可以向标准错误输出调试信息。\n\n### 编译与测试运行\n\n你可以从比赛网页下载包含样例评测器的压缩包，用于本地测试。压缩包中也包含你程序的样例源文件。\n\n样例评测器文件为 `grader.cpp`。为测试你的程序，请将 `grader.cpp`、`Aoi.cpp`、`Bitaro.cpp`、`Aoi.h`、`Bitaro.h` 放在同一目录下，并运行以下命令进行编译。你也可以运行压缩包内的 `compile.sh`。\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp Aoi.cpp Bitaro.cpp\n```\n\n当编译成功时，将生成可执行文件 `grader`。\n\n注意，实际评测器不同于样例评测器。样例评测器作为单进程执行，从标准输入读取数据，并向标准输出与标准错误输出写出结果。\n", "inputFormat": "\n样例评测器从标准输入读取如下数据。\n\n> $N$ $M$\\\n> $A_0$ $B_0$ $C_0$\\\n> $A_1$ $B_1$ $C_1$\\\n> $A_{M-1}$ $B_{M-1}$ $C_{M-1}$\\\n> $Q$\\\n> $T_0$ $T_1$ $\\cdots$ $T_{Q-1}$\\\n> $K$\\\n> $X_0$ $X_1$ $\\cdots$ $X_{K-1}$\n", "outputFormat": "\n样例评测器向标准输出与标准错误输出输出如下信息（引号仅为说明）。\n\n* 若你的程序被判为 **Wrong Answer [1], [2], [3], [4], 或 [6]**，样例评测器会在标准错误输出写出其类型，如 “Wrong Answer [1]”。标准输出不会输出任何内容。\n* 否则，`aoi` 函数返回的字符串 $s$ 的长度会以 “Accepted: 2024” 的格式输出到标准错误输出。此外，在第 $(j+1)$ 次（$0 \\le j \\le Q-1$）对 `answer` 的调用中，路径长度会输出到标准输出的第 $(j+1)$ 行。样例评测程序 **不会检查** 该路径是否最短。\n\n若你的程序同时满足多种 Wrong Answer 的条件，样例评测器仅报告其中一种。", "hint": "\n### 示例通信\n\n下面给出一个样例评测器的输入及相应的函数调用。\n\n| 样例输入 1 | 调用 | 返回值 |\n|---|---|---|\n| $$\\texttt{3 3}\\\\ \\texttt{1 2 1} \\\\ \\texttt{0 2 2} \\\\ \\texttt{0 1 3} \\\\ \\texttt{2} \\\\ \\texttt{2 1} \\\\ \\texttt{2} \\\\ \\texttt{0 1}$$ | `aoi(3, 3, 2, 2, [1, 0, 0], [2, 2, 1], [1, 2, 3], [2, 1], [0, 1])` |  |\n| ^ | | `\"101001\"` |\n| ^ | `bitaro(3, 3, 2, 2, [1, 0, 0], [2, 2, 1], [-1, -1, 3], [2, 1], [0, 1], \"101001\")` | |\n| ^ | `answer([1])` | |\n| ^ | `answer([1, 0])` | |\n\n从城市 $0$ 到城市 $1$ 的最短路径，可以按顺序经过道路 $1$ 和 $0$，或者仅经过道路 $2$。因此，在本样例的第二次对 `answer` 的调用中，调用 `answer([2])` 也是可以接受的。\n\n从比赛网站下载的文件 `sample-01-in.txt` 与输入样例 $1$ 相对应。压缩包中的 `sample-01-in.txt` 与 `sample-02-in.txt` 可作为样例评测器的输入。\n\n### 约束\n\n所有输入数据均满足以下条件：\n\n* $2 \\le N \\le 10000$。\n* $1 \\le M \\le 20000$。\n* $1 \\le Q \\le 16$。\n* $1 \\le K \\le 300$。\n* $0 \\le A_i < B_i \\le N-1$（$0 \\le i \\le M-1$）。\n* $(A_i, B_i) \\ne (A_j, B_j)$（$0 \\le i < j \\le M-1$）。\n* $1 \\le C_i \\le 10^{12}$（$0 \\le i \\le M-1$）。\n* $1 \\le T_j \\le N-1$（$0 \\le j \\le Q-1$）。\n* $T_j \\ne T_k$（$0 \\le j < k \\le Q-1$）。\n* $0 \\le X_k \\le M-1$（$0 \\le k \\le K-1$）。\n* $X_k \\ne X_l$（$0 \\le k < l \\le K-1$）。\n* 通过若干条道路可以在任意两座城市之间往来。\n* 所有输入值均为整数。\n\n### 评分\n\n若你的程序在任意测试用例中被判定为 **Wrong Answer [1] - [6]**（见实现细节）或出现任意类型的运行时错误（TLE、MLE、异常结束等），你的得分为 $0$ 分。\n\n否则，评分依据为在本题所有测试用例中，函数 `aoi` 返回的字符串 $s$ 的最大长度 $L$。\n\n* 若 $1561 \\le L \\le 12000$，得分为 $\\left\\lfloor \\dfrac{100\\,000}{L-560} \\right\\rfloor$。\n* 若 $0 \\le L \\le 1560$，得分为 $100$ 分。\n\n其中，$\\lfloor x \\rfloor$ 表示不超过 $x$ 的最大整数。\n\n", "locale": "zh-CN"}}}
{"pid": "P10435", "type": "P", "difficulty": 7, "samples": [["2\n1 2 6 3\n2 5\n4 3", "2"], ["9\n1 2 3 4 5 6 7 8 9 18 17 16 15 14 13 12 11 10\n2 7 4 1 7 6 4 10 6\n6 8 9 3 7 1 9 5 4\n", "8"], ["7\n13 16 18 18 21 22 22 23 23 21 19 17 15 14\n14 14 20 19 22 17 25\n24 15 18 25 24 19 11", "3"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 有趣的家庭菜园 5 / Growing Vegetables is Fun 5", "background": "", "description": "Bitaro，一个多年来一直热衷于园艺的人，计划从今年春天开始种植一种名为 Bita-radish 的植物。 \n\nBitaro 已经准备好了 $2N$ 个 Bita-radish 幼苗。这些幼苗从 $1$ 到 $2N$ 编号，Bitaro 计划按照这个顺序进行栽培。第 $i$ 个幼苗（$1 \\leq i \\leq 2N$）的大小为 $A_i$。Bitaro 希望每个幼苗都能得到足够的阳光，因此幼苗的大小满足以下条件：\n\n- $A_1 \\leq A_2 \\leq \\cdots \\leq A_N \\leq A_{N+1}$. \n- $A_{N+1} \\geq A_{N+2} \\geq \\cdots \\geq A_{2N-1} \\geq A_{2N} \\geq A_1$. \n\n注意，幼苗 $1$ 最小，幼苗 $N+1$ 最大。\n\nBitaro 还准备了 $N$ 个红色花盆和 $N$ 个蓝色花盆，每个花盆也有一定大小。第 $j$ 个（$1 \\leq j \\leq N$）红色花盆的大小是 $B_j$，第 $k$ 个（$1 \\leq k \\leq N$）蓝色花盆的大小是 $C_k$。Bitaro 在这总共 $2N$ 个花盆中各种植一株 Bita-radish 幼苗，并按某种顺序排列花盆，使幼苗按 $1,2,...,2N$ 顺序依次放入花盆中。\n\n考虑到外观，这 $2N$ 个花盆必须被安排在一个美观的顺序中。这里，美观的顺序意味着花盆的排列使得存在连续的 $N$ 个花盆颜色相同。更确切地说，一个花盆排列被称为是美观的，当且仅当存在一个整数 $l$，满足 $1 \\leq l \\leq N+1$，使得种植了幼苗 $l, l+1, \\ldots, l+N-1$ 的花盆颜色都相同。\n\n当尺寸为 $y$ 的幼苗种植在尺寸为 $x$ 的花盆中时，该对的栽培难度是绝对值 $|x-y|$。Bitaro 种植 Bita-radish 的工作量是 $2N$ 对花盆和幼苗中的**最大**栽培难度。编写一个程序，给定 Bita-radish 幼苗和花盆的信息，找到种植幼苗的最小可能 Bitaro 工作量值，并且花盆需要按美观的顺序排列。", "inputFormat": "从标准输入中读取以下数据：\n\n- $N$\n- $A_1$ $A_2$ ... $A_{2N}$\n- $B_1$ $B_2$ ... $B_N$\n- $C_1$ $C_2$ ... $C_N$", "outputFormat": "输出一个值，种植幼苗以使花盆按美观顺序排列时 Bitaro 工作量的最小可能值。\n", "hint": "#### 样例解释 1\n\n在这个样例输入中，Bitaro 可以通过以下方式种植幼苗来实现工作量为 $2$：\n\n- 将幼苗 $1$ 种植在第一个红色花盆中。这对的栽培难度是 $|2 - 1| = 1$。\n- 将幼苗 $2$ 种植在第二个蓝色花盆中。这对的栽培难度是 $|3 - 2| = 1$。\n- 将幼苗 $3$ 种植在第一个蓝色花盆中。这对的栽培难度是 $|4 - 6| = 2$。\n- 将幼苗 $4$ 种植在第二个红色花盆中。这对的栽培难度是 $|5 - 3| = 2$。\n\n种植了幼苗 $2$ 和 $3$ 的花盆的颜色都是蓝色，因此花盆是按美观顺序排列的。\n\n当种植幼苗以使花盆按美观顺序排列时，无法实现工作量小于 $2$。因此，输出为 $2$。\n\n这个样例输入满足所有子任务的约束条件。\n\n\n#### 样例解释 2\n\n这个样例输入满足子任务 $2,3,4,5$ 的约束条件。\n\n#### 样例解释 3\n\n这个样例输入满足子任务 $2,3,5$ 的约束条件。\n\n### 约束条件\n\n- $1 \\leq N \\leq 300,000$.\n- $1 \\leq A_i \\leq 10^9$ （$1 \\leq i \\leq 2N$）.\n- $1 \\leq B_j \\leq 10^9$ （$1 \\leq j \\leq N$）.\n- $1 \\leq C_k \\leq 10^9$ （$1 \\leq k \\leq N$）.\n- $A_1 \\leq A_2 \\leq \\cdots \\leq A_N \\leq A_{N+1}$.\n- $A_{N+1} \\geq A_{N+2} \\geq \\cdots \\geq A_{2N-1} \\geq A_{2N} \\geq A_1$.\n- 所有输入值都是整数。\n\n### 子任务\n\n1. (4 分) $N \\leq 5$。\n2. (5 分) $N \\leq 10$。\n3. (21 分) $N \\leq 2,000$。\n4. (37 分) 所有的 $A_i$ 的值都是不同的。另外，满足 $A_N < A_{2N}$。\n5. (33 分) 没有额外的约束条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 有趣的家庭菜园 5 / Growing Vegetables is Fun 5", "background": "", "description": "Bitaro，一个多年来一直热衷于园艺的人，计划从今年春天开始种植一种名为 Bita-radish 的植物。 \n\nBitaro 已经准备好了 $2N$ 个 Bita-radish 幼苗。这些幼苗从 $1$ 到 $2N$ 编号，Bitaro 计划按照这个顺序进行栽培。第 $i$ 个幼苗（$1 \\leq i \\leq 2N$）的大小为 $A_i$。Bitaro 希望每个幼苗都能得到足够的阳光，因此幼苗的大小满足以下条件：\n\n- $A_1 \\leq A_2 \\leq \\cdots \\leq A_N \\leq A_{N+1}$. \n- $A_{N+1} \\geq A_{N+2} \\geq \\cdots \\geq A_{2N-1} \\geq A_{2N} \\geq A_1$. \n\n注意，幼苗 $1$ 最小，幼苗 $N+1$ 最大。\n\nBitaro 还准备了 $N$ 个红色花盆和 $N$ 个蓝色花盆，每个花盆也有一定大小。第 $j$ 个（$1 \\leq j \\leq N$）红色花盆的大小是 $B_j$，第 $k$ 个（$1 \\leq k \\leq N$）蓝色花盆的大小是 $C_k$。Bitaro 在这总共 $2N$ 个花盆中各种植一株 Bita-radish 幼苗，并按某种顺序排列花盆，使幼苗按 $1,2,...,2N$ 顺序依次放入花盆中。\n\n考虑到外观，这 $2N$ 个花盆必须被安排在一个美观的顺序中。这里，美观的顺序意味着花盆的排列使得存在连续的 $N$ 个花盆颜色相同。更确切地说，一个花盆排列被称为是美观的，当且仅当存在一个整数 $l$，满足 $1 \\leq l \\leq N+1$，使得种植了幼苗 $l, l+1, \\ldots, l+N-1$ 的花盆颜色都相同。\n\n当尺寸为 $y$ 的幼苗种植在尺寸为 $x$ 的花盆中时，该对的栽培难度是绝对值 $|x-y|$。Bitaro 种植 Bita-radish 的工作量是 $2N$ 对花盆和幼苗中的**最大**栽培难度。编写一个程序，给定 Bita-radish 幼苗和花盆的信息，找到种植幼苗的最小可能 Bitaro 工作量值，并且花盆需要按美观的顺序排列。", "inputFormat": "从标准输入中读取以下数据：\n\n- $N$\n- $A_1$ $A_2$ ... $A_{2N}$\n- $B_1$ $B_2$ ... $B_N$\n- $C_1$ $C_2$ ... $C_N$", "outputFormat": "输出一个值，种植幼苗以使花盆按美观顺序排列时 Bitaro 工作量的最小可能值。\n", "hint": "#### 样例解释 1\n\n在这个样例输入中，Bitaro 可以通过以下方式种植幼苗来实现工作量为 $2$：\n\n- 将幼苗 $1$ 种植在第一个红色花盆中。这对的栽培难度是 $|2 - 1| = 1$。\n- 将幼苗 $2$ 种植在第二个蓝色花盆中。这对的栽培难度是 $|3 - 2| = 1$。\n- 将幼苗 $3$ 种植在第一个蓝色花盆中。这对的栽培难度是 $|4 - 6| = 2$。\n- 将幼苗 $4$ 种植在第二个红色花盆中。这对的栽培难度是 $|5 - 3| = 2$。\n\n种植了幼苗 $2$ 和 $3$ 的花盆的颜色都是蓝色，因此花盆是按美观顺序排列的。\n\n当种植幼苗以使花盆按美观顺序排列时，无法实现工作量小于 $2$。因此，输出为 $2$。\n\n这个样例输入满足所有子任务的约束条件。\n\n\n#### 样例解释 2\n\n这个样例输入满足子任务 $2,3,4,5$ 的约束条件。\n\n#### 样例解释 3\n\n这个样例输入满足子任务 $2,3,5$ 的约束条件。\n\n### 约束条件\n\n- $1 \\leq N \\leq 300,000$.\n- $1 \\leq A_i \\leq 10^9$ （$1 \\leq i \\leq 2N$）.\n- $1 \\leq B_j \\leq 10^9$ （$1 \\leq j \\leq N$）.\n- $1 \\leq C_k \\leq 10^9$ （$1 \\leq k \\leq N$）.\n- $A_1 \\leq A_2 \\leq \\cdots \\leq A_N \\leq A_{N+1}$.\n- $A_{N+1} \\geq A_{N+2} \\geq \\cdots \\geq A_{2N-1} \\geq A_{2N} \\geq A_1$.\n- 所有输入值都是整数。\n\n### 子任务\n\n1. (4 分) $N \\leq 5$。\n2. (5 分) $N \\leq 10$。\n3. (21 分) $N \\leq 2,000$。\n4. (37 分) 所有的 $A_i$ 的值都是不同的。另外，满足 $A_N < A_{2N}$。\n5. (33 分) 没有额外的约束条件。", "locale": "zh-CN"}}}
{"pid": "P10436", "type": "P", "difficulty": 7, "samples": [["5 3\n1 3\n2 2\n4 4\n1 3\n1 1\n2 3\n2 1\n4 4", "1 3"], ["2 2\n1 1\n2 2\n1 2\n2 1\n", ""], ["8 8\n5 2\n4 4\n1 3\n7 8\n3 1\n8 7\n6 5\n2 6\n1 4\n7 2\n8 8\n3 1\n5 6\n2 7\n6 3\n2 5", "3 4 5 8"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 卡牌收集 / Card Collection", "background": "", "description": "JOI 君对一款卡牌游戏中的卡牌收集充满热情。卡牌游戏中的每张卡牌都有两个整数，代表其强度和成本。为了获得一张新卡牌，JOI 君将 $N$ 张卡牌带到一个卡牌交换处。每张卡牌编号从 $1$ 到 $N$。第 $i$ 张卡牌（$1 \\leq i \\leq N$）的强度是 $S_i$，成本是 $V_i$。\n\n卡牌交换处有两台机器可供使用。如果你将两张卡牌 $A$ 和 $B$ 插入其中一台机器，你将能够获得满足以下条件的卡牌 $C$：\n\n- 如果你使用第一台机器，那么 $C$ 的强度等于 $A$ 和 $B$ 的强度中的最大值，并且 $C$ 的成本等于 $A$ 和 $B$ 的成本中的最大值。\n- 如果你使用第二台机器，那么 $C$ 的强度等于 $A$ 和 $B$ 的强度中的最小值，并且 $C$ 的成本等于 $A$ 和 $B$ 的成本中的最小值。\n\nJOI 君计划使用这些机器正好 $N - 1$ 次以获得一张新卡牌。为此，他将 $N$ 张卡牌按卡牌 $1$ 到卡牌 $N$ 的顺序依次排列。然后，他重复以下操作 $N - 1$ 次：\n\n- 选择两张相邻的卡牌，使用其中一台机器来得到一张新卡牌，并将新卡牌放在操作前所选两张卡牌的位置。\n\n在执行 $N-1$ 次操作后，JOI 君将只剩下一张卡牌。这张卡牌的强度和成本将取决于他执行的操作。\n\nJOI 君有一个希望在执行 $N-1$ 次操作后获得的卡牌列表。第 $j$ 张卡牌（$1 \\leq j \\leq M$）由一对整数 $(T_j, W_j)$ 表示，其中 $T_j$ 是第 $j$ 张卡牌的强度，$W_j$ 是第 $j$ 张卡牌的成本。编写一个程序，给定有关 JOI 君卡牌的信息以及他想获得的卡牌列表，确定在执行 $N-1$ 次操作后他可以获得的列表中的哪些卡牌。\n", "inputFormat": "从标准输入读取以下数据。\n\n- $N$ $M$\n- $S_1$ $V_1$\n- $S_2$ $V_2$\n- ...\n- $S_N$ $V_N$\n- $T_1$ $W_1$\n- $T_2$ $W_2$\n- ...\n- $T_M$ $W_M$", "outputFormat": "向标准输出写入一行，输出应按升序包含 JOI 君可以在执行 $N-1$ 次操作后获得的列表中所有卡牌的编号。\n", "hint": "#### 样例解释 1\n\n例如，JOI 君可以通过以下方式获得一张强度为 2，成本为 3 的卡牌：\n\n- 交出卡牌 4 和卡牌 5，获得一张强度为 1，成本为 1 的卡牌。\n- 交出卡牌 3 和第一次操作中获得的卡牌，获得一张强度为 1，成本为 1 的卡牌。\n- 交出卡牌 1 和卡牌 2，获得一张强度为 2，成本为 3 的卡牌。\n- 交出第二次和第三次操作中获得的卡牌，获得一张强度为 2，成本为 3 的卡牌。\n\n请注意，即使在第三次操作中获得了一张强度为 2，成本为 3 的卡牌，JOI 君仍需要执行最后一次操作。即使在某些操作后获得了某张卡牌，也可能在执行 $N-1$ 次操作后无法获得它。\n\n这个样例输入满足所有子任务的约束条件。\n\n#### 样例解释 2\n\n与此样例输出一样，如果在执行 $N-1$ 次操作后无法获得列表中的任何卡牌，则应输出一个空行。\n\n这个样例输入满足所有子任务的约束条件。\n\n#### 样例解释 3\n\n这个样例输入满足所有子任务的约束条件。\n\n\n### 约束条件\n\n- $2 \\leq N \\leq 200,000$．\n- $1 \\leq M \\leq 200,000$．\n- $1 \\leq S_i \\leq 10^9$ ($1 \\leq i \\leq N$)．\n- $1 \\leq V_i \\leq 10^9$ ($1 \\leq i \\leq N$)．\n- $1 \\leq T_j \\leq 10^9$ ($1 \\leq j \\leq M$)．\n- $1 \\leq W_j \\leq 10^9$ ($1 \\leq j \\leq M$)．\n- 给定的值均为整数。\n\n### 子任务\n\n1. (11 分) $N \\leq 20$，$M \\leq 10$．\n2. (38 分) $N \\leq 2,000$，$M \\leq 10$．\n3. (22 分) $M \\leq 10$．\n4. (29 分) 无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 卡牌收集 / Card Collection", "background": "", "description": "JOI 君对一款卡牌游戏中的卡牌收集充满热情。卡牌游戏中的每张卡牌都有两个整数，代表其强度和成本。为了获得一张新卡牌，JOI 君将 $N$ 张卡牌带到一个卡牌交换处。每张卡牌编号从 $1$ 到 $N$。第 $i$ 张卡牌（$1 \\leq i \\leq N$）的强度是 $S_i$，成本是 $V_i$。\n\n卡牌交换处有两台机器可供使用。如果你将两张卡牌 $A$ 和 $B$ 插入其中一台机器，你将能够获得满足以下条件的卡牌 $C$：\n\n- 如果你使用第一台机器，那么 $C$ 的强度等于 $A$ 和 $B$ 的强度中的最大值，并且 $C$ 的成本等于 $A$ 和 $B$ 的成本中的最大值。\n- 如果你使用第二台机器，那么 $C$ 的强度等于 $A$ 和 $B$ 的强度中的最小值，并且 $C$ 的成本等于 $A$ 和 $B$ 的成本中的最小值。\n\nJOI 君计划使用这些机器正好 $N - 1$ 次以获得一张新卡牌。为此，他将 $N$ 张卡牌按卡牌 $1$ 到卡牌 $N$ 的顺序依次排列。然后，他重复以下操作 $N - 1$ 次：\n\n- 选择两张相邻的卡牌，使用其中一台机器来得到一张新卡牌，并将新卡牌放在操作前所选两张卡牌的位置。\n\n在执行 $N-1$ 次操作后，JOI 君将只剩下一张卡牌。这张卡牌的强度和成本将取决于他执行的操作。\n\nJOI 君有一个希望在执行 $N-1$ 次操作后获得的卡牌列表。第 $j$ 张卡牌（$1 \\leq j \\leq M$）由一对整数 $(T_j, W_j)$ 表示，其中 $T_j$ 是第 $j$ 张卡牌的强度，$W_j$ 是第 $j$ 张卡牌的成本。编写一个程序，给定有关 JOI 君卡牌的信息以及他想获得的卡牌列表，确定在执行 $N-1$ 次操作后他可以获得的列表中的哪些卡牌。\n", "inputFormat": "从标准输入读取以下数据。\n\n- $N$ $M$\n- $S_1$ $V_1$\n- $S_2$ $V_2$\n- ...\n- $S_N$ $V_N$\n- $T_1$ $W_1$\n- $T_2$ $W_2$\n- ...\n- $T_M$ $W_M$", "outputFormat": "向标准输出写入一行，输出应按升序包含 JOI 君可以在执行 $N-1$ 次操作后获得的列表中所有卡牌的编号。\n", "hint": "#### 样例解释 1\n\n例如，JOI 君可以通过以下方式获得一张强度为 2，成本为 3 的卡牌：\n\n- 交出卡牌 4 和卡牌 5，获得一张强度为 1，成本为 1 的卡牌。\n- 交出卡牌 3 和第一次操作中获得的卡牌，获得一张强度为 1，成本为 1 的卡牌。\n- 交出卡牌 1 和卡牌 2，获得一张强度为 2，成本为 3 的卡牌。\n- 交出第二次和第三次操作中获得的卡牌，获得一张强度为 2，成本为 3 的卡牌。\n\n请注意，即使在第三次操作中获得了一张强度为 2，成本为 3 的卡牌，JOI 君仍需要执行最后一次操作。即使在某些操作后获得了某张卡牌，也可能在执行 $N-1$ 次操作后无法获得它。\n\n这个样例输入满足所有子任务的约束条件。\n\n#### 样例解释 2\n\n与此样例输出一样，如果在执行 $N-1$ 次操作后无法获得列表中的任何卡牌，则应输出一个空行。\n\n这个样例输入满足所有子任务的约束条件。\n\n#### 样例解释 3\n\n这个样例输入满足所有子任务的约束条件。\n\n\n### 约束条件\n\n- $2 \\leq N \\leq 200,000$．\n- $1 \\leq M \\leq 200,000$．\n- $1 \\leq S_i \\leq 10^9$ ($1 \\leq i \\leq N$)．\n- $1 \\leq V_i \\leq 10^9$ ($1 \\leq i \\leq N$)．\n- $1 \\leq T_j \\leq 10^9$ ($1 \\leq j \\leq M$)．\n- $1 \\leq W_j \\leq 10^9$ ($1 \\leq j \\leq M$)．\n- 给定的值均为整数。\n\n### 子任务\n\n1. (11 分) $N \\leq 20$，$M \\leq 10$．\n2. (38 分) $N \\leq 2,000$，$M \\leq 10$．\n3. (22 分) $M \\leq 10$．\n4. (29 分) 无额外约束。", "locale": "zh-CN"}}}
{"pid": "P10437", "type": "P", "difficulty": 6, "samples": [["3\n0 1 2\n0 1\n1 2\n0", "1"], ["3\n0 1 2\n0 1\n1 2\n2\n2 0\n0 2", "1\n0\n1"], ["7\n1 0 2 2 0 1 0\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6\n7\n0 0\n1 1\n2 0\n3 0\n4 2\n5 2\n6 2", "3\n0\n4\n4\n0\n4\n5\n5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2024", "交互题", "O2优化", "树链剖分", "动态 DP", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] JOI 之旅 / JOI Tour", "background": "提交时请不要引用 `joitour.h`。\n\n请不要使用 C++14 (GCC 9) 提交。", "description": "在 IOI 国，有 $N$ 个城市，编号为 $0$ 到 $N-1$，有 $N-1$ 条道路，编号为 $0$ 到 $N-2$。路 $j\\ (0\\le j\\le N-2)$ 双向连接城市 $U_j$ 和城市 $V_j$。你可以通过道路从一个城市到达另一其他城市。\n\nIOI 国的每个城市都有一家餐厅。在城市 $i\\ (0\\le i\\le N-1)$ 的餐厅类型用 $F_i$ 表示，具体来说：\n\n- $F_i=0$：果汁店\n- $F_i=1$：日式煎蛋卷店\n- $F_i=2$：冰淇淋店\n\n理惠女士是 IOI 国的导游，她正在规划一个叫做 **JOI 之旅**的观光计划。JOI 之旅中计划按如下顺序前往 $3$ 种餐厅：\n\n1. 选择有果汁店的城市 $i_0\\ (0\\le i_0\\le N-1)$，并从城市 $i_0$ 开始旅行。\n2. 前往城市 $i_0$ 的果汁店。\n3. 选择有日式煎蛋卷店的城市 $i_1\\ (0\\le i_1\\le N-1)$，并从城市 $i_0$ 出发乘公交车沿最短路径前往城市 $i_1$。\n4. 前往城市 $i_1$ 的日式煎蛋卷店。\n5. 选择有冰淇淋店的城市 $i_2\\ (0\\le i_2\\le N-1)$，并从城市 $i_1$ 出发乘公交车沿最短路径前往城市 $i_2$​。\n6. 前往城市 $i_2$​ 的冰淇淋店。\n7. 在城市 $i_2$ 结束行程。\n\n为了避免游客无聊，理惠女士决定选择三个城市 $i_0,i_1,i_2$ 满足它们不会经过相同的道路两次。我们称这样的 JOI 之旅是好的。为了帮助她找到理想的旅行计划，你被要求计算好的 JOI 之旅的数量。换句话说，你需要找到满足所有如下条件的三元组 $(i_0,i_1,i_2)$ 的个数：\n\n- 城市 $i_0$ 中的餐厅是果汁店。\n- 城市 $i_1$ 中的餐厅是日式煎蛋卷店。\n- 城市 $i_2$ 中的餐厅是冰淇淋店。\n- 当我们沿最短路径从城市 $i_0$ 移动到 $i_1$ 再移动到 $i_2$ 的过程中，不会经过相同的道路两次。\n\n在 IOI 国，会有 $Q$ 次餐厅类型改变的事件。当第 $(k+1)\\ (0\\le k\\le Q-1)$ 个事件发生时，会给出两个整数 $X_k$ 和 $Y_k$，满足 $0\\le X_k\\le N-1$ 且 $0\\le Y_k\\le 2$。然后，在城市 $X_k$ 的餐厅类型会变为 $Y_k$。也就是说，当 $Y_k=0,1,2$ 时，餐厅类型会分别变为果汁店，日式煎蛋卷店和冰淇淋店。在每个事件过后，你应该立即计算最新的好的 JOI 之旅的数量并告诉理惠女士。\n\n给定道路和餐厅信息，在每次类型改变事件发生之后计算好的 JOI 之旅的数量。\n\n### 实现细节\n\n你需要实现如下函数。\n\n- `void init(int N, std::vector<int> F, std::vector<int> U, std::vector<int> V, int Q)`\n  - 使用此函数给出道路和餐厅信息。\n  - 这个函数仅在程序开始时调用一次。\n  - 参数 `N` 是城市个数 $N$。\n  - 参数 `F` 是长为 $N$ 的数组。`F[i]` （$0\\le i\\le N-1$）表示城市 $i$ 中餐厅的类别，也就是 $F_i$。\n  - 参数 `U` 和 `V` 是长为 $N-1$ 的数组。`U[j]` 和 `V[j]`（$0\\le j\\le N-2$）是被路 $j$ 连接的两个城市 $U_j$ 和 $V_j$。\n  - 参数 `Q` 是餐厅类型改变事件的个数 $Q$。\n- `void change(int X, int Y)`\n  - 使用此函数给出餐厅类型改变事件。\n  - 这个函数被调用 $Q$ 次。\n  - 第 $(k+1)\\ (0\\le k\\le Q-1)$ 次调用中，参数 `X` 是餐厅类型改变发生的城市编号，也就是 $X_k$。\n  - 第 $(k+1)\\ (0\\le k\\le Q-1)$ 次调用中，参数 `Y` 是餐厅的新类型，也就是 $Y_k$。保证新类型与原类型不同。\n- `long long num_tours()`\n  - 这个函数在如下场景被调用，共 $Q+1$ 次。\n    - 在执行完函数 `init` 后。\n    - 在执行完函数 `change` 后。\n  - 这个函数应返回最新的好 JOI 之旅数。", "inputFormat": "**以下为下发 grader 的输入格式，你不应该从标准输入中读入任何信息。**\n\n第一行一个整数 $N$。\n\n第二行 $N$ 个整数 $F_0,\\ldots,F_{N-1}$。\n\n接下来 $N-1$ 行，每行两个整数 $U_j,V_j$。\n\n接下来一行一个整数 $Q$。\n\n接下来 $Q$ 行，每行两个整数 $X_k,Y_k$。", "outputFormat": "**以下为下发 grader 的输出格式，你不应该向标准输出中打印任何信息。**\n\n下发 grader 会在每次调用 `num_tours` 函数后输出一行一个整数，表示这个函数的返回值。", "hint": "#### 样例解释 1\n\n|                函数调用                 | 返回值 |\n| :-------------------------------------: | :----: |\n| `init(3, [0, 1, 2], [0, 1], [1, 2], 0)` |        |\n|              `num_tours()`              |  $1$   |\n\n只有一个好的 JOI 之旅，表示为 $(i_0,i_1,i_2)=(0,1,2)$。下面是对于它满足是好的 JOI 之旅条件的解释。\n\n- $F_0=0$，在城市 $0$ 的餐厅是果汁店。\n- $F_1=1$，在城市 $1$ 的餐厅是日式煎蛋卷店。\n- $F_2=2$，在城市 $2$ 的餐厅是冰淇淋店。\n- 当我们沿最短路径从城市 $0$ 移动到 $1$，然后从 $1$ 移动到 $2$ 时，我们没有经过相同的道路两次。\n\n因此，第一次 `num_tours()` 函数的调用返回值为 $1$。\n\n该样例满足子任务 $1,2,3,4,6,7$ 的限制。\n\n#### 样例解释 2\n\n|                函数调用                 | 返回值 |\n| :-------------------------------------: | :----: |\n| `init(3, [0, 1, 2], [0, 1], [1, 2], 2)` |        |\n|              `num_tours()`              |  $1$   |\n|             `change(2, 0)`              |        |\n|              `num_tours()`              |  $0$   |\n|             `change(0, 2)`              |        |\n|              `num_tours()`              |  $1$   |\n\n最初有一个好的 JOI 之旅，表示为 $(i_0,i_1,i_2)=(0,1,2)$。因此，第一次 `num_tours()` 函数的调用返回值为 $1$。\n\n在第一个事件中，在城市 $2$ 的餐厅从冰淇淋店变成了果汁店。在这次变化后，冰淇淋店从 IOI 国消失了，好的 JOI 之旅也没有了。因此，第二次 `num_tours()` 函数的调用返回值为 $0$。\n\n在第二个事件中，在城市 $0$ 的餐厅从果汁店变成了冰淇淋店。在这次变化后，有一个好的 JOI 之旅，表示为 $(i_0,i_1,i_2)=(2,1,0)$。因此，第三次 `num_tours()` 函数的调用返回值为 $1$。\n\n该样例满足子任务 $1,2,4,6,7$ 的限制。\n\n#### 样例解释 3\n\n这组样例满足子任务 $1,2,5,6,7$ 的限制。\n\n### 重要提示\n\n- 你的程序可以实现其它函数供内部使用，或者使用全局变量。\n- 你的程序禁止使用标准输入输出。你的程序禁止与其他文件通过任何方式交互。然而，你的程序可以使用标准错误输出输出调试信息。\n\n### 编译和测试运行\n\n你可以在「文件 - 附加文件」中下载样例交互器来测试你的程序。附加文件中还包含一个样例程序。\n\n样例交互器是文件 `grader.cpp`。为了测试你的程序，请将 `grader.cpp`，`joitour.cpp` 和 `joitour.h` 放在同一目录下，并且执行如下命令编译程序。此外你也可以运行 `compile.sh` 来编译你的程序。\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp joitour.cpp\n```\n\n当编译成功时，会生成可执行文件 `grader`。\n\n注意测评时使用的交互器与样例交互器不同。样例交互器会以单进程的形式执行，它会从标准输入中读入数据，输出结果到标准输出。\n\n### 约束条件\n\n- $3\\le N\\le 2\\times 10^5$。\n- $0\\le F_i\\le 2\\ (0\\le i\\le N-1)$。\n- $0\\le U_j<V_j\\le N-1\\ (0\\le j\\le N-2)$。\n- 可以通过道路从一个城市前往任意其他城市。\n- $0\\le Q\\le 5\\times 10^4$。\n- $0\\le X_k\\le N-1\\ (0\\le k\\le Q-1)$。\n- $0\\le Y_k\\le 2\\ (0\\le k\\le Q-1)$。\n- 对于每次调用函数 `change`，新类型不同于原类型。\n\n### 子任务\n\n- （6 分）$N\\le 400$，$Q\\le 100$。\n- （8 分）$N\\le 4\\,000$，$Q\\le 1\\,000$。\n- （6 分）$Q=0$。\n- （16 分）$U_j=j,V_j=j+1\\ (0\\le j\\le N-2)$。\n- （16 分）$U_j=\\lfloor\\frac{j}{2}\\rfloor,V_j=j+1\\ (0\\le j\\le N-2)$。\n- （34 分）$N\\le 10^5$，$Q\\le 2.5\\times 10^4$。\n- （14 分）无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] JOI 之旅 / JOI Tour", "background": "提交时请不要引用 `joitour.h`。\n\n请不要使用 C++14 (GCC 9) 提交。", "description": "在 IOI 国，有 $N$ 个城市，编号为 $0$ 到 $N-1$，有 $N-1$ 条道路，编号为 $0$ 到 $N-2$。路 $j\\ (0\\le j\\le N-2)$ 双向连接城市 $U_j$ 和城市 $V_j$。你可以通过道路从一个城市到达另一其他城市。\n\nIOI 国的每个城市都有一家餐厅。在城市 $i\\ (0\\le i\\le N-1)$ 的餐厅类型用 $F_i$ 表示，具体来说：\n\n- $F_i=0$：果汁店\n- $F_i=1$：日式煎蛋卷店\n- $F_i=2$：冰淇淋店\n\n理惠女士是 IOI 国的导游，她正在规划一个叫做 **JOI 之旅**的观光计划。JOI 之旅中计划按如下顺序前往 $3$ 种餐厅：\n\n1. 选择有果汁店的城市 $i_0\\ (0\\le i_0\\le N-1)$，并从城市 $i_0$ 开始旅行。\n2. 前往城市 $i_0$ 的果汁店。\n3. 选择有日式煎蛋卷店的城市 $i_1\\ (0\\le i_1\\le N-1)$，并从城市 $i_0$ 出发乘公交车沿最短路径前往城市 $i_1$。\n4. 前往城市 $i_1$ 的日式煎蛋卷店。\n5. 选择有冰淇淋店的城市 $i_2\\ (0\\le i_2\\le N-1)$，并从城市 $i_1$ 出发乘公交车沿最短路径前往城市 $i_2$​。\n6. 前往城市 $i_2$​ 的冰淇淋店。\n7. 在城市 $i_2$ 结束行程。\n\n为了避免游客无聊，理惠女士决定选择三个城市 $i_0,i_1,i_2$ 满足它们不会经过相同的道路两次。我们称这样的 JOI 之旅是好的。为了帮助她找到理想的旅行计划，你被要求计算好的 JOI 之旅的数量。换句话说，你需要找到满足所有如下条件的三元组 $(i_0,i_1,i_2)$ 的个数：\n\n- 城市 $i_0$ 中的餐厅是果汁店。\n- 城市 $i_1$ 中的餐厅是日式煎蛋卷店。\n- 城市 $i_2$ 中的餐厅是冰淇淋店。\n- 当我们沿最短路径从城市 $i_0$ 移动到 $i_1$ 再移动到 $i_2$ 的过程中，不会经过相同的道路两次。\n\n在 IOI 国，会有 $Q$ 次餐厅类型改变的事件。当第 $(k+1)\\ (0\\le k\\le Q-1)$ 个事件发生时，会给出两个整数 $X_k$ 和 $Y_k$，满足 $0\\le X_k\\le N-1$ 且 $0\\le Y_k\\le 2$。然后，在城市 $X_k$ 的餐厅类型会变为 $Y_k$。也就是说，当 $Y_k=0,1,2$ 时，餐厅类型会分别变为果汁店，日式煎蛋卷店和冰淇淋店。在每个事件过后，你应该立即计算最新的好的 JOI 之旅的数量并告诉理惠女士。\n\n给定道路和餐厅信息，在每次类型改变事件发生之后计算好的 JOI 之旅的数量。\n\n### 实现细节\n\n你需要实现如下函数。\n\n- `void init(int N, std::vector<int> F, std::vector<int> U, std::vector<int> V, int Q)`\n  - 使用此函数给出道路和餐厅信息。\n  - 这个函数仅在程序开始时调用一次。\n  - 参数 `N` 是城市个数 $N$。\n  - 参数 `F` 是长为 $N$ 的数组。`F[i]` （$0\\le i\\le N-1$）表示城市 $i$ 中餐厅的类别，也就是 $F_i$。\n  - 参数 `U` 和 `V` 是长为 $N-1$ 的数组。`U[j]` 和 `V[j]`（$0\\le j\\le N-2$）是被路 $j$ 连接的两个城市 $U_j$ 和 $V_j$。\n  - 参数 `Q` 是餐厅类型改变事件的个数 $Q$。\n- `void change(int X, int Y)`\n  - 使用此函数给出餐厅类型改变事件。\n  - 这个函数被调用 $Q$ 次。\n  - 第 $(k+1)\\ (0\\le k\\le Q-1)$ 次调用中，参数 `X` 是餐厅类型改变发生的城市编号，也就是 $X_k$。\n  - 第 $(k+1)\\ (0\\le k\\le Q-1)$ 次调用中，参数 `Y` 是餐厅的新类型，也就是 $Y_k$。保证新类型与原类型不同。\n- `long long num_tours()`\n  - 这个函数在如下场景被调用，共 $Q+1$ 次。\n    - 在执行完函数 `init` 后。\n    - 在执行完函数 `change` 后。\n  - 这个函数应返回最新的好 JOI 之旅数。", "inputFormat": "**以下为下发 grader 的输入格式，你不应该从标准输入中读入任何信息。**\n\n第一行一个整数 $N$。\n\n第二行 $N$ 个整数 $F_0,\\ldots,F_{N-1}$。\n\n接下来 $N-1$ 行，每行两个整数 $U_j,V_j$。\n\n接下来一行一个整数 $Q$。\n\n接下来 $Q$ 行，每行两个整数 $X_k,Y_k$。", "outputFormat": "**以下为下发 grader 的输出格式，你不应该向标准输出中打印任何信息。**\n\n下发 grader 会在每次调用 `num_tours` 函数后输出一行一个整数，表示这个函数的返回值。", "hint": "#### 样例解释 1\n\n|                函数调用                 | 返回值 |\n| :-------------------------------------: | :----: |\n| `init(3, [0, 1, 2], [0, 1], [1, 2], 0)` |        |\n|              `num_tours()`              |  $1$   |\n\n只有一个好的 JOI 之旅，表示为 $(i_0,i_1,i_2)=(0,1,2)$。下面是对于它满足是好的 JOI 之旅条件的解释。\n\n- $F_0=0$，在城市 $0$ 的餐厅是果汁店。\n- $F_1=1$，在城市 $1$ 的餐厅是日式煎蛋卷店。\n- $F_2=2$，在城市 $2$ 的餐厅是冰淇淋店。\n- 当我们沿最短路径从城市 $0$ 移动到 $1$，然后从 $1$ 移动到 $2$ 时，我们没有经过相同的道路两次。\n\n因此，第一次 `num_tours()` 函数的调用返回值为 $1$。\n\n该样例满足子任务 $1,2,3,4,6,7$ 的限制。\n\n#### 样例解释 2\n\n|                函数调用                 | 返回值 |\n| :-------------------------------------: | :----: |\n| `init(3, [0, 1, 2], [0, 1], [1, 2], 2)` |        |\n|              `num_tours()`              |  $1$   |\n|             `change(2, 0)`              |        |\n|              `num_tours()`              |  $0$   |\n|             `change(0, 2)`              |        |\n|              `num_tours()`              |  $1$   |\n\n最初有一个好的 JOI 之旅，表示为 $(i_0,i_1,i_2)=(0,1,2)$。因此，第一次 `num_tours()` 函数的调用返回值为 $1$。\n\n在第一个事件中，在城市 $2$ 的餐厅从冰淇淋店变成了果汁店。在这次变化后，冰淇淋店从 IOI 国消失了，好的 JOI 之旅也没有了。因此，第二次 `num_tours()` 函数的调用返回值为 $0$。\n\n在第二个事件中，在城市 $0$ 的餐厅从果汁店变成了冰淇淋店。在这次变化后，有一个好的 JOI 之旅，表示为 $(i_0,i_1,i_2)=(2,1,0)$。因此，第三次 `num_tours()` 函数的调用返回值为 $1$。\n\n该样例满足子任务 $1,2,4,6,7$ 的限制。\n\n#### 样例解释 3\n\n这组样例满足子任务 $1,2,5,6,7$ 的限制。\n\n### 重要提示\n\n- 你的程序可以实现其它函数供内部使用，或者使用全局变量。\n- 你的程序禁止使用标准输入输出。你的程序禁止与其他文件通过任何方式交互。然而，你的程序可以使用标准错误输出输出调试信息。\n\n### 编译和测试运行\n\n你可以在「文件 - 附加文件」中下载样例交互器来测试你的程序。附加文件中还包含一个样例程序。\n\n样例交互器是文件 `grader.cpp`。为了测试你的程序，请将 `grader.cpp`，`joitour.cpp` 和 `joitour.h` 放在同一目录下，并且执行如下命令编译程序。此外你也可以运行 `compile.sh` 来编译你的程序。\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp joitour.cpp\n```\n\n当编译成功时，会生成可执行文件 `grader`。\n\n注意测评时使用的交互器与样例交互器不同。样例交互器会以单进程的形式执行，它会从标准输入中读入数据，输出结果到标准输出。\n\n### 约束条件\n\n- $3\\le N\\le 2\\times 10^5$。\n- $0\\le F_i\\le 2\\ (0\\le i\\le N-1)$。\n- $0\\le U_j<V_j\\le N-1\\ (0\\le j\\le N-2)$。\n- 可以通过道路从一个城市前往任意其他城市。\n- $0\\le Q\\le 5\\times 10^4$。\n- $0\\le X_k\\le N-1\\ (0\\le k\\le Q-1)$。\n- $0\\le Y_k\\le 2\\ (0\\le k\\le Q-1)$。\n- 对于每次调用函数 `change`，新类型不同于原类型。\n\n### 子任务\n\n- （6 分）$N\\le 400$，$Q\\le 100$。\n- （8 分）$N\\le 4\\,000$，$Q\\le 1\\,000$。\n- （6 分）$Q=0$。\n- （16 分）$U_j=j,V_j=j+1\\ (0\\le j\\le N-2)$。\n- （16 分）$U_j=\\lfloor\\frac{j}{2}\\rfloor,V_j=j+1\\ (0\\le j\\le N-2)$。\n- （34 分）$N\\le 10^5$，$Q\\le 2.5\\times 10^4$。\n- （14 分）无额外约束。", "locale": "zh-CN"}}}
{"pid": "P10438", "type": "P", "difficulty": 6, "samples": [["3 1\n4 10 35\n4 5\n10 12\n14 14\n13", "120"], ["5 10\n10 1 9\n7 11\n25 32\n37 38\n43 44\n50 52\n6\n12\n18\n24\n30\n36\n42\n48\n54\n60", "6\n11\n17\n22\n-1\n33\n-1\n44\n-1\n55"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 塔楼 / Tower", "background": "", "description": "IOI Tower 是一座极其高的塔楼，配备了一条用于上升的楼梯。这个楼梯由 $10^{100}$ 个台阶组成，从底部开始依次编号为第 $0$ 级、第 $1$ 级，依此类推。JOI 君目前在第 $0$ 级，并打算爬楼梯。JOI 君可以通过以下两种方式上楼，禁止下楼。\n\n- 上升 $1$ 级。这个动作需要 $A$ 秒。\n- 从当前级别跳到上方 $D$ 级，跳过中间的台阶。这个动作需要 $B$ 秒。\n\n目前，楼梯的几个位置正在进行施工，正在施工的台阶不能踩上去。具体来说，有 $N$ 处正在进行施工，第 $i$ 处施工（$1 \\leq i \\leq N$）正在进行的台阶为 $L_i$ 到 $R_i$。\n\nIOI Tower 有 $Q$ 个房间，编号从 $1$ 到 $Q$。人们可以从楼梯的第 $X_j$ 级进入第 $j$ 个房间（$1 \\leq j \\leq Q$）。因此，JOI 君决定确定他是否可以到达每个房间，如果可能的话，以最短时间需要多少秒到达。\n\n给出关于 JOI 君、施工和房间的信息，创建一个程序，确定 JOI 君是否可以到达第 $j$ 个房间（$1 \\leq j \\leq Q$），如果可能的话，计算需要的最短时间。\n", "inputFormat": "从标准输入读取以下数据。\n\n- $N$ $Q$\n- $D$ $A$ $B$\n- $L_1$ $R_1$\n- $L_2$ $R_2$\n- ...\n- $L_N$ $R_N$\n- $X_1$\n- $X_2$\n- ...\n- $X_Q$\n", "outputFormat": "输出 $Q$ 行，在第 $j$ 行（$1 \\leq j \\leq Q$）输出 JOI 君到达第 $X_j$ 级台阶所需的最少秒数；如果无法到达，则输出 $-1$。\n", "hint": "#### 样例解释 1\n\nJOI 君可以按照以下步骤在 $120$ 秒内到达楼梯的第 $13$ 阶：\n\n- 从第 $0$ 阶到第 $1$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $1$ 阶到第 $2$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $2$ 阶到第 $3$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $3$ 阶跳到第 $7$ 阶，跳过中间的台阶。此操作需要 $35$ 秒。\n- 从第 $7$ 阶到第 $8$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $8$ 阶到第 $9$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $9$ 阶跳到第 $13$ 阶，跳过中间的台阶。此操作需要 $35$ 秒。\n\n由于无法在小于 $120$ 秒内到达第 $13$ 阶楼梯，输出为 $120$。\n\n这个样例输入满足子任务 $1,2,4$ 的约束条件。\n\n#### 样例解释 2\n\n这个样例输入满足子任务 $1,2,4$ 的约束条件。\n\n### 约束条件\n\n- $1 \\leq N \\leq 200,000$\n- $1 \\leq Q \\leq 200,000$\n- $1 \\leq D \\leq 10^{12}$\n- $1 \\leq A \\leq 1,000,000$\n- $1 \\leq B \\leq 1,000,000$\n- $1 \\leq L_i \\leq R_i \\leq 10^{12}$（$1 \\leq i \\leq N$）\n- $R_{i}+1 < L_{i+1}$（$1 \\leq i \\leq N-1$）\n- $1 \\leq X_j \\leq 10^{12}$（$1 \\leq j \\leq Q$）\n- 给定值均为整数。\n\n### 子任务\n\n1. （5 分）$R_i \\leq 1,000,000$（$1 \\leq i \\leq N$），$X_j \\leq 1,000,000$（$1 \\leq j \\leq Q$）\n2. （38 分）$N \\leq 2,000$，$Q \\leq 2,000$\n3. （25 分）$A = 1$，$B = D$\n4. （32 分）无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 塔楼 / Tower", "background": "", "description": "IOI Tower 是一座极其高的塔楼，配备了一条用于上升的楼梯。这个楼梯由 $10^{100}$ 个台阶组成，从底部开始依次编号为第 $0$ 级、第 $1$ 级，依此类推。JOI 君目前在第 $0$ 级，并打算爬楼梯。JOI 君可以通过以下两种方式上楼，禁止下楼。\n\n- 上升 $1$ 级。这个动作需要 $A$ 秒。\n- 从当前级别跳到上方 $D$ 级，跳过中间的台阶。这个动作需要 $B$ 秒。\n\n目前，楼梯的几个位置正在进行施工，正在施工的台阶不能踩上去。具体来说，有 $N$ 处正在进行施工，第 $i$ 处施工（$1 \\leq i \\leq N$）正在进行的台阶为 $L_i$ 到 $R_i$。\n\nIOI Tower 有 $Q$ 个房间，编号从 $1$ 到 $Q$。人们可以从楼梯的第 $X_j$ 级进入第 $j$ 个房间（$1 \\leq j \\leq Q$）。因此，JOI 君决定确定他是否可以到达每个房间，如果可能的话，以最短时间需要多少秒到达。\n\n给出关于 JOI 君、施工和房间的信息，创建一个程序，确定 JOI 君是否可以到达第 $j$ 个房间（$1 \\leq j \\leq Q$），如果可能的话，计算需要的最短时间。\n", "inputFormat": "从标准输入读取以下数据。\n\n- $N$ $Q$\n- $D$ $A$ $B$\n- $L_1$ $R_1$\n- $L_2$ $R_2$\n- ...\n- $L_N$ $R_N$\n- $X_1$\n- $X_2$\n- ...\n- $X_Q$\n", "outputFormat": "输出 $Q$ 行，在第 $j$ 行（$1 \\leq j \\leq Q$）输出 JOI 君到达第 $X_j$ 级台阶所需的最少秒数；如果无法到达，则输出 $-1$。\n", "hint": "#### 样例解释 1\n\nJOI 君可以按照以下步骤在 $120$ 秒内到达楼梯的第 $13$ 阶：\n\n- 从第 $0$ 阶到第 $1$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $1$ 阶到第 $2$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $2$ 阶到第 $3$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $3$ 阶跳到第 $7$ 阶，跳过中间的台阶。此操作需要 $35$ 秒。\n- 从第 $7$ 阶到第 $8$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $8$ 阶到第 $9$ 阶上升。此操作需要 $10$ 秒。\n- 从第 $9$ 阶跳到第 $13$ 阶，跳过中间的台阶。此操作需要 $35$ 秒。\n\n由于无法在小于 $120$ 秒内到达第 $13$ 阶楼梯，输出为 $120$。\n\n这个样例输入满足子任务 $1,2,4$ 的约束条件。\n\n#### 样例解释 2\n\n这个样例输入满足子任务 $1,2,4$ 的约束条件。\n\n### 约束条件\n\n- $1 \\leq N \\leq 200,000$\n- $1 \\leq Q \\leq 200,000$\n- $1 \\leq D \\leq 10^{12}$\n- $1 \\leq A \\leq 1,000,000$\n- $1 \\leq B \\leq 1,000,000$\n- $1 \\leq L_i \\leq R_i \\leq 10^{12}$（$1 \\leq i \\leq N$）\n- $R_{i}+1 < L_{i+1}$（$1 \\leq i \\leq N-1$）\n- $1 \\leq X_j \\leq 10^{12}$（$1 \\leq j \\leq Q$）\n- 给定值均为整数。\n\n### 子任务\n\n1. （5 分）$R_i \\leq 1,000,000$（$1 \\leq i \\leq N$），$X_j \\leq 1,000,000$（$1 \\leq j \\leq Q$）\n2. （38 分）$N \\leq 2,000$，$Q \\leq 2,000$\n3. （25 分）$A = 1$，$B = D$\n4. （32 分）无额外约束。", "locale": "zh-CN"}}}
{"pid": "P10439", "type": "P", "difficulty": 6, "samples": [["4 10000\n1\n100 300\n2\n200 400\n300 600\n1\n500 600\n3\n1 3\n2 4\n1 4", "500\n400\n10500"], ["6 10000\n1\n100 300\n1\n400 700\n1\n500 600\n1\n300 900\n1\n200 800\n1\n1 6\n", "30700"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 逃生路线 2 / Escape Route 2", "background": "", "description": "IOI 王国由从西向东排列的 $N$ 座城市组成，城市按照从西向东的顺序从 $1$ 到 $N$ 编号。\n\n在 IOI 王国，他们使用 Byou 作为时间单位。IOI 王国的一天被分为 $T$ 个时间单位。从某一天开始后的 $x$ 个 Byous（$0 \\leq x < T$）被称为时间 $x$。因此，当从某一天的时间 $T - 1$ 开始经过 $1$ 个 Byou 时，将成为下一天的时间 $0$。\n\nJOI 组织是 IOI 王国的秘密教派之一。由于它是一个秘密教派，成员必须绕过国家的检查站。因此，JOI 组织成员只能使用 JOY 航空公司运营的航班进行城市间旅行。\n\nJOY 航空公司在城市 $i$（$1 \\leq i \\leq N - 1$）提供 $M_i$ 趟航班。第 $j$ 趟航班（$1 \\leq j \\leq M_i$）每天从城市 $i$ 在时间 $A_{i,j}$ 起飞，于当天的时间 $B_{i,j}$ 到达城市 $i + 1$。这里，满足 $A_{i,j} < B_{i,j}$。\n\n这些航班提供了便捷的转机服务，也可以在抵达后立即起飞或在公司的机场过夜。\n\nJOI 组织有 $Q$ 名成员，编号从 $1$ 到 $Q$。成员 $k$（$1 \\leq k \\leq Q$）将他们的运营基地设在城市 $L_k$，生活基地设在城市 $R_k$。因此，他们想知道通过选择从城市 $L_k$ 出发的时间和适当的航班进行，从城市 $L_k$ 出发到城市 $R_k$ 的最短时间。\n\n给定 JOY 航空公司运营的航班和 JOI 组织成员的信息，编写一个程序，找到每个成员 $k$ 从城市 $L_k$ 到城市 $R_k$ 的最短时间。", "inputFormat": "从标准输入中读取以下数据。\n\n- $N$ $T$\n- $M_1$\n- $A_{1,1}$ $B_{1,1}$\n- $A_{1,2}$ $B_{1,2}$\n- ...\n- $A_{1,M_1}$ $B_{1,M_1}$\n- $M_2$\n- $A_{2,1}$ $B_{2,1}$\n- $A_{2,2}$ $B_{2,2}$\n- ...\n- $A_{2,M_2}$ $B_{2,M_2}$\n- ...\n- $M_{N-1}$\n- $A_{N-1,1}$ $B_{N-1,1}$\n- $A_{N-1,2}$ $B_{N-1,2}$\n- ...\n- $A_{N-1,M_{N-1}}$ $B_{N-1,M_{N-1}}$\n- $Q$\n- $L_1$ $R_1$\n- $L_2$ $R_2$\n- ...\n- $L_Q$ $R_Q$\n", "outputFormat": "输出 $Q$ 行到标准输出。在第 $k$ 行（$1 \\leq k \\leq Q$），输出成员 $k$ 从城市 $L_k$ 到城市 $R_k$ 所需的最短时间。\n", "hint": "#### 样例解释 1\n\n作为演示，让我们将成员 $k$ 从城市 $L_k$ 出发的第一天称为第 $1$ 天。成员 $1$ 可以按照以下行动在 $500$ Byou 内从城市 $1$ 前往城市 $3$：\n\n1. 第 $1$ 天时刻 $100$ 从城市 $1$ 出发，并在第 $1$ 天时刻 $300$ 到达城市 $2$。\n2. 第 $1$ 天时刻 $300$ 从城市 $2$ 出发，并在第 $1$ 天时刻 $600$ 到达城市 $3$。\n\n由于没有更快的旅行方式，所以在第 $1$ 行输出 $500$。\n\n成员 $2$ 可以按照以下行动在 $400$ Byou 内从城市 $2$ 前往城市 $4$：\n\n1. 第 $1$ 天时刻 $200$ 从城市 $2$ 出发，并在第 $1$ 天时刻 $400$ 到达城市 $3$。\n2. 第 $1$ 天时刻 $500$ 从城市 $3$ 出发，并在第 $1$ 天时刻 $600$ 到达城市 $4$。\n\n由于没有更快的旅行方式，所以在第 $2$ 行输出 $400$。\n\n成员 $3$ 可以按照以下行动在 $10500$ Byou 内从城市 $1$ 前往城市 $4$：\n\n1. 第 $1$ 天时刻 $100$ 从城市 $1$ 出发，并在第 $1$ 天时刻 $300$ 到达城市 $2$。\n2. 第 $1$ 天时刻 $300$ 从城市 $2$ 出发，并在第 $1$ 天时刻 $600$ 到达城市 $3$。\n3. 第 $2$ 天时刻 $500$ 从城市 $3$ 出发，并在第 $2$ 天时刻 $600$ 到达城市 $4$。\n\n由于没有更快的旅行方式，所以在第 $3$ 行输出 $10500$。\n\n这个样例输入满足子任务 $2,4,5,6$ 的限制条件。\n\n\n#### 样例解释 2\n\n这个样例输入满足所有子任务的约束条件。\n\n### 约束条件\n\n- $2 \\leq N \\leq 100,000$\n- $2 \\leq T \\leq 10^9$\n- $M_i \\geq 1$（$1 \\leq i \\leq N - 1$）\n- $M_1 + M_2 + \\cdots + M_{N-1} \\leq 100,000$\n- $0 \\leq A_{i,j} < B_{i,j} < T$（$1 \\leq i \\leq N - 1, 1 \\leq j \\leq M_i$）\n- $1 \\leq Q \\leq 300,000$\n- $1 \\leq L_k < R_k \\leq N$（$1 \\leq k \\leq Q$）\n- 给定值均为整数。\n\n### 子任务\n\n1. (6 分) $N \\leq 2,000$，$M_i = 1$（$1 \\leq i \\leq N - 1$）\n2. (8 分) $N \\leq 2,000$，$M_i \\leq 5$（$1 \\leq i \\leq N - 1$）\n3. (17 分) $M_i = 1$（$1 \\leq i \\leq N - 1$）\n4. (23 分) $M_i \\leq 5$（$1 \\leq i \\leq N - 1$）\n5. (36 分) $N \\leq 90,000$，$Q \\leq 90,000$，$M_1 + M_2 + \\cdots + M_{N-1} \\leq 90,000$\n6. (10 分) 无额外约束条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 逃生路线 2 / Escape Route 2", "background": "", "description": "IOI 王国由从西向东排列的 $N$ 座城市组成，城市按照从西向东的顺序从 $1$ 到 $N$ 编号。\n\n在 IOI 王国，他们使用 Byou 作为时间单位。IOI 王国的一天被分为 $T$ 个时间单位。从某一天开始后的 $x$ 个 Byous（$0 \\leq x < T$）被称为时间 $x$。因此，当从某一天的时间 $T - 1$ 开始经过 $1$ 个 Byou 时，将成为下一天的时间 $0$。\n\nJOI 组织是 IOI 王国的秘密教派之一。由于它是一个秘密教派，成员必须绕过国家的检查站。因此，JOI 组织成员只能使用 JOY 航空公司运营的航班进行城市间旅行。\n\nJOY 航空公司在城市 $i$（$1 \\leq i \\leq N - 1$）提供 $M_i$ 趟航班。第 $j$ 趟航班（$1 \\leq j \\leq M_i$）每天从城市 $i$ 在时间 $A_{i,j}$ 起飞，于当天的时间 $B_{i,j}$ 到达城市 $i + 1$。这里，满足 $A_{i,j} < B_{i,j}$。\n\n这些航班提供了便捷的转机服务，也可以在抵达后立即起飞或在公司的机场过夜。\n\nJOI 组织有 $Q$ 名成员，编号从 $1$ 到 $Q$。成员 $k$（$1 \\leq k \\leq Q$）将他们的运营基地设在城市 $L_k$，生活基地设在城市 $R_k$。因此，他们想知道通过选择从城市 $L_k$ 出发的时间和适当的航班进行，从城市 $L_k$ 出发到城市 $R_k$ 的最短时间。\n\n给定 JOY 航空公司运营的航班和 JOI 组织成员的信息，编写一个程序，找到每个成员 $k$ 从城市 $L_k$ 到城市 $R_k$ 的最短时间。", "inputFormat": "从标准输入中读取以下数据。\n\n- $N$ $T$\n- $M_1$\n- $A_{1,1}$ $B_{1,1}$\n- $A_{1,2}$ $B_{1,2}$\n- ...\n- $A_{1,M_1}$ $B_{1,M_1}$\n- $M_2$\n- $A_{2,1}$ $B_{2,1}$\n- $A_{2,2}$ $B_{2,2}$\n- ...\n- $A_{2,M_2}$ $B_{2,M_2}$\n- ...\n- $M_{N-1}$\n- $A_{N-1,1}$ $B_{N-1,1}$\n- $A_{N-1,2}$ $B_{N-1,2}$\n- ...\n- $A_{N-1,M_{N-1}}$ $B_{N-1,M_{N-1}}$\n- $Q$\n- $L_1$ $R_1$\n- $L_2$ $R_2$\n- ...\n- $L_Q$ $R_Q$\n", "outputFormat": "输出 $Q$ 行到标准输出。在第 $k$ 行（$1 \\leq k \\leq Q$），输出成员 $k$ 从城市 $L_k$ 到城市 $R_k$ 所需的最短时间。\n", "hint": "#### 样例解释 1\n\n作为演示，让我们将成员 $k$ 从城市 $L_k$ 出发的第一天称为第 $1$ 天。成员 $1$ 可以按照以下行动在 $500$ Byou 内从城市 $1$ 前往城市 $3$：\n\n1. 第 $1$ 天时刻 $100$ 从城市 $1$ 出发，并在第 $1$ 天时刻 $300$ 到达城市 $2$。\n2. 第 $1$ 天时刻 $300$ 从城市 $2$ 出发，并在第 $1$ 天时刻 $600$ 到达城市 $3$。\n\n由于没有更快的旅行方式，所以在第 $1$ 行输出 $500$。\n\n成员 $2$ 可以按照以下行动在 $400$ Byou 内从城市 $2$ 前往城市 $4$：\n\n1. 第 $1$ 天时刻 $200$ 从城市 $2$ 出发，并在第 $1$ 天时刻 $400$ 到达城市 $3$。\n2. 第 $1$ 天时刻 $500$ 从城市 $3$ 出发，并在第 $1$ 天时刻 $600$ 到达城市 $4$。\n\n由于没有更快的旅行方式，所以在第 $2$ 行输出 $400$。\n\n成员 $3$ 可以按照以下行动在 $10500$ Byou 内从城市 $1$ 前往城市 $4$：\n\n1. 第 $1$ 天时刻 $100$ 从城市 $1$ 出发，并在第 $1$ 天时刻 $300$ 到达城市 $2$。\n2. 第 $1$ 天时刻 $300$ 从城市 $2$ 出发，并在第 $1$ 天时刻 $600$ 到达城市 $3$。\n3. 第 $2$ 天时刻 $500$ 从城市 $3$ 出发，并在第 $2$ 天时刻 $600$ 到达城市 $4$。\n\n由于没有更快的旅行方式，所以在第 $3$ 行输出 $10500$。\n\n这个样例输入满足子任务 $2,4,5,6$ 的限制条件。\n\n\n#### 样例解释 2\n\n这个样例输入满足所有子任务的约束条件。\n\n### 约束条件\n\n- $2 \\leq N \\leq 100,000$\n- $2 \\leq T \\leq 10^9$\n- $M_i \\geq 1$（$1 \\leq i \\leq N - 1$）\n- $M_1 + M_2 + \\cdots + M_{N-1} \\leq 100,000$\n- $0 \\leq A_{i,j} < B_{i,j} < T$（$1 \\leq i \\leq N - 1, 1 \\leq j \\leq M_i$）\n- $1 \\leq Q \\leq 300,000$\n- $1 \\leq L_k < R_k \\leq N$（$1 \\leq k \\leq Q$）\n- 给定值均为整数。\n\n### 子任务\n\n1. (6 分) $N \\leq 2,000$，$M_i = 1$（$1 \\leq i \\leq N - 1$）\n2. (8 分) $N \\leq 2,000$，$M_i \\leq 5$（$1 \\leq i \\leq N - 1$）\n3. (17 分) $M_i = 1$（$1 \\leq i \\leq N - 1$）\n4. (23 分) $M_i \\leq 5$（$1 \\leq i \\leq N - 1$）\n5. (36 分) $N \\leq 90,000$，$Q \\leq 90,000$，$M_1 + M_2 + \\cdots + M_{N-1} \\leq 90,000$\n6. (10 分) 无额外约束条件。", "locale": "zh-CN"}}}
{"pid": "P10440", "type": "P", "difficulty": 6, "samples": [["4 16\n1 2\n2 4\n4 3", ""], ["5 25\n5 2\n3 1\n1 4\n1 5", ""]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "交互题", "Special Judge", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 环岛旅行 / Island Hopping", "background": "**由于部分 BUG，使用 C++14 (GCC9) 提交会产生编译错误，请使用 C++14 等语言进行提交。**\n\n**题目译自 [JOISC 2024](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/index.html) Day4 T2 「[島巡り](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/contest4/island.pdf) / [Island Hopping](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/contest4/island-en.pdf)」**。翻译来源 LOJ。\n\n**不要引入 `island.h`**。你应该在文件头添加以下声明：\n\n```\nint query(int, int);\nvoid answer(int, int);\n```\n\n交互文件可在 [JOI 官网](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/index.html)下载。", "description": "**这是一道交互题。本题交互库是非自适应的。**\n\nJOI 国有 $N$ 座岛屿，编号为 $1$ 到 $N$。有 $N-1$ 条航线，编号为 $1$ 到 $N-1$。航线 $j\\ (1\\le j\\le N-1)$ 双向连接岛屿 $A_j$ 和 $B_j$。可以从一座岛屿出发，通过一些航线到达任意另一个岛屿。\n\n葵准备在 JOI 国旅行。然而她不知道 JOI 国的航线。她准备向 JOI 国居住的 Bitaro 按下面的方式提一些问题：\n\n1. 葵告诉 Bitaro 两个整数 $v$ 和 $k$，其中 $1\\le v\\le N,1\\le k\\le N-1$。\n2. Bitaro 会告诉她除了 $v$ 之外的其他 $N-1$ 座岛屿中，距离 $v$ 第 $k$ 近的岛屿编号。更确切地说，他会告诉她一个整数 $i$，满足 $\\text{dist}(v,i)\\times N+i\\ (1\\le i\\le N,i\\neq v)$ 是第 $k$ 小的，其中 $\\text{dist}(v,i)$ 是从岛屿 $v$ 到 $i$ 所经过的最小航线数。\n\n葵想通过提问知道所有 JOI 国的航线。因为葵不想花费太多时间，所以她最多只能向 Bitaro 问 $L$ 个问题。\n\n给定 JOI 国的岛屿数和提问限制数，写一个程序模拟葵的提问策略，以找出所有的航线。\n\n### 实现细节\n\n你需要在程序开头引入库 `island.h`。\n\n你需要实现如下函数。\n\n- `void solve(int N, int L)`\n\n  此函数在每个测试点中只被调用一次\n\n  - 参数 `N` 是岛屿数 $N$\n  - 参数 `L` 是提问次数限制 $L$。\n\n在程序中，你可以调用如下函数。\n\n- `int query(int v, int k)`\n\n  葵使用此函数向 Bitaro 提问\n\n  - 参数 `v` 必须在 $1$ 到 $N$ 之间。如果不是，你的程序会被判为 **Wrong Answer [1]**。\n  - 参数 `k` 必须在 $1$ 到 $N-1$​ 之间。如果不是，你的程序会被判为 **Wrong Answer [2]**。\n  - 返回值表示除 $v$ 之外的其他 $N-1$ 个岛屿中，距离 $v$ 第 $k$ 近的岛屿编号。参考题目描述获得更详细的定义。\n  - 你不能调用 `query` 函数超过 $L$ 次，否则你的程序会被判为 **Wrong Answer [3]**。\n\n- `void answer(int x, int y)`\n\n  使用此函数回答 JOI 国的一条航线\n\n  - 参数 `x` 和 `y` 表示被一条航线连接的两座岛屿。\n  - 参数 `x` 和 `y` 必须在 $1$ 到 $N$ 之间。如果不是，你的程序会被判为 **Wrong Answer [4]**。\n  - 必须存在一条连接岛屿 `x` 和 `y` 的航线。换句话说，必须存在一个整数 $j\\ (1\\le j\\le N-1)$ 满足 $x=A_j,y=B_j$ 或 $x=B_j,y=A_j$。否则，你的程序会被判为 **Wrong Answer [5]**。\n  - 你的程序不能回答相同的航线两次或以上。否则，你的程序会被判为 **Wrong Answer [6]**。\n  - 函数 `answer` 必须被调用恰好 $N-1$ 次。如果 `solve` 函数运行结束后此函数调用次数不是 $N-1$，你的程序会被判为 **Wrong Answer [7]**。\n  \n### 注意事项\n\n- 你的程序可以实现其它函数供内部使用，或者使用全局变量。\n- 你的程序禁止使用标准输入输出。你的程序禁止与其他文件通过任何方式交互。然而，你的程序可以使用标准错误输出输出调试信息。\n- 测评中使用的交互器**不是**自适应性的。这意味着每组测试点的答案是提前确定好的。\n\n### 编译运行\n\n你可以在附件中下载样例交互器来测试你的程序。附加文件中还包含一个样例程序。\n\n样例交互器是文件 `grader.cpp`。为了测试你的程序，请将 `grader.cpp`，`island.cpp` 和 `island.h` 放在同一目录下，并且执行如下命令编译程序。此外你也可以运行 `compile.sh` 来编译你的程序。\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp island.cpp\n```\n\n当编译成功时，会生成可执行文件 `grader`。\n\n注意测评时使用的交互器与样例交互器不同。样例交互器会以单进程的形式执行，它会从标准输入中读入数据，输出结果到标准输出。", "inputFormat": "Sample Grader 输入格式如下：\n\n第一行两个整数 $N,L$。\n\n接下来 $N-1$ 行，每行两个整数 $A_j,B_j$。", "outputFormat": "样例交互器将向标准输出中输出如下信息：\n\n\n- 如果你的程序被判为正确，它会报告调用 `query` 的次数，如：`Accepted: 2024`。\n- 如果你的程序被判为某种 Wrong Answer，样例交互程序会输出它的类别，如：`Wrong Answer [4]`。\n\n如果你的程序满足多种 Wrong Answer 的类别，样例交互器只会报告其中一个。", "hint": "### 样例交互\n\n#### 样例交互 $1$\n\n样例调用过程如下表所示。\n\n|      调用      |      调用      | 返回值 |\n| :------------: | :------------: | :----: |\n| `solve(4, 16)` |               |        |\n|                | `query(2, 1)`  |  $1$   |\n|                | `query(3, 1)`  |  $4$   |\n|                | `answer(2, 4)` |        |\n|                | `query(2, 2)`  |  $4$   |\n|                | `answer(2, 1)` |        |\n|                | `query(3, 2)`  |  $2$   |\n|                | `query(2, 1)`  |  $1$   |\n|                | `answer(3, 4)` |        |\n\n从岛屿 $2$ 到岛屿 $1,3,4$ 的最小经过航线数分别为 $1,2,1$。例如，从岛屿 $2$ 到岛屿 $3$，我们可以使用航线 $2$ 后使用航线 $3$。\n\n将岛屿按 $\\text{dist}(2,i)\\times N+i\\ (i\\neq 2)$ 递增的顺序排序，结果是岛屿 $1,4,3$。因此，`query(2, 1)` 的返回值为 $1$，`query(2, 2)` 的返回值为 $4$。\n\n样例 $1$ 满足子任务 $2,6$ 的限制。\n\n#### 样例交互 $2$\n\n\n样例调用过程如下表所示。\n\n|      调用      |      调用      | 返回值 |\n| :------------: | :------------: | :----: |\n| `solve(5, 25)` |            |        |\n|                | `query(1, 3)`  |  $5$   |\n|                | `query(1, 4)`  |  $2$   |\n|                | `answer(3, 1)` |        |\n|                | `query(2, 4)`  |  $4$   |\n|                | `query(3, 1)`  |  $1$   |\n|                | `query(3, 2)`  |  $4$   |\n|                | `answer(1, 5)` |        |\n|                | `answer(4, 1)` |      |\n|                | `answer(2, 5)`  |        |\n\n从岛屿 $1$ 到岛屿 $2,3,4,5$ 的最小经过航线数分别为 $2,1,1,1$。例如，从岛屿 $1$ 到岛屿 $2$，我们可以使用航线 $4$ 后使用航线 $1$。\n\n将岛屿按 $\\text{dist}(1,i)\\times N+i\\ (i\\neq 1)$ 递增的顺序排序，结果是岛屿 $3,4,5,2$。因此，`query(1, 3)` 的返回值为 $5$，`query(1, 4)` 的返回值为 $2$。\n\n样例 $2$ 满足子任务 $4,6$ 的限制。\n\n### 数据范围\n\n- $3\\le N\\le 300$\n- $1\\le A_j,B_j\\le N\\ (1\\le j\\le N-1)$\n- $A_j\\neq B_j\\ (1\\le j\\le N-1)$\n- 可以通过航线，从一个岛屿到达任意其他岛屿\n\n### 子任务\n\n| 子任务 |                           附加限制                           | 分值 |\n| :----: | :----------------------------------------------------------: | :--: |\n|  $1$   |                          $N=3,L=9$                           | $2$  |\n|  $2$   |             $L=N^2$，每座岛屿最多有两条航线连接              | $4$  |\n|  $3$   |              $L=2N$，每座岛屿最多有两条航线连接              | $7$  |\n|  $4$   | $L=N^2$，岛屿 $1$ 有三条航线连接，其他每座岛屿最多有两条航线连接 | $9$  |\n|  $5$   | $L=3N$，岛屿 $1$ 有三条航线连接，其他每座岛屿最多有两条航线连接 | $13$ |\n|  $6$   |                           $L=N^2$                            | $15$ |\n|  $7$   |                            $L=3N$                            | $22$ |\n|  $8$   |                            $L=2N$                            | $28$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 环岛旅行 / Island Hopping", "background": "**由于部分 BUG，使用 C++14 (GCC9) 提交会产生编译错误，请使用 C++14 等语言进行提交。**\n\n**题目译自 [JOISC 2024](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/index.html) Day4 T2 「[島巡り](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/contest4/island.pdf) / [Island Hopping](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/contest4/island-en.pdf)」**。翻译来源 LOJ。\n\n**不要引入 `island.h`**。你应该在文件头添加以下声明：\n\n```\nint query(int, int);\nvoid answer(int, int);\n```\n\n交互文件可在 [JOI 官网](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/index.html)下载。", "description": "**这是一道交互题。本题交互库是非自适应的。**\n\nJOI 国有 $N$ 座岛屿，编号为 $1$ 到 $N$。有 $N-1$ 条航线，编号为 $1$ 到 $N-1$。航线 $j\\ (1\\le j\\le N-1)$ 双向连接岛屿 $A_j$ 和 $B_j$。可以从一座岛屿出发，通过一些航线到达任意另一个岛屿。\n\n葵准备在 JOI 国旅行。然而她不知道 JOI 国的航线。她准备向 JOI 国居住的 Bitaro 按下面的方式提一些问题：\n\n1. 葵告诉 Bitaro 两个整数 $v$ 和 $k$，其中 $1\\le v\\le N,1\\le k\\le N-1$。\n2. Bitaro 会告诉她除了 $v$ 之外的其他 $N-1$ 座岛屿中，距离 $v$ 第 $k$ 近的岛屿编号。更确切地说，他会告诉她一个整数 $i$，满足 $\\text{dist}(v,i)\\times N+i\\ (1\\le i\\le N,i\\neq v)$ 是第 $k$ 小的，其中 $\\text{dist}(v,i)$ 是从岛屿 $v$ 到 $i$ 所经过的最小航线数。\n\n葵想通过提问知道所有 JOI 国的航线。因为葵不想花费太多时间，所以她最多只能向 Bitaro 问 $L$ 个问题。\n\n给定 JOI 国的岛屿数和提问限制数，写一个程序模拟葵的提问策略，以找出所有的航线。\n\n### 实现细节\n\n你需要在程序开头引入库 `island.h`。\n\n你需要实现如下函数。\n\n- `void solve(int N, int L)`\n\n  此函数在每个测试点中只被调用一次\n\n  - 参数 `N` 是岛屿数 $N$\n  - 参数 `L` 是提问次数限制 $L$。\n\n在程序中，你可以调用如下函数。\n\n- `int query(int v, int k)`\n\n  葵使用此函数向 Bitaro 提问\n\n  - 参数 `v` 必须在 $1$ 到 $N$ 之间。如果不是，你的程序会被判为 **Wrong Answer [1]**。\n  - 参数 `k` 必须在 $1$ 到 $N-1$​ 之间。如果不是，你的程序会被判为 **Wrong Answer [2]**。\n  - 返回值表示除 $v$ 之外的其他 $N-1$ 个岛屿中，距离 $v$ 第 $k$ 近的岛屿编号。参考题目描述获得更详细的定义。\n  - 你不能调用 `query` 函数超过 $L$ 次，否则你的程序会被判为 **Wrong Answer [3]**。\n\n- `void answer(int x, int y)`\n\n  使用此函数回答 JOI 国的一条航线\n\n  - 参数 `x` 和 `y` 表示被一条航线连接的两座岛屿。\n  - 参数 `x` 和 `y` 必须在 $1$ 到 $N$ 之间。如果不是，你的程序会被判为 **Wrong Answer [4]**。\n  - 必须存在一条连接岛屿 `x` 和 `y` 的航线。换句话说，必须存在一个整数 $j\\ (1\\le j\\le N-1)$ 满足 $x=A_j,y=B_j$ 或 $x=B_j,y=A_j$。否则，你的程序会被判为 **Wrong Answer [5]**。\n  - 你的程序不能回答相同的航线两次或以上。否则，你的程序会被判为 **Wrong Answer [6]**。\n  - 函数 `answer` 必须被调用恰好 $N-1$ 次。如果 `solve` 函数运行结束后此函数调用次数不是 $N-1$，你的程序会被判为 **Wrong Answer [7]**。\n  \n### 注意事项\n\n- 你的程序可以实现其它函数供内部使用，或者使用全局变量。\n- 你的程序禁止使用标准输入输出。你的程序禁止与其他文件通过任何方式交互。然而，你的程序可以使用标准错误输出输出调试信息。\n- 测评中使用的交互器**不是**自适应性的。这意味着每组测试点的答案是提前确定好的。\n\n### 编译运行\n\n你可以在附件中下载样例交互器来测试你的程序。附加文件中还包含一个样例程序。\n\n样例交互器是文件 `grader.cpp`。为了测试你的程序，请将 `grader.cpp`，`island.cpp` 和 `island.h` 放在同一目录下，并且执行如下命令编译程序。此外你也可以运行 `compile.sh` 来编译你的程序。\n\n```bash\ng++ -std=gnu++20 -O2 -o grader grader.cpp island.cpp\n```\n\n当编译成功时，会生成可执行文件 `grader`。\n\n注意测评时使用的交互器与样例交互器不同。样例交互器会以单进程的形式执行，它会从标准输入中读入数据，输出结果到标准输出。", "inputFormat": "Sample Grader 输入格式如下：\n\n第一行两个整数 $N,L$。\n\n接下来 $N-1$ 行，每行两个整数 $A_j,B_j$。", "outputFormat": "样例交互器将向标准输出中输出如下信息：\n\n\n- 如果你的程序被判为正确，它会报告调用 `query` 的次数，如：`Accepted: 2024`。\n- 如果你的程序被判为某种 Wrong Answer，样例交互程序会输出它的类别，如：`Wrong Answer [4]`。\n\n如果你的程序满足多种 Wrong Answer 的类别，样例交互器只会报告其中一个。", "hint": "### 样例交互\n\n#### 样例交互 $1$\n\n样例调用过程如下表所示。\n\n|      调用      |      调用      | 返回值 |\n| :------------: | :------------: | :----: |\n| `solve(4, 16)` |               |        |\n|                | `query(2, 1)`  |  $1$   |\n|                | `query(3, 1)`  |  $4$   |\n|                | `answer(2, 4)` |        |\n|                | `query(2, 2)`  |  $4$   |\n|                | `answer(2, 1)` |        |\n|                | `query(3, 2)`  |  $2$   |\n|                | `query(2, 1)`  |  $1$   |\n|                | `answer(3, 4)` |        |\n\n从岛屿 $2$ 到岛屿 $1,3,4$ 的最小经过航线数分别为 $1,2,1$。例如，从岛屿 $2$ 到岛屿 $3$，我们可以使用航线 $2$ 后使用航线 $3$。\n\n将岛屿按 $\\text{dist}(2,i)\\times N+i\\ (i\\neq 2)$ 递增的顺序排序，结果是岛屿 $1,4,3$。因此，`query(2, 1)` 的返回值为 $1$，`query(2, 2)` 的返回值为 $4$。\n\n样例 $1$ 满足子任务 $2,6$ 的限制。\n\n#### 样例交互 $2$\n\n\n样例调用过程如下表所示。\n\n|      调用      |      调用      | 返回值 |\n| :------------: | :------------: | :----: |\n| `solve(5, 25)` |            |        |\n|                | `query(1, 3)`  |  $5$   |\n|                | `query(1, 4)`  |  $2$   |\n|                | `answer(3, 1)` |        |\n|                | `query(2, 4)`  |  $4$   |\n|                | `query(3, 1)`  |  $1$   |\n|                | `query(3, 2)`  |  $4$   |\n|                | `answer(1, 5)` |        |\n|                | `answer(4, 1)` |      |\n|                | `answer(2, 5)`  |        |\n\n从岛屿 $1$ 到岛屿 $2,3,4,5$ 的最小经过航线数分别为 $2,1,1,1$。例如，从岛屿 $1$ 到岛屿 $2$，我们可以使用航线 $4$ 后使用航线 $1$。\n\n将岛屿按 $\\text{dist}(1,i)\\times N+i\\ (i\\neq 1)$ 递增的顺序排序，结果是岛屿 $3,4,5,2$。因此，`query(1, 3)` 的返回值为 $5$，`query(1, 4)` 的返回值为 $2$。\n\n样例 $2$ 满足子任务 $4,6$ 的限制。\n\n### 数据范围\n\n- $3\\le N\\le 300$\n- $1\\le A_j,B_j\\le N\\ (1\\le j\\le N-1)$\n- $A_j\\neq B_j\\ (1\\le j\\le N-1)$\n- 可以通过航线，从一个岛屿到达任意其他岛屿\n\n### 子任务\n\n| 子任务 |                           附加限制                           | 分值 |\n| :----: | :----------------------------------------------------------: | :--: |\n|  $1$   |                          $N=3,L=9$                           | $2$  |\n|  $2$   |             $L=N^2$，每座岛屿最多有两条航线连接              | $4$  |\n|  $3$   |              $L=2N$，每座岛屿最多有两条航线连接              | $7$  |\n|  $4$   | $L=N^2$，岛屿 $1$ 有三条航线连接，其他每座岛屿最多有两条航线连接 | $9$  |\n|  $5$   | $L=3N$，岛屿 $1$ 有三条航线连接，其他每座岛屿最多有两条航线连接 | $13$ |\n|  $6$   |                           $L=N^2$                            | $15$ |\n|  $7$   |                            $L=3N$                            | $22$ |\n|  $8$   |                            $L=2N$                            | $28$ |", "locale": "zh-CN"}}}
{"pid": "P10441", "type": "P", "difficulty": 7, "samples": [["2\n3 1\n4 4", "Yes\n0\n10\nNo"], ["1\n5 3", "Yes\n0\n11\n001\n0101"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "JOISC/JOIST（日本）"], "title": "[JOIST 2024] 乒乓球 / Table Tennis", "background": "", "description": "在 JOI 王国举办了一场乒乓球比赛。 $N$ 只编号从 $1$ 到 $N$ 的海狸参加了这场比赛，并进行了一场循环赛。\n\n你从 Bitaro 那里得知了关于比赛结果的以下信息。\n\n-  没有平局比赛。\n- 正好有 $M$ 种选择 $3$ 只海狸形成“三元悖论”。请注意，只有当以下两个条件之一恰好满足时，$3$ 只海狸 $i, j, k$（$1 \\leq i < j < k \\leq N$）才形成“三元悖论”。\n- - 海狸 $i$ 击败了海狸 $j$，海狸 $j$ 击败了海狸 $k$，海狸 $k$ 又击败了海狸 $i$。\n- - 海狸 $i$ 击败了海狸 $k$，海狸 $k$ 击败了海狸 $j$，海狸 $j$ 又击败了海狸 $i$。\n\n你不确定 Bitaro 提供的信息是否正确，所以你决定思考是否有任何与 Bitaro 提供的信息相符的比赛结果。编写一个程序，根据 Bitaro 提供的信息判断是否有任何比赛结果与信息相符，如果有，找出其中任意一种比赛结果。", "inputFormat": "一个测试案例包括 $Q$ 个场景，编号从 $1$ 到 $Q$。每个场景指定以下数值。\n\n- 参加比赛的海狸数量 $N$。\n- 选择 $3$ 只形成“三元悖论”的海狸的方式数量 $M$。\n\n输入数据的格式如下。\n\n- $Q$\n\n每个场景的输入数据格式如下。\n\n- $N$ $M$", "outputFormat": "对应各个场景，按照以下顺序将答案写入标准输出。\n\n在某些场景中，如果有任何与信息相符的比赛结果，请按照以下方式输出。\n\n- Yes\n- $S_2$\n- $S_3$\n- ...\n- $S_N$\n\n这里，$S_i$（$2 \\leq i \\leq N$）是一个字符为 '0' 或 '1'，长度为 $i-1$ 的字符串。$S_i$ 的第 $j$ 个字符为 '0' 表示海狸 $i$ 被海狸 $j$ 打败，为 '1' 表示海狸 $i$ 打败了海狸 $j$。如果存在多个结果，可以输出任何一个。\n\n在某些场景中，如果没有任何与信息相符的比赛结果，请输出 No。", "hint": "#### 样例解释 1\n\n有 $Q = 2$ 个场景。\n\n在这个示例输出中，场景 $1$ 的结果是，海狸 $1$ 打败了海狸 $2$，海狸 $2$ 打败了海狸 $3$，海狸 $3$ 打败了海狸 $1$。因此，海狸 $1$、$2$、$3$ 形成了“三元悖论”。没有其他方式选择 $3$ 只海狸，所以有确切地 $1$ 种方式选择 $3$ 只形成“三元悖论”的海狸。\n\n对应场景 $1$ 的另一个输出如下。\n\n```\nYes\n1\n01\n```\n\n在场景 $2$ 中，没有任何与信息相符的比赛结果。因此，输出 No。\n\n这个示例输入满足子任务 $2,3,4,5,6$ 的约束条件。\n\n#### 样例解释 2\n\n在这个示例输出中，场景 $1$ 的结果是，海狸 $1$ 打败了海狸 $4$，海狸 $4$ 打败了海狸 $3$，海狸 $3$ 打败了海狸 $1$。因此，海狸 $1,3,4$ 形成了“三元悖论”。还有两种其他方式选择 $3$ 只形成“三元悖论”的海狸：选择海狸 $2,3,4$ 和选择海狸 $3,4,5$。因此，有确切地 $3$ 种方式选择 $3$ 只形成“三元悖论”的海狸。\n\n这个示例输入满足所有子任务的约束条件。\n\n\n### 约束条件\n\n- $1 \\leq Q$．\n- $3 \\leq N \\leq 5000$．\n- $0 \\leq M \\leq \\frac{1}{6} N(N - 1)(N - 2)$．\n- $Q$ 个场景中 $N$ 的总和不超过 5000\n- 给定值均为整数。\n\n### 子任务\n\n1. (5 分) $M \\leq N - 2$．\n2. (4 分) $Q$ 个场景中 $N$ 的总和不超过 7。\n3. (23 分) $Q$ 个场景中 $N$ 的总和不超过 20。\n4. (30 分) $Q$ 个场景中 $N$ 的总和不超过 150。\n5. (15 分) $Q$ 个场景中 $N$ 的总和不超过 600。\n6. (23 分) 无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOIST 2024] 乒乓球 / Table Tennis", "background": "", "description": "在 JOI 王国举办了一场乒乓球比赛。 $N$ 只编号从 $1$ 到 $N$ 的海狸参加了这场比赛，并进行了一场循环赛。\n\n你从 Bitaro 那里得知了关于比赛结果的以下信息。\n\n-  没有平局比赛。\n- 正好有 $M$ 种选择 $3$ 只海狸形成“三元悖论”。请注意，只有当以下两个条件之一恰好满足时，$3$ 只海狸 $i, j, k$（$1 \\leq i < j < k \\leq N$）才形成“三元悖论”。\n- - 海狸 $i$ 击败了海狸 $j$，海狸 $j$ 击败了海狸 $k$，海狸 $k$ 又击败了海狸 $i$。\n- - 海狸 $i$ 击败了海狸 $k$，海狸 $k$ 击败了海狸 $j$，海狸 $j$ 又击败了海狸 $i$。\n\n你不确定 Bitaro 提供的信息是否正确，所以你决定思考是否有任何与 Bitaro 提供的信息相符的比赛结果。编写一个程序，根据 Bitaro 提供的信息判断是否有任何比赛结果与信息相符，如果有，找出其中任意一种比赛结果。", "inputFormat": "一个测试案例包括 $Q$ 个场景，编号从 $1$ 到 $Q$。每个场景指定以下数值。\n\n- 参加比赛的海狸数量 $N$。\n- 选择 $3$ 只形成“三元悖论”的海狸的方式数量 $M$。\n\n输入数据的格式如下。\n\n- $Q$\n\n每个场景的输入数据格式如下。\n\n- $N$ $M$", "outputFormat": "对应各个场景，按照以下顺序将答案写入标准输出。\n\n在某些场景中，如果有任何与信息相符的比赛结果，请按照以下方式输出。\n\n- Yes\n- $S_2$\n- $S_3$\n- ...\n- $S_N$\n\n这里，$S_i$（$2 \\leq i \\leq N$）是一个字符为 '0' 或 '1'，长度为 $i-1$ 的字符串。$S_i$ 的第 $j$ 个字符为 '0' 表示海狸 $i$ 被海狸 $j$ 打败，为 '1' 表示海狸 $i$ 打败了海狸 $j$。如果存在多个结果，可以输出任何一个。\n\n在某些场景中，如果没有任何与信息相符的比赛结果，请输出 No。", "hint": "#### 样例解释 1\n\n有 $Q = 2$ 个场景。\n\n在这个示例输出中，场景 $1$ 的结果是，海狸 $1$ 打败了海狸 $2$，海狸 $2$ 打败了海狸 $3$，海狸 $3$ 打败了海狸 $1$。因此，海狸 $1$、$2$、$3$ 形成了“三元悖论”。没有其他方式选择 $3$ 只海狸，所以有确切地 $1$ 种方式选择 $3$ 只形成“三元悖论”的海狸。\n\n对应场景 $1$ 的另一个输出如下。\n\n```\nYes\n1\n01\n```\n\n在场景 $2$ 中，没有任何与信息相符的比赛结果。因此，输出 No。\n\n这个示例输入满足子任务 $2,3,4,5,6$ 的约束条件。\n\n#### 样例解释 2\n\n在这个示例输出中，场景 $1$ 的结果是，海狸 $1$ 打败了海狸 $4$，海狸 $4$ 打败了海狸 $3$，海狸 $3$ 打败了海狸 $1$。因此，海狸 $1,3,4$ 形成了“三元悖论”。还有两种其他方式选择 $3$ 只形成“三元悖论”的海狸：选择海狸 $2,3,4$ 和选择海狸 $3,4,5$。因此，有确切地 $3$ 种方式选择 $3$ 只形成“三元悖论”的海狸。\n\n这个示例输入满足所有子任务的约束条件。\n\n\n### 约束条件\n\n- $1 \\leq Q$．\n- $3 \\leq N \\leq 5000$．\n- $0 \\leq M \\leq \\frac{1}{6} N(N - 1)(N - 2)$．\n- $Q$ 个场景中 $N$ 的总和不超过 5000\n- 给定值均为整数。\n\n### 子任务\n\n1. (5 分) $M \\leq N - 2$．\n2. (4 分) $Q$ 个场景中 $N$ 的总和不超过 7。\n3. (23 分) $Q$ 个场景中 $N$ 的总和不超过 20。\n4. (30 分) $Q$ 个场景中 $N$ 的总和不超过 150。\n5. (15 分) $Q$ 个场景中 $N$ 的总和不超过 600。\n6. (23 分) 无额外约束。", "locale": "zh-CN"}}}
{"pid": "P10442", "type": "P", "difficulty": 1, "samples": [["abc\nbc", "2"], ["aaaaa\nbbbbb", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "字符串", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「MYOI-R3」字符串", "background": "", "description": "给定字符串 $s,t$。\n\n现在你要在 $s,t$ 中删除一些字符并将它们重新排列使 $s=t$。\n\n问操作后的 $|s|$（即字符串 $s$ 的长度）最大是多少？", "inputFormat": "第一行一个字符串 $s$。\n\n第二行一个字符串 $t$。\n", "outputFormat": "一行一个整数，表示操作后的 $|s|$ 的最大值。", "hint": "在第一个样例中，将 `a` 删除，留下 `bc`。\n\n此时 $|s|=2$，可以证明这是最优解。\n\n在第二个样例中，将 `aaaaa` 删除，留下空串。\n将 `bbbbb` 删除，留下空串。\n\n此时 $|s|=0$，可以证明这是最优解。\n\n**本题采用捆绑测试**。\n\n记 $n=\\max(|s|,|t|)$。\n\n| $\\text{Subtask}$ | $n\\le $|  特殊性质 |总分值 |\n| :--------------: | :-----: |:-----:|:--------: |\n|       $1$        |  $10$ |  无  | $25$ |\n$2$        | $10^5$  | $\\text{A}$|  $25$ |\n|       $3$        | $10^5$  | $\\text{B}$ | $25$ |\n|       $4$        | $10^5$ |     无     | $25$ |\n\n\n对于 $100\\%$ 的数据，$1  \\le |s|,|t| \\le 10^5$，字符串均由小写字母组成。\n\n特殊性质 $\\text{A}$：$s$ 是一个 $\\text{a}\\sim\\text{z}$ 的排列。\n\n特殊性质 $\\text{B}$：保证 $s_i,t_i\\in\\{\\text{a},\\text{b} \\}$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MYOI-R3」字符串", "background": "", "description": "给定字符串 $s,t$。\n\n现在你要在 $s,t$ 中删除一些字符并将它们重新排列使 $s=t$。\n\n问操作后的 $|s|$（即字符串 $s$ 的长度）最大是多少？", "inputFormat": "第一行一个字符串 $s$。\n\n第二行一个字符串 $t$。\n", "outputFormat": "一行一个整数，表示操作后的 $|s|$ 的最大值。", "hint": "在第一个样例中，将 `a` 删除，留下 `bc`。\n\n此时 $|s|=2$，可以证明这是最优解。\n\n在第二个样例中，将 `aaaaa` 删除，留下空串。\n将 `bbbbb` 删除，留下空串。\n\n此时 $|s|=0$，可以证明这是最优解。\n\n**本题采用捆绑测试**。\n\n记 $n=\\max(|s|,|t|)$。\n\n| $\\text{Subtask}$ | $n\\le $|  特殊性质 |总分值 |\n| :--------------: | :-----: |:-----:|:--------: |\n|       $1$        |  $10$ |  无  | $25$ |\n$2$        | $10^5$  | $\\text{A}$|  $25$ |\n|       $3$        | $10^5$  | $\\text{B}$ | $25$ |\n|       $4$        | $10^5$ |     无     | $25$ |\n\n\n对于 $100\\%$ 的数据，$1  \\le |s|,|t| \\le 10^5$，字符串均由小写字母组成。\n\n特殊性质 $\\text{A}$：$s$ 是一个 $\\text{a}\\sim\\text{z}$ 的排列。\n\n特殊性质 $\\text{B}$：保证 $s_i,t_i\\in\\{\\text{a},\\text{b} \\}$。\n", "locale": "zh-CN"}}}
{"pid": "P10443", "type": "P", "difficulty": 3, "samples": [["2\n3\n1 2 3\n3\n1 2 4", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "最大公约数 gcd", "洛谷月赛"], "title": "「MYOI-R3」消消乐", "background": "**upd 2024/5/12 18:14：增加了两组 Hack 数据，位于 Subtask 1，分值为 $0$ 分。**\n\n**upd 2024/5/12 21:27：增加了一组 Hack 数据，位于 Subtask 1，分值为 $0$ 分。**", "description": "给定一个长度为 $n$ 的数列 $a$。\n\n定义一次操作为选择三个整数 $x,y,z\\in[1,n]$，满足 $\\gcd(a_x,a_y)=a_z$ 且 $x,y,z$ 两两不同，接着消除 $a_z$（即之后的操作中不能再选择 $a_z$ 了）。\n\n问经过若干次操作后可否消除数列 $a_1\\sim a_n$ 中的 $n-2$ 个数？", "inputFormat": "第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据，\n\n第一行一个正整数 $n$。\n\n第二行 $n$ 个正整数 $a_i$。", "outputFormat": "对于每组数据，一行一个字符串 `Yes` 或 `No`。", "hint": "### 样例解释：\n\n- 对于第一组数据，可以通过 $(2,3)$ 消除 $1$。\n- 对于第二组数据，可以证明无解。\n\n### 数据范围：\n\n本题共有 $20$ 个测试点，每个测试点的分值均为 $5$ 分。\n\n对于 $100\\%$ 的数据，$1\\le T\\le 10^5$，$2\\leq n \\leq 10^6$，$2 \\le \\sum n\\le 10^6$，$1\\le a_i\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MYOI-R3」消消乐", "background": "**upd 2024/5/12 18:14：增加了两组 Hack 数据，位于 Subtask 1，分值为 $0$ 分。**\n\n**upd 2024/5/12 21:27：增加了一组 Hack 数据，位于 Subtask 1，分值为 $0$ 分。**", "description": "给定一个长度为 $n$ 的数列 $a$。\n\n定义一次操作为选择三个整数 $x,y,z\\in[1,n]$，满足 $\\gcd(a_x,a_y)=a_z$ 且 $x,y,z$ 两两不同，接着消除 $a_z$（即之后的操作中不能再选择 $a_z$ 了）。\n\n问经过若干次操作后可否消除数列 $a_1\\sim a_n$ 中的 $n-2$ 个数？", "inputFormat": "第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据，\n\n第一行一个正整数 $n$。\n\n第二行 $n$ 个正整数 $a_i$。", "outputFormat": "对于每组数据，一行一个字符串 `Yes` 或 `No`。", "hint": "### 样例解释：\n\n- 对于第一组数据，可以通过 $(2,3)$ 消除 $1$。\n- 对于第二组数据，可以证明无解。\n\n### 数据范围：\n\n本题共有 $20$ 个测试点，每个测试点的分值均为 $5$ 分。\n\n对于 $100\\%$ 的数据，$1\\le T\\le 10^5$，$2\\leq n \\leq 10^6$，$2 \\le \\sum n\\le 10^6$，$1\\le a_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P10444", "type": "P", "difficulty": 3, "samples": [["2 1\n6\n1 1 4 5 1 4\n7\n1 9 1 9 8 1 0", "No\nYes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "二分", "洛谷原创", "O2优化", "洛谷月赛", "双指针 two-pointer", "Ad-hoc"], "title": "「MYOI-R3」极差", "background": "", "description": "对于一个序列 $c$ ，定义 $c$ 的极差为 $c$ 中最大值与最小值之差。现在给定一个长度为 $n$ 的序列 $a$，问是否能将其分成至少两个长度大于 $1$ 的子序列，使得每个子序列的极差都相等（注意，所有元素都必须分配且每个元素仅能分配到一个子序列中）。", "inputFormat": "**本题包含多组数据**。\n\n第一行两个整数 $T,id$，表示数据组数和子任务编号。\n\n对于每组数据，\n\n第一行一个正整数 $n$，表示数组长度。\n\n第二行 $n$ 个整数表示序列 $a$。", "outputFormat": "\n对于每组数据，输出一行一个字符串 `Yes` 或 `No`。", "hint": "### 样例 $\\small\\text{1}$ 解释\n\n样例符合子任务 1 的约束，$id=1$。\n\n\n询问一：\n\n可以证明，没有任何方案满足条件。\n\n询问二：\n\n合法分配的一种子序列集合如下：\n- $\\{1,9\\}$。\n- $\\{1,9\\}$。\n- $\\{8,1,0\\}$。\n\n答案不唯一。\n\n### 数据规模与约定\n\n**本题采用捆绑测试**。\n\n- Subtask 1（20 points）：$4\\le \\sum n\\le 20,a_i\\ge 0$。\n- Subtask 2（20 points）：$4\\le \\sum n\\le 100,a_i\\ge 0$。\n- Subtask 3（20 points）：$4\\le \\sum n\\le 10^3,a_i\\ge 0$。\n- Subtask 4（10 points）：$a$ 数组中元素相等。\n- Subtask 5（30 points）：无特殊限制。\n\n\n对于 $100\\%$ 的数据，$4\\le \\sum n\\le 10^6,0\\le |a_i|\\le 10^9,1\\le T\\le 300$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MYOI-R3」极差", "background": "", "description": "对于一个序列 $c$ ，定义 $c$ 的极差为 $c$ 中最大值与最小值之差。现在给定一个长度为 $n$ 的序列 $a$，问是否能将其分成至少两个长度大于 $1$ 的子序列，使得每个子序列的极差都相等（注意，所有元素都必须分配且每个元素仅能分配到一个子序列中）。", "inputFormat": "**本题包含多组数据**。\n\n第一行两个整数 $T,id$，表示数据组数和子任务编号。\n\n对于每组数据，\n\n第一行一个正整数 $n$，表示数组长度。\n\n第二行 $n$ 个整数表示序列 $a$。", "outputFormat": "\n对于每组数据，输出一行一个字符串 `Yes` 或 `No`。", "hint": "### 样例 $\\small\\text{1}$ 解释\n\n样例符合子任务 1 的约束，$id=1$。\n\n\n询问一：\n\n可以证明，没有任何方案满足条件。\n\n询问二：\n\n合法分配的一种子序列集合如下：\n- $\\{1,9\\}$。\n- $\\{1,9\\}$。\n- $\\{8,1,0\\}$。\n\n答案不唯一。\n\n### 数据规模与约定\n\n**本题采用捆绑测试**。\n\n- Subtask 1（20 points）：$4\\le \\sum n\\le 20,a_i\\ge 0$。\n- Subtask 2（20 points）：$4\\le \\sum n\\le 100,a_i\\ge 0$。\n- Subtask 3（20 points）：$4\\le \\sum n\\le 10^3,a_i\\ge 0$。\n- Subtask 4（10 points）：$a$ 数组中元素相等。\n- Subtask 5（30 points）：无特殊限制。\n\n\n对于 $100\\%$ 的数据，$4\\le \\sum n\\le 10^6,0\\le |a_i|\\le 10^9,1\\le T\\le 300$。\n", "locale": "zh-CN"}}}
{"pid": "P10445", "type": "P", "difficulty": 4, "samples": [["3 11 3\n1 -3 4 ", "3\n1 2 3"], ["5 15 3\n-5 -10 0 5 10 ", "3\n2 1 3 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "二分", "洛谷原创", "Special Judge", "O2优化", "洛谷月赛", "双指针 two-pointer"], "title": "「MYOI-R3」签到", "background": "Updated on 2024/5/12：新增两组 hack 数据，位于 Subtask #5 的 #31 和 #32。\n\nUpdated on 2024/5/13：由于争议过大，目前难度已降绿。暂时不考虑再次变动本题难度。", "description": "这一场比赛为了选手顺利完成签到题，设置有 $n$ 个签到处，你和它们都在一条笔直的公路上，我们不妨把这条笔直的公路看作成一条数轴，你现在在数轴原点的位置上（即坐标为 $0$），第 $i$ 个签到处在坐标为 $x_i$ 的地方，你在每个时间单位内**最多**可以移动 $1$ 个单位长度。\n\n你需要去**尽量多**的签到处签到，然后在 $m$ 个时间单位内回到数轴原点。签到的时间可以**忽略不计**，而且你可能在同一地点瞬间完成**位于同一位置的多个不同签到处**的签到。\n\n出题人为了让各位选手们更方便、更顺利地签到，还在场上第 $p$ 个签到处放置了签到礼物。如果选手在这里**签过到**，那么回到原点的时间限制可以被**推迟到** $m+5$ 个单位时间。注：你可以在第 $m$ 个时刻后才获得礼物，但你必须在 $m+5$ 个单位时间前回到原点。\n\n求选手**最多**可以在多少个不同的签到处签到，并在此前提下**最小化**签过到的签到处的编号的集合的字典序（如果有多解，输出任意一个方案即可）。\n\n注：集合的字典序等价于把集合内的元素从小到大排序之后的序列的字典序。", "inputFormat": "第一行，三个整数 $n,m,p$。\n\n第二行，一共 $n$ 个整数，第 $i$ 个整数表示 $x_i$。", "outputFormat": "第一行，一个整数 $ans$，表示你最多能去签到的签到处的数量。\n\n第二行，输出 $ans$ 个正整数，表示**依次要去签到**的签到处的编号。\n\n**本题采用 Special Judge，如果有多解，输出任意一个即可。**", "hint": "### 样例 $\\small\\text{1}$ 解释\n\n\n很显然，可以去所有的签到处签到，输出一个耗时不超过 $16$ 的行动方案即可。\n\n### 样例 $\\small\\text{2}$ 解释\n\n要去 $3$ 个签到处签到一共有 $3$ 种不同的选择方案：$1$ $2$ $3$、$1$ $3$ $4$、$3$ $4$ $5$，显然，第一种选择最优，选择以下四种行动方案 $1$ $2$ $3$、$2$ $1$ $3$、$3$ $1$ $2$、$3$ $2$ $1$ 皆可。\n\n### 数据规模与约定\n\n**本题采用捆绑测试**。\n\n**本题采用「Special Judge」。**\n\n|$\\textbf{Subtask}$ | $\\textbf{Special conditions}$ |$\\textbf{Points}$ |\n| :----------: | :----------: | :----------: | \n| $0$ | 是样例 | $0$ |\n| $1$ | $n\\leq 15$ | $10$ |\n| $2$ | $n\\leq 300$ | $15$ |\n| $3$ | $n\\leq 7\\times 10^3$ | $20$ |\n| $4$ | $n\\leq 10^5$ | $25$ |\n| $5$ | 无 | $30$ |\n\n**请注意大量数据的输入输出对程序效率的影响。**\n\n**保证本题的时间限制足够长。**\n\n对于 $100\\%$ 的数据，$1\\leq p\\leq n\\leq 10^6$，$0\\leq m\\leq 10^{18}$，$-10^{18}\\leq x_i\\leq 10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MYOI-R3」签到", "background": "Updated on 2024/5/12：新增两组 hack 数据，位于 Subtask #5 的 #31 和 #32。\n\nUpdated on 2024/5/13：由于争议过大，目前难度已降绿。暂时不考虑再次变动本题难度。", "description": "这一场比赛为了选手顺利完成签到题，设置有 $n$ 个签到处，你和它们都在一条笔直的公路上，我们不妨把这条笔直的公路看作成一条数轴，你现在在数轴原点的位置上（即坐标为 $0$），第 $i$ 个签到处在坐标为 $x_i$ 的地方，你在每个时间单位内**最多**可以移动 $1$ 个单位长度。\n\n你需要去**尽量多**的签到处签到，然后在 $m$ 个时间单位内回到数轴原点。签到的时间可以**忽略不计**，而且你可能在同一地点瞬间完成**位于同一位置的多个不同签到处**的签到。\n\n出题人为了让各位选手们更方便、更顺利地签到，还在场上第 $p$ 个签到处放置了签到礼物。如果选手在这里**签过到**，那么回到原点的时间限制可以被**推迟到** $m+5$ 个单位时间。注：你可以在第 $m$ 个时刻后才获得礼物，但你必须在 $m+5$ 个单位时间前回到原点。\n\n求选手**最多**可以在多少个不同的签到处签到，并在此前提下**最小化**签过到的签到处的编号的集合的字典序（如果有多解，输出任意一个方案即可）。\n\n注：集合的字典序等价于把集合内的元素从小到大排序之后的序列的字典序。", "inputFormat": "第一行，三个整数 $n,m,p$。\n\n第二行，一共 $n$ 个整数，第 $i$ 个整数表示 $x_i$。", "outputFormat": "第一行，一个整数 $ans$，表示你最多能去签到的签到处的数量。\n\n第二行，输出 $ans$ 个正整数，表示**依次要去签到**的签到处的编号。\n\n**本题采用 Special Judge，如果有多解，输出任意一个即可。**", "hint": "### 样例 $\\small\\text{1}$ 解释\n\n\n很显然，可以去所有的签到处签到，输出一个耗时不超过 $16$ 的行动方案即可。\n\n### 样例 $\\small\\text{2}$ 解释\n\n要去 $3$ 个签到处签到一共有 $3$ 种不同的选择方案：$1$ $2$ $3$、$1$ $3$ $4$、$3$ $4$ $5$，显然，第一种选择最优，选择以下四种行动方案 $1$ $2$ $3$、$2$ $1$ $3$、$3$ $1$ $2$、$3$ $2$ $1$ 皆可。\n\n### 数据规模与约定\n\n**本题采用捆绑测试**。\n\n**本题采用「Special Judge」。**\n\n|$\\textbf{Subtask}$ | $\\textbf{Special conditions}$ |$\\textbf{Points}$ |\n| :----------: | :----------: | :----------: | \n| $0$ | 是样例 | $0$ |\n| $1$ | $n\\leq 15$ | $10$ |\n| $2$ | $n\\leq 300$ | $15$ |\n| $3$ | $n\\leq 7\\times 10^3$ | $20$ |\n| $4$ | $n\\leq 10^5$ | $25$ |\n| $5$ | 无 | $30$ |\n\n**请注意大量数据的输入输出对程序效率的影响。**\n\n**保证本题的时间限制足够长。**\n\n对于 $100\\%$ 的数据，$1\\leq p\\leq n\\leq 10^6$，$0\\leq m\\leq 10^{18}$，$-10^{18}\\leq x_i\\leq 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P10446", "type": "P", "difficulty": 2, "samples": [["3\n4\n5", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": [], "title": "64位整数乘法", "background": "", "description": "求 $a$ 乘 $b$ 对 $p$ 取模的值。", "inputFormat": "第一行输入整数 $a$，第二行输入整数 $b$，第三行输入整数 $p$。", "outputFormat": "输出一个整数，表示 `a*b mod p` 的值。", "hint": "$1 \\le a,b,p \\le 10^{18}$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "64位整数乘法", "background": "", "description": "求 $a$ 乘 $b$ 对 $p$ 取模的值。", "inputFormat": "第一行输入整数 $a$，第二行输入整数 $b$，第三行输入整数 $p$。", "outputFormat": "输出一个整数，表示 `a*b mod p` 的值。", "hint": "$1 \\le a,b,p \\le 10^{18}$", "locale": "zh-CN"}}}
{"pid": "P10447", "type": "P", "difficulty": 4, "samples": [["5\n0 2 4 5 1\n2 0 6 5 3\n4 6 0 8 3\n5 5 8 0 5\n1 3 3 5 0", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["状压 DP"], "title": "最短 Hamilton 路径", "background": "", "description": "给定一张 $n$ 个点的带权无向图，点从 $0 \\sim n-1$ 标号，求起点 $0$ 到终点 $n-1$ 的最短 Hamilton 路径。 \n\nHamilton 路径的定义是从 $0$ 到 $n-1$ 不重不漏地经过每个点恰好一次。", "inputFormat": "第一行输入整数 $n$。\n\n接下来 $n$ 行每行 $n$ 个整数，其中第 $i$ 行第 $j$ 个整数表示点 $i-1$ 到 $j-1$ 的距离（记为 $a[i-1,j-1]$）。\n\n对于任意的 $x,y,z$，数据保证 $a[x,x]=0，a[x,y]=a[y,x]$ 并且 $a[x,y]+a[y,z] \\ge a[x,z]$。", "outputFormat": "输出一个整数，表示最短 Hamilton 路径的长度。", "hint": "对于所有测试数据满足 $1 \\le n \\le 20$，$0 \\le a[i,j] \\le 10^7$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "最短 Hamilton 路径", "background": "", "description": "给定一张 $n$ 个点的带权无向图，点从 $0 \\sim n-1$ 标号，求起点 $0$ 到终点 $n-1$ 的最短 Hamilton 路径。 \n\nHamilton 路径的定义是从 $0$ 到 $n-1$ 不重不漏地经过每个点恰好一次。", "inputFormat": "第一行输入整数 $n$。\n\n接下来 $n$ 行每行 $n$ 个整数，其中第 $i$ 行第 $j$ 个整数表示点 $i-1$ 到 $j-1$ 的距离（记为 $a[i-1,j-1]$）。\n\n对于任意的 $x,y,z$，数据保证 $a[x,x]=0，a[x,y]=a[y,x]$ 并且 $a[x,y]+a[y,z] \\ge a[x,z]$。", "outputFormat": "输出一个整数，表示最短 Hamilton 路径的长度。", "hint": "对于所有测试数据满足 $1 \\le n \\le 20$，$0 \\le a[i,j] \\le 10^7$", "locale": "zh-CN"}}}
{"pid": "P10448", "type": "P", "difficulty": 2, "samples": [["5 3", "1 2 3 \n1 2 4 \n1 2 5 \n1 3 4 \n1 3 5 \n1 4 5 \n2 3 4 \n2 3 5 \n2 4 5 \n3 4 5 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["深度优先搜索 DFS"], "title": "组合型枚举", "background": "", "description": "从 $1 \\sim n$ 这 $n$ 个整数中随机选出 $m$ 个，输出所有可能的选择方案。", "inputFormat": "两个整数 $n, m$ ,在同一行用空格隔开。", "outputFormat": "按照从小到大的顺序输出所有方案，每行 $1$ 个。\n\n首先，同一行内的数升序排列，相邻两个数用一个空格隔开。\n\n其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 `1 3 5 7` 排在 `1 3 6 8` 前面）。", "hint": "对于所有测试数据满足 $0 \\le m \\le n$ ,  $ n+(n-m) \\le 25 $。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "组合型枚举", "background": "", "description": "从 $1 \\sim n$ 这 $n$ 个整数中随机选出 $m$ 个，输出所有可能的选择方案。", "inputFormat": "两个整数 $n, m$ ,在同一行用空格隔开。", "outputFormat": "按照从小到大的顺序输出所有方案，每行 $1$ 个。\n\n首先，同一行内的数升序排列，相邻两个数用一个空格隔开。\n\n其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 `1 3 5 7` 排在 `1 3 6 8` 前面）。", "hint": "对于所有测试数据满足 $0 \\le m \\le n$ ,  $ n+(n-m) \\le 25 $。", "locale": "zh-CN"}}}
{"pid": "P10449", "type": "P", "difficulty": 4, "samples": [["3\n00111\n01011\n10001\n11010\n11100\n\n11101\n11101\n11110\n11111\n11111\n\n01111\n11111\n11111\n11111\n11111", "3\n2\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "深度优先搜索 DFS", "状压 DP"], "title": "费解的开关", "background": "", "description": "你玩过“拉灯”游戏吗？\n\n$25$ 盏灯排成一个 $5 \\times 5$ 的方形。\n\n每一个灯都有一个开关，游戏者可以改变它的状态。\n\n每一步，游戏者可以改变某一个灯的状态。\n\n游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。\n\n我们用数字 $1$ 表示一盏开着的灯，用数字 $0$ 表示关着的灯。\n\n下面这种状态\n\n    10111\n    01101\n    10111\n    10000\n    11011\n\n\n在改变了最左上角的灯的状态后将变成：\n\n    01111\n    11101\n    10111\n    10000\n    11011\n\n\n再改变它正中间的灯后状态将变成：\n\n    01111\n    11001\n    11001\n    10100\n    11011\n\n\n给定一些游戏的初始状态，编写程序判断游戏者是否可能在 $6$ 步以内使所有的灯都变亮。", "inputFormat": "第一行输入正整数 $n$，代表数据中共有 $n$ 个待解决的游戏初始状态。\n\n以下若干行数据分为 $n$ 组，每组数据有 $5$ 行，每行 $5$ 个字符。\n\n每组数据描述了一个游戏的初始状态。\n\n各组数据间用一个空行分隔。", "outputFormat": "一共输出 $n$ 行数据，每行有一个小于等于 $6$ 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。\n\n对于某一个游戏初始状态，若 $6$ 步以内无法使所有灯变亮，则输出 `-1`。", "hint": "测试数据满足 $0 < n \\le 500$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "费解的开关", "background": "", "description": "你玩过“拉灯”游戏吗？\n\n$25$ 盏灯排成一个 $5 \\times 5$ 的方形。\n\n每一个灯都有一个开关，游戏者可以改变它的状态。\n\n每一步，游戏者可以改变某一个灯的状态。\n\n游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。\n\n我们用数字 $1$ 表示一盏开着的灯，用数字 $0$ 表示关着的灯。\n\n下面这种状态\n\n    10111\n    01101\n    10111\n    10000\n    11011\n\n\n在改变了最左上角的灯的状态后将变成：\n\n    01111\n    11101\n    10111\n    10000\n    11011\n\n\n再改变它正中间的灯后状态将变成：\n\n    01111\n    11001\n    11001\n    10100\n    11011\n\n\n给定一些游戏的初始状态，编写程序判断游戏者是否可能在 $6$ 步以内使所有的灯都变亮。", "inputFormat": "第一行输入正整数 $n$，代表数据中共有 $n$ 个待解决的游戏初始状态。\n\n以下若干行数据分为 $n$ 组，每组数据有 $5$ 行，每行 $5$ 个字符。\n\n每组数据描述了一个游戏的初始状态。\n\n各组数据间用一个空行分隔。", "outputFormat": "一共输出 $n$ 行数据，每行有一个小于等于 $6$ 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。\n\n对于某一个游戏初始状态，若 $6$ 步以内无法使所有灯变亮，则输出 `-1`。", "hint": "测试数据满足 $0 < n \\le 500$。", "locale": "zh-CN"}}}
{"pid": "P10450", "type": "P", "difficulty": 3, "samples": [["10 6\n6 4 2 10 3 8 5 9 4 1", "6500"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2003", "二分", "USACO", "单调队列", "前缀和"], "title": "[USACO03MAR] Best Cow Fences G", "background": "", "description": "**原题来自：USACO 2003 Mar. Green**\n\n给定一个长度为 $n$ 的非负整数序列 $A$ ，求一个平均数最大的，长度不小于 $L$ 的子段。", "inputFormat": "第一行用空格分隔的两个整数 $n$ 和 $L$；\n\n第二行为 $n$ 个用空格隔开的非负整数，表示 $A_i$。", "outputFormat": "输出一个整数，表示这个平均数的 $1000$ 倍。不用四舍五入，直接输出。", "hint": "$1 \\leq n \\leq 10^5,0 \\leq A_i \\leq 2000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO03MAR] Best Cow Fences G", "background": "", "description": "**原题来自：USACO 2003 Mar. Green**\n\n给定一个长度为 $n$ 的非负整数序列 $A$ ，求一个平均数最大的，长度不小于 $L$ 的子段。", "inputFormat": "第一行用空格分隔的两个整数 $n$ 和 $L$；\n\n第二行为 $n$ 个用空格隔开的非负整数，表示 $A_i$。", "outputFormat": "输出一个整数，表示这个平均数的 $1000$ 倍。不用四舍五入，直接输出。", "hint": "$1 \\leq n \\leq 10^5,0 \\leq A_i \\leq 2000$。", "locale": "zh-CN"}}}
{"pid": "P10451", "type": "P", "difficulty": 3, "samples": [["3\n\n1\n\n0\n\n0", "? 1 2\n\n? 1 3\n\n? 2 3\n\n! 3 1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["交互题", "Special Judge", "O2优化"], "title": "Innovative Business", "background": "", "description": "有 $N$ 个元素，编号 $1,2,\\dots,N$，每一对元素之间的大小关系是确定的，关系具有反对称性，但不具有传递性。\n\n**注意**：不存在两个元素大小相等的情况。\n\n也就是说，元素的大小关系是 $N$ 个点与 $\\frac{N \\times (N-1)}{2}$ 条有向边构成的任意有向图。\n\n然而，这是一道交互式试题，这些关系不能一次性得知，你必须通过不超过 $10000$ 次提问来获取信息，每次提问只能了解某两个元素之间的关系。\n\n现在请你把这 $N$ 个元素排成一行，使得每个元素都小于右边与它相邻的元素。\n\n你可以通过我们预设的 bool 函数 compare 来获得两个元素之间的大小关系。\n\n例如，编号为 $a$ 和 $b$ 的两个元素，如果元素 $a$ 小于元素 $b$，则 compare(a,b) 返回 true，否则返回 false。\n\n将 $N$ 个元素排好序后，把他们的编号以数组的形式输出，如果答案不唯一，则输出任意一个均可。\n\n---\n\n为了适配 OJ，本题交互格式进行修改。改为 I/O 交互。\n\n```cpp\nbool compare(int a, int b)\n{\n    cout << \"? \" << a << ' ' << b << endl;\n    bool t;\n    cin >> t;\n    return t;\n}\n```\n\n请在代码里填写此函数。**擅自修改内容后果自负。**", "inputFormat": "交互库会先给出一个正整数 $N$ 表示元素数量。\n\n之后的每次回答，交互库会返回 $1$ 或 $0$ 表示大小关系。$1$ 代表 $\\text{true}$，$0$ 代表 $\\text{false}$。", "outputFormat": "你可以使用题面中的 `compare` 函数进行提问。如要自己编写询问，询问格式为 `? a b`。\n\n输出答案之前请先给出一个感叹号 `!`。之后用空格分割这 $n$ 个编号。具体见样例 #1.", "hint": "测试数据满足 $1 \\le N \\le 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Innovative Business", "background": "", "description": "有 $N$ 个元素，编号 $1,2,\\dots,N$，每一对元素之间的大小关系是确定的，关系具有反对称性，但不具有传递性。\n\n**注意**：不存在两个元素大小相等的情况。\n\n也就是说，元素的大小关系是 $N$ 个点与 $\\frac{N \\times (N-1)}{2}$ 条有向边构成的任意有向图。\n\n然而，这是一道交互式试题，这些关系不能一次性得知，你必须通过不超过 $10000$ 次提问来获取信息，每次提问只能了解某两个元素之间的关系。\n\n现在请你把这 $N$ 个元素排成一行，使得每个元素都小于右边与它相邻的元素。\n\n你可以通过我们预设的 bool 函数 compare 来获得两个元素之间的大小关系。\n\n例如，编号为 $a$ 和 $b$ 的两个元素，如果元素 $a$ 小于元素 $b$，则 compare(a,b) 返回 true，否则返回 false。\n\n将 $N$ 个元素排好序后，把他们的编号以数组的形式输出，如果答案不唯一，则输出任意一个均可。\n\n---\n\n为了适配 OJ，本题交互格式进行修改。改为 I/O 交互。\n\n```cpp\nbool compare(int a, int b)\n{\n    cout << \"? \" << a << ' ' << b << endl;\n    bool t;\n    cin >> t;\n    return t;\n}\n```\n\n请在代码里填写此函数。**擅自修改内容后果自负。**", "inputFormat": "交互库会先给出一个正整数 $N$ 表示元素数量。\n\n之后的每次回答，交互库会返回 $1$ 或 $0$ 表示大小关系。$1$ 代表 $\\text{true}$，$0$ 代表 $\\text{false}$。", "outputFormat": "你可以使用题面中的 `compare` 函数进行提问。如要自己编写询问，询问格式为 `? a b`。\n\n输出答案之前请先给出一个感叹号 `!`。之后用空格分割这 $n$ 个编号。具体见样例 #1.", "hint": "测试数据满足 $1 \\le N \\le 1000$。", "locale": "zh-CN"}}}
