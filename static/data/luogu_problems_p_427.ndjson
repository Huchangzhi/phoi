{"pid": "P9659", "type": "P", "difficulty": 6, "samples": [["1", "4 6\n1 2 1\n2 3 2\n3 4 3\n4 1 4\n1 3 5\n2 4 6"]], "limits": {"time": [1000, 1000], "memory": [262144, 262144]}, "tags": ["2021", "提交答案", "Special Judge", "O2优化", "构造", "ICPC", "澳门"], "title": "[ICPC 2021 Macao R] Shortest Path Fast Algorithm", "background": "", "description": "Recently, BaoBao has learned the Shortest Path Fast Algorithm (SPFA, or more formally, Bellman-Ford-Moore Algorithm) to solve the shortest path problem efficiently. He realizes that the algorithm looks so similar to the Dijkstra's algorithm after replacing the FIFO queue with priority queue, and shows you the below pseudo code.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yunmac9g.png)\n\nBy picking the best vertex from $Q$ we mean picking the vertex with the smallest priority value (in case that multiple vertices have the smallest priority value, pick the vertex with the largest index among them).\n\nYou, the future computer scientist, find the BaoBao-modified SPFA algorithm works so slow in some carefully construted graph. However, BaoBao is sure that his algorithm works well, unless you show him a simple undirected graph that makes the variable $\\tt{cnt}$ in the SPFA function no less than a certain $k$ $\\textbf{at some time}$. For convenience, the source vertex of the SPFA function is specified to be vertex $1$.\n\nJust teach him a lesson!", "inputFormat": "There is only one test case in each test file.\n\nThe first and only line of the input contains a single integer $k$ where $k = 1$ for the sample test case and $k = 10^5$ for the only secret test case.", "outputFormat": "Output several lines in the following format to describe the input data of a simple undirected graph that makes the variable $\\tt{cnt}$ in the SPFA function no less than $k$ $\\textbf{at some time}$.\n\nThe first line contains two integers $n$ ($1 \\le n \\le 100$) and $m$ ($0 \\le m \\le 10^3$), indicating the number of vertices and edges in the graph.\n\nThen $m$ lines follow, the $i$-th of which contains three integers $u_i$, $v_i$ ($1 \\le u_i, v_i \\le n$) and $w_i$ ($1 \\le w_i \\le 10^6$), indicating that the $i$-th edge in the graph has a weight of $w_i$ and connects the $u_i$-th and the $v_i$-th vertices.\n\nNote that a simple graph contains no self-loops and no multiple edges.", "hint": "For your convenience, you can copy the $\\tt{C++}$ code, which corresponds to the given pseudo code, from the contest website. Save the code as $\\tt{spfa.cpp}$, use $\\text{g++ spfa.cpp -O2 -o spfa}$ to compile it and you will get an executable file named $\\tt{spfa}$. Run $\\tt{spfa}$, feed your output to its standard input and it will print out the $\\textbf{final}$ value of $\\tt{cnt}$. Given the sample output it will print out $4$, which means the sample output is not sufficient to pass the secret test case.\n\nNote that the given code does not check the validity of your output (for example it does not check if your output is really a simple graph). You might still fail the test if your output is invalid, even if the executable prints out a large value.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] Shortest Path Fast Algorithm", "background": "", "description": "Recently, BaoBao has learned the Shortest Path Fast Algorithm (SPFA, or more formally, Bellman-Ford-Moore Algorithm) to solve the shortest path problem efficiently. He realizes that the algorithm looks so similar to the Dijkstra's algorithm after replacing the FIFO queue with priority queue, and shows you the below pseudo code.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yunmac9g.png)\n\nBy picking the best vertex from $Q$ we mean picking the vertex with the smallest priority value (in case that multiple vertices have the smallest priority value, pick the vertex with the largest index among them).\n\nYou, the future computer scientist, find the BaoBao-modified SPFA algorithm works so slow in some carefully construted graph. However, BaoBao is sure that his algorithm works well, unless you show him a simple undirected graph that makes the variable $\\tt{cnt}$ in the SPFA function no less than a certain $k$ $\\textbf{at some time}$. For convenience, the source vertex of the SPFA function is specified to be vertex $1$.\n\nJust teach him a lesson!", "inputFormat": "There is only one test case in each test file.\n\nThe first and only line of the input contains a single integer $k$ where $k = 1$ for the sample test case and $k = 10^5$ for the only secret test case.", "outputFormat": "Output several lines in the following format to describe the input data of a simple undirected graph that makes the variable $\\tt{cnt}$ in the SPFA function no less than $k$ $\\textbf{at some time}$.\n\nThe first line contains two integers $n$ ($1 \\le n \\le 100$) and $m$ ($0 \\le m \\le 10^3$), indicating the number of vertices and edges in the graph.\n\nThen $m$ lines follow, the $i$-th of which contains three integers $u_i$, $v_i$ ($1 \\le u_i, v_i \\le n$) and $w_i$ ($1 \\le w_i \\le 10^6$), indicating that the $i$-th edge in the graph has a weight of $w_i$ and connects the $u_i$-th and the $v_i$-th vertices.\n\nNote that a simple graph contains no self-loops and no multiple edges.", "hint": "For your convenience, you can copy the $\\tt{C++}$ code, which corresponds to the given pseudo code, from the contest website. Save the code as $\\tt{spfa.cpp}$, use $\\text{g++ spfa.cpp -O2 -o spfa}$ to compile it and you will get an executable file named $\\tt{spfa}$. Run $\\tt{spfa}$, feed your output to its standard input and it will print out the $\\textbf{final}$ value of $\\tt{cnt}$. Given the sample output it will print out $4$, which means the sample output is not sufficient to pass the secret test case.\n\nNote that the given code does not check the validity of your output (for example it does not check if your output is really a simple graph). You might still fail the test if your output is invalid, even if the executable prints out a large value.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] Shortest Path Fast Algorithm", "background": "", "description": "最近，宝宝学习了最短路径快速算法（SPFA，或更正式地说，贝尔曼-福特-摩尔算法）以有效地解决最短路径问题。他意识到，如果用优先队列代替先进先出队列，该算法看起来与 Dijkstra 算法非常相似，并向你展示了下面的伪代码。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yunmac9g.png)\n\n选择 $Q$ 中最佳顶点意味着选择具有最小优先级值的顶点（如果有多个顶点具有最小优先级值，则选择其中索引最大的顶点）。\n\n作为未来的计算机科学家，你发现宝宝修改后的 SPFA 算法在某些精心构造的图中运行速度非常慢。然而，宝宝确信他的算法很好，除非你向他展示一个简单的无向图，在该图中，SPFA 函数中的变量 $\\tt{cnt}$ 在某个时刻不少于某个 $k$。为方便起见，SPFA 函数的源顶点被指定为顶点 $1$。\n\n就给他个教训吧！", "inputFormat": "每个测试文件中只有一个测试用例。\n\n输入的第一行包含一个整数 $k$，其中 $k = 1$ 为示例测试用例，$k = 10^5$ 为唯一的秘密测试用例。", "outputFormat": "输出几行以以下格式描述简单无向图的输入数据，使得 SPFA 函数中的变量 $\\tt{cnt}$ 在某个时刻不少于 $k$。\n\n第一行包含两个整数 $n$（$1 \\le n \\le 100$）和 $m$（$0 \\le m \\le 10^3$），表示图中的顶点数和边数。\n\n然后，跟着 $m$ 行，第 $i$ 行包含三个整数 $u_i$、$v_i$（$1 \\le u_i, v_i \\le n$）和 $w_i$（$1 \\le w_i \\le 10^6$），表示图中的第 $i$ 条边的权重为 $w_i$，连接了第 $u_i$ 个和第 $v_i$ 个顶点。\n\n注意，简单图不包含自环和重边。", "hint": "为方便起见，你可以从比赛网站上复制与给定伪代码对应的 $\\tt{C++}$ 代码。将代码保存为 $\\tt{spfa.cpp}$，使用 $\\text{g++ spfa.cpp -O2 -o spfa}$ 进行编译，你将得到一个名为 $\\tt{spfa}$ 的可执行文件。运行 $\\tt{spfa}$，将你的输出提供给它的标准输入，它将打印出 $\\tt{cnt}$ 的 $\\textbf{最终}$ 值。给出示例输出后，它将打印出 $4$，这意味着示例输出不足以通过秘密测试用例。\n\n注意，给定的代码不会检查你的输出的有效性（例如，它不会检查你的输出是否真的是一个简单图）。即使可执行文件打印出一个很大的值，如果你的输出无效，你仍然可能失败测试。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "locale": "zh-CN"}}}
{"pid": "P9660", "type": "P", "difficulty": 6, "samples": [["4 4\n2 4 1 3\n1\n2\n3\n4", "25\n20\n25\n30"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "多项式", "O2优化", "快速傅里叶变换 FFT", "快速数论变换 NTT", "ICPC", "澳门"], "title": "[ICPC 2021 Macao R] Pass the Ball!", "background": "", "description": "There are $n$ children playing with $n$ balls. Both children and balls are numbered from $1$ to $n$.\n\nBefore the game, $n$ integers $p_1, p_2, \\cdots, p_n$ are given. In each round of the game, child $i$ will pass the ball he possesses to child $p_i$. It is guaranteed that no child will pass his ball to himself, which means $p_i \\neq i$. Moreover, we also know that after each round, each child will hold exactly one ball.\n\nLet $b_i$ be the ball possessed by child $i$. At the beginning of the game, child $i$ ($1 \\le i \\le n$) will be carrying ball $i$, which means $b_i=i$ initially. You're asked to process $q$ queries. For each query you're given an integer $k$ and you need to compute the value of $\\sum\\limits_{i=1}^{n} i \\times b_i$ after $k$ rounds.", "inputFormat": "There is only one test case for each test file.\n\nThe first line of the input contains two integers $n$ ($2 \\le n \\le 10^5$) and $q$ ($1 \\le q \\le 10^5$), indicating the number of children and the number of queries.\n\nThe second line contains $n$ integers $p_1, p_2, \\cdots, p_n$ ($1 \\le p_i \\le n$) indicating how the children pass the balls around.\n\nFor the following $q$ lines, the $i$-th line contains one integer $k_i$ ($1 \\le k_i \\le 10^9$) indicating a query asking for the result after $k_i$ rounds.", "outputFormat": "For each query output one line containing one integer indicating the answer.", "hint": "The sample test case is explained below.\n\n$$\n\\begin{array}{|c|c|c|c|c|c|} \\hline \\textbf{Round} & \\textbf{b1} & \\textbf{b2} & \\textbf{b3} & \\textbf{b4} & \\textbf{Answer} \\\\\\hline \n1 & 3 & 1 & 4 & 2 & 25 \\\\\\hline\n2 & 4 & 3 & 2 & 1 & 20 \\\\\\hline\n3 & 2 & 4 & 1 & 3 & 25 \\\\\\hline\n4 & 1 & 2 & 3 & 4 & 30 \\\\\\hline\n\\end{array}\n$$", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] Pass the Ball!", "background": "", "description": "There are $n$ children playing with $n$ balls. Both children and balls are numbered from $1$ to $n$.\n\nBefore the game, $n$ integers $p_1, p_2, \\cdots, p_n$ are given. In each round of the game, child $i$ will pass the ball he possesses to child $p_i$. It is guaranteed that no child will pass his ball to himself, which means $p_i \\neq i$. Moreover, we also know that after each round, each child will hold exactly one ball.\n\nLet $b_i$ be the ball possessed by child $i$. At the beginning of the game, child $i$ ($1 \\le i \\le n$) will be carrying ball $i$, which means $b_i=i$ initially. You're asked to process $q$ queries. For each query you're given an integer $k$ and you need to compute the value of $\\sum\\limits_{i=1}^{n} i \\times b_i$ after $k$ rounds.", "inputFormat": "There is only one test case for each test file.\n\nThe first line of the input contains two integers $n$ ($2 \\le n \\le 10^5$) and $q$ ($1 \\le q \\le 10^5$), indicating the number of children and the number of queries.\n\nThe second line contains $n$ integers $p_1, p_2, \\cdots, p_n$ ($1 \\le p_i \\le n$) indicating how the children pass the balls around.\n\nFor the following $q$ lines, the $i$-th line contains one integer $k_i$ ($1 \\le k_i \\le 10^9$) indicating a query asking for the result after $k_i$ rounds.", "outputFormat": "For each query output one line containing one integer indicating the answer.", "hint": "The sample test case is explained below.\n\n$$\n\\begin{array}{|c|c|c|c|c|c|} \\hline \\textbf{Round} & \\textbf{b1} & \\textbf{b2} & \\textbf{b3} & \\textbf{b4} & \\textbf{Answer} \\\\\\hline \n1 & 3 & 1 & 4 & 2 & 25 \\\\\\hline\n2 & 4 & 3 & 2 & 1 & 20 \\\\\\hline\n3 & 2 & 4 & 1 & 3 & 25 \\\\\\hline\n4 & 1 & 2 & 3 & 4 & 30 \\\\\\hline\n\\end{array}\n$$", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] Pass the Ball!", "background": "", "description": "有 $n$ 个孩子和 $n$ 个球在玩游戏。孩子和球都从 $1$ 编号到 $n$。\n\n游戏开始前，给出了 $n$ 个整数 $p_1, p_2, \\cdots, p_n$。在游戏的每一轮中，孩子 $i$ 会把他手里的球传给孩子 $p_i$。保证没有孩子会把他手里的球传给自己，也就是说 $p_i \\neq i$。此外，我们还知道在每一轮之后，每个孩子手里都会正好持有一个球。\n\n设 $b_i$ 表示孩子 $i$ 所持有的球。在游戏开始时，孩子 $i$（$1 \\le i \\le n$）将携带球 $i$，也就是说 $b_i=i$。你需要处理 $q$ 个查询。对于每个查询，你会得到一个整数 $k$，你需要计算在 $k$ 轮后 $\\sum\\limits_{i=1}^{n} i \\times b_i$ 的值。", "inputFormat": "输入的第一行包含两个整数 $n$（$2 \\le n \\le 10^5$）和 $q$（$1 \\le q \\le 10^5$），表示孩子的数量和查询的数量。\n\n第二行包含 $n$ 个整数 $p_1, p_2, \\cdots, p_n$（$1 \\le p_i \\le n$），表示孩子之间传球的方式。\n\n接下来的 $q$ 行中，第 $i$ 行包含一个整数 $k_i$（$1 \\le k_i \\le 10^9$），表示询问在 $k_i$ 轮后的结果。", "outputFormat": "对于每个查询，输出一行包含一个整数，表示答案。\n\n**【样例解释】**\n\n示例测试用例解释如下。\n\n$$\n\\begin{array}{|c|c|c|c|c|c|} \\hline \\textbf{轮次} & \\textbf{b1} & \\textbf{b2} & \\textbf{b3} & \\textbf{b4} & \\textbf{答案} \\\\\\hline \n1 & 3 & 1 & 4 & 2 & 25 \\\\\\hline\n2 & 4 & 3 & 2 & 1 & 20 \\\\\\hline\n3 & 2 & 4 & 1 & 3 & 25 \\\\\\hline\n4 & 1 & 2 & 3 & 4 & 30 \\\\\\hline\n\\end{array}\n$$\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9661", "type": "P", "difficulty": 4, "samples": [["5\n5 0 3 0 3", "3 3 1 3 1"], ["2\n1 0", "Recurrent"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2021", "O2优化", "ICPC", "Ad-hoc", "澳门"], "title": "[ICPC 2021 Macao R] Sandpile on Clique", "background": "", "description": "The $\\textit{Abelian Sandpile Model}$ is a famous dynamical system displaying self-organized criticality. It has been studied for decades since it was introduced by Per Bak, Chao Tang and Kurt Wiesenfeld in a 1987 paper. The sandpile prediction is of wide interest in physics,\ncomputer science, and mathematics, both for its beautiful algebraic structure and for its relevance to applications like load balancing and derandomization of models like internal diffusion-limited aggregation. The sandpile model is related to many other models and physical phenomena, like the rotor-routing model, avalanche models.\n\nIn the sandpile model, we are given an undirected graph $G$ whose vertices are indexed from $1$ to $n$. We're also given $n$ integers $a_1, a_2, \\cdots, a_n$ where $a_i$ indicates that there are $a_i$ chips placed on vertex $i$ initially. Each turn we will pick an arbitrary vertex $v$ such that the number of chips on $v$ is not smaller than the number of edges connecting $v$, denoted as $d_v$. For each neighbor of $v$, it will receive one chip from $v$. Therefore, $v$ will lost $d_v$ chips. This process is called firing or toppling. Firing will keep happening until no vertex $v$ has at least $d_v$ chips.\n\nIt can be proven that the order of firing doesn't affect the result. Meanwhile, it is also possible that the firing will never terminate. This instance is described as ``recurrent``. Now you are given a clique and the initial number of chips. Determine whether this instance is a recurrent one. If not, please output the final number of chips for each node respectively.\n\nA clique (also called a complete graph) is a graph where every two vertices are connected with an edge.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains an integer $n$ ($2 \\leq n \\leq 5 \\times 10^5$) indicating the size of the clique. \n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($0 \\leq a_i \\leq 10^9$) where $a_i$ indicates the initial number of chips placed on vertex $i$.\n", "outputFormat": "Output one line. If the given sandpile instance will terminate, output $n$ integers separated by a space where the $i$-th integer indicates the final number of chips on the $i$-th vertex. Otherwise output ``Recurrent`` (without quotes) instead.\n\nPlease, DO NOT output extra spaces at the end of each line or your solution may be considered incorrect!", "hint": "For the first sample test case:\n\n- We can only select vertex $1$ at the beginning. The number of chips becomes $\\{1, 1, 4, 1, 4\\}$.\n- We can now select vertex $3$ or $5$ because both of them have at least $4$ chips. We select vertex $3$ and the number of chips becomes $\\{2, 2, 0, 2, 5\\}$. Selecting vertex $5$ will lead to the same result.\n- We now select vertex $5$. The number of chips becomes $\\{3, 3, 1, 3, 1\\}$. There is no vertex with at least $4$ chips so the firing terminates.\n\nFor the second sample test case, we can select vertex $1$ and $2$ repeatedly. The firing never terminates.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] Sandpile on Clique", "background": "", "description": "The $\\textit{Abelian Sandpile Model}$ is a famous dynamical system displaying self-organized criticality. It has been studied for decades since it was introduced by Per Bak, Chao Tang and Kurt Wiesenfeld in a 1987 paper. The sandpile prediction is of wide interest in physics,\ncomputer science, and mathematics, both for its beautiful algebraic structure and for its relevance to applications like load balancing and derandomization of models like internal diffusion-limited aggregation. The sandpile model is related to many other models and physical phenomena, like the rotor-routing model, avalanche models.\n\nIn the sandpile model, we are given an undirected graph $G$ whose vertices are indexed from $1$ to $n$. We're also given $n$ integers $a_1, a_2, \\cdots, a_n$ where $a_i$ indicates that there are $a_i$ chips placed on vertex $i$ initially. Each turn we will pick an arbitrary vertex $v$ such that the number of chips on $v$ is not smaller than the number of edges connecting $v$, denoted as $d_v$. For each neighbor of $v$, it will receive one chip from $v$. Therefore, $v$ will lost $d_v$ chips. This process is called firing or toppling. Firing will keep happening until no vertex $v$ has at least $d_v$ chips.\n\nIt can be proven that the order of firing doesn't affect the result. Meanwhile, it is also possible that the firing will never terminate. This instance is described as ``recurrent``. Now you are given a clique and the initial number of chips. Determine whether this instance is a recurrent one. If not, please output the final number of chips for each node respectively.\n\nA clique (also called a complete graph) is a graph where every two vertices are connected with an edge.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains an integer $n$ ($2 \\leq n \\leq 5 \\times 10^5$) indicating the size of the clique. \n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($0 \\leq a_i \\leq 10^9$) where $a_i$ indicates the initial number of chips placed on vertex $i$.\n", "outputFormat": "Output one line. If the given sandpile instance will terminate, output $n$ integers separated by a space where the $i$-th integer indicates the final number of chips on the $i$-th vertex. Otherwise output ``Recurrent`` (without quotes) instead.\n\nPlease, DO NOT output extra spaces at the end of each line or your solution may be considered incorrect!", "hint": "For the first sample test case:\n\n- We can only select vertex $1$ at the beginning. The number of chips becomes $\\{1, 1, 4, 1, 4\\}$.\n- We can now select vertex $3$ or $5$ because both of them have at least $4$ chips. We select vertex $3$ and the number of chips becomes $\\{2, 2, 0, 2, 5\\}$. Selecting vertex $5$ will lead to the same result.\n- We now select vertex $5$. The number of chips becomes $\\{3, 3, 1, 3, 1\\}$. There is no vertex with at least $4$ chips so the firing terminates.\n\nFor the second sample test case, we can select vertex $1$ and $2$ repeatedly. The firing never terminates.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] Sandpile on Clique", "background": "", "description": "阿贝尔沙堆模型（Abelian Sandpile Model）是一个著名的显示自组织临界性的动力学系统。自从它由 Per Bak、Chao Tang 和 Kurt Wiesenfeld 在 1987 年的一篇论文中引入以来，它已经被研究了数十年。沙堆模型的预测引起了物理学、计算机科学和数学的广泛关注，这不仅是因为它美丽的代数结构，还因为它与负载平衡和内部扩散有关的模型的应用，如去随机化。沙堆模型与许多其他模型和物理现象相关，如转子路由模型、雪崩模型。\n\n在沙堆模型中，给定一个顶点编号从 $1$ 到 $n$ 的无向图 $G$。我们还给出了 $n$ 个整数 $a_1, a_2, \\cdots, a_n$，其中 $a_i$ 表示初始时放置在顶点 $i$ 上的筹码数量。每个回合，我们将选择一个任意的顶点 $v$，使得 $v$ 上的筹码数量不小于与 $v$ 相连的边数，记为 $d_v$。对于 $v$ 的每个邻居，它将从 $v$ 接收一枚筹码。因此，$v$ 将失去 $d_v$ 枚筹码。这个过程被称为 ``firing`` 或 ``toppling``。直到没有顶点 $v$ 至少有 $d_v$ 枚筹码时，firing 才会停止。\n\n可以证明，firing 的顺序不会影响结果。同时，也可能 firing 永远不会终止。这种情况被描述为“recurrent”。现在给定一个团和初始筹码数量，请确定这个实例是否是一个 recurrent 实例。如果不是，请分别输出每个节点的最终筹码数量。\n\n团（也称为完全图）是一个图，其中任意两个顶点都有边相连。", "inputFormat": "每个测试文件中只有一个测试用例。\n\n输入的第一行包含一个整数 $n$（$2 \\leq n \\leq 5 \\times 10^5$），表示团的大小。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\cdots, a_n$（$0 \\leq a_i \\leq 10^9$），其中 $a_i$ 表示放置在顶点 $i$ 上的初始筹码数量。", "outputFormat": "输出一行。如果给定的沙堆实例将终止，则输出由空格分隔的 $n$ 个整数，其中第 $i$ 个整数表示第 $i$ 个顶点上的最终筹码数量。否则输出 ``Recurrent``（不包括引号）。\n\n请不要在每行末尾输出额外的空格，否则您的解决方案可能被认为是错误的！\n\n**【样例解释】**\n\n对于第一个样例测试用例：\n\n- 我们只能在开始时选择顶点 $1$。筹码数量变为 $\\{1, 1, 4, 1, 4\\}$。\n- 现在我们可以选择顶点 $3$ 或 $5$，因为它们都至少有 $4$ 枚筹码。我们选择顶点 $3$，筹码数量变为 $\\{2, 2, 0, 2, 5\\}$。选择顶点 $5$ 会得到相同的结果。\n- 现在我们选择顶点 $5$。筹码数量变为 $\\{3, 3, 1, 3, 1\\}$。没有顶点至少有 $4$ 枚筹码，因此 firing 终止。\n\n对于第二个样例测试用例，我们可以重复选择顶点 $1$ 和 $2$。firing 永远不会终止。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9662", "type": "P", "difficulty": 5, "samples": [["2\n5 3\n2 4 3 5 1\n1 1\n1", "3\n0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2021", "O2优化", "ICPC", "澳门"], "title": "[ICPC 2021 Macao R] Cyclic Buffer", "background": "", "description": "There is a cyclic buffer of size $n$ with readers from the $1$-st position to the $k$-th position (both inclusive). Let $a_i$ ($1 \\le i \\le n$) be the integer at the $i$-th position of the buffer initially. What's more, $a_1, a_2, \\cdots, a_n$ form a permutation of $n$.\n\nWe're going to visit all the integers from $1$ to $n$ (both inclusive) in increasing order. An integer can be visited only when it is residing in positions with readers (that is to say, when it is in the first $k$ positions). In case that an integer cannot be visited, we can shift the whole buffer in either directions any number of times.\n\n- If we shift the buffer to the left once, integers in the $i$-th position will be moved to the $(i - 1)$-th position if $i > 1$, and integer in the $1$-st position will be moved to the $n$-th position.\n- If we shift the buffer to the right once, integers in the $i$-th position will be moved to the $(i + 1)$-th position if $i < n$, and integer in the $n$-th position will be moved to the $1$-st position.\n\nWhat's the minimum number of times to shift the buffer so that we can visit all the integers in increasing order?", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 10^6$) indicating the size of the buffer and the number of readers.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le n$) where $a_i$ indicates the integer in the $i$-th position of the buffer initially.\n\nIt's guaranteed that the given $n$ integers form a permutation of $n$. It's also guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the minimum number of times to shift the buffer so that all integers can be visited in increasing order.", "hint": "For the first sample test case:\n- Shift to the right once so the buffer becomes $\\{1, 2, 4, 3, 5\\}$. $1$ and $2$ can now be visited in order as they are in the first $3$ positions.\n- Shift to the left twice so the buffer becomes $\\{4, 3, 5, 1, 2\\}$. $3$, $4$ and $5$ can now be visited in order as they are in the first $3$ positions.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] Cyclic Buffer", "background": "", "description": "There is a cyclic buffer of size $n$ with readers from the $1$-st position to the $k$-th position (both inclusive). Let $a_i$ ($1 \\le i \\le n$) be the integer at the $i$-th position of the buffer initially. What's more, $a_1, a_2, \\cdots, a_n$ form a permutation of $n$.\n\nWe're going to visit all the integers from $1$ to $n$ (both inclusive) in increasing order. An integer can be visited only when it is residing in positions with readers (that is to say, when it is in the first $k$ positions). In case that an integer cannot be visited, we can shift the whole buffer in either directions any number of times.\n\n- If we shift the buffer to the left once, integers in the $i$-th position will be moved to the $(i - 1)$-th position if $i > 1$, and integer in the $1$-st position will be moved to the $n$-th position.\n- If we shift the buffer to the right once, integers in the $i$-th position will be moved to the $(i + 1)$-th position if $i < n$, and integer in the $n$-th position will be moved to the $1$-st position.\n\nWhat's the minimum number of times to shift the buffer so that we can visit all the integers in increasing order?", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $k$ ($1 \\le k \\le n \\le 10^6$) indicating the size of the buffer and the number of readers.\n\nThe second line contains $n$ integers $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le n$) where $a_i$ indicates the integer in the $i$-th position of the buffer initially.\n\nIt's guaranteed that the given $n$ integers form a permutation of $n$. It's also guaranteed that the sum of $n$ of all test cases will not exceed $10^6$.", "outputFormat": "For each test case output one line containing one integer indicating the minimum number of times to shift the buffer so that all integers can be visited in increasing order.", "hint": "For the first sample test case:\n- Shift to the right once so the buffer becomes $\\{1, 2, 4, 3, 5\\}$. $1$ and $2$ can now be visited in order as they are in the first $3$ positions.\n- Shift to the left twice so the buffer becomes $\\{4, 3, 5, 1, 2\\}$. $3$, $4$ and $5$ can now be visited in order as they are in the first $3$ positions.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] Cyclic Buffer", "background": "", "description": "有一个大小为 $n$ 的循环缓冲区，读入流从第 $1$ 个位置到第 $k$ 个位置（两者都包含在内）。设 $a_i$ ($1 \\le i \\le n$) 是缓冲区初始时第 $i$ 个位置上的整数。此外，$a_1, a_2, \\cdots, a_n$ 形成 $n$ 的一个排列。\n\n我们将以递增顺序访问从 $1$ 到 $n$ 的所有整数（两者都包含在内）。只有当整数位于具有读入流的位置（即位于前 $k$ 个位置）时，才能访问整数。如果某个整数无法访问，则可以将整个缓冲区向任意方向移动任意次数。\n\n- 如果我们向左移动缓冲区一次，则位于第 $i$ 个位置的整数将移动到第 $(i - 1)$ 个位置（如果 $i > 1$），并且位于第 $1$ 个位置的整数将移动到第 $n$ 个位置。\n- 如果我们向右移动缓冲区一次，则位于第 $i$ 个位置的整数将移动到第 $(i + 1)$ 个位置（如果 $i < n$），并且位于第 $n$ 个位置的整数将移动到第 $1$ 个位置。\n\n我们需要移动缓冲区的最小次数，以便以递增顺序访问所有整数。", "inputFormat": "每个测试文件中包含多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含两个整数 $n$ 和 $k$ ($1 \\le k \\le n \\le 10^6$)，表示缓冲区的大小和读入流的数量。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\cdots, a_n$ ($1 \\le a_i \\le n$)，其中 $a_i$ 表示缓冲区初始时第 $i$ 个位置上的整数。\n\n保证给定的 $n$ 个整数构成 $n$ 的一个排列。还保证所有测试用例中 $n$ 的总和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数，表示移动缓冲区的最小次数，以便所有整数可以以递增顺序访问。\n\n**【样例解释】**\n\n对于第一个样例测试用例：\n- 向右移动一次，使缓冲区变为 $\\{1, 2, 4, 3, 5\\}$。现在 $1$ 和 $2$ 可以按顺序访问，因为它们位于前 $3$ 个位置。\n- 向左移动两次，使缓冲区变为 $\\{4, 3, 5, 1, 2\\}$。现在 $3$、$4$ 和 $5$ 可以按顺序访问，因为它们位于前 $3$ 个位置。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9663", "type": "P", "difficulty": 6, "samples": [["4 2\n1 2\n2 3\n1 4", "15"], ["3 1\n1 2\n2 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2021", "O2优化", "树形 DP", "ICPC", "澳门"], "title": "[ICPC 2021 Macao R] Permutation on Tree", "background": "", "description": "Given a tree with $n$ vertices where vertex $r$ is the root, we say a permutation $p_1, p_2, \\cdots, p_n$ of $n$ is good if it satisfies the following constraint:\n\n- Let $a_x$ be the index of $x$ in the permutation (That is, $p_{a_x} = x$). For all $1 \\le u, v \\le n$, if vertex $u$ is an ancestor of vertex $v$ in the tree, then $a_u < a_v$.\n\nDefine the score of a permutation to be $\\sum\\limits_{i=1}^{n-1} |p_i - p_{i+1}|$ where $|x|$ is the absolute value of $x$. Calculate the sum of scores of all different good permutations.", "inputFormat": "There is only one test case in each test file.\n\nThe first line contains two integers $n$ and $r$ ($2 \\le n \\le 200$, $1 \\le r \\le n$) indicating the size of the tree and the root.\n\nFor the following $(n - 1)$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$) indicating an edge connecting vertex $u_i$ and $v_i$ in the tree.", "outputFormat": "For each test case output one line containing one integer indicating the sum of scores of all different good permutations. As the answer may be large, output the answer modulo $(10^9 + 7)$.", "hint": "For the first sample test case, there are three good permutations: $\\{2, 1, 3, 4\\}$, $\\{2, 1, 4, 3\\}$ and $\\{2, 3, 1, 4\\}$. Their scores are $4$, $5$ and $6$ respectively so the answer is $4 + 5 + 6 = 15$.\n\nFor the second sample test case, there is only one good permutation: $\\{1, 2, 3\\}$. It's score is $2$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] Permutation on Tree", "background": "", "description": "Given a tree with $n$ vertices where vertex $r$ is the root, we say a permutation $p_1, p_2, \\cdots, p_n$ of $n$ is good if it satisfies the following constraint:\n\n- Let $a_x$ be the index of $x$ in the permutation (That is, $p_{a_x} = x$). For all $1 \\le u, v \\le n$, if vertex $u$ is an ancestor of vertex $v$ in the tree, then $a_u < a_v$.\n\nDefine the score of a permutation to be $\\sum\\limits_{i=1}^{n-1} |p_i - p_{i+1}|$ where $|x|$ is the absolute value of $x$. Calculate the sum of scores of all different good permutations.", "inputFormat": "There is only one test case in each test file.\n\nThe first line contains two integers $n$ and $r$ ($2 \\le n \\le 200$, $1 \\le r \\le n$) indicating the size of the tree and the root.\n\nFor the following $(n - 1)$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$) indicating an edge connecting vertex $u_i$ and $v_i$ in the tree.", "outputFormat": "For each test case output one line containing one integer indicating the sum of scores of all different good permutations. As the answer may be large, output the answer modulo $(10^9 + 7)$.", "hint": "For the first sample test case, there are three good permutations: $\\{2, 1, 3, 4\\}$, $\\{2, 1, 4, 3\\}$ and $\\{2, 3, 1, 4\\}$. Their scores are $4$, $5$ and $6$ respectively so the answer is $4 + 5 + 6 = 15$.\n\nFor the second sample test case, there is only one good permutation: $\\{1, 2, 3\\}$. It's score is $2$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] Permutation on Tree", "background": "", "description": "给定一个有 $n$ 个顶点的树，其中顶点 $r$ 是根，如果一个排列 $p_1, p_2, \\cdots, p_n$ 满足以下约束条件，我们称其为好排列：\n\n- 设 $a_x$ 是排列中 $x$ 的索引（即 $p_{a_x} = x$）。对于所有 $1 \\le u, v \\le n$，如果顶点 $u$ 是树中顶点 $v$ 的祖先，则 $a_u < a_v$。\n\n定义排列的分数为 $\\sum\\limits_{i=1}^{n-1} |p_i - p_{i+1}|$，其中 $|x|$ 表示 $x$ 的绝对值。计算所有不同好排列的分数之和。", "inputFormat": "每个测试文件中包含一个测试用例。输入的第一行包含两个整数 $n$ 和 $r$ ($2 \\le n \\le 200$, $1 \\le r \\le n$)，表示树的大小和根。\n\n接下来的 $(n - 1)$ 行，第 $i$ 行包含两个整数 $u_i$ 和 $v_i$ ($1 \\le u_i, v_i \\le n$)，表示树中连接顶点 $u_i$ 和 $v_i$ 的边。", "outputFormat": "对于每个测试用例，输出一行，包含一个整数，表示所有不同好排列的分数之和。由于答案可能很大，输出答案对 $(10^9 + 7)$ 取模的结果。\n\n**【样例解释】**\n\n对于第一个样例测试用例，有三个好排列：$\\{2, 1, 3, 4\\}$、$\\{2, 1, 4, 3\\}$ 和 $\\{2, 3, 1, 4\\}$。它们的分数分别为 $4$、$5$ 和 $6$，因此答案为 $4 + 5 + 6 = 15$。\n\n对于第二个样例测试用例，只有一个好排列：$\\{1, 2, 3\\}$。它的分数为 $2$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9664", "type": "P", "difficulty": 6, "samples": [["4\nicpc\nmacau\nregional\ncontest", "4"], ["3\nababa\nbabab\naba", "7"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "后缀自动机 SAM", "O2优化", "生成树", "后缀数组 SA", "后缀树", "ICPC", "澳门"], "title": "[ICPC 2021 Macao R] LCS Spanning Tree", "background": "", "description": "Given a complete undirected graph of $n$ vertices and $n$ strings $s_1, s_2, \\cdots, s_n$, the weight of edge connecting vertices $i$ and $j$ is equal to the length of the longest common substring (LCS) between $s_i$ and $s_j$. Compute the maximum total weight of any spanning tree on this graph.\n\nA substring of a string can be obtained by removing some (possibly zero) characters from the beginning and/or the end of that string. For example, ``maca``, ``aca`` and ``cau`` are all substrings of ``macau``, while ``acu`` is not.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains one integer $n$ ($1 \\leq n \\leq 2 \\times 10^6$) indicating the number of vertices and strings.\n\nFor the following $n$ lines, the $i$-th line contains one string $s_i$ ($1 \\le |s_i| \\le 2 \\times 10^6$) consisting only of lowercase English letters.\n\nIt's guaranteed that the sum of lengths of all strings will not exceed $2 \\times 10^6$.", "outputFormat": "Output one line containing one integer indicating the answer.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] LCS Spanning Tree", "background": "", "description": "Given a complete undirected graph of $n$ vertices and $n$ strings $s_1, s_2, \\cdots, s_n$, the weight of edge connecting vertices $i$ and $j$ is equal to the length of the longest common substring (LCS) between $s_i$ and $s_j$. Compute the maximum total weight of any spanning tree on this graph.\n\nA substring of a string can be obtained by removing some (possibly zero) characters from the beginning and/or the end of that string. For example, ``maca``, ``aca`` and ``cau`` are all substrings of ``macau``, while ``acu`` is not.", "inputFormat": "There is only one test case in each test file.\n\nThe first line of the input contains one integer $n$ ($1 \\leq n \\leq 2 \\times 10^6$) indicating the number of vertices and strings.\n\nFor the following $n$ lines, the $i$-th line contains one string $s_i$ ($1 \\le |s_i| \\le 2 \\times 10^6$) consisting only of lowercase English letters.\n\nIt's guaranteed that the sum of lengths of all strings will not exceed $2 \\times 10^6$.", "outputFormat": "Output one line containing one integer indicating the answer.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] LCS Spanning Tree", "background": "", "description": "给定一个有 $n$ 个顶点的完全无向图和 $n$ 个字符串 $s_1, s_2, \\cdots, s_n$，连接顶点 $i$ 和 $j$ 的边的权重等于字符串 $s_i$ 和 $s_j$ 的最长公共子串（LCS）的长度。计算此图上任意生成树的最大总权重。\n\n一个字符串的子串可以通过从该字符串的开头和/或结尾删除一些（可能为零）字符来获得。例如，“maca”、“aca” 和“cau”都是“macau”的子串，而“acu”不是。", "inputFormat": "每个测试文件中包含一个测试用例。\n\n输入的第一行包含一个整数 $n$ ($1 \\leq n \\leq 2 \\times 10^6$)，表示顶点和字符串的数量。\n\n接下来的 $n$ 行，第 $i$ 行包含一个字符串 $s_i$ ($1 \\le |s_i| \\le 2 \\times 10^6$)，由小写英文字母组成。\n\n保证所有字符串的长度之和不超过 $2 \\times 10^6$。", "outputFormat": "输出一行，包含一个整数，表示答案。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9665", "type": "P", "difficulty": 6, "samples": [["2\n1 1\n0 1 1 1\n5 1\n0 1 1 1\n0 1 2 1\n0 3 3 1\n1 4 1\n1 3 1", "0\n0\n2\n3\n2\n0"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "2021", "O2优化", "树论", "ICPC", "澳门"], "title": "[ICPC 2021 Macao R] Colorful Tree", "background": "", "description": "Your task is to maintain a colorful tree and process queries.\n\nAt the beginning, there is only one vertex numbered $1$ with color $C$ on the tree. Then there are $q$ operations of two types coming in order:\n- $0$ $x$ $c$ $d$: Add a new vertex indexed $(n+1)$ with color $c$ to the tree, where $n$ is the current number of existing vertices. An edge connecting vertex $x$ and $(n+1)$ with length $d$ will also be added to the tree.\n- $1$ $x$ $c$: Change the color of vertex $x$ to $c$.\n\nAfter each operation, you should find a pair of vertices $u$ and $v$ ($1 \\le u, v \\le n$) with $\\textbf{different}$ colors in the current tree so that the distance between $u$ and $v$ is as large as possible.\n\nThe distance between two vertices $u$ and $v$ is the length of the shortest path from $u$ to $v$ on the tree.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line of the input contains two integers $q$ and $C$ ($1 \\le q \\le 5 \\times 10^5$, $1 \\le C \\le q$) indicating the number of operations and the initial color of vertex $1$.\n\nFor the following $q$ lines, each line describes an operation taking place in order with $3$ or $4$ integers.\n- If the $i$-th line contains $4$ integers $0$, $x_i$, $c_i$ and $d_i$ ($1 \\le x_i \\le n$, $1 \\le c_i \\le q$, $1 \\le d \\le 10^9$), the $i$-th operation will add a new vertex $(n + 1)$ with color $c_i$ to the tree and connect it to vertex $x_i$ with an edge of length $d_i$.\n- If the $i$-th line contains $3$ integers $1$, $x_i$ and $c_i$ ($1 \\le x_i \\le n$, $1 \\le c_i \\le q$), the $i$-th operation will change the color of vertex $x_i$ to $c_i$.\n\nIt's guaranteed that the sum of $q$ of all test cases will not exceed $5 \\times 10^5$.", "outputFormat": "For each operation output the maximum distance between two vertices with different colors. If no valid pair exists output $0$ instead.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] Colorful Tree", "background": "", "description": "Your task is to maintain a colorful tree and process queries.\n\nAt the beginning, there is only one vertex numbered $1$ with color $C$ on the tree. Then there are $q$ operations of two types coming in order:\n- $0$ $x$ $c$ $d$: Add a new vertex indexed $(n+1)$ with color $c$ to the tree, where $n$ is the current number of existing vertices. An edge connecting vertex $x$ and $(n+1)$ with length $d$ will also be added to the tree.\n- $1$ $x$ $c$: Change the color of vertex $x$ to $c$.\n\nAfter each operation, you should find a pair of vertices $u$ and $v$ ($1 \\le u, v \\le n$) with $\\textbf{different}$ colors in the current tree so that the distance between $u$ and $v$ is as large as possible.\n\nThe distance between two vertices $u$ and $v$ is the length of the shortest path from $u$ to $v$ on the tree.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line of the input contains two integers $q$ and $C$ ($1 \\le q \\le 5 \\times 10^5$, $1 \\le C \\le q$) indicating the number of operations and the initial color of vertex $1$.\n\nFor the following $q$ lines, each line describes an operation taking place in order with $3$ or $4$ integers.\n- If the $i$-th line contains $4$ integers $0$, $x_i$, $c_i$ and $d_i$ ($1 \\le x_i \\le n$, $1 \\le c_i \\le q$, $1 \\le d \\le 10^9$), the $i$-th operation will add a new vertex $(n + 1)$ with color $c_i$ to the tree and connect it to vertex $x_i$ with an edge of length $d_i$.\n- If the $i$-th line contains $3$ integers $1$, $x_i$ and $c_i$ ($1 \\le x_i \\le n$, $1 \\le c_i \\le q$), the $i$-th operation will change the color of vertex $x_i$ to $c_i$.\n\nIt's guaranteed that the sum of $q$ of all test cases will not exceed $5 \\times 10^5$.", "outputFormat": "For each operation output the maximum distance between two vertices with different colors. If no valid pair exists output $0$ instead.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] Colorful Tree", "background": null, "description": "你的任务是维护一棵有色树并处理查询。\n\n一开始，树上只有一个编号为 $1$ 的顶点，颜色为 $C$。然后按顺序进行 $q$ 个操作，有两种类型：\n- $0$ $x$ $c$ $d$：向树中添加一个颜色为 $c$ 的新顶点，其编号为 $(n+1)$，其中 $n$ 是当前存在的顶点数。同时，添加一条连接顶点 $x$ 和 $(n+1)$ 的长度为 $d$ 的边。\n- $1$ $x$ $c$：将顶点 $x$ 的颜色更改为 $c$。\n\n在每次操作之后，你应该找到当前树中颜色 $\\textbf{不同}$ 的两个顶点 $u$ 和 $v$（$1 \\le u, v \\le n$），使得它们之间的距离尽可能大。\n\n两个顶点 $u$ 和 $v$ 之间的距离是树上从 $u$ 到 $v$ 的最短路径的长度。", "inputFormat": "存在多个测试用例。输入的第一行包含一个整数 $T$ ，表示测试用例的数量。对于每个测试用例：\n\n输入的第一行包含两个整数 $q$ 和 $C$（$1 \\le q \\le 5 \\times 10^5$，$1 \\le C \\le q$），表示操作的数量和顶点 $1$ 的初始颜色。\n\n接下来的 $q$ 行中，每行描述一个按顺序进行的操作，包含 $3$ 或 $4$ 个整数。\n- 如果第 $i$ 行包含 $4$ 个整数 $0$、$x_i$、$c_i$ 和 $d_i$（$1 \\le x_i \\le n$，$1 \\le c_i \\le q$，$1 \\le d \\le 10^9$），则第 $i$ 个操作将向树中添加一个颜色为 $c_i$ 的新顶点 $(n + 1)$，并将其与顶点 $x_i$ 连接，边的长度为 $d_i$。\n- 如果第 $i$ 行包含 $3$ 个整数 $1$、$x_i$ 和 $c_i$（$1 \\le x_i \\le n$，$1 \\le c_i \\le q$），则第 $i$ 个操作将顶点 $x_i$ 的颜色更改为 $c_i$。\n\n保证所有测试用例中 $q$ 的总和不超过 $5 \\times 10^5$。", "outputFormat": "对于每个操作，输出两个不同颜色顶点之间的最大距离。如果不存在有效的顶点对，则输出 $0$。\n\n翻译来自于：[ChatGPT](https://chatgpt.com/)", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9666", "type": "P", "difficulty": 3, "samples": [["2\n6 8\n1 2\n2 3\n5 6\n3 4\n2 5\n5 4\n5 1\n4 2\n4 2\n1 2\n4 3", "2 4 5 6\n-1"]], "limits": {"time": [2000, 2000, 2000], "memory": [262144, 262144, 262144]}, "tags": ["2021", "O2优化", "生成树", "ICPC", "澳门"], "title": "[ICPC 2021 Macao R] Link-Cut Tree", "background": "", "description": "BaoBao just learned how to use a data structure called link-cut tree to find cycles in a graph and decided to give it a try. BaoBao is given an undirected graph with $n$ vertices and $m$ edges, where the length of the $i$-th edge equals $2^i$. She needs to find a simple cycle with the smallest length.\n\nA simple cycle is a subgraph of the original graph containing $k$ ($3 \\le k \\le n$) vertices $a_1, a_2, \\cdots, a_k$ and $k$ edges such that for all $1 \\le i \\le k$ there is an edge connecting vertices $a_i$ and $a_{(i \\mod k) + 1}$ in the subgraph. The length of a simple cycle is the total length of the edges in the cycle.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($3 \\le n \\le 10^5$, $1 \\le m \\le 10^5$) indicating the number of vertices and edges in the original graph.\n\nFor the following $m$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$) indicating an edge connecting vertices $u_i$ and $v_i$ with length $2^i$. There are no self loops nor multiple edges. Note that the graph is not necessarily connected.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $10^6$.", "outputFormat": "For each test case output one line. If there are no simple cycles in the graph output ``-1`` (without quotes); Otherwise output $k$ integers separated by a space in increasing order indicating the indices of the edges in the simple cycle with the smallest length. It can be shown that there is at most one answer.\n\nPlease, DO NOT output extra spaces at the end of each line, or your solution may be considered incorrect!", "hint": "The first sample test case is shown below. The integers beside the edges are their indices (outside the parentheses) and lengths (inside the parentheses). The simple cycle with the smallest length consists of edges $2$, $4$, $5$ and $6$ with a length of $2^2 + 2^4 + 2^5 + 2^6 = 116$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2021 Macao R] Link-Cut Tree", "background": "", "description": "BaoBao just learned how to use a data structure called link-cut tree to find cycles in a graph and decided to give it a try. BaoBao is given an undirected graph with $n$ vertices and $m$ edges, where the length of the $i$-th edge equals $2^i$. She needs to find a simple cycle with the smallest length.\n\nA simple cycle is a subgraph of the original graph containing $k$ ($3 \\le k \\le n$) vertices $a_1, a_2, \\cdots, a_k$ and $k$ edges such that for all $1 \\le i \\le k$ there is an edge connecting vertices $a_i$ and $a_{(i \\mod k) + 1}$ in the subgraph. The length of a simple cycle is the total length of the edges in the cycle.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n$ and $m$ ($3 \\le n \\le 10^5$, $1 \\le m \\le 10^5$) indicating the number of vertices and edges in the original graph.\n\nFor the following $m$ lines, the $i$-th line contains two integers $u_i$ and $v_i$ ($1 \\le u_i, v_i \\le n$) indicating an edge connecting vertices $u_i$ and $v_i$ with length $2^i$. There are no self loops nor multiple edges. Note that the graph is not necessarily connected.\n\nIt's guaranteed that neither the sum of $n$ nor the sum of $m$ of all test cases will exceed $10^6$.", "outputFormat": "For each test case output one line. If there are no simple cycles in the graph output ``-1`` (without quotes); Otherwise output $k$ integers separated by a space in increasing order indicating the indices of the edges in the simple cycle with the smallest length. It can be shown that there is at most one answer.\n\nPlease, DO NOT output extra spaces at the end of each line, or your solution may be considered incorrect!", "hint": "The first sample test case is shown below. The integers beside the edges are their indices (outside the parentheses) and lengths (inside the parentheses). The simple cycle with the smallest length consists of edges $2$, $4$, $5$ and $6$ with a length of $2^2 + 2^4 + 2^5 + 2^6 = 116$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2021 Macao R] Link-Cut Tree", "background": "", "description": "宝宝刚刚学会使用一种称为“链接切割树”的数据结构来寻找图中的环，并决定尝试一下。宝宝得到一个有 $n$ 个顶点和 $m$ 条边的无向图，其中第 $i$ 条边的长度为 $2^i$。她需要找到一个长度最小的简单环。\n\n一个简单环是原始图的一个子图，包含 $k$ ($3 \\le k \\le n$) 个顶点 $a_1, a_2, \\cdots, a_k$ 和 $k$ 条边，使得对于所有 $1 \\le i \\le k$，在子图中存在一条边连接顶点 $a_i$ 和 $a_{(i \\mod k) + 1}$。简单环的长度是环中边的总长度。", "inputFormat": "输入包含多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含两个整数 $n$ 和 $m$ ($3 \\le n \\le 10^5$, $1 \\le m \\le 10^5$)，表示原始图中的顶点数和边数。\n\n接下来的 $m$ 行中，第 $i$ 行包含两个整数 $u_i$ 和 $v_i$ ($1 \\le u_i, v_i \\le n$)，表示连接顶点 $u_i$ 和 $v_i$ 的一条边，其长度为 $2^i$。没有自环或重边。注意，图不一定是连通的。\n\n保证所有测试用例中 $n$ 的总和和 $m$ 的总和都不会超过 $10^6$。", "outputFormat": "对于每个测试用例输出一行。如果图中没有简单环，则输出“-1”（不带引号）；否则输出 $k$ 个以空格分隔的整数，按升序表示简单环中最小长度的边的索引。可以证明最多只有一个答案。\n\n请不要在每行末尾输出多余的空格，否则您的解答可能会被视为不正确！", "hint": "第一个样例测试用例如下。边旁边的整数是它们的索引（括号外）和长度（括号内）。长度最小的简单环由边 $2$、$4$、$5$ 和 $6$ 组成，其长度为 $2^2 + 2^4 + 2^5 + 2^6 = 116$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9667", "type": "P", "difficulty": 4, "samples": [["3\n2 0\n2 6\n5 0\n1 2 3 4 5\n5 3\n1 2 3 4 5", "2\n4\n1"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "枚举", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] Tower", "background": "", "description": "Prof. Pang built $n$ block towers with different heights. The $i$-th tower has height $a_i$.\n\nProf. Shou doesn't like these towers because of their arbitrary heights. He decides to $\\textbf{first remove exactly \\textit{m} of them}$, and then perform some (or none) of the following operations: \n\n- Choose a tower and increase its height $a_i$ by $1$. \n- Choose a tower and decrease its height $a_i$ by $1$.\n- Choose a tower and divide its height $a_i$ by $2$. If the new height is not an integer, it is rounded down. \n\nProf. Shou can never choose a removed tower. If after an operation, the height of a tower will become $0$, that operation is not allowed. Under these constraints, Prof. Shou can perform an arbitrary number of operations in arbitrary order. \n\nProf. Shou would like all the towers that are not removed to have the same heights. Please calculate the minimum number of operations to achieve this.", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10)$, the number of test cases.\n\nFor each test case, the first line contains two integers $n, m~(1\\le n\\le 500, 0\\le m <n)$, the number of towers, and the number of towers Prof. Shou should delete before performing the operations.\n\nThe next line contains $n$ integers $a_1,\\ldots, a_n~(1\\le a_i\\le 10^9)$, the initial heights of the towers.", "outputFormat": "For each test case, output the minimum number of operations in one line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Tower", "background": "", "description": "Prof. Pang built $n$ block towers with different heights. The $i$-th tower has height $a_i$.\n\nProf. Shou doesn't like these towers because of their arbitrary heights. He decides to $\\textbf{first remove exactly \\textit{m} of them}$, and then perform some (or none) of the following operations: \n\n- Choose a tower and increase its height $a_i$ by $1$. \n- Choose a tower and decrease its height $a_i$ by $1$.\n- Choose a tower and divide its height $a_i$ by $2$. If the new height is not an integer, it is rounded down. \n\nProf. Shou can never choose a removed tower. If after an operation, the height of a tower will become $0$, that operation is not allowed. Under these constraints, Prof. Shou can perform an arbitrary number of operations in arbitrary order. \n\nProf. Shou would like all the towers that are not removed to have the same heights. Please calculate the minimum number of operations to achieve this.", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10)$, the number of test cases.\n\nFor each test case, the first line contains two integers $n, m~(1\\le n\\le 500, 0\\le m <n)$, the number of towers, and the number of towers Prof. Shou should delete before performing the operations.\n\nThe next line contains $n$ integers $a_1,\\ldots, a_n~(1\\le a_i\\le 10^9)$, the initial heights of the towers.", "outputFormat": "For each test case, output the minimum number of operations in one line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Tower", "background": "", "description": "庞教授搭了 $n$ 座不同高度的塔。第 $i$ 座塔的高度是 $a _ {i}$。\n\n寿教授不喜欢这些参差不齐的塔。他决定**先去掉它们中的 $m$ 座**，然后执行以下操作中的一些（或不执行）：\n- 选择一座塔并增加它 $1$ 个单位高度。\n- 选择一座塔并减少它 $1$ 个单位高度。\n- 选择一座塔并把它的高度 $a _ {i}$ 除以 $2$，如果它不是整数的话，向下取整。\n\n寿教授永远不会选择被拆除的塔。如果操作后，塔的高度变为 $0$，则不允许操作。在这些约束条件下，寿教授可以按任意顺序执行任意数量的运算。\n\n寿教授希望所有没有被拆除的塔都有相同的高度 $a _ {i}$。请计算实现此目标的最小操作次数。", "inputFormat": "第一行是一个整数 $T(1\\leqslant$ $T$ $\\leqslant$ $10)$,表示有 $T$ 组数据。\n\n对于每组测试数据，第一行包括两个整数 $n,m (1\\leqslant$ $n$ $\\leqslant$ $500$,$0$ $\\leqslant$ $m$ $\\leqslant n$)，表示塔的数量以及寿教授在执行操作之前应该删除的塔的数量。\n\n下一行包括 $n$ 个整数 $a _ {1},\\dots,a _ {n} (1\\leqslant$ $a _ {i}$ $\\leqslant$ $10^9)$，表示塔的最初高度。", "outputFormat": "对于每组测试数据，在一行中输出最小操作数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9668", "type": "P", "difficulty": 6, "samples": [["3\n2 3 2 4 2\n7\n8\n1 1 1 1 2\n3\n4\n9 7 10 3 5\n5\n10\n20\n30\n50", "3\n4\n2\n2\n5\n9\n13\n18\n28"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] Torch", "background": "", "description": "Prof. Pang and Prof. Shou go to explore a cave together. Prof. Pang walks ahead of Prof. Shou. \n\nEach of them has a torch for illumination. The torches need fuel to burn. Prof. Pang's torch can burn for $a_1$ seconds once it has been refilled, and it takes $b_1$ seconds to refuel the torch after it burns out. Prof. Shou's torch can burn for $a_2$ seconds once it has been refilled, and it takes $b_2$ seconds to refuel the torch after it burns out. The person who is refueling the torch cannot walk simultaneously. For safety reasons, they cannot refuel the torch until the fuel runs out. \n\nBecause Prof. Pang is too fat and the cave is too narrow, Prof. Shou cannot surpass Prof. Pang during the exploration, which means that Prof. Shou is at least 1 unit behind Prof. Pang. \n\nEach of them can walk forward a distance of 1 unit per second when his torch is burning. Every second, Prof. Pang moves first, then Prof. Shou does. In order to get to their destination earlier, they will move as long as they can walk forward. \n\nNow Prof. Shou has $n$ questions, and for the $i$-th question, he wants to know that at time $q_i$, how many units of the distance he has moved forward from the starting point? Prof. Shou starts 1 unit behind Prof. Pang. The initial time is 0. Both Prof. Pang and Prof. Shou refueled the torch before the initial time.", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the first line contains 5 integers $a_1, b_1, a_2, b_2, n~(1 \\le a_1, b_1, a_2, b_2, n \\le 10^6)$ denoting the time Prof. Pang's torch can burn, the time for Prof. Pang to refuel his torch, the time Prof. Shou's torch can burn, the time for Prof. Shou to refuel his torch, and the number of Prof. Shou's queries. Each of the next $n$ lines describes a query. Query $i$ is denoted by one integer $q_i~(1 \\le q_i \\le 10^{16})$.\n\nIt is guaranteed that over all test cases, each of the following numbers is no more than $10^6$:\n\n- the sum of $a_1$, \n- the sum of $a_2$, \n- the sum of $b_1$, \n- the sum of $b_2$, \n- and the sum of $n$.", "outputFormat": "For each query, print one line containing the answer -- the number of units that Prof. Shou has walked forward from the starting point.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Torch", "background": "", "description": "Prof. Pang and Prof. Shou go to explore a cave together. Prof. Pang walks ahead of Prof. Shou. \n\nEach of them has a torch for illumination. The torches need fuel to burn. Prof. Pang's torch can burn for $a_1$ seconds once it has been refilled, and it takes $b_1$ seconds to refuel the torch after it burns out. Prof. Shou's torch can burn for $a_2$ seconds once it has been refilled, and it takes $b_2$ seconds to refuel the torch after it burns out. The person who is refueling the torch cannot walk simultaneously. For safety reasons, they cannot refuel the torch until the fuel runs out. \n\nBecause Prof. Pang is too fat and the cave is too narrow, Prof. Shou cannot surpass Prof. Pang during the exploration, which means that Prof. Shou is at least 1 unit behind Prof. Pang. \n\nEach of them can walk forward a distance of 1 unit per second when his torch is burning. Every second, Prof. Pang moves first, then Prof. Shou does. In order to get to their destination earlier, they will move as long as they can walk forward. \n\nNow Prof. Shou has $n$ questions, and for the $i$-th question, he wants to know that at time $q_i$, how many units of the distance he has moved forward from the starting point? Prof. Shou starts 1 unit behind Prof. Pang. The initial time is 0. Both Prof. Pang and Prof. Shou refueled the torch before the initial time.", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the first line contains 5 integers $a_1, b_1, a_2, b_2, n~(1 \\le a_1, b_1, a_2, b_2, n \\le 10^6)$ denoting the time Prof. Pang's torch can burn, the time for Prof. Pang to refuel his torch, the time Prof. Shou's torch can burn, the time for Prof. Shou to refuel his torch, and the number of Prof. Shou's queries. Each of the next $n$ lines describes a query. Query $i$ is denoted by one integer $q_i~(1 \\le q_i \\le 10^{16})$.\n\nIt is guaranteed that over all test cases, each of the following numbers is no more than $10^6$:\n\n- the sum of $a_1$, \n- the sum of $a_2$, \n- the sum of $b_1$, \n- the sum of $b_2$, \n- and the sum of $n$.", "outputFormat": "For each query, print one line containing the answer -- the number of units that Prof. Shou has walked forward from the starting point.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Torch", "background": "", "description": "胖子和瘦子在一个山洞里行走，胖子在瘦子前面。每个人都有一支火把。\n\n胖子的火把填满燃料后可以燃烧 $a_1$ 秒，在熄灭后需要花费 $b_1$ 秒填充燃料。\n\n瘦子的火把填满燃料后可以燃烧 $a_2$ 秒，在熄灭后需要花费 $b_2$ 秒填充燃料。\n\n每个人只能在自己的火把燃烧时前进，速度为 $1\\operatorname{m/s}$。\n\n因为胖子太胖，所以瘦子只能跟在胖子后面而不能超过胖子。\n\n每一秒胖子先移动，之后瘦子再移动。\n\n初始时两个人的火把都已经填满了燃料，瘦子在胖子后面 $1 \\operatorname{m}$。\n\n给定 $n$ 个询问，每次给一个正整数 $q_i$，表示查询第 $q_i$ 秒后，瘦子的移动距离。\n\n\n接下来 $n$ 行，每行一个正整数 $q_i$，表示询问。", "inputFormat": "**本题包含多组测试数据**\n\n第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据：", "outputFormat": "每组数据输出 $n$ 行，表示每个询问的答案，即第 $q_i$ 秒后瘦子的移动距离。", "hint": "下面 $\\sum n$ 表示所有数据的 $n$ 之和，$\\sum a_1, \\sum b_1, \\sum a_2, \\sum b_2$ 同理。\n\n$1 \\le T \\le 10^5$，$1 \\le a_1, b_1, a_2, b_2 \\le 10^6$，$\\sum a_1, \\sum b_1, \\sum a_2, \\sum b_2, \\sum n \\le 10^6$，$1 \\le q_i \\le 10^{16}$。", "locale": "zh-CN"}}}
{"pid": "P9669", "type": "P", "difficulty": 6, "samples": [["5\n1 2\n1 3\n3 4\n3 5", "4 0 0 0 0\n0 2 0 0 2\n0 2 2 0 0\n0 0 1 2 1\n0 0 1 2 1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "背包 DP", "树形 DP", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] DFS Order 2", "background": "", "description": "Prof. Pang has a rooted tree that is rooted at vertex $1$ and has $n$ nodes. These $n$ nodes are numbered from $1$ to $n$.\n\nNow he wants to start the depth-first search at the root. He wonders for each node $v$, how many ways it can appear in the $j$-th position of $\\textbf{depth-first search order}$. The depth-first search order is the order of nodes visited during the depth-first search. A node appears in the $j$-th ($1\\le j\\le n$) position in this order means it is visited after $j-1$ other nodes. Because sons of a node can be iterated in arbitrary order, multiple possible depth-first orders exist. \n\nProf. Pang wants to know for each node $v$, how many different $\\textbf{depth-first search order}$s such that $v$ appears in the $j$-th position. For each $v, j~(1 \\le v, j \\le n)$, compute the answer. Because the answer can be very large, output it modulo $998244353$.\n\nFollowing is a pseudo-code for the depth-first search on a rooted tree. After calling $\\textbf{main}$(), $\\texttt{dfs\\_order}$ is the depth-first search order.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l3gjstn0.png)", "inputFormat": "The first line contains one integer $n~(1\\le n \\le 500)$, the number of vertices in the tree.\n\nEach of the next $n-1$ lines describes an edge of the tree. Edge $i$ is denoted by two integers $u_i$ and $v_i$, the labels of vertices it connects $(1\\le u_i,v_i\\le n, u_i\\neq v_i)$.\n\nIt is guaranteed that the given edges form a tree.", "outputFormat": "For each vertex $v$ from $1$ to $n$, output one line containing $n$ integers modulo $998244353$. The $j$-th integer in the $v$-th line should be the number of different depth-first search orders such that $v$ appears in the $j$-th position.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] DFS Order 2", "background": "", "description": "Prof. Pang has a rooted tree that is rooted at vertex $1$ and has $n$ nodes. These $n$ nodes are numbered from $1$ to $n$.\n\nNow he wants to start the depth-first search at the root. He wonders for each node $v$, how many ways it can appear in the $j$-th position of $\\textbf{depth-first search order}$. The depth-first search order is the order of nodes visited during the depth-first search. A node appears in the $j$-th ($1\\le j\\le n$) position in this order means it is visited after $j-1$ other nodes. Because sons of a node can be iterated in arbitrary order, multiple possible depth-first orders exist. \n\nProf. Pang wants to know for each node $v$, how many different $\\textbf{depth-first search order}$s such that $v$ appears in the $j$-th position. For each $v, j~(1 \\le v, j \\le n)$, compute the answer. Because the answer can be very large, output it modulo $998244353$.\n\nFollowing is a pseudo-code for the depth-first search on a rooted tree. After calling $\\textbf{main}$(), $\\texttt{dfs\\_order}$ is the depth-first search order.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l3gjstn0.png)", "inputFormat": "The first line contains one integer $n~(1\\le n \\le 500)$, the number of vertices in the tree.\n\nEach of the next $n-1$ lines describes an edge of the tree. Edge $i$ is denoted by two integers $u_i$ and $v_i$, the labels of vertices it connects $(1\\le u_i,v_i\\le n, u_i\\neq v_i)$.\n\nIt is guaranteed that the given edges form a tree.", "outputFormat": "For each vertex $v$ from $1$ to $n$, output one line containing $n$ integers modulo $998244353$. The $j$-th integer in the $v$-th line should be the number of different depth-first search orders such that $v$ appears in the $j$-th position.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] DFS Order 2", "background": "", "description": "P 有一棵树，根节点是 $1$ ，总共有 $n$ 个节点，从 $1$ 到 $n$ 编号。\n\n他想从根节点开始进行深度优先搜索。他想知道对于每个节点 $v$，在深度优先搜索中，它出现在第 $j$ 个位置的方式有多少种。深度优先搜索的顺序是在搜索过程中访问节点的顺序。节点出现在第 $j\\,(1 \\le j \\le n)$ 个位置表示它在访问了 $j - 1$ 个其他节点之后才被访问。因为节点的子节点可以以任意顺序访问，所以有多种可能的深度优先搜索顺序。\n\nP 想知道对于每个节点 $v$，有多少种不同的深度优先搜索顺序，使得 $v$ 出现在第 $j$ 个位置。对于每个 $v$ 和 $j\\,(i \\le v,j \\le n)$，计算答案。答案可能很大，所以输出时要取模 $998\\,244\\,353$。\n\n以下是深度优先搜索的伪代码，用于处理树。在调用 $\\textbf{main()}$ 函数后，$\\texttt{dfs\\_order}$ 将会包含深度优先搜索的顺序。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l3gjstn0.png)", "inputFormat": "第一行包含一个整数 $n\\,(1\\le n\\le 500)$，表示树中的节点数量。\n\n接下来的n-1行描述了树的边。第i行包含两个整数 $u_i$ 和 $v_i$，表示连接的两个节点的标签 $(1\\le u_i,v_i\\le n,u_i\\not=v_i)$。\n\n保证给定的边构成一棵树。", "outputFormat": "对于每个从 $1$ 到 $n$ 的节点 $v$，输出一行，包含 $n$ 个整数，取模 $998\\,244\\,353$。在第 $v$ 行中，第 $j$ 个整数表示不同的深度优先搜索顺序中，节点 $v$ 出现在第 $j$ 个位置的数量。\n\n翻译由 @ayf2192538031 提供。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9670", "type": "P", "difficulty": 4, "samples": [["1 13\n7 951\n+ 1/6\n? 3 4\n+ 4/183\n- 2\n+ 3/217\n.\n.\n.\n+ 2/29\n+ 1/91\n.\n+ 1/22\n.", "Yes\n+ 1/6\n+ 2/263\n+ 4/183\n- 2\n+ 3/217\n.\n.\n.\n+ 2/29\n+ 1/91\n.\n+ 1/22\n."], ["6 2\n1 100\n.\n? 3 4\n2 100\n+ 1/1\n+ 1/2\n0 0\n- 5\n- 6\n2 480\n? 100 100\n? 100 100\n2 480\n? 99 100\n? 100 100\n1 2000\n? 100 100\n? 100 100", "No\nNo\nYes\n- 5\n- 6\nYes\n+ 1/240\n+ 1/240\nNo\nYes\n+ 87/280\n- 100"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "Special Judge", "O2优化", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] Frozen Scoreboard", "background": "", "description": "There was an ICPC contest two thousand years ago in the Qin dynasty. There were $m$ problems and $n$ teams in the contest. We only know how many problems each team solved and how much total time they used from the historical records. These are called the $\\textbf{final result}$s of the teams. We don't know which problems they solved or their submission times.\n\nRecently, we seem to had a discovery. We found the $\\textbf{frozen scoreboard}$ of the teams. From the frozen scoreboard of a team, we know their submissions during the whole contest, but we don't know the verdicts of the submissions in the last hour. And some people found that for some teams, their frozen scoreboards may contradict their final results in the historical records.\n\nGiven the final results and the frozen scoreboards of the teams, please construct a $\\textbf{final scoreboard}$ for each team that is consistent with both its final result and its frozen scoreboard.\n\nFrom the submissions during the contest, we can calculate the final scoreboard and the final result as follows:\n\nFor a fixed team $i$, its $\\textbf{final scoreboard}$ is an array of $m$ elements where the $j$-th element shows some information about team $i$'s submissions on problem $j$. \n\n- If team $i$ didn't submit to problem $j$, the cell should be a single character ``.`` (without quotes). \n\n- If team $i$ submitted $x$ times to problem $j$ and none of the submissions was accepted, the cell should contain $-\\ x$. \n\n- Otherwise, consider all submissions from team $i$ to problem $j$. Each submission has a submission time. Suppose the earliest accepted submission is the $x$-th one. Then the cell should contain $+\\ x/y$ where $y~(0\\le y\\le 299)$ is the submission time of the $x$-th submission. $y$ is an integer representing the submission time in minutes.\n\nNote that in the final scoreboard, we don't care about submissions after the first accepted one. It is possible that two or more submissions happened in the same minute.\n\nThe $\\textbf{final result}$ of a team is computed from its $\\textbf{final scoreboard}$. For each team, we can calculate the number of problems it solved. This number is equal to the number of ``+`` in the team's final scoreboard.\n\nWe can also calculate its total time. If team $i$ solved problem $j$ in the $y$-th minute after $x-1$ unaccepted submissions (in other words, the $j$-th cell of its final scoreboard is $+\\ x/y$), problem $j$ contributes $20(x-1)+y$ time to team $i$. If team $i$ didn't solve problem $j$, problem $j$ contributes $0$ time to team $i$, no matter team $i$ submitted to problem $j$ or not. The total time of team $i$ is the sum of contributions of each problem.\n\nThe rules for the $\\textbf{frozen scoreboard}$ will be introduced in the input section. We will distinguish submissions in the final hour and other submissions. A submission was in the final hour if its submission time is between $240$ and $299$.", "inputFormat": "The first line contains two integers $n, m~(1\\le n\\le 1000, 1\\le m\\le 13)$, the number of teams in the contest, and the number of problems in the contest.\n\nThen there are $n$ blocks describing the $\\textbf{final result}$ and the $\\textbf{frozen scoreboard}$ of each team.\n\nThe $i$-th block represents team $i$. In the $i$-th block, the first line contains two integers $a_i, b_i~(0\\le a_i\\le m, 0\\le b_i\\le 10^5)$, the number of problems team $i$ solved $\\textbf{during the whole contest}$ and the total time of team $i$ for solving the $a_i$ problems. These two numbers represent the final result of the contest. The next $m$ lines describe the status of team $i$ in the frozen scoreboard. For each $1\\le j\\le m$, \n\n- If the $j$-th line is $+\\ x/y$ $(1\\le x\\le 100, 0\\le y\\le 239)$, team $i$ solved problem $j$ at time $y$ and the accepted solution is their $x$-th submission on problem $j$.\n- If the $j$-th line is $?\\ x\\ y$ $(1\\leq x \\leq y \\leq 100)$, team $i$ didn't solve the problem $j$ in the first four hours. Team $i$ submitted problem $j$ for $y$ times in which $x$ submissions are in the last hour. Note that submissions made in the last hour after the accepted one will count in the $\\textbf{frozen scoreboard}$, but not in the $\\textbf{final scoreboard}$.\n- If the $j$-th line is $-\\ x$, team $i$ didn't solve the problem $j$ in the first four hours. Team $i$ submitted problem $j$ for $x~(1\\le x\\le 100)$ times before the last hour and did not submit problem $j$ in the last hour.\n- If the $j$-th line is a single character ``.`` (without quotes), team $i$ didn't submit problem $j$ at all.", "outputFormat": "For each team $i$, if its final result contradicts its frozen scoreboard, output $\\texttt{No}$ in one line. Otherwise, output $\\texttt{Yes}$ in the first line and then output $m$ lines, describing a final scoreboard that is consistent with both the final result and the frozen scoreboard of team $i$. The $j$-th line should contain \n\n- $+\\ x/y$ $(1\\le x \\le 100, 0\\le y \\le 299)$, if the $x$-th submission from team $i$ to problem $j$ is accepted and is in the $y$-th minute of the contest. All submissions from team $i$ to team $j$ before the $x$-th one was not accepted. Please don't output extra spaces before and after slash ``/``. \n- $-\\ x$ $(1\\le x\\le 100)$, if team $i$ submitted to problem $j$ for $x$ times and none of the submissions was accepted.\n- $.$ if team $i$ didn't submit to problem $j$ at all. \n\nIf there are multiple solutions, output any.\n\n$\\textbf{Please note that in the input and the output, there is always a space following each ?, +, and -.}$", "hint": "Here is an example of the frozen scoreboard in the first sample.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jw4c3965.png)", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Frozen Scoreboard", "background": "", "description": "There was an ICPC contest two thousand years ago in the Qin dynasty. There were $m$ problems and $n$ teams in the contest. We only know how many problems each team solved and how much total time they used from the historical records. These are called the $\\textbf{final result}$s of the teams. We don't know which problems they solved or their submission times.\n\nRecently, we seem to had a discovery. We found the $\\textbf{frozen scoreboard}$ of the teams. From the frozen scoreboard of a team, we know their submissions during the whole contest, but we don't know the verdicts of the submissions in the last hour. And some people found that for some teams, their frozen scoreboards may contradict their final results in the historical records.\n\nGiven the final results and the frozen scoreboards of the teams, please construct a $\\textbf{final scoreboard}$ for each team that is consistent with both its final result and its frozen scoreboard.\n\nFrom the submissions during the contest, we can calculate the final scoreboard and the final result as follows:\n\nFor a fixed team $i$, its $\\textbf{final scoreboard}$ is an array of $m$ elements where the $j$-th element shows some information about team $i$'s submissions on problem $j$. \n\n- If team $i$ didn't submit to problem $j$, the cell should be a single character ``.`` (without quotes). \n\n- If team $i$ submitted $x$ times to problem $j$ and none of the submissions was accepted, the cell should contain $-\\ x$. \n\n- Otherwise, consider all submissions from team $i$ to problem $j$. Each submission has a submission time. Suppose the earliest accepted submission is the $x$-th one. Then the cell should contain $+\\ x/y$ where $y~(0\\le y\\le 299)$ is the submission time of the $x$-th submission. $y$ is an integer representing the submission time in minutes.\n\nNote that in the final scoreboard, we don't care about submissions after the first accepted one. It is possible that two or more submissions happened in the same minute.\n\nThe $\\textbf{final result}$ of a team is computed from its $\\textbf{final scoreboard}$. For each team, we can calculate the number of problems it solved. This number is equal to the number of ``+`` in the team's final scoreboard.\n\nWe can also calculate its total time. If team $i$ solved problem $j$ in the $y$-th minute after $x-1$ unaccepted submissions (in other words, the $j$-th cell of its final scoreboard is $+\\ x/y$), problem $j$ contributes $20(x-1)+y$ time to team $i$. If team $i$ didn't solve problem $j$, problem $j$ contributes $0$ time to team $i$, no matter team $i$ submitted to problem $j$ or not. The total time of team $i$ is the sum of contributions of each problem.\n\nThe rules for the $\\textbf{frozen scoreboard}$ will be introduced in the input section. We will distinguish submissions in the final hour and other submissions. A submission was in the final hour if its submission time is between $240$ and $299$.", "inputFormat": "The first line contains two integers $n, m~(1\\le n\\le 1000, 1\\le m\\le 13)$, the number of teams in the contest, and the number of problems in the contest.\n\nThen there are $n$ blocks describing the $\\textbf{final result}$ and the $\\textbf{frozen scoreboard}$ of each team.\n\nThe $i$-th block represents team $i$. In the $i$-th block, the first line contains two integers $a_i, b_i~(0\\le a_i\\le m, 0\\le b_i\\le 10^5)$, the number of problems team $i$ solved $\\textbf{during the whole contest}$ and the total time of team $i$ for solving the $a_i$ problems. These two numbers represent the final result of the contest. The next $m$ lines describe the status of team $i$ in the frozen scoreboard. For each $1\\le j\\le m$, \n\n- If the $j$-th line is $+\\ x/y$ $(1\\le x\\le 100, 0\\le y\\le 239)$, team $i$ solved problem $j$ at time $y$ and the accepted solution is their $x$-th submission on problem $j$.\n- If the $j$-th line is $?\\ x\\ y$ $(1\\leq x \\leq y \\leq 100)$, team $i$ didn't solve the problem $j$ in the first four hours. Team $i$ submitted problem $j$ for $y$ times in which $x$ submissions are in the last hour. Note that submissions made in the last hour after the accepted one will count in the $\\textbf{frozen scoreboard}$, but not in the $\\textbf{final scoreboard}$.\n- If the $j$-th line is $-\\ x$, team $i$ didn't solve the problem $j$ in the first four hours. Team $i$ submitted problem $j$ for $x~(1\\le x\\le 100)$ times before the last hour and did not submit problem $j$ in the last hour.\n- If the $j$-th line is a single character ``.`` (without quotes), team $i$ didn't submit problem $j$ at all.", "outputFormat": "For each team $i$, if its final result contradicts its frozen scoreboard, output $\\texttt{No}$ in one line. Otherwise, output $\\texttt{Yes}$ in the first line and then output $m$ lines, describing a final scoreboard that is consistent with both the final result and the frozen scoreboard of team $i$. The $j$-th line should contain \n\n- $+\\ x/y$ $(1\\le x \\le 100, 0\\le y \\le 299)$, if the $x$-th submission from team $i$ to problem $j$ is accepted and is in the $y$-th minute of the contest. All submissions from team $i$ to team $j$ before the $x$-th one was not accepted. Please don't output extra spaces before and after slash ``/``. \n- $-\\ x$ $(1\\le x\\le 100)$, if team $i$ submitted to problem $j$ for $x$ times and none of the submissions was accepted.\n- $.$ if team $i$ didn't submit to problem $j$ at all. \n\nIf there are multiple solutions, output any.\n\n$\\textbf{Please note that in the input and the output, there is always a space following each ?, +, and -.}$", "hint": "Here is an example of the frozen scoreboard in the first sample.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jw4c3965.png)", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Frozen Scoreboard", "background": "", "description": "2000 年以前的秦朝，曾举办过一次 ICPC 比赛。比赛中有 $m$ 道题，$n$ 个团队。我们知道每个队完成了多少道题以及其历史记录的总用时。这些称作该团队的结果，但是我们不知道他们每道题是否完成、用时多久。\n\n最近，我们发现了每个队**冻结的计分板**。从该计分板上，我们可以看到每个队在比赛中的提交情况，但是不知道在最后一小时内提交的判分。一些人发现，对于一些队来说，他们冻结的计分板可能与他们在历史记录中的最终成绩相矛盾。\n\n请根据最终得分和冻结的计分板，为各队创建一个与其最终结果和冻结的计分板一致的最终计分板。\n\n按照以下规则来计算计分板和总分：\n\n对于给定的队伍 $i$，它**最终的计分板**是一个 $m$ 元数组，其中第 $j$ 个元素给出队伍 $i$ 在第 $j$ 题上的提交信息。\n\n- 如果队伍 $i$ 没有提交问题 $j$，输出 ```.```。\n\n- 如果队伍 $i$ 对问题 $j$ 提交了 $x$ 次但均未通过，输出 $-x$。\n\n- 否则，考虑队伍 $i$ 在问题 $j$ 的所有评测结果。每次提交都有一个提交时间，设第一个通过的评测是第 $x$ 次评测，在第 $y$ 分钟时提交。输出 $+x/y$，其中 $0\\leq y\\leq299$。\n\n在最终计分板上，只考虑第一次通过的提交。同一分钟内可能有多次提交。\n\n一个队伍的最终得分是该队伍完成了多少道题，即该队最终计分板上 ```+``` 的个数。\n\n一个队伍总用时按如下方式计算。如果队伍 $i$ 在第 $y$ 分钟完成了第 $j$ 道题，在完成前有 $x-1$ 次失败的提交（即最终计分板上第 $j$ 个问题的数为 $+x/y$），该问题的用时记为 $20(x-1)+y$。 如果队伍 $i$ 没有完成第 $j$ 道题，该问题的用时记为 $0$，无论是否提交过。队伍 $i$ 的总时间是每道题用时的总和。", "inputFormat": "第一行包括两个整数 $n,m\\;(1\\leq n\\leq1000,1\\leq m\\leq13)$，为队伍个数和题目个数。\n\n接下来 $n$ 组，描述每个队伍的最终得分和冻结的计分板。\n\n第 $i$ 组表示队伍 $i$。每一组中，第一行包括两个整数 $a_i,b_i\\;(0\\leq a_i\\leq m,0\\leq b_i\\leq10^5)$，为队伍 $i$ 在**整场比赛中**完成的题目个数和每道题的用时。这两个数字是比赛的最终结果。\n\n接下来 $m$ 行，描述队伍 $i$ 在计分板上的内容。对于任意 $1\\leq j\\leq m$，\n\n- 如果第 $j$ 行是 $+\\,x/y\\;(1\\leq x\\leq100,0\\leq y\\leq239)$，表示队伍 $i$ 在第 $y$ 分钟，第 $x$ 次提交时通过了题 $j$。\n\n- 如果第 $j$ 行是 $?\\,x\\,y\\;(1\\leq x\\leq y\\leq100)$，表示队伍 $i$ 没有在前四个小时中作出题 $j$。这个队伍提交了 $y$ 次，其中 $x$ 次在最后一小时内。最后一小时内且通过该题的提交记录会在**冻结的计分板**上显示，但不会在**最终计分板**上显示。\n\n- 如果第 $j$ 行是 $-x$，表示队伍 $i$ 没有在前四小时内作出题 $j$。这个队伍在最后一个小时前提交了 $x\\,(1\\leq x\\leq100)$ 次，且没有在最后一小时内做出题 $j$。\n\n- 如果第 $j$ 行是一个单一的字符 ```.```，表示队伍 $i$ 没有提交过题 $j$。", "outputFormat": "对于每个队伍 $i$，如果最终结果和冻结的计分板相矛盾，输出一行 $\\texttt{No}$。否则，第一行输出 $\\texttt{Yes}$，接下来 $m$ 行，描述一种队伍 $i$ 可能的计分板，满足最终结果和冻结的计分板。其中，第 $j$ 行应该包括：\n\n- $+\\,x/y\\,(1\\leq x\\leq100,0\\leq y\\leq299)$，如果队伍 $i$ 在第 $x$ 次提交，第 $y$ 分钟完成了题 $j$，在这之前没有队伍通过这道题。不要在字符 ```/``` 前后输出多余的空格。\n\n- $-x\\,(1\\leq x\\leq100)$，如果队伍 $i$ 提交了 $x$ 次题 $j$，且均未通过。\n\n- ```.```，如果队伍 $i$ 没有提交题 $j$。\n\n如果有多种可能的答案，任意输出一种即可。\n\n**请注意，在输入和输出中，```?,+,-``` 后总有一个空格。**", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9671", "type": "P", "difficulty": 3, "samples": [["3\n3 1\n4 2\n5 3", "No\nYes\nYes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "Special Judge", "O2优化", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] Identical Parity", "background": "", "description": "Let the value of a sequence be the sum of all numbers in it.\n\nDetermine whether there exists a permutation of length $n$ such that the values of all subsegments of length $k$ of the permutation share the same parity. The values share the same parity means that they are all odd numbers or they are all even numbers.\n\nA subsegment of a permutation is a contiguous subsequence of that permutation. A permutation of length $n$ is a sequence in which each integer from $1$ to $n$ appears exactly once.", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the only line contains two integers $n,k~(1 \\le k \\le n \\le 10^9)$.", "outputFormat": "For each test case, output $\\texttt{Yes}$ (without quotes) if there exists a valid permutation, or $\\texttt{No}$ (without quotes) otherwise.\n\nYou can output $\\texttt{Yes}$ and $\\texttt{No}$ in any case (for example, strings $\\texttt{YES}$, $\\texttt{yEs}$ and $\\texttt{yes}$ will be recognized as positive responses).", "hint": "In the first test case, it can be shown that there does not exist any valid permutation.\n\nIn the second test case, $[1,2,3,4]$ is one of the valid permutations. Its subsegments of length $2$ are $[1,2],[2,3],[3,4]$. Their values are $3,5,7$, respectively. They share the same parity.\n\nIn the third test case, $[1,2,3,5,4]$ is one of the valid permutations. Its subsegments of length $3$ are $[1,2,3],[2,3,5],[3,5,4]$. Their values are $6,10,12$, respectively. They share the same parity.", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Identical Parity", "background": "", "description": "Let the value of a sequence be the sum of all numbers in it.\n\nDetermine whether there exists a permutation of length $n$ such that the values of all subsegments of length $k$ of the permutation share the same parity. The values share the same parity means that they are all odd numbers or they are all even numbers.\n\nA subsegment of a permutation is a contiguous subsequence of that permutation. A permutation of length $n$ is a sequence in which each integer from $1$ to $n$ appears exactly once.", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the only line contains two integers $n,k~(1 \\le k \\le n \\le 10^9)$.", "outputFormat": "For each test case, output $\\texttt{Yes}$ (without quotes) if there exists a valid permutation, or $\\texttt{No}$ (without quotes) otherwise.\n\nYou can output $\\texttt{Yes}$ and $\\texttt{No}$ in any case (for example, strings $\\texttt{YES}$, $\\texttt{yEs}$ and $\\texttt{yes}$ will be recognized as positive responses).", "hint": "In the first test case, it can be shown that there does not exist any valid permutation.\n\nIn the second test case, $[1,2,3,4]$ is one of the valid permutations. Its subsegments of length $2$ are $[1,2],[2,3],[3,4]$. Their values are $3,5,7$, respectively. They share the same parity.\n\nIn the third test case, $[1,2,3,5,4]$ is one of the valid permutations. Its subsegments of length $3$ are $[1,2,3],[2,3,5],[3,5,4]$. Their values are $6,10,12$, respectively. They share the same parity.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Identical Parity", "background": null, "description": "定义一个序列的 **权值** 等于这个序列所有的元素之和。\n\n试判断：是否存在一个长度为 $n$ 的 **排列**，满足以下约束条件？\n\n- 其所有长度为 $k$ 的 **子区间** 的权值具有相同的奇偶性。", "inputFormat": "第一行一个整数 $T$ $(1\\leqslant T\\leqslant 10^5)$，表示测试数据组数。\n\n每组测试数据共一行，包含两个整数 $n,k$ $(1 \\le k \\le  n \\le 10^9)$。", "outputFormat": "对于每组测试数据，输出一行一个字符串。若存在符合题意的排列，输出 $\\texttt{Yes}$；否则，输出 $\\texttt{No}$。\n\n你可以以任意的大小写输出 $\\texttt{Yes}$ 和 $\\texttt{No}$（例如，$\\texttt{YES}$，$\\texttt{yEs}$ 和 $\\texttt{yes}$ 都会被视作合法的输出）。\n\n### 样例解释\n\n对于第一组测试数据，能够证明不存在任何符合题意的排列。\n\n对于第二组测试数据，$[1,2,3,4]$ 是一个符合题意的排列。其所有长度为 $2$ 的子区间分别为 $[1,2],[2,3],[3,4]$，它们的权值分别为 $3,5,7$，具有相同的奇偶性。\n\n对于第三组测试数据，$[1,2,3,5,4]$ 是一个符合题意的排列。其所有长度为 $3$ 的子区间分别为 $[1,2,3],[2,3,5],[3,5,4]$，它们的权值分别为 $6,10,12$，具有相同的奇偶性。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9672", "type": "P", "difficulty": 7, "samples": [["4\n3 3\n1 1\n3 1\n3 3\n4 500000000000000000\n1 1\n1000000000 1\n1000000000 1000000000\n1 1000000000\n9 22\n9 6\n6 7\n9 7\n10 10\n6 9\n3 9\n1 6\n1 5\n7 3\n5 22447972861454999\n270353376 593874603\n230208698 598303091\n237630296 255016434\n782669452 568066304\n654623868 958264153", "3 2\n500000000 500000000\n7 8\n730715389 644702744"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "ICPC", "类欧几里得算法", "济南"], "title": "[ICPC 2022 Jinan R] Grid Points", "background": null, "description": "You are given a simple polygon in the first quadrant of the Cartesian plane. This means that the coordinate $(x,y)$ of any point in the polygon satisfies $x> 0$ and $y> 0$. \n\nConsider all grid points in the polygon. Order them in increasing order of $\\textbf{slopes}$. Output the $k$-th grid point in this order. \n\nA grid point is a point $(x, y)$ such that $x$ and $y$ are integers. A point on the boundary of a polygon is considered to be in the polygon. The slope of point $(x, y)$ is $y/x$. If two points have the same slope, they are ordered lexicographically first by $x$, then by $y$. In other words, a point $(x_1, y_1)$ is lexicographically less than $(x_2, y_2)$ if $(x_1<x_2)\\vee (x_1=x_2 \\wedge y_1<y_2)$.", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 500)$, the number of test cases.\n\nFor each test case, the first line contains two integers $n, k~(n\\ge 3, 1\\le k)$. Each of the next $n$ lines describes a vertex of the polygon. Each vertex is denoted by two integers $x, y~(1\\le x, y\\le 10^9)$, representing its coordinate $(x, y)$. The vertices are given in counterclockwise order.\n\nIt is guaranteed that the polygon is simple, i.e.~ the vertices are distinct, two edges may overlap only when they are consecutive on the boundary, and the overlap contains exactly $1$ point. It is guaranteed that $k$ is no more than the number of grid points in the polygon.\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $2000$.", "outputFormat": "For each test case, output two integers $x, y$ in one line representing the coordinate $(x, y)$ of the $k$-th grid point.", "hint": null, "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Grid Points", "background": null, "description": "You are given a simple polygon in the first quadrant of the Cartesian plane. This means that the coordinate $(x,y)$ of any point in the polygon satisfies $x> 0$ and $y> 0$. \n\nConsider all grid points in the polygon. Order them in increasing order of $\\textbf{slopes}$. Output the $k$-th grid point in this order. \n\nA grid point is a point $(x, y)$ such that $x$ and $y$ are integers. A point on the boundary of a polygon is considered to be in the polygon. The slope of point $(x, y)$ is $y/x$. If two points have the same slope, they are ordered lexicographically first by $x$, then by $y$. In other words, a point $(x_1, y_1)$ is lexicographically less than $(x_2, y_2)$ if $(x_1<x_2)\\vee (x_1=x_2 \\wedge y_1<y_2)$.", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 500)$, the number of test cases.\n\nFor each test case, the first line contains two integers $n, k~(n\\ge 3, 1\\le k)$. Each of the next $n$ lines describes a vertex of the polygon. Each vertex is denoted by two integers $x, y~(1\\le x, y\\le 10^9)$, representing its coordinate $(x, y)$. The vertices are given in counterclockwise order.\n\nIt is guaranteed that the polygon is simple, i.e.~ the vertices are distinct, two edges may overlap only when they are consecutive on the boundary, and the overlap contains exactly $1$ point. It is guaranteed that $k$ is no more than the number of grid points in the polygon.\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $2000$.", "outputFormat": "For each test case, output two integers $x, y$ in one line representing the coordinate $(x, y)$ of the $k$-th grid point.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Grid Points", "background": "", "description": "给你一个在笛卡尔平面第一象限中的多边形。这意味着多边形中任何顶点的坐标 $(x, y)$ 都满足 $x>0$ 和 $y>0$。\n\n考虑多边形中的所有网格点。将它们按**斜率**从小到大排序。输出排序之后的第 $k$ 个网格点。\n\n如果 $x,y\\in \\Z$，那么 $(x,y)$ 就是一个网格点。多边形边界上的一个点也被认为在多边形中。点 $(x,y)$ 的斜率为 $y/x$。如果两个点具有相同的斜率，则先按 $x$ 从小到大排序，再按 $y$ 从小到大排序。换句话说，如果$(x_1<x_2)\\vee(x_1=x_2\\wedge y_1<y_2)$，则点 $(x_1,y_1)$ 在斜率上小于 $(x_2,y_2)$。", "inputFormat": "第一行包含一个整数 $T (1\\le T\\le 500)$，表示数据组数。\n\n对于每组数据，第一行包含两个整数 $n,k(n\\ge 3,1\\le k)$。\n\n接下来 $n$ 行，每行给出了多边形的一个顶点。每个顶点由两个整数 $x,y(1\\le x, y\\le 10^9)$ 表示，表示其坐标 $(x,y)$。顶点按逆时针顺序给出。\n\n保证多边形是简单的，即所有顶点互不相同，两条边只有在相邻时才会重叠，并且恰好重叠 $1$ 次。\n\n保证 $k$ 不超过多边形中的网格点数。\n\n保证 $\\sum n \\le 2000$。", "outputFormat": "对于每组数据，输出一行两个整数 $x,y$，表示第 $k$ 个网格点的坐标。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9673", "type": "P", "difficulty": 5, "samples": [["3\n3\n3 2 1\n5\n2 4 5 3 1\n10\n7 2 4 6 1 9 10 8 5 3", "1\n4\n7"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] Quick Sort", "background": "", "description": "When Prof. Pang was young, he wrote the following code for quick sort. Please calculate how many swaps are performed when calling $\\text{quicksort}(A, 1, n)$. $A$ is a given permutation with length $n$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8ig9i3bq.png)", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the first line contains one positive integer $n~(1\\le n \\le 5\\times 10^5)$. The next line contains $n$ integers $a_1,\\ldots, a_n~(1 \\le a_i\\le n)$ denoting the permutation $A$. It is guaranteed that $a_1,\\ldots, a_n$ form a permutation, i.e.~$a_i\\neq a_j$ for $i \\neq j$. \n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $5\\times 10^5$.", "outputFormat": "For each test case, output one line containing the number of swaps performed when calling $\\text{quicksort}(A, 1, n)$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Quick Sort", "background": "", "description": "When Prof. Pang was young, he wrote the following code for quick sort. Please calculate how many swaps are performed when calling $\\text{quicksort}(A, 1, n)$. $A$ is a given permutation with length $n$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8ig9i3bq.png)", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the first line contains one positive integer $n~(1\\le n \\le 5\\times 10^5)$. The next line contains $n$ integers $a_1,\\ldots, a_n~(1 \\le a_i\\le n)$ denoting the permutation $A$. It is guaranteed that $a_1,\\ldots, a_n$ form a permutation, i.e.~$a_i\\neq a_j$ for $i \\neq j$. \n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $5\\times 10^5$.", "outputFormat": "For each test case, output one line containing the number of swaps performed when calling $\\text{quicksort}(A, 1, n)$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Quick Sort", "background": "", "description": "给定一个长度为 $n$ 的排列 $A$。现使用如下伪代码对 $A$ 进行排序：\n\n```\nprocedure QUICKSORT(A,lo,hi)\n    if lo>=0 and hi>=0 and lo<hi then\n    \tp=PARTITION(A,lo,hi)\n        QUICKSORT(A,lo,p)\n        QUICKSORT(A,p+1,hi)\n    end if\nend procedure\nprocedure PARTITION(A,lo,hi)\n    pivot=A[floor((hi+lo)/2)]\n    i=lo-1\n    j=hi+1\n    while True do\n        repeat\n            i=i+1\n        until A[i]>=pivot\n        repeat\n            j=j-1\n        until A[j]<=pivot\n        if i>=j then\n            return j\n        end if\n        Swap A[i] with A[j]\n    end while\nend procedure\n```\n\n试计算：调用 `QUICKSORT(A,1,n)` 函数过程中，`Swap` 操作执行了多少次。", "inputFormat": "第一行包含一个整数 $T$ $(1\\leqslant T\\leqslant 10^5)$，表示测试数据组数。\n\n对于每组测试数据：\n\n第一行包含一个正整数 $n$ $(1\\leqslant n\\leqslant 5\\times 10^5)$。\n\n第二行包含 $n$ 个整数 $a_1,\\dots,a_n$ $(1\\leqslant a_i\\leqslant n)$，表示排列 $A$。保证 $a_1,\\dots,a_n$ 构成一个排列，即：$\\forall i\\not= j,a_i\\not=a_j$。\n\n保证所有测试数据中 $n$ 的和不超过 $5\\times 10^5$。", "outputFormat": "对于每组测试数据，输出一行一个整数，表示调用 `QUICKSORT(A,1,n)` 函数过程中，`Swap` 操作执行的次数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9674", "type": "P", "difficulty": 6, "samples": [["4\n1\n1 1000000000\n2\n1 1000000000\n1 1000000000\n4\n1 2\n3 4\n5 6\n7 8\n4\n1 3\n2 4\n5 8\n6 7", "1\n499999999500000000\n26\n28"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "ICPC", "Ad-hoc", "分类讨论", "济南"], "title": "[ICPC 2022 Jinan R] Set of Intervals", "background": "", "description": "Prof. Pang has a multi-set of intervals $S=\\{[l_i,r_i]\\}$($l_i<r_i$).\n\nProf. Pang will perform the following operation for $|S|-1$ times:\n\n- Select two intervals $[a,b]$ and $[c,d]$ from $S$, and then choose two integers $x,y$ satisfying $x\\in [a,b], y\\in [c,d], x<y$. After that, delete $[a,b]$ and $[c,d]$ from $S$, and add $[x,y]$ to $S$.\n\nIt's easy to find that $S$ contains exactly one interval after the operations, and Prof. Pang will get the interval as a gift.\n\nNow Prof. Pang wants you to calculate how many different intervals he can get.", "inputFormat": "The first line contains one integer $T~$($1\\le T \\le 10^4$), the number of test cases.\n\nFor each test case, the first line contains one integer $n~$($1\\le n\\le 10^5$) --- the size of $S$. Each of the following $n$ lines contains two integers $l_i$ and $r_i~$($1\\le l_i<r_i\\le 10^9$), describing the $i$-th interval in $S$.\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $10^5$.", "outputFormat": "For each test case, output one line containing the answer to Prof. Pang's question.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Set of Intervals", "background": "", "description": "Prof. Pang has a multi-set of intervals $S=\\{[l_i,r_i]\\}$($l_i<r_i$).\n\nProf. Pang will perform the following operation for $|S|-1$ times:\n\n- Select two intervals $[a,b]$ and $[c,d]$ from $S$, and then choose two integers $x,y$ satisfying $x\\in [a,b], y\\in [c,d], x<y$. After that, delete $[a,b]$ and $[c,d]$ from $S$, and add $[x,y]$ to $S$.\n\nIt's easy to find that $S$ contains exactly one interval after the operations, and Prof. Pang will get the interval as a gift.\n\nNow Prof. Pang wants you to calculate how many different intervals he can get.", "inputFormat": "The first line contains one integer $T~$($1\\le T \\le 10^4$), the number of test cases.\n\nFor each test case, the first line contains one integer $n~$($1\\le n\\le 10^5$) --- the size of $S$. Each of the following $n$ lines contains two integers $l_i$ and $r_i~$($1\\le l_i<r_i\\le 10^9$), describing the $i$-th interval in $S$.\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $10^5$.", "outputFormat": "For each test case, output one line containing the answer to Prof. Pang's question.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Set of Intervals", "background": "", "description": "庞教授有一个多重区间集 $S=\\{[l_i,r_i]\\}$（$l_i<r_i$）。\n\n庞教授将对 $|S|-1$ 次执行以下操作：\n\n- 从 $S$ 中选择两个区间 $[a,b]$ 和 $[c,d]$，然后选择两个整数 $x,y$ 满足 $x\\in [a,b], y\\in [c,d], x<y$。之后，从 $S$ 中删除 $[a,b]$ 和 $[c,d]$，并将 $[x,y]$ 添加到 $S$。\n\n很容易发现，经过这些操作后，$S$ 中恰好包含一个区间，庞教授将得到这个区间作为礼物。\n\n现在庞教授希望你计算他可以得到多少个不同的区间。", "inputFormat": "第一行包含一个整数 $T$（$1\\le T \\le 10^4$），表示测试用例的数量。\n\n对于每个测试用例，第一行包含一个整数 $n$（$1\\le n\\le 10^5$）——$S$ 的大小。接下来的 $n$ 行中的每一行包含两个整数 $l_i$ 和 $r_i$（$1\\le l_i<r_i\\le 10^9$），描述 $S$ 中的第 $i$ 个区间。\n\n保证所有测试用例的 $n$ 之和不超过 $10^5$。", "outputFormat": "对于每个测试用例，输出一行，包含庞教授问题的答案。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9675", "type": "P", "difficulty": 7, "samples": [["4\n3 2 10\n1 2 5\n2 3 4\n3 0 1000000000\n3 3 100\n1 2 3\n1 3 4\n2 3 5\n4 6 1000000000\n1 2 244\n1 2 325\n1 4 927\n3 3 248\n2 4 834\n3 4 285", "125\n0\n15300\n840659991"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "半平面交", "ICPC", "李超线段树", "济南"], "title": "[ICPC 2022 Jinan R] Shortest Path", "background": "", "description": "You are given an undirected weighted graph $G$ with vertices $1, 2, \\ldots, n$. Please output the sum of the answers to the following $x$ questions:\n- The $i$-th question $(1\\le i\\le x$): What is the minimum length of path that starts at vertex $1$, ends at vertex $n$, and contains exactly $i$ edges?\n\nFor each question, if such a path does not exist, the answer is considered to be $0$. A path may use one edge multiple times. Output the answer modulo $998244353$. \n", "inputFormat": "The first line contains one integer $T~(1 \\le T\\le 2000)$, the number of test cases.\n\nFor each test case, the first line contains three integers $n, m, x~(1\\le n\\le 2000, 0\\le m\\le 5000, 1\\le x\\le 10^9)$. Each of the next $m$ lines describes an edge of the graph. Edge $i$ is denoted by three integers $a_i, b_i, w_i$ $(1\\le a_i, b_i\\le n, 1\\le w_i\\le 10^9)$, the labels of vertices it connects and its weight. Note that self-loops and parallel edges may exist.\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $2000$ and the sum of $m$ over all test cases is no more than $5000$.", "outputFormat": "For each test case, output one integer modulo $998244353$ denoting the answer.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Shortest Path", "background": "", "description": "You are given an undirected weighted graph $G$ with vertices $1, 2, \\ldots, n$. Please output the sum of the answers to the following $x$ questions:\n- The $i$-th question $(1\\le i\\le x$): What is the minimum length of path that starts at vertex $1$, ends at vertex $n$, and contains exactly $i$ edges?\n\nFor each question, if such a path does not exist, the answer is considered to be $0$. A path may use one edge multiple times. Output the answer modulo $998244353$. \n", "inputFormat": "The first line contains one integer $T~(1 \\le T\\le 2000)$, the number of test cases.\n\nFor each test case, the first line contains three integers $n, m, x~(1\\le n\\le 2000, 0\\le m\\le 5000, 1\\le x\\le 10^9)$. Each of the next $m$ lines describes an edge of the graph. Edge $i$ is denoted by three integers $a_i, b_i, w_i$ $(1\\le a_i, b_i\\le n, 1\\le w_i\\le 10^9)$, the labels of vertices it connects and its weight. Note that self-loops and parallel edges may exist.\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $2000$ and the sum of $m$ over all test cases is no more than $5000$.", "outputFormat": "For each test case, output one integer modulo $998244353$ denoting the answer.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Shortest Path", "background": "", "description": "给定一张 $n$ 个点 $m$ 条边的无向图 $G$，边有边权。你要回答 $x$ 个问题，其中第 $i$ $(1\\leqslant i\\leqslant x)$ 个问题形如：\n\n- 从结点 $1$ 出发，经过 **恰好** $i$ 条边，到达结点 $n$ 的最短路径长度为多少？\n\n对于每个询问，若不存在这样的路径，答案应当为 $0$。一条路径可能 **多次** 经过一条边。\n\n求出这 $x$ 个问题所对应的答案之和。输出答案对 $998244353$ 取模后的结果。", "inputFormat": "第一行包含一个整数 $T$ $(1\\leqslant T\\leqslant 2000)$，表示测试数据组数。\n\n对于每组测试数据：\n\n第一行三个整数 $n,m,x$ $(1\\leqslant n\\leqslant 2000,0\\leqslant m\\leqslant 5000,1\\leqslant x\\leqslant 10^9)$。\n\n接下来 $m$ 行，每行三个整数 $a_i,b_i,w_i$ $(1\\leqslant a_i,b_i\\leqslant n,1\\leqslant w_i\\leqslant 10^9)$，分别表示第 $i$ 条边连接的两个结点的编号和其边权。注意 **可能存在自环和重边**。\n\n保证所有测试数据中 $n$ 的总和不超过 $2000$，且 $m$ 的总和不超过 $5000$。", "outputFormat": "对于每组测试数据，输出这组测试数据对应的答案 $\\bmod$ $998244353$ 后的结果。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P9676", "type": "P", "difficulty": 6, "samples": [["2\n3\n1 1 10\n1 10 1\n10 1 1\n5\n1 2 3\n6 5 4\n7 8 9\n12 11 10\n13 14 15\n", "26\n41"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2022", "O2优化", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R]  Skills", "background": "", "description": "\nProf. Pang has $3$ different skills to practice, including soda drinking, fox hunting, and stock investing. We call them Skill $1$, Skill $2$, and Skill $3$. In each of the following $n$ days, Prof. Pang can choose one of the three skills to practice. In the $i$-th day ($1\\le i\\le n$), if Prof. Pang chooses Skill $j$ ($1\\le j\\le 3$) to practice, his level of Skill $j$ will increase by $a_{i,j}$. Initially, Prof. Pang's levels of all skills are $0$.\n\nProf. Pang forgets skills if he does not practice. At the end of each day, if he has not practiced Skill $j$ for $k$ days, his level of Skill $j$ will decrease by $k$. For example, if he practices Skill $1$ on day $1$ and Skill $2$ on day $2$, at the end of day $2$, he has not practiced Skill $1$ for $1$ day and has not practiced Skill $3$ for $2$ days. Then his levels of Skill $1$ and Skill $3$ will decrease by $1$ and $2$, respectively. His level of Skill $2$ does not decrease at the end of day $2$ because he practices Skill $2$ on that day. In this example, we also know that his levels of Skill $2$ and Skill $3$ both decrease by $1$ at the end of day $1$.\n\nProf. Pang's level of any skill will not decrease below $0$. For example, if his level of some skill is $3$ and at the end of some day, this level is decreased by $4$, it will become $0$ instead of $-1$.\n\nProf. Pang values all skills equally. Thus, he wants to maximize the sum of his three skill levels after the end of day $n$. \n\nGiven $a_{i,j}$ ($1\\le i\\le n, 1\\le j\\le 3$), find the maximum sum.\n", "inputFormat": "The first line contains a single integer $T~(1 \\le T \\le 1000)$ denoting the number of test cases.\n\nFor each test case, the first line contains an integer $n~(1 \\le n \\le 1000)$. The $(i+1)$-th line contains three integers $a_{i,1}, a_{i,2}, a_{i,3}$ ($0\\le a_{i,j}\\le 10000$ for any $1\\le i\\le n, 1\\le j\\le 3$).\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $1000$.", "outputFormat": "For each test case, output the maximum possible sum of skill levels in one line. ", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R]  Skills", "background": "", "description": "\nProf. Pang has $3$ different skills to practice, including soda drinking, fox hunting, and stock investing. We call them Skill $1$, Skill $2$, and Skill $3$. In each of the following $n$ days, Prof. Pang can choose one of the three skills to practice. In the $i$-th day ($1\\le i\\le n$), if Prof. Pang chooses Skill $j$ ($1\\le j\\le 3$) to practice, his level of Skill $j$ will increase by $a_{i,j}$. Initially, Prof. Pang's levels of all skills are $0$.\n\nProf. Pang forgets skills if he does not practice. At the end of each day, if he has not practiced Skill $j$ for $k$ days, his level of Skill $j$ will decrease by $k$. For example, if he practices Skill $1$ on day $1$ and Skill $2$ on day $2$, at the end of day $2$, he has not practiced Skill $1$ for $1$ day and has not practiced Skill $3$ for $2$ days. Then his levels of Skill $1$ and Skill $3$ will decrease by $1$ and $2$, respectively. His level of Skill $2$ does not decrease at the end of day $2$ because he practices Skill $2$ on that day. In this example, we also know that his levels of Skill $2$ and Skill $3$ both decrease by $1$ at the end of day $1$.\n\nProf. Pang's level of any skill will not decrease below $0$. For example, if his level of some skill is $3$ and at the end of some day, this level is decreased by $4$, it will become $0$ instead of $-1$.\n\nProf. Pang values all skills equally. Thus, he wants to maximize the sum of his three skill levels after the end of day $n$. \n\nGiven $a_{i,j}$ ($1\\le i\\le n, 1\\le j\\le 3$), find the maximum sum.\n", "inputFormat": "The first line contains a single integer $T~(1 \\le T \\le 1000)$ denoting the number of test cases.\n\nFor each test case, the first line contains an integer $n~(1 \\le n \\le 1000)$. The $(i+1)$-th line contains three integers $a_{i,1}, a_{i,2}, a_{i,3}$ ($0\\le a_{i,j}\\le 10000$ for any $1\\le i\\le n, 1\\le j\\le 3$).\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $1000$.", "outputFormat": "For each test case, output the maximum possible sum of skill levels in one line. ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R]  Skills", "background": null, "description": "庞博士有 $3$ 项技能：喝汽水、猎狐和炒股，编号分别为 $1,2,3$。初始时，每项技能的熟练度为 $0$。\n\n接下来有 $n$ 天。在第 $i$ 天，庞博士可以选择一项技能（假设是第 $j$ 项）进行练习，然后在这天结束时让这项技能的熟练度增加 $a_{i,j}(0\\leq a_{i,j}\\leq 10000)$。同时，如果某一项技能（假设是第 $k$ 项）已经有 $x$ 天没有练习，那么在这天结束时，这项技能的熟练度会减少 $x$。当然，任何一项技能的熟练度都不可能小于 $0$。\n\n现在，庞博士想知道：在第 $n$ 天结束后，这 $3$ 项技能的熟练度之和最大为多少。由于他非常忙，而且他的日程和对习惯的适应程度可能有变，所以庞博士把这 $T$ 个问题交给了你——每个问题的内容都一样，只是给出的数据可能有所不同而已。", "inputFormat": "第一行，一个正整数 $T~(1 \\leq T \\leq 1000)$，表示数据组数。\n\n对于每组数据，输入 $(n + 1)$ 行。\n\n* 第一行，一个正整数 $n\\ (1 \\leq n \\leq 1000)$，表示天数。\n* 第 $i + 1$ 行，包含三个正整数 $a_{i, 1}, a_{i, 2}, a_{i, 3}\\ (0 \\leq a_{i, j} \\leq 10000,\\ \\forall 1 \\leq i \\leq n,\\ 1 \\leq j \\leq 3)$。\n\n数据保证单个测试点内的 $\\sum n$ 不超过 $1000$。", "outputFormat": "对于每组数据，输出 $1$ 行 $1$ 个数，表示答案。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9677", "type": "P", "difficulty": 2, "samples": [["3\n3\n1 2 3\n3\n3 2 1\n5\n1 4 2 5 3\n", "3\n1\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] Stack Sort", "background": "", "description": "You are given a permutation with $n$ numbers, $a_1, a_2, \\dots, a_n (1\\leq a_i\\leq n, a_i\\neq a_j\\textrm{ when }i\\neq j)$. \n\nYou want to sort these numbers using $m$ stacks. Specifically, you should complete the following task: \n\nInitially, all stacks are empty. You need to push each number $a_i$ to the top of one of the $m$ stacks one by one, in the order of $a_1,a_2,\\ldots, a_n$. $\\textbf{After pushing all numbers in the stacks}$, you pop all the elements from the stacks in a clever order so that the first number you pop is $1$, the second number you pop is $2$, and so on. **If you pop an element from a stack $S$, you cannot pop any element from the other stacks until $S$ becomes empty.**\n\nWhat is the minimum possible $m$ to complete the task?", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the first line contains one positive integer $n~(1\\le n \\le 5 \\times 10^5)$. The next line contains $n$ integers $a_1,\\ldots, a_n~(1 \\le a_i\\le n)$ denoting the permutation. It is guaranteed that $a_1,\\ldots, a_n$ form a permutation, i.e. $a_i\\neq a_j$ for $i \\neq j$. \n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $5\\times 10^5$.\n", "outputFormat": "For each test case, output the minimum possible $m$ in one line.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Stack Sort", "background": "", "description": "You are given a permutation with $n$ numbers, $a_1, a_2, \\dots, a_n (1\\leq a_i\\leq n, a_i\\neq a_j\\textrm{ when }i\\neq j)$. \n\nYou want to sort these numbers using $m$ stacks. Specifically, you should complete the following task: \n\nInitially, all stacks are empty. You need to push each number $a_i$ to the top of one of the $m$ stacks one by one, in the order of $a_1,a_2,\\ldots, a_n$. $\\textbf{After pushing all numbers in the stacks}$, you pop all the elements from the stacks in a clever order so that the first number you pop is $1$, the second number you pop is $2$, and so on. **If you pop an element from a stack $S$, you cannot pop any element from the other stacks until $S$ becomes empty.**\n\nWhat is the minimum possible $m$ to complete the task?", "inputFormat": "The first line contains one integer $T~(1\\le T \\le 10^5)$, the number of test cases.\n\nFor each test case, the first line contains one positive integer $n~(1\\le n \\le 5 \\times 10^5)$. The next line contains $n$ integers $a_1,\\ldots, a_n~(1 \\le a_i\\le n)$ denoting the permutation. It is guaranteed that $a_1,\\ldots, a_n$ form a permutation, i.e. $a_i\\neq a_j$ for $i \\neq j$. \n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $5\\times 10^5$.\n", "outputFormat": "For each test case, output the minimum possible $m$ in one line.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Stack Sort", "background": "", "description": "给定一个包含 $n$ 个数字的排列 $a_1, a_2, \\dots, a_n (1\\leq a_i\\leq n, a_i\n\\neq a_j\\text{ 当 }i\n\\neq j)$。\n\n你需要使用 $m$ 个栈对这些数字进行排序。具体来说，你需要完成以下任务：\n\n最初，所有栈都是空的。你需要按照 $a_1,a_2,\\ldots, a_n$ 的顺序，将每个数字 $a_i$ 压入 $m$ 个栈中的一个栈的顶部。**在将所有数字压入栈中之后**，你需要以一种巧妙的顺序从栈中弹出所有元素，使得你弹出的第一个数字是 $1$，第二个数字是 $2$，依此类推。**如果你从一个栈 $S$ 中弹出一个元素，那么在 $S$ 变空之前，你不能从其他栈中弹出任何元素。**\n\n完成任务所需的最小 $m$ 是多少？", "inputFormat": "第一行包含一个整数 $T~(1\\le T \\le 10^5)$，表示测试用例的数量。\n\n对于每个测试用例，第一行包含一个正整数 $n~(1\\le n \\le 5 \\times 10^5)$。下一行包含 $n$ 个整数 $a_1,\\ldots, a_n~(1 \\le a_i\\le n)$，表示排列。保证 $a_1,\\ldots, a_n$ 形成一个排列，即 $a_i\n\\neq a_j$ 对于 $i \n\\neq j$。\n\n保证所有测试用例中 $n$ 的总和不超过 $5\\times 10^5$。", "outputFormat": "对于每个测试用例，输出一个整数，表示完成任务所需的最小 $m$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9678", "type": "P", "difficulty": 7, "samples": [["5\n1 2 5\n1 3 3\n1 4 4\n3 5 2\n5\n1 1\n1 4\n2 4\n3 4\n2 5\n", "-1\n3\n7\n7\n2\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["点分治", "2022", "O2优化", "ICPC", "济南"], "title": "[ICPC 2022 Jinan R] Tree Distance", "background": "", "description": "You are given an unrooted weighted tree $T$ with vertices $1, 2, \\ldots, n$. Please answer some queries.\n\nWe define $\\texttt{dist}(i,j)$ as the distance between vertex $i$ and vertex $j$ in $T$.\n\nFor each query, you are given two integers $l, r$. Please answer the value of \n\n$$\\min_{l\\le i< j\\le r}(\\texttt{dist}(i,j)).$$", "inputFormat": "The first line contains one integer $n~(1\\leq n\\le 2 \\times 10^5)$, the number of vertices in the tree. \n\nEach of the next $n-1$ lines describes an edge of the tree. Edge $i$ is denoted by three integers $a_i, b_i, w_i$ $(1\\le a_i, b_i\\le n, 1\\le w_i\\le 10^9)$, the labels of vertices it connects and its weight. \n\nThen one line contains one integer $q~(1\\leq q\\le 10^6)$, the number of queries.\n\nEach of the following $q$ lines contains two integers $l, r~(1\\le l \\le r\\le n)$ describing a query.\n\nIt is guaranteed that the given edges form a tree.", "outputFormat": "\nFor each query, output the answer in one line. If there is no $i,j$ such that $l\\le i<j\\le r$, the answer is $-1$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2022 Jinan R] Tree Distance", "background": "", "description": "You are given an unrooted weighted tree $T$ with vertices $1, 2, \\ldots, n$. Please answer some queries.\n\nWe define $\\texttt{dist}(i,j)$ as the distance between vertex $i$ and vertex $j$ in $T$.\n\nFor each query, you are given two integers $l, r$. Please answer the value of \n\n$$\\min_{l\\le i< j\\le r}(\\texttt{dist}(i,j)).$$", "inputFormat": "The first line contains one integer $n~(1\\leq n\\le 2 \\times 10^5)$, the number of vertices in the tree. \n\nEach of the next $n-1$ lines describes an edge of the tree. Edge $i$ is denoted by three integers $a_i, b_i, w_i$ $(1\\le a_i, b_i\\le n, 1\\le w_i\\le 10^9)$, the labels of vertices it connects and its weight. \n\nThen one line contains one integer $q~(1\\leq q\\le 10^6)$, the number of queries.\n\nEach of the following $q$ lines contains two integers $l, r~(1\\le l \\le r\\le n)$ describing a query.\n\nIt is guaranteed that the given edges form a tree.", "outputFormat": "\nFor each query, output the answer in one line. If there is no $i,j$ such that $l\\le i<j\\le r$, the answer is $-1$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2022 Jinan R] Tree Distance", "background": "", "description": "给定一个无根的加权树 $T$，其顶点为 $1, 2, \\ldots, n$。请回答一些查询。\n\n我们定义 $\\texttt{dist}(i,j)$ 为顶点 $i$ 和顶点 $j$ 在树 $T$ 中的距离。\n\n对于每个查询，给定两个整数 $l, r$。请回答以下值：\n\n$$\\min_{l\\le i< j\\le r}(\\texttt{dist}(i,j)).$$", "inputFormat": "第一行包含一个整数 $n~(1\\leq n\\le 2 \\times 10^5)$，表示树中的顶点数。\n\n接下来的 $n-1$ 行描述了树中的一条边。第 $i$ 条边由三个整数 $a_i, b_i, w_i$ $(1\\le a_i, b_i\\le n, 1\\le w_i\\le 10^9)$ 表示，分别为它连接的顶点的标签及其权重。\n\n然后一行包含一个整数 $q~(1\\leq q\\le 10^6)$，表示查询的数量。\n\n接下来的 $q$ 行中的每一行包含两个整数 $l, r~(1\\le l \\le r\\le n)$，描述一个查询。\n\n保证给定的边构成一棵树。", "outputFormat": "对于每个查询，输出答案一行。如果不存在 $i,j$ 使得 $l\\le i<j\\le r$，则答案为 $-1$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
