{"pid": "P6749", "type": "P", "difficulty": 7, "samples": [["3 3\n3 2 1 \n2 \n1 1 3 1 \n2 ", "3 \n0 "]], "limits": {"time": [1000, 1000, 1000, 1000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["线段树", "颜色段均摊（珂朵莉树 ODT）", "O2优化", "树套树", "分块", "洛谷月赛"], "title": "『MdOI R3』Yoshino", "background": "\n\n『变成了精灵确实是遭遇了许多难过的事情，也遭遇了许多悲伤的事情。但是——我也得到了比这些难过和悲伤多得多的快乐与开心。』\n\n『——我觉得，虽然澪小姐想要使用我的生命，但是作为交换，她不是也让我活了更长的时间了吗？』\n\n『对了——差点忘了。四糸奈，……稍微一会儿，可以吗。』\n\n『那么，正式介绍一下呢，——妈妈。』\n\n『这位是七罪小姐，我——最重要的朋友。』\n\n『这位是士道先生，是我——最喜欢的人。』\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v7zfroxm.png)", "description": "Yoshino 给了你一个长度为 $n$ 的序列，第 $i$ 项为 $a_i$。\n\n现在 Yoshino 会对数列进行 $m$ 次操作。\n\n操作分成两种：\n\n - $1\\  l\\  r\\  x$ Yoshino 把数列下标在 $[l,r]$ 区间内的数修改为了一个从 $x$ 开始公差为 $1$ 的等差数列。\n\n - $2$ Yoshino 需要查询整个数列中的逆序对个数。逆序对的定义为数对 $(i,j)$ 满足 $i<j$ 且 $a_i>a_j$。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数，第 $i$ 个为 $a_i$。\n\n接下来 $m$ 行，每行代表一个操作，含义见上。", "outputFormat": "对于每次询问，一行一个整数输出答案。", "hint": "【样例解释】 \n\n第一次操作为询问操作，此时有 $(1,3),(2,3),(1,2)$ 三组逆序对，答案为 $3$。\n\n第二次操作修改完成后，数列变为 $1\\ 2\\ 3$。\n\n第三次操作为询问操作，此时数列中没有逆序对，故答案为 $0$。\n\n更多样例请[到这里](https://www.luogu.com.cn/paste/j4nq14ov)领取。\n\n---\n\n【数据范围】\n\n**本题采用捆绑测试**\n\n| 子任务编号 | $n,m\\le$       | 特殊条件                               | 分值  | 时限  |\n| ---------- | -------------- | -------------------------------------- | ----- | ----- |\n| $1$        | $500$          | 无                                     | $10 $ | $1s$  |\n| $2$        | $3\\times 10^3$ | 无                                     | $10$  | $1s $ |\n| $3$        | $3\\times 10^4$ | 修改长度为 $1$                         | $15$  | $2s $ |\n| $4$        | $3\\times 10^4$ | 保证任何时刻序列中的最大值不超过 $15$ | $20 $ | $2s $ |\n| $5$        | $3\\times 10^4$ | 保证第奇数次操作 $1$ 为 $1\\ 1\\ n\\ 1$   | $20$  | $ 2s$ |\n| $6$        | $3\\times 10^4$ | 无特殊限制                             | $25 $ | $2s$  |\n\n对于所有的数据，$1\\le n,m,a_i\\le 3\\times 10^4$，$1\\le l\\le r\\le n$，$1\\le x\\le 3\\times 10^4-r+l$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『MdOI R3』Yoshino", "background": "\n\n『变成了精灵确实是遭遇了许多难过的事情，也遭遇了许多悲伤的事情。但是——我也得到了比这些难过和悲伤多得多的快乐与开心。』\n\n『——我觉得，虽然澪小姐想要使用我的生命，但是作为交换，她不是也让我活了更长的时间了吗？』\n\n『对了——差点忘了。四糸奈，……稍微一会儿，可以吗。』\n\n『那么，正式介绍一下呢，——妈妈。』\n\n『这位是七罪小姐，我——最重要的朋友。』\n\n『这位是士道先生，是我——最喜欢的人。』\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v7zfroxm.png)", "description": "Yoshino 给了你一个长度为 $n$ 的序列，第 $i$ 项为 $a_i$。\n\n现在 Yoshino 会对数列进行 $m$ 次操作。\n\n操作分成两种：\n\n - $1\\  l\\  r\\  x$ Yoshino 把数列下标在 $[l,r]$ 区间内的数修改为了一个从 $x$ 开始公差为 $1$ 的等差数列。\n\n - $2$ Yoshino 需要查询整个数列中的逆序对个数。逆序对的定义为数对 $(i,j)$ 满足 $i<j$ 且 $a_i>a_j$。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数，第 $i$ 个为 $a_i$。\n\n接下来 $m$ 行，每行代表一个操作，含义见上。", "outputFormat": "对于每次询问，一行一个整数输出答案。", "hint": "【样例解释】 \n\n第一次操作为询问操作，此时有 $(1,3),(2,3),(1,2)$ 三组逆序对，答案为 $3$。\n\n第二次操作修改完成后，数列变为 $1\\ 2\\ 3$。\n\n第三次操作为询问操作，此时数列中没有逆序对，故答案为 $0$。\n\n更多样例请[到这里](https://www.luogu.com.cn/paste/j4nq14ov)领取。\n\n---\n\n【数据范围】\n\n**本题采用捆绑测试**\n\n| 子任务编号 | $n,m\\le$       | 特殊条件                               | 分值  | 时限  |\n| ---------- | -------------- | -------------------------------------- | ----- | ----- |\n| $1$        | $500$          | 无                                     | $10 $ | $1s$  |\n| $2$        | $3\\times 10^3$ | 无                                     | $10$  | $1s $ |\n| $3$        | $3\\times 10^4$ | 修改长度为 $1$                         | $15$  | $2s $ |\n| $4$        | $3\\times 10^4$ | 保证任何时刻序列中的最大值不超过 $15$ | $20 $ | $2s $ |\n| $5$        | $3\\times 10^4$ | 保证第奇数次操作 $1$ 为 $1\\ 1\\ n\\ 1$   | $20$  | $ 2s$ |\n| $6$        | $3\\times 10^4$ | 无特殊限制                             | $25 $ | $2s$  |\n\n对于所有的数据，$1\\le n,m,a_i\\le 3\\times 10^4$，$1\\le l\\le r\\le n$，$1\\le x\\le 3\\times 10^4-r+l$。", "locale": "zh-CN"}}}
{"pid": "P6750", "type": "P", "difficulty": 7, "samples": [["1 2 0 19260817", "9"], ["2 2 0 19260817", "36"], ["1 2 1 19260817\n1 1 2 1", "4"], ["3 3 1 19260817\n1 2 1 1", "190"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "数学", "单调队列", "O2优化", "前缀和", "二项式定理", "生成函数", "快速数论变换 NTT", "洛谷月赛"], "title": "『MdOI R3』Pekka Bridge Spam", "background": "JohnVictor 比较喜欢玩 Clash Royale。\n\n他喜欢玩一套叫做 Pekka Bridge Spam 的卡组，然而这卡组被削弱了。现在他天梯已经掉了很多分了，不会玩了，只能在竞技场上给他的攻城锤安排地方了。\n\n于是就有了这道题。", "description": "JohnVictor 的皇室竞技场是一个 $2n \\times 2m$（$2n$ 行，$2m$ 列）的方格表，他要在上面放 $n\\times m$ 个 $1 \\times 2$ 的攻城锤，使得任意两个攻城锤不相交。\n\n然而攻城锤里面的野蛮人靠太近会打架，所以他要求任意一个 $2 \\times 2$ 的正方形中有两个相邻的格子没有被任何攻城锤占有。\n\n现在已经摆好了 $k$ 个攻城锤了，JohnVictor 想要知道有多少种方法能摆放这些攻城锤，注意，攻城锤两两之间没有区别。\n\n由于这个答案实在是太大了，JohnVictor 只想知道这个答案对素数 $p$ 取模后的余数。**保证取模前的真实答案大于 $0$**。\n\n为了避免玩过皇室的参赛者对题目理解产生问题，这里的攻城锤看做一个 $1 \\times 2$ 的多米诺，翻转后也与自身一样。如果还是不理解可以参考样例。\n\n**由于本题数据范围较大，使用 C++ 的选手可以使用以下代码来加快取模速度。**\n\n代码出自 [KATCL](https://github.com/kth-competitive-programming/kactl/blob/master/content/various/FastMod.h) 。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef __uint128_t L;\nstruct FastMod {\n    ull b, m;\n    FastMod(ull b) : b(b), m(ull((L(1) << 64) / b)) {}\n    ull reduce(ull a) {\n        ull q = (ull)((L(m) * a) >> 64);\n        ull r = a - q * b; // can be proven that 0 <= r < 2*b\n        return r >= b ? r - b : r;\n    }\n};\nFastMod F(2);\n\nint main() {\n    int M = 1000000007; F = FastMod(M);\n    ull x = 10ULL*M+3; \n    cout << x << \" \" << F.reduce(x) << \"\\n\"; // 10000000073 3\n}\n```\n\n使用方法：\n\n假设当前程序中需要取模的数为 $p$，那么就在 `main` 函数开头处调用 `F = FastMod(p);`。\n\n计算 $a\\bmod p$ 的时候调用\n`\nF.reduce(a);\n`，\n返回值就是 $a\\bmod p$ 的值。", "inputFormat": "第一行为四个整数 $n,m,k,p$。\n\n接下来 $k$ 行，每行四个整数 $x_{1i},y_{1i},x_{2i},y_{2i}(1 \\le i \\le k)$，代表一块攻城锤的位置。\n\n注意这里 $x,y$ 坐标表示的是在第 $x$ 行第 $y$ 列，并不是横纵坐标。", "outputFormat": "一行一个整数，输出答案对 $p$ 取模后的值。", "hint": "【样例 1 解释】   \n$9$ 种情况如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0s4px806.png)\n\n【样例 2 解释】   \n我有一种绝妙的解释方法，可惜这里位置太小，我写不下。\n\n【样例 3 解释】  \n上图中第一行的第 $1,2$ 幅和第二行的第 $1,2$ 幅图就是要求的 $4$ 种情况。\n\n更多样例请[到这里](https://www.luogu.com.cn/paste/b2ad2hoy)领取。\n\n【数据范围】\n\n本题采用捆绑测试，共有 $7$ 个子任务。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 9 \\times 10^3$，$1 \\le m \\le 10^{18}$，$0 \\le k \\le  10^5$，$|x_{1i}-x_{2i}|+|y_{1i}-y_{2i}|=1$，$1 \\le x_{1i},x_{2i} \\le 2n$，$1 \\le y_{1i},y_{2i} \\le 2m$，$10^7\\le p \\le 10^9 + 9 $，**输入数据保证有解且 $p$ 为素数**。\n\n|子任务编号|$n\\leq$|$m\\leq$|其他性质|分值|时间限制|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|1|$3$|$3$||$5$|$1.0s$|\n|2|$10$|$10$|$k=0$|$10$|$1.0s$|\n|3|$5 \\times 10^3$|$5 \\times 10^3$||$13$|$2.0s$|\n|4|$80$|||$17$|$1.0s$|\n|5|$2\\times 10^3$||$p=998244353$|$20$|$3.0s$|\n|6||||$35$|$3.0s$|\n【温馨提示】\n\n为了确保卡掉小常数的错解本题开大了数据范围，请注意常数因子对程序运行效率的影响。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『MdOI R3』Pekka Bridge Spam", "background": "JohnVictor 比较喜欢玩 Clash Royale。\n\n他喜欢玩一套叫做 Pekka Bridge Spam 的卡组，然而这卡组被削弱了。现在他天梯已经掉了很多分了，不会玩了，只能在竞技场上给他的攻城锤安排地方了。\n\n于是就有了这道题。", "description": "JohnVictor 的皇室竞技场是一个 $2n \\times 2m$（$2n$ 行，$2m$ 列）的方格表，他要在上面放 $n\\times m$ 个 $1 \\times 2$ 的攻城锤，使得任意两个攻城锤不相交。\n\n然而攻城锤里面的野蛮人靠太近会打架，所以他要求任意一个 $2 \\times 2$ 的正方形中有两个相邻的格子没有被任何攻城锤占有。\n\n现在已经摆好了 $k$ 个攻城锤了，JohnVictor 想要知道有多少种方法能摆放这些攻城锤，注意，攻城锤两两之间没有区别。\n\n由于这个答案实在是太大了，JohnVictor 只想知道这个答案对素数 $p$ 取模后的余数。**保证取模前的真实答案大于 $0$**。\n\n为了避免玩过皇室的参赛者对题目理解产生问题，这里的攻城锤看做一个 $1 \\times 2$ 的多米诺，翻转后也与自身一样。如果还是不理解可以参考样例。\n\n**由于本题数据范围较大，使用 C++ 的选手可以使用以下代码来加快取模速度。**\n\n代码出自 [KATCL](https://github.com/kth-competitive-programming/kactl/blob/master/content/various/FastMod.h) 。\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef __uint128_t L;\nstruct FastMod {\n    ull b, m;\n    FastMod(ull b) : b(b), m(ull((L(1) << 64) / b)) {}\n    ull reduce(ull a) {\n        ull q = (ull)((L(m) * a) >> 64);\n        ull r = a - q * b; // can be proven that 0 <= r < 2*b\n        return r >= b ? r - b : r;\n    }\n};\nFastMod F(2);\n\nint main() {\n    int M = 1000000007; F = FastMod(M);\n    ull x = 10ULL*M+3; \n    cout << x << \" \" << F.reduce(x) << \"\\n\"; // 10000000073 3\n}\n```\n\n使用方法：\n\n假设当前程序中需要取模的数为 $p$，那么就在 `main` 函数开头处调用 `F = FastMod(p);`。\n\n计算 $a\\bmod p$ 的时候调用\n`\nF.reduce(a);\n`，\n返回值就是 $a\\bmod p$ 的值。", "inputFormat": "第一行为四个整数 $n,m,k,p$。\n\n接下来 $k$ 行，每行四个整数 $x_{1i},y_{1i},x_{2i},y_{2i}(1 \\le i \\le k)$，代表一块攻城锤的位置。\n\n注意这里 $x,y$ 坐标表示的是在第 $x$ 行第 $y$ 列，并不是横纵坐标。", "outputFormat": "一行一个整数，输出答案对 $p$ 取模后的值。", "hint": "【样例 1 解释】   \n$9$ 种情况如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0s4px806.png)\n\n【样例 2 解释】   \n我有一种绝妙的解释方法，可惜这里位置太小，我写不下。\n\n【样例 3 解释】  \n上图中第一行的第 $1,2$ 幅和第二行的第 $1,2$ 幅图就是要求的 $4$ 种情况。\n\n更多样例请[到这里](https://www.luogu.com.cn/paste/b2ad2hoy)领取。\n\n【数据范围】\n\n本题采用捆绑测试，共有 $7$ 个子任务。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 9 \\times 10^3$，$1 \\le m \\le 10^{18}$，$0 \\le k \\le  10^5$，$|x_{1i}-x_{2i}|+|y_{1i}-y_{2i}|=1$，$1 \\le x_{1i},x_{2i} \\le 2n$，$1 \\le y_{1i},y_{2i} \\le 2m$，$10^7\\le p \\le 10^9 + 9 $，**输入数据保证有解且 $p$ 为素数**。\n\n|子任务编号|$n\\leq$|$m\\leq$|其他性质|分值|时间限制|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|1|$3$|$3$||$5$|$1.0s$|\n|2|$10$|$10$|$k=0$|$10$|$1.0s$|\n|3|$5 \\times 10^3$|$5 \\times 10^3$||$13$|$2.0s$|\n|4|$80$|||$17$|$1.0s$|\n|5|$2\\times 10^3$||$p=998244353$|$20$|$3.0s$|\n|6||||$35$|$3.0s$|\n【温馨提示】\n\n为了确保卡掉小常数的错解本题开大了数据范围，请注意常数因子对程序运行效率的影响。", "locale": "zh-CN"}}}
{"pid": "P6751", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2019", "IOI", "交互题", "Special Judge"], "title": "[IOI 2019] 视觉程序", "background": "[评测方式](https://www.luogu.com.cn/paste/5z13bn4l)\n\n[一些说明~~和扯淡~~](https://www.luogu.com.cn/paste/l6kcccs4)", "description": "你在给机器人编写一个视觉程序。每次机器人的摄像头拍下一张照片时，图像将以黑白图像的形式存储在机器人的内存中。每张图像是由像素构成的 $H\\times W$ 网格。图像的行从 $0$ 到 $H-1$ 编号，列从 $0$ 到 $W-1$ 编号。每张图像含有**恰好两个**黑色像素，其他像素均为白色。\n\n机器人可以用简单指令构成的程序来处理图像。给出 $H$，$W$ 和一个正整数 $K$ 的值，你的目标是要编写一个函数，用来为机器人生成程序。该程序需要判定图像中两个黑色像素的距离是否正好为 $K$。这里，在第 $r_1$ 行及第 $c_1$ 列上的像素与第 $r_2$ 行及第 $c_2$ 列上的像素之间的距离定义为 $|r_1-r_2|+|c_1-c_2|$。 在这个式子中，$|x|$ 表示 $x$ 的绝对值，即当 $x\\ge0$ 时，其值为 $x$，而当 $x<0$ 时，其值为 $-x$。\n\n下面描述机器人是如何运作的。\n\n机器人的内存有足够多的存储单元，从 $0$ 开始编号。每个存储单元可以保存 $0$ 或 $1$，且它的内容一旦设置后就不可更改。图像一行接一行地保存在存储单元里，这些存储单元的编号从 $0$ 到 $H\\cdot W-1$。第一行保存在存储单元 $0$ 到 $W-1$ 里，最后一行保存在存储单元 $(H-1)W$ 到 $H\\cdot W-1$ 里。特别地，如果位于第 $i$ 行第 $j$ 列上的那个像素是黑色的，则保存在存储单元 $i\\cdot W+j$ 里的值为 $1$，否则为 $0$。\n\n机器人的程序是一个**指令**的序列，这些指令用从 $0$ 开始的连续整数进行编号。在程序运行时，指令将一条一条地被执行。每条指令读取一个或多个存储单元的值（我们将这些值称为指令的**输入**），同时产生一个 $0$ 或 $1$ 的值（我们称之为指令的**输出**）。指令 $i$ 的输出将会保存在存储单元 $H\\cdot W+i$ 中。指令 $i$ 的输入只能是保存图像的存储单元，或者是保存之前指令输出的存储单元，也就是编号为从 $0$ 到 $H\\cdot W+i-1$ 的存储单元。\n\n机器人共有四种指令：\n- `NOT`：有唯一一个输入。若输入为 $0$ 时，其输出为 $1$，否则为 $0$。\n- `AND`：有一个或多个输入。其输出为 $1$ 当且仅当输入**全部**为 $1$。\n- `OR`：有一个或多个输入。其输出为 $1$ 当且仅当输入中**至少有一个** $1$。\n- `XOR`：有一个或多个输入。其输出为 $1$ 当且仅当输入中 $1$ 的个数是**奇数**。\n\n如果两个黑色像素之间的距离正好为 $K$，则最后一条指令的输出应为 $1$，否则输出应为 $0$。\n#### 实现细节\n你需要实现以下函数：\n```plain\nvoid construct_network(int H, int W, int K)\n```\n- $H$，$W$：机器人摄像头所拍到的图像的尺寸\n- $K$：一个正整数\n- 这个函数需要生成一个机器人的程序。对于机器人摄像头所拍到的每幅图像，该程序应判定图像中两个黑色像素之间的距离是否正好为 $K$。\n\n该程序应当通过调用以下函数将指令追加到机器人的程序中（最初机器人的程序是空的）：\n```plain\nint add_not(int N)\nint add_and(int[] Ns)\nint add_or(int[] Ns)\nint add_xor(int[] Ns)\n```\n- 分别追加一条 `NOT`，`AND`，`OR` 或 `XOR` 指令。\n- $N$（对于 `add_not` 而言）：要追加的 `NOT` 指令的输入存储单元编号\n- $Ns$（对于 `add_and`，`add_or`，`add_xor` 而言）：要追加的 `AND`，`OR` 或 `XOR` 指令的输入存储单元的编号的数组\n- 每次函数调用都会返回追加指令的输出存储单位的编号。对这些函数的连续调用将会返回从 $H\\cdot W$ 开始的连续整数。\n\n机器人的程序最多可以包含 $10^4$ 条指令。这些指令一共最多只能读入 $10^6$ 个值。换句话说，所有 `add_and`，`add_or` 及 `add_xor` 调用中的 $Ns$ 数组的长度总和再加上 `add_not` 调用的次数不得超过 $10^6$。\n\n\n当追加完最后一条指令后，函数 `construct_network` 必须返回。所产生的机器人程序会在一些图像上进行评测。对于一幅图像，程序最后一条指令的输出是 $1$ 当且仅当两个黑色像素之间的距离正好为 $K$。如果对测试点中的每幅图像，你的解答所产生的程序都可以正确地输出结果，那就通过了该测试点。\n\n评测程序在评测你的程序时可能会出现以下错误信息：\n- `Instruction with no inputs`：一个空数组被作为 `add_and`，`add_or` 或 `add_xor` 的输入。\n- `Invalid index`：给 `add_not`，`add_or` 或 `add_xor` 提供了不正确（可能是负数）的存储单元编号作为输入。\n- `Too many instructions`：你的函数尝试添加多于 $10^4$ 条的指令。\n- `Too many inputs`：程序中的指令一共读取了多于 $10^6$ 个值。\n#### 评测程序示例\n评测程序示例读取下述格式的输入：\n- 第 $1$ 行：$H$，$W$，$K$\n- 第 $2+i$ 行（$i\\ge0$）：$r1_i$，$c1_i$，$r2_i$，$c2_i$\n- 最后一行：$-1$\n\n除第一行和最后一行外，每一行都表示了一幅含有两个黑色像素的图像。记第 $2+i$ 行上的图像为图像 $i$。该图像中，一个黑色像素位于第 $r_1[i]$ 行及第 $c_1[i]$ 列上，令一个黑色像素位于第 $r_2[i]$ 行及第 $c_2[i]$ 列上。\n\n评测程序首先调用 `construct_network(H, W, K)`。若 `construct_network` 违反了题目描述中的限制条件，评测程序示例将会输出在实现细节一节末尾所列举的某条错误信息并退出。\n\n否则，评测程序示例将输出两部分内容。\n\n首先，评测程序示例会以下列格式输出机器人程序所产生的输出：\n- 第 $1+i$ 行（$0\\le i$）：对于图像 $i$，机器人程序最后一条指令的输出（$1$ 或 $0$）。\n\n其次，评测程序示例会以下列格式输出到当前目录下一个名为 `log.txt` 的文件中：\n- 第 $1+i$ 行（$0\\le i$）：$m_{i,0}$，$m_{i,1}$，$\\dots$，$m_{i,c-1}$\n\n在第 $1+i$ 行上的序列描述以图像 $i$ 作为输入时，在机器人程序运行结束后放在内存中的数据。具体来说，$m_{i,j}$ 是保存在存储单元 $j$ 里面的值。注意，$c$ 的值（序列长度）等于 $H\\cdot W$ 再加上机器人程序的指令数。", "inputFormat": "", "outputFormat": "", "hint": "#### 样例\n假设 $H=2$，$W=3$，$K=3$。在此情况下，两个黑色像素之间的距离为 $3$ 的图像只有两种。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9fec7n4k.png)\n\n- 情况一：黑色像素是 $0$ 和 $5$。\n- 情况二：黑色像素是 $2$ 和 $3$。\n\n一种可行的方案是通过以下调用来构造机器人程序：\n1. `add_and([0, 5])`，将加入一条指令，当且仅当图像符合情况一时其输出为 $1$。输出结果将保存在存储单元 $6$ 里。\n1. `add_and([2, 3])`，将加入一条指令，当且仅当图像符合情况二时其输出为 $1$。输出结果将保存在存储单元 $7$ 里。\n1. `add_or([6, 7])`，将加入一条指令，当且仅当上述两种情况之一成立时其输出为 $1$。\n#### 数据范围\n对于所有数据：\n- $1\\le H,W\\le200$；\n- $2\\le H\\cdot W$；\n- $1\\le K\\le H+W-2$。\n\n详细子任务附加限制与分值如下表：\n| 子任务编号 |                           附加限制                           | 分值 |\n| :--------: | :----------------------------------------------------------: | :--: |\n|    $1$     |                     $\\max(H,W) \\le 3$                        | $10$ |\n|    $2$     |                     $\\max(H,W) \\le 10$                       | $11$ |\n|    $3$     |                     $\\max(H,W) \\le 30$                       | $11$ |\n|    $4$     |                     $\\max(H,W) \\le 100$                      | $15$ |\n|    $5$     |                       $\\min(H,W) = 1$                        | $12$ |\n|    $6$     |     每幅图像上位于第 $0$ 行且位于第 $0$ 列的那个像素是黑色的         | $8$ |\n|    $7$     |                           $K = 1$                            | $14$ |\n|    $8$     |                      没有任何附加限制                           | $19$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2019] 视觉程序", "background": "[评测方式](https://www.luogu.com.cn/paste/5z13bn4l)\n\n[一些说明~~和扯淡~~](https://www.luogu.com.cn/paste/l6kcccs4)", "description": "你在给机器人编写一个视觉程序。每次机器人的摄像头拍下一张照片时，图像将以黑白图像的形式存储在机器人的内存中。每张图像是由像素构成的 $H\\times W$ 网格。图像的行从 $0$ 到 $H-1$ 编号，列从 $0$ 到 $W-1$ 编号。每张图像含有**恰好两个**黑色像素，其他像素均为白色。\n\n机器人可以用简单指令构成的程序来处理图像。给出 $H$，$W$ 和一个正整数 $K$ 的值，你的目标是要编写一个函数，用来为机器人生成程序。该程序需要判定图像中两个黑色像素的距离是否正好为 $K$。这里，在第 $r_1$ 行及第 $c_1$ 列上的像素与第 $r_2$ 行及第 $c_2$ 列上的像素之间的距离定义为 $|r_1-r_2|+|c_1-c_2|$。 在这个式子中，$|x|$ 表示 $x$ 的绝对值，即当 $x\\ge0$ 时，其值为 $x$，而当 $x<0$ 时，其值为 $-x$。\n\n下面描述机器人是如何运作的。\n\n机器人的内存有足够多的存储单元，从 $0$ 开始编号。每个存储单元可以保存 $0$ 或 $1$，且它的内容一旦设置后就不可更改。图像一行接一行地保存在存储单元里，这些存储单元的编号从 $0$ 到 $H\\cdot W-1$。第一行保存在存储单元 $0$ 到 $W-1$ 里，最后一行保存在存储单元 $(H-1)W$ 到 $H\\cdot W-1$ 里。特别地，如果位于第 $i$ 行第 $j$ 列上的那个像素是黑色的，则保存在存储单元 $i\\cdot W+j$ 里的值为 $1$，否则为 $0$。\n\n机器人的程序是一个**指令**的序列，这些指令用从 $0$ 开始的连续整数进行编号。在程序运行时，指令将一条一条地被执行。每条指令读取一个或多个存储单元的值（我们将这些值称为指令的**输入**），同时产生一个 $0$ 或 $1$ 的值（我们称之为指令的**输出**）。指令 $i$ 的输出将会保存在存储单元 $H\\cdot W+i$ 中。指令 $i$ 的输入只能是保存图像的存储单元，或者是保存之前指令输出的存储单元，也就是编号为从 $0$ 到 $H\\cdot W+i-1$ 的存储单元。\n\n机器人共有四种指令：\n- `NOT`：有唯一一个输入。若输入为 $0$ 时，其输出为 $1$，否则为 $0$。\n- `AND`：有一个或多个输入。其输出为 $1$ 当且仅当输入**全部**为 $1$。\n- `OR`：有一个或多个输入。其输出为 $1$ 当且仅当输入中**至少有一个** $1$。\n- `XOR`：有一个或多个输入。其输出为 $1$ 当且仅当输入中 $1$ 的个数是**奇数**。\n\n如果两个黑色像素之间的距离正好为 $K$，则最后一条指令的输出应为 $1$，否则输出应为 $0$。\n#### 实现细节\n你需要实现以下函数：\n```plain\nvoid construct_network(int H, int W, int K)\n```\n- $H$，$W$：机器人摄像头所拍到的图像的尺寸\n- $K$：一个正整数\n- 这个函数需要生成一个机器人的程序。对于机器人摄像头所拍到的每幅图像，该程序应判定图像中两个黑色像素之间的距离是否正好为 $K$。\n\n该程序应当通过调用以下函数将指令追加到机器人的程序中（最初机器人的程序是空的）：\n```plain\nint add_not(int N)\nint add_and(int[] Ns)\nint add_or(int[] Ns)\nint add_xor(int[] Ns)\n```\n- 分别追加一条 `NOT`，`AND`，`OR` 或 `XOR` 指令。\n- $N$（对于 `add_not` 而言）：要追加的 `NOT` 指令的输入存储单元编号\n- $Ns$（对于 `add_and`，`add_or`，`add_xor` 而言）：要追加的 `AND`，`OR` 或 `XOR` 指令的输入存储单元的编号的数组\n- 每次函数调用都会返回追加指令的输出存储单位的编号。对这些函数的连续调用将会返回从 $H\\cdot W$ 开始的连续整数。\n\n机器人的程序最多可以包含 $10^4$ 条指令。这些指令一共最多只能读入 $10^6$ 个值。换句话说，所有 `add_and`，`add_or` 及 `add_xor` 调用中的 $Ns$ 数组的长度总和再加上 `add_not` 调用的次数不得超过 $10^6$。\n\n\n当追加完最后一条指令后，函数 `construct_network` 必须返回。所产生的机器人程序会在一些图像上进行评测。对于一幅图像，程序最后一条指令的输出是 $1$ 当且仅当两个黑色像素之间的距离正好为 $K$。如果对测试点中的每幅图像，你的解答所产生的程序都可以正确地输出结果，那就通过了该测试点。\n\n评测程序在评测你的程序时可能会出现以下错误信息：\n- `Instruction with no inputs`：一个空数组被作为 `add_and`，`add_or` 或 `add_xor` 的输入。\n- `Invalid index`：给 `add_not`，`add_or` 或 `add_xor` 提供了不正确（可能是负数）的存储单元编号作为输入。\n- `Too many instructions`：你的函数尝试添加多于 $10^4$ 条的指令。\n- `Too many inputs`：程序中的指令一共读取了多于 $10^6$ 个值。\n#### 评测程序示例\n评测程序示例读取下述格式的输入：\n- 第 $1$ 行：$H$，$W$，$K$\n- 第 $2+i$ 行（$i\\ge0$）：$r1_i$，$c1_i$，$r2_i$，$c2_i$\n- 最后一行：$-1$\n\n除第一行和最后一行外，每一行都表示了一幅含有两个黑色像素的图像。记第 $2+i$ 行上的图像为图像 $i$。该图像中，一个黑色像素位于第 $r_1[i]$ 行及第 $c_1[i]$ 列上，令一个黑色像素位于第 $r_2[i]$ 行及第 $c_2[i]$ 列上。\n\n评测程序首先调用 `construct_network(H, W, K)`。若 `construct_network` 违反了题目描述中的限制条件，评测程序示例将会输出在实现细节一节末尾所列举的某条错误信息并退出。\n\n否则，评测程序示例将输出两部分内容。\n\n首先，评测程序示例会以下列格式输出机器人程序所产生的输出：\n- 第 $1+i$ 行（$0\\le i$）：对于图像 $i$，机器人程序最后一条指令的输出（$1$ 或 $0$）。\n\n其次，评测程序示例会以下列格式输出到当前目录下一个名为 `log.txt` 的文件中：\n- 第 $1+i$ 行（$0\\le i$）：$m_{i,0}$，$m_{i,1}$，$\\dots$，$m_{i,c-1}$\n\n在第 $1+i$ 行上的序列描述以图像 $i$ 作为输入时，在机器人程序运行结束后放在内存中的数据。具体来说，$m_{i,j}$ 是保存在存储单元 $j$ 里面的值。注意，$c$ 的值（序列长度）等于 $H\\cdot W$ 再加上机器人程序的指令数。", "inputFormat": "", "outputFormat": "", "hint": "#### 样例\n假设 $H=2$，$W=3$，$K=3$。在此情况下，两个黑色像素之间的距离为 $3$ 的图像只有两种。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9fec7n4k.png)\n\n- 情况一：黑色像素是 $0$ 和 $5$。\n- 情况二：黑色像素是 $2$ 和 $3$。\n\n一种可行的方案是通过以下调用来构造机器人程序：\n1. `add_and([0, 5])`，将加入一条指令，当且仅当图像符合情况一时其输出为 $1$。输出结果将保存在存储单元 $6$ 里。\n1. `add_and([2, 3])`，将加入一条指令，当且仅当图像符合情况二时其输出为 $1$。输出结果将保存在存储单元 $7$ 里。\n1. `add_or([6, 7])`，将加入一条指令，当且仅当上述两种情况之一成立时其输出为 $1$。\n#### 数据范围\n对于所有数据：\n- $1\\le H,W\\le200$；\n- $2\\le H\\cdot W$；\n- $1\\le K\\le H+W-2$。\n\n详细子任务附加限制与分值如下表：\n| 子任务编号 |                           附加限制                           | 分值 |\n| :--------: | :----------------------------------------------------------: | :--: |\n|    $1$     |                     $\\max(H,W) \\le 3$                        | $10$ |\n|    $2$     |                     $\\max(H,W) \\le 10$                       | $11$ |\n|    $3$     |                     $\\max(H,W) \\le 30$                       | $11$ |\n|    $4$     |                     $\\max(H,W) \\le 100$                      | $15$ |\n|    $5$     |                       $\\min(H,W) = 1$                        | $12$ |\n|    $6$     |     每幅图像上位于第 $0$ 行且位于第 $0$ 列的那个像素是黑色的         | $8$ |\n|    $7$     |                           $K = 1$                            | $14$ |\n|    $8$     |                      没有任何附加限制                           | $19$ |", "locale": "zh-CN"}}}
{"pid": "P6752", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000], "memory": [17408]}, "tags": ["2011", "交互题", "Special Judge", "进制", "其它技巧", "BalkanOI（巴尔干半岛）"], "title": "[BalkanOI 2011] cmp", "background": "You must design an algorithm for an ancient computer whose memory is just an array of $10240$ bits.The memory is initialized to zero, after which you may write and read a single bit at a time.\n\nYou must implement two operations on this computer:\n\n$\\operatorname{remember}(a)$: $a$ is an integer between $0$ and $4095$\n- The implementation of this operation may call:\n- - $\\operatorname{bit\\_set}(address)$: $\\ \\ \\ \\ $ $address$ is an integer between $1$ and $10240$\n- - The memory bit at position address will be set to $1$\n\n$\\operatorname{compare}(b)$: $b$ is an integer between $0$ and $4095$\n- if $b < a$, it should return $-1$\n- if $b = a$, it should return $0$\n- if $b > a$, it should return $1$\n- The implementation of this operation may call:\n- - $\\operatorname{bit\\_get}(address)$ Returns the memory bit at position $address$: $1$ if it was set through $\\operatorname{bit\\_set}()$ during the $\\operatorname{remember}(a)$ operation, and $0$ otherwise.", "description": "Implement $\\operatorname{remember}()$ and $\\operatorname{compare}()$ to minimize the total number of memory accesses ($\\operatorname{bit\\_set}()$\nand $\\operatorname{bit\\_get}()$) in the worst-case for all possible values of $a$ and $b$.\n\nYour solution will be evaluated exhaustively:\n\n```\ndefine AllMemory = array [0..4095][1..10240] of bits\nset AllMemory to zeros\nfor a = 0..4095:\n    define bit_set(address): AllMemory[a][address] = 1\n    remember(a)\nlet maxA= the maximum number of bit_set() calls executed for any a\nfor (a,b) ∈ {0..4095}×{0..4095} in random order (i.e. all valid pairs (a,b) are considered, in some random order)\n    define bit_get(address): return AllMemory[a][address]\n    answer =compare(b)\n    if answer for comparing a and b is incorrect : your score = 0; exit\nlet maxB = the maximum number of bit_get() calls executed for any (a,b) pair\nT=maxA + maxB\nIf (T>20): your score = 0; exit\nelse your score = 1 + 9 * (21– T); exit\n```", "inputFormat": "", "outputFormat": "", "hint": "### Description of implementation\n\n**Actually many things are here. BUT, If YOU ARE GOING TO SUBMIT ON LUOGU, You Should Use C++, YOUR CODE MUSTN'T INCLUDE `cmp.h`.**\n\n**Here is an example code to submit on Luogu.**\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n// Your codes here\nextern\"C\" void bit_set(int);\nextern\"C\" int bit_get(int);\nextern\"C\" void remember(int a){\n    // Your codes here\n}\nextern\"C\" int compare(int b){\n    // Your codes here\n}\n```\n\n### Constraints\n- You may be disqualified for any attempt to interact with the memory of our grading code.\n- If your solution does not obey the protocol defined above (e.g. calling $\\operatorname{bit\\_set}()$ during $\\operatorname{compare}()$ or with an invalid address), you will receive zero points.\n- Time limit: your implementation must execute $4096$ calls to $\\operatorname{remember}()$ and $4096\\times 4096$\ncalls to $\\operatorname{compare}()$ in under $10$ seconds.\n\nFrom [Balkan Olympiad in Informatics 2011](http://www.boi2011.ro/boi2011/) [Day 2](http://www.boi2011.ro/boi2011/?pagina=probleme) [T1 cmp](http://www.boi2011.ro/resurse/tasks/cmp.zip).", "locale": "en", "translations": {"en": {"title": "[BalkanOI 2011] cmp", "background": "You must design an algorithm for an ancient computer whose memory is just an array of $10240$ bits.The memory is initialized to zero, after which you may write and read a single bit at a time.\n\nYou must implement two operations on this computer:\n\n$\\operatorname{remember}(a)$: $a$ is an integer between $0$ and $4095$\n- The implementation of this operation may call:\n- - $\\operatorname{bit\\_set}(address)$: $\\ \\ \\ \\ $ $address$ is an integer between $1$ and $10240$\n- - The memory bit at position address will be set to $1$\n\n$\\operatorname{compare}(b)$: $b$ is an integer between $0$ and $4095$\n- if $b < a$, it should return $-1$\n- if $b = a$, it should return $0$\n- if $b > a$, it should return $1$\n- The implementation of this operation may call:\n- - $\\operatorname{bit\\_get}(address)$ Returns the memory bit at position $address$: $1$ if it was set through $\\operatorname{bit\\_set}()$ during the $\\operatorname{remember}(a)$ operation, and $0$ otherwise.", "description": "Implement $\\operatorname{remember}()$ and $\\operatorname{compare}()$ to minimize the total number of memory accesses ($\\operatorname{bit\\_set}()$\nand $\\operatorname{bit\\_get}()$) in the worst-case for all possible values of $a$ and $b$.\n\nYour solution will be evaluated exhaustively:\n\n```\ndefine AllMemory = array [0..4095][1..10240] of bits\nset AllMemory to zeros\nfor a = 0..4095:\n    define bit_set(address): AllMemory[a][address] = 1\n    remember(a)\nlet maxA= the maximum number of bit_set() calls executed for any a\nfor (a,b) ∈ {0..4095}×{0..4095} in random order (i.e. all valid pairs (a,b) are considered, in some random order)\n    define bit_get(address): return AllMemory[a][address]\n    answer =compare(b)\n    if answer for comparing a and b is incorrect : your score = 0; exit\nlet maxB = the maximum number of bit_get() calls executed for any (a,b) pair\nT=maxA + maxB\nIf (T>20): your score = 0; exit\nelse your score = 1 + 9 * (21– T); exit\n```", "inputFormat": "", "outputFormat": "", "hint": "### Description of implementation\n\n**Actually many things are here. BUT, If YOU ARE GOING TO SUBMIT ON LUOGU, You Should Use C++, YOUR CODE MUSTN'T INCLUDE `cmp.h`.**\n\n**Here is an example code to submit on Luogu.**\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n// Your codes here\nextern\"C\" void bit_set(int);\nextern\"C\" int bit_get(int);\nextern\"C\" void remember(int a){\n    // Your codes here\n}\nextern\"C\" int compare(int b){\n    // Your codes here\n}\n```\n\n### Constraints\n- You may be disqualified for any attempt to interact with the memory of our grading code.\n- If your solution does not obey the protocol defined above (e.g. calling $\\operatorname{bit\\_set}()$ during $\\operatorname{compare}()$ or with an invalid address), you will receive zero points.\n- Time limit: your implementation must execute $4096$ calls to $\\operatorname{remember}()$ and $4096\\times 4096$\ncalls to $\\operatorname{compare}()$ in under $10$ seconds.\n\nFrom [Balkan Olympiad in Informatics 2011](http://www.boi2011.ro/boi2011/) [Day 2](http://www.boi2011.ro/boi2011/?pagina=probleme) [T1 cmp](http://www.boi2011.ro/resurse/tasks/cmp.zip).", "locale": "en"}, "zh-CN": {"title": "[BalkanOI 2011] cmp", "background": "这是一道 **Grader 交互题**。\n\n本题时限 10s，空限除交互库所用内存仅 16MB。\n\n本题分数最高 $190$，但标解所选择的方案可得 $100$ 分。\n\n#### 测评注意事项\n- 你的代码中不应包含 `cmp.h`，而应该在开头包含下面两个函数的声明：\n   - `void bit_set(int);`\n   - `int bit_get(int);`\n- 你的代码中应该实现两个函数 ：\n   - `void remember(int a);`\n   - `int compare(int b);`\n\n换句话说，您可以在如下的代码模板中编写程序：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ndo something...\nextern \"C\" void bit_set(int);\nextern \"C\" int bit_get(int);\nextern \"C\" void remember(int a) {\n    do something...\n}\nextern \"C\" int compare(int b) {\n    do something...\n}\n```", "description": "我们有一个第一维长度为 $4096$，第二维长度为 $10240$ 的二维 $01$ 数组 $mem$，初始时所有值为 $0$。\n\n您需要编写在 $01$ 数组上执行的两个操作 `void remember(int a)` 和 `int compare(int b)`。\n\n#### 实现细节\n\n`void remember(int a)` ：\n\n- 保证 $0\\le a\\le 4095$。\n- 您可以调用 `void bit_set(int ad)`，其中您需要保证 $1\\le ad \\le 10240$。\n  - 这会导致 $mem_{a,ad}=1$。\n\n`int compare(int b)`：\n\n- 保证 $0\\le b\\le 4095$。\n- 您需要将 $a$ 与  $b$ 进行比较，其中 $a$ 未知：\n  -  若 $b<a$，请返回 $-1$。\n  - 若 $b=a$，请返回 $0$。\n  - 若 $b>a$，请返回 $1$。\n- 您可以调用 `int bit_get(int ad)`，其中您需要保证 $1\\le ad \\le 10240$。\n  - 这会返回 $mem_{a,ad}$ 的值\n\n#### 任务\n\n您应该实现上述两个函数 `void remember(int a)` 和 `int compare(int b)` 在最大程度上减少 `void bit_set(int ad)` 和 `int bit_get(int ad)` 的调用次数。\n\n您的得分由以下伪代码计算：\n\n```\ndefine AllMemory = array [0..4095][1..10240] of bits\nset AllMemory to zeros\nfor a = 0..4095:\n    define bit_set(address): AllMemory[a][address] = 1\n    remember(a)\nlet maxA= the maximum number of bit_set() calls executed for any a\nfor (a,b) ∈ {0..4095}×{0..4095} in random order (i.e. all valid pairs (a,b) are considered, in some random order)\n    define bit_get(address): return AllMemory[a][address]\n    answer =compare(b)\n    if answer for comparing a and b is incorrect : your score = 0; exit\nlet maxB = the maximum number of bit_get() calls executed for any (a,b) pair\nT=maxA + maxB\nIf (T>20): your score = 0; exit\nelse your score = 1 + 9 * (21– T); exit\n```", "inputFormat": null, "outputFormat": null, "hint": "#### 限制\n\n- 如果您的解决方案不遵守上面的实现细节部分，您保龄。\n\n- 您的解决方案必须可以在 10s 内调用 $4096$ 次  `void remember(int a)`  和 $4096\\times 4096$ 次 `int compare(int b)`。\n#### 说明\n本题译自 [Balkan Olympiad in Informatics 2011](http://www.boi2011.ro/boi2011/) [Day 2](http://www.boi2011.ro/boi2011/?pagina=probleme) [T1 cmp](http://www.boi2011.ro/resurse/tasks/cmp.zip)。\n\n感谢 @[tiger2005](https://www.luogu.com.cn/user/60864) 提供的交互库。", "locale": "zh-CN"}}}
{"pid": "P6753", "type": "P", "difficulty": 4, "samples": [["8 4\n0\n1\n2\n2\n3\n3\n4\n6\n1 8\n2 5\n2 7\n2 8", "1\n3\n2\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2013", "倍增", "BalticOI（波罗的海）"], "title": "[BalticOI 2013] Ball Machine (Day1)", "background": null, "description": "给定一棵树，在根节点放一些球，如果下方有空位，那么它就会往下滚到下面的节点，如果有多个节点选择，它会选择 **以其（即后文中提到的儿子节点）为根节点的子树中标号最小值最小** 的儿子节点。每个位置最多只能有一个球，如果已经有球了，则该位置的空位被占用。\n\n从一个位置上拿走球，上面的球也会滚下来。\n\n每次给定一些操作，分别为在根节点放若干个球，和把某个节点的球拿走，求最后的结果。", "inputFormat": "第一行两个整数 $N,Q$ 代表树的节点数和操作数。      \n这 $N$ 个节点编号为 $1$ 到 $N$。       \n接下来 $N$ 行每行一个整数第 $i$ 行代表第 $i$ 个节点的父节点。   \n接下来 $Q$ 行每行两个整数 $opt,num$：\n\n- 如果 $opt=1$，代表在根节点放 $num$ 个球。\n- 如果 $opt=2$，代表撤掉 $num$ 节点的球。", "outputFormat": "每次操作后都需要输出一个结果：\n\n- 如果 $opt=1$，输出最后一个球落到了哪里。\n- 如果 $opt=2$，输出撤掉那个球会有多少个球滚下来。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le N,Q \\le 10^5$。     \n对于其中 $25\\%$ 的数据，每个节点的儿子节点数只可能为 $0$ 个或 $2$ 个，且所有叶子节点到根节点的距离相同。     \n对于另外 $30\\%$ 的数据，$opt=2$ 的操作输出的总为 $0$。  \n对于另外 $40\\%$ 的数据，只有一个 $opt=1$ 的操作。\n\n#### 说明\n\n翻译自 [BalticOI 2013 Day1 A Ball Machine](https://boi.cses.fi/files/boi2013_day1.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2013] Ball Machine (Day1)", "background": null, "description": "给定一棵树，在根节点放一些球，如果下方有空位，那么它就会往下滚到下面的节点，如果有多个节点选择，它会选择 **以其（即后文中提到的儿子节点）为根节点的子树中标号最小值最小** 的儿子节点。每个位置最多只能有一个球，如果已经有球了，则该位置的空位被占用。\n\n从一个位置上拿走球，上面的球也会滚下来。\n\n每次给定一些操作，分别为在根节点放若干个球，和把某个节点的球拿走，求最后的结果。", "inputFormat": "第一行两个整数 $N,Q$ 代表树的节点数和操作数。      \n这 $N$ 个节点编号为 $1$ 到 $N$。       \n接下来 $N$ 行每行一个整数第 $i$ 行代表第 $i$ 个节点的父节点。   \n接下来 $Q$ 行每行两个整数 $opt,num$：\n\n- 如果 $opt=1$，代表在根节点放 $num$ 个球。\n- 如果 $opt=2$，代表撤掉 $num$ 节点的球。", "outputFormat": "每次操作后都需要输出一个结果：\n\n- 如果 $opt=1$，输出最后一个球落到了哪里。\n- 如果 $opt=2$，输出撤掉那个球会有多少个球滚下来。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le N,Q \\le 10^5$。     \n对于其中 $25\\%$ 的数据，每个节点的儿子节点数只可能为 $0$ 个或 $2$ 个，且所有叶子节点到根节点的距离相同。     \n对于另外 $30\\%$ 的数据，$opt=2$ 的操作输出的总为 $0$。  \n对于另外 $40\\%$ 的数据，只有一个 $opt=1$ 的操作。\n\n#### 说明\n\n翻译自 [BalticOI 2013 Day1 A Ball Machine](https://boi.cses.fi/files/boi2013_day1.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6754", "type": "P", "difficulty": 6, "samples": [["123 321", "153"], ["123456789 987654321", "167386971"]], "limits": {"time": [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2013", "数位 DP", "BalticOI（波罗的海）"], "title": "[BalticOI 2013] Palindrome-Free Numbers (Day1)", "background": "", "description": "我们定义回文串为正着读反着读都一样的数字串，如果一个数字串的一个长度大于 $1$ 的子串也为回文串的话，那么我们也定义这个数字串为回文串。\n\n顾名思义，不是回文串的数字串为非回文串。\n\n给定 $a,b$，求区间 $[a,b]$ 中有多少个数字串为非回文串。", "inputFormat": "一行两个整数 $a,b$ 代表这个区间。", "outputFormat": "一行一个整数代表答案。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$0 \\le a \\le b \\le 10^{18}$。    \n对于其中的 $25\\%$ 的数据，$b-a \\le 10^5$。\n\n#### 说明\n\n翻译自 [BalticOI 2013 Day1 B Palindrome-Free Numbers](https://boi.cses.fi/files/boi2013_day1.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2013] Palindrome-Free Numbers (Day1)", "background": "", "description": "我们定义回文串为正着读反着读都一样的数字串，如果一个数字串的一个长度大于 $1$ 的子串也为回文串的话，那么我们也定义这个数字串为回文串。\n\n顾名思义，不是回文串的数字串为非回文串。\n\n给定 $a,b$，求区间 $[a,b]$ 中有多少个数字串为非回文串。", "inputFormat": "一行两个整数 $a,b$ 代表这个区间。", "outputFormat": "一行一个整数代表答案。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$0 \\le a \\le b \\le 10^{18}$。    \n对于其中的 $25\\%$ 的数据，$b-a \\le 10^5$。\n\n#### 说明\n\n翻译自 [BalticOI 2013 Day1 B Palindrome-Free Numbers](https://boi.cses.fi/files/boi2013_day1.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6755", "type": "P", "difficulty": 6, "samples": [["4 3\n-1\n1\n-3\n1\n1 2\n1 3\n1 4", "2\n-6\n2"], ["4 5\n1\n2\n1\n2\n1 2\n2 3\n3 4\n4 1\n1 3", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "图论", "2013", "BalticOI（波罗的海）"], "title": "[BalticOI 2013] Pipes (Day1)", "background": "", "description": "给定一个 $N$ 点 $M$ 边的无向图，**保证图连通**。现在每个点都有一定量的水，现在可以在一条边上进行操作：\n\n- 让水流出：给定 $d$，假设长度为 $m$，流的时间为 $s$，那么总共失水速度为 $\\dfrac{2dm^3}{s}$，这条边两边的每个点的失水速度为 $\\dfrac{dm^3}{s}$。\n- 让水流进：给定 $p$，假设长度为 $m$，流的时间为 $s$，那么总共得水速度为 $\\dfrac{2pm^3}{s}$，这条边两边的每个点的得水速度为 $\\dfrac{pm^3}{s}$。\n\n现在给定这个图，和每个点的水量的变化速度，求每条边的水量的变化速度的构造方案。", "inputFormat": "第一行两个整数 $N,M$ 代表点数和边数。     \n这 $N$ 个点编号为 $1$ 到 $N$。   \n接下来 $N$ 行每行一个整数 $c_i$ 代表这个点的水量变化速度，正数为得水，负数为失水。     \n接下来 $M$ 行每行两个整数代表一条边。", "outputFormat": "如果不存在这样的构造方案或者有多解，只输出一个整数 `0`。   \n如果存在这样的方案，输出 $M$ 行，每行一个整数代表每条边的水量变化速度。     \n得水为正数，失水为负数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^5$，$1 \\le M \\le 5 \\times 10^5$，$-10^9 \\le c_i \\le 10^9$，如果有解且唯一解，每个答案在 $[-10^9,10^9]$ 的范围内。     \n对于其中 $30\\%$ 的数据，该图为一棵树。\n\n#### 说明\n\n翻译自 [BalticOI 2013 Day1 C Pipes](https://boi.cses.fi/files/boi2013_day1.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2013] Pipes (Day1)", "background": "", "description": "给定一个 $N$ 点 $M$ 边的无向图，**保证图连通**。现在每个点都有一定量的水，现在可以在一条边上进行操作：\n\n- 让水流出：给定 $d$，假设长度为 $m$，流的时间为 $s$，那么总共失水速度为 $\\dfrac{2dm^3}{s}$，这条边两边的每个点的失水速度为 $\\dfrac{dm^3}{s}$。\n- 让水流进：给定 $p$，假设长度为 $m$，流的时间为 $s$，那么总共得水速度为 $\\dfrac{2pm^3}{s}$，这条边两边的每个点的得水速度为 $\\dfrac{pm^3}{s}$。\n\n现在给定这个图，和每个点的水量的变化速度，求每条边的水量的变化速度的构造方案。", "inputFormat": "第一行两个整数 $N,M$ 代表点数和边数。     \n这 $N$ 个点编号为 $1$ 到 $N$。   \n接下来 $N$ 行每行一个整数 $c_i$ 代表这个点的水量变化速度，正数为得水，负数为失水。     \n接下来 $M$ 行每行两个整数代表一条边。", "outputFormat": "如果不存在这样的构造方案或者有多解，只输出一个整数 `0`。   \n如果存在这样的方案，输出 $M$ 行，每行一个整数代表每条边的水量变化速度。     \n得水为正数，失水为负数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^5$，$1 \\le M \\le 5 \\times 10^5$，$-10^9 \\le c_i \\le 10^9$，如果有解且唯一解，每个答案在 $[-10^9,10^9]$ 的范围内。     \n对于其中 $30\\%$ 的数据，该图为一棵树。\n\n#### 说明\n\n翻译自 [BalticOI 2013 Day1 C Pipes](https://boi.cses.fi/files/boi2013_day1.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6756", "type": "P", "difficulty": 5, "samples": [["2 2\n2 3\n5\n6", "3\noo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "BalticOI（波罗的海）"], "title": "[BalticOI 2013] Brunhilda’s Birthday", "background": "", "description": "有一个整数 $n$ 以及一个长度为 $m$ 的素数表 $p$。\n\n您可以进行任意多次操作，每一次操作时，您选择一个素数 $p_i$，这会使得 $n\\to \\lfloor \\frac{n}{p_i}\\rfloor\\times p_i$。\n\n您的目标是求出使得 $n$ 变为 $0$ 的最小操作数，如果不可能变为 $0$，请输出 `oo`。\n\n为了增加难度，您需要回答 $Q$ 组 $n$。 ", "inputFormat": "第一行为两个整数 $m,Q$。\n\n接下来一行 $m$ 个整数 $p$。\n\n接下来 $Q$ 行，一行一个整数 $n$，表示每一次询问给出的 $n$。", "outputFormat": "对于每一个询问，求出使得 $n$ 变为 $0$ 的最小操作数，如果不可能变为 $0$，请输出 `oo`。", "hint": "#### 数据范围及限制\n- 对于 $20$ 分的数据，保证 $m,n,Q\\le 10^4$。\n- 对于另外 $20$ 分的数据，保证 $Q=1$。\n- 对于 $100\\%$ 的数据，保证 $1\\le m,Q\\le 10^5$，$2\\le p_i\\le 10^7$ 且 $p_i$ 为素数，$1\\le n\\le 10^7$。\n\n#### 说明\n本题译自 [Baltic Olympiad in Informatics 2013](https://boi.cses.fi/tasks.php) [Day 2](https://boi.cses.fi/files/boi2013_day2.pdf) T1 Brunhilda’s Birthday。\n\n因为译题人找不到合适的设置，所以本题满分 $110$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2013] Brunhilda’s Birthday", "background": "", "description": "有一个整数 $n$ 以及一个长度为 $m$ 的素数表 $p$。\n\n您可以进行任意多次操作，每一次操作时，您选择一个素数 $p_i$，这会使得 $n\\to \\lfloor \\frac{n}{p_i}\\rfloor\\times p_i$。\n\n您的目标是求出使得 $n$ 变为 $0$ 的最小操作数，如果不可能变为 $0$，请输出 `oo`。\n\n为了增加难度，您需要回答 $Q$ 组 $n$。 ", "inputFormat": "第一行为两个整数 $m,Q$。\n\n接下来一行 $m$ 个整数 $p$。\n\n接下来 $Q$ 行，一行一个整数 $n$，表示每一次询问给出的 $n$。", "outputFormat": "对于每一个询问，求出使得 $n$ 变为 $0$ 的最小操作数，如果不可能变为 $0$，请输出 `oo`。", "hint": "#### 数据范围及限制\n- 对于 $20$ 分的数据，保证 $m,n,Q\\le 10^4$。\n- 对于另外 $20$ 分的数据，保证 $Q=1$。\n- 对于 $100\\%$ 的数据，保证 $1\\le m,Q\\le 10^5$，$2\\le p_i\\le 10^7$ 且 $p_i$ 为素数，$1\\le n\\le 10^7$。\n\n#### 说明\n本题译自 [Baltic Olympiad in Informatics 2013](https://boi.cses.fi/tasks.php) [Day 2](https://boi.cses.fi/files/boi2013_day2.pdf) T1 Brunhilda’s Birthday。\n\n因为译题人找不到合适的设置，所以本题满分 $110$ 分。", "locale": "zh-CN"}}}
{"pid": "P6757", "type": "P", "difficulty": 4, "samples": [["5 8\nFFR.....\n.FRRR...\n.FFFFF..\n..RRRFFR\n.....FFF", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "2013", "并查集", "广度优先搜索 BFS", "BalticOI（波罗的海）"], "title": "[BalticOI 2013] Tracks in the Snow", "background": "", "description": "有一个含 $H$ 行，$W$ 列的字符矩阵，初始全为 `.`。\n\n有两种动物，狐狸和兔子，将会从左上角走到右下角，狐狸会留下 `F` 的痕迹，兔子会留下 `R` 的痕迹。\n\n痕迹会相互覆盖。\n\n走路规则如下：\n- 可以往返走；\n- 不可以走对角线；\n- 不可以跳格子；\n- 不可能有两只动物一起走。\n\n现在您得到了这个被动物们走过的矩阵，请求出至少有几个动物走过了该矩阵。", "inputFormat": "第一行为两个整数 $H,W$。\n\n接下来 $H$ 行，一行 $W$ 个字符，表示整个字符矩阵。", "outputFormat": "仅一行一个整数，表示至少有几个动物走过了该矩阵。", "hint": "#### 数据范围及限制\n- 对于 $30$ 分的数据，保证答案 $\\le 200$，$H,W\\le 500$。\n- 对于 $100\\%$ 的数据，保证 $1\\le H,W\\le 4\\times 10^3$，答案 $\\ge 1$，读入的字符只会是 `.` 或 `R` 或 `F`。\n\n#### 说明\n本题译自 [Baltic Olympiad in Informatics 2013](https://boi.cses.fi/tasks.php) [Day 2](https://boi.cses.fi/files/boi2013_day2.pdf) T2 Tracks in the Snow。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2013] Tracks in the Snow", "background": "", "description": "有一个含 $H$ 行，$W$ 列的字符矩阵，初始全为 `.`。\n\n有两种动物，狐狸和兔子，将会从左上角走到右下角，狐狸会留下 `F` 的痕迹，兔子会留下 `R` 的痕迹。\n\n痕迹会相互覆盖。\n\n走路规则如下：\n- 可以往返走；\n- 不可以走对角线；\n- 不可以跳格子；\n- 不可能有两只动物一起走。\n\n现在您得到了这个被动物们走过的矩阵，请求出至少有几个动物走过了该矩阵。", "inputFormat": "第一行为两个整数 $H,W$。\n\n接下来 $H$ 行，一行 $W$ 个字符，表示整个字符矩阵。", "outputFormat": "仅一行一个整数，表示至少有几个动物走过了该矩阵。", "hint": "#### 数据范围及限制\n- 对于 $30$ 分的数据，保证答案 $\\le 200$，$H,W\\le 500$。\n- 对于 $100\\%$ 的数据，保证 $1\\le H,W\\le 4\\times 10^3$，答案 $\\ge 1$，读入的字符只会是 `.` 或 `R` 或 `F`。\n\n#### 说明\n本题译自 [Baltic Olympiad in Informatics 2013](https://boi.cses.fi/tasks.php) [Day 2](https://boi.cses.fi/files/boi2013_day2.pdf) T2 Tracks in the Snow。", "locale": "zh-CN"}}}
{"pid": "P6758", "type": "P", "difficulty": 7, "samples": [["35\nchefeddiefedjeffeachbigagedegghehad", "36\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2013", "BalticOI（波罗的海）"], "title": "[BalticOI 2013] Vim", "background": "", "description": "给定一个长度为 $N$ 的字符串 $S$，Victor 的目标是将其中的 `e` 全部删除，而不删除其他字符。最开始光标在第一个字符处。\n\nVictor 使用 `Vim` 来解决这个问题。\n\n然而，Victor 并不熟悉 `Vim`，他只知道这里面的三个指令：\n- `x`：删除光标处的字符，光标位置不变，不可以在最后的字符处使用这个命令。\n- `h`：将光标向左移动一格，如果光标位于第一个位置，则光标不动。\n- `f`：其后接一个字符 $c$，其将会将光标移至其右边的第一个字符 $c$，$c\\not =$ `e`。\n\n请计算将其中的 `e` 全部删除，而不删除其他字符的最小**按键**数。", "inputFormat": "第一行为一个整数 $N$。\n\n接下来一行一个字符串 $S$。", "outputFormat": "仅一行一个整数，表示将其中的 `e` 全部删除，而不删除其他字符的最小**按键**数。", "hint": "#### 样例解释\n`fdhxhhxffhxfahxhhhxhhhxfdhxfghxfahhx` 为最优解。\n#### 数据范围及限制\n- 对于 $50$ 分的数据，保证 $N\\le 500$。\n- 对于另外 $10$ 分的数据，保证 $N\\le 5\\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1\\le N\\le 7\\times 10^4$，$S_i\\in\\{$ `a` $\\sim$ `j` $\\}$，$S_1,S_N\\not=$ `e`。\n\n**译者提醒：实在是搞不懂怎样设置了，所以按洛谷默认的来。**\n#### 说明\n本题译自 [Baltic Olympiad in Informatics 2013](https://boi.cses.fi/tasks.php) [Day 2](https://boi.cses.fi/files/boi2013_day2.pdf) T3 Vim。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2013] Vim", "background": "", "description": "给定一个长度为 $N$ 的字符串 $S$，Victor 的目标是将其中的 `e` 全部删除，而不删除其他字符。最开始光标在第一个字符处。\n\nVictor 使用 `Vim` 来解决这个问题。\n\n然而，Victor 并不熟悉 `Vim`，他只知道这里面的三个指令：\n- `x`：删除光标处的字符，光标位置不变，不可以在最后的字符处使用这个命令。\n- `h`：将光标向左移动一格，如果光标位于第一个位置，则光标不动。\n- `f`：其后接一个字符 $c$，其将会将光标移至其右边的第一个字符 $c$，$c\\not =$ `e`。\n\n请计算将其中的 `e` 全部删除，而不删除其他字符的最小**按键**数。", "inputFormat": "第一行为一个整数 $N$。\n\n接下来一行一个字符串 $S$。", "outputFormat": "仅一行一个整数，表示将其中的 `e` 全部删除，而不删除其他字符的最小**按键**数。", "hint": "#### 样例解释\n`fdhxhhxffhxfahxhhhxhhhxfdhxfghxfahhx` 为最优解。\n#### 数据范围及限制\n- 对于 $50$ 分的数据，保证 $N\\le 500$。\n- 对于另外 $10$ 分的数据，保证 $N\\le 5\\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1\\le N\\le 7\\times 10^4$，$S_i\\in\\{$ `a` $\\sim$ `j` $\\}$，$S_1,S_N\\not=$ `e`。\n\n**译者提醒：实在是搞不懂怎样设置了，所以按洛谷默认的来。**\n#### 说明\n本题译自 [Baltic Olympiad in Informatics 2013](https://boi.cses.fi/tasks.php) [Day 2](https://boi.cses.fi/files/boi2013_day2.pdf) T3 Vim。", "locale": "zh-CN"}}}
{"pid": "P6759", "type": "P", "difficulty": 2, "samples": [["4\n13\n9\n19\n3\n0\n10\n20\n3\n4\n0\n11\n2\n1\n15\n0\n12\n5\n5\n13\n0", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2006", "USACO"], "title": "[USACO06OPEN] 县集市 The County Fair", "background": null, "description": "每年，FJ 都喜欢去参加县集市，集市上有 $n$ 个展位，每个摊位 $i$ 都会在当天的特定时间 $p_i$ 发放精美的礼品。FJ 已经听说了这一点，他希望能收集尽可能多的礼品和他的奶牛们一起分享。要想获得摊位 $i$ 发放的礼品，FJ 必须确保时间点 $p_i$ 时位于摊位 $i$。\n\n为了获得尽可能多的礼品，FJ 进行了一番详细的调查，通过调查FJ确定了从摊位 $i$ 到摊位 $j$ 所花费的时间 $t_{i,j}$。集市的布局很不寻常，这会导致，FJ如果在从 $i$ 到 $j$ 的过程中选择从其他摊位绕行，可能会比直接从 $i$ 到 $j$ 所花费的时间更少，然而我们耿直的 FJ 从来不这么做，如果他想从摊位 $i$ 到摊位 $j$，他一定会花 $t_{i,j}$ 的时间从 $i$ 走到 $j$。另外由于集市所在地崎岖不平，所以 $t_{i,j}$ 可能与 $t_{j,i}$ 不相同。\n\nFJ 在时间 $0$ 时，位于 $1$ 号摊位，请计算他最多可以收集多少奖品。", "inputFormat": "第 $1$ 行：一个整数 $n$，表示摊位的数量。\n\n第 $2$ 行：共 $n$ 个整数，其中第 $i+1$ 的正数 $p_i$ 表示摊位 $i$ 发放礼品的时间。\n\n第 $n+2$ 到第 $n^2+n+1$ 行：共 $n^2$ 行，第一个 $n$ 行描述了 FJ 从摊位 $1$ 走到到摊位 $1$...$n$ 所需时间（$t_{1,1},t_{1,2}, ...t_{1,n}$），接下来的 $n$ 行描述了 FJ 从摊位 $2$ 走到摊位 $1$...$n$ 所需时间（$t_{2,1},t_{2,2}, ...t_{2,n}$），以此类推，最后的 $n$ 行描述了 FJ 从摊位 $n$ 走到摊位 $1$...$n$ 所需要的时间 $t_{n,1},t_{n,2}, ...t_{n,n}$。对于任意摊位 $i$，$t_{i,i}=0$。", "outputFormat": "一行：一个整数，表示 FJ 最多可以领取到的奖品数量。", "hint": "#### 样例说明\n\n样例中集市上共有 $4$ 个摊位。$1$ 号摊位在时间 $13$ 发放礼品，$2$ 号摊位在时间 $9$ 发放礼品，$3$ 号摊位在时间 $19$ 发放礼品，$4$ 号摊位在时间 $3$ 发放礼品。\n\nFJ 首先从 $1$ 号摊位走到 $4$ 号摊位，用时 $3$，并在时间 $3$ 到达，正好可以领取到奖品，接着他从摊位 $4$ 走到摊位 $2$ ，用时 $5$，并在时间 $8$ 到达，在等待 $1$ 个时间点后可以领取 $2$ 号摊位的礼品，接着他从 $2$ 号摊位走到 $1$ 号摊位，用时 $4$，并在时间 $13$ 到达，从而可以收集到第 $3$ 个礼品。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1\\le n\\le 400$，$0\\le p_i\\le 10^9$，$1\\le t_{i,j}\\le 10^6$。\n\n数据来自 darkbzoj。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO06OPEN] 县集市 The County Fair", "background": null, "description": "每年，FJ 都喜欢去参加县集市，集市上有 $n$ 个展位，每个摊位 $i$ 都会在当天的特定时间 $p_i$ 发放精美的礼品。FJ 已经听说了这一点，他希望能收集尽可能多的礼品和他的奶牛们一起分享。要想获得摊位 $i$ 发放的礼品，FJ 必须确保时间点 $p_i$ 时位于摊位 $i$。\n\n为了获得尽可能多的礼品，FJ 进行了一番详细的调查，通过调查FJ确定了从摊位 $i$ 到摊位 $j$ 所花费的时间 $t_{i,j}$。集市的布局很不寻常，这会导致，FJ如果在从 $i$ 到 $j$ 的过程中选择从其他摊位绕行，可能会比直接从 $i$ 到 $j$ 所花费的时间更少，然而我们耿直的 FJ 从来不这么做，如果他想从摊位 $i$ 到摊位 $j$，他一定会花 $t_{i,j}$ 的时间从 $i$ 走到 $j$。另外由于集市所在地崎岖不平，所以 $t_{i,j}$ 可能与 $t_{j,i}$ 不相同。\n\nFJ 在时间 $0$ 时，位于 $1$ 号摊位，请计算他最多可以收集多少奖品。", "inputFormat": "第 $1$ 行：一个整数 $n$，表示摊位的数量。\n\n第 $2$ 行：共 $n$ 个整数，其中第 $i+1$ 的正数 $p_i$ 表示摊位 $i$ 发放礼品的时间。\n\n第 $n+2$ 到第 $n^2+n+1$ 行：共 $n^2$ 行，第一个 $n$ 行描述了 FJ 从摊位 $1$ 走到到摊位 $1$...$n$ 所需时间（$t_{1,1},t_{1,2}, ...t_{1,n}$），接下来的 $n$ 行描述了 FJ 从摊位 $2$ 走到摊位 $1$...$n$ 所需时间（$t_{2,1},t_{2,2}, ...t_{2,n}$），以此类推，最后的 $n$ 行描述了 FJ 从摊位 $n$ 走到摊位 $1$...$n$ 所需要的时间 $t_{n,1},t_{n,2}, ...t_{n,n}$。对于任意摊位 $i$，$t_{i,i}=0$。", "outputFormat": "一行：一个整数，表示 FJ 最多可以领取到的奖品数量。", "hint": "#### 样例说明\n\n样例中集市上共有 $4$ 个摊位。$1$ 号摊位在时间 $13$ 发放礼品，$2$ 号摊位在时间 $9$ 发放礼品，$3$ 号摊位在时间 $19$ 发放礼品，$4$ 号摊位在时间 $3$ 发放礼品。\n\nFJ 首先从 $1$ 号摊位走到 $4$ 号摊位，用时 $3$，并在时间 $3$ 到达，正好可以领取到奖品，接着他从摊位 $4$ 走到摊位 $2$ ，用时 $5$，并在时间 $8$ 到达，在等待 $1$ 个时间点后可以领取 $2$ 号摊位的礼品，接着他从 $2$ 号摊位走到 $1$ 号摊位，用时 $4$，并在时间 $13$ 到达，从而可以收集到第 $3$ 个礼品。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1\\le n\\le 400$，$0\\le p_i\\le 10^9$，$1\\le t_{i,j}\\le 10^6$。\n\n数据来自 darkbzoj。", "locale": "zh-CN"}}}
{"pid": "P6760", "type": "P", "difficulty": 6, "samples": [["3\n3 1 2 3\n3 3 4 5\n2 4 2", "4\n7\n7"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["贪心", "2019", "THUPC"], "title": "[THUPC 2019] 大碗宽面", "background": "", "description": "Yazid 喜欢吃大碗宽面。现有 $m$ 碗宽面，其中第 $i$ 碗宽面（$1 \\le i \\le m$）共包含 $n_i$ 根面条，它们的宽度分别为 $A_{i,1},A_{i,2},\\cdots,A_{i,n}$。\n\n记 $f(u,v)$ 表示若混合第 $u$ 碗宽面和第 $v$ 碗宽面，将得到的超大碗宽面的第 $\\left\\lfloor\\dfrac{n_u +n_v +1}{2}\\right\\rfloor$ 小的面条宽度（$\\lfloor x \\rfloor$ 表示不超过 $x$ 的最大整数）。\n\nYazid 想求出所有 $f(u,v)$，但为了节省你的输出时间，你只需要对所有 $1 \\le u \\le m$ 求出：\n\n- $R(u)=\\mathop{\\rm xor}\\limits_{v=1}^{m} {(f(u,v)+u+v)}$（$\\rm xor$ 指异或运算，在 C++ 语言中对应 `^` 运算符）。", "inputFormat": "第一行一个正整数 $m$，表示宽面碗数。\n\n接下来 $m$ 行，每行若干个用单个空格隔开的整数描述一碗宽面：这部分的第 $i$ 行的第一个正整数为 $n_i$，表示第 $i$ 碗宽面包含的面条数；接下来 $n_i$ 个非负整数 $A_{i,j}$ 描述各面条的宽度。", "outputFormat": "输出 $n$ 行，每行一个整数，其中第 $i$ 行的整数为 $R(i)$。", "hint": "#### 样例说明\n\n对于样例 $1$：\n\n- $\\def\\x{\\operatorname{xor}} R(1) = {(f(1,1)+2)}\\x{(f(1,2)+3)}\\x{(f(1,3)+4)} = 4\\x6\\x6 = 4$\n- $\\def\\x{\\operatorname{xor}} R(2) = {(f(2,1)+3)}\\x{(f(2,2)+4)}\\x{(f(2,3)+5)} = 6\\x8\\x9 = 7$\n- $\\def\\x{\\operatorname{xor}} R(3) = {(f(3,1)+4)}\\x{(f(3,2)+5)}\\x{(f(3,3)+6)} = 6\\x9\\x8 = 7$\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$m \\le 10^4$，$n_i \\le 500$，$0 \\le A_{i,j} \\le 10^9$。\n\n#### 说明\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 https://github.com/wangyurzee7/THUPC2019 查看。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2019] 大碗宽面", "background": "", "description": "Yazid 喜欢吃大碗宽面。现有 $m$ 碗宽面，其中第 $i$ 碗宽面（$1 \\le i \\le m$）共包含 $n_i$ 根面条，它们的宽度分别为 $A_{i,1},A_{i,2},\\cdots,A_{i,n}$。\n\n记 $f(u,v)$ 表示若混合第 $u$ 碗宽面和第 $v$ 碗宽面，将得到的超大碗宽面的第 $\\left\\lfloor\\dfrac{n_u +n_v +1}{2}\\right\\rfloor$ 小的面条宽度（$\\lfloor x \\rfloor$ 表示不超过 $x$ 的最大整数）。\n\nYazid 想求出所有 $f(u,v)$，但为了节省你的输出时间，你只需要对所有 $1 \\le u \\le m$ 求出：\n\n- $R(u)=\\mathop{\\rm xor}\\limits_{v=1}^{m} {(f(u,v)+u+v)}$（$\\rm xor$ 指异或运算，在 C++ 语言中对应 `^` 运算符）。", "inputFormat": "第一行一个正整数 $m$，表示宽面碗数。\n\n接下来 $m$ 行，每行若干个用单个空格隔开的整数描述一碗宽面：这部分的第 $i$ 行的第一个正整数为 $n_i$，表示第 $i$ 碗宽面包含的面条数；接下来 $n_i$ 个非负整数 $A_{i,j}$ 描述各面条的宽度。", "outputFormat": "输出 $n$ 行，每行一个整数，其中第 $i$ 行的整数为 $R(i)$。", "hint": "#### 样例说明\n\n对于样例 $1$：\n\n- $\\def\\x{\\operatorname{xor}} R(1) = {(f(1,1)+2)}\\x{(f(1,2)+3)}\\x{(f(1,3)+4)} = 4\\x6\\x6 = 4$\n- $\\def\\x{\\operatorname{xor}} R(2) = {(f(2,1)+3)}\\x{(f(2,2)+4)}\\x{(f(2,3)+5)} = 6\\x8\\x9 = 7$\n- $\\def\\x{\\operatorname{xor}} R(3) = {(f(3,1)+4)}\\x{(f(3,2)+5)}\\x{(f(3,3)+6)} = 6\\x9\\x8 = 7$\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$m \\le 10^4$，$n_i \\le 500$，$0 \\le A_{i,j} \\le 10^9$。\n\n#### 说明\n\n来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。\n\n题解等资源可在 https://github.com/wangyurzee7/THUPC2019 查看。", "locale": "zh-CN"}}}
{"pid": "P6761", "type": "P", "difficulty": 5, "samples": [["3 3\n3\n1 0 3 0\n0 0 0 3\n3 0 3 1", "1"]], "limits": {"time": [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2010", "二分", "BalticOI（波罗的海）"], "title": "[BalticOI 2010] BEARs (Day1)", "background": "本题中的 $(a,b) \\to (c,d)$ 代表一条从 $(a,b)$ 连向 $(c,d)$ 的线段。", "description": "给定 $N$ 条长度为 $1$ 的线段，定义他们为「标记线」。\n\n现在在点 $(A,B)$ 处有一个强盗，他要前往 $(0,0)$，警察们可以任意选择一个点，关闭他四周的任意一条线段。比如选择点 $(0,0)$，线段 $(-1,1) \\to (1,1)$，$(-1,1)\\to (-1,-1)$，$(-1,-1) \\to (1,-1)$，$(1,-1) \\to (1,1)$ 其中之一将会被关闭，但是关闭的线段中不能有与标记线 **直接相连** 的线段。比如 $(0,0) \\to (0,2)$ 与 $(0,1) \\to (0,3)$ 是直接相连的，但是 $(-1,1) \\to (1,1)$ 与 $(0,0) \\to (0,3)$ 不是。\n\n强盗可以到达关闭的线段上的点，但是不能通过关闭的线段离开。\n\n求强盗离 $(0,0)$ 的最近的距离的最大值 $D$。", "inputFormat": "第一行两个整数 $A,B$ 代表强盗初始在 $(A,B)$。     \n第二行一个整数 $N$ 代表标记线数。    \n接下来 $N$ 行每行两个整数 $X_1,Y_1,X_2,Y_2$ 代表一条标记线 $(X_1,Y_1) \\to (X_2,Y_2)$。", "outputFormat": "一行一个整数代表强盗离 $(0,0)$ 的最近的距离的最大值 $D$。", "hint": "#### 样例说明\n\n对于样例 $1$，如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cqukdqmc.png)\n\n选择的点为 $(0,0)$，关闭的线段为 $(1,1) \\to (1,-1)$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$|A|,|B|,|X_1|,|Y_1|,|X_2|,|Y_2| \\le 10^6$，$0 \\le N \\le 500$，保证每条标记线 $X_1=X_2$ 或者 $Y_1=Y_2$。\n\n#### 说明\n\n翻译自 [BalticOI 2010 Day1 A BEARs](https://boi.cses.fi/files/boi2010_day1.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2010] BEARs (Day1)", "background": "本题中的 $(a,b) \\to (c,d)$ 代表一条从 $(a,b)$ 连向 $(c,d)$ 的线段。", "description": "给定 $N$ 条长度为 $1$ 的线段，定义他们为「标记线」。\n\n现在在点 $(A,B)$ 处有一个强盗，他要前往 $(0,0)$，警察们可以任意选择一个点，关闭他四周的任意一条线段。比如选择点 $(0,0)$，线段 $(-1,1) \\to (1,1)$，$(-1,1)\\to (-1,-1)$，$(-1,-1) \\to (1,-1)$，$(1,-1) \\to (1,1)$ 其中之一将会被关闭，但是关闭的线段中不能有与标记线 **直接相连** 的线段。比如 $(0,0) \\to (0,2)$ 与 $(0,1) \\to (0,3)$ 是直接相连的，但是 $(-1,1) \\to (1,1)$ 与 $(0,0) \\to (0,3)$ 不是。\n\n强盗可以到达关闭的线段上的点，但是不能通过关闭的线段离开。\n\n求强盗离 $(0,0)$ 的最近的距离的最大值 $D$。", "inputFormat": "第一行两个整数 $A,B$ 代表强盗初始在 $(A,B)$。     \n第二行一个整数 $N$ 代表标记线数。    \n接下来 $N$ 行每行两个整数 $X_1,Y_1,X_2,Y_2$ 代表一条标记线 $(X_1,Y_1) \\to (X_2,Y_2)$。", "outputFormat": "一行一个整数代表强盗离 $(0,0)$ 的最近的距离的最大值 $D$。", "hint": "#### 样例说明\n\n对于样例 $1$，如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cqukdqmc.png)\n\n选择的点为 $(0,0)$，关闭的线段为 $(1,1) \\to (1,-1)$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$|A|,|B|,|X_1|,|Y_1|,|X_2|,|Y_2| \\le 10^6$，$0 \\le N \\le 500$，保证每条标记线 $X_1=X_2$ 或者 $Y_1=Y_2$。\n\n#### 说明\n\n翻译自 [BalticOI 2010 Day1 A BEARs](https://boi.cses.fi/files/boi2010_day1.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6762", "type": "P", "difficulty": 7, "samples": [["2\nWWGG..\n.BB.WW\n.WGG..\nWWGG..", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "搜索", "2010", "BalticOI（波罗的海）", "状压 DP"], "title": "[BalticOI 2010] Lego (Day1)", "background": "", "description": "给定一些 $2 \\times 2$ 的乐高方块，分别有白色（W），灰色（G）和黑色（B）。现在您要往 $6 \\times 6$ 的底板上放置方块，需要保证不能有完全浮空的方块（即四个方格均无放置的地方）也不能超出 $6 \\times 6$ 的底板。\n\n现在给定一个放置完方块的底板的一面的示意图，和这一面逆时针旋转 $90^\\circ$ 后的一面的示意图，求有多少种放置方块的方法数。", "inputFormat": "第一行一个整数 $H$ 代表这种放置方块的高度。    \n接下来 $H$ 行每行六个字符，代表从这一面看到的示意图。    \n接下来 $H$ 行每行六个字符，代表从上一面逆时针旋转 $90^\\circ$ 后的示意图。   \n只能从前面，后面，左面，右面看，不能从上面，下面看。", "outputFormat": "一行一个整数代表答案。          \n答案保证在 64 位有符号整数内。", "hint": "#### 样例 1 解释\n\n如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/njr2rk9l.png)\n\n第一个是从 $A$ 面观察到的示意图。    \n第二个是从 $B$ 面（$A$ 面逆时针旋转 $90^\\circ$）观察到的示意图。\n\n下面是这 $6$ 种情况（感谢 Vonov 提供的图片！）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wymozlif.png)         \n![](https://cdn.luogu.com.cn/upload/image_hosting/1vw0fu3t.png)         \n![](https://cdn.luogu.com.cn/upload/image_hosting/umn2hync.png)             \n![](https://cdn.luogu.com.cn/upload/image_hosting/pykojvay.png)           \n![](https://cdn.luogu.com.cn/upload/image_hosting/9z9wvzxp.png)          \n![](https://cdn.luogu.com.cn/upload/image_hosting/hkp3tjfp.png)\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le H \\le 6$。\n\n#### 说明\n\n翻译自 [BalticOI 2010 Day1 B Lego](https://boi.cses.fi/files/boi2010_day1.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2010] Lego (Day1)", "background": "", "description": "给定一些 $2 \\times 2$ 的乐高方块，分别有白色（W），灰色（G）和黑色（B）。现在您要往 $6 \\times 6$ 的底板上放置方块，需要保证不能有完全浮空的方块（即四个方格均无放置的地方）也不能超出 $6 \\times 6$ 的底板。\n\n现在给定一个放置完方块的底板的一面的示意图，和这一面逆时针旋转 $90^\\circ$ 后的一面的示意图，求有多少种放置方块的方法数。", "inputFormat": "第一行一个整数 $H$ 代表这种放置方块的高度。    \n接下来 $H$ 行每行六个字符，代表从这一面看到的示意图。    \n接下来 $H$ 行每行六个字符，代表从上一面逆时针旋转 $90^\\circ$ 后的示意图。   \n只能从前面，后面，左面，右面看，不能从上面，下面看。", "outputFormat": "一行一个整数代表答案。          \n答案保证在 64 位有符号整数内。", "hint": "#### 样例 1 解释\n\n如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/njr2rk9l.png)\n\n第一个是从 $A$ 面观察到的示意图。    \n第二个是从 $B$ 面（$A$ 面逆时针旋转 $90^\\circ$）观察到的示意图。\n\n下面是这 $6$ 种情况（感谢 Vonov 提供的图片！）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wymozlif.png)         \n![](https://cdn.luogu.com.cn/upload/image_hosting/1vw0fu3t.png)         \n![](https://cdn.luogu.com.cn/upload/image_hosting/umn2hync.png)             \n![](https://cdn.luogu.com.cn/upload/image_hosting/pykojvay.png)           \n![](https://cdn.luogu.com.cn/upload/image_hosting/9z9wvzxp.png)          \n![](https://cdn.luogu.com.cn/upload/image_hosting/hkp3tjfp.png)\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le H \\le 6$。\n\n#### 说明\n\n翻译自 [BalticOI 2010 Day1 B Lego](https://boi.cses.fi/files/boi2010_day1.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6763", "type": "P", "difficulty": 5, "samples": [["2\n1 1\n3 3", "1"], ["2\n1 3\n3 1", "2"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2010", "BalticOI（波罗的海）"], "title": "[BalticOI 2010] Printed Circuit Board (Day1)", "background": "", "description": "你现在有无数个平面直角坐标系，给定 $N$ 条线段，每条线段连接 $(X_{i,1},0)$ 和 $(X_{i,2},H)$（$H$ 是一个正数，不过并不给定，解题也并不需要），要求将这些线段放置在平面直角坐标系上，不能有任意两条线段相交。\n\n求最小需要多少平面直角坐标系才能容纳这些线段。", "inputFormat": "第一行一个整数 $N$ 代表线段数。     \n接下来 $N$ 行每行两个整数 $X_{i,1},X_{i,2}$ 代表一条线段。", "outputFormat": "一行一个整数代表答案。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le N\\le 10^5$，$0 \\le X_{i,1},X_{i,2} \\le 10^6$。所有的 $X_{i, 1}$ 互不相同，所有的 $X_{i,2}$ 互不相同。也即，没有两个端点在同一位置。\n\n#### 说明\n\n翻译自 [BalticOI 2010 Day1 C Printed Circuit Board](https://boi.cses.fi/files/boi2010_day1.pdf)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2010] Printed Circuit Board (Day1)", "background": "", "description": "你现在有无数个平面直角坐标系，给定 $N$ 条线段，每条线段连接 $(X_{i,1},0)$ 和 $(X_{i,2},H)$（$H$ 是一个正数，不过并不给定，解题也并不需要），要求将这些线段放置在平面直角坐标系上，不能有任意两条线段相交。\n\n求最小需要多少平面直角坐标系才能容纳这些线段。", "inputFormat": "第一行一个整数 $N$ 代表线段数。     \n接下来 $N$ 行每行两个整数 $X_{i,1},X_{i,2}$ 代表一条线段。", "outputFormat": "一行一个整数代表答案。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le N\\le 10^5$，$0 \\le X_{i,1},X_{i,2} \\le 10^6$。所有的 $X_{i, 1}$ 互不相同，所有的 $X_{i,2}$ 互不相同。也即，没有两个端点在同一位置。\n\n#### 说明\n\n翻译自 [BalticOI 2010 Day1 C Printed Circuit Board](https://boi.cses.fi/files/boi2010_day1.pdf)。", "locale": "zh-CN"}}}
{"pid": "P6764", "type": "P", "difficulty": 6, "samples": [["8 3 5\n3 3 1 3 4 4 2 2\n3 0 1 2\n2 2 3\n2 3 4\n", "3\n"], ["5 4 4\n1 0 1 2 2\n2 0 1\n1 1\n1 2\n1 3\n", "-1\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "APIO", "交互题", "Special Judge", "O2优化"], "title": "[APIO2020] 粉刷墙壁", "background": "本题仅支持 C++ 系列语言，提交时**不需要**包含 `paint.h` 头文件。\n\n如果交互库存在其他问题，请私信 mrsrz。", "description": "距离上一次 Pak Dengklek 在他的家中粉刷墙壁已经过了一段时间，所以他想重新粉刷一次。他家的墙壁由 $N$ 段组成，它们从 $0$ 到 $N - 1$ 编号。本题中我们假设存在 $K$ 种不同的颜色，颜色用从 $0$ 到 $K - 1$ 的整数表示（例如，红色用 $0$ 表示, 蓝色用 $1$ 表示，以此类推）。Pak Dengklek 希望用第 $C[i]$ 种颜色来粉刷第 $i$ 段的墙壁。\n\n为了粉刷墙壁，Pak Dengklek 雇用了一家有 $M$ 个承包商的承包商公司，承包商从 $0$ 到 $M - 1$ 编号。对 Pak Dengklek 来说不幸的是，承包商只愿意粉刷他们自己喜欢的\n颜色。具体来说，第 $j$ 个承包商喜欢 $A[j]$ 种颜色，并且只想用下列颜色来粉刷墙壁：第 $B[j][0]$ 种颜色，第 $B[j][1]$ 种颜色，$\\dots$，或第 $B[j][A[j] − 1]$ 种颜色。\n\nPak Dengklek 可以给承包商公司提出一些要求。在单个要求中，Pak Dengklek 将给出两个参数 $x$ 和 $y$， 其中 $0 \\leq x < M$，$0 \\leq y \\leq N - M$。承包商公司将会指派第 $((x + l) \\mod M)$ 个承包商粉刷第 $(y + l)$ 段墙壁，其中 $0 \\leq l < M$。如果存在一个 $l$ 使\n得第 $((x + l) \\mod M)$ 个承包商不喜欢第 $C[y + l]$ 种颜色，那么该要求将无效。\n\nPak Dengklek 需要为每个要求付费，因此他想知道为了使墙壁中每个段都能用自己预期的颜色粉刷，他至少要提出多少个要求，或是确认他的预期无法达到。每一段墙壁可以被粉刷多次，但必须保证每次粉刷的颜色都是 Pak Dengklek 所预期的。\n\n你必须实现 `minimumInstructions` 函数：\n\n- `minimumInstructions(N, M, K, C, A, B)` - 该函数将被评测库恰好调用一次。\n\t- $N$：一个整数表示墙壁的段数。\n\t- $M$：一个整数表示承包商的数量。\n\t- $K$：一个整数表示颜色的种数。\n\t- $C$：一个长度为 $N$ 的整数序列，表示每段墙壁预期的颜色。\n\t- $A$：一个长度为 $M$ 的整数序列，表示承包商喜欢的颜色数。\n\t- $B$：一个长度为 $M$ 的每个元素为序列的序列，表示承包商喜欢的具体颜色。\n\t- 该函数必须返回一个整数，表示 Pak Dengklek 为了让墙壁按预期粉刷所需要提出的最小要求数；若预期无法达到则返回 $-1$。", "inputFormat": "样例评测库将读入以下格式的数据：\n```\nN M K\nC[0] C[1] ... C[N-1]\nA[0] B[0][0] B[0][1] ... B[0][A[0]-1]\nA[1] B[1][0] B[1][1] ... B[1][A[1]-1]\n.\n.\n.\nA[M-1] B[M-1][0] B[M-1][1] ... B[M-1][A[M-1]-1]\n```", "outputFormat": "样例评测库将输出函数 `minimumInstructions` 的返回值", "hint": "在第一个样例中， $N = 8$，$M = 3$，$K = 5$，$C = [3, 3, 1, 3, 4, 4, 2, 2]$，$A = [3, 2, 2]$，$B = [[0, 1, 2], [2, 3], [3, 4]]$。Pak Dengklek 可以提出下列的要求。\n\n1. $x = 1$，$y = 0$。这是一个有效的要求，第一个承包商可以粉刷第零段墙壁，第二个承包商可以粉刷第一段墙壁，第零个承包商可以粉刷第二段墙壁。\n2. $x = 0$，$y = 2$。 这是一个有效的要求，第零个承包商可以粉刷第二段墙壁，第一个承包商可以粉刷第三段墙壁，第二个承包商可以粉刷第四段墙壁。\n3. $x = 2$，$y = 5$。 这是一个有效的要求，第二个承包商可以粉刷第五段墙壁，第零个承包商可以粉刷第六段墙壁，第一个承包商可以粉刷第七段墙壁。\n\n容易看出 Pak Dengklek 不能用少于 $3$ 个的要求来达到预期，因此 `minimumInstructions(8, 3, 5, [3, 3, 1, 3, 4, 4, 2, 2], [3, 2, 2], [[0, 1, 2], [2, 3], [3,\n4]])` 应该返回 $3$。\n\n在第二个样例中，$N = 5$，$M = 4$，$K = 4$，$C = [1, 0, 1, 2, 2]$，$A = [2, 1, 1, 1]$，$B =\n[[0, 1], [1], [2], [3]]$。由于第三个承包商只喜欢第 $3$ 种颜色但没有任何一段墙壁能被该颜色粉刷，Pak Dengklek 无法给出任何有效指令。因此`minimumInstructions(5, 4, 4,[1, 0, 1, 2, 2], [2, 1, 1, 1], [[0, 1], [1], [2], [3]])` 应该返回 $-1$。\n\n对于 $0 \\leq k < K$, 令 $f(k)$ 表示喜欢第 $k$ 种颜色的承包商数量。\n\n【条件限制】\n\n- $1 \\leq N \\leq 10^5$。\n- $1 \\leq M \\leq \\min(N, 5 \\times 10^4)$。\n- $1 \\leq K \\leq 10^5$。\n- $0 \\leq C[i] < K$。\n- $1 \\leq A[j] \\leq K$。\n- $0 \\leq B[j][0] < B[j][1] < \\dots < B[j][A[j] − 1] < K$。\n- $\\sum f(k)^2 \\leq 4\\times 10^5$。\n\n【子任务 $1$（$12$ 分）】\n\n- $f(k) \\leq 1$。\n\n【子任务 $2$（$15$ 分）】\n\n- $N \\leq 500$。\n- $M \\leq \\min(N, 200)$。\n- $\\sum f(k)^2 \\leq 1 000$。\n\n【子任务 $3$（$13$ 分）】\n\n- $N \\leq 500$。\n- $M \\leq \\min(N, 200)$。\n\n【子任务 $4$（$23$ 分）】\n\n- $N \\leq 20 000$。\n- $M \\leq \\min(N, 2 000)$。\n\n【子任务 $5$（$37$ 分）】\n\n- 无附加限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[APIO2020] 粉刷墙壁", "background": "本题仅支持 C++ 系列语言，提交时**不需要**包含 `paint.h` 头文件。\n\n如果交互库存在其他问题，请私信 mrsrz。", "description": "距离上一次 Pak Dengklek 在他的家中粉刷墙壁已经过了一段时间，所以他想重新粉刷一次。他家的墙壁由 $N$ 段组成，它们从 $0$ 到 $N - 1$ 编号。本题中我们假设存在 $K$ 种不同的颜色，颜色用从 $0$ 到 $K - 1$ 的整数表示（例如，红色用 $0$ 表示, 蓝色用 $1$ 表示，以此类推）。Pak Dengklek 希望用第 $C[i]$ 种颜色来粉刷第 $i$ 段的墙壁。\n\n为了粉刷墙壁，Pak Dengklek 雇用了一家有 $M$ 个承包商的承包商公司，承包商从 $0$ 到 $M - 1$ 编号。对 Pak Dengklek 来说不幸的是，承包商只愿意粉刷他们自己喜欢的\n颜色。具体来说，第 $j$ 个承包商喜欢 $A[j]$ 种颜色，并且只想用下列颜色来粉刷墙壁：第 $B[j][0]$ 种颜色，第 $B[j][1]$ 种颜色，$\\dots$，或第 $B[j][A[j] − 1]$ 种颜色。\n\nPak Dengklek 可以给承包商公司提出一些要求。在单个要求中，Pak Dengklek 将给出两个参数 $x$ 和 $y$， 其中 $0 \\leq x < M$，$0 \\leq y \\leq N - M$。承包商公司将会指派第 $((x + l) \\mod M)$ 个承包商粉刷第 $(y + l)$ 段墙壁，其中 $0 \\leq l < M$。如果存在一个 $l$ 使\n得第 $((x + l) \\mod M)$ 个承包商不喜欢第 $C[y + l]$ 种颜色，那么该要求将无效。\n\nPak Dengklek 需要为每个要求付费，因此他想知道为了使墙壁中每个段都能用自己预期的颜色粉刷，他至少要提出多少个要求，或是确认他的预期无法达到。每一段墙壁可以被粉刷多次，但必须保证每次粉刷的颜色都是 Pak Dengklek 所预期的。\n\n你必须实现 `minimumInstructions` 函数：\n\n- `minimumInstructions(N, M, K, C, A, B)` - 该函数将被评测库恰好调用一次。\n\t- $N$：一个整数表示墙壁的段数。\n\t- $M$：一个整数表示承包商的数量。\n\t- $K$：一个整数表示颜色的种数。\n\t- $C$：一个长度为 $N$ 的整数序列，表示每段墙壁预期的颜色。\n\t- $A$：一个长度为 $M$ 的整数序列，表示承包商喜欢的颜色数。\n\t- $B$：一个长度为 $M$ 的每个元素为序列的序列，表示承包商喜欢的具体颜色。\n\t- 该函数必须返回一个整数，表示 Pak Dengklek 为了让墙壁按预期粉刷所需要提出的最小要求数；若预期无法达到则返回 $-1$。", "inputFormat": "样例评测库将读入以下格式的数据：\n```\nN M K\nC[0] C[1] ... C[N-1]\nA[0] B[0][0] B[0][1] ... B[0][A[0]-1]\nA[1] B[1][0] B[1][1] ... B[1][A[1]-1]\n.\n.\n.\nA[M-1] B[M-1][0] B[M-1][1] ... B[M-1][A[M-1]-1]\n```", "outputFormat": "样例评测库将输出函数 `minimumInstructions` 的返回值", "hint": "在第一个样例中， $N = 8$，$M = 3$，$K = 5$，$C = [3, 3, 1, 3, 4, 4, 2, 2]$，$A = [3, 2, 2]$，$B = [[0, 1, 2], [2, 3], [3, 4]]$。Pak Dengklek 可以提出下列的要求。\n\n1. $x = 1$，$y = 0$。这是一个有效的要求，第一个承包商可以粉刷第零段墙壁，第二个承包商可以粉刷第一段墙壁，第零个承包商可以粉刷第二段墙壁。\n2. $x = 0$，$y = 2$。 这是一个有效的要求，第零个承包商可以粉刷第二段墙壁，第一个承包商可以粉刷第三段墙壁，第二个承包商可以粉刷第四段墙壁。\n3. $x = 2$，$y = 5$。 这是一个有效的要求，第二个承包商可以粉刷第五段墙壁，第零个承包商可以粉刷第六段墙壁，第一个承包商可以粉刷第七段墙壁。\n\n容易看出 Pak Dengklek 不能用少于 $3$ 个的要求来达到预期，因此 `minimumInstructions(8, 3, 5, [3, 3, 1, 3, 4, 4, 2, 2], [3, 2, 2], [[0, 1, 2], [2, 3], [3,\n4]])` 应该返回 $3$。\n\n在第二个样例中，$N = 5$，$M = 4$，$K = 4$，$C = [1, 0, 1, 2, 2]$，$A = [2, 1, 1, 1]$，$B =\n[[0, 1], [1], [2], [3]]$。由于第三个承包商只喜欢第 $3$ 种颜色但没有任何一段墙壁能被该颜色粉刷，Pak Dengklek 无法给出任何有效指令。因此`minimumInstructions(5, 4, 4,[1, 0, 1, 2, 2], [2, 1, 1, 1], [[0, 1], [1], [2], [3]])` 应该返回 $-1$。\n\n对于 $0 \\leq k < K$, 令 $f(k)$ 表示喜欢第 $k$ 种颜色的承包商数量。\n\n【条件限制】\n\n- $1 \\leq N \\leq 10^5$。\n- $1 \\leq M \\leq \\min(N, 5 \\times 10^4)$。\n- $1 \\leq K \\leq 10^5$。\n- $0 \\leq C[i] < K$。\n- $1 \\leq A[j] \\leq K$。\n- $0 \\leq B[j][0] < B[j][1] < \\dots < B[j][A[j] − 1] < K$。\n- $\\sum f(k)^2 \\leq 4\\times 10^5$。\n\n【子任务 $1$（$12$ 分）】\n\n- $f(k) \\leq 1$。\n\n【子任务 $2$（$15$ 分）】\n\n- $N \\leq 500$。\n- $M \\leq \\min(N, 200)$。\n- $\\sum f(k)^2 \\leq 1 000$。\n\n【子任务 $3$（$13$ 分）】\n\n- $N \\leq 500$。\n- $M \\leq \\min(N, 200)$。\n\n【子任务 $4$（$23$ 分）】\n\n- $N \\leq 20 000$。\n- $M \\leq \\min(N, 2 000)$。\n\n【子任务 $5$（$37$ 分）】\n\n- 无附加限制。", "locale": "zh-CN"}}}
{"pid": "P6765", "type": "P", "difficulty": 6, "samples": [["5 6\n0 1 4\n0 2 4\n1 2 1\n1 3 2\n1 4 10\n2 3 3\n3\n1 2\n2 4\n0 1\n", "3\n10\n4\n"], ["3 2\n0 1 5\n0 2 5\n1\n1 2\n", "-1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "APIO", "交互题", "Special Judge"], "title": "[APIO2020] 交换城市", "background": "本题仅支持 C++ 系列语言，提交时**不需要**包含 `swap.h` 头文件。\n\n由于交互库本身的性能问题，本题的时间限制上调为 $3$ 秒。如果交互库存在其他问题，请私信 mrsrz。", "description": "印度尼西亚有 $N$ 个城市以及 $M$ 条双向道路，城市从 $0$ 到 $N - 1$ 编号，道路从 $0$ 到 $M - 1$ 编号。每条道路连接着两个不同的城市，第 $i$ 条道路连接第 $U[i]$ 个城市与第 $V[i]$ 个城市，汽车行驶这条道路将耗费 $W[i]$ 个单位汽油。通过这些道路，任意两个城市间能够互相到达。\n\n接下来的 $Q$ 天中, 每天会有一对城市希望建立政治关系。具体来说，第 $j$ 天，第 $X[j]$ 个城市想要和第 $Y[j]$ 个城市建立政治关系。为此，第 $X[j]$ 个城市将会派一名代表坐汽车前往第 $Y[j]$ 个城市。同样地，第 $Y[j]$ 个城市也会派一名代表坐汽车前往第 $X[j]$ 个城市。\n\n为了避免拥塞，两辆车不应在任何时间点碰面。更具体地，两辆车不能在同一个时间点出现在同一个城市。同样地，两辆车也不应该沿相反的方向同时行驶过同一条道路。另外，汽车行驶过一条道路时必须完整经过道路并到达道路另一端的城市（换句话说，汽车不允许在道路中间掉转方向）。但是，汽车可以多次到达一个城市或是多次经过一条道路。此外，汽车可以在任何时间在任何城市等候。\n\n由于高燃料容量汽车的价格昂贵，两个城市都分别希望选择一条路线，使得两辆汽车所需的最大单位汽油容量最小。每个城市中都有加油站并且供油量是无限的，因此汽车所需的单位汽油容量实际上就是行驶过的道路中最大的单位汽油消耗量。\n\n你必须实现 `init` 和 `getMinimumFuelCapacity` 函数。\n\n- `init(N, M, U, V, W)` - 该函数将在所有 `getMinimumFuelCapacity` 的调用前被评测库恰好调用一次。\n\t- $N$： 一个整数表示城市数。\n\t- $M$： 一个整数表示道路数。\n\t- $U$： 一个长为 $M$ 的整数序列表示道路的第一个端点城市。\n\t- $V$： 一个长为 $M$ 的整数序列表示道路的第二个端点城市。\n\t- $W$： 一个长为 $M$ 的整数序列表示道路的汽油消耗。\n\n- `getMinimumFuelCapacity(X, Y)` - 该函数将被评测库调用恰好 $Q$ 次。\n\t- $X$： 一个整数表示第一个城市。\n\t- $Y$： 一个整数表示第二个城市。\n\t- 该函数必须返回一个整数，表示根据题目描述中的规则，两辆分别从第 $X$ 个城市与第 $Y$ 个城市出发要到达彼此城市的车，它们的单位汽油容量最大值的最小值。若无法满足题目规则则返回 $−1$。", "inputFormat": "样例评测库将读入以下格式的数据： \n\n```\nN M\nU[0] V[0] W[0]\nU[1] V[1] W[1]\n.\n.\n.\nU[M-1] V[M-1] W[M-1]\nQ\nX[0] Y[0]\nX[1] Y[1]\n.\n.\n.\nX[Q-1] Y[Q-1]\n```", "outputFormat": "对每个 `getMinimumFuelCapacity` 的调用，样例评测库会输出该函数的返回值", "hint": "第一个样例中, $N = 5$，$M = 6$，$U = [0, 0, 1, 1, 1, 2]$，$V = [1, 2, 2, 3, 4, 3]$，$W =\n[4, 4, 1, 2, 10, 3]$，$Q = 3$，$X = [1, 2, 0]$，$Y = [2, 4, 1]$。如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j3x1idy8.png)\n\n评测库初始时将调用 `init(5, 6, [0, 0, 1, 1, 1, 2], [1, 2, 2, 3, 4, 3],[4, 4, 1, 2, 10, 3])`。之后，评测库将进行如下函数调用：\n\n- `getMinimumFuelCapacity(1, 2)`。首先，从第一个城市出发的汽车可以行驶到第三个城市。接着，从第二个城市出发的汽车可以行驶到第一个城市，并且在第三个城市的汽车可以行驶到第二个城市。因此，最大的单位汽油容量为 $3$ （从第三个城市到第二个城市需要花费 $3$ 个单位汽油）。没有其他更优的路线方案，因此该函数应该返回 $3$。\n\n- `getMinimumFuelCapacity(2, 4)`。任何从第四个城市出发或要到达第四个城市的汽车都需要耗费 $10$ 个单位汽油，因此该函数应该返回 $10$。\n\n- `getMinimumFuelCapacity(0, 1)`。该函数应该返回 $4$。\n\n第二个样例中，$N = 3$，$M = 2$，$U = [0, 0]$，$V = [1, 2]$，$W = [5, 5]$，$Q = 1$，$X = [1]$，$Y = [2]$。 如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3df9k1og.png)\n\n评测库初始时将调用 `init(3, 2, [0, 0], [1, 2], [5, 5])`，之后，评测库将进行如下函数调用：\n\n- `getMinimumFuelCapacity(1, 2)`。两辆车无法满足不在同一时间点碰面的要求，所以该函数应该返回 $-1$。\n\n【条件限制】\n\n- $2 \\leq N \\leq 100 000$。\n- $N - 1 \\leq M \\leq 200 000$。\n- $0 \\leq U[i] < V [i] < N$。\n- 任意两个城市间至多存在一条道路直接相连。\n- 任意两个城市经过道路可以互相到达。\n- $1 \\leq W[i] \\leq 10^9$。\n- $1 \\leq Q \\leq 200 000$。\n- $0 \\leq X[j] < Y [j] < N$。\n\n【子任务 $1$（$6$ 分）】\n\n- 每个城市至多是两条道路的一个端点。\n\n【子任务 $2$（$7$ 分）】\n\n- $M = N - 1$。\n- $U[i] = 0$。\n\n【子任务 $3$（$17$ 分）】\n\n- $Q \\leq 5$。\n- $N \\leq 1 000$。\n- $M \\leq 2 000$。\n\n【子任务 $4$（$20$ 分）】\n\n- $Q \\leq 5$。\n\n【子任务 $5$（$23$ 分）】\n\n- $M = N - 1$。\n\n【子任务 $6$（$27$ 分）】\n\n- 无附加限制。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[APIO2020] 交换城市", "background": "本题仅支持 C++ 系列语言，提交时**不需要**包含 `swap.h` 头文件。\n\n由于交互库本身的性能问题，本题的时间限制上调为 $3$ 秒。如果交互库存在其他问题，请私信 mrsrz。", "description": "印度尼西亚有 $N$ 个城市以及 $M$ 条双向道路，城市从 $0$ 到 $N - 1$ 编号，道路从 $0$ 到 $M - 1$ 编号。每条道路连接着两个不同的城市，第 $i$ 条道路连接第 $U[i]$ 个城市与第 $V[i]$ 个城市，汽车行驶这条道路将耗费 $W[i]$ 个单位汽油。通过这些道路，任意两个城市间能够互相到达。\n\n接下来的 $Q$ 天中, 每天会有一对城市希望建立政治关系。具体来说，第 $j$ 天，第 $X[j]$ 个城市想要和第 $Y[j]$ 个城市建立政治关系。为此，第 $X[j]$ 个城市将会派一名代表坐汽车前往第 $Y[j]$ 个城市。同样地，第 $Y[j]$ 个城市也会派一名代表坐汽车前往第 $X[j]$ 个城市。\n\n为了避免拥塞，两辆车不应在任何时间点碰面。更具体地，两辆车不能在同一个时间点出现在同一个城市。同样地，两辆车也不应该沿相反的方向同时行驶过同一条道路。另外，汽车行驶过一条道路时必须完整经过道路并到达道路另一端的城市（换句话说，汽车不允许在道路中间掉转方向）。但是，汽车可以多次到达一个城市或是多次经过一条道路。此外，汽车可以在任何时间在任何城市等候。\n\n由于高燃料容量汽车的价格昂贵，两个城市都分别希望选择一条路线，使得两辆汽车所需的最大单位汽油容量最小。每个城市中都有加油站并且供油量是无限的，因此汽车所需的单位汽油容量实际上就是行驶过的道路中最大的单位汽油消耗量。\n\n你必须实现 `init` 和 `getMinimumFuelCapacity` 函数。\n\n- `init(N, M, U, V, W)` - 该函数将在所有 `getMinimumFuelCapacity` 的调用前被评测库恰好调用一次。\n\t- $N$： 一个整数表示城市数。\n\t- $M$： 一个整数表示道路数。\n\t- $U$： 一个长为 $M$ 的整数序列表示道路的第一个端点城市。\n\t- $V$： 一个长为 $M$ 的整数序列表示道路的第二个端点城市。\n\t- $W$： 一个长为 $M$ 的整数序列表示道路的汽油消耗。\n\n- `getMinimumFuelCapacity(X, Y)` - 该函数将被评测库调用恰好 $Q$ 次。\n\t- $X$： 一个整数表示第一个城市。\n\t- $Y$： 一个整数表示第二个城市。\n\t- 该函数必须返回一个整数，表示根据题目描述中的规则，两辆分别从第 $X$ 个城市与第 $Y$ 个城市出发要到达彼此城市的车，它们的单位汽油容量最大值的最小值。若无法满足题目规则则返回 $−1$。", "inputFormat": "样例评测库将读入以下格式的数据： \n\n```\nN M\nU[0] V[0] W[0]\nU[1] V[1] W[1]\n.\n.\n.\nU[M-1] V[M-1] W[M-1]\nQ\nX[0] Y[0]\nX[1] Y[1]\n.\n.\n.\nX[Q-1] Y[Q-1]\n```", "outputFormat": "对每个 `getMinimumFuelCapacity` 的调用，样例评测库会输出该函数的返回值", "hint": "第一个样例中, $N = 5$，$M = 6$，$U = [0, 0, 1, 1, 1, 2]$，$V = [1, 2, 2, 3, 4, 3]$，$W =\n[4, 4, 1, 2, 10, 3]$，$Q = 3$，$X = [1, 2, 0]$，$Y = [2, 4, 1]$。如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j3x1idy8.png)\n\n评测库初始时将调用 `init(5, 6, [0, 0, 1, 1, 1, 2], [1, 2, 2, 3, 4, 3],[4, 4, 1, 2, 10, 3])`。之后，评测库将进行如下函数调用：\n\n- `getMinimumFuelCapacity(1, 2)`。首先，从第一个城市出发的汽车可以行驶到第三个城市。接着，从第二个城市出发的汽车可以行驶到第一个城市，并且在第三个城市的汽车可以行驶到第二个城市。因此，最大的单位汽油容量为 $3$ （从第三个城市到第二个城市需要花费 $3$ 个单位汽油）。没有其他更优的路线方案，因此该函数应该返回 $3$。\n\n- `getMinimumFuelCapacity(2, 4)`。任何从第四个城市出发或要到达第四个城市的汽车都需要耗费 $10$ 个单位汽油，因此该函数应该返回 $10$。\n\n- `getMinimumFuelCapacity(0, 1)`。该函数应该返回 $4$。\n\n第二个样例中，$N = 3$，$M = 2$，$U = [0, 0]$，$V = [1, 2]$，$W = [5, 5]$，$Q = 1$，$X = [1]$，$Y = [2]$。 如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3df9k1og.png)\n\n评测库初始时将调用 `init(3, 2, [0, 0], [1, 2], [5, 5])`，之后，评测库将进行如下函数调用：\n\n- `getMinimumFuelCapacity(1, 2)`。两辆车无法满足不在同一时间点碰面的要求，所以该函数应该返回 $-1$。\n\n【条件限制】\n\n- $2 \\leq N \\leq 100 000$。\n- $N - 1 \\leq M \\leq 200 000$。\n- $0 \\leq U[i] < V [i] < N$。\n- 任意两个城市间至多存在一条道路直接相连。\n- 任意两个城市经过道路可以互相到达。\n- $1 \\leq W[i] \\leq 10^9$。\n- $1 \\leq Q \\leq 200 000$。\n- $0 \\leq X[j] < Y [j] < N$。\n\n【子任务 $1$（$6$ 分）】\n\n- 每个城市至多是两条道路的一个端点。\n\n【子任务 $2$（$7$ 分）】\n\n- $M = N - 1$。\n- $U[i] = 0$。\n\n【子任务 $3$（$17$ 分）】\n\n- $Q \\leq 5$。\n- $N \\leq 1 000$。\n- $M \\leq 2 000$。\n\n【子任务 $4$（$20$ 分）】\n\n- $Q \\leq 5$。\n\n【子任务 $5$（$23$ 分）】\n\n- $M = N - 1$。\n\n【子任务 $6$（$27$ 分）】\n\n- 无附加限制。\n", "locale": "zh-CN"}}}
{"pid": "P6766", "type": "P", "difficulty": 6, "samples": [["7 400000\n0 1\n0 5\n0 6\n1 2\n1 4\n2 3\n", "3 6 4 5 2 0 1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "APIO", "交互题", "Special Judge", "O2优化"], "title": "[APIO2020] 有趣的旅途", "background": "本题仅支持 C++ 系列语言，提交时**不需要**包含 `fun.h` 头文件，但需要在程序开头声明 `int hoursRequired(int,int)` 以及 `int attractionsBehind(int,int)`。如果您不明白这是什么意思，也可以直接将 `fun.h` 中的内容粘贴到程序的开头。\n\n交互库在程序非正常结束时可能会返回一些奇怪的信息。\n\n如果交互库存在其他问题，请私信 mrsrz。", "description": "雅加达最大的主题公园中有 $N$ 个景点，它们从 $0$ 到 $N -1$ 编号。这些景点由 $N-1$ 条双向道路连接，任意两个景点间经由这些道路将存在唯一一条简单路径。道路从 $0$ 到 $N - 2$ 编号。第 $i$ 条道路连接第 $A[i]$ 个景点与第 $B[i]$ 个景点，经过这条道路需要花费一个小时。为了避免拥塞，每个景点将至多与三条道路相连。\n\n你想寻找一条游玩路线并使得每个景点都被参观一次。你认为从一个景点走到下一个景点时经过太多道路是十分无聊的。为了寻找一条有趣的路线，你打算安排景点的参观顺序，使得参观下一个景点所花费的时间不超过参观之前景点所花费的时间。换句话说，你想找到一个序列 $P[0], P[1],\\dots, P[N - 1]$ 使其包含 $0$ 到 $N - 1$ 中的所有整数恰好一次，并且从第 $P[i]$ 个景点到达第 $P[i + 1]$ 个景点所需的时间不超过从第 $P[i - 1]$ 个景点到达第 $P[i]$ 个景点所需的时间，其中 $0 < i < N - 1$。\n\n你手上没有景点的完整地图，因此你必须向信息中心进行若干次询问才能找到一条有趣路线。你最多能进行 $Q$ 次询问，每次询问需要提供两个参数 $X$ 和 $Y$ ，其中 $0 \\leq X, Y < N$。每次询问是以下任意一种：\n\n- 从第 $X$ 个景点到第 $Y$ 个景点需要花费多少个小时。特别地，若 $X = Y$ 则回答将是 $0$。\n\n- 有多少个景点 $Z$ 满足，当你想从第 $X$ 个景点到达第 $Z$ 个景点时一定会经过第 $Y$ 个景点。第 $Y$ 个景点将会被计算在内，特别地，若 $X = Y$ 则回答将是 $N$。\n\n你必须实现 `createFunTour` 函数：\n\n- `createFunTour(N, Q)` - 该函数将被评测库恰好调用一次。\n\t- $N$：一个整数表示景点的数量。\n\t- $Q$：一个整数表示询问次数的最大值。\n\t- 该函数可以调用以下两个交互函数：\n    \t- `hoursRequired(X, Y)`\n        \t- $X$：一个整数表示第一个景点的编号。\n\t\t\t- $Y$：一个整数表示第二个景点的编号。\n\t\t\t- 该函数将返回一个整数表示从第 $X$ 个景点到第 $Y$ 个景点需要花费的小时数。\n\t\t\t- 如果 $X$ 或 $Y$ 的值不在 $0$ 到 $N - 1$ 的范围内，该测试点将视为答案错误。\n\t\t- `attractionsBehind(X, Y)`\n\t\t\t- $X$：一个整数表示第一个景点的编号。\n            - $Y$：一个整数表示第二个景点的编号。\n\t\t\t- 该函数将返回一个整数表示有多少个景点 $Z$ 满足，当你想从第 $X$ 个景点到达第 $Z$ 个景点时一定会经过第 $Y$ 个景点。\n\t\t\t- 如果 $X$ 或 $Y$ 的值不在 $0$ 到 $N - 1$ 的范围内，该测试点将视为答案错误。\n\t- 该函数必须返回一个长为 $N$ 的整数序列，表示你找到的景点参观顺序。", "inputFormat": "样例评测库将读入以下格式的数据：\n\n```\nN Q\nA[0] B[0]\nA[1] B[1]\n.\n.\n.\nA[N-2] B[N-2]\n```", "outputFormat": "如果 `createFunTour` 正确返回了一个满足题意的序列，并且 `hoursRequired` 和 `attractionsBehind` 的调用次数总和不超过 $Q$，那么样例评测库将会输出 `createFunTour` 得到的序列。其他情况下样例评测库将会输出错误信息", "hint": "在下图的例子中 $N = 7$，$Q = 400 000$，$A = [0, 0, 0, 1, 1, 2]$，$B = [1, 5, 6, 2, 4, 3]$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j8tmoxuo.png)\n\n评测库将调用 `createFunTour(7, 400000)`。\n- 如果你询问 `hoursRequired(3, 5)`，函数将返回 $4$。\n- 如果你询问 `hoursRequired(5, 4)`，函数将返回 $3$。\n- 如果你询问 `attractionsBehind(5, 1)`，函数将返回 $4$。从第五个景点到第一、二、三、四个景点将一定会经过第一个景点。\n- 如果你询问 `attractionsBehind(1, 5)`，函数将返回 $1$。\n- 一个符合要求的返回序列为 $[3, 6, 4, 5, 2, 0, 1]$，到达下一个参观景点所需的时间按顺序分别为 $[4, 3, 3, 3, 2, 1]$。\n\n【条件限制】\n\n- $2 \\leq N \\leq 100 000$。\n- $Q = 400 000$。\n- 任意两个景点间可以通过双向道路互相到达。\n- 每个景点至多连接着三条道路。\n\n【子任务 $1$（$10$ 分）】\n\n- $N \\leq 17$。\n\n【子任务 $2$（$16$ 分）】\n\n- $N \\leq 500$。\n\n【子任务 $3$（$21$ 分）】\n\n- 对所有的 $1 \\leq i < N$，有一条连接着第 $i$ 个景点与第 $\\lfloor \\dfrac{i-1}{2} \\rfloor$\n个景点的双向道路。\n\n【子任务 $4$（$19$ 分）】\n\n存在至少一个景点 $T$ 使得对于所有 $0 \\leq i < N$，`hoursRequired(T, i)` $<30$ 并且存在一个整数区间 $[L[i], R[i]](0 \\leq L[i] \\leq i \\leq R[i] < N)$ 满足下列条件：\n\n- 从第 $T$ 个景点到达第 $j$ 个景点必须经过第 $i$ 个景点当且仅当 $L[i] \\leq j \\leq R[i]$。\n\n- 若 $L[i] < i$，则恰有一个景点 $X$ 满足：\n\t- $L[i] \\leq X < i$。\n\t- 有一条连接第 $i$ 个景点与第 $X$ 个景点的道路。   \n- 若 $i < R[i]$，则恰有一个景点 $Y$ 满足：\n\t- $i < Y \\leq R[i]$。\n\t- 有一条连接第 $i$ 个景点与第 $Y$ 个景点的道路。\n\n【子任务 $5$（$34$ 分）】\n- 无附加限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[APIO2020] 有趣的旅途", "background": "本题仅支持 C++ 系列语言，提交时**不需要**包含 `fun.h` 头文件，但需要在程序开头声明 `int hoursRequired(int,int)` 以及 `int attractionsBehind(int,int)`。如果您不明白这是什么意思，也可以直接将 `fun.h` 中的内容粘贴到程序的开头。\n\n交互库在程序非正常结束时可能会返回一些奇怪的信息。\n\n如果交互库存在其他问题，请私信 mrsrz。", "description": "雅加达最大的主题公园中有 $N$ 个景点，它们从 $0$ 到 $N -1$ 编号。这些景点由 $N-1$ 条双向道路连接，任意两个景点间经由这些道路将存在唯一一条简单路径。道路从 $0$ 到 $N - 2$ 编号。第 $i$ 条道路连接第 $A[i]$ 个景点与第 $B[i]$ 个景点，经过这条道路需要花费一个小时。为了避免拥塞，每个景点将至多与三条道路相连。\n\n你想寻找一条游玩路线并使得每个景点都被参观一次。你认为从一个景点走到下一个景点时经过太多道路是十分无聊的。为了寻找一条有趣的路线，你打算安排景点的参观顺序，使得参观下一个景点所花费的时间不超过参观之前景点所花费的时间。换句话说，你想找到一个序列 $P[0], P[1],\\dots, P[N - 1]$ 使其包含 $0$ 到 $N - 1$ 中的所有整数恰好一次，并且从第 $P[i]$ 个景点到达第 $P[i + 1]$ 个景点所需的时间不超过从第 $P[i - 1]$ 个景点到达第 $P[i]$ 个景点所需的时间，其中 $0 < i < N - 1$。\n\n你手上没有景点的完整地图，因此你必须向信息中心进行若干次询问才能找到一条有趣路线。你最多能进行 $Q$ 次询问，每次询问需要提供两个参数 $X$ 和 $Y$ ，其中 $0 \\leq X, Y < N$。每次询问是以下任意一种：\n\n- 从第 $X$ 个景点到第 $Y$ 个景点需要花费多少个小时。特别地，若 $X = Y$ 则回答将是 $0$。\n\n- 有多少个景点 $Z$ 满足，当你想从第 $X$ 个景点到达第 $Z$ 个景点时一定会经过第 $Y$ 个景点。第 $Y$ 个景点将会被计算在内，特别地，若 $X = Y$ 则回答将是 $N$。\n\n你必须实现 `createFunTour` 函数：\n\n- `createFunTour(N, Q)` - 该函数将被评测库恰好调用一次。\n\t- $N$：一个整数表示景点的数量。\n\t- $Q$：一个整数表示询问次数的最大值。\n\t- 该函数可以调用以下两个交互函数：\n    \t- `hoursRequired(X, Y)`\n        \t- $X$：一个整数表示第一个景点的编号。\n\t\t\t- $Y$：一个整数表示第二个景点的编号。\n\t\t\t- 该函数将返回一个整数表示从第 $X$ 个景点到第 $Y$ 个景点需要花费的小时数。\n\t\t\t- 如果 $X$ 或 $Y$ 的值不在 $0$ 到 $N - 1$ 的范围内，该测试点将视为答案错误。\n\t\t- `attractionsBehind(X, Y)`\n\t\t\t- $X$：一个整数表示第一个景点的编号。\n            - $Y$：一个整数表示第二个景点的编号。\n\t\t\t- 该函数将返回一个整数表示有多少个景点 $Z$ 满足，当你想从第 $X$ 个景点到达第 $Z$ 个景点时一定会经过第 $Y$ 个景点。\n\t\t\t- 如果 $X$ 或 $Y$ 的值不在 $0$ 到 $N - 1$ 的范围内，该测试点将视为答案错误。\n\t- 该函数必须返回一个长为 $N$ 的整数序列，表示你找到的景点参观顺序。", "inputFormat": "样例评测库将读入以下格式的数据：\n\n```\nN Q\nA[0] B[0]\nA[1] B[1]\n.\n.\n.\nA[N-2] B[N-2]\n```", "outputFormat": "如果 `createFunTour` 正确返回了一个满足题意的序列，并且 `hoursRequired` 和 `attractionsBehind` 的调用次数总和不超过 $Q$，那么样例评测库将会输出 `createFunTour` 得到的序列。其他情况下样例评测库将会输出错误信息", "hint": "在下图的例子中 $N = 7$，$Q = 400 000$，$A = [0, 0, 0, 1, 1, 2]$，$B = [1, 5, 6, 2, 4, 3]$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j8tmoxuo.png)\n\n评测库将调用 `createFunTour(7, 400000)`。\n- 如果你询问 `hoursRequired(3, 5)`，函数将返回 $4$。\n- 如果你询问 `hoursRequired(5, 4)`，函数将返回 $3$。\n- 如果你询问 `attractionsBehind(5, 1)`，函数将返回 $4$。从第五个景点到第一、二、三、四个景点将一定会经过第一个景点。\n- 如果你询问 `attractionsBehind(1, 5)`，函数将返回 $1$。\n- 一个符合要求的返回序列为 $[3, 6, 4, 5, 2, 0, 1]$，到达下一个参观景点所需的时间按顺序分别为 $[4, 3, 3, 3, 2, 1]$。\n\n【条件限制】\n\n- $2 \\leq N \\leq 100 000$。\n- $Q = 400 000$。\n- 任意两个景点间可以通过双向道路互相到达。\n- 每个景点至多连接着三条道路。\n\n【子任务 $1$（$10$ 分）】\n\n- $N \\leq 17$。\n\n【子任务 $2$（$16$ 分）】\n\n- $N \\leq 500$。\n\n【子任务 $3$（$21$ 分）】\n\n- 对所有的 $1 \\leq i < N$，有一条连接着第 $i$ 个景点与第 $\\lfloor \\dfrac{i-1}{2} \\rfloor$\n个景点的双向道路。\n\n【子任务 $4$（$19$ 分）】\n\n存在至少一个景点 $T$ 使得对于所有 $0 \\leq i < N$，`hoursRequired(T, i)` $<30$ 并且存在一个整数区间 $[L[i], R[i]](0 \\leq L[i] \\leq i \\leq R[i] < N)$ 满足下列条件：\n\n- 从第 $T$ 个景点到达第 $j$ 个景点必须经过第 $i$ 个景点当且仅当 $L[i] \\leq j \\leq R[i]$。\n\n- 若 $L[i] < i$，则恰有一个景点 $X$ 满足：\n\t- $L[i] \\leq X < i$。\n\t- 有一条连接第 $i$ 个景点与第 $X$ 个景点的道路。   \n- 若 $i < R[i]$，则恰有一个景点 $Y$ 满足：\n\t- $i < Y \\leq R[i]$。\n\t- 有一条连接第 $i$ 个景点与第 $Y$ 个景点的道路。\n\n【子任务 $5$（$34$ 分）】\n- 无附加限制。", "locale": "zh-CN"}}}
{"pid": "P6767", "type": "P", "difficulty": 4, "samples": [["5 1 4 3 6", "12"], ["22 2 3 10 14", "31"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2012", "2020", "枚举", "最大公约数 gcd", "BalticOI（波罗的海）"], "title": "[BalticOI 2012/2020] 玫瑰 (Day0)", "background": "因为特殊原因，本题目另外 $24$ 组数据请在 [这里](https://www.luogu.com.cn/problem/U127462) 提交。\n\nValentine 是人赢。", "description": "现在 Valentine 要给他的 $N$ 个妹子买玫瑰花，现在 Valentine 面前有两家店，每一家店有无数朵玫瑰花，但是他们按束卖。第一家店一束花里有 $A$ 朵，每一束花要用 $B$ 块钱。第二家店一束花里有 $C$ 朵，每一束花要用 $D$ 块钱。\n\n求 Valentine 至少买 $N$ 朵花最少需要花多少钱。\n\n至少可以这么理解，假如 $M>N$，但是买 $M$ 朵花的钱比买 $N$ 朵花的少，Valentine 就会买 $M$ 朵花，并把多出来的花给其他妹子，没错，Valentine 很花心。", "inputFormat": "一行五个整数 $N,A,B,C,D$，意义见题目所述。", "outputFormat": "一行一个整数代表最小花费。", "hint": "#### 样例说明\n\n对于样例 $1$，Valentine 可以选择在第二家店买 $2$ 束花。\n\n对于样例 $2$，Valentine 可以选择在第一家店买 $1$ 束花，在第二家店买 $2$ 束花。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（20 pts）：$N,A,B,C,D \\le 1000$。\n- Subtask 2（80 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^{15}$，$1 \\le A,B,C,D \\le 10^5$，保证答案不超过 $10^{18}$。\n\n#### 说明\n\n翻译自 [BalticOI 2020 Day0 B Roses](http://www.boi2020.lv/data/tasks/en/day0/roses.pdf)。\n\n与 BalticOI 2012 Day0 A 内容一致。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2012/2020] 玫瑰 (Day0)", "background": "因为特殊原因，本题目另外 $24$ 组数据请在 [这里](https://www.luogu.com.cn/problem/U127462) 提交。\n\nValentine 是人赢。", "description": "现在 Valentine 要给他的 $N$ 个妹子买玫瑰花，现在 Valentine 面前有两家店，每一家店有无数朵玫瑰花，但是他们按束卖。第一家店一束花里有 $A$ 朵，每一束花要用 $B$ 块钱。第二家店一束花里有 $C$ 朵，每一束花要用 $D$ 块钱。\n\n求 Valentine 至少买 $N$ 朵花最少需要花多少钱。\n\n至少可以这么理解，假如 $M>N$，但是买 $M$ 朵花的钱比买 $N$ 朵花的少，Valentine 就会买 $M$ 朵花，并把多出来的花给其他妹子，没错，Valentine 很花心。", "inputFormat": "一行五个整数 $N,A,B,C,D$，意义见题目所述。", "outputFormat": "一行一个整数代表最小花费。", "hint": "#### 样例说明\n\n对于样例 $1$，Valentine 可以选择在第二家店买 $2$ 束花。\n\n对于样例 $2$，Valentine 可以选择在第一家店买 $1$ 束花，在第二家店买 $2$ 束花。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（20 pts）：$N,A,B,C,D \\le 1000$。\n- Subtask 2（80 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^{15}$，$1 \\le A,B,C,D \\le 10^5$，保证答案不超过 $10^{18}$。\n\n#### 说明\n\n翻译自 [BalticOI 2020 Day0 B Roses](http://www.boi2020.lv/data/tasks/en/day0/roses.pdf)。\n\n与 BalticOI 2012 Day0 A 内容一致。", "locale": "zh-CN"}}}
{"pid": "P6768", "type": "P", "difficulty": 5, "samples": [["3 4\n7 2\n0 4\n2 6\n1 2 40\n3 2 70\n2 3 90\n1 3 120\n", "110"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2005", "二分", "USACO", "最短路"], "title": "[USACO05MAR] Ombrophobic Bovines 发抖的牛", "background": "", "description": "FJ 的牛们非常害怕淋雨，那会使他们瑟瑟发抖。他们打算安装一个下雨报警器，并且安排了一个撤退计划。他们需要计算最少的让所有牛进入雨棚的时间。  \n牛们在农场的 $F$ 个田地上吃草。有 $P$ 条双向路连接着这些田地。路很宽，无限量的牛可以通过。田地上有雨棚，雨棚有一定的容量，牛们可以瞬间从这块田地进入这块田地上的雨棚。  \n请计算最少的时间，让每只牛都进入雨棚。", "inputFormat": "第 $1$ 行：两个整数 $F$ 和 $P$；  \n第 $2$ 到 $F+1$ 行：第 $i+1$ 行有两个整数描述第 $i$ 个田地，第一个表示田地上的牛数，第二个表示田地上的雨棚容量。两个整数都在 $0$ 和 $1000$ 之间。  \n第 $F+2$ 到 $F+P+1$ 行：每行三个整数描述一条路，分别是起点终点，及通过这条路所需的时间（在 $1$ 和 $10^9$ 之间）。", "outputFormat": "一个整数，表示最少的时间。如果无法使牛们全部进入雨棚，输出 $-1$。", "hint": "对于 $100\\%$ 的数据：$1\\le F\\le 200$，$1\\le P\\le 1500$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO05MAR] Ombrophobic Bovines 发抖的牛", "background": "", "description": "FJ 的牛们非常害怕淋雨，那会使他们瑟瑟发抖。他们打算安装一个下雨报警器，并且安排了一个撤退计划。他们需要计算最少的让所有牛进入雨棚的时间。  \n牛们在农场的 $F$ 个田地上吃草。有 $P$ 条双向路连接着这些田地。路很宽，无限量的牛可以通过。田地上有雨棚，雨棚有一定的容量，牛们可以瞬间从这块田地进入这块田地上的雨棚。  \n请计算最少的时间，让每只牛都进入雨棚。", "inputFormat": "第 $1$ 行：两个整数 $F$ 和 $P$；  \n第 $2$ 到 $F+1$ 行：第 $i+1$ 行有两个整数描述第 $i$ 个田地，第一个表示田地上的牛数，第二个表示田地上的雨棚容量。两个整数都在 $0$ 和 $1000$ 之间。  \n第 $F+2$ 到 $F+P+1$ 行：每行三个整数描述一条路，分别是起点终点，及通过这条路所需的时间（在 $1$ 和 $10^9$ 之间）。", "outputFormat": "一个整数，表示最少的时间。如果无法使牛们全部进入雨棚，输出 $-1$。", "hint": "对于 $100\\%$ 的数据：$1\\le F\\le 200$，$1\\le P\\le 1500$。", "locale": "zh-CN"}}}
