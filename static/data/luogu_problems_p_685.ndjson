{"pid": "P14886", "type": "P", "difficulty": 3, "samples": [["3\n3 4\n1 5\n7 7", "3\n0\ninfty"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "数论"], "title": "Left and Right", "background": "", "description": "Yuki 有两个整数 $l$ 和 $r$。她希望你求解一个巨大的不定方程，可是那实在是太巨大了！因此，Yuki 转而想要考你：有多少个正整数 $x$ 不能被表示为若干个在 $[l, r]$ 内的正整数和？特殊地，如果答案有无穷多个，输出 `infty`。", "inputFormat": "**本题单个测试点内有多组测试数据**。\n\n第一行，一个整数 $t$（$1 \\leq t \\leq 10^5$），描述数据组数。对于每组数据：\n\n- 仅一行，两个整数 $l,r$（$1 \\leq l \\leq r \\leq 10^9$）。", "outputFormat": "对于每组数据：如果答案是有限的，输出仅一行一个整数，表示答案；否则仅输出一个字符串 `infty` 即可。", "hint": "#### 样例解释\n\n对于第一组样例，只有 $x$ 取 $1, 2, 5$ 时不能被表示。\n\n对于第三组样例，显然只要 $7 \\nmid x$，就无法被表示。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Left and Right", "background": "", "description": "Yuki 有两个整数 $l$ 和 $r$。她希望你求解一个巨大的不定方程，可是那实在是太巨大了！因此，Yuki 转而想要考你：有多少个正整数 $x$ 不能被表示为若干个在 $[l, r]$ 内的正整数和？特殊地，如果答案有无穷多个，输出 `infty`。", "inputFormat": "**本题单个测试点内有多组测试数据**。\n\n第一行，一个整数 $t$（$1 \\leq t \\leq 10^5$），描述数据组数。对于每组数据：\n\n- 仅一行，两个整数 $l,r$（$1 \\leq l \\leq r \\leq 10^9$）。", "outputFormat": "对于每组数据：如果答案是有限的，输出仅一行一个整数，表示答案；否则仅输出一个字符串 `infty` 即可。", "hint": "#### 样例解释\n\n对于第一组样例，只有 $x$ 取 $1, 2, 5$ 时不能被表示。\n\n对于第三组样例，显然只要 $7 \\nmid x$，就无法被表示。", "locale": "zh-CN"}}}
{"pid": "P14887", "type": "P", "difficulty": 1, "samples": [["5\n2 3\n1 5\n3 3\n2 6 1\n4 5\n5 5 5 5\n5 1000000000\n1000000000 1000000000 1000000000 1000000000 1000000000\n10 100\n97 135 103 130 147 89 93 215 175 261", "4\n5\n5\n1000000000\n219"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心"], "title": "Cafeforces", "background": "", "description": "Cafeforces 是一个大型线上比赛平台，其中每位用户有一个评分，会随着每场比赛的表现分上下起伏。\n\n具体地，如果一个账号在一场比赛前的评分为 $x$，这场比赛的表现分为 $y$，那么赛后该账号的评分会变为 $\\lceil{\\frac{x+y}{2}}\\rceil$，其中 $\\lceil a\\rceil$ 表示不小于 $a$ 的最小整数。\n\n你有两个账号，初始评分都为 $s$，并且决定要参加接下来的 $n$ 场比赛（不能选择不参加）。\n\n通过预测能力，你提前知道了接下来每一场比赛中你的表现分，其中第 $i$ 场的表现分为 $p_i$。\n\n请合理安排每场比赛要参加的账号，最大化 $n$ 场比赛后两个账号评分的较大值，并求出该结果。", "inputFormat": "**本题单个测试点内有多组测试数据**。\n\n第一行，一个整数 $t$（$1 \\leq t \\leq 2\\times10^5$），描述数据组数。对于每组数据：\n\n- 第一行，两个整数 $n,s$（$1 \\le n \\le 2\\times10^5$，$0 \\le s \\le 10^9$）。\n- 第二行，$n$ 个整数 $p_1,p_2,\\dots,p_n$（$0 \\le p_i \\le 10^9$）。\n\n保证对于单个测试点，所有 $n$ 的和不超过 $2\\times 10^5$。", "outputFormat": "对于每组测试数据，输出一行一个整数表示答案。", "hint": "#### 样例解释\n\n对于第一组数据，可以使用第一个账号参加第一场比赛，第二个账号参加第二场比赛，此时两个账号的评分分别为 $2$ 和 $4$，较大值为 $4$，可以证明没有更优的方案。\n\n对于第二组数据，可以使用第一个账号参加第一、二场比赛，第二个账号参加第三场比赛。此时两个账号的评分分别为 $5$ 和 $2$，较大值为 $5$。\n\n对于第三组数据，无论选择什么方案，两个账号的评分都不会改变，因此答案为 $5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Cafeforces", "background": "", "description": "Cafeforces 是一个大型线上比赛平台，其中每位用户有一个评分，会随着每场比赛的表现分上下起伏。\n\n具体地，如果一个账号在一场比赛前的评分为 $x$，这场比赛的表现分为 $y$，那么赛后该账号的评分会变为 $\\lceil{\\frac{x+y}{2}}\\rceil$，其中 $\\lceil a\\rceil$ 表示不小于 $a$ 的最小整数。\n\n你有两个账号，初始评分都为 $s$，并且决定要参加接下来的 $n$ 场比赛（不能选择不参加）。\n\n通过预测能力，你提前知道了接下来每一场比赛中你的表现分，其中第 $i$ 场的表现分为 $p_i$。\n\n请合理安排每场比赛要参加的账号，最大化 $n$ 场比赛后两个账号评分的较大值，并求出该结果。", "inputFormat": "**本题单个测试点内有多组测试数据**。\n\n第一行，一个整数 $t$（$1 \\leq t \\leq 2\\times10^5$），描述数据组数。对于每组数据：\n\n- 第一行，两个整数 $n,s$（$1 \\le n \\le 2\\times10^5$，$0 \\le s \\le 10^9$）。\n- 第二行，$n$ 个整数 $p_1,p_2,\\dots,p_n$（$0 \\le p_i \\le 10^9$）。\n\n保证对于单个测试点，所有 $n$ 的和不超过 $2\\times 10^5$。", "outputFormat": "对于每组测试数据，输出一行一个整数表示答案。", "hint": "#### 样例解释\n\n对于第一组数据，可以使用第一个账号参加第一场比赛，第二个账号参加第二场比赛，此时两个账号的评分分别为 $2$ 和 $4$，较大值为 $4$，可以证明没有更优的方案。\n\n对于第二组数据，可以使用第一个账号参加第一、二场比赛，第二个账号参加第三场比赛。此时两个账号的评分分别为 $5$ 和 $2$，较大值为 $5$。\n\n对于第三组数据，无论选择什么方案，两个账号的评分都不会改变，因此答案为 $5$。", "locale": "zh-CN"}}}
{"pid": "P14888", "type": "P", "difficulty": 4, "samples": [["6\n3\n2 1\n3 2\n4\n1 2\n3 2\n2 4\n7\n7 3\n6 5\n3 1\n1 2\n1 5\n5 4\n9\n4 5\n5 9\n2 8\n5 1\n3 8\n8 9\n8 6\n6 7\n10\n3 8\n3 2\n9 7\n4 3\n6 1\n5 2\n3 6\n3 7\n6 10\n10\n4 6\n3 7\n10 8\n3 5\n2 8\n6 10\n1 2\n5 9\n8 9", "1\n3\n12\n26\n28\n36"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["树论", "Ad-hoc"], "title": "Pair Counting", "background": "", "description": "给定一棵包含 $n$ 个结点的无根树。\n\n初始时，你需要确定一个结点为根；接下来，你可以进行任意次操作。\n\n每次操作，你需要依次执行下面的步骤：\n\n- 选择一个正整数 $k$。\n- 标记当前每一棵树中到其根距离为 $k$ 的结点，删掉这些结点与其父亲的连边，形成若干棵新树。\n- 令这些被标记的结点为对应新树的根。\n\n其中，点 $u$ 到点 $v$ 的距离等于两点之间简单路径上边的数量。\n\n对于点对 $(x,y)$，如果有一种钦定根与操作的方案，能使得结点 $x$ 与结点 $y$ 在同一次操作中被标记，我们称该二元组是**优美的**。\n\n你需要求出满足 $1\\le x<y\\le n$ 的点对 $(x,y)$ 中，有多少个点对是**优美的**。", "inputFormat": "**本题有多组测试数据。**\n\n输入的第一行一个整数 $T$ 表示测试数据组数（$1\\le T\\le 10^5$）。\n\n对于每组测试数据，\n\n- 第一行包含一个整数 $n$（$3\\le n\\le 10^6$）。\n\n- 接下来 $n−1$ 行，第 $i$ 行包含两个整数 $u_i,v_i$，表示树上编号为 $i$ 的边连接结点 $u_i$ 和 $v_i$。\n\n保证给出的所有边构成一棵树；保证对于单个测试点，所有 $n$ 的和不超过 $10^6$。", "outputFormat": "对于每组测试数据，输出一行一个整数表示答案。", "hint": "#### 样例解释\n\n对于第一组数据，优美的点对只有 $(1,3)$。\n\n对于第二组数据，优美的点对有 $(1,3)$、$(1,4)$ 和 $(3,4)$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Pair Counting", "background": "", "description": "给定一棵包含 $n$ 个结点的无根树。\n\n初始时，你需要确定一个结点为根；接下来，你可以进行任意次操作。\n\n每次操作，你需要依次执行下面的步骤：\n\n- 选择一个正整数 $k$。\n- 标记当前每一棵树中到其根距离为 $k$ 的结点，删掉这些结点与其父亲的连边，形成若干棵新树。\n- 令这些被标记的结点为对应新树的根。\n\n其中，点 $u$ 到点 $v$ 的距离等于两点之间简单路径上边的数量。\n\n对于点对 $(x,y)$，如果有一种钦定根与操作的方案，能使得结点 $x$ 与结点 $y$ 在同一次操作中被标记，我们称该二元组是**优美的**。\n\n你需要求出满足 $1\\le x<y\\le n$ 的点对 $(x,y)$ 中，有多少个点对是**优美的**。", "inputFormat": "**本题有多组测试数据。**\n\n输入的第一行一个整数 $T$ 表示测试数据组数（$1\\le T\\le 10^5$）。\n\n对于每组测试数据，\n\n- 第一行包含一个整数 $n$（$3\\le n\\le 10^6$）。\n\n- 接下来 $n−1$ 行，第 $i$ 行包含两个整数 $u_i,v_i$，表示树上编号为 $i$ 的边连接结点 $u_i$ 和 $v_i$。\n\n保证给出的所有边构成一棵树；保证对于单个测试点，所有 $n$ 的和不超过 $10^6$。", "outputFormat": "对于每组测试数据，输出一行一个整数表示答案。", "hint": "#### 样例解释\n\n对于第一组数据，优美的点对只有 $(1,3)$。\n\n对于第二组数据，优美的点对有 $(1,3)$、$(1,4)$ 和 $(3,4)$。", "locale": "zh-CN"}}}
{"pid": "P14889", "type": "P", "difficulty": 6, "samples": [["10 10 10\n9 10\n1 5\n3 9\n8 9\n4 9\n7 9\n5 4\n2 10\n6 7\n4 5\n3 2\n3 1\n1 10 2\n1 5 1\n1 4 5\n5 4\n2 9\n1 9 3\n2 9", "YES\nNO\nNO\nNO\nNO\nNO\nYES\nNO\nNO\nNO\nNO"], ["10 4 10\n8 9\n2 4\n10 5\n9 4\n3 2\n1 2\n5 4\n6 4\n7 8\n1 2 1\n1 2 1\n5 10\n1 5 4\n1 10 5\n3 4\n1 5 4\n5 2\n1 5 10\n1 4 5", "YES\nNO\nYES\nNO\nNO\nYES\nNO\nYES\nNO\nNO\nNO"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "哈希 hashing"], "title": "Key Point", "background": "", "description": "给定一个包含 $n$ 个结点和 $\\boldsymbol{n-1}$ **条有向边**的有向图 $G$ 和一个不大于 $n$ 的正整数 $k$，保证图 $G$ 中的所有边在视为无向边后图连通（即形成一棵树）。\n\n现有 $q$ 次操作。操作共五种，参数分别如下：\n\n- `1 x y`：翻转结点 $x$ 和结点 $y$ 之间边的方向，保证结点 $x$ 和结点 $y$ 之间存在一条边；\n- `2 a`：将结点 $a$ 的所有入边翻转方向；\n- `3 b`：将结点 $b$ 的所有出边翻转方向；\n- `4 c`：将结点 $c$ 的所有入边和出边翻转方向；\n- `5 p`：将 $k$ 的值修改为 $p$。\n\n其中，结点 $u$ 的入边表示以结点 $u$ 为终点的有向边，结点 $u$ 的出边表示以结点 $u$ 为起点的有向边。\n\n你需要维护这个有向图，并在首次操作前和每次操作后，判断是否所有除结点 $k$ 以外的结点都能通过当前的有向边到达结点 $k$，若是则输出 `YES`，否则输出 `NO`。", "inputFormat": "第一行输入三个整数 $n,k,q$（$2 \\le n \\le 10^6$，$0 \\le q \\le 10^6$，$1 \\le k \\le n$）。\n\n接下来 $n-1$ 行，每行输入两个正整数 $u_i,v_i$，表示结点 $u_i$ 和结点 $v_i$ 之间存在一条由结点 $u_i$ 至结点 $v_i$ 的**有向边**（$1 \\le u_i,v_i \\le n$）。\n\n接下来 $q$ 行，输入每行 $2\\sim3$ 个正整数，表示一次操作，含义及格式见「题目描述」（$1 \\le x,y,a,b,c,p \\le n$）。\n\n保证图 $G$ 中的所有边在视为无向边后图连通（即形成一棵树），保证在进行第一种操作时结点 $x$ 和结点 $y$ 之间存在一条边。", "outputFormat": "共 $q+1$ 行，在首次操作前和每次操作后，判断是否所有除结点 $k$ 以外的结点都能通过当前的有向边到达结点 $k$，若是则输出 `YES`，反之输出 `NO`。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Key Point", "background": "", "description": "给定一个包含 $n$ 个结点和 $\\boldsymbol{n-1}$ **条有向边**的有向图 $G$ 和一个不大于 $n$ 的正整数 $k$，保证图 $G$ 中的所有边在视为无向边后图连通（即形成一棵树）。\n\n现有 $q$ 次操作。操作共五种，参数分别如下：\n\n- `1 x y`：翻转结点 $x$ 和结点 $y$ 之间边的方向，保证结点 $x$ 和结点 $y$ 之间存在一条边；\n- `2 a`：将结点 $a$ 的所有入边翻转方向；\n- `3 b`：将结点 $b$ 的所有出边翻转方向；\n- `4 c`：将结点 $c$ 的所有入边和出边翻转方向；\n- `5 p`：将 $k$ 的值修改为 $p$。\n\n其中，结点 $u$ 的入边表示以结点 $u$ 为终点的有向边，结点 $u$ 的出边表示以结点 $u$ 为起点的有向边。\n\n你需要维护这个有向图，并在首次操作前和每次操作后，判断是否所有除结点 $k$ 以外的结点都能通过当前的有向边到达结点 $k$，若是则输出 `YES`，否则输出 `NO`。", "inputFormat": "第一行输入三个整数 $n,k,q$（$2 \\le n \\le 10^6$，$0 \\le q \\le 10^6$，$1 \\le k \\le n$）。\n\n接下来 $n-1$ 行，每行输入两个正整数 $u_i,v_i$，表示结点 $u_i$ 和结点 $v_i$ 之间存在一条由结点 $u_i$ 至结点 $v_i$ 的**有向边**（$1 \\le u_i,v_i \\le n$）。\n\n接下来 $q$ 行，输入每行 $2\\sim3$ 个正整数，表示一次操作，含义及格式见「题目描述」（$1 \\le x,y,a,b,c,p \\le n$）。\n\n保证图 $G$ 中的所有边在视为无向边后图连通（即形成一棵树），保证在进行第一种操作时结点 $x$ 和结点 $y$ 之间存在一条边。", "outputFormat": "共 $q+1$ 行，在首次操作前和每次操作后，判断是否所有除结点 $k$ 以外的结点都能通过当前的有向边到达结点 $k$，若是则输出 `YES`，反之输出 `NO`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14890", "type": "P", "difficulty": 4, "samples": [["2\n5 2\n-1 1 1 -1 -1\n8 100\n1 1 -1 -1 -1 -1 1 -1", "5\n16"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP"], "title": "Yummy", "background": "", "description": "给定一个长度为 $n$ 的序列 $s$ 和一个正整数 $k$，其中 $s_i \\in \\{-1,1\\}$，即 $s_i$ 为 $-1$ 或 $1$。\n\n我们称一个长度为 $n$ 的序列 $v$ 是 Yummy 的，当且仅当序列 $v$ 中的每个元素**均为不大于 $\\boldsymbol{k}$ 的非负整数**，且满足：\n\n$$\n\\sum_{i=1}^n s_i\\cdot v_i\\cdot k^i=0\n$$\n\n即对于所有不大于 $n$ 的正整数 $i$，$s_i \\cdot v_i \\cdot k^i$ 之和为 $0$。\n\n你需要求出不同的长度为 $n$ 的 Yummy 的序列 $v$ 的数量。其中，我们称两个长度均为 $m$ 的序列 $a,b$ 是不同的，当且仅当存在至少一个不大于 $m$ 的正整数 $i$ 满足 $a_i\\ne b_i$。\n\n由于答案可能很大，所以你只需要求出答案对 $998244353$ 取模的结果。", "inputFormat": "**本题有多组测试数据**。\n\n输入文件的第一行输入一个正整数 $T$（$1 \\leq T \\leq 10^4$） 表示测试数据组数。\n\n接下来，对于每一组测试数据：\n\n第一行输入两个正整数 $n$（$2 \\leq n \\leq 5 \\times 10^5$）和 $k$（$2 \\leq k \\leq 10^9$）。\n\n第二行输入 $n$ 个整数 $s_i$（$s_i \\in \\{-1,1\\}$）。\n\n保证对于单个测试点，所有 $n$ 的和不超过 $5\\times 10^5$。", "outputFormat": "对于每组测试数据，输出一行一个正整数表示答案对 $998244353$ 取模的结果。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Yummy", "background": "", "description": "给定一个长度为 $n$ 的序列 $s$ 和一个正整数 $k$，其中 $s_i \\in \\{-1,1\\}$，即 $s_i$ 为 $-1$ 或 $1$。\n\n我们称一个长度为 $n$ 的序列 $v$ 是 Yummy 的，当且仅当序列 $v$ 中的每个元素**均为不大于 $\\boldsymbol{k}$ 的非负整数**，且满足：\n\n$$\n\\sum_{i=1}^n s_i\\cdot v_i\\cdot k^i=0\n$$\n\n即对于所有不大于 $n$ 的正整数 $i$，$s_i \\cdot v_i \\cdot k^i$ 之和为 $0$。\n\n你需要求出不同的长度为 $n$ 的 Yummy 的序列 $v$ 的数量。其中，我们称两个长度均为 $m$ 的序列 $a,b$ 是不同的，当且仅当存在至少一个不大于 $m$ 的正整数 $i$ 满足 $a_i\\ne b_i$。\n\n由于答案可能很大，所以你只需要求出答案对 $998244353$ 取模的结果。", "inputFormat": "**本题有多组测试数据**。\n\n输入文件的第一行输入一个正整数 $T$（$1 \\leq T \\leq 10^4$） 表示测试数据组数。\n\n接下来，对于每一组测试数据：\n\n第一行输入两个正整数 $n$（$2 \\leq n \\leq 5 \\times 10^5$）和 $k$（$2 \\leq k \\leq 10^9$）。\n\n第二行输入 $n$ 个整数 $s_i$（$s_i \\in \\{-1,1\\}$）。\n\n保证对于单个测试点，所有 $n$ 的和不超过 $5\\times 10^5$。", "outputFormat": "对于每组测试数据，输出一行一个正整数表示答案对 $998244353$ 取模的结果。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14891", "type": "P", "difficulty": 5, "samples": [["5\n1 1 2 2 5", "0\n1\n2\n3\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["并查集", "Ad-hoc"], "title": "Trink", "background": "", "description": "给定一棵以 $1$ 为根结点的有根树 $T$，儿子之间有左右顺序。初始时，$T$ 只有一个结点 $1$。\n\n接下来有 $n$ 次操作，第 $i$ 次操作给出 $f_i$，你需要新建一个结点 $i+1$ 作为 $f_i$ 最右侧的儿子结点，加入树 $T$。每次操作后，你需要回答以下问题：\n\n---\n\n对一棵树，定义「Trink 变换」为：\n\n-  **同时**考虑所有**不为** $1$ 的结点 $u$，如果 $u$ 不是 $u$ 父亲从左向右的第一个儿子，则把 $u$ 的父亲改为所有在 $u$ 左侧的兄弟中最靠右的一个。\n\n问：对 $T$ 最少执行多少次 Trink 变换后，树 $T$ 满足，对树 $T$ 继续进行一次 Trink 变换后，树 $T$ 的形态保持不变。\n\n---\n\n询问之间互相独立。也就是说，并不会真的对原树进行「Trink 变换」。", "inputFormat": "第一行，一个整数 $n$（$1 \\leq n \\leq 10^6$）。\n\n第二行，$n$ 个整数，依次表示 $f_1, \\ldots, f_n$（$1 \\leq f_i \\leq i$）。\n", "outputFormat": "输出 $n$ 行，第 $i$ 行包含一个整数，表示第 $i$ 次操作后的答案。", "hint": "#### 样例解释\n\n对于最后一次询问，以下展示了第 $k\\ (0 \\leq k \\leq 4)$ 次操作后，树 $T$ 的形态：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i8rzjnpk.png)\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Trink", "background": "", "description": "给定一棵以 $1$ 为根结点的有根树 $T$，儿子之间有左右顺序。初始时，$T$ 只有一个结点 $1$。\n\n接下来有 $n$ 次操作，第 $i$ 次操作给出 $f_i$，你需要新建一个结点 $i+1$ 作为 $f_i$ 最右侧的儿子结点，加入树 $T$。每次操作后，你需要回答以下问题：\n\n---\n\n对一棵树，定义「Trink 变换」为：\n\n-  **同时**考虑所有**不为** $1$ 的结点 $u$，如果 $u$ 不是 $u$ 父亲从左向右的第一个儿子，则把 $u$ 的父亲改为所有在 $u$ 左侧的兄弟中最靠右的一个。\n\n问：对 $T$ 最少执行多少次 Trink 变换后，树 $T$ 满足，对树 $T$ 继续进行一次 Trink 变换后，树 $T$ 的形态保持不变。\n\n---\n\n询问之间互相独立。也就是说，并不会真的对原树进行「Trink 变换」。", "inputFormat": "第一行，一个整数 $n$（$1 \\leq n \\leq 10^6$）。\n\n第二行，$n$ 个整数，依次表示 $f_1, \\ldots, f_n$（$1 \\leq f_i \\leq i$）。\n", "outputFormat": "输出 $n$ 行，第 $i$ 行包含一个整数，表示第 $i$ 次操作后的答案。", "hint": "#### 样例解释\n\n对于最后一次询问，以下展示了第 $k\\ (0 \\leq k \\leq 4)$ 次操作后，树 $T$ 的形态：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i8rzjnpk.png)\n", "locale": "zh-CN"}}}
{"pid": "P14892", "type": "P", "difficulty": 2, "samples": [["3\n2 4 2\n3 10\n5 2 1\n1 2 2 1 1\n5 3 8\n0 1 2 3 2", "2\n2\n9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心"], "title": "Equal", "background": "", "description": "有一个长度为 $n$ 的非负整数序列 $a$，你可以无限的做以下两种操作，使得序列中的每一个数字都相等：\n\n-  花费 $x$ 的代价，使得对于所有不大于 $n$ 的正整数 $i$，$a_i$ 的值变为 $\\max(a_i-1,0)$；\n-  花费 $y$ 的代价，替换序列中的一个数为任意数字；\n\n求需要花费的最小代价。", "inputFormat": "**每个测试点有多组测试数据**。\n\n第一行一个整数 $t$，表示数据组数。\n\n接下来依次输入 $t$ 组测试数据。\n\n对于每一组测试数据，第一行三个正整数 $n,x,y$，表示序列长度，第一种操作的代价和第二种操作的代价；第二行 $n$ 个非负整数 $a_1,a_2......a_n$（$1\\le n \\le 2\\times10^5$，$0 \\le x,y,a_i \\le 10^9$）。\n\n保证对于单个测试点，所有 $n$ 的和不超过 $2\\times 10^5$。", "outputFormat": "对于每一组测试数据，输出一行一个整数，表示需要花费的最小代价。", "hint": "#### 样例解释\n\n对于第一组数据，可以进行 $1$ 次第二种操作，把 $a_2$ 的值修改为 $3$，此时 $a_1=a_2=3$。\n\n对于第二组数据，可以进行 $2$ 次第二种操作，把 $a_2$ 和 $a_3$ 的值修改为 $1$，此时 $a_1=a_2=a_3=a_4=a_5=1$。\n\n对于第三组数据，可以进行 $3$ 次第一种操作，此时 $a_1=a_2=a_3=a_4=a_5=0$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "Equal", "background": "", "description": "有一个长度为 $n$ 的非负整数序列 $a$，你可以无限的做以下两种操作，使得序列中的每一个数字都相等：\n\n-  花费 $x$ 的代价，使得对于所有不大于 $n$ 的正整数 $i$，$a_i$ 的值变为 $\\max(a_i-1,0)$；\n-  花费 $y$ 的代价，替换序列中的一个数为任意数字；\n\n求需要花费的最小代价。", "inputFormat": "**每个测试点有多组测试数据**。\n\n第一行一个整数 $t$，表示数据组数。\n\n接下来依次输入 $t$ 组测试数据。\n\n对于每一组测试数据，第一行三个正整数 $n,x,y$，表示序列长度，第一种操作的代价和第二种操作的代价；第二行 $n$ 个非负整数 $a_1,a_2......a_n$（$1\\le n \\le 2\\times10^5$，$0 \\le x,y,a_i \\le 10^9$）。\n\n保证对于单个测试点，所有 $n$ 的和不超过 $2\\times 10^5$。", "outputFormat": "对于每一组测试数据，输出一行一个整数，表示需要花费的最小代价。", "hint": "#### 样例解释\n\n对于第一组数据，可以进行 $1$ 次第二种操作，把 $a_2$ 的值修改为 $3$，此时 $a_1=a_2=3$。\n\n对于第二组数据，可以进行 $2$ 次第二种操作，把 $a_2$ 和 $a_3$ 的值修改为 $1$，此时 $a_1=a_2=a_3=a_4=a_5=1$。\n\n对于第三组数据，可以进行 $3$ 次第一种操作，此时 $a_1=a_2=a_3=a_4=a_5=0$。\n", "locale": "zh-CN"}}}
{"pid": "P14893", "type": "P", "difficulty": 3, "samples": [["2\nfile10\nfile20\nfile3", "+\n-"], ["11\nX52Y\nX\nX5\nX52\nX52Y\nX52Y6\n32\nABC\nXYZ\nx51y\nX8Y\nX222", "-\n-\n-\n+\n+\n-\n-\n+\n+\n-\n+"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "ICPC", "横浜"], "title": "[ICPC 2018 Yokohama R] Digits Are Not Just Characters", "background": "", "description": "Mr. Manuel Majorana Minore made a number of files with numbers in their names. He wants to have a list of the files, but the file listing command commonly used lists them in an order different from what he prefers, interpreting digit sequences in them as ASCII code sequences, not as numbers. For example, the files **file10**, **file20** and **file3** are listed in this order.\n\nWrite a program which decides the orders of file names interpreting digit sequences as numeric values.\n\nEach file name consists of uppercase letters (from ‘A’ to ‘Z’), lowercase letters (from ‘a’ to ‘z’), and digits (from ‘0’ to ‘9’).\n\nA file name is looked upon as a sequence of items, each being either a letter or a number. Each single uppercase or lowercase letter forms a letter item. Each consecutive sequence of digits forms a number item.\n\nTwo items are ordered as follows.\n\n- Number items come before letter items.\n- Two letter items are ordered by their ASCII codes.\n- Two number items are ordered by their values when interpreted as decimal numbers.\n\nTwo file names are compared item by item, starting from the top, and the order of the first different corresponding items decides the order of the file names. If one of them, say $A$, has more items than the other, $B$, and all the items of $B$ are the same as the corresponding items of $A$, $B$ should come before.\n\nFor example, three file names in Sample Input 1, **file10**, **file20**, and **file3** all start with the same sequence of four letter items **f**, **i**, **l**, and **e**, followed by a number item, $10$, $20$, and $3$, respectively. Comparing numeric values of these number items, they are ordered as **file3** $<$ **file10** $<$ **file20**.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n& n \\\\\n& s_0 \\\\\n& s_1 \\\\\n& \\vdots \\\\\n& s_n\n\\end{aligned}\n$$\n\nThe integer $n$ in the first line gives the number of file names ($s_1$ through $s_n$) to be compared with the file name given in the next line ($s_0$). Here, $n$ satisfies $1 \\leq n \\leq 1000$.\n\nThe following $n + 1$ lines are file names, $s_0$ through $s_n$, one in each line. They have at least one and no more than nine characters. Each of the characters is either an uppercase letter, a lowercase letter, or a digit.\n\nSequences of digits in the file names never start with a digit zero ($0$).", "outputFormat": "For each of the file names, $s_1$ through $s_n$, output one line with a character indicating whether it should come **before** $s_0$ or not. The character should be “-” if it is to be listed before $s_0$; otherwise, it should be “+”, including cases where two names are identical.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 Yokohama R] Digits Are Not Just Characters", "background": "", "description": "Mr. Manuel Majorana Minore made a number of files with numbers in their names. He wants to have a list of the files, but the file listing command commonly used lists them in an order different from what he prefers, interpreting digit sequences in them as ASCII code sequences, not as numbers. For example, the files **file10**, **file20** and **file3** are listed in this order.\n\nWrite a program which decides the orders of file names interpreting digit sequences as numeric values.\n\nEach file name consists of uppercase letters (from ‘A’ to ‘Z’), lowercase letters (from ‘a’ to ‘z’), and digits (from ‘0’ to ‘9’).\n\nA file name is looked upon as a sequence of items, each being either a letter or a number. Each single uppercase or lowercase letter forms a letter item. Each consecutive sequence of digits forms a number item.\n\nTwo items are ordered as follows.\n\n- Number items come before letter items.\n- Two letter items are ordered by their ASCII codes.\n- Two number items are ordered by their values when interpreted as decimal numbers.\n\nTwo file names are compared item by item, starting from the top, and the order of the first different corresponding items decides the order of the file names. If one of them, say $A$, has more items than the other, $B$, and all the items of $B$ are the same as the corresponding items of $A$, $B$ should come before.\n\nFor example, three file names in Sample Input 1, **file10**, **file20**, and **file3** all start with the same sequence of four letter items **f**, **i**, **l**, and **e**, followed by a number item, $10$, $20$, and $3$, respectively. Comparing numeric values of these number items, they are ordered as **file3** $<$ **file10** $<$ **file20**.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n& n \\\\\n& s_0 \\\\\n& s_1 \\\\\n& \\vdots \\\\\n& s_n\n\\end{aligned}\n$$\n\nThe integer $n$ in the first line gives the number of file names ($s_1$ through $s_n$) to be compared with the file name given in the next line ($s_0$). Here, $n$ satisfies $1 \\leq n \\leq 1000$.\n\nThe following $n + 1$ lines are file names, $s_0$ through $s_n$, one in each line. They have at least one and no more than nine characters. Each of the characters is either an uppercase letter, a lowercase letter, or a digit.\n\nSequences of digits in the file names never start with a digit zero ($0$).", "outputFormat": "For each of the file names, $s_1$ through $s_n$, output one line with a character indicating whether it should come **before** $s_0$ or not. The character should be “-” if it is to be listed before $s_0$; otherwise, it should be “+”, including cases where two names are identical.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 Yokohama R] Digits Are Not Just Characters", "background": "", "description": "Manuel Majorana Minore 先生创建了许多文件名中包含数字的文件。他希望得到一个文件列表，但常用的文件列表命令会按照不同于他偏好的顺序列出文件，因为这些命令将文件名中的数字序列解释为 ASCII 码序列，而不是数字。例如，文件 **file10**、**file20** 和 **file3** 会按此顺序列出。\n\n请编写一个程序，将数字序列解释为数值，从而决定文件名的顺序。\n\n每个文件名由大写字母（从 ‘A’ 到 ‘Z’）、小写字母（从 ‘a’ 到 ‘z’）和数字（从 ‘0’ 到 ‘9’）组成。\n\n文件名被视为一系列项，每一项要么是一个字母，要么是一个数字。每个单独的大写或小写字母构成一个字母项。每个连续的数字序列构成一个数字项。\n\n两项之间的顺序如下确定。\n\n- 数字项排在字母项之前。\n- 两个字母项按照它们的 ASCII 码排序。\n- 两个数字项按照它们解释为十进制数时的数值排序。\n\n比较两个文件名时，从第一个项开始逐个比较，第一个不同的对应项的次序决定了文件名的次序。如果其中一个文件名（例如 $A$）比另一个文件名 $B$ 有更多的项，并且 $B$ 的所有项都与 $A$ 的对应项相同，那么 $B$ 应排在前面。\n\n例如，样例输入 1 中的三个文件名 **file10**、**file20** 和 **file3** 都以相同的四个字母项序列 **f**、**i**、**l** 和 **e** 开头，随后分别是数字项 $10$、$20$ 和 $3$。比较这些数字项的数值，它们的顺序为 **file3** $<$ **file10** $<$ **file20**。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n& n \\\\\n& s_0 \\\\\n& s_1 \\\\\n& \\vdots \\\\\n& s_n\n\\end{aligned}\n$$\n\n第一行的整数 $n$ 给出了需要与下一行（$s_0$）给出的文件名进行比较的文件名（$s_1$ 到 $s_n$）的数量。其中，$n$ 满足 $1 \\leq n \\leq 1000$。\n\n接下来的 $n + 1$ 行是文件名，$s_0$ 到 $s_n$，每行一个。文件名至少包含一个字符，最多包含九个字符。每个字符要么是大写字母、小写字母，要么是数字。\n\n文件名中的数字序列永远不会以数字零（$0$）开头。", "outputFormat": "对于每个文件名 $s_1$ 到 $s_n$，输出一行包含一个字符，表示它是否应该排在 $s_0$ **之前**。如果它应排在 $s_0$ 之前，则字符应为 “-”；否则，应为 “+”，包括两个文件名相同的情况。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14894", "type": "P", "difficulty": 3, "samples": [["6\n0 1 3 5 6 9", "4"], ["7\n1 4 7 3 2 6 5", "7"], ["5\n1 2 4 8 16\n", "2"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2018", "ICPC", "双指针 two-pointer", "哈希表", "横浜"], "title": "[ICPC 2018 Yokohama R] Arithmetic Progressions", "background": "", "description": "An arithmetic progression is a sequence of numbers $a_1$, $a_2$, $\\ldots$, $a_k$ where the difference of consecutive members $a_{i+1} - a_i$ is a constant ($1 \\leq i \\leq k-1$). For example, the sequence $5$, $8$, $11$, $14$, $17$ is an arithmetic progression of length $5$ with the common difference $3$.\n\nIn this problem, you are requested to find the longest arithmetic progression which can be formed selecting some numbers from a given set of numbers. For example, if the given set of numbers is $\\{0, 1, 3, 5, 6, 9\\}$, you can form arithmetic progressions such as $0$, $3$, $6$, $9$ with the common difference $3$, or $9$, $5$, $1$ with the common difference $-4$. In this case, the progressions $0$, $3$, $6$, $9$ and $9$, $6$, $3$, $0$ are the longest.\n", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n \\\\\n&v_1 & v_2 & \\cdots & v_n\\\\\n\\end{aligned}\n$$\n\n$n$ is the number of elements of the set, which is an integer satisfying $2 \\leq n \\leq 5000$. Each $v_i$ ($1 \\leq i \\leq n$) is an element of the set, which is an integer satisfying $0 \\leq v_i \\leq 10^9$. $v_i$'s are all different, i.e., $v_i \\neq v_j$ if $i \\neq j$.\n", "outputFormat": "Output the length of the longest arithmetic progressions which can be formed selecting some numbers from the given set of numbers.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 Yokohama R] Arithmetic Progressions", "background": "", "description": "An arithmetic progression is a sequence of numbers $a_1$, $a_2$, $\\ldots$, $a_k$ where the difference of consecutive members $a_{i+1} - a_i$ is a constant ($1 \\leq i \\leq k-1$). For example, the sequence $5$, $8$, $11$, $14$, $17$ is an arithmetic progression of length $5$ with the common difference $3$.\n\nIn this problem, you are requested to find the longest arithmetic progression which can be formed selecting some numbers from a given set of numbers. For example, if the given set of numbers is $\\{0, 1, 3, 5, 6, 9\\}$, you can form arithmetic progressions such as $0$, $3$, $6$, $9$ with the common difference $3$, or $9$, $5$, $1$ with the common difference $-4$. In this case, the progressions $0$, $3$, $6$, $9$ and $9$, $6$, $3$, $0$ are the longest.\n", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n \\\\\n&v_1 & v_2 & \\cdots & v_n\\\\\n\\end{aligned}\n$$\n\n$n$ is the number of elements of the set, which is an integer satisfying $2 \\leq n \\leq 5000$. Each $v_i$ ($1 \\leq i \\leq n$) is an element of the set, which is an integer satisfying $0 \\leq v_i \\leq 10^9$. $v_i$'s are all different, i.e., $v_i \\neq v_j$ if $i \\neq j$.\n", "outputFormat": "Output the length of the longest arithmetic progressions which can be formed selecting some numbers from the given set of numbers.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 Yokohama R] Arithmetic Progressions", "background": "", "description": "等差数列是一列数字 $a_1$, $a_2$, $\\ldots$, $a_k$，其中连续项之间的差 $a_{i+1} - a_i$ 是一个常数（$1 \\leq i \\leq k-1$）。例如，序列 $5$, $8$, $11$, $14$, $17$ 是一个长度为 $5$、公差为 $3$ 的等差数列。\n\n在本问题中，你需要从给定的一个数字集合中选出一些数字，找出可以形成的最长等差数列。例如，如果给定的数字集合是 $\\{0, 1, 3, 5, 6, 9\\}$，你可以形成公差为 $3$ 的等差数列 $0$, $3$, $6$, $9$，或者公差为 $-4$ 的等差数列 $9$, $5$, $1$。在这种情况下，等差数列 $0$, $3$, $6$, $9$ 和 $9$, $6$, $3$, $0$ 是最长的。\n", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n&n \\\\\n&v_1 & v_2 & \\cdots & v_n\\\\\n\\end{aligned}\n$$\n\n$n$ 是集合中元素的数量，是一个满足 $2 \\leq n \\leq 5000$ 的整数。每个 $v_i$ （$1 \\leq i \\leq n$）是集合中的一个元素，是一个满足 $0 \\leq v_i \\leq 10^9$ 的整数。所有的 $v_i$ 互不相同，即如果 $i \\neq j$，则 $v_i \\neq v_j$。", "outputFormat": "输出从给定数字集合中选出一些数字可以形成的最长等差数列的长度。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14895", "type": "P", "difficulty": 3, "samples": [["5 2 7\n1 1\n1 2\n1 3\n2 3\n2 4\n4 4\n5 2", "9"], ["500 500 16\n1 1\n1 2\n1 999\n1 1000\n2 1\n2 2\n2 999\n2 1000\n3 1\n3 2\n3 999\n3 1000\n499 500\n499 501\n499 999\n499 1000", "1008"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2018", "ICPC", "横浜"], "title": "[ICPC 2018 Yokohama R] Emergency Evacuation", "background": "", "description": "The Japanese government plans to increase the number of inbound tourists to forty million in the year $2020$, and sixty million in $2030$. Not only increasing touristic appeal but also developing tourism infrastructure further is indispensable to accomplish such numbers.\n\nOne possible enhancement on transport is providing cars extremely long and/or wide, carrying many passengers at a time. Too large a car, however, may require too long to evacuate all passengers in an emergency. You are requested to help estimating the time required.\n\nThe car is assumed to have the following seat arrangement.\n\n- A center aisle goes straight through the car, directly connecting to the emergency exit door at the rear center of the car.\n- The rows of the same number of passenger seats are on both sides of the aisle.\n\nA rough estimation requested is based on a simple step-wise model. All passengers are initially on a distinct seat, and they can make one of the following moves in each step.\n\n- Passengers on a seat can move to an adjacent seat toward the aisle. Passengers on a seat adjacent to the aisle can move sideways directly to the aisle.\n- Passengers on the aisle can move backward by one row of seats. If the passenger is in front of the emergency exit, that is, by the rear-most seat rows, he/she can get off the car.\n\nThe seat or the aisle position to move to must be empty; either no other passenger is there before the step, or the passenger there empties the seat by moving to another position in the same step. When two or more passengers satisfy the condition for the same position, only one of them can move, keeping the others wait in their original positions.\n\nThe leftmost figure of Figure C.1 depicts the seat arrangement of a small car given in Sample Input 1. The car have five rows of seats, two seats each on both sides of the aisle, totaling twenty. The initial positions of seven passengers on board are also shown.\n\nThe two other figures of Figure C.1 show possible positions of passengers after the first and the second steps. Passenger movements are indicated by fat arrows. Note that, two of the passengers in the front seat had to wait for a vacancy in the first step, and one in the second row had to wait in the next step.\n\nYour task is to write a program that gives the smallest possible number of steps for all the passengers to get off the car, given the seat arrangement and passengers' initial positions.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/x3p3lfi8.png)\n\nFigure C.1. Simple Model\n:::", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n& r \\quad s \\quad p \\\\\n& i_1 \\quad j_1 \\\\\n& \\vdots \\\\\n& i_p \\quad j_p\n\\end{aligned}\n$$\n\nHere, $r$ is the number of passenger seat rows, $s$ is the number of seats on each side of the aisle, and $p$ is the number of passengers. They are integers satisfying $1 \\leq r \\leq 500$, $1 \\leq s \\leq 500$, and $1 \\leq p \\leq 2rs$.\n\nThe following $p$ lines give initial seat positions of the passengers. The $k$-th line with $i_k$ and $j_k$ means that the $k$-th passenger's seat is in the $i_k$-th seat row and it is the $j_k$-th seat on that row. Here, rows and seats are counted from front to rear and left to right, both starting from one. They satisfy $1 \\leq i_k \\leq r$ and $1 \\leq j_k \\leq 2s$. Passengers are on distinct seats, that is, $i_k \\neq i_l$ or $j_k \\neq j_l$ holds if $k \\neq l$.", "outputFormat": "The output should be one line containing a single integer, the minimum number of steps required for all the passengers to get off the car.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 Yokohama R] Emergency Evacuation", "background": "", "description": "The Japanese government plans to increase the number of inbound tourists to forty million in the year $2020$, and sixty million in $2030$. Not only increasing touristic appeal but also developing tourism infrastructure further is indispensable to accomplish such numbers.\n\nOne possible enhancement on transport is providing cars extremely long and/or wide, carrying many passengers at a time. Too large a car, however, may require too long to evacuate all passengers in an emergency. You are requested to help estimating the time required.\n\nThe car is assumed to have the following seat arrangement.\n\n- A center aisle goes straight through the car, directly connecting to the emergency exit door at the rear center of the car.\n- The rows of the same number of passenger seats are on both sides of the aisle.\n\nA rough estimation requested is based on a simple step-wise model. All passengers are initially on a distinct seat, and they can make one of the following moves in each step.\n\n- Passengers on a seat can move to an adjacent seat toward the aisle. Passengers on a seat adjacent to the aisle can move sideways directly to the aisle.\n- Passengers on the aisle can move backward by one row of seats. If the passenger is in front of the emergency exit, that is, by the rear-most seat rows, he/she can get off the car.\n\nThe seat or the aisle position to move to must be empty; either no other passenger is there before the step, or the passenger there empties the seat by moving to another position in the same step. When two or more passengers satisfy the condition for the same position, only one of them can move, keeping the others wait in their original positions.\n\nThe leftmost figure of Figure C.1 depicts the seat arrangement of a small car given in Sample Input 1. The car have five rows of seats, two seats each on both sides of the aisle, totaling twenty. The initial positions of seven passengers on board are also shown.\n\nThe two other figures of Figure C.1 show possible positions of passengers after the first and the second steps. Passenger movements are indicated by fat arrows. Note that, two of the passengers in the front seat had to wait for a vacancy in the first step, and one in the second row had to wait in the next step.\n\nYour task is to write a program that gives the smallest possible number of steps for all the passengers to get off the car, given the seat arrangement and passengers' initial positions.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/x3p3lfi8.png)\n\nFigure C.1. Simple Model\n:::", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n& r \\quad s \\quad p \\\\\n& i_1 \\quad j_1 \\\\\n& \\vdots \\\\\n& i_p \\quad j_p\n\\end{aligned}\n$$\n\nHere, $r$ is the number of passenger seat rows, $s$ is the number of seats on each side of the aisle, and $p$ is the number of passengers. They are integers satisfying $1 \\leq r \\leq 500$, $1 \\leq s \\leq 500$, and $1 \\leq p \\leq 2rs$.\n\nThe following $p$ lines give initial seat positions of the passengers. The $k$-th line with $i_k$ and $j_k$ means that the $k$-th passenger's seat is in the $i_k$-th seat row and it is the $j_k$-th seat on that row. Here, rows and seats are counted from front to rear and left to right, both starting from one. They satisfy $1 \\leq i_k \\leq r$ and $1 \\leq j_k \\leq 2s$. Passengers are on distinct seats, that is, $i_k \\neq i_l$ or $j_k \\neq j_l$ holds if $k \\neq l$.", "outputFormat": "The output should be one line containing a single integer, the minimum number of steps required for all the passengers to get off the car.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 Yokohama R] Emergency Evacuation", "background": "", "description": "日本政$ $府计划在 $2020$ 年将入境游客数量增加到四千万，并在 $2030$ 年增加到六千万。要实现这样的数字，不仅需要增加旅游吸引力，进一步发展旅游基础设施也是必不可少的。\n\n在交通方面，一个可能的改进是提供极长和/或极宽的车辆，一次运送许多乘客。然而，过大的车辆在紧急情况下疏散所有乘客可能需要很长时间。你被请求帮助估算所需的时间。\n\n假设车辆具有以下座位布局。\n\n- 一条中央过道笔直穿过车辆，直接连接到车辆后部中央的紧急出口门。\n- 过道两侧有相同数量的乘客座位排。\n\n所请求的粗略估算基于一个简单的逐步模型。所有乘客最初都位于不同的座位上，他们在每一步中可以执行以下一种移动。\n\n- 座位上的乘客可以向靠近过道的相邻座位移动。靠近过道的座位上的乘客可以直接横向移动到过道上。\n- 过道上的乘客可以向后移动一排座位。如果乘客在紧急出口前方（即最后一排座位处），他/她可以下车。\n\n要移动到的座位或过道位置必须是空的；即在该步骤之前没有其他乘客在那里，或者在那里的乘客通过在同一步骤中移动到另一个位置而腾出了该位置。当两个或更多乘客满足同一位置的移动条件时，只有其中一人可以移动，其他人必须在原位置等待。\n\n图 C.1 中最左边的图描绘了样例输入 1 中给出的一个小型车辆的座位布局。该车辆有五排座位，过道两侧各有两个座位，总共二十个座位。车上七名乘客的初始位置也已标出。\n\n图 C.1 中的另外两个图显示了第一步和第二步之后乘客的可能位置。乘客移动用粗箭头表示。请注意，前排座位上的两名乘客在第一步中不得不等待空位，第二排的一名乘客在下一步中不得不等待。\n\n你的任务是编写一个程序，在给定座位布局和乘客初始位置的情况下，计算出所有乘客下车所需的最小步数。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/x3p3lfi8.png)\n\n图 C.1. 简单模型\n:::", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n& r \\quad s \\quad p \\\\\n& i_1 \\quad j_1 \\\\\n& \\vdots \\\\\n& i_p \\quad j_p\n\\end{aligned}\n$$\n\n其中，$r$ 是乘客座位排数，$s$ 是过道每侧的座位数，$p$ 是乘客数量。它们是满足 $1 \\leq r \\leq 500$，$1 \\leq s \\leq 500$ 和 $1 \\leq p \\leq 2rs$ 的整数。\n\n接下来的 $p$ 行给出乘客的初始座位位置。第 $k$ 行包含 $i_k$ 和 $j_k$，表示第 $k$ 个乘客的座位在第 $i_k$ 排，且是该排的第 $j_k$ 个座位。这里，排数和座位编号均从前到后、从左到右计数，且都从 $1$ 开始。它们满足 $1 \\leq i_k \\leq r$ 和 $1 \\leq j_k \\leq 2s$。乘客位于不同的座位上，即如果 $k \\neq l$，则 $i_k \\neq i_l$ 或 $j_k \\neq j_l$ 成立。", "outputFormat": "输出应包含一行一个整数，表示所有乘客下车所需的最小步数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14896", "type": "P", "difficulty": 5, "samples": [["0101\n1100001", "0010"], ["101010101\n010101010", "000000"], ["11111111\n00000000", "01"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "广度优先搜索 BFS", "有限状态自动机", "ICPC", "横浜"], "title": "[ICPC 2018 Yokohama R] Shortest Common Non-Subsequence", "background": "", "description": "A subsequence of a sequence $P$ is a sequence that can be derived from the original sequence $P$ by picking up some or no elements of $P$ preserving the order. For example, \"ICPC\" is a subsequence of \"MICROPROCESSOR\".\n\nA common subsequence of two sequences is a subsequence of both sequences. The famous longest common subsequence problem is finding the longest of common subsequences of two given sequences.\n\nIn this problem, conversely, we consider the shortest common non-subsequence problem: Given two sequences consisting of 0 and 1, your task is to find the shortest sequence also consisting of 0 and 1 that is a subsequence of neither of the two sequences.", "inputFormat": "The input consists of a single test case with two lines. Both lines are sequences consisting only of 0 and 1. Their lengths are between 1 and 4000, inclusive.\n", "outputFormat": "Output in one line the shortest common non-subsequence of two given sequences. If there are two or more such sequences, you should output the lexicographically smallest one. Here, a sequence $P$ is lexicographically smaller than another sequence $Q$ of the same length if there exists $k$ such that $P_1 = Q_1$, $\\ldots$, $P_{k-1} = Q_{k-1}$, and $P_k < Q_k$, where $S_i$ is the $i$-th character of a sequence $S$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 Yokohama R] Shortest Common Non-Subsequence", "background": "", "description": "A subsequence of a sequence $P$ is a sequence that can be derived from the original sequence $P$ by picking up some or no elements of $P$ preserving the order. For example, \"ICPC\" is a subsequence of \"MICROPROCESSOR\".\n\nA common subsequence of two sequences is a subsequence of both sequences. The famous longest common subsequence problem is finding the longest of common subsequences of two given sequences.\n\nIn this problem, conversely, we consider the shortest common non-subsequence problem: Given two sequences consisting of 0 and 1, your task is to find the shortest sequence also consisting of 0 and 1 that is a subsequence of neither of the two sequences.", "inputFormat": "The input consists of a single test case with two lines. Both lines are sequences consisting only of 0 and 1. Their lengths are between 1 and 4000, inclusive.\n", "outputFormat": "Output in one line the shortest common non-subsequence of two given sequences. If there are two or more such sequences, you should output the lexicographically smallest one. Here, a sequence $P$ is lexicographically smaller than another sequence $Q$ of the same length if there exists $k$ such that $P_1 = Q_1$, $\\ldots$, $P_{k-1} = Q_{k-1}$, and $P_k < Q_k$, where $S_i$ is the $i$-th character of a sequence $S$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 Yokohama R] Shortest Common Non-Subsequence", "background": "", "description": "序列 $P$ 的一个子序列是指可以通过从原序列 $P$ 中选取某些或不选取任何元素并保持原有顺序而得到的序列。例如，\"ICPC\" 是 \"MICROPROCESSOR\" 的一个子序列。\n\n两个序列的公共子序列是指同时作为这两个序列子序列的序列。著名的**最长公共子序列**问题是寻找两个给定序列的最长公共子序列。\n\n在本问题中，相反地，我们考虑**最短公共非子序列**问题：给定两个由 0 和 1 组成的序列，你的任务是找到一个同样由 0 和 1 组成的最短序列，该序列不是这两个序列中任何一个的子序列。\n", "inputFormat": "输入由两行组成，构成一个测试用例。两行都是仅由 0 和 1 组成的序列。它们的长度在 1 到 4000 之间（含）。\n", "outputFormat": "在一行中输出两个给定序列的最短公共非子序列。如果存在两个或更多这样的序列，你应该输出字典序最小的那个。这里，对于长度相同的两个序列 $P$ 和 $Q$，如果存在 $k$ 使得 $P_1 = Q_1$，$\\ldots$，$P_{k-1} = Q_{k-1}$，且 $P_k < Q_k$，则称 $P$ 的字典序小于 $Q$，其中 $S_i$ 是序列 $S$ 的第 $i$ 个字符。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14897", "type": "P", "difficulty": 6, "samples": [["4 2\n1 2\n3 4", "2\n1 4\n2 3"], ["6 9\n1 4\n1 5\n1 6\n2 4\n2 5\n2 6\n3 4\n3 5\n3 6", "-1"], ["6 7\n1 2\n1 3\n1 4\n2 3\n4 5\n4 6\n5 6", "3\n1 5\n2 4\n2 5"], ["4 3\n2 3\n2 4\n3 4", "-1"], ["5 5\n1 3\n1 4\n2 4\n2 5\n3 5", "0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "Special Judge", "欧拉回路", "高斯消元", "ICPC", "横浜"], "title": "[ICPC 2018 Yokohama R] Eulerian Flight Tour", "background": "", "description": "You have an airline route map of a certain region. All the airports in the region and all the **non-stop routes** between them are on the map. Here, a non-stop route is a flight route that provides non-stop flights in both ways.\n\nNamed after the great mathematician Leonhard Euler, an **Eulerian tour** is an itinerary visiting all the airports in the region taking a single flight of every non-stop route available in the region. To be precise, it is a list of airports, satisfying all of the following.\n\n- The list begins and ends with the same airport.\n- There are non-stop routes between pairs of airports adjacent in the list.\n- All the airports in the region appear at least once in the list. Note that it is allowed to have some airports appearing multiple times.\n- For all the airport pairs with non-stop routes in between, there should be one and only one adjacent appearance of two airports of the pair in the list in either order.\n\nIt may not always be possible to find an Eulerian tour only with the non-stop routes listed in the map. Adding more routes, however, may enable Eulerian tours. Your task is to find a set of additional routes that enables Eulerian tours.", "inputFormat": "The input consists of a single test case.\n\n$$\n\\begin{aligned}\n& n \\quad m \\\\\n& a_1 \\quad b_1 \\\\\n& \\vdots \\\\\n& a_m \\quad b_m\n\\end{aligned}\n$$\n\n$n$ ($3 \\leq n \\leq 100$) is the number of airports. The airports are numbered from 1 to $n$. $m$ ($0 \\leq m \\leq \\frac{n(n-1)}{2}$) is the number of pairs of airports that have non-stop routes. Among the $m$ lines following it, integers $a_i$ and $b_i$ on the $i$-th line of them ($1 \\leq i \\leq m$) are airport numbers between which a non-stop route is operated. You can assume $1 \\leq a_i < b_i \\leq n$, and for any $i \\neq j$, either $a_i \\neq a_j$ or $b_i \\neq b_j$ holds.", "outputFormat": "Output a set of additional non-stop routes that enables Eulerian tours. If two or more different sets will do, any one of them is acceptable. The output should be in the following format.\n\n$$\n\\begin{aligned}\n& k \\\\\n& c_1 \\quad d_1 \\\\\n& \\vdots \\\\\n& c_k \\quad d_k\n\\end{aligned}\n$$\n\n$k$ is the number of non-stop routes to add, possibly zero. Each of the following $k$ lines should have a pair of integers, separated by a space. Integers $c_i$ and $d_i$ in the $i$-th line ($c_i < d_i$) are airport numbers specifying that a non-stop route is to be added between them. These pairs, $(c_i, d_i)$ for $1 \\leq i \\leq k$, should be distinct and should not appear in the input.\n\nIf adding new non-stop routes can never enable Eulerian tours, output -1 in a line.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 Yokohama R] Eulerian Flight Tour", "background": "", "description": "You have an airline route map of a certain region. All the airports in the region and all the **non-stop routes** between them are on the map. Here, a non-stop route is a flight route that provides non-stop flights in both ways.\n\nNamed after the great mathematician Leonhard Euler, an **Eulerian tour** is an itinerary visiting all the airports in the region taking a single flight of every non-stop route available in the region. To be precise, it is a list of airports, satisfying all of the following.\n\n- The list begins and ends with the same airport.\n- There are non-stop routes between pairs of airports adjacent in the list.\n- All the airports in the region appear at least once in the list. Note that it is allowed to have some airports appearing multiple times.\n- For all the airport pairs with non-stop routes in between, there should be one and only one adjacent appearance of two airports of the pair in the list in either order.\n\nIt may not always be possible to find an Eulerian tour only with the non-stop routes listed in the map. Adding more routes, however, may enable Eulerian tours. Your task is to find a set of additional routes that enables Eulerian tours.", "inputFormat": "The input consists of a single test case.\n\n$$\n\\begin{aligned}\n& n \\quad m \\\\\n& a_1 \\quad b_1 \\\\\n& \\vdots \\\\\n& a_m \\quad b_m\n\\end{aligned}\n$$\n\n$n$ ($3 \\leq n \\leq 100$) is the number of airports. The airports are numbered from 1 to $n$. $m$ ($0 \\leq m \\leq \\frac{n(n-1)}{2}$) is the number of pairs of airports that have non-stop routes. Among the $m$ lines following it, integers $a_i$ and $b_i$ on the $i$-th line of them ($1 \\leq i \\leq m$) are airport numbers between which a non-stop route is operated. You can assume $1 \\leq a_i < b_i \\leq n$, and for any $i \\neq j$, either $a_i \\neq a_j$ or $b_i \\neq b_j$ holds.", "outputFormat": "Output a set of additional non-stop routes that enables Eulerian tours. If two or more different sets will do, any one of them is acceptable. The output should be in the following format.\n\n$$\n\\begin{aligned}\n& k \\\\\n& c_1 \\quad d_1 \\\\\n& \\vdots \\\\\n& c_k \\quad d_k\n\\end{aligned}\n$$\n\n$k$ is the number of non-stop routes to add, possibly zero. Each of the following $k$ lines should have a pair of integers, separated by a space. Integers $c_i$ and $d_i$ in the $i$-th line ($c_i < d_i$) are airport numbers specifying that a non-stop route is to be added between them. These pairs, $(c_i, d_i)$ for $1 \\leq i \\leq k$, should be distinct and should not appear in the input.\n\nIf adding new non-stop routes can never enable Eulerian tours, output -1 in a line.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 Yokohama R] Eulerian Flight Tour", "background": "", "description": "你拥有某个地区的航线地图。该地区的所有机场以及它们之间的所有**直飞航线**都标记在地图上。这里，直飞航线是指提供双向直飞航班的航线。\n\n以伟大的数学家莱昂哈德·欧拉命名的**欧拉环游**是一种行程，它访问该地区的所有机场，并搭乘该地区可用的每条直飞航线恰好一次。准确地说，它是一个机场列表，满足以下所有条件。\n\n- 列表以同一个机场开始和结束。\n- 列表中相邻的机场对之间存在直飞航线。\n- 该地区的所有机场至少在列表中出现一次。注意，允许某些机场出现多次。\n- 对于所有存在直飞航线的机场对，该对机场（无论顺序）在列表中应恰好出现一次作为相邻项。\n\n仅凭地图上列出的直飞航线，可能并不总是能找到欧拉环游。然而，添加更多航线可能使得欧拉环游成为可能。你的任务是找出一组额外的航线，使得欧拉环游成为可能。", "inputFormat": "输入包含单个测试用例。\n\n$$\n\\begin{aligned}\n& n \\quad m \\\\\n& a_1 \\quad b_1 \\\\\n& \\vdots \\\\\n& a_m \\quad b_m\n\\end{aligned}\n$$\n\n$n$ （$3 \\leq n \\leq 100$）是机场的数量。机场编号从 $1$ 到 $n$。$m$ （$0 \\leq m \\leq \\frac{n(n-1)}{2}$）是存在直飞航线的机场对的数量。接下来的 $m$ 行中，第 $i$ 行（$1 \\leq i \\leq m$）的整数 $a_i$ 和 $b_i$ 表示在两个机场之间有直飞航线运营。你可以假设 $1 \\leq a_i < b_i \\leq n$，并且对于任意 $i \\neq j$，满足 $a_i \\neq a_j$ 或 $b_i \\neq b_j$。", "outputFormat": "输出一组能使得欧拉环游成为可能的额外直飞航线。如果有两种或更多种不同的可行集合，输出其中任意一种均可。输出应采用以下格式。\n\n$$\n\\begin{aligned}\n& k \\\\\n& c_1 \\quad d_1 \\\\\n& \\vdots \\\\\n& c_k \\quad d_k\n\\end{aligned}\n$$\n\n$k$ 是要添加的直飞航线数量，可能为零。接下来的 $k$ 行中，每行应包含一对用空格分隔的整数。第 $i$ 行（$c_i < d_i$）的整数 $c_i$ 和 $d_i$ 表示要在它们之间添加一条直飞航线的机场编号。这些对，即对于 $1 \\leq i \\leq k$ 的 $(c_i, d_i)$，应互不相同且不应出现在输入中。\n\n如果添加新的直飞航线永远无法使得欧拉环游成为可能，则在一行中输出 -1。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14898", "type": "P", "difficulty": 6, "samples": [["4\n0 0\n10 0\n10 10\n0 10", "10\n14.142135623730950488"], ["3\n0 0\n6 0\n3 10", "4.2426406871192851464\n10.0"], ["5\n0 0\n99999 20000\n100000 70000\n33344 63344\n1 50000", "54475.580091580027976\n120182.57592539864775"], ["6\n100 350\n101 349\n6400 3440\n6400 3441\n1200 7250\n1199 7249", "4559.2050019027964982\n6216.7174287968524227"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "2018", "Special Judge", "ICPC", "横浜"], "title": "[ICPC 2018 Yokohama R] Fair Chocolate-Cutting", "background": "", "description": "You are given a flat piece of chocolate of convex polygon shape. You are to cut it into two pieces of precisely the same amount with a straight knife.\n\nWrite a program that computes, for a given convex polygon, the maximum and minimum lengths of the line segments that divide the polygon into two equal areas.\n\nThe figures below correspond to first two sample inputs. Two dashed lines in each of them correspond to the equal-area cuts of minimum and maximum lengths.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/3z3tw7m4.png)\n\nFigure F.1. Sample Chocolate Pieces and Cut Lines\n:::", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n& n \\\\\n& x_1 \\quad y_1 \\\\\n& \\vdots \\\\\n& x_n \\quad y_n\n\\end{aligned}\n$$\n\nThe first line has an integer $n$, which is the number of vertices of the given polygon. Here, $n$ is between 3 and 5000, inclusive. Each of the following $n$ lines has two integers $x_i$ and $y_i$, which give the coordinates ($x_i$, $y_i$) of the $i$-th vertex of the polygon, in counterclockwise order. Both $x_i$ and $y_i$ are between 0 and 100 000, inclusive.\n\nThe polygon is guaranteed to be simple and convex. In other words, no two edges of the polygon intersect each other and interior angles at all of its vertices are less than $180^\\circ$.", "outputFormat": "Two lines should be output. The first line should have the minimum length of a straight line segment that partitions the polygon into two parts of the equal area. The second line should have the maximum length of such a line segment. The answer will be considered as correct if the values output have an absolute or relative error less than $10^{-6}$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 Yokohama R] Fair Chocolate-Cutting", "background": "", "description": "You are given a flat piece of chocolate of convex polygon shape. You are to cut it into two pieces of precisely the same amount with a straight knife.\n\nWrite a program that computes, for a given convex polygon, the maximum and minimum lengths of the line segments that divide the polygon into two equal areas.\n\nThe figures below correspond to first two sample inputs. Two dashed lines in each of them correspond to the equal-area cuts of minimum and maximum lengths.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/3z3tw7m4.png)\n\nFigure F.1. Sample Chocolate Pieces and Cut Lines\n:::", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n& n \\\\\n& x_1 \\quad y_1 \\\\\n& \\vdots \\\\\n& x_n \\quad y_n\n\\end{aligned}\n$$\n\nThe first line has an integer $n$, which is the number of vertices of the given polygon. Here, $n$ is between 3 and 5000, inclusive. Each of the following $n$ lines has two integers $x_i$ and $y_i$, which give the coordinates ($x_i$, $y_i$) of the $i$-th vertex of the polygon, in counterclockwise order. Both $x_i$ and $y_i$ are between 0 and 100 000, inclusive.\n\nThe polygon is guaranteed to be simple and convex. In other words, no two edges of the polygon intersect each other and interior angles at all of its vertices are less than $180^\\circ$.", "outputFormat": "Two lines should be output. The first line should have the minimum length of a straight line segment that partitions the polygon into two parts of the equal area. The second line should have the maximum length of such a line segment. The answer will be considered as correct if the values output have an absolute or relative error less than $10^{-6}$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 Yokohama R] Fair Chocolate-Cutting", "background": "", "description": "你有一块凸多边形形状的平面巧克力。你需要用一把直刀将其切成两块面积完全相同的部分。\n\n对于给定的凸多边形，编写一个程序，计算将该多边形分割成两个相等面积的线段的最大长度和最小长度。\n\n下图对应于前两个样例输入。每个图中的两条虚线分别对应最小和最大长度的等面积切割线。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/3z3tw7m4.png)\n\n图 F.1. 样例巧克力块及切割线\n:::", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n& n \\\\\n& x_1 \\quad y_1 \\\\\n& \\vdots \\\\\n& x_n \\quad y_n\n\\end{aligned}\n$$\n\n第一行有一个整数 $n$，表示给定多边形的顶点数。其中，$n$ 在 $3$ 到 $5000$ 之间（含）。接下来的 $n$ 行中，每行有两个整数 $x_i$ 和 $y_i$，它们按逆时针顺序给出了多边形第 $i$ 个顶点的坐标 ($x_i$, $y_i$)。$x_i$ 和 $y_i$ 都在 $0$ 到 $100000$ 之间（含）。\n\n保证多边形是简单且凸的。换句话说，多边形的任意两条边互不相交，且其所有顶点的内角都小于 $180^\\circ$。", "outputFormat": "应输出两行。第一行应包含将多边形分割成两个相等面积的直线段的最小长度。第二行应包含此类直线段的最大长度。如果输出的值与正确答案的绝对误差或相对误差小于 $10^{-6}$，则视为正确。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14899", "type": "P", "difficulty": 4, "samples": [["7\n3 1 4 1 5 9 2", "3"], ["9\n10 4 6 3 15 9 1 1 12", "8"], ["8\n9 9 8 8 7 7 6 6", "0"], ["6\n8 7 2 5 4 6", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "树状数组", "ICPC", "横浜"], "title": "[ICPC 2018 Yokohama R] What Goes Up Must Come Down", "background": "", "description": "Several cards with numbers printed on them are lined up on the table.\n\nWe'd like to change their order so that first some are in non-decreasing order of the numbers on them, and the rest are in non-increasing order. For example, $(1, 2, 3, 2, 1)$, $(1, 1, 3, 4, 5, 9, 2)$, and $(5, 3, 1)$ are acceptable orders, but $(8, 7, 9)$ and $(5, 3, 5, 3)$ are not.\n\nTo put it formally, with $n$ the number of cards and $b_i$ the number printed on the card at the $i$-th position ($1 \\leq i \\leq n$) after reordering, there should exist $k \\in \\{1, \\ldots, n\\}$ such that ($b_i \\leq b_{i+1} \\; \\forall i \\in \\{1, \\ldots, k-1\\}$) and ($b_i \\geq b_{i+1} \\; \\forall i \\in \\{k, \\ldots, n-1\\}$) hold.\n\nFor reordering, the only operation allowed at a time is to swap the positions of an adjacent card pair. We want to know the minimum number of swaps required to complete the reorder.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n\\\\\n&a_1 \\; \\ldots \\; a_n\\\\\n\\end{aligned}\n$$\n\nAn integer $n$ in the first line is the number of cards ($1 \\leq n \\leq 100\\,000$). Integers $a_1$ through $a_n$ in the second line are the numbers printed on the cards, in the order of their original positions ($1 \\leq a_i \\leq 100\\,000$).\n", "outputFormat": "Output in a line the minimum number of swaps required to reorder the cards as specified.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 Yokohama R] What Goes Up Must Come Down", "background": "", "description": "Several cards with numbers printed on them are lined up on the table.\n\nWe'd like to change their order so that first some are in non-decreasing order of the numbers on them, and the rest are in non-increasing order. For example, $(1, 2, 3, 2, 1)$, $(1, 1, 3, 4, 5, 9, 2)$, and $(5, 3, 1)$ are acceptable orders, but $(8, 7, 9)$ and $(5, 3, 5, 3)$ are not.\n\nTo put it formally, with $n$ the number of cards and $b_i$ the number printed on the card at the $i$-th position ($1 \\leq i \\leq n$) after reordering, there should exist $k \\in \\{1, \\ldots, n\\}$ such that ($b_i \\leq b_{i+1} \\; \\forall i \\in \\{1, \\ldots, k-1\\}$) and ($b_i \\geq b_{i+1} \\; \\forall i \\in \\{k, \\ldots, n-1\\}$) hold.\n\nFor reordering, the only operation allowed at a time is to swap the positions of an adjacent card pair. We want to know the minimum number of swaps required to complete the reorder.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n&n\\\\\n&a_1 \\; \\ldots \\; a_n\\\\\n\\end{aligned}\n$$\n\nAn integer $n$ in the first line is the number of cards ($1 \\leq n \\leq 100\\,000$). Integers $a_1$ through $a_n$ in the second line are the numbers printed on the cards, in the order of their original positions ($1 \\leq a_i \\leq 100\\,000$).\n", "outputFormat": "Output in a line the minimum number of swaps required to reorder the cards as specified.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 Yokohama R] What Goes Up Must Come Down", "background": "", "description": "几张印有数字的卡片在桌子上排成一列。\n\n我们想要改变它们的顺序，使得一部分卡片按上面数字的非递减顺序排列，其余部分按非递增顺序排列。例如，$(1, 2, 3, 2, 1)$、$(1, 1, 3, 4, 5, 9, 2)$ 和 $(5, 3, 1)$ 是可接受的顺序，但 $(8, 7, 9)$ 和 $(5, 3, 5, 3)$ 则不是。\n\n形式化地说，设 $n$ 为卡片数量，重新排序后第 $i$ 个位置（$1 \\leq i \\leq n$）卡片上的数字为 $b_i$，应存在 $k \\in \\{1, \\ldots, n\\}$，使得 ($b_i \\leq b_{i+1} \\; \\forall i \\in \\{1, \\ldots, k-1\\}$) 且 ($b_i \\geq b_{i+1} \\; \\forall i \\in \\{k, \\ldots, n-1\\}$) 成立。\n\n为了重新排序，每次只允许交换相邻两张卡片的位置。我们想知道完成重新排序所需的最小交换次数。\n", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n&n\\\\\n&a_1 \\; \\ldots \\; a_n\\\\\n\\end{aligned}\n$$\n\n第一行的整数 $n$ 是卡片的数量（$1 \\leq n \\leq 100\\,000$）。第二行的整数 $a_1$ 到 $a_n$ 是卡片上印着的数字，按它们原始位置的顺序给出（$1 \\leq a_i \\leq 100\\,000$）。", "outputFormat": "在一行中输出将卡片按指定要求重新排序所需的最小交换次数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14900", "type": "P", "difficulty": 6, "samples": [["5 8\n0 0\n2 0\n0 2\n2 2\n1 1\n1 2\n1 3\n1 5\n2 4\n2 5\n3 4\n3 5\n4 5", "1\n2\n2\n1\n3"], ["6 10\n0 0\n1 0\n1 1\n2 1\n0 2\n1 2\n1 2\n1 3\n1 5\n2 3\n2 4\n3 4\n3 5\n3 6\n4 6\n5 6", "1\n2\n3\n4\n2\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2018", "Special Judge", "ICPC", "横浜"], "title": "[ICPC 2018 Yokohama R] Four-Coloring", "background": "", "description": "You are given a planar embedding of a connected graph. Each vertex of the graph corresponds to a distinct point with integer coordinates. Each edge between two vertices corresponds to a straight line segment connecting the two points corresponding to the vertices. As the given embedding is planar, the line segments corresponding to edges do not share any points other than their common endpoints. The given embedding is organized so that inclinations of all the line segments are multiples of 45 degrees. In other words, for two points with coordinates $(x_u, y_u)$ and $(x_v, y_v)$ corresponding to vertices $u$ and $v$ with an edge between them, one of $x_u = x_v$, $y_u = y_v$, or $|x_u - x_v| = |y_u - y_v|$ holds.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8knyacui.png)\n\nFigure H.1. Sample Input 1 and 2\n:::\n\nYour task is to color each vertex in one of the four colors, $\\{1, 2, 3, 4\\}$, so that no two vertices connected by an edge are of the same color. According to the famous four color theorem, such a coloring is always possible. Please find one.\n", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n& n \\; m \\\\\n& x_1 \\; y_1 \\\\\n& \\vdots \\\\\n& x_n \\; y_n \\\\\n& u_1 \\; v_1 \\\\\n& \\vdots \\\\\n& u_m \\; v_m\n\\end{aligned}\n$$\n\nThe first line contains two integers, $n$ and $m$. $n$ is the number of vertices and $m$ is the number of edges satisfying $3 \\leq n \\leq m \\leq 10\\,000$. The vertices are numbered 1 through $n$. Each of the next $n$ lines contains two integers. Integers on the $v$-th line, $x_v$ ($0 \\leq x_v \\leq 1000$) and $y_v$ ($0 \\leq y_v \\leq 1000$), denote the coordinates of the point corresponding to the vertex $v$. Vertices correspond to distinct points, i.e., $(x_u, y_u) \\neq (x_v, y_v)$ holds for $u \\neq v$. Each of the next $m$ lines contains two integers. Integers on the $i$-th line, $u_i$ and $v_i$, with $1 \\leq u_i < v_i \\leq n$, mean that there is an edge connecting two vertices $u_i$ and $v_i$.\n", "outputFormat": "The output should consist of $n$ lines. The $v$-th line of the output should contain one integer $c_v \\in \\{1, 2, 3, 4\\}$ which means that the vertex $v$ is to be colored $c_v$. The output must satisfy $c_u \\neq c_v$ for every edge connecting $u$ and $v$ in the graph. If there are multiple solutions, you may output any one of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 Yokohama R] Four-Coloring", "background": "", "description": "You are given a planar embedding of a connected graph. Each vertex of the graph corresponds to a distinct point with integer coordinates. Each edge between two vertices corresponds to a straight line segment connecting the two points corresponding to the vertices. As the given embedding is planar, the line segments corresponding to edges do not share any points other than their common endpoints. The given embedding is organized so that inclinations of all the line segments are multiples of 45 degrees. In other words, for two points with coordinates $(x_u, y_u)$ and $(x_v, y_v)$ corresponding to vertices $u$ and $v$ with an edge between them, one of $x_u = x_v$, $y_u = y_v$, or $|x_u - x_v| = |y_u - y_v|$ holds.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8knyacui.png)\n\nFigure H.1. Sample Input 1 and 2\n:::\n\nYour task is to color each vertex in one of the four colors, $\\{1, 2, 3, 4\\}$, so that no two vertices connected by an edge are of the same color. According to the famous four color theorem, such a coloring is always possible. Please find one.\n", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n& n \\; m \\\\\n& x_1 \\; y_1 \\\\\n& \\vdots \\\\\n& x_n \\; y_n \\\\\n& u_1 \\; v_1 \\\\\n& \\vdots \\\\\n& u_m \\; v_m\n\\end{aligned}\n$$\n\nThe first line contains two integers, $n$ and $m$. $n$ is the number of vertices and $m$ is the number of edges satisfying $3 \\leq n \\leq m \\leq 10\\,000$. The vertices are numbered 1 through $n$. Each of the next $n$ lines contains two integers. Integers on the $v$-th line, $x_v$ ($0 \\leq x_v \\leq 1000$) and $y_v$ ($0 \\leq y_v \\leq 1000$), denote the coordinates of the point corresponding to the vertex $v$. Vertices correspond to distinct points, i.e., $(x_u, y_u) \\neq (x_v, y_v)$ holds for $u \\neq v$. Each of the next $m$ lines contains two integers. Integers on the $i$-th line, $u_i$ and $v_i$, with $1 \\leq u_i < v_i \\leq n$, mean that there is an edge connecting two vertices $u_i$ and $v_i$.\n", "outputFormat": "The output should consist of $n$ lines. The $v$-th line of the output should contain one integer $c_v \\in \\{1, 2, 3, 4\\}$ which means that the vertex $v$ is to be colored $c_v$. The output must satisfy $c_u \\neq c_v$ for every edge connecting $u$ and $v$ in the graph. If there are multiple solutions, you may output any one of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 Yokohama R] Four-Coloring", "background": "", "description": "给定一个连通图的平面嵌入。图中的每个顶点对应于一个具有整数坐标的不同点。两个顶点之间的每条边对应于连接这两个顶点对应点的直线段。由于给定的嵌入是平面的，对应边的线段除公共端点外不共享任何点。给定的嵌入被组织成使得所有线段的倾斜度都是 $45$ 度的倍数。换句话说，对于存在边的两个顶点 $u$ 和 $v$，其对应坐标分别为 $(x_u, y_u)$ 和 $(x_v, y_v)$，则满足 $x_u = x_v$、$y_u = y_v$ 或 $|x_u - x_v| = |y_u - y_v|$ 中的一个。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8knyacui.png)\n\n图 H.1. 样例输入 1 和 2\n:::\n\n你的任务是为每个顶点涂上四种颜色 $\\{1, 2, 3, 4\\}$ 中的一种，使得有边连接的两个顶点颜色不同。根据著名的四色定理，这样的着色总是可能的。请找出一种着色方案。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n& n \\; m \\\\\n& x_1 \\; y_1 \\\\\n& \\vdots \\\\\n& x_n \\; y_n \\\\\n& u_1 \\; v_1 \\\\\n& \\vdots \\\\\n& u_m \\; v_m\n\\end{aligned}\n$$\n\n第一行包含两个整数 $n$ 和 $m$。$n$ 是顶点数，$m$ 是边数，满足 $3 \\leq n \\leq m \\leq 10\\,000$。顶点编号为 $1$ 到 $n$。接下来的 $n$ 行中，每行包含两个整数。第 $v$ 行的整数 $x_v$ （$0 \\leq x_v \\leq 1000$）和 $y_v$ （$0 \\leq y_v \\leq 1000$）表示顶点 $v$ 对应点的坐标。顶点对应于不同的点，即对于 $u \\neq v$，满足 $(x_u, y_u) \\neq (x_v, y_v)$。接下来的 $m$ 行中，每行包含两个整数。第 $i$ 行的整数 $u_i$ 和 $v_i$，满足 $1 \\leq u_i < v_i \\leq n$，表示存在一条连接顶点 $u_i$ 和 $v_i$ 的边。", "outputFormat": "输出应由 $n$ 行组成。输出的第 $v$ 行应包含一个整数 $c_v \\in \\{1, 2, 3, 4\\}$，表示顶点 $v$ 将被涂色为 $c_v$。输出必须满足对于图中每条连接 $u$ 和 $v$ 的边，都有 $c_u \\neq c_v$。如果有多个解，你可以输出其中任意一个。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14901", "type": "P", "difficulty": 6, "samples": [["2 3\n001\n101", "-0-\n-00"], ["5 4\n1111\n1000\n1000\n1000\n1000", "0000\n0+++\n0+++\n0+++\n0+++"], ["10 10\n1000001001\n0000010100\n0000100010\n0001000001\n0010000010\n0100000100\n1000001000\n0000010000\n0000100000\n0001000001", "000-00000-\n0-00000-00\n00-00000-0\n+00000+000\n00-0000000\n0-00000000\n000-00000-\n0-000-0-00\n00-0-000-0\n+00000+000"], ["1 1\n0", "+"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "线性代数", "高斯消元", "ICPC", "横浜"], "title": "[ICPC 2018 Yokohama R] Ranks", "background": "", "description": "A finite field $\\mathbf{F}_2$ consists of two elements: $0$ and $1$. Addition and multiplication on $\\mathbf{F}_2$ are those on integers modulo two, as defined below.\n\n||||\n|:-:|:-:|:-:|\n|$\\boldsymbol{+}$|$\\mathbf{0}$|$\\mathbf{1}$|\n|$\\mathbf{0}$|$\\mathbf{0}$|$\\mathbf{1}$|\n|$\\mathbf{1}$|$\\mathbf{1}$|$\\mathbf{0}$|\n\n||||\n|:-:|:-:|:-:|\n|$\\boldsymbol{\\times}$|$\\mathbf{0}$|$\\mathbf{1}$|\n|$\\mathbf{0}$|$\\mathbf{0}$|$\\mathbf{0}$|\n|$\\mathbf{1}$|$\\mathbf{0}$|$\\mathbf{1}$|\n\nA set of vectors $\\mathbf{v}_1, \\ldots, \\mathbf{v}_k$ over $\\mathbf{F}_2$ with the same dimension is said to be **linearly independent** when, for $c_1, \\ldots, c_k \\in \\mathbf{F}_2$, $c_1 \\mathbf{v}_1 + \\cdots + c_k \\mathbf{v}_k = \\mathbf{0}$ is equivalent to $c_1 = \\cdots = c_k = 0$, where $\\mathbf{0}$ is the zero vector, the vector with all its elements being zero.\n\nThe **rank** of a matrix is the maximum cardinality of its linearly independent sets of column vectors. For example, the rank of the matrix $\\begin{bmatrix} 0 & 0 & 1 \\\\ 1 & 0 & 1 \\end{bmatrix}$ is two; the column vectors $\\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$ and $\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$ (the first and the third columns) are linearly independent while the set of all three column vectors is **not** linearly independent. Note that the rank is zero for the zero matrix.\n\nGiven the above definition of the rank of matrices, the following may be an intriguing question. How does a modification of an entry in a matrix change the rank of the matrix? To investigate this question, let us suppose that we are given a matrix $A$ over $\\mathbf{F}_2$. For any indices $i$ and $j$, let $A^{(ij)}$ be a matrix equivalent to $A$ except that the $(i,j)$ entry is flipped.\n\n$$\nA^{(ij)}_{kl} = \\begin{cases}\nA_{kl} + 1 & (k = i \\text{ and } l = j) \\\\\nA_{kl} & (\\text{otherwise})\n\\end{cases}\n$$\n\nIn this problem, we are interested in the rank of the matrix $A^{(ij)}$. Let us denote the rank of $A$ by $r$, and that of $A^{(ij)}$ by $r^{(ij)}$. Your task is to determine, for all $(i,j)$ entries, the relation of ranks before and after flipping the entry out of the following possibilities: (i) $r^{(ij)} < r$, (ii) $r^{(ij)} = r$, or (iii) $r^{(ij)} > r$.\n", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n& n \\; m \\\\\n& A_{11} \\ldots A_{1m} \\\\\n& \\vdots \\\\\n& A_{n1} \\ldots A_{nm}\n\\end{aligned}\n$$\n\n$n$ and $m$ are the numbers of rows and columns in the matrix $A$, respectively ($1 \\leq n \\leq 1000$, $1 \\leq m \\leq 1000$). In the next $n$ lines, the entries of $A$ are listed without spaces in between. $A_{ij}$ is the entry in the $i$-th row and $j$-th column, which is either $0$ or $1$.", "outputFormat": "Output $n$ lines, each consisting of $m$ characters. The character in the $i$-th line at the $j$-th position must be either $-$ (minus), $0$ (zero), or $+$ (plus). They correspond to the possibilities (i), (ii), and (iii) in the problem statement respectively.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 Yokohama R] Ranks", "background": "", "description": "A finite field $\\mathbf{F}_2$ consists of two elements: $0$ and $1$. Addition and multiplication on $\\mathbf{F}_2$ are those on integers modulo two, as defined below.\n\n||||\n|:-:|:-:|:-:|\n|$\\boldsymbol{+}$|$\\mathbf{0}$|$\\mathbf{1}$|\n|$\\mathbf{0}$|$\\mathbf{0}$|$\\mathbf{1}$|\n|$\\mathbf{1}$|$\\mathbf{1}$|$\\mathbf{0}$|\n\n||||\n|:-:|:-:|:-:|\n|$\\boldsymbol{\\times}$|$\\mathbf{0}$|$\\mathbf{1}$|\n|$\\mathbf{0}$|$\\mathbf{0}$|$\\mathbf{0}$|\n|$\\mathbf{1}$|$\\mathbf{0}$|$\\mathbf{1}$|\n\nA set of vectors $\\mathbf{v}_1, \\ldots, \\mathbf{v}_k$ over $\\mathbf{F}_2$ with the same dimension is said to be **linearly independent** when, for $c_1, \\ldots, c_k \\in \\mathbf{F}_2$, $c_1 \\mathbf{v}_1 + \\cdots + c_k \\mathbf{v}_k = \\mathbf{0}$ is equivalent to $c_1 = \\cdots = c_k = 0$, where $\\mathbf{0}$ is the zero vector, the vector with all its elements being zero.\n\nThe **rank** of a matrix is the maximum cardinality of its linearly independent sets of column vectors. For example, the rank of the matrix $\\begin{bmatrix} 0 & 0 & 1 \\\\ 1 & 0 & 1 \\end{bmatrix}$ is two; the column vectors $\\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$ and $\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$ (the first and the third columns) are linearly independent while the set of all three column vectors is **not** linearly independent. Note that the rank is zero for the zero matrix.\n\nGiven the above definition of the rank of matrices, the following may be an intriguing question. How does a modification of an entry in a matrix change the rank of the matrix? To investigate this question, let us suppose that we are given a matrix $A$ over $\\mathbf{F}_2$. For any indices $i$ and $j$, let $A^{(ij)}$ be a matrix equivalent to $A$ except that the $(i,j)$ entry is flipped.\n\n$$\nA^{(ij)}_{kl} = \\begin{cases}\nA_{kl} + 1 & (k = i \\text{ and } l = j) \\\\\nA_{kl} & (\\text{otherwise})\n\\end{cases}\n$$\n\nIn this problem, we are interested in the rank of the matrix $A^{(ij)}$. Let us denote the rank of $A$ by $r$, and that of $A^{(ij)}$ by $r^{(ij)}$. Your task is to determine, for all $(i,j)$ entries, the relation of ranks before and after flipping the entry out of the following possibilities: (i) $r^{(ij)} < r$, (ii) $r^{(ij)} = r$, or (iii) $r^{(ij)} > r$.\n", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n& n \\; m \\\\\n& A_{11} \\ldots A_{1m} \\\\\n& \\vdots \\\\\n& A_{n1} \\ldots A_{nm}\n\\end{aligned}\n$$\n\n$n$ and $m$ are the numbers of rows and columns in the matrix $A$, respectively ($1 \\leq n \\leq 1000$, $1 \\leq m \\leq 1000$). In the next $n$ lines, the entries of $A$ are listed without spaces in between. $A_{ij}$ is the entry in the $i$-th row and $j$-th column, which is either $0$ or $1$.", "outputFormat": "Output $n$ lines, each consisting of $m$ characters. The character in the $i$-th line at the $j$-th position must be either $-$ (minus), $0$ (zero), or $+$ (plus). They correspond to the possibilities (i), (ii), and (iii) in the problem statement respectively.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 Yokohama R] Ranks", "background": "", "description": "有限域 $\\mathbf{F}_2$ 由两个元素组成：$0$ 和 $1$。$\\mathbf{F}_2$ 上的加法和乘法是模 $2$ 的整数运算，定义如下。\n\n|$\\boldsymbol{+}$|$\\mathbf{0}$|$\\mathbf{1}$|\n|:-:|:-:|:-:|\n|$\\mathbf{0}$|$\\mathbf{0}$|$\\mathbf{1}$|\n|$\\mathbf{1}$|$\\mathbf{1}$|$\\mathbf{0}$|\n\n|$\\boldsymbol{\\times}$|$\\mathbf{0}$|$\\mathbf{1}$|\n|:-:|:-:|:-:|\n|$\\mathbf{0}$|$\\mathbf{0}$|$\\mathbf{0}$|\n|$\\mathbf{1}$|$\\mathbf{0}$|$\\mathbf{1}$|\n\n具有相同维数的一组向量 $\\mathbf{v}_1, \\ldots, \\mathbf{v}_k$（在 $\\mathbf{F}_2$ 上）被称为**线性无关**，如果对于 $c_1, \\ldots, c_k \\in \\mathbf{F}_2$，$c_1 \\mathbf{v}_1 + \\cdots + c_k \\mathbf{v}_k = \\mathbf{0}$ 等价于 $c_1 = \\cdots = c_k = 0$，其中 $\\mathbf{0}$ 是零向量，即所有元素均为零的向量。\n\n矩阵的**秩**是其列向量线性无关集合的最大基数。例如，矩阵 $\\begin{bmatrix} 0 & 0 & 1 \\\\ 1 & 0 & 1 \\end{bmatrix}$ 的秩是二；列向量 $\\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$ 和 $\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$（第一列和第三列）是线性无关的，而所有三个列向量的集合**不是**线性无关的。注意，零矩阵的秩为零。\n\n给定上述矩阵秩的定义，以下可能是一个有趣的问题：修改矩阵中的一个元素会如何改变矩阵的秩？为了研究这个问题，假设我们给定一个 $\\mathbf{F}_2$ 上的矩阵 $A$。对于任意索引 $i$ 和 $j$，令 $A^{(ij)}$ 为一个与 $A$ 相同的矩阵，除了第 $(i,j)$ 个元素被翻转（即从 $0$ 变为 $1$ 或从 $1$ 变为 $0$）。\n\n$$\nA^{(ij)}_{kl} = \\begin{cases}\nA_{kl} + 1 & (k = i \\text{ 且 } l = j) \\\\\nA_{kl} & (\\text{其他情况})\n\\end{cases}\n$$\n\n在本问题中，我们关注矩阵 $A^{(ij)}$ 的秩。令 $A$ 的秩为 $r$，$A^{(ij)}$ 的秩为 $r^{(ij)}$。你的任务是针对所有 $(i,j)$ 位置，在翻转该位置的元素后，判断秩的关系属于以下哪种可能性：(i) $r^{(ij)} < r$，(ii) $r^{(ij)} = r$，或 (iii) $r^{(ij)} > r$。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n& n \\; m \\\\\n& A_{11} \\ldots A_{1m} \\\\\n& \\vdots \\\\\n& A_{n1} \\ldots A_{nm}\n\\end{aligned}\n$$\n\n$n$ 和 $m$ 分别是矩阵 $A$ 的行数和列数（$1 \\leq n \\leq 1000$，$1 \\leq m \\leq 1000$）。接下来的 $n$ 行中，按行列出 $A$ 的元素，元素之间没有空格。$A_{ij}$ 是第 $i$ 行第 $j$ 列的元素，取值为 $0$ 或 $1$。\n", "outputFormat": "输出 $n$ 行，每行包含 $m$ 个字符。第 $i$ 行第 $j$ 个位置的字符必须是 $-$（减号）、$0$（零）或 $+$（加号）。它们分别对应问题描述中的可能性 (i)、(ii) 和 (iii)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14902", "type": "P", "difficulty": 5, "samples": [["5\n1 2\n2 3\n3 4\n2 5\n1 2 1 2 3\n11\nQ 1\nQ 2\nQ 3\nQ 4\nU 5 1\nQ 1\nU 3 2\nQ 1\nQ 2\nU 5 4\nQ 1", "2\n2\n0\n-1\n3\n2\n2\n0"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2018", "最近公共祖先 LCA", "ICPC", "横浜"], "title": "[ICPC 2018 Yokohama R] Colorful Tree", "background": "", "description": "A tree structure with some colors associated with its vertices and a sequence of commands on it are given. A command is either an update operation or a query on the tree. Each of the update operations changes the color of a specified vertex, without changing the tree structure. Each of the queries asks the number of edges in the minimum connected subgraph of the tree that contains all the vertices of the specified color.\n\nYour task is to find answers of each of the queries, assuming that the commands are performed in the given order.\n\n", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n& n \\\\\n& a_1 \\; b_1 \\\\\n& \\vdots \\\\\n& a_{n-1} \\; b_{n-1} \\\\\n& c_1 \\; \\ldots \\; c_n \\\\\n& m \\\\\n& command_1 \\\\\n& \\vdots \\\\\n& command_m\n\\end{aligned}\n$$\n\nThe first line contains an integer $n$ ($2 \\leq n \\leq 100\\,000$), the number of vertices of the tree. The vertices are numbered $1$ through $n$. Each of the following $n-1$ lines contains two integers $a_i$ ($1 \\leq a_i \\leq n$) and $b_i$ ($1 \\leq b_i \\leq n$), meaning that the $i$-th edge connects vertices $a_i$ and $b_i$. It is ensured that all the vertices are connected, that is, the given graph is a tree. The next line contains $n$ integers, $c_1$ through $c_n$, where $c_j$ ($1 \\leq c_j \\leq 100\\,000$) is the initial color of vertex $j$. The next line contains an integer $m$ ($1 \\leq m \\leq 100\\,000$), which indicates the number of commands. Each of the following $m$ lines contains a command in the following format.\n\n$$\\text{U} \\; x_k \\; y_k$$\n\nor\n\n$$\\text{Q} \\; y_k$$\n\nWhen the $k$-th command starts with U, it means an update operation changing the color of vertex $x_k$ ($1 \\leq x_k \\leq n$) to $y_k$ ($1 \\leq y_k \\leq 100\\,000$). When the $k$-th command starts with Q, it means a query asking the number of edges in the minimum connected subgraph of the tree that contains all the vertices of color $y_k$ ($1 \\leq y_k \\leq 100\\,000$).\n", "outputFormat": "For each query, output the number of edges in the minimum connected subgraph of the tree containing all the vertices of the specified color. If the tree doesn’t contain any vertex of the specified color, output $-1$ instead.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 Yokohama R] Colorful Tree", "background": "", "description": "A tree structure with some colors associated with its vertices and a sequence of commands on it are given. A command is either an update operation or a query on the tree. Each of the update operations changes the color of a specified vertex, without changing the tree structure. Each of the queries asks the number of edges in the minimum connected subgraph of the tree that contains all the vertices of the specified color.\n\nYour task is to find answers of each of the queries, assuming that the commands are performed in the given order.\n\n", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n& n \\\\\n& a_1 \\; b_1 \\\\\n& \\vdots \\\\\n& a_{n-1} \\; b_{n-1} \\\\\n& c_1 \\; \\ldots \\; c_n \\\\\n& m \\\\\n& command_1 \\\\\n& \\vdots \\\\\n& command_m\n\\end{aligned}\n$$\n\nThe first line contains an integer $n$ ($2 \\leq n \\leq 100\\,000$), the number of vertices of the tree. The vertices are numbered $1$ through $n$. Each of the following $n-1$ lines contains two integers $a_i$ ($1 \\leq a_i \\leq n$) and $b_i$ ($1 \\leq b_i \\leq n$), meaning that the $i$-th edge connects vertices $a_i$ and $b_i$. It is ensured that all the vertices are connected, that is, the given graph is a tree. The next line contains $n$ integers, $c_1$ through $c_n$, where $c_j$ ($1 \\leq c_j \\leq 100\\,000$) is the initial color of vertex $j$. The next line contains an integer $m$ ($1 \\leq m \\leq 100\\,000$), which indicates the number of commands. Each of the following $m$ lines contains a command in the following format.\n\n$$\\text{U} \\; x_k \\; y_k$$\n\nor\n\n$$\\text{Q} \\; y_k$$\n\nWhen the $k$-th command starts with U, it means an update operation changing the color of vertex $x_k$ ($1 \\leq x_k \\leq n$) to $y_k$ ($1 \\leq y_k \\leq 100\\,000$). When the $k$-th command starts with Q, it means a query asking the number of edges in the minimum connected subgraph of the tree that contains all the vertices of color $y_k$ ($1 \\leq y_k \\leq 100\\,000$).\n", "outputFormat": "For each query, output the number of edges in the minimum connected subgraph of the tree containing all the vertices of the specified color. If the tree doesn’t contain any vertex of the specified color, output $-1$ instead.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 Yokohama R] Colorful Tree", "background": "", "description": "给定一棵树，其顶点关联着一些颜色，以及一个对该树的操作命令序列。命令要么是更新操作，要么是查询操作。每个更新操作会改变指定顶点的颜色，而不改变树的结构。每个查询会询问树中包含所有指定颜色顶点的最小连通子图中的边数。\n\n你的任务是假设命令按给定顺序执行，找出每个查询的答案。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n& n \\\\\n& a_1 \\; b_1 \\\\\n& \\vdots \\\\\n& a_{n-1} \\; b_{n-1} \\\\\n& c_1 \\; \\ldots \\; c_n \\\\\n& m \\\\\n& command_1 \\\\\n& \\vdots \\\\\n& command_m\n\\end{aligned}\n$$\n\n第一行包含一个整数 $n$ （$2 \\leq n \\leq 100\\,000$），表示树的顶点数。顶点编号为 $1$ 到 $n$。接下来的 $n-1$ 行中，每行包含两个整数 $a_i$ （$1 \\leq a_i \\leq n$）和 $b_i$ （$1 \\leq b_i \\leq n$），表示第 $i$ 条边连接顶点 $a_i$ 和 $b_i$。确保所有顶点都是连通的，即给定的图是一棵树。下一行包含 $n$ 个整数 $c_1$ 到 $c_n$，其中 $c_j$ （$1 \\leq c_j \\leq 100\\,000$）是顶点 $j$ 的初始颜色。接下来一行包含一个整数 $m$ （$1 \\leq m \\leq 100\\,000$），表示命令的数量。接下来的 $m$ 行中，每行包含一个以下格式的命令。\n\n$$\\text{U} \\; x_k \\; y_k$$\n\n或\n\n$$\\text{Q} \\; y_k$$\n\n当第 $k$ 个命令以 U 开头时，表示一个更新操作，将顶点 $x_k$ （$1 \\leq x_k \\leq n$）的颜色更改为 $y_k$ （$1 \\leq y_k \\leq 100\\,000$）。当第 $k$ 个命令以 Q 开头时，表示一个查询，询问树中包含所有颜色为 $y_k$ （$1 \\leq y_k \\leq 100\\,000$）的顶点的最小连通子图中的边数。", "outputFormat": "对于每个查询，输出树中包含所有指定颜色顶点的最小连通子图中的边数。如果树中不包含任何具有指定颜色的顶点，则输出 $-1$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14903", "type": "P", "difficulty": 5, "samples": [["5\n1 2 3 4 5\n1 2 3 4 5", "2 3 4 5 1"], ["5\n3 4 5 6 7\n1 3 5 7 9", "9 5 7 3 1"], ["5\n3 2 2 1 1\n1 1 2 2 3", "1 3 1 2 2"], ["5\n3 4 10 4 9\n2 7 3 6 9", "9 7 3 6 2"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2018", "二分", "ICPC", "横浜"], "title": "[ICPC 2018 Yokohama R] Sixth Sense", "background": "", "description": "Ms. Future is gifted with precognition. Naturally, she is excellent at some card games since she can correctly foresee every player’s actions, except her own. Today, she accepted a challenge from a reckless gambler Mr. Past. They agreed to play a simple two-player trick-taking card game.\n\nCards for the game have a number printed on one side, leaving the other side blank making indistinguishable from other cards.\n\nA game starts with the same number, say $n$, of cards being handed out to both players, without revealing the printed number to the opponent.\n\nA game consists of $n$ tricks. In each trick, both players pull one card out of her/his hand. The player pulling out the card with the larger number takes this trick. Because Ms. Future is extremely good at this game, they have agreed to give tricks to Mr. Past when both pull out cards with the same number. Once a card is used, it can never be used later in the same game. The game continues until all the cards in the hands are used up. The objective of the game is to take as many tricks as possible.\n\nYour mission of this problem is to help Ms. Future by providing a computer program to determine the best playing order of the cards in her hand. Since she has the sixth sense, your program can utilize information that is not available to ordinary people before the game.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n& n \\\\\n& p_1 \\; \\cdots \\; p_n \\\\\n& f_1 \\; \\cdots \\; f_n\n\\end{aligned}\n$$\n\n$n$ in the first line is the number of tricks, which is an integer between $2$ and $5000$, inclusive. The second line represents the Mr. Past’s playing order of the cards in his hand. In the $i$-th trick, he will pull out a card with the number $p_i$ ($1 \\leq i \\leq n$). The third line represents the Ms. Future’s hand. $f_i$ ($1 \\leq i \\leq n$) is the number that she will see on the $i$-th received card from the dealer. Every number in the second or third line is an integer between $1$ and $10\\,000$, inclusive. These lines may have duplicate numbers.", "outputFormat": "The output should be a single line containing $n$ integers $a_1 \\; \\cdots \\; a_n$ separated by a space, where $a_i$ ($1 \\leq i \\leq n$) is the number on the card she should play at the $i$-th trick for maximizing the number of taken tricks. If there are two or more such sequences of numbers, output the lexicographically greatest one among them.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2018 Yokohama R] Sixth Sense", "background": "", "description": "Ms. Future is gifted with precognition. Naturally, she is excellent at some card games since she can correctly foresee every player’s actions, except her own. Today, she accepted a challenge from a reckless gambler Mr. Past. They agreed to play a simple two-player trick-taking card game.\n\nCards for the game have a number printed on one side, leaving the other side blank making indistinguishable from other cards.\n\nA game starts with the same number, say $n$, of cards being handed out to both players, without revealing the printed number to the opponent.\n\nA game consists of $n$ tricks. In each trick, both players pull one card out of her/his hand. The player pulling out the card with the larger number takes this trick. Because Ms. Future is extremely good at this game, they have agreed to give tricks to Mr. Past when both pull out cards with the same number. Once a card is used, it can never be used later in the same game. The game continues until all the cards in the hands are used up. The objective of the game is to take as many tricks as possible.\n\nYour mission of this problem is to help Ms. Future by providing a computer program to determine the best playing order of the cards in her hand. Since she has the sixth sense, your program can utilize information that is not available to ordinary people before the game.", "inputFormat": "The input consists of a single test case of the following format.\n\n$$\n\\begin{aligned}\n& n \\\\\n& p_1 \\; \\cdots \\; p_n \\\\\n& f_1 \\; \\cdots \\; f_n\n\\end{aligned}\n$$\n\n$n$ in the first line is the number of tricks, which is an integer between $2$ and $5000$, inclusive. The second line represents the Mr. Past’s playing order of the cards in his hand. In the $i$-th trick, he will pull out a card with the number $p_i$ ($1 \\leq i \\leq n$). The third line represents the Ms. Future’s hand. $f_i$ ($1 \\leq i \\leq n$) is the number that she will see on the $i$-th received card from the dealer. Every number in the second or third line is an integer between $1$ and $10\\,000$, inclusive. These lines may have duplicate numbers.", "outputFormat": "The output should be a single line containing $n$ integers $a_1 \\; \\cdots \\; a_n$ separated by a space, where $a_i$ ($1 \\leq i \\leq n$) is the number on the card she should play at the $i$-th trick for maximizing the number of taken tricks. If there are two or more such sequences of numbers, output the lexicographically greatest one among them.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2018 Yokohama R] Sixth Sense", "background": "", "description": "Future 女士拥有预知能力。自然地，她在某些纸牌游戏中表现出色，因为她能准确预见到除自己外所有玩家的行动。今天，她接受了一位鲁莽的赌徒 Past 先生的挑战。他们同意玩一个简单的两人吃墩纸牌游戏。\n\n游戏用的纸牌一面印有数字，另一面为空白，使得不同牌之间无法区分。\n\n游戏开始时，每位玩家都分到相同数量的牌，例如 $n$ 张，且不向对手展示牌面上的数字。\n\n一场游戏由 $n$ 个墩组成。在每个墩中，双方各从手牌中打出一张牌。打出数字较大的牌的玩家赢得该墩。由于 Future 女士非常擅长这个游戏，他们约定当双方打出数字相同的牌时，该墩归 Past 先生所有。一旦一张牌被使用过，在同一场游戏中就不能再次使用。游戏持续进行，直到手牌全部用完。游戏的目标是赢得尽可能多的墩。\n\n你在这个问题中的任务是通过提供一个计算机程序来帮助 Future 女士，确定她手牌的最佳出牌顺序。由于她拥有第六感，你的程序可以利用游戏开始前普通人无法获得的信息。", "inputFormat": "输入包含单个测试用例，格式如下。\n\n$$\n\\begin{aligned}\n& n \\\\\n& p_1 \\; \\cdots \\; p_n \\\\\n& f_1 \\; \\cdots \\; f_n\n\\end{aligned}\n$$\n\n第一行的 $n$ 是墩的数量，是一个介于 $2$ 到 $5000$ 之间（含）的整数。第二行代表 Past 先生手牌中的出牌顺序。在第 $i$ 墩，他将打出一张数字为 $p_i$ 的牌（$1 \\leq i \\leq n$）。第三行代表 Future 女士的手牌。$f_i$ （$1 \\leq i \\leq n$）是她从发牌者处收到的第 $i$ 张牌上看到的数字。第二行或第三行中的每个数字都是介于 $1$ 到 $10\\,000$ 之间（含）的整数。这些行中可能有重复的数字。", "outputFormat": "输出应为一整行，包含 $n$ 个由空格分隔的整数 $a_1 \\; \\cdots \\; a_n$，其中 $a_i$ （$1 \\leq i \\leq n$）是她在第 $i$ 墩为了最大化赢得墩数所应打出的牌上的数字。如果有两个或更多这样的数字序列，输出其中字典序最大的一个。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14904", "type": "P", "difficulty": 2, "samples": [["5\n3 2 1 5 4\n8 6 10 9 7", "25"], ["5\n10 70 30 90 50\n71 31 51 91 11", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2024", "排序", "台湾"], "title": "[NHSPC 2024] 計程車叫車問題", "background": "", "description": "你是某計程車公司老闆，擁有 $m$ 台計程車。這些計程車都在 $x$ 軸上，位置分別是 $t_1, t_2, t_3, \\ldots,t_m$。同時，你接到 $m$ 名路人的搭車請求，這 $m$ 名路人也在 $x$ 軸上，位置分別是 $p_1, p_2, p_3, \\ldots, p_m$。我們假設上述 $2m$ 個座標均相異。你的任務是為每一位路人指派一台計程車，且每台計程車只能指派給一位路人。你的目標是最小化這 $m$ 台計程車到其指派路人的距離總和（稱此距離總和為叫車距離總和）。你的程式必須輸出最小叫車距離總和。\n\n舉例來說，如果你有 $2$ 台計程車（$m=2$），位置分別在 $100$ 與 $1$（$t_1=100, t_2=1$），而 $2$ 名路人位置分別在 $3$ 與 $101$（$p_1=3, p_2=101$），則最小叫車距離總和為 $|100-101|+|1-3|=3$。\n\n下圖顯示另一個例子。在這個例子中有$5$台計程車（$m=5$），位置分別在 $3, 2, 1, 5, 4$（$t_1=3, t_2=2, t_3=1, t_4=5, t_5=4$），而 $5$ 名路人位置分別在 $8, 6, 10, 9, 7$（$p_1=8, p_2=6, p_3=10, p_4=9, p_5=7$），則最小叫車距離總和為 $25$（下圖所顯示的計程車指派方式之叫車距離總和即為 $25$）。\n\n:::align{centered}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8j0ikn8g.png)\n:::\n", "inputFormat": "$$\n\\begin{aligned} \n&m \\\\ \n&t_1 \\ t_2 \\ \\ldots \\ t_m \\\\ \n&p_1 \\ p_2 \\ \\ldots \\ p_m \n\\end{aligned}\n$$ \n\n* $m$ 代表路人及計程車的數量。\n* $t_i$ 代表第 $i$ 輛計程車的位置。\n* $p_i$ 代表第 $i$ 個路人的位置。", "outputFormat": "$$a$$\n\n* $a$ 代表給定輸入的最小叫車距離總和。", "hint": "### 測資限制\n\n* $1 \\leq m \\leq 10^6$。\n* $1 \\leq t_i \\leq 2 \\times 10^6$。\n* $1 \\leq p_i \\leq 2 \\times 10^6$。\n* 保證給定的 $2m$ 個座標均相異。\n\n### 評分說明\n\n本題共有兩組子任務，條件限制如下所示。\n每一組可有一或多筆測試資料，該組所有測試資料皆需答對才會獲得該組分數。\n\n|  子任務  |  分數  | 額外輸入限制 |\n| :------: | :----: | ------------ |\n| 1 | 40 | $\\max_i\\{t_i\\} < \\min_i\\{p_i\\}$。 |\n| 2 | 60 | 無額外限制。 |", "locale": "zh-Hant", "translations": {"zh-CN": {"title": "[NHSPC 2024] 计程车叫车问题", "background": "", "description": "你是某出租车公司老板，拥有 $m$ 台出租车。这些出租车都在 $x$ 轴上，位置分别是 $t_1, t_2, t_3, \\ldots,t_m$。同时，你接到 $m$ 名路人的搭车请求，这 $m$ 名路人也在 $x$ 轴上，位置分别是 $p_1, p_2, p_3, \\ldots, p_m$。我们假设上述 $2m$ 个坐标均相异。你的任务是为每一位路人指派一台出租车，且每台出租车只能指派给一位路人。你的目标是最小化这 $m$ 台出租车到其指派路人的距离总和（称此距离总和为叫车距离总和）。你的程序必须输出最小叫车距离总和。\n\n举例来说，如果你有 $2$ 台出租车（$m=2$），位置分别在 $100$ 与 $1$（$t_1=100, t_2=1$），而 $2$ 名路人位置分别在 $3$ 与 $101$（$p_1=3, p_2=101$），则最小叫车距离总和为 $|100-101|+|1-3|=3$。\n\n下图显示另一个例子。在这个例子中有 $5$ 台出租车（$m=5$），位置分别在 $3, 2, 1, 5, 4$（$t_1=3, t_2=2, t_3=1, t_4=5, t_5=4$），而 $5$ 名路人位置分别在 $8, 6, 10, 9, 7$（$p_1=8, p_2=6, p_3=10, p_4=9, p_5=7$），则最小叫车距离总和为 $25$（下图所显示的出租车指派方式之叫车距离总和即为 $25$）。\n\n:::align{centered}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8j0ikn8g.png)\n:::", "inputFormat": "$$\n\\begin{aligned} \n&m \\\\ \n&t_1 \\ t_2 \\ \\ldots \\ t_m \\\\ \n&p_1 \\ p_2 \\ \\ldots \\ p_m \n\\end{aligned}\n$$ \n\n* $m$ 代表路人及出租车的数量。\n* $t_i$ 代表第 $i$ 辆出租车的位置。\n* $p_i$ 代表第 $i$ 个路人的位置。", "outputFormat": "$$a$$\n\n* $a$ 代表给定输入的最小叫车距离总和。", "hint": "### 数据限制\n\n* $1 \\leq m \\leq 10^6$。\n* $1 \\leq t_i \\leq 2 \\times 10^6$。\n* $1 \\leq p_i \\leq 2 \\times 10^6$。\n* 保证给定的 $2m$ 个坐标均相异。\n\n### 评分说明\n\n本题共有两组子任务，条件限制如下所示。\n每一组可有一或多笔测试数据，该组所有测试数据皆需答对才会获得该组分数。\n\n|  子任务  |  分数  | 额外输入限制 |\n| :------: | :----: | ------------ |\n| 1 | 40 | $\\max_i\\{t_i\\} < \\min_i\\{p_i\\}$。 |\n| 2 | 60 | 无额外限制。 |", "locale": "zh-CN"}, "zh-Hant": {"title": "[NHSPC 2024] 計程車叫車問題", "background": "", "description": "你是某計程車公司老闆，擁有 $m$ 台計程車。這些計程車都在 $x$ 軸上，位置分別是 $t_1, t_2, t_3, \\ldots,t_m$。同時，你接到 $m$ 名路人的搭車請求，這 $m$ 名路人也在 $x$ 軸上，位置分別是 $p_1, p_2, p_3, \\ldots, p_m$。我們假設上述 $2m$ 個座標均相異。你的任務是為每一位路人指派一台計程車，且每台計程車只能指派給一位路人。你的目標是最小化這 $m$ 台計程車到其指派路人的距離總和（稱此距離總和為叫車距離總和）。你的程式必須輸出最小叫車距離總和。\n\n舉例來說，如果你有 $2$ 台計程車（$m=2$），位置分別在 $100$ 與 $1$（$t_1=100, t_2=1$），而 $2$ 名路人位置分別在 $3$ 與 $101$（$p_1=3, p_2=101$），則最小叫車距離總和為 $|100-101|+|1-3|=3$。\n\n下圖顯示另一個例子。在這個例子中有$5$台計程車（$m=5$），位置分別在 $3, 2, 1, 5, 4$（$t_1=3, t_2=2, t_3=1, t_4=5, t_5=4$），而 $5$ 名路人位置分別在 $8, 6, 10, 9, 7$（$p_1=8, p_2=6, p_3=10, p_4=9, p_5=7$），則最小叫車距離總和為 $25$（下圖所顯示的計程車指派方式之叫車距離總和即為 $25$）。\n\n:::align{centered}\n![](https://cdn.luogu.com.cn/upload/image_hosting/8j0ikn8g.png)\n:::\n", "inputFormat": "$$\n\\begin{aligned} \n&m \\\\ \n&t_1 \\ t_2 \\ \\ldots \\ t_m \\\\ \n&p_1 \\ p_2 \\ \\ldots \\ p_m \n\\end{aligned}\n$$ \n\n* $m$ 代表路人及計程車的數量。\n* $t_i$ 代表第 $i$ 輛計程車的位置。\n* $p_i$ 代表第 $i$ 個路人的位置。", "outputFormat": "$$a$$\n\n* $a$ 代表給定輸入的最小叫車距離總和。", "hint": "### 測資限制\n\n* $1 \\leq m \\leq 10^6$。\n* $1 \\leq t_i \\leq 2 \\times 10^6$。\n* $1 \\leq p_i \\leq 2 \\times 10^6$。\n* 保證給定的 $2m$ 個座標均相異。\n\n### 評分說明\n\n本題共有兩組子任務，條件限制如下所示。\n每一組可有一或多筆測試資料，該組所有測試資料皆需答對才會獲得該組分數。\n\n|  子任務  |  分數  | 額外輸入限制 |\n| :------: | :----: | ------------ |\n| 1 | 40 | $\\max_i\\{t_i\\} < \\min_i\\{p_i\\}$。 |\n| 2 | 60 | 無額外限制。 |", "locale": "zh-Hant"}}}
{"pid": "P14905", "type": "P", "difficulty": 4, "samples": [["RRGGBGB", "1"], ["GRRGBRB", "3"], ["aAaaAaa", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "枚举", "台湾"], "title": "[NHSPC 2024] 分漆付款", "background": "", "description": "兔子是「兔兔建設」的社長。最近公司的建設進度不如預期，經過兔子社長的調查後，發現原因出在負責運送油漆的粽子離職了！於是兔子社長決定雇用猩猩來完成原本粽子的工作。另外，在調查過程中兔子社長還發現，假如能在油漆搬運抵達之後將其進行分類，可以進一步提升裝潢部門的效率。於是兔子社長藉此機會，也將此任務安排給猩猩來完成。\n\n根據規定，搬運完成的油漆桶會被擺放成一列。由於油漆桶非常重，猩猩每次只能將兩桶相鄰的油漆交換位置。兔子社長給猩猩的要求是將所有相同顏色的油漆桶擺在一起。舉例來說，假設油漆總共有 7 桶，其顏色分為紅綠藍三種，分別以 `R`、`G`、`B` 表示，而初始時此 7 桶油漆從左到右的排列為：`RRGGBGB`，則猩猩只需要一次操作，便能把油漆桶排列為 `RRGGGBB`。又若初始時油漆桶的排列為：`GRRGBRB`，則猩猩最少只要三次操作，便能把油漆桶排列為 `GGRRRBB`。\n\n狡猾的兔子社長決定根據完成任務所需最少的交換次數來支付猩猩的薪水，假如給定油漆桶初始的排列，你能幫助猩猩算出最少的交換次數，來估計她應得的薪水嗎？", "inputFormat": "$$S$$\n\n- $S$ 為一個字串，代表油漆桶的排列順序，其中相同字符表示相同顏色的油漆桶，不同字符代表不同顏色。", "outputFormat": "$$m$$\n\n- $m$ 代表最少的交換次數。", "hint": "### 測資限制\n\n* $1 \\le |S| \\le {10}^{6}$。\n* $1 \\le \\textrm{distinct}(S) \\le 7$。\n* 字串 $S$ 由大小寫英文字母組成。\n* $\\textrm{distinct}(S)$ 代表字串 $S$ 中字元種類的數量。\n\n### 評分說明\n\n本題共有三組子任務，條件限制如下所示。\n每一組可有一或多筆測試資料，該組所有測試資料皆需答對才會獲得該組分數。\n\n|  子任務  |  分數  | 額外輸入限制 |\n| :------: | :----: | ------------ |\n| 1 | 21 | $\\textrm{distinct}(S) \\le 2$。 |\n| 2 | 26 | $1 \\le \\lvert S\\rvert \\le {10}^{3}$，$\\textrm{distinct}(S) \\le 3$。 |\n| 3 | 53 | 無額外限制。 |", "locale": "zh-Hant", "translations": {"zh-CN": {"title": "[NHSPC 2024] 分漆付款", "background": "", "description": "兔子是「兔兔建设」的社长。最近公司的建设进度不如预期，经过兔子社长的调查后，发现原因出在负责运送油漆的粽子离职了！于是兔子社长决定雇用猩猩来完成原本粽子的工作。另外，在调查过程中兔子社长还发现，假如能在油漆搬运抵达之后将其进行分类，可以进一步提升装潢部门的效率。于是兔子社长借此机会，也将此任务安排给猩猩来完成。\n\n根据规定，搬运完成的油漆桶会被摆放成一列。由于油漆桶非常重，猩猩每次只能将两桶相邻的油漆交换位置。兔子社长给猩猩的要求是将所有相同颜色的油漆桶摆在一起。举例来说，假设油漆总共有 7 桶，其颜色分为红绿蓝三种，分别以 `R`、`G`、`B` 表示，而初始时此 7 桶油漆从左到右的排列为：`RRGGBGB`，则猩猩只需要一次操作，便能把油漆桶排列为 `RRGGGBB`。又若初始时油漆桶的排列为：`GRRGBRB`，则猩猩最少只要三次操作，便能把油漆桶排列为 `GGRRRBB`。\n\n狡猾的兔子社长决定根据完成任务所需最少的交换次数来支付猩猩的薪水，假如给定油漆桶初始的排列，你能帮助猩猩算出最少的交换次数，来估计她应得的薪水吗？", "inputFormat": "$$S$$\n\n- $S$ 为一个字符串，代表油漆桶的排列顺序，其中相同字符表示相同颜色的油漆桶，不同字符代表不同颜色。\n", "outputFormat": "$$m$$\n\n- $m$ 代表最少的交换次数。", "hint": "### 数据限制\n\n* $1 \\le |S| \\le {10}^{6}$。\n* $1 \\le \\textrm{distinct}(S) \\le 7$。\n* 字符串 $S$ 由大小写英文字母组成。\n* $\\textrm{distinct}(S)$ 代表字符串 $S$ 中字符种类的数量。\n\n### 评分说明\n\n本题共有三组子任务，条件限制如下所示。\n每一组可有一或多笔测试数据，该组所有测试数据皆需答对才会获得该组分数。\n\n|  子任务  |  分数  | 额外输入限制 |\n| :------: | :----: | ------------ |\n| 1 | 21 | $\\textrm{distinct}(S) \\le 2$。 |\n| 2 | 26 | $1 \\le \\lvert S\\rvert \\le {10}^{3}$，$\\textrm{distinct}(S) \\le 3$。 |\n| 3 | 53 | 无额外限制。 |", "locale": "zh-CN"}, "zh-Hant": {"title": "[NHSPC 2024] 分漆付款", "background": "", "description": "兔子是「兔兔建設」的社長。最近公司的建設進度不如預期，經過兔子社長的調查後，發現原因出在負責運送油漆的粽子離職了！於是兔子社長決定雇用猩猩來完成原本粽子的工作。另外，在調查過程中兔子社長還發現，假如能在油漆搬運抵達之後將其進行分類，可以進一步提升裝潢部門的效率。於是兔子社長藉此機會，也將此任務安排給猩猩來完成。\n\n根據規定，搬運完成的油漆桶會被擺放成一列。由於油漆桶非常重，猩猩每次只能將兩桶相鄰的油漆交換位置。兔子社長給猩猩的要求是將所有相同顏色的油漆桶擺在一起。舉例來說，假設油漆總共有 7 桶，其顏色分為紅綠藍三種，分別以 `R`、`G`、`B` 表示，而初始時此 7 桶油漆從左到右的排列為：`RRGGBGB`，則猩猩只需要一次操作，便能把油漆桶排列為 `RRGGGBB`。又若初始時油漆桶的排列為：`GRRGBRB`，則猩猩最少只要三次操作，便能把油漆桶排列為 `GGRRRBB`。\n\n狡猾的兔子社長決定根據完成任務所需最少的交換次數來支付猩猩的薪水，假如給定油漆桶初始的排列，你能幫助猩猩算出最少的交換次數，來估計她應得的薪水嗎？", "inputFormat": "$$S$$\n\n- $S$ 為一個字串，代表油漆桶的排列順序，其中相同字符表示相同顏色的油漆桶，不同字符代表不同顏色。", "outputFormat": "$$m$$\n\n- $m$ 代表最少的交換次數。", "hint": "### 測資限制\n\n* $1 \\le |S| \\le {10}^{6}$。\n* $1 \\le \\textrm{distinct}(S) \\le 7$。\n* 字串 $S$ 由大小寫英文字母組成。\n* $\\textrm{distinct}(S)$ 代表字串 $S$ 中字元種類的數量。\n\n### 評分說明\n\n本題共有三組子任務，條件限制如下所示。\n每一組可有一或多筆測試資料，該組所有測試資料皆需答對才會獲得該組分數。\n\n|  子任務  |  分數  | 額外輸入限制 |\n| :------: | :----: | ------------ |\n| 1 | 21 | $\\textrm{distinct}(S) \\le 2$。 |\n| 2 | 26 | $1 \\le \\lvert S\\rvert \\le {10}^{3}$，$\\textrm{distinct}(S) \\le 3$。 |\n| 3 | 53 | 無額外限制。 |", "locale": "zh-Hant"}}}
