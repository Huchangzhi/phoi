{"pid": "P7030", "type": "P", "difficulty": 3, "samples": [["12\n", "3\n1 12\n3 2 3 2\n2 4 3\n"], ["1\n", "-1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2017", "二分", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2017] Little Difference", "background": "", "description": "\n\nLittle Lidia likes playing with numbers. Today she has a positive integer $n$ , and she wants to decompose it to the product of positive integers.\n\nBecause Lidia is little, she likes to play with numbers with little difference. So, all numbers in decomposition should differ by at most one. And of course, the product of all numbers in the decomposition must be equal to $n$ . She considers two decompositions the same if and only if they have the same number of integers and there is a permutation that transforms the first one to the second one.\n\nWrite a program that finds all decompositions, which little Lidia can play with today.\n\n", "inputFormat": "\n\nThe only line of the input contains a single integer $n (1 \\le n \\le 10^{18}).$\n\n", "outputFormat": "\n\nIn first line output the number of decompositions of $n$ , or $−1$ if this number is infinite. If number of decompositions is finite, print all of them one per line. In each line first print number $k_{i}$ of elements in decomposition. Then print $k_{i}$ integers in this decomposition in any order. Don't forget that decompositions which are different only in order of elements are considered the same.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en", "translations": {"en": {"title": "[NWRRC 2017] Little Difference", "background": "", "description": "\n\nLittle Lidia likes playing with numbers. Today she has a positive integer $n$ , and she wants to decompose it to the product of positive integers.\n\nBecause Lidia is little, she likes to play with numbers with little difference. So, all numbers in decomposition should differ by at most one. And of course, the product of all numbers in the decomposition must be equal to $n$ . She considers two decompositions the same if and only if they have the same number of integers and there is a permutation that transforms the first one to the second one.\n\nWrite a program that finds all decompositions, which little Lidia can play with today.\n\n", "inputFormat": "\n\nThe only line of the input contains a single integer $n (1 \\le n \\le 10^{18}).$\n\n", "outputFormat": "\n\nIn first line output the number of decompositions of $n$ , or $−1$ if this number is infinite. If number of decompositions is finite, print all of them one per line. In each line first print number $k_{i}$ of elements in decomposition. Then print $k_{i}$ integers in this decomposition in any order. Don't forget that decompositions which are different only in order of elements are considered the same.\n\n", "hint": "Time limit: 3 s, Memory limit: 512 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2017] Little Difference", "background": "", "description": "小莉迪亚喜欢玩数字。今天她有一个正整数 $n$，她想把它分解为若干个正整数的乘积。  \n\n因为莉迪亚还小，她喜欢玩差别很小的数字。所以，分解中的所有数字的差值最多为 1。当然，分解中所有数字的乘积必须等于 $n$。她认为两个分解相同当且仅当它们有相同数量的整数，并且存在一个排列可以将第一个分解变换为第二个分解。  \n\n编写一个程序，找出所有小莉迪亚今天可以玩的分解。", "inputFormat": "输入的唯一一行包含一个整数 $n (1 \\le n \\le 10^{18})$。", "outputFormat": "第一行输出 $n$ 的分解数量，如果这个数量是无限的则输出 $-1$。如果分解数量是有限的，逐行输出所有分解。在每一行中，首先输出分解中元素的数量 $k_{i}$。然后输出该分解中的 $k_{i}$ 个整数，顺序可以是任意的。不要忘记，仅在元素顺序上不同的分解被认为是相同的。", "hint": "时间限制：3 秒，内存限制：512 MB。  \n\nspj 提供者：@[shenyouran](\\/user\\/137367)。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7031", "type": "P", "difficulty": 1, "samples": [["7 3 2 2 3 2 \n", "0 0 4 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2016", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2016] Anniversary Cake", "background": "", "description": "\n\nTwo students, Adam and Anton, are celebrating two-year anniversary of not passing their Math $Logic exa_m.$ After very careful search in a local supermarket, they bought a rectangular cake with $integer dimensions$ and two candles.\n\nLater in the campus Adam put the candles into different integer points of the cake and gave a knife $to Anto_n$ to cut the cake. The cut should start and end at integer points at the edges of the cake, and $it should$ not touch the candles. Also each piece should have exactly one candle at it. Please, help $Anto_n to$ find the starting and ending points of the cut.\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13473/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-11-01%20%EC%98%A4%ED%9B%84%202.30.49.png)\n\nA $7 \\times 3$ cake and two candles at $(2 , 2)$ and $(3 , 2)$ .\n\nAnton can cut this cake through $(0 , 0)$ and $(4 , 3)$ .\n\n", "inputFormat": "\n\nThe single line of the input contains six integers: $w , h$ -- cake dimensions; $a_{x}, a_{y}$ -- $x$ and $y coordinates$ of the first candle; $b_{x}, b_{y}$ -- the coordinates of the second candle $(3 \\le w , h \\le 10^{9}; 0 < a_{x}, b_{x} < w$ ; $0 < a_{y}, b_{y} < h$ ; $a_{x} ≠ b_{x}$ or $a_{y }≠ b_{y}).$\n\n", "outputFormat": "\n\nOutput four integers $s_{x}, s_{y}, e_{x},$ and $e_{y}$ -- the starting and ending coordinates of the cut. Both $starting and$ ending point of the cut should belong to the sides of the cake.\n\nIf there are several solutions, output any of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\nspj provider:@[shenyouran](/user/137367)", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Anniversary Cake", "background": "", "description": "\n\nTwo students, Adam and Anton, are celebrating two-year anniversary of not passing their Math $Logic exa_m.$ After very careful search in a local supermarket, they bought a rectangular cake with $integer dimensions$ and two candles.\n\nLater in the campus Adam put the candles into different integer points of the cake and gave a knife $to Anto_n$ to cut the cake. The cut should start and end at integer points at the edges of the cake, and $it should$ not touch the candles. Also each piece should have exactly one candle at it. Please, help $Anto_n to$ find the starting and ending points of the cut.\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13473/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-11-01%20%EC%98%A4%ED%9B%84%202.30.49.png)\n\nA $7 \\times 3$ cake and two candles at $(2 , 2)$ and $(3 , 2)$ .\n\nAnton can cut this cake through $(0 , 0)$ and $(4 , 3)$ .\n\n", "inputFormat": "\n\nThe single line of the input contains six integers: $w , h$ -- cake dimensions; $a_{x}, a_{y}$ -- $x$ and $y coordinates$ of the first candle; $b_{x}, b_{y}$ -- the coordinates of the second candle $(3 \\le w , h \\le 10^{9}; 0 < a_{x}, b_{x} < w$ ; $0 < a_{y}, b_{y} < h$ ; $a_{x} ≠ b_{x}$ or $a_{y }≠ b_{y}).$\n\n", "outputFormat": "\n\nOutput four integers $s_{x}, s_{y}, e_{x},$ and $e_{y}$ -- the starting and ending coordinates of the cut. Both $starting and$ ending point of the cut should belong to the sides of the cake.\n\nIf there are several solutions, output any of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\nspj provider:@[shenyouran](/user/137367)", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Anniversary Cake", "background": "", "description": "两个学生，Adam 和 Anton，正在庆祝他们未通过数学逻辑考试两周年。在当地超市经过仔细挑选后，他们买了一个长方形的蛋糕，蛋糕的尺寸是整数，并且有两根蜡烛。\n\n后来在校园里，Adam 把蜡烛插在蛋糕的不同整数点上，并把刀交给 Anton 来切蛋糕。切口应该从蛋糕边缘的整数点开始和结束，并且不能碰到蜡烛。每一块蛋糕上应该正好有一根蜡烛。请帮助 Anton 找到切口的起点和终点。\n\n一个 $7 \\times 3$ 的蛋糕和两个蜡烛放在 $(2, 2)$ 和 $(3, 2)$。\n\nAnton 可以从 $(0, 0)$ 到 $(4, 3)$ 切开这个蛋糕。", "inputFormat": "输入的单行包含六个整数：$w, h$ —— 蛋糕的尺寸；$a_{x}, a_{y}$ —— 第一根蜡烛的 $x$ 和 $y$ 坐标；$b_{x}, b_{y}$ —— 第二根蜡烛的坐标（$3 \\le w, h \\le 10^{9}; 0 < a_{x}, b_{x} < w; 0 < a_{y}, b_{y} < h; a_{x} \neq b_{x}$ 或 $a_{y} \neq b_{y}$）。", "outputFormat": "输出四个整数 $s_{x}, s_{y}, e_{x}, e_{y}$ —— 切口的起点和终点坐标。切口的起点和终点都应该在蛋糕的边缘上。\n\n如果有多个解决方案，输出其中任意一个。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\nspj 提供者：@[shenyouran](\\/user\\/137367)\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7032", "type": "P", "difficulty": 6, "samples": [["10 5 7\n", "BGBGBGBGGG\n"], ["10 3 8\n", "Impossible\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2016] Boys and Girls", "background": "", "description": "\n\nBob found a nice task in his old math book for children. It says:\n\nThere are $10$ children standing in a circle, $5$ of them stand next to a boy, and $7$ of them stand next to a girl. How is it possible?\n\nHere is the solution to the task. If $4$ boys and $6$ girls stand like this: BGBGBGBGGG, there are $5$ children who stand next to a boy (here they are underlined: BGBGBGBGGG), and $7$ children who stand next to a girl $(BGBGBGBGGG).$\n\nNow Bob wants to solve a generalized version of this task:\n\nThere are $n$ children standing in a circle, $x$ of them stand next to a boy, and $y$ of them stand next to a girl. How is it possible?\n\nHelp Bob by writing a program that solves the generalized task.\n\n", "inputFormat": "\n\nThe single line of the input contains three integers $n , x$ and $y (2 \\le n \\le 100 000$ ; $0 \\le x , y \\le n)$ .\n\n", "outputFormat": "\n\nIf there is a solution, output a string of length $n$ , describing the order of children in the circle. $Character ‘G'$ corresponds to a girl, character $‘B'$ corresponds to a boy. If there are several solutions, output any $of the_m.$\n\nIf there is no solution, output `Impossible`.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Boys and Girls", "background": "", "description": "\n\nBob found a nice task in his old math book for children. It says:\n\nThere are $10$ children standing in a circle, $5$ of them stand next to a boy, and $7$ of them stand next to a girl. How is it possible?\n\nHere is the solution to the task. If $4$ boys and $6$ girls stand like this: BGBGBGBGGG, there are $5$ children who stand next to a boy (here they are underlined: BGBGBGBGGG), and $7$ children who stand next to a girl $(BGBGBGBGGG).$\n\nNow Bob wants to solve a generalized version of this task:\n\nThere are $n$ children standing in a circle, $x$ of them stand next to a boy, and $y$ of them stand next to a girl. How is it possible?\n\nHelp Bob by writing a program that solves the generalized task.\n\n", "inputFormat": "\n\nThe single line of the input contains three integers $n , x$ and $y (2 \\le n \\le 100 000$ ; $0 \\le x , y \\le n)$ .\n\n", "outputFormat": "\n\nIf there is a solution, output a string of length $n$ , describing the order of children in the circle. $Character ‘G'$ corresponds to a girl, character $‘B'$ corresponds to a boy. If there are several solutions, output any $of the_m.$\n\nIf there is no solution, output `Impossible`.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Boys and Girls", "background": "", "description": "Bob在他那本给孩子们的旧数学书中找到了一个好任务。上面写着：\n\n有 $10$ 个孩子站成一个圆圈，其中 $5$ 个站在一个男孩旁边， $7$ 个站在一个女孩旁边。如何解决这个任务？\n\n这个任务的解决方案如下：如果 $4$ 个男孩和 $6$ 个女孩像这样站着：$bgbgbbggg$，那么有 555 个孩子站在一个男孩旁边（用粗体字标记：b**g**b**g**b**g**b**g**g**g**）， 777 个孩子站在一个女孩旁边（用粗体字标记：**b**g**b**g**b**g**bggg**）。\n\n现在Bob想解决这个任务的广义版本：\n\n有 $n$ 个孩子站在一个圆圈里，其中 $x$ 个孩子站在一个男孩旁边， $y$ 个孩子站在一个女孩旁边。如何解决这个任务？\n\n请编写一个程序来帮助Bob解决这个任务。", "inputFormat": "一行，包括三个整数 $n$ , $x$ , $y$ 。($2≤n≤100000$; $0≤x,y≤n$)", "outputFormat": "若有解，输出一个长度为 $n$ 的字符串，描述圆中元素的顺序。每个字符 $G$ 对应一个女孩，字符 $B$ 对应一个男孩。如果有多个解决方案，则输出其中任意一种。\n如果没有解决方案，输出```'Impossible'```\n。（不包括引号）", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7033", "type": "P", "difficulty": 4, "samples": [["4\n2 3\n3 2\n1 1\n4 5\n", "2\n2\n0\n3\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "ICPC", "NWRRC"], "title": "[NWRRC 2016] CodeCoder vs TopForces", "background": "", "description": "\n\nCompetitive programming is very popular in Byteland. In fact, every Bytelandian citizen is registered at two programming sites -- CodeCoder and TopForces. Each site maintains its own proprietary rating system. Each citizen has a unique integer rating at each site that approximates their skill. Greater rating corresponds to better skill.\n\nPeople of Byteland are naturally optimistic. Citizen A thinks that he has a chance to beat citizen B in a programming competition if there exists a sequence of Bytelandian citizens $A = P_{0}, P_{1},...,P_{k} = B$ for some $k \\ge 1$ such that for each $i (0 \\le i < k) , P_{i}$ has higher rating than $P_{i+1}$ at one or both sites.\n\nEach Bytelandian citizen wants to know how many other citizens they can possibly beat in a programming competition.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $n$ -- the number of citizens $(1 \\le n \\le 100 000)$ . $The following n$ lines contain information about ratings. The i-th of them contains two integers $CC_{i} and TF_{i}$ -- ratings of the i-th citizen at CodeCoder and TopForces $(1 \\le CC_{i}, TF_{i} \\le 10^{6}).$ All the ratings at each site are distinct.\n\n", "outputFormat": "\n\nFor each citizen $i$ output an integer $b_{i}$ -- how many other citizens they can possibly beat in a programming competition. Each $b_{i}$ should be printed in a separate line, in the order the citizens are given in the input.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] CodeCoder vs TopForces", "background": "", "description": "\n\nCompetitive programming is very popular in Byteland. In fact, every Bytelandian citizen is registered at two programming sites -- CodeCoder and TopForces. Each site maintains its own proprietary rating system. Each citizen has a unique integer rating at each site that approximates their skill. Greater rating corresponds to better skill.\n\nPeople of Byteland are naturally optimistic. Citizen A thinks that he has a chance to beat citizen B in a programming competition if there exists a sequence of Bytelandian citizens $A = P_{0}, P_{1},...,P_{k} = B$ for some $k \\ge 1$ such that for each $i (0 \\le i < k) , P_{i}$ has higher rating than $P_{i+1}$ at one or both sites.\n\nEach Bytelandian citizen wants to know how many other citizens they can possibly beat in a programming competition.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $n$ -- the number of citizens $(1 \\le n \\le 100 000)$ . $The following n$ lines contain information about ratings. The i-th of them contains two integers $CC_{i} and TF_{i}$ -- ratings of the i-th citizen at CodeCoder and TopForces $(1 \\le CC_{i}, TF_{i} \\le 10^{6}).$ All the ratings at each site are distinct.\n\n", "outputFormat": "\n\nFor each citizen $i$ output an integer $b_{i}$ -- how many other citizens they can possibly beat in a programming competition. Each $b_{i}$ should be printed in a separate line, in the order the citizens are given in the input.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] CodeCoder vs TopForces", "background": "", "description": "在 Byteland，竞赛编程非常流行。事实上，每位 Byteland 的公民都在两个编程网站——CodeCoder 和 TopForces 上注册。每个网站都有自己专有的评分系统。每位公民在每个网站上都有一个唯一的整数评分，代表他们的技能。评分越高，技能越好。\n\nByteland 的人天生乐观。公民 A 认为，如果存在一个 Byteland 公民的序列 $A = P_{0}, P_{1},...,P_{k} = B$，对于某个 $k \\ge 1$，使得对于每个 $i (0 \\le i < k)$，$P_{i}$ 在一个或两个网站上的评分都高于 $P_{i+1}$，那么他就有机会在编程比赛中击败公民 B。\n\n每位 Byteland 公民都想知道他们在编程比赛中可能击败多少其他公民。", "inputFormat": "输入的第一行包含一个整数 $n$——公民的数量 $(1 \\le n \\le 100 000)$。接下来的 $n$ 行包含关于评分的信息。第 $i$ 行包含两个整数 $CC_{i}$ 和 $TF_{i}$——第 $i$ 位公民在 CodeCoder 和 TopForces 上的评分 $(1 \\le CC_{i}, TF_{i} \\le 10^{6})$。每个网站上的所有评分都是不同的。", "outputFormat": "对于每位公民 $i$，输出一个整数 $b_{i}$——他们在编程比赛中可能击败的其他公民数量。每个 $b_{i}$ 应该单独一行输出，顺序与输入中给出的公民顺序相同。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7034", "type": "P", "difficulty": 5, "samples": [["2\n 1 1\n0 1 1\n 1 0\n0 1 1\n 1 1\n0 1 1\n 1 0\n0 1 1\n 0 0\n", "37\n34\n71\n"], ["1\n 1\n0 1\n 1\n1 1\n 1\n1 1\n 1\n0 1\n 0\n", "2\n2\n4\n"], ["1\n 1\n1 0\n 1\n1 1\n 1\n1 1\n 1\n0 1\n 0\n", "NO\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2016] Digital Addition", "background": "", "description": "\n\nDeidra is doing a columnar addition. She writes down two non-negative integer summands one below the other, left-pads them with zeroes so that they have equal length, and calculates the sum (e.g. $ 77 + 05 = 82$) . If the sum is longer than each of the summands (because of a carry, as in $96 + 07 = 103$) she appends a zero at the beginning of each summand ($096 + 007 = 103)$ . She allows herself to use unnecessary leading zeroes ( $007 + 004 = 011)$ as soon as the length of all three numbers is the same.\n\nAlso Deidra has a homemade printing press. She decided to print her addition without a plus or $a horizontal$ line, using the following standard font:\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13476/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-11-01%20%EC%98%A4%ED%9B%84%202.41.11.png)\n\nUnfortunately, she messed up with spacing, and all the digits were printed over each other in the following way. Digits that were supposed to be horizontally adjacent were printed so that the right two segments of the left digit coincide with the left two segments of the right digit. Digits that were supposed to be vertically adjacent were printed so that the bottom half (a square with 4 segments) of the upper digit coincides with the top half of the lower digit.\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13476/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-11-01%20%EC%98%A4%ED%9B%84%202.41.17.png)\n\nWhen one or more black segments are printed at the same position, the result looks black. When only empty segments are printed at the position, the result looks white.\n\nGiven the resulting picture, find a correct addition that could produce it or detect that there is none.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $w (1 \\le w \\le 100)$ -- the width of Deidra's addition $(number of$ digits in each line).\n\nThe following $9$ lines contain the description of the picture printed with the bad spacing. Each line contains $w$ or $w + 1$ digits. ‘1' denotes a black segment, ‘0' denotes a white one. Even lines start with a space. See the examples for clarification.\n\n", "outputFormat": "\n\nIf there is no valid addition, output `NO`.\n\nOtherwise output a valid addition that produces the given figure. The output should consist of three lines, each containing $w$ digits.\n\nIf there are several solutions, output any of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Digital Addition", "background": "", "description": "\n\nDeidra is doing a columnar addition. She writes down two non-negative integer summands one below the other, left-pads them with zeroes so that they have equal length, and calculates the sum (e.g. $ 77 + 05 = 82$) . If the sum is longer than each of the summands (because of a carry, as in $96 + 07 = 103$) she appends a zero at the beginning of each summand ($096 + 007 = 103)$ . She allows herself to use unnecessary leading zeroes ( $007 + 004 = 011)$ as soon as the length of all three numbers is the same.\n\nAlso Deidra has a homemade printing press. She decided to print her addition without a plus or $a horizontal$ line, using the following standard font:\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13476/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-11-01%20%EC%98%A4%ED%9B%84%202.41.11.png)\n\nUnfortunately, she messed up with spacing, and all the digits were printed over each other in the following way. Digits that were supposed to be horizontally adjacent were printed so that the right two segments of the left digit coincide with the left two segments of the right digit. Digits that were supposed to be vertically adjacent were printed so that the bottom half (a square with 4 segments) of the upper digit coincides with the top half of the lower digit.\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13476/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-11-01%20%EC%98%A4%ED%9B%84%202.41.17.png)\n\nWhen one or more black segments are printed at the same position, the result looks black. When only empty segments are printed at the position, the result looks white.\n\nGiven the resulting picture, find a correct addition that could produce it or detect that there is none.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $w (1 \\le w \\le 100)$ -- the width of Deidra's addition $(number of$ digits in each line).\n\nThe following $9$ lines contain the description of the picture printed with the bad spacing. Each line contains $w$ or $w + 1$ digits. ‘1' denotes a black segment, ‘0' denotes a white one. Even lines start with a space. See the examples for clarification.\n\n", "outputFormat": "\n\nIf there is no valid addition, output `NO`.\n\nOtherwise output a valid addition that produces the given figure. The output should consist of three lines, each containing $w$ digits.\n\nIf there are several solutions, output any of them.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Digital Addition", "background": null, "description": "Deidra 正在做一个列式的加法。她写下两个正整数来对其进行求和，且一个在另一个下方，在它们的左边添 0，使得他们拥有相同的长度，然后相加计算结果（例如 $77 + 05 = 82$）。如果这个结果的长度大于这两个加数任何一个的长度（由于进位，例如$96 + 07 = 103$），就在两个加数前面附加零（$096 + 007 = 103$）。她允许不必要的前导零的出现（$007 + 004 = 011$）只要算式中的三个数字的长度都相同。\n\nDeidra 还有一台自制的打印机。她决定在没有加号和水平线的情况下打印她的加法算式，使用下面的标准字体：\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13476/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-11-01%20%EC%98%A4%ED%9B%84%202.41.11.png)\n\n不幸的是，她弄乱了这些数字的间距，所有的数字都将以以下方式打印。打印这些本应水平相邻的数字时左边数字的右两段与右边数字的左两端重合。打印应该竖直相邻的数字时，上边数字的下半部分（由四段组成的正方形部分）与下边数字的上半部分重合。\n\n![](https://onlinejudgeimages.s3.amazonaws.com/problem/13476/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-11-01%20%EC%98%A4%ED%9B%84%202.41.17.png)\n\n如果在同一位置打印一个或多个线段时，将显示为黑色。当所在位置仅打印空段时，将显示为白色。\n\n给定一个生成的图片，找到可以通过打印机产生这个图片的正确算式。如果找不到符合要求的算式，就输出 `NO`。", "inputFormat": "第一行包含一个整数 $w(1\\le w \\le 100)$ 代表 Deidra 加法的宽度（接下来每行的数字个数）。\n\n接下来的 $9$ 行包含对于用错误打印机输出的图片的描述。每行包含 $w$ 或 $w+1$ 个数字。`1` 表示黑色段，`0` 表示白色段。偶数行以空格开头。有关说明请参阅样例。", "outputFormat": "如果没有符合要求的算式，则输出 `NO`。\n\n否则输出给定图片所对应的有效算式。输出应由三行组成，每行包含 $w$ 个数字。\n\n如果有多个符合规定的算式，请输出其任何一个。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P7035", "type": "P", "difficulty": 6, "samples": [["43\nyou should read statement really carefully.\n3 6\n...XX.\n..XXX.\n...XXX\n", "YES\n3 42\n"], ["43\nyou should read statement really carefully.\n3 2\nXX\nXX\nXX\n", "NO\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2016] Easy Reading", "background": "", "description": "\n\nEugene is reading a boring book. To make this process interesting he is drawing a picture at the  same time.  He has a piece of graph paper that is divided into square cells. All the cells are empty at  the beginning. \n\nEugene starts by painting over one cell. Then he opens the book at a random page and starts reading.   Whenever  he sees the letter  `u`  in the text, he moves his pen one cell up and then paints over the  cell under  his pen. Whenever he sees the letter  `d`,  he does the same but moves his pen one cell down  instead of  up. For letters  `l`  and  `r`  he moves to the left and to the right, respectively. If he wants to paint  a cell  that was already painted, he paints it again.\n\nYou have found a piece of paper and the text of the book. Now you want to understand if the picture  o_n the  paper could be drawn by Eugene at some point of his book reading. Remember that Eugene  could use  some substring of the text.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $l$ -- the length of the text $(1 \\le l \\le 100 000)$ . The $second line$ contains a string of length $l$ -- the text. It contains only lowercase English letters, spaces, commas and periods. The text neither begins nor ends with a space.\n\nThe third line contains two positive integers $n$ and $m$ -- the picture dimensions $(2 \\le n \\times m \\le 100 000)$ .\n\nEach of the following $n$ lines contains a string of length $m$ . Painted cells are denoted by `X`, while empty cells -- by `.` . It is guaranteed that there are at least two painted cells in the picture.\n\nThe first of these $n$ lines corresponds to the top of the picture and the last one corresponds to the bottom of it.\n\n", "outputFormat": "\n\nIf the picture could be painted by Eugene, output `YES` on the first line. On the second line print two integers b and $e$ such that if Eugene read all letters from $b$ to $e$ , inclusive, he would draw exactly $the same$ picture as described in the input $(1 \\le b \\le e \\le l)$ . If there are several solutions, output any of them.\n\nIf the picture couldn't be drawn by Eugene, output `NO`.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Easy Reading", "background": "", "description": "\n\nEugene is reading a boring book. To make this process interesting he is drawing a picture at the  same time.  He has a piece of graph paper that is divided into square cells. All the cells are empty at  the beginning. \n\nEugene starts by painting over one cell. Then he opens the book at a random page and starts reading.   Whenever  he sees the letter  `u`  in the text, he moves his pen one cell up and then paints over the  cell under  his pen. Whenever he sees the letter  `d`,  he does the same but moves his pen one cell down  instead of  up. For letters  `l`  and  `r`  he moves to the left and to the right, respectively. If he wants to paint  a cell  that was already painted, he paints it again.\n\nYou have found a piece of paper and the text of the book. Now you want to understand if the picture  o_n the  paper could be drawn by Eugene at some point of his book reading. Remember that Eugene  could use  some substring of the text.\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $l$ -- the length of the text $(1 \\le l \\le 100 000)$ . The $second line$ contains a string of length $l$ -- the text. It contains only lowercase English letters, spaces, commas and periods. The text neither begins nor ends with a space.\n\nThe third line contains two positive integers $n$ and $m$ -- the picture dimensions $(2 \\le n \\times m \\le 100 000)$ .\n\nEach of the following $n$ lines contains a string of length $m$ . Painted cells are denoted by `X`, while empty cells -- by `.` . It is guaranteed that there are at least two painted cells in the picture.\n\nThe first of these $n$ lines corresponds to the top of the picture and the last one corresponds to the bottom of it.\n\n", "outputFormat": "\n\nIf the picture could be painted by Eugene, output `YES` on the first line. On the second line print two integers b and $e$ such that if Eugene read all letters from $b$ to $e$ , inclusive, he would draw exactly $the same$ picture as described in the input $(1 \\le b \\le e \\le l)$ . If there are several solutions, output any of them.\n\nIf the picture couldn't be drawn by Eugene, output `NO`.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Easy Reading", "background": "", "description": "Eugene正在读一本无聊的书。为了使阅读更有趣，他在阅读的同时同时作画。 他有一张方格纸。 所有的方格一开始都是空的。\n\nEugene一开始在一个方格上作画。让后他随机翻开一页并开始阅读。当他遇到字母 `u`  时, 他把笔向上移动一格并在这格上画画。 当他看到 `d`时, 他会做同样的操作，但是向下移动一格而不是向上移动一格。 `l` ,`r`分别是向左和向右一格。 如果这个单元格已经画过了他会再画一次。\n\n现在你有一张纸与这本书中的内容。 现在你想知道这张纸上的图片是否可能被Eugene在某一时刻画过。 记住：Eugene可以只使用用这个内容的子字符串。", "inputFormat": "第一行是一个整数$l(1 \\le l \\le 10^5)$--表示这个内容的长度。 \n\n第二行是一个长度为$l$的字符串$a$。它只包含小写英文字母、空格、逗号和句号。$a$既不会以空格开头也不会以空格结尾。\n\n第三行是两个整数$n$ 与 $m$--图的大小$(2 \\le n \\times m \\le 10^5)$ 。\n\n第$4$~$3+n$行，每行一个长度为$m$的字符串。画过的格子用`x`表示，没画过的用`.`表示。保证一幅图中至少有两个格子已被涂色。\n\n这 $n$ 行字符串中的第一行对应于图片的顶部，最后一行对应于图片的底部。", "outputFormat": "如果可能被绘制，第一行输出`YES`，第二行输出用空格隔开的两个整数$b$和$e$,表示Eugene从第$b$个字母开始读，到第$e$个字母结束(包含$b$和$e$)。\n\n如果不能，输出`NO`。\n\n## 样例 #1\n\n### 样例输入 #1\n\n```\n43\nyou should read statement really carefully.\n3 6\n...XX.\n..XXX.\n...XXX\n```\n\n### 样例输出 #1\n\n```\nYES\n3 42\n```\n\n## 样例 #2\n\n### 样例输入 #2\n\n```\n43\nyou should read statement really carefully.\n3 2\nXX\nXX\nXX\n```\n\n### 样例输出 #2\n\n```\nNO\n```", "hint": "时限: 2 s, 内存限制: 256 MB.", "locale": "zh-CN"}}}
{"pid": "P7036", "type": "P", "difficulty": 2, "samples": [["2 7\n2 2\n", "2\n"], ["10 6\n4 8\n", "2\n"], ["5 5\n1 6\n", "-1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "ICPC", "NWRRC"], "title": "[NWRRC 2016] Folding", "background": "", "description": "\n\nAs you can remember, Alex is fond of origami. She switched from squares to rectangles, and rectangles are much more difficult to master. Her main interest is to determine what is the minimum possible number of folds required to transform $W \\times H$ rectangle to $w \\times h$ one. The result of each fold should also be rectangular, so it is only allowed to make folds that are parallel to the sides of the rectangle.\n\nHelp Alex and write a program that determines the minimum required number of folds.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $W$ and $H$ -- the initial rectangle dimensions. The second line contains two more integers $w$ and $h$ -- the target rectangle dimensions $(1 \\le W , H , w , h \\le 10^{9}).$\n\n", "outputFormat": "\n\nOutput a single integer -- the minimum required number of folds to transform the initial rectangle to the target one.\n\nIf the required transformation is not possible, output $−1$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Folding", "background": "", "description": "\n\nAs you can remember, Alex is fond of origami. She switched from squares to rectangles, and rectangles are much more difficult to master. Her main interest is to determine what is the minimum possible number of folds required to transform $W \\times H$ rectangle to $w \\times h$ one. The result of each fold should also be rectangular, so it is only allowed to make folds that are parallel to the sides of the rectangle.\n\nHelp Alex and write a program that determines the minimum required number of folds.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $W$ and $H$ -- the initial rectangle dimensions. The second line contains two more integers $w$ and $h$ -- the target rectangle dimensions $(1 \\le W , H , w , h \\le 10^{9}).$\n\n", "outputFormat": "\n\nOutput a single integer -- the minimum required number of folds to transform the initial rectangle to the target one.\n\nIf the required transformation is not possible, output $−1$ .\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Folding", "background": "", "description": "### 题目大意：\n\n求一个 $W\\times H $ 的矩形通过折叠变为一个 $w\\times h$ 的矩形的最少折叠次数，其中每次折叠的折痕必须平行于矩形的一边。\n\n------------", "inputFormat": "第一行两个正整数 $W,H$，第二行两个正整数 $w,h$。\n\n$1\\le W,H,w,h\\le10^9$\n\n------------", "outputFormat": "输出最少折叠次数。若无法通过折叠变为目标矩形，输出 `-1`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7037", "type": "P", "difficulty": 6, "samples": [["7 6\n1 2 1 3 3 3\n+ 4\n+ 5\n+ 6\n+ 7\n- 6\n- 5\n", "1 0\n2 0\n2 1\n2 0\n2 1\n2 0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "ICPC", "NWRRC"], "title": "[NWRRC 2016] Gangsters in Central City", "background": "", "description": "\n\nFor a long time, there were no problems with water in Central City. The sewage of the city has a form of a rooted tree: the central reservoir is situated at the root and the houses are at the leaves. The water flows from the central reservoir to the houses by the pipes that runs along the edges of the tree. Each house has an access to water.\n\nSuddenly, gangsters captured some of the houses. As a mayor of the city you are very concerned, and you want to kick out the gangsters. So you want to stop the water flow to houses captured by the gangsters.  To do that you could clog some pipes of the sewage system. If the path from the reservoir to a house contains at least one clogged pipe, the house does not have an access to water.\n\nYou are very afraid of the gangsters, so you decided to clog up the minimal number of pipes, that it could look like an accident. At the same time, you care about the citizens, so for the chosen number of clogged pipes, you want to minimize the number of houses without gangsters and access to water.\n\nUnfortunately, the gangsters could appear and disappear from some houses. So, you are asking the scientists about the minimum required number of clogged pipes and the minimum required number of houses without gangsters and access to water after each change in the gangsters' location.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $n$ and $q$ -- the number of vertices in the tree which represents the sewage and the number of changes in the location of the gangsters $(2 \\le n \\le 100 000$ ; $1 \\le q \\le 100 000)$ .\n\nThe second line contains the description of the sewage: a sequence of $n − 1$ integers $p_{2}, p_{3},$ . . . , $p_{n}$, where $p_{i} is$ the parent of the vertex $i (1 \\le p_{i} < i)$ . The central reservoir is located at the vertex $1$ .\n\nThe next $q$ lines represent the changes in the location of the gangsters. Each change could be one of two different types: \n\n- `+ v` -- the gangsters capture the house at vertex $v$ ; \n- `- v` -- the gangsters leave the house at vertex $v$ .\n\nAt the beginning all the houses are free of gangsters. All the changes form the correct sequence: the gangsters cannot capture the house if it is already captured and the gangsters could not leave the house if it is not captured.\n\n", "outputFormat": "\n\nThe output should contain 2q integers, two in each line: $c_{i}$ -- the minimum number of clogged pipes and $h_{i}$ -- the minimum number of houses without gangsters and have no access to water for the chosen $c_{i}$\n\n.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Gangsters in Central City", "background": "", "description": "\n\nFor a long time, there were no problems with water in Central City. The sewage of the city has a form of a rooted tree: the central reservoir is situated at the root and the houses are at the leaves. The water flows from the central reservoir to the houses by the pipes that runs along the edges of the tree. Each house has an access to water.\n\nSuddenly, gangsters captured some of the houses. As a mayor of the city you are very concerned, and you want to kick out the gangsters. So you want to stop the water flow to houses captured by the gangsters.  To do that you could clog some pipes of the sewage system. If the path from the reservoir to a house contains at least one clogged pipe, the house does not have an access to water.\n\nYou are very afraid of the gangsters, so you decided to clog up the minimal number of pipes, that it could look like an accident. At the same time, you care about the citizens, so for the chosen number of clogged pipes, you want to minimize the number of houses without gangsters and access to water.\n\nUnfortunately, the gangsters could appear and disappear from some houses. So, you are asking the scientists about the minimum required number of clogged pipes and the minimum required number of houses without gangsters and access to water after each change in the gangsters' location.\n\n", "inputFormat": "\n\nThe first line of the input contains two integers $n$ and $q$ -- the number of vertices in the tree which represents the sewage and the number of changes in the location of the gangsters $(2 \\le n \\le 100 000$ ; $1 \\le q \\le 100 000)$ .\n\nThe second line contains the description of the sewage: a sequence of $n − 1$ integers $p_{2}, p_{3},$ . . . , $p_{n}$, where $p_{i} is$ the parent of the vertex $i (1 \\le p_{i} < i)$ . The central reservoir is located at the vertex $1$ .\n\nThe next $q$ lines represent the changes in the location of the gangsters. Each change could be one of two different types: \n\n- `+ v` -- the gangsters capture the house at vertex $v$ ; \n- `- v` -- the gangsters leave the house at vertex $v$ .\n\nAt the beginning all the houses are free of gangsters. All the changes form the correct sequence: the gangsters cannot capture the house if it is already captured and the gangsters could not leave the house if it is not captured.\n\n", "outputFormat": "\n\nThe output should contain 2q integers, two in each line: $c_{i}$ -- the minimum number of clogged pipes and $h_{i}$ -- the minimum number of houses without gangsters and have no access to water for the chosen $c_{i}$\n\n.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Gangsters in Central City", "background": "", "description": "长期以来，中央城的水供应一直没有问题。城市的排水系统呈现出一棵根树的形式：中央水库位于树根，房屋位于树叶。水通过沿着树的边缘运行的管道从中央水库流向房屋。每个房屋都能获得水。\n\n突然，黑帮占领了一些房屋。作为市长，你非常担心，并想要赶走这些黑帮。因此，你希望停止向被黑帮占领的房屋供水。为此，你可以堵塞排水系统中的一些管道。如果从水库到某个房屋的路径上至少有一根管道被堵塞，那么该房屋将无法获得水。\n\n你非常害怕这些黑帮，所以你决定堵塞最少数量的管道，以使其看起来像是意外。同时，你关心市民，因此对于选择的堵塞管道数量，你希望最小化没有黑帮且无法获得水的房屋数量。\n\n不幸的是，黑帮可能会在一些房屋中出现和消失。因此，你询问科学家在每次黑帮位置变化后所需的最小堵塞管道数量以及没有黑帮且无法获得水的房屋的最小数量。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $q$ —— 表示树中顶点的数量（代表排水系统）和黑帮位置变化的次数（$2 \\le n \\le 100 000$；$1 \\le q \\le 100 000$）。\n\n第二行包含排水系统的描述：一个由 $n - 1$ 个整数 $p_{2}, p_{3}, \\ldots, p_{n}$ 组成的序列，其中 $p_{i}$ 是顶点 $i$ 的父节点 $(1 \\le p_{i} < i)$。中央水库位于顶点 $1$。\n\n接下来的 $q$ 行表示黑帮位置的变化。每个变化可以是两种不同类型之一：\n\n- `+ v` —— 黑帮占领顶点 $v$ 处的房屋；\n- `- v` —— 黑帮离开顶点 $v$ 处的房屋。\n\n一开始所有房屋都没有被黑帮占领。所有变化形成了正确的序列：黑帮不能占领已经被占领的房屋，黑帮也不能离开未被占领的房屋。", "outputFormat": "输出应包含 2q 个整数，每行两个：$c_{i}$ —— 最小堵塞管道数量，以及 $h_{i}$ —— 在选择的 $c_{i}$ 下没有黑帮且无法获得水的房屋的最小数量。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7038", "type": "P", "difficulty": 7, "samples": [["3\n5 3\n5 6\n4 4\n", "4\n0 0 3\n3 0 2\n3 2 1\n4 2 1\n5\n0 0 2\n0 2 2\n0 4 2\n2 0 3\n2 3 3\n1\n0 0 4\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2016] Hard Cuts", "background": "", "description": "\n\nGiven a rectangle with integer side lengths, your task is to cut it into the smallest possible number $of squares$ with integer side lengths.\n\n", "inputFormat": "\n\nThe first line contains a single integer $T$ -- the number of test cases $(1 \\le T \\le 3600)$ . Each of the $next T$ lines contains two integers $w_{i}, h_{i}$ -- the dimensions of the rectangle $(1 \\le w_{i}, h_{i} \\le 60$ ; for any $i ≠ j, either w_{i }≠ w_{j}$ or $h_{i} ≠ h_{j} ).$\n\n", "outputFormat": "\n\nFor the i-th test case, output $k_{i}$ -- the minimal number of squares, such that it is possible to cut $the w_{i}$ by $h_{i}$ rectangle into $k_{i}$ squares. The following $k_{i} lines$ should contain three integers each: $x_{ij} , y_{ij} -- the$ coordinates of the bottom-left corner of the j-th square and $l_{ij }--$ its side length $(0 \\le x_{ij} \\le w_{i} − l_{ij} ; 0 \\le y_{ij} \\le h_{i} −l_{ij} ).$ The bottom-left corner of the rectangle has coordinates $(0 , 0)$ and the top-right $corner has$ coordinates $(w_{i}, h_{i}).$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Hard Cuts", "background": "", "description": "\n\nGiven a rectangle with integer side lengths, your task is to cut it into the smallest possible number $of squares$ with integer side lengths.\n\n", "inputFormat": "\n\nThe first line contains a single integer $T$ -- the number of test cases $(1 \\le T \\le 3600)$ . Each of the $next T$ lines contains two integers $w_{i}, h_{i}$ -- the dimensions of the rectangle $(1 \\le w_{i}, h_{i} \\le 60$ ; for any $i ≠ j, either w_{i }≠ w_{j}$ or $h_{i} ≠ h_{j} ).$\n\n", "outputFormat": "\n\nFor the i-th test case, output $k_{i}$ -- the minimal number of squares, such that it is possible to cut $the w_{i}$ by $h_{i}$ rectangle into $k_{i}$ squares. The following $k_{i} lines$ should contain three integers each: $x_{ij} , y_{ij} -- the$ coordinates of the bottom-left corner of the j-th square and $l_{ij }--$ its side length $(0 \\le x_{ij} \\le w_{i} − l_{ij} ; 0 \\le y_{ij} \\le h_{i} −l_{ij} ).$ The bottom-left corner of the rectangle has coordinates $(0 , 0)$ and the top-right $corner has$ coordinates $(w_{i}, h_{i}).$\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Hard Cuts", "background": null, "description": "给定一个具有整数边长的矩形，你的任务是将其切割成尽可能少的整数边长的正方形。", "inputFormat": "第一行包含一个整数 $T$ —— 测试用例的数量 $(1 \\le T \\le 3600)$。接下来的 $T$ 行中的每一行包含两个整数 $w_{i}, h_{i}$ —— 矩形的尺寸 $(1 \\le w_{i}, h_{i} \\le 60$；对于任何 $i \\neq j$，要么 $w_{i} \\neq w_{j}$，要么 $h_{i} \\neq h_{j})$。", "outputFormat": "对于第 $i$ 个测试用例，输出 $k_{i}$ —— 最小的正方形数量，使得可以将 $w_{i}$ 乘以 $h_{i}$ 的矩形切割成 $k_{i}$ 个正方形。接下来的 $k_{i}$ 行应包含三个整数：$x_{ij}, y_{ij}$ —— 第 $j$ 个正方形左下角的坐标，以及 $l_{ij}$ —— 其边长 $(0 \\le x_{ij} \\le w_{i} - l_{ij}; 0 \\le y_{ij} \\le h_{i} - l_{ij})$。矩形的左下角坐标为 $(0, 0)$，右上角坐标为 $(w_{i}, h_{i})$。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7039", "type": "P", "difficulty": 6, "samples": [["5\n7 3\n3 5\n1 4\n2 1\n5 0\n", "3\n"], ["4\n1 1\n3 1\n5 5\n1 3\n", "2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["计算几何", "2016", "叉积", "ICPC", "状压 DP", "NWRRC"], "title": "[NWRRC 2016] Integral Polygons", "background": "", "description": "\n\nIngrid holds a polygon shop in a far away country. She sells only convex polygons with integer coordinates. Her customers prefer polygons that can be cut into two halves in a proper way, that is the cut should be straight  with starting and ending points in the polygon vertices and both halves should be non-empty and have integer areas. The more ways to cut the polygon in the proper way are -- the more expensive the polygon is.\n\nFor example, there are three ways to cut the left polygon in the proper way, and two ways for the right polygon.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fei0xc33.png)\n\nThe polygons in the shop are always of excellent quality, so the business is expanding. Now Ingrid needs some automatic tool to determine the number of ways to cut the polygon in the proper way. This is very important for her shop, since otherwise you will spend a lot of time on setting prices -- just imagine how much time would it take to set prices for a medium-sized van with polygons. Could you help Ingrid and write the tool for her?\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $n$ -- the number of polygon vertices $(4 \\le n \\le 200 000)$ . $ Each$ of the following $n$ lines contains vertex coordinates: a pair of integers $x_{i}$ and $y_{i}$ per line $(-10^{9} \\le x_{i}, y_{i} \\le 10^{9}).  The$ specified polygon is convex and its vertices are specified in the order of traversal.\n\n", "outputFormat": "\n\nOutput a single integer $w$ -- the number of ways to cut the polygon in the proper way.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Integral Polygons", "background": "", "description": "\n\nIngrid holds a polygon shop in a far away country. She sells only convex polygons with integer coordinates. Her customers prefer polygons that can be cut into two halves in a proper way, that is the cut should be straight  with starting and ending points in the polygon vertices and both halves should be non-empty and have integer areas. The more ways to cut the polygon in the proper way are -- the more expensive the polygon is.\n\nFor example, there are three ways to cut the left polygon in the proper way, and two ways for the right polygon.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fei0xc33.png)\n\nThe polygons in the shop are always of excellent quality, so the business is expanding. Now Ingrid needs some automatic tool to determine the number of ways to cut the polygon in the proper way. This is very important for her shop, since otherwise you will spend a lot of time on setting prices -- just imagine how much time would it take to set prices for a medium-sized van with polygons. Could you help Ingrid and write the tool for her?\n\n", "inputFormat": "\n\nThe first line of the input contains an integer $n$ -- the number of polygon vertices $(4 \\le n \\le 200 000)$ . $ Each$ of the following $n$ lines contains vertex coordinates: a pair of integers $x_{i}$ and $y_{i}$ per line $(-10^{9} \\le x_{i}, y_{i} \\le 10^{9}).  The$ specified polygon is convex and its vertices are specified in the order of traversal.\n\n", "outputFormat": "\n\nOutput a single integer $w$ -- the number of ways to cut the polygon in the proper way.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Integral Polygons", "background": "", "description": "Ingrid 在一个遥远的国家经营着一家多边形商店。她只出售具有整数坐标的凸多边形。她的顾客更喜欢可以以适当方式切割成两半的多边形，即切割应是直线，起点和终点在多边形的顶点上，并且两半都不为空且面积为整数。切割多边形的适当方式越多，多边形就越昂贵。\n\n例如，左边的多边形有三种适当的切割方式，而右边的多边形有两种。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fei0xc33.png)\n\n商店里的多边形质量总是很优秀，所以业务正在扩展。现在 Ingrid 需要一些自动化工具来确定适当切割多边形的方式数量。这对她的商店非常重要，否则你将花费大量时间来设定价格——想象一下为一辆中型货车的多边形设定价格需要多少时间。你能帮助 Ingrid 编写这个工具吗？", "inputFormat": "输入的第一行包含一个整数 $n$ —— 多边形顶点的数量 $(4 \\le n \\le 200 000)$。接下来的 $n$ 行中的每一行包含顶点坐标：每行一对整数 $x_{i}$ 和 $y_{i}$ $(-10^{9} \\le x_{i}, y_{i} \\le 10^{9})$。指定的多边形是凸的，其顶点按遍历顺序指定。", "outputFormat": "输出一个整数 $w$ —— 以适当方式切割多边形的方式数量。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7040", "type": "P", "difficulty": 4, "samples": [["0\n", "? /?/ ?\n"], ["1\n", "a = ? max ?\n(a max a) / a\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2016] Java2016", "background": "", "description": "\n\nJohn likes to learn esoteric programming languages. Recently he discovered the probabilistic $\\textit{programming language}$ Java2K. Built-in functions of Java2K have only a certain probability to do whatever you $\\textit{intend them}$ to do.\n\nThe Java2K programming is very hard, so John designed a much simpler language for training: Java2016. $\\textit{Built-in}$ operators of Java2016 are deterministic, while their operands are random. Each value in $\\textit{Java2016 is}$ a positive integer in the range $0 \\cdots 255$ , inclusive.\n\nJava2016 supports six operators of three precedencies:\n\n$$\\begin{aligned}{\\langle \\mathrm{expression}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{min}\\text'}{\\langle \\mathrm{sum}\\rangle}\\mid{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{max}\\text'}{\\langle \\mathrm{sum}\\rangle}\\mid {\\langle \\mathrm{sum}\\rangle}\\\\{\\langle \\mathrm{sum}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{sum}\\rangle}\\operatorname{`\\texttt{+}\\text'}{\\langle \\mathrm{term}\\rangle}\\mid{\\langle \\mathrm{sum}\\rangle}\\operatorname{`\\texttt{-}\\text'}{\\langle \\mathrm{term}\\rangle}\\mid{\\langle \\mathrm{term}\\rangle}\\\\{\\langle \\mathrm{term}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{term}\\rangle}\\operatorname{`\\texttt{*}\\text'}{\\langle \\mathrm{factor}\\rangle}\\mid {\\langle \\mathrm{term}\\rangle}\\operatorname{`\\texttt{/}\\text'}{\\langle \\mathrm{factor}\\rangle}\\mid {\\langle \\mathrm{factor}\\rangle}\\\\{\\langle \\mathrm{factor}\\rangle}&\\quad::=\\quad\\operatorname{`\\texttt{(}\\text'}{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{)}\\text'}\\mid `\\texttt{?}\\text'\\mid {\\langle \\mathrm{macro}\\rangle}\\end{aligned}$$\n\nMinimum $(\\textit{`min'})$ and maximum $((\\textit{`max'}))$ operators are defined as usual. Addition $(\\text{`+'}),$ subtraction $(\\text{`--'}) and$ multiplication $(\\text{`}\\times\\text{'})$ are defined modulo $256$ . The result of the division $(\\text{`}/\\text{'})$ is rounded towards zero. $\\textit{If}$ the divider is zero, the program crashes. The argument of the operator is a result of another $\\textit{operator, evenly}$ distributed random value $(\\text{`}?\\text{'})$, or macro substitution.\n\nFor instance, the probability that $\\text{`?/?/?'}$ is evaluated to zero is $98.2\\%$, while the probability of $the crash$ is $0.8\\%$.\n\nThe Java2016 program consists of zero or more macro definitions, followed by the resulting expression. $ Each$ macro definition has a form of\n\n$$\\begin{aligned}{\\langle \\mathrm{macrodef}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{macro}\\rangle}\\operatorname{`\\texttt{=}\\text'}{\\langle \\mathrm{expression}\\rangle}\\\\{\\langle \\mathrm{macro}\\rangle}&\\quad::=\\quad\\operatorname{`\\texttt{a}\\text'}\\ldots\\operatorname{`\\texttt{z}\\text'}\\end{aligned}$$\n\n\nThe macro should be defined before the first use. It may not be redefined. The macro is expanded to $its definitio_n$ on each use. For instance,\n\n```plain\na = ? max ?\n(a max $a) / a\n```\n\nis expanded to `((? max ?) max (? max ?)) / (? max ?)`.\n\nJohn is going to add probabilistic constants to Java2016, so for each possible constant value he needs $a progra_m$ that successfully evaluates to this value with at least one-half probability. Crashes are $\\textit{counted toward}$ failures.\n\n", "inputFormat": "\n\nThe input contains a single integer $c$ -- the target constant $(0 \\le c \\le 255)$ .\n\n", "outputFormat": "\n\nOutput a Java2016 program that successfully evaluates to constant $c$ with probability no less than $1/2$ . $ The$ total length of the program should not exceed $256$ characters (excluding spaces).\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] Java2016", "background": "", "description": "\n\nJohn likes to learn esoteric programming languages. Recently he discovered the probabilistic $\\textit{programming language}$ Java2K. Built-in functions of Java2K have only a certain probability to do whatever you $\\textit{intend them}$ to do.\n\nThe Java2K programming is very hard, so John designed a much simpler language for training: Java2016. $\\textit{Built-in}$ operators of Java2016 are deterministic, while their operands are random. Each value in $\\textit{Java2016 is}$ a positive integer in the range $0 \\cdots 255$ , inclusive.\n\nJava2016 supports six operators of three precedencies:\n\n$$\\begin{aligned}{\\langle \\mathrm{expression}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{min}\\text'}{\\langle \\mathrm{sum}\\rangle}\\mid{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{max}\\text'}{\\langle \\mathrm{sum}\\rangle}\\mid {\\langle \\mathrm{sum}\\rangle}\\\\{\\langle \\mathrm{sum}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{sum}\\rangle}\\operatorname{`\\texttt{+}\\text'}{\\langle \\mathrm{term}\\rangle}\\mid{\\langle \\mathrm{sum}\\rangle}\\operatorname{`\\texttt{-}\\text'}{\\langle \\mathrm{term}\\rangle}\\mid{\\langle \\mathrm{term}\\rangle}\\\\{\\langle \\mathrm{term}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{term}\\rangle}\\operatorname{`\\texttt{*}\\text'}{\\langle \\mathrm{factor}\\rangle}\\mid {\\langle \\mathrm{term}\\rangle}\\operatorname{`\\texttt{/}\\text'}{\\langle \\mathrm{factor}\\rangle}\\mid {\\langle \\mathrm{factor}\\rangle}\\\\{\\langle \\mathrm{factor}\\rangle}&\\quad::=\\quad\\operatorname{`\\texttt{(}\\text'}{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{)}\\text'}\\mid `\\texttt{?}\\text'\\mid {\\langle \\mathrm{macro}\\rangle}\\end{aligned}$$\n\nMinimum $(\\textit{`min'})$ and maximum $((\\textit{`max'}))$ operators are defined as usual. Addition $(\\text{`+'}),$ subtraction $(\\text{`--'}) and$ multiplication $(\\text{`}\\times\\text{'})$ are defined modulo $256$ . The result of the division $(\\text{`}/\\text{'})$ is rounded towards zero. $\\textit{If}$ the divider is zero, the program crashes. The argument of the operator is a result of another $\\textit{operator, evenly}$ distributed random value $(\\text{`}?\\text{'})$, or macro substitution.\n\nFor instance, the probability that $\\text{`?/?/?'}$ is evaluated to zero is $98.2\\%$, while the probability of $the crash$ is $0.8\\%$.\n\nThe Java2016 program consists of zero or more macro definitions, followed by the resulting expression. $ Each$ macro definition has a form of\n\n$$\\begin{aligned}{\\langle \\mathrm{macrodef}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{macro}\\rangle}\\operatorname{`\\texttt{=}\\text'}{\\langle \\mathrm{expression}\\rangle}\\\\{\\langle \\mathrm{macro}\\rangle}&\\quad::=\\quad\\operatorname{`\\texttt{a}\\text'}\\ldots\\operatorname{`\\texttt{z}\\text'}\\end{aligned}$$\n\n\nThe macro should be defined before the first use. It may not be redefined. The macro is expanded to $its definitio_n$ on each use. For instance,\n\n```plain\na = ? max ?\n(a max $a) / a\n```\n\nis expanded to `((? max ?) max (? max ?)) / (? max ?)`.\n\nJohn is going to add probabilistic constants to Java2016, so for each possible constant value he needs $a progra_m$ that successfully evaluates to this value with at least one-half probability. Crashes are $\\textit{counted toward}$ failures.\n\n", "inputFormat": "\n\nThe input contains a single integer $c$ -- the target constant $(0 \\le c \\le 255)$ .\n\n", "outputFormat": "\n\nOutput a Java2016 program that successfully evaluates to constant $c$ with probability no less than $1/2$ . $ The$ total length of the program should not exceed $256$ characters (excluding spaces).\n\n", "hint": "Time limit: 2 s, Memory limit: 512 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] Java2016", "background": "", "description": "John 喜欢学习晦涩的编程语言。最近他发现了概率编程语言 Java2K。Java2K 的内置函数只有一定的概率能够执行你想让它们做的事情。\n\nJava2K 编程非常困难，所以 John 设计了一种更简单的语言用于训练：Java2016。Java2016 的内置运算符是确定性的，而它们的操作数是随机的。在 Java2016 中，每个值都是范围在 $0 \\cdots 255$ 之间的正整数。\n\nJava2016 支持三种优先级的六个运算符：\n\n$$\n\\begin{aligned}\n{\\langle \\mathrm{expression}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{min}\\text'}{\\langle \\mathrm{sum}\\rangle}\\mid{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{max}\\text'}{\\langle \\mathrm{sum}\\rangle}\\mid {\\langle \\mathrm{sum}\\rangle}\\\\\n{\\langle \\mathrm{sum}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{sum}\\rangle}\\operatorname{`\\texttt{+}\\text'}{\\langle \\mathrm{term}\\rangle}\\mid{\\langle \\mathrm{sum}\\rangle}\\operatorname{`\\texttt{-}\\text'}{\\langle \\mathrm{term}\\rangle}\\mid{\\langle \\mathrm{term}\\rangle}\\\\\n{\\langle \\mathrm{term}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{term}\\rangle}\\operatorname{`\\texttt{*}\\text'}{\\langle \\mathrm{factor}\\rangle}\\mid {\\langle \\mathrm{term}\\rangle}\\operatorname{`\\texttt{\\/}\\text'}{\\langle \\mathrm{factor}\\rangle}\\mid {\\langle \\mathrm{factor}\\rangle}\\\\\n{\\langle \\mathrm{factor}\\rangle}&\\quad::=\\quad\\operatorname{`\\texttt{(}\\text'}{\\langle \\mathrm{expression}\\rangle}\\operatorname{`\\texttt{)}\\text'}\\mid `\\texttt{?}\\text'\\mid {\\langle \\mathrm{macro}\\rangle}\n\\end{aligned}\n$$\n\n最小值（`min`）和最大值（`max`）运算符的定义与通常相同。加法（`+`）、减法（`-`）和乘法（`*`）的定义是模 $256$。除法（`/`）的结果向零取整。如果除数为零，程序崩溃。运算符的参数是另一个运算符的结果、均匀分布的随机值（`?`）或宏替换。\n\n例如，`?/?/?` 被评估为零的概率是 $98.2\\%$，而崩溃的概率是 $0.8\\%$。\n\nJava2016 程序由零个或多个宏定义组成，后跟结果表达式。每个宏定义的形式为：\n\n$$\n\\begin{aligned}\n{\\langle \\mathrm{macrodef}\\rangle}&\\quad::=\\quad{\\langle \\mathrm{macro}\\rangle}\\operatorname{`\\texttt{=}\\text'}{\\langle \\mathrm{expression}\\rangle}\\\\\n{\\langle \\mathrm{macro}\\rangle}&\\quad::=\\quad\\operatorname{`\\texttt{a}\\text'}\\ldots\\operatorname{`\\texttt{z}\\text'}\n\\end{aligned}\n$$\n\n宏应该在第一次使用之前定义。它不能被重新定义。宏在每次使用时扩展为其定义。例如，\n\n```plain\na = ? max ?\n(a max $a) / a\n```\n\n被扩展为 `((? max ?) max (? max ?)) / (? max ?)`。\n\nJohn 打算向 Java2016 添加概率常量，因此对于每个可能的常量值，他需要一个程序，该程序能够以至少一半的概率成功评估为该值。崩溃被计入失败。", "inputFormat": "输入包含一个整数 $c$ —— 目标常量 $(0 \\le c \\le 255)$。", "outputFormat": "输出一个 Java2016 程序，该程序成功评估为常量 $c$ 的概率不小于 $1/2$。程序的总长度不应超过 $256$ 个字符（不包括空格）。", "hint": "时间限制：2 秒，内存限制：512 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7041", "type": "P", "difficulty": 2, "samples": [["22 10 2016\n7\n28 2 1999\n22 7 1995\n21 10 1998\n23 10 1998\n3 9 2000\n1 4 2013\n17 12 2004\n", "3\n"], ["22 10 2016\n1\n28 2 1999\n", "-1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "ICPC", "NWRRC"], "title": "[NWRRC 2016] King’s Heir", "background": "", "description": "\n\nThe king is dead, long live the king! After the sudden death of the king Fert XIII the people of the Flatland Kingdom are going to welcome the new king. Unfortunately, there is a problem, Fert has too many sons.\n\nActually, he has $n$ sons and he loved each new son more than all of his previous sons. Well, probably he just stopped loving his sons because of their bad behavior. Anyway, after the new son was born Fert made the new testament that declared that the newly born son would be the heir.\n\nHowever, there is a problem. Only the king's son who is at least $18$ years old at the moment of the $king's death$ can become a new king. Now the ministers of the government are trying to find the correct $new king,$ but they seem to fail. Help them!\n\n", "inputFormat": "\n\nThe first line of the input contains three integers: $d , m$ and $y$ -- the day, the month and the year of the king's death, $d$ is from $1$ to $31$ , $m$ is from $1$ to $12 , y$ is from $1$ to $9999$ . It is guaranteed that there exists day $d$ in month $m$ , all months have the same number of days in Flatland as in our country, except that Flatland calendar doesn't have leap years, so February (month $2$) always has $28$ days.\n\nThe second line contains $n (1 \\le n \\le 100)$ -- the number of king's sons. The following $n$ lines contain three integers each $d_{i}, m_{i}$ and $ y_{i}$ and specify the birth dates of king's sons. All dates are correct and no son is born after or on the day of king's death. The king had no twins, so no two sons were born on the same date.\n\n", "outputFormat": "\n\nOutput one integer -- the number of the son that would become the king, or $−1$ if none of them is $at least 18$ years old. The sons are numbered from $1$ to $n$ in order they are described in the input. The youngest son who is at least $18$ years old at the moment of the king's death would become the king. $If the$ son has his 18th birthday exactly on the day of the king's death, he can become a king.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2016] King’s Heir", "background": "", "description": "\n\nThe king is dead, long live the king! After the sudden death of the king Fert XIII the people of the Flatland Kingdom are going to welcome the new king. Unfortunately, there is a problem, Fert has too many sons.\n\nActually, he has $n$ sons and he loved each new son more than all of his previous sons. Well, probably he just stopped loving his sons because of their bad behavior. Anyway, after the new son was born Fert made the new testament that declared that the newly born son would be the heir.\n\nHowever, there is a problem. Only the king's son who is at least $18$ years old at the moment of the $king's death$ can become a new king. Now the ministers of the government are trying to find the correct $new king,$ but they seem to fail. Help them!\n\n", "inputFormat": "\n\nThe first line of the input contains three integers: $d , m$ and $y$ -- the day, the month and the year of the king's death, $d$ is from $1$ to $31$ , $m$ is from $1$ to $12 , y$ is from $1$ to $9999$ . It is guaranteed that there exists day $d$ in month $m$ , all months have the same number of days in Flatland as in our country, except that Flatland calendar doesn't have leap years, so February (month $2$) always has $28$ days.\n\nThe second line contains $n (1 \\le n \\le 100)$ -- the number of king's sons. The following $n$ lines contain three integers each $d_{i}, m_{i}$ and $ y_{i}$ and specify the birth dates of king's sons. All dates are correct and no son is born after or on the day of king's death. The king had no twins, so no two sons were born on the same date.\n\n", "outputFormat": "\n\nOutput one integer -- the number of the son that would become the king, or $−1$ if none of them is $at least 18$ years old. The sons are numbered from $1$ to $n$ in order they are described in the input. The youngest son who is at least $18$ years old at the moment of the king's death would become the king. $If the$ son has his 18th birthday exactly on the day of the king's death, he can become a king.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2016] King’s Heir", "background": "", "description": "国王去世了，国王万岁！在国王 Fert XIII 突然去世后，平面王国的人民将迎接新国王。不幸的是，出现了一个问题，Fert 有太多的儿子。\n\n实际上，他有 $n$ 个儿子，并且他对每个新儿子的爱都超过了他之前所有的儿子。可能是因为他们的坏行为，他不再爱他的儿子们。无论如何，在新儿子出生后，Fert 制定了新的遗嘱，宣布新出生的儿子将成为继承人。\n\n然而，问题在于，只有在国王去世时年满 $18$ 岁的国王儿子才能成为新国王。现在，政府的部长们正在努力寻找正确的新国王，但他们似乎失败了。请帮助他们！", "inputFormat": "输入的第一行包含三个整数：$d, m$ 和 $y$ —— 国王去世的日期、月份和年份，$d$ 从 $1$ 到 $31$，$m$ 从 $1$ 到 $12$，$y$ 从 $1$ 到 $9999$。可以保证在月份 $m$ 中存在日期 $d$，平面王国的所有月份的天数与我们国家相同，只是平面王国的日历没有闰年，因此二月（第 $2$ 个月）总是有 $28$ 天。\n\n第二行包含 $n (1 \\le n \\le 100)$ —— 国王的儿子数量。接下来的 $n$ 行每行包含三个整数 $d_{i}, m_{i}$ 和 $y_{i}$，指定国王儿子的出生日期。所有日期都是正确的，并且没有儿子在国王去世当天或之后出生。国王没有双胞胎，因此没有两个儿子在同一天出生。", "outputFormat": "输出一个整数 —— 成为国王的儿子的编号，如果没有一个儿子在国王去世时至少 $18$ 岁，则输出 $-1$。儿子按输入中描述的顺序从 $1$ 到 $n$ 编号。最年轻的在国王去世时至少 $18$ 岁的儿子将成为国王。如果儿子在国王去世当天正好满 $18$ 岁，他可以成为国王。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P7042", "type": "P", "difficulty": 2, "samples": [["3\n1 3 3 1\n2 4 7 8\n2 3 1 4", "4\n0\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "计算几何", "O2优化", "洛谷月赛"], "title": "「MCOI-03」正方", "background": "MC 中没有圆。\n\n所以小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 喜欢 Square。", "description": "给定一个正方形，求有多少个正方形内的点满足与正方形四个顶点划分出来的四块面积的比为 $a:b:c:d$。四个数不分顺序。\n\n比如如下图所示假设一个点 E 使得分成的四个三角形的面积之比为 $a:b:c:d$，那么这个点 E 就符合要求。因为不分顺序，所以分出来的比是 $d:b:a:c$ 也可以。但是点 E 不是唯一解，你要输出的是解的个数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/95llbbcx.png)\n\n因为小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 很喜欢询问，所以本题给定了 $q$ 组询问。", "inputFormat": "第一行一个整数 $q$ 代表询问个数。     \n接下来 $q$ 行每行四个整数 $a,b,c,d$。", "outputFormat": "$q$ 行每行一个整数代表答案。", "hint": "#### 数据规模与约定\n\n对于 $20\\%$ 的数据，$a=b=c=d$。    \n对于 $100\\%$ 的数据，$1 \\le a,b,c,d \\le 9 \\times 10^{18}$，$1 \\le q \\le 100$，不保证 $a:b:c:d$ 为最简比，不保证 $a,b,c,d$ 为升序。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MCOI-03」正方", "background": "MC 中没有圆。\n\n所以小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 喜欢 Square。", "description": "给定一个正方形，求有多少个正方形内的点满足与正方形四个顶点划分出来的四块面积的比为 $a:b:c:d$。四个数不分顺序。\n\n比如如下图所示假设一个点 E 使得分成的四个三角形的面积之比为 $a:b:c:d$，那么这个点 E 就符合要求。因为不分顺序，所以分出来的比是 $d:b:a:c$ 也可以。但是点 E 不是唯一解，你要输出的是解的个数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/95llbbcx.png)\n\n因为小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 很喜欢询问，所以本题给定了 $q$ 组询问。", "inputFormat": "第一行一个整数 $q$ 代表询问个数。     \n接下来 $q$ 行每行四个整数 $a,b,c,d$。", "outputFormat": "$q$ 行每行一个整数代表答案。", "hint": "#### 数据规模与约定\n\n对于 $20\\%$ 的数据，$a=b=c=d$。    \n对于 $100\\%$ 的数据，$1 \\le a,b,c,d \\le 9 \\times 10^{18}$，$1 \\le q \\le 100$，不保证 $a:b:c:d$ 为最简比，不保证 $a,b,c,d$ 为升序。", "locale": "zh-CN"}}}
{"pid": "P7043", "type": "P", "difficulty": 3, "samples": [["2\n2 3\n2 6\n1 2\n3 5\n2 6 4\n1 3\n2 3", "2\n3"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144]}, "tags": ["O2优化", "洛谷月赛"], "title": "「MCOI-03」村国", "background": "$\\texttt{What did this player dream?}$\n\n他梦见了什么？\n\n$\\texttt{This player dreamed of sunlight and trees.Of fire and water.}$\n\n他梦见了阳光与树木。梦见了火与水。\n\n$\\texttt{It dreamed it created. And it dreamed it destroyed. It dreamed it hunted,}$ \n$\\texttt{and was hunted. It dreamed of shelter.}$\n\n他梦见他的创造，亦梦见他毁灭。它梦见他在狩猎，亦梦见被猎捕。他梦见温馨的居所。\n\n$\\texttt{Hah, the original interface. A million years old, and it still works.But}$ \n$\\texttt{ what true structure did this player create, in the reality behind the screen?}$\n\n哎，那原始的界面。经历百万年的岁月，它依然在工作。只是他在屏幕后的真实里，到底创造了什么真实的世界呢？", "description": "C 国一共有 $N$ 个村庄，$N-1$ 条道路。这些道路都可以双向通行。保证小 S 可以从一座村庄到其他任何一座村庄。这 $N$ 个村庄编号为 $1$ 到 $N$。\n\n刚开始小 S 对第 $i$ 个村庄的好感值为 $A_i$。小 S 的假期一共有 $M$ 天，他会在 C 国旅行一共 $M$ 天。每一天他会选择来到当前好感值最高的村庄。如果有好感值相同的村庄，他会选择编号最小的村庄。假设这一天他来到村庄 $X$，那么这一天结束后，与村庄 $X$ 直接相邻所有村庄的好感值都会增加 $1$。即能从 $X$ 出发仅经过一条道路到达的村庄好感值会增加 $1$。因为小 S 已经在村庄 $X$ 待过一天了，所以这一天结束后村庄 $X$ 的好感值并不会增加。\n\n现在小 S 想要知道经过 $M$ 天的旅行后好感值最高的村庄。\n\n如果有多个好感值最高的村庄，输出编号最小的。", "inputFormat": "**本题单个测试点包含多组测试数据**。        \n第一行一个正整数 $T$ 表示数据组数。      \n对于每组数据：      \n第一行包括两个正整数 $N,M$，表示村庄个数和旅行天数。     \n接下来一行 $N$ 个整数，第 $i$ 个整数表示第 $i$ 座村庄的好感值 $A_i$。        \n接下来 $N-1$ 行。每行两个整数 $x,y$ 表示村庄 $x$ 和村庄 $y$ 之间有一条双向通行的道路。", "outputFormat": "一个整数表示 $M$ 天结束后好感值最高的村庄的编号。如果有多个好感值最高的村庄，输出编号最小的。", "hint": "#### 样例说明\n\n对于第一组数据，小 S 在 $2$ 号村庄旅行了 $3$ 天，结束时村庄 $1,2$ 的好感值分别为 $5,6$。所以答案输出 $2$。\n\n对于第二组数据，结束时三个村庄的好感值分别为 $3,7,8$，所以答案输出 $3$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le N\\le 2\\times10^6$，$1 \\le M\\le10^{18}$，$1 \\le A_i\\le2^{31}-1$，$1 \\le T\\le10$。\n\n| 测试点编号 | $A_i\\le$ | $\\sum N \\le$ | $M \\le $ | 测试点分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $\\rm 1$ | $10$ | $20$ | $10$ | $5$ |\n| $\\rm 2$ | $10^2$ | $2 \\times 10^2$ | $10^2$ | $10$ |\n| $\\rm 3$ | $10^3$ | $2 \\times 10^3$ | $10^3$ | $15$ |\n| $\\rm 4$ | $10^5$ | $2 \\times 10^5$ | $10^5$ | $25$ |\n| $\\rm 5$ |  | $2 \\times 10^6$ |  | $45$ |\n\n#### 提示\n\n**本题输入量较大，请使用较快的读入方式。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MCOI-03」村国", "background": "$\\texttt{What did this player dream?}$\n\n他梦见了什么？\n\n$\\texttt{This player dreamed of sunlight and trees.Of fire and water.}$\n\n他梦见了阳光与树木。梦见了火与水。\n\n$\\texttt{It dreamed it created. And it dreamed it destroyed. It dreamed it hunted,}$ \n$\\texttt{and was hunted. It dreamed of shelter.}$\n\n他梦见他的创造，亦梦见他毁灭。它梦见他在狩猎，亦梦见被猎捕。他梦见温馨的居所。\n\n$\\texttt{Hah, the original interface. A million years old, and it still works.But}$ \n$\\texttt{ what true structure did this player create, in the reality behind the screen?}$\n\n哎，那原始的界面。经历百万年的岁月，它依然在工作。只是他在屏幕后的真实里，到底创造了什么真实的世界呢？", "description": "C 国一共有 $N$ 个村庄，$N-1$ 条道路。这些道路都可以双向通行。保证小 S 可以从一座村庄到其他任何一座村庄。这 $N$ 个村庄编号为 $1$ 到 $N$。\n\n刚开始小 S 对第 $i$ 个村庄的好感值为 $A_i$。小 S 的假期一共有 $M$ 天，他会在 C 国旅行一共 $M$ 天。每一天他会选择来到当前好感值最高的村庄。如果有好感值相同的村庄，他会选择编号最小的村庄。假设这一天他来到村庄 $X$，那么这一天结束后，与村庄 $X$ 直接相邻所有村庄的好感值都会增加 $1$。即能从 $X$ 出发仅经过一条道路到达的村庄好感值会增加 $1$。因为小 S 已经在村庄 $X$ 待过一天了，所以这一天结束后村庄 $X$ 的好感值并不会增加。\n\n现在小 S 想要知道经过 $M$ 天的旅行后好感值最高的村庄。\n\n如果有多个好感值最高的村庄，输出编号最小的。", "inputFormat": "**本题单个测试点包含多组测试数据**。        \n第一行一个正整数 $T$ 表示数据组数。      \n对于每组数据：      \n第一行包括两个正整数 $N,M$，表示村庄个数和旅行天数。     \n接下来一行 $N$ 个整数，第 $i$ 个整数表示第 $i$ 座村庄的好感值 $A_i$。        \n接下来 $N-1$ 行。每行两个整数 $x,y$ 表示村庄 $x$ 和村庄 $y$ 之间有一条双向通行的道路。", "outputFormat": "一个整数表示 $M$ 天结束后好感值最高的村庄的编号。如果有多个好感值最高的村庄，输出编号最小的。", "hint": "#### 样例说明\n\n对于第一组数据，小 S 在 $2$ 号村庄旅行了 $3$ 天，结束时村庄 $1,2$ 的好感值分别为 $5,6$。所以答案输出 $2$。\n\n对于第二组数据，结束时三个村庄的好感值分别为 $3,7,8$，所以答案输出 $3$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le N\\le 2\\times10^6$，$1 \\le M\\le10^{18}$，$1 \\le A_i\\le2^{31}-1$，$1 \\le T\\le10$。\n\n| 测试点编号 | $A_i\\le$ | $\\sum N \\le$ | $M \\le $ | 测试点分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $\\rm 1$ | $10$ | $20$ | $10$ | $5$ |\n| $\\rm 2$ | $10^2$ | $2 \\times 10^2$ | $10^2$ | $10$ |\n| $\\rm 3$ | $10^3$ | $2 \\times 10^3$ | $10^3$ | $15$ |\n| $\\rm 4$ | $10^5$ | $2 \\times 10^5$ | $10^5$ | $25$ |\n| $\\rm 5$ |  | $2 \\times 10^6$ |  | $45$ |\n\n#### 提示\n\n**本题输入量较大，请使用较快的读入方式。**", "locale": "zh-CN"}}}
{"pid": "P7044", "type": "P", "difficulty": 5, "samples": [["3 1\n(()", "6"], ["3 2\n(()", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化", "组合数学", "洛谷月赛"], "title": "「MCOI-03」括号", "background": "MCOI q 群的日常 ……\n\n> 一只书虫仔：挖不到钻石，我要哭了（笑）     \n> WAPER420：我们分明次次挖到钻石啊（疑惑）   \n> 一只书虫仔：（友善的笑容）     \n> 7KByte：为什么你们都喜欢加括号啊（呆呆地望着）      \n> 一只书虫仔：（笑）  \n> WAPER420：（笑）     \n> 鏡音リン：（笑）     \n> 7KByte：（笑）\n\n---\n\n本题中 **合法括号串** 的定义如下：\n\n1. 空串是合法括号串。\n2. 如果 ```A``` 是合法括号串，则 ```(A)``` 是合法括号串。\n3. 如果 ```A```，```B``` 是合法括号串，则 ```AB``` 是合法括号串。\n\n本题中 **子串** 的定义如下：\n\n字符串 $S$ 的子串是 $S$ 中连续的任意个字符组成的字符串。$S$ 的子串可用起始位置 $l$ 与终止位置 $r$ 来表示，记为 $S(l,r)$（$1 \\leq l \\leq r \\leq |S|$，$|S |$ 表示 ```S``` 的长度）。", "description": "定义一个括号串的 $0$ 级偏值为将该括号串修改为 **合法括号串** 需要的最小操作数。一次操作你可以在一个位置 **添加** 一个括号或者 **删除** 一个位置的括号。\n\n定义一个括号串的 $i\\ (i>0)$ 级偏值为该串 **所有子串** 的 $i-1$ 级偏值之和。\n\n现在你需要求出一个长度为 $N$ 的括号串 $S$ 的 $K$ 级偏值。答案可能很大，输出对 $998244353$ 取模后的结果。", "inputFormat": "第一行包括两个整数 $N,K$。\n\n第二行一个字符串代表括号序列 $S$。", "outputFormat": "一行一个整数代表答案对 $998244353$ 取模的结果。", "hint": "#### 样例说明\n\n对于样例 $1$，$S$ 的所有子串的 $0$ 级代价为：\n\n- $\\texttt{(}$，代价为 $1$\n- $\\texttt{(}$，代价为 $1$\n- $\\texttt{)}$，代价为 $1$\n- $\\texttt{((}$，代价为 $2$\n- $\\texttt{()}$，代价为 $0$\n- $\\texttt{(()}$，代价为 $1$\n\n总和为 $1+1+1+2+0+1=6$。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $N\\le$ | $K\\le$ | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $5$ | $5$ | $3$ |\n| $2$ | $5\\times 10^3$ | $1$ | $10$ |\n| $3$ | $10^6$ | $1$ | $12$ |\n| $4$ | $10^2$ | $10^2$ | $10$ |\n| $5$ | $5\\times10^3$ | $5\\times 10^3$ | $20$ |\n| $6$ | $10^6$ | $10^6$ | $45$ |\n\n\n对于 $100\\%$ 的数据，$1 \\le N,K \\le  10^6$。\n\n---\n\n原 idea：WAPER420", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MCOI-03」括号", "background": "MCOI q 群的日常 ……\n\n> 一只书虫仔：挖不到钻石，我要哭了（笑）     \n> WAPER420：我们分明次次挖到钻石啊（疑惑）   \n> 一只书虫仔：（友善的笑容）     \n> 7KByte：为什么你们都喜欢加括号啊（呆呆地望着）      \n> 一只书虫仔：（笑）  \n> WAPER420：（笑）     \n> 鏡音リン：（笑）     \n> 7KByte：（笑）\n\n---\n\n本题中 **合法括号串** 的定义如下：\n\n1. 空串是合法括号串。\n2. 如果 ```A``` 是合法括号串，则 ```(A)``` 是合法括号串。\n3. 如果 ```A```，```B``` 是合法括号串，则 ```AB``` 是合法括号串。\n\n本题中 **子串** 的定义如下：\n\n字符串 $S$ 的子串是 $S$ 中连续的任意个字符组成的字符串。$S$ 的子串可用起始位置 $l$ 与终止位置 $r$ 来表示，记为 $S(l,r)$（$1 \\leq l \\leq r \\leq |S|$，$|S |$ 表示 ```S``` 的长度）。", "description": "定义一个括号串的 $0$ 级偏值为将该括号串修改为 **合法括号串** 需要的最小操作数。一次操作你可以在一个位置 **添加** 一个括号或者 **删除** 一个位置的括号。\n\n定义一个括号串的 $i\\ (i>0)$ 级偏值为该串 **所有子串** 的 $i-1$ 级偏值之和。\n\n现在你需要求出一个长度为 $N$ 的括号串 $S$ 的 $K$ 级偏值。答案可能很大，输出对 $998244353$ 取模后的结果。", "inputFormat": "第一行包括两个整数 $N,K$。\n\n第二行一个字符串代表括号序列 $S$。", "outputFormat": "一行一个整数代表答案对 $998244353$ 取模的结果。", "hint": "#### 样例说明\n\n对于样例 $1$，$S$ 的所有子串的 $0$ 级代价为：\n\n- $\\texttt{(}$，代价为 $1$\n- $\\texttt{(}$，代价为 $1$\n- $\\texttt{)}$，代价为 $1$\n- $\\texttt{((}$，代价为 $2$\n- $\\texttt{()}$，代价为 $0$\n- $\\texttt{(()}$，代价为 $1$\n\n总和为 $1+1+1+2+0+1=6$。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $N\\le$ | $K\\le$ | 分值 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $5$ | $5$ | $3$ |\n| $2$ | $5\\times 10^3$ | $1$ | $10$ |\n| $3$ | $10^6$ | $1$ | $12$ |\n| $4$ | $10^2$ | $10^2$ | $10$ |\n| $5$ | $5\\times10^3$ | $5\\times 10^3$ | $20$ |\n| $6$ | $10^6$ | $10^6$ | $45$ |\n\n\n对于 $100\\%$ 的数据，$1 \\le N,K \\le  10^6$。\n\n---\n\n原 idea：WAPER420", "locale": "zh-CN"}}}
{"pid": "P7045", "type": "P", "difficulty": 6, "samples": [["2\n3 100\n\n1\n\n1\n\n1\n\n\n2 100\n\n0", "\n\n0 1\n\n0 2\n\n1 2\n\n3\n0 1 2\n\n0 1\n\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["交互题", "Special Judge", "O2优化", "构造", "洛谷月赛"], "title": "「MCOI-03」金牌", "background": "**这是一道交互题**。\n\n书虫有很多块金牌！", "description": "书虫正在整理他的 $n$ 块金牌，他发现所有金牌都是有磁性的！形式地说，每块金牌属于一种磁极，**磁极有很多种**。两块相邻的金牌磁极相同则相互排斥，不同则相互吸引。\n\n书虫不知道每块金牌的磁极，他只能通过把两块金牌靠近的方式得知它们是相同磁极还是不同磁极。换句话说，你可以进行不超过 $Q$ 次交互，每次向交互库询问两个数 $x,y$，交互库会返回第 $x$ 块金牌和第 $y$ 块金牌是排斥还是吸引。金牌从 $0$ 到 $n-1$ 编号。\n\n书虫希望把他的金牌排成一个排列，满足任意两块相邻的金牌都相吸引，请你帮他排出 **任意一个** 合法的排列，或者告诉他无解。\n\n### 交互格式\n\n**本题包含多组数据**。输入的第一行包含一个整数 $T$, 代表数据组数。\n\n对于每一组数据，第一行读入两个整数 $n,Q$，代表金牌的数量和交互次数上限。\n\n如果你需要向交互库发起询问，请向标准输出中输出一行以空格隔开的两个整数 $x,y$ 并 **清空缓冲区**。关于如何清空缓冲区，在下面的提示中有说明。接下来，从标准输入中读入一个整数 $ret$。如果 $ret=1$ 表示第 $x$ 块金牌和第 $y$ 块金牌吸引，如果 $ret=0$ 表示它们排斥。\n\n如果你已经确定无解，请输出一行一个整数 $-1$ 并 **清空缓冲区**。然后本组数据结束，你应该接下来处理下一组数据。\n\n如果你已经确定有解，请先输出一行一个整数 $n$，接下来一行输出 **任意一组** 合法的金牌排列，并 **清空缓冲区**。然后本组数据结束，你应该接下来处理下一组数据。\n\n$T$ 组数据处理完之后你应该立即结束程序，多余的输出可能导致 RE。", "inputFormat": "见「交互格式」。", "outputFormat": "见「交互格式」。", "hint": "### 样例 1 解释\n\n样例中有两组数据。对于第一组数据，共有三块金牌，通过三次交互得知，它们的磁极都互不相同，那么任意一种排列都是正确的。\n\n对于第二组数据，两块金牌的磁极相同，所以无解。\n\n### 数据规模与约定\n\n**本题使用捆绑测试**，数据范围如下表：\n\n| 测试点编号 | $Q=$ | 特殊性质 | 得分 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\frac{n(n-1)}{2}$ | $n\\ge 4$ | $10$ |\n| $2$ | $2n-2$ | 一种磁极最多只有 $2$ 块金牌 | $20$ |\n| $3$ | $2n-2$ | 磁极的种类不超过 $3$ 种 | $20$ |\n| $4$ | $3n$ | 无 | $20$ |\n| $5$ | $2n-2$ | 无 | $30$ |\n\n对于全部数据，$2\\le n\\le5\\times10^4$，$1\\le T\\le 5\\times 10^4$，$\\sum Q\\le 10^5$。\n\n### 提示\n\n你可以使用如下语句来清空缓冲区：\n\n- 对于 C/C++：```fflush(stdout);```\n- 对于 C++：```std::cout << std::flush;```\n- 对于 Java：```System.out.flush();```\n- 对于 Python：```stdout.flush();```\n- 对于 Pascal：```flush(output);```\n- 对于其他语言，请自行查阅对应语言的帮助文档。\n- 特别的，对于 C++ 语言，在输出换行时使用 ```std::endl ``` 而不是 ```'\\n'```，也可以自动刷新缓冲区。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MCOI-03」金牌", "background": "**这是一道交互题**。\n\n书虫有很多块金牌！", "description": "书虫正在整理他的 $n$ 块金牌，他发现所有金牌都是有磁性的！形式地说，每块金牌属于一种磁极，**磁极有很多种**。两块相邻的金牌磁极相同则相互排斥，不同则相互吸引。\n\n书虫不知道每块金牌的磁极，他只能通过把两块金牌靠近的方式得知它们是相同磁极还是不同磁极。换句话说，你可以进行不超过 $Q$ 次交互，每次向交互库询问两个数 $x,y$，交互库会返回第 $x$ 块金牌和第 $y$ 块金牌是排斥还是吸引。金牌从 $0$ 到 $n-1$ 编号。\n\n书虫希望把他的金牌排成一个排列，满足任意两块相邻的金牌都相吸引，请你帮他排出 **任意一个** 合法的排列，或者告诉他无解。\n\n### 交互格式\n\n**本题包含多组数据**。输入的第一行包含一个整数 $T$, 代表数据组数。\n\n对于每一组数据，第一行读入两个整数 $n,Q$，代表金牌的数量和交互次数上限。\n\n如果你需要向交互库发起询问，请向标准输出中输出一行以空格隔开的两个整数 $x,y$ 并 **清空缓冲区**。关于如何清空缓冲区，在下面的提示中有说明。接下来，从标准输入中读入一个整数 $ret$。如果 $ret=1$ 表示第 $x$ 块金牌和第 $y$ 块金牌吸引，如果 $ret=0$ 表示它们排斥。\n\n如果你已经确定无解，请输出一行一个整数 $-1$ 并 **清空缓冲区**。然后本组数据结束，你应该接下来处理下一组数据。\n\n如果你已经确定有解，请先输出一行一个整数 $n$，接下来一行输出 **任意一组** 合法的金牌排列，并 **清空缓冲区**。然后本组数据结束，你应该接下来处理下一组数据。\n\n$T$ 组数据处理完之后你应该立即结束程序，多余的输出可能导致 RE。", "inputFormat": "见「交互格式」。", "outputFormat": "见「交互格式」。", "hint": "### 样例 1 解释\n\n样例中有两组数据。对于第一组数据，共有三块金牌，通过三次交互得知，它们的磁极都互不相同，那么任意一种排列都是正确的。\n\n对于第二组数据，两块金牌的磁极相同，所以无解。\n\n### 数据规模与约定\n\n**本题使用捆绑测试**，数据范围如下表：\n\n| 测试点编号 | $Q=$ | 特殊性质 | 得分 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\frac{n(n-1)}{2}$ | $n\\ge 4$ | $10$ |\n| $2$ | $2n-2$ | 一种磁极最多只有 $2$ 块金牌 | $20$ |\n| $3$ | $2n-2$ | 磁极的种类不超过 $3$ 种 | $20$ |\n| $4$ | $3n$ | 无 | $20$ |\n| $5$ | $2n-2$ | 无 | $30$ |\n\n对于全部数据，$2\\le n\\le5\\times10^4$，$1\\le T\\le 5\\times 10^4$，$\\sum Q\\le 10^5$。\n\n### 提示\n\n你可以使用如下语句来清空缓冲区：\n\n- 对于 C/C++：```fflush(stdout);```\n- 对于 C++：```std::cout << std::flush;```\n- 对于 Java：```System.out.flush();```\n- 对于 Python：```stdout.flush();```\n- 对于 Pascal：```flush(output);```\n- 对于其他语言，请自行查阅对应语言的帮助文档。\n- 特别的，对于 C++ 语言，在输出换行时使用 ```std::endl ``` 而不是 ```'\\n'```，也可以自动刷新缓冲区。", "locale": "zh-CN"}}}
{"pid": "P7046", "type": "P", "difficulty": 6, "samples": [["5 5 1\nababa\n1 2\n2 3\n1 3\n1 4\n2 5", "0 0\n1 0\n3 2\n5 2\n6 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 2333, 2333, 2333, 2333, 2333, 2333, 2333, 2333, 2333, 2333], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["O2优化", "洛谷月赛"], "title": "「MCOI-03」诗韵", "background": "$\\texttt{And the game was over and the player woke up from the dream. }$\n\n游戏结束了，玩家从梦中醒来。\n\n$\\texttt{And the player began a new dream. }$\n\n并开始了新的梦境。\n\n$\\texttt{And the player dreamed again, dreamed better.}$\n\n并再次沉入梦境中，沉入更好的梦。\n\n$\\texttt{And the player was the universe. And the player was love.}$\n\n而玩家就是宇宙。而玩家就是爱。\n\n$\\texttt{You are the player.}$\n\n你就是那个玩家。\n\n\n$\\texttt{Wake up.}$\n\n\n该醒了。", "description": "小 C 想要写首诗文，但是写诗需要押韵。\n\n一首诗文是由需多句子组成，这些句子需要押韵。\n\n但押韵也有优劣。小 C 对押韵有一个评分。评分定义为这些句子的最长公共后缀长度，而韵脚被定义为这些句子的公共后缀。韵脚可以为空串，一个集合的韵脚可以有多个。\n\n最开始，小 C 一个句子也没有写出来。即最开始的记忆集合为空。\n\n小 C 会思考 $M$ 个时刻。每个时刻，他会想出一个句子。即向记忆集合中加入一个新的句子。\n\n小 C 可能会加入多个相同的句子，请只保留一个。因为他的记忆力很好，所以他想到的句子不会被遗忘。\n\n但是他不想花太多心思去造句，所以他认为，只要有 **大于** $K$ 个句子，就能写成一首诗。所以每想出一个句子后，他会向你询问集合所有的元素个数 $>K$ 的子集的评分的最大值，和集合所有元素个数 $>K$ 的子集的韵脚的种类。注意：如果有多个不同的满足条件的集合韵脚相同，则这个韵脚只能计算一次。\n\n由于小 C 很强，所以他造的所有句子的总长度可能非常大。为了方便告诉你这些句子，他造的每一个句子都是长度为 $N$ 的母串 $T$ 的子串。\n\n**注意**：集合是满足特异性的，即集合中的元素应该互不相同，如果有相同元素仅保留一个。", "inputFormat": "第一行包括三个整数 $N,M,K$。\n\n\n第二行包括一个长度为 $N$ 的字符串，即母串 $T$。   \n\n\n接下来 $M$ 行，每行两个整数 $l,r$，表示当前时刻 小C 想起的句子是母串的 $[l,r]$ 子串。", "outputFormat": "$M$ 行每行两个整数。第一个整数指不同的韵脚个数，第二个整数指评分的最大值。", "hint": "#### 样例解释\n\n第一个时刻后，记忆集合为 $\\{\\texttt{\"ab\"}\\}$。没有子集满足条件，输出 $0\\ 0$。\n\n第二个时刻后，记忆集合为 $\\{\\texttt{\"ab\",\"ba\"}\\}$。能得到的韵脚只有空串。\n\n第三个时刻后，记忆集合为 $\\{\\texttt{\"ab\",\"ba\",\"aba\"}\\}$。能得到的韵脚有空串，$\\texttt{\"a\"}$，$\\texttt{\"ba\"}$。\n\n第四个时刻后，记忆集合为 $\\{\\texttt{\"ab\",\"ba\",\"aba\",\"abab\"}\\}$。能得到的韵脚有空串，$\\texttt{\"a\"}$，$\\texttt{\"ba\"}$，$\\texttt{\"b\"}$，$\\texttt{\"ab\"}$。\n\n第五个时刻后，记忆集合为 $\\{\\texttt{\"ab\",\"ba\",\"aba\",\"abab\",\"baba\"}\\}$。能得到的韵脚有空串，$\\texttt{\"a\"}$，$\\texttt{\"ba\"}$，$\\texttt{\"b\"}$，$\\texttt{\"ab\"}$，$\\texttt{\"aba\"}$。\n\n#### 数据规模和约定\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $N\\le$ | $M\\le$ |  时限 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $10$ | $\\rm1s$ | $15$ |\n| $2$ | $ 10^3$ | $10^3$  | $\\rm 1s$ | $20$ |\n| $3$ | $10^5$ | $10^5$  | $\\rm 1s$ | $25$ |\n| $4$ | $ 5\\times 10^5$ | $5\\times 10^5$ | $\\rm 2.33s$ | $40$ |\n\n对于 $100\\%$ 的数据，$1 \\le N\\le 5\\times 10^5$，$1 \\le M\\le   5 \\times 10^5，0\\le K \\le M$。仅包含小写字母。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MCOI-03」诗韵", "background": "$\\texttt{And the game was over and the player woke up from the dream. }$\n\n游戏结束了，玩家从梦中醒来。\n\n$\\texttt{And the player began a new dream. }$\n\n并开始了新的梦境。\n\n$\\texttt{And the player dreamed again, dreamed better.}$\n\n并再次沉入梦境中，沉入更好的梦。\n\n$\\texttt{And the player was the universe. And the player was love.}$\n\n而玩家就是宇宙。而玩家就是爱。\n\n$\\texttt{You are the player.}$\n\n你就是那个玩家。\n\n\n$\\texttt{Wake up.}$\n\n\n该醒了。", "description": "小 C 想要写首诗文，但是写诗需要押韵。\n\n一首诗文是由需多句子组成，这些句子需要押韵。\n\n但押韵也有优劣。小 C 对押韵有一个评分。评分定义为这些句子的最长公共后缀长度，而韵脚被定义为这些句子的公共后缀。韵脚可以为空串，一个集合的韵脚可以有多个。\n\n最开始，小 C 一个句子也没有写出来。即最开始的记忆集合为空。\n\n小 C 会思考 $M$ 个时刻。每个时刻，他会想出一个句子。即向记忆集合中加入一个新的句子。\n\n小 C 可能会加入多个相同的句子，请只保留一个。因为他的记忆力很好，所以他想到的句子不会被遗忘。\n\n但是他不想花太多心思去造句，所以他认为，只要有 **大于** $K$ 个句子，就能写成一首诗。所以每想出一个句子后，他会向你询问集合所有的元素个数 $>K$ 的子集的评分的最大值，和集合所有元素个数 $>K$ 的子集的韵脚的种类。注意：如果有多个不同的满足条件的集合韵脚相同，则这个韵脚只能计算一次。\n\n由于小 C 很强，所以他造的所有句子的总长度可能非常大。为了方便告诉你这些句子，他造的每一个句子都是长度为 $N$ 的母串 $T$ 的子串。\n\n**注意**：集合是满足特异性的，即集合中的元素应该互不相同，如果有相同元素仅保留一个。", "inputFormat": "第一行包括三个整数 $N,M,K$。\n\n\n第二行包括一个长度为 $N$ 的字符串，即母串 $T$。   \n\n\n接下来 $M$ 行，每行两个整数 $l,r$，表示当前时刻 小C 想起的句子是母串的 $[l,r]$ 子串。", "outputFormat": "$M$ 行每行两个整数。第一个整数指不同的韵脚个数，第二个整数指评分的最大值。", "hint": "#### 样例解释\n\n第一个时刻后，记忆集合为 $\\{\\texttt{\"ab\"}\\}$。没有子集满足条件，输出 $0\\ 0$。\n\n第二个时刻后，记忆集合为 $\\{\\texttt{\"ab\",\"ba\"}\\}$。能得到的韵脚只有空串。\n\n第三个时刻后，记忆集合为 $\\{\\texttt{\"ab\",\"ba\",\"aba\"}\\}$。能得到的韵脚有空串，$\\texttt{\"a\"}$，$\\texttt{\"ba\"}$。\n\n第四个时刻后，记忆集合为 $\\{\\texttt{\"ab\",\"ba\",\"aba\",\"abab\"}\\}$。能得到的韵脚有空串，$\\texttt{\"a\"}$，$\\texttt{\"ba\"}$，$\\texttt{\"b\"}$，$\\texttt{\"ab\"}$。\n\n第五个时刻后，记忆集合为 $\\{\\texttt{\"ab\",\"ba\",\"aba\",\"abab\",\"baba\"}\\}$。能得到的韵脚有空串，$\\texttt{\"a\"}$，$\\texttt{\"ba\"}$，$\\texttt{\"b\"}$，$\\texttt{\"ab\"}$，$\\texttt{\"aba\"}$。\n\n#### 数据规模和约定\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | $N\\le$ | $M\\le$ |  时限 | 分值 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $10$ | $\\rm1s$ | $15$ |\n| $2$ | $ 10^3$ | $10^3$  | $\\rm 1s$ | $20$ |\n| $3$ | $10^5$ | $10^5$  | $\\rm 1s$ | $25$ |\n| $4$ | $ 5\\times 10^5$ | $5\\times 10^5$ | $\\rm 2.33s$ | $40$ |\n\n对于 $100\\%$ 的数据，$1 \\le N\\le 5\\times 10^5$，$1 \\le M\\le   5 \\times 10^5，0\\le K \\le M$。仅包含小写字母。\n", "locale": "zh-CN"}}}
{"pid": "P7047", "type": "P", "difficulty": 7, "samples": [["10", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "高精度", "O2优化", "剪枝", "洛谷月赛"], "title": "「MCOI-03」数据", "background": "Rin 正在给 MCOI Round 998244353 的题目出数据。\n\n但是她太菜了，把数据生成器写出锅了，于是数据只生成了一半然后生成器就 RE 了。\n\n现在她想请你用这一半的数据恢复出完整的数据。", "description": "以下是一些常见的定义，如果你很熟悉它们你也可以不看。\n\n01 串是指仅包含 ```0``` 和 ```1``` 两种字符的字符串，仅包含其中一种也是可以的。\n\n一个字符串取出其连续的一段称为子串。容易发现一个长度为 $2n$ 的字符串有 $n+1$ 个长度为 $n$ 的子串。\n\n一组实数 $A$ 的平均值 $\\overline{A}=\\frac{\\sum_{x\\in A}x}{|A|}$，即所有元素的和除以元素的个数。\n\n在此基础上，$A$ 的方差 $S^2=\\frac{\\sum_{x\\in A}(x-\\overline{A})^2}{|A|}$，即所有元素与平均值的差的平方和除以元素的个数。\n\n一个长度为 $n$ 的 01 串 $S$ 的二进制值等于 $\\sum_{i=1}^nS_i2^{n-i}$，其中 $S_i$ 是 $S$ 从左向右第 $i$ 个字符上的数字。\n\n在本题中，给出如下定义：\n\n一组数据是一个长度为 $2n$ 的 01 串。\n\n一组数据的毒瘤度定义为，其所有长度为 $n$ 的子串的二进制值的方差。\n\n现在，给定一组数据的前 $n$ 个字符。你需要找到使得这组数据的毒瘤度 **最小** 的后 $n$ 个字符。如果有多解，请按照这后 $n$ 个字符构成的子串的二进制值从小到大排序输出。\n\n", "inputFormat": "输入数据共一行，包含一个长度为 $n$ 的 01 串，表示一组数据的前 $n$ 个字符。", "outputFormat": "输出若干行，每一行一个长度为 $n$ 的 01 串，表示一组毒瘤度最小的数据的后 $n$ 个字符，按照其二进制值从小到大排序输出。", "hint": "#### 样例一解释\n\n在本例中 $n=2$，存在四组满足要求的数据分别是 ```1000```，```1001```，```1010```，```1011```。\n\n```1010``` 有三个长度为 $2$ 的子串，分别为 ```10```，```01```，```10```。它们的二进制值分别为 $2,1,2$。${2,1,2}$ 的平均值为 $\\frac{5}{3}$，方差为 $\\frac{2}{9}$。故 ```1010``` 的毒瘤度为 $\\frac{2}{9}$。\n\n可以计算出这四组数据的毒瘤度分别为 $\\frac{8}{9},\\frac{2}{3},\\frac{2}{9},\\frac{2}{3}$。其中 ```1010``` 是唯一毒瘤度最小的，故程序输出其后 $2$ 个字符 ```10```。\n\n#### 数据范围与提示\n\n保证所有数据随机生成。对于 01 串的每一位，其为 ```1``` 的概率都是 $\\frac{1}{2}$ 且不同位相互独立。\n\n本题不采用捆绑测试，按点给分。测试点 $1$ 计 $1$ 分，其他测试点每个计 $3$ 分。\n\n每个测试点 $n$ 的规模如下表：\n\n| 测试点编号 | $1$ | $2\\sim 7$ | $8\\sim 13$ | $14\\sim 16$ | \n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $n$ | $\\le 3$ | $\\le20$ | $=26$ | $=56$ | \n|**测试点编号**|$17\\sim 20$ | $21\\sim 24$ | $25\\sim 28$ | $29\\sim 34$ |\n|$n$|$=200$ | $=500$ | $\\le1000$ | $\\le 1500$ |\n\n提示：在 C++ 中您可以使用 $128$ 位整数```__int128```。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「MCOI-03」数据", "background": "Rin 正在给 MCOI Round 998244353 的题目出数据。\n\n但是她太菜了，把数据生成器写出锅了，于是数据只生成了一半然后生成器就 RE 了。\n\n现在她想请你用这一半的数据恢复出完整的数据。", "description": "以下是一些常见的定义，如果你很熟悉它们你也可以不看。\n\n01 串是指仅包含 ```0``` 和 ```1``` 两种字符的字符串，仅包含其中一种也是可以的。\n\n一个字符串取出其连续的一段称为子串。容易发现一个长度为 $2n$ 的字符串有 $n+1$ 个长度为 $n$ 的子串。\n\n一组实数 $A$ 的平均值 $\\overline{A}=\\frac{\\sum_{x\\in A}x}{|A|}$，即所有元素的和除以元素的个数。\n\n在此基础上，$A$ 的方差 $S^2=\\frac{\\sum_{x\\in A}(x-\\overline{A})^2}{|A|}$，即所有元素与平均值的差的平方和除以元素的个数。\n\n一个长度为 $n$ 的 01 串 $S$ 的二进制值等于 $\\sum_{i=1}^nS_i2^{n-i}$，其中 $S_i$ 是 $S$ 从左向右第 $i$ 个字符上的数字。\n\n在本题中，给出如下定义：\n\n一组数据是一个长度为 $2n$ 的 01 串。\n\n一组数据的毒瘤度定义为，其所有长度为 $n$ 的子串的二进制值的方差。\n\n现在，给定一组数据的前 $n$ 个字符。你需要找到使得这组数据的毒瘤度 **最小** 的后 $n$ 个字符。如果有多解，请按照这后 $n$ 个字符构成的子串的二进制值从小到大排序输出。\n\n", "inputFormat": "输入数据共一行，包含一个长度为 $n$ 的 01 串，表示一组数据的前 $n$ 个字符。", "outputFormat": "输出若干行，每一行一个长度为 $n$ 的 01 串，表示一组毒瘤度最小的数据的后 $n$ 个字符，按照其二进制值从小到大排序输出。", "hint": "#### 样例一解释\n\n在本例中 $n=2$，存在四组满足要求的数据分别是 ```1000```，```1001```，```1010```，```1011```。\n\n```1010``` 有三个长度为 $2$ 的子串，分别为 ```10```，```01```，```10```。它们的二进制值分别为 $2,1,2$。${2,1,2}$ 的平均值为 $\\frac{5}{3}$，方差为 $\\frac{2}{9}$。故 ```1010``` 的毒瘤度为 $\\frac{2}{9}$。\n\n可以计算出这四组数据的毒瘤度分别为 $\\frac{8}{9},\\frac{2}{3},\\frac{2}{9},\\frac{2}{3}$。其中 ```1010``` 是唯一毒瘤度最小的，故程序输出其后 $2$ 个字符 ```10```。\n\n#### 数据范围与提示\n\n保证所有数据随机生成。对于 01 串的每一位，其为 ```1``` 的概率都是 $\\frac{1}{2}$ 且不同位相互独立。\n\n本题不采用捆绑测试，按点给分。测试点 $1$ 计 $1$ 分，其他测试点每个计 $3$ 分。\n\n每个测试点 $n$ 的规模如下表：\n\n| 测试点编号 | $1$ | $2\\sim 7$ | $8\\sim 13$ | $14\\sim 16$ | \n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $n$ | $\\le 3$ | $\\le20$ | $=26$ | $=56$ | \n|**测试点编号**|$17\\sim 20$ | $21\\sim 24$ | $25\\sim 28$ | $29\\sim 34$ |\n|$n$|$=200$ | $=500$ | $\\le1000$ | $\\le 1500$ |\n\n提示：在 C++ 中您可以使用 $128$ 位整数```__int128```。", "locale": "zh-CN"}}}
{"pid": "P7048", "type": "P", "difficulty": 2, "samples": [["210 297\n", "105.0\n"], ["250 100\n", "83.333333\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Alex Origami Squares", "background": "", "description": "\n\nAlex is fond of origami -- Japanese art of paper folding. Most origami designs start with a square sheet of paper. Alex is going to make a present for his mother. Present's design requires three equal square sheets of paper, but Alex has only one rectangular sheet. He is able to cut out squares of this sheet, but their sides should be parallel to the sides of the sheet. Help Alex to determine the maximum possible size of the paper squares he is able to cut out.\n\n", "inputFormat": "\n\nThe single line of the input file contains two integers $h$ and $w$ -- the height and the width of the sheet of paper $(1 \\le h , w \\le 1000)$ .\n\n", "outputFormat": "\n\nOutput a single real number -- the maximum possible length of the square side. It should be possible to cut out three such squares of $h \\times w$ sheet of paper, so that their sides are parallel to the sides of the sheet.\n\nYour answer should be precise up to three digits after the decimal point.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Alex Origami Squares", "background": "", "description": "\n\nAlex is fond of origami -- Japanese art of paper folding. Most origami designs start with a square sheet of paper. Alex is going to make a present for his mother. Present's design requires three equal square sheets of paper, but Alex has only one rectangular sheet. He is able to cut out squares of this sheet, but their sides should be parallel to the sides of the sheet. Help Alex to determine the maximum possible size of the paper squares he is able to cut out.\n\n", "inputFormat": "\n\nThe single line of the input file contains two integers $h$ and $w$ -- the height and the width of the sheet of paper $(1 \\le h , w \\le 1000)$ .\n\n", "outputFormat": "\n\nOutput a single real number -- the maximum possible length of the square side. It should be possible to cut out three such squares of $h \\times w$ sheet of paper, so that their sides are parallel to the sides of the sheet.\n\nYour answer should be precise up to three digits after the decimal point.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\nspj provider:@[shenyouran](/user/137367).", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Alex Origami Squares", "background": "", "description": "有一张矩形纸，要求将其裁成三个全等的正方形，且每一个正方形的侧面都与纸张的侧面平行，问裁成的小正方形边长最大是多少。", "inputFormat": "一行两个整数 $h$ 和 $w$ $(1\\le h,w\\le 10^3)$ 表示矩形纸张的长和宽。", "outputFormat": "输出一行一个实数，表示正方形边长的最大可能值。\n\n你的答案与标准答案的相对及绝对误差不应超过 $10^{-3}$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P7049", "type": "P", "difficulty": 4, "samples": [["2 3\n", "6 7\n@@@@@@@\n@.@@@@@\n@@...@@\n@@@@@@@\n.......\n@@@@@@@\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "Special Judge", "ICPC", "NWRRC"], "title": "[NWRRC 2015] Black and White", "background": "", "description": "\n\nThe jury has a great artistic idea -- to create a rectangular panel out of a huge pile of black and white squares of the same size. The panel should have exactly $b 4-connected$ areas made of black tiles, and $w 4-connected$ areas made of white tiles.\n\nRemember, a $4-connected$ area of some color is a maximal set of the panel tiles such that:\n\nany two tiles of the area share the same color;\n\nfor any two tiles of the area there is a tile sequence connecting them, such that any two consecutive tiles of the sequence share a common side.\n\nIn addition to the artistic idea, the jury has already developed a program that produces design of the panel. But since this problem is about art, any new solution is extremely important for the jury.\n\n", "inputFormat": "\n\nThe only line of the input file contains two integers $b$ and $w$ -- number of black and white areas $(1 \\le b , w \\le 1000)$ .\n\n", "outputFormat": "\n\nThe first line of the output file should contain the picture sizes $r$ and $c$ -- the number of rows and columns $(1 \\le r , c \\le 100 000)$ . This line should be followed by $r$ lines of $c$ symbols each. Each symbol should be either $‘@'$ (for black tile) or $‘. '$ (for white one). There should be no more than $100 000$ tiles in the panel.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en", "translations": {"en": {"title": "[NWRRC 2015] Black and White", "background": "", "description": "\n\nThe jury has a great artistic idea -- to create a rectangular panel out of a huge pile of black and white squares of the same size. The panel should have exactly $b 4-connected$ areas made of black tiles, and $w 4-connected$ areas made of white tiles.\n\nRemember, a $4-connected$ area of some color is a maximal set of the panel tiles such that:\n\nany two tiles of the area share the same color;\n\nfor any two tiles of the area there is a tile sequence connecting them, such that any two consecutive tiles of the sequence share a common side.\n\nIn addition to the artistic idea, the jury has already developed a program that produces design of the panel. But since this problem is about art, any new solution is extremely important for the jury.\n\n", "inputFormat": "\n\nThe only line of the input file contains two integers $b$ and $w$ -- number of black and white areas $(1 \\le b , w \\le 1000)$ .\n\n", "outputFormat": "\n\nThe first line of the output file should contain the picture sizes $r$ and $c$ -- the number of rows and columns $(1 \\le r , c \\le 100 000)$ . This line should be followed by $r$ lines of $c$ symbols each. Each symbol should be either $‘@'$ (for black tile) or $‘. '$ (for white one). There should be no more than $100 000$ tiles in the panel.\n\n", "hint": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "locale": "en"}, "zh-CN": {"title": "[NWRRC 2015] Black and White", "background": "", "description": "陪审团有一个很棒的艺术创意——用一大堆相同大小的黑白方块创建一个矩形面板。面板应该有恰好 $b$ 个 4-连通的黑色区域和 $w$ 个 4-连通的白色区域。\n\n请记住，一个颜色的 4-连通区域是面板方块的一个极大集合，使得：\n\n任何两个区域的方块颜色相同；\n\n对于区域的任何两个方块，都存在一个连接它们的方块序列，使得序列中的任何两个连续方块共享一个公共边。\n\n除了这个艺术创意，陪审团已经开发了一个程序来生成面板的设计。但由于这个问题涉及艺术，任何新的解决方案对陪审团来说都极其重要。", "inputFormat": "输入文件的唯一一行包含两个整数 $b$ 和 $w$——黑色和白色区域的数量 $(1 \\le b , w \\le 1000)$。", "outputFormat": "输出文件的第一行应包含图片的尺寸 $r$ 和 $c$——行数和列数 $(1 \\le r , c \\le 100 000)$。接下来的 $r$ 行中，每行应包含 $c$ 个符号。每个符号应为 ‘@’（表示黑色方块）或 ‘.’（表示白色方块）。面板中的方块数量不应超过 $100 000$。", "hint": "时间限制：2 秒，内存限制：256 MB。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
