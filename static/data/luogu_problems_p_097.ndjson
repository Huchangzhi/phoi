{"pid": "P2968", "type": "P", "difficulty": 4, "samples": [["14 3 \n7 3 \n11 1 \n13 8 \n", "5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09DEC] Bobsledding S", "background": "", "description": "Bessie 从山顶滑雪到山脚，山顶到山脚的距离是 $L$（$2 \\le L \\le 10^9$）。\n\nBessie 在起点的速度是 $1$，她可以在滑行的过程中改变速度：如果上一米的速度是 $v_0$，这一米的速度可以是 $v_0 + 1$、$v_0 - 1$ 或 $v_0$。\n\nBessie 会遇到 $N$（$1 \\le N \\le 10^5$）个转弯处，第 $i$ 个转弯处和出发点的距离是 $T_i$（$1 \\le T_i < L$）。为了安全，她到达第 $i$ 个转弯处时的速度不能超过 $S_i$（$1 \\le S_i \\le 10^9$）。贝茜到达终点时的速度没有最大限制。\n\n求 Bessie 在滑雪过程中的最高速度。", "inputFormat": "第一行两个正整数 $L$ 和 $N$。\n\n第 $i + 1$（$1 \\le i \\le N$）行两个正整数 $T_i$ 和 $S_i$。", "outputFormat": "一个整数，表示 Bessie 在滑雪过程中的最高速度。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09DEC] Bobsledding S", "background": null, "description": "Bessie has entered a bobsled competition because she hopes her hefty weight will give her an advantage over the $L$ meter course ($2 \\le L \\le 10^9$).\n\nBessie pushes off the starting line at $1$ meter per second, and her speed can change while she travels along the course. Near the middle of every meter Bessie covers, she can change her speed by using gravity to accelerate by $1$ meter per second, or by braking to keep the same speed or decrease her speed by $1$ meter per second.\n\nOn the way down the hill, Bessie must negotiate $N$ turns ($1 \\le N \\le 10^5$). Turn $i$ is located $T_i$ meters from the start ($1 \\le T_i < L$), and she must enter the meter that contains turn $i$ at a speed of at most $S_i$ meters per second ($1 \\le S_i \\le 10^9$). Bessie may cross the finish line at any speed.\n\nHelp Bessie determine the maximum speed she can attain anywhere on the course without exceeding the speed limits at the turns.\n\nConsider this course with the meter markers as integers and the turn speed limits in brackets (for example, \"[3]\"):\n\n```\n\n|   1   2   3   4   5   6   7[3]\n|---+---+---+---+---+---+---+\n|                            \\\nStart                         + 8    \n                               \\\n                                + 9    \n                                 \\\n                                  + 10       +++ 14 (finish)\n                                   \\         /\n                              11[1] +---+---+\n                                        12  13[8]\n```\n\nBelow is a chart of Bessie's speeds at the beginning of each meter along the course:\n\n```\nMax:                              3               1       8 \nMtrs: 0   1   2   3   4   5   6   7   8   9  10  11  12  13  14\nSpd:  1   2   3   4   5   5   4   3   4   3   2   1   2   3   4 \n```\n\nHer maximum speed was $5$ near the beginning of meter $4$.", "inputFormat": "* Line $1$: Two space-separated integers: $L$ and $N$.\n* Lines $2$ to $N+1$: Line $i+1$ describes turn $i$ with two space-separated integers: $T_i$ and $S_i$.", "outputFormat": "* Line 1: A single integer, representing the maximum speed that Bessie can attain between the start and the finish line, inclusive.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO09DEC] Bobsledding S", "background": "", "description": "Bessie 从山顶滑雪到山脚，山顶到山脚的距离是 $L$（$2 \\le L \\le 10^9$）。\n\nBessie 在起点的速度是 $1$，她可以在滑行的过程中改变速度：如果上一米的速度是 $v_0$，这一米的速度可以是 $v_0 + 1$、$v_0 - 1$ 或 $v_0$。\n\nBessie 会遇到 $N$（$1 \\le N \\le 10^5$）个转弯处，第 $i$ 个转弯处和出发点的距离是 $T_i$（$1 \\le T_i < L$）。为了安全，她到达第 $i$ 个转弯处时的速度不能超过 $S_i$（$1 \\le S_i \\le 10^9$）。贝茜到达终点时的速度没有最大限制。\n\n求 Bessie 在滑雪过程中的最高速度。", "inputFormat": "第一行两个正整数 $L$ 和 $N$。\n\n第 $i + 1$（$1 \\le i \\le N$）行两个正整数 $T_i$ 和 $S_i$。", "outputFormat": "一个整数，表示 Bessie 在滑雪过程中的最高速度。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2969", "type": "P", "difficulty": 2, "samples": [["3 5 \n2 \n1 \n3 \n2 \n3 \n4 \n0 \n1 \n", "2 \n3 \n3 \n1 \n1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO", "排序", "前缀和"], "title": "[USACO09DEC] Music Notes S", "background": "", "description": "FJ is going to teach his cows how to play a song. The song consists of N (1 <= N <= 50,000) notes, and the i-th note lasts for B\\_i (1 <= B\\_i <= 10,000) beats (thus no song is longer than 500,000,000 beats). The cows will begin playing the song at time 0; thus, they will play note 1 from time 0 through just before time B\\_1, note 2 from time B\\_1 through just before time B\\_1 + B\\_2, etc.\n\nHowever, recently the cows have lost interest in the song, as they feel that it is too long and boring. Thus, to make sure his cows are paying attention, he asks them Q (1 <= Q <= 50,000) questions of the form, 'In the interval from time T through just before time T+1, which note should you be playing?' The cows need your help to answer these questions which are supplied as T\\_i (0 <= T\\_i <=\n\nend\\_of\\_song). \n\nConsider this song with three notes of durations 2, 1, and 3 beats:\n\n```cpp\nBeat:   0    1    2    3    4    5    6    ...\n        |----|----|----|----|----|----|--- ...\n        1111111111     :              :\n                  22222:              :\n                       333333333333333:\n``` \nHere is a set of five queries along with the resulting answer:\n\nQuery    Note\n\n2        2\n\n3        3\n\n4        3\n\n0        1\n\n1        1\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and Q\n\n\\* Lines 2..N+1: Line i+1 contains the single integer: B\\_i\n\n\\* Lines N+2..N+Q+1: Line N+i+1 contains a single integer: T\\_i\n", "outputFormat": "\\* Lines 1..Q: For each query, print a single integer that is the index of the note that the cows should be playing.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO09DEC] Music Notes S", "background": "", "description": "FJ is going to teach his cows how to play a song. The song consists of N (1 <= N <= 50,000) notes, and the i-th note lasts for B\\_i (1 <= B\\_i <= 10,000) beats (thus no song is longer than 500,000,000 beats). The cows will begin playing the song at time 0; thus, they will play note 1 from time 0 through just before time B\\_1, note 2 from time B\\_1 through just before time B\\_1 + B\\_2, etc.\n\nHowever, recently the cows have lost interest in the song, as they feel that it is too long and boring. Thus, to make sure his cows are paying attention, he asks them Q (1 <= Q <= 50,000) questions of the form, 'In the interval from time T through just before time T+1, which note should you be playing?' The cows need your help to answer these questions which are supplied as T\\_i (0 <= T\\_i <=\n\nend\\_of\\_song). \n\nConsider this song with three notes of durations 2, 1, and 3 beats:\n\n```cpp\nBeat:   0    1    2    3    4    5    6    ...\n        |----|----|----|----|----|----|--- ...\n        1111111111     :              :\n                  22222:              :\n                       333333333333333:\n``` \nHere is a set of five queries along with the resulting answer:\n\nQuery    Note\n\n2        2\n\n3        3\n\n4        3\n\n0        1\n\n1        1\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and Q\n\n\\* Lines 2..N+1: Line i+1 contains the single integer: B\\_i\n\n\\* Lines N+2..N+Q+1: Line N+i+1 contains a single integer: T\\_i\n", "outputFormat": "\\* Lines 1..Q: For each query, print a single integer that is the index of the note that the cows should be playing.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO09DEC] Music Notes S", "background": "", "description": "FJ 准备教他的奶牛们演奏一首歌曲。这首歌由 $N$ 个音符组成，其中第 $i$ 个音符持续 $B_i$ 个节拍（$1 \\leq N \\leq 50,000$，$1 \\leq B_i \\leq 10,000$），因此整首歌的长度不会超过 500,000,000 个节拍。奶牛们将在时间 0 开始演奏这首歌，因此它们将在时间 0 到时间 $B_1$ 之前演奏第 1 个音符，在时间 $B_1$ 到时间 $B_1 + B_2$ 之前演奏第 2 个音符，依此类推。\n\n然而，最近奶牛们对这首歌失去了兴趣，因为它们觉得这首歌太长且无聊。因此，为了确保奶牛们集中注意力，他向它们提出了 $Q$ 个问题（$1 \\leq Q \\leq 50,000$），问题的形式为「在时间 $T$ 到时间 $T+1$ 之前的区间内，你应该演奏哪个音符？」奶牛们需要你的帮助来回答这些问题，这些问题以 $T_i$ 的形式给出（$0 \\leq T_i \\leq \\text{end\\_of\\_song}$）。\n\n考虑这首由三个音符组成的歌曲，音符的持续时间分别为 2、1 和 3 个节拍：\n\n```cpp\nBeat:   0    1    2    3    4    5    6    ...\n        |----|----|----|----|----|----|--- ...\n        1111111111     :              :\n                  22222:              :\n                       333333333333333:\n``` \n这里有一组五个查询及其对应的答案：\n\nQuery    Note\n\n2        2\n\n3        3\n\n4        3\n\n0        1\n\n1        1\n", "inputFormat": "\\* 第 1 行：两个用空格分隔的整数：$N$ 和 $Q$\n\n\\* 第 2 行到第 $N+1$ 行：第 $i+1$ 行包含一个整数：$B_i$\n\n\\* 第 $N+2$ 行到第 $N+Q+1$ 行：第 $N+i+1$ 行包含一个整数：$T_i$\n", "outputFormat": "\\* 第 1 行到第 $Q$ 行：对于每个查询，输出一个整数，表示奶牛们应该演奏的音符的索引。\n", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2970", "type": "P", "difficulty": 2, "samples": [["5 \n2 4 \n1 12 \n4 5 \n7 10 \n7 8 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2009", "USACO", "排序"], "title": "[USACO09DEC] Selfish Grazing S", "background": "", "description": "Each of Farmer John's N (1 <= N <= 50,000) cows likes to graze in a certain part of the pasture, which can be thought of as a large one-dimeensional number line. Cow i's favorite grazing range starts at location S\\_i and ends at location E\\_i (1 <= S\\_i < E\\_i; S\\_i < E\\_i <= 100,000,000).\n\nMost folks know the cows are quite selfish; no cow wants to share any of its grazing area with another. Thus, two cows i and j can only graze at the same time if either S\\_i >= E\\_j or E\\_i <= S\\_j. FJ would like to know the maximum number of cows that can graze at the same time for a given set of cows and their preferences.\n\nConsider a set of 5 cows with ranges shown below:\n\n```cpp\n  ... 1    2    3    4    5    6    7    8    9   10   11   12   13 ...\n  ... |----|----|----|----|----|----|----|----|----|----|----|----|----\nCow 1:      <===:===>          :              :              :\nCow 2: <========:==============:==============:=============>:\nCow 3:          :     <====>   :              :              :\nCow 4:          :              :     <========:===>          :\nCow 5:          :              :     <==>     :              :\n```\nThese ranges represent (2, 4), (1, 12), (4, 5), (7, 10), and (7, 8), respectively.\n\nFor a solution, the first, third, and fourth (or fifth) cows can all graze at the same time. If the second cow grazed, no other cows could graze. Also, the fourth and fifth cows cannot graze together, so it is impossible for four or more cows to graze.\n\n约翰有N(1≤N≤50000)头牛，约翰的草地可以认为是一条直线．每只牛只喜欢在某个特定的范围内吃草．第i头牛喜欢在区间(Si，Ei)吃草，1≤Si<Ei≤1,000,000,00.\n\n奶牛们都很自私，他们不喜欢和其他奶牛共享自己喜欢吃草的领域，因此约翰要保证任意\n\n两头牛都不会共享他们喜欢吃草昀领域．如果奶牛i和奶牛J想要同时吃草，那么要满足：Si>=Ej或者Ei≤Sj．约翰想知道在同一时刻，最多可以有多少头奶牛同时吃草？\n", "inputFormat": "\\* Line 1: A  single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains the two space-separated integers: S\\_i and E\\_i\n", "outputFormat": "\\* Line 1: A single integer representing the maximum number of cows that can graze at once.\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09DEC] Selfish Grazing S", "background": "", "description": "Each of Farmer John’s $N$ cows ($1 \\le N \\le 50{,}000$) likes to graze in a specific part of the pasture, which can be modeled as a large one-dimensional number line. Cow $i$’s favorite grazing range starts at location $S_i$ and ends at location $E_i$ ($1 \\le S_i < E_i \\le 100{,}000{,}000$).\n\nCows are quite selfish; no cow wants to share any of its grazing area with another. Thus, two cows $i$ and $j$ can graze at the same time only if $S_i \\ge E_j$ or $E_i \\le S_j$. Farmer John would like to know the maximum number of cows that can graze at the same time for a given set of cows and their preferences.\n\nConsider a set of 5 cows with ranges shown below:\n\n```cpp\n  ... 1    2    3    4    5    6    7    8    9   10   11   12   13 ...\n  ... |----|----|----|----|----|----|----|----|----|----|----|----|----\nCow 1:      <===:===>          :              :              :\nCow 2: <========:==============:==============:=============>:\nCow 3:          :     <====>   :              :              :\nCow 4:          :              :     <========:===>          :\nCow 5:          :              :     <==>     :              :\n```\n\nThese ranges represent (2, 4), (1, 12), (4, 5), (7, 10), and (7, 8), respectively.\n\nAs a solution, the first, third, and fourth (or fifth) cows can all graze at the same time. If the second cow grazed, no other cows could graze. Also, the fourth and fifth cows cannot graze together, so it is impossible for four or more cows to graze.", "inputFormat": "- Line 1: A single integer $N$.\n- Lines 2..$N+1$: Line $i+1$ contains two space-separated integers $S_i$ and $E_i$.", "outputFormat": "- Line 1: A single integer representing the maximum number of cows that can graze at once.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09DEC] Selfish Grazing S", "background": "", "description": "Each of Farmer John's N (1 <= N <= 50,000) cows likes to graze in a certain part of the pasture, which can be thought of as a large one-dimeensional number line. Cow i's favorite grazing range starts at location S\\_i and ends at location E\\_i (1 <= S\\_i < E\\_i; S\\_i < E\\_i <= 100,000,000).\n\nMost folks know the cows are quite selfish; no cow wants to share any of its grazing area with another. Thus, two cows i and j can only graze at the same time if either S\\_i >= E\\_j or E\\_i <= S\\_j. FJ would like to know the maximum number of cows that can graze at the same time for a given set of cows and their preferences.\n\nConsider a set of 5 cows with ranges shown below:\n\n```cpp\n  ... 1    2    3    4    5    6    7    8    9   10   11   12   13 ...\n  ... |----|----|----|----|----|----|----|----|----|----|----|----|----\nCow 1:      <===:===>          :              :              :\nCow 2: <========:==============:==============:=============>:\nCow 3:          :     <====>   :              :              :\nCow 4:          :              :     <========:===>          :\nCow 5:          :              :     <==>     :              :\n```\nThese ranges represent (2, 4), (1, 12), (4, 5), (7, 10), and (7, 8), respectively.\n\nFor a solution, the first, third, and fourth (or fifth) cows can all graze at the same time. If the second cow grazed, no other cows could graze. Also, the fourth and fifth cows cannot graze together, so it is impossible for four or more cows to graze.\n\n约翰有N(1≤N≤50000)头牛，约翰的草地可以认为是一条直线．每只牛只喜欢在某个特定的范围内吃草．第i头牛喜欢在区间(Si，Ei)吃草，1≤Si<Ei≤1,000,000,00.\n\n奶牛们都很自私，他们不喜欢和其他奶牛共享自己喜欢吃草的领域，因此约翰要保证任意\n\n两头牛都不会共享他们喜欢吃草昀领域．如果奶牛i和奶牛J想要同时吃草，那么要满足：Si>=Ej或者Ei≤Sj．约翰想知道在同一时刻，最多可以有多少头奶牛同时吃草？\n", "inputFormat": "\\* Line 1: A  single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains the two space-separated integers: S\\_i and E\\_i\n", "outputFormat": "\\* Line 1: A single integer representing the maximum number of cows that can graze at once.\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2971", "type": "P", "difficulty": 4, "samples": [["6 2 \n1 3 \n2 1 \n1 0 \n2 1 \n2 1 \n1 5 \n", "3 \n2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO", "树上启发式合并", "最近公共祖先 LCA", "树的直径", "树论"], "title": "[USACO10HOL] Cow Politics G", "background": null, "description": "农夫约翰的奶牛住在 $n$ 片不同的草地上，标号为 $1\\sim n$。\n\n恰好有 $n-1$ 条单位长度的双向道路，用各种各样的方法连接这些草地。而且从每片草地出发都可以抵达其他所有草地。也就是说，这些草地和道路构成了一种叫做树的图。输入包含一个详细的草地的集合，详细说明了每个草地的父节点 $p_i$。根节点的 $p_i=0$, 表示它没有父节点。\n\n因为奶牛建立了 $1\\sim k$ 一共 $k$ 个政党。每只奶牛都要加入某一个政党，其中， 第 $i$ 只奶牛属于第 $a_i$ 个政党。而且每个政党至少有两只奶牛。 每个政党都想知道自己的“范围”有多大。其中，定义一个政党的范围是这个政党离得最远的两只奶牛（沿着双向道路行走）的距离。", "inputFormat": "第一行两个整数 $n,k$。\n\n第 $2\\sim n+1$ 行：第 $i+1$ 行两个整数 $a_i,p_i$。", "outputFormat": "一共 $K$ 行，第 $i$ 行一个整数表示第 $i$ 个政党的范围。", "hint": "数据范围：$2 \\le n \\le 2\\times10^5,1 \\le k \\le \\frac n2,0\\le p_i\\le n,1\\le a_i\\le k$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10HOL] Cow Politics G", "background": "", "description": "Farmer John's cows live on $n$ different pastures, numbered $1 \\sim n$.\n\nThere are exactly $n-1$ undirected roads of unit length connecting these pastures, and from any pasture you can reach all others. In other words, the pastures and roads form a tree. The input specifies, for each pasture $i$, its parent $p_i$. The root has $p_i = 0$, meaning it has no parent.\n\nThere are $k$ political parties numbered $1 \\sim k$. Each cow joins exactly one party; specifically, cow $i$ (at pasture $i$) belongs to party $a_i$. Each party has at least two cows. Every party wants to know its \"range\", defined as the distance (along the undirected roads) between the farthest pair of cows within that party.", "inputFormat": "The first line contains two integers $n, k$.\n\nLines $2 \\sim n+1$: line $i+1$ contains two integers $a_i, p_i$.", "outputFormat": "Output $k$ lines. The $i$-th line contains a single integer, the range of party $i$.", "hint": "Constraints: $2 \\le n \\le 2 \\times 10^5, 1 \\le k \\le \\frac n2, 0 \\le p_i \\le n, 1 \\le a_i \\le k$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10HOL] Cow Politics G", "background": null, "description": "农夫约翰的奶牛住在 $n$ 片不同的草地上，标号为 $1\\sim n$。\n\n恰好有 $n-1$ 条单位长度的双向道路，用各种各样的方法连接这些草地。而且从每片草地出发都可以抵达其他所有草地。也就是说，这些草地和道路构成了一种叫做树的图。输入包含一个详细的草地的集合，详细说明了每个草地的父节点 $p_i$。根节点的 $p_i=0$, 表示它没有父节点。\n\n因为奶牛建立了 $1\\sim k$ 一共 $k$ 个政党。每只奶牛都要加入某一个政党，其中， 第 $i$ 只奶牛属于第 $a_i$ 个政党。而且每个政党至少有两只奶牛。 每个政党都想知道自己的“范围”有多大。其中，定义一个政党的范围是这个政党离得最远的两只奶牛（沿着双向道路行走）的距离。", "inputFormat": "第一行两个整数 $n,k$。\n\n第 $2\\sim n+1$ 行：第 $i+1$ 行两个整数 $a_i,p_i$。", "outputFormat": "一共 $K$ 行，第 $i$ 行一个整数表示第 $i$ 个政党的范围。", "hint": "数据范围：$2 \\le n \\le 2\\times10^5,1 \\le k \\le \\frac n2,0\\le p_i\\le n,1\\le a_i\\le k$。", "locale": "zh-CN"}}}
{"pid": "P2972", "type": "P", "difficulty": 5, "samples": [["3 2 10 \n1 5 \n1 3 \n2 3 \n3 1 \n", "No \nYes \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2010", "USACO"], "title": "[USACO10HOL] Rocks and Trees G", "background": "```\nMy country's bigger than most\nAnd if asked I boast\n'Cause I'm really proud\nSo I shout it loud\nThough our numbers are few\nWe will welcome you\nAlthough we don't have history\nGold medal winning teams\nHeroes or prisoners\nWorld famous volcanoes\nStill what we've got's glorious\n'Cause we've got\nRocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd water\n-The Arrogant Worms, on Canada\n（本段为诗歌，具体内容与题目无关）", "description": "After moving across the 49th parallel to Canada, the land of rocks and trees, Farmer John's cows invented a game to spend their leisure time on the pasture; naturally, it involved the rocks and trees! Cowboy Ted likes this game very much, but so poor is his luck that he always loses to other cows. This time, he is going to seek your help. \n\nThe game's rules are simple. It is played with a tree that has both $N$$(2 \\leqslant N \\leqslant10000)$nodes conveniently numbered $1 \\cdots N$ and also $N-1$ branches. Node 1 is the root of this tree; except for node 1, node $i$ has parent $P_i$ $(1 \\leqslant P_i < i)$. Initially, Each node contains some rocks (except the root node, which has no rocks). In particular, non-root node $i$ has exactly $R_i (1 \\leqslant R_i \\leqslant 1000)$ rocks at the beginning of the game. \n\nTwo players alternate turns to play this game in turn, with Ted going first. In each turn, the current player can choose a non-root node $i$ and move at most $L (1 \\leqslant L \\leqslant 1000)$ rocks from this node one branch closer to the root (i.e., move these rocks to the parent node). He must move at least one rock, and, of course, he cannot exceed the current number of rocks on this node. The game ends when a player can't make a legal move (i.e., when all the rocks are on node 1); that player loses. \n\nTed needs your help. He has given you the initial configuration of the game, and he will then make $T (1 \\leqslant T \\leqslant 10000)$changes to the configuration one by one. Please help him determine, after each step, if he can win the game beginning from this configuration, assuming both he and his opponent use the best possible strategy. \n\nTed's changes are specified as two integers $A_j (1 < A_j \\leqslant N)$ and $B_j (1 \\leqslant B_j \\leqslant 1000)$, meaning that Ted will change the number of rocks on node $A_j$ to $B_j$ (this is a `set` not a `subtract` or `add`), and will then ask you whether he can win. Changes accumulate; node $A_j$'s rocks stay at $B_j$ until another change for $A_j$ appears.\n\nConsider this example with three nodes numbered as shown and the shape shown in Board 0. Initially, there are 5 rocks on node 2 and 3 rocks on node 3; see Board 1.\n\nFor the first change, Ted removes 2 rocks from node 2 (thus leaving 3); see Board 2. For the second change, Ted removes 2 rocks from node 3 (thus leaving 1). Note that node 2 still has 3 rocks; see Board 3.\n\nBoard 0 Board 1 Board 2 Board 3\n\n（原题面并未给出链接）\n\nYour program should determine in each case who wins.\n\nFor about 30% of the test cases, $N \\leqslant 10$, and $T \\leqslant 100$, and no tree node will have more than 5 rocks on it after any of Ted's changes.\n\nPartial feedback will be provided for your first $50$ submissions.", "inputFormat": "Line $1$: Three space-separated integers: $N$, $T$, and $L$.  \nLines $2 \\cdots N$: Line i contains two space-separted integers: $P_i$ and $R_i$.  \nLines $N+1 \\cdots N+T$: Line $j+N$ describes Ted's next change using two space-separated integers: $A_j$ and $B_j$.", "outputFormat": "Lines $1 \\cdots T$: Line $i$ contains `Yes` if Ted can win the game after change $i$; and `No` otherwise.", "hint": "数据来源：bzoj。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10HOL] Rocks and Trees G", "background": "```\nMy country's bigger than most\nAnd if asked I boast\n'Cause I'm really proud\nSo I shout it loud\nThough our numbers are few\nWe will welcome you\nAlthough we don't have history\nGold medal winning teams\nHeroes or prisoners\nWorld famous volcanoes\nStill what we've got's glorious\n'Cause we've got\nRocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd water\n-The Arrogant Worms, on Canada\n（本段为诗歌，具体内容与题目无关）\n```\n\n(This passage is a poem; the content is unrelated to the problem.)", "description": "After moving across the 49th parallel to Canada, the land of rocks and trees, Farmer John's cows invented a game to spend their leisure time on the pasture; naturally, it involved the rocks and trees! Cowboy Ted likes this game very much, but so poor is his luck that he always loses to other cows. This time, he is going to seek your help.\n\nThe game's rules are simple. It is played with a tree that has both $N$ $(2 \\leqslant N \\leqslant10000)$ nodes conveniently numbered $1 \\cdots N$ and also $N-1$ branches. Node 1 is the root of this tree; except for node 1, node $i$ has parent $P_i$ $(1 \\leqslant P_i < i)$. Initially, each node contains some rocks (except the root node, which has no rocks). In particular, non-root node $i$ has exactly $R_i$ $(1 \\leqslant R_i \\leqslant 1000)$ rocks at the beginning of the game.\n\nTwo players alternate turns to play this game, with Ted going first. In each turn, the current player can choose a non-root node $i$ and move at most $L$ $(1 \\leqslant L \\leqslant 1000)$ rocks from this node one branch closer to the root (i.e., move these rocks to the parent node). He must move at least one rock, and, of course, he cannot exceed the current number of rocks on this node. The game ends when a player can't make a legal move (i.e., when all the rocks are on node 1); that player loses.\n\nTed needs your help. He has given you the initial configuration of the game, and he will then make $T$ $(1 \\leqslant T \\leqslant 10000)$ changes to the configuration one by one. Please help him determine, after each step, if he can win the game beginning from this configuration, assuming both he and his opponent use the best possible strategy.\n\nTed's changes are specified as two integers $A_j$ $(1 < A_j \\leqslant N)$ and $B_j$ $(1 \\leqslant B_j \\leqslant 1000)$, meaning that Ted will change the number of rocks on node $A_j$ to $B_j$ (this is a \"set\", not a \"subtract\" or \"add\"), and will then ask you whether he can win. Changes accumulate; node $A_j$'s rocks stay at $B_j$ until another change for $A_j$ appears.\n\nConsider this example with three nodes numbered as shown and the shape shown in Board 0. Initially, there are 5 rocks on node 2 and 3 rocks on node 3; see Board 1.\n\nFor the first change, Ted removes 2 rocks from node 2 (thus leaving 3); see Board 2. For the second change, Ted removes 2 rocks from node 3 (thus leaving 1). Note that node 2 still has 3 rocks; see Board 3.\n\nBoard 0 Board 1 Board 2 Board 3\n\n(No link is provided in the original statement.)\n\nYour program should determine in each case who wins.\n\nFor about 30% of the test cases, $N \\leqslant 10$, and $T \\leqslant 100$, and no tree node will have more than 5 rocks on it after any of Ted's changes.\n\nPartial feedback will be provided for your first $50$ submissions.", "inputFormat": "Line $1$: Three space-separated integers: $N$, $T$, and $L$.  \nLines $2 \\cdots N$: Line $i$ contains two space-separated integers: $P_i$ and $R_i$.  \nLines $N+1 \\cdots N+T$: Line $j+N$ describes Ted's next change using two space-separated integers: $A_j$ and $B_j$.", "outputFormat": "Lines $1 \\cdots T$: Line $i$ contains \"Yes\" if Ted can win the game after change $i$, and \"No\" otherwise.", "hint": "Testdata source: bzoj.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10HOL] Rocks and Trees G", "background": "```\nMy country's bigger than most\nAnd if asked I boast\n'Cause I'm really proud\nSo I shout it loud\nThough our numbers are few\nWe will welcome you\nAlthough we don't have history\nGold medal winning teams\nHeroes or prisoners\nWorld famous volcanoes\nStill what we've got's glorious\n'Cause we've got\nRocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd rocks and trees\nAnd trees and rocks\nAnd water\n-The Arrogant Worms, on Canada\n（本段为诗歌，具体内容与题目无关）", "description": "After moving across the 49th parallel to Canada, the land of rocks and trees, Farmer John's cows invented a game to spend their leisure time on the pasture; naturally, it involved the rocks and trees! Cowboy Ted likes this game very much, but so poor is his luck that he always loses to other cows. This time, he is going to seek your help. \n\nThe game's rules are simple. It is played with a tree that has both $N$$(2 \\leqslant N \\leqslant10000)$nodes conveniently numbered $1 \\cdots N$ and also $N-1$ branches. Node 1 is the root of this tree; except for node 1, node $i$ has parent $P_i$ $(1 \\leqslant P_i < i)$. Initially, Each node contains some rocks (except the root node, which has no rocks). In particular, non-root node $i$ has exactly $R_i (1 \\leqslant R_i \\leqslant 1000)$ rocks at the beginning of the game. \n\nTwo players alternate turns to play this game in turn, with Ted going first. In each turn, the current player can choose a non-root node $i$ and move at most $L (1 \\leqslant L \\leqslant 1000)$ rocks from this node one branch closer to the root (i.e., move these rocks to the parent node). He must move at least one rock, and, of course, he cannot exceed the current number of rocks on this node. The game ends when a player can't make a legal move (i.e., when all the rocks are on node 1); that player loses. \n\nTed needs your help. He has given you the initial configuration of the game, and he will then make $T (1 \\leqslant T \\leqslant 10000)$changes to the configuration one by one. Please help him determine, after each step, if he can win the game beginning from this configuration, assuming both he and his opponent use the best possible strategy. \n\nTed's changes are specified as two integers $A_j (1 < A_j \\leqslant N)$ and $B_j (1 \\leqslant B_j \\leqslant 1000)$, meaning that Ted will change the number of rocks on node $A_j$ to $B_j$ (this is a `set` not a `subtract` or `add`), and will then ask you whether he can win. Changes accumulate; node $A_j$'s rocks stay at $B_j$ until another change for $A_j$ appears.\n\nConsider this example with three nodes numbered as shown and the shape shown in Board 0. Initially, there are 5 rocks on node 2 and 3 rocks on node 3; see Board 1.\n\nFor the first change, Ted removes 2 rocks from node 2 (thus leaving 3); see Board 2. For the second change, Ted removes 2 rocks from node 3 (thus leaving 1). Note that node 2 still has 3 rocks; see Board 3.\n\nBoard 0 Board 1 Board 2 Board 3\n\n（原题面并未给出链接）\n\nYour program should determine in each case who wins.\n\nFor about 30% of the test cases, $N \\leqslant 10$, and $T \\leqslant 100$, and no tree node will have more than 5 rocks on it after any of Ted's changes.\n\nPartial feedback will be provided for your first $50$ submissions.", "inputFormat": "Line $1$: Three space-separated integers: $N$, $T$, and $L$.  \nLines $2 \\cdots N$: Line i contains two space-separted integers: $P_i$ and $R_i$.  \nLines $N+1 \\cdots N+T$: Line $j+N$ describes Ted's next change using two space-separated integers: $A_j$ and $B_j$.", "outputFormat": "Lines $1 \\cdots T$: Line $i$ contains `Yes` if Ted can win the game after change $i$; and `No` otherwise.", "hint": "数据来源：bzoj。", "locale": "zh-CN"}}}
{"pid": "P2973", "type": "P", "difficulty": 6, "samples": [["2 1 1 2 \n1 2 \n", "0.666666667 \n0.333333333 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO", "Special Judge", "O2优化", "高斯消元"], "title": "[USACO10HOL] Driving Out the Piggies G", "background": "", "description": "The Cows have constructed a randomized stink bomb for the purpose of driving away the Piggies. The Piggy civilization consists of N (2 <= N <= 300) Piggy cities conveniently numbered 1..N connected by M (1 <= M <= 44,850) bidirectional roads specified by their distinct endpoints A\\_j and B\\_j (1 <= A\\_j <= N; 1 <= B\\_j <= N). Piggy city 1 is always connected to at least one other city.\n\nThe stink bomb is deployed in Piggy city 1. Each hour (including the first one), it has a P/Q (1 <= P <= 1,000,000; 1 <= Q <=\n\n1,000,000; P <= Q) chance of polluting the city it occupies. If it does not go off, it chooses a random road out of the city and follows it until it reaches a new city.  All roads out of a city are equally likely to be chosen.\n\nBecause of the random nature of the stink bomb, the Cows are wondering which cities are most likely to be polluted. Given a map of the Piggy civilization and the probability that the stink bomb detonates in a given hour, compute for each city the probability that it will be polluted.\n\nFor example, suppose that the Piggie civilization consists of two cities connected together and that the stink bomb, which starts in city 1, has a probability of 1/2 of detonating each time it enters a city:\n\n1--2\nWe have the following possible paths for the stink bomb (where the last entry is the ending city):\n\n1: 1\n2: 1-2\n3: 1-2-1\n\n4: 1-2-1-2\n\n5: 1-2-1-2-1\n\netc.\nTo find the probability that the stink bomb ends at city 1, we can add up the probabilities of taking the 1st, 3rd, 5th, ... paths above (specifically, every odd-numbered path in the above list). The probability of taking path number k is exactly (1/2)^k - the bomb must not remain in its city for k - 1 turns (each time with a probability of 1 - 1/2 = 1/2) and then land in the last city\n\n(probability 1/2). \n\nSo our probability of ending in city 1 is represented by the sum 1/2 + (1/2)^3 + (1/2)^5 + ... . When we sum these terms infinitely, we will end up with exactly 2/3 as our probability, approximately 0.666666667. This means the probability of landing in city 2 is 1/3, approximately 0.333333333. \n\nPartial feedback will be provided for your first 50 submissions. ", "inputFormat": "\\* Line 1: Four space separated integers: N, M, P, and Q\n\n\\* Lines 2..M+1: Line i+1 describes a road with two space separated integers: A\\_j and B\\_j\n", "outputFormat": "\\* Lines 1..N: On line i, print the probability that city i will be destroyed as a floating point number. An answer with an absolute error of at most 10^-6 will be accepted (note that you should output at least 6 decimal places for this to take effect).\n", "hint": "感谢 @[Alpha](https://www.luogu.com.cn/user/87058) 贡献 Special Judge。", "locale": "en", "translations": {"en": {"title": "[USACO10HOL] Driving Out the Piggies G", "background": "", "description": "The Cows have constructed a randomized stink bomb for the purpose of driving away the Piggies. The Piggy civilization consists of N (2 <= N <= 300) Piggy cities conveniently numbered 1..N connected by M (1 <= M <= 44,850) bidirectional roads specified by their distinct endpoints A\\_j and B\\_j (1 <= A\\_j <= N; 1 <= B\\_j <= N). Piggy city 1 is always connected to at least one other city.\n\nThe stink bomb is deployed in Piggy city 1. Each hour (including the first one), it has a P/Q (1 <= P <= 1,000,000; 1 <= Q <=\n\n1,000,000; P <= Q) chance of polluting the city it occupies. If it does not go off, it chooses a random road out of the city and follows it until it reaches a new city.  All roads out of a city are equally likely to be chosen.\n\nBecause of the random nature of the stink bomb, the Cows are wondering which cities are most likely to be polluted. Given a map of the Piggy civilization and the probability that the stink bomb detonates in a given hour, compute for each city the probability that it will be polluted.\n\nFor example, suppose that the Piggie civilization consists of two cities connected together and that the stink bomb, which starts in city 1, has a probability of 1/2 of detonating each time it enters a city:\n\n1--2\nWe have the following possible paths for the stink bomb (where the last entry is the ending city):\n\n1: 1\n2: 1-2\n3: 1-2-1\n\n4: 1-2-1-2\n\n5: 1-2-1-2-1\n\netc.\nTo find the probability that the stink bomb ends at city 1, we can add up the probabilities of taking the 1st, 3rd, 5th, ... paths above (specifically, every odd-numbered path in the above list). The probability of taking path number k is exactly (1/2)^k - the bomb must not remain in its city for k - 1 turns (each time with a probability of 1 - 1/2 = 1/2) and then land in the last city\n\n(probability 1/2). \n\nSo our probability of ending in city 1 is represented by the sum 1/2 + (1/2)^3 + (1/2)^5 + ... . When we sum these terms infinitely, we will end up with exactly 2/3 as our probability, approximately 0.666666667. This means the probability of landing in city 2 is 1/3, approximately 0.333333333. \n\nPartial feedback will be provided for your first 50 submissions. ", "inputFormat": "\\* Line 1: Four space separated integers: N, M, P, and Q\n\n\\* Lines 2..M+1: Line i+1 describes a road with two space separated integers: A\\_j and B\\_j\n", "outputFormat": "\\* Lines 1..N: On line i, print the probability that city i will be destroyed as a floating point number. An answer with an absolute error of at most 10^-6 will be accepted (note that you should output at least 6 decimal places for this to take effect).\n", "hint": "感谢 @[Alpha](https://www.luogu.com.cn/user/87058) 贡献 Special Judge。", "locale": "en"}, "zh-CN": {"title": "[USACO10HOL] Driving Out the Piggies G", "background": null, "description": "奶牛们制造了一种随机臭弹，目的是驱赶小猪。小猪文明由 $ N (2 \\leq N \\leq 300) $ 个小猪城市组成，这些城市编号为 1 到 N，通过 $ M (1 \\leq M \\leq 44,850) $ 条双向道路连接，具体由它们的不同端点 $A_j$ 和 $B_j$ 指定 $ (1 \\leq A_j \\leq N; 1 \\leq B_j \\leq N) $。小猪城市 $1$ 总是与至少一个其他城市相连。\n\n臭弹在小猪城市 $1$ 部署。每小时（包括第一小时），它有 $P/Q (1 \\leq P \\leq 1,000,000, 1 \\leq Q \\leq 1,000,000; P \\leq Q) $ 的概率爆炸并污染它所在的城市。如果它没有爆炸，它会随机选择一条通往其他城市的道路并沿着它走，直到到达一个新城市。所有从一个城市出发的道路被选择的概率相同。\n\n由于臭弹的随机性质，奶牛们想知道哪些城市最有可能被污染。给定小猪文明的地图以及臭弹在每个小时内爆炸的概率，计算每个城市被污染的概率。\n\n例如，假设小猪文明由两个城市组成并且相连，臭弹从城市 $1$ 开始，每次进入一个城市时有 $\\frac12$ 的概率爆炸：\n\n1--2\n\n我们有以下可能的臭弹路径（最后一个城市是终点城市）：\n\n1: 1\n\n2: 1-2\n\n3: 1-2-1\n\n4: 1-2-1-2\n\n5: 1-2-1-2-1\n\n等等。\n要找到臭弹最终停留在城市 $1$ 的概率，我们可以将上述每条路径的概率相加（具体来说，就是上述列表中每一个奇数编号的路径）。选择第 $k$ 条路径的概率正好是 $(1/2)^k$ ——臭弹必须在前 $k-1$ 次不留在它的城市（每次概率为 $1-\\frac12=\\frac12$），然后在最后一个城市停留（概率为 $\\frac12$）。\n\n因此，我们在城市 $1$ 停留的概率由无穷级数 $\\displaystyle\\sum_{2\\nmid k}\\left(\\frac12\\right)^k$ 表示。当我们无限地求和这些项时，最终得到的概率恰好是 $\\frac23$，大约为 $0.666666667$。这意味着在城市 $2$ 停留的概率是 $\\frac13$，大约为 $0.333333333$。", "inputFormat": "第 $1$ 行：四个用空格分隔的整数：$N,M,P,Q$。\n\n第 $2$ 行到第 $M+1$ 行：第 $i+1$ 行描述一条道路，包含两个用空格分隔的整数：$A_j$ 和 $B_j$。", "outputFormat": "第 $1$ 行到第 $N$ 行：在第 $i$ 行，输出城市 $i$ 被摧毁的概率，格式为浮点数。绝对误差最多为 $10^{-6}$ 的答案将被接受（注意，您应该输出至少 $6$ 位小数以满足此要求）。", "hint": "感谢 @[Alpha](https://www.luogu.com.cn/user/87058) 贡献 Special Judge。", "locale": "zh-CN"}}}
{"pid": "P2974", "type": "P", "difficulty": 6, "samples": [["5 4 \nTEJTJ \n1 2 \n2 3 \n3 4 \n4 5 \n", "2 \nMOVE 3 2 \nATTACK 2 1 \nATTACK 5 4 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2010", "USACO", "Special Judge", "费用流"], "title": "[USACO10HOL] Cow War G", "background": "", "description": "Farmer John has long had a dispute with neighbor Farmer Tom over a group of V (1 <= V <= 1,000) pastures conveniently numbered 1..V. Both farmers currently graze their cows on the pastures; each pasture might be empty or might have a single cow which is owned by either Farmer John or Farmer Tom.\n\nFarmer John's patience is at an end, and he wishes to settle the dispute with Farmer Tom by tipping over Tom's cows. Of course, he wants to strike first and to tip as many of Farmer Tom's cows as possible.\n\nA total of E (1 <= E <= 5,000) bidirectional cowpaths connect pairs of pastures. No two pastures are connected by more than one cowpath; each path connects exactly two distinct pastures. Paths are described by their endpoints P1\\_i and P2\\_i (1 <= P1\\_i <= V; 1 <= P2\\_i <= V).\n\nDuring his offense, each of Farmer John's cows can traverse a single cowpath if she wishes. Whether or not she chooses to traverse a cowpath, she can then (if she wishes) launch a cow tipping attack to a pasture connected to her pasture by a single cowpath, thus tipping the enemy cow on that pasture. Note that a cow can move and then attack -- but she is not able to attack and then move.\n\nEach pasture can hold exactly one cow at a time; no cow can move to a pasture occupied by another cow, especially if it has been tipped. Of course, if a pasture is vacated, another cow can later move in to take its place. A tipped cow cannot be tipped again.\n\nFarmer John wants to know two things:\n\n\\* How many of Farmer Tom's cows he can tip in the first salvo\n\nof the war\n\n\\* How to command his cows to move and attack so as to tip\n\nthat maximal number of Farmer Tom's cows in that first salvo\n\nFind the maximum number of cows that can be tipped and construct a sequence of move and attack commands to his cows that then obey the rules and tip that number of cows. Any such sequence is acceptable, as long as it tips the maximum number of Farmer Tom's cows.\n\nConsider, for instance, a group of 5 pastures arranged in a line, with each pasture connected (via '--'; see diagram below) to its left and right neighbors (if they exist). In other words, there is a cowpath from Pasture 1 to Pasture 2, Pasture 2 to Pasture 3, etc. Farmer Tom ('T') has 2 cows, standing on pastures 1 and 4, while Farmer John ('J') has 2 cows standing on pastures 3 and 5 ('E' means empty):\n\n1    2    3    4    5\n\nT -- E -- J -- T -- J\n\nIn this case, Farmer John can tip both of Farmer Tom's cows by first moving his cow on Pasture 3 to Pasture 2, so that the pastures in order are now TJETJ. Farmer John can then have both of his cows attack to the left.  Note that although the cow in Pasture 3 could have attacked to the right without moving, the rightmost cow would then be unable to attack. The only valid solutions thus have the same move and attacks, although the order in which Farmer John commands his cows can vary slightly.\n\nIf you compute the correct maximum number but do not provide a sequence (or your sequence is wrong), you will get 50% of the points for that test case. A program will grade your output.\n\nPartial feedback will be provided for your first 50 submissions.", "inputFormat": "\\* Line 1: Two space separated integers: V and E\n\n\\* Line 2: A string of V characters (no spaces); character #i indicates whether pasture #i is empty ('E') or has a cow owned by Farmer John ('J') or Farmer Tom ('T')\n\n\\* Lines 3..E+2: Line i+2 contains two space separated integers: P1\\_i and P2\\_i\n", "outputFormat": "\\* Line 1: A single integer, the maximum number of enemy cows Farmer John can have tipped\n\n\\* Lines 2.....: One of Farmer John's instructions to his cows (to be executed in the order given):\n\nMOVE A B\n\nor\nATTACK A B\n\nwhere A is the vertex the cow occupies before taking the action and B is the vertex it is moving to or attacking, respectively. Note that when instructing a cow that has already moved to attack, the instruction specifies the location the cow is currently standing, not where it was originally.\n", "hint": "The other valid outputs are:\n\n2\nMOVE 3 2\n\nATTACK 5 4\n\nATTACK 2 1\n\nand\n2\nATTACK 5 4\n\nMOVE 3 2\n\nATTACK 2 1\n\nwhich are just reorderings of the output shown.  This might not be true on other testdata.\n", "locale": "en", "translations": {"en": {"title": "[USACO10HOL] Cow War G", "background": "", "description": "Farmer John has long had a dispute with neighbor Farmer Tom over a group of V (1 <= V <= 1,000) pastures conveniently numbered 1..V. Both farmers currently graze their cows on the pastures; each pasture might be empty or might have a single cow which is owned by either Farmer John or Farmer Tom.\n\nFarmer John's patience is at an end, and he wishes to settle the dispute with Farmer Tom by tipping over Tom's cows. Of course, he wants to strike first and to tip as many of Farmer Tom's cows as possible.\n\nA total of E (1 <= E <= 5,000) bidirectional cowpaths connect pairs of pastures. No two pastures are connected by more than one cowpath; each path connects exactly two distinct pastures. Paths are described by their endpoints P1\\_i and P2\\_i (1 <= P1\\_i <= V; 1 <= P2\\_i <= V).\n\nDuring his offense, each of Farmer John's cows can traverse a single cowpath if she wishes. Whether or not she chooses to traverse a cowpath, she can then (if she wishes) launch a cow tipping attack to a pasture connected to her pasture by a single cowpath, thus tipping the enemy cow on that pasture. Note that a cow can move and then attack -- but she is not able to attack and then move.\n\nEach pasture can hold exactly one cow at a time; no cow can move to a pasture occupied by another cow, especially if it has been tipped. Of course, if a pasture is vacated, another cow can later move in to take its place. A tipped cow cannot be tipped again.\n\nFarmer John wants to know two things:\n\n\\* How many of Farmer Tom's cows he can tip in the first salvo\n\nof the war\n\n\\* How to command his cows to move and attack so as to tip\n\nthat maximal number of Farmer Tom's cows in that first salvo\n\nFind the maximum number of cows that can be tipped and construct a sequence of move and attack commands to his cows that then obey the rules and tip that number of cows. Any such sequence is acceptable, as long as it tips the maximum number of Farmer Tom's cows.\n\nConsider, for instance, a group of 5 pastures arranged in a line, with each pasture connected (via '--'; see diagram below) to its left and right neighbors (if they exist). In other words, there is a cowpath from Pasture 1 to Pasture 2, Pasture 2 to Pasture 3, etc. Farmer Tom ('T') has 2 cows, standing on pastures 1 and 4, while Farmer John ('J') has 2 cows standing on pastures 3 and 5 ('E' means empty):\n\n1    2    3    4    5\n\nT -- E -- J -- T -- J\n\nIn this case, Farmer John can tip both of Farmer Tom's cows by first moving his cow on Pasture 3 to Pasture 2, so that the pastures in order are now TJETJ. Farmer John can then have both of his cows attack to the left.  Note that although the cow in Pasture 3 could have attacked to the right without moving, the rightmost cow would then be unable to attack. The only valid solutions thus have the same move and attacks, although the order in which Farmer John commands his cows can vary slightly.\n\nIf you compute the correct maximum number but do not provide a sequence (or your sequence is wrong), you will get 50% of the points for that test case. A program will grade your output.\n\nPartial feedback will be provided for your first 50 submissions.", "inputFormat": "\\* Line 1: Two space separated integers: V and E\n\n\\* Line 2: A string of V characters (no spaces); character #i indicates whether pasture #i is empty ('E') or has a cow owned by Farmer John ('J') or Farmer Tom ('T')\n\n\\* Lines 3..E+2: Line i+2 contains two space separated integers: P1\\_i and P2\\_i\n", "outputFormat": "\\* Line 1: A single integer, the maximum number of enemy cows Farmer John can have tipped\n\n\\* Lines 2.....: One of Farmer John's instructions to his cows (to be executed in the order given):\n\nMOVE A B\n\nor\nATTACK A B\n\nwhere A is the vertex the cow occupies before taking the action and B is the vertex it is moving to or attacking, respectively. Note that when instructing a cow that has already moved to attack, the instruction specifies the location the cow is currently standing, not where it was originally.\n", "hint": "The other valid outputs are:\n\n2\nMOVE 3 2\n\nATTACK 5 4\n\nATTACK 2 1\n\nand\n2\nATTACK 5 4\n\nMOVE 3 2\n\nATTACK 2 1\n\nwhich are just reorderings of the output shown.  This might not be true on other testdata.\n", "locale": "en"}, "zh-CN": {"title": "[USACO10HOL] Cow War G", "background": null, "description": "给定 $V$ 个点，$E$ 条边的无向图。\n一开始每个点上有 `T` 牛，`J` 牛，或者没有（`E`）。\n`J` 牛可以 `MOVE` 到一个相邻的点，也可以 `ATTACK` 相邻点上的一个 `T` 牛。不过操作有限制，只能按照 `MOVE`,`ATTACK` 或者 `MOVE` 然后 `ATTACK` 三种方式操作。\n一个 `T` 牛仅能被 `ATTACK` 一次，被 `ATTACK` 后它会留在原地。\n需要保证任意时刻，每个点上有且仅有一头牛。\n求所有 `T` 牛被 `ATTACK` 的最大次数，并给出一个可行的操作方案。", "inputFormat": "第一行两个整数 $V,E$，表示无向图的点数和边数。\n接下来一行 $V$ 个字符，第 $i$ 个字符表示第 $i$ 个点的初始状态。\n接下来 $E$ 行每行两个整数 $u,v$，表示存在一条连接 $u,v$ 的无向边。", "outputFormat": "第一行一个整数，表示所有 `T` 牛被 `ATTACK` 的最大次数。\n接下来若干行，每行以 `MOVE u v` 或 `ATTACK u v` 的形式给出，表示你的操作方案。", "hint": "对于测试点 $1\\sim5$，$1\\leq V\\leq 30,1\\leq E\\leq 50$。\n\n对于测试点 $6\\sim 10$，$1\\leq V\\leq 500,1\\leq E\\leq 2\\times 10^3$。\n\n对于测试点 $11\\sim 15$，$1\\leq V\\leq 10^3,1\\leq E\\leq 5\\times 10^3$。\n\n注意：一个操作需要描述现在的位置，例如：点 $3$ 上的牛先 `MOVE` 到点 $2$，再 `ATTACK` 点 $4$，应该写为：\n\n```\nMOVE 3 2\nATTACK 2 4\n```", "locale": "zh-CN"}}}
{"pid": "P2975", "type": "P", "difficulty": 5, "samples": [["6 \n17 \n5 \n9 \n10 \n3 \n8 \n", "27 17 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10JAN] Taking Turns G", "background": "", "description": "Farmer John has invented a new way of feeding his cows. He lays out N (1 <= N <= 700,000) hay bales conveniently numbered 1..N in a long line in the barn. Hay bale i has weight W\\_i (1 <= W\\_i <=\n\n2,000,000,000). A sequence of six weights might look something like:\n\n17 5 9 10 3 8\n\nA pair of cows named Bessie and Dessie walks down this line after examining all the haybales to learn their weights. Bessie is the first chooser. They take turns picking haybales to eat as they walk (once a haybale is skipped, they cannot return to it). For instance, if cows Bessie and Dessie go down the line, a possible scenario is:\n\n\\* Bessie picks the weight 17 haybale\n\n\\* Dessie skips the weight 5 haybale and picks the weight 9 haybale \\* Bessie picks the weight 10 haybale\n\n\\* Dessie skips the weight 3 haybale and picks the weight 8 haybale\n\nDiagrammatically:\n\nBessie   |      | \n17 5 9 10 3 8\n\nDessie       |      | \nThis scenario only shows a single skipped bale; either cow can skip as many as she pleases when it's her turn.\n\nEach cow wishes to maximize the total weight of hay she herself consumes (and each knows that the other cow has this goal).\n\nFurthermore, a cow will choose to eat the first bale of hay that maximimizes her total weight consumed.\n\nGiven a sequence of hay weights, determine the amount of hay that a pair of cows will eat as they go down the line of hay.\n\n两头奶牛 Bessi 和 Dessie 走过一条路吃草，共 $n(1\\le n \\le 7\\times 10 ^ 5)$ 个格子，第 $i$ 个格子有重量为 $W_i(1 \\le W_i \\le 2 \\times 10 ^{9})$ 的草，两牛轮流走，一旦某头牛走过了一格，那么这格的草再也不可能被任一头奶牛吃，每格的草只能被吃一次，所以两头牛只能往后走。Bessi 先走，每头牛每次都往最终自己能吃到最多草的格子走（若有多个格子则选择第一个能吃到最多草的格子），他们都知道对方也想吃到最多的草，问最后 Bessi 和 Dessie 各吃到的草的重量。\n\n输入格式：\n\n第一行一个正整数 $n(1\\leq n\\le 7\\times 10 ^ 5)$，接下来有 $n$ 行，第 $i+1$ 行为 $W_i(1 \\le W_i \\le 2 \\times 10 ^{9})$。", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: W\\_i\n", "outputFormat": "\\* Line 1: Two space-separated integers, the total weight of hay consumed by Bessie and Dessie respectively\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10JAN] Taking Turns G", "background": "", "description": "Farmer John lays out $n$ hay bales in a line, conveniently numbered $1..n$. Hay bale $i$ has weight $W_i$. The constraints are $1 \\le n \\le 7 \\times 10^5$ and $1 \\le W_i \\le 2 \\times 10^9$.\n\nA sequence of six weights might look like:\n17 5 9 10 3 8.\n\nTwo cows, Bessie and Dessie, walk down this line after examining all the hay bales and learning their weights. Bessie chooses first. They take turns picking hay bales to eat as they proceed from left to right. Either cow may skip any number of bales on her turn, but once a bale has been passed, neither cow can return to it, and each bale can be eaten at most once.\n\nFor example, as they go down the line, a possible scenario is:\n- Bessie picks the 17-weight bale.\n- Dessie skips the 5-weight bale and picks the 9-weight bale.\n- Bessie picks the 10-weight bale.\n- Dessie skips the 3-weight bale and picks the 8-weight bale.\nThis scenario shows just one skipped bale; in general, either cow may skip any number of bales on her turn.\n\nEach cow wishes to maximize the total weight of hay she herself consumes (and each knows the other has this goal). Furthermore, whenever multiple choices lead to the same maximum total for herself under optimal play, a cow will choose the first bale (the earliest position) among those optimal choices.\n\nGiven the sequence of hay weights, determine the total weight of hay eaten by Bessie and by Dessie, respectively.", "inputFormat": "- Line 1: A single integer $n$.\n- Lines $2..n+1$: Line $i+1$ contains a single integer $W_i$.", "outputFormat": "- Line 1: Two space-separated integers: the total weight consumed by Bessie and by Dessie, respectively.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10JAN] Taking Turns G", "background": "", "description": "Farmer John has invented a new way of feeding his cows. He lays out N (1 <= N <= 700,000) hay bales conveniently numbered 1..N in a long line in the barn. Hay bale i has weight W\\_i (1 <= W\\_i <=\n\n2,000,000,000). A sequence of six weights might look something like:\n\n17 5 9 10 3 8\n\nA pair of cows named Bessie and Dessie walks down this line after examining all the haybales to learn their weights. Bessie is the first chooser. They take turns picking haybales to eat as they walk (once a haybale is skipped, they cannot return to it). For instance, if cows Bessie and Dessie go down the line, a possible scenario is:\n\n\\* Bessie picks the weight 17 haybale\n\n\\* Dessie skips the weight 5 haybale and picks the weight 9 haybale \\* Bessie picks the weight 10 haybale\n\n\\* Dessie skips the weight 3 haybale and picks the weight 8 haybale\n\nDiagrammatically:\n\nBessie   |      | \n17 5 9 10 3 8\n\nDessie       |      | \nThis scenario only shows a single skipped bale; either cow can skip as many as she pleases when it's her turn.\n\nEach cow wishes to maximize the total weight of hay she herself consumes (and each knows that the other cow has this goal).\n\nFurthermore, a cow will choose to eat the first bale of hay that maximimizes her total weight consumed.\n\nGiven a sequence of hay weights, determine the amount of hay that a pair of cows will eat as they go down the line of hay.\n\n两头奶牛 Bessi 和 Dessie 走过一条路吃草，共 $n(1\\le n \\le 7\\times 10 ^ 5)$ 个格子，第 $i$ 个格子有重量为 $W_i(1 \\le W_i \\le 2 \\times 10 ^{9})$ 的草，两牛轮流走，一旦某头牛走过了一格，那么这格的草再也不可能被任一头奶牛吃，每格的草只能被吃一次，所以两头牛只能往后走。Bessi 先走，每头牛每次都往最终自己能吃到最多草的格子走（若有多个格子则选择第一个能吃到最多草的格子），他们都知道对方也想吃到最多的草，问最后 Bessi 和 Dessie 各吃到的草的重量。\n\n输入格式：\n\n第一行一个正整数 $n(1\\leq n\\le 7\\times 10 ^ 5)$，接下来有 $n$ 行，第 $i+1$ 行为 $W_i(1 \\le W_i \\le 2 \\times 10 ^{9})$。", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: W\\_i\n", "outputFormat": "\\* Line 1: Two space-separated integers, the total weight of hay consumed by Bessie and Dessie respectively\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2976", "type": "P", "difficulty": 6, "samples": [["12 19 \n................... \n................... \n.....A............. \n.....A..x.......... \n..x..A.....AAAA.... \n.....A.....A..A.... \n.....AAAAAAAA.A.... \n........A.....A.... \n.xx...AAA...x.A.... \n......A............ \n...AAAAAAAAAAAAA... \n................... \n", "62 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10JAN] Shipping Around an Island G", "background": "", "description": "Farmer John decided to start his own cruise ship line! He has but one ship, but is hoping for big growth. He recently acquired a map of the area of ocean where his cruise ship will operate. It looks something like the diagram below, with height H (3 <= H <= 1000) and width W (3 <= W <= 1000).\n\n```cpp\n................... \n................... \n.....A............. \n.....A..x.......... \n..x..A.....AAAA.... \n.....A.....A..A.... \n.....AAAAAAAA.A.... \n........A.....A.... \n.xx...AAA...x.A.... \n......A............ \n...AAAAAAAAAAAAA... \n................... \n```\nIn this map, '.' denotes water; 'A' is an element of the main island; and 'x' are other islands.\n\nFarmer John has decided his cruise ship will loop around the main island. However, due to trade restrictions, the path his ship takes is NOT allowed to go around any OTHER islands. For instance, the following path of length 50 is not allowed because it encloses the island denoted by 'x'.\n\n```cpp\n................... \n....+--+........... \n....|A.|........... \n....|A.|x.+-----+.. \n..x.|A.+--+AAAA.|.. \n....|A.....A..A.|.. \n....|AAAAAAAA.A.|.. \n....|...A.....A.|.. \n.xx.|.AAA...x.A.|..    <--- route circumnavigates 'x' -- illegal! ..+-+.A.........|.. \n..|AAAAAAAAAAAAA|.. \n..+-------------+.. \n```\nGiven a map, help Farmer John determine the shortest path his cruise ship can take to go around the main island without going around any other islands.\n\nTwo cells are considered connected if they lie vertically or\n\nhorizontally across from one another (not diagonally). It is\n\nguaranteed that the main island is connected and that a solution exists.\n\nNote that FJ's path may visit the same square more than once, for instance there are three squares that are visited more than once in FJ's optimal path (of length 62) for the example:\n\n```cpp\n................... \n....+--+........... \n....|A.|........... \n....|A.|x.+----+... \n..x.|A.+--+AAAA|... \n....|A.....A..A|... \n....|AAAAAAAA.A|... \n....|...A..+-+A|... \n.xx.|.AAA..|x|A|... \n..+-+.A....+-+-++.. \n..|AAAAAAAAAAAAA|.. \n..+-------------+.. \n```\nThe above diagram is somewhat unclear because of the path overlapping itself.  Drawn in two stages, FJ's optimal path is:\n\n```cpp\n...................            ................... \n...................            ....+--+........... \n.....A.............            ....|A.|........... \n.....A..x..........            ....|A.|x.+----+... \n..x..A.....AAAA....            ..x.|A.+--+AAAA|... \n.....A.....A..A....  and then  ....|A.....A..A|... \n.....AAAAAAAA.A....            ....|AAAAAAAA.A|... \n....V...A..+>.A....            ....V...A...>+A|... \n.xx.|.AAA..|x.A....            .xx...AAA...x|A|... \n..+-+.A....+----+..            .....A.......+-+... \n..|AAAAAAAAAAAAA|..            ...AAAAAAAAAAAAA... \n..+-------------+..            ................... \n```\n\nJohn 得到一份地图，长 $H$（$3 \\leq H\\leq 1000$）宽 $W$（$3 \\leq W\\leq 1000$），地图中 ``.`` 表示水，`A` 表示大陆，`x` 表示其他小岛。他决定驾驶他的船绕大陆一圈，但并不想环绕其他小岛。John 可以再任意有水的格子出发，求绕一周最小路径长度（一个格子可以经过任意多次）。\n\n输入格式：\n\n第一行两个空格隔开正整数 $H$ 和 $W$（$3 \\leq H,W\\leq 1000$），接下来有 $H$ 行，每行 $W$ 个字符表示地图。", "inputFormat": "\\* Line 1: Two space-separated integers: H and W\n\n\\* Lines 2..H+1: Line i+1 contains contains W characters that are the elements of map row i (all '.' or 'x' or 'A')\n", "outputFormat": "\\* Line 1: The minimum length of a path that Farmer John's cruise ship can take\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10JAN] Shipping Around an Island G", "background": "", "description": "Farmer John decided to start his own cruise ship line! He has but one ship, but is hoping for big growth. He recently acquired a map of the area of ocean where his cruise ship will operate. It looks something like the diagram below, with height $H$ ($3 \\leq H \\leq 1000$) and width $W$ ($3 \\leq W \\leq 1000$).\n\n```cpp\n................... \n................... \n.....A............. \n.....A..x.......... \n..x..A.....AAAA.... \n.....A.....A..A.... \n.....AAAAAAAA.A.... \n........A.....A.... \n.xx...AAA...x.A.... \n......A............ \n...AAAAAAAAAAAAA... \n................... \n```\n\nIn this map, '.' denotes water; 'A' is an element of the main island; and 'x' are other islands.\n\nFarmer John has decided his cruise ship will loop around the main island. However, due to trade restrictions, the path his ship takes is NOT allowed to go around any other islands. For instance, the following path of length 50 is not allowed because it encloses the island denoted by 'x'.\n\n```cpp\n................... \n....+--+........... \n....|A.|........... \n....|A.|x.+-----+.. \n..x.|A.+--+AAAA.|.. \n....|A.....A..A.|.. \n....|AAAAAAAA.A.|.. \n....|...A.....A.|.. \n.xx.|.AAA...x.A.|..    <--- route circumnavigates 'x' -- illegal! ..+-+.A.........|.. \n..|AAAAAAAAAAAAA|.. \n..+-------------+.. \n```\n\nGiven a map, help Farmer John determine the shortest path his cruise ship can take to go around the main island without going around any other islands.\n\nTwo cells are considered connected if they lie vertically or horizontally across from one another (not diagonally). It is guaranteed that the main island is connected and that a solution exists. The path may start on any water cell and may visit the same square more than once. For instance, there are three squares that are visited more than once in FJ's optimal path (of length 62) for the example:\n\n```cpp\n................... \n....+--+........... \n....|A.|........... \n....|A.|x.+----+... \n..x.|A.+--+AAAA|... \n....|A.....A..A|... \n....|AAAAAAAA.A|... \n....|...A..+-+A|... \n.xx.|.AAA..|x|A|... \n..+-+.A....+-+-++.. \n..|AAAAAAAAAAAAA|.. \n..+-------------+.. \n```\n\nThe above diagram is somewhat unclear because of the path overlapping itself. Drawn in two stages, FJ's optimal path is:\n\n```cpp\n...................            ................... \n...................            ....+--+........... \n.....A.............            ....|A.|........... \n.....A..x..........            ....|A.|x.+----+... \n..x..A.....AAAA....            ..x.|A.+--+AAAA|... \n.....A.....A..A....  and then  ....|A.....A..A|... \n.....AAAAAAAA.A....            ....|AAAAAAAA.A|... \n....V...A..+>.A....            ....V...A...>+A|... \n.xx.|.AAA..|x.A....            .xx...AAA...x|A|... \n..+-+.A....+----+..            .....A.......+-+... \n..|AAAAAAAAAAAAA|..            ...AAAAAAAAAAAAA... \n..+-------------+..            ................... \n```\n\nJohn obtained a map of size $H$ ($3 \\leq H \\leq 1000$) by $W$ ($3 \\leq W \\leq 1000$). '.' denotes water, 'A' denotes the main island, and 'x' denotes other small islands. He wants to pilot his ship once around the main island, but the route must not circumnavigate any other islands. The path may start on any water cell, and a cell may be visited any number of times. Find the minimum length of such a route.", "inputFormat": "- Line 1: Two space-separated integers $H$ and $W$ ($3 \\leq H, W \\leq 1000$).\n- Lines 2..$H+1$: Each of the next $H$ lines contains $W$ characters describing a map row, each character being '.' or 'x' or 'A'.", "outputFormat": "- Line 1: A single integer — the minimum length of a valid path that Farmer John's cruise ship can take.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10JAN] Shipping Around an Island G", "background": "", "description": "Farmer John decided to start his own cruise ship line! He has but one ship, but is hoping for big growth. He recently acquired a map of the area of ocean where his cruise ship will operate. It looks something like the diagram below, with height H (3 <= H <= 1000) and width W (3 <= W <= 1000).\n\n```cpp\n................... \n................... \n.....A............. \n.....A..x.......... \n..x..A.....AAAA.... \n.....A.....A..A.... \n.....AAAAAAAA.A.... \n........A.....A.... \n.xx...AAA...x.A.... \n......A............ \n...AAAAAAAAAAAAA... \n................... \n```\nIn this map, '.' denotes water; 'A' is an element of the main island; and 'x' are other islands.\n\nFarmer John has decided his cruise ship will loop around the main island. However, due to trade restrictions, the path his ship takes is NOT allowed to go around any OTHER islands. For instance, the following path of length 50 is not allowed because it encloses the island denoted by 'x'.\n\n```cpp\n................... \n....+--+........... \n....|A.|........... \n....|A.|x.+-----+.. \n..x.|A.+--+AAAA.|.. \n....|A.....A..A.|.. \n....|AAAAAAAA.A.|.. \n....|...A.....A.|.. \n.xx.|.AAA...x.A.|..    <--- route circumnavigates 'x' -- illegal! ..+-+.A.........|.. \n..|AAAAAAAAAAAAA|.. \n..+-------------+.. \n```\nGiven a map, help Farmer John determine the shortest path his cruise ship can take to go around the main island without going around any other islands.\n\nTwo cells are considered connected if they lie vertically or\n\nhorizontally across from one another (not diagonally). It is\n\nguaranteed that the main island is connected and that a solution exists.\n\nNote that FJ's path may visit the same square more than once, for instance there are three squares that are visited more than once in FJ's optimal path (of length 62) for the example:\n\n```cpp\n................... \n....+--+........... \n....|A.|........... \n....|A.|x.+----+... \n..x.|A.+--+AAAA|... \n....|A.....A..A|... \n....|AAAAAAAA.A|... \n....|...A..+-+A|... \n.xx.|.AAA..|x|A|... \n..+-+.A....+-+-++.. \n..|AAAAAAAAAAAAA|.. \n..+-------------+.. \n```\nThe above diagram is somewhat unclear because of the path overlapping itself.  Drawn in two stages, FJ's optimal path is:\n\n```cpp\n...................            ................... \n...................            ....+--+........... \n.....A.............            ....|A.|........... \n.....A..x..........            ....|A.|x.+----+... \n..x..A.....AAAA....            ..x.|A.+--+AAAA|... \n.....A.....A..A....  and then  ....|A.....A..A|... \n.....AAAAAAAA.A....            ....|AAAAAAAA.A|... \n....V...A..+>.A....            ....V...A...>+A|... \n.xx.|.AAA..|x.A....            .xx...AAA...x|A|... \n..+-+.A....+----+..            .....A.......+-+... \n..|AAAAAAAAAAAAA|..            ...AAAAAAAAAAAAA... \n..+-------------+..            ................... \n```\n\nJohn 得到一份地图，长 $H$（$3 \\leq H\\leq 1000$）宽 $W$（$3 \\leq W\\leq 1000$），地图中 ``.`` 表示水，`A` 表示大陆，`x` 表示其他小岛。他决定驾驶他的船绕大陆一圈，但并不想环绕其他小岛。John 可以再任意有水的格子出发，求绕一周最小路径长度（一个格子可以经过任意多次）。\n\n输入格式：\n\n第一行两个空格隔开正整数 $H$ 和 $W$（$3 \\leq H,W\\leq 1000$），接下来有 $H$ 行，每行 $W$ 个字符表示地图。", "inputFormat": "\\* Line 1: Two space-separated integers: H and W\n\n\\* Lines 2..H+1: Line i+1 contains contains W characters that are the elements of map row i (all '.' or 'x' or 'A')\n", "outputFormat": "\\* Line 1: The minimum length of a path that Farmer John's cruise ship can take\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2977", "type": "P", "difficulty": 5, "samples": [["6 1 \n1 2 \n2 3 \n2 4 \n4 5 \n4 6 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "递推", "2010", "USACO", "排序"], "title": "[USACO10JAN] Cow Telephones G", "background": null, "description": "奶牛们建立了一个电话网络，对于这个题目可以将其视为一个有 $N$（$1 \\le N \\le 100{,}000$）个结点的无根树，为了方便将其编号为 $1\\cdots N$。每个结点代表一个电话交换机，每条边代表用于连接两个交换机的电话线。第 $i$ 条边由该边连接的两个结点 $A_i$ 和 $B_i$ 表示（$1 \\le A_i \\le N, 1 \\le B_i \\le N, A_i \\ne B_i$）。\n\n有些交换机只有一条电话线连接到另一个交换机，这些是树的叶子结点，每个叶子结点都是一个位于奶牛田中的电话亭。\n\n两只奶牛交流时的对话沿着两个奶牛所在节点之间的唯一的最短路径传递。一个交换机最多可以同时处理 $K$（$1 \\le K \\le 10$）个对话，并且在任何时候每个电话线上最多只能有一个对话。\n\n假设每个叶子结点上都有一头奶牛，那么最多有多少对奶牛可以同时进行对话？当然，一头奶牛最多只能参与一个对话。", "inputFormat": "第 $1$ 行：两个由空格分隔的整数 $N$ 和 $K$。\n\n第 $2\\cdots N$ 行：第 $i + 1$ 行包含两个由空格分隔的整数 $A_i$ 和 $B_i$。", "outputFormat": "第 $1$ 行：可以同时进行对话的奶牛对数。", "hint": "```plain\n1   5          C1   C5 \n|   |          ||   || \n2---4   -->    |2---4| \n|   |          ||   || \n3   6          C3   C6\n```\n\n考虑这个有 $6$ 个结点且 $K = 1$ 的电话树：\n\n有四头分别位于节点 $1$、$3$、$5$ 和 $6$ 的奶牛。如果奶牛 $1$ 和奶牛 $3$ 交谈，奶牛 $5$ 和奶牛 $6$ 交谈，那么它们不会超过每个交换机的最大对话数，所以在这个样例中答案是 $2$（即有两对奶牛可以同时进行交谈）。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10JAN] Cow Telephones G", "background": null, "description": "The cows have set up a telephone network, which for the purposes of this problem can be considered to be an unrooted tree of unspecified degree with $N$ ($1 \\le N \\le 100{,}000$) vertices conveniently numbered $1\\dots N$. Each vertex represents a telephone switchboard, and each edge represents a telephone wire between two switchboards. Edge $i$ is specified by two integers $A_i$ and $B_i$ the are the two vertices joined by edge $i$ ($1 \\le A_i \\le N$; $1 \\le B_i \\le N$; $A_i \\ne B_i$).\n\nSome switchboards have only one telephone wire connecting them to another switchboard; these are the leaves of the tree, each of which is a telephone booth located in a cow field.\n\nFor two cows to communicate, their conversation passes along the unique shortest path between the two vertices where the cows are located. A switchboard can accomodate only up to $K$ ($1 \\le K \\le 10$) simultaneous conversations, and there can be at most one conversation going through a given wire at any one time.\n\nGiven that there is a cow at each leaf of the tree, what is the maximum number of pairs of cows that can simultaneously hold conversations? A cow can, of course, participate in at most one conversation.", "inputFormat": "\\* Line $1$: Two space separated integers: $N$ and $K$.\n\n\\* Lines $2\\dots N$: Line $i+1$ contains two space-separated integers: $A_i$ and $B_i$.", "outputFormat": "\\* Line $1$: The number of pairs of cows that can simultaneously hold conversations.", "hint": "```plain\n1   5          C1   C5 \n|   |          ||   || \n2---4   -->    |2---4| \n|   |          ||   || \n3   6          C3   C6 \n```\nConsider this six-node telephone tree with $K=1$: \n\nThere are four cows, located at vertices $1$, $3$, $5$ and $6$. If cow $1$ talks to cow $3$, and cow $5$ talks to cow $6$, then they do not exceed the maximum number of conversations per switchboard, so for this example the answer is $2$ (for two pairs of cows talking simultaneously).", "locale": "en"}, "zh-CN": {"title": "[USACO10JAN] Cow Telephones G", "background": null, "description": "奶牛们建立了一个电话网络，对于这个题目可以将其视为一个有 $N$（$1 \\le N \\le 100{,}000$）个结点的无根树，为了方便将其编号为 $1\\cdots N$。每个结点代表一个电话交换机，每条边代表用于连接两个交换机的电话线。第 $i$ 条边由该边连接的两个结点 $A_i$ 和 $B_i$ 表示（$1 \\le A_i \\le N, 1 \\le B_i \\le N, A_i \\ne B_i$）。\n\n有些交换机只有一条电话线连接到另一个交换机，这些是树的叶子结点，每个叶子结点都是一个位于奶牛田中的电话亭。\n\n两只奶牛交流时的对话沿着两个奶牛所在节点之间的唯一的最短路径传递。一个交换机最多可以同时处理 $K$（$1 \\le K \\le 10$）个对话，并且在任何时候每个电话线上最多只能有一个对话。\n\n假设每个叶子结点上都有一头奶牛，那么最多有多少对奶牛可以同时进行对话？当然，一头奶牛最多只能参与一个对话。", "inputFormat": "第 $1$ 行：两个由空格分隔的整数 $N$ 和 $K$。\n\n第 $2\\cdots N$ 行：第 $i + 1$ 行包含两个由空格分隔的整数 $A_i$ 和 $B_i$。", "outputFormat": "第 $1$ 行：可以同时进行对话的奶牛对数。", "hint": "```plain\n1   5          C1   C5 \n|   |          ||   || \n2---4   -->    |2---4| \n|   |          ||   || \n3   6          C3   C6\n```\n\n考虑这个有 $6$ 个结点且 $K = 1$ 的电话树：\n\n有四头分别位于节点 $1$、$3$、$5$ 和 $6$ 的奶牛。如果奶牛 $1$ 和奶牛 $3$ 交谈，奶牛 $5$ 和奶牛 $6$ 交谈，那么它们不会超过每个交换机的最大对话数，所以在这个样例中答案是 $2$（即有两对奶牛可以同时进行交谈）。", "locale": "zh-CN"}}}
{"pid": "P2978", "type": "P", "difficulty": 2, "samples": [["5 3 3 \n2 5 \n2 3 \n4 5 \n2 3 \n3 5 \n1 5 \n", "Y \nY \nN \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10JAN] Tea Time S", "background": null, "description": "$N (1 \\leq N \\leq 1000)$ 头奶牛，编号为 $1 \\dots N$，在参加一个喝茶时间活动。在喝茶时间活动开始之前，已经有 $M (1 \\leq M \\leq 2,000)$ 对奶牛彼此认识（是朋友）。第i对彼此认识的奶牛通过两个不相同的整数 $A_i$ 和 $B_i$ 给定（$1 \\leq A_i \\leq N, 1 \\leq B_i \\leq N$）。输入数据保证一对奶牛不会出现多次。 在喝茶时间活动中，如果奶牛 $i$ 和奶牛 $j$ 有一个相同的朋友奶牛 $k$，那么他们会在某次的喝茶活动中去认识对方（成为朋友），从而扩大他们的社交圈。请判断，在喝茶活动举办很久以后（直到没有新的奶牛彼此认识），$Q (1 \\leq Q \\leq 100)$ 对奶牛是否已经彼此认识。询问j包含一对不同的奶牛编号 $X_j$ 和 $Y_j$（$1 \\leq X_j \\leq N, 1 \\leq Y_j \\leq N$）。\n\n例如，假设共有 $5$ 头奶牛，我们知道 $2$ 号认识 $5$ 号，$2$ 号认识 $3$ 号，而且 $4$ 号认识 $5$ 号；如下图 (a)。\n\n```cpp\n   2---3           2---3            2---3\n    \\              |\\  |            |\\ /|\n1    \\     -->  1  | \\ |    -->  1  | X |\n      \\            |  \\|            |/ \\|\n   4---5           4---5            4---5\n    (a)             (b)              (c)\n```\n在第一次喝茶活动中，$2$ 号认识 $4$ 号，$3$ 号认识 $5$ 号，如上图 (b) 所示。接下来的喝茶活动中，$3$ 号认识了 $4$ 号，如上图 (c) 所示。", "inputFormat": "第 $1$ 行：三个空格隔开的整数：$N$，$M$ 和 $Q$。\n\n\n第 $2 \\dots M+1$ 行：第 $i+1$ 行包含两个空格隔开的整数 $A_i$ 和 $B_i$。\n\n第 $M+2 \\dots M+Q+1$ 行：第 $j+M+1$ 行包含两个空格隔开的整数 $X_j$ 和 $Y_j$，表示询问 $j$。", "outputFormat": "第 $1 \\dots Q$ 行：如果第 $j$ 个询问的两头奶牛认识， 第 $j$ 行输出 `Y`。如果不认识，第 $j$ 行输出 `N`。", "hint": "感谢@蒟蒻orz神犇 提供翻译。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10JAN] Tea Time S", "background": null, "description": "$N (1 \\leq N \\leq 1000)$ cows, conveniently numbered $1 \\dots N$ all attend a tea time every day. $M (1 \\leq M \\leq 2,000)$ unique pairs of those cows have already met before the first tea time. Pair $i$ of these cows who have met is specified by two differing integers $A_i$ and $B_i $ ($1 \\leq A_i \\leq N, 1 \\leq B_i \\leq N$). The input never indicates that cows have met each other more than once.\n\nAt tea time, any cow $i$ and cow $j$ who have met a mutual friend cow $k$ will meet sometime during that tea time and thus expand their circle of known cows.\n\nDetermine whether $Q (1 \\leq Q \\leq 100)$ pairs of cows have met after tea times are held for long enough that no new cow meetings are occurring. Query $j$ consists of a pair of different cows $X_j$ and $Y_j$ ($1 \\leq X_j \\leq N, 1 \\leq Y_j \\leq N$).\n\nFor example, suppose that out of cows $1$ through $5$, we know that $2$ has met $5$, $2$ has met $3$, and $4$ has met $5$; see (a) below.\n\n```\n   2---3           2---3            2---3\n    \\              |\\  |            |\\ /|\n1    \\     -->  1  | \\ |    -->  1  | X |\n      \\            |  \\|            |/ \\|\n   4---5           4---5            4---5\n    (a)             (b)              (c)\n```\n\nIn the first tea time, cow $2$ meets cow $4$, and cow $3$ meets cow $5$; see (b) above. In the second tea time, cow $3$ meets cow $4$; see (c) above.", "inputFormat": "Line $1$: Three space-separated integers: $N$, $M$, and $Q$.\n\nLines $2 \\dots M+1$: Line $i+1$ contains two space-separated integers: $A_i$ and $B_i$.\n\nLines $M+2 \\dots M+Q+1$: Line $j+M+1$ contains query $j$ as two space-separated integers: $X_j$ and $Y_j$.", "outputFormat": "Lines $1 \\dots Q$: Line $j$ should be `Y` if the cows in the $j$-th query have met and `N` if they have not met.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO10JAN] Tea Time S", "background": null, "description": "$N (1 \\leq N \\leq 1000)$ 头奶牛，编号为 $1 \\dots N$，在参加一个喝茶时间活动。在喝茶时间活动开始之前，已经有 $M (1 \\leq M \\leq 2,000)$ 对奶牛彼此认识（是朋友）。第i对彼此认识的奶牛通过两个不相同的整数 $A_i$ 和 $B_i$ 给定（$1 \\leq A_i \\leq N, 1 \\leq B_i \\leq N$）。输入数据保证一对奶牛不会出现多次。 在喝茶时间活动中，如果奶牛 $i$ 和奶牛 $j$ 有一个相同的朋友奶牛 $k$，那么他们会在某次的喝茶活动中去认识对方（成为朋友），从而扩大他们的社交圈。请判断，在喝茶活动举办很久以后（直到没有新的奶牛彼此认识），$Q (1 \\leq Q \\leq 100)$ 对奶牛是否已经彼此认识。询问j包含一对不同的奶牛编号 $X_j$ 和 $Y_j$（$1 \\leq X_j \\leq N, 1 \\leq Y_j \\leq N$）。\n\n例如，假设共有 $5$ 头奶牛，我们知道 $2$ 号认识 $5$ 号，$2$ 号认识 $3$ 号，而且 $4$ 号认识 $5$ 号；如下图 (a)。\n\n```cpp\n   2---3           2---3            2---3\n    \\              |\\  |            |\\ /|\n1    \\     -->  1  | \\ |    -->  1  | X |\n      \\            |  \\|            |/ \\|\n   4---5           4---5            4---5\n    (a)             (b)              (c)\n```\n在第一次喝茶活动中，$2$ 号认识 $4$ 号，$3$ 号认识 $5$ 号，如上图 (b) 所示。接下来的喝茶活动中，$3$ 号认识了 $4$ 号，如上图 (c) 所示。", "inputFormat": "第 $1$ 行：三个空格隔开的整数：$N$，$M$ 和 $Q$。\n\n\n第 $2 \\dots M+1$ 行：第 $i+1$ 行包含两个空格隔开的整数 $A_i$ 和 $B_i$。\n\n第 $M+2 \\dots M+Q+1$ 行：第 $j+M+1$ 行包含两个空格隔开的整数 $X_j$ 和 $Y_j$，表示询问 $j$。", "outputFormat": "第 $1 \\dots Q$ 行：如果第 $j$ 个询问的两头奶牛认识， 第 $j$ 行输出 `Y`。如果不认识，第 $j$ 行输出 `N`。", "hint": "感谢@蒟蒻orz神犇 提供翻译。", "locale": "zh-CN"}}}
{"pid": "P2979", "type": "P", "difficulty": 4, "samples": [["3 53 25 \n100 25 \n20 5 \n40 10 \n", "240 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "USACO", "枚举", "背包 DP"], "title": "[USACO10JAN] Cheese Towers S", "background": "", "description": "Farmer John wants to save some blocks of his cows' delicious Wisconsin cheese varieties in his cellar for the coming winter. He has room for one tower of cheese in his cellar, and that tower's height can be at most T (1 <= T <= 1,000). The cows have provided him with a virtually unlimited number of blocks of each kind of N (1 <= N <= 100) different types of cheese (conveniently numbered 1..N). He'd like to store (subject to the constraints of height) the most\n\nvaluable set of blocks he possibly can. The cows will sell the rest to support the orphan calves association.\n\nEach block of the i-th type of cheese has some value V\\_i (1 <= V\\_i <= 1,000,000) and some height H\\_i (5 <= H\\_i <= T), which is always a multiple of 5.\n\nCheese compresses. A block of cheese that has height greater than or equal to K (1 <= K <= T) is considered 'large' and will crush any and all of the cheese blocks (even other large ones) located below it in the tower. A crushed block of cheese doesn't lose any value, but its height reduces to just 4/5 of its old height. Because the height of a block of cheese is always a multiple of 5, the height of a crushed block of cheese will always be an integer. A block of cheese is either crushed or not crushed; having multiple large blocks above it does not crush it more. Only tall blocks of cheese crush other blocks; aggregate height of a tower does not affect whether a block is crushed or not.\n\nWhat is the total value of the best cheese tower FJ can construct?\n\nConsider, for example, a cheese tower whose maximum height can be 53 to be build from three types of cheese blocks. Large blocks are those that are greater than or equal to 25. Below is a chart of the values and heights of the various cheese blocks he stacks:\n\nType    Value      Height \n\n1      100         25\n\n2       20          5\n\n3       40         10\n\nFJ constructs the following tower: \n\nType Height Value \n\ntop -> [1]   25    100\n\n```cpp\n[2]    4     20   <- crushed by [1] above \n[3]    8     40   <- crushed by [1] above \n[3]    8     40   <- crushed by [1] above \nbottom -> [3]    8     40   <- crushed by [1] above \n```\nThe topmost cheese block is so large that the blocks below it are crushed. The total height is:\n```cpp\n25 + 4 + 8 + 8 + 8 = 53 \nThe total height does not exceed 53 and thus is 'legal'. The total value is: \n100 + 20 + 40 + 40 + 40 = 240. \nThis is the best tower for this particular set of cheese blocks. \n要建一个奶酪塔，高度最大为T。他有N块奶酪。第i块高度为Hi（一定是5的倍数），价值为Vi。一块高度>=K的奶酪被称为大奶酪，一个奶酪如果在它上方有大奶酪（多块只算一次），它的高度就会变成原来的4/5.。 很显然John想让他的奶酪他价值和最大。求这个最大值。\n```", "inputFormat": "\\* Line 1: Three space-separated integers: N, T, and K\n\n\\* Lines 2..N+1: Line i+1 contains two space separated integers: V\\_i and H\\_i\n", "outputFormat": "\\* Line 1: The value of the best tower FJ can build\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10JAN] Cheese Towers S", "background": "", "description": "Farmer John wants to save some blocks of his cows' delicious Wisconsin cheese varieties in his cellar for the coming winter. He has room for one tower of cheese in his cellar, and that tower's height can be at most T (1 <= T <= 1,000). The cows have provided him with a virtually unlimited number of blocks of each kind of N (1 <= N <= 100) different types of cheese (conveniently numbered 1..N). He'd like to store (subject to the constraints of height) the most\n\nvaluable set of blocks he possibly can. The cows will sell the rest to support the orphan calves association.\n\nEach block of the i-th type of cheese has some value V\\_i (1 <= V\\_i <= 1,000,000) and some height H\\_i (5 <= H\\_i <= T), which is always a multiple of 5.\n\nCheese compresses. A block of cheese that has height greater than or equal to K (1 <= K <= T) is considered 'large' and will crush any and all of the cheese blocks (even other large ones) located below it in the tower. A crushed block of cheese doesn't lose any value, but its height reduces to just 4/5 of its old height. Because the height of a block of cheese is always a multiple of 5, the height of a crushed block of cheese will always be an integer. A block of cheese is either crushed or not crushed; having multiple large blocks above it does not crush it more. Only tall blocks of cheese crush other blocks; aggregate height of a tower does not affect whether a block is crushed or not.\n\nWhat is the total value of the best cheese tower FJ can construct?\n\nConsider, for example, a cheese tower whose maximum height can be 53 to be build from three types of cheese blocks. Large blocks are those that are greater than or equal to 25. Below is a chart of the values and heights of the various cheese blocks he stacks:\n\nType    Value      Height \n\n1      100         25\n\n2       20          5\n\n3       40         10\n\nFJ constructs the following tower: \n\nType Height Value \n\ntop -> [1]   25    100\n\n```cpp\n[2]    4     20   <- crushed by [1] above \n[3]    8     40   <- crushed by [1] above \n[3]    8     40   <- crushed by [1] above \nbottom -> [3]    8     40   <- crushed by [1] above \n```\nThe topmost cheese block is so large that the blocks below it are crushed. The total height is:\n```cpp\n25 + 4 + 8 + 8 + 8 = 53 \nThe total height does not exceed 53 and thus is 'legal'. The total value is: \n100 + 20 + 40 + 40 + 40 = 240. \nThis is the best tower for this particular set of cheese blocks. \n要建一个奶酪塔，高度最大为T。他有N块奶酪。第i块高度为Hi（一定是5的倍数），价值为Vi。一块高度>=K的奶酪被称为大奶酪，一个奶酪如果在它上方有大奶酪（多块只算一次），它的高度就会变成原来的4/5.。 很显然John想让他的奶酪他价值和最大。求这个最大值。\n```", "inputFormat": "\\* Line 1: Three space-separated integers: N, T, and K\n\n\\* Lines 2..N+1: Line i+1 contains two space separated integers: V\\_i and H\\_i\n", "outputFormat": "\\* Line 1: The value of the best tower FJ can build\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10JAN] Cheese Towers S", "background": "", "description": "FJ 要建一个奶酪塔，高度最大为 $T\\ (1 \\le T \\le 10^3)$ 。他有 $N\\ (1 \\le N \\le 10^2)$ 种奶酪。第 $i$ 种奶酪的高度为 $H_i\\ (5\\le H_i \\le T\\text{ 且 }5 \\mid H_i)$ ，价值为 $V_i\\ (1 \\le V_i \\le 10^6)$ 。一块高度 $H_i\\ge K\\ (1 \\le K \\le T)$ 的奶酪被称为大奶酪，如果一个奶酪上方有大奶酪（如果有多块就只算一次），这个奶酪的高度 $H_i$ 就会变成原来的 $\\frac{4}{5}$。FJ 想让他的奶酪塔价值和最大。请你求出这个最大值。\n\n例如，考虑一种奶酪塔，其最大高度可以是 $53$，可以用三种类型的奶酪块建造。大块是大于或等于 $25$ 的块。下面是他堆叠的各种奶酪块的值和高度的图表：\n\n|类型|价值|高度|\n| :----------: | :----------: | :----------: |\n|1|100|25|\n|2|20|5|\n|3|40|10|\n\nFJ建造了以下奶酪塔：\n\n|类型|价值|高度|\n| :----------: | :----------: | :----------: |\n|1|100|25|\n|2|20|4|\n|3|40|8|\n|3|40|8|\n|3|40|8|\n\n总高度是 $25 + 4 + 8 + 8 + 8 = 53$，除塔顶奶酪外，其余高度均被压低。总价值是 $100 + 20 + 40 + 40 + 40 = 240$。", "inputFormat": "第1行为三个用空格隔开的整数 $N,T,K$。\n\n第2至 $N+1$ 行中第 $i+1$ 行包含两个用空格隔开的整数 $V_i,H_i$。", "outputFormat": "一行一个整数为奶酪塔的最大价值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2980", "type": "P", "difficulty": 5, "samples": [["5 3 \n0 1 \n1 2 \n3 3 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10FEB] Covering the Corral G", "background": "", "description": "The cows are so modest that they want Farmer John to install covers around the circular corral where they occasionally gather. The corral has circumference $C$ with $1 \\le C \\le 1{,}000{,}000{,}000$, and FJ can choose from a set of $M$ covers with $1 \\le M \\le 100{,}000$, each with a fixed starting point and size. It is guaranteed that at least one set of covers can surround the entire corral.\n\nCover $i$ can be installed at integer location $x_i$ (the distance from the starting point around the corral) with $0 \\le x_i < C$, and has integer length $l_i$ with $1 \\le l_i \\le C$.\n\nFJ wants to minimize the number of segments he must install. What is the minimum number of segments required to cover the entire circumference of the corral?\n\nConsider a corral of circumference $5$, shown below as a pair of connected line segments where both '0's are the same point on the corral (as are both 1's, 2's, and 3's).\n\nThree potential covering segments are available for installation:\n```\nStart   Length\ni      x_i     l_i\n1       0       1\n2       1       2\n3       3       3\n```\n```\n0   1   2   3   4   0   1   2   3  ...\ncorral: +---+---+---+---+--:+---+---+---+- ...\n11111               1111\n22222222            22222222\n333333333333\n|..................|\n```\nAs shown, installing segments 2 and 3 covers an extent of (at least) five units around the circumference. FJ has no trouble with overlap, so do not worry about that.", "inputFormat": "- Line 1: Two space-separated integers $C$ and $M$.\n- Lines $2..M+1$: Line $i+1$ contains two space-separated integers $x_i$ and $l_i$.", "outputFormat": "- Line 1: A single integer, the minimum number of segments required to cover the entire circumference of the corral.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en", "translations": {"en": {"title": "[USACO10FEB] Covering the Corral G", "background": "", "description": "The cows are so modest that they want Farmer John to install covers around the circular corral where they occasionally gather. The corral has circumference $C$ with $1 \\le C \\le 1{,}000{,}000{,}000$, and FJ can choose from a set of $M$ covers with $1 \\le M \\le 100{,}000$, each with a fixed starting point and size. It is guaranteed that at least one set of covers can surround the entire corral.\n\nCover $i$ can be installed at integer location $x_i$ (the distance from the starting point around the corral) with $0 \\le x_i < C$, and has integer length $l_i$ with $1 \\le l_i \\le C$.\n\nFJ wants to minimize the number of segments he must install. What is the minimum number of segments required to cover the entire circumference of the corral?\n\nConsider a corral of circumference $5$, shown below as a pair of connected line segments where both '0's are the same point on the corral (as are both 1's, 2's, and 3's).\n\nThree potential covering segments are available for installation:\n```\nStart   Length\ni      x_i     l_i\n1       0       1\n2       1       2\n3       3       3\n```\n```\n0   1   2   3   4   0   1   2   3  ...\ncorral: +---+---+---+---+--:+---+---+---+- ...\n11111               1111\n22222222            22222222\n333333333333\n|..................|\n```\nAs shown, installing segments 2 and 3 covers an extent of (at least) five units around the circumference. FJ has no trouble with overlap, so do not worry about that.", "inputFormat": "- Line 1: Two space-separated integers $C$ and $M$.\n- Lines $2..M+1$: Line $i+1$ contains two space-separated integers $x_i$ and $l_i$.", "outputFormat": "- Line 1: A single integer, the minimum number of segments required to cover the entire circumference of the corral.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10FEB] Covering the Corral G", "background": "", "description": "The cows are so modest they want Farmer John to install covers around the circular corral where they occasionally gather. The corral has circumference C (1 <= C <= 1,000,000,000), and FJ can choose from a set of M (1 <= M <= 100,000) covers that have fixed starting points and sizes. At least one set of covers can surround the entire corral.\n\nCover i can be installed at integer location x\\_i (distance from starting point around corral) (0 <= x\\_i < C) and has integer length l\\_i (1 <= l\\_i <= C).\n\nFJ wants to minimize the number of segments he must install. What is the minimum number of segments required to cover the entire circumference of the corral?\n\nConsider a corral of circumference 5, shown below as a pair of connected line segments where both '0's are the same point on the corral (as are both 1's, 2's, and 3's).\n\nThree potential covering segments are available for installation:\n\nStart   Length\n\ni     x\\_i     l\\_i\n\n1      0       1\n\n2      1       2\n\n3      3       3\n\n0   1   2   3   4   0   1   2   3  ...\n\ncorral: +---+---+---+---+--:+---+---+---+- ...\n\n11111               1111\n\n22222222            22222222\n\n333333333333\n\n|..................| \nAs shown, installing segments 2 and 3 cover an extent of (at least) five units around the circumference. FJ has no trouble with the overlap, so don't worry about that.\n\n奶牛们非常羞涩，他们要求Farmer John在他们的圆形牛棚周围建造围栏。牛棚的周长为c(1 <= C <= 1,000,000,000)，现在，FJ希望从一些有固定起点和终点的栏杆的集合里选出一些栏杆。 栏杆i 的起点可以被建造在一个整数位置 x\\_i(相距围栏起点i个长度) (0 <= x\\_i < C),并且，这个栏杆有一个整数长度l\\_i(1 <= l\\_i <= C)。 FJ 希望最小化栏杆的数量，从而达到覆盖整个牛棚的外圈。\n", "inputFormat": "\\* Line 1: Two space-separated integers: C and M\n\n\\* Lines 2..M+1: Line i+1 contains two space-separated integers: x\\_i and l\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the minimum number of segments required to cover all segments of the circumference of the corral\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2981", "type": "P", "difficulty": 5, "samples": [["6 2 1 5 1 \n5 4 \n2 3 \n1 1 \n6 2 \n5 0 \n0 0 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10FEB] Cows on Ice G", "background": null, "description": "Bessie 在一个冰封的湖面上溜冰，湖面可以表示为二维的平面，坐标范围是 $-10^9 \\cdots10^9$。湖面上的 $N(1 \\le N \\le 20000)$ 个位置有石块(编号分别为 $1$ 到 $N$)，第 $i$ 个石块在 $(X_i, Y_i)$，其它位置是滑溜溜的冰面。\n\n由于 Bessie 滑冰技术不够好，她通过推动自己旁边的石块，依靠反作用力向某一个方向前进，在碰到一个新的石块之前，Bessie 是不会停下来的。(当然，最后会停留在某块石块的前一个格子里)由于 Bessie 无法计算复杂的角度，她只能够向东南西北四个方向前进。很显然，Bessie 不能够穿越石块，因此，Bessie 仅仅可以向三个方向滑。 \n\n滑冰不是没有风险，Bessie滑向某个方向后必须能碰到某个石块，因此她必须很小心。\n\n考虑下面的状况：Bessie 想要到达在她东边的 $(5, 1)$（`.` 表示冰，`*` 表示石头，`B` 表示 Bessie，`G` 表示终点）。如果她直接向东滑，她会滑过头，因为她只能在撞击一块石头时停下。可以用下面的方式到达 $(5, 1)$\n\n```cpp\n    (a)             (b)             (c)             (d)\n4 .....*.         .....*.         .....*.         .....*.\n3 ..*....    ^    ..*....    >    ..*....    v    ..*....\n2 ......*    ^    ..B...*    >    .....B*    v    ......*\n1 .*B..G. ------> .*...G. ------> .*...G. ------> .*...B.\n0 *....*.         *....*.         *....*.         *....*.\n  0123456\n```\n\n在情况（a）中 Bessie 可以向北、东和南滑动，但是只有向北滑能够撞击石头。在情况（b）中 Bessie 同理只能向东滑。\n\nBessie 一开始在 $(B_x, B_y)$，她需要到达 $(G_x, G_y)$。\n\nBessie 不太介意滑冰。但是，由于她的体重问题（毕竟她是一只牛），她需要很大的力气才能够把自己推动并向某一个方向滑去。所以，Farmer John 想要知道她至少需要几次才能够到达目的地。", "inputFormat": "第一行五个整数 $N$，$B_x$，$B_y$，$G_x$ 与 $G_y$。\n\n接下来 $N$ 行，第 $i$ 行两个整数 $X_i$ 和 $Y_i$。", "outputFormat": "一行一个整数，表示 Bessie 最少需要推动自己几次。", "hint": "保证没有两个石块在同一个位置上。\n\n保证有解。\n\n\n$1 \\le N \\le 20000$,$-10^9 \\le X_i, Y_i, B_x, B_y, G_x, G_y \\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10FEB] Cows on Ice G", "background": "", "description": "Bessie is ice skating on a large frozen lake modelled as a 2-dimensional grid with coordinates in the range $-10^9 \\cdots 10^9$. $N(1 \\le N \\le 20,000)$ of the lake's grid cells contain rocks(conveniently numbered $1 \\cdots N$). The other cells contain slippery ice.\n\nSince Bessie is not a very good skater, she traverses the lake's cells by pushing herself away from her current position near a rock and sliding continuously in the same direction until she hits another rock (stopping in the square before she hits the rock, of course). Never good with complicated angles, Bessie can push herself only straight north, east, south, or west. She can't push herself through the rock, of course, and thus generally has only three possible directions to move.\n\nSliding is not without risks. Bessie must hit a rock or might end up sliding for a very long time. She must aim her pushes carefully.\n\nConsider the situation depicted below; Bessie wants to get to location $(5, 1)$, which is east of her current location (`.` = ice, `*` = rock, `B` = Bessie, `G` = goal). If she slides directly to the east, she will slide past the location since she can stop only by encountering a rock head on. One way to get to $(5, 1)$ is the following:\n\n```cpp\n    (a)             (b)             (c)             (d)\n4 .....*.         .....*.         .....*.         .....*.\n3 ..*....  slide  ..*....  slide  ..*....  slide  ..*....\n2 ......*  north  ..B...*  east   .....B*  south  ......*\n1 .*B..G. ------> .*...G. ------> .*...G. ------> .*...B.\n0 *....*.         *....*.         *....*.         *....*.\n  0123456\n```\n\nBessie could slide north, east, or south in situation (a), but only north has a rock for stopping. For situation (b), she can slide only east for the same reason.\n\nFor the input, rock i is located at cell $(X_i,Y_i)(-10^9 \\le X_i \\le 10^9,-10^9 \\le Y_i \\le 10^9)$, and no two rocks occupy the same position. Bessie starts at $B_x$,$B_y$ (which is next to a rock) $(-10^9 \\le Bx \\le 10^9,-10^9 \\le By \\le 10^9)$. Bessie's goal is $G_x$,$G_y$ $(-10 \\le Gx \\le 10^9,-10^9 \\le Gy \\le 10^9)$. Bessie can always reach the goal one way or another.\n\nBessie doesn't mind sliding. However, pushing herself away from a rock is very tiring. To prepare her, FJ would like to know the minimum number of pushes Bessie needs to do.", "inputFormat": "* Line 1: Five space separated integers: $N$, $B_x$, $B_y$, $G_x$, and $G_y$.\n\n* Lines $2 \\cdots N+1$: Line $i+1$ describes a rock location with space separated integers: $X_i$ and $Y_i$.", "outputFormat": "Line 1: A single integer that is the minimum number of pushes for Bessie to get to her goal.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10FEB] Cows on Ice G", "background": null, "description": "Bessie 在一个冰封的湖面上溜冰，湖面可以表示为二维的平面，坐标范围是 $-10^9 \\cdots10^9$。湖面上的 $N(1 \\le N \\le 20000)$ 个位置有石块(编号分别为 $1$ 到 $N$)，第 $i$ 个石块在 $(X_i, Y_i)$，其它位置是滑溜溜的冰面。\n\n由于 Bessie 滑冰技术不够好，她通过推动自己旁边的石块，依靠反作用力向某一个方向前进，在碰到一个新的石块之前，Bessie 是不会停下来的。(当然，最后会停留在某块石块的前一个格子里)由于 Bessie 无法计算复杂的角度，她只能够向东南西北四个方向前进。很显然，Bessie 不能够穿越石块，因此，Bessie 仅仅可以向三个方向滑。 \n\n滑冰不是没有风险，Bessie滑向某个方向后必须能碰到某个石块，因此她必须很小心。\n\n考虑下面的状况：Bessie 想要到达在她东边的 $(5, 1)$（`.` 表示冰，`*` 表示石头，`B` 表示 Bessie，`G` 表示终点）。如果她直接向东滑，她会滑过头，因为她只能在撞击一块石头时停下。可以用下面的方式到达 $(5, 1)$\n\n```cpp\n    (a)             (b)             (c)             (d)\n4 .....*.         .....*.         .....*.         .....*.\n3 ..*....    ^    ..*....    >    ..*....    v    ..*....\n2 ......*    ^    ..B...*    >    .....B*    v    ......*\n1 .*B..G. ------> .*...G. ------> .*...G. ------> .*...B.\n0 *....*.         *....*.         *....*.         *....*.\n  0123456\n```\n\n在情况（a）中 Bessie 可以向北、东和南滑动，但是只有向北滑能够撞击石头。在情况（b）中 Bessie 同理只能向东滑。\n\nBessie 一开始在 $(B_x, B_y)$，她需要到达 $(G_x, G_y)$。\n\nBessie 不太介意滑冰。但是，由于她的体重问题（毕竟她是一只牛），她需要很大的力气才能够把自己推动并向某一个方向滑去。所以，Farmer John 想要知道她至少需要几次才能够到达目的地。", "inputFormat": "第一行五个整数 $N$，$B_x$，$B_y$，$G_x$ 与 $G_y$。\n\n接下来 $N$ 行，第 $i$ 行两个整数 $X_i$ 和 $Y_i$。", "outputFormat": "一行一个整数，表示 Bessie 最少需要推动自己几次。", "hint": "保证没有两个石块在同一个位置上。\n\n保证有解。\n\n\n$1 \\le N \\le 20000$,$-10^9 \\le X_i, Y_i, B_x, B_y, G_x, G_y \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P2982", "type": "P", "difficulty": 5, "samples": [["5 \n1 4 \n5 4 \n1 3 \n2 4 \n4 \n2 \n1 \n5 \n3 \n", "0 \n1 \n0 \n2 \n1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "线段树", "USACO", "树状数组", "深度优先搜索 DFS"], "title": "[USACO10FEB] Slowing down G", "background": "", "description": "Every day each of Farmer John's N $(1 \\le N \\le 100,000)$ cows conveniently numbered $1..N$ move from the barn to her private pasture. The pastures are organized as a tree, with the barn being on pasture $1$. Exactly $N-1$ cow unidirectional paths connect the pastures; directly connected pastures have exactly one path. Path $i$ connects pastures $A_i$ and $B_i$ $(1 \\le A_i \\le N,1 \\le B_i \\le N)$.\n\nCow $i$ has a private pasture $P_i(1 \\le P_i \\le N)$. The barn's small door lets only one cow exit at a time; and the patient cows wait until their predecessor arrives at her private pasture. First cow $1$ exits and moves to pasture $P_1$. Then cow $2$ exits and goes to pasture $P_2$, and so on.\n\nWhile cow $i$ walks to $P_i$ she might or might not pass through a pasture that already contains an eating cow. When a cow is present in a pasture, cow $i$ walks slower than usual to prevent annoying her friend.\n\n```cpp\nConsider the following pasture network, where the number between\nparentheses indicates the pastures' owner.\n\n        1 (3)        \n       / \\\n  (1) 4   3 (5)\n     / \\   \n(2) 2   5 (4)\n\nFirst, cow 1 walks to her pasture:\n\n        1 (3)        \n       / \\\n  [1] 4*  3 (5)\n     / \\   \n(2) 2   5 (4)\n\nWhen cow 2 moves to her pasture, she first passes into the barn's\npasture, pasture 1. Then she sneaks around cow 1 in pasture 4 before\narriving at her own pasture.\n\n        1 (3)\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5 (4)\n\nCow 3 doesn't get far at all -- she lounges in the barn's pasture, #1.\n\n        1* [3]\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5 (4)\n\nCow 4 must slow for pasture 1 and 4 on her way to pasture 5:\n\n        1* [3]\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5* [4]\n\nCow 5 slows for cow 3 in pasture 1 and then enters her own private pasture:\n\n        1* [3]\n       / \\\n  [1] 4*  3*[5]\n     / \\   \n[2] 2*  5* [4]\n```\n\nFJ would like to know how many times each cow has to slow down.\n\n每天 Farmer John 的 $N$ 头奶牛，编号 $1 \\ldots N$，从粮仓走向他的自己的牧场。牧场构成了一棵树，粮仓在 $1$ 号牧场。恰好有 $N-1$ 条道路直接连接着牧场，使得牧场之间都恰好有一条路径相连。第 $i$ 条路连接着 $A_i$ 和 $B_i$。奶牛们每人有一个私人牧场 $P_i$。粮仓的门每次只能让一只奶牛离开。耐心的奶牛们会等到他们的前面的朋友们到达了自己的私人牧场后才离开。首先奶牛 $1$ 离开，前往 $P_1$；然后是奶牛 $2$，以此类推。\n\n当奶牛 $i$ 走向牧场 $P_i$ 的时候，他可能会经过正在吃草的同伴旁。当路过已经有奶牛的牧场时，奶牛 $i$ 会放慢自己的速度，防止打扰他的朋友。\n\nFJ 想要知道奶牛们总共要放慢多少次速度。", "inputFormat": "\n\\* Line $1$: Line $1$ contains a single integer: $N$\n\n\\* Lines $2..N$: Line $i+1$ contains two space-separated integers: $A_i$ and $B_i$\n\n\\* Lines $N+1..N+N$: line $N+i$ contains a single integer: $P_i$\n\n第一行：有一个整数 $N$。\n\n第 $2 \\sim N$ 行：第 $i+1$ 行有两个以空格隔开的整数 $A_i$ 和 $B_i$。\n\n第 $N+1 \\sim N+N$ 行：第 $N+i$ 行有一个整数 $P_i$。", "outputFormat": "\\* Lines $1 \\sim N$：Line $i$ contains the number of times cow $i$ has to slow down.\n\n第 $1 \\sim N$ 行：第 $i$ 行包括奶牛 $i$ 需要放慢速度的次数。", "hint": "数据范围：$1 \\leq A_i,B_i,P_i\\leq N \\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10FEB] Slowing down G", "background": "", "description": "Every day, each of Farmer John's $N$ $(1 \\le N \\le 100{,}000)$ cows, conveniently numbered $1..N$, moves from the barn to her private pasture. The pastures form a tree, with the barn at pasture $1$. Exactly $N-1$ undirected paths connect the pastures; directly connected pastures have exactly one path. Path $i$ connects pastures $A_i$ and $B_i$ $(1 \\le A_i \\le N, 1 \\le B_i \\le N)$.\n\nCow $i$ has a private pasture $P_i$ $(1 \\le P_i \\le N)$. The barn's small door lets only one cow exit at a time, and the patient cows wait until their predecessor arrives at her private pasture. First, cow $1$ exits and moves to pasture $P_1$. Then cow $2$ exits and goes to pasture $P_2$, and so on.\n\nWhile cow $i$ walks to $P_i$, she might or might not pass through a pasture that already contains an eating cow. When a cow is present in a pasture, cow $i$ walks slower than usual while passing through that pasture to avoid annoying her friend.\n\n```cpp\nConsider the following pasture network, where the number between\nparentheses indicates the pastures' owner.\n\n        1 (3)        \n       / \\\n  (1) 4   3 (5)\n     / \\   \n(2) 2   5 (4)\n\nFirst, cow 1 walks to her pasture:\n\n        1 (3)        \n       / \\\n  [1] 4*  3 (5)\n     / \\   \n(2) 2   5 (4)\n\nWhen cow 2 moves to her pasture, she first passes into the barn's\npasture, pasture 1. Then she sneaks around cow 1 in pasture 4 before\narriving at her own pasture.\n\n        1 (3)\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5 (4)\n\nCow 3 doesn't get far at all -- she lounges in the barn's pasture, #1.\n\n        1* [3]\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5 (4)\n\nCow 4 must slow for pasture 1 and 4 on her way to pasture 5:\n\n        1* [3]\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5* [4]\n\nCow 5 slows for cow 3 in pasture 1 and then enters her own private pasture:\n\n        1* [3]\n       / \\\n  [1] 4*  3*[5]\n     / \\   \n[2] 2*  5* [4]\n```\n\nFJ would like to know how many times each cow has to slow down.", "inputFormat": "- Line 1: An integer $N$.\n- Lines $2..N$: Line $i+1$ contains two space-separated integers $A_i$ and $B_i$.\n- Lines $N+1..N+N$: Line $N+i$ contains a single integer $P_i$.", "outputFormat": "- Lines $1..N$: Line $i$ contains the number of times cow $i$ has to slow down.", "hint": "Constraints: $1 \\leq A_i, B_i, P_i \\leq N \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10FEB] Slowing down G", "background": "", "description": "Every day each of Farmer John's N $(1 \\le N \\le 100,000)$ cows conveniently numbered $1..N$ move from the barn to her private pasture. The pastures are organized as a tree, with the barn being on pasture $1$. Exactly $N-1$ cow unidirectional paths connect the pastures; directly connected pastures have exactly one path. Path $i$ connects pastures $A_i$ and $B_i$ $(1 \\le A_i \\le N,1 \\le B_i \\le N)$.\n\nCow $i$ has a private pasture $P_i(1 \\le P_i \\le N)$. The barn's small door lets only one cow exit at a time; and the patient cows wait until their predecessor arrives at her private pasture. First cow $1$ exits and moves to pasture $P_1$. Then cow $2$ exits and goes to pasture $P_2$, and so on.\n\nWhile cow $i$ walks to $P_i$ she might or might not pass through a pasture that already contains an eating cow. When a cow is present in a pasture, cow $i$ walks slower than usual to prevent annoying her friend.\n\n```cpp\nConsider the following pasture network, where the number between\nparentheses indicates the pastures' owner.\n\n        1 (3)        \n       / \\\n  (1) 4   3 (5)\n     / \\   \n(2) 2   5 (4)\n\nFirst, cow 1 walks to her pasture:\n\n        1 (3)        \n       / \\\n  [1] 4*  3 (5)\n     / \\   \n(2) 2   5 (4)\n\nWhen cow 2 moves to her pasture, she first passes into the barn's\npasture, pasture 1. Then she sneaks around cow 1 in pasture 4 before\narriving at her own pasture.\n\n        1 (3)\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5 (4)\n\nCow 3 doesn't get far at all -- she lounges in the barn's pasture, #1.\n\n        1* [3]\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5 (4)\n\nCow 4 must slow for pasture 1 and 4 on her way to pasture 5:\n\n        1* [3]\n       / \\\n  [1] 4*  3 (5)\n     / \\   \n[2] 2*  5* [4]\n\nCow 5 slows for cow 3 in pasture 1 and then enters her own private pasture:\n\n        1* [3]\n       / \\\n  [1] 4*  3*[5]\n     / \\   \n[2] 2*  5* [4]\n```\n\nFJ would like to know how many times each cow has to slow down.\n\n每天 Farmer John 的 $N$ 头奶牛，编号 $1 \\ldots N$，从粮仓走向他的自己的牧场。牧场构成了一棵树，粮仓在 $1$ 号牧场。恰好有 $N-1$ 条道路直接连接着牧场，使得牧场之间都恰好有一条路径相连。第 $i$ 条路连接着 $A_i$ 和 $B_i$。奶牛们每人有一个私人牧场 $P_i$。粮仓的门每次只能让一只奶牛离开。耐心的奶牛们会等到他们的前面的朋友们到达了自己的私人牧场后才离开。首先奶牛 $1$ 离开，前往 $P_1$；然后是奶牛 $2$，以此类推。\n\n当奶牛 $i$ 走向牧场 $P_i$ 的时候，他可能会经过正在吃草的同伴旁。当路过已经有奶牛的牧场时，奶牛 $i$ 会放慢自己的速度，防止打扰他的朋友。\n\nFJ 想要知道奶牛们总共要放慢多少次速度。", "inputFormat": "\n\\* Line $1$: Line $1$ contains a single integer: $N$\n\n\\* Lines $2..N$: Line $i+1$ contains two space-separated integers: $A_i$ and $B_i$\n\n\\* Lines $N+1..N+N$: line $N+i$ contains a single integer: $P_i$\n\n第一行：有一个整数 $N$。\n\n第 $2 \\sim N$ 行：第 $i+1$ 行有两个以空格隔开的整数 $A_i$ 和 $B_i$。\n\n第 $N+1 \\sim N+N$ 行：第 $N+i$ 行有一个整数 $P_i$。", "outputFormat": "\\* Lines $1 \\sim N$：Line $i$ contains the number of times cow $i$ has to slow down.\n\n第 $1 \\sim N$ 行：第 $i$ 行包括奶牛 $i$ 需要放慢速度的次数。", "hint": "数据范围：$1 \\leq A_i,B_i,P_i\\leq N \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P2983", "type": "P", "difficulty": 3, "samples": [["5 50 \n5 3 \n1 1 \n10 4 \n7 2 \n60 1 \n", "8 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2010", "USACO"], "title": "[USACO10FEB] Chocolate Buying S", "background": "", "description": "Bessie and the herd love chocolate so Farmer John is buying them some.\n\nThe Bovine Chocolate Store features $N (1 \\le N \\le 100,000)$ kinds of chocolate in essentially unlimited quantities.  Each type i of chocolate has price $P_i (1 \\le P_i \\le 10^{18})$ per piece and there are $C_i (1 \\le C_i \\le 10^{18})$ cows that want that type of chocolate.\n\nFarmer John has a budget of $B (1 \\le B \\le 10^{18})$ that he can spend on chocolates for the cows. What is the maximum number of cows that he can satisfy?  All cows only want one type of chocolate, and will be satisfied only by that type.\n\nConsider an example where FJ has $50$ to spend on $5$ different types of chocolate. A total of eleven cows have various chocolate preferences:\n\n|Chocolate\\_Type|Per\\_Chocolate\\_Cost|Cows\\_preferring\\_this\\_type| \n|:-----------:|:-----------:|:-----------:|\n|$1$|$5$|$3$|\n|$2$|$1$|$1$|\n|$3$|$10$|$4$|\n|$4$|$7$|$2$|\n|$5$|$60$|$1$|\n\nObviously, FJ can't purchase chocolate type $5$, since he doesn't have enough money. Even if it cost only $50$, it's a counterproductive purchase since only one cow would be satisfied.\n\nLooking at the chocolates start at the less expensive ones, he can purchase $1$ chocolate of type $2$ for $1 \\times 1$ leaving $50-1=49$, then purchase $3$ chocolate of type $1$ for $3 \\times 5$ leaving $49-15=34$, then  purchase $2$ chocolate of type $4$ for $2 \\times 7$ leaving $34-14=20$, then  purchase $2$ chocolate of type $3$ for $2 \\times 10$ leaving $20-20=0$.\n\nHe would thus satisfy $1 + 3 + 2 + 2 = 8$ cows. ", "inputFormat": "\nLine $1$: Two space separated integers: $N$ and $B$.\n\nLines $2\\ldots N+1$: Line $i$ contains two space separated integers defining chocolate type $i$: $P_i$ and $C_i$.", "outputFormat": "Line $1$: A single integer that is the maximum number of cows that Farmer John can satisfy.", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10FEB] Chocolate Buying S", "background": "", "description": "Bessie and the herd love chocolate so Farmer John is buying them some.\n\nThe Bovine Chocolate Store features $N (1 \\le N \\le 100,000)$ kinds of chocolate in essentially unlimited quantities.  Each type i of chocolate has price $P_i (1 \\le P_i \\le 10^{18})$ per piece and there are $C_i (1 \\le C_i \\le 10^{18})$ cows that want that type of chocolate.\n\nFarmer John has a budget of $B (1 \\le B \\le 10^{18})$ that he can spend on chocolates for the cows. What is the maximum number of cows that he can satisfy?  All cows only want one type of chocolate, and will be satisfied only by that type.\n\nConsider an example where FJ has $50$ to spend on $5$ different types of chocolate. A total of eleven cows have various chocolate preferences:\n\n|Chocolate\\_Type|Per\\_Chocolate\\_Cost|Cows\\_preferring\\_this\\_type| \n|:-----------:|:-----------:|:-----------:|\n|$1$|$5$|$3$|\n|$2$|$1$|$1$|\n|$3$|$10$|$4$|\n|$4$|$7$|$2$|\n|$5$|$60$|$1$|\n\nObviously, FJ can't purchase chocolate type $5$, since he doesn't have enough money. Even if it cost only $50$, it's a counterproductive purchase since only one cow would be satisfied.\n\nLooking at the chocolates start at the less expensive ones, he can purchase $1$ chocolate of type $2$ for $1 \\times 1$ leaving $50-1=49$, then purchase $3$ chocolate of type $1$ for $3 \\times 5$ leaving $49-15=34$, then  purchase $2$ chocolate of type $4$ for $2 \\times 7$ leaving $34-14=20$, then  purchase $2$ chocolate of type $3$ for $2 \\times 10$ leaving $20-20=0$.\n\nHe would thus satisfy $1 + 3 + 2 + 2 = 8$ cows. ", "inputFormat": "\nLine $1$: Two space separated integers: $N$ and $B$.\n\nLines $2\\ldots N+1$: Line $i$ contains two space separated integers defining chocolate type $i$: $P_i$ and $C_i$.", "outputFormat": "Line $1$: A single integer that is the maximum number of cows that Farmer John can satisfy.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10FEB] Chocolate Buying S", "background": "", "description": "Bessie 和牛群都非常喜欢巧克力，所以农夫约翰打算为它们购买一些。\n\n牛巧克力商店提供 $N$ 种巧克力（$1 \\le N \\le 100,000$），每种巧克力的数量基本上是无限的。每种巧克力 $i$ 的单价为 $P_i$（$1 \\le P_i \\le 10^{18}$），并且有 $C_i$（$1 \\le C_i \\le 10^{18}$）头牛想要这种巧克力。\n\n农夫约翰有一个预算 $B$（$1 \\le B \\le 10^{18}$），他可以用来为牛群购买巧克力。他最多能满足多少头牛？所有的牛只想要一种巧克力，并且只会对这种巧克力感到满意。\n\n考虑一个例子，假设农夫约翰有 $50$ 元可以花在 $5$ 种不同的巧克力上。总共有 11 头牛对各种巧克力有不同的偏好：\n\n| 巧克力类型 | 每块巧克力的价格 | 喜欢这种类型的牛数量 | \n|:-----------:|:-----------:|:-----------:|\n| $1$ | $5$ | $3$ |\n| $2$ | $1$ | $1$ |\n| $3$ | $10$ | $4$ |\n| $4$ | $7$ | $2$ |\n| $5$ | $60$ | $1$ |\n\n显然，农夫约翰不能购买第 5 种巧克力，因为他没有足够的钱。即使它只花费 $50$，这也是一个不划算的购买，因为只有一头牛会感到满意。\n\n从价格较低的巧克力开始，他可以购买 1 块第 2 种巧克力，花费 $1 \\times 1$，剩下 $50-1=49$；然后购买 3 块第 1 种巧克力，花费 $3 \\times 5$，剩下 $49-15=34$；然后购买 2 块第 4 种巧克力，花费 $2 \\times 7$，剩下 $34-14=20$；最后购买 2 块第 3 种巧克力，花费 $2 \\times 10$，剩下 $20-20=0$。\n\n这样，他就能满足 $1 + 3 + 2 + 2 = 8$ 头牛。", "inputFormat": "\n第 1 行：两个用空格分隔的整数：$N$ 和 $B$。\n\n第 $2\\ldots N+1$ 行：第 $i$ 行包含两个用空格分隔的整数，定义巧克力类型 $i$：$P_i$ 和 $C_i$。", "outputFormat": "第 1 行：一个整数，表示农夫约翰最多能满足的牛的数量。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2984", "type": "P", "difficulty": 3, "samples": [["6 7 3 \n1 2 3 \n5 4 3 \n3 1 1 \n6 1 9 \n3 4 2 \n1 4 4 \n3 2 2 \n2 4 \n5 1 \n3 6 \n", "6 \n6 \n10 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2010", "USACO", "最短路"], "title": "[USACO10FEB] Chocolate Giving S", "background": null, "description": "Farmer John is distributing chocolates at the barn for Valentine's day, and $B$ ($1 \\le B \\le 25000$) of his bulls have a special cow in mind to receive a chocolate gift.\n\nEach of the bulls and cows is grazing alone in one of the farm's $N$ ($2\\times B \\le N \\le 50000$) pastures conveniently numbered $1\\dots N$ and connected by $M$ ($N-1 \\le M \\le 10^5$) bidirectional cowpaths of various lengths. Some pastures might be directly connected by more than one cowpath. Cowpath $i$ connects pastures $R_i $ and $S_i$ ($1 \\le R_i \\le N$; $1 \\le S_i \\le N$) and has length $L_i$ ($1 \\le L_i \\le 2000$).\n\nBull $i$ resides in pasture $P_i$ ($1 \\le P_i \\le N$) and wishes to give a chocolate to the cow in pasture $Q_i$ ($1 \\le Q_i \\le N$).\n\nHelp the bulls find the shortest path from their current pasture to the barn (which is located at pasture $1$) and then onward to the pasture where their special cow is grazing. The barn connects, one way or another (potentially via other cowpaths and pastures) to every pasture.\n\nAs an example, consider a farm with $6$ pastures, $6$ paths, and $3$ bulls (in pastures $2$, $3$, and $5$) who wish to bestow chocolates on their love-objects:\n\n```cpp\n\n                      *1  <-- Bull wants chocolates for pasture 1 cow\n             [4]--3--[5]  <-- [5] is the pasture ID\n            /  |\n           /   |\n          4    2          <-- 2 is the cowpath length\n         /     |               between [3] and [4]\n      [1]--1--[3]*6\n     /   \\    /\n    9     3  2\n   /       \\/\n [6]      [2]*4\n```\n\\* The Bull in pasture $2$ can travel distance $3$ (two different ways) to get to the barn then travel distance $2+1$ to pastures $[3]$ and $[4]$ to gift his chocolate. That's $6$ altogether.\n\n\\* The Bull in pasture $5$ can travel to pasture $4$ (distance $3$), then pastures $3$ and $1$ (total: $3 + 2 + 1 = 6$) to bestow his chocolate offer.\n\n\\* The Bull in pasture $3$ can travel distance $1$ to pasture $1$ and then take his chocolate $9$ more to pasture $6$, a total distance of $10$.", "inputFormat": "\\* Line $1$: Three space separated integers: $N$, $M$, and $B$;\n\n\\* Lines $2\\dots M+1$: Line $i+1$ describes cowpath $i$ with three space-separated integers: $R_i$, $S_i$, and $L_i$;\n\n\\* Lines $M+2\\dots M+B+1$: Line $M+i+1$ contains two space separated integers: $P_i$ and $Q_i$.", "outputFormat": "\\* Lines $1\\dots B$: Line $i$ should contain a single integer, the smallest distance that the bull in pasture $P_i$ must travel to get chocolates from the barn and then award them to the cow of his dreams in pasture $Q_i$.", "hint": null, "locale": "en", "translations": {"en": {"title": "[USACO10FEB] Chocolate Giving S", "background": null, "description": "Farmer John is distributing chocolates at the barn for Valentine's day, and $B$ ($1 \\le B \\le 25000$) of his bulls have a special cow in mind to receive a chocolate gift.\n\nEach of the bulls and cows is grazing alone in one of the farm's $N$ ($2\\times B \\le N \\le 50000$) pastures conveniently numbered $1\\dots N$ and connected by $M$ ($N-1 \\le M \\le 10^5$) bidirectional cowpaths of various lengths. Some pastures might be directly connected by more than one cowpath. Cowpath $i$ connects pastures $R_i $ and $S_i$ ($1 \\le R_i \\le N$; $1 \\le S_i \\le N$) and has length $L_i$ ($1 \\le L_i \\le 2000$).\n\nBull $i$ resides in pasture $P_i$ ($1 \\le P_i \\le N$) and wishes to give a chocolate to the cow in pasture $Q_i$ ($1 \\le Q_i \\le N$).\n\nHelp the bulls find the shortest path from their current pasture to the barn (which is located at pasture $1$) and then onward to the pasture where their special cow is grazing. The barn connects, one way or another (potentially via other cowpaths and pastures) to every pasture.\n\nAs an example, consider a farm with $6$ pastures, $6$ paths, and $3$ bulls (in pastures $2$, $3$, and $5$) who wish to bestow chocolates on their love-objects:\n\n```cpp\n\n                      *1  <-- Bull wants chocolates for pasture 1 cow\n             [4]--3--[5]  <-- [5] is the pasture ID\n            /  |\n           /   |\n          4    2          <-- 2 is the cowpath length\n         /     |               between [3] and [4]\n      [1]--1--[3]*6\n     /   \\    /\n    9     3  2\n   /       \\/\n [6]      [2]*4\n```\n\\* The Bull in pasture $2$ can travel distance $3$ (two different ways) to get to the barn then travel distance $2+1$ to pastures $[3]$ and $[4]$ to gift his chocolate. That's $6$ altogether.\n\n\\* The Bull in pasture $5$ can travel to pasture $4$ (distance $3$), then pastures $3$ and $1$ (total: $3 + 2 + 1 = 6$) to bestow his chocolate offer.\n\n\\* The Bull in pasture $3$ can travel distance $1$ to pasture $1$ and then take his chocolate $9$ more to pasture $6$, a total distance of $10$.", "inputFormat": "\\* Line $1$: Three space separated integers: $N$, $M$, and $B$;\n\n\\* Lines $2\\dots M+1$: Line $i+1$ describes cowpath $i$ with three space-separated integers: $R_i$, $S_i$, and $L_i$;\n\n\\* Lines $M+2\\dots M+B+1$: Line $M+i+1$ contains two space separated integers: $P_i$ and $Q_i$.", "outputFormat": "\\* Lines $1\\dots B$: Line $i$ should contain a single integer, the smallest distance that the bull in pasture $P_i$ must travel to get chocolates from the barn and then award them to the cow of his dreams in pasture $Q_i$.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO10FEB] Chocolate Giving S", "background": "", "description": "FJ 有 $B$ 头奶牛 $(1\\le B\\le 25000)$，有 $N(2\\times B\\le N\\le 50000)$ 个农场，编号 $1$ 到 $N$，有 $M(N-1\\le M\\le 100000)$ 条双向边，第 $i$ 条边连接农场 $R_i$ 和 $S_i(1\\le R_i\\le N, 1\\le S_i\\le N)$，该边的长度是 $L_i(1\\le L_i\\le 2000)$。居住在农场 $P_i$ 的奶牛 A $(1\\le P_i\\le N)$，想送一份新年礼物给居住在农场 $Q_i(1\\le Q_i\\le N)$ 的奶牛 B，但是奶牛 A 必须先到 FJ（居住在编号 $1$ 的农场）那里取礼物，然后再送给奶牛 B。你的任务是：奶牛 A 至少需要走多远的路程？", "inputFormat": "* 第一行三个整数 $N,M,B$。\n* 第 $2$ 至 $M+1$ 行，每行 $3$ 个整数 $R_i,S_i,L_i$。\n\n* 第 $M+2$ 至 $M+B+1$ 行，进行 $B$ 次询问，每行 $2$ 个整数 $P_i ,Q_i$。", "outputFormat": "每次询问输出一个整数，即答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2985", "type": "P", "difficulty": 3, "samples": [["5 5 \n10 \n40 \n13 \n22 \n7 \n", "24 \n1 \n1 \n3 \n4 \n5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2010", "二分", "USACO"], "title": "[USACO10FEB] Chocolate Eating S", "background": null, "description": "Bessie 从公牛们那里收到了 $N$（$1 \\leq N \\leq 5\\times10^4$）块巧克力，但她不想吃得太快，所以她计划在接下来的 $D$（$1 \\leq D \\leq 5\\times10^4$）天内安排吃巧克力的日程，以使这些天中她每天的最低幸福值尽可能高。\n\nBessie 的幸福值是一个整数，初始为 $0$，每晚睡觉时会减半（如果有小数则向下取整）。然而，当她吃掉第 $i$ 块巧克力时，幸福值会增加整数 $H_i$（$1 \\leq H_i \\leq 1\\times10^6$）。如果她在某天吃巧克力，那么当天的幸福值以吃完巧克力后的值为准。Bessie 坚持要按照收到巧克力的顺序来吃。\n\n如果有多个最优解，输出任意一个即可。\n\n考虑一个要在 $5$ 天内吃完 $5$ 块巧克力的例子，它们分别带来的幸福值为 $(10, 40, 13, 22, 7)$。\n\n如果 Bessie 在第一天吃掉第一块巧克力（$10$ 幸福值），然后等待之后再吃其他巧克力，她第一天的幸福值就是 $10$。\n\n以下是一个最大化最低幸福值的完整安排：\n\n第 $1$ 天：起床时幸福值 $0$ → 吃掉 $10+40$ → 睡前幸福值 $50$。\n\n第 $2$ 天：起床时幸福值 $25$ → 不吃 → 睡前幸福值 $25$。\n\n第 $3$ 天：起床时幸福值 $12$ → 吃掉 $13$ → 睡前幸福值 $25$。\n\n第 $4$ 天：起床时幸福值 $12$ → 吃掉 $22$ → 睡前幸福值 $34$。\n\n第 $5$ 天：起床时幸福值 $17$ → 吃掉 $7$ → 睡前幸福值 $24$。\n\n这样得到的最低睡前幸福值是 $24$，这是 Bessie 能做到的最好结果。", "inputFormat": "* 第 $1$ 行：两个用空格分隔的整数：$N$ 和 $D$。\n* 第 $2\\sim N+1$ 行：第 $i+1$ 行包含一个整数：$H_i$。", "outputFormat": "* 第 $1$ 行：一个整数，表示 Bessie 在接下来 $D$ 天中能达到的最高最低幸福值。\n* 第 $2\\sim N+1$ 行：第 $i+1$ 行包含一个整数，表示 Bessie 吃掉第 $i$ 块巧克力的日期。", "hint": "翻译由 DeepSeek 辅助完成。\n\nAssisted translation by DeepSeek.", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10FEB] Chocolate Eating S", "background": null, "description": "Bessie has received N (1 <= N <= 50,000) chocolates from the bulls, but doesn't want to eat them too quickly, so she wants to plan out her chocolate eating schedule for the next D (1 <= D <= 50,000) days in order to maximize her minimum happiness level over the set of those days.\n\nBessie's happiness level is an integer that starts at 0 and halves (rounding down if necessary) over night as she sleeps. However, when she eats chocolate i, her happiness level increases by integer H\\_i (1 <= H\\_i <= 1,000,000). If she eats chocolates on a day, her happiness for that day is considered the happiness level after she eats the chocolates. Bessie insists that she eat the chocolates in the order that she received them.\n\nIf more than one optimal solution exists, print any one of them.\n\nConsider a sequence of 5 chocolates to be eaten over a period of 5 days; they respectively bring happiness (10, 40, 13, 22, 7).\n\nIf Bessie eats the first chocolate (10 happiness) on the first day and then waits to eat the others, her happiness level is 10 after the first day.\n\nHere is the complete schedule which turns out to maximize her minimum happiness:\n\n\n|Day|  Wakeup happiness|   Happiness from eating|   Bedtime happiness|\n|-:|-:|-:|-:|\n|1|            0|             10 + 40|                   50|\n|2|           25|                 ---|                   25|\n|3|           12|                  13|                   25|\n|4|           12|                  22|                   34|\n|5|           17|                   7|                   24|\n\n\nThe minimum bedtime happiness is 24, which turns out to be the best Bessie can do.", "inputFormat": "\\* Line 1: Two space separated integers: N and D\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: H\\_i", "outputFormat": "\\* Line 1: A single integer, the highest Bessie's minimum happiness can be over the next D days\n\n\\* Lines 2..N+1: Line i+1 contains an integer that is the day on which Bessie eats chocolate i", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO10FEB] Chocolate Eating S", "background": null, "description": "Bessie 从公牛们那里收到了 $N$（$1 \\leq N \\leq 5\\times10^4$）块巧克力，但她不想吃得太快，所以她计划在接下来的 $D$（$1 \\leq D \\leq 5\\times10^4$）天内安排吃巧克力的日程，以使这些天中她每天的最低幸福值尽可能高。\n\nBessie 的幸福值是一个整数，初始为 $0$，每晚睡觉时会减半（如果有小数则向下取整）。然而，当她吃掉第 $i$ 块巧克力时，幸福值会增加整数 $H_i$（$1 \\leq H_i \\leq 1\\times10^6$）。如果她在某天吃巧克力，那么当天的幸福值以吃完巧克力后的值为准。Bessie 坚持要按照收到巧克力的顺序来吃。\n\n如果有多个最优解，输出任意一个即可。\n\n考虑一个要在 $5$ 天内吃完 $5$ 块巧克力的例子，它们分别带来的幸福值为 $(10, 40, 13, 22, 7)$。\n\n如果 Bessie 在第一天吃掉第一块巧克力（$10$ 幸福值），然后等待之后再吃其他巧克力，她第一天的幸福值就是 $10$。\n\n以下是一个最大化最低幸福值的完整安排：\n\n第 $1$ 天：起床时幸福值 $0$ → 吃掉 $10+40$ → 睡前幸福值 $50$。\n\n第 $2$ 天：起床时幸福值 $25$ → 不吃 → 睡前幸福值 $25$。\n\n第 $3$ 天：起床时幸福值 $12$ → 吃掉 $13$ → 睡前幸福值 $25$。\n\n第 $4$ 天：起床时幸福值 $12$ → 吃掉 $22$ → 睡前幸福值 $34$。\n\n第 $5$ 天：起床时幸福值 $17$ → 吃掉 $7$ → 睡前幸福值 $24$。\n\n这样得到的最低睡前幸福值是 $24$，这是 Bessie 能做到的最好结果。", "inputFormat": "* 第 $1$ 行：两个用空格分隔的整数：$N$ 和 $D$。\n* 第 $2\\sim N+1$ 行：第 $i+1$ 行包含一个整数：$H_i$。", "outputFormat": "* 第 $1$ 行：一个整数，表示 Bessie 在接下来 $D$ 天中能达到的最高最低幸福值。\n* 第 $2\\sim N+1$ 行：第 $i+1$ 行包含一个整数，表示 Bessie 吃掉第 $i$ 块巧克力的日期。", "hint": "翻译由 DeepSeek 辅助完成。\n\nAssisted translation by DeepSeek.", "locale": "zh-CN"}}}
{"pid": "P2986", "type": "P", "difficulty": 4, "samples": [["5 \n1 \n1 \n0 \n0 \n2 \n1 3 1 \n2 3 2 \n3 4 3 \n4 5 3 \n", "15 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2010", "USACO", "树形 DP"], "title": "[USACO10MAR] Great Cow Gathering G", "background": "", "description": "Bessie 正在计划一年一度的奶牛大集会，来自全国各地的奶牛将来参加这一次集会。当然，她会选择最方便的地点来举办这次集会。\n\n每个奶牛居住在 $N$ 个农场中的一个，这些农场由 $N-1$ 条道路连接，并且从任意一个农场都能够到达另外一个农场。道路 $i$ 连接农场 $A_i$ 和 $B_i$，长度为 $L_i$。集会可以在 $N$ 个农场中的任意一个举行。另外，每个牛棚中居住着 $C_i$ 只奶牛。\n\n在选择集会的地点的时候，Bessie 希望最大化方便的程度（也就是最小化不方便程度）。比如选择第 $X$ 个农场作为集会地点，它的不方便程度是其它牛棚中每只奶牛去参加集会所走的路程之和（比如，农场 $i$ 到达农场 $X$ 的距离是 $20$，那么总路程就是 $C_i\\times 20$）。帮助 Bessie 找出最方便的地点来举行大集会。", "inputFormat": "第一行一个整数 $N$ 。\n\n第二到 $N+1$ 行：第 $i+1$ 行有一个整数 $C_i$。\n\n第 $N+2$ 行到 $2N$ 行：第 $i+N+1$ 行为 $3$ 个整数：$A_i,B_i$ 和 $L_i$。", "outputFormat": "一行一个整数，表示最小的不方便值。", "hint": "$1\\leq N\\leq 10^5$，$1\\leq A_i\\leq B_i\\leq N$，$0 \\leq C_i,L_i \\leq 10^3$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10MAR] Great Cow Gathering G", "background": "", "description": "Bessie is planning the annual grand cow gathering, with cows coming from all over the country. Of course, she will choose the most convenient place to hold it.\n\nEach cow lives on one of the $N$ farms, which are connected by $N-1$ roads so that any farm is reachable from any other. Road $i$ connects farms $A_i$ and $B_i$ with length $L_i$. The gathering may be held at any of the $N$ farms. In addition, farm $i$ contains $C_i$ cows.\n\nWhen choosing the location, Bessie wants to maximize convenience (that is, minimize inconvenience). If farm $X$ is chosen as the location, its inconvenience is the sum, over all other farms, of the distance each cow must travel to attend. For example, if the distance from farm $i$ to farm $X$ is $20$, then the total distance contributed by farm $i$ is $C_i \\times 20$. Help Bessie find the most convenient farm for the gathering.", "inputFormat": "- Line 1: an integer $N$.\n- Lines 2 to $N+1$: line $i+1$ contains a single integer $C_i$.\n- Lines $N+2$ to $2N$: line $i+N+1$ contains $3$ integers $A_i$, $B_i$, and $L_i$.", "outputFormat": "A single line containing one integer, the minimum inconvenience.", "hint": "Constraints\n\n$1 \\leq N \\leq 10^5$, $1 \\leq A_i \\leq B_i \\leq N$, $0 \\leq C_i, L_i \\leq 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10MAR] Great Cow Gathering G", "background": "", "description": "Bessie 正在计划一年一度的奶牛大集会，来自全国各地的奶牛将来参加这一次集会。当然，她会选择最方便的地点来举办这次集会。\n\n每个奶牛居住在 $N$ 个农场中的一个，这些农场由 $N-1$ 条道路连接，并且从任意一个农场都能够到达另外一个农场。道路 $i$ 连接农场 $A_i$ 和 $B_i$，长度为 $L_i$。集会可以在 $N$ 个农场中的任意一个举行。另外，每个牛棚中居住着 $C_i$ 只奶牛。\n\n在选择集会的地点的时候，Bessie 希望最大化方便的程度（也就是最小化不方便程度）。比如选择第 $X$ 个农场作为集会地点，它的不方便程度是其它牛棚中每只奶牛去参加集会所走的路程之和（比如，农场 $i$ 到达农场 $X$ 的距离是 $20$，那么总路程就是 $C_i\\times 20$）。帮助 Bessie 找出最方便的地点来举行大集会。", "inputFormat": "第一行一个整数 $N$ 。\n\n第二到 $N+1$ 行：第 $i+1$ 行有一个整数 $C_i$。\n\n第 $N+2$ 行到 $2N$ 行：第 $i+N+1$ 行为 $3$ 个整数：$A_i,B_i$ 和 $L_i$。", "outputFormat": "一行一个整数，表示最小的不方便值。", "hint": "$1\\leq N\\leq 10^5$，$1\\leq A_i\\leq B_i\\leq N$，$0 \\leq C_i,L_i \\leq 10^3$。", "locale": "zh-CN"}}}
{"pid": "P2987", "type": "P", "difficulty": 6, "samples": [["3 3 \nJ 6 5 4 5 4 7 \nB 5 4 2 3 5 5 \nJ 9 0 10 8 2 7 \n6 6 4 5 4 7 \n9 0 10 8 2 6 \n3 4 8 4 4 6 \n", "J \nJ \nU \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "USACO"], "title": "[USACO10MAR] StarCowraft G", "background": "", "description": "The beta version of StarCowraft II is ready! Farmer John and Bessie are testing it, trying different strategies in one-on-one battles against each other's armies. The goal in StarCowraft II is to defeat your opponent's army in a battle.\n\nEach player's army fights in a battle. An army comprises as many as three different types of 'units' with respective strengths denoted by constant positive real numbers unknown to the players: cattlebruisers with strength S1, cow templars with strength S2, and ultracows with strength S3. The only given bounding information is that no unit is more than 100 times as strong as any another unit.\n\nAn army's total strength is the sum of the individual strengths of each of its units. An army that has, among others units, 23\n\ncattlebruisers would gain 23\\*S1 strength just from the cattlebruisers.\n\nWhen two opposing armies fight in a battle, the army with a higher total strength value wins.  If the armies have exactly equal strength values, one of the players randomly wins.\n\nFarmer John and Bessie played N (0 <= N <= 300) 'test battles'. In the i-th test battle, FJ's army had J1\\_i cattlebruisers, J2\\_i cow templars, and J3\\_i ultracows (0 <= J1\\_i + J2\\_i + J3\\_i <= 1,000). Similarly, Bessie's army had B1\\_i cattlebruisers, B2\\_i cow templars, and B3\\_i ultracows (0 <= B1\\_i + B2\\_i + B3\\_i <= 1,000). After their armies fought against each other, FJ and Bessie recorded the winner as a single 'victory letter' V\\_i: 'J' if Farm John won the battle; 'B' if Bessie won.\n\nAlthough these victory results are the only information that they have, they hope to predict some of the results of additional battles if they are given the unit compositions of two opposing armies. For some battles, though, they know it might not be possible to determine the winner with certainty.\n\nGiven the results of the N test battles that Farmer John and Bessie already played, write a program that decides the winner (if possible) for M (1 <= M <= 2,000) new battles.\n\nThe results reported for the test battles are correct; there exists at least one set of strength values which are consistent with the results.\n\nFor purposes of demonstrating the army strength evaluation functions, consider these test battles fought in a game where we (but neither FJ nor Bessie) know that S1=9.0, S2=7.0, and S3=4.0:\n\n```cpp\n---- Farmer John ----    ------- Bessie ------    Battle \nJ1  J2  J3 J_Strength    B1  B2  B3 B_Strength   Outcome \n6   5   4    105         5   4   7    101          J \n5   4   2     81         3   5   5     82          B \n9   0  10    121         8   2   7    114          J \n```\nThese results connote the following deduced results for the reasons shown:\n\n---- Farmer John ----    ------- Bessie ------    Battle\n\nJ1  J2  J3 J\\_Strength    B1  B2  B3 B\\_Strength   Outcome\n\n6   6   4    112         5   4   7    101          J\n\nFJ's army is even stronger than in test battle 1 9   0  10    121         8   2   6    110          J\n\nBessie's army is even weaker than in test battle 3\n\n《星际争霸2》全面公测啦！Farmer John和Bessie正在测试中——在1v1的战役中使用一些不同的策略来对抗对方的部队。《星际争霸2》的游戏目标就是在战役中打败你对手的军队。\n\n每个选手的军队都在战役中拼杀。一支军队由若干3种不同类型的单位所组成，不同单位有着不同的由正实数表示的，且不被选手所知道的力量值：cattlebruisers 的力量是S1，cow templars 的力量是S2，ultracows的力量是S3。唯一提供的信息是，没有一个单位的力量值超过另一个单位力量值的100倍。\n\n一支军队的总力量值，是其中各自单独的单位的力量值的总和。比如一支军队除了其他单位有23个cattlebruisers，那么这支军队单独从cattlebruisers就能获得23\\*S1的力量值。\n\n当两支对立的军队在战役中厮杀，有着更高力量值的军队将获得胜利。如果两支军队的力量值恰好相同，那么将随机产生一个获胜方。\n\nFarmer John 和 Bessie 进行了 N (0 <= N <= 300) 局的“测试战役”。在第 i 局测试战役中，Farmer John 有 J1\\_i 个 cattlebruisers，J2\\_i 个 cow templars 以及 J3\\_i 个 ultracows(0 <= J1\\_i + J2\\_i + J3\\_i <= 1,000)。相似的，Bessie的军队有 B1\\_i 个 cattlebruisers，B2\\_i 个 cow templars 以及 B3\\_i 个 ultracows (0 <= B1\\_i + B2\\_i + B3\\_i <= 1,000)。当他们的军队战斗结束后，FJ 和 Bessie 将胜者以一个单独的“胜利字母” V\\_i 记录下来：\"J\"表示 Farmer John 赢得了战役；\"B\" 表示 Bessie 获胜了。\n\n虽然这些结果是他们唯一所拥有的信息，但是他们希望预测一些额外的战役的结果——如果告知他们两支对立军队的组成。尽管，可能对于一些比赛他们是无法确定到底哪一方一定能获胜的。\n\n给出已经结束的 N 场测试战役的结果，写一个程序来确定(如果可能的话)M (1 <=M <=2,000)场额外战役的获胜方。\n\n所有给出的测试战役的结果都是正确的。至少存在一种合法的力量值的取值符合这些结果。\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 describes a test battle with seven\n\nspace-separated items -- a victory letter and six\n\nspace-separated integer unit counts: V\\_i, J1\\_i, J2\\_i, J3\\_i, B1\\_i, B2\\_i, and B3\\_i\n\n\\* Lines N+2..N+M+1: Line i+N+1 describes a 'new battle' using six space-separated integers: J1\\_i, J2\\_i, J3\\_i, B1\\_i, B2\\_i, and B3\\_i\n", "outputFormat": "\\* Lines 1..M: Line i contains the outcome of the i-th new battle: 'J' if Farmer John definitely wins, 'B' if Bessie definitely wins, and 'U' (undecidable) if it is impossible to decide the winner with the given information.\n", "hint": "First two games correspond to the examples in the description. The result of the last game cannot be determined with only the information that Farmer John and Bessie currently have. Specifically, both S\\_1=9.0, S\\_2=7.0, S\\_3=4.0 and S\\_1=12.0, S\\_2=20.0, S\\_3=10.0 are consistent with the &quot;test battles,&quot; but they give different results when plugged in the third &quot;new battle.&quot;\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10MAR] StarCowraft G", "background": "", "description": "The beta version of StarCowraft II is ready! Farmer John and Bessie are testing it, trying different strategies in one-on-one battles against each other’s armies. The goal in StarCowraft II is to defeat your opponent’s army in a battle.\n\nEach player’s army fights in a battle. An army comprises up to three different types of units with respective strengths denoted by constant positive real numbers unknown to the players: cattlebruisers with strength S1, cow templars with strength S2, and ultracows with strength S3. The only given bounding information is that no unit is more than 100 times as strong as any other unit.\n\nAn army’s total strength is the sum of the individual strengths of each of its units. For example, an army that has, among other units, 23 cattlebruisers would gain 23*S1 strength just from the cattlebruisers.\n\nWhen two opposing armies fight in a battle, the army with the higher total strength value wins. If the armies have exactly equal strength values, one of the players wins at random.\n\nFarmer John and Bessie played N (0 <= N <= 300) test battles. In the i-th test battle, FJ’s army had J1\\_i cattlebruisers, J2\\_i cow templars, and J3\\_i ultracows (0 <= J1\\_i + J2\\_i + J3\\_i <= 1,000). Similarly, Bessie’s army had B1\\_i cattlebruisers, B2\\_i cow templars, and B3\\_i ultracows (0 <= B1\\_i + B2\\_i + B3\\_i <= 1,000). After their armies fought, FJ and Bessie recorded the winner as a single victory letter V\\_i: ‘J’ if Farmer John won the battle; ‘B’ if Bessie won.\n\nAlthough these victory results are the only information they have, they hope to predict some of the results of additional battles if they are given the unit compositions of two opposing armies. For some battles, however, it might not be possible to determine the winner with certainty.\n\nGiven the results of the N test battles that Farmer John and Bessie already played, write a program that decides the winner (if possible) for M (1 <= M <= 2,000) new battles.\n\nThe results reported for the test battles are correct; there exists at least one set of strength values that is consistent with the results.\n\nFor purposes of demonstrating the army strength evaluation functions, consider these test battles fought in a game where we (but neither FJ nor Bessie) know that S1 = 9.0, S2 = 7.0, and S3 = 4.0:\n\n```cpp\n---- Farmer John ----    ------- Bessie ------    Battle \nJ1  J2  J3 J_Strength    B1  B2  B3 B_Strength   Outcome \n6   5   4    105         5   4   7    101          J \n5   4   2     81         3   5   5     82          B \n9   0  10    121         8   2   7    114          J \n```\n\nThese results imply the following deduced results, for the reasons shown:\n\n```cpp\n---- Farmer John ----    ------- Bessie ------    Battle\nJ1  J2  J3 J_Strength    B1  B2  B3 B_Strength   Outcome\n6   6   4    112         5   4   7    101          J\n9   0  10    121         8   2   6    110          J\n```\n\nFJ’s army is even stronger than in test battle 1.\nBessie’s army is even weaker than in test battle 3.", "inputFormat": "* Line 1: Two space-separated integers: N and M.\n* Lines 2..N+1: Line i+1 describes a test battle with seven space-separated items — a victory letter and six space-separated integer unit counts: V\\_i, J1\\_i, J2\\_i, J3\\_i, B1\\_i, B2\\_i, and B3\\_i.\n* Lines N+2..N+M+1: Line i+N+1 describes a new battle using six space-separated integers: J1\\_i, J2\\_i, J3\\_i, B1\\_i, B2\\_i, and B3\\_i.", "outputFormat": "* Lines 1..M: Line i contains the outcome of the i-th new battle: ‘J’ if Farmer John definitely wins, ‘B’ if Bessie definitely wins, and ‘U’ (undecidable) if it is impossible to decide the winner with the given information.", "hint": "The first two games correspond to the examples in the description. The result of the last game cannot be determined with only the information that Farmer John and Bessie currently have. Specifically, both S1 = 9.0, S2 = 7.0, S3 = 4.0 and S1 = 12.0, S2 = 20.0, S3 = 10.0 are consistent with the “test battles,” but they give different results when plugged into the third “new battle.”\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO10MAR] StarCowraft G", "background": "", "description": "The beta version of StarCowraft II is ready! Farmer John and Bessie are testing it, trying different strategies in one-on-one battles against each other's armies. The goal in StarCowraft II is to defeat your opponent's army in a battle.\n\nEach player's army fights in a battle. An army comprises as many as three different types of 'units' with respective strengths denoted by constant positive real numbers unknown to the players: cattlebruisers with strength S1, cow templars with strength S2, and ultracows with strength S3. The only given bounding information is that no unit is more than 100 times as strong as any another unit.\n\nAn army's total strength is the sum of the individual strengths of each of its units. An army that has, among others units, 23\n\ncattlebruisers would gain 23\\*S1 strength just from the cattlebruisers.\n\nWhen two opposing armies fight in a battle, the army with a higher total strength value wins.  If the armies have exactly equal strength values, one of the players randomly wins.\n\nFarmer John and Bessie played N (0 <= N <= 300) 'test battles'. In the i-th test battle, FJ's army had J1\\_i cattlebruisers, J2\\_i cow templars, and J3\\_i ultracows (0 <= J1\\_i + J2\\_i + J3\\_i <= 1,000). Similarly, Bessie's army had B1\\_i cattlebruisers, B2\\_i cow templars, and B3\\_i ultracows (0 <= B1\\_i + B2\\_i + B3\\_i <= 1,000). After their armies fought against each other, FJ and Bessie recorded the winner as a single 'victory letter' V\\_i: 'J' if Farm John won the battle; 'B' if Bessie won.\n\nAlthough these victory results are the only information that they have, they hope to predict some of the results of additional battles if they are given the unit compositions of two opposing armies. For some battles, though, they know it might not be possible to determine the winner with certainty.\n\nGiven the results of the N test battles that Farmer John and Bessie already played, write a program that decides the winner (if possible) for M (1 <= M <= 2,000) new battles.\n\nThe results reported for the test battles are correct; there exists at least one set of strength values which are consistent with the results.\n\nFor purposes of demonstrating the army strength evaluation functions, consider these test battles fought in a game where we (but neither FJ nor Bessie) know that S1=9.0, S2=7.0, and S3=4.0:\n\n```cpp\n---- Farmer John ----    ------- Bessie ------    Battle \nJ1  J2  J3 J_Strength    B1  B2  B3 B_Strength   Outcome \n6   5   4    105         5   4   7    101          J \n5   4   2     81         3   5   5     82          B \n9   0  10    121         8   2   7    114          J \n```\nThese results connote the following deduced results for the reasons shown:\n\n---- Farmer John ----    ------- Bessie ------    Battle\n\nJ1  J2  J3 J\\_Strength    B1  B2  B3 B\\_Strength   Outcome\n\n6   6   4    112         5   4   7    101          J\n\nFJ's army is even stronger than in test battle 1 9   0  10    121         8   2   6    110          J\n\nBessie's army is even weaker than in test battle 3\n\n《星际争霸2》全面公测啦！Farmer John和Bessie正在测试中——在1v1的战役中使用一些不同的策略来对抗对方的部队。《星际争霸2》的游戏目标就是在战役中打败你对手的军队。\n\n每个选手的军队都在战役中拼杀。一支军队由若干3种不同类型的单位所组成，不同单位有着不同的由正实数表示的，且不被选手所知道的力量值：cattlebruisers 的力量是S1，cow templars 的力量是S2，ultracows的力量是S3。唯一提供的信息是，没有一个单位的力量值超过另一个单位力量值的100倍。\n\n一支军队的总力量值，是其中各自单独的单位的力量值的总和。比如一支军队除了其他单位有23个cattlebruisers，那么这支军队单独从cattlebruisers就能获得23\\*S1的力量值。\n\n当两支对立的军队在战役中厮杀，有着更高力量值的军队将获得胜利。如果两支军队的力量值恰好相同，那么将随机产生一个获胜方。\n\nFarmer John 和 Bessie 进行了 N (0 <= N <= 300) 局的“测试战役”。在第 i 局测试战役中，Farmer John 有 J1\\_i 个 cattlebruisers，J2\\_i 个 cow templars 以及 J3\\_i 个 ultracows(0 <= J1\\_i + J2\\_i + J3\\_i <= 1,000)。相似的，Bessie的军队有 B1\\_i 个 cattlebruisers，B2\\_i 个 cow templars 以及 B3\\_i 个 ultracows (0 <= B1\\_i + B2\\_i + B3\\_i <= 1,000)。当他们的军队战斗结束后，FJ 和 Bessie 将胜者以一个单独的“胜利字母” V\\_i 记录下来：\"J\"表示 Farmer John 赢得了战役；\"B\" 表示 Bessie 获胜了。\n\n虽然这些结果是他们唯一所拥有的信息，但是他们希望预测一些额外的战役的结果——如果告知他们两支对立军队的组成。尽管，可能对于一些比赛他们是无法确定到底哪一方一定能获胜的。\n\n给出已经结束的 N 场测试战役的结果，写一个程序来确定(如果可能的话)M (1 <=M <=2,000)场额外战役的获胜方。\n\n所有给出的测试战役的结果都是正确的。至少存在一种合法的力量值的取值符合这些结果。\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 describes a test battle with seven\n\nspace-separated items -- a victory letter and six\n\nspace-separated integer unit counts: V\\_i, J1\\_i, J2\\_i, J3\\_i, B1\\_i, B2\\_i, and B3\\_i\n\n\\* Lines N+2..N+M+1: Line i+N+1 describes a 'new battle' using six space-separated integers: J1\\_i, J2\\_i, J3\\_i, B1\\_i, B2\\_i, and B3\\_i\n", "outputFormat": "\\* Lines 1..M: Line i contains the outcome of the i-th new battle: 'J' if Farmer John definitely wins, 'B' if Bessie definitely wins, and 'U' (undecidable) if it is impossible to decide the winner with the given information.\n", "hint": "First two games correspond to the examples in the description. The result of the last game cannot be determined with only the information that Farmer John and Bessie currently have. Specifically, both S\\_1=9.0, S\\_2=7.0, S\\_3=4.0 and S\\_1=12.0, S\\_2=20.0, S\\_3=10.0 are consistent with the &quot;test battles,&quot; but they give different results when plugged in the third &quot;new battle.&quot;\n", "locale": "zh-CN"}}}
