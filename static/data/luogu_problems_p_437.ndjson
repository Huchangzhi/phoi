{"pid": "P9860", "type": "P", "difficulty": 2, "samples": [["3\n2\n2\n-|\n*+\n3\n5\n+||*+\n+++|+\n**--+\n2\n3\n+*+\n+*+\n", "3\n7\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 S3] Maze", "background": "", "description": "In order to make a few dollars, you have decided to become part of a scientific experiment. You are fed lots of pizza, then more pizza and then you are asked to find your way across the city on a scooter powered only by pizza. Of course, the city has lots of intersections, and these intersections are very controlled. Some intersections are forbidden for you to enter; some only let you move north/south as you leave the intersection; others let you move only east/west as you leave the intersection; and the rest let you go in any compass direction (north, south, east or west).\n\nThankfully your scientific friends have given you a map of the city (on the back of a pizza box), with an arrangement of symbols indicating how you can move around the city. Specifically, there are 4 different symbols on the box:\n\n- The symbol `+` indicates we can move in any direction (north/south/east/west) from this location.\n\n- The symbol `-` indicates we can move only east or west from this location.\n\n- The symbol `|` indicates we can move only north or south from this location.\n\n- The symbol `*` indicates we cannot occupy this location.\n\nYour task is to determine how many intersections you must pass through to move from the northwest corner of the city to the south-east corner of the city.", "inputFormat": "The input begins with a number $t (1 \\leq t \\leq 10)$ on its own line, which indicates how many different cases are contained in this file. Each case begins with a number $r$ on one line, followed by a number $c$ on the next line $(1 \\leq r, c \\leq 20)$. The next $r$ lines contain $c$ characters, where each character is\none of {`+`, `*`, `-`, `|`}. You may assume the north-west corner of the city can be occupied (i.e., it will not be marked with `*`).", "outputFormat": "The output will be $t$ lines long, with one integer per line. The integer on line $i (1 \\leq i \\leq t)$ indicates the minimum number of intersections required to pass through as you move from the north-west corner of the city to the south-east corner of the city. If there is no way to get from the north-west corner to the south-east corner, output $−1$ for that test case.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CCC 2008 S3] Maze", "background": "", "description": "In order to make a few dollars, you have decided to become part of a scientific experiment. You are fed lots of pizza, then more pizza and then you are asked to find your way across the city on a scooter powered only by pizza. Of course, the city has lots of intersections, and these intersections are very controlled. Some intersections are forbidden for you to enter; some only let you move north/south as you leave the intersection; others let you move only east/west as you leave the intersection; and the rest let you go in any compass direction (north, south, east or west).\n\nThankfully your scientific friends have given you a map of the city (on the back of a pizza box), with an arrangement of symbols indicating how you can move around the city. Specifically, there are 4 different symbols on the box:\n\n- The symbol `+` indicates we can move in any direction (north/south/east/west) from this location.\n\n- The symbol `-` indicates we can move only east or west from this location.\n\n- The symbol `|` indicates we can move only north or south from this location.\n\n- The symbol `*` indicates we cannot occupy this location.\n\nYour task is to determine how many intersections you must pass through to move from the northwest corner of the city to the south-east corner of the city.", "inputFormat": "The input begins with a number $t (1 \\leq t \\leq 10)$ on its own line, which indicates how many different cases are contained in this file. Each case begins with a number $r$ on one line, followed by a number $c$ on the next line $(1 \\leq r, c \\leq 20)$. The next $r$ lines contain $c$ characters, where each character is\none of {`+`, `*`, `-`, `|`}. You may assume the north-west corner of the city can be occupied (i.e., it will not be marked with `*`).", "outputFormat": "The output will be $t$ lines long, with one integer per line. The integer on line $i (1 \\leq i \\leq t)$ indicates the minimum number of intersections required to pass through as you move from the north-west corner of the city to the south-east corner of the city. If there is no way to get from the north-west corner to the south-east corner, output $−1$ for that test case.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 S3] Maze", "background": "", "description": "为了赚点钱，你决定参与一个科学实验。你会被喂很多披萨，然后再吃更多的披萨，接着你需要骑着一辆仅靠披萨驱动的滑板车穿越城市。当然，城市里有很多交叉路口，这些路口受到严格控制。有些路口是禁止进入的；有些只允许你在离开路口时向北或向南移动；有些只允许你在离开路口时向东或向西移动；剩下的则允许你朝任意方向（北、南、东或西）移动。\n\n幸运的是，你的科学朋友给了你一张城市地图（在一个披萨盒的背面），上面用一些符号表示你可以如何在城市中移动。具体来说，盒子上有 4 种不同的符号：\n\n- 符号 `+` 表示我们可以从这个位置向任意方向（北/南/东/西）移动。\n- 符号 `-` 表示我们只能从这个位置向东或向西移动。\n- 符号 `|` 表示我们只能从这个位置向北或向南移动。\n- 符号 `*` 表示我们不能占据这个位置。\n\n你的任务是确定从城市的西北角移动到东南角需要经过多少个交叉路口。", "inputFormat": "输入以一个数字 $t (1 \\leq t \\leq 10)$ 开始，单独占一行，表示文件中包含多少个不同的测试用例。每个测试用例以一个数字 $r$ 开始，接下来一行是一个数字 $c$，其中 $(1 \\leq r, c \\leq 20)$。接下来的 $r$ 行包含 $c$ 个字符，其中每个字符是 {`+`, `*`, `-`, `|`} 中的一个。你可以假设城市的西北角可以被占据（即，它不会被标记为 `*`）。", "outputFormat": "输出将有 $t$ 行，每行一个整数。第 $i (1 \\leq i \\leq t)$ 行的整数表示从城市的西北角移动到东南角所需经过的最少交叉路口数。如果无法从西北角到达东南角，则对该测试用例输出 $-1$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9861", "type": "P", "difficulty": 3, "samples": [["3\n3\n3\n3\n3\n1\n1\n1\n1\n12\n5\n13\n1", "24\n4\n21"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 S4] Twenty-four", "background": "", "description": "Twenty-four is a popular card game designed to be played by four players. Each player is dealt a deck of cards, which are kept face down. On every turn, each of the four players turns over the top card of his or her deck, so that it is visible to all. The goal is to find an arithmetic expression using the values of the cards (with $A$ meaning $1$, $J$ meaning $11$, $Q$ meaning $12$, and K meaning $13$) that evaluates to the number $24$. For example, for the example in the illustration, one possible expression would be:\n\n$((A \\times K) - J) \\times Q$\n\n$((1 \\times 13) - 11) \\times 12$\n\nThe first player to find such an expression wins the turn, and adds all four cards to the bottom of his or her deck.\n\nEach valid arithmetic expression must use all four cards, and must combine their values using addition, subtraction, multiplication, or division. Parentheses are allowed to specify precedence of operations. Juxtaposing cards to make multiple-digit decimal numbers is not allowed (e.g. you cannot place the cards $2$ and $4$ beside each other to make $24$). Non-integer quotients of division are also not allowed, even as a partial result (of a subexpression of the overall expression).\n\nIn some cases, the players may take a very long time to find an expression evaluating to $24$. In fact, in some cases, no such expression exists. Your task is to determine, given four cards, an expression that evaluates to the largest number less than or equal to $24$.", "inputFormat": "The first line contains an integer $1 \\leq N \\leq 5$ indicating the number of card hands that follow. Each hand consists of four lines. Each of these lines is an integer $1 \\leq C \\leq 13$ indicating the value of a card.", "outputFormat": "For each hand, output a line containing an integer n if the cards can be combined using arithmetic operators to evaluate to $n$. The value $n$ should be the largest possible value amongst all possible arithmetic expressions using these $4$ cards, so long as $n \\leq 24$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[CCC 2008 S4] Twenty-four", "background": "", "description": "Twenty-four is a popular card game designed to be played by four players. Each player is dealt a deck of cards, which are kept face down. On every turn, each of the four players turns over the top card of his or her deck, so that it is visible to all. The goal is to find an arithmetic expression using the values of the cards (with $A$ meaning $1$, $J$ meaning $11$, $Q$ meaning $12$, and K meaning $13$) that evaluates to the number $24$. For example, for the example in the illustration, one possible expression would be:\n\n$((A \\times K) - J) \\times Q$\n\n$((1 \\times 13) - 11) \\times 12$\n\nThe first player to find such an expression wins the turn, and adds all four cards to the bottom of his or her deck.\n\nEach valid arithmetic expression must use all four cards, and must combine their values using addition, subtraction, multiplication, or division. Parentheses are allowed to specify precedence of operations. Juxtaposing cards to make multiple-digit decimal numbers is not allowed (e.g. you cannot place the cards $2$ and $4$ beside each other to make $24$). Non-integer quotients of division are also not allowed, even as a partial result (of a subexpression of the overall expression).\n\nIn some cases, the players may take a very long time to find an expression evaluating to $24$. In fact, in some cases, no such expression exists. Your task is to determine, given four cards, an expression that evaluates to the largest number less than or equal to $24$.", "inputFormat": "The first line contains an integer $1 \\leq N \\leq 5$ indicating the number of card hands that follow. Each hand consists of four lines. Each of these lines is an integer $1 \\leq C \\leq 13$ indicating the value of a card.", "outputFormat": "For each hand, output a line containing an integer n if the cards can be combined using arithmetic operators to evaluate to $n$. The value $n$ should be the largest possible value amongst all possible arithmetic expressions using these $4$ cards, so long as $n \\leq 24$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 S4] Twenty-four", "background": "", "description": "二十四点是一种流行的纸牌游戏，适合四名玩家进行。每位玩家会得到一副牌，牌面朝下。在每一轮中，每位玩家翻开自己牌堆顶的一张牌，使其对所有人可见。目标是使用这些牌的值（其中 $A$ 表示 $1$，$J$ 表示 $11$，$Q$ 表示 $12$，$K$ 表示 $13$）找到一个算术表达式，使其结果为 $24$。例如，在示例中，一个可能的表达式是：\n\n$((A \\times K) - J) \\times Q$\n\n$((1 \\times 13) - 11) \\times 12$\n\n第一个找到这样表达式的玩家赢得这一轮，并将四张牌放到自己牌堆的底部。\n\n每个有效的算术表达式必须使用所有四张牌，并且必须通过加法、减法、乘法或除法组合它们的值。允许使用括号来指定运算的优先级。不能将牌并列以构成多位十进制数（例如，不能将牌 $2$ 和 $4$ 并列以形成 $24$）。不允许非整数的除法结果，即使是作为整体表达式的子表达式的部分结果。\n\n在某些情况下，玩家可能需要很长时间才能找到一个结果为 $24$ 的表达式。实际上，在某些情况下，不存在这样的表达式。你的任务是给定四张牌，找出一个结果为小于或等于 $24$ 的最大数的表达式。", "inputFormat": "第一行包含一个整数 $1 \\leq N \\leq 5$，表示接下来有多少副牌。每副牌由四行组成。每行是一个整数 $1 \\leq C \\leq 13$，表示一张牌的值。", "outputFormat": "对于每副牌，如果这些牌可以通过算术运算符组合成一个结果为 $n$ 的表达式，则输出一行包含一个整数 $n$。值 $n$ 应该是在所有可能的算术表达式中不超过 $24$ 的最大值。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9862", "type": "P", "difficulty": 4, "samples": [["6\n0 2 0 2\n1 3 1 3\n1 5 0 3\n3 3 3 3\n8 8 6 7\n8 8 8 8", "Roland\nPatrick\nRoland\nRoland\nRoland\nPatrick"]], "limits": {"time": [2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288]}, "tags": ["2008", "CCC（加拿大）"], "title": "[CCC 2008 J5/S5] Nukit", "background": "注：J5 与 S5 仅数据范围有所不同，在此选取 S5 的数据范围及数据进行评测。", "description": "Canada’s top two nuclear scientists, Patrick and Roland, have just completed the construction of the world’s first nuclear fission reactor. Now it is their job to sit and operate the reactor all day, every day. Naturally they got a little bored after doing this for a while and as a result, two things have happened. First, they can now control the individual reactions that happen inside the reactor. Second, to pass the time, they have invented a new game called Nukit.\n\nAt the beginning of Nukit, a number of particles are put in the reactor. The players take alternating turns, with Patrick always going first. When it is a player’s turn to move, they must select some of the remaining particles to form one of the possible reactions. Then those particles are destroyed. Eventually there will be so few particles that none of the reactions can be formed; at this point, the first person who is unable to form a reaction on their turn loses.\n\nIn our universe you can assume that there are only $4$ types of particles: `A`, `B`, `C`, `D`. Each reaction is a list of particles that can be destroyed on a single turn. The five reactions are:\n\n$1.$ `AABDD`\n\n$2.$ `ABCD`\n\n$3.$ `CCD`\n\n$4.$ `BBB`\n\n$5.$ `AD`\n\nFor example, the first reaction `AABDD` says that it is allowable to destroy two `A`, one `B`, and two `D` particles all at the same time on a turn.\n\nIt turns out that, no matter how many particles start off in the reactor, exactly one of Patrick or Roland has a perfect winning strategy. By player $X$ has a perfect winning strategy, we mean that no matter what the other player does, player $X$ can always win by carefully choosing reactions.\n\nFor example, if the reactor starts off with one `A`, five `B`, and three `D` particles then Roland has the following perfect winning strategy: “if Patrick forms reaction `BBB` initially, then form reaction `AD` afterward; if Patrick forms reaction AD initially, then form reaction `BBB` afterward.” (The strategy works because either way, on Patrick’s second turn, there are not enough particles left to form any reactions.)\n\nGiven the number of each type of particle initially in the reactor, can you figure out who has a perfect winning strategy?", "inputFormat": "The first line of input contains $n$, the number of test cases $(1 \\leq n < 100)$. Each test case consists of $4$ integers separated by spaces on a single line; they represent the initial number of `A`, `B`, `C` and `D` particles. You can assume that there are initially between $0$ and $30$ (inclusive) of each type of particle.", "outputFormat": "For each test case, output the player who has a perfect winning strategy, either `Roland` or `Patrick`.", "hint": "Partial Explanation for Sample Output:\n\nThe first output occurs since Patrick loses immediately, since he cannot form any reaction. (Roland’s perfect winning strategy is “do nothing.”)\n\nThe second output occurs since Patrick has the perfect winning strategy “form reaction ABCD,” which makes Roland lose on his first turn.\n\nThe third output is explained in the problem statement.", "locale": "en", "translations": {"en": {"title": "[CCC 2008 J5/S5] Nukit", "background": "注：J5 与 S5 仅数据范围有所不同，在此选取 S5 的数据范围及数据进行评测。", "description": "Canada’s top two nuclear scientists, Patrick and Roland, have just completed the construction of the world’s first nuclear fission reactor. Now it is their job to sit and operate the reactor all day, every day. Naturally they got a little bored after doing this for a while and as a result, two things have happened. First, they can now control the individual reactions that happen inside the reactor. Second, to pass the time, they have invented a new game called Nukit.\n\nAt the beginning of Nukit, a number of particles are put in the reactor. The players take alternating turns, with Patrick always going first. When it is a player’s turn to move, they must select some of the remaining particles to form one of the possible reactions. Then those particles are destroyed. Eventually there will be so few particles that none of the reactions can be formed; at this point, the first person who is unable to form a reaction on their turn loses.\n\nIn our universe you can assume that there are only $4$ types of particles: `A`, `B`, `C`, `D`. Each reaction is a list of particles that can be destroyed on a single turn. The five reactions are:\n\n$1.$ `AABDD`\n\n$2.$ `ABCD`\n\n$3.$ `CCD`\n\n$4.$ `BBB`\n\n$5.$ `AD`\n\nFor example, the first reaction `AABDD` says that it is allowable to destroy two `A`, one `B`, and two `D` particles all at the same time on a turn.\n\nIt turns out that, no matter how many particles start off in the reactor, exactly one of Patrick or Roland has a perfect winning strategy. By player $X$ has a perfect winning strategy, we mean that no matter what the other player does, player $X$ can always win by carefully choosing reactions.\n\nFor example, if the reactor starts off with one `A`, five `B`, and three `D` particles then Roland has the following perfect winning strategy: “if Patrick forms reaction `BBB` initially, then form reaction `AD` afterward; if Patrick forms reaction AD initially, then form reaction `BBB` afterward.” (The strategy works because either way, on Patrick’s second turn, there are not enough particles left to form any reactions.)\n\nGiven the number of each type of particle initially in the reactor, can you figure out who has a perfect winning strategy?", "inputFormat": "The first line of input contains $n$, the number of test cases $(1 \\leq n < 100)$. Each test case consists of $4$ integers separated by spaces on a single line; they represent the initial number of `A`, `B`, `C` and `D` particles. You can assume that there are initially between $0$ and $30$ (inclusive) of each type of particle.", "outputFormat": "For each test case, output the player who has a perfect winning strategy, either `Roland` or `Patrick`.", "hint": "Partial Explanation for Sample Output:\n\nThe first output occurs since Patrick loses immediately, since he cannot form any reaction. (Roland’s perfect winning strategy is “do nothing.”)\n\nThe second output occurs since Patrick has the perfect winning strategy “form reaction ABCD,” which makes Roland lose on his first turn.\n\nThe third output is explained in the problem statement.", "locale": "en"}, "zh-CN": {"title": "[CCC 2008 J5/S5] Nukit", "background": "", "description": "加拿大的两位顶尖核科学家，Patrick 和 Roland，刚刚完成了世界上第一个核裂变反应堆的建造。现在，他们的工作是每天坐在反应堆前操作它。自然地，在这样做了一段时间后，他们有些无聊，因此发生了两件事。首先，他们现在可以控制反应堆内发生的个别反应。其次，为了打发时间，他们发明了一种叫做 Nukit 的新游戏。\n\n在 Nukit 的开始阶段，反应堆中放入了一些粒子。玩家轮流进行操作，Patrick 总是先走。当轮到一个玩家操作时，他们必须选择一些剩余的粒子来形成一个可能的反应。然后这些粒子被销毁。最终，粒子会变得如此之少，以至于无法形成任何反应；此时，第一个无法在其回合中形成反应的人输掉比赛。\n\n在我们的宇宙中，你可以假设只有 $4$ 种类型的粒子：`A`，`B`，`C`，`D`。每个反应都是可以在单个回合中销毁的粒子列表。五种反应是：\n\n1. `AABDD`\n\n2. `ABCD`\n\n3. `CCD`\n\n4. `BBB`\n\n5. `AD`\n\n例如，第一个反应 `AABDD` 表示可以在一个回合中同时销毁两个 `A`，一个 `B` 和两个 `D` 粒子。\n\n事实证明，无论反应堆中最初有多少粒子，Patrick 或 Roland 中总有一个人有完美的获胜策略。我们所说的玩家 $X$ 有完美的获胜策略，意味着无论另一个玩家做什么，玩家 $X$ 都可以通过仔细选择反应来获胜。\n\n例如，如果反应堆最初有一个 `A`，五个 `B` 和三个 `D` 粒子，那么 Roland 有以下完美的获胜策略：“如果 Patrick 最初形成反应 `BBB`，那么随后形成反应 `AD`；如果 Patrick 最初形成反应 `AD`，那么随后形成反应 `BBB`。”（策略有效，因为无论哪种方式，在 Patrick 的第二个回合中，剩余的粒子不足以形成任何反应。）\n\n给定反应堆中每种类型的粒子的初始数量，你能找出谁有完美的获胜策略吗？", "inputFormat": "输入的第一行包含 $n$，表示测试用例的数量 $(1 \\leq n < 100)$。每个测试用例由一行上的 $4$ 个整数组成，用空格分隔；它们表示 `A`，`B`，`C` 和 `D` 粒子的初始数量。你可以假设每种类型的粒子最初在 $0$ 到 $30$（含）之间。", "outputFormat": "对于每个测试用例，输出有完美获胜策略的玩家，`Roland` 或 `Patrick`。", "hint": "样例输出的部分解释：\n\n第一个输出发生是因为 Patrick 立即输掉，因为他无法形成任何反应。（Roland 的完美获胜策略是“什么都不做。”）\n\n第二个输出发生是因为 Patrick 有完美的获胜策略“形成反应 ABCD”，这使得 Roland 在他的第一个回合中输掉。\n\n第三个输出在问题陈述中已解释。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9863", "type": "P", "difficulty": 4, "samples": [["8 2 1", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["POI（波兰）", "2021", "2022"], "title": "[POI 2021/2022 R2] arm", "background": "翻译自 [POI2021-2022R2 Day0 试机题](https://szkopul.edu.pl/problemset/problem/gxeCvLD1xW1t-Y33bbC0n3wZ/statement/)。\n", "description": "初始时你有 $1$ 个物品，你需要将物品的数量按若干次以下步骤增加到 $> n$ 个。\n\n- 选择 $1$：将物品数量存储进数据库中，耗费 $a$ 的时间。\n- 选择 $2$：使物品数量增加等同于数据库中的数量，耗费 $b$ 的时间。\n\n初始时数据库为空，问最小操作次数。", "inputFormat": "输入一行，共三个整数 $n,a,b\\ (1 \\leq n \\leq 10^{18},1 \\leq a,b \\leq 10^9)$。", "outputFormat": "输出最小的操作次数。", "hint": "样例解释：\n\n初始时你有一个物品。  \n先进行一次扫描，耗费 $2$ 时间。  \n然后打印 $2$ 次，耗费 $1 \\times 2 = 2$ 时间，数量增加到 $3$。  \n继续进行扫描，耗费 $2$ 时间。  \n最后再打印 $2$ 次，耗费 $1 \\times 2 = 2$ 时间，数量变为 $9$。\n\n子任务分配：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | $a = b = 1$ | $10$ |\n| $2$ | $n \\leq 10^3$ | $40$ |\n| $3$ | $n \\leq 10^5$ | $15$ |\n| $4$ | $n \\leq 10^9$ | $15$ |\n| $5$ | 无特殊限制 | $20$ |\n\n子任务 $0$ 为样例。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2021/2022 R2] arm", "background": "翻译自 [POI2021-2022R2 Day0 试机题](https://szkopul.edu.pl/problemset/problem/gxeCvLD1xW1t-Y33bbC0n3wZ/statement/)。\n", "description": "初始时你有 $1$ 个物品，你需要将物品的数量按若干次以下步骤增加到 $> n$ 个。\n\n- 选择 $1$：将物品数量存储进数据库中，耗费 $a$ 的时间。\n- 选择 $2$：使物品数量增加等同于数据库中的数量，耗费 $b$ 的时间。\n\n初始时数据库为空，问最小操作次数。", "inputFormat": "输入一行，共三个整数 $n,a,b\\ (1 \\leq n \\leq 10^{18},1 \\leq a,b \\leq 10^9)$。", "outputFormat": "输出最小的操作次数。", "hint": "样例解释：\n\n初始时你有一个物品。  \n先进行一次扫描，耗费 $2$ 时间。  \n然后打印 $2$ 次，耗费 $1 \\times 2 = 2$ 时间，数量增加到 $3$。  \n继续进行扫描，耗费 $2$ 时间。  \n最后再打印 $2$ 次，耗费 $1 \\times 2 = 2$ 时间，数量变为 $9$。\n\n子任务分配：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | $a = b = 1$ | $10$ |\n| $2$ | $n \\leq 10^3$ | $40$ |\n| $3$ | $n \\leq 10^5$ | $15$ |\n| $4$ | $n \\leq 10^9$ | $15$ |\n| $5$ | 无特殊限制 | $20$ |\n\n子任务 $0$ 为样例。", "locale": "zh-CN"}}}
{"pid": "P9864", "type": "P", "difficulty": 6, "samples": [["6 2\n2 6\n1 2\n2 3\n2 4\n5 4\n5 6", "5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["POI（波兰）", "2021", "2022", "树形 DP"], "title": "[POI 2021/2022 R2] age", "background": "翻译自 [POI2021~2022R2 Day1T1](https://szkopul.edu.pl/problemset/problem/weKRWGa1NgLNHT1WLDo5ohuH/statement/)。\n", "description": "有一个 $n$ 个城市的国家，我们可以将其看为一棵 $n-1$ 条道路连接的树，有一天，你突发奇想，想要派出 $k$ 个人在不同城市上。人及其移动需要满足如下条件：\n\n- 每天只能是一个人移动，移动到其相邻存在道路连接一个城市。\n\n- 假如有两个人 $a,b$，城市 $i$ 被 $a$ 到达过了，则 $b$ 不能到达 $i$ 城市。\n\n初始时你知道了人的位置，每个人初始所在地不相同，且该城市视为“已到达过”的城市，你需要安排一个合法的经过城市的方案。\n\n请你求出最少要几天才能使所有的城市都被人到达过。", "inputFormat": "第一行两个整数 $n,k\\ (1 \\leq n \\leq 5 \\times 10^5, 1 \\leq k \\leq n)$。\n\n第二行 $k$ 个数，表示那些人的初始位置。\n\n然后 $n-1$ 行，描述了每条道路 $(a_i,b_i)\\ (1 \\leq a_i,b_i \\leq n)$。", "outputFormat": "输出最少天数。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y9gojuv8.png)\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $n \\leq 10$ | $6$ |\n| $2$ | $n \\leq 20$ | $13$ |\n| $3$ | $n \\leq 2000$ | $27$ |\n| $4$ | $k=1$ | $10$ |\n| $5$ | $k=2$ | $7$ |\n| $6$ | 输入为一条链 | $7$ |\n| $7$ | 无特殊性质 | $30$ |\n\n子任务 $0$ 为样例。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2021/2022 R2] age", "background": "翻译自 [POI2021~2022R2 Day1T1](https://szkopul.edu.pl/problemset/problem/weKRWGa1NgLNHT1WLDo5ohuH/statement/)。\n", "description": "有一个 $n$ 个城市的国家，我们可以将其看为一棵 $n-1$ 条道路连接的树，有一天，你突发奇想，想要派出 $k$ 个人在不同城市上。人及其移动需要满足如下条件：\n\n- 每天只能是一个人移动，移动到其相邻存在道路连接一个城市。\n\n- 假如有两个人 $a,b$，城市 $i$ 被 $a$ 到达过了，则 $b$ 不能到达 $i$ 城市。\n\n初始时你知道了人的位置，每个人初始所在地不相同，且该城市视为“已到达过”的城市，你需要安排一个合法的经过城市的方案。\n\n请你求出最少要几天才能使所有的城市都被人到达过。", "inputFormat": "第一行两个整数 $n,k\\ (1 \\leq n \\leq 5 \\times 10^5, 1 \\leq k \\leq n)$。\n\n第二行 $k$ 个数，表示那些人的初始位置。\n\n然后 $n-1$ 行，描述了每条道路 $(a_i,b_i)\\ (1 \\leq a_i,b_i \\leq n)$。", "outputFormat": "输出最少天数。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y9gojuv8.png)\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $n \\leq 10$ | $6$ |\n| $2$ | $n \\leq 20$ | $13$ |\n| $3$ | $n \\leq 2000$ | $27$ |\n| $4$ | $k=1$ | $10$ |\n| $5$ | $k=2$ | $7$ |\n| $6$ | 输入为一条链 | $7$ |\n| $7$ | 无特殊性质 | $30$ |\n\n子任务 $0$ 为样例。", "locale": "zh-CN"}}}
{"pid": "P9865", "type": "P", "difficulty": 4, "samples": [["10 3 4", "7 9 11 13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["POI（波兰）", "2021", "2022"], "title": "[POI 2021/2022 R2] lic", "background": "翻译自 [POI2021~2022R2 Day1T2](https://szkopul.edu.pl/problemset/problem/kQ5ExYNkFhx3K2FvVuXAAbn4/statement/)。", "description": "定义 $a$ 的「不友好数」$b$ 为 $\\gcd(a,b)=1$ 的数。\n\n现在你知道了数字 $n$，你需要求出它的「不友好数」升序排序第 $k$ 个开始后的 $c$ 个数。", "inputFormat": "一行，三个数 $n,k,c\\ (2 \\leq n \\leq 10^{14}, 1 \\leq k \\leq 10^{14}, 1 \\leq c \\leq 10^5)$。", "outputFormat": "输出 $c$ 个数，表示第 $k \\sim k+c-1$ 个 $n$ 的「不友好数」。", "hint": "样例解释：\n\n$10$ 的「不友好数」依次为 $1,3,7,9,11,13,17\\ldots$。\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------- | :----------- | :----------- |\n| $1$ | $n \\leq 10^6$ 且 $M \\leq n$ | $10$ |\n| $2$ | $f(n) \\leq 10^6$ 且 $M \\leq n$ | $36$ |\n| $3$ | $c \\leq 100$ | $30$ |\n| $4$ | 无特殊限制 | $24$ |\n\n上述 $M$ 为输出的最大值，$f(n)$ 为 $\\leq n$ 的「不友好数」数量。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2021/2022 R2] lic", "background": "翻译自 [POI2021~2022R2 Day1T2](https://szkopul.edu.pl/problemset/problem/kQ5ExYNkFhx3K2FvVuXAAbn4/statement/)。", "description": "定义 $a$ 的「不友好数」$b$ 为 $\\gcd(a,b)=1$ 的数。\n\n现在你知道了数字 $n$，你需要求出它的「不友好数」升序排序第 $k$ 个开始后的 $c$ 个数。", "inputFormat": "一行，三个数 $n,k,c\\ (2 \\leq n \\leq 10^{14}, 1 \\leq k \\leq 10^{14}, 1 \\leq c \\leq 10^5)$。", "outputFormat": "输出 $c$ 个数，表示第 $k \\sim k+c-1$ 个 $n$ 的「不友好数」。", "hint": "样例解释：\n\n$10$ 的「不友好数」依次为 $1,3,7,9,11,13,17\\ldots$。\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------- | :----------- | :----------- |\n| $1$ | $n \\leq 10^6$ 且 $M \\leq n$ | $10$ |\n| $2$ | $f(n) \\leq 10^6$ 且 $M \\leq n$ | $36$ |\n| $3$ | $c \\leq 100$ | $30$ |\n| $4$ | 无特殊限制 | $24$ |\n\n上述 $M$ 为输出的最大值，$f(n)$ 为 $\\leq n$ 的「不友好数」数量。", "locale": "zh-CN"}}}
{"pid": "P9866", "type": "P", "difficulty": 5, "samples": [["6\n......\n.X.##.\n..#.X.\n..X.#K\n.P#.X#\n.X....", "9\n2 3\nGGPPGPPDD\n"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200, 307200]}, "tags": ["POI（波兰）", "2021", "2022", "Special Judge"], "title": "[POI 2021/2022 R2] bom", "background": "翻译自 [POI2021~2022R2 Day2T1](https://szkopul.edu.pl/problemset/problem/MfTrGDTrlrVX21vwwhgsjaLv/statement/)。\n\n时限：sub1 和 sub4 8s，sub2 2s, sub3 3s。", "description": "你有一个 $n \\times n$ 的图，仅包含 `.`、`X`、`P`、`K`、`#`，意义如下：\n\n- `P` 起点。\n- `K` 终点。\n- `.` 可以通过的路。\n- `X` 不可以通过的岩石墙。\n- `#` 不可以通过的砖墙。\n\n你还有一枚炸弹，你选择一个不是岩石墙的地方放置，爆炸时，会从原来的地方上下左右依次扩散爆炸直到某一方向碰到了岩石墙或超出了图的范围。  \n爆炸区域变为空地，但岩石墙不会。\n\n然后你需要求出起点至终点的最短路径。", "inputFormat": "第一行一个整数 $n\\ (2 \\leq n \\leq 1000)$。\n\n然后 $n \\times n$ 大小的字符矩阵，描述了图。", "outputFormat": "如果放置完炸弹并引爆后有解，则输出三行：\n\n- 第一行：最短路径长度。\n- 第二行：放置炸弹位置。\n- 第三行：其中符合条件的最短路径（其中 `G` 表示向上，`D` 表示向下，`L` 表示向左，`P` 表示向右）。\n\n若无解，输出 `NIE`。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v7jk5v8b.png)\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | 不含砖墙 | $10$ |\n| $2$ | $n \\leq 50$ | $20$ |\n| $3$ | $n \\leq 200$ | $30$ |\n| $4$ | 无特殊限制 | $40$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2021/2022 R2] bom", "background": "翻译自 [POI2021~2022R2 Day2T1](https://szkopul.edu.pl/problemset/problem/MfTrGDTrlrVX21vwwhgsjaLv/statement/)。\n\n时限：sub1 和 sub4 8s，sub2 2s, sub3 3s。", "description": "你有一个 $n \\times n$ 的图，仅包含 `.`、`X`、`P`、`K`、`#`，意义如下：\n\n- `P` 起点。\n- `K` 终点。\n- `.` 可以通过的路。\n- `X` 不可以通过的岩石墙。\n- `#` 不可以通过的砖墙。\n\n你还有一枚炸弹，你选择一个不是岩石墙的地方放置，爆炸时，会从原来的地方上下左右依次扩散爆炸直到某一方向碰到了岩石墙或超出了图的范围。  \n爆炸区域变为空地，但岩石墙不会。\n\n然后你需要求出起点至终点的最短路径。", "inputFormat": "第一行一个整数 $n\\ (2 \\leq n \\leq 1000)$。\n\n然后 $n \\times n$ 大小的字符矩阵，描述了图。", "outputFormat": "如果放置完炸弹并引爆后有解，则输出三行：\n\n- 第一行：最短路径长度。\n- 第二行：放置炸弹位置。\n- 第三行：其中符合条件的最短路径（其中 `G` 表示向上，`D` 表示向下，`L` 表示向左，`P` 表示向右）。\n\n若无解，输出 `NIE`。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v7jk5v8b.png)\n\n子任务分配如下：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :-----------: | :-----------: | :-----------: |\n| $1$ | 不含砖墙 | $10$ |\n| $2$ | $n \\leq 50$ | $20$ |\n| $3$ | $n \\leq 200$ | $30$ |\n| $4$ | 无特殊限制 | $40$ |\n", "locale": "zh-CN"}}}
{"pid": "P9867", "type": "P", "difficulty": 7, "samples": [["7\n? 1\nZ 2\n? 1\nZ 1\nW 2\n? 2\n? 3", "1\n2\n3\n2"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["POI（波兰）", "2021", "2022"], "title": "[POI 2021/2022 R2] kon", "background": "翻译自 [POI2021~2022R2 Day2T2](https://szkopul.edu.pl/problemset/problem/TEuljz3gsotYQRUKdlEZZr1G/statement/)。\n", "description": "有一个舞会，一开始角色只有 $1$、$2$，他们两个都愿意和彼此跳舞。\n\n然后存在 $q$ 个事件，分别对应下方的操作：\n\n- `W x`：表示新加入一个人，他和编号 $x$ 的人愿意互相和对方跳舞。\n- `Z x`：表示新加入一个人，初始时他和编号为 $x$ 的人愿意跳舞的对象都互相同意跳舞。\n- `? x`：表示查询愿意与 $x$ 跳舞的有几个人。\n\n新加入的人的编号是当前人数加一。", "inputFormat": "第一行一个整数 $q\\ (1 \\leq q \\leq 10^6)$。\n\n然后 $q$ 行，每行一个字符和一个整数 $x$，含义如题目描述所述。", "outputFormat": "对应每个 `?` 操作，输出一行答案。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qvrwztvc.png)\n\n子任务分配：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $q \\leq 5000$ | $20$ |\n| $2$ | 仅包含操作 `Z` 和 `?` | $10$ |\n| $3$ | `?` 总是在 $q$ 次操作的末尾部分出现 | $35$ |\n| $4$ | 无附加限制 | $35$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2021/2022 R2] kon", "background": "翻译自 [POI2021~2022R2 Day2T2](https://szkopul.edu.pl/problemset/problem/TEuljz3gsotYQRUKdlEZZr1G/statement/)。\n", "description": "有一个舞会，一开始角色只有 $1$、$2$，他们两个都愿意和彼此跳舞。\n\n然后存在 $q$ 个事件，分别对应下方的操作：\n\n- `W x`：表示新加入一个人，他和编号 $x$ 的人愿意互相和对方跳舞。\n- `Z x`：表示新加入一个人，初始时他和编号为 $x$ 的人愿意跳舞的对象都互相同意跳舞。\n- `? x`：表示查询愿意与 $x$ 跳舞的有几个人。\n\n新加入的人的编号是当前人数加一。", "inputFormat": "第一行一个整数 $q\\ (1 \\leq q \\leq 10^6)$。\n\n然后 $q$ 行，每行一个字符和一个整数 $x$，含义如题目描述所述。", "outputFormat": "对应每个 `?` 操作，输出一行答案。", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qvrwztvc.png)\n\n子任务分配：\n\n| 子任务编号 | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $q \\leq 5000$ | $20$ |\n| $2$ | 仅包含操作 `Z` 和 `?` | $10$ |\n| $3$ | `?` 总是在 $q$ 次操作的末尾部分出现 | $35$ |\n| $4$ | 无附加限制 | $35$ |\n", "locale": "zh-CN"}}}
{"pid": "P9868", "type": "P", "difficulty": 2, "samples": [["4 7\nabandon\nbananaa\nbaannaa\nnotnotn\n", "1110"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2023", "NOIP 提高组", "O2优化"], "title": "[NOIP2023] 词典", "background": "", "description": "小 S 的词典里有 $n$ 个两两不同的、长度均为 $m$ 的单词 $w_1,w_2,\\cdots,w_n$。每个单词都是一个小写字母构成的字符串。\n\n小 S 可以做以下操作任意多次（可以不做）：选择词典中的任意一个单词，交换其中任意两个字符。\n\n对于每个 $1 \\le i \\le n$，小 S 想知道，是否可以通过以上操作得到新的 $n$ 个单词 $w'_1,w'_2,\\cdots , w'_n$，使得对于每个 $j \\neq i$，$w'_i$ 的字典序比 $w'_j$ 都要小。**对于 $n=1$ 的情况，我们约定：上述性质是自然成立的。**\n\n对于两个同样长度的字符串 $s = s_1s_2\\cdots s_L$ 和 $t = t_1t_2 \\cdots t_L$，称字符串 $s$ 字典序小于字符串 $t$，当且仅当以下条件成立：存在位置 $i$，在第 $i$ 个字符之前 $s$ 和 $t$ 都相同，而且 $s_i < t_i$，即小写字母 $s_i$ 在英文字母顺序中先于 $t_i$。", "inputFormat": "输入的第一行包含两个正整数 $n$ 和 $m$，分别表示单词个数和单词长度。\n\n接下来 $n$ 行，每行包含一个长度为 $m$ 的小写字母字符串 $w_i$， 表示一个单词。", "outputFormat": "输出一行，其中包含一个长度为 $n$ 的 `01` 字符串 $a$；对于 $1 \\le i \\le n$，如果题目描述中的性质成立，则 $a_i =$ `1`，否则 $a_i =$ `0`。", "hint": "**【样例解释 #1】**\n\n- 不做任何操作，第一个单词字典序最小，因此输出第一个字符为 `1`；\n- 交换 `bananaa` 的前两个字符以及 `abandon` 的第三个和第六个字符，得到 `abondan`, `abnanaa`, `baannaa`, `notnotn`，此时第二个单词字典序最小，因此输出第二个字符为 `1`；\n- 交换 `baannaa` 的第一个和最后一个字符得到 `aaannab`，其余字符串不变，此时第三个单词字典序最小，因此输出第三个字符为 `1`；\n- 无论如何操作，第四个单词不会小于第二个单词，因此输出第四个字符为 `0`。\n\n**【样例解释 #2】**\n\n该组样例满足测试点 $4$ 的限制。\n\n**【样例解释 #3】**\n\n该组样例满足测试点 $7$ 的限制。\n\n**【样例解释 #4】**\n\n该组样例满足测试点 $10$ 的限制。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1 \\le n \\le 3000$，$1 \\le m \\le 3000$，$w_i$ 为长度为 $m$ 的小写字母字符串且两两不同。\n\n| 测试点编号 | $n\\leq$ | $m\\leq$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $1$ | $1$ |\n| $2\\sim 4$ | $26$ | $1$ |\n| $5\\sim 7$ | $15$ | $2$ |\n| $8$ | $300$ | $300$ |\n| $9$ | $10^3$ | $10^3$ |\n| $10$ | $3000$ | $3000$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOIP2023] 词典", "background": "", "description": "小 S 的词典里有 $n$ 个两两不同的、长度均为 $m$ 的单词 $w_1,w_2,\\cdots,w_n$。每个单词都是一个小写字母构成的字符串。\n\n小 S 可以做以下操作任意多次（可以不做）：选择词典中的任意一个单词，交换其中任意两个字符。\n\n对于每个 $1 \\le i \\le n$，小 S 想知道，是否可以通过以上操作得到新的 $n$ 个单词 $w'_1,w'_2,\\cdots , w'_n$，使得对于每个 $j \\neq i$，$w'_i$ 的字典序比 $w'_j$ 都要小。**对于 $n=1$ 的情况，我们约定：上述性质是自然成立的。**\n\n对于两个同样长度的字符串 $s = s_1s_2\\cdots s_L$ 和 $t = t_1t_2 \\cdots t_L$，称字符串 $s$ 字典序小于字符串 $t$，当且仅当以下条件成立：存在位置 $i$，在第 $i$ 个字符之前 $s$ 和 $t$ 都相同，而且 $s_i < t_i$，即小写字母 $s_i$ 在英文字母顺序中先于 $t_i$。", "inputFormat": "输入的第一行包含两个正整数 $n$ 和 $m$，分别表示单词个数和单词长度。\n\n接下来 $n$ 行，每行包含一个长度为 $m$ 的小写字母字符串 $w_i$， 表示一个单词。", "outputFormat": "输出一行，其中包含一个长度为 $n$ 的 `01` 字符串 $a$；对于 $1 \\le i \\le n$，如果题目描述中的性质成立，则 $a_i =$ `1`，否则 $a_i =$ `0`。", "hint": "**【样例解释 #1】**\n\n- 不做任何操作，第一个单词字典序最小，因此输出第一个字符为 `1`；\n- 交换 `bananaa` 的前两个字符以及 `abandon` 的第三个和第六个字符，得到 `abondan`, `abnanaa`, `baannaa`, `notnotn`，此时第二个单词字典序最小，因此输出第二个字符为 `1`；\n- 交换 `baannaa` 的第一个和最后一个字符得到 `aaannab`，其余字符串不变，此时第三个单词字典序最小，因此输出第三个字符为 `1`；\n- 无论如何操作，第四个单词不会小于第二个单词，因此输出第四个字符为 `0`。\n\n**【样例解释 #2】**\n\n该组样例满足测试点 $4$ 的限制。\n\n**【样例解释 #3】**\n\n该组样例满足测试点 $7$ 的限制。\n\n**【样例解释 #4】**\n\n该组样例满足测试点 $10$ 的限制。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1 \\le n \\le 3000$，$1 \\le m \\le 3000$，$w_i$ 为长度为 $m$ 的小写字母字符串且两两不同。\n\n| 测试点编号 | $n\\leq$ | $m\\leq$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $1$ | $1$ |\n| $2\\sim 4$ | $26$ | $1$ |\n| $5\\sim 7$ | $15$ | $2$ |\n| $8$ | $300$ | $300$ |\n| $9$ | $10^3$ | $10^3$ |\n| $10$ | $3000$ | $3000$ |", "locale": "zh-CN"}}}
{"pid": "P9869", "type": "P", "difficulty": 4, "samples": [["1 3\n3 3\n- 2 1\n- 3 2\n+ 1 3\n3 3\n- 2 1\n- 3 2\n- 1 3\n2 2\nT 2\nU 2\n", "0\n3\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["并查集", "2023", "NOIP 提高组", "O2优化", "二分图", "基环树"], "title": "[NOIP2023] 三值逻辑", "background": null, "description": "小 L 今天学习了 Kleene 三值逻辑。\n\n在三值逻辑中，一个变量的值可能为：真（$\\mathit{True}$，简写作 $\\mathit{T}$）、假（$\\mathit{False}$，简写作 $\\mathit{F}$）或未确定（$\\mathit{Unknown}$，简写作 $\\mathit{U}$）。\n\n在三值逻辑上也可以定义逻辑运算。由于小 L 学习进度很慢，只掌握了逻辑非运算 $\\lnot$，其运算法则为：\n$$\\lnot \\mathit{T} = \\mathit{F}, \\lnot \\mathit{F} = \\mathit{T}, \\lnot\\mathit{U} = \\mathit{U}.$$\n\n现在小 L 有 $n$ 个三值逻辑变量 $x_1,\\cdots, x_n$。小 L 想进行一些有趣的尝试，于是他写下了 $m$ 条语句。语句有以下三种类型，其中 $\\leftarrow$ 表示赋值：\n\n1. $x_i \\leftarrow v$，其中 $v$ 为 $\\mathit{T}, \\mathit{F}, \\mathit{U}$ 的一种；\n2. $x_i \\leftarrow x_j$；\n3. $x_i \\leftarrow \\lnot x_j$。\n\n一开始，小 L 会给这些变量赋初值，然后按顺序运行这 $m$ 条语句。\n\n小 L 希望执行了所有语句后，所有变量的最终值与初值都相等。在此前提下，小 L 希望初值中 $\\mathit{Unknown}$ 的变量尽可能少。\n\n在本题中，你需要帮助小 L 找到 $\\mathit{Unknown}$ 变量个数最少的赋初值方案，使得执行了所有语句后所有变量的最终值和初始值相等。小 L 保证，至少对于本题的所有测试用例，这样的赋初值方案都必然是存在的。", "inputFormat": "**本题的测试点包含有多组测试数据。**\n\n输入的第一行包含两个整数 $c$ 和 $t$，分别表示测试点编号和测试数据组数。对于样例，$c$ 表示该样例与测试点 $c$ 拥有相同的限制条件。\n\n接下来，对于每组测试数据：\n\n- 输入的第一行包含两个整数 $n$ 和 $m$，分别表示变量个数和语句条数。\n- 接下来 $m$ 行，按运行顺序给出每条语句。\n  - 输入的第一个字符 $v$ 描述这条语句的类型。保证 $v$ 为 `TFU+-` 的其中一种。\n  - 若 $v$ 为 `TFU` 的某一种时，接下来给出一个整数 $i$，表示该语句为 $x_i \\leftarrow v$；\n  - 若 $v$ 为 `+`，接下来给出两个整数 $i,j$，表示该语句为 $x_i \\leftarrow x_j$；\n  - 若 $v$ 为 `-`，接下来给出两个整数 $i,j$，表示该语句为 $x_i \\leftarrow \\lnot x_j$。", "outputFormat": "对于每组测试数据输出一行一个整数，表示所有符合条件的赋初值方案中，$\\mathit{Unknown}$ 变量个数的最小值。", "hint": "**【样例解释 #1】**\n\n第一组测试数据中，$m$ 行语句依次为\n\n- $x_2 \\leftarrow \\lnot x_1$；\n- $x_3 \\leftarrow \\lnot x_2$；\n- $x_1 \\leftarrow x_3$。\n\n一组合法的赋初值方案为 $x_1 = \\mathit{T}, x_2 = \\mathit{F}, x_3 = \\mathit{T}$，共有 $0$ 个 $\\mathit{Unknown}$ 变量。因为不存在赋初值方案中有小于 $0$ 个 $\\mathit{Unknown}$ 变量，故输出为 $0$。\n\n第二组测试数据中，$m$ 行语句依次为\n\n- $x_2 \\leftarrow \\lnot x_1$；\n- $x_3 \\leftarrow \\lnot x_2$；\n- $x_1 \\leftarrow \\lnot x_3$。\n\n唯一的赋初值方案为 $x_1 = x_2 = x_3 = \\mathit{U}$，共有 $3$ 个 $\\mathit{Unknown}$ 变量，故输出为 $3$。\n\n第三组测试数据中，$m$ 行语句依次为\n\n- $x_2 \\leftarrow \\mathit{T}$；\n- $x_2 \\leftarrow \\mathit{U}$；\n\n一个最小化 $\\mathit{Unknown}$ 变量个数的赋初值方案为 $x_1 = \\mathit{T}, x_2 = \\mathit{U}$。$x_1 = x_2 = \\mathit{U}$ 也是一个合法的方案，但它没有最小化 $\\mathit{Unknown}$ 变量的个数。\n\n**【样例解释 #2】**\n\n该组样例满足测试点 $2$ 的条件。\n\n**【样例解释 #3】**\n\n该组样例满足测试点 $5$ 的条件。\n\n**【样例解释 #4】**\n\n该组样例满足测试点 $8$ 的条件。\n\n**【数据范围】**\n\n对于所有测试数据，保证：\n\n- $1 \\le t \\le 6$，$1 \\le n,m \\le 10 ^ 5$；\n- 对于每个操作，$v$ 为 `TFU+-` 中的某个字符，$1 \\le i,j \\le n$。\n\n| 测试点编号 | $n,m\\leq$ | $v$ 可能的取值 |\n| :----------: | :----------: | :----------: |\n| $1,2$ | $10$ | $\\mathit{TFU+-}$ |\n| $3$ | $10^3$ | $\\mathit{TFU}$ |\n| $4$ | $10^5$ | $\\mathit{TFU}$ |\n| $5$ | $10^3$ | $\\mathit{U+}$ |\n| $6$ | $10^5$ | $\\mathit{U+}$ |\n| $7$ | $10^3$ | $\\mathit{+-}$ |\n| $8$ | $10^5$ | $\\mathit{+-}$ |\n| $9$ | $10^3$ | $\\mathit{TFU+-}$ |\n| $10$ | $10^5$ | $\\mathit{TFU+-}$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOIP2023] 三值逻辑", "background": null, "description": "小 L 今天学习了 Kleene 三值逻辑。\n\n在三值逻辑中，一个变量的值可能为：真（$\\mathit{True}$，简写作 $\\mathit{T}$）、假（$\\mathit{False}$，简写作 $\\mathit{F}$）或未确定（$\\mathit{Unknown}$，简写作 $\\mathit{U}$）。\n\n在三值逻辑上也可以定义逻辑运算。由于小 L 学习进度很慢，只掌握了逻辑非运算 $\\lnot$，其运算法则为：\n$$\\lnot \\mathit{T} = \\mathit{F}, \\lnot \\mathit{F} = \\mathit{T}, \\lnot\\mathit{U} = \\mathit{U}.$$\n\n现在小 L 有 $n$ 个三值逻辑变量 $x_1,\\cdots, x_n$。小 L 想进行一些有趣的尝试，于是他写下了 $m$ 条语句。语句有以下三种类型，其中 $\\leftarrow$ 表示赋值：\n\n1. $x_i \\leftarrow v$，其中 $v$ 为 $\\mathit{T}, \\mathit{F}, \\mathit{U}$ 的一种；\n2. $x_i \\leftarrow x_j$；\n3. $x_i \\leftarrow \\lnot x_j$。\n\n一开始，小 L 会给这些变量赋初值，然后按顺序运行这 $m$ 条语句。\n\n小 L 希望执行了所有语句后，所有变量的最终值与初值都相等。在此前提下，小 L 希望初值中 $\\mathit{Unknown}$ 的变量尽可能少。\n\n在本题中，你需要帮助小 L 找到 $\\mathit{Unknown}$ 变量个数最少的赋初值方案，使得执行了所有语句后所有变量的最终值和初始值相等。小 L 保证，至少对于本题的所有测试用例，这样的赋初值方案都必然是存在的。", "inputFormat": "**本题的测试点包含有多组测试数据。**\n\n输入的第一行包含两个整数 $c$ 和 $t$，分别表示测试点编号和测试数据组数。对于样例，$c$ 表示该样例与测试点 $c$ 拥有相同的限制条件。\n\n接下来，对于每组测试数据：\n\n- 输入的第一行包含两个整数 $n$ 和 $m$，分别表示变量个数和语句条数。\n- 接下来 $m$ 行，按运行顺序给出每条语句。\n  - 输入的第一个字符 $v$ 描述这条语句的类型。保证 $v$ 为 `TFU+-` 的其中一种。\n  - 若 $v$ 为 `TFU` 的某一种时，接下来给出一个整数 $i$，表示该语句为 $x_i \\leftarrow v$；\n  - 若 $v$ 为 `+`，接下来给出两个整数 $i,j$，表示该语句为 $x_i \\leftarrow x_j$；\n  - 若 $v$ 为 `-`，接下来给出两个整数 $i,j$，表示该语句为 $x_i \\leftarrow \\lnot x_j$。", "outputFormat": "对于每组测试数据输出一行一个整数，表示所有符合条件的赋初值方案中，$\\mathit{Unknown}$ 变量个数的最小值。", "hint": "**【样例解释 #1】**\n\n第一组测试数据中，$m$ 行语句依次为\n\n- $x_2 \\leftarrow \\lnot x_1$；\n- $x_3 \\leftarrow \\lnot x_2$；\n- $x_1 \\leftarrow x_3$。\n\n一组合法的赋初值方案为 $x_1 = \\mathit{T}, x_2 = \\mathit{F}, x_3 = \\mathit{T}$，共有 $0$ 个 $\\mathit{Unknown}$ 变量。因为不存在赋初值方案中有小于 $0$ 个 $\\mathit{Unknown}$ 变量，故输出为 $0$。\n\n第二组测试数据中，$m$ 行语句依次为\n\n- $x_2 \\leftarrow \\lnot x_1$；\n- $x_3 \\leftarrow \\lnot x_2$；\n- $x_1 \\leftarrow \\lnot x_3$。\n\n唯一的赋初值方案为 $x_1 = x_2 = x_3 = \\mathit{U}$，共有 $3$ 个 $\\mathit{Unknown}$ 变量，故输出为 $3$。\n\n第三组测试数据中，$m$ 行语句依次为\n\n- $x_2 \\leftarrow \\mathit{T}$；\n- $x_2 \\leftarrow \\mathit{U}$；\n\n一个最小化 $\\mathit{Unknown}$ 变量个数的赋初值方案为 $x_1 = \\mathit{T}, x_2 = \\mathit{U}$。$x_1 = x_2 = \\mathit{U}$ 也是一个合法的方案，但它没有最小化 $\\mathit{Unknown}$ 变量的个数。\n\n**【样例解释 #2】**\n\n该组样例满足测试点 $2$ 的条件。\n\n**【样例解释 #3】**\n\n该组样例满足测试点 $5$ 的条件。\n\n**【样例解释 #4】**\n\n该组样例满足测试点 $8$ 的条件。\n\n**【数据范围】**\n\n对于所有测试数据，保证：\n\n- $1 \\le t \\le 6$，$1 \\le n,m \\le 10 ^ 5$；\n- 对于每个操作，$v$ 为 `TFU+-` 中的某个字符，$1 \\le i,j \\le n$。\n\n| 测试点编号 | $n,m\\leq$ | $v$ 可能的取值 |\n| :----------: | :----------: | :----------: |\n| $1,2$ | $10$ | $\\mathit{TFU+-}$ |\n| $3$ | $10^3$ | $\\mathit{TFU}$ |\n| $4$ | $10^5$ | $\\mathit{TFU}$ |\n| $5$ | $10^3$ | $\\mathit{U+}$ |\n| $6$ | $10^5$ | $\\mathit{U+}$ |\n| $7$ | $10^3$ | $\\mathit{+-}$ |\n| $8$ | $10^5$ | $\\mathit{+-}$ |\n| $9$ | $10^3$ | $\\mathit{TFU+-}$ |\n| $10$ | $10^5$ | $\\mathit{TFU+-}$ |", "locale": "zh-CN"}}}
{"pid": "P9870", "type": "P", "difficulty": 6, "samples": [["3 3 3 3\n8 6 9\n1 7 4\n1 0\n3 0\n0 2\n1 8\n3 5\n1 1\n2 8\n1 7\n", "1001"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "贪心", "2023", "NOIP 提高组", "O2优化", "Ad-hoc"], "title": "[NOIP2023] 双序列拓展", "background": "", "description": "称某个序列 $B = \\{b_1,b_2,\\cdots,b_n\\}$ 是另一个序列 $A = \\{a_1,a_2,\\cdots,a_m\\}$ 的**拓展**当且仅当存在**正整数**序列 $L = \\{l_1,l_2,\\cdots,l_m\\}$，将 $a_i$ 替换为 $l_i$ 个 $a_i$ 后得到序列 $B$。例如，\n\n- $\\{1,3,3,3,2,2,2\\}$ 是 $\\{1,3,3,2\\}$ 的拓展，取 $L = \\{1,1,2,3\\}$ 或 $\\{1,2,1,3\\}$；\n- 而 $\\{1,3,3,2\\}$ 不是 $\\{1,3,3,3,2\\}$ 的拓展，$\\{1,2,3\\}$ 不是 $\\{1,3,2\\}$ 的拓展。\n\n小 R 给了你两个序列 $X$ 和 $Y$，他希望你找到 $X$ 的一个长度为 $l_0 = 10^{100}$ 的拓展 $F = \\{f_i\\}$ 以及 $Y$ 的一个长度为 $l_0$ 的拓展 $G = \\{g_i\\}$，使得任意 $1 \\le i , j \\le l_0$ 都有 $(f_i - g_i)(f_j - g_j) > 0$。由于序列太长，你只需要告诉小 R 是否存在这样的两个序列即可。\n\n为了避免你扔硬币蒙混过关，小 R 还给了 $q$ 次额外询问，每次额外询问中小 R 会修改 $X$ 和 $Y$ 中若干元素的值。你需要对每次得到的新的 $X$ 和 $Y$ 都进行上述的判断。\n\n**询问之间是独立的，每次询问中涉及的修改均在原始序列上完成。**", "inputFormat": "输入的第一行包含四个整数 $c, n, m, q$，分别表示测试点编号、序列 $X$ 的长度、序列 $Y$ 的长度和额外询问的个数。对于样例，$c$ 表示该样例与测试点 $c$ 拥有相同的限制条件。\n\n输入的第二行包含 $n$ 个整数 $x_1,x_2,\\cdots, x_n$，描述序列 $X$。\n\n输入的第三行包含 $m$ 个整数 $y_1,y_2,\\cdots, y_m$，描述序列 $Y$。\n\n接下来依次描述 $q$ 组额外询问。对于每组额外询问：\n\n- 输入的第一行包含两个整数 $k_x$ 和 $k_y$，分别表示对序列 $X$ 和 $Y$ 产生的修改个数。\n- 接下来 $k_x$ 行每行包含两个整数 $p_x, v_x$，表示将 $x_{p_x}$ 修改为 $v_x$。\n- 接下来 $k_y$ 行每行包含两个整数 $p_y, v_y$，表示将 $y_{p_y}$ 修改为 $v_y$。", "outputFormat": "输出一行，其中包含一个长度为 $(q+1)$ 的 `01` 序列，序列的第一个元素表示初始询问的答案，之后 $q$ 个元素依次表示每组额外询问的答案。对于每个询问，如果存在满足题目条件的序列 $F$ 和 $G$，输出 `1`，否则输出 `0`。", "hint": "**【样例解释 #1】**\n\n由于 $F$ 和 $G$ 太长，用省略号表示重复最后一个元素直到序列长度为 $l_0$。如 $\\{1,2,3,3,\\cdots\\}$ 表示序列从第三个元素之后都是 $3$。\n\n以下依次描述四次询问，其中第一次询问为初始询问，之后的三次为额外询问：\n\n1. $A = \\{8,6,9\\}$，$B = \\{1,7,4\\}$，取 $F = \\{8,8,6,9,\\cdots\\}, G = \\{1,7,4,4,\\cdots\\}$；\n2. $A = \\{8,6,0\\}$，$B = \\{1,7,4\\}$，可以证明不存在满足要求的方案；\n3. $A = \\{8,6,9\\}$，$B = \\{8,7,5\\}$，可以证明不存在满足要求的方案；\n4. $A = \\{8,8,9\\}$，$B = \\{7,7,4\\}$，取 $F = \\{8,8,9,\\cdots\\}, G = \\{7,7,4,\\cdots\\}$。\n\n**【样例解释 #2】**\n\n该组样例满足测试点 $4$ 的条件。\n\n**【样例解释 #3】**\n\n该组样例满足测试点 $7$ 的条件。\n\n**【样例解释 #4】**\n\n该组样例满足测试点 $9$ 的条件。\n\n**【样例解释 #5】**\n\n该组样例满足测试点 $18$ 的条件。\n\n**【数据范围】**\n\n对于所有测试数据，保证：\n\n- $1 \\le n, m \\le 5 \\times 10 ^ 5$；\n- $0 \\le q \\le 60$；\n- $0 \\le x_i, y_i < 10 ^ 9$；\n- $0 \\le k_x, k_y \\le 5 \\times 10 ^ 5$，且所有额外询问的 $(k_x+k_y)$ 的和不超过 $5 \\times 10 ^ 5$；\n- $1 \\le p_x \\le n$，$1 \\le p_y \\le m$，$0 \\le v_x, v_y < 10 ^ 9$；\n- 对于每组额外询问，$p_x$ 两两不同，$p_y$ 两两不同。\n\n|测试点编号|$n, m \\le$|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$1$|否|\n|$2$|$2$|否|\n|$3, 4$|$6$|否|\n|$5$|$200$|否|\n|$6, 7$|$2000$|否|\n|$8, 9$|$4 \\times 10 ^ 4$|是|\n|$10, 11$|$1.5 \\times 10 ^ 5$|是|\n|$12 \\sim 14$|$5 \\times 10 ^ 5$|是|\n|$15, 16$|$4 \\times 10 ^ 4$|否|\n|$17, 18$|$1.5 \\times 10 ^ 5$|否|\n|$19, 20$|$5 \\times 10 ^ 5$|否|\n\n特殊性质：对于每组询问（包括初始询问和额外询问），保证 $x_1 < y_1$，且 $x_n$ 是序列 $X$ 唯一的一个最小值，$y_m$ 是序列 $Y$ 唯一的一个最大值。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOIP2023] 双序列拓展", "background": "", "description": "称某个序列 $B = \\{b_1,b_2,\\cdots,b_n\\}$ 是另一个序列 $A = \\{a_1,a_2,\\cdots,a_m\\}$ 的**拓展**当且仅当存在**正整数**序列 $L = \\{l_1,l_2,\\cdots,l_m\\}$，将 $a_i$ 替换为 $l_i$ 个 $a_i$ 后得到序列 $B$。例如，\n\n- $\\{1,3,3,3,2,2,2\\}$ 是 $\\{1,3,3,2\\}$ 的拓展，取 $L = \\{1,1,2,3\\}$ 或 $\\{1,2,1,3\\}$；\n- 而 $\\{1,3,3,2\\}$ 不是 $\\{1,3,3,3,2\\}$ 的拓展，$\\{1,2,3\\}$ 不是 $\\{1,3,2\\}$ 的拓展。\n\n小 R 给了你两个序列 $X$ 和 $Y$，他希望你找到 $X$ 的一个长度为 $l_0 = 10^{100}$ 的拓展 $F = \\{f_i\\}$ 以及 $Y$ 的一个长度为 $l_0$ 的拓展 $G = \\{g_i\\}$，使得任意 $1 \\le i , j \\le l_0$ 都有 $(f_i - g_i)(f_j - g_j) > 0$。由于序列太长，你只需要告诉小 R 是否存在这样的两个序列即可。\n\n为了避免你扔硬币蒙混过关，小 R 还给了 $q$ 次额外询问，每次额外询问中小 R 会修改 $X$ 和 $Y$ 中若干元素的值。你需要对每次得到的新的 $X$ 和 $Y$ 都进行上述的判断。\n\n**询问之间是独立的，每次询问中涉及的修改均在原始序列上完成。**", "inputFormat": "输入的第一行包含四个整数 $c, n, m, q$，分别表示测试点编号、序列 $X$ 的长度、序列 $Y$ 的长度和额外询问的个数。对于样例，$c$ 表示该样例与测试点 $c$ 拥有相同的限制条件。\n\n输入的第二行包含 $n$ 个整数 $x_1,x_2,\\cdots, x_n$，描述序列 $X$。\n\n输入的第三行包含 $m$ 个整数 $y_1,y_2,\\cdots, y_m$，描述序列 $Y$。\n\n接下来依次描述 $q$ 组额外询问。对于每组额外询问：\n\n- 输入的第一行包含两个整数 $k_x$ 和 $k_y$，分别表示对序列 $X$ 和 $Y$ 产生的修改个数。\n- 接下来 $k_x$ 行每行包含两个整数 $p_x, v_x$，表示将 $x_{p_x}$ 修改为 $v_x$。\n- 接下来 $k_y$ 行每行包含两个整数 $p_y, v_y$，表示将 $y_{p_y}$ 修改为 $v_y$。", "outputFormat": "输出一行，其中包含一个长度为 $(q+1)$ 的 `01` 序列，序列的第一个元素表示初始询问的答案，之后 $q$ 个元素依次表示每组额外询问的答案。对于每个询问，如果存在满足题目条件的序列 $F$ 和 $G$，输出 `1`，否则输出 `0`。", "hint": "**【样例解释 #1】**\n\n由于 $F$ 和 $G$ 太长，用省略号表示重复最后一个元素直到序列长度为 $l_0$。如 $\\{1,2,3,3,\\cdots\\}$ 表示序列从第三个元素之后都是 $3$。\n\n以下依次描述四次询问，其中第一次询问为初始询问，之后的三次为额外询问：\n\n1. $A = \\{8,6,9\\}$，$B = \\{1,7,4\\}$，取 $F = \\{8,8,6,9,\\cdots\\}, G = \\{1,7,4,4,\\cdots\\}$；\n2. $A = \\{8,6,0\\}$，$B = \\{1,7,4\\}$，可以证明不存在满足要求的方案；\n3. $A = \\{8,6,9\\}$，$B = \\{8,7,5\\}$，可以证明不存在满足要求的方案；\n4. $A = \\{8,8,9\\}$，$B = \\{7,7,4\\}$，取 $F = \\{8,8,9,\\cdots\\}, G = \\{7,7,4,\\cdots\\}$。\n\n**【样例解释 #2】**\n\n该组样例满足测试点 $4$ 的条件。\n\n**【样例解释 #3】**\n\n该组样例满足测试点 $7$ 的条件。\n\n**【样例解释 #4】**\n\n该组样例满足测试点 $9$ 的条件。\n\n**【样例解释 #5】**\n\n该组样例满足测试点 $18$ 的条件。\n\n**【数据范围】**\n\n对于所有测试数据，保证：\n\n- $1 \\le n, m \\le 5 \\times 10 ^ 5$；\n- $0 \\le q \\le 60$；\n- $0 \\le x_i, y_i < 10 ^ 9$；\n- $0 \\le k_x, k_y \\le 5 \\times 10 ^ 5$，且所有额外询问的 $(k_x+k_y)$ 的和不超过 $5 \\times 10 ^ 5$；\n- $1 \\le p_x \\le n$，$1 \\le p_y \\le m$，$0 \\le v_x, v_y < 10 ^ 9$；\n- 对于每组额外询问，$p_x$ 两两不同，$p_y$ 两两不同。\n\n|测试点编号|$n, m \\le$|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$1$|否|\n|$2$|$2$|否|\n|$3, 4$|$6$|否|\n|$5$|$200$|否|\n|$6, 7$|$2000$|否|\n|$8, 9$|$4 \\times 10 ^ 4$|是|\n|$10, 11$|$1.5 \\times 10 ^ 5$|是|\n|$12 \\sim 14$|$5 \\times 10 ^ 5$|是|\n|$15, 16$|$4 \\times 10 ^ 4$|否|\n|$17, 18$|$1.5 \\times 10 ^ 5$|否|\n|$19, 20$|$5 \\times 10 ^ 5$|否|\n\n特殊性质：对于每组询问（包括初始询问和额外询问），保证 $x_1 < y_1$，且 $x_n$ 是序列 $X$ 唯一的一个最小值，$y_m$ 是序列 $Y$ 唯一的一个最大值。", "locale": "zh-CN"}}}
{"pid": "P9871", "type": "P", "difficulty": 6, "samples": [["1 1\n3 2 2 1\n2 2 4\n3 2 3\n", "2\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "线段树", "2023", "离散化", "NOIP 提高组", "O2优化", "动态规划优化"], "title": "[NOIP2023] 天天爱打卡", "background": "", "description": "小 T 同学非常热衷于跑步。为了让跑步更加有趣，他决定制作一款叫做《天天爱打卡》的软件，使得用户每天都可以进行跑步打卡。\n\n开发完成后，小 T 同学计划进行试运行，他找了大 Y 同学来帮忙。试运行共 $n$ 天，编号为从 $1$ 到 $n$。\n\n对大 Y 同学来说，如果某天他选择跑步打卡，那么他的能量值会减少 $d$。初始时，他的能量值是 $0$，并且试运行期间他的**能量值可以是负数**。\n\n而且大 Y 不会**连续**跑步打卡**超过** $k$ 天；即不能存在 $1\\le x\\le n-k$，使得他在第 $x$ 到第 $x+k$ 天均进行了跑步打卡。\n\n小 T 同学在软件中设计了 $m$ 个挑战，第 $i$（$1\\le i \\le m$）个挑战可以用三个正整数 $(x_i,y_i,v_i)$ 描述，表示如果在第 $x_i$ 天时，用户已经连续跑步打卡至少 $y_i$ 天（即第 $x_i-y_i+1$ 到第 $x_i$ 天均完成了跑步打卡），那么小 T 同学就会请用户吃饭，从而使用户的能量值提高 $v_i$。\n\n现在大 Y 想知道，在软件试运行的 $n$ 天结束后，他的能量值**最高**可以达到多少？", "inputFormat": "**本题的测试点包含有多组测试数据。**\n\n输入的第一行包含两个整数 $c$ 和 $t$，分别表示测试点编号和测试数据组数。对于样例，$c$ 表示该样例与测试点 $c$ 拥有相同的限制条件。\n\n接下来，对于每组测试数据：\n\n- 输入的第一行包含四个正整数 $n,m,k,d$，分别表示试运行的天数、挑战的个数、大 Y 单次跑步打卡的连续天数限制以及大 Y 跑步打卡减少的能量值。\n- 接下来 $m$ 行，每行包含三个正整数 $x_i,y_i,v_i$，表示一次挑战。", "outputFormat": "输出一行一个整数表示对应的答案。", "hint": "**【样例解释 #1】**\n\n在第 $1,2$ 天跑步打卡，第 $3$ 天不跑步打卡，最终会获得 $(-1)+(-1)+4=2$ 的能量值。\n\n**【样例解释 #2】**\n\n该组样例满足测试点 $3$ 的条件。\n\n**【样例解释 #3】**\n\n该组样例满足测试点 $5$ 的条件。\n\n**【样例解释 #4】**\n\n该组样例满足测试点 $15$ 的条件。\n\n**【样例解释 #5】**\n\n该组样例满足测试点 $17$ 的条件。\n\n**【样例解释 #6】**\n\n该组样例满足测试点 $19$ 的条件。\n\n**【数据范围】**\n\n记 $l_i=x_i-y_i+1$，$r_i=x_i$​；\n\n对于所有测试数据，保证：$1\\le t\\le 10$，$1\\le k\\le n\\le 10^9$，$1\\le m\\le 10^5$，$1\\le l_i\\le r_i\\le n$，$1\\le d,v_i\\le 10^9$。\n\n|测试点编号|$n \\le$|$m \\le$|特殊性质|\n|:-:|:-:|:-:|:-:|\n|$1, 2$|$18$|$10 ^ 2$|无|\n|$3, 4$|$10 ^ 2$|$10 ^ 2$|无|\n|$5 \\sim 7$|$10 ^ 3$|$10 ^ 3$|无|\n|$8, 9$|$10 ^ 3$|$10 ^ 5$|无|\n|$10, 11$|$10 ^ 5$|$10 ^ 3$|无|\n|$12 \\sim 14$|$10 ^ 5$|$10 ^ 5$|无|\n|$15, 16$|$10 ^ 9$|$10 ^ 5$|A|\n|$17, 18$|$10 ^ 9$|$10 ^ 5$|B|\n|$19 \\sim 21$|$10 ^ 9$|$10 ^ 5$|C|\n|$22 \\sim 25$|$10 ^ 9$|$10 ^ 5$|无|\n\n特殊性质 A：$k\\le 10^2$；\n\n特殊性质 B：$\\forall 1\\le i<m$，$r_i<l_{i+1}$；\n\n特殊性质 C：$\\forall 1\\le i<j\\le m$，$l_i<l_j$，$r_i<r_j$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOIP2023] 天天爱打卡", "background": "", "description": "小 T 同学非常热衷于跑步。为了让跑步更加有趣，他决定制作一款叫做《天天爱打卡》的软件，使得用户每天都可以进行跑步打卡。\n\n开发完成后，小 T 同学计划进行试运行，他找了大 Y 同学来帮忙。试运行共 $n$ 天，编号为从 $1$ 到 $n$。\n\n对大 Y 同学来说，如果某天他选择跑步打卡，那么他的能量值会减少 $d$。初始时，他的能量值是 $0$，并且试运行期间他的**能量值可以是负数**。\n\n而且大 Y 不会**连续**跑步打卡**超过** $k$ 天；即不能存在 $1\\le x\\le n-k$，使得他在第 $x$ 到第 $x+k$ 天均进行了跑步打卡。\n\n小 T 同学在软件中设计了 $m$ 个挑战，第 $i$（$1\\le i \\le m$）个挑战可以用三个正整数 $(x_i,y_i,v_i)$ 描述，表示如果在第 $x_i$ 天时，用户已经连续跑步打卡至少 $y_i$ 天（即第 $x_i-y_i+1$ 到第 $x_i$ 天均完成了跑步打卡），那么小 T 同学就会请用户吃饭，从而使用户的能量值提高 $v_i$。\n\n现在大 Y 想知道，在软件试运行的 $n$ 天结束后，他的能量值**最高**可以达到多少？", "inputFormat": "**本题的测试点包含有多组测试数据。**\n\n输入的第一行包含两个整数 $c$ 和 $t$，分别表示测试点编号和测试数据组数。对于样例，$c$ 表示该样例与测试点 $c$ 拥有相同的限制条件。\n\n接下来，对于每组测试数据：\n\n- 输入的第一行包含四个正整数 $n,m,k,d$，分别表示试运行的天数、挑战的个数、大 Y 单次跑步打卡的连续天数限制以及大 Y 跑步打卡减少的能量值。\n- 接下来 $m$ 行，每行包含三个正整数 $x_i,y_i,v_i$，表示一次挑战。", "outputFormat": "输出一行一个整数表示对应的答案。", "hint": "**【样例解释 #1】**\n\n在第 $1,2$ 天跑步打卡，第 $3$ 天不跑步打卡，最终会获得 $(-1)+(-1)+4=2$ 的能量值。\n\n**【样例解释 #2】**\n\n该组样例满足测试点 $3$ 的条件。\n\n**【样例解释 #3】**\n\n该组样例满足测试点 $5$ 的条件。\n\n**【样例解释 #4】**\n\n该组样例满足测试点 $15$ 的条件。\n\n**【样例解释 #5】**\n\n该组样例满足测试点 $17$ 的条件。\n\n**【样例解释 #6】**\n\n该组样例满足测试点 $19$ 的条件。\n\n**【数据范围】**\n\n记 $l_i=x_i-y_i+1$，$r_i=x_i$​；\n\n对于所有测试数据，保证：$1\\le t\\le 10$，$1\\le k\\le n\\le 10^9$，$1\\le m\\le 10^5$，$1\\le l_i\\le r_i\\le n$，$1\\le d,v_i\\le 10^9$。\n\n|测试点编号|$n \\le$|$m \\le$|特殊性质|\n|:-:|:-:|:-:|:-:|\n|$1, 2$|$18$|$10 ^ 2$|无|\n|$3, 4$|$10 ^ 2$|$10 ^ 2$|无|\n|$5 \\sim 7$|$10 ^ 3$|$10 ^ 3$|无|\n|$8, 9$|$10 ^ 3$|$10 ^ 5$|无|\n|$10, 11$|$10 ^ 5$|$10 ^ 3$|无|\n|$12 \\sim 14$|$10 ^ 5$|$10 ^ 5$|无|\n|$15, 16$|$10 ^ 9$|$10 ^ 5$|A|\n|$17, 18$|$10 ^ 9$|$10 ^ 5$|B|\n|$19 \\sim 21$|$10 ^ 9$|$10 ^ 5$|C|\n|$22 \\sim 25$|$10 ^ 9$|$10 ^ 5$|无|\n\n特殊性质 A：$k\\le 10^2$；\n\n特殊性质 B：$\\forall 1\\le i<m$，$r_i<l_{i+1}$；\n\n特殊性质 C：$\\forall 1\\le i<j\\le m$，$l_i<l_j$，$r_i<r_j$。", "locale": "zh-CN"}}}
{"pid": "P9872", "type": "P", "difficulty": 2, "samples": [["2\n4\n1 2\n2 3\n3 4\n5\n1 2\n2 3\n2 4\n1 5", "1 1\n2 2\n3 3\n4 4\n1 1\n2 3\n3 5\n3 5\n2 5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "O2优化", "深度优先搜索 DFS", "树的遍历", "ICPC", "EC Final"], "title": "[EC Final 2021] DFS Order", "background": "", "description": "Prof. Pang has a rooted tree which is rooted at $1$ with $n$ nodes. These $n$ nodes are numbered from $1$ to $n$.\n\nNow he wants to start the depth-first search at the root. He wonders for each node $v$, what is the minimum and the maximum position it can appear in the $\\textbf{depth-first search order}$. The depth-first search order is the order of nodes visited during the depth-first search. A node appears in the $j$-th ($1\\le j\\le n$) position in this order means it is visited after $j-1$ other nodes. Because sons of a node can be iterated in arbitrary order, multiple possible depth-first orders exist. Prof. Pang wants to know for each node $v$, what are the minimum value and the maximum value of $j$ such that $v$ appears in the $j$-th position.\n\nFollowing is a pseudo-code for the depth-first search on a rooted tree. After its execution, $\\texttt{dfs\\_order}$ is the depth-first search order.\n\n```\nlet dfs_order be an empty list\n\ndef dfs(vertex x):\n    append x to the end of dfs_order.\n    for (each son y of x): // sons can be iterated in arbitrary order.\n        dfs(y)\n\ndfs(root)\n```", "inputFormat": "The first line contains a single integer $T~(1 \\le T \\le 10^6)$ denoting the number of test cases.\n\nFor each test case, the first line contains an integer $n~(1 \\le n \\le 10 ^ 5)$. Each of the next $n-1$ lines contains two integers $x$ and $y$, indicating node $x$ is node $y$'s parent ($1\\le x, y\\le n$). These edges form a tree rooted at $1$.\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $10^6$.", "outputFormat": "For each test case, print $n$ lines. The $i$-th line contains two integers denoting the minimum and the maximum position node $i$ can appear in the depth-first search order.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2021] DFS Order", "background": "", "description": "Prof. Pang has a rooted tree which is rooted at $1$ with $n$ nodes. These $n$ nodes are numbered from $1$ to $n$.\n\nNow he wants to start the depth-first search at the root. He wonders for each node $v$, what is the minimum and the maximum position it can appear in the $\\textbf{depth-first search order}$. The depth-first search order is the order of nodes visited during the depth-first search. A node appears in the $j$-th ($1\\le j\\le n$) position in this order means it is visited after $j-1$ other nodes. Because sons of a node can be iterated in arbitrary order, multiple possible depth-first orders exist. Prof. Pang wants to know for each node $v$, what are the minimum value and the maximum value of $j$ such that $v$ appears in the $j$-th position.\n\nFollowing is a pseudo-code for the depth-first search on a rooted tree. After its execution, $\\texttt{dfs\\_order}$ is the depth-first search order.\n\n```\nlet dfs_order be an empty list\n\ndef dfs(vertex x):\n    append x to the end of dfs_order.\n    for (each son y of x): // sons can be iterated in arbitrary order.\n        dfs(y)\n\ndfs(root)\n```", "inputFormat": "The first line contains a single integer $T~(1 \\le T \\le 10^6)$ denoting the number of test cases.\n\nFor each test case, the first line contains an integer $n~(1 \\le n \\le 10 ^ 5)$. Each of the next $n-1$ lines contains two integers $x$ and $y$, indicating node $x$ is node $y$'s parent ($1\\le x, y\\le n$). These edges form a tree rooted at $1$.\n\nIt is guaranteed that the sum of $n$ over all test cases is no more than $10^6$.", "outputFormat": "For each test case, print $n$ lines. The $i$-th line contains two integers denoting the minimum and the maximum position node $i$ can appear in the depth-first search order.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2021] DFS Order", "background": "", "description": "庞教授有一棵以 $1$ 为根的树，这棵树有 $n$ 个节点。这 $n$ 个节点的编号从 $1$ 到 $n$。\n\n现在他想从根节点开始进行深度优先搜索。他想知道对于每个节点 $v$，它在深度优先搜索顺序中出现的最小和最大位置。深度优先搜索顺序是指在深度优先搜索过程中访问节点的顺序。一个节点出现在这个顺序中的第 $j$ 个位置（$1 \\le j \\le n$）意味着它是在 $j-1$ 个其他节点之后被访问的。由于一个节点的子节点可以以任意顺序进行迭代，因此存在多种可能的深度优先顺序。庞教授想知道对于每个节点 $v$，使得 $v$ 出现在第 $j$ 个位置的最小值和最大值分别是多少。\n\n以下是对根树进行深度优先搜索的伪代码。在其执行之后，$\\texttt{dfs\\_order}$ 是深度优先搜索顺序。\n\n```\nlet dfs_order be an empty list\n\ndef dfs(vertex x):\n    append x to the end of dfs_order.\n    for (each son y of x): // sons can be iterated in arbitrary order.\n        dfs(y)\n\ndfs(root)\n```", "inputFormat": "第一行包含一个整数 $T~(1 \\le T \\le 10^6)$，表示测试用例的数量。\n\n对于每个测试用例，第一行包含一个整数 $n~(1 \\le n \\le 10 ^ 5)$。接下来的 $n-1$ 行中的每一行包含两个整数 $x$ 和 $y$，表示节点 $x$ 是节点 $y$ 的父节点（$1\\le x, y\\le n$）。这些边形成了一棵以 $1$ 为根的树。\n\n保证所有测试用例中 $n$ 的总和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出 $n$ 行。第 $i$ 行包含两个整数，表示节点 $i$ 在深度优先搜索顺序中出现的最小和最大位置。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9873", "type": "P", "difficulty": 5, "samples": [["2\n114514\n0000000", "1\n3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["字符串", "2021", "O2优化", "ICPC", "EC Final"], "title": "[EC Final 2021] Beautiful String", "background": "", "description": "Prof. Pang recently got a dictionary of the elvish language, including many strings representing their words. He thinks a partition of string $s$ is beautiful if both of the following conditions are satisfied:\n\n- $s = s_1 + s_2 + s_3 + s_4 + s_5 + s_6$, where $s_i (1\\leq i\\leq 6)$ are nonempty substrings. $a + b$ means the concatenation of string $a$ and $b$ here.\n- $s_1 = s_2 = s_5, s_3 = s_6$.\n\n\nFor example, you can partition the string ``114514`` into $6$ parts : ``114514`` = ``1`` + ``1`` + ``4`` + ``5`` + ``1`` + ``4``. The first, second, fifth parts are the same, and the third and sixth parts are the same. Thus, the partition of $s=$``114514`` into $s_1=$``1``, $s_2=$``1``, $s_3=$``4``, $s_4=$``5``, $s_5=$``1``, and $s_6=$``4`` is beautiful. \n\nAccordingly, the beauty of a string $s$ is defined as the number of beautiful partitions of $s$.\n\nGiven a string $t$, please help Prof. Pang to figure out the sum of beauties of all substrings of $t$.\n", "inputFormat": "The first line contains a single integer $T~(1\\leq T \\le 50)$ indicating the number of test cases. \n\nFor each test case, there is one single line containing the string $t$, consisting of digits from `0' to `9'.\n\nIt is guaranteed that the length of each $t$ in each test case will not exceed $5000$ and the total length will not exceed $30000$.", "outputFormat": "For each test case, output a single line containing an integer, indicating the sum of beauties of all substrings of $t$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2021] Beautiful String", "background": "", "description": "Prof. Pang recently got a dictionary of the elvish language, including many strings representing their words. He thinks a partition of string $s$ is beautiful if both of the following conditions are satisfied:\n\n- $s = s_1 + s_2 + s_3 + s_4 + s_5 + s_6$, where $s_i (1\\leq i\\leq 6)$ are nonempty substrings. $a + b$ means the concatenation of string $a$ and $b$ here.\n- $s_1 = s_2 = s_5, s_3 = s_6$.\n\n\nFor example, you can partition the string ``114514`` into $6$ parts : ``114514`` = ``1`` + ``1`` + ``4`` + ``5`` + ``1`` + ``4``. The first, second, fifth parts are the same, and the third and sixth parts are the same. Thus, the partition of $s=$``114514`` into $s_1=$``1``, $s_2=$``1``, $s_3=$``4``, $s_4=$``5``, $s_5=$``1``, and $s_6=$``4`` is beautiful. \n\nAccordingly, the beauty of a string $s$ is defined as the number of beautiful partitions of $s$.\n\nGiven a string $t$, please help Prof. Pang to figure out the sum of beauties of all substrings of $t$.\n", "inputFormat": "The first line contains a single integer $T~(1\\leq T \\le 50)$ indicating the number of test cases. \n\nFor each test case, there is one single line containing the string $t$, consisting of digits from `0' to `9'.\n\nIt is guaranteed that the length of each $t$ in each test case will not exceed $5000$ and the total length will not exceed $30000$.", "outputFormat": "For each test case, output a single line containing an integer, indicating the sum of beauties of all substrings of $t$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2021] Beautiful String", "background": "", "description": "庞教授最近获得了一本精灵语言的字典，其中包含许多表示他们单词的字符串。他认为字符串 $s$ 的一个划分是美丽的，如果满足以下两个条件：\n\n- $s = s_1 + s_2 + s_3 + s_4 + s_5 + s_6$，其中 $s_i (1\\leq i\\leq 6)$ 是非空子字符串。这里 $a + b$ 表示字符串 $a$ 和 $b$ 的连接。\n- $s_1 = s_2 = s_5, s_3 = s_6$。\n\n例如，你可以将字符串 \"114514\" 划分为 6 部分：\"114514\" = \"1\" + \"1\" + \"4\" + \"5\" + \"1\" + \"4\"。第一、第二、第五部分相同，第三和第六部分相同。因此，将 $s=$\"114514\" 划分为 $s_1=$\"1\"，$s_2=$\"1\"，$s_3=$\"4\"，$s_4=$\"5\"，$s_5=$\"1\"，和 $s_6=$\"4\" 是美丽的。\n\n因此，字符串 $s$ 的美丽定义为 $s$ 的美丽划分的数量。\n\n给定一个字符串 $t$，请帮助庞教授计算 $t$ 的所有子串的美丽之和。", "inputFormat": "第一行包含一个整数 $T~(1\\leq T \\le 50)$，表示测试用例的数量。\n\n对于每个测试用例，有一行包含字符串 $t$，由数字 '0' 到 '9' 组成。\n\n保证每个测试用例中每个 $t$ 的长度不超过 $5000$，且总长度不超过 $30000$。", "outputFormat": "对于每个测试用例，输出一个整数，表示 $t$ 的所有子串的美丽之和。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9874", "type": "P", "difficulty": 6, "samples": [["2 5\nCRANE\nxx--x\nNASAL\nOOxOO", "21"], ["1 5\nBBBAA\nxxxx-", "0"], ["2 5\nABCDE\n-xxxx\nABCDE\nxxxxx", "0"], ["1 3\nABC\n---", "2"], ["1 15\nAAAAAAAAAAAAAAB\n-xxxxxxxxxxxxxx", "918547951"], ["1 15\nAAAAAAAAAAAAAAA\n-xxxxxxxxxxxxxx", "0"], ["1 1\nK\nx", "25"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2021", "O2优化", "ICPC", "EC Final"], "title": "[EC Final 2021] String-dle Count", "background": "", "description": "While most people love to play Wordle these days, Prof. Pang has become addicted to String-dle.\n\nString-dle is an interesting string-guessing game where the player tries to guess a string of $k$ capital letters through several rounds. In each round, the player submits a string of length $k$ as his guess, and the system grades the guess through the following pseudo-code:\n\n```\ndef grading(answer, guess):\n  let count be a hash map\n  for i = 1 to k:\n    if answer[i] not in count:\n      count[answer[i]] = 1\n    else:\n      count[answer[i]] = count[answer[i]] + 1\n  let grade be an array of length k\n  for i = 1 to k:\n    if answer[i] == guess[i]:\n      grade[i] = 'O'\n      count[guess[i]] = count[guess[i]] - 1\n  for i = 1 to k:\n    if answer[i] != guess[i]:\n      if count[guess[i]] > 0:\n        grade[i] = '-'\n        count[guess[i]] = count[guess[i]] - 1\n      else:\n        grade[i] = 'x'\n  return grade\n```\n\nThe grade consisting of $\\tt{O}$ (capital letter O), $\\tt{-}$ (dash), and $\\tt{x}$ (small letter x) is then returned to the player, and the player may base his next guess on the previous grades. The following is an example of one game Prof. Pang played:\n\n```\nG: CRANE\nA: xx--x\nG: UTTER\nA: xxOxx\nG: NASAL\nA: OOxOO\nG: NATAL\nA: OOOOO\n```\n\nStrings after $\\tt{G}$ are Prof. Pang's guesses and strings after $\\tt{A}$ are the grades of the guesses. \n\nProf. Pang really enjoys the game. He believes that he has developed a perfect strategy for it. However, today he goes mad because he thinks the grading system is bugged! He wants to have someone write an analysis program to figure out the number of possible strings that can be the answer to the puzzle based on his list of guesses and grades.\n\nSince the grading system might be bugged, it might not conform to the pseudo-code given above. So specifically, the task is to find how many strings that are consistent with the input. A string s is consistent with the input if for any guess g in the input and its corresponding grade d, grading(s, g)=d.\n\nAnd of course, you will be doing the programming.", "inputFormat": "The first line consists of two integers $n$ and $k$ $(1 \\le n \\le 10^4, 1 \\le k \\le 19)$, which are the number of guesses and the length of the string, respectively.\n\nThe following lines consist of the guesses and the grades, one per line, correspondingly.", "outputFormat": "An integer, denoting how many possible answers there are, modulo $10^9+7$.", "hint": "For the second example:\n\nIf the answer is $\\tt{ACDEF}$, the guess $\\tt{BBBAA}$ will produce a grade of $\\tt{xxx-x}$.", "locale": "en", "translations": {"en": {"title": "[EC Final 2021] String-dle Count", "background": "", "description": "While most people love to play Wordle these days, Prof. Pang has become addicted to String-dle.\n\nString-dle is an interesting string-guessing game where the player tries to guess a string of $k$ capital letters through several rounds. In each round, the player submits a string of length $k$ as his guess, and the system grades the guess through the following pseudo-code:\n\n```\ndef grading(answer, guess):\n  let count be a hash map\n  for i = 1 to k:\n    if answer[i] not in count:\n      count[answer[i]] = 1\n    else:\n      count[answer[i]] = count[answer[i]] + 1\n  let grade be an array of length k\n  for i = 1 to k:\n    if answer[i] == guess[i]:\n      grade[i] = 'O'\n      count[guess[i]] = count[guess[i]] - 1\n  for i = 1 to k:\n    if answer[i] != guess[i]:\n      if count[guess[i]] > 0:\n        grade[i] = '-'\n        count[guess[i]] = count[guess[i]] - 1\n      else:\n        grade[i] = 'x'\n  return grade\n```\n\nThe grade consisting of $\\tt{O}$ (capital letter O), $\\tt{-}$ (dash), and $\\tt{x}$ (small letter x) is then returned to the player, and the player may base his next guess on the previous grades. The following is an example of one game Prof. Pang played:\n\n```\nG: CRANE\nA: xx--x\nG: UTTER\nA: xxOxx\nG: NASAL\nA: OOxOO\nG: NATAL\nA: OOOOO\n```\n\nStrings after $\\tt{G}$ are Prof. Pang's guesses and strings after $\\tt{A}$ are the grades of the guesses. \n\nProf. Pang really enjoys the game. He believes that he has developed a perfect strategy for it. However, today he goes mad because he thinks the grading system is bugged! He wants to have someone write an analysis program to figure out the number of possible strings that can be the answer to the puzzle based on his list of guesses and grades.\n\nSince the grading system might be bugged, it might not conform to the pseudo-code given above. So specifically, the task is to find how many strings that are consistent with the input. A string s is consistent with the input if for any guess g in the input and its corresponding grade d, grading(s, g)=d.\n\nAnd of course, you will be doing the programming.", "inputFormat": "The first line consists of two integers $n$ and $k$ $(1 \\le n \\le 10^4, 1 \\le k \\le 19)$, which are the number of guesses and the length of the string, respectively.\n\nThe following lines consist of the guesses and the grades, one per line, correspondingly.", "outputFormat": "An integer, denoting how many possible answers there are, modulo $10^9+7$.", "hint": "For the second example:\n\nIf the answer is $\\tt{ACDEF}$, the guess $\\tt{BBBAA}$ will produce a grade of $\\tt{xxx-x}$.", "locale": "en"}, "zh-CN": {"title": "[EC Final 2021] String-dle Count", "background": "", "description": "当大多数人都沉迷于玩 Wordle 的时候，庞教授却已经沉迷于玩 String-dle 了。\n\nString-dle 是一个有趣的猜字符串的游戏，玩家在玩的时候要通过几轮尝试，猜出一个长度为 $k$ 的字符串。并且在每轮尝试中，玩家要提交一个长度为 $k$ 的字符串来作为他的猜测，而系统通过以下伪代码来为提交的猜测评级：\n```\ndef grading(answer, guess):\n  let count be a hash map\n  for i = 1 to k:\n    if answer[i] not in count:\n      count[answer[i]] = 1\n    else:\n      count[answer[i]] = count[answer[i]] + 1\n  let grade be an array of length k\n  for i = 1 to k:\n    if answer[i] == guess[i]:\n      grade[i] = 'O'\n      count[guess[i]] = count[guess[i]] - 1\n  for i = 1 to k:\n    if answer[i] != guess[i]:\n      if count[guess[i]] > 0:\n        grade[i] = '-'\n        count[guess[i]] = count[guess[i]] - 1\n      else:\n        grade[i] = 'x'\n  return grade\n```\n返回的评级包括 $\\tt{O}$（大写字母 O）、$\\tt{-}$（破折号）和 $\\tt{x}$（小写字母 x），且玩家可以基于先前的评级进行下一次猜测。下面是庞教授玩的一局游戏示例：\n```\nG: CRANE\nA: xx--x\nG: UTTER\nA: xxOxx\nG: NASAL\nA: OOxOO\nG: NATAL\nA: OOOOO\n```\n在字符串 $\\tt{G}$ 后面的是庞教授的猜测，以及在字符串 $\\tt{A}$ 后面的是该次猜测的评级。\n\n庞教授非常喜欢这个游戏。他确信他已经知道了这个游戏的完美策略。然而，今天他很生气，因为他认为评级系统出了问题！他想让人写一个分析程序，根据他的猜测与评级找出所有可能的可以作为答案的字符串。\n\n由于评级系统可能出了问题，所以它可能不再符合上面给出的伪代码。具体来说，你需要找到所有符合输入的字符串。一个符合输入的字符串是指，对于输入中任意一个猜测  $g$ 和它的正确评级 $d$，都符合  `grading(s, g)=d`。\n\n当然，你接受了这个任务。", "inputFormat": "第一行是两个整数 $n$、$k$ $(1 \\le n \\le 10^4, 1 \\le k \\le 19)$，分别是猜测的次数和字符串的长度。\n\n下面共有 $2n$ 行，每两行都对应一个猜测和它对应的评级。", "outputFormat": "一个整数，表示有多少种可能的答案，并模 $10^9+7$.\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n2 5\nCRANE\nxx--x\nNASAL\nOOxOO\n```\n\n#### 样例输出 #1\n\n```\n21\n```\n\n### 样例 #2\n\n#### 样例输入 #2\n\n```\n1 5\nBBBAA\nxxxx-\n```\n\n#### 样例输出 #2\n\n```\n0\n```\n\n### 样例 #3\n\n#### 样例输入 #3\n\n```\n2 5\nABCDE\n-xxxx\nABCDE\nxxxxx\n```\n\n#### 样例输出 #3\n\n```\n0\n```\n\n### 样例 #4\n\n#### 样例输入 #4\n\n```\n1 3\nABC\n---\n```\n\n#### 样例输出 #4\n\n```\n2\n```\n\n### 样例 #5\n\n#### 样例输入 #5\n\n```\n1 15\nAAAAAAAAAAAAAAB\n-xxxxxxxxxxxxxx\n```\n\n#### 样例输出 #5\n\n```\n918547951\n```\n\n## 样例 #6\n\n#### 样例输入 #6\n\n```\n1 15\nAAAAAAAAAAAAAAA\n-xxxxxxxxxxxxxx\n```\n\n#### 样例输出 #6\n\n```\n0\n```\n\n### 样例 #7\n\n#### 样例输入 #7\n\n```\n1 1\nK\nx\n```\n\n#### 样例输出 #7\n\n```\n25\n```", "hint": "对于第二个样例:\n\n如果答案是 $\\tt{ACDEF}$，则 $\\tt{BBBAA}$ 的评级为 $\\tt{xxx-x}$.", "locale": "zh-CN"}}}
{"pid": "P9875", "type": "P", "difficulty": 6, "samples": [["3\n0 0\n1 1\n2 2 3 3\n4 4 5 5\n0 0\n1 1\n2 2 3 3\n2 2 3 3\n0 0\n10 10\n10 0 0 10\n1 1 2 2", "0\n0\n1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["计算几何", "2021", "O2优化", "ICPC", "EC Final"], "title": "[EC Final 2021] Two Walls", "background": "", "description": "Prof. Pang has bought a humanoid cleaning robot to clean his yard. The robot is not very sophisticated. It can either move forward or change its direction at a time, all controlled by Prof. Pang's controller.\n\nProf. Pang's yard is a 2D plane. The robot needs to move from its current location $A$ to the destination $B$ to fulfill some ``cleaning`` needs of Prof. Pang. However, there are two straight walls $CD$ and $EF$ in Prof. Pang's yard. Since the robot is clumsy, it will fall over if it touches any of the walls (even at endpoints).\n\nNow that Prof. Pang is lazy, he wants to minimize the number of times the robot changes its direction. Can you help him?", "inputFormat": "The first line contains a single integer $T$ ($1 \\le T \\le 10^5$) denoting the number of test cases.\n\nFor each test case, the first line contains two integers $x_A, y_A$, the coordinates of point $A$. The second line contains two integers $x_B, y_B$, the coordinates of point $B$.\nThe third line contains four integers $x_C, y_C, x_D, y_D$, the coordinates of point $C$ and $D$ which are the endpoints of the first wall. The fourth line contains four integers $x_E, y_E, x_F, y_F$, the coordinates of point $E$ and $F$ which are the endpoints of the second wall.\n\nIt is guaranteed that neither the current location $A$ nor the destination $B$ of the robot are on any of the walls. A wall may degenerate to a point. It can be proved that the robot can always move from $A$ to $B$ without touching any of the walls. All values lie within $[-10^9, 10^9]$.", "outputFormat": "For each test case, print one number $d$ in one line, denoting the minimum number of turns.", "hint": "The following are illustrations for the first sample and the third sample.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nuyvzg7a.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/diy78yex.png)", "locale": "en", "translations": {"en": {"title": "[EC Final 2021] Two Walls", "background": "", "description": "Prof. Pang has bought a humanoid cleaning robot to clean his yard. The robot is not very sophisticated. It can either move forward or change its direction at a time, all controlled by Prof. Pang's controller.\n\nProf. Pang's yard is a 2D plane. The robot needs to move from its current location $A$ to the destination $B$ to fulfill some ``cleaning`` needs of Prof. Pang. However, there are two straight walls $CD$ and $EF$ in Prof. Pang's yard. Since the robot is clumsy, it will fall over if it touches any of the walls (even at endpoints).\n\nNow that Prof. Pang is lazy, he wants to minimize the number of times the robot changes its direction. Can you help him?", "inputFormat": "The first line contains a single integer $T$ ($1 \\le T \\le 10^5$) denoting the number of test cases.\n\nFor each test case, the first line contains two integers $x_A, y_A$, the coordinates of point $A$. The second line contains two integers $x_B, y_B$, the coordinates of point $B$.\nThe third line contains four integers $x_C, y_C, x_D, y_D$, the coordinates of point $C$ and $D$ which are the endpoints of the first wall. The fourth line contains four integers $x_E, y_E, x_F, y_F$, the coordinates of point $E$ and $F$ which are the endpoints of the second wall.\n\nIt is guaranteed that neither the current location $A$ nor the destination $B$ of the robot are on any of the walls. A wall may degenerate to a point. It can be proved that the robot can always move from $A$ to $B$ without touching any of the walls. All values lie within $[-10^9, 10^9]$.", "outputFormat": "For each test case, print one number $d$ in one line, denoting the minimum number of turns.", "hint": "The following are illustrations for the first sample and the third sample.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nuyvzg7a.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/diy78yex.png)", "locale": "en"}, "zh-CN": {"title": "[EC Final 2021] Two Walls", "background": "", "description": "庞教授买了一个人形清洁机器人来清理他的院子。这个机器人并不十分复杂，它可以前进或改变方向，这一切都由庞教授的控制器控制。\n\n庞教授的院子是一个二维平面。机器人需要从当前位置 $A$ 移动到目的地 $B$，以满足庞教授的一些“清洁”需求。然而，庞教授的院子里有两堵直墙 $CD$ 和 $EF$。由于机器人笨拙，如果它碰到任何一堵墙（即使是端点），它就会摔倒。\n\n由于庞教授很懒，他希望尽量减少机器人改变方向的次数。你能帮他吗？", "inputFormat": "第一行包含一个整数 $T$ ($1 \\le T \\le 10^5$)，表示测试用例的数量。\n\n对于每个测试用例，第一行包含两个整数 $x_A, y_A$，表示点 $A$ 的坐标。第二行包含两个整数 $x_B, y_B$，表示点 $B$ 的坐标。第三行包含四个整数 $x_C, y_C, x_D, y_D$，表示第一堵墙的端点 $C$ 和 $D$ 的坐标。第四行包含四个整数 $x_E, y_E, x_F, y_F$，表示第二堵墙的端点 $E$ 和 $F$ 的坐标。\n\n保证机器人的当前位置 $A$ 和目的地 $B$ 都不在任何墙上。一堵墙可能退化为一个点。可以证明机器人总能从 $A$ 移动到 $B$ 而不碰到任何墙。所有值都在 $[-10^9, 10^9]$ 范围内。", "outputFormat": "对于每个测试用例，输出一个数字 $d$，表示最少的转弯次数。", "hint": "以下是第一个样例和第三个样例的示意图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nuyvzg7a.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/diy78yex.png)\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9876", "type": "P", "difficulty": 5, "samples": [["2\n2 2\n2H 2D\n3H 3D\n4S\n2 2\n2H 2D\n3H 4D\n4S", "Pang\nShou"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "O2优化", "ICPC", "分类讨论", "EC Final"], "title": "[EC Final 2021] Prof. Pang and Poker", "background": "", "description": "Prof. Pang is playing a card game with his two friends Alice and Bob. All cards are drawn from a standard 52-card deck. A standard 52-card deck comprises $13$ ranks in each of the four French suits: clubs ($\\clubsuit$), diamonds ($\\diamondsuit$), hearts ($\\heartsuit$) and spades ($\\spadesuit$). Each suit includes an Ace (A), a King (K), a Queen (Q), and a Jack (J), each depicted alongside a symbol of its suit; and numerals or pip cards from the Deuce (Two) to the Ten, with each card depicting that many symbols (pips) of its suit. $\\textbf{No card can be drawn more than once.}$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3xtu6g4z.png)\n\nIndividual cards are ranked as follows (high-to-low): A, K, Q, J, 10, 9, 8, 7, 6, 5, 4, 3, 2. $\\textbf{Suits do not affect ranks of the cards.}$ For example, Ace of diamonds and Ace of clubs have the same rank. No one of them is ranked strictly higher than the other.\n\nInitially, Alice and Bob will hold one or more cards while Prof. Pang will hold exactly one card. $\\textbf{Each player can see cards held by himself/herself and cards held by other players.}$ They will play the game in the following multi-round rule:\n\n- The initiative player chooses one card and put it out to start one round.\n- The next player can pass or put out a new card, then the player after the next can also pass or put out a new card, and so on. The only constraint is that the rank of the newly put card should be strictly higher than all previous cards in this round.\n- The round ends when two players choose to pass consecutively. The one who put out the last card becomes the initiative player in the next round.\n- If someone put out all the cards in his/her hand, the game ends immediately.\n\nIn this game, Alice is the initiative player in the first round. Bob, Prof. Pang,  and Alice are the next players of Alice, Bob,  and Prof. Pang respectively. Prof. Pang will be happy if and only if he is the one that first put out all the cards. (Prof. Pang wants to be happy, of course.) Alice wants to drink milk tea so she decides to make Prof. Pang happy and then asks him to buy milk tea for her. However, Bob doesn't want it to happen, so he decides to avoid Prof. Pang from being happy. If they play the game optimally for themselves, will Prof. Pang be happy in the end?", "inputFormat": "The first line contains a single integer $T$ ($1\\le T \\le 10^4$) denoting the number of test cases. For each test case:\n\nThe first line contains two integers $n,m$ ($1\\le n,m \\le 50$) denoting the number of cards in Alice's hand and Bob's hand initially.\n\nThe second line contains $n$ strings $a_i$ ($1\\le i \\le n$) denoting the cards in Alice's hand.\n\nThe third line contains $m$ strings $b_i$ ($1\\le i \\le m$) denoting the cards in Bod's hand.\n\nThe fourth line contains one string $p$ denoting the card in Prof. Pang's hand.\n\nFor each card, the first character of its corresponding string denotes its rank. (Possible ranks are `2` ,`3`,`4`,`5`,`6`,`7`,`8`,`9`,`T`,`J`,`Q`,`K`,`A`. `T` denotes $10$.) The second character denotes its suit. `C` denotes clubs. `D` denotes diamonds. `H` denotes hearts. `S` denotes spades.\n\nIt is guaranteed that each card appears at most once in one test case.", "outputFormat": "For each test case, print one line. Print $\\texttt{Pang}$ if Prof. Pang will be happy. Otherwise, print $\\texttt{Shou}$.", "hint": "- For the first case, Prof. Pang can always put out his only card ``4S``.\n- For the second case, Bob can put out ``4D`` and become the initiative player in the second round regardless of the card Alice put out in the first round, then Bob put out ``3H`` and the game ends.", "locale": "en", "translations": {"en": {"title": "[EC Final 2021] Prof. Pang and Poker", "background": "", "description": "Prof. Pang is playing a card game with his two friends Alice and Bob. All cards are drawn from a standard 52-card deck. A standard 52-card deck comprises $13$ ranks in each of the four French suits: clubs ($\\clubsuit$), diamonds ($\\diamondsuit$), hearts ($\\heartsuit$) and spades ($\\spadesuit$). Each suit includes an Ace (A), a King (K), a Queen (Q), and a Jack (J), each depicted alongside a symbol of its suit; and numerals or pip cards from the Deuce (Two) to the Ten, with each card depicting that many symbols (pips) of its suit. $\\textbf{No card can be drawn more than once.}$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3xtu6g4z.png)\n\nIndividual cards are ranked as follows (high-to-low): A, K, Q, J, 10, 9, 8, 7, 6, 5, 4, 3, 2. $\\textbf{Suits do not affect ranks of the cards.}$ For example, Ace of diamonds and Ace of clubs have the same rank. No one of them is ranked strictly higher than the other.\n\nInitially, Alice and Bob will hold one or more cards while Prof. Pang will hold exactly one card. $\\textbf{Each player can see cards held by himself/herself and cards held by other players.}$ They will play the game in the following multi-round rule:\n\n- The initiative player chooses one card and put it out to start one round.\n- The next player can pass or put out a new card, then the player after the next can also pass or put out a new card, and so on. The only constraint is that the rank of the newly put card should be strictly higher than all previous cards in this round.\n- The round ends when two players choose to pass consecutively. The one who put out the last card becomes the initiative player in the next round.\n- If someone put out all the cards in his/her hand, the game ends immediately.\n\nIn this game, Alice is the initiative player in the first round. Bob, Prof. Pang,  and Alice are the next players of Alice, Bob,  and Prof. Pang respectively. Prof. Pang will be happy if and only if he is the one that first put out all the cards. (Prof. Pang wants to be happy, of course.) Alice wants to drink milk tea so she decides to make Prof. Pang happy and then asks him to buy milk tea for her. However, Bob doesn't want it to happen, so he decides to avoid Prof. Pang from being happy. If they play the game optimally for themselves, will Prof. Pang be happy in the end?", "inputFormat": "The first line contains a single integer $T$ ($1\\le T \\le 10^4$) denoting the number of test cases. For each test case:\n\nThe first line contains two integers $n,m$ ($1\\le n,m \\le 50$) denoting the number of cards in Alice's hand and Bob's hand initially.\n\nThe second line contains $n$ strings $a_i$ ($1\\le i \\le n$) denoting the cards in Alice's hand.\n\nThe third line contains $m$ strings $b_i$ ($1\\le i \\le m$) denoting the cards in Bod's hand.\n\nThe fourth line contains one string $p$ denoting the card in Prof. Pang's hand.\n\nFor each card, the first character of its corresponding string denotes its rank. (Possible ranks are `2` ,`3`,`4`,`5`,`6`,`7`,`8`,`9`,`T`,`J`,`Q`,`K`,`A`. `T` denotes $10$.) The second character denotes its suit. `C` denotes clubs. `D` denotes diamonds. `H` denotes hearts. `S` denotes spades.\n\nIt is guaranteed that each card appears at most once in one test case.", "outputFormat": "For each test case, print one line. Print $\\texttt{Pang}$ if Prof. Pang will be happy. Otherwise, print $\\texttt{Shou}$.", "hint": "- For the first case, Prof. Pang can always put out his only card ``4S``.\n- For the second case, Bob can put out ``4D`` and become the initiative player in the second round regardless of the card Alice put out in the first round, then Bob put out ``3H`` and the game ends.", "locale": "en"}, "zh-CN": {"title": "[EC Final 2021] Prof. Pang and Poker", "background": "", "description": "庞教授正在和他的两个朋友 Alice 和 Bob 玩纸牌游戏。所有的牌都从一副标准的 52 张牌的牌堆中抽取。一副标准的 52 张牌的牌堆由四种法式花色中的 13 个等级组成：梅花 ($\\clubsuit$)、方块 ($\\diamondsuit$)、红心 ($\\heartsuit$) 和黑桃 ($\\spadesuit$)。每种花色包括一张 A（Ace）、一张 K（King）、一张 Q（Queen）和一张 J（Jack），每张牌旁边都有其花色的符号；以及从 2 到 10 的数字牌，每张牌上都有相应数量的花色符号（点数）。**没有一张牌可以被抽取多于一次。**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3xtu6g4z.png)\n\n单张牌的等级如下（从高到低）：A、K、Q、J、10、9、8、7、6、5、4、3、2。**花色不影响牌的等级。**例如，方块 A 和梅花 A 具有相同的等级。它们之间没有一个严格高于另一个。\n\n最初，Alice 和 Bob 将持有一张或多张牌，而庞教授将持有恰好一张牌。**每个玩家可以看到自己和其他玩家持有的牌。**他们将按照以下多轮规则进行游戏：\n\n- 先手玩家选择一张牌并打出以开始一轮。\n- 下一个玩家可以选择过牌或打出新牌，然后下一个玩家也可以选择过牌或打出新牌，依此类推。唯一的限制是，新打出的牌的等级必须严格高于本轮中所有之前的牌。\n- 当两名玩家连续选择过牌时，本轮结束。最后打出牌的玩家在下一轮中成为先手玩家。\n- 如果有人打出了手中的所有牌，游戏立即结束。\n\n在这个游戏中，Alice 是第一轮的先手玩家。Bob、庞教授和 Alice 分别是 Alice、Bob 和庞教授的下一个玩家。庞教授只有在他是第一个打出所有牌的人时才会感到高兴。（庞教授当然想要高兴。）Alice 想喝奶茶，所以她决定让庞教授高兴，然后让他给她买奶茶。然而，Bob 不想让这种情况发生，所以他决定避免庞教授感到高兴。如果他们都为自己以最佳方式玩游戏，庞教授最后会高兴吗？", "inputFormat": "第一行包含一个整数 $T$ ($1\\le T \\le 10^4$)，表示测试用例的数量。对于每个测试用例：\n\n第一行包含两个整数 $n,m$ ($1\\le n,m \\le 50$)，表示 Alice 和 Bob 手中最初的牌数。\n\n第二行包含 $n$ 个字符串 $a_i$ ($1\\le i \\le n$)，表示 Alice 手中的牌。\n\n第三行包含 $m$ 个字符串 $b_i$ ($1\\le i \\le m$)，表示 Bob 手中的牌。\n\n第四行包含一个字符串 $p$，表示庞教授手中的牌。\n\n对于每张牌，其对应字符串的第一个字符表示其等级。（可能的等级有 `2` 、`3`、`4`、`5`、`6`、`7`、`8`、`9`、`T`、`J`、`Q`、`K`、`A`。`T` 表示 $10$。）第二个字符表示其花色。`C` 表示梅花。`D` 表示方块。`H` 表示红心。`S` 表示黑桃。\n\n保证在一个测试用例中，每张牌最多出现一次。", "outputFormat": "对于每个测试用例，输出一行。如果庞教授会高兴，输出 `Pang`。否则，输出 `Shou`。", "hint": "- 对于第一个案例，庞教授总是可以打出他唯一的牌 “4S”。\n- 对于第二个案例，无论 Alice 在第一轮打出什么牌，Bob 都可以打出 “4D” 并在第二轮成为先手玩家，然后 Bob 打出 “3H”，游戏结束。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9877", "type": "P", "difficulty": 7, "samples": [["5 6 3\n0 -5 -3 8 -3\n2 3 5\n1 2 5\n2 1 5\n1 4 -3\n2 3 5\n2 1 5", "8\n10\n0\n5"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "O2优化", "ICPC", "EC Final"], "title": "[EC Final 2021] Vacation", "background": "", "description": "Prof. Pang has an annual leave of $c$ days and he wants to go on vacation.\n\nNow there are $n$ days in a year. Prof. Pang can gain $a_i$ happiness if he rests on the $i$-th day. The values of happiness, $a_i$, may be negative.\n\nProf. Pang wants you to do $m$ operations:\n\n- $1~x~y$, change the happiness of the $x$-th day to $y$.\n- $2~l~r$, Prof. Pang wants to find a period of vacation in $[l, r]$. He wants to rest for several (possibly $0$) days in a row and gain as much happiness as possible. However, he only has $c$ days off, thus he can rest for no more than $c$ consecutive days in $[l,r]$.\n\nThat means he wants to find \n\n$$\\max\\left(\\max_{l \\leq l' \\leq r' \\leq r\\atop r'-l'+1\\leq c}  ~~ \\left(\\sum_{i=l'} ^{r'} a_i\\right), 0\\right).$$\n", "inputFormat": "The first line contains three integers $n, m, c (1\\leq n\\leq 2\\times 10^5, 1\\leq m \\leq 5\\times 10^5, 1\\leq c\\leq n)$ indicating the number of days in a year, the number of operations, and Prof. Pang's annual leave days.\n\nThe next line contains $n$ integers $a_1, a_2, \\dots, a_n(-10^9 \\leq a_i\\leq 10^9)$ indicating the values of happiness of every day.\n\nThe next $m$ lines are the $m$ operations in the format described above.\n\nIt is guaranteed that $1\\leq x\\leq n, -10^9\\leq y\\leq 10^9, 1\\leq l\\leq r \\leq n$.", "outputFormat": "For each operation of the second type, print the answer.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2021] Vacation", "background": "", "description": "Prof. Pang has an annual leave of $c$ days and he wants to go on vacation.\n\nNow there are $n$ days in a year. Prof. Pang can gain $a_i$ happiness if he rests on the $i$-th day. The values of happiness, $a_i$, may be negative.\n\nProf. Pang wants you to do $m$ operations:\n\n- $1~x~y$, change the happiness of the $x$-th day to $y$.\n- $2~l~r$, Prof. Pang wants to find a period of vacation in $[l, r]$. He wants to rest for several (possibly $0$) days in a row and gain as much happiness as possible. However, he only has $c$ days off, thus he can rest for no more than $c$ consecutive days in $[l,r]$.\n\nThat means he wants to find \n\n$$\\max\\left(\\max_{l \\leq l' \\leq r' \\leq r\\atop r'-l'+1\\leq c}  ~~ \\left(\\sum_{i=l'} ^{r'} a_i\\right), 0\\right).$$\n", "inputFormat": "The first line contains three integers $n, m, c (1\\leq n\\leq 2\\times 10^5, 1\\leq m \\leq 5\\times 10^5, 1\\leq c\\leq n)$ indicating the number of days in a year, the number of operations, and Prof. Pang's annual leave days.\n\nThe next line contains $n$ integers $a_1, a_2, \\dots, a_n(-10^9 \\leq a_i\\leq 10^9)$ indicating the values of happiness of every day.\n\nThe next $m$ lines are the $m$ operations in the format described above.\n\nIt is guaranteed that $1\\leq x\\leq n, -10^9\\leq y\\leq 10^9, 1\\leq l\\leq r \\leq n$.", "outputFormat": "For each operation of the second type, print the answer.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2021] Vacation", "background": "", "description": "庞教授有 $c$ 天的年假，他想去度假。\n\n现在一年有 $n$ 天。如果庞教授在第 $i$ 天休息，他可以获得 $a_i$ 的幸福感。幸福感的值 $a_i$ 可能是负数。\n\n庞教授希望你执行 $m$ 个操作：\n\n- $1~x~y$，将第 $x$ 天的幸福感改为 $y$。\n- $2~l~r$，庞教授希望在 $[l, r]$ 期间找到一个度假期。他希望连续休息几天（可能为 $0$ 天）并获得尽可能多的幸福感。然而，他只有 $c$ 天的假期，因此在 $[l,r]$ 中他最多只能连续休息 $c$ 天。\n\n这意味着他希望找到\n\n$$\\max\\left(\\max_{l \\leq l' \\leq r' \\leq r\\atop r'-l'+1\\leq c}  ~~ \\left(\\sum_{i=l'} ^{r'} a_i\\right), 0\\right)。$$", "inputFormat": "第一行包含三个整数 $n, m, c (1\\leq n\\leq 2\\times 10^5, 1\\leq m \\leq 5\\times 10^5, 1\\leq c\\leq n)$，表示一年中的天数、操作的数量和庞教授的年假天数。\n\n下一行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n(-10^9 \\leq a_i\\leq 10^9)$，表示每一天的幸福感值。\n\n接下来的 $m$ 行是格式如上所述的 $m$ 个操作。\n\n保证 $1\\leq x\\leq n, -10^9\\leq y\\leq 10^9, 1\\leq l\\leq r \\leq n$。", "outputFormat": "对于每个第二类操作，输出答案。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9878", "type": "P", "difficulty": 7, "samples": [["3\n2 2\n??\n??\n3 3\nBW?\nW?B\n?BW\n3 3\nBW?\nW?W\n?W?", "YES\nBW\nWW\nNO\nYES\nBWB\nWWW\nBWB"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "Special Judge", "O2优化", "构造", "ICPC", "EC Final"], "title": "[EC Final 2021] Check Pattern is Bad", "background": "", "description": "Prof. Pang is given an $n\\times m$ board. Some cells are colored black, some cells are colored white, and others are uncolored.\n\nProf. Pang doesn't like $\\textbf{check patterns}$, so he wants to color all uncolored cells such that there is no check pattern on the board.\n\n$4$ cells forming a $2\\times 2$ square are said to have the check pattern if they are colored in one of the following ways:\n\n```plain\nBW\nWB\n```\n\n```plain\nWB\nBW\n```\n\nHere `W` (\"wakuda\" in Chewa language) means the cell is colored black and `B` (\"biancu\" in Corsican language) means the cell is colored white.", "inputFormat": "The first line contains a single integer $T$ $(1\\leq T \\leq 10^4)$ denoting the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1\\le n, m\\le 100$) denoting the dimensions of the board.\n\nEach of the next $n$ lines contains $m$ characters. The $j$-th character of the $i$-th line represents the status of the cell on the $i$-th row and $j$-th column of the board. The character is `W` if the cell is colored black, `B` if the cell is colored white, and `?` if the cell is uncolored. \n\nIt is guaranteed that the sum of $nm$ over all test cases is no more than $10^6$.", "outputFormat": "For each test case, output a line containing $\\texttt{NO}$ if you cannot color all the uncolored cells such that there is no check pattern on the board.\n\nOtherwise, output a line containing $\\texttt{YES}$. In the next $n$ lines, output the colored board in the same format as the input. The output board should satisfy the following conditions.\n\n- It does not have any check pattern.\n- It consists of only $\\texttt{B}$ and $\\texttt{W}$.\n- If a cell is already colored in the input, its color cannot be changed in the output.\n\nIf there are multiple solutions, output any of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2021] Check Pattern is Bad", "background": "", "description": "Prof. Pang is given an $n\\times m$ board. Some cells are colored black, some cells are colored white, and others are uncolored.\n\nProf. Pang doesn't like $\\textbf{check patterns}$, so he wants to color all uncolored cells such that there is no check pattern on the board.\n\n$4$ cells forming a $2\\times 2$ square are said to have the check pattern if they are colored in one of the following ways:\n\n```plain\nBW\nWB\n```\n\n```plain\nWB\nBW\n```\n\nHere `W` (\"wakuda\" in Chewa language) means the cell is colored black and `B` (\"biancu\" in Corsican language) means the cell is colored white.", "inputFormat": "The first line contains a single integer $T$ $(1\\leq T \\leq 10^4)$ denoting the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1\\le n, m\\le 100$) denoting the dimensions of the board.\n\nEach of the next $n$ lines contains $m$ characters. The $j$-th character of the $i$-th line represents the status of the cell on the $i$-th row and $j$-th column of the board. The character is `W` if the cell is colored black, `B` if the cell is colored white, and `?` if the cell is uncolored. \n\nIt is guaranteed that the sum of $nm$ over all test cases is no more than $10^6$.", "outputFormat": "For each test case, output a line containing $\\texttt{NO}$ if you cannot color all the uncolored cells such that there is no check pattern on the board.\n\nOtherwise, output a line containing $\\texttt{YES}$. In the next $n$ lines, output the colored board in the same format as the input. The output board should satisfy the following conditions.\n\n- It does not have any check pattern.\n- It consists of only $\\texttt{B}$ and $\\texttt{W}$.\n- If a cell is already colored in the input, its color cannot be changed in the output.\n\nIf there are multiple solutions, output any of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2021] Check Pattern is Bad", "background": "", "description": "庞教授得到一个 $n \\times m$ 的棋盘。有些格子被涂成黑色，有些被涂成白色，其他的则没有颜色。\n\n庞教授不喜欢“棋盘格”图案，所以他想要给所有未上色的格子上色，使得棋盘上没有棋盘格图案。\n\n如果 $4$ 个格子形成一个 $2 \\times 2$ 的正方形，并且它们的颜色是以下两种方式之一，则称它们具有棋盘格图案：\n\n```plain\nBW\nWB\n```\n\n```plain\nWB\nBW\n```\n\n这里 `W`（在切瓦语中为“wakuda”）表示格子被涂成黑色，`B`（在科西嘉语中为“biancu”）表示格子被涂成白色。", "inputFormat": "第一行包含一个整数 $T$ $(1 \\leq T \\leq 10^4)$，表示测试用例的数量。\n\n每个测试用例的第一行包含两个整数 $n$ 和 $m$ ($1 \\le n, m \\le 100$)，表示棋盘的尺寸。\n\n接下来的 $n$ 行中的每一行包含 $m$ 个字符。第 $i$ 行的第 $j$ 个字符表示棋盘第 $i$ 行第 $j$ 列的格子的状态。若格子被涂成黑色，则字符为 `W`；若格子被涂成白色，则字符为 `B`；若格子未上色，则字符为 `?`。\n\n保证所有测试用例中 $nm$ 的总和不超过 $10^6$。", "outputFormat": "对于每个测试用例，如果不能给所有未上色的格子上色以使棋盘上没有棋盘格图案，则输出一行 `NO`。\n\n否则，输出一行 `YES`。在接下来的 $n$ 行中，输出与输入格式相同的涂色棋盘。输出的棋盘应满足以下条件：\n\n- 没有任何棋盘格图案。\n- 仅由 `B` 和 `W` 组成。\n- 如果输入中某个格子已经上色，则在输出中不能更改其颜色。\n\n如果有多个解决方案，输出其中任意一个。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9879", "type": "P", "difficulty": 6, "samples": [["3\n2 2\n??\n??\n3 3\nBW?\nW?B\n?BW\n3 3\nBW?\nW?W\n?W?\n", "1\nWB\nBW\n1\nBWB\nWWB\nBBW\n4\nBWB\nWBW\nBWB\n"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "网络流", "Special Judge", "O2优化", "ICPC", "EC Final"], "title": "[EC Final 2021] Check Pattern is Good", "background": "", "description": "Prof. Shou is given an $n\\times m$ board. Some cells are colored black, some cells are colored white, and others are uncolored.\n\nProf. Shou likes **check patterns**, so he wants to color all uncolored cells and maximizes the number of check patterns on the board.\n\n$4$ cells forming a $2\\times 2$ square are said to have the check pattern if they are colored in one of the following ways:\n\n```plain\nBW\nWB\n```\n\n```plain\nWB\nBW\n```\n\nHere `W` (\"wakuda\" in Chewa language) means the cell is colored black and `B` (\"biancu\" in Corsican language) means the cell is colored white.", "inputFormat": "The first line contains a single integer $T$ $(1\\leq T \\leq 10^4)$ denoting the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1\\le n, m\\le 100$) denoting the dimensions of the board.\n\nEach of the next $n$ lines contains $m$ characters. The $j$-th character of the $i$-th line represents the status of the cell on the $i$-th row and $j$-th column of the board. The character is `W` if the cell is colored black, `B` if the cell is colored white, and `?` if the cell is uncolored. \n\nIt is guaranteed that the sum of $nm$ over all test cases is no more than $10^6$.", "outputFormat": "For each test case, output a line containing the maximum number of check patterns on the board.\n\nIn the next $n$ lines, output the colored board in the same format as the input. The output board should satisfy the following conditions.\n\n- It consists of only `B` and `W`.\n- If a cell is already colored in the input, its color cannot be changed in the output.\n- The number of check patterns equals the answer you print.\n\nIf there are multiple solutions, output any of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[EC Final 2021] Check Pattern is Good", "background": "", "description": "Prof. Shou is given an $n\\times m$ board. Some cells are colored black, some cells are colored white, and others are uncolored.\n\nProf. Shou likes **check patterns**, so he wants to color all uncolored cells and maximizes the number of check patterns on the board.\n\n$4$ cells forming a $2\\times 2$ square are said to have the check pattern if they are colored in one of the following ways:\n\n```plain\nBW\nWB\n```\n\n```plain\nWB\nBW\n```\n\nHere `W` (\"wakuda\" in Chewa language) means the cell is colored black and `B` (\"biancu\" in Corsican language) means the cell is colored white.", "inputFormat": "The first line contains a single integer $T$ $(1\\leq T \\leq 10^4)$ denoting the number of test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ ($1\\le n, m\\le 100$) denoting the dimensions of the board.\n\nEach of the next $n$ lines contains $m$ characters. The $j$-th character of the $i$-th line represents the status of the cell on the $i$-th row and $j$-th column of the board. The character is `W` if the cell is colored black, `B` if the cell is colored white, and `?` if the cell is uncolored. \n\nIt is guaranteed that the sum of $nm$ over all test cases is no more than $10^6$.", "outputFormat": "For each test case, output a line containing the maximum number of check patterns on the board.\n\nIn the next $n$ lines, output the colored board in the same format as the input. The output board should satisfy the following conditions.\n\n- It consists of only `B` and `W`.\n- If a cell is already colored in the input, its color cannot be changed in the output.\n- The number of check patterns equals the answer you print.\n\nIf there are multiple solutions, output any of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[EC Final 2021] Check Pattern is Good", "background": "", "description": "教授 Shou 得到了一个 $(n \\times m)$ 的棋盘。一些格子被涂成了黑色，一些被涂成了白色，还有一些没有上色。\n\n教授 Shou 喜欢**棋盘图案**，所以他想给所有未上色的格子涂色，并最大化棋盘上的棋盘图案数量。\n\n如果四个形成一个 $(2 \\times 2)$ 方格的单元格以以下任一种方式上色，则说它们形成了一个棋盘图案：\n\n`BW `\n\n`WB`\n\n或者\n\n`WB `\n\n`BW`\n\n这里的 `W`（在奇瓦语中是“wakuda”，意为黑色）表示格子被涂成了黑色，而 `B`（在科西嘉语中是“biancu”，意为白色）表示格子被涂成了白色。", "inputFormat": "第一行包含一个整数 $T (1 \\leq T \\leq 10^4)$，表示测试用例的数量。\n\n每个测试用例的第一行包含两个整数 $n$ 和 $ m$ $(1 \\leq n, m \\leq 100)$，表示棋盘的尺寸。\n\n接下来的 $n$ 行每行包含 $m$ 个字符。第 $i$ 行的第 $j$ 个字符表示棋盘上第 $i$ 行和第 $j$ 列的格子的状态。如果格子被涂成了黑色，则字符为 `W`；如果格子被涂成了白色，则字符为 `B`；如果格子未上色，则字符为 `?`。\n\n保证所有测试用例中 $ n \\times m $ 的总和不超过 $10^6$。\n\n\n* 只包含 `B` 和 `W`。\n* 如果输入中的格子已经上色，则在输出中不能改变其颜色。\n* 棋盘图案的数量等于你打印的答案。\n\n如果有多种解决方案，输出其中任何一种。", "outputFormat": "对于每个测试用例，输出一行，包含棋盘上的最大棋盘图案数量。", "hint": "", "locale": "zh-CN"}}}
