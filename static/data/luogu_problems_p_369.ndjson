{"pid": "P8478", "type": "P", "difficulty": 7, "samples": [["3 0\n2 2 2", "8"], ["3 1\n2 2 2", "30"], ["5 3\n2 3 4 4 3", "275200"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["洛谷原创", "O2优化", "洛谷月赛"], "title": "「GLR-R3」清明", "background": "&emsp;&emsp;「&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;，&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;」\n\n---\n\n&emsp;&emsp;“你非说这不是我的实力，那凭什么一个偶然错音就不能毁了我的命运？！”\n\n&emsp;&emsp;天依没有注意到，心中所哭嚎向的那个人，同她一样撑着伞，身后十来步而已。\n\n---\n\n&emsp;&emsp;**清明**　「你在名为弱小的深渊　究竟看见过什么」", "description": "雨打在窗沿，下坠，一级一级。\n\n这里一共有 $n$ 级窗沿，从高到低编号，最高层编号为 $1$，最底层编号为 $n$。假设在某一瞬间，第 $i$ 级窗沿上有 $a_i$ 单位体积的雨水。由于奇妙的物理原因，第 $i$ 级的雨水将在「下一个瞬间」滴向第 $i+1,i+2,\\dots,\\min\\{i+k,n\\}$ 级，也可能留在第 $i$ 级，但是每一种去向的雨水的单位体积都应是非负整数，且总和为 $a_i$。\n\n设在「下一个瞬间」，第 $i$ 级窗沿上有 $a_i'$ 单位的雨水，那么称此时雨水的**奇妙度**为 $\\prod_{i=1}^n a_i'$。现在，悲伤的人儿想知道，对于所有**本质不同的**「下一个瞬间」，雨水的奇妙度之和对素数 $P=998244353$ 取模的结果。\n\n两个「下一个瞬间」本质不同，当且仅当存在编号 $i<j$ 的两级窗沿，从窗沿 $i$ 滴向窗沿 $j$ 的雨水的单位体积不同。", "inputFormat": "第一行输入两个正整数 $n,k$，分别表示窗沿的数量、限制雨点滴落距离的常数。\n\n第二行输入 $n$ 个非负整数 $a_1,a_2,a_3,\\cdots,a_n$，其中 $a_i$ 表示第 $i$ 级窗沿在这一瞬间的雨水体积。", "outputFormat": "输出一行一个整数，表示所有本质不同的「下一个瞬间」，雨水的奇妙度之和对 $P$ 取模后的结果。", "hint": "#### 样例 #1 解释\n\n容易发现总共只有一种本质不同的「下一个瞬间」，也就是每级窗沿都没有雨水向其他窗沿滴落。\n\n所以最终 $a'=\\{2,2,2\\}$，权值为 $8$。\n\n#### 样例 #2 解释\n\n设 $c_k$ 表示从第 $k$ 级窗沿滴向第 $k+1$ 级窗沿的雨点体积，显然有 $c_3=0$。\n\n枚举所有合法的滴落情况：\n\n- $c=\\{0,0,0\\},b=\\{2,2,2\\}$，权值为 $8$；\n- $c=\\{0,1,0\\},b=\\{2,1,3\\}$，权值为 $6$；\n- $c=\\{0,2,0\\},b=\\{2,0,4\\}$，权值为 $0$；\n- $c=\\{1,0,0\\},b=\\{1,3,2\\}$，权值为 $6$；\n- $c=\\{1,1,0\\},b=\\{1,2,3\\}$，权值为 $6$；\n- $c=\\{1,2,0\\},b=\\{1,1,4\\}$，权值为 $4$；\n- $c_1=2$，此时必然有 $b_1=0$，此情况下的三种方案权值均为 $0$；\n\n所以所有本质不同的「下一个瞬间」的权值和为 $8+6+0+6+6+4+0+0+0=30$。\n\n### 数据规模与约定\n\n**本题采用 Subtask 的计分方式。**\n\n对于 $100\\%$ 的数据，$0\\le k<n\\le 32$，$0\\le a_i<P$。\n\n对于不同的子任务，作如下约定：\n\n| 子任务编号 |   $n$   |   $k$   | $\\max a_i$ | 子任务分值 |\n| :--------: | :-----: | :-----: | :--------: | :--: |\n|    $1$     | $\\le32$ |  $<n$   |    $=0$    | $2$  |\n|    $2$     | $\\le32$ |  $=0$   |    $<P$    | $2$  |\n|    $3$     | $\\le32$ |  $<n$   |    $=1$    | $3$  |\n|    $4$     | $\\le5$  |  $<n$   |   $\\le4$   | $20$ |\n|    $5$     | $\\le32$ |  $=1$   |    $<P$    | $13$ |\n|    $6$     | $\\le32$ | $=n-1$  |    $<P$    | $10$ |\n|    $7$     | $\\le32$ | $\\le16$ |    $<P$    | $20$ |\n|    $8$     | $\\le25$ |  $<n$   |    $<P$    | $10$ |\n|    $9$     | $\\le32$ |  $<n$   |    $<P$    | $20$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「GLR-R3」清明", "background": "&emsp;&emsp;「&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;，&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;」\n\n---\n\n&emsp;&emsp;“你非说这不是我的实力，那凭什么一个偶然错音就不能毁了我的命运？！”\n\n&emsp;&emsp;天依没有注意到，心中所哭嚎向的那个人，同她一样撑着伞，身后十来步而已。\n\n---\n\n&emsp;&emsp;**清明**　「你在名为弱小的深渊　究竟看见过什么」", "description": "雨打在窗沿，下坠，一级一级。\n\n这里一共有 $n$ 级窗沿，从高到低编号，最高层编号为 $1$，最底层编号为 $n$。假设在某一瞬间，第 $i$ 级窗沿上有 $a_i$ 单位体积的雨水。由于奇妙的物理原因，第 $i$ 级的雨水将在「下一个瞬间」滴向第 $i+1,i+2,\\dots,\\min\\{i+k,n\\}$ 级，也可能留在第 $i$ 级，但是每一种去向的雨水的单位体积都应是非负整数，且总和为 $a_i$。\n\n设在「下一个瞬间」，第 $i$ 级窗沿上有 $a_i'$ 单位的雨水，那么称此时雨水的**奇妙度**为 $\\prod_{i=1}^n a_i'$。现在，悲伤的人儿想知道，对于所有**本质不同的**「下一个瞬间」，雨水的奇妙度之和对素数 $P=998244353$ 取模的结果。\n\n两个「下一个瞬间」本质不同，当且仅当存在编号 $i<j$ 的两级窗沿，从窗沿 $i$ 滴向窗沿 $j$ 的雨水的单位体积不同。", "inputFormat": "第一行输入两个正整数 $n,k$，分别表示窗沿的数量、限制雨点滴落距离的常数。\n\n第二行输入 $n$ 个非负整数 $a_1,a_2,a_3,\\cdots,a_n$，其中 $a_i$ 表示第 $i$ 级窗沿在这一瞬间的雨水体积。", "outputFormat": "输出一行一个整数，表示所有本质不同的「下一个瞬间」，雨水的奇妙度之和对 $P$ 取模后的结果。", "hint": "#### 样例 #1 解释\n\n容易发现总共只有一种本质不同的「下一个瞬间」，也就是每级窗沿都没有雨水向其他窗沿滴落。\n\n所以最终 $a'=\\{2,2,2\\}$，权值为 $8$。\n\n#### 样例 #2 解释\n\n设 $c_k$ 表示从第 $k$ 级窗沿滴向第 $k+1$ 级窗沿的雨点体积，显然有 $c_3=0$。\n\n枚举所有合法的滴落情况：\n\n- $c=\\{0,0,0\\},b=\\{2,2,2\\}$，权值为 $8$；\n- $c=\\{0,1,0\\},b=\\{2,1,3\\}$，权值为 $6$；\n- $c=\\{0,2,0\\},b=\\{2,0,4\\}$，权值为 $0$；\n- $c=\\{1,0,0\\},b=\\{1,3,2\\}$，权值为 $6$；\n- $c=\\{1,1,0\\},b=\\{1,2,3\\}$，权值为 $6$；\n- $c=\\{1,2,0\\},b=\\{1,1,4\\}$，权值为 $4$；\n- $c_1=2$，此时必然有 $b_1=0$，此情况下的三种方案权值均为 $0$；\n\n所以所有本质不同的「下一个瞬间」的权值和为 $8+6+0+6+6+4+0+0+0=30$。\n\n### 数据规模与约定\n\n**本题采用 Subtask 的计分方式。**\n\n对于 $100\\%$ 的数据，$0\\le k<n\\le 32$，$0\\le a_i<P$。\n\n对于不同的子任务，作如下约定：\n\n| 子任务编号 |   $n$   |   $k$   | $\\max a_i$ | 子任务分值 |\n| :--------: | :-----: | :-----: | :--------: | :--: |\n|    $1$     | $\\le32$ |  $<n$   |    $=0$    | $2$  |\n|    $2$     | $\\le32$ |  $=0$   |    $<P$    | $2$  |\n|    $3$     | $\\le32$ |  $<n$   |    $=1$    | $3$  |\n|    $4$     | $\\le5$  |  $<n$   |   $\\le4$   | $20$ |\n|    $5$     | $\\le32$ |  $=1$   |    $<P$    | $13$ |\n|    $6$     | $\\le32$ | $=n-1$  |    $<P$    | $10$ |\n|    $7$     | $\\le32$ | $\\le16$ |    $<P$    | $20$ |\n|    $8$     | $\\le25$ |  $<n$   |    $<P$    | $10$ |\n|    $9$     | $\\le32$ |  $<n$   |    $<P$    | $20$ |\n", "locale": "zh-CN"}}}
{"pid": "P8479", "type": "P", "difficulty": 7, "samples": [["0\n5\n1 2 3 4 5\n1 2 2 1\n5\n1 1 2\n0 2 3 -2\n1 3 4\n0 4 4 1\n1 3 4\n", "15\n0\n1"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "O2优化", "洛谷月赛"], "title": "「GLR-R3」谷雨", "background": "&emsp;&emsp;「几枝新叶萧萧竹，数笔横皴淡淡山」\n\n---\n\n&emsp;&emsp;十几天前的那条路，还好，两个人一起。\n\n&emsp;&emsp;“很幸运呢”，阿绫悄悄嘬一口才破涕为笑的天依，“上天保佑我们要在一……”\n\n&emsp;&emsp;鼓着腮掐着软软的腰，天依却又不觉流露笑意，是很幸运呢，刚好入围……\n\n&emsp;&emsp;鳞次栉比的尽头，天空似云下起伏的山，皴擦着淡青墨样的欣喜。\n\n&emsp;&emsp;她们的故事还在继续，正如谷物正当在今日生长。\n\n---\n\n&emsp;&emsp;**谷雨**&emsp;「我翻过一座高山　前方依然　山路漫漫」", "description": "老 V 为发挥不错的大家办了场小 party，为了活跃气氛，同时贯彻安全环保的理念，~~（主要还是因为编不出来了，）~~ 老 V 带来了一个高大上的“电子烟花”，美其名曰，火**树**银花。\n\n物如其名，这是一棵含有 $n$ 个结点的树，结点 $u$ 上有点权 $l_u$，表示该结点上所设烟花样式的**绚丽度**。好奇的大家一共对它进行了 $q$ 次操作，不妨记树上从 $u$ 到 $v$ 的路径上的结点（含 $u,v$）构成集合 $P(u,v)$，则每次操作形如：\n\n0. 给定结点编号 $u,v$ 和新的绚丽度 $k$，意为将所有 $\\in P(u,v)$，**或者**存在一个邻接点 $\\in P(u,v)$ 的结点 $w$ 的绚丽度 $l_w$ **赋值**为 $k$。\n\n1. 给定 $u,v$，点燃这一串烟花最“耀眼”的子段。具体地，维护一个**序列** $S$，从 $u$ 出发沿着树边走向 $v$，当走到结点 $w$（$w$ 可能为 $u$ 或 $v$） 时：\n\n    - 将 $l_w$ 加入序列 $S$ 的末尾；\n    - **按标号从小到大**枚举 $w$ 的邻接点 $x$，若 $x\\notin P(u,v)$，将 $l_x$ 加入 $S$ 的末尾；\n    - 最后，走向下一个结点。\n\n得到最终的 $S$ 后，系统将自动点燃 $S$ 中绚丽度之和最大的子段，子段可能为空。而你需要求出这一和的最大值，即对于每次 1. 操作，求出 $S$ 的**最大可空子段和**。", "inputFormat": "第一行一个整数 $T$，表示该测试数据所属的子任务编号。\n\n第二行一个整数 $n$，表示树的结点个数。\n\n第三行 $n$ 个整数，第 $i$ 个整数 $l_i$ 表示结点 $i$ 的初始权值。\n\n第四行 $n-1$ 个整数，**为方便选手处理数据，此处假设 $1$ 号结点为树的根。** 第 $i$ 个整数 $p_i$ 表示结点 $i+1$ 的父亲，即表述一条边 $(p_i,i+1)$。**保证 $p_i<i+1$**。\n\n第五行一个整数 $q$，表示需要处理的操作数量。\n\n接下来 $q$ 行，每行格式为 $0~u~v~k$ 或者 $1~u~v$，分别对应了「题目描述」中的两种操作。", "outputFormat": "输出有若干行，第 $i$ 行应包含一个整数 $a_i$，表示第 $i$ 次 1. 操作的答案。", "hint": "#### 样例 #1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2szx2kdy.png)\n\n本组样例不属于测试数据，故第一行 $T$ 以 $0$ 代替。\n\n第 $1$ 次操作为询问，依次遍历到的结点为 $\\lang 1,5,2,3,4\\rang$，对应权值队列 $S=\\lang 1,5,2,3,4\\rang$，最大子段和为 $15$。\n\n第 $2$ 次操作为修改，将结点 $2,1,4,3$ 的点权修改为 $-2$。\n\n第 $3$ 次操作为询问，依次遍历到的结点为 $\\lang 3,2,1,4\\rang$，对应权值队列 $S=\\lang -2,-2,-2,-2\\rang$，注意子段可以为空，所以最大子段和为 $0$。\n\n第 $4$ 次操作为修改，将结点 $4,2$ 的点权修改为 $1$。\n\n第 $5$ 次操作为询问，依次遍历到的结点为 $\\lang 3,2,1,4\\rang$，对应权值队列 $S=\\lang -2,1,-2,1\\rang$，最大子段和为 $1$。\n\n### 数据规模与约定\n\n**本题采用 Subtask 的计分方式。**\n\n设 $V$ 为初始点权以及修改操作中点权的值域。\n\n对于 $100\\%$ 的数据，$1\\le n,q\\le10^5$，$1\\le p_i\\le i$，$V\\subseteq[-10^9,10^9]$，操作参数 $1\\le u,v\\le n$。\n\n对于不同的子任务，作如下约定：\n\n| 子任务编号 |   $n,q$   |       $V$       | 特殊性质 | 子任务分值 |\n| :--------: | :-------: | :-------------: | :------: | :--------: |\n|    $1$     | $\\le10^3$ | $\\subseteq[-10^9,10^9]$ |    无    |    $10$    |\n|    $2$     | $\\le10^5$ | $\\subseteq[-10^9,10^9]$ |  **A**   |    $10$    |\n|    $3$     | $\\le10^5$ | $\\subseteq[-10^9,10^9]$ |  **B**   |    $10$    |\n|    $4$     | $\\le10^5$ | $\\subseteq[-10^9,10^9]$ |  **C**   |    $15$    |\n|    $5$     | $\\le10^5$ | $\\subseteq[-10^9,10^9]$ |  **D**   |    $15$    |\n|    $6$     | $\\le10^5$ |   $\\subseteq[0,10^9]$   |    无    |    $10$    |\n|    $7$     | $\\le10^5$ | $\\subseteq[-10^9,10^9]$ |  **E**   |    $20$    |\n|    $8$     | $\\le10^5$ | $\\subseteq[-10^9,10^9]$ |    无    |    $10$    |\n\n- **特殊性质 A**：对于所有 $i\\in[1,n)$，满足 $p_i=i$。\n- **特殊性质 B**：对于所有操作中的参数 $u,v$，满足 $u=v$。\n- **特殊性质 C**：不存在修改操作。\n- **特殊性质 D**：有且仅有第 $q$ 次操作是询问操作。\n- **特殊性质 E**：对于所有**询问操作**中的参数 $u,v$，满足当结点 $1$ 为树根时，$u=v$ 或 $u$ 是 $v$ 的祖先。\n- **注意**：输入数据中的 $T$ 仅指该数据点所属子任务编号，该数据点可能满足其他子任务的约束条件。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「GLR-R3」谷雨", "background": "&emsp;&emsp;「几枝新叶萧萧竹，数笔横皴淡淡山」\n\n---\n\n&emsp;&emsp;十几天前的那条路，还好，两个人一起。\n\n&emsp;&emsp;“很幸运呢”，阿绫悄悄嘬一口才破涕为笑的天依，“上天保佑我们要在一……”\n\n&emsp;&emsp;鼓着腮掐着软软的腰，天依却又不觉流露笑意，是很幸运呢，刚好入围……\n\n&emsp;&emsp;鳞次栉比的尽头，天空似云下起伏的山，皴擦着淡青墨样的欣喜。\n\n&emsp;&emsp;她们的故事还在继续，正如谷物正当在今日生长。\n\n---\n\n&emsp;&emsp;**谷雨**&emsp;「我翻过一座高山　前方依然　山路漫漫」", "description": "老 V 为发挥不错的大家办了场小 party，为了活跃气氛，同时贯彻安全环保的理念，~~（主要还是因为编不出来了，）~~ 老 V 带来了一个高大上的“电子烟花”，美其名曰，火**树**银花。\n\n物如其名，这是一棵含有 $n$ 个结点的树，结点 $u$ 上有点权 $l_u$，表示该结点上所设烟花样式的**绚丽度**。好奇的大家一共对它进行了 $q$ 次操作，不妨记树上从 $u$ 到 $v$ 的路径上的结点（含 $u,v$）构成集合 $P(u,v)$，则每次操作形如：\n\n0. 给定结点编号 $u,v$ 和新的绚丽度 $k$，意为将所有 $\\in P(u,v)$，**或者**存在一个邻接点 $\\in P(u,v)$ 的结点 $w$ 的绚丽度 $l_w$ **赋值**为 $k$。\n\n1. 给定 $u,v$，点燃这一串烟花最“耀眼”的子段。具体地，维护一个**序列** $S$，从 $u$ 出发沿着树边走向 $v$，当走到结点 $w$（$w$ 可能为 $u$ 或 $v$） 时：\n\n    - 将 $l_w$ 加入序列 $S$ 的末尾；\n    - **按标号从小到大**枚举 $w$ 的邻接点 $x$，若 $x\\notin P(u,v)$，将 $l_x$ 加入 $S$ 的末尾；\n    - 最后，走向下一个结点。\n\n得到最终的 $S$ 后，系统将自动点燃 $S$ 中绚丽度之和最大的子段，子段可能为空。而你需要求出这一和的最大值，即对于每次 1. 操作，求出 $S$ 的**最大可空子段和**。", "inputFormat": "第一行一个整数 $T$，表示该测试数据所属的子任务编号。\n\n第二行一个整数 $n$，表示树的结点个数。\n\n第三行 $n$ 个整数，第 $i$ 个整数 $l_i$ 表示结点 $i$ 的初始权值。\n\n第四行 $n-1$ 个整数，**为方便选手处理数据，此处假设 $1$ 号结点为树的根。** 第 $i$ 个整数 $p_i$ 表示结点 $i+1$ 的父亲，即表述一条边 $(p_i,i+1)$。**保证 $p_i<i+1$**。\n\n第五行一个整数 $q$，表示需要处理的操作数量。\n\n接下来 $q$ 行，每行格式为 $0~u~v~k$ 或者 $1~u~v$，分别对应了「题目描述」中的两种操作。", "outputFormat": "输出有若干行，第 $i$ 行应包含一个整数 $a_i$，表示第 $i$ 次 1. 操作的答案。", "hint": "#### 样例 #1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2szx2kdy.png)\n\n本组样例不属于测试数据，故第一行 $T$ 以 $0$ 代替。\n\n第 $1$ 次操作为询问，依次遍历到的结点为 $\\lang 1,5,2,3,4\\rang$，对应权值队列 $S=\\lang 1,5,2,3,4\\rang$，最大子段和为 $15$。\n\n第 $2$ 次操作为修改，将结点 $2,1,4,3$ 的点权修改为 $-2$。\n\n第 $3$ 次操作为询问，依次遍历到的结点为 $\\lang 3,2,1,4\\rang$，对应权值队列 $S=\\lang -2,-2,-2,-2\\rang$，注意子段可以为空，所以最大子段和为 $0$。\n\n第 $4$ 次操作为修改，将结点 $4,2$ 的点权修改为 $1$。\n\n第 $5$ 次操作为询问，依次遍历到的结点为 $\\lang 3,2,1,4\\rang$，对应权值队列 $S=\\lang -2,1,-2,1\\rang$，最大子段和为 $1$。\n\n### 数据规模与约定\n\n**本题采用 Subtask 的计分方式。**\n\n设 $V$ 为初始点权以及修改操作中点权的值域。\n\n对于 $100\\%$ 的数据，$1\\le n,q\\le10^5$，$1\\le p_i\\le i$，$V\\subseteq[-10^9,10^9]$，操作参数 $1\\le u,v\\le n$。\n\n对于不同的子任务，作如下约定：\n\n| 子任务编号 |   $n,q$   |       $V$       | 特殊性质 | 子任务分值 |\n| :--------: | :-------: | :-------------: | :------: | :--------: |\n|    $1$     | $\\le10^3$ | $\\subseteq[-10^9,10^9]$ |    无    |    $10$    |\n|    $2$     | $\\le10^5$ | $\\subseteq[-10^9,10^9]$ |  **A**   |    $10$    |\n|    $3$     | $\\le10^5$ | $\\subseteq[-10^9,10^9]$ |  **B**   |    $10$    |\n|    $4$     | $\\le10^5$ | $\\subseteq[-10^9,10^9]$ |  **C**   |    $15$    |\n|    $5$     | $\\le10^5$ | $\\subseteq[-10^9,10^9]$ |  **D**   |    $15$    |\n|    $6$     | $\\le10^5$ |   $\\subseteq[0,10^9]$   |    无    |    $10$    |\n|    $7$     | $\\le10^5$ | $\\subseteq[-10^9,10^9]$ |  **E**   |    $20$    |\n|    $8$     | $\\le10^5$ | $\\subseteq[-10^9,10^9]$ |    无    |    $10$    |\n\n- **特殊性质 A**：对于所有 $i\\in[1,n)$，满足 $p_i=i$。\n- **特殊性质 B**：对于所有操作中的参数 $u,v$，满足 $u=v$。\n- **特殊性质 C**：不存在修改操作。\n- **特殊性质 D**：有且仅有第 $q$ 次操作是询问操作。\n- **特殊性质 E**：对于所有**询问操作**中的参数 $u,v$，满足当结点 $1$ 为树根时，$u=v$ 或 $u$ 是 $v$ 的祖先。\n- **注意**：输入数据中的 $T$ 仅指该数据点所属子任务编号，该数据点可能满足其他子任务的约束条件。", "locale": "zh-CN"}}}
{"pid": "P8480", "type": "P", "difficulty": 1, "samples": [["3 2\n0 1 0 ", "6"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["贪心", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「HGOI-1」PMTD", "background": " $\\text{uuku}$ 在学习[四则运算](https://baike.baidu.com/item/%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/5337481?fr=aladdin)！", "description": "为了验证 $\\text{uuku}$ 学习成果，$\\text{bh1234666}$ 给出一个长为 $n$ 整数序列 $a_i$。并让 $\\text{uuku}$ 给这个序列进行 $m$ 次操作。\n\n每次操作可以任意选择序列中一个数 $a_i$，令 $a_i$ 变成 $a_i+2$，$a_i-2$，$a_i\\times 2$，$\\lfloor\\frac{a_i}{2}\\rfloor$ 这四个结果中的一个。\n\n$\\text{bh1234666}$ 希望 $m$ 次操作后，整个序列的极差（最大值减最小值）最大。\n\n显然 $\\text{uuku}$ 没有认真学习，所以他希望你来帮他回答这个问题。", "inputFormat": "第一行两个整数 $n$，$m$。\n\n第二行 $n$ 个整数，表示序列 $a_i$。", "outputFormat": "共一行一个整数，表示最大的极差。", "hint": "#### 样例解释\n\n第一步操作：将 $1$ 加上 $2$ 得到 $3$。\n\n第二步操作：将 $3$ 乘以 $2$ 得到 $6$。\n\n极差为 $6-0=6$。\n\n#### 数据范围\n\n本题采用**捆绑测试**，共有 $2$ 个 $\\text{subtask}$，最终分数为所有 $\\text{subtask}$ 分数之和。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{Task} & \\textbf{Score} & \\textbf{特殊限制} \\cr\\hline\n1 & 40 & n \\le 5,m \\le 5 \\cr\\hline\n2 & 60 &  \\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 10^6$，$1 \\le m \\le 10$，$0 \\le a_i \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「HGOI-1」PMTD", "background": " $\\text{uuku}$ 在学习[四则运算](https://baike.baidu.com/item/%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/5337481?fr=aladdin)！", "description": "为了验证 $\\text{uuku}$ 学习成果，$\\text{bh1234666}$ 给出一个长为 $n$ 整数序列 $a_i$。并让 $\\text{uuku}$ 给这个序列进行 $m$ 次操作。\n\n每次操作可以任意选择序列中一个数 $a_i$，令 $a_i$ 变成 $a_i+2$，$a_i-2$，$a_i\\times 2$，$\\lfloor\\frac{a_i}{2}\\rfloor$ 这四个结果中的一个。\n\n$\\text{bh1234666}$ 希望 $m$ 次操作后，整个序列的极差（最大值减最小值）最大。\n\n显然 $\\text{uuku}$ 没有认真学习，所以他希望你来帮他回答这个问题。", "inputFormat": "第一行两个整数 $n$，$m$。\n\n第二行 $n$ 个整数，表示序列 $a_i$。", "outputFormat": "共一行一个整数，表示最大的极差。", "hint": "#### 样例解释\n\n第一步操作：将 $1$ 加上 $2$ 得到 $3$。\n\n第二步操作：将 $3$ 乘以 $2$ 得到 $6$。\n\n极差为 $6-0=6$。\n\n#### 数据范围\n\n本题采用**捆绑测试**，共有 $2$ 个 $\\text{subtask}$，最终分数为所有 $\\text{subtask}$ 分数之和。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{Task} & \\textbf{Score} & \\textbf{特殊限制} \\cr\\hline\n1 & 40 & n \\le 5,m \\le 5 \\cr\\hline\n2 & 60 &  \\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 10^6$，$1 \\le m \\le 10$，$0 \\le a_i \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P8481", "type": "P", "difficulty": 2, "samples": [["10\n1 2 4 6 7 8 10 13 15 17\n3\n4\n10\n15", "3\n3\n3"], ["13\n1 2 4 6 10 12 19 23 45 99 101 123 134\n5\n1\n2\n10\n19\n123\n", "3\n4\n3\n3\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["二分", "洛谷原创", "O2优化", "深度优先搜索 DFS", "洛谷月赛"], "title": "「HGOI-1」Binary search", "background": "$\\text{bh1234666}$ 正在学习[二分查找](https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/10628618?fr=aladdin)。", "description": "众所周知二分查找的 $\\text{mid}$ 在计算时可以取 $\\lfloor\\dfrac{l+r}{2}\\rfloor$ 或者 $\\lceil\\dfrac{l+r}{2}\\rceil$，于是有选择困难症的 $\\text{bh1234666}$ 同学在自己的二分查找代码中加入了随机化，每次随机选取其中的一个作为 $\\textit{mid}$。\n\n注意，选取不同的 mid 其他参数也会受到影响，请以代码为准。\n\n现在 $\\text{bh1234666}$ 给你了二分查找使用的序列（保证为单调递增）以及他想要寻找的数（保证在序列内），他想知道在运气最好的情况下循环需要进行几次（即代码中 $\\textit{cnt}$ 的可能的最终值的最小值）。\n\n循环：\n```cpp\nint find(int *num,int x,int len)\n{\n\tint l=0,r=len-1,mid,cnt=0,w;\n\twhile(l<r)\n\t{\n\t\tcnt++;\n\t\tw=rand()%2;\n\t\tmid=(l+r+w)/2;\n\t\tif(num[mid]-w<x) l=mid+!w;\n\t\telse r=mid-w;\n\t}\n\treturn mid;\n}\n```\n递归：\n```\nint cnt;\nint get(int *num,int x,int l,int r)\n{\n\tif(l==r) return l;\n\tcnt++;\n\tint w=rand()%2;\n\tint mid=(l+r+w)/2;\n\tif(num[mid]-w<x) return get(num,x,mid+!w,r);\n\telse return get(num,x,l,mid-w);\n}\nint find(int *num,int x,int len)\n{\n\tcnt=0;\n\treturn get(num,x,0,len-1);\n}\n```\n注：以上两代码完全等价。\n\n在此对上述代码中的 $w$ 的作用做进一步阐释。\n\n例如对于区间 $[0,7]$，有 $8$ 个成员。虽然 $mid$ 的取值会因为 $w$ 的取值改变而改变，但是最终确定的区间一定是 $[0,3]$ 或 $[4,7]$，选手可以就上述代码自行模拟。\n\n对于区间 $[0,6]$，有 $7$ 个成员。$\\textit{mid}$ 的取值与 $w$ 的取值无关，但是 $l$ 和 $r$ 的取值会受到 $w$ 的影响，最终确定的区间可能是 $[0,2]$，$[3,6]$（$w=1$）或 $[0,3]$，$[4,6]$（$w=0$）。", "inputFormat": "第一行给出一个整数 $n$ 表示序列长度。\n\n第二行给出单调递增的 $n$ 个整数表示 $\\text{bh1234666}$ 的序列。\n\n第三行一个整数 $q$ 表示询问的次数。\n\n接下来 $q$ 行每行一个整数表示需要查询的数字。", "outputFormat": "对于每个询问回答一个整数，表示最小的循环次数。", "hint": "### 样例 1 解释\n\n找 $4$：\n\n取 $[1,5]$。\n\n取 $[1,3]$。\n\n取 $[3,3]$（退出循环）。\n\n### 样例 2 解释\n\n查询 $10$ 的位置。\n\n$$\n[1,13] \\stackrel{w=0}{\\longrightarrow} [1,7]\\stackrel{w=0}{\\longrightarrow}[5,7] \\stackrel{w=1}{\\longrightarrow} [5,5]\n$$\n\n### 数据范围及约定\n本题采用**捆绑测试**，共有 $3$ 个 $\\text{subtask}$，最终分数为所有 $\\text{subtask}$ 分数之和。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{Task} & \\textbf{Score} & \\text{特殊限制} \\cr\\hline\n1 & 25 & n \\le 20 \\cr\\hline\n2 & 35 & n=2^k(k \\in \\mathbf{N}) \\cr\\hline\n3 & 40 &  \\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，保证 $1 \\le n \\le 2^{20}$，$1 \\le q \\le 100$，$1 \\le num_i \\le 10^9$。\n\n本题有 [extra sub](https://www.luogu.com.cn/problem/P8487)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「HGOI-1」Binary search", "background": "$\\text{bh1234666}$ 正在学习[二分查找](https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/10628618?fr=aladdin)。", "description": "众所周知二分查找的 $\\text{mid}$ 在计算时可以取 $\\lfloor\\dfrac{l+r}{2}\\rfloor$ 或者 $\\lceil\\dfrac{l+r}{2}\\rceil$，于是有选择困难症的 $\\text{bh1234666}$ 同学在自己的二分查找代码中加入了随机化，每次随机选取其中的一个作为 $\\textit{mid}$。\n\n注意，选取不同的 mid 其他参数也会受到影响，请以代码为准。\n\n现在 $\\text{bh1234666}$ 给你了二分查找使用的序列（保证为单调递增）以及他想要寻找的数（保证在序列内），他想知道在运气最好的情况下循环需要进行几次（即代码中 $\\textit{cnt}$ 的可能的最终值的最小值）。\n\n循环：\n```cpp\nint find(int *num,int x,int len)\n{\n\tint l=0,r=len-1,mid,cnt=0,w;\n\twhile(l<r)\n\t{\n\t\tcnt++;\n\t\tw=rand()%2;\n\t\tmid=(l+r+w)/2;\n\t\tif(num[mid]-w<x) l=mid+!w;\n\t\telse r=mid-w;\n\t}\n\treturn mid;\n}\n```\n递归：\n```\nint cnt;\nint get(int *num,int x,int l,int r)\n{\n\tif(l==r) return l;\n\tcnt++;\n\tint w=rand()%2;\n\tint mid=(l+r+w)/2;\n\tif(num[mid]-w<x) return get(num,x,mid+!w,r);\n\telse return get(num,x,l,mid-w);\n}\nint find(int *num,int x,int len)\n{\n\tcnt=0;\n\treturn get(num,x,0,len-1);\n}\n```\n注：以上两代码完全等价。\n\n在此对上述代码中的 $w$ 的作用做进一步阐释。\n\n例如对于区间 $[0,7]$，有 $8$ 个成员。虽然 $mid$ 的取值会因为 $w$ 的取值改变而改变，但是最终确定的区间一定是 $[0,3]$ 或 $[4,7]$，选手可以就上述代码自行模拟。\n\n对于区间 $[0,6]$，有 $7$ 个成员。$\\textit{mid}$ 的取值与 $w$ 的取值无关，但是 $l$ 和 $r$ 的取值会受到 $w$ 的影响，最终确定的区间可能是 $[0,2]$，$[3,6]$（$w=1$）或 $[0,3]$，$[4,6]$（$w=0$）。", "inputFormat": "第一行给出一个整数 $n$ 表示序列长度。\n\n第二行给出单调递增的 $n$ 个整数表示 $\\text{bh1234666}$ 的序列。\n\n第三行一个整数 $q$ 表示询问的次数。\n\n接下来 $q$ 行每行一个整数表示需要查询的数字。", "outputFormat": "对于每个询问回答一个整数，表示最小的循环次数。", "hint": "### 样例 1 解释\n\n找 $4$：\n\n取 $[1,5]$。\n\n取 $[1,3]$。\n\n取 $[3,3]$（退出循环）。\n\n### 样例 2 解释\n\n查询 $10$ 的位置。\n\n$$\n[1,13] \\stackrel{w=0}{\\longrightarrow} [1,7]\\stackrel{w=0}{\\longrightarrow}[5,7] \\stackrel{w=1}{\\longrightarrow} [5,5]\n$$\n\n### 数据范围及约定\n本题采用**捆绑测试**，共有 $3$ 个 $\\text{subtask}$，最终分数为所有 $\\text{subtask}$ 分数之和。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{Task} & \\textbf{Score} & \\text{特殊限制} \\cr\\hline\n1 & 25 & n \\le 20 \\cr\\hline\n2 & 35 & n=2^k(k \\in \\mathbf{N}) \\cr\\hline\n3 & 40 &  \\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，保证 $1 \\le n \\le 2^{20}$，$1 \\le q \\le 100$，$1 \\le num_i \\le 10^9$。\n\n本题有 [extra sub](https://www.luogu.com.cn/problem/P8487)。", "locale": "zh-CN"}}}
{"pid": "P8482", "type": "P", "difficulty": 4, "samples": [["1 2 3 2 1 1 2 1 2 1", "13949030\n620572547"]], "limits": {"time": [750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "高精度", "洛谷原创", "Special Judge", "O2优化", "洛谷月赛"], "title": "「HGOI-1」Number", "background": "$\\text{bh1234666}$ 正在学习乘法！", "description": "$\\text{bh1234666}$ 有一定数量的数字 $0 \\sim 9$，现在他想让你寻找一种分配方案，将它们分成两个整数，使得他们的乘积 $p$ 最大。\n \n由于 $\\text{bh1234666}$ 不喜欢太大的数，所以你只需要输出**两个非负整数**，使它们的乘积**等于**最大乘积 $p$，但是这两个整数 $0 \\sim 9$ 的数量不能等于给定的数量（任意一个数字数量不相等即可，**不考虑前导零**）。\n\n$\\text{bh1234666}$ 是很善良的，如果 $0 \\sim 9$ 的数量等于给定的数量了，你依旧可以得到的一半的分。", "inputFormat": "第一行十个整数 $c_0,c_1,\\cdots c_9$，分别表示 $0 \\sim 9$ 的个数。", "outputFormat": "共两行每行一个非负整数，分别表示你给出的两个非负整数。", "hint": "#### 样例解释\n最大可能乘积为 $97643210 \\times 88653221=13949030 \\times 620572547=8656385075279410$。\n\n若输出 $97643210 \\times 88653221$ 则只能得到一半的分，因为 $0\\sim 9$ 出现的次数与给定的相同。\n\n#### 数据范围及约定\n本题采用**捆绑测试**，共有 $5$ 个 $\\text{subtask}$，最终分数为所有 $\\text{subtask}$ 分数之和。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{Task} & \\textbf{Score} & \\sum c_i\\le \\cr\\hline\n1 & 10 & 20 \\cr\\hline\n2 & 20 & 100 \\cr\\hline\n3 & 20 & 5000 \\cr\\hline\n4 & 20 & 10^6 \\cr\\hline\n5 & 30 & 10^7 \\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，保证 $1 \\le c_i$，$\\sum c_i \\le 10^7$。\n\n#### 说明\n\n本题有 $\\text{spj}$，两数乘积正确得一半的分，数量与给出的不同且乘积正确得全部分数。故每一 $\\text{subtask}$ 的得分为其中所有数据点得分的**最小值**。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「HGOI-1」Number", "background": "$\\text{bh1234666}$ 正在学习乘法！", "description": "$\\text{bh1234666}$ 有一定数量的数字 $0 \\sim 9$，现在他想让你寻找一种分配方案，将它们分成两个整数，使得他们的乘积 $p$ 最大。\n \n由于 $\\text{bh1234666}$ 不喜欢太大的数，所以你只需要输出**两个非负整数**，使它们的乘积**等于**最大乘积 $p$，但是这两个整数 $0 \\sim 9$ 的数量不能等于给定的数量（任意一个数字数量不相等即可，**不考虑前导零**）。\n\n$\\text{bh1234666}$ 是很善良的，如果 $0 \\sim 9$ 的数量等于给定的数量了，你依旧可以得到的一半的分。", "inputFormat": "第一行十个整数 $c_0,c_1,\\cdots c_9$，分别表示 $0 \\sim 9$ 的个数。", "outputFormat": "共两行每行一个非负整数，分别表示你给出的两个非负整数。", "hint": "#### 样例解释\n最大可能乘积为 $97643210 \\times 88653221=13949030 \\times 620572547=8656385075279410$。\n\n若输出 $97643210 \\times 88653221$ 则只能得到一半的分，因为 $0\\sim 9$ 出现的次数与给定的相同。\n\n#### 数据范围及约定\n本题采用**捆绑测试**，共有 $5$ 个 $\\text{subtask}$，最终分数为所有 $\\text{subtask}$ 分数之和。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{Task} & \\textbf{Score} & \\sum c_i\\le \\cr\\hline\n1 & 10 & 20 \\cr\\hline\n2 & 20 & 100 \\cr\\hline\n3 & 20 & 5000 \\cr\\hline\n4 & 20 & 10^6 \\cr\\hline\n5 & 30 & 10^7 \\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，保证 $1 \\le c_i$，$\\sum c_i \\le 10^7$。\n\n#### 说明\n\n本题有 $\\text{spj}$，两数乘积正确得一半的分，数量与给出的不同且乘积正确得全部分数。故每一 $\\text{subtask}$ 的得分为其中所有数据点得分的**最小值**。\n", "locale": "zh-CN"}}}
{"pid": "P8483", "type": "P", "difficulty": 4, "samples": [["4 4\n1 2 3\n2 3 4\n3 4 5\n4 5 6", "114\n1 2\n1 2\n1 3\n3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "贪心", "二分", "堆", "洛谷原创", "Special Judge", "O2优化", "构造", "洛谷月赛"], "title": "「HGOI-1」Build", "background": "一次旅行，$\\text{uuku}$ 到了一个奇怪的小镇。", "description": "这个小镇将要和周围的其他小镇一共 $n$ 个小镇，一起修建一个能**连通**这 $n$ 个小镇，有 $m$ 条高速公路的交通网。其中每条高速公路都将会连接**不同的两个小镇**，即不存在一条高速公路的起点和终点相同。\n\n但高速公路的修建费用是很高的，所以镇长们一致决定将共同承担高速公路的费用，所以他们希望修建的**总费用最小**。\n\n而且由于不同小镇的基础设施建设情况不同，所以每个小镇在修建的费用也不同。经过协商，每条高速公路将由其所连接的两个小镇共同施工。每个小镇负责一半路程。为了同时结束整个施工过程，显然将会有小镇同时进行多条道路的施工，而施工的道路数量越多，所需要花费的价钱就越多。\n\n经过计算，每个小镇施工的花费可以用函数表示，及对于小镇 $i$，有三个参数 $a_i$，$b_i$，$c_i$。对于 $i$ 小镇来说在修建其第 $j$ 条高速时，**这条**高速所需要的花费为 $a_ij^2+b_ij+c_i$。\n\n现在，这些镇长想要 $\\text{uuku}$ 给他们提供一个满足要求的**建造方案**，使**总价格最小**。\n\n当然，$\\text{uuku}$ 将这个问题交给了你。", "inputFormat": "第一行两个整数 $n$，$m$。\n\n接下来 $n$ 行，每行三个整数 $a_i$，$b_i$，$c_i$。", "outputFormat": "共 $m+1$ 行\n\n第一行一个整数表示最小价格。\n\n接下来 $m$ 行，每行两个整数 $u$，$v$，表示你提供的方案中的一条边。", "hint": "#### 数据范围\n本题采用**捆绑测试**，共有 $6$ 个 $\\text{subtask}$，最终分数为所有 $\\text{subtask}$ 分数之和。\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{Task} & \\textbf{Score} & \\textbf{特殊限制} \\cr\\hline\n1 & 10 & n,m\\le 500  \\cr\\hline\n2 & 20 &  n,m\\le 5\\times 10^3 \\cr\\hline\n3 & 10 & \\text{每个小镇的函数相同}\\cr\\hline\n4 & 20 & a_i=0 \\cr\\hline\n5 & 20 & m=n-1 \\cr\\hline\n6 & 20 & \\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，$2\\le n \\le 2 \\times 10^5$， $n-1 \\le m \\le 10^6$，$0 \\le a_i$，$b_i$，$c_i \\le 10^6$。\n\n数据保证最小价格在 $\\tt{long \\ long}$ 范围内。\n\n#### 说明\n\n本题有 $\\text{spj}$，价格正确可以获得 $30\\%$ 的分数。每个 $\\text{subtask}$ 取其中所有数据点得分的最小值。\n\n如果你不会构造方案，也请你再输出最小价格后输出 $m$ 行，每行两个 $[1,n]$ 范围内的整数，防止 $\\text{spj}$ 出现错误。\n\n本题已添加 hack 数据，为 $\\text{subtask7}$，该 $\\text{subtask}$ 不计分数，但会影响是否 $\\text{AC}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「HGOI-1」Build", "background": "一次旅行，$\\text{uuku}$ 到了一个奇怪的小镇。", "description": "这个小镇将要和周围的其他小镇一共 $n$ 个小镇，一起修建一个能**连通**这 $n$ 个小镇，有 $m$ 条高速公路的交通网。其中每条高速公路都将会连接**不同的两个小镇**，即不存在一条高速公路的起点和终点相同。\n\n但高速公路的修建费用是很高的，所以镇长们一致决定将共同承担高速公路的费用，所以他们希望修建的**总费用最小**。\n\n而且由于不同小镇的基础设施建设情况不同，所以每个小镇在修建的费用也不同。经过协商，每条高速公路将由其所连接的两个小镇共同施工。每个小镇负责一半路程。为了同时结束整个施工过程，显然将会有小镇同时进行多条道路的施工，而施工的道路数量越多，所需要花费的价钱就越多。\n\n经过计算，每个小镇施工的花费可以用函数表示，及对于小镇 $i$，有三个参数 $a_i$，$b_i$，$c_i$。对于 $i$ 小镇来说在修建其第 $j$ 条高速时，**这条**高速所需要的花费为 $a_ij^2+b_ij+c_i$。\n\n现在，这些镇长想要 $\\text{uuku}$ 给他们提供一个满足要求的**建造方案**，使**总价格最小**。\n\n当然，$\\text{uuku}$ 将这个问题交给了你。", "inputFormat": "第一行两个整数 $n$，$m$。\n\n接下来 $n$ 行，每行三个整数 $a_i$，$b_i$，$c_i$。", "outputFormat": "共 $m+1$ 行\n\n第一行一个整数表示最小价格。\n\n接下来 $m$ 行，每行两个整数 $u$，$v$，表示你提供的方案中的一条边。", "hint": "#### 数据范围\n本题采用**捆绑测试**，共有 $6$ 个 $\\text{subtask}$，最终分数为所有 $\\text{subtask}$ 分数之和。\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{Task} & \\textbf{Score} & \\textbf{特殊限制} \\cr\\hline\n1 & 10 & n,m\\le 500  \\cr\\hline\n2 & 20 &  n,m\\le 5\\times 10^3 \\cr\\hline\n3 & 10 & \\text{每个小镇的函数相同}\\cr\\hline\n4 & 20 & a_i=0 \\cr\\hline\n5 & 20 & m=n-1 \\cr\\hline\n6 & 20 & \\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，$2\\le n \\le 2 \\times 10^5$， $n-1 \\le m \\le 10^6$，$0 \\le a_i$，$b_i$，$c_i \\le 10^6$。\n\n数据保证最小价格在 $\\tt{long \\ long}$ 范围内。\n\n#### 说明\n\n本题有 $\\text{spj}$，价格正确可以获得 $30\\%$ 的分数。每个 $\\text{subtask}$ 取其中所有数据点得分的最小值。\n\n如果你不会构造方案，也请你再输出最小价格后输出 $m$ 行，每行两个 $[1,n]$ 范围内的整数，防止 $\\text{spj}$ 出现错误。\n\n本题已添加 hack 数据，为 $\\text{subtask7}$，该 $\\text{subtask}$ 不计分数，但会影响是否 $\\text{AC}$。", "locale": "zh-CN"}}}
{"pid": "P8484", "type": "P", "difficulty": 6, "samples": [["5 10\n1 3 1 1 1 1 1 1 5 1", "3 5 6 7 12 16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "贪心", "线段树", "堆", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「HGOI-1」Mole", "background": "$\\text{brealid}$ 觉得普通的打地鼠游戏太过于 $\\text{simple}$ 了。所以，她设计了一款全新的打地鼠游戏。", "description": "在长度为 $l$ 的游戏窗口上，有一个长为 $t$ 的地鼠序列 $(l \\le t)$，初始序列左端与窗口左端对齐，接下来序列每秒移动一个单位长度，（即最左端的地鼠离开窗口，最右端的地鼠进入窗口），向左滚动直至玩家结束游戏或者序列最右端与窗口最右端重合（即任何时刻窗口内均应有 $l$ 只地鼠）。\n\n游戏开始的第一秒序列不会移动，不难发现游戏最多会进行 $(t-l+1)$ 秒。\n\n序列 $T$ 中的每一只地鼠都有自己的高度 $h_i$，玩家每次可以选择击打一只地鼠，玩家可以获得与地鼠高度 $h_i$ 数值相同的金币奖励，同时地鼠 $i$ 的高度 $h_i$ 会减一。\n\n经过调研，$\\text{brealid}$ 控制了游戏运行速度，使得玩家在地鼠序列移动一个单位长度的同时**最多只能打击一次**（也可以不打）。\n\n现在 $\\text{brealid}$ 告诉了你某一次游戏的窗口长度 $l$、序列长度 $t$ 以及某一局游戏中生成的地鼠高度序列 $T$。我们可爱的 $\\text{brealid}$ 想要知道，她在**任意时刻**结束游戏所能得到的**最多金币**，即在第 $1,2,\\cdots (t-l+1)$ 秒时停止游戏分别可以获得的最多金币。", "inputFormat": "第一行两个整数 $l$，$t$，表示窗口长度 $l$ 和序列长度 $t$。\n\n第二行 $t$ 个整数，表示某一局中的地鼠高度序列。", "outputFormat": "一行 $t-l+1$ 个整数 $a_1,a_2,\\cdots a_{t-l+1}$，$a_i$ 表示第 $i$ 秒时结束游戏可以获得的最多的金币数。\n", "hint": "#### 样例解释\n\n第一秒：锤 $2$，答案加 $3$。\n\n第二秒：锤 $2$，答案加 $2$。\n\n第三秒：随便锤一个，答案加 $1$。\n\n第四秒：再随便锤一个（非 $0$ 的），答案加 $1$。\n\n第五秒：锤 $9$，答案加 $5$。\n\n第六秒：锤 $9$，答案加 $4$。\n\n#### 数据范围\n\n本题采用**捆绑测试**，共有 $4$ 个 $\\text{subtask}$，最终分数为所有 $\\text{subtask}$ 分数之和。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{Task} & \\textbf{Score} & l\\le t\\le  \\cr\\hline\n1 & 10 & 10 \\cr\\hline\n2 & 20 & 500 \\cr\\hline\n3 & 30 & 5000 \\cr\\hline\n4 & 40 & 10^6 \\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，$1\\le l\\le t\\le 10^6$，$|h_i|\\le 10^9$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「HGOI-1」Mole", "background": "$\\text{brealid}$ 觉得普通的打地鼠游戏太过于 $\\text{simple}$ 了。所以，她设计了一款全新的打地鼠游戏。", "description": "在长度为 $l$ 的游戏窗口上，有一个长为 $t$ 的地鼠序列 $(l \\le t)$，初始序列左端与窗口左端对齐，接下来序列每秒移动一个单位长度，（即最左端的地鼠离开窗口，最右端的地鼠进入窗口），向左滚动直至玩家结束游戏或者序列最右端与窗口最右端重合（即任何时刻窗口内均应有 $l$ 只地鼠）。\n\n游戏开始的第一秒序列不会移动，不难发现游戏最多会进行 $(t-l+1)$ 秒。\n\n序列 $T$ 中的每一只地鼠都有自己的高度 $h_i$，玩家每次可以选择击打一只地鼠，玩家可以获得与地鼠高度 $h_i$ 数值相同的金币奖励，同时地鼠 $i$ 的高度 $h_i$ 会减一。\n\n经过调研，$\\text{brealid}$ 控制了游戏运行速度，使得玩家在地鼠序列移动一个单位长度的同时**最多只能打击一次**（也可以不打）。\n\n现在 $\\text{brealid}$ 告诉了你某一次游戏的窗口长度 $l$、序列长度 $t$ 以及某一局游戏中生成的地鼠高度序列 $T$。我们可爱的 $\\text{brealid}$ 想要知道，她在**任意时刻**结束游戏所能得到的**最多金币**，即在第 $1,2,\\cdots (t-l+1)$ 秒时停止游戏分别可以获得的最多金币。", "inputFormat": "第一行两个整数 $l$，$t$，表示窗口长度 $l$ 和序列长度 $t$。\n\n第二行 $t$ 个整数，表示某一局中的地鼠高度序列。", "outputFormat": "一行 $t-l+1$ 个整数 $a_1,a_2,\\cdots a_{t-l+1}$，$a_i$ 表示第 $i$ 秒时结束游戏可以获得的最多的金币数。\n", "hint": "#### 样例解释\n\n第一秒：锤 $2$，答案加 $3$。\n\n第二秒：锤 $2$，答案加 $2$。\n\n第三秒：随便锤一个，答案加 $1$。\n\n第四秒：再随便锤一个（非 $0$ 的），答案加 $1$。\n\n第五秒：锤 $9$，答案加 $5$。\n\n第六秒：锤 $9$，答案加 $4$。\n\n#### 数据范围\n\n本题采用**捆绑测试**，共有 $4$ 个 $\\text{subtask}$，最终分数为所有 $\\text{subtask}$ 分数之和。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{Task} & \\textbf{Score} & l\\le t\\le  \\cr\\hline\n1 & 10 & 10 \\cr\\hline\n2 & 20 & 500 \\cr\\hline\n3 & 30 & 5000 \\cr\\hline\n4 & 40 & 10^6 \\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，$1\\le l\\le t\\le 10^6$，$|h_i|\\le 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P8485", "type": "P", "difficulty": 6, "samples": [["3 9\n#...#...#\n#.#...#.#\n#########", "110916040"], ["10 20\n###...###....#######\n##..#.####.##.######\n##.##.####.#.#.#####\n#.#..##..###.#.....#\n#..##.#.#....###.#.#\n####....#.##.#..##.#\n##..###.#.#..#.##..#\n###...#..##.##..##.#\n#.#.#.##.##.##..####\n####################", "966268884"], ["10 20\n#####.######.####.##\n####.#.#####.###.###\n###.###.####.##.####\n###.###.####.#.#####\n##.#####.###..######\n##.......###.#.#####\n#..#####..##.##.####\n#.#######.##.###.###\n#.#######.##.####.##\n####################", "581693010"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["并查集", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「HGOI-1」Water", "background": "$\\text{uuku}$ 每天都给他的线段树浇水。但由于线段树是平面的，所以 $\\text{uuku}$ 用一个二维的水桶给它浇水。", "description": "水桶可以描述为一个 $h\\times w$ 的竖直平面，其中 `.` 表示空格，`#` 表示挡板，保证除顶面外所有边界均有 `#`。\n\n$\\text{uuku}$ 给水桶装水的方式很奇特：他希望在装水完成的瞬间水不流动。即对于任意一格存在水的位置，其左右和下方均有水或者挡板。并且如果一格水的上方是空格，则称之为水平面，如果上方是挡板或者水桶外部，则称之为上界面。水形成的四连通块内的所有水平面都要一样高且所有上界面都应该不高于水平面（该条件即为在真空环境且存在重力时水不流动）。\n\n从装水完成后开始计时，每秒都会进行一次扩展。每次扩展所有水平面都会向上方的空格**扩展一层**，并填充**高度小于等于新扩展层的**所有可达的空格（可以理解为仍满足 $\\text{uuku}$ 的上述要求），这一切可以看作是瞬间完成的。\n\n神奇的水会一直扩展，直到**所有可达的空格**均被水填满后停止扩展，即不存在水平面。\n\n现在 $\\text{uuku}$ 想知道，对于所有符合他要求的装水方案，所有水停止扩展所需时间的**平均值**是多少。\n", "inputFormat": "第一行两个整数 $h$，$w$，表示水桶的高度和宽度。\n\n接下来 $h$ 行，每行 $w$ 个字符，其中 `.` 表示空格，`#` 表示挡板。", "outputFormat": "一行一个整数，表示 $\\text{uuku}$ 给水桶装水需要的时间的平均值，由于答案可能很大，所以你只需要给出对 $998244353$ 取模以后的结果。", "hint": "#### 样例 1 解释\n\n装水无需时间。\n\n共有 $9$ 种情况（`*` 表示水）：\n\n$1$：\n\n```\n#...#...#\n#.#...#.#\n#########\n```\n需要 $0\\text{s}$。\n\n$2$：\n\n```\n#...#...#\n#*#...#.#\n#########\n```\n需要 $1\\text{s}$。\n\n$3$：\n\n```\n#...#...#\n#*#***#.#\n#########\n```\n需要 $1\\text{s}$。\n\n$4$：\n\n```\n#...#...#\n#*#***#*#\n#########\n```\n需要 $1\\text{s}$。\n\n$5$：\n\n```\n#...#...#\n#.#***#.#\n#########\n```\n\n需要 $1\\text{s}$。\n\n$6$：\n\n```\n#...#...#\n#.#***#*#\n#########\n```\n\n需要 $1\\text{s}$。\n\n$7$：\n\n```\n#...#...#\n#*#...#*#\n#########\n```\n\n需要 $1\\text{s}$。\n\n$8$：\n\n```\n#...#...#\n#.#...#*#\n#########\n```\n\n需要 $1\\text{s}$。\n\n$9$：\n\n```\n#***#***#\n#*#***#*#\n#########\n```\n\n需要 $0\\text{s}$。\n\n因此期望为 $\\dfrac{7}{9}\\equiv 110916040(\\bmod 998244353)$。\n\n#### 数据范围\n\n本题采用**捆绑测试**，共有 $5$ 个 $\\text{subtask}$，最终分数为所有 $\\text{subtask}$ 分数之和。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{Task} & \\textbf{Score} & h,w\\le \\cr\\hline\n1 & 10 &  10 \\cr\\hline\n2 & 20 &  100 \\cr\\hline\n3 & 20 &  500 \\cr\\hline\n4 & 20 &  2000 \\cr\\hline\n5 & 30 &  5000 \\cr\\hline\n\\end{array}\n$$\n\n\n对于 $100\\%$ 的数据，$1 \\le h,w \\le 5000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「HGOI-1」Water", "background": "$\\text{uuku}$ 每天都给他的线段树浇水。但由于线段树是平面的，所以 $\\text{uuku}$ 用一个二维的水桶给它浇水。", "description": "水桶可以描述为一个 $h\\times w$ 的竖直平面，其中 `.` 表示空格，`#` 表示挡板，保证除顶面外所有边界均有 `#`。\n\n$\\text{uuku}$ 给水桶装水的方式很奇特：他希望在装水完成的瞬间水不流动。即对于任意一格存在水的位置，其左右和下方均有水或者挡板。并且如果一格水的上方是空格，则称之为水平面，如果上方是挡板或者水桶外部，则称之为上界面。水形成的四连通块内的所有水平面都要一样高且所有上界面都应该不高于水平面（该条件即为在真空环境且存在重力时水不流动）。\n\n从装水完成后开始计时，每秒都会进行一次扩展。每次扩展所有水平面都会向上方的空格**扩展一层**，并填充**高度小于等于新扩展层的**所有可达的空格（可以理解为仍满足 $\\text{uuku}$ 的上述要求），这一切可以看作是瞬间完成的。\n\n神奇的水会一直扩展，直到**所有可达的空格**均被水填满后停止扩展，即不存在水平面。\n\n现在 $\\text{uuku}$ 想知道，对于所有符合他要求的装水方案，所有水停止扩展所需时间的**平均值**是多少。\n", "inputFormat": "第一行两个整数 $h$，$w$，表示水桶的高度和宽度。\n\n接下来 $h$ 行，每行 $w$ 个字符，其中 `.` 表示空格，`#` 表示挡板。", "outputFormat": "一行一个整数，表示 $\\text{uuku}$ 给水桶装水需要的时间的平均值，由于答案可能很大，所以你只需要给出对 $998244353$ 取模以后的结果。", "hint": "#### 样例 1 解释\n\n装水无需时间。\n\n共有 $9$ 种情况（`*` 表示水）：\n\n$1$：\n\n```\n#...#...#\n#.#...#.#\n#########\n```\n需要 $0\\text{s}$。\n\n$2$：\n\n```\n#...#...#\n#*#...#.#\n#########\n```\n需要 $1\\text{s}$。\n\n$3$：\n\n```\n#...#...#\n#*#***#.#\n#########\n```\n需要 $1\\text{s}$。\n\n$4$：\n\n```\n#...#...#\n#*#***#*#\n#########\n```\n需要 $1\\text{s}$。\n\n$5$：\n\n```\n#...#...#\n#.#***#.#\n#########\n```\n\n需要 $1\\text{s}$。\n\n$6$：\n\n```\n#...#...#\n#.#***#*#\n#########\n```\n\n需要 $1\\text{s}$。\n\n$7$：\n\n```\n#...#...#\n#*#...#*#\n#########\n```\n\n需要 $1\\text{s}$。\n\n$8$：\n\n```\n#...#...#\n#.#...#*#\n#########\n```\n\n需要 $1\\text{s}$。\n\n$9$：\n\n```\n#***#***#\n#*#***#*#\n#########\n```\n\n需要 $0\\text{s}$。\n\n因此期望为 $\\dfrac{7}{9}\\equiv 110916040(\\bmod 998244353)$。\n\n#### 数据范围\n\n本题采用**捆绑测试**，共有 $5$ 个 $\\text{subtask}$，最终分数为所有 $\\text{subtask}$ 分数之和。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{Task} & \\textbf{Score} & h,w\\le \\cr\\hline\n1 & 10 &  10 \\cr\\hline\n2 & 20 &  100 \\cr\\hline\n3 & 20 &  500 \\cr\\hline\n4 & 20 &  2000 \\cr\\hline\n5 & 30 &  5000 \\cr\\hline\n\\end{array}\n$$\n\n\n对于 $100\\%$ 的数据，$1 \\le h,w \\le 5000$。", "locale": "zh-CN"}}}
{"pid": "P8486", "type": "P", "difficulty": 7, "samples": [["4 2 2\n499122177 499122177 499122177 499122177\n1 2 \n4 5", "779878410"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["多项式", "洛谷原创", "O2优化", "生成函数", "快速数论变换 NTT", "洛谷月赛"], "title": "「HGOI-1」Competition", "background": "$\\text{HGOI}$ 举办了一场模拟赛。\n\n为了增加选手们的积极性，$\\text{HGOI}$ 的出题人根据题目难度划定了一个分数线。$\\text{bh1234666}$ 会给超过这个分数线的选手发奖品。", "description": "众所周知，$\\text{OI}$ 赛制的比赛有很大的运气成分。选手们往往不能发挥出真实水平。所以对于参赛的 $n$ 位选手，第 $i$ 位选手会有一个达到分数线的概率 $p_i$。\n\n在模拟赛结束后就是最激动人心颁奖环节。\n\n组委会的委员们设置了若干种类的奖品，并且每种奖品都有对应的价值。而他们对自己设置的奖品的发放有各自的要求：\n\n- $\\text{uuku}$ 喜欢成双成对，所以对于他设置的**每种**奖品必须向**偶数个获奖选手**发放。\n\n- $\\text{rechinist}$ 喜欢跟 $\\text{uuku}$ 对着干，所以对于他设置的**每种**奖品必须向**奇数个获奖选手**发放。\n\n委员 $\\text{uuku}$ 设置了 $A$ 种奖品，$a_i$ 表示他设置的第 $i$ 种奖品的价值。\n\n委员 $\\text{rechinist}$ 准备了 $B$ 种奖品，$b_i$ 表示他设置的第 $i$ 种奖品的价值。\n\n当然**每个获奖选手**都将被发给**恰好**一份奖励。\n\n选手们不关心每种奖品被发放了几次，但是他们关心有多少种奖品被发放了，因此选手们的积极性被定义为所有被发放的奖品的价值的乘积（每种奖品只会被乘一次）。\n\n假如获奖人数使得委员会无法发放奖品， $\\text{bh1234666}$ 会十分生气，拒绝提供资金购买奖品，使得选手积极性为 $0$ 。\n\n现在，委员会已经知道了每个选手能达到分数线的概率 $p_i$，他们想知道选手们积极性的期望值为多少。\n\n由于答案可能很大，所以你只需要给出对 $998244353$ 取模以后的结果。\n", "inputFormat": "第一行四个整数 $n$，$A$，$B$ 表示参赛人数和两位委员提出的金额序列的长度。\n\n第二行 $n$ 个整数，表示 $n$ 选手达到分数线的概率 $p_i$（为了方便我们给出模 $998244353$ 意义下的概率）。\n\n第三行 $A$ 个整数，表示 $\\text{uuku}$ 提出的金额序列 $a$。\n\n第四行 $B$ 个整数，表示 $\\text{rechinist}$ 提出的金额序列 $b$。", "outputFormat": "一行一个整数，表示**选手们积极性的期望值**。", "hint": "#### 样例1解释\n\n$0\\sim n$ 人达到分数线的概率依次为$\\dfrac{1}{16}$，$\\dfrac{1}{4}$，$\\dfrac{3}{8}$，$\\dfrac{1}{4}$，$\\dfrac{1}{16}$。\n\n对于 $0$ 人达到分数线无发放方案。\n\n对于 $1$ 人达到分数线无发放方案。\n\n对于 $2$ 人达到分数线有如下 $2$ 种发放方案。\n\n$4$，$5$ 价值为 $20$ 对期望贡献为 $20\\times \\dfrac{3}{8}\\times \\dfrac{1}{2}=\\dfrac{15}{4}$。\n\n$5$，$4$ 价值为 $20$ 对期望贡献为 $20\\times \\dfrac{3}{8}\\times \\dfrac{1}{2}=\\dfrac{15}{4}$。\n\n对于 $3$ 人达到分数线无发放方案。\n\n对于 $4$ 人达到分数线有如下 $32$ 种发放方案。\n\n对于发放 $4$，$5$ 两种奖品一共有 $8$ 种方式。\n\n每种价值均为 $20$ 对期望总贡献为 $20\\times 8\\times \\dfrac{1}{16}\\times \\dfrac{1}{32}=\\dfrac{5}{16}$。\n\n对于发放 $1$，$4$，$5$ 三种奖品一共有 $12$ 种方式。\n\n每种价值均为 $20$ 对期望总贡献为 $20\\times 12\\times \\dfrac{1}{16}\\times \\dfrac{1}{32}=\\dfrac{15}{32}$。\n\n对于发放 $2$，$4$，$5$ 三种奖品一共有 $12$ 种方式。\n\n价值均为 $40$ 对期望贡献为 $40\\times 12\\times \\dfrac{1}{16}\\times \\dfrac{1}{32}=\\dfrac{15}{16}$。\n\n则总期望 $E=\\dfrac{15}{4}+\\dfrac{15}{4}+\\dfrac{5}{16}+\\dfrac{15}{32}+\\dfrac{15}{16}=\\dfrac{295}{32}\\equiv 779878410 (\\bmod\\ 998244353)$。\n\n#### 数据范围\n\n本题采用**捆绑测试**，共有 $6$ 个 $\\text{subtask}$，最终分数为所有 $\\text{subtask}$ 分数之和。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{Task} & \\textbf{Score} & \\textbf{特殊限制} \\cr\\hline\n1 & 5 & n \\le 5 \\text{且} A \\text{，}B \\le 5 \\cr\\hline\n2 & 10 & n \\le 500 \\text{且} A+B \\le 500 \\cr\\hline\n3 & 15 & n \\le 2000 \\text{且} A+B\\le 2000  \\cr\\hline\n4 & 20 & n\\text{，}A\\text{，}B \\le 5000  \\cr\\hline\n5 & 20 & n \\le 2\\times 10^5 \\text{，} A \\text{，} B \\le 10^5\\cr\\hline\n6 & 30 &  \\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，$1 \\le A$，$B \\le 2 \\times 10^5$，$1 \\le n \\le 4 \\times 10^5$，$1 \\le a_i$，$b_i$，$p_i \\le 998244352$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「HGOI-1」Competition", "background": "$\\text{HGOI}$ 举办了一场模拟赛。\n\n为了增加选手们的积极性，$\\text{HGOI}$ 的出题人根据题目难度划定了一个分数线。$\\text{bh1234666}$ 会给超过这个分数线的选手发奖品。", "description": "众所周知，$\\text{OI}$ 赛制的比赛有很大的运气成分。选手们往往不能发挥出真实水平。所以对于参赛的 $n$ 位选手，第 $i$ 位选手会有一个达到分数线的概率 $p_i$。\n\n在模拟赛结束后就是最激动人心颁奖环节。\n\n组委会的委员们设置了若干种类的奖品，并且每种奖品都有对应的价值。而他们对自己设置的奖品的发放有各自的要求：\n\n- $\\text{uuku}$ 喜欢成双成对，所以对于他设置的**每种**奖品必须向**偶数个获奖选手**发放。\n\n- $\\text{rechinist}$ 喜欢跟 $\\text{uuku}$ 对着干，所以对于他设置的**每种**奖品必须向**奇数个获奖选手**发放。\n\n委员 $\\text{uuku}$ 设置了 $A$ 种奖品，$a_i$ 表示他设置的第 $i$ 种奖品的价值。\n\n委员 $\\text{rechinist}$ 准备了 $B$ 种奖品，$b_i$ 表示他设置的第 $i$ 种奖品的价值。\n\n当然**每个获奖选手**都将被发给**恰好**一份奖励。\n\n选手们不关心每种奖品被发放了几次，但是他们关心有多少种奖品被发放了，因此选手们的积极性被定义为所有被发放的奖品的价值的乘积（每种奖品只会被乘一次）。\n\n假如获奖人数使得委员会无法发放奖品， $\\text{bh1234666}$ 会十分生气，拒绝提供资金购买奖品，使得选手积极性为 $0$ 。\n\n现在，委员会已经知道了每个选手能达到分数线的概率 $p_i$，他们想知道选手们积极性的期望值为多少。\n\n由于答案可能很大，所以你只需要给出对 $998244353$ 取模以后的结果。\n", "inputFormat": "第一行四个整数 $n$，$A$，$B$ 表示参赛人数和两位委员提出的金额序列的长度。\n\n第二行 $n$ 个整数，表示 $n$ 选手达到分数线的概率 $p_i$（为了方便我们给出模 $998244353$ 意义下的概率）。\n\n第三行 $A$ 个整数，表示 $\\text{uuku}$ 提出的金额序列 $a$。\n\n第四行 $B$ 个整数，表示 $\\text{rechinist}$ 提出的金额序列 $b$。", "outputFormat": "一行一个整数，表示**选手们积极性的期望值**。", "hint": "#### 样例1解释\n\n$0\\sim n$ 人达到分数线的概率依次为$\\dfrac{1}{16}$，$\\dfrac{1}{4}$，$\\dfrac{3}{8}$，$\\dfrac{1}{4}$，$\\dfrac{1}{16}$。\n\n对于 $0$ 人达到分数线无发放方案。\n\n对于 $1$ 人达到分数线无发放方案。\n\n对于 $2$ 人达到分数线有如下 $2$ 种发放方案。\n\n$4$，$5$ 价值为 $20$ 对期望贡献为 $20\\times \\dfrac{3}{8}\\times \\dfrac{1}{2}=\\dfrac{15}{4}$。\n\n$5$，$4$ 价值为 $20$ 对期望贡献为 $20\\times \\dfrac{3}{8}\\times \\dfrac{1}{2}=\\dfrac{15}{4}$。\n\n对于 $3$ 人达到分数线无发放方案。\n\n对于 $4$ 人达到分数线有如下 $32$ 种发放方案。\n\n对于发放 $4$，$5$ 两种奖品一共有 $8$ 种方式。\n\n每种价值均为 $20$ 对期望总贡献为 $20\\times 8\\times \\dfrac{1}{16}\\times \\dfrac{1}{32}=\\dfrac{5}{16}$。\n\n对于发放 $1$，$4$，$5$ 三种奖品一共有 $12$ 种方式。\n\n每种价值均为 $20$ 对期望总贡献为 $20\\times 12\\times \\dfrac{1}{16}\\times \\dfrac{1}{32}=\\dfrac{15}{32}$。\n\n对于发放 $2$，$4$，$5$ 三种奖品一共有 $12$ 种方式。\n\n价值均为 $40$ 对期望贡献为 $40\\times 12\\times \\dfrac{1}{16}\\times \\dfrac{1}{32}=\\dfrac{15}{16}$。\n\n则总期望 $E=\\dfrac{15}{4}+\\dfrac{15}{4}+\\dfrac{5}{16}+\\dfrac{15}{32}+\\dfrac{15}{16}=\\dfrac{295}{32}\\equiv 779878410 (\\bmod\\ 998244353)$。\n\n#### 数据范围\n\n本题采用**捆绑测试**，共有 $6$ 个 $\\text{subtask}$，最终分数为所有 $\\text{subtask}$ 分数之和。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{Task} & \\textbf{Score} & \\textbf{特殊限制} \\cr\\hline\n1 & 5 & n \\le 5 \\text{且} A \\text{，}B \\le 5 \\cr\\hline\n2 & 10 & n \\le 500 \\text{且} A+B \\le 500 \\cr\\hline\n3 & 15 & n \\le 2000 \\text{且} A+B\\le 2000  \\cr\\hline\n4 & 20 & n\\text{，}A\\text{，}B \\le 5000  \\cr\\hline\n5 & 20 & n \\le 2\\times 10^5 \\text{，} A \\text{，} B \\le 10^5\\cr\\hline\n6 & 30 &  \\cr\\hline\n\\end{array}\n$$\n\n对于 $100\\%$ 的数据，$1 \\le A$，$B \\le 2 \\times 10^5$，$1 \\le n \\le 4 \\times 10^5$，$1 \\le a_i$，$b_i$，$p_i \\le 998244352$。", "locale": "zh-CN"}}}
{"pid": "P8487", "type": "P", "difficulty": 5, "samples": [["10\n3 0\n2 6 8", "18"], ["13\n5 0\n0 1 4 6 11\n", "52"], ["1928374\n10 1000000\n193 3489 238 438 8 912 83 19 12489 10", "10000215403302"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "二分", "洛谷原创", "O2优化", "位运算", "洛谷月赛"], "title": "「HGOI-1」Binary search Ex", "background": "此题为 [div.2 B](https://www.luogu.com.cn/problem/P8481) 的 extra sub，并非完整的题，总分为 $25$ 分（进入主题库后满分为 $100$ 分）。\n\n$\\text{bh1234666}$ 正在学习[二分查找](https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/10628618?fr=aladdin)。", "description": "众所周知二分查找的 $\\text{mid}$ 在计算时可以取 $\\lfloor\\dfrac{l+r}{2}\\rfloor$ 或者 $\\lceil\\dfrac{l+r}{2}\\rceil$,于是有选择困难症的 $\\text{bh1234666}$ 同学在自己的二分查找代码中加入了随机化，每次随机选取其中的一个作为 $\\textit{mid}$。\n\n现在 $\\text{bh1234666}$ 告诉你了他要找的数在序列内的下标（从 $0$ 开始，可以理解为在一个 $0\\sim n-1$ 的升序序列内查询询问的数），他想知道在运气最好的情况下循环需要进行几次（即代码中 $\\textit{cnt}$ 的可能的最终值的最小值）。\n\n循环：\n```cpp\nint find(int *num,int x,int len)\n{\n\tint l=0,r=len-1,mid,cnt=0,w;\n\twhile(l<r)\n\t{\n\t\tcnt++;\n\t\tw=rand()%2;\n\t\tmid=(l+r+w)/2;\n\t\tif(num[mid]-w<x) l=mid+!w;\n\t\telse r=mid-w;\n\t}\n\treturn mid;\n}\n```\n递归：\n```\nint cnt;\nint get(int *num,int x,int l,int r)\n{\n\tif(l==r) return l;\n\tcnt++;\n\tint w=rand()%2;\n\tint mid=(l+r+w)/2;\n\tif(num[mid]-w<x) return get(num,x,mid+!w,r);\n\telse return get(num,x,l,mid-w);\n}\nint find(int *num,int x,int len)\n{\n\tcnt=0;\n\treturn get(num,x,0,len-1);\n}\n```\n注：以上两代码完全等价。", "inputFormat": "第一行给出一个整数 $n$ 表示序列长度。\n\n第二行两个整数 $q$，$q_2$ 表示询问的次数，其中 $q$ 表示输入的询问次数，$q_2$ 表示由数据生成器生成的询问次数。\n\n接下来一行 $q$ 个整数表示需要查询的数字。\n\n接下来由数据生成器给出 $q_2$ 个询问（无需读入）。", "outputFormat": "在总共的 $q+q_2$ 次询问中，记第 $i$ \n次询问的答案为 $ans_i$。\n\n请你输出一个整数 $\\sum\\limits_{i=1}^{q+q_2}i\\times ans_i$ 来表示答案。", "hint": "### 样例 1 解释\n\n还原后的输出：$3\\  3\\  3$。\n\n找 $2$：\n\n取 $[1,5]$。\n\n取 $[1,3]$。\n\n取 $[3,3]$（退出循环）。\n\n### 样例 2 解释\n\n还原后的输出：$3\\ 4\\ 3\\  3\\  4$。\n\n#### 数据生成器\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define ull unsigned long long\null sd = 111111111111111111ull, sd2, k = 1;\null qu, n, ans;//qu表示每次询问的位置。 \ninline ull get_q(int i)\n{\n\tsd = (sd2 ^ (sd2 >> 3)) + 998244353;\n\treturn ((sd2 = sd ^ (sd << 37)) & k) + ((i & 1) ? 0 : (n - k - 1));\n}\nint q, q2;\nvoid init()\n{\n\t//Put your code here or not.\n}\ninline ull get_ans(ull x)\n{\n\t//Put your code here.\n}\nint main()\n{\n\tcin >> n;\n\tsd2 = n;\n\twhile((k << 1) <= n + 1) k <<= 1;\n\tk -= 1;\n\tcin >> q >> q2;\n\tinit();\n\tfor(int i = 1; i <= q; i++)\n\t{\n\t\tcin >> qu;\n\t\tans += get_ans(qu) * i;\n\t}\n\tfor(int i = 1; i <= q2; i++)\n\t{\n\t\tqu = get_q(i);\n\t\tans += get_ans(qu) * (i + q);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n```\n\n### 数据范围及约定\n\n此题不进行捆绑测试，分数为各点分数之和。数据存在梯度，如下表所示。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{ExTest} & \\textbf{Score} & \\textbf{特殊限制} \\cr\\hline\n1 & 5 & n,q_2 \\le 2^{20}\\cr\\hline\n2 & 5 & n \\le 2^{30},q_2 \\le 2\\times 10^6 \\cr\\hline\n3 & 5 & n \\le 2^{40},q_2 \\le 5 \\times 10^6 \\cr\\hline\n4 & 5 &  n \\le 2^{50},q_2 \\le  2\\times 10^7 \\cr\\hline\n5 & 5 &  n \\le 2^{60},q_2 \\le 2\\times 10^8 \\cr\\hline\n\\end{array}\n$$\n对于 $100\\%$ 的数据，$1 \\le n \\le 2^{60}$，$1 \\le q+q_2 \\le n$，$q \\le 2^{20}$，$q_2 \\le 2 \\times 10^8$。\n\n本题保证时限是 std 的两倍以上且使用给出的模板可以通过此题。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「HGOI-1」Binary search Ex", "background": "此题为 [div.2 B](https://www.luogu.com.cn/problem/P8481) 的 extra sub，并非完整的题，总分为 $25$ 分（进入主题库后满分为 $100$ 分）。\n\n$\\text{bh1234666}$ 正在学习[二分查找](https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/10628618?fr=aladdin)。", "description": "众所周知二分查找的 $\\text{mid}$ 在计算时可以取 $\\lfloor\\dfrac{l+r}{2}\\rfloor$ 或者 $\\lceil\\dfrac{l+r}{2}\\rceil$,于是有选择困难症的 $\\text{bh1234666}$ 同学在自己的二分查找代码中加入了随机化，每次随机选取其中的一个作为 $\\textit{mid}$。\n\n现在 $\\text{bh1234666}$ 告诉你了他要找的数在序列内的下标（从 $0$ 开始，可以理解为在一个 $0\\sim n-1$ 的升序序列内查询询问的数），他想知道在运气最好的情况下循环需要进行几次（即代码中 $\\textit{cnt}$ 的可能的最终值的最小值）。\n\n循环：\n```cpp\nint find(int *num,int x,int len)\n{\n\tint l=0,r=len-1,mid,cnt=0,w;\n\twhile(l<r)\n\t{\n\t\tcnt++;\n\t\tw=rand()%2;\n\t\tmid=(l+r+w)/2;\n\t\tif(num[mid]-w<x) l=mid+!w;\n\t\telse r=mid-w;\n\t}\n\treturn mid;\n}\n```\n递归：\n```\nint cnt;\nint get(int *num,int x,int l,int r)\n{\n\tif(l==r) return l;\n\tcnt++;\n\tint w=rand()%2;\n\tint mid=(l+r+w)/2;\n\tif(num[mid]-w<x) return get(num,x,mid+!w,r);\n\telse return get(num,x,l,mid-w);\n}\nint find(int *num,int x,int len)\n{\n\tcnt=0;\n\treturn get(num,x,0,len-1);\n}\n```\n注：以上两代码完全等价。", "inputFormat": "第一行给出一个整数 $n$ 表示序列长度。\n\n第二行两个整数 $q$，$q_2$ 表示询问的次数，其中 $q$ 表示输入的询问次数，$q_2$ 表示由数据生成器生成的询问次数。\n\n接下来一行 $q$ 个整数表示需要查询的数字。\n\n接下来由数据生成器给出 $q_2$ 个询问（无需读入）。", "outputFormat": "在总共的 $q+q_2$ 次询问中，记第 $i$ \n次询问的答案为 $ans_i$。\n\n请你输出一个整数 $\\sum\\limits_{i=1}^{q+q_2}i\\times ans_i$ 来表示答案。", "hint": "### 样例 1 解释\n\n还原后的输出：$3\\  3\\  3$。\n\n找 $2$：\n\n取 $[1,5]$。\n\n取 $[1,3]$。\n\n取 $[3,3]$（退出循环）。\n\n### 样例 2 解释\n\n还原后的输出：$3\\ 4\\ 3\\  3\\  4$。\n\n#### 数据生成器\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define ull unsigned long long\null sd = 111111111111111111ull, sd2, k = 1;\null qu, n, ans;//qu表示每次询问的位置。 \ninline ull get_q(int i)\n{\n\tsd = (sd2 ^ (sd2 >> 3)) + 998244353;\n\treturn ((sd2 = sd ^ (sd << 37)) & k) + ((i & 1) ? 0 : (n - k - 1));\n}\nint q, q2;\nvoid init()\n{\n\t//Put your code here or not.\n}\ninline ull get_ans(ull x)\n{\n\t//Put your code here.\n}\nint main()\n{\n\tcin >> n;\n\tsd2 = n;\n\twhile((k << 1) <= n + 1) k <<= 1;\n\tk -= 1;\n\tcin >> q >> q2;\n\tinit();\n\tfor(int i = 1; i <= q; i++)\n\t{\n\t\tcin >> qu;\n\t\tans += get_ans(qu) * i;\n\t}\n\tfor(int i = 1; i <= q2; i++)\n\t{\n\t\tqu = get_q(i);\n\t\tans += get_ans(qu) * (i + q);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n```\n\n### 数据范围及约定\n\n此题不进行捆绑测试，分数为各点分数之和。数据存在梯度，如下表所示。\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|}\\hline\n\\textbf{ExTest} & \\textbf{Score} & \\textbf{特殊限制} \\cr\\hline\n1 & 5 & n,q_2 \\le 2^{20}\\cr\\hline\n2 & 5 & n \\le 2^{30},q_2 \\le 2\\times 10^6 \\cr\\hline\n3 & 5 & n \\le 2^{40},q_2 \\le 5 \\times 10^6 \\cr\\hline\n4 & 5 &  n \\le 2^{50},q_2 \\le  2\\times 10^7 \\cr\\hline\n5 & 5 &  n \\le 2^{60},q_2 \\le 2\\times 10^8 \\cr\\hline\n\\end{array}\n$$\n对于 $100\\%$ 的数据，$1 \\le n \\le 2^{60}$，$1 \\le q+q_2 \\le n$，$q \\le 2^{20}$，$q_2 \\le 2 \\times 10^8$。\n\n本题保证时限是 std 的两倍以上且使用给出的模板可以通过此题。", "locale": "zh-CN"}}}
{"pid": "P8488", "type": "P", "difficulty": 4, "samples": [["5 5\n2 8 15 1 10\n5 19 19 3 5\n6 6 2 8 2\n12 16 3 8 17\n12 5 3 14 13\n1 1 1 1 1 1\n", "97"], ["2 5\n2 8 15 3 10\n5 19 19 3 5\n1 2 3 4 5 6", "194"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "洛谷原创", "O2优化", "洛谷月赛"], "title": "「Wdoi-(-1)」恋弹者们的黑集市", "background": "> 天弓千亦有言：「能力卡终将大势所趋归于陈腐，集市终将回归日常，这是发展规律。」但不知为何和神明所说相悖，卡片的价值遭到了炒作。有人在炒作卡的价值吗废话？又或者说，有倒爷在囤积这些卡片吗？卡片市场秩序完全陷入混乱之时，即便是神明也无法介入的集市，就此出现。\n\n$$\\quad\\tag*{\\small\\textit{---TH18.5 恋弹者们的黑集市}}$$\n\n魔理沙正在调查妖怪之山的高地，来收集逸散在各地的能力卡片。就在此时，她遇到了住在此处的驹草山如。\n\n在河童与天狗间游刃有余的驹草山如，掌握着此地大量的资源。显而易见的，她掌握着大量的能力卡片——这正是魔理沙探访的目标。\n\n「想要这些卡片吗，那就让我们玩一个游戏吧」\n\n「赢了，这些卡片就都归你；输了，你可要交出身上所有的卡片。」\n\n", "description": "### 原始题意\n\n\n\n驹草山如将一个六面写满权值的骰子放在了棋盘上。棋盘上花花绿绿写着很多数字。第 $i$ 行第 $j$ 列写有数字 $a_{i-1,j-1}$。\n\n「你能否获得这些能力卡片，取决于你获得的分数。」\n\n魔理沙有两种方法移动这个骰子：将骰子向下一列**翻转**，或者向下一行**翻转**。值得注意的是，翻转骰子后，骰子每面上的数字就会随着翻滚而改变。现在魔理沙需要将骰子滚动至第 $n$ 行第 $m$ 列。\n\n魔理沙的分数被定义为，所有时刻，骰子与棋盘上的数字接触的那一面的数字，乘上棋盘上该数字，再累加起来的和。只有魔理沙最大化这个和，她才能获取她所需要的卡片。\n\n你能帮帮魔理沙吗？\n\n### 简要题意\n\n有一个 $n\\times m$ 大小的棋盘，第 $i$ 行第 $j$ 列写有数字 $a_{i-1,j-1}$。\n\n现在有一个骰子，六个面按照前、后、左、右、上、下的顺序，依次写有数字 $w_0,w_1,w_2,w_3,w_4,w_5$。现在骰子摆放在 $(0,0)$ 位置，需要将它**滚动**至 $(n-1,m-1)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2l378eln.png)\n\n骰子只有两种方式滚动：向下一行翻滚、向下一列翻滚。我们记一种方案的权值为，整个过程中（包括骰子在起点和终点时），骰子**最底面**上写着的数字，与此时骰子所在格子上写着的数字的乘积之和。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4jwvxax5.png)\n\n（为了方便读者阅读，骰子上的数字已经隐去）\n\n现在你需要最大化这个乘积之和。", "inputFormat": "- 第一行有两个正整数 $n, m$，表示棋盘的大小。\n- 接下来 $n$ 行 $m$ 列描述棋盘内元素的值 $a_{i,j}$。\n- 接下来一行有六个整数，分别表示 $w_0,w_1,w_2,w_3,w_4,w_5$。", "outputFormat": "- 输出共一行一个整数，表示可以获得的最大权值。", "hint": "### 样例解释\n\n#### 样例 1 解释\n\n一种最优的方案为，$(0,0)\\to(0,1)\\to(1,1)\\to(1,2)\\to(1,3)\\to(2,3)\\to(3,3)\\to(3,4)\\to(4,4)$。\n\n总权值为 $2+8+19+19+3+8+8+17+13=97$。\n\n#### 样例 2 解释\n\n一种最优的方案为，$(0,0)\\to(0,1)\\to(1,1)\\to(1,2)\\to(1,3)\\to(1,4)$。\n\n### 数据范围及约定\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\bm{n,m\\le} & \\textbf{特殊性质} & \\textbf{分值} \\\\\\hline\n1 & 10 & - & 10 \\\\\\hline\n2 & 100 & - & 30 \\\\\\hline\n3 & 10^3 & \\textbf{A} & 10 \\\\\\hline\n4 & 10^3 & - & 50 \\\\\\hline\n\\end{array}$$\n\n- **特殊性质** $\\textbf{A}$：保证 $w_i=1,i=0,1,2,\\cdots 5$。\n\n对于全部数据，保证 $1\\le n,m\\le 10^3$，$|a_i|\\le 10^3$，$|w_i|\\le 10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「Wdoi-(-1)」恋弹者们的黑集市", "background": "> 天弓千亦有言：「能力卡终将大势所趋归于陈腐，集市终将回归日常，这是发展规律。」但不知为何和神明所说相悖，卡片的价值遭到了炒作。有人在炒作卡的价值吗废话？又或者说，有倒爷在囤积这些卡片吗？卡片市场秩序完全陷入混乱之时，即便是神明也无法介入的集市，就此出现。\n\n$$\\quad\\tag*{\\small\\textit{---TH18.5 恋弹者们的黑集市}}$$\n\n魔理沙正在调查妖怪之山的高地，来收集逸散在各地的能力卡片。就在此时，她遇到了住在此处的驹草山如。\n\n在河童与天狗间游刃有余的驹草山如，掌握着此地大量的资源。显而易见的，她掌握着大量的能力卡片——这正是魔理沙探访的目标。\n\n「想要这些卡片吗，那就让我们玩一个游戏吧」\n\n「赢了，这些卡片就都归你；输了，你可要交出身上所有的卡片。」\n\n", "description": "### 原始题意\n\n\n\n驹草山如将一个六面写满权值的骰子放在了棋盘上。棋盘上花花绿绿写着很多数字。第 $i$ 行第 $j$ 列写有数字 $a_{i-1,j-1}$。\n\n「你能否获得这些能力卡片，取决于你获得的分数。」\n\n魔理沙有两种方法移动这个骰子：将骰子向下一列**翻转**，或者向下一行**翻转**。值得注意的是，翻转骰子后，骰子每面上的数字就会随着翻滚而改变。现在魔理沙需要将骰子滚动至第 $n$ 行第 $m$ 列。\n\n魔理沙的分数被定义为，所有时刻，骰子与棋盘上的数字接触的那一面的数字，乘上棋盘上该数字，再累加起来的和。只有魔理沙最大化这个和，她才能获取她所需要的卡片。\n\n你能帮帮魔理沙吗？\n\n### 简要题意\n\n有一个 $n\\times m$ 大小的棋盘，第 $i$ 行第 $j$ 列写有数字 $a_{i-1,j-1}$。\n\n现在有一个骰子，六个面按照前、后、左、右、上、下的顺序，依次写有数字 $w_0,w_1,w_2,w_3,w_4,w_5$。现在骰子摆放在 $(0,0)$ 位置，需要将它**滚动**至 $(n-1,m-1)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2l378eln.png)\n\n骰子只有两种方式滚动：向下一行翻滚、向下一列翻滚。我们记一种方案的权值为，整个过程中（包括骰子在起点和终点时），骰子**最底面**上写着的数字，与此时骰子所在格子上写着的数字的乘积之和。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4jwvxax5.png)\n\n（为了方便读者阅读，骰子上的数字已经隐去）\n\n现在你需要最大化这个乘积之和。", "inputFormat": "- 第一行有两个正整数 $n, m$，表示棋盘的大小。\n- 接下来 $n$ 行 $m$ 列描述棋盘内元素的值 $a_{i,j}$。\n- 接下来一行有六个整数，分别表示 $w_0,w_1,w_2,w_3,w_4,w_5$。", "outputFormat": "- 输出共一行一个整数，表示可以获得的最大权值。", "hint": "### 样例解释\n\n#### 样例 1 解释\n\n一种最优的方案为，$(0,0)\\to(0,1)\\to(1,1)\\to(1,2)\\to(1,3)\\to(2,3)\\to(3,3)\\to(3,4)\\to(4,4)$。\n\n总权值为 $2+8+19+19+3+8+8+17+13=97$。\n\n#### 样例 2 解释\n\n一种最优的方案为，$(0,0)\\to(0,1)\\to(1,1)\\to(1,2)\\to(1,3)\\to(1,4)$。\n\n### 数据范围及约定\n\n$$\n\\def\\arraystretch{1.5}\n\\begin{array}{|c|c|c|c|}\\hline\n\\textbf{Subtask} & \\bm{n,m\\le} & \\textbf{特殊性质} & \\textbf{分值} \\\\\\hline\n1 & 10 & - & 10 \\\\\\hline\n2 & 100 & - & 30 \\\\\\hline\n3 & 10^3 & \\textbf{A} & 10 \\\\\\hline\n4 & 10^3 & - & 50 \\\\\\hline\n\\end{array}$$\n\n- **特殊性质** $\\textbf{A}$：保证 $w_i=1,i=0,1,2,\\cdots 5$。\n\n对于全部数据，保证 $1\\le n,m\\le 10^3$，$|a_i|\\le 10^3$，$|w_i|\\le 10^3$。", "locale": "zh-CN"}}}
{"pid": "P8490", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["动态规划 DP", "2022", "IOI", "交互题", "动态规划优化", "前缀和", "Ad-hoc"], "title": "[IOI 2022] 鲶鱼塘", "background": "### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。", "description": "Bu Dengklek 有一个鲶鱼塘。这个鲶鱼塘是由 $N \\times N$ 个网格单元构成的池塘。每个单元都是相同大小的正方形。网格各列自西向东编号为从 $0$ 到 $N - 1$，各行自南向北编号为从 $0$ 到 $N - 1$。我们把坐落在网格第 $c$ 列第 $r$ 行处（$0 \\le c \\le N - 1$，$0 \\le r \\le N - 1$）的单元记为单元 $(c, r)$。\n\n池塘里总共有 $M$ 条鲶鱼，编号为从 $0$ 到 $M - 1$，分别位于**不同的**单元中。对每个满足 $0 \\le i \\le M - 1$ 的 $i$，鲶鱼 $i$ 在单元 $(X_i, Y_i)$ 中，其重量为 $W_i$ 克。\n\nBu Dengklek 想造些长堤来抓鲶鱼。在第 $c$ 列中长度为 $k$ 的长堤（对于所有 $0 \\le c \\le N - 1$ 和 $1 \\le k \\le N$），是一个从第 $0$ 行跨到第 $k - 1$ 行的矩形，盖住单元 $(c, 0), (c, 1), \\ldots, (c, k - 1)$。对于每一列，Bu Dengklek 可以按照她自己选择的某个长度造长堤，也可以不造。\n\n鲶鱼 $i$（对所有满足 $0 \\le i \\le M - 1$ 的 $i$）能被抓住，如果有某个长堤紧邻它的西侧或东侧，而且没有长堤盖住它所在的单元；也就是说，如果\n* 单元 $(X_i - 1, Y_i)$ 或 $(X_i + 1, Y_i)$ 中 **至少有一个** 被某个长堤盖住，而且\n* 没有长堤盖住单元 $(X_i, Y_i)$。\n\n例如，考虑尺寸为 $N = 5$，有 $M = 4$ 条鲶鱼的池塘：\n\n* 鲶鱼 $0$ 在单元 $(0, 2)$ 中，重量为 $5$ 克。\n* 鲶鱼 $1$ 在单元 $(1, 1)$ 中，重量为 $2$ 克。\n* 鲶鱼 $2$ 在单元 $(4, 4)$ 中，重量为 $1$ 克。\n* 鲶鱼 $3$ 在单元 $(3, 3)$ 中，重量为 $3$ 克。\n\nBu Dengklek 可以这样来造长堤：\n\n| 造长堤前 | 造长堤后 |\n| :---: | :---: |\n| ![](https://cdn.luogu.com.cn/upload/image_hosting/2rcnqc7k.png) | ![](https://cdn.luogu.com.cn/upload/image_hosting/yesaiovt.png) |\n\n单元中的数字表示该单元中鲶鱼的重量。\n阴影单元被长堤盖住。\n在该场景中，鲶鱼 $0$（在单元 $(0, 2)$ 中）和鲶鱼 $3$（在单元 $(3, 3)$ 中）能被抓住。\n鲶鱼 $1$（在单元 $(1, 1)$ 中）没被抓住，因为有一个长堤盖住了它所在的单元；鲶鱼 $2$（在单元 $(4, 4)$ 中）没被抓住，因为没有长堤紧邻它的西侧或东侧。\n\nBu Dengklek 希望造出来的长堤能让被抓住的鲶鱼的总重量尽量大。\n你的任务是求出 Bu Dengklek 通过造长堤能抓住的鲶鱼的最大总重量。", "inputFormat": "你需要实现下面的函数：\n\n```go\nint64 max_weights(int N, int M, int[] X, int[] Y, int[] W)\n```\n\n* $N$：池塘的尺寸。\n* $M$：鲶鱼的数量。\n* $X$, $Y$：长度为 $M$ 的两个数组，给出鲶鱼的位置。\n* $W$：长度为 $M$ 的数组，给出鲶鱼的重量。\n* 该函数需要返回一个整数，表示 Bu Dengklek 通过造长堤能抓住的鲶鱼的最大总重量。\n* 该函数将被恰好调用一次。", "outputFormat": "考虑如下调用：\n\n```go\nmax_weights(5, 4, [0, 1, 4, 3], [2, 1, 4, 3], [5, 2, 1, 3])\n```\n\n该例子的解释请见前面的题面。\n\n在造完所述的长堤后，Bu Dengklek 能抓住鲶鱼 $0$ 和 $3$，其总重量为 $5 + 3 = 8$ 克。\n因为无法造出能够抓住总重量超过  $8$ 克的鲶鱼的长堤，函数应当返回 $8$。", "hint": "### 约束条件\n\n* $2 \\le N \\le 100\\;000$\n* $1 \\le M \\le 300\\;000$\n* $0 \\le X_i \\le N - 1$，$0 \\le Y_i \\le N - 1$（对所有满足 $0 \\le i \\le M - 1$ 的 $i$）\n* $1 \\le W_i \\le 10^9$（对所有满足 $0 \\le i \\le M - 1$ 的 $i$）\n* 任意两条鲶鱼都不会在同一单元中。\n  换句话说，$X_i \\neq X[j]$ 或 $Y_i \\neq Y[j]$（对于所有满足 $0 \\le i \\lt j \\le M - 1$ 的 $i$ 和 $j$）。\n\n### 子任务\n\n1. （3 分） $X_i$ 是偶数（对于所有满足 $0 \\le i \\le M - 1$ 的 $i$）\n1. （6 分） $X_i \\le 1$（对于所有满足 $0 \\le i \\le M - 1$ 的 $i$）\n1. （9 分） $Y_i = 0$（对于所有满足 $0 \\le i \\le M - 1$ 的 $i$）\n1. （14 分） $N \\le 300$，$Y_i \\le 8$（对于所有满足 $0 \\le i \\le M - 1$ 的 $i$）\n1. （21 分） $N \\le 300$\n1. （17 分） $N \\le 3000$\n1. （14 分） 在每列中至多有 $2$ 条鲶鱼。\n1. （16 分） 没有额外限制。\n\n### 评测程序示例\n\n评测程序示例读取如下格式的输入：\n\n* 第 $1$ 行：$N \\; M$\n* 第 $2 + i$ 行（$0 \\le i \\le M - 1$）：$X_i \\; Y_i \\; W_i$\n\n评测程序示例将按照如下格式打印你的答案：\n\n* 第 $1$ 行：`max_weights` 的返回值\n\n### 约定\n\n题面在给出函数接口时，会使用一般性的类型名称 `void`、`int`、`int64`、`int[]`（数组）和 `int[][]`（数组的数组）。\n\n在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：\n\n| `void ` | `int` | `int64`     | `int[]`            |\n| ------- | ----- | ----------- | ------------------ |\n| `void ` | `int` | `long long` | `std::vector<int>` |\n\n| `int[][]`                       | 数组 `a` 的长度 |\n| ------------------------------- | ------------------- |\n| `std::vector<std::vector<int>>` | `a.size()`          |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2022] 鲶鱼塘", "background": "### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。", "description": "Bu Dengklek 有一个鲶鱼塘。这个鲶鱼塘是由 $N \\times N$ 个网格单元构成的池塘。每个单元都是相同大小的正方形。网格各列自西向东编号为从 $0$ 到 $N - 1$，各行自南向北编号为从 $0$ 到 $N - 1$。我们把坐落在网格第 $c$ 列第 $r$ 行处（$0 \\le c \\le N - 1$，$0 \\le r \\le N - 1$）的单元记为单元 $(c, r)$。\n\n池塘里总共有 $M$ 条鲶鱼，编号为从 $0$ 到 $M - 1$，分别位于**不同的**单元中。对每个满足 $0 \\le i \\le M - 1$ 的 $i$，鲶鱼 $i$ 在单元 $(X_i, Y_i)$ 中，其重量为 $W_i$ 克。\n\nBu Dengklek 想造些长堤来抓鲶鱼。在第 $c$ 列中长度为 $k$ 的长堤（对于所有 $0 \\le c \\le N - 1$ 和 $1 \\le k \\le N$），是一个从第 $0$ 行跨到第 $k - 1$ 行的矩形，盖住单元 $(c, 0), (c, 1), \\ldots, (c, k - 1)$。对于每一列，Bu Dengklek 可以按照她自己选择的某个长度造长堤，也可以不造。\n\n鲶鱼 $i$（对所有满足 $0 \\le i \\le M - 1$ 的 $i$）能被抓住，如果有某个长堤紧邻它的西侧或东侧，而且没有长堤盖住它所在的单元；也就是说，如果\n* 单元 $(X_i - 1, Y_i)$ 或 $(X_i + 1, Y_i)$ 中 **至少有一个** 被某个长堤盖住，而且\n* 没有长堤盖住单元 $(X_i, Y_i)$。\n\n例如，考虑尺寸为 $N = 5$，有 $M = 4$ 条鲶鱼的池塘：\n\n* 鲶鱼 $0$ 在单元 $(0, 2)$ 中，重量为 $5$ 克。\n* 鲶鱼 $1$ 在单元 $(1, 1)$ 中，重量为 $2$ 克。\n* 鲶鱼 $2$ 在单元 $(4, 4)$ 中，重量为 $1$ 克。\n* 鲶鱼 $3$ 在单元 $(3, 3)$ 中，重量为 $3$ 克。\n\nBu Dengklek 可以这样来造长堤：\n\n| 造长堤前 | 造长堤后 |\n| :---: | :---: |\n| ![](https://cdn.luogu.com.cn/upload/image_hosting/2rcnqc7k.png) | ![](https://cdn.luogu.com.cn/upload/image_hosting/yesaiovt.png) |\n\n单元中的数字表示该单元中鲶鱼的重量。\n阴影单元被长堤盖住。\n在该场景中，鲶鱼 $0$（在单元 $(0, 2)$ 中）和鲶鱼 $3$（在单元 $(3, 3)$ 中）能被抓住。\n鲶鱼 $1$（在单元 $(1, 1)$ 中）没被抓住，因为有一个长堤盖住了它所在的单元；鲶鱼 $2$（在单元 $(4, 4)$ 中）没被抓住，因为没有长堤紧邻它的西侧或东侧。\n\nBu Dengklek 希望造出来的长堤能让被抓住的鲶鱼的总重量尽量大。\n你的任务是求出 Bu Dengklek 通过造长堤能抓住的鲶鱼的最大总重量。", "inputFormat": "你需要实现下面的函数：\n\n```go\nint64 max_weights(int N, int M, int[] X, int[] Y, int[] W)\n```\n\n* $N$：池塘的尺寸。\n* $M$：鲶鱼的数量。\n* $X$, $Y$：长度为 $M$ 的两个数组，给出鲶鱼的位置。\n* $W$：长度为 $M$ 的数组，给出鲶鱼的重量。\n* 该函数需要返回一个整数，表示 Bu Dengklek 通过造长堤能抓住的鲶鱼的最大总重量。\n* 该函数将被恰好调用一次。", "outputFormat": "考虑如下调用：\n\n```go\nmax_weights(5, 4, [0, 1, 4, 3], [2, 1, 4, 3], [5, 2, 1, 3])\n```\n\n该例子的解释请见前面的题面。\n\n在造完所述的长堤后，Bu Dengklek 能抓住鲶鱼 $0$ 和 $3$，其总重量为 $5 + 3 = 8$ 克。\n因为无法造出能够抓住总重量超过  $8$ 克的鲶鱼的长堤，函数应当返回 $8$。", "hint": "### 约束条件\n\n* $2 \\le N \\le 100\\;000$\n* $1 \\le M \\le 300\\;000$\n* $0 \\le X_i \\le N - 1$，$0 \\le Y_i \\le N - 1$（对所有满足 $0 \\le i \\le M - 1$ 的 $i$）\n* $1 \\le W_i \\le 10^9$（对所有满足 $0 \\le i \\le M - 1$ 的 $i$）\n* 任意两条鲶鱼都不会在同一单元中。\n  换句话说，$X_i \\neq X[j]$ 或 $Y_i \\neq Y[j]$（对于所有满足 $0 \\le i \\lt j \\le M - 1$ 的 $i$ 和 $j$）。\n\n### 子任务\n\n1. （3 分） $X_i$ 是偶数（对于所有满足 $0 \\le i \\le M - 1$ 的 $i$）\n1. （6 分） $X_i \\le 1$（对于所有满足 $0 \\le i \\le M - 1$ 的 $i$）\n1. （9 分） $Y_i = 0$（对于所有满足 $0 \\le i \\le M - 1$ 的 $i$）\n1. （14 分） $N \\le 300$，$Y_i \\le 8$（对于所有满足 $0 \\le i \\le M - 1$ 的 $i$）\n1. （21 分） $N \\le 300$\n1. （17 分） $N \\le 3000$\n1. （14 分） 在每列中至多有 $2$ 条鲶鱼。\n1. （16 分） 没有额外限制。\n\n### 评测程序示例\n\n评测程序示例读取如下格式的输入：\n\n* 第 $1$ 行：$N \\; M$\n* 第 $2 + i$ 行（$0 \\le i \\le M - 1$）：$X_i \\; Y_i \\; W_i$\n\n评测程序示例将按照如下格式打印你的答案：\n\n* 第 $1$ 行：`max_weights` 的返回值\n\n### 约定\n\n题面在给出函数接口时，会使用一般性的类型名称 `void`、`int`、`int64`、`int[]`（数组）和 `int[][]`（数组的数组）。\n\n在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：\n\n| `void ` | `int` | `int64`     | `int[]`            |\n| ------- | ----- | ----------- | ------------------ |\n| `void ` | `int` | `long long` | `std::vector<int>` |\n\n| `int[][]`                       | 数组 `a` 的长度 |\n| ------------------------------- | ------------------- |\n| `std::vector<std::vector<int>>` | `a.size()`          |\n", "locale": "zh-CN"}}}
{"pid": "P8491", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "IOI", "交互题", "Special Judge", "进制", "构造", "Ad-hoc"], "title": "[IOI 2022] 囚徒挑战", "background": "### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。", "description": "一个监狱里关着 $500$ 名囚徒。\n有一天，监狱长给了他们一个重获自由的机会。\n他把装钱的两个袋子 A 和 B 放在一个房间里。\n每个袋子装有若干枚硬币，数量的范围在 $1$ 到 $N$ 之间（包含 $1$ 和 $N$）。\n两个袋子里硬币的数量**不同**。\n监狱长给囚徒们提出了挑战，目标是指出硬币数量较少的那个袋子。\n\n房间里除了袋子还有一块白板。\n任意时刻白板上写着一个数，一开始写的是 $0$。\n\n监狱长让囚徒一个接一个地进入房间。\n每个进入房间的囚徒不知道他之前进入过房间的囚徒有多少人，也不知道是哪些人。\n每次一个囚徒进入房间时，他看一眼白板上目前写的这个数。\n看完之后，他必须在袋子 A 和 B 之间做出选择。\n接着，他**检查**自己选的那个袋子，知道了里面有多少枚硬币。\n然后，这名囚徒必须选择做以下两种**行动**之一：\n\n* 将白板上的数改写成一个非负整数，并离开房间。\n注意他可以改变成新的数，也可以保留当前的数。\n然后挑战继续进行（除非所有 $500$ 名囚徒都已经进过房间）。\n* 指出硬币数量较少的那个袋子。这会立即结束挑战。\n\n对于已经进过房间的囚徒，监狱长不会让他再次进入房间。\n\n如果某个囚徒正确地指出硬币较少的袋子，则囚徒们获得挑战的胜利。\n如果指出的袋子不正确，或者所有 $500$ 人进过房间之后还没有人尝试指出硬币较少的袋子，则囚徒们失败。\n\n挑战开始之前，囚徒们集合在监狱大厅商量应对挑战的共同**策略**，分以下三个步骤：\n* 他们挑选一个非负整数 $x$，作为他们可能会写在白板上的最大的数。\n* 他们决定对任意一个数 $i$ ($0 \\le i \\le x$)，如果某个囚徒进入房间后看到白板上写着数 $i$，那么他应该去检查哪个袋子。\n* 他们决定当某个囚徒得知选中的袋子里的硬币数量后要采取的行动。具体来说，对任意写在白板上的数 $i$ ($0 \\le i \\le x$) 和检查选中的袋子里的硬币数量 $j$ ($1 \\le j \\le N$)，他们要决定做出以下两种行动之一：\n  - 白板上应该要写一个 $0$ 到 $x$ 之间（包含 $0$ 和 $x$）的什么数；\n  - 指出哪个袋子是硬币较少的。\n\n如果赢得挑战，监狱长会在囚徒们继续服刑 $x$ 天后释放他们。\n\n你的任务是提出能够确保囚徒们赢得挑战的策略（不管袋子 A 和 B 中的硬币数量是多少）。\n你的得分取决于 $x$ 的值（详见子任务一节）。", "inputFormat": "你要实现以下函数：\n\n```go\nint[][] devise_strategy(int N)\n```\n\n- $N$：每个袋子里硬币最多可能的数量。\n- 该函数需要返回一个数组 $s$，它的每个元素是长度为 $N + 1$ 的整数数组，表示你给出的策略。$x$ 的值是数组 $s$ 的长度减一。对满足 $0 \\le i \\le x$ 的每个 $i$，数组 $s_i$ 表示囚徒在进入房间看到白板上写着数 $i$ 时要做的事情：\n  1. 如果囚徒应该检查袋子 A，则 $s_{i, 0}$ 的值是 $0$；如果囚徒应该检查袋子 B，则该值是 $1$。\n  2. 令 $j$ 为所选袋子中的硬币数量，囚徒应该进行以下行动：\n     - 如果 $s_{i, j}$ 的值是 $-1$，则囚徒应该指出袋子 A 是硬币较少的袋子。\n     - 如果 $s_{i, j}$ 的值是 $-2$，则囚徒应该指出袋子 B 是硬币较少的袋子。\n     - 如果 $s_{i, j}$ 的值是非负整数，则囚徒应该把这个数写到白板上。注意 $s_{i, j}$ 至多只能是 $x$。\n- 该函数恰好被调用一次。", "outputFormat": "考虑以下调⽤：\n\n```go\ndevise_strategy(3)\n```\n\n令 $v$ 表示囚徒进入房间时看到白板上写着的数。以下是一种正确的策略：\n\n- 如果 $v = 0$（也包括开始时的数），则检查袋子 A。\n  - 如果它装了 $1$ 个硬币，则指出袋子 A 是硬币较少的袋子。\n  - 如果它装了 $3$ 个硬币，则指出袋子 B 是硬币较少的袋子。\n  - 如果它装了 $2$ 个硬币，则在白板上写上 $1$（覆盖之前的 $0$）。\n- 如果 $v = 1$，则检查袋子 B。\n  - 如果它装了 $1$ 个硬币，则指出袋子 B 是硬币较少的袋子。\n  - 如果它装了 $3$ 个硬币，则指出袋子 A 是硬币较少的袋子。\n  - 如果它装了 $2$ 个硬币，则在白板上写上 $0$（覆盖之前的 $1$）。注意，这种情况其实不可能发生，因为此时两个袋子都装有 $2$ 枚硬币，是不允许的。\n\n要产生以上策略，函数应该返回 `[[0, -1, 1, -2], [1, -2, 0, -1]]`。\n返回的数组长度是 $2$，此时 $x$ 的值是 $2 - 1 = 1$。", "hint": "### 约束条件\n\n- $2 \\leq N \\leq 5000$。\n\n### 子任务\n\n1. （5 分）$N \\le 500$，$x$ 的值不能超过 $500$。\n1. （5 分）$N \\le 500$，$x$ 的值不能超过 $70$。\n1. （90分）$x$ 的值不能超过 $60$。\n\n对于任何测试用例，如果 `devise_strategy` 返回的数组是不合法的，则你在该子任务上的得分为 $0$。\n\n子任务 3 有部分分。\n令 $m$ 为该子任务中所有测试用例返回数组对应的 $x$ 的最大值，你的得分将根据下表计算：\n\n| 条件 | 得分 |\n| :-: | :-: |\n| $40 \\leq m \\leq 60$ | $20$ |\n| $26 \\leq m \\leq 39$ | $25 + 1.5 \\times (40 − m)$ |\n| $m = 25$ | $50$ |\n| $m = 24$ | $55$ |\n| $m = 23$ | $62$ |\n| $m = 22$ | $70$ |\n| $m = 21$ | $80$ |\n| $m \\leq 20$ | $90$ |\n\n### 评测程序示例\n\n评测程序示例按以下格式读取输入：\n\n* 第 $1$ 行：$N$\n* 第 $2 + k$ 行 ($0 \\le k$)：$A_k \\; B_k$\n* 最后一行：$-1$\n\n除第一行和最后一行外，每行表示一个场景。\n将第 $2 + k$ 行对应的场景称为场景 $k$。\n场景 $k$ 中，袋子 A 装有 $A[k]$ 枚硬币，袋子 B 装有 $B[k]$ 枚硬币。\n\n评测程序示例首先调用 `devise_strategy(N)`。\n$x$ 的值是返回数组的长度减一。\n如果评测程序示例检测到 `devise_strategy` 返回的数组不符合实现细节中描述的约束，它会打印如下错误信息并退出：\n\n* `s is an empty array`：$s$ 是空的数组（表示不合法的策略）。\n* `s[i] contains incorrect length`：存在一个下标 $i$ ($0 \\le i \\le x$) 满足 $s_i$ 的长度不是 $N + 1$。\n* `First element of s[i] is non-binary`：存在一个下标 $i$ ($0 \\le i \\le x$) 满足 $s_{i,0}$ 既不是 $0$，也不是$1$。\n* `s[i][j] contains incorrect value`：存在下标 $i, j$ ($0 \\le i \\le x, 1 \\le j \\le N$) 满足 $s_{i, j}$ 的值不在 $-2$ 和 $x$ 之间。\n\n否则，评测程序示例产生两项输出内容。\n\n首先，评测程序示例以如下格式打印你的策略的输出：\n\n* 第 $1 + k$ 行 ($0 \\le k$)：场景 $k$ 下你的策略的输出。\n如果用该策略导致某个囚徒指出袋子 A 是硬币较少的，则输出字符 `A`。\n如果用该策略导致某个囚徒指出袋子 B 是硬币较少的，则输出字符 `B`。\n如果用该策略后没有囚徒指出哪个袋子的硬币较少，则输出字符 `X`。\n\n其次，评测程序示例以如下格式在当前目录下写一个文件 `log.txt`：\n\n* 第 $1 + k$ 行 ($0 \\le k$)：$w_{k,0} \\; w_{k,1} \\; \\ldots$\n\n第 $1 + k$ 行的序列对应于场景 $k$，描述了写在白板上的数。\n具体来说，$w[k][l]$ 是第 $l + 1$ 个囚徒进入房间后写的数。\n\n### 约定\n\n题面在给出函数接口时，会使用一般性的类型名称 `void`、`int`、`int64`、`int[]`（数组）和 `int[][]`（数组的数组）。\n\n在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：\n\n| `void ` | `int` | `int64`     | `int[]`            |\n| ------- | ----- | ----------- | ------------------ |\n| `void ` | `int` | `long long` | `std::vector<int>` |\n\n| `int[][]`                       | 数组 `a` 的长度 |\n| ------------------------------- | ------------------- |\n| `std::vector<std::vector<int>>` | `a.size()`          |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2022] 囚徒挑战", "background": "### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。", "description": "一个监狱里关着 $500$ 名囚徒。\n有一天，监狱长给了他们一个重获自由的机会。\n他把装钱的两个袋子 A 和 B 放在一个房间里。\n每个袋子装有若干枚硬币，数量的范围在 $1$ 到 $N$ 之间（包含 $1$ 和 $N$）。\n两个袋子里硬币的数量**不同**。\n监狱长给囚徒们提出了挑战，目标是指出硬币数量较少的那个袋子。\n\n房间里除了袋子还有一块白板。\n任意时刻白板上写着一个数，一开始写的是 $0$。\n\n监狱长让囚徒一个接一个地进入房间。\n每个进入房间的囚徒不知道他之前进入过房间的囚徒有多少人，也不知道是哪些人。\n每次一个囚徒进入房间时，他看一眼白板上目前写的这个数。\n看完之后，他必须在袋子 A 和 B 之间做出选择。\n接着，他**检查**自己选的那个袋子，知道了里面有多少枚硬币。\n然后，这名囚徒必须选择做以下两种**行动**之一：\n\n* 将白板上的数改写成一个非负整数，并离开房间。\n注意他可以改变成新的数，也可以保留当前的数。\n然后挑战继续进行（除非所有 $500$ 名囚徒都已经进过房间）。\n* 指出硬币数量较少的那个袋子。这会立即结束挑战。\n\n对于已经进过房间的囚徒，监狱长不会让他再次进入房间。\n\n如果某个囚徒正确地指出硬币较少的袋子，则囚徒们获得挑战的胜利。\n如果指出的袋子不正确，或者所有 $500$ 人进过房间之后还没有人尝试指出硬币较少的袋子，则囚徒们失败。\n\n挑战开始之前，囚徒们集合在监狱大厅商量应对挑战的共同**策略**，分以下三个步骤：\n* 他们挑选一个非负整数 $x$，作为他们可能会写在白板上的最大的数。\n* 他们决定对任意一个数 $i$ ($0 \\le i \\le x$)，如果某个囚徒进入房间后看到白板上写着数 $i$，那么他应该去检查哪个袋子。\n* 他们决定当某个囚徒得知选中的袋子里的硬币数量后要采取的行动。具体来说，对任意写在白板上的数 $i$ ($0 \\le i \\le x$) 和检查选中的袋子里的硬币数量 $j$ ($1 \\le j \\le N$)，他们要决定做出以下两种行动之一：\n  - 白板上应该要写一个 $0$ 到 $x$ 之间（包含 $0$ 和 $x$）的什么数；\n  - 指出哪个袋子是硬币较少的。\n\n如果赢得挑战，监狱长会在囚徒们继续服刑 $x$ 天后释放他们。\n\n你的任务是提出能够确保囚徒们赢得挑战的策略（不管袋子 A 和 B 中的硬币数量是多少）。\n你的得分取决于 $x$ 的值（详见子任务一节）。", "inputFormat": "你要实现以下函数：\n\n```go\nint[][] devise_strategy(int N)\n```\n\n- $N$：每个袋子里硬币最多可能的数量。\n- 该函数需要返回一个数组 $s$，它的每个元素是长度为 $N + 1$ 的整数数组，表示你给出的策略。$x$ 的值是数组 $s$ 的长度减一。对满足 $0 \\le i \\le x$ 的每个 $i$，数组 $s_i$ 表示囚徒在进入房间看到白板上写着数 $i$ 时要做的事情：\n  1. 如果囚徒应该检查袋子 A，则 $s_{i, 0}$ 的值是 $0$；如果囚徒应该检查袋子 B，则该值是 $1$。\n  2. 令 $j$ 为所选袋子中的硬币数量，囚徒应该进行以下行动：\n     - 如果 $s_{i, j}$ 的值是 $-1$，则囚徒应该指出袋子 A 是硬币较少的袋子。\n     - 如果 $s_{i, j}$ 的值是 $-2$，则囚徒应该指出袋子 B 是硬币较少的袋子。\n     - 如果 $s_{i, j}$ 的值是非负整数，则囚徒应该把这个数写到白板上。注意 $s_{i, j}$ 至多只能是 $x$。\n- 该函数恰好被调用一次。", "outputFormat": "考虑以下调⽤：\n\n```go\ndevise_strategy(3)\n```\n\n令 $v$ 表示囚徒进入房间时看到白板上写着的数。以下是一种正确的策略：\n\n- 如果 $v = 0$（也包括开始时的数），则检查袋子 A。\n  - 如果它装了 $1$ 个硬币，则指出袋子 A 是硬币较少的袋子。\n  - 如果它装了 $3$ 个硬币，则指出袋子 B 是硬币较少的袋子。\n  - 如果它装了 $2$ 个硬币，则在白板上写上 $1$（覆盖之前的 $0$）。\n- 如果 $v = 1$，则检查袋子 B。\n  - 如果它装了 $1$ 个硬币，则指出袋子 B 是硬币较少的袋子。\n  - 如果它装了 $3$ 个硬币，则指出袋子 A 是硬币较少的袋子。\n  - 如果它装了 $2$ 个硬币，则在白板上写上 $0$（覆盖之前的 $1$）。注意，这种情况其实不可能发生，因为此时两个袋子都装有 $2$ 枚硬币，是不允许的。\n\n要产生以上策略，函数应该返回 `[[0, -1, 1, -2], [1, -2, 0, -1]]`。\n返回的数组长度是 $2$，此时 $x$ 的值是 $2 - 1 = 1$。", "hint": "### 约束条件\n\n- $2 \\leq N \\leq 5000$。\n\n### 子任务\n\n1. （5 分）$N \\le 500$，$x$ 的值不能超过 $500$。\n1. （5 分）$N \\le 500$，$x$ 的值不能超过 $70$。\n1. （90分）$x$ 的值不能超过 $60$。\n\n对于任何测试用例，如果 `devise_strategy` 返回的数组是不合法的，则你在该子任务上的得分为 $0$。\n\n子任务 3 有部分分。\n令 $m$ 为该子任务中所有测试用例返回数组对应的 $x$ 的最大值，你的得分将根据下表计算：\n\n| 条件 | 得分 |\n| :-: | :-: |\n| $40 \\leq m \\leq 60$ | $20$ |\n| $26 \\leq m \\leq 39$ | $25 + 1.5 \\times (40 − m)$ |\n| $m = 25$ | $50$ |\n| $m = 24$ | $55$ |\n| $m = 23$ | $62$ |\n| $m = 22$ | $70$ |\n| $m = 21$ | $80$ |\n| $m \\leq 20$ | $90$ |\n\n### 评测程序示例\n\n评测程序示例按以下格式读取输入：\n\n* 第 $1$ 行：$N$\n* 第 $2 + k$ 行 ($0 \\le k$)：$A_k \\; B_k$\n* 最后一行：$-1$\n\n除第一行和最后一行外，每行表示一个场景。\n将第 $2 + k$ 行对应的场景称为场景 $k$。\n场景 $k$ 中，袋子 A 装有 $A[k]$ 枚硬币，袋子 B 装有 $B[k]$ 枚硬币。\n\n评测程序示例首先调用 `devise_strategy(N)`。\n$x$ 的值是返回数组的长度减一。\n如果评测程序示例检测到 `devise_strategy` 返回的数组不符合实现细节中描述的约束，它会打印如下错误信息并退出：\n\n* `s is an empty array`：$s$ 是空的数组（表示不合法的策略）。\n* `s[i] contains incorrect length`：存在一个下标 $i$ ($0 \\le i \\le x$) 满足 $s_i$ 的长度不是 $N + 1$。\n* `First element of s[i] is non-binary`：存在一个下标 $i$ ($0 \\le i \\le x$) 满足 $s_{i,0}$ 既不是 $0$，也不是$1$。\n* `s[i][j] contains incorrect value`：存在下标 $i, j$ ($0 \\le i \\le x, 1 \\le j \\le N$) 满足 $s_{i, j}$ 的值不在 $-2$ 和 $x$ 之间。\n\n否则，评测程序示例产生两项输出内容。\n\n首先，评测程序示例以如下格式打印你的策略的输出：\n\n* 第 $1 + k$ 行 ($0 \\le k$)：场景 $k$ 下你的策略的输出。\n如果用该策略导致某个囚徒指出袋子 A 是硬币较少的，则输出字符 `A`。\n如果用该策略导致某个囚徒指出袋子 B 是硬币较少的，则输出字符 `B`。\n如果用该策略后没有囚徒指出哪个袋子的硬币较少，则输出字符 `X`。\n\n其次，评测程序示例以如下格式在当前目录下写一个文件 `log.txt`：\n\n* 第 $1 + k$ 行 ($0 \\le k$)：$w_{k,0} \\; w_{k,1} \\; \\ldots$\n\n第 $1 + k$ 行的序列对应于场景 $k$，描述了写在白板上的数。\n具体来说，$w[k][l]$ 是第 $l + 1$ 个囚徒进入房间后写的数。\n\n### 约定\n\n题面在给出函数接口时，会使用一般性的类型名称 `void`、`int`、`int64`、`int[]`（数组）和 `int[][]`（数组的数组）。\n\n在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：\n\n| `void ` | `int` | `int64`     | `int[]`            |\n| ------- | ----- | ----------- | ------------------ |\n| `void ` | `int` | `long long` | `std::vector<int>` |\n\n| `int[][]`                       | 数组 `a` 的长度 |\n| ------------------------------- | ------------------- |\n| `std::vector<std::vector<int>>` | `a.size()`          |\n", "locale": "zh-CN"}}}
{"pid": "P8492", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "IOI", "交互题"], "title": "[IOI 2022] 无线电信号塔", "background": "\n\n### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。", "description": "雅加达有 $N$ 个无线电信号塔。这些信号塔排布成一条直线，并且从左到右依次编号为从 $0$ 到 $N - 1$。\n对于每个满足 $0 \\le i \\le N - 1$ 的 $i$，信号塔 $i$ 的高度为 $H_i$ 米。\n所有塔的高度都是**不同的**。\n\n对于某个为正数的信号干扰参数 $\\delta$，一对信号塔 $i$ 和 $j$ ($0 \\le i \\lt j \\le N - 1$) 之间能够互相通信，当且仅当存在一个中间信号塔 $k$ 满足如下条件：\n\n* 塔 $i$ 在塔 $k$ 的左边，并且塔 $j$ 在塔 $k$ 的右边，即 $i \\lt k \\lt j$；\n* 塔 $i$ 和塔 $j$ 的高度都至多为 $H[k] - \\delta$ 米。\n\nPak Dengklek 想租一些信号塔来组建他的新无线电网络。\n你的任务是回答 Pak Dengklek 提出的 $Q$ 个询问。这些询问的形式如下：\n给定参数 $L, R$ 和 $D$ ($0 \\le L \\le R \\le N - 1$ 且 $D > 0$)，在满足下述所有条件时，Pak Dengklek 最多能够租多少个信号塔：\n\n * Pak Dengklek 只能租编号在 $L$ 和 $R$ 之间的信号塔（包括 $L$和 $R$）；\n * 信号干扰参数 $\\delta$ 的值为 $D$；\n * Pak Dengklek 租的信号塔两两之间必须能够进行通信。\n\n注意，无论中间信号塔 $k$ 是否被租，两个已租的信号塔都可以借助信号塔 $k$ 进行通信。", "inputFormat": "你需要实现以下函数：\n\n```go\nvoid init(int N, int[] H)\n```\n\n* $N$： 信号塔的数量。\n* $H$： 一个长度为 $N$ 的数组，给出信号塔的高度。\n* 这个函数恰好被调用一次，且在函数 `max_towers` 的所有调用之前。\n\n```go\nint max_towers(int L, int R, int D)\n```\n\n* $L$, $R$：信号塔编号区间的边界。\n* $D$：信号干扰参数 $\\delta$ 的值。\n* 该函数应返回 Pak Dengklek 最多能租的信号塔数量（用于组建信号网络），这里 Pak Dengklek 只能租 $L$ 和 $R$之间（包含 $L$ 和 $R$）的信号塔，且信号干扰参数 $\\delta$ 的值是 $D$。\n* 该函数将被调用恰好 $Q$ 次。", "outputFormat": "考虑如下函数调⽤序列：\n\n```go\ninit(7, [10, 20, 60, 40, 50, 30, 70])\n```\n\n```go\nmax_towers(1, 5, 10)\n```\n\nPak Dengklek 可以租编号为 $1$, $3$ 和 $5$ 的信号塔。\n下面给出了这个例子的示意图，其中的灰色梯形表示被租的信号塔。\n\n![](https://img.loj.ac.cn/2022/08/10/a52f5b077031b.png)\n\n信号塔 $3$ 和 $5$ 可以借助信号塔 $4$ 进行通信，这是因为 $40 \\le 50 - 10$ 且 $30 \\le 50 - 10$。\n信号塔 $1$ 和 $3$ 可以借助信号塔 $2$ 进行通信。\n信号塔 $1$ 和 $5$ 可以借助信号塔 $3$ 进行通信。\n无法租超过 $3$ 个信号塔，因此函数应返回 $3$。\n\n```go\nmax_towers(2, 2, 100)\n```\n\n在这个区间里只有 $1$ 个信号塔，所以 Pak Dengklek 只能租借 $1$ 个信号塔。\n因此函数应返回 $1$。\n\n```go\nmax_towers(0, 6, 17)\n```\n\nPak Dengklek 可以租信号塔$1$ 和 $3$ 。\n信号塔  $1$ 和 $3$ 可以借助信号塔 $2$进行通信，这是因为 $20 \\le 60 - 17$ 且 $40 \\le 60 - 17$。\n无法租赁超过 $2$ 个信号塔，因此函数应返回 $2$。", "hint": "### 约束条件\n\n* $1 \\le N \\le 100\\;000$\n* $1 \\le Q \\le 100\\;000$\n* $1 \\le H_i \\le 10^9$ (对于所有满足 $0 \\le i \\le N - 1$ 的 $i$ )\n* $H_i \\ne H_j$ (对于所有满足 $0 \\le i \\lt j \\le N - 1$  的 $i$ 和 $j$ )\n* $0 \\le L \\le R \\le N - 1$\n* $1 \\le D \\le 10^9$\n\n### 子任务\n\n1. (4 分) 存在一个满足下述所有条件的信号塔 $k$ ($0 \\le k \\le N - 1$) \n   * 对于 $0 \\le i \\le k - 1$ 的每个 $i$：$H_i \\lt H_{i + 1}$ \n   * 对于 $k \\le i \\le N - 2$ 的每个 $i$：$H_i \\gt H_{i + 1}$ \n2. (11 分) $Q = 1$，$N \\le 2000$\n3. (12 分) $Q = 1$\n4. (14 分) $D = 1$\n5. (17 分) $L = 0$，$R = N - 1$\n6. (19 分)  $D$ 的值在 `max_towers` 的所有调用中都是相同的\n7. (23 分) 没有额外的限制\n\n### 评测程序示例\n\n评测程序示例读取如下格式的输入：\n\n* 第 $1$ 行：$N \\; Q$\n* 第 $2$ 行：$H_{0} \\; H_{1} \\; \\ldots \\; H_{N - 1}$\n* 第 $3 + j$ 行（$0 \\le j \\le Q - 1$）：$L \\; R \\; D$（对应第 $j$ 次询问）\n\n评测程序示例按照如下的格式打印你的答案：\n\n* 第 $1 + j$ 行（$0 \\le j \\le Q - 1$）：`max_towers` 对第 $j$ 次询问的返回值\n\n### 约定\n\n题面在给出函数接口时，会使用一般性的类型名称 `void`、`int`、`int64`、`int[]`（数组）和 `int[][]`（数组的数组）。\n\n在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：\n\n| `void ` | `int` | `int64`     | `int[]`            |\n| ------- | ----- | ----------- | ------------------ |\n| `void ` | `int` | `long long` | `std::vector<int>` |\n\n| `int[][]`                       | 数组 `a` 的长度 |\n| ------------------------------- | ------------------- |\n| `std::vector<std::vector<int>>` | `a.size()`          |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2022] 无线电信号塔", "background": "\n\n### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。", "description": "雅加达有 $N$ 个无线电信号塔。这些信号塔排布成一条直线，并且从左到右依次编号为从 $0$ 到 $N - 1$。\n对于每个满足 $0 \\le i \\le N - 1$ 的 $i$，信号塔 $i$ 的高度为 $H_i$ 米。\n所有塔的高度都是**不同的**。\n\n对于某个为正数的信号干扰参数 $\\delta$，一对信号塔 $i$ 和 $j$ ($0 \\le i \\lt j \\le N - 1$) 之间能够互相通信，当且仅当存在一个中间信号塔 $k$ 满足如下条件：\n\n* 塔 $i$ 在塔 $k$ 的左边，并且塔 $j$ 在塔 $k$ 的右边，即 $i \\lt k \\lt j$；\n* 塔 $i$ 和塔 $j$ 的高度都至多为 $H[k] - \\delta$ 米。\n\nPak Dengklek 想租一些信号塔来组建他的新无线电网络。\n你的任务是回答 Pak Dengklek 提出的 $Q$ 个询问。这些询问的形式如下：\n给定参数 $L, R$ 和 $D$ ($0 \\le L \\le R \\le N - 1$ 且 $D > 0$)，在满足下述所有条件时，Pak Dengklek 最多能够租多少个信号塔：\n\n * Pak Dengklek 只能租编号在 $L$ 和 $R$ 之间的信号塔（包括 $L$和 $R$）；\n * 信号干扰参数 $\\delta$ 的值为 $D$；\n * Pak Dengklek 租的信号塔两两之间必须能够进行通信。\n\n注意，无论中间信号塔 $k$ 是否被租，两个已租的信号塔都可以借助信号塔 $k$ 进行通信。", "inputFormat": "你需要实现以下函数：\n\n```go\nvoid init(int N, int[] H)\n```\n\n* $N$： 信号塔的数量。\n* $H$： 一个长度为 $N$ 的数组，给出信号塔的高度。\n* 这个函数恰好被调用一次，且在函数 `max_towers` 的所有调用之前。\n\n```go\nint max_towers(int L, int R, int D)\n```\n\n* $L$, $R$：信号塔编号区间的边界。\n* $D$：信号干扰参数 $\\delta$ 的值。\n* 该函数应返回 Pak Dengklek 最多能租的信号塔数量（用于组建信号网络），这里 Pak Dengklek 只能租 $L$ 和 $R$之间（包含 $L$ 和 $R$）的信号塔，且信号干扰参数 $\\delta$ 的值是 $D$。\n* 该函数将被调用恰好 $Q$ 次。", "outputFormat": "考虑如下函数调⽤序列：\n\n```go\ninit(7, [10, 20, 60, 40, 50, 30, 70])\n```\n\n```go\nmax_towers(1, 5, 10)\n```\n\nPak Dengklek 可以租编号为 $1$, $3$ 和 $5$ 的信号塔。\n下面给出了这个例子的示意图，其中的灰色梯形表示被租的信号塔。\n\n![](https://img.loj.ac.cn/2022/08/10/a52f5b077031b.png)\n\n信号塔 $3$ 和 $5$ 可以借助信号塔 $4$ 进行通信，这是因为 $40 \\le 50 - 10$ 且 $30 \\le 50 - 10$。\n信号塔 $1$ 和 $3$ 可以借助信号塔 $2$ 进行通信。\n信号塔 $1$ 和 $5$ 可以借助信号塔 $3$ 进行通信。\n无法租超过 $3$ 个信号塔，因此函数应返回 $3$。\n\n```go\nmax_towers(2, 2, 100)\n```\n\n在这个区间里只有 $1$ 个信号塔，所以 Pak Dengklek 只能租借 $1$ 个信号塔。\n因此函数应返回 $1$。\n\n```go\nmax_towers(0, 6, 17)\n```\n\nPak Dengklek 可以租信号塔$1$ 和 $3$ 。\n信号塔  $1$ 和 $3$ 可以借助信号塔 $2$进行通信，这是因为 $20 \\le 60 - 17$ 且 $40 \\le 60 - 17$。\n无法租赁超过 $2$ 个信号塔，因此函数应返回 $2$。", "hint": "### 约束条件\n\n* $1 \\le N \\le 100\\;000$\n* $1 \\le Q \\le 100\\;000$\n* $1 \\le H_i \\le 10^9$ (对于所有满足 $0 \\le i \\le N - 1$ 的 $i$ )\n* $H_i \\ne H_j$ (对于所有满足 $0 \\le i \\lt j \\le N - 1$  的 $i$ 和 $j$ )\n* $0 \\le L \\le R \\le N - 1$\n* $1 \\le D \\le 10^9$\n\n### 子任务\n\n1. (4 分) 存在一个满足下述所有条件的信号塔 $k$ ($0 \\le k \\le N - 1$) \n   * 对于 $0 \\le i \\le k - 1$ 的每个 $i$：$H_i \\lt H_{i + 1}$ \n   * 对于 $k \\le i \\le N - 2$ 的每个 $i$：$H_i \\gt H_{i + 1}$ \n2. (11 分) $Q = 1$，$N \\le 2000$\n3. (12 分) $Q = 1$\n4. (14 分) $D = 1$\n5. (17 分) $L = 0$，$R = N - 1$\n6. (19 分)  $D$ 的值在 `max_towers` 的所有调用中都是相同的\n7. (23 分) 没有额外的限制\n\n### 评测程序示例\n\n评测程序示例读取如下格式的输入：\n\n* 第 $1$ 行：$N \\; Q$\n* 第 $2$ 行：$H_{0} \\; H_{1} \\; \\ldots \\; H_{N - 1}$\n* 第 $3 + j$ 行（$0 \\le j \\le Q - 1$）：$L \\; R \\; D$（对应第 $j$ 次询问）\n\n评测程序示例按照如下的格式打印你的答案：\n\n* 第 $1 + j$ 行（$0 \\le j \\le Q - 1$）：`max_towers` 对第 $j$ 次询问的返回值\n\n### 约定\n\n题面在给出函数接口时，会使用一般性的类型名称 `void`、`int`、`int64`、`int[]`（数组）和 `int[][]`（数组的数组）。\n\n在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：\n\n| `void ` | `int` | `int64`     | `int[]`            |\n| ------- | ----- | ----------- | ------------------ |\n| `void ` | `int` | `long long` | `std::vector<int>` |\n\n| `int[][]`                       | 数组 `a` 的长度 |\n| ------------------------------- | ------------------- |\n| `std::vector<std::vector<int>>` | `a.size()`          |\n", "locale": "zh-CN"}}}
{"pid": "P8493", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "IOI", "交互题", "树形 DP", "组合数学", "期望"], "title": "[IOI 2022] 数字电路", "background": "**由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。**\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。\n\n由于本题数据点过多，结合洛谷评测技术实现情况，本题将不按照题给 Subtask 评分。", "description": "有一个数字电路，由编号为从 $0$ 到 $N + M - 1$ 的 $N + M$ 个**门**组成。其中，$0$ 到 $N - 1$ 号门是**阈值门**，而 $N$ 到 $N + M - 1$ 号门是**输入门**。\n\n除 $0$ 号门之外的每个门都是恰好一个某阈值门的**输入**。具体来说，对于每个满足 $1 \\le i \\le N + M - 1$ 的 $i$，门 $i$ 是门 $P[i]$ 的一个输入，其中 $0 \\le P[i] \\le N-1$。重要的是，我们保证 $P[i] \\lt i$ 成立。此外，我们假设有 $P[0] = -1$。每个阈值门有一个或多个的输入。输入门没有任何输入。\n\n每个门都有一个**状态**，取 $0$ 或 $1$。输入门的初始状态由一个包含 $M$ 个整数的数组 $A$ 给定。也就是说，对于每个满足 $0 \\le j \\le M - 1$ 的 $j$ ，输入门 $N + j$ 的初始状态为 $A[j]$。\n\n每个阈值门的状态取决于它的输入的状态，具体如下。首先，每个阈值门会被指定一个阈值**参数**。对于一个有 $c$ 个输入的阈值门，其所指定的参数必须是 $1$ 到 $c$ 之间的某个整数（包括 $1$ 和 $c$）。随后，对于一个参数为 $p$ 的阈值门，如果它的输入中至少有 $p$ 个门的状态为 $1$，则当前阈值门的状态为 $1$，否则状态为 $0$。\n\n例如，假设有 $N = 3$ 个阈值门和 $M = 4$ 个输入门。其中，门 $0$ 的输入为门 $1$ 和门 $6$，门 $1$ 的输入为门 $2$、$4$ 和 $5$，门 $2$ 仅有的输入为门 $3$。\n\n上述例子的说明可见下图。\n\n![](https://arina.loli.net/2022/08/12/JtjqOi4HVBXeD3x.png)\n\n假设输入门 $3$ 和 $5$ 的状态为 $1$，而门 $4$ 和 $6$ 的状态为 $0$。假设阈值门 $2$、$1$、$0$ 被指定的参数分别为 $1$、$2$、$2$。在这种情况下，门 $2$ 的状态为 $1$，门 $1$ 的状态为 $1$ ，门 $0$ 的状态为 $0$。下面给出了参数赋值以及状态的示意图。状态为 $1$ 的门被标记为黑色。\n\n![](https://arina.loli.net/2022/08/12/Sdiye2vg3B1aYPu.png)\n\n输入门的状态将会经历 $Q$ 次更新。每次更新用两个整数 $L$ 和 $R$ 来描述 ($N \\le L \\le R \\le N + M - 1$) ，表示翻转所有编号在 $L$ 和 $R$ 之间（包括 $L$ 和 $R$）的输入门的状态。这就是说，对于所有满足 $L \\le i \\le R$ 的 $i$，输入门 $i$ 的状态如果为 $0$，则会被翻转为$1$；如果状态为 $1$，则会被翻转为 $0$。每个门被翻转后将会一直保持在新状态，直到在后续某次更新中被翻转。\n\n你的目标是，计算每次更新后有多少种阈值门参数的赋值方案，使得门 $0$ 的状态为 $1$。当有至少一个阈值门的参数不同时，两种参数赋值方案被认为是不同的。由于方案数可能较大，你需要计算它对 $1\\;000\\;002\\;022$ 取模的结果。\n\n注意，在上面的例子中，共有 $6$ 种不同的对阈值门参数进行赋值的方案，因为门 $0$、$1$、$2$ 分别有 $2$、$3$、$1$ 个输入。在这 $6$ 种方案里面，有 $2$ 种参数赋值方案使得门 $0$ 的状态为 $1$。", "inputFormat": "你的任务是实现下述两个函数。\n\n```go\nvoid init(int N, int M, int[] P, int[] A)\n```\n\n- $N$： 阈值门的数量。\n- $M$：输入门的数量。\n- $P$： 一个长度为 $N + M$ 的数组，给出阈值门的输入。\n- $A$： 一个长度为 $M$ 的数组，给出输入门的初始状态。\n- 这个函数被调用恰好一次，且发生在函数 `count_ways` 的所有调用之前。\n\n```go\nint count_ways(int L, int R)\n```\n\n- $L$, $R$：编号在 $L$ 和 $R$ 之间的输入门的状态将会被翻转。\n- 这个函数应首先执行所规定的更新，然后返回使得门 $0$ 的状态为 $1$ 的参数赋值方案的方案数对 $1\\;000\\;002\\;022$ 取模的结果。\n- 这个函数会被调用恰好 $Q$ 次。", "outputFormat": "考虑如下的函数调用序列：\n\n```go\ninit(3, 4, [-1, 0, 1, 2, 1, 1, 0], [1, 0, 1, 0])\n```\n\n题面描述中已经给出了对这个例子的解释。\n\n```go\ncount_ways(3, 4)\n```\n\n这次调用翻转了门 $3$ 和 $4$ 的状态，也就是说，门 $3$ 的状态变成 $0$，门 $4$ 的状态变成 $1$。下面给出了两种可行的参数赋值方案，可以使得门 $0$ 的状态为 $1$ 。\n\n|               方案 $1$                |               方案 $2$                |\n| :-----------------------------------: | :-----------------------------------: |\n| ![](https://arina.loli.net/2022/08/12/azi4xDYOKpBnge6.png) | ![](https://arina.loli.net/2022/08/12/MBPhnOFyARSEQDH.png) |\n\n在所有其他的参数赋值方案中，门 $0$ 的状态为 $0$。因此，函数应返回 $2$。\n\n```go\ncount_ways(4, 5)\n```\n\n这次调用翻转了门 $4$ 和 $5$ 的状态。其结果是，所有输入门的状态均为 $0$，而且对于所有的参数赋值方案，门 $0$ 的状态均为 $0$。因此，函数应返回 $0$。\n\n```go\ncount_ways(3, 6)\n```\n\n这次调用将所有输入门的状态置为 $1$。其结果是，对于所有参数赋值方案，门 $0$ 的状态均为 $1$。因此，函数应返回 $6$。", "hint": "### 约束条件\n\n- $1 \\le N, M \\le 10^5$；\n- $1 \\le Q \\le 10^5$；\n- $P[0] = -1$；\n- $0 \\le P[i] \\lt i$ 且 $P[i] \\le N - 1$（对于所有满足 $1 \\le i \\le N + M - 1$ 的 $i$）；\n- 每个阈值门至少有一个输入（对于所有满足 $0 \\le i \\le N - 1$ 的 $i$，存在某个下标 $x$ 满足 $i \\lt x \\le N + M - 1$ 且 $P[x] = i$）；\n- $0 \\le A[j] \\le 1$（对于所有满足 $0 \\le j \\le M - 1$的 $j$）；\n- $N \\le L \\le R \\le N + M - 1$。\n\n### 子任务\n\n1. （2 分）$N = 1$，$M \\le 1000$，$Q \\le 5$；\n2. （7 分）$N, M \\le 1000$，$Q \\le 5$，每个阈值门都有恰好两个输入；\n3. （9 分）$N, M \\le 1000$，$Q \\le 5$；\n4. （4 分）$M = N + 1$，$M = 2^z$（对于某个正整数 $z$）， $P[i] = \\lfloor\\frac{i - 1}{2}\\rfloor$（对于所有满足 $1 \\le i \\le N + M - 1$ 的 $i$），$L = R$；\n5. （12 分）$M = N + 1$，$M = 2^z$（对于某个正整数 $z$），$P[i] = \\lfloor\\frac{i - 1}{2}\\rfloor$（对于所有满足$1 \\le i \\le N + M - 1$的 $i$）；\n6. （27 分）每个阈值门都恰好有两个输入；\n7. （28 分）$N, M \\le 5000$；\n8. （11 分）没有额外的约束条件。\n\n### 评测程序示例\n\n评测程序示例读取如下格式的输入：\n\n- 第 $1$ 行： $N \\; M \\; Q$；\n- 第 $2$ 行： $P[0] \\; P[1] \\; \\ldots \\; P[N + M - 1]$；\n- 第 $3$ 行： $A[0] \\; A[1] \\; \\ldots \\; A[M - 1]$；\n- 第 $4 + k$ 行（$0 \\le k \\le Q - 1$）： 第 $k$ 次更新对应的 $L \\; R$。\n\n评测程序示例按照如下格式打印你的答案：\n\n- 第 $1 + k$ 行（$0 \\le k \\le Q - 1$）： `count_ways` 函数对第 $k$ 次更新的返回值。\n\n### 约定\n\n题面在给出函数接口时，会使用一般性的类型名称 `void`、`bool`、`int`、`int[]`（数组）和 `union(bool, int[])`。\n\n在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：\n\n| `void ` | `bool` | `int` | `int[]`            |\n| ------- | ------ | ------| ------------------ |\n| `void ` | `bool` | `int` | `std::vector<int>` |\n\n| `union(bool, int[])`                   | 数组 `a` 的长度 |\n| -------------------------------------- | ------------------- |\n| `std::variant<bool, std::vector<int>>` | `a.size()`          |\n\nC++ 语言里，`std::variant` 定义在 `<variant>` 头文件中。\n一个返回类型为 `std::variant<bool, std::vector<int>>` 的函数可以返回一个 `bool` 或一个 `std::vector<int>`。\n以下示例代码给出了三个返回 `std::variant` 的函数，它们都能正常工作：\n\n```cpp\nstd::variant<bool, std::vector<int>> foo(int N) {\n    return N % 2 == 0;\n}\n\nstd::variant<bool, std::vector<int>> goo(int N) {\n    return std::vector<int>(N, 0);\n}\n\nstd::variant<bool, std::vector<int>> hoo(int N) {\n    if (N % 2 == 0) {\n        return false;\n    }\n\n    return std::vector<int>(N, 0);\n}\n```", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2022] 数字电路", "background": "**由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。**\n\n这是一道交互题，你只需要实现代码中要求的函数。\n\n你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。\n\n由于本题数据点过多，结合洛谷评测技术实现情况，本题将不按照题给 Subtask 评分。", "description": "有一个数字电路，由编号为从 $0$ 到 $N + M - 1$ 的 $N + M$ 个**门**组成。其中，$0$ 到 $N - 1$ 号门是**阈值门**，而 $N$ 到 $N + M - 1$ 号门是**输入门**。\n\n除 $0$ 号门之外的每个门都是恰好一个某阈值门的**输入**。具体来说，对于每个满足 $1 \\le i \\le N + M - 1$ 的 $i$，门 $i$ 是门 $P[i]$ 的一个输入，其中 $0 \\le P[i] \\le N-1$。重要的是，我们保证 $P[i] \\lt i$ 成立。此外，我们假设有 $P[0] = -1$。每个阈值门有一个或多个的输入。输入门没有任何输入。\n\n每个门都有一个**状态**，取 $0$ 或 $1$。输入门的初始状态由一个包含 $M$ 个整数的数组 $A$ 给定。也就是说，对于每个满足 $0 \\le j \\le M - 1$ 的 $j$ ，输入门 $N + j$ 的初始状态为 $A[j]$。\n\n每个阈值门的状态取决于它的输入的状态，具体如下。首先，每个阈值门会被指定一个阈值**参数**。对于一个有 $c$ 个输入的阈值门，其所指定的参数必须是 $1$ 到 $c$ 之间的某个整数（包括 $1$ 和 $c$）。随后，对于一个参数为 $p$ 的阈值门，如果它的输入中至少有 $p$ 个门的状态为 $1$，则当前阈值门的状态为 $1$，否则状态为 $0$。\n\n例如，假设有 $N = 3$ 个阈值门和 $M = 4$ 个输入门。其中，门 $0$ 的输入为门 $1$ 和门 $6$，门 $1$ 的输入为门 $2$、$4$ 和 $5$，门 $2$ 仅有的输入为门 $3$。\n\n上述例子的说明可见下图。\n\n![](https://arina.loli.net/2022/08/12/JtjqOi4HVBXeD3x.png)\n\n假设输入门 $3$ 和 $5$ 的状态为 $1$，而门 $4$ 和 $6$ 的状态为 $0$。假设阈值门 $2$、$1$、$0$ 被指定的参数分别为 $1$、$2$、$2$。在这种情况下，门 $2$ 的状态为 $1$，门 $1$ 的状态为 $1$ ，门 $0$ 的状态为 $0$。下面给出了参数赋值以及状态的示意图。状态为 $1$ 的门被标记为黑色。\n\n![](https://arina.loli.net/2022/08/12/Sdiye2vg3B1aYPu.png)\n\n输入门的状态将会经历 $Q$ 次更新。每次更新用两个整数 $L$ 和 $R$ 来描述 ($N \\le L \\le R \\le N + M - 1$) ，表示翻转所有编号在 $L$ 和 $R$ 之间（包括 $L$ 和 $R$）的输入门的状态。这就是说，对于所有满足 $L \\le i \\le R$ 的 $i$，输入门 $i$ 的状态如果为 $0$，则会被翻转为$1$；如果状态为 $1$，则会被翻转为 $0$。每个门被翻转后将会一直保持在新状态，直到在后续某次更新中被翻转。\n\n你的目标是，计算每次更新后有多少种阈值门参数的赋值方案，使得门 $0$ 的状态为 $1$。当有至少一个阈值门的参数不同时，两种参数赋值方案被认为是不同的。由于方案数可能较大，你需要计算它对 $1\\;000\\;002\\;022$ 取模的结果。\n\n注意，在上面的例子中，共有 $6$ 种不同的对阈值门参数进行赋值的方案，因为门 $0$、$1$、$2$ 分别有 $2$、$3$、$1$ 个输入。在这 $6$ 种方案里面，有 $2$ 种参数赋值方案使得门 $0$ 的状态为 $1$。", "inputFormat": "你的任务是实现下述两个函数。\n\n```go\nvoid init(int N, int M, int[] P, int[] A)\n```\n\n- $N$： 阈值门的数量。\n- $M$：输入门的数量。\n- $P$： 一个长度为 $N + M$ 的数组，给出阈值门的输入。\n- $A$： 一个长度为 $M$ 的数组，给出输入门的初始状态。\n- 这个函数被调用恰好一次，且发生在函数 `count_ways` 的所有调用之前。\n\n```go\nint count_ways(int L, int R)\n```\n\n- $L$, $R$：编号在 $L$ 和 $R$ 之间的输入门的状态将会被翻转。\n- 这个函数应首先执行所规定的更新，然后返回使得门 $0$ 的状态为 $1$ 的参数赋值方案的方案数对 $1\\;000\\;002\\;022$ 取模的结果。\n- 这个函数会被调用恰好 $Q$ 次。", "outputFormat": "考虑如下的函数调用序列：\n\n```go\ninit(3, 4, [-1, 0, 1, 2, 1, 1, 0], [1, 0, 1, 0])\n```\n\n题面描述中已经给出了对这个例子的解释。\n\n```go\ncount_ways(3, 4)\n```\n\n这次调用翻转了门 $3$ 和 $4$ 的状态，也就是说，门 $3$ 的状态变成 $0$，门 $4$ 的状态变成 $1$。下面给出了两种可行的参数赋值方案，可以使得门 $0$ 的状态为 $1$ 。\n\n|               方案 $1$                |               方案 $2$                |\n| :-----------------------------------: | :-----------------------------------: |\n| ![](https://arina.loli.net/2022/08/12/azi4xDYOKpBnge6.png) | ![](https://arina.loli.net/2022/08/12/MBPhnOFyARSEQDH.png) |\n\n在所有其他的参数赋值方案中，门 $0$ 的状态为 $0$。因此，函数应返回 $2$。\n\n```go\ncount_ways(4, 5)\n```\n\n这次调用翻转了门 $4$ 和 $5$ 的状态。其结果是，所有输入门的状态均为 $0$，而且对于所有的参数赋值方案，门 $0$ 的状态均为 $0$。因此，函数应返回 $0$。\n\n```go\ncount_ways(3, 6)\n```\n\n这次调用将所有输入门的状态置为 $1$。其结果是，对于所有参数赋值方案，门 $0$ 的状态均为 $1$。因此，函数应返回 $6$。", "hint": "### 约束条件\n\n- $1 \\le N, M \\le 10^5$；\n- $1 \\le Q \\le 10^5$；\n- $P[0] = -1$；\n- $0 \\le P[i] \\lt i$ 且 $P[i] \\le N - 1$（对于所有满足 $1 \\le i \\le N + M - 1$ 的 $i$）；\n- 每个阈值门至少有一个输入（对于所有满足 $0 \\le i \\le N - 1$ 的 $i$，存在某个下标 $x$ 满足 $i \\lt x \\le N + M - 1$ 且 $P[x] = i$）；\n- $0 \\le A[j] \\le 1$（对于所有满足 $0 \\le j \\le M - 1$的 $j$）；\n- $N \\le L \\le R \\le N + M - 1$。\n\n### 子任务\n\n1. （2 分）$N = 1$，$M \\le 1000$，$Q \\le 5$；\n2. （7 分）$N, M \\le 1000$，$Q \\le 5$，每个阈值门都有恰好两个输入；\n3. （9 分）$N, M \\le 1000$，$Q \\le 5$；\n4. （4 分）$M = N + 1$，$M = 2^z$（对于某个正整数 $z$）， $P[i] = \\lfloor\\frac{i - 1}{2}\\rfloor$（对于所有满足 $1 \\le i \\le N + M - 1$ 的 $i$），$L = R$；\n5. （12 分）$M = N + 1$，$M = 2^z$（对于某个正整数 $z$），$P[i] = \\lfloor\\frac{i - 1}{2}\\rfloor$（对于所有满足$1 \\le i \\le N + M - 1$的 $i$）；\n6. （27 分）每个阈值门都恰好有两个输入；\n7. （28 分）$N, M \\le 5000$；\n8. （11 分）没有额外的约束条件。\n\n### 评测程序示例\n\n评测程序示例读取如下格式的输入：\n\n- 第 $1$ 行： $N \\; M \\; Q$；\n- 第 $2$ 行： $P[0] \\; P[1] \\; \\ldots \\; P[N + M - 1]$；\n- 第 $3$ 行： $A[0] \\; A[1] \\; \\ldots \\; A[M - 1]$；\n- 第 $4 + k$ 行（$0 \\le k \\le Q - 1$）： 第 $k$ 次更新对应的 $L \\; R$。\n\n评测程序示例按照如下格式打印你的答案：\n\n- 第 $1 + k$ 行（$0 \\le k \\le Q - 1$）： `count_ways` 函数对第 $k$ 次更新的返回值。\n\n### 约定\n\n题面在给出函数接口时，会使用一般性的类型名称 `void`、`bool`、`int`、`int[]`（数组）和 `union(bool, int[])`。\n\n在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：\n\n| `void ` | `bool` | `int` | `int[]`            |\n| ------- | ------ | ------| ------------------ |\n| `void ` | `bool` | `int` | `std::vector<int>` |\n\n| `union(bool, int[])`                   | 数组 `a` 的长度 |\n| -------------------------------------- | ------------------- |\n| `std::variant<bool, std::vector<int>>` | `a.size()`          |\n\nC++ 语言里，`std::variant` 定义在 `<variant>` 头文件中。\n一个返回类型为 `std::variant<bool, std::vector<int>>` 的函数可以返回一个 `bool` 或一个 `std::vector<int>`。\n以下示例代码给出了三个返回 `std::variant` 的函数，它们都能正常工作：\n\n```cpp\nstd::variant<bool, std::vector<int>> foo(int N) {\n    return N % 2 == 0;\n}\n\nstd::variant<bool, std::vector<int>> goo(int N) {\n    return std::vector<int>(N, 0);\n}\n\nstd::variant<bool, std::vector<int>> hoo(int N) {\n    if (N % 2 == 0) {\n        return false;\n    }\n\n    return std::vector<int>(N, 0);\n}\n```", "locale": "zh-CN"}}}
{"pid": "P8494", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000, 2048000]}, "tags": ["二分", "2022", "IOI", "交互题", "Special Judge", "随机化", "Ad-hoc"], "title": "[IOI 2022] 最罕见的昆虫", "background": "**本题为交互题。**\n\n您**不需要也不应该**在提交的程序中包含 `insects.h` 头文件和主函数。\n\n但是在您的程序中，需要声明以下三个函数：\n\n```cpp\nvoid move_inside(int i);\nvoid move_outside(int i);\nint press_button();\n```\n\n例如，您的程序可以是这样：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid move_inside(int i);\nvoid move_outside(int i);\nint press_button();\n\nint min_cardinality(int N) {\n\t// Code Here\n}\n```", "description": "Pak Blangkon 的房子四周有 $N$ 只昆虫，编号为 $0$ 至 $N-1$。每只昆虫有一个**类型**，以从 $0$ 至 $10^9$（包含 $0$ 和 $10^9$）的整数编号。可能有多只昆虫类型相同。\n\n假设将昆虫按照类型分组。我们定义**最常见**昆虫类型的基数是昆虫最多的分组中的昆虫数。类似地，**最罕见**昆虫类型的基数是昆虫最少的分组中的昆虫数。\n\n例如，假设有 $11$ 只昆虫，类型分别为 $[5, 7, 9, 11, 11, 5, 0, 11, 9, 100, 9]$。在此情形中，**最常见**昆虫类型的基数是 $3$，是因为类型 $9$ 和类型 $11$ 的分组均有最多数目的昆虫，每个分组都有 $3$ 只。**最罕见**昆虫类型的基数是 $1$，是因为类型 $7$、类型 $0$ 和类型 $100$ 的分组均有最少数目的昆虫，每个分组都有 $1$ 只。\n\nPak Blangkon 不知道这些昆虫的类型。他有一台单按钮的机器，可以提供昆虫类型相关的信息。刚开始时，机器是空的。在使用机器时，可以做如下三种操作：\n\n1. 将一只昆虫放进机器。\n2. 将一只昆虫取出机器。\n3. 按下机器的按钮。\n\n每种操作最多可以做 $40\\;000$ 次。\n\n每当按下按钮时，机器会报告在机器内的**最常见**昆虫类型的基数。\n\n你的任务是使用上述机器，确定 Pak Blangkon 的房子四周所有 $N$ 只昆虫中**最罕见**昆虫类型的基数。此外，在某些子任务里，你的得分取决于机器执行某种操作的最大次数（详见子任务一节）。", "inputFormat": "你要实现以下函数：\n\n```go\nint min_cardinality(int N)\n```\n\n- $N$：昆虫数量。\n- 此函数应返回 Pak Blangkon 的房子四周所有 $N$ 只昆虫中**最罕见**昆虫类型的基数。\n- 此函数恰好被调用一次。\n\n该函数可调用以下几个函数：\n\n```go\nvoid move_inside(int i)\n```\n\n- $i$：将被放进机器的昆虫编号。编号 $i$ 的取值范围是 $0$ 至 $N-1$（包含 $0$ 和 $N-1$）。\n- 如果昆虫已在机器内，函数调用不会影响机器内昆虫的集合。但是，调用仍会被计入此类操作的次数。\n- 此函数最多可以被调用 $40\\;000$ 次。\n\n```go\nvoid move_outside(int i)\n```\n\n- $i$：将被从机器中取出的昆虫编号。编号 $i$ 的取值范围是 $0$ 至 $N-1$（包含 $0$ 和 $N-1$）。\n- 如果昆虫已在机器外，函数调用不会影响机器内昆虫的集合。但是，调用仍会被计入此类操作的次数。\n- 此函数最多可以被调用 $40\\;000$ 次。\n\n```go\nint press_button()\n```\n\n- 此函数返回机器内**最常见**昆虫类型的基数。\n- 此函数最多可以被调用 $40\\;000$ 次。\n- 评测程序**不是适应性**的。也就是说，所有 $N$ 只昆虫的类型在 `min_cardinality` 调用前已经确定。\n", "outputFormat": "考虑在某个场景下，有 $6$ 只类型分别为 $[5, 8, 9, 5, 9, 9]$ 的昆虫。\n函数 `min_cardinality` 的调用方式如下：\n\n```go\nmin_cardinality(6)\n```\n\n此函数按以下次序调用了 `move_inside`、`move_outside` 和 `press_button`。\n\n|     函数调用      |  返回值  |       机器内的昆虫       |   机器内的昆虫类型   |\n| :---------------: | :------: | :----------------------: | :------------------: |\n|                   | $\\\\{\\\\}$ |          $[\\ ]$          |\n| `move_inside(0)`  |          |        $\\\\{0\\\\}$         |        $[5]$         |\n| `press_button()`  |   $1$    |        $\\\\{0\\\\}$         |        $[5]$         |\n| `move_inside(1)`  |          |       $\\\\{0, 1\\\\}$       |       $[5, 8]$       |\n| `press_button()`  |   $1$    |       $\\\\{0, 1\\\\}$       |       $[5, 8]$       |\n| `move_inside(3)`  |          |     $\\\\{0, 1, 3\\\\}$      |     $[5, 8, 5]$      |\n| `press_button()`  |   $2$    |     $\\\\{0, 1, 3\\\\}$      |     $[5, 8, 5]$      |\n| `move_inside(2)`  |          |    $\\\\{0, 1, 2, 3\\\\}$    |    $[5, 8, 9, 5]$    |\n| `move_inside(4)`  |          |  $\\\\{0, 1, 2, 3, 4\\\\}$   |  $[5, 8, 9, 5, 9]$   |\n| `move_inside(5)`  |          | $\\\\{0, 1, 2, 3, 4, 5\\\\}$ | $[5, 8, 9, 5, 9, 9]$ |\n| `press_button()`  |   $3$    | $\\\\{0, 1, 2, 3, 4, 5\\\\}$ | $[5, 8, 9, 5, 9, 9]$ |\n| `move_inside(5)`  |          | $\\\\{0, 1, 2, 3, 4, 5\\\\}$ | $[5, 8, 9, 5, 9, 9]$ |\n| `press_button()`  |   $3$    | $\\\\{0, 1, 2, 3, 4, 5\\\\}$ | $[5, 8, 9, 5, 9, 9]$ |\n| `move_outside(5)` |          |  $\\\\{0, 1, 2, 3, 4\\\\}$   |  $[5, 8, 9, 5, 9]$   |\n| `press_button()`  |   $2$    |  $\\\\{0, 1, 2, 3, 4\\\\}$   |  $[5, 8, 9, 5, 9]$   |\n\n至此，已有充分信息表明，最罕见昆虫类型的基数是 $1$。\n因此，函数 `min_cardinality` 应返回 $1$。\n\n在这个例子里，`move_inside` 被调用 $7$ 次，`move_outside` 被调用 $1$ 次，`press_button` 被调用 $6$ 次。", "hint": "### 约束条件\n\n- $2 \\le N \\le 2000$。\n\n### 子任务\n\n1. （10 分） $N \\le 200$；\n2. （15 分） $N \\le 1000$；\n3. （75 分） 没有额外的约束条件。\n\n如果在某个测试用例上，函数 `move_inside`、`move_outside` 或 `press_button` 的调用次数不符合“实现细节”中给出的约束条件，或者 `min_cardinality` 的返回值不正确，你的解答在此子任务上得分为 $0$。\n\n令 $q$ 为以下三个值的 **最大值**：`move_inside` 的调用次数、`move_outside` 的调用次数、`press_button` 的调用次数。\n\n在子任务 3 中，你可能会得部分分。令 $m$ 为此子任务所有测试用例的 $\\frac{q}{N}$ 的最大值。你在此子任务的得分将根据以下表格计算：\n\n|       条件       |                   得分                   |\n| :--------------: | :--------------------------------------: |\n|    $20 \\lt m$    | $0$ （CMS 报告“`Output isn’t correct`”） |\n| $6 \\lt m \\le 20$ |           $\\frac{225}{m - 2}$            |\n| $3 \\lt m \\le 6$  |          $81 - \\frac{2}{3} m^2$          |\n|    $m \\le 3$     |                   $75$                   |\n\n### 评测程序示例\n\n令 $T$ 是长度为 $N$ 的整数数组，其中 $T[i]$ 是编号为 $i$ 的昆虫的类型。\n\n评测程序示例按以下格式读取输入：\n\n- 第 $1$ 行：$N$；\n- 第 $2$ 行：$T[0] \\; T[1] \\; \\ldots \\; T[N - 1]$。\n\n如果评测程序示例检测到非法行为，评测程序示例将输出 `Protocol Violation: <MSG>`，其中 `<MSG>` 为如下某种类型：\n\n- `invalid parameter`：在函数调用 `move_inside` 或 `move_outside` 时，参数 $i$ 的值不在 $0$ 至 $N-1$ 的范围内（包括 $0$ 和 $N-1$）。\n- `too many calls`：函数 `move_inside`、`move_outside` 或 `press_button` 中**某个**的调用次数超过 $40\\;000$ 次。\n\n否则，评测程序示例按以下格式输出：\n\n- 第 $1$ 行：`min_cardinality` 的返回值；\n- 第 $2$ 行：$q$。\n\n### 约定\n\n题面在给出函数接口时，会使用一般性的类型名称 `void`、`bool`、`int`、`int[]`（数组）和 `union(bool, int[])`。\n\n在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：\n\n| `void ` | `bool` | `int` | `int[]`            |\n| ------- | ------ | ------| ------------------ |\n| `void ` | `bool` | `int` | `std::vector<int>` |\n\n| `union(bool, int[])`                   | 数组 `a` 的长度 |\n| -------------------------------------- | ------------------- |\n| `std::variant<bool, std::vector<int>>` | `a.size()`          |\n\nC++ 语言里，`std::variant` 定义在 `<variant>` 头文件中。\n一个返回类型为 `std::variant<bool, std::vector<int>>` 的函数可以返回一个 `bool` 或一个 `std::vector<int>`。\n以下示例代码给出了三个返回 `std::variant` 的函数，它们都能正常工作：\n\n```cpp\nstd::variant<bool, std::vector<int>> foo(int N) {\n    return N % 2 == 0;\n}\n\nstd::variant<bool, std::vector<int>> goo(int N) {\n    return std::vector<int>(N, 0);\n}\n\nstd::variant<bool, std::vector<int>> hoo(int N) {\n    if (N % 2 == 0) {\n        return false;\n    }\n\n    return std::vector<int>(N, 0);\n}\n```", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2022] 最罕见的昆虫", "background": "**本题为交互题。**\n\n您**不需要也不应该**在提交的程序中包含 `insects.h` 头文件和主函数。\n\n但是在您的程序中，需要声明以下三个函数：\n\n```cpp\nvoid move_inside(int i);\nvoid move_outside(int i);\nint press_button();\n```\n\n例如，您的程序可以是这样：\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid move_inside(int i);\nvoid move_outside(int i);\nint press_button();\n\nint min_cardinality(int N) {\n\t// Code Here\n}\n```", "description": "Pak Blangkon 的房子四周有 $N$ 只昆虫，编号为 $0$ 至 $N-1$。每只昆虫有一个**类型**，以从 $0$ 至 $10^9$（包含 $0$ 和 $10^9$）的整数编号。可能有多只昆虫类型相同。\n\n假设将昆虫按照类型分组。我们定义**最常见**昆虫类型的基数是昆虫最多的分组中的昆虫数。类似地，**最罕见**昆虫类型的基数是昆虫最少的分组中的昆虫数。\n\n例如，假设有 $11$ 只昆虫，类型分别为 $[5, 7, 9, 11, 11, 5, 0, 11, 9, 100, 9]$。在此情形中，**最常见**昆虫类型的基数是 $3$，是因为类型 $9$ 和类型 $11$ 的分组均有最多数目的昆虫，每个分组都有 $3$ 只。**最罕见**昆虫类型的基数是 $1$，是因为类型 $7$、类型 $0$ 和类型 $100$ 的分组均有最少数目的昆虫，每个分组都有 $1$ 只。\n\nPak Blangkon 不知道这些昆虫的类型。他有一台单按钮的机器，可以提供昆虫类型相关的信息。刚开始时，机器是空的。在使用机器时，可以做如下三种操作：\n\n1. 将一只昆虫放进机器。\n2. 将一只昆虫取出机器。\n3. 按下机器的按钮。\n\n每种操作最多可以做 $40\\;000$ 次。\n\n每当按下按钮时，机器会报告在机器内的**最常见**昆虫类型的基数。\n\n你的任务是使用上述机器，确定 Pak Blangkon 的房子四周所有 $N$ 只昆虫中**最罕见**昆虫类型的基数。此外，在某些子任务里，你的得分取决于机器执行某种操作的最大次数（详见子任务一节）。", "inputFormat": "你要实现以下函数：\n\n```go\nint min_cardinality(int N)\n```\n\n- $N$：昆虫数量。\n- 此函数应返回 Pak Blangkon 的房子四周所有 $N$ 只昆虫中**最罕见**昆虫类型的基数。\n- 此函数恰好被调用一次。\n\n该函数可调用以下几个函数：\n\n```go\nvoid move_inside(int i)\n```\n\n- $i$：将被放进机器的昆虫编号。编号 $i$ 的取值范围是 $0$ 至 $N-1$（包含 $0$ 和 $N-1$）。\n- 如果昆虫已在机器内，函数调用不会影响机器内昆虫的集合。但是，调用仍会被计入此类操作的次数。\n- 此函数最多可以被调用 $40\\;000$ 次。\n\n```go\nvoid move_outside(int i)\n```\n\n- $i$：将被从机器中取出的昆虫编号。编号 $i$ 的取值范围是 $0$ 至 $N-1$（包含 $0$ 和 $N-1$）。\n- 如果昆虫已在机器外，函数调用不会影响机器内昆虫的集合。但是，调用仍会被计入此类操作的次数。\n- 此函数最多可以被调用 $40\\;000$ 次。\n\n```go\nint press_button()\n```\n\n- 此函数返回机器内**最常见**昆虫类型的基数。\n- 此函数最多可以被调用 $40\\;000$ 次。\n- 评测程序**不是适应性**的。也就是说，所有 $N$ 只昆虫的类型在 `min_cardinality` 调用前已经确定。\n", "outputFormat": "考虑在某个场景下，有 $6$ 只类型分别为 $[5, 8, 9, 5, 9, 9]$ 的昆虫。\n函数 `min_cardinality` 的调用方式如下：\n\n```go\nmin_cardinality(6)\n```\n\n此函数按以下次序调用了 `move_inside`、`move_outside` 和 `press_button`。\n\n|     函数调用      |  返回值  |       机器内的昆虫       |   机器内的昆虫类型   |\n| :---------------: | :------: | :----------------------: | :------------------: |\n|                   | $\\\\{\\\\}$ |          $[\\ ]$          |\n| `move_inside(0)`  |          |        $\\\\{0\\\\}$         |        $[5]$         |\n| `press_button()`  |   $1$    |        $\\\\{0\\\\}$         |        $[5]$         |\n| `move_inside(1)`  |          |       $\\\\{0, 1\\\\}$       |       $[5, 8]$       |\n| `press_button()`  |   $1$    |       $\\\\{0, 1\\\\}$       |       $[5, 8]$       |\n| `move_inside(3)`  |          |     $\\\\{0, 1, 3\\\\}$      |     $[5, 8, 5]$      |\n| `press_button()`  |   $2$    |     $\\\\{0, 1, 3\\\\}$      |     $[5, 8, 5]$      |\n| `move_inside(2)`  |          |    $\\\\{0, 1, 2, 3\\\\}$    |    $[5, 8, 9, 5]$    |\n| `move_inside(4)`  |          |  $\\\\{0, 1, 2, 3, 4\\\\}$   |  $[5, 8, 9, 5, 9]$   |\n| `move_inside(5)`  |          | $\\\\{0, 1, 2, 3, 4, 5\\\\}$ | $[5, 8, 9, 5, 9, 9]$ |\n| `press_button()`  |   $3$    | $\\\\{0, 1, 2, 3, 4, 5\\\\}$ | $[5, 8, 9, 5, 9, 9]$ |\n| `move_inside(5)`  |          | $\\\\{0, 1, 2, 3, 4, 5\\\\}$ | $[5, 8, 9, 5, 9, 9]$ |\n| `press_button()`  |   $3$    | $\\\\{0, 1, 2, 3, 4, 5\\\\}$ | $[5, 8, 9, 5, 9, 9]$ |\n| `move_outside(5)` |          |  $\\\\{0, 1, 2, 3, 4\\\\}$   |  $[5, 8, 9, 5, 9]$   |\n| `press_button()`  |   $2$    |  $\\\\{0, 1, 2, 3, 4\\\\}$   |  $[5, 8, 9, 5, 9]$   |\n\n至此，已有充分信息表明，最罕见昆虫类型的基数是 $1$。\n因此，函数 `min_cardinality` 应返回 $1$。\n\n在这个例子里，`move_inside` 被调用 $7$ 次，`move_outside` 被调用 $1$ 次，`press_button` 被调用 $6$ 次。", "hint": "### 约束条件\n\n- $2 \\le N \\le 2000$。\n\n### 子任务\n\n1. （10 分） $N \\le 200$；\n2. （15 分） $N \\le 1000$；\n3. （75 分） 没有额外的约束条件。\n\n如果在某个测试用例上，函数 `move_inside`、`move_outside` 或 `press_button` 的调用次数不符合“实现细节”中给出的约束条件，或者 `min_cardinality` 的返回值不正确，你的解答在此子任务上得分为 $0$。\n\n令 $q$ 为以下三个值的 **最大值**：`move_inside` 的调用次数、`move_outside` 的调用次数、`press_button` 的调用次数。\n\n在子任务 3 中，你可能会得部分分。令 $m$ 为此子任务所有测试用例的 $\\frac{q}{N}$ 的最大值。你在此子任务的得分将根据以下表格计算：\n\n|       条件       |                   得分                   |\n| :--------------: | :--------------------------------------: |\n|    $20 \\lt m$    | $0$ （CMS 报告“`Output isn’t correct`”） |\n| $6 \\lt m \\le 20$ |           $\\frac{225}{m - 2}$            |\n| $3 \\lt m \\le 6$  |          $81 - \\frac{2}{3} m^2$          |\n|    $m \\le 3$     |                   $75$                   |\n\n### 评测程序示例\n\n令 $T$ 是长度为 $N$ 的整数数组，其中 $T[i]$ 是编号为 $i$ 的昆虫的类型。\n\n评测程序示例按以下格式读取输入：\n\n- 第 $1$ 行：$N$；\n- 第 $2$ 行：$T[0] \\; T[1] \\; \\ldots \\; T[N - 1]$。\n\n如果评测程序示例检测到非法行为，评测程序示例将输出 `Protocol Violation: <MSG>`，其中 `<MSG>` 为如下某种类型：\n\n- `invalid parameter`：在函数调用 `move_inside` 或 `move_outside` 时，参数 $i$ 的值不在 $0$ 至 $N-1$ 的范围内（包括 $0$ 和 $N-1$）。\n- `too many calls`：函数 `move_inside`、`move_outside` 或 `press_button` 中**某个**的调用次数超过 $40\\;000$ 次。\n\n否则，评测程序示例按以下格式输出：\n\n- 第 $1$ 行：`min_cardinality` 的返回值；\n- 第 $2$ 行：$q$。\n\n### 约定\n\n题面在给出函数接口时，会使用一般性的类型名称 `void`、`bool`、`int`、`int[]`（数组）和 `union(bool, int[])`。\n\n在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：\n\n| `void ` | `bool` | `int` | `int[]`            |\n| ------- | ------ | ------| ------------------ |\n| `void ` | `bool` | `int` | `std::vector<int>` |\n\n| `union(bool, int[])`                   | 数组 `a` 的长度 |\n| -------------------------------------- | ------------------- |\n| `std::variant<bool, std::vector<int>>` | `a.size()`          |\n\nC++ 语言里，`std::variant` 定义在 `<variant>` 头文件中。\n一个返回类型为 `std::variant<bool, std::vector<int>>` 的函数可以返回一个 `bool` 或一个 `std::vector<int>`。\n以下示例代码给出了三个返回 `std::variant` 的函数，它们都能正常工作：\n\n```cpp\nstd::variant<bool, std::vector<int>> foo(int N) {\n    return N % 2 == 0;\n}\n\nstd::variant<bool, std::vector<int>> goo(int N) {\n    return std::vector<int>(N, 0);\n}\n\nstd::variant<bool, std::vector<int>> hoo(int N) {\n    if (N % 2 == 0) {\n        return false;\n    }\n\n    return std::vector<int>(N, 0);\n}\n```", "locale": "zh-CN"}}}
{"pid": "P8495", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2022", "IOI", "交互题", "Special Judge"], "title": "[IOI 2022] 千岛", "background": "不要 $\\texttt{\\#include \"islands.h\"}$。", "description": "千岛是爪哇海里一组美丽的岛屿，其中有 $N$ 个岛屿，编号为从 $0$ 到 $N - 1$。\n\n有 $M$ 艘独木舟在岛屿之间航行，编号为从 $0$ 到 $M - 1$。对于满足 $0 \\le i \\le M - 1$ 的所有 $i$，独木舟 $i$ 可以停靠在岛屿 $U_i$ 或 $V_i$，并且在岛屿 $U_i$ 和 $V_i$ 之间航行。具体来说，当独木舟停靠在岛屿 $U_i$ 时，可以用它从岛屿 $U_i$ 去往岛屿 $V_i$，此后该独木舟就变成停靠在岛屿 $V[i]$。类似地，当该独木舟停靠在岛屿 $V[i]$ 时，它可以从岛屿 $V_i$ 航向岛屿 $U_i$，此后该独木舟就变成停靠在岛屿 $U_i$。在初始时，该独木舟停靠在岛屿 $U_i$。可能有多艘独木舟能用于在同一对岛屿之间航行。也可能会有多艘独木舟停靠在同一个岛屿处。\n\n出于安全考虑，各艘独木舟在每次航行后必须进行维修，因此同一独木舟不允许紧接着完成两次航行。也就是说，在用完某艘独木舟 $i$ 后，必须先用过另外某艘独木舟，才能再启用独木舟 $i$。\n\nBu Dengklek 想策划一次在部分岛屿之间的旅行。她的旅程是**合理的**，当且仅当满足如下条件：\n\n- 她的旅程应从岛屿 $0$ 开始，并且在该岛屿结束。\n- 她应该游览岛屿 $0$ 之外的至少一个岛屿。\n- 在旅行结束后，每艘独木舟应停靠在旅行开始前它所在的岛屿。也就是说，对于满足 $0 \\le i \\le M - 1$ 的所有 $i$，独木舟必须停靠在岛屿 $U_i$。\n\n请你帮助 Bu Dengklek 找出包括至多航行 $2\\;000\\;000$ 次的合理旅行，或者告诉她不存在合理旅行。\n可以证明，在本题所给出的约束条件下（参见约束条件部分），如果存在合理旅行，则必然存在航行次数不超过 $2\\;000\\;000$ 次的合理旅行。", "inputFormat": "你要实现如下函数：\n\n```go\nunion(bool, int[]) find_journey(int N, int M, int[] U, int[] V)\n```\n\n- $N$：岛屿数量。\n- $M$：独木舟数量。\n- $U$, $V$：长度为 $M$ 的两个数组，给出独木舟航行的岛屿。\n- 该函数应当返回一个布尔类型或者整数数组。\n  - 如果不存在合理旅程，该函数应返回 `false`。\n  - 如果存在合理旅程，你有两个选择：\n  - 如果想得到全部的分数，该函数应返回一个至多包含 $2\\;000\\;000$ 个整数的数组，该数组用来刻画一个合理旅程。更确切地说，该数组中的元素应为旅程中所用独木舟的编号（按照独木舟的使用顺序）。\n  - 如果想得到部分分数，该函数应返回 `true`，或返回一个包含超过 $2\\;000\\;000$ 个整数的数组，或返回了一个未给出合理旅程的整数数组（更多细节参见“子任务”部分）。\n- 该函数将被调用恰好一次。", "outputFormat": "### 例子 1\n\n考虑如下调用：\n\n```go\nfind_journey(4, 5, [0, 1, 2, 0, 3], [1, 2, 3, 3, 1])\n```\n\n下图给出了岛屿和独木舟。\n\n![](https://arina.loli.net/2022/08/12/Aey1En5QvcFHrUZ.png)\n\n一个可行的合理旅行如下。Bu Dengklek 先依次使用独木舟 $0$，$1$，$2$ 和 $4$。结果是她将在岛屿 $1$ 上。其后，Bu Dengklek 可以再次使用独木舟 $0$，因为该独木舟正停靠在岛屿 $1$，而且她用的上一艘独木舟不是 $0$。再次使用独木舟 $0$ 后，现在 Bu Dengklek 在岛屿 $0$ 上。然而，独木舟 $1$，$2$ 和 $4$ 没有停靠在旅程开始前它们所在的岛屿。接下来 Bu Dengklek 继续她的旅程，使用独木舟 $3$，$2$，$1$，$4$ 和再一次使用 $3$。Bu Dengklek 回到了岛屿 $0$ 上，并且所有独木舟都停靠在旅行开始前它们所在的岛屿。\n\n因此，返回结果 $[0, 1, 2, 4, 0, 3, 2, 1, 4, 3]$ 刻画了一个合理旅程。\n\n### 例子 2\n\n考虑如下调用：\n\n```go\nfind_journey(2, 3, [0, 1, 1], [1, 0, 0])\n```\n\n下图给出了岛屿和独木舟。\n\n![](https://arina.loli.net/2022/08/12/nWJqhN7KXV3FPRl.png)\n\nBu Dengklek 仅能从使用独木舟 $0$ 开始，此后她可以使用独木舟 $1$ 或者 $2$。注意，她不能连续使用独木舟 $0$ 两次。在两种情况下，Bu Dengklek 都回到了岛屿 $0$ 上。然而，有独木舟没停靠在旅行开始前它们所在的岛屿，而 Bu Dengklek 此后却无法再使用任何独木舟，因为唯一停靠在岛屿 $0$ 的独木舟是她刚用过的那艘。由于不存在合理旅程，该函数应当返回 `false`。", "hint": "### 约束条件\n\n- $2 \\le N \\le 10^5$；\n- $1 \\le M \\le 2 \\times 10^5$；\n- $0 \\le U_i \\le N - 1$ 且 $0 \\le V_i \\le N - 1$（对于所有满足 $0 \\le i \\le M - 1$ 的 $i$）；\n- $U_i \\neq V_i$（对于所有满足 $0 \\le i \\le M - 1$ 的 $i$）。\n\n### 子任务\n\n1. （5 分）$N = 2$。\n1. （5 分） $N \\le 400$。\n   对于每一对不同的岛屿 $x$ 和 $y$（$0 \\le x \\lt y \\le N - 1$），恰好有两艘可在它们之间航行的独木舟。\n   其中一艘停靠在岛屿 $x$，而另一艘停靠在岛屿 $y$。\n1. （21 分） $N \\le 1000$，$M$ 是偶数，而且对于满足 $0 \\le i \\le M - 1$ 的所有**偶数** $i$，独木舟 $i$ 和 $i + 1$ 都可以用于在岛屿 $U_i$ 和 $V_i$ 之间航行。独木舟 $i$ 最初停靠在岛屿 $U_i$ 处，而独木舟 $i + 1$ 最初停靠在岛屿 $V_i$ 处。形式化地，$U_i = V_{i + 1}$ 且 $V_i = U_{i + 1}$。\n1. （24 分） $N \\le 1000$，$M$ 是偶数，而且对于满足 $0 \\le i \\le M - 1$ 的所有**偶数** $i$，独木舟 $i$ 和 $i + 1$ 都可以用于在岛屿 $U_i$ 和 $V_i$ 之间航行。两艘独木舟最初都停靠在岛屿 $U_i$ 处。\n   形式化地，$U_i = U_{i + 1}$ 且 $V_i = V_{i + 1}$。\n1. （45 分）没有额外的约束条件。\n\n对于每个存在合理旅程的测试用例，你的解答：\n\n- 如果返回一个合理旅程，将得到全部分数，\n- 如果返回 `true`，或返回一个超过 $2\\;000\\;000$ 个整数的数组，或返回一个未给出合理旅程的数组，将得到 $35\\%$ 的分数，\n- 在其他情况下得分为 $0$。\n\n对于每个不存在合理旅程的测试用例，你的解答：\n\n- 如果返回 `false`，将得到全部分数，\n- 在其他情况下得分为 $0$。\n\n注意，每个子任务上的最终得分，为该子任务中所有测试用例上的最低得分。\n\n### 评测程序示例\n\n评测程序示例读取如下格式的输入：\n\n- 第 $1$ 行：$N \\; M$；\n- 第 $2 + i$ 行（$0 \\le i \\le M - 1$）：$U_i \\; V_i$。\n\n测试程序示例将按照如下格式打印你的答案：\n\n- 如果 `find_journey` 返回一个 `bool`：\n  - 第 $1$ 行：$0$；\n  - 第 $2$ 行：如果 `find_journey` 返回 `false` 则为 $0$，否则为 $1$。\n- 如果 `find_journey` 返回一个 `int[]`，该数组中的元素记为 $c[0], c[1], \\ldots c[k-1]$。测试程序示例打印出：\n  - 第 $1$ 行：$1$；\n  - 第 $2$ 行：$k$；\n  - 第 $3$ 行：$c[0] \\; c[1] \\; \\ldots \\; c[k-1]$。\n\n### 约定\n\n题面在给出函数接口时，会使用一般性的类型名称 `void`、`bool`、`int`、`int[]`（数组）和 `union(bool, int[])`。\n\n在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：\n\n| `void ` | `bool` | `int` | `int[]`            |\n| ------- | ------ | ------| ------------------ |\n| `void ` | `bool` | `int` | `std::vector<int>` |\n\n| `union(bool, int[])`                   | 数组 `a` 的长度 |\n| -------------------------------------- | ------------------- |\n| `std::variant<bool, std::vector<int>>` | `a.size()`          |\n\nC++ 语言里，`std::variant` 定义在 `<variant>` 头文件中。\n一个返回类型为 `std::variant<bool, std::vector<int>>` 的函数可以返回一个 `bool` 或一个 `std::vector<int>`。\n以下示例代码给出了三个返回 `std::variant` 的函数，它们都能正常工作：\n\n```cpp\nstd::variant<bool, std::vector<int>> foo(int N) {\n    return N % 2 == 0;\n}\n\nstd::variant<bool, std::vector<int>> goo(int N) {\n    return std::vector<int>(N, 0);\n}\n\nstd::variant<bool, std::vector<int>> hoo(int N) {\n    if (N % 2 == 0) {\n        return false;\n    }\n\n    return std::vector<int>(N, 0);\n}\n```", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[IOI 2022] 千岛", "background": "不要 $\\texttt{\\#include \"islands.h\"}$。", "description": "千岛是爪哇海里一组美丽的岛屿，其中有 $N$ 个岛屿，编号为从 $0$ 到 $N - 1$。\n\n有 $M$ 艘独木舟在岛屿之间航行，编号为从 $0$ 到 $M - 1$。对于满足 $0 \\le i \\le M - 1$ 的所有 $i$，独木舟 $i$ 可以停靠在岛屿 $U_i$ 或 $V_i$，并且在岛屿 $U_i$ 和 $V_i$ 之间航行。具体来说，当独木舟停靠在岛屿 $U_i$ 时，可以用它从岛屿 $U_i$ 去往岛屿 $V_i$，此后该独木舟就变成停靠在岛屿 $V[i]$。类似地，当该独木舟停靠在岛屿 $V[i]$ 时，它可以从岛屿 $V_i$ 航向岛屿 $U_i$，此后该独木舟就变成停靠在岛屿 $U_i$。在初始时，该独木舟停靠在岛屿 $U_i$。可能有多艘独木舟能用于在同一对岛屿之间航行。也可能会有多艘独木舟停靠在同一个岛屿处。\n\n出于安全考虑，各艘独木舟在每次航行后必须进行维修，因此同一独木舟不允许紧接着完成两次航行。也就是说，在用完某艘独木舟 $i$ 后，必须先用过另外某艘独木舟，才能再启用独木舟 $i$。\n\nBu Dengklek 想策划一次在部分岛屿之间的旅行。她的旅程是**合理的**，当且仅当满足如下条件：\n\n- 她的旅程应从岛屿 $0$ 开始，并且在该岛屿结束。\n- 她应该游览岛屿 $0$ 之外的至少一个岛屿。\n- 在旅行结束后，每艘独木舟应停靠在旅行开始前它所在的岛屿。也就是说，对于满足 $0 \\le i \\le M - 1$ 的所有 $i$，独木舟必须停靠在岛屿 $U_i$。\n\n请你帮助 Bu Dengklek 找出包括至多航行 $2\\;000\\;000$ 次的合理旅行，或者告诉她不存在合理旅行。\n可以证明，在本题所给出的约束条件下（参见约束条件部分），如果存在合理旅行，则必然存在航行次数不超过 $2\\;000\\;000$ 次的合理旅行。", "inputFormat": "你要实现如下函数：\n\n```go\nunion(bool, int[]) find_journey(int N, int M, int[] U, int[] V)\n```\n\n- $N$：岛屿数量。\n- $M$：独木舟数量。\n- $U$, $V$：长度为 $M$ 的两个数组，给出独木舟航行的岛屿。\n- 该函数应当返回一个布尔类型或者整数数组。\n  - 如果不存在合理旅程，该函数应返回 `false`。\n  - 如果存在合理旅程，你有两个选择：\n  - 如果想得到全部的分数，该函数应返回一个至多包含 $2\\;000\\;000$ 个整数的数组，该数组用来刻画一个合理旅程。更确切地说，该数组中的元素应为旅程中所用独木舟的编号（按照独木舟的使用顺序）。\n  - 如果想得到部分分数，该函数应返回 `true`，或返回一个包含超过 $2\\;000\\;000$ 个整数的数组，或返回了一个未给出合理旅程的整数数组（更多细节参见“子任务”部分）。\n- 该函数将被调用恰好一次。", "outputFormat": "### 例子 1\n\n考虑如下调用：\n\n```go\nfind_journey(4, 5, [0, 1, 2, 0, 3], [1, 2, 3, 3, 1])\n```\n\n下图给出了岛屿和独木舟。\n\n![](https://arina.loli.net/2022/08/12/Aey1En5QvcFHrUZ.png)\n\n一个可行的合理旅行如下。Bu Dengklek 先依次使用独木舟 $0$，$1$，$2$ 和 $4$。结果是她将在岛屿 $1$ 上。其后，Bu Dengklek 可以再次使用独木舟 $0$，因为该独木舟正停靠在岛屿 $1$，而且她用的上一艘独木舟不是 $0$。再次使用独木舟 $0$ 后，现在 Bu Dengklek 在岛屿 $0$ 上。然而，独木舟 $1$，$2$ 和 $4$ 没有停靠在旅程开始前它们所在的岛屿。接下来 Bu Dengklek 继续她的旅程，使用独木舟 $3$，$2$，$1$，$4$ 和再一次使用 $3$。Bu Dengklek 回到了岛屿 $0$ 上，并且所有独木舟都停靠在旅行开始前它们所在的岛屿。\n\n因此，返回结果 $[0, 1, 2, 4, 0, 3, 2, 1, 4, 3]$ 刻画了一个合理旅程。\n\n### 例子 2\n\n考虑如下调用：\n\n```go\nfind_journey(2, 3, [0, 1, 1], [1, 0, 0])\n```\n\n下图给出了岛屿和独木舟。\n\n![](https://arina.loli.net/2022/08/12/nWJqhN7KXV3FPRl.png)\n\nBu Dengklek 仅能从使用独木舟 $0$ 开始，此后她可以使用独木舟 $1$ 或者 $2$。注意，她不能连续使用独木舟 $0$ 两次。在两种情况下，Bu Dengklek 都回到了岛屿 $0$ 上。然而，有独木舟没停靠在旅行开始前它们所在的岛屿，而 Bu Dengklek 此后却无法再使用任何独木舟，因为唯一停靠在岛屿 $0$ 的独木舟是她刚用过的那艘。由于不存在合理旅程，该函数应当返回 `false`。", "hint": "### 约束条件\n\n- $2 \\le N \\le 10^5$；\n- $1 \\le M \\le 2 \\times 10^5$；\n- $0 \\le U_i \\le N - 1$ 且 $0 \\le V_i \\le N - 1$（对于所有满足 $0 \\le i \\le M - 1$ 的 $i$）；\n- $U_i \\neq V_i$（对于所有满足 $0 \\le i \\le M - 1$ 的 $i$）。\n\n### 子任务\n\n1. （5 分）$N = 2$。\n1. （5 分） $N \\le 400$。\n   对于每一对不同的岛屿 $x$ 和 $y$（$0 \\le x \\lt y \\le N - 1$），恰好有两艘可在它们之间航行的独木舟。\n   其中一艘停靠在岛屿 $x$，而另一艘停靠在岛屿 $y$。\n1. （21 分） $N \\le 1000$，$M$ 是偶数，而且对于满足 $0 \\le i \\le M - 1$ 的所有**偶数** $i$，独木舟 $i$ 和 $i + 1$ 都可以用于在岛屿 $U_i$ 和 $V_i$ 之间航行。独木舟 $i$ 最初停靠在岛屿 $U_i$ 处，而独木舟 $i + 1$ 最初停靠在岛屿 $V_i$ 处。形式化地，$U_i = V_{i + 1}$ 且 $V_i = U_{i + 1}$。\n1. （24 分） $N \\le 1000$，$M$ 是偶数，而且对于满足 $0 \\le i \\le M - 1$ 的所有**偶数** $i$，独木舟 $i$ 和 $i + 1$ 都可以用于在岛屿 $U_i$ 和 $V_i$ 之间航行。两艘独木舟最初都停靠在岛屿 $U_i$ 处。\n   形式化地，$U_i = U_{i + 1}$ 且 $V_i = V_{i + 1}$。\n1. （45 分）没有额外的约束条件。\n\n对于每个存在合理旅程的测试用例，你的解答：\n\n- 如果返回一个合理旅程，将得到全部分数，\n- 如果返回 `true`，或返回一个超过 $2\\;000\\;000$ 个整数的数组，或返回一个未给出合理旅程的数组，将得到 $35\\%$ 的分数，\n- 在其他情况下得分为 $0$。\n\n对于每个不存在合理旅程的测试用例，你的解答：\n\n- 如果返回 `false`，将得到全部分数，\n- 在其他情况下得分为 $0$。\n\n注意，每个子任务上的最终得分，为该子任务中所有测试用例上的最低得分。\n\n### 评测程序示例\n\n评测程序示例读取如下格式的输入：\n\n- 第 $1$ 行：$N \\; M$；\n- 第 $2 + i$ 行（$0 \\le i \\le M - 1$）：$U_i \\; V_i$。\n\n测试程序示例将按照如下格式打印你的答案：\n\n- 如果 `find_journey` 返回一个 `bool`：\n  - 第 $1$ 行：$0$；\n  - 第 $2$ 行：如果 `find_journey` 返回 `false` 则为 $0$，否则为 $1$。\n- 如果 `find_journey` 返回一个 `int[]`，该数组中的元素记为 $c[0], c[1], \\ldots c[k-1]$。测试程序示例打印出：\n  - 第 $1$ 行：$1$；\n  - 第 $2$ 行：$k$；\n  - 第 $3$ 行：$c[0] \\; c[1] \\; \\ldots \\; c[k-1]$。\n\n### 约定\n\n题面在给出函数接口时，会使用一般性的类型名称 `void`、`bool`、`int`、`int[]`（数组）和 `union(bool, int[])`。\n\n在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：\n\n| `void ` | `bool` | `int` | `int[]`            |\n| ------- | ------ | ------| ------------------ |\n| `void ` | `bool` | `int` | `std::vector<int>` |\n\n| `union(bool, int[])`                   | 数组 `a` 的长度 |\n| -------------------------------------- | ------------------- |\n| `std::variant<bool, std::vector<int>>` | `a.size()`          |\n\nC++ 语言里，`std::variant` 定义在 `<variant>` 头文件中。\n一个返回类型为 `std::variant<bool, std::vector<int>>` 的函数可以返回一个 `bool` 或一个 `std::vector<int>`。\n以下示例代码给出了三个返回 `std::variant` 的函数，它们都能正常工作：\n\n```cpp\nstd::variant<bool, std::vector<int>> foo(int N) {\n    return N % 2 == 0;\n}\n\nstd::variant<bool, std::vector<int>> goo(int N) {\n    return std::vector<int>(N, 0);\n}\n\nstd::variant<bool, std::vector<int>> hoo(int N) {\n    if (N % 2 == 0) {\n        return false;\n    }\n\n    return std::vector<int>(N, 0);\n}\n```", "locale": "zh-CN"}}}
{"pid": "P8496", "type": "P", "difficulty": 6, "samples": [["2 8\n3 1 1 2\n3 3 3 3\n3 1 1\n3 1 2\n4 2 1 3\n3 1 3\n2 3\n3 1 3\n1 3 1\n3 1 3\n", "1\n3\n-1\n3\n-1\n"], ["4 9\n1 1\n1 2\n1 3\n1 4\n3 4 1 2 3 4\n1 1 2\n3 2 1 2\n2 3\n3 3 1 2 3\n1 4 4\n1 4 4\n1 4 4\n3 4 1 2 3 4\n", "-1\n2\n2\n4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "NOI", "O2优化"], "title": "[NOI2022] 众数", "background": null, "description": "**对于一个序列，定义其众数为序列中出现次数严格大于一半的数字。注意该定义与一般的定义有出入，在本题中请以题面中给出的定义为准。**\n\n一开始给定 $n$ 个长度不一的正整数序列，编号为 $1 \\sim n$，初始序列可以为空。这 $n$ 个序列被视为存在，其他编号对应的序列视为不存在。\n\n有 $q$ 次操作，操作有以下类型:\n\n- $1 \\ x \\ y$：在 $x$ 号序列末尾插入数字 $y$。保证 $x$ 号序列存在，且 $1 \\le x, y \\le n + q$。\n- $2 \\ x$：删除 $x$ 号序列末尾的数字，保证 $x$ 号序列存在、非空，且 $1 \\le x \\le n + q$。\n- $3 \\ m \\ x_1 \\ x_2 \\dots \\ x_m$：将 $x_1, x_2, \\ldots, x_m$ 号序列顺次拼接，得到一个新序列，并询问其众数。如果不存在满足上述条件的数，则返回 $-1$。数据保证对于任意 $1 \\le i \\le m$，$x_i$ 是一个仍然存在的序列，$1 \\le x_i \\le n + q$，且拼接得到的序列非空。**注意：不保证 $\\boldsymbol{x_1, \\ldots, x_m}$ 互不相同，询问中的合并操作不会对后续操作产生影响。**\n- $4 \\ x_1 \\ x_2 \\ x_3$：新建一个编号为 $x_3$ 的序列，其为 $x_1$ 号序列后顺次添加 $x_2$ 号序列中数字得到的结果，然后删除 $x_1, x_2$ 对应的序列。此时序列 $x_3$ 视为存在，而序列 $x_1, x_2$ 被视为不存在，在后续操作中也不会被再次使用。保证 $1 \\le x_1, x_2, x_3 \\le n + q$、$x_1 \\ne x_2$、序列 $x_1, x_2$ 在操作前存在、且在操作前没有序列使用过编号 $x_3$。", "inputFormat": "输入的第一行包含两个正整数 $n$ 和 $q$，分别表示数列的个数和操作的次数，保证 $n \\le 5 \\times {10}^5$、$q \\le 5 \\times {10}^5$。\n\n接下来 $n$ 行，第 $i$ 行表示编号为 $i$ 的数列。每一行的第一个非负整数 $l_i$ 表示初始第 $i$ 号序列的数字个数，接下来有 $l_i$ 个非负整数 $a_{i,j}$ 按顺序表示数列中的数字。假定 $C_l = \\sum l_i$ 代表输入序列长度之和，则保证 $C_l \\le 5 \\times {10}^5$、$a_{i,j} \\le n + q$。\n\n接下来 $q$ 行，每行若干个正整数，表示一个操作，并按照题面描述中的格式输入。\n\n假定 $C_m = \\sum m$ 代表所有操作 $3$ 需要拼接的序列个数之和，则保证 $C_m \\le 5 \\times {10}^5$。", "outputFormat": "对于每次询问，一行输出一个整数表示对应的答案。", "hint": "**【样例解释 \\#1】**\n\n第一次询问查询序列 $1$ 的众数。由于序列包含两个 $1$，超过序列长度的一半，因此众数为 $1$。\n\n第二次询问查询序列 $2$ 的众数。由于序列只包含 $3$，因此众数为 $3$。\n\n第三次询问询问序列 $3$ 的众数。此时序列 $3$ 为 $(3, 3, 3, 1, 1, 2)$，不存在出现次数大于 $3$ 次的数，因此输出为 $-1$。\n\n----\n\n**【样例解释 \\#2】**\n\n第一次询问查询序列 $1, 2, 3, 4$ 拼接后得到的序列的众数。拼接的结果为 $(1, 2, 3, 4)$，不存在出现次数大于两次的数，因此输出为 $-1$。\n\n第四次询问查询序列 $1, 2, 3, 4$ 拼接后得到的序列的众数。拼接的结果为 $(1, 2, 2, 4, 4, 4, 4)$，众数为 $4$。\n\n----\n\n**【样例 \\#3】**\n\n见附件中的 `major/major3.in` 与 `major/major3.ans`。\n\n该样例满足测试点 $1 \\sim 3$ 的限制。\n\n----\n\n**【样例 \\#4】**\n\n见附件中的 `major/major4.in` 与 `major/major4.ans`。\n\n该样例满足测试点 $11 \\sim 12$ 的限制。\n\n----\n\n**【数据范围】**\n\n对于所有测试数据，保证 $1 \\le n, q, C_m, C_l \\le 5 \\times {10}^5$。\n\n| $n, q$ | $C_m, C_l$ | 测试点编号 | 特殊性质 A | 特殊性质 B | 特殊性质 C |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| $\\le 300$ | $\\le 300$ | $1 \\sim 3$ | 否 | 否 | 是 |\n| $\\le 4000$ | $\\le 4000$ | $4 \\sim 7$ | 否 | 否 | 是 |\n| $\\le {10}^5$ | $\\le {10}^5$ | $8$ | 是 | 是 | 是 |\n| $\\le {10}^5$ | $\\le {10}^5$ | $9$ | 是 | 否 | 否 |\n| $\\le {10}^5$ | $\\le {10}^5$ | $10$ | 否 | 是 | 否 |\n| $\\le {10}^5$ | $\\le {10}^5$ | $11 \\sim 12$ | 否 | 否 | 是 |\n| $\\le {10}^5$ | $\\le {10}^5$ | $13$ | 否 | 否 | 否 |\n| $\\le 5 \\times {10}^5$ | $\\le 5 \\times {10}^5$ | $14$ | 是 | 是 | 是 |\n| $\\le 5 \\times {10}^5$ | $\\le 5 \\times {10}^5$ | $15$ | 是 | 否 | 否 |\n| $\\le 5 \\times {10}^5$ | $\\le 5 \\times {10}^5$ | $16$ | 否 | 是 | 否 |\n| $\\le 5 \\times {10}^5$ | $\\le 5 \\times {10}^5$ | $17 \\sim 18$ | 否 | 否 | 是 |\n| $\\le 5 \\times {10}^5$ | $\\le 5 \\times {10}^5$ | $19 \\sim 20$ | 否 | 否 | 否 |\n\n特殊性质 A：保证 $n = 1$ 且没有操作 $4$。  \n特殊性质 B：保证任意时刻任何序列中只有数字 $1$ 和 $2$。  \n特殊性质 C：保证没有操作 $2$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOI2022] 众数", "background": null, "description": "**对于一个序列，定义其众数为序列中出现次数严格大于一半的数字。注意该定义与一般的定义有出入，在本题中请以题面中给出的定义为准。**\n\n一开始给定 $n$ 个长度不一的正整数序列，编号为 $1 \\sim n$，初始序列可以为空。这 $n$ 个序列被视为存在，其他编号对应的序列视为不存在。\n\n有 $q$ 次操作，操作有以下类型:\n\n- $1 \\ x \\ y$：在 $x$ 号序列末尾插入数字 $y$。保证 $x$ 号序列存在，且 $1 \\le x, y \\le n + q$。\n- $2 \\ x$：删除 $x$ 号序列末尾的数字，保证 $x$ 号序列存在、非空，且 $1 \\le x \\le n + q$。\n- $3 \\ m \\ x_1 \\ x_2 \\dots \\ x_m$：将 $x_1, x_2, \\ldots, x_m$ 号序列顺次拼接，得到一个新序列，并询问其众数。如果不存在满足上述条件的数，则返回 $-1$。数据保证对于任意 $1 \\le i \\le m$，$x_i$ 是一个仍然存在的序列，$1 \\le x_i \\le n + q$，且拼接得到的序列非空。**注意：不保证 $\\boldsymbol{x_1, \\ldots, x_m}$ 互不相同，询问中的合并操作不会对后续操作产生影响。**\n- $4 \\ x_1 \\ x_2 \\ x_3$：新建一个编号为 $x_3$ 的序列，其为 $x_1$ 号序列后顺次添加 $x_2$ 号序列中数字得到的结果，然后删除 $x_1, x_2$ 对应的序列。此时序列 $x_3$ 视为存在，而序列 $x_1, x_2$ 被视为不存在，在后续操作中也不会被再次使用。保证 $1 \\le x_1, x_2, x_3 \\le n + q$、$x_1 \\ne x_2$、序列 $x_1, x_2$ 在操作前存在、且在操作前没有序列使用过编号 $x_3$。", "inputFormat": "输入的第一行包含两个正整数 $n$ 和 $q$，分别表示数列的个数和操作的次数，保证 $n \\le 5 \\times {10}^5$、$q \\le 5 \\times {10}^5$。\n\n接下来 $n$ 行，第 $i$ 行表示编号为 $i$ 的数列。每一行的第一个非负整数 $l_i$ 表示初始第 $i$ 号序列的数字个数，接下来有 $l_i$ 个非负整数 $a_{i,j}$ 按顺序表示数列中的数字。假定 $C_l = \\sum l_i$ 代表输入序列长度之和，则保证 $C_l \\le 5 \\times {10}^5$、$a_{i,j} \\le n + q$。\n\n接下来 $q$ 行，每行若干个正整数，表示一个操作，并按照题面描述中的格式输入。\n\n假定 $C_m = \\sum m$ 代表所有操作 $3$ 需要拼接的序列个数之和，则保证 $C_m \\le 5 \\times {10}^5$。", "outputFormat": "对于每次询问，一行输出一个整数表示对应的答案。", "hint": "**【样例解释 \\#1】**\n\n第一次询问查询序列 $1$ 的众数。由于序列包含两个 $1$，超过序列长度的一半，因此众数为 $1$。\n\n第二次询问查询序列 $2$ 的众数。由于序列只包含 $3$，因此众数为 $3$。\n\n第三次询问询问序列 $3$ 的众数。此时序列 $3$ 为 $(3, 3, 3, 1, 1, 2)$，不存在出现次数大于 $3$ 次的数，因此输出为 $-1$。\n\n----\n\n**【样例解释 \\#2】**\n\n第一次询问查询序列 $1, 2, 3, 4$ 拼接后得到的序列的众数。拼接的结果为 $(1, 2, 3, 4)$，不存在出现次数大于两次的数，因此输出为 $-1$。\n\n第四次询问查询序列 $1, 2, 3, 4$ 拼接后得到的序列的众数。拼接的结果为 $(1, 2, 2, 4, 4, 4, 4)$，众数为 $4$。\n\n----\n\n**【样例 \\#3】**\n\n见附件中的 `major/major3.in` 与 `major/major3.ans`。\n\n该样例满足测试点 $1 \\sim 3$ 的限制。\n\n----\n\n**【样例 \\#4】**\n\n见附件中的 `major/major4.in` 与 `major/major4.ans`。\n\n该样例满足测试点 $11 \\sim 12$ 的限制。\n\n----\n\n**【数据范围】**\n\n对于所有测试数据，保证 $1 \\le n, q, C_m, C_l \\le 5 \\times {10}^5$。\n\n| $n, q$ | $C_m, C_l$ | 测试点编号 | 特殊性质 A | 特殊性质 B | 特殊性质 C |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| $\\le 300$ | $\\le 300$ | $1 \\sim 3$ | 否 | 否 | 是 |\n| $\\le 4000$ | $\\le 4000$ | $4 \\sim 7$ | 否 | 否 | 是 |\n| $\\le {10}^5$ | $\\le {10}^5$ | $8$ | 是 | 是 | 是 |\n| $\\le {10}^5$ | $\\le {10}^5$ | $9$ | 是 | 否 | 否 |\n| $\\le {10}^5$ | $\\le {10}^5$ | $10$ | 否 | 是 | 否 |\n| $\\le {10}^5$ | $\\le {10}^5$ | $11 \\sim 12$ | 否 | 否 | 是 |\n| $\\le {10}^5$ | $\\le {10}^5$ | $13$ | 否 | 否 | 否 |\n| $\\le 5 \\times {10}^5$ | $\\le 5 \\times {10}^5$ | $14$ | 是 | 是 | 是 |\n| $\\le 5 \\times {10}^5$ | $\\le 5 \\times {10}^5$ | $15$ | 是 | 否 | 否 |\n| $\\le 5 \\times {10}^5$ | $\\le 5 \\times {10}^5$ | $16$ | 否 | 是 | 否 |\n| $\\le 5 \\times {10}^5$ | $\\le 5 \\times {10}^5$ | $17 \\sim 18$ | 否 | 否 | 是 |\n| $\\le 5 \\times {10}^5$ | $\\le 5 \\times {10}^5$ | $19 \\sim 20$ | 否 | 否 | 否 |\n\n特殊性质 A：保证 $n = 1$ 且没有操作 $4$。  \n特殊性质 B：保证任意时刻任何序列中只有数字 $1$ 和 $2$。  \n特殊性质 C：保证没有操作 $2$。", "locale": "zh-CN"}}}
{"pid": "P8497", "type": "P", "difficulty": 7, "samples": [["1\n4 1\n0 1\n0 1\n0 1\n0 1\n", "14\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "NOI", "O2优化", "DP 套 DP"], "title": "[NOI2022] 移除石子", "background": "", "description": "你正在玩一个名为“移除石子”的小游戏。\n\n有 $n$ 堆石子排成一行，第 $i$ 堆有 $a_i$ 枚，你的任务是通过如下的操作将所有石子移除：\n\n- 操作一：选择一堆石子，将其中的至少 $2$ 枚石子移除；\n- 操作二：选择一个连续的编号区间 $[l, r]$（$1 \\le l \\le r \\le n$）并满足 $r - l \\ge 2$，将其中的每一堆石子都恰好移除 $1$ 枚。\n\n你可以采用任意顺序执行任意多次上述两种操作，直到无法再执行操作为止。若最后你能将所有石子全部移除则胜利。\n\n你或许已经开始计算起了诸如“有多少种本质不同的操作方式”的问题，但实际玩起来你却发现自己总是在输。因此，你打算玩个小花招：在游戏开始时，你在手里偷偷藏有 $k$ 枚石子，在执行所有操作之前你**可以且必须**将这些石子放入某一堆或某几堆石子中。你期望这会提高自己的胜率，但也清楚这可能会使自己输掉原本可能胜利的游戏。\n\n现在，你可以自由选择一个初始局面进行游戏，具体而言，每个 $a_i$ 可以选择 $[l_i, r_i]$ 范围内的任意整数。你希望计算出，在多少种初始局面下，自己存在至少一种获胜的方案。由于答案很大，你只需要输出其对 $({10}^9 + 7)$ 取模的结果。**两个初始局面不同，当且仅当存在至少一个 $\\boldsymbol{1 \\le i \\le n}$ 使得两者的 $\\boldsymbol{a_i}$ 不相等，注意这里的“初始局面”指的是你放入 $\\boldsymbol{k}$ 枚石子之前的局面。**", "inputFormat": "**本题有多组测试数据。** 第一行一个正整数 $T$ 表示测试数据组数，接下来依次给出每组测试数据。\n\n对于每组测试数据，第一行两个整数 $n, k$，分别表示石子堆数和加入的石子个数，接下来 $n$ 行，每行两个非负整数 $l_i, r_i$ 表示每堆石子初始石子数的范围。", "outputFormat": "对于每组数据输出一行一个整数，表示可能获胜的局面数对$({10}^9 + 7)$ 取模的结果。", "hint": "**【样例解释 \\#1】**\n\n共有 $2^4 = 16$ 种可能的初始局面，可以证明除了 $(0 \\ 0 \\ 0 \\ 0)$ 和 $(1 \\ 0 \\ 0 \\ 1)$ 这两种初始局面无法获胜以外，其余初始局面均存在获胜方案。例如，初始局面为 $(1 \\ 0 \\ 1 \\ 0)$ 时，你可以将手中的 $1$ 枚石子放入第 $2$ 堆石子，使局面变为 $(1 \\ 1 \\ 1 \\ 0)$，再对区间 $[1, 3]$ 使用一次操作二即可。\n\n----\n\n**【样例 \\#2】**\n\n见附件中的 `stone/stone2.in` 与 `stone/stone2.ans`。\n\n----\n\n**【样例 \\#3】**\n\n见附件中的 `stone/stone3.in` 与 `stone/stone3.ans`。\n\n----\n\n**【样例 \\#4】**\n\n见附件中的 `stone/stone4.in` 与 `stone/stone4.ans`。\n\n----\n\n**【数据范围】**\n\n对于 $100 \\%$ 的数据，保证 $T \\le 10$，$3 \\le n \\le 1000$，$0 \\le l_i \\le r_i \\le {10}^9$，$0 \\le k \\le 100$。\n\n| 测试点编号 | $n \\le$ | $k \\le$ | 特殊条件 |\n|:-:|:-:|:-:|:-:|\n| $1 \\sim 3$ | $5$ | $2$ | $r_i \\le 5$ |\n| $4 \\sim 5$ | $1000$ | $0$ | $l_i = r_i$ |\n| $6 \\sim 8$ | $1000$ | $100$ | $l_i = r_i$ |\n| $9 \\sim 11$ | $1000$ | $0$ | 无 |\n| $12 \\sim 13$ | $1000$ | $2$ | 无 |\n| $14 \\sim 15$ | $1000$ | $100$ | $r_i \\le 10$ |\n| $16 \\sim 20$ | $1000$ | $100$ | 无 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOI2022] 移除石子", "background": "", "description": "你正在玩一个名为“移除石子”的小游戏。\n\n有 $n$ 堆石子排成一行，第 $i$ 堆有 $a_i$ 枚，你的任务是通过如下的操作将所有石子移除：\n\n- 操作一：选择一堆石子，将其中的至少 $2$ 枚石子移除；\n- 操作二：选择一个连续的编号区间 $[l, r]$（$1 \\le l \\le r \\le n$）并满足 $r - l \\ge 2$，将其中的每一堆石子都恰好移除 $1$ 枚。\n\n你可以采用任意顺序执行任意多次上述两种操作，直到无法再执行操作为止。若最后你能将所有石子全部移除则胜利。\n\n你或许已经开始计算起了诸如“有多少种本质不同的操作方式”的问题，但实际玩起来你却发现自己总是在输。因此，你打算玩个小花招：在游戏开始时，你在手里偷偷藏有 $k$ 枚石子，在执行所有操作之前你**可以且必须**将这些石子放入某一堆或某几堆石子中。你期望这会提高自己的胜率，但也清楚这可能会使自己输掉原本可能胜利的游戏。\n\n现在，你可以自由选择一个初始局面进行游戏，具体而言，每个 $a_i$ 可以选择 $[l_i, r_i]$ 范围内的任意整数。你希望计算出，在多少种初始局面下，自己存在至少一种获胜的方案。由于答案很大，你只需要输出其对 $({10}^9 + 7)$ 取模的结果。**两个初始局面不同，当且仅当存在至少一个 $\\boldsymbol{1 \\le i \\le n}$ 使得两者的 $\\boldsymbol{a_i}$ 不相等，注意这里的“初始局面”指的是你放入 $\\boldsymbol{k}$ 枚石子之前的局面。**", "inputFormat": "**本题有多组测试数据。** 第一行一个正整数 $T$ 表示测试数据组数，接下来依次给出每组测试数据。\n\n对于每组测试数据，第一行两个整数 $n, k$，分别表示石子堆数和加入的石子个数，接下来 $n$ 行，每行两个非负整数 $l_i, r_i$ 表示每堆石子初始石子数的范围。", "outputFormat": "对于每组数据输出一行一个整数，表示可能获胜的局面数对$({10}^9 + 7)$ 取模的结果。", "hint": "**【样例解释 \\#1】**\n\n共有 $2^4 = 16$ 种可能的初始局面，可以证明除了 $(0 \\ 0 \\ 0 \\ 0)$ 和 $(1 \\ 0 \\ 0 \\ 1)$ 这两种初始局面无法获胜以外，其余初始局面均存在获胜方案。例如，初始局面为 $(1 \\ 0 \\ 1 \\ 0)$ 时，你可以将手中的 $1$ 枚石子放入第 $2$ 堆石子，使局面变为 $(1 \\ 1 \\ 1 \\ 0)$，再对区间 $[1, 3]$ 使用一次操作二即可。\n\n----\n\n**【样例 \\#2】**\n\n见附件中的 `stone/stone2.in` 与 `stone/stone2.ans`。\n\n----\n\n**【样例 \\#3】**\n\n见附件中的 `stone/stone3.in` 与 `stone/stone3.ans`。\n\n----\n\n**【样例 \\#4】**\n\n见附件中的 `stone/stone4.in` 与 `stone/stone4.ans`。\n\n----\n\n**【数据范围】**\n\n对于 $100 \\%$ 的数据，保证 $T \\le 10$，$3 \\le n \\le 1000$，$0 \\le l_i \\le r_i \\le {10}^9$，$0 \\le k \\le 100$。\n\n| 测试点编号 | $n \\le$ | $k \\le$ | 特殊条件 |\n|:-:|:-:|:-:|:-:|\n| $1 \\sim 3$ | $5$ | $2$ | $r_i \\le 5$ |\n| $4 \\sim 5$ | $1000$ | $0$ | $l_i = r_i$ |\n| $6 \\sim 8$ | $1000$ | $100$ | $l_i = r_i$ |\n| $9 \\sim 11$ | $1000$ | $0$ | 无 |\n| $12 \\sim 13$ | $1000$ | $2$ | 无 |\n| $14 \\sim 15$ | $1000$ | $100$ | $r_i \\le 10$ |\n| $16 \\sim 20$ | $1000$ | $100$ | 无 |", "locale": "zh-CN"}}}
{"pid": "P8498", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2022", "NOI", "交互题", "Special Judge", "O2优化"], "title": "[NOI2022] 树上邻域数点", "background": "**这是一道交互题。**\n\n**在提交本题前请务必仔细阅读以下内容。**\n\n本题只支持 C++ 语言提交（建议使用 C++14，请不要使用 C++14 (GCC9)）。\n\n由于洛谷特殊的交互机制，在提交本题时，请去掉代码中的 ```#include \"count.h\"``` 语句，并将下发文件 **`count_.h`** （注意并不是 `count.zip` 里的 `count.h`）中的内容粘贴到代码最开头，然后提交。\n\n如果您无法打开 `count_.h`，那么可以复制下面的内容。\n\n```cpp\n#ifndef CIRCLE_H\n#define CIRCLE_H\n#include<vector>\nstruct info{\n  unsigned val;\n  unsigned poi[2];\n};\nconst info emptyinfo=info{0,(unsigned)-1,(unsigned)-1};\ninfo MR(info a,info b);\ninfo MC(info a,info b);\nvoid init(int T,int n,int q,std::vector<int>dad,std::vector<info>ve,int M);\nbool isempty(info a);\ninfo ask(int x,int d);\n\n#endif\n```\n\n如果您在提交本题时出现了任何意外的情况，请咨询管理员。", "description": "给出五元组 $(T, I, S_V, S_E, \\iota)$，其中：\n\n- $T$ 是一棵 $n$ 个点的有根树 $T = (V, E)$，其中 $V$ 为 $T$ 的点集，$E$ 为 $T$ 的边集。树的节点被编号为 $1, 2, \\ldots, n$，其中根节点编号为 $1$。\n- $I$ 是一个集合，集合中的元素称作**信息**。其中有两个不同的特殊元素：单位元 $\\epsilon$ 和不合法信息 $\\bot$。\n\n对于一般的信息，其都具有**点集合**和**边集合**两个属性。特别的，对于单位元，其只有边集合的属性，而对于不合法信息，其没有以上两种属性。\n\n- 对于信息 $o \\in I \\setminus \\{ \\epsilon, \\bot \\}$，$o$ 的**点集合**是 $V$ 的一个二元子集，记作 $S_V(o)$，满足 $S_V(o) \\subseteq V$ 且 $\\lvert S_V(o) \\rvert = 2$。其中，两个集合 $A, B$ 的差 $A \\setminus B$ 被定义为 $A \\setminus B = \\{ x \\in A \\hspace{3mu}\\vert\\hspace{3mu} x \\notin B \\}$。\n- 对于信息 $o \\in I \\setminus \\{ \\bot \\}$，$o$ 的**边集合**是 $E$ 的一个子集，记作 $S_E(o)$，满足 $S_E(o) \\subseteq E$。规定单位元的边集合为空，也即 $S_E(\\epsilon) = \\varnothing$。\n- 对于树上的任何一条边 $e \\in E$，记 $e = (u, v)$，存在一个关于 $e$ 的信息 $\\iota(e) \\in I$，它以其端点为点集合、自身为边集合，即 $S_V(\\iota(e)) = \\{ u, v \\}$、$S_E(\\iota(e)) = \\{ e \\}$。\n\n信息有两种合并的方式，分别记作 $R$ 和 $C$。对于 $\\forall a, b \\in I$，记 $r = R(a, b), c = C(a, b)$，满足 $r, c \\in I$，则：\n\n- 单位元和任何信息合并都得到对方。也即，如果 $a = \\epsilon$，那么 $r = c = b$；如果 $b = \\epsilon$，那么 $r = c = a$。\n- 不合法信息和任何信息合并都得到不合法信息。也即，如果 $a = \\bot$ 或者 $b = \\bot$，那么 $r = c = \\bot$。\n- 对于剩下的情况，如果两个信息的**边集合**的交集非空，或者**点集合**的交集的大小不为 $1$，则合并得到不合法信息。也即，如果 $S_E(a) \\cap S_E(b) \\ne \\varnothing$ 或 $\\lvert S_V(a) \\cap S_V(b) \\rvert \\ne 1$，则 $r = c = \\bot$。\n- 否则，有\n  $$ S_E(r) = S_E(c) = S_E(a) \\cup S_E(b) \\text{,} $$\n  $$ S_V(r) = S_V(a) \\text{,} $$\n  $$ S_V(c) = S_V(a) \\oplus S_V(b) \\text{,} $$\n  其中 $\\oplus$ 表示集合的对称差运算，也即 $A \\oplus B = (A \\cup B) \\setminus (A \\cap B)$。\n\n定义 $T$ 中两个点的树上距离为树上以两个点为端点的唯一简单路径经过的边数。\n\n给出评分参数 $M$ 和 $q$ 次询问，每次询问给出树上的一个点 $u$ 和一个非负整数 $d$。记点集 $X$ 为 $T$ 中所有与 $u$ 的树上距离不超过 $d$ 的点构成的集合，又记边集 $Y = \\{ (a, b) \\in E \\hspace{3mu}\\vert\\hspace{3mu} a, b \\in X \\}$ 为 $X$ 内部的边集。可以证明，从 $\\epsilon$ 和所有 $\\iota(e)$（$e \\in E$）出发，总是能通过有限次 $R, C$ 的调用得到信息 $o \\ne \\bot$ 满足 $S_E(o) = Y$。\n\n每组询问中，你需要在 $R$ 和 $C$ 的调用次数总和不超过 $M$ 的限制下构造出一个满足这样的要求的信息 $o$。特别地，如果 $d = 0$，则直接返回单位元 $\\epsilon$ 即可。\n\n----\n\n**【实现细节】**\n\n请确保你的程序开头有 `#include \"count.h\"`。\n\n头文件 `count.h` 中实现了如下内容：\n\n1. 定义了信息对应的数据类型 `info`；\n2. 定义了 $\\epsilon$ 所对应的 `info` 类型常量 `emptyinfo`，你可以在程序中直接使用。\n3. 定义并实现了以下两个信息合并函数，你可以在程序中直接调用：\n   \n   ```cpp\n   info MR(info a,info b);\n   info MC(info a,info b);\n   ```\n   \n   - 两个函数分别返回 $R(a, b)$ 与 $C(a, b)$ 对应的信息。\n   \n   **你需要保证调用 $\\boldsymbol{R(a, b)}$ 与 $\\boldsymbol{C(a, b)}$ 时结果不为 $\\boldsymbol{\\bot}$，否则程序可能会出现异常行为。**\n4. 定义并实现了判定一个信息是否为单位元的函数，你可以在程序中直接调用：\n   ```cpp\n   bool isempty(info a);\n   ```\n   - 这个函数返回真当且仅当 $a$ 为单位元。\n\n可以查看参考交互库了解更多实现细节。\n\n**你不需要，也不应该实现主函数。** 你需要实现如下几个函数：\n\n```cpp\nvoid init(int T, int n, int q, vector<int> fa, vector<info> e, int M);\n```\n\n- `T` 表示测试点编号，`n` 表示树的点数，`q` 表示询问数，`M` 表示该测试点的评分参数。\n- `fa` 和 `e` 的长度均为 $n - 1$。对于 $0 \\le i < n - 1$，$fa[i]$ 和 $i + 2$ 为第 $i$ 条边 $e_i$ 的两个端点，$e[i]$ 为题目描述中提到的 $\\iota(e_i)$ 所对应的 `info` 类型元素。数据保证 $fa[i]$ 小于 $i + 2$。\n\n```cpp\ninfo ask(int u, int d);\n```\n\n给出一个询问，参数的意义见题目描述。你需要在函数结束时返回一个满足题设条件的信息。\n\n最终测试时，在每个测试点，交互库会**恰好**调用一次 `init` 函数，随后调用 $q$ 次 `ask`函数。交互库会使用特殊的实现方式，单个 `info` 类型的变量会恒定消耗 $12$ 字节内存，**这与下发的参考交互库不同**。为保证程序运行时内存使用在题目限制内，你需要保证运行过程中没有过多的 `info` 类型变量同时存在。\n\n保证在满足调用次数限制且不进行 `isempty` 函数调用的情况下，最终测试的交互库运行所需的时间不超过 0.6 秒，交互库本身所消耗的内存不超过 16 MiB。保证在只执行 ${10}^8$ 次 `isempty` 函数调用的情况下，最终测试的交互库运行的时间不超过 0.25 秒。\n\n在下发文件中包含一个名为 `count.cpp` 的文件，作为示例程序，选手可以在此基础上继续实现本题。在下发文件中还额外包含一个名为 `count_backup.h` 的备份文件，我们保证其与 `count.h` 文件完全相同。\n\n----\n\n**【测试程序方式】**\n\n本题目录下提供了两个交互库的参考实现 `grader.o`、`checker.o`，其为两个不同的交互库编译产生的可链接文件。最终测试时所用的交互库实现与该实现有不同，因此选手的解法**不应依赖交互库的具体实现**，同时也不应该依赖 `count.h` 中 `info` 类型的具体实现。\n\n你需要修改下发的 `count.h` 来帮助进行链接。具体的，在将源代码 `count.cpp` 和程序 `grader.o` 进行链接的时候，你需要注释掉 `count.h` 代码的第 5 行，并保留第 4 行的代码。链接 `checker.o` 方法类似，需要注释掉 `count.h` 代码的第 4 行，并保留第 5 行的代码。选手可以对 `count.h` 的实现自行修改来实现不同程序的编译。\n\n修改后，选手可以在本题目录下使用如下命令编译得到可执行程序：\n\n```bash\ng++ count.cpp -c -O2 -std=c++14 -lm && g++ count.o grader.o -o count\ng++ count.cpp -c -O2 -std=c++14 -lm && g++ count.o checker.o -o count\n```\n\n其中第一行命令会编译当前 `count.cpp` 后与 `grader.o` 链接起来，生成可执行文件 `count`，第二行命令则会编译当前 `count.cpp` 后与 `checker.o` 链接起来，生成可执行文件 `count`。\n\n按上述方法编译得到的可执行文件 `count`，其运行方式如下：\n\n- 可执行文件将从标准输入读入以下格式的数据：\n  - 第一行四个整数 $id, n, q, M$，分别表示测试点编号、树的点数、询问数和评分参数；\n  - 第二行 $n - 1$ 个整数 $p_2, p_3, \\ldots, p_n$，分别表示 $2$ 至 $n$ 的父亲节点编号，在本地调试时你需要保证 $\\forall i \\in [2, n]$，$p_i < i$；\n  - 接下来 $q$ 行每行两个整数 $u, d$，描述一次询问。\n- 读入之后，交互库会进行测试。如果你的程序不满足交互库限制，其会在输出中返回对应的错误信息。否则，对于链接的可执行文件，其输出如下：\n  - 总共一行三个整数 $C_1, C_2, C_3$，其中：\n    - $C_1$ 表示程序在 `init` 函数中调用交互库函数的总次数；\n    - $C_2$ 表示程序在运行过程中调用交互库函数的总次数；\n    - $C_3$ 表示程序在 $q$ 次 `ask` 函数中调用交互库函数的次数的最大值。\n    - 对于上述三个统计量，我们只会计入 `MR`、`MC` 函数的调用次数，而不会计入 `isempty` 函数的调用次数。\n- 在链接不同文件的时候，其能够进行的检查也不同，具体地：\n  - `grader.o`：其在运行时不会检查 `ask` 函数返回的信息是否正确，但可以帮助选手判断交互操作是否符合要求。这份程序运行时间最接近评测时的交互库，因此选手可以利用该程序测试运行速度，但不保证程序正确性。\n  - `checker.o`：其在运行时会检查 `ask` 函数返回的信息是否正确，也可以帮助选手判断交互操作是否符合要求。同时其会检查 `ask` 函数返回的信息是否正确。这份程序可以进行答案正确性的检查。\n\n选手在调试时需要保证输入可执行文件 `count` 的数据满足上述输入格式，否则不保证输出结果正确。\n", "inputFormat": "见【测试程序方式】。", "outputFormat": "见【测试程序方式】。", "hint": "**【评分方式】**\n\n最终评测**只会**收取 `count.cpp`，修改选手目录下其他文件不会对评测结果产生影响。**注意：**\n\n- **未初始化的 `info` 类型的变量不保证是 `emptyinfo`。**\n- **请不要尝试访问或修改 `info` 类型的成员变量，否则将被视为攻击交互库。**\n- **请不要在 `init` 函数调用之前调用 `MR` 和 `MC` 函数，否则可能会发生未定义行为。**\n- **你只能访问自己定义的变量和交互库返回的 `info` 类型变量，尝试访问其他空间将可能导致编译错误或运行时错误。**\n\n**本题首先会受到和传统题相同的限制**，例如编译错误会导致整道题目得 0 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 0 分等。\n\n在上述条件以外，在一个测试点中，若程序执行了非法的函数调用或询问操作中给出了错误回答，该测试点将会获得 0 分。否则，记 $C_1, C_3$ 分别表示你的程序在 `init` 函数中调用交互库函数的次数，和你的程序在所有 $q$ 次 `ask` 函数中调用交互库函数的次数的最大值。如果 $C_1 \\le 3 \\cdot {10}^7$ 且 $C_3$ 不超过该测试点的评分参数 $M$，你将获得该测试点的分数，否则你无法获得该测试点的分数。注意：计算 $C_1, C_3$ 时只会计入 `MR`、`MC` 函数的调用次数，而不会计入 `isempty` 函数的调用次数。\n\n----\n\n**【样例 \\#1】**\n\n见附件中的 `count/count1.in` 与 `count/count1.ans`。\n\n----\n\n**【样例 \\#2】**\n\n见附件中的 `count/count2.in` 与 `count/count2.ans`。\n\n该组样例满足数据范围中的特殊性质 A。\n\n----\n\n**【样例 \\#3】**\n\n见附件中的 `count/count3.in` 与 `count/count3.ans`。\n\n该组样例满足数据范围中的特殊性质 B。\n\n----\n\n**【样例 \\#4】**\n\n见附件中的 `count/count4.in` 与 `count/count4.ans`。\n\n----\n\n**【数据范围】**\n\n对于所有测试点，$1 \\le n \\le 2 \\times {10}^5$，$1 \\le q \\le {10}^6$；每组询问中，有 $1 \\le u \\le n$，$1 \\le d \\le n - 1$。\n\n| 测试点   | $n=$              | $q=$            | 特殊性质 | $M=$  |\n|:-----:|:-----------------:|:---------------:|:----:|:-----:|\n| $1$   | $1000$            | $10^4$          |      | $500$ |\n| $2$   | $2000$            | $10^4$          |      | $500$ |\n| $3,4$ | $10^5$            | $10^6$          | A    | $5$   |\n| $5,6$ | $6 \\times 10^4$   | $6\\times 10^4$  | B    | $50$  |\n| $7$   | $6 \\times 10^4$   | $6 \\times 10^4$ | B    | $5$   |\n| $8$   | $10^5$            | $10^5$          | B    | $5$   |\n| $9$   | $7500$            | $5 \\times 10^4$ | C    | $500$ |\n| $10$  | $10^4$            | $5 \\times 10^4$ |      | $500$ |\n| $11$  | $1.5 \\times 10^4$ | $5 \\times 10^4$ |      | $500$ |\n| $12$  | $2 \\times 10^4$   | $5 \\times 10^4$ |      | $50$  |\n| $13$  | $2.5 \\times 10^4$ | $5 \\times 10^4$ |      | $5$   |\n| $14$  | $3 \\times 10^4$   | $10^5$          |      | $5$   |\n| $15$  | $6 \\times 10^4$   | $10^6$          | D    | $5$   |\n| $16$  | $6 \\times 10^4$   | $10^6$          |      | $5$   |\n| $17$  | $8 \\times 10^4$   | $10^6$          |      | $5$   |\n| $18$  | $10^5$            | $10^6$          |      | $5$   |\n| $19$  | $1.5 \\times 10^5$ | $10^6$          |      | $5$   |\n| $20$  | $2 \\times 10^5$   | $10^6$          |      | $1$   |\n\n\n特殊性质 A：保证 $\\forall i \\in [1, n - 1]$，编号为 $i + 1$ 的点的父节点为 $i$。  \n特殊性质 B：保证所有询问均满足 $u = 1$。  \n特殊性质 C：保证所有询问均满足 $d \\le 100$。  \n特殊性质 D：保证所有询问均满足 $d \\ge 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOI2022] 树上邻域数点", "background": "**这是一道交互题。**\n\n**在提交本题前请务必仔细阅读以下内容。**\n\n本题只支持 C++ 语言提交（建议使用 C++14，请不要使用 C++14 (GCC9)）。\n\n由于洛谷特殊的交互机制，在提交本题时，请去掉代码中的 ```#include \"count.h\"``` 语句，并将下发文件 **`count_.h`** （注意并不是 `count.zip` 里的 `count.h`）中的内容粘贴到代码最开头，然后提交。\n\n如果您无法打开 `count_.h`，那么可以复制下面的内容。\n\n```cpp\n#ifndef CIRCLE_H\n#define CIRCLE_H\n#include<vector>\nstruct info{\n  unsigned val;\n  unsigned poi[2];\n};\nconst info emptyinfo=info{0,(unsigned)-1,(unsigned)-1};\ninfo MR(info a,info b);\ninfo MC(info a,info b);\nvoid init(int T,int n,int q,std::vector<int>dad,std::vector<info>ve,int M);\nbool isempty(info a);\ninfo ask(int x,int d);\n\n#endif\n```\n\n如果您在提交本题时出现了任何意外的情况，请咨询管理员。", "description": "给出五元组 $(T, I, S_V, S_E, \\iota)$，其中：\n\n- $T$ 是一棵 $n$ 个点的有根树 $T = (V, E)$，其中 $V$ 为 $T$ 的点集，$E$ 为 $T$ 的边集。树的节点被编号为 $1, 2, \\ldots, n$，其中根节点编号为 $1$。\n- $I$ 是一个集合，集合中的元素称作**信息**。其中有两个不同的特殊元素：单位元 $\\epsilon$ 和不合法信息 $\\bot$。\n\n对于一般的信息，其都具有**点集合**和**边集合**两个属性。特别的，对于单位元，其只有边集合的属性，而对于不合法信息，其没有以上两种属性。\n\n- 对于信息 $o \\in I \\setminus \\{ \\epsilon, \\bot \\}$，$o$ 的**点集合**是 $V$ 的一个二元子集，记作 $S_V(o)$，满足 $S_V(o) \\subseteq V$ 且 $\\lvert S_V(o) \\rvert = 2$。其中，两个集合 $A, B$ 的差 $A \\setminus B$ 被定义为 $A \\setminus B = \\{ x \\in A \\hspace{3mu}\\vert\\hspace{3mu} x \\notin B \\}$。\n- 对于信息 $o \\in I \\setminus \\{ \\bot \\}$，$o$ 的**边集合**是 $E$ 的一个子集，记作 $S_E(o)$，满足 $S_E(o) \\subseteq E$。规定单位元的边集合为空，也即 $S_E(\\epsilon) = \\varnothing$。\n- 对于树上的任何一条边 $e \\in E$，记 $e = (u, v)$，存在一个关于 $e$ 的信息 $\\iota(e) \\in I$，它以其端点为点集合、自身为边集合，即 $S_V(\\iota(e)) = \\{ u, v \\}$、$S_E(\\iota(e)) = \\{ e \\}$。\n\n信息有两种合并的方式，分别记作 $R$ 和 $C$。对于 $\\forall a, b \\in I$，记 $r = R(a, b), c = C(a, b)$，满足 $r, c \\in I$，则：\n\n- 单位元和任何信息合并都得到对方。也即，如果 $a = \\epsilon$，那么 $r = c = b$；如果 $b = \\epsilon$，那么 $r = c = a$。\n- 不合法信息和任何信息合并都得到不合法信息。也即，如果 $a = \\bot$ 或者 $b = \\bot$，那么 $r = c = \\bot$。\n- 对于剩下的情况，如果两个信息的**边集合**的交集非空，或者**点集合**的交集的大小不为 $1$，则合并得到不合法信息。也即，如果 $S_E(a) \\cap S_E(b) \\ne \\varnothing$ 或 $\\lvert S_V(a) \\cap S_V(b) \\rvert \\ne 1$，则 $r = c = \\bot$。\n- 否则，有\n  $$ S_E(r) = S_E(c) = S_E(a) \\cup S_E(b) \\text{,} $$\n  $$ S_V(r) = S_V(a) \\text{,} $$\n  $$ S_V(c) = S_V(a) \\oplus S_V(b) \\text{,} $$\n  其中 $\\oplus$ 表示集合的对称差运算，也即 $A \\oplus B = (A \\cup B) \\setminus (A \\cap B)$。\n\n定义 $T$ 中两个点的树上距离为树上以两个点为端点的唯一简单路径经过的边数。\n\n给出评分参数 $M$ 和 $q$ 次询问，每次询问给出树上的一个点 $u$ 和一个非负整数 $d$。记点集 $X$ 为 $T$ 中所有与 $u$ 的树上距离不超过 $d$ 的点构成的集合，又记边集 $Y = \\{ (a, b) \\in E \\hspace{3mu}\\vert\\hspace{3mu} a, b \\in X \\}$ 为 $X$ 内部的边集。可以证明，从 $\\epsilon$ 和所有 $\\iota(e)$（$e \\in E$）出发，总是能通过有限次 $R, C$ 的调用得到信息 $o \\ne \\bot$ 满足 $S_E(o) = Y$。\n\n每组询问中，你需要在 $R$ 和 $C$ 的调用次数总和不超过 $M$ 的限制下构造出一个满足这样的要求的信息 $o$。特别地，如果 $d = 0$，则直接返回单位元 $\\epsilon$ 即可。\n\n----\n\n**【实现细节】**\n\n请确保你的程序开头有 `#include \"count.h\"`。\n\n头文件 `count.h` 中实现了如下内容：\n\n1. 定义了信息对应的数据类型 `info`；\n2. 定义了 $\\epsilon$ 所对应的 `info` 类型常量 `emptyinfo`，你可以在程序中直接使用。\n3. 定义并实现了以下两个信息合并函数，你可以在程序中直接调用：\n   \n   ```cpp\n   info MR(info a,info b);\n   info MC(info a,info b);\n   ```\n   \n   - 两个函数分别返回 $R(a, b)$ 与 $C(a, b)$ 对应的信息。\n   \n   **你需要保证调用 $\\boldsymbol{R(a, b)}$ 与 $\\boldsymbol{C(a, b)}$ 时结果不为 $\\boldsymbol{\\bot}$，否则程序可能会出现异常行为。**\n4. 定义并实现了判定一个信息是否为单位元的函数，你可以在程序中直接调用：\n   ```cpp\n   bool isempty(info a);\n   ```\n   - 这个函数返回真当且仅当 $a$ 为单位元。\n\n可以查看参考交互库了解更多实现细节。\n\n**你不需要，也不应该实现主函数。** 你需要实现如下几个函数：\n\n```cpp\nvoid init(int T, int n, int q, vector<int> fa, vector<info> e, int M);\n```\n\n- `T` 表示测试点编号，`n` 表示树的点数，`q` 表示询问数，`M` 表示该测试点的评分参数。\n- `fa` 和 `e` 的长度均为 $n - 1$。对于 $0 \\le i < n - 1$，$fa[i]$ 和 $i + 2$ 为第 $i$ 条边 $e_i$ 的两个端点，$e[i]$ 为题目描述中提到的 $\\iota(e_i)$ 所对应的 `info` 类型元素。数据保证 $fa[i]$ 小于 $i + 2$。\n\n```cpp\ninfo ask(int u, int d);\n```\n\n给出一个询问，参数的意义见题目描述。你需要在函数结束时返回一个满足题设条件的信息。\n\n最终测试时，在每个测试点，交互库会**恰好**调用一次 `init` 函数，随后调用 $q$ 次 `ask`函数。交互库会使用特殊的实现方式，单个 `info` 类型的变量会恒定消耗 $12$ 字节内存，**这与下发的参考交互库不同**。为保证程序运行时内存使用在题目限制内，你需要保证运行过程中没有过多的 `info` 类型变量同时存在。\n\n保证在满足调用次数限制且不进行 `isempty` 函数调用的情况下，最终测试的交互库运行所需的时间不超过 0.6 秒，交互库本身所消耗的内存不超过 16 MiB。保证在只执行 ${10}^8$ 次 `isempty` 函数调用的情况下，最终测试的交互库运行的时间不超过 0.25 秒。\n\n在下发文件中包含一个名为 `count.cpp` 的文件，作为示例程序，选手可以在此基础上继续实现本题。在下发文件中还额外包含一个名为 `count_backup.h` 的备份文件，我们保证其与 `count.h` 文件完全相同。\n\n----\n\n**【测试程序方式】**\n\n本题目录下提供了两个交互库的参考实现 `grader.o`、`checker.o`，其为两个不同的交互库编译产生的可链接文件。最终测试时所用的交互库实现与该实现有不同，因此选手的解法**不应依赖交互库的具体实现**，同时也不应该依赖 `count.h` 中 `info` 类型的具体实现。\n\n你需要修改下发的 `count.h` 来帮助进行链接。具体的，在将源代码 `count.cpp` 和程序 `grader.o` 进行链接的时候，你需要注释掉 `count.h` 代码的第 5 行，并保留第 4 行的代码。链接 `checker.o` 方法类似，需要注释掉 `count.h` 代码的第 4 行，并保留第 5 行的代码。选手可以对 `count.h` 的实现自行修改来实现不同程序的编译。\n\n修改后，选手可以在本题目录下使用如下命令编译得到可执行程序：\n\n```bash\ng++ count.cpp -c -O2 -std=c++14 -lm && g++ count.o grader.o -o count\ng++ count.cpp -c -O2 -std=c++14 -lm && g++ count.o checker.o -o count\n```\n\n其中第一行命令会编译当前 `count.cpp` 后与 `grader.o` 链接起来，生成可执行文件 `count`，第二行命令则会编译当前 `count.cpp` 后与 `checker.o` 链接起来，生成可执行文件 `count`。\n\n按上述方法编译得到的可执行文件 `count`，其运行方式如下：\n\n- 可执行文件将从标准输入读入以下格式的数据：\n  - 第一行四个整数 $id, n, q, M$，分别表示测试点编号、树的点数、询问数和评分参数；\n  - 第二行 $n - 1$ 个整数 $p_2, p_3, \\ldots, p_n$，分别表示 $2$ 至 $n$ 的父亲节点编号，在本地调试时你需要保证 $\\forall i \\in [2, n]$，$p_i < i$；\n  - 接下来 $q$ 行每行两个整数 $u, d$，描述一次询问。\n- 读入之后，交互库会进行测试。如果你的程序不满足交互库限制，其会在输出中返回对应的错误信息。否则，对于链接的可执行文件，其输出如下：\n  - 总共一行三个整数 $C_1, C_2, C_3$，其中：\n    - $C_1$ 表示程序在 `init` 函数中调用交互库函数的总次数；\n    - $C_2$ 表示程序在运行过程中调用交互库函数的总次数；\n    - $C_3$ 表示程序在 $q$ 次 `ask` 函数中调用交互库函数的次数的最大值。\n    - 对于上述三个统计量，我们只会计入 `MR`、`MC` 函数的调用次数，而不会计入 `isempty` 函数的调用次数。\n- 在链接不同文件的时候，其能够进行的检查也不同，具体地：\n  - `grader.o`：其在运行时不会检查 `ask` 函数返回的信息是否正确，但可以帮助选手判断交互操作是否符合要求。这份程序运行时间最接近评测时的交互库，因此选手可以利用该程序测试运行速度，但不保证程序正确性。\n  - `checker.o`：其在运行时会检查 `ask` 函数返回的信息是否正确，也可以帮助选手判断交互操作是否符合要求。同时其会检查 `ask` 函数返回的信息是否正确。这份程序可以进行答案正确性的检查。\n\n选手在调试时需要保证输入可执行文件 `count` 的数据满足上述输入格式，否则不保证输出结果正确。\n", "inputFormat": "见【测试程序方式】。", "outputFormat": "见【测试程序方式】。", "hint": "**【评分方式】**\n\n最终评测**只会**收取 `count.cpp`，修改选手目录下其他文件不会对评测结果产生影响。**注意：**\n\n- **未初始化的 `info` 类型的变量不保证是 `emptyinfo`。**\n- **请不要尝试访问或修改 `info` 类型的成员变量，否则将被视为攻击交互库。**\n- **请不要在 `init` 函数调用之前调用 `MR` 和 `MC` 函数，否则可能会发生未定义行为。**\n- **你只能访问自己定义的变量和交互库返回的 `info` 类型变量，尝试访问其他空间将可能导致编译错误或运行时错误。**\n\n**本题首先会受到和传统题相同的限制**，例如编译错误会导致整道题目得 0 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 0 分等。\n\n在上述条件以外，在一个测试点中，若程序执行了非法的函数调用或询问操作中给出了错误回答，该测试点将会获得 0 分。否则，记 $C_1, C_3$ 分别表示你的程序在 `init` 函数中调用交互库函数的次数，和你的程序在所有 $q$ 次 `ask` 函数中调用交互库函数的次数的最大值。如果 $C_1 \\le 3 \\cdot {10}^7$ 且 $C_3$ 不超过该测试点的评分参数 $M$，你将获得该测试点的分数，否则你无法获得该测试点的分数。注意：计算 $C_1, C_3$ 时只会计入 `MR`、`MC` 函数的调用次数，而不会计入 `isempty` 函数的调用次数。\n\n----\n\n**【样例 \\#1】**\n\n见附件中的 `count/count1.in` 与 `count/count1.ans`。\n\n----\n\n**【样例 \\#2】**\n\n见附件中的 `count/count2.in` 与 `count/count2.ans`。\n\n该组样例满足数据范围中的特殊性质 A。\n\n----\n\n**【样例 \\#3】**\n\n见附件中的 `count/count3.in` 与 `count/count3.ans`。\n\n该组样例满足数据范围中的特殊性质 B。\n\n----\n\n**【样例 \\#4】**\n\n见附件中的 `count/count4.in` 与 `count/count4.ans`。\n\n----\n\n**【数据范围】**\n\n对于所有测试点，$1 \\le n \\le 2 \\times {10}^5$，$1 \\le q \\le {10}^6$；每组询问中，有 $1 \\le u \\le n$，$1 \\le d \\le n - 1$。\n\n| 测试点   | $n=$              | $q=$            | 特殊性质 | $M=$  |\n|:-----:|:-----------------:|:---------------:|:----:|:-----:|\n| $1$   | $1000$            | $10^4$          |      | $500$ |\n| $2$   | $2000$            | $10^4$          |      | $500$ |\n| $3,4$ | $10^5$            | $10^6$          | A    | $5$   |\n| $5,6$ | $6 \\times 10^4$   | $6\\times 10^4$  | B    | $50$  |\n| $7$   | $6 \\times 10^4$   | $6 \\times 10^4$ | B    | $5$   |\n| $8$   | $10^5$            | $10^5$          | B    | $5$   |\n| $9$   | $7500$            | $5 \\times 10^4$ | C    | $500$ |\n| $10$  | $10^4$            | $5 \\times 10^4$ |      | $500$ |\n| $11$  | $1.5 \\times 10^4$ | $5 \\times 10^4$ |      | $500$ |\n| $12$  | $2 \\times 10^4$   | $5 \\times 10^4$ |      | $50$  |\n| $13$  | $2.5 \\times 10^4$ | $5 \\times 10^4$ |      | $5$   |\n| $14$  | $3 \\times 10^4$   | $10^5$          |      | $5$   |\n| $15$  | $6 \\times 10^4$   | $10^6$          | D    | $5$   |\n| $16$  | $6 \\times 10^4$   | $10^6$          |      | $5$   |\n| $17$  | $8 \\times 10^4$   | $10^6$          |      | $5$   |\n| $18$  | $10^5$            | $10^6$          |      | $5$   |\n| $19$  | $1.5 \\times 10^5$ | $10^6$          |      | $5$   |\n| $20$  | $2 \\times 10^5$   | $10^6$          |      | $1$   |\n\n\n特殊性质 A：保证 $\\forall i \\in [1, n - 1]$，编号为 $i + 1$ 的点的父节点为 $i$。  \n特殊性质 B：保证所有询问均满足 $u = 1$。  \n特殊性质 C：保证所有询问均满足 $d \\le 100$。  \n特殊性质 D：保证所有询问均满足 $d \\ge 1000$。", "locale": "zh-CN"}}}
