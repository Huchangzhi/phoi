{"pid": "P2272", "type": "P", "difficulty": 5, "samples": [["6 6 20070603\n1 2\n2 1\n1 3\n2 4\n5 6\n6 4", "3\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "图论", "2007", "各省省选", "浙江", "记忆化搜索", "拓扑排序", "强连通分量", "Tarjan"], "title": "[ZJOI2007] 最大半连通子图", "background": null, "description": "一个有向图 $G=\\left(V,E\\right)$ 称为半连通的 (Semi-Connected)，如果满足：$\\forall u,v\\in V$，满足 $u\\to v$ 或 $v\\to u$，即对于图中任意两点 $u,v$，存在一条 $u$ 到 $v$ 的有向路径或者从 $v$ 到 $u$ 的有向路径。\n\n若 $G'=\\left(V',E'\\right)$ 满足 $V'\\subseteq V$，$E'$ 是 $E$ 中端点属于 $V'$ 的所有边，则称 $G'$ 是 $G$ 的一个导出子图。若 $G'$ 是 $G$ 的导出子图，且 $G'$ 半连通，则称 $G'$ 为 $G$ 的半连通子图。若 $G'$ 是 $G$ 所有半连通子图中包含节点数最多的，则称 $G'$ 是 $G$ 的最大半连通子图。\n\n给定一个有向图 $G$，请求出 $G$ 的最大半连通子图拥有的节点数 $K$，以及不同的最大半连通子图的数目 $C$。由于 $C$ 可能比较大，仅要求输出 $C$ 对 $X$ 的余数。", "inputFormat": "第一行包含三个整数 $N,M,X$。$N,M$ 分别表示图 $G$ 的点数与边数，$X$ 的意义如上文所述。\n\n接下来 $M$ 行，每行两个正整数 $a,b$，表示一条有向边 $\\left(a,b\\right)$。图中的每个点将编号为 $1,2,3\\dots N$，保证输入中同一个 $\\left(a,b\\right)$ 不会出现两次。", "outputFormat": "应包含两行，第一行包含一个整数 $K$，第二行包含整数 $C\\bmod X$。", "hint": "对于 $100\\%$ 的数据，$N\\le 10^5$，$M\\le 10^6$，$X\\le 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2007] Maximum Semi-Connected Subgraph", "background": "", "description": "A directed graph $G=\\left(V,E\\right)$ is called semi-connected if it satisfies: $\\forall u,v\\in V$, either $u\\to v$ or $v\\to u$, that is, for any two vertices $u,v$ in the graph, there exists a directed path from $u$ to $v$ or from $v$ to $u$.\n\nIf $G'=\\left(V',E'\\right)$ satisfies $V'\\subseteq V$ and $E'$ is the set of all edges in $E$ whose endpoints lie in $V'$, then $G'$ is called an induced subgraph of $G$. If $G'$ is an induced subgraph of $G$ and $G'$ is semi-connected, then $G'$ is called a semi-connected subgraph of $G$. If $G'$ contains the largest number of vertices among all semi-connected subgraphs of $G$, then $G'$ is called a maximum semi-connected subgraph of $G$.\n\nGiven a directed graph $G$, find $K$, the number of vertices in a maximum semi-connected subgraph of $G$, and $C$, the number of different maximum semi-connected subgraphs. Since $C$ may be large, output $C$ modulo $X$.", "inputFormat": "The first line contains three integers $N,M,X$. $N$ and $M$ denote the number of vertices and edges of graph $G$, respectively. The meaning of $X$ is as described above.\n\nThe next $M$ lines each contain two positive integers $a,b$, representing a directed edge $\\left(a,b\\right)$. Each vertex is labeled $1,2,3\\dots N$. It is guaranteed that the same $\\left(a,b\\right)$ does not appear twice in the input.", "outputFormat": "Output two lines. The first line contains an integer $K$. The second line contains an integer $C\\bmod X$.", "hint": "For $100\\%$ of the testdata, $N\\le 10^5$, $M\\le 10^6$, $X\\le 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2007] 最大半连通子图", "background": null, "description": "一个有向图 $G=\\left(V,E\\right)$ 称为半连通的 (Semi-Connected)，如果满足：$\\forall u,v\\in V$，满足 $u\\to v$ 或 $v\\to u$，即对于图中任意两点 $u,v$，存在一条 $u$ 到 $v$ 的有向路径或者从 $v$ 到 $u$ 的有向路径。\n\n若 $G'=\\left(V',E'\\right)$ 满足 $V'\\subseteq V$，$E'$ 是 $E$ 中端点属于 $V'$ 的所有边，则称 $G'$ 是 $G$ 的一个导出子图。若 $G'$ 是 $G$ 的导出子图，且 $G'$ 半连通，则称 $G'$ 为 $G$ 的半连通子图。若 $G'$ 是 $G$ 所有半连通子图中包含节点数最多的，则称 $G'$ 是 $G$ 的最大半连通子图。\n\n给定一个有向图 $G$，请求出 $G$ 的最大半连通子图拥有的节点数 $K$，以及不同的最大半连通子图的数目 $C$。由于 $C$ 可能比较大，仅要求输出 $C$ 对 $X$ 的余数。", "inputFormat": "第一行包含三个整数 $N,M,X$。$N,M$ 分别表示图 $G$ 的点数与边数，$X$ 的意义如上文所述。\n\n接下来 $M$ 行，每行两个正整数 $a,b$，表示一条有向边 $\\left(a,b\\right)$。图中的每个点将编号为 $1,2,3\\dots N$，保证输入中同一个 $\\left(a,b\\right)$ 不会出现两次。", "outputFormat": "应包含两行，第一行包含一个整数 $K$，第二行包含整数 $C\\bmod X$。", "hint": "对于 $100\\%$ 的数据，$N\\le 10^5$，$M\\le 10^6$，$X\\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P2273", "type": "P", "difficulty": 4, "samples": [["3 3\r\n1,2,2,3,1,2\r\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2002", "各省省选", "湖南", "bitset"], "title": "[HNOI2002] 交换", "background": "", "description": "给定 $n$ 个整数寄存器 $r_1,r_2,\\cdots,r_n$。我们定义一个比较交换指令 $\\text{CE}(a,b)$ 如下：如果 $r_a$ 中的值大于 $r_b$ 中的值，则交换寄存器 $r_a$ 和 $r_b$ 中的值。其中，$1\\leq a<b\\leq n$。\n\n一个比较交换程序（简称为 CE-程序）就是一个有限交换指令序列。称一个 CE-程序为 MIN-程序，如果在该程序执行之后，寄存器 $r_1$ 中的值是所有寄存器中的值的最小者；如果一个 CE-程序在删除其中任意一条交换指令后，仍然是一个 MIN-程序，则称该 CE-程序是可靠的 MIN-程序。\n\n你的任务是：给定一个 CE-程序 P，编程求出至少在程序 P 的尾部增加多少条指令才能使程序 P 成为可靠的 MIN-程序。\n\n例如，考虑下列三个寄存器的 CE-程序：\n\n$\\text{CE}(1, 2)$，$\\text{CE}(2, 3)$，$\\text{CE}(1, 2)$。\n\n我们仅需要增加两条指令：$\\text{CE}(1, 3)$，$\\text{CE}(1, 2)$ 就可使该 CE-程序成为可靠的 MIN-程序。", "inputFormat": "共两行，第一行为用空格分开的两个整数 $n,m$；其中 $n$ 为寄存器个数（$2\\leq n\\leq 10 ^ 4$），$m$ 为 CE-程序的指令条数（$0\\leq m\\leq20000$）。\n\n接下来为 $m$ 条指令 $\\text{CE}(a,b)$，$a,b$ 之间用逗号分隔，两条指令之间也用逗号分隔。", "outputFormat": "共一行一个整数即应该增加的最少指令条数。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2002] Swap", "background": "", "description": "Given $n$ integer registers $r_1, r_2, \\cdots, r_n$. We define a compare-exchange instruction $\\text{CE}(a,b)$ as follows: if the value in $r_a$ is greater than the value in $r_b$, then swap the values in registers $r_a$ and $r_b$. Here, $1 \\leq a < b \\leq n$.\n\nA compare-exchange program (abbreviated as a CE program) is a finite sequence of compare-exchange instructions. A CE program is called a MIN program if, after executing the program, the value in register $r_1$ is the minimum among all registers. If a CE program remains a MIN program after removing any single instruction from it, then the CE program is called a reliable MIN program.\n\nYour task is: given a CE program $P$, compute the minimum number of instructions that must be appended to the end of $P$ to make $P$ a reliable MIN program.\n\nFor example, consider the following CE program on three registers:\n\n$\\text{CE}(1, 2)$, $\\text{CE}(2, 3)$, $\\text{CE}(1, 2)$.\n\nWe only need to append two instructions: $\\text{CE}(1, 3)$, $\\text{CE}(1, 2)$ to make this CE program a reliable MIN program.", "inputFormat": "There are two lines. The first line contains two space-separated integers $n$ and $m$; here $n$ is the number of registers ($2 \\leq n \\leq 10 ^ 4$), and $m$ is the number of instructions in the CE program ($0 \\leq m \\leq 20000$).\n\nThe second line contains $m$ instructions $\\text{CE}(a, b)$. Inside each instruction, $a$ and $b$ are separated by a comma, and different instructions are also separated by commas.", "outputFormat": "Output a single integer on one line: the minimal number of instructions that should be appended.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2002] 交换", "background": "", "description": "给定 $n$ 个整数寄存器 $r_1,r_2,\\cdots,r_n$。我们定义一个比较交换指令 $\\text{CE}(a,b)$ 如下：如果 $r_a$ 中的值大于 $r_b$ 中的值，则交换寄存器 $r_a$ 和 $r_b$ 中的值。其中，$1\\leq a<b\\leq n$。\n\n一个比较交换程序（简称为 CE-程序）就是一个有限交换指令序列。称一个 CE-程序为 MIN-程序，如果在该程序执行之后，寄存器 $r_1$ 中的值是所有寄存器中的值的最小者；如果一个 CE-程序在删除其中任意一条交换指令后，仍然是一个 MIN-程序，则称该 CE-程序是可靠的 MIN-程序。\n\n你的任务是：给定一个 CE-程序 P，编程求出至少在程序 P 的尾部增加多少条指令才能使程序 P 成为可靠的 MIN-程序。\n\n例如，考虑下列三个寄存器的 CE-程序：\n\n$\\text{CE}(1, 2)$，$\\text{CE}(2, 3)$，$\\text{CE}(1, 2)$。\n\n我们仅需要增加两条指令：$\\text{CE}(1, 3)$，$\\text{CE}(1, 2)$ 就可使该 CE-程序成为可靠的 MIN-程序。", "inputFormat": "共两行，第一行为用空格分开的两个整数 $n,m$；其中 $n$ 为寄存器个数（$2\\leq n\\leq 10 ^ 4$），$m$ 为 CE-程序的指令条数（$0\\leq m\\leq20000$）。\n\n接下来为 $m$ 条指令 $\\text{CE}(a,b)$，$a,b$ 之间用逗号分隔，两条指令之间也用逗号分隔。", "outputFormat": "共一行一个整数即应该增加的最少指令条数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2274", "type": "P", "difficulty": 5, "samples": [["20", "((X)X(X))X"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2002", "各省省选", "湖南"], "title": "[HNOI2002] 树的排序", "background": "", "description": "1. 空树编号为 $0$，只有根节点的树编号为 $1$；\n2. 设 $m$ 为一任意非负整数，那么任意一棵有 $m$ 个节点的树的编号小于任意一棵有 $m+1$ 个节点的树；\n3. 设 $A,B$ 是两棵节点数相同的树（$A,B$ 不相同），则 $A$ 编号比 $B$ 小时，一定满足下面两个条件之一（反之亦然）：\n   1. $A$ 左子树编号小于 $B$ 左子树编号；\n   2. $A$ 左子树编号等于 $B$ 左子树编号（即 $A,B$ 左子树形态相同），且 $A$ 右子树编号小于 $B$ 右子树编号；\n4. 编号按照正常的规则，编号应是连续的非负整数，任意一棵树唯一对应一个编号，任意一个非负整数唯一对应一棵树。\n\n（注：上述树均指二叉树）", "inputFormat": "仅 $1$ 行，为一个整数 $n$，$1\\le n\\le 500{,}000{,}000$。\n\n对于 $10\\%$ 的数据，保证树节点个数不超过三个。", "outputFormat": "仅 $1$ 行，为对应编号为 $n$ 的二叉树。按下列方式输出：\n\n- 如果是一个结点的二叉树，则输出 $X$；\n- 如果二叉树的左、右子树分别为 $L$ 和 $R$，$L,R$ 的输出形式分别为 $L'$ 和 $R'$，则输出为 $\\texttt{(}L'\\texttt{)}X\\texttt{(}R'\\texttt{)}$，当左子树为空时，输出为 $X\\texttt{(}R'\\texttt{)}$，当左子树为空时 $\\texttt{(}L'\\texttt{)}X$。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2002] Ordering of Binary Trees", "background": "", "description": "1. The empty tree is numbered $0$, and the tree with only the root node is numbered $1$.\n2. Let $m$ be any non-negative integer. Then the number of any tree with $m$ nodes is smaller than the number of any tree with $m+1$ nodes.\n3. Let $A, B$ be two trees with the same number of nodes (with $A \\ne B$). The number of $A$ is smaller than that of $B$ if and only if one of the following holds:\n   1. The number of the left subtree of $A$ is smaller than the number of the left subtree of $B$.\n   2. The numbers of the left subtrees of $A$ and $B$ are equal (that is, the left subtrees of $A$ and $B$ have the same shape), and the number of the right subtree of $A$ is smaller than the number of the right subtree of $B$.\n4. Following the usual rule, the numbers are consecutive non-negative integers. Each tree corresponds to a unique number, and each non-negative integer corresponds to a unique tree.\n\n(Note: all trees mentioned above are binary trees.)", "inputFormat": "A single line with an integer $n$, $1\\le n\\le 500{,}000{,}000$.\n\nFor $10\\%$ of the testdata, the number of nodes in the tree does not exceed three.", "outputFormat": "A single line: the binary tree corresponding to number $n$. Output as follows:\n\n- If it is a one-node binary tree, output $X$.\n- If the left and right subtrees are $L$ and $R$, and their respective outputs are $L'$ and $R'$, then output $\\texttt{(}L'\\texttt{)}X\\texttt{(}R'\\texttt{)}$; when the left subtree is empty, output $X\\texttt{(}R'\\texttt{)}$; when the right subtree is empty, output $\\texttt{(}L'\\texttt{)}X$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2002] 树的排序", "background": "", "description": "1. 空树编号为 $0$，只有根节点的树编号为 $1$；\n2. 设 $m$ 为一任意非负整数，那么任意一棵有 $m$ 个节点的树的编号小于任意一棵有 $m+1$ 个节点的树；\n3. 设 $A,B$ 是两棵节点数相同的树（$A,B$ 不相同），则 $A$ 编号比 $B$ 小时，一定满足下面两个条件之一（反之亦然）：\n   1. $A$ 左子树编号小于 $B$ 左子树编号；\n   2. $A$ 左子树编号等于 $B$ 左子树编号（即 $A,B$ 左子树形态相同），且 $A$ 右子树编号小于 $B$ 右子树编号；\n4. 编号按照正常的规则，编号应是连续的非负整数，任意一棵树唯一对应一个编号，任意一个非负整数唯一对应一棵树。\n\n（注：上述树均指二叉树）", "inputFormat": "仅 $1$ 行，为一个整数 $n$，$1\\le n\\le 500{,}000{,}000$。\n\n对于 $10\\%$ 的数据，保证树节点个数不超过三个。", "outputFormat": "仅 $1$ 行，为对应编号为 $n$ 的二叉树。按下列方式输出：\n\n- 如果是一个结点的二叉树，则输出 $X$；\n- 如果二叉树的左、右子树分别为 $L$ 和 $R$，$L,R$ 的输出形式分别为 $L'$ 和 $R'$，则输出为 $\\texttt{(}L'\\texttt{)}X\\texttt{(}R'\\texttt{)}$，当左子树为空时，输出为 $X\\texttt{(}R'\\texttt{)}$，当左子树为空时 $\\texttt{(}L'\\texttt{)}X$。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2275", "type": "P", "difficulty": 0, "samples": [["5 5 1\r\n3 3\r\n1 1 1 1 1\r\n1 6 9 5 1\r\n1 3 10 3 1\r\n1 2 1 2 1\r\n1 1 1 1 1\r\n\r\n4 1 1 1 2\r\n1 1 1 1 1\r\n1 2 3 1 2\r\n1 2 1 1 1\r\n1 1 1 1 1\r\n", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2002", "各省省选", "平衡树", "湖南", "概率论"], "title": "[HNOI2002] 灌溉问题", "background": "", "description": "久居山区的人们一直都为水源的问题而烦恼，缺水使得他们的农田无法获得好的收成。最近，一条好消息传来：政$%$府将提供资金为他们开凿一条水道，将唯一的水源——山顶一个湖泊中的水引入他们的村落。人们顿时都高兴了起来，他们的农田终于可以丰收了。\n\n然而，在开凿水道时，人们却遇到了一个难题：怎样开凿才能得到最大的丰收呢？\n\n要知道，山顶的水是非常有限的，并不可能灌溉到每一个地区。而且，不同地区的土地肥沃程度也是不一样的。虽然并非只有河流经过的地区才能被灌溉，但也不可能将水从很远的地方引过来。你现在必须想办法帮他们解决这个问题。\n\n首先，你可以将这个山区划分成 $N \\times N$ 的区域，湖泊的位置为 $(x,y)$（下标从 $1$ 开始），以及每个区域的海拔高度（开凿出的河流显然只能从严格高处往严格低流），还有每块区域的土地价值也是已知的。\n\n同时，需要注意的是，你的河流是不允许有分支（支流）的，最多只能灌溉 $M$ 块土地，而且被灌溉的土地只能在离河流的 $R$ 格范围以内（包含对角线）。\n\n注意：河流经过的地区土地依然保持其价值，可以选择是否对其灌溉。\n\n你的目的就是找出一条最好的开凿河流的方法，使得能灌溉的土地价值总和最高。", "inputFormat": "第一行为三个整数 $N,M,R\\ (1 \\le N \\le 20,1 \\le M \\le \\min\\{N^2,100\\},1 \\le R \\le \\min\\{N-1,5\\})$，分别给出区域的边长，最多灌溉的土地数和被灌溉土地到河流的最大允许距离。\n\n第二行为两个整数 $x,y\\ (1 \\le x,y \\le N)$，给出了湖泊的位置。\n\n下面一个 $N \\times N$ 的矩阵 $A\\ (1 \\le A_{i,j} \\le 200)$，其中 $A_{i,j}$ 表示 $(i,j)$ 的高度。\n\n下面一个 $N \\times N$ 的矩阵 $V\\ (1 \\le V_{i,j} \\le 200)$，其中 $V_{i,j}$ 表示 $(i,j)$ 的价值。", "outputFormat": "输出一个整数，表示你的程序计算出的最大价值。", "hint": "样例解释：\n\n以下是一种最优解。\n\n河流流向：\n\n$$(3,3) \\to (2,3) \\to (2,2) \\to (3,2) \\to (3,1)$$\n\n灌溉的土地：\n\n$$(1,1),(2,2),(3,2),(3,3),(4,2)$$", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2002] Irrigation Problem", "background": "", "description": "People living in mountainous areas have long been troubled by the lack of water sources, which prevents their farmland from achieving good harvests. Recently, good news arrived: the govern$%$ment will provide funds to dig a canal to bring water from the only source—a lake on the mountain top—down to their village. People were overjoyed; their fields could finally yield a good harvest.\n\nHowever, when digging the canal, they encountered a problem: how should they dig to obtain the greatest harvest?\n\nNote that the water at the mountain top is very limited and cannot irrigate every region. Moreover, different regions have different levels of soil fertility. Although irrigation is not limited only to regions that the river passes through, water cannot be brought from very far away. You must find a way to solve this problem.\n\nFirst, you can divide the mountainous area into an $N \\times N$ grid, with the lake located at $(x,y)$ (indices start from $1$). The elevation of each cell is known (the excavated river can only flow strictly from higher elevation to strictly lower elevation), and the value of each cell of land is also known.\n\nAt the same time, note that the river is not allowed to have branches (tributaries). At most $M$ plots can be irrigated, and irrigated plots must be within $R$ cells of the river (including diagonals).\n\nNote: Land that the river passes through still retains its value; you may choose whether to irrigate it.\n\nYour goal is to find the best way to dig the river such that the total value of irrigated land is maximized.", "inputFormat": "The first line contains three integers $N,M,R\\ (1 \\le N \\le 20,1 \\le M \\le \\min\\{N^2,100\\},1 \\le R \\le \\min\\{N-1,5\\})$, giving the side length of the grid, the maximum number of plots that can be irrigated, and the maximum allowed distance from an irrigated plot to the river.\n\nThe second line contains two integers $x,y\\ (1 \\le x,y \\le N)$, giving the location of the lake.\n\nThen follows an $N \\times N$ matrix $A\\ (1 \\le A_{i,j} \\le 200)$, where $A_{i,j}$ denotes the elevation of $(i,j)$.\n\nThen follows an $N \\times N$ matrix $V\\ (1 \\le V_{i,j} \\le 200)$, where $V_{i,j}$ denotes the value of $(i,j)$.", "outputFormat": "Output a single integer, the maximum total value computed by your program.", "hint": "Sample explanation:\n\nAn optimal solution is as follows.\n\nRiver flow:\n\n$$(3,3) \\to (2,3) \\to (2,2) \\to (3,2) \\to (3,1)$$\n\nIrrigated plots:\n\n$$(1,1),(2,2),(3,2),(3,3),(4,2)$$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2002] 灌溉问题", "background": "", "description": "久居山区的人们一直都为水源的问题而烦恼，缺水使得他们的农田无法获得好的收成。最近，一条好消息传来：政$%$府将提供资金为他们开凿一条水道，将唯一的水源——山顶一个湖泊中的水引入他们的村落。人们顿时都高兴了起来，他们的农田终于可以丰收了。\n\n然而，在开凿水道时，人们却遇到了一个难题：怎样开凿才能得到最大的丰收呢？\n\n要知道，山顶的水是非常有限的，并不可能灌溉到每一个地区。而且，不同地区的土地肥沃程度也是不一样的。虽然并非只有河流经过的地区才能被灌溉，但也不可能将水从很远的地方引过来。你现在必须想办法帮他们解决这个问题。\n\n首先，你可以将这个山区划分成 $N \\times N$ 的区域，湖泊的位置为 $(x,y)$（下标从 $1$ 开始），以及每个区域的海拔高度（开凿出的河流显然只能从严格高处往严格低流），还有每块区域的土地价值也是已知的。\n\n同时，需要注意的是，你的河流是不允许有分支（支流）的，最多只能灌溉 $M$ 块土地，而且被灌溉的土地只能在离河流的 $R$ 格范围以内（包含对角线）。\n\n注意：河流经过的地区土地依然保持其价值，可以选择是否对其灌溉。\n\n你的目的就是找出一条最好的开凿河流的方法，使得能灌溉的土地价值总和最高。", "inputFormat": "第一行为三个整数 $N,M,R\\ (1 \\le N \\le 20,1 \\le M \\le \\min\\{N^2,100\\},1 \\le R \\le \\min\\{N-1,5\\})$，分别给出区域的边长，最多灌溉的土地数和被灌溉土地到河流的最大允许距离。\n\n第二行为两个整数 $x,y\\ (1 \\le x,y \\le N)$，给出了湖泊的位置。\n\n下面一个 $N \\times N$ 的矩阵 $A\\ (1 \\le A_{i,j} \\le 200)$，其中 $A_{i,j}$ 表示 $(i,j)$ 的高度。\n\n下面一个 $N \\times N$ 的矩阵 $V\\ (1 \\le V_{i,j} \\le 200)$，其中 $V_{i,j}$ 表示 $(i,j)$ 的价值。", "outputFormat": "输出一个整数，表示你的程序计算出的最大价值。", "hint": "样例解释：\n\n以下是一种最优解。\n\n河流流向：\n\n$$(3,3) \\to (2,3) \\to (2,2) \\to (3,2) \\to (3,1)$$\n\n灌溉的土地：\n\n$$(1,1),(2,2),(3,2),(3,3),(4,2)$$", "locale": "zh-CN"}}}
{"pid": "P2276", "type": "P", "difficulty": 6, "samples": [["9 3 1 3 1", "9 3 1 3 2 0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2002", "各省省选", "湖南"], "title": "[HNOI2002] 农场的果树", "background": "", "description": "Farmer John 的农场环境优美，其中生长了许多苹果树，而苹果正是 Farmer John 农场里奶牛最喜爱的食物！\n\n一天，闲来无事的奶牛 Besty 坐在苹果树下。她忽然发现，农场里的苹果树都是的二叉树！——当然，这种二叉树并不是严格意义上的二叉树，它可能有左子树而不存在右子树，反之也有可能。\n\n刚学过 Computer Science 的 Besty 给二叉树上每个节点记录下其左子树的节点个数。例如下面的一棵树：\n\n```cpp\n                3\n              /  \\\n             1     3\n            / \\   / \\\n           0   0  1  0\n                 / \\\n                0   0\n```\n随后，用先序遍历给这棵树编码，需要注意的是叶子节点上的数值不必考虑。为了更方便表述，Besty 又在这样的编码前加入一个数字：该树上节点总数。于是，上面这棵数的编码就是：9 3 1 3 1。\n\n这样一来，每一种编码就对应了一棵唯一的二叉树。\n\nBesty 还发现，农场里的所有二叉树的节点总数都相同！并且在节点总数确定的情况下，对任意的合法编码，农场里都存在唯一的一棵树与之对应！\n\n于是，Besty 将所有的二叉树按照上述编码规则编码，然后以编码为关键字进行字典排序。\n\n现在，对于一个给定的编码，奶牛 Besty 想知道字典排序紧跟其后的编码是什么。\n", "inputFormat": "输入文件名：next.in\n\n输入文件有一行，为一个二叉树的编码。保证节点总数不超过 $5\\times10^3$。\n", "outputFormat": "输出文件名：next.out\n\n输出文件有一行，为按字典排序紧跟其后的编码是什么。如果输入的编码是最后一个，则输出 `-1`。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2002] Fruit Trees on the Farm", "background": "", "description": "Farmer John’s farm is beautiful, with many apple trees, and apples are the cows’ favorite food on Farmer John’s farm.\n\nOne day, the idle cow Besty sat under an apple tree. She suddenly noticed that the apple trees on the farm are all binary trees! — Of course, this kind of binary tree is not a strict (full) binary tree; it may have a left subtree but no right subtree, and vice versa.\n\nHaving just learned some Computer Science, Besty wrote down, for each node in a binary tree, the number of nodes in its left subtree. For example, consider the following tree:\n\n```cpp\n                3\n              /  \\\n             1     3\n            / \\   / \\\n           0   0  1  0\n                 / \\\n                0   0\n```\nThen, she encodes this tree by a preorder traversal. Note that the values on leaf nodes are ignored. For convenience, Besty also puts one number at the front of such an encoding: the total number of nodes in the tree. Therefore, the code for the above tree is: 9 3 1 3 1.\n\nIn this way, each code corresponds to a unique binary tree.\n\nBesty also found that all binary trees on the farm have the same total number of nodes. Moreover, with a fixed total number of nodes, for any valid code, there exists exactly one tree on the farm that corresponds to it.\n\nSo, Besty encodes all the binary trees according to the rule above, then sorts them lexicographically by their codes.\n\nNow, given one code, Besty wants to know which code comes immediately after it in lexicographic order.", "inputFormat": "Input file name: next.in.\n\nThe input contains one line: a code of a binary tree. It is guaranteed that the total number of nodes does not exceed $5\\times10^3$.", "outputFormat": "Output file name: next.out.\n\nOutput one line: the code that comes immediately after the given code in lexicographic order. If the input code is the last one, output `-1`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2002] 农场的果树", "background": "", "description": "Farmer John 的农场环境优美，其中生长了许多苹果树，而苹果正是 Farmer John 农场里奶牛最喜爱的食物！\n\n一天，闲来无事的奶牛 Besty 坐在苹果树下。她忽然发现，农场里的苹果树都是的二叉树！——当然，这种二叉树并不是严格意义上的二叉树，它可能有左子树而不存在右子树，反之也有可能。\n\n刚学过 Computer Science 的 Besty 给二叉树上每个节点记录下其左子树的节点个数。例如下面的一棵树：\n\n```cpp\n                3\n              /  \\\n             1     3\n            / \\   / \\\n           0   0  1  0\n                 / \\\n                0   0\n```\n随后，用先序遍历给这棵树编码，需要注意的是叶子节点上的数值不必考虑。为了更方便表述，Besty 又在这样的编码前加入一个数字：该树上节点总数。于是，上面这棵数的编码就是：9 3 1 3 1。\n\n这样一来，每一种编码就对应了一棵唯一的二叉树。\n\nBesty 还发现，农场里的所有二叉树的节点总数都相同！并且在节点总数确定的情况下，对任意的合法编码，农场里都存在唯一的一棵树与之对应！\n\n于是，Besty 将所有的二叉树按照上述编码规则编码，然后以编码为关键字进行字典排序。\n\n现在，对于一个给定的编码，奶牛 Besty 想知道字典排序紧跟其后的编码是什么。\n", "inputFormat": "输入文件名：next.in\n\n输入文件有一行，为一个二叉树的编码。保证节点总数不超过 $5\\times10^3$。\n", "outputFormat": "输出文件名：next.out\n\n输出文件有一行，为按字典排序紧跟其后的编码是什么。如果输入的编码是最后一个，则输出 `-1`。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2277", "type": "P", "difficulty": 4, "samples": [["5 5 5 5\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2003", "各省省选", "湖南"], "title": "[HNOI2003] 24点游戏", "background": "", "description": "为了培养小孩的计算能力，大人们经常给小孩玩这样的游戏：从一副扑克牌中任意抽出 $4$ 张扑克，要小孩用 `+`、`-`、`*`、`/` 和括号组成一个合法的表达式，并使表达式的值为 $24$ 点。这种游戏就是所谓的“$24$ 点游戏”。\n\n请你编程求出对于给出的任意 $4$ 个正整数 $a$、$b$、$c$、$d$，请你编程求出这 $4$ 个整数能组成多少个值为 $24$ 的不同表达式。\n", "inputFormat": "输入文件共一行，为四个正整数 $a$、$b$、$c$、$d$。（$0 \\le a, b, c, d \\le 100$）\n", "outputFormat": "输出文件为由 $a$、$b$、$c$、$d$ 组成的值为 $24$ 的表达式个数，如没有，输出 $0$。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2003] 24 Game", "background": "", "description": "To develop children's arithmetic skills, adults often have them play the following game: draw any $4$ cards from a deck of playing cards, and ask the child to use `+`, `-`, `*`, `/`, and parentheses to form a valid expression whose value is $24$. This game is called the \"24 game\".\n\nGiven any four integers $a$, $b$, $c$, $d$, compute how many different expressions with value $24$ can be formed from these $4$ integers.", "inputFormat": "The input contains one line with four integers $a$, $b$, $c$, $d$ ($0 \\le a, b, c, d \\le 100$).", "outputFormat": "Output the number of expressions equal to $24$ that can be formed from $a$, $b$, $c$, $d$. If there are none, output $0$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2003] 24点游戏", "background": "", "description": "为了培养小孩的计算能力，大人们经常给小孩玩这样的游戏：从一副扑克牌中任意抽出 $4$ 张扑克，要小孩用 `+`、`-`、`*`、`/` 和括号组成一个合法的表达式，并使表达式的值为 $24$ 点。这种游戏就是所谓的“$24$ 点游戏”。\n\n请你编程求出对于给出的任意 $4$ 个正整数 $a$、$b$、$c$、$d$，请你编程求出这 $4$ 个整数能组成多少个值为 $24$ 的不同表达式。\n", "inputFormat": "输入文件共一行，为四个正整数 $a$、$b$、$c$、$d$。（$0 \\le a, b, c, d \\le 100$）\n", "outputFormat": "输出文件为由 $a$、$b$、$c$、$d$ 组成的值为 $24$ 的表达式个数，如没有，输出 $0$。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2278", "type": "P", "difficulty": 3, "samples": [["1 1 5 3 \n2 10 5 1 \n3 12 7 2 \n4 20 2 3 \n5 21 9 4 \n6 22 2 4 \n7 23 5 2 \n8 24 2 4 \n", "1 6\n3 19\n5 30\n6 32\n8 34\n4 35\n7 40\n2 42\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2003", "各省省选", "湖南", "优先队列", "队列"], "title": "[HNOI2003] 操作系统", "background": "", "description": "写一个程序来模拟操作系统的进程调度。假设该系统只有一个 CPU，每一个进程的到达时间，执行时间和运行优先级都是已知的。其中运行优先级用自然数表示，数字越大，则优先级越高。\n\n如果一个进程到达的时候 CPU 是空闲的，则它会一直占用 CPU 直到该进程结束。除非在这个过程中，有一个比它优先级高的进程要运行。在这种情况下，这个新的（优先级更高的）进程会占用 CPU，而老的只有等待。\n\n如果一个进程到达时，CPU 正在处理一个比它优先级高或优先级相同的进程，则这个（新到达的）进程必须等待。\n\n一旦 CPU 空闲，如果此时有进程在等待，则选择优先级最高的先运行。如果有多个优先级最高的进程，则选择到达时间最早的。\n", "inputFormat": "输入包含若干行，每一行有四个自然数（均不超过 $10^8$），分别是进程号，到达时间，执行时间和优先级。不同进程有不同的编号，不会有两个相同优先级的进程同时到达。输入数据已经按到达时间从小到大排序。输入数据保证在任何时候，等待队列中的进程不超过 $15000$ 个。\n", "outputFormat": "按照进程结束的时间输出每个进程的进程号和结束时间。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2003] Operating System", "background": "", "description": "Write a program to simulate process scheduling in an operating system. Assume the system has only one CPU. For each process, its arrival time, execution time, and priority are known. The priority is represented by natural numbers; a larger number means a higher priority.\n\nIf a process arrives when the CPU is idle, it will occupy the CPU continuously until it finishes, unless during this time a process with a higher priority needs to run. In that case, the new (higher-priority) process will take the CPU, and the old one must wait.\n\nIf a process arrives while the CPU is executing a process with a higher or equal priority, then the newly arrived process must wait.\n\nOnce the CPU becomes idle, if there are processes waiting, choose the one with the highest priority to run first. If there are multiple processes with the highest priority, choose the one with the earliest arrival time.", "inputFormat": "The input contains several lines. Each line has four natural numbers (each not exceeding $10^8$): process ID, arrival time, execution time, and priority. Different processes have different IDs. No two processes with the same priority arrive at the same time. The input is sorted in non-decreasing order of arrival time. It is guaranteed that at any time, the number of processes in the waiting queue does not exceed 15000.", "outputFormat": "Output the process ID and its completion time for each process, in the order of their completion times.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2003] 操作系统", "background": "", "description": "写一个程序来模拟操作系统的进程调度。假设该系统只有一个 CPU，每一个进程的到达时间，执行时间和运行优先级都是已知的。其中运行优先级用自然数表示，数字越大，则优先级越高。\n\n如果一个进程到达的时候 CPU 是空闲的，则它会一直占用 CPU 直到该进程结束。除非在这个过程中，有一个比它优先级高的进程要运行。在这种情况下，这个新的（优先级更高的）进程会占用 CPU，而老的只有等待。\n\n如果一个进程到达时，CPU 正在处理一个比它优先级高或优先级相同的进程，则这个（新到达的）进程必须等待。\n\n一旦 CPU 空闲，如果此时有进程在等待，则选择优先级最高的先运行。如果有多个优先级最高的进程，则选择到达时间最早的。\n", "inputFormat": "输入包含若干行，每一行有四个自然数（均不超过 $10^8$），分别是进程号，到达时间，执行时间和优先级。不同进程有不同的编号，不会有两个相同优先级的进程同时到达。输入数据已经按到达时间从小到大排序。输入数据保证在任何时候，等待队列中的进程不超过 $15000$ 个。\n", "outputFormat": "按照进程结束的时间输出每个进程的进程号和结束时间。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2279", "type": "P", "difficulty": 5, "samples": [["6\n1\n2\n3\n4\n5\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2003", "各省省选", "湖南", "深度优先搜索 DFS", "树形 DP"], "title": "[HNOI2003] 消防局的设立", "background": "", "description": "2020 年，人类在火星上建立了一个庞大的基地群，总共有 $n$ 个基地。起初为了节约材料，人类只修建了 $n-1$ 条道路来连接这些基地，并且每两个基地都能够通过道路到达，所以所有的基地形成了一个巨大的树状结构。如果基地 $A$ 到基地 $B$ 至少要经过 $d$ 条道路的话，我们称基地A到基地B的距离为 $d$。\n\n由于火星上非常干燥，经常引发火灾，人类决定在火星上修建若干个消防局。消防局只能修建在基地里，每个消防局有能力扑灭与它距离不超过 $2$ 的基地的火灾。\n\n你的任务是计算至少要修建多少个消防局才能够确保火星上所有的基地在发生火灾时，消防队有能力及时扑灭火灾。", "inputFormat": "输入文件的第一行为 $n$（$1 \\leq n \\leq 1000$），表示火星上基地的数目。接下来的 $n-1$ 行每行有一个正整数，其中文件第 $i$ 行的正整数为 $a_i$，表示从编号为 $i$ 的基地到编号为 $a_i$ 的基地之间有一条道路，为了更加简洁的描述树状结构的基地群，有 $a_i\\lt i$。", "outputFormat": "仅有一个正整数，表示至少要设立多少个消防局才有能力及时扑灭任何基地发生的火灾。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2003] Establishing Fire Stations", "background": "", "description": "In 2020, humans established a large cluster of bases on Mars, with a total of $n$ bases. To save materials at the beginning, humans built only $n-1$ roads to connect these bases, and every pair of bases can be reached via roads, so all the bases form a large tree structure. If traveling from base A to base B requires at least $d$ roads (i.e., the length of the shortest path is $d$), we define the distance from base A to base B to be $d$.\n\nBecause Mars is very dry and fires occur frequently, humans decided to build several fire stations. Fire stations can only be built in bases, and each fire station can extinguish fires at any base whose distance from it does not exceed $2$.\n\nYour task is to compute the minimum number of fire stations needed to ensure that whenever a fire occurs at any base on Mars, the firefighters can extinguish it in time.", "inputFormat": "The first line contains $n$ ($1 \\leq n \\leq 1000$), the number of bases on Mars.  \nFor each $i = 2, 3, \\dots, n$, line $i$ contains a positive integer $a_i$, indicating that there is a road between base $i$ and base $a_i$. To make the tree representation concise, $a_i < i$.", "outputFormat": "Output a single positive integer, the minimum number of fire stations required so that any base that catches fire can be extinguished in time.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2003] 消防局的设立", "background": "", "description": "2020 年，人类在火星上建立了一个庞大的基地群，总共有 $n$ 个基地。起初为了节约材料，人类只修建了 $n-1$ 条道路来连接这些基地，并且每两个基地都能够通过道路到达，所以所有的基地形成了一个巨大的树状结构。如果基地 $A$ 到基地 $B$ 至少要经过 $d$ 条道路的话，我们称基地A到基地B的距离为 $d$。\n\n由于火星上非常干燥，经常引发火灾，人类决定在火星上修建若干个消防局。消防局只能修建在基地里，每个消防局有能力扑灭与它距离不超过 $2$ 的基地的火灾。\n\n你的任务是计算至少要修建多少个消防局才能够确保火星上所有的基地在发生火灾时，消防队有能力及时扑灭火灾。", "inputFormat": "输入文件的第一行为 $n$（$1 \\leq n \\leq 1000$），表示火星上基地的数目。接下来的 $n-1$ 行每行有一个正整数，其中文件第 $i$ 行的正整数为 $a_i$，表示从编号为 $i$ 的基地到编号为 $a_i$ 的基地之间有一条道路，为了更加简洁的描述树状结构的基地群，有 $a_i\\lt i$。", "outputFormat": "仅有一个正整数，表示至少要设立多少个消防局才有能力及时扑灭任何基地发生的火灾。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2280", "type": "P", "difficulty": 3, "samples": [["2 1\n0 0 1\n1 1 1\n", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "2003", "各省省选", "湖南", "枚举", "前缀和"], "title": "[HNOI2003] 激光炸弹", "background": "", "description": "一种新型的激光炸弹，可以摧毁一个边长为 $m$ 的正方形内的所有目标。现在地图上有 $n$ 个目标，用整数 $x_i$ , $y_i$ 表示目标在地图上的位置，每个目标都有一个价值 $v_i$。激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆破范围，即那个边长为 $m$ 的边必须与 $x$ 轴，$y$ 轴平行。若目标位于爆破正方形的边上，该目标不会被摧毁。\n\n现在你的任务是计算一颗炸弹最多能炸掉地图上总价值为多少的目标。\n\n可能存在多个目标在同一位置上的情况。", "inputFormat": "输入的第一行为整数 $n$ 和整数 $m$；\n\n接下来的 $n$ 行，每行有 $3$ 个整数 $x, y, v$，表示一个目标的坐标与价值。", "outputFormat": "输出仅有一个正整数，表示一颗炸弹最多能炸掉地图上总价值为多少的目标（结果不会超过 $32767$ ）。", "hint": "**数据规模与约定**\n\n- 对于 $100\\%$ 的数据，保证 $1 \\le n \\le 10^4$，$0 \\le x_i ,y_i \\le 5\\times 10^3$，$1 \\le m \\le 5\\times 10^3$，$1 \\le v_i < 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2003] Laser Bomb", "background": "", "description": "A new type of laser bomb can destroy all targets inside a square with side length $m$. There are $n$ targets on the map. Integers $x_i$ and $y_i$ denote the position of a target on the map, and each target has a value $v_i$. The bomb is aimed via satellite, but it has a drawback: the blast square, i.e., the square of side length $m$, must have its sides parallel to the x-axis and y-axis. If a target lies on the boundary of the blast square, it will not be destroyed.\n\nYour task is to compute the maximum total value of targets that a single bomb can destroy.\n\nMultiple targets may be located at the same position.", "inputFormat": "The first line contains integers $n$ and $m$.\n\nEach of the next $n$ lines contains three integers $x, y, v$, denoting a target’s coordinates and its value.", "outputFormat": "Output a single positive integer, the maximum total value of targets that can be destroyed by one bomb (the result does not exceed 32767).", "hint": "- Constraints\n  - For $100\\%$ of the testdata, it is guaranteed that $1 \\le n \\le 10^4$, $0 \\le x_i , y_i \\le 5\\times 10^3$, $1 \\le m \\le 5\\times 10^3$, $1 \\le v_i < 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2003] 激光炸弹", "background": "", "description": "一种新型的激光炸弹，可以摧毁一个边长为 $m$ 的正方形内的所有目标。现在地图上有 $n$ 个目标，用整数 $x_i$ , $y_i$ 表示目标在地图上的位置，每个目标都有一个价值 $v_i$。激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆破范围，即那个边长为 $m$ 的边必须与 $x$ 轴，$y$ 轴平行。若目标位于爆破正方形的边上，该目标不会被摧毁。\n\n现在你的任务是计算一颗炸弹最多能炸掉地图上总价值为多少的目标。\n\n可能存在多个目标在同一位置上的情况。", "inputFormat": "输入的第一行为整数 $n$ 和整数 $m$；\n\n接下来的 $n$ 行，每行有 $3$ 个整数 $x, y, v$，表示一个目标的坐标与价值。", "outputFormat": "输出仅有一个正整数，表示一颗炸弹最多能炸掉地图上总价值为多少的目标（结果不会超过 $32767$ ）。", "hint": "**数据规模与约定**\n\n- 对于 $100\\%$ 的数据，保证 $1 \\le n \\le 10^4$，$0 \\le x_i ,y_i \\le 5\\times 10^3$，$1 \\le m \\le 5\\times 10^3$，$1 \\le v_i < 100$。", "locale": "zh-CN"}}}
{"pid": "P2281", "type": "P", "difficulty": 5, "samples": [["A + B\n3 A + 4 A B^3 + C\n", "C+B+4A+4AB^3\r\nBC+AC+3AB+4AB^4+3A^2+4A^2B^3\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2003", "各省省选", "湖南"], "title": "[HNOI2003] 多项式的加法和乘法", "background": "", "description": "今天的数学课上，老师讲了多项式的加法和乘法。然后布置了很多计算题，小明不想花太多时间来做数学作业，于是想编写一个程序来完成这个任务。\n\n比如计算下面两个多项式的和与积：\n\n$xy^2z+31wx^3y^3z^{50}+s^3$  \n$v^2+s^3+3wx^3y^3$\n\n假定所有变量都是单个大写字符，所有的系数和指数都是常数，且都是整数。\n\n我们用 `X^3` 表示 $X$ 的三次方，在系数和不同的项之间用空格分隔，例如 `X Y^2` 中，$X$ 和 $Y$ 之间有空格。下面是两个多项式的例子，除此之外没有别的空格。\n\n`X Y^2 Z + 31 W X^3 Y^3 Z^50 + S^3`  \n`V^2 + S^3 + 3 W X^3 Y^3`\n\n现在，按照上面的格式给定两个多项式，请你求出这两个多项式的和与积。", "inputFormat": "输入包括两行，每一行是一个多项式。每个多项式不超过 $250$ 个字符。计算过程中保证任何中间结果系数和指数均不超过长整数范围。", "outputFormat": "输出也是两行，第一行是两个多项式的和，第二行是两个多项式的积。输出中要求合并同类项。输出多项式的格式和输入的格式类似，但输出时请把所有空格都去掉，并保证每一项都是 ASCII 码排在前面的变量放在前面，即输出 `X^3Y^2` 而不是 `Y^2X^3`。另外，输出的项请按变量 `A` 的指数从小到大排列，变量 `A` 指数相同的，按变量 `B` 的指数从小到大排列，依此类推。并注意输出要符合我们平常书写的习惯。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2003] Addition and Multiplication of Polynomials", "background": "", "description": "In today’s math class, the teacher covered addition and multiplication of polynomials. Then a lot of exercises were assigned. Xiaoming didn’t want to spend too much time on the homework, so he decided to write a program to do it.\n\nFor example, compute the sum and product of the following two polynomials:\n\n$xy^2z+31wx^3y^3z^{50}+s^3$  \n$v^2+s^3+3wx^3y^3$\n\nAssume all variables are single uppercase letters, and all coefficients and exponents are constants and integers.\n\nWe use `X^3` to denote the third power of $X$, and we separate the coefficient and different variables by spaces. For example, in `X Y^2`, there is a space between $X$ and $Y$. Below are two example polynomials; aside from these, there are no other spaces.\n\n`X Y^2 Z + 31 W X^3 Y^3 Z^50 + S^3`  \n`V^2 + S^3 + 3 W X^3 Y^3`\n\nNow, given two polynomials in the above format, compute their sum and product.", "inputFormat": "The input consists of two lines, each being one polynomial. Each polynomial has at most $250$ characters. During computation, it is guaranteed that the coefficients and exponents of any intermediate results do not exceed the long integer range.", "outputFormat": "Output two lines: the first line is the sum of the two polynomials, and the second line is their product. Like the input, combine like terms in the output. The output format is similar to the input format, except that all spaces must be removed, and within each term the variables must be ordered by ascending ASCII code (i.e., output `X^3Y^2` instead of `Y^2X^3`). Additionally, order the terms by the exponent of variable `A` in ascending order; if the exponents of `A` are equal, then by the exponent of `B` in ascending order; and so on. Also make sure the output conforms to our usual mathematical writing conventions.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2003] 多项式的加法和乘法", "background": "", "description": "今天的数学课上，老师讲了多项式的加法和乘法。然后布置了很多计算题，小明不想花太多时间来做数学作业，于是想编写一个程序来完成这个任务。\n\n比如计算下面两个多项式的和与积：\n\n$xy^2z+31wx^3y^3z^{50}+s^3$  \n$v^2+s^3+3wx^3y^3$\n\n假定所有变量都是单个大写字符，所有的系数和指数都是常数，且都是整数。\n\n我们用 `X^3` 表示 $X$ 的三次方，在系数和不同的项之间用空格分隔，例如 `X Y^2` 中，$X$ 和 $Y$ 之间有空格。下面是两个多项式的例子，除此之外没有别的空格。\n\n`X Y^2 Z + 31 W X^3 Y^3 Z^50 + S^3`  \n`V^2 + S^3 + 3 W X^3 Y^3`\n\n现在，按照上面的格式给定两个多项式，请你求出这两个多项式的和与积。", "inputFormat": "输入包括两行，每一行是一个多项式。每个多项式不超过 $250$ 个字符。计算过程中保证任何中间结果系数和指数均不超过长整数范围。", "outputFormat": "输出也是两行，第一行是两个多项式的和，第二行是两个多项式的积。输出中要求合并同类项。输出多项式的格式和输入的格式类似，但输出时请把所有空格都去掉，并保证每一项都是 ASCII 码排在前面的变量放在前面，即输出 `X^3Y^2` 而不是 `Y^2X^3`。另外，输出的项请按变量 `A` 的指数从小到大排列，变量 `A` 指数相同的，按变量 `B` 的指数从小到大排列，依此类推。并注意输出要符合我们平常书写的习惯。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2282", "type": "P", "difficulty": 7, "samples": [["189419111949\n1000010\n", "1894,1911,1949\n1,000010\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [162000, 162000, 162000, 162000, 162000, 162000, 162000, 162000, 162000, 162000]}, "tags": ["2003", "各省省选", "湖南"], "title": "[HNOI2003] 历史年份", "background": null, "description": "明天就要考近代史了，小明决定把要背的历史事件，根据事件发生的年份，按顺序从小到大抄在一张纸上。可是他抄的时候，相邻两个年份相隔太近了。例如 $1894,1911,1949$ 这三个时间，由于相隔太近，纸上写的是：`189419111949`。\n\n这使小明很苦恼，于是他准备编写个程序把这些年份还原成应该的样子。那么，怎么才能够正确地还原呢？\n\n首先，这些年份是按时间顺序严格递增排列的，所以，还原后的也必须满足这点要求。但如果仅仅是这样，那么 $1,89,419,111949$ 也满足要求。显然，最后的年份不可能有这么大，所以，小明要求在这个条件下，最后一个数要最小。\n\n加了这个限制后，$18,94,1911,1949$ 也满足条件，但因为是近代史，第一个年份也不会这么早，所以，小明还要在保证最后一个数最小的前提下，第一个数要尽量大。并在保证第一个数最大的情况下，第二个数最大……以此类推。\n\n注意：在本题中，数字前的前导 $0$ 是被允许的。", "inputFormat": "输入文件包含多行，每一行是一个由不超过 $2000$ 个数字组成的字符串，表示一个测试例子。一个输入文件中最多包含 $1000$ 个测试例子。", "outputFormat": "相对于输入文件的每一个测试例子，你的程序要输出对应的一行，即是分割后的数字序列，相邻两个数用一个逗号分割。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2003] Historical Years", "background": "", "description": "Xiao Ming has a modern history exam tomorrow. He decides to copy the historical events he needs to memorize onto a sheet of paper in ascending order by the year they occurred. However, when he copied them, adjacent years were too close to each other. For example, the three years $1894,1911,1949$ look like this on paper: `189419111949`.\n\nThis troubles Xiao Ming, so he plans to write a program to restore these years to their correct form. How can we restore them correctly?\n\nFirst, the years are strictly increasing in chronological order, so the restored sequence must also satisfy this requirement. But if that is the only constraint, then $1,89,419,111949$ would also satisfy it. Clearly, the last year cannot be that large, so Xiao Ming requires that, under this constraint, the last number be as small as possible.\n\nWith this additional restriction, $18,94,1911,1949$ also satisfies the condition. But since this is modern history, the first year would not be that early. Therefore, on the premise that the last number is minimized, Xiao Ming wants the first number to be as large as possible; and with the first number fixed at its maximum, the second number should be as large as possible; and so on.\n\nNote: In this problem, leading zeros (i.e., leading $0$) are allowed.", "inputFormat": "The input file contains multiple lines. Each line is a string consisting of no more than $2000$ digits, representing one test case. There are at most $1000$ test cases in a single input file.", "outputFormat": "For each test case in the input file, output one corresponding line: the sequence of numbers after splitting, with adjacent numbers separated by a comma.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2003] 历史年份", "background": null, "description": "明天就要考近代史了，小明决定把要背的历史事件，根据事件发生的年份，按顺序从小到大抄在一张纸上。可是他抄的时候，相邻两个年份相隔太近了。例如 $1894,1911,1949$ 这三个时间，由于相隔太近，纸上写的是：`189419111949`。\n\n这使小明很苦恼，于是他准备编写个程序把这些年份还原成应该的样子。那么，怎么才能够正确地还原呢？\n\n首先，这些年份是按时间顺序严格递增排列的，所以，还原后的也必须满足这点要求。但如果仅仅是这样，那么 $1,89,419,111949$ 也满足要求。显然，最后的年份不可能有这么大，所以，小明要求在这个条件下，最后一个数要最小。\n\n加了这个限制后，$18,94,1911,1949$ 也满足条件，但因为是近代史，第一个年份也不会这么早，所以，小明还要在保证最后一个数最小的前提下，第一个数要尽量大。并在保证第一个数最大的情况下，第二个数最大……以此类推。\n\n注意：在本题中，数字前的前导 $0$ 是被允许的。", "inputFormat": "输入文件包含多行，每一行是一个由不超过 $2000$ 个数字组成的字符串，表示一个测试例子。一个输入文件中最多包含 $1000$ 个测试例子。", "outputFormat": "相对于输入文件的每一个测试例子，你的程序要输出对应的一行，即是分割后的数字序列，相邻两个数用一个逗号分割。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2283", "type": "P", "difficulty": 6, "samples": [["5\t\t\t\t\t\t\t\t\t\r\n0 0\r\n0 6\r\n6 6\r\n6 0\r\n3 3\r\n", "9.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "2003", "各省省选", "湖南", "深度优先搜索 DFS"], "title": "[HNOI2003] 多边形", "background": null, "description": "![](https://cdn.luogu.com.cn/upload/pic/1330.png)", "inputFormat": "第一行一个正整数 $n\\ (3 \\le n \\le 1500)$，表示多边形的顶点数。\n\n之后 $n$ 行，每行两个整数 $x_i,y_i\\ (-500 \\le x_i,y_i \\le 500)$，依次表示多边形的每个顶点的坐标。", "outputFormat": "阴影部分的面积，保留 $2$ 位小数。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2003] Polygon", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1330.png)", "inputFormat": "The first line contains a positive integer $n\\ (3 \\le n \\le 1500)$, denoting the number of vertices of the polygon.\nThen $n$ lines follow, each containing two integers $x_i,y_i\\ (-500 \\le x_i,y_i \\le 500)$, representing the coordinates of the polygon’s vertices in order.", "outputFormat": "Output the area of the shaded region, rounded to $2$ decimal places.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2003] 多边形", "background": null, "description": "![](https://cdn.luogu.com.cn/upload/pic/1330.png)", "inputFormat": "第一行一个正整数 $n\\ (3 \\le n \\le 1500)$，表示多边形的顶点数。\n\n之后 $n$ 行，每行两个整数 $x_i,y_i\\ (-500 \\le x_i,y_i \\le 500)$，依次表示多边形的每个顶点的坐标。", "outputFormat": "阴影部分的面积，保留 $2$ 位小数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2284", "type": "P", "difficulty": 6, "samples": [["2\r\n2\r\n5 3\r\n4 2\r\n2\r\n4 3\r\n6 2\r\n", "possible\r\nimpossible\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2003", "各省省选", "湖南"], "title": "[HNOI2003] 密室之门", "background": "", "description": "最近，我国考古学家在秦陵兵马俑的新墓坑中发现了若干个密室，每个密室都可以由一个奇特的门进入。那么怎样才能进入密室呢？\n\n第 $i$ 个密室的门上有 $a_i$ 个转盘，该密室的第 $j$ 个转盘被均匀的分成 $b_{i,j}$ 格，这 $b_{i,j}$ 个格子按顺时针方向依次编号为 $0,1,\\dots,b_{i,j}-1$，并且每一个转盘上面都有一个指针（结构类似于钟表），指针大约每过 $1.53$ 秒就会从原来指向编号为 $x$ 的格子变成指向编号为 $(x+1)\\mod b_{i,j}$ 的格子。当一扇门上所有的转盘上的指针都指向编号为 $0$ 的格子的时候，那么这扇门就会被开启。\n\n但是当考古学家发现密室时，转盘上的指针都指向不同编号的格子，考古学家经过计算发现按照门被开启的原理，有些密室是永远也打不开的。你的任务就是判断那些密室的门是可能被打开的。", "inputFormat": "输入文件的第一行为 $n$，表示密室的个数。接下来的数据分为 $n$ 组，每组描述一扇门。每组数据的第一行为 $a_i$，即该密室门上转盘的个数，接下来的 $a_i$ 行每行有两个数据，第一个数据表示 $b_{i,j}$，第二个数据表示发现该密室时指针所指向的格子的编号。", "outputFormat": "输出文件总共有 $n$ 行。若第 $i$ 间密室的门能够被打开，则输出文件的第 $i$ 行输出 `possible`，如果不能打开则输出 `impossible`。（注意小写输出）。", "hint": "对于 $100\\%$ 的数据，$n<100$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2003] The Door to the Secret Chamber", "background": "", "description": "Recently, archaeologists in China discovered several secret chambers in a new pit of the Terracotta Army, each accessible through a peculiar door. How can a chamber be entered?\n\nOn the door to the $i$-th chamber, there are $a_i$ dials. The $j$-th dial of this chamber is evenly divided into $b_{i,j}$ cells, numbered in clockwise order as $0, 1, \\dots, b_{i,j}-1$. Each dial has a hand (similar to a clock). Approximately every 1.53 seconds, a hand that was pointing at the cell numbered $x$ advances to point at the cell numbered $(x+1)\\mod b_{i,j}$. When, for a door, the hands on all its dials simultaneously point to the cell numbered $0$, the door opens.\n\nHowever, when the chambers were discovered, the hands on the dials pointed to various indices. Based on the opening rule, it was determined that some chambers can never be opened. Your task is to determine which doors can possibly be opened.", "inputFormat": "The first line contains $n$, the number of chambers. The data that follows is divided into $n$ groups, each describing one door. In group $i$, the first line contains $a_i$, the number of dials on that door. Each of the next $a_i$ lines contains two integers: the first is $b_{i,j}$, and the second is the index of the cell the hand was pointing to when the chamber was discovered.", "outputFormat": "Output $n$ lines. For the $i$-th chamber, print `possible` if its door can be opened; otherwise, print `impossible`. Note: use lowercase.", "hint": "Constraints: For $100\\%$ of the testdata, $n<100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2003] 密室之门", "background": "", "description": "最近，我国考古学家在秦陵兵马俑的新墓坑中发现了若干个密室，每个密室都可以由一个奇特的门进入。那么怎样才能进入密室呢？\n\n第 $i$ 个密室的门上有 $a_i$ 个转盘，该密室的第 $j$ 个转盘被均匀的分成 $b_{i,j}$ 格，这 $b_{i,j}$ 个格子按顺时针方向依次编号为 $0,1,\\dots,b_{i,j}-1$，并且每一个转盘上面都有一个指针（结构类似于钟表），指针大约每过 $1.53$ 秒就会从原来指向编号为 $x$ 的格子变成指向编号为 $(x+1)\\mod b_{i,j}$ 的格子。当一扇门上所有的转盘上的指针都指向编号为 $0$ 的格子的时候，那么这扇门就会被开启。\n\n但是当考古学家发现密室时，转盘上的指针都指向不同编号的格子，考古学家经过计算发现按照门被开启的原理，有些密室是永远也打不开的。你的任务就是判断那些密室的门是可能被打开的。", "inputFormat": "输入文件的第一行为 $n$，表示密室的个数。接下来的数据分为 $n$ 组，每组描述一扇门。每组数据的第一行为 $a_i$，即该密室门上转盘的个数，接下来的 $a_i$ 行每行有两个数据，第一个数据表示 $b_{i,j}$，第二个数据表示发现该密室时指针所指向的格子的编号。", "outputFormat": "输出文件总共有 $n$ 行。若第 $i$ 间密室的门能够被打开，则输出文件的第 $i$ 行输出 `possible`，如果不能打开则输出 `impossible`。（注意小写输出）。", "hint": "对于 $100\\%$ 的数据，$n<100$。", "locale": "zh-CN"}}}
{"pid": "P2285", "type": "P", "difficulty": 3, "samples": [["2 2\t         \r\n1 1 1\t\t\r\n2 2 2\r\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2004", "各省省选", "湖南", "最短路"], "title": "[HNOI2004] 打鼹鼠", "background": null, "description": "鼹鼠是一种很喜欢挖洞的动物，但每过一定的时间，它还是喜欢把头探出到地面上来透透气的。\n\n根据这个特点阿牛编写了一个打鼹鼠的游戏：在一个 $n \\times n$ 的网格中，在某些时刻鼹鼠会在某一个网格探出头来透透气。\n\n你可以控制一个机器人来打鼹鼠，如果 $i$ 时刻鼹鼠在某个网格中出现，而机器人也处于同一网格的话，那么这个鼹鼠就会被机器人打死。\n\n而机器人每一时刻只能够移动一格或停留在原地不动。机器人的移动是指从当前所处的网格移向相邻的网格，即从坐标为 $(i, j)$ 的网格移向 $(i-1, j), (i+1, j), (i, j-1), (i, j+1)$ 四个网格，机器人不能走出整个 $n \\times n$ 的网格。\n\n游戏开始时，你可以自由选定机器人的初始位置。\n\n现在知道在一段时间内，鼹鼠出现的时间和地点，请编写一个程序使机器人在这一段时间内打死尽可能多的鼹鼠。", "inputFormat": "第一行为 $n, m\\ (1 \\le n \\le 10^3, 1 \\le m \\le 10^4)$，其中 $m$ 表示在这一段时间内出现的鼹鼠的个数。\n\n接下来的 $m$ 行中每行有三个数据 $t, x, y\\ (1 \\le t \\le 2.5 \\times 10^7, 1 \\le x,y \\le n)$，表示在游戏开始后 $t$ 个时刻，在第 $x$ 行第 $y$ 个网格里出现了一只鼹鼠。\n\n$t$ 按不降的顺序给出。\n\n注意同一时刻可能出现多只鼹鼠，但同一时刻同一地点只可能出现一只鼹鼠。", "outputFormat": "仅包含一个非负整数，表示被打死鼹鼠的最大数目。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2004] Whack-a-Mole", "background": "", "description": "Moles like to dig holes, but at certain times they will stick their heads out of the ground to breathe.\n\nBased on this, Aniu designed a whack-a-mole game: on an $n \\times n$ grid, at certain times a mole will pop up in some cell.\n\nYou can control a robot to whack moles. If at time $i$ a mole appears in some cell and the robot is in the same cell, then this mole will be killed by the robot.\n\nAt each time step, the robot can move by one cell or stay where it is. Moving means going from the current cell to an adjacent cell, i.e., from the cell with coordinates $(i, j)$ to one of $(i-1, j)$, $(i+1, j)$, $(i, j-1)$, $(i, j+1)$. The robot cannot leave the $n \\times n$ grid.\n\nAt the start of the game, you may choose the robot’s initial position arbitrarily.\n\nGiven the times and locations where moles appear over a period of time, write a program to maximize the number of moles the robot can kill during this period.", "inputFormat": "The first line contains $n, m\\ (1 \\le n \\le 10^3, 1 \\le m \\le 10^4)$, where $m$ is the number of moles that appear during this period.\n\nEach of the next $m$ lines contains three integers $t, x, y\\ (1 \\le t \\le 2.5 \\times 10^7, 1 \\le x, y \\le n)$, meaning that $t$ time units after the game starts, a mole appears in row $x$, column $y$.\n\nThe values of $t$ are given in nondecreasing order.\n\nNote that multiple moles may appear at the same time, but at most one mole appears at the same location at the same time.", "outputFormat": "Output a single non-negative integer, the maximum number of moles that can be killed.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2004] 打鼹鼠", "background": null, "description": "鼹鼠是一种很喜欢挖洞的动物，但每过一定的时间，它还是喜欢把头探出到地面上来透透气的。\n\n根据这个特点阿牛编写了一个打鼹鼠的游戏：在一个 $n \\times n$ 的网格中，在某些时刻鼹鼠会在某一个网格探出头来透透气。\n\n你可以控制一个机器人来打鼹鼠，如果 $i$ 时刻鼹鼠在某个网格中出现，而机器人也处于同一网格的话，那么这个鼹鼠就会被机器人打死。\n\n而机器人每一时刻只能够移动一格或停留在原地不动。机器人的移动是指从当前所处的网格移向相邻的网格，即从坐标为 $(i, j)$ 的网格移向 $(i-1, j), (i+1, j), (i, j-1), (i, j+1)$ 四个网格，机器人不能走出整个 $n \\times n$ 的网格。\n\n游戏开始时，你可以自由选定机器人的初始位置。\n\n现在知道在一段时间内，鼹鼠出现的时间和地点，请编写一个程序使机器人在这一段时间内打死尽可能多的鼹鼠。", "inputFormat": "第一行为 $n, m\\ (1 \\le n \\le 10^3, 1 \\le m \\le 10^4)$，其中 $m$ 表示在这一段时间内出现的鼹鼠的个数。\n\n接下来的 $m$ 行中每行有三个数据 $t, x, y\\ (1 \\le t \\le 2.5 \\times 10^7, 1 \\le x,y \\le n)$，表示在游戏开始后 $t$ 个时刻，在第 $x$ 行第 $y$ 个网格里出现了一只鼹鼠。\n\n$t$ 按不降的顺序给出。\n\n注意同一时刻可能出现多只鼹鼠，但同一时刻同一地点只可能出现一只鼹鼠。", "outputFormat": "仅包含一个非负整数，表示被打死鼹鼠的最大数目。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2286", "type": "P", "difficulty": 3, "samples": [["5                  \r\n0 2                      \r\n0 4                         \r\n1 3\r\n1 2\r\n1 5\r\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2004", "线段树", "各省省选", "平衡树", "树状数组", "离散化", "湖南", "STL"], "title": "[HNOI2004] 宠物收养场", "background": "题面修缮来自于 [LaDeX](https://www.luogu.com.cn/user/431658)。", "description": "凡凡开了一间宠物收养场。收养场提供两种服务：收养被主人遗弃的宠物和让新的主人领养这些宠物。\n\n每个领养者都希望领养到自己满意的宠物，凡凡根据领养者的要求通过他自己发明的一个特殊的公式，得出该领养者希望领养的宠物的特点值 $a$（$a$ 是一个正整数，$a<2^{31}$），而他也给每个处在收养场的宠物一个特点值。这样他就能够很方便的处理整个领养宠物的过程了，宠物收养场总是会有两种情况发生：被遗弃的宠物过多或者是想要收养宠物的人太多，而宠物太少。\n\n被遗弃的宠物过多时，假若到来一个领养者，这个领养者希望领养的宠物的特点值为 $a$，那么它将会领养一只目前未被领养的宠物中特点值最接近 $a$ 的一只宠物。（任何两只宠物的特点值都不可能是相同的，任何两个领养者的希望领养宠物的特点值也不可能是一样的）如果有两只满足要求的宠物，即存在两只宠物他们的特点值分别为 $a-b$ 和 $a+b$，那么领养者将会领养特点值为 $a-b$ 的那只宠物。\n\n收养宠物的人过多，假若到来一只被收养的宠物，那么哪个领养者能够领养它呢？能够领养它的领养者，是那个希望被领养宠物的特点值最接近该宠物特点值的领养者，如果该宠物的特点值为 $a$，存在两个领养者他们希望领养宠物的特点值分别为 $a-b$ 和 $a+b$，那么特点值为 $a-b$ 的那个领养者将成功领养该宠物。\n\n一个领养者领养了一个特点值为 $a$ 的宠物，而它本身希望领养的宠物的特点值为 $b$，那么这个领养者的不满意程度为 $|a-b|$。\n\n你得到了一年当中，领养者和被收养宠物到来收养所的情况，请你计算所有收养了宠物的领养者的不满意程度的总和。这一年初始时，收养所里面既没有宠物，也没有领养者。", "inputFormat": "第一行为一个正整数 $n$，$n\\leq80000$，表示一年当中来到收养场的宠物和领养者的总数。接下来的 $n$ 行，按到来时间的先后顺序描述了一年当中来到收养场的宠物和领养者的情况。每行有两个正整数 $a,b$，其中 $a=0$ 表示宠物，$a=1$ 表示领养者，$b$ 表示宠物的特点值或是领养者希望领养宠物的特点值。（同一时间呆在收养所中的，要么全是宠物，要么全是领养者，这些宠物和领养者的个数不会超过 $10000$ 个）\n", "outputFormat": "仅有一个正整数，表示一年当中所有收养了宠物的领养者的不满意程度的总和对 $1000000$ 取模以后的结果。\n", "hint": "样例解释：\n\n注：$|3-2| + |2-4|=3$，\n最后一个领养者没有宠物可以领养。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2004] Pet Adoption Center", "background": "Problem statement polished by [LaDeX](https://www.luogu.com.cn/user/431658).", "description": "Fanfan opened a pet adoption center. The center offers two services: taking in abandoned pets and allowing new owners to adopt these pets.\n\nEach adopter hopes to adopt a satisfactory pet. Based on the adopter’s requirements, Fanfan uses a special formula of his own invention to obtain the adopter’s desired feature value $a$ ($a$ is a positive integer, $a < 2^{31}$). He also assigns a feature value to each pet in the shelter. This makes handling the entire adoption process convenient. The shelter often faces two situations: too many abandoned pets, or too many adopters and too few pets.\n\nWhen there are too many abandoned pets, if an adopter arrives desiring a feature value $a$, they will adopt the currently unadopted pet whose feature value is closest to $a$. (No two pets share the same feature value, and no two adopters share the same desired feature value.) If there are two candidates with feature values $a-b$ and $a+b$, the adopter will adopt the pet with feature value $a-b$.\n\nWhen there are too many adopters, if a pet arrives, which adopter can adopt it? The adopter who can adopt it is the one whose desired feature value is closest to the pet’s feature value. If the pet’s feature value is $a$ and there are two adopters desiring $a-b$ and $a+b$, then the adopter with desired value $a-b$ will successfully adopt the pet.\n\nIf an adopter adopts a pet with feature value $a$ while their desired feature value is $b$, the adopter’s dissatisfaction is $|a-b|$.\n\nYou are given the sequence of arrivals of adopters and pets at the shelter over a year. Please compute the total dissatisfaction of all adopters who successfully adopted a pet. At the beginning of the year, there are neither pets nor adopters in the shelter.", "inputFormat": "The first line contains an integer $n$, $n \\leq 80000$, the total number of pets and adopters arriving at the shelter during the year. The next $n$ lines, in order of arrival time, describe these arrivals. Each line contains two integers $a, b$, where $a \\in \\{0, 1\\}$ ($a = 0$ indicates a pet, $a = 1$ indicates an adopter), and $b$ is the pet’s feature value or the adopter’s desired feature value. (At any given time, the shelter contains either only pets or only adopters, and their counts do not exceed $10000$.)", "outputFormat": "Output a single integer: the total dissatisfaction of all adopters who successfully adopted a pet, modulo $1000000$.", "hint": "Sample explanation:\n\nNote: $|3-2| + |2-4| = 3$. The last adopter has no pet to adopt.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2004] 宠物收养场", "background": "题面修缮来自于 [LaDeX](https://www.luogu.com.cn/user/431658)。", "description": "凡凡开了一间宠物收养场。收养场提供两种服务：收养被主人遗弃的宠物和让新的主人领养这些宠物。\n\n每个领养者都希望领养到自己满意的宠物，凡凡根据领养者的要求通过他自己发明的一个特殊的公式，得出该领养者希望领养的宠物的特点值 $a$（$a$ 是一个正整数，$a<2^{31}$），而他也给每个处在收养场的宠物一个特点值。这样他就能够很方便的处理整个领养宠物的过程了，宠物收养场总是会有两种情况发生：被遗弃的宠物过多或者是想要收养宠物的人太多，而宠物太少。\n\n被遗弃的宠物过多时，假若到来一个领养者，这个领养者希望领养的宠物的特点值为 $a$，那么它将会领养一只目前未被领养的宠物中特点值最接近 $a$ 的一只宠物。（任何两只宠物的特点值都不可能是相同的，任何两个领养者的希望领养宠物的特点值也不可能是一样的）如果有两只满足要求的宠物，即存在两只宠物他们的特点值分别为 $a-b$ 和 $a+b$，那么领养者将会领养特点值为 $a-b$ 的那只宠物。\n\n收养宠物的人过多，假若到来一只被收养的宠物，那么哪个领养者能够领养它呢？能够领养它的领养者，是那个希望被领养宠物的特点值最接近该宠物特点值的领养者，如果该宠物的特点值为 $a$，存在两个领养者他们希望领养宠物的特点值分别为 $a-b$ 和 $a+b$，那么特点值为 $a-b$ 的那个领养者将成功领养该宠物。\n\n一个领养者领养了一个特点值为 $a$ 的宠物，而它本身希望领养的宠物的特点值为 $b$，那么这个领养者的不满意程度为 $|a-b|$。\n\n你得到了一年当中，领养者和被收养宠物到来收养所的情况，请你计算所有收养了宠物的领养者的不满意程度的总和。这一年初始时，收养所里面既没有宠物，也没有领养者。", "inputFormat": "第一行为一个正整数 $n$，$n\\leq80000$，表示一年当中来到收养场的宠物和领养者的总数。接下来的 $n$ 行，按到来时间的先后顺序描述了一年当中来到收养场的宠物和领养者的情况。每行有两个正整数 $a,b$，其中 $a=0$ 表示宠物，$a=1$ 表示领养者，$b$ 表示宠物的特点值或是领养者希望领养宠物的特点值。（同一时间呆在收养所中的，要么全是宠物，要么全是领养者，这些宠物和领养者的个数不会超过 $10000$ 个）\n", "outputFormat": "仅有一个正整数，表示一年当中所有收养了宠物的领养者的不满意程度的总和对 $1000000$ 取模以后的结果。\n", "hint": "样例解释：\n\n注：$|3-2| + |2-4|=3$，\n最后一个领养者没有宠物可以领养。", "locale": "zh-CN"}}}
{"pid": "P2287", "type": "P", "difficulty": 6, "samples": [["4 \r\n0 0 0\r\n1 0 0\r\n0 1 0\r\n0 0 1\r\n", "2.366025"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2004", "各省省选", "湖南", "凸包"], "title": "[HNOI2004] 最佳包裹", "background": "", "description": "发强公司生产了一种金属制品，是由一些笔直的金属条连接起来的，金属条和别的金属条在交点上被焊接在了一起。现在由于美观需要，在这个产品用一层特殊的材料包裹起来。公司为了节约成本，希望消耗的材料最少（不计裁剪时的边角料的损失）。\n\n编程，输入包括该产品的顶点的个数，以及所有顶点的坐标；请计算出包裹这个产品所需要的材料的最小面积。结果要求精确到小数点后第六位（四舍五入）。", "inputFormat": "输入文件由 $(n+1)$ 行组成。\n\n第 $1$ 行是一个整数 $n$（$4 \\leq n \\leq 100$），表示顶点的个数；\n\n第 $2$ 行到第 $(n+1)$ 行，第 $(i+1)$ 行有 $3$ 个实数 $x_i$，$y_i$，$z_i$，表示第 $i$ 个顶点的坐标。\n\n保证顶点的位置各不相同。", "outputFormat": "输出文件只有一个实数，四舍五入精确到小数点后六位，表示包裹一个该产品所需的材料面积的最小值。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2004] Best Package", "background": "", "description": "Faqiang Company produces a kind of metal product made by connecting several straight metal bars, which are welded together at their intersection points. For aesthetic reasons, the product is to be wrapped with a layer of special material. To save costs, the company hopes to use the least amount of material (the waste from cutting scraps is ignored).\n\nWrite a program that, given the number of vertices of the product and the coordinates of all vertices, computes the minimal area of material needed to wrap the product. The result should be rounded to six decimal places.", "inputFormat": "The input file consists of $(n+1)$ lines.\n\nThe first line contains an integer $n$ ($4 \\leq n \\leq 100$), denoting the number of vertices.\n\nFrom line $2$ to line $(n+1)$, the $(i+1)$-th line contains three real numbers $x_i$, $y_i$, $z_i$, which are the coordinates of the $i$-th vertex.\n\nAll vertices are guaranteed to be distinct.", "outputFormat": "Output a single real number, rounded to six decimal places, which is the minimal area of material required to wrap one such product.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2004] 最佳包裹", "background": "", "description": "发强公司生产了一种金属制品，是由一些笔直的金属条连接起来的，金属条和别的金属条在交点上被焊接在了一起。现在由于美观需要，在这个产品用一层特殊的材料包裹起来。公司为了节约成本，希望消耗的材料最少（不计裁剪时的边角料的损失）。\n\n编程，输入包括该产品的顶点的个数，以及所有顶点的坐标；请计算出包裹这个产品所需要的材料的最小面积。结果要求精确到小数点后第六位（四舍五入）。", "inputFormat": "输入文件由 $(n+1)$ 行组成。\n\n第 $1$ 行是一个整数 $n$（$4 \\leq n \\leq 100$），表示顶点的个数；\n\n第 $2$ 行到第 $(n+1)$ 行，第 $(i+1)$ 行有 $3$ 个实数 $x_i$，$y_i$，$z_i$，表示第 $i$ 个顶点的坐标。\n\n保证顶点的位置各不相同。", "outputFormat": "输出文件只有一个实数，四舍五入精确到小数点后六位，表示包裹一个该产品所需的材料面积的最小值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2288", "type": "P", "difficulty": 0, "samples": [["3 5\r\n6 1 2 5\r\n1 2 8 4\r\n4 -1 5 6\r\n1 0\r\n5 -1\r\n4 2\r\n7 3\r\n4 4\r\n", "11.933\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "各省省选", "湖南"], "title": "[HNOI2005] 纸片覆盖", "background": "", "description": "喜欢几何的小付遇到了这样一个问题：一天他在一张白纸上画了 $n$ 条直线，然后剪了一张 $m$ 边形（简单多边形）的小纸片。\n\n他想把这张小纸片放在白纸上，使它盖住的线段的总长度最长。并且这张多边形纸片不能翻转或旋转，只能平移，如果直线的某一段刚好与多边形纸片的边重合，那么，这条线段算作是被覆盖。\n\n你能帮他解决这个问题吗？", "inputFormat": "从文件 `input.txt` 中读入数据，文件第一行为两个数 $n$ 和 $m$，其中 $1\\leq n,m\\leq10$，分别表示直线的数目和多边形的边数。\n\n接下来的 $n$ 行分别表示各条直线，每行有 $4$ 个实数 $x_1,y_1,x_2,y_2$，表示一条经过 $\\left(x_1,y_1\\right)$ 和 $\\left(x_2,y_2\\right)$ 的直线。\n\n接下来的 $m$ 行按顺时针或逆时针的顺序输入多边形的各个顶点，每行有 $2$ 个实数 $x,y$，表示一个顶点的坐标。\n\n这里假设所有输入的实数都在 $-10000$ 到 $10000$ 之间，且不会超过 $2$ 位小数，输入的多边形保证不自交，且连续的 $3$ 点不共线。\n", "outputFormat": "输出文件 `output.txt` 中仅包含一个数 $L$，表示输入的多边形能盖住的最大的线段总长度，精确到小数点后 $3$ 位。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2005] Paper Covering", "background": "", "description": "Xiaofu, who likes geometry, encountered the following problem: one day he drew $n$ lines on a white sheet of paper, and then cut out a small $m$-gon (simple polygon).\n\nHe wants to place this small paper piece on the sheet so that the total length of the lines it covers is maximized. The polygon piece cannot be flipped or rotated; it can only be translated. If some portion of a line happens to coincide with an edge of the polygon, then that segment is considered covered.\n\nCan you help him solve this problem?", "inputFormat": "Read from the file `input.txt`. The first line contains two numbers $n$ and $m$, where $1 \\leq n, m \\leq 10$, denoting the number of lines and the number of edges of the polygon, respectively.\n\nEach of the next $n$ lines describes a line, with $4$ real numbers $x_1, y_1, x_2, y_2$, representing a line passing through $\\left(x_1, y_1\\right)$ and $\\left(x_2, y_2\\right)$.\n\nEach of the next $m$ lines gives the vertices of the polygon in either clockwise or counterclockwise order, with $2$ real numbers $x, y$, representing the coordinates of a vertex.\n\nAssume all input real numbers are between $-10000$ and $10000$, and have no more than $2$ decimal places. The input polygon is guaranteed to be non-self-intersecting, and no three consecutive points are collinear.", "outputFormat": "The output file `output.txt` contains only one number $L$, the maximum total length of line segments that the input polygon can cover, accurate to $3$ decimal places.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2005] 纸片覆盖", "background": "", "description": "喜欢几何的小付遇到了这样一个问题：一天他在一张白纸上画了 $n$ 条直线，然后剪了一张 $m$ 边形（简单多边形）的小纸片。\n\n他想把这张小纸片放在白纸上，使它盖住的线段的总长度最长。并且这张多边形纸片不能翻转或旋转，只能平移，如果直线的某一段刚好与多边形纸片的边重合，那么，这条线段算作是被覆盖。\n\n你能帮他解决这个问题吗？", "inputFormat": "从文件 `input.txt` 中读入数据，文件第一行为两个数 $n$ 和 $m$，其中 $1\\leq n,m\\leq10$，分别表示直线的数目和多边形的边数。\n\n接下来的 $n$ 行分别表示各条直线，每行有 $4$ 个实数 $x_1,y_1,x_2,y_2$，表示一条经过 $\\left(x_1,y_1\\right)$ 和 $\\left(x_2,y_2\\right)$ 的直线。\n\n接下来的 $m$ 行按顺时针或逆时针的顺序输入多边形的各个顶点，每行有 $2$ 个实数 $x,y$，表示一个顶点的坐标。\n\n这里假设所有输入的实数都在 $-10000$ 到 $10000$ 之间，且不会超过 $2$ 位小数，输入的多边形保证不自交，且连续的 $3$ 点不共线。\n", "outputFormat": "输出文件 `output.txt` 中仅包含一个数 $L$，表示输入的多边形能盖住的最大的线段总长度，精确到小数点后 $3$ 位。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2289", "type": "P", "difficulty": 7, "samples": [[" 2 2", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "高精度", "2004", "各省省选", "湖南", "哈希 hashing", "轮廓线 DP"], "title": "[HNOI2004] 邮递员", "background": "", "description": "小李在 P 市的邮政局工作，他每天的工作是从邮局出发，到自己所管辖的所有邮筒取信件，然后带回邮局。他所管辖的邮筒非常巧地排成了一个 $m\\times n$ 的点阵（点阵中的间距都是相等的）。左上角的邮筒恰好在邮局的门口。\n\n小李是一个非常标新立异的人，他希望每天都能走不同的路线，但是同时，他又不希望路线的长度增加（即选择最短的路径走，注意路径长度是指小李实际走的物理距离，并且对路过每个邮筒的次数没有限制），他想知道他有多少条不同的路线可走。他在任何两个邮筒之间走的是直线。\n\n编程，输入包括点阵的 $m$ 和 $n$ 的值；计算出小李可选的不同路线的总条数。", "inputFormat": "输入只有一行两个整数 $m$，$n$，表示了小李管辖内的邮筒排成的点阵大小。", "outputFormat": "输出一行一个整数，表示小李可选的不同路线的条数。", "hint": "#### 样例输入输出 1 解释\n![](https://cdn.luogu.com.cn/upload/pic/1331.png)\n\n---\n#### 数据规模与约定\n- 对于 $100\\%$ 的数据，保证 $1\\le m\\le10$，$1\\le n\\le20$，且保证 $n\\times m$ 是偶数。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2004] Postman", "background": "", "description": "Xiao Li works at the post office in city P. Every day, his job is to start from the post office, collect letters from all the mailboxes under his charge, and then return to the post office. The mailboxes he manages happen to form an $m \\times n$ lattice of points (with equal spacing). The mailbox at the upper-left corner is exactly at the post office entrance.\n\nXiao Li is a very unconventional person. He hopes to take a different route every day, but at the same time he does not want the route length to increase (that is, he chooses a shortest route; note that the route length is the physical distance he actually walks, and there is no restriction on how many times he passes each mailbox). He wants to know how many different routes he can take. Between any two mailboxes, he walks along a straight line.\n\nWrite a program that takes the values of $m$ and $n$ for the lattice as input, and computes the total number of different routes Xiao Li can choose.", "inputFormat": "The input consists of a single line with two integers $m$, $n$, representing the size of the lattice of mailboxes under Xiao Li’s charge.", "outputFormat": "Output one line with a single integer, the number of different routes Xiao Li can choose.", "hint": "#### Explanation for Sample Input/Output 1\n![](https://cdn.luogu.com.cn/upload/pic/1331.png)\n\n---\n#### Constraints\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\le m \\le 10$, $1 \\le n \\le 20$, and $n \\times m$ is even.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2004] 邮递员", "background": "", "description": "小李在 P 市的邮政局工作，他每天的工作是从邮局出发，到自己所管辖的所有邮筒取信件，然后带回邮局。他所管辖的邮筒非常巧地排成了一个 $m\\times n$ 的点阵（点阵中的间距都是相等的）。左上角的邮筒恰好在邮局的门口。\n\n小李是一个非常标新立异的人，他希望每天都能走不同的路线，但是同时，他又不希望路线的长度增加（即选择最短的路径走，注意路径长度是指小李实际走的物理距离，并且对路过每个邮筒的次数没有限制），他想知道他有多少条不同的路线可走。他在任何两个邮筒之间走的是直线。\n\n编程，输入包括点阵的 $m$ 和 $n$ 的值；计算出小李可选的不同路线的总条数。", "inputFormat": "输入只有一行两个整数 $m$，$n$，表示了小李管辖内的邮筒排成的点阵大小。", "outputFormat": "输出一行一个整数，表示小李可选的不同路线的条数。", "hint": "#### 样例输入输出 1 解释\n![](https://cdn.luogu.com.cn/upload/pic/1331.png)\n\n---\n#### 数据规模与约定\n- 对于 $100\\%$ 的数据，保证 $1\\le m\\le10$，$1\\le n\\le20$，且保证 $n\\times m$ 是偶数。", "locale": "zh-CN"}}}
{"pid": "P2290", "type": "P", "difficulty": 5, "samples": [["4                     \n2 1 2 1\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2004", "各省省选", "湖南", "组合数学", "排列组合", "Prüfer 序列"], "title": "[HNOI2004] 树的计数", "background": "", "description": "一个有 $n$ 个节点的树，设它的节点分别为 $v_1,v_2,\\ldots,v_n$，已知第 $i$ 个节点 $v_i$ 的度数为 $d_i$，问满足这样的条件的不同的树有多少棵。\n", "inputFormat": "输入文件第一行是一个正整数 $n$ ，表示树有 $n$ 个结点。第二行有 $n$ 个数，第 $i$ 个数表示 $d_i$，即树的第 $i$ 个结点的度数。", "outputFormat": "输出满足条件的树有多少棵。\n", "hint": "$1\\le n\\le 150$，保证满足条件的树不超过 $10^{17}$ 个。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2004] Counting Trees", "background": "", "description": "Consider a tree with $n$ nodes, denoted $v_1, v_2, \\ldots, v_n$. The degree of node $v_i$ is given as $d_i$. How many distinct trees satisfy these conditions?", "inputFormat": "The first line contains a positive integer $n$, the number of nodes in the tree. The second line contains $n$ integers; the $i$-th of them is $d_i$, the degree of node $v_i$.", "outputFormat": "Output the number of trees that satisfy the conditions.", "hint": "Constraints: $1 \\le n \\le 150$. It is guaranteed that the number of valid trees does not exceed $10^{17}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2004] 树的计数", "background": "", "description": "一个有 $n$ 个节点的树，设它的节点分别为 $v_1,v_2,\\ldots,v_n$，已知第 $i$ 个节点 $v_i$ 的度数为 $d_i$，问满足这样的条件的不同的树有多少棵。\n", "inputFormat": "输入文件第一行是一个正整数 $n$ ，表示树有 $n$ 个结点。第二行有 $n$ 个数，第 $i$ 个数表示 $d_i$，即树的第 $i$ 个结点的度数。", "outputFormat": "输出满足条件的树有多少棵。\n", "hint": "$1\\le n\\le 150$，保证满足条件的树不超过 $10^{17}$ 个。", "locale": "zh-CN"}}}
{"pid": "P2291", "type": "P", "difficulty": 5, "samples": [["22 2", "27"], ["22 1", "25"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "PA（波兰）"], "title": "[PA 2011] Prime prime power 质数的质数次方", "background": "", "description": "对于给定的数 $n$，求第 $k$ 小的 $a^b$（$a,b$ 都为质数），使得它的值大于 $n$。", "inputFormat": "一行两个整数 $n,k$。", "outputFormat": "一行一个整数为答案。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^{18}$，$1\\le k\\le 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2011] Prime prime power 质数的质数次方", "background": "", "description": "对于给定的数 $n$，求第 $k$ 小的 $a^b$（$a,b$ 都为质数），使得它的值大于 $n$。", "inputFormat": "一行两个整数 $n,k$。", "outputFormat": "一行一个整数为答案。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^{18}$，$1\\le k\\le 10^5$。", "locale": "zh-CN"}}}
