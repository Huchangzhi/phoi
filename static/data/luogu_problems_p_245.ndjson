{"pid": "P5955", "type": "P", "difficulty": 6, "samples": [["5\n2 -2\n-2 -2\n0 2\n3 1\n-3 1", "26"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "POI（波兰）"], "title": "[POI 2018] Pionek", "background": "", "description": "在无限大的二维平面的原点 $(0,0)$ 放置着一个棋子。你有 $n$ 条可用的移动指令，每条指令可以用一个二维整数向量表示。每条指令可以执行 $1$ 次或者不执行。棋子可以重复经过同一个点，两条指令的方向向量也可能相同。你的目标是让棋子最终离原点的**欧几里得距离**最远，请问这个最远距离是多少？", "inputFormat": "第一行包含一个正整数 $n$，表示指令条数。\n\n接下来 $n$ 行，每行两个整数 $x,y$，表示你可以从 $(a,b)$ 移动到 $(a+x,b+y)$。", "outputFormat": "输出一行一个整数，即最大距离的平方。", "hint": "对于 $100\\%$ 的数据，$n\\le 2 \\times 10^5$，$|x|,|y| \\le 10^4$。\n\n-----\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aiztesh5.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2018] Pionek", "background": "", "description": "在无限大的二维平面的原点 $(0,0)$ 放置着一个棋子。你有 $n$ 条可用的移动指令，每条指令可以用一个二维整数向量表示。每条指令可以执行 $1$ 次或者不执行。棋子可以重复经过同一个点，两条指令的方向向量也可能相同。你的目标是让棋子最终离原点的**欧几里得距离**最远，请问这个最远距离是多少？", "inputFormat": "第一行包含一个正整数 $n$，表示指令条数。\n\n接下来 $n$ 行，每行两个整数 $x,y$，表示你可以从 $(a,b)$ 移动到 $(a+x,b+y)$。", "outputFormat": "输出一行一个整数，即最大距离的平方。", "hint": "对于 $100\\%$ 的数据，$n\\le 2 \\times 10^5$，$|x|,|y| \\le 10^4$。\n\n-----\n\n### 样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/aiztesh5.png)", "locale": "zh-CN"}}}
{"pid": "P5956", "type": "P", "difficulty": 3, "samples": [["3 3\n1 1 1\n0\n1\n2", "0\n2 \n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "二分", "POI（波兰）", "数论"], "title": "[POI 2017] Podzielno", "background": null, "description": "$B$ 进制数，每个数字 $i \\in [0,B)$ 有 $a_i$ 个。你要用这些数字组成一个最大的 $B$ 进制数 $X$（不能有前导零，不需要用完所有数字），使得 $X$ 是 $B-1$ 的倍数。 $q$ 次询问，每次询问 $X$ 在 $B$ 进制下的第 $k$ 位数字是什么（最低位是第 $0$ 位）。", "inputFormat": "第一行包含两个正整数 $B,q$。\n\n第二行包含 $B$ 个正整数 $a_0,a_1,a_2,...,a_{B-1}$。\n\n接下来 $q$ 行，每行一个整数 $k$，表示一个询问。", "outputFormat": "输出 $q$ 行，每行一个整数，依次回答每个询问，如果那一位不存在，请输出 $-1$。", "hint": "对于 $100\\%$ 的数据，$2\\le B\\le10^6$，$1\\le q\\le 10^5$，$1\\le a_i\\le10^6$，$0\\le k\\le10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2017] Podzielno", "background": null, "description": "$B$ 进制数，每个数字 $i \\in [0,B)$ 有 $a_i$ 个。你要用这些数字组成一个最大的 $B$ 进制数 $X$（不能有前导零，不需要用完所有数字），使得 $X$ 是 $B-1$ 的倍数。 $q$ 次询问，每次询问 $X$ 在 $B$ 进制下的第 $k$ 位数字是什么（最低位是第 $0$ 位）。", "inputFormat": "第一行包含两个正整数 $B,q$。\n\n第二行包含 $B$ 个正整数 $a_0,a_1,a_2,...,a_{B-1}$。\n\n接下来 $q$ 行，每行一个整数 $k$，表示一个询问。", "outputFormat": "输出 $q$ 行，每行一个整数，依次回答每个询问，如果那一位不存在，请输出 $-1$。", "hint": "对于 $100\\%$ 的数据，$2\\le B\\le10^6$，$1\\le q\\le 10^5$，$1\\le a_i\\le10^6$，$0\\le k\\le10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P5957", "type": "P", "difficulty": 4, "samples": [["4 11\n4 1 4\n7 -1 2\n8 -1 3\n9 0 2", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2017", "POI（波兰）"], "title": "[POI 2017] Flappy Bird", "background": "`《飞扬的小鸟》` 是一款风靡的小游戏。", "description": "在游戏中，小鸟一开始位于 $(0,0)$ 处，它的目标是飞到横坐标为 $X$ 的某个位置上。\n\n每一秒，你可以选择点击屏幕，那么小鸟会从 $(x,y)$ 飞到 $(x+1,y+1)$，或者不点击，那么小鸟会飞到 $(x+1,y-1)$。\n\n在游戏中还有 $n$ 个障碍物，用三元组 $(x_i,a_i,b_i)$ 描述，表示在直线 $x=x_i$ 上，$y\\le a_i$ 或者 $y\\ge b_i$ 的部分都是障碍物，碰到或者擦边都算游戏失败。\n\n现在，请你求出小鸟从 $(0,0)$ 飞到目的地最少需要点击多少次屏幕。", "inputFormat": "第一行包含两个整数 $n,X$。\n接下来 $n$ 行，每行三个整数 $x_i,a_i,b_i$。数据保证 $x_i<x_{i+1}$。", "outputFormat": "如果无论如何都飞不到目的地，输出 `NIE`，否则输出点击屏幕的最少次数。", "hint": "对于 $100\\%$ 的数据，$0\\le n\\le 500000$，$1\\le X\\le10^9$，$0<x_i<X$，$-10^9\\le a_i<b_i\\le 10^9$。\n\n-------\n\n### 样例解释：\n![](https://cdn.luogu.com.cn/upload/image_hosting/9lse80af.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2017] Flappy Bird", "background": "`《飞扬的小鸟》` 是一款风靡的小游戏。", "description": "在游戏中，小鸟一开始位于 $(0,0)$ 处，它的目标是飞到横坐标为 $X$ 的某个位置上。\n\n每一秒，你可以选择点击屏幕，那么小鸟会从 $(x,y)$ 飞到 $(x+1,y+1)$，或者不点击，那么小鸟会飞到 $(x+1,y-1)$。\n\n在游戏中还有 $n$ 个障碍物，用三元组 $(x_i,a_i,b_i)$ 描述，表示在直线 $x=x_i$ 上，$y\\le a_i$ 或者 $y\\ge b_i$ 的部分都是障碍物，碰到或者擦边都算游戏失败。\n\n现在，请你求出小鸟从 $(0,0)$ 飞到目的地最少需要点击多少次屏幕。", "inputFormat": "第一行包含两个整数 $n,X$。\n接下来 $n$ 行，每行三个整数 $x_i,a_i,b_i$。数据保证 $x_i<x_{i+1}$。", "outputFormat": "如果无论如何都飞不到目的地，输出 `NIE`，否则输出点击屏幕的最少次数。", "hint": "对于 $100\\%$ 的数据，$0\\le n\\le 500000$，$1\\le X\\le10^9$，$0<x_i<X$，$-10^9\\le a_i<b_i\\le 10^9$。\n\n-------\n\n### 样例解释：\n![](https://cdn.luogu.com.cn/upload/image_hosting/9lse80af.png)", "locale": "zh-CN"}}}
{"pid": "P5958", "type": "P", "difficulty": 5, "samples": [["9 3\n1\n1\n2\n2\n2\n3\n7\n3", "0.6666666667"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2017", "POI（波兰）", "Special Judge", "树形 DP"], "title": "[POI 2017] Sabotaż", "background": null, "description": "某个公司有 $n$ 个人，上下级关系构成了一个有根树。其中有个人是叛徒（这个人不知道是谁）。\n\n对于一个人，如果他下属（直接或者间接，不包括他自己）中叛徒占的比例超过 $x$，那么这个人也会变成叛徒，并且他的所有下属都会变成叛徒。你要求出一个最小的 $x$，使得最坏情况下，叛徒的个数不会超过 $k$。", "inputFormat": "第一行包含两个正整数 $n,k$。\n\n接下来 $n-1$ 行，第 $i$ 行包含一个正整数 $p_{i+1}$，表示 $i+1$ 的父亲是 $p_{i+1}$。", "outputFormat": "输出一行一个实数 $x$，误差在 $10^{-6}$ 以内都认为是正确的。", "hint": "#### 样例解释\n答案中的 $x$ 实际上是一个无限趋近于 $\\frac{2}{3}$ 但是大于 $\\frac{2}{3}$ 的数。 \n\n因为当 $x$ 取 $\\frac{2}{3}$ 时，最坏情况下 $3,7,8,9$ 都是叛徒，超过了 $k=3$。\n#### 数据范围\n对于 $100\\%$ 的数据，$1\\le k\\le n\\le 500000$，$1\\le p_{i+1}\\le i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2017] Sabotaż", "background": null, "description": "某个公司有 $n$ 个人，上下级关系构成了一个有根树。其中有个人是叛徒（这个人不知道是谁）。\n\n对于一个人，如果他下属（直接或者间接，不包括他自己）中叛徒占的比例超过 $x$，那么这个人也会变成叛徒，并且他的所有下属都会变成叛徒。你要求出一个最小的 $x$，使得最坏情况下，叛徒的个数不会超过 $k$。", "inputFormat": "第一行包含两个正整数 $n,k$。\n\n接下来 $n-1$ 行，第 $i$ 行包含一个正整数 $p_{i+1}$，表示 $i+1$ 的父亲是 $p_{i+1}$。", "outputFormat": "输出一行一个实数 $x$，误差在 $10^{-6}$ 以内都认为是正确的。", "hint": "#### 样例解释\n答案中的 $x$ 实际上是一个无限趋近于 $\\frac{2}{3}$ 但是大于 $\\frac{2}{3}$ 的数。 \n\n因为当 $x$ 取 $\\frac{2}{3}$ 时，最坏情况下 $3,7,8,9$ 都是叛徒，超过了 $k=3$。\n#### 数据范围\n对于 $100\\%$ 的数据，$1\\le k\\le n\\le 500000$，$1\\le p_{i+1}\\le i$。", "locale": "zh-CN"}}}
{"pid": "P5959", "type": "P", "difficulty": 4, "samples": [["7\n6 6 2 2 1\n5 3 5 1 4", "TAK\n1 5 2\n5 7 1\n5 2 4\n7 3 3\n1 4 2\n1 6 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "POI（波兰）", "Special Judge"], "title": "[POI 2018] Plan metra", "background": "", "description": "有一棵 $n$ 个点的无根树，每条边有一个正整数权值，表示长度，定义两点距离为在树上的最短路径的长度。\n\n已知 $2$ 到 $ n-1$ 每个点在树上与 $1$ 和 $n$ 的距离，请根据这些信息还原出这棵树。", "inputFormat": "第一行包含一个正整数 $n$，表示点数。\n\n第二行包含 $n-2$ 个正整数 $d(1,2),d(1,3),...,d(1,n-1)$，分别表示每个点到 $1$ 的距离。\n\n第三行包含 $n-2$ 个正整数 $d(n,2),d(n,3),...,d(n,n-1)$，分别表示每个点到 $n$ 的距离。", "outputFormat": "若无解，输出 `NIE`。\n\n否则第一行输出`TAK`，接下来 $n-1$ 行每行三个正整数 $u,v,c$，表示存在一条长度为 $c$ 的连接 $u$ 和 $v$ 两点的树边。\n\n若有多组解，输出任意一组即可。\n\n**本题使用 Special Judge。**", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 500000$，$1\\le d\\le 1000000$，$1\\le u,v\\le n$，$1\\le c\\le1000000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2018] Plan metra", "background": "", "description": "有一棵 $n$ 个点的无根树，每条边有一个正整数权值，表示长度，定义两点距离为在树上的最短路径的长度。\n\n已知 $2$ 到 $ n-1$ 每个点在树上与 $1$ 和 $n$ 的距离，请根据这些信息还原出这棵树。", "inputFormat": "第一行包含一个正整数 $n$，表示点数。\n\n第二行包含 $n-2$ 个正整数 $d(1,2),d(1,3),...,d(1,n-1)$，分别表示每个点到 $1$ 的距离。\n\n第三行包含 $n-2$ 个正整数 $d(n,2),d(n,3),...,d(n,n-1)$，分别表示每个点到 $n$ 的距离。", "outputFormat": "若无解，输出 `NIE`。\n\n否则第一行输出`TAK`，接下来 $n-1$ 行每行三个正整数 $u,v,c$，表示存在一条长度为 $c$ 的连接 $u$ 和 $v$ 两点的树边。\n\n若有多组解，输出任意一组即可。\n\n**本题使用 Special Judge。**", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 500000$，$1\\le d\\le 1000000$，$1\\le u,v\\le n$，$1\\le c\\le1000000$。", "locale": "zh-CN"}}}
{"pid": "P5960", "type": "P", "difficulty": 4, "samples": [["3 3\n1 2 3\n2 3 -2\n1 3 1", "5 3 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["Special Judge", "差分约束", "模板题"], "title": "【模板】差分约束", "background": "", "description": "给出一组包含 $m$ 个不等式，有 $n$ 个未知数的形如：\n\n$$ \\begin{cases} x_{c_1}-x_{c'_1}\\leq y_1 \\\\x_{c_2}-x_{c'_2} \\leq y_2 \\\\ \\cdots\\\\ x_{c_m} - x_{c'_m}\\leq y_m\\end{cases}$$\n\n的不等式组，求任意一组满足这个不等式组的解。", "inputFormat": "第一行为两个正整数 $n,m$，代表未知数的数量和不等式的数量。\n\n接下来 $m$ 行，每行包含三个整数 $c,c',y$，代表一个不等式 $x_c-x_{c'}\\leq y$。", "outputFormat": "一行，$n$ 个数，表示 $x_1 , x_2 \\cdots x_n$ 的一组可行解，如果有多组解，请输出任意一组，无解请输出 `NO`。", "hint": "**样例解释**\n\n$\\begin{cases}x_1-x_2\\leq 3 \\\\ x_2 - x_3 \\leq -2 \\\\ x_1 - x_3 \\leq 1 \\end{cases}$\n\n一种可行的方法是 $x_1 = 5, x_2 = 3, x_3 = 5$。\n\n$\\begin{cases}5-3  = 2\\leq 3 \\\\ 3 - 5 = -2 \\leq -2 \\\\ 5 - 5  = 0\\leq 1 \\end{cases}$\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$1\\leq n,m \\leq 5\\times 10^3$，$-10^4\\leq y\\leq 10^4$，$1\\leq c,c'\\leq n$，$c \\neq c'$。\n\n**评分策略**\n\n你的答案符合该不等式组即可得分，请确保你的答案中的数据在 `int` 范围内。\n\n如果并没有答案，而你的程序给出了答案，SPJ 会给出 `There is no answer, but you gave it`，结果为 WA；    \n如果并没有答案，而你的程序输出了 `NO`，SPJ 会给出 `No answer`，结果为 AC；       \n如果存在答案，而你的答案错误，SPJ 会给出 `Wrong answer`，结果为 WA；    \n如果存在答案，且你的答案正确，SPJ 会给出 `The answer is correct`，结果为 AC。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Difference Constraints", "background": "", "description": "You are given a system of inequalities with $m$ inequalities and $n$ unknowns of the form:\n\n$$ \\begin{cases} x_{c_1}-x_{c'_1}\\leq y_1 \\\\x_{c_2}-x_{c'_2} \\leq y_2 \\\\ \\cdots\\\\ x_{c_m} - x_{c'_m}\\leq y_m\\end{cases}$$\n\nFind any set of values that satisfies this system of inequalities.", "inputFormat": "The first line contains two positive integers $n, m$, representing the number of unknowns and the number of inequalities.\n\nThe next $m$ lines each contain three integers $c, c', y$, representing an inequality $x_c - x_{c'} \\leq y$.", "outputFormat": "Output one line with $n$ numbers, representing a feasible solution $x_1, x_2 \\cdots x_n$. If there are multiple solutions, output any one of them. If there is no solution, output `NO`.", "hint": "**Sample Explanation**\n\n$\\begin{cases}x_1-x_2\\leq 3 \\\\ x_2 - x_3 \\leq -2 \\\\ x_1 - x_3 \\leq 1 \\end{cases}$\n\nOne feasible solution is $x_1 = 5, x_2 = 3, x_3 = 5$.\n\n$\\begin{cases}5-3  = 2\\leq 3 \\\\ 3 - 5 = -2 \\leq -2 \\\\ 5 - 5  = 0\\leq 1 \\end{cases}$\n\n**Constraints**\n\nFor $100\\%$ of the testdata, $1\\leq n,m \\leq 5\\times 10^3$, $-10^4\\leq y\\leq 10^4$, $1\\leq c,c'\\leq n$, and $c \\neq c'$.\n\n**Scoring Policy**\n\nYou will get points as long as your output satisfies the system of inequalities. Please make sure the numbers in your output are within the `int` range.\n\nIf there is no solution but your program outputs a solution, the SPJ will return `There is no answer, but you gave it`, and the result will be WA.  \nIf there is no solution and your program outputs `NO`, the SPJ will return `No answer`, and the result will be AC.  \nIf a solution exists but your output is incorrect, the SPJ will return `Wrong answer`, and the result will be WA.  \nIf a solution exists and your output is correct, the SPJ will return `The answer is correct`, and the result will be AC.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】差分约束", "background": "", "description": "给出一组包含 $m$ 个不等式，有 $n$ 个未知数的形如：\n\n$$ \\begin{cases} x_{c_1}-x_{c'_1}\\leq y_1 \\\\x_{c_2}-x_{c'_2} \\leq y_2 \\\\ \\cdots\\\\ x_{c_m} - x_{c'_m}\\leq y_m\\end{cases}$$\n\n的不等式组，求任意一组满足这个不等式组的解。", "inputFormat": "第一行为两个正整数 $n,m$，代表未知数的数量和不等式的数量。\n\n接下来 $m$ 行，每行包含三个整数 $c,c',y$，代表一个不等式 $x_c-x_{c'}\\leq y$。", "outputFormat": "一行，$n$ 个数，表示 $x_1 , x_2 \\cdots x_n$ 的一组可行解，如果有多组解，请输出任意一组，无解请输出 `NO`。", "hint": "**样例解释**\n\n$\\begin{cases}x_1-x_2\\leq 3 \\\\ x_2 - x_3 \\leq -2 \\\\ x_1 - x_3 \\leq 1 \\end{cases}$\n\n一种可行的方法是 $x_1 = 5, x_2 = 3, x_3 = 5$。\n\n$\\begin{cases}5-3  = 2\\leq 3 \\\\ 3 - 5 = -2 \\leq -2 \\\\ 5 - 5  = 0\\leq 1 \\end{cases}$\n\n**数据范围**\n\n对于 $100\\%$ 的数据，$1\\leq n,m \\leq 5\\times 10^3$，$-10^4\\leq y\\leq 10^4$，$1\\leq c,c'\\leq n$，$c \\neq c'$。\n\n**评分策略**\n\n你的答案符合该不等式组即可得分，请确保你的答案中的数据在 `int` 范围内。\n\n如果并没有答案，而你的程序给出了答案，SPJ 会给出 `There is no answer, but you gave it`，结果为 WA；    \n如果并没有答案，而你的程序输出了 `NO`，SPJ 会给出 `No answer`，结果为 AC；       \n如果存在答案，而你的答案错误，SPJ 会给出 `Wrong answer`，结果为 WA；    \n如果存在答案，且你的答案正确，SPJ 会给出 `The answer is correct`，结果为 AC。", "locale": "zh-CN"}}}
{"pid": "P5961", "type": "P", "difficulty": 3, "samples": [["7 25\n1 0\n2 0\n3 1\n5 0\n10 0\n13 0\n20 0", "3\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2006", "BalticOI（波罗的海）"], "title": "[BalticOI 2006] coin collector钱币收藏家", "background": null, "description": "有一个国家，流通着 $n$ 种面值的硬币，其中包括了1分硬币。另外，有一种面值为 $K$ 分的纸币，它超过了所有硬币的面值。 有一位硬币收藏家，他想收集每一种面值的硬币样本。他家里已经有一些硬币，但是现在他只带着一张 $K$ 分纸币去商店。 商店里总共有 $K-1$ 种商品，价格分别为 $1$ 分、$2$ 分…… $K-1$ 分。\n\n这家商店使用以下算法找零：  \n1.假设总共需要找 $A$ 分；  \n2.寻找最高的不超过 $A$ 的硬币面值，设它为 $B$ 分硬币；  \n3.给顾客一枚 $B$ 分硬币，然后令 $A$ 为 $A-B$；  \n4.如果 $A=0$，算法结束；否则转2。\n\n收藏家想用他的 $K$ 分纸币买一件商品。请你编写程序，计算：收藏家能够得到多少种他还没有过的硬币? 在满足上一问的前提下，他能够买的最贵的商品是什么?", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $K$。\n\n以下 $n$ 行描述各种流通的硬币的面值和是否已收藏状态。第 $i+1$ 行包含整数 $C_i\\ (1\\le C_i<K)$ 和 $d_i$，$C_i$ 表示第 $i$ 种硬币的面值。若 $d_i=1$，收藏家已经有硬币 $C_i$，若 $d_i=0$，收藏家还没有硬币 $C_i$。输入按照硬币面值递增顺序，也就是 $C_1<C_2<…<C_n$，第一枚硬币是 $1$ 分硬币，也就是 $C_1=1$。", "outputFormat": "输出第一行为一个整数，表示收藏家最多能获得多少种之前还没有的硬币。\n\n第二行为一个整数，表示在前一问的前提下，收藏家能购买的最贵的商品价格。", "hint": "对于所有数据，$1\\le n\\le 5\\times 10^5$，$2\\le K\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2006] coin collector钱币收藏家", "background": null, "description": "有一个国家，流通着 $n$ 种面值的硬币，其中包括了1分硬币。另外，有一种面值为 $K$ 分的纸币，它超过了所有硬币的面值。 有一位硬币收藏家，他想收集每一种面值的硬币样本。他家里已经有一些硬币，但是现在他只带着一张 $K$ 分纸币去商店。 商店里总共有 $K-1$ 种商品，价格分别为 $1$ 分、$2$ 分…… $K-1$ 分。\n\n这家商店使用以下算法找零：  \n1.假设总共需要找 $A$ 分；  \n2.寻找最高的不超过 $A$ 的硬币面值，设它为 $B$ 分硬币；  \n3.给顾客一枚 $B$ 分硬币，然后令 $A$ 为 $A-B$；  \n4.如果 $A=0$，算法结束；否则转2。\n\n收藏家想用他的 $K$ 分纸币买一件商品。请你编写程序，计算：收藏家能够得到多少种他还没有过的硬币? 在满足上一问的前提下，他能够买的最贵的商品是什么?", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $K$。\n\n以下 $n$ 行描述各种流通的硬币的面值和是否已收藏状态。第 $i+1$ 行包含整数 $C_i\\ (1\\le C_i<K)$ 和 $d_i$，$C_i$ 表示第 $i$ 种硬币的面值。若 $d_i=1$，收藏家已经有硬币 $C_i$，若 $d_i=0$，收藏家还没有硬币 $C_i$。输入按照硬币面值递增顺序，也就是 $C_1<C_2<…<C_n$，第一枚硬币是 $1$ 分硬币，也就是 $C_1=1$。", "outputFormat": "输出第一行为一个整数，表示收藏家最多能获得多少种之前还没有的硬币。\n\n第二行为一个整数，表示在前一问的前提下，收藏家能购买的最贵的商品价格。", "hint": "对于所有数据，$1\\le n\\le 5\\times 10^5$，$2\\le K\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5962", "type": "P", "difficulty": 4, "samples": [["12\n2-4,7,9;\n1,4,11-12;\n1,4,10,12;\n1,4-8,10-12;\n1,8;\n1,3-6,8,10-12;\n1,3,5-6,8,11;\n1,8,10-12;\n1-8;\n;\n2;\n2-4,7-10,12;", "29 1\n7 3\n4 2\n1 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2004", "并查集", "BalticOI（波罗的海）"], "title": "[BalticOI 2004] Ships (Day1)", "background": null, "description": "有一个由 $n\\times n$ 的正方形组成的“船”的游戏棋盘。每个单元格可能属于某艘船（黑色）或为空。如果两个边相邻的单元格都是黑色，那么这两个单元格属于同一艘船。不同船之间没有公共边。船的吨位是这些相邻的单元格数。\n\n在给定的样例中，棋盘中（黑色）的单元格属于船，共有一艘 $29$ 吨的船，三艘 $7$ 吨的船，二艘 $4$ 吨的船，三艘 $1$ 吨的船。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uk57lz80.png)\n\n请写一个程序，对给定的游戏局面计算出每艘船的吨位和数量。", "inputFormat": "第一行包含一个整数 $n$ 表示游戏棋盘的大小。\n\n接下来 $n$ 行，第 $i+1$ 行描述第 $i$ 行的列（船）的信息，中间用一个逗号分隔：\n- 如果是单独一个数，那么这一列属于船，这列的左、右单元格是空的；\n- 如果是 `-` 连接的两个数，表示这两列之间的所有格子（包含这两列）都属于船，则左侧和右侧是空的。\n\n数据之间用逗号分隔，每行结尾的分号。行中没有空格。如果某行只有一个分号，则这行没有船的信息。", "outputFormat": "你的程序必须输出船的信息。每行是一个空格分隔的两个整数。第一个数是船的吨位，第二个数是这个吨位的船只数量。必须以递减顺序输出船的吨位，并且至少有一艘船有此吨位。", "hint": "对于所有的数据，$1\\le n<3\\times 10^4$，船舶总数和船舶吨位都不超过 $10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2004] Ships (Day1)", "background": null, "description": "有一个由 $n\\times n$ 的正方形组成的“船”的游戏棋盘。每个单元格可能属于某艘船（黑色）或为空。如果两个边相邻的单元格都是黑色，那么这两个单元格属于同一艘船。不同船之间没有公共边。船的吨位是这些相邻的单元格数。\n\n在给定的样例中，棋盘中（黑色）的单元格属于船，共有一艘 $29$ 吨的船，三艘 $7$ 吨的船，二艘 $4$ 吨的船，三艘 $1$ 吨的船。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uk57lz80.png)\n\n请写一个程序，对给定的游戏局面计算出每艘船的吨位和数量。", "inputFormat": "第一行包含一个整数 $n$ 表示游戏棋盘的大小。\n\n接下来 $n$ 行，第 $i+1$ 行描述第 $i$ 行的列（船）的信息，中间用一个逗号分隔：\n- 如果是单独一个数，那么这一列属于船，这列的左、右单元格是空的；\n- 如果是 `-` 连接的两个数，表示这两列之间的所有格子（包含这两列）都属于船，则左侧和右侧是空的。\n\n数据之间用逗号分隔，每行结尾的分号。行中没有空格。如果某行只有一个分号，则这行没有船的信息。", "outputFormat": "你的程序必须输出船的信息。每行是一个空格分隔的两个整数。第一个数是船的吨位，第二个数是这个吨位的船只数量。必须以递减顺序输出船的吨位，并且至少有一艘船有此吨位。", "hint": "对于所有的数据，$1\\le n<3\\times 10^4$，船舶总数和船舶吨位都不超过 $10^3$。", "locale": "zh-CN"}}}
{"pid": "P5963", "type": "P", "difficulty": 3, "samples": [["6\n-8 12\n0 5\n7 -3\n10 -7\n-2 7\n1 4", "-34"], ["10\n70 70\n62 73\n81 65\n59 77\n99 40\n35 88\n80 57\n76 67\n85 57\n53 96", "-155\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心", "2005", "排序", "BalticOI（波罗的海）"], "title": "[BalticOI 2005] Card 卡牌游戏 (Day0)", "background": null, "description": "Adam 喜欢数。有一次他在他的抽屉里找到了一沓空白纸卡牌，在每张卡牌的两面写上随机的数，然后思考下面的谜题：把所有卡牌按任意顺序（必要时翻转）填入下面格式的表达式，最小的可能得到的表达式的值是多少？\n\n>`□-□+□-□+□-□+...-□`（第一个符号和最后一个符号均为 `-`）\n\n过了一会 Adam 想出了一个解法。你也能想出来吗？编写一个程序解决上面描述的谜题。", "inputFormat": "标准输入的第一行包含卡牌的数量 $N$。\n\n接下来 $N$ 行，第 $i+1$ 行两个整数 $a_i$ 和 $b_i$，分别表示写在第 $i$ 张卡牌两面的数。", "outputFormat": "标准输出仅一行，应当包含最小的可能得到的表达式的值。", "hint": "#### 样例 1 解释\n\n卡牌填入表达式的顺序：$1,2,3,5,4,6$。\n\n此时最小值为 $(-8) - 5 + (-3) - 7 + (-7) - 4 = -34$。\n\n#### 样例 2 解释\n\n卡牌填入表达式的顺序：$2,1,4,3,5,8,6,9,7,10$。\n\n此时最小值为 $62 - 70 + 59 - 81 + 40 - 76 + 35 - 85 + 57 - 96 = -155$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$2\\le N\\le 10^5$，$N$ 为偶数（原因显然），$|a_i|,|b_i|\\le 2000$。\n\n#### 说明\n\n翻译自 BalticOI 2005 Day0 Card。\n\n原官网已经丢失此题，原数据可以在[这里](https://www.acmicpc.net/problem/3373)评测。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2005] Card 卡牌游戏 (Day0)", "background": null, "description": "Adam 喜欢数。有一次他在他的抽屉里找到了一沓空白纸卡牌，在每张卡牌的两面写上随机的数，然后思考下面的谜题：把所有卡牌按任意顺序（必要时翻转）填入下面格式的表达式，最小的可能得到的表达式的值是多少？\n\n>`□-□+□-□+□-□+...-□`（第一个符号和最后一个符号均为 `-`）\n\n过了一会 Adam 想出了一个解法。你也能想出来吗？编写一个程序解决上面描述的谜题。", "inputFormat": "标准输入的第一行包含卡牌的数量 $N$。\n\n接下来 $N$ 行，第 $i+1$ 行两个整数 $a_i$ 和 $b_i$，分别表示写在第 $i$ 张卡牌两面的数。", "outputFormat": "标准输出仅一行，应当包含最小的可能得到的表达式的值。", "hint": "#### 样例 1 解释\n\n卡牌填入表达式的顺序：$1,2,3,5,4,6$。\n\n此时最小值为 $(-8) - 5 + (-3) - 7 + (-7) - 4 = -34$。\n\n#### 样例 2 解释\n\n卡牌填入表达式的顺序：$2,1,4,3,5,8,6,9,7,10$。\n\n此时最小值为 $62 - 70 + 59 - 81 + 40 - 76 + 35 - 85 + 57 - 96 = -155$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$2\\le N\\le 10^5$，$N$ 为偶数（原因显然），$|a_i|,|b_i|\\le 2000$。\n\n#### 说明\n\n翻译自 BalticOI 2005 Day0 Card。\n\n原官网已经丢失此题，原数据可以在[这里](https://www.acmicpc.net/problem/3373)评测。", "locale": "zh-CN"}}}
{"pid": "P5964", "type": "P", "difficulty": 5, "samples": [["5\nBBBAB\nBBBAB\nAAAAA\nBBABA\nBBAAB", "14\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "POI（波兰）"], "title": "[POI 2016] Park wodny", "background": "", "description": "给出一个 $n\\times n$ 的四连通的网格图，每个格子要么是 `A`，要么是 `B`，保证 `B` 的连通块的形状都是矩形。\n\n现在你最多可以把两个 `A` 变成 `B`，问最大的 `B` 的连通块有多大。", "inputFormat": "第一行包含一个正整数 $n$。\n\n接下来 $n$ 行，每行 $n$ 个字符，表示这个网格图。\n", "outputFormat": "输出一行一个整数，即最大的 `B` 的连通块的大小。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2016] Park wodny", "background": "", "description": "给出一个 $n\\times n$ 的四连通的网格图，每个格子要么是 `A`，要么是 `B`，保证 `B` 的连通块的形状都是矩形。\n\n现在你最多可以把两个 `A` 变成 `B`，问最大的 `B` 的连通块有多大。", "inputFormat": "第一行包含一个正整数 $n$。\n\n接下来 $n$ 行，每行 $n$ 个字符，表示这个网格图。\n", "outputFormat": "输出一行一个整数，即最大的 `B` 的连通块的大小。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^3$。", "locale": "zh-CN"}}}
{"pid": "P5965", "type": "P", "difficulty": 3, "samples": [["112", "50"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "PA（波兰）"], "title": "[PA 2019] A+B", "background": "", "description": "在列竖式计算两个十进制数的和的时候，人们可能会错算成这样：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g0xa2tjn.png)\n\n在图里的左边，$248+208$ 被错算成了 $4416$。\n\n给定正整数 $n$，问有多少对非负整数 $a,b$ 满足 $a+b$ 会被错算成 $n$。\n\n请注意 $a$ 可以等于 $b$，且 $a=1,b=2$ 和 $a=2,b=1$ 是两种不同的方案。", "inputFormat": "第一行包含一个正整数 $n$。", "outputFormat": "输出一个整数，即满足条件的 $a,b$ 的数量。", "hint": "对于 $100\\%$ 的数据，$1\\le n<10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] A+B", "background": "", "description": "在列竖式计算两个十进制数的和的时候，人们可能会错算成这样：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g0xa2tjn.png)\n\n在图里的左边，$248+208$ 被错算成了 $4416$。\n\n给定正整数 $n$，问有多少对非负整数 $a,b$ 满足 $a+b$ 会被错算成 $n$。\n\n请注意 $a$ 可以等于 $b$，且 $a=1,b=2$ 和 $a=2,b=1$ 是两种不同的方案。", "inputFormat": "第一行包含一个正整数 $n$。", "outputFormat": "输出一个整数，即满足条件的 $a,b$ 的数量。", "hint": "对于 $100\\%$ 的数据，$1\\le n<10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P5966", "type": "P", "difficulty": 6, "samples": [["6 7\n1 2\n2 3\n3 1\n3 4\n4 5\n5 6\n6 3", "1\n1\n1\n2\n1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "POI（波兰）"], "title": "[POI 2016] Hydrorozgrywka", "background": null, "description": "给定一个 $n$ 个点 $m$ 条边的无向连通图，保证每条边属于且只属于一个环。\n\n两个人在这张图上玩游戏，一开始他们会在某个节点放一个棋子，然后依次移动这个棋子，已经走过的边不能再走，谁不能移动谁就输了。\n\n请求出所有先手必胜的策略中游戏开始时放棋子的位置。", "inputFormat": "第一行包含两个正整数 $ n,m$，表示点数和边数。\n\n接下来 $m$ 行每行包含两个正整数 $a,b$，表示 $a$ 点到 $b$ 点之间有一条无向边。", "outputFormat": "包含 $n$ 行，对于第 $i$ 行，如果在 $i$ 点放棋子先手必胜，输出 `1`，否则输出 `2`。", "hint": "对于 $100\\%$ 的数据，$3\\le n,m\\le 5 \\times 10^5$，$1\\le a,b\\le n$，$a\\ne b$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2016] Hydrorozgrywka", "background": null, "description": "给定一个 $n$ 个点 $m$ 条边的无向连通图，保证每条边属于且只属于一个环。\n\n两个人在这张图上玩游戏，一开始他们会在某个节点放一个棋子，然后依次移动这个棋子，已经走过的边不能再走，谁不能移动谁就输了。\n\n请求出所有先手必胜的策略中游戏开始时放棋子的位置。", "inputFormat": "第一行包含两个正整数 $ n,m$，表示点数和边数。\n\n接下来 $m$ 行每行包含两个正整数 $a,b$，表示 $a$ 点到 $b$ 点之间有一条无向边。", "outputFormat": "包含 $n$ 行，对于第 $i$ 行，如果在 $i$ 点放棋子先手必胜，输出 `1`，否则输出 `2`。", "hint": "对于 $100\\%$ 的数据，$3\\le n,m\\le 5 \\times 10^5$，$1\\le a,b\\le n$，$a\\ne b$。", "locale": "zh-CN"}}}
{"pid": "P5967", "type": "P", "difficulty": 5, "samples": [["4 10\n3 7 4 3", "10\n1 3 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["搜索", "2016", "线段树", "堆", "POI（波兰）"], "title": "[POI 2016] Korale", "background": "", "description": "有 $n$ 个带标号的珠子，第 $i$ 个珠子的价值为 $a_i$。\n\n现在你可以选择若干个珠子组成项链（也可以一个都不选），项链的价值为所有珠子的价值和。\n\n给出所有可能的项链排序，先按权值从小到大排序，对于权值相同的，根据所用珠子集合的标号的字典序从小到大排序。\n\n请输出第 $k$ 小的项链的价值，以及所用的珠子集合。", "inputFormat": "第一行包含两个正整数 $n,k$。\n第二行包含 $n$ 个正整数，依次表示每个珠子的价值 $a_i$。", "outputFormat": "第一行输出第 $k$ 小的项链的价值。\n第二行按标号从小到大依次输出该项链里每个珠子的标号。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le k\\le \n\\min(2^n,10^6)$，$1\\le a_i\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2016] Korale", "background": "", "description": "有 $n$ 个带标号的珠子，第 $i$ 个珠子的价值为 $a_i$。\n\n现在你可以选择若干个珠子组成项链（也可以一个都不选），项链的价值为所有珠子的价值和。\n\n给出所有可能的项链排序，先按权值从小到大排序，对于权值相同的，根据所用珠子集合的标号的字典序从小到大排序。\n\n请输出第 $k$ 小的项链的价值，以及所用的珠子集合。", "inputFormat": "第一行包含两个正整数 $n,k$。\n第二行包含 $n$ 个正整数，依次表示每个珠子的价值 $a_i$。", "outputFormat": "第一行输出第 $k$ 小的项链的价值。\n第二行按标号从小到大依次输出该项链里每个珠子的标号。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le k\\le \n\\min(2^n,10^6)$，$1\\le a_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5968", "type": "P", "difficulty": 4, "samples": [["2\n17\n18", "6 3\n16 15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2017", "POI（波兰）"], "title": "[POI 2017] Reprezentacje ró?nicowe", "background": "", "description": "给定一个数列 $a$：\n- 当 $n\\le 2$ 时，$a_n=n$。\n- 当 $n>2$，且 $n$ 是奇数时， $a_n=2\\times a_{n-1}$。\n- 当 $n>2$，且 $n$ 是偶数时，$a_n=a_{n-1}+r_{n-1}$。\n\n其中 $r_{n-1}= \\operatorname{mex}(|a_i-a_j|)(1\\le i\\le j\\le n-1)$， $\\operatorname{mex} \\left\\{ S\\right\\}$ 表示最小的不在 $S$ 集合里面的非负整数。\n\n数列 $a$ 的前若干项依次为：\n\n$1,2,4,8,16,21,42,51,102,112,224,235,470,486,972,990,1980$。\n\n可以证明，对于任意正整数 $x$，只存在唯一一对整数 $(p,q)$ 满足 $x=a_p-a_q$，定义为 $\\operatorname{repr}(x)$。\n\n比如 $\\operatorname{repr}(17)=(6,3)$，$\\operatorname{repr}(18)=(16,15)$。\n现有 $n$ 个询问，每次给定一个正整数 $x$，请求出 $\\operatorname{repr}(x)$。", "inputFormat": "第一行包含一个正整数 $n$。\n\n接下来 $n$ 行，每行一个正整数 $x$，表示一个询问。", "outputFormat": "输出 $n$ 行，每行两个正整数 $ p,q$，依次回答每个询问。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^5$，$1\\le x\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2017] Reprezentacje ró?nicowe", "background": "", "description": "给定一个数列 $a$：\n- 当 $n\\le 2$ 时，$a_n=n$。\n- 当 $n>2$，且 $n$ 是奇数时， $a_n=2\\times a_{n-1}$。\n- 当 $n>2$，且 $n$ 是偶数时，$a_n=a_{n-1}+r_{n-1}$。\n\n其中 $r_{n-1}= \\operatorname{mex}(|a_i-a_j|)(1\\le i\\le j\\le n-1)$， $\\operatorname{mex} \\left\\{ S\\right\\}$ 表示最小的不在 $S$ 集合里面的非负整数。\n\n数列 $a$ 的前若干项依次为：\n\n$1,2,4,8,16,21,42,51,102,112,224,235,470,486,972,990,1980$。\n\n可以证明，对于任意正整数 $x$，只存在唯一一对整数 $(p,q)$ 满足 $x=a_p-a_q$，定义为 $\\operatorname{repr}(x)$。\n\n比如 $\\operatorname{repr}(17)=(6,3)$，$\\operatorname{repr}(18)=(16,15)$。\n现有 $n$ 个询问，每次给定一个正整数 $x$，请求出 $\\operatorname{repr}(x)$。", "inputFormat": "第一行包含一个正整数 $n$。\n\n接下来 $n$ 行，每行一个正整数 $x$，表示一个询问。", "outputFormat": "输出 $n$ 行，每行两个正整数 $ p,q$，依次回答每个询问。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^5$，$1\\le x\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P5969", "type": "P", "difficulty": 5, "samples": [["7\n1 2\n2 3\n4 3\n5 4\n6 3\n7 6", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "POI（波兰）"], "title": "[POI 2016] Nadajniki", "background": "", "description": "比特镇一共有 $n$ 个房子，编号依次为 $1$ 到 $n$，这些房子通过 $n-1$ 条无向道路连通在一起，形成了一棵树的结构。\n\nBytesear 要在比特镇实施 Wifi 搭建计划，他要让 Wifi 覆盖到比特镇的每一条道路。\n\nBytesear 可以安置无限多个 Wifi 发射器，但是只能安置在树上的节点上，一个房子可以安置多个 Wifi 发射器。\n\n对于一条道路 $(a,b)$，如果它满足以下两个条件之中的至少一个，那么这条边将被 Wifi 覆盖：\n- $a$ 点放置了 Wifi 发射器或者 $b$ 点放置了 Wifi 发射器。\n- 与 $a$ 点或 $b$ 点直接相邻的点中，至少放置了两个 Wifi 发射器。\n\n请帮助 Bytesear 规划一个最优的放置方案，使得 Wifi 覆盖到比特镇的每一条道路，且放置的 Wifi 发射器总数尽可能少。", "inputFormat": "第一行包含一个正整数 $n$，表示房子的总数。\n\n接下来 $n-1$ 行，每行两个正整数 $a,b$，表示 $a$ 点和 $b$ 点之间有一条边。", "outputFormat": "输出一行一个整数，即最少的 Wifi 发射器总数。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le2 \\times 10^5$，$1\\le a,b\\le n$。\n\n----\n\n### 样例解释：\n\n在 $3$ 号点放置两个 Wifi 发射器。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2016] Nadajniki", "background": "", "description": "比特镇一共有 $n$ 个房子，编号依次为 $1$ 到 $n$，这些房子通过 $n-1$ 条无向道路连通在一起，形成了一棵树的结构。\n\nBytesear 要在比特镇实施 Wifi 搭建计划，他要让 Wifi 覆盖到比特镇的每一条道路。\n\nBytesear 可以安置无限多个 Wifi 发射器，但是只能安置在树上的节点上，一个房子可以安置多个 Wifi 发射器。\n\n对于一条道路 $(a,b)$，如果它满足以下两个条件之中的至少一个，那么这条边将被 Wifi 覆盖：\n- $a$ 点放置了 Wifi 发射器或者 $b$ 点放置了 Wifi 发射器。\n- 与 $a$ 点或 $b$ 点直接相邻的点中，至少放置了两个 Wifi 发射器。\n\n请帮助 Bytesear 规划一个最优的放置方案，使得 Wifi 覆盖到比特镇的每一条道路，且放置的 Wifi 发射器总数尽可能少。", "inputFormat": "第一行包含一个正整数 $n$，表示房子的总数。\n\n接下来 $n-1$ 行，每行两个正整数 $a,b$，表示 $a$ 点和 $b$ 点之间有一条边。", "outputFormat": "输出一行一个整数，即最少的 Wifi 发射器总数。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le2 \\times 10^5$，$1\\le a,b\\le n$。\n\n----\n\n### 样例解释：\n\n在 $3$ 号点放置两个 Wifi 发射器。\n", "locale": "zh-CN"}}}
{"pid": "P5970", "type": "P", "difficulty": 5, "samples": [["5 2\n1 3 4 1 2", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "POI（波兰）"], "title": "[POI 2016] Nim z utrudnieniem", "background": "", "description": "A 和 B 两个人玩游戏，一共有 $m$ 颗石子，A 把它们分成了 $n$ 堆，每堆石子数分别为 $a_1,a_2,...,a_n$，每轮可以选择一堆石子，取掉任意颗石子，但不能不取。谁先不能操作，谁就输了。在游戏开始前，B 可以扔掉若干堆石子，但是必须保证扔掉的堆数是 $d$ 的倍数，且不能扔掉所有石子。\n\nA 先手，请问 B 有多少种扔的方式，使得 B 能够获胜。", "inputFormat": "第一行包含两个正整数 $n,d$。\n\n第二行包含 $n$ 个正整数 $a_1,a_2,...,a_n$。", "outputFormat": "输出一行一个整数，即方案数对 $10^9+7$ 取模的结果。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 5\\times 10^5$，$1\\le d\\le 10$，$1\\le a_i\\le 10^6$，$m$ 不直接给出，但数据保证 $1\\le m\\le 10^7$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2016] Nim z utrudnieniem", "background": "", "description": "A 和 B 两个人玩游戏，一共有 $m$ 颗石子，A 把它们分成了 $n$ 堆，每堆石子数分别为 $a_1,a_2,...,a_n$，每轮可以选择一堆石子，取掉任意颗石子，但不能不取。谁先不能操作，谁就输了。在游戏开始前，B 可以扔掉若干堆石子，但是必须保证扔掉的堆数是 $d$ 的倍数，且不能扔掉所有石子。\n\nA 先手，请问 B 有多少种扔的方式，使得 B 能够获胜。", "inputFormat": "第一行包含两个正整数 $n,d$。\n\n第二行包含 $n$ 个正整数 $a_1,a_2,...,a_n$。", "outputFormat": "输出一行一个整数，即方案数对 $10^9+7$ 取模的结果。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 5\\times 10^5$，$1\\le d\\le 10$，$1\\le a_i\\le 10^6$，$m$ 不直接给出，但数据保证 $1\\le m\\le 10^7$。", "locale": "zh-CN"}}}
{"pid": "P5971", "type": "P", "difficulty": 5, "samples": [["5\n1 2 1 3 3", "8"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["贪心", "2009", "CTSC/CTS"], "title": "[CTSC2009] 移盘子", "background": "", "description": "已知有三根柱子，分别记为 $A$， $B$ 和 $C$。初始状态时 $A$ 上放有 $N$ 个盘子，而 $B$ 和 $C$ 两个柱子上没有放任何盘子。你每次能做的移动操作就是把某根柱子最上面的一个盘子拿下来，然后放到另一个柱子上。盘子有三类，分别用 $1$， $2$， $3$ 来表示。你的目标是，让所有 $1$ 类盘子最终放在 $A$ 上，让所有 $2$ 类盘子最终放在 $B$ 上，所有 $3$ 类盘子最终放在 $C$ 上。现在让你求出实现上述目标总共最少需要多少次移动？", "inputFormat": "输入文件 trique.in 第一行包含一个整数 $N$，为盘子的总数。\n第二行有 $N$ 个数，每个数只能是 $1$， $2$， $3$ 之一。这 $N$ 个数表示在初始状态时第一个柱子上所有盘子的类型，按照从上往下的顺序。", "outputFormat": "输出文件 trique.out 只包含一个数，即最少的移动次数。", "hint": "### 样例说明\n初始状态如下图：\n![](https://cdn.luogu.com.cn/upload/image_hosting/caccgwlp.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/d686q4vz.png)\n\n### 数据范围\n对于 $20$%的数据， 盘子的种类不超过 $2$ 种；\n\n对于 $40$%的数据， $N \\leq 300$；\n\n对于 $100$%的数据， $N \\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2009] Moving Plates", "background": "", "description": "There are three pegs, named $A$, $B$, and $C$. Initially, $A$ has $N$ plates on it, while $B$ and $C$ are empty. Each move consists of taking the top plate from one peg and placing it onto another peg. Plates are of three types, denoted by $1$, $2$, and $3$. Your goal is to have all type $1$ plates on $A$, all type $2$ plates on $B$, and all type $3$ plates on $C$ in the end. Find the minimum number of moves needed to achieve this goal.", "inputFormat": "The input file trique.in contains:\n- The first line: an integer $N$, the total number of plates.\n- The second line: $N$ numbers, each being $1$, $2$, or $3$. These $N$ numbers describe the types of all plates initially on peg $A$, listed from top to bottom.", "outputFormat": "The output file trique.out contains a single number: the minimum number of moves.", "hint": "Sample explanation:\nInitial state as shown below:\n![](https://cdn.luogu.com.cn/upload/image_hosting/caccgwlp.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/d686q4vz.png)\n\nConstraints:\n- For $20$% of the testdata, the number of plate types does not exceed $2$.\n- For $40$% of the testdata, $N \\leq 300$.\n- For $100$% of the testdata, $N \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2009] 移盘子", "background": "", "description": "已知有三根柱子，分别记为 $A$， $B$ 和 $C$。初始状态时 $A$ 上放有 $N$ 个盘子，而 $B$ 和 $C$ 两个柱子上没有放任何盘子。你每次能做的移动操作就是把某根柱子最上面的一个盘子拿下来，然后放到另一个柱子上。盘子有三类，分别用 $1$， $2$， $3$ 来表示。你的目标是，让所有 $1$ 类盘子最终放在 $A$ 上，让所有 $2$ 类盘子最终放在 $B$ 上，所有 $3$ 类盘子最终放在 $C$ 上。现在让你求出实现上述目标总共最少需要多少次移动？", "inputFormat": "输入文件 trique.in 第一行包含一个整数 $N$，为盘子的总数。\n第二行有 $N$ 个数，每个数只能是 $1$， $2$， $3$ 之一。这 $N$ 个数表示在初始状态时第一个柱子上所有盘子的类型，按照从上往下的顺序。", "outputFormat": "输出文件 trique.out 只包含一个数，即最少的移动次数。", "hint": "### 样例说明\n初始状态如下图：\n![](https://cdn.luogu.com.cn/upload/image_hosting/caccgwlp.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/d686q4vz.png)\n\n### 数据范围\n对于 $20$%的数据， 盘子的种类不超过 $2$ 种；\n\n对于 $40$%的数据， $N \\leq 300$；\n\n对于 $100$%的数据， $N \\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P5972", "type": "P", "difficulty": 7, "samples": [["5\n5 3 1 4 2", "0 5\n0 3\n1 2\n3 1\n7 1"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2019", "O2优化", "动态规划优化", "状态合并", "均摊分析", "折半搜索 meet in the middle", "PA（波兰）", "状压 DP"], "title": "[PA 2019] Desant", "background": "", "description": "给定一个 $1$ 到 $n$ 的排列 $a_{1..n}$，它有 $2^n-1$ 个非空子序列。\n\n请对于每个 $k$，找到一个长度为 $k$ 的子序列，使得这个子序列的逆序对数量最少，并输出逆序对数量最少的子序列的数量。", "inputFormat": "第一行包含一个正整数 $n$。\n\n第二行包含 $n$ 个正整数 $a_1,a_2,...,a_n$。", "outputFormat": "输出 $n$ 行，每行两个整数，第 $k$ 行输出长度为 $k$ 的子序列中逆序对数量的最小值以及满足这个最小值的子序列数量。", "hint": "对于 $100\\%$ 的数据，$1\\le k\\le n$，$1\\le n\\le 40$，$1\\le a_i\\le n,a_i\\ne a_j$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2019] Desant", "background": "", "description": "给定一个 $1$ 到 $n$ 的排列 $a_{1..n}$，它有 $2^n-1$ 个非空子序列。\n\n请对于每个 $k$，找到一个长度为 $k$ 的子序列，使得这个子序列的逆序对数量最少，并输出逆序对数量最少的子序列的数量。", "inputFormat": "第一行包含一个正整数 $n$。\n\n第二行包含 $n$ 个正整数 $a_1,a_2,...,a_n$。", "outputFormat": "输出 $n$ 行，每行两个整数，第 $k$ 行输出长度为 $k$ 的子序列中逆序对数量的最小值以及满足这个最小值的子序列数量。", "hint": "对于 $100\\%$ 的数据，$1\\le k\\le n$，$1\\le n\\le 40$，$1\\le a_i\\le n,a_i\\ne a_j$。", "locale": "zh-CN"}}}
{"pid": "P5973", "type": "P", "difficulty": 4, "samples": [["3\n15 2\n24 4\n24 5", "TAK\nTAK\nNIE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "PA（波兰）"], "title": "[PA 2013] Iloczyn", "background": null, "description": "给定正整数 $n$ 和 $k$，问能否将 $n$ 分解为 $k$ 个不同正整数的乘积。", "inputFormat": "第一行一个数 $T$ 表示测试组数。\n\n接下来 $T$ 行每行两个数 $n,k$。", "outputFormat": "输出 $T$ 行，若可以被分解，输出 `TAK`；否则输出 `NIE`。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 4\\times 10^3$，$1\\le n\\le 10^9$，$1\\le k\\le 20$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2013] Iloczyn", "background": null, "description": "给定正整数 $n$ 和 $k$，问能否将 $n$ 分解为 $k$ 个不同正整数的乘积。", "inputFormat": "第一行一个数 $T$ 表示测试组数。\n\n接下来 $T$ 行每行两个数 $n,k$。", "outputFormat": "输出 $T$ 行，若可以被分解，输出 `TAK`；否则输出 `NIE`。", "hint": "对于 $100\\%$ 的数据，$1\\le T\\le 4\\times 10^3$，$1\\le n\\le 10^9$，$1\\le k\\le 20$。", "locale": "zh-CN"}}}
{"pid": "P5974", "type": "P", "difficulty": 6, "samples": [["10 5 \n1 8 \n2 6 \n4 8 \n2 2 \n9 7 \n8 5 \n5 3 \n3 3 \n4 6 \n4 1 ", "2.236068 \n3 4 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2006", "Special Judge", "CEOI（中欧）"], "title": "[CEOI 2006] ANTENNA", "background": "", "description": "给出 $N$ 个点的坐标，要求能够覆盖其中至少 $K$ 个点的圆的最小半径及圆心位置。", "inputFormat": "第一行两个整数 $N,K$。\n\n接下来的 $N$ 行，每行两个整数，为每个点的坐标。", "outputFormat": "第一行为圆的半径。\n\n第二行为圆心的坐标。\n\n使用 SPJ，满足以下两个条件才正确：\n\n- $R$ 误差不超过 $10^{-4}$。\n\n- 虽然多组解可以输出任意一组，但以你输出的坐标为圆心的圆如果以 $R+0.0002$为半径至少应该覆盖 $K$个点。", "hint": "对于 $100\\%$ 的数据， $2\\le K\\le N\\le 500$，$0\\le X,Y\\le 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CEOI 2006] ANTENNA", "background": "", "description": "给出 $N$ 个点的坐标，要求能够覆盖其中至少 $K$ 个点的圆的最小半径及圆心位置。", "inputFormat": "第一行两个整数 $N,K$。\n\n接下来的 $N$ 行，每行两个整数，为每个点的坐标。", "outputFormat": "第一行为圆的半径。\n\n第二行为圆心的坐标。\n\n使用 SPJ，满足以下两个条件才正确：\n\n- $R$ 误差不超过 $10^{-4}$。\n\n- 虽然多组解可以输出任意一组，但以你输出的坐标为圆心的圆如果以 $R+0.0002$为半径至少应该覆盖 $K$个点。", "hint": "对于 $100\\%$ 的数据， $2\\le K\\le N\\le 500$，$0\\le X,Y\\le 10^4$。", "locale": "zh-CN"}}}
