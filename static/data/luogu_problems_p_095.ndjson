{"pid": "P2928", "type": "P", "difficulty": 6, "samples": [["3 1 0 0 0 2 \n0 -3 0 4 \n1 2 -1 1 \n1 -2 2 -1 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09HOL] Cattle Bruisers G", "background": "", "description": "\nCanmuu is out for revenge after being utterly defeated by Bessie in paintball and has challenged Bessie to a video game.\n\nIn this game, Bessie starts out at point $(BX, BY)$ in the coordinate grid $(-1,000 \\le BX \\le 1,000; -1000 \\le BY \\le 1,000)$, and tries to escape, starting at time 0. She moves continuously at a velocity of $(BVX, BVY)$ units/second $(-100 \\le BVX \\le 100; -100 \\le BVY \\le 100)$. Thus, at time 1 she will be at point $(BX + BVX, BY + BVY)$; at time $1.5$ she will be at $(BX + 1.5 \\times BVX, BY + 1.5\\times BVY)$.\n\nUnfortunately, Canmuu has sent $N (1 \\le N \\le 50,000)$ cattle bruisers to pursue Bessie.  At time $t=0$, cattle bruiser i is at position $(X_i, Y_i) (-1,000 \\le X_i \\le 1,000; -1,000 \\le Y_i \\le 1,000)$ with velocity $(VX_i, VY_i)$ units/second $(-1,000 \\le VX_i \\le 1,000; -1,000 \\le VY_i \\le 1,000)$.\n\nEach cattle bruiser carries a 'proximity' weapon to fire at Bessie; the weapon can hurt Bessie when the cattle bruiser is no further than $R (1 \\le R \\le 2,500)$ units from her.\n\nBessie has a shield to protect herself from these attacks. However, she does not want to waste any of her shield's power, so she would like to know the maximum number of cattle bruisers within firing range for any (potentially non-integer) time.\n\nIn order to avoid precision errors with real numbers, it is guaranteed that the answer produced will be the same whether the attack range is decreased to $R-0.0001$ or increased to $R+0.0001$.\n\nFEEDBACK: Your first $50$  submissions for this problem will be run on some of the official test data, and you will receive a summary of the results.\n\n自从卡门在弹珠游戏中被贝茜彻底击败，他一直在想找机会复仇。这会儿，他邀贝茜去玩一个电脑游戏。\n\n游戏中，贝茜在（$B_X,B_Y$）处开始行动，这时时刻为 $0$。她要试图逃离。她的速度为 ($BV_X，BV_Y$) 每秒。\n\n不幸的是，卡门为了复仇，放出 $N (1\\le N\\le 50000)$ 个杀手追击贝茜。\n\n在 $t = 0$ 时，杀手 $i$ 的位置是 $X_i$, $Y_i$ 他的速度是 $Vx_i,Vy_i$ 每秒。\n\n由于每个杀手配备了手枪，手枪的射程是 $R$，也就是说贝茜要与这个杀手的距离需要保持超过 $R$，否则有性命之虞。\n\n然而，贝茜还有一件秘密武器，盾。但是，她不想过多地消耗盾的能量。所以，她想知道在逃脱过程中，某一个时刻她在最多为多少个杀手的射程内。当然这个时刻不一定是整数。\n\n为了防止出现精度误差，数据保证在 $r+10^{-4}\\le R\\le r+10^{-4}$ 时也能得出正确结果。", "inputFormat": "\\* Line $1$: Six space-separated integers: $N$, $R$, $BX$, $BY$, $BVX$, and $BVY$.\n\n\\* Lines $2$ ~ $N+1$: Line i+1 contains four space-separated integers: $X_i$, $Y_i$, $VX_i$, and $VY_i$.\n\n第一行：六个整数：$N,R,B_X,B_Y,BV_X,BV_Y$.\n\n后 $n$ 行每行包含四个整数：$X_i,Y_i,Vx_i,Vy_i$.", "outputFormat": "\\* Line $1$: Print a single integer denoting the maximum number of cattle bruisers within attack range at any point in time.\n\n\n输出一个整数，表示在任意时刻攻击范围内最多可存在的杀手数量。", "hint": "\nBessie starts at point $(0, 0)$ and is moving at $2$ units per second in the (positive) y-direction. There are $3$ cattle bruisers, the first of which starts at point $(0, -3)$ and travels $4$ units per second in the y-direction. The maximum distance for a cattle bruiser to be in range of Bessie is $1$ unit.\n\nAt time $1.5$, Bessie is at point $(0, 3)$, and the three bruisers are at points $(0, 3)$, $(-0.5, 3.5)$, and $(4, -3.5)$. The first two cattle bruisers are within $1$ unit of Bessie, while the third will never be within $1$ unit of Bessie, so $2$ is the most achievable.\n\n样例解释：\n\n贝茜从点 $(0, 0)$ 出发，以每秒 $2$ 个单位的速度沿 y 轴正方向移动。有 $3$ 个杀手，其中第一个从点 $(0, -3)$ 出发，以每秒 $4$ 个单位的速度沿 y 轴移动。杀手与贝茜的最远有效距离为 $1$ 个单位。\n\n在时刻 $1.5$，贝茜位于点 $(0, 3)$，而三个杀手分别位于点 $(0, 3),(-0.5, 3.5)$ 和 $(4, -3.5)$。前两个杀手与贝茜的距离均不超过 $1$ 单位，但第三个杀手永远无法进入贝茜 $1$ 单位范围内，因此最多可存在的杀手数量为 $2$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09HOL] Cattle Bruisers G", "background": "", "description": "Canmuu is out for revenge after being utterly defeated by Bessie in paintball and has challenged Bessie to a video game.\n\nIn this game, Bessie starts at point $(BX, BY)$ in the coordinate grid ($-1{,}000 \\le BX \\le 1{,}000$; $-1{,}000 \\le BY \\le 1{,}000$) at time $0$. She moves continuously with velocity $(BVX, BVY)$ units per second ($-100 \\le BVX \\le 100$; $-100 \\le BVY \\le 100$). Thus, at time $1$ she will be at point $(BX + BVX, BY + BVY)$; at time $1.5$ she will be at $(BX + 1.5 \\times BVX, BY + 1.5 \\times BVY)$.\n\nUnfortunately, Canmuu has sent $N$ ($1 \\le N \\le 50{,}000$) cattle bruisers to pursue Bessie. At time $t = 0$, cattle bruiser $i$ is at position $(X_i, Y_i)$ ($-1{,}000 \\le X_i \\le 1{,}000$; $-1{,}000 \\le Y_i \\le 1{,}000$) with velocity $(VX_i, VY_i)$ units per second ($-1{,}000 \\le VX_i \\le 1{,}000$; $-1{,}000 \\le VY_i \\le 1{,}000$).\n\nEach cattle bruiser carries a \"proximity\" weapon that can hurt Bessie when the cattle bruiser is no farther than $R$ ($1 \\le R \\le 2{,}500$) units from her.\n\nBessie has a shield to protect herself from these attacks. However, she does not want to waste any of her shield’s power, so she would like to know the maximum number of cattle bruisers within firing range at any (possibly non-integer) time.\n\nTo avoid precision errors with real numbers, it is guaranteed that the answer remains the same whether the attack range is decreased to $R - 10^{-4}$ or increased to $R + 10^{-4}$.", "inputFormat": "- Line $1$: Six space-separated integers: $N$, $R$, $BX$, $BY$, $BVX$, $BVY$.\n- Lines $2$ to $N + 1$: Line $i + 1$ contains four space-separated integers: $X_i$, $Y_i$, $VX_i$, $VY_i$.", "outputFormat": "- Line $1$: Print a single integer denoting the maximum number of cattle bruisers within attack range at any point in time.", "hint": "Bessie starts at point $(0, 0)$ and is moving at $2$ units per second in the positive y-direction. There are $3$ cattle bruisers; the first starts at point $(0, -3)$ and travels $4$ units per second in the y-direction. The maximum distance for a cattle bruiser to be in range of Bessie is $1$ unit.\n\nAt time $1.5$, Bessie is at point $(0, 3)$, and the three bruisers are at points $(0, 3)$, $(-0.5, 3.5)$, and $(4, -3.5)$. The first two cattle bruisers are within $1$ unit of Bessie, while the third will never be within $1$ unit of Bessie, so the maximum achievable number is $2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09HOL] Cattle Bruisers G", "background": "", "description": "\nCanmuu is out for revenge after being utterly defeated by Bessie in paintball and has challenged Bessie to a video game.\n\nIn this game, Bessie starts out at point $(BX, BY)$ in the coordinate grid $(-1,000 \\le BX \\le 1,000; -1000 \\le BY \\le 1,000)$, and tries to escape, starting at time 0. She moves continuously at a velocity of $(BVX, BVY)$ units/second $(-100 \\le BVX \\le 100; -100 \\le BVY \\le 100)$. Thus, at time 1 she will be at point $(BX + BVX, BY + BVY)$; at time $1.5$ she will be at $(BX + 1.5 \\times BVX, BY + 1.5\\times BVY)$.\n\nUnfortunately, Canmuu has sent $N (1 \\le N \\le 50,000)$ cattle bruisers to pursue Bessie.  At time $t=0$, cattle bruiser i is at position $(X_i, Y_i) (-1,000 \\le X_i \\le 1,000; -1,000 \\le Y_i \\le 1,000)$ with velocity $(VX_i, VY_i)$ units/second $(-1,000 \\le VX_i \\le 1,000; -1,000 \\le VY_i \\le 1,000)$.\n\nEach cattle bruiser carries a 'proximity' weapon to fire at Bessie; the weapon can hurt Bessie when the cattle bruiser is no further than $R (1 \\le R \\le 2,500)$ units from her.\n\nBessie has a shield to protect herself from these attacks. However, she does not want to waste any of her shield's power, so she would like to know the maximum number of cattle bruisers within firing range for any (potentially non-integer) time.\n\nIn order to avoid precision errors with real numbers, it is guaranteed that the answer produced will be the same whether the attack range is decreased to $R-0.0001$ or increased to $R+0.0001$.\n\nFEEDBACK: Your first $50$  submissions for this problem will be run on some of the official test data, and you will receive a summary of the results.\n\n自从卡门在弹珠游戏中被贝茜彻底击败，他一直在想找机会复仇。这会儿，他邀贝茜去玩一个电脑游戏。\n\n游戏中，贝茜在（$B_X,B_Y$）处开始行动，这时时刻为 $0$。她要试图逃离。她的速度为 ($BV_X，BV_Y$) 每秒。\n\n不幸的是，卡门为了复仇，放出 $N (1\\le N\\le 50000)$ 个杀手追击贝茜。\n\n在 $t = 0$ 时，杀手 $i$ 的位置是 $X_i$, $Y_i$ 他的速度是 $Vx_i,Vy_i$ 每秒。\n\n由于每个杀手配备了手枪，手枪的射程是 $R$，也就是说贝茜要与这个杀手的距离需要保持超过 $R$，否则有性命之虞。\n\n然而，贝茜还有一件秘密武器，盾。但是，她不想过多地消耗盾的能量。所以，她想知道在逃脱过程中，某一个时刻她在最多为多少个杀手的射程内。当然这个时刻不一定是整数。\n\n为了防止出现精度误差，数据保证在 $r+10^{-4}\\le R\\le r+10^{-4}$ 时也能得出正确结果。", "inputFormat": "\\* Line $1$: Six space-separated integers: $N$, $R$, $BX$, $BY$, $BVX$, and $BVY$.\n\n\\* Lines $2$ ~ $N+1$: Line i+1 contains four space-separated integers: $X_i$, $Y_i$, $VX_i$, and $VY_i$.\n\n第一行：六个整数：$N,R,B_X,B_Y,BV_X,BV_Y$.\n\n后 $n$ 行每行包含四个整数：$X_i,Y_i,Vx_i,Vy_i$.", "outputFormat": "\\* Line $1$: Print a single integer denoting the maximum number of cattle bruisers within attack range at any point in time.\n\n\n输出一个整数，表示在任意时刻攻击范围内最多可存在的杀手数量。", "hint": "\nBessie starts at point $(0, 0)$ and is moving at $2$ units per second in the (positive) y-direction. There are $3$ cattle bruisers, the first of which starts at point $(0, -3)$ and travels $4$ units per second in the y-direction. The maximum distance for a cattle bruiser to be in range of Bessie is $1$ unit.\n\nAt time $1.5$, Bessie is at point $(0, 3)$, and the three bruisers are at points $(0, 3)$, $(-0.5, 3.5)$, and $(4, -3.5)$. The first two cattle bruisers are within $1$ unit of Bessie, while the third will never be within $1$ unit of Bessie, so $2$ is the most achievable.\n\n样例解释：\n\n贝茜从点 $(0, 0)$ 出发，以每秒 $2$ 个单位的速度沿 y 轴正方向移动。有 $3$ 个杀手，其中第一个从点 $(0, -3)$ 出发，以每秒 $4$ 个单位的速度沿 y 轴移动。杀手与贝茜的最远有效距离为 $1$ 个单位。\n\n在时刻 $1.5$，贝茜位于点 $(0, 3)$，而三个杀手分别位于点 $(0, 3),(-0.5, 3.5)$ 和 $(4, -3.5)$。前两个杀手与贝茜的距离均不超过 $1$ 单位，但第三个杀手永远无法进入贝茜 $1$ 单位范围内，因此最多可存在的杀手数量为 $2$。", "locale": "zh-CN"}}}
{"pid": "P2929", "type": "P", "difficulty": 5, "samples": [["4 1 3 \n0110 \n", "4 \n1001 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09HOL] Transmission Delay G", "background": "", "description": "Farmer John has taken to yodeling from the top of the barn in order to communicate with the cows out in the pastures. Being bovine and all, cows can hear binary messages (0's and 1's) but have trouble with perfect communications because FJ's yodeling echoes off the silo. In fact, in a sequence of N (1 <= N <= 2,000) bits, Bessie will always receive a sequence of N bits, with the same number of 0s and 1s, but each 0 or 1 might be delayed.\n\nPrecisely speaking, for a given number D (0 <= D < N), the i-th bit might be heard as the j-th one as long as |i - j| <= D (in other words, no bit appears in a position farther than distance D from its original position). \nConsider the following message as an example: 0110. Four possible messages might be heard if D = 1: 0101, 0110, 1001, and 1010.\n\nGiven the message to be yodeled by FJ, along with two numbers D and K (1 <= K <= 100,000,000), determine the number of different messages that might be heard by Bessie, modulo 100,000,000. Also determine the K-th smallest such message in lexicographical order (in binary representation, with 0 coming before 1). It is guaranteed that K will be no larger than the number of different possible messages.\n\nMEMORY LIMIT: 32 MB\n\nTIME LIMIT: 2 seconds\n\nFEEDBACK: Your first 50 submissions for this problem will be run on some of the official test data, and you will receive a summary of the results.\n\n约翰在屋顶上唱歌，以此来与奶牛们交流。但是奶牛们的听力很奇怪，她们只能听到约翰的歌声变成 $0$ 和 $1$ 构成的信息串时的样子。约翰的声音里有 $N  (1 \\leq N \\leq 2000)$ 个 $0$ 或 $1$，奶牛听到的也是 $N$ 个，而且 $0$ 和 $1$ 的数量不会变化，但是一部分 $0$ 或 $1$ 可能偏离原来的位置，这就是约翰的歌声在传输时发生的“传输延迟”现象。$0$ 或 $1$ 的偏离距离不会超过 $D(O \\leq D < N)$，也就是说某一个码的原本位置和现在的位置之差的绝对值不大于 $D$。\n\n比如，对于 `0110`，$D = 1$，传输延迟发生后可能出现 `0101`，`0110`，`1001`，`1010` 这四种串．\n\n给出约翰歌声的 $01$ 串形式和一个整数 $K(1 \\leq K \\leq10^8)$，请计算传输延迟发生后一共有多少种可能的 $01$ 串，以及其中第 $K$ 大的串是什么。", "inputFormat": "\\* Line 1: Three space-separated integers: N, D, and K\n\n\\* Line 2: FJ's binary message, containing exactly N bits\n", "outputFormat": "\\* Line 1: The number of different possible messages that can heard by Bessie, mod 100,000,000\n\n\\* Line 2: The K-th smallest such message (in binary representation)\n\nNote that if your program's first line of output is correct but the second line of output is either missing or wrong, you will receive 40% of the points for that test case.\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09HOL] Transmission Delay G", "background": "", "description": "Farmer John has taken to yodeling from the top of the barn in order to communicate with the cows out in the pastures. Being bovine and all, cows can hear binary messages (0's and 1's) but have trouble with perfect communications because FJ's yodeling echoes off the silo. In fact, in a sequence of N (1 <= N <= 2,000) bits, Bessie will always receive a sequence of N bits, with the same number of 0s and 1s, but each 0 or 1 might be delayed.\n\nPrecisely speaking, for a given number D (0 <= D < N), the i-th bit might be heard as the j-th one as long as |i - j| <= D (in other words, no bit appears in a position farther than distance D from its original position). Consider the following message as an example: 0110. Four possible messages might be heard if D = 1: 0101, 0110, 1001, and 1010.\n\nGiven the message to be yodeled by FJ, along with two numbers D and K (1 <= K <= 100,000,000), determine the number of different messages that might be heard by Bessie, modulo 100,000,000. Also determine the K-th smallest such message in lexicographical order (in binary representation, with 0 coming before 1). It is guaranteed that K will be no larger than the number of different possible messages.\n\nMEMORY LIMIT: 32 MB.\n\nTIME LIMIT: 2 seconds.\n\nFEEDBACK: Your first 50 submissions for this problem will be run on some of the official testdata, and you will receive a summary of the results.\n\nFarmer John sings from the rooftop to communicate with the cows. The cows can only hear the message when it is represented as a string of $0$ and $1$. There are $N  (1 \\leq N \\leq 2000)$ bits in Farmer John's voice, and the cows will also hear $N$ bits, with the counts of $0$ and $1$ unchanged, but some bits may shift from their original positions due to “transmission delay.” The shift distance will not exceed $D(O \\leq D < N)$, meaning the absolute difference between a bit’s original position and its received position is at most $D$.\n\nFor example, for `0110` with $D = 1$, the possible received strings are `0101`, `0110`, `1001`, and `1010`.\n\nGiven the $01$-string of Farmer John’s message and an integer $K(1 \\leq K \\leq10^8)$, compute the total number of possible $01$ strings after transmission delay, and find the K-th smallest string in lexicographical order.", "inputFormat": "- Line 1: Three space-separated integers: N, D, and K.\n- Line 2: FJ's binary message, containing exactly N bits.", "outputFormat": "- Line 1: The number of different possible messages that can be heard by Bessie, modulo 100,000,000.\n- Line 2: The K-th smallest such message (in binary representation).\n\nNote that if your program's first line of output is correct but the second line of output is either missing or wrong, you will receive 40% of the points for that test case.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09HOL] Transmission Delay G", "background": "", "description": "Farmer John has taken to yodeling from the top of the barn in order to communicate with the cows out in the pastures. Being bovine and all, cows can hear binary messages (0's and 1's) but have trouble with perfect communications because FJ's yodeling echoes off the silo. In fact, in a sequence of N (1 <= N <= 2,000) bits, Bessie will always receive a sequence of N bits, with the same number of 0s and 1s, but each 0 or 1 might be delayed.\n\nPrecisely speaking, for a given number D (0 <= D < N), the i-th bit might be heard as the j-th one as long as |i - j| <= D (in other words, no bit appears in a position farther than distance D from its original position). \nConsider the following message as an example: 0110. Four possible messages might be heard if D = 1: 0101, 0110, 1001, and 1010.\n\nGiven the message to be yodeled by FJ, along with two numbers D and K (1 <= K <= 100,000,000), determine the number of different messages that might be heard by Bessie, modulo 100,000,000. Also determine the K-th smallest such message in lexicographical order (in binary representation, with 0 coming before 1). It is guaranteed that K will be no larger than the number of different possible messages.\n\nMEMORY LIMIT: 32 MB\n\nTIME LIMIT: 2 seconds\n\nFEEDBACK: Your first 50 submissions for this problem will be run on some of the official test data, and you will receive a summary of the results.\n\n约翰在屋顶上唱歌，以此来与奶牛们交流。但是奶牛们的听力很奇怪，她们只能听到约翰的歌声变成 $0$ 和 $1$ 构成的信息串时的样子。约翰的声音里有 $N  (1 \\leq N \\leq 2000)$ 个 $0$ 或 $1$，奶牛听到的也是 $N$ 个，而且 $0$ 和 $1$ 的数量不会变化，但是一部分 $0$ 或 $1$ 可能偏离原来的位置，这就是约翰的歌声在传输时发生的“传输延迟”现象。$0$ 或 $1$ 的偏离距离不会超过 $D(O \\leq D < N)$，也就是说某一个码的原本位置和现在的位置之差的绝对值不大于 $D$。\n\n比如，对于 `0110`，$D = 1$，传输延迟发生后可能出现 `0101`，`0110`，`1001`，`1010` 这四种串．\n\n给出约翰歌声的 $01$ 串形式和一个整数 $K(1 \\leq K \\leq10^8)$，请计算传输延迟发生后一共有多少种可能的 $01$ 串，以及其中第 $K$ 大的串是什么。", "inputFormat": "\\* Line 1: Three space-separated integers: N, D, and K\n\n\\* Line 2: FJ's binary message, containing exactly N bits\n", "outputFormat": "\\* Line 1: The number of different possible messages that can heard by Bessie, mod 100,000,000\n\n\\* Line 2: The K-th smallest such message (in binary representation)\n\nNote that if your program's first line of output is correct but the second line of output is either missing or wrong, you will receive 40% of the points for that test case.\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2930", "type": "P", "difficulty": 6, "samples": [["17 15 10 \n111111101111111 \n111111000111111 \n111110000011111 \n111100000001111 \n111000000000111 \n111100000001111 \n111000000000111 \n110000000000011 \n111000000000111 \n110000000000011 \n100000000000001 \n110000000000011 \n100000000000001 \n000000000000000 \n111111000111111 \n111111000111111 \n111111000111111 \n5 8 2 14 1 \n8 17 3 7 1 \n4 5 10 15 0 \n7 16 12 14 1 \n2 17 13 14 0 \n2 6 2 3 1 \n13 14 4 8 1 \n3 6 6 7 1 \n1 16 10 11 0 \n7 16 10 10 0 \n", "113 \n94 \n95 \n91 \n87 \n93 \n91 \n87 \n93 \n93 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "线段树", "USACO", "颜色段均摊（珂朵莉树 ODT）"], "title": "[USACO09HOL] Holiday Painting G", "background": null, "description": "为了表达假日的激情，奶牛们要画一幅巨大的画。\n\n画布可以分成 $R\\times C$ 个方格，从上到下编为 $1$ 到 $R$ 行，从左到右编为 $1$ 到 $C$ 列。作画的颜色有两种，白色（用 $0$ 表示）或者黑色（用 $1$ 表示）。\n\n由于时间紧迫，奶牛们不得不请教北面的邻居，卡门。卡门送给它们一台机器，一次操作只输入 $5$ 个参数 $R1_i,R2_i,C1_i,C2_i,X_i$（$1 \\le R1_i \\le R2_i \\le R$，$1 \\le C1_i \\le C2_i \\le C$，$0 \\le X_i \\le 1$），表示把 $R1_i$ 行到 $R2_i$ 行，$C1_i$ 列到 $C2_i$ 列的一个大长方形涂成 $X_i$ 色。在所有操作还未进行的时候，画布是白色的。\n\n奶牛们一共要进行 $Q$ 次操作。\n\n因为这样的画法总要出些差错，所以奶牛们想请你算算，每一次操作过后，一共有多少个方格与它们的目标画里对应的方格是同色的。", "inputFormat": "第一行包括三个整数 $R,C,Q$。\n\n第二行至第 $R+1$ 行：第 $i+1$ 行包含 $C$ 个字符，每个字符均为 $0$ 或 $1$，表示网格的第 $i$ 行。\n\n第 $R+2$ 行至第 $R+Q+1$ 行：第 $R+i+1$ 行包含五个整数，表示一次涂色操作：$R1_i,R2_i,C1_i,C2_i,X_i$。", "outputFormat": "对于每次操作，输出一行一个整数，表示此次操作后匹配的方格数量。", "hint": "### 样例解释\n\n奶牛们想要画一幅节日树的图画。\n\n第一次操作后，图像网格如下所示：\n\n```markdown\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n011111111111110\n011111111111110\n011111111111110\n011111111111110\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n```\n\n有 $113$ 个方格与树形图像中的对应方格相匹配，它们以下方的```x```标记表示（其他部分则按首次涂色后的实际形态展示）：\n```markdown\n0000000x0000000\n000000xxx000000\n00000xxxxx00000\n0000xxxxxxx0000\n0xx111111111xx0\n0xxx1111111xxx0\n0xx111111111xx0\n0x11111111111x0\n000xxxxxxxxx000\n00xxxxxxxxxxx00\n0xxxxxxxxxxxxx0\n00xxxxxxxxxxx00\n0xxxxxxxxxxxxx0\nxxxxxxxxxxxxxxx\n000000xxx000000\n000000xxx000000\n000000xxx000000\n```\n\n### 数据范围\n\n对于所有数据：\n\n$1\\le Q\\le 10^4$，$1\\le R\\le 5\\times10^4$，$1\\le C\\le 15$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09HOL] Holiday Painting G", "background": "", "description": "The cows want to paint a large picture on an $R \\times C$ grid ($1 \\le R \\le 50{,}000$, $1 \\le C \\le 15$). Each cell holds a bit, either 0 or 1. Rows are numbered $1..R$, and columns are numbered $1..C$. The initial picture is all 0s.\n\nThey will perform $Q$ operations ($1 \\le Q \\le 10{,}000$). Each operation takes five parameters $R1_i,R2_i,C1_i,C2_i,X_i$ $(1 \\le R1_i \\le R2_i \\le R; 1 \\le C1_i \\le C2_i \\le C; 0 \\le X_i \\le 1)$, and paints every cell in rows $R1_i$ to $R2_i$ and columns $C1_i$ to $C2_i$ to color $X_i$.\n\nA target image is given as an $R \\times C$ grid of '0'/'1' characters. After each operation, output how many cells in the current painted grid match the corresponding cells in the target image.\n\nMemory limit: 64 MB. Time limit: 1.5 seconds.", "inputFormat": "- Line 1: Three space-separated integers: $R$, $C$, and $Q$.\n- Lines 2..$R+1$: Line $i+1$ contains $C$ characters, each '0' or '1', denoting the $i$-th row of the target grid.\n- Lines $R+2..R+Q+1$: Line $R+i+1$ contains five space-separated integers representing a paint operation: $R1_i$, $R2_i$, $C1_i$, $C2_i$, and $X_i$.", "outputFormat": "- Lines 1..$Q$: On line $i$, print a single integer representing the number of matching unit squares after the $i$-th operation.", "hint": "The cows want to paint a picture of a holiday tree.\n\nAfter the first operation, the picture grid looks as follows:\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\n011111111111110\n\n011111111111110\n\n011111111111110\n\n011111111111110\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\n000000000000000\n\nThere are 113 unit squares which match the corresponding square in the tree image; they are denoted below by an 'x' (the other bits are shown as they appear after the first paint splash):\n\n0000000x0000000\n\n000000xxx000000\n\n00000xxxxx00000\n\n0000xxxxxxx0000\n\n0xx111111111xx0\n\n0xxx1111111xxx0\n\n0xx111111111xx0\n\n0x11111111111x0\n\n000xxxxxxxxx000\n\n00xxxxxxxxxxx00\n\n0xxxxxxxxxxxxx0\n\n00xxxxxxxxxxx00\n\n0xxxxxxxxxxxxx0\n\nxxxxxxxxxxxxxxx\n\n000000xxx000000\n\n000000xxx000000\n\n000000xxx000000.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09HOL] Holiday Painting G", "background": null, "description": "为了表达假日的激情，奶牛们要画一幅巨大的画。\n\n画布可以分成 $R\\times C$ 个方格，从上到下编为 $1$ 到 $R$ 行，从左到右编为 $1$ 到 $C$ 列。作画的颜色有两种，白色（用 $0$ 表示）或者黑色（用 $1$ 表示）。\n\n由于时间紧迫，奶牛们不得不请教北面的邻居，卡门。卡门送给它们一台机器，一次操作只输入 $5$ 个参数 $R1_i,R2_i,C1_i,C2_i,X_i$（$1 \\le R1_i \\le R2_i \\le R$，$1 \\le C1_i \\le C2_i \\le C$，$0 \\le X_i \\le 1$），表示把 $R1_i$ 行到 $R2_i$ 行，$C1_i$ 列到 $C2_i$ 列的一个大长方形涂成 $X_i$ 色。在所有操作还未进行的时候，画布是白色的。\n\n奶牛们一共要进行 $Q$ 次操作。\n\n因为这样的画法总要出些差错，所以奶牛们想请你算算，每一次操作过后，一共有多少个方格与它们的目标画里对应的方格是同色的。", "inputFormat": "第一行包括三个整数 $R,C,Q$。\n\n第二行至第 $R+1$ 行：第 $i+1$ 行包含 $C$ 个字符，每个字符均为 $0$ 或 $1$，表示网格的第 $i$ 行。\n\n第 $R+2$ 行至第 $R+Q+1$ 行：第 $R+i+1$ 行包含五个整数，表示一次涂色操作：$R1_i,R2_i,C1_i,C2_i,X_i$。", "outputFormat": "对于每次操作，输出一行一个整数，表示此次操作后匹配的方格数量。", "hint": "### 样例解释\n\n奶牛们想要画一幅节日树的图画。\n\n第一次操作后，图像网格如下所示：\n\n```markdown\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n011111111111110\n011111111111110\n011111111111110\n011111111111110\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n000000000000000\n```\n\n有 $113$ 个方格与树形图像中的对应方格相匹配，它们以下方的```x```标记表示（其他部分则按首次涂色后的实际形态展示）：\n```markdown\n0000000x0000000\n000000xxx000000\n00000xxxxx00000\n0000xxxxxxx0000\n0xx111111111xx0\n0xxx1111111xxx0\n0xx111111111xx0\n0x11111111111x0\n000xxxxxxxxx000\n00xxxxxxxxxxx00\n0xxxxxxxxxxxxx0\n00xxxxxxxxxxx00\n0xxxxxxxxxxxxx0\nxxxxxxxxxxxxxxx\n000000xxx000000\n000000xxx000000\n000000xxx000000\n```\n\n### 数据范围\n\n对于所有数据：\n\n$1\\le Q\\le 10^4$，$1\\le R\\le 5\\times10^4$，$1\\le C\\le 15$。", "locale": "zh-CN"}}}
{"pid": "P2931", "type": "P", "difficulty": 0, "samples": [["0 6 \n", "#FILE perlbrac 0 \n6 \n0 \n1 \n0 \n2 \n1 \n0 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2009", "线段树", "USACO", "树状数组", "Special Judge"], "title": "[USACO09HOL] Pearl Bracelet G【征集 SPJ】", "background": "", "description": "Bessie received a magic bracelet of a set of the rarest black pearls for her favorite holiday. Bessie loved the bracelet and marveled that each pearl contained a small number engraved on it. She noticed that if you align the the bracelet's pearls in all the possible ways by bending it around some point (see below), the 'progressive' sums of the pearls' numbers that have corresponding numbers on the top and bottom sides of the bracelet never, everatch when compared using mod M (2 <= M <= 100). 'Progressive' sums are exemplified below.\n\nSuppose the mod M is 3. Consider a bracelet with N=6 pearls, etched sequentially with the numbers 0, 1, 0, 2, 1, 0. We'll illustrate this bracelet with its clasps like this:\n\n>0-1-0-2-1-0< \nThe six-pearl bracelet can be laid out on the ground in five different ways so that some pearls 'correspond' to each other (see below). We can 'progressively' sum-mod-M those pearls that correspond on the top and also sum-mod-M the corresponding pearls on the bottom, as shown with ONE-sums, TWO-sums, THREE-sums (and so on when N > 6).\n\n```cpp\n               |     THREE-sums         |     TWO-sums      | ONE-sums\n --------------+------------------------+-------------------+--------- \n    >0-1-0-2-1 |                        |                   | => 1 |\n               |                        |                   | \n            >0 |                        |                   | => 0 \n --------------+------------------------+-------------------+--------- \n      >0-1-0-2 |                        | => 0+2 = 2        | => 2 | \n               |                        |                   | \n          >0-1 |                        | => 0+1 = 1        | => 1 \n --------------+------------------------+-------------------+--------- \n        >0-1-0 | => 0+1+0 = 1           | => 1+0 = 1        | => 0 | \n               |                        |                   | \n        >0-1-2 | => 0+1+2 = 3 mod 3 = 0 | => 1+2 mod 3 = 0  | => 2 \n --------------+------------------------+-------------------+--------- \n          >0-1 |                        | => 0+1 = 1        | => 1 | \n               |                        |                   | \n      >0-1-2-0 |                        | => 2+0 = 2        | => 0 \n --------------+------------------------+-------------------+--------- \n            >0 |                        |                   | => 0 | \n               |                        |                   | \n    >0-1-2-0-1 |                        |                   | => 1 \n```\n\n\n\nBessie notes that all the pairs of sums contain different numbers and has heard this is true for all the magic bracelets. Bessie wondered what is longest possible bracelet that has this unique-sum property.\n\nGiven M, find a really long (but no longer than 20,000) set of numbers can be etched on the black pearls to maintain this unique sum property for a bracelet.\n\nThis is an output-only problem, the 15 input files can be downloaded at: http://ace.delos.com/perlbrac.zip\n\nSCORING: Scoring for this problem will be relative; your integer score (out of 10) for each test case will be int (10 \\* sqrt (YOURS / BEST)), where YOURS is the length of your solution, and BEST is the length of the best solution among all contestants.\n\nFEEDBACK: When you submit a file for grading, it will be checked for both correct format and validity (i.e., whether it satisfies the required numerical properties), and you will be informed of the results.\n", "inputFormat": "\\* Line 1: Two space-separated integers: the case number and M\n", "outputFormat": "\\* Line 1: A single line containing the task name and case number: #FILE perlbrac CASENUM\n\n\\* Line 2: A single line with a single integer, N (which must be no larger than 20,000)\n\n\\* Lines 3..N+1: Line i+2 contains a single integer that is the integer etched onto the i-th pearl on the bracelet; this number should be between 0 and M - 1, inclusive\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO09HOL] Pearl Bracelet G【征集 SPJ】", "background": "", "description": "Bessie received a magic bracelet of a set of the rarest black pearls for her favorite holiday. Bessie loved the bracelet and marveled that each pearl contained a small number engraved on it. She noticed that if you align the the bracelet's pearls in all the possible ways by bending it around some point (see below), the 'progressive' sums of the pearls' numbers that have corresponding numbers on the top and bottom sides of the bracelet never, everatch when compared using mod M (2 <= M <= 100). 'Progressive' sums are exemplified below.\n\nSuppose the mod M is 3. Consider a bracelet with N=6 pearls, etched sequentially with the numbers 0, 1, 0, 2, 1, 0. We'll illustrate this bracelet with its clasps like this:\n\n>0-1-0-2-1-0< \nThe six-pearl bracelet can be laid out on the ground in five different ways so that some pearls 'correspond' to each other (see below). We can 'progressively' sum-mod-M those pearls that correspond on the top and also sum-mod-M the corresponding pearls on the bottom, as shown with ONE-sums, TWO-sums, THREE-sums (and so on when N > 6).\n\n```cpp\n               |     THREE-sums         |     TWO-sums      | ONE-sums\n --------------+------------------------+-------------------+--------- \n    >0-1-0-2-1 |                        |                   | => 1 |\n               |                        |                   | \n            >0 |                        |                   | => 0 \n --------------+------------------------+-------------------+--------- \n      >0-1-0-2 |                        | => 0+2 = 2        | => 2 | \n               |                        |                   | \n          >0-1 |                        | => 0+1 = 1        | => 1 \n --------------+------------------------+-------------------+--------- \n        >0-1-0 | => 0+1+0 = 1           | => 1+0 = 1        | => 0 | \n               |                        |                   | \n        >0-1-2 | => 0+1+2 = 3 mod 3 = 0 | => 1+2 mod 3 = 0  | => 2 \n --------------+------------------------+-------------------+--------- \n          >0-1 |                        | => 0+1 = 1        | => 1 | \n               |                        |                   | \n      >0-1-2-0 |                        | => 2+0 = 2        | => 0 \n --------------+------------------------+-------------------+--------- \n            >0 |                        |                   | => 0 | \n               |                        |                   | \n    >0-1-2-0-1 |                        |                   | => 1 \n```\n\n\n\nBessie notes that all the pairs of sums contain different numbers and has heard this is true for all the magic bracelets. Bessie wondered what is longest possible bracelet that has this unique-sum property.\n\nGiven M, find a really long (but no longer than 20,000) set of numbers can be etched on the black pearls to maintain this unique sum property for a bracelet.\n\nThis is an output-only problem, the 15 input files can be downloaded at: http://ace.delos.com/perlbrac.zip\n\nSCORING: Scoring for this problem will be relative; your integer score (out of 10) for each test case will be int (10 \\* sqrt (YOURS / BEST)), where YOURS is the length of your solution, and BEST is the length of the best solution among all contestants.\n\nFEEDBACK: When you submit a file for grading, it will be checked for both correct format and validity (i.e., whether it satisfies the required numerical properties), and you will be informed of the results.\n", "inputFormat": "\\* Line 1: Two space-separated integers: the case number and M\n", "outputFormat": "\\* Line 1: A single line containing the task name and case number: #FILE perlbrac CASENUM\n\n\\* Line 2: A single line with a single integer, N (which must be no larger than 20,000)\n\n\\* Lines 3..N+1: Line i+2 contains a single integer that is the integer etched onto the i-th pearl on the bracelet; this number should be between 0 and M - 1, inclusive\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO09HOL] Pearl Bracelet G【征集 SPJ】", "background": "", "description": "Bessie 收到了一个魔法手镯，这是一套稀有的黑珍珠，是她最喜欢的节日礼物。Bessie 非常喜欢这个手镯，并惊奇地发现每颗珍珠上都刻有一个小数字。她注意到，如果通过围绕某个点弯曲手镯来排列珍珠的所有可能方式（见下文），手镯上下两侧对应数字的珍珠的「渐进」和在模 M（2 <= M <= 100）比较时从未匹配过。「渐进」和的例子如下。\n\n假设模 M 为 3。考虑一个有 N=6 颗珍珠的手镯，珍珠上依次刻有数字 0, 1, 0, 2, 1, 0。我们将这个手镯用它的扣子这样表示：\n\n>0-1-0-2-1-0< \n这个六颗珍珠的手镯可以在地上以五种不同的方式排列，使得某些珍珠「对应」彼此（见下文）。我们可以对上面对应的珍珠进行「渐进」和模 M 运算，也可以对下面对应的珍珠进行和模 M 运算，如同用 ONE-sums, TWO-sums, THREE-sums（当 N > 6 时以此类推）所示。\n\n```cpp\n               |     THREE-sums         |     TWO-sums      | ONE-sums\n --------------+------------------------+-------------------+--------- \n    >0-1-0-2-1 |                        |                   | => 1 |\n               |                        |                   | \n            >0 |                        |                   | => 0 \n --------------+------------------------+-------------------+--------- \n      >0-1-0-2 |                        | => 0+2 = 2        | => 2 | \n               |                        |                   | \n          >0-1 |                        | => 0+1 = 1        | => 1 \n --------------+------------------------+-------------------+--------- \n        >0-1-0 | => 0+1+0 = 1           | => 1+0 = 1        | => 0 | \n               |                        |                   | \n        >0-1-2 | => 0+1+2 = 3 mod 3 = 0 | => 1+2 mod 3 = 0  | => 2 \n --------------+------------------------+-------------------+--------- \n          >0-1 |                        | => 0+1 = 1        | => 1 | \n               |                        |                   | \n      >0-1-2-0 |                        | => 2+0 = 2        | => 0 \n --------------+------------------------+-------------------+--------- \n            >0 |                        |                   | => 0 | \n               |                        |                   | \n    >0-1-2-0-1 |                        |                   | => 1 \n```\n\n\n\nBessie 注意到所有的和对都包含不同的数字，并且听说对于所有的魔法手镯都是如此。Bessie 想知道具有这种唯一和性质的最长可能手镯是多少。\n\n给定 M，找到一组非常长（但不超过 20,000）的数字，可以刻在黑珍珠上以保持手镯的这种唯一和性质。\n\n这是一个仅输出题目，15 个输入文件可以从以下地址下载：http://ace.delos.com/perlbrac.zip\n\n评分：此问题的评分将是相对的；每个测试用例的整数得分（满分 10 分）将是 int(10 \\* sqrt(YOURS / BEST))，其中 YOURS 是你的解的长度，BEST 是所有参赛者中最佳解的长度。\n\n反馈：当你提交一个文件进行评分时，它将被检查格式和有效性（即是否满足所需的数值属性），并且你将被告知结果。", "inputFormat": "\\* 第 1 行：两个用空格分隔的整数：案例编号和 M\n", "outputFormat": "\\* 第 1 行：包含任务名称和案例编号的单行：#FILE perlbrac CASENUM\n\n\\* 第 2 行：单行包含一个整数 N（必须不大于 20,000）\n\n\\* 第 3 到 N+1 行：第 i+2 行包含一个整数，即刻在手镯上第 i 颗珍珠上的整数；这个数字应在 0 到 M - 1 之间（含）\n", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2932", "type": "P", "difficulty": 3, "samples": [["4 3 1 \n1 2 \n2 3 \n3 4 \n3 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09JAN] Earthquake Damage G", "background": "", "description": "Wisconsin has had an earthquake that has struck Farmer John's farm! The earthquake has damaged some of the pastures so that they are unpassable. Remarkably, none of the cowpaths was damaged.\n\nAs usual, the farm is modeled as a set of $P(1 \\le P \\le 30,000)$ pastures conveniently numbered $1\\ldots P$ which are connected by a set of $C (1 \\le C \\le 100,000)$ non-directional cowpaths conveniently numbered $1\\ldots C$. Cowpath $i$ connects pastures $a_i$ and $b_i (1 \\le a_i \\le P; 1 \\le b_i \\le P)$. Cowpaths might connect $a_i$ to itself or perhaps might connect two pastures more than once.  The barn is located in pasture $1$.\n\nA total of $N (1 \\le N \\le P)$ cows (in different pastures) sequentially contact Farmer John via moobile phone with an integer message $report_j (2 \\le report_j \\le P)$ that indicates that pasture $report_j$ is undamaged but that the calling cow is unable to return to the barn from pasture $report_j$ because she could not find a path that does not go through damaged pastures.\n\nAfter all the cows report in, determine the minimum number of pastures (including ones that are uncrossable) from which it is not possible to return to the barn.\n\nNote: Feedback on some of the test data will be provided on the first $50$ submissions.", "inputFormat": "Line $1$: Three space-separated integers: $P$,$C$,and $N$.\n\nLines $2\\ldots C+1$: Line $i+1$ describes cowpath $i$ with two integers: $a_i$ and $b_i$.\n\nLines $C+2\\ldots C+N+1$: Line $C+1+j$ contains a single integer: $report_j$.\n", "outputFormat": "Line $1$: A single integer that is the minimum count of pastures from which a cow can not return to the barn (including the damaged pastures themselves)\n", "hint": "Pasture $2$ is damaged, resulting in cows in pastures $2, 3, 4$ not being able to return to the barn.", "locale": "en", "translations": {"en": {"title": "[USACO09JAN] Earthquake Damage G", "background": "", "description": "Wisconsin has had an earthquake that has struck Farmer John's farm! The earthquake has damaged some of the pastures so that they are unpassable. Remarkably, none of the cowpaths was damaged.\n\nAs usual, the farm is modeled as a set of $P(1 \\le P \\le 30,000)$ pastures conveniently numbered $1\\ldots P$ which are connected by a set of $C (1 \\le C \\le 100,000)$ non-directional cowpaths conveniently numbered $1\\ldots C$. Cowpath $i$ connects pastures $a_i$ and $b_i (1 \\le a_i \\le P; 1 \\le b_i \\le P)$. Cowpaths might connect $a_i$ to itself or perhaps might connect two pastures more than once.  The barn is located in pasture $1$.\n\nA total of $N (1 \\le N \\le P)$ cows (in different pastures) sequentially contact Farmer John via moobile phone with an integer message $report_j (2 \\le report_j \\le P)$ that indicates that pasture $report_j$ is undamaged but that the calling cow is unable to return to the barn from pasture $report_j$ because she could not find a path that does not go through damaged pastures.\n\nAfter all the cows report in, determine the minimum number of pastures (including ones that are uncrossable) from which it is not possible to return to the barn.\n\nNote: Feedback on some of the test data will be provided on the first $50$ submissions.", "inputFormat": "Line $1$: Three space-separated integers: $P$,$C$,and $N$.\n\nLines $2\\ldots C+1$: Line $i+1$ describes cowpath $i$ with two integers: $a_i$ and $b_i$.\n\nLines $C+2\\ldots C+N+1$: Line $C+1+j$ contains a single integer: $report_j$.\n", "outputFormat": "Line $1$: A single integer that is the minimum count of pastures from which a cow can not return to the barn (including the damaged pastures themselves)\n", "hint": "Pasture $2$ is damaged, resulting in cows in pastures $2, 3, 4$ not being able to return to the barn.", "locale": "en"}, "zh-CN": {"title": "[USACO09JAN] Earthquake Damage G", "background": "", "description": "威斯康星州发生了一场地震，影响了 Farmer John 的农场！地震损坏了一些牧场，使它们无法通行。值得注意的是，没有一条牛道受到损坏。\n\n像往常一样，农场被建模为一组编号为 $1\\ldots P$ 的 $P(1 \\le P \\le 30,000)$ 个牧场，这些牧场通过一组编号为 $1\\ldots C$ 的 $C (1 \\le C \\le 100,000)$ 条无向牛道连接。牛道 $i$ 连接牧场 $a_i$ 和 $b_i (1 \\le a_i \\le P; 1 \\le b_i \\le P)$。牛道可能连接 $a_i$ 自己，或者可能多次连接两个牧场。谷仓位于牧场 $1$。\n\n总共有 $N (1 \\le N \\le P)$ 头牛（在不同的牧场）通过手机依次联系 Farmer John，发送一个整数消息 $report_j (2 \\le report_j \\le P)$，表示牧场 $report_j$ 未受损，但打电话的牛无法从牧场 $report_j$ 返回谷仓，因为它找不到不经过受损牧场的路径。\n\n在所有牛报告后，确定无法返回谷仓的最小牧场数量（包括那些不可通行的牧场）。\n\n注意：在前 $50$ 次提交中，将提供部分测试数据的反馈。", "inputFormat": "第 $1$ 行：三个用空格分隔的整数：$P$，$C$ 和 $N$。\n\n第 $2\\ldots C+1$ 行：第 $i+1$ 行描述牛道 $i$，包含两个整数：$a_i$ 和 $b_i$。\n\n第 $C+2\\ldots C+N+1$ 行：第 $C+1+j$ 行包含一个整数：$report_j$。\n", "outputFormat": "第 $1$ 行：一个整数，表示无法从牧场返回谷仓的最小牧场数量（包括受损的牧场本身）。\n", "hint": "牧场 $2$ 受损，导致牧场 $2, 3, 4$ 的牛无法返回谷仓。（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2933", "type": "P", "difficulty": 5, "samples": [["4 20 \n10 \n3 \n20 \n40 \n", "2 17 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09JAN] The Baric Bovine G", "background": "", "description": "Following up on a journal article about increasing milk production, Bessie has become the Baric Bovine by studying atmospheric pressure in order to curry favor with Farmer John.\n\nShe takes N (1 <= N <= 100) measurements conveniently named M\\_1 through M\\_N during the day (1 <= M\\_i <= 1,000,000); these measurements are numbered in the order in which Bessie observed them.\n\nIn order to characterize the day's atmospheric pressure readings, she is interested in finding a subset of the measurements (given by the K (1 <= K <= N) indices s\\_j where 1 <= s\\_1 < s\\_2 < ... < s\\_K <= N) that accurately reflects the entire set, i.e., limits the error as described below.\n\nIn any subset of measurements, an error is incurred for each\n\nmeasurement (1) before the first member of the subset, (2) between two consecutive measurements in the subset, and (3) after the last member of the subset. The total error value for a given set of s\\_j values is the sum of each of the individual errors.\n\nSpecifically, for all measurements whose index i is not one of the s\\_j values:\n\n```cpp\n* if i is less than s_1, then the sample error is: \n2 * | M_i - M_(s_1) | \n* if i is between s_j and s_(j+1), then the sample error is \n| 2 * M_i - Sum(s_j, s_(j+1)) | \nwhere Sum(x, y) = M_x + M_y; \n* if i is greater than s_K, then the sample error is \n2 * | M_i - M_(s_K) | \nGiven a maximum error value E (1 <= E <= 1,000,000), determine the size of the smallest subset of measurements that produces an error of at most E. \n```\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and E\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: M\\_i\n", "outputFormat": "\\* Line 1: Two space-separated integers: the size of the smallest subset of measurements that produces an error of at most E and the least possible error for the subset of that size.\n", "hint": "Bessie takes four measurements; the maximum error is 20. The\n\nmeasurements are, in sequence: 10, 3, 20, and 40.\n\n\nChoosing the second and fourth measurements is the best option, giving an error of 17. The first term's error is 2\\*|10-3| = 14; the third term's error is |2\\*20 - (3+40)| = 3. ", "locale": "en", "translations": {"en": {"title": "[USACO09JAN] The Baric Bovine G", "background": "", "description": "Following up on a journal article about increasing milk production, Bessie has become the Baric Bovine by studying atmospheric pressure in order to curry favor with Farmer John.\n\nShe takes N (1 <= N <= 100) measurements conveniently named M\\_1 through M\\_N during the day (1 <= M\\_i <= 1,000,000); these measurements are numbered in the order in which Bessie observed them.\n\nIn order to characterize the day's atmospheric pressure readings, she is interested in finding a subset of the measurements (given by the K (1 <= K <= N) indices s\\_j where 1 <= s\\_1 < s\\_2 < ... < s\\_K <= N) that accurately reflects the entire set, i.e., limits the error as described below.\n\nIn any subset of measurements, an error is incurred for each\n\nmeasurement (1) before the first member of the subset, (2) between two consecutive measurements in the subset, and (3) after the last member of the subset. The total error value for a given set of s\\_j values is the sum of each of the individual errors.\n\nSpecifically, for all measurements whose index i is not one of the s\\_j values:\n\n```cpp\n* if i is less than s_1, then the sample error is: \n2 * | M_i - M_(s_1) | \n* if i is between s_j and s_(j+1), then the sample error is \n| 2 * M_i - Sum(s_j, s_(j+1)) | \nwhere Sum(x, y) = M_x + M_y; \n* if i is greater than s_K, then the sample error is \n2 * | M_i - M_(s_K) | \nGiven a maximum error value E (1 <= E <= 1,000,000), determine the size of the smallest subset of measurements that produces an error of at most E. \n```\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and E\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: M\\_i\n", "outputFormat": "\\* Line 1: Two space-separated integers: the size of the smallest subset of measurements that produces an error of at most E and the least possible error for the subset of that size.\n", "hint": "Bessie takes four measurements; the maximum error is 20. The\n\nmeasurements are, in sequence: 10, 3, 20, and 40.\n\n\nChoosing the second and fourth measurements is the best option, giving an error of 17. The first term's error is 2\\*|10-3| = 14; the third term's error is |2\\*20 - (3+40)| = 3. ", "locale": "en"}, "zh-CN": {"title": "[USACO09JAN] The Baric Bovine G", "background": "", "description": "为了研究农场的气候，Bessie 帮助农夫 John 做了  $N$ 次气压测量并按顺序记录了结果  $M_1 \\cdots M_n$。Bessie 想找出一部分测量结果来总结一整天的气压分布。她想用  $K(1 \\leq K \\leq N)$ 个数  $s_j (1 \\leq s_1 < s_2 < \\cdots < s_K \\leq N)$ 来概括所有测量结果。她想限制如下的误差: 对于任何测量结果子集，每一个非此子集中的结果都会产生误差。总误差是所有测量结果的误差之和。更明确地说，对于每一个和所有  $s_j$ 都不同的  $i$：\n\n- 如果  $i$ 小于  $s_1$, 误差是： $2 \\times | M_i - M_{(s_1)} |$；\n- 如果  $i$ 在  $s_j$ 和  $s_{(j+1)}$ 之间，误差是： $| 2 \\times M_i - \\operatorname{Sum}(s_j, s_{(j+1)}) |$。注： $\\operatorname{Sum}(x, y) = M_x + M_y$  ( $M_x$ 和  $M_y$ 之和)；\n- 如果  $i$ 大于  $s_K$ ,误差为： $2 \\times | M_i - M_{(s_K)} |$ 给出最大允许的误差  $E$，找出最小的一部分结果使得误差最多为  $E$。", "inputFormat": "- 第  $1$ 行：两个用空格分开的正整数  $N$ 和  $E$。\n\n- 第  $2\\cdots N+1$ 行：第  $i+1$ 行包含单独的一个正整数  $M_i$。", "outputFormat": "- 第  $1$ 行：两个用空格分开的整数，分别代表着最小的使得误差小于等于  $E$ 的测量结果子集元素的数量和其能达到的最小误差值。", "hint": "对于所有数据， $1 \\leq N \\leq 100$， $1 \\leq M_i \\leq 1,000,000$， $1 \\leq E \\leq 1,000,000$。\n\n### 样例说明\n\nBessie 做了 4 次测量，最大允许的误差是 20。测量的结果分别为 10，3，20 和 40。\n\n选择第二次和第四次测量结果是最佳的，误差为 17。第一个结果的误差为  $2\\times|10-3|=14$，第三个的为  $|2\\times20-(3+40)|=3$。", "locale": "zh-CN"}}}
{"pid": "P2934", "type": "P", "difficulty": 5, "samples": [["4 5 \n1 2 2 \n1 3 2 \n3 4 4 \n3 2 1 \n2 4 3 \n", "3 \n3 \n6 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO", "并查集", "最短路", "最近公共祖先 LCA", "树链剖分"], "title": "[USACO09JAN] Safe Travel G", "background": "", "description": "Gremlins have infested the farm. These nasty, ugly fairy-like creatures thwart the cows as each one walks from the barn (conveniently located at pasture\\_1) to the other fields, with cow\\_i traveling to from pasture\\_1 to pasture\\_i. Each gremlin is personalized and knows the quickest path that cow\\_i normally takes to pasture\\_i. Gremlin\\_i waits for cow\\_i in the middle of the final cowpath of the quickest route to pasture\\_i, hoping to harass cow\\_i.\n\nEach of the cows, of course, wishes not to be harassed and thus chooses an at least slightly  different route from pasture\\_1 (the barn) to pasture\\_i.\n\nCompute the best time to traverse each of these new not-quite-quickest routes that enable each cow\\_i that avoid gremlin\\_i who is located on the final cowpath of the quickest route from pasture\\_1 to pasture\\_i.\n\nAs usual, the M (2 <= M <= 200,000) cowpaths conveniently numbered 1..M are bidirectional and enable travel to all N (3 <= N <= 100,000) pastures conveniently numbered 1..N. Cowpath i connects pastures a\\_i (1 <= a\\_i <= N) and b\\_i (1 <= b\\_i <= N) and requires t\\_i (1 <= t\\_i <= 1,000) time to traverse. No two cowpaths connect the same two pastures, and no path connects a pasture to itself (a\\_i != b\\_i). Best of all, the shortest path regularly taken by cow\\_i from pasture\\_1 to pasture\\_i is unique in all the test data supplied to your program.\n\nBy way of example, consider these pastures, cowpaths, and [times]:\n\n```cpp\n1--[2]--2-------+ \n|       |       | \n[2]     [1]     [3] \n|       |       | \n+-------3--[4]--4\n```\n``` \nTRAVEL     BEST ROUTE   BEST TIME   LAST PATH \np_1 to p_2       1->2          2         1->2 \np_1 to p_3       1->3          2         1->3 \np_1 to p_4      1->2->4        5         2->4 \n```\nWhen gremlins are present:\n\n```cpp\nTRAVEL     BEST ROUTE   BEST TIME    AVOID \np_1 to p_2     1->3->2         3         1->2 \np_1 to p_3     1->2->3         3         1->3 \np_1 to p_4     1->3->4         6         2->4 \n```\nFor 20% of the test data, N <= 200. \n\nFor 50% of the test data, N <= 3000. \n\nTIME LIMIT: 3 Seconds\n\nMEMORY LIMIT: 64 MB", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Three space-separated integers: a\\_i, b\\_i, and t\\_i\n", "outputFormat": "\\* Lines 1..N-1: Line i contains the smallest time required to travel from pasture\\_1 to pasture\\_i+1 while avoiding the final cowpath of the shortest path from pasture\\_1 to pasture\\_i+1. If no such path exists from pasture\\_1 to pasture\\_i+1, output -1 alone on the line.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO09JAN] Safe Travel G", "background": "", "description": "Gremlins have infested the farm. These nasty, ugly fairy-like creatures thwart the cows as each one walks from the barn (conveniently located at pasture\\_1) to the other fields, with cow\\_i traveling to from pasture\\_1 to pasture\\_i. Each gremlin is personalized and knows the quickest path that cow\\_i normally takes to pasture\\_i. Gremlin\\_i waits for cow\\_i in the middle of the final cowpath of the quickest route to pasture\\_i, hoping to harass cow\\_i.\n\nEach of the cows, of course, wishes not to be harassed and thus chooses an at least slightly  different route from pasture\\_1 (the barn) to pasture\\_i.\n\nCompute the best time to traverse each of these new not-quite-quickest routes that enable each cow\\_i that avoid gremlin\\_i who is located on the final cowpath of the quickest route from pasture\\_1 to pasture\\_i.\n\nAs usual, the M (2 <= M <= 200,000) cowpaths conveniently numbered 1..M are bidirectional and enable travel to all N (3 <= N <= 100,000) pastures conveniently numbered 1..N. Cowpath i connects pastures a\\_i (1 <= a\\_i <= N) and b\\_i (1 <= b\\_i <= N) and requires t\\_i (1 <= t\\_i <= 1,000) time to traverse. No two cowpaths connect the same two pastures, and no path connects a pasture to itself (a\\_i != b\\_i). Best of all, the shortest path regularly taken by cow\\_i from pasture\\_1 to pasture\\_i is unique in all the test data supplied to your program.\n\nBy way of example, consider these pastures, cowpaths, and [times]:\n\n```cpp\n1--[2]--2-------+ \n|       |       | \n[2]     [1]     [3] \n|       |       | \n+-------3--[4]--4\n```\n``` \nTRAVEL     BEST ROUTE   BEST TIME   LAST PATH \np_1 to p_2       1->2          2         1->2 \np_1 to p_3       1->3          2         1->3 \np_1 to p_4      1->2->4        5         2->4 \n```\nWhen gremlins are present:\n\n```cpp\nTRAVEL     BEST ROUTE   BEST TIME    AVOID \np_1 to p_2     1->3->2         3         1->2 \np_1 to p_3     1->2->3         3         1->3 \np_1 to p_4     1->3->4         6         2->4 \n```\nFor 20% of the test data, N <= 200. \n\nFor 50% of the test data, N <= 3000. \n\nTIME LIMIT: 3 Seconds\n\nMEMORY LIMIT: 64 MB", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Three space-separated integers: a\\_i, b\\_i, and t\\_i\n", "outputFormat": "\\* Lines 1..N-1: Line i contains the smallest time required to travel from pasture\\_1 to pasture\\_i+1 while avoiding the final cowpath of the shortest path from pasture\\_1 to pasture\\_i+1. If no such path exists from pasture\\_1 to pasture\\_i+1, output -1 alone on the line.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO09JAN] Safe Travel G", "background": "", "description": "小妖精侵占了农场。这些讨厌的类精灵生物会阻挠每头牛从谷仓（位于 $\\mathrm{pasture}_1$（牧场 $1$））前往其他牧场的行程，其中第 $i$ 头牛要从 $\\mathrm{pasture}_1$ 前往 $\\mathrm{pasture}_i$。每个小妖精都经过个性化训练，知道第 $i$ 头牛前往 $\\mathrm{pasture}_i$ 的最短路径。第 $i$ 个小妖精会埋伏在第 $i$ 头牛最短路径的最后一条道路上，企图骚扰这头牛。\n\n每头牛当然都不希望被骚扰，因此会选择一条与原始最短路径至少存在细微差别的从 $\\mathrm{pasture}_1$ 到 $\\mathrm{pasture}_i$ 的新路径。\n\n请计算每头牛避开位于其原始最短路径最后一条道路上的小妖精后，新路线的最短通行时间。\n\n给定 $M (2 \\leq M \\leq 200\\,000)$ 条双向道路（编号 $1\\dots M$）连接 $N (3 \\leq N \\leq 100\\,000)$ 个牧场（编号 $1\\dots N$）。第 $i$ 条道路连接牧场 $a_i (1 \\leq a_i \\leq N)$ 和 $b_i (1 \\leq b_i \\leq N)$，通行时间为 $t_i (1 \\leq t_i \\leq 1\\,000)$。保证没有两条道路连接同一对牧场，且所有测试数据中从 $\\mathrm{pasture}_1$ 到任意 $\\mathrm{pasture}_i$ 的最短路径唯一。\n\n例如以下牧场、道路和通行时间：\n\n```\n1--[2]--2-------+ \n|       |       | \n[2]     [1]     [3] \n|       |       | \n+-------3--[4]--4\n```\n\n```\nTRAVEL     最佳路线      最短时间    最后一条道路 \np_1 到 p_2   1->2          2         1->2 \np_1 到 p_3   1->3          2         1->3 \np_1 到 p_4  1->2->4        5         2->4 \n```\n\n当存在小妖精时：\n\n```\nTRAVEL     最佳路线      最短时间    规避道路 \np_1 到 p_2   1->3->2        3         1->2 \np_1 到 p_3   1->2->3        3         1->3 \np_1 到 p_4   1->3->4        6         2->4 \n```\n\n- 对于 $20\\%$ 的测试数据，$N\\leq 200$。\n- 对于 $50\\%$ 的测试数据，$N\\leq 3000$。", "inputFormat": "- 第 $1$ 行：两个空格分隔的整数 $N$ 和 $M$\n- 第 $2\\dots (M+1)$ 行：每行三个空格分隔的整数 $a_i$、$b_i$ 和 $t_i$", "outputFormat": "- 第 1..N-1 行：第 $i$ 行输出从 $\\mathrm{pasture}_1$ 到 $\\mathrm{pasture}_{i+1}$ 时，避开其原始最短路径最后一条道路后的新最短路径时间。若不存在这样的路径，输出 -1。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2935", "type": "P", "difficulty": 3, "samples": [["13 6 15 \n11 \n13 \n10 \n12 \n8 \n1 \n2 4 3 \n7 11 3 \n10 11 1 \n4 13 3 \n9 10 3 \n2 3 2 \n3 5 4 \n5 9 2 \n6 7 6 \n5 6 1 \n1 2 4 \n4 5 3 \n11 12 3 \n6 10 1 \n7 8 7 \n", "10 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO", "枚举", "最短路"], "title": "[USACO09JAN] Best Spot S", "background": null, "description": "约翰拥有 $P(1 \\leq P \\leq 500)$ 个牧场，\n\n贝茜特别喜欢其中的 $F(1\\leq F \\leq P)$ 个。\n\n所有的牧场由 $C(1 < C \\leq 8000)$ 条双向路连接，第 $i$ 条路连接着 $a_i$,$b_i$ 两个牧场 $(1 \\leq a_i \\leq P,1 \\leq b_i \\leq P)$，需要 $T_i(1 \\leq T_i < 892)$ 个单位时间来通过。\n\n作为一只总想提升自己生活方式的奶牛，贝茜希望自己有朝一日醒来，到达所有那 $F$ 个她喜欢的牧场的平均用时最小。那她前一天应该睡在哪个牧场呢？请帮助贝茜找到这个最佳牧场。\n\n例如，考虑如下图所示的牧场布局，其中含有 * 的牧场的编号是最受欢迎的。而中括号内的数字是这条牛道的通过时间。\n\n```cpp\n\n            1*--[4]--2--[2]--3\n                     |       |\n                    [3]     [4]\n                     |       |\n                     4--[3]--5--[1]---6---[6]---7--[7]--8*\n                     |       |        |         |\n                    [3]     [2]      [1]       [3]\n                     |       |        |         |\n                    13*      9--[3]--10*--[1]--11*--[3]--12*\n```\n下表显示了牧场 $4,5,6,7,9,10,11$ 和 $12$ 与贝茜最喜欢的牧场的各个距离、平均距离和最终求出的最佳牧场：\n```cpp\n                    * * * * * * 最喜欢的牧场 * * * * * *\n  可能的         牧场    牧场    牧场    牧场    牧场    牧场         平均\n 最佳牧场          1       8      10      11      12      13          距离\n------------      --      --      --      --      --      --      -----------\n    4              7      16       5       6       9       3      46/6 = 7.67\n    5             10      13       2       3       6       6      40/6 = 6.67\n    6             11      12       1       2       5       7      38/6 = 6.33\n    7             16       7       4       3       6      12      48/6 = 8.00\n    9             12      14       3       4       7       8      48/6 = 8.00\n   10             12      11       0       1       4       8      36/6 = 6.00 ** 最佳的\n   11             13      10       1       0       3       9      36/6 = 6.00\n   12             16      13       4       3       0      12      48/6 = 8.00\n\n```\n由表格可见，在样例环境下，牧场 $10$ 到所有贝茜喜欢的牧场的平均距离最小，为最佳牧场。", "inputFormat": "第一行包含三个整数 $P$,$F$,$C$。\n\n接下来 $F$ 行，每行一个整数，表示贝茜喜欢的牧场的编号。\n\n接下来 $C$ 行，每行三个整数 $a_i$,$b_i$,$T_i$，表示存在一条连接 $a_i$ 和 $b_i$ 的双向通路，通过时间为 $T_i$。", "outputFormat": "一个整数，表示最佳的牧场编号。如果有多个最佳牧场，则输出编号最小的那一个。", "hint": "翻译来自 AASDFGHJKL(1035916)。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09JAN] Best Spot S", "background": "", "description": "John owns $P(1 \\leq P \\leq 500)$ pastures.\n\nBessie especially likes $F(1\\leq F \\leq P)$ of them.\n\nAll pastures are connected by $C(1 < C \\leq 8000)$ bidirectional roads. The $i$-th road connects pastures $a_i$,$b_i$ $(1 \\leq a_i \\leq P,1 \\leq b_i \\leq P)$ and takes $T_i(1 \\leq T_i < 892)$ units of time to traverse.\n\nAs a cow who always wants to improve her lifestyle, Bessie hopes that one day she will wake up at a pasture where the average time to reach all $F$ pastures she likes is minimized. At which pasture should she sleep the day before? Please help Bessie find this best pasture.\n\nFor example, consider the pasture layout shown below, where starred pastures are the most favored ones, and the numbers in brackets are the traversal times of the cow paths.\n\n```cpp\n\n            1*--[4]--2--[2]--3\n                     |       |\n                    [3]     [4]\n                     |       |\n                     4--[3]--5--[1]---6---[6]---7--[7]--8*\n                     |       |        |         |\n                    [3]     [2]      [1]       [3]\n                     |       |        |         |\n                    13*      9--[3]--10*--[1]--11*--[3]--12*\n```\n下表显示了牧场 $4,5,6,7,9,10,11$ 和 $12$ 与贝茜最喜欢的牧场的各个距离、平均距离和最终求出的最佳牧场：\n```cpp\n                    * * * * * * 最喜欢的牧场 * * * * * *\n  可能的         牧场    牧场    牧场    牧场    牧场    牧场         平均\n 最佳牧场          1       8      10      11      12      13          距离\n------------      --      --      --      --      --      --      -----------\n    4              7      16       5       6       9       3      46/6 = 7.67\n    5             10      13       2       3       6       6      40/6 = 6.67\n    6             11      12       1       2       5       7      38/6 = 6.33\n    7             16       7       4       3       6      12      48/6 = 8.00\n    9             12      14       3       4       7       8      48/6 = 8.00\n   10             12      11       0       1       4       8      36/6 = 6.00 ** 最佳的\n   11             13      10       1       0       3       9      36/6 = 6.00\n   12             16      13       4       3       0      12      48/6 = 8.00\n\n```\nFrom the table, in the sample setting, pasture $10$ has the smallest average distance to all pastures Bessie likes, making it the best pasture.", "inputFormat": "The first line contains three integers $P$,$F$,$C$.\n\nThe next $F$ lines each contain a single integer, the index of a pasture that Bessie likes.\n\nThe next $C$ lines each contain three integers $a_i$,$b_i$,$T_i$, indicating there is a bidirectional path between $a_i$ and $b_i$ with traversal time $T_i$.", "outputFormat": "Output a single integer, the index of the best pasture. If there are multiple best pastures, output the smallest index.", "hint": "Translated by AASDFGHJKL (1035916).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09JAN] Best Spot S", "background": null, "description": "约翰拥有 $P(1 \\leq P \\leq 500)$ 个牧场，\n\n贝茜特别喜欢其中的 $F(1\\leq F \\leq P)$ 个。\n\n所有的牧场由 $C(1 < C \\leq 8000)$ 条双向路连接，第 $i$ 条路连接着 $a_i$,$b_i$ 两个牧场 $(1 \\leq a_i \\leq P,1 \\leq b_i \\leq P)$，需要 $T_i(1 \\leq T_i < 892)$ 个单位时间来通过。\n\n作为一只总想提升自己生活方式的奶牛，贝茜希望自己有朝一日醒来，到达所有那 $F$ 个她喜欢的牧场的平均用时最小。那她前一天应该睡在哪个牧场呢？请帮助贝茜找到这个最佳牧场。\n\n例如，考虑如下图所示的牧场布局，其中含有 * 的牧场的编号是最受欢迎的。而中括号内的数字是这条牛道的通过时间。\n\n```cpp\n\n            1*--[4]--2--[2]--3\n                     |       |\n                    [3]     [4]\n                     |       |\n                     4--[3]--5--[1]---6---[6]---7--[7]--8*\n                     |       |        |         |\n                    [3]     [2]      [1]       [3]\n                     |       |        |         |\n                    13*      9--[3]--10*--[1]--11*--[3]--12*\n```\n下表显示了牧场 $4,5,6,7,9,10,11$ 和 $12$ 与贝茜最喜欢的牧场的各个距离、平均距离和最终求出的最佳牧场：\n```cpp\n                    * * * * * * 最喜欢的牧场 * * * * * *\n  可能的         牧场    牧场    牧场    牧场    牧场    牧场         平均\n 最佳牧场          1       8      10      11      12      13          距离\n------------      --      --      --      --      --      --      -----------\n    4              7      16       5       6       9       3      46/6 = 7.67\n    5             10      13       2       3       6       6      40/6 = 6.67\n    6             11      12       1       2       5       7      38/6 = 6.33\n    7             16       7       4       3       6      12      48/6 = 8.00\n    9             12      14       3       4       7       8      48/6 = 8.00\n   10             12      11       0       1       4       8      36/6 = 6.00 ** 最佳的\n   11             13      10       1       0       3       9      36/6 = 6.00\n   12             16      13       4       3       0      12      48/6 = 8.00\n\n```\n由表格可见，在样例环境下，牧场 $10$ 到所有贝茜喜欢的牧场的平均距离最小，为最佳牧场。", "inputFormat": "第一行包含三个整数 $P$,$F$,$C$。\n\n接下来 $F$ 行，每行一个整数，表示贝茜喜欢的牧场的编号。\n\n接下来 $C$ 行，每行三个整数 $a_i$,$b_i$,$T_i$，表示存在一条连接 $a_i$ 和 $b_i$ 的双向通路，通过时间为 $T_i$。", "outputFormat": "一个整数，表示最佳的牧场编号。如果有多个最佳牧场，则输出编号最小的那一个。", "hint": "翻译来自 AASDFGHJKL(1035916)。", "locale": "zh-CN"}}}
{"pid": "P2936", "type": "P", "difficulty": 5, "samples": [["5 \nA B 3 \nB C 3 \nC D 5 \nD Z 4 \nB Z 6 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO", "网络流"], "title": "[USACO09JAN] Total Flow S", "background": "", "description": "Farmer John always wants his cows to have enough water and thus has made a map of the N (1 <= N <= 700) water pipes on the farm that connect the well to the barn. He was surprised to find a wild mess of different size pipes connected in an apparently haphazard way. He wants to calculate the flow through the pipes.\n\nTwo pipes connected in a row allow water flow that is the minimum of the values of the two pipe's flow values. The example of a pipe with flow capacity 5 connecting to a pipe of flow capacity 3 can be reduced logically to a single pipe of flow capacity 3:\n\n```plain\n+---5---+---3---+    ->    +---3---+\n```\n\nSimilarly, pipes in parallel let through water that is the sum of their flow capacities:\n\n```plain\n   +---5---+\n---+       +---    ->    +---8---+\n   +---3---+\n```\n\nFinally, a pipe that connects to nothing else can be removed; it contributes no flow to the final overall capacity:\n\n```plain\n   +---5---+\n---+               ->    +---3---+\n   +---3---+--\n```\n\nAll the pipes in the many mazes of plumbing can be reduced using these ideas into a single total flow capacity.\n\nGiven a map of the pipes, determine the flow capacity between the well (A) and the barn (Z).\n\nConsider this example where node names are labeled with letters:\n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +---3---+---5---+---4---+\n                 C       D\n```\n\nPipe BC and CD can be combined:\n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +-----3-----+-----4-----+\n                     D\n```\n\nThen BD and DZ can be combined: \n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +-----------3-----------+\n```\n\nThen two legs of BZ can be combined: \n\n```plain\n         B\nA+---3---+---9---+Z\n```\n\nThen AB and BZ can be combined to yield a net capacity of 3:\n\n```plain\nA+---3---+Z\n```\n\nWrite a program to read in a set of pipes described as two endpoints and then calculate the net flow capacity from 'A' to 'Z'. All\n\nnetworks in the test data can be reduced using the rules here.\n\nPipe i connects two different nodes a\\_i and b\\_i (a\\_i in range\n\n'A-Za-z'; b\\_i in range 'A-Za-z') and has flow F\\_i (1 <= F\\_i <= 1,000). Note that lower- and upper-case node names are intended to be treated as different.\n\nThe system will provide extra test case feedback for your first 50 submissions.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N + 1: Line i+1 describes pipe i with two letters and an integer, all space-separated: a\\_i, b\\_i, and F\\_i\n", "outputFormat": "\\* Line 1: A single integer that the maximum flow from the well ('A') to the barn ('Z')\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO09JAN] Total Flow S", "background": "", "description": "Farmer John always wants his cows to have enough water and thus has made a map of the N (1 <= N <= 700) water pipes on the farm that connect the well to the barn. He was surprised to find a wild mess of different size pipes connected in an apparently haphazard way. He wants to calculate the flow through the pipes.\n\nTwo pipes connected in a row allow water flow that is the minimum of the values of the two pipe's flow values. The example of a pipe with flow capacity 5 connecting to a pipe of flow capacity 3 can be reduced logically to a single pipe of flow capacity 3:\n\n```plain\n+---5---+---3---+    ->    +---3---+\n```\n\nSimilarly, pipes in parallel let through water that is the sum of their flow capacities:\n\n```plain\n   +---5---+\n---+       +---    ->    +---8---+\n   +---3---+\n```\n\nFinally, a pipe that connects to nothing else can be removed; it contributes no flow to the final overall capacity:\n\n```plain\n   +---5---+\n---+               ->    +---3---+\n   +---3---+--\n```\n\nAll the pipes in the many mazes of plumbing can be reduced using these ideas into a single total flow capacity.\n\nGiven a map of the pipes, determine the flow capacity between the well (A) and the barn (Z).\n\nConsider this example where node names are labeled with letters:\n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +---3---+---5---+---4---+\n                 C       D\n```\n\nPipe BC and CD can be combined:\n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +-----3-----+-----4-----+\n                     D\n```\n\nThen BD and DZ can be combined: \n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +-----------3-----------+\n```\n\nThen two legs of BZ can be combined: \n\n```plain\n         B\nA+---3---+---9---+Z\n```\n\nThen AB and BZ can be combined to yield a net capacity of 3:\n\n```plain\nA+---3---+Z\n```\n\nWrite a program to read in a set of pipes described as two endpoints and then calculate the net flow capacity from 'A' to 'Z'. All\n\nnetworks in the test data can be reduced using the rules here.\n\nPipe i connects two different nodes a\\_i and b\\_i (a\\_i in range\n\n'A-Za-z'; b\\_i in range 'A-Za-z') and has flow F\\_i (1 <= F\\_i <= 1,000). Note that lower- and upper-case node names are intended to be treated as different.\n\nThe system will provide extra test case feedback for your first 50 submissions.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N + 1: Line i+1 describes pipe i with two letters and an integer, all space-separated: a\\_i, b\\_i, and F\\_i\n", "outputFormat": "\\* Line 1: A single integer that the maximum flow from the well ('A') to the barn ('Z')\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO09JAN] Total Flow S", "background": null, "description": "**请注意，题面中并没有说明水管是单向的还是双向的（虽然应该是双向的）。数据保证无论将水管视作单向还是双向得到的结果相同。**\n\n农夫约翰总是希望他的奶牛有足够的水，因此他绘制了一张农场上连接水井和谷仓的 $N（1 \\leq N \\leq 700$）根水管的地图。他惊讶地发现这些不同尺寸的水管连接得杂乱无章。他想计算水管的流量。\n\n两个串联的水管允许的水流量是两个水管流量值中的最小值。例如，一个流量为 $5$ 的水管连接到一个流量为 $3$ 的水管，可以逻辑上简化为一个流量为 $3$ 的水管：\n\n```plain\n+---5---+---3---+    ->    +---3---+\n```\n\n类似地，并联的水管允许的水流量是它们流量的总和：\n\n```plain\n   +---5---+\n---+       +---    ->    +---8---+\n   +---3---+\n```\n\n最后，一个没有连接到其他任何东西的水管可以被移除，它对最终的总流量没有贡献：\n\n```plain\n   +---5---+\n---+               ->    +---3---+\n   +---3---+--\n```\n\n管道网络中的所有水管都可以使用这些方法简化为一个总流量。\n\n给定一张水管的地图，确定从水井 $A$ 到谷仓 $Z$ 的流量。\n\n考虑这个节点名称用字母标记的例子：\n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +---3---+---5---+---4---+\n                 C       D\n```\n\n管道 $BC$ 和 $CD$ 可以合并：\n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +-----3-----+-----4-----+\n                     D\n```\n\n然后 $BD$ 和 $DZ$ 可以合并：\n\n```plain\n         +-----------6-----------+\nA+---3---+B                      +Z\n         +-----------3-----------+\n```\n\n然后 $BZ$ 的两条路径可以合并：\n\n```plain\n         B\nA+---3---+---9---+Z\n```\n\n最后，$AB$ 和 $BZ$ 可以合并，得到净流量为 $3$：\n\n```plain\nA+---3---+Z\n```\n\n编写一个程序读取描述为两个端点的水管集合，然后计算从 $A$ 到 $Z$ 的净流量。测试数据中的所有网络都可以使用这里的规则简化。\n\n管道 i 连接两个不同的节点 $a_i$ 和 $b_i$（节点范围均为 $a-z、A-Z$），流量为 $F_i$（$1 \\leq F_i \\leq 1,000$）。注意，小写和大写的节点名称应视为不同。\n\n形式化题意：求出 $A$ 到 $Z$ 的最大流。", "inputFormat": "第 $1$ 行：一个整数：$N$\n\n第 $2$ 行到第 $N+1$ 行：第 $i+1$ 行描述第 $i$ 根水管，包含两个字母和一个整数，均以空格分隔：$a_i$，$b_i$ 和 $F_i$。", "outputFormat": "第 $1$ 行：一个整数，表示从水井 $A$ 到谷仓 $Z$ 的最大流量。", "hint": "@[langmouren](luogu://user/1470994) 提供翻译", "locale": "zh-CN"}}}
{"pid": "P2937", "type": "P", "difficulty": 4, "samples": [["7 8 \n....... \n......C \n......* \n*****.* \n....*.. \n....*.. \n.C..*.. \n....... \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2009", "USACO", "并查集", "广度优先搜索 BFS", "深度优先搜索 DFS", "最短路", "最近公共祖先 LCA"], "title": "[USACO09JAN] Laserphones S", "background": null, "description": "The cows have a new laser-based system so they can have casual conversations while out in the pasture which is modeled as a W x H grid of points (1 <= W <= 100; 1 <= H <= 100).\n\nThe system requires a sort of line-of-sight connectivity in order to sustain communication. The pasture, of course, has rocks and trees that disrupt the communication but the cows have purchased diagonal mirrors ('/' and '\\' below) that deflect the laser beam through a 90 degree turn. Below is a map that illustrates the\n\nproblem.\n\nH is 8 and W is 7 for this map.  The two communicating cows are notated as 'C's; rocks and other blocking elements are notated as '\\*'s:\n\n```plain\n7 . . . . . . .         7 . . . . . . . \n6 . . . . . . C         6 . . . . . /-C \n5 . . . . . . *         5 . . . . . | * \n4 * * * * * . *         4 * * * * * | * \n3 . . . . * . .         3 . . . . * | . \n2 . . . . * . .         2 . . . . * | . \n1 . C . . * . .         1 . C . . * | . \n0 . . . . . . .         0 . \\-------/ . \n  0 1 2 3 4 5 6           0 1 2 3 4 5 6 \n```\nDetermine the minimum number of mirrors M that must be installed to maintain laser communication between the two cows, a feat which is always possible in the given test data.", "inputFormat": "\\* Line 1: Two space separated integers: W and H\n\n\\* Lines 2..H+1: The entire pasture.", "outputFormat": "\\* Line 1: A single integer: M", "hint": null, "locale": "en", "translations": {"en": {"title": "[USACO09JAN] Laserphones S", "background": null, "description": "The cows have a new laser-based system so they can have casual conversations while out in the pasture which is modeled as a W x H grid of points (1 <= W <= 100; 1 <= H <= 100).\n\nThe system requires a sort of line-of-sight connectivity in order to sustain communication. The pasture, of course, has rocks and trees that disrupt the communication but the cows have purchased diagonal mirrors ('/' and '\\' below) that deflect the laser beam through a 90 degree turn. Below is a map that illustrates the\n\nproblem.\n\nH is 8 and W is 7 for this map.  The two communicating cows are notated as 'C's; rocks and other blocking elements are notated as '\\*'s:\n\n```plain\n7 . . . . . . .         7 . . . . . . . \n6 . . . . . . C         6 . . . . . /-C \n5 . . . . . . *         5 . . . . . | * \n4 * * * * * . *         4 * * * * * | * \n3 . . . . * . .         3 . . . . * | . \n2 . . . . * . .         2 . . . . * | . \n1 . C . . * . .         1 . C . . * | . \n0 . . . . . . .         0 . \\-------/ . \n  0 1 2 3 4 5 6           0 1 2 3 4 5 6 \n```\nDetermine the minimum number of mirrors M that must be installed to maintain laser communication between the two cows, a feat which is always possible in the given test data.", "inputFormat": "\\* Line 1: Two space separated integers: W and H\n\n\\* Lines 2..H+1: The entire pasture.", "outputFormat": "\\* Line 1: A single integer: M", "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO09JAN] Laserphones S", "background": null, "description": "奶牛们有一个新的激光系统，这样它们在牧场上时可以进行随意的交谈。牧场被建模为一个 $W \\times H$ 的点阵（$1 \\leq W \\leq 100$，$1 \\leq H \\leq 100$）。\n\n该系统需要某种视线连通性以维持通信。当然，牧场上有岩石和树木会干扰通信，但奶牛们购买了对角镜（如下的 '/' 和 '\\\\'）来使激光束偏转 90 度。下面是一个说明问题的地图。\n\n对于这张地图，$H$ 是 8，$W$ 是 7。两个正在通信的奶牛用 'C' 表示；岩石和其他阻挡元素用 '*' 表示：\n\n```plain\n7 . . . . . . .         7 . . . . . . . \n6 . . . . . . C         6 . . . . . /-C \n5 . . . . . . *         5 . . . . . | * \n4 * * * * * . *         4 * * * * * | * \n3 . . . . * . .         3 . . . . * | . \n2 . . . . * . .         2 . . . . * | . \n1 . C . . * . .         1 . C . . * | . \n0 . . . . . . .         0 . \\-------/ . \n  0 1 2 3 4 5 6           0 1 2 3 4 5 6 \n```\n确定必须安装的最少镜子数量 $M$，以维持两头奶牛之间的激光通信。在给定的测试数据中，这一壮举总是可能的。", "inputFormat": "\\* 第 1 行：两个用空格分隔的整数：$W$ 和 $H$\n\n\\* 第 2 行到第 $H+1$ 行：整个牧场。", "outputFormat": "\\* 第 1 行：一个整数：$M$", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2938", "type": "P", "difficulty": 4, "samples": [["2 3 10 \n10 15 15 \n13 11 20 \n", "24 \n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO", "背包 DP", "最短路", "排列组合"], "title": "[USACO09FEB] Stock Market G", "background": "", "description": "Despite their innate prudence, the cows took a beating in the home mortgage market and now are trying their hand at stocks. Happily, Bessie is prescient and knows not only today's S (2 <= S <= 50) stock prices but also the future stock prices for a total of D days (2 <= D <= 10).\n\nGiven the matrix of current and future stock prices on various days (1 <= PR\\_sd <= 1,000) and an initial M (1 <= M <= 200,000) units of money, determine an optimal buying and selling strategy in order to maximize the gain realized by selling stock on the final day. Shares must be purchased in integer multiples, and you need not spend all the money (or any money). It is guaranteed that you will not be able to earn a profit of more than 500,000 units of money.\n\nConsider the example below of a bull (i.e., improving) market, the kind Bessie likes most. In this case, S=2 stocks and D=3 days. The cows have 10 units of money to invest.\n\n| Stock | Today's price | Tomorrow's price |    Two days hence Stock   |\n| :---: | :-----------: | :--------------: | :--: |\n|  $A$  |      10       |        15        |  15  |\n|  $B$  |      13       |        11        |  20  |\n\nIf money is to be made, the cows must purchase stock 1 on day 1. Selling stock 1 on day 2 and quickly buying stock 2 yields 4 money in the bank and one share of 2. Selling stock 2 on the final day brings in 20 money for a total of 24 money when the 20 is added to the bank.\n", "inputFormat": "\\* Line 1: Three space-separated integers: S, D, and M\n\n\\* Lines 2..S+1: Line s+1 contains the D prices for stock s on days 1..D: PR\\_sd\n", "outputFormat": "\\* Line 1: The maximum amount of money possible to have after selling on day D.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO09FEB] Stock Market G", "background": "", "description": "Despite their innate prudence, the cows took a beating in the home mortgage market and now are trying their hand at stocks. Happily, Bessie is prescient and knows not only today's S (2 <= S <= 50) stock prices but also the future stock prices for a total of D days (2 <= D <= 10).\n\nGiven the matrix of current and future stock prices on various days (1 <= PR\\_sd <= 1,000) and an initial M (1 <= M <= 200,000) units of money, determine an optimal buying and selling strategy in order to maximize the gain realized by selling stock on the final day. Shares must be purchased in integer multiples, and you need not spend all the money (or any money). It is guaranteed that you will not be able to earn a profit of more than 500,000 units of money.\n\nConsider the example below of a bull (i.e., improving) market, the kind Bessie likes most. In this case, S=2 stocks and D=3 days. The cows have 10 units of money to invest.\n\n| Stock | Today's price | Tomorrow's price |    Two days hence Stock   |\n| :---: | :-----------: | :--------------: | :--: |\n|  $A$  |      10       |        15        |  15  |\n|  $B$  |      13       |        11        |  20  |\n\nIf money is to be made, the cows must purchase stock 1 on day 1. Selling stock 1 on day 2 and quickly buying stock 2 yields 4 money in the bank and one share of 2. Selling stock 2 on the final day brings in 20 money for a total of 24 money when the 20 is added to the bank.\n", "inputFormat": "\\* Line 1: Three space-separated integers: S, D, and M\n\n\\* Lines 2..S+1: Line s+1 contains the D prices for stock s on days 1..D: PR\\_sd\n", "outputFormat": "\\* Line 1: The maximum amount of money possible to have after selling on day D.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO09FEB] Stock Market G", "background": "", "description": "尽管奶牛天生谨慎，它们仍然在住房抵押信贷市场中大受打击，现在它们准备在股市上碰碰运气。贝西有内部消息，她知道 $S$ 只股票在今后 $D$ 天内的价格。\n\n假设在一开始，她筹集了 $M$ 元钱，那么她该怎样操作才能赚到最多的钱呢？贝西在每天可以买卖多只股票，也可以多次买卖同一只股票，交易单位必须是整数，数量不限。举一个牛市的例子：\n\n假设贝西有 $10$ 元本金，股票价格如下：\n\n|  股票 | 今天的价格 | 明天的价格 | 后天的价格 |\n| :-: | :---: | :---: | :---: |\n| $A$ |   $10$  |   $15$  |   $15$  |\n| $B$ |   $13$  |   $11$  |   $20$  |\n\n最赚钱的做法是：今天买入 $A$ 股 $1$ 张，到明天把它卖掉并且买入 $B$ 股 $1$ 张，在后天卖掉 $B$ 股，这样贝西就有 $24$ 元了。", "inputFormat": "第一行：三个整数 $S,D$ 和 $M$，$2\\le S\\le 50,2\\le D\\le 10,1\\le M\\le 200000$。\n\n第二行到第 $S + 1$ 行：第 $i + 1$ 行有 $D$ 个整数：$P_{i,1}$ 到 $P_{i,D}$，表示第 $i$ 种股票在第一天到最后一天的售价，对所有 $1\\le j\\le D$，$1\\le P_{i,j}\\le 1000$。", "outputFormat": "单个整数：表示奶牛可以获得的最大钱数，保证这个数不会超过 $500000$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2939", "type": "P", "difficulty": 4, "samples": [["4 4 1 \n1 2 10 \n2 4 10 \n1 3 1 \n3 4 100 \n", "1 \n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "USACO", "最短路"], "title": "[USACO09FEB] Revamping Trails G", "background": "", "description": "Farmer John dutifully checks on the cows every day. He traverses some of the M (1 <= M <= 50,000) trails conveniently numbered 1..M from pasture 1 all the way out to pasture N (a journey which is always possible for trail maps given in the test data). The N (1 <= N <= 10,000) pastures conveniently numbered 1..N on Farmer John's farm are currently connected by bidirectional dirt trails.  Each trail i connects pastures P1\\_i and P2\\_i (1 <= P1\\_i <= N; 1 <= P2\\_i <= N) and requires T\\_i (1 <= T\\_i <= 1,000,000) units of time to traverse.\n\nHe wants to revamp some of the trails on his farm to save time on his long journey. Specifically, he will choose K (1 <= K <= 20) trails to turn into highways, which will effectively reduce the trail's traversal time to 0. Help FJ decide which trails to revamp to minimize the resulting time of getting from pasture 1 to N.\n\nTIME LIMIT: 2 seconds\n\n", "inputFormat": "\\* Line 1: Three space-separated integers: N, M, and K\n\n\\* Lines 2..M+1: Line i+1 describes trail i with three space-separated integers: P1\\_i, P2\\_i, and T\\_i\n", "outputFormat": "\\* Line 1: The length of the shortest path after revamping no more than K edges\n", "hint": "K is 1; revamp trail 3->4 to take time 0 instead of 100. The new shortest path is 1->3->4, total traversal time now 1.\n", "locale": "en", "translations": {"en": {"title": "[USACO09FEB] Revamping Trails G", "background": "", "description": "Farmer John dutifully checks on the cows every day. He traverses some of the M (1 <= M <= 50,000) trails conveniently numbered 1..M from pasture 1 all the way out to pasture N (a journey which is always possible for trail maps given in the test data). The N (1 <= N <= 10,000) pastures conveniently numbered 1..N on Farmer John's farm are currently connected by bidirectional dirt trails.  Each trail i connects pastures P1\\_i and P2\\_i (1 <= P1\\_i <= N; 1 <= P2\\_i <= N) and requires T\\_i (1 <= T\\_i <= 1,000,000) units of time to traverse.\n\nHe wants to revamp some of the trails on his farm to save time on his long journey. Specifically, he will choose K (1 <= K <= 20) trails to turn into highways, which will effectively reduce the trail's traversal time to 0. Help FJ decide which trails to revamp to minimize the resulting time of getting from pasture 1 to N.\n\nTIME LIMIT: 2 seconds\n\n", "inputFormat": "\\* Line 1: Three space-separated integers: N, M, and K\n\n\\* Lines 2..M+1: Line i+1 describes trail i with three space-separated integers: P1\\_i, P2\\_i, and T\\_i\n", "outputFormat": "\\* Line 1: The length of the shortest path after revamping no more than K edges\n", "hint": "K is 1; revamp trail 3->4 to take time 0 instead of 100. The new shortest path is 1->3->4, total traversal time now 1.\n", "locale": "en"}, "zh-CN": {"title": "[USACO09FEB] Revamping Trails G", "background": null, "description": "农夫约翰每天都会认真检查他的奶牛。他会穿越一些编号为 $1$ 到 $M$ 的小径（$1 \\leq M \\leq 50,000$），从牧场 $1$ 一直走到牧场 $N$（对于测试数据给出的路径图，这段旅程总是可能的）。农夫约翰的农场上有 $N$ 个牧场（$1 \\leq N \\leq 10,000$），它们通过双向泥土小径连接在一起。每条小径 $i$ 连接牧场 $P1_i$ 和 $P2_i$（$1 \\leq P1_i \\leq N,1 \\leq P2_i \\leq N$），需要 $T_i$（$1 \\leq T_i \\leq 1,000,000$）单位时间来穿越。\n\n他想要改造农场上的一些小径，以节省长途旅行的时间。具体来说，他将选择 $K$（$1 \\leq K \\leq 20$）条小径将其改造成高速公路，这将有效地将小径的穿越时间减少到 $0$。帮助 FJ 决定改造哪些小径以最小化从牧场 $1$ 到 $N$ 的最终时间。", "inputFormat": "* 第 $1$ 行：三个用空格分隔的整数：$N,M$ 和 $K$。\n\n* 第 $2$ 行到第 $M+1$ 行：第 $i+1$ 行描述小径 $i$，包含三个用空格分隔的整数：$P1_i$、$P2_i$ 和 $T_i$。", "outputFormat": "共 $1$ 行：改造不超过 $K$ 条边后的最短路径长度。", "hint": "$K$ 为 $1$；将小径 $3$->$4$ 改造成高速公路，时间从 $100$ 变为 $0$。新的最短路径为 $1$->$3$->$4$，总穿越时间现在为 $1$。", "locale": "zh-CN"}}}
{"pid": "P2940", "type": "P", "difficulty": 3, "samples": [["4 \n8 6 6 1 \n-3 4 0 5 \n4 2 1 9 \n1 -9 9 -2 \n", "24 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09FEB] The Leprechaun S", "background": "", "description": "Imagine Bessie's surprise as she spotted a leprechaun prancing through the north pasture. Being no one's fool, she charged and captured him with her prehensile hooves.\n\n\"One wish, bovine one. That's all I have for cows,\" he said.\n\n\"Riches,\" Bessie replied dreamily. \"The opportunity for riches.\"\n\nLeprechauns never grant the easiest possible form of a wish. When the smoke from a loud explosion cleared, a shimmering donut spun slowly over the verdant green fields.\n\n\"I have made you a torus,\" the leprechaun cooed. \"On that torus is an $N \\times N$ matrix ($1 \\le N \\le 200$) of integers in the range $-1{,}000{,}000..1{,}000{,}000$ that will determine the magnitude of your riches. You must find the contiguous sequence of integers, all in one row, one column, or along one diagonal, that yields the largest sum among all possible sequences on the torus.\"\n\nBessie realized that the torus \"wraps\" the rows, columns, and diagonals of the matrix so that one may choose contiguous elements that wrap around the edges. In other words, the two ends of a row are adjacent, the two ends of a column are adjacent, and even the ends across adjacent rows are adjacent in the diagonal directions. You must choose at least one matrix element.\n\nBy way of example, consider the $4 \\times 4$ matrix on the left below in which all the elements of one exemplary wrapped diagonal are marked:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/03z54guy.png)\n\nThe marked diagonal of the right-hand matrix includes two nines (the highest available number) and a six, for a total of $24$. This is the best possible sum for this matrix and uses only three of the four possible elements on that diagonal.", "inputFormat": "* Line 1: A single integer $N$.\n* Lines $2..N+1$: Line $i+1$ contains $N$ space-separated integers that compose row $i$ of the matrix.", "outputFormat": "* Line 1: A single integer that is the largest possible sum computable using the rules above.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en", "translations": {"en": {"title": "[USACO09FEB] The Leprechaun S", "background": "", "description": "Imagine Bessie's surprise as she spotted a leprechaun prancing through the north pasture. Being no one's fool, she charged and captured him with her prehensile hooves.\n\n\"One wish, bovine one. That's all I have for cows,\" he said.\n\n\"Riches,\" Bessie replied dreamily. \"The opportunity for riches.\"\n\nLeprechauns never grant the easiest possible form of a wish. When the smoke from a loud explosion cleared, a shimmering donut spun slowly over the verdant green fields.\n\n\"I have made you a torus,\" the leprechaun cooed. \"On that torus is an $N \\times N$ matrix ($1 \\le N \\le 200$) of integers in the range $-1{,}000{,}000..1{,}000{,}000$ that will determine the magnitude of your riches. You must find the contiguous sequence of integers, all in one row, one column, or along one diagonal, that yields the largest sum among all possible sequences on the torus.\"\n\nBessie realized that the torus \"wraps\" the rows, columns, and diagonals of the matrix so that one may choose contiguous elements that wrap around the edges. In other words, the two ends of a row are adjacent, the two ends of a column are adjacent, and even the ends across adjacent rows are adjacent in the diagonal directions. You must choose at least one matrix element.\n\nBy way of example, consider the $4 \\times 4$ matrix on the left below in which all the elements of one exemplary wrapped diagonal are marked:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/03z54guy.png)\n\nThe marked diagonal of the right-hand matrix includes two nines (the highest available number) and a six, for a total of $24$. This is the best possible sum for this matrix and uses only three of the four possible elements on that diagonal.", "inputFormat": "* Line 1: A single integer $N$.\n* Lines $2..N+1$: Line $i+1$ contains $N$ space-separated integers that compose row $i$ of the matrix.", "outputFormat": "* Line 1: A single integer that is the largest possible sum computable using the rules above.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09FEB] The Leprechaun S", "background": null, "description": "你难以想象贝茜看到一只妖精在牧场出现时是多么的惊讶．她不是傻瓜，立即猛扑过去，用她那灵活的牛蹄抓住了那只妖精．\n\n“你可以许一个愿望，傻大个儿！”妖精说．\n\n“财富，”贝茜用梦游般的声音回答道，  “我要获得财富的机会．”", "inputFormat": "妖精从来没有碰到过这么简单的愿望．他在地方划出一大块 $N\\times N(1≤N≤200)$ 的方格，每个格子上写上 $-1,000,000$ 到 $1,000,000$ 之间的数字．他说：“在方格上朝一个方向行走，可以是行的方向，列的方向，斜对角的方向，一步只能走一格，所有你踩过的数字的和就是你的财富．”\n\n贝茜请你来帮忙，找到一行、一列或一条对角线上找一段连续的数字，它们的和最大．由于妖精方格的神奇特性，沿着一个方向走，走到了边际，再一步跨过去可以“绕”到方格的对边出现．一行两端的格子是相邻的，一列两端的格子也是相邻的，甚至相邻两行的分别两端的格子也是相邻的（斜对角方向）．\n\n对于下图左边的方格，所有标记过的数字都在一条对角线上．\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tc1tim3s.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8cgrjpuz.png)\n \n对于这个方格，能踩出来的最大的和是 24，踩过的数字在右图中标记出来了", "outputFormat": "一行一个正整数表示答案", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2941", "type": "P", "difficulty": 3, "samples": [["12 \n1 7 \n7 3 \n3 6 \n6 10 \n10 1 \n2 12 \n2 9 \n8 9 \n8 12 \n11 5 \n5 4 \n11 4 \n0 15 9 20 25 8 10 13 17 8 8 7 \n15 0 12 12 10 10 8 15 15 8 8 9 \n9 12 0 25 20 18 16 14 13 7 12 12 \n20 12 25 0 8 13 14 15 15 10 10 10 \n25 10 20 8 0 16 20 18 17 18 9 11 \n8 10 18 13 16 0 10 9 11 10 8 12 \n10 8 16 14 20 10 0 18 20 6 16 15 \n13 15 14 15 18 9 18 0 5 12 12 13 \n17 15 13 15 17 11 20 5 0 22 8 10 \n8 8 7 10 18 10 6 12 22 0 11 12 \n8 8 12 10 9 8 16 12 8 11 0 9 \n7 9 12 10 11 12 15 13 10 12 9 0 \n", "30 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO", "并查集", "枚举"], "title": "[USACO09FEB] Surround the Islands S", "background": "", "description": "Farmer John has bought property in the Caribbean and is going to try to raise dairy cows on a big farm composed of islands. Set in his ways, he wants to surround all the islands with fence.\n\nEach island in the farm has the shape of a polygon. He fences the islands one side at a time (between a consecutive pair of vertices) and proceeds clockwise around a given island with his fencing\n\noperations. Since he wants to fence all the islands, he must at some point travel to any other islands using a boat.\n\nHe can start fencing at any vertex and, at any vertex he encounters, travel to some vertex on another island, fence all the way around it, and then IMMEDIATELY return back to the same vertex on the original island using the same path he traveled before. Each boat trip has a cost defined by a supplied matrix.\n\nThe islands are described by a set of N (3 <= N <= 500) pairs of vertices V1,V2 (1 <= V1 <= N; 1 <= V2 <= N) although you must figure out how to assemble them into islands. The vertices are conveniently numbered 1..N.\n\nThe cost of traveling by boat between each pair of vertices is given by a symmetric cost matrix whose elements fall in the range 0..1000.\n\nWhat is the minimum cost of surrounding the islands with the fence?", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Each line describes an island's border with two space-separated integers: V1 and V2\n\n\\* Lines N+2..2\\*N+1: Line i-N-1 contains N integers that describe row i of the cost matrix: Row\\_i\n", "outputFormat": "\\* Line 1: A single integer that specifies the minimum cost of building the fence\n", "hint": "1        10            4\n\nxxxxxxx              x\n\nxxxxxxxxx            xxxx\n\n7 xxxxxxxxxxx 6        xxxxxxx\n\nxxxxxxxxxxx       11 xxxxxxxxxx 5\n\nxxxxxxx\n\nxxx\n3         12 xxxxxxx 2\n\nxxxxxxxx\n\nxxxxxxxx\n\nxxxxxxxxx\n\nxxxxxxxxx\n\nxxxxxxxxxx\n\nxxxxxxxxxx\n\n8 xxxxxxxxxx 9\n\nThe example describes three islands: {1,7,3,6,10}, {4,5,11} and {2,9,8,12}. The travel costs are provided as a matrix. For example, the travel cost from vertex 1 to 2 is 15.\n\n\nThere is more than one solution. One is: FJ starts from vertex 3 then 7 and stops at 1, travels to 11 followed by 4,5,11. He then returns back to 1, and travels to 12 followed by 2,9,8,12. Finally, he returns back to 1 and continues with 10,6,3,7. The costs are 8 \\* 2 = 16 for traveling from 1 to 11 and returning back, and 7 \\* 2 = 14 for traveling from 1 to 12 and back -- a total cost of 30.\n", "locale": "en", "translations": {"en": {"title": "[USACO09FEB] Surround the Islands S", "background": "", "description": "Farmer John has bought property in the Caribbean and is going to try to raise dairy cows on a big farm composed of islands. Set in his ways, he wants to surround all the islands with fence.\n\nEach island in the farm has the shape of a polygon. He fences the islands one side at a time (between a consecutive pair of vertices) and proceeds clockwise around a given island with his fencing\n\noperations. Since he wants to fence all the islands, he must at some point travel to any other islands using a boat.\n\nHe can start fencing at any vertex and, at any vertex he encounters, travel to some vertex on another island, fence all the way around it, and then IMMEDIATELY return back to the same vertex on the original island using the same path he traveled before. Each boat trip has a cost defined by a supplied matrix.\n\nThe islands are described by a set of N (3 <= N <= 500) pairs of vertices V1,V2 (1 <= V1 <= N; 1 <= V2 <= N) although you must figure out how to assemble them into islands. The vertices are conveniently numbered 1..N.\n\nThe cost of traveling by boat between each pair of vertices is given by a symmetric cost matrix whose elements fall in the range 0..1000.\n\nWhat is the minimum cost of surrounding the islands with the fence?", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Each line describes an island's border with two space-separated integers: V1 and V2\n\n\\* Lines N+2..2\\*N+1: Line i-N-1 contains N integers that describe row i of the cost matrix: Row\\_i\n", "outputFormat": "\\* Line 1: A single integer that specifies the minimum cost of building the fence\n", "hint": "1        10            4\n\nxxxxxxx              x\n\nxxxxxxxxx            xxxx\n\n7 xxxxxxxxxxx 6        xxxxxxx\n\nxxxxxxxxxxx       11 xxxxxxxxxx 5\n\nxxxxxxx\n\nxxx\n3         12 xxxxxxx 2\n\nxxxxxxxx\n\nxxxxxxxx\n\nxxxxxxxxx\n\nxxxxxxxxx\n\nxxxxxxxxxx\n\nxxxxxxxxxx\n\n8 xxxxxxxxxx 9\n\nThe example describes three islands: {1,7,3,6,10}, {4,5,11} and {2,9,8,12}. The travel costs are provided as a matrix. For example, the travel cost from vertex 1 to 2 is 15.\n\n\nThere is more than one solution. One is: FJ starts from vertex 3 then 7 and stops at 1, travels to 11 followed by 4,5,11. He then returns back to 1, and travels to 12 followed by 2,9,8,12. Finally, he returns back to 1 and continues with 10,6,3,7. The costs are 8 \\* 2 = 16 for traveling from 1 to 11 and returning back, and 7 \\* 2 = 14 for traveling from 1 to 12 and back -- a total cost of 30.\n", "locale": "en"}, "zh-CN": {"title": "[USACO09FEB] Surround the Islands S", "background": null, "description": "Farmer John 在加勒比海购置了一片地产，准备在由一系列岛屿组成的农场上养奶牛。 出于他的意愿，他要把所有的岛屿都用篱笆围上。\n每个岛都是多边形的。每一次，FJ 会给多边形的一个边（即相邻的两个顶点之间）装上篱笆。对于整个岛屿，他会按照顺时针顺序装上篱笆。由于他想要给所有的岛屿都装上篱笆，某些时候，他必须从一个岛屿坐船到另一个岛屿去。  \nFJ 可以从任何一个顶点开始装篱笆，也可以从任何一个顶点坐船到另一个岛的某个顶点上，从这个顶点开始把该岛屿的篱笆全都装好，然后**马上**坐船原路返回。保证任意两个顶点间都有航线。在任意两个顶点之间坐船的费用会在一个矩阵中给出。  \n\n所有的岛屿由给定的 $N$ 对顶点 $V_1$，$V_2$ 描述（即：给定顶点 $V_1$ 与 $V_2$ 相邻）。每个顶点具体属于哪个岛屿**不会**在输入中给出。所有顶点由 $1$ 到 $N$ 标号。  \n在顶点间坐船旅行的费用由一个 $N \\times N$ 的矩阵给出。保证两个岛屿间两个方向的旅行费用相等且不会超过 $1000$。   \n\n请求出 FJ 把篱笆装完所需要的最小花费。", "inputFormat": "第 $1$ 行一个整数 $N$。\n\n第 $2$ 至第 $N+1$ 行：每行包含两个整数 $V_1$ 和 $V_2$，表示这两个顶点在同一个岛屿上且相邻。\n\n第 $N+2$ 行至第 $2\\times N+1$ 行：每行包含 $N$ 个整数，第 $i+N+1$ 行的第 $j$ 个整数表示从 $i$ 号顶点坐船到第 $j$ 号顶点的花费。", "outputFormat": "一行一个整数，表示 FJ 把篱笆装完所需要的最小花费。", "hint": "对于所有数据，保证：\n+ $3 \\leq N \\leq 500$\n+ $1 \\leq V_1,V_2 \\leq N$\n+ 任意两个顶点之间的旅行花费 $\\leq 1000$", "locale": "zh-CN"}}}
{"pid": "P2942", "type": "P", "difficulty": 3, "samples": [["3 10 \n4 3 3 \n17 8 2 \n", "65 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO"], "title": "[USACO09MAR] Moon Mooing G", "background": "", "description": "A full moon casts some sort of spell on the cows and, like their cousins the wolves and coyotes, they bay at the moon -- mooing instead of howling, of course.\n\nEach 'moo' lasts a certain amount of time. A short 'moo' might last time 1; a longer one might last time 24 or even 1,000,000,000 or longer (cows can really moo when they want to). No 'moo' will last more than or equal to 2^63.\n\nIt should come as no surprise that the cows have a pattern to their moos.  Bessie will choose an integer c (1 <= c <= 100) that is the initial length of a moo.\n\nAfter Bessie moos for length c, the cows calculate times for\n\nsubsequent moos. They apply two formulae to each moo time to yield even more moo times. The two formulae are:\n\n```cpp\nf1(c)=a1*c/d1+b1 (integer divide, of course) and \nf2(c)=a2*c/d2+b2. \nThey then successively use the two new times created by evaluating f1(c) and f2(c) to create even more mooing times. They keep a sorted list of all the possible mooing times (discarding duplicates). \nThey are allowed to moo a total of N times (1 <= N <= 4,000,000). Please determine the length of the longest moo before they must quit. \nThe constants in the formulae have these constraints: 1 <= d1 < a1; d1 < a1 <= 20; 0 <= b1 <= 20; 1 <= d2 < a2; d2 < a2 <= 20; 0 <= b2 <= 20. \nConsider an example where c=3 and N=10. The constants are: \na1=4    b1=3     d1=3 \na2=17   b2=8     d2=2 \n```\nThe first mooing time is 3, given by the value of c. The total list of mooing times is:\n```cpp\n1. c=3             ->  3       6. f2(3)=17*3/2+8  -> 33 \n2. f1(3)=4*3/3+3   ->  7       7. f1(28)=4*28/3+3 -> 40 \n3. f1(7)=4*7/3+3   -> 12       8. f1(33)=4*33/3+3 -> 47 \n4. f1(12)=4*12/3+3 -> 19       9. f1(40)=4*40/3+3 -> 56 \n5. f1(19)=4*19/3+3 -> 28      10. f1(47)=4*47/3+3 -> 65 \nThe tenth time is 65, which would be the proper answer for this set of inputs. \n```\nPartial feedback will be provided on the first 50 submissions.\nMEMORY LIMIT: 64MB\n\n满月的时候，和狼一样，牛们也在月光下叫，他们从不嚎叫，而是哞叫。\n\n每次哞叫都有一个时长，可能是 $1$ 秒，可能是 $10^9$ 秒或更久，牛们真的非常能叫.当然，没有哞叫时长会超过或等于 $2^{63}$。\n\n牛们的哞叫可以找到规律，这并不奇怪。贝茜会选择一个整数 $c(c\\le100)$ 来作为初始时长之后，牛们根据两条公式确定更多的时长：\n\n$f_1(c)=\\lfloor a_1c/d_1\\rfloor+b_1$\n\n$f_2(c)=\\lfloor a_2c/d_2\\rfloor+b_2$ \n\n牛们用这两条公式不断地迭代、计算，算得大量的时长.然后她们将这些时长排序，剔除重复的时长，最后取前 $N(1<N< 4000000)$ 个整数为她们 $N$ 次哞叫的时长.请你计算，第 $N$ 次哞叫的时长是多少。公式中的常量均为整数，满足下列关系： \n\n$1 \\le d_1 < a_1 \\le 20$; $0\\le b_1 \\le 20$;\n\n$1 \\le d_2 < a_2 \\le 20$; $0\\le b_2\\le 20$。\n", "inputFormat": "\\* Line 1: Two space-separated integers: c and N\n\n\\* Line 2: Three space-separated integers: a1, b1, and d1\n\n\\* Line 3: Three space-separated integers: a2, b2, and d2\n", "outputFormat": "\\* Line 1: A single line which contains a single integer which is the length of the Nth moo\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09MAR] Moon Mooing G", "background": "", "description": "A full moon casts some sort of spell on the cows and, like their cousins the wolves and coyotes, they bay at the moon — mooing instead of howling, of course.\n\nEach \"moo\" lasts a certain amount of time. A short \"moo\" might last time 1; a longer one might last time 24 or even 1,000,000,000 or longer (cows can really moo when they want to). No \"moo\" will last more than or equal to $2^{63}$.\n\nIt should come as no surprise that the cows have a pattern to their moos. Bessie will choose an integer $c$ ($1 \\le c \\le 100$) that is the initial length of a moo.\n\nAfter Bessie moos for length $c$, the cows calculate times for subsequent moos. They apply two formulae to each moo time to yield even more moo times. The two formulae are:\n\n```cpp\nf1(c)=a1*c/d1+b1 (integer divide, of course) and \nf2(c)=a2*c/d2+b2. \nThey then successively use the two new times created by evaluating f1(c) and f2(c) to create even more mooing times. They keep a sorted list of all the possible mooing times (discarding duplicates). \nThey are allowed to moo a total of N times (1 <= N <= 4,000,000). Please determine the length of the longest moo before they must quit. \nThe constants in the formulae have these constraints: 1 <= d1 < a1; d1 < a1 <= 20; 0 <= b1 <= 20; 1 <= d2 < a2; d2 < a2 <= 20; 0 <= b2 <= 20. \nConsider an example where c=3 and N=10. The constants are: \na1=4    b1=3     d1=3 \na2=17   b2=8     d2=2 \n```\n\nThe first mooing time is 3, given by the value of $c$. The total list of mooing times is:\n```cpp\n1. c=3             ->  3       6. f2(3)=17*3/2+8  -> 33 \n2. f1(3)=4*3/3+3   ->  7       7. f1(28)=4*28/3+3 -> 40 \n3. f1(7)=4*7/3+3   -> 12       8. f1(33)=4*33/3+3 -> 47 \n4. f1(12)=4*12/3+3 -> 19       9. f1(40)=4*40/3+3 -> 56 \n5. f1(19)=4*19/3+3 -> 28      10. f1(47)=4*47/3+3 -> 65 \nThe tenth time is 65, which would be the proper answer for this set of inputs. \n```\n\nThey keep a sorted list of all possible moo times (discarding duplicates). They are allowed to moo a total of $N$ times ($1 \\le N \\le 4{,}000{,}000$). Please determine the length of the $N$-th moo.\n\nThe constants in the formulae are integers and satisfy:\n$1 \\le d_1 < a_1 \\le 20$; $0 \\le b_1 \\le 20$;\n$1 \\le d_2 < a_2 \\le 20$; $0 \\le b_2 \\le 20$.\n\nThe two formulae are:\n$f_1(c)=\\lfloor a_1 c / d_1 \\rfloor + b_1$\n$f_2(c)=\\lfloor a_2 c / d_2 \\rfloor + b_2$.", "inputFormat": "- Line 1: Two space-separated integers: $c$ and $N$.\n- Line 2: Three space-separated integers: $a_1$, $b_1$, and $d_1$.\n- Line 3: Three space-separated integers: $a_2$, $b_2$, and $d_2$.", "outputFormat": "- Line 1: A single integer — the length of the $N$-th moo.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09MAR] Moon Mooing G", "background": "", "description": "A full moon casts some sort of spell on the cows and, like their cousins the wolves and coyotes, they bay at the moon -- mooing instead of howling, of course.\n\nEach 'moo' lasts a certain amount of time. A short 'moo' might last time 1; a longer one might last time 24 or even 1,000,000,000 or longer (cows can really moo when they want to). No 'moo' will last more than or equal to 2^63.\n\nIt should come as no surprise that the cows have a pattern to their moos.  Bessie will choose an integer c (1 <= c <= 100) that is the initial length of a moo.\n\nAfter Bessie moos for length c, the cows calculate times for\n\nsubsequent moos. They apply two formulae to each moo time to yield even more moo times. The two formulae are:\n\n```cpp\nf1(c)=a1*c/d1+b1 (integer divide, of course) and \nf2(c)=a2*c/d2+b2. \nThey then successively use the two new times created by evaluating f1(c) and f2(c) to create even more mooing times. They keep a sorted list of all the possible mooing times (discarding duplicates). \nThey are allowed to moo a total of N times (1 <= N <= 4,000,000). Please determine the length of the longest moo before they must quit. \nThe constants in the formulae have these constraints: 1 <= d1 < a1; d1 < a1 <= 20; 0 <= b1 <= 20; 1 <= d2 < a2; d2 < a2 <= 20; 0 <= b2 <= 20. \nConsider an example where c=3 and N=10. The constants are: \na1=4    b1=3     d1=3 \na2=17   b2=8     d2=2 \n```\nThe first mooing time is 3, given by the value of c. The total list of mooing times is:\n```cpp\n1. c=3             ->  3       6. f2(3)=17*3/2+8  -> 33 \n2. f1(3)=4*3/3+3   ->  7       7. f1(28)=4*28/3+3 -> 40 \n3. f1(7)=4*7/3+3   -> 12       8. f1(33)=4*33/3+3 -> 47 \n4. f1(12)=4*12/3+3 -> 19       9. f1(40)=4*40/3+3 -> 56 \n5. f1(19)=4*19/3+3 -> 28      10. f1(47)=4*47/3+3 -> 65 \nThe tenth time is 65, which would be the proper answer for this set of inputs. \n```\nPartial feedback will be provided on the first 50 submissions.\nMEMORY LIMIT: 64MB\n\n满月的时候，和狼一样，牛们也在月光下叫，他们从不嚎叫，而是哞叫。\n\n每次哞叫都有一个时长，可能是 $1$ 秒，可能是 $10^9$ 秒或更久，牛们真的非常能叫.当然，没有哞叫时长会超过或等于 $2^{63}$。\n\n牛们的哞叫可以找到规律，这并不奇怪。贝茜会选择一个整数 $c(c\\le100)$ 来作为初始时长之后，牛们根据两条公式确定更多的时长：\n\n$f_1(c)=\\lfloor a_1c/d_1\\rfloor+b_1$\n\n$f_2(c)=\\lfloor a_2c/d_2\\rfloor+b_2$ \n\n牛们用这两条公式不断地迭代、计算，算得大量的时长.然后她们将这些时长排序，剔除重复的时长，最后取前 $N(1<N< 4000000)$ 个整数为她们 $N$ 次哞叫的时长.请你计算，第 $N$ 次哞叫的时长是多少。公式中的常量均为整数，满足下列关系： \n\n$1 \\le d_1 < a_1 \\le 20$; $0\\le b_1 \\le 20$;\n\n$1 \\le d_2 < a_2 \\le 20$; $0\\le b_2\\le 20$。\n", "inputFormat": "\\* Line 1: Two space-separated integers: c and N\n\n\\* Line 2: Three space-separated integers: a1, b1, and d1\n\n\\* Line 3: Three space-separated integers: a2, b2, and d2\n", "outputFormat": "\\* Line 1: A single line which contains a single integer which is the length of the Nth moo\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2943", "type": "P", "difficulty": 5, "samples": [["13 4 \n1 \n2 \n1 \n3 \n2 \n2 \n3 \n4 \n3 \n4 \n3 \n1 \n4 \n", "11 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2009", "USACO", "枚举"], "title": "[USACO09MAR] Cleaning Up G", "background": "", "description": "In the good old days, Farmer John served a boring cuisine comprising but a single type of cow food to his N (1 <= N <= 40000) prize dairy cows. Times change. Today he serves the herd a total of M (1 <= M <= N) different types of food (conveniently numbered 1..M).\n\nThe cows are picky. Cow i has a single food preference P\\_i (1 <= P\\_i <= M) and will eat only that favorite food.\n\nEach day at feeding time FJ converts the barn into a tastefully lit cafeteria. The cows line up outside to enter the cafeteria in order of their previously-mentioned convenient index number.\n\nUnfortunately, with so many types of food, cleaning up afterwards is very time-consuming. If Farmer John is serving K different types of food, it takes him K\\*K units of time to clean the barn.\n\nTo save time, FJ serves the cows in contiguous groups from the line. After each group, he cleans up the barn and sets out the food for the next group (of course, he only sets out food that cows in the any given group will eat). Determine the minimum amount of total time FJ must spend cleaning the barn. Each group consists of the next contiguous group of cows from the line; each cow belongs to exactly one group; and the barn must be cleaned up after every group, including the last one.\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: P\\_i\n", "outputFormat": "\\* Line 1: A single integer: the minimum amount of time FJ must spend cleaning the  barn.\n", "hint": "There are four types of food and thirteen cows in line. The first cow prefers type 1, the second type 2, the third type 1, etc.\n\n\nThe first four groups contain one cow each. The fifth group contains two cows who prefer food #2 (requiring one unit of time). The sixth group contains cows preferring foods 3, 4, 3, 4, 3 (and requires four units of time to clean). The last two groups contain one cow each. The total time is 11.\n", "locale": "en", "translations": {"en": {"title": "[USACO09MAR] Cleaning Up G", "background": "", "description": "In the good old days, Farmer John served a boring cuisine comprising but a single type of cow food to his N (1 <= N <= 40000) prize dairy cows. Times change. Today he serves the herd a total of M (1 <= M <= N) different types of food (conveniently numbered 1..M).\n\nThe cows are picky. Cow i has a single food preference P\\_i (1 <= P\\_i <= M) and will eat only that favorite food.\n\nEach day at feeding time FJ converts the barn into a tastefully lit cafeteria. The cows line up outside to enter the cafeteria in order of their previously-mentioned convenient index number.\n\nUnfortunately, with so many types of food, cleaning up afterwards is very time-consuming. If Farmer John is serving K different types of food, it takes him K\\*K units of time to clean the barn.\n\nTo save time, FJ serves the cows in contiguous groups from the line. After each group, he cleans up the barn and sets out the food for the next group (of course, he only sets out food that cows in the any given group will eat). Determine the minimum amount of total time FJ must spend cleaning the barn. Each group consists of the next contiguous group of cows from the line; each cow belongs to exactly one group; and the barn must be cleaned up after every group, including the last one.\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: P\\_i\n", "outputFormat": "\\* Line 1: A single integer: the minimum amount of time FJ must spend cleaning the  barn.\n", "hint": "There are four types of food and thirteen cows in line. The first cow prefers type 1, the second type 2, the third type 1, etc.\n\n\nThe first four groups contain one cow each. The fifth group contains two cows who prefer food #2 (requiring one unit of time). The sixth group contains cows preferring foods 3, 4, 3, 4, 3 (and requires four units of time to clean). The last two groups contain one cow each. The total time is 11.\n", "locale": "en"}, "zh-CN": {"title": "[USACO09MAR] Cleaning Up G", "background": null, "description": "在过去的好日子里，农夫约翰只为他的 $N$（$1 \\leq N \\leq 40000$）头优质奶牛提供一种单一类型的牛饲料。时光流逝，如今他为牛群提供总共 $M$（$1 \\leq M \\leq N$）种不同类型的食物（方便地编号为 $1$ 到 $M$）。\n\n奶牛们很挑剔。奶牛 $i$ 只有一个食物偏好 $P_i$（$1 \\leq P_i \\leq M$），并且只吃那种最喜欢的食物。\n\n每天喂食时间，FJ 将谷仓改造成一个灯光优雅的自助餐厅。奶牛们按照之前提到的方便索引编号排队进入餐厅。\n\n不幸的是，由于食物种类繁多，事后清理工作非常耗时。如果农夫约翰提供 $K$ 种不同类型的食物，他需要花费 $K \\times K$ 单位的时间来清理谷仓。\n\n为了节省时间，FJ 将奶牛按连续的组来喂食。每组之后，他清理谷仓并为下一组准备食物（当然，他只准备给定组中的奶牛会吃的食物）。请确定 FJ 清理谷仓所需的最少总时间。每组由队列中下一个连续的奶牛组组成；每头奶牛只属于一个组；每组之后，包括最后一组，谷仓都必须清理。", "inputFormat": "第 $1$ 行两个用空格分隔的整数 $N$ 和 $M$。\n\n第 $2$ 行到第 $N+1$ 行：第 $i+1$ 行包含一个整数 $P_i$。", "outputFormat": "第 1 行一个整数：FJ 清理谷仓所需的最少时间。", "hint": "有四种类型的食物和十三头奶牛排队。第一头奶牛喜欢类型 $1$，第二头喜欢类型 $2$，第三头喜欢类型 $1$，等等。\n\n前四组每组包含一头奶牛。第五组包含两头喜欢食物 $2$ 的奶牛（需要一单位时间）。第六组包含喜欢食物 $3$、$4$、$3$、$4$、$3$ 的奶牛（需要四单位时间清理）。最后两组每组包含一头奶牛。总时间是 $11$。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2944", "type": "P", "difficulty": 6, "samples": [["5 5 2 \n1 2 \n2 3 \n3 5 \n2 4 \n4 5 \n4 \n5 \n", "1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "USACO", "网络流", "图论建模", "最小割"], "title": "[USACO09MAR] Earthquake Damage 2 G", "background": null, "description": "威斯康辛州发生地震，袭击了农夫约翰的农场！地震摧毁了部分牧场。令人惊讶的是，所有的路径均未受损。\n\n农夫约翰的农场有 $P\\ (1 \\le P \\le 3,000)$ 个牧场，牧场依次编号为 $1$ 至 $P$。牧场通过 $C\\ (1 \\le C \\le 20,000)$ 条双向路径相连，路径依次编号为 $1$ 至 $C$。第 $i$ 条路径连接牧场 $a_i$ 和 $b_i\\ (1 \\le a_i,b_i \\le P)$。路径可能连接同一牧场，也可能重复连接两个牧场。牛棚位于牧场 $1$。\n\n共有位于不同牧场的 $N\\ (1 \\le N \\le P)$ 头奶牛依次通过手机向农夫约翰报告它们所位于的牧场的编号，第 $j$ 头奶牛报告的编号为 $report_j\\ (2 \\le report_j \\le P)$，表明虽然牧场 $report_j$ 没有被摧毁，但报告的奶牛找不到一条可以在不经过被摧毁牧场的前提下从 $report_j$ 返回牛棚的路径。\n\n所有奶牛报告完毕后，请确定被摧毁牧场的最小数量。", "inputFormat": "第 $1$ 行：三个以空格分隔的整数，分别表示 $P$，$C$ 和 $N$。\n\n第 $2$ 到 $C+1$ 行：第 $i+1$ 行包含两个整数，表示一条连接牧场 $a_i$ 和 $b_i$ 的双向路径。\n\n第 $C+2$ 到 $C+N+1$ 行：第 $C+1+j$ 行包含一个整数，表示 $report_j$。", "outputFormat": "第 $1$ 行：一个整数，表示被摧毁牧场的最小数量。", "hint": "只有牧场 $2$ 被摧毁才会出现这种情况。", "locale": "zh-CN", "translations": {"en": {"title": null, "background": null, "description": "Wisconsin has had an earthquake that has struck Farmer John's farm! The earthquake has damaged some of the pastures so that they are unpassable. Remarkably, none of the cowpaths was damaged.\n\nAs usual, the farm is modeled as a set of $P\\ (1 \\le P \\le 3,000)$ pastures conveniently numbered $1\\cdots P$ which are connected by a set of $C\\ (1 \\le C \\le 20,000)$ non-directional cowpaths conveniently numbered $1\\dots C$. Cowpath $i$ connects pastures $a_i$ and $b_i\\ (1 \\le a_i,b_i \\le P)$. Cowpaths might connect $a_i$ to itself or perhaps might connect two pastures more than once. The barn is located in pasture $1$.\n\nA total of $N\\ (1 \\le N \\le P)$ cows (in different pastures) sequentially contacts Farmer John via moobile phone with an integer message $report_j\\ (2 \\le report_j \\le P)$ that indicates that pasture $report_j$ is undamaged but that the calling cow is unable to return to the barn from pasture $report_j$ because she could not find a path that does not go through damaged pastures.\n\nAfter all the cows report in, determine the minimum number of pastures that are damaged.", "inputFormat": "Line $1$: Three space-separated integers: $P$, $C$, and $N$.\n\nLines $2\\dots C+1$: Line $i+1$ describes cowpath $i$ with two integers: $a_i$ and $b_i$.\n\nLines $C+2\\dots C+N+1$: Line $C+1+j$ contains a single integer: $report_j$", "outputFormat": "Line $1$: One number, the minimum number of damaged pastures.", "hint": "Only pasture $2$ being damaged gives such a scenario.", "locale": "en"}, "zh-CN": {"title": "[USACO09MAR] Earthquake Damage 2 G", "background": null, "description": "威斯康辛州发生地震，袭击了农夫约翰的农场！地震摧毁了部分牧场。令人惊讶的是，所有的路径均未受损。\n\n农夫约翰的农场有 $P\\ (1 \\le P \\le 3,000)$ 个牧场，牧场依次编号为 $1$ 至 $P$。牧场通过 $C\\ (1 \\le C \\le 20,000)$ 条双向路径相连，路径依次编号为 $1$ 至 $C$。第 $i$ 条路径连接牧场 $a_i$ 和 $b_i\\ (1 \\le a_i,b_i \\le P)$。路径可能连接同一牧场，也可能重复连接两个牧场。牛棚位于牧场 $1$。\n\n共有位于不同牧场的 $N\\ (1 \\le N \\le P)$ 头奶牛依次通过手机向农夫约翰报告它们所位于的牧场的编号，第 $j$ 头奶牛报告的编号为 $report_j\\ (2 \\le report_j \\le P)$，表明虽然牧场 $report_j$ 没有被摧毁，但报告的奶牛找不到一条可以在不经过被摧毁牧场的前提下从 $report_j$ 返回牛棚的路径。\n\n所有奶牛报告完毕后，请确定被摧毁牧场的最小数量。", "inputFormat": "第 $1$ 行：三个以空格分隔的整数，分别表示 $P$，$C$ 和 $N$。\n\n第 $2$ 到 $C+1$ 行：第 $i+1$ 行包含两个整数，表示一条连接牧场 $a_i$ 和 $b_i$ 的双向路径。\n\n第 $C+2$ 到 $C+N+1$ 行：第 $C+1+j$ 行包含一个整数，表示 $report_j$。", "outputFormat": "第 $1$ 行：一个整数，表示被摧毁牧场的最小数量。", "hint": "只有牧场 $2$ 被摧毁才会出现这种情况。", "locale": "zh-CN"}}}
{"pid": "P2945", "type": "P", "difficulty": 2, "samples": [["3 6 5 \n3 1 \n1 2 \n1 2 \n", "11 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2009", "USACO"], "title": "[USACO09MAR] Sand Castle S", "background": "", "description": "Farmer John has built a sand castle! Like all good castles, the walls have crennelations, that nifty pattern of embrasures (gaps) and merlons (filled spaces); see the diagram below. The N (1 <= N <= 25,000) merlons of his castle wall are conveniently numbered 1..N; merlon i has height M\\_i (1 <= M\\_i <= 100,000); his merlons often have varying heights, unlike so many.\n\nHe wishes to modify the castle design in the following fashion: he has a list of numbers B\\_1 through B\\_N (1 <= B\\_i <= 100,000), and wants to change the merlon heights to those heights B\\_1, ..., B\\_N in some order (not necessarily the order given or any other order derived from the data).\n\nTo do this, he has hired some bovine craftsmen to raise and lower the merlons' heights. Craftsmen, of course, cost a lot of money. In particular, they charge FJ a total X (1 <= X <= 100) money per unit height added and Y (1 <= Y <= 100) money per unit height\n\nreduced.\n\nFJ would like to know the cheapest possible cost of modifying his sand castle if he picks the best permutation of heights. The answer is guaranteed to fit within a 32-bit signed integer.\n\nNote: about 40% of the test data will have N <= 9, and about 60% will have N <= 18.", "inputFormat": "\\* Line 1: Three space-separated integers: N, X, and Y\n\n\\* Lines 2..N+1: Line i+1 contains the two space-separated integers: M\\_i and B\\_i\n", "outputFormat": "\\* Line 1: A single integer, the minimum cost needed to rebuild the castle\n", "hint": "FJ's castle starts with heights of 3, 1, and 1. He would like to change them so that their heights are 1, 2, and 2, in some order. It costs 6 to add a unit of height and 5 to remove a unit of height.\n\n\nFJ reduces the first merlon's height by 1, for a cost of 5 (yielding merlons of heights 2, 1, and 1). He then adds one unit of height to the second merlon for a cost of 6 (yielding merlons of heights 2, 2, and 1).\n", "locale": "en", "translations": {"en": {"title": "[USACO09MAR] Sand Castle S", "background": "", "description": "Farmer John has built a sand castle! Like all good castles, the walls have crennelations, that nifty pattern of embrasures (gaps) and merlons (filled spaces); see the diagram below. The N (1 <= N <= 25,000) merlons of his castle wall are conveniently numbered 1..N; merlon i has height M\\_i (1 <= M\\_i <= 100,000); his merlons often have varying heights, unlike so many.\n\nHe wishes to modify the castle design in the following fashion: he has a list of numbers B\\_1 through B\\_N (1 <= B\\_i <= 100,000), and wants to change the merlon heights to those heights B\\_1, ..., B\\_N in some order (not necessarily the order given or any other order derived from the data).\n\nTo do this, he has hired some bovine craftsmen to raise and lower the merlons' heights. Craftsmen, of course, cost a lot of money. In particular, they charge FJ a total X (1 <= X <= 100) money per unit height added and Y (1 <= Y <= 100) money per unit height\n\nreduced.\n\nFJ would like to know the cheapest possible cost of modifying his sand castle if he picks the best permutation of heights. The answer is guaranteed to fit within a 32-bit signed integer.\n\nNote: about 40% of the test data will have N <= 9, and about 60% will have N <= 18.", "inputFormat": "\\* Line 1: Three space-separated integers: N, X, and Y\n\n\\* Lines 2..N+1: Line i+1 contains the two space-separated integers: M\\_i and B\\_i\n", "outputFormat": "\\* Line 1: A single integer, the minimum cost needed to rebuild the castle\n", "hint": "FJ's castle starts with heights of 3, 1, and 1. He would like to change them so that their heights are 1, 2, and 2, in some order. It costs 6 to add a unit of height and 5 to remove a unit of height.\n\n\nFJ reduces the first merlon's height by 1, for a cost of 5 (yielding merlons of heights 2, 1, and 1). He then adds one unit of height to the second merlon for a cost of 6 (yielding merlons of heights 2, 2, and 1).\n", "locale": "en"}, "zh-CN": {"title": "[USACO09MAR] Sand Castle S", "background": "", "description": "农夫 John 建造了一座沙堡！像所有好的城堡一样，城墙上有垛口，那种由垛口（空隙）和垛堞（填充空间）组成的精巧图案；见下图。他的城堡墙上的 N（1 <= N <= 25,000）个垛堞被方便地编号为 1 到 N；垛堞 i 的高度为 $M_i$（1 <= $M_i$ <= 100,000）；他的垛堞高度常常不同，这与许多其他的不同。\n\n他希望以以下方式修改城堡设计：他有一个从 $B_1$ 到 $B_N$（1 <= $B_i$ <= 100,000）的数字列表，并希望将垛堞的高度更改为这些高度 $B_1, ..., B_N$ 的某种顺序（不一定是给定的顺序或从数据派生的任何其他顺序）。\n\n为此，他雇佣了一些牛工匠来增加和降低垛堞的高度。当然，工匠们要价很高。特别是，他们向 FJ 收取总共 $X$（1 <= $X$ <= 100）每单位高度增加的钱和 $Y$（1 <= $Y$ <= 100）每单位高度减少的钱。\n\nFJ 想知道如果他选择最佳的高度排列，修改他的沙堡的最低可能成本是多少。答案保证适合 32 位有符号整数。\n\n注意：大约 40% 的测试数据将有 N <= 9，大约 60% 将有 N <= 18。", "inputFormat": "\\* 第 1 行：三个用空格分隔的整数：N, X 和 Y\n\n\\* 第 2 行到第 N+1 行：第 i+1 行包含两个用空格分隔的整数：$M_i$ 和 $B_i$\n", "outputFormat": "\\* 第 1 行：一个整数，重建城堡所需的最低成本\n", "hint": "FJ 的城堡起始高度为 3, 1 和 1。他希望将它们的高度更改为 1, 2 和 2，以某种顺序。增加一个单位高度的成本为 6，减少一个单位高度的成本为 5。\n\n\nFJ 将第一个垛堞的高度减少 1，成本为 5（得到高度为 2, 1 和 1 的垛堞）。然后他为第二个垛堞增加一个单位的高度，成本为 6（得到高度为 2, 2 和 1 的垛堞）。\n（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P2946", "type": "P", "difficulty": 3, "samples": [["4 5 \n1 \n2 \n8 \n2 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "USACO", "背包 DP"], "title": "[USACO09MAR] Cow Frisbee Team S", "background": "", "description": "老唐最近迷上了飞盘，约翰想和他一起玩，于是打算从他家的 $N$ 头奶牛中选出一支队伍。\n\n每只奶牛的能力为整数，第 $i$ 头奶牛的能力为 $R_i$。飞盘队的队员数量不能少于 $1$、大于 $N$。一支队伍的总能力就是所有队员能力的总和。\n\n约翰比较迷信，他的幸运数字是 $F$，所以他要求队伍的总能力必须是 $F$ 的倍数。请帮他算一下，符合这个要求的队伍组合有多少？由于这个数字很大，只要输出答案对 $10^8$ 取模的值。", "inputFormat": "第一行：两个用空格分开的整数：$N$ 和 $F$。\n\n第二行到 $N+1$ 行：第 $i+1$ 行有一个整数 $R_i$，表示第 $i$ 头奶牛的能力。", "outputFormat": "第一行：单个整数，表示方案数对 $10^8$ 取模的值。", "hint": "对于 $100\\%$ 的数据，$1 \\le N \\le 2000$，$1 \\le F \\le 1000$，$1 \\le R_i \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09MAR] Cow Frisbee Team S", "background": "", "description": "Lao Tang has recently gotten into frisbee, and John wants to play with him, so he plans to select a team from his $N$ cows.\n\nEach cow has an integer ability. The $i$-th cow’s ability is $R_i$. The number of players on the frisbee team must be between $1$ and $N$ inclusive. A team’s total ability is the sum of the abilities of all its members.\n\nJohn is superstitious, and his lucky number is $F$, so he requires the team’s total ability to be a multiple of $F$. Please compute how many team selections satisfy this requirement. Since this number can be very large, output the answer modulo $10^8$.", "inputFormat": "The first line contains two space-separated integers: $N$ and $F$.\n\nLines $2$ through $N+1$: line $i+1$ contains an integer $R_i$, the ability of the $i$-th cow.", "outputFormat": "A single integer: the number of valid selections modulo $10^8$.", "hint": "For $100\\%$ of the testdata, $1 \\le N \\le 2000$, $1 \\le F \\le 1000$, $1 \\le R_i \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09MAR] Cow Frisbee Team S", "background": "", "description": "老唐最近迷上了飞盘，约翰想和他一起玩，于是打算从他家的 $N$ 头奶牛中选出一支队伍。\n\n每只奶牛的能力为整数，第 $i$ 头奶牛的能力为 $R_i$。飞盘队的队员数量不能少于 $1$、大于 $N$。一支队伍的总能力就是所有队员能力的总和。\n\n约翰比较迷信，他的幸运数字是 $F$，所以他要求队伍的总能力必须是 $F$ 的倍数。请帮他算一下，符合这个要求的队伍组合有多少？由于这个数字很大，只要输出答案对 $10^8$ 取模的值。", "inputFormat": "第一行：两个用空格分开的整数：$N$ 和 $F$。\n\n第二行到 $N+1$ 行：第 $i+1$ 行有一个整数 $R_i$，表示第 $i$ 头奶牛的能力。", "outputFormat": "第一行：单个整数，表示方案数对 $10^8$ 取模的值。", "hint": "对于 $100\\%$ 的数据，$1 \\le N \\le 2000$，$1 \\le F \\le 1000$，$1 \\le R_i \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P2947", "type": "P", "difficulty": 3, "samples": [["6 \n3 \n2 \n6 \n1 \n1 \n2 \n", "3 \n3 \n0 \n6 \n6 \n0 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2009", "USACO", "单调栈"], "title": "[USACO09MAR] Look Up S", "background": null, "description": "约翰的 $N(1\\le N\\le10^5)$ 头奶牛站成一排，奶牛 $i$ 的身高是 $H_i(1\\le H_i\\le10^6)$。现在，每只奶牛都在向右看。对于奶牛 $i$，如果奶牛 $j$ 满足 $i<j$ 且 $H_i<H_j$，我们可以说奶牛 $i$ 可以仰望奶牛 $j$。 求出每只奶牛离她最近的仰望对象。", "inputFormat": "第 $1$ 行输入 $N$，之后 $N$ 行第 $i+1$ 行输入一个身高 $H_i$。", "outputFormat": "共 $N$ 行，按顺序每行输出一只奶牛的最近仰望对象，如果没有仰望对象，输出 $0$。", "hint": "**【输入说明】**\n\n$6$ 头奶牛的身高分别为 $3$, $2$, $6$, $1$, $1$, $2$。\n\n**【输出说明】**\n\n奶牛 $1,2$ 仰望奶牛 $3$，奶牛 $4,5$ 仰望奶牛 $6$，奶牛 $3$ 和 $6$ 没有仰望对象。\n\n**【数据规模】**\n\n对于 $20\\%$ 的数据：$1\\le N\\le10$；\n\n对于 $50\\%$ 的数据：$1\\le N\\le10^3$；\n\n对于 $100\\%$ 的数据：$1\\le N\\le10^5,1\\le H_i\\le10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09MAR] Look Up S", "background": null, "description": "Farmer John's $N(1 \\le N \\le 10^5)$ cows, conveniently numbered $1$ to $N$, are once again standing in a row. Cow $i$ has height $H_i(1 \\le H_i \\le 10^6)$.\n\nEach cow is looking to her right toward those with higher index numbers. We say that cow $i$ \"looks up to\" cow $j$ if $i < j$ and $H_i < H_j$. For each cow $i$, FJ would like to know the index of the first cow in line \"looked up to\" by cow $i$.\n\nNote: about $50\\%$ of the test data will have $N \\le 10^3$.", "inputFormat": "Line $1$ : A single integer: $N$.\n\nLines $2$ to $N+1$ : Line $i+1$ contains the single integer: $H_i$.", "outputFormat": "Lines $1$ to $N$: Line $i$ contains a single integer representing the smallest index of a cow up to which cow $i$ looks. If no such cow exists, print $0$.", "hint": "FJ has six cows of heights $3$, $2$, $6$, $1$, $1$, and $2$.\n\n\nCows $1$ and $2$ both look up to cow $3$; cows $4$ and $5$ both look up to cow $6$. Cows $3$ and $6$ do not look up to any cow.", "locale": "en"}, "zh-CN": {"title": "[USACO09MAR] Look Up S", "background": null, "description": "约翰的 $N(1\\le N\\le10^5)$ 头奶牛站成一排，奶牛 $i$ 的身高是 $H_i(1\\le H_i\\le10^6)$。现在，每只奶牛都在向右看。对于奶牛 $i$，如果奶牛 $j$ 满足 $i<j$ 且 $H_i<H_j$，我们可以说奶牛 $i$ 可以仰望奶牛 $j$。 求出每只奶牛离她最近的仰望对象。", "inputFormat": "第 $1$ 行输入 $N$，之后 $N$ 行第 $i+1$ 行输入一个身高 $H_i$。", "outputFormat": "共 $N$ 行，按顺序每行输出一只奶牛的最近仰望对象，如果没有仰望对象，输出 $0$。", "hint": "**【输入说明】**\n\n$6$ 头奶牛的身高分别为 $3$, $2$, $6$, $1$, $1$, $2$。\n\n**【输出说明】**\n\n奶牛 $1,2$ 仰望奶牛 $3$，奶牛 $4,5$ 仰望奶牛 $6$，奶牛 $3$ 和 $6$ 没有仰望对象。\n\n**【数据规模】**\n\n对于 $20\\%$ 的数据：$1\\le N\\le10$；\n\n对于 $50\\%$ 的数据：$1\\le N\\le10^3$；\n\n对于 $100\\%$ 的数据：$1\\le N\\le10^5,1\\le H_i\\le10^6$。", "locale": "zh-CN"}}}
