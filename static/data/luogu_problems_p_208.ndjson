{"pid": "P5206", "type": "P", "difficulty": 7, "samples": [["3 2 0\n1 2\n2 3\n1 2\n2 3", "2\n"], ["3 2 1\n1 2\n2 3", "10"], ["3 2 2\n", "30\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "树形 DP", "组合数学", "生成函数", "拉格朗日反演", "WC"], "title": "[WC2019] 数树", "background": "白兔喜欢树。\n\n白云喜欢数数。\n\n有 $n$ 只鼠，白兔用 $n - 1$ 根蓝色绳子把它们连成了一棵树，每根蓝色绳子连着两只鼠，白云用 $n - 1$ 根红色绳子把它们连成了一棵树，每根红色绳子连接着两只鼠。\n\n白云要给予每只鼠一个数。这个数可以是 $[1, y]$ 中的任意一个整数。\n\n白兔给了白云一个要求：对于两只鼠 $p, q$，若存在一条连接这两只鼠的路径同时属于这两棵树，则 $p$ 和 $q$ 必须被给予相同的整数。存在一条路径同时属于这两棵树指的是：存在一个序列 $(a_1 = p, a_2, \\cdots , a_m = q)$，使得：对于所有 $i \\in [1, m - 1]$，都有 $a_i$ 和 $a_{i+1}$ 既有一根红色绳子直接相连也有一根蓝色绳子直接相连。\n\n白云想知道，她有多少种给予数的方案呢？\n\n鼠在不停地挣扎，想要摆脱绳子的束缚。白云还没有思考出来，鼠便把红色绳子都咬断了。\n\n白兔有些气恼，但是他还是想要知道答案。他便问白云：对于所有红色绳子的连接方案，答案的总和（即求所有红色绳子连接方案的给予数方案之和）是多少？\n\n鼠在不停地挣扎，想要摆脱绳子的束缚。白云还没有思考出来，鼠便把蓝色绳子也咬断了。\n\n白兔有些气恼，但是他还是想要知道答案。他便问白云：对于所有红色和蓝色绳子的连接方案，答案的总和（即求所有红色和蓝色绳子连接方案的给予数方案之和）是多少？两个方案不同当且仅当存在至少一对鼠，在两种方案中，这两只鼠之间直接连接的绳子不同（两只鼠之间连接绳子的可能性有 4 种：没有绳子直接连接，只有红色绳子直接连接，只有蓝色绳子直接连接，两种颜色的绳子均直接连接）。\n\n白云哭了。", "description": "本题包含三个问题：\n- 问题 0：已知两棵 $n$ 个节点的树的形态（两棵树的节点标号均为 $1$ 至 $n$），其中第一棵树是红树，第二棵树是蓝树。要给予每个节点一个 $[1, y]$ 中的整数，使得对于任意两个节点 $p, q$，如果存在一条路径 $(a_1 = p, a_2, \\cdots , a_m = q)$ 同时属于这两棵树，则 $p, q$ 必须被给予相同的数。求给予数的方案数。\n  - 存在一条路径同时属于这两棵树的定义见「题目背景」。\n- 问题 1：已知蓝树，对于红树的所有 $n^{n-2}$ 种选择方案，求问题 0 的答案之和。\n- 问题 2：对于蓝树的所有 $n^{n-2}$ 种选择方案，求问题 1 的答案之和。\n\n提示：$n$ 个节点的树一共有 $n^{n-2}$ 种。\n\n在不同的测试点中，你将可能需要回答不同的问题。我们将用 $\\text{op}$ 来指代你需要回答的问题编号（对应上述 0、 1、 2）。\n\n由于答案可能很大，因此你只需要输出答案对 $998, 244, 353$ 取模的结果即可。", "inputFormat": "第一行三个用空格隔开的整数 $n, y, \\text{op}$。\n如果 $\\text{op} = 0$，则接下来 $2 \\times (n - 1)$ 行，前 $(n - 1)$ 行每描述一条蓝色绳子，接下来 $(n - 1)$ 行每行描述一条红色绳子。  \n如果 $\\text{op} = 1$，则接下来 $(n - 1)$ 行，每行描述一条蓝色绳子。  \n如果 $\\text{op} = 2$，则接下来没有输入。  \n描述绳子的各行将包含两个用空格隔开的整数，分别表示被这条绳子连接的两只鼠的编号。鼠的编号是从 $1$ 开始的。", "outputFormat": "输出一个整数，表示答案对 $998, 244, 353$ 取模的结果。", "hint": "#### 样例说明 1\n两棵树相同，所以任意两个点都必须被给予相同的数，方案数为 $2$。\n\n#### 样例说明 2\n红树共有三种可能的情况：\n1. 包含绳子 $(1, 2)$（表示连接 $1, 2$ 号鼠的绳子，下同）、$(2, 3)$：此时任意两只鼠都必须被给予相同的数，问题 0 的答案为 $2$。\n2. 包含绳子 $(1, 2)$、$(1, 3)$：此时 $1$ 号鼠和 $2$ 号鼠必须被给予相同的数，问题 0 的答案为 $2 \\times 2 = 4$。\n3. 包含绳子 $(2, 3)$、$(1, 3)$：此时 $2$ 号点和 $3$ 号点必须被给予相同的数，问题 0 的答案为 $2 \\times 2 = 4$。\n\n综上，问题 1 的答案为 $2 + 4 + 4 = 10$。\n\n#### 样例说明 3\n蓝树一共有三种可能的情况。不难发现，对于蓝树的每一种情况，求得的问题 1 的答案都是 $10$。所以答案为 $10 \\times 3 = 30$。\n\n::cute-table{tuack}\n\n| 问题类型 $(\\mathrm{op})$ | 测试点编号 | $n$ | $y$ | 集训队每点分值 | 非集训队每点分值 |\n|:---:|:---:|:---:|:---:|:---:|:---:|\n| **0** | 1 | $\\le 10$ | 无特殊限制 | 2 | 18 |\n| ^ | 2 | $\\le 10^{5}$ | ^ | ^ | 5 |\n| ^ | 3 | ^ | ^ | ^ | ^ |\n| **1** | 4 | $=3$ | ^ | 1 |4 |\n| ^ | 5 | $=5$ | ^ | ^ |^ |\n| ^ | 6 | $\\le 500$ | ^ | 6 | ^ |\n| ^ | 7 | ^ | ^ | ^ | ^ |\n| ^ | 8 | $\\le 5000$ | ^ | ^ |^ |\n| ^ | 9 | ^ | ^ | ^ |^ |\n| ^ | 10 | $\\le 10^{5}$ | $=1$ | 1 |^ |\n| ^ | 11 | ^ | 无特殊限制 | 5 | 2 |\n| ^ | 12 | ^ | ^ | ^ | ^ |\n| ^ | 13 | ^ | ^ | ^ | ^ |\n| ^ | 14 | ^ | ^ | ^ | ^ |\n| **2** | 15 | $=3$ | ^ | 1 | 4 |\n| ^ | 16 | $=10$ | ^ | ^ | ^ |\n| ^ | 17 | $\\le 500$ | ^ | 6 | ^ |\n| ^ | 18 | ^ | ^ | ^ | ^ |\n| ^ | 19 | $\\le 5000$ | ^ | ^ | ^ |\n| ^ | 20 | ^ | ^ | ^ | ^ |\n| ^ | 21 | $\\le 10^{5}$ | $=1$ | 1 | ^ |\n| ^ | 22 | ^ | 无特殊限制 | 5 | 2 |\n| ^ | 23 | ^ | ^ | ^ | ^ |\n| ^ | 24 | ^ | ^ | ^ | ^ |\n| ^ | 25 | ^ | ^ | ^ | ^ |\n\n为了优化你的阅读体验，我们把**测试点编号**放在了表格的中间，请注意这一点。\n\n所有测试点均满足  $3 \\leq n \\leq 10^{5}, 1 \\leq y<998244353, o p \\in\\{0,1,2\\} $ 。\n\n## 洛谷按照集训队分值赋分", "locale": "zh-CN", "translations": {"en": {"title": "[WC2019] Counting Trees", "background": "The white rabbit likes trees.\n\nThe white cloud likes counting.\n\nThere are $n$ mice. The white rabbit uses $n - 1$ blue ropes to connect them into a tree; each blue rope connects two mice. The white cloud uses $n - 1$ red ropes to connect them into a tree; each red rope connects two mice.\n\nThe white cloud wants to assign a number to each mouse. This number can be any integer in $[1, y]$.\n\nThe white rabbit gives the white cloud a requirement: for two mice $p, q$, if there exists a path connecting these two mice that belongs to both trees, then $p$ and $q$ must be assigned the same integer.  \n“Having a path that belongs to both trees” means: there exists a sequence $(a_1 = p, a_2, \\cdots , a_m = q)$ such that for all $i \\in [1, m - 1]$, $a_i$ and $a_{i+1}$ are directly connected by both a red rope and a blue rope.\n\nThe white cloud wants to know: how many different assignment schemes are there?\n\nThe mice keep struggling, trying to break free from the ropes. Before the white cloud can figure it out, the mice bite off all the red ropes.\n\nThe white rabbit is somewhat annoyed, but still wants to know the answer. So he asks the white cloud: over all possible connection schemes of the red ropes, what is the total sum of the answers (that is, sum the number of assignment schemes over all red-rope connection schemes)?\n\nThe mice keep struggling, trying to break free from the ropes. Before the white cloud can figure it out, the mice bite off the blue ropes as well.\n\nThe white rabbit is somewhat annoyed, but still wants to know the answer. So he asks the white cloud: over all possible connection schemes of both the red ropes and the blue ropes, what is the total sum of the answers (that is, sum the number of assignment schemes over all red-rope and blue-rope connection schemes)? Two schemes are different if and only if there exists at least one pair of mice such that the ropes directly connecting these two mice are different in the two schemes (there are 4 possibilities for ropes between two mice: no rope directly connects them, only a red rope directly connects them, only a blue rope directly connects them, and both colors of ropes directly connect them).\n\nThe white cloud cries.", "description": "This problem contains three questions:\n- Question 0: The shapes of two trees with $n$ nodes are given (both trees have nodes labeled from $1$ to $n$). The first tree is the red tree, and the second tree is the blue tree. You need to assign each node an integer in $[1, y]$ such that for any two nodes $p, q$, if there exists a path $(a_1 = p, a_2, \\cdots , a_m = q)$ that belongs to both trees, then $p, q$ must be assigned the same number. Find the number of assignment schemes.\n  - The definition of “there exists a path that belongs to both trees” is the same as in the “Background”.\n- Question 1: The blue tree is given. For all $n^{n-2}$ choices of the red tree, compute the sum of the answers to Question 0.\n- Question 2: For all $n^{n-2}$ choices of the blue tree, compute the sum of the answers to Question 1.\n\nHint: There are $n^{n-2}$ different trees on $n$ nodes.\n\nIn different test points, you may need to answer different questions. We use $\\text{op}$ to denote the index of the question you need to answer (corresponding to 0, 1, 2 above).\n\nSince the answer may be very large, you only need to output it modulo $998, 244, 353$.", "inputFormat": "The first line contains three integers $n, y, \\text{op}$ separated by spaces.  \nIf $\\text{op} = 0$, then the next $2 \\times (n - 1)$ lines follow: the first $(n - 1)$ lines each describe a blue rope, and the next $(n - 1)$ lines each describe a red rope.  \nIf $\\text{op} = 1$, then the next $(n - 1)$ lines follow, each describing a blue rope.  \nIf $\\text{op} = 2$, then there is no further input.  \nEach rope description line contains two integers separated by a space, representing the indices of the two mice connected by this rope. The mice are numbered starting from $1$.", "outputFormat": "Output one integer, representing the answer modulo $998, 244, 353$.", "hint": "#### Sample Explanation 1\nThe two trees are the same, so any two nodes must be assigned the same number. The number of schemes is $2$.\n\n#### Sample Explanation 2\nThere are three possible red trees:\n1. Contains ropes $(1, 2)$ (meaning the rope connecting mice $1$ and $2$, similarly below), $(2, 3)$. Then any two mice must be assigned the same number, so the answer to Question 0 is $2$.\n2. Contains ropes $(1, 2)$, $(1, 3)$. Then mice $1$ and $2$ must be assigned the same number, so the answer to Question 0 is $2 \\times 2 = 4$.\n3. Contains ropes $(2, 3)$, $(1, 3)$. Then node $2$ and node $3$ must be assigned the same number, so the answer to Question 0 is $2 \\times 2 = 4$.\n\nTherefore, the answer to Question 1 is $2 + 4 + 4 = 10$.\n\n#### Sample Explanation 3\nThere are three possible blue trees. It is not hard to see that for each blue tree, the computed answer to Question 1 is $10$. So the answer is $10 \\times 3 = 30$.\n\n::cute-table{tuack}\n\n| Question Type $(\\mathrm{op})$ | Test Point ID | $n$ | $y$ | Points per Test (CTT) | Points per Test (Non-CTT) |\n|:---:|:---:|:---:|:---:|:---:|:---:|\n| **0** | 1 | $\\le 10$ | No special restriction | 2 | 18 |\n| ^ | 2 | $\\le 10^{5}$ | ^ | ^ | 5 |\n| ^ | 3 | ^ | ^ | ^ | ^ |\n| **1** | 4 | $=3$ | ^ | 1 | 4 |\n| ^ | 5 | $=5$ | ^ | ^ | ^ |\n| ^ | 6 | $\\le 500$ | ^ | 6 | ^ |\n| ^ | 7 | ^ | ^ | ^ | ^ |\n| ^ | 8 | $\\le 5000$ | ^ | ^ | ^ |\n| ^ | 9 | ^ | ^ | ^ | ^ |\n| ^ | 10 | $\\le 10^{5}$ | $=1$ | 1 | ^ |\n| ^ | 11 | ^ | No special restriction | 5 | 2 |\n| ^ | 12 | ^ | ^ | ^ | ^ |\n| ^ | 13 | ^ | ^ | ^ | ^ |\n| ^ | 14 | ^ | ^ | ^ | ^ |\n| **2** | 15 | $=3$ | ^ | 1 | 4 |\n| ^ | 16 | $=10$ | ^ | ^ | ^ |\n| ^ | 17 | $\\le 500$ | ^ | 6 | ^ |\n| ^ | 18 | ^ | ^ | ^ | ^ |\n| ^ | 19 | $\\le 5000$ | ^ | ^ | ^ |\n| ^ | 20 | ^ | ^ | ^ | ^ |\n| ^ | 21 | $\\le 10^{5}$ | $=1$ | 1 | ^ |\n| ^ | 22 | ^ | No special restriction | 5 | 2 |\n| ^ | 23 | ^ | ^ | ^ | ^ |\n| ^ | 24 | ^ | ^ | ^ | ^ |\n| ^ | 25 | ^ | ^ | ^ | ^ |\n\nTo optimize your reading experience, we placed the **Test Point ID** in the middle of the table; please pay attention to this.\n\nAll test points satisfy $3 \\leq n \\leq 10^{5}, 1 \\leq y<998244353, o p \\in\\{0,1,2\\} $.\n\n## Luogu scores according to CTT points\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2019] 数树", "background": "白兔喜欢树。\n\n白云喜欢数数。\n\n有 $n$ 只鼠，白兔用 $n - 1$ 根蓝色绳子把它们连成了一棵树，每根蓝色绳子连着两只鼠，白云用 $n - 1$ 根红色绳子把它们连成了一棵树，每根红色绳子连接着两只鼠。\n\n白云要给予每只鼠一个数。这个数可以是 $[1, y]$ 中的任意一个整数。\n\n白兔给了白云一个要求：对于两只鼠 $p, q$，若存在一条连接这两只鼠的路径同时属于这两棵树，则 $p$ 和 $q$ 必须被给予相同的整数。存在一条路径同时属于这两棵树指的是：存在一个序列 $(a_1 = p, a_2, \\cdots , a_m = q)$，使得：对于所有 $i \\in [1, m - 1]$，都有 $a_i$ 和 $a_{i+1}$ 既有一根红色绳子直接相连也有一根蓝色绳子直接相连。\n\n白云想知道，她有多少种给予数的方案呢？\n\n鼠在不停地挣扎，想要摆脱绳子的束缚。白云还没有思考出来，鼠便把红色绳子都咬断了。\n\n白兔有些气恼，但是他还是想要知道答案。他便问白云：对于所有红色绳子的连接方案，答案的总和（即求所有红色绳子连接方案的给予数方案之和）是多少？\n\n鼠在不停地挣扎，想要摆脱绳子的束缚。白云还没有思考出来，鼠便把蓝色绳子也咬断了。\n\n白兔有些气恼，但是他还是想要知道答案。他便问白云：对于所有红色和蓝色绳子的连接方案，答案的总和（即求所有红色和蓝色绳子连接方案的给予数方案之和）是多少？两个方案不同当且仅当存在至少一对鼠，在两种方案中，这两只鼠之间直接连接的绳子不同（两只鼠之间连接绳子的可能性有 4 种：没有绳子直接连接，只有红色绳子直接连接，只有蓝色绳子直接连接，两种颜色的绳子均直接连接）。\n\n白云哭了。", "description": "本题包含三个问题：\n- 问题 0：已知两棵 $n$ 个节点的树的形态（两棵树的节点标号均为 $1$ 至 $n$），其中第一棵树是红树，第二棵树是蓝树。要给予每个节点一个 $[1, y]$ 中的整数，使得对于任意两个节点 $p, q$，如果存在一条路径 $(a_1 = p, a_2, \\cdots , a_m = q)$ 同时属于这两棵树，则 $p, q$ 必须被给予相同的数。求给予数的方案数。\n  - 存在一条路径同时属于这两棵树的定义见「题目背景」。\n- 问题 1：已知蓝树，对于红树的所有 $n^{n-2}$ 种选择方案，求问题 0 的答案之和。\n- 问题 2：对于蓝树的所有 $n^{n-2}$ 种选择方案，求问题 1 的答案之和。\n\n提示：$n$ 个节点的树一共有 $n^{n-2}$ 种。\n\n在不同的测试点中，你将可能需要回答不同的问题。我们将用 $\\text{op}$ 来指代你需要回答的问题编号（对应上述 0、 1、 2）。\n\n由于答案可能很大，因此你只需要输出答案对 $998, 244, 353$ 取模的结果即可。", "inputFormat": "第一行三个用空格隔开的整数 $n, y, \\text{op}$。\n如果 $\\text{op} = 0$，则接下来 $2 \\times (n - 1)$ 行，前 $(n - 1)$ 行每描述一条蓝色绳子，接下来 $(n - 1)$ 行每行描述一条红色绳子。  \n如果 $\\text{op} = 1$，则接下来 $(n - 1)$ 行，每行描述一条蓝色绳子。  \n如果 $\\text{op} = 2$，则接下来没有输入。  \n描述绳子的各行将包含两个用空格隔开的整数，分别表示被这条绳子连接的两只鼠的编号。鼠的编号是从 $1$ 开始的。", "outputFormat": "输出一个整数，表示答案对 $998, 244, 353$ 取模的结果。", "hint": "#### 样例说明 1\n两棵树相同，所以任意两个点都必须被给予相同的数，方案数为 $2$。\n\n#### 样例说明 2\n红树共有三种可能的情况：\n1. 包含绳子 $(1, 2)$（表示连接 $1, 2$ 号鼠的绳子，下同）、$(2, 3)$：此时任意两只鼠都必须被给予相同的数，问题 0 的答案为 $2$。\n2. 包含绳子 $(1, 2)$、$(1, 3)$：此时 $1$ 号鼠和 $2$ 号鼠必须被给予相同的数，问题 0 的答案为 $2 \\times 2 = 4$。\n3. 包含绳子 $(2, 3)$、$(1, 3)$：此时 $2$ 号点和 $3$ 号点必须被给予相同的数，问题 0 的答案为 $2 \\times 2 = 4$。\n\n综上，问题 1 的答案为 $2 + 4 + 4 = 10$。\n\n#### 样例说明 3\n蓝树一共有三种可能的情况。不难发现，对于蓝树的每一种情况，求得的问题 1 的答案都是 $10$。所以答案为 $10 \\times 3 = 30$。\n\n::cute-table{tuack}\n\n| 问题类型 $(\\mathrm{op})$ | 测试点编号 | $n$ | $y$ | 集训队每点分值 | 非集训队每点分值 |\n|:---:|:---:|:---:|:---:|:---:|:---:|\n| **0** | 1 | $\\le 10$ | 无特殊限制 | 2 | 18 |\n| ^ | 2 | $\\le 10^{5}$ | ^ | ^ | 5 |\n| ^ | 3 | ^ | ^ | ^ | ^ |\n| **1** | 4 | $=3$ | ^ | 1 |4 |\n| ^ | 5 | $=5$ | ^ | ^ |^ |\n| ^ | 6 | $\\le 500$ | ^ | 6 | ^ |\n| ^ | 7 | ^ | ^ | ^ | ^ |\n| ^ | 8 | $\\le 5000$ | ^ | ^ |^ |\n| ^ | 9 | ^ | ^ | ^ |^ |\n| ^ | 10 | $\\le 10^{5}$ | $=1$ | 1 |^ |\n| ^ | 11 | ^ | 无特殊限制 | 5 | 2 |\n| ^ | 12 | ^ | ^ | ^ | ^ |\n| ^ | 13 | ^ | ^ | ^ | ^ |\n| ^ | 14 | ^ | ^ | ^ | ^ |\n| **2** | 15 | $=3$ | ^ | 1 | 4 |\n| ^ | 16 | $=10$ | ^ | ^ | ^ |\n| ^ | 17 | $\\le 500$ | ^ | 6 | ^ |\n| ^ | 18 | ^ | ^ | ^ | ^ |\n| ^ | 19 | $\\le 5000$ | ^ | ^ | ^ |\n| ^ | 20 | ^ | ^ | ^ | ^ |\n| ^ | 21 | $\\le 10^{5}$ | $=1$ | 1 | ^ |\n| ^ | 22 | ^ | 无特殊限制 | 5 | 2 |\n| ^ | 23 | ^ | ^ | ^ | ^ |\n| ^ | 24 | ^ | ^ | ^ | ^ |\n| ^ | 25 | ^ | ^ | ^ | ^ |\n\n为了优化你的阅读体验，我们把**测试点编号**放在了表格的中间，请注意这一点。\n\n所有测试点均满足  $3 \\leq n \\leq 10^{5}, 1 \\leq y<998244353, o p \\in\\{0,1,2\\} $ 。\n\n## 洛谷按照集训队分值赋分", "locale": "zh-CN"}}}
{"pid": "P5207", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["2019", "提交答案", "Special Judge", "WC"], "title": "[WC2019] 远古计算机", "background": "企鹅大陆是一片神奇的土地，在厚厚的冰层下埋藏着一个巨大的宝藏。探险家企鹅豆豆挖穿冰层到达了宝库，但他发现了一个令人发愁的问题。一共有五座宝库，每个宝库是由某些远古计算机控制的。由于年代久远，这些计算机里的程序已经消失不见了，只有给这些计算机重新填写代码并且顺利运行，输出了正确结果才能触发开门的机关。", "description": "每一个宝库大门由一个计算机集群控制，计算机之间用数据线相连以便传输数据。但是有很多数据线已经损坏了，所以只留下了一部分连线。一开始数据线上没有数据，当一台计算机向数据线上写入时，数据线上就有了一个整数。每条数据线上最多可以同时传输一个整数，当整数被读取后便会消失，数据线就又回到没有数据的状态。\n\n每台远古计算机有两个储存单元，分别名为 $a$ 和 $b$，每个储存单元能够储存一个 $-2147483648$ 到 $2147483647$ 之间的整数。\n\n每个时刻，每台远古计算机可以执行一条指令，一共有以下几种指令：\n- `mov reg val`：将储存单元 `reg` 的值赋值为 `val` 的值；\n- `add reg val`：给储存单元 `reg` 加上 `val` 的值；\n- `dec reg val`：给储存单元 `reg` 减去 `val` 的值；\n- `mul reg val`：给储存单元 `reg` 乘以 `val` 的值；\n- `div reg val`：给储存单元 `reg` 除以 `val` 的值，这里的除法是向零取整的除法，如 $\\frac{-5}{2} = -2$；\n- `and reg val`：给储存单元 `reg` 二进制与上 `val` 的值；\n- `or reg val`：给储存单元 `reg` 二进制或上 `val` 的值；\n- `xor reg val`：给储存单元 `reg` 二进制异或上 `val` 的值；\n- `jmp val` 跳转到整个程序第 `val` 条语句，语句从程序开头开始，用从 $1$ 开始的正整数计数；\n- `jz reg val`：如果 `reg` 的值为 $0$，那么跳转到第 `val` 行；\n- `jnz reg val`：如果 `reg` 的值不为 $0$，那么跳转到第 `val` 行；\n- `jgz reg val`：如果 `reg` 的值严格大于 $0$，那么跳转到第 `val` 行；\n- `jsz reg val`：如果 `reg` 的值严格小于 $0$，那么跳转到第 `val` 行；\n- `read x reg`：从远古计算机 $x$ 读取一个数到储存单元 `reg` 当中，如果数据线上缓存了一个数字，将读取这个数字并返回，否则等待下个周期再次尝试读取。$x = 0$ 时视为从标准输入数据读取一个数；\n- `write val x`：将 `val` 的数值向远古计算机 $x$ 方向所在数据线写入，当且仅当数据线上没有存有数据才会成功写入，否则等待下个周期再次尝试写入。$x = 0$ 时视为向标准输出数据写出一个数。\n\n`reg` 表示一个储存单元，只能为 $a$ 或者 $b$ 之一。\n\n`val` 表示一个储存单元或者一个数字的值，比如填入 $a$ 表示 $a$ 中储存的值或者填入 $233$ 表示 $233$ 这个数字。\n\n一台远古计算机读写指令中 $x$ 只有与当前远古计算机直接有数据线相连，或者 $x=0$ 才被视为合法指令。\n\n每台远古计算机的标准输入输出独立，远古计算机之间互不影响，即每台远古计算机都有独立的一个标准输入端和一个标准输出端。\n\n每个周期计算时，所有需要执行 `write` 指令的远古计算机先计算，然后需要执行 `read` 指令的远古计算机再计算，需要执行其余指令的远古计算机最后计算。\n\n在读取时，如果标准输入数据没有任何可以继续读取的数据，该远古计算机将进入永远等待状态。\n\n一台远古计算机如果执行完了最后一条指令，将会重新从第一条指令开始执行。\n\n如果一台远古计算机没有任何指令，该计算机将永远处于等待状态。\n\n指令计数是从 $1$ 开始的正整数。\n\n一条数据线上最多只能暂存一个数据，两台计算机之间只有一条数据线，即可能读取自己上一轮写入的数据，如果两端的远古计算机同时读取或写入同一条数据线上的\n数据，结果将不可预知。\n\n不存在写入标准输入的方法或是从标准输出当中读取数据的方法。\n\n比如如下样例是从 $1$ 号计算机的标准输入读入两个数，并从 $2$ 号计算机的标准输出输出两个数之和。\n\n```plain\nnode 1\nread 0 a\nread 0 b\nwrite a 2\nwrite b 2\nnode 2\nread 1 a\nread 1 b\nadd a b\nwrite a 0\n```\n\n而以下写法是错误的\n\n```plain\nnode 1\nread 0 a\nread 0 b\nadd a b\nwrite a 0\nnode 2\nmov a a\n```\n\n因为正确答案中，一号远古计算机的标准输出为空，而二号远古计算机的标准输出才是两个数之和。\n\n#### 子任务\n\n##### 子任务 1\n$1$ 号远古计算机的标准输入将会有不超过 $100$ 个非负整数，按照原顺序输出到 $1$ 号远古计算机的输出当中。\n\n##### 子任务 2\n$1$ 号远古计算机一个非负整数 $k$，按照原输入顺序将斐波那契数列第 $k$ 项输出到 $1$ 号点的标准输出当中，输入数据保证第 $k$ 项不超过 $10^9$。斐波那契数列通项公式为 $F_0 = 0, F_1 = 1, F_n = F_{n-1} + F_{n-2}(2 \\le n)$。\n\n##### 子任务 3\n$1$ 号远古计算机的标准输入将会有不超过 $100$ 个非负整数，按照原顺序输出到 $n$ 号远古计算机的输出当中。\n\n##### 子任务 4\n第 $1$ 到 $50$ 号远古计算机分别输入 $1$ 个数，将这 $50$ 个数从 $51$ 到 $100$ 号远古计算机输出，输出顺序任意，每个远古计算机输出数字个数任意。\n\n##### 子任务 5\n第 $1$ 到 $10$ 号远古计算机各输入 $1$ 个数，将这些数对应从 $100$ 到 $91$ 号远古计算机输出，即 $i$ 号点输入的数需要从 $101 - i$ 号点输出。", "inputFormat": "这是一道提交答案题，共有 $5$ 组输入数据，这些数据命名为 `oldcomputer1.in` ~ `oldcomputer5.in`。\n\n这些文件描述了远古计算机之间的连线状态。\n\n文件的第一行是三个非负整数 $x,n$ 和 $m$，表示测试点编号、远古计算机的个数与他们之间的连线条数，远古计算机是从 $1$ 到 $n$ 标号的。\n\n接下来 $m$ 行，每行两个正整数 $x, y$，表示计算机 $x$ 和计算机 $y$ 之间通过数据线直接相连。", "outputFormat": "对于每组输入数据，你需要提交相应的输出文件 `oldcomputer1.out` ~ `oldcomputer5.out`。\n\n这些文件描述了每台远古计算机的代码内容。\n\n文件由多个代码块组成，每个代码块的具体格式如下：\n\n第一行为一个字符串 `node` 与一个 $1$ 到 $n$ 之间的整数 $a$，由一个空格隔开，表示接下来是计算机 $a$ 的指令。\n\n接下来多行为该计算机的具体指令内容。\n\n每台计算机的指令应当最多出现一次，否则将会出现未知错误。\n\n所有计算机的指令总条数应当不超过 $10^6$ 行。", "hint": "#### 评分方式\n对于每个测试点，有三个参数 $a_1, a_2, a_3$。\n\n如果选手提交的代码在 $a_1$ 个周期内正确输出了答案，将会得到该测试点 $100\\%$ 的分。  \n如果选手提交的代码在 $a_2$ 个周期内正确输出了答案，将会得到该测试点 $60\\%$ 的分。  \n如果选手提交的代码在 $a_3$ 个周期内正确输出了答案，将会得到该测试点 $30\\%$ 的分。\n\n即在每个周期结束时，会分别进行一次答案正确性判断，以最早正确的一次为准。\n\n#### 子任务分值\n|  子任务编号  | $1$  | $2$  | $3$  | $4$  | $5$  |\n| :----------: | :--: | :--: | :--: | :--: | :--: |\n|  集训队分值  | $10$ | $15$ | $15$ | $30$ | $30$ |\n| 非集训队分值 | $20$ | $20$ | $20$ | $20$ | $20$ |\n\n#### 提示\n\n感谢 @tiger2005 提供 spj。关于 spj 的使用方法，请参考这两个讨论贴：\n- [Tester finished.\n](https://www.luogu.com.cn/discuss/show/245001)\n- [Checker finished.](https://www.luogu.com.cn/discuss/show/245044)", "locale": "zh-CN", "translations": {"en": {"title": "[WC2019] Ancient Computer", "background": "Penguin Continent is a magical land. Beneath the thick ice lies a huge treasure. The explorer penguin Doudou dug through the ice and reached the treasury, but then he found a troubling problem. There are five vaults in total, and each vault is controlled by some ancient computers. Because they are so old, the programs inside these computers have already disappeared. Only by rewriting code for these computers, running it successfully, and producing the correct output can the door-opening mechanism be triggered.", "description": "Each vault gate is controlled by a computer cluster. The computers are connected by data cables to transmit data. However, many cables are broken, so only some connections remain. At the beginning, there is no data on any cable. When a computer writes to a cable, there will be an integer on that cable. Each cable can transmit at most one integer at the same time. After the integer is read, it disappears and the cable returns to the no-data state.\n\nEach ancient computer has two storage cells, named $a$ and $b$. Each cell can store an integer from $-2147483648$ to $2147483647$.\n\nAt each moment, each ancient computer can execute one instruction. The instruction types are as follows:\n\n- `mov reg val`: set the value of storage cell `reg` to the value of `val`;\n- `add reg val`: add the value of `val` to storage cell `reg`;\n- `dec reg val`: subtract the value of `val` from storage cell `reg`;\n- `mul reg val`: multiply storage cell `reg` by the value of `val`;\n- `div reg val`: divide storage cell `reg` by the value of `val`; this division is truncation toward zero, e.g. $\\frac{-5}{2} = -2$;\n- `and reg val`: bitwise AND storage cell `reg` with the value of `val`;\n- `or reg val`: bitwise OR storage cell `reg` with the value of `val`;\n- `xor reg val`: bitwise XOR storage cell `reg` with the value of `val`;\n- `jmp val`: jump to the `val`-th statement of the whole program. Statements are counted from the beginning of the program starting at $1$;\n- `jz reg val`: if the value of `reg` is $0$, jump to line `val`;\n- `jnz reg val`: if the value of `reg` is not $0$, jump to line `val`;\n- `jgz reg val`: if the value of `reg` is strictly greater than $0$, jump to line `val`;\n- `jsz reg val`: if the value of `reg` is strictly less than $0$, jump to line `val`;\n- `read x reg`: read a number from ancient computer $x$ into storage cell `reg`. If there is a cached number on the cable, read it and return; otherwise, wait and try again in the next cycle. When $x = 0$, it is considered reading one number from standard input;\n- `write val x`: write the value of `val` onto the cable in the direction of ancient computer $x$. This succeeds if and only if there is no data currently stored on the cable; otherwise, wait and try again in the next cycle. When $x = 0$, it is considered writing one number to standard output.\n\n`reg` denotes a storage cell, and can only be $a$ or $b$.\n\n`val` denotes the value of a storage cell or a number. For example, writing $a$ means the value stored in $a$, and writing $233$ means the number $233$.\n\nIn the read/write instructions of an ancient computer, $x$ is considered a valid instruction only if $x$ is directly connected to the current ancient computer by a data cable, or $x = 0$.\n\nEach ancient computer has independent standard input and standard output. Different ancient computers do not affect each other. That is, each ancient computer has its own independent standard input port and standard output port.\n\nIn each cycle, all ancient computers that need to execute `write` instructions are processed first, then those that need to execute `read` instructions, and finally those that need to execute other instructions.\n\nWhen reading, if there is no more data available from standard input, the ancient computer will enter an eternal waiting state.\n\nIf an ancient computer finishes executing the last instruction, it will restart from the first instruction.\n\nIf an ancient computer has no instructions at all, it will stay in an eternal waiting state.\n\nInstruction indices are positive integers starting from $1$.\n\nEach data cable can buffer at most one piece of data. Between two computers there is only one data cable, so it is possible to read the data written by itself in the previous round. If the two endpoint ancient computers read from or write to the same cable at the same time, the result will be unpredictable.\n\nThere is no way to write to standard input, and there is no way to read from standard output.\n\nFor example, the following sample reads two numbers from the standard input of computer $1$, and outputs the sum of the two numbers to the standard output of computer $2$.\n\n```plain\nnode 1\nread 0 a\nread 0 b\nwrite a 2\nwrite b 2\nnode 2\nread 1 a\nread 1 b\nadd a b\nwrite a 0\n```\n\nThe following is incorrect:\n\n```plain\nnode 1\nread 0 a\nread 0 b\nadd a b\nwrite a 0\nnode 2\nmov a a\n```\n\nBecause in the correct answer, the standard output of ancient computer $1$ is empty, while the standard output of ancient computer $2$ is the sum of the two numbers.\n\n#### Subtasks\n\n##### Subtask 1\n\nThe standard input of ancient computer $1$ will contain no more than $100$ non-negative integers. Output them in the original order to the output of ancient computer $1$.\n\n##### Subtask 2\n\nAncient computer $1$ will receive one non-negative integer $k$. Output the $k$-th term of the Fibonacci sequence to the standard output of node $1$ in the original input order. The input guarantees that the $k$-th term is at most $10^9$. The Fibonacci sequence is defined as $F_0 = 0, F_1 = 1, F_n = F_{n-1} + F_{n-2}(2 \\le n)$.\n\n##### Subtask 3\n\nThe standard input of ancient computer $1$ will contain no more than $100$ non-negative integers. Output them in the original order to the output of ancient computer $n$.\n\n##### Subtask 4\n\nAncient computers $1$ to $50$ each input one number. Output these $50$ numbers from ancient computers $51$ to $100$. The output order is arbitrary, and each ancient computer may output any number of values.\n\n##### Subtask 5\n\nAncient computers $1$ to $10$ each input one number. Output these numbers correspondingly from ancient computers $100$ to $91$. That is, the number input at node $i$ must be output from node $101 - i$.", "inputFormat": "This is an output-only problem. There are $5$ groups of input data, named `oldcomputer1.in` to `oldcomputer5.in`.\n\nThese files describe the connection status between the ancient computers.\n\nThe first line of the file contains three non-negative integers $x, n$ and $m$, representing the test point ID, the number of ancient computers, and the number of cables between them. The ancient computers are numbered from $1$ to $n$.\n\nThe next $m$ lines each contain two positive integers $x, y$, indicating that computer $x$ and computer $y$ are directly connected by a data cable.", "outputFormat": "For each group of input data, you need to submit the corresponding output file `oldcomputer1.out` to `oldcomputer5.out`.\n\nThese files describe the code content for each ancient computer.\n\nA file consists of multiple code blocks. The format of each code block is as follows:\n\nThe first line contains a string `node` and an integer $a$ between $1$ and $n$, separated by a space, indicating that the following instructions belong to computer $a$.\n\nThe following lines are the specific instructions of that computer.\n\nEach computer's instruction block should appear at most once; otherwise, unknown errors may occur.\n\nThe total number of instruction lines for all computers must not exceed $10^6$.", "hint": "#### Scoring\n\nFor each test point, there are three parameters $a_1, a_2, a_3$.\n\nIf the submitted code outputs the correct answer within $a_1$ cycles, you will get $100\\%$ of the score for that test point.  \nIf the submitted code outputs the correct answer within $a_2$ cycles, you will get $60\\%$ of the score for that test point.  \nIf the submitted code outputs the correct answer within $a_3$ cycles, you will get $30\\%$ of the score for that test point.\n\nThat is, at the end of each cycle, the answer will be checked once, and the earliest correct check result will be used.\n\n#### Subtask Scores\n\n| Subtask ID | $1$  | $2$  | $3$  | $4$  | $5$  |\n| :--------: | :--: | :--: | :--: | :--: | :--: |\n| CTT score  | $10$ | $15$ | $15$ | $30$ | $30$ |\n| Non-CTT score | $20$ | $20$ | $20$ | $20$ | $20$ |\n\n#### Notes\n\nThanks to @tiger2005 for providing the spj. For how to use the spj, please refer to these two discussion posts:\n- [Tester finished.\n](https://www.luogu.com.cn/discuss/show/245001)\n- [Checker finished.](https://www.luogu.com.cn/discuss/show/245044).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2019] 远古计算机", "background": "企鹅大陆是一片神奇的土地，在厚厚的冰层下埋藏着一个巨大的宝藏。探险家企鹅豆豆挖穿冰层到达了宝库，但他发现了一个令人发愁的问题。一共有五座宝库，每个宝库是由某些远古计算机控制的。由于年代久远，这些计算机里的程序已经消失不见了，只有给这些计算机重新填写代码并且顺利运行，输出了正确结果才能触发开门的机关。", "description": "每一个宝库大门由一个计算机集群控制，计算机之间用数据线相连以便传输数据。但是有很多数据线已经损坏了，所以只留下了一部分连线。一开始数据线上没有数据，当一台计算机向数据线上写入时，数据线上就有了一个整数。每条数据线上最多可以同时传输一个整数，当整数被读取后便会消失，数据线就又回到没有数据的状态。\n\n每台远古计算机有两个储存单元，分别名为 $a$ 和 $b$，每个储存单元能够储存一个 $-2147483648$ 到 $2147483647$ 之间的整数。\n\n每个时刻，每台远古计算机可以执行一条指令，一共有以下几种指令：\n- `mov reg val`：将储存单元 `reg` 的值赋值为 `val` 的值；\n- `add reg val`：给储存单元 `reg` 加上 `val` 的值；\n- `dec reg val`：给储存单元 `reg` 减去 `val` 的值；\n- `mul reg val`：给储存单元 `reg` 乘以 `val` 的值；\n- `div reg val`：给储存单元 `reg` 除以 `val` 的值，这里的除法是向零取整的除法，如 $\\frac{-5}{2} = -2$；\n- `and reg val`：给储存单元 `reg` 二进制与上 `val` 的值；\n- `or reg val`：给储存单元 `reg` 二进制或上 `val` 的值；\n- `xor reg val`：给储存单元 `reg` 二进制异或上 `val` 的值；\n- `jmp val` 跳转到整个程序第 `val` 条语句，语句从程序开头开始，用从 $1$ 开始的正整数计数；\n- `jz reg val`：如果 `reg` 的值为 $0$，那么跳转到第 `val` 行；\n- `jnz reg val`：如果 `reg` 的值不为 $0$，那么跳转到第 `val` 行；\n- `jgz reg val`：如果 `reg` 的值严格大于 $0$，那么跳转到第 `val` 行；\n- `jsz reg val`：如果 `reg` 的值严格小于 $0$，那么跳转到第 `val` 行；\n- `read x reg`：从远古计算机 $x$ 读取一个数到储存单元 `reg` 当中，如果数据线上缓存了一个数字，将读取这个数字并返回，否则等待下个周期再次尝试读取。$x = 0$ 时视为从标准输入数据读取一个数；\n- `write val x`：将 `val` 的数值向远古计算机 $x$ 方向所在数据线写入，当且仅当数据线上没有存有数据才会成功写入，否则等待下个周期再次尝试写入。$x = 0$ 时视为向标准输出数据写出一个数。\n\n`reg` 表示一个储存单元，只能为 $a$ 或者 $b$ 之一。\n\n`val` 表示一个储存单元或者一个数字的值，比如填入 $a$ 表示 $a$ 中储存的值或者填入 $233$ 表示 $233$ 这个数字。\n\n一台远古计算机读写指令中 $x$ 只有与当前远古计算机直接有数据线相连，或者 $x=0$ 才被视为合法指令。\n\n每台远古计算机的标准输入输出独立，远古计算机之间互不影响，即每台远古计算机都有独立的一个标准输入端和一个标准输出端。\n\n每个周期计算时，所有需要执行 `write` 指令的远古计算机先计算，然后需要执行 `read` 指令的远古计算机再计算，需要执行其余指令的远古计算机最后计算。\n\n在读取时，如果标准输入数据没有任何可以继续读取的数据，该远古计算机将进入永远等待状态。\n\n一台远古计算机如果执行完了最后一条指令，将会重新从第一条指令开始执行。\n\n如果一台远古计算机没有任何指令，该计算机将永远处于等待状态。\n\n指令计数是从 $1$ 开始的正整数。\n\n一条数据线上最多只能暂存一个数据，两台计算机之间只有一条数据线，即可能读取自己上一轮写入的数据，如果两端的远古计算机同时读取或写入同一条数据线上的\n数据，结果将不可预知。\n\n不存在写入标准输入的方法或是从标准输出当中读取数据的方法。\n\n比如如下样例是从 $1$ 号计算机的标准输入读入两个数，并从 $2$ 号计算机的标准输出输出两个数之和。\n\n```plain\nnode 1\nread 0 a\nread 0 b\nwrite a 2\nwrite b 2\nnode 2\nread 1 a\nread 1 b\nadd a b\nwrite a 0\n```\n\n而以下写法是错误的\n\n```plain\nnode 1\nread 0 a\nread 0 b\nadd a b\nwrite a 0\nnode 2\nmov a a\n```\n\n因为正确答案中，一号远古计算机的标准输出为空，而二号远古计算机的标准输出才是两个数之和。\n\n#### 子任务\n\n##### 子任务 1\n$1$ 号远古计算机的标准输入将会有不超过 $100$ 个非负整数，按照原顺序输出到 $1$ 号远古计算机的输出当中。\n\n##### 子任务 2\n$1$ 号远古计算机一个非负整数 $k$，按照原输入顺序将斐波那契数列第 $k$ 项输出到 $1$ 号点的标准输出当中，输入数据保证第 $k$ 项不超过 $10^9$。斐波那契数列通项公式为 $F_0 = 0, F_1 = 1, F_n = F_{n-1} + F_{n-2}(2 \\le n)$。\n\n##### 子任务 3\n$1$ 号远古计算机的标准输入将会有不超过 $100$ 个非负整数，按照原顺序输出到 $n$ 号远古计算机的输出当中。\n\n##### 子任务 4\n第 $1$ 到 $50$ 号远古计算机分别输入 $1$ 个数，将这 $50$ 个数从 $51$ 到 $100$ 号远古计算机输出，输出顺序任意，每个远古计算机输出数字个数任意。\n\n##### 子任务 5\n第 $1$ 到 $10$ 号远古计算机各输入 $1$ 个数，将这些数对应从 $100$ 到 $91$ 号远古计算机输出，即 $i$ 号点输入的数需要从 $101 - i$ 号点输出。", "inputFormat": "这是一道提交答案题，共有 $5$ 组输入数据，这些数据命名为 `oldcomputer1.in` ~ `oldcomputer5.in`。\n\n这些文件描述了远古计算机之间的连线状态。\n\n文件的第一行是三个非负整数 $x,n$ 和 $m$，表示测试点编号、远古计算机的个数与他们之间的连线条数，远古计算机是从 $1$ 到 $n$ 标号的。\n\n接下来 $m$ 行，每行两个正整数 $x, y$，表示计算机 $x$ 和计算机 $y$ 之间通过数据线直接相连。", "outputFormat": "对于每组输入数据，你需要提交相应的输出文件 `oldcomputer1.out` ~ `oldcomputer5.out`。\n\n这些文件描述了每台远古计算机的代码内容。\n\n文件由多个代码块组成，每个代码块的具体格式如下：\n\n第一行为一个字符串 `node` 与一个 $1$ 到 $n$ 之间的整数 $a$，由一个空格隔开，表示接下来是计算机 $a$ 的指令。\n\n接下来多行为该计算机的具体指令内容。\n\n每台计算机的指令应当最多出现一次，否则将会出现未知错误。\n\n所有计算机的指令总条数应当不超过 $10^6$ 行。", "hint": "#### 评分方式\n对于每个测试点，有三个参数 $a_1, a_2, a_3$。\n\n如果选手提交的代码在 $a_1$ 个周期内正确输出了答案，将会得到该测试点 $100\\%$ 的分。  \n如果选手提交的代码在 $a_2$ 个周期内正确输出了答案，将会得到该测试点 $60\\%$ 的分。  \n如果选手提交的代码在 $a_3$ 个周期内正确输出了答案，将会得到该测试点 $30\\%$ 的分。\n\n即在每个周期结束时，会分别进行一次答案正确性判断，以最早正确的一次为准。\n\n#### 子任务分值\n|  子任务编号  | $1$  | $2$  | $3$  | $4$  | $5$  |\n| :----------: | :--: | :--: | :--: | :--: | :--: |\n|  集训队分值  | $10$ | $15$ | $15$ | $30$ | $30$ |\n| 非集训队分值 | $20$ | $20$ | $20$ | $20$ | $20$ |\n\n#### 提示\n\n感谢 @tiger2005 提供 spj。关于 spj 的使用方法，请参考这两个讨论贴：\n- [Tester finished.\n](https://www.luogu.com.cn/discuss/show/245001)\n- [Checker finished.](https://www.luogu.com.cn/discuss/show/245044)", "locale": "zh-CN"}}}
{"pid": "P5208", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "交互题", "Special Judge", "O2优化", "WC"], "title": "[WC2019] I 君的商店", "background": "### 特别提示\n\n**在洛谷提交本题时的一些注意事项（与原题面不同之处请以此处为准）：**\n\n1. 与原题不同的是，你不需要，也不应该在程序开头包含 `shop.h` 头文件。\n2. 提交时，请在程序中加入以下函数声明语句：\n\n```cpp\nint query(int *S, int nS, int *T, int nT);\n```\n\n3. 仅支持 `C++`（含 `C++`，`C++11`，`C++14`，`C++17`）提交。", "description": "V 君、I 君和 Y 君是好朋友。\n\nI 君最近开了一家商店，商店里准备了 $N$ 种物品（编号为 $0 \\sim N - 1$ 中的整数），每种物品均有无限个可供出售，每种物品的单价是 $0$ 或者 $1$。\n\nV 君想知道每个物品的价格，他已经通过某种超自然力量知道，这 $N$ 个物品里，价格是 $1$ 的物品恰好有奇数/偶数个，且**至少存在一个物品的价格是 $1$**。\n\n然而， V 君并不想自己去问 I 君，他选择了这样一种方法：他准备了 $+\\infty$ 的钱给 Y 君。然后让 Y 君帮他跑腿：每一次，他会给 Y 君指定两个非空物品**集合** $S, T$（同一个集合内的物品必须两两不同，即每种物品在每个集合类最多包含一个），Y 君会跑到商店，分别买下这两个集合的物品，把他们送回来，并告诉 V 君哪个集合的物品价格之和更高。但是，当**两集合价格之和相等**的时候，Y 君会按照 I 君的指示来回答 V 君。\n\n带着很多物品跑腿是一个很累的事情，因此，我们定义一次跑腿的体力消耗是 $\\texttt{S} + \\texttt{T}$。其中，$\\texttt{S}$ 表示集合 $S$ 包含的物品个数。\n\n你的任务是：写一个程序，帮助 V 君决定如何合理地让 Y 君跑腿，从而推算出每种物品的价值。Y 君的体力有限，你当然不能让他过于劳 累，也即，你不能让他的总体力消耗超过某个预设的阈值 $M$。\n\n#### 实现细节\n你不需要，也不应该实现主函数，你只需要实现下列函数：\n- `find_price(task_id, N, K, ans)`\n- 其中 `task_id` 表示子任务编号（见限制与约定）。$N$ 表示物品个数，$K$ 的意义为：\n  - 若 $K = 0$，表示有偶数个物品价值为 $1$；\n  - 若 $K = 1$，表示有奇数个物品价值为 $1$。\n- 你需要将计算出的物品价格放在数组 $\\text{ans}[]$ 中，其中 $\\text{ans[i]}$ 表示编号为 $i$ 的物品的价格。\n\n你可以通过调用如下函数来向交互库发出询问：\n- `query(S, nS, T, nT)`\n- 这里 $\\text{nS} = \\texttt{S}, \\text{nT} = \\texttt{T}$, 数组 $\\text{S [0\\ldots (nS - 1)]}$ 和数组 $\\text{T[0\\ldots (nT - 1)]}$ 分别描述两个集合，你需要保证：\n  - $\\text{nS, nT} > 0$；\n  - $\\forall 0 \\le i < \\text{nS} , 0 \\le \\text{S[i]} < N$；\n  - $\\forall 0 \\le i < \\text{nT} , 0 \\le \\text{T[i]} < N$；  \n$\\forall$ 的意思是：「对于任意的」。例如：$\\forall 0 \\le i < \\text{nS} , 0 \\le \\text{S[i]} < N$ 的意思是：「对于任意的在 $[0, \\text{nS})$ 内的 $i$，$\\text{S[i]}$ 在 $[0, N)$ 内」。\n- 调用此函数一次的时间复杂度为 $\\Theta(\\text{nS + nT})$。它的返回值为 $0$ 或 $1$，返回值的意义为：\n  - 若集合 $S$ 的物品价格和更大，返回 $0$；\n  - 若集合 $T$ 的物品价格和更大，返回 $1$；\n  - 否则，按照某种未知规则返回 $0$ 或 $1$。\n- 如题面所述，我们定义这样一次调用的代价为 $\\text{nS + nT}$。\n\n评测时，交互库可能会调用 `find_price` 多次（不超过 $10$ 次），每次调用代表一次新的猜价格游戏，所有的物品的价格都会被重新设定。", "inputFormat": "可执行文件将从标准输入读入以下格式的数据：\n\n第一行一个整数 $T ( T \\le 100 )$，表示数据组数。对每组数据：\n- 第一行包含两个整数 $\\texttt{task\\_id}, N$；\n- 接下来一行一个长度为 $N$ 的 $01$ 串 $s$，其中 $s_i$ 表示物品 $i$ 的价格。你需要保证至少有一个物品价格为 $1$。\n\n读入完成之后，交互库将调用 $T$ 次 `find_price` 函数。\n\n接下来交互库会判断你的函数每次计算是否正确，若全部正确则会输出 `Correct`，否则会输出相应的错误信息。", "outputFormat": "", "hint": "#### 评分标准\n\n题目首先会受到和非交互式程序题相同的限制。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。\n\n在上述条件基础上，在一个测试点中，你得到满分，当且仅当**每一次** `find_price` 的调用中：\n- 你的每一个 `query` 的调用符合规则，且调用代价之和不超过 $M$；\n- 你的函数正确计算了 $\\text{ans[]}$ 数组。\n\n在一个测试点中，如果你没有获得满分，那么你获得 $0$ 分。\n\n#### 子任务\n我们令代价之和的上界为 $M$，记答案数组为 $\\text{ans[]}$：\n- 子任务 1：$N \\le 5, M = 100$；\n- 子任务 2：$N \\le 10^3, M = 10^6$；\n- 子任务 3：$N \\le 10^5, M = 100$，保证 $\\forall i < j < k$，若 $\\text{ans[i]} = \\text{ans[k]}$ 则必有 $\\text{ans[j]} = \\text{ans[i]}$。\n- 子任务 4：$N \\le 10^4, M = 2 \\times 10^5$；\n- 子任务 5：$N \\le 5 \\times 10^4, M = 350100$；\n- 子任务 6：$N \\le 10^5, M = 500100$。\n\n#### 提示\n**I 君可能并不愿意让 V 君知道每件物品的价格，在物品价格相等时，他会按照他自己的某种方式来回答问题。**\n\n#### 子任务分值\n在本场比赛中，测试点（或子任务）的分值分布与你是否为集训队选手有关。本题的分值设置如下：\n\n| 子任务编号   | 1    | 2    | 3    | 4    | 5    | 6    |\n| :------------: | :----: | :----: | :----: | :----: | :----: | :----: |\n| 集训队分值   | $20$ | $11$ | $9$  | $12$ | $17$ | $31$ |\n| 非集训队分值 | $31$ | $21$ | $13$ | $9$  | $11$ | $15$ |\n\n**洛谷评测时采用集训队分值计算分数**。", "locale": "zh-CN", "translations": {"en": {"title": "[WC2019] Mr. I’s Shop.", "background": "### Special Notice.\n\n**Some notes when submitting this problem on Luogu (if it differs from the original statement, please follow what is written here):**\n\n1. Different from the original problem, you do not need, and should not, include the `shop.h` header file at the beginning of your program.\n2. When submitting, please add the following function declaration in your program:\n\n```cpp\nint query(int *S, int nS, int *T, int nT);\n```\n\n3. Only `C++` (including `C++`, `C++11`, `C++14`, `C++17`) submissions are supported.", "description": "Mr. V, Mr. I, and Mr. Y are good friends.\n\nMr. I recently opened a shop. The shop has $N$ kinds of items (with IDs being integers from $0 \\sim N - 1$). Each kind of item has an unlimited supply. The unit price of each item is either $0$ or $1$.\n\nMr. V wants to know the price of every item. Through some supernatural power, he already knows that among these $N$ items, the number of items priced at $1$ is exactly odd/even, and **there is at least one item whose price is $1$**.\n\nHowever, Mr. V does not want to ask Mr. I himself. He chooses the following method: he prepares $+\\infty$ money for Mr. Y, and lets Mr. Y run errands for him. Each time, he specifies two non-empty item **sets** $S, T$ to Mr. Y (items within the same set must be pairwise distinct, i.e. each kind of item can appear at most once in each set). Mr. Y will go to the shop, buy the items in the two sets respectively, bring them back, and tell Mr. V which set has a larger total price. However, when **the sums of the two sets are equal**, Mr. Y will answer Mr. V according to Mr. I’s instructions.\n\nCarrying many items is tiring, so we define the physical cost of one errand as $\\texttt{S} + \\texttt{T}$, where $\\texttt{S}$ denotes the number of items in set $S$.\n\nYour task is to write a program to help Mr. V decide how to make Mr. Y run errands in a reasonable way, so as to deduce the value of every kind of item. Mr. Y’s stamina is limited, so you cannot make him too tired, i.e. you cannot let his total physical cost exceed a preset threshold $M$.\n\n#### Implementation Details\nYou do not need, and should not, implement the main function. You only need to implement the following function:\n- `find_price(task_id, N, K, ans)`\n- Here `task_id` denotes the subtask ID (see Constraints and Rules). $N$ denotes the number of items, and the meaning of $K$ is:\n  - If $K = 0$, it means there are an even number of items with value $1$.\n  - If $K = 1$, it means there are an odd number of items with value $1$.\n- You need to store the computed item prices in the array $\\text{ans}[]$, where $\\text{ans[i]}$ is the price of the item with ID $i$.\n\nYou can make queries to the interactive library by calling the following function:\n- `query(S, nS, T, nT)`\n- Here $\\text{nS} = \\texttt{S}, \\text{nT} = \\texttt{T}$. Arrays $\\text{S [0\\ldots (nS - 1)]}$ and $\\text{T[0\\ldots (nT - 1)]}$ describe the two sets respectively. You must ensure:\n  - $\\text{nS, nT} > 0$.\n  - $\\forall 0 \\le i < \\text{nS} , 0 \\le \\text{S[i]} < N$.\n  - $\\forall 0 \\le i < \\text{nT} , 0 \\le \\text{T[i]} < N$.  \n$\\forall$ means “for any”. For example, $\\forall 0 \\le i < \\text{nS} , 0 \\le \\text{S[i]} < N$ means: “for any $i$ in $[0, \\text{nS})$, $\\text{S[i]}$ is in $[0, N)$”.\n- The time complexity of calling this function once is $\\Theta(\\text{nS + nT})$. It returns $0$ or $1$, and the meaning is:\n  - If the sum of prices of items in set $S$ is larger, return $0$.\n  - If the sum of prices of items in set $T$ is larger, return $1$.\n  - Otherwise, return $0$ or $1$ according to some unknown rule.\n- As stated, we define the cost of one call as $\\text{nS + nT}$.\n\nDuring evaluation, the interactive library may call `find_price` multiple times (no more than $10$ times). Each call represents a new price-guessing game, and all item prices will be reset.", "inputFormat": "The executable will read input from standard input in the following format:\n\nThe first line contains an integer $T ( T \\le 100 )$, the number of test groups. For each group:\n- The first line contains two integers $\\texttt{task\\_id}, N$.\n- The next line contains a binary string $s$ of length $N$, where $s_i$ denotes the price of item $i$. You need to ensure that at least one item has price $1$.\n\nAfter reading is finished, the interactive library will call the `find_price` function $T$ times.\n\nThen the interactive library will check whether your function is correct each time. If all are correct, it will output `Correct`; otherwise, it will output the corresponding error message.", "outputFormat": "", "hint": "#### Scoring Rules\n\nThis problem is first subject to the same limits as non-interactive programming problems. For example, a compilation error will cause the entire problem to score $0$ points; runtime error, exceeding the time limit, exceeding the memory limit, etc. will cause the corresponding test points to score $0$ points. You may only access variables you define yourself and the variables provided by the interactive library and their corresponding memory space. Attempting to access other memory may cause a compilation error or runtime error.\n\nUnder the above conditions, in a test point, you get full score if and only if, in **every** call to `find_price`:\n- Every call to `query` follows the rules, and the sum of call costs does not exceed $M$.\n- Your function correctly computes the array $\\text{ans[]}$.\n\nIn a test point, if you do not get full score, then you get $0$ points.\n\n#### Subtasks\nLet the upper bound of the total cost be $M$, and denote the answer array as $\\text{ans[]}$:\n- Subtask 1: $N \\le 5, M = 100$.\n- Subtask 2: $N \\le 10^3, M = 10^6$.\n- Subtask 3: $N \\le 10^5, M = 100$. It is guaranteed that $\\forall i < j < k$, if $\\text{ans[i]} = \\text{ans[k]}$ then $\\text{ans[j]} = \\text{ans[i]}$.\n- Subtask 4: $N \\le 10^4, M = 2 \\times 10^5$.\n- Subtask 5: $N \\le 5 \\times 10^4, M = 350100$.\n- Subtask 6: $N \\le 10^5, M = 500100$.\n\n#### Note\n**Mr. I may not be willing to let Mr. V know the price of every item. When the sums are equal, he will answer in his own way.**\n\n#### Subtask Scores\nIn this contest, the score distribution of test points (or subtasks) depends on whether you are a CTT contestant. The score settings for this problem are as follows:\n\n| Subtask ID   | 1    | 2    | 3    | 4    | 5    | 6    |\n| :------------: | :----: | :----: | :----: | :----: | :----: | :----: |\n| CTT Score   | $20$ | $11$ | $9$  | $12$ | $17$ | $31$ |\n| Non-CTT Score | $31$ | $21$ | $13$ | $9$  | $11$ | $15$ |\n\n**Luogu uses the CTT scoring scheme when judging.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2019] I 君的商店", "background": "### 特别提示\n\n**在洛谷提交本题时的一些注意事项（与原题面不同之处请以此处为准）：**\n\n1. 与原题不同的是，你不需要，也不应该在程序开头包含 `shop.h` 头文件。\n2. 提交时，请在程序中加入以下函数声明语句：\n\n```cpp\nint query(int *S, int nS, int *T, int nT);\n```\n\n3. 仅支持 `C++`（含 `C++`，`C++11`，`C++14`，`C++17`）提交。", "description": "V 君、I 君和 Y 君是好朋友。\n\nI 君最近开了一家商店，商店里准备了 $N$ 种物品（编号为 $0 \\sim N - 1$ 中的整数），每种物品均有无限个可供出售，每种物品的单价是 $0$ 或者 $1$。\n\nV 君想知道每个物品的价格，他已经通过某种超自然力量知道，这 $N$ 个物品里，价格是 $1$ 的物品恰好有奇数/偶数个，且**至少存在一个物品的价格是 $1$**。\n\n然而， V 君并不想自己去问 I 君，他选择了这样一种方法：他准备了 $+\\infty$ 的钱给 Y 君。然后让 Y 君帮他跑腿：每一次，他会给 Y 君指定两个非空物品**集合** $S, T$（同一个集合内的物品必须两两不同，即每种物品在每个集合类最多包含一个），Y 君会跑到商店，分别买下这两个集合的物品，把他们送回来，并告诉 V 君哪个集合的物品价格之和更高。但是，当**两集合价格之和相等**的时候，Y 君会按照 I 君的指示来回答 V 君。\n\n带着很多物品跑腿是一个很累的事情，因此，我们定义一次跑腿的体力消耗是 $\\texttt{S} + \\texttt{T}$。其中，$\\texttt{S}$ 表示集合 $S$ 包含的物品个数。\n\n你的任务是：写一个程序，帮助 V 君决定如何合理地让 Y 君跑腿，从而推算出每种物品的价值。Y 君的体力有限，你当然不能让他过于劳 累，也即，你不能让他的总体力消耗超过某个预设的阈值 $M$。\n\n#### 实现细节\n你不需要，也不应该实现主函数，你只需要实现下列函数：\n- `find_price(task_id, N, K, ans)`\n- 其中 `task_id` 表示子任务编号（见限制与约定）。$N$ 表示物品个数，$K$ 的意义为：\n  - 若 $K = 0$，表示有偶数个物品价值为 $1$；\n  - 若 $K = 1$，表示有奇数个物品价值为 $1$。\n- 你需要将计算出的物品价格放在数组 $\\text{ans}[]$ 中，其中 $\\text{ans[i]}$ 表示编号为 $i$ 的物品的价格。\n\n你可以通过调用如下函数来向交互库发出询问：\n- `query(S, nS, T, nT)`\n- 这里 $\\text{nS} = \\texttt{S}, \\text{nT} = \\texttt{T}$, 数组 $\\text{S [0\\ldots (nS - 1)]}$ 和数组 $\\text{T[0\\ldots (nT - 1)]}$ 分别描述两个集合，你需要保证：\n  - $\\text{nS, nT} > 0$；\n  - $\\forall 0 \\le i < \\text{nS} , 0 \\le \\text{S[i]} < N$；\n  - $\\forall 0 \\le i < \\text{nT} , 0 \\le \\text{T[i]} < N$；  \n$\\forall$ 的意思是：「对于任意的」。例如：$\\forall 0 \\le i < \\text{nS} , 0 \\le \\text{S[i]} < N$ 的意思是：「对于任意的在 $[0, \\text{nS})$ 内的 $i$，$\\text{S[i]}$ 在 $[0, N)$ 内」。\n- 调用此函数一次的时间复杂度为 $\\Theta(\\text{nS + nT})$。它的返回值为 $0$ 或 $1$，返回值的意义为：\n  - 若集合 $S$ 的物品价格和更大，返回 $0$；\n  - 若集合 $T$ 的物品价格和更大，返回 $1$；\n  - 否则，按照某种未知规则返回 $0$ 或 $1$。\n- 如题面所述，我们定义这样一次调用的代价为 $\\text{nS + nT}$。\n\n评测时，交互库可能会调用 `find_price` 多次（不超过 $10$ 次），每次调用代表一次新的猜价格游戏，所有的物品的价格都会被重新设定。", "inputFormat": "可执行文件将从标准输入读入以下格式的数据：\n\n第一行一个整数 $T ( T \\le 100 )$，表示数据组数。对每组数据：\n- 第一行包含两个整数 $\\texttt{task\\_id}, N$；\n- 接下来一行一个长度为 $N$ 的 $01$ 串 $s$，其中 $s_i$ 表示物品 $i$ 的价格。你需要保证至少有一个物品价格为 $1$。\n\n读入完成之后，交互库将调用 $T$ 次 `find_price` 函数。\n\n接下来交互库会判断你的函数每次计算是否正确，若全部正确则会输出 `Correct`，否则会输出相应的错误信息。", "outputFormat": "", "hint": "#### 评分标准\n\n题目首先会受到和非交互式程序题相同的限制。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。\n\n在上述条件基础上，在一个测试点中，你得到满分，当且仅当**每一次** `find_price` 的调用中：\n- 你的每一个 `query` 的调用符合规则，且调用代价之和不超过 $M$；\n- 你的函数正确计算了 $\\text{ans[]}$ 数组。\n\n在一个测试点中，如果你没有获得满分，那么你获得 $0$ 分。\n\n#### 子任务\n我们令代价之和的上界为 $M$，记答案数组为 $\\text{ans[]}$：\n- 子任务 1：$N \\le 5, M = 100$；\n- 子任务 2：$N \\le 10^3, M = 10^6$；\n- 子任务 3：$N \\le 10^5, M = 100$，保证 $\\forall i < j < k$，若 $\\text{ans[i]} = \\text{ans[k]}$ 则必有 $\\text{ans[j]} = \\text{ans[i]}$。\n- 子任务 4：$N \\le 10^4, M = 2 \\times 10^5$；\n- 子任务 5：$N \\le 5 \\times 10^4, M = 350100$；\n- 子任务 6：$N \\le 10^5, M = 500100$。\n\n#### 提示\n**I 君可能并不愿意让 V 君知道每件物品的价格，在物品价格相等时，他会按照他自己的某种方式来回答问题。**\n\n#### 子任务分值\n在本场比赛中，测试点（或子任务）的分值分布与你是否为集训队选手有关。本题的分值设置如下：\n\n| 子任务编号   | 1    | 2    | 3    | 4    | 5    | 6    |\n| :------------: | :----: | :----: | :----: | :----: | :----: | :----: |\n| 集训队分值   | $20$ | $11$ | $9$  | $12$ | $17$ | $31$ |\n| 非集训队分值 | $31$ | $21$ | $13$ | $9$  | $11$ | $15$ |\n\n**洛谷评测时采用集训队分值计算分数**。", "locale": "zh-CN"}}}
{"pid": "P5209", "type": "P", "difficulty": 7, "samples": [["3\n3 1\n1\n1\n1\n1 2\n2 1\n4 2\n2 1\n1 2\n1 2\n2 1\n", "7\n2\n31"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "各省省选", "浙江"], "title": "[ZJOI2017] 汉诺塔", "background": "虽然九条可怜经常出题，但是她发现要一个人出一场比赛是在是太难了，于是她丢下了手头的出题工作开始玩小游戏。", "description": "有一个游戏是汉诺塔的改版。在这个游戏中，盘子的大小可以相同，但是保证了相同大小的盘子恰好有 K 个。\n\n初始状态下，所有盘子自底向上从大到小地放置在第一根柱子上，对于相同大小的盘子，我们自底向上给它们从 1 到 K 标号。目标是把所有盘子都移动到第三根柱子上。\n\n因为相同大小的盘子的上下顺序没有要求，不难发现合法的终止状态有很多，因此游戏里指定了一种终止状态。\n\n游戏的任务是最小化移动的步数。\n\n可怜想了想觉得这个问题好像挺难的，于是她就把这个出到比赛里来给你做啦。\n\n下面给出汉诺塔的具体规则：\n\n• 有三根柱子和若干块圆盘，初始状态下所有圆盘都在第一根柱子上。\n\n• 每一时刻你可以把某一根柱子顶端的圆盘移动到另一根柱子的顶端，目标是把\n所有盘子都\n\n移动到第三根柱子上。\n\n• 移动的过程中必须要保证较大的圆盘不会压在较小的圆盘上。（相同大小的圆盘没有顺序限制）。\n", "inputFormat": "第一行输入一个整数表示数据组数。\n\n每组数据第一行是两个整数 n 和 K。\n\n接下来 n 行按照盘子从大到小的顺序给出终止状态下同一大小的盘子的相对顺序（从左到右依次表示自底向上），\n\n例如 K = 2 时，2 1 表示原来在上方的盘子到了下面，原来在下方的盘子到了上面。", "outputFormat": "对于每组数据输出一个整数表示最少步数。", "hint": "\n| 测试点编号 | K | 测试点编号 | K |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| 1 | =1 | 6 | =3 |\n| 2 | =2 | 7 | =3 |\n| 3 | =2 | 8 | =4 |\n| 4 | =2 | 9 | =4 |\n| 5 | =3 | 10 | =4 |\n\n对于 100% 的数据，保证 T ≤ $10^4$\n, 1 ≤ n ≤ 50, 1 ≤ xi ≤ K。\n\n**在实际的测试点中，T 组数据的 K 都是相同的**\n\n$\\textcolor{white}{SookeAKIOI}$", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2017] Tower of Hanoi", "background": "Although Jiutiao often sets problems, she found that setting an entire contest by herself was really too hard, so she dropped the work at hand and started playing some mini-games.", "description": "There is a modified version of the Tower of Hanoi. In this game, disks are allowed to have the same size, but it is guaranteed that for each size there are exactly $K$ disks of that size.\n\nIn the initial state, all disks are stacked on the first peg from bottom to top in non-increasing order of size (larger below, smaller above). For disks of the same size, we label them from $1$ to $K$ from bottom to top. The goal is to move all disks to the third peg.\n\nSince there is no requirement on the relative order of disks of the same size, it is easy to see that there are many legal terminal states. Therefore, the game specifies one particular terminal state.\n\nThe task is to minimize the number of moves.\n\nJiutiao thought this problem seemed quite difficult, so she put it into the contest for you to solve.\n\nThe specific rules are as follows:\n\n- There are three pegs and several circular disks. In the initial state, all disks are on the first peg.\n- At any moment, you may move the top disk of one peg to the top of another peg, with the goal of moving all disks to the third peg.\n- During the process, you must ensure that a larger disk is never placed on top of a smaller disk. (There is no order restriction among disks of the same size.)", "inputFormat": "The first line contains an integer indicating the number of test cases.\n\nFor each test case, the first line contains two integers $n$ and $K$.\n\nThe next $n$ lines, in order from larger sizes to smaller sizes, give the relative order of the $K$ disks of that same size in the terminal state (from left to right represents bottom to top).\n\nFor example, when $K = 2$, `2 1` means the disk that was originally on top goes to the bottom, and the disk that was originally on the bottom goes to the top.", "outputFormat": "For each test case, output one integer indicating the minimum number of moves.", "hint": "| Test Point ID | K | Test Point ID | K |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| 1 | =1 | 6 | =3 |\n| 2 | =2 | 7 | =3 |\n| 3 | =2 | 8 | =4 |\n| 4 | =2 | 9 | =4 |\n| 5 | =3 | 10 | =4 |\n\nFor $100\\%$ of the data, it is guaranteed that $T \\le 10^4$, $1 \\le n \\le 50$, $1 \\le x_i \\le K$.\n\n**In the actual test points, the values of $K$ are the same for all $T$ test cases.**\n\n$\\textcolor{white}{SookeAKIOI}$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2017] 汉诺塔", "background": "虽然九条可怜经常出题，但是她发现要一个人出一场比赛是在是太难了，于是她丢下了手头的出题工作开始玩小游戏。", "description": "有一个游戏是汉诺塔的改版。在这个游戏中，盘子的大小可以相同，但是保证了相同大小的盘子恰好有 K 个。\n\n初始状态下，所有盘子自底向上从大到小地放置在第一根柱子上，对于相同大小的盘子，我们自底向上给它们从 1 到 K 标号。目标是把所有盘子都移动到第三根柱子上。\n\n因为相同大小的盘子的上下顺序没有要求，不难发现合法的终止状态有很多，因此游戏里指定了一种终止状态。\n\n游戏的任务是最小化移动的步数。\n\n可怜想了想觉得这个问题好像挺难的，于是她就把这个出到比赛里来给你做啦。\n\n下面给出汉诺塔的具体规则：\n\n• 有三根柱子和若干块圆盘，初始状态下所有圆盘都在第一根柱子上。\n\n• 每一时刻你可以把某一根柱子顶端的圆盘移动到另一根柱子的顶端，目标是把\n所有盘子都\n\n移动到第三根柱子上。\n\n• 移动的过程中必须要保证较大的圆盘不会压在较小的圆盘上。（相同大小的圆盘没有顺序限制）。\n", "inputFormat": "第一行输入一个整数表示数据组数。\n\n每组数据第一行是两个整数 n 和 K。\n\n接下来 n 行按照盘子从大到小的顺序给出终止状态下同一大小的盘子的相对顺序（从左到右依次表示自底向上），\n\n例如 K = 2 时，2 1 表示原来在上方的盘子到了下面，原来在下方的盘子到了上面。", "outputFormat": "对于每组数据输出一个整数表示最少步数。", "hint": "\n| 测试点编号 | K | 测试点编号 | K |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| 1 | =1 | 6 | =3 |\n| 2 | =2 | 7 | =3 |\n| 3 | =2 | 8 | =4 |\n| 4 | =2 | 9 | =4 |\n| 5 | =3 | 10 | =4 |\n\n对于 100% 的数据，保证 T ≤ $10^4$\n, 1 ≤ n ≤ 50, 1 ≤ xi ≤ K。\n\n**在实际的测试点中，T 组数据的 K 都是相同的**\n\n$\\textcolor{white}{SookeAKIOI}$", "locale": "zh-CN"}}}
{"pid": "P5210", "type": "P", "difficulty": 7, "samples": [["10\n3 1 2 9 6 4 5 7 8\n3\n7 6 7\n18 4 5\n14 5 6\n", "7\n11\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "各省省选", "浙江"], "title": "[ZJOI2017] 线段树", "background": "线段树是九条可怜很喜欢的一个数据结构，它拥有着简单的结构、优秀的复杂度与强大的功能，因此可怜曾经花了很长时间研究线段树的一些性质。\n", "description": "线段树是九条可怜很喜欢的一个数据结构，它拥有着简单的结构、优秀的复杂度与强大的功能，因此可怜曾经花了很长时间研究线段树的一些性质。\n\n最近可怜又开始研究起线段树来了，有所不同的是，她把目光放在了更广义的线段树上：在正常的线段树中，对于区间 $[l, r]$，我们会取 $m = \\lfloor \\frac{l+r}{2} \\rfloor$，然后将这个区间分成 $[l, m]$ 和 $[m + 1, r]$ 两个子区间。在广义的线段树中，$m$ 不要求恰好等于区间的中点，但是 $m$ 还是必须满足 $l \\le m < r$ 的。不难发现在广义的线段树中，树的深度可以达到 $O(n)$ 级别。\n\n例如下面这棵树，就是一棵广义的线段树：\n\n![Segment tree](https://cdn.luogu.com.cn/upload/pic/50896.png)\n\n为了方便，我们按照先序遍历给线段树上所有的节点标号，例如在上图中，$[2, 3]$ 的标号是 $5$，$[4, 4]$ 的标号是 $9$，不难发现在 $[1, n]$ 上建立的广义线段树，它共有着 $2n − 1$ 个节点。\n\n考虑把线段树上的定位区间操作 $($就是打懒标记的时候干的事情$)$ 移植到广义线段树上，可以发现在广义的线段树上还是可以用传统的线段树上的方法定位区间的，例如在上图中，蓝色节点和蓝色边就是在定位区间 $[2, 4]$ 时经过的点和边，最终定位到的点是 $[2, 3]$ 和 $[4, 4]$。\n\n如果你对线段树不熟悉，这儿给出定位区间操作形式化的定义：给出区间 $[l, r]$，找出尽可能少的**区间互不相交**的线段树节点，使得它们区间的并集**恰好**是 $[l, r]$。\n\n定义 $S_{[l,r]}$ 为定位区间 $[l, r]$ 得到的点集，例如在上图中，$S_{[2,4]} = \\{5, 9\\}$。定义线段树上两个点 $u, v$ 的距离 $d(u, v)$ 为线段树上 $u$ 到 $v$ 最短路径上的边数，例如在上图中 $d(5, 9) = 3$。\n\n现在可怜给了你一棵 $[1, n]$ 上的广义的线段树并给了 $m$ 组询问，每组询问给出三个数 $u, l, r\\ (l \\le r)$，可怜想要知道 $\\sum_{v \\in S_{[l, r]}} d(u, v)$。", "inputFormat": "第一行输入一个整数 $n$。\n\n接下来一行包含 $n - 1$ 个空格隔开的整数：按照标号递增的顺序，给出广义线段树上所有**非叶子**节点的划分位置 $m$。不难发现通过这些信息就能唯一确定一棵 $[1, n]$ 上的广义线段树。\n\n接下来一行输入一个整数 $m$。\n\n之后 $m$ 行每行输入三个整数 $u, l, r\\ (1 \\le u \\le 2n − 1, 1 \\le l \\le r \\le n)$，表示一组询问。", "outputFormat": "对于每组询问，输出一个整数表示答案。\n", "hint": "|  测试点编号   |         $n$         |         $m$         | 其他约定  |   \n| :------: | :-----------------: | :-----------------: | :---: |   \n|    $1$     |      $\\le 100$      |      $\\le 100$      |   无   |    \n|    $2$     | $\\le 2 \\times 10^5$ |      $\\le 20$       |   无   |    \n|   $3,4$    | $\\le 2 \\times 10^5$ | $\\le 2 \\times 10^5$ | $r=n$ |    \n|   $5,6$    | $\\le 2 \\times 10^5$ | $\\le 2 \\times 10^5$ | $u=1$ |    \n| $7,8,9,10$ | $\\le 2 \\times 10^5$ | $\\le 2 \\times 10^5$ |   无   |    \n\n对于 $100\\%$ 的数据，保证 $n \\ge 2, m \\ge 1$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2017] Segment Tree", "background": "A segment tree is a data structure that Jiu Tiao Ke Lian likes very much. It has a simple structure, good complexity, and powerful functions, so Ke Lian once spent a long time studying some properties of segment trees.", "description": "A segment tree is a data structure that Jiu Tiao Ke Lian likes very much. It has a simple structure, good complexity, and powerful functions, so Ke Lian once spent a long time studying some properties of segment trees.\n\nRecently, Ke Lian started studying segment trees again. The difference is that she focused on a more general segment tree. In a normal segment tree, for an interval $[l, r]$, we take $m = \\lfloor \\frac{l+r}{2} \\rfloor$, and then split this interval into two sub-intervals $[l, m]$ and $[m + 1, r]$. In a generalized segment tree, $m$ is not required to be exactly the midpoint of the interval, but it still must satisfy $l \\le m < r$. It is not hard to see that in a generalized segment tree, the depth of the tree can reach $O(n)$.\n\nFor example, the following tree is a generalized segment tree:\n\n![Segment tree](https://cdn.luogu.com.cn/upload/pic/50896.png)\n\nFor convenience, we number all nodes of the segment tree by preorder traversal. For example, in the figure above, the number of $[2, 3]$ is $5$, and the number of $[4, 4]$ is $9$. It is not hard to see that a generalized segment tree built on $[1, n]$ has a total of $2n - 1$ nodes.\n\nConsider transplanting the interval-location operation on a segment tree (this is what is done when applying lazy tags) to a generalized segment tree. You can find that on a generalized segment tree, you can still locate an interval using the traditional segment tree method. For example, in the figure above, the blue nodes and blue edges are the nodes and edges passed when locating interval $[2, 4]$, and the final located nodes are $[2, 3]$ and $[4, 4]$.\n\nIf you are not familiar with segment trees, here is a formal definition of the interval-location operation. Given an interval $[l, r]$, find as few segment tree nodes as possible whose intervals are **pairwise disjoint**, such that the union of their intervals is **exactly** $[l, r]$.\n\nDefine $S_{[l,r]}$ as the set of nodes obtained by locating interval $[l, r]$. For example, in the figure above, $S_{[2,4]} = \\{5, 9\\}$. Define the distance $d(u, v)$ between two nodes $u, v$ on the segment tree as the number of edges on the shortest path from $u$ to $v$ on the segment tree. For example, in the figure above, $d(5, 9) = 3$.\n\nNow, Ke Lian gives you a generalized segment tree on $[1, n]$ and $m$ queries. Each query gives three integers $u, l, r\\ (l \\le r)$. Ke Lian wants to know $\\sum_{v \\in S_{[l, r]}} d(u, v)$.", "inputFormat": "The first line contains an integer $n$.\n\nThe next line contains $n - 1$ space-separated integers. In increasing order of node number, they give the split position $m$ of every **non-leaf** node in the generalized segment tree. It is not hard to see that this information uniquely determines a generalized segment tree on $[1, n]$.\n\nThe next line contains an integer $m$.\n\nThen follow $m$ lines. Each line contains three integers $u, l, r\\ (1 \\le u \\le 2n - 1, 1 \\le l \\le r \\le n)$, representing a query.", "outputFormat": "For each query, output one integer as the answer.", "hint": "| Test Point ID | $n$ | $m$ | Other Constraints |\n| :------: | :-----------------: | :-----------------: | :---: |\n| $1$ | $\\le 100$ | $\\le 100$ | None |\n| $2$ | $\\le 2 \\times 10^5$ | $\\le 20$ | None |\n| $3,4$ | $\\le 2 \\times 10^5$ | $\\le 2 \\times 10^5$ | $r = n$ |\n| $5,6$ | $\\le 2 \\times 10^5$ | $\\le 2 \\times 10^5$ | $u = 1$ |\n| $7,8,9,10$ | $\\le 2 \\times 10^5$ | $\\le 2 \\times 10^5$ | None |\n\nFor $100\\%$ of the testdata, it is guaranteed that $n \\ge 2, m \\ge 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2017] 线段树", "background": "线段树是九条可怜很喜欢的一个数据结构，它拥有着简单的结构、优秀的复杂度与强大的功能，因此可怜曾经花了很长时间研究线段树的一些性质。\n", "description": "线段树是九条可怜很喜欢的一个数据结构，它拥有着简单的结构、优秀的复杂度与强大的功能，因此可怜曾经花了很长时间研究线段树的一些性质。\n\n最近可怜又开始研究起线段树来了，有所不同的是，她把目光放在了更广义的线段树上：在正常的线段树中，对于区间 $[l, r]$，我们会取 $m = \\lfloor \\frac{l+r}{2} \\rfloor$，然后将这个区间分成 $[l, m]$ 和 $[m + 1, r]$ 两个子区间。在广义的线段树中，$m$ 不要求恰好等于区间的中点，但是 $m$ 还是必须满足 $l \\le m < r$ 的。不难发现在广义的线段树中，树的深度可以达到 $O(n)$ 级别。\n\n例如下面这棵树，就是一棵广义的线段树：\n\n![Segment tree](https://cdn.luogu.com.cn/upload/pic/50896.png)\n\n为了方便，我们按照先序遍历给线段树上所有的节点标号，例如在上图中，$[2, 3]$ 的标号是 $5$，$[4, 4]$ 的标号是 $9$，不难发现在 $[1, n]$ 上建立的广义线段树，它共有着 $2n − 1$ 个节点。\n\n考虑把线段树上的定位区间操作 $($就是打懒标记的时候干的事情$)$ 移植到广义线段树上，可以发现在广义的线段树上还是可以用传统的线段树上的方法定位区间的，例如在上图中，蓝色节点和蓝色边就是在定位区间 $[2, 4]$ 时经过的点和边，最终定位到的点是 $[2, 3]$ 和 $[4, 4]$。\n\n如果你对线段树不熟悉，这儿给出定位区间操作形式化的定义：给出区间 $[l, r]$，找出尽可能少的**区间互不相交**的线段树节点，使得它们区间的并集**恰好**是 $[l, r]$。\n\n定义 $S_{[l,r]}$ 为定位区间 $[l, r]$ 得到的点集，例如在上图中，$S_{[2,4]} = \\{5, 9\\}$。定义线段树上两个点 $u, v$ 的距离 $d(u, v)$ 为线段树上 $u$ 到 $v$ 最短路径上的边数，例如在上图中 $d(5, 9) = 3$。\n\n现在可怜给了你一棵 $[1, n]$ 上的广义的线段树并给了 $m$ 组询问，每组询问给出三个数 $u, l, r\\ (l \\le r)$，可怜想要知道 $\\sum_{v \\in S_{[l, r]}} d(u, v)$。", "inputFormat": "第一行输入一个整数 $n$。\n\n接下来一行包含 $n - 1$ 个空格隔开的整数：按照标号递增的顺序，给出广义线段树上所有**非叶子**节点的划分位置 $m$。不难发现通过这些信息就能唯一确定一棵 $[1, n]$ 上的广义线段树。\n\n接下来一行输入一个整数 $m$。\n\n之后 $m$ 行每行输入三个整数 $u, l, r\\ (1 \\le u \\le 2n − 1, 1 \\le l \\le r \\le n)$，表示一组询问。", "outputFormat": "对于每组询问，输出一个整数表示答案。\n", "hint": "|  测试点编号   |         $n$         |         $m$         | 其他约定  |   \n| :------: | :-----------------: | :-----------------: | :---: |   \n|    $1$     |      $\\le 100$      |      $\\le 100$      |   无   |    \n|    $2$     | $\\le 2 \\times 10^5$ |      $\\le 20$       |   无   |    \n|   $3,4$    | $\\le 2 \\times 10^5$ | $\\le 2 \\times 10^5$ | $r=n$ |    \n|   $5,6$    | $\\le 2 \\times 10^5$ | $\\le 2 \\times 10^5$ | $u=1$ |    \n| $7,8,9,10$ | $\\le 2 \\times 10^5$ | $\\le 2 \\times 10^5$ |   无   |    \n\n对于 $100\\%$ 的数据，保证 $n \\ge 2, m \\ge 1$。", "locale": "zh-CN"}}}
{"pid": "P5211", "type": "P", "difficulty": 7, "samples": [["5 5\n3 2 1 4 3\n2 1 5\n1 2 4 2\n2 1 5\n1 2 5 1\n2 1 5\n", "3\n5\n1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2017", "线段树", "各省省选", "浙江"], "title": "[ZJOI2017] 字符串", "background": "猪小侠最近学习了字符串相关理论，现在他遇到了这样一个题：", "description": "维护一个动态字符串 $s_{1..n}$，字符串的字符集是所有 $|x| \\leq 10 ^ 9$ 的整数。要求支持两个操作：\n\n1. 输入 $l, r, d$，对于所有 $l \\leq i \\leq r$，将 $s_i$ 修改为 $s_i + d$，注意 $d$ 可能是负数。\n\n2. 输入 $l, r$，输出子串 $s_{l..r}$ 的字典序最小的后缀的起点位置。即，如果最小后缀是 $s_{p..r}$（$l\\leq p\\leq r$），请输出 $p$。", "inputFormat": "第一行两个非负整数 $n, q$。\n\n接下来一行包含 $n$ 个正整数，表示初始时的字符串。\n\n接下来 $q$ 行，每行为 $1\\ l\\ r\\ d$ 或 $2\\ l\\ r$，分别表示两种操作。\n", "outputFormat": "对于所有的查询操作按顺序输出答案。", "hint": "| 测试点编号 | $n$ | $m$ | 其他约定 |\n| ------ | ------ | ------ | ------ |\n| $1$ | $\\leq 300$ | $\\leq 300$ | 无 |\n| $2$ | $\\leq 2 \\times 10^4$ | $\\leq 2 \\times 10^4$ | 无 |\n| $3$ | $\\leq 2 \\times 10^4$ | $\\leq 2 \\times 10^5$ | 无 |\n| $4$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ |只有第二类操作 |\n| $5$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ |只有第二类操作 |\n| $6$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ |数据随机生成 |\n| $7$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ |数据随机生成 |\n| $8$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ |无 |\n| $9$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ |无 |\n| $10$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ |无 |\n\n对于 $100\\%$ 的数据，$1\\leq l\\leq r\\leq n$，$|d|\\leq 10 ^ 3$，$|s_i|\\leq 10 ^ 8$。\n\n注意，$6$ 和 $7$ 两个测试数据在随机生成时，$s_i$ 在 $\\{0, 1\\}$ 中随机，$d$ 在 $\\{-1, 1\\}$ 中随机。操作种类和操作区间都是等概率随机的。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2017] String", "background": "Pig Xiaoxia has recently been studying string-related theory, and now he has encountered the following problem.", "description": "Maintain a dynamic string $s_{1..n}$, whose alphabet is all integers with $|x| \\leq 10 ^ 9$. You need to support two operations:\n\n1. Input $l, r, d$. For all $l \\leq i \\leq r$, modify $s_i$ to $s_i + d$. Note that $d$ may be negative.\n\n2. Input $l, r$. Output the starting position of the lexicographically smallest suffix of the substring $s_{l..r}$. That is, if the smallest suffix is $s_{p..r}$ ($l \\leq p \\leq r$), output $p$.", "inputFormat": "The first line contains two non-negative integers $n, q$.\n\nThe next line contains $n$ positive integers, representing the initial string.\n\nThe next $q$ lines each describe an operation in the form $1\\ l\\ r\\ d$ or $2\\ l\\ r$, corresponding to the two operations above.", "outputFormat": "For each query operation, output the answer in order.", "hint": "| Test Point ID | $n$ | $m$ | Other Constraints |\n| ------ | ------ | ------ | ------ |\n| $1$ | $\\leq 300$ | $\\leq 300$ | None |\n| $2$ | $\\leq 2 \\times 10^4$ | $\\leq 2 \\times 10^4$ | None |\n| $3$ | $\\leq 2 \\times 10^4$ | $\\leq 2 \\times 10^5$ | None |\n| $4$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ | Only the second type of operation |\n| $5$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ | Only the second type of operation |\n| $6$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ | testdata generated randomly |\n| $7$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ | testdata generated randomly |\n| $8$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ | None |\n| $9$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ | None |\n| $10$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ | None |\n\nConstraints: For $100\\%$ of the data, $1 \\leq l \\leq r \\leq n$, $|d| \\leq 10 ^ 3$, and $|s_i| \\leq 10 ^ 8$.\n\nNote: In test points $6$ and $7$, during random generation, $s_i$ is chosen randomly from $\\{0, 1\\}$, and $d$ is chosen randomly from $\\{-1, 1\\}$. The operation type and the operation interval are both selected uniformly at random.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2017] 字符串", "background": "猪小侠最近学习了字符串相关理论，现在他遇到了这样一个题：", "description": "维护一个动态字符串 $s_{1..n}$，字符串的字符集是所有 $|x| \\leq 10 ^ 9$ 的整数。要求支持两个操作：\n\n1. 输入 $l, r, d$，对于所有 $l \\leq i \\leq r$，将 $s_i$ 修改为 $s_i + d$，注意 $d$ 可能是负数。\n\n2. 输入 $l, r$，输出子串 $s_{l..r}$ 的字典序最小的后缀的起点位置。即，如果最小后缀是 $s_{p..r}$（$l\\leq p\\leq r$），请输出 $p$。", "inputFormat": "第一行两个非负整数 $n, q$。\n\n接下来一行包含 $n$ 个正整数，表示初始时的字符串。\n\n接下来 $q$ 行，每行为 $1\\ l\\ r\\ d$ 或 $2\\ l\\ r$，分别表示两种操作。\n", "outputFormat": "对于所有的查询操作按顺序输出答案。", "hint": "| 测试点编号 | $n$ | $m$ | 其他约定 |\n| ------ | ------ | ------ | ------ |\n| $1$ | $\\leq 300$ | $\\leq 300$ | 无 |\n| $2$ | $\\leq 2 \\times 10^4$ | $\\leq 2 \\times 10^4$ | 无 |\n| $3$ | $\\leq 2 \\times 10^4$ | $\\leq 2 \\times 10^5$ | 无 |\n| $4$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ |只有第二类操作 |\n| $5$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ |只有第二类操作 |\n| $6$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ |数据随机生成 |\n| $7$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ |数据随机生成 |\n| $8$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ |无 |\n| $9$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ |无 |\n| $10$ | $\\leq 2 \\times 10^5$ | $\\leq 3 \\times 10^4$ |无 |\n\n对于 $100\\%$ 的数据，$1\\leq l\\leq r\\leq n$，$|d|\\leq 10 ^ 3$，$|s_i|\\leq 10 ^ 8$。\n\n注意，$6$ 和 $7$ 两个测试数据在随机生成时，$s_i$ 在 $\\{0, 1\\}$ 中随机，$d$ 在 $\\{-1, 1\\}$ 中随机。操作种类和操作区间都是等概率随机的。", "locale": "zh-CN"}}}
{"pid": "P5212", "type": "P", "difficulty": 6, "samples": [["2\nA\nQUERY B\nADD BBABBBBAAB", "0"]], "limits": {"time": [1000, 3000, 3000, 1000, 3000, 3000, 1000, 3000, 1000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["平衡树", "后缀自动机 SAM", "O2优化", "动态树 LCT"], "title": "SubString", "background": "", "description": "给定一个字符串 `init`，要求支持两个操作：\n\n- 在当前字符串的后面插入一个字符串。\n\n- 询问字符串 $s$ 在当前字符串中出现了几次。(作为连续子串)\n\n强制在线。", "inputFormat": "第一行一个整数 $Q$ 表示操作个数。\n\n第二行一个字符串表示初始字符串 `init`。\n\n接下来 $Q$ 行，每行 $2$ 个字符串 `Type`,`Str`。\n\n- `Type` 是 `ADD`，表示在后面插入字符串。\n\n- `Type` 是 `QUERY`，表示询问某字符串在当前字符串中出现了几次。\n\n为了体现在线操作，你需要维护一个变量 `mask`，初始值为 $0$。\n\n```cpp\nString decodeWithMask(String s, int mask) {\n\tchar[] chars = s.toCharArray();\n\tfor (int j = 0; j < chars.length; j++) {\n\t\tmask = (mask * 131 + j) % chars.length;\n\t\t\n\t\tchar t = chars[j];\n\t\tchars[j] = chars[mask];\n\t\tchars[mask] = t;\n\t}\n\t\n\treturn new String(chars);\n}\n```\n\n读入串 `Str` 之后，使用这个过程将之解码成真正询问的串 `TrueStr`。\n\n询问的时候，对 `TrueStr` 询问后输出一行答案 `Result`。\n\n然后 $mask=mask \\bigoplus Result$。\n\n插入的时候，将`TrueStr`插到当前字符串后面即可。\n\n**注意：`ADD` 和 `QUERY` 操作的字符串都需要解压。**\n\n", "outputFormat": "对于每一个 `QUERY` 操作，输出询问的字符串在当前字符串中出现了几次。", "hint": "$|\\mathrm{init}| \\leq 6 \\times 10^5$，$Q \\leq 6\\times 10^5$，询问总长度 $\\leq 3 \\times 10^6$。\n\n保证字符串中只会出现 `A` 和 `B`。\n\n为防止评测过慢，对于测试点 $2,3,5,6,8,11$ 时限为 3s，其余为 1s。\n\n原题：BZOJ 2555", "locale": "zh-CN", "translations": {"en": {"title": "SubString", "background": "", "description": "Given a string `init`, you need to support two operations:\n\n- Append a string to the end of the current string.\n\n- Query how many times a string $s$ appears in the current string (as a contiguous substring).\n\nThe operations are strictly online.", "inputFormat": "The first line contains an integer $Q$, the number of operations.\n\nThe second line contains a string, the initial string `init`.\n\nNext come $Q$ lines. Each line contains two strings, `Type` and `Str`.\n\n- `Type` is `ADD`, meaning to append a string to the end.\n\n- `Type` is `QUERY`, meaning to ask how many times a string appears in the current string.\n\nTo enforce online processing, you need to maintain a variable `mask`, initially $0$.\n\n```cpp\nString decodeWithMask(String s, int mask) {\n\tchar[] chars = s.toCharArray();\n\tfor (int j = 0; j < chars.length; j++) {\n\t\tmask = (mask * 131 + j) % chars.length;\n\t\t\n\t\tchar t = chars[j];\n\t\tchars[j] = chars[mask];\n\t\tchars[mask] = t;\n\t}\n\t\n\treturn new String(chars);\n}\n```\n\nAfter reading `Str`, use this process to decode it into the real string `TrueStr`.\n\nFor a query, query `TrueStr` and output one line with the answer `Result`.\n\nThen update $mask = mask \\bigoplus Result$.\n\nFor an insertion, append `TrueStr` to the end of the current string.\n\n**Note: the strings in both `ADD` and `QUERY` operations must be decoded.**", "outputFormat": "For each `QUERY` operation, output how many times the queried string appears in the current string.", "hint": "$|\\mathrm{init}| \\leq 6 \\times 10^5$, $Q \\leq 6 \\times 10^5$, and the total length of all queried strings is at most $3 \\times 10^6$.\n\nIt is guaranteed that the strings contain only `A` and `B`.\n\nTo avoid slow judging, for test points $2,3,5,6,8,11$ the time limit is 3 s, and for the others it is 1 s.\n\nOriginal problem: BZOJ 2555.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "SubString", "background": "", "description": "给定一个字符串 `init`，要求支持两个操作：\n\n- 在当前字符串的后面插入一个字符串。\n\n- 询问字符串 $s$ 在当前字符串中出现了几次。(作为连续子串)\n\n强制在线。", "inputFormat": "第一行一个整数 $Q$ 表示操作个数。\n\n第二行一个字符串表示初始字符串 `init`。\n\n接下来 $Q$ 行，每行 $2$ 个字符串 `Type`,`Str`。\n\n- `Type` 是 `ADD`，表示在后面插入字符串。\n\n- `Type` 是 `QUERY`，表示询问某字符串在当前字符串中出现了几次。\n\n为了体现在线操作，你需要维护一个变量 `mask`，初始值为 $0$。\n\n```cpp\nString decodeWithMask(String s, int mask) {\n\tchar[] chars = s.toCharArray();\n\tfor (int j = 0; j < chars.length; j++) {\n\t\tmask = (mask * 131 + j) % chars.length;\n\t\t\n\t\tchar t = chars[j];\n\t\tchars[j] = chars[mask];\n\t\tchars[mask] = t;\n\t}\n\t\n\treturn new String(chars);\n}\n```\n\n读入串 `Str` 之后，使用这个过程将之解码成真正询问的串 `TrueStr`。\n\n询问的时候，对 `TrueStr` 询问后输出一行答案 `Result`。\n\n然后 $mask=mask \\bigoplus Result$。\n\n插入的时候，将`TrueStr`插到当前字符串后面即可。\n\n**注意：`ADD` 和 `QUERY` 操作的字符串都需要解压。**\n\n", "outputFormat": "对于每一个 `QUERY` 操作，输出询问的字符串在当前字符串中出现了几次。", "hint": "$|\\mathrm{init}| \\leq 6 \\times 10^5$，$Q \\leq 6\\times 10^5$，询问总长度 $\\leq 3 \\times 10^6$。\n\n保证字符串中只会出现 `A` 和 `B`。\n\n为防止评测过慢，对于测试点 $2,3,5,6,8,11$ 时限为 3s，其余为 1s。\n\n原题：BZOJ 2555", "locale": "zh-CN"}}}
{"pid": "P5213", "type": "P", "difficulty": 6, "samples": [["2 3 2 2", "1"], ["5 5 2 0", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "各省省选", "上海", "分类讨论"], "title": "[SHOI2014] 超能粒子炮", "background": "shoi2014 day1t3", "description": "邪恶的巨型宇宙怪物 CCM (Crazy Code Monster) 即将对美丽的地球发动攻击！\n\n在这千钧一发的时刻,地球联合军决定使用地球最先进的能量武器——由发明家 SHTSC 设计的超能粒子炮彻底摧毁 CCM。\n\n超能粒子炮由垂直方向从上到下共 $n$ 个超能粒子发射管构成,编号 $1 \\sim n$。所有的发射管都会在开火的一瞬间同时发射出强大的超能粒子流。  \n为了彻底摧毁再生能力极强的邪恶宇宙怪物 CCM，地球联合军将 CCM 从上到下分为 $m$ 个区域，编号 $1 \\sim m$，分别进行打击。其中超能粒子炮的第 $i$ 号发射管将会对准 $f(i)$ 号区域发射。$f(i)$ 的公式如下：\n$$f(i) = (ai + b) \\bmod m + 1$$\n其中 $a, b$ 都是给定的常数。\n\n然而，出于某种不可告人的目的，N 财团不希望 CCM 被超能粒子炮彻底消灭。于是 N 财团以远程精神控制了超能粒子炮的操作员——你来阻止地球军消灭 CCM。\n\n你发现，超能粒子炮的开火模式会使得不同的粒子流的运动轨迹发生交叉，而在所有这些交叉点处部署一种名为折跃棱镜的能量反射装置就能使得超能粒子炮因过载而自爆。这样，你就可以阻止地球联合军使用超能粒子炮摧毁 CCM 而成为下一代 N 财团金牌的获得者。\n\n为了实现这个计划,你需要知道有多少对粒子流 $i, j$，满足 $i<j$ 且 $f(i) > f(j)$。", "inputFormat": "第一行四个整数 $n, m, a, b$。分别为超能粒子炮的发射管数目、CCM 被分成的区域数、以及题目描述中的 $f$ 公式中的常数。", "outputFormat": "输出一行一个整数，为运动轨迹交叉的粒子流的对数。", "hint": "对于 10%的数据，$n\\leq 5 \\times 10^3$。\n\n对于 20%的数据，$n\\leq m\\leq 10^6$。\n\n对于额外 20%的数据，$b=0$。\n\n对于 80%的数据，$1\\leq a\\leq 1000$。\n\n对于 $100\\%$ 的数据，$n \\leq m \\leq 10^9$，存在 $a'$ 满足 $a\\times a' =1 \\pmod m$，且 $\\min \\{a,a'\\} \\leq 1000, a,b<m$，$m$ 是质数。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2014] Super Particle Cannon.", "background": "shoi2014 day1t3", "description": "The evil giant space monster CCM (Crazy Code Monster) is about to attack the beautiful Earth.\n\nAt this critical moment, the Earth Allied Forces decide to use the most advanced energy weapon on Earth—the Super Particle Cannon designed by the inventor SHTSC—to completely destroy CCM.\n\nThe Super Particle Cannon consists of $n$ Super Particle launch tubes arranged vertically from top to bottom, numbered $1 \\sim n$. All tubes will fire powerful Super Particle streams at the same instant.  \nTo completely destroy the evil space monster CCM, which has extremely strong regeneration ability, the Earth Allied Forces divide CCM from top to bottom into $m$ regions, numbered $1 \\sim m$, and attack them separately. The $i$-th launch tube of the Super Particle Cannon will aim at region $f(i)$. The formula of $f(i)$ is:\n$$f(i) = (ai + b) \\bmod m + 1$$\nwhere $a$ and $b$ are given constants.\n\nHowever, for some unspeakable purpose, the N Consortium does not want CCM to be completely eliminated by the Super Particle Cannon. So the N Consortium remotely mind-controls the operator of the Super Particle Cannon—you—to stop the Earth forces from destroying CCM.\n\nYou discover that the firing pattern of the Super Particle Cannon will cause the trajectories of different particle streams to cross. If energy reflection devices called Warp Prisms are deployed at all these intersection points, the Super Particle Cannon will overload and self-destruct. In this way, you can stop the Earth Allied Forces from using the Super Particle Cannon to destroy CCM, and become the next-generation gold medal winner of the N Consortium.\n\nTo carry out this plan, you need to know how many pairs of particle streams $i, j$ satisfy $i<j$ and $f(i) > f(j)$.", "inputFormat": "The first line contains four integers $n, m, a, b$, representing the number of launch tubes of the Super Particle Cannon, the number of regions CCM is divided into, and the constants in the formula $f$ described above.", "outputFormat": "Output one integer in a single line, the number of pairs of particle streams whose trajectories intersect.", "hint": "For $10\\%$ of the data, $n\\leq 5 \\times 10^3$.\n\nFor $20\\%$ of the data, $n\\leq m\\leq 10^6$.\n\nFor an additional $20\\%$ of the data, $b=0$.\n\nFor $80\\%$ of the data, $1\\leq a\\leq 1000$.\n\nFor $100\\%$ of the data, $n \\leq m \\leq 10^9$, there exists $a'$ such that $a\\times a' =1 \\pmod m$, and $\\min \\{a,a'\\} \\leq 1000, a,b<m$, and $m$ is prime.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2014] 超能粒子炮", "background": "shoi2014 day1t3", "description": "邪恶的巨型宇宙怪物 CCM (Crazy Code Monster) 即将对美丽的地球发动攻击！\n\n在这千钧一发的时刻,地球联合军决定使用地球最先进的能量武器——由发明家 SHTSC 设计的超能粒子炮彻底摧毁 CCM。\n\n超能粒子炮由垂直方向从上到下共 $n$ 个超能粒子发射管构成,编号 $1 \\sim n$。所有的发射管都会在开火的一瞬间同时发射出强大的超能粒子流。  \n为了彻底摧毁再生能力极强的邪恶宇宙怪物 CCM，地球联合军将 CCM 从上到下分为 $m$ 个区域，编号 $1 \\sim m$，分别进行打击。其中超能粒子炮的第 $i$ 号发射管将会对准 $f(i)$ 号区域发射。$f(i)$ 的公式如下：\n$$f(i) = (ai + b) \\bmod m + 1$$\n其中 $a, b$ 都是给定的常数。\n\n然而，出于某种不可告人的目的，N 财团不希望 CCM 被超能粒子炮彻底消灭。于是 N 财团以远程精神控制了超能粒子炮的操作员——你来阻止地球军消灭 CCM。\n\n你发现，超能粒子炮的开火模式会使得不同的粒子流的运动轨迹发生交叉，而在所有这些交叉点处部署一种名为折跃棱镜的能量反射装置就能使得超能粒子炮因过载而自爆。这样，你就可以阻止地球联合军使用超能粒子炮摧毁 CCM 而成为下一代 N 财团金牌的获得者。\n\n为了实现这个计划,你需要知道有多少对粒子流 $i, j$，满足 $i<j$ 且 $f(i) > f(j)$。", "inputFormat": "第一行四个整数 $n, m, a, b$。分别为超能粒子炮的发射管数目、CCM 被分成的区域数、以及题目描述中的 $f$ 公式中的常数。", "outputFormat": "输出一行一个整数，为运动轨迹交叉的粒子流的对数。", "hint": "对于 10%的数据，$n\\leq 5 \\times 10^3$。\n\n对于 20%的数据，$n\\leq m\\leq 10^6$。\n\n对于额外 20%的数据，$b=0$。\n\n对于 80%的数据，$1\\leq a\\leq 1000$。\n\n对于 $100\\%$ 的数据，$n \\leq m \\leq 10^9$，存在 $a'$ 满足 $a\\times a' =1 \\pmod m$，且 $\\min \\{a,a'\\} \\leq 1000, a,b<m$，$m$ 是质数。", "locale": "zh-CN"}}}
{"pid": "P5214", "type": "P", "difficulty": 5, "samples": [["7 10\n1 2\n2 3\n3 4\n4 1\n1 3\n2 4\n5 6\n6 7\n7 5\n2 5\n10\nQ\nD 2 5\nQ\nD 5 6\nD 5 7\nQ\nA 2 5\nQ\nA 5 6\nQ", "1\n2\n3\n2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2014", "各省省选", "上海"], "title": "[SHOI2014] 神奇化合物", "background": "SHOI2014 day2t1", "description": "科学家最近发现了一种高分子有机化合物 SHTSC。这种物质的分子由单个或多个原子组成，原子之间通过化学键相互连接。SHTSC 十分不稳定，其原子之间的化学键经常会伴随着炫酷的声音特效和光影效果发生断裂或者重新连接。\n\n然而，令科学家们大为惊异的是，SHTSC 在变化过程中始终保持着一种特殊的性质：即不存在这样的原子序列 $a_1,a_2,\\ldots,a_n \\ (n>3)$ 满足 $a_1$ 与 $a_2$、$a_2$ 与 $a_3$、……、$a_{n-1}$ 与 $a_n$ 以及 $a_n$ 与 $a_1$ 都通过化学键相连,但它们之间却没有其他化学键相连的情况。\n\n现在科学家将 SHTSC 的原子由 $1$ 到 $n$ 标号，并告诉你 SHTSC 的初始形态以及原子之间的化学键变化情况，他们想知道在实验过程中的某些时刻 SHTSC 分裂成了多少个分子？", "inputFormat": "第一行两个整数 $n, m$。表示 SHTSC 的总原子个数以及初始的化学键数。  \n从第二行开始的 $m$ 行，每行两个整数 $a, b \\ (1 \\leq a,b \\leq n)$。表示编号为 $a, b$ 的两个原子在初始状态中有化学键相连。数据保证每对 $a, b$ 只出现一次。  \n第 $m+2$ 行有一个整数 $q$。表示实验的总操作数。  \n之后 $q$ 行中的每一行为以下三种操作当中的一种：\n1. ``A i j`` 表示 $i$ 号原子与 $j$ 号原子之间形成了一条新的化学键;\n2. ``D i j`` 表示 $i$ 号原子与 $j$ 号原子之间原有的化学键断裂了;\n3. ``Q`` 询问当前 SHTSC 分裂成了多少个不同的分子。\n数据保证所有的实验操作都是合法的。", "outputFormat": "对于每个 $Q$ 操作，输出一行一个整数，为相应时刻的分子个数。", "hint": "对于 30%的数据，$n, q\\leq 1000$。\n\n对于 100%的数据，$n\\leq 5000,m\\leq 200000,q\\leq 10000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2014] Magical Compound", "background": "SHOI2014 day2t1", "description": "Scientists have recently discovered a polymer organic compound called SHTSC. The molecules of this substance consist of one or more atoms, and atoms are connected to each other by chemical bonds. SHTSC is very unstable: the chemical bonds between its atoms often break or reconnect, accompanied by cool sound effects and visual effects.\n\nHowever, what greatly surprised the scientists is that during these changes, SHTSC always maintains a special property: there does not exist an atom sequence $a_1,a_2,\\ldots,a_n \\ (n>3)$ such that $a_1$ is bonded to $a_2$, $a_2$ is bonded to $a_3$, $\\ldots$, $a_{n-1}$ is bonded to $a_n$, and $a_n$ is bonded to $a_1$, but there are no other chemical bonds among them.\n\nNow the scientists label the atoms of SHTSC from $1$ to $n$, and tell you the initial form of SHTSC and the changes of chemical bonds between atoms. They want to know, at certain moments during the experiment, into how many molecules SHTSC is split.", "inputFormat": "The first line contains two integers $n, m$, representing the total number of atoms in SHTSC and the number of initial chemical bonds.  \nStarting from the second line, the next $m$ lines each contain two integers $a, b \\ (1 \\leq a,b \\leq n)$, indicating that atoms $a$ and $b$ are connected by a chemical bond in the initial state. The data guarantees that each pair $a, b$ appears only once.  \nLine $m+2$ contains an integer $q$, representing the total number of operations in the experiment.  \nThe following $q$ lines each describe one of the three types of operations below:  \n1. ``A i j`` means a new chemical bond is formed between atom $i$ and atom $j$.  \n2. ``D i j`` means the existing chemical bond between atom $i$ and atom $j$ is broken.  \n3. ``Q`` asks how many different molecules SHTSC is currently split into.  \nThe data guarantees that all operations are valid.", "outputFormat": "For each `Q` operation, output one line with one integer, the number of molecules at that moment.", "hint": "For $30\\%$ of the testdata, $n, q \\leq 1000$.\n\nFor $100\\%$ of the testdata, $n \\leq 5000, m \\leq 200000, q \\leq 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2014] 神奇化合物", "background": "SHOI2014 day2t1", "description": "科学家最近发现了一种高分子有机化合物 SHTSC。这种物质的分子由单个或多个原子组成，原子之间通过化学键相互连接。SHTSC 十分不稳定，其原子之间的化学键经常会伴随着炫酷的声音特效和光影效果发生断裂或者重新连接。\n\n然而，令科学家们大为惊异的是，SHTSC 在变化过程中始终保持着一种特殊的性质：即不存在这样的原子序列 $a_1,a_2,\\ldots,a_n \\ (n>3)$ 满足 $a_1$ 与 $a_2$、$a_2$ 与 $a_3$、……、$a_{n-1}$ 与 $a_n$ 以及 $a_n$ 与 $a_1$ 都通过化学键相连,但它们之间却没有其他化学键相连的情况。\n\n现在科学家将 SHTSC 的原子由 $1$ 到 $n$ 标号，并告诉你 SHTSC 的初始形态以及原子之间的化学键变化情况，他们想知道在实验过程中的某些时刻 SHTSC 分裂成了多少个分子？", "inputFormat": "第一行两个整数 $n, m$。表示 SHTSC 的总原子个数以及初始的化学键数。  \n从第二行开始的 $m$ 行，每行两个整数 $a, b \\ (1 \\leq a,b \\leq n)$。表示编号为 $a, b$ 的两个原子在初始状态中有化学键相连。数据保证每对 $a, b$ 只出现一次。  \n第 $m+2$ 行有一个整数 $q$。表示实验的总操作数。  \n之后 $q$ 行中的每一行为以下三种操作当中的一种：\n1. ``A i j`` 表示 $i$ 号原子与 $j$ 号原子之间形成了一条新的化学键;\n2. ``D i j`` 表示 $i$ 号原子与 $j$ 号原子之间原有的化学键断裂了;\n3. ``Q`` 询问当前 SHTSC 分裂成了多少个不同的分子。\n数据保证所有的实验操作都是合法的。", "outputFormat": "对于每个 $Q$ 操作，输出一行一个整数，为相应时刻的分子个数。", "hint": "对于 30%的数据，$n, q\\leq 1000$。\n\n对于 100%的数据，$n\\leq 5000,m\\leq 200000,q\\leq 10000$。", "locale": "zh-CN"}}}
{"pid": "P5215", "type": "P", "difficulty": 6, "samples": [["36 3\n6\n4\n2", "1"], ["44 2\n6\n4\n", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "各省省选", "上海"], "title": "[SHOI2014] 神秘金字塔", "background": "SHOI2014 day2t3", "description": "对神经组织的进化生物学研究将历史追溯到了人类社会形成之初、一个叫做 CCM 的神秘部落。\n\n考古学证据表明，CCM 一度具有高度繁华的文明。然而 CCM 的历史却似乎在一夜之间神秘地消失了。考古学家近日在大西洋底发掘出了一处 CCM 文明遗迹,有希望能够揭开 CCM 古文明失落之谜。\n\nCCM 遗迹的中央是一座巨大的石质建筑,被考古学家称之为金字塔。金字塔有这样四条性质:\n1. CCM 金字塔由完全相同的 $1 \\times 1 \\times 1$ 单位的立方体石块构成；\n2. CCM 金字塔由若干层组成，每一层的石块从正上方看都在平面上形成一个联通块。高层的石块都有低层的石块在下方作为支撑，不会有石块悬空；\n3. CCM 金字塔的每一层严格都满足左右对称和上下对称，并且所有层的对称轴是重合的，从左右/上下对称轴向两端长度/宽度非严格递减；\n4. CCM 金字塔的每一层的最大长度和最大宽度都相等，并且都是偶数（因为 CCM 人认为偶数代表了好运而奇数则会带来不幸）。\n\n然而，不幸的是，遗迹中的金字塔由于年代过于久远，已经残缺不全，难以辨认全貌。为了尽可能地还原 CCM 金字塔的实际情况，考古学家们通过其他证据估计出了 CCM 金字塔所使用的石块个数、金字塔的高度以及每一层的宽度，他们想请你帮忙计算符合上述性质的可能的金字塔个数。", "inputFormat": "第一行两个整数 $n,h$，表示 CCM 金字塔的总石块数和 CCM 金字塔的高度。  \n从第二行开始的 $h$ 行，每行一个整数 $l$，表示从最底层开始的每一层的最大长度(宽度)，保证非严格递减。", "outputFormat": "输出一行一个整数，表示可能的金字塔个数。由于方案数可能数量很大，输出答案为模 $10^9+7$ 之后的结果。", "hint": "对于 10%的数据，$h=1$。\n\n对于 30%的数据，$n\\leq 200,l\\leq 10, h\\leq 5$。\n\n对于 70%的数据，$n\\leq 800,l\\leq 20, h\\leq8$。\n\n对于 100%的数据，$n\\leq 1000, 2\\leq l\\leq 20, 1\\leq h\\leq 10$。\n\n![](https://cdn.luogu.com.cn/upload/pic/51009.png)", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2014] Mysterious Pyramid", "background": "SHOI2014 day2t3.", "description": "Evolutionary biology research on neural tissue traces history back to the very beginning of human society, to a mysterious tribe called CCM.\n\nArchaeological evidence shows that CCM once had a highly prosperous civilization. However, CCM’s history seems to have mysteriously vanished overnight. Recently, archaeologists discovered a site of CCM civilization on the Atlantic seabed, and it is hoped that this can uncover the mystery of the lost ancient CCM civilization.\n\nAt the center of the CCM site is a huge stone building, called a pyramid by archaeologists. The pyramid has the following four properties:\n1. The CCM pyramid is made of identical $1 \\times 1 \\times 1$ unit cubic stone blocks.\n2. The CCM pyramid consists of several layers. When viewed from directly above, the blocks in each layer form a connected component on the plane. Every block in an upper layer has blocks in a lower layer directly beneath it for support, so no block is floating.\n3. Each layer of the CCM pyramid strictly satisfies left-right symmetry and up-down symmetry, and the symmetry axes of all layers coincide. Along the left-right / up-down symmetry axes toward both ends, the length / width is non-increasing.\n4. In each layer, the maximum length and the maximum width are equal, and both are even (because CCM people believed even numbers represent good luck, while odd numbers bring misfortune).\n\nUnfortunately, the pyramid in the ruins is too old and has been badly damaged, making it hard to recognize its full shape. In order to reconstruct the real CCM pyramid as much as possible, archaeologists estimated, from other evidence, the number of stone blocks used, the height of the pyramid, and the width of each layer. They want you to help compute how many possible pyramids satisfy the properties above.", "inputFormat": "The first line contains two integers $n, h$, representing the total number of stone blocks in the CCM pyramid and the height of the CCM pyramid.  \nStarting from the second line, there are $h$ lines. Each line contains one integer $l$, representing the maximum length (width) of each layer from the bottom upward. It is guaranteed to be non-increasing.", "outputFormat": "Output one integer on a single line, representing the number of possible pyramids. Since the number of solutions may be very large, output the result modulo $10^9+7$.", "hint": "For $10\\%$ of the testdata, $h = 1$.\n\nFor $30\\%$ of the testdata, $n \\leq 200, l \\leq 10, h \\leq 5$.\n\nFor $70\\%$ of the testdata, $n \\leq 800, l \\leq 20, h \\leq 8$.\n\nFor $100\\%$ of the testdata, $n \\leq 1000, 2 \\leq l \\leq 20, 1 \\leq h \\leq 10$.\n\n![](https://cdn.luogu.com.cn/upload/pic/51009.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2014] 神秘金字塔", "background": "SHOI2014 day2t3", "description": "对神经组织的进化生物学研究将历史追溯到了人类社会形成之初、一个叫做 CCM 的神秘部落。\n\n考古学证据表明，CCM 一度具有高度繁华的文明。然而 CCM 的历史却似乎在一夜之间神秘地消失了。考古学家近日在大西洋底发掘出了一处 CCM 文明遗迹,有希望能够揭开 CCM 古文明失落之谜。\n\nCCM 遗迹的中央是一座巨大的石质建筑,被考古学家称之为金字塔。金字塔有这样四条性质:\n1. CCM 金字塔由完全相同的 $1 \\times 1 \\times 1$ 单位的立方体石块构成；\n2. CCM 金字塔由若干层组成，每一层的石块从正上方看都在平面上形成一个联通块。高层的石块都有低层的石块在下方作为支撑，不会有石块悬空；\n3. CCM 金字塔的每一层严格都满足左右对称和上下对称，并且所有层的对称轴是重合的，从左右/上下对称轴向两端长度/宽度非严格递减；\n4. CCM 金字塔的每一层的最大长度和最大宽度都相等，并且都是偶数（因为 CCM 人认为偶数代表了好运而奇数则会带来不幸）。\n\n然而，不幸的是，遗迹中的金字塔由于年代过于久远，已经残缺不全，难以辨认全貌。为了尽可能地还原 CCM 金字塔的实际情况，考古学家们通过其他证据估计出了 CCM 金字塔所使用的石块个数、金字塔的高度以及每一层的宽度，他们想请你帮忙计算符合上述性质的可能的金字塔个数。", "inputFormat": "第一行两个整数 $n,h$，表示 CCM 金字塔的总石块数和 CCM 金字塔的高度。  \n从第二行开始的 $h$ 行，每行一个整数 $l$，表示从最底层开始的每一层的最大长度(宽度)，保证非严格递减。", "outputFormat": "输出一行一个整数，表示可能的金字塔个数。由于方案数可能数量很大，输出答案为模 $10^9+7$ 之后的结果。", "hint": "对于 10%的数据，$h=1$。\n\n对于 30%的数据，$n\\leq 200,l\\leq 10, h\\leq 5$。\n\n对于 70%的数据，$n\\leq 800,l\\leq 20, h\\leq8$。\n\n对于 100%的数据，$n\\leq 1000, 2\\leq l\\leq 20, 1\\leq h\\leq 10$。\n\n![](https://cdn.luogu.com.cn/upload/pic/51009.png)", "locale": "zh-CN"}}}
{"pid": "P5216", "type": "P", "difficulty": 4, "samples": [["4\n2 3 6 3\n", "156"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "DLS 采花", "background": "超水的签到题", "description": "DLS 有 $N$ 个花田，每个花田里有 $a_i$ 朵花。\n\nDLS 喜欢稀奇古怪的花田，他希望重新排列花田，然后去采花。  \n但 DLS 采花又有一个癖好：他会从左往右采花。  \n若当前采到第 $i$ 个花田，在之前有一个花田的花的数量，是第 $i$ 个花田的花的数量的因子的话，那么 DLS 不会采这个花田的花。\n\n现在，DLS 想知道对于所有排列花田的方案，他能够采到的花的数量的和是多少。  \n由于答案会比较大，请对 $998244353$ 取模。", "inputFormat": "第一行一个正整数 $N$。  \n第二行是一个长度为 $N$ 的序列 $a$。\n", "outputFormat": "共一行，表示所有方案中采花的数量和对 $998244353$ 取模的结果。", "hint": "|数据百分比|限制|\n|-|-|\n|$50\\%$|$N \\le 9$|\n|$80\\%$|$N \\le 1000$|\n|$100\\%$|$N \\le 10^5,a_i \\le 10^5$|", "locale": "zh-CN", "translations": {"en": {"title": "DLS Picking Flowers.", "background": "A very easy check-in problem.", "description": "DLS has $N$ flower fields, and the $i$-th field has $a_i$ flowers.\n\nDLS likes strange and unusual flower fields. He wants to rearrange the fields and then pick flowers.  \nHowever, DLS has another habit when picking flowers: he picks from left to right.  \nWhen he reaches the $i$-th field, if among the fields before it there is a field whose number of flowers is a divisor of the number of flowers in the $i$-th field, then DLS will not pick any flowers from this field.\n\nNow, DLS wants to know, over all permutations of the fields, what the total sum of the number of flowers he can pick is.  \nSince the answer can be large, output it modulo $998244353$.", "inputFormat": "The first line contains a positive integer $N$.  \nThe second line contains a sequence $a$ of length $N$.", "outputFormat": "Output one line: the sum of the number of flowers picked over all permutations, modulo $998244353$.", "hint": "|Data Percentage|Constraints|\n|-|-|\n|$50\\%$|$N \\le 9$|\n|$80\\%$|$N \\le 1000$|\n|$100\\%$|$N \\le 10^5, a_i \\le 10^5$|\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "DLS 采花", "background": "超水的签到题", "description": "DLS 有 $N$ 个花田，每个花田里有 $a_i$ 朵花。\n\nDLS 喜欢稀奇古怪的花田，他希望重新排列花田，然后去采花。  \n但 DLS 采花又有一个癖好：他会从左往右采花。  \n若当前采到第 $i$ 个花田，在之前有一个花田的花的数量，是第 $i$ 个花田的花的数量的因子的话，那么 DLS 不会采这个花田的花。\n\n现在，DLS 想知道对于所有排列花田的方案，他能够采到的花的数量的和是多少。  \n由于答案会比较大，请对 $998244353$ 取模。", "inputFormat": "第一行一个正整数 $N$。  \n第二行是一个长度为 $N$ 的序列 $a$。\n", "outputFormat": "共一行，表示所有方案中采花的数量和对 $998244353$ 取模的结果。", "hint": "|数据百分比|限制|\n|-|-|\n|$50\\%$|$N \\le 9$|\n|$80\\%$|$N \\le 1000$|\n|$100\\%$|$N \\le 10^5,a_i \\le 10^5$|", "locale": "zh-CN"}}}
{"pid": "P5217", "type": "P", "difficulty": 6, "samples": [["12 6\nkimiwakawaii\nR 2 4\nP 4\nD 1\nI 0 w\nT 3\nQ 3 10", "2\nm\n5\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["平衡树", "状压 DP"], "title": "贫穷", "background": "LHF 最大的特点就是贫穷。  \nLHF 最大的爱好就是看购物节目。\n\n这天他又在看购物节目了。  \n他在节目里看到一款新型文本编辑器，~~除了价钱以外~~非常适合他这样的穷人使用。\n\n因为……它能够计算打印成本！  \n（这里的打印成本是与出现过的字母的种类数相关的）\n\n他十分心动，要求你实现这个功能。", "description": "这个文本编辑器支持以下操作：\n - $\\texttt{I x c}$，在第 $x$ 个字母后面插入一个 $c$。\n - $\\texttt{D x}$，删除第 $x$ 个字母。\n - $\\texttt{R x y}$，反转当前文本中的区间 $[x,y]$。\n - $\\texttt{P x}$，输出初始文本中第 $x$ 个字母在当前文本中的位置。特别地，若不存在，输出 $0$。\n - $\\texttt{T x}$，输出当前文本中第 $x$ 个字母。\n - $\\texttt{Q x y}$，输出当前文本中区间 $[x,y]$ 内出现过的字母的种类数。", "inputFormat": "第一行，两个整数 $n,m$，分别表示初始文本长度和操作个数。  \n第二行，一个长度为 $n$ 的字符串，表示初始文本。  \n以下 $m$ 行，每行表示一个操作。", "outputFormat": "对于所有需要输出的操作，输出结果。", "hint": "**数据范围：**\n\n对于 $20\\%$ 的数据，$n \\le 100$。  \n对于 $50\\%$ 的数据，$n \\le 10000$。  \n对于 $100\\%$ 的数据，$1 \\le n,m \\le 10^5$，文本涉及的字母仅包含小写字母。\n\n**样例解释：**\n\n 1. 文本不变，但初始文本中第 $2$ 个字母与第 $4$ 个字母的位置交换。\n 2. 当前第 $2$ 个字母是初始文本的第 $4$ 个字母。\n 3. 文本变为 $\\texttt{imiwakawaii}$。\n 4. 文本变为 $\\texttt{wimiwakawaii}$。\n 5. 这个字母为 $\\texttt{m}$。 \n 6. 这段文本为 $\\texttt{miwakawa}$，包含的字符种类的集合为 $\\{\\texttt{a},\\texttt{i},\\texttt{k},\\texttt{m},\\texttt{w}\\}$，元素个数为 $5$。", "locale": "zh-CN", "translations": {"en": {"title": "Poverty", "background": "LHF’s biggest trait is being poor.  \nLHF’s biggest hobby is watching shopping TV shows.\n\nToday, he was watching a shopping show again.  \nOn the show, he saw a new type of text editor. It was very suitable for a poor person like him ~~except for the price~~.\n\nBecause… it can calculate printing costs.  \n(The printing cost here depends on the number of different kinds of letters that have appeared.)\n\nHe was very interested and asks you to implement this feature.", "description": "This text editor supports the following operations:\n\n- $\\texttt{I x c}$: Insert a $c$ after the $x$-th letter.\n- $\\texttt{D x}$: Delete the $x$-th letter.\n- $\\texttt{R x y}$: Reverse the interval $[x,y]$ in the current text.\n- $\\texttt{P x}$: Output the position of the $x$-th letter in the initial text within the current text. In particular, if it does not exist, output $0$.\n- $\\texttt{T x}$: Output the $x$-th letter in the current text.\n- $\\texttt{Q x y}$: Output the number of different kinds of letters that have appeared in interval $[x,y]$ of the current text.", "inputFormat": "The first line contains two integers $n,m$, representing the length of the initial text and the number of operations.  \nThe second line contains a string of length $n$, representing the initial text.  \nThe next $m$ lines each describe one operation.", "outputFormat": "For every operation that requires output, print the result.", "hint": "**Constraints:**\n\nFor $20\\%$ of the testdata, $n \\le 100$.  \nFor $50\\%$ of the testdata, $n \\le 10000$.  \nFor $100\\%$ of the testdata, $1 \\le n,m \\le 10^5$, and the text contains only lowercase letters.\n\n**Sample Explanation:**\n\n1. The text does not change, but the positions of the $2$-nd and $4$-th letters in the initial text are swapped.\n2. The current $2$-nd letter is the $4$-th letter of the initial text.\n3. The text becomes $\\texttt{imiwakawaii}$.\n4. The text becomes $\\texttt{wimiwakawaii}$.\n5. This letter is $\\texttt{m}$.\n6. This segment is $\\texttt{miwakawa}$, and the set of character kinds it contains is $\\{\\texttt{a},\\texttt{i},\\texttt{k},\\texttt{m},\\texttt{w}\\}$, so the number of elements is $5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "贫穷", "background": "LHF 最大的特点就是贫穷。  \nLHF 最大的爱好就是看购物节目。\n\n这天他又在看购物节目了。  \n他在节目里看到一款新型文本编辑器，~~除了价钱以外~~非常适合他这样的穷人使用。\n\n因为……它能够计算打印成本！  \n（这里的打印成本是与出现过的字母的种类数相关的）\n\n他十分心动，要求你实现这个功能。", "description": "这个文本编辑器支持以下操作：\n - $\\texttt{I x c}$，在第 $x$ 个字母后面插入一个 $c$。\n - $\\texttt{D x}$，删除第 $x$ 个字母。\n - $\\texttt{R x y}$，反转当前文本中的区间 $[x,y]$。\n - $\\texttt{P x}$，输出初始文本中第 $x$ 个字母在当前文本中的位置。特别地，若不存在，输出 $0$。\n - $\\texttt{T x}$，输出当前文本中第 $x$ 个字母。\n - $\\texttt{Q x y}$，输出当前文本中区间 $[x,y]$ 内出现过的字母的种类数。", "inputFormat": "第一行，两个整数 $n,m$，分别表示初始文本长度和操作个数。  \n第二行，一个长度为 $n$ 的字符串，表示初始文本。  \n以下 $m$ 行，每行表示一个操作。", "outputFormat": "对于所有需要输出的操作，输出结果。", "hint": "**数据范围：**\n\n对于 $20\\%$ 的数据，$n \\le 100$。  \n对于 $50\\%$ 的数据，$n \\le 10000$。  \n对于 $100\\%$ 的数据，$1 \\le n,m \\le 10^5$，文本涉及的字母仅包含小写字母。\n\n**样例解释：**\n\n 1. 文本不变，但初始文本中第 $2$ 个字母与第 $4$ 个字母的位置交换。\n 2. 当前第 $2$ 个字母是初始文本的第 $4$ 个字母。\n 3. 文本变为 $\\texttt{imiwakawaii}$。\n 4. 文本变为 $\\texttt{wimiwakawaii}$。\n 5. 这个字母为 $\\texttt{m}$。 \n 6. 这段文本为 $\\texttt{miwakawa}$，包含的字符种类的集合为 $\\{\\texttt{a},\\texttt{i},\\texttt{k},\\texttt{m},\\texttt{w}\\}$，元素个数为 $5$。", "locale": "zh-CN"}}}
{"pid": "P5218", "type": "P", "difficulty": 6, "samples": [["5", "26"], ["16", "65243"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": [], "title": "无聊的水题 II", "background": "出题人过菜，只会出这种题。", "description": "DLS 是一个喜欢玩游戏的男生。\n\n今天他从朋友那里看到了 $N$ 件武器，其中第 $i$ 件武器的威力值为$i$。\n\n他观察了这 $N$ 件武器许久，打算买下其中若干件武器，但他想用买下的武器的威力值组合出任意威力值，其中每一件武器已经的威力值可以叠加，甚至可以减去。  \n例如一个威力值为 $3$ 的武器，可以组合成的威力值为 $\\dots,-6,-3,0,3,6,\\dots$。\n\n他想找出所有满足以上条件的买下装备的方案，但方案数量实在太多了。你能帮他计算一下吗？    \n答案对 $10^9+7$ 取模。", "inputFormat": "一行一个整数 $N$。", "outputFormat": "一行一个整数表示答案", "hint": "|数据百分比|限制|\n|-|-|\n|$10\\%$|$N \\le 20$|\n|$30\\%$|$N \\le 2000$|\n|$60\\%$|$N \\le 10^7$|\n|$100\\%$|$N \\le 10^{11}$|", "locale": "zh-CN", "translations": {"en": {"title": "Boring Easy Problem II", "background": "The problem setter is not skilled, and can only make this kind of problem.", "description": "DLS is a boy who likes playing games.\n\nToday, he saw $N$ weapons from his friend, where the power value of the $i$-th weapon is $i$.\n\nHe observed these $N$ weapons for a long time and plans to buy some of them, but he wants to use the power values of the weapons he buys to form any power value. The power values of each weapon can be added together, and can even be subtracted.  \nFor example, with a weapon whose power value is $3$, the power values that can be formed are $\\dots,-6,-3,0,3,6,\\dots$.\n\nHe wants to find all purchase plans that satisfy the above condition, but there are too many plans. Can you help him compute it?  \nOutput the answer modulo $10^9+7$.", "inputFormat": "One line with one integer $N$.", "outputFormat": "One line with one integer, representing the answer.", "hint": "|Percentage of testdata|Constraints|\n|-|-|\n|$10\\%$|$N \\le 20$|\n|$30\\%$|$N \\le 2000$|\n|$60\\%$|$N \\le 10^7$|\n|$100\\%$|$N \\le 10^{11}$|\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "无聊的水题 II", "background": "出题人过菜，只会出这种题。", "description": "DLS 是一个喜欢玩游戏的男生。\n\n今天他从朋友那里看到了 $N$ 件武器，其中第 $i$ 件武器的威力值为$i$。\n\n他观察了这 $N$ 件武器许久，打算买下其中若干件武器，但他想用买下的武器的威力值组合出任意威力值，其中每一件武器已经的威力值可以叠加，甚至可以减去。  \n例如一个威力值为 $3$ 的武器，可以组合成的威力值为 $\\dots,-6,-3,0,3,6,\\dots$。\n\n他想找出所有满足以上条件的买下装备的方案，但方案数量实在太多了。你能帮他计算一下吗？    \n答案对 $10^9+7$ 取模。", "inputFormat": "一行一个整数 $N$。", "outputFormat": "一行一个整数表示答案", "hint": "|数据百分比|限制|\n|-|-|\n|$10\\%$|$N \\le 20$|\n|$30\\%$|$N \\le 2000$|\n|$60\\%$|$N \\le 10^7$|\n|$100\\%$|$N \\le 10^{11}$|", "locale": "zh-CN"}}}
{"pid": "P5219", "type": "P", "difficulty": 6, "samples": [["3 2", "3"], ["7 4", "2520"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": [], "title": "无聊的水题 I", "background": "出题人过菜，只会出这种题，稍微有点卡常。", "description": "DLS 喜欢上树。  \n但是他并不想把一道数据结构题出到树上，他喜欢计 Tree。\n\n这一天，他想自己造一棵树，他手头有 $N$ 个树的节点，标号为 $1 \\sim N$，他会在它们之间连边，我们定义两颗树不同，当且仅当一对节点在一棵树中有连边，另一棵树中没有连边。  \n但他不喜欢一棵太多分叉的树，于是他想让这棵树的节点中最大的度数为 $M$。\n\nDLS 由于不太擅长理科，所以希望你帮他计算有多少棵这样的树。 \n答案对 $998244353$ 取模。", "inputFormat": "一行两个整数 $N, M$。", "outputFormat": "一行一个整数表示答案。", "hint": "|数据百分比|限制|\n|-|-|\n|$10\\%$|$N,M \\le 8$|\n|$30\\%$|$N,M \\le 100$|\n|$50\\%$|$N,M \\le 500$|\n|$70\\%$|$N,M \\le 2000$|\n|$100\\%$|$2 \\le N,M \\le 5 \\times 10^4$|", "locale": "zh-CN", "translations": {"en": {"title": "Boring Easy Problem I.", "background": "The problem setter is too weak and can only make this kind of problem. It is slightly time-limit tight.", "description": "DLS likes climbing trees.  \nHowever, he does not want to put a data structure problem onto a tree; he likes counting Tree.\n\nOne day, he wants to build a tree by himself. He has $N$ nodes, labeled from $1$ to $N$, and he will connect edges between them. We define two trees to be different if and only if there exists a pair of nodes such that they are connected by an edge in one tree, but not connected by an edge in the other tree.  \nBut he does not like a tree with too many branches, so he wants the maximum degree among all nodes in this tree to be $M$.\n\nSince DLS is not very good at math and science, he hopes you can help him compute how many such trees there are.  \nOutput the answer modulo $998244353$.", "inputFormat": "A single line with two integers $N, M$.", "outputFormat": "A single line with one integer, representing the answer.", "hint": "|Percentage of testdata|Constraints|\n|-|-|\n|$10\\%$|$N, M \\le 8$|\n|$30\\%$|$N, M \\le 100$|\n|$50\\%$|$N, M \\le 500$|\n|$70\\%$|$N, M \\le 2000$|\n|$100\\%$|$2 \\le N, M \\le 5 \\times 10^4$|\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "无聊的水题 I", "background": "出题人过菜，只会出这种题，稍微有点卡常。", "description": "DLS 喜欢上树。  \n但是他并不想把一道数据结构题出到树上，他喜欢计 Tree。\n\n这一天，他想自己造一棵树，他手头有 $N$ 个树的节点，标号为 $1 \\sim N$，他会在它们之间连边，我们定义两颗树不同，当且仅当一对节点在一棵树中有连边，另一棵树中没有连边。  \n但他不喜欢一棵太多分叉的树，于是他想让这棵树的节点中最大的度数为 $M$。\n\nDLS 由于不太擅长理科，所以希望你帮他计算有多少棵这样的树。 \n答案对 $998244353$ 取模。", "inputFormat": "一行两个整数 $N, M$。", "outputFormat": "一行一个整数表示答案。", "hint": "|数据百分比|限制|\n|-|-|\n|$10\\%$|$N,M \\le 8$|\n|$30\\%$|$N,M \\le 100$|\n|$50\\%$|$N,M \\le 500$|\n|$70\\%$|$N,M \\le 2000$|\n|$100\\%$|$2 \\le N,M \\le 5 \\times 10^4$|", "locale": "zh-CN"}}}
{"pid": "P5220", "type": "P", "difficulty": 6, "samples": [["5 3\n1 2 3 4 5\n1 2\n2 3\n3 4\n4 5\nQ 1 5\nC 1 2\nQ 1 5", "325\n565"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": [], "title": "特工的信息流", "background": "$\\text{TYM}$ 是一名特工。  \n$\\text{TYM}$ 所在的国家正受到侵犯，他被赋予一个任务：于城市之间传递信息。", "description": "$\\text{TYM}$ 所在的国家有 $n$ 个城市，编号为 $1,\\dots,n$，由 $n - 1$ 条双向道路连接。保证任意两个城市间都有唯一的简单路径。  \n以及，每个城市都有一个信息流的流量 $a_i$。\n\n$\\text{TYM}$ 一共要执行 $m_0$ 个任务，每个任务给定两个城市 $s,t$，其执行过程如下：  \n第一个时刻，他从城市 $s$ 出发，以每个时刻移动到下一个城市的速度，走 $s,t$ 之间的简单路径到 $t$。  \n每到达一个城市，他都会把这个城市的信息流 $a_i$ 发送到经过的每个城市。  \n我们约定，他到达一个城市的同一时刻也会把这个城市的信息流发送给这个城市。我们定义一个城市的价值为这个城市所接受到的信息流的乘积。\n\n请你求出每个任务中，$s$ 到 $t$ 的简单路径上经过的城市的价值的总和对 $20924$ 取模的结果。\n\n此外，不幸地，由于侵略者同时也在行动，所以在他执行多个任务之间，可能会有某个 $a_i$ 发生改变。\n\n他的任务总数与改变某个 $a_i$ 的次数之和为 $m$。", "inputFormat": "第一行，两个整数 $n,m$。  \n第二行，$n$ 个整数，第 $i$ 个表示第 $i$ 个城市的信息流流量 $a_i$。  \n以下 $n - 1$ 行，每行两个整数 $u,v$，表示 $u,v$ 之间有一条双向道路。  \n以下 $m$ 行，每行描述一个任务或是一次修改事件：\n  - 形如 `Q s t`，表示 $\\text{TYM}$ 从 $s$ 到 $t$ 执行了一次任务。\n  - 形如 `C x k`，表示侵略者的行动令 $a_x \\rightarrow a_x + k$。", "outputFormat": "对于每次任务，输出经过的城市收到的信息流总流量。", "hint": "**数据范围：**\n\n对于 $20\\%$ 的数据，$1 \\leq n,m \\leq 2000$；  \n对于额外的 $20\\%$ 的数据，满足 $a_i=2$，且没有修改操作；  \n对于额外的 $20\\%$ 的数据，满足道路从 $i$ 连向 $i+1$；  \n对于 $100\\%$ 的数据，$1 \\leq n,m \\leq 10^5,1 \\leq a_i \\leq 20923$。\n\n**样例解释：**\n\n第一个询问，$1 \\cdot 2 \\cdot 3 \\cdot 4 \\cdot 5 + 2 \\cdot 3 \\cdot 4 \\cdot 5 + 3 \\cdot 4 \\cdot 5 + 4 \\cdot 5 + 5 = 325$；  \n修改，$a_1 = 1 + 2 = 3$；  \n第二个询问，$3 \\cdot 2 \\cdot 3 \\cdot 4 \\cdot 5 + 2 \\cdot 3 \\cdot 4 \\cdot 5 + 3 \\cdot 4 \\cdot 5 + 4 \\cdot 5 + 5 = 565$；", "locale": "zh-CN", "translations": {"en": {"title": "Agent’s Information Flow", "background": "$\\text{TYM}$ is an agent.  \nThe country where $\\text{TYM}$ lives is being invaded, and he is given a mission: to deliver information between cities.", "description": "The country where $\\text{TYM}$ lives has $n$ cities, numbered $1,\\dots,n$, connected by $n - 1$ bidirectional roads. It is guaranteed that there is a unique simple path between any two cities.  \nAlso, each city has an information flow rate $a_i$.\n\n$\\text{TYM}$ needs to perform a total of $m_0$ missions. Each mission gives two cities $s,t$, and is carried out as follows:  \nAt the first moment, he starts from city $s$ and moves along the simple path between $s$ and $t$ to reach $t$, moving to the next city in each time unit.  \nEvery time he arrives at a city, he sends that city’s information flow $a_i$ to every city on the route he passes through.  \nWe agree that at the same moment he arrives at a city, he also sends that city’s information flow to itself. We define the value of a city as the product of all information flows received by that city.\n\nFor each mission, compute the sum of the values of the cities on the simple path from $s$ to $t$, modulo $20924$.\n\nIn addition, unfortunately, because the invaders are also acting at the same time, between his missions, some $a_i$ may change.\n\nThe total number of missions plus the number of times an $a_i$ is changed is $m$.", "inputFormat": "The first line contains two integers $n,m$.  \nThe second line contains $n$ integers; the $i$-th integer represents the information flow rate $a_i$ of city $i$.  \nThe next $n - 1$ lines each contain two integers $u,v$, indicating that there is a bidirectional road between $u$ and $v$.  \nThe next $m$ lines each describe a mission or an update event:\n- In the form `Q s t`, meaning $\\text{TYM}$ performs a mission from $s$ to $t$.\n- In the form `C x k`, meaning the invaders’ action makes $a_x \\rightarrow a_x + k$.", "outputFormat": "For each mission, output the total sum of information flow received by the cities on the route.", "hint": "**Constraints:**\n\nFor $20\\%$ of the testdata, $1 \\leq n,m \\leq 2000$.  \nFor an additional $20\\%$ of the testdata, $a_i=2$, and there are no update operations.  \nFor an additional $20\\%$ of the testdata, the roads connect $i$ to $i+1$.  \nFor $100\\%$ of the testdata, $1 \\leq n,m \\leq 10^5, 1 \\leq a_i \\leq 20923$.\n\n**Sample Explanation:**\n\nFor the first query, $1 \\cdot 2 \\cdot 3 \\cdot 4 \\cdot 5 + 2 \\cdot 3 \\cdot 4 \\cdot 5 + 3 \\cdot 4 \\cdot 5 + 4 \\cdot 5 + 5 = 325$.  \nUpdate: $a_1 = 1 + 2 = 3$.  \nFor the second query, $3 \\cdot 2 \\cdot 3 \\cdot 4 \\cdot 5 + 2 \\cdot 3 \\cdot 4 \\cdot 5 + 3 \\cdot 4 \\cdot 5 + 4 \\cdot 5 + 5 = 565$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "特工的信息流", "background": "$\\text{TYM}$ 是一名特工。  \n$\\text{TYM}$ 所在的国家正受到侵犯，他被赋予一个任务：于城市之间传递信息。", "description": "$\\text{TYM}$ 所在的国家有 $n$ 个城市，编号为 $1,\\dots,n$，由 $n - 1$ 条双向道路连接。保证任意两个城市间都有唯一的简单路径。  \n以及，每个城市都有一个信息流的流量 $a_i$。\n\n$\\text{TYM}$ 一共要执行 $m_0$ 个任务，每个任务给定两个城市 $s,t$，其执行过程如下：  \n第一个时刻，他从城市 $s$ 出发，以每个时刻移动到下一个城市的速度，走 $s,t$ 之间的简单路径到 $t$。  \n每到达一个城市，他都会把这个城市的信息流 $a_i$ 发送到经过的每个城市。  \n我们约定，他到达一个城市的同一时刻也会把这个城市的信息流发送给这个城市。我们定义一个城市的价值为这个城市所接受到的信息流的乘积。\n\n请你求出每个任务中，$s$ 到 $t$ 的简单路径上经过的城市的价值的总和对 $20924$ 取模的结果。\n\n此外，不幸地，由于侵略者同时也在行动，所以在他执行多个任务之间，可能会有某个 $a_i$ 发生改变。\n\n他的任务总数与改变某个 $a_i$ 的次数之和为 $m$。", "inputFormat": "第一行，两个整数 $n,m$。  \n第二行，$n$ 个整数，第 $i$ 个表示第 $i$ 个城市的信息流流量 $a_i$。  \n以下 $n - 1$ 行，每行两个整数 $u,v$，表示 $u,v$ 之间有一条双向道路。  \n以下 $m$ 行，每行描述一个任务或是一次修改事件：\n  - 形如 `Q s t`，表示 $\\text{TYM}$ 从 $s$ 到 $t$ 执行了一次任务。\n  - 形如 `C x k`，表示侵略者的行动令 $a_x \\rightarrow a_x + k$。", "outputFormat": "对于每次任务，输出经过的城市收到的信息流总流量。", "hint": "**数据范围：**\n\n对于 $20\\%$ 的数据，$1 \\leq n,m \\leq 2000$；  \n对于额外的 $20\\%$ 的数据，满足 $a_i=2$，且没有修改操作；  \n对于额外的 $20\\%$ 的数据，满足道路从 $i$ 连向 $i+1$；  \n对于 $100\\%$ 的数据，$1 \\leq n,m \\leq 10^5,1 \\leq a_i \\leq 20923$。\n\n**样例解释：**\n\n第一个询问，$1 \\cdot 2 \\cdot 3 \\cdot 4 \\cdot 5 + 2 \\cdot 3 \\cdot 4 \\cdot 5 + 3 \\cdot 4 \\cdot 5 + 4 \\cdot 5 + 5 = 325$；  \n修改，$a_1 = 1 + 2 = 3$；  \n第二个询问，$3 \\cdot 2 \\cdot 3 \\cdot 4 \\cdot 5 + 2 \\cdot 3 \\cdot 4 \\cdot 5 + 3 \\cdot 4 \\cdot 5 + 4 \\cdot 5 + 5 = 565$；", "locale": "zh-CN"}}}
{"pid": "P5221", "type": "P", "difficulty": 6, "samples": [["5\n", "585494\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["数学", "O2优化", "莫比乌斯反演"], "title": "Product", "background": "${\\rm CYJian}$：“听说 $\\gcd$ 和 $\\sum$ 套起来比较好玩？？那我就……”", "description": "${\\rm CYJian}$ 最近闲的玩起了 $\\gcd$。他想到了一个非常简单而有意思的式子：\n\n$$\\prod_{i=1}^N\\prod_{j=1}^N\\frac{\\operatorname{lcm}(i,j)}{\\gcd(i,j)}\\pmod{104857601}$$\n\n${\\rm CYJian}$ 已经算出来这个式子的值了。现在请你帮他验算一下吧。${\\rm CYJian}$ 只给你 $0.2\\textrm{s}$ 的时间哦。\n\n2024.5.11 **upd**: 放宽时空限制。", "inputFormat": "一行一个正整数 $N$。", "outputFormat": "一行一个正整数，表示答案模 $104857601$ 的值。", "hint": "样例解释：\n\n|$\\frac{\\operatorname{lcm}}{\\gcd}$|1|2|3|4|5|\n|:--:|:--:|:--:|:--:|:--:|:--:|\n|**1**|1|2|3|4|5|\n|**2**|2|1|6|2|10|\n|**3**|3|6|1|12|15|\n|**4**|4|2|12|1|20|\n|**5**|5|10|15|20|1|\n\n对于 $30\\%$ 的数据：$1 \\leq N \\leq 5000$。\n\n对于 $100\\%$ 的数据：$1 \\leq N \\leq 1000000$。", "locale": "zh-CN", "translations": {"en": {"title": "Product", "background": "${\\rm CYJian}$: “I heard that combining $\\gcd$ and $\\sum$ is pretty fun?? Then I will...”", "description": "${\\rm CYJian}$ has been bored recently and started playing with $\\gcd$. He came up with a very simple and interesting expression:\n\n$$\\prod_{i=1}^N\\prod_{j=1}^N\\frac{\\operatorname{lcm}(i,j)}{\\gcd(i,j)}\\pmod{104857601}$$\n\n${\\rm CYJian}$ has already computed the value of this expression. Now please help him verify it. ${\\rm CYJian}$ only gives you $0.2\\textrm{s}$ of time.\n\n2024.5.11 **upd**: The time and memory limits have been relaxed.", "inputFormat": "One line with a positive integer $N$.", "outputFormat": "One line with a positive integer, the value of the answer modulo $104857601$.", "hint": "Sample explanation:\n\n|$\\frac{\\operatorname{lcm}}{\\gcd}$|1|2|3|4|5|\n|:--:|:--:|:--:|:--:|:--:|:--:|\n|**1**|1|2|3|4|5|\n|**2**|2|1|6|2|10|\n|**3**|3|6|1|12|15|\n|**4**|4|2|12|1|20|\n|**5**|5|10|15|20|1|\n\nFor $30\\%$ of the testdata: $1 \\leq N \\leq 5000$.\n\nFor $100\\%$ of the testdata: $1 \\leq N \\leq 1000000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Product", "background": "${\\rm CYJian}$：“听说 $\\gcd$ 和 $\\sum$ 套起来比较好玩？？那我就……”", "description": "${\\rm CYJian}$ 最近闲的玩起了 $\\gcd$。他想到了一个非常简单而有意思的式子：\n\n$$\\prod_{i=1}^N\\prod_{j=1}^N\\frac{\\operatorname{lcm}(i,j)}{\\gcd(i,j)}\\pmod{104857601}$$\n\n${\\rm CYJian}$ 已经算出来这个式子的值了。现在请你帮他验算一下吧。${\\rm CYJian}$ 只给你 $0.2\\textrm{s}$ 的时间哦。\n\n2024.5.11 **upd**: 放宽时空限制。", "inputFormat": "一行一个正整数 $N$。", "outputFormat": "一行一个正整数，表示答案模 $104857601$ 的值。", "hint": "样例解释：\n\n|$\\frac{\\operatorname{lcm}}{\\gcd}$|1|2|3|4|5|\n|:--:|:--:|:--:|:--:|:--:|:--:|\n|**1**|1|2|3|4|5|\n|**2**|2|1|6|2|10|\n|**3**|3|6|1|12|15|\n|**4**|4|2|12|1|20|\n|**5**|5|10|15|20|1|\n\n对于 $30\\%$ 的数据：$1 \\leq N \\leq 5000$。\n\n对于 $100\\%$ 的数据：$1 \\leq N \\leq 1000000$。", "locale": "zh-CN"}}}
{"pid": "P5222", "type": "P", "difficulty": 6, "samples": [["3 5 2 3\n1 2\n2 4\n0\n1\n2\n", "1\n2\n2\n"], ["5 1000 5 10\n1 2\n2 3\n3 4\n4 5\n5 6\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n", "0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化"], "title": "Game", "background": "Justin摆弄着他的棋盘和棋...突然，他想到了一个非常好玩的游戏。", "description": "棋盘可以看做是一个$N \\times M$的网格，~~由于Justin太健壮了，~~所以他把$T$个格子弄坏了。也就是说，上面没法放棋子。\n\nJustin想到的游戏是这样的：一开始，你可以选择棋盘的第一列的一些没有坏的格子，在上面各放上一枚棋子。然后，你可以执行依次以下操作若干次：\n\n1. 选择一枚棋子，将其向上或者向下移动到**相邻**的一个好的且**没有其他棋子**的格子上。\n\n2. 将所有棋子移动到下一列。若移动到下一列后有**任意一个**棋子落在坏的格子上，则不能执行此操作。\n\nJustin现在给了你$Q$个问题，每一次给你一个$k_i$，询问你最多能在第一列上放多少枚棋子使得经过若干次操作后你能将所有棋子移动到最后一列，且**所有棋子加起来**最多执行$k_i$次1操作。\n\n(感谢巨佬ywwywwyww 发现题目问题，现已修复。)\n\n\n", "inputFormat": "第一行四个正整数:$N$,$M$,$T$,$Q$\n\n接下来$T$行每行两个正整数$x_i$,$y_i$表示一个坏了的格子。\n\n接下来$Q$行每行一个正整数$k_i$表示第$i$次Justin的询问。", "outputFormat": "输出$Q$行，每行一个非负整数表示每一次询问的答案。", "hint": "第一组样例：限制为0时，可以在(3,1)放置一枚棋子，然后一直执行二操作。\n\n限制为1时，可以在(3,1)放置一枚棋子，在(2,1)放置一枚棋子，然后执行两次二操作之后对(2,3)上的棋子执行一次一操作到(1,3)，然后一直执行二操作就好了。\n\n限制为2时，和上面一样。因为如果放置三枚棋子的话是没办法执行操作二的。\n\n第二组样例：发现完全堵死了，所以根本不可能移动到最后一列。\n\n数据范围：\n\n|测试点编号|$N\\le$|$M\\le$|$T\\le$|$Q\\le$|\n|:-------:|:-------:|:-------:|:-------:|:-------:|\n|$1$|$1$|$10^6$|$1$|$10^5$|\n|$2-6$|$10$|$100$|$10$|$100$|\n|$7-10$|$20$|$100$|$50$|$10^3$|\n|$11-14$|$30$|$10^4$|$100$|$10^4$|\n|$15-20$|$50$|$10^6$|$10^3$|$10^5$|\n\n$$1 \\le x_i \\le N \\qquad 1\\le y_i \\le M \\qquad 0 \\le k_i \\le 2^{31}-1$$\n\n此题测试点$11$~$20$的数据随机生成。", "locale": "zh-CN", "translations": {"en": {"title": "Game", "background": "Justin was playing with his board and pieces... Suddenly, he came up with a very interesting game.", "description": "The board can be seen as an $N \\times M$ grid. ~~Because Justin is too strong,~~ he broke $T$ cells, meaning no piece can be placed on those cells.\n\nThe game Justin came up with works like this: At the beginning, you may choose some unbroken cells in the first column and place one piece on each of them. Then, you may perform the following operations in order any number of times:\n\n1. Choose one piece and move it up or down to an **adjacent** cell that is unbroken and **does not contain any other piece**.\n\n2. Move all pieces to the next column. If, after moving to the next column, **any** piece lands on a broken cell, then this operation cannot be performed.\n\nJustin now gives you $Q$ queries. Each time you are given a $k_i$, asking: what is the maximum number of pieces you can place in the first column such that, after some operations, you can move all pieces to the last column, and the total number of operation 1 performed by **all pieces combined** is at most $k_i$.\n\n(Thanks to ywwywwyww for finding an issue in the statement. It has now been fixed.)", "inputFormat": "The first line contains four positive integers: $N$, $M$, $T$, $Q$.\n\nThe next $T$ lines each contain two positive integers $x_i$, $y_i$, indicating a broken cell.\n\nThe next $Q$ lines each contain one positive integer $k_i$, representing Justin's $i$-th query.", "outputFormat": "Output $Q$ lines, each containing a non-negative integer indicating the answer to each query.", "hint": "In the first sample:\n\nWhen the limit is $0$, you can place one piece at $(3,1)$, then keep performing operation 2.\n\nWhen the limit is $1$, you can place one piece at $(3,1)$ and another at $(2,1)$. After performing operation 2 twice, perform operation 1 once on the piece at $(2,3)$ to move it to $(1,3)$, then keep performing operation 2.\n\nWhen the limit is $2$, it is the same as above. Because if you place three pieces, you cannot perform operation 2.\n\nIn the second sample:\n\nYou can see it is completely blocked, so it is impossible to move to the last column.\n\nConstraints:\n\n|Test Point ID|$N\\le$|$M\\le$|$T\\le$|$Q\\le$|\n|:-------:|:-------:|:-------:|:-------:|:-------:|\n|$1$|$1$|$10^6$|$1$|$10^5$|\n|$2-6$|$10$|$100$|$10$|$100$|\n|$7-10$|$20$|$100$|$50$|$10^3$|\n|$11-14$|$30$|$10^4$|$100$|$10^4$|\n|$15-20$|$50$|$10^6$|$10^3$|$10^5$|\n\n$$1 \\le x_i \\le N \\qquad 1\\le y_i \\le M \\qquad 0 \\le k_i \\le 2^{31}-1$$\n\nThe testdata for test points $11$~$20$ is randomly generated.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Game", "background": "Justin摆弄着他的棋盘和棋...突然，他想到了一个非常好玩的游戏。", "description": "棋盘可以看做是一个$N \\times M$的网格，~~由于Justin太健壮了，~~所以他把$T$个格子弄坏了。也就是说，上面没法放棋子。\n\nJustin想到的游戏是这样的：一开始，你可以选择棋盘的第一列的一些没有坏的格子，在上面各放上一枚棋子。然后，你可以执行依次以下操作若干次：\n\n1. 选择一枚棋子，将其向上或者向下移动到**相邻**的一个好的且**没有其他棋子**的格子上。\n\n2. 将所有棋子移动到下一列。若移动到下一列后有**任意一个**棋子落在坏的格子上，则不能执行此操作。\n\nJustin现在给了你$Q$个问题，每一次给你一个$k_i$，询问你最多能在第一列上放多少枚棋子使得经过若干次操作后你能将所有棋子移动到最后一列，且**所有棋子加起来**最多执行$k_i$次1操作。\n\n(感谢巨佬ywwywwyww 发现题目问题，现已修复。)\n\n\n", "inputFormat": "第一行四个正整数:$N$,$M$,$T$,$Q$\n\n接下来$T$行每行两个正整数$x_i$,$y_i$表示一个坏了的格子。\n\n接下来$Q$行每行一个正整数$k_i$表示第$i$次Justin的询问。", "outputFormat": "输出$Q$行，每行一个非负整数表示每一次询问的答案。", "hint": "第一组样例：限制为0时，可以在(3,1)放置一枚棋子，然后一直执行二操作。\n\n限制为1时，可以在(3,1)放置一枚棋子，在(2,1)放置一枚棋子，然后执行两次二操作之后对(2,3)上的棋子执行一次一操作到(1,3)，然后一直执行二操作就好了。\n\n限制为2时，和上面一样。因为如果放置三枚棋子的话是没办法执行操作二的。\n\n第二组样例：发现完全堵死了，所以根本不可能移动到最后一列。\n\n数据范围：\n\n|测试点编号|$N\\le$|$M\\le$|$T\\le$|$Q\\le$|\n|:-------:|:-------:|:-------:|:-------:|:-------:|\n|$1$|$1$|$10^6$|$1$|$10^5$|\n|$2-6$|$10$|$100$|$10$|$100$|\n|$7-10$|$20$|$100$|$50$|$10^3$|\n|$11-14$|$30$|$10^4$|$100$|$10^4$|\n|$15-20$|$50$|$10^6$|$10^3$|$10^5$|\n\n$$1 \\le x_i \\le N \\qquad 1\\le y_i \\le M \\qquad 0 \\le k_i \\le 2^{31}-1$$\n\n此题测试点$11$~$20$的数据随机生成。", "locale": "zh-CN"}}}
{"pid": "P5223", "type": "P", "difficulty": 6, "samples": [["1 1", "1\n"], ["2 2\n", "3\n"], ["3 3\n", "11\n"], ["4 3\n", "23\n"]], "limits": {"time": [600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化"], "title": "Function", "background": "${\\rm CYJian}$最近想起了[水の三角](https://www.luogu.org/problemnew/show/P5014)，他觉得太水了，于是想了一个更加有意思的版本。", "description": "给你$N$和$K$，请你求出：\n\n$$\\sum_{i=1}^{K}f[N][i] \\ (\\bmod\\ 998244353)$$\n\n其中：\n\n$$f[i][j]=f[i-1][j]+f[i][j-1]+f[i-1][j-1](i>1,j \\leq i)$$\n\n$$f[1][1] = 1 \\qquad f[i][0] = 0 \\qquad f[i][j]=0(j>i)$$", "inputFormat": "第一行两个正整数表示$N$，$K$。", "outputFormat": "一行，输出上面式子的值。", "hint": "对于$10\\%$的数据：$1 \\leq N \\leq 10^3 \\qquad 1 \\leq K \\leq 10^2$\n\n对于$30\\%$的数据：$1 \\leq N \\leq 10^6 \\qquad 1 \\leq K \\leq 10^2$\n\n对于$50\\%$的数据：$1 \\leq N \\leq 10^{18} \\qquad 1 \\leq K \\leq 10^2$\n\n对于另$20\\%$的数据：$1 \\leq N \\leq 10^6 \\qquad 1 \\leq K \\leq 10^3$\n\n对于$100\\%$的数据：$1 \\leq N \\leq 10^{18} \\qquad 1 \\leq K \\leq 10^3$\n\n保证$K \\leq N$\n\nUpd：时限改为了：第$1$~$35$的测试点时限为$600ms$，第$36$~$50$的测试点时限为$400ms$。", "locale": "zh-CN", "translations": {"en": {"title": "Function", "background": "${\\rm CYJian}$ recently thought of [Water Triangle](https://www.luogu.org/problemnew/show/P5014) and felt it was too easy, so he came up with a more interesting version.", "description": "Given $N$ and $K$, compute:\n\n$$\\sum_{i=1}^{K} f[N][i] \\ (\\bmod\\ 998244353)$$\n\nwhere:\n\n$$f[i][j] = f[i-1][j] + f[i][j-1] + f[i-1][j-1] \\ (i>1, j \\leq i)$$\n\n$$f[1][1] = 1 \\qquad f[i][0] = 0 \\qquad f[i][j] = 0 \\ (j>i)$$", "inputFormat": "The first line contains two positive integers $N$ and $K$.", "outputFormat": "Output one line containing the value of the expression above.", "hint": "Constraints:\n\nFor $10\\%$ of the testdata: $1 \\leq N \\leq 10^3 \\qquad 1 \\leq K \\leq 10^2$.\n\nFor $30\\%$ of the testdata: $1 \\leq N \\leq 10^6 \\qquad 1 \\leq K \\leq 10^2$.\n\nFor $50\\%$ of the testdata: $1 \\leq N \\leq 10^{18} \\qquad 1 \\leq K \\leq 10^2$.\n\nFor another $20\\%$ of the testdata: $1 \\leq N \\leq 10^6 \\qquad 1 \\leq K \\leq 10^3$.\n\nFor $100\\%$ of the testdata: $1 \\leq N \\leq 10^{18} \\qquad 1 \\leq K \\leq 10^3$.\n\nIt is guaranteed that $K \\leq N$.\n\nUpdate: The time limit has been changed as follows: for test points $1$~$35$, the time limit is $600 \\text{ ms}$; for test points $36$~$50$, the time limit is $400 \\text{ ms}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Function", "background": "${\\rm CYJian}$最近想起了[水の三角](https://www.luogu.org/problemnew/show/P5014)，他觉得太水了，于是想了一个更加有意思的版本。", "description": "给你$N$和$K$，请你求出：\n\n$$\\sum_{i=1}^{K}f[N][i] \\ (\\bmod\\ 998244353)$$\n\n其中：\n\n$$f[i][j]=f[i-1][j]+f[i][j-1]+f[i-1][j-1](i>1,j \\leq i)$$\n\n$$f[1][1] = 1 \\qquad f[i][0] = 0 \\qquad f[i][j]=0(j>i)$$", "inputFormat": "第一行两个正整数表示$N$，$K$。", "outputFormat": "一行，输出上面式子的值。", "hint": "对于$10\\%$的数据：$1 \\leq N \\leq 10^3 \\qquad 1 \\leq K \\leq 10^2$\n\n对于$30\\%$的数据：$1 \\leq N \\leq 10^6 \\qquad 1 \\leq K \\leq 10^2$\n\n对于$50\\%$的数据：$1 \\leq N \\leq 10^{18} \\qquad 1 \\leq K \\leq 10^2$\n\n对于另$20\\%$的数据：$1 \\leq N \\leq 10^6 \\qquad 1 \\leq K \\leq 10^3$\n\n对于$100\\%$的数据：$1 \\leq N \\leq 10^{18} \\qquad 1 \\leq K \\leq 10^3$\n\n保证$K \\leq N$\n\nUpd：时限改为了：第$1$~$35$的测试点时限为$600ms$，第$36$~$50$的测试点时限为$400ms$。", "locale": "zh-CN"}}}
{"pid": "P5224", "type": "P", "difficulty": 6, "samples": [["10 2 3\n", "342\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化"], "title": "Candies", "background": "JerryC 有一大袋糖果，他正以 $1\\ \\textrm{t/ms}$ 的速度食用着这一袋糖果......", "description": "JerryC 的糖果有 $N$ 箱（两两之间不同）。他一开始想挑 $M$ 箱出来，但是觉得吃起来不过瘾，所以又想要多拿一些出来。由于他比较喜欢数字 $K$，所以只要拿出来的糖的量 $x$（$x \\ge M$）满足：$x \\equiv M\\pmod{K}$，JerryC 就会得到满足感。\n\n求有多少种方案使得 JerryC 得到满足感。请输出方案数 $\\bmod\\ 1004535809$ 的结果。", "inputFormat": "一行三个非负整数 $N,M,K$。", "outputFormat": "一行一个非负整数，表示方案数 $\\bmod\\ 1004535809$ 的结果。", "hint": "样例解释：\n\n可以拿出来：$2$ 箱 $5$ 箱 $8$ 箱，组合数算一下就是了：\n\n$$\\binom{10}{2}+\\binom{10}{5}+\\binom{10}{8}=342$$\n\n数据范围：\n\n|测试点编号|$N\\le$|$K\\le$|\n|:-------:|:-------:|:-------:|\n|$1$|$1$|$1$|\n|$2-3$|$10^6$|$10$|\n|$4-8$|$10^{12}$|$100$|\n|$9-12$|$10^{15}$|$10^3$|\n|$12-20$|$10^{18}$|$10^4$|\n\n$0 \\leq M < K$。", "locale": "zh-CN", "translations": {"en": {"title": "Candies", "background": "JerryC has a big bag of candies, and he is eating this bag at a speed of $1\\ \\textrm{t/ms}$.", "description": "JerryC has $N$ boxes of candies (all different from each other). At first, he wanted to pick $M$ boxes, but he felt it was not enough, so he wants to take some more. Since he likes the number $K$, as long as the number of boxes he takes out $x$ ($x \\ge M$) satisfies $x \\equiv M\\pmod{K}$, JerryC will feel satisfied.\n\nFind how many ways can make JerryC feel satisfied. Output the number of ways $\\bmod\\ 1004535809$.", "inputFormat": "One line with three non-negative integers $N, M, K$.", "outputFormat": "One line with one non-negative integer, the number of ways $\\bmod\\ 1004535809$.", "hint": "Sample explanation:\n\nHe can take out $2$ boxes, $5$ boxes, or $8$ boxes. Just compute the combinations:\n\n$$\\binom{10}{2}+\\binom{10}{5}+\\binom{10}{8}=342$$\n\nConstraints:\n\n|Test Point ID|$N\\le$|$K\\le$|\n|:-------:|:-------:|:-------:|\n|$1$|$1$|$1$|\n|$2-3$|$10^6$|$10$|\n|$4-8$|$10^{12}$|$100$|\n|$9-12$|$10^{15}$|$10^3$|\n|$12-20$|$10^{18}$|$10^4$|\n\n$0 \\leq M < K$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Candies", "background": "JerryC 有一大袋糖果，他正以 $1\\ \\textrm{t/ms}$ 的速度食用着这一袋糖果......", "description": "JerryC 的糖果有 $N$ 箱（两两之间不同）。他一开始想挑 $M$ 箱出来，但是觉得吃起来不过瘾，所以又想要多拿一些出来。由于他比较喜欢数字 $K$，所以只要拿出来的糖的量 $x$（$x \\ge M$）满足：$x \\equiv M\\pmod{K}$，JerryC 就会得到满足感。\n\n求有多少种方案使得 JerryC 得到满足感。请输出方案数 $\\bmod\\ 1004535809$ 的结果。", "inputFormat": "一行三个非负整数 $N,M,K$。", "outputFormat": "一行一个非负整数，表示方案数 $\\bmod\\ 1004535809$ 的结果。", "hint": "样例解释：\n\n可以拿出来：$2$ 箱 $5$ 箱 $8$ 箱，组合数算一下就是了：\n\n$$\\binom{10}{2}+\\binom{10}{5}+\\binom{10}{8}=342$$\n\n数据范围：\n\n|测试点编号|$N\\le$|$K\\le$|\n|:-------:|:-------:|:-------:|\n|$1$|$1$|$1$|\n|$2-3$|$10^6$|$10$|\n|$4-8$|$10^{12}$|$100$|\n|$9-12$|$10^{15}$|$10^3$|\n|$12-20$|$10^{18}$|$10^4$|\n\n$0 \\leq M < K$。", "locale": "zh-CN"}}}
{"pid": "P5225", "type": "P", "difficulty": 7, "samples": [["3 3 3 1\n1 2\n2 3\n1 3\n1 2 3\n2 3 1\n3 1 2\n0 2 1\n2 0 3\n1 3 0\n", "1 3 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2018", "提交答案", "Special Judge", "CTSC/CTS"], "title": "[CTSC2018] 组合数问题", "background": "", "description": "众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这题不仅和组合数没什么关系，甚至和小葱也没有关系。\n\n这次我们的主人公是小何同学。众所周知，小何同学非常有钱，他买了 $K$ 台 TPU 来解决 A+B 问题。现在小何同学有 $N$ 个 A+B 问题，第 $i$ 个 A+B 问题在第 $j$ 台 TPU 上计算需要 $t_{i j}$ 的时间。与传统的 A+B 问题不一样的是，这 $N$ 个 A+B 问题之间有 $M$ 个依赖关系，如果问题 $i$ 依赖于问题 $j$，那么问题 $i$ 必须等待问题 $j$ 计算完毕，并将计算的结果传输到问题 $i$ 所在的 TPU 之后，问题 $i$ 才能开始进行计算。如果问题 $i$ 在第 $p$ 台 TPU 上进行计算，问题 $j$ 在第 $q$ 台机器上进行计算，那么问题 $i$ 的结果传输到问题 $j$ 所需要的时间为 $r_{p q}$。数据之间的传输是并行的，即同时有多台机器向一台机器传输数据，或一台机器向多台机器发送数据，都并不会影响到数据传输的速度；但我们规定数据的传输是不能转发的，即如果要从第 $i$ 台机器向第 $j$ 台机器传输某个数据，不能先传输到第 $k$ 台机器再传输到第 $j$ 台机器。\n\n虽然小何同学特别有钱，但是小何同学没有多少的时间毕竟他还要去陪妹子，所以现在小何同学希望你来帮他决定每个 A+B 问题分配到哪台机器上计算，使得所有 TPU 的计算时间总和最小或者所有任务完成的时间最小。所谓 TPU 的计算时间，其定义为 TPU 用来计算问题的时间加上所有数据传输的时间之和。所有任务完成时间定义为从第一个计算开始到最后一个计算结束的时间。\n\n虽然小何同学特别有钱，并且小何同学知道你也没有多少时间来做这个题，所以小何同学为了简化问题，对上述任务作出了如下规定：\n\n1. 问题的依赖关系之间没有环。\n\n2. 任何一个时刻，一台 TPU 只能计算一个问题，且一旦开始这个问题的计算，就不会被打断，会一直计算到这个问题计算完成。\n\n3. 如果一台 TPU 此时没有计算任何一个问题，并且存在一个或多个问题已经准备好数据可以计算，那么 TPU 会选择其中编号最小的问题开始计算。\n\n4. 一台 TPU 同时进行多个数据传输，且彼此之间互相不会影响速度，计算问题的同时也可以进行数据传输，且彼此之间的速度都不会受到影响。\n\n5. 数据不能进行转发，只能直接在相应的机器之间传输。\n\n6. 保证 $r_{ii} = 0$。\n\n7. 如果一个任务不依赖于其他任务，则该任务所需要的数据已经直接在对应机器上准备好了不需要传输。\n\n在上面的这些条件下，小何同学认为这个问题已经足够简单了，于是他愉快地去找妹子玩耍，并把这个问题交给了你。", "inputFormat": "这是一道提交答案题，共有 $10$ 组输入数据，这些数据命名为 `placement1.in` ~ `placement10.in`。\n\n第一行四个整数 $N, M, K, op$。如果 $op = 1$，则代表你要最小化 TPU 的计算时间总和，否则你需要最小化最后一个完成的任务的完成时间。\n\n接下来 $M$ 行每行两个数 $i, j$，代表问题 $j$ 依赖于问题 $i$。\n\n接下来 $N$ 行每行 $K$ 个数，代表 $t_{i j}$。\n\n接下来 $K$ 行每行 $K$ 个数，代表 $r_{i j}$。", "outputFormat": "对于每组输入数据，你需要提交相应的输出文件 `placement1.out` ~ `placement10.out`。\n\n一行 $N$ 个整数，代表每个任务被分配给哪台机器。", "hint": "本题的每个测试点有十个评分标准，如果你的答案小于等于其中 $k$ 个评分标准，那么该测试点你会得到 $k$ 分。\n\n这些标准保存在选手目录的 `placement*.ans` 中。\n\n### 提示\n为了方便你测试自己的答案，小何同学把妹子甩了然后给你写了一个模拟器。你可以在你的目录下找到一个可执行文件 `simulator`。它的用法为在终端中执行 `./simulator <input_file> <output_file>`。其中 `<input_file>` 为输入文件，`<output_file>` 为你的答案。它会告诉你你的分配方案的总计算时间和所有任务的完成时间。\n\n注意：由于陪妹子玩耍降低了小何同学的编程技巧，小何同学不能保证这个模拟器能对不是他提供的输入文件给出正确的结果。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2018] Binomial Coefficient Problem", "background": "", "description": "As everyone knows, student Xiao Cong is good at calculations, especially at computing binomial coefficients. But this problem is not only almost unrelated to binomial coefficients, it is not even related to Xiao Cong.\n\nThis time, our main character is student Xiao He. As everyone knows, Xiao He is very rich. He bought $K$ TPUs to solve A+B problems. Now Xiao He has $N$ A+B problems. The $i$-th A+B problem needs time $t_{i j}$ to be computed on the $j$-th TPU. Different from traditional A+B problems, there are $M$ dependency relations among these $N$ A+B problems. If problem $i$ depends on problem $j$, then problem $i$ must wait until problem $j$ finishes computing, and after the result is transmitted to the TPU where problem $i$ is located, problem $i$ can start computing. If problem $i$ is computed on the $p$-th TPU and problem $j$ is computed on the $q$-th machine, then the time needed to transmit the result is $r_{p q}$. Data transmission is parallel: multiple machines transmitting to one machine at the same time, or one machine sending data to multiple machines at the same time, will not affect the transmission speed. However, we规定 that data transmission cannot be forwarded: if some data needs to be transmitted from machine $i$ to machine $j$, it cannot be sent to machine $k$ first and then to machine $j$.\n\nAlthough Xiao He is very rich, he does not have much time (after all, he still needs to spend time with girls). So now Xiao He wants you to help him decide which machine each A+B problem should be assigned to, so as to minimize either the total computation time of all TPUs, or the time when all tasks are finished. The “TPU computation time” is defined as the time the TPU spends computing problems plus the sum of all data transmission time. The “all tasks finish time” is defined as the time from the start of the first computation to the end of the last computation.\n\nAlthough Xiao He is very rich, and he knows you do not have much time to do this problem either, to simplify the problem, he makes the following rules for the tasks above:\n\n1. The dependency relations form an acyclic graph.\n\n2. At any moment, one TPU can compute only one problem. Once it starts computing a problem, it will not be interrupted and will keep computing until the problem is finished.\n\n3. If a TPU is currently not computing any problem, and there exists one or more problems whose data is ready for computation, then the TPU will choose the problem with the smallest index among them to start computing.\n\n4. A TPU can perform multiple data transmissions at the same time, and they do not affect each other’s speed. It can also transmit data while computing problems, and the speeds will not affect each other.\n\n5. Data cannot be forwarded; it can only be transmitted directly between the corresponding machines.\n\n6. It is guaranteed that $r_{ii} = 0$.\n\n7. If a task does not depend on other tasks, then the data it needs is already prepared directly on the corresponding machine and does not need transmission.\n\nUnder the conditions above, Xiao He thinks this problem is simple enough. So he happily goes to have fun with girls and leaves this problem to you.", "inputFormat": "This is an output-only problem. There are $10$ groups of input data, named `placement1.in` ~ `placement10.in`.\n\nThe first line contains four integers $N, M, K, op$. If $op = 1$, it means you need to minimize the sum of TPU computation time; otherwise, you need to minimize the completion time of the last finished task.\n\nNext $M$ lines each contain two numbers $i, j$, meaning problem $j$ depends on problem $i$.\n\nNext $N$ lines each contain $K$ numbers, representing $t_{i j}$.\n\nNext $K$ lines each contain $K$ numbers, representing $r_{i j}$.", "outputFormat": "For each group of input data, you need to submit the corresponding output file `placement1.out` ~ `placement10.out`.\n\nOne line with $N$ integers, indicating which machine each task is assigned to.", "hint": "Each test point of this problem has ten scoring criteria. If your answer is less than or equal to the $k$-th criterion among them, then you will get $k$ points for that test point.\n\nThese criteria are stored in `placement*.ans` in the contestant directory.\n\n### Hint\n\nTo make it easier for you to test your own answer, Xiao He dumped the girl and then wrote a simulator for you. You can find an executable file `simulator` in your directory. Its usage is to run `./simulator <input_file> <output_file>` in the terminal, where `<input_file>` is the input file and `<output_file>` is your answer. It will tell you the total computation time of your assignment scheme and the completion time of all tasks.\n\nNote: Since spending time with girls reduced Xiao He’s programming skills, Xiao He cannot guarantee that this simulator will produce correct results for input files not provided by him.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2018] 组合数问题", "background": "", "description": "众所周知，小葱同学擅长计算，尤其擅长计算组合数，但这题不仅和组合数没什么关系，甚至和小葱也没有关系。\n\n这次我们的主人公是小何同学。众所周知，小何同学非常有钱，他买了 $K$ 台 TPU 来解决 A+B 问题。现在小何同学有 $N$ 个 A+B 问题，第 $i$ 个 A+B 问题在第 $j$ 台 TPU 上计算需要 $t_{i j}$ 的时间。与传统的 A+B 问题不一样的是，这 $N$ 个 A+B 问题之间有 $M$ 个依赖关系，如果问题 $i$ 依赖于问题 $j$，那么问题 $i$ 必须等待问题 $j$ 计算完毕，并将计算的结果传输到问题 $i$ 所在的 TPU 之后，问题 $i$ 才能开始进行计算。如果问题 $i$ 在第 $p$ 台 TPU 上进行计算，问题 $j$ 在第 $q$ 台机器上进行计算，那么问题 $i$ 的结果传输到问题 $j$ 所需要的时间为 $r_{p q}$。数据之间的传输是并行的，即同时有多台机器向一台机器传输数据，或一台机器向多台机器发送数据，都并不会影响到数据传输的速度；但我们规定数据的传输是不能转发的，即如果要从第 $i$ 台机器向第 $j$ 台机器传输某个数据，不能先传输到第 $k$ 台机器再传输到第 $j$ 台机器。\n\n虽然小何同学特别有钱，但是小何同学没有多少的时间毕竟他还要去陪妹子，所以现在小何同学希望你来帮他决定每个 A+B 问题分配到哪台机器上计算，使得所有 TPU 的计算时间总和最小或者所有任务完成的时间最小。所谓 TPU 的计算时间，其定义为 TPU 用来计算问题的时间加上所有数据传输的时间之和。所有任务完成时间定义为从第一个计算开始到最后一个计算结束的时间。\n\n虽然小何同学特别有钱，并且小何同学知道你也没有多少时间来做这个题，所以小何同学为了简化问题，对上述任务作出了如下规定：\n\n1. 问题的依赖关系之间没有环。\n\n2. 任何一个时刻，一台 TPU 只能计算一个问题，且一旦开始这个问题的计算，就不会被打断，会一直计算到这个问题计算完成。\n\n3. 如果一台 TPU 此时没有计算任何一个问题，并且存在一个或多个问题已经准备好数据可以计算，那么 TPU 会选择其中编号最小的问题开始计算。\n\n4. 一台 TPU 同时进行多个数据传输，且彼此之间互相不会影响速度，计算问题的同时也可以进行数据传输，且彼此之间的速度都不会受到影响。\n\n5. 数据不能进行转发，只能直接在相应的机器之间传输。\n\n6. 保证 $r_{ii} = 0$。\n\n7. 如果一个任务不依赖于其他任务，则该任务所需要的数据已经直接在对应机器上准备好了不需要传输。\n\n在上面的这些条件下，小何同学认为这个问题已经足够简单了，于是他愉快地去找妹子玩耍，并把这个问题交给了你。", "inputFormat": "这是一道提交答案题，共有 $10$ 组输入数据，这些数据命名为 `placement1.in` ~ `placement10.in`。\n\n第一行四个整数 $N, M, K, op$。如果 $op = 1$，则代表你要最小化 TPU 的计算时间总和，否则你需要最小化最后一个完成的任务的完成时间。\n\n接下来 $M$ 行每行两个数 $i, j$，代表问题 $j$ 依赖于问题 $i$。\n\n接下来 $N$ 行每行 $K$ 个数，代表 $t_{i j}$。\n\n接下来 $K$ 行每行 $K$ 个数，代表 $r_{i j}$。", "outputFormat": "对于每组输入数据，你需要提交相应的输出文件 `placement1.out` ~ `placement10.out`。\n\n一行 $N$ 个整数，代表每个任务被分配给哪台机器。", "hint": "本题的每个测试点有十个评分标准，如果你的答案小于等于其中 $k$ 个评分标准，那么该测试点你会得到 $k$ 分。\n\n这些标准保存在选手目录的 `placement*.ans` 中。\n\n### 提示\n为了方便你测试自己的答案，小何同学把妹子甩了然后给你写了一个模拟器。你可以在你的目录下找到一个可执行文件 `simulator`。它的用法为在终端中执行 `./simulator <input_file> <output_file>`。其中 `<input_file>` 为输入文件，`<output_file>` 为你的答案。它会告诉你你的分配方案的总计算时间和所有任务的完成时间。\n\n注意：由于陪妹子玩耍降低了小何同学的编程技巧，小何同学不能保证这个模拟器能对不是他提供的输入文件给出正确的结果。", "locale": "zh-CN"}}}
