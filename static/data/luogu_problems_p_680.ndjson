{"pid": "P14786", "type": "P", "difficulty": 6, "samples": [["3\n1\n5 3\n2\n2 7\n8 4\n2\n10 8\n6 3", "6\n21\n21\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2025", "排序", "ICPC", "NERC/NEERC"], "title": "[NERC 2025] Elevator Against Humanity", "background": "", "description": "Nowadays, all gadgets are smart: smart phones, smart speakers, smart bulbs, and even smart elevators. The machines rise up.\n\nThe headquarters of the human resistance is located in a skyscraper. However, the smart elevator tries to slow people down without revealing itself.\n\nThere are $n$ people in the skyscraper waiting for the elevator on different floors. Each person wants to get to another floor. Each person’s destination floor is different from every other destination floor and from all starting floors. At the beginning, the elevator is located on the first floor. It moves one floor per unit of time. Whenever the doors open, it chooses the next floor and travels directly to it. The elevator can either go to the starting floor of the person who hasn’t boarded the elevator yet and take them, or go to the destination floor of the person who is already in the elevator and disembark them. Note that the elevator doesn’t stop on the intermediate floors even for the people who are already inside the elevator. The passenger boarding and disembarkation take negligible time. The elevator is big enough to accommodate all people at the same time.\n\nThe goal of the elevator is to maximize the total time until all passengers have been delivered to their destination floors. Find the maximum total time starting from the first floor until the disembarkation of the last passenger. Elevator doesn’t need to return to the first floor.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10\\,000$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ denoting the number of people ($1 \\le n \\le 10^5$).\n\nEach of the following $n$ lines contains two integers $s_i$ and $f_i$ ($2 \\le s_i, f_i \\le 10^9$) denoting the starting and the destination floor of the person $i$, respectively. All $2n$ floors in the input are pairwise distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n", "outputFormat": "For each test case, print the maximum time needed to transport all people.", "hint": "In the first test case, there is only one person. The sequence of visited floors is $1 \\rightarrow 5 \\rightarrow 3$, and the time is $6$.\n\nIn the second test case, one of the correct sequences is $1 \\rightarrow 8 \\rightarrow 2 \\rightarrow 7 \\rightarrow 4$ with the time $21$.\n\nIn the third test case, one of the correct sequences is $1 \\rightarrow 10 \\rightarrow 6 \\rightarrow 3 \\rightarrow 8$ with the time $21$.\n", "locale": "en", "translations": {"en": {"title": "[NERC 2025] Elevator Against Humanity", "background": "", "description": "Nowadays, all gadgets are smart: smart phones, smart speakers, smart bulbs, and even smart elevators. The machines rise up.\n\nThe headquarters of the human resistance is located in a skyscraper. However, the smart elevator tries to slow people down without revealing itself.\n\nThere are $n$ people in the skyscraper waiting for the elevator on different floors. Each person wants to get to another floor. Each person’s destination floor is different from every other destination floor and from all starting floors. At the beginning, the elevator is located on the first floor. It moves one floor per unit of time. Whenever the doors open, it chooses the next floor and travels directly to it. The elevator can either go to the starting floor of the person who hasn’t boarded the elevator yet and take them, or go to the destination floor of the person who is already in the elevator and disembark them. Note that the elevator doesn’t stop on the intermediate floors even for the people who are already inside the elevator. The passenger boarding and disembarkation take negligible time. The elevator is big enough to accommodate all people at the same time.\n\nThe goal of the elevator is to maximize the total time until all passengers have been delivered to their destination floors. Find the maximum total time starting from the first floor until the disembarkation of the last passenger. Elevator doesn’t need to return to the first floor.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10\\,000$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$ denoting the number of people ($1 \\le n \\le 10^5$).\n\nEach of the following $n$ lines contains two integers $s_i$ and $f_i$ ($2 \\le s_i, f_i \\le 10^9$) denoting the starting and the destination floor of the person $i$, respectively. All $2n$ floors in the input are pairwise distinct.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $10^5$.\n", "outputFormat": "For each test case, print the maximum time needed to transport all people.", "hint": "In the first test case, there is only one person. The sequence of visited floors is $1 \\rightarrow 5 \\rightarrow 3$, and the time is $6$.\n\nIn the second test case, one of the correct sequences is $1 \\rightarrow 8 \\rightarrow 2 \\rightarrow 7 \\rightarrow 4$ with the time $21$.\n\nIn the third test case, one of the correct sequences is $1 \\rightarrow 10 \\rightarrow 6 \\rightarrow 3 \\rightarrow 8$ with the time $21$.\n", "locale": "en"}, "zh-CN": {"title": "[NERC 2025] Elevator Against Humanity", "background": "", "description": "如今，所有设备都变得智能：智能手机、智能音箱、智能灯泡，甚至是智能电梯。机器正在崛起。\n\n人类抵抗组织的总部设在一座摩天大楼里。然而，智能电梯试图在不暴露自身的情况下拖慢人们的行动。\n\n摩天大楼里有 $n$ 个人在不同的楼层等电梯。每个人都想去另一个楼层。每个人的目标楼层都与其他人的目标楼层以及所有起始楼层不同。开始时，电梯位于第一层。它每单位时间移动一层。每当门打开时，它选择下一个楼层并直接前往该楼层。电梯可以选择前往尚未上电梯的人的起始楼层接他们，或者前往已在电梯内的人的目标楼层让他们下电梯。注意，电梯不会在中间楼层停靠，即使对于已经在电梯内的人也是如此。乘客上下电梯的时间可以忽略不计。电梯足够大，可以同时容纳所有人。\n\n电梯的目标是最大化所有乘客被送达目标楼层为止的总时间。找出从第一层开始到最后一名乘客下电梯为止的最大总时间。电梯不需要返回第一层。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例的数量 $t$ ($1 \\le t \\le 10\\,000$)。接下来是测试用例的描述。\n\n每个测试用例的第一行包含一个整数 $n$，表示人数 ($1 \\le n \\le 10^5$)。\n\n接下来的 $n$ 行，每行包含两个整数 $s_i$ 和 $f_i$ ($2 \\le s_i, f_i \\le 10^9$)，分别表示第 $i$ 个人的起始楼层和目标楼层。输入中的所有 $2n$ 个楼层都是两两不同的。\n\n保证所有测试用例的 $n$ 之和不超过 $10^5$。", "outputFormat": "对于每个测试用例，输出运送所有人所需的最大时间。", "hint": "在第一个测试用例中，只有一个人。访问楼层的顺序是 $1 \\rightarrow 5 \\rightarrow 3$，时间为 $6$。\n\n在第二个测试用例中，一个正确的顺序是 $1 \\rightarrow 8 \\rightarrow 2 \\rightarrow 7 \\rightarrow 4$，时间为 $21$。\n\n在第三个测试用例中，一个正确的顺序是 $1 \\rightarrow 10 \\rightarrow 6 \\rightarrow 3 \\rightarrow 8$，时间为 $21$。", "locale": "zh-CN"}}}
{"pid": "P14787", "type": "P", "difficulty": 4, "samples": [["3\n3\n1 2 3\n1\n1\n5\n10 3 4 7 4", "Bob\nAlice\nAlice"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["博弈论", "2025", "ICPC", "NERC/NEERC"], "title": "[NERC 2025] Fragmented Nim", "background": "", "description": "The classical game of Nim goes as follows. There are $n$ piles of stones, and pile $i$ initially consists of $a_i$ stones. Alice and Bob take turns; Alice goes first. On their turn, a player chooses any non-empty pile and removes any positive number of stones from it. The player who takes the last stone wins.\n\nAfter playing a lot of Nim, Alice and Bob decided to vary the rules a little bit. In this variation, the player whose turn it is does not choose a pile — *their opponent* does it for them! However, the player still gets to decide the number of stones to remove from that pile.\n\nAlice still moves first. On Alice’s turn Bob chooses any non-empty pile, and then Alice removes any positive number of stones from it. Similarly, on Bob’s turn Alice chooses any non-empty pile, and then Bob removes any positive number of stones from it.\n\nFor the given configuration of stones in the piles, determine who will win if both players follow the optimal strategy.\n", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$, denoting the number of piles ($1 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$, denoting the number of stones in the piles ($1 \\le a_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print the name of the winner of the game if both players follow the optimal strategy: “Alice” or “Bob”.", "hint": "In the first test case, here’s one possible way the game could proceed:\n\n- Bob chooses the first pile. Alice removes 1 stone from it.\n- Alice chooses the third pile. Bob removes 2 stones from it.\n- Bob chooses the third pile. Alice removes 1 stone from it.\n- Alice chooses the second pile. Bob removes 2 stones from it and wins.\n\nIn the second test case, Bob chooses the only pile, and Alice wins by removing the only stone from it.\n", "locale": "en", "translations": {"en": {"title": "[NERC 2025] Fragmented Nim", "background": "", "description": "The classical game of Nim goes as follows. There are $n$ piles of stones, and pile $i$ initially consists of $a_i$ stones. Alice and Bob take turns; Alice goes first. On their turn, a player chooses any non-empty pile and removes any positive number of stones from it. The player who takes the last stone wins.\n\nAfter playing a lot of Nim, Alice and Bob decided to vary the rules a little bit. In this variation, the player whose turn it is does not choose a pile — *their opponent* does it for them! However, the player still gets to decide the number of stones to remove from that pile.\n\nAlice still moves first. On Alice’s turn Bob chooses any non-empty pile, and then Alice removes any positive number of stones from it. Similarly, on Bob’s turn Alice chooses any non-empty pile, and then Bob removes any positive number of stones from it.\n\nFor the given configuration of stones in the piles, determine who will win if both players follow the optimal strategy.\n", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$, denoting the number of piles ($1 \\le n \\le 2 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$, denoting the number of stones in the piles ($1 \\le a_i \\le 10^9$).\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each test case, print the name of the winner of the game if both players follow the optimal strategy: “Alice” or “Bob”.", "hint": "In the first test case, here’s one possible way the game could proceed:\n\n- Bob chooses the first pile. Alice removes 1 stone from it.\n- Alice chooses the third pile. Bob removes 2 stones from it.\n- Bob chooses the third pile. Alice removes 1 stone from it.\n- Alice chooses the second pile. Bob removes 2 stones from it and wins.\n\nIn the second test case, Bob chooses the only pile, and Alice wins by removing the only stone from it.\n", "locale": "en"}, "zh-CN": {"title": "[NERC 2025] Fragmented Nim", "background": "", "description": "经典的 Nim 游戏规则如下。有 $n$ 堆石子，第 $i$ 堆初始有 $a_i$ 颗石子。Alice 和 Bob 轮流行动；Alice 先手。轮到一名玩家时，他可以选择任意一个非空石子堆，并从中移除任意正数颗石子。拿走最后一颗石子的玩家获胜。\n\n在玩了大量 Nim 游戏后，Alice 和 Bob 决定稍微改变一下规则。在这个变体中，轮到行动的玩家并不选择石子堆——**他的对手** 会替他选择！不过，该玩家仍然可以决定从该堆中移除多少颗石子。\n\n仍然是 Alice 先手。在 Alice 的回合，Bob 选择任意一个非空石子堆，然后 Alice 从中移除任意正数颗石子。类似地，在 Bob 的回合，Alice 选择任意一个非空石子堆，然后 Bob 从中移除任意正数颗石子。\n\n对于给定的各堆石子配置，如果双方都遵循最优策略，请确定谁将获胜。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例的数量 $t$ ($1 \\le t \\le 10^4$)。接下来是测试用例的描述。\n\n每个测试用例的第一行包含一个整数 $n$，表示石子堆的数量 ($1 \\le n \\le 2 \\cdot 10^5$)。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n$，表示各堆石子的数量 ($1 \\le a_i \\le 10^9$)。\n\n保证所有测试用例的 $n$ 之和不超过 $2 \\cdot 10^5$。", "outputFormat": "对于每个测试用例，如果双方都遵循最优策略，请输出游戏获胜者的名字：“Alice” 或 “Bob”。\n", "hint": "在第一个测试用例中，游戏可能的一种进行方式如下：\n\n- Bob 选择第一堆。Alice 从中移除 $1$ 颗石子。\n- Alice 选择第三堆。Bob 从中移除 $2$ 颗石子。\n- Bob 选择第三堆。Alice 从中移除 $1$ 颗石子。\n- Alice 选择第二堆。Bob 从中移除 $2$ 颗石子并获胜。\n\n在第二个测试用例中，Bob 选择唯一的一堆，Alice 通过移除其中唯一的一颗石子获胜。", "locale": "zh-CN"}}}
{"pid": "P14788", "type": "P", "difficulty": 5, "samples": [["5\n2\n3 3\n3\n2 2 2\n4\n1 2 4 3\n5\n0 2 3 5 4\n6\n5 8 3 10 14 4", "3\n2\n2\n4\n10"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "数学", "二分", "2025", "ICPC", "NERC/NEERC"], "title": "[NERC 2025] Greta' s Game", "background": "", "description": "Greta and Alice are the two permanent hosts of the hit comedy show “QuestExpert”. For this season they invited $n$ programmers to complete quests, set by Alice. After that they all meet in a studio to review how well they did and complete the final studio quest.\n\nToday, the studio quest that Alice came up with is as follows: first, all $n$ participants stand in a circle in order from 1 to $n$ counter-clockwise. Then Alice holds some number of rounds. In each round, every participant writes down an integer on a piece of paper. After that, Alice checks the numbers and for each $i$ from 1 to $n$, if the $i$-th participant’s number is strictly larger than the number of the next participant in counter-clockwise order (participant number $(i \\bmod n) + 1$), then the $i$-th and the $(i \\bmod n) + 1$-st participants both receive one point. After all rounds are complete, Alice calculates the total number of points for each participant and reports them to Greta. It turned out that the $i$-th participant scored $a_i$ points.\n\nGreta thinks that math games are boring, and this one took too long. To prove her wrong, Alice decides to cheat a little and instead of telling Greta the real number of rounds, she will tell her the minimum possible number of rounds that could still result in the $i$-th participant scoring $a_i$ points for each $i$.\n\nHelp Alice determine this number.\n", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$, denoting the number of participants ($2 \\le n \\le 5 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$, denoting the final scores of the participants ($0 \\le a_i \\le 10^9$). It is guaranteed that those scores were achieved in the described game with at least one round.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.", "outputFormat": "For each test case, output on a separate line the minimum number of rounds that could lead to the given scores.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2025] Greta' s Game", "background": "", "description": "Greta and Alice are the two permanent hosts of the hit comedy show “QuestExpert”. For this season they invited $n$ programmers to complete quests, set by Alice. After that they all meet in a studio to review how well they did and complete the final studio quest.\n\nToday, the studio quest that Alice came up with is as follows: first, all $n$ participants stand in a circle in order from 1 to $n$ counter-clockwise. Then Alice holds some number of rounds. In each round, every participant writes down an integer on a piece of paper. After that, Alice checks the numbers and for each $i$ from 1 to $n$, if the $i$-th participant’s number is strictly larger than the number of the next participant in counter-clockwise order (participant number $(i \\bmod n) + 1$), then the $i$-th and the $(i \\bmod n) + 1$-st participants both receive one point. After all rounds are complete, Alice calculates the total number of points for each participant and reports them to Greta. It turned out that the $i$-th participant scored $a_i$ points.\n\nGreta thinks that math games are boring, and this one took too long. To prove her wrong, Alice decides to cheat a little and instead of telling Greta the real number of rounds, she will tell her the minimum possible number of rounds that could still result in the $i$-th participant scoring $a_i$ points for each $i$.\n\nHelp Alice determine this number.\n", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains a single integer $n$, denoting the number of participants ($2 \\le n \\le 5 \\cdot 10^5$).\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$, denoting the final scores of the participants ($0 \\le a_i \\le 10^9$). It is guaranteed that those scores were achieved in the described game with at least one round.\n\nIt is guaranteed that the sum of $n$ over all test cases does not exceed $5 \\cdot 10^5$.", "outputFormat": "For each test case, output on a separate line the minimum number of rounds that could lead to the given scores.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2025] Greta' s Game", "background": "", "description": "Greta 和 Alice 是热门喜剧节目“QuestExpert”的两位常驻主持人。在本季中，他们邀请了 $n$ 位程序员来完成由 Alice 设置的挑战。之后，他们齐聚演播室，回顾各自的表现并完成最终的演播室挑战。\n\n今天，Alice 设计的演播室挑战如下：首先，所有 $n$ 位参与者按 $1$ 到 $n$ 的顺序逆时针站成一个圆圈。然后，Alice 主持若干轮。在每一轮中，每位参与者在一张纸上写下一个整数。之后，Alice 检查这些数字，对于每个从 $1$ 到 $n$ 的 $i$，如果第 $i$ 位参与者的数字严格大于下一位逆时针方向参与者（编号为 $(i \\bmod n) + 1$ 的参与者）的数字，那么第 $i$ 位和第 $(i \\bmod n) + 1$ 位参与者各自获得 $1$ 分。所有轮次结束后，Alice 计算每位参与者的总得分并报告给 Greta。结果显示，第 $i$ 位参与者获得了 $a_i$ 分。\n\nGreta 认为数学游戏很无聊，而且这个游戏耗时太长。为了证明她错了，Alice 决定稍微作弊一下：她不告诉 Greta 真实的轮数，而是告诉她仍然能够使每位参与者 $i$ 获得 $a_i$ 分的最小可能轮数。\n\n请帮助 Alice 确定这个数字。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例的数量 $t$ ($1 \\le t \\le 10^4$)。接下来是测试用例的描述。\n\n每个测试用例的第一行包含一个整数 $n$，表示参与者的数量 ($2 \\le n \\le 5 \\cdot 10^5$)。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n$，表示参与者的最终得分 ($0 \\le a_i \\le 10^9$)。保证这些得分是在所述游戏中，经过至少一轮后达成的。\n\n保证所有测试用例的 $n$ 之和不超过 $5 \\cdot 10^5$。", "outputFormat": "对于每个测试用例，在单独的一行中输出能够导致给定得分的最小轮数。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14789", "type": "P", "difficulty": 2, "samples": [["10 20 6\n40", "4 3 1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2025", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2025] Honey Cake", "background": "", "description": "Hannah and Henry are going to host a party for $n$ people, including themselves.\n\nThey bought a honey cake of size $w \\times h \\times d$ inches for the party, and want to split it into $n$ equal pieces. The honey cake can be cut parallel to any of its faces. To make cuts precise, each edge of length $w$ is cut into the same number of equal parts, each having integer length; similarly for edges of lengths $h$ and $d$. Given the dimensions of the honey cake, determine whether it is possible to cut it into $n$ equal pieces, and if so, how.", "inputFormat": "The first line of input contains three integers: $w$, $h$, and $d$, the dimensions of the honey cake in inches ($1 \\le w, h, d \\le 10^9$).\n\nThe second line contains a single integer $n$ ($1 \\le n \\le 10^9$).", "outputFormat": "Output three integers $w_c$, $h_c$, $d_c$, the number of cuts to be made along each of the dimensions $w$, $h$, and $d$, respectively, if it is possible to cut the cake, or a single integer $-1$ otherwise. Note that making zero cuts along a dimension is allowed, too.", "hint": "In the first example, the cake will be cut into $5 \\cdot 4 \\cdot 2 = 40$ pieces of size $2 \\times 5 \\times 3$ inches.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/0ebsnvq2.png)\n:::", "locale": "en", "translations": {"en": {"title": "[NERC 2025] Honey Cake", "background": "", "description": "Hannah and Henry are going to host a party for $n$ people, including themselves.\n\nThey bought a honey cake of size $w \\times h \\times d$ inches for the party, and want to split it into $n$ equal pieces. The honey cake can be cut parallel to any of its faces. To make cuts precise, each edge of length $w$ is cut into the same number of equal parts, each having integer length; similarly for edges of lengths $h$ and $d$. Given the dimensions of the honey cake, determine whether it is possible to cut it into $n$ equal pieces, and if so, how.", "inputFormat": "The first line of input contains three integers: $w$, $h$, and $d$, the dimensions of the honey cake in inches ($1 \\le w, h, d \\le 10^9$).\n\nThe second line contains a single integer $n$ ($1 \\le n \\le 10^9$).", "outputFormat": "Output three integers $w_c$, $h_c$, $d_c$, the number of cuts to be made along each of the dimensions $w$, $h$, and $d$, respectively, if it is possible to cut the cake, or a single integer $-1$ otherwise. Note that making zero cuts along a dimension is allowed, too.", "hint": "In the first example, the cake will be cut into $5 \\cdot 4 \\cdot 2 = 40$ pieces of size $2 \\times 5 \\times 3$ inches.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/0ebsnvq2.png)\n:::", "locale": "en"}, "zh-CN": {"title": "[NERC 2025] Honey Cake", "background": "", "description": "Hannah 和 Henry 准备为 $n$ 个人（包括他们自己）举办一场派对。\n\n他们为派对买了一块尺寸为 $w \\times h \\times d$ 英寸的蜂蜜蛋糕，并想将它切成 $n$ 块相等的部分。蜂蜜蛋糕可以沿着平行于其任一表面的方向切割。为了使切割精确，长度为 $w$ 的每条边被分成相同数量的等份，每份具有整数长度；同样地，长度为 $h$ 和 $d$ 的边也如此。给定蜂蜜蛋糕的尺寸，判断是否可能将其切成 $n$ 块相等的部分，如果可以，请给出切割方案。", "inputFormat": "输入的第一行包含三个整数：$w$、$h$ 和 $d$，表示蜂蜜蛋糕的尺寸（单位：英寸）（$1 \\le w, h, d \\le 10^9$）。\n\n第二行包含一个整数 $n$ ($1 \\le n \\le 10^9$)。", "outputFormat": "如果可以切割蛋糕，则输出三个整数 $w_c$、$h_c$、$d_c$，分别表示沿着 $w$、$h$、$d$ 三个维度需要进行的切割次数；否则输出一个整数 $-1$。注意，允许在某个维度上进行零次切割。", "hint": "在第一个例子中，蛋糕将被切成 $5 \\cdot 4 \\cdot 2 = 40$ 块，每块尺寸为 $2 \\times 5 \\times 3$ 英寸。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/0ebsnvq2.png)\n:::", "locale": "zh-CN"}}}
{"pid": "P14790", "type": "P", "difficulty": 7, "samples": [["3\n4\n0 0\n4 0\n3 3\n1 3\n5\n-1 1\n5 1\n2 -1\n2 4\n6 3\n4\n0 0\n1 0\n0 1\n1 1\n4\n5 5\n6 5\n5 6\n6 6\n3\n0 0\n4 0\n0 2\n3\n4 -2\n4 2\n6 1", "1 4 1 2\n-1\n1 2 1 2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2025] Irrigation Interlock", "background": "", "description": "Two irrigation cooperatives share the same fertile valley. The first cooperative maintains pumps scattered across the fields; the second supervises reservoirs on the surrounding hills. Whenever both cooperatives decide to lay a pair of new pipes, the pipes must intersect — at such an intersection they can install a joint valve. Pipes always follow a straight line segment between a pair of distinct pumps or a pair of distinct reservoirs. Two pipes intersect if they share at least one common point (touching and overlapping pipes are considered intersecting).\n\nYou are given the exact coordinates of every pump and every reservoir on a Cartesian plane. For each planning scenario, determine whether the first cooperative can pick two distinct pumps and the second cooperative can pick two distinct reservoirs so that the two straight pipes intersect. If this is possible, report the indices of those pumps and reservoirs; otherwise declare that the project cannot be realized.", "inputFormat": "The first line contains an integer $t$ ($1 \\le t \\le 10^5$) — the number of planning scenarios.\n\nFor each planning scenario:\n\n- The first line contains an integer $n$ ($2 \\le n \\le 10^5$) — the number of pumps managed by the first cooperative.\n- Each of the next $n$ lines contains two integers $x_i$ and $y_i$ ($|x_i|, |y_i| \\le 10^9$) — the Cartesian coordinates of pump $i$. The pump locations are distinct.\n- The next line contains an integer $m$ ($2 \\le m \\le 10^5$) — the number of reservoirs managed by the second cooperative.\n- Each of the next $m$ lines contains two integers $u_j$ and $v_j$ ($|u_j|, |v_j| \\le 10^9$) — the Cartesian coordinates of reservoir $j$. The reservoir locations are distinct.\n\nNo pump shares its location with any reservoir.\n\nIt is guaranteed that the sum of $n$ over all planning scenarios does not exceed $2 \\cdot 10^5$ and the sum of $m$ over all planning scenarios does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each planning scenario:\n\n- If the first cooperative can choose two pumps and the second cooperative can choose two reservoirs so that the straight pipes connecting each pair intersect, output four integers $p_1, p_2, r_1, r_2$ — the indices of two chosen pumps ($1 \\le p_1, p_2 \\le n; p_1 \\ne p_2$) and two chosen reservoirs ($1 \\le r_1, r_2 \\le m; r_1 \\ne r_2$).\n- If such an intersection is impossible, output $-1$.\n- In case several valid solutions exist, any one of them is acceptable.\n", "hint": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mwa31svh.png)\n:::\n\n", "locale": "en", "translations": {"en": {"title": "[NERC 2025] Irrigation Interlock", "background": "", "description": "Two irrigation cooperatives share the same fertile valley. The first cooperative maintains pumps scattered across the fields; the second supervises reservoirs on the surrounding hills. Whenever both cooperatives decide to lay a pair of new pipes, the pipes must intersect — at such an intersection they can install a joint valve. Pipes always follow a straight line segment between a pair of distinct pumps or a pair of distinct reservoirs. Two pipes intersect if they share at least one common point (touching and overlapping pipes are considered intersecting).\n\nYou are given the exact coordinates of every pump and every reservoir on a Cartesian plane. For each planning scenario, determine whether the first cooperative can pick two distinct pumps and the second cooperative can pick two distinct reservoirs so that the two straight pipes intersect. If this is possible, report the indices of those pumps and reservoirs; otherwise declare that the project cannot be realized.", "inputFormat": "The first line contains an integer $t$ ($1 \\le t \\le 10^5$) — the number of planning scenarios.\n\nFor each planning scenario:\n\n- The first line contains an integer $n$ ($2 \\le n \\le 10^5$) — the number of pumps managed by the first cooperative.\n- Each of the next $n$ lines contains two integers $x_i$ and $y_i$ ($|x_i|, |y_i| \\le 10^9$) — the Cartesian coordinates of pump $i$. The pump locations are distinct.\n- The next line contains an integer $m$ ($2 \\le m \\le 10^5$) — the number of reservoirs managed by the second cooperative.\n- Each of the next $m$ lines contains two integers $u_j$ and $v_j$ ($|u_j|, |v_j| \\le 10^9$) — the Cartesian coordinates of reservoir $j$. The reservoir locations are distinct.\n\nNo pump shares its location with any reservoir.\n\nIt is guaranteed that the sum of $n$ over all planning scenarios does not exceed $2 \\cdot 10^5$ and the sum of $m$ over all planning scenarios does not exceed $2 \\cdot 10^5$.", "outputFormat": "For each planning scenario:\n\n- If the first cooperative can choose two pumps and the second cooperative can choose two reservoirs so that the straight pipes connecting each pair intersect, output four integers $p_1, p_2, r_1, r_2$ — the indices of two chosen pumps ($1 \\le p_1, p_2 \\le n; p_1 \\ne p_2$) and two chosen reservoirs ($1 \\le r_1, r_2 \\le m; r_1 \\ne r_2$).\n- If such an intersection is impossible, output $-1$.\n- In case several valid solutions exist, any one of them is acceptable.\n", "hint": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mwa31svh.png)\n:::\n\n", "locale": "en"}, "zh-CN": {"title": "[NERC 2025] Irrigation Interlock", "background": "", "description": "两个灌溉合作社共享同一片肥沃的谷地。第一个合作社维护着分布在田野中的泵站；第二个合作社监管着周围山上的水库。每当两个合作社决定铺设一对新管道时，这些管道必须相交——在相交处他们可以安装一个联合阀门。管道始终沿着连接一对不同泵站或一对不同水库的直线段铺设。如果两条管道至少共享一个公共点（接触和重叠的管道被视为相交），则认为它们相交。\n\n你将在笛卡尔平面上获得每个泵站和每个水库的精确坐标。针对每个规划场景，判断第一个合作社是否能选择两个不同的泵站，第二个合作社是否能选择两个不同的水库，使得连接这两对点的直线管道相交。如果可能，报告这些泵站和水库的索引；否则声明该项目无法实现。\n", "inputFormat": "第一行包含一个整数 $t$ ($1 \\le t \\le 10^5$) —— 规划场景的数量。\n\n对于每个规划场景：\n\n- 第一行包含一个整数 $n$ ($2 \\le n \\le 10^5$) —— 第一个合作社管理的泵站数量。\n- 接下来的 $n$ 行，每行包含两个整数 $x_i$ 和 $y_i$ ($|x_i|, |y_i| \\le 10^9$) —— 泵站 $i$ 的笛卡尔坐标。泵站的位置互不相同。\n- 接下来一行包含一个整数 $m$ ($2 \\le m \\le 10^5$) —— 第二个合作社管理的水库数量。\n- 接下来的 $m$ 行，每行包含两个整数 $u_j$ 和 $v_j$ ($|u_j|, |v_j| \\le 10^9$) —— 水库 $j$ 的笛卡尔坐标。水库的位置互不相同。\n\n没有任何泵站与任何水库位置相同。\n\n保证所有规划场景的 $n$ 之和不超过 $2 \\cdot 10^5$，所有规划场景的 $m$ 之和也不超过 $2 \\cdot 10^5$。", "outputFormat": "对于每个规划场景：\n\n- 如果第一个合作社可以选择两个泵站，第二个合作社可以选择两个水库，使得连接每对点的直线管道相交，则输出四个整数 $p_1, p_2, r_1, r_2$ —— 两个所选泵站的索引 ($1 \\le p_1, p_2 \\le n; p_1 \\ne p_2$) 和两个所选水库的索引 ($1 \\le r_1, r_2 \\le m; r_1 \\ne r_2$)。\n- 如果这样的相交不可能，则输出 $-1$。\n- 如果存在多个有效解决方案，输出其中任意一个即可接受。", "hint": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mwa31svh.png)\n:::", "locale": "zh-CN"}}}
{"pid": "P14791", "type": "P", "difficulty": 5, "samples": [["2 2\n70 30", "160"], ["2 30\n30 70", "12099716.1778528057038784"], ["2 5\n40 50", "0"], ["6 6\n10 20 60 30 40 50", "29.40799999999990177457221"], ["1 5\n61", "1702.708163199999489734182"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "数学", "2025", "Special Judge", "组合数学", "概率论", "ICPC", "NERC/NEERC"], "title": "[NERC 2025] Jinx or Jackpot", "background": "", "description": "Jack is in his favourite casino and has 1000 dollars. The casino has literally nothing but a single slot machine. Jack knows the history of this casino. Once upon a time, the future owner of the casino was walking and suddenly saw an array of $n$ integer choices $p_1, \\dots, p_n$ each from 0 to 100. He picked an index $i$ ($1 \\le i \\le n$) uniformly at random and thought that it was a good idea to create a casino in which there is only one slot machine with jackpot probability of $\\frac{p_i}{100}$. And he created it.\n\nJack knows the array of choices $p_1, \\dots, p_n$ that suddenly appeared to the owner during the walk, but he does not know which $i$ the owner picked. However, the chosen index $i$ is fixed forever; the slot machine always uses the same $p_i$ as explained below.\n\nOn the slot machine, Jack can bet $x$ dollars, where $x$ is a **non-negative** integer, and pull the lever. Then:\n\n1. With probability $\\frac{p_i}{100}$ it will be a jackpot, and the slot machine returns $2x$ dollars to him, so he gains $x$ dollars.\n\n2. With probability $1 - \\frac{p_i}{100}$ it will be a jinx, and the slot machine returns nothing to him, so he loses $x$ dollars.\n\nEven if Jack bets 0 dollars, he will understand whether it was a jinx or a jackpot.\n\nAlso, the slot machine is not very durable, so Jack can play at most $k$ rounds on it.\n\nFind the maximum expected **profit** Jack can achieve by an optimal strategy. Here a profit is defined as the final amount of money Jack has minus his initial 1000 dollars.\n\nOf course, Jack can’t make a bet that is more than his current balance.\n", "inputFormat": "The first line contains two integers $n$ and $k$ ($1 \\le n \\le 100\\,000; 1 \\le k \\le 30$) — the number of choices and the limit on the number of rounds. The second line contains $n$ integers $p_1, \\dots, p_n$ ($0 \\le p_i \\le 100$) — the choices.\n", "outputFormat": "Output a single real number — the expected profit Jack can achieve by an optimal strategy. Your answer will be considered correct if its absolute or relative error is at most $10^{-4}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2025] Jinx or Jackpot", "background": "", "description": "Jack is in his favourite casino and has 1000 dollars. The casino has literally nothing but a single slot machine. Jack knows the history of this casino. Once upon a time, the future owner of the casino was walking and suddenly saw an array of $n$ integer choices $p_1, \\dots, p_n$ each from 0 to 100. He picked an index $i$ ($1 \\le i \\le n$) uniformly at random and thought that it was a good idea to create a casino in which there is only one slot machine with jackpot probability of $\\frac{p_i}{100}$. And he created it.\n\nJack knows the array of choices $p_1, \\dots, p_n$ that suddenly appeared to the owner during the walk, but he does not know which $i$ the owner picked. However, the chosen index $i$ is fixed forever; the slot machine always uses the same $p_i$ as explained below.\n\nOn the slot machine, Jack can bet $x$ dollars, where $x$ is a **non-negative** integer, and pull the lever. Then:\n\n1. With probability $\\frac{p_i}{100}$ it will be a jackpot, and the slot machine returns $2x$ dollars to him, so he gains $x$ dollars.\n\n2. With probability $1 - \\frac{p_i}{100}$ it will be a jinx, and the slot machine returns nothing to him, so he loses $x$ dollars.\n\nEven if Jack bets 0 dollars, he will understand whether it was a jinx or a jackpot.\n\nAlso, the slot machine is not very durable, so Jack can play at most $k$ rounds on it.\n\nFind the maximum expected **profit** Jack can achieve by an optimal strategy. Here a profit is defined as the final amount of money Jack has minus his initial 1000 dollars.\n\nOf course, Jack can’t make a bet that is more than his current balance.\n", "inputFormat": "The first line contains two integers $n$ and $k$ ($1 \\le n \\le 100\\,000; 1 \\le k \\le 30$) — the number of choices and the limit on the number of rounds. The second line contains $n$ integers $p_1, \\dots, p_n$ ($0 \\le p_i \\le 100$) — the choices.\n", "outputFormat": "Output a single real number — the expected profit Jack can achieve by an optimal strategy. Your answer will be considered correct if its absolute or relative error is at most $10^{-4}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2025] Jinx or Jackpot", "background": "", "description": "Jack 正在他最喜爱的赌场里，身上有 1000 美元。赌场里除了一台老虎机外一无所有。Jack 知道这家赌场的历史。从前，赌场未来的主人正在散步时，突然看到了一个包含 $n$ 个整数选项的数组 $p_1, \\dots, p_n$，每个选项都在 0 到 100 之间。他均匀随机地选取了一个索引 $i$ ($1 \\le i \\le n$)，并认为创建一个只有一台老虎机的赌场是个好主意，这台老虎机的中奖概率为 $\\frac{p_i}{100}$。于是他照做了。\n\nJack 知道主人散步时突然看到的选项数组 $p_1, \\dots, p_n$，但他不知道主人具体选取了哪个 $i$。然而，被选中的索引 $i$ 是永久固定的；老虎机始终使用相同的 $p_i$，如下所述。\n\n在老虎机上，Jack 可以下注 $x$ 美元，其中 $x$ 是一个 **非负** 整数，然后拉下拉杆。接着：\n\n1. 以概率 $\\frac{p_i}{100}$，它会中奖，老虎机返还给他 $2x$ 美元，因此他盈利 $x$ 美元。\n\n2. 以概率 $1 - \\frac{p_i}{100}$，它会失败，老虎机不返还任何钱，因此他亏损 $x$ 美元。\n\n即使 Jack 下注 0 美元，他也能知道结果是失败还是中奖。\n\n此外，老虎机不太耐用，因此 Jack 最多只能玩 $k$ 轮。\n\n通过最优策略，找出 Jack 能获得的最大期望 **利润**。这里的利润定义为 Jack 最终拥有的金额减去他初始的 1000 美元。\n\n当然，Jack 不能下注超过他当前余额的金额。", "inputFormat": "第一行包含两个整数 $n$ 和 $k$ ($1 \\le n \\le 100\\,000$；$1 \\le k \\le 30$) —— 选项数量和轮数限制。第二行包含 $n$ 个整数 $p_1, \\dots, p_n$ ($0 \\le p_i \\le 100$) —— 选项。", "outputFormat": "输出一个实数 —— Jack 通过最优策略能获得的期望利润。如果你的答案的绝对误差或相对误差不超过 $10^{-4}$，即被视为正确。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14792", "type": "P", "difficulty": 7, "samples": [["3\n2 3\nBBG\nGBB\n3 3\nGGG\nGGG\nGGG\n3 3\nGGG\nBBB\nGGG", "YES\n001\n101\n100\n0011\n1100\nYES\n111\n010\n010\n111\n1001\n1111\n1001\nNO"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2025] Knit the Grid", "background": "", "description": "The voodoo lady once knitted a magical tapestry. Initially, she took a blank canvas that can be represented as an $r \\times c$ grid with $r$ rows and $c$ columns, thus having $(r + 1) \\times (c + 1)$ grid points. Then she did the following operation some number of times: she knitted a cycle on the canvas along the grid lines, passing through each grid point at most once within that cycle. Additionally, no two cycles share any grid point.\n\nIn the end, it turned out that exactly one cycle passes through each of the $(r-1) \\cdot (c-1)$ inner grid points that don't lie on the canvas' border. Here are some examples of cycle arrangements for $r=2$, $c=3$ with the inner grid points highlighted:\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/6to903st.png)\n:::\n\nThen she left the canvas on the floor overnight. During the night, $r\\cdot c$ green frogs hopped on the canvas, with one sitting in each cell. But that was only the beginning of the voodoo lady's troubles! Because then, the old witch came to the canvas, and one-by-one, ripped away every knitted line on the canvas. Every time she ripped away a knitted line segment between two adjacent grid points, the frogs in the cells adjacent to that line segment got startled (there were one or two startled frogs, depending on whether the line segment was on a border or not). When a frog got startled, it instantly changed its color: if the frog was green, it became brown; and if it was brown, it became green again.\n\nIf the cycles were arranged as in the pictures above, then the colors would be as follows (greyed out cells represent green frogs and white cells represent brown ones):\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/rlh2zugm.png)\n:::\n\nWhen the voodoo lady came back to her canvas, she only saw that there were frogs of two colors on her canvas, but no knitted cycles. From the given arrangement of the frog colors, determine whether it could have been produced by the described process, and if so, help the voodoo lady to restore a possible arrangement of cycles.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $r$ and $c$, denoting the dimensions of the grid ($2 \\le r, c \\le 10^3$).\n\nEach of the next $r$ lines contains a string consisting of $c$ characters $\\texttt{G}$ or $\\texttt{B}$ denoting green and brown frogs respectively.\n\nIt is guaranteed that the sum of $r \\cdot c$ over all test cases does not exceed $2 \\cdot 10^6$.", "outputFormat": "For each test case, on the first line output $\\texttt{YES}$ if the given frog colors could have been produced by the described process, and $\\texttt{NO}$ otherwise.\n\nIf the answer is $\\texttt{YES}$, output $2r+1$ more lines with binary strings (with $\\texttt{0}$ and $\\texttt{1}$ characters). The first $r+1$ of those lines should have length $c$ each and represent the horizontal grid line segments and the next $r$ lines have length $c+1$ each and represent the vertical grid line segments of the answer as explained below.\n\nIn the first $r+1$ lines $j$-th character of the $i$-th line is $\\texttt{1}$ if the horizontal grid line segment that is $j$-th from the left and $i$-th from the top should have a knitted line along it, and $\\texttt{0}$ otherwise.\n\nIn the next $r$ lines $j$-th character of the $i$-th line is $\\texttt{1}$ if the vertical grid line segment that is $j$-th from the left and $i$-th from the top should have a knitted line along it, and $\\texttt{0}$ otherwise.", "hint": "The first test case is the first example of a cycle arrangement from the statement. \n\nIn the second sample test case, the output shown in the sample is illustrated in the first picture below. The cycle arrangement in the second picture is also correct, while in the third picture it is not, because some grid points are shared by more than one cycle. Leaving the grid empty would also not be correct, because there would be no cycle passing through inner grid points.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/kwjf3g5u.png)\n:::", "locale": "en", "translations": {"en": {"title": "[NERC 2025] Knit the Grid", "background": "", "description": "The voodoo lady once knitted a magical tapestry. Initially, she took a blank canvas that can be represented as an $r \\times c$ grid with $r$ rows and $c$ columns, thus having $(r + 1) \\times (c + 1)$ grid points. Then she did the following operation some number of times: she knitted a cycle on the canvas along the grid lines, passing through each grid point at most once within that cycle. Additionally, no two cycles share any grid point.\n\nIn the end, it turned out that exactly one cycle passes through each of the $(r-1) \\cdot (c-1)$ inner grid points that don't lie on the canvas' border. Here are some examples of cycle arrangements for $r=2$, $c=3$ with the inner grid points highlighted:\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/6to903st.png)\n:::\n\nThen she left the canvas on the floor overnight. During the night, $r\\cdot c$ green frogs hopped on the canvas, with one sitting in each cell. But that was only the beginning of the voodoo lady's troubles! Because then, the old witch came to the canvas, and one-by-one, ripped away every knitted line on the canvas. Every time she ripped away a knitted line segment between two adjacent grid points, the frogs in the cells adjacent to that line segment got startled (there were one or two startled frogs, depending on whether the line segment was on a border or not). When a frog got startled, it instantly changed its color: if the frog was green, it became brown; and if it was brown, it became green again.\n\nIf the cycles were arranged as in the pictures above, then the colors would be as follows (greyed out cells represent green frogs and white cells represent brown ones):\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/rlh2zugm.png)\n:::\n\nWhen the voodoo lady came back to her canvas, she only saw that there were frogs of two colors on her canvas, but no knitted cycles. From the given arrangement of the frog colors, determine whether it could have been produced by the described process, and if so, help the voodoo lady to restore a possible arrangement of cycles.", "inputFormat": "Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \\le t \\le 10^4$). The description of the test cases follows.\n\nThe first line of each test case contains two integers $r$ and $c$, denoting the dimensions of the grid ($2 \\le r, c \\le 10^3$).\n\nEach of the next $r$ lines contains a string consisting of $c$ characters $\\texttt{G}$ or $\\texttt{B}$ denoting green and brown frogs respectively.\n\nIt is guaranteed that the sum of $r \\cdot c$ over all test cases does not exceed $2 \\cdot 10^6$.", "outputFormat": "For each test case, on the first line output $\\texttt{YES}$ if the given frog colors could have been produced by the described process, and $\\texttt{NO}$ otherwise.\n\nIf the answer is $\\texttt{YES}$, output $2r+1$ more lines with binary strings (with $\\texttt{0}$ and $\\texttt{1}$ characters). The first $r+1$ of those lines should have length $c$ each and represent the horizontal grid line segments and the next $r$ lines have length $c+1$ each and represent the vertical grid line segments of the answer as explained below.\n\nIn the first $r+1$ lines $j$-th character of the $i$-th line is $\\texttt{1}$ if the horizontal grid line segment that is $j$-th from the left and $i$-th from the top should have a knitted line along it, and $\\texttt{0}$ otherwise.\n\nIn the next $r$ lines $j$-th character of the $i$-th line is $\\texttt{1}$ if the vertical grid line segment that is $j$-th from the left and $i$-th from the top should have a knitted line along it, and $\\texttt{0}$ otherwise.", "hint": "The first test case is the first example of a cycle arrangement from the statement. \n\nIn the second sample test case, the output shown in the sample is illustrated in the first picture below. The cycle arrangement in the second picture is also correct, while in the third picture it is not, because some grid points are shared by more than one cycle. Leaving the grid empty would also not be correct, because there would be no cycle passing through inner grid points.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/kwjf3g5u.png)\n:::", "locale": "en"}, "zh-CN": {"title": "[NERC 2025] Knit the Grid", "background": null, "description": "一位巫毒女士曾编织了一幅魔法挂毯。起初，她拿了一块空白画布，可以表示为一个 $r \\times c$ 的网格，有 $r$ 行和 $c$ 列，因此有 $(r + 1) \\times (c + 1)$ 个网格点。然后她进行了若干次如下操作：她沿着网格线在画布上编织一个环，该环中每个网格点最多被经过一次。此外，任意两个环不共享任何网格点。\n\n最终，对于不在画布边界上的 $(r - 1) \\times (c - 1)$ 个内部网格点，每个点恰好被一个环经过。以下是 $r=2$、$c=3$ 时的一些环排列示例，内部网格点已高亮显示：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/6to903st.png)\n:::\n\n然后她将画布留在地板上过夜。夜间，$r \\times c$ 只绿色青蛙跳上了画布，每只青蛙坐在一个单元格里。但这只是巫毒女士麻烦的开始！因为随后，老巫婆来到画布前，一个接一个地撕掉了画布上所有编织的线条。每次她撕掉两个相邻网格点之间的编织线段时，与该线段相邻的单元格中的青蛙会受到惊吓（根据线段是否在边界上，会有一只或两只青蛙受到惊吓）。当青蛙受到惊吓时，它会立即改变颜色：如果青蛙是绿色的，它会变成棕色；如果是棕色的，它会变回绿色。\n\n如果环的排列如上图所示，那么颜色将如下所示（灰色单元格代表绿色青蛙，白色单元格代表棕色青蛙）：\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/rlh2zugm.png)\n:::\n\n当巫毒女士回到她的画布前时，她只看到画布上有两种颜色的青蛙，但编织的环都不见了。根据给定的青蛙颜色排列，判断它是否可能是由上述过程产生的，如果是，请帮助巫毒女士恢复一种可能的环排列。", "inputFormat": "每个测试包含多个测试用例。第一行包含测试用例的数量 $t$ ($1 \\le t \\le 10^4$)。接下来是测试用例的描述。\n\n每个测试用例的第一行包含两个整数 $r$ 和 $c$，表示网格的尺寸 ($2 \\le r, c \\le 10^3$)。\n\n接下来的 $r$ 行，每行包含一个由 $c$ 个字符组成的字符串，字符为 $\\texttt{G}$ 或 $\\texttt{B}$，分别表示绿色和棕色青蛙。\n\n保证所有测试用例的 $r \\times c$ 之和不超过 $2 \\times 10^6$。", "outputFormat": "对于每个测试用例，如果给定的青蛙颜色可能是由上述过程产生的，则在第一行输出 $\\texttt{YES}$，否则输出 $\\texttt{NO}$。\n\n如果答案是 $\\texttt{YES}$，则额外输出 $2r+1$ 行二进制字符串（由 $\\texttt{0}$ 和 $\\texttt{1}$ 字符组成）。前 $r+1$ 行每行长度为 $c$，表示水平网格线段；接下来的 $r$ 行每行长度为 $c+1$，表示垂直网格线段，具体解释如下。\n\n在前 $r+1$ 行中，第 $i$ 行的第 $j$ 个字符为 $\\texttt{1}$，表示从左数第 $j$ 条、从上数第 $i$ 条的水平网格线段应有一条编织线经过，否则为 $\\texttt{0}$。\n\n在接下来的 $r$ 行中，第 $i$ 行的第 $j$ 个字符为 $\\texttt{1}$，表示从左数第 $j$ 条、从上数第 $i$ 条的垂直网格线段应有一条编织线经过，否则为 $\\texttt{0}$。", "hint": "第一个测试用例是题目描述中的第一个环排列示例。\n\n在第二个样例测试用例中，样例中展示的输出如下图所示的第一张图。第二张图中的环排列也是正确的，而第三张图中的排列不正确，因为有些网格点被多个环共享。保持网格为空也是不正确的，因为没有环经过内部网格点。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/kwjf3g5u.png)\n:::", "locale": "zh-CN"}}}
{"pid": "P14793", "type": "P", "difficulty": 6, "samples": [["4\n5\n1 + 1 = 2\nUUUUL\n5\n1 + 2 = 3\nUUUUL\n5\n2 + 1 = 3\nUUUUL\n5\n2 + 2 = 4\nUUUUL", "6.000000000000\n6.000000000000\n4.000000000000\n4.000000000000\n0.000000000000"], ["4\n4\nN E F <EOS>\nLLLL\n5\nN E R C <EOS>\nLLLLL\n6\nN E E R C <EOS>\nLLLLLL\n5\nI C P C <EOS>\nLLLLL", "55.683674395584\n12.490224995673\n8.000000000000\n8.000000000000\n8.000000000000\n8.000000000000"], ["1\n16\na b a c a b a d b a b d a b a c\nULLULLLLLLULLLLL", "22.595941331507\n12.464393446710\n5.245112497837\n2.000000000000\n0.000000000000\n0.000000000000\n0.000000000000\n0.000000000000\n0.000000000000\n0.000000000000\n0.000000000000\n0.000000000000\n0.000000000000\n0.000000000000\n0.000000000000\n0.000000000000"], ["2\n4\nWA WA WA AC\nLULL\n4\nAC AC WA AC\nLLUL", "5.509775004327\n4.754887502163\n4.000000000000\n2.000000000000"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2025", "Special Judge", "字典树 Trie", "后缀数组 SA", "ICPC", "拉格朗日乘数法", "NERC/NEERC"], "title": "[NERC 2025] LLM Training", "background": "", "description": "You are given a text dataset. Your task is to train LLM (Large Language Model) and find the minimal possible loss. No kidding.\n\nA text dataset is an array of texts $t_1, t_2, \\ldots, t_n$. Each text $t_i$ is a sequence of tokens. We define the set of tokens $T$ as the set of all tokens that appear in at least one text $t_i$. Additionally, for each text $t_i$, there is a set of positions $L_i \\subseteq \\{1, 2, \\ldots, |t_i|\\}$. The token $t_i[j]$ is generated by LLM if $j \\in L_i$ and is written by the user if $j \\notin L_i$.\n\nLet us define LLM with context size $k$ as a probabilistic model $P_k$, such that it defines the probability distribution of the next token of the sequence, depending on a context $w$ --- a sequence of length between $0$ and $k$ (inclusive) whose elements are from $T$. Thus the probabilistic model $P_k$ is a large table of probabilities $P_k(\\text{next} | w)$, defined for any context $w \\in T^{*}$, $0 \\leq |w| \\leq k$ and any token $\\text{next} \\in T$. Conditions $0 \\leq P_k(\\text{next} | w) \\leq 1$ and $\\sum\\limits_{\\text{next} \\in T} P_k(\\text{next} | w) = 1$ should be satisfied.\n\nThe loss function of LLM with the context size $k$ is the following function defined for $P_k$:\n\n$$\n\\mathcal{L}_k(P_k) \\,\\, = \\,\\,\n\\sum_{i=1}^{n} \\,\\, \\sum_{j\\in L_i} \\,\n-\\log_2 P_k\\!\\left(\n\\underbrace{t_i[j]}_{\\text{next token}}\n\\ \\middle|\\ \n\\underbrace{t_i[\\max(1,j-k)\\,..\\,j-1]}_{\\text{context}}\n\\right)\n$$\n\nHere $t_i[l\\,..\\,r] = t_i[l] t_i[l+1] \\ldots t_i[r]$ is the substring from $l$-th to $r$-th token, $t_i[1\\,..\\,0]$ is an empty string. So, for each text and for each token that is generated by LLM, we add to the loss the negative logarithm (base 2) of the probability that this token will be generated, depending on the substring of previous $k$ tokens (or the whole prefix, if it has length less than $k$). If the probability is zero, we assume that the negative logarithm is $+\\infty$. This loss function is known as the (base 2) Cross Entropy Loss over the LLM-generated positions. The smaller the loss function value $\\mathcal{L}_k(P_k)$, the better LLM $P_k$ is.\n\nFor each $0 \\leq k < \\max\\limits_{i=1..n} |t_i|$, calculate the minimum possible loss $\\mathcal{L}_k(P_k)$ that could be obtained for some $P_k$ --- LLM with context size $k$. It can be proved that this minimum is reachable and is not infinite.", "inputFormat": "The first line contains a single integer $n$ ($1 \\leq n \\leq 10^5$) --- the number of texts in the dataset. Text descriptions follow.\n\nThe first line of the $i$-th text description contains a single integer $m_i$ ($1 \\leq m_i \\leq 3 \\cdot 10^5$) --- the length of $t_i$ ($m_i = |t_i|$).\n\nThe next line contains $m_i$ strings $t_{i}[1]$, $t_{i}[2]$, $\\ldots$, $t_{i}[m_i]$ ($1 \\leq |t_{i}[j]| \\leq 5$) --- tokens of the text $t_i$. Each token consists of symbols with ASCII codes from $33$ to $126$ (printable characters).\n\nThe next line contains a string $\\ell_i$ of $m_i$ letters $\\texttt{U}$ and $\\texttt{L}$, which encodes the set $L_i$. All positions with the letter $\\texttt{L}$ are generated by LLM, and all positions with the letter $\\texttt{U}$ are written by the user. So $L_i = \\{j\\,|\\,\\ell_{i}[j] = \\texttt{L}\\}$. It is guaranteed that the last token is generated by LLM, so $\\ell_{i}[m_i] = \\texttt{L}$.\n\nIt is guaranteed that the sum of $m_i$ for all $i$ ($1 \\le i \\le n$) does not exceed $3 \\cdot 10^5$.", "outputFormat": "Print $M = \\max\\limits_{i=1..n} m_i$ real numbers: for each $k = 0, 1, \\ldots, M-1$ print the minimum possible loss $\\mathcal{L}_k(P_k)$ for all possible $P_k$ --- LLM with context size $k$.\n\nYour answers will be accepted if their absolute or relative errors do not exceed $10^{-6}$; formally, if $p$ is your answer, and $q$ is the jury's answer, this should hold: $\\frac{|p - q|}{\\max\\{1, |q|\\}} \\le 10^{-6}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2025] LLM Training", "background": "", "description": "You are given a text dataset. Your task is to train LLM (Large Language Model) and find the minimal possible loss. No kidding.\n\nA text dataset is an array of texts $t_1, t_2, \\ldots, t_n$. Each text $t_i$ is a sequence of tokens. We define the set of tokens $T$ as the set of all tokens that appear in at least one text $t_i$. Additionally, for each text $t_i$, there is a set of positions $L_i \\subseteq \\{1, 2, \\ldots, |t_i|\\}$. The token $t_i[j]$ is generated by LLM if $j \\in L_i$ and is written by the user if $j \\notin L_i$.\n\nLet us define LLM with context size $k$ as a probabilistic model $P_k$, such that it defines the probability distribution of the next token of the sequence, depending on a context $w$ --- a sequence of length between $0$ and $k$ (inclusive) whose elements are from $T$. Thus the probabilistic model $P_k$ is a large table of probabilities $P_k(\\text{next} | w)$, defined for any context $w \\in T^{*}$, $0 \\leq |w| \\leq k$ and any token $\\text{next} \\in T$. Conditions $0 \\leq P_k(\\text{next} | w) \\leq 1$ and $\\sum\\limits_{\\text{next} \\in T} P_k(\\text{next} | w) = 1$ should be satisfied.\n\nThe loss function of LLM with the context size $k$ is the following function defined for $P_k$:\n\n$$\n\\mathcal{L}_k(P_k) \\,\\, = \\,\\,\n\\sum_{i=1}^{n} \\,\\, \\sum_{j\\in L_i} \\,\n-\\log_2 P_k\\!\\left(\n\\underbrace{t_i[j]}_{\\text{next token}}\n\\ \\middle|\\ \n\\underbrace{t_i[\\max(1,j-k)\\,..\\,j-1]}_{\\text{context}}\n\\right)\n$$\n\nHere $t_i[l\\,..\\,r] = t_i[l] t_i[l+1] \\ldots t_i[r]$ is the substring from $l$-th to $r$-th token, $t_i[1\\,..\\,0]$ is an empty string. So, for each text and for each token that is generated by LLM, we add to the loss the negative logarithm (base 2) of the probability that this token will be generated, depending on the substring of previous $k$ tokens (or the whole prefix, if it has length less than $k$). If the probability is zero, we assume that the negative logarithm is $+\\infty$. This loss function is known as the (base 2) Cross Entropy Loss over the LLM-generated positions. The smaller the loss function value $\\mathcal{L}_k(P_k)$, the better LLM $P_k$ is.\n\nFor each $0 \\leq k < \\max\\limits_{i=1..n} |t_i|$, calculate the minimum possible loss $\\mathcal{L}_k(P_k)$ that could be obtained for some $P_k$ --- LLM with context size $k$. It can be proved that this minimum is reachable and is not infinite.", "inputFormat": "The first line contains a single integer $n$ ($1 \\leq n \\leq 10^5$) --- the number of texts in the dataset. Text descriptions follow.\n\nThe first line of the $i$-th text description contains a single integer $m_i$ ($1 \\leq m_i \\leq 3 \\cdot 10^5$) --- the length of $t_i$ ($m_i = |t_i|$).\n\nThe next line contains $m_i$ strings $t_{i}[1]$, $t_{i}[2]$, $\\ldots$, $t_{i}[m_i]$ ($1 \\leq |t_{i}[j]| \\leq 5$) --- tokens of the text $t_i$. Each token consists of symbols with ASCII codes from $33$ to $126$ (printable characters).\n\nThe next line contains a string $\\ell_i$ of $m_i$ letters $\\texttt{U}$ and $\\texttt{L}$, which encodes the set $L_i$. All positions with the letter $\\texttt{L}$ are generated by LLM, and all positions with the letter $\\texttt{U}$ are written by the user. So $L_i = \\{j\\,|\\,\\ell_{i}[j] = \\texttt{L}\\}$. It is guaranteed that the last token is generated by LLM, so $\\ell_{i}[m_i] = \\texttt{L}$.\n\nIt is guaranteed that the sum of $m_i$ for all $i$ ($1 \\le i \\le n$) does not exceed $3 \\cdot 10^5$.", "outputFormat": "Print $M = \\max\\limits_{i=1..n} m_i$ real numbers: for each $k = 0, 1, \\ldots, M-1$ print the minimum possible loss $\\mathcal{L}_k(P_k)$ for all possible $P_k$ --- LLM with context size $k$.\n\nYour answers will be accepted if their absolute or relative errors do not exceed $10^{-6}$; formally, if $p$ is your answer, and $q$ is the jury's answer, this should hold: $\\frac{|p - q|}{\\max\\{1, |q|\\}} \\le 10^{-6}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2025] LLM Training", "background": "", "description": "你被给予一个文本数据集。你的任务是训练 LLM（大型语言模型）并找到可能的最小损失。不开玩笑。\n\n一个文本数据集是一个文本数组 $t_1, t_2, \\ldots, t_n$。每个文本 $t_i$ 是一个词元序列。我们将词元集合 $T$ 定义为出现在至少一个文本 $t_i$ 中的所有词元的集合。此外，对于每个文本 $t_i$，存在一个位置集合 $L_i \\subseteq \\{1, 2, \\ldots, |t_i|\\}$。词元 $t_i[j]$ 由 LLM 生成当且仅当 $j \\in L_i$，由用户书写当且仅当 $j \\notin L_i$。\n\n让我们将上下文大小为 $k$ 的 LLM 定义为一个概率模型 $P_k$，它根据一个上下文 $w$（一个长度在 $0$ 到 $k$ 之间（含）且元素来自 $T$ 的序列）定义序列下一个词元的概率分布。因此概率模型 $P_k$ 是一个庞大的概率表 $P_k(\\text{next} | w)$，对任意上下文 $w \\in T^{*}$、$0 \\leq |w| \\leq k$ 和任意词元 $\\text{next} \\in T$ 均有定义。条件 $0 \\leq P_k(\\text{next} | w) \\leq 1$ 和 $\\sum\\limits_{\\text{next} \\in T} P_k(\\text{next} | w) = 1$ 必须满足。\n\n上下文大小为 $k$ 的 LLM 的损失函数是为 $P_k$ 定义的如下函数：\n\n$$\n\\mathcal{L}_k(P_k) \\,\\, = \\,\\,\n\\sum_{i=1}^{n} \\,\\, \\sum_{j\\in L_i} \\,\n-\\log_2 P_k\\!\\left(\n\\underbrace{t_i[j]}_{\\text{下一个词元}}\n\\ \\middle|\\ \n\\underbrace{t_i[\\max(1,j-k)\\,..\\,j-1]}_{\\text{上下文}}\n\\right)\n$$\n\n这里 $t_i[l\\,..\\,r] = t_i[l] t_i[l+1] \\ldots t_i[r]$ 是从第 $l$ 个到第 $r$ 个词元的子串，$t_i[1\\,..\\,0]$ 是空字符串。因此，对于每个文本以及每个由 LLM 生成的词元，我们将该词元将被生成的概率的负对数（以 $2$ 为底）加到损失中，该概率依赖于前 $k$ 个词元的子串（或者如果前缀长度小于 $k$，则是整个前缀）。如果概率为零，我们假设负对数为 $+\\infty$。该损失函数被称为基于 LLM 生成位置的（以 $2$ 为底的）交叉熵损失。损失函数值 $\\mathcal{L}_k(P_k)$ 越小，LLM $P_k$ 越好。\n\n对于每个 $0 \\leq k < \\max\\limits_{i=1..n} |t_i|$，计算对于某些 $P_k$ —— 上下文大小为 $k$ 的 LLM —— 可以获得的最小可能损失 $\\mathcal{L}_k(P_k)$。可以证明这个最小值是可达到的且不是无穷大。", "inputFormat": "第一行包含一个整数 $n$ ($1 \\leq n \\leq 10^5$) —— 数据集中文本的数量。接下来是文本描述。\n\n第 $i$ 个文本描述的第一行包含一个整数 $m_i$ ($1 \\leq m_i \\leq 3 \\cdot 10^5$) —— $t_i$ 的长度 ($m_i = |t_i|$)。\n\n下一行包含 $m_i$ 个字符串 $t_{i}[1]$, $t_{i}[2]$, $\\ldots$, $t_{i}[m_i]$ ($1 \\leq |t_{i}[j]| \\leq 5$) —— 文本 $t_i$ 的词元。每个词元由 ASCII 码在 $33$ 到 $126$ 之间的字符（可打印字符）组成。\n\n下一行包含一个由 $m_i$ 个字母 $\\texttt{U}$ 和 $\\texttt{L}$ 组成的字符串 $\\ell_i$，它编码了集合 $L_i$。所有字母为 $\\texttt{L}$ 的位置由 LLM 生成，所有字母为 $\\texttt{U}$ 的位置由用户书写。因此 $L_i = \\{j\\,|\\,\\ell_{i}[j] = \\texttt{L}\\}$。保证最后一个词元由 LLM 生成，即 $\\ell_{i}[m_i] = \\texttt{L}$。\n\n保证所有 $i$ ($1 \\le i \\le n$) 的 $m_i$ 之和不超过 $3 \\cdot 10^5$。", "outputFormat": "输出 $M = \\max\\limits_{i=1..n} m_i$ 个实数：对于每个 $k = 0, 1, \\ldots, M-1$，输出所有可能的 $P_k$ —— 上下文大小为 $k$ 的 LLM —— 的最小可能损失 $\\mathcal{L}_k(P_k)$。\n\n如果你的答案的绝对误差或相对误差不超过 $10^{-6}$，则将被接受；形式化地说，如果 $p$ 是你的答案，$q$ 是出题人的答案，则应满足：$\\frac{|p - q|}{\\max\\{1, |q|\\}} \\le 10^{-6}$。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14794", "type": "P", "difficulty": 3, "samples": [["3\n11101\n10110\n11101\n10010\n01100\n10110", "0\n1\n2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2025", "ICPC", "NERC/NEERC"], "title": "[NERC 2025] Medical Parity", "background": "", "description": "Nurse Mira works in an allergy clinic. For each patient Mira tests $n$ allergens in a fixed order. The outcome of the tests is written down as a binary string $x$ of length $n$: for each allergen, 1 means a positive reaction and 0 means no reaction.\n\nTo analyze how the reactions are distributed, Mira also writes a $\\emph{parity control string}$ for $x$. For a binary string $x$ of length $n$, the parity control string $y$ is defined as follows. For every position $i$ ($1 \\le i \\le n$), let $c_i$ be the number of characters equal to 1 among the first $i$ characters of $x$ (including position $i$). The parity control string $y$ is the binary string of length $n$ such that $y_i = c_i \\mod 2$ for all $i$ ($1 \\le i \\le n$). In other words, $y_i$ is 1 if $c_i$ is odd and 0 if $c_i$ is even. For example, if $x = 11101$, then $y = 10110$.\n\nUnfortunately, when recording the data, some bits in the test result string and the parity control string may have been written incorrectly. For a given patient, Mira later finds in the system two binary strings $x'$ and $y'$ of the same length $n$. They were intended to be some true test result string $x$ and its parity control string $y$, but some bits in $x$ and $y$ might have been flipped during recording. For instance, in the previous example only the 3rd bit in $y$ could have been flipped, resulting in $x' = 11101$ and $y' = 10010$.\n\nIn one $\\emph{bit flip}$, a position in one of the two strings is chosen and the bit at this position is flipped (changing 0 to 1 or 1 to 0). Mira wants to know the minimal number of bit flips that could have happened when recording the data.\n\nFormally, you are given two binary strings $x'$ and $y'$ of length $n$. You want to obtain two strings $x$ and $y$ of length $n$ from $x'$ and $y'$ by flipping some bits in $x'$ and $y'$, so that $y$ is a parity control string of $x$. Find the minimal possible total number of bit flips needed.", "inputFormat": "The first line of the input contains the number of test cases $t$. The $2t$ lines follow --- two lines for each test case. The first line of each test case contains a non-empty binary string $x'$ consisting of characters 0 and 1. The second line contains a binary string $y'$ consisting of characters 0 and 1 with the same length as $x'$.\n\nThe total length of all $x'$ strings in the input does not exceed $10^6$.", "outputFormat": "Print $t$ lines --- one line for each test case. For each test case, print a single integer --- the minimal possible number of bit flips that could have happened when recording the data.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2025] Medical Parity", "background": "", "description": "Nurse Mira works in an allergy clinic. For each patient Mira tests $n$ allergens in a fixed order. The outcome of the tests is written down as a binary string $x$ of length $n$: for each allergen, 1 means a positive reaction and 0 means no reaction.\n\nTo analyze how the reactions are distributed, Mira also writes a $\\emph{parity control string}$ for $x$. For a binary string $x$ of length $n$, the parity control string $y$ is defined as follows. For every position $i$ ($1 \\le i \\le n$), let $c_i$ be the number of characters equal to 1 among the first $i$ characters of $x$ (including position $i$). The parity control string $y$ is the binary string of length $n$ such that $y_i = c_i \\mod 2$ for all $i$ ($1 \\le i \\le n$). In other words, $y_i$ is 1 if $c_i$ is odd and 0 if $c_i$ is even. For example, if $x = 11101$, then $y = 10110$.\n\nUnfortunately, when recording the data, some bits in the test result string and the parity control string may have been written incorrectly. For a given patient, Mira later finds in the system two binary strings $x'$ and $y'$ of the same length $n$. They were intended to be some true test result string $x$ and its parity control string $y$, but some bits in $x$ and $y$ might have been flipped during recording. For instance, in the previous example only the 3rd bit in $y$ could have been flipped, resulting in $x' = 11101$ and $y' = 10010$.\n\nIn one $\\emph{bit flip}$, a position in one of the two strings is chosen and the bit at this position is flipped (changing 0 to 1 or 1 to 0). Mira wants to know the minimal number of bit flips that could have happened when recording the data.\n\nFormally, you are given two binary strings $x'$ and $y'$ of length $n$. You want to obtain two strings $x$ and $y$ of length $n$ from $x'$ and $y'$ by flipping some bits in $x'$ and $y'$, so that $y$ is a parity control string of $x$. Find the minimal possible total number of bit flips needed.", "inputFormat": "The first line of the input contains the number of test cases $t$. The $2t$ lines follow --- two lines for each test case. The first line of each test case contains a non-empty binary string $x'$ consisting of characters 0 and 1. The second line contains a binary string $y'$ consisting of characters 0 and 1 with the same length as $x'$.\n\nThe total length of all $x'$ strings in the input does not exceed $10^6$.", "outputFormat": "Print $t$ lines --- one line for each test case. For each test case, print a single integer --- the minimal possible number of bit flips that could have happened when recording the data.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2025] Medical Parity", "background": "", "description": "Mira 护士在一家过敏诊所工作。对于每位患者，Mira 按固定顺序测试 $n$ 种过敏原。测试结果被记录为一个长度为 $n$ 的二进制字符串 $x$：对于每种过敏原，1 表示阳性反应，0 表示无反应。\n\n为了分析反应是如何分布的，Mira 还会为 $x$ 编写一个 **奇偶控制字符串**。对于一个长度为 $n$ 的二进制字符串 $x$，奇偶控制字符串 $y$ 定义如下：对于每个位置 $i$ ($1 \\le i \\le n$)，令 $c_i$ 为 $x$ 的前 $i$ 个字符（包括位置 $i$）中等于 1 的字符个数。奇偶控制字符串 $y$ 是一个长度为 $n$ 的二进制字符串，使得对所有 $i$ ($1 \\le i \\le n$)，有 $y_i = c_i \\mod 2$。换句话说，如果 $c_i$ 为奇数则 $y_i$ 为 1，如果 $c_i$ 为偶数则 $y_i$ 为 0。例如，如果 $x = 11101$，那么 $y = 10110$。\n\n不幸的是，在记录数据时，测试结果字符串和奇偶控制字符串中的某些位可能被错误地书写了。对于一位给定的患者，Mira 后来在系统中找到了两个长度相同、均为 $n$ 的二进制字符串 $x'$ 和 $y'$。它们本应是某个真实的测试结果字符串 $x$ 及其奇偶控制字符串 $y$，但在记录过程中 $x$ 和 $y$ 的一些位可能被翻转了。例如，在前面的例子中，只有 $y$ 的第 3 位可能被翻转了，导致 $x' = 11101$ 和 $y' = 10010$。\n\n在一次 **位翻转** 中，选择两个字符串中某一位置，将该位置的位进行翻转（将 0 变为 1 或将 1 变为 0）。Mira 想知道在记录数据时可能发生的最小位翻转次数。\n\n形式化地说，你被给予两个长度为 $n$ 的二进制字符串 $x'$ 和 $y'$。你希望通过翻转 $x'$ 和 $y'$ 中的一些位，得到两个长度为 $n$ 的字符串 $x$ 和 $y$，使得 $y$ 是 $x$ 的奇偶控制字符串。找出所需的最小可能的总位翻转次数。", "inputFormat": "输入的第一行包含测试用例的数量 $t$。接下来是 $2t$ 行 —— 每个测试用例两行。每个测试用例的第一行包含一个非空的二进制字符串 $x'$，由字符 0 和 1 组成。第二行包含一个二进制字符串 $y'$，由字符 0 和 1 组成，且长度与 $x'$ 相同。\n\n输入中所有 $x'$ 字符串的总长度不超过 $10^6$。", "outputFormat": "输出 $t$ 行 —— 每个测试用例一行。对于每个测试用例，输出一个整数 —— 在记录数据时可能发生的最小位翻转次数。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14795", "type": "P", "difficulty": 2, "samples": [["3\n1000 500 800", "1000"], ["6\n100 75 41 75 13 89", "89"], ["6\n20 25 12 7 13 16", "16"], ["8\n364353982 103422534 437367896 91518637 364353982 221490368 437367896 103422534", "364353982"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "离散化", "JOI（日本）"], "title": "[JOI 2026 二次预选] 分班 / Class Division", "background": "", "description": " JOI 高校的一年级共有 $N$ 人，并被编号为从 $1$ 到 $N$。\n\n某天，一年级的 $N$ 人参加了考试。学生 $i$（$1 \\le i \\le N$）的得分为 $A_i$ 分。这里，$N$ 人并不是都取得了相同的分数。\n\n根据这次考试的成绩来决定明年的分班。具体来说，选择一个整数 $x$，将 $N$ 名学生分成两个班：得分在 $x$ 分以上（含 $x$ 分）的学生进入升学班，得分低于 $x$ 分的学生进入普通班。\n\n在此，要求每个班都至少有 $1$ 名学生，并且选择一种分法，使升学班的人数与普通班的人数之差最小。进一步地，如果满足条件的分法有多个，则在其中选择升学班人数最少的分法。\n\n给定学生人数以及每位学生的得分，编写程序求出升学班学生得分的最低分。", "inputFormat": "\n输入按以下格式给出。  \n> $N$  \n> $A_1\\ \\ A_2\\ \\ \\dots\\ \\ A_N$", "outputFormat": "输出一行：升学班学生得分的最低分。\n", "hint": "\n### 样例解释\n\n\n#### 样例 $1$ 解释\n\n例如，令 $x = 900$，则学生 $1$ 被分到升学班，学生 $2, 3$ 被分到普通班。\n\n另一种可能的分班方式是，将学生 $1, 3$ 分到升学班，将学生 $2$ 分到普通班。比如令 $x = 800$ 就可以实现这一点。\n\n这两种分法中，升学班人数与普通班人数之差都为 $1$。因此，会选择升学班人数最少的前一种分法。此时，升学班学生得分的最低分是 $1\\,000$ 分。\n\n该输入样例满足所有子任务的约束。\n\n### 样例 2 解释\n\n令 $x = 89$，则学生 $1, 6$ 被分到升学班，学生 $2, 3, 4, 5$ 被分到普通班。此时升学班学生得分的最低分为 $89$ 分。\n\n该输入样例满足子任务 4 的约束。\n\n### 样例 $3$ 解释\n该输入样例满足子任务 3, 4 的约束。\n\n### 样例 $4$ 解释\n该输入样例满足子任务 4 的约束。\n\n\n### 约束\n\n- $2 \\le N \\le 500\\,000$。\n- $1 \\le A_i \\le 10^9$（$1 \\le i \\le N$）。\n- 存在 $i, j$（$1 \\le i < j \\le N$）使得 $A_i \\ne A_j$。\n- 输入的值均为整数。\n\n### 子任务\n\n- $\\text{(20 pts)}$：$N = 3$。\n- $\\text{(20 pts)}$：$A_i$ 为 $500, 800, 1\\,000$ 之一（$1 \\le i \\le N$）。\n- $\\text{(20 pts)}$：$A_i \\ne A_j$（$1 \\le i < j \\le N$）。\n- $\\text{(40 pts)}$：无额外约束。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI 2026 二次预选] 分班 / Class Division", "background": "", "description": " JOI 高校的一年级共有 $N$ 人，并被编号为从 $1$ 到 $N$。\n\n某天，一年级的 $N$ 人参加了考试。学生 $i$（$1 \\le i \\le N$）的得分为 $A_i$ 分。这里，$N$ 人并不是都取得了相同的分数。\n\n根据这次考试的成绩来决定明年的分班。具体来说，选择一个整数 $x$，将 $N$ 名学生分成两个班：得分在 $x$ 分以上（含 $x$ 分）的学生进入升学班，得分低于 $x$ 分的学生进入普通班。\n\n在此，要求每个班都至少有 $1$ 名学生，并且选择一种分法，使升学班的人数与普通班的人数之差最小。进一步地，如果满足条件的分法有多个，则在其中选择升学班人数最少的分法。\n\n给定学生人数以及每位学生的得分，编写程序求出升学班学生得分的最低分。", "inputFormat": "\n输入按以下格式给出。  \n> $N$  \n> $A_1\\ \\ A_2\\ \\ \\dots\\ \\ A_N$", "outputFormat": "输出一行：升学班学生得分的最低分。\n", "hint": "\n### 样例解释\n\n\n#### 样例 $1$ 解释\n\n例如，令 $x = 900$，则学生 $1$ 被分到升学班，学生 $2, 3$ 被分到普通班。\n\n另一种可能的分班方式是，将学生 $1, 3$ 分到升学班，将学生 $2$ 分到普通班。比如令 $x = 800$ 就可以实现这一点。\n\n这两种分法中，升学班人数与普通班人数之差都为 $1$。因此，会选择升学班人数最少的前一种分法。此时，升学班学生得分的最低分是 $1\\,000$ 分。\n\n该输入样例满足所有子任务的约束。\n\n### 样例 2 解释\n\n令 $x = 89$，则学生 $1, 6$ 被分到升学班，学生 $2, 3, 4, 5$ 被分到普通班。此时升学班学生得分的最低分为 $89$ 分。\n\n该输入样例满足子任务 4 的约束。\n\n### 样例 $3$ 解释\n该输入样例满足子任务 3, 4 的约束。\n\n### 样例 $4$ 解释\n该输入样例满足子任务 4 的约束。\n\n\n### 约束\n\n- $2 \\le N \\le 500\\,000$。\n- $1 \\le A_i \\le 10^9$（$1 \\le i \\le N$）。\n- 存在 $i, j$（$1 \\le i < j \\le N$）使得 $A_i \\ne A_j$。\n- 输入的值均为整数。\n\n### 子任务\n\n- $\\text{(20 pts)}$：$N = 3$。\n- $\\text{(20 pts)}$：$A_i$ 为 $500, 800, 1\\,000$ 之一（$1 \\le i \\le N$）。\n- $\\text{(20 pts)}$：$A_i \\ne A_j$（$1 \\le i < j \\le N$）。\n- $\\text{(40 pts)}$：无额外约束。\n\n", "locale": "zh-CN"}}}
{"pid": "P14796", "type": "P", "difficulty": 3, "samples": [["3\n3 1 2", "2"], ["1\n99 ", "33"], ["2\n5 6", "3"], ["6\n0 2 2 3 1 2 ", "3"], ["1\n0", "0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "数学", "贪心", "2025", "JOI（日本）"], "title": "[JOI 2026 二次预选] 究极团子达人 / Ultimate Dango Maker", "background": "", "description": "JOI 君是一名团子师傅。团子有从颜色 $1$ 到颜色 $N$ 的 $N$ 种颜色，JOI 君拥有颜色 $i$（$1 \\le i \\le N$）的团子 $A_i$ 个。\n\nJOI 君可以从自己拥有的团子中选出 $3$ 个，做成 $1$ 串串团子。  \n但是，当选出的 $3$ 个团子的颜色为 $c_1, c_2, c_3$（$1 \\le c_1 \\le N$，$1 \\le c_2 \\le N$，$1 \\le c_3 \\le N$）时，$c_1$ 与 $c_2$，$c_2$ 与 $c_3$，$c_3$ 与 $c_1$ 的差分别必须不超过 $1$。  \n也就是说，必须满足以下所有条件。\n\n- $|c_1 - c_2| \\le 1$\n- $|c_2 - c_3| \\le 1$\n- $|c_3 - c_1| \\le 1$\n\n不能在多串团子之间共享并使用同一个团子。JOI 君想要通过巧妙地选择自己拥有的团子，尽可能多地制作团子串。\n\n当给出关于 JOI 君所拥有团子的信息时，请编写一个程序，求出 JOI 君能够制作的团子串数的最大值。\n", "inputFormat": "\n输入按如下格式给出。  \n> $N$  \n> $A_1$ $A_2 $ $\\dots$ $A_N$", "outputFormat": "输出一行：JOI 君能够制作的团子串数的最大值。\n", "hint": "\n### 样例解释\n\n#### 样例 $1$ 解释\n\n\n可以制作共计 $2$ 串：$1$ 串使用颜色 $1$ 的团子 $3$ 个，另 $1$ 串使用颜色 $2$ 的团子 $1$ 个与颜色 $3$ 的团子 $2$ 个。  \n第 $1$ 串满足 $|1 - 1| = 0 \\le 1$，第 $2$ 串满足 $|2 - 3| \\le 1$，$|3 - 3| \\le 1$，因此这种选取方式满足条件。  \n由于无法制作超过 $2$ 串团子，所以输出 $2$。\n\n该输入示例满足子任务 $5, 6$ 的约束。\n#### 样例 $2$ 解释\n\n可以制作颜色 $1$ 的团子 $3$ 个组成团子 $33$ 串。  \n由于无法制作超过 $33$ 串团子，所以输出 $33$。\n\n该输入示例满足子任务 $1, 2, 3, 6$ 的约束。\n#### 样例 $3$ 解释\n\n可以制作共计 $3$ 串：$1$ 串使用颜色 $1$ 的团子 $3$ 个，$1$ 串使用颜色 $1$ 的团子 $2$ 个与颜色 $2$ 的团子 $1$ 个，$1$ 串使用颜色 $2$ 的团子 $3$ 个。  \n由于无法制作超过 $3$ 串团子，所以输出 $3$。\n\n该输入示例满足子任务 $2, 6$ 的约束。\n#### 样例 $4$ 解释\n\n该输入示例满足子任务 $5, 6$ 的约束。\n#### 样例 $5$ 解释\n\n该输入示例满足子任务 $1, 2, 3, 5, 6$ 的约束。\n\n\n### 约束\n\n- $1 \\le N \\le 200\\,000$。\n- $0 \\le A_i \\le 10^9$（$1 \\le i \\le N$）。\n- 输入中的值均为整数。\n\n### 子任务\n\n- （$6$ 分）$N = 1$。\n- （$9$ 分）$N \\le 2$。\n- （$10$ 分）$A_i$ 是 $3$ 的倍数（$1 \\le i \\le N$）。\n- （$17$ 分）$A_i = 2$（$1 \\le i \\le N$）。\n- （$21$ 分）$A_i \\le 3$（$1 \\le i \\le N$）。\n- （$37$ 分）没有额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI 2026 二次预选] 究极团子达人 / Ultimate Dango Maker", "background": "", "description": "JOI 君是一名团子师傅。团子有从颜色 $1$ 到颜色 $N$ 的 $N$ 种颜色，JOI 君拥有颜色 $i$（$1 \\le i \\le N$）的团子 $A_i$ 个。\n\nJOI 君可以从自己拥有的团子中选出 $3$ 个，做成 $1$ 串串团子。  \n但是，当选出的 $3$ 个团子的颜色为 $c_1, c_2, c_3$（$1 \\le c_1 \\le N$，$1 \\le c_2 \\le N$，$1 \\le c_3 \\le N$）时，$c_1$ 与 $c_2$，$c_2$ 与 $c_3$，$c_3$ 与 $c_1$ 的差分别必须不超过 $1$。  \n也就是说，必须满足以下所有条件。\n\n- $|c_1 - c_2| \\le 1$\n- $|c_2 - c_3| \\le 1$\n- $|c_3 - c_1| \\le 1$\n\n不能在多串团子之间共享并使用同一个团子。JOI 君想要通过巧妙地选择自己拥有的团子，尽可能多地制作团子串。\n\n当给出关于 JOI 君所拥有团子的信息时，请编写一个程序，求出 JOI 君能够制作的团子串数的最大值。\n", "inputFormat": "\n输入按如下格式给出。  \n> $N$  \n> $A_1$ $A_2 $ $\\dots$ $A_N$", "outputFormat": "输出一行：JOI 君能够制作的团子串数的最大值。\n", "hint": "\n### 样例解释\n\n#### 样例 $1$ 解释\n\n\n可以制作共计 $2$ 串：$1$ 串使用颜色 $1$ 的团子 $3$ 个，另 $1$ 串使用颜色 $2$ 的团子 $1$ 个与颜色 $3$ 的团子 $2$ 个。  \n第 $1$ 串满足 $|1 - 1| = 0 \\le 1$，第 $2$ 串满足 $|2 - 3| \\le 1$，$|3 - 3| \\le 1$，因此这种选取方式满足条件。  \n由于无法制作超过 $2$ 串团子，所以输出 $2$。\n\n该输入示例满足子任务 $5, 6$ 的约束。\n#### 样例 $2$ 解释\n\n可以制作颜色 $1$ 的团子 $3$ 个组成团子 $33$ 串。  \n由于无法制作超过 $33$ 串团子，所以输出 $33$。\n\n该输入示例满足子任务 $1, 2, 3, 6$ 的约束。\n#### 样例 $3$ 解释\n\n可以制作共计 $3$ 串：$1$ 串使用颜色 $1$ 的团子 $3$ 个，$1$ 串使用颜色 $1$ 的团子 $2$ 个与颜色 $2$ 的团子 $1$ 个，$1$ 串使用颜色 $2$ 的团子 $3$ 个。  \n由于无法制作超过 $3$ 串团子，所以输出 $3$。\n\n该输入示例满足子任务 $2, 6$ 的约束。\n#### 样例 $4$ 解释\n\n该输入示例满足子任务 $5, 6$ 的约束。\n#### 样例 $5$ 解释\n\n该输入示例满足子任务 $1, 2, 3, 5, 6$ 的约束。\n\n\n### 约束\n\n- $1 \\le N \\le 200\\,000$。\n- $0 \\le A_i \\le 10^9$（$1 \\le i \\le N$）。\n- 输入中的值均为整数。\n\n### 子任务\n\n- （$6$ 分）$N = 1$。\n- （$9$ 分）$N \\le 2$。\n- （$10$ 分）$A_i$ 是 $3$ 的倍数（$1 \\le i \\le N$）。\n- （$17$ 分）$A_i = 2$（$1 \\le i \\le N$）。\n- （$21$ 分）$A_i \\le 3$（$1 \\le i \\le N$）。\n- （$37$ 分）没有额外约束。", "locale": "zh-CN"}}}
{"pid": "P14797", "type": "P", "difficulty": 2, "samples": [["6\nJOIJOI ", "OIOIJJ"], ["8\nJJJOIOIO", "OIOIJJJO"], ["20\nJJOIJOIJOOIJOIIJJOIO", "OIOIJJJJOOIOIJIOIJJO"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["模拟", "2025", "JOI（日本）"], "title": "[JOI 2026 二次预选] JOI 消去器 / JOI Eliminator", "background": "", "description": " 由 $\\texttt{J}, \\texttt{O}, \\texttt{I}$ 构成的长度为 $N$ 的字符串 $S$ 存在。  \nJOI 君对字符串 $S$ 重复进行如下操作，直到无法再进行任何操作为止。\n\n- 在 $S$ 中选择一处 $\\texttt{J}, \\texttt{O}, \\texttt{I}$ 按此顺序连续排列的部分，并将该部分替换为 $\\texttt{O}, \\texttt{I}, \\texttt{J}$ 的排列。\n\n可以证明，操作的重复必定会结束，并且无论操作方式如何，最终字符串的状态都是唯一确定的。\n\n给出初始字符串 $S$ 的信息时，请编写程序求出最终的字符串 $S$。  \n", "inputFormat": "\n输入按如下格式给出。  \n> $N$  \n> $S$  ", "outputFormat": "将最终的字符串 $S$ 用一行输出。\n", "hint": "\n### 样例解释\n\n#### 样例 $1$ 解释\n\n\n例如，可以考虑 JOI 君如下进行操作。\n\n最初，$S = \\texttt{JOIJOI}$。  \n\n- 对第 $1$ 个字符到第 $3$ 个字符进行操作。$S = \\texttt{OIJJOI}$。  \n- 对第 $4$ 个字符到第 $6$ 个字符进行操作。$S = \\texttt{OIJOIJ}$。  \n- 对第 $3$ 个字符到第 $5$ 个字符进行操作。$S = \\texttt{OIOIJJ}$。  \n\n由于无法再进行更多操作，因此输出 $\\texttt{OIOIJJ}$。  \n\n该样例输入满足子任务 $1, 2, 4$ 的约束。  \n\n\n#### 样例 $2$ 解释\n该样例输入满足子任务 $1, 3, 4$ 的约束。  \n#### 样例 $3$ 解释\n\n\n该样例输入满足子任务 $1, 4$ 的约束。\n\n\n### 约束\n\n- $3 \\le N \\le 500\\,000$。  \n- $S$ 是由 $\\texttt{J}, \\texttt{O}, \\texttt{I}$ 构成的长度为 $N$ 的字符串。  \n- $N$ 是整数。  \n\n### 子任务\n\n- （14 分）$N \\le 100$。  \n- （27 分）$N$ 是 $3$ 的倍数，并且 $S$ 是将 $JOI$ 重复 $N / 3$ 次得到的字符串。  \n- （29 分）存在某个整数 $k$（$2 \\le k \\le N$），使得从 $S$ 的第 $1$ 个字符到第 $k$ 个字符全都是 $\\texttt{J}$，而从第 $k + 1$ 个字符开始之后都不是 $\\texttt{J}$。  \n- （30 分）无额外约束。  ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI 2026 二次预选] JOI 消去器 / JOI Eliminator", "background": "", "description": " 由 $\\texttt{J}, \\texttt{O}, \\texttt{I}$ 构成的长度为 $N$ 的字符串 $S$ 存在。  \nJOI 君对字符串 $S$ 重复进行如下操作，直到无法再进行任何操作为止。\n\n- 在 $S$ 中选择一处 $\\texttt{J}, \\texttt{O}, \\texttt{I}$ 按此顺序连续排列的部分，并将该部分替换为 $\\texttt{O}, \\texttt{I}, \\texttt{J}$ 的排列。\n\n可以证明，操作的重复必定会结束，并且无论操作方式如何，最终字符串的状态都是唯一确定的。\n\n给出初始字符串 $S$ 的信息时，请编写程序求出最终的字符串 $S$。  \n", "inputFormat": "\n输入按如下格式给出。  \n> $N$  \n> $S$  ", "outputFormat": "将最终的字符串 $S$ 用一行输出。\n", "hint": "\n### 样例解释\n\n#### 样例 $1$ 解释\n\n\n例如，可以考虑 JOI 君如下进行操作。\n\n最初，$S = \\texttt{JOIJOI}$。  \n\n- 对第 $1$ 个字符到第 $3$ 个字符进行操作。$S = \\texttt{OIJJOI}$。  \n- 对第 $4$ 个字符到第 $6$ 个字符进行操作。$S = \\texttt{OIJOIJ}$。  \n- 对第 $3$ 个字符到第 $5$ 个字符进行操作。$S = \\texttt{OIOIJJ}$。  \n\n由于无法再进行更多操作，因此输出 $\\texttt{OIOIJJ}$。  \n\n该样例输入满足子任务 $1, 2, 4$ 的约束。  \n\n\n#### 样例 $2$ 解释\n该样例输入满足子任务 $1, 3, 4$ 的约束。  \n#### 样例 $3$ 解释\n\n\n该样例输入满足子任务 $1, 4$ 的约束。\n\n\n### 约束\n\n- $3 \\le N \\le 500\\,000$。  \n- $S$ 是由 $\\texttt{J}, \\texttt{O}, \\texttt{I}$ 构成的长度为 $N$ 的字符串。  \n- $N$ 是整数。  \n\n### 子任务\n\n- （14 分）$N \\le 100$。  \n- （27 分）$N$ 是 $3$ 的倍数，并且 $S$ 是将 $JOI$ 重复 $N / 3$ 次得到的字符串。  \n- （29 分）存在某个整数 $k$（$2 \\le k \\le N$），使得从 $S$ 的第 $1$ 个字符到第 $k$ 个字符全都是 $\\texttt{J}$，而从第 $k + 1$ 个字符开始之后都不是 $\\texttt{J}$。  \n- （30 分）无额外约束。  ", "locale": "zh-CN"}}}
{"pid": "P14798", "type": "P", "difficulty": 4, "samples": [["3 4\n8 10 3\n12 5\n3 2\n3 4\n100 100", "20\n14\n8\n21"], ["1 3 \n83\n2 5\n4 5\n6 5", "34\n67\n83"], ["15 3\n3 1 4 1 5 9 2 6 5 3 5 8 9 7 9\n1 1\n10 1\n20 1", "9\n67\n77"], ["6 3\n1000000000 999999999 999999998 999999997 999999996 999999995\n1000000000 1\n1 1000000000\n900000000 900000000", "5999999985\n1\n1499999985"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "二分", "2025", "JOI（日本）"], "title": "[JOI 2026 二次预选] 购物 3 / Shopping 3", "background": "", "description": " JOI 商店里有 $N$ 个商品，商品被编号为 $1$ 到 $N$。商品 $i$（$1 \\le i \\le N$）的标价是 $A_i$。\n\n在 JOI 商店的网络购物中，购买商品时可以选择使用同一种类的优惠券 $0$ 张以上，并且可以使用任意张数。JOI 商店一共有 $Q$ 种优惠券，优惠券种类编号为 $1$ 到 $Q$。\n\n当使用种类 $j$（$1 \\le j \\le Q$）的优惠券 $k$ 张（$k \\ge 0$）时，其效果如下。\n\n- 对于 $i = 1, 2, \\dots, N$，商品 $i$ 的价格变为 $\\max(0, A_i - D_j \\times k)$（其中 $\\max(0, A_i - D_j \\times k)$ 表示 $0$ 与 $A_i - D_j \\times k$ 中较大的那个）。\n- 除了商品价格之外，还需要支付额外费用 $C_j \\times k$。\n\n对每一种优惠券种类，都可以提出 $Q$ 个问题。第 $j$ 个问题如下。\n\n- 只使用种类 $j$ 的优惠券购买 $N$ 个商品各 $1$ 个时，需要支付的总金额的最小值是多少。\n\n给定商品与优惠券的信息，请编写程序求出各个问题的答案。", "inputFormat": "\n输入按如下格式给出。\n\n> $N\\ \\ Q$  \n> $A_1\\ \\ A_2\\ \\ \\dots\\ \\ A_N$  \n> $C_1\\ \\ D_1$  \n> $\\vdots$  \n> $C_Q\\ \\ D_Q$\n", "outputFormat": "\n输出 $Q$ 行。第 $j$ 行（$1 \\le j \\le Q$）输出第 $j$ 个问题的答案。\n", "hint": "\n### 样例解释\n\n#### 样例 $1$ 解释\n\n在第 $1$ 个问题中，使用种类 $1$ 的优惠券 $1$ 张后，各商品价格变为 $3, 5, 0$，总金额为 $3 + 5 + 0 + 12 \\times 1 = 20$。由于无法达到比 $20$ 更小的总金额，因此输出 $20$。\n\n在第 $2$ 个问题中，使用种类 $2$ 的优惠券 $4$ 张后，各商品价格变为 $0, 2, 0$，总金额为 $0 + 2 + 0 + 3 \\times 4 = 14$。由于无法达到比 $14$ 更小的总金额，因此输出 $14$。\n\n在第 $3$ 个问题中，使用种类 $3$ 的优惠券 $2$ 张后，各商品价格变为 $0, 2, 0$，总金额为 $0 + 2 + 0 + 3 \\times 2 = 8$。由于无法达到比 $8$ 更小的总金额，因此输出 $8$。\n\n在第 $4$ 个问题中，使用种类 $4$ 的优惠券 $0$ 张后，各商品价格变为 $8, 10, 3$，总金额为 $8 + 10 + 3 + 100 \\times 0 = 21$。由于无法达到比 $21$ 更小的总金额，因此输出 $21$。\n\n该输入示例满足子任务 $2, 4, 6, 7$ 的约束。\n#### 样例 $2$ 解释\n该输入示例满足子任务 $1, 2, 4, 6, 7$ 的约束。\n#### 样例 $3$ 解释\n该输入示例满足子任务 $2, 3, 4, 5, 6, 7$ 的约束。\n#### 样例 $4$ 解释\n\n该输入示例满足子任务 $4, 7$ 的约束。\n\n\n\n### 约束\n\n- $1 \\le N \\le 300\\,000$。\n- $1 \\le Q \\le 300\\,000$。\n- $1 \\le A_i \\le 10^9$（$1 \\le i \\le N$）。\n- $1 \\le C_j \\le 10^9$（$1 \\le j \\le Q$）。\n- $1 \\le D_j \\le 10^9$（$1 \\le j \\le Q$）。\n- 输入值均为整数。\n\n### 子任务\n\n- （$6$ 分）$N = 1$，$Q \\le 3\\,000$。\n- （$3$ 分）$N \\le 100$，$Q \\le 100$，$A_i \\le 100$（$1 \\le i \\le N$）。\n- （$8$ 分）$N \\le 3\\,000$，$Q \\le 3\\,000$，$D_j = 1$（$1 \\le j \\le Q$）。\n- （$22$ 分）$N \\le 3\\,000$，$Q \\le 3\\,000$。\n- （$15$ 分）$D_j = 1$（$1 \\le j \\le Q$）。\n- （$18$ 分）$A_i \\le 1\\,000\\,000$（$1 \\le i \\le N$）。\n- （$28$ 分）无额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI 2026 二次预选] 购物 3 / Shopping 3", "background": "", "description": " JOI 商店里有 $N$ 个商品，商品被编号为 $1$ 到 $N$。商品 $i$（$1 \\le i \\le N$）的标价是 $A_i$。\n\n在 JOI 商店的网络购物中，购买商品时可以选择使用同一种类的优惠券 $0$ 张以上，并且可以使用任意张数。JOI 商店一共有 $Q$ 种优惠券，优惠券种类编号为 $1$ 到 $Q$。\n\n当使用种类 $j$（$1 \\le j \\le Q$）的优惠券 $k$ 张（$k \\ge 0$）时，其效果如下。\n\n- 对于 $i = 1, 2, \\dots, N$，商品 $i$ 的价格变为 $\\max(0, A_i - D_j \\times k)$（其中 $\\max(0, A_i - D_j \\times k)$ 表示 $0$ 与 $A_i - D_j \\times k$ 中较大的那个）。\n- 除了商品价格之外，还需要支付额外费用 $C_j \\times k$。\n\n对每一种优惠券种类，都可以提出 $Q$ 个问题。第 $j$ 个问题如下。\n\n- 只使用种类 $j$ 的优惠券购买 $N$ 个商品各 $1$ 个时，需要支付的总金额的最小值是多少。\n\n给定商品与优惠券的信息，请编写程序求出各个问题的答案。", "inputFormat": "\n输入按如下格式给出。\n\n> $N\\ \\ Q$  \n> $A_1\\ \\ A_2\\ \\ \\dots\\ \\ A_N$  \n> $C_1\\ \\ D_1$  \n> $\\vdots$  \n> $C_Q\\ \\ D_Q$\n", "outputFormat": "\n输出 $Q$ 行。第 $j$ 行（$1 \\le j \\le Q$）输出第 $j$ 个问题的答案。\n", "hint": "\n### 样例解释\n\n#### 样例 $1$ 解释\n\n在第 $1$ 个问题中，使用种类 $1$ 的优惠券 $1$ 张后，各商品价格变为 $3, 5, 0$，总金额为 $3 + 5 + 0 + 12 \\times 1 = 20$。由于无法达到比 $20$ 更小的总金额，因此输出 $20$。\n\n在第 $2$ 个问题中，使用种类 $2$ 的优惠券 $4$ 张后，各商品价格变为 $0, 2, 0$，总金额为 $0 + 2 + 0 + 3 \\times 4 = 14$。由于无法达到比 $14$ 更小的总金额，因此输出 $14$。\n\n在第 $3$ 个问题中，使用种类 $3$ 的优惠券 $2$ 张后，各商品价格变为 $0, 2, 0$，总金额为 $0 + 2 + 0 + 3 \\times 2 = 8$。由于无法达到比 $8$ 更小的总金额，因此输出 $8$。\n\n在第 $4$ 个问题中，使用种类 $4$ 的优惠券 $0$ 张后，各商品价格变为 $8, 10, 3$，总金额为 $8 + 10 + 3 + 100 \\times 0 = 21$。由于无法达到比 $21$ 更小的总金额，因此输出 $21$。\n\n该输入示例满足子任务 $2, 4, 6, 7$ 的约束。\n#### 样例 $2$ 解释\n该输入示例满足子任务 $1, 2, 4, 6, 7$ 的约束。\n#### 样例 $3$ 解释\n该输入示例满足子任务 $2, 3, 4, 5, 6, 7$ 的约束。\n#### 样例 $4$ 解释\n\n该输入示例满足子任务 $4, 7$ 的约束。\n\n\n\n### 约束\n\n- $1 \\le N \\le 300\\,000$。\n- $1 \\le Q \\le 300\\,000$。\n- $1 \\le A_i \\le 10^9$（$1 \\le i \\le N$）。\n- $1 \\le C_j \\le 10^9$（$1 \\le j \\le Q$）。\n- $1 \\le D_j \\le 10^9$（$1 \\le j \\le Q$）。\n- 输入值均为整数。\n\n### 子任务\n\n- （$6$ 分）$N = 1$，$Q \\le 3\\,000$。\n- （$3$ 分）$N \\le 100$，$Q \\le 100$，$A_i \\le 100$（$1 \\le i \\le N$）。\n- （$8$ 分）$N \\le 3\\,000$，$Q \\le 3\\,000$，$D_j = 1$（$1 \\le j \\le Q$）。\n- （$22$ 分）$N \\le 3\\,000$，$Q \\le 3\\,000$。\n- （$15$ 分）$D_j = 1$（$1 \\le j \\le Q$）。\n- （$18$ 分）$A_i \\le 1\\,000\\,000$（$1 \\le i \\le N$）。\n- （$28$ 分）无额外约束。", "locale": "zh-CN"}}}
{"pid": "P14799", "type": "P", "difficulty": 4, "samples": [["4 4\n1 2\n1 3\n1 4\n3 4", "0\n3\n0\n3"], ["2 0", "1\n1"], ["4 3\n1 3\n3 4\n2 4", "2\n1\n1\n3"], ["6 6\n1 4\n1 3\n2 4\n2 5\n3 6\n5 6", "1\n1\n3\n5\n3\n5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "图论建模", "图遍历", "连通块", "JOI（日本）"], "title": "[JOI 2026 二次预选] 比太郎之旅 3 / Bitaro's Travel 3", "background": "", "description": " JOI 国由 $N$ 个城市和连接它们的 $M$ 条道路构成。城市被编号为 $1$ 到 $N$，道路被编号为 $1$ 到 $M$。道路 $i \\ (1 \\le i \\le M)$ 双向连接城市 $A_i$ 和城市 $B_i$。这里，$A_i < B_i$。此外，对于任意两个城市的配对，连接它们的道路最多只有 $1$ 条。也就是说，$A_i \\ne A_j$ 或 $B_i \\ne B_j \\ (1 \\le i < j \\le M)$。\n\n比太郎现在在城市 $s$，正在制定旅行计划。旅行计划用数列 $v = (v_1, v_2, \\dots)$ 表示，它表示比太郎将访问的城市编号的顺序。这里，$v$ 是由 $1$ 以上 $N$ 以下的整数组成的、长度至少为 $1$ 的数列。由于比太郎对旅行中访问城市编号的顺序有很强的执念，数列 $v$ 在其长度为 $l$ 时，必须满足以下所有条件。\n\n1. $v_1 = s$。\n2. 对于各个 $j = 1, 2, \\dots, l - 1$，城市 $v_j$ 与城市 $v_{j+1}$ 由道路连接。\n3. 对于各个 $j = 1, 2, \\dots, l - 1$，当 $j$ 为奇数时有 $v_j < v_{j+1}$ 成立，当 $j$ 为偶数时有 $v_j > v_{j+1}$ 成立。\n\n例如，$v = (2)$ 和 $v = (1, 4, 1, 5, 3)$ 满足第 $3$ 个条件，但 $v = (3, 2)$ 不满足第 $3$ 个条件。\n\n比太郎想知道：无论制定怎样的旅行计划都无法到达的城市，即在满足上述所有条件的任意数列 $v$ 中都不会出现其编号的城市，总共有多少个。\n\n由于你不知道比太郎当前在什么城市，因此希望对 $s = 1, 2, \\dots, N$ 各自，计算比太郎问题的答案。\n\n给定关于 JOI 国的城市与道路的信息，请编写程序，对 $s = 1, 2, \\dots, N$ 各自，求出无论比太郎制定怎样的旅行计划都无法到达的城市个数。", "inputFormat": "\n输入按以下格式给出。  \n> $N \\ \\ M$  \n> $A_1 \\ \\ B_1$  \n> $A_2 \\ \\ B_2$  \n> $\\vdots$  \n> $A_M \\ \\ B_M$", "outputFormat": "输出 $N$ 行。第 $k \\ (1 \\le k \\le N)$ 行输出当 $s = k$ 时，无论比太郎制定怎样的旅行计划都无法到达的城市个数。\n", "hint": "\n### 样例解释\n\n#### 样例 $1$ 解释\n\n\n当 $s = 1$ 时，作为 $v$ 可能的数列有 $v = (1)$、$v = (1, 2)$、$v = (1, 3)$、$v = (1, 4, 1)$、$v = (1, 4, 1, 2)$ 等。不存在无论制定怎样的旅行计划都无法到达的城市。\n\n当 $s = 2$ 时，作为 $v$ 可能的数列只有 $v = (2)$。无论制定怎样的旅行计划，都无法到达城市 $1, 3, 4$。\n\n当 $s = 3$ 时，作为 $v$ 可能的数列有 $v = (3)$、$v = (3, 4, 1, 2)$ 等。不存在无论制定怎样的旅行计划都无法到达的城市。\n\n当 $s = 4$ 时，作为 $v$ 可能的数列只有 $v = (4)$。无论制定怎样的旅行计划，都无法到达城市 $1, 2, 3$。\n\n该输入示例满足子任务 $2, 5$ 的约束。\n\n#### 样例 $2$ 解释\n当 $s = 1$ 时，作为 $v$ 可能的数列只有 $v = (1)$。无论制定怎样的旅行计划，都无法到达城市 $2$。\n\n当 $s = 2$ 时，作为 $v$ 可能的数列只有 $v = (2)$。无论制定怎样的旅行计划，都无法到达城市 $1$。\n\n该输入示例满足子任务 $2, 4, 5$ 的约束。\n#### 样例 $3$ 解释\n该输入示例满足所有子任务的约束。\n\n#### 样例 $4$ 解释\n\n该输入示例满足子任务 $2, 4, 5$ 的约束。\n\n### 约束\n\n- $1 \\le N \\le 300\\,000$。\n- $0 \\le M \\le 300\\,000$。\n- $1 \\le A_i < B_i \\le N \\ (1 \\le i \\le M)$。\n- $A_i \\ne A_j$ 或 $B_i \\ne B_j \\ (1 \\le i < j \\le M)$。\n- 输入的值全部为整数。\n\n### 子任务\n\n- （12 分）$N \\le 1000$，$M = N - 1$。另外，存在一个将 $(1, 2, \\dots, N)$ 重新排列得到的某个排列 $P = (P_1, P_2, \\dots, P_N)$，并且对各个 $i = 1, 2, \\dots, N - 1$，存在一条连接 $P_i$ 与 $P_{i+1}$ 的道路。\n- （19 分）$N \\le 1000$，$M \\le 1000$。\n- （15 分）$M = N - 1$。另外，存在一个将 $(1, 2, \\dots, N)$ 重新排列得到的某个排列 $P = (P_1, P_2, \\dots, P_N)$，并且对各个 $i = 1, 2, \\dots, N - 1$，存在一条连接 $P_i$ 与 $P_{i+1}$ 的道路。\n- （17 分）对每个城市，与该城市直接由道路连接的城市最多为 $2$ 个。\n- （37 分）没有额外约束。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI 2026 二次预选] 比太郎之旅 3 / Bitaro's Travel 3", "background": "", "description": " JOI 国由 $N$ 个城市和连接它们的 $M$ 条道路构成。城市被编号为 $1$ 到 $N$，道路被编号为 $1$ 到 $M$。道路 $i \\ (1 \\le i \\le M)$ 双向连接城市 $A_i$ 和城市 $B_i$。这里，$A_i < B_i$。此外，对于任意两个城市的配对，连接它们的道路最多只有 $1$ 条。也就是说，$A_i \\ne A_j$ 或 $B_i \\ne B_j \\ (1 \\le i < j \\le M)$。\n\n比太郎现在在城市 $s$，正在制定旅行计划。旅行计划用数列 $v = (v_1, v_2, \\dots)$ 表示，它表示比太郎将访问的城市编号的顺序。这里，$v$ 是由 $1$ 以上 $N$ 以下的整数组成的、长度至少为 $1$ 的数列。由于比太郎对旅行中访问城市编号的顺序有很强的执念，数列 $v$ 在其长度为 $l$ 时，必须满足以下所有条件。\n\n1. $v_1 = s$。\n2. 对于各个 $j = 1, 2, \\dots, l - 1$，城市 $v_j$ 与城市 $v_{j+1}$ 由道路连接。\n3. 对于各个 $j = 1, 2, \\dots, l - 1$，当 $j$ 为奇数时有 $v_j < v_{j+1}$ 成立，当 $j$ 为偶数时有 $v_j > v_{j+1}$ 成立。\n\n例如，$v = (2)$ 和 $v = (1, 4, 1, 5, 3)$ 满足第 $3$ 个条件，但 $v = (3, 2)$ 不满足第 $3$ 个条件。\n\n比太郎想知道：无论制定怎样的旅行计划都无法到达的城市，即在满足上述所有条件的任意数列 $v$ 中都不会出现其编号的城市，总共有多少个。\n\n由于你不知道比太郎当前在什么城市，因此希望对 $s = 1, 2, \\dots, N$ 各自，计算比太郎问题的答案。\n\n给定关于 JOI 国的城市与道路的信息，请编写程序，对 $s = 1, 2, \\dots, N$ 各自，求出无论比太郎制定怎样的旅行计划都无法到达的城市个数。", "inputFormat": "\n输入按以下格式给出。  \n> $N \\ \\ M$  \n> $A_1 \\ \\ B_1$  \n> $A_2 \\ \\ B_2$  \n> $\\vdots$  \n> $A_M \\ \\ B_M$", "outputFormat": "输出 $N$ 行。第 $k \\ (1 \\le k \\le N)$ 行输出当 $s = k$ 时，无论比太郎制定怎样的旅行计划都无法到达的城市个数。\n", "hint": "\n### 样例解释\n\n#### 样例 $1$ 解释\n\n\n当 $s = 1$ 时，作为 $v$ 可能的数列有 $v = (1)$、$v = (1, 2)$、$v = (1, 3)$、$v = (1, 4, 1)$、$v = (1, 4, 1, 2)$ 等。不存在无论制定怎样的旅行计划都无法到达的城市。\n\n当 $s = 2$ 时，作为 $v$ 可能的数列只有 $v = (2)$。无论制定怎样的旅行计划，都无法到达城市 $1, 3, 4$。\n\n当 $s = 3$ 时，作为 $v$ 可能的数列有 $v = (3)$、$v = (3, 4, 1, 2)$ 等。不存在无论制定怎样的旅行计划都无法到达的城市。\n\n当 $s = 4$ 时，作为 $v$ 可能的数列只有 $v = (4)$。无论制定怎样的旅行计划，都无法到达城市 $1, 2, 3$。\n\n该输入示例满足子任务 $2, 5$ 的约束。\n\n#### 样例 $2$ 解释\n当 $s = 1$ 时，作为 $v$ 可能的数列只有 $v = (1)$。无论制定怎样的旅行计划，都无法到达城市 $2$。\n\n当 $s = 2$ 时，作为 $v$ 可能的数列只有 $v = (2)$。无论制定怎样的旅行计划，都无法到达城市 $1$。\n\n该输入示例满足子任务 $2, 4, 5$ 的约束。\n#### 样例 $3$ 解释\n该输入示例满足所有子任务的约束。\n\n#### 样例 $4$ 解释\n\n该输入示例满足子任务 $2, 4, 5$ 的约束。\n\n### 约束\n\n- $1 \\le N \\le 300\\,000$。\n- $0 \\le M \\le 300\\,000$。\n- $1 \\le A_i < B_i \\le N \\ (1 \\le i \\le M)$。\n- $A_i \\ne A_j$ 或 $B_i \\ne B_j \\ (1 \\le i < j \\le M)$。\n- 输入的值全部为整数。\n\n### 子任务\n\n- （12 分）$N \\le 1000$，$M = N - 1$。另外，存在一个将 $(1, 2, \\dots, N)$ 重新排列得到的某个排列 $P = (P_1, P_2, \\dots, P_N)$，并且对各个 $i = 1, 2, \\dots, N - 1$，存在一条连接 $P_i$ 与 $P_{i+1}$ 的道路。\n- （19 分）$N \\le 1000$，$M \\le 1000$。\n- （15 分）$M = N - 1$。另外，存在一个将 $(1, 2, \\dots, N)$ 重新排列得到的某个排列 $P = (P_1, P_2, \\dots, P_N)$，并且对各个 $i = 1, 2, \\dots, N - 1$，存在一条连接 $P_i$ 与 $P_{i+1}$ 的道路。\n- （17 分）对每个城市，与该城市直接由道路连接的城市最多为 $2$ 个。\n- （37 分）没有额外约束。\n", "locale": "zh-CN"}}}
{"pid": "P14800", "type": "P", "difficulty": 5, "samples": [["2  \n1 2", "1"], ["3  \n1 10 100", "-1"], ["5  \n5 6 8 9 11", "3\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2025", "ST 表", "JOI（日本）"], "title": "[JOI 2026 二次预选] 船 / Ship", "background": "", "description": " 意大利的切塞纳蒂科 (Cesenatico) 是一座面向亚得里亚海的港口城市，并以拥有运河而闻名。运河中停泊着船只，也作为旅游景点而闻名。这里，我们想要考虑一个将现实简化后的如下情境设定。\n\n运河是直线状的，并且只有一侧与亚得里亚海相通。另外，运河中停泊着从 1 到 $N$ 编号的 $N$ 艘船，船 $i$ ($1 \\le i \\le N$) 停泊在距离亚得里亚海 $A_i$ 的位置。\n\n这里，编号较小的船停泊在离亚得里亚海更近的位置。也就是说，成立 $A_1 < A_2 < \\dots < A_N$。\n\n你决定为了城里举办的祭典给船上色。具体来说，对每一艘船，从颜色 1 到颜色 $N$ 的 $N$ 种颜色中选择 1 种颜色，并用该颜色给船上色。这里，希望满足以下条件。\n\n- 对于任意颜色 $c$ ($1 \\le c \\le N$)，被涂成颜色 $c$ 的船的数量**不是** 1 艘。注意，也**可以不存在**被涂成颜色 $c$ 的船。  \n- 若被涂成颜色 $c$ 的船有 2 艘以上，则被涂成颜色 $c$ 的船等间隔排列。换句话说，对被涂成颜色 $c$ 的船，将其到亚得里亚海的距离按升序排列得到的序列是等差数列。\n\n为了让船看起来更美观，定义如下所表示的**美丽度**。\n\n- 在同一种颜色涂装的不同两艘船之间的距离中可能的最小值。这里，船 $i$ 与船 $j$ ($1 \\le i \\le N,\\ 1 \\le j \\le N,\\ i \\ne j$) 之间的距离定义为 $|A_i - A_j|$。\n\n给定船的信息时，请编写程序判断是否存在满足条件的船的涂色方式；若存在，则求出作为美丽度可能的最大值。\n", "inputFormat": "\n输入以如下形式给出。  \n> $N$  \n> $A_1\\ \\ A_2\\ \\ A_3\\ \\ \\dots\\ \\ A_N$\n", "outputFormat": "\n若不存在满足条件的船的涂色方式，则输出 $-1$。\n\n若存在，输出一行：美丽度可能的最大值。", "hint": "\n### 样例解释\n#### 样例 $1$ 解释\n\n例如，作为**不满足**条件的船的涂色方式，可以考虑如下。\n\n- 将船 1 涂成颜色 1，将船 2 涂成颜色 2。\n\n在这种涂色方式中，被涂成颜色 1 的船的数量为 1 艘，因此不满足条件。\n\n例如，作为满足条件的船的涂色方式，可以考虑如下。\n\n- 将船 1 与船 2 涂成颜色 2。\n\n在这种涂色方式中，不存在被涂成颜色 1 的船，因此满足关于颜色 1 的条件。另外，将被涂成颜色 2 的船到亚得里亚海的距离按升序排列得到的序列为 $(1, 2)$，这是等差数列，因此满足关于颜色 2 的条件。于是，这种涂色方式满足条件。\n\n在这种涂色方式中，同色涂装的两艘船的组合是船 1 与船 2。这两艘船之间的距离为 $|A_1 - A_2| = |1 - 2| = 1$。因此，美丽度为 1。\n\n由于无法使美丽度达到 2 以上，因此输出 1。\n\n该输入示例满足所有子任务的约束。\n\n#### 样例 $2$ 解释\n为了对任意颜色都使得被涂成该颜色的船的数量不是 1 艘，必须将船 1、2、3 涂成同一种颜色。\n\n此时，将与船 1 被涂的颜色相同的船到亚得里亚海的距离按升序排列得到的序列为 $(1, 10, 100)$，这不是等差数列。\n\n因此，不存在满足条件的船的涂色方式，所以输出 $-1$。\n\n该输入示例满足子任务 2、3、4、5 的约束。\n#### 样例 $3$ 解释\n例如，作为满足条件的船的涂色方式，可以考虑如下。\n\n- 将船 1、船 3、船 5 涂成颜色 1，将船 2、船 4 涂成颜色 4。\n\n在这种涂色方式中，同色涂装的两艘船的组合共有 4 组，分别是船 1 与船 3、船 1 与船 5、船 2 与船 4、船 3 与船 5。这些组合中两艘船之间的距离分别为 3、6、3、3。因此，美丽度为 3。\n\n由于无法使美丽度达到 4 以上，因此输出 3。\n\n该输入示例满足子任务 2、3、4、5 的约束。\n\n\n\n### 约束\n\n- $2 \\le N \\le 3\\,500$。  \n- $1 \\le A_i \\le 10^9$ ($1 \\le i \\le N$)。  \n- $A_i < A_{i+1}$ ($1 \\le i \\le N-1$)。  \n- 输入的值全部为整数。\n\n### 子任务\n\n- (8 分) $A_i = i$ ($1 \\le i \\le N$)。  \n- (11 分) $N \\le 7$。  \n- (12 分) $N \\le 100$。  \n- (39 分) $N \\le 700$。  \n- (30 分) 没有额外约束。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[JOI 2026 二次预选] 船 / Ship", "background": "", "description": " 意大利的切塞纳蒂科 (Cesenatico) 是一座面向亚得里亚海的港口城市，并以拥有运河而闻名。运河中停泊着船只，也作为旅游景点而闻名。这里，我们想要考虑一个将现实简化后的如下情境设定。\n\n运河是直线状的，并且只有一侧与亚得里亚海相通。另外，运河中停泊着从 1 到 $N$ 编号的 $N$ 艘船，船 $i$ ($1 \\le i \\le N$) 停泊在距离亚得里亚海 $A_i$ 的位置。\n\n这里，编号较小的船停泊在离亚得里亚海更近的位置。也就是说，成立 $A_1 < A_2 < \\dots < A_N$。\n\n你决定为了城里举办的祭典给船上色。具体来说，对每一艘船，从颜色 1 到颜色 $N$ 的 $N$ 种颜色中选择 1 种颜色，并用该颜色给船上色。这里，希望满足以下条件。\n\n- 对于任意颜色 $c$ ($1 \\le c \\le N$)，被涂成颜色 $c$ 的船的数量**不是** 1 艘。注意，也**可以不存在**被涂成颜色 $c$ 的船。  \n- 若被涂成颜色 $c$ 的船有 2 艘以上，则被涂成颜色 $c$ 的船等间隔排列。换句话说，对被涂成颜色 $c$ 的船，将其到亚得里亚海的距离按升序排列得到的序列是等差数列。\n\n为了让船看起来更美观，定义如下所表示的**美丽度**。\n\n- 在同一种颜色涂装的不同两艘船之间的距离中可能的最小值。这里，船 $i$ 与船 $j$ ($1 \\le i \\le N,\\ 1 \\le j \\le N,\\ i \\ne j$) 之间的距离定义为 $|A_i - A_j|$。\n\n给定船的信息时，请编写程序判断是否存在满足条件的船的涂色方式；若存在，则求出作为美丽度可能的最大值。\n", "inputFormat": "\n输入以如下形式给出。  \n> $N$  \n> $A_1\\ \\ A_2\\ \\ A_3\\ \\ \\dots\\ \\ A_N$\n", "outputFormat": "\n若不存在满足条件的船的涂色方式，则输出 $-1$。\n\n若存在，输出一行：美丽度可能的最大值。", "hint": "\n### 样例解释\n#### 样例 $1$ 解释\n\n例如，作为**不满足**条件的船的涂色方式，可以考虑如下。\n\n- 将船 1 涂成颜色 1，将船 2 涂成颜色 2。\n\n在这种涂色方式中，被涂成颜色 1 的船的数量为 1 艘，因此不满足条件。\n\n例如，作为满足条件的船的涂色方式，可以考虑如下。\n\n- 将船 1 与船 2 涂成颜色 2。\n\n在这种涂色方式中，不存在被涂成颜色 1 的船，因此满足关于颜色 1 的条件。另外，将被涂成颜色 2 的船到亚得里亚海的距离按升序排列得到的序列为 $(1, 2)$，这是等差数列，因此满足关于颜色 2 的条件。于是，这种涂色方式满足条件。\n\n在这种涂色方式中，同色涂装的两艘船的组合是船 1 与船 2。这两艘船之间的距离为 $|A_1 - A_2| = |1 - 2| = 1$。因此，美丽度为 1。\n\n由于无法使美丽度达到 2 以上，因此输出 1。\n\n该输入示例满足所有子任务的约束。\n\n#### 样例 $2$ 解释\n为了对任意颜色都使得被涂成该颜色的船的数量不是 1 艘，必须将船 1、2、3 涂成同一种颜色。\n\n此时，将与船 1 被涂的颜色相同的船到亚得里亚海的距离按升序排列得到的序列为 $(1, 10, 100)$，这不是等差数列。\n\n因此，不存在满足条件的船的涂色方式，所以输出 $-1$。\n\n该输入示例满足子任务 2、3、4、5 的约束。\n#### 样例 $3$ 解释\n例如，作为满足条件的船的涂色方式，可以考虑如下。\n\n- 将船 1、船 3、船 5 涂成颜色 1，将船 2、船 4 涂成颜色 4。\n\n在这种涂色方式中，同色涂装的两艘船的组合共有 4 组，分别是船 1 与船 3、船 1 与船 5、船 2 与船 4、船 3 与船 5。这些组合中两艘船之间的距离分别为 3、6、3、3。因此，美丽度为 3。\n\n由于无法使美丽度达到 4 以上，因此输出 3。\n\n该输入示例满足子任务 2、3、4、5 的约束。\n\n\n\n### 约束\n\n- $2 \\le N \\le 3\\,500$。  \n- $1 \\le A_i \\le 10^9$ ($1 \\le i \\le N$)。  \n- $A_i < A_{i+1}$ ($1 \\le i \\le N-1$)。  \n- 输入的值全部为整数。\n\n### 子任务\n\n- (8 分) $A_i = i$ ($1 \\le i \\le N$)。  \n- (11 分) $N \\le 7$。  \n- (12 分) $N \\le 100$。  \n- (39 分) $N \\le 700$。  \n- (30 分) 没有额外约束。", "locale": "zh-CN"}}}
{"pid": "P14801", "type": "P", "difficulty": 5, "samples": [["5 7", "8\n3 2 1 3 1 4 1\n1 5 0\n1 6 1\n1 7 1\n1 8 1\n1 8 0\n1 8 1\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "Special Judge", "CCPC", "哈尔滨"], "title": "[CCPC 2024 哈尔滨站] 造计算机", "background": "", "description": "你想要造一台计算机来实现一个功能：给出一个整数 $x$，判断 $x$ 是否在 $[L, R]$ 区间内。为此，你在电路中设计了一个边权为 $0$ 和 $1$ 的有向无环图，包含一个入度为 $0$ 的起点和一个出度为 $0$ 的终点。从起点出发沿着某一条路径走到终点，将经过的边权连成一个串，就可以得到 $[L, R]$ 范围内的一个整数的不含前导零的二进制表示，并且 $[L, R]$ 范围内的任意一个整数都能从这张图中找到唯一一条对应路径。这样一来，你只需要判断一个数的二进制表示是否能够通过这个有向无环图表达出来，就可以判断它是否在 $[L, R]$ 区间内。\n\n显然，你可以将每个整数的对应路径分开成一条条链的形式，可你发现给出的范围很大时，这种有向无环图所需的节点太多了，你造的只有 256MiB 内存的计算机根本存不下。因此，你需要压缩这张有向无环图，即不同的路径之间可能会有共用的节点，使得这张图的点数和边数减少到一定范围内。形式化地说，你需要构造一个点数不超过 $100$，每个节点出度不超过 $200$ 的有向无环图，边权为 $0$ 和 $1$，有且仅有一个入度为 $0$ 的起点和一个出度为 $0$ 的终点。$[L, R]$ 中的每一个整数，都能与这张有向无环图中的一条起点到终点的路径 $\\textbf{一一对应}$。具体地说，对于$[L, R]$ 中的任意一个整数，在图中有且仅有一条起点到终点的路径与之对应，且图中不存在一条起点到终点的路径能够对应 $[L, R]$ 范围之外的某一个整数。注意，图中的任意一条起点到终点的路径得到的二进制串均不能出现前导零。两点之间可以存在边权不同的两条边。", "inputFormat": "一行两个正整数 $L, R$ ($1 \\le L \\le R \\le 10^6$)。", "outputFormat": "第一行输出节点数 $n$ ($1 \\le n \\le 100$)。\n\n对于接下来 $n$ 行，第 $i$ 行先输出一个整数 $k$ ($0 \\le k \\le 200$)，表示节点 $i$ 的出边条数，接下来输出 $2 \\cdot k$ 个正整数 $a_{i,k}, v_{i,k}$ ($1 \\le a_{i,k} \\le n$, $a_{i,k} \\neq i$, $v_{i,k} \\in \\{0, 1\\}$)，表示点 $i$ 有一条连向 $a_{i,k}$ 的边权为 $v_{i,k}$ 的有向边。你需要保证输出的是一张满足题目要求的有向无环图。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CCPC 2024 Harbin Site] Build a Computer", "background": "", "description": "You want to build a computer to achieve a specific functionality: Given an integer $x$, determine whether $x$ lies within the interval $[L, R]$. To accomplish this, you designed a directed acyclic graph (DAG) with edge weights of $0$ and $1$, which contains a starting node with an indegree of $0$ and an ending node with an outdegree of $0$. By starting from the starting node and following a path to the ending node, the sequence of the traversed edge weights forms a binary representation of an integer within the range $[L, R]$ without leading zeros. Every integer within the range $[L, R]$ must correspond to exactly one unique path in this graph. In this way, you can determine whether an integer lies within the range $[L, R]$ by checking if its binary representation can be constructed by traversing this DAG.\n\nClearly, you could separate the corresponding path for each integer into individual chains. However, you realized that for a large range, such a DAG would require too many nodes, and the computer you built with only 256 MiB of memory cannot store it. Therefore, you need to compress this DAG, allowing different paths to share nodes, in order to reduce the number of nodes and edges. Formally, you need to construct a DAG with no more than $100$ nodes, where each node has an outdegree of at most $200$. The DAG must have edge weights of $0$ and $1$, with exactly one starting node with an in-degree of $0$ and one ending node with an out-degree of $0$. Every integer in the range $[L, R]$ must correspond to $\\textbf{exactly}$ one unique path from the start to the end in this DAG, and no path should represent any integer outside the range $[L, R]$. Note that none of the binary sequences formed by any path in the graph should have leading zeros. There may be two edges with different weights between two nodes.", "inputFormat": "A single line containing two positive integers $L, R$ ($1 \\le L \\le R \\le 10^6$).", "outputFormat": "The first line should output the number of nodes $n$ ($1 \\le n \\le 100$).\n\nFor the next $n$ lines, the $i$-th line should start with an integer $k$ ($0 \\le k \\le 200$), representing the number of outgoing edges from node $i$. Then output $2 \\cdot k$ integers $a_{i,k}, v_{i,k}$ ($1 \\le a_{i,k} \\le n$, $a_{i,k} \\neq i$, $v_{i,k} \\in \\{0, 1\\}$), which means that node $i$ has a directed edge with weight $v_{i,k}$ to node $a_{i,k}$. You must ensure that the output represents a directed acyclic graph that satisfies the requirements.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCPC 2024 哈尔滨站] 造计算机", "background": "", "description": "你想要造一台计算机来实现一个功能：给出一个整数 $x$，判断 $x$ 是否在 $[L, R]$ 区间内。为此，你在电路中设计了一个边权为 $0$ 和 $1$ 的有向无环图，包含一个入度为 $0$ 的起点和一个出度为 $0$ 的终点。从起点出发沿着某一条路径走到终点，将经过的边权连成一个串，就可以得到 $[L, R]$ 范围内的一个整数的不含前导零的二进制表示，并且 $[L, R]$ 范围内的任意一个整数都能从这张图中找到唯一一条对应路径。这样一来，你只需要判断一个数的二进制表示是否能够通过这个有向无环图表达出来，就可以判断它是否在 $[L, R]$ 区间内。\n\n显然，你可以将每个整数的对应路径分开成一条条链的形式，可你发现给出的范围很大时，这种有向无环图所需的节点太多了，你造的只有 256MiB 内存的计算机根本存不下。因此，你需要压缩这张有向无环图，即不同的路径之间可能会有共用的节点，使得这张图的点数和边数减少到一定范围内。形式化地说，你需要构造一个点数不超过 $100$，每个节点出度不超过 $200$ 的有向无环图，边权为 $0$ 和 $1$，有且仅有一个入度为 $0$ 的起点和一个出度为 $0$ 的终点。$[L, R]$ 中的每一个整数，都能与这张有向无环图中的一条起点到终点的路径 $\\textbf{一一对应}$。具体地说，对于$[L, R]$ 中的任意一个整数，在图中有且仅有一条起点到终点的路径与之对应，且图中不存在一条起点到终点的路径能够对应 $[L, R]$ 范围之外的某一个整数。注意，图中的任意一条起点到终点的路径得到的二进制串均不能出现前导零。两点之间可以存在边权不同的两条边。", "inputFormat": "一行两个正整数 $L, R$ ($1 \\le L \\le R \\le 10^6$)。", "outputFormat": "第一行输出节点数 $n$ ($1 \\le n \\le 100$)。\n\n对于接下来 $n$ 行，第 $i$ 行先输出一个整数 $k$ ($0 \\le k \\le 200$)，表示节点 $i$ 的出边条数，接下来输出 $2 \\cdot k$ 个正整数 $a_{i,k}, v_{i,k}$ ($1 \\le a_{i,k} \\le n$, $a_{i,k} \\neq i$, $v_{i,k} \\in \\{0, 1\\}$)，表示点 $i$ 有一条连向 $a_{i,k}$ 的边权为 $v_{i,k}$ 的有向边。你需要保证输出的是一张满足题目要求的有向无环图。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14802", "type": "P", "difficulty": 6, "samples": [["2\n6\n-2 0\n1 -2\n5 2\n0 4\n1 2\n3 1\n4\n0 0\n1 0\n0 1\n1 1", "40\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["计算几何", "2024", "凸包", "旋转卡壳", "CCPC", "哈尔滨"], "title": "[CCPC 2024 哈尔滨站] 凹包", "background": "", "description": "简单多边形是平面中由线段组成的闭合曲线，这些线段首尾相连，除了因连接共用的线段端点，任何两个线段都不能彼此相交。\n\n简单多边形可以分为两类：凸多边形和凹多边形。一个凸多边形是指：多边形中任意两点间的线段上的所有点都在多边形内，包括在内部或边界上。不是凸多边形的简单多边形就是凹多边形。如下图，左边是一个凸多边形，右边是一个凹多边形。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/gs8lvekd.png)\n:::\n\n现在，给定 $n$ 个点，满足所有点互不相同，且不存在三个点在同一条直线上。你的任务是选择这 $n$ 个点中的一些点（可以全选），并按照任意顺序依次连边，最后需要连成一个面积严格大于 $0$ 的 $\\textbf{凹多边形}$。你需要求出能形成的凹多边形的面积最大是多少。", "inputFormat": "第一行一个正整数 $T$ ($1\\le T \\le 10^4$)，表示数据组数。\n\n对于每组数据，第一行一个正整数 $n$ ($3\\le n \\le 10^5$)，表示点数。\n\n接下来 $n$ 行，每行两个整数 $x_i, y_i$ ($-10^9 \\le x_i,y_i \\le 10^9$)，表示各个点的坐标。保证所有点的坐标互不相同，且不存在三点共线。\n\n各个测试数据组的 $n$ 之和不超过 $2\\cdot 10^5$。", "outputFormat": "对于每组数据，如果不能形成面积严格大于 $0$ 的凹多边形，输出 $-1$；否则，输出一个正整数，表示形成的最大的凹多边形的面积的两倍。可以证明这个答案是一个正整数。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CCPC 2024 Harbin Site] Build a Computer", "background": "", "description": "A simple polygon is a closed curve in the Euclidean plane consisting of straight line segments meeting end-to-end. Two line segments meet at every endpoint, and there are no other points of intersection between the line segments.\n\nSimple polygons can be categorized into two types: convex and concave. A convex polygon is defined as a polygon where, for any two points inside it, all points on the line segment between these two points also lie inside the polygon, either within its interior or on its boundary. A simple polygon that is not convex is called a concave polygon. As shown in the figure below, the left one is a convex polygon, while the right one is a concave polygon.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/gs8lvekd.png)\n:::\n\nNow, given $n$ points such that all points are distinct and no three points are collinear, your task is to select some of these $n$ points (maybe all of them) and connect them in any order to form a $\\textbf{concave polygon}$ with a strictly positive area. You need to determine the maximum possible area of the concave polygon that can be formed.", "inputFormat": "The first line contains an integer $T$ ($1\\le T \\le 10^4$), indicating the number of test cases.\n\nFor each test case, the first line contains a positive integer $n$ ($3\\le n \\le 10^5$), indicating the number of points.\n\nThe next $n$ lines each contain two integers $x_i, y_i$ ($-10^9 \\le x_i,y_i \\le 10^9$), representing the coordinates of each point. It is guaranteed that all points are distinct, and no three points are collinear.\n\nThe sum of $n$ over all test cases does not exceed $2\\cdot 10^5$.", "outputFormat": "For each test case, if it is not possible to form a concave polygon with a strictly positive area, output $-1$; otherwise, output a positive integer representing twice the maximum area of the concave polygon that can be formed. It can be proven that this answer is always a positive integer.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCPC 2024 哈尔滨站] 凹包", "background": "", "description": "简单多边形是平面中由线段组成的闭合曲线，这些线段首尾相连，除了因连接共用的线段端点，任何两个线段都不能彼此相交。\n\n简单多边形可以分为两类：凸多边形和凹多边形。一个凸多边形是指：多边形中任意两点间的线段上的所有点都在多边形内，包括在内部或边界上。不是凸多边形的简单多边形就是凹多边形。如下图，左边是一个凸多边形，右边是一个凹多边形。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/gs8lvekd.png)\n:::\n\n现在，给定 $n$ 个点，满足所有点互不相同，且不存在三个点在同一条直线上。你的任务是选择这 $n$ 个点中的一些点（可以全选），并按照任意顺序依次连边，最后需要连成一个面积严格大于 $0$ 的 $\\textbf{凹多边形}$。你需要求出能形成的凹多边形的面积最大是多少。", "inputFormat": "第一行一个正整数 $T$ ($1\\le T \\le 10^4$)，表示数据组数。\n\n对于每组数据，第一行一个正整数 $n$ ($3\\le n \\le 10^5$)，表示点数。\n\n接下来 $n$ 行，每行两个整数 $x_i, y_i$ ($-10^9 \\le x_i,y_i \\le 10^9$)，表示各个点的坐标。保证所有点的坐标互不相同，且不存在三点共线。\n\n各个测试数据组的 $n$ 之和不超过 $2\\cdot 10^5$。", "outputFormat": "对于每组数据，如果不能形成面积严格大于 $0$ 的凹多边形，输出 $-1$；否则，输出一个正整数，表示形成的最大的凹多边形的面积的两倍。可以证明这个答案是一个正整数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14803", "type": "P", "difficulty": 2, "samples": [["1\n2\nS 2\nE 1", "3 S\nZ 2\nL\nZ 1"]], "limits": {"time": [1000, 1000, 1000], "memory": [1048576, 1048576, 1048576]}, "tags": ["模拟", "2024", "Special Judge", "CCPC", "哈尔滨"], "title": "[CCPC 2024 哈尔滨站] 在哈尔滨指路", "background": "", "description": "在指路的时候，一些地区的人更习惯按绝对方位指路，比如：「往南走到第二个路口，再往东走到第一个路口就到了。」然而由于哈尔滨城市路网规划十分复杂，很多街道并不是正方位朝向的，因此如果你按照绝对方位给长期生活在哈尔滨的人指路的话，他很可能因为不习惯找方位而弄不清你所指的位置。\n\n在哈尔滨，人们更习惯使用相对方位来指路，比如指引同样的位置，哈尔滨人会首先让你朝向南，并告诉你：「沿路捡直（直行）走到第二个路口，左拐，再捡直走到第一个路口就到了。」\n\n为了应对这种差异，你准备写一个程序，将按绝对方位的指路方式转化为哈尔滨人习惯的指路方式。当然，如果直接使用哈尔滨的地图的话就太复杂了，所以本题中你可以认为地图是一个无限大的网格形状。", "inputFormat": "第一行一个整数 $T$ ($1 \\le T \\le 10^4$)，表示测试数据组数。\n\n对于每组测试数据，第一行一个整数 $n$ ($1 \\le n \\le 10$)，表示指路指令的个数。\n\n接下来 $n$ 行，每行按照绝对位置描述一个指令，包含一个字符 $d$ ($d\\in\\{\\texttt{N}, \\texttt{S}, \\texttt{W}, \\texttt{E}\\}$) 和一个整数 $x$ ($1 \\le x \\le 10$)，表示「往 $d$ 方位走到第 $x$ 个路口」。其中 $\\texttt{N}$ 表示向北，$\\texttt{S}$ 表示向南，$\\texttt{W}$ 表示向西，$\\texttt{E}$ 表示向东。\n\n保证相邻两个指令中 $d$ 不相同且不相反（北与南互相相反，西与东互相相反）。", "outputFormat": "对于每组数据，第一行输出一个整数 $m$ ($1 \\le m \\le 20$) 和一个字符 $f$ ($f \\in \\{\\texttt{N}, \\texttt{S}, \\texttt{W}, \\texttt{E}\\}$)，分别表示按哈尔滨人习惯的指路方式的指令条数和初始面向的方位，方位的含义同输入中描述。\n\n接下来输出 $m$ 行，每行首先输出一个字符 $g \\in \\{\\texttt{Z}, \\texttt{L}, \\texttt{R}\\}$，其中 $\\texttt{Z}$ 表示直走，$\\texttt{L}$ 表示左转，$\\texttt{R}$ 表示右转。如果输出的字符为 $\\texttt{Z}$，此行还需输出一个整数 $y$ ($1 \\le y \\le 100$) 表示直走到第 $y$ 个路口。第一个输出的指令必须以 $\\texttt{Z}$ 开头，输出中相邻两个指令的字符 $g$ 不能相同，并且 $\\texttt{L}$ 指令和 $\\texttt{R}$ 指令不能相邻。\n\n本题中你无需最小化 $m$，如果有多种方案可以到达同一目的地，输出任意一个均可。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[CCPC 2024 Harbin Site] Giving Directions in Harbin", "background": "", "description": "In some regions, people are more accustomed to giving directions using cardinal directions, such as: go south to the second intersection, then head east to the first intersection. However, due to the complex road network planning in Harbin, many streets do not align perfectly with cardinal directions. Thus, if you provide directions using absolute directions to someone who has lived in Harbin for a long time, they may struggle to understand your intended route.\n\nIn Harbin, people are more accustomed to using relative directions to give guidance. For the same location, a Harbin resident might first instruct you to face south, and then say: walk straight along the road to the second intersection, then turn left, and then straight to the first intersection. \n\nTo address this difference, you decide to write a program that converts the direction-giving style using cardinal directions into the style preferred by Harbin residents. Of course, using a real map of Harbin would be too complicated, so in this problem, you can assume the map is an infinitely large grid.", "inputFormat": "The first line contains an integer $T$ ($1 \\le T \\le 10^4$), indicating the number of test cases.\n\nFor each test case, the first line contains an integer $n$ ($1 \\le n \\le 10$), indicating the number of direction instructions.\n\nThe next $n$ lines each describe an instruction in absolute position, consisting of a character $d$ ($d\\in\\{\\texttt{N}, \\texttt{S}, \\texttt{W}, \\texttt{E}\\}$) and an integer $x$ ($1 \\le x \\le 10$), indicating ``go to the $x$-th intersection in the $d$ direction.'' Here, $\\texttt{N}$ represents north, $\\texttt{S}$ represents south, $\\texttt{W}$ represents west, and $\\texttt{E}$ represents east.\n\nIt is guaranteed that two consecutive instructions will not have the same direction or opposite directions (north and south are opposite, as are west and east).", "outputFormat": "For each test case, the first line outputs an integer $m$ ($1 \\le m \\le 20$) and a character $f$ ($f \\in \\{\\texttt{N}, \\texttt{S}, \\texttt{W}, \\texttt{E}\\}$), representing the number of instructions in Harbin style and the initial facing direction, with the same meanings for directions as in the input. \n\nNext, output $m$ lines. Each line starts with a character $g \\in \\{\\texttt{Z}, \\texttt{L}, \\texttt{R}\\}$, where $\\texttt{Z}$ means to go straight, $\\texttt{L}$ means to turn left, and $\\texttt{R}$ means to turn right. If the character is $\\texttt{Z}$, the line must also include an integer $y$ ($1 \\le y \\le 100$), representing going straight to the $y$-th intersection. The first output instruction must start with $\\texttt{Z}$. Consecutive instructions cannot have the same character $g$, and $\\texttt{L}$ and $\\texttt{R}$ instructions cannot be adjacent.\n\nIn this problem, you do not need to minimize $m$. If there are multiple ways to reach the same destination, any valid solution is acceptable.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[CCPC 2024 哈尔滨站] 在哈尔滨指路", "background": "", "description": "在指路的时候，一些地区的人更习惯按绝对方位指路，比如：「往南走到第二个路口，再往东走到第一个路口就到了。」然而由于哈尔滨城市路网规划十分复杂，很多街道并不是正方位朝向的，因此如果你按照绝对方位给长期生活在哈尔滨的人指路的话，他很可能因为不习惯找方位而弄不清你所指的位置。\n\n在哈尔滨，人们更习惯使用相对方位来指路，比如指引同样的位置，哈尔滨人会首先让你朝向南，并告诉你：「沿路捡直（直行）走到第二个路口，左拐，再捡直走到第一个路口就到了。」\n\n为了应对这种差异，你准备写一个程序，将按绝对方位的指路方式转化为哈尔滨人习惯的指路方式。当然，如果直接使用哈尔滨的地图的话就太复杂了，所以本题中你可以认为地图是一个无限大的网格形状。", "inputFormat": "第一行一个整数 $T$ ($1 \\le T \\le 10^4$)，表示测试数据组数。\n\n对于每组测试数据，第一行一个整数 $n$ ($1 \\le n \\le 10$)，表示指路指令的个数。\n\n接下来 $n$ 行，每行按照绝对位置描述一个指令，包含一个字符 $d$ ($d\\in\\{\\texttt{N}, \\texttt{S}, \\texttt{W}, \\texttt{E}\\}$) 和一个整数 $x$ ($1 \\le x \\le 10$)，表示「往 $d$ 方位走到第 $x$ 个路口」。其中 $\\texttt{N}$ 表示向北，$\\texttt{S}$ 表示向南，$\\texttt{W}$ 表示向西，$\\texttt{E}$ 表示向东。\n\n保证相邻两个指令中 $d$ 不相同且不相反（北与南互相相反，西与东互相相反）。", "outputFormat": "对于每组数据，第一行输出一个整数 $m$ ($1 \\le m \\le 20$) 和一个字符 $f$ ($f \\in \\{\\texttt{N}, \\texttt{S}, \\texttt{W}, \\texttt{E}\\}$)，分别表示按哈尔滨人习惯的指路方式的指令条数和初始面向的方位，方位的含义同输入中描述。\n\n接下来输出 $m$ 行，每行首先输出一个字符 $g \\in \\{\\texttt{Z}, \\texttt{L}, \\texttt{R}\\}$，其中 $\\texttt{Z}$ 表示直走，$\\texttt{L}$ 表示左转，$\\texttt{R}$ 表示右转。如果输出的字符为 $\\texttt{Z}$，此行还需输出一个整数 $y$ ($1 \\le y \\le 100$) 表示直走到第 $y$ 个路口。第一个输出的指令必须以 $\\texttt{Z}$ 开头，输出中相邻两个指令的字符 $g$ 不能相同，并且 $\\texttt{L}$ 指令和 $\\texttt{R}$ 指令不能相邻。\n\n本题中你无需最小化 $m$，如果有多种方案可以到达同一目的地，输出任意一个均可。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14804", "type": "P", "difficulty": 7, "samples": [["5\nabcab\nacabc", "6"], ["6\nbabbaa\nbabaaa", "6"], ["2\nne\nfu", "0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "CCPC", "哈尔滨"], "title": "[CCPC 2024 哈尔滨站] 一个朴素的字符串问题", "background": "", "description": "有一个 $2$ 行 $n$ 列的字符表格，每个单元格内有一个小写字母。你可以选择任意一个位置作为起点，然后走若干步，每一步只能向右或向下，最后停在任意一个单元格中。将经过的单元格中的字符按顺序拼接在一起，可以形成一个字符串。\n\n定义一个字符串 $S$ 是双重串，当且仅当存在非空字符串 $T$ 满足 $S = TT$。如 $\\texttt{aa}$，$\\texttt{xyzxyz}$ 都是双重串，而 $\\texttt{a}$，$\\texttt{xyzyz}$ 不是双重串。\n\n对于给定的字符表格，请求出你可以获得的最长的双重串的长度。", "inputFormat": "第一行一个整数 $n$ ($1 \\le n \\le 2 \\times 10^5$)，表示字符表格的列数。\n\n接下来两行分别有两个长为 $n$ 且只包含小写英文字母的字符串，表示这个字符表格。", "outputFormat": "一行一个整数，表示你可以获得的最长双重串的长度。", "hint": "对于第一组样例，最长的双重串可以通过如下方式得到（方法不唯一）：\n\n$$\n\\begin{aligned}\n\\underline{\\texttt{abc}}\\texttt{ab}\\\\\n\\texttt{ac}\\underline{\\texttt{abc}}\n\\end{aligned}\n$$", "locale": "zh-CN", "translations": {"en": {"title": "[CCPC 2024 Harbin Site] A Simple String Problem", "background": "", "description": "You are given a character grid with $2$ rows and $n$ columns, where each cell contains a lowercase letter. You can start at any position in the grid and move several steps, with each step either to the right or downward, stopping at any cell. Concatenating the characters from the cells visited in order forms a string.\n\nA string $S$ is called a double string if and only if there exists a non-empty string $T$ such that $S = TT$. For example, $\\texttt{aa}$ and $\\texttt{xyzxyz}$ are double strings, while $\\texttt{a}$ and $\\texttt{xyzyz}$ are not.\n\nGiven the character grid, find the length of the longest double string you can obtain.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 2 \\times 10^5$), representing the number of columns in the character grid.\n\nThe next two lines contain two strings of length $n$ consisting only of lowercase English letters, representing the character grid.", "outputFormat": "Output a single integer, representing the length of the longest double string you can obtain.", "hint": "In the first example, the longest double string can be obtained as follows (not unique):\n\n$$\n\\begin{aligned}\n\\underline{\\texttt{abc}}\\texttt{ab}\\\\\n\\texttt{ac}\\underline{\\texttt{abc}}\n\\end{aligned}\n$$\n", "locale": "en"}, "zh-CN": {"title": "[CCPC 2024 哈尔滨站] 一个朴素的字符串问题", "background": "", "description": "有一个 $2$ 行 $n$ 列的字符表格，每个单元格内有一个小写字母。你可以选择任意一个位置作为起点，然后走若干步，每一步只能向右或向下，最后停在任意一个单元格中。将经过的单元格中的字符按顺序拼接在一起，可以形成一个字符串。\n\n定义一个字符串 $S$ 是双重串，当且仅当存在非空字符串 $T$ 满足 $S = TT$。如 $\\texttt{aa}$，$\\texttt{xyzxyz}$ 都是双重串，而 $\\texttt{a}$，$\\texttt{xyzyz}$ 不是双重串。\n\n对于给定的字符表格，请求出你可以获得的最长的双重串的长度。", "inputFormat": "第一行一个整数 $n$ ($1 \\le n \\le 2 \\times 10^5$)，表示字符表格的列数。\n\n接下来两行分别有两个长为 $n$ 且只包含小写英文字母的字符串，表示这个字符表格。", "outputFormat": "一行一个整数，表示你可以获得的最长双重串的长度。", "hint": "对于第一组样例，最长的双重串可以通过如下方式得到（方法不唯一）：\n\n$$\n\\begin{aligned}\n\\underline{\\texttt{abc}}\\texttt{ab}\\\\\n\\texttt{ac}\\underline{\\texttt{abc}}\n\\end{aligned}\n$$", "locale": "zh-CN"}}}
{"pid": "P14805", "type": "P", "difficulty": 6, "samples": [["2 3\n-4 -5\n1 2 3", "250000004"], ["3 3\n-4 -5 -6\n1 2 3", "500000006"], ["5 5\n-4 -5 -6 -10 -2\n1 2 3 2 4", "434986672"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2024", "CCPC", "哈尔滨"], "title": "[CCPC 2024 哈尔滨站] 弹珠赛跑", "background": "", "description": "弹珠赛跑是一种非常有趣的玩弹珠的方式，你今天也想尝试一下。\n\n$x$ 轴负半轴有 $n$ 个起跑点位，第 $i$ 个点位的坐标为 $x_i$。总共有 $m$ 个弹珠，其中 $m$ 是奇数，第 $i$ 个弹珠的移动速度为 $v_i$。在一场比赛中，每一个弹珠都会等概率地随机选择一个起跑点位，不同的弹珠可以选到相同的点位。比赛开始时，所有弹珠同时出发，向 $x$ 正半轴方向一直移动。令 $c_i$ 为第 $i$ 个弹珠选择的起跑点位编号，不难得出在时间为 $t$ 时第 $i$ 个弹珠的坐标为 $x_{c_i} + v_i \\cdot t$。\n\n你是个独特的弹珠爱好者，并不在乎哪个弹珠最快。你只想知道这 $m$ 个弹珠的所有坐标的**中位数**恰好在原点（即 $x = 0$）的时间点。一个长度为奇数 $m$ 的序列的中位数是从小到大排序后下标为 $\\frac{m+1}{2}$ 的数（下标从 $1$ 开始）。由于赛跑还没开始，弹珠的起跑点位还没有确定，所以你想知道这个答案的数学期望。为了避免实数误差，你只需要输出这个答案在 $10^9+7$ 模意义下的结果（详情见输出格式）。", "inputFormat": "第一行两个正整数 $n$ 和 $m$ ($1 \\le n, m \\le 500$，且 $m$ 为奇数)，表示起跑点位个数和弹珠的个数。\n\n第二行 $n$ 个整数 $x_1, x_2, \\ldots, x_n$ ($-10^9 \\le x_i < 0$)，表示每个起跑点位的坐标。保证所有 $x_i$ 互不相同。\n\n第三行 $m$ 个整数 $v_1, v_2, \\ldots, v_m$ ($1 \\le v_i \\le 10^9$)，表示每个弹珠的移动速度。", "outputFormat": "输出一行一个整数，表示答案的数学期望对 $10^9+7$ 取模后的结果。\n\n令 $M=10^9+7$。可以证明，答案能够表示为最简分数 $\\frac p q$，其中 $p$ 和 $q$ 是正整数且 $q \\not\\equiv 0\\pmod M$。则你需要输出 $p\\cdot q^{-1}\\pmod M$，$q^{-1}$ 表示 $q$ 在模 $M$ 意义下的乘法逆元。换句话说，输出满足 $0\\le x < M$ 且 $x\\cdot q\\equiv p\\pmod M$ 的整数 $x$。可以证明，符合条件的 $x$ 是唯一的。", "hint": "对于第一个样例，三个弹珠的速度分别为 $1, 2, 3$，考虑三个弹珠分别的初始坐标：\n- $-4, -4, -4$：$t=2$ 的时候，三个弹珠的坐标分别为 $-2, 0, 2$，中位数恰好在原点。\n- $-4, -4, -5$：$t=2$ 的时候，三个弹珠的坐标分别为 $-2, 0, 1$，中位数恰好在原点。\n- $-4, -5, -4$：$t=2.5$ 的时候，三个弹珠的坐标分别为 $-1.5, 0, 3.5$，中位数恰好在原点。\n- $(-4, -5, -5)$, $(-5, -4, -4)$, $(-5, -4, -5)$, $(-5, -5, -4)$, $(-5, -5, -5)$ 的时候同理，中位数恰好在原点的时间分别为 $t=2.5$, $t=2$, $t=2$, $t=2.5$, $t=2.5$。\n\n综上，期望时间为 $\\frac{2 + 2 + 2.5 + 2.5 + 2 + 2 + 2.5 + 2.5}{8} = \\frac{9}{4}$，因此你需要输出 $9 \\cdot 4^{-1} \\bmod (10^9+7) = 250000004$。", "locale": "zh-CN", "translations": {"en": {"title": "[CCPC 2024 Harbin Site] Marble Race", "background": "", "description": "Marble race is a fun way to play with marbles, and today you want to give it a try.\n\nThere are $n$ starting points on the negative half of the $x$-axis, with the $i$-th point located at $x_i$. There are $m$ marbles in total, where $m$ is an odd number, and the $i$-th marble has a speed of $v_i$. In a race, each marble randomly chooses a starting point with equal probability, and different marbles can choose the same starting point. Then, all the marbles start moving simultaneously towards the positive direction of the $x$-axis. Let $c_i$ be the starting point chosen by the $i$-th marble. At time $t$, the coordinate of the $i$-th marble is given by $x_{c_i} + v_i \\cdot t$.\n\nYou are a unique marble race enthusiast and do not care which marble is the fastest. Instead, you want to find out the exact time when the \\textbf{median} of all the $m$ marble coordinates reaches the origin (i.e., $x = 0$). The median of a sequence of length $m$ (where $m$ is odd) is defined as the element at the position $\\frac{m+1}{2}$ when sorted in ascending order (indexing starts from $1$). Since the race has not yet started and the starting points are not yet determined, you are interested in the expected value of this time. To avoid floating-point errors, you only need to output the result modulo $10^9+7$ (see the output format for details).", "inputFormat": "The first line contains two positive integers $n$ and $m$ ($1 \\le n, m \\le 500$, and $m$ is odd), representing the number of starting points and the number of marbles.\n\nThe second line contains $n$ integers $x_1, x_2, \\ldots, x_n$ ($-10^9 \\le x_i < 0$), representing the coordinates of each starting point. It is guaranteed that all $x_i$ are distinct.\n\nThe third line contains $m$ integers $v_1, v_2, \\ldots, v_m$ ($1 \\le v_i \\le 10^9$), representing the speed of each marble.", "outputFormat": "Output a single integer, representing the expected time modulo $10^9+7$.\n\nFormally, let $M=10^9+7$. It can be shown that the answer can be expressed as an irreducible fraction $\\frac p q$, where $p$ and $q$ are integers and $q \\not\\equiv 0\\pmod M$. Output the integer equal to $p\\cdot q^{-1}\\pmod M$, where $q^{-1}$ denotes the modular multiplicative inverse of $q$ modulo $M$. In other words, output such an integer $x$ that $0\\le x < M$ and $x\\cdot q\\equiv p\\pmod M$. It can be proved that there is exactly one $x$ which meets the condition.", "hint": "For the first example, the speeds of the three marbles are $1, 2, 3$, respectively. Consider the initial positions of the three marbles:\n\n- $-4, -4, -4$: At $t=2$, the coordinates of the three marbles are $-2, 0, 2$, and the median is at the origin.\n- $-4, -4, -5$: At $t=2$, the coordinates are $-2, 0, 1$, and the median is at the origin.\n- $-4, -5, -4$: At $t=2.5$, the coordinates are $-1.5, 0, 3.5$, and the median is at the origin.\n- For $(-4, -5, -5)$, $(-5, -4, -4)$, $(-5, -4, -5)$, $(-5, -5, -4)$, $(-5, -5, -5)$, the median is at the origin at times $t=2.5$, $t=2$, $t=2$, $t=2.5$, $t=2.5$, respectively.\n\nIn summary, the expected time is $\\frac{2 + 2 + 2.5 + 2.5 + 2 + 2 + 2.5 + 2.5}{8} = \\frac{9}{4}$, so you need to output $9 \\cdot 4^{-1} \\bmod (10^9+7) = 250000004$.", "locale": "en"}, "zh-CN": {"title": "[CCPC 2024 哈尔滨站] 弹珠赛跑", "background": "", "description": "弹珠赛跑是一种非常有趣的玩弹珠的方式，你今天也想尝试一下。\n\n$x$ 轴负半轴有 $n$ 个起跑点位，第 $i$ 个点位的坐标为 $x_i$。总共有 $m$ 个弹珠，其中 $m$ 是奇数，第 $i$ 个弹珠的移动速度为 $v_i$。在一场比赛中，每一个弹珠都会等概率地随机选择一个起跑点位，不同的弹珠可以选到相同的点位。比赛开始时，所有弹珠同时出发，向 $x$ 正半轴方向一直移动。令 $c_i$ 为第 $i$ 个弹珠选择的起跑点位编号，不难得出在时间为 $t$ 时第 $i$ 个弹珠的坐标为 $x_{c_i} + v_i \\cdot t$。\n\n你是个独特的弹珠爱好者，并不在乎哪个弹珠最快。你只想知道这 $m$ 个弹珠的所有坐标的**中位数**恰好在原点（即 $x = 0$）的时间点。一个长度为奇数 $m$ 的序列的中位数是从小到大排序后下标为 $\\frac{m+1}{2}$ 的数（下标从 $1$ 开始）。由于赛跑还没开始，弹珠的起跑点位还没有确定，所以你想知道这个答案的数学期望。为了避免实数误差，你只需要输出这个答案在 $10^9+7$ 模意义下的结果（详情见输出格式）。", "inputFormat": "第一行两个正整数 $n$ 和 $m$ ($1 \\le n, m \\le 500$，且 $m$ 为奇数)，表示起跑点位个数和弹珠的个数。\n\n第二行 $n$ 个整数 $x_1, x_2, \\ldots, x_n$ ($-10^9 \\le x_i < 0$)，表示每个起跑点位的坐标。保证所有 $x_i$ 互不相同。\n\n第三行 $m$ 个整数 $v_1, v_2, \\ldots, v_m$ ($1 \\le v_i \\le 10^9$)，表示每个弹珠的移动速度。", "outputFormat": "输出一行一个整数，表示答案的数学期望对 $10^9+7$ 取模后的结果。\n\n令 $M=10^9+7$。可以证明，答案能够表示为最简分数 $\\frac p q$，其中 $p$ 和 $q$ 是正整数且 $q \\not\\equiv 0\\pmod M$。则你需要输出 $p\\cdot q^{-1}\\pmod M$，$q^{-1}$ 表示 $q$ 在模 $M$ 意义下的乘法逆元。换句话说，输出满足 $0\\le x < M$ 且 $x\\cdot q\\equiv p\\pmod M$ 的整数 $x$。可以证明，符合条件的 $x$ 是唯一的。", "hint": "对于第一个样例，三个弹珠的速度分别为 $1, 2, 3$，考虑三个弹珠分别的初始坐标：\n- $-4, -4, -4$：$t=2$ 的时候，三个弹珠的坐标分别为 $-2, 0, 2$，中位数恰好在原点。\n- $-4, -4, -5$：$t=2$ 的时候，三个弹珠的坐标分别为 $-2, 0, 1$，中位数恰好在原点。\n- $-4, -5, -4$：$t=2.5$ 的时候，三个弹珠的坐标分别为 $-1.5, 0, 3.5$，中位数恰好在原点。\n- $(-4, -5, -5)$, $(-5, -4, -4)$, $(-5, -4, -5)$, $(-5, -5, -4)$, $(-5, -5, -5)$ 的时候同理，中位数恰好在原点的时间分别为 $t=2.5$, $t=2$, $t=2$, $t=2.5$, $t=2.5$。\n\n综上，期望时间为 $\\frac{2 + 2 + 2.5 + 2.5 + 2 + 2 + 2.5 + 2.5}{8} = \\frac{9}{4}$，因此你需要输出 $9 \\cdot 4^{-1} \\bmod (10^9+7) = 250000004$。", "locale": "zh-CN"}}}
