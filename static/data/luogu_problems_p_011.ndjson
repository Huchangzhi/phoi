{"pid": "P1221", "type": "P", "difficulty": 5, "samples": [["1000 2000", "Between 1000 and 2000, 1680 has a maximum of 40 divisors."]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索"], "title": "最多因子数", "background": "本题疑似错题。", "description": "数学家们喜欢各种类型的有奇怪特性的数。例如，他们认为 $945$ 是一个有趣的数，因为它是第一个所有约数之和大于本身的奇数。\n\n为了帮助他们寻找有趣的数，你将写一个程序扫描一定范围内的数，并确定在此范围内约数个数最多的那个数。不幸的是，这个数和给定的范围的都比较大，用简单的方法寻找可能需要较多的运行时间。所以请确定你的算法能在几秒内完成最大范围内的扫描。", "inputFormat": "只有一行，给出扫描的范围，由下界 $L$ 和上界 $U$ 确定。满足 $2\\le L\\le U\\le10^9$。", "outputFormat": "对于给定的范围，输出该范围内约数个数 $D$ 最多的数 $P$。若有多个，则输出最小的那个。请输出 $\\texttt{Between }L\\texttt{ and }U\\texttt{, }P\\texttt{ has a maximum of }D\\texttt{ divisors.}$，其中 $L,U,P,D$ 的含义同前面所述。", "hint": "update: 2024/6/6 加上了 6 组 hack。", "locale": "zh-CN", "translations": {"en": {"title": "Maximum Number of Divisors", "background": "This problem is suspected to be flawed.", "description": "Mathematicians like numbers with various strange properties. For example, they consider $945$ an interesting number because it is the first odd number whose sum of all divisors is greater than itself.\n\nTo help them find interesting numbers, you will write a program to scan numbers within a given range and determine the number in this range that has the most divisors. Unfortunately, both the number and the given range can be large, and using a simple approach may take a lot of time. So please ensure your algorithm can finish scanning the maximum range within a few seconds.", "inputFormat": "A single line giving the range to scan, specified by the lower bound $L$ and upper bound $U$, satisfying $2 \\le L \\le U \\le 10^9$.", "outputFormat": "For the given range, output the number $P$ in this range that has the maximum number of divisors $D$. If there are multiple, output the smallest one. Please output $\\texttt{Between }L\\texttt{ and }U\\texttt{, }P\\texttt{ has a maximum of }D\\texttt{ divisors.}$, where $L$, $U$, $P$, and $D$ have the meanings stated above.", "hint": "update: 2024/6/6 added 6 hack testcases.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最多因子数", "background": "本题疑似错题。", "description": "数学家们喜欢各种类型的有奇怪特性的数。例如，他们认为 $945$ 是一个有趣的数，因为它是第一个所有约数之和大于本身的奇数。\n\n为了帮助他们寻找有趣的数，你将写一个程序扫描一定范围内的数，并确定在此范围内约数个数最多的那个数。不幸的是，这个数和给定的范围的都比较大，用简单的方法寻找可能需要较多的运行时间。所以请确定你的算法能在几秒内完成最大范围内的扫描。", "inputFormat": "只有一行，给出扫描的范围，由下界 $L$ 和上界 $U$ 确定。满足 $2\\le L\\le U\\le10^9$。", "outputFormat": "对于给定的范围，输出该范围内约数个数 $D$ 最多的数 $P$。若有多个，则输出最小的那个。请输出 $\\texttt{Between }L\\texttt{ and }U\\texttt{, }P\\texttt{ has a maximum of }D\\texttt{ divisors.}$，其中 $L,U,P,D$ 的含义同前面所述。", "hint": "update: 2024/6/6 加上了 6 组 hack。", "locale": "zh-CN"}}}
{"pid": "P1222", "type": "P", "difficulty": 6, "samples": [["5\n-5 -3 6\n-1 -2 3\n0 0 2\n-2 2 1\n-4 -1 2\n", "24.5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何"], "title": "三角形", "background": "", "description": "给出平面上的 $n$ 个等腰直角三角形。每个三角形用三个整数 $x,y,m$ 描述。一个三角形的三个顶点分别是 $(x,y),(x+m,y),(x,y+m)$。\n\n你的任务是计算这些三角形覆盖的总面积。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行每行描述一个三角形，包括三个整数 $x_i,y_i,m_i$。", "outputFormat": "输出文件仅包含一个实数，精确到小数点后一位，表示总面积。\n", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5ti25vl7.png)\n\n数据范围：$1\\le n \\le 2000$，$1 \\le i \\le n$，$-10^7 \\le x_i,y_i \\le 10^7$，$1\\leq m_i \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Triangle", "background": "", "description": "Given $n$ isosceles right triangles on the plane. Each triangle is described by three integers $x, y, m$. The three vertices of a triangle are $(x, y)$, $(x + m, y)$, $(x, y + m)$.\n\nYour task is to compute the total area covered by these triangles.", "inputFormat": "The first line contains an integer $n$.\n\nEach of the next $n$ lines describes a triangle with three integers $x_i, y_i, m_i$.", "outputFormat": "Output a single real number with one digit after the decimal point, representing the total area.", "hint": "Sample explanation:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5ti25vl7.png)\n\nConstraints: $1 \\le n \\le 2000$, $1 \\le i \\le n$, $-10^7 \\le x_i, y_i \\le 10^7$, $1 \\leq m_i \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "三角形", "background": "", "description": "给出平面上的 $n$ 个等腰直角三角形。每个三角形用三个整数 $x,y,m$ 描述。一个三角形的三个顶点分别是 $(x,y),(x+m,y),(x,y+m)$。\n\n你的任务是计算这些三角形覆盖的总面积。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行每行描述一个三角形，包括三个整数 $x_i,y_i,m_i$。", "outputFormat": "输出文件仅包含一个实数，精确到小数点后一位，表示总面积。\n", "hint": "样例解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5ti25vl7.png)\n\n数据范围：$1\\le n \\le 2000$，$1 \\le i \\le n$，$-10^7 \\le x_i,y_i \\le 10^7$，$1\\leq m_i \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P1223", "type": "P", "difficulty": 2, "samples": [["10 \n56 12 1 99 1000 234 33 55 99 812", "3 2 7 8 1 4 9 6 10 5\n291.90\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "排序"], "title": "排队接水", "background": null, "description": "有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。\n\n一个人的等待时间不包括他的接水时间。\n\n如果两个人接水的时间相同，编号更小的人应当排在前面。", "inputFormat": "第一行为一个整数 $n$。\n\n第二行 $n$ 个整数，第 $i$ 个整数 $T_i$ 表示第 $i$ 个人的接水时间 $T_i$。", "outputFormat": "输出文件有两行，第一行为一种平均时间最短的排队顺序；第二行为这种排列方案下的平均等待时间（输出结果精确到小数点后两位）。", "hint": "$1\\le n \\leq 1000$，$1\\le t_i \\leq 10^6$，不保证 $t_i$ 不重复。", "locale": "zh-CN", "translations": {"en": {"title": "Queueing for Water", "background": "", "description": "There are $n$ people lining up at a faucet. Suppose the time each person needs to fill water is $T_i$. Please write a program to find an ordering of these $n$ people that minimizes the average waiting time of all $n$ people.\n\nA person's waiting time does not include their own filling time.\n\nIf two people have the same filling time, the one with the smaller index should be placed earlier.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n$ integers. The $i$-th integer $T_i$ denotes the $i$-th person's filling time $T_i$.", "outputFormat": "Output two lines. The first line is an ordering that yields the minimum average waiting time. The second line is the average waiting time under this ordering (rounded to two decimal places).", "hint": "Constraints: $1 \\le n \\leq 1000$, $1 \\le t_i \\leq 10^6$. The $t_i$ are not guaranteed to be distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "排队接水", "background": null, "description": "有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。\n\n一个人的等待时间不包括他的接水时间。\n\n如果两个人接水的时间相同，编号更小的人应当排在前面。", "inputFormat": "第一行为一个整数 $n$。\n\n第二行 $n$ 个整数，第 $i$ 个整数 $T_i$ 表示第 $i$ 个人的接水时间 $T_i$。", "outputFormat": "输出文件有两行，第一行为一种平均时间最短的排队顺序；第二行为这种排列方案下的平均等待时间（输出结果精确到小数点后两位）。", "hint": "$1\\le n \\leq 1000$，$1\\le t_i \\leq 10^6$，不保证 $t_i$ 不重复。", "locale": "zh-CN"}}}
{"pid": "P1224", "type": "P", "difficulty": 6, "samples": [["3 5 2 \n1 0 1 0 1 \n1 1 0 1 0 \n0 1 0 1 1\n", "2 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2013", "NOI", "Special Judge", "矩阵乘法", "向量"], "title": "[NOI2013] 向量内积", "background": "", "description": "两个 $d$ 维向量 $A=[a_1,a_2,\\ldots,a_d]$ 与 $B=[b_1,b_2,\\ldots,b_d]$ 的内积为其相对应维度的权值的乘积和，即：\n\n$$(A,B)=\\sum_{i=1}^d a_ib_i=a_1b_1+a_2b_2+\\ldots+a_db_d$$\n\n现有 $n$ 个 $d$ 维向量 $x_1,\\ldots,x_n$ ，小喵喵想知道是否存在两个向量的内积为 $k$ 的倍数。请帮助她解决这个问题。\n", "inputFormat": "第一行包含 $3$ 个正整数 $n,d,k$，分别表示向量的个数，维数以及待检测的倍数。\n\n接下来 $n$ 行每行有 $d$ 个非负整数，其中第 $i$ 行的第 $j$ 个整数表示向量 $x_i$ 的第 $j$ 维权值 $x_{i,j}$。\n", "outputFormat": "包含两个整数，用空格隔开。\n\n如果存在两个向量 $x_p,x_q$ 的内积为 $k$ 的整数倍，则输出两个向量的编号 $p$ 与 $q$（要求 $p<q$）。如果存在多组这样的向量组合，输出其中任意一组即可。\n\n若不存在这样的向量组合，则输出两个 $-1$。\n", "hint": "### 数据范围\n\n::cute-table{tuack}\n\n| 测试点编号 | $n$ | $d$ | $k$ | $x_{i,j}$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2$ | $20$ | $2$ | $\\leq 10$ |\n| $2$ | $5$ | ^ | ^ | ^ |\n| $3$ | $10$ | $20$ | $3$ | ^ |\n| $4$ | $20$ | $20$ | $2$ | $\\leq 100$ |\n| $5$ | $50$ | $20$ | $3$ | ^ |\n| $6$ | $50$ | $50$ | $2$ | $\\leq 10^3$ |\n| $7$ | $50$ | $50$ | $3$ | $\\leq 3\\times 10^6 $ |\n| $8$ | $80$ | $80$ | $2$ | $\\leq 2\\times 10^6 $ |\n| $9$ | $100$ | $100$ | $3$ | $\\leq 3\\times 10^6 $ |\n| $10$ | $500$ | ^ | ^ | ^ |\n| $11$ | $10^3$ | ^ | $2$ | $\\leq 2\\times 10^6$ |\n| $12$ | $10^3$ | ^ | $3$ | $\\leq 3\\times 10^6$ |\n| $13$ | $10^4$ | ^ | $2$ | $<10$ |\n| $14$ | $10^4$ | ^ | $3$ | ^ |\n| $15$ | $1.5\\times 10^4$ | ^ | $2$ | ^ |\n| $16$ | $1.8\\times 10^4$ | ^ | ^ | ^ |\n| $17$ | $2\\times 10^4$ | ^ | ^ | ^ |\n| $18$ | $5\\times 10^4$ | $30$ | $3$ | ^ |\n| $19$ | $8\\times 10^4$ | ^ | ^ | ^ |\n| $20$ | $10^5$ | ^ | ^ | ^ |", "locale": "zh-CN", "translations": {"en": {"title": "{{[NOI2013] Vector Inner Product}}", "background": "{{}}", "description": "{{The dot product of two $d$-dimensional vectors $A=[a_1,a_2,\\ldots,a_d]$ and $B=[b_1,b_2,\\ldots,b_d]$ is the sum of the products of their corresponding coordinates, i.e.:\n\n$$(A,B)=\\sum_{i=1}^d a_ib_i=a_1b_1+a_2b_2+\\ldots+a_db_d$$\n\nGiven $n$ $d$-dimensional vectors $x_1,\\ldots,x_n$, Xiao Miaomiao (pinyin) wants to know whether there exist two vectors whose dot product is a multiple of $k$. Please help her solve this problem.}}", "inputFormat": "{{The first line contains $3$ positive integers $n, d, k$, representing the number of vectors, the dimension, and the multiple to check, respectively.\n\nThe next $n$ lines each contain $d$ non-negative integers. In the $i$-th line, the $j$-th integer is the $j$-th coordinate value $x_{i,j}$ of vector $x_i$.}}", "outputFormat": "{{Output two integers separated by a space.\n\nIf there exist two vectors $x_p, x_q$ whose dot product is an integer multiple of $k$, output their indices $p$ and $q$ (require $p<q$). If there are multiple valid pairs, output any one of them.\n\nIf no such pair exists, output two $-1$.}}", "hint": "{{### Constraints\n\n| Test point ID | $n$ | $d$ | $k$ | $x_{i,j}$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2$ | $20$ | $2$ | $\\leq 10$ |\n| $2$ | $5$ | ^ | ^ | ^ |\n| $3$ | $10$ | $20$ | $3$ | ^ |\n| $4$ | $20$ | $20$ | $2$ | $\\leq 100$ |\n| $5$ | $50$ | $20$ | $3$ | ^ |\n| $6$ | $50$ | $50$ | $2$ | $\\leq 10^3$ |\n| $7$ | $50$ | $50$ | $3$ | $\\leq 3\\times 10^6 $ |\n| $8$ | $80$ | $80$ | $2$ | $\\leq 2\\times 10^6 $ |\n| $9$ | $100$ | $100$ | $3$ | $\\leq 3\\times 10^6 $ |\n| $10$ | $500$ | ^ | ^ | ^ |\n| $11$ | $10^3$ | ^ | $2$ | $\\leq 2\\times 10^6$ |\n| $12$ | $10^3$ | ^ | $3$ | $\\leq 3\\times 10^6$ |\n| $13$ | $10^4$ | ^ | $2$ | $<10$ |\n| $14$ | $10^4$ | ^ | $3$ | ^ |\n| $15$ | $1.5\\times 10^4$ | ^ | $2$ | ^ |\n| $16$ | $1.8\\times 10^4$ | ^ | ^ | ^ |\n| $17$ | $2\\times 10^4$ | ^ | ^ | ^ |\n| $18$ | $5\\times 10^4$ | $30$ | $3$ | ^ |\n| $19$ | $8\\times 10^4$ | ^ | ^ | ^ |\n| $20$ | $10^5$ | ^ | ^ | ^ |}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2013] 向量内积", "background": "", "description": "两个 $d$ 维向量 $A=[a_1,a_2,\\ldots,a_d]$ 与 $B=[b_1,b_2,\\ldots,b_d]$ 的内积为其相对应维度的权值的乘积和，即：\n\n$$(A,B)=\\sum_{i=1}^d a_ib_i=a_1b_1+a_2b_2+\\ldots+a_db_d$$\n\n现有 $n$ 个 $d$ 维向量 $x_1,\\ldots,x_n$ ，小喵喵想知道是否存在两个向量的内积为 $k$ 的倍数。请帮助她解决这个问题。\n", "inputFormat": "第一行包含 $3$ 个正整数 $n,d,k$，分别表示向量的个数，维数以及待检测的倍数。\n\n接下来 $n$ 行每行有 $d$ 个非负整数，其中第 $i$ 行的第 $j$ 个整数表示向量 $x_i$ 的第 $j$ 维权值 $x_{i,j}$。\n", "outputFormat": "包含两个整数，用空格隔开。\n\n如果存在两个向量 $x_p,x_q$ 的内积为 $k$ 的整数倍，则输出两个向量的编号 $p$ 与 $q$（要求 $p<q$）。如果存在多组这样的向量组合，输出其中任意一组即可。\n\n若不存在这样的向量组合，则输出两个 $-1$。\n", "hint": "### 数据范围\n\n::cute-table{tuack}\n\n| 测试点编号 | $n$ | $d$ | $k$ | $x_{i,j}$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $2$ | $20$ | $2$ | $\\leq 10$ |\n| $2$ | $5$ | ^ | ^ | ^ |\n| $3$ | $10$ | $20$ | $3$ | ^ |\n| $4$ | $20$ | $20$ | $2$ | $\\leq 100$ |\n| $5$ | $50$ | $20$ | $3$ | ^ |\n| $6$ | $50$ | $50$ | $2$ | $\\leq 10^3$ |\n| $7$ | $50$ | $50$ | $3$ | $\\leq 3\\times 10^6 $ |\n| $8$ | $80$ | $80$ | $2$ | $\\leq 2\\times 10^6 $ |\n| $9$ | $100$ | $100$ | $3$ | $\\leq 3\\times 10^6 $ |\n| $10$ | $500$ | ^ | ^ | ^ |\n| $11$ | $10^3$ | ^ | $2$ | $\\leq 2\\times 10^6$ |\n| $12$ | $10^3$ | ^ | $3$ | $\\leq 3\\times 10^6$ |\n| $13$ | $10^4$ | ^ | $2$ | $<10$ |\n| $14$ | $10^4$ | ^ | $3$ | ^ |\n| $15$ | $1.5\\times 10^4$ | ^ | $2$ | ^ |\n| $16$ | $1.8\\times 10^4$ | ^ | ^ | ^ |\n| $17$ | $2\\times 10^4$ | ^ | ^ | ^ |\n| $18$ | $5\\times 10^4$ | $30$ | $3$ | ^ |\n| $19$ | $8\\times 10^4$ | ^ | ^ | ^ |\n| $20$ | $10^5$ | ^ | ^ | ^ |", "locale": "zh-CN"}}}
{"pid": "P1225", "type": "P", "difficulty": 4, "samples": [["1111\n0000\n1110\n0010\n1010\n0101\n1010\n0101\n", "4\n1222\n1424\n3242\n4344\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "Special Judge"], "title": "黑白棋游戏", "background": "", "description": "黑白棋游戏的棋盘由 $4 \\times 4$ 方格阵列构成。棋盘的每一方格中放有 $1$ 枚棋子，共有 $8$ 枚白棋子和 $8$ 枚黑棋子。这 $16$ 枚棋子的每一种放置方案都构成一个游戏状态。在棋盘上拥有 $1$ 条公共边的 $2$ 个方格称为相邻方格。一个方格最多可有 $4$ 个相邻方格。在玩黑白棋游戏时，每一步可将任何 $2$ 个相邻方格中棋子互换位置。对于给定的初始游戏状态和目标游戏状态，编程计算从初始游戏状态变化到目标游戏状态的最短着棋序列。", "inputFormat": "输入文件共有 $8$ 行。前四行是初始游戏状态，后四行是目标游戏状态。每行 $4$ 个数分别表示该行放置的棋子颜色。“ $0$ ”表示白棋；“ $1$ ”表示黑棋。", "outputFormat": "输出文件的第一行是着棋步数 $n$。接下来 $n$ 行，每行 $4$ 个数分别表示该步交换棋子的两个相邻方格的位置。例如，abcd 表示将棋盘上 $(a,b)$ 处的棋子与 $(c,d)$ 处的棋子换位。", "hint": "由 @zhouyonglong 提供 SPJ\n", "locale": "zh-CN", "translations": {"en": {"title": "Black-and-White Chess Game", "background": "", "description": "The board of the black-and-white chess game consists of a $4 \\times 4$ grid. Each square contains $1$ piece, with $8$ white pieces and $8$ black pieces in total. Every arrangement of these $16$ pieces constitutes a game state. Two squares that share a common edge are called adjacent squares. A square can have at most $4$ adjacent squares. In each move, you may swap the pieces in any two adjacent squares. Given an initial game state and a target game state, write a program to compute the shortest sequence of moves that transforms the initial state into the target state.", "inputFormat": "The input consists of $8$ lines. The first $4$ lines describe the initial game state, and the last $4$ lines describe the target game state. Each line contains $4$ numbers indicating the colors of the pieces in that row. \"0\" denotes a white piece; \"1\" denotes a black piece.", "outputFormat": "Output the number of moves $n$ on the first line. Then output $n$ lines, each containing $4$ numbers that represent the positions of the two adjacent squares whose pieces are swapped in that move. For example, abcd denotes swapping the piece at $(a,b)$ with the piece at $(c,d)$.", "hint": "SPJ provided by @zhouyonglong.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "黑白棋游戏", "background": "", "description": "黑白棋游戏的棋盘由 $4 \\times 4$ 方格阵列构成。棋盘的每一方格中放有 $1$ 枚棋子，共有 $8$ 枚白棋子和 $8$ 枚黑棋子。这 $16$ 枚棋子的每一种放置方案都构成一个游戏状态。在棋盘上拥有 $1$ 条公共边的 $2$ 个方格称为相邻方格。一个方格最多可有 $4$ 个相邻方格。在玩黑白棋游戏时，每一步可将任何 $2$ 个相邻方格中棋子互换位置。对于给定的初始游戏状态和目标游戏状态，编程计算从初始游戏状态变化到目标游戏状态的最短着棋序列。", "inputFormat": "输入文件共有 $8$ 行。前四行是初始游戏状态，后四行是目标游戏状态。每行 $4$ 个数分别表示该行放置的棋子颜色。“ $0$ ”表示白棋；“ $1$ ”表示黑棋。", "outputFormat": "输出文件的第一行是着棋步数 $n$。接下来 $n$ 行，每行 $4$ 个数分别表示该步交换棋子的两个相邻方格的位置。例如，abcd 表示将棋盘上 $(a,b)$ 处的棋子与 $(c,d)$ 处的棋子换位。", "hint": "由 @zhouyonglong 提供 SPJ\n", "locale": "zh-CN"}}}
{"pid": "P1226", "type": "P", "difficulty": 2, "samples": [["2 10 9\n", "2^10 mod 9=7\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "递推", "递归", "模板题"], "title": "【模板】快速幂", "background": "", "description": "给你三个整数 $a,b,p$，求 $a^b \\bmod p$。", "inputFormat": "输入只有一行三个整数，分别代表 $a,b,p$。\n", "outputFormat": "输出一行一个字符串 `a^b mod p=s`，其中 $a,b,p$ 分别为题目给定的值， $s$ 为运算结果。", "hint": "**样例解释**\n\n$2^{10} = 1024$，$1024 \\bmod 9 = 7$。\n\n**数据规模与约定**\n\n对于 $100\\%$ 的数据，保证 $0\\le a,b < 2^{31}$，$a+b>0$，$2 \\leq p \\lt 2^{31}$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Fast Power", "background": "", "description": "Given three integers $a$, $b$, $p$, compute $a^b \\bmod p$.", "inputFormat": "The input contains a single line with three integers representing $a$, $b$, $p$.", "outputFormat": "Output one line with the string `a^b mod p=s`, where $a$, $b$, $p$ are the given values and $s$ is the result.", "hint": "Sample Explanation:\n\n$2^{10} = 1024$，$1024 \\bmod 9 = 7$.\n\nConstraints:\n\nFor $100\\%$ of the testdata, it is guaranteed that $0 \\leq a, b < 2^{31}$, $a + b > 0$, $2 \\leq p \\lt 2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】快速幂", "background": "", "description": "给你三个整数 $a,b,p$，求 $a^b \\bmod p$。", "inputFormat": "输入只有一行三个整数，分别代表 $a,b,p$。\n", "outputFormat": "输出一行一个字符串 `a^b mod p=s`，其中 $a,b,p$ 分别为题目给定的值， $s$ 为运算结果。", "hint": "**样例解释**\n\n$2^{10} = 1024$，$1024 \\bmod 9 = 7$。\n\n**数据规模与约定**\n\n对于 $100\\%$ 的数据，保证 $0\\le a,b < 2^{31}$，$a+b>0$，$2 \\leq p \\lt 2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P1227", "type": "P", "difficulty": 3, "samples": [["8\r\n1 10\r\n3 6\r\n6 8\r\n6 2\r\n3 -4\r\n1 0\r\n-2 -2\r\n-2 4\r\n", "V.I.P. should stay at (2.0,3.0)."]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "2008", "各省省选", "江苏", "排序"], "title": "[JSOI2008] 完美的对称", "background": "", "description": "在峰会期间，必须使用许多保镖保卫参加会议的各国代表。代表们除了由他自己的随身保镖保护外，组委会还指派了一些其他的特工和阻击手保护他们。为了使他们的工作卓有成效，使被保卫的人的安全尽可能得到保障，保镖被分配到被保护人的各个方向。\n\n保镖的最佳站立位置应该是这样的：被保护人应站在所有保镖的对称中心。但是，只要被保护人一移动，保镖就很难根据要人的新位置调整位置。大多数的特工都很难对此作出实时调整。\n\n因此，安全部长决定将该过程逆转一下，保镖先站好自己的位置，然后要人在他们的对称中心找到合适的位置。如果要人随便走动，我们就对他的安全不必负责。\n\n你的工作是使这个过程自动操作。给出一组 $N$ 个点（保镖的位置），你要找出它们的对称中心 $S$，在这儿被保护人将相对安全。下面以此类推。\n\n首先我们给定一点 $A$ 以及对称中心 $S$，点 $A'$ 是点 $A$ 以 $S$ 为对称中心形成的像点，即点 $S$ 是线段 $AA'$ 的对称中心。\n\n点阵组（$X$）以 $S$ 为中心的像点是由每个点的像点组成的点阵组。$X$ 是用来产生对称中心 $S$ 的，即点阵 $X$ 以 $S$ 为中心的像点的集合即为点阵 $X$ 本身。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/trym53o8.png)\n", "inputFormat": "输入文件第一行是一个整数 $N$，$1\\le N\\le 20000$，接下来的 $N$ 行每行包含用空格隔开的两个整数 $X_i$ 和 $Y_i$，$-10^5\\le X_i,Y_i\\le 10^5$，表示这组点阵中第 $i$ 个点的笛卡尔坐标值。\n\n\n因为任何两个保镖都不会站在同一个位置上，所以在给定的作业中，任何两点都不相同。但注意保镖可以站在被保护人相同的位置。\n", "outputFormat": "输出文件仅有一行。如果给定的点阵能产生一个对称中心，则输出 $\\texttt{V.I.P.  should  stay  at (}x\\texttt{,}y\\texttt{).}$，其中 $x$ 和 $y$ 代表中心的笛卡尔坐标值，格式为四舍五入保留至小数点后一位。\n\n\n如果该组点阵无对称中心，输出 `This is a dangerous situation!`，注意输出时除了两个单词之间用一个空格隔开外，不要输出多余空格。\n", "hint": "JSOI2008 第二轮。\n", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Perfect Symmetry", "background": "", "description": "During the summit, many bodyguards are needed to protect the representatives of various countries. Besides their own personal bodyguards, the organizing committee also assigns additional agents and snipers to protect them. To make their work effective and maximize the safety of the protected person, bodyguards are deployed in all directions around the VIP.\n\nThe optimal standing positions for the bodyguards should be such that the protected person stands at the center of symmetry of all bodyguards. However, once the VIP moves, it becomes hard for the bodyguards to adjust their positions according to the VIP’s new location. Most agents cannot make this adjustment in real time.\n\nTherefore, the Minister of Security decides to reverse the process: the bodyguards take their positions first, and then the VIP finds an appropriate position at their center of symmetry. If the VIP walks around freely, we are not responsible for his safety.\n\nYour task is to automate this process. Given a set of $N$ points (the bodyguards’ positions), find their center of symmetry $S$, where the VIP will be relatively safe. The definitions are as follows.\n\nFirst, given a point $A$ and a center of symmetry $S$, the point $A'$ is the image of $A$ with respect to $S$, i.e., $S$ is the midpoint of segment $AA'$.\n\nThe image of a point set $X$ with respect to $S$ is the point set consisting of the images of all its points. The set $X$ admits a center of symmetry $S$ if the image of $X$ with respect to $S$ equals $X$ itself.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/trym53o8.png)", "inputFormat": "The first line of input contains an integer $N$, $1\\le N\\le 20000$. Each of the next $N$ lines contains two integers $X_i$ and $Y_i$, $-10^5\\le X_i,Y_i\\le 10^5$, giving the Cartesian coordinates of the $i$-th point in the set.\n\nNo two bodyguards will stand at the same position, so any two points in the input are distinct. Note that a bodyguard may stand at the same position as the VIP.", "outputFormat": "Output exactly one line. If the given set admits a center of symmetry, print $\\texttt{V.I.P.  should  stay  at (}x\\texttt{,}y\\texttt{).}$, where $x$ and $y$ are the coordinates of the center, rounded to one decimal place.\n\nIf the set has no center of symmetry, output `This is a dangerous situation!`. Make sure there is exactly one space between words and no extra spaces.", "hint": "JSOI2008 Round 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] 完美的对称", "background": "", "description": "在峰会期间，必须使用许多保镖保卫参加会议的各国代表。代表们除了由他自己的随身保镖保护外，组委会还指派了一些其他的特工和阻击手保护他们。为了使他们的工作卓有成效，使被保卫的人的安全尽可能得到保障，保镖被分配到被保护人的各个方向。\n\n保镖的最佳站立位置应该是这样的：被保护人应站在所有保镖的对称中心。但是，只要被保护人一移动，保镖就很难根据要人的新位置调整位置。大多数的特工都很难对此作出实时调整。\n\n因此，安全部长决定将该过程逆转一下，保镖先站好自己的位置，然后要人在他们的对称中心找到合适的位置。如果要人随便走动，我们就对他的安全不必负责。\n\n你的工作是使这个过程自动操作。给出一组 $N$ 个点（保镖的位置），你要找出它们的对称中心 $S$，在这儿被保护人将相对安全。下面以此类推。\n\n首先我们给定一点 $A$ 以及对称中心 $S$，点 $A'$ 是点 $A$ 以 $S$ 为对称中心形成的像点，即点 $S$ 是线段 $AA'$ 的对称中心。\n\n点阵组（$X$）以 $S$ 为中心的像点是由每个点的像点组成的点阵组。$X$ 是用来产生对称中心 $S$ 的，即点阵 $X$ 以 $S$ 为中心的像点的集合即为点阵 $X$ 本身。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/trym53o8.png)\n", "inputFormat": "输入文件第一行是一个整数 $N$，$1\\le N\\le 20000$，接下来的 $N$ 行每行包含用空格隔开的两个整数 $X_i$ 和 $Y_i$，$-10^5\\le X_i,Y_i\\le 10^5$，表示这组点阵中第 $i$ 个点的笛卡尔坐标值。\n\n\n因为任何两个保镖都不会站在同一个位置上，所以在给定的作业中，任何两点都不相同。但注意保镖可以站在被保护人相同的位置。\n", "outputFormat": "输出文件仅有一行。如果给定的点阵能产生一个对称中心，则输出 $\\texttt{V.I.P.  should  stay  at (}x\\texttt{,}y\\texttt{).}$，其中 $x$ 和 $y$ 代表中心的笛卡尔坐标值，格式为四舍五入保留至小数点后一位。\n\n\n如果该组点阵无对称中心，输出 `This is a dangerous situation!`，注意输出时除了两个单词之间用一个空格隔开外，不要输出多余空格。\n", "hint": "JSOI2008 第二轮。\n", "locale": "zh-CN"}}}
{"pid": "P1228", "type": "P", "difficulty": 3, "samples": [["3                          \n3 3   ", "5 5 1\n2 2 4\n1 1 4\n1 4 3\n4 1 2\n4 4 1\n2 7 3\n1 5 4\n1 8 3\n3 6 3\n4 8 1\n7 2 2\n5 1 4\n6 3 2\n8 1 2\n8 4 1\n7 7 1\n6 6 1\n5 8 3\n8 5 2\n8 8 1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递归", "Special Judge", "分治"], "title": "地毯填补问题", "background": "", "description": "相传在一个古老的阿拉伯国家里，有一座宫殿。宫殿里有个四四方方的格子迷宫，国王选择驸马的方法非常特殊，也非常简单：公主就站在其中一个方格子上，只要谁能用地毯将除公主站立的地方外的所有地方盖上，美丽漂亮聪慧的公主就是他的人了。公主这一个方格不能用地毯盖住，毯子的形状有所规定，只能有四种选择（如图）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cik5fiow.png)\n\n并且每一方格只能用一层地毯，迷宫的大小为 $2^k\\times 2^k$ 的方形。当然，也不能让公主无限制的在那儿等，对吧？由于你使用的是计算机，所以实现时间为 $1$ 秒。\n", "inputFormat": "输入文件共 $2$ 行。\n\n第一行一个整数 $k$，即给定被填补迷宫的大小为 $2^k\\times 2^k$（$0\\lt k\\leq 10$）；\n第二行两个整数 $x,y$，即给出公主所在方格的坐标（$x$ 为行坐标，$y$ 为列坐标），$x$ 和 $y$ 之间有一个空格隔开。\n", "outputFormat": "将迷宫填补完整的方案：每一补（行）为 $x\\ y\\ c$（$x,y$ 为毯子拐角的行坐标和列坐标，$c$ 为使用毯子的形状，具体见上面的图 $1$，毯子形状分别用 $1,2,3,4$ 表示，$x,y,c$ 之间用一个空格隔开）。\n", "hint": "spj 报错代码解释：\n\n1. $c$ 越界；\n2. $x,y$ 越界；\n3. $(x,y)$ 位置已被覆盖；\n4. $(x,y)$ 位置从未被覆盖。\n\n$\\text{upd 2023.8.19}$：增加样例解释。\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r9j8r452.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "Carpet Tiling Problem", "background": "# Description\n\nIt is said that in an ancient Arabian country, there was a palace. Inside the palace, there was a square grid maze. The king’s method for choosing a prince consort was very special and simple: the princess stood on one grid cell, and whoever could cover every other cell with carpets, except the one where the princess stood, would win the beautiful, elegant, and intelligent princess. The princess’s cell must not be covered, and the carpet shape is restricted to four options only (see the figure):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cik5fiow.png)\n\nEach grid cell may be covered by at most one layer of carpet. The maze is a square of size $2^k\\times 2^k$. The time limit is $1$ second.", "description": "", "inputFormat": "", "outputFormat": "Output a complete tiling plan: each placement (one line) is $x\\ y\\ c$ ($x, y$ are the row and column of the carpet’s corner cell, and $c$ is the carpet’s shape; see Figure $1$ above. The four shapes are represented by $1, 2, 3, 4$. Separate $x, y, c$ with a single space).", "hint": "Explanation of SPJ error codes:\n\n1. $c$ is out of range.\n2. $x, y$ are out of range.\n3. The position $(x, y)$ has already been covered.\n4. The position $(x, y)$ was never covered.\n\n$\\text{upd 2023.8.19}$: Added sample explanation.\n\n### Sample Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r9j8r452.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "地毯填补问题", "background": "", "description": "相传在一个古老的阿拉伯国家里，有一座宫殿。宫殿里有个四四方方的格子迷宫，国王选择驸马的方法非常特殊，也非常简单：公主就站在其中一个方格子上，只要谁能用地毯将除公主站立的地方外的所有地方盖上，美丽漂亮聪慧的公主就是他的人了。公主这一个方格不能用地毯盖住，毯子的形状有所规定，只能有四种选择（如图）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cik5fiow.png)\n\n并且每一方格只能用一层地毯，迷宫的大小为 $2^k\\times 2^k$ 的方形。当然，也不能让公主无限制的在那儿等，对吧？由于你使用的是计算机，所以实现时间为 $1$ 秒。\n", "inputFormat": "输入文件共 $2$ 行。\n\n第一行一个整数 $k$，即给定被填补迷宫的大小为 $2^k\\times 2^k$（$0\\lt k\\leq 10$）；\n第二行两个整数 $x,y$，即给出公主所在方格的坐标（$x$ 为行坐标，$y$ 为列坐标），$x$ 和 $y$ 之间有一个空格隔开。\n", "outputFormat": "将迷宫填补完整的方案：每一补（行）为 $x\\ y\\ c$（$x,y$ 为毯子拐角的行坐标和列坐标，$c$ 为使用毯子的形状，具体见上面的图 $1$，毯子形状分别用 $1,2,3,4$ 表示，$x,y,c$ 之间用一个空格隔开）。\n", "hint": "spj 报错代码解释：\n\n1. $c$ 越界；\n2. $x,y$ 越界；\n3. $(x,y)$ 位置已被覆盖；\n4. $(x,y)$ 位置从未被覆盖。\n\n$\\text{upd 2023.8.19}$：增加样例解释。\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r9j8r452.png)\n", "locale": "zh-CN"}}}
{"pid": "P1229", "type": "P", "difficulty": 3, "samples": [["abc                           \ncba\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["树形数据结构"], "title": "遍历问题", "background": "", "description": "我们都很熟悉二叉树的前序、中序、后序遍历，在数据结构中常提出这样的问题：已知一棵二叉树的前序和中序遍历，求它的后序遍历，相应的，已知一棵二叉树的后序遍历和中序遍历序列你也能求出它的前序遍历。然而给定一棵二叉树的前序和后序遍历，你却不能确定其中序遍历序列，考虑如下图中的几棵二叉树：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w75s9yip.png)\n\n所有这些二叉树都有着相同的前序遍历和后序遍历，但中序遍历却不相同。\n\n", "inputFormat": "共两行，第一行表示该二叉树的前序遍历结果 $s_1$，第二行表示该二叉树的后序遍历结果 $s_2$。\n\n\n保证至少存在一棵二叉树满足给出的信息，$s _ 1, s _ 2$ 中只含小写字母，且在某个字符串中不存在相同的字母。", "outputFormat": "输出可能的中序遍历序列的总数，结果不超过 $2^{63}-1$。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Traversal Problem", "background": "", "description": "We are all familiar with preorder, inorder, and postorder traversals of binary trees. In data structures, a common problem is: given the preorder and inorder traversals of a binary tree, find its postorder traversal; similarly, given the postorder and inorder traversals, you can find its preorder traversal. However, given the preorder and postorder traversals of a binary tree, you cannot determine its inorder traversal. Consider the binary trees in the figure below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w75s9yip.png)\n\nAll these binary trees have the same preorder and postorder traversals, but different inorder traversals.", "inputFormat": "Two lines in total. The first line is the preorder traversal $s_1$ of the binary tree, and the second line is the postorder traversal $s_2$.\n\nIt is guaranteed that at least one binary tree satisfies the given information. $s_1, s_2$ contain only lowercase letters, and within each string no letter appears more than once.", "outputFormat": "Output the total number of possible inorder traversal sequences. The result does not exceed $2^{63}-1$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "遍历问题", "background": "", "description": "我们都很熟悉二叉树的前序、中序、后序遍历，在数据结构中常提出这样的问题：已知一棵二叉树的前序和中序遍历，求它的后序遍历，相应的，已知一棵二叉树的后序遍历和中序遍历序列你也能求出它的前序遍历。然而给定一棵二叉树的前序和后序遍历，你却不能确定其中序遍历序列，考虑如下图中的几棵二叉树：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/w75s9yip.png)\n\n所有这些二叉树都有着相同的前序遍历和后序遍历，但中序遍历却不相同。\n\n", "inputFormat": "共两行，第一行表示该二叉树的前序遍历结果 $s_1$，第二行表示该二叉树的后序遍历结果 $s_2$。\n\n\n保证至少存在一棵二叉树满足给出的信息，$s _ 1, s _ 2$ 中只含小写字母，且在某个字符串中不存在相同的字母。", "outputFormat": "输出可能的中序遍历序列的总数，结果不超过 $2^{63}-1$。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1230", "type": "P", "difficulty": 3, "samples": [["10000\n7\n4 2 4 3 1 4 6\n70 60 50 40 30 20 10\n", "9950"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "排序"], "title": "智力大冲浪", "background": "", "description": "小伟报名参加中央电视台的智力大冲浪节目。本次挑战赛吸引了众多参赛者，主持人为了表彰大家的勇气，先奖励每个参赛者 $m$ 元。先不要太高兴，因为这些钱还不一定都是你的。接下来主持人宣布了比赛规则：\n\n首先，比赛时间分为 $n$ 个时段，它又给出了很多小游戏，每个小游戏都必须在规定期限 $t_i$ 前完成。如果一个游戏没能在规定期限前完成，则要从奖励费 $m$ 元中扣去一部分钱 $w_i$，$w_i$ 为自然数，不同的游戏扣去的钱是不一样的。当然，每个游戏本身都很简单，保证每个参赛者都能在一个时段内完成，而且都必须从整时段开始。主持人只是想考考每个参赛者如何安排组织自己做游戏的顺序。作为参赛者，小伟很想赢得冠军，当然更想赢取最多的钱！注意：比赛绝对不会让参赛者赔钱!\n", "inputFormat": "第一行为 $m$，表示一开始奖励给每位参赛者的钱；\n\n第二行为 $n$，表示有 $n$ 个小游戏；\n\n第三行有 $n$ 个数，分别表示游戏 $1$ 到 $n$ 的规定完成期限；\n\n第四行有 $n$ 个数，分别表示游戏 $1$ 到 $n$ 不能在规定期限前完成的扣款数。", "outputFormat": "输出仅一行，表示小伟能赢取最多的钱。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 500$，$1 \\le m \\le 5 \\times 10^5$，$1 \\le t_i \\le n$，$1 \\le w_i \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Intellectual Surfing", "background": "", "description": "Xiaowei signed up for China Central Television (CCTV)'s “Intellectual Surfing” show. This challenge has attracted many contestants. To honor everyone’s courage, the host first awards each contestant $m$ yuan. Don’t celebrate too soon, because this money may not all be yours. Next, the host announces the rules:\n\nFirst, the contest time is divided into $n$ time slots, and the host also provides many mini-games. Each mini-game must be completed before its deadline $t_i$. If a game is not completed before its deadline, a penalty $w_i$ will be deducted from the $m$ yuan award. Here $w_i$ are natural numbers, and the deduction differs from game to game. Of course, every game itself is very simple: each contestant can finish any single game within one time slot, and each game must start at the beginning of a whole time slot. The host only wants to test how each contestant schedules the order of games. As a contestant, Xiaowei wants to win the championship and, of course, the most money! Note: The contest will never make contestants lose money.", "inputFormat": "- The first line contains $m$, the initial award for each contestant.\n- The second line contains $n$, the number of mini-games.\n- The third line contains $n$ numbers, the deadlines of games $1$ through $n$.\n- The fourth line contains $n$ numbers, the penalty amounts if games $1$ through $n$ are not completed before their deadlines.", "outputFormat": "Output a single line: the maximum amount of money Xiaowei can win.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le n \\le 500$, $1 \\le m \\le 5 \\times 10^5$, $1 \\le t_i \\le n$, $1 \\le w_i \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "智力大冲浪", "background": "", "description": "小伟报名参加中央电视台的智力大冲浪节目。本次挑战赛吸引了众多参赛者，主持人为了表彰大家的勇气，先奖励每个参赛者 $m$ 元。先不要太高兴，因为这些钱还不一定都是你的。接下来主持人宣布了比赛规则：\n\n首先，比赛时间分为 $n$ 个时段，它又给出了很多小游戏，每个小游戏都必须在规定期限 $t_i$ 前完成。如果一个游戏没能在规定期限前完成，则要从奖励费 $m$ 元中扣去一部分钱 $w_i$，$w_i$ 为自然数，不同的游戏扣去的钱是不一样的。当然，每个游戏本身都很简单，保证每个参赛者都能在一个时段内完成，而且都必须从整时段开始。主持人只是想考考每个参赛者如何安排组织自己做游戏的顺序。作为参赛者，小伟很想赢得冠军，当然更想赢取最多的钱！注意：比赛绝对不会让参赛者赔钱!\n", "inputFormat": "第一行为 $m$，表示一开始奖励给每位参赛者的钱；\n\n第二行为 $n$，表示有 $n$ 个小游戏；\n\n第三行有 $n$ 个数，分别表示游戏 $1$ 到 $n$ 的规定完成期限；\n\n第四行有 $n$ 个数，分别表示游戏 $1$ 到 $n$ 不能在规定期限前完成的扣款数。", "outputFormat": "输出仅一行，表示小伟能赢取最多的钱。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 500$，$1 \\le m \\le 5 \\times 10^5$，$1 \\le t_i \\le n$，$1 \\le w_i \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P1231", "type": "P", "difficulty": 6, "samples": [["5 3 4\n5\n4 3\n2 2\n5 2\n5 1\n5 3\n5\n1 3\n3 1\n2 2\n3 3\n4 3\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "网络流", "洛谷原创", "洛谷月赛"], "title": "教辅的组成", "background": "滚粗了的 HansBug 在收拾旧语文书，然而他发现了什么奇妙的东西。\n", "description": "蒟蒻 HansBug 在一本语文书里面发现了一本答案，然而他却明明记得这书应该还包含一份练习题。然而出现在他眼前的书多得数不胜数，其中有书，有答案，有练习册。已知一个完整的书册均应该包含且仅包含一本书、一本练习册和一份答案，然而现在全都乱做了一团。许多书上面的字迹都已经模糊了，然而 HansBug 还是可以大致判断这是一本书还是练习册或答案，并且能够大致知道一本书和答案以及一本书和练习册的对应关系（即仅仅知道某书和某答案、某书和某练习册有可能相对应，除此以外的均不可能对应）。既然如此，HansBug 想知道在这样的情况下，最多可能同时组合成多少个完整的书册。\n\n", "inputFormat": "第一行包含三个正整数 $N_1,N_2,N_3$，分别表示书的个数、练习册的个数和答案的个数。\n\n第二行包含一个正整数 $M_1$，表示书和练习册可能的对应关系个数。\n\n接下来 $M_1$ 行每行包含两个正整数 $x,y$，表示第 $x$ 本书和第 $y$ 本练习册可能对应。（$1\\leq x \\leq N_1$，$1 \\leq y \\leq N_2$）\n\n第 $M_{1}+3$ 行包含一个正整数 $M_2$，表述书和答案可能的对应关系个数。\n\n接下来 $M_2$ 行每行包含两个正整数 $x,y$，表示第 $x$ 本书和第 $y$ 本答案可能对应。（$1 \\leq x \\leq N_1$，$1 \\leq y \\leq N_3$）\n", "outputFormat": "输出包含一个正整数，表示最多可能组成完整书册的数目。\n", "hint": "样例说明：\n\n如题，$N_1=5$，$N_2=3$，$N_3=4$，表示书有 $5$ 本、练习册有 $3$ 本、答案有 $4$ 本。\n\n$M_1=5$，表示书和练习册共有 $5$ 个可能的对应关系，分别为：书 $4$ 和练习册 $3$ 、书 $2$ 和练习册 $2$ 、书 $5$ 和练习册 $2$ 、书 $5$ 和练习册 $1$ 以及书 $5$ 和练习册 $3$。\n\n$M_2=5$，表示数和答案共有 $5$ 个可能的对应关系，分别为：书 $1$ 和答案 $3$、书 $3$ 和答案 $1$、书 $2$ 和答案 $2$、书 $3$ 和答案 $3$ 以及书 $4$ 和答案 $3$。\n\n所以，以上情况的话最多可以同时配成两个书册，分别为：书 $2$ 练习册 $2$ 答案 $2$、书 $4$ 练习册 $3$ 答案 $3$。\n\n\n数据规模：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/srj2v9um.png)\n\n对于数据点 $1,2,3$，$1\\le M_1,M_2\\leq 20$。\n\n对于数据点 $4\\sim 10$，$1\\le M_1,M_2 \\leq 20000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Composition of Study Aids", "background": "HansBug, who had been kicked out, was tidying up old Chinese textbooks when he discovered something curious.", "description": "In a Chinese textbook, HansBug found an answer key, but he clearly remembered that the book should also come with a workbook. However, there are too many items in front of him to count, including books, answer keys, and workbooks. A complete set should contain and only contain one book, one workbook, and one answer key, but everything is in a mess now. Although many labels have faded, HansBug can still roughly tell whether an item is a book, a workbook, or an answer key. He also roughly knows the possible correspondences between a book and an answer key, and between a book and a workbook (that is, he only knows which book and which answer key, and which book and which workbook could possibly correspond; all other pairs are impossible). Given this information, HansBug wants to know the maximum number of complete sets that can be formed simultaneously.", "inputFormat": "The first line contains three positive integers $N_1,N_2,N_3$, representing the numbers of books, workbooks, and answer keys respectively.\n\nThe second line contains a positive integer $M_1$, representing the number of possible correspondences between books and workbooks.\n\nEach of the next $M_1$ lines contains two positive integers $x,y$, indicating that book $x$ and workbook $y$ could correspond. ($1\\leq x \\leq N_1$, $1 \\leq y \\leq N_2$)\n\nThe next line contains a positive integer $M_2$, representing the number of possible correspondences between books and answer keys.\n\nEach of the next $M_2$ lines contains two positive integers $x,y$, indicating that book $x$ and answer key $y$ could correspond. ($1 \\leq x \\leq N_1$, $1 \\leq y \\leq N_3$)", "outputFormat": "Output a single positive integer, the maximum possible number of complete sets.", "hint": "Sample explanation:\n\nAs described, $N_1=5$, $N_2=3$, $N_3=4$, meaning there are $5$ books, $3$ workbooks, and $4$ answer keys.\n\n$M_1=5$, meaning there are $5$ possible correspondences between books and workbooks, namely: book $4$ with workbook $3$, book $2$ with workbook $2$, book $5$ with workbook $2$, book $5$ with workbook $1$, and book $5$ with workbook $3$.\n\n$M_2=5$, meaning there are $5$ possible correspondences between books and answer keys, namely: book $1$ with answer key $3$, book $3$ with answer key $1$, book $2$ with answer key $2$, book $3$ with answer key $3$, and book $4$ with answer key $3$.\n\nTherefore, at most two complete sets can be formed simultaneously in this case, namely: book $2$ + workbook $2$ + answer key $2$, and book $4$ + workbook $3$ + answer key $3$.\n\nConstraints:\n\n- For testdata points $1,2,3$, $1\\le M_1,M_2\\leq 20$.\n- For testdata points $4\\sim 10$, $1\\le M_1,M_2 \\leq 20000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "教辅的组成", "background": "滚粗了的 HansBug 在收拾旧语文书，然而他发现了什么奇妙的东西。\n", "description": "蒟蒻 HansBug 在一本语文书里面发现了一本答案，然而他却明明记得这书应该还包含一份练习题。然而出现在他眼前的书多得数不胜数，其中有书，有答案，有练习册。已知一个完整的书册均应该包含且仅包含一本书、一本练习册和一份答案，然而现在全都乱做了一团。许多书上面的字迹都已经模糊了，然而 HansBug 还是可以大致判断这是一本书还是练习册或答案，并且能够大致知道一本书和答案以及一本书和练习册的对应关系（即仅仅知道某书和某答案、某书和某练习册有可能相对应，除此以外的均不可能对应）。既然如此，HansBug 想知道在这样的情况下，最多可能同时组合成多少个完整的书册。\n\n", "inputFormat": "第一行包含三个正整数 $N_1,N_2,N_3$，分别表示书的个数、练习册的个数和答案的个数。\n\n第二行包含一个正整数 $M_1$，表示书和练习册可能的对应关系个数。\n\n接下来 $M_1$ 行每行包含两个正整数 $x,y$，表示第 $x$ 本书和第 $y$ 本练习册可能对应。（$1\\leq x \\leq N_1$，$1 \\leq y \\leq N_2$）\n\n第 $M_{1}+3$ 行包含一个正整数 $M_2$，表述书和答案可能的对应关系个数。\n\n接下来 $M_2$ 行每行包含两个正整数 $x,y$，表示第 $x$ 本书和第 $y$ 本答案可能对应。（$1 \\leq x \\leq N_1$，$1 \\leq y \\leq N_3$）\n", "outputFormat": "输出包含一个正整数，表示最多可能组成完整书册的数目。\n", "hint": "样例说明：\n\n如题，$N_1=5$，$N_2=3$，$N_3=4$，表示书有 $5$ 本、练习册有 $3$ 本、答案有 $4$ 本。\n\n$M_1=5$，表示书和练习册共有 $5$ 个可能的对应关系，分别为：书 $4$ 和练习册 $3$ 、书 $2$ 和练习册 $2$ 、书 $5$ 和练习册 $2$ 、书 $5$ 和练习册 $1$ 以及书 $5$ 和练习册 $3$。\n\n$M_2=5$，表示数和答案共有 $5$ 个可能的对应关系，分别为：书 $1$ 和答案 $3$、书 $3$ 和答案 $1$、书 $2$ 和答案 $2$、书 $3$ 和答案 $3$ 以及书 $4$ 和答案 $3$。\n\n所以，以上情况的话最多可以同时配成两个书册，分别为：书 $2$ 练习册 $2$ 答案 $2$、书 $4$ 练习册 $3$ 答案 $3$。\n\n\n数据规模：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/srj2v9um.png)\n\n对于数据点 $1,2,3$，$1\\le M_1,M_2\\leq 20$。\n\n对于数据点 $4\\sim 10$，$1\\le M_1,M_2 \\leq 20000$。\n", "locale": "zh-CN"}}}
{"pid": "P1232", "type": "P", "difficulty": 6, "samples": [["5 \n1 2 4 5 3 \n1 2 3 4 5\n", "3.500\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2013", "NOI", "广度优先搜索 BFS", "深度优先搜索 DFS"], "title": "[NOI2013] 树的计数", "background": "", "description": "我们知道一棵有根树可以进行深度优先遍历（DFS）以及广度优先遍历（BFS）来生成这棵树的 DFS 序以及 BFS 序。两棵不同的树的 DFS 序有可能相同，并且它们的 BFS 序也有可能相同，例如下面两棵树的 DFS 序都是 `1 2 4 5 3`，BFS 序都是 `1 2 3 4 5`。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kagmha60.png)\n\n现给定一个 DFS 序和 BFS 序，我们想要知道，符合条件的有根树中，树的高度的平均值。即，假如共有 $K$ 棵不同的有根树具有这组 DFS 序和 BFS 序，且他们的高度分别是 $h_1, h_2, \\ldots, h_K$，那么请你输出：\n\n$$\n\\frac{h_1+h_2+\\ldots+h_K}K\n$$", "inputFormat": "第一行包含 $1$ 个正整数 $n$，表示树的节点个数。\n\n第二行包含 $n$ 个正整数，是一个 $1 \\ldots n$ 的排列，表示树的 DFS 序。\n\n第三行包含 $n$ 个正整数，是一个 $1 \\ldots n$ 的排列，表示树的 BFS 序。\n\n输入保证至少存在一棵树符合给定的两个序列。", "outputFormat": "输出 $1$ 个实数，四舍五入保留恰好三位小数，表示树高的平均值。", "hint": "如果输出文件的答案与标准输出的差不超过 $0.001$，则将获得该测试点上的分数，否则不得分。\n\n### 数据范围\n\n- 对于 $20\\%$ 的测试数据，满足：$n \\le 10$；\n- 对于 $40\\%$ 的测试数据，满足：$n \\le 100$；\n- 对于 $85\\%$ 的测试数据，满足：$n \\le 2 \\times 10^3$；\n- 对于 $100\\%$ 的测试数据，满足：$2 \\le n \\le 2 \\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2013] Counting Trees", "background": "", "description": "We know that a rooted tree can be traversed by depth-first search (DFS) and breadth-first search (BFS) to generate the DFS order and BFS order of the tree. Two different trees may have the same DFS order, and they may also have the same BFS order. For example, the two trees below both have DFS order `1 2 4 5 3` and BFS order `1 2 3 4 5`.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kagmha60.png)\n\nGiven a DFS order and a BFS order, we want to know the average height of all rooted trees that satisfy them. That is, suppose there are $K$ different rooted trees that have this pair of DFS and BFS orders, and their heights are $h_1, h_2, \\ldots, h_K$. Please output:\n\n$$\n\\frac{h_1+h_2+\\ldots+h_K}K\n$$", "inputFormat": "The first line contains $1$ positive integer $n$, the number of nodes of the tree.\n\nThe second line contains $n$ positive integers, a permutation of $\\,$ $1 \\ldots n$, representing the DFS order of the tree.\n\nThe third line contains $n$ positive integers, a permutation of $\\,$ $1 \\ldots n$, representing the BFS order of the tree.\n\nIt is guaranteed that there exists at least one tree consistent with the given two sequences.", "outputFormat": "Output $1$ real number, rounded to exactly three decimal places, representing the average tree height.", "hint": "If the absolute difference between your output and the standard answer does not exceed $0.001$, you will receive full credit for that test point; otherwise, you will receive no credit.\n\nConstraints\n- For $20\\%$ of the testdata: $n \\le 10$.\n- For $40\\%$ of the testdata: $n \\le 100$.\n- For $85\\%$ of the testdata: $n \\le 2 \\times 10^3$.\n- For $100\\%$ of the testdata: $2 \\le n \\le 2 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2013] 树的计数", "background": "", "description": "我们知道一棵有根树可以进行深度优先遍历（DFS）以及广度优先遍历（BFS）来生成这棵树的 DFS 序以及 BFS 序。两棵不同的树的 DFS 序有可能相同，并且它们的 BFS 序也有可能相同，例如下面两棵树的 DFS 序都是 `1 2 4 5 3`，BFS 序都是 `1 2 3 4 5`。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kagmha60.png)\n\n现给定一个 DFS 序和 BFS 序，我们想要知道，符合条件的有根树中，树的高度的平均值。即，假如共有 $K$ 棵不同的有根树具有这组 DFS 序和 BFS 序，且他们的高度分别是 $h_1, h_2, \\ldots, h_K$，那么请你输出：\n\n$$\n\\frac{h_1+h_2+\\ldots+h_K}K\n$$", "inputFormat": "第一行包含 $1$ 个正整数 $n$，表示树的节点个数。\n\n第二行包含 $n$ 个正整数，是一个 $1 \\ldots n$ 的排列，表示树的 DFS 序。\n\n第三行包含 $n$ 个正整数，是一个 $1 \\ldots n$ 的排列，表示树的 BFS 序。\n\n输入保证至少存在一棵树符合给定的两个序列。", "outputFormat": "输出 $1$ 个实数，四舍五入保留恰好三位小数，表示树高的平均值。", "hint": "如果输出文件的答案与标准输出的差不超过 $0.001$，则将获得该测试点上的分数，否则不得分。\n\n### 数据范围\n\n- 对于 $20\\%$ 的测试数据，满足：$n \\le 10$；\n- 对于 $40\\%$ 的测试数据，满足：$n \\le 100$；\n- 对于 $85\\%$ 的测试数据，满足：$n \\le 2 \\times 10^3$；\n- 对于 $100\\%$ 的测试数据，满足：$2 \\le n \\le 2 \\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P1233", "type": "P", "difficulty": 3, "samples": [["5\n4 9 5 2 2 1 3 5 1 4\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "贪心"], "title": "木棍加工", "background": "", "description": "一堆木头棍子共有 $n$ 根，每根棍子的长度和宽度都是已知的。棍子可以被一台机器一个接一个地加工。机器处理一根棍子之前需要准备时间。准备时间是这样定义的：\n\n- 第一根棍子的准备时间为 $1$ 分钟。\n- 如果刚处理完长度为 $l$，宽度为 $w$ 的棍子，那么如果下一个棍子长度为 $l_i$，宽度为 $w_i$，并且满足 $l\\ge l_i$、$w\\ge w_i$，这个棍子就不需要准备时间，否则需要 $1$ 分钟的准备时间。\n\n计算处理完 $n$ 根棍子所需要的最短准备时间。比如，你有 $5$ 根棍子，长度和宽度分别为 $(4,9),(5,2),(2,1),(3,5),(1,4)$，最短准备时间为 $2$（按 $(4,9),(3,5),(1,4),(5,2),(2,1)$ 的次序进行加工）。", "inputFormat": "第一行是一个整数 $n$（$n\\le5000$）。\n\n第二行是 $2n$ 个整数，分别是 $l_1,w_1,l_2,w_2,\\ldots,l_n,w_n$。$l$ 和 $w$ 的值均不超过 $10000$，相邻两数之间用空格分开。", "outputFormat": "仅一行，一个整数，所需要的最短准备时间。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 5000$，$1 \\le l_i, w_i \\le {10}^4$。", "locale": "zh-CN", "translations": {"en": {"title": "Stick Processing", "background": "", "description": "There are $n$ wooden sticks in total, and the length and width of each stick are known. The sticks can be processed by a machine one after another. Before processing a stick, the machine may need setup time. The setup time is defined as follows:\n\n- The setup time for the first stick is $1$ minute.\n- If the just-processed stick has length $l$ and width $w$, then for the next stick with length $l_i$ and width $w_i$, if $l \\ge l_i$ and $w \\ge w_i$, no setup time is needed; otherwise, $1$ minute of setup time is needed.\n\nCompute the minimum total setup time needed to process all $n$ sticks. For example, if you have $5$ sticks with lengths and widths $(4, 9), (5, 2), (2, 1), (3, 5), (1, 4)$, the minimum setup time is $2$ (process in the order $(4, 9), (3, 5), (1, 4), (5, 2), (2, 1)$).", "inputFormat": "The first line contains an integer $n$ ($n \\le 5000$).\n\nThe second line contains $2n$ integers: $l_1, w_1, l_2, w_2, \\ldots, l_n, w_n$. The values of $l$ and $w$ do not exceed $10000$, and adjacent numbers are separated by spaces.", "outputFormat": "A single line containing one integer: the minimum total setup time required.", "hint": "For $100 \\%$ of the testdata, $1 \\le n \\le 5000$, $1 \\le l_i, w_i \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "木棍加工", "background": "", "description": "一堆木头棍子共有 $n$ 根，每根棍子的长度和宽度都是已知的。棍子可以被一台机器一个接一个地加工。机器处理一根棍子之前需要准备时间。准备时间是这样定义的：\n\n- 第一根棍子的准备时间为 $1$ 分钟。\n- 如果刚处理完长度为 $l$，宽度为 $w$ 的棍子，那么如果下一个棍子长度为 $l_i$，宽度为 $w_i$，并且满足 $l\\ge l_i$、$w\\ge w_i$，这个棍子就不需要准备时间，否则需要 $1$ 分钟的准备时间。\n\n计算处理完 $n$ 根棍子所需要的最短准备时间。比如，你有 $5$ 根棍子，长度和宽度分别为 $(4,9),(5,2),(2,1),(3,5),(1,4)$，最短准备时间为 $2$（按 $(4,9),(3,5),(1,4),(5,2),(2,1)$ 的次序进行加工）。", "inputFormat": "第一行是一个整数 $n$（$n\\le5000$）。\n\n第二行是 $2n$ 个整数，分别是 $l_1,w_1,l_2,w_2,\\ldots,l_n,w_n$。$l$ 和 $w$ 的值均不超过 $10000$，相邻两数之间用空格分开。", "outputFormat": "仅一行，一个整数，所需要的最短准备时间。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 5000$，$1 \\le l_i, w_i \\le {10}^4$。", "locale": "zh-CN"}}}
{"pid": "P1234", "type": "P", "difficulty": 2, "samples": [["5 5\nheheh\nheheh\nheheh\nheheh\nheheh\n", "10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索"], "title": "小 A 的口头禅", "background": "", "description": "小 A 最近有了一个口头禅 “呵呵”，于是他给出了一个矩形，让你求出里面有几个 “$\\verb!hehe!$”（方向可以是向上、向下、向左、向右的直线）。\n", "inputFormat": "第一行两个数 $n, m$，表示这个矩形的大小。\n\n接下来 $n$ 行，每行 $m$ 个字符，表示这个矩形。\n", "outputFormat": "一行一个数，表示有几个 “$\\verb!hehe!$”。\n", "hint": "$1 \\leq n,m \\leq1000$。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "{{Xiao A's Catchphrase}}", "background": "{{}}", "description": "{{Xiao A recently picked up a catchphrase \"hehe\", so he gives a rectangle and asks you to count how many \"$\\verb!hehe!$\" there are inside (as straight lines in the upward, downward, leftward, or rightward directions).}}", "inputFormat": "{{The first line contains two numbers $n, m$, representing the size of the rectangle.\n\nThen follow $n$ lines, each with $m$ characters, representing the rectangle.}}", "outputFormat": "{{Output a single number on one line, representing how many \"$\\verb!hehe!$\" there are.}}", "hint": "{{$1 \\leq n, m \\leq 1000$.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小 A 的口头禅", "background": "", "description": "小 A 最近有了一个口头禅 “呵呵”，于是他给出了一个矩形，让你求出里面有几个 “$\\verb!hehe!$”（方向可以是向上、向下、向左、向右的直线）。\n", "inputFormat": "第一行两个数 $n, m$，表示这个矩形的大小。\n\n接下来 $n$ 行，每行 $m$ 个字符，表示这个矩形。\n", "outputFormat": "一行一个数，表示有几个 “$\\verb!hehe!$”。\n", "hint": "$1 \\leq n,m \\leq1000$。\n\n", "locale": "zh-CN"}}}
{"pid": "P1235", "type": "P", "difficulty": 6, "samples": [["7 4                                                    \r\n4 1 2                                          \r\n5 2 3                                          \r\n6 4 5                                          \r\n7 5 6\r\n4\r\n1 2\r\n2 6\r\n7 5\r\n3 3\r\n", "0%\r\n50%\r\n81.25%\r\n100%\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "高精度"], "title": "血缘关系", "background": "", "description": "我们正在研究妖怪家族的血缘关系。每个妖怪都有相同数量的基因，但是不同的妖怪的基因可能是不同的。我们希望知道任意给定的两个妖怪之间究竟有多少相同的基因。由于基因数量相当庞大，直接检测是行不通的。但是，我们知道妖怪家族的家谱，所以我们可以根据家谱来估算两个妖怪之间相同基因的数量。\n\n妖怪之间的基因继承关系相当简单：如果妖怪 $C$ 是妖怪 $A$ 和 $B$ 的孩子，则 $C$ 的任意一个基因只能是继承 $A$ 或 $B$ 的基因，继承 $A$ 或 $B$ 的概率各占 $50\\%$。所有基因可认为是相互独立的，每个基因的继承关系不受别的基因影响。\n\n现在，我们来定义两个妖怪 $X$ 和 $Y$ 的基因相似程度。例如，有一个家族，这个家族中有两个毫无关系（没有相同基因）的妖怪 $A$ 和 $B$，及它们的孩子 $C$ 和 $D$。那么 $C$ 和 $D$ 相似程度是多少呢？因为 $C$ 和 $D$ 的基因都来自 $A$ 和 $B$，从概率来说，各占 $50\\%$。所以，依概率计算 $C$ 和 $D$ 平均有 $50\\%$ 的相同基因，$C$ 和 $D$ 的基因相似程度为 $50\\%$。需要注意的是，如果 $A$ 和 $B$ 之间存在相同基因的话，$C$ 和 $D$ 的基因相似程度就不再是 $50\\%$ 了。\n\n你的任务是写一个程序，对于给定的家谱以及成对出现的妖怪，计算它们之间的基因相似程度。", "inputFormat": "第一行两个整数 $n\\ (2 \\le n \\le 300)$ 和 $k$。表示家族中成员数，它们分别用 $1,2,\\cdots,n$ 来表示。$k\\ (0 \\le k \\le n-2)$ 表示这个家族中有父母的妖怪数量（其他的妖怪没有父母，它们之间可以认为毫无关系，即没有任何相同基因）。\n\n接下来的 $k$ 行，每行三个整数 $a,b,c$，表示妖怪 $a$ 是妖怪 $b$ 的孩子。\n\n然后是一行一个整数 $m$（$1 \\le m \\le n_2$），表示需要计算基因相似程度的妖怪对数。\n\n接下来的 $m$ 行，每行两个整数，表示需要计算基因相似程度的两个妖怪。\n\n你可以认为这里给出的家谱总是合法的。具体来说就是，没有任何的妖怪会成为自己的祖先，并且你也不必担心会存在性别错乱问题。", "outputFormat": "共 $m$ 行。可 $k$ 行表示第 $k$ 对妖怪之间的基因相似程度。你必须按百分比输出，有多少精度就输出多少，而且必须准确，但不允许出现多余的 $0$（注意，$0.001$ 的情况应输出 $\\verb!0.1%!$，而不是 $\\verb!.1%!$）。具体格式参见样例。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Blood Relationship", "background": "", "description": "We are studying the blood relationships within a family of yaoguai (妖怪, yaoguai). Each yaoguai has the same number of genes, but the genes of different yaoguai may differ. We want to know how many genes are the same between any two given yaoguai. Since the number of genes is massive, direct testing is not feasible. However, we know the family tree, so we can estimate the number of shared genes between two yaoguai based on the family tree.\n\nThe inheritance of genes among yaoguai is quite simple: if yaoguai $C$ is the child of yaoguai $A$ and $B$, then any single gene of $C$ can only be inherited from either $A$ or $B$, with a $50\\%$ probability for each. All genes are considered independent, and the inheritance of any gene is not affected by other genes.\n\nNow, we define the gene similarity between two yaoguai $X$ and $Y$. For example, consider a family with two unrelated yaoguai $A$ and $B$ (no shared genes), and their children $C$ and $D$. What is the similarity between $C$ and $D$? Since the genes of $C$ and $D$ both come from $A$ and $B$, each with a probability of $50\\%$, in expectation $C$ and $D$ share $50\\%$ of their genes, so the gene similarity between $C$ and $D$ is $50\\%$. Note that if $A$ and $B$ have shared genes, then the similarity between $C$ and $D$ will no longer be $50\\%$.\n\nYour task is to write a program that, given the family tree and several pairs of yaoguai, computes their gene similarity.", "inputFormat": "The first line contains two integers $n\\ (2 \\le n \\le 300)$ and $k$. Here $n$ is the number of members in the family, labeled $1,2,\\cdots,n$. $k\\ (0 \\le k \\le n-2)$ is the number of yaoguai in this family who have parents (the remaining yaoguai have no parents given; they can be regarded as unrelated to each other, i.e., sharing no genes).\n\nThe next $k$ lines each contain three integers $a, b, c$, meaning yaoguai $a$ is the child of yaoguai $b$ and $c$.\n\nThen a line with one integer $m$ ($1 \\le m \\le n^2$), the number of yaoguai pairs for which the gene similarity is to be computed.\n\nThe next $m$ lines each contain two integers, representing a pair of yaoguai whose gene similarity should be computed.\n\nYou may assume the given family tree is always valid. Specifically, no yaoguai will be an ancestor of themself, and you do not need to worry about gender inconsistencies.", "outputFormat": "Output $m$ lines. The $i$-th line corresponds to the gene similarity of the $i$-th pair of yaoguai. You must output it as a percentage, with as much precision as there actually is, and it must be exact, but do not print extra trailing $0$s. Also, a leading zero before the decimal point is required (note that for $0.001$ you should output $\\verb!0.1%!$, not $\\verb!.1%!$). See the sample for the exact format.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "血缘关系", "background": "", "description": "我们正在研究妖怪家族的血缘关系。每个妖怪都有相同数量的基因，但是不同的妖怪的基因可能是不同的。我们希望知道任意给定的两个妖怪之间究竟有多少相同的基因。由于基因数量相当庞大，直接检测是行不通的。但是，我们知道妖怪家族的家谱，所以我们可以根据家谱来估算两个妖怪之间相同基因的数量。\n\n妖怪之间的基因继承关系相当简单：如果妖怪 $C$ 是妖怪 $A$ 和 $B$ 的孩子，则 $C$ 的任意一个基因只能是继承 $A$ 或 $B$ 的基因，继承 $A$ 或 $B$ 的概率各占 $50\\%$。所有基因可认为是相互独立的，每个基因的继承关系不受别的基因影响。\n\n现在，我们来定义两个妖怪 $X$ 和 $Y$ 的基因相似程度。例如，有一个家族，这个家族中有两个毫无关系（没有相同基因）的妖怪 $A$ 和 $B$，及它们的孩子 $C$ 和 $D$。那么 $C$ 和 $D$ 相似程度是多少呢？因为 $C$ 和 $D$ 的基因都来自 $A$ 和 $B$，从概率来说，各占 $50\\%$。所以，依概率计算 $C$ 和 $D$ 平均有 $50\\%$ 的相同基因，$C$ 和 $D$ 的基因相似程度为 $50\\%$。需要注意的是，如果 $A$ 和 $B$ 之间存在相同基因的话，$C$ 和 $D$ 的基因相似程度就不再是 $50\\%$ 了。\n\n你的任务是写一个程序，对于给定的家谱以及成对出现的妖怪，计算它们之间的基因相似程度。", "inputFormat": "第一行两个整数 $n\\ (2 \\le n \\le 300)$ 和 $k$。表示家族中成员数，它们分别用 $1,2,\\cdots,n$ 来表示。$k\\ (0 \\le k \\le n-2)$ 表示这个家族中有父母的妖怪数量（其他的妖怪没有父母，它们之间可以认为毫无关系，即没有任何相同基因）。\n\n接下来的 $k$ 行，每行三个整数 $a,b,c$，表示妖怪 $a$ 是妖怪 $b$ 的孩子。\n\n然后是一行一个整数 $m$（$1 \\le m \\le n_2$），表示需要计算基因相似程度的妖怪对数。\n\n接下来的 $m$ 行，每行两个整数，表示需要计算基因相似程度的两个妖怪。\n\n你可以认为这里给出的家谱总是合法的。具体来说就是，没有任何的妖怪会成为自己的祖先，并且你也不必担心会存在性别错乱问题。", "outputFormat": "共 $m$ 行。可 $k$ 行表示第 $k$ 对妖怪之间的基因相似程度。你必须按百分比输出，有多少精度就输出多少，而且必须准确，但不允许出现多余的 $0$（注意，$0.001$ 的情况应输出 $\\verb!0.1%!$，而不是 $\\verb!.1%!$）。具体格式参见样例。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1236", "type": "P", "difficulty": 4, "samples": [["1 2 3 7\n", "2+1=3\n7*3=21\n21+3=24\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "递归", "Special Judge", "枚举"], "title": "算24点", "background": null, "description": "几十年前全世界就流行一种数字游戏，至今仍有人乐此不疲．在中国我们把这种游戏称为“算 $24$ 点”。您作为游戏者将得到 $4$ 个 $1 \\sim 9$ 之间的自然数作为操作数，而您的任务是对这 $4$ 个操作数进行适当的算术运算，要求运算结果等于 $24$。\n\n您可以使用的运算只有：$\\verb!+!,\\verb!-!,\\verb!*!,\\verb!/!$，您还可以使用 $\\verb!()!$ 来改变运算顺序。注意：所有的中间结果须是整数，所以一些除法运算是不允许的（例如，$(2\\times 2)/4$ 是合法的，$2\\times (2/4)$ 是不合法的）。下面我们给出一个游戏的具体例子：\n\n若给出的 $4$ 个操作数是：$1$、$2$、$3$、$7$，则一种可能的解答是 $1+2+3\\times 7=24$。", "inputFormat": "只有一行，四个 $1$ 到 $9$ 之间的自然数。", "outputFormat": "如果有解的话，只要输出一个解。输出的是三行数据，分别表示运算的步骤。\n\n- 其中第一行是输入的两个数和一个运算符和运算后的结果；\n- 第二行是第一行的结果和一个输入的数据、运算符、运算后的结果，或者是另外两个数的输出结果；\n- 第三行是前面的结果第二行的结果或者剩下的一个数字、运算符和 $\\verb!=24!$。如果两个操作数有大小的话则先输出大的。\n\n如果没有解则输出 `No answer!`。\n\n如果有多重合法解，输出任意一种即可。\n\n注：所有运算结果均为正整数。", "hint": "感谢 chenyy 提供 special judge\n\n---\n\n$\\text{upd 2022.8.1}$：新增加一组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "24 Game", "background": "", "description": "Decades ago, a number game became popular worldwide and is still enjoyed today. In China, we call this game \"24 Game\". As a player, you are given 4 natural numbers between $1$ and $9$ as operands. Your task is to perform arithmetic operations on these 4 operands so that the result equals $24$.\n\nYou may use only the operations $\\verb!+!, \\verb!-!, \\verb!*!,$ and $\\verb!/!$. You may also use $\\verb!()!$ to change the order of operations. Note: all intermediate results must be integers, so some divisions are not allowed (for example, $(2\\times 2)/4$ is valid, while $2\\times (2/4)$ is invalid). Here is a concrete example of the game:\n\nIf the 4 operands are $1$, $2$, $3$, and $7$, then one possible answer is $1+2+3\\times 7=24$.", "inputFormat": "A single line containing four natural numbers between $1$ and $9$ (inclusive).", "outputFormat": "If a solution exists, output any one solution. The output consists of three lines, each describing one computation step.\n\n- The first line is two input numbers, an operator, and the result after the operation.\n- The second line is the result from the first line combined with one remaining input number, an operator, and the new result, or the result of applying an operator to the other two input numbers.\n- The third line combines the previous result, the second line’s result or the remaining number, an operator, and $\\verb!=24!$. If two operands are different, output the larger one first.\n\nIf there is no solution, output `No answer!`.\n\nIf multiple valid solutions exist, output any one of them.\n\nNote: all operation results must be positive integers.", "hint": "Thanks to chenyy for the special judge.\n\n---\n\n$\\text{upd 2022.8.1}$: Added a new set of hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "算24点", "background": null, "description": "几十年前全世界就流行一种数字游戏，至今仍有人乐此不疲．在中国我们把这种游戏称为“算 $24$ 点”。您作为游戏者将得到 $4$ 个 $1 \\sim 9$ 之间的自然数作为操作数，而您的任务是对这 $4$ 个操作数进行适当的算术运算，要求运算结果等于 $24$。\n\n您可以使用的运算只有：$\\verb!+!,\\verb!-!,\\verb!*!,\\verb!/!$，您还可以使用 $\\verb!()!$ 来改变运算顺序。注意：所有的中间结果须是整数，所以一些除法运算是不允许的（例如，$(2\\times 2)/4$ 是合法的，$2\\times (2/4)$ 是不合法的）。下面我们给出一个游戏的具体例子：\n\n若给出的 $4$ 个操作数是：$1$、$2$、$3$、$7$，则一种可能的解答是 $1+2+3\\times 7=24$。", "inputFormat": "只有一行，四个 $1$ 到 $9$ 之间的自然数。", "outputFormat": "如果有解的话，只要输出一个解。输出的是三行数据，分别表示运算的步骤。\n\n- 其中第一行是输入的两个数和一个运算符和运算后的结果；\n- 第二行是第一行的结果和一个输入的数据、运算符、运算后的结果，或者是另外两个数的输出结果；\n- 第三行是前面的结果第二行的结果或者剩下的一个数字、运算符和 $\\verb!=24!$。如果两个操作数有大小的话则先输出大的。\n\n如果没有解则输出 `No answer!`。\n\n如果有多重合法解，输出任意一种即可。\n\n注：所有运算结果均为正整数。", "hint": "感谢 chenyy 提供 special judge\n\n---\n\n$\\text{upd 2022.8.1}$：新增加一组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P1237", "type": "P", "difficulty": 5, "samples": [["3\nA->BD\nBD->C\nA->C\n", "FD 3 is redundant using FDs: 1 2\n"], ["6\nP->RST\nVRT->SQP\nPS->T\nQ->TR\nQS->P\nSR->V\n", "FD 3 is redundant using FDs: 1\nFD 5 is redundant using FDs: 4 6 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "数学"], "title": "冗余依赖", "background": "", "description": "在设计关系数据库的表格时，术语“函数依赖”（FD）被用来表示不同域之间的关系。函数依赖是描述一个集合中的域的值与另一个集合中的域的值之间的关系。记号 $X \\to Y$ 被用来表示当集合 $X$ 中的域被赋值后，集合 $Y$ 的域就可以确定相应的值。例如，一个数据表格包含“社会治安编号”（$S$）、“姓名”（$N$）、“地址”（$A$）、“电话”（$P$）的域，并且每个人都与某个特定的互不相同的 $S$ 值相对应，根据域 $S$ 就可以确定域 $N$ 、 $A$ 、 $P$ 的值。这就记作 $S \\to \\{N,A,P\\}$。\n\n写一个程序以找出一组依赖中所有的冗余依赖。一个依赖是冗余的是指它可以通过组里的其他依赖得到。例如，如果组里包括依赖 $A \\to B$ 、 $B \\to C$ 和 $A \\to C$，那么第三个依赖是冗余的，因为域 $C$ 可以用前两个依赖得到（域 $A$ 确定了域 $B$ 的值，同样域 $B$ 确定了域 $C$ 的值）。在 $A \\to B$ 、 $B \\to C$ 、 $C \\to A$ 、 $A \\to C$ 、 $C \\to B$ 和 $B \\to A$ 中，所有的依赖都是冗余的。\n\n现在要求你编写一个程序，从给定的依赖关系中找出冗余的。", "inputFormat": "第一行是一个不超过 $100$ 的整数 $n$，它表示文件中函数依赖的个数。\n\n从第二行起每一行是一个函数依赖且互不重复，每行包含用字符 $\\verb!-!$ 和 $\\verb!>!$ 隔开的非空域列表。列表月包含大写的字母，函数依赖的数据行中不包括空格和制表符，不会出现“平凡”冗余依赖（如 $A \\to A$）。虽然文件中没有对函数依赖编号，但其顺序就是编号 $1$ 到 $n$。", "outputFormat": "每一行输出一个冗余依赖，以及其他依赖的一个序列以说明该依赖是冗余的。格式为 $\\texttt{FD}\\ x\\ \\texttt{is redundant using FDs:}\\ p_1\\ p_2 \\cdots p_k$。其中 $x$ 是冗余的依赖的编号，$p_1,p_2,\\cdots,p_k$ 是用来证明 $x$ 是冗余依赖的依赖序列。\n\n如果许多函数依赖的序列都能被用来说明一个依赖是冗余的，则输出其中最短的证明序列。\n\n如果这些函数依赖中不包含冗余依赖，则输出 `No redundant FDs`。\n", "hint": "### 样例 1 解释\n\n依赖关系 $3$ 是冗余的。因为 $A\\to C$ 可以使用前两个依赖关系 $A\\to \\{B,D\\}$ 和 $\\{B, D\\}\\to C$ 得到。", "locale": "zh-CN", "translations": {"en": {"title": "Redundant Dependencies", "background": "", "description": "When designing tables in a relational database, the term \"functional dependency\" (FD) is used to describe relationships between attributes. A functional dependency describes the relationship between the values of attributes in one set and those in another set. The notation $X \\to Y$ is used to mean that once the attributes in set $X$ are assigned values, the attributes in set $Y$ are determined. For example, in a data table with attributes \"Social Security Number\" ($S$), \"Name\" ($N$), \"Address\" ($A$), and \"Phone\" ($P$), where each person has a unique value of $S$, the attributes $N$, $A$, and $P$ are determined by $S$. This is written as $S \\to \\{N, A, P\\}$.\n\nWrite a program to find all redundant dependencies in a set of dependencies. A dependency is redundant if it can be derived from the other dependencies in the set. For example, if the set includes $A \\to B$, $B \\to C$, and $A \\to C$, then the third dependency is redundant because $C$ can be derived from the first two dependencies ($A$ determines $B$, and $B$ determines $C$). Among $A \\to B$, $B \\to C$, $C \\to A$, $A \\to C$, $C \\to B$, and $B \\to A$, all dependencies are redundant.\n\nYou are required to write a program to identify the redundant dependencies from the given set.", "inputFormat": "The first line contains an integer $n$ not exceeding $100$, which is the number of functional dependencies in the file.\n\nFrom the second line onward, each line contains one functional dependency, and all dependencies are distinct. Each line consists of two non-empty attribute lists separated by the characters $\\verb!-!$ and $\\verb!>!$. Each list consists solely of uppercase letters. There are no spaces or tabs in any FD line. No trivial dependencies (such as $A \\to A$) will appear. Although the FDs are not explicitly numbered in the file, their order corresponds to indices $1$ through $n$.", "outputFormat": "Output each redundant dependency on its own line, along with a sequence of other dependencies that shows it is redundant. The format is $\\texttt{FD}\\ x\\ \\texttt{is redundant using FDs:}\\ p_1\\ p_2 \\cdots p_k$ where $x$ is the index of the redundant dependency, and $p_1, p_2, \\cdots, p_k$ is a sequence of dependency indices that proves $x$ is redundant.\n\nIf multiple sequences of functional dependencies can be used to show a dependency is redundant, output the shortest proof sequence.\n\nIf no redundant dependencies are present among the given FDs, output `No redundant FDs`.", "hint": "### Explanation for Sample 1\n\nDependency $3$ is redundant because $A \\to C$ can be derived from the first two dependencies $A \\to \\{B, D\\}$ and $\\{B, D\\} \\to C$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "冗余依赖", "background": "", "description": "在设计关系数据库的表格时，术语“函数依赖”（FD）被用来表示不同域之间的关系。函数依赖是描述一个集合中的域的值与另一个集合中的域的值之间的关系。记号 $X \\to Y$ 被用来表示当集合 $X$ 中的域被赋值后，集合 $Y$ 的域就可以确定相应的值。例如，一个数据表格包含“社会治安编号”（$S$）、“姓名”（$N$）、“地址”（$A$）、“电话”（$P$）的域，并且每个人都与某个特定的互不相同的 $S$ 值相对应，根据域 $S$ 就可以确定域 $N$ 、 $A$ 、 $P$ 的值。这就记作 $S \\to \\{N,A,P\\}$。\n\n写一个程序以找出一组依赖中所有的冗余依赖。一个依赖是冗余的是指它可以通过组里的其他依赖得到。例如，如果组里包括依赖 $A \\to B$ 、 $B \\to C$ 和 $A \\to C$，那么第三个依赖是冗余的，因为域 $C$ 可以用前两个依赖得到（域 $A$ 确定了域 $B$ 的值，同样域 $B$ 确定了域 $C$ 的值）。在 $A \\to B$ 、 $B \\to C$ 、 $C \\to A$ 、 $A \\to C$ 、 $C \\to B$ 和 $B \\to A$ 中，所有的依赖都是冗余的。\n\n现在要求你编写一个程序，从给定的依赖关系中找出冗余的。", "inputFormat": "第一行是一个不超过 $100$ 的整数 $n$，它表示文件中函数依赖的个数。\n\n从第二行起每一行是一个函数依赖且互不重复，每行包含用字符 $\\verb!-!$ 和 $\\verb!>!$ 隔开的非空域列表。列表月包含大写的字母，函数依赖的数据行中不包括空格和制表符，不会出现“平凡”冗余依赖（如 $A \\to A$）。虽然文件中没有对函数依赖编号，但其顺序就是编号 $1$ 到 $n$。", "outputFormat": "每一行输出一个冗余依赖，以及其他依赖的一个序列以说明该依赖是冗余的。格式为 $\\texttt{FD}\\ x\\ \\texttt{is redundant using FDs:}\\ p_1\\ p_2 \\cdots p_k$。其中 $x$ 是冗余的依赖的编号，$p_1,p_2,\\cdots,p_k$ 是用来证明 $x$ 是冗余依赖的依赖序列。\n\n如果许多函数依赖的序列都能被用来说明一个依赖是冗余的，则输出其中最短的证明序列。\n\n如果这些函数依赖中不包含冗余依赖，则输出 `No redundant FDs`。\n", "hint": "### 样例 1 解释\n\n依赖关系 $3$ 是冗余的。因为 $A\\to C$ 可以使用前两个依赖关系 $A\\to \\{B,D\\}$ 和 $\\{B, D\\}\\to C$ 得到。", "locale": "zh-CN"}}}
{"pid": "P1238", "type": "P", "difficulty": 3, "samples": [["5 6\n1 0 0 1 0 1\n1 1 1 1 1 1\n0 0 1 1 1 0\n1 1 1 1 1 0\n1 1 1 0 1 1\n1 1\n5 6", "(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)\n(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索"], "title": "走迷宫", "background": "", "description": "有一个 $m\\times n$ 格的迷宫(表示有 $m$ 行、$n$ 列)，其中有可走的也有不可走的，如果用 $1$ 表示可以走，$0$ 表示不可以走，文件读入这 $m\\times n$ 个数据和起始点、结束点（起始点和结束点都是用两个数据来描述的，分别表示这个点的行号和列号）。现在要你编程找出所有可行的道路，要求所走的路中没有重复的点，走时只能是上下左右四个方向。如果一条路都不可行，则输出相应信息（用 $-1$ 表示无路）。\n\n优先顺序：左上右下。**数据保证随机生成。**\n", "inputFormat": "第一行是两个数 $m,n(1<m,n<15)$，接下来是 $m$ 行 $n$ 列由 $1$ 和 $0$ 组成的数据，最后两行是起始点和结束点。\n", "outputFormat": "所有可行的路径，描述一个点时用 $(x,y)$ 的形式，除开始点外，其他的都要用 `->` 表示方向。\n\n如果没有一条可行的路则输出 $-1$。\n", "hint": "数据保证随机生成。事实上，如果 $n=m=14$ 且每个位置都是 $1$ 的话，有 $69450664761521361664274701548907358996488$ 种路径。", "locale": "zh-CN", "translations": {"en": {"title": "Maze Pathfinding", "background": "", "description": "There is an $m \\times n$ grid maze (meaning $m$ rows and $n$ columns), with some cells passable and others not. Use $1$ for passable and $0$ for impassable. The input provides these $m \\times n$ values and the start and end points (each point is described by two numbers: its row index and column index). Your task is to write a program to find all feasible paths such that no cell is visited more than once, and movement is allowed only in the four directions: up, down, left, and right. If no path is feasible, output the corresponding information ($-1$ means no path).\n\nPriority order: left, up, right, down. **The testdata are guaranteed to be randomly generated.**", "inputFormat": "The first line contains two integers $m, n$ ($1 < m, n < 15$). Then follow $m$ rows and $n$ columns of data consisting of $1$ and $0$. The last two lines are the start point and the end point.", "outputFormat": "Output all feasible paths. When describing a point, use the form $(x, y)$. Except for the starting point, connect consecutive points using `->` to indicate direction.\n\nIf there is no feasible path, output $-1$.", "hint": "The testdata are guaranteed to be randomly generated. In fact, if $n = m = 14$ and every cell is $1$, there are $69450664761521361664274701548907358996488$ paths.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "走迷宫", "background": "", "description": "有一个 $m\\times n$ 格的迷宫(表示有 $m$ 行、$n$ 列)，其中有可走的也有不可走的，如果用 $1$ 表示可以走，$0$ 表示不可以走，文件读入这 $m\\times n$ 个数据和起始点、结束点（起始点和结束点都是用两个数据来描述的，分别表示这个点的行号和列号）。现在要你编程找出所有可行的道路，要求所走的路中没有重复的点，走时只能是上下左右四个方向。如果一条路都不可行，则输出相应信息（用 $-1$ 表示无路）。\n\n优先顺序：左上右下。**数据保证随机生成。**\n", "inputFormat": "第一行是两个数 $m,n(1<m,n<15)$，接下来是 $m$ 行 $n$ 列由 $1$ 和 $0$ 组成的数据，最后两行是起始点和结束点。\n", "outputFormat": "所有可行的路径，描述一个点时用 $(x,y)$ 的形式，除开始点外，其他的都要用 `->` 表示方向。\n\n如果没有一条可行的路则输出 $-1$。\n", "hint": "数据保证随机生成。事实上，如果 $n=m=14$ 且每个位置都是 $1$ 的话，有 $69450664761521361664274701548907358996488$ 种路径。", "locale": "zh-CN"}}}
{"pid": "P1239", "type": "P", "difficulty": 4, "samples": [["11", "1\n4\n1\n1\n1\n1\n1\n1\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["递推"], "title": "计数器", "background": "", "description": "一本书的页数为 $n$，页码从 $1$ 开始编起，请你求出全部页码中，用了多少个 $0,1,2\\cdots 9$。每个页码不含前导 $0$，如 $n=1234$ 时第 $5$ 页不是 $0005$，只是 $5$。\n", "inputFormat": "一个正整数 $n$，表示总的页码。\n", "outputFormat": "输出共十行，其中第 $k$ 行为数字 $k-1$ 的个数。\n", "hint": "对于 $100\\%$ 数据，满足 $1\\le n\\le 10^9$。\n\n---\n\n$2022.7.4$：新添加三组 $\\text{Hack}$ 数据。", "locale": "zh-CN", "translations": {"en": {"title": "Counter", "background": "", "description": "A book has $n$ pages, with page numbers starting from $1$. Please find how many times each of the digits $0,1,2\\cdots 9$ appears in all page numbers. No page number has leading zeros; for example, when $n=1234$, page $5$ is not 0005, but just $5$.", "inputFormat": "A single positive integer $n$, the total number of pages.", "outputFormat": "Output ten lines in total, where the $k$-th line is the count of digit $k-1$.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 10^9$.\n\n---\n\n$2022.7.4$: Three new groups of $\\text{Hack}$ testdata were added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "计数器", "background": "", "description": "一本书的页数为 $n$，页码从 $1$ 开始编起，请你求出全部页码中，用了多少个 $0,1,2\\cdots 9$。每个页码不含前导 $0$，如 $n=1234$ 时第 $5$ 页不是 $0005$，只是 $5$。\n", "inputFormat": "一个正整数 $n$，表示总的页码。\n", "outputFormat": "输出共十行，其中第 $k$ 行为数字 $k-1$ 的个数。\n", "hint": "对于 $100\\%$ 数据，满足 $1\\le n\\le 10^9$。\n\n---\n\n$2022.7.4$：新添加三组 $\\text{Hack}$ 数据。", "locale": "zh-CN"}}}
{"pid": "P1240", "type": "P", "difficulty": 4, "samples": [["2 2\r\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推"], "title": "诸侯安置", "background": "", "description": "很久以前，有一个强大的帝国，它的国土成正方形状，如图所示。\n\n这个国家有若干诸侯。由于这些诸侯都曾立下赫赫战功，国王准备给他们每人一块封地（正方形中的一格）。但是，这些诸侯又非常好战，当两个诸侯位于同一行或同一列时，他们就会开战。如下图为 $n＝3$ 时的国土，阴影部分表示诸侯所处的位置。前两幅图中的诸侯可以互相攻击，第三幅则不可以。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7h9ptqlv.png)\n\n国王自然不愿意看到他的诸侯们互相开战，致使国家动荡不安。  因此，他希望通过合理的安排诸侯所处的位置，使他们两两之间都不能攻击。\n\n现在，给出正方形的边长 $n$，以及需要封地的诸侯数量 $k$，要求你求出所有可能的安置方案数。（满足 $n\\le100$，$k\\le2n^2-2n+1$）\n\n由于方案数可能很多，你只需要输出方案数除以 $504$ 的余数即可。\n", "inputFormat": "仅一行，两个整数 $n$ 和 $k$，中间用一空格隔开。\n", "outputFormat": "一个整数，表示方案数除以 $504$ 的余数。\n", "hint": "注意：镜面和旋转的情况属于不同的方案。", "locale": "zh-CN", "translations": {"en": {"title": "Placement of Feudal Lords", "background": "", "description": "A long time ago, there was a powerful empire whose territory was square-shaped, as shown in the figure.\n\nThe country has several feudal lords. Since these lords had made great contributions, the king planned to grant each of them a fief (one cell in the square grid). However, these lords are very warlike: if two lords are in the same row or the same column, they will go to war. The following figure shows the territory when $n=3$, where the shaded cells indicate the lords’ positions. In the first two figures, the lords can attack each other; in the third figure, they cannot.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7h9ptqlv.png)\n\nNaturally, the king does not want to see his lords fighting each other and causing unrest. Therefore, he hopes to arrange their positions so that no two lords can attack each other.\n\nNow, given the side length $n$ of the square and the number of lords $k$ to be placed, find the total number of valid arrangements. (You only need to output the remainder when the number of arrangements is divided by $504$.)\n\nConstraints: $n \\le 100$, $k \\le 2n^2 - 2n + 1$.", "inputFormat": "A single line containing two integers $n$ and $k$, separated by a space.", "outputFormat": "A single integer, the remainder when the number of valid arrangements is divided by $504$.", "hint": "Note: Mirror images and rotations are considered different solutions.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "诸侯安置", "background": "", "description": "很久以前，有一个强大的帝国，它的国土成正方形状，如图所示。\n\n这个国家有若干诸侯。由于这些诸侯都曾立下赫赫战功，国王准备给他们每人一块封地（正方形中的一格）。但是，这些诸侯又非常好战，当两个诸侯位于同一行或同一列时，他们就会开战。如下图为 $n＝3$ 时的国土，阴影部分表示诸侯所处的位置。前两幅图中的诸侯可以互相攻击，第三幅则不可以。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7h9ptqlv.png)\n\n国王自然不愿意看到他的诸侯们互相开战，致使国家动荡不安。  因此，他希望通过合理的安排诸侯所处的位置，使他们两两之间都不能攻击。\n\n现在，给出正方形的边长 $n$，以及需要封地的诸侯数量 $k$，要求你求出所有可能的安置方案数。（满足 $n\\le100$，$k\\le2n^2-2n+1$）\n\n由于方案数可能很多，你只需要输出方案数除以 $504$ 的余数即可。\n", "inputFormat": "仅一行，两个整数 $n$ 和 $k$，中间用一空格隔开。\n", "outputFormat": "一个整数，表示方案数除以 $504$ 的余数。\n", "hint": "注意：镜面和旋转的情况属于不同的方案。", "locale": "zh-CN"}}}
