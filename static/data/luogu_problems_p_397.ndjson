{"pid": "P9052", "type": "P", "difficulty": 7, "samples": [["9\n2 2 3\n1 1\n1 2\n1 5\n3 5 8 9\n1 5\n2 6 4\n2 5 9\n3 5 8 5", "0 1 4 4 5 6 7 7 7"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2021", "PA（波兰）"], "title": "[PA 2021] Areny", "background": null, "description": "Bajtek 在圣诞节收到了父母送的最新电脑游戏 Byte Defence 4。他兴致勃勃地打开游戏开始玩。游戏里操控的角色叫 Bajtonator，需要通过打怪、完成任务和升级装备来变强。地图上有 $n$ 个特殊的竞技场，里面有很稀有的掉落品。但有 $n$ 种通行证，想进某个竞技场必须持有对应的通行证。\n\n这个游戏的规则如下：\n\n1. 如果你有某个竞技场的通行证，就可以进入该竞技场与怪物战斗。进入竞技场不会消耗通行证，怪物会在你离开后复活，所以同一张通行证可以反复使用，反复挑战同一竞技场。\n2. 每个竞技场都有一个事先公开、固定不变的通行证池，池里的通行证不会被移出或改变。击败竞技场里的怪物后，除了可能掉落稀有物品外，还会从该竞技场的通行证池里随机抽取一张通行证，复制一份交给你。所以你可能在多次胜利后拥有相同类型的多张通行证副本。\n\n看了攻略后，Bajtek 得知竞技场编号越大越难。他的实力可以用一个整数 $k$ 来表示：他一定能在编号小于等于 $k$ 的竞技场获胜，而对编号大于 $k$ 的竞技场他一定无法获胜。\n\n开始时他没有任何通行证，只能花钱买**一张**。买哪一张最划算呢？\n\n他认为，如果买了竞技场 $A$ 的通行证，凭借这个起始通行证和之后的战斗所得通行证，**无论如何**他最终都能进入竞技场 $B$ 并获胜，那这张通行证就是值得买的。\n\n所以他想知道，对于某个固定的 $k$，有多少有序竞技场对 $(A,B)$ 满足：\n\n1. $A\\neq B$。\n2. 如果只买了竞技场 $A$ 的通行证，凭借这个起始通行证和之后的战斗所得通行证，无论如何他最终都能进入竞技场 $B$ 并获胜。\n\n你需要对于 $k=1,2,\\cdots,n$ 计算这样的有序对 $(A,B)$ 的个数。", "inputFormat": "第一行，一个整数 $n\\;(2\\le n\\le 2\\cdot 10^5)$，表示竞技场的数量。\n\n接下来 $n$ 行，其中第 $i$ 行先是一个整数 $l_i\\;(1\\le l_i)$，表示第 $i$ 个竞技场的通行证池大小。随后给出 $l_i$ 个整数，表示该池中每种通行证能进入的竞技场编号。所有 $l_i$ 的总和不超过 $5\\cdot10^5$。", "outputFormat": "一行，$n$ 个整数，其中第 $i$ 个整数表示 $k = i$ 时的答案。", "hint": null, "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Areny", "background": null, "description": "Bajtek 在圣诞节收到了父母送的最新电脑游戏 Byte Defence 4。他兴致勃勃地打开游戏开始玩。游戏里操控的角色叫 Bajtonator，需要通过打怪、完成任务和升级装备来变强。地图上有 $n$ 个特殊的竞技场，里面有很稀有的掉落品。但有 $n$ 种通行证，想进某个竞技场必须持有对应的通行证。\n\n这个游戏的规则如下：\n\n1. 如果你有某个竞技场的通行证，就可以进入该竞技场与怪物战斗。进入竞技场不会消耗通行证，怪物会在你离开后复活，所以同一张通行证可以反复使用，反复挑战同一竞技场。\n2. 每个竞技场都有一个事先公开、固定不变的通行证池，池里的通行证不会被移出或改变。击败竞技场里的怪物后，除了可能掉落稀有物品外，还会从该竞技场的通行证池里随机抽取一张通行证，复制一份交给你。所以你可能在多次胜利后拥有相同类型的多张通行证副本。\n\n看了攻略后，Bajtek 得知竞技场编号越大越难。他的实力可以用一个整数 $k$ 来表示：他一定能在编号小于等于 $k$ 的竞技场获胜，而对编号大于 $k$ 的竞技场他一定无法获胜。\n\n开始时他没有任何通行证，只能花钱买**一张**。买哪一张最划算呢？\n\n他认为，如果买了竞技场 $A$ 的通行证，凭借这个起始通行证和之后的战斗所得通行证，**无论如何**他最终都能进入竞技场 $B$ 并获胜，那这张通行证就是值得买的。\n\n所以他想知道，对于某个固定的 $k$，有多少有序竞技场对 $(A,B)$ 满足：\n\n1. $A\\neq B$。\n2. 如果只买了竞技场 $A$ 的通行证，凭借这个起始通行证和之后的战斗所得通行证，无论如何他最终都能进入竞技场 $B$ 并获胜。\n\n你需要对于 $k=1,2,\\cdots,n$ 计算这样的有序对 $(A,B)$ 的个数。", "inputFormat": "第一行，一个整数 $n\\;(2\\le n\\le 2\\cdot 10^5)$，表示竞技场的数量。\n\n接下来 $n$ 行，其中第 $i$ 行先是一个整数 $l_i\\;(1\\le l_i)$，表示第 $i$ 个竞技场的通行证池大小。随后给出 $l_i$ 个整数，表示该池中每种通行证能进入的竞技场编号。所有 $l_i$ 的总和不超过 $5\\cdot10^5$。", "outputFormat": "一行，$n$ 个整数，其中第 $i$ 个整数表示 $k = i$ 时的答案。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9053", "type": "P", "difficulty": 4, "samples": [["5\n1 4 3 5 2", "11 5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2021", "PA（波兰）"], "title": "[PA 2021] Ranking sklepów internetowych", "background": "", "description": "给定长为 $n$ 的**排列** $a$。\n\n定义区间 $[l, r]$ 的权值如下：将区间内的数从小到大排序，设 $x$ 为区间长度（即 $r - l + 1$），$y$ 为区间中位数，则该区间的权值为 $x + 2y$。\n\n求所有 $\\frac{n(n + 1)}{2}$ 个区间中权值的最大值和最大值的个数。\n\n------------\n\n中位数的定义：\n\n以一个长为 $n$ 的**单调递增**的序列 $a$ 为例。\n\n- 当 $n$ 为奇数，中位数为 $a_{\\frac{n + 1}{2}}$。\n- 当 $n$ 为偶数，中位数为 $\\frac{a_{\\frac{n}{2}} + a_{\\frac{n}{2} + 1}}{2}$。", "inputFormat": "第一行，一个整数 $n$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$。", "outputFormat": "一行，两个整数，表示权值的最大值和最大值的个数。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^6$，$1 \\leq a_i \\leq n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2021] Ranking sklepów internetowych", "background": "", "description": "给定长为 $n$ 的**排列** $a$。\n\n定义区间 $[l, r]$ 的权值如下：将区间内的数从小到大排序，设 $x$ 为区间长度（即 $r - l + 1$），$y$ 为区间中位数，则该区间的权值为 $x + 2y$。\n\n求所有 $\\frac{n(n + 1)}{2}$ 个区间中权值的最大值和最大值的个数。\n\n------------\n\n中位数的定义：\n\n以一个长为 $n$ 的**单调递增**的序列 $a$ 为例。\n\n- 当 $n$ 为奇数，中位数为 $a_{\\frac{n + 1}{2}}$。\n- 当 $n$ 为偶数，中位数为 $\\frac{a_{\\frac{n}{2}} + a_{\\frac{n}{2} + 1}}{2}$。", "inputFormat": "第一行，一个整数 $n$；\n\n第二行，$n$ 个整数 $a_1, a_2, \\cdots, a_n$。", "outputFormat": "一行，两个整数，表示权值的最大值和最大值的个数。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^6$，$1 \\leq a_i \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P9054", "type": "P", "difficulty": 7, "samples": [["9 11\n4\n2 2 1 1\n4\n2 2 2 2\n4\n2 1 1 2\n7\n5 5 4 4 4 5 5\n7\n1 3 2 2 2 2 4\n7\n3 3 2 4 4 5 3\n8\n2 2 3 5 3 3 3 4\n8\n5 4 4 4 4 6 6 5\n8\n4 4 4 2 4 4 2 3\n9\n4 7 5 5 5 5 3 4 4\n9\n3 4 4 4 4 4 4 4 6", "1 2 4 3\n2 1 4 3\n1 3 2 4\n3 1 7 2 6 4 5\n3 1 6 4 2 5 7\n2 3 1 6 4 7 5\n5 6 3 1 7 4 2 8\n1 8 2 7 3 5 6 4\n6 3 2 7 4 5 1 8\n5 8 6 3 7 1 9 2 4\n2 9 3 1 8 5 7 6 4"], ["5 1\n4\n2 2 1 1\n1011\n0111\n1011\n1001\n1010", "1 2 4 3"], ["6 1\n4\n2 2 1 1\n1011", "1 2 4 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["动态规划 DP", "贪心", "集训队互测", "2022", "Special Judge", "O2优化", "构造", "Ad-hoc", "分类讨论"], "title": "[集训队互测 2022] 心跳排列图", "background": "下发文件见附件。", "description": "注：本题中所有序列下标均从 1 开始。\n\n机器人心脏的跳动，排列成图是什么样的？\n\n你有一个算法竞赛机器人，每分钟心跳 $n$ 次，第 $i$ 次心跳的强度为 $a_i$。这里，$a_1\\sim a_n$ 恰为 $1\\sim n$ 的一个排列。\n\n设 $A_i$ 为序列 $a$ 删除第 $i$ 个元素后得到的序列，即 $A_i=[a_1,\\dots,a_{i-1},a_{i+1},\\dots,a_n]$。\n\n对于元素互不相同的序列 $p$，设 $G(p)$ 为一个无向图，有 $|p|$ 个点，编号为 $1\\sim |p|$。对于每对正整数 $1\\le i\\lt j\\le |p|$，若 $\\forall k\\in [i,j]\\cap \\mathbb{Z}$，都有 $p_k\\in [\\min(p_i,p_j),\\max(p_i,p_j)]$，则 $G(p)$ 中 $i$ 号点和 $j$ 号点有一条边。设 $F(p)$ 为 $G(p)$ 中 $1$ 号点到 $|p|$ 号点的最短路长度，这里一条路径长度定义为其边数。\n\n设 $f(a)=[F(A_1),F(A_2),\\dots,F(A_n)]$。\n\n给定长度为 $n$ 的序列 $[b_1,\\dots,b_n]$，请你求出任意一个 $1\\sim n$ 的排列 $a$，使得 $f(a)=b$。**保证有解。**\n\n在某些子任务中，算法竞赛机器人小 G 会给你一些“提示”：设 $G_0=G(a)$，设 $path_0$ 为 $G_0$ 中某条 $1$ 到 $n$ 的最短路经过的点构成的集合，设 $path_j$ 为 $G(A_j)$ 中某条起始点到结束点的最短路经过的点构成的集合（注意，为了方便，这里给出的 $path_j$ 中点的编号仍然沿用原图中点的编号，参见样例 2）。则小 G 有可能会额外告诉你所有 $path_j$（包括 $path_0$），也有可能只告诉你 $path_0$，也有可能不给你提示，详见输入格式。\n\n保证给出的提示是正确的，也即一定存在一个满足所有提示的排列。\n\n下发文件中有 `checker.cpp`，你可以用它来检查自己的输出是否正确。用法是 `./checker input output output`，`input` 和 `output` 分别为输入文件和你的输出。同时还下发了 `testlib.h`，请将其和 checker 置于同一目录下来编译 checker。", "inputFormat": "第一行两个正整数，为子任务编号 $S$ 以及数据组数 $T$。\n\n接下来 $T$ 组数据，每组数据格式为：第一行一个正整数 $n$，第二行 $n$ 个正整数 $b_1,\\dots,b_n$。\n\n**特别地，**\n\n1. 若 $S=5$，每组数据还会输入 $n+1$ 行，这 $n+1$ 行里第 $i$ 行是一个长度为 $n$ 的 01 串 $c_i$，$c_{i,j}=[j\\in path_{i-1}]$。\n2. 若 $S=6$，每组数据还会输入第三行，包含一个长度为 $n$ 的 01 串 $c$，$c_i=[i\\in path_0]$。\n\n注意：\n\n1. 即使你的程序不需要用到提示，在 $S=5$ 或 $S=6$ 时你仍然需要读入数组 $c$。\n2. 对于一种输入的 $b$，符合条件的 $a$ 可能不唯一，进而 $c$ 可能也不唯一。**不要求**你的输出符合我们给出的 $c$ 的限制，只要符合 $b$ 的限制即视为正确。\n\n同一行输入的不同变量用一个空格隔开。", "outputFormat": "对于每组数据输出一行 $n$ 个正整数，为你求出的排列 $a$。", "hint": "**样例 1 解释**\n\n考虑样例中的第一组数据。一组解是 $a=[1,2,4,3]$。$A_1,A_2,A_3,A_4$ 分别为 $[2,4,3],[1,4,3],[1,2,3],[1,2,4]$。$G(A_1),G(A_2),G(A_3),G(A_4)$ 四个图中的边分别为：\n\n- $G(A_1)$：$(1,2),(2,3)$。因此 $F(A_1)=2$。\n- $G(A_2)$：$(1,2),(2,3)$。因此 $F(A_2)=2$。\n- $G(A_3)$：$(1,2),(1,3),(2,3)$。因此 $F(A_3)=1$。\n- $G(A_4)$：$(1,2),(1,3),(2,3)$。因此 $F(A_4)=1$。\n\n所以 $f(a)=[2,2,1,1]$，符合输入。\n\n符合输入的 $a$ 不唯一，比如 $a=[4,3,1,2]$ 也是正确的。\n\n**样例 2 解释**\n\n该样例的排列和第一个样例中第一组数据是相同的，但本样例存在子任务 5 的提示。注意在给出 $path_j$ 时仍然沿用原编号，例如删去 $1$ 后，新的最短路经过的点编号为 $2\\to 3\\to 4$。\n\n**样例 3 解释**\n\n该样例的排列和第一个样例中第一组数据是相同的，但本样例存在子任务 6 的提示。\n\n**数据范围**\n\n对于所有数据：$1\\le T\\le 4\\times 10^4,4\\le n\\le 10^5,\\sum n\\le 5\\times 10^5$。\n\n- 子任务 1（$7$ 分）$T\\le 250,n\\le 7$。\n- 子任务 2（$5$ 分）$b_i=1$。\n- 子任务 3（$10$ 分）$n\\ge 90000$，保证存在一组解满足 $a_1=1,a_n=n$。\n- 子任务 4（$7$ 分）$n\\ge 90000$，保证存在一组解满足 $a_2=1,a_{n-1}=n$。\n- 子任务 5（$15$ 分）$n\\le 100,\\sum n^3\\le 3\\times 10^6$，存在所有 $path_j$ 的提示。\n- 子任务 6（$15$ 分）$n\\le 100,\\sum n^3\\le 3\\times 10^6$，存在 $path_0$ 的提示。\n- 子任务 7（$15$ 分）$n=100,T=3$，共 5 个测试点，输入生成方式是随机一个 $a$ 再求出 $f(a)$ 作为输入。\n- 子任务 8（$25$ 分）$n\\le 100,\\sum n^3\\le 3\\times 10^6$。\n- 子任务 9（$1$ 分）无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2022] 心跳排列图", "background": "下发文件见附件。", "description": "注：本题中所有序列下标均从 1 开始。\n\n机器人心脏的跳动，排列成图是什么样的？\n\n你有一个算法竞赛机器人，每分钟心跳 $n$ 次，第 $i$ 次心跳的强度为 $a_i$。这里，$a_1\\sim a_n$ 恰为 $1\\sim n$ 的一个排列。\n\n设 $A_i$ 为序列 $a$ 删除第 $i$ 个元素后得到的序列，即 $A_i=[a_1,\\dots,a_{i-1},a_{i+1},\\dots,a_n]$。\n\n对于元素互不相同的序列 $p$，设 $G(p)$ 为一个无向图，有 $|p|$ 个点，编号为 $1\\sim |p|$。对于每对正整数 $1\\le i\\lt j\\le |p|$，若 $\\forall k\\in [i,j]\\cap \\mathbb{Z}$，都有 $p_k\\in [\\min(p_i,p_j),\\max(p_i,p_j)]$，则 $G(p)$ 中 $i$ 号点和 $j$ 号点有一条边。设 $F(p)$ 为 $G(p)$ 中 $1$ 号点到 $|p|$ 号点的最短路长度，这里一条路径长度定义为其边数。\n\n设 $f(a)=[F(A_1),F(A_2),\\dots,F(A_n)]$。\n\n给定长度为 $n$ 的序列 $[b_1,\\dots,b_n]$，请你求出任意一个 $1\\sim n$ 的排列 $a$，使得 $f(a)=b$。**保证有解。**\n\n在某些子任务中，算法竞赛机器人小 G 会给你一些“提示”：设 $G_0=G(a)$，设 $path_0$ 为 $G_0$ 中某条 $1$ 到 $n$ 的最短路经过的点构成的集合，设 $path_j$ 为 $G(A_j)$ 中某条起始点到结束点的最短路经过的点构成的集合（注意，为了方便，这里给出的 $path_j$ 中点的编号仍然沿用原图中点的编号，参见样例 2）。则小 G 有可能会额外告诉你所有 $path_j$（包括 $path_0$），也有可能只告诉你 $path_0$，也有可能不给你提示，详见输入格式。\n\n保证给出的提示是正确的，也即一定存在一个满足所有提示的排列。\n\n下发文件中有 `checker.cpp`，你可以用它来检查自己的输出是否正确。用法是 `./checker input output output`，`input` 和 `output` 分别为输入文件和你的输出。同时还下发了 `testlib.h`，请将其和 checker 置于同一目录下来编译 checker。", "inputFormat": "第一行两个正整数，为子任务编号 $S$ 以及数据组数 $T$。\n\n接下来 $T$ 组数据，每组数据格式为：第一行一个正整数 $n$，第二行 $n$ 个正整数 $b_1,\\dots,b_n$。\n\n**特别地，**\n\n1. 若 $S=5$，每组数据还会输入 $n+1$ 行，这 $n+1$ 行里第 $i$ 行是一个长度为 $n$ 的 01 串 $c_i$，$c_{i,j}=[j\\in path_{i-1}]$。\n2. 若 $S=6$，每组数据还会输入第三行，包含一个长度为 $n$ 的 01 串 $c$，$c_i=[i\\in path_0]$。\n\n注意：\n\n1. 即使你的程序不需要用到提示，在 $S=5$ 或 $S=6$ 时你仍然需要读入数组 $c$。\n2. 对于一种输入的 $b$，符合条件的 $a$ 可能不唯一，进而 $c$ 可能也不唯一。**不要求**你的输出符合我们给出的 $c$ 的限制，只要符合 $b$ 的限制即视为正确。\n\n同一行输入的不同变量用一个空格隔开。", "outputFormat": "对于每组数据输出一行 $n$ 个正整数，为你求出的排列 $a$。", "hint": "**样例 1 解释**\n\n考虑样例中的第一组数据。一组解是 $a=[1,2,4,3]$。$A_1,A_2,A_3,A_4$ 分别为 $[2,4,3],[1,4,3],[1,2,3],[1,2,4]$。$G(A_1),G(A_2),G(A_3),G(A_4)$ 四个图中的边分别为：\n\n- $G(A_1)$：$(1,2),(2,3)$。因此 $F(A_1)=2$。\n- $G(A_2)$：$(1,2),(2,3)$。因此 $F(A_2)=2$。\n- $G(A_3)$：$(1,2),(1,3),(2,3)$。因此 $F(A_3)=1$。\n- $G(A_4)$：$(1,2),(1,3),(2,3)$。因此 $F(A_4)=1$。\n\n所以 $f(a)=[2,2,1,1]$，符合输入。\n\n符合输入的 $a$ 不唯一，比如 $a=[4,3,1,2]$ 也是正确的。\n\n**样例 2 解释**\n\n该样例的排列和第一个样例中第一组数据是相同的，但本样例存在子任务 5 的提示。注意在给出 $path_j$ 时仍然沿用原编号，例如删去 $1$ 后，新的最短路经过的点编号为 $2\\to 3\\to 4$。\n\n**样例 3 解释**\n\n该样例的排列和第一个样例中第一组数据是相同的，但本样例存在子任务 6 的提示。\n\n**数据范围**\n\n对于所有数据：$1\\le T\\le 4\\times 10^4,4\\le n\\le 10^5,\\sum n\\le 5\\times 10^5$。\n\n- 子任务 1（$7$ 分）$T\\le 250,n\\le 7$。\n- 子任务 2（$5$ 分）$b_i=1$。\n- 子任务 3（$10$ 分）$n\\ge 90000$，保证存在一组解满足 $a_1=1,a_n=n$。\n- 子任务 4（$7$ 分）$n\\ge 90000$，保证存在一组解满足 $a_2=1,a_{n-1}=n$。\n- 子任务 5（$15$ 分）$n\\le 100,\\sum n^3\\le 3\\times 10^6$，存在所有 $path_j$ 的提示。\n- 子任务 6（$15$ 分）$n\\le 100,\\sum n^3\\le 3\\times 10^6$，存在 $path_0$ 的提示。\n- 子任务 7（$15$ 分）$n=100,T=3$，共 5 个测试点，输入生成方式是随机一个 $a$ 再求出 $f(a)$ 作为输入。\n- 子任务 8（$25$ 分）$n\\le 100,\\sum n^3\\le 3\\times 10^6$。\n- 子任务 9（$1$ 分）无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P9055", "type": "P", "difficulty": 6, "samples": [["2 0 1 2\n10", "3034"], ["14 1 14 13\n10110101110101", "379883349"]], "limits": {"time": [600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "集训队互测", "2021", "O2优化", "组合数学", "构造", "分类讨论"], "title": "[集训队互测 2021] 数列重排", "background": "dottle bot。", "description": "定义一个数列区间的 $\\textrm{mex}$ 为区间中最小的没有出现过的自然数，定义一个数列的价值为其中 $\\textrm{mex}\\geq k$ 的区间数量。\n\n给定 $n$ 个小于 $m$ 的自然数和一个区间 $[l,r]$，令 $f(k)$ 表示 $n$ 个数构成的数列所有重排列中数列价值的最大值，对于每一个 $k\\in [l,r]$，求出 $f(k)$。\n\n令 $a_i$ 表示数字 $i$ 出现的次数，保证存在正整数 $X$，使得  $\\forall i\\le m-1,a_i\\in \\{X,X+1\\}$。", "inputFormat": "由于 $n$ 可能很大，将采取如下方式减少读入量：\n\n第一行四个整数 $m,l,r,X$。\n\n第二行一个长度为 $m$ 的 $01$ 串，若其中第 $i$ 个位置为 $1$ 则数字 $i-1$ 的出现次数为 $X+1$，否则出现次数为 $X$。\n\n根据输入可以推出 $n=mX+S$，其中 $S$ 为 $01$ 串中 $1$ 的数量。", "outputFormat": "为了减少输出量，令 $ans=\\displaystyle{\\bigoplus_{i=l}^r}  (233^if(i)\\bmod 998244353)$，其中 $\\displaystyle\\bigoplus$ 表示二进制下的按位异或，输出一行一个整数 $ans$。", "hint": "#### 样例 1 解释\n\n在样例给出的数列中，有 $3$ 个 $0$ 和 $2$ 个 $1$，任意排列 $f(0)$ 均为 $15$，排列为 $\\textrm{01010}$ 时 $f(1)$ 有最大值 $13$，答案为：\n$$\n\\displaystyle (233^0\\times 15\\bmod 998244353)\\oplus(233^1\\times 13\\bmod 998244353)=3034\n$$\n\n#### 数据范围\n\n- Subtask 1（5 points）：$n,m\\leq 9$。\n- Subtask 2（15 points）：$n,m\\leq 200$。\n- Subtask 3（15 points）：$n,m\\leq 5\\times 10^3$。\n- Subtask 4（5 points）：$m\\leq 2$，$l=0$，$r=1$。\n- Subtask 5（10 points）：$m\\leq 10^6$，$l=m$，$r=m$。 \n- Subtask 6（10 points）：$m\\leq 10^6$，$X=1$，$s_i=0$。\n- Subtask 7（15 points）：$m\\leq 10^6$，$r-l+1\\leq 10^4$。\n- Subtask 8（15 points）：$m\\leq 2\\times 10^6$。\n- Subtask 9（10 points）：无特殊限制。\n\n对于所有数据，满足 $n\\leq 10^9$，$m\\leq 10^7$，$0\\leq l\\leq r\\leq m$，$X\\geq 1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2021] 数列重排", "background": "dottle bot。", "description": "定义一个数列区间的 $\\textrm{mex}$ 为区间中最小的没有出现过的自然数，定义一个数列的价值为其中 $\\textrm{mex}\\geq k$ 的区间数量。\n\n给定 $n$ 个小于 $m$ 的自然数和一个区间 $[l,r]$，令 $f(k)$ 表示 $n$ 个数构成的数列所有重排列中数列价值的最大值，对于每一个 $k\\in [l,r]$，求出 $f(k)$。\n\n令 $a_i$ 表示数字 $i$ 出现的次数，保证存在正整数 $X$，使得  $\\forall i\\le m-1,a_i\\in \\{X,X+1\\}$。", "inputFormat": "由于 $n$ 可能很大，将采取如下方式减少读入量：\n\n第一行四个整数 $m,l,r,X$。\n\n第二行一个长度为 $m$ 的 $01$ 串，若其中第 $i$ 个位置为 $1$ 则数字 $i-1$ 的出现次数为 $X+1$，否则出现次数为 $X$。\n\n根据输入可以推出 $n=mX+S$，其中 $S$ 为 $01$ 串中 $1$ 的数量。", "outputFormat": "为了减少输出量，令 $ans=\\displaystyle{\\bigoplus_{i=l}^r}  (233^if(i)\\bmod 998244353)$，其中 $\\displaystyle\\bigoplus$ 表示二进制下的按位异或，输出一行一个整数 $ans$。", "hint": "#### 样例 1 解释\n\n在样例给出的数列中，有 $3$ 个 $0$ 和 $2$ 个 $1$，任意排列 $f(0)$ 均为 $15$，排列为 $\\textrm{01010}$ 时 $f(1)$ 有最大值 $13$，答案为：\n$$\n\\displaystyle (233^0\\times 15\\bmod 998244353)\\oplus(233^1\\times 13\\bmod 998244353)=3034\n$$\n\n#### 数据范围\n\n- Subtask 1（5 points）：$n,m\\leq 9$。\n- Subtask 2（15 points）：$n,m\\leq 200$。\n- Subtask 3（15 points）：$n,m\\leq 5\\times 10^3$。\n- Subtask 4（5 points）：$m\\leq 2$，$l=0$，$r=1$。\n- Subtask 5（10 points）：$m\\leq 10^6$，$l=m$，$r=m$。 \n- Subtask 6（10 points）：$m\\leq 10^6$，$X=1$，$s_i=0$。\n- Subtask 7（15 points）：$m\\leq 10^6$，$r-l+1\\leq 10^4$。\n- Subtask 8（15 points）：$m\\leq 2\\times 10^6$。\n- Subtask 9（10 points）：无特殊限制。\n\n对于所有数据，满足 $n\\leq 10^9$，$m\\leq 10^7$，$0\\leq l\\leq r\\leq m$，$X\\geq 1$。", "locale": "zh-CN"}}}
{"pid": "P9056", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 3000, 3000, 3000, 3000, 3000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["集训队互测", "2022", "交互题", "Special Judge", "O2优化", "树论", "随机化"], "title": "[集训队互测 2022] 在路上", "background": "滥用本题评测者封号。\n\ndottle bot。", "description": "**这是一道交互题，仅支持 C++ 提交**。\n\n有一棵未知的树，**保证树的大小为奇数，你需要找到这棵树重心的编号**。\n\n你可以进行询问，每次询问你可以询问三个点 $(x,y,z)$，若不存在一条简单路径同时经过三个点，则交互器会返回 $0$，否则若存在，那么交互器会返回三个点在路径上相对顺序中间的一个点。\n\n令 $dis(a,b)$ 表示 $a,b$ 两点在树上最短路径经过的边数，你也可以理解为:\n\n若 $dis(x,y)+dis(x,z)=dis(y,z)$，则交互器会返回 $x$。\n\n否则若 $dis(y,x)+dis(y,z)=dis(x,z)$，交互器会返回 $y$。\n\n否则若 $dis(z,x)+dis(z,y)=dis(x,y)$，交互器会返回 $z$。\n\n否则交互器会返回 $0$。\n\n在最终的测试中，每个测试点会包含 $T$ 组测试数据，和一个常数 $M$，表示你在所有测试数据中询问次数总和的上限，具体细则见 输入格式 以及 数据范围。\n\n#### 实现细节\n\n~~你需要引用 `path.h` 头文件。~~ 本题中你只需要把 `path.h` 头文件的内容粘贴到程序开头即可，不要引用 `path.h` 头文件。\n\n你需要实现下面的函数：\n\n```\nint centroid(int id,int N,int M);\n```\n\n其中 $id$ 为当前子任务的编号，$N$ 为当前询问树的大小，$M$ 为当前测试点剩余的询问次数，函数的返回值为当前树的重心编号。\n\n具体的，在第一次调用时 $M$ 为当前测试点的询问次数上限，每次调用结束之后 $M$ 会减去当前测试点使用的询问次数。\n\n你可以调用下面的函数：\n\n```\nint ask(int x,int y,int z);\n```\n\n表示你进行了一次询问，交互器会返回当前询问的答案，特别的，若询问次数已经超过了上限，交互器会返回 $-1$。\n\n注意同一个测试点中 `centroid` 函数可能会被多次调用，请注意数组清空等情况。\n\n**下发文件中有样例交互库，该交互库的实现与评测时的交互库几乎一致，如果对交互方式有不理解可以参照交互库的代码理解**。\n", "inputFormat": "样例评测库将读入如下格式的输入数据：\n\n第一行三个整数 $id,T,M$，表示当前的子任务编号以及测试数据的数量，以及询问次数的上界。\n\n对于每一组测试数据，第一行一个正整数 $n$，表示当前测试数据中树的大小。\n\n之后一行 $n-1$ 个正整数，第 $i$ 个数表示 $i+1$ 在以 $1$ 为根意义下的父亲节点。\n\n数据的答案将在交互库内部计算。", "outputFormat": "具体信息见交互库。", "hint": "#### 数据范围\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f3d6b2zv.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)\n\n特殊性质 $A$：保证树的形态为一条链，即每个点的度数均不超过 $2$。\n\n保证每个 Subtask 里的测试数据数量均不超过 $20$。**请仔细阅读每一档子任务及其限制**。\n\n#### 时空限制\n\nSubtask 5 时限为 3s。\n\nSubtask 7,8 时限为 4s。\n\n其余 Subtask 时限为 1s。\n\n空间限制：512MB。\n\n保证最终交互库的时间使用不超过  2s，空间使用不超过 64MB。\n\n#### 下发文件\n\n下发文件中有一个样例交互库，提供的交互头文件，一份示例代码，以及一个满足子任务 $4$ 性质的样例，选手也可以按照题目的输入格式构造其他样例。\n\n另外也有一份洛谷样式的交互库。\n\n保证下发的交互库和最终使用的交互库除反作弊之外没有区别，你可以使用这个交互库输出调试信息。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2022] 在路上", "background": "滥用本题评测者封号。\n\ndottle bot。", "description": "**这是一道交互题，仅支持 C++ 提交**。\n\n有一棵未知的树，**保证树的大小为奇数，你需要找到这棵树重心的编号**。\n\n你可以进行询问，每次询问你可以询问三个点 $(x,y,z)$，若不存在一条简单路径同时经过三个点，则交互器会返回 $0$，否则若存在，那么交互器会返回三个点在路径上相对顺序中间的一个点。\n\n令 $dis(a,b)$ 表示 $a,b$ 两点在树上最短路径经过的边数，你也可以理解为:\n\n若 $dis(x,y)+dis(x,z)=dis(y,z)$，则交互器会返回 $x$。\n\n否则若 $dis(y,x)+dis(y,z)=dis(x,z)$，交互器会返回 $y$。\n\n否则若 $dis(z,x)+dis(z,y)=dis(x,y)$，交互器会返回 $z$。\n\n否则交互器会返回 $0$。\n\n在最终的测试中，每个测试点会包含 $T$ 组测试数据，和一个常数 $M$，表示你在所有测试数据中询问次数总和的上限，具体细则见 输入格式 以及 数据范围。\n\n#### 实现细节\n\n~~你需要引用 `path.h` 头文件。~~ 本题中你只需要把 `path.h` 头文件的内容粘贴到程序开头即可，不要引用 `path.h` 头文件。\n\n你需要实现下面的函数：\n\n```\nint centroid(int id,int N,int M);\n```\n\n其中 $id$ 为当前子任务的编号，$N$ 为当前询问树的大小，$M$ 为当前测试点剩余的询问次数，函数的返回值为当前树的重心编号。\n\n具体的，在第一次调用时 $M$ 为当前测试点的询问次数上限，每次调用结束之后 $M$ 会减去当前测试点使用的询问次数。\n\n你可以调用下面的函数：\n\n```\nint ask(int x,int y,int z);\n```\n\n表示你进行了一次询问，交互器会返回当前询问的答案，特别的，若询问次数已经超过了上限，交互器会返回 $-1$。\n\n注意同一个测试点中 `centroid` 函数可能会被多次调用，请注意数组清空等情况。\n\n**下发文件中有样例交互库，该交互库的实现与评测时的交互库几乎一致，如果对交互方式有不理解可以参照交互库的代码理解**。\n", "inputFormat": "样例评测库将读入如下格式的输入数据：\n\n第一行三个整数 $id,T,M$，表示当前的子任务编号以及测试数据的数量，以及询问次数的上界。\n\n对于每一组测试数据，第一行一个正整数 $n$，表示当前测试数据中树的大小。\n\n之后一行 $n-1$ 个正整数，第 $i$ 个数表示 $i+1$ 在以 $1$ 为根意义下的父亲节点。\n\n数据的答案将在交互库内部计算。", "outputFormat": "具体信息见交互库。", "hint": "#### 数据范围\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f3d6b2zv.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)\n\n特殊性质 $A$：保证树的形态为一条链，即每个点的度数均不超过 $2$。\n\n保证每个 Subtask 里的测试数据数量均不超过 $20$。**请仔细阅读每一档子任务及其限制**。\n\n#### 时空限制\n\nSubtask 5 时限为 3s。\n\nSubtask 7,8 时限为 4s。\n\n其余 Subtask 时限为 1s。\n\n空间限制：512MB。\n\n保证最终交互库的时间使用不超过  2s，空间使用不超过 64MB。\n\n#### 下发文件\n\n下发文件中有一个样例交互库，提供的交互头文件，一份示例代码，以及一个满足子任务 $4$ 性质的样例，选手也可以按照题目的输入格式构造其他样例。\n\n另外也有一份洛谷样式的交互库。\n\n保证下发的交互库和最终使用的交互库除反作弊之外没有区别，你可以使用这个交互库输出调试信息。", "locale": "zh-CN"}}}
{"pid": "P9057", "type": "P", "difficulty": 7, "samples": [["5 20 10\n1 4 4 166348285\n2 2 5\n2 1 5\n1 1 2 10\n1 4 4 3\n1 4 5 6\n2 5 5\n1 5 5 1\n1 2 3 1\n2 5 5\n2 5 5\n2 3 4\n2 3 3\n2 4 5\n2 4 4\n1 2 5 5\n1 5 5 9\n1 1 4 5\n2 5 5\n2 1 4", "4\n5\n2\n3\n3\n4\n2\n5\n2\n2\n8"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2004", "O2优化", "Ynoi"], "title": "[Ynoi2004] rpfrdtzls", "background": "", "description": "给定 $n,m,A$，维护由序列构成的序列 $a_1,\\dots,a_n$，初始 $a_i$ 包含一个元素 $A+1$；\n\n共 $m$ 次操作：\n\n修改操作：给定 $l,r,x$，对 $l\\le i\\le r$，在序列 $a_i$ 前面插入元素 $x$\n\n查询操作：给定 $l,r$，查询 $\\sum\\limits_{i=l}^r F(a_i,A)$\n\n其中 $F((x_1,\\dots,x_n),0)=0$\n\n对 $k>0$，$F((x_1,\\dots,x_n),k)=F((x_2,\\dots,x_n),\\lfloor \\frac{k}{x_1} \\rfloor)+1$\n\n### ", "inputFormat": "第一行三个整数 $n,m,A$；\n\n接下来 $m$ 行，每行 $1,l,r,x$ 表示一个修改操作，或 $2,l,r$ 表示一个查询操作；", "outputFormat": "对每个查询操作，输出一行，表示答案。", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m\\le 5\\times 10^5$，$1\\le A,x\\le 10^9$，$1\\le l\\le r\\le n$。\n\n对于 $25\\%$ 的数据，满足 $n,m\\le 100$。\n\n对于 $50\\%$ 的数据，满足 $n,m\\le 10^5$。\n\n对于另外 $25\\%$ 的数据，满足 $x\\ne 1$。\n\n对于另外 $25\\%$ 的数据，无特殊限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2004] rpfrdtzls", "background": "", "description": "给定 $n,m,A$，维护由序列构成的序列 $a_1,\\dots,a_n$，初始 $a_i$ 包含一个元素 $A+1$；\n\n共 $m$ 次操作：\n\n修改操作：给定 $l,r,x$，对 $l\\le i\\le r$，在序列 $a_i$ 前面插入元素 $x$\n\n查询操作：给定 $l,r$，查询 $\\sum\\limits_{i=l}^r F(a_i,A)$\n\n其中 $F((x_1,\\dots,x_n),0)=0$\n\n对 $k>0$，$F((x_1,\\dots,x_n),k)=F((x_2,\\dots,x_n),\\lfloor \\frac{k}{x_1} \\rfloor)+1$\n\n### ", "inputFormat": "第一行三个整数 $n,m,A$；\n\n接下来 $m$ 行，每行 $1,l,r,x$ 表示一个修改操作，或 $2,l,r$ 表示一个查询操作；", "outputFormat": "对每个查询操作，输出一行，表示答案。", "hint": "Idea：nzhtl1477，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m\\le 5\\times 10^5$，$1\\le A,x\\le 10^9$，$1\\le l\\le r\\le n$。\n\n对于 $25\\%$ 的数据，满足 $n,m\\le 100$。\n\n对于 $50\\%$ 的数据，满足 $n,m\\le 10^5$。\n\n对于另外 $25\\%$ 的数据，满足 $x\\ne 1$。\n\n对于另外 $25\\%$ 的数据，无特殊限制。", "locale": "zh-CN"}}}
{"pid": "P9058", "type": "P", "difficulty": 7, "samples": [["5\n1 2 5\n1 3 3\n1 4 4\n3 5 2\n5\n1 1\n1 4\n2 4\n3 4\n2 5", "-1\n3\n7\n7\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2004", "O2优化", "Ynoi"], "title": "[Ynoi2004] rpmtdq", "background": "", "description": "给定一棵有边权的无根树，需要回答一些询问。\n\n定义 $\\texttt{dist(i,j)}$ 代表树上点 $i$ 和点 $j$ 之间的距离。\n\n对于每一组询问，会给出 $l,r$，你需要输出 $\\min(\\texttt{dist(i,j)})$ 其中 $l\\leq i < j \\leq r$。", "inputFormat": "第一行一个整数 $n$，表示树的节点个数。\n\n接下来 $n-1$ 行，每行三个整数 $x,y,z$ 表示一条连接 $x,y$ 边权为 $z$ 的树边，输入保证构成一棵树。\n\n之后一行一个数 $q$，表示询问个数。\n\n之后 $q$ 行，每行两个整数 $l,r$ 表示一组询问，如果对于一组询问，找不到任何二元组 $(i,j)$ 满足 $l\\le i<j\\le r$，则输出 $-1$。", "outputFormat": "输出 $q$ 行，每行一个整数，表示这组询问的答案。", "hint": "Idea：nzhtl1477，Solution：Kubic&ccz181078，Code：Kubic，Data：Kubic\n\n对于$100\\%$的数据，满足 $n\\leq2\\times 10^5$，$q\\leq 10^6$，$1\\le z\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2004] rpmtdq", "background": "", "description": "给定一棵有边权的无根树，需要回答一些询问。\n\n定义 $\\texttt{dist(i,j)}$ 代表树上点 $i$ 和点 $j$ 之间的距离。\n\n对于每一组询问，会给出 $l,r$，你需要输出 $\\min(\\texttt{dist(i,j)})$ 其中 $l\\leq i < j \\leq r$。", "inputFormat": "第一行一个整数 $n$，表示树的节点个数。\n\n接下来 $n-1$ 行，每行三个整数 $x,y,z$ 表示一条连接 $x,y$ 边权为 $z$ 的树边，输入保证构成一棵树。\n\n之后一行一个数 $q$，表示询问个数。\n\n之后 $q$ 行，每行两个整数 $l,r$ 表示一组询问，如果对于一组询问，找不到任何二元组 $(i,j)$ 满足 $l\\le i<j\\le r$，则输出 $-1$。", "outputFormat": "输出 $q$ 行，每行一个整数，表示这组询问的答案。", "hint": "Idea：nzhtl1477，Solution：Kubic&ccz181078，Code：Kubic，Data：Kubic\n\n对于$100\\%$的数据，满足 $n\\leq2\\times 10^5$，$q\\leq 10^6$，$1\\le z\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P9060", "type": "P", "difficulty": 6, "samples": [["5 3\n2 6 3 15 5\n4 4\n1 3\n2 5", "15\n216\n546750"], ["6 6\n3332 411 6666 6291 415 7180\n4 6\n1 5\n5 6\n4 4\n1 2\n1 3", "889738671\n989336054\n14898500\n6291\n1369452\n867407130"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2002", "O2优化", "Ynoi"], "title": "[Ynoi2002] Goedel Machine", "background": "# 1.前言\n\n哥德尔机 [1] 是由 LSTM 之父 Jürgen Schmidhuber 提出的一种可学习的通用问题求解器。本文将对该模型进行描述与讨论，并且说明这个模型拥有许多重要的性质，这些性质是我们认为通用人工智能所必需的。\n\n# 2.相关概念\n\n## 学习\n\n学习指模型对模型自身的参数（同一个模型在参数不同时有不同的行为）进行修改。用于对自己进行修改的方法叫做学习算法。\n\n## 元学习\n\n元学习指模型拥有通过学习修改自己的学习算法的能力。有大量证据指示人类拥有比较强的元学习的能力。\n\n### 元学习分层\n\n不可学习的方法没有学习能力，比如解决 OI 题的程序，坦克世界的固定线路看到人就停车的脚本等。\n\n常见的机器学习方法，比如朴素的神经网络方法没有元学习能力，因为学习算法是不可学习的梯度下降算法。支持向量机没有元学习能力，因为学习算法是确定的，等。\n\n专门设计了元学习特性的神经网络有元学习能力，但是没有元元学习能力，也就是说不能对学习自己学习算法的算法进行学习。\n\n假设你想设计一种学习算法：\n\n初始时，你想让你的算法可学习，于是设计了初始的学习算法。\n\n然后你想让你的初始学习算法可学习，于是设计了元学习算法。\n\n然后你想让你的元学习算法可学习，于是设计了元元学习算法。\n\n这样每一步你都必须设计新的学习算法，用于之前的学习算法的学习。设计第 $i$ 层的学习算法时，这个学习算法可以优化前 $i-1$ 层，但是对第 $i$ 层的优化需要第 $i+1$ 层后的方法。分层不是必需的，这里分层是人为设计的，因为你人为设计了分层结构，所以你需要设计无限层的元学习算法。\n\n一直这样递归下去可以发现现有机器学习方法的一个问题：因为不能人工设计无限层的元学习算法，所以在某一层之后一定不可学习。这样会导致人工设计可以一直让模型变强，因为设计了第 $i$ 层元学习的模型不会比只设计了前 $i-1$ 层元学习的模型弱，但是这个过程永不收敛。这样的模型不具备一种**不可改进性**，即在给定足量的计算资源下，这个模型是最优的。\n\n哥德尔机以及类似的构造尝试将所有层级的元学习用同一个东西去泛化，将任意层的元学习问题变成一层普通的学习问题。要实现这样的功能，我们需要一个足够强的优化器。弱的优化器，比如梯度下降的神经网络，面临的问题是无法使用梯度下降去优化模型梯度下降的过程，也就是说无法直接用学习算法去处理元学习层面的优化。于是元学习特性需要人为设计，也就是说需要设计优化元学习任务的优化器，而这样会导致该优化器无法用已设计好的方法优化，需要继续设计新的对应的优化算法。这样分层的元学习需要无限的设计，是神经网络方法最大的问题之一。\n\n### 不分层元学习/无限层元学习\n\n哥德尔机没有元学习分层的设计，因为其架构会将所有优化问题用同样的方法优化，并且该优化方法可以优化自身，所以哥德尔机拥有不分层的元学习能力，或者可以叫做无限层元学习的能力。在给定足量的计算资源下，哥德尔机不弱于任何其它可计算的机器学习模型。\n\n实际上存在一些元学习算法是递归的，即存在一种元学习算法，第 $i$ 层可以对前 $i-1$ 层进行优化，且对任意 $i$，这个算法都是相同的，所以只需要有限的人为设计。我们认为这类方法是有一些问题的，不如不分层的元学习算法，这里不展开讨论。\n\n元学习和学习实际上不可区分，这个会在后续进行讨论。\n\n## 强化学习\n\n模型与环境交互并优化由环境提供的奖励。\n\n### 马尔可夫决策过程\n\n时间被分为一些离散的时间步，模型每个时刻从环境中获取输入信息（包括环境提供的奖励），并能从有限种对环境的操作中选一部分执行，环境由这一时刻的状态以及模型采取的操作计算出环境下一时刻的状态。\n\n## 通用人工智能/完全人工智能/人工广义智能\n\n这些词语是 Artificial General Intelligence 的中文翻译，该词语代表一个可以在各个领域达到人类顶尖水平甚至超越的人工智能模型。\n\n通用人工智能**没有准确的定义**，不同人对通用人工智能应该有什么样的能力看法不同。\n\n## 自编程/自修改/自进步\n\n这三个词语指模型的一种能力，有这种能力的模型可以通过修改自己来提升自己的表现。一般提升表现指可以在监督学习任务中通过更多的数据，或在强化学习任务中获得更大的预期奖励。\n\n## 自指\n\n一个模型是完全自指的，表示某个模型可以在内部描述自己的所有性质。虽然人类不是一个完全自指的模型，但是人类可以描述关于自己的部分性质。\n\n自指常用于构建悖论，如：\n\n1. \"这句话是错的\" 是对的还是错的？\n\n2. 罗素悖论：一个理发师只给不理自己头发的人理发，那这个理发师是否给自己理发？\n\n3. 停机问题：一个图灵机如果判定出自己停机，则不停机。\n\n4. 哥德尔不完备性定理。\n\n哥德尔机是一个可以完全自指的模型。哥德尔机的作者认为 \"意识\" 的本质是自指，即模型可以意识到自己的存在。哥德尔机的学习算法可以完全自指，也就是说可以用学习算法处理学习算法的学习，甚至完全覆写掉初始的学习算法。\n\n## 可计算性\n\n程序在不限制空间并且不限制字长时，能在有限时间内完成处理的问题是可计算的问题所构成的集合。\n\n## 图灵机\n\n本文中我们直接把 图灵机 当成 C++ 语言写成的代码，不限制空间并且不限制字长。\n\n### 通用图灵机\n\n用 C++ 语言显然可以模拟执行 C++ 语言。假设我们写出了一份 C++ 语言代码 A，用于执行任何其它 C++ 语言写出的代码。则当我们想执行 C++ 代码 B 时，可以将 B 做为 A 的输入，并执行 A。这样的代码 A 叫做 通用图灵机。\n\n## 不可区分性\n\n有许多人类设计的分层结构是不可区分的，如：\n\n1. 数据与程序不可区分：这里我们顺便解释中文房间悖论。中文房间指给定一个黑箱，将一个不会中文的人和一个翻译器一起放入。在房间外的人向内部提供中文文章，内部的人将文章输入翻译器后直接得到翻译后的结果，并将结果输出，此时从外部看来，无法判定内部的人是否会中文。这个悖论实际上等价于：现在有一个通用图灵机，以及一份通用人工智能的代码。如果我们将通用图灵机看做模型（程序），将通用人工智能看做数据进行执行（对于通用图灵机而言，一个图灵机的程序可以是数据，并且做为数据的程序可以被执行），则这里可以认为这个通用图灵机在给定数据下是一个通用人工智能。也就是说我们可以将非平凡的部分：通用人工智能，在程序和数据两边任意转移，但必须在某一边解决这个本质问题。\n\n2. 监督学习的数据和模型的先验（初始引入的知识）不可区分，强化学习的人类知识和模型的 reward 不可区分：监督学习模型的 loss 函数可以内嵌任意复杂的信息，包括数据集中的所有信息，这种情况下模型的 loss 是模型的先验的一部分。强化学习模型 reward 函数可以内嵌任意复杂的信息，包括关于环境的先验，以及人类知识。如 AlphaGo 算法中使用了 MCTS 搜索算法做为探索先验，这样的先验（搜索）就是一种人类知识。\n\n3. 模型关于自己的先验与模型关于环境的先验不可区分：这个在后续会进行讨论。\n\n4. 学习和元学习不可区分：假设模型分为学习算法和模型主体部分，学习算法经过学习后被修改了，则这里可以看做是元学习。但如果将整个模型做为一个整体来看待，学习实际上改变了模型的一些参数，是普通的学习。从学习和元学习不可区分也可以看出对元学习人为分层是不自然的，应该将元学习的优化视为普通学习处理。\n\n由于不可区分性，一般来说我们用功能而不是具体的结构来衡量模型的能力。比如对于中文房间悖论，可以认为一个有翻译器的人类就是懂得中文的，因为和懂得中文的人表现一致，一个没有翻译器的人类是不懂得中文的。\n\n同理，由于不可区分性，对于“理解”和“意识”的讨论都是无意义的，因为我们用功能而不是具体的结构来衡量模型的能力。\n\n# 3.简介\n\n几乎所有已知的用于解决问题的算法（包括证明搜索器，监督学习，强化学习等）都在元学习方面有欠缺，理由在元学习分层中有描述。人类需要一直不断地设计新的更好的算法（有更多层元学习的算法），并且提供计算资源对这些算法进行测试。\n\n如何才能消除人类的必要性？为了方便描述，我们定义了学习，学习指模型对模型自身的参数进行修改。对自己进行修改的方法叫做学习算法。最简单的想法就是让机器可以进行任意复杂的学习，也就是说学习方法需要足够强，比如从所有可计算的程序中选出一个最高效的学习算法，利用这个学习算法修改自己。\n\n为了解决这个问题，作者设计了一类最优的，完全自指的，通用的问题求解器——哥德尔机。哥德尔机与一个部分可观测的环境交互，并且原则上可以无限制地修改自身（学习），唯一的限制是哥德尔机自己的可计算性。哥德尔机的初始算法有能力完全重写自己，这样的重写能力保证哥德尔机是全局最优的。\n\n## 哥德尔机的结构\n\n哥德尔机主要包含公理系统、证明搜索程序、行为程序、目标函数。\n\n# 4.环境和形式化目标\n\n模型的环境处在一个人为设计的硬件中，该硬件可以是通用图灵机，空间有限的图灵机，或抽象的电子计算机。模型是单例的，只有唯一一个同时存在。模型的生命包含一些离散的时间步：$1,2,\\dots$，模型的生命在 $T$ 时刻结束，这个时刻可能对模型而言不可见。任何一个时变的变量 $Q$ 在 $t$ 时刻的值可以记作 $Q(t)$。\n\n每一步时间我们的硬件执行一个基本操作，改变硬件的状态 $s$，为不失一般性，$s\\in \\mathcal S \\in B^*$，$B^*$ 表示所有可能的二进制串。每一步时间环境状态可能发生变化，环境状态用 $Env$ 表示，$Env\\in \\mathcal E$，$\\mathcal E$ 表示考虑的环境的集合，这个会在后续进行讨论。硬件有硬编码的转移方程：$F:\\mathcal S\\times \\mathcal E \\rightarrow \\mathcal S$。对任何 $t>1$，$s(t)=F(s(t-1),Env(t-1))$ 表示当前 $t-1$ 个时刻都结束后，$t$ 时刻还没开始时硬件的状态。\n$Env(t)$ 表示 $t$ 时刻的环境，由 $s(t-1)$ 中描述环境变化的变量与环境交互得到，如果环境是随机的，则这里按对应概率进行采样。\n\n定义四个特殊的变量：$time,x,y,p$：\n\n1. $time$ 表示当前时刻。\n2. $x$ 表示环境对哥德尔机的输入，对任意 $t>1$，$x(t)\\neq x(t-1)$ 可能发生当且仅当哥德尔机输出了一个特定字符串，表示向环境请求输入。这样就可以避免每个时刻只有常数的计算资源，导致不能对输入完全观测（比如复制整个输入所需的计算资源比每个时刻的计算资源多）。\n3. $y$ 表示哥德尔机对环境的输出，$y(t)$ 表示一个二进制串。输出可能对环境产生影响，比如输出一个控制指令，指令操作环境中的一个机器人，或者指令打开电视机。\n4. $p(1)$ 表示最初哥德尔机的软件，也就是根据环境输入计算出对环境输出的计算过程。初始的 $p(1)$ 可以用一个图灵机表示，所以不是最优的。\n\n每一个时刻 $1\\le t\\le T$ 模型的目标是最大化预期回报。对于一个确定的 $s$ 和 $Env$，奖励函数可以写做：$u(s,Env):\\mathcal S\\times \\mathcal E\\rightarrow \\mathcal R$，$u(s,Env)=E_{\\mu} \\bigg [\\sum _{\\tau=time} ^T  r(\\tau)\\bigg | s,Env \\bigg ]$，其中 $\\mathcal R$ 表示实数，$r(t)$ 表示 $t$ 时刻获得的实数表示的奖励。$E_{\\mu}\\big(\\cdot \\big|\\cdot\\big)$ 表示条件期望，其中 $\\mu$ 表示所有可能的环境。\n\n这里需要注意到 $s$ 表示的也是模型的内环境，因为硬件行为完全由模型决定，$Env$ 表示外部环境，$time=time(s)$ 表示 $s$ 状态所在时刻。\n\n可以同时修改奖励函数使得模型倾向于选择更低方差的改进。绝大部分计算机科学的问题都可以用这个设计形式化。\n\n# 5.哥德尔机的基本思想\n\n为了让我们的硬件变成一个有自指能力的哥德尔机，需要设计对应的软件（也就是可运行代码） $p$，该软件需要有修改自己的能力。初始的代码 $p(1)$ 有一个目前不是最优的问题求解器 $e(1)$，用于和环境交互，这个问题求解器可以是任何传统的强化学习算法，同时还有一个通用的证明搜索器，证明搜索器持续地搜索二元组 (程序，证明） 直到对一个 程序 A，搜索到了一个 证明 B，表明：将搜索到的这个程序 A 直接用于修改 $p$ 后得到的程序的预期回报比修改前的 $p$ 更大。之后模型会使用 程序 A 对 $p$ 进行修改，这个修改不止对 $e$ 有效，同时可能影响到 $p$ 中的证明搜索器。\n\n## 自修改公理\n\n在 $t_1$ 时刻，我们使用搜索到的程序 A 来修改 $s(t_1)$ 当且仅当搜索到了证明 B，表示：$u[A(s(t_1)),Env(t_1)]>u[s(t_1),Env(t_1)]$。硬件状态 $s$ 包含了软件 $p$，用 $A(s(t_1))$ 表示用程序 A 对 $t_1$ 时刻的模型的软件进行学习。\n\n哥德尔机还需要引入大量其它的公理才能变得足够强，比如关于环境的公理，以及概率相关的公理。我们使用 $\\mathcal A$ 来表示一个足够强的哥德尔机的公理系统。\n\n## 哥德尔不完备定理\n\n我们说一个公理系统是一致的，当且仅当对任意命题 $P$，$P$ 和 非 $P$ 这两个命题不能同时在这个公理系统下被证明。\n\n哥德尔不完备定理指的是：任何一个公理系统，如果是一致的，并且能定义自然数，与自然数的加法，乘法和等于，则一定存在一个命题 $P$，$P$ 和 非 $P$ 在这个公理系统中不可证明。\n\n## 哥德尔机的局限性与优势\n\n哥德尔不完备性定理使得对任意一个足够强的公理系统，一定存在不可证的命题。哥德尔不完备定理不会导致哥德尔机弱，因为如果存在某个对哥德尔机有用的命题，但是这个命题在哥德尔机的公理系统下是不可证的，则对人而言，这个命题在同一个公理系统下也是不可证的，人也无法利用这个命题。\n\n哥德尔机更大的局限性在于，在现实环境中，时间和空间资源是有限的，如果哥德尔机的初始公理设计不够好，会导致即使其拥有极大量资源，也无法搜索出足量有效的自修改程序，导致花费了极大量的资源后还是一个低效的搜索器。\n\n哥德尔机需要引入大量的概率相关的公理，因为有限时间的观测只能产生有限的数据。有限的数据会导致任何证明都不能保证不会和后来的观测数据发生矛盾，所以只能给出证明的置信度，而不能保证证明一定正确。\n\n在一般的环境中，哥德尔机模型难以进行严格控制变量的实验，难以收集独立同分布的数据，难以短时间内发现环境在大时间尺度上的改变，这导致对概率的严格推断难以证明有用的结论，因此哥德尔机加入普通的概率公理可能也证明不出任何有用的东西。\n\n这样的问题导致哥德尔机不像是一个形式系统，不像一个证明搜索器，如果把初始的软件 $p$ 看做是一个模型初始的学习算法，自修改看做是学习，哥德尔机更像是一个程序搜索器。这种情况下，不一致或者过弱的公理系统对应一个不完备的初始学习算法，比如神经网络。\n\n哥德尔机的优势在于，哥德尔机可以对自己的初始算法进行任意的改动，并且现有的其它方法都无法做到这一点，比如神经网络无法学习自己的梯度下降学习法，有元学习的神经网络无法学习自己的元学习算法，搜索器无法学习自己的搜索策略等。这里的本质区别是哥德尔机的学习比这些模型强，强到可以完全复写掉初始的学习算法，而其它模型只能修改初始学习算法的一部分。\n\n# 6.全局最优性定理\n\n## 自修改公理与全局最优\n\n对任何形式化的奖励函数 $u$，假设哥德尔机公理 $\\mathcal A$ 是一致的，则任何自修改公理推出的自修改程序 $p$ 是全局最优的：在执行自修改 $p$ 之前哥德尔机的最大预期回报比执行 $p$ 之后的低。\n\n这里的自修改看上去像是一种贪心算法，每次贪心地向更优的方向改进，为什么是全局最优呢？我们可以证明满足自修改公理的程序 $p$ 是对当前哥德尔机的状态而言，所有可能的程序里最优的一个修改。\n\n证明的思路其实很简单，考虑搜索到 $p$ 后，哥德尔机可以采取的两种方案：\n\n1. 执行自修改程序 $p$。\n\n2. 不执行自修改程序 $p$，继续搜索其它程序执行。\n\n第二种方案考虑到了未来会搜索到的所有程序，而哥德尔机证明了第一种方案比第二种方案优，所以程序 $p$ 是在公理 $\\mathcal A$ 下，所有程序中最优的一个。\n\n在实践中，这里的最优性应该需要考虑搜索到每个程序的期望代价，比如存在一些自修改，效果比 $p$ 更好，但是搜索到这些自修改需要大量时间，或是执行了自修改 $p$ 后模型可以更快地搜索到其它自修改。也正是因为这些原因，所以哥德尔机证明了执行自修改 $p$ 后有更大的预期回报。\n\n## $O()$-最优性\n\n哥德尔机在任何任务上是 $O()$-最优 的，即与可以证明理论最优的解（如果存在）只在计算资源消耗上差常数倍。这是因为哥德尔机的初始算法即可保证搜索所有程序和证明是 $O()$-最优 的，哥德尔机是不可能比初始算法弱的，所以也是 $O()$-最优 的。\n\n$O()$-最优性 不是一个很强的性质，假设有一个问题，这个问题的最优解是 程序 A，则一个 $O()$-最优 的模型只需要花费常数的计算资源代价搜索到 程序 A，并且证明这个程序比之前模型给出的解优，就可以实现 $O()$-最优。比较两个证明搜索器时也是类似的，一个证明搜索器可以花费常数时间搜索到另一个并证明最优。\n\n$O()$-最优 的优化器需要一个极大的常数启动，这样的优化器最开始效果很差，需要搜索极长时间才可以变得足够强。我们认为这个过程和自然中的进化类似，并在后文讨论二者的相关性。\n\n# 7.bias-optimal searcher（给定先验下最优的搜索器）\n\nbias-optimal searcher（给定先验下最优的搜索器）的定义：\n\n给定先验概率 $P(p|r)$ 表示问题 $r$ 应该选取解 $p$ 的概率。\n\n黑盒函数可以在 $t(p,r)$ 的时间内判断问题 $r$ 是否有解 $p$。\n\nbias-optimal searcher 在有限时间 $T$ 内，对任意问题 $r$，如果有解 $p$ 满足 $t(p,r)\\le P(p|r)\\times T$ 则能求出问题的一个解。\n\nnear-bias-optimal searcher 则放宽条件到 $t(p,r)\\le P(p|r)\\times T/n$，$n>1$ 是近似比。bias-optimal searcher 有 Optimal Ordered Problem Solver 等已知的构造，这里不做相关解释。\n\n这里搜索器关心的是如何按给定先验分配计算资源，$p$ 可以是程序，$t$ 是程序运行用时。\n\n哥德尔机只需要使用一个 bias-optimal searcher 做为初始证明搜索器，则是 $O()$-最优 的，因为 bias-optimal searcher 是 $O()$-最优 的。\n\n# 8.哥德尔机的缺陷和相关讨论\n\n## 预测而不是证明\n\n考虑到有限的交互导致对环境认知的不确定性，从有限的与环境交互的历史中，不应该能证明无限长时间内可靠的环境性质。\n\n如果尝试构造一个比原有公理系统强的形式系统并用其进行证明，就无法证明新的形式系统的一致性，只能用有限的经验来支持这个新的形式系统是有用的（例如在发现矛盾前暂时正常使用）。\n\n如果尝试增加对环境的假设，那么加入这个假设可以得到新的形式系统，但这个假设不能用初始的公理系统证明，同上。\n\n从这个角度看，利用证明对环境进行推断，和一般的元学习是类似的。这里的证明其实不如说是一种基于已有数据对未来的预测。\n\n另一方面，形式系统可以证明一些关于无穷的命题，这些命题不能从有限的数据中得到，但可能产生可验证且有用的推论。\n\n如果这样的构造是有用的，初始学习算法应该能构造出这样的形式系统并用其进行证明，但不会认为形式系统是绝对可靠的。\n\n从这个角度看，形式系统和一般的程序是类似的。\n\n## 计算资源限制\n\n哥德尔机考虑的是理想环境，模型存活 $T$ 时间，最优化的是在存活的时间内奖励的和。\n\n### 有限存活时间\n\n有限存活时间会限制模型，导致模型无法到达全局最优。\n\n由于哥德尔机的低效性，从现实的角度看，我们认为目前可以提供的算力不够让哥德尔机优化到足够强，甚至无法搜索到任何一个可证明的改进。\n\n对于存活时间有限的情况，实际上哥德尔机很难在有限的数据下，给出对所有可能的环境在 $T$ 时刻内的收益期望，除非对环境有过强的假设。因为哥德尔机设计的最大预期回报需要对所有可能的环境，求出该环境出现的概率，并且加权计算出期望奖励。可能的环境有限显然是一个过强的假设，因为这会导致模型不图灵完备，退化成一个 DFA。而当可能的环境无限的情况下，无法在有限时间内计算这个期望。\n\n就算写出了满足文中描述特性的哥德尔机的代码，在对环境没有过强的假设下，因为预期回报不可计算，该哥德尔机在有限的计算资源下只会卡在第一步操作上，之后消耗光计算资源。或是有一些修改可以不需要计算预期回报，比如将 `a=a+1` 改写为 `++a`，但在对环境没有过强假设的情况下，哥德尔机很难证明一个稍微复杂的修改是更优的。\n\n### 无限存活时间\n\n无限存活时间会导致奖励函数失效，因为无限长的时间会导致奖励函数 $u(s,Env)=E_{\\mu} \\bigg [\\sum _{\\tau=time} ^\\infty r(\\tau)\\bigg | s,Env \\bigg ]$ 无界。两个期望无穷的预期奖励是不可比较的，这也是为什么已有强化学习方法都会设立奖励衰减因子，因为这样的方法可以让 每个状态的预期奖励 有界。无限存活时间还可能导致每个时刻的奖励 $r(\\tau)$ 也是无界的。\n\n对于存活时间无限的情况，模型实际上不能只优化奖励，还需要优化自己的存活和计算资源，因为如果需要人类提供无限的计算资源，则模型不能脱离人类，无法 \"消除人类的必要性\"。\n\n## 启动低效\n\n如果引入大量概率方面的先验进入公理系统，并且可以让预期回报可计算，哥德尔机还是会面临启动过于低效的问题。\n\n简单设计的通用方法，例如哥德尔机和其它一些 $O()$-最优 的证明搜索方法，通常需要非常长的时间后才能变得足够优。\n\n例如，解决特定任务的最优方法需要 $t$ 时间，但通用方法需要 $a+t\\times b$ 的时间，其中 $a$ 是极大的常数，我们将其定义为：**启动常数**，用于在启动阶段找出这个最优方法，$b$ 是模拟执行这个最优方法的常数代价（这个一般不严重，合理假设下可以做到 $b=1$）。\n\n为了得到实用的通用方法，主要的设计复杂性在于降低启动常数 $a$。\n因此，需要首先构造一个简单的通用方法，允许较大的启动常数 $a$；然后，通过具体设计来降低 $a$。\n\n### 进化\n\n进化是一种自然地生成任意复杂的结构的过程。进化生成的生物也可以通过影响环境从而在环境中生成任意复杂的结构。进化的过程和已知的优化过程区别很大，已知的优化过程都有明确的目的性，如神经网络方法通过梯度下降优化模型的 loss，强化学习方法优化模型的最大预期回报等。进化没有在优化任何预设的目标，可以从两个不同的角度看待进化：\n\n1. 进化是一个在确定规则下沿时间轴演化的动力系统。进化没有任何目的性，但是可以生成任意复杂的结构。在这个角度下，我们可以认为没有智能体，只有一个不断演化的环境，但是环境的演化足够复杂，使得其中可以生成任意复杂的结构，如生命游戏。从一些例子中可以看到进化的复杂性，如：如何才能在宇宙中生成一块会飞的金块？进化先在环境中生成了人类，然后人类制作了旅行者号探测器，里面携带了一块人类制作的纯金的碟片，而这其中人类以及金的生成如果展开来讲也是一个极其复杂的过程。遗传算法之所以不是进化，也是因为遗传算法无法在环境中构建任意复杂的结构，并且遗传算法无法模拟生物之间复杂的交互作用。\n\n2. 进化是智能体不断和环境交互的过程：其中进行计算或和环境交互会减少自己的计算资源，可以从环境中获取计算资源。当智能体计算资源为 $0$ 时死亡，需要优化自己存活时间。智能体和环境的边界不可区分。智能体可以将除了自己以外的其它智能体也视为环境的一部分，对其它智能体的建模，如博弈论之类的方法，是将这些智能体看做是环境中比较容易预测的一部分，并研究这一部分环境相关的特性。从这里可以看出智能体和环境是不可区分的，智能体在环境中的边界是模糊的，例如：人吃环境中的饭，吃下去的饭是否属于人的一部分；人是否是环境中人的种群的一部分；人造出了机器人，机器人是人通过对环境进行操作后得到的，是否属于人的一部分。\n\n人类是经过了极长时间进化后产生的复杂结构，如果将进化看做是生成通用人工智能的方法，则进化像生成一块会飞的金块一样生成通用人工智能：通过先生成人类后生成这些复杂结构。生成人类的过程就是上述的极大的启动常数 $a$，通过对模型引入合适的人为设计的先验，同时不破坏完备性，这样应该可以得到一个只需要较小启动的常数，便可以在绝大部分任务上达到较优的通用人工智能。\n\n### 神经网络不完备\n\n神经网络是对模型引入人为设计的先验，但是破坏了完备性的一个例子。完备性被破坏导致神经网络不能通用地解决所有问题，但是可以以很低的启动常数解决一些特定的问题。\n\n神经网络不完备指的是：\n\n1. 搜索的计算图受限。神经网络搜索的是一类比较静态的计算图，虽然有一些动态的尝试，如 MoE 类的方法，Transformer 稀疏化，外置内存类的方法（类似神经图灵机），但是能搜索到的程序空间依然受限。神经网络虽然是图灵完备的，但是静态计算图会导致计算低效，如使用 Transformer 模型计算乘法需要做很长的自回归，输出乘法的中间结果，而实际上的乘法只需要很小的计算量即可完成。神经网络由于其结构固定，无法通过搜索来对结构进行改进。关于神经网络架构搜索（元学习）相关的内容会在后文讨论。\n\n2. 无法遍历状态空间。常见的梯度下降方法都需要让学习率逐步下降，否则训练无法收敛，这样会导致每次随机初始化后模型只能探索到状态空间中很小的一部分。更好的一种神经网络类方法是随机初始化大量神经网络，将其均训练到收敛，之后用于测试时，对这些神经网络的结果取平均或最大似然。这样可以降低模型的方差，因为可以更广泛地探索状态空间。\n\n3. 元学习能力受限。朴素的神经网络方法基于梯度下降，每一步的学习率确定，没有元学习能力。而有元学习特性的神经网络也只是对梯度下降的参数进行学习，甚至无法比较大地修改自己的学习算法。神经网络方法对已知形式的问题效果不错，因为加入了大量专门解决这类问题的人为设计的 trick。但是元学习对应的问题是未知的，神经网络学习能力受限会导致其无法对这些未知结构的问题进行好的学习，而无法对元学习进行好的学习会导致神经网络能力学习更受限。\n\n现在研究神经网络的算法工程师们希望通过神经网络实现通用人工智能，并且一直在设计更为通用的模型，但是我们认为这样的方式是不合理的。\n\n试想一个 Transformer 模型，为了优化平方代价的 attention，假设实现了一种优秀的 attention 策略，该策略允许我们每次只访问 $O(1)$ 个位置的 attention，就可以获取原本需要 $\\Theta(n)$ 个位置的 attention 才能获得的信息。假设这样的 Transformer 模型学到了正确的硬的内存访问，并且训练和测试不分离，也就是说模型的训练方式也是强的，不局限于梯度下降，不会发生灾难性遗忘，并且可以常数代价模拟任何动态计算图，则这样的模型是通用人工智能。\n\n这个模型中神经网络的部分则会退化为一个 for，因为 Transformer 是一个一直增长的函数式内存，每次只需要做常数规模的计算，并且从内存中取出 $O(1)$ 个位置的信息，并写下 $O(1)$ 的信息，真正的复杂性转移到了该如何设计优秀的 attention 策略，以及如何训练上。\n\n我们认为自动数学证明和自动代码生成是足够复杂的任务，在这两个任务上远远超越人类表现的模型应该可以像哥德尔机一样，探索可能有效的改进，并且通过证明以及自编程来修改自己。\n\n最近神经网络类方法取得了很好的进展，如 AI 绘画，AlphaCode，ChatGPT，DreamerV3 等，以我们的知识，我们认为他们无法通过神经网络实现通用人工智能，因为所有这一切模型的学习算法都是本质性地弱的，并且难以改进。\n\n希望本文中给出的推理有误，他们可以实现通用人工智能，实现无数人梦寐以求的技术。\n\n## 什么是好的？\n\n如果对通用人工智能，可以给出定义和证明特定实现的正确性，则可以用证明搜索器来搜索和使用通用人工智能的实现，这个证明搜索器就是一个通用人工智能的实现，搜索器搜索到通用人工智能所需的时间是一个极大的常数，这个常数是证明搜索器做为通用人工智能的启动常数的一部分。\n\n但在搜索出来之前，并不知道存在某种具体实现是能证明正确性的，这里需要注意，可能能证明存在性，但不能对任意一个实例证明它是存在性的实例。\n\n给出的形式定义也依赖人的经验，不保证正确性；如果形式定义有误，需要人发现和修改，无法 \"消除人类的必要性\"。\n\n基于永久存活的定义中，由于我们对环境特性不够了解，以及判断永久存活需要无限长时间的观测，通用人工智能的存在性和正确性很可能是不可证的，而基于理想环境中优化长期奖励的定义看起来更容易证明。\n\n对于哥德尔机而言，通用人工智能的复杂性转移到了判断什么样的修改在未来对自己有利，也就是 \"什么样的修改是好的？\"，其余部分的设计都是比较平凡的。我们认为哥德尔机的问题也在于没解决这个问题，靠一个初始公理系统去直接证明修改后的模型比修改前的模型能获得更大的预期回报，这样的设计过于低效，甚至不一定正确，因为文章没有给出一个可以计算在所有环境中期望预期回报的公理系统的具体实现。\n\n如果我们知道了如何判断什么是好的，则由全局最优性定理，只需要一个保证完备性的搜索所有可能的程序的证明搜索器（探索机制），再判断修改是不是好的，如果是好的则应用该修改（学习机制），就可以实现通用人工智能。\n\n# 9. Q.A.\n\n1. Q：形式化证明是否在现实世界中有意义？\n\n\tA：有意义，你需要将不确定性以及概率方面的公理，以及现实世界的性质引入哥德尔机。\n\n2. Q：哥德尔机会不会使用一个自毁的自修改？哥德尔机会不会直接通过修改自己的奖励函数获得巨大的奖励？\n\n\tA：哥德尔机只会证明一个自修改会增加当前的奖励函数下的最大预期奖励时才会使用。如果哥德尔机的自修改可能导致自毁，则这里使用了概率相关的公理，模型有概率自毁，有概率获得更大的预期奖励。如果哥德尔机修改了自己的奖励函数，则使用新的奖励函数一定可以增加模型原有的奖励函数下的最大预期奖励。\n\n3. Q：自动证明非常难，哥德尔机该如何工作？\n\n\tA：现在人类工作大量使用自动证明搜索器，因为证明和程序是等价的，所以神经网络也可以看做是一种证明搜索器。这些已有的证明搜索器基本上都不是 $O()$-最优的，他们是设计来处理具体任务的，在具体任务上有较小的启动常数，但是在设计范围外的任务上可能需要无限大的启动常数。\n\n4. Q：\"没有免费的午餐定理\" 是否说明不存在通用的问题求解器？\n\n\tA：不是，\"没有免费的午餐定理\" 构造了一种特殊的问题，这种问题中数据有歧义，通常处理的问题都不会有这样差的性质。这种问题上人类也无法取得好的表现。\n\n# 10.结论\n\n模型的自进步性一直被认为是重要的，如图灵 [2] 发现与其花费极大量的计算资源去设计成千上万个功能性模块，不如直接设计一个人类婴儿，让其在环境中学习，这样的性质就是自进步性 [3]，也就是学习。学习的重要性是显而易见的，随着环境变化，模型如果无法学习，则一定会被环境淘汰。如果通过一直修改人工智能的功能模块来实现通用人工智能，则需要人类永远存活。\n\n之后科学家发现，学习算法的好坏是显著影响模型效果的，神经网络从最初算力要求过大，被支持向量机等模型打败，经过算力以及模型结构，训练 trick 等进步，变成目前最广泛使用的模型。但我们认为神经网络模型的学习算法是本质弱的，通用人工智能需要一个足够强的学习算法。对这个学习算法而言，与其花费极大量计算资源去直接设计这个学习算法，不如直接设计一个通用的元学习。\n\n但是现在人工智能方面的研究反而不追求通用性，很多模型是针对具体任务设计的，无法在其他任务上工作，剩下一些模型虽然可以将任何输入输出内容转化为序列，通过序列预测来通用地解决任务，但这些模型没有足够的元学习能力，无法学习到一个足够复杂的学习算法，因此无法解决非平凡的任务，如程序生成，自动证明等。现在针对通用模型的研究主要都在通过加 trick 的方式提高模型表现，比如使用更高质量的数据，使用人的评价来强化学习（RLHF）等。我们认为这些 trick 对类似哥德尔机的通用人工智能也是有帮助的，可以降低模型的启动常数，但是使用这些 trick 去增强一个不完备的模型（如神经网络）是不合理的，应该先设计出完备的模型，后使用这些 trick 去训练完备的模型。\n\n哥德尔机是一个有不分层元学习设计的模型，是 $O()$-最优 的学习算法，但我们认为哥德尔机的设计并没有完全解决通用人工智能的复杂性，因为其启动常数过高，同时公理系统 $\\mathcal A$ 的设计非平凡但作者未给出。尽管如此，我们依然认为哥德尔机是一个非常有意义的模型，是人工智能的重要里程碑。\n\n不分层的元学习模型虽然不会遇到分层中的那些问题，但是会将复杂性全部转移到学习中。学习不只是需要对我们已有的任务和数据进行学习，还需要对模型学习过程中生成的任意复杂的结构进行学习。解决了学习的问题等价于写出了通用人工智能的代码，而学习的问题在于什么是好的，如果模型可以判断什么是好的，则可以选择对自己有利的修改，逐步变强。\n\n到底什么是好的呢？小编也很想知道。目前我们只有几个比较模糊的设计，并且补全细节后也不能完全解决这个问题。\n\n# 11.摇人\n\n大家如果对相关内容感兴趣，可以加群：756872300 来讨论。\n\n# 12.引用\n\n[1] Jürgen Schmidhuber (2006). Goedel Machines: Self-Referential \nUniversal Problem Solvers Making\nProvably Optimal Self-Improvements https://arxiv.org/pdf/cs/0309048v5.pdf\n\n[2] Turing, A. M. (1950). Computing machinery and intelligence. Mind, 59, 433–460. https://doi.org/10.1093/mind/LIX.236.433\n\n[3] McCarthy, J., Minsky, M. L., Rochester, N. & Shannon, C. E. (1955). A PROPOSAL FOR THE DARTMOUTH SUMMER RESEARCH PROJECT ON ARTIFICIAL INTELLIGENCE http://www-formal.stanford.edu/jmc/history/dartmouth/dartmouth.html .", "description": "由于你不会设计哥德尔机，所以你决定先做一道数据结构题：\n\n给定一个长度为 $n$ 的序列 $a_1\\cdots a_n$。你需要回答 $m$ 个询问，第 $i$ 个询问给定一个区间 $[l_i,r_i]$，请你求出这个区间中所有非空子集的最大公约数的乘积。由于答案可能很大，每次询问请你求出其对 $998244353$ 取模的结果。", "inputFormat": "第一行两个正整数 $n,m$，含义同题目描述。\n\n接下来一行 $n$ 个正整数描述序列 $a_1\\cdots a_n$。\n\n接下来 $m$ 行，第个 $i$ 行是 $l_i,r_i$，描述第 $i$ 个询问。", "outputFormat": "输出 $m$ 行，对于每个询问输出询问答案对 $998244353$ 取模的结果。", "hint": "Idea：ouuan&lk，Solution：ccz181078，Code：ouuan&lk，Data：ouuan&lk\n\n对于 $10\\%$ 的数据，满足 $n,m\\le10$。\n\n对于另外 $10\\%$ 的数据，满足 $n,m\\le1000$。\n\n对于另外 $20\\%$ 的数据，满足 $1\\le a_i\\le1000$。\n\n对于另外 $10\\%$ 的数据，满足对所有 $1\\le i<n$，$l_i\\le l_{i+1}\\le 10^5$ 且 $r_i\\le r_{i+1}\\le 10^5$\n\n对于另外 $20\\%$ 的数据，满足 $1\\le a_i\\le30000$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m,a_i\\le 10^5$，$1\\le l_i\\le r_i\\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2002] Goedel Machine", "background": "# 1.前言\n\n哥德尔机 [1] 是由 LSTM 之父 Jürgen Schmidhuber 提出的一种可学习的通用问题求解器。本文将对该模型进行描述与讨论，并且说明这个模型拥有许多重要的性质，这些性质是我们认为通用人工智能所必需的。\n\n# 2.相关概念\n\n## 学习\n\n学习指模型对模型自身的参数（同一个模型在参数不同时有不同的行为）进行修改。用于对自己进行修改的方法叫做学习算法。\n\n## 元学习\n\n元学习指模型拥有通过学习修改自己的学习算法的能力。有大量证据指示人类拥有比较强的元学习的能力。\n\n### 元学习分层\n\n不可学习的方法没有学习能力，比如解决 OI 题的程序，坦克世界的固定线路看到人就停车的脚本等。\n\n常见的机器学习方法，比如朴素的神经网络方法没有元学习能力，因为学习算法是不可学习的梯度下降算法。支持向量机没有元学习能力，因为学习算法是确定的，等。\n\n专门设计了元学习特性的神经网络有元学习能力，但是没有元元学习能力，也就是说不能对学习自己学习算法的算法进行学习。\n\n假设你想设计一种学习算法：\n\n初始时，你想让你的算法可学习，于是设计了初始的学习算法。\n\n然后你想让你的初始学习算法可学习，于是设计了元学习算法。\n\n然后你想让你的元学习算法可学习，于是设计了元元学习算法。\n\n这样每一步你都必须设计新的学习算法，用于之前的学习算法的学习。设计第 $i$ 层的学习算法时，这个学习算法可以优化前 $i-1$ 层，但是对第 $i$ 层的优化需要第 $i+1$ 层后的方法。分层不是必需的，这里分层是人为设计的，因为你人为设计了分层结构，所以你需要设计无限层的元学习算法。\n\n一直这样递归下去可以发现现有机器学习方法的一个问题：因为不能人工设计无限层的元学习算法，所以在某一层之后一定不可学习。这样会导致人工设计可以一直让模型变强，因为设计了第 $i$ 层元学习的模型不会比只设计了前 $i-1$ 层元学习的模型弱，但是这个过程永不收敛。这样的模型不具备一种**不可改进性**，即在给定足量的计算资源下，这个模型是最优的。\n\n哥德尔机以及类似的构造尝试将所有层级的元学习用同一个东西去泛化，将任意层的元学习问题变成一层普通的学习问题。要实现这样的功能，我们需要一个足够强的优化器。弱的优化器，比如梯度下降的神经网络，面临的问题是无法使用梯度下降去优化模型梯度下降的过程，也就是说无法直接用学习算法去处理元学习层面的优化。于是元学习特性需要人为设计，也就是说需要设计优化元学习任务的优化器，而这样会导致该优化器无法用已设计好的方法优化，需要继续设计新的对应的优化算法。这样分层的元学习需要无限的设计，是神经网络方法最大的问题之一。\n\n### 不分层元学习/无限层元学习\n\n哥德尔机没有元学习分层的设计，因为其架构会将所有优化问题用同样的方法优化，并且该优化方法可以优化自身，所以哥德尔机拥有不分层的元学习能力，或者可以叫做无限层元学习的能力。在给定足量的计算资源下，哥德尔机不弱于任何其它可计算的机器学习模型。\n\n实际上存在一些元学习算法是递归的，即存在一种元学习算法，第 $i$ 层可以对前 $i-1$ 层进行优化，且对任意 $i$，这个算法都是相同的，所以只需要有限的人为设计。我们认为这类方法是有一些问题的，不如不分层的元学习算法，这里不展开讨论。\n\n元学习和学习实际上不可区分，这个会在后续进行讨论。\n\n## 强化学习\n\n模型与环境交互并优化由环境提供的奖励。\n\n### 马尔可夫决策过程\n\n时间被分为一些离散的时间步，模型每个时刻从环境中获取输入信息（包括环境提供的奖励），并能从有限种对环境的操作中选一部分执行，环境由这一时刻的状态以及模型采取的操作计算出环境下一时刻的状态。\n\n## 通用人工智能/完全人工智能/人工广义智能\n\n这些词语是 Artificial General Intelligence 的中文翻译，该词语代表一个可以在各个领域达到人类顶尖水平甚至超越的人工智能模型。\n\n通用人工智能**没有准确的定义**，不同人对通用人工智能应该有什么样的能力看法不同。\n\n## 自编程/自修改/自进步\n\n这三个词语指模型的一种能力，有这种能力的模型可以通过修改自己来提升自己的表现。一般提升表现指可以在监督学习任务中通过更多的数据，或在强化学习任务中获得更大的预期奖励。\n\n## 自指\n\n一个模型是完全自指的，表示某个模型可以在内部描述自己的所有性质。虽然人类不是一个完全自指的模型，但是人类可以描述关于自己的部分性质。\n\n自指常用于构建悖论，如：\n\n1. \"这句话是错的\" 是对的还是错的？\n\n2. 罗素悖论：一个理发师只给不理自己头发的人理发，那这个理发师是否给自己理发？\n\n3. 停机问题：一个图灵机如果判定出自己停机，则不停机。\n\n4. 哥德尔不完备性定理。\n\n哥德尔机是一个可以完全自指的模型。哥德尔机的作者认为 \"意识\" 的本质是自指，即模型可以意识到自己的存在。哥德尔机的学习算法可以完全自指，也就是说可以用学习算法处理学习算法的学习，甚至完全覆写掉初始的学习算法。\n\n## 可计算性\n\n程序在不限制空间并且不限制字长时，能在有限时间内完成处理的问题是可计算的问题所构成的集合。\n\n## 图灵机\n\n本文中我们直接把 图灵机 当成 C++ 语言写成的代码，不限制空间并且不限制字长。\n\n### 通用图灵机\n\n用 C++ 语言显然可以模拟执行 C++ 语言。假设我们写出了一份 C++ 语言代码 A，用于执行任何其它 C++ 语言写出的代码。则当我们想执行 C++ 代码 B 时，可以将 B 做为 A 的输入，并执行 A。这样的代码 A 叫做 通用图灵机。\n\n## 不可区分性\n\n有许多人类设计的分层结构是不可区分的，如：\n\n1. 数据与程序不可区分：这里我们顺便解释中文房间悖论。中文房间指给定一个黑箱，将一个不会中文的人和一个翻译器一起放入。在房间外的人向内部提供中文文章，内部的人将文章输入翻译器后直接得到翻译后的结果，并将结果输出，此时从外部看来，无法判定内部的人是否会中文。这个悖论实际上等价于：现在有一个通用图灵机，以及一份通用人工智能的代码。如果我们将通用图灵机看做模型（程序），将通用人工智能看做数据进行执行（对于通用图灵机而言，一个图灵机的程序可以是数据，并且做为数据的程序可以被执行），则这里可以认为这个通用图灵机在给定数据下是一个通用人工智能。也就是说我们可以将非平凡的部分：通用人工智能，在程序和数据两边任意转移，但必须在某一边解决这个本质问题。\n\n2. 监督学习的数据和模型的先验（初始引入的知识）不可区分，强化学习的人类知识和模型的 reward 不可区分：监督学习模型的 loss 函数可以内嵌任意复杂的信息，包括数据集中的所有信息，这种情况下模型的 loss 是模型的先验的一部分。强化学习模型 reward 函数可以内嵌任意复杂的信息，包括关于环境的先验，以及人类知识。如 AlphaGo 算法中使用了 MCTS 搜索算法做为探索先验，这样的先验（搜索）就是一种人类知识。\n\n3. 模型关于自己的先验与模型关于环境的先验不可区分：这个在后续会进行讨论。\n\n4. 学习和元学习不可区分：假设模型分为学习算法和模型主体部分，学习算法经过学习后被修改了，则这里可以看做是元学习。但如果将整个模型做为一个整体来看待，学习实际上改变了模型的一些参数，是普通的学习。从学习和元学习不可区分也可以看出对元学习人为分层是不自然的，应该将元学习的优化视为普通学习处理。\n\n由于不可区分性，一般来说我们用功能而不是具体的结构来衡量模型的能力。比如对于中文房间悖论，可以认为一个有翻译器的人类就是懂得中文的，因为和懂得中文的人表现一致，一个没有翻译器的人类是不懂得中文的。\n\n同理，由于不可区分性，对于“理解”和“意识”的讨论都是无意义的，因为我们用功能而不是具体的结构来衡量模型的能力。\n\n# 3.简介\n\n几乎所有已知的用于解决问题的算法（包括证明搜索器，监督学习，强化学习等）都在元学习方面有欠缺，理由在元学习分层中有描述。人类需要一直不断地设计新的更好的算法（有更多层元学习的算法），并且提供计算资源对这些算法进行测试。\n\n如何才能消除人类的必要性？为了方便描述，我们定义了学习，学习指模型对模型自身的参数进行修改。对自己进行修改的方法叫做学习算法。最简单的想法就是让机器可以进行任意复杂的学习，也就是说学习方法需要足够强，比如从所有可计算的程序中选出一个最高效的学习算法，利用这个学习算法修改自己。\n\n为了解决这个问题，作者设计了一类最优的，完全自指的，通用的问题求解器——哥德尔机。哥德尔机与一个部分可观测的环境交互，并且原则上可以无限制地修改自身（学习），唯一的限制是哥德尔机自己的可计算性。哥德尔机的初始算法有能力完全重写自己，这样的重写能力保证哥德尔机是全局最优的。\n\n## 哥德尔机的结构\n\n哥德尔机主要包含公理系统、证明搜索程序、行为程序、目标函数。\n\n# 4.环境和形式化目标\n\n模型的环境处在一个人为设计的硬件中，该硬件可以是通用图灵机，空间有限的图灵机，或抽象的电子计算机。模型是单例的，只有唯一一个同时存在。模型的生命包含一些离散的时间步：$1,2,\\dots$，模型的生命在 $T$ 时刻结束，这个时刻可能对模型而言不可见。任何一个时变的变量 $Q$ 在 $t$ 时刻的值可以记作 $Q(t)$。\n\n每一步时间我们的硬件执行一个基本操作，改变硬件的状态 $s$，为不失一般性，$s\\in \\mathcal S \\in B^*$，$B^*$ 表示所有可能的二进制串。每一步时间环境状态可能发生变化，环境状态用 $Env$ 表示，$Env\\in \\mathcal E$，$\\mathcal E$ 表示考虑的环境的集合，这个会在后续进行讨论。硬件有硬编码的转移方程：$F:\\mathcal S\\times \\mathcal E \\rightarrow \\mathcal S$。对任何 $t>1$，$s(t)=F(s(t-1),Env(t-1))$ 表示当前 $t-1$ 个时刻都结束后，$t$ 时刻还没开始时硬件的状态。\n$Env(t)$ 表示 $t$ 时刻的环境，由 $s(t-1)$ 中描述环境变化的变量与环境交互得到，如果环境是随机的，则这里按对应概率进行采样。\n\n定义四个特殊的变量：$time,x,y,p$：\n\n1. $time$ 表示当前时刻。\n2. $x$ 表示环境对哥德尔机的输入，对任意 $t>1$，$x(t)\\neq x(t-1)$ 可能发生当且仅当哥德尔机输出了一个特定字符串，表示向环境请求输入。这样就可以避免每个时刻只有常数的计算资源，导致不能对输入完全观测（比如复制整个输入所需的计算资源比每个时刻的计算资源多）。\n3. $y$ 表示哥德尔机对环境的输出，$y(t)$ 表示一个二进制串。输出可能对环境产生影响，比如输出一个控制指令，指令操作环境中的一个机器人，或者指令打开电视机。\n4. $p(1)$ 表示最初哥德尔机的软件，也就是根据环境输入计算出对环境输出的计算过程。初始的 $p(1)$ 可以用一个图灵机表示，所以不是最优的。\n\n每一个时刻 $1\\le t\\le T$ 模型的目标是最大化预期回报。对于一个确定的 $s$ 和 $Env$，奖励函数可以写做：$u(s,Env):\\mathcal S\\times \\mathcal E\\rightarrow \\mathcal R$，$u(s,Env)=E_{\\mu} \\bigg [\\sum _{\\tau=time} ^T  r(\\tau)\\bigg | s,Env \\bigg ]$，其中 $\\mathcal R$ 表示实数，$r(t)$ 表示 $t$ 时刻获得的实数表示的奖励。$E_{\\mu}\\big(\\cdot \\big|\\cdot\\big)$ 表示条件期望，其中 $\\mu$ 表示所有可能的环境。\n\n这里需要注意到 $s$ 表示的也是模型的内环境，因为硬件行为完全由模型决定，$Env$ 表示外部环境，$time=time(s)$ 表示 $s$ 状态所在时刻。\n\n可以同时修改奖励函数使得模型倾向于选择更低方差的改进。绝大部分计算机科学的问题都可以用这个设计形式化。\n\n# 5.哥德尔机的基本思想\n\n为了让我们的硬件变成一个有自指能力的哥德尔机，需要设计对应的软件（也就是可运行代码） $p$，该软件需要有修改自己的能力。初始的代码 $p(1)$ 有一个目前不是最优的问题求解器 $e(1)$，用于和环境交互，这个问题求解器可以是任何传统的强化学习算法，同时还有一个通用的证明搜索器，证明搜索器持续地搜索二元组 (程序，证明） 直到对一个 程序 A，搜索到了一个 证明 B，表明：将搜索到的这个程序 A 直接用于修改 $p$ 后得到的程序的预期回报比修改前的 $p$ 更大。之后模型会使用 程序 A 对 $p$ 进行修改，这个修改不止对 $e$ 有效，同时可能影响到 $p$ 中的证明搜索器。\n\n## 自修改公理\n\n在 $t_1$ 时刻，我们使用搜索到的程序 A 来修改 $s(t_1)$ 当且仅当搜索到了证明 B，表示：$u[A(s(t_1)),Env(t_1)]>u[s(t_1),Env(t_1)]$。硬件状态 $s$ 包含了软件 $p$，用 $A(s(t_1))$ 表示用程序 A 对 $t_1$ 时刻的模型的软件进行学习。\n\n哥德尔机还需要引入大量其它的公理才能变得足够强，比如关于环境的公理，以及概率相关的公理。我们使用 $\\mathcal A$ 来表示一个足够强的哥德尔机的公理系统。\n\n## 哥德尔不完备定理\n\n我们说一个公理系统是一致的，当且仅当对任意命题 $P$，$P$ 和 非 $P$ 这两个命题不能同时在这个公理系统下被证明。\n\n哥德尔不完备定理指的是：任何一个公理系统，如果是一致的，并且能定义自然数，与自然数的加法，乘法和等于，则一定存在一个命题 $P$，$P$ 和 非 $P$ 在这个公理系统中不可证明。\n\n## 哥德尔机的局限性与优势\n\n哥德尔不完备性定理使得对任意一个足够强的公理系统，一定存在不可证的命题。哥德尔不完备定理不会导致哥德尔机弱，因为如果存在某个对哥德尔机有用的命题，但是这个命题在哥德尔机的公理系统下是不可证的，则对人而言，这个命题在同一个公理系统下也是不可证的，人也无法利用这个命题。\n\n哥德尔机更大的局限性在于，在现实环境中，时间和空间资源是有限的，如果哥德尔机的初始公理设计不够好，会导致即使其拥有极大量资源，也无法搜索出足量有效的自修改程序，导致花费了极大量的资源后还是一个低效的搜索器。\n\n哥德尔机需要引入大量的概率相关的公理，因为有限时间的观测只能产生有限的数据。有限的数据会导致任何证明都不能保证不会和后来的观测数据发生矛盾，所以只能给出证明的置信度，而不能保证证明一定正确。\n\n在一般的环境中，哥德尔机模型难以进行严格控制变量的实验，难以收集独立同分布的数据，难以短时间内发现环境在大时间尺度上的改变，这导致对概率的严格推断难以证明有用的结论，因此哥德尔机加入普通的概率公理可能也证明不出任何有用的东西。\n\n这样的问题导致哥德尔机不像是一个形式系统，不像一个证明搜索器，如果把初始的软件 $p$ 看做是一个模型初始的学习算法，自修改看做是学习，哥德尔机更像是一个程序搜索器。这种情况下，不一致或者过弱的公理系统对应一个不完备的初始学习算法，比如神经网络。\n\n哥德尔机的优势在于，哥德尔机可以对自己的初始算法进行任意的改动，并且现有的其它方法都无法做到这一点，比如神经网络无法学习自己的梯度下降学习法，有元学习的神经网络无法学习自己的元学习算法，搜索器无法学习自己的搜索策略等。这里的本质区别是哥德尔机的学习比这些模型强，强到可以完全复写掉初始的学习算法，而其它模型只能修改初始学习算法的一部分。\n\n# 6.全局最优性定理\n\n## 自修改公理与全局最优\n\n对任何形式化的奖励函数 $u$，假设哥德尔机公理 $\\mathcal A$ 是一致的，则任何自修改公理推出的自修改程序 $p$ 是全局最优的：在执行自修改 $p$ 之前哥德尔机的最大预期回报比执行 $p$ 之后的低。\n\n这里的自修改看上去像是一种贪心算法，每次贪心地向更优的方向改进，为什么是全局最优呢？我们可以证明满足自修改公理的程序 $p$ 是对当前哥德尔机的状态而言，所有可能的程序里最优的一个修改。\n\n证明的思路其实很简单，考虑搜索到 $p$ 后，哥德尔机可以采取的两种方案：\n\n1. 执行自修改程序 $p$。\n\n2. 不执行自修改程序 $p$，继续搜索其它程序执行。\n\n第二种方案考虑到了未来会搜索到的所有程序，而哥德尔机证明了第一种方案比第二种方案优，所以程序 $p$ 是在公理 $\\mathcal A$ 下，所有程序中最优的一个。\n\n在实践中，这里的最优性应该需要考虑搜索到每个程序的期望代价，比如存在一些自修改，效果比 $p$ 更好，但是搜索到这些自修改需要大量时间，或是执行了自修改 $p$ 后模型可以更快地搜索到其它自修改。也正是因为这些原因，所以哥德尔机证明了执行自修改 $p$ 后有更大的预期回报。\n\n## $O()$-最优性\n\n哥德尔机在任何任务上是 $O()$-最优 的，即与可以证明理论最优的解（如果存在）只在计算资源消耗上差常数倍。这是因为哥德尔机的初始算法即可保证搜索所有程序和证明是 $O()$-最优 的，哥德尔机是不可能比初始算法弱的，所以也是 $O()$-最优 的。\n\n$O()$-最优性 不是一个很强的性质，假设有一个问题，这个问题的最优解是 程序 A，则一个 $O()$-最优 的模型只需要花费常数的计算资源代价搜索到 程序 A，并且证明这个程序比之前模型给出的解优，就可以实现 $O()$-最优。比较两个证明搜索器时也是类似的，一个证明搜索器可以花费常数时间搜索到另一个并证明最优。\n\n$O()$-最优 的优化器需要一个极大的常数启动，这样的优化器最开始效果很差，需要搜索极长时间才可以变得足够强。我们认为这个过程和自然中的进化类似，并在后文讨论二者的相关性。\n\n# 7.bias-optimal searcher（给定先验下最优的搜索器）\n\nbias-optimal searcher（给定先验下最优的搜索器）的定义：\n\n给定先验概率 $P(p|r)$ 表示问题 $r$ 应该选取解 $p$ 的概率。\n\n黑盒函数可以在 $t(p,r)$ 的时间内判断问题 $r$ 是否有解 $p$。\n\nbias-optimal searcher 在有限时间 $T$ 内，对任意问题 $r$，如果有解 $p$ 满足 $t(p,r)\\le P(p|r)\\times T$ 则能求出问题的一个解。\n\nnear-bias-optimal searcher 则放宽条件到 $t(p,r)\\le P(p|r)\\times T/n$，$n>1$ 是近似比。bias-optimal searcher 有 Optimal Ordered Problem Solver 等已知的构造，这里不做相关解释。\n\n这里搜索器关心的是如何按给定先验分配计算资源，$p$ 可以是程序，$t$ 是程序运行用时。\n\n哥德尔机只需要使用一个 bias-optimal searcher 做为初始证明搜索器，则是 $O()$-最优 的，因为 bias-optimal searcher 是 $O()$-最优 的。\n\n# 8.哥德尔机的缺陷和相关讨论\n\n## 预测而不是证明\n\n考虑到有限的交互导致对环境认知的不确定性，从有限的与环境交互的历史中，不应该能证明无限长时间内可靠的环境性质。\n\n如果尝试构造一个比原有公理系统强的形式系统并用其进行证明，就无法证明新的形式系统的一致性，只能用有限的经验来支持这个新的形式系统是有用的（例如在发现矛盾前暂时正常使用）。\n\n如果尝试增加对环境的假设，那么加入这个假设可以得到新的形式系统，但这个假设不能用初始的公理系统证明，同上。\n\n从这个角度看，利用证明对环境进行推断，和一般的元学习是类似的。这里的证明其实不如说是一种基于已有数据对未来的预测。\n\n另一方面，形式系统可以证明一些关于无穷的命题，这些命题不能从有限的数据中得到，但可能产生可验证且有用的推论。\n\n如果这样的构造是有用的，初始学习算法应该能构造出这样的形式系统并用其进行证明，但不会认为形式系统是绝对可靠的。\n\n从这个角度看，形式系统和一般的程序是类似的。\n\n## 计算资源限制\n\n哥德尔机考虑的是理想环境，模型存活 $T$ 时间，最优化的是在存活的时间内奖励的和。\n\n### 有限存活时间\n\n有限存活时间会限制模型，导致模型无法到达全局最优。\n\n由于哥德尔机的低效性，从现实的角度看，我们认为目前可以提供的算力不够让哥德尔机优化到足够强，甚至无法搜索到任何一个可证明的改进。\n\n对于存活时间有限的情况，实际上哥德尔机很难在有限的数据下，给出对所有可能的环境在 $T$ 时刻内的收益期望，除非对环境有过强的假设。因为哥德尔机设计的最大预期回报需要对所有可能的环境，求出该环境出现的概率，并且加权计算出期望奖励。可能的环境有限显然是一个过强的假设，因为这会导致模型不图灵完备，退化成一个 DFA。而当可能的环境无限的情况下，无法在有限时间内计算这个期望。\n\n就算写出了满足文中描述特性的哥德尔机的代码，在对环境没有过强的假设下，因为预期回报不可计算，该哥德尔机在有限的计算资源下只会卡在第一步操作上，之后消耗光计算资源。或是有一些修改可以不需要计算预期回报，比如将 `a=a+1` 改写为 `++a`，但在对环境没有过强假设的情况下，哥德尔机很难证明一个稍微复杂的修改是更优的。\n\n### 无限存活时间\n\n无限存活时间会导致奖励函数失效，因为无限长的时间会导致奖励函数 $u(s,Env)=E_{\\mu} \\bigg [\\sum _{\\tau=time} ^\\infty r(\\tau)\\bigg | s,Env \\bigg ]$ 无界。两个期望无穷的预期奖励是不可比较的，这也是为什么已有强化学习方法都会设立奖励衰减因子，因为这样的方法可以让 每个状态的预期奖励 有界。无限存活时间还可能导致每个时刻的奖励 $r(\\tau)$ 也是无界的。\n\n对于存活时间无限的情况，模型实际上不能只优化奖励，还需要优化自己的存活和计算资源，因为如果需要人类提供无限的计算资源，则模型不能脱离人类，无法 \"消除人类的必要性\"。\n\n## 启动低效\n\n如果引入大量概率方面的先验进入公理系统，并且可以让预期回报可计算，哥德尔机还是会面临启动过于低效的问题。\n\n简单设计的通用方法，例如哥德尔机和其它一些 $O()$-最优 的证明搜索方法，通常需要非常长的时间后才能变得足够优。\n\n例如，解决特定任务的最优方法需要 $t$ 时间，但通用方法需要 $a+t\\times b$ 的时间，其中 $a$ 是极大的常数，我们将其定义为：**启动常数**，用于在启动阶段找出这个最优方法，$b$ 是模拟执行这个最优方法的常数代价（这个一般不严重，合理假设下可以做到 $b=1$）。\n\n为了得到实用的通用方法，主要的设计复杂性在于降低启动常数 $a$。\n因此，需要首先构造一个简单的通用方法，允许较大的启动常数 $a$；然后，通过具体设计来降低 $a$。\n\n### 进化\n\n进化是一种自然地生成任意复杂的结构的过程。进化生成的生物也可以通过影响环境从而在环境中生成任意复杂的结构。进化的过程和已知的优化过程区别很大，已知的优化过程都有明确的目的性，如神经网络方法通过梯度下降优化模型的 loss，强化学习方法优化模型的最大预期回报等。进化没有在优化任何预设的目标，可以从两个不同的角度看待进化：\n\n1. 进化是一个在确定规则下沿时间轴演化的动力系统。进化没有任何目的性，但是可以生成任意复杂的结构。在这个角度下，我们可以认为没有智能体，只有一个不断演化的环境，但是环境的演化足够复杂，使得其中可以生成任意复杂的结构，如生命游戏。从一些例子中可以看到进化的复杂性，如：如何才能在宇宙中生成一块会飞的金块？进化先在环境中生成了人类，然后人类制作了旅行者号探测器，里面携带了一块人类制作的纯金的碟片，而这其中人类以及金的生成如果展开来讲也是一个极其复杂的过程。遗传算法之所以不是进化，也是因为遗传算法无法在环境中构建任意复杂的结构，并且遗传算法无法模拟生物之间复杂的交互作用。\n\n2. 进化是智能体不断和环境交互的过程：其中进行计算或和环境交互会减少自己的计算资源，可以从环境中获取计算资源。当智能体计算资源为 $0$ 时死亡，需要优化自己存活时间。智能体和环境的边界不可区分。智能体可以将除了自己以外的其它智能体也视为环境的一部分，对其它智能体的建模，如博弈论之类的方法，是将这些智能体看做是环境中比较容易预测的一部分，并研究这一部分环境相关的特性。从这里可以看出智能体和环境是不可区分的，智能体在环境中的边界是模糊的，例如：人吃环境中的饭，吃下去的饭是否属于人的一部分；人是否是环境中人的种群的一部分；人造出了机器人，机器人是人通过对环境进行操作后得到的，是否属于人的一部分。\n\n人类是经过了极长时间进化后产生的复杂结构，如果将进化看做是生成通用人工智能的方法，则进化像生成一块会飞的金块一样生成通用人工智能：通过先生成人类后生成这些复杂结构。生成人类的过程就是上述的极大的启动常数 $a$，通过对模型引入合适的人为设计的先验，同时不破坏完备性，这样应该可以得到一个只需要较小启动的常数，便可以在绝大部分任务上达到较优的通用人工智能。\n\n### 神经网络不完备\n\n神经网络是对模型引入人为设计的先验，但是破坏了完备性的一个例子。完备性被破坏导致神经网络不能通用地解决所有问题，但是可以以很低的启动常数解决一些特定的问题。\n\n神经网络不完备指的是：\n\n1. 搜索的计算图受限。神经网络搜索的是一类比较静态的计算图，虽然有一些动态的尝试，如 MoE 类的方法，Transformer 稀疏化，外置内存类的方法（类似神经图灵机），但是能搜索到的程序空间依然受限。神经网络虽然是图灵完备的，但是静态计算图会导致计算低效，如使用 Transformer 模型计算乘法需要做很长的自回归，输出乘法的中间结果，而实际上的乘法只需要很小的计算量即可完成。神经网络由于其结构固定，无法通过搜索来对结构进行改进。关于神经网络架构搜索（元学习）相关的内容会在后文讨论。\n\n2. 无法遍历状态空间。常见的梯度下降方法都需要让学习率逐步下降，否则训练无法收敛，这样会导致每次随机初始化后模型只能探索到状态空间中很小的一部分。更好的一种神经网络类方法是随机初始化大量神经网络，将其均训练到收敛，之后用于测试时，对这些神经网络的结果取平均或最大似然。这样可以降低模型的方差，因为可以更广泛地探索状态空间。\n\n3. 元学习能力受限。朴素的神经网络方法基于梯度下降，每一步的学习率确定，没有元学习能力。而有元学习特性的神经网络也只是对梯度下降的参数进行学习，甚至无法比较大地修改自己的学习算法。神经网络方法对已知形式的问题效果不错，因为加入了大量专门解决这类问题的人为设计的 trick。但是元学习对应的问题是未知的，神经网络学习能力受限会导致其无法对这些未知结构的问题进行好的学习，而无法对元学习进行好的学习会导致神经网络能力学习更受限。\n\n现在研究神经网络的算法工程师们希望通过神经网络实现通用人工智能，并且一直在设计更为通用的模型，但是我们认为这样的方式是不合理的。\n\n试想一个 Transformer 模型，为了优化平方代价的 attention，假设实现了一种优秀的 attention 策略，该策略允许我们每次只访问 $O(1)$ 个位置的 attention，就可以获取原本需要 $\\Theta(n)$ 个位置的 attention 才能获得的信息。假设这样的 Transformer 模型学到了正确的硬的内存访问，并且训练和测试不分离，也就是说模型的训练方式也是强的，不局限于梯度下降，不会发生灾难性遗忘，并且可以常数代价模拟任何动态计算图，则这样的模型是通用人工智能。\n\n这个模型中神经网络的部分则会退化为一个 for，因为 Transformer 是一个一直增长的函数式内存，每次只需要做常数规模的计算，并且从内存中取出 $O(1)$ 个位置的信息，并写下 $O(1)$ 的信息，真正的复杂性转移到了该如何设计优秀的 attention 策略，以及如何训练上。\n\n我们认为自动数学证明和自动代码生成是足够复杂的任务，在这两个任务上远远超越人类表现的模型应该可以像哥德尔机一样，探索可能有效的改进，并且通过证明以及自编程来修改自己。\n\n最近神经网络类方法取得了很好的进展，如 AI 绘画，AlphaCode，ChatGPT，DreamerV3 等，以我们的知识，我们认为他们无法通过神经网络实现通用人工智能，因为所有这一切模型的学习算法都是本质性地弱的，并且难以改进。\n\n希望本文中给出的推理有误，他们可以实现通用人工智能，实现无数人梦寐以求的技术。\n\n## 什么是好的？\n\n如果对通用人工智能，可以给出定义和证明特定实现的正确性，则可以用证明搜索器来搜索和使用通用人工智能的实现，这个证明搜索器就是一个通用人工智能的实现，搜索器搜索到通用人工智能所需的时间是一个极大的常数，这个常数是证明搜索器做为通用人工智能的启动常数的一部分。\n\n但在搜索出来之前，并不知道存在某种具体实现是能证明正确性的，这里需要注意，可能能证明存在性，但不能对任意一个实例证明它是存在性的实例。\n\n给出的形式定义也依赖人的经验，不保证正确性；如果形式定义有误，需要人发现和修改，无法 \"消除人类的必要性\"。\n\n基于永久存活的定义中，由于我们对环境特性不够了解，以及判断永久存活需要无限长时间的观测，通用人工智能的存在性和正确性很可能是不可证的，而基于理想环境中优化长期奖励的定义看起来更容易证明。\n\n对于哥德尔机而言，通用人工智能的复杂性转移到了判断什么样的修改在未来对自己有利，也就是 \"什么样的修改是好的？\"，其余部分的设计都是比较平凡的。我们认为哥德尔机的问题也在于没解决这个问题，靠一个初始公理系统去直接证明修改后的模型比修改前的模型能获得更大的预期回报，这样的设计过于低效，甚至不一定正确，因为文章没有给出一个可以计算在所有环境中期望预期回报的公理系统的具体实现。\n\n如果我们知道了如何判断什么是好的，则由全局最优性定理，只需要一个保证完备性的搜索所有可能的程序的证明搜索器（探索机制），再判断修改是不是好的，如果是好的则应用该修改（学习机制），就可以实现通用人工智能。\n\n# 9. Q.A.\n\n1. Q：形式化证明是否在现实世界中有意义？\n\n\tA：有意义，你需要将不确定性以及概率方面的公理，以及现实世界的性质引入哥德尔机。\n\n2. Q：哥德尔机会不会使用一个自毁的自修改？哥德尔机会不会直接通过修改自己的奖励函数获得巨大的奖励？\n\n\tA：哥德尔机只会证明一个自修改会增加当前的奖励函数下的最大预期奖励时才会使用。如果哥德尔机的自修改可能导致自毁，则这里使用了概率相关的公理，模型有概率自毁，有概率获得更大的预期奖励。如果哥德尔机修改了自己的奖励函数，则使用新的奖励函数一定可以增加模型原有的奖励函数下的最大预期奖励。\n\n3. Q：自动证明非常难，哥德尔机该如何工作？\n\n\tA：现在人类工作大量使用自动证明搜索器，因为证明和程序是等价的，所以神经网络也可以看做是一种证明搜索器。这些已有的证明搜索器基本上都不是 $O()$-最优的，他们是设计来处理具体任务的，在具体任务上有较小的启动常数，但是在设计范围外的任务上可能需要无限大的启动常数。\n\n4. Q：\"没有免费的午餐定理\" 是否说明不存在通用的问题求解器？\n\n\tA：不是，\"没有免费的午餐定理\" 构造了一种特殊的问题，这种问题中数据有歧义，通常处理的问题都不会有这样差的性质。这种问题上人类也无法取得好的表现。\n\n# 10.结论\n\n模型的自进步性一直被认为是重要的，如图灵 [2] 发现与其花费极大量的计算资源去设计成千上万个功能性模块，不如直接设计一个人类婴儿，让其在环境中学习，这样的性质就是自进步性 [3]，也就是学习。学习的重要性是显而易见的，随着环境变化，模型如果无法学习，则一定会被环境淘汰。如果通过一直修改人工智能的功能模块来实现通用人工智能，则需要人类永远存活。\n\n之后科学家发现，学习算法的好坏是显著影响模型效果的，神经网络从最初算力要求过大，被支持向量机等模型打败，经过算力以及模型结构，训练 trick 等进步，变成目前最广泛使用的模型。但我们认为神经网络模型的学习算法是本质弱的，通用人工智能需要一个足够强的学习算法。对这个学习算法而言，与其花费极大量计算资源去直接设计这个学习算法，不如直接设计一个通用的元学习。\n\n但是现在人工智能方面的研究反而不追求通用性，很多模型是针对具体任务设计的，无法在其他任务上工作，剩下一些模型虽然可以将任何输入输出内容转化为序列，通过序列预测来通用地解决任务，但这些模型没有足够的元学习能力，无法学习到一个足够复杂的学习算法，因此无法解决非平凡的任务，如程序生成，自动证明等。现在针对通用模型的研究主要都在通过加 trick 的方式提高模型表现，比如使用更高质量的数据，使用人的评价来强化学习（RLHF）等。我们认为这些 trick 对类似哥德尔机的通用人工智能也是有帮助的，可以降低模型的启动常数，但是使用这些 trick 去增强一个不完备的模型（如神经网络）是不合理的，应该先设计出完备的模型，后使用这些 trick 去训练完备的模型。\n\n哥德尔机是一个有不分层元学习设计的模型，是 $O()$-最优 的学习算法，但我们认为哥德尔机的设计并没有完全解决通用人工智能的复杂性，因为其启动常数过高，同时公理系统 $\\mathcal A$ 的设计非平凡但作者未给出。尽管如此，我们依然认为哥德尔机是一个非常有意义的模型，是人工智能的重要里程碑。\n\n不分层的元学习模型虽然不会遇到分层中的那些问题，但是会将复杂性全部转移到学习中。学习不只是需要对我们已有的任务和数据进行学习，还需要对模型学习过程中生成的任意复杂的结构进行学习。解决了学习的问题等价于写出了通用人工智能的代码，而学习的问题在于什么是好的，如果模型可以判断什么是好的，则可以选择对自己有利的修改，逐步变强。\n\n到底什么是好的呢？小编也很想知道。目前我们只有几个比较模糊的设计，并且补全细节后也不能完全解决这个问题。\n\n# 11.摇人\n\n大家如果对相关内容感兴趣，可以加群：756872300 来讨论。\n\n# 12.引用\n\n[1] Jürgen Schmidhuber (2006). Goedel Machines: Self-Referential \nUniversal Problem Solvers Making\nProvably Optimal Self-Improvements https://arxiv.org/pdf/cs/0309048v5.pdf\n\n[2] Turing, A. M. (1950). Computing machinery and intelligence. Mind, 59, 433–460. https://doi.org/10.1093/mind/LIX.236.433\n\n[3] McCarthy, J., Minsky, M. L., Rochester, N. & Shannon, C. E. (1955). A PROPOSAL FOR THE DARTMOUTH SUMMER RESEARCH PROJECT ON ARTIFICIAL INTELLIGENCE http://www-formal.stanford.edu/jmc/history/dartmouth/dartmouth.html .", "description": "由于你不会设计哥德尔机，所以你决定先做一道数据结构题：\n\n给定一个长度为 $n$ 的序列 $a_1\\cdots a_n$。你需要回答 $m$ 个询问，第 $i$ 个询问给定一个区间 $[l_i,r_i]$，请你求出这个区间中所有非空子集的最大公约数的乘积。由于答案可能很大，每次询问请你求出其对 $998244353$ 取模的结果。", "inputFormat": "第一行两个正整数 $n,m$，含义同题目描述。\n\n接下来一行 $n$ 个正整数描述序列 $a_1\\cdots a_n$。\n\n接下来 $m$ 行，第个 $i$ 行是 $l_i,r_i$，描述第 $i$ 个询问。", "outputFormat": "输出 $m$ 行，对于每个询问输出询问答案对 $998244353$ 取模的结果。", "hint": "Idea：ouuan&lk，Solution：ccz181078，Code：ouuan&lk，Data：ouuan&lk\n\n对于 $10\\%$ 的数据，满足 $n,m\\le10$。\n\n对于另外 $10\\%$ 的数据，满足 $n,m\\le1000$。\n\n对于另外 $20\\%$ 的数据，满足 $1\\le a_i\\le1000$。\n\n对于另外 $10\\%$ 的数据，满足对所有 $1\\le i<n$，$l_i\\le l_{i+1}\\le 10^5$ 且 $r_i\\le r_{i+1}\\le 10^5$\n\n对于另外 $20\\%$ 的数据，满足 $1\\le a_i\\le30000$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m,a_i\\le 10^5$，$1\\le l_i\\le r_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P9061", "type": "P", "difficulty": 7, "samples": [["5 6\n1 2\n3 1\n5 1\n3 5\n4 4\n1 4 2 5 4\n1 4 3 5 3\n2 3 5 1 3\n2 2 3 1 4\n1 3 3 1 4\n2 5 5 2 1", "4\n3\n0\n0\n0\n0"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2002", "O2优化", "Ynoi"], "title": "[Ynoi2002] Optimal Ordered Problem Solver", "background": "", "description": "给定 $n$ 个点 $(x_i,y_i)_{i=1}^n$，你需要按顺序处理 $m$ 次操作。每次操作给出 $o,x,y,X,Y$，\n\n- 首先进行修改：\n  - 若 $o=1$ 则将满足 $x_i\\le x,\\;y_i\\le y$ 的点的 $y_i$ 修改为 $y$；\n  - 若 $o=2$ 则将满足 $x_i\\le x,\\;y_i\\le y$ 的点的 $x_i$ 修改为 $x$。\n- 然后进行查询，询问满足 $x_i\\le X,\\;y_i\\le Y$ 的点数。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $n$ 行每行两个整数 $x_i,y_i$。\n\n接下来 $m$ 行每行五个整数 $o,x,y,X,Y$，表示一次操作。", "outputFormat": "共 $m$ 行，每行一个整数，依次表示每次操作进行的查询的答案。", "hint": "Idea：ccz181078，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n对于所有数据，$1 \\le n,m \\le 10^6$，$1\\le x_i,y_i,x,y,X,Y\\le n$。\n\n子任务 1（20 分）：$n,m\\le 10^3$；\n\n子任务 2（20 分）：$x_i,y_i,x,y,X,Y$ 独立地在 $1$ 到 $n$ 内均匀随机选取；\n\n子任务 3（20 分）：$o=1$；\n\n子任务 4（20 分）：$n,m\\le 3\\times 10^5$，依赖子任务 1；\n\n子任务 5（20 分）：无特殊限制，依赖子任务 1、2、3、4。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2002] Optimal Ordered Problem Solver", "background": "", "description": "给定 $n$ 个点 $(x_i,y_i)_{i=1}^n$，你需要按顺序处理 $m$ 次操作。每次操作给出 $o,x,y,X,Y$，\n\n- 首先进行修改：\n  - 若 $o=1$ 则将满足 $x_i\\le x,\\;y_i\\le y$ 的点的 $y_i$ 修改为 $y$；\n  - 若 $o=2$ 则将满足 $x_i\\le x,\\;y_i\\le y$ 的点的 $x_i$ 修改为 $x$。\n- 然后进行查询，询问满足 $x_i\\le X,\\;y_i\\le Y$ 的点数。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $n$ 行每行两个整数 $x_i,y_i$。\n\n接下来 $m$ 行每行五个整数 $o,x,y,X,Y$，表示一次操作。", "outputFormat": "共 $m$ 行，每行一个整数，依次表示每次操作进行的查询的答案。", "hint": "Idea：ccz181078，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n对于所有数据，$1 \\le n,m \\le 10^6$，$1\\le x_i,y_i,x,y,X,Y\\le n$。\n\n子任务 1（20 分）：$n,m\\le 10^3$；\n\n子任务 2（20 分）：$x_i,y_i,x,y,X,Y$ 独立地在 $1$ 到 $n$ 内均匀随机选取；\n\n子任务 3（20 分）：$o=1$；\n\n子任务 4（20 分）：$n,m\\le 3\\times 10^5$，依赖子任务 1；\n\n子任务 5（20 分）：无特殊限制，依赖子任务 1、2、3、4。", "locale": "zh-CN"}}}
{"pid": "P9062", "type": "P", "difficulty": 7, "samples": [["5 5\n2 4\n1 1\n3 3\n5 1\n4 2\n1 5\n2 3\n2 4\n3 5\n1 3", "2\n8\n8\n2\n2"], ["2 1\n1 1\n1 1\n1 2", "0"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2002", "O2优化", "Ynoi"], "title": "[Ynoi2002] Adaptive Hsearch&Lsearch", "background": "", "description": "有 $n$ 个点 $p_1,p_2,\\dots,p_n$ 在二维平面上。\n\n有 $q$ 次询问，在第 $i$ 个询问中，给定两个数 $l_i,r_i$ ($1\\leq l_i< r_i\\leq n$)，你需要找到一对 $(u,v)$ 满足 $l_i\\leq u<v\\leq r_i$，$p_u$ 和 $p_v$ 之间的欧几里得距离 $\\sqrt{(x_u-x_v)^2+(y_u-y_v)^2}$ 最小。", "inputFormat": "第一行两个数 $n,q$ 表示点数以及询问数。\n\n之后 $n$ 行，第 $i$ 行包含两个整数 $x_i,y_i$ 表示 $p_i$ 的坐标。\n\n之后 $q$ 行，第 $i$ 行包含两个整数 $l_i,r_i$ ($1\\leq l_i< r_i\\leq n$) 表示第 $i$ 个询问。", "outputFormat": "对每个询问，输出一行一个整数表示最小的 $(x_u-x_v)^2+(y_u-y_v)^2$。", "hint": "Idea：Claris，Solution：Claris，Code：Claris，Data：Claris&nzhtl1477\n\n对于 $100\\%$ 的数据，满足 $2 \\leq n\\leq 250\\,000$, $1\\leq q\\leq 250\\,000$，$1\\leq x_i,y_i\\leq 10^8$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi2002] Adaptive Hsearch&Lsearch", "background": "", "description": "有 $n$ 个点 $p_1,p_2,\\dots,p_n$ 在二维平面上。\n\n有 $q$ 次询问，在第 $i$ 个询问中，给定两个数 $l_i,r_i$ ($1\\leq l_i< r_i\\leq n$)，你需要找到一对 $(u,v)$ 满足 $l_i\\leq u<v\\leq r_i$，$p_u$ 和 $p_v$ 之间的欧几里得距离 $\\sqrt{(x_u-x_v)^2+(y_u-y_v)^2}$ 最小。", "inputFormat": "第一行两个数 $n,q$ 表示点数以及询问数。\n\n之后 $n$ 行，第 $i$ 行包含两个整数 $x_i,y_i$ 表示 $p_i$ 的坐标。\n\n之后 $q$ 行，第 $i$ 行包含两个整数 $l_i,r_i$ ($1\\leq l_i< r_i\\leq n$) 表示第 $i$ 个询问。", "outputFormat": "对每个询问，输出一行一个整数表示最小的 $(x_u-x_v)^2+(y_u-y_v)^2$。", "hint": "Idea：Claris，Solution：Claris，Code：Claris，Data：Claris&nzhtl1477\n\n对于 $100\\%$ 的数据，满足 $2 \\leq n\\leq 250\\,000$, $1\\leq q\\leq 250\\,000$，$1\\leq x_i,y_i\\leq 10^8$。", "locale": "zh-CN"}}}
{"pid": "P9063", "type": "P", "difficulty": 1, "samples": [["5\n2\n3\n4\n6\n9", "No\nYes\nNo\nNo\nYes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "洛谷月赛"], "title": "[yLOI2023] 分解只因数", "background": "", "description": "给定一个正整数 $n$，对 $n$ 分解质因数。\n\n设 $n = p_1 \\times p_2 \\times p_3 \\times \\dots \\times p_x$，其中 $p_i$ 均为质数。\n\n如果 $p_i$ 均为奇数，则称 $n$ 为『只因数』。\n\n现在，给出若干个 $n$，请你判断 $n$ 是不是『只因数』。", "inputFormat": "**本题单测试点内有多组测试数据**。\n\n第一行是一个整数，表示数据组数 $T$。\n\n接下来 $T$ 行，每行一个整数，表示一组数据的 $n$。", "outputFormat": "对每组数据，输出一行一个字符串。如果 $n$ 是『只因数』，请输出 `Yes`，否则输出 `No`。", "hint": "### 数据规模与约定\n\n本题共有 $10$ 个测试点。对第 $i$ 个测试点，$T = \\max(1, i - 1)$。\n\n- 对 $30\\%$ 的数据，$n \\leq 3$。\n- 对 $50\\%$ 的数据，$n \\leq 10$。\n- 另有 $10\\%$ 的数据，$n$ 为奇数。\n- 另有 $10\\%$ 的数据，$n$ 为偶数。\n- 对 $90\\%$ 的数据，$n \\leq 10^9$。\n- 对 $100\\%$ 的数据，$1 \\leq T \\leq 9$，$2 \\leq n \\leq 10^{18}$。\n\n### 说明\n\n本题共有两个附加样例文件，见题目附件中的 `ibvl.zip`。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[yLOI2023] 分解只因数", "background": "", "description": "给定一个正整数 $n$，对 $n$ 分解质因数。\n\n设 $n = p_1 \\times p_2 \\times p_3 \\times \\dots \\times p_x$，其中 $p_i$ 均为质数。\n\n如果 $p_i$ 均为奇数，则称 $n$ 为『只因数』。\n\n现在，给出若干个 $n$，请你判断 $n$ 是不是『只因数』。", "inputFormat": "**本题单测试点内有多组测试数据**。\n\n第一行是一个整数，表示数据组数 $T$。\n\n接下来 $T$ 行，每行一个整数，表示一组数据的 $n$。", "outputFormat": "对每组数据，输出一行一个字符串。如果 $n$ 是『只因数』，请输出 `Yes`，否则输出 `No`。", "hint": "### 数据规模与约定\n\n本题共有 $10$ 个测试点。对第 $i$ 个测试点，$T = \\max(1, i - 1)$。\n\n- 对 $30\\%$ 的数据，$n \\leq 3$。\n- 对 $50\\%$ 的数据，$n \\leq 10$。\n- 另有 $10\\%$ 的数据，$n$ 为奇数。\n- 另有 $10\\%$ 的数据，$n$ 为偶数。\n- 对 $90\\%$ 的数据，$n \\leq 10^9$。\n- 对 $100\\%$ 的数据，$1 \\leq T \\leq 9$，$2 \\leq n \\leq 10^{18}$。\n\n### 说明\n\n本题共有两个附加样例文件，见题目附件中的 `ibvl.zip`。", "locale": "zh-CN"}}}
{"pid": "P9064", "type": "P", "difficulty": 2, "samples": [["5 3\n1 2 3 4 5", "2"], ["6 4\n1 7 8 3 4 6", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "洛谷月赛"], "title": "[yLOI2023] 苦竹林", "background": "> 悬挂在屋檐下的风铃，摇晃的声音很动听。  \n> 思念就像梅雨下不停，我的心境一片泥泞。  \n> 散落在天际里的繁星，闪烁着你我的宿命。  \n> 当枫叶轻盈落入湖心，近看山水一片宁静。  \n\n——银临 & 涵昱《苦竹林》", "description": "共有 $n$ 个风铃悬挂在屋檐下，每个风铃都能发出一定音调的声音。从左到右给风铃从 $1$ 至 $n$ 编号，第 $i$ 个风铃的音调是 $a_i$。\n\n为了表达内心的思念，扶苏决定在 $n$ 个的风铃中取出 $m$ 个，送给远方的朋友。\n\n请你找到最小的整数 $\\varepsilon$，使得存在一种方案，能够从 $n$ 个风铃中挑出 $m$ 个，设挑出风铃的音调为 $b_1, b_2, \\dots b_m$，满足对任意的 $1 \\leq i, j \\leq m$，都有 $|b_i - b_j| \\leq \\varepsilon$。", "inputFormat": "第一行是两个整数，表示风铃的个数 $n$ 和挑选出风铃的个数 $m$。  \n第二行有 $n$ 个整数，表示每个风铃的音调。第 $i$ 个整数表示 $a_i$。", "outputFormat": "输出一行一个整数，表示最小的 $\\varepsilon$。", "hint": "### 样例 2 解释\n\n一种选择的方案是选择第 $2,4,5,6$ 四个风铃，音调依次为 $7,3,4,6$。可以得到对任何的 $1 \\leq i, j\\leq 4$，都有 $|b_i - b_j| \\leq 4$。\n\n另一种方案是选择第 $2,3,5,6$ 四个风铃，同样计算得到的 $\\varepsilon$ 为 $4$。\n\n### 数据规模与约定\n\n- 对 $10\\%$ 的数据，$m = 2$。\n- 另有 $10\\%$ 的数据，$m = n$。\n- 对 $40\\%$ 的数据，$n \\leq 5$。\n- 对 $60\\%$ 的数据，保证对所有的 $2 \\leq i \\leq n$，满足 $a_{i - 1} \\leq a_i$，即 $a_i$ 单调不降。\n- 对 $80\\%$ 的数据，$n \\leq 10^3$。\n- 对 $100\\%$ 的数据，$2 \\leq m \\leq n \\leq 10^5$，$1 \\leq a_i \\leq 10^9$。\n\n### 说明\n\n本题共有三个附加样例文件，见题目附件中的 `ring.zip`。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[yLOI2023] 苦竹林", "background": "> 悬挂在屋檐下的风铃，摇晃的声音很动听。  \n> 思念就像梅雨下不停，我的心境一片泥泞。  \n> 散落在天际里的繁星，闪烁着你我的宿命。  \n> 当枫叶轻盈落入湖心，近看山水一片宁静。  \n\n——银临 & 涵昱《苦竹林》", "description": "共有 $n$ 个风铃悬挂在屋檐下，每个风铃都能发出一定音调的声音。从左到右给风铃从 $1$ 至 $n$ 编号，第 $i$ 个风铃的音调是 $a_i$。\n\n为了表达内心的思念，扶苏决定在 $n$ 个的风铃中取出 $m$ 个，送给远方的朋友。\n\n请你找到最小的整数 $\\varepsilon$，使得存在一种方案，能够从 $n$ 个风铃中挑出 $m$ 个，设挑出风铃的音调为 $b_1, b_2, \\dots b_m$，满足对任意的 $1 \\leq i, j \\leq m$，都有 $|b_i - b_j| \\leq \\varepsilon$。", "inputFormat": "第一行是两个整数，表示风铃的个数 $n$ 和挑选出风铃的个数 $m$。  \n第二行有 $n$ 个整数，表示每个风铃的音调。第 $i$ 个整数表示 $a_i$。", "outputFormat": "输出一行一个整数，表示最小的 $\\varepsilon$。", "hint": "### 样例 2 解释\n\n一种选择的方案是选择第 $2,4,5,6$ 四个风铃，音调依次为 $7,3,4,6$。可以得到对任何的 $1 \\leq i, j\\leq 4$，都有 $|b_i - b_j| \\leq 4$。\n\n另一种方案是选择第 $2,3,5,6$ 四个风铃，同样计算得到的 $\\varepsilon$ 为 $4$。\n\n### 数据规模与约定\n\n- 对 $10\\%$ 的数据，$m = 2$。\n- 另有 $10\\%$ 的数据，$m = n$。\n- 对 $40\\%$ 的数据，$n \\leq 5$。\n- 对 $60\\%$ 的数据，保证对所有的 $2 \\leq i \\leq n$，满足 $a_{i - 1} \\leq a_i$，即 $a_i$ 单调不降。\n- 对 $80\\%$ 的数据，$n \\leq 10^3$。\n- 对 $100\\%$ 的数据，$2 \\leq m \\leq n \\leq 10^5$，$1 \\leq a_i \\leq 10^9$。\n\n### 说明\n\n本题共有三个附加样例文件，见题目附件中的 `ring.zip`。", "locale": "zh-CN"}}}
{"pid": "P9065", "type": "P", "difficulty": 4, "samples": [["4 4 2\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 1\n3 4", "3"], ["4 4 3\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 1\n2 4\n4 1", "4"], ["2 5 0\n1 0 3 3 4\n2 3 4 0 5", "7"], ["4 4 3\n1 1 1 0\n1 1 0 1\n1 0 1 1\n0 1 1 1\n1 1\n2 1\n3 3", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "洛谷月赛"], "title": "[yLOI2023] 云梦谣", "background": "> 归来且做云梦梦一场 大梦好  \n> 栽花闻酒香 醒醒醉醉笑笑  \n> 天地偌大复路远山高 最难得偷半日逍遥  \n> 偶尔糊涂不问世事不知晓\n\n——银临 & 慕寒《云梦谣》", "description": "“喂，枸杞，你这只笨狗，又偷吃！看我不收拾你！”\n\n朵一气呼呼地从院子里跑出来，手中握着掸子，而枸杞早已不见踪影。\n\n云梦庭可以看作一个 $n$ 行 $m$ 列的方格阵，第 $i$ 行第 $j$ 列的格子被记作 $(i,j)$。每个格子 $(i,j)$ 要么有一个高度 $h_{i,j}$（$h_{i,j}$ 为正整数），要么是障碍物，不能通过。（方便起见，约定障碍物的 $h_{i,j}$ 用 $0$ 表示。）另外，云梦庭上有 $k$ 个指定的格子上可以进行**御剑飞行**。开始时，朵一和枸杞分别位于方格 $(1,1)$ 和 $(n,m)$。\n\n朵一的御剑飞行还不是很熟练，现在她还控制不好御剑的高度。因此在任意时刻，朵一在方格 $(i,j)$ 上可以做如下行动之一：\n\n- 移动到与该方格相邻的方格 $(i-1,j)$、$(i+1,j)$、$(i,j-1)$、$(i,j+1)$ 之一上（不能移动出方格边界，也不能移动到障碍物上）；\n- 如果方格 $(i,j)$ 上允许御剑飞行，则朵一可以御剑飞行至另一个**同样允许御剑飞行且与方格 $(i,j)$ 高度相等的方格上**；\n- 使用仙法将当前格子的高度 $h_{i,j}$ 改变为任一正整数。\n\n进行上述每项行动均需花费 $1$ 个单位时间。\n\n“哼，笨狗子你再跑！”说罢，朵一便追了出去。朵一接下来还要尽快继续今天的修行，因此她想知道到达 $(n,m)$ 格子所需的最短时间是多少。", "inputFormat": "输入的第一行有三个整数，依次表示方格阵的行数 $n$、列数 $m$ 和能御剑飞行的方格个数 $k$。  \n接下来 $n$ 行，每行 $m$ 个整数，其中第 $i$ 行的第 $j$ 个数表示方格 $(i,j)$ 的高度 $h_{i,j}$。数据保证 $h_{1,1}$ 和 $h_{n,m}$ 不为 $0$。  \n接下来 $k$ 行，每行两个整数 $x$ 和 $y$，表示一个允许御剑飞行的方格的坐标 $(x, y)$。数据保证这 $k$ 个方格的坐标互不相同。", "outputFormat": "一行一个整数，表示朵一到达 $(n,m)$ 所需的最小时间。如果朵一无法到达，输出 ```-1```。", "hint": "### 样例 1 解释\n\n第 $1$ 个单位时间，朵一将当前方格 $(1,1)$ 的高度修改为 $4$；  \n第 $2$ 个单位时间，朵一从方格 $(1,1)$ 御剑飞行至 $(3,4)$；  \n第 $3$ 个单位时间，朵一从方格 $(3,4)$ 移动到 $(4,4)$，追上了枸杞。\n\n### 样例 2 解释\n\n第 $1$ 个单位时间，朵一从方格 $(1,1)$ 御剑飞行至 $(4,1)$；  \n第 $2$ 个单位时间，朵一从方格 $(4,1)$ 移动到 $(4,2)$；  \n第 $3$ 个单位时间，朵一从方格 $(4,2)$ 移动到 $(4,3)$；  \n第 $4$ 个单位时间，朵一从方格 $(4,3)$ 移动到 $(4,4)$，追上了枸杞。\n\n### 数据规模与约定\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f2epmv84.png)\n\n对全部的测试点，保证 $1 \\leq n, m \\leq 3 \\times 10^3$，$0 \\leq k,h_{i,j} \\leq n \\times m$。\n### 提示\n\n请注意大量数据读入对程序效率造成的影响，选择合适的读入方式，避免超时。\n\n### 说明\n\n本题共有 5 个附加样例文件，见附件里的 dream.zip。\n\n### 后记\n\n不过，别看朵一现在一副生气的样子，可当她追上枸杞后，大抵是不舍得真的动手吧。“嘿嘿，今日的修行结束后，该吃什么好呢？”在这飞瀑悬挂、翠竹怀抱的云梦庭中，修仙炼体，不羡尘嚣，应是这世上最逍遥的事了。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[yLOI2023] 云梦谣", "background": "> 归来且做云梦梦一场 大梦好  \n> 栽花闻酒香 醒醒醉醉笑笑  \n> 天地偌大复路远山高 最难得偷半日逍遥  \n> 偶尔糊涂不问世事不知晓\n\n——银临 & 慕寒《云梦谣》", "description": "“喂，枸杞，你这只笨狗，又偷吃！看我不收拾你！”\n\n朵一气呼呼地从院子里跑出来，手中握着掸子，而枸杞早已不见踪影。\n\n云梦庭可以看作一个 $n$ 行 $m$ 列的方格阵，第 $i$ 行第 $j$ 列的格子被记作 $(i,j)$。每个格子 $(i,j)$ 要么有一个高度 $h_{i,j}$（$h_{i,j}$ 为正整数），要么是障碍物，不能通过。（方便起见，约定障碍物的 $h_{i,j}$ 用 $0$ 表示。）另外，云梦庭上有 $k$ 个指定的格子上可以进行**御剑飞行**。开始时，朵一和枸杞分别位于方格 $(1,1)$ 和 $(n,m)$。\n\n朵一的御剑飞行还不是很熟练，现在她还控制不好御剑的高度。因此在任意时刻，朵一在方格 $(i,j)$ 上可以做如下行动之一：\n\n- 移动到与该方格相邻的方格 $(i-1,j)$、$(i+1,j)$、$(i,j-1)$、$(i,j+1)$ 之一上（不能移动出方格边界，也不能移动到障碍物上）；\n- 如果方格 $(i,j)$ 上允许御剑飞行，则朵一可以御剑飞行至另一个**同样允许御剑飞行且与方格 $(i,j)$ 高度相等的方格上**；\n- 使用仙法将当前格子的高度 $h_{i,j}$ 改变为任一正整数。\n\n进行上述每项行动均需花费 $1$ 个单位时间。\n\n“哼，笨狗子你再跑！”说罢，朵一便追了出去。朵一接下来还要尽快继续今天的修行，因此她想知道到达 $(n,m)$ 格子所需的最短时间是多少。", "inputFormat": "输入的第一行有三个整数，依次表示方格阵的行数 $n$、列数 $m$ 和能御剑飞行的方格个数 $k$。  \n接下来 $n$ 行，每行 $m$ 个整数，其中第 $i$ 行的第 $j$ 个数表示方格 $(i,j)$ 的高度 $h_{i,j}$。数据保证 $h_{1,1}$ 和 $h_{n,m}$ 不为 $0$。  \n接下来 $k$ 行，每行两个整数 $x$ 和 $y$，表示一个允许御剑飞行的方格的坐标 $(x, y)$。数据保证这 $k$ 个方格的坐标互不相同。", "outputFormat": "一行一个整数，表示朵一到达 $(n,m)$ 所需的最小时间。如果朵一无法到达，输出 ```-1```。", "hint": "### 样例 1 解释\n\n第 $1$ 个单位时间，朵一将当前方格 $(1,1)$ 的高度修改为 $4$；  \n第 $2$ 个单位时间，朵一从方格 $(1,1)$ 御剑飞行至 $(3,4)$；  \n第 $3$ 个单位时间，朵一从方格 $(3,4)$ 移动到 $(4,4)$，追上了枸杞。\n\n### 样例 2 解释\n\n第 $1$ 个单位时间，朵一从方格 $(1,1)$ 御剑飞行至 $(4,1)$；  \n第 $2$ 个单位时间，朵一从方格 $(4,1)$ 移动到 $(4,2)$；  \n第 $3$ 个单位时间，朵一从方格 $(4,2)$ 移动到 $(4,3)$；  \n第 $4$ 个单位时间，朵一从方格 $(4,3)$ 移动到 $(4,4)$，追上了枸杞。\n\n### 数据规模与约定\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f2epmv84.png)\n\n对全部的测试点，保证 $1 \\leq n, m \\leq 3 \\times 10^3$，$0 \\leq k,h_{i,j} \\leq n \\times m$。\n### 提示\n\n请注意大量数据读入对程序效率造成的影响，选择合适的读入方式，避免超时。\n\n### 说明\n\n本题共有 5 个附加样例文件，见附件里的 dream.zip。\n\n### 后记\n\n不过，别看朵一现在一副生气的样子，可当她追上枸杞后，大抵是不舍得真的动手吧。“嘿嘿，今日的修行结束后，该吃什么好呢？”在这飞瀑悬挂、翠竹怀抱的云梦庭中，修仙炼体，不羡尘嚣，应是这世上最逍遥的事了。", "locale": "zh-CN"}}}
{"pid": "P9066", "type": "P", "difficulty": 5, "samples": [["4\n1 2 3 4\n2 3 1 4\n", "2 4 4 0"], ["5\n1 2 3 4 5\n5 3 2 1 4\n", "0 1 1 5 1"], ["5\n2 4 6 10 12\n5 3 1 4 2\n", "0 2 2 2 10"], ["7\n2 4 6 8 12 14 16\n5 3 2 6 1 4 7\n", "8 2 8 16 16 16 0"], ["7\n2 4 6 8 12 14 16\n7 1 6 3 5 4 2\n", "0 2 2 6 2 12 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "O2优化", "洛谷月赛"], "title": "[yLOI2023] 腐草为萤", "background": "> 于盛夏之末，入夜仍灼热。  \n> 又一场离合，开始凄恻。  \n> 是扇底闪躲，或雨水摧折。  \n> 哪里都值得，恋恋不舍。  \n\n——银临《腐草为萤》", "description": "夜幕降临，在树林中的一条平直的小径上，萤火虫们受到夜晚的呼唤，纷纷外出行动。\n\n将小径视作数轴，一开始，共计 $n$ 只萤火虫在数轴的一些整点上，从左到右依次标号为 $1 \\sim n$，第 $i$ 只萤火虫的初始坐标为 $x_i$。每个萤火虫有不同的亮度值，$i$ 号萤火虫的亮度为 $a_i$。\n\n在任意时刻，对任意存活的萤火虫 $i$，它会按如下规则飞行：\n\n- 在当前仍存活的萤火虫中，找到与 $i$ 相邻的萤火虫（可能是一只或两只）中亮度最大的一只，记其编号为 $j$。如果 $a_i < a_j$，则 $i$ 会朝着 $j$ 飞行，否则 $i$ 留在原地。\n- 这里两只萤火虫『相邻』的定义是：若两只萤火虫之间不存在任何仍存活的萤火虫，则它们相邻。\n- 萤火虫飞行的速度均为每秒一个单位长度。\n\n萤火虫生命短暂，当两只萤火虫相遇之时（即两个萤火虫的坐标相同时），亮度值较低的萤火虫将耗尽生命，在小径上消失。显然，最后只会剩余 $1$ 只萤火虫。对其余的每只萤火虫，请分别求出它们耗尽生命时的坐标。", "inputFormat": "第一行是一个整数，表示萤火虫数量 $n$。  \n第二行有 $n$ 个整数，第 $i$ 个整数表示标号为 $i$ 的萤火虫初始坐标 $x_i$。数据保证 $x_i$ 单调递增。  \n第三行有 $n$ 个整数，第 $i$ 个整数表示标号为 $i$ 的萤火虫的亮度值 $a_i$。数据保证亮度值互不相同。", "outputFormat": "输出一行 $n$ 个以单个空格隔开的整数，第 $i$ 个整数表示编号为 $i$ 的萤火虫生命耗尽时的坐标。如果 $i$ 号萤火虫最后存活下来了，则第 $i$ 个数输出 0。", "hint": "### 样例 1 解释\n\n- 在第一秒时，标号为 $1$ 的萤火虫向右移动，标号为 $2$ 的萤火虫位置不变，标号为 $3$ 的萤火虫向右移动，标号为 $4$ 的萤火虫位置不变。\n- 第二秒开始时，萤火虫 $1$ 遇到萤火虫 $2$，前者亮度更低，耗尽生命，此时其坐标为 $2$；萤火虫 $3$ 遇到萤火虫 $4$，前者亮度更低，耗尽生命，此时其坐标为 $4$。\n- 接下来，萤火虫 $2$ 向右移动，直到在坐标 $4$ 遇到萤火虫 $4$，耗尽生命。\n\n### 数据规模与约定\n\n- 对于 $5\\%$ 的数据，$n = 2$。\n- 对于 $30\\%$ 的数据，$n \\leq 100$，$x_i \\leq 200$。\n- 对于 $60\\%$ 的数据，$n \\leq 10^3$。\n- 另有 $5\\%$ 的数据，满足特殊约定 A。\n- 另有 $5\\%$ 的数据，满足特殊约定 B。\n- 对 $100\\%$ 的数据，保证 $2 \\leq n \\leq 5 \\times 10^5$，$1 \\leq x_i \\leq 10^9$，$1 \\leq a_i \\leq n$。且 $x_i < x_{i + 1}$，$a_i$ 是长度为 $n$ 的排列。\n\n其中：\n\n- 特殊约定 A：数列 $a$ 单调递增。  \n- 特殊约定 B：数列 $a$ 是单峰的，仅有一个极大值。即：存在 $p$ 满足 $1 \\leq p < n$，使得 $a_1 \\sim a_p$ 单调递增，$a_p \\sim a_n$ 单调递减.\n\n### 提示\n\n- **请注意大量数据的读入输出对程序效率造成的影响，选择合适的读入输出方式，避免超时**。\n- **请注意时间复杂度的常数因子对程序运行效率造成的影响**。\n\n### 说明\n\n本题共有 7 个附加样例文件，见题目附件中的 glowworm.zip。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[yLOI2023] 腐草为萤", "background": "> 于盛夏之末，入夜仍灼热。  \n> 又一场离合，开始凄恻。  \n> 是扇底闪躲，或雨水摧折。  \n> 哪里都值得，恋恋不舍。  \n\n——银临《腐草为萤》", "description": "夜幕降临，在树林中的一条平直的小径上，萤火虫们受到夜晚的呼唤，纷纷外出行动。\n\n将小径视作数轴，一开始，共计 $n$ 只萤火虫在数轴的一些整点上，从左到右依次标号为 $1 \\sim n$，第 $i$ 只萤火虫的初始坐标为 $x_i$。每个萤火虫有不同的亮度值，$i$ 号萤火虫的亮度为 $a_i$。\n\n在任意时刻，对任意存活的萤火虫 $i$，它会按如下规则飞行：\n\n- 在当前仍存活的萤火虫中，找到与 $i$ 相邻的萤火虫（可能是一只或两只）中亮度最大的一只，记其编号为 $j$。如果 $a_i < a_j$，则 $i$ 会朝着 $j$ 飞行，否则 $i$ 留在原地。\n- 这里两只萤火虫『相邻』的定义是：若两只萤火虫之间不存在任何仍存活的萤火虫，则它们相邻。\n- 萤火虫飞行的速度均为每秒一个单位长度。\n\n萤火虫生命短暂，当两只萤火虫相遇之时（即两个萤火虫的坐标相同时），亮度值较低的萤火虫将耗尽生命，在小径上消失。显然，最后只会剩余 $1$ 只萤火虫。对其余的每只萤火虫，请分别求出它们耗尽生命时的坐标。", "inputFormat": "第一行是一个整数，表示萤火虫数量 $n$。  \n第二行有 $n$ 个整数，第 $i$ 个整数表示标号为 $i$ 的萤火虫初始坐标 $x_i$。数据保证 $x_i$ 单调递增。  \n第三行有 $n$ 个整数，第 $i$ 个整数表示标号为 $i$ 的萤火虫的亮度值 $a_i$。数据保证亮度值互不相同。", "outputFormat": "输出一行 $n$ 个以单个空格隔开的整数，第 $i$ 个整数表示编号为 $i$ 的萤火虫生命耗尽时的坐标。如果 $i$ 号萤火虫最后存活下来了，则第 $i$ 个数输出 0。", "hint": "### 样例 1 解释\n\n- 在第一秒时，标号为 $1$ 的萤火虫向右移动，标号为 $2$ 的萤火虫位置不变，标号为 $3$ 的萤火虫向右移动，标号为 $4$ 的萤火虫位置不变。\n- 第二秒开始时，萤火虫 $1$ 遇到萤火虫 $2$，前者亮度更低，耗尽生命，此时其坐标为 $2$；萤火虫 $3$ 遇到萤火虫 $4$，前者亮度更低，耗尽生命，此时其坐标为 $4$。\n- 接下来，萤火虫 $2$ 向右移动，直到在坐标 $4$ 遇到萤火虫 $4$，耗尽生命。\n\n### 数据规模与约定\n\n- 对于 $5\\%$ 的数据，$n = 2$。\n- 对于 $30\\%$ 的数据，$n \\leq 100$，$x_i \\leq 200$。\n- 对于 $60\\%$ 的数据，$n \\leq 10^3$。\n- 另有 $5\\%$ 的数据，满足特殊约定 A。\n- 另有 $5\\%$ 的数据，满足特殊约定 B。\n- 对 $100\\%$ 的数据，保证 $2 \\leq n \\leq 5 \\times 10^5$，$1 \\leq x_i \\leq 10^9$，$1 \\leq a_i \\leq n$。且 $x_i < x_{i + 1}$，$a_i$ 是长度为 $n$ 的排列。\n\n其中：\n\n- 特殊约定 A：数列 $a$ 单调递增。  \n- 特殊约定 B：数列 $a$ 是单峰的，仅有一个极大值。即：存在 $p$ 满足 $1 \\leq p < n$，使得 $a_1 \\sim a_p$ 单调递增，$a_p \\sim a_n$ 单调递减.\n\n### 提示\n\n- **请注意大量数据的读入输出对程序效率造成的影响，选择合适的读入输出方式，避免超时**。\n- **请注意时间复杂度的常数因子对程序运行效率造成的影响**。\n\n### 说明\n\n本题共有 7 个附加样例文件，见题目附件中的 glowworm.zip。", "locale": "zh-CN"}}}
{"pid": "P9067", "type": "P", "difficulty": 6, "samples": [["4 5\n1 1 2\n3 1 1 1\n2 4\n1 1 1\n1 4 3\n2 4\n1 3 3", "2\n4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2022] 虚空处刑 TEST_105", "background": "我要对不死者先生你施展魔法，希望你能看到，更多美好的事物，希望你能见识到，更多我无法见识的事物，希望...你的心...不管几次都能苏——\n\n......\n\n你的魔法为时已晚了，和知道没有办法可以救你是一样的，仿佛就像是这什么都没有的天空一样啊——\n\n星星？\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1q0z7j3z.png)\n\n......\n\n星星呢？有个星形的星星飘在天上？\n\n像那种奇妙的东西啊，是超人机械的产物哦。\n\n......\n\n已不能，继续光顾着追求星星...\n\n不死者的本体的确不见得是在那颗星星上，我也知道他们大多是脱离常轨的危险任务，这些我都明白...\n\n但天上就是飘着那种星星啊，超人机械或许就在上面，史前的睿智肯定堆积如山。\n\n......\n\n星形的理由是个迷，也看不出任何工学上的必然性。但他若是以自然物为基础打造的，那这形状就说得通了。\n\n正确来说，我认为那是个群体，而不是单一生命体，且若它是生物，那就可预想它有着机械所没有的优点，像是自然修复损毁部位，透过增殖解决经年老化问题，甚至可能是以不需管理者为前提所打造的。\n\n目前我们还不理解它是用什么系统来维持飞行轨道，但高度应该是最佳环境不会错。\n\n连次元的墙壁都能跨越的超绝知性体，怎么可能将与自身相关的重要机构，放在区区三万六千公里高的天空上？\n\n你不觉得魔法是个很极端的东西吗？光用想的就能产生出热或质量，这实在太荒唐了，超越人智，犹如神般的存在姑且先不谈，一个小小的生命，人类的亚种，魔法使们怎么可能会有如此强大的力量？\n\n魔法使换句话说就是水龙头，水源则是另在别处。\n\n星星是超人机械所撒下的，供应魔力与抑制魔法的生命机器，除此以外可能什么都不是吧。\n\n......\n\n我们已经不做星星的梦了。\n\n魔法产生的原理，一旦被世人知道，就会引发末日战争。现在我们只能尽全力透过操控情报，让世人不对此事感兴趣。", "description": "给定一棵 $n$ 个节点的树，第 $i$ 个点有点权 $a_i$。\n\n定义一个点 $x$ 所在的极大同色连通块为一个**极大的**点集 $S$，满足 $x\\in S$，且对任意点集中的元素 $i,j$，可以找到一个节点序列 $p_1,p_2,...p_t$，满足 $p_1=i$，$p_t=j$，且对任意 $k$ 为 $[1,t)$ 中的整数，满足 $p_k$ 与 $p_{k+1}$ 在树上相邻，且 $a_{p_k}=a_{p_{k+1}}$，且 $p_k\\in S$。\n\n有 $m$ 次操作：\n\n`1 x y`：给出一个点 $x$ ，将其所在的极大同色连通块中每个点的点权修改为 $y$。\n\n`2 x`：给出一个点 $x$，查询其所在的极大同色连通块的大小。", "inputFormat": "第一行两个数 $n,m$。\n\n第二行 $n-1$ 个数，第 $i$ 个数表示树上第 $i+1$ 的节点的父亲节点的编号，保证父亲节点的编号比该节点小。\n\n第三行 $n$ 个数，第 $i$ 个数表示 $a_i$。\n\n之后 $m$ 行，每行形如 `1 x y` 或 `2 x`，意义如上述。", "outputFormat": "对每个 $2$ 操作，输出一行一个数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：ccz181078，Data：ccz181078\n\n对于 $20\\%$ 的数据，满足 $n,m\\leq2\\times 10^3$。\n\n对于 $40\\%$ 的数据，满足 $n,m\\leq2\\times 10^5$。\n\n对于另外 $30\\%$ 的数据，满足 $1\\le a_i,y\\le 2$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m,a_i,x,y\\le10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2022] 虚空处刑 TEST_105", "background": "我要对不死者先生你施展魔法，希望你能看到，更多美好的事物，希望你能见识到，更多我无法见识的事物，希望...你的心...不管几次都能苏——\n\n......\n\n你的魔法为时已晚了，和知道没有办法可以救你是一样的，仿佛就像是这什么都没有的天空一样啊——\n\n星星？\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1q0z7j3z.png)\n\n......\n\n星星呢？有个星形的星星飘在天上？\n\n像那种奇妙的东西啊，是超人机械的产物哦。\n\n......\n\n已不能，继续光顾着追求星星...\n\n不死者的本体的确不见得是在那颗星星上，我也知道他们大多是脱离常轨的危险任务，这些我都明白...\n\n但天上就是飘着那种星星啊，超人机械或许就在上面，史前的睿智肯定堆积如山。\n\n......\n\n星形的理由是个迷，也看不出任何工学上的必然性。但他若是以自然物为基础打造的，那这形状就说得通了。\n\n正确来说，我认为那是个群体，而不是单一生命体，且若它是生物，那就可预想它有着机械所没有的优点，像是自然修复损毁部位，透过增殖解决经年老化问题，甚至可能是以不需管理者为前提所打造的。\n\n目前我们还不理解它是用什么系统来维持飞行轨道，但高度应该是最佳环境不会错。\n\n连次元的墙壁都能跨越的超绝知性体，怎么可能将与自身相关的重要机构，放在区区三万六千公里高的天空上？\n\n你不觉得魔法是个很极端的东西吗？光用想的就能产生出热或质量，这实在太荒唐了，超越人智，犹如神般的存在姑且先不谈，一个小小的生命，人类的亚种，魔法使们怎么可能会有如此强大的力量？\n\n魔法使换句话说就是水龙头，水源则是另在别处。\n\n星星是超人机械所撒下的，供应魔力与抑制魔法的生命机器，除此以外可能什么都不是吧。\n\n......\n\n我们已经不做星星的梦了。\n\n魔法产生的原理，一旦被世人知道，就会引发末日战争。现在我们只能尽全力透过操控情报，让世人不对此事感兴趣。", "description": "给定一棵 $n$ 个节点的树，第 $i$ 个点有点权 $a_i$。\n\n定义一个点 $x$ 所在的极大同色连通块为一个**极大的**点集 $S$，满足 $x\\in S$，且对任意点集中的元素 $i,j$，可以找到一个节点序列 $p_1,p_2,...p_t$，满足 $p_1=i$，$p_t=j$，且对任意 $k$ 为 $[1,t)$ 中的整数，满足 $p_k$ 与 $p_{k+1}$ 在树上相邻，且 $a_{p_k}=a_{p_{k+1}}$，且 $p_k\\in S$。\n\n有 $m$ 次操作：\n\n`1 x y`：给出一个点 $x$ ，将其所在的极大同色连通块中每个点的点权修改为 $y$。\n\n`2 x`：给出一个点 $x$，查询其所在的极大同色连通块的大小。", "inputFormat": "第一行两个数 $n,m$。\n\n第二行 $n-1$ 个数，第 $i$ 个数表示树上第 $i+1$ 的节点的父亲节点的编号，保证父亲节点的编号比该节点小。\n\n第三行 $n$ 个数，第 $i$ 个数表示 $a_i$。\n\n之后 $m$ 行，每行形如 `1 x y` 或 `2 x`，意义如上述。", "outputFormat": "对每个 $2$ 操作，输出一行一个数表示答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：ccz181078，Data：ccz181078\n\n对于 $20\\%$ 的数据，满足 $n,m\\leq2\\times 10^3$。\n\n对于 $40\\%$ 的数据，满足 $n,m\\leq2\\times 10^5$。\n\n对于另外 $30\\%$ 的数据，满足 $1\\le a_i,y\\le 2$。\n\n对于 $100\\%$ 的数据，满足 $1\\le n,m,a_i,x,y\\le10^6$。", "locale": "zh-CN"}}}
{"pid": "P9068", "type": "P", "difficulty": 6, "samples": [["5\n3 1 2 1 5 \n1\n3 3", "3\n1"], ["6\n1 1 4 5 1 4\n3\n1 5\n1 1\n4 4", "3\n3\n3\n1"], ["15\n6 14 12 12 6 8 9 3 8 14 14 15 6 15 2 \n10\n12 13\n10 10\n14 9\n8 8\n11 11\n5 8\n1 6\n11 12\n2 13\n1 9", "23\n25\n29\n30\n24\n29\n29\n29\n24\n20\n20"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 51200, 51200, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 51200, 51200, 51200, 51200, 51200]}, "tags": ["2022", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2022] 超人机械 TEST_95", "background": "距今 300 年前，史前科学文明跨越了界限。出现了凌驾人类的人工智能，也就是超人机械。\n\n不为人知的诞生，等察觉到时，世界已经在【他】的手中了。\n\n究竟他身在何处，有什么样的外貌，虽然直到最后都没有人知道。但他好像可以出现在任何地方，化为任何样貌。\n\n既非敌对，也非压制，单纯只是力量上占上风而已。也不太常出手进行干涉。我想一定是人类对他来说无所谓吧。\n\n但即使如此，他还是会帮人实现愿望，魔人或魔龙，各式各样的不可思议，都是有人追求才被造出来的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qmrcnbwc.png)\n\n......\n\n然而在某一天，超人机械消失了。\n\n被腐铁菌干掉了，只是躲了起来，启程前往次元的另一端等，众说纷纭。留下的只有超人机械莫名其妙的发明品。和被世人自己弄得一团乱的世界。\n\n这座树海一定也是超人机械的产物。魔力会一下子增幅，一下子又消耗掉对吧？魔法是从异次元将力量取出的能力，是超出人类理解范围的技术。", "description": "给定一个序列 $a$ ，我们定义一个二元组 $(i,j)$ 为一个逆序对当且仅当 $i<j$ 且 $a_i>a_j$ 。定义两个逆序对 $(i_1,j_1),(i_2,j_2)$ **本质不同** 当且仅当 $a_{i_1}\\ne a_{i_2}$ 或 $a_{j_1}\\ne a_{j_2}$ 。\n\n现在给出 $a$ 序列，问本质不同逆序对个数。\n\n这还不够。\n\n现在有 $q$ 组修改，每一次修改形如 $x~y$ 表示修改 $a_x$ 为 $y$ ，每一次修改 **不互相独立** ，即这一次修改会影响到后面的所有修改。\n\n你需要对于每一次修改输出序列本质不同逆序对个数。\n\n为了体现本题的不同解法，本题不同测试点拥有不同的时空限制。", "inputFormat": "第一行一个整数 $n$ ，表示序列长度。\n\n第二行 $n$ 个整数 $a_i$ ，表示序列 $a$ 。\n\n第三行一个整数 $q$ ，表示询问组数。\n\n后面 $q$ 行每行两个整数表示一次修改。", "outputFormat": "一行一个整数，表示初始序列中本质不同逆序对个数。\n\n后面 $q$ 行每行一个整数，第 $i + 1$ 行表示第 $i$ 次修改后序列本质不同逆序对个数。", "hint": "Idea：DPair，Solution：DPair，Code：DPair，Data：DPair\n\n对于 $100\\%$ 的数据 $1\\le n \\le 10^5, 0\\le q \\le 10^5, 1\\le a_i, x, y \\le n$ 。\n\n以下为子任务：（留空部分表示无特殊限制）\n\n| 测试点编号 | $n$       | $q$       | $a_i,y$ | 特殊性质 | 时空限制 | 对应大样例 |\n| ---------- | --------- | --------- | ------- | -------- | -------- | ---------- |\n| 1-3        | $\\le2000$ | $\\le2000$ |         | A        | 1s/500MB | Sample1    |\n| 4-5        |           | $=0$      |         | A        | 1s/50MB  | Sample2    |\n| 6-10       |           |           |         | A        | 3s/500MB | Sample3    |\n| 11-15      |           |           |         |          | 3s/500MB |            |\n| 16-20      |           |           |         |          | 1s/50MB  |            |\n\n特殊性质 A：保证数据完全随机", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2022] 超人机械 TEST_95", "background": "距今 300 年前，史前科学文明跨越了界限。出现了凌驾人类的人工智能，也就是超人机械。\n\n不为人知的诞生，等察觉到时，世界已经在【他】的手中了。\n\n究竟他身在何处，有什么样的外貌，虽然直到最后都没有人知道。但他好像可以出现在任何地方，化为任何样貌。\n\n既非敌对，也非压制，单纯只是力量上占上风而已。也不太常出手进行干涉。我想一定是人类对他来说无所谓吧。\n\n但即使如此，他还是会帮人实现愿望，魔人或魔龙，各式各样的不可思议，都是有人追求才被造出来的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qmrcnbwc.png)\n\n......\n\n然而在某一天，超人机械消失了。\n\n被腐铁菌干掉了，只是躲了起来，启程前往次元的另一端等，众说纷纭。留下的只有超人机械莫名其妙的发明品。和被世人自己弄得一团乱的世界。\n\n这座树海一定也是超人机械的产物。魔力会一下子增幅，一下子又消耗掉对吧？魔法是从异次元将力量取出的能力，是超出人类理解范围的技术。", "description": "给定一个序列 $a$ ，我们定义一个二元组 $(i,j)$ 为一个逆序对当且仅当 $i<j$ 且 $a_i>a_j$ 。定义两个逆序对 $(i_1,j_1),(i_2,j_2)$ **本质不同** 当且仅当 $a_{i_1}\\ne a_{i_2}$ 或 $a_{j_1}\\ne a_{j_2}$ 。\n\n现在给出 $a$ 序列，问本质不同逆序对个数。\n\n这还不够。\n\n现在有 $q$ 组修改，每一次修改形如 $x~y$ 表示修改 $a_x$ 为 $y$ ，每一次修改 **不互相独立** ，即这一次修改会影响到后面的所有修改。\n\n你需要对于每一次修改输出序列本质不同逆序对个数。\n\n为了体现本题的不同解法，本题不同测试点拥有不同的时空限制。", "inputFormat": "第一行一个整数 $n$ ，表示序列长度。\n\n第二行 $n$ 个整数 $a_i$ ，表示序列 $a$ 。\n\n第三行一个整数 $q$ ，表示询问组数。\n\n后面 $q$ 行每行两个整数表示一次修改。", "outputFormat": "一行一个整数，表示初始序列中本质不同逆序对个数。\n\n后面 $q$ 行每行一个整数，第 $i + 1$ 行表示第 $i$ 次修改后序列本质不同逆序对个数。", "hint": "Idea：DPair，Solution：DPair，Code：DPair，Data：DPair\n\n对于 $100\\%$ 的数据 $1\\le n \\le 10^5, 0\\le q \\le 10^5, 1\\le a_i, x, y \\le n$ 。\n\n以下为子任务：（留空部分表示无特殊限制）\n\n| 测试点编号 | $n$       | $q$       | $a_i,y$ | 特殊性质 | 时空限制 | 对应大样例 |\n| ---------- | --------- | --------- | ------- | -------- | -------- | ---------- |\n| 1-3        | $\\le2000$ | $\\le2000$ |         | A        | 1s/500MB | Sample1    |\n| 4-5        |           | $=0$      |         | A        | 1s/50MB  | Sample2    |\n| 6-10       |           |           |         | A        | 3s/500MB | Sample3    |\n| 11-15      |           |           |         |          | 3s/500MB |            |\n| 16-20      |           |           |         |          | 1s/50MB  |            |\n\n特殊性质 A：保证数据完全随机", "locale": "zh-CN"}}}
{"pid": "P9069", "type": "P", "difficulty": 7, "samples": [["10 10\n0 1 2 3 4 5 6 7 8 9\n1 5 10 5\n2 1 10\n1 23 29 23\n2 21 19\n1 1048573 1048570 1048574\n2 1048573 1048566\n1 1048573 1048569 1048575\n2 1048575 1048564\n1 1048572 1048567 1048572\n2 1048572 1048567", "20\n18446744073709551615\n18446744073709551614\n18446744073709551613\n18446744073709551606"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2022", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2022] 堕天作战 TEST_98", "background": "明明超越人智，君临了至高点，却总是给些奇怪的奇迹。当然也会有不满的人出现，想要取回灵长的宝座。\n\n有许多的国家，组织，个人，用各种方法挑战超人机械。要让天上宛如神的他，堕落于地的众多手段——被称作是堕天作战。\n\n为了从超人机械手中抢夺神性而被用上的手段里，有一个天马行空的心理战。希望他能抛下机械的身份理解人类活着的美好——这样。\n\n那就像是狗在对着人类说当条狗吧，像那种狗我会嗤之以鼻的。但是没想到，他接受了那个邀约。不管是好奇心，打发时间，或是同情，总之他将降级为人类的分身送到这世上了。\n\n那时正逢地壳变动或是寒冷化之类的地球规模的异变，而魔人在此时趁机崛起，撒下了腐铁菌，让科学文明画下句点。而超人机械则是一副事不关己的样子。\n\n分身似乎不断地送了好几位来，但都死了，在那种世界里。不管试多少次都在途中倒下，还没体会到人类的美好就死了。\n\n于是出现了分身第二弹——不会死！本末倒置对吧，那已经不是人类了。\n\n......\n\n我想应该不是那样。\n\n超人机械是足以发明出魔法的存在吧？虽然我觉得不死者这种存在听起来很假。\n\n但这么厉害的机械，若真的想理解人类，只要随便抓个几十，几百人，当作零件装到自家身上，马上就能解决了吧？\n\n......\n\n该怎么说呢，我觉得...为了理解人类这个见解，有点牵强了呢？\n\n从包括人类在内更上一层楼的知性，是如何诞生的角度来思考的话。\n\n而且我认为，超人机械，是透过机械化——达成超越的人类。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t2yh2k2u.png)\n\n......\n\n宇宙是很严峻的，真空，极寒，辐射，我的魔力能否起作用，完全是未知数。\n\n就算是要打造火箭，也不知道要耗费多少资源才能连飞行员的生存设备也一并完善...\n\n但只要有不死者就能解决，不会错的。", "description": "给定一个长为 $n$ 的序列 $a$，有两种操作，共 $m$ 次：\n\n1. 给定 $l$ $r$ $x$，对于所有 $i$ 满足 $l\\le i\\le r$ 且 $a_i \\neq x$，$a_i\\leftarrow a_i-x$。\n2. 给定 $l$ $r$，求对于所有 $i$ 满足 $l\\le i\\le r$ 且 $a_i\\neq 0$，$a_i$ 的和。", "inputFormat": "第一行两个数 $n,m$。\n\n第二行 $n$ 个用空格隔开的数表示序列 $a$。\n\n之后 $m$ 行，每行三个或四个数：\n\n若输入为 `1 l r x`，则表示对区间 $[l,r]$ 进行一次 $1$ 操作，若输入为 `2 l r`，则表示对区间 $[l,r]$ 进行一次 $2$ 操作。\n\n本题强制在线，所有输入的 $l,r,x$ 均需要异或 $lastans$，其定义为上一次询问操作得到的答案对 $2^{20}$ 取模后的值，若之前没有询问操作，则为 $0$。", "outputFormat": "对每个 $2$ 操作，输出一行一个数表示答案对 $2^{64}$ 取模后的结果。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：w33z8kqrqk8zzzx33，Data：w33z8kqrqk8zzzx33\n\n对于 $5\\%$ 的数据，$n,m\\le 1000$。\n\n对于 $30\\%$ 的数据，$n,m\\le 5\\times10^4$。\n\n对于另外 $20\\%$ 的数据，$l=1,r=n$。\n\n对于另外 $20\\%$ 的数据，$x=1$。\n\n对于 $100\\%$ 的数据 $1\\le n,m \\le 5\\times10^5, 0\\le a_i, x \\le10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2022] 堕天作战 TEST_98", "background": "明明超越人智，君临了至高点，却总是给些奇怪的奇迹。当然也会有不满的人出现，想要取回灵长的宝座。\n\n有许多的国家，组织，个人，用各种方法挑战超人机械。要让天上宛如神的他，堕落于地的众多手段——被称作是堕天作战。\n\n为了从超人机械手中抢夺神性而被用上的手段里，有一个天马行空的心理战。希望他能抛下机械的身份理解人类活着的美好——这样。\n\n那就像是狗在对着人类说当条狗吧，像那种狗我会嗤之以鼻的。但是没想到，他接受了那个邀约。不管是好奇心，打发时间，或是同情，总之他将降级为人类的分身送到这世上了。\n\n那时正逢地壳变动或是寒冷化之类的地球规模的异变，而魔人在此时趁机崛起，撒下了腐铁菌，让科学文明画下句点。而超人机械则是一副事不关己的样子。\n\n分身似乎不断地送了好几位来，但都死了，在那种世界里。不管试多少次都在途中倒下，还没体会到人类的美好就死了。\n\n于是出现了分身第二弹——不会死！本末倒置对吧，那已经不是人类了。\n\n......\n\n我想应该不是那样。\n\n超人机械是足以发明出魔法的存在吧？虽然我觉得不死者这种存在听起来很假。\n\n但这么厉害的机械，若真的想理解人类，只要随便抓个几十，几百人，当作零件装到自家身上，马上就能解决了吧？\n\n......\n\n该怎么说呢，我觉得...为了理解人类这个见解，有点牵强了呢？\n\n从包括人类在内更上一层楼的知性，是如何诞生的角度来思考的话。\n\n而且我认为，超人机械，是透过机械化——达成超越的人类。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/t2yh2k2u.png)\n\n......\n\n宇宙是很严峻的，真空，极寒，辐射，我的魔力能否起作用，完全是未知数。\n\n就算是要打造火箭，也不知道要耗费多少资源才能连飞行员的生存设备也一并完善...\n\n但只要有不死者就能解决，不会错的。", "description": "给定一个长为 $n$ 的序列 $a$，有两种操作，共 $m$ 次：\n\n1. 给定 $l$ $r$ $x$，对于所有 $i$ 满足 $l\\le i\\le r$ 且 $a_i \\neq x$，$a_i\\leftarrow a_i-x$。\n2. 给定 $l$ $r$，求对于所有 $i$ 满足 $l\\le i\\le r$ 且 $a_i\\neq 0$，$a_i$ 的和。", "inputFormat": "第一行两个数 $n,m$。\n\n第二行 $n$ 个用空格隔开的数表示序列 $a$。\n\n之后 $m$ 行，每行三个或四个数：\n\n若输入为 `1 l r x`，则表示对区间 $[l,r]$ 进行一次 $1$ 操作，若输入为 `2 l r`，则表示对区间 $[l,r]$ 进行一次 $2$ 操作。\n\n本题强制在线，所有输入的 $l,r,x$ 均需要异或 $lastans$，其定义为上一次询问操作得到的答案对 $2^{20}$ 取模后的值，若之前没有询问操作，则为 $0$。", "outputFormat": "对每个 $2$ 操作，输出一行一个数表示答案对 $2^{64}$ 取模后的结果。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：w33z8kqrqk8zzzx33，Data：w33z8kqrqk8zzzx33\n\n对于 $5\\%$ 的数据，$n,m\\le 1000$。\n\n对于 $30\\%$ 的数据，$n,m\\le 5\\times10^4$。\n\n对于另外 $20\\%$ 的数据，$l=1,r=n$。\n\n对于另外 $20\\%$ 的数据，$x=1$。\n\n对于 $100\\%$ 的数据 $1\\le n,m \\le 5\\times10^5, 0\\le a_i, x \\le10^9$。", "locale": "zh-CN"}}}
{"pid": "P9070", "type": "P", "difficulty": 7, "samples": [["2\n3\n1 2 2\n2 3 3\n3 1 1\n3\n1 2 3\n2 3 1\n3 2 1", "2\n1 3 3 1\n2 3 3 2\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "Special Judge", "CTSC/CTS"], "title": "[CTS2023] 琪露诺的符卡交换", "background": "", "description": "受异变的影响，琪露诺发现封印了自己能力的卡片正在幻想乡中流通。\n\n琪露诺调查之后，发现一共有 $n$ 种不同的卡片，每种卡片的数量总共恰好是 $n$ 张，有 $n$ 个人购买了这些卡片，每个人都恰好买了 $n$ 张卡片，并且可能会买到相同种类的卡片。\n\n但是琪露诺想要让每个人都正好持有 $n$ 种卡片，于是她把这 $n$ 个人聚集在一起，想要通过卡片交换的形式达成她的目的。\n\n琪露诺每次会选择两个人持有的某张卡片进行交换，直到每个人都正好持有 $n$ 种卡片为止。\n\n由于每次交换都会减少卡片上的魔力，所以琪露诺想要每张卡片最多被交换一次。\n\n但是她对如何进行交换犯了难，于是她转而寻求你的帮助。\n\n你需要告诉她交换的过程，或者告诉她不存在这样的方案。", "inputFormat": "第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据，第一行一个正整数 $n$，含义如题所示。\n\n接下来 $n$ 行，每行输入 $n$ 个正整数，其中第 $i$ 行的第 $j$ 个正整数表示第 $i$ 个人持有的第 $j$ 张卡片的种类。", "outputFormat": "对于每组数据，如果不存在能够让每个人都持有 $n$ 种卡片的方案，输出一行 $-1$。\n\n否则首先输出一行一个正整数 $m$，表示交换次数。\n\n接下来 $m$ 行，每行输出四个正整数 $a,b,c,d$，表示第 $a$ 个人的第 $b$ 张卡片，与第 $c$ 个人的第 $d$ 张卡片进行一次交换。\n\n注意你需要保证不存在某张卡片被交换了两次，并且交换结束后每个人都正好持有 $n$ 种卡片。", "hint": "**【样例解释】**\n\n第一组数据，我们第一次交换第一个人的第三张卡牌，和第三个人的第一张卡牌；\n\n第二次交换第二个人的第三张卡牌，和第三个人的第二张卡牌；\n\n一共交换两次，可以使得所有人都持有三种卡牌。\n\n输出其它方案也是被允许的。\n\n第二组数据，因为一开始所有人都持有了三种卡牌，所以无需交换，输出一行 $0$ 即可。\n\n**【数据范围】**\n\n子任务 $1$（$20$ 分）：每个人只持有一种卡片。\n\n子任务 $2$（$20$ 分）：每个人持有至少 $n-1$ 张同一种类的卡片。\n\n子任务 $3$（$60$ 分）：无特殊限制。\n\n对于所有数据，满足 $\\sum\\limits_{i=1}^{T}n_{i} \\leq 200$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTS2023] 琪露诺的符卡交换", "background": "", "description": "受异变的影响，琪露诺发现封印了自己能力的卡片正在幻想乡中流通。\n\n琪露诺调查之后，发现一共有 $n$ 种不同的卡片，每种卡片的数量总共恰好是 $n$ 张，有 $n$ 个人购买了这些卡片，每个人都恰好买了 $n$ 张卡片，并且可能会买到相同种类的卡片。\n\n但是琪露诺想要让每个人都正好持有 $n$ 种卡片，于是她把这 $n$ 个人聚集在一起，想要通过卡片交换的形式达成她的目的。\n\n琪露诺每次会选择两个人持有的某张卡片进行交换，直到每个人都正好持有 $n$ 种卡片为止。\n\n由于每次交换都会减少卡片上的魔力，所以琪露诺想要每张卡片最多被交换一次。\n\n但是她对如何进行交换犯了难，于是她转而寻求你的帮助。\n\n你需要告诉她交换的过程，或者告诉她不存在这样的方案。", "inputFormat": "第一行一个正整数 $T$，表示数据组数。\n\n对于每组数据，第一行一个正整数 $n$，含义如题所示。\n\n接下来 $n$ 行，每行输入 $n$ 个正整数，其中第 $i$ 行的第 $j$ 个正整数表示第 $i$ 个人持有的第 $j$ 张卡片的种类。", "outputFormat": "对于每组数据，如果不存在能够让每个人都持有 $n$ 种卡片的方案，输出一行 $-1$。\n\n否则首先输出一行一个正整数 $m$，表示交换次数。\n\n接下来 $m$ 行，每行输出四个正整数 $a,b,c,d$，表示第 $a$ 个人的第 $b$ 张卡片，与第 $c$ 个人的第 $d$ 张卡片进行一次交换。\n\n注意你需要保证不存在某张卡片被交换了两次，并且交换结束后每个人都正好持有 $n$ 种卡片。", "hint": "**【样例解释】**\n\n第一组数据，我们第一次交换第一个人的第三张卡牌，和第三个人的第一张卡牌；\n\n第二次交换第二个人的第三张卡牌，和第三个人的第二张卡牌；\n\n一共交换两次，可以使得所有人都持有三种卡牌。\n\n输出其它方案也是被允许的。\n\n第二组数据，因为一开始所有人都持有了三种卡牌，所以无需交换，输出一行 $0$ 即可。\n\n**【数据范围】**\n\n子任务 $1$（$20$ 分）：每个人只持有一种卡片。\n\n子任务 $2$（$20$ 分）：每个人持有至少 $n-1$ 张同一种类的卡片。\n\n子任务 $3$（$60$ 分）：无特殊限制。\n\n对于所有数据，满足 $\\sum\\limits_{i=1}^{T}n_{i} \\leq 200$。", "locale": "zh-CN"}}}
{"pid": "P9071", "type": "P", "difficulty": 7, "samples": [["0 6 1\n97429867398990605044182047185430790478", "Message:    97429867398990605044182047185430790478\nTaking off: 10101\nLanding:    10011\nReceived:   97429867398990605044182047185430790478\n\nAccepted using 5 pigeons."]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2023", "交互题", "Special Judge", "通信题", "CTSC/CTS"], "title": "[CTS2023] 鸽子（无防作弊）", "background": "\n\n小 E 和小 F 是一对好闺蜜。\n\n", "description": "这是一道**通信题**。\n\n小 E 有一些很重要的信息要传给小 F。信息的内容可以用一个不超过 $128$ 位的二进制整数来表示。\n\n但是小 E 现在只有鸽子。好多好多的鸽子。黑色和白色的鸽子。\n\n小 E 可以让不同颜色的鸽子按一定的顺序起飞，飞到小 F 那里，这样小 F 就可以根据降落的鸽子的颜色顺序来知道信息的具体内容了。当然鸽子的数量是需要约定好且固定的，不然小 F 可能会在看到所有鸽子之前误以为所有的鸽子都已经飞过来了。\n\n但是众所周知，“鸽子”一词总是和“时间”联系在一起。鸽子会放鸽子。不过小 E 的鸽子还算守时，起飞和降落的顺序之差不会超过一个正整数 $k$。形式化地，设起飞的第 $i$ 只鸽子是第 $p_i$ 个降落的，那么 $\\{p_i\\}$ 是一个排列且对于所有的 $i$，$\\left|i-p_i\\right|\\le k$。\n\n小 E 自然是考虑到了这些情况，并提前与小 F 约定好了。请问如果你是小 E 你要怎样做下约定以及发送信息呢？\n\n### 实现细节\n\n【备注】：提交此题需要在所有函数前加上 `extern \"C\"`。\n\n你不需要也不应该实现主函数。你需要实现三个函数 `pigeon_num`，`send` 和 `receive`。\n\n函数 `pigeon_num` 的接口如下：\n\n```cpp\nint pigeon_num(int Taskid, int k);\n```\n\n- 该函数传入子任务编号 `Taskid` 和题目中参数 `k` 的值。\n- 该函数需要返回小 E 需要放飞的鸽子数量 $n$。\n\n函数 `send` 的接口如下：\n\n```cpp\nstd::string send(int Taskid, int n, int k, __uint128_t msg);\n```\n\n- 该函数传入子任务编号 `Taskid`，`pigeon_num` 函数的返回值 `n`，题目中的参数 `k` 以及需要发送的信息 `msg`。\n- 该函数需要返回一个长度恰好为 $n$ 的字符串，其中下标为 $i(0\\le i\\lt n)$ 的位置表示小 E 放飞的第 $i+1$ 只鸽子的颜色，`0` 表示黑色，`1` 表示白色。\n\n函数 `receive` 的接口如下：\n\n```cpp\n__uint128_t receive(int Taskid, int k, const std::string &msg);\n```\n\n- 该函数传入子任务编号 `Taskid`，题目中的参数 `k` 以及小 F 看到的鸽子的降落顺序 `msg`。\n- `msg` 为一个长度为 $n$ 的字符串，其中下标为 $i(0\\le i\\lt n)$ 的位置表示小 F 看到的第 $i+1$ 只降落的鸽子的颜色，`0` 表示黑色，`1` 表示白色。`msg` 的值与某次调用 `send` 函数的返回值有着题目描述中所满足的关系。\n- 该函数需要正确返回小 E 发送的信息的内容。\n\n你可以参考下发的样例程序 `pigeon.cpp`，也可以从头开始写一个程序。\n\n在评测时，交互库会被运行**两次**，**两次运行独立计算时间和空间**。\n\n在第一次运行时，交互库会先调用一次 `pigeon_num` 函数，然后调用不超过 $1000$ 次 `send` 函数。\n\n在第二次运行时，交互库会调用不超过 $10000$ 次 `receive` 函数。\n\n保证在题目限制下，评测交互库的运行时间不超过 $1\\texttt{s}$，运行内存不超过 $512\\textrm{MB}$。也就是说，你实际可以利用的时间至少为 $2\\texttt{s}$，空间至少为 $1.5\\textrm{GB}$。\n\n**由于洛谷暂不支持通信题的评测，评测方式逻辑与下发交互库类似。这意味着可以轻松地作弊。E_Space 在这里不追究有关于此的作弊行为，但请不要写到题解中去。**\n\n### 测试程序方式\n\n将样例交互库 `grader.cpp` 和你的代码 `pigeon.cpp` 置于同一目录下并在终端中输入如下命令进行编译：\n\n```bash\ng++ pigeon.cpp grader.cpp -o grader -g -Wall --std=c++11\n```\n\n然后运行 `./grader` 即可。样例交互库使用标准输入和标准输出，**只需要运行一次**。\n\n注意下发的交互库与实际评测时使用的交互库的实现不同。比如在下发的交互库中，通过 `send` 函数修改的全局变量的值能够被 `receive` 函数查看。\n\n", "inputFormat": "第一行三个非负整数 $\\mathrm{Taskid}$，$k$，$T$。其中 $\\mathrm{Taskid}$ 表示子任务编号，$T$ 表示发送信息的数量。\n\n接下来 $T$ 行，每行一个非负 $128$ 位整数表示信息的内容。\n\n", "outputFormat": "如果你的程序在该测试点上是正确的，对于每一条信息，交互库会输出四行内容。\n\n- 第一行 `Message` 为小 E 想要发送的信息，即 `send` 函数中参数 `msg` 的内容。\n- 第二行 `Taking off` 为鸽子起飞的顺序，即 `send` 函数的返回值。\n- 第三行 `Landing` 为鸽子降落的顺序，即 `receive` 函数中参数 `msg` 的内容。\n- 第四行 `Received` 为小 F 解读出来的信息，即 `receive` 函数的返回值。\n- 最后一行输出 `Accepted using <num> pigeon(s).`，其中 `<num>` 是小 E 放飞的鸽子的数量，即 `pigeon_num` 函数的返回值。\n\n否则如果程序正常退出，交互库会输出以下内容之一：\n\n- `Invalid number of pigeons.`：输出这句话说明 `pigeon_num` 函数的返回值不在 $[1,4000]$ 之间。\n- `Invalid color of pigeon.`：输出这句话说明 `send` 函数的返回值中有非 `0` 或 `1` 的字符。\n- `Too few or too many pigeons taking off.`：输出这句话说明 `send` 函数的返回值的长度不等于 `pigeon_num` 函数的返回值。\n- `Received wrong message.`：输出这句话说明 `receive` 函数的返回值与 `send` 函数中的参数 `msg` 不相等。\n\n一旦交互库输出了报错语句，交互库程序就会立即停止运行。\n\n", "hint": "#### 样例解释\n\n这是样例交互库在下发样例程序 `pigeon.cpp` 在样例输入下的输出。\n\n对于小 E 来说，$97429867398990605044182047185430790478$ 是一个很有意义的数。所以只需要放飞少量鸽子就够了。\n\n### 子任务\n\n子任务 $0$（$0.01$ 分）：样例。保证信息对应的整数等于 $97429867398990605044182047185430790478$。下发的 `pigeon.cpp` 能够通过样例。该子任务的评测结果会显示在评测结果中。\n\n子任务 $1$（$3.99$ 分）：保证信息对应的整数小于 $1024$。 $k\\le 20$。\n\n子任务 $2$（$12$ 分）：$k=1$。保证信息对应的整数小于 $1048576$。\n\n子任务 $3\\sim 9$（每个子任务 $12$ 分，共 $84$ 分）：$k\\le 20$。\n\n**由于洛谷不支持小数得分，本题的得分显示将乘以 100 来表示保留两位小数之后的结果。**\n\n### 评分方式\n\n评测时，你只需在 OJ 上提交你的源程序，修改下发的其他文件不会对评测结果产生影响。\n\n本题首先会受到和传统题相同的限制，例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。\n\n对于每个子任务，如果你的程序有以下行为，将会被判为 $0$ 分：\n\n- `pigeon_num` 函数的返回值不在 $[1,4000]$ 之内；\n- `send` 函数的返回值的长度不等于 `pigeon_num` 函数的返回值；\n- `send` 函数的返回值的内容包含 `0` 或 `1` 之外的字符；\n- `receive` 函数没有正确地返回小 E 发送的信息内容。\n\n此外，对于每个子任务，你的得分与小 E 放飞的鸽子的数量，即 `pigeon_num` 函数的返回值有关。设这个值为 $n$。\n\n在子任务 $1 \\sim 2$ 中，如果 $n\\le 4000$，那么你就能得到该测试点的满分，否则得到零分。\n\n在子任务 $3\\sim 9$ 中，同一个子任务中所有测试点的 $k$ 的值相同，且编号越大的子任务中 $k$ 的值越大。设 $C(k)$ 为一个关于 $k$ 的函数，则\n\n- 如果 $n\\le C(k)$，那么你可以得到该测试点的满分。\n- 若 $n\\le C(k)+5$，那么在此范围内 $n$ 的值每多 $1$，你就会失去该测试点满分乘以 $2\\%$ 的分数。\n- 若 $C(k)+5 \\lt n\\le \\lfloor 1.1\\times C(k)\\rfloor$，那么在此范围内 $n$ 的值每多 $1$，你就会额外失去该测试点满分乘以 $400\\%/C(k)$ 的分数。\n- 若 $n\\gt \\lfloor 1.1\\times C(k)\\rfloor$，那么在此范围内 $n$ 的值每多 $1$，你就会额外失去该测试点满分乘以 $40\\%/C(k)$ 的分数。\n- 若你的答案正确，你至少可以得到 $1$ 分。\n\n换句话说，你在一个测试点的得分等于 $\\max(1, 12\\times \\min(1, f_k(n)))$，其中 $f_k(n)$ 是一个关于 $n$ 的分段线性函数，满足：\n\n- $f_k(C(k))=1$\n- 两个拐点的横坐标分别为 $C(k)+5$ 和 $\\lfloor 1.1\\times C(k)\\rfloor$。\n- 被两个拐点分割所形成的三段区间的斜率依次为 $-0.02$，$-4/C(k)$ 和 $-0.4/C(k)$。\n\n\n你的每个子任务的得分是子任务中所有测试点得分的最小值。\n\n$C(k)$ 的函数值由下表给出。在下表中未出现的 $k$ 值不会出现在子任务 $3\\sim 9$ 的测试数据中。\n\n| $k$ | $1$ | $2$ | $5$ | $7$ | $10$ | $14$ | $20$ |\n| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |\n| $C(k)$ | $206$ | $284$ | $485$ | $605$ | $773$ | $983$ | $1277$ |\n\n**通过访问输入输出文件、攻击评测系统或攻击评测库等方式得分属于作弊行为，所得分数无效。**\n\n**由于洛谷暂不支持通信题的评测，评测方式逻辑与下发交互库类似。这意味着可以轻松地作弊。E_Space 在这里不追究有关于此的作弊行为，但请不要写到题解中去。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTS2023] 鸽子（无防作弊）", "background": "\n\n小 E 和小 F 是一对好闺蜜。\n\n", "description": "这是一道**通信题**。\n\n小 E 有一些很重要的信息要传给小 F。信息的内容可以用一个不超过 $128$ 位的二进制整数来表示。\n\n但是小 E 现在只有鸽子。好多好多的鸽子。黑色和白色的鸽子。\n\n小 E 可以让不同颜色的鸽子按一定的顺序起飞，飞到小 F 那里，这样小 F 就可以根据降落的鸽子的颜色顺序来知道信息的具体内容了。当然鸽子的数量是需要约定好且固定的，不然小 F 可能会在看到所有鸽子之前误以为所有的鸽子都已经飞过来了。\n\n但是众所周知，“鸽子”一词总是和“时间”联系在一起。鸽子会放鸽子。不过小 E 的鸽子还算守时，起飞和降落的顺序之差不会超过一个正整数 $k$。形式化地，设起飞的第 $i$ 只鸽子是第 $p_i$ 个降落的，那么 $\\{p_i\\}$ 是一个排列且对于所有的 $i$，$\\left|i-p_i\\right|\\le k$。\n\n小 E 自然是考虑到了这些情况，并提前与小 F 约定好了。请问如果你是小 E 你要怎样做下约定以及发送信息呢？\n\n### 实现细节\n\n【备注】：提交此题需要在所有函数前加上 `extern \"C\"`。\n\n你不需要也不应该实现主函数。你需要实现三个函数 `pigeon_num`，`send` 和 `receive`。\n\n函数 `pigeon_num` 的接口如下：\n\n```cpp\nint pigeon_num(int Taskid, int k);\n```\n\n- 该函数传入子任务编号 `Taskid` 和题目中参数 `k` 的值。\n- 该函数需要返回小 E 需要放飞的鸽子数量 $n$。\n\n函数 `send` 的接口如下：\n\n```cpp\nstd::string send(int Taskid, int n, int k, __uint128_t msg);\n```\n\n- 该函数传入子任务编号 `Taskid`，`pigeon_num` 函数的返回值 `n`，题目中的参数 `k` 以及需要发送的信息 `msg`。\n- 该函数需要返回一个长度恰好为 $n$ 的字符串，其中下标为 $i(0\\le i\\lt n)$ 的位置表示小 E 放飞的第 $i+1$ 只鸽子的颜色，`0` 表示黑色，`1` 表示白色。\n\n函数 `receive` 的接口如下：\n\n```cpp\n__uint128_t receive(int Taskid, int k, const std::string &msg);\n```\n\n- 该函数传入子任务编号 `Taskid`，题目中的参数 `k` 以及小 F 看到的鸽子的降落顺序 `msg`。\n- `msg` 为一个长度为 $n$ 的字符串，其中下标为 $i(0\\le i\\lt n)$ 的位置表示小 F 看到的第 $i+1$ 只降落的鸽子的颜色，`0` 表示黑色，`1` 表示白色。`msg` 的值与某次调用 `send` 函数的返回值有着题目描述中所满足的关系。\n- 该函数需要正确返回小 E 发送的信息的内容。\n\n你可以参考下发的样例程序 `pigeon.cpp`，也可以从头开始写一个程序。\n\n在评测时，交互库会被运行**两次**，**两次运行独立计算时间和空间**。\n\n在第一次运行时，交互库会先调用一次 `pigeon_num` 函数，然后调用不超过 $1000$ 次 `send` 函数。\n\n在第二次运行时，交互库会调用不超过 $10000$ 次 `receive` 函数。\n\n保证在题目限制下，评测交互库的运行时间不超过 $1\\texttt{s}$，运行内存不超过 $512\\textrm{MB}$。也就是说，你实际可以利用的时间至少为 $2\\texttt{s}$，空间至少为 $1.5\\textrm{GB}$。\n\n**由于洛谷暂不支持通信题的评测，评测方式逻辑与下发交互库类似。这意味着可以轻松地作弊。E_Space 在这里不追究有关于此的作弊行为，但请不要写到题解中去。**\n\n### 测试程序方式\n\n将样例交互库 `grader.cpp` 和你的代码 `pigeon.cpp` 置于同一目录下并在终端中输入如下命令进行编译：\n\n```bash\ng++ pigeon.cpp grader.cpp -o grader -g -Wall --std=c++11\n```\n\n然后运行 `./grader` 即可。样例交互库使用标准输入和标准输出，**只需要运行一次**。\n\n注意下发的交互库与实际评测时使用的交互库的实现不同。比如在下发的交互库中，通过 `send` 函数修改的全局变量的值能够被 `receive` 函数查看。\n\n", "inputFormat": "第一行三个非负整数 $\\mathrm{Taskid}$，$k$，$T$。其中 $\\mathrm{Taskid}$ 表示子任务编号，$T$ 表示发送信息的数量。\n\n接下来 $T$ 行，每行一个非负 $128$ 位整数表示信息的内容。\n\n", "outputFormat": "如果你的程序在该测试点上是正确的，对于每一条信息，交互库会输出四行内容。\n\n- 第一行 `Message` 为小 E 想要发送的信息，即 `send` 函数中参数 `msg` 的内容。\n- 第二行 `Taking off` 为鸽子起飞的顺序，即 `send` 函数的返回值。\n- 第三行 `Landing` 为鸽子降落的顺序，即 `receive` 函数中参数 `msg` 的内容。\n- 第四行 `Received` 为小 F 解读出来的信息，即 `receive` 函数的返回值。\n- 最后一行输出 `Accepted using <num> pigeon(s).`，其中 `<num>` 是小 E 放飞的鸽子的数量，即 `pigeon_num` 函数的返回值。\n\n否则如果程序正常退出，交互库会输出以下内容之一：\n\n- `Invalid number of pigeons.`：输出这句话说明 `pigeon_num` 函数的返回值不在 $[1,4000]$ 之间。\n- `Invalid color of pigeon.`：输出这句话说明 `send` 函数的返回值中有非 `0` 或 `1` 的字符。\n- `Too few or too many pigeons taking off.`：输出这句话说明 `send` 函数的返回值的长度不等于 `pigeon_num` 函数的返回值。\n- `Received wrong message.`：输出这句话说明 `receive` 函数的返回值与 `send` 函数中的参数 `msg` 不相等。\n\n一旦交互库输出了报错语句，交互库程序就会立即停止运行。\n\n", "hint": "#### 样例解释\n\n这是样例交互库在下发样例程序 `pigeon.cpp` 在样例输入下的输出。\n\n对于小 E 来说，$97429867398990605044182047185430790478$ 是一个很有意义的数。所以只需要放飞少量鸽子就够了。\n\n### 子任务\n\n子任务 $0$（$0.01$ 分）：样例。保证信息对应的整数等于 $97429867398990605044182047185430790478$。下发的 `pigeon.cpp` 能够通过样例。该子任务的评测结果会显示在评测结果中。\n\n子任务 $1$（$3.99$ 分）：保证信息对应的整数小于 $1024$。 $k\\le 20$。\n\n子任务 $2$（$12$ 分）：$k=1$。保证信息对应的整数小于 $1048576$。\n\n子任务 $3\\sim 9$（每个子任务 $12$ 分，共 $84$ 分）：$k\\le 20$。\n\n**由于洛谷不支持小数得分，本题的得分显示将乘以 100 来表示保留两位小数之后的结果。**\n\n### 评分方式\n\n评测时，你只需在 OJ 上提交你的源程序，修改下发的其他文件不会对评测结果产生影响。\n\n本题首先会受到和传统题相同的限制，例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。\n\n对于每个子任务，如果你的程序有以下行为，将会被判为 $0$ 分：\n\n- `pigeon_num` 函数的返回值不在 $[1,4000]$ 之内；\n- `send` 函数的返回值的长度不等于 `pigeon_num` 函数的返回值；\n- `send` 函数的返回值的内容包含 `0` 或 `1` 之外的字符；\n- `receive` 函数没有正确地返回小 E 发送的信息内容。\n\n此外，对于每个子任务，你的得分与小 E 放飞的鸽子的数量，即 `pigeon_num` 函数的返回值有关。设这个值为 $n$。\n\n在子任务 $1 \\sim 2$ 中，如果 $n\\le 4000$，那么你就能得到该测试点的满分，否则得到零分。\n\n在子任务 $3\\sim 9$ 中，同一个子任务中所有测试点的 $k$ 的值相同，且编号越大的子任务中 $k$ 的值越大。设 $C(k)$ 为一个关于 $k$ 的函数，则\n\n- 如果 $n\\le C(k)$，那么你可以得到该测试点的满分。\n- 若 $n\\le C(k)+5$，那么在此范围内 $n$ 的值每多 $1$，你就会失去该测试点满分乘以 $2\\%$ 的分数。\n- 若 $C(k)+5 \\lt n\\le \\lfloor 1.1\\times C(k)\\rfloor$，那么在此范围内 $n$ 的值每多 $1$，你就会额外失去该测试点满分乘以 $400\\%/C(k)$ 的分数。\n- 若 $n\\gt \\lfloor 1.1\\times C(k)\\rfloor$，那么在此范围内 $n$ 的值每多 $1$，你就会额外失去该测试点满分乘以 $40\\%/C(k)$ 的分数。\n- 若你的答案正确，你至少可以得到 $1$ 分。\n\n换句话说，你在一个测试点的得分等于 $\\max(1, 12\\times \\min(1, f_k(n)))$，其中 $f_k(n)$ 是一个关于 $n$ 的分段线性函数，满足：\n\n- $f_k(C(k))=1$\n- 两个拐点的横坐标分别为 $C(k)+5$ 和 $\\lfloor 1.1\\times C(k)\\rfloor$。\n- 被两个拐点分割所形成的三段区间的斜率依次为 $-0.02$，$-4/C(k)$ 和 $-0.4/C(k)$。\n\n\n你的每个子任务的得分是子任务中所有测试点得分的最小值。\n\n$C(k)$ 的函数值由下表给出。在下表中未出现的 $k$ 值不会出现在子任务 $3\\sim 9$ 的测试数据中。\n\n| $k$ | $1$ | $2$ | $5$ | $7$ | $10$ | $14$ | $20$ |\n| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |\n| $C(k)$ | $206$ | $284$ | $485$ | $605$ | $773$ | $983$ | $1277$ |\n\n**通过访问输入输出文件、攻击评测系统或攻击评测库等方式得分属于作弊行为，所得分数无效。**\n\n**由于洛谷暂不支持通信题的评测，评测方式逻辑与下发交互库类似。这意味着可以轻松地作弊。E_Space 在这里不追究有关于此的作弊行为，但请不要写到题解中去。**", "locale": "zh-CN"}}}
{"pid": "P9072", "type": "P", "difficulty": 7, "samples": [["1 4 2 2\n2 1", "7"], ["2 4 2 2\n1 2 2 1", "19"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "CTSC/CTS"], "title": "[CTS2023] 另一个欧拉数问题", "background": "你继续向前走，遇到了一个身着黑袍的老人，那边的门前放着一个巨大的沙盘，老人用手中的树枝在沙盘前画着奇怪的符号。\n\n老人告诉你，他从年轻开始便梦想一个问题，直到他垂垂老矣，似乎也只揭露了答案的一角。\n\n或许我该将它们交给你们了，老人说。\n\n别太担心，我不想太为难你，至少我已经把必要的工具给你准备好了。", "description": "对于正整数 $\\alpha$，考虑下述长为 $\\alpha n$ 的序列 $a$：\n\n- 对于每个 $k=1,\\dots, n$，序列 $a$ 中出现了恰好 $\\alpha$ 个 $k$。\n\n- 对于 $i < j$ 满足 $a_i = a_j$，那么对任意 $i < k < j$，有 $a_k \\geq a_i$。\n\n我们称满足上述要求的序列是一个 $(n,\\alpha)$ 阶排列。\n\n现在输入一个 $(n_0,\\alpha)$ 阶排列 $P$。又给定 $n$ 和 $m$，请你计算有多少 $(n,\\alpha)$ 阶排列包含子序列 $P$，并且满足：\n\n- 总共有 $m$ 个下标 $i$ 满足 $a_i > a_{i+1}$。\n\n你只需计算出这样的序列总数对 $998244353$ 取模的结果。", "inputFormat": "第一行输入四个整数 $\\alpha$，$n$，$m$，$n_0$。\n\n第二行输入 $\\alpha n_0$ 个正整数，保证构成一个 $(n_0,\\alpha)$ 阶排列。", "outputFormat": "输出一个整数，表示满足要求的序列的数量。", "hint": "**【数据范围】**\n\n子任务 $1$（$10$ 分）：保证 $n \\leq 2000$。\n\n子任务 $2$（$10$ 分）：保证 $\\alpha = 1$，$n_0=1$。\n\n子任务 $3$（$30$ 分）：保证 $\\alpha = 1$。\n\n子任务 $4$（$15$ 分）：保证 $\\alpha = 2$，$n_0=1$。\n\n子任务 $5$（$15$ 分）：保证 $\\alpha = 2$。\n\n子任务 $6$（$20$ 分）：无特殊限制。\n\n对于所有数据，保证 $1\\leq n \\leq 2\\times 10^5$，$0\\leq m < n$，$1\\leq n_0\\leq n$，$1\\leq \\alpha n_0 \\leq 2\\times 10^5$。\n\n**【提示】**\n\n为了方便选手处理形式幂级数的运算，我们提供了一个模板。选手可以根据自己的需要参考与使用该模板，也可以不使用该模板。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CTS2023] 另一个欧拉数问题", "background": "你继续向前走，遇到了一个身着黑袍的老人，那边的门前放着一个巨大的沙盘，老人用手中的树枝在沙盘前画着奇怪的符号。\n\n老人告诉你，他从年轻开始便梦想一个问题，直到他垂垂老矣，似乎也只揭露了答案的一角。\n\n或许我该将它们交给你们了，老人说。\n\n别太担心，我不想太为难你，至少我已经把必要的工具给你准备好了。", "description": "对于正整数 $\\alpha$，考虑下述长为 $\\alpha n$ 的序列 $a$：\n\n- 对于每个 $k=1,\\dots, n$，序列 $a$ 中出现了恰好 $\\alpha$ 个 $k$。\n\n- 对于 $i < j$ 满足 $a_i = a_j$，那么对任意 $i < k < j$，有 $a_k \\geq a_i$。\n\n我们称满足上述要求的序列是一个 $(n,\\alpha)$ 阶排列。\n\n现在输入一个 $(n_0,\\alpha)$ 阶排列 $P$。又给定 $n$ 和 $m$，请你计算有多少 $(n,\\alpha)$ 阶排列包含子序列 $P$，并且满足：\n\n- 总共有 $m$ 个下标 $i$ 满足 $a_i > a_{i+1}$。\n\n你只需计算出这样的序列总数对 $998244353$ 取模的结果。", "inputFormat": "第一行输入四个整数 $\\alpha$，$n$，$m$，$n_0$。\n\n第二行输入 $\\alpha n_0$ 个正整数，保证构成一个 $(n_0,\\alpha)$ 阶排列。", "outputFormat": "输出一个整数，表示满足要求的序列的数量。", "hint": "**【数据范围】**\n\n子任务 $1$（$10$ 分）：保证 $n \\leq 2000$。\n\n子任务 $2$（$10$ 分）：保证 $\\alpha = 1$，$n_0=1$。\n\n子任务 $3$（$30$ 分）：保证 $\\alpha = 1$。\n\n子任务 $4$（$15$ 分）：保证 $\\alpha = 2$，$n_0=1$。\n\n子任务 $5$（$15$ 分）：保证 $\\alpha = 2$。\n\n子任务 $6$（$20$ 分）：无特殊限制。\n\n对于所有数据，保证 $1\\leq n \\leq 2\\times 10^5$，$0\\leq m < n$，$1\\leq n_0\\leq n$，$1\\leq \\alpha n_0 \\leq 2\\times 10^5$。\n\n**【提示】**\n\n为了方便选手处理形式幂级数的运算，我们提供了一个模板。选手可以根据自己的需要参考与使用该模板，也可以不使用该模板。", "locale": "zh-CN"}}}
