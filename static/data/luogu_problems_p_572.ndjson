{"pid": "P12611", "type": "P", "difficulty": 2, "samples": [["1\nAbC3c2Cd9", "ACC14"], ["3\nAhkiy-6ebvXCV1\n393hhhUHkbs5gh6QpS-9-8\nPL12N-2G1234Duytrty8-86tyaYySsDdEe", "AXCV-5\nUHQS387\nPLNGDYSDE1166"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "字符串", "2025", "CCC（加拿大）"], "title": "[CCC 2025 Junior] Product Codes", "background": "Score: 15.", "description": "A store has hired the Code Cleaning Crew to help it update all of its product codes.\n\nThe original product codes are sequences of letters, positive integers, and negative integers. For example, $\\tt{cG23mH-9s}$ is a product code that contains two uppercase letters, three lowercase letters, one positive integer, and one negative integer.\n\nThe new product codes are made by removing all lowercase letters, keeping all uppercase letters in order, and adding all the integers to form one new integer which is placed at the end of the code. For example, the new product code for $\\tt{cG23mH-9s}$ is $\\tt{GH14}$.\n\nYour job is to take a list of original product codes and determine the new product codes.", "inputFormat": "The first line of input contains a positive integer, $N$, representing the number of original product codes that need to be updated. The following $N$ lines each contain one original product code.\n\nEach original product code contains at least one uppercase letter, at least one lowercase letter, and at least one integer. Also, a positive integer never immediately follows another integer. This means, for example, that $23$ is the integer $23$ instead of the integer $2$ followed by the integer $3$.\n\n", "outputFormat": "Output the $N$ new product codes, one per line.", "hint": "**Explanation of Output for Sample Input 1**\n\nFor the single original product code, the uppercase letters $\\tt A$, $\\tt C$, and $\\tt C$ are kept in order and the sum of the integers is $3 + 2 + 9 = 14$.\n\n**Explanation of Output for Sample Input 2**\n\nFor the first original product code, the uppercase letters $\\tt A$, $\\tt X$, $\\tt C$, and $\\tt V$ are kept in order and the sum of the integers is $-6 + 1 = -5$.\n\nFor the second and third original product codes, their uppercase letters are also kept in order and the sums of the integers are $393 + 5 + 6 - 9 - 8 = 387$ and $12 - 2 + 1234 + 8 - 86 = 1166$ respectively.\n\nThe following table shows how the available $15$ marks are distributed:\n\n|Marks|Description|\n|:-:|:-:|\n|2|All the integers are positive and single-digit|\n|2|All the integers are single-digit.|\n|7|Any positive integer may be multi-digit.|\n|4|Any integer may be multi-digit.|", "locale": "en", "translations": {"en": {"title": "[CCC 2025 Junior] Product Codes", "background": "Score: 15.", "description": "A store has hired the Code Cleaning Crew to help it update all of its product codes.\n\nThe original product codes are sequences of letters, positive integers, and negative integers. For example, $\\tt{cG23mH-9s}$ is a product code that contains two uppercase letters, three lowercase letters, one positive integer, and one negative integer.\n\nThe new product codes are made by removing all lowercase letters, keeping all uppercase letters in order, and adding all the integers to form one new integer which is placed at the end of the code. For example, the new product code for $\\tt{cG23mH-9s}$ is $\\tt{GH14}$.\n\nYour job is to take a list of original product codes and determine the new product codes.", "inputFormat": "The first line of input contains a positive integer, $N$, representing the number of original product codes that need to be updated. The following $N$ lines each contain one original product code.\n\nEach original product code contains at least one uppercase letter, at least one lowercase letter, and at least one integer. Also, a positive integer never immediately follows another integer. This means, for example, that $23$ is the integer $23$ instead of the integer $2$ followed by the integer $3$.\n\n", "outputFormat": "Output the $N$ new product codes, one per line.", "hint": "**Explanation of Output for Sample Input 1**\n\nFor the single original product code, the uppercase letters $\\tt A$, $\\tt C$, and $\\tt C$ are kept in order and the sum of the integers is $3 + 2 + 9 = 14$.\n\n**Explanation of Output for Sample Input 2**\n\nFor the first original product code, the uppercase letters $\\tt A$, $\\tt X$, $\\tt C$, and $\\tt V$ are kept in order and the sum of the integers is $-6 + 1 = -5$.\n\nFor the second and third original product codes, their uppercase letters are also kept in order and the sums of the integers are $393 + 5 + 6 - 9 - 8 = 387$ and $12 - 2 + 1234 + 8 - 86 = 1166$ respectively.\n\nThe following table shows how the available $15$ marks are distributed:\n\n|Marks|Description|\n|:-:|:-:|\n|2|All the integers are positive and single-digit|\n|2|All the integers are single-digit.|\n|7|Any positive integer may be multi-digit.|\n|4|Any integer may be multi-digit.|", "locale": "en"}, "zh-CN": {"title": "[CCC 2025 Junior] Product Codes", "background": "本题满分 15 分。", "description": "一家商店聘请了代码清理团队来帮助更新所有产品编码。\n\n原始产品编码由字母、正整数和负整数组成。例如，$\\tt{cG23mH-9s}$ 是一个包含两个大写字母、三个小写字母、一个正整数和一个负整数的产品编码。\n\n新的产品编码需要删除所有小写字母，保留所有大写字母并按原顺序排列，并将所有整数相加得到一个总和作为新整数放在编码末尾。例如，$\\tt{cG23mH-9s}$ 的新产品编码是 $\\tt{GH14}$。\n\n你的任务是处理一组原始产品编码，并生成对应的新编码。", "inputFormat": "第一行输入一个正整数 $N$，表示需要更新的原始产品编码数量。接下来的 $N$ 行每行包含一个原始产品编码。\n\n每个原始产品编码至少包含一个大写字母、一个小写字母和一个整数。此外，正整数不会紧跟在另一个整数之后。这意味着，例如 $23$ 会被视为整数 $23$，而不是整数 $2$ 和 $3$ 的组合。", "outputFormat": "输出 $N$ 个新编码，每行一个。\n", "hint": "**样例输入 1 的输出解释**\n\n对于单个原始产品编码，大写字母 $\\tt A$、$\\tt C$ 和 $\\tt C$ 被按顺序保留，整数部分的总和为 $3 + 2 + 9 = 14$。\n\n**样例输入 2 的输出解释**\n\n对于第一个原始产品编码，大写字母 $\\tt A$、$\\tt X$、$\\tt C$ 和 $\\tt V$ 被按顺序保留，整数部分的总和为 $-6 + 1 = -5$。\n\n对于第二个和第三个原始产品编码，它们的大写字母同样按顺序保留，整数部分的总和分别为 $393 + 5 + 6 - 9 - 8 = 387$ 和 $12 - 2 + 1234 + 8 - 86 = 1166$。\n\n以下表格展示了 15 分的分配情况：\n\n|分值|描述|\n|:-:|:-:|\n|2|所有整数均为正整数且为个位数|\n|2|所有整数均为个位数|\n|7|正整数可能为多位数|\n|4|整数可能为多位数（正或负）|\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12612", "type": "P", "difficulty": 2, "samples": [["8\nP\nS\nP\nS\nS\nP\nP\nS", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["递推", "2025", "CCC（加拿大）", "双指针 two-pointer"], "title": "[CCC 2025 Junior] Sunny Days", "background": "Score: 15.", "description": "There is a large amount of historical weather data for CEMCity. Each day in the data is listed as either a day with sunshine or a day with precipitation. Jeremy is interested in finding the record for the most consecutive days with sunshine. Unfortunately, the data is incorrect for exactly one day, but Jeremy doesn't know which day this is.\n\nYour job is to help Jeremy determine the maximum possible number of consecutive days with sunshine.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mirndz24.png)", "inputFormat": "The first line of input contains a positive integer, $N$, representing the number of days in the historical data. The following $N$ lines each contain either the character $S$ or the character $P$, representing a day with sunshine or a day with precipitation, respectively, in chronological order.", "outputFormat": "Output the non-negative integer, $M$, which is the maximum possible number of consecutive days with sunshine.", "hint": "**Explanation of Output for Sample Input**\n\nIf the data is incorrect for the third day, then there was sunshine from the second day to the fifth day which is four consecutive days with sunshine. This is the maximum possible number of consecutive days with sunshine. That is, no matter which day the data is incorrect for, there were not five (or more) consecutive days of sunshine.\n\nThe following table shows how the available 15 marks are distributed:\n\n|Marks|Description|Bounds|\n|:-:|:-:|:-:|\n|2|There are not many days in the historical data. The data consists of a single block of all S's followed by a single block of all P's. One of these blocks may be empty.|$N\\leq 1000$|\n|4|There are not many days in the historical data. The data contains S's and P's possibly in mixed order.|$N\\leq 1000$|\n|9|There are possibly many days in the historical data.|$N\\leq 500\\,000$|", "locale": "en", "translations": {"en": {"title": "[CCC 2025 Junior] Sunny Days", "background": "Score: 15.", "description": "There is a large amount of historical weather data for CEMCity. Each day in the data is listed as either a day with sunshine or a day with precipitation. Jeremy is interested in finding the record for the most consecutive days with sunshine. Unfortunately, the data is incorrect for exactly one day, but Jeremy doesn't know which day this is.\n\nYour job is to help Jeremy determine the maximum possible number of consecutive days with sunshine.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mirndz24.png)", "inputFormat": "The first line of input contains a positive integer, $N$, representing the number of days in the historical data. The following $N$ lines each contain either the character $S$ or the character $P$, representing a day with sunshine or a day with precipitation, respectively, in chronological order.", "outputFormat": "Output the non-negative integer, $M$, which is the maximum possible number of consecutive days with sunshine.", "hint": "**Explanation of Output for Sample Input**\n\nIf the data is incorrect for the third day, then there was sunshine from the second day to the fifth day which is four consecutive days with sunshine. This is the maximum possible number of consecutive days with sunshine. That is, no matter which day the data is incorrect for, there were not five (or more) consecutive days of sunshine.\n\nThe following table shows how the available 15 marks are distributed:\n\n|Marks|Description|Bounds|\n|:-:|:-:|:-:|\n|2|There are not many days in the historical data. The data consists of a single block of all S's followed by a single block of all P's. One of these blocks may be empty.|$N\\leq 1000$|\n|4|There are not many days in the historical data. The data contains S's and P's possibly in mixed order.|$N\\leq 1000$|\n|9|There are possibly many days in the historical data.|$N\\leq 500\\,000$|", "locale": "en"}, "zh-CN": {"title": "[CCC 2025 Junior] Sunny Days", "background": "本题满分 15 分。", "description": "CEMCity 拥有大量历史天气数据。数据中每一天都被标记为晴天（S）或降水日（P）。Jeremy 想要找出最长的连续晴天记录。然而，这些数据中恰好有一天的记录是错误的（但 Jeremy 不知道是哪一天）。\n\n你的任务是帮助 Jeremy 计算出可能的最长连续晴天天数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mirndz24.png)", "inputFormat": "第一行输入一个正整数 $N$，表示历史数据的天数。接下来的 $N$ 行每行包含一个字符 $S$（晴天）或 $P$（降水日），按时间顺序排列。", "outputFormat": "输出一个非负整数 $M$，表示可能的最长连续晴天天数。", "hint": "**样例输入输出解释**\n\n如果第三天的数据是错误的（实际应为晴天），那么从第二天到第五天将出现连续 4 天的晴天记录。这是可能的最长连续晴天天数。也就是说，无论哪一天的数据是错误的，都不会出现 5 天或更长的连续晴天。\n\n以下表格展示了 15 分的分配情况：\n\n|分值|描述|数据范围|\n|:-:|:-:|:-:|\n|2|历史数据天数较少。数据由连续的 S 和连续的 P 组成（其中一个部分可能为空）|$N\\leq 1000$|\n|4|历史数据天数较少。数据中 S 和 P 可能交替出现|$N\\leq 1000$|\n|9|历史数据可能包含大量天数|$N\\leq 500\\,000$|\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12613", "type": "P", "difficulty": 2, "samples": [["3\n5\n7", "6"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2025", "CCC（加拿大）"], "title": "[CCC 2025 Junior]  Connecting Territories", "background": "Score: 15.", "description": "Ava is playing a strategic game on a grid of tiles. Each tile has an associated cost. When the costs of the tiles are read from left to right, starting with the first row, a repeating pattern of the first $M$ positive integers in increasing order is revealed: $1, 2, 3, \\dots , M, 1, 2, 3, \\dots , M, 1, 2, 3, \\dots$ In this pattern, $M$ represents the maximum cost of a tile. In the grid of tiles shown, $M$ is equal to $5$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wbyl4yjv.png)\n\nAva needs to purchase one tile in each row in order to make a connecting path from the upper territory (above the first row of tiles) to the lower territory (below the last row of tiles). The first tile purchased must be in the first row. Each subsequently purchased tile must share either an edge or a corner with the tile purchased previously. In the grid of tiles shown, the cost of Ava's connecting path is $9$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5h5lj684.png)\n\nGiven a grid of tiles, your job is to determine the minimum cost of a connecting path between the upper and lower territories.", "inputFormat": "The first line of input contains a positive integer, $R$, representing the number of rows in the grid. The second line contains a positive integer, $C$, representing the number of columns in the grid. The third line contains a positive integer, $M$ where $M \\leq 100\\, 000$, representing the maximum cost of a tile.", "outputFormat": "Output the positive integer, $P$, which is the minimum cost of a connecting path between the\nupper and lower territories.", "hint": "**Explanation of Output for Sample Input**\n\nThe cost of each tile is shown. The sequence of tiles that Ava should purchase to minimize the cost of a connecting path is highlighted in green.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2onq6n9o.png)\n\nThe following table shows how the available 15 marks are distributed:\n\n|Marks|Descripton|Bounds|\n|:-:|:-:|:-:|\n|3|There are two rows and at most ten columns.| $R = 2$ and $C \\leq 10$|\n|8|There are at most ten rows and at most ten columns.| $R \\leq 10$ and $C \\leq 10$ |\n|2|There are at most 100 rows and at most 100 columns.| $R \\leq 100$ and $C \\leq 100$|\n|2| The grid may be very large.|$R \\leq 20\\, 000$ and $C \\leq 20\\, 000$|", "locale": "en", "translations": {"en": {"title": "[CCC 2025 Junior]  Connecting Territories", "background": "Score: 15.", "description": "Ava is playing a strategic game on a grid of tiles. Each tile has an associated cost. When the costs of the tiles are read from left to right, starting with the first row, a repeating pattern of the first $M$ positive integers in increasing order is revealed: $1, 2, 3, \\dots , M, 1, 2, 3, \\dots , M, 1, 2, 3, \\dots$ In this pattern, $M$ represents the maximum cost of a tile. In the grid of tiles shown, $M$ is equal to $5$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wbyl4yjv.png)\n\nAva needs to purchase one tile in each row in order to make a connecting path from the upper territory (above the first row of tiles) to the lower territory (below the last row of tiles). The first tile purchased must be in the first row. Each subsequently purchased tile must share either an edge or a corner with the tile purchased previously. In the grid of tiles shown, the cost of Ava's connecting path is $9$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5h5lj684.png)\n\nGiven a grid of tiles, your job is to determine the minimum cost of a connecting path between the upper and lower territories.", "inputFormat": "The first line of input contains a positive integer, $R$, representing the number of rows in the grid. The second line contains a positive integer, $C$, representing the number of columns in the grid. The third line contains a positive integer, $M$ where $M \\leq 100\\, 000$, representing the maximum cost of a tile.", "outputFormat": "Output the positive integer, $P$, which is the minimum cost of a connecting path between the\nupper and lower territories.", "hint": "**Explanation of Output for Sample Input**\n\nThe cost of each tile is shown. The sequence of tiles that Ava should purchase to minimize the cost of a connecting path is highlighted in green.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2onq6n9o.png)\n\nThe following table shows how the available 15 marks are distributed:\n\n|Marks|Descripton|Bounds|\n|:-:|:-:|:-:|\n|3|There are two rows and at most ten columns.| $R = 2$ and $C \\leq 10$|\n|8|There are at most ten rows and at most ten columns.| $R \\leq 10$ and $C \\leq 10$ |\n|2|There are at most 100 rows and at most 100 columns.| $R \\leq 100$ and $C \\leq 100$|\n|2| The grid may be very large.|$R \\leq 20\\, 000$ and $C \\leq 20\\, 000$|", "locale": "en"}, "zh-CN": {"title": "[CCC 2025 Junior] Connecting Territories", "background": "本题满分 15 分。", "description": "Ava 正在一个由格子组成的网格上玩策略游戏。每个格子都有一个对应的花费。当从左到右逐行读取格子的花费时，会呈现一个由前 $M$ 个正整数按递增顺序重复组成的模式：$1, 2, 3, \\dots , M, 1, 2, 3, \\dots , M, 1, 2, 3, \\dots$。在这个模式中，$M$ 表示格子的最大花费。在示例网格中，$M$ 等于 $5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wbyl4yjv.png)\n\nAva 需要在每一行购买一个格子，以构建一条从上领地（第一行格子上方）通往下领地（最后一行格子下方）的连通路径。第一个购买的格子必须在第一行。随后购买的每个格子必须与上一个购买的格子共享一条边或一个角。在示例网格中，Ava 的连通路径总花费为 $9$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5h5lj684.png)\n\n给定一个格子网格，你的任务是确定从上领地到下领地的连通路径的最小花费。", "inputFormat": "第一行输入一个正整数 $R$，表示网格的行数。第二行输入一个正整数 $C$，表示网格的列数。第三行输入一个正整数 $M$（$M \\leq 100\\,000$），表示格子的最大花费。", "outputFormat": "输出一个正整数 $P$，表示连通路径的最小花费。\n", "hint": "**样例输入输出解释**\n\n每个格子的花费如图所示。Ava 应购买的格子序列（绿色高亮部分）使得连通路径的花费最小。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2onq6n9o.png)\n\n以下表格展示了 15 分的分配情况：\n\n|分值|描述|数据范围|\n|:-:|:-:|:-:|\n|3|网格有两行且最多十列。|$R = 2$ 且 $C \\leq 10$|\n|8|网格最多十行且最多十列。|$R \\leq 10$ 且 $C \\leq 10$|\n|2|网格最多 100 行且最多 100 列。|$R \\leq 100$ 且 $C \\leq 100$|\n|2|网格可能非常大。|$R \\leq 20\\,000$ 且 $C \\leq 20\\,000$|\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12614", "type": "P", "difficulty": 0, "samples": [["5 2", "2"], ["442 6", "896944318"], ["7133 9", "980381648"]], "limits": {"time": [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "RMI（罗马尼亚）"], "title": "[RMI 2023] AA Tree", "background": "翻译来自 [LibreOJ](https://loj.ac/p/4799)。", "description": "**题目译自 [Romanian Master of Informatics 2023](https://rmi.lbi.ro/rmi_2023/) Day1 T1 「[AA Tree](https://csacademy.com/contest/rmi-2023-day-1/task/aa-tree/)」**\n\n> 由于原始问题中对二叉搜索树的定义有误，本题描述略有调整。\n\n**AA 树**是一种特殊的二叉搜索树，每个节点都拥有一个**值**和一个**层级**。值的排列遵循普通的二叉搜索树规则：\n\n1. 每个左子节点（以及左子树中的所有节点）的值都小于等于其父节点的值。\n2. 每个右子节点（以及右子树中的所有节点）的值都大于等于其父节点的值。\n\n层级则需满足以下条件：\n\n1. 所有叶子节点的层级为 $1$。\n2. 每个左子节点的层级比其父节点小 $1$。\n3. 每个右子节点的层级等于或比其父节点小 $1$。\n4. 每个右孙节点的层级必须严格小于其祖父节点的层级。\n5. 层级大于 $1$ 的每个节点必须有两个子节点。\n\n下面展示了五棵 **AA 树**的样例，分别包含 $3$、$5$、$5$、$11$ 和 $11$ 个节点。为了更清晰地展示，与父节点层级相同的右子节点用红色标出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xpvdtszv.png)\n\n给定两个数字 $N$ 和 $L$，请你计算将 $1$、$2$、...、$N$ 这 $N$ 个值排列成一棵 **AA 树**，且恰好有 $L$ 个层级的方法有多少种？", "inputFormat": "输入只有一行，包含两个用空格分隔的整数 $N$ 和 $L$。", "outputFormat": "输出排列方法的数量，对 $10^9 + 7$ 取模。", "hint": "### 样例 1 解释\n\n两种可能的排列方式如上图中的第 $2$ 和第 $3$ 棵树所示。\n\n### 数据范围与提示\n\n对于所有输入数据，满足：\n\n* $1 \\leq L \\leq 9$\n* $1 \\leq N \\leq 10\\ 000$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :---: | :---: | :--: |\n| $1$ | $19$      | $L \\leq 4$|\n| $2$ | $34$      | $5 \\leq L \\leq 7$      |\n| $3$ | $47$      | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2023] AA Tree", "background": "翻译来自 [LibreOJ](https://loj.ac/p/4799)。", "description": "**题目译自 [Romanian Master of Informatics 2023](https://rmi.lbi.ro/rmi_2023/) Day1 T1 「[AA Tree](https://csacademy.com/contest/rmi-2023-day-1/task/aa-tree/)」**\n\n> 由于原始问题中对二叉搜索树的定义有误，本题描述略有调整。\n\n**AA 树**是一种特殊的二叉搜索树，每个节点都拥有一个**值**和一个**层级**。值的排列遵循普通的二叉搜索树规则：\n\n1. 每个左子节点（以及左子树中的所有节点）的值都小于等于其父节点的值。\n2. 每个右子节点（以及右子树中的所有节点）的值都大于等于其父节点的值。\n\n层级则需满足以下条件：\n\n1. 所有叶子节点的层级为 $1$。\n2. 每个左子节点的层级比其父节点小 $1$。\n3. 每个右子节点的层级等于或比其父节点小 $1$。\n4. 每个右孙节点的层级必须严格小于其祖父节点的层级。\n5. 层级大于 $1$ 的每个节点必须有两个子节点。\n\n下面展示了五棵 **AA 树**的样例，分别包含 $3$、$5$、$5$、$11$ 和 $11$ 个节点。为了更清晰地展示，与父节点层级相同的右子节点用红色标出。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xpvdtszv.png)\n\n给定两个数字 $N$ 和 $L$，请你计算将 $1$、$2$、...、$N$ 这 $N$ 个值排列成一棵 **AA 树**，且恰好有 $L$ 个层级的方法有多少种？", "inputFormat": "输入只有一行，包含两个用空格分隔的整数 $N$ 和 $L$。", "outputFormat": "输出排列方法的数量，对 $10^9 + 7$ 取模。", "hint": "### 样例 1 解释\n\n两种可能的排列方式如上图中的第 $2$ 和第 $3$ 棵树所示。\n\n### 数据范围与提示\n\n对于所有输入数据，满足：\n\n* $1 \\leq L \\leq 9$\n* $1 \\leq N \\leq 10\\ 000$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :---: | :---: | :--: |\n| $1$ | $19$      | $L \\leq 4$|\n| $2$ | $34$      | $5 \\leq L \\leq 7$      |\n| $3$ | $47$      | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P12615", "type": "P", "difficulty": 6, "samples": [["3 1\n0 3 3", "3"], ["3 2\n0 3 3", "10"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2023", "RMI（罗马尼亚）"], "title": "[RMI 2023] Heroes", "background": "翻译来自 [LibreOJ](https://loj.ac/p/4800)。", "description": "> —— 小明，你整天玩电脑游戏是在浪费生命啊！  \n> —— 没事的，妈妈，我还有三条命呢！\n\n在保卫世间一切美好事物的大战中，有 $H$ 位英雄正在与 $M$ 只怪兽激战。他们围成一个圈，按特定的顺序站好。第 $i$ 位英雄身后跟着 $m_i$ 只怪兽（总共有 $m_1 + m_2 + \\dots + m_H = M$）。\n\n战斗从第一位英雄开始，大家轮流挥剑进攻。英雄可以攻击圈中任意一只怪兽，而怪兽也能攻击任意一位英雄（无论位置远近）。每只怪兽挨上 $K$ 剑就会被消灭，而英雄们则是无敌的。\n\n英雄们为了荣耀而战，希望尽可能少挨怪兽的攻击。请你计算，在消灭所有怪兽前，英雄们最少需要承受多少次攻击？", "inputFormat": "第一行包含两个整数 $H$ 和 $K$，用空格分隔。\n\n第二行包含 $H$ 个用空格分隔的整数，分别是 $m_1, m_2, \\ldots ,m_H$。", "outputFormat": "输出一个整数，表示英雄们最少需要承受的攻击次数。", "hint": "### 样例 1 解释\n\n这里有 $H=3$ 位英雄和 $M=6$ 只怪兽，每只怪兽的生命值为 $K=1$。初始站位是 `HHMMMHMMM`（`H` 表示英雄，`M` 表示怪兽）。前两位英雄分别消灭第一和第二只怪兽，第三只怪兽发起攻击。第三位英雄消灭第四只怪兽，最后两只怪兽也发动攻击。此时圈中变为 `HHMHMM`。第二轮时，每位英雄各消灭一只怪兽，之后英雄们不再受到攻击。\n\n### 数据范围与提示\n\n对于所有输入数据，满足：\n\n* $1 \\leq H \\leq 3\\ 000$\n* $1 \\leq M \\leq 1\\ 000 \\ 000 \\ 000$\n* $1 \\leq K \\leq 1\\ 000$\n* 对于 $1 \\leq i \\leq H$，$0 \\leq m_i \\leq M$\n* 答案保证不超过 $10^{18}$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :---: | :---: | :--: |\n| $1$ | $7$      | $H \\leq 10$, $M \\leq 4$, $K \\leq 4$|\n| $2$ | $11$      | $H \\leq 20$, $M \\leq 10$, $K \\leq 30$|\n| $3$ | $15$      | $M \\leq 150\\ 000$    |\n| $4$ | $17$      | $M \\leq 5\\ 000 \\ 000$   |\n| $5$ | $19$      | $M \\leq 30\\ 000 \\ 000$    |\n| $6$ | $31$      | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2023] Heroes", "background": "翻译来自 [LibreOJ](https://loj.ac/p/4800)。", "description": "> —— 小明，你整天玩电脑游戏是在浪费生命啊！  \n> —— 没事的，妈妈，我还有三条命呢！\n\n在保卫世间一切美好事物的大战中，有 $H$ 位英雄正在与 $M$ 只怪兽激战。他们围成一个圈，按特定的顺序站好。第 $i$ 位英雄身后跟着 $m_i$ 只怪兽（总共有 $m_1 + m_2 + \\dots + m_H = M$）。\n\n战斗从第一位英雄开始，大家轮流挥剑进攻。英雄可以攻击圈中任意一只怪兽，而怪兽也能攻击任意一位英雄（无论位置远近）。每只怪兽挨上 $K$ 剑就会被消灭，而英雄们则是无敌的。\n\n英雄们为了荣耀而战，希望尽可能少挨怪兽的攻击。请你计算，在消灭所有怪兽前，英雄们最少需要承受多少次攻击？", "inputFormat": "第一行包含两个整数 $H$ 和 $K$，用空格分隔。\n\n第二行包含 $H$ 个用空格分隔的整数，分别是 $m_1, m_2, \\ldots ,m_H$。", "outputFormat": "输出一个整数，表示英雄们最少需要承受的攻击次数。", "hint": "### 样例 1 解释\n\n这里有 $H=3$ 位英雄和 $M=6$ 只怪兽，每只怪兽的生命值为 $K=1$。初始站位是 `HHMMMHMMM`（`H` 表示英雄，`M` 表示怪兽）。前两位英雄分别消灭第一和第二只怪兽，第三只怪兽发起攻击。第三位英雄消灭第四只怪兽，最后两只怪兽也发动攻击。此时圈中变为 `HHMHMM`。第二轮时，每位英雄各消灭一只怪兽，之后英雄们不再受到攻击。\n\n### 数据范围与提示\n\n对于所有输入数据，满足：\n\n* $1 \\leq H \\leq 3\\ 000$\n* $1 \\leq M \\leq 1\\ 000 \\ 000 \\ 000$\n* $1 \\leq K \\leq 1\\ 000$\n* 对于 $1 \\leq i \\leq H$，$0 \\leq m_i \\leq M$\n* 答案保证不超过 $10^{18}$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :---: | :---: | :--: |\n| $1$ | $7$      | $H \\leq 10$, $M \\leq 4$, $K \\leq 4$|\n| $2$ | $11$      | $H \\leq 20$, $M \\leq 10$, $K \\leq 30$|\n| $3$ | $15$      | $M \\leq 150\\ 000$    |\n| $4$ | $17$      | $M \\leq 5\\ 000 \\ 000$   |\n| $5$ | $19$      | $M \\leq 30\\ 000 \\ 000$    |\n| $6$ | $31$      | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P12616", "type": "P", "difficulty": 7, "samples": [["3 12\nR 3 2\nR 6 1\nL 3 2\n0\n1\n2\n3\n4\n5\n6\n7\n17\n18\n19\n200", "0\n1\n2\n3\n2\n1\n0\n-1\n5\n6\n5\n-152"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "RMI（罗马尼亚）"], "title": "[RMI 2023] Pinball", "background": "翻译来自 [LibreOJ](https://loj.ac/p/4801)。", "description": "**题目译自 [Romanian Master of Informatics 2023](https://rmi.lbi.ro/rmi_2023/) Day1 T3 「[Pinball](https://csacademy.com/contest/rmi-2023-day-1/task/pinball/)」**\n\n> —— 大家稍微冷静一下……\n\n想象一个球，它静静地躺在 $X$ 轴上，初始位置是坐标 $0$。与此同时，$X$ 轴上分布着 $N$ 组墙壁。每组墙壁可以用一个三元组 $(dir, len, freq)$ 来描述：\n\n* $dir$ 表示墙壁的摆放方向，可以是 $\\texttt{L}$（向左）或 $\\texttt{R}$（向右）。\n* 如果 $dir=\\texttt{L}$，那么这组墙壁会出现在位置 $−len, −2 \\cdot len, −3 \\cdot len,\\ldots −freq \\cdot len$。\n* 如果 $dir=\\texttt{R}$，那么这组墙壁会出现在位置 $len, 2 \\cdot len, 3 \\cdot len,\\ldots , freq \\cdot len$。\n\n需要注意的是，由于这些信息的特性，同一个坐标上可能会同时存在多堵墙。\n\n在时间 $T=0$ 时，球开始以每秒一单位的速度向右移动。每当球撞上一堵墙，那堵墙就会立刻被撞毁，同时球会掉头反向移动。如果某个坐标有多堵墙，球撞击时只会毁掉其中一堵。\n\n现在给你 $Q$ 个问题。每个问题会给出一个整数 $T$，请你算出经过 $T$ 秒后，球所在的坐标是多少。", "inputFormat": "第一行包含两个整数 $N$ 和 $Q$，中间用一个空格隔开。\n\n接下来的 $N$ 行，每行有三个用空格分隔的整数 $dir, len, freq$，描述一组墙壁的摆放方式。\n\n再接下来的 $Q$ 行，每行有一个整数 $T$，表示一个询问。", "outputFormat": "输出 $Q$ 行，第 $i$ 行给出第 $i$ 个询问的答案。", "hint": "对于所有输入数据，满足：\n\n* $1 \\leq N, Q \\leq 250\\ 000$\n* $1 \\leq T \\leq 10^{12}$\n* $dir \\in \\{\\texttt{L}, \\texttt{R}\\}$\n* $1 \\leq len, freq \\leq 10^{12}$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :---: | :---: | :--: |\n| $1$ | $13$      | $N, Q \\leq 1\\ 000$|\n| $2$ | $8$      | $Q, T \\leq 1\\ 000$      |\n| $3$ | $16$      | $1 \\leq len \\leq 10$    |\n| $4$ | $10$      | $T \\leq 10^6$   |\n| $5$ | $11$      | $len \\cdot freq \\leq 10^6$    |\n| $6$ | $9$      | 令 $S$ 为输入中所有 $freq$ 的总和，$S \\leq 10^6$    |\n| $7$ | $33$      | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2023] Pinball", "background": "翻译来自 [LibreOJ](https://loj.ac/p/4801)。", "description": "**题目译自 [Romanian Master of Informatics 2023](https://rmi.lbi.ro/rmi_2023/) Day1 T3 「[Pinball](https://csacademy.com/contest/rmi-2023-day-1/task/pinball/)」**\n\n> —— 大家稍微冷静一下……\n\n想象一个球，它静静地躺在 $X$ 轴上，初始位置是坐标 $0$。与此同时，$X$ 轴上分布着 $N$ 组墙壁。每组墙壁可以用一个三元组 $(dir, len, freq)$ 来描述：\n\n* $dir$ 表示墙壁的摆放方向，可以是 $\\texttt{L}$（向左）或 $\\texttt{R}$（向右）。\n* 如果 $dir=\\texttt{L}$，那么这组墙壁会出现在位置 $−len, −2 \\cdot len, −3 \\cdot len,\\ldots −freq \\cdot len$。\n* 如果 $dir=\\texttt{R}$，那么这组墙壁会出现在位置 $len, 2 \\cdot len, 3 \\cdot len,\\ldots , freq \\cdot len$。\n\n需要注意的是，由于这些信息的特性，同一个坐标上可能会同时存在多堵墙。\n\n在时间 $T=0$ 时，球开始以每秒一单位的速度向右移动。每当球撞上一堵墙，那堵墙就会立刻被撞毁，同时球会掉头反向移动。如果某个坐标有多堵墙，球撞击时只会毁掉其中一堵。\n\n现在给你 $Q$ 个问题。每个问题会给出一个整数 $T$，请你算出经过 $T$ 秒后，球所在的坐标是多少。", "inputFormat": "第一行包含两个整数 $N$ 和 $Q$，中间用一个空格隔开。\n\n接下来的 $N$ 行，每行有三个用空格分隔的整数 $dir, len, freq$，描述一组墙壁的摆放方式。\n\n再接下来的 $Q$ 行，每行有一个整数 $T$，表示一个询问。", "outputFormat": "输出 $Q$ 行，第 $i$ 行给出第 $i$ 个询问的答案。", "hint": "对于所有输入数据，满足：\n\n* $1 \\leq N, Q \\leq 250\\ 000$\n* $1 \\leq T \\leq 10^{12}$\n* $dir \\in \\{\\texttt{L}, \\texttt{R}\\}$\n* $1 \\leq len, freq \\leq 10^{12}$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :---: | :---: | :--: |\n| $1$ | $13$      | $N, Q \\leq 1\\ 000$|\n| $2$ | $8$      | $Q, T \\leq 1\\ 000$      |\n| $3$ | $16$      | $1 \\leq len \\leq 10$    |\n| $4$ | $10$      | $T \\leq 10^6$   |\n| $5$ | $11$      | $len \\cdot freq \\leq 10^6$    |\n| $6$ | $9$      | 令 $S$ 为输入中所有 $freq$ 的总和，$S \\leq 10^6$    |\n| $7$ | $33$      | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P12617", "type": "P", "difficulty": 6, "samples": [["5 6\n011110\n111110\n011111\n111111\n011110", "3 2 4"], ["3 3\n010\n101\n010", "0 0 0"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "斜率优化", "RMI（罗马尼亚）"], "title": "[RMI 2023] Circles", "background": "翻译来自 [LibreOJ](https://loj.ac/p/4802)。", "description": "历史上最为顽皮的两位达契亚人——丹尼洛和斯特加诺突发奇想，决定挖一些毫无用处的隧道来捉弄后人。他们知道，未来的历史学家们会为这些莫名其妙的隧道绞尽脑汁，试图猜测它们的用途，可实际上，这些隧道压根儿没啥用。\n\n他们找到一面巨大的墙，打算在这上面开挖。可惜的是，墙上有些地方坚不可摧，他们只能绕开这些区域。为了美观，隧道的入口必须是圆形的。\n\n具体来说，这面墙可以看作一个笛卡尔平面，$x$ 坐标范围是 $[0, M]$，$y$ 坐标范围是 $[0, N]$。那些坚不可摧的部分是边长为 $1$ 的正方形，边与坐标轴平行，顶点位于整数坐标上。可挖掘区域的地图可以用一个二进制矩阵表示，矩阵有 $N$ 行（从 $0$ 到 $N-1$ 编号）和 $M$ 列（从 $0$ 到 $M-1$ 编号）。如果矩阵中第 $l$ 行第 $c$ 列的元素是 $1$，那么所有满足 $c \\leq x \\leq c+1$ 且 $l \\leq y \\leq l+1$ 的点 $(x, y)$ 都可以被挖开。**注意区分平面中的坐标 $(x, y)$ 和矩阵中元素的位置 $(l, c)$。**\n\n挖隧道时，他们会先选一个**整数坐标** $(x, y)$ 作为隧道的中心，然后确定一个半径 $r$，接着开始挖掘以 $(x, y)$ 为圆心、半径为 $r$ 的圆盘内的所有点。**注意，这个圆盘包括内部的所有点，不仅仅是圆周上的点，而且圆盘必须完全位于定义的平面内。**\n\n他们希望隧道越显眼越好，所以想挖一个半径最大的隧道。为了施工方便，如果有多个半径最大的隧道，他们会挑一个最好挖的——也就是 $y$ 坐标最小的那个。如果还有多个选择，他们就选 $x$ 坐标最小的那个。", "inputFormat": "第一行包含两个整数 $N$ 和 $M$，分别表示定义平面的范围和二进制矩阵的尺寸。\n\n接下来的 $N$ 行，每行是一个长度为 $M$ 的字符串，由 `0` 和 `1` 组成，表示上面定义的矩阵元素。", "outputFormat": "在一行中输出三个用空格分隔的整数 $x, y, R$。$(x, y)$ 表示丹尼洛和斯特加诺将要挖掘的隧道中心的坐标，$R$ 表示圆的半径平方后取整的结果。如果找不到半径为正整数的圆，输出 `0 0 0`。", "hint": "### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6w4993co.png)\n\n### 数据范围与提示\n\n对于所有输入数据，满足：\n\n* $1 \\leq N, M \\leq 3\\ 000$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :---: | :---: | :--: |\n| $1$ | $4$      | 矩阵中恰好有四个格子是 $1$。|\n| $2$ | $9$      | 矩阵中的 $1$ 构成一个边与坐标轴平行的矩形。      |\n| $3$ | $14$     | $N, M \\leq 50$    |\n| $4$ | $15$      | $N, M \\leq 600$   |\n| $5$ | $21$      | 矩阵是随机生成的。    |\n| $6$ | $37$      | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2023] Circles", "background": "翻译来自 [LibreOJ](https://loj.ac/p/4802)。", "description": "历史上最为顽皮的两位达契亚人——丹尼洛和斯特加诺突发奇想，决定挖一些毫无用处的隧道来捉弄后人。他们知道，未来的历史学家们会为这些莫名其妙的隧道绞尽脑汁，试图猜测它们的用途，可实际上，这些隧道压根儿没啥用。\n\n他们找到一面巨大的墙，打算在这上面开挖。可惜的是，墙上有些地方坚不可摧，他们只能绕开这些区域。为了美观，隧道的入口必须是圆形的。\n\n具体来说，这面墙可以看作一个笛卡尔平面，$x$ 坐标范围是 $[0, M]$，$y$ 坐标范围是 $[0, N]$。那些坚不可摧的部分是边长为 $1$ 的正方形，边与坐标轴平行，顶点位于整数坐标上。可挖掘区域的地图可以用一个二进制矩阵表示，矩阵有 $N$ 行（从 $0$ 到 $N-1$ 编号）和 $M$ 列（从 $0$ 到 $M-1$ 编号）。如果矩阵中第 $l$ 行第 $c$ 列的元素是 $1$，那么所有满足 $c \\leq x \\leq c+1$ 且 $l \\leq y \\leq l+1$ 的点 $(x, y)$ 都可以被挖开。**注意区分平面中的坐标 $(x, y)$ 和矩阵中元素的位置 $(l, c)$。**\n\n挖隧道时，他们会先选一个**整数坐标** $(x, y)$ 作为隧道的中心，然后确定一个半径 $r$，接着开始挖掘以 $(x, y)$ 为圆心、半径为 $r$ 的圆盘内的所有点。**注意，这个圆盘包括内部的所有点，不仅仅是圆周上的点，而且圆盘必须完全位于定义的平面内。**\n\n他们希望隧道越显眼越好，所以想挖一个半径最大的隧道。为了施工方便，如果有多个半径最大的隧道，他们会挑一个最好挖的——也就是 $y$ 坐标最小的那个。如果还有多个选择，他们就选 $x$ 坐标最小的那个。", "inputFormat": "第一行包含两个整数 $N$ 和 $M$，分别表示定义平面的范围和二进制矩阵的尺寸。\n\n接下来的 $N$ 行，每行是一个长度为 $M$ 的字符串，由 `0` 和 `1` 组成，表示上面定义的矩阵元素。", "outputFormat": "在一行中输出三个用空格分隔的整数 $x, y, R$。$(x, y)$ 表示丹尼洛和斯特加诺将要挖掘的隧道中心的坐标，$R$ 表示圆的半径平方后取整的结果。如果找不到半径为正整数的圆，输出 `0 0 0`。", "hint": "### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6w4993co.png)\n\n### 数据范围与提示\n\n对于所有输入数据，满足：\n\n* $1 \\leq N, M \\leq 3\\ 000$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :---: | :---: | :--: |\n| $1$ | $4$      | 矩阵中恰好有四个格子是 $1$。|\n| $2$ | $9$      | 矩阵中的 $1$ 构成一个边与坐标轴平行的矩形。      |\n| $3$ | $14$     | $N, M \\leq 50$    |\n| $4$ | $15$      | $N, M \\leq 600$   |\n| $5$ | $21$      | 矩阵是随机生成的。    |\n| $6$ | $37$      | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P12618", "type": "P", "difficulty": 0, "samples": [["3 2 7\n8 1\n2 0\n0 3\n2\n10 2\n2 6", "29"], ["6 4 200\n12 1 19 10\n45 3 42 44\n42 32 40 41\n39 12 32 47\n35 18 40 20\n38 14 25 1\n3\n34 10 7 9\n29 32 21 50\n16 36 18 38", "708"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "RMI（罗马尼亚）"], "title": "[RMI 2023] Statues", "background": "翻译来自 [LibreOJ](https://loj.ac/p/4803)。", "description": "`<Link />` 想要拿到一张新的 `C chart`，而这张图表只能在 `<meta>` 岛的 `<element>` 神殿里找到。要进入神殿，他得先解开一个谜题。\n\n`<Link />` 需要进入一个 $T$ 维空间，这里每个点的坐标都由一个长度为 $T$ 的数组表示，比如 $[x_1, x_2, x_3, \\dots, x_T]$。在这个空间里，有 $N$ 个固定不动的雕像（编号从 $1$ 到 $N$）和 $Q$ 个可以移动的雕像（编号从 $1$ 到 $Q$）。`<Link />` 最多可以移动 **$K$ 次**，每次他可以选择一个**可移动的雕像**，然后沿着某个轴的方向移动它一个单位。也就是说，某个雕像的坐标会变成 $[x_1, x_2, \\dots, x_i−1, \\dots, x_T]$ 或 $[x_1, x_2, \\dots, x_i+1, \\dots, x_T]$。\n\n为了打开 `<element>` 神殿的大门，他需要调整这些**可移动雕像**的位置，让所有**可移动雕像**与所有**固定雕像**之间的曼哈顿距离之和尽可能小。\n\n两个 $T$ 维点 $[x_1, x_2, \\dots, x_T]$ 和 $[y_1, y_2, \\dots, y_T]$ 之间的曼哈顿距离定义为：\n\n$$\\operatorname{dist}([x_1, x_2, \\dots, x_T], [y_1, y_2, \\dots, y_T]) = \\displaystyle \\sum_{i = 1}^{T} |x_i - y_i|$$\n\n假设 $s$ 是所有**固定雕像**的坐标数组，$m$ 是经过最多 $K$ 次最优移动后所有**可移动雕像**的坐标数组。你需要计算：\n\n$$\\displaystyle \\sum_{i = 1}^{N} \\sum_{j = 1}^{Q} \\operatorname{dist}(s_i, m_j)$$", "inputFormat": "第一行包含三个整数 $N, T, K$，分别表示固定雕像的数量、空间维数以及 `<Link />` 最多可以移动的次数。\n\n接下来的 $N$ 行，每行有 $T$ 个用空格分隔的整数。第 $i$ 行表示第 $i$ 个**固定雕像**的坐标。\n\n再下一行是一个单独的整数 $Q$，表示**可移动雕像**的数量。\n\n接下来的 $Q$ 行，每行有 $T$ 个用空格分隔的整数，以类似的方式表示每个**可移动雕像**的坐标。", "outputFormat": "输出一个整数，表示在最多 $K$ 次移动后，所有**固定雕像**到所有**可移动雕像**的曼哈顿距离之和的最小值。", "hint": "### 数据范围与提示\n\n对于所有输入数据，满足：\n\n* $1 \\leq N, Q \\leq 100\\ 000$\n* $1 \\leq T \\leq 10$\n* $1 \\leq K \\leq 10^{15}$\n* 所有坐标都是 $0$ 到 $10^9$ 之间的整数（包含边界）。\n* 答案保证能用 64 位有符号整数表示。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :---: | :---: | :--: |\n| $1$ | $7$      | $T = Q = 1$|\n| $2$ | $10$      | $N, Q, K \\leq 100$      |\n| $3$ | $12$     | $N, Q \\leq 50$    |\n| $4$ | $28$      | $T = 1$   |\n| $5$ | $17$      | $Q = 1$    |\n| $6$ | $26$      | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2023] Statues", "background": "翻译来自 [LibreOJ](https://loj.ac/p/4803)。", "description": "`<Link />` 想要拿到一张新的 `C chart`，而这张图表只能在 `<meta>` 岛的 `<element>` 神殿里找到。要进入神殿，他得先解开一个谜题。\n\n`<Link />` 需要进入一个 $T$ 维空间，这里每个点的坐标都由一个长度为 $T$ 的数组表示，比如 $[x_1, x_2, x_3, \\dots, x_T]$。在这个空间里，有 $N$ 个固定不动的雕像（编号从 $1$ 到 $N$）和 $Q$ 个可以移动的雕像（编号从 $1$ 到 $Q$）。`<Link />` 最多可以移动 **$K$ 次**，每次他可以选择一个**可移动的雕像**，然后沿着某个轴的方向移动它一个单位。也就是说，某个雕像的坐标会变成 $[x_1, x_2, \\dots, x_i−1, \\dots, x_T]$ 或 $[x_1, x_2, \\dots, x_i+1, \\dots, x_T]$。\n\n为了打开 `<element>` 神殿的大门，他需要调整这些**可移动雕像**的位置，让所有**可移动雕像**与所有**固定雕像**之间的曼哈顿距离之和尽可能小。\n\n两个 $T$ 维点 $[x_1, x_2, \\dots, x_T]$ 和 $[y_1, y_2, \\dots, y_T]$ 之间的曼哈顿距离定义为：\n\n$$\\operatorname{dist}([x_1, x_2, \\dots, x_T], [y_1, y_2, \\dots, y_T]) = \\displaystyle \\sum_{i = 1}^{T} |x_i - y_i|$$\n\n假设 $s$ 是所有**固定雕像**的坐标数组，$m$ 是经过最多 $K$ 次最优移动后所有**可移动雕像**的坐标数组。你需要计算：\n\n$$\\displaystyle \\sum_{i = 1}^{N} \\sum_{j = 1}^{Q} \\operatorname{dist}(s_i, m_j)$$", "inputFormat": "第一行包含三个整数 $N, T, K$，分别表示固定雕像的数量、空间维数以及 `<Link />` 最多可以移动的次数。\n\n接下来的 $N$ 行，每行有 $T$ 个用空格分隔的整数。第 $i$ 行表示第 $i$ 个**固定雕像**的坐标。\n\n再下一行是一个单独的整数 $Q$，表示**可移动雕像**的数量。\n\n接下来的 $Q$ 行，每行有 $T$ 个用空格分隔的整数，以类似的方式表示每个**可移动雕像**的坐标。", "outputFormat": "输出一个整数，表示在最多 $K$ 次移动后，所有**固定雕像**到所有**可移动雕像**的曼哈顿距离之和的最小值。", "hint": "### 数据范围与提示\n\n对于所有输入数据，满足：\n\n* $1 \\leq N, Q \\leq 100\\ 000$\n* $1 \\leq T \\leq 10$\n* $1 \\leq K \\leq 10^{15}$\n* 所有坐标都是 $0$ 到 $10^9$ 之间的整数（包含边界）。\n* 答案保证能用 64 位有符号整数表示。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :---: | :---: | :--: |\n| $1$ | $7$      | $T = Q = 1$|\n| $2$ | $10$      | $N, Q, K \\leq 100$      |\n| $3$ | $12$     | $N, Q \\leq 50$    |\n| $4$ | $28$      | $T = 1$   |\n| $5$ | $17$      | $Q = 1$    |\n| $6$ | $26$      | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P12619", "type": "P", "difficulty": 6, "samples": [["6\n5 2 42\n5 4 52\n6 3 26\n4 6 39\n1 6 15", "54\n1 6\n3 5\n4 2"], ["4\n1 2 4\n3 4 5\n2 3 1", "1\n2 3\n1 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "Special Judge", "RMI（罗马尼亚）"], "title": "[RMI 2023] To be, xor not to be", "background": "翻译来自 [LibreOJ](https://loj.ac/p/4804)。", "description": "丹德罗马克的贵族王子斯特甘，因心爱的父亲去世而悲痛万分。他曾不懈地尝试通过计算各种梯形图形的面积（用辛普森法则）来探究父亲的命运，可惜毫无结果。正当他几近绝望时，一位精灵现身相助，赠予他一棵树，让他悉心照料。后来，精灵对他说：「看！仔细看！你发现了吗？这棵树很特别，它的顶点数量是偶数。只要你能找到一种最佳方式，把这些顶点两两配对，让配对的总成本尽可能小，你就能揭开父亲去世的真相。不过，首先你得弄清楚配对的成本是什么，它的秘密藏在生命的意义里。」\n\n斯特甘是个数学天才，他深知生命的真谛在于那句名言：「生存，**还是异或生存**」（至于后面的话，咱们就不多说了）。于是他推断出，对于一对顶点，配对的成本是连接它们的简单路径上所有边的权值的按位异或（XOR）结果。\n\n可惜，天意弄人，斯特甘完全不懂计算机科学，面对这个问题束手无策，只好向你求助。\n\n具体来说，你会得到一棵有 $N$ 个顶点的树，$N$ 是偶数。每条边都有一个权值。对于一对顶点 $(u, v)$，它们的配对成本是连接它们的简单路径上所有边权值的按位 XOR。\n\n你的任务是把这些顶点分成 $\\frac{N}{2}$ 对，使得所有配对成本的总和尽量小。因为要找到绝对的最优解可能太难，我们只要求你尽力而为，你会根据结果获得相应的分数。", "inputFormat": "第一行是一个偶数整数 $N$，表示树中顶点的数量。接下来的 $N-1$ 行，每行包含三个用空格分隔的数字 $u_i, v_i, w_i$，表示有一条权值为 $w_i$ 的边连接 $u_i$ 和 $v_i$。$u_i$ 和 $v_i$ 都在 $1$ 到 $N$ 之间。", "outputFormat": "第一行输出你所选配对的总成本。接下来的 $\\frac{N}{2}$ 行，每行输出一对配对的顶点编号。所有配对之间不能有重复的顶点。", "hint": "### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kmbhafeu.png)\n\n### 样例 2 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zesf3dsi.png)\n\n### 数据范围与提示\n\n对于所有输入数据，满足：\n\n* $2 \\leq N \\leq 200$\n* $N$ 是偶数\n* $0 \\leq w_i \\leq 2^{24}$\n* 按位 XOR (^) 操作返回一个数字，其二进制表示中，每一位上是 $1$ 的情况是两个操作数对应位中恰好有一个是 $1$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :---: | :---: | :--: |\n| $1$ | $3$     | $N \\leq 10, w_i \\leq 64$|\n| $2$ | $6$    | $N \\leq 14$      |\n| $3$ | $19$    | $N \\leq 40, w_i \\leq 64$|    |\n| $4$ | $8$      | $N \\leq 120, w_i \\leq 16$|   |\n| $5$ | $41$ | $N \\leq 120$    |\n| $6$ | $23$    | 无附加限制 |\n\n对于每个子任务：\n\n1. 如果你的程序在某个测试点中无法生成有效答案（超时、运行错误），该子任务得分为 $0$。\n2. 如果你输出的 $\\frac{N}{2}$ 对配对无法正确分割 $N$ 个顶点，或者与你输出的总成本不符，答案也不算正确。\n3. 如果以上情况都没发生，你将根据以下公式得分：\n\n$$\\text{group\\_score} \\cdot \\min \\left\\{  \\left( \\frac{ok\\_cost_i}{out\\_cost_i} \\right) ^4 \\right\\}$$\n\n其中：\n\n* $i$ 表示该子任务中的每个测试点\n* $out\\_cost_i$ 是你的代码在测试点 $i$ 中计算出的成本\n* $ok\\_cost_i$ 是测试点 $i$ 的最优答案", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[RMI 2023] To be, xor not to be", "background": "翻译来自 [LibreOJ](https://loj.ac/p/4804)。", "description": "丹德罗马克的贵族王子斯特甘，因心爱的父亲去世而悲痛万分。他曾不懈地尝试通过计算各种梯形图形的面积（用辛普森法则）来探究父亲的命运，可惜毫无结果。正当他几近绝望时，一位精灵现身相助，赠予他一棵树，让他悉心照料。后来，精灵对他说：「看！仔细看！你发现了吗？这棵树很特别，它的顶点数量是偶数。只要你能找到一种最佳方式，把这些顶点两两配对，让配对的总成本尽可能小，你就能揭开父亲去世的真相。不过，首先你得弄清楚配对的成本是什么，它的秘密藏在生命的意义里。」\n\n斯特甘是个数学天才，他深知生命的真谛在于那句名言：「生存，**还是异或生存**」（至于后面的话，咱们就不多说了）。于是他推断出，对于一对顶点，配对的成本是连接它们的简单路径上所有边的权值的按位异或（XOR）结果。\n\n可惜，天意弄人，斯特甘完全不懂计算机科学，面对这个问题束手无策，只好向你求助。\n\n具体来说，你会得到一棵有 $N$ 个顶点的树，$N$ 是偶数。每条边都有一个权值。对于一对顶点 $(u, v)$，它们的配对成本是连接它们的简单路径上所有边权值的按位 XOR。\n\n你的任务是把这些顶点分成 $\\frac{N}{2}$ 对，使得所有配对成本的总和尽量小。因为要找到绝对的最优解可能太难，我们只要求你尽力而为，你会根据结果获得相应的分数。", "inputFormat": "第一行是一个偶数整数 $N$，表示树中顶点的数量。接下来的 $N-1$ 行，每行包含三个用空格分隔的数字 $u_i, v_i, w_i$，表示有一条权值为 $w_i$ 的边连接 $u_i$ 和 $v_i$。$u_i$ 和 $v_i$ 都在 $1$ 到 $N$ 之间。", "outputFormat": "第一行输出你所选配对的总成本。接下来的 $\\frac{N}{2}$ 行，每行输出一对配对的顶点编号。所有配对之间不能有重复的顶点。", "hint": "### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kmbhafeu.png)\n\n### 样例 2 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zesf3dsi.png)\n\n### 数据范围与提示\n\n对于所有输入数据，满足：\n\n* $2 \\leq N \\leq 200$\n* $N$ 是偶数\n* $0 \\leq w_i \\leq 2^{24}$\n* 按位 XOR (^) 操作返回一个数字，其二进制表示中，每一位上是 $1$ 的情况是两个操作数对应位中恰好有一个是 $1$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :---: | :---: | :--: |\n| $1$ | $3$     | $N \\leq 10, w_i \\leq 64$|\n| $2$ | $6$    | $N \\leq 14$      |\n| $3$ | $19$    | $N \\leq 40, w_i \\leq 64$|    |\n| $4$ | $8$      | $N \\leq 120, w_i \\leq 16$|   |\n| $5$ | $41$ | $N \\leq 120$    |\n| $6$ | $23$    | 无附加限制 |\n\n对于每个子任务：\n\n1. 如果你的程序在某个测试点中无法生成有效答案（超时、运行错误），该子任务得分为 $0$。\n2. 如果你输出的 $\\frac{N}{2}$ 对配对无法正确分割 $N$ 个顶点，或者与你输出的总成本不符，答案也不算正确。\n3. 如果以上情况都没发生，你将根据以下公式得分：\n\n$$\\text{group\\_score} \\cdot \\min \\left\\{  \\left( \\frac{ok\\_cost_i}{out\\_cost_i} \\right) ^4 \\right\\}$$\n\n其中：\n\n* $i$ 表示该子任务中的每个测试点\n* $out\\_cost_i$ 是你的代码在测试点 $i$ 中计算出的成本\n* $ok\\_cost_i$ 是测试点 $i$ 的最优答案", "locale": "zh-CN"}}}
{"pid": "P12620", "type": "P", "difficulty": 5, "samples": [["9 13", "18 13"], ["19 47", "13110 18612"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "数论", "ICPC", "欧拉函数", "NAC"], "title": "[ICPC 2025 NAC] A Totient Quotient", "background": "", "description": "For a positive integer $k$, Euler's totient function $\\phi(k)$ is defined as the number of positive integers less than or equal to $k$ and relatively prime to $k$.\nFor example, $\\phi(9) = 6$, $\\phi(24) = 8,$ and $\\phi(1) = 1$. (As a reminder, the greatest common divisor (gcd) of two positive integers $a$ and $b$ is the greatest positive integer that divides both $a$ and $b$. Two positive integers are relatively prime if their gcd is $1$.)\n\nEuler's product formula gives the value of $\\phi(k)$ in terms of the prime factorization of $k$. For a prime $p$, let $\\nu_p(k)$ be the highest power of $p$ which divides $k$ (so for example, $\\nu_2(48) = 4$, $\\nu_3(48)=1$, and $\\nu_5(48)=0$). If $k$ is a product of powers of prime factors, $k = \\prod_{i=1}^j p_i^{\\nu_{p_i}(k)}$ (where the product only includes primes $p_i$ with $\\nu_{p_i}(k) > 0$), \nthen \n$$ \\phi(k) = \\prod_{i=1}^j \\left[(p_i - 1)\\left(p_i^{\\nu_{p_i}(k)-1}\\right)\\right].$$\n\nA recent edition of The American Mathematical Monthly (Li et al., *Positive Rational Numbers of the Form $\\phi(m^2)/\\phi(n^2)$*, 128(2), 2021) proved the following fact about totient quotients: for any pair of positive integers $a$, $b$ there is a unique pair of positive integers $m$, $n$ for which:\n- $\\frac{a}{b} = \\frac{\\phi(m^2)}{\\phi(n^2)};$\n- if a prime $p$ divides the product $mn$, then $\\nu_p(m) \\neq \\nu_{p}(n)$;\n- $\\gcd(m,n)$ is square-free: that is, for every prime $p$, $\\gcd(m,n)$ is not divisible by $p^2$.\n\nConditions 2 and 3 guarantee that $m$ and $n$ are the unique smallest pair of positive integers satisfying condition 1.\n\nYou'd like to verify this claim numerically. Write a program which takes as input two integers $a$ and $b$ and outputs the corresponding pair $m, n$.", "inputFormat": "The only line of input contains two space-separated integers $a$ and $b$ ($ 1 \\leq a, b \\leq 10\\,000$). These two integers are guaranteed to be relatively prime. Additionally, $a$ and $b$ will be chosen so that output values $m$ and $n$ are less than $2^{63}$.", "outputFormat": "Print the two positive integers $m$ and $n$ satisfying all three of the conditions of The American Mathematical Monthly's theorem, separated by a space. It is guaranteed that $ m, n < 2^{63}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2025 NAC] A Totient Quotient", "background": "", "description": "For a positive integer $k$, Euler's totient function $\\phi(k)$ is defined as the number of positive integers less than or equal to $k$ and relatively prime to $k$.\nFor example, $\\phi(9) = 6$, $\\phi(24) = 8,$ and $\\phi(1) = 1$. (As a reminder, the greatest common divisor (gcd) of two positive integers $a$ and $b$ is the greatest positive integer that divides both $a$ and $b$. Two positive integers are relatively prime if their gcd is $1$.)\n\nEuler's product formula gives the value of $\\phi(k)$ in terms of the prime factorization of $k$. For a prime $p$, let $\\nu_p(k)$ be the highest power of $p$ which divides $k$ (so for example, $\\nu_2(48) = 4$, $\\nu_3(48)=1$, and $\\nu_5(48)=0$). If $k$ is a product of powers of prime factors, $k = \\prod_{i=1}^j p_i^{\\nu_{p_i}(k)}$ (where the product only includes primes $p_i$ with $\\nu_{p_i}(k) > 0$), \nthen \n$$ \\phi(k) = \\prod_{i=1}^j \\left[(p_i - 1)\\left(p_i^{\\nu_{p_i}(k)-1}\\right)\\right].$$\n\nA recent edition of The American Mathematical Monthly (Li et al., *Positive Rational Numbers of the Form $\\phi(m^2)/\\phi(n^2)$*, 128(2), 2021) proved the following fact about totient quotients: for any pair of positive integers $a$, $b$ there is a unique pair of positive integers $m$, $n$ for which:\n- $\\frac{a}{b} = \\frac{\\phi(m^2)}{\\phi(n^2)};$\n- if a prime $p$ divides the product $mn$, then $\\nu_p(m) \\neq \\nu_{p}(n)$;\n- $\\gcd(m,n)$ is square-free: that is, for every prime $p$, $\\gcd(m,n)$ is not divisible by $p^2$.\n\nConditions 2 and 3 guarantee that $m$ and $n$ are the unique smallest pair of positive integers satisfying condition 1.\n\nYou'd like to verify this claim numerically. Write a program which takes as input two integers $a$ and $b$ and outputs the corresponding pair $m, n$.", "inputFormat": "The only line of input contains two space-separated integers $a$ and $b$ ($ 1 \\leq a, b \\leq 10\\,000$). These two integers are guaranteed to be relatively prime. Additionally, $a$ and $b$ will be chosen so that output values $m$ and $n$ are less than $2^{63}$.", "outputFormat": "Print the two positive integers $m$ and $n$ satisfying all three of the conditions of The American Mathematical Monthly's theorem, separated by a space. It is guaranteed that $ m, n < 2^{63}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2025 NAC] A Totient Quotient", "background": "", "description": "对于一个正整数 $k$，欧拉函数 $\\phi(k)$ 定义为小于等于 $k$ 且与 $k$ 互质的正整数的个数。例如，$\\phi(9) = 6$，$\\phi(24) = 8$，$\\phi(1) = 1$。（提醒一下，两个正整数 $a$ 和 $b$ 的最大公约数（gcd）是能同时整除 $a$ 和 $b$ 的最大正整数。如果两个正整数的 gcd 为 $1$，则它们互质。）\n\n欧拉乘积公式通过 $k$ 的质因数分解给出了 $\\phi(k)$ 的值。对于一个质数 $p$，令 $\\nu_p(k)$ 表示 $p$ 的最高幂次，使得 $p^{\\nu_p(k)}$ 能整除 $k$（例如，$\\nu_2(48) = 4$，$\\nu_3(48)=1$，$\\nu_5(48)=0$）。如果 $k$ 是若干质数的幂次的乘积，即 $k = \\prod_{i=1}^j p_i^{\\nu_{p_i}(k)}$（其中乘积仅包含满足 $\\nu_{p_i}(k) > 0$ 的质数 $p_i$），那么：\n$$ \\phi(k) = \\prod_{i=1}^j \\left[(p_i - 1)\\left(p_i^{\\nu_{p_i}(k)-1}\\right)\\right].$$\n\n《美国数学月刊》（Li 等人，《形如 $\\phi(m^2)/\\phi(n^2)$ 的正有理数》，128(2)，2021 年）最近的一期证明了以下关于欧拉商的事实：对于任意一对正整数 $a$、$b$，存在唯一的一对正整数 $m$、$n$ 满足：\n1. $\\frac{a}{b} = \\frac{\\phi(m^2)}{\\phi(n^2)}$；\n2. 如果一个质数 $p$ 整除乘积 $mn$，则 $\\nu_p(m) \\neq \\nu_{p}(n)$；\n3. $\\gcd(m,n)$ 是无平方因子的：即对于每个质数 $p$，$\\gcd(m,n)$ 不被 $p^2$ 整除。\n\n条件 2 和 3 保证了 $m$ 和 $n$ 是满足条件 1 的唯一最小正整数对。\n\n你希望通过数值验证这一结论。编写一个程序，输入两个整数 $a$ 和 $b$，输出对应的 $m$ 和 $n$。", "inputFormat": "输入仅有一行，包含两个以空格分隔的整数 $a$ 和 $b$（$1 \\leq a, b \\leq 10\\,000$）。这两个整数保证互质。此外，$a$ 和 $b$ 的选择会使得输出的 $m$ 和 $n$ 均小于 $2^{63}$。", "outputFormat": "输出两个满足《美国数学月刊》定理中所有三个条件的正整数 $m$ 和 $n$，以空格分隔。保证 $m, n < 2^{63}$。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12621", "type": "P", "difficulty": 5, "samples": [["8\n1 3\n3 2\n1 4\n1 7\n7 6\n6 5\n6 8", "72"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["动态规划 DP", "2025", "树形 DP", "ICPC", "NAC"], "title": "[ICPC 2025 NAC] Circle of Leaf", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/at1ek3bh.png)\n\nOuroboros from [Wikimedia Commons](https://commons.wikimedia.org/wiki/File:Ouroboros-Zanaq.svg)\n", "description": "Your friend has given you a rooted tree: a connected graph with $N$ nodes and $N-1$ edges. The nodes of the tree are numbered from $1$ to $N$, with node $1$ being the root of the tree and other nodes numbered arbitrarily.\n\nHowever, you recently learned about the Ouroboros, an ancient mythical snake that eats its own tail, signifying a cycle with no beginning and end. You dislike the fact that the tree you were given has a very clear beginning at the root, and clear ends at its leaves, so you decide to completely change the structure of this tree into a new graph which you have named an *Ouroboros Graph*.\n\nTo construct this Ouroboros Graph, you take the leaves of the tree (the nodes with no direct children) and draw special \"leaf\" edges that connect every leaf directly to the root. **If there is already an edge connecting a leaf to the root, you still add a duplicate edge.**\n\nWith this special graph structure, you can now create lots of different trees by removing some subset of edges, and in the spirit of Ouroboros, the leaves and roots can change depending on which subset of edges you remove. How many different trees can you make by removing a subset of edges from the Ouroboros Graph? Two trees are considered different if one tree has an edge that the other tree does not. (If both a regular and a \"leaf\" edge connect the same pair of nodes, then they are distinguishable from each other and are considered different edges.) Since the number of trees can be large, compute the answer modulo $998\\,244\\,353$.", "inputFormat": "The first line of input contains a single integer $N$ ($2 \\leq N \\leq 200\\,000$), the number of nodes in the tree.\n\nEach of the next $N-1$ lines contains two space separated integers $a$ and $b$ ($1 \\leq a,b \\leq N$) specifying that an edge exists between parent node $a$ and child node $b$ in the tree. The input graph is indeed guaranteed to be a tree: there is a unique path of edges between every pair of nodes in the graph.", "outputFormat": "Print the number of different trees modulo $998\\,244\\,353$ that can be created by removing some subset of edges from the input tree's Ouroboros Graph.\n", "hint": "In the diagram below, the left subfigure illustrates the Ouroboros Graph corresponding to Sample Input 1, with the original edges of the tree drawn in black and the \"leaf\" edges dashed in red. The tree on the right illustrates one of the $72$ possible different trees that can be formed by deleting some subset of edges from the Ouroboros Graph: in this case, original edges $6$--$5$ and $1$--$3$ and \"leaf\" edges $1$--$8$ and $1$--$4$ were deleted.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ljg58dpq.png)", "locale": "en", "translations": {"en": {"title": "[ICPC 2025 NAC] Circle of Leaf", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/at1ek3bh.png)\n\nOuroboros from [Wikimedia Commons](https://commons.wikimedia.org/wiki/File:Ouroboros-Zanaq.svg)\n", "description": "Your friend has given you a rooted tree: a connected graph with $N$ nodes and $N-1$ edges. The nodes of the tree are numbered from $1$ to $N$, with node $1$ being the root of the tree and other nodes numbered arbitrarily.\n\nHowever, you recently learned about the Ouroboros, an ancient mythical snake that eats its own tail, signifying a cycle with no beginning and end. You dislike the fact that the tree you were given has a very clear beginning at the root, and clear ends at its leaves, so you decide to completely change the structure of this tree into a new graph which you have named an *Ouroboros Graph*.\n\nTo construct this Ouroboros Graph, you take the leaves of the tree (the nodes with no direct children) and draw special \"leaf\" edges that connect every leaf directly to the root. **If there is already an edge connecting a leaf to the root, you still add a duplicate edge.**\n\nWith this special graph structure, you can now create lots of different trees by removing some subset of edges, and in the spirit of Ouroboros, the leaves and roots can change depending on which subset of edges you remove. How many different trees can you make by removing a subset of edges from the Ouroboros Graph? Two trees are considered different if one tree has an edge that the other tree does not. (If both a regular and a \"leaf\" edge connect the same pair of nodes, then they are distinguishable from each other and are considered different edges.) Since the number of trees can be large, compute the answer modulo $998\\,244\\,353$.", "inputFormat": "The first line of input contains a single integer $N$ ($2 \\leq N \\leq 200\\,000$), the number of nodes in the tree.\n\nEach of the next $N-1$ lines contains two space separated integers $a$ and $b$ ($1 \\leq a,b \\leq N$) specifying that an edge exists between parent node $a$ and child node $b$ in the tree. The input graph is indeed guaranteed to be a tree: there is a unique path of edges between every pair of nodes in the graph.", "outputFormat": "Print the number of different trees modulo $998\\,244\\,353$ that can be created by removing some subset of edges from the input tree's Ouroboros Graph.\n", "hint": "In the diagram below, the left subfigure illustrates the Ouroboros Graph corresponding to Sample Input 1, with the original edges of the tree drawn in black and the \"leaf\" edges dashed in red. The tree on the right illustrates one of the $72$ possible different trees that can be formed by deleting some subset of edges from the Ouroboros Graph: in this case, original edges $6$--$5$ and $1$--$3$ and \"leaf\" edges $1$--$8$ and $1$--$4$ were deleted.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ljg58dpq.png)", "locale": "en"}, "zh-CN": {"title": "[ICPC 2025 NAC] Circle of Leaf", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/at1ek3bh.png)\n\n图片来自 [Wikimedia Commons](https://commons.wikimedia.org/wiki/File:Ouroboros-Zanaq.svg)", "description": "你的朋友给了你一棵有根树：一个包含 $N$ 个节点和 $N-1$ 条边的连通图。树的节点编号为 $1$ 到 $N$，其中节点 $1$ 是树的根，其他节点的编号是任意的。\n\n然而，你最近了解到衔尾蛇（Ouroboros），一种古老的神话蛇，它咬住自己的尾巴，象征着一个无始无终的循环。你不喜欢这棵树的清晰结构——根是起点，叶子是终点，因此你决定彻底改变这棵树的结构，构建一种新的图，你称之为 *衔尾蛇图*。\n\n为了构造这个衔尾蛇图，你取出树的所有叶子节点（没有直接子节点的节点），并在每个叶子和根之间添加特殊的“叶子”边。**如果某个叶子已经有一条连接到根的边，你仍然会添加一条重复的边。**\n\n在这种特殊的图结构下，你可以通过删除某些边的子集来生成许多不同的树。在衔尾蛇的精神下，根和叶子的身份会随着删除的边而变化。问：通过从衔尾蛇图中删除某些边的子集，可以生成多少种不同的树？如果两棵树有一条边存在于其中一棵树但不存在于另一棵树，则认为它们是不同的。（如果一条普通边和一条“叶子”边连接同一对节点，它们被视为不同的边。）由于树的数量可能很大，请将答案对 $998\\,244\\,353$ 取模。", "inputFormat": "第一行输入包含一个整数 $N$（$2 \\leq N \\leq 200\\,000$），表示树的节点数。\n\n接下来的 $N-1$ 行每行包含两个空格分隔的整数 $a$ 和 $b$（$1 \\leq a,b \\leq N$），表示树中父节点 $a$ 和子节点 $b$ 之间有一条边。输入保证给定的图是一棵树：图中任意两个节点之间有且仅有一条路径。\n", "outputFormat": "输出从衔尾蛇图中删除某些边的子集后可以形成的不同树的数量，结果对 $998\\,244\\,353$ 取模。\n", "hint": "在下面的示意图中，左侧子图展示了样例输入 1 对应的衔尾蛇图，其中原始树边用黑色实线表示，新增的“叶子”边用红色虚线表示。右侧的树展示了从衔尾蛇图中删除某些边后形成的 $72$ 种可能的不同树之一：在这个例子中，原始边 $6$--$5$ 和 $1$--$3$ 以及“叶子”边 $1$--$8$ 和 $1$--$4$ 被删除了。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ljg58dpq.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12622", "type": "P", "difficulty": 7, "samples": [["3 6\n1 2 3 7 8 9\n\n\n\nYes\n\nFree\n\nNo\n\nTrapped", "\n\nTrapper\n2\n4 5\n\n5\n\n0\n\n6"], ["2 0\n\n7\n3 1 2 8 9 4 5\n\n5\n\n4\n4 6 7 8\n\n7", "\nRunner\n\n\nYes\n\nFree\n\n\nYes\n\nFree\n5 4 1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["搜索", "2025", "交互题", "Special Judge", "记忆化搜索", "ICPC", "NAC"], "title": "[ICPC 2025 NAC] Entrapment", "background": "", "description": " _Entrapment_  is an asymmetric two-player game that is played on a $3\\times 3$ square grid. The two players are called the Runner and the Trapper. The grid squares are numbered from $1$ to $9$ as depicted below:\n\n$$\\begin{array}{|c|c|c|}\n    \\hline\n    1 & 2 & 3 \\\\\n    \\hline\n    4 & 5 & 6 \\\\\n    \\hline\n    7 & 8 & 9 \\\\\n    \\hline\n\\end{array}$$\n\nBefore starting the game, the players agree on the number of rounds that the game will last, and on the starting state of the game board. Up to $8$ of the grid squares can be marked as _unavailable_. The players also choose who will be the Runner and who will be the Trapper. The Runner then secretly chooses a starting square from among those that are available (i.e., are not marked as unavailable) but does not tell the Trapper their choice.\n\nEach of the game rounds consists of the following steps, in order:\n\n- The Trapper publicly chooses some subset of the available squares (the empty set is allowed) and asks the Runner, \"Are you currently in any of these squares?\"\n- The Runner answers truthfully whether or not they are in any of the chosen squares.\n- The Trapper publicly chooses exactly one available square. That square becomes unavailable for the rest of the game. (The Runner might currently reside in that square; if so, nothing special happens.)\n- The Runner secretly moves from their current square to an available orthogonally-adjacent square. If no such square exists, the Runner announces that they are trapped and the Trapper wins the game.\n\nIf the Runner has not been trapped by the end of the last round, they prove to the Trapper that they answered all questions truthfully by revealing their choice of starting square and the move that they made during each round. The Runner then wins the game.\n\nBecause the Runner's initial choice of square is secret, as are all of their subsequent moves, the Runner is allowed to \"cheat\" by not truly committing to a square.  At the end of the game, if the Runner can produce a choice of starting square and subsequent moves that do not result in being trapped and are consistent with the answers to the Trapper's questions during each round, that is enough for the Runner to win the game.", "inputFormat": "### Interaction\n\nThis is an interactive problem. Given the number of game rounds and the set of squares that are initially marked unavailable, determine whether the\nRunner or the Trapper would win assuming optimal play, and then prove it by\nplaying as that role against the judge. The judge will obey all game rules, but may or may not play optimally.\n\nInteraction starts by reading a line of $2$ space-separated integers $R$ and $U$\n($1 \\leq R \\leq 9$, $0 \\leq U \\leq 8$, $R + U \\leq 9$): the\nnumber of rounds in the game and the number of squares that are unavailable at the start of the game.\n\nNext, if $U>0$, read a line of $U$ space-separated integers $s$ ($1 \\leq s \\leq 9$): the labels of the squares that are unavailable at the start of the game. Please refer to the diagram above for how the squares in the grid are labeled. The $U$ labels are guaranteed to be distinct.\n\nDetermine whether the Runner or Trapper would win the game with optimal play, given the starting board and number of game rounds. Print a line of output with the string $\\texttt{Runner}$ if the runner wins with optimal play, and the string $\\texttt{Trapper}$ otherwise. You will play as that role for the rest of the game; please see the appropriate section below for further instructions on how to interact with the judge in that role.\n\n**For the Runner**, repeat the following steps $R$ times:\n\n- Read a line of input with a single integer $N$: the size of the subset of available squares that the Trapper has chosen to ask about. $N$ is guaranteed to be between $0$ and the number of available squares left on the board, inclusive.\n- If $N>0$, read a line of $N$ space-separated integers $\\ell$ ($1 \\leq \\ell \\leq 9$) listing the labels of the squares in the Trapper's chosen subset. The labels are guaranteed to be distinct and all of the chosen squares are guaranteed to be available.\n- Print a line of output containing either the string $\\texttt{Yes}$ or the string $\\texttt{No}$. The former informs the trapper that you are currently in one of the chosen squares; the latter informs the trapper that you are not.\n- Read a line with a single integer $i$ ($1 \\leq i \\leq 9$),  the label of the square that the Trapper marks as unavailable. It is guaranteed that square $i$ is a formerly-available square.\n- Print a line with the string $\\texttt{Free}$ to inform the Trapper that you have secretly moved to an orthogonally-adjacent available square and are ready to proceed to the next round. If there are no orthogonally-adjacent squares available, you must print $\\texttt{Trapped}$ instead and exit; your submission will be judged incorrect for having failed to elude the Trapper.\n\nAfter you have played $R$ rounds of the game according to the protocol above, print a line with $R+1$ space-separated integers. The first integer is the label of your chosen starting square; each of the next $R$ integers are the labels of the squares onto which you moved at the end of each of the $R$ rounds. Your moves must be legal and must be consistent with the answers you gave to the Trapper's queries during each round of play. After printing this line, your program must exit.\n\n**For the Trapper**, repeat the following steps $R$ times:\n\n- Print a line with a single integer $N$: the size of the subset of available squares that you would like to ask the Runner about.\n- If $N>0$, print a line of $N$ space-separated integers listing the available squares to ask the Runner about. You may list the labels in any order, but the labels must be distinct and must refer to available squares.\n- Read a line of input containing a single string: $\\texttt{Yes}$ if the Runner is in one of your chosen squares, or $\\texttt{No}$ otherwise.\n- Print a line with a single integer $i$: the square that you are marking unavailable. The label $i$ must be a valid currently-available square.\n- Read a line with a single string: $\\texttt{Free}$ if the Runner has moved to an available square, or $\\texttt{Trapped}$ if they were unable to do so. After reading the word $\\texttt{Trapped}$, you have won the game, and your program must exit. If you read the word $\\texttt{Free}$ at the end of the $R$th round, your program must also exit, though your submission will be judged incorrect since you have failed to trap the Runner.\n\nThe judge is guaranteed to answer all questions truthfully.\n\n**Do not forget to flush the output stream after each line that you print** and to cleanly exit after the interaction is done. Please also make sure that you follow the above interaction protocol exactly regarding what information to print on which line of output: for example, if the protocol requires you to print a list of space-separated integers on a single line, the judge **will not** accept each integer on its own line.\n\nIf the judge receives invalid or unexpected input, it will print $-1$ and then immediately exit. Your program must detect this error report and cleanly exit in order to receive a Wrong Answer verdict. If your program blocks waiting for further interaction from the judge, or tries to interpret the $-1$ as a game move, you may receive a different rejected verdict (such as Time Limit Exceeded or Runtime Error) instead of Wrong Answer.\n\nYou have been provided with a command-line tool for local testing. The tool has comments at the top to explain its use.", "outputFormat": "See Interaction.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2025 NAC] Entrapment", "background": "", "description": " _Entrapment_  is an asymmetric two-player game that is played on a $3\\times 3$ square grid. The two players are called the Runner and the Trapper. The grid squares are numbered from $1$ to $9$ as depicted below:\n\n$$\\begin{array}{|c|c|c|}\n    \\hline\n    1 & 2 & 3 \\\\\n    \\hline\n    4 & 5 & 6 \\\\\n    \\hline\n    7 & 8 & 9 \\\\\n    \\hline\n\\end{array}$$\n\nBefore starting the game, the players agree on the number of rounds that the game will last, and on the starting state of the game board. Up to $8$ of the grid squares can be marked as _unavailable_. The players also choose who will be the Runner and who will be the Trapper. The Runner then secretly chooses a starting square from among those that are available (i.e., are not marked as unavailable) but does not tell the Trapper their choice.\n\nEach of the game rounds consists of the following steps, in order:\n\n- The Trapper publicly chooses some subset of the available squares (the empty set is allowed) and asks the Runner, \"Are you currently in any of these squares?\"\n- The Runner answers truthfully whether or not they are in any of the chosen squares.\n- The Trapper publicly chooses exactly one available square. That square becomes unavailable for the rest of the game. (The Runner might currently reside in that square; if so, nothing special happens.)\n- The Runner secretly moves from their current square to an available orthogonally-adjacent square. If no such square exists, the Runner announces that they are trapped and the Trapper wins the game.\n\nIf the Runner has not been trapped by the end of the last round, they prove to the Trapper that they answered all questions truthfully by revealing their choice of starting square and the move that they made during each round. The Runner then wins the game.\n\nBecause the Runner's initial choice of square is secret, as are all of their subsequent moves, the Runner is allowed to \"cheat\" by not truly committing to a square.  At the end of the game, if the Runner can produce a choice of starting square and subsequent moves that do not result in being trapped and are consistent with the answers to the Trapper's questions during each round, that is enough for the Runner to win the game.", "inputFormat": "### Interaction\n\nThis is an interactive problem. Given the number of game rounds and the set of squares that are initially marked unavailable, determine whether the\nRunner or the Trapper would win assuming optimal play, and then prove it by\nplaying as that role against the judge. The judge will obey all game rules, but may or may not play optimally.\n\nInteraction starts by reading a line of $2$ space-separated integers $R$ and $U$\n($1 \\leq R \\leq 9$, $0 \\leq U \\leq 8$, $R + U \\leq 9$): the\nnumber of rounds in the game and the number of squares that are unavailable at the start of the game.\n\nNext, if $U>0$, read a line of $U$ space-separated integers $s$ ($1 \\leq s \\leq 9$): the labels of the squares that are unavailable at the start of the game. Please refer to the diagram above for how the squares in the grid are labeled. The $U$ labels are guaranteed to be distinct.\n\nDetermine whether the Runner or Trapper would win the game with optimal play, given the starting board and number of game rounds. Print a line of output with the string $\\texttt{Runner}$ if the runner wins with optimal play, and the string $\\texttt{Trapper}$ otherwise. You will play as that role for the rest of the game; please see the appropriate section below for further instructions on how to interact with the judge in that role.\n\n**For the Runner**, repeat the following steps $R$ times:\n\n- Read a line of input with a single integer $N$: the size of the subset of available squares that the Trapper has chosen to ask about. $N$ is guaranteed to be between $0$ and the number of available squares left on the board, inclusive.\n- If $N>0$, read a line of $N$ space-separated integers $\\ell$ ($1 \\leq \\ell \\leq 9$) listing the labels of the squares in the Trapper's chosen subset. The labels are guaranteed to be distinct and all of the chosen squares are guaranteed to be available.\n- Print a line of output containing either the string $\\texttt{Yes}$ or the string $\\texttt{No}$. The former informs the trapper that you are currently in one of the chosen squares; the latter informs the trapper that you are not.\n- Read a line with a single integer $i$ ($1 \\leq i \\leq 9$),  the label of the square that the Trapper marks as unavailable. It is guaranteed that square $i$ is a formerly-available square.\n- Print a line with the string $\\texttt{Free}$ to inform the Trapper that you have secretly moved to an orthogonally-adjacent available square and are ready to proceed to the next round. If there are no orthogonally-adjacent squares available, you must print $\\texttt{Trapped}$ instead and exit; your submission will be judged incorrect for having failed to elude the Trapper.\n\nAfter you have played $R$ rounds of the game according to the protocol above, print a line with $R+1$ space-separated integers. The first integer is the label of your chosen starting square; each of the next $R$ integers are the labels of the squares onto which you moved at the end of each of the $R$ rounds. Your moves must be legal and must be consistent with the answers you gave to the Trapper's queries during each round of play. After printing this line, your program must exit.\n\n**For the Trapper**, repeat the following steps $R$ times:\n\n- Print a line with a single integer $N$: the size of the subset of available squares that you would like to ask the Runner about.\n- If $N>0$, print a line of $N$ space-separated integers listing the available squares to ask the Runner about. You may list the labels in any order, but the labels must be distinct and must refer to available squares.\n- Read a line of input containing a single string: $\\texttt{Yes}$ if the Runner is in one of your chosen squares, or $\\texttt{No}$ otherwise.\n- Print a line with a single integer $i$: the square that you are marking unavailable. The label $i$ must be a valid currently-available square.\n- Read a line with a single string: $\\texttt{Free}$ if the Runner has moved to an available square, or $\\texttt{Trapped}$ if they were unable to do so. After reading the word $\\texttt{Trapped}$, you have won the game, and your program must exit. If you read the word $\\texttt{Free}$ at the end of the $R$th round, your program must also exit, though your submission will be judged incorrect since you have failed to trap the Runner.\n\nThe judge is guaranteed to answer all questions truthfully.\n\n**Do not forget to flush the output stream after each line that you print** and to cleanly exit after the interaction is done. Please also make sure that you follow the above interaction protocol exactly regarding what information to print on which line of output: for example, if the protocol requires you to print a list of space-separated integers on a single line, the judge **will not** accept each integer on its own line.\n\nIf the judge receives invalid or unexpected input, it will print $-1$ and then immediately exit. Your program must detect this error report and cleanly exit in order to receive a Wrong Answer verdict. If your program blocks waiting for further interaction from the judge, or tries to interpret the $-1$ as a game move, you may receive a different rejected verdict (such as Time Limit Exceeded or Runtime Error) instead of Wrong Answer.\n\nYou have been provided with a command-line tool for local testing. The tool has comments at the top to explain its use.", "outputFormat": "See Interaction.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2025 NAC] Entrapment", "background": "", "description": "_Entrapment_ 是一款非对称的双人游戏，在一个 $3 \\times 3$ 的方格棋盘上进行。两名玩家分别称为 Runner（逃亡者）和 Trapper（追捕者）。棋盘方格编号如下：\n\n$$\\begin{array}{|c|c|c|}\n    \\hline\n    1 & 2 & 3 \\\\\n    \\hline\n    4 & 5 & 6 \\\\\n    \\hline\n    7 & 8 & 9 \\\\\n    \\hline\n\\end{array}$$\n\n游戏开始前，玩家需约定游戏轮数 $R$ 和初始棋盘状态。最多有 $8$ 个方格可被标记为 _不可用_。玩家还需确定谁扮演 Runner，谁扮演 Trapper。Runner 会秘密选择一个可用的起始方格（未被标记为不可用的方格），但不会告知 Trapper。\n\n每轮游戏按以下顺序进行：\n1. Trapper 公开选择一个可用方格的子集（允许空集），并询问 Runner：\"你当前是否在这些方格中？\"\n2. Runner 必须如实回答\"是\"或\"否\"。\n3. Trapper 公开选择一个可用方格，该方格在后续游戏中变为不可用。（Runner 可能正位于该方格，此时无特殊效果）\n4. Runner 秘密移动到当前方格的相邻可用方格（上下左右相邻）。若无可用相邻方格，Runner 宣布被捕获，Trapper 获胜。\n\n若游戏结束时 Runner 未被捕获，需向 Trapper 证明自己始终诚实：公开起始方格和每轮移动路径。此时 Runner 获胜。\n\n由于 Runner 的初始选择和移动路径都是秘密的，Runner 可以通过\"作弊\"（不真正固定位置）来规避追捕。只要最终能提供符合所有回答的合法移动路径，Runner 即可获胜。", "inputFormat": "### 交互说明\n\n本题为交互题。给定游戏轮数 $R$ 和初始不可用方格集合，判断在最优策略下 Runner 或 Trapper 谁能获胜，并作为该角色与评测机对战。评测机会遵守游戏规则，但不保证采用最优策略。\n\n交互开始时，首先读取一行两个整数 $R$ 和 $U$（$1 \\leq R \\leq 9$，$0 \\leq U \\leq 8$，$R + U \\leq 9$），分别表示游戏轮数和初始不可用方格数量。\n\n若 $U > 0$，接着读取一行 $U$ 个空格分隔的整数 $s$（$1 \\leq s \\leq 9$），表示初始不可用方格的编号（参见上方编号图示）。保证这些编号互不相同。\n\n判断最优策略下的获胜方，输出一行字符串 $\\texttt{Runner}$（Runner 必胜）或 $\\texttt{Trapper}$（否则）。之后将作为该角色继续交互：\n\n**作为 Runner** 时，重复以下步骤 $R$ 次：\n1. 读取一个整数 $N$ 表示 Trapper 询问的方格数量（$0 \\leq N \\leq \\text{可用方格数}$）\n2. 若 $N > 0$，读取一行 $N$ 个空格分隔的整数 $\\ell$，表示被询问的方格编号（保证编号合法且可用）\n3. 输出 $\\texttt{Yes}$ 或 $\\texttt{No}$ 回答是否位于被询问方格中\n4. 读取一个整数 $i$ 表示 Trapper 标记为不可用的方格（保证该方格当前可用）\n5. 若有可用相邻方格，输出 $\\texttt{Free}$；否则输出 $\\texttt{Trapped}$ 并退出（此时判负）\n\n完成 $R$ 轮后，输出一行 $R+1$ 个空格分隔的整数：起始方格编号和每轮移动的目标方格编号。移动路径必须合法且与之前回答一致，然后退出程序。\n\n**作为 Trapper** 时，重复以下步骤 $R$ 次：\n1. 输出一个整数 $N$ 表示询问的方格数量\n2. 若 $N > 0$，输出一行 $N$ 个空格分隔的可用方格编号\n3. 读取 $\\texttt{Yes}$ 或 $\\texttt{No}$ 作为回答\n4. 输出一个整数 $i$ 表示要标记为不可用的方格（必须当前可用）\n5. 读取 $\\texttt{Free}$ 或 $\\texttt{Trapped}$：若为后者则获胜并退出；若完成 $R$ 轮后 Runner 仍自由则判负\n\n评测机保证所有回答真实有效。\n\n**注意**：每次输出后需刷新输出流，交互结束后需立即退出。若评测机收到非法输入会输出 $-1$ 并退出，此时程序必须检测该错误并退出以避免错误判定。", "outputFormat": "参见交互说明。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12623", "type": "P", "difficulty": 5, "samples": [["4 4 5 5\n0 5\n0 2\n5 2\n5 5\n0 -5\n0 -2\n5 -2\n5 -5", "-1 1"], ["4 4 6 5\n0 5\n0 2\n6 2\n6 5\n0 -5\n0 -2\n6 -2\n6 -5", "0 0"], ["3 3 7 5\n0 5\n5 -1\n7 5\n0 -5\n2 1\n7 -5", "impossible"], ["4 3 5 5\n0 5\n0 2\n5 2\n5 5\n0 -5\n3 -1\n5 -5", "-1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "ICPC", "双指针 two-pointer", "NAC"], "title": "[ICPC 2025 NAC] Geometry Rush", "background": "", "description": "You are playing the summer's hottest rhythm-based action platformer---Geometry Rush! The game is played on a 2D plane. Your character begins at $(0,0)$ and every second must move at a $45$-degree angle either up-right or down-right, which takes your character from position $(x,y)$ to $(x+1,y+1)$ or $(x+1, y-1)$ respectively. You can change which direction you move every second, but not in between moves. There are obstacles protruding from the floor and ceiling that you must dodge. You win the game if, after $w$ seconds, you reach the line $x=w$ without having touched any obstacles on the way.\n\nThe play area extends vertically from $y=-h$ to $y=h$. Obstacles are two polygonal curves: one curve starts at $(0,h)$ and ends at $(w,h)$ and represents a ceiling of varying height. The $x$ values of the vertices of this curve are non-decreasing, and the $y$ values lie between $-h$ and $h$ inclusive. A second polygonal curve starts at $(0,-h)$ and ends at $(w,-h)$ and represents the floor. Its vertices satisfy similar constraints.\n\nYour character is a point of negligible extent: you can move from position $(x,y)$ to $(x+1,y\\pm 1)$ so long as the line segment between your start and end position does not intersect either obstacle. (Exactly touching either polygonal curve counts as intersecting an obstacle, and loses the game.)\n\nYou have played *a lot* of games of Geometry Rush. To keep the game interesting, you have started to set challenges for yourself. For example: you win the game no matter where you cross the $x=w$ goal line. But for what maximum value of $y$ can you win the game by crossing at $(w,y)$ without touching any obstacles on the way? For what minimum value? Compute these numbers.", "inputFormat": "The first line of the input contains four space-separated integers $n$, $m$, $w$, and $h$. The first two integers ($3 \\leq n, m \\leq 10^{5}$) are the number of vertices in the ceiling and floor polygonal curves, respectively. The second two integers ($3 \\leq w, h \\leq 10^{5}$) are the width and height of the play area, as described above.\n\nThe next $n$ lines each contain two space-separated integers $x$ and $y$ ($0 \\leq x \\leq w$; $-h \\leq y \\leq h$): the coordinates of the vertices of the ceiling polygonal curve, in order from left to right. It is guaranteed that the first vertex is at $(0,h)$ and the last vertex is at $(w,h)$.\n\nThe next $m$ lines each contain two space-separated integers $x$ and $y$ ($0 \\leq x \\leq w$; $-h \\leq y \\leq h$): the coordinates of the vertices of the floor polygonal curve, in order from left to right. It is guaranteed that the first vertex is at $(0,-h)$ and the last vertex is at $(w,-h)$.\n\nFor both polygonal curves: the $x$ coordinates are non-decreasing, all vertices are distinct, and the curve does not self-intersect. Neither curve intersects $(0,0)$. (The floor and ceiling curves might intersect each other, in which case the game is unwinnable.)", "outputFormat": "If it is impossible to win the game, print $\\texttt{impossible}$. Otherwise, print two space-separated integers: the minimum and maximum $y$ values that the player could reach at $x=w$ without losing the game by touching an obstacle along the way.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2025 NAC] Geometry Rush", "background": "", "description": "You are playing the summer's hottest rhythm-based action platformer---Geometry Rush! The game is played on a 2D plane. Your character begins at $(0,0)$ and every second must move at a $45$-degree angle either up-right or down-right, which takes your character from position $(x,y)$ to $(x+1,y+1)$ or $(x+1, y-1)$ respectively. You can change which direction you move every second, but not in between moves. There are obstacles protruding from the floor and ceiling that you must dodge. You win the game if, after $w$ seconds, you reach the line $x=w$ without having touched any obstacles on the way.\n\nThe play area extends vertically from $y=-h$ to $y=h$. Obstacles are two polygonal curves: one curve starts at $(0,h)$ and ends at $(w,h)$ and represents a ceiling of varying height. The $x$ values of the vertices of this curve are non-decreasing, and the $y$ values lie between $-h$ and $h$ inclusive. A second polygonal curve starts at $(0,-h)$ and ends at $(w,-h)$ and represents the floor. Its vertices satisfy similar constraints.\n\nYour character is a point of negligible extent: you can move from position $(x,y)$ to $(x+1,y\\pm 1)$ so long as the line segment between your start and end position does not intersect either obstacle. (Exactly touching either polygonal curve counts as intersecting an obstacle, and loses the game.)\n\nYou have played *a lot* of games of Geometry Rush. To keep the game interesting, you have started to set challenges for yourself. For example: you win the game no matter where you cross the $x=w$ goal line. But for what maximum value of $y$ can you win the game by crossing at $(w,y)$ without touching any obstacles on the way? For what minimum value? Compute these numbers.", "inputFormat": "The first line of the input contains four space-separated integers $n$, $m$, $w$, and $h$. The first two integers ($3 \\leq n, m \\leq 10^{5}$) are the number of vertices in the ceiling and floor polygonal curves, respectively. The second two integers ($3 \\leq w, h \\leq 10^{5}$) are the width and height of the play area, as described above.\n\nThe next $n$ lines each contain two space-separated integers $x$ and $y$ ($0 \\leq x \\leq w$; $-h \\leq y \\leq h$): the coordinates of the vertices of the ceiling polygonal curve, in order from left to right. It is guaranteed that the first vertex is at $(0,h)$ and the last vertex is at $(w,h)$.\n\nThe next $m$ lines each contain two space-separated integers $x$ and $y$ ($0 \\leq x \\leq w$; $-h \\leq y \\leq h$): the coordinates of the vertices of the floor polygonal curve, in order from left to right. It is guaranteed that the first vertex is at $(0,-h)$ and the last vertex is at $(w,-h)$.\n\nFor both polygonal curves: the $x$ coordinates are non-decreasing, all vertices are distinct, and the curve does not self-intersect. Neither curve intersects $(0,0)$. (The floor and ceiling curves might intersect each other, in which case the game is unwinnable.)", "outputFormat": "If it is impossible to win the game, print $\\texttt{impossible}$. Otherwise, print two space-separated integers: the minimum and maximum $y$ values that the player could reach at $x=w$ without losing the game by touching an obstacle along the way.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2025 NAC] Geometry Rush", "background": "", "description": "你正在玩今夏最热门的节奏动作平台游戏——Geometry Rush！游戏在一个二维平面上进行。你的角色从 $(0,0)$ 出发，每秒必须以 $45$ 度角向上或向下移动，即从位置 $(x,y)$ 移动到 $(x+1,y+1)$ 或 $(x+1,y-1)$。你可以在每秒改变移动方向，但不能在移动过程中调整。游戏中有从天花板和地面突出的障碍物需要躲避。若在 $w$ 秒后到达终点线 $x=w$ 且未触碰任何障碍物，则获胜。\n\n游戏区域的垂直范围为 $y=-h$ 到 $y=h$。障碍物由两条多边形曲线组成：一条从 $(0,h)$ 延伸到 $(w,h)$ 表示变化高度的天花板，其顶点的 $x$ 坐标非递减，$y$ 坐标在 $[-h,h]$ 范围内；另一条从 $(0,-h)$ 延伸到 $(w,-h)$ 表示地面，其顶点满足类似约束。\n\n你的角色被视为一个无限小的点：从 $(x,y)$ 移动到 $(x+1,y \\pm 1)$ 时，若移动路径与任一障碍物相交（包括恰好接触多边形曲线）则游戏失败。\n\n为了增加挑战性，你开始设定特殊目标：无论从终点线 $x=w$ 的哪个位置穿过均可获胜，但求能穿过的最大 $y$ 值和最小 $y$ 值分别是多少？", "inputFormat": "第一行包含四个整数 $n$、$m$、$w$ 和 $h$（$3 \\leq n, m \\leq 10^{5}$；$3 \\leq w, h \\leq 10^{5}$），分别表示天花板和地面多边形曲线的顶点数，以及游戏区域的宽度和高度。\n\n接下来 $n$ 行每行两个整数 $x$ 和 $y$（$0 \\leq x \\leq w$，$-h \\leq y \\leq h$），按从左到右顺序给出天花板曲线的顶点坐标。保证第一个顶点为 $(0,h)$，最后一个为 $(w,h)$。\n\n随后 $m$ 行以相同格式给出地面曲线的顶点坐标，首尾顶点分别为 $(0,-h)$ 和 $(w,-h)$。\n\n对于两条曲线：$x$ 坐标非递减，顶点互不重复，曲线不自交。两条曲线均不经过 $(0,0)$（若曲线相交则游戏无法获胜）。", "outputFormat": "若游戏无法获胜，输出 $\\texttt{impossible}$。否则输出两个整数：可到达终点线 $x=w$ 的最小和最大 $y$ 值。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12624", "type": "P", "difficulty": 6, "samples": [["10 2\n3 5 7 6 8 6 4 5 2 6\n2 4 6 5 4 3 3 6 3 4", "4"], ["7 1\n4 3 2 1 7 6 5\n4 2 3 1 7 6 5", "11"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["线段树", "树状数组", "2025", "分治", "ST 表", "ICPC", "NAC"], "title": "[ICPC 2025 NAC] Humans vs AI", "background": "", "description": "In the world of rising AI, James is scared of losing his job. So, when his boss asks him to evaluate a new AI model to see how well it performs compared to humans, he wants to make it look as bad as possible.\n\nTo test the AI, James conducts a sequence of $N$ trials where a human and an AI are\ngiven the same task and then scored based on their performance on the task. \nHe is then going to send the results of some non-empty contiguous subsequence of these trials to his boss and quietly delete the rest.\n\nLet $a_i$ and $h_i$ be the performance of the AI and human on trial $i$, respectively. James's boss evaluates the AI on a sequence of trials by calculating two total scores: one for the humans, and one for the AI. Both scores are initially $0$. For each trial $i$ where $h_i \\geq a_i$, the boss awards the humans $h_i-a_i$ points. For each trial where $h_i < a_i$, the AI earns $a_i-h_i$ points.\nIf the humans' total score is greater than or equal to the AI's total score times some constant $k$ (to account for humans needing food, water, and a desk), James's boss declares that the humans outperform the AI.\n\nJames plans to send his chosen subsequence of test results through email to his boss. There is, however, one complication: since AI is already all-knowing and all-pervasive, it intercepts this email and may swap the value of $h_i$ and $a_i$ for one trial $i$ of its choice. (It doesn't want to swap more than one trial result---James might notice!)\n\nCount how many non-empty contiguous subsequences of trial results James could send his boss with the guarantee that humans will be declared to outperform the AI, even if the AI swaps the result of up to one trial.", "inputFormat": "The first line of input contains two space-separate integers: $N$ ($1 \\leq N \\leq 2 \\cdot 10^5$), the total number of trials James conducted, and $k$ ($1 \\leq k \\leq 100$), the multiplier James's boss will apply to the AI's total score to determine whether humans outperform AI.\n\nThe second line contains $N$ space-separated integers $h_1, h_2, \\ldots, h_N$ ($0 \\leq h_i \\leq 10^6$), the performance of the humans on each of the $N$ trials.\n\nThe third line contains $N$ space-separated integers $a_1, a_2, \\ldots, a_N$ ($0 \\leq a_i \\leq 10^6$), the performance of the AI on the $N$ trials.", "outputFormat": "Print the number of non-empty contiguous trial subsequences for which James's boss would declare that humans outperform AI, even if the AI swaps the result of up to one trial.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2025 NAC] Humans vs AI", "background": "", "description": "In the world of rising AI, James is scared of losing his job. So, when his boss asks him to evaluate a new AI model to see how well it performs compared to humans, he wants to make it look as bad as possible.\n\nTo test the AI, James conducts a sequence of $N$ trials where a human and an AI are\ngiven the same task and then scored based on their performance on the task. \nHe is then going to send the results of some non-empty contiguous subsequence of these trials to his boss and quietly delete the rest.\n\nLet $a_i$ and $h_i$ be the performance of the AI and human on trial $i$, respectively. James's boss evaluates the AI on a sequence of trials by calculating two total scores: one for the humans, and one for the AI. Both scores are initially $0$. For each trial $i$ where $h_i \\geq a_i$, the boss awards the humans $h_i-a_i$ points. For each trial where $h_i < a_i$, the AI earns $a_i-h_i$ points.\nIf the humans' total score is greater than or equal to the AI's total score times some constant $k$ (to account for humans needing food, water, and a desk), James's boss declares that the humans outperform the AI.\n\nJames plans to send his chosen subsequence of test results through email to his boss. There is, however, one complication: since AI is already all-knowing and all-pervasive, it intercepts this email and may swap the value of $h_i$ and $a_i$ for one trial $i$ of its choice. (It doesn't want to swap more than one trial result---James might notice!)\n\nCount how many non-empty contiguous subsequences of trial results James could send his boss with the guarantee that humans will be declared to outperform the AI, even if the AI swaps the result of up to one trial.", "inputFormat": "The first line of input contains two space-separate integers: $N$ ($1 \\leq N \\leq 2 \\cdot 10^5$), the total number of trials James conducted, and $k$ ($1 \\leq k \\leq 100$), the multiplier James's boss will apply to the AI's total score to determine whether humans outperform AI.\n\nThe second line contains $N$ space-separated integers $h_1, h_2, \\ldots, h_N$ ($0 \\leq h_i \\leq 10^6$), the performance of the humans on each of the $N$ trials.\n\nThe third line contains $N$ space-separated integers $a_1, a_2, \\ldots, a_N$ ($0 \\leq a_i \\leq 10^6$), the performance of the AI on the $N$ trials.", "outputFormat": "Print the number of non-empty contiguous trial subsequences for which James's boss would declare that humans outperform AI, even if the AI swaps the result of up to one trial.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2025 NAC] Humans vs AI", "background": "", "description": "在人工智能崛起的时代，James 害怕失去工作。因此，当老板要求他评估一个新 AI 模型与人类的表现对比时，他想要尽可能让 AI 看起来表现糟糕。\n\n为了测试 AI，James 进行了 $N$ 次试验，每次试验中人类和 AI 执行相同任务并根据表现评分。之后他将选择这些试验结果的某个非空连续子序列发送给老板，并悄悄删除其余部分。\n\n设 $a_i$ 和 $h_i$ 分别表示第 $i$ 次试验中 AI 和人类的表现。老板通过计算两个总分来评估序列：人类总分和 AI 总分，初始均为 $0$。对于每个 $h_i \\geq a_i$ 的试验，老板给人类加 $h_i - a_i$ 分；对于每个 $h_i < a_i$ 的试验，AI 获得 $a_i - h_i$ 分。若人类总分大于等于 AI 总分乘以常数 $k$（考虑人类需要食物、水和工位等因素），老板则判定人类优于 AI。\n\nJames 计划通过邮件发送选定的试验结果子序列。但有一个问题：无所不知的 AI 会拦截邮件，并可能选择交换某次试验的 $h_i$ 和 $a_i$ 值（最多交换一次，以免 James 察觉）。\n\n计算有多少个非空连续子序列能保证：即使 AI 交换最多一次试验结果，老板仍会判定人类优于 AI。", "inputFormat": "第一行输入两个整数 $N$（$1 \\leq N \\leq 2 \\cdot 10^5$）和 $k$（$1 \\leq k \\leq 100$），分别表示试验次数和 AI 分数乘数。\n\n第二行包含 $N$ 个整数 $h_1, h_2, \\ldots, h_N$（$0 \\leq h_i \\leq 10^6$），表示人类每次试验的表现。\n\n第三行包含 $N$ 个整数 $a_1, a_2, \\ldots, a_N$（$0 \\leq a_i \\leq 10^6$），表示 AI 每次试验的表现。\n", "outputFormat": "输出满足条件的非空连续子序列数量。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12625", "type": "P", "difficulty": 5, "samples": [["2\n4 3 5 3 1 2\n1 2 0 1 0 0", "RR*\nURU\nUDU\nULL\n\nR*"], ["3\n3 3 0 0 0 8\n2 2 0 2 0 1\n1 1 0 0 0 0", "impossible\n\nimpossible\n\n*"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "Special Judge", "构造", "ICPC", "NAC"], "title": "[ICPC 2025 NAC] Mob Grinder", "background": "", "description": "In a certain popular sandbox video game, one can build a structure called a *mob grinder*.\n\nA mob grinder consists of an $N\\times M$ rectangular grid of tiles. Monsters, also known as \"mobs\", appear continuously at random places on the grid. The goal of a mob grinder is to move all of the monsters to the top-right tile in the grid, no matter where they originally appear. To accomplish this goal, each tile (except for the top-right tile) has a conveyor belt on it with a specified direction (up, right, down, or left). A monster on a conveyor belt gets moved to the orthogonally adjacent tile in the direction specified by the conveyor belt orientation.\n\nYour job is to place a conveyor belt on each tile (other than the top-right corner) so that no matter where a monster appears on the grid, it will get moved to the top-right corner after a finite amount of time, without ever leaving the bounds of the grid. However, there is a limit on how many conveyor belts you can use of each orientation: your final design must have exactly $U$ conveyor belts going up, $R$ going right, $D$ going down, and $L$ going left.\n\nYou are asked to design multiple mob grinders, each with a specification of how many conveyor belts of each type you are allowed to use. Design a valid mob grinder that meets each specification, if possible.", "inputFormat": "The first line of input contains an integer $T$ ($1 \\leq T \\leq 10^5$): the number of mob grinders you need to design.\n\nEach of the next $T$ lines of input contains six space-separated integers that describe one mob grinder specification. The first two integers, $N$ and $M$, ($1\\leq N,M$ and $N\\cdot M \\leq 10^5)$ are the number of rows and columns in the grid, respectively. The last four, $U$, $R$, $D$, $L$ $(0 \\leq U, R, D, L$ and $U+R+D+L = (N \\cdot M)-1)$, are the number of times you must use each conveyor belt orientation in your design.\n\nIt is guaranteed that the sum of $N\\cdot M$ over all $T$ mob grinders does not exceed $10^5$.", "outputFormat": "Print $T$ mob grinder designs, one for each specification. Separate consecutive designs with a single empty line.\n\nIf it is impossible to construct a valid mob grinder respecting the given constraints for the given specification, print $\\texttt{impossible}$. Otherwise, print an $N\\times M$ grid of ASCII characters. The top-right tile must be a $\\texttt{*}$. \nEvery other character in the grid must be either $\\texttt{U}$, $\\texttt{R}$, $\\texttt{D}$, or $\\texttt{L}$, representing the orientation of the conveyor belt on that grid tile.\n\n**This problem is whitespace-sensitive.** You *must* separate each mob grinder design with exactly one empty line (containing just a newline character). You *must not* print an empty line, or any other extraneous output, after the last mob grinder design (though the last line of output must be terminated with a newline). Please see the Sample Output for examples of how to correctly format your mob grinder designs.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2025 NAC] Mob Grinder", "background": "", "description": "In a certain popular sandbox video game, one can build a structure called a *mob grinder*.\n\nA mob grinder consists of an $N\\times M$ rectangular grid of tiles. Monsters, also known as \"mobs\", appear continuously at random places on the grid. The goal of a mob grinder is to move all of the monsters to the top-right tile in the grid, no matter where they originally appear. To accomplish this goal, each tile (except for the top-right tile) has a conveyor belt on it with a specified direction (up, right, down, or left). A monster on a conveyor belt gets moved to the orthogonally adjacent tile in the direction specified by the conveyor belt orientation.\n\nYour job is to place a conveyor belt on each tile (other than the top-right corner) so that no matter where a monster appears on the grid, it will get moved to the top-right corner after a finite amount of time, without ever leaving the bounds of the grid. However, there is a limit on how many conveyor belts you can use of each orientation: your final design must have exactly $U$ conveyor belts going up, $R$ going right, $D$ going down, and $L$ going left.\n\nYou are asked to design multiple mob grinders, each with a specification of how many conveyor belts of each type you are allowed to use. Design a valid mob grinder that meets each specification, if possible.", "inputFormat": "The first line of input contains an integer $T$ ($1 \\leq T \\leq 10^5$): the number of mob grinders you need to design.\n\nEach of the next $T$ lines of input contains six space-separated integers that describe one mob grinder specification. The first two integers, $N$ and $M$, ($1\\leq N,M$ and $N\\cdot M \\leq 10^5)$ are the number of rows and columns in the grid, respectively. The last four, $U$, $R$, $D$, $L$ $(0 \\leq U, R, D, L$ and $U+R+D+L = (N \\cdot M)-1)$, are the number of times you must use each conveyor belt orientation in your design.\n\nIt is guaranteed that the sum of $N\\cdot M$ over all $T$ mob grinders does not exceed $10^5$.", "outputFormat": "Print $T$ mob grinder designs, one for each specification. Separate consecutive designs with a single empty line.\n\nIf it is impossible to construct a valid mob grinder respecting the given constraints for the given specification, print $\\texttt{impossible}$. Otherwise, print an $N\\times M$ grid of ASCII characters. The top-right tile must be a $\\texttt{*}$. \nEvery other character in the grid must be either $\\texttt{U}$, $\\texttt{R}$, $\\texttt{D}$, or $\\texttt{L}$, representing the orientation of the conveyor belt on that grid tile.\n\n**This problem is whitespace-sensitive.** You *must* separate each mob grinder design with exactly one empty line (containing just a newline character). You *must not* print an empty line, or any other extraneous output, after the last mob grinder design (though the last line of output must be terminated with a newline). Please see the Sample Output for examples of how to correctly format your mob grinder designs.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2025 NAC] Mob Grinder", "background": "", "description": "在某款流行的沙盒视频游戏中，玩家可以建造一种名为 *mob grinder*（怪物磨床）的结构。\n\n一个 mob grinder 由 $N \\times M$ 的矩形网格组成。怪物（或称 \"mob\"）会随机出现在网格各处。mob grinder 的目标是将所有怪物移动到网格右上角的格子，无论它们最初出现在哪里。为实现这一目标，每个格子（除右上角外）都装有一个指定方向（上、右、下、左）的传送带。怪物在传送带上会沿着传送带方向移动到相邻的格子。\n\n你的任务是为每个格子（除右上角外）设置传送带方向，使得无论怪物出现在网格何处，都能在有限时间内被传送到右上角，且不会离开网格边界。但每种方向的传送带使用数量有限制：最终设计必须恰好使用 $U$ 个向上、$R$ 个向右、$D$ 个向下、$L$ 个向左的传送带。\n\n你需要设计多个 mob grinder，每个都有特定的传送带使用数量要求。判断每个规格是否可行，若可行则输出有效设计。", "inputFormat": "第一行输入整数 $T$（$1 \\leq T \\leq 10^5$），表示需要设计的 mob grinder 数量。\n\n接下来 $T$ 行每行包含六个整数，描述一个 mob grinder 规格：前两个整数 $N$ 和 $M$（$1 \\leq N,M$ 且 $N \\cdot M \\leq 10^5$）表示网格的行列数；后四个整数 $U$、$R$、$D$、$L$（$0 \\leq U, R, D, L$ 且 $U + R + D + L = (N \\cdot M) - 1$）表示各方向传送带的使用数量。\n\n保证所有 $T$ 个 mob grinder 的 $N \\cdot M$ 总和不超过 $10^5$。\n", "outputFormat": "输出 $T$ 个 mob grinder 设计，每个规格对应一个，相邻设计用空行分隔。\n\n若某规格无法构造有效设计，输出 $\\texttt{impossible}$。否则输出 $N \\times M$ 的 ASCII 字符网格：右上角格子为 $\\texttt{*}$，其余格子为 $\\texttt{U}$、$\\texttt{R}$、$\\texttt{D}$ 或 $\\texttt{L}$，表示传送带方向。\n\n**注意空白符敏感**：必须用恰好一个空行（仅含换行符）分隔设计，最后一行输出后不得有多余空行（但需以换行符结尾）。参见样例输出格式。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12626", "type": "P", "difficulty": 7, "samples": [["6 9\n1 2 9\n2 3 9\n3 4 9\n3 4 -9\n4 1 9\n1 5 1\n5 6 1\n6 2 1\n3 4 8", "36"], ["5 7\n1 2 1\n2 3 -2\n3 4 3\n4 5 6\n5 1 4\n5 3 2\n2 5 9", "16"]], "limits": {"time": [7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000, 7000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "ICPC", "NAC"], "title": "[ICPC 2025 NAC] Most Scenic Cycle", "background": "", "description": "The government of the Independent Country of Problem Creators (ICPC) finally saved enough money to construct high speed rail infrastructure. The new rail system has $V$ stations and $E$ bidirectional direct railway lines that each connect two stations together. The head of ICPC Rail Infrastructure Planning, Skib E. Dee, has seen enough programming problems about tree-topology transportation networks in other countries to know that such a network would be a recipe for disaster: a single broken railway line would split the network into disconnected pieces and disrupt travel for days. Instead, Dee decided that the ICPC rail network will be **robustly connected**: every pair of stations $s_1$, $s_2$ must be connected by at least two paths which do not share any direct railway lines, and do not share any railway stations other than $s_1$ and $s_2$ themselves.\n\nOf course, ICPC cannot afford to build too many redundant railway lines. To balance efficiency and resiliency, Dee has also designed the network to be **regionally connected**. A cycle is a non-empty path from a station to itself which doesn't repeat any railway station (apart from the first station, which must repeat exactly once as the last station of the cycle). In order for the network to be regionally connected, there must exist a set $\\mathcal{F}$ of $E-V+1$ **regional cycles** satisfying three properties:\n\n- every direct railway line in the transportation network belongs to at least one regional cycle;\n- if two regional cycles share any direct railway lines, then all railway lines and stations shared by those cycles lie along a connected path;\n- for each subset $f$ of $\\mathcal{F}$, at most $|f|-1$ pairs of regional cycles in $f$ share any direct railway lines.\n\nTo promote the new high speed rail, Dee needs to create a timelapse video of a train travelling around some cycle in the railway network. Each direct railway line has a (possibly negative) scenic value representing how nice the view out the train window is along that line. Dee wants to send the train around whichever cycle maximizes the sum of scenic values of the direct railway lines on the cycle---compute this maximum possible sum. (The most scenic cycle that Dee is looking for does **not** have to be a regional cycle.) In order to ensure this cycle is not boring, it must traverse at least two direct railway lines, and must not repeat any railway station (apart from the first station, which must repeat exactly once as the last station of the cycle).", "inputFormat": "The first line of input contains two space-separated integers $V$ ($2\\leq V \\leq 2 \\cdot 10^5$) and $E$ ($V \\leq E \\leq 4 \\cdot 10^5$), the number of stations and direct railway lines in the rail network, respectively.\n\nThe next $E$ lines of input describe the direct railway lines. Each line contains three space-separated integers $a$, $b$, and $s$ ($1\\leq a,b \\leq V$; $-10^9 \\leq s \\leq 10^9$), signifying that a direct railway line exists between stations $a$ and $b$ with scenic value $s$. No direct railway line connects a station to itself, but **multiple direct railway lines might exist between the same two stations**. It is guaranteed that the input graph will be both **robustly connected** and **regionally connected**.", "outputFormat": "Print the sum of scenic values around the cycle in the railway network that maximizes this sum.", "hint": "For the railway network in Sample Input 2, one possible choice for the regional cycles in $\\mathcal{F}$ are  $1 \\rightarrow 2 \\rightarrow 5 \\rightarrow 1$, $2 \\rightarrow 5 \\rightarrow 3 \\rightarrow 2$, and $3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 3$ (pictured on the left). The most scenic cycle (pictured on the right, in blue) has a scenic value sum of $9+6+3-2 = 16$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/31jr1qj8.png)", "locale": "en", "translations": {"en": {"title": "[ICPC 2025 NAC] Most Scenic Cycle", "background": "", "description": "The government of the Independent Country of Problem Creators (ICPC) finally saved enough money to construct high speed rail infrastructure. The new rail system has $V$ stations and $E$ bidirectional direct railway lines that each connect two stations together. The head of ICPC Rail Infrastructure Planning, Skib E. Dee, has seen enough programming problems about tree-topology transportation networks in other countries to know that such a network would be a recipe for disaster: a single broken railway line would split the network into disconnected pieces and disrupt travel for days. Instead, Dee decided that the ICPC rail network will be **robustly connected**: every pair of stations $s_1$, $s_2$ must be connected by at least two paths which do not share any direct railway lines, and do not share any railway stations other than $s_1$ and $s_2$ themselves.\n\nOf course, ICPC cannot afford to build too many redundant railway lines. To balance efficiency and resiliency, Dee has also designed the network to be **regionally connected**. A cycle is a non-empty path from a station to itself which doesn't repeat any railway station (apart from the first station, which must repeat exactly once as the last station of the cycle). In order for the network to be regionally connected, there must exist a set $\\mathcal{F}$ of $E-V+1$ **regional cycles** satisfying three properties:\n\n- every direct railway line in the transportation network belongs to at least one regional cycle;\n- if two regional cycles share any direct railway lines, then all railway lines and stations shared by those cycles lie along a connected path;\n- for each subset $f$ of $\\mathcal{F}$, at most $|f|-1$ pairs of regional cycles in $f$ share any direct railway lines.\n\nTo promote the new high speed rail, Dee needs to create a timelapse video of a train travelling around some cycle in the railway network. Each direct railway line has a (possibly negative) scenic value representing how nice the view out the train window is along that line. Dee wants to send the train around whichever cycle maximizes the sum of scenic values of the direct railway lines on the cycle---compute this maximum possible sum. (The most scenic cycle that Dee is looking for does **not** have to be a regional cycle.) In order to ensure this cycle is not boring, it must traverse at least two direct railway lines, and must not repeat any railway station (apart from the first station, which must repeat exactly once as the last station of the cycle).", "inputFormat": "The first line of input contains two space-separated integers $V$ ($2\\leq V \\leq 2 \\cdot 10^5$) and $E$ ($V \\leq E \\leq 4 \\cdot 10^5$), the number of stations and direct railway lines in the rail network, respectively.\n\nThe next $E$ lines of input describe the direct railway lines. Each line contains three space-separated integers $a$, $b$, and $s$ ($1\\leq a,b \\leq V$; $-10^9 \\leq s \\leq 10^9$), signifying that a direct railway line exists between stations $a$ and $b$ with scenic value $s$. No direct railway line connects a station to itself, but **multiple direct railway lines might exist between the same two stations**. It is guaranteed that the input graph will be both **robustly connected** and **regionally connected**.", "outputFormat": "Print the sum of scenic values around the cycle in the railway network that maximizes this sum.", "hint": "For the railway network in Sample Input 2, one possible choice for the regional cycles in $\\mathcal{F}$ are  $1 \\rightarrow 2 \\rightarrow 5 \\rightarrow 1$, $2 \\rightarrow 5 \\rightarrow 3 \\rightarrow 2$, and $3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 3$ (pictured on the left). The most scenic cycle (pictured on the right, in blue) has a scenic value sum of $9+6+3-2 = 16$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/31jr1qj8.png)", "locale": "en"}, "zh-CN": {"title": "[ICPC 2025 NAC] Most Scenic Cycle", "background": "", "description": "独立出题者国家（ICPC）政$ $府终于攒够了建设高速铁路系统的资金。新铁路系统包含 $V$ 个车站和 $E$ 条双向直达铁路线，每条线路连接两个车站。ICPC 铁路基础设施规划负责人 Skib E. Dee 深知树形拓扑交通网络的弊端：单条铁路线损坏会导致网络分裂，造成数日交通中断。因此，Dee 决定将 ICPC 铁路网络设计为**强健连通**：任意两个车站 $s_1$ 和 $s_2$ 之间必须存在至少两条路径，这两条路径不共享任何直达铁路线，且除 $s_1$ 和 $s_2$ 外不共享任何车站。\n\n当然，ICPC 无法承担过多冗余铁路线的建设成本。为平衡效率与鲁棒性，Dee 还将网络设计为**区域连通**。一个环是指从某车站出发回到自身且不重复经过任何车站（起始车站仅在开头和结尾各出现一次）的非空路径。要实现区域连通，必须存在由 $E-V+1$ 个**区域环**组成的集合 $\\mathcal{F}$，满足以下三个性质：\n- 交通网络中每条直达铁路线至少属于一个区域环；\n- 若两个区域环共享任何直达铁路线，则它们共享的所有铁路线和车站必须构成一条连通路径；\n- 对于 $\\mathcal{F}$ 的任意子集 $f$，其中共享铁路线的区域环对数不超过 $|f|-1$。\n\n为宣传新高铁，Dee 需要制作一段火车沿铁路环线行驶的延时视频。每条直达铁路线都有一个（可能为负的）风景值，表示沿线车窗外的景色优美程度。Dee 希望选择风景值总和最大的环线作为拍摄路线（该环线**不必**是区域环）。为确保环线不单调，它必须包含至少两条铁路线，且不重复经过任何车站（起始车站仅在开头和结尾各出现一次）。", "inputFormat": "第一行输入两个整数 $V$（$2 \\leq V \\leq 2 \\cdot 10^5$）和 $E$（$V \\leq E \\leq 4 \\cdot 10^5$），分别表示车站数量和直达铁路线数量。\n\n接下来 $E$ 行描述直达铁路线，每行包含三个整数 $a$、$b$ 和 $s$（$1 \\leq a,b \\leq V$；$-10^9 \\leq s \\leq 10^9$），表示车站 $a$ 与 $b$ 之间存在一条风景值为 $s$ 的直达铁路线。没有铁路线连接同一车站，但**同一对车站间可能存在多条铁路线**。保证输入图既是**强健连通**的，也是**区域连通**的。\n", "outputFormat": "输出铁路网络中风景值总和最大的环线的风景值总和。\n", "hint": "对于样例输入 2 的铁路网络，集合 $\\mathcal{F}$ 的区域环可选为 $1 \\rightarrow 2 \\rightarrow 5 \\rightarrow 1$、$2 \\rightarrow 5 \\rightarrow 3 \\rightarrow 2$ 和 $3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 3$（左图）。风景值总和最大的环线（右图蓝色路径）的风景值总和为 $9+6+3-2=16$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/31jr1qj8.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12627", "type": "P", "difficulty": 5, "samples": [["5 10\n-1 2 3 -1 -1\n1 2\n1 3\n2 4\n2 5", "18"], ["1 5\n-1", "5"], ["2 5\n5 5\n1 2", "-1"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["贪心", "2025", "ICPC", "NAC"], "title": "[ICPC 2025 NAC] Ornaments on a Tree", "background": "", "description": "You're helping your friend decorate their Christmas tree! Funnily enough, the places to put your ornaments on their Christmas tree can be represented\nby a (graph-theoretic) tree with nodes labeled $1$ to $N$, with node $1$ being the root of the tree and other nodes numbered arbitrarily. You have an infinite supply of ornaments of every non-negative integer weight\n(including $0$), and you must place exactly one ornament on each node of the tree.\n\nHowever, your friend has some restrictions on how they want their tree decorated. First, they have strong opinions about which ornament must go on some of the tree nodes; you are only allowed to choose decorations on the other nodes. Second, each region of their tree can support only so much weight: if the sum of the weights of the ornaments on a node and all of its immediate children exceeds a constant $K$, the whole tree will come crashing down!\n\nYour friend wants to know the largest possible total weight of ornaments on their tree, given the above restrictions. Can you help them find out?", "inputFormat": "The first line of input has two space-separated integers $N$ and $K$ ($1 \\leq N \\leq 2 \\cdot 10^5, 0 \\leq K \\leq 10^9$), the number of nodes in the tree and the weight constant, respectively.\n\nThe next line contains $N$ space-separated integers. The $i^\\text{th}$ integer (starting at $i=1$) is either $-1$ or a non-negative integer. If it is $-1$, you are free to choose any ornament for node $i$. If it is a non-negative integer $w_i$ ($0 \\leq w_i \\leq 10^9$), your friend insists you place an ornament with weight $w_i$  on node $i$.\n\nThe next $N-1$ lines each contain two space-separated integers $a$ and $b$ ($1 \\leq a, b \\leq N$), indicating that nodes $a$ and $b$ are connected by an edge. The input graph is guaranteed to be a tree: there is a unique path of edges between every pair of nodes in the graph.", "outputFormat": "If it is impossible to place ornaments on the tree in a way that satisfies all of the constraints described above, print $-1$.\nOtherwise, print the maximum possible total weight of the ornaments on the tree, subject to the constraints.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2025 NAC] Ornaments on a Tree", "background": "", "description": "You're helping your friend decorate their Christmas tree! Funnily enough, the places to put your ornaments on their Christmas tree can be represented\nby a (graph-theoretic) tree with nodes labeled $1$ to $N$, with node $1$ being the root of the tree and other nodes numbered arbitrarily. You have an infinite supply of ornaments of every non-negative integer weight\n(including $0$), and you must place exactly one ornament on each node of the tree.\n\nHowever, your friend has some restrictions on how they want their tree decorated. First, they have strong opinions about which ornament must go on some of the tree nodes; you are only allowed to choose decorations on the other nodes. Second, each region of their tree can support only so much weight: if the sum of the weights of the ornaments on a node and all of its immediate children exceeds a constant $K$, the whole tree will come crashing down!\n\nYour friend wants to know the largest possible total weight of ornaments on their tree, given the above restrictions. Can you help them find out?", "inputFormat": "The first line of input has two space-separated integers $N$ and $K$ ($1 \\leq N \\leq 2 \\cdot 10^5, 0 \\leq K \\leq 10^9$), the number of nodes in the tree and the weight constant, respectively.\n\nThe next line contains $N$ space-separated integers. The $i^\\text{th}$ integer (starting at $i=1$) is either $-1$ or a non-negative integer. If it is $-1$, you are free to choose any ornament for node $i$. If it is a non-negative integer $w_i$ ($0 \\leq w_i \\leq 10^9$), your friend insists you place an ornament with weight $w_i$  on node $i$.\n\nThe next $N-1$ lines each contain two space-separated integers $a$ and $b$ ($1 \\leq a, b \\leq N$), indicating that nodes $a$ and $b$ are connected by an edge. The input graph is guaranteed to be a tree: there is a unique path of edges between every pair of nodes in the graph.", "outputFormat": "If it is impossible to place ornaments on the tree in a way that satisfies all of the constraints described above, print $-1$.\nOtherwise, print the maximum possible total weight of the ornaments on the tree, subject to the constraints.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2025 NAC] Ornaments on a Tree", "background": "", "description": "你正在帮朋友装饰圣诞树！有趣的是，圣诞树上挂装饰品的位置可以用一棵（图论中的）树来表示，树的节点编号为 $1$ 到 $N$，其中节点 $1$ 是树的根，其他节点编号任意。你有无限多个重量为非负整数（包括 $0$）的装饰品，必须在树的每个节点上恰好挂一个装饰品。\n\n不过，朋友对装饰方式有一些限制。首先，他们对某些节点必须挂什么装饰品有严格要求；你只能自由选择其他节点的装饰品。其次，圣诞树的每个区域只能承受一定重量：如果一个节点及其所有直接子节点上的装饰品重量之和超过常数 $K$，整棵树就会倒塌！\n\n在满足上述限制的条件下，朋友想知道树上装饰品的最大可能总重量。你能帮他们找到答案吗？", "inputFormat": "第一行输入两个整数 $N$ 和 $K$（$1 \\leq N \\leq 2 \\cdot 10^5$，$0 \\leq K \\leq 10^9$），分别表示树的节点数量和重量限制常数。\n\n第二行包含 $N$ 个整数。第 $i$ 个整数（从 $i=1$ 开始）为 $-1$ 或一个非负整数。如果是 $-1$，你可以自由选择节点 $i$ 的装饰品；如果是非负整数 $w_i$（$0 \\leq w_i \\leq 10^9$），则朋友要求你必须将重量为 $w_i$ 的装饰品挂在节点 $i$ 上。\n\n接下来 $N-1$ 行每行包含两个整数 $a$ 和 $b$（$1 \\leq a, b \\leq N$），表示节点 $a$ 和 $b$ 之间有一条边相连。输入保证是一棵树：图中任意两个节点之间有且仅有一条路径。\n", "outputFormat": "如果无法在满足所有限制条件的情况下装饰圣诞树，输出 $-1$。否则，输出在限制条件下树上装饰品的最大可能总重量。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12628", "type": "P", "difficulty": 6, "samples": [["4\n-0.950000 -0.850000\n-0.100000 0.999999\n0.111000 0.555000\n-0.200000 1.600000", "3\n0\n-1\n-1"], ["3\n0.500000 0.700000\n0.100000 0.200000\n0.800000 0.900000", "0"], ["4\n-360.000001 -24.000001\n-359.999999 -24.000001\n-359.999999 -23.999999\n-360.000001 -23.999999", "2\n-25\n-360"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "Special Judge", "ICPC", "NAC"], "title": "[ICPC 2025 NAC] Polygon Partition", "background": "", "description": "A simple polygon is a polygon that is not self-intersecting and does not contain any holes. You are given the $N$ vertices of a simple polygon, $v_1$, $v_2$, $\\ldots$, $v_N$, where $v_i = (x_i, y_i)$, and $x_i$ and $y_i$ are the $x$-coordinate and $y$-coordinate of the $i^{\\textrm{th}}$ vertex, respectively. The vertices are distinct and given in counterclockwise order (so there is an edge between each pair of consecutive vertices; there is also an edge from $v_N$ back to $v_1$).\n\nThe polygon's boundary does not pass through any **lattice points** (a lattice point is a point where both coordinates are integers). In addition, none of the $x_i$ or $y_i$ values are exactly an integer.\n\nA **semi-integer point** is a point where exactly one of its coordinates is an integer. Let $\\mathcal{P} = \\left\\{p_1, p_2, \\ldots, p_k\\right\\}$ be all of the semi-integer points that lie on the boundary of the polygon.\nFor each semi-integer point $p_i$ in $\\mathcal{P}$, let $n_i$ be the floor of the non-integer coordinate of $p_i$. For a subset $\\mathcal{S}$ of $\\mathcal{P}$, let $\\sigma(\\mathcal{S})$ be the sum of the $n_i$ of the points in $\\mathcal{S}$ (with $\\sigma(\\emptyset) = 0$). Does there exist a partition of $\\mathcal{P}$ into two subsets $\\mathcal{S}_1$ and $\\mathcal{S}_2$ so that the $\\sigma(\\mathcal{S}_1) = \\sigma(\\mathcal{S}_2)$?\n\n(Two sets $\\mathcal{S}_1$ and $\\mathcal{S}_2$ are a partition of $\\mathcal{P}$ if $\\mathcal{P} = \\mathcal{S}_1 \\cup \\mathcal{S}_2$ and $\\mathcal{S}_1 \\cap \\mathcal{S}_2 = \\emptyset$. There are no other restrictions on $\\mathcal{S}_1$ and $\\mathcal{S}_2$ so long as these two conditions hold and $\\sigma(\\mathcal{S}_1) = \\sigma(\\mathcal{S}_2)$. In particular, empty sets are allowed, and the semi-integer points in each set **do not** have to be contiguous around the polygon boundary.)", "inputFormat": "The first line of input contains one integer $N$ ($3 \\leq N \\leq 500$), the number of vertices of the polygon.\n\nEach of the next $N$ lines contains two space-separated real numbers $x_i$ and $y_i$ ($-500 < x_i, y_i < 500$): the coordinates of the polygon vertices, in counterclockwise order. Each coordinate will have exactly $6$ digits after the decimal point and will not be exactly an integer.\n\nIt is guaranteed that the polygon does not self-intersect, that the vertices are distinct, and that the polygon boundary does not pass through any lattice points.", "outputFormat": "If there is no solution, print $-1$ and no further output. \n\nOtherwise, print a single integer $M$ on its own line: the number of semi-integer points in one of the two subsets in a valid partition of $\\mathcal{P}$.\nOn the next $M$ lines of output, print the values $n_i$ for the points in that subset, one per line. \n\nIf there are multiple valid partitions, you may choose any of them. You may print either of its two subsets, and you may list the subset's $n_i$ values in any order.", "hint": "Sample Input 1 is shown in the image below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qx8pxc9s.png)\n\nThe points of the vertices are labeled $A,B,C,D$.\nThe semi-integer points are marked in orange and labeled $p_i$ going counterclockwise around the perimeter starting from $A$. The values $n_i$ of the semi-integer points are, in the same order, $-1, 0, 0, -1, -1, -1$.\nAny subset of those values that sum to $-2$ would be accepted as correct. Sample Output 1 shows one possible correct answer.\n\nThe boundary of the polygon in Sample Input 2 does not intersect any semi-integer points, so $\\mathcal{P}$ is empty, and it can be partitioned into two empty sets each with $n_i$ sum of zero.", "locale": "en", "translations": {"en": {"title": "[ICPC 2025 NAC] Polygon Partition", "background": "", "description": "A simple polygon is a polygon that is not self-intersecting and does not contain any holes. You are given the $N$ vertices of a simple polygon, $v_1$, $v_2$, $\\ldots$, $v_N$, where $v_i = (x_i, y_i)$, and $x_i$ and $y_i$ are the $x$-coordinate and $y$-coordinate of the $i^{\\textrm{th}}$ vertex, respectively. The vertices are distinct and given in counterclockwise order (so there is an edge between each pair of consecutive vertices; there is also an edge from $v_N$ back to $v_1$).\n\nThe polygon's boundary does not pass through any **lattice points** (a lattice point is a point where both coordinates are integers). In addition, none of the $x_i$ or $y_i$ values are exactly an integer.\n\nA **semi-integer point** is a point where exactly one of its coordinates is an integer. Let $\\mathcal{P} = \\left\\{p_1, p_2, \\ldots, p_k\\right\\}$ be all of the semi-integer points that lie on the boundary of the polygon.\nFor each semi-integer point $p_i$ in $\\mathcal{P}$, let $n_i$ be the floor of the non-integer coordinate of $p_i$. For a subset $\\mathcal{S}$ of $\\mathcal{P}$, let $\\sigma(\\mathcal{S})$ be the sum of the $n_i$ of the points in $\\mathcal{S}$ (with $\\sigma(\\emptyset) = 0$). Does there exist a partition of $\\mathcal{P}$ into two subsets $\\mathcal{S}_1$ and $\\mathcal{S}_2$ so that the $\\sigma(\\mathcal{S}_1) = \\sigma(\\mathcal{S}_2)$?\n\n(Two sets $\\mathcal{S}_1$ and $\\mathcal{S}_2$ are a partition of $\\mathcal{P}$ if $\\mathcal{P} = \\mathcal{S}_1 \\cup \\mathcal{S}_2$ and $\\mathcal{S}_1 \\cap \\mathcal{S}_2 = \\emptyset$. There are no other restrictions on $\\mathcal{S}_1$ and $\\mathcal{S}_2$ so long as these two conditions hold and $\\sigma(\\mathcal{S}_1) = \\sigma(\\mathcal{S}_2)$. In particular, empty sets are allowed, and the semi-integer points in each set **do not** have to be contiguous around the polygon boundary.)", "inputFormat": "The first line of input contains one integer $N$ ($3 \\leq N \\leq 500$), the number of vertices of the polygon.\n\nEach of the next $N$ lines contains two space-separated real numbers $x_i$ and $y_i$ ($-500 < x_i, y_i < 500$): the coordinates of the polygon vertices, in counterclockwise order. Each coordinate will have exactly $6$ digits after the decimal point and will not be exactly an integer.\n\nIt is guaranteed that the polygon does not self-intersect, that the vertices are distinct, and that the polygon boundary does not pass through any lattice points.", "outputFormat": "If there is no solution, print $-1$ and no further output. \n\nOtherwise, print a single integer $M$ on its own line: the number of semi-integer points in one of the two subsets in a valid partition of $\\mathcal{P}$.\nOn the next $M$ lines of output, print the values $n_i$ for the points in that subset, one per line. \n\nIf there are multiple valid partitions, you may choose any of them. You may print either of its two subsets, and you may list the subset's $n_i$ values in any order.", "hint": "Sample Input 1 is shown in the image below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qx8pxc9s.png)\n\nThe points of the vertices are labeled $A,B,C,D$.\nThe semi-integer points are marked in orange and labeled $p_i$ going counterclockwise around the perimeter starting from $A$. The values $n_i$ of the semi-integer points are, in the same order, $-1, 0, 0, -1, -1, -1$.\nAny subset of those values that sum to $-2$ would be accepted as correct. Sample Output 1 shows one possible correct answer.\n\nThe boundary of the polygon in Sample Input 2 does not intersect any semi-integer points, so $\\mathcal{P}$ is empty, and it can be partitioned into two empty sets each with $n_i$ sum of zero.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2025 NAC] Polygon Partition", "background": "", "description": "简单多边形是指不自交且无洞的多边形。给定一个简单多边形的 $N$ 个顶点 $v_1, v_2, \\ldots, v_N$，其中 $v_i = (x_i, y_i)$，$x_i$ 和 $y_i$ 分别是第 $i$ 个顶点的 $x$ 坐标和 $y$ 坐标。顶点互不相同且按逆时针顺序给出（因此每对相邻顶点之间有一条边；$v_N$ 和 $v_1$ 之间也有一条边）。\n\n多边形的边界不经过任何**格点**（格点是指两个坐标均为整数的点）。此外，所有 $x_i$ 和 $y_i$ 的值均不为整数。\n\n**半整数点**是指恰好有一个坐标为整数的点。设 $\\mathcal{P} = \\left\\{p_1, p_2, \\ldots, p_k\\right\\}$ 为多边形边界上的所有半整数点。对于每个半整数点 $p_i \\in \\mathcal{P}$，令 $n_i$ 为 $p_i$ 的非整数坐标的下取整值。对于 $\\mathcal{P}$ 的子集 $\\mathcal{S}$，定义 $\\sigma(\\mathcal{S})$ 为 $\\mathcal{S}$ 中所有点的 $n_i$ 之和（$\\sigma(\\emptyset) = 0$）。是否存在一种将 $\\mathcal{P}$ 划分为两个子集 $\\mathcal{S}_1$ 和 $\\mathcal{S}_2$ 的方法，使得 $\\sigma(\\mathcal{S}_1) = \\sigma(\\mathcal{S}_2)$？\n\n（两个集合 $\\mathcal{S}_1$ 和 $\\mathcal{S}_2$ 构成 $\\mathcal{P}$ 的划分，当且仅当 $\\mathcal{P} = \\mathcal{S}_1 \\cup \\mathcal{S}_2$ 且 $\\mathcal{S}_1 \\cap \\mathcal{S}_2 = \\emptyset$。只要满足这两个条件且 $\\sigma(\\mathcal{S}_1) = \\sigma(\\mathcal{S}_2)$，对 $\\mathcal{S}_1$ 和 $\\mathcal{S}_2$ 没有其他限制。特别地，允许空集，且每个子集中的半整数点**不必**在多边形边界上连续。）", "inputFormat": "第一行输入一个整数 $N$（$3 \\leq N \\leq 500$），表示多边形的顶点数。\n\n接下来的 $N$ 行，每行包含两个实数 $x_i$ 和 $y_i$（$-500 < x_i, y_i < 500$），表示多边形顶点的坐标，按逆时针顺序给出。每个坐标的小数部分恰好有 $6$ 位，且不为整数。\n\n保证多边形不自交、顶点互不相同，且多边形边界不经过任何格点。", "outputFormat": "如果无解，输出 $-1$ 并结束。\n\n否则，第一行输出一个整数 $M$，表示划分 $\\mathcal{P}$ 后其中一个子集中的半整数点数量。接下来的 $M$ 行，每行输出该子集中一个点的 $n_i$ 值。\n\n如果存在多个有效划分，可以任选其一。可以输出划分中的任意一个子集，且 $n_i$ 值可以按任意顺序列出。", "hint": "样例输入 1 对应的多边形如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qx8pxc9s.png)\n\n顶点标记为 $A,B,C,D$。半整数点用橙色标出，从 $A$ 开始逆时针依次标记为 $p_i$。这些半整数点的 $n_i$ 值依次为 $-1, 0, 0, -1, -1, -1$。任何 $n_i$ 之和为 $-2$ 的子集均为正确答案。样例输出 1 展示了一种可能的正确答案。\n\n样例输入 2 的多边形边界未经过任何半整数点，因此 $\\mathcal{P}$ 为空集，可以划分为两个空集，其 $\\sigma$ 值均为零。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12629", "type": "P", "difficulty": 6, "samples": [["RYBB", "831870297"], ["YRBBR", "598946615"]], "limits": {"time": [15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "多项式", "分治", "快速傅里叶变换 FFT", "ICPC", "NAC"], "title": "[ICPC 2025 NAC] Popping Balloons", "background": "", "description": "The ICPC logo has three colors: blue, yellow, and red. The NAC volunteers have just inflated a huge number of balloons in these\ncolors and arranged them in a line. They next need to sort the balloons by color before they can give them out to contestants. \n\nUnfortunately, due to the Orlando heat, the balloons begin to randomly pop: each second, a random remaining balloon\npops (and the volunteers remove the debris from the line). This isn't all bad: maybe if the NAC volunteers wait long enough, the balloons will become sorted by chance? Compute the expected number of seconds until the first time that all blue balloons come before all yellow and red balloons, and all yellow balloons come before all red balloons. (These conditions are satisfied even if they are vacuously true: for example, if there are no blue balloons at all remaining, then it is true that all blue balloons come before all yellow and red balloons.)", "inputFormat": "The input has one line: a string $s$ ($1\\le |s|\\le 2\\cdot 10^5$) where each character is one of $\\texttt{B}$, $\\texttt{Y}$, or $\\texttt{R}$ representing blue, yellow, and red respectively ---the colors of the initial balloons in the line.", "outputFormat": "Print the expected number of seconds that elapse before the first time that all blue balloons come before all yellow\nand red balloons, and all yellow balloons come before all red balloons. Since this number might not be an integer, print\n it modulo $998\\, 244\\, 353$.\n\nFormally, let $p = 998\\,244\\,353$. It can be shown that the answer can be expressed as an irreducible fraction $\\frac{a}{b}$, where $a$ and $b$ are non-negative integers and $b \\not \\equiv 0 \\pmod{p}$. Print the integer $x$ with $0 \\leq x < p$ and $x \\equiv a \\cdot b^{-1} \\bmod p$.", "hint": "In Sample Input 1, the expected time until the balloon colors first become sorted in the correct order is $\\frac {17}{6} = 2\\cdot \\frac{1}{6} + 3 \\cdot \\frac{5}{6}$ seconds:\nthe only way for the balloon colors to be sorted correctly after $2$ seconds is if the first two balloons to pop are the yellow and red balloon (in either order). The probability that these balloons pop before either blue balloon is $\\frac{1}{6}$. Otherwise (with probability $\\frac{5}{6}$) the balloon colors will automatically be sorted after $3$ seconds, when there is only one balloon left.\nSince $6^{-1} \\equiv 166\\,374\\,059\\pmod {p}$, the answer is $17\\cdot\n166\\,374\\,059\\equiv 831\\,870\\,297\\pmod{p}$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2025 NAC] Popping Balloons", "background": "", "description": "The ICPC logo has three colors: blue, yellow, and red. The NAC volunteers have just inflated a huge number of balloons in these\ncolors and arranged them in a line. They next need to sort the balloons by color before they can give them out to contestants. \n\nUnfortunately, due to the Orlando heat, the balloons begin to randomly pop: each second, a random remaining balloon\npops (and the volunteers remove the debris from the line). This isn't all bad: maybe if the NAC volunteers wait long enough, the balloons will become sorted by chance? Compute the expected number of seconds until the first time that all blue balloons come before all yellow and red balloons, and all yellow balloons come before all red balloons. (These conditions are satisfied even if they are vacuously true: for example, if there are no blue balloons at all remaining, then it is true that all blue balloons come before all yellow and red balloons.)", "inputFormat": "The input has one line: a string $s$ ($1\\le |s|\\le 2\\cdot 10^5$) where each character is one of $\\texttt{B}$, $\\texttt{Y}$, or $\\texttt{R}$ representing blue, yellow, and red respectively ---the colors of the initial balloons in the line.", "outputFormat": "Print the expected number of seconds that elapse before the first time that all blue balloons come before all yellow\nand red balloons, and all yellow balloons come before all red balloons. Since this number might not be an integer, print\n it modulo $998\\, 244\\, 353$.\n\nFormally, let $p = 998\\,244\\,353$. It can be shown that the answer can be expressed as an irreducible fraction $\\frac{a}{b}$, where $a$ and $b$ are non-negative integers and $b \\not \\equiv 0 \\pmod{p}$. Print the integer $x$ with $0 \\leq x < p$ and $x \\equiv a \\cdot b^{-1} \\bmod p$.", "hint": "In Sample Input 1, the expected time until the balloon colors first become sorted in the correct order is $\\frac {17}{6} = 2\\cdot \\frac{1}{6} + 3 \\cdot \\frac{5}{6}$ seconds:\nthe only way for the balloon colors to be sorted correctly after $2$ seconds is if the first two balloons to pop are the yellow and red balloon (in either order). The probability that these balloons pop before either blue balloon is $\\frac{1}{6}$. Otherwise (with probability $\\frac{5}{6}$) the balloon colors will automatically be sorted after $3$ seconds, when there is only one balloon left.\nSince $6^{-1} \\equiv 166\\,374\\,059\\pmod {p}$, the answer is $17\\cdot\n166\\,374\\,059\\equiv 831\\,870\\,297\\pmod{p}$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2025 NAC] Popping Balloons", "background": "", "description": "ICPC 的标志有三种颜色：蓝色、黄色和红色。NAC 志愿者们刚刚充好了大量这三种颜色的气球，并将它们排成一条直线。接下来他们需要按照颜色对气球进行分类，才能分发给参赛者。\n\n不幸的是，由于奥兰多的炎热天气，气球开始随机爆炸：每秒会有一个随机剩余的气球爆炸（志愿者们会从队列中清除爆炸后的残骸）。这也不全是坏事：也许如果 NAC 志愿者们等待足够长的时间，气球就会偶然排好序？请计算在第一次满足以下条件时的期望秒数：所有蓝色气球都位于所有黄色和红色气球之前，且所有黄色气球都位于所有红色气球之前。（即使这些条件是\"空洞地\"满足的也成立：例如，如果根本没有剩余蓝色气球，那么\"所有蓝色气球都在黄色和红色气球之前\"这一条件自动成立。）", "inputFormat": "输入包含一行：一个字符串 $s$（$1 \\leq |s| \\leq 2 \\cdot 10^5$），其中每个字符是 $\\texttt{B}$、$\\texttt{Y}$ 或 $\\texttt{R}$，分别代表蓝色、黄色和红色——即初始排列中气球的颜色。\n", "outputFormat": "输出在第一次满足排序条件时的期望秒数。由于这个数字可能不是整数，请输出其对 $998\\,244\\,353$ 取模的结果。\n\n形式化地说，设 $p = 998\\,244\\,353$。可以证明答案可以表示为最简分数 $\\frac{a}{b}$，其中 $a$ 和 $b$ 是非负整数且 $b \\not \\equiv 0 \\pmod{p}$。输出满足 $0 \\leq x < p$ 且 $x \\equiv a \\cdot b^{-1} \\bmod p$ 的整数 $x$。\n", "hint": "在样例输入 1 中，气球颜色首次正确排序的期望时间是 $\\frac{17}{6} = 2 \\cdot \\frac{1}{6} + 3 \\cdot \\frac{5}{6}$ 秒：\n唯一能在 2 秒后使气球正确排序的情况是前两个爆炸的气球是黄色和红色气球（顺序不限）。这两个气球在蓝色气球之前爆炸的概率是 $\\frac{1}{6}$。否则（概率为 $\\frac{5}{6}$），气球将在 3 秒后（只剩一个气球时）自动排序。\n由于 $6^{-1} \\equiv 166\\,374\\,059 \\pmod{p}$，所以答案是 $17 \\cdot 166\\,374\\,059 \\equiv 831\\,870\\,297 \\pmod{p}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12630", "type": "P", "difficulty": 4, "samples": [["4\n0\n2\n2\n1", "4"], ["3\n4\n0\n4", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "ICPC", "NAC"], "title": "[ICPC 2025 NAC] SLA Tomography", "background": "", "description": "Stereolithography (SLA) is a 3D printing technique for hardening liquid material into a solid object one layer at a time using a laser. In this problem, we will consider a 2D simplification of SLA where the design of the object being printed can be represented as a rectangular grid of $\\texttt{\\#}$ and $\\texttt{.}$ characters, where $\\texttt{\\#}$ represents a grid cell occupied by the object and $\\texttt{.}$ is empty space. For example, here is a $4\\times 8$ design:\n\n```\n..#.....\n..#..#..\n#.#.##..\n#.#####.\n```\n\nA design does not have to consist of a single connected piece, but except for $\\texttt{\\#}$ cells on the bottom row of the design, **each $\\texttt{\\#}$ cell must be supported by another $\\texttt{\\#}$ cell directly below it**.\n\nPrinting an object using SLA proceeds layer-by-layer, starting from the bottom row. First, all cells in the row are flooded with a liquid photosensitive resin. Then a laser sweeps over the row, hardening the resin in all $\\texttt{\\#}$ cells into a solid and skipping all $\\texttt{.}$ cells. Then, leftover liquid to the left of the leftmost $\\texttt{\\#}$ and to the right of the rightmost $\\texttt{\\#}$ drains away. Other liquid remains trapped. (If there are no $\\texttt{\\#}$ cells in the row---which can only happen for rows near the top of the design, after the object has been fully printed---all liquid drains away from the row.) This process then repeats for each subsequent row. For the design above, after printing is complete, resin remains trapped in all of the cells marked with a $\\sim$ character below:\n\n```\n..#.....\n..#~~#..\n#~#~##..\n#~#####.\n```\n\nWhile manually suctioning the leftover resin from the object, you start to wonder: how much of the original design can be recovered from knowing only how much liquid resin is left over in each row of the design after printing? For the above design, the amount of leftover resin in each row (starting from the top of the design) is $0$, $2$, $2$, $1$. Other designs also have the same leftover-resin fingerprint; for example:\n\n```\n....\n#..#\n#..#\n#.##\n```\n\nGiven a list of how many cells of liquid resin are left over in each row (starting from the top row), print the width of the narrowest object design whose rows would contain those amounts of liquid resin after printing. If no such design exists, print $\\texttt{impossible}$.", "inputFormat": "The first line of input contains a single integer $N (1 \\leq N \\leq 10^5)$, the number of rows in the object design.\n$N$ lines follow, each containing a single integer $x$ ($0 \\leq x \\leq 10^9$), the number of cells of leftover liquid resin in each row of the desired object design (in order from top to bottom).\n\nAt least one row will have at least one leftover cell of liquid resin.", "outputFormat": "Print the width (number of columns) in the narrowest object design whose number of leftover liquid resin cells in each row matches the input. (\"Narrowest\" means having the smallest possible number of columns). If no such design exists, print $\\texttt{impossible}$ instead.", "hint": "Sample Input 1 corresponds to the example above. One narrowest-possible design for Sample Input 2 is:\n\n```\n#....#.....\n######.....\n######....#\n```", "locale": "en", "translations": {"en": {"title": "[ICPC 2025 NAC] SLA Tomography", "background": "", "description": "Stereolithography (SLA) is a 3D printing technique for hardening liquid material into a solid object one layer at a time using a laser. In this problem, we will consider a 2D simplification of SLA where the design of the object being printed can be represented as a rectangular grid of $\\texttt{\\#}$ and $\\texttt{.}$ characters, where $\\texttt{\\#}$ represents a grid cell occupied by the object and $\\texttt{.}$ is empty space. For example, here is a $4\\times 8$ design:\n\n```\n..#.....\n..#..#..\n#.#.##..\n#.#####.\n```\n\nA design does not have to consist of a single connected piece, but except for $\\texttt{\\#}$ cells on the bottom row of the design, **each $\\texttt{\\#}$ cell must be supported by another $\\texttt{\\#}$ cell directly below it**.\n\nPrinting an object using SLA proceeds layer-by-layer, starting from the bottom row. First, all cells in the row are flooded with a liquid photosensitive resin. Then a laser sweeps over the row, hardening the resin in all $\\texttt{\\#}$ cells into a solid and skipping all $\\texttt{.}$ cells. Then, leftover liquid to the left of the leftmost $\\texttt{\\#}$ and to the right of the rightmost $\\texttt{\\#}$ drains away. Other liquid remains trapped. (If there are no $\\texttt{\\#}$ cells in the row---which can only happen for rows near the top of the design, after the object has been fully printed---all liquid drains away from the row.) This process then repeats for each subsequent row. For the design above, after printing is complete, resin remains trapped in all of the cells marked with a $\\sim$ character below:\n\n```\n..#.....\n..#~~#..\n#~#~##..\n#~#####.\n```\n\nWhile manually suctioning the leftover resin from the object, you start to wonder: how much of the original design can be recovered from knowing only how much liquid resin is left over in each row of the design after printing? For the above design, the amount of leftover resin in each row (starting from the top of the design) is $0$, $2$, $2$, $1$. Other designs also have the same leftover-resin fingerprint; for example:\n\n```\n....\n#..#\n#..#\n#.##\n```\n\nGiven a list of how many cells of liquid resin are left over in each row (starting from the top row), print the width of the narrowest object design whose rows would contain those amounts of liquid resin after printing. If no such design exists, print $\\texttt{impossible}$.", "inputFormat": "The first line of input contains a single integer $N (1 \\leq N \\leq 10^5)$, the number of rows in the object design.\n$N$ lines follow, each containing a single integer $x$ ($0 \\leq x \\leq 10^9$), the number of cells of leftover liquid resin in each row of the desired object design (in order from top to bottom).\n\nAt least one row will have at least one leftover cell of liquid resin.", "outputFormat": "Print the width (number of columns) in the narrowest object design whose number of leftover liquid resin cells in each row matches the input. (\"Narrowest\" means having the smallest possible number of columns). If no such design exists, print $\\texttt{impossible}$ instead.", "hint": "Sample Input 1 corresponds to the example above. One narrowest-possible design for Sample Input 2 is:\n\n```\n#....#.....\n######.....\n######....#\n```", "locale": "en"}, "zh-CN": {"title": "[ICPC 2025 NAC] SLA Tomography", "background": "", "description": "立体光刻（SLA）是一种 3D 打印技术，通过激光逐层将液态材料固化成固体物体。在本问题中，我们将考虑 SLA 的二维简化版本，其中打印对象的设计可以表示为一个由 $\\texttt{\\#}$ 和 $\\texttt{.}$ 字符组成的矩形网格，$\\texttt{\\#}$ 表示被对象占据的网格单元，$\\texttt{.}$ 表示空白区域。例如，以下是一个 $4 \\times 8$ 的设计：\n\n```\n..#.....\n..#..#..\n#.#.##..\n#.#####.\n```\n\n设计不必由单个连通块组成，但除了设计最底行的 $\\texttt{\\#}$ 单元外，**每个 $\\texttt{\\#}$ 单元必须由正下方的另一个 $\\texttt{\\#}$ 单元支撑**。\n\n使用 SLA 打印对象的过程是逐层进行的，从最底行开始。首先，该行的所有单元都被液态光敏树脂覆盖。然后激光扫描该行，将所有 $\\texttt{\\#}$ 单元的树脂固化成固体，跳过所有 $\\texttt{.}$ 单元。接着，最左侧 $\\texttt{\\#}$ 左侧和最右侧 $\\texttt{\\#}$ 右侧的多余液态树脂会流走，其他液态树脂则会被困住。（如果某行没有 $\\texttt{\\#}$ 单元——这种情况只可能发生在设计顶部附近，当对象已完全打印时——该行的所有液态树脂都会流走。）然后对每一后续行重复此过程。对于上面的设计，打印完成后，所有标有 $\\sim$ 字符的单元中会残留树脂：\n\n```\n..#.....\n..#~~#..\n#~#~##..\n#~#####.\n```\n\n在手动吸除对象上残留的树脂时，你开始思考：仅通过知道打印后设计每一行残留的液态树脂量，能还原出原始设计的多少信息？对于上述设计，每一行（从设计顶部开始）的残留树脂量分别为 $0$、$2$、$2$、$1$。其他设计也可能具有相同的残留树脂特征；例如：\n\n```\n....\n#..#\n#..#\n#.##\n```\n\n给定每一行（从顶行开始）残留液态树脂单元的数量列表，输出满足这些残留量的最窄对象设计的宽度。如果不存在这样的设计，输出 $\\texttt{impossible}$。", "inputFormat": "第一行输入包含一个整数 $N$（$1 \\leq N \\leq 10^5$），表示对象设计的行数。  \n接下来 $N$ 行，每行包含一个整数 $x$（$0 \\leq x \\leq 10^9$），表示期望对象设计每一行（从顶行到底行）的残留液态树脂单元数量。  \n\n至少有一行的残留液态树脂单元数量大于零。", "outputFormat": "输出满足输入残留量的最窄对象设计的宽度（列数）。（\"最窄\"指列数尽可能少。）如果不存在这样的设计，输出 $\\texttt{impossible}$。\n", "hint": "样例输入 1 对应上述示例。样例输入 2 的一个最窄可能设计为：\n\n```\n#....#.....\n######.....\n######....#\n```\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
