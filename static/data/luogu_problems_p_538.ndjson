{"pid": "P11922", "type": "P", "difficulty": 5, "samples": [["4 1\n1 1\n3 2\n4 3\n4 1", "6"], ["4 5\n1 1\n3 2\n4 3\n4 1", "5"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000, 8000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2025", "PA（波兰）"], "title": "[PA 2025] 叠积木 / Wieża", "background": "PA 2025 R4C.", "description": "有 $n$ 块正方体积木，编号 $1\\sim n$。第 $i$ 块积木的边长为 $a_i$，图案种类为 $w_i$。\n\n我们称一座**塔**是一个序列 $p_1,p_2,\\ldots,p_m$，其中 $1\\le p_i\\le n$，且 $p_i$ 两两不同。\n\n一座塔是**稳的**，当且仅当：\n\n- $\\forall 1\\le i\\lt m$，$a_{p_i}\\gt a_{p_{i+1}}$。\n\n给定正整数 $c$。定义一座塔的**美观度**为：\n\n$$\\sum_{1\\le i\\le m} a_{p_i}-c\\cdot \\sum_{1\\le i\\lt m} [w_{p_i}\\neq w_{p_{i+1}}]$$\n\n换句话说，是组成塔的积木高度减去（相邻的不同图案的积木对数乘以 $c$）。\n\n求出**稳的**塔的最大美观度。", "inputFormat": "第一行，正整数 $n,c$。\n\n接下来 $n$ 行，第 $i$ 行两个正整数 $a_i,w_i$。\n\n保证 $\\forall 1\\le i\\lt n$，有 $a_i\\le a_{i+1}$。", "outputFormat": "输出一行一个整数，表示稳的塔的最大美观度。", "hint": "### 样例解释\n\n**两个样例中**，四块积木的形状和图案如下所示。两个样例唯一的区别只有 $c$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fgnbuet8.png?x-oss-process=image/resize,m_lfit,h_150)\n\n\n样例 $1$ 中，下图的两个稳的塔的美观度是最大的，为 $4+3+1-(1+1)\\times 1=6$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ys9t7rao.png?x-oss-process=image/resize,m_lfit,h_150)\n\n\n但是在样例 $2$ 中，上图的塔的美观度为 $-2$。样例 $2$ 中美观度最大的稳的塔如下所示，它的美观度为 $4+1-5\\times 0=5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l1ou8e1y.png?x-oss-process=image/resize,m_lfit,h_100)\n\n### 子任务\n\n在价值 $50$ 分的子任务中，满足 $\\forall 1\\le i\\lt n$，$a_i\\lt a_{i+1}$。\n\n### 数据范围\n\n- $1\\le n,c,a_i,w_i\\le 5\\times 10^5$；\n- $\\forall 1\\le i\\lt n$，$a_i\\le a_{i+1}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2025] 叠积木 / Wieża", "background": "PA 2025 R4C.", "description": "有 $n$ 块正方体积木，编号 $1\\sim n$。第 $i$ 块积木的边长为 $a_i$，图案种类为 $w_i$。\n\n我们称一座**塔**是一个序列 $p_1,p_2,\\ldots,p_m$，其中 $1\\le p_i\\le n$，且 $p_i$ 两两不同。\n\n一座塔是**稳的**，当且仅当：\n\n- $\\forall 1\\le i\\lt m$，$a_{p_i}\\gt a_{p_{i+1}}$。\n\n给定正整数 $c$。定义一座塔的**美观度**为：\n\n$$\\sum_{1\\le i\\le m} a_{p_i}-c\\cdot \\sum_{1\\le i\\lt m} [w_{p_i}\\neq w_{p_{i+1}}]$$\n\n换句话说，是组成塔的积木高度减去（相邻的不同图案的积木对数乘以 $c$）。\n\n求出**稳的**塔的最大美观度。", "inputFormat": "第一行，正整数 $n,c$。\n\n接下来 $n$ 行，第 $i$ 行两个正整数 $a_i,w_i$。\n\n保证 $\\forall 1\\le i\\lt n$，有 $a_i\\le a_{i+1}$。", "outputFormat": "输出一行一个整数，表示稳的塔的最大美观度。", "hint": "### 样例解释\n\n**两个样例中**，四块积木的形状和图案如下所示。两个样例唯一的区别只有 $c$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fgnbuet8.png?x-oss-process=image/resize,m_lfit,h_150)\n\n\n样例 $1$ 中，下图的两个稳的塔的美观度是最大的，为 $4+3+1-(1+1)\\times 1=6$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ys9t7rao.png?x-oss-process=image/resize,m_lfit,h_150)\n\n\n但是在样例 $2$ 中，上图的塔的美观度为 $-2$。样例 $2$ 中美观度最大的稳的塔如下所示，它的美观度为 $4+1-5\\times 0=5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l1ou8e1y.png?x-oss-process=image/resize,m_lfit,h_100)\n\n### 子任务\n\n在价值 $50$ 分的子任务中，满足 $\\forall 1\\le i\\lt n$，$a_i\\lt a_{i+1}$。\n\n### 数据范围\n\n- $1\\le n,c,a_i,w_i\\le 5\\times 10^5$；\n- $\\forall 1\\le i\\lt n$，$a_i\\le a_{i+1}$。", "locale": "zh-CN"}}}
{"pid": "P11923", "type": "P", "difficulty": 7, "samples": [["5 7 22 3\n1 1\n1 2\n1 3\n2 3\n3 3\n3 2\n2 1\n3 1\n4 1\n5 1\n1 5\n1 6\n1 7\n2 5\n2 7\n3 5\n3 6\n3 7\n4 5\n5 5\n4 7\n5 7\n2 2\n2 6\n5 1", "22\n14\n6\n5"]], "limits": {"time": [15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "PA（波兰）"], "title": "[PA 2025] 砖块收集 / Zbieranie klocków", "background": "\nPA 2025 R4B.\n\n**警告：滥用本题评测一次即可封号。**", "description": "\n有一个 $ n \\times m $ 的矩形棋盘被划分为 $ n \\times m $ 个正方形格子。有若干块立方体积木在棋盘上。积木的尺寸与格子相同，每块积木恰好占据一个格子。我们记第 $i$ 行第 $j$ 列的格子为 $(i,j)$。\n\n现在小女孩 Algosia 要收积木。一块积木可以被收走，当且仅当：\n\n- 这块积木的上面和下面没有相邻的积木；\n- **或者**这块积木的左边和右边没有相邻的积木。\n\n初始时棋盘上有 $k$ 块积木。$q$ 次操作，每次操作新增一个积木，或者移除一个积木（**这里的移除不受上述条件的限制**）。\n\n对于 $i=1,2,\\ldots,q+1$，Algosia 想要知道：在进行前 $(i-1)$ 次操作后，她最多可以**逐个**收走多少个积木。\n\n注意，积木不会真的被收走。\n", "inputFormat": "第一行，四个正整数 $n,m,k,q$。\n\n接下来 $k$ 行，每行两个正整数 $x_i,y_i$，表示初始时第 $i$ 块积木所在的格子是 $(i,j)$。保证这 $k$ 个格子两两不同。\n\n接下来 $q$ 行，每行两个正整数 $x,y$，描述一次操作：\n\n- 若 $(x,y)$ 上没有积木，在 $(x,y)$ 上放一个积木；\n- 否则移除 $(x,y)$ 上的积木。\n\n", "outputFormat": "\n输出 $(q+1)$ 行，每行一个非负整数：\n\n- 第 $i$ 行的数表示，在进行前 $(i-1)$ 次操作后，Algosia 最多可以**逐个**收走多少个积木。\n", "hint": "\n### 样例解释\n\n初始时的棋盘如下左图所示。棋盘上有 $22$ 块积木。\n\n将一开始可以被收走的积木收走后，棋盘变成了下右图的样子。于是所有积木都可以被收走。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o2zqsgkw.png?x-oss-process=image/resize,m_lfit,h_150)\n![](https://cdn.luogu.com.cn/upload/image_hosting/b39avzr2.png?x-oss-process=image/resize,m_lfit,h_150)\n\n第 $1$ 次操作中，放上了一块新的积木（以红色标识）。这 $3\\times 3$ 块积木就没办法收走了，最后只能收走 $14$ 块积木。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vuzf3mky.png?x-oss-process=image/resize,m_lfit,h_150)\n\n继续进行第二次操作后，棋盘变成了下图的形状。此时只能收走 $6$ 块积木。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yfj4oie4.png?x-oss-process=image/resize,m_lfit,h_150)\n\n继续进行第三次操作后，棋盘变成了下图的形状。答案为 $5$。\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fvbomqzj.png?x-oss-process=image/resize,m_lfit,h_150)\n\n### 子任务\n\n解决 $q=1$ 的子任务可以获得大于 $0$ 分的部分分。\n\n### 数据范围\n- $ 1 \\leq n, m \\leq 2\\times 10^5$；\n- $1 \\leq k, q \\leq 75\\, 000 $；\n- $1\\le x_i,x\\le n$，$1\\le y_i,y\\le m$；\n- $\\forall 1\\le i\\lt j\\le k$，$(x_i,y_i)\\neq (x_j,y_j)$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2025] 砖块收集 / Zbieranie klocków", "background": "\nPA 2025 R4B.\n\n**警告：滥用本题评测一次即可封号。**", "description": "\n有一个 $ n \\times m $ 的矩形棋盘被划分为 $ n \\times m $ 个正方形格子。有若干块立方体积木在棋盘上。积木的尺寸与格子相同，每块积木恰好占据一个格子。我们记第 $i$ 行第 $j$ 列的格子为 $(i,j)$。\n\n现在小女孩 Algosia 要收积木。一块积木可以被收走，当且仅当：\n\n- 这块积木的上面和下面没有相邻的积木；\n- **或者**这块积木的左边和右边没有相邻的积木。\n\n初始时棋盘上有 $k$ 块积木。$q$ 次操作，每次操作新增一个积木，或者移除一个积木（**这里的移除不受上述条件的限制**）。\n\n对于 $i=1,2,\\ldots,q+1$，Algosia 想要知道：在进行前 $(i-1)$ 次操作后，她最多可以**逐个**收走多少个积木。\n\n注意，积木不会真的被收走。\n", "inputFormat": "第一行，四个正整数 $n,m,k,q$。\n\n接下来 $k$ 行，每行两个正整数 $x_i,y_i$，表示初始时第 $i$ 块积木所在的格子是 $(i,j)$。保证这 $k$ 个格子两两不同。\n\n接下来 $q$ 行，每行两个正整数 $x,y$，描述一次操作：\n\n- 若 $(x,y)$ 上没有积木，在 $(x,y)$ 上放一个积木；\n- 否则移除 $(x,y)$ 上的积木。\n\n", "outputFormat": "\n输出 $(q+1)$ 行，每行一个非负整数：\n\n- 第 $i$ 行的数表示，在进行前 $(i-1)$ 次操作后，Algosia 最多可以**逐个**收走多少个积木。\n", "hint": "\n### 样例解释\n\n初始时的棋盘如下左图所示。棋盘上有 $22$ 块积木。\n\n将一开始可以被收走的积木收走后，棋盘变成了下右图的样子。于是所有积木都可以被收走。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o2zqsgkw.png?x-oss-process=image/resize,m_lfit,h_150)\n![](https://cdn.luogu.com.cn/upload/image_hosting/b39avzr2.png?x-oss-process=image/resize,m_lfit,h_150)\n\n第 $1$ 次操作中，放上了一块新的积木（以红色标识）。这 $3\\times 3$ 块积木就没办法收走了，最后只能收走 $14$ 块积木。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vuzf3mky.png?x-oss-process=image/resize,m_lfit,h_150)\n\n继续进行第二次操作后，棋盘变成了下图的形状。此时只能收走 $6$ 块积木。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yfj4oie4.png?x-oss-process=image/resize,m_lfit,h_150)\n\n继续进行第三次操作后，棋盘变成了下图的形状。答案为 $5$。\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fvbomqzj.png?x-oss-process=image/resize,m_lfit,h_150)\n\n### 子任务\n\n解决 $q=1$ 的子任务可以获得大于 $0$ 分的部分分。\n\n### 数据范围\n- $ 1 \\leq n, m \\leq 2\\times 10^5$；\n- $1 \\leq k, q \\leq 75\\, 000 $；\n- $1\\le x_i,x\\le n$，$1\\le y_i,y\\le m$；\n- $\\forall 1\\le i\\lt j\\le k$，$(x_i,y_i)\\neq (x_j,y_j)$。\n", "locale": "zh-CN"}}}
{"pid": "P11924", "type": "P", "difficulty": 7, "samples": [["3 100\n28 1 56", "44 0 56"], ["5 1\n1 1 1 1 1", "-1 0 0 1 0"], ["6 6\n3 5 1 4 2 6", "2 0 0 0 4 0"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "PA（波兰）"], "title": "[PA 2025] 贪婪大盗 / Piracka Chciwość", "background": "\nPA 2025 R4A.\n\n$\\textcolor{red}{\\textbf{1G / 6s.}}$", "description": "有 $n$ 名海盗，编号 $1\\sim n$。海盗编号越小，他的地位越高。\n\n每位海盗 $i$ 都有一个贪婪系数 $a_i$，为正整数。\n\n他们获得了 $m$ 枚金币，现在要分金币。\n\n分金币的方式如下：\n\n- **船上**编号最小的海盗提出一个分赃方案，即为每个**船上**的海盗 $i$ 分配 $b_i$ 枚金币。这里，$\\sum b_i=m$。\n- 然后，所有**船上**的海盗（包括提出方案的海盗）对该分赃方案投票，选择支持或反对。  \n\t- 如果**至少 $50\\%$** 的海盗支持方案，则金币按照提议的方式分配。\n\t- 否则，提出方案的海盗被**扔下船**（他不再参与接下来的讨论，也无法获得任何金币）。随后，由仍在船上的编号最小的海盗重复上述过程，直到确定一种分配方式为止。\n    \n    \n每个海盗 $ i $ 选择支持该分赃方案，当且仅当，如果拒绝方案：\n\n- 他最终会被扔下船（他提出自己的方案后会被否决）；\n- 或者他在该方案中的收益 $ b_i $ 满足 $b_i \\geq d_i + a_i$，其中 \n  \n  - $ d_i $ 是当前方案被否决后，该海盗最终获得的金币数；\n  - $ a_i $ 是贪婪系数。\n\n**所有海盗都知道所有其他海盗的贪婪系数**，每个人的策略都是固定的：\n\n1. 如果提出方案的海盗无论如何都会被扔下船（不存在一个方案可接受）：\n\t- 该海盗提议自己独占所有金币，接受自己的命运，被扔下船。\n2. 否则，存在至少一个可接受的方案。\n\t- 该海盗会选择提出其中一个方案（$0$ 金币也比被扔下船好）。\n\t- 在所有可接受的方案中，海盗会选择自己分得最多金币的方案；\n\t- 如果仍然有多个可接受方案，海盗更倾向于让编号较大的海盗获得更多金币。  \n    \n   \t\t具体地说，编号为 $ i $ 的海盗，在所有可接受方案中，最小化编号 $ i+1 $ 的海盗所获金币数。\n   \t\t- 如果仍然有多个方案，则最小化编号 $ i+2 $ 的海盗所得金币数，依此类推。\n   \n求出最终每个海盗能够分得多少金币。", "inputFormat": "\n第一行，两个正整数 $n,m$。\n\n第二行，$n$ 个正整数 $a_1,a_2,\\ldots,a_n$。\n\n", "outputFormat": "输出一行 $n$ 个整数 $b_1,b_2,\\ldots,b_n$。\n\n- 若第 $i$ 个海盗被扔下船，$b_i=-1$；\n- 否则 $b_i$ 为最终第 $i$ 个海盗分得的金币数。\n", "hint": "\n### 样例解释\n\n- 样例解释 $1$：\n \n 如果海盗 $1$ 被扔下船，那么海盗 $2$ 会独占所有金币（虽然海盗 $3$ 会投反对票，但是无济于事）。\n    \n因此，海盗 $1$ 无法说服海盗 $2$ 支持他的方案，除非他给海盗 $2$ 至少 $100 + 1 = 101$ 枚金币（这超出了总金币数）。 \n        \n从而，海盗 $1$ 选择转而说服海盗 $3$，即给他足够多的金币，使他愿意支持该方案。海盗 $1$ 需要至少给海盗 $3$ $56$ 枚金币。\n\n所以最终方案为：$b_1=44$，$b_2=0$，$b_3=56$。\n\n在该方案下，海盗 $1,3$ 投下反对票，海盗 $2$ 无力回天。\n\n- 样例解释 $2$：\n\n对于海盗 $1$，金币无论如何都不够分，所以他被扔下船。\n\n海盗 $2$ 有两个选择：\n\n1. 将 $1$ 枚金币给海盗 $3$；\n2. 将 $1$ 枚金币给海盗 $4$。\n\n按照规则，他选择方案 $2$。\n\n- 样例解释 $3$：海盗 $1,2,5$ 支持海盗 $1$ 的方案，所以方案成功通过。\n\n### 数据范围\n\n- $1 \\leq n \\leq 5\\times 10^4$；\n- $1 \\leq m \\leq 5\\times 10^6$；\n- $1\\le a_i\\le 64$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2025] 贪婪大盗 / Piracka Chciwość", "background": "\nPA 2025 R4A.\n\n$\\textcolor{red}{\\textbf{1G / 6s.}}$", "description": "有 $n$ 名海盗，编号 $1\\sim n$。海盗编号越小，他的地位越高。\n\n每位海盗 $i$ 都有一个贪婪系数 $a_i$，为正整数。\n\n他们获得了 $m$ 枚金币，现在要分金币。\n\n分金币的方式如下：\n\n- **船上**编号最小的海盗提出一个分赃方案，即为每个**船上**的海盗 $i$ 分配 $b_i$ 枚金币。这里，$\\sum b_i=m$。\n- 然后，所有**船上**的海盗（包括提出方案的海盗）对该分赃方案投票，选择支持或反对。  \n\t- 如果**至少 $50\\%$** 的海盗支持方案，则金币按照提议的方式分配。\n\t- 否则，提出方案的海盗被**扔下船**（他不再参与接下来的讨论，也无法获得任何金币）。随后，由仍在船上的编号最小的海盗重复上述过程，直到确定一种分配方式为止。\n    \n    \n每个海盗 $ i $ 选择支持该分赃方案，当且仅当，如果拒绝方案：\n\n- 他最终会被扔下船（他提出自己的方案后会被否决）；\n- 或者他在该方案中的收益 $ b_i $ 满足 $b_i \\geq d_i + a_i$，其中 \n  \n  - $ d_i $ 是当前方案被否决后，该海盗最终获得的金币数；\n  - $ a_i $ 是贪婪系数。\n\n**所有海盗都知道所有其他海盗的贪婪系数**，每个人的策略都是固定的：\n\n1. 如果提出方案的海盗无论如何都会被扔下船（不存在一个方案可接受）：\n\t- 该海盗提议自己独占所有金币，接受自己的命运，被扔下船。\n2. 否则，存在至少一个可接受的方案。\n\t- 该海盗会选择提出其中一个方案（$0$ 金币也比被扔下船好）。\n\t- 在所有可接受的方案中，海盗会选择自己分得最多金币的方案；\n\t- 如果仍然有多个可接受方案，海盗更倾向于让编号较大的海盗获得更多金币。  \n    \n   \t\t具体地说，编号为 $ i $ 的海盗，在所有可接受方案中，最小化编号 $ i+1 $ 的海盗所获金币数。\n   \t\t- 如果仍然有多个方案，则最小化编号 $ i+2 $ 的海盗所得金币数，依此类推。\n   \n求出最终每个海盗能够分得多少金币。", "inputFormat": "\n第一行，两个正整数 $n,m$。\n\n第二行，$n$ 个正整数 $a_1,a_2,\\ldots,a_n$。\n\n", "outputFormat": "输出一行 $n$ 个整数 $b_1,b_2,\\ldots,b_n$。\n\n- 若第 $i$ 个海盗被扔下船，$b_i=-1$；\n- 否则 $b_i$ 为最终第 $i$ 个海盗分得的金币数。\n", "hint": "\n### 样例解释\n\n- 样例解释 $1$：\n \n 如果海盗 $1$ 被扔下船，那么海盗 $2$ 会独占所有金币（虽然海盗 $3$ 会投反对票，但是无济于事）。\n    \n因此，海盗 $1$ 无法说服海盗 $2$ 支持他的方案，除非他给海盗 $2$ 至少 $100 + 1 = 101$ 枚金币（这超出了总金币数）。 \n        \n从而，海盗 $1$ 选择转而说服海盗 $3$，即给他足够多的金币，使他愿意支持该方案。海盗 $1$ 需要至少给海盗 $3$ $56$ 枚金币。\n\n所以最终方案为：$b_1=44$，$b_2=0$，$b_3=56$。\n\n在该方案下，海盗 $1,3$ 投下反对票，海盗 $2$ 无力回天。\n\n- 样例解释 $2$：\n\n对于海盗 $1$，金币无论如何都不够分，所以他被扔下船。\n\n海盗 $2$ 有两个选择：\n\n1. 将 $1$ 枚金币给海盗 $3$；\n2. 将 $1$ 枚金币给海盗 $4$。\n\n按照规则，他选择方案 $2$。\n\n- 样例解释 $3$：海盗 $1,2,5$ 支持海盗 $1$ 的方案，所以方案成功通过。\n\n### 数据范围\n\n- $1 \\leq n \\leq 5\\times 10^4$；\n- $1 \\leq m \\leq 5\\times 10^6$；\n- $1\\le a_i\\le 64$。\n", "locale": "zh-CN"}}}
{"pid": "P11925", "type": "P", "difficulty": 4, "samples": [], "limits": {"time": [4000], "memory": [1048576]}, "tags": ["2025", "提交答案", "Special Judge", "PA（波兰）"], "title": "[PA 2025] 显像管 / Migawka", "background": "PA 2025 R5C.\n\n可以用 PHP 语言提交答案，也可以提交答案生成器。", "description": "**这是一道提交答案题。**\n\n有一台老旧的黑白电视机，屏幕尺寸为 $100 \\times 100$ 像素。每个像素可以是亮着的，也可以是熄灭的。然而，这台电视机有缺陷的，显示的图像一般不会保持太久。\n\n称一个 $2 \\times 2$ 的像素块是**错误的**，当且仅当其**只有**（主/副）对角线上的像素是亮的。电视机每秒将**在至少一个**错误块中的像素状态反转（亮变为灭，灭变为亮）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1usrl3xs.png?x-oss-process=image/resize,m_lfit,h_200)\n\n例如，考虑一个 $4 \\times 4$ 的电视机屏幕，初始时各像素状态为下图左 $1$ 所示。下图展示了电视机在未来几秒钟的屏幕状态变化。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wcgmxgup.png?x-oss-process=image/resize,m_lfit,h_200)\n\n从图中可以看出，第 $3$ 秒的屏幕画面与第 $1$ 秒相同，所以有 $3$ 种不同的画面。\n\n构造初始的像素状态，最大化它能生成的不同画面的数量。（在刚才的例子中，生成了 $3$ 种不同画面）。\n", "inputFormat": "没有输入。", "outputFormat": "输出 $100$ 行，第 $i$ 行一个长度为 $100$ 的 $\\texttt{01}$ 串 $s_{i,j}$，表示电视机的初始画面（$\\texttt{1}$ 代表像素点亮，$\\texttt{0}$ 代表像素熄灭）。", "hint": "\n### 计分方式\n\n设初始画面生成了 $x$ 种不同的画面。\n\n令 $i$ 为最大的的非负整数，满足 $(10\\cdot i-1)^2\\le x$，则得分为 $\\min(100,10\\cdot i)$。\n\n### 提示\n\n\n**光敏性癫痫警告：开发者已尽力确保可视化对癫痫患者是安全的，但请小心使用。**\n\n我们在附件中提供了可视化工具 $\\boldsymbol{visualise.py}$。\n\n这是一个 Python 脚本，依赖于 `matplotlib` 和 `numpy` 库（请自行搜索如何安装，可能需要更换镜像源）。\n\n使用以下命令启动可视化工具：\n\n- Linux / MacOS：\n\n\t```bash\n\tpython3 visualise.py < mig.txt\n\t```\n- Windows cmd：\n\t```bash\n\tpy visualise.py < mig.txt\n    ```\n\n压缩包还包含了一个示例文件 $\\boldsymbol{mig.txt}$。\n\n你可以根据需要自行修改可视化工具。  \n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2025] 显像管 / Migawka", "background": "PA 2025 R5C.\n\n可以用 PHP 语言提交答案，也可以提交答案生成器。", "description": "**这是一道提交答案题。**\n\n有一台老旧的黑白电视机，屏幕尺寸为 $100 \\times 100$ 像素。每个像素可以是亮着的，也可以是熄灭的。然而，这台电视机有缺陷的，显示的图像一般不会保持太久。\n\n称一个 $2 \\times 2$ 的像素块是**错误的**，当且仅当其**只有**（主/副）对角线上的像素是亮的。电视机每秒将**在至少一个**错误块中的像素状态反转（亮变为灭，灭变为亮）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1usrl3xs.png?x-oss-process=image/resize,m_lfit,h_200)\n\n例如，考虑一个 $4 \\times 4$ 的电视机屏幕，初始时各像素状态为下图左 $1$ 所示。下图展示了电视机在未来几秒钟的屏幕状态变化。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wcgmxgup.png?x-oss-process=image/resize,m_lfit,h_200)\n\n从图中可以看出，第 $3$ 秒的屏幕画面与第 $1$ 秒相同，所以有 $3$ 种不同的画面。\n\n构造初始的像素状态，最大化它能生成的不同画面的数量。（在刚才的例子中，生成了 $3$ 种不同画面）。\n", "inputFormat": "没有输入。", "outputFormat": "输出 $100$ 行，第 $i$ 行一个长度为 $100$ 的 $\\texttt{01}$ 串 $s_{i,j}$，表示电视机的初始画面（$\\texttt{1}$ 代表像素点亮，$\\texttt{0}$ 代表像素熄灭）。", "hint": "\n### 计分方式\n\n设初始画面生成了 $x$ 种不同的画面。\n\n令 $i$ 为最大的的非负整数，满足 $(10\\cdot i-1)^2\\le x$，则得分为 $\\min(100,10\\cdot i)$。\n\n### 提示\n\n\n**光敏性癫痫警告：开发者已尽力确保可视化对癫痫患者是安全的，但请小心使用。**\n\n我们在附件中提供了可视化工具 $\\boldsymbol{visualise.py}$。\n\n这是一个 Python 脚本，依赖于 `matplotlib` 和 `numpy` 库（请自行搜索如何安装，可能需要更换镜像源）。\n\n使用以下命令启动可视化工具：\n\n- Linux / MacOS：\n\n\t```bash\n\tpython3 visualise.py < mig.txt\n\t```\n- Windows cmd：\n\t```bash\n\tpy visualise.py < mig.txt\n    ```\n\n压缩包还包含了一个示例文件 $\\boldsymbol{mig.txt}$。\n\n你可以根据需要自行修改可视化工具。  \n\n", "locale": "zh-CN"}}}
{"pid": "P11926", "type": "P", "difficulty": 0, "samples": [["4\n1\n1\n1\n57\n5\n0 3 4 3 0\n2\n4 4", "3\n9\n5\n6"]], "limits": {"time": [20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "PA（波兰）"], "title": "[PA 2025] 三人赛 / Turniej trójek", "background": "PA 2025 R5C.\n\n**警告：滥用本题评测一次即可封号。**", "description": "有 $n$ 栋建筑，编号 $1\\sim n$。\n\n\n举行了若干场比赛，每场比赛参赛人数**恰好** $3$ 人。设这三个人所在的建筑编号为 $a,b,c$，则这场比赛将在建筑 $\\operatorname{median}(a,b,c)$ 举行，其中 $\\operatorname{median}(a,b,c)$ 表示数列 $[a,b,c]$ 的中位数。\n\n- 特别地，若 $a=b$，那么无论 $c$ 的取值如何，比赛都会在建筑 $a$ 举行。\n\n已知：\n\n\n- 每三名玩家**至多**进行了一次比赛；\n- 对于每座建筑 $i$，有 $a_i$ 场比赛在建筑 $i$ 中举行。\n\n但是你不知道每栋建筑中的玩家人数。求出最少的人数，符合已知数据。\n", "inputFormat": "\n**本题单个测试点内含有多组测试数据。**\n\n第一行，一个正整数 $T$，表示测试数据组数。\n\n接下来描述 $T$ 组测试数据：\n\n每组测试数据两行。第一行，正整数 $n$。第二行，$n$ 个非负整数 $a_1,a_2,\\ldots,a_n$。\n\n保证每组数据中，$\\sum a_i\\gt 0$。\n\n", "outputFormat": "输出 $T$ 行，每行一个正整数，表示建筑物中玩家人数和的最小值。", "hint": "### 样例解释\n\n\n- 第 $1$ 组数据：一场比赛需要 $3$ 名玩家。\n- 第 $2$ 组数据：$8$ 名玩家至多组 ${8\\choose 3}=56$ 场比赛，所以至少需要 $9$ 人。\n- 第 $3$ 组数据：每个建筑只住一个人就够了：\n\t- 建筑 $2$ 中：建筑 $(1,2,3),(1,2,4),(1,2,5)$ 的玩家组了比赛；\n\t- 建筑 $3$ 中：建筑 $(1,3,4),(1,3,5),(2,3,4),(2,3,5)$ 的玩家组了比赛；\n    - 建筑 $4$ 中：建筑 $(1,4,5),(2,4,5),(3,4,5)$ 的玩家组了比赛。\n    \n\n### 数据范围\n\n- $1\\le T\\le 50$；\n- $1\\le n,\\sum n\\le 2\\times 10^5$；\n- $0\\le a_i\\le 10^6$；\n- 每组数据中，$\\sum a_i\\gt 0$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2025] 三人赛 / Turniej trójek", "background": "PA 2025 R5C.\n\n**警告：滥用本题评测一次即可封号。**", "description": "有 $n$ 栋建筑，编号 $1\\sim n$。\n\n\n举行了若干场比赛，每场比赛参赛人数**恰好** $3$ 人。设这三个人所在的建筑编号为 $a,b,c$，则这场比赛将在建筑 $\\operatorname{median}(a,b,c)$ 举行，其中 $\\operatorname{median}(a,b,c)$ 表示数列 $[a,b,c]$ 的中位数。\n\n- 特别地，若 $a=b$，那么无论 $c$ 的取值如何，比赛都会在建筑 $a$ 举行。\n\n已知：\n\n\n- 每三名玩家**至多**进行了一次比赛；\n- 对于每座建筑 $i$，有 $a_i$ 场比赛在建筑 $i$ 中举行。\n\n但是你不知道每栋建筑中的玩家人数。求出最少的人数，符合已知数据。\n", "inputFormat": "\n**本题单个测试点内含有多组测试数据。**\n\n第一行，一个正整数 $T$，表示测试数据组数。\n\n接下来描述 $T$ 组测试数据：\n\n每组测试数据两行。第一行，正整数 $n$。第二行，$n$ 个非负整数 $a_1,a_2,\\ldots,a_n$。\n\n保证每组数据中，$\\sum a_i\\gt 0$。\n\n", "outputFormat": "输出 $T$ 行，每行一个正整数，表示建筑物中玩家人数和的最小值。", "hint": "### 样例解释\n\n\n- 第 $1$ 组数据：一场比赛需要 $3$ 名玩家。\n- 第 $2$ 组数据：$8$ 名玩家至多组 ${8\\choose 3}=56$ 场比赛，所以至少需要 $9$ 人。\n- 第 $3$ 组数据：每个建筑只住一个人就够了：\n\t- 建筑 $2$ 中：建筑 $(1,2,3),(1,2,4),(1,2,5)$ 的玩家组了比赛；\n\t- 建筑 $3$ 中：建筑 $(1,3,4),(1,3,5),(2,3,4),(2,3,5)$ 的玩家组了比赛；\n    - 建筑 $4$ 中：建筑 $(1,4,5),(2,4,5),(3,4,5)$ 的玩家组了比赛。\n    \n\n### 数据范围\n\n- $1\\le T\\le 50$；\n- $1\\le n,\\sum n\\le 2\\times 10^5$；\n- $0\\le a_i\\le 10^6$；\n- 每组数据中，$\\sum a_i\\gt 0$。", "locale": "zh-CN"}}}
{"pid": "P11927", "type": "P", "difficulty": 6, "samples": [["4\n2 3\n250 1000\n1 1 2\n1 2 3\n2 1 37\n3 5\n500 800 1100\n1 1 2\n1 2 1\n2 2 3\n2 3 1\n3 3 5\n2 2\n4 4\n1 1 2\n1 2 1\n2 1\n10 10\n1 2 1000000000", "666\n1080\n4\n-1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "PA（波兰）"], "title": "[PA 2025] 重金属 / Heavy Metal", "background": "PA 2025 R5B.", "description": "\n扩音系统由 $n$ 个路由器和 $m$ 个放大器组成。麦克风连接到第 $1$ 号路由器，扬声器连接到第 $n$ 号路由器。\n\n每个放大器连接两个路由器（输入和输出），**增益系数**为 $w_i$。路由器的最大带宽为 $p_i$。  \n\n麦克风的信号功率为 $1$。配置系统，使信号在放大器、路由器中传输。信号经过放大器后，功率会乘以该放大器的增益系数，但是为了避免烧毁，通过路由器的信号功率必须**不大于** $p_i$。\n\n**信号可以多次通过同一路由器或放大器**。最终将信号传输到扬声器（到达 $n$ 号路由器），在路由器不烧毁的前提下，最大化信号的功率。求出可能的最大功率。\n\n", "inputFormat": "**本题单个测试点内含有多组测试数据。**\n\n第一行，正整数 $T$，表示测试数据组数。接下来依次描述 $T$ 组数据：\n\n每组数据第一行，两个正整数 $n,m$。\n\n每组数据第二行，$n$ 个正整数 $p_1,p_2,\\ldots,p_n$。\n\n每组数据接下来的 $m$ 行，每行三个正整数 $a_i,b_i,w_i$，表示放大器的输入路由器、输出路由器和增益系数。\n\n", "outputFormat": "\n\n输出 $T$ 行，每行一个整数：\n\n- 若能成功将信号传输到扬声器，输出可能的最大增益系数；\n- 否则，输出一行一个 $-1$。  \n", "hint": "\n\n### 样例解释\n\n$114(514)$ 表示，信号到达第 $114$ 个路由器时，功率为 $514$。\n\n- 样例 $1$ 解释：\n\n最优路径：$1(1)\\to 1(1\\times 2)\\to 2(2\\times 3)\\to 1(6\\times 37)\\to 2(222\\times 3)$。\n\n- 样例 $2$ 解释：\n\n最优路径：$1(1)\\to 1(2)\\to 1(4)\\to 1(8)\\to 2(8)\\to 2(24)\\to 2(72)\\to 2(216)\\to 3(216)\\to 3(1080)$。  \n\n- 样例 $3$ 解释：\n\n最优路径：$1\\to 1(2)\\to 1(4)\\to 2(4)$。\n\n- 样例 $4$ 解释：路由器 $2$ 一定会被烧毁，所以无法传到路由器 $2$。\n\n### 数据范围\n\n- $1\\le n,\\sum n\\le 100$；\n- $1\\le m,\\sum m\\le 200$；\n- $1\\le p_i\\le 10^9$；\n- $1\\le a_i,b_i\\le n$；\n- $1\\le w_i\\le 10^9$。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2025] 重金属 / Heavy Metal", "background": "PA 2025 R5B.", "description": "\n扩音系统由 $n$ 个路由器和 $m$ 个放大器组成。麦克风连接到第 $1$ 号路由器，扬声器连接到第 $n$ 号路由器。\n\n每个放大器连接两个路由器（输入和输出），**增益系数**为 $w_i$。路由器的最大带宽为 $p_i$。  \n\n麦克风的信号功率为 $1$。配置系统，使信号在放大器、路由器中传输。信号经过放大器后，功率会乘以该放大器的增益系数，但是为了避免烧毁，通过路由器的信号功率必须**不大于** $p_i$。\n\n**信号可以多次通过同一路由器或放大器**。最终将信号传输到扬声器（到达 $n$ 号路由器），在路由器不烧毁的前提下，最大化信号的功率。求出可能的最大功率。\n\n", "inputFormat": "**本题单个测试点内含有多组测试数据。**\n\n第一行，正整数 $T$，表示测试数据组数。接下来依次描述 $T$ 组数据：\n\n每组数据第一行，两个正整数 $n,m$。\n\n每组数据第二行，$n$ 个正整数 $p_1,p_2,\\ldots,p_n$。\n\n每组数据接下来的 $m$ 行，每行三个正整数 $a_i,b_i,w_i$，表示放大器的输入路由器、输出路由器和增益系数。\n\n", "outputFormat": "\n\n输出 $T$ 行，每行一个整数：\n\n- 若能成功将信号传输到扬声器，输出可能的最大增益系数；\n- 否则，输出一行一个 $-1$。  \n", "hint": "\n\n### 样例解释\n\n$114(514)$ 表示，信号到达第 $114$ 个路由器时，功率为 $514$。\n\n- 样例 $1$ 解释：\n\n最优路径：$1(1)\\to 1(1\\times 2)\\to 2(2\\times 3)\\to 1(6\\times 37)\\to 2(222\\times 3)$。\n\n- 样例 $2$ 解释：\n\n最优路径：$1(1)\\to 1(2)\\to 1(4)\\to 1(8)\\to 2(8)\\to 2(24)\\to 2(72)\\to 2(216)\\to 3(216)\\to 3(1080)$。  \n\n- 样例 $3$ 解释：\n\n最优路径：$1\\to 1(2)\\to 1(4)\\to 2(4)$。\n\n- 样例 $4$ 解释：路由器 $2$ 一定会被烧毁，所以无法传到路由器 $2$。\n\n### 数据范围\n\n- $1\\le n,\\sum n\\le 100$；\n- $1\\le m,\\sum m\\le 200$；\n- $1\\le p_i\\le 10^9$；\n- $1\\le a_i,b_i\\le n$；\n- $1\\le w_i\\le 10^9$。\n\n", "locale": "zh-CN"}}}
{"pid": "P11928", "type": "P", "difficulty": 6, "samples": [["4 3\nabca\n1 a\n4 d\n2 c", "1\n1\n0\n4"]], "limits": {"time": [15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["线段树", "2025", "矩阵乘法", "PA（波兰）", "动态 DP"], "title": "[PA 2025] 子序列 / Podciągi", "background": "PA 2025 R5B.\n\n**警告：滥用本题评测一次即可封号。**", "description": "本题中下标均为 $\\text{1-indexed}$。\n\n给定长度为 $n$ 的字符串 $s$，字符集 $\\Sigma=\\{\\texttt{a},\\texttt{b},\\ldots,\\texttt{f}\\}$。\n\n有 $q$ 次操作，每次操作对 $s$ 进行单点修改。\n\n对于 $i=1,2,\\ldots,q+1$，求出：进行前 $(i-1)$ 次操作后，$s$ 中满足以下条件的**非空**子序列 $t$ 的数量：\n\n- $t$ 在 $s$ 中出现至少两次。\n\n由于答案可能很大，只需要求出答案对 $998\\, 244\\, 353$ 取模后的结果。\n", "inputFormat": "\n第一行，两个非负整数 $n,q$。\n\n第二行，字符串 $s$。\n\n接下来 $q$ 行，第 $i$ 行正整数 $p_i$ 和字符 $c_i$，表示一次操作 $s_{p_i}\\gets c_i$。\n", "outputFormat": "输出 $(q+1)$ 行，第 $i$ 行一个非负整数，表示进行前 $(i-1)$ 次操作后的答案对 $998\\, 244\\, 353$ 取模后的结果。\n", "hint": "\n### 样例解释\n\n- 初始字符串为 $s=\\texttt{abca}$，唯一符合条件的子序列为 $\\texttt{a}$。\n- 进行 $1$ 次操作后，字符串为 $s=\\texttt{abca}$，唯一符合条件的子序列为 $\\texttt{a}$。\n- 进行前 $2$ 次操作后，字符串为 $s=\\texttt{abcd}$，无符合条件的子序列。\n- 进行前 $3$ 次操作后，$s=\\texttt{accd}$，符合条件的子序列有 $\\texttt{ac},\\texttt{cd},\\texttt{acd},\\texttt{c}$。\n\n### 子任务\n\n存在大于 $0$ 分的子任务满足 $\\Sigma=\\{\\texttt{a},\\texttt{b}\\}$。\n\n### 数据范围\n\n- $3 \\le n \\le 5\\times 10^4$；\n- $0 \\le q \\le 5\\times 10^4$；\n- $s_i,c_i\\in \\Sigma=\\{\\texttt{a},\\texttt{b},\\ldots,\\texttt{f}\\}$；\n- $1\\le p_i\\le n$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2025] 子序列 / Podciągi", "background": "PA 2025 R5B.\n\n**警告：滥用本题评测一次即可封号。**", "description": "本题中下标均为 $\\text{1-indexed}$。\n\n给定长度为 $n$ 的字符串 $s$，字符集 $\\Sigma=\\{\\texttt{a},\\texttt{b},\\ldots,\\texttt{f}\\}$。\n\n有 $q$ 次操作，每次操作对 $s$ 进行单点修改。\n\n对于 $i=1,2,\\ldots,q+1$，求出：进行前 $(i-1)$ 次操作后，$s$ 中满足以下条件的**非空**子序列 $t$ 的数量：\n\n- $t$ 在 $s$ 中出现至少两次。\n\n由于答案可能很大，只需要求出答案对 $998\\, 244\\, 353$ 取模后的结果。\n", "inputFormat": "\n第一行，两个非负整数 $n,q$。\n\n第二行，字符串 $s$。\n\n接下来 $q$ 行，第 $i$ 行正整数 $p_i$ 和字符 $c_i$，表示一次操作 $s_{p_i}\\gets c_i$。\n", "outputFormat": "输出 $(q+1)$ 行，第 $i$ 行一个非负整数，表示进行前 $(i-1)$ 次操作后的答案对 $998\\, 244\\, 353$ 取模后的结果。\n", "hint": "\n### 样例解释\n\n- 初始字符串为 $s=\\texttt{abca}$，唯一符合条件的子序列为 $\\texttt{a}$。\n- 进行 $1$ 次操作后，字符串为 $s=\\texttt{abca}$，唯一符合条件的子序列为 $\\texttt{a}$。\n- 进行前 $2$ 次操作后，字符串为 $s=\\texttt{abcd}$，无符合条件的子序列。\n- 进行前 $3$ 次操作后，$s=\\texttt{accd}$，符合条件的子序列有 $\\texttt{ac},\\texttt{cd},\\texttt{acd},\\texttt{c}$。\n\n### 子任务\n\n存在大于 $0$ 分的子任务满足 $\\Sigma=\\{\\texttt{a},\\texttt{b}\\}$。\n\n### 数据范围\n\n- $3 \\le n \\le 5\\times 10^4$；\n- $0 \\le q \\le 5\\times 10^4$；\n- $s_i,c_i\\in \\Sigma=\\{\\texttt{a},\\texttt{b},\\ldots,\\texttt{f}\\}$；\n- $1\\le p_i\\le n$。\n", "locale": "zh-CN"}}}
{"pid": "P11929", "type": "P", "difficulty": 7, "samples": [["2 2 3 10000019", "4 4"], ["2 3 3 999999937", "5 10"], ["8 9 11 15872567", "57 57"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "PA（波兰）"], "title": "[PA 2025] 光滑排列 / Gładkie permutacj", "background": "PA 2025 R5A.\n\n", "description": "对于序列 $a=[a_1,a_2,\\ldots,a_k]$，我们说：\n\n- $a$ 是递增的，当且仅当 $a_1\\lt a_2\\lt \\ldots\\lt a_k$；\n- $a$ 是递减的，当且仅当 $a_1\\gt a_2\\gt \\ldots\\gt a_k$；\n- $a$ 是**单峰的**，当且仅当存在 $1\\le l\\le k$，使得 $[a_1,a_2,\\ldots,a_l]$ 是递增的，且 $[a_l,a_{l+1},\\ldots,a_k]$ 是递减的。\n\n特别地，若 $k=1$，则 $a$ 既是递增的，也是递减的，也是单峰的。\n\n对于正整数 $a,b,c$，我们说一个排列 $p$ 是好的，当且仅当：\n\n- $p$ 的最长上升子序列（LIS）长度为 $a$；\n- $p$ 的最长下降子序列（LDS）长度为 $b$；\n- $p$ 的最长单峰子序列长度为 $c$。\n\n\n\n> **例**\n>\n> $a=2,b=3,c=4$ 时，排列 $[4, 5, 2, 3, 1]$ 是好的，因为：  \n> - LIS 为 $[4, 5]$（长度 $2$）；  \n> - LDS为 $[4, 2, 1]$（长度 $3$）；  \n> - 最长单峰子序列为 $[4, 5, 3, 1]$（长度 $4$）。  \n\n给定 $a,b,c$ 满足 $1\\le a\\le b\\le c\\lt a+b$。求出：\n\n1. 好的排列 $p$ 的长度的最大值（记为 $n$）；\n2. **长度为 $n$ 的**好的排列的数量对大素数 $\\mathrm{mod}$ 取模后的结果。\n\n可以证明，在题目条件下，好的排列至少有一个，且只有有限个。\n\n\n", "inputFormat": "\n一行四个正整数 $a,b,c,\\mathrm{mod}$。\n\n", "outputFormat": "一行两个正整数：\n\n- 最长的好的排列的长度 $n$；\n- 长度为 $n$ 的好的排列的数量对 $\\mathrm{mod}$ 取模后的结果。\n", "hint": "\n### 样例解释\n\n- 样例 $1$ 解释：\n\n样例 $1$ 中，$a=2,b=2,c=3$。\n\n所有好的排列为：\n\n- $[1, 3, 2]$；\n- $[2, 3, 1]$；\n- $[2, 1, 4, 3]$；\n- $[2, 4, 1, 3]$；\n- $[3, 1, 4, 2]$；\n- $[3, 4, 1, 2]$。\n\n其中最长的排列长度为 $4$。  \n\n\n\n- 样例 $2$ 解释：\n\n样例 $2$ 中，$a=2,b=3,c=3$。\n\n\n所有好的排列为：\n- $[3, 2, 1, 5, 4]$；\n- $[3, 2, 5, 1, 4]$； \n- $[4, 2, 1, 5, 3]$；\n- $[4, 2, 5, 1, 3]$；\n- $[4, 3, 1, 5, 2]$；\n- $[4, 3, 5, 1, 2]$；\n- $[5, 2, 1, 4, 3]$；\n- $[5, 2, 4, 1, 3]$；\n- $[5, 3, 1, 4, 2]$；\n- $[5, 3, 4, 1, 2]$。\n\n### 子任务\n\n在大于 $0$ 分的子任务中，保证 $c = a + b - 1$。  \n\n### 数据范围\n\n- $1 \\leq a \\leq 20$；\n- $ a \\leq b \\leq 5\\times 10^4$；\n- $b \\leq c \\lt a + b$；\n- $10^7 \\leq \\mathrm{mod} \\leq 10^9$；\n- $\\mathrm{mod}$ 是素数。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2025] 光滑排列 / Gładkie permutacj", "background": "PA 2025 R5A.\n\n", "description": "对于序列 $a=[a_1,a_2,\\ldots,a_k]$，我们说：\n\n- $a$ 是递增的，当且仅当 $a_1\\lt a_2\\lt \\ldots\\lt a_k$；\n- $a$ 是递减的，当且仅当 $a_1\\gt a_2\\gt \\ldots\\gt a_k$；\n- $a$ 是**单峰的**，当且仅当存在 $1\\le l\\le k$，使得 $[a_1,a_2,\\ldots,a_l]$ 是递增的，且 $[a_l,a_{l+1},\\ldots,a_k]$ 是递减的。\n\n特别地，若 $k=1$，则 $a$ 既是递增的，也是递减的，也是单峰的。\n\n对于正整数 $a,b,c$，我们说一个排列 $p$ 是好的，当且仅当：\n\n- $p$ 的最长上升子序列（LIS）长度为 $a$；\n- $p$ 的最长下降子序列（LDS）长度为 $b$；\n- $p$ 的最长单峰子序列长度为 $c$。\n\n\n\n> **例**\n>\n> $a=2,b=3,c=4$ 时，排列 $[4, 5, 2, 3, 1]$ 是好的，因为：  \n> - LIS 为 $[4, 5]$（长度 $2$）；  \n> - LDS为 $[4, 2, 1]$（长度 $3$）；  \n> - 最长单峰子序列为 $[4, 5, 3, 1]$（长度 $4$）。  \n\n给定 $a,b,c$ 满足 $1\\le a\\le b\\le c\\lt a+b$。求出：\n\n1. 好的排列 $p$ 的长度的最大值（记为 $n$）；\n2. **长度为 $n$ 的**好的排列的数量对大素数 $\\mathrm{mod}$ 取模后的结果。\n\n可以证明，在题目条件下，好的排列至少有一个，且只有有限个。\n\n\n", "inputFormat": "\n一行四个正整数 $a,b,c,\\mathrm{mod}$。\n\n", "outputFormat": "一行两个正整数：\n\n- 最长的好的排列的长度 $n$；\n- 长度为 $n$ 的好的排列的数量对 $\\mathrm{mod}$ 取模后的结果。\n", "hint": "\n### 样例解释\n\n- 样例 $1$ 解释：\n\n样例 $1$ 中，$a=2,b=2,c=3$。\n\n所有好的排列为：\n\n- $[1, 3, 2]$；\n- $[2, 3, 1]$；\n- $[2, 1, 4, 3]$；\n- $[2, 4, 1, 3]$；\n- $[3, 1, 4, 2]$；\n- $[3, 4, 1, 2]$。\n\n其中最长的排列长度为 $4$。  \n\n\n\n- 样例 $2$ 解释：\n\n样例 $2$ 中，$a=2,b=3,c=3$。\n\n\n所有好的排列为：\n- $[3, 2, 1, 5, 4]$；\n- $[3, 2, 5, 1, 4]$； \n- $[4, 2, 1, 5, 3]$；\n- $[4, 2, 5, 1, 3]$；\n- $[4, 3, 1, 5, 2]$；\n- $[4, 3, 5, 1, 2]$；\n- $[5, 2, 1, 4, 3]$；\n- $[5, 2, 4, 1, 3]$；\n- $[5, 3, 1, 4, 2]$；\n- $[5, 3, 4, 1, 2]$。\n\n### 子任务\n\n在大于 $0$ 分的子任务中，保证 $c = a + b - 1$。  \n\n### 数据范围\n\n- $1 \\leq a \\leq 20$；\n- $ a \\leq b \\leq 5\\times 10^4$；\n- $b \\leq c \\lt a + b$；\n- $10^7 \\leq \\mathrm{mod} \\leq 10^9$；\n- $\\mathrm{mod}$ 是素数。\n\n", "locale": "zh-CN"}}}
{"pid": "P11930", "type": "P", "difficulty": 6, "samples": [["3 2 4\n3 4 1\n2 3 1\n1 2 10\n2 1 2\n2 3 1\n1 3 1\n2 3 2", "0\n10\n20\n22"]], "limits": {"time": [25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000, 25000], "memory": [4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000, 4000000]}, "tags": ["2025", "分块", "PA（波兰）"], "title": "[PA 2025] 吃树叶 / Liście", "background": "PA 2025 R5A.\n\n**警告：滥用本题评测一次即可封号。**\n\n[这里](https://www.luogu.com.cn/problem/U547677)提供了本题的部分测试点（你可以在**附件**中下载它们），**强烈建议上述题目提交通过后再提交本题。**\n\n注记：原题评测机速度应该不快于洛谷的 $1/4$。", "description": "\n有 $10^6$ 棵树，自西向东编号 $1\\sim 10^6$。小恐龙的营地在第 $1$ 棵树西边。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x3sfvs1o.png)\n\n在接下来的 $n$ 天中，小恐龙的饮食计划为：\n\n- 第 $i$ 天，她将从营地步行到树 $a_i$，再返回营地。从营地去树 $a_i$ 的途中，她会摘下遇到的所有的树的 $v_i$ 片叶子（返程时不摘叶子）。\n\n不难发现，每天，每棵树至多只被摘一次叶子。\n\n一开始，$v_i=0$。有 $m$ 次修改：\n\n- 第 $j$ 次修改将**前 $p_j$ 天的 $v_i$**（$i = 1, 2, \\ldots, p_j$）每个增加 $w_j$。  \n\n此外，修改间隙有 $z$ 次查询：  \n\n- 第 $j$ 次查询：求出在前 $p_j$ 天中，第 $d_j$ 棵树被吃掉的总叶子数。\n\n修改会影响所有后面的查询，但是每个查询之间是独立的。\n", "inputFormat": "第一行，三个正整数 $n,m,z$。\n\n第二行，$n$ 个正整数 $a_1,a_2,\\ldots,a_n$。\n\n接下来 $(m+z)$ 行，每行三个正整数：\n- $\\texttt{1}$ $p_j$ $w_j$，描述一次修改操作；\n- $\\texttt{2}$ $p_j$ $d_j$，描述一次查询操作。\n\n", "outputFormat": "\n输出 $z$ 行，每行一个非负整数，表示查询的答案。\n", "hint": "### 样例解释\n\n饮食计划如下：\n\n- 第 $1$ 天：前往 $a_1 = 3$ 号树；  \n- 第 $2$ 天：前往 $a_2 = 4$ 号树；\n- 第 $3$ 天：前往 $a_3 = 1$ 号树；\n\n初始时所有 $v_1 = v_2 = v_3 = 0$，即实际上一片叶子都不会摘。\n\n1. 第一次查询，问前 $3$ 天中，$1$ 号树被摘掉的叶子数。答案显然为 $0$。\n2. 第一次修改，将前 $2$ 天的 $v_i$ 各增加 $10$。  \n   此时 $v_1=10,v_2=10,v_3=0$。\n3. 第二次查询，问第 $1$ 天中，$2$ 号树被摘掉的叶子数。\n\n\t由于第一天摘了 $2$ 号树的叶子，所以答案为 $10$。\n4. 第三次查询，问前 $3$ 天中，$1$ 号树被摘掉的总叶子数。\n\t\n    由于前两天都会摘 $1$ 号树的叶子，所以答案为 $10+10=20$。\n5. 第二次修改，将前 $3$ 天的 $v_i$ 各加 $1$。  \n\n   此时，$v_1=11,v_2=11,v_3=1$。\n\n6. 第四次查询，问前 $3$ 天中，$2$ 号树摘掉的叶子数。\n   \n   答案为 $11 + 11 + 0 = 22$。  \n\n\n### 数据范围\n\n- $1 \\leq n, m, z \\leq 10^6$；\n- $n \\cdot m \\cdot z \\leq 10^{16}$；\n- $1\\le a_i,w_j,d_j\\le 10^6$；\n- $1\\le p_j\\le n$。\n\n### 子任务\n\n子任务 $0$ 为样例。\n\n下表中，符号 $a \\sim b$ 表示 $0.99 \\cdot b < a \\le b$。\n\n| 子任务编号 | 限制 | \n|:-------:|---------|\n| $1$ | $(m + z) \\cdot n \\le 10^7$ |\n| $2$ | $z \\cdot m \\le 10^7$，$n \\cdot m \\cdot z \\sim 10^{13}$ |\n| $3$ | $n = 10^4$，$n \\cdot m \\cdot z \\sim 10^{14}$ |\n| $4$ | $m = 10^4$，$n \\cdot m \\cdot z \\sim 10^{14}$ |\n| $5$ | $z = 10^4$，$n \\cdot m \\cdot z \\sim 10^{14}$ |\n| $6$ | $n \\cdot m \\cdot z \\sim 10^{14}$ |\n| $7$ | $n = 10^4$，$n \\cdot m \\cdot z \\sim 10^{16}$ |\n| $8$ | $m = 10^4$，$n \\cdot m \\cdot z \\sim 10^{16}$ |\n| $9$ | $z = 10^4$，$n \\cdot m \\cdot z \\sim 10^{16}$ |\n| $10$ | $n \\cdot m \\cdot z \\sim 10^{16}$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[PA 2025] 吃树叶 / Liście", "background": "PA 2025 R5A.\n\n**警告：滥用本题评测一次即可封号。**\n\n[这里](https://www.luogu.com.cn/problem/U547677)提供了本题的部分测试点（你可以在**附件**中下载它们），**强烈建议上述题目提交通过后再提交本题。**\n\n注记：原题评测机速度应该不快于洛谷的 $1/4$。", "description": "\n有 $10^6$ 棵树，自西向东编号 $1\\sim 10^6$。小恐龙的营地在第 $1$ 棵树西边。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x3sfvs1o.png)\n\n在接下来的 $n$ 天中，小恐龙的饮食计划为：\n\n- 第 $i$ 天，她将从营地步行到树 $a_i$，再返回营地。从营地去树 $a_i$ 的途中，她会摘下遇到的所有的树的 $v_i$ 片叶子（返程时不摘叶子）。\n\n不难发现，每天，每棵树至多只被摘一次叶子。\n\n一开始，$v_i=0$。有 $m$ 次修改：\n\n- 第 $j$ 次修改将**前 $p_j$ 天的 $v_i$**（$i = 1, 2, \\ldots, p_j$）每个增加 $w_j$。  \n\n此外，修改间隙有 $z$ 次查询：  \n\n- 第 $j$ 次查询：求出在前 $p_j$ 天中，第 $d_j$ 棵树被吃掉的总叶子数。\n\n修改会影响所有后面的查询，但是每个查询之间是独立的。\n", "inputFormat": "第一行，三个正整数 $n,m,z$。\n\n第二行，$n$ 个正整数 $a_1,a_2,\\ldots,a_n$。\n\n接下来 $(m+z)$ 行，每行三个正整数：\n- $\\texttt{1}$ $p_j$ $w_j$，描述一次修改操作；\n- $\\texttt{2}$ $p_j$ $d_j$，描述一次查询操作。\n\n", "outputFormat": "\n输出 $z$ 行，每行一个非负整数，表示查询的答案。\n", "hint": "### 样例解释\n\n饮食计划如下：\n\n- 第 $1$ 天：前往 $a_1 = 3$ 号树；  \n- 第 $2$ 天：前往 $a_2 = 4$ 号树；\n- 第 $3$ 天：前往 $a_3 = 1$ 号树；\n\n初始时所有 $v_1 = v_2 = v_3 = 0$，即实际上一片叶子都不会摘。\n\n1. 第一次查询，问前 $3$ 天中，$1$ 号树被摘掉的叶子数。答案显然为 $0$。\n2. 第一次修改，将前 $2$ 天的 $v_i$ 各增加 $10$。  \n   此时 $v_1=10,v_2=10,v_3=0$。\n3. 第二次查询，问第 $1$ 天中，$2$ 号树被摘掉的叶子数。\n\n\t由于第一天摘了 $2$ 号树的叶子，所以答案为 $10$。\n4. 第三次查询，问前 $3$ 天中，$1$ 号树被摘掉的总叶子数。\n\t\n    由于前两天都会摘 $1$ 号树的叶子，所以答案为 $10+10=20$。\n5. 第二次修改，将前 $3$ 天的 $v_i$ 各加 $1$。  \n\n   此时，$v_1=11,v_2=11,v_3=1$。\n\n6. 第四次查询，问前 $3$ 天中，$2$ 号树摘掉的叶子数。\n   \n   答案为 $11 + 11 + 0 = 22$。  \n\n\n### 数据范围\n\n- $1 \\leq n, m, z \\leq 10^6$；\n- $n \\cdot m \\cdot z \\leq 10^{16}$；\n- $1\\le a_i,w_j,d_j\\le 10^6$；\n- $1\\le p_j\\le n$。\n\n### 子任务\n\n子任务 $0$ 为样例。\n\n下表中，符号 $a \\sim b$ 表示 $0.99 \\cdot b < a \\le b$。\n\n| 子任务编号 | 限制 | \n|:-------:|---------|\n| $1$ | $(m + z) \\cdot n \\le 10^7$ |\n| $2$ | $z \\cdot m \\le 10^7$，$n \\cdot m \\cdot z \\sim 10^{13}$ |\n| $3$ | $n = 10^4$，$n \\cdot m \\cdot z \\sim 10^{14}$ |\n| $4$ | $m = 10^4$，$n \\cdot m \\cdot z \\sim 10^{14}$ |\n| $5$ | $z = 10^4$，$n \\cdot m \\cdot z \\sim 10^{14}$ |\n| $6$ | $n \\cdot m \\cdot z \\sim 10^{14}$ |\n| $7$ | $n = 10^4$，$n \\cdot m \\cdot z \\sim 10^{16}$ |\n| $8$ | $m = 10^4$，$n \\cdot m \\cdot z \\sim 10^{16}$ |\n| $9$ | $z = 10^4$，$n \\cdot m \\cdot z \\sim 10^{16}$ |\n| $10$ | $n \\cdot m \\cdot z \\sim 10^{16}$ |\n", "locale": "zh-CN"}}}
{"pid": "P11931", "type": "P", "difficulty": 3, "samples": [["8 3\n3\n1\n2\n1\n1\n3\n3\n2", "2"], ["1 2\n1", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "ICPC"], "title": "[CrCPC 2024] AI 的末日", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) A.", "description": "有 $n$ 件衣服要被**依次**叠好。\n\n一共有 $k$ 种衣服，第 $j$ 种衣服要被叠到第 $j$ 堆上。第 $i$ 件衣服的种类为 $a_i$。\n\n你随身带着一本数学笔记本。你不想弄脏它，于是把它放在某一堆上。但是**衣服不能叠在笔记本上**，如果要把一件衣服叠在笔记本所在的堆上，那么必须先把笔记本移走。\n\n你可以任意选择初始时笔记本的位置，也可以在合法的前提下任意选择把笔记本移到哪堆。在最优策略下，至少需要**移**多少次笔记本？\n", "inputFormat": "第一行，两个正整数 $n,k$。\n\n接下来 $n$ 行，第 $i$ 行一个正整数 $a_i$。", "outputFormat": "一行一个非负整数表示答案。", "hint": "- $1\\le n\\le 10^6$，$2\\le k\\le 10^9$；\n- $1\\le a_i\\le k$。\n\n样例解释：一开始放在第 $1$ 堆上，然后放在第 $3$ 堆上，然后移回第 $1$ 堆。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CrCPC 2024] AI 的末日", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) A.", "description": "有 $n$ 件衣服要被**依次**叠好。\n\n一共有 $k$ 种衣服，第 $j$ 种衣服要被叠到第 $j$ 堆上。第 $i$ 件衣服的种类为 $a_i$。\n\n你随身带着一本数学笔记本。你不想弄脏它，于是把它放在某一堆上。但是**衣服不能叠在笔记本上**，如果要把一件衣服叠在笔记本所在的堆上，那么必须先把笔记本移走。\n\n你可以任意选择初始时笔记本的位置，也可以在合法的前提下任意选择把笔记本移到哪堆。在最优策略下，至少需要**移**多少次笔记本？\n", "inputFormat": "第一行，两个正整数 $n,k$。\n\n接下来 $n$ 行，第 $i$ 行一个正整数 $a_i$。", "outputFormat": "一行一个非负整数表示答案。", "hint": "- $1\\le n\\le 10^6$，$2\\le k\\le 10^9$；\n- $1\\le a_i\\le k$。\n\n样例解释：一开始放在第 $1$ 堆上，然后放在第 $3$ 堆上，然后移回第 $1$ 堆。\n", "locale": "zh-CN"}}}
{"pid": "P11932", "type": "P", "difficulty": 6, "samples": [["2 2 0\n1 2\n3 1 0 0", "4"], ["3 5 1 2\n2 11 3\n5 4 5 1 12 6", "13"], ["2 3 2\n2 3 2\n3 10 12 4", "impossible"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "Special Judge", "ICPC"], "title": "[CrCPC 2024] 平凡的数论题", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) B.", "description": "给定非负整数序列 $a,b,c$，长度分别为 $|a|,|b|,|c|$。这里序列下标是 **0-indexed** 的。\n\n令 $l=\\max\\{a_i,b_i,c_i\\}$。\n\n找到任意一个 $\\in [l+1,10^{19})$ 的正整数 $B$，使得 $\\displaystyle \\left(\\sum_{0\\le i\\lt |a|} a_iB^i\\right)\\left(\\sum_{0\\le j\\lt |b|} b_jB^j\\right)=\\sum_{0\\le k\\lt |c|} c_kB^k$ 成立。\n\n数据保证，若存在正整数 $B\\ge l+1$ 使得上式成立，则存在一个 $\\in [l+1,10^{19})$ 的正整数 $B$ 使得上式成立。\n", "inputFormat": "第一行，$|a|+1$ 个非负整数 $|a|,a_{|a|-1},a_{|a|-2},\\ldots,a_0$。\n\n第二行，$|b|+1$ 个非负整数 $|b|,b_{|b|-1},b_{|b|-2},\\ldots,b_0$。\n\n第一行，$|c|+1$ 个非负整数 $|c|,c_{|c|-1},c_{|c|-2},\\ldots,c_0$。\n\n**数据保证 $a_{|a|-1},b_{|b|-1},c_{|c|-1}\\neq 0$。**\n", "outputFormat": "如果存在 $\\in [l+1,10^{19})$ 的 $B$，直接输出；\n\n否则输出一行一个 $\\texttt{impossible}。$\n\n\n**数据保证，若存在正整数 $B\\ge l+1$ 使得上式成立，则存在一个 $\\in [l+1,10^{19})$ 的正整数 $B$ 使得上式成立。**", "hint": "- $1\\le |a|,|b|,|c|\\le 10^3$；\n- $0\\le a_i,b_i,c_i\\le 2^{30}$；\n- $a_{|a|-1},b_{|b-1|},c_{|c-1|}\\neq 0$。\n- 若存在正整数 $B\\ge l+1$ 使得上式成立，则存在一个 $\\in [l+1,10^{19})$ 的正整数 $B$ 使得上式成立。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CrCPC 2024] 平凡的数论题", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) B.", "description": "给定非负整数序列 $a,b,c$，长度分别为 $|a|,|b|,|c|$。这里序列下标是 **0-indexed** 的。\n\n令 $l=\\max\\{a_i,b_i,c_i\\}$。\n\n找到任意一个 $\\in [l+1,10^{19})$ 的正整数 $B$，使得 $\\displaystyle \\left(\\sum_{0\\le i\\lt |a|} a_iB^i\\right)\\left(\\sum_{0\\le j\\lt |b|} b_jB^j\\right)=\\sum_{0\\le k\\lt |c|} c_kB^k$ 成立。\n\n数据保证，若存在正整数 $B\\ge l+1$ 使得上式成立，则存在一个 $\\in [l+1,10^{19})$ 的正整数 $B$ 使得上式成立。\n", "inputFormat": "第一行，$|a|+1$ 个非负整数 $|a|,a_{|a|-1},a_{|a|-2},\\ldots,a_0$。\n\n第二行，$|b|+1$ 个非负整数 $|b|,b_{|b|-1},b_{|b|-2},\\ldots,b_0$。\n\n第一行，$|c|+1$ 个非负整数 $|c|,c_{|c|-1},c_{|c|-2},\\ldots,c_0$。\n\n**数据保证 $a_{|a|-1},b_{|b|-1},c_{|c|-1}\\neq 0$。**\n", "outputFormat": "如果存在 $\\in [l+1,10^{19})$ 的 $B$，直接输出；\n\n否则输出一行一个 $\\texttt{impossible}。$\n\n\n**数据保证，若存在正整数 $B\\ge l+1$ 使得上式成立，则存在一个 $\\in [l+1,10^{19})$ 的正整数 $B$ 使得上式成立。**", "hint": "- $1\\le |a|,|b|,|c|\\le 10^3$；\n- $0\\le a_i,b_i,c_i\\le 2^{30}$；\n- $a_{|a|-1},b_{|b-1|},c_{|c-1|}\\neq 0$。\n- 若存在正整数 $B\\ge l+1$ 使得上式成立，则存在一个 $\\in [l+1,10^{19})$ 的正整数 $B$ 使得上式成立。", "locale": "zh-CN"}}}
{"pid": "P11933", "type": "P", "difficulty": 6, "samples": [["5 1\n0 0\n-1 2\n4 3\n-3 4\n1 5", "6.8416192530"], ["2 1\n0 0\n0 1", "1.0000000000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "Special Judge", "ICPC"], "title": "[CrCPC 2024] 修路", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) C.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uwqqd8f7.png?x-oss-process=image/resize,w_200)", "description": "有一条河流。这条河流由 $(n-1)$ 段线段组成，由 $n$ 个点 $(x_1,y_1),(x_2,y_2),\\ldots,(x_n,y_n)$ 顺次连接而成。这里，$\\forall 1\\le i\\lt n$，都有 $y_i\\lt y_{i+1}$。\n\n要修建一条路，起点为 $(x_1,y_1)$，终点为 $(x_n,y_n)$。路同样也是折线段。\n\n给定正实数 $T$。令折线段的（欧几里得）总长度为 $a$，**穿过**河流的次数为 $b$，一种修路方案的**代价**为 $a+T\\cdot b$。\n\n路可以贴着河流修，贴着河流修不算作穿过。\n\n求出修路方案可能的最小代价。\n", "inputFormat": "第一行，正整数 $n$ 和正实数 $T$。$T$ 最多有两位小数。\n\n接下来 $n$ 行，第 $i$ 行两个整数 $x_i,y_i$。\n\n**数据保证不存在三点共线。**\n", "outputFormat": "输出一行一个实数表示代价。\n\n当你的答案与标准答案的绝对或相对误差不大于 $10^{-6}$ 时，认为你的答案正确。\n", "hint": "#### 样例解释\n\n样例 $1$ 解释：见【题目背景】中的图。\n\n#### 数据范围\n\n- $2\\le n\\le 1\\, 500$；\n- $0\\lt T\\le 10^6$，$T$ 至多有两位小数；\n- $|x_i|,|y_i|\\le 10^5$；\n- $\\forall 1\\le i\\lt n$，有 $y_i\\lt y_{i+1}$；\n- 保证不存在三点共线。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CrCPC 2024] 修路", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) C.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uwqqd8f7.png?x-oss-process=image/resize,w_200)", "description": "有一条河流。这条河流由 $(n-1)$ 段线段组成，由 $n$ 个点 $(x_1,y_1),(x_2,y_2),\\ldots,(x_n,y_n)$ 顺次连接而成。这里，$\\forall 1\\le i\\lt n$，都有 $y_i\\lt y_{i+1}$。\n\n要修建一条路，起点为 $(x_1,y_1)$，终点为 $(x_n,y_n)$。路同样也是折线段。\n\n给定正实数 $T$。令折线段的（欧几里得）总长度为 $a$，**穿过**河流的次数为 $b$，一种修路方案的**代价**为 $a+T\\cdot b$。\n\n路可以贴着河流修，贴着河流修不算作穿过。\n\n求出修路方案可能的最小代价。\n", "inputFormat": "第一行，正整数 $n$ 和正实数 $T$。$T$ 最多有两位小数。\n\n接下来 $n$ 行，第 $i$ 行两个整数 $x_i,y_i$。\n\n**数据保证不存在三点共线。**\n", "outputFormat": "输出一行一个实数表示代价。\n\n当你的答案与标准答案的绝对或相对误差不大于 $10^{-6}$ 时，认为你的答案正确。\n", "hint": "#### 样例解释\n\n样例 $1$ 解释：见【题目背景】中的图。\n\n#### 数据范围\n\n- $2\\le n\\le 1\\, 500$；\n- $0\\lt T\\le 10^6$，$T$ 至多有两位小数；\n- $|x_i|,|y_i|\\le 10^5$；\n- $\\forall 1\\le i\\lt n$，有 $y_i\\lt y_{i+1}$；\n- 保证不存在三点共线。\n", "locale": "zh-CN"}}}
{"pid": "P11934", "type": "P", "difficulty": 5, "samples": [["9\n3 4 7 8 9 1 2 5 6", "1"], ["3\n1 3 2", "1"], ["4\n1 3 2 4", "2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "ICPC"], "title": "[CrCPC 2024] 排序", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) D.", "description": "给定 $1\\sim n$ 的排列 $p_1,p_2,\\ldots,p_n$。\n\n你可以执行任意多次（包括零次）以下操作：\n\n- 将 $p$ **划分**成**可以为空**的四段，依次记为 $a,b,c,d$。将这四段重排成 $c,a,d,b$。\n\n求出至少操作多少次后，排列将变为 $1,2,\\ldots,n$。\n", "inputFormat": "第一行，一个正整数 $n$。\n\n第二行，$n$ 个正整数 $p_1,p_2,\\ldots,p_n$。", "outputFormat": "输出一行一个非负整数，表示答案。", "hint": "#### 样例解释\n\n- 样例 $1$ 解释：\n\t- 令 $a=[3,4],b=[7,8,9],c=[1,2],d=[5,6]$。\n    - 交换后变为 $[1,2],[3,4],[5,6],[7,8,9]$。\n- 样例 $2$ 解释：\n\t- 令 $a=[1],b=[3],c=[],d=[2]$。\n    - 交换后变为 $[],[1],[2],[3]$。\n#### 数据范围\n\n- $1\\le n\\le 10$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CrCPC 2024] 排序", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) D.", "description": "给定 $1\\sim n$ 的排列 $p_1,p_2,\\ldots,p_n$。\n\n你可以执行任意多次（包括零次）以下操作：\n\n- 将 $p$ **划分**成**可以为空**的四段，依次记为 $a,b,c,d$。将这四段重排成 $c,a,d,b$。\n\n求出至少操作多少次后，排列将变为 $1,2,\\ldots,n$。\n", "inputFormat": "第一行，一个正整数 $n$。\n\n第二行，$n$ 个正整数 $p_1,p_2,\\ldots,p_n$。", "outputFormat": "输出一行一个非负整数，表示答案。", "hint": "#### 样例解释\n\n- 样例 $1$ 解释：\n\t- 令 $a=[3,4],b=[7,8,9],c=[1,2],d=[5,6]$。\n    - 交换后变为 $[1,2],[3,4],[5,6],[7,8,9]$。\n- 样例 $2$ 解释：\n\t- 令 $a=[1],b=[3],c=[],d=[2]$。\n    - 交换后变为 $[],[1],[2],[3]$。\n#### 数据范围\n\n- $1\\le n\\le 10$。", "locale": "zh-CN"}}}
{"pid": "P11935", "type": "P", "difficulty": 6, "samples": [["4 8", "663085949"], ["8 8", "480783235"], ["3 2", "875000008"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "ICPC"], "title": "[CrCPC 2024] 萌萌交互题", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) E.", "description": "**这是一道传统题。**\n\n交互库有一个隐藏的长度为 $n$，值域为 $[1,k]$ 的正整数序列 $a=[a_1,\\ldots,a_n]$。\n\n每次询问可以给定一个长度为 $n$，值域为 $[1,k]$ 的正整数序列 $[b_1,\\ldots,b_n]$，交互库会告诉你猜对了哪些位置。也就是，交互库会返回一个长度为 $n$ 的 $01$ 序列 $s$，$s_i=1$ 表示 $a_i=b_i$，$s_i=0$ 表示 $a_i\\neq b_i$。\n\n**交互库是非自适应的**，也就是说序列 $a$ 已经事先确定。\n\n对于序列 $[a_1,a_2,\\ldots,a_n]$，定义 $f([a_1,a_2,\\ldots,a_n])$ 为：如果交互库隐藏的序列为 $a=[a_1,a_2,\\ldots,a_n]$，最优策略下要多少次才能猜出 $a$ 序列。\n\n\n若交互库在 $k^n$ 个长度为 $n$，值域 $\\in [1,k]$ 的正整数序列 $[a_1,a_2,\\ldots,a_n]$ 中等概率独立随机选取一个，求出 $f$ 的期望值。\n\n换句话说，令 $\\displaystyle p=\\sum_{1\\le a_1\\le k}\\sum_{1\\le a_2\\le k}\\cdots \\sum_{1\\le a_n\\le k}f([a_1,a_2,\\ldots,a_n])$，$q=k^n$，求出 $p/q$。\n\n只需要输出答案对 $(10^9+7)$ 取模后的结果。\n\n（注记：当且仅当交互库返回 $[1,1,\\ldots,1]$ 时，认为猜出了序列。换句话说，就算已经事先确定这个序列，也要再询问一次。）\n\n", "inputFormat": "一行两个正整数 $n,k$。", "outputFormat": "一行一个非负整数，表示答案对 $(10^9+7)$ 取模后的结果。", "hint": "#### 样例解释\n\n样例 $3$ 真实答案为 $\\frac{1}{8}+\\frac{7}{8}\\cdot 2=\\frac{15}{8}$。\n\n#### 数据范围\n\n- $1\\le n\\le 10^6$；\n- $1\\le k\\le 10^9$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CrCPC 2024] 萌萌交互题", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) E.", "description": "**这是一道传统题。**\n\n交互库有一个隐藏的长度为 $n$，值域为 $[1,k]$ 的正整数序列 $a=[a_1,\\ldots,a_n]$。\n\n每次询问可以给定一个长度为 $n$，值域为 $[1,k]$ 的正整数序列 $[b_1,\\ldots,b_n]$，交互库会告诉你猜对了哪些位置。也就是，交互库会返回一个长度为 $n$ 的 $01$ 序列 $s$，$s_i=1$ 表示 $a_i=b_i$，$s_i=0$ 表示 $a_i\\neq b_i$。\n\n**交互库是非自适应的**，也就是说序列 $a$ 已经事先确定。\n\n对于序列 $[a_1,a_2,\\ldots,a_n]$，定义 $f([a_1,a_2,\\ldots,a_n])$ 为：如果交互库隐藏的序列为 $a=[a_1,a_2,\\ldots,a_n]$，最优策略下要多少次才能猜出 $a$ 序列。\n\n\n若交互库在 $k^n$ 个长度为 $n$，值域 $\\in [1,k]$ 的正整数序列 $[a_1,a_2,\\ldots,a_n]$ 中等概率独立随机选取一个，求出 $f$ 的期望值。\n\n换句话说，令 $\\displaystyle p=\\sum_{1\\le a_1\\le k}\\sum_{1\\le a_2\\le k}\\cdots \\sum_{1\\le a_n\\le k}f([a_1,a_2,\\ldots,a_n])$，$q=k^n$，求出 $p/q$。\n\n只需要输出答案对 $(10^9+7)$ 取模后的结果。\n\n（注记：当且仅当交互库返回 $[1,1,\\ldots,1]$ 时，认为猜出了序列。换句话说，就算已经事先确定这个序列，也要再询问一次。）\n\n", "inputFormat": "一行两个正整数 $n,k$。", "outputFormat": "一行一个非负整数，表示答案对 $(10^9+7)$ 取模后的结果。", "hint": "#### 样例解释\n\n样例 $3$ 真实答案为 $\\frac{1}{8}+\\frac{7}{8}\\cdot 2=\\frac{15}{8}$。\n\n#### 数据范围\n\n- $1\\le n\\le 10^6$；\n- $1\\le k\\le 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P11936", "type": "P", "difficulty": 1, "samples": [["3\n10 12 4", "2"], ["5\n20 2 22 2020 2002", "4"], ["5\n9 2 7 4 11", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "ICPC"], "title": "[CrCPC 2024] 取名", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) F.", "description": "有两个帮派：奇数帮，偶数帮。\n\n每个成员都有一个**唯一的**正整数昵称。奇数帮的成员的昵称是奇数，偶数帮的成员的昵称是偶数。\n\n已知有 $n$ 个人加入了帮派，并给出他们的昵称。\n\nMirko 要加入一个帮派。他会选择人数较多的帮派，然后选择最小的符合要求的正整数作为他的昵称。请你告诉他他的昵称是什么。\n", "inputFormat": "第一行，正整数 $n$。\n\n第二行，$n$ 个正整数，表示 $n$ 个帮派成员的昵称。\n\n**数据保证两个帮派人数不同。**", "outputFormat": "输出一行一个正整数表示答案。", "hint": "- $1\\le n\\le 100$；\n- 所有输入的数都是 $[1,10^6]$ 间的整数。\n- **数据保证两个帮派人数不同。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CrCPC 2024] 取名", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) F.", "description": "有两个帮派：奇数帮，偶数帮。\n\n每个成员都有一个**唯一的**正整数昵称。奇数帮的成员的昵称是奇数，偶数帮的成员的昵称是偶数。\n\n已知有 $n$ 个人加入了帮派，并给出他们的昵称。\n\nMirko 要加入一个帮派。他会选择人数较多的帮派，然后选择最小的符合要求的正整数作为他的昵称。请你告诉他他的昵称是什么。\n", "inputFormat": "第一行，正整数 $n$。\n\n第二行，$n$ 个正整数，表示 $n$ 个帮派成员的昵称。\n\n**数据保证两个帮派人数不同。**", "outputFormat": "输出一行一个正整数表示答案。", "hint": "- $1\\le n\\le 100$；\n- 所有输入的数都是 $[1,10^6]$ 间的整数。\n- **数据保证两个帮派人数不同。**", "locale": "zh-CN"}}}
{"pid": "P11937", "type": "P", "difficulty": 6, "samples": [["3\n2 2\nCC\nCC\n2 2\nCB\nBC\n1 12\nCBCCCCCCCCBC", "2/1\n2/1\n4/1"], ["1\n6 2\nCC\nCC\nCC\nCC\nCC\nCC", "6/1"], ["1\n6 3\nCBC\nCBC\nCBC\nCBC\nCBC\nCBC", "4/1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188, 524188]}, "tags": ["2024", "ICPC"], "title": "[CrCPC 2024] 传传爆", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) G.\n\n2025/3/19：加入一组来自 @_lmh_ 的 hack 数据，位于 Subtask 0。", "description": "有一个 $n\\times m$ 的矩阵，左上角的格子记为 $(1,1)$，右下角的格子记为 $(n,m)$。\n\n格子要么是黑色的，要么是白色的。魔法少女从 $(1,1)$ 出发寻找食物，按照如下规则移动：\n\n- 每次可以向上下左右移动一步，但是不能出界。\n- 如果移动到黑色格子，则无事发生。\n- 如果移动到白色格子，魔法少女会被**等概率独立随机**传送到任意一个白色格子（包括她所在的格子）上。传送完后可以继续移动。\n\n当魔法少女到达 $(n,m)$ 时，她会停止移动。**魔法少女会最小化移动的期望次数**。求出魔法少女移动的期望步数。\n\n**题目保证 $(1,1)$ 和 $(n,m)$ 都是黑色的。**\n", "inputFormat": "**本题单个测试点内含有多组测试数据。**\n\n第一行，一个正整数 $T$，表示数据组数。\n\n接下来依次描述 $T$ 组数据：\n\n每组数据第一行，两个正整数 $n,m$。\n\n接下来一个 $n\\times m$ 的矩阵，第 $i$ 行第 $j$ 列的字符是 $\\texttt{C}$，表示 $(i,j)$ 是黑色；否则是 $\\texttt{B}$，表示 $(i,j)$ 是白色。\n", "outputFormat": "可以证明答案一定是一个有理数。\n\n对于每组数据，输出一行一个**既约分数** $p/q$。", "hint": "- $1\\le T\\le 10^3$；\n- $1\\le n,m\\le 10^3$；\n- $\\sum nm\\le 10^6$。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CrCPC 2024] 传传爆", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) G.\n\n2025/3/19：加入一组来自 @_lmh_ 的 hack 数据，位于 Subtask 0。", "description": "有一个 $n\\times m$ 的矩阵，左上角的格子记为 $(1,1)$，右下角的格子记为 $(n,m)$。\n\n格子要么是黑色的，要么是白色的。魔法少女从 $(1,1)$ 出发寻找食物，按照如下规则移动：\n\n- 每次可以向上下左右移动一步，但是不能出界。\n- 如果移动到黑色格子，则无事发生。\n- 如果移动到白色格子，魔法少女会被**等概率独立随机**传送到任意一个白色格子（包括她所在的格子）上。传送完后可以继续移动。\n\n当魔法少女到达 $(n,m)$ 时，她会停止移动。**魔法少女会最小化移动的期望次数**。求出魔法少女移动的期望步数。\n\n**题目保证 $(1,1)$ 和 $(n,m)$ 都是黑色的。**\n", "inputFormat": "**本题单个测试点内含有多组测试数据。**\n\n第一行，一个正整数 $T$，表示数据组数。\n\n接下来依次描述 $T$ 组数据：\n\n每组数据第一行，两个正整数 $n,m$。\n\n接下来一个 $n\\times m$ 的矩阵，第 $i$ 行第 $j$ 列的字符是 $\\texttt{C}$，表示 $(i,j)$ 是黑色；否则是 $\\texttt{B}$，表示 $(i,j)$ 是白色。\n", "outputFormat": "可以证明答案一定是一个有理数。\n\n对于每组数据，输出一行一个**既约分数** $p/q$。", "hint": "- $1\\le T\\le 10^3$；\n- $1\\le n,m\\le 10^3$；\n- $\\sum nm\\le 10^6$。\n\n", "locale": "zh-CN"}}}
{"pid": "P11938", "type": "P", "difficulty": 5, "samples": [["5 1 5\n5\n1 2 2\n1 4 2\n2 3 1\n3 4 1\n5 3 1\n4\n1 2 2\n2 4 2\n2 3 1\n2 5 2", "-1"], ["3 1 3\n4\n1 2 10\n2 3 10\n1 3 20\n2 3 30\n4\n2 1 10\n1 3 10\n1 1 10\n2 3 10", "20"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "ICPC"], "title": "[CrCPC 2024] 信步山中", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) H.", "description": "给定两张 $n$ 个点的**无向连通图** $G_1(V_1,E_1),G_2(V_2,E_2)$。边有边权。\n\n初始时童子军们在起点 $s$，他们要行军到终点 $t$。\n\n他们的行动会遵循以下规则：\n\n令童子军当前在节点 $x$，\n\n- 第 $1,3,5,\\cdots$ 次移动，他们会选择一条边 $(x,y,w)\\in E_1$，然后移动到 $y$。\n\t- 令 $\\operatorname{dist}_1(x,y)$ 表示 $G_1$ 中 $x,y$ 之间的最短路长度。$\\operatorname{dist}_1(x,t)\\textcolor{red}{\\gt}\\operatorname{dist}_1(y,t)$ 必须满足。\n- 第 $2,4,6,\\cdots$ 次移动，他们会选择一条边 $(x,y,w)\\in E_2$，然后移动到 $y$。\n\t- 令 $\\operatorname{dist}_2(x,y)$ 表示 $G_2$ 中 $x,y$ 之间的最短路长度。$\\operatorname{dist}_2(x,t)\\textcolor{red}{\\gt}\\operatorname{dist}_2(y,t)$ 必须满足。\n\n你需要求出，在满足上述条件的情况下，从起点到终点经过边的边权和的**最大值**。\n\n特别地，最大值可以为无穷大，即他们可以永远走不到终点。在符合条件的情况下，可以一直拖着不走到终点。\n", "inputFormat": "第一行，三个正整数 $n,s,t$。\n\n第二行，一个正整数 $m_1$，表示 $G_1$ 的边数 $|E_1|$。\n\n接下来 $m_1$ 行，每行三个正整数 $u,v,w$，表示 $(u,v,w)\\in E_1$。\n\n第 $(m_1+3)$ 行，一个正整数 $m_2$，表示 $G_2$ 的边数 $|E_2|$。\n\n接下来 $m_2$ 行，每行三个正整数 $u,v,w$，表示 $(u,v,w)\\in E_2$。", "outputFormat": "如果答案为无穷大，输出一行一个 $\\texttt{-1}$。\n\n否则输出一行一个非负整数表示答案。", "hint": "- $2\\le n\\le 10^3$；\n- $n-1\\le m_1,m_2\\le 10^5$；\n- $1\\le u,v\\le n$，$1\\le w\\le 10^6$；\n- $1\\le s,t\\le n$。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CrCPC 2024] 信步山中", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) H.", "description": "给定两张 $n$ 个点的**无向连通图** $G_1(V_1,E_1),G_2(V_2,E_2)$。边有边权。\n\n初始时童子军们在起点 $s$，他们要行军到终点 $t$。\n\n他们的行动会遵循以下规则：\n\n令童子军当前在节点 $x$，\n\n- 第 $1,3,5,\\cdots$ 次移动，他们会选择一条边 $(x,y,w)\\in E_1$，然后移动到 $y$。\n\t- 令 $\\operatorname{dist}_1(x,y)$ 表示 $G_1$ 中 $x,y$ 之间的最短路长度。$\\operatorname{dist}_1(x,t)\\textcolor{red}{\\gt}\\operatorname{dist}_1(y,t)$ 必须满足。\n- 第 $2,4,6,\\cdots$ 次移动，他们会选择一条边 $(x,y,w)\\in E_2$，然后移动到 $y$。\n\t- 令 $\\operatorname{dist}_2(x,y)$ 表示 $G_2$ 中 $x,y$ 之间的最短路长度。$\\operatorname{dist}_2(x,t)\\textcolor{red}{\\gt}\\operatorname{dist}_2(y,t)$ 必须满足。\n\n你需要求出，在满足上述条件的情况下，从起点到终点经过边的边权和的**最大值**。\n\n特别地，最大值可以为无穷大，即他们可以永远走不到终点。在符合条件的情况下，可以一直拖着不走到终点。\n", "inputFormat": "第一行，三个正整数 $n,s,t$。\n\n第二行，一个正整数 $m_1$，表示 $G_1$ 的边数 $|E_1|$。\n\n接下来 $m_1$ 行，每行三个正整数 $u,v,w$，表示 $(u,v,w)\\in E_1$。\n\n第 $(m_1+3)$ 行，一个正整数 $m_2$，表示 $G_2$ 的边数 $|E_2|$。\n\n接下来 $m_2$ 行，每行三个正整数 $u,v,w$，表示 $(u,v,w)\\in E_2$。", "outputFormat": "如果答案为无穷大，输出一行一个 $\\texttt{-1}$。\n\n否则输出一行一个非负整数表示答案。", "hint": "- $2\\le n\\le 10^3$；\n- $n-1\\le m_1,m_2\\le 10^5$；\n- $1\\le u,v\\le n$，$1\\le w\\le 10^6$；\n- $1\\le s,t\\le n$。\n\n", "locale": "zh-CN"}}}
{"pid": "P11939", "type": "P", "difficulty": 2, "samples": [["2 1\nNijeZivotJedanACM -\nZivotJESTJedanACM -\nNijeZivotJedanACM -", "1"], ["3 2\nStoJeZivot ?1/04:00:00 +1/02:04:06\nJeLiZivotJedanACM ?1/04:59:59 -\nNijeZivotJedanACM ?1/04:42:43 -\nNijeZivotJedanACM +1/04:42:43 -", "2"], ["7 4\nNisamSadaNistaDonio +1/03:59:59 +3/03:42:02 +2/00:14:59 ?1/04:56:12\nJeLiMojKockaSeUmio ?4/04:00:00 -3 +1/00:10:01 +9/03:04:42\nOstaviDobroJe ?4/04:59:59 -1 +2/00:24:15 +8/03:24:45\nDobroJeOstavi +1/01:42:53 - ?9/04:58:23 ?1/04:34:43\nNijeZivotJedanACM ?2/04:50:05 ?4/04:32:12 +2/01:32:45 ?1/04:59:59\nKoSeToSeta ?1/04:23:32 - +9/01:00:00 -9\nSipSipSipSipSipSip - - - ?9/04:00:00\nNijeZivotJedanACM -2 +4/04:32:12 +2/01:32:45 +1/04:59:59", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "ICPC"], "title": "[CrCPC 2024] 别样的滚榜大战", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) I.", "description": "为了解题方便，我们简单介绍本题中 ICPC 赛制的部分规则。与实际规则不同的地方，**以本题中描述的为准**。\n \n1. 题目与队伍：共有 $m$ 道题目，$n$ 支队伍。**每支队伍的队伍名都是独一无二的**。\n2. 排名规则。\n\t1. 解出题目越多的队伍排名越靠前。\n    1. 若解题数相同，则罚时越少的队伍排名越靠前。\n    3. 若解题数和罚时数都相同，则队伍名字典序越小的队伍排名越靠前。  \n3. 罚时。\n\t1. 某队伍的**总罚时**等于所有**解出题目**的罚时之和。  \n\t2. 题目的罚时计算规则。\n    \t- 题目罚时为该题最后一次提交正确解答的时间。  \n  \t\t- **每次**错误提交，额外增加 $20$ 分钟的罚时。  \n        - 队伍不会重新提交已经通过的题目。 \n  \t\t- 每队每道题最多提交 $9$ 次。\n4. 计分与封榜机制。\n\t1. 比赛总时长 $5$ 小时。\n    2. 前 $4$ 小时：\n  \t\t- 排行榜是可见的，所有队伍都能看到当前排名和每道题的提交信息（提交次数、是否解出、解出的时间）。  \n  \t\t- **每次提交后，排行榜都会实时更新**。  \n\t3. 第 $5$ 小时（最后 $1$ 小时）：  \n  \t\t- 排行榜被冻结，此时**排名不会再更新**，但仍然记录每个队伍的提交情况（提交次数、最后提交的时间）。  \n  \t\t- 每个队伍只能看到**自己的提交**是否正确，但无法看到其他队伍的最新解题情况。  \n\n现在比赛已经结束，排行榜即将解封。我们需要帮助 NijeZivotJedanACM 队计算他们在最终排名中可能的**最低**位置。\n\n", "inputFormat": "第一行，两个正整数 $n,m$。\n\n接下来 $n$ 行，每行描述一支队伍和这支队伍的（比赛结束，但**排行榜还未解封时**的）解题情况：\n- 每行第一个字符串，表示队伍名。队伍名只由大小写英文字母组成，且长度不超过 $20$。\n- 接下来 $m$ 个字符串，第 $i$ 个字符串描述该队伍在第 $i$ 道题中的解题情况：\n\t- 格式为 $\\texttt{sx/v}$，其中\n    \t- $\\texttt{s}$ 表示该题的提交状态：\n        \t- $\\texttt{+}$ 表示通过；\n            - $\\texttt{-}$ 表示未通过；\n            - $\\texttt{?}$ 表示未知。\n        - $\\texttt{x}$ 表示总提交次数：\n        \t- 若 $x=0$，则省略。\n        - $\\texttt{v}$ 表示最后一次提交时间：\n        \t- 格式为 $\\texttt{hh:mm:ss}$，**可能有前导零**，且时间严格小于 $5$ 小时。\n            - **如果该题未通过，则整个 $\\textcolor{red}{\\texttt{/v}}$ 部分省略。**\n\n第 $(n+2)$ 行，$(m+1)$ 个字符串描述 NijeZivotJedanACM 队在排行榜解封后的解题情况，格式和之前描述的相同。", "outputFormat": "一行一个正整数，表示答案。", "hint": "- $1\\le n\\le 10^3$；\n- $1\\le m\\le 15$；\n- 每支队伍的名字都不同，且由长度不超过 $20$ 的大小写英文字母组成的字符串构成。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CrCPC 2024] 别样的滚榜大战", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) I.", "description": "为了解题方便，我们简单介绍本题中 ICPC 赛制的部分规则。与实际规则不同的地方，**以本题中描述的为准**。\n \n1. 题目与队伍：共有 $m$ 道题目，$n$ 支队伍。**每支队伍的队伍名都是独一无二的**。\n2. 排名规则。\n\t1. 解出题目越多的队伍排名越靠前。\n    1. 若解题数相同，则罚时越少的队伍排名越靠前。\n    3. 若解题数和罚时数都相同，则队伍名字典序越小的队伍排名越靠前。  \n3. 罚时。\n\t1. 某队伍的**总罚时**等于所有**解出题目**的罚时之和。  \n\t2. 题目的罚时计算规则。\n    \t- 题目罚时为该题最后一次提交正确解答的时间。  \n  \t\t- **每次**错误提交，额外增加 $20$ 分钟的罚时。  \n        - 队伍不会重新提交已经通过的题目。 \n  \t\t- 每队每道题最多提交 $9$ 次。\n4. 计分与封榜机制。\n\t1. 比赛总时长 $5$ 小时。\n    2. 前 $4$ 小时：\n  \t\t- 排行榜是可见的，所有队伍都能看到当前排名和每道题的提交信息（提交次数、是否解出、解出的时间）。  \n  \t\t- **每次提交后，排行榜都会实时更新**。  \n\t3. 第 $5$ 小时（最后 $1$ 小时）：  \n  \t\t- 排行榜被冻结，此时**排名不会再更新**，但仍然记录每个队伍的提交情况（提交次数、最后提交的时间）。  \n  \t\t- 每个队伍只能看到**自己的提交**是否正确，但无法看到其他队伍的最新解题情况。  \n\n现在比赛已经结束，排行榜即将解封。我们需要帮助 NijeZivotJedanACM 队计算他们在最终排名中可能的**最低**位置。\n\n", "inputFormat": "第一行，两个正整数 $n,m$。\n\n接下来 $n$ 行，每行描述一支队伍和这支队伍的（比赛结束，但**排行榜还未解封时**的）解题情况：\n- 每行第一个字符串，表示队伍名。队伍名只由大小写英文字母组成，且长度不超过 $20$。\n- 接下来 $m$ 个字符串，第 $i$ 个字符串描述该队伍在第 $i$ 道题中的解题情况：\n\t- 格式为 $\\texttt{sx/v}$，其中\n    \t- $\\texttt{s}$ 表示该题的提交状态：\n        \t- $\\texttt{+}$ 表示通过；\n            - $\\texttt{-}$ 表示未通过；\n            - $\\texttt{?}$ 表示未知。\n        - $\\texttt{x}$ 表示总提交次数：\n        \t- 若 $x=0$，则省略。\n        - $\\texttt{v}$ 表示最后一次提交时间：\n        \t- 格式为 $\\texttt{hh:mm:ss}$，**可能有前导零**，且时间严格小于 $5$ 小时。\n            - **如果该题未通过，则整个 $\\textcolor{red}{\\texttt{/v}}$ 部分省略。**\n\n第 $(n+2)$ 行，$(m+1)$ 个字符串描述 NijeZivotJedanACM 队在排行榜解封后的解题情况，格式和之前描述的相同。", "outputFormat": "一行一个正整数，表示答案。", "hint": "- $1\\le n\\le 10^3$；\n- $1\\le m\\le 15$；\n- 每支队伍的名字都不同，且由长度不超过 $20$ 的大小写英文字母组成的字符串构成。", "locale": "zh-CN"}}}
{"pid": "P11940", "type": "P", "difficulty": 4, "samples": [["10 6\n1 4\n3 5\n6 7\n2 1\n9 4\n8 5", "14"], ["100 3\n11 50\n50 49\n36 35", "42"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "ICPC"], "title": "[CrCPC 2024] 搬东西", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) J.", "description": "街道上有 $l$ 家商店，自西向东编号为 $1,2,\\ldots,l$。相邻两家商店的距离为 $1$ 米。\n\n有 $n$ 个任务，第 $i$ 个任务要求从商店 $s_i$ 搬东西到商店 $t_i$。\n\n假设一次可以搬无限重的东西，可以**从任意商店出发**，整个任务结束后可以**停在任意商店**，求出路程和的最小值。\n", "inputFormat": "第一行，两个正整数 $l,n$。\n\n接下来 $n$ 行，第 $i$ 行的正整数为 $s_i,t_i$。", "outputFormat": "输出一行一个正整数，表示答案。", "hint": "#### 样例解释\n\n样例 $1$ 解释：\n\n从 $2$ 出发，\n\n- 在 $2\\to 1$ 的时候完成第 $4$ 个任务；\n- 在 $1\\to 9$ 的时候完成第 $1,2,3$ 个任务；\n- 在 $9\\to 4$ 的时候完成第 $5,6$ 个任务。\n\n总路程为 $|2-1|+|1-9|+|9-4|=14$，可以证明这是最优的方案。\n\n#### 数据范围\n\n- $1\\le l\\le 10^9$；\n- $1\\le n\\le 10^5$；\n- $1\\le s_i,t_i\\le l$，$s_i\\neq t_i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CrCPC 2024] 搬东西", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) J.", "description": "街道上有 $l$ 家商店，自西向东编号为 $1,2,\\ldots,l$。相邻两家商店的距离为 $1$ 米。\n\n有 $n$ 个任务，第 $i$ 个任务要求从商店 $s_i$ 搬东西到商店 $t_i$。\n\n假设一次可以搬无限重的东西，可以**从任意商店出发**，整个任务结束后可以**停在任意商店**，求出路程和的最小值。\n", "inputFormat": "第一行，两个正整数 $l,n$。\n\n接下来 $n$ 行，第 $i$ 行的正整数为 $s_i,t_i$。", "outputFormat": "输出一行一个正整数，表示答案。", "hint": "#### 样例解释\n\n样例 $1$ 解释：\n\n从 $2$ 出发，\n\n- 在 $2\\to 1$ 的时候完成第 $4$ 个任务；\n- 在 $1\\to 9$ 的时候完成第 $1,2,3$ 个任务；\n- 在 $9\\to 4$ 的时候完成第 $5,6$ 个任务。\n\n总路程为 $|2-1|+|1-9|+|9-4|=14$，可以证明这是最优的方案。\n\n#### 数据范围\n\n- $1\\le l\\le 10^9$；\n- $1\\le n\\le 10^5$；\n- $1\\le s_i,t_i\\le l$，$s_i\\neq t_i$。", "locale": "zh-CN"}}}
{"pid": "P11941", "type": "P", "difficulty": 5, "samples": [["1\nbrainrot\ntime\ngospodin\nmalnar\nje\nw\nrizzler\ni\nveliki\nsigma\nte\nima\nogroman\ngyatt\na\nskibidi\ntoilet\nnije\njer\nzivi\nu\nohiou\npa\nplaca\nfanum\ntax", "Krasan"], ["1\ndotdash\ndashdotdotdot\ndashdotdashdot\ndashdotdot\ndot\ndotdotdashdot\ndashdashdot\ndotdotdotdot\ndotdot\ndotdashdashdash\ndashdotdash\ndotdashdotdot\ndashdash\ndashdot\ndashdashdash\ndotdashdashdot\ndashdashdotdash\ndotdashdot\ndotdotdot\ndash\ndotdotdash\ndotdotdotdash\ndotdashdash\ndashdotdotdash\ndashdotdashdash\ndashdashdotdot", "Ruzan"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "ICPC"], "title": "[CrCPC 2024] 牙牙学语", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) K.", "description": "给定 $26$ 个只含小写英文字母的字符串 $s_a,s_b,\\ldots,s_{z}$。\n\n对于任意一个只含小写英文字母的字符串 $t$，我们把 $t$ 中的每个字母 $x$ 替换成字符串 $s_x$，得到新的字符串 $t'$。\n\n> 例子：当 $s_a=\\texttt{ana}$，$s_b=\\texttt{ban}$ 时，\n> \n> $t=\\texttt{\\textcolor{green}{b}a\\textcolor{green}{b}a}\\implies t'=\\texttt{\\textcolor{green}{ban}ana\\textcolor{green}{ban}ana}$。\n\n如果**存在**两个不同的字符串 $p,q$，它们在替换后得到的字符串 $p',q'$ 相同，亦即 $p\\neq q$ 且 $p'=q'$，那么我们就说这个替换规则是坏的，否则我们说这个替换规则是好的。\n\n试判断给定的替换规则是不是好的。\n", "inputFormat": "**本题单个测试点内含有多组测试数据。**\n\n第一行，正整数 $T$，表示测试数据组数。\n\n接下来描述 $T$ 组测试数据：每组测试数据 $26$ 行，每行一个字符串，分别为 $s_a,s_b,\\cdots,s_z$。", "outputFormat": "对于每组测试数据，输出一行：\n\n如果替换规则是好的，输出 $\\texttt{Krasan}$（=克罗地亚语「漂亮的」）；\n\n否则输出 $\\texttt{Ruzan}$（$\\texttt{ružan}$=克罗地亚语「丑陋的」）。", "hint": "#### 样例解释\n\n样例 $2$ 解释：$\\texttt{a}$ 和 $\\texttt{et}$ 是一个符合条件的例子。\n\n#### 数据范围\n\n- $1\\le t\\le 10^4$；\n- 输入的字符串长度和不超过 $10^6$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CrCPC 2024] 牙牙学语", "background": "译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) K.", "description": "给定 $26$ 个只含小写英文字母的字符串 $s_a,s_b,\\ldots,s_{z}$。\n\n对于任意一个只含小写英文字母的字符串 $t$，我们把 $t$ 中的每个字母 $x$ 替换成字符串 $s_x$，得到新的字符串 $t'$。\n\n> 例子：当 $s_a=\\texttt{ana}$，$s_b=\\texttt{ban}$ 时，\n> \n> $t=\\texttt{\\textcolor{green}{b}a\\textcolor{green}{b}a}\\implies t'=\\texttt{\\textcolor{green}{ban}ana\\textcolor{green}{ban}ana}$。\n\n如果**存在**两个不同的字符串 $p,q$，它们在替换后得到的字符串 $p',q'$ 相同，亦即 $p\\neq q$ 且 $p'=q'$，那么我们就说这个替换规则是坏的，否则我们说这个替换规则是好的。\n\n试判断给定的替换规则是不是好的。\n", "inputFormat": "**本题单个测试点内含有多组测试数据。**\n\n第一行，正整数 $T$，表示测试数据组数。\n\n接下来描述 $T$ 组测试数据：每组测试数据 $26$ 行，每行一个字符串，分别为 $s_a,s_b,\\cdots,s_z$。", "outputFormat": "对于每组测试数据，输出一行：\n\n如果替换规则是好的，输出 $\\texttt{Krasan}$（=克罗地亚语「漂亮的」）；\n\n否则输出 $\\texttt{Ruzan}$（$\\texttt{ružan}$=克罗地亚语「丑陋的」）。", "hint": "#### 样例解释\n\n样例 $2$ 解释：$\\texttt{a}$ 和 $\\texttt{et}$ 是一个符合条件的例子。\n\n#### 数据范围\n\n- $1\\le t\\le 10^4$；\n- 输入的字符串长度和不超过 $10^6$。\n", "locale": "zh-CN"}}}
