{"pid": "P14625", "type": "P", "difficulty": 0, "samples": [["4 6\n1 2\n2 3\n2 3\n3 4\n1 4\n1 4", "Yes"], ["4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4", "No"], ["9 12\n1 9\n1 4\n5 4\n6 5\n1 5\n8 1\n3 6\n6 8\n3 8\n2 9\n9 7\n7 2", "Yes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "高校校赛"], "title": "[2018 KAIST RUN Fall] Electronic Circuit", "background": "", "description": "Joon is taking General Physics II and he is now studying electronic circuits. An electronic circuit consists of several nodes and undirected wires each connecting two distinct nodes. Moreover, a circuit has two distinctive end nodes; a source node and a sink node, where a voltage is applied (usually it is applied by additional wire with a battery connecting the two nodes, but we will neglect it). Each wire has a resistance, and Joon should know how to calculate the composite resistance of a circuit.\n\nBy the way, Joon hates complicated things. So he only cares about circuits that can be made by series and parallel compositions, since they are easy to calculate the composite resistance. He calls them `nice` circuits; formally, a nice circuit can be defined as follows.\n\n- A circuit with a single wire connecting two end nodes is nice.\n- A circuit obtained by merging the sink node of a nice circuit $C_1$ and the source node of a nice circuit $C_2$ into a single node is nice. The source node and the sink node of the obtained circuit are the source node of $C_1$ and the sink node of $C_2$, respectively.\n- A circuit obtained by merging the two source nodes of nice circuits $C_1$ and $C_2$ into a single node, and merging the two sink nodes of $C_1$ and $C_2$ into a single node, is nice. The two end nodes of the obtained circuit are the respective merged end nodes.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/psev5xxs.png)\n\nIllustration of the definition of nice circuit.\n:::\n\nHe made a circuit with his wires to calculate the composite resistance, but his friend Pringles screwed up his circuit, so now Joon does not know what the end nodes are. To make things worse, he is not even sure whether the circuit is nice or not.\n\nJoon will give you the circuit. He kindly asks you whether the circuit can be nice by appropriately choosing two end nodes. Be careful that there may be multiple wires connecting two nodes.", "inputFormat": "The first line contains two integers, $n$ and $m$ ($2\\leq n\\leq 10^5$, $1\\leq m\\leq 3\\times 10^5$), where $n$ is the number of nodes and $m$ is the number of wires. All nodes are numbered from $1$ to $n$.\n\nIn the following $m$ lines, each line contains two integers $u$ and $v$ ($1 \\leq u,v \\leq n$ , $u \\neq v$), which represents a wire connecting $u$ and $v$. It is guaranteed that every node is attached to at least one wire; otherwise the node does not exist!", "outputFormat": "Print $\\texttt{Yes}$ if the given circuit can be nice, or $\\texttt{No}$ otherwise.", "hint": "", "locale": "en", "translations": {"en": {"title": "[2018 KAIST RUN Fall] Electronic Circuit", "background": "", "description": "Joon is taking General Physics II and he is now studying electronic circuits. An electronic circuit consists of several nodes and undirected wires each connecting two distinct nodes. Moreover, a circuit has two distinctive end nodes; a source node and a sink node, where a voltage is applied (usually it is applied by additional wire with a battery connecting the two nodes, but we will neglect it). Each wire has a resistance, and Joon should know how to calculate the composite resistance of a circuit.\n\nBy the way, Joon hates complicated things. So he only cares about circuits that can be made by series and parallel compositions, since they are easy to calculate the composite resistance. He calls them `nice` circuits; formally, a nice circuit can be defined as follows.\n\n- A circuit with a single wire connecting two end nodes is nice.\n- A circuit obtained by merging the sink node of a nice circuit $C_1$ and the source node of a nice circuit $C_2$ into a single node is nice. The source node and the sink node of the obtained circuit are the source node of $C_1$ and the sink node of $C_2$, respectively.\n- A circuit obtained by merging the two source nodes of nice circuits $C_1$ and $C_2$ into a single node, and merging the two sink nodes of $C_1$ and $C_2$ into a single node, is nice. The two end nodes of the obtained circuit are the respective merged end nodes.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/psev5xxs.png)\n\nIllustration of the definition of nice circuit.\n:::\n\nHe made a circuit with his wires to calculate the composite resistance, but his friend Pringles screwed up his circuit, so now Joon does not know what the end nodes are. To make things worse, he is not even sure whether the circuit is nice or not.\n\nJoon will give you the circuit. He kindly asks you whether the circuit can be nice by appropriately choosing two end nodes. Be careful that there may be multiple wires connecting two nodes.", "inputFormat": "The first line contains two integers, $n$ and $m$ ($2\\leq n\\leq 10^5$, $1\\leq m\\leq 3\\times 10^5$), where $n$ is the number of nodes and $m$ is the number of wires. All nodes are numbered from $1$ to $n$.\n\nIn the following $m$ lines, each line contains two integers $u$ and $v$ ($1 \\leq u,v \\leq n$ , $u \\neq v$), which represents a wire connecting $u$ and $v$. It is guaranteed that every node is attached to at least one wire; otherwise the node does not exist!", "outputFormat": "Print $\\texttt{Yes}$ if the given circuit can be nice, or $\\texttt{No}$ otherwise.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[2018 KAIST RUN Fall] Electronic Circuit", "background": "", "description": "Joon 正在学习普通物理 II，他现在正在研究电路。一个电路由若干个节点和连接两个不同节点的无向导线组成。此外，电路有两个不同的端节点：源节点和汇节点，电压施加在这两个节点上（通常是通过连接这两个节点的带电池的额外导线施加的，但我们将忽略这一点）。每根导线都有一个电阻，Joon 需要知道如何计算电路的复合电阻。\n\n不过，Joon 讨厌复杂的事物。所以他只关心可以通过串联和并联组合构成的电路，因为它们容易计算复合电阻。他称这些电路为\"优美\"电路；形式化地说，优美电路可以定义如下：\n\n- 具有单根导线连接两个端节点的电路是优美的。\n- 将一个优美电路 $C_1$ 的汇节点与另一个优美电路 $C_2$ 的源节点合并为一个节点后得到的电路是优美的。所得电路的源节点和汇节点分别是 $C_1$ 的源节点和 $C_2$ 的汇节点。\n- 将两个优美电路 $C_1$ 和 $C_2$ 的两个源节点合并为一个节点，并将两个汇节点合并为一个节点后得到的电路是优美的。所得电路的两个端节点分别是合并后的端节点。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/psev5xxs.png)\n\n优美电路定义的图示。\n:::\n\n他用导线制作了一个电路来计算复合电阻，但他的朋友 Pringles 弄乱了他的电路，所以现在 Joon 不知道端节点是什么。更糟糕的是，他甚至不确定这个电路是否优美。\n\nJoon 将给你这个电路。他恳切地询问你是否可以通过适当地选择两个端节点使该电路变得优美。注意，两个节点之间可能有多根导线连接。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$（$2 \\leq n \\leq 10^5$，$1 \\leq m \\leq 3 \\times 10^5$），其中 $n$ 是节点数，$m$ 是导线数。所有节点编号从 $1$ 到 $n$。\n\n接下来的 $m$ 行，每行包含两个整数 $u$ 和 $v$（$1 \\leq u,v \\leq n$，$u \\neq v$），表示一根连接 $u$ 和 $v$ 的导线。保证每个节点都至少连接一根导线；否则该节点不存在！", "outputFormat": "如果给定的电路可以是优美的，则输出 `Yes`，否则输出 `No`。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14626", "type": "P", "difficulty": 0, "samples": [["4\n1\n2\n3\n4", "1\n-1 -1\n0\n3\n-1 -1\n-1 -1\n0 1\n2\n3\n-1 -1\n0 0\n1 0\n2\n5\n-1 -1\n0 0\n0 0\n2 1\n1 2\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "Special Judge", "高校校赛"], "title": "[2018 KAIST RUN Fall] Fake Plastic Trees", "background": "", "description": "$\\textbf{Tree}$ is a recursive structure, which is either:\n\n- $\\textbf{Empty}$. Empty tree is denoted as $-1$ and has a size of 0. \n- $\\textbf{Non-empty}$. Non-empty tree $T$ is denoted as a pair of two trees $(T_1, T_2)$, where $T_1$ is called $\\textbf{left subtree}$ of $T$, and $T_2$ is called $\\textbf{right subtree}$ of $T$. If $T = (-1, -1)$, then we call such $T$ a $\\textbf{leaf}$. Leaf has a size of 1, and non-leaf has a size of $|T_1| + |T_2|$, where $|T_1|$ is the size of $T_1$, and $|T_2|$ is the size of $T_2$.\n\nA non-empty tree $T$ is a $\\textbf{Fake Plastic Tree}$, if the tree is $\\textit{balanced}$. Formally, Let $T = (T_1, T_2)$. If $|T_1| = |T_2|$ or $|T_1| = |T_2| + 1$ holds, then $T$ is a Fake Plastic Tree. \n\nIn computer science, trees are commonly used as a data structure, and they are stored in a memory. At first, there are no trees in the memory, and only an imaginary $\\textit{null pointer}$ exists (which corresponds to empty tree, $-1$). You can allocate a tree in the memory, by setting $T_1$ and $T_2$ as either a null pointer or a pointer of an existing tree. Then, the memory is extended by adding $T = (T_1, T_2)$ into its structure. Note that pointer can be described as a small integer, reducing the need for explicitly storing the whole tree.\n\nFormally, memory $M$ is an inductive structure, which at first contains only empty tree $-1$. ($M = \\{-1\\}$). You can expand the memory with following operation $M \\leftarrow M \\cup \\{(T_1, T_2)\\}$, where $T_1 \\in M, T_2 \\in M$. If a tree $T$ is inserted in $i$-th stage, then it has the $\\textbf{index}$ $i-1$. For a tree with index $i$, their subtrees can be represented as a pair of integer in range $[-1, i-1]$. \n\nYour task is to construct a memory $M$, which satisfies the following: \n\n- Every tree in $M$ is either empty or Fake Plastic Tree.\n- $M$ has at most 125 non-empty trees.\n- There exists a tree $T \\in M$, where $|T| = N$ holds. $N$ is an integer, and is given as an input.", "inputFormat": "The first line contains a single integer $T$, the number of test cases. ($1 \\leq T \\leq 2000$)\n\nIn the next $T$ lines, a single integer $N$ is given, which indicates the number of leaves your tree should contain. ($1 \\leq N \\leq 10^{18}$)", "outputFormat": "For each case, you should print $V + 2$ lines, where $V$ is the number of non-empty trees in $M$. ($1 \\leq V \\leq 125$).\n\nIn the first line, you should print single integer $V$. \n\nIn the next $V$ lines, you should print two space-separated integer $L_i, R_i$, which indicates the index of left subtree and right subtree for a tree with index $i$. ($-1 \\leq L_i, R_i \\leq i - 1$).\n\nIn the $V+2$-th line, you should print $P$, the index of the tree which contains $N$ nodes. ($0 \\leq P \\leq V-1$).\n\nIt is guaranteed that an answer always exists under the given condition.", "hint": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/2mpg8ofb.png)\n\nIllustration of output for $N = 4$ in the example.\n:::", "locale": "en", "translations": {"en": {"title": "[2018 KAIST RUN Fall] Fake Plastic Trees", "background": "", "description": "$\\textbf{Tree}$ is a recursive structure, which is either:\n\n- $\\textbf{Empty}$. Empty tree is denoted as $-1$ and has a size of 0. \n- $\\textbf{Non-empty}$. Non-empty tree $T$ is denoted as a pair of two trees $(T_1, T_2)$, where $T_1$ is called $\\textbf{left subtree}$ of $T$, and $T_2$ is called $\\textbf{right subtree}$ of $T$. If $T = (-1, -1)$, then we call such $T$ a $\\textbf{leaf}$. Leaf has a size of 1, and non-leaf has a size of $|T_1| + |T_2|$, where $|T_1|$ is the size of $T_1$, and $|T_2|$ is the size of $T_2$.\n\nA non-empty tree $T$ is a $\\textbf{Fake Plastic Tree}$, if the tree is $\\textit{balanced}$. Formally, Let $T = (T_1, T_2)$. If $|T_1| = |T_2|$ or $|T_1| = |T_2| + 1$ holds, then $T$ is a Fake Plastic Tree. \n\nIn computer science, trees are commonly used as a data structure, and they are stored in a memory. At first, there are no trees in the memory, and only an imaginary $\\textit{null pointer}$ exists (which corresponds to empty tree, $-1$). You can allocate a tree in the memory, by setting $T_1$ and $T_2$ as either a null pointer or a pointer of an existing tree. Then, the memory is extended by adding $T = (T_1, T_2)$ into its structure. Note that pointer can be described as a small integer, reducing the need for explicitly storing the whole tree.\n\nFormally, memory $M$ is an inductive structure, which at first contains only empty tree $-1$. ($M = \\{-1\\}$). You can expand the memory with following operation $M \\leftarrow M \\cup \\{(T_1, T_2)\\}$, where $T_1 \\in M, T_2 \\in M$. If a tree $T$ is inserted in $i$-th stage, then it has the $\\textbf{index}$ $i-1$. For a tree with index $i$, their subtrees can be represented as a pair of integer in range $[-1, i-1]$. \n\nYour task is to construct a memory $M$, which satisfies the following: \n\n- Every tree in $M$ is either empty or Fake Plastic Tree.\n- $M$ has at most 125 non-empty trees.\n- There exists a tree $T \\in M$, where $|T| = N$ holds. $N$ is an integer, and is given as an input.", "inputFormat": "The first line contains a single integer $T$, the number of test cases. ($1 \\leq T \\leq 2000$)\n\nIn the next $T$ lines, a single integer $N$ is given, which indicates the number of leaves your tree should contain. ($1 \\leq N \\leq 10^{18}$)", "outputFormat": "For each case, you should print $V + 2$ lines, where $V$ is the number of non-empty trees in $M$. ($1 \\leq V \\leq 125$).\n\nIn the first line, you should print single integer $V$. \n\nIn the next $V$ lines, you should print two space-separated integer $L_i, R_i$, which indicates the index of left subtree and right subtree for a tree with index $i$. ($-1 \\leq L_i, R_i \\leq i - 1$).\n\nIn the $V+2$-th line, you should print $P$, the index of the tree which contains $N$ nodes. ($0 \\leq P \\leq V-1$).\n\nIt is guaranteed that an answer always exists under the given condition.", "hint": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/2mpg8ofb.png)\n\nIllustration of output for $N = 4$ in the example.\n:::", "locale": "en"}, "zh-CN": {"title": "[2018 KAIST RUN Fall] Fake Plastic Trees", "background": "", "description": "**树** 是一种递归结构，它要么是：\n\n- **空树**。空树表示为 $-1$，大小为 $0$。\n- **非空树**。非空树 $T$ 表示为一对树 $(T_1, T_2)$，其中 $T_1$ 称为 $T$ 的 **左子树**，$T_2$ 称为 $T$ 的 **右子树**。如果 $T = (-1, -1)$，则称这样的 $T$ 为 **叶子**。叶子的大小为 $1$，非叶子树的大小为 $|T_1| + |T_2|$，其中 $|T_1|$ 是 $T_1$ 的大小，$|T_2|$ 是 $T_2$ 的大小。\n\n一棵非空树 $T$ 是 **虚假塑料树**，当且仅当该树是 **平衡的**。形式化地说，设 $T = (T_1, T_2)$。如果 $|T_1| = |T_2|$ 或 $|T_1| = |T_2| + 1$ 成立，则 $T$ 是虚假塑料树。\n\n在计算机科学中，树通常被用作数据结构，并存储在内存中。最初，内存中没有树，只存在一个想象中的 **空指针**（对应空树 $-1$）。你可以通过将 $T_1$ 和 $T_2$ 设置为空指针或指向现有树的指针来在内存中分配一棵树。然后，内存通过将 $T = (T_1, T_2)$ 添加到其结构中来扩展。注意，指针可以用小整数描述，减少了显式存储整棵树的需要。\n\n形式化地说，内存 $M$ 是一个归纳结构，最初只包含空树 $-1$（$M = \\{-1\\}$）。你可以通过以下操作扩展内存：$M \\leftarrow M \\cup \\{(T_1, T_2)\\}$，其中 $T_1 \\in M, T_2 \\in M$。如果一棵树 $T$ 在第 $i$ 阶段被插入，则它具有 **索引** $i-1$。对于索引为 $i$ 的树，它们的子树可以表示为范围在 $[-1, i-1]$ 内的一对整数。\n\n你的任务是构造一个内存 $M$，满足以下条件：\n\n- $M$ 中的每棵树要么是空树，要么是虚假塑料树。\n- $M$ 中最多有 $125$ 棵非空树。\n- 存在一棵树 $T \\in M$，满足 $|T| = N$。$N$ 是一个整数，作为输入给出。", "inputFormat": "第一行包含一个整数 $T$，表示测试用例的数量（$1 \\leq T \\leq 2000$）。\n\n接下来的 $T$ 行，每行给出一个整数 $N$，表示你的树应包含的叶子数量（$1 \\leq N \\leq 10^{18}$）。\n", "outputFormat": "对于每个测试用例，你应该输出 $V + 2$ 行，其中 $V$ 是 $M$ 中非空树的数量（$1 \\leq V \\leq 125$）。\n\n第一行输出一个整数 $V$。\n\n接下来的 $V$ 行，每行输出两个以空格分隔的整数 $L_i, R_i$，表示索引为 $i$ 的树的左子树和右子树的索引（$-1 \\leq L_i, R_i \\leq i - 1$）。\n\n第 $V+2$ 行输出 $P$，表示包含 $N$ 个节点的树的索引（$0 \\leq P \\leq V-1$）。\n\n保证在给定条件下总是存在答案。", "hint": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/2mpg8ofb.png)\n\n示例中 $N = 4$ 的输出图示。\n:::\n\n---\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14627", "type": "P", "difficulty": 0, "samples": [["5 0\n1 3 10 3 1", "4"], ["5 1\n1 3 10 3 1", "2"], ["12 0\n317 448 258 208 284 248 315 367 562 500 426 390", "1525"], ["12 2\n317 448 258 208 284 248 315 367 562 500 426 390", "1107"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "高校校赛"], "title": "[2018 KAIST RUN Fall] Fascination Street", "background": "", "description": "A street named $\\textit{Fascination Street}$ is divided into $N$ equal length of blocks. For each block $i$ ($1 \\leq i \\leq N$), it has block $i-1$ in its left side if $i > 1$, and block $i+1$ in its right side if $i < N$. \n\nUnlike its name, the street is infamous to be a dark and eerie place in the night. To solve this, Robert decided to install the streetlight for some of the blocks. The cost of installing a streetlight for $i$-th block is $W_i$, and the total cost is the sum of each installation cost. After installing, every block should either have a streetlight, or have a streetlight in it's left or right block. \n\nRobert also has some tricks to reduce the cost. Before installing the streetlight, Robert selects two distinct blocks $i$ and $j$, and exchange their position. After the operation, the cost of installation is exchanged. In other words, the operation simply swaps the value of $W_i$ and $W_j$. This operation have no cost, but Robert can only perform it at most $K$ times.\n\nNow, given the array $W$ and the maximum possible number of operations $K$, you should find the minimum cost of lighting the whole street.", "inputFormat": "The first line contains two space-separated integers $N, K$. $N$ is the number of blocks, and $K$ is the maximum possible number of operations. ($1 \\leq N \\leq 250000 , 0 \\leq K \\leq 9$)\n\nThe second line contains $N$ space-separated integers $W_1, W_2 \\cdots W_N$, where $W_i$ is the cost of installing a streetlight for $i$-th block. ($0 \\leq W_i \\leq 10^9$)", "outputFormat": "Print a single integer which contains the minimum cost of lighting the whole street.", "hint": "", "locale": "en", "translations": {"en": {"title": "[2018 KAIST RUN Fall] Fascination Street", "background": "", "description": "A street named $\\textit{Fascination Street}$ is divided into $N$ equal length of blocks. For each block $i$ ($1 \\leq i \\leq N$), it has block $i-1$ in its left side if $i > 1$, and block $i+1$ in its right side if $i < N$. \n\nUnlike its name, the street is infamous to be a dark and eerie place in the night. To solve this, Robert decided to install the streetlight for some of the blocks. The cost of installing a streetlight for $i$-th block is $W_i$, and the total cost is the sum of each installation cost. After installing, every block should either have a streetlight, or have a streetlight in it's left or right block. \n\nRobert also has some tricks to reduce the cost. Before installing the streetlight, Robert selects two distinct blocks $i$ and $j$, and exchange their position. After the operation, the cost of installation is exchanged. In other words, the operation simply swaps the value of $W_i$ and $W_j$. This operation have no cost, but Robert can only perform it at most $K$ times.\n\nNow, given the array $W$ and the maximum possible number of operations $K$, you should find the minimum cost of lighting the whole street.", "inputFormat": "The first line contains two space-separated integers $N, K$. $N$ is the number of blocks, and $K$ is the maximum possible number of operations. ($1 \\leq N \\leq 250000 , 0 \\leq K \\leq 9$)\n\nThe second line contains $N$ space-separated integers $W_1, W_2 \\cdots W_N$, where $W_i$ is the cost of installing a streetlight for $i$-th block. ($0 \\leq W_i \\leq 10^9$)", "outputFormat": "Print a single integer which contains the minimum cost of lighting the whole street.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[2018 KAIST RUN Fall] Fascination Street", "background": "", "description": "一条名为 **迷人街道** 的街道被划分为 $N$ 个长度相等的街区。对于每个街区 $i$（$1 \\leq i \\leq N$），如果 $i > 1$，则其左侧有街区 $i-1$；如果 $i < N$，则其右侧有街区 $i+1$。\n\n与其名字不同，这条街道在夜晚以黑暗和阴森著称。为了解决这个问题，Robert 决定在一些街区安装路灯。为第 $i$ 个街区安装路灯的成本是 $W_i$，总成本是每个安装成本的总和。安装后，每个街区要么自身有路灯，要么其左侧或右侧的街区有路灯。\n\nRobert 还有一些技巧来降低成本。在安装路灯之前，Robert 选择两个不同的街区 $i$ 和 $j$，并交换它们的位置。操作后，安装成本也会交换。换句话说，该操作只是交换 $W_i$ 和 $W_j$ 的值。这个操作没有成本，但 Robert 最多只能执行 $K$ 次。\n\n现在，给定数组 $W$ 和最大可能的操作次数 $K$，你需要找到照亮整条街道的最小成本。", "inputFormat": "第一行包含两个以空格分隔的整数 $N, K$。$N$ 是街区的数量，$K$ 是最大可能的操作次数（$1 \\leq N \\leq 250000$，$0 \\leq K \\leq 9$）。\n\n第二行包含 $N$ 个以空格分隔的整数 $W_1, W_2 \\cdots W_N$，其中 $W_i$ 是为第 $i$ 个街区安装路灯的成本（$0 \\leq W_i \\leq 10^9$）。", "outputFormat": "输出一个整数，表示照亮整条街道的最小成本。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14628", "type": "P", "difficulty": 3, "samples": [["5 8 3 6", "16"], ["2018 2019 2018 2019", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "最大公约数 gcd", "高校校赛"], "title": "[2018 KAIST RUN Fall] Fractions", "background": "", "description": "About 44 days are left before $\\textit{College Scholastic Ability Test}$ is held. This exam aims to measure students' achievement of National Curriculum standards and scholastic ability required for college education. (<http://www.kice.re.kr/sub/info.do?m=0205&s=english>)\n\nOne of the subjects covered by this test is Mathematics, which consists of 21 multiple choice questions and 9 short-answer questions. The answer of each short-answer question is guaranteed to be a $\\textit{unique positive integer below 1\\,000}$, as you can see from the answer sheet below.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ih4k5me.png)\n:::\n\nHowever, the organizers might want to give students short-answer questions with non-integer answers, such as $2\\sqrt{3}$ or $\\frac{5}{3}$. Usually, the workaround is to write the answer in a canonical form, and then sum up all the integers inside that form and ask students to write that number instead.\n\nIn particular, when the answer is a positive rational number $\\frac{a}{b}$, the organizers usually ask students to reduce it and sum up the numerator and the denominator of the reduced fraction. For example, when the answer is $\\frac{18}{10}$, the student should reduce it to $\\frac{9}{5}$ and write the final answer as $9 + 5 = 14$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mp3dql8e.png)\n:::\n\nHowever, when the answer is $\\frac{521}{500}$, the reduced fraction is also $\\frac{521}{500}$, so the student should write the final answer as $521 + 500 = 1021$. But this shouldn't happen, since all the answers for the short-answer questions are below 1\\,000. To avoid this situation, the organizers should make sure that after reducing the fraction, the sum of the numerator and the denominator shouldn't exceed $999$. Let's call such fractions as $\\textit{Suneung Fractions}$. For example, $\\frac{1996}{2}$ and $\\frac{18}{10}$ are $\\textit{Suneung fractions}$, while $\\frac{1998}{2}$ and $\\frac{521}{500}$ are not.\n\nSuppose that, this year, one of the organizers wrote a problem, and the answer to that problem is $\\frac{x}{y}$. Since the problem is not finalized yet, the only thing we know is $A \\le x \\le B$ and $C \\le y \\le D$ holds, for given $A, B, C, D$. The organizers want to know, among all the pairs $(x, y)$, how many of $\\frac{x}{y}$ is a $\\textit{Suneung fraction}$. Write a program that counts this number.", "inputFormat": "The first and only line contains four space-separated integers $A, B, C$ and $D$ ($1 \\le A \\le B \\le 10^{12}$, $1 \\le C \\le D \\le 10^{12}$)", "outputFormat": "Print the number of integral pairs $(x, y)$ ($A \\le x \\le B$, $C \\le y \\le D$), where $\\frac{x}{y}$ is a $\\textit{Suneung fraction}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[2018 KAIST RUN Fall] Fractions", "background": "", "description": "About 44 days are left before $\\textit{College Scholastic Ability Test}$ is held. This exam aims to measure students' achievement of National Curriculum standards and scholastic ability required for college education. (<http://www.kice.re.kr/sub/info.do?m=0205&s=english>)\n\nOne of the subjects covered by this test is Mathematics, which consists of 21 multiple choice questions and 9 short-answer questions. The answer of each short-answer question is guaranteed to be a $\\textit{unique positive integer below 1\\,000}$, as you can see from the answer sheet below.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ih4k5me.png)\n:::\n\nHowever, the organizers might want to give students short-answer questions with non-integer answers, such as $2\\sqrt{3}$ or $\\frac{5}{3}$. Usually, the workaround is to write the answer in a canonical form, and then sum up all the integers inside that form and ask students to write that number instead.\n\nIn particular, when the answer is a positive rational number $\\frac{a}{b}$, the organizers usually ask students to reduce it and sum up the numerator and the denominator of the reduced fraction. For example, when the answer is $\\frac{18}{10}$, the student should reduce it to $\\frac{9}{5}$ and write the final answer as $9 + 5 = 14$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mp3dql8e.png)\n:::\n\nHowever, when the answer is $\\frac{521}{500}$, the reduced fraction is also $\\frac{521}{500}$, so the student should write the final answer as $521 + 500 = 1021$. But this shouldn't happen, since all the answers for the short-answer questions are below 1\\,000. To avoid this situation, the organizers should make sure that after reducing the fraction, the sum of the numerator and the denominator shouldn't exceed $999$. Let's call such fractions as $\\textit{Suneung Fractions}$. For example, $\\frac{1996}{2}$ and $\\frac{18}{10}$ are $\\textit{Suneung fractions}$, while $\\frac{1998}{2}$ and $\\frac{521}{500}$ are not.\n\nSuppose that, this year, one of the organizers wrote a problem, and the answer to that problem is $\\frac{x}{y}$. Since the problem is not finalized yet, the only thing we know is $A \\le x \\le B$ and $C \\le y \\le D$ holds, for given $A, B, C, D$. The organizers want to know, among all the pairs $(x, y)$, how many of $\\frac{x}{y}$ is a $\\textit{Suneung fraction}$. Write a program that counts this number.", "inputFormat": "The first and only line contains four space-separated integers $A, B, C$ and $D$ ($1 \\le A \\le B \\le 10^{12}$, $1 \\le C \\le D \\le 10^{12}$)", "outputFormat": "Print the number of integral pairs $(x, y)$ ($A \\le x \\le B$, $C \\le y \\le D$), where $\\frac{x}{y}$ is a $\\textit{Suneung fraction}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[2018 KAIST RUN Fall] Fractions", "background": "", "description": "距离 **大学修学能力考试**（College Scholastic Ability Test）举行还有大约 44 天。该考试旨在衡量学生对国家课程标准的掌握程度以及大学教育所需的学术能力。（<http://www.kice.re.kr/sub/info.do?m=0205&s=english>）\n\n该考试涵盖的科目之一是数学，由 21 道选择题和 9 道简答题组成。每道简答题的答案保证是 **小于 1,000 的唯一正整数**，如下面的答题卡所示。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ih4k5me.png)\n:::\n\n然而，出题人可能希望给学生提供非整数答案的简答题，例如 $2\\sqrt{3}$ 或 $\\frac{5}{3}$。通常的解决方法是将其写成规范形式，然后将该形式中的所有整数相加，并要求学生填写该数字。\n\n特别地，当答案是正有理数 $\\frac{a}{b}$ 时，出题人通常要求学生将其约分，并将约分后的分子和分母相加。例如，当答案是 $\\frac{18}{10}$ 时，学生应将其约分为 $\\frac{9}{5}$，并填写最终答案 $9 + 5 = 14$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mp3dql8e.png)\n:::\n\n然而，当答案是 $\\frac{521}{500}$ 时，约分后仍为 $\\frac{521}{500}$，因此学生应填写最终答案 $521 + 500 = 1021$。但这不应发生，因为所有简答题的答案都应小于 1,000。为避免这种情况，出题人应确保在约分后，分子和分母之和不超过 $999$。我们称这样的分数为 **修能分数**（Suneung Fractions）。例如，$\\frac{1996}{2}$ 和 $\\frac{18}{10}$ 是 **修能分数**，而 $\\frac{1998}{2}$ 和 $\\frac{521}{500}$ 不是。\n\n假设今年有一位出题人编写了一道题，该题的答案是 $\\frac{x}{y}$。由于题目尚未最终确定，我们仅知道对于给定的 $A, B, C, D$，有 $A \\le x \\le B$ 和 $C \\le y \\le D$ 成立。出题人想知道，在所有 $(x, y)$ 对中，有多少个 $\\frac{x}{y}$ 是 **修能分数**。请编写一个程序来计算这个数量。", "inputFormat": "第一行也是唯一一行包含四个以空格分隔的整数 $A, B, C$ 和 $D$（$1 \\le A \\le B \\le 10^{12}$，$1 \\le C \\le D \\le 10^{12}$）。", "outputFormat": "输出整数对 $(x, y)$（$A \\le x \\le B$，$C \\le y \\le D$）的数量，其中 $\\frac{x}{y}$ 是 **修能分数**。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14629", "type": "P", "difficulty": 0, "samples": [["2\n3\n5", "First\nSecond"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "高校校赛"], "title": "[2018 KAIST RUN Fall] Game on Plane", "background": "", "description": "You are given $N$ points on a plane. These points are precisely the set of vertices of some regular $N$-gon. Koosaga, an extreme villain, is challenging you with a game using these points. You and Koosaga alternatively take turns, and in each turn, the player\n\n- chooses two of the given points, then\n- draws the line segment connecting the two chosen points.\n\nAlso, the newly drawn line segment must not intersect with any of the previously drawn line segments in the interior. It is possible for two segments to meet at their endpoints. If at any point of the game, there exists a convex polygon consisting of the drawn line segments, the game ends and the last player who made the move wins.\n\nGiven the integer $N$, Koosaga is letting you decide who will move first. Your task is decide whether you need to move first or the second so that you can win regardless of Koosaga's moves.", "inputFormat": "The input consists of many test cases. The first line contains an integer $T$ ($1\\leq T\\leq 5000$), the number of test cases. Each of the following $T$ test cases is consisted of one line containing the integer $N$ ($3\\leq N\\leq 5000$).", "outputFormat": "For each test case, print one line containing the string $\\texttt{First}$ if you need to move first or $\\texttt{Second}$ if you need to move second so that you can win regardless of Koosaga's moves.", "hint": "", "locale": "en", "translations": {"en": {"title": "[2018 KAIST RUN Fall] Game on Plane", "background": "", "description": "You are given $N$ points on a plane. These points are precisely the set of vertices of some regular $N$-gon. Koosaga, an extreme villain, is challenging you with a game using these points. You and Koosaga alternatively take turns, and in each turn, the player\n\n- chooses two of the given points, then\n- draws the line segment connecting the two chosen points.\n\nAlso, the newly drawn line segment must not intersect with any of the previously drawn line segments in the interior. It is possible for two segments to meet at their endpoints. If at any point of the game, there exists a convex polygon consisting of the drawn line segments, the game ends and the last player who made the move wins.\n\nGiven the integer $N$, Koosaga is letting you decide who will move first. Your task is decide whether you need to move first or the second so that you can win regardless of Koosaga's moves.", "inputFormat": "The input consists of many test cases. The first line contains an integer $T$ ($1\\leq T\\leq 5000$), the number of test cases. Each of the following $T$ test cases is consisted of one line containing the integer $N$ ($3\\leq N\\leq 5000$).", "outputFormat": "For each test case, print one line containing the string $\\texttt{First}$ if you need to move first or $\\texttt{Second}$ if you need to move second so that you can win regardless of Koosaga's moves.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[2018 KAIST RUN Fall] Game on Plane", "background": "", "description": "给定平面上的 $N$ 个点。这些点恰好构成某个正 $N$ 边形的顶点集。超级反派 Koosaga 正在用这些点向你发起一个游戏挑战。你和 Koosaga 轮流进行操作，在每一轮中，玩家需要：\n\n- 选择给定的两个点，然后\n- 绘制连接这两个点的线段。\n\n同时，新绘制的线段不能在内部与任何先前绘制的线段相交。允许两条线段在端点处相交。如果在游戏的任何时刻，绘制的线段构成了一个凸多边形，则游戏结束，最后进行操作的玩家获胜。\n\n给定整数 $N$，Koosaga 让你决定谁先行动。你的任务是判断你需要先手还是后手，以便无论 Koosaga 如何操作，你都能获胜。", "inputFormat": "输入包含多个测试用例。第一行包含一个整数 $T$（$1 \\leq T \\leq 5000$），表示测试用例的数量。接下来的 $T$ 行每行包含一个整数 $N$（$3 \\leq N \\leq 5000$），表示每个测试用例的输入。", "outputFormat": "对于每个测试用例，输出一行字符串：如果你需要先手才能无论 Koosaga 如何操作都获胜，则输出 `First`；如果你需要后手才能无论 Koosaga 如何操作都获胜，则输出 `Second`。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14630", "type": "P", "difficulty": 0, "samples": [["9\n7 4 3 5 4 2 5 1 2\n42 45", "12 12 14 15"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "高校校赛"], "title": "[2018 KAIST RUN Fall] Histogram Sequence", "background": "", "description": "A histogram is a polygon made by aligning $N$ adjacent rectangles that share a common base line. Each rectangle is called a $\\textit{bar}$. The $i$-th bar from the left has width 1 and height $H_i$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/dfx3nshv.png)\n\nFigure: This picture depicts a case when $N = 9$ and $H = [7,4,3,5,4,2,5,1,2]$.\n:::\n\nOne day, you wanted to find the area of the largest rectangle contained in the given histogram. What you did was to make a list of integers $A$ by the following procedure:\n\n- For each $1 \\le i \\le j \\le N$, calculate the largest area of the rectangle contained in the histogram, where the rectangle's base line coincides with the base line of the $i, i+1, \\cdots, j-1, j$-th bar. Add the area to the list $A$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mtpxpz4u.png)\n\nFigure: This picture depicts a case when $i = 3$ and $j = 5$. The area is 9.\n:::\n\nThe length of the list $A$ is exactly $\\frac{N(N+1)}{2}$ since you chose each pair $(i, j)$ exactly once.  To make your life easier, you sorted the list $A$ in non-decreasing order. Now, to find the largest area of the rectangle contained in the histogram, you just need to read the last element of $A$, $A_{N(N+1)/2}$.\n\nHowever, you are not satisfied with this at all, so I decided to let you compute some part of the list $A$. You have to write a program that, given two indices $L$ and $R$ ($L \\le R$), calculate the values $A_{L..R}$, i.e. $A_{L}, A_{L+1}, \\cdots, A_{R-1}, A_{R}$.", "inputFormat": "The first line of the input contains an integer $N$ ($1 \\le N \\le 300\\,000$) which is the number of bars in the histogram.\n\nThe next line contains $N$ space-separated positive integers $H_1, H_2, \\cdots, H_N$ ($1 \\le H_i \\le 10^9$), where $H_i$ is the height of the $i$-th bar.\n\nThe last line contains two integers $L$ and $R$ ($1 \\le L \\le R \\le \\frac{N(N+1)}{2}$, $R - L + 1 \\le 300\\,000$).", "outputFormat": "Print $R - L + 1$ integers. The $j$-th ($1 \\le j \\le R-L+1$) of them should be the $(L+j-1)$-th element of the list $A$, i.e. $A_{L+j-1}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[2018 KAIST RUN Fall] Histogram Sequence", "background": "", "description": "A histogram is a polygon made by aligning $N$ adjacent rectangles that share a common base line. Each rectangle is called a $\\textit{bar}$. The $i$-th bar from the left has width 1 and height $H_i$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/dfx3nshv.png)\n\nFigure: This picture depicts a case when $N = 9$ and $H = [7,4,3,5,4,2,5,1,2]$.\n:::\n\nOne day, you wanted to find the area of the largest rectangle contained in the given histogram. What you did was to make a list of integers $A$ by the following procedure:\n\n- For each $1 \\le i \\le j \\le N$, calculate the largest area of the rectangle contained in the histogram, where the rectangle's base line coincides with the base line of the $i, i+1, \\cdots, j-1, j$-th bar. Add the area to the list $A$.\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mtpxpz4u.png)\n\nFigure: This picture depicts a case when $i = 3$ and $j = 5$. The area is 9.\n:::\n\nThe length of the list $A$ is exactly $\\frac{N(N+1)}{2}$ since you chose each pair $(i, j)$ exactly once.  To make your life easier, you sorted the list $A$ in non-decreasing order. Now, to find the largest area of the rectangle contained in the histogram, you just need to read the last element of $A$, $A_{N(N+1)/2}$.\n\nHowever, you are not satisfied with this at all, so I decided to let you compute some part of the list $A$. You have to write a program that, given two indices $L$ and $R$ ($L \\le R$), calculate the values $A_{L..R}$, i.e. $A_{L}, A_{L+1}, \\cdots, A_{R-1}, A_{R}$.", "inputFormat": "The first line of the input contains an integer $N$ ($1 \\le N \\le 300\\,000$) which is the number of bars in the histogram.\n\nThe next line contains $N$ space-separated positive integers $H_1, H_2, \\cdots, H_N$ ($1 \\le H_i \\le 10^9$), where $H_i$ is the height of the $i$-th bar.\n\nThe last line contains two integers $L$ and $R$ ($1 \\le L \\le R \\le \\frac{N(N+1)}{2}$, $R - L + 1 \\le 300\\,000$).", "outputFormat": "Print $R - L + 1$ integers. The $j$-th ($1 \\le j \\le R-L+1$) of them should be the $(L+j-1)$-th element of the list $A$, i.e. $A_{L+j-1}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[2018 KAIST RUN Fall] Histogram Sequence", "background": "", "description": "直方图是由 $N$ 个相邻矩形沿共同基线对齐形成的多边形。每个矩形称为一个 **条柱**。从左数第 $i$ 个条柱的宽度为 $1$，高度为 $H_i$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/dfx3nshv.png)\n\n图示：此图描绘了 $N = 9$ 且 $H = [7,4,3,5,4,2,5,1,2]$ 的情况。\n:::\n\n有一天，你想找出给定直方图中包含的最大矩形的面积。你通过以下步骤创建了一个整数列表 $A$：\n\n- 对于每个 $1 \\le i \\le j \\le N$，计算直方图中包含的最大矩形面积，其中矩形的基线与第 $i, i+1, \\cdots, j-1, j$ 个条柱的基线重合。将该面积添加到列表 $A$ 中。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/mtpxpz4u.png)\n\n图示：此图描绘了 $i = 3$ 且 $j = 5$ 的情况。面积为 $9$。\n:::\n\n列表 $A$ 的长度恰好为 $\\frac{N(N+1)}{2}$，因为你恰好选择了每对 $(i, j)$ 一次。为了使生活更轻松，你将列表 $A$ 按非递减顺序排序。现在，要找到直方图中包含的最大矩形面积，你只需读取 $A$ 的最后一个元素 $A_{N(N+1)/2}$。\n\n然而，你对此并不满意，所以我决定让你计算列表 $A$ 的某一部分。你需要编写一个程序，在给定两个索引 $L$ 和 $R$（$L \\le R$）的情况下，计算 $A_{L..R}$ 的值，即 $A_{L}, A_{L+1}, \\cdots, A_{R-1}, A_{R}$。\n", "inputFormat": "输入的第一行包含一个整数 $N$（$1 \\le N \\le 300,000$），表示直方图中条柱的数量。\n\n下一行包含 $N$ 个以空格分隔的正整数 $H_1, H_2, \\cdots, H_N$（$1 \\le H_i \\le 10^9$），其中 $H_i$ 是第 $i$ 个条柱的高度。\n\n最后一行包含两个整数 $L$ 和 $R$（$1 \\le L \\le R \\le \\frac{N(N+1)}{2}$，$R - L + 1 \\le 300,000$）。\n", "outputFormat": "输出 $R - L + 1$ 个整数。其中第 $j$ 个（$1 \\le j \\le R-L+1$）应为列表 $A$ 的第 $(L+j-1)$ 个元素，即 $A_{L+j-1}$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P14631", "type": "P", "difficulty": 1, "samples": [["abc\n3", "NO"], ["abba\n1", "YES"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["字符串", "2018", "高校校赛"], "title": "[2018 KAIST RUN Fall] Repetitive Palindrome", "background": "", "description": "You are given a string $s$ consisting of lowercase alphabets, and an integer $k$.\n\nMake a new string $t$ by concatenating $k$ copies of $s$. Determine whether $t$ is a palindrome, e.g. is the same backward as forward.", "inputFormat": "The first line contains a string $s$ consisting of lowercase alphabets. ($1 \\le |s| \\le 250000$)\n\nThe second line contains an integer $k$. ($1 \\le k \\le 10^{18}$)", "outputFormat": "If $t$ is a palindrome, print $\\texttt{YES}$. If not, print $\\texttt{NO}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[2018 KAIST RUN Fall] Repetitive Palindrome", "background": "", "description": "You are given a string $s$ consisting of lowercase alphabets, and an integer $k$.\n\nMake a new string $t$ by concatenating $k$ copies of $s$. Determine whether $t$ is a palindrome, e.g. is the same backward as forward.", "inputFormat": "The first line contains a string $s$ consisting of lowercase alphabets. ($1 \\le |s| \\le 250000$)\n\nThe second line contains an integer $k$. ($1 \\le k \\le 10^{18}$)", "outputFormat": "If $t$ is a palindrome, print $\\texttt{YES}$. If not, print $\\texttt{NO}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[2018 KAIST RUN Fall] Repetitive Palindrome", "background": "", "description": "给定一个由小写字母组成的字符串 $s$ 和一个整数 $k$。\n\n将 $s$ 重复 $k$ 次连接成一个新字符串 $t$。判断 $t$ 是否是回文串，即正着读和反着读是否相同。\n", "inputFormat": "第一行包含一个由小写字母组成的字符串 $s$（$1 \\le |s| \\le 250000$）。\n\n第二行包含一个整数 $k$（$1 \\le k \\le 10^{18}$）。", "outputFormat": "如果 $t$ 是回文串，输出 `YES`；否则输出 `NO`。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14632", "type": "P", "difficulty": 0, "samples": [["2\n1 4 6 7\n7", "5"], ["2\n3 4 5 7\n7", "0"], ["3\n4 9 12 13 14 16\n15", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "高校校赛"], "title": "[2018 KAIST RUN Fall] Rising Sun", "background": "", "description": "Joon has a midterm exam tomorrow, but he hasn't studied anything. So he decided to stay up all night to study. He promised himself that he will not stop studying before the sun rises.\n\nJoon's house is in some mountains. For convenience, let's say that Joon is living in a 2-dimensional coordinate system. The mountains are in the region $y\\geq 0$, starting at $x=a_0$, and the boundary of them consists of $2n$ line segments parallel to either $y=x$ or $y=-x$.\n\nMore precisely, the boundary of the mountains can be described by $(2n-1)$ additional integers, where the $i$th number $a_i$ of them is the $x$-coordinate of the $i$th cusp of the mountains. The boundary line starts at $(a_0, 0)$, proceeds parallel to $y=x$ until its $x$-coordinate reaches $a_1$, then proceeds parallel to $y=-x$ until its $x$-coordinate reaches $a_2$, and so on. After the last step, the line proceeds parallel to $y=-x$ until it meets the $x$-axis.\n\nThe interior of the mountains is the region below the boundary and above the $x$-axis. Thus, the interior and the boundary are disjoint.\n\nAt some point between $x=a_0$ and $x=a_{2n-1}$, there is Joon's house on the boundary of the mountains. The size of his house is neglectable compared to the mountains.\n\nCurrently, the sun is at the origin and it rises vertically ($+y$ direction), 1 per minute. Joon can see the sun if the interior of the mountains does not intersect the straight line segment connecting Joon's house and the sun. Joon is completely exhausted and wants to know when can he stop studying. But as you may expect, he is out of his mind, so he cannot do such difficult math. Help him!", "inputFormat": "The first line of the input contains an integer $n$ ($1\\leq n\\leq 10^3$).\n\nThe next line contains $2n$ integers, the $i$th of which is the integer $a_{i-1}$ ($1\\leq a_0<\\cdots<a_{2n-1}\\leq 10^6$).\n\nThe last line contains an integer $x$, the $x$-coordinate of Joon's house ($a_0\\leq x\\leq a_{2n-1}$).\n\nIt is guaranteed that the boundary of the mountains is in the region $y\\geq 0$.", "outputFormat": "Print exactly one integer $m$, the smallest integer such that Joon can see the sun after $m$ minutes.", "hint": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/dws5koz6.png)\n\nIllustration of the first example.\n:::", "locale": "en", "translations": {"en": {"title": "[2018 KAIST RUN Fall] Rising Sun", "background": "", "description": "Joon has a midterm exam tomorrow, but he hasn't studied anything. So he decided to stay up all night to study. He promised himself that he will not stop studying before the sun rises.\n\nJoon's house is in some mountains. For convenience, let's say that Joon is living in a 2-dimensional coordinate system. The mountains are in the region $y\\geq 0$, starting at $x=a_0$, and the boundary of them consists of $2n$ line segments parallel to either $y=x$ or $y=-x$.\n\nMore precisely, the boundary of the mountains can be described by $(2n-1)$ additional integers, where the $i$th number $a_i$ of them is the $x$-coordinate of the $i$th cusp of the mountains. The boundary line starts at $(a_0, 0)$, proceeds parallel to $y=x$ until its $x$-coordinate reaches $a_1$, then proceeds parallel to $y=-x$ until its $x$-coordinate reaches $a_2$, and so on. After the last step, the line proceeds parallel to $y=-x$ until it meets the $x$-axis.\n\nThe interior of the mountains is the region below the boundary and above the $x$-axis. Thus, the interior and the boundary are disjoint.\n\nAt some point between $x=a_0$ and $x=a_{2n-1}$, there is Joon's house on the boundary of the mountains. The size of his house is neglectable compared to the mountains.\n\nCurrently, the sun is at the origin and it rises vertically ($+y$ direction), 1 per minute. Joon can see the sun if the interior of the mountains does not intersect the straight line segment connecting Joon's house and the sun. Joon is completely exhausted and wants to know when can he stop studying. But as you may expect, he is out of his mind, so he cannot do such difficult math. Help him!", "inputFormat": "The first line of the input contains an integer $n$ ($1\\leq n\\leq 10^3$).\n\nThe next line contains $2n$ integers, the $i$th of which is the integer $a_{i-1}$ ($1\\leq a_0<\\cdots<a_{2n-1}\\leq 10^6$).\n\nThe last line contains an integer $x$, the $x$-coordinate of Joon's house ($a_0\\leq x\\leq a_{2n-1}$).\n\nIt is guaranteed that the boundary of the mountains is in the region $y\\geq 0$.", "outputFormat": "Print exactly one integer $m$, the smallest integer such that Joon can see the sun after $m$ minutes.", "hint": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/dws5koz6.png)\n\nIllustration of the first example.\n:::", "locale": "en"}, "zh-CN": {"title": "[2018 KAIST RUN Fall] Rising Sun", "background": "", "description": "Joon 明天有期中考试，但他什么都没学。因此他决定通宵学习。他承诺自己在太阳升起之前不会停止学习。\n\nJoon 的家在山区。为方便起见，假设 Joon 生活在一个二维坐标系中。山区位于 $y \\geq 0$ 的区域，起始于 $x = a_0$，其边界由 $2n$ 条分别平行于 $y = x$ 或 $y = -x$ 的线段组成。\n\n更精确地说，山区的边界可以用 $(2n-1)$ 个额外的整数描述，其中第 $i$ 个数 $a_i$ 是山区第 $i$ 个尖顶的 $x$ 坐标。边界线从 $(a_0, 0)$ 开始，平行于 $y = x$ 延伸直到其 $x$ 坐标达到 $a_1$，然后平行于 $y = -x$ 延伸直到其 $x$ 坐标达到 $a_2$，依此类推。在最后一步之后，边界线平行于 $y = -x$ 延伸直到与 $x$ 轴相交。\n\n山区的内部是边界下方且 $x$ 轴上方的区域。因此，内部与边界不相交。\n\n在 $x = a_0$ 和 $x = a_{2n-1}$ 之间的某处，Joon 的家位于山区的边界上。与山区相比，他家的尺寸可以忽略不计。\n\n目前，太阳位于原点，并以每分钟 $1$ 个单位的速度垂直（$+y$ 方向）上升。如果山区的内部不与连接 Joon 家和太阳的直线段相交，则 Joon 可以看到太阳。Joon 已经完全精疲力尽，想知道他何时可以停止学习。但如你所料，他已经神志不清，无法完成如此困难的数学计算。请帮助他！", "inputFormat": "输入的第一行包含一个整数 $n$（$1 \\leq n \\leq 10^3$）。\n\n下一行包含 $2n$ 个整数，其中第 $i$ 个是整数 $a_{i-1}$（$1 \\leq a_0 < \\cdots < a_{2n-1} \\leq 10^6$）。\n\n最后一行包含一个整数 $x$，表示 Joon 家的 $x$ 坐标（$a_0 \\leq x \\leq a_{2n-1}$）。\n\n保证山区的边界位于 $y \\geq 0$ 的区域。", "outputFormat": "输出恰好一个整数 $m$，表示 Joon 在 $m$ 分钟后可以看到太阳的最小整数。\n", "hint": ":::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/dws5koz6.png)\n\n第一个示例的图示。\n:::\n\n---\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14633", "type": "P", "difficulty": 6, "samples": [["5 1\n1 2 2\n2 3 3\n2 4 10\n4 5 6", "10"], ["5 2\n1 2 2\n2 3 3\n2 4 10\n4 5 6", "9"], ["5 3\n1 2 2\n2 3 3\n2 4 10\n4 5 6", "Impossible\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "凸完全单调性（wqs 二分）", "高校校赛"], "title": "[2018 KAIST RUN Fall] Utilitarianism", "background": "", "description": "In RUN-land, there are $n$ cities numbered $1$ to $n$. Some pairs of cities are connected by a bidirectional road. It happens that there are $n-1$ roads in total and that for any two cities, there is a unique path from one to the other. Also, each road is assigned an integer called the $\\textit{value}$.\n\nToday, to honor the $k$ co-founders of RUN-land, Alex, the king of RUN-land, has decided to choose $k$ different roads and give one road to each of the $k$ co-founders. To prevent unnecessary conflicts, there should be no city that is connected to more than one chosen roads.\n\nIn this process, Alex, the king of RUN-land, does not care about who gets what road. Instead, Alex, the king of RUN-land, is only interested in the sum of the values of the $k$ chosen roads. Your task is to choose the roads to maximize this sum.", "inputFormat": "The first line contains two integers $n$ and $k$ ($2\\leq n\\leq250000$,$1\\leq k\\leq n-1$), which are the number of cities in RUN-land, and the number of roads to choose. Each of the next $n-1$ lines contains three integers $u,v,c$ ($1\\leq u,v\\leq n$, $-10^6\\leq c\\leq 10^6$), which means that the city $u$ and the city $v$ are directly connected with a bidirectional road with value $c$.", "outputFormat": "If there is no way to choose $k$ roads to satisfy the conditions, print $\\tt{Impossible}$. Otherwise, print one integer, the maximum sum of the values of the $k$ chosen roads.", "hint": "", "locale": "en", "translations": {"en": {"title": "[2018 KAIST RUN Fall] Utilitarianism", "background": "", "description": "In RUN-land, there are $n$ cities numbered $1$ to $n$. Some pairs of cities are connected by a bidirectional road. It happens that there are $n-1$ roads in total and that for any two cities, there is a unique path from one to the other. Also, each road is assigned an integer called the $\\textit{value}$.\n\nToday, to honor the $k$ co-founders of RUN-land, Alex, the king of RUN-land, has decided to choose $k$ different roads and give one road to each of the $k$ co-founders. To prevent unnecessary conflicts, there should be no city that is connected to more than one chosen roads.\n\nIn this process, Alex, the king of RUN-land, does not care about who gets what road. Instead, Alex, the king of RUN-land, is only interested in the sum of the values of the $k$ chosen roads. Your task is to choose the roads to maximize this sum.", "inputFormat": "The first line contains two integers $n$ and $k$ ($2\\leq n\\leq250000$,$1\\leq k\\leq n-1$), which are the number of cities in RUN-land, and the number of roads to choose. Each of the next $n-1$ lines contains three integers $u,v,c$ ($1\\leq u,v\\leq n$, $-10^6\\leq c\\leq 10^6$), which means that the city $u$ and the city $v$ are directly connected with a bidirectional road with value $c$.", "outputFormat": "If there is no way to choose $k$ roads to satisfy the conditions, print $\\tt{Impossible}$. Otherwise, print one integer, the maximum sum of the values of the $k$ chosen roads.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[2018 KAIST RUN Fall] Utilitarianism", "background": "", "description": "在 RUN 国，有 $n$ 个编号为 $1$ 到 $n$ 的城市。一些城市对之间由双向道路连接。恰好总共有 $n-1$ 条道路，并且对于任意两个城市，都存在唯一的路径连接它们。此外，每条道路都被分配了一个整数，称为 **价值**。\n\n今天，为了表彰 RUN 国的 $k$ 位共同创始人，RUN 国的国王 Alex 决定选择 $k$ 条不同的道路，并将每条道路授予一位共同创始人。为避免不必要的冲突，任何城市都不能连接到超过一条被选中的道路。\n\n在这个过程中，RUN 国的国王 Alex 并不关心谁得到哪条道路。相反，Alex 国王只关心这 $k$ 条被选中道路的价值之和。你的任务是选择道路以最大化这个总和。", "inputFormat": "第一行包含两个整数 $n$ 和 $k$（$2 \\leq n \\leq 250000$，$1 \\leq k \\leq n-1$），分别表示 RUN 国的城市数量和要选择的道路数量。接下来的 $n-1$ 行每行包含三个整数 $u, v, c$（$1 \\leq u, v \\leq n$，$-10^6 \\leq c \\leq 10^6$），表示城市 $u$ 和城市 $v$ 之间由一条价值为 $c$ 的双向道路直接连接。\n", "outputFormat": "如果无法选择 $k$ 条道路满足条件，输出 `Impossible`。否则，输出一个整数，表示被选中的 $k$ 条道路的最大价值总和。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14634", "type": "P", "difficulty": 2, "samples": [["4 3\n-5 0\n0 5\n3 4\n1 -6\n-2 2\n0 0\n2 2", "LINE 1 2\nPOINT\nREGION 3"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2018", "高校校赛"], "title": "[2018 KAIST RUN Fall] Voronoi Diagram Returns", "background": "", "description": ":::align{center}\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/umujsipf.png)\n\nVoronoi Diagram of size 4.\n:::\n\nIn the 2-dimensional Cartesian coordinate system, we define the $\\textbf{Voronoi Diagram}$ of a non-empty \n set of points $S$, as a diagram that divides the plane by the criteria \"which point in the set $S$ is closest in this location?\". More precisely, the Voronoi diagram of a given non-empty point set $\\{P_1, P_2, \\cdots, P_n\\}$ is a collection of $\\textbf{regions}$: A point $K$ is included in region $i$ if and only if $d(P_i, K) \\le d(P_j, K)$ holds for all $1 \\le j \\le n$, where $d(X, Y)$ denotes the Euclidean distance between point $X$ and $Y$.\n\nFor example, in the picture above, every location over the plane is colored by the closest point with such location. The points which belongs to a single region is colored by a light color indicating a region, and the points which belongs to more than one region forms lines and points colored black.\n\nThere is an algorithm which computes the Voronoi Diagram in $O(n \\log(n))$, but it is infamous to be very complicated and hard. In fact, we are lenient problem setters, so we set $n \\leq 2000$, which means you can solve this task with slower Voronoi Diagram algorithms!\n\nIn this task, you should solve the $\\textbf{point query problem}$ in Voronoi diagram: in the Voronoi diagram constructed with the set of points $\\{P_1, P_2, \\cdots, P_n\\}$, you should determine which region(s) the point belongs in. More precisely, you will be given $q$ queries of points. For each query point, you should determine the following:\n\n- If it's not included in any region, output $\\texttt{NONE}$.\n- If it's included in exactly one region, output $\\texttt{REGION X}$, where $\\texttt{X}$ is the index of such region.\n- If it's included in exactly two regions, output $\\texttt{LINE X Y}$, where $\\texttt{X}$ and $\\texttt{Y}$ ($\\texttt{X}$ $<$ $\\texttt{Y}$) are the indices of such two regions.\n- If it's included in three or more regions, output $\\texttt{POINT}$.", "inputFormat": "In the first line, the number of points consisting Voronoi diagram $n$, and the number of queries $q$ are given. ($3 \\le n \\le 2\\ 000, 1 \\le q \\le 250\\ 000$) \n\nIn the $i$th line of next $n$ lines, two integers indicating $x$ and $y$ co-ordinate of $P_i$ are given. These are the points consisting the Voronoi diagram. All $n$ points are distinct. ($|x|, |y| \\le 10^4$) \n\nIn the $j$th line of next $q$ lines, two integers indicating $x$ and $y$ co-ordinate of $Q_j$ are given. For each point $Q_j$, you should determine in which region(s) the given point belongs to. ($|x|, |y| \\le 10^4$)", "outputFormat": "Output consists of $q$ lines. In the $j$th line, you should print one of following:\n\n- If $Q_j$ is not included in any region, output $\\texttt{NONE}$.\n- If $Q_j$ is included in exactly one region, output $\\texttt{REGION X}$, where $\\texttt{X}$ is the index of such region.\n- If $Q_j$ is included in exactly two regions, output $\\texttt{LINE X Y}$, where $\\texttt{X}$ and $\\texttt{Y}$ ($\\texttt{X}$ $<$ $\\texttt{Y}$) are the indices of such two regions.\n- If $Q_j$ is included in three or more regions, output $\\texttt{POINT}$.", "hint": "Example is illustrated as diagram above.", "locale": "en", "translations": {"en": {"title": "[2018 KAIST RUN Fall] Voronoi Diagram Returns", "background": "", "description": ":::align{center}\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/umujsipf.png)\n\nVoronoi Diagram of size 4.\n:::\n\nIn the 2-dimensional Cartesian coordinate system, we define the $\\textbf{Voronoi Diagram}$ of a non-empty \n set of points $S$, as a diagram that divides the plane by the criteria \"which point in the set $S$ is closest in this location?\". More precisely, the Voronoi diagram of a given non-empty point set $\\{P_1, P_2, \\cdots, P_n\\}$ is a collection of $\\textbf{regions}$: A point $K$ is included in region $i$ if and only if $d(P_i, K) \\le d(P_j, K)$ holds for all $1 \\le j \\le n$, where $d(X, Y)$ denotes the Euclidean distance between point $X$ and $Y$.\n\nFor example, in the picture above, every location over the plane is colored by the closest point with such location. The points which belongs to a single region is colored by a light color indicating a region, and the points which belongs to more than one region forms lines and points colored black.\n\nThere is an algorithm which computes the Voronoi Diagram in $O(n \\log(n))$, but it is infamous to be very complicated and hard. In fact, we are lenient problem setters, so we set $n \\leq 2000$, which means you can solve this task with slower Voronoi Diagram algorithms!\n\nIn this task, you should solve the $\\textbf{point query problem}$ in Voronoi diagram: in the Voronoi diagram constructed with the set of points $\\{P_1, P_2, \\cdots, P_n\\}$, you should determine which region(s) the point belongs in. More precisely, you will be given $q$ queries of points. For each query point, you should determine the following:\n\n- If it's not included in any region, output $\\texttt{NONE}$.\n- If it's included in exactly one region, output $\\texttt{REGION X}$, where $\\texttt{X}$ is the index of such region.\n- If it's included in exactly two regions, output $\\texttt{LINE X Y}$, where $\\texttt{X}$ and $\\texttt{Y}$ ($\\texttt{X}$ $<$ $\\texttt{Y}$) are the indices of such two regions.\n- If it's included in three or more regions, output $\\texttt{POINT}$.", "inputFormat": "In the first line, the number of points consisting Voronoi diagram $n$, and the number of queries $q$ are given. ($3 \\le n \\le 2\\ 000, 1 \\le q \\le 250\\ 000$) \n\nIn the $i$th line of next $n$ lines, two integers indicating $x$ and $y$ co-ordinate of $P_i$ are given. These are the points consisting the Voronoi diagram. All $n$ points are distinct. ($|x|, |y| \\le 10^4$) \n\nIn the $j$th line of next $q$ lines, two integers indicating $x$ and $y$ co-ordinate of $Q_j$ are given. For each point $Q_j$, you should determine in which region(s) the given point belongs to. ($|x|, |y| \\le 10^4$)", "outputFormat": "Output consists of $q$ lines. In the $j$th line, you should print one of following:\n\n- If $Q_j$ is not included in any region, output $\\texttt{NONE}$.\n- If $Q_j$ is included in exactly one region, output $\\texttt{REGION X}$, where $\\texttt{X}$ is the index of such region.\n- If $Q_j$ is included in exactly two regions, output $\\texttt{LINE X Y}$, where $\\texttt{X}$ and $\\texttt{Y}$ ($\\texttt{X}$ $<$ $\\texttt{Y}$) are the indices of such two regions.\n- If $Q_j$ is included in three or more regions, output $\\texttt{POINT}$.", "hint": "Example is illustrated as diagram above.", "locale": "en"}, "zh-CN": {"title": "[2018 KAIST RUN Fall] Voronoi Diagram Returns", "background": "", "description": ":::align{center}\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/umujsipf.png)\n\n大小为 4 的 Voronoi 图。\n:::\n\n在二维笛卡尔坐标系中，我们将非空点集 $S$ 的 **Voronoi 图** 定义为按\"该位置最接近集合 $S$ 中的哪个点？\"这一准则划分平面的图形。更精确地说，给定非空点集 $\\{P_1, P_2, \\cdots, P_n\\}$ 的 Voronoi 图是一个 **区域** 的集合：点 $K$ 包含在区域 $i$ 中当且仅当对于所有 $1 \\le j \\le n$ 有 $d(P_i, K) \\le d(P_j, K)$，其中 $d(X, Y)$ 表示点 $X$ 和 $Y$ 之间的欧几里得距离。\n\n例如，在上图中，平面上的每个位置都根据最接近的点着色。属于单个区域的点用浅色表示该区域，而属于多个区域的点形成黑色的线和点。\n\n有一种算法可以在 $O(n \\log(n))$ 时间内计算 Voronoi 图，但它以非常复杂和困难而闻名。实际上，我们是宽容的出题人，因此我们设定 $n \\leq 2000$，这意味着你可以用较慢的 Voronoi 图算法解决这个任务！\n\n在此任务中，你需要解决 Voronoi 图中的 **点查询问题**：在由点集 $\\{P_1, P_2, \\cdots, P_n\\}$ 构建的 Voronoi 图中，你需要确定点属于哪个（哪些）区域。更精确地说，你将收到 $q$ 个点的查询。对于每个查询点，你需要确定以下内容：\n\n- 如果它不包含在任何区域中，输出 `NONE`。\n- 如果它恰好包含在一个区域中，输出 `REGION X`，其中 `X` 是该区域的索引。\n- 如果它恰好包含在两个区域中，输出 `LINE X Y`，其中 `X` 和 `Y`（`X` $<$ `Y`）是这两个区域的索引。\n- 如果它包含在三个或更多区域中，输出 `POINT`。", "inputFormat": "第一行给出构成 Voronoi 图的点的数量 $n$ 和查询的数量 $q$（$3 \\le n \\le 2,000$，$1 \\le q \\le 250,000$）。\n\n接下来的 $n$ 行中，第 $i$ 行给出两个整数，表示 $P_i$ 的 $x$ 和 $y$ 坐标。这些是构成 Voronoi 图的点。所有 $n$ 个点都是不同的（$|x|, |y| \\le 10^4$）。\n\n接下来的 $q$ 行中，第 $j$ 行给出两个整数，表示 $Q_j$ 的 $x$ 和 $y$ 坐标。对于每个点 $Q_j$，你应该确定给定点属于哪个（哪些）区域（$|x|, |y| \\le 10^4$）。", "outputFormat": "输出包含 $q$ 行。在第 $j$ 行，你应该输出以下之一：\n\n- 如果 $Q_j$ 不包含在任何区域中，输出 `NONE`。\n- 如果 $Q_j$ 恰好包含在一个区域中，输出 `REGION X`，其中 `X` 是该区域的索引。\n- 如果 $Q_j$ 恰好包含在两个区域中，输出 `LINE X Y`，其中 `X` 和 `Y`（`X` $<$ `Y`）是这两个区域的索引。\n- 如果 $Q_j$ 包含在三个或更多区域中，输出 `POINT`。", "hint": "示例图如上所示。\n\n---\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P14635", "type": "P", "difficulty": 3, "samples": [["2 10\n4 1\n3 3", "4"], ["3 15\n1 7\n2 3\n3 1", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "二分", "2025", "NOIP 提高组", "O2优化", "排序"], "title": "[NOIP2025] 糖果店", "background": "", "description": "小 X 开了一家糖果店，售卖 $n$ 种糖果，每种糖果均有无限颗。对于不同种类的糖果，小 X 采用了不同的促销策略。具体地，对于第 $i$ ($1 \\le i \\le n$) 种糖果，购买第一颗的价格为 $x_i$ 元，第二颗为 $y_i$ 元，第三颗又变回 $x_i$ 元，第四颗则为 $y_i$ 元，以此类推。\n\n小 R 带了 $m$ 元钱买糖果。小 R 不关心糖果的种类，只想得到数量尽可能多的糖果。你需要帮助小 R 求出，$m$ 元钱能购买的糖果数量的最大值。", "inputFormat": "输入的第一行包含两个正整数 $n, m$，代表糖果的种类数和小 R 的钱数。\n\n输入的第 $i+1$ ($1 \\le i \\le n$) 行包含两个正整数 $x_i, y_i$，分别表示购买第 $i$ 种糖果时第奇数颗的价格和第偶数颗的价格。", "outputFormat": "输出一行一个非负整数，表示 $m$ 元钱能购买的糖果数量的最大值。", "hint": "### 【样例 1 解释】\n\n小 R 可以购买 4 颗第一种糖果，共花费 $4 + 1 + 4 + 1 = 10$ 元。\n\n### 【样例 2 解释】\n\n小 R 可以购买 1 颗第一种糖果、1 颗第二种糖果与 6 颗第三种糖果，共花费 $1 + 2 + 12 = 15$ 元。\n\n### 【样例 3】\n\n见选手目录下的 `candy/candy3.in` 与 `candy/candy3.ans`。  \n\n该样例满足测试点 $6$ 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 `candy/candy4.in` 与 `candy/candy4.ans`。  \n\n该样例满足测试点 $8,9$ 的约束条件。\n\n### 【样例 5】\n\n见选手目录下的 `candy/candy5.in` 与 `candy/candy5.ans`。  \n\n该样例满足测试点 $11,12$ 的约束条件。\n\n### 【样例 6】\n\n见选手目录下的 `candy/candy6.in` 与 `candy/candy6.ans`。  \n\n该样例满足测试点 $13$ 的约束条件。\n\n### 【样例 7】\n\n见选手目录下的 `candy/candy7.in` 与 `candy/candy7.ans`。  \n\n该样例满足测试点 $17,18$ 的约束条件。\n\n\n### 【数据范围】\n\n对于所有测试数据，均有：\n- $1 \\le n \\le 10^5$；\n- $1 \\le m \\le 10^{18}$；\n- 对于所有 $1 \\le i \\le n$，均有 $1 \\le x_i, y_i \\le 10^9$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\le$ | $m \\le$ | 特殊性质 |\n|:----------:|:-------:|:-------:|:--------:|\n| $1$        | $1$     | $10$    | 无       |\n| $2,3$      | $2$     | $20$    | ^        |\n| $4,5$      | $10$    | ^       | ^        |\n| $6$        | $10^2$  | $10^2$  | A        |\n| $7$        | ^       | ^       | B        |\n| $8,9$      | ^       | ^       | 无       |\n| $10$       | $10^3$  | $10^4$  | A        |\n| $11,12$    | ^       | ^       | B        |\n| $13$       | ^       | ^       | 无       |\n| $14$       | $10^5$  | $10^9$  | A        |\n| $15,16$    | ^       | ^       | B        |\n| $17,18$    | ^       | ^       | 无       |\n| $19,20$    | ^       | $10^{18}$ | ^       |\n\n特殊性质 A：对于所有 $1 \\le i \\le n$，均有 $x_i = y_i$。\n\n特殊性质 B：对于所有 $1 \\le i \\le n$，均有 $x_i \\ge y_i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOIP2025] 糖果店", "background": "", "description": "小 X 开了一家糖果店，售卖 $n$ 种糖果，每种糖果均有无限颗。对于不同种类的糖果，小 X 采用了不同的促销策略。具体地，对于第 $i$ ($1 \\le i \\le n$) 种糖果，购买第一颗的价格为 $x_i$ 元，第二颗为 $y_i$ 元，第三颗又变回 $x_i$ 元，第四颗则为 $y_i$ 元，以此类推。\n\n小 R 带了 $m$ 元钱买糖果。小 R 不关心糖果的种类，只想得到数量尽可能多的糖果。你需要帮助小 R 求出，$m$ 元钱能购买的糖果数量的最大值。", "inputFormat": "输入的第一行包含两个正整数 $n, m$，代表糖果的种类数和小 R 的钱数。\n\n输入的第 $i+1$ ($1 \\le i \\le n$) 行包含两个正整数 $x_i, y_i$，分别表示购买第 $i$ 种糖果时第奇数颗的价格和第偶数颗的价格。", "outputFormat": "输出一行一个非负整数，表示 $m$ 元钱能购买的糖果数量的最大值。", "hint": "### 【样例 1 解释】\n\n小 R 可以购买 4 颗第一种糖果，共花费 $4 + 1 + 4 + 1 = 10$ 元。\n\n### 【样例 2 解释】\n\n小 R 可以购买 1 颗第一种糖果、1 颗第二种糖果与 6 颗第三种糖果，共花费 $1 + 2 + 12 = 15$ 元。\n\n### 【样例 3】\n\n见选手目录下的 `candy/candy3.in` 与 `candy/candy3.ans`。  \n\n该样例满足测试点 $6$ 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 `candy/candy4.in` 与 `candy/candy4.ans`。  \n\n该样例满足测试点 $8,9$ 的约束条件。\n\n### 【样例 5】\n\n见选手目录下的 `candy/candy5.in` 与 `candy/candy5.ans`。  \n\n该样例满足测试点 $11,12$ 的约束条件。\n\n### 【样例 6】\n\n见选手目录下的 `candy/candy6.in` 与 `candy/candy6.ans`。  \n\n该样例满足测试点 $13$ 的约束条件。\n\n### 【样例 7】\n\n见选手目录下的 `candy/candy7.in` 与 `candy/candy7.ans`。  \n\n该样例满足测试点 $17,18$ 的约束条件。\n\n\n### 【数据范围】\n\n对于所有测试数据，均有：\n- $1 \\le n \\le 10^5$；\n- $1 \\le m \\le 10^{18}$；\n- 对于所有 $1 \\le i \\le n$，均有 $1 \\le x_i, y_i \\le 10^9$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\le$ | $m \\le$ | 特殊性质 |\n|:----------:|:-------:|:-------:|:--------:|\n| $1$        | $1$     | $10$    | 无       |\n| $2,3$      | $2$     | $20$    | ^        |\n| $4,5$      | $10$    | ^       | ^        |\n| $6$        | $10^2$  | $10^2$  | A        |\n| $7$        | ^       | ^       | B        |\n| $8,9$      | ^       | ^       | 无       |\n| $10$       | $10^3$  | $10^4$  | A        |\n| $11,12$    | ^       | ^       | B        |\n| $13$       | ^       | ^       | 无       |\n| $14$       | $10^5$  | $10^9$  | A        |\n| $15,16$    | ^       | ^       | B        |\n| $17,18$    | ^       | ^       | 无       |\n| $19,20$    | ^       | $10^{18}$ | ^       |\n\n特殊性质 A：对于所有 $1 \\le i \\le n$，均有 $x_i = y_i$。\n\n特殊性质 B：对于所有 $1 \\le i \\le n$，均有 $x_i \\ge y_i$。", "locale": "zh-CN"}}}
{"pid": "P14636", "type": "P", "difficulty": 6, "samples": [["0 1\n3 2\n1 3 5", "6"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2025", "NOIP 提高组", "O2优化", "枚举", "组合数学", "排列组合", "双指针 two-pointer"], "title": "[NOIP2025] 清仓甩卖", "background": "额外提供了 0.5 秒的时限。", "description": "小 X 的糖果促销策略很成功，现在糖果店只剩下了 $n$ 颗糖果，其中第 $i$ ($1 \\le i \\le n$) 颗糖果的原价为 $a_i$ 元。小 X 计划将它们全部重新定价，清仓甩卖。具体地，小 X 会将每颗糖果的清仓价格分别定为 $1$ 元或 $2$ 元。设第 $i$ ($1 \\le i \\le n$) 颗糖果的清仓价格为 $w_i \\in \\{1,2\\}$ 元，则它的**性价比**被定义为原价与清仓价格的比值，即 $\\frac{a_i}{w_i}$。\n\n小 R 又带了 $m$ 元钱买糖果。这一次，小 R 希望他购买到的糖果的原价总和最大，于是他采用了以下购买策略：将所有糖果按照**性价比从大到小排序**，然后依次考虑每一颗糖果。具体地，若小 R 在考虑第 $i$ ($1 \\le i \\le n$) 颗糖果时剩余的钱至少为 $w_i$ 元，则他会购买这颗糖果；否则他会跳过这颗糖果，继续考虑下一颗。特别地，若存在两颗糖果的性价比相同，则小 R 会先考虑**原价较高**的糖果；若存在两颗糖果的性价比与原价均相同，则小 R 会先考虑编号较小的糖果。\n\n例如，若小 X 的糖果商店剩余 $3$ 颗糖果，原价分别为 $a_1=1$，$a_2=3$，$a_3=5$，而清仓价格分别为 $w_1=w_2=1$，$w_3=2$，则性价比分别为 $1, 3, \\frac{5}{2}$。因此小 R 会先考虑第 $2$ 颗糖果，然后考虑第 $3$ 颗糖果，最后考虑第 $1$ 颗糖果。\n\n小 R 想知道，在小 X 的所有 $2^n$ 种定价方案中，有多少种定价方案使得他按照上述购买策略能购买到的糖果的**原价总和最大**。你需要帮助小 R 求出满足要求的定价方案的数量。由于答案可能较大，你只需要求出答案对 $998,244,353$ 取模后的结果。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含两个非负整数 $c, t$，分别表示测试点编号与测试数据组数。$c=0$ 表示该测试点为样例。\n\n接下来依次输入每组测试数据，对于每组测试数据：\n- 第一行包含两个正整数 $n, m$，分别表示糖果的数量与小 R 的钱数；\n- 第二行包含 $n$ 个正整数 $a_1, a_2, \\ldots, a_n$，分别表示每颗糖果的原价。", "outputFormat": "对于每组测试数据，输出一行一个非负整数，表示使得小 R 购买到的糖果的原价总和达到最大值的定价方案数对 $998,244,353$ 取模后的结果。", "hint": "### 【样例 1 解释】\n\n该样例即为【题目描述】中的例子。共有以下 $6$ 种定价方案使得小 R 购买到的糖果原价总和最大，分别为：\n\n- $w_1 = w_2 = w_3 = 1$，小 R 购买到的糖果原价总和为 $8$；\n- $w_1 = w_3 = 1$，$w_2 = 2$，小 R 购买到的糖果原价总和为 $6$；\n- $w_1 = 1$，$w_2 = w_3 = 2$，小 R 购买到的糖果原价总和为 $5$；\n- $w_2 = w_3 = 1$，$w_1 = 2$，小 R 购买到的糖果原价总和为 $8$；\n- $w_3 = 1$，$w_1 = w_2 = 2$，小 R 购买到的糖果原价总和为 $5$；\n- $w_1 = w_2 = w_3 = 2$，小 R 购买到的糖果原价总和为 $5$。\n\n注意：若 $w_1 = w_2 = 1$，$w_3 = 2$，则小 R 会依次购买第 $2$ 颗和第 $1$ 颗糖果，原价总和为 $4$，但小 R 可以只购买第 $3$ 颗糖果，原价总和为 $5$。因此该定价方案无法使小 R 购买到的糖果的原价总和达到最大值。\n\n### 【样例 2】\n\n见选手目录下的 `sale/sale2.in` 与 `sale/sale2.ans`。  \n\n该样例满足测试点 $1 \\sim 3$ 的约束条件。\n\n### 【样例 3】\n\n见选手目录下的 `sale/sale3.in` 与 `sale/sale3.ans`。  \n\n该样例满足测试点 $4,5$ 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 `sale/sale4.in` 与 `sale/sale4.ans`。  \n\n该样例满足测试点 $7 \\sim 9$ 的约束条件。\n\n### 【样例 5】\n\n见选手目录下的 `sale/sale5.in` 与 `sale/sale5.ans`。  \n\n该样例满足测试点 $10 \\sim 12$ 的约束条件。\n\n### 【样例 6】\n\n见选手目录下的 `sale/sale6.in` 与 `sale/sale6.ans`。  \n\n该样例满足测试点 $13$ 的约束条件。\n\n### 【样例 7】\n\n见选手目录下的 `sale/sale7.in` 与 `sale/sale7.ans`。  \n\n该样例满足测试点 $14,15$ 的约束条件。\n\n### 【样例 8】\n\n见选手目录下的 `sale/sale8.in` 与 `sale/sale8.ans`。  \n\n该样例满足测试点 $17$ 的约束条件。\n\n### 【样例 9】\n\n见选手目录下的 `sale/sale9.in` 与 `sale/sale9.ans`。  \n\n该样例满足测试点 $19,20$ 的约束条件。\n\n### 【样例 10】\n\n见选手目录下的 `sale/sale10.in` 与 `sale/sale10.ans`。  \n\n该样例满足测试点 $21 \\sim 23$ 的约束条件。\n\n### 【样例 11】\n\n见选手目录下的 `sale/sale11.in` 与 `sale/sale11.ans`。  \n\n该样例满足测试点 $24,25$ 的约束条件。\n\n### 【数据范围】\n\n设 $N$ 为单个测试点内所有测试数据的 $n$ 的和。对于所有测试数据，均有：\n\n- $1 \\le t \\le 5 \\times 10^4$；\n- $1 \\le n \\le 5,000$，$N \\le 5 \\times 10^4$，$1 \\le m \\le 2n - 1$；\n- 对于所有 $1 \\le i \\le n$，均有 $1 \\le a_i \\le 10^9$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\le$ | $N \\le$ | $m$ | 特殊性质 |\n|:----------:|:-------:|:-------:|:---:|:--------:|\n| $1\\sim 3$  | $5$     | $5{,}000$ | $\\le 2n - 1$ | 无 |\n| $4,5$      | $10$    | ^ | ^ | ^ |\n| $6$        | $40$    | ^ | ^ | ^ |\n| $7\\sim 9$  | $300$   | ^ | $=2$ | ^ |\n| $10\\sim 12$| ^ | ^ | $\\le 2n - 1$ | B |\n| $13$       | ^ | ^ | ^ | 无 |\n| $14,15$    | $10^3$ | $10^4$ | $=2$ | ^ |\n| $16$       | ^ | ^ | $=2n - 1$ | ^ |\n| $17$       | ^ | ^ | $=2n - 2$ | ^ |\n| $18$       | ^ | ^ | $\\le 2n - 1$ | A |\n| $19,20$    | ^ | ^ | ^ | B |\n| $21\\sim 23$| ^ | ^ | ^ | 无 |\n| $24,25$    | $5{,}000$ | $5 \\times 10^4$ | ^ | ^ |\n\n特殊性质 A：$a_1 = a_2 = \\cdots = a_n$。\n\n特殊性质 B：对于所有 $1 \\le i \\le n$，均有 $a_i > 5 \\times 10^8$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOIP2025] 清仓甩卖", "background": "额外提供了 0.5 秒的时限。", "description": "小 X 的糖果促销策略很成功，现在糖果店只剩下了 $n$ 颗糖果，其中第 $i$ ($1 \\le i \\le n$) 颗糖果的原价为 $a_i$ 元。小 X 计划将它们全部重新定价，清仓甩卖。具体地，小 X 会将每颗糖果的清仓价格分别定为 $1$ 元或 $2$ 元。设第 $i$ ($1 \\le i \\le n$) 颗糖果的清仓价格为 $w_i \\in \\{1,2\\}$ 元，则它的**性价比**被定义为原价与清仓价格的比值，即 $\\frac{a_i}{w_i}$。\n\n小 R 又带了 $m$ 元钱买糖果。这一次，小 R 希望他购买到的糖果的原价总和最大，于是他采用了以下购买策略：将所有糖果按照**性价比从大到小排序**，然后依次考虑每一颗糖果。具体地，若小 R 在考虑第 $i$ ($1 \\le i \\le n$) 颗糖果时剩余的钱至少为 $w_i$ 元，则他会购买这颗糖果；否则他会跳过这颗糖果，继续考虑下一颗。特别地，若存在两颗糖果的性价比相同，则小 R 会先考虑**原价较高**的糖果；若存在两颗糖果的性价比与原价均相同，则小 R 会先考虑编号较小的糖果。\n\n例如，若小 X 的糖果商店剩余 $3$ 颗糖果，原价分别为 $a_1=1$，$a_2=3$，$a_3=5$，而清仓价格分别为 $w_1=w_2=1$，$w_3=2$，则性价比分别为 $1, 3, \\frac{5}{2}$。因此小 R 会先考虑第 $2$ 颗糖果，然后考虑第 $3$ 颗糖果，最后考虑第 $1$ 颗糖果。\n\n小 R 想知道，在小 X 的所有 $2^n$ 种定价方案中，有多少种定价方案使得他按照上述购买策略能购买到的糖果的**原价总和最大**。你需要帮助小 R 求出满足要求的定价方案的数量。由于答案可能较大，你只需要求出答案对 $998,244,353$ 取模后的结果。", "inputFormat": "**本题包含多组测试数据。**\n\n输入的第一行包含两个非负整数 $c, t$，分别表示测试点编号与测试数据组数。$c=0$ 表示该测试点为样例。\n\n接下来依次输入每组测试数据，对于每组测试数据：\n- 第一行包含两个正整数 $n, m$，分别表示糖果的数量与小 R 的钱数；\n- 第二行包含 $n$ 个正整数 $a_1, a_2, \\ldots, a_n$，分别表示每颗糖果的原价。", "outputFormat": "对于每组测试数据，输出一行一个非负整数，表示使得小 R 购买到的糖果的原价总和达到最大值的定价方案数对 $998,244,353$ 取模后的结果。", "hint": "### 【样例 1 解释】\n\n该样例即为【题目描述】中的例子。共有以下 $6$ 种定价方案使得小 R 购买到的糖果原价总和最大，分别为：\n\n- $w_1 = w_2 = w_3 = 1$，小 R 购买到的糖果原价总和为 $8$；\n- $w_1 = w_3 = 1$，$w_2 = 2$，小 R 购买到的糖果原价总和为 $6$；\n- $w_1 = 1$，$w_2 = w_3 = 2$，小 R 购买到的糖果原价总和为 $5$；\n- $w_2 = w_3 = 1$，$w_1 = 2$，小 R 购买到的糖果原价总和为 $8$；\n- $w_3 = 1$，$w_1 = w_2 = 2$，小 R 购买到的糖果原价总和为 $5$；\n- $w_1 = w_2 = w_3 = 2$，小 R 购买到的糖果原价总和为 $5$。\n\n注意：若 $w_1 = w_2 = 1$，$w_3 = 2$，则小 R 会依次购买第 $2$ 颗和第 $1$ 颗糖果，原价总和为 $4$，但小 R 可以只购买第 $3$ 颗糖果，原价总和为 $5$。因此该定价方案无法使小 R 购买到的糖果的原价总和达到最大值。\n\n### 【样例 2】\n\n见选手目录下的 `sale/sale2.in` 与 `sale/sale2.ans`。  \n\n该样例满足测试点 $1 \\sim 3$ 的约束条件。\n\n### 【样例 3】\n\n见选手目录下的 `sale/sale3.in` 与 `sale/sale3.ans`。  \n\n该样例满足测试点 $4,5$ 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 `sale/sale4.in` 与 `sale/sale4.ans`。  \n\n该样例满足测试点 $7 \\sim 9$ 的约束条件。\n\n### 【样例 5】\n\n见选手目录下的 `sale/sale5.in` 与 `sale/sale5.ans`。  \n\n该样例满足测试点 $10 \\sim 12$ 的约束条件。\n\n### 【样例 6】\n\n见选手目录下的 `sale/sale6.in` 与 `sale/sale6.ans`。  \n\n该样例满足测试点 $13$ 的约束条件。\n\n### 【样例 7】\n\n见选手目录下的 `sale/sale7.in` 与 `sale/sale7.ans`。  \n\n该样例满足测试点 $14,15$ 的约束条件。\n\n### 【样例 8】\n\n见选手目录下的 `sale/sale8.in` 与 `sale/sale8.ans`。  \n\n该样例满足测试点 $17$ 的约束条件。\n\n### 【样例 9】\n\n见选手目录下的 `sale/sale9.in` 与 `sale/sale9.ans`。  \n\n该样例满足测试点 $19,20$ 的约束条件。\n\n### 【样例 10】\n\n见选手目录下的 `sale/sale10.in` 与 `sale/sale10.ans`。  \n\n该样例满足测试点 $21 \\sim 23$ 的约束条件。\n\n### 【样例 11】\n\n见选手目录下的 `sale/sale11.in` 与 `sale/sale11.ans`。  \n\n该样例满足测试点 $24,25$ 的约束条件。\n\n### 【数据范围】\n\n设 $N$ 为单个测试点内所有测试数据的 $n$ 的和。对于所有测试数据，均有：\n\n- $1 \\le t \\le 5 \\times 10^4$；\n- $1 \\le n \\le 5,000$，$N \\le 5 \\times 10^4$，$1 \\le m \\le 2n - 1$；\n- 对于所有 $1 \\le i \\le n$，均有 $1 \\le a_i \\le 10^9$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\le$ | $N \\le$ | $m$ | 特殊性质 |\n|:----------:|:-------:|:-------:|:---:|:--------:|\n| $1\\sim 3$  | $5$     | $5{,}000$ | $\\le 2n - 1$ | 无 |\n| $4,5$      | $10$    | ^ | ^ | ^ |\n| $6$        | $40$    | ^ | ^ | ^ |\n| $7\\sim 9$  | $300$   | ^ | $=2$ | ^ |\n| $10\\sim 12$| ^ | ^ | $\\le 2n - 1$ | B |\n| $13$       | ^ | ^ | ^ | 无 |\n| $14,15$    | $10^3$ | $10^4$ | $=2$ | ^ |\n| $16$       | ^ | ^ | $=2n - 1$ | ^ |\n| $17$       | ^ | ^ | $=2n - 2$ | ^ |\n| $18$       | ^ | ^ | $\\le 2n - 1$ | A |\n| $19,20$    | ^ | ^ | ^ | B |\n| $21\\sim 23$| ^ | ^ | ^ | 无 |\n| $24,25$    | $5{,}000$ | $5 \\times 10^4$ | ^ | ^ |\n\n特殊性质 A：$a_1 = a_2 = \\cdots = a_n$。\n\n特殊性质 B：对于所有 $1 \\le i \\le n$，均有 $a_i > 5 \\times 10^8$。", "locale": "zh-CN"}}}
{"pid": "P14637", "type": "P", "difficulty": 7, "samples": [["2\n5 2\n1 1 2 2\n7 2\n1 1 2 2 2 3", "9\n13"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "树状数组", "2025", "NOIP 提高组", "O2优化", "动态规划优化", "树形 DP", "树链剖分"], "title": "[NOIP2025] 树的价值", "background": "", "description": "给定一棵 $n$ 个结点的有根树，其中结点 1 为根，结点 $i$ ($2 \\le i \\le n$) 的父亲结点为结点 $p_i$。\n\n对于 $1 \\le i \\le n$，定义结点 $i$ 的**深度** $d_i$ 为结点 1 到结点 $i$ 的简单路径的**边数**，也就是说，$d_1 = 0$，$d_i = d_{p_i} + 1$ ($2 \\le i \\le n$)。定义有根树的**高度** $h$ 为所有结点的**深度**的**最大值**，即 $h = \\max_{i=1}^{n} d_i$。\n\n给定高度的上界 $m$。在本题中，给定的有根树的高度不超过 $m$。\n\n你需要给每个结点设置一个**非负整数**作为它的**权值**。对于 $1 \\le i \\le n$，若结点 $i$ 的权值为 $a_i$，令 $S_i$ 表示结点 $i$ 的**子树**中结点权值构成的集合。对于每一种权值设置方案，定义树的**价值**为 $\\sum_{i=1}^{n} \\mathrm{mex}(S_i)$，其中 $\\mathrm{mex}(S)$ 表示**不在**集合 $S$ 中的**最小非负整数**。例如，在下图中，若设置 $a_1 = 3$，$a_2 = 2$，$a_3 = a_4 = 0$，$a_5 = 1$，则 $S_1 = \\{0,1,2,3\\}$，$S_2 = \\{0,1,2\\}$，$S_3 = \\{0\\}$，$S_4 = \\{0\\}$，$S_5 = \\{1\\}$，树的价值为 $4 + 3 + 1 + 1 + 0 = 9$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/w66oxx87.png)\n:::\n\n你需要求出，在所有权值设置方案中，树的价值的最大值。\n", "inputFormat": "本题包含多组测试数据。\n\n输入的第一行包含一个正整数 $t$，表示测试数据组数。\n\n接下来依次输入每组测试数据，对于每组测试数据：\n- 第一行包含两个正整数 $n, m$，分别表示结点数量与高度的上界。\n- 第二行包含 $n - 1$ 个正整数 $p_2, p_3, \\ldots, p_n$，分别表示每个结点的父亲结点。", "outputFormat": "对于每组测试数据，输出一行一个非负整数，表示树的价值的最大值。\n", "hint": "### 【样例 1 解释】\n\n该样例共包含两组测试数据。\n\n对于第一组测试数据，可以设置 $a_1 = 3$，$a_2 = 2$，$a_3 = a_4 = 0$，$a_5 = 1$，则树的价值为 $4 + 3 + 1 + 1 + 0 = 9$。\n\n对于第二组测试数据，可以设置 $a_1 = 4$，$a_2 = 3$，$a_4 = 2$，$a_3 = a_6 = 1$，$a_5 = a_7 = 0$，则树的价值为 $5 + 4 + 2 + 0 + 1 + 0 + 1 = 13$。\n\n### 【样例 2】\n\n见选手目录下的 `tree/tree2.in` 与 `tree/tree2.ans`。  \n\n该样例满足测试点 $3,4$ 的约束条件。\n\n### 【样例 3】\n\n见选手目录下的 `tree/tree3.in` 与 `tree/tree3.ans`。  \n\n该样例满足测试点 $7,8$ 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 `tree/tree4.in` 与 `tree/tree4.ans`。  \n\n该样例满足测试点 $13,14$ 的约束条件。\n\n### 【样例 5】\n\n见选手目录下的 `tree/tree5.in` 与 `tree/tree5.ans`。 \n\n该样例满足测试点 $18,19$ 的约束条件。\n\n### 【数据范围】\n\n对于所有测试数据，均有：\n\n- $1 \\le t \\le 5$；\n- $2 \\le n \\le 8,000$，$1 \\le m \\le \\min(n - 1, 800)$；\n- 对于所有 $2 \\le i \\le n$，均有 $1 \\le p_i \\le i - 1$；\n- 给定的有根树的高度不超过 $m$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\le$ | $m \\le$ |\n|:----------:|:-------:|:-------:|\n| $1,2$      | $7$     | $n-1$   |\n| $3,4$      | $13$    | ^       |\n| $5,6$      | $18$    | ^       |\n| $7,8$      | $40$    | ^       |\n| $9,10$     | $120$   | ^       |\n| $11,12$    | $360$   | ^       |\n| $13,14$    | $4{,}000$ | $2$    |\n| $15\\sim 17$| ^       | $10$    |\n| $18,19$    | ^       | $50$    |\n| $20\\sim 25$| $8{,}000$ | $800$  |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOIP2025] 树的价值", "background": "", "description": "给定一棵 $n$ 个结点的有根树，其中结点 1 为根，结点 $i$ ($2 \\le i \\le n$) 的父亲结点为结点 $p_i$。\n\n对于 $1 \\le i \\le n$，定义结点 $i$ 的**深度** $d_i$ 为结点 1 到结点 $i$ 的简单路径的**边数**，也就是说，$d_1 = 0$，$d_i = d_{p_i} + 1$ ($2 \\le i \\le n$)。定义有根树的**高度** $h$ 为所有结点的**深度**的**最大值**，即 $h = \\max_{i=1}^{n} d_i$。\n\n给定高度的上界 $m$。在本题中，给定的有根树的高度不超过 $m$。\n\n你需要给每个结点设置一个**非负整数**作为它的**权值**。对于 $1 \\le i \\le n$，若结点 $i$ 的权值为 $a_i$，令 $S_i$ 表示结点 $i$ 的**子树**中结点权值构成的集合。对于每一种权值设置方案，定义树的**价值**为 $\\sum_{i=1}^{n} \\mathrm{mex}(S_i)$，其中 $\\mathrm{mex}(S)$ 表示**不在**集合 $S$ 中的**最小非负整数**。例如，在下图中，若设置 $a_1 = 3$，$a_2 = 2$，$a_3 = a_4 = 0$，$a_5 = 1$，则 $S_1 = \\{0,1,2,3\\}$，$S_2 = \\{0,1,2\\}$，$S_3 = \\{0\\}$，$S_4 = \\{0\\}$，$S_5 = \\{1\\}$，树的价值为 $4 + 3 + 1 + 1 + 0 = 9$。\n\n:::align{center}\n![](https://cdn.luogu.com.cn/upload/image_hosting/w66oxx87.png)\n:::\n\n你需要求出，在所有权值设置方案中，树的价值的最大值。\n", "inputFormat": "本题包含多组测试数据。\n\n输入的第一行包含一个正整数 $t$，表示测试数据组数。\n\n接下来依次输入每组测试数据，对于每组测试数据：\n- 第一行包含两个正整数 $n, m$，分别表示结点数量与高度的上界。\n- 第二行包含 $n - 1$ 个正整数 $p_2, p_3, \\ldots, p_n$，分别表示每个结点的父亲结点。", "outputFormat": "对于每组测试数据，输出一行一个非负整数，表示树的价值的最大值。\n", "hint": "### 【样例 1 解释】\n\n该样例共包含两组测试数据。\n\n对于第一组测试数据，可以设置 $a_1 = 3$，$a_2 = 2$，$a_3 = a_4 = 0$，$a_5 = 1$，则树的价值为 $4 + 3 + 1 + 1 + 0 = 9$。\n\n对于第二组测试数据，可以设置 $a_1 = 4$，$a_2 = 3$，$a_4 = 2$，$a_3 = a_6 = 1$，$a_5 = a_7 = 0$，则树的价值为 $5 + 4 + 2 + 0 + 1 + 0 + 1 = 13$。\n\n### 【样例 2】\n\n见选手目录下的 `tree/tree2.in` 与 `tree/tree2.ans`。  \n\n该样例满足测试点 $3,4$ 的约束条件。\n\n### 【样例 3】\n\n见选手目录下的 `tree/tree3.in` 与 `tree/tree3.ans`。  \n\n该样例满足测试点 $7,8$ 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 `tree/tree4.in` 与 `tree/tree4.ans`。  \n\n该样例满足测试点 $13,14$ 的约束条件。\n\n### 【样例 5】\n\n见选手目录下的 `tree/tree5.in` 与 `tree/tree5.ans`。 \n\n该样例满足测试点 $18,19$ 的约束条件。\n\n### 【数据范围】\n\n对于所有测试数据，均有：\n\n- $1 \\le t \\le 5$；\n- $2 \\le n \\le 8,000$，$1 \\le m \\le \\min(n - 1, 800)$；\n- 对于所有 $2 \\le i \\le n$，均有 $1 \\le p_i \\le i - 1$；\n- 给定的有根树的高度不超过 $m$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\le$ | $m \\le$ |\n|:----------:|:-------:|:-------:|\n| $1,2$      | $7$     | $n-1$   |\n| $3,4$      | $13$    | ^       |\n| $5,6$      | $18$    | ^       |\n| $7,8$      | $40$    | ^       |\n| $9,10$     | $120$   | ^       |\n| $11,12$    | $360$   | ^       |\n| $13,14$    | $4{,}000$ | $2$    |\n| $15\\sim 17$| ^       | $10$    |\n| $18,19$    | ^       | $50$    |\n| $20\\sim 25$| $8{,}000$ | $800$  |", "locale": "zh-CN"}}}
{"pid": "P14638", "type": "P", "difficulty": 7, "samples": [["4\n2 4 -5 1\n3\n1 2\n3 4\n1 4", "18446744073709551603\n8\n4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["倍增", "单调队列", "2025", "NOIP 提高组", "O2优化", "分治", "ST 表", "单调栈"], "title": "[NOIP2025] 序列询问", "background": "额外提供了 1 秒的时限。", "description": "给定一个长度为 $n$ 的整数序列 $a_1, a_2, \\ldots, a_n$。\n\n有 $q$ 次询问，其中第 $j$ ($1 \\le j \\le q$) 次询问将会给出 $L_j, R_j$ ($1 \\le L_j \\le R_j \\le n$)。定义区间 $[l, r]$ ($1 \\le l \\le r \\le n$) 是**极好的**，当且仅当区间 $[l, r]$ 的长度在 $[L_j, R_j]$ 内，即 $L_j \\le r - l + 1 \\le R_j$。定义区间 $[l, r]$ ($1 \\le l \\le r \\le n$) 的**权值**为 $\\sum_{i=l}^{r} a_i$。对于所有 $i = 1, 2, \\ldots, n$，求出所有**包含** $i$ 的极好区间的最大权值，即 $\\max_{1 \\le l \\le i \\le r \\le n} \\{ \\sum_{i=l}^{r} a_i \\mid L_j \\le r - l + 1 \\le R_j \\}$。", "inputFormat": "输入的第一行包含一个正整数 $n$，表示序列长度。\n\n输入的第二行包含 $n$ 个整数 $a_1, a_2, \\ldots, a_n$。\n\n输入的第三行包含一个正整数 $q$，表示询问次数。\n\n输入的第 $j + 3$ ($1 \\le j \\le q$) 行包含两个正整数 $L_j, R_j$，表示第 $j$ 次询问。\n", "outputFormat": "对于每次询问，设包含 $i$ ($1 \\le i \\le n$) 的极好区间的最大权值为 $k_i$，输出一行一个非负整数，表示 $\\bigoplus_{i=1}^{n} \\left( (i \\times k_i) \\bmod 2^{64} \\right)$，其中 $\\oplus$ 表示**二进制按位异或**。注意：对于任意**整数** $x$，存在**唯一的非负整数** $x'$ 满足 $x' \\equiv x \\pmod{2^{64}}$ 且 $0 \\le x' \\le 2^{64} - 1$，则记 $x \\bmod 2^{64} = x'$。", "hint": "### 【样例 1 解释】\n\n对于第 $1$ 次询问：\n- 包含 $1$ 的极好区间为 $[1,1]$ 和 $[1,2]$，权值分别为 $2,6$；\n- 包含 $2$ 的极好区间为 $[1,2]$，$[2,2]$ 和 $[2,3]$，权值分别为 $6,4,-1$；\n- 包含 $3$ 的极好区间为 $[2,3]$，$[3,3]$ 和 $[3,4]$，权值分别为 $-1,-5,-4$；\n- 包含 $4$ 的极好区间为 $[3,4]$ 和 $[4,4]$，权值分别为 $-4,1$。\n\n因此 $k_1 = 6$，$k_2 = 6$，$k_3 = -1$，$k_4 = 1$。\n\n对于第 2 次询问，$k_1 = 2$，$k_2 = 2$，$k_3 = 2$，$k_4 = 2$。\n\n对于第 3 次询问，$k_1 = 6$，$k_2 = 6$，$k_3 = 2$，$k_4 = 2$。\n\n### 【样例 2】\n\n见选手目录下的 `query/query2.in` 与 `query/query2.ans`。  \n\n该样例满足测试点 $2,3$ 的约束条件。\n\n### 【样例 3】\n\n见选手目录下的 `query/query3.in` 与 `query/query3.ans`。  \n\n该样例满足测试点 $4$ 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 `query/query4.in` 与 `query/query4.ans`。  \n\n该样例满足测试点 $6,7$ 的约束条件。\n\n### 【样例 5】\n\n见选手目录下的 `query/query5.in` 与 `query/query5.ans`。  \n\n该样例满足测试点 $8 \\sim 10$ 的约束条件。\n\n### 【样例 6】\n\n见选手目录下的 `query/query6.in` 与 `query/query6.ans`。  \n\n该样例满足测试点 $11,12$ 的约束条件。\n\n### 【样例 7】\n\n见选手目录下的 `query/query7.in` 与 `query/query7.ans`。  \n\n该样例满足测试点 $13$ 的约束条件。\n\n### 【样例 8】\n\n见选手目录下的 `query/query8.in` 与 `query/query8.ans`。  \n\n该样例满足测试点 $16 \\sim 20$ 的约束条件。\n\n### 【数据范围】\n\n对于所有测试数据，均有：\n\n- $1 \\le n \\le 5 \\times 10^4$，$1 \\le q \\le 1,024$；\n- 对于所有 $1 \\le i \\le n$，均有 $|a_i| \\le 10^5$；\n- 对于所有 $1 \\le j \\le q$，均有 $1 \\le L_j \\le R_j \\le n$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\le$       | $q \\le$ | 特殊性质 |\n|:----------:|:-------------:|:-------:|:--------:|\n| $1$        | $10^3$        | $1$     | 无       |\n| $2,3$      | $3{,}000$     | $50$    | ^        |\n| $4$        | $10^4$        | $128$   | ^        |\n| $5$        | $3 \\times 10^4$ | $512$ | ^        |\n| $6,7$      | $5 \\times 10^4$ | $1{,}024$ | A     |\n| $8 \\sim 10$| ^             | $512$   | B        |\n| $11,12$    | ^             | ^       | C        |\n| $13$       | ^             | $1{,}024$ | D     |\n| $14,15$    | ^             | ^       | E        |\n| $16 \\sim 20$| ^            | ^       | 无       |\n\n特殊性质 A：对于所有 $1 \\le j \\le q$，均有 $L_j = R_j$。\n\n特殊性质 B：对于所有 $1 \\le j \\le q$，均有 $R_j \\le 32$。\n\n特殊性质 C：对于所有 $1 \\le j \\le q$，均有 $L_j \\le 16$ 且 $R_j \\ge n - 1000$。\n\n特殊性质 D：对于所有 $1 \\le j \\le q$，均有 $L_j > n/2$。\n\n特殊性质 E：对于所有 $1 \\le j \\le q$，均有 $L_j > n/4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOIP2025] 序列询问", "background": "额外提供了 1 秒的时限。", "description": "给定一个长度为 $n$ 的整数序列 $a_1, a_2, \\ldots, a_n$。\n\n有 $q$ 次询问，其中第 $j$ ($1 \\le j \\le q$) 次询问将会给出 $L_j, R_j$ ($1 \\le L_j \\le R_j \\le n$)。定义区间 $[l, r]$ ($1 \\le l \\le r \\le n$) 是**极好的**，当且仅当区间 $[l, r]$ 的长度在 $[L_j, R_j]$ 内，即 $L_j \\le r - l + 1 \\le R_j$。定义区间 $[l, r]$ ($1 \\le l \\le r \\le n$) 的**权值**为 $\\sum_{i=l}^{r} a_i$。对于所有 $i = 1, 2, \\ldots, n$，求出所有**包含** $i$ 的极好区间的最大权值，即 $\\max_{1 \\le l \\le i \\le r \\le n} \\{ \\sum_{i=l}^{r} a_i \\mid L_j \\le r - l + 1 \\le R_j \\}$。", "inputFormat": "输入的第一行包含一个正整数 $n$，表示序列长度。\n\n输入的第二行包含 $n$ 个整数 $a_1, a_2, \\ldots, a_n$。\n\n输入的第三行包含一个正整数 $q$，表示询问次数。\n\n输入的第 $j + 3$ ($1 \\le j \\le q$) 行包含两个正整数 $L_j, R_j$，表示第 $j$ 次询问。\n", "outputFormat": "对于每次询问，设包含 $i$ ($1 \\le i \\le n$) 的极好区间的最大权值为 $k_i$，输出一行一个非负整数，表示 $\\bigoplus_{i=1}^{n} \\left( (i \\times k_i) \\bmod 2^{64} \\right)$，其中 $\\oplus$ 表示**二进制按位异或**。注意：对于任意**整数** $x$，存在**唯一的非负整数** $x'$ 满足 $x' \\equiv x \\pmod{2^{64}}$ 且 $0 \\le x' \\le 2^{64} - 1$，则记 $x \\bmod 2^{64} = x'$。", "hint": "### 【样例 1 解释】\n\n对于第 $1$ 次询问：\n- 包含 $1$ 的极好区间为 $[1,1]$ 和 $[1,2]$，权值分别为 $2,6$；\n- 包含 $2$ 的极好区间为 $[1,2]$，$[2,2]$ 和 $[2,3]$，权值分别为 $6,4,-1$；\n- 包含 $3$ 的极好区间为 $[2,3]$，$[3,3]$ 和 $[3,4]$，权值分别为 $-1,-5,-4$；\n- 包含 $4$ 的极好区间为 $[3,4]$ 和 $[4,4]$，权值分别为 $-4,1$。\n\n因此 $k_1 = 6$，$k_2 = 6$，$k_3 = -1$，$k_4 = 1$。\n\n对于第 2 次询问，$k_1 = 2$，$k_2 = 2$，$k_3 = 2$，$k_4 = 2$。\n\n对于第 3 次询问，$k_1 = 6$，$k_2 = 6$，$k_3 = 2$，$k_4 = 2$。\n\n### 【样例 2】\n\n见选手目录下的 `query/query2.in` 与 `query/query2.ans`。  \n\n该样例满足测试点 $2,3$ 的约束条件。\n\n### 【样例 3】\n\n见选手目录下的 `query/query3.in` 与 `query/query3.ans`。  \n\n该样例满足测试点 $4$ 的约束条件。\n\n### 【样例 4】\n\n见选手目录下的 `query/query4.in` 与 `query/query4.ans`。  \n\n该样例满足测试点 $6,7$ 的约束条件。\n\n### 【样例 5】\n\n见选手目录下的 `query/query5.in` 与 `query/query5.ans`。  \n\n该样例满足测试点 $8 \\sim 10$ 的约束条件。\n\n### 【样例 6】\n\n见选手目录下的 `query/query6.in` 与 `query/query6.ans`。  \n\n该样例满足测试点 $11,12$ 的约束条件。\n\n### 【样例 7】\n\n见选手目录下的 `query/query7.in` 与 `query/query7.ans`。  \n\n该样例满足测试点 $13$ 的约束条件。\n\n### 【样例 8】\n\n见选手目录下的 `query/query8.in` 与 `query/query8.ans`。  \n\n该样例满足测试点 $16 \\sim 20$ 的约束条件。\n\n### 【数据范围】\n\n对于所有测试数据，均有：\n\n- $1 \\le n \\le 5 \\times 10^4$，$1 \\le q \\le 1,024$；\n- 对于所有 $1 \\le i \\le n$，均有 $|a_i| \\le 10^5$；\n- 对于所有 $1 \\le j \\le q$，均有 $1 \\le L_j \\le R_j \\le n$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\le$       | $q \\le$ | 特殊性质 |\n|:----------:|:-------------:|:-------:|:--------:|\n| $1$        | $10^3$        | $1$     | 无       |\n| $2,3$      | $3{,}000$     | $50$    | ^        |\n| $4$        | $10^4$        | $128$   | ^        |\n| $5$        | $3 \\times 10^4$ | $512$ | ^        |\n| $6,7$      | $5 \\times 10^4$ | $1{,}024$ | A     |\n| $8 \\sim 10$| ^             | $512$   | B        |\n| $11,12$    | ^             | ^       | C        |\n| $13$       | ^             | $1{,}024$ | D     |\n| $14,15$    | ^             | ^       | E        |\n| $16 \\sim 20$| ^            | ^       | 无       |\n\n特殊性质 A：对于所有 $1 \\le j \\le q$，均有 $L_j = R_j$。\n\n特殊性质 B：对于所有 $1 \\le j \\le q$，均有 $R_j \\le 32$。\n\n特殊性质 C：对于所有 $1 \\le j \\le q$，均有 $L_j \\le 16$ 且 $R_j \\ge n - 1000$。\n\n特殊性质 D：对于所有 $1 \\le j \\le q$，均有 $L_j > n/2$。\n\n特殊性质 E：对于所有 $1 \\le j \\le q$，均有 $L_j > n/4$。", "locale": "zh-CN"}}}
{"pid": "P14639", "type": "P", "difficulty": 4, "samples": [["3\n1 3 2", "4"], ["8\n3 7 1 7 4 2 5 1", "126"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "组合数学"], "title": "【OIMO Round 1】世界线", "background": "", "description": "X 正在编写她的小说，她需要为这本小说设定一条世界线，也就是各个事件发生的时间次序。\n\nX 已经想好了 $n$ 个事件，第 $i$ 个事件有一个 $1$ 到 $n$ 内的类型 $a_i$。X 要将这 $n$ 个事件的**类型**排成一个序列 $B$。\n\nX 希望小说的内容跌宕起伏，所以对于 $B$ 的每个前缀 $b_1,\\dots,b_k$，$b_k$ 必须是该前缀的最大值或最小值。\n\nX 想要知道，符合要求的**本质不同**的序列 $B$ 共有多少种？\n\n由于数量实在是太大了，X 让你将答案对 $998244353$ 取模。\n\n**本质不同**：定义两个长度为 $n$ 的序列 $X$ 和 $Y$ 是本质不同的，当且仅当存在 $1\\le i\\le n$，使得 $x_i\\neq y_i$。", "inputFormat": "第一行一个正整数 $n$，表示事件的个数。\n\n第二行 $n$ 个正整数，第 $i$ 个正整数为 $a_i$。", "outputFormat": "一行一个正整数，表示答案对 $998244353$ 取模后的值。", "hint": "#### 样例解释\n对于样例 1，一共有以下四种序列是符合要求的：\n- $[1,2,3]$；\n- $[2,1,3]$；\n- $[2,3,1]$；\n- $[3,2,1]$。\n\n**本题采用捆绑测试**。\n\n- Subtask 1（20 points）：$n \\le 10$。\n- Subtask 2（80 points）：无特殊限制。\n\n对于所有测试数据，$1 \\le n \\le 10^6$，$1 \\le a_i \\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【OIMO Round 1】世界线", "background": "", "description": "X 正在编写她的小说，她需要为这本小说设定一条世界线，也就是各个事件发生的时间次序。\n\nX 已经想好了 $n$ 个事件，第 $i$ 个事件有一个 $1$ 到 $n$ 内的类型 $a_i$。X 要将这 $n$ 个事件的**类型**排成一个序列 $B$。\n\nX 希望小说的内容跌宕起伏，所以对于 $B$ 的每个前缀 $b_1,\\dots,b_k$，$b_k$ 必须是该前缀的最大值或最小值。\n\nX 想要知道，符合要求的**本质不同**的序列 $B$ 共有多少种？\n\n由于数量实在是太大了，X 让你将答案对 $998244353$ 取模。\n\n**本质不同**：定义两个长度为 $n$ 的序列 $X$ 和 $Y$ 是本质不同的，当且仅当存在 $1\\le i\\le n$，使得 $x_i\\neq y_i$。", "inputFormat": "第一行一个正整数 $n$，表示事件的个数。\n\n第二行 $n$ 个正整数，第 $i$ 个正整数为 $a_i$。", "outputFormat": "一行一个正整数，表示答案对 $998244353$ 取模后的值。", "hint": "#### 样例解释\n对于样例 1，一共有以下四种序列是符合要求的：\n- $[1,2,3]$；\n- $[2,1,3]$；\n- $[2,3,1]$；\n- $[3,2,1]$。\n\n**本题采用捆绑测试**。\n\n- Subtask 1（20 points）：$n \\le 10$。\n- Subtask 2（80 points）：无特殊限制。\n\n对于所有测试数据，$1 \\le n \\le 10^6$，$1 \\le a_i \\le n$。", "locale": "zh-CN"}}}
{"pid": "P14640", "type": "P", "difficulty": 3, "samples": [["2\n1 2\n114514 1919810", "1\n1047"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "O2优化"], "title": "【OIMO Round 1】校验", "background": "**请注意本题特殊的时间限制，并使用更快的读写方式。**", "description": "X 有一些数，她对数有不同的喜爱程度。具体的，她对某个数的喜爱度计算方法如下：\n\n定义一个正整数 $x$ 的校验值为 $(-1)^{\\Omega(x)}$，其中 $\\Omega(x)$ 为 $x$ 的**可重**素因子个数。比如，$12$ 的校验值为 $(-1)^3=-1$，因为它有 $3$ 个素因子 $2,2,3$。\n\nX 对一个数的喜爱度是这个数的**所有因数**的校验值之和。例如，X 对 $2$ 的喜爱度为 $0$，因为 $1$ 的校验值为 $1$，$2$ 的校验值为 $-1$。\n\nH 有一个区间 $[l,r]$，他想知道 X 对这个区间内所有数的喜爱度之和。\n\n**形式化题意**：给定 $l,r$，求 $\\sum\\limits_{i=l}^r\\sum\\limits_{x\\mid i}(-1)^{\\Omega(x)}$ 的值，其中 $\\Omega(x)$ 为 $x$ 的**可重**素因子个数。", "inputFormat": "第一行一个正整数 $T$，表示测试数据组数。\n\n接下来 $T$ 行，每行两个正整数 $l,r$，表示一个区间。", "outputFormat": "输出 $T$ 行，每行一个整数，代表答案。", "hint": "#### 样例解释\n对于第一组数据，X 对 $1$ 的喜爱度为 $1$，对 $2$ 的喜爱度为 $0$，因此和为 $1$。\n\n**本题采用捆绑测试**。\n\n- Subtask 1（10 points）：$T\\le 10$，$1\\le l\\le r\\le 100$；\n- Subtask 2（25 points）：$1\\le l\\le r\\le 10^5$；\n- Subtask 3（65 points）：无特殊限制。\n\n对于所有测试数据，$1\\le T\\le 10^6$，$1\\le l\\le r\\le 10^9$。\n\n**请注意本题特殊的时间限制，并使用更快的读写方式。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【OIMO Round 1】校验", "background": "**请注意本题特殊的时间限制，并使用更快的读写方式。**", "description": "X 有一些数，她对数有不同的喜爱程度。具体的，她对某个数的喜爱度计算方法如下：\n\n定义一个正整数 $x$ 的校验值为 $(-1)^{\\Omega(x)}$，其中 $\\Omega(x)$ 为 $x$ 的**可重**素因子个数。比如，$12$ 的校验值为 $(-1)^3=-1$，因为它有 $3$ 个素因子 $2,2,3$。\n\nX 对一个数的喜爱度是这个数的**所有因数**的校验值之和。例如，X 对 $2$ 的喜爱度为 $0$，因为 $1$ 的校验值为 $1$，$2$ 的校验值为 $-1$。\n\nH 有一个区间 $[l,r]$，他想知道 X 对这个区间内所有数的喜爱度之和。\n\n**形式化题意**：给定 $l,r$，求 $\\sum\\limits_{i=l}^r\\sum\\limits_{x\\mid i}(-1)^{\\Omega(x)}$ 的值，其中 $\\Omega(x)$ 为 $x$ 的**可重**素因子个数。", "inputFormat": "第一行一个正整数 $T$，表示测试数据组数。\n\n接下来 $T$ 行，每行两个正整数 $l,r$，表示一个区间。", "outputFormat": "输出 $T$ 行，每行一个整数，代表答案。", "hint": "#### 样例解释\n对于第一组数据，X 对 $1$ 的喜爱度为 $1$，对 $2$ 的喜爱度为 $0$，因此和为 $1$。\n\n**本题采用捆绑测试**。\n\n- Subtask 1（10 points）：$T\\le 10$，$1\\le l\\le r\\le 100$；\n- Subtask 2（25 points）：$1\\le l\\le r\\le 10^5$；\n- Subtask 3（65 points）：无特殊限制。\n\n对于所有测试数据，$1\\le T\\le 10^6$，$1\\le l\\le r\\le 10^9$。\n\n**请注意本题特殊的时间限制，并使用更快的读写方式。**", "locale": "zh-CN"}}}
{"pid": "P14641", "type": "P", "difficulty": 5, "samples": [["3 2\n\n0 0", "\n1 1\n\n2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["交互题", "Special Judge", "O2优化", "二次剩余"], "title": "【OIMO Round 1】进制整除", "background": "", "description": "**这是一道交互题**。\n\nX 和 H 玩腻了猜数游戏！于是他们开始玩填数游戏。这个游戏的规则是这样的：\n\n首先，两人确定一个质数 $p$ 与一个正整数 $n$，满足 $n<p$，并创建一个长度为 $p$ 的数组 $a$，下标从 $0$ 开始。\n\n然后，从 X 开始，两人轮流从 $\\{0,1,\\dots,p-1\\}$ 中选择一个以前从未被选过的数 $i$，并为 $a_i$ 赋一个整数值 $x$，满足 $0\\le x<n$。当所有数都被选择过后，游戏结束。\n\n作为游戏的发起人，X 希望最终的数组 $a$ 满足 $p$ 整除 $\\sum_{i=0}^{p-1}a_in^i$。你能帮她进行这个游戏吗？\n\n### 交互方式\n你需要通过**标准输入输出**与评测机进行交互。\n\n首先，你需要从**标准输入**中输入两个整数 $p,n$，含义见题面。\n\n接下来，对于每个你的轮次，你需要向**标准输出**输出两个整数 $i,x$，代表你选择的下标和值，**然后输出一个换行并清空缓冲区**。其中 $i$ 不应在之前的操作中出现，包括你的和 H 的操作。如果你的操作不合法，评测机将输出 `ERROR`，此时你应该立即终止你的程序。\n\n对于每个 H 的轮次，你需要从**标准输入**中输入两个整数 $i,x$，代表他选择的下标和值。保证 $i$ 不在之前的操作中出现过。\n\n当游戏结束时，你应该立即终止你的程序。\n\n你可以使用如下语句来清空缓冲区：\n\n- 对于 C/C++：`fflush(stdout)`；\n- 对于 C++：`std::cout << std::flush`；\n- 对于 Java：`System.out.flush()`；\n- 对于 Python：`stdout.flush()`；\n- 对于 Pascal：`flush(output)`；\n- 对于其他语言，请自行查阅对应语言的帮助文档。\n\n特别的，对于 C++ 语言，在输出换行时如果你使用 `std::endl` 而不是 `'\\n'`，也可以自动刷新缓冲区。**建议使用`std::endl`以避免忘记输出换行。**", "inputFormat": "见【交互方式】。", "outputFormat": "见【交互方式】。", "hint": "#### 样例解释\n在这里，我们有 $a_0n^0+a_1n^1+a_2n^2=0\\times1+1\\times2+1\\times4=6$，显然 $3$ 整除 $6$。\n\n**本题采用捆绑测试**。\n\n对于所有数据，$1\\le n < p\\le 10^5$。\n\n- Subtask 1（20 points）：$n^{p+1}\\le 10^7$。\n- Subtask 2（10 points）：$n=2$。\n- Subtask 3（10 points）：$n=p-1$。\n- Subtask 4（60 points）：无特殊限制。\n\n交互题会首先受到与传统题相同的限制，如时间，空间限制等。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【OIMO Round 1】进制整除", "background": "", "description": "**这是一道交互题**。\n\nX 和 H 玩腻了猜数游戏！于是他们开始玩填数游戏。这个游戏的规则是这样的：\n\n首先，两人确定一个质数 $p$ 与一个正整数 $n$，满足 $n<p$，并创建一个长度为 $p$ 的数组 $a$，下标从 $0$ 开始。\n\n然后，从 X 开始，两人轮流从 $\\{0,1,\\dots,p-1\\}$ 中选择一个以前从未被选过的数 $i$，并为 $a_i$ 赋一个整数值 $x$，满足 $0\\le x<n$。当所有数都被选择过后，游戏结束。\n\n作为游戏的发起人，X 希望最终的数组 $a$ 满足 $p$ 整除 $\\sum_{i=0}^{p-1}a_in^i$。你能帮她进行这个游戏吗？\n\n### 交互方式\n你需要通过**标准输入输出**与评测机进行交互。\n\n首先，你需要从**标准输入**中输入两个整数 $p,n$，含义见题面。\n\n接下来，对于每个你的轮次，你需要向**标准输出**输出两个整数 $i,x$，代表你选择的下标和值，**然后输出一个换行并清空缓冲区**。其中 $i$ 不应在之前的操作中出现，包括你的和 H 的操作。如果你的操作不合法，评测机将输出 `ERROR`，此时你应该立即终止你的程序。\n\n对于每个 H 的轮次，你需要从**标准输入**中输入两个整数 $i,x$，代表他选择的下标和值。保证 $i$ 不在之前的操作中出现过。\n\n当游戏结束时，你应该立即终止你的程序。\n\n你可以使用如下语句来清空缓冲区：\n\n- 对于 C/C++：`fflush(stdout)`；\n- 对于 C++：`std::cout << std::flush`；\n- 对于 Java：`System.out.flush()`；\n- 对于 Python：`stdout.flush()`；\n- 对于 Pascal：`flush(output)`；\n- 对于其他语言，请自行查阅对应语言的帮助文档。\n\n特别的，对于 C++ 语言，在输出换行时如果你使用 `std::endl` 而不是 `'\\n'`，也可以自动刷新缓冲区。**建议使用`std::endl`以避免忘记输出换行。**", "inputFormat": "见【交互方式】。", "outputFormat": "见【交互方式】。", "hint": "#### 样例解释\n在这里，我们有 $a_0n^0+a_1n^1+a_2n^2=0\\times1+1\\times2+1\\times4=6$，显然 $3$ 整除 $6$。\n\n**本题采用捆绑测试**。\n\n对于所有数据，$1\\le n < p\\le 10^5$。\n\n- Subtask 1（20 points）：$n^{p+1}\\le 10^7$。\n- Subtask 2（10 points）：$n=2$。\n- Subtask 3（10 points）：$n=p-1$。\n- Subtask 4（60 points）：无特殊限制。\n\n交互题会首先受到与传统题相同的限制，如时间，空间限制等。", "locale": "zh-CN"}}}
{"pid": "P14642", "type": "P", "difficulty": 5, "samples": [["3\n25000000 2\n20000000 17\n114514 1919810", "499122180 748683265\n431089804 156793081\n820514992 908533289"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "概率论", "期望", "随机游走 Markov Chain"], "title": "【OIMO Round 1】十二宫标志", "background": "", "description": "X 喜欢在城市里随机游走，她为自己的游走方式制定了一个规则。\n\n城市可以视作一个二维平面直角坐标系，初始 X 在 $(0,0)$ 位置，面朝的方向均匀随机。\n\nX 会选定一个概率 $p$，并执行以下步骤 $n$ 次：\n- 有 $p$ 的概率，她会右转（即顺时针转向）$30\\degree$（即 $\\frac\\pi6$ 弧度）；有 $1-p$ 的概率，她不会改变方向。\n- 面朝现在的方向前进一个单位长度。\n\nH 想要去找 X，但 X 刚刚结束一次游走，H 并不清楚她的位置。\n\nH 在给 X 发消息前想要知道，X 在结束了一次游走后，与点 $(0,0)$ 间欧氏距离的平方的期望值是多少？\n\n容易证明，答案可以唯一地表示为 $a+b\\sqrt 3$ 的形式（其中 $a,b$ 均为有理数）。请你输出 $a,b$ 对 $998244353$ 取模的值。", "inputFormat": "第一行一个正整数 $T$，表示有 $T$ 组数据。  \n接下来 $T$ 行，每行两个整数 $p',n$。其中 $p' = p\\times 10^8$。 ", "outputFormat": "输出 $T$ 行，每行两个整数 $a,b$ 表示答案。", "hint": "【样例解释】\n\n对于第一组数据，每步之前有 $1/4$ 的概率转向，所以有：\n\n- $\\frac9{16}$ 的概率直行两次，到原点距离的平方为 $4$；\n- $\\frac3{16}$ 的概率在第一次转向，第二次不转，到原点距离的平方为 $4$；\n- $\\frac3{16}$ 的概率在第一次不转，第二次转向，到原点距离的平方为 $(2+\\sqrt 3)$；\n- $\\frac1{16}$ 的概率转向两次，到原点距离的平方为 $(2+\\sqrt 3)$。\n\n根据以上情况，可以算出期望值为 $\\frac72+\\frac14\\sqrt 3$。\n\n对于第二组数据，答案为：\n$$\\frac{20196247660583+6251719221244 \\sqrt{3}}{152587890625}$$\n\n**本题采用捆绑测试。**\n\n- Subtask 1（10 pts）：$1 \\le T \\le 100$，$1 \\le n \\le 18$；  \n- Subtask 2（25 pts）：$1\\le n \\le 100$；    \n- Subtask 3（25 pts）：$p'=5\\times 10^7$，$1 \\le n \\le  10^5$；  \n- Subtask 4（40 pts）：无特殊限制。\n\n对于全部的数据，$1\\leq T \\leq 10^3$，$0 \\leq p' \\leq 10^8$，$1 \\leq n \\leq 10^7$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "【OIMO Round 1】十二宫标志", "background": "", "description": "X 喜欢在城市里随机游走，她为自己的游走方式制定了一个规则。\n\n城市可以视作一个二维平面直角坐标系，初始 X 在 $(0,0)$ 位置，面朝的方向均匀随机。\n\nX 会选定一个概率 $p$，并执行以下步骤 $n$ 次：\n- 有 $p$ 的概率，她会右转（即顺时针转向）$30\\degree$（即 $\\frac\\pi6$ 弧度）；有 $1-p$ 的概率，她不会改变方向。\n- 面朝现在的方向前进一个单位长度。\n\nH 想要去找 X，但 X 刚刚结束一次游走，H 并不清楚她的位置。\n\nH 在给 X 发消息前想要知道，X 在结束了一次游走后，与点 $(0,0)$ 间欧氏距离的平方的期望值是多少？\n\n容易证明，答案可以唯一地表示为 $a+b\\sqrt 3$ 的形式（其中 $a,b$ 均为有理数）。请你输出 $a,b$ 对 $998244353$ 取模的值。", "inputFormat": "第一行一个正整数 $T$，表示有 $T$ 组数据。  \n接下来 $T$ 行，每行两个整数 $p',n$。其中 $p' = p\\times 10^8$。 ", "outputFormat": "输出 $T$ 行，每行两个整数 $a,b$ 表示答案。", "hint": "【样例解释】\n\n对于第一组数据，每步之前有 $1/4$ 的概率转向，所以有：\n\n- $\\frac9{16}$ 的概率直行两次，到原点距离的平方为 $4$；\n- $\\frac3{16}$ 的概率在第一次转向，第二次不转，到原点距离的平方为 $4$；\n- $\\frac3{16}$ 的概率在第一次不转，第二次转向，到原点距离的平方为 $(2+\\sqrt 3)$；\n- $\\frac1{16}$ 的概率转向两次，到原点距离的平方为 $(2+\\sqrt 3)$。\n\n根据以上情况，可以算出期望值为 $\\frac72+\\frac14\\sqrt 3$。\n\n对于第二组数据，答案为：\n$$\\frac{20196247660583+6251719221244 \\sqrt{3}}{152587890625}$$\n\n**本题采用捆绑测试。**\n\n- Subtask 1（10 pts）：$1 \\le T \\le 100$，$1 \\le n \\le 18$；  \n- Subtask 2（25 pts）：$1\\le n \\le 100$；    \n- Subtask 3（25 pts）：$p'=5\\times 10^7$，$1 \\le n \\le  10^5$；  \n- Subtask 4（40 pts）：无特殊限制。\n\n对于全部的数据，$1\\leq T \\leq 10^3$，$0 \\leq p' \\leq 10^8$，$1 \\leq n \\leq 10^7$。", "locale": "zh-CN"}}}
{"pid": "P14643", "type": "P", "difficulty": 2, "samples": [["2\n2 5 3\n1 4 4", "12"], ["6\n55 40 23\n40 23 55\n55 35 25\n23 56 35\n55 40 23\n55 20 40", "38500"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["POI（波兰）", "2025"], "title": "[POI 2025/2026 #1] 托运 / Carry-on luggage", "background": "", "description": "有 $n$ 条航线，第 $i$ 条航线要求行李能被装进长宽高分别为 $A_i,B_i,C_i$ 的长方体中（边缘可以相切，对于每条航线可以任意旋转）。\n\n现在欲采购一个长宽高分别为 $X,Y,Z$ 的长方体行李箱，最大化其体积（$X\\cdot Y\\cdot Z$）。求出可能的最大体积。\n", "inputFormat": "第一行，正整数 $n$（$1\\le n\\le 10^5$）。\n\n接下来 $n$ 行，每行三个正整数 $X_i,Y_i,Z_i$（$1\\le X_i,Y_i,Z_i\\le 10^6$）。", "outputFormat": "一行一个正整数表示答案。", "hint": "### 样例解释\n\n- **样例 $1$ 解释**：买 $1\\times 3\\times 4$ 的行李箱。\n- **样例 $2$ 解释**：买 $55\\times 35\\times 20$ 的行李箱。\n\n### 大样例\n\n可以在附件中获得大样例。\n\n样例 $\\texttt{0a}$ 是题面中展示的样例。此外：\n\n- $\\texttt{0b}$：$n=10^4$，$A_i=33i$，$B_i=C_i=1$。答案为 $33$。\n- $\\texttt{0c}$：$n=10^5$，$A_i=i,B_i=n+1-i,C_i=10^6$。答案为 $50\\,001\\,000\\,000$。\n### 子任务\n\n\n本题采用捆绑测试。\n| 子任务编号 | 限制 | 得分 |\n| :---------: | :--------------------- | :-----: |\n| $1$      | $n,A_i,B_i,C_i\\le 10$ | $12$   |\n| $2$      | $B_i=C_i=1$                                                                 | $9$   |\n| $3$      | $C_i=1$                                                                   | $33$   |\n| $4$      | 无额外限制                                                                   | $46$   |\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2025/2026 #1] 托运 / Carry-on luggage", "background": "", "description": "有 $n$ 条航线，第 $i$ 条航线要求行李能被装进长宽高分别为 $A_i,B_i,C_i$ 的长方体中（边缘可以相切，对于每条航线可以任意旋转）。\n\n现在欲采购一个长宽高分别为 $X,Y,Z$ 的长方体行李箱，最大化其体积（$X\\cdot Y\\cdot Z$）。求出可能的最大体积。\n", "inputFormat": "第一行，正整数 $n$（$1\\le n\\le 10^5$）。\n\n接下来 $n$ 行，每行三个正整数 $X_i,Y_i,Z_i$（$1\\le X_i,Y_i,Z_i\\le 10^6$）。", "outputFormat": "一行一个正整数表示答案。", "hint": "### 样例解释\n\n- **样例 $1$ 解释**：买 $1\\times 3\\times 4$ 的行李箱。\n- **样例 $2$ 解释**：买 $55\\times 35\\times 20$ 的行李箱。\n\n### 大样例\n\n可以在附件中获得大样例。\n\n样例 $\\texttt{0a}$ 是题面中展示的样例。此外：\n\n- $\\texttt{0b}$：$n=10^4$，$A_i=33i$，$B_i=C_i=1$。答案为 $33$。\n- $\\texttt{0c}$：$n=10^5$，$A_i=i,B_i=n+1-i,C_i=10^6$。答案为 $50\\,001\\,000\\,000$。\n### 子任务\n\n\n本题采用捆绑测试。\n| 子任务编号 | 限制 | 得分 |\n| :---------: | :--------------------- | :-----: |\n| $1$      | $n,A_i,B_i,C_i\\le 10$ | $12$   |\n| $2$      | $B_i=C_i=1$                                                                 | $9$   |\n| $3$      | $C_i=1$                                                                   | $33$   |\n| $4$      | 无额外限制                                                                   | $46$   |\n\n", "locale": "zh-CN"}}}
{"pid": "P14644", "type": "P", "difficulty": 3, "samples": [["6 1 4 2", "1 6 11 14 19 19"]], "limits": {"time": [11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000, 11000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "POI（波兰）", "2025"], "title": "[POI 2025/2026 #1] 表达式 / Arithmetic expression", "background": "滥用评测者将被封号。", "description": "给定正整数 $n,a,b,c$。对于 $i=1,2,\\ldots,n$，构造一个**代价**最小的表达式，使得表达式求值的结果为 $i$。只需要求出最小的代价。\n\n---\n\n我们给出表达式及其代价的定义。\n\n- $\\texttt{1}$ 是代价为 $a$、求值结果为 $1$ 的表达式。\n- 若 $X,Y$ 的代价分别为 $x,y$，且求值结果分别为 $p,q$：\n    - $(X+Y)$ 是代价为 $x+y+b$、求值结果为 $p+q$ 的表达式。\n    - $(X\\times Y)$ 是代价为 $x+y+c$、求值结果为 $p\\cdot q$ 的表达式。\n\n例如，$\\tt(( 1 + 1) × (1 + 1)) × (1 + 1)$ 是代价为 $6a+3b+2c$，求值结果为 $8$ 的表达式。", "inputFormat": "一行四个正整数 $n,a,b,c$（$1\\le n\\le 3\\, 000$，$1\\le a,b,c\\le10^9$）。", "outputFormat": "$n$ 个正整数，第 $i$ 个正整数表示求值结果为 $i$ 的表达式的最小代价。", "hint": "### 样例解释\n\n下表展示了可以得到 $1\\sim 6$ 的最小代价的表达式。\n\n| 求值结果 | 表达式          | 代价  |\n| :------ | :------------------ | :------------------------- |\n| $1$       | $\\tt 1                $   | $a = 1$                    |\n| $2$       | $\\tt (1+1)            $   | $2a + b = 2 + 4 = 6$       |\n| $3$       | $\\tt ((1+1)+1)        $   | $3a + 2b = 3 + 8 = 11$     |\n| $4$       | $\\tt ((1+1)*(1+1))    $   | $4a + 2b + c = 4 + 8 + 2 = 14$ |\n| $5$       | $\\tt (((1+1)*(1+1))+1)$   | $5a + 3b + c = 5 + 12 + 2 = 19$ |\n| $6$       | $\\tt ((1+1)*((1+1)+1))$   | $5a + 3b + c = 5 + 12 + 2 = 19$ |\n\n### 大样例\n\n可以在附件中获得大样例。\n\n样例 $\\texttt{0a}$ 是题面中展示的样例。此外：\n\n*   $\\texttt{0b}$： $n = 9, a = 2, b = 3, c = 1$。\n*   $\\texttt{0c}$： $n = 200, a = 1, b = 2, c = 3$。\n*   $\\texttt{0d}$： $n = 2500, a = 1, b = 1, c = 1$。\n*   $\\texttt{0e}$： $n = 3000, a = b = c = 10^9$。\n\n### 子任务\n\n\n本题采用捆绑测试。\n| 子任务编号 | 限制 | 得分 |\n| :---------: | :--------------------- | :-----: |\n| $1$       | $n \\le 10$                | $13$     |\n| $2$       | $n \\le 200$               | $31$     |\n| $3$       | $a = b = c = 1$           | $13$     |\n| $4$       | 无额外限制                | $43$     |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2025/2026 #1] 表达式 / Arithmetic expression", "background": "滥用评测者将被封号。", "description": "给定正整数 $n,a,b,c$。对于 $i=1,2,\\ldots,n$，构造一个**代价**最小的表达式，使得表达式求值的结果为 $i$。只需要求出最小的代价。\n\n---\n\n我们给出表达式及其代价的定义。\n\n- $\\texttt{1}$ 是代价为 $a$、求值结果为 $1$ 的表达式。\n- 若 $X,Y$ 的代价分别为 $x,y$，且求值结果分别为 $p,q$：\n    - $(X+Y)$ 是代价为 $x+y+b$、求值结果为 $p+q$ 的表达式。\n    - $(X\\times Y)$ 是代价为 $x+y+c$、求值结果为 $p\\cdot q$ 的表达式。\n\n例如，$\\tt(( 1 + 1) × (1 + 1)) × (1 + 1)$ 是代价为 $6a+3b+2c$，求值结果为 $8$ 的表达式。", "inputFormat": "一行四个正整数 $n,a,b,c$（$1\\le n\\le 3\\, 000$，$1\\le a,b,c\\le10^9$）。", "outputFormat": "$n$ 个正整数，第 $i$ 个正整数表示求值结果为 $i$ 的表达式的最小代价。", "hint": "### 样例解释\n\n下表展示了可以得到 $1\\sim 6$ 的最小代价的表达式。\n\n| 求值结果 | 表达式          | 代价  |\n| :------ | :------------------ | :------------------------- |\n| $1$       | $\\tt 1                $   | $a = 1$                    |\n| $2$       | $\\tt (1+1)            $   | $2a + b = 2 + 4 = 6$       |\n| $3$       | $\\tt ((1+1)+1)        $   | $3a + 2b = 3 + 8 = 11$     |\n| $4$       | $\\tt ((1+1)*(1+1))    $   | $4a + 2b + c = 4 + 8 + 2 = 14$ |\n| $5$       | $\\tt (((1+1)*(1+1))+1)$   | $5a + 3b + c = 5 + 12 + 2 = 19$ |\n| $6$       | $\\tt ((1+1)*((1+1)+1))$   | $5a + 3b + c = 5 + 12 + 2 = 19$ |\n\n### 大样例\n\n可以在附件中获得大样例。\n\n样例 $\\texttt{0a}$ 是题面中展示的样例。此外：\n\n*   $\\texttt{0b}$： $n = 9, a = 2, b = 3, c = 1$。\n*   $\\texttt{0c}$： $n = 200, a = 1, b = 2, c = 3$。\n*   $\\texttt{0d}$： $n = 2500, a = 1, b = 1, c = 1$。\n*   $\\texttt{0e}$： $n = 3000, a = b = c = 10^9$。\n\n### 子任务\n\n\n本题采用捆绑测试。\n| 子任务编号 | 限制 | 得分 |\n| :---------: | :--------------------- | :-----: |\n| $1$       | $n \\le 10$                | $13$     |\n| $2$       | $n \\le 200$               | $31$     |\n| $3$       | $a = b = c = 1$           | $13$     |\n| $4$       | 无额外限制                | $43$     |", "locale": "zh-CN"}}}
