{"pid": "P9920", "type": "P", "difficulty": 7, "samples": [["10\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n8 8\n9 9\n10 10\n\n3 -1\n1\n2\n3\n", "1\n1\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数论", "洛谷原创", "Special Judge", "素数判断,质数,筛法", "洛谷月赛"], "title": "「RiOI-03」变换，反演", "background": "为了题目要求，我们对积性函数进行重定义：**不保证 $f(1)=1$**。", "description": "**这是一道非传统题。**\n\n给定一个**积性函数** $f(d)$。对于每一个测试点，我们会在附件中给出 $g(n)=\\sum_{d|n}f(d)$ 的其中 $k$ 项 $\\bmod\\ 998244353$ 的值，这部分也会在输入中出现。接着，对于每一个测试点，有 $t$ 组数据。对于每组数据，输入 $d$，请输出 $f(d)\\bmod998244353$ 的值。", "inputFormat": "第一行为 $k$，接下来每一行会有两个正整数，分别为 $d$ 与 $g(d)$。\n\n之后输入两个数 $t,id$，分别表示数据组数与数据点编号。对于每组数据，输入一个正整数 $n$。", "outputFormat": "对于每组数据，输出一个非负整数表示答案。", "hint": "#### 【样例解释】\n\n由于 $g(d)=d$，因此 $f(d)=\\varphi(d)$，结果正确。\n\n#### 【数据范围】\n\n对于每个测试点：\n\n如果你正确回答了 $n\\le k$ 的测试数据，你将得到 $20\\%$ 的分数。\n\n如果你正确回答了所有测试数据，你将得到剩余 $80\\%$ 的分数。**所以，如果你无法正确回答，也请随机输出一个数来保证格式正确。**\n\n#### 【数据范围】\n\n|$\\text{Id}$|$\\text{Name}$|$\\text{Score}$| $n\\leq$|$k=$|$t=$|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|$0$|$\\text{Epsilon}$|$5$|$10^6$|$100$|$10$|\n|$1$|$\\text{Division}$|$5$|$10^9$|$100$|$10$|\n|$2$|$\\text{Unknown}$|$5$|$10^{18}$|$1$|$10$|\n|$3$|$\\text{Random}$|$10$|$10^5$|$10^5$|$10^5$|\n|$4$|$\\text{Double}$|$10$|$10^9$|$100$|$10$|\n|$5$|$\\text{Hack}$|$10$|$10^9$|$31623$|$1$|\n|$6$|$\\text{Square}$|$15$|$10^{18}$|$100$|$5$|\n|$7$|$\\text{Poly}$|$20$|$10^9$|$10^5$|$100$|\n|$8$|$\\text{Thanks}$|$20$|$10^5$|$4$|$10^5$|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「RiOI-03」变换，反演", "background": "为了题目要求，我们对积性函数进行重定义：**不保证 $f(1)=1$**。", "description": "**这是一道非传统题。**\n\n给定一个**积性函数** $f(d)$。对于每一个测试点，我们会在附件中给出 $g(n)=\\sum_{d|n}f(d)$ 的其中 $k$ 项 $\\bmod\\ 998244353$ 的值，这部分也会在输入中出现。接着，对于每一个测试点，有 $t$ 组数据。对于每组数据，输入 $d$，请输出 $f(d)\\bmod998244353$ 的值。", "inputFormat": "第一行为 $k$，接下来每一行会有两个正整数，分别为 $d$ 与 $g(d)$。\n\n之后输入两个数 $t,id$，分别表示数据组数与数据点编号。对于每组数据，输入一个正整数 $n$。", "outputFormat": "对于每组数据，输出一个非负整数表示答案。", "hint": "#### 【样例解释】\n\n由于 $g(d)=d$，因此 $f(d)=\\varphi(d)$，结果正确。\n\n#### 【数据范围】\n\n对于每个测试点：\n\n如果你正确回答了 $n\\le k$ 的测试数据，你将得到 $20\\%$ 的分数。\n\n如果你正确回答了所有测试数据，你将得到剩余 $80\\%$ 的分数。**所以，如果你无法正确回答，也请随机输出一个数来保证格式正确。**\n\n#### 【数据范围】\n\n|$\\text{Id}$|$\\text{Name}$|$\\text{Score}$| $n\\leq$|$k=$|$t=$|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|$0$|$\\text{Epsilon}$|$5$|$10^6$|$100$|$10$|\n|$1$|$\\text{Division}$|$5$|$10^9$|$100$|$10$|\n|$2$|$\\text{Unknown}$|$5$|$10^{18}$|$1$|$10$|\n|$3$|$\\text{Random}$|$10$|$10^5$|$10^5$|$10^5$|\n|$4$|$\\text{Double}$|$10$|$10^9$|$100$|$10$|\n|$5$|$\\text{Hack}$|$10$|$10^9$|$31623$|$1$|\n|$6$|$\\text{Square}$|$15$|$10^{18}$|$100$|$5$|\n|$7$|$\\text{Poly}$|$20$|$10^9$|$10^5$|$100$|\n|$8$|$\\text{Thanks}$|$20$|$10^5$|$4$|$10^5$|", "locale": "zh-CN"}}}
{"pid": "P9921", "type": "P", "difficulty": 5, "samples": [["5 2\n.X...\n.XXXX\nXX...\n.....\n.X.X.\n", "3\n"], ["2 1\n..\n..\n", "2\n"], ["2 2\nX.\n..\n", "1\n"], ["10 2\nXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXX\n..........\nXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXX\nXXXXXXXXXX\n", "5\n"], ["10 2\nXX.XXXXX.X\nXX.XXXXX.X\nXX.XXXXX.X\nXX.XXXXX.X\nXX.XXXXX.X\nXX.XXXXX.X\nXX.XXXXX.X\nXX.XXXXX.X\nXX.XXXXX.X\nXX.XXXXX.X\n", "10\n"], ["见附件", "531\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["POI（波兰）", "2023", "前缀和", "分类讨论"], "title": "[POI 2023/2024 R1] Budowa lotniska", "background": "译自 [XXXI Olimpiada Informatyczna - I etap](https://sio2.mimuw.edu.pl/c/oi31-1/dashboard/) [Budowa lotniska](https://sio2.mimuw.edu.pl/c/oi31-1/p/bud/)。", "description": "给你一个 $n\\times n$ 的地图，地图上有 `.` 有 `X`。\n\n求出最大的 $k$，使得：\n\n在地图上能找到 $m(m\\leq 2)$ 个 $1\\times k$ 或 $k\\times 1$ 的长条，使得长条不交且长条内全是 `.`。", "inputFormat": "第一行两个正整数 $n,m$。\n\n接下来 $n$ 行，描述地图。", "outputFormat": "一行一个非负整数，最大的 $k$。", "hint": "样例解释：\n\n```plain\n.X...\n.XXXX\nXX..2\n111.2\n.X.X2\n```\n\n对于所有数据，$1\\leq n\\leq1500$，$1\\leq m\\leq2$，地图上只有 `.` 和 `X`。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | $m=1$ | 20 |\n| 2 | $n\\leq 30$ | 22 |\n| 3 | $n\\leq 300$ | 23 |\n| 4 |  | 35 |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2023/2024 R1] Budowa lotniska", "background": "译自 [XXXI Olimpiada Informatyczna - I etap](https://sio2.mimuw.edu.pl/c/oi31-1/dashboard/) [Budowa lotniska](https://sio2.mimuw.edu.pl/c/oi31-1/p/bud/)。", "description": "给你一个 $n\\times n$ 的地图，地图上有 `.` 有 `X`。\n\n求出最大的 $k$，使得：\n\n在地图上能找到 $m(m\\leq 2)$ 个 $1\\times k$ 或 $k\\times 1$ 的长条，使得长条不交且长条内全是 `.`。", "inputFormat": "第一行两个正整数 $n,m$。\n\n接下来 $n$ 行，描述地图。", "outputFormat": "一行一个非负整数，最大的 $k$。", "hint": "样例解释：\n\n```plain\n.X...\n.XXXX\nXX..2\n111.2\n.X.X2\n```\n\n对于所有数据，$1\\leq n\\leq1500$，$1\\leq m\\leq2$，地图上只有 `.` 和 `X`。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | $m=1$ | 20 |\n| 2 | $n\\leq 30$ | 22 |\n| 3 | $n\\leq 300$ | 23 |\n| 4 |  | 35 |\n", "locale": "zh-CN"}}}
{"pid": "P9922", "type": "P", "difficulty": 6, "samples": [["11 3 12 13\nabaaabababa\n", "ba\n"], ["20 3 30 40\nabcdabcdabcdabcdabcd\n", "bcdabcdabcd\n"], ["见附件", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n"], ["见附件", "见附件"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["POI（波兰）", "2023"], "title": "[POI 2023/2024 R1] CzatBBB", "background": "译自 [XXXI Olimpiada Informatyczna - I etap](https://sio2.mimuw.edu.pl/c/oi31-1/dashboard/) [CzatBBB](https://sio2.mimuw.edu.pl/c/oi31-1/p/cza/)。\n", "description": "给出一个 $n$ 个字母的字符串 $S$ 和一个参数 $k$，设 $R$ 为字符串 $S$ 的后 $k$ 个字母形成的字串。\n\n假设字符串 $S'$ 为 $S$ 添加一个新字母生成的新字符串。\n\n添加的规则如下所示： 对于字母 $X$ 字母，计算它在字符串 $S$ 中紧接着 $R$ 出现的次数。出现频率最高的字母为新添加的字母，如果有多个出现频率最高的字母，取最小的一个。如果 $R$ 在字符串 $S$ 中的其他地方都没有出现，则取 $X = a$。最后，我们扩展字符串 $S$，在其末尾添加字母 $X$。\n\n例如，设 $S = \\text{abaaabababa}$，$k = 3$ 则 $R$ 与后一个字母一起出现的字串为的：$\\text{abaa}$、$\\text{abab}$、$\\text{abab}$。它最常与字母 $\\text{b}$ 一起出现，因此我们在 $S$ 中加上 $\\text{b}$，生成 $S' = \\text{abaaabababab}$。\n\n现在 $S' = \\text{abaaabababab}$，$R = \\text{bab}$，$R$ 与后一个字母一起出现的字串为：$\\text{baba}$、$\\text{baba}$，如 $\\text{baba}$、$\\text{baba}$，因此我们在 $S'$ 后面加上 $a$。\n\n以此类推，这样的操作会进行无数次。\n\n你的任务是编写一个程序，输出新字符串最后 $a$ 至 $b$ 个字符。", "inputFormat": "第一行输入包含四个整数 $n$、$k$、$a$ 和 $b$。\n\n第二行输入包含一个 $n$ 个字母的字符串，由小写英文字母组成的 $n$ 个字母字符串，表示单词 $S$。", "outputFormat": "输出字符串 $S'$ 的第 $a$ 个字符 至第 $b$ 个字符，表示扩展单词 $S'$ 中位于以下位置的字母。", "hint": "对于所有的数据，$2\\leq n\\leq10^6$，$1\\leq k<n<a<b<10^{18}$，$b+1-a\\leq10^6$，串只含小写字母。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | $n\\leq100$，$b\\leq1000$ | 8 |\n| 2 | $b\\leq 10^8$ | 10 |\n| 3 | $n\\leq 500$，后缀 $R$ 的前一次出现将始终存在，并且每次出现后都会有相同的字母  | 16 |\n| 4 | 后缀 $R$ 的前一次出现将始终存在，并且每次出现后都会有相同的字母 | 10 |\n| 5 | $k\\leq20$，$b\\leq 10^{10}$，串只含 `ab` | 16 |\n| 6 | 无任何限制  | 40 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2023/2024 R1] CzatBBB", "background": "译自 [XXXI Olimpiada Informatyczna - I etap](https://sio2.mimuw.edu.pl/c/oi31-1/dashboard/) [CzatBBB](https://sio2.mimuw.edu.pl/c/oi31-1/p/cza/)。\n", "description": "给出一个 $n$ 个字母的字符串 $S$ 和一个参数 $k$，设 $R$ 为字符串 $S$ 的后 $k$ 个字母形成的字串。\n\n假设字符串 $S'$ 为 $S$ 添加一个新字母生成的新字符串。\n\n添加的规则如下所示： 对于字母 $X$ 字母，计算它在字符串 $S$ 中紧接着 $R$ 出现的次数。出现频率最高的字母为新添加的字母，如果有多个出现频率最高的字母，取最小的一个。如果 $R$ 在字符串 $S$ 中的其他地方都没有出现，则取 $X = a$。最后，我们扩展字符串 $S$，在其末尾添加字母 $X$。\n\n例如，设 $S = \\text{abaaabababa}$，$k = 3$ 则 $R$ 与后一个字母一起出现的字串为的：$\\text{abaa}$、$\\text{abab}$、$\\text{abab}$。它最常与字母 $\\text{b}$ 一起出现，因此我们在 $S$ 中加上 $\\text{b}$，生成 $S' = \\text{abaaabababab}$。\n\n现在 $S' = \\text{abaaabababab}$，$R = \\text{bab}$，$R$ 与后一个字母一起出现的字串为：$\\text{baba}$、$\\text{baba}$，如 $\\text{baba}$、$\\text{baba}$，因此我们在 $S'$ 后面加上 $a$。\n\n以此类推，这样的操作会进行无数次。\n\n你的任务是编写一个程序，输出新字符串最后 $a$ 至 $b$ 个字符。", "inputFormat": "第一行输入包含四个整数 $n$、$k$、$a$ 和 $b$。\n\n第二行输入包含一个 $n$ 个字母的字符串，由小写英文字母组成的 $n$ 个字母字符串，表示单词 $S$。", "outputFormat": "输出字符串 $S'$ 的第 $a$ 个字符 至第 $b$ 个字符，表示扩展单词 $S'$ 中位于以下位置的字母。", "hint": "对于所有的数据，$2\\leq n\\leq10^6$，$1\\leq k<n<a<b<10^{18}$，$b+1-a\\leq10^6$，串只含小写字母。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | $n\\leq100$，$b\\leq1000$ | 8 |\n| 2 | $b\\leq 10^8$ | 10 |\n| 3 | $n\\leq 500$，后缀 $R$ 的前一次出现将始终存在，并且每次出现后都会有相同的字母  | 16 |\n| 4 | 后缀 $R$ 的前一次出现将始终存在，并且每次出现后都会有相同的字母 | 10 |\n| 5 | $k\\leq20$，$b\\leq 10^{10}$，串只含 `ab` | 16 |\n| 6 | 无任何限制  | 40 |", "locale": "zh-CN"}}}
{"pid": "P9923", "type": "P", "difficulty": 5, "samples": [["3 6\n1 1\n1 2\n2 2\n3 1\n3 2\n3 3\n", "TAK\n4\n1 2 4 5\n"], ["9 1\n1 1\n", "NIE\n"], ["见附件", "TAK\n4\n1 2 10 11\n"], ["见附件", "TAK\n4\n1 2 100001 100002\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["图论", "POI（波兰）", "2023", "Special Judge", "构造"], "title": "[POI 2023/2024 R1] Przyciski", "background": "译自 [XXXI Olimpiada Informatyczna - I etap](https://sio2.mimuw.edu.pl/c/oi31-1/dashboard/) [Przyciski](https://sio2.mimuw.edu.pl/c/oi31-1/p/prz/)。", "description": "一个 $n\\times n$ 的方阵，里面有 $m$ 个按钮。\n\n你需要按下若干个（至少一个）按钮，使得每行每列被按下的按钮个数奇偶性相同。", "inputFormat": "第一行两个正整数 $n,m$。\n\n接下来 $m$ 行，每行两个正整数，表示一个按钮的坐标。", "outputFormat": "如果无解，输出一行 `NIE`。\n\n如果有解，第一行输出 `TAK`，第二行输出一个正整数 $k$，表示按下按钮的个数，第三行输出若干个正整数，表示你按下的按钮的编号。", "hint": "样例一解释：$R_1=2,R_2=0,R_3=2,C_1=C_2=2,C_3=0$。\n\n对于所有的数据，$1\\leq n\\leq 100000$，$1\\leq m\\leq\\min(n^2,500000)$。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | $m\\leq 20$ | 24 |\n| 2 | 如果有解，保证存在偶数解 | 24 |\n| 3 | 如果有解，保证存在奇数解 | 24 |\n| 4 |  | 28 |\n\n如果有解并且你指出有解但是构造错误，你能得到 $50\\%$ 的分数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2023/2024 R1] Przyciski", "background": "译自 [XXXI Olimpiada Informatyczna - I etap](https://sio2.mimuw.edu.pl/c/oi31-1/dashboard/) [Przyciski](https://sio2.mimuw.edu.pl/c/oi31-1/p/prz/)。", "description": "一个 $n\\times n$ 的方阵，里面有 $m$ 个按钮。\n\n你需要按下若干个（至少一个）按钮，使得每行每列被按下的按钮个数奇偶性相同。", "inputFormat": "第一行两个正整数 $n,m$。\n\n接下来 $m$ 行，每行两个正整数，表示一个按钮的坐标。", "outputFormat": "如果无解，输出一行 `NIE`。\n\n如果有解，第一行输出 `TAK`，第二行输出一个正整数 $k$，表示按下按钮的个数，第三行输出若干个正整数，表示你按下的按钮的编号。", "hint": "样例一解释：$R_1=2,R_2=0,R_3=2,C_1=C_2=2,C_3=0$。\n\n对于所有的数据，$1\\leq n\\leq 100000$，$1\\leq m\\leq\\min(n^2,500000)$。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | $m\\leq 20$ | 24 |\n| 2 | 如果有解，保证存在偶数解 | 24 |\n| 3 | 如果有解，保证存在奇数解 | 24 |\n| 4 |  | 28 |\n\n如果有解并且你指出有解但是构造错误，你能得到 $50\\%$ 的分数。", "locale": "zh-CN"}}}
{"pid": "P9924", "type": "P", "difficulty": 7, "samples": [["3 4 4\n1 4\n2 6\n3 4\n3 6\n", "3\nABA\nAAC\nBAA\nBBB\nCCB\nBCC\n"], ["见附件", "见附件"], ["见附件", "见附件"], ["2 1 4\n1 4\n", "2\nAB\nAC\nBA\nBB\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["POI（波兰）", "2023", "Special Judge", "构造"], "title": "[POI 2023/2024 R1] Satelity", "background": "译自 [XXXI Olimpiada Informatyczna - I etap](https://sio2.mimuw.edu.pl/c/oi31-1/dashboard/) [Satelity](https://sio2.mimuw.edu.pl/c/oi31-1/p/sat/)。", "description": "有 $2n$ 个卫星，$1\\sim n$ 属于 A 公司，$n+1\\sim 2n$ 属于 B 公司。\n\n两个卫星**应当**能够通信**当且仅当**它们属于同一个公司或者有额外要求。\n\n你需要给每个卫星分配一个等长的**独一无二**的识别码，识别码应当只包含字母 `ABC`，两个卫星**实际**能够通信**当且仅当**识别码有至少一位相同。要求你的识别码方案满足要求。输出你的方案。", "inputFormat": "本题多测，读入直到文件结束。\n\n对于每组数据，第一行三个正整数 $n,p,M$，其中 $M$ 意为你的识别码长度不得超过 $M$。\n\n接下来 $p$ 行，每行两个正整数，表示这两个卫星有额外要求应当能够通信。", "outputFormat": "对于每组数据，第一行一个正整数 $m(1\\leq m\\leq M)$，表示你的方案的识别码长度。\n\n接下来 $2n$ 行，每行一个长度为 $m$ 的只含 `ABC` 的字符串，识别码。", "hint": "单个输入文件不超过 40MB，请使用较快的输入输出方式。\n\n对于所有测试点，$1\\leq\\sum n\\leq 2\\times 10^6$，$1\\leq\\sum n^2\\leq10^7$。\n\n对于所有数据，$2\\leq n\\leq1000$，$1\\leq p\\leq n^2$。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | $n\\leq100$，$M=n^2+2n$ | 7 |\n| 2 | $M=3n$ | 11 |\n| 3 | $M=n+2\\lceil\\log_2n\\rceil$ | 23 |\n| 4 | $M=n+2$ | 41 |\n| 5 | $M=n+1$ | 18 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2023/2024 R1] Satelity", "background": "译自 [XXXI Olimpiada Informatyczna - I etap](https://sio2.mimuw.edu.pl/c/oi31-1/dashboard/) [Satelity](https://sio2.mimuw.edu.pl/c/oi31-1/p/sat/)。", "description": "有 $2n$ 个卫星，$1\\sim n$ 属于 A 公司，$n+1\\sim 2n$ 属于 B 公司。\n\n两个卫星**应当**能够通信**当且仅当**它们属于同一个公司或者有额外要求。\n\n你需要给每个卫星分配一个等长的**独一无二**的识别码，识别码应当只包含字母 `ABC`，两个卫星**实际**能够通信**当且仅当**识别码有至少一位相同。要求你的识别码方案满足要求。输出你的方案。", "inputFormat": "本题多测，读入直到文件结束。\n\n对于每组数据，第一行三个正整数 $n,p,M$，其中 $M$ 意为你的识别码长度不得超过 $M$。\n\n接下来 $p$ 行，每行两个正整数，表示这两个卫星有额外要求应当能够通信。", "outputFormat": "对于每组数据，第一行一个正整数 $m(1\\leq m\\leq M)$，表示你的方案的识别码长度。\n\n接下来 $2n$ 行，每行一个长度为 $m$ 的只含 `ABC` 的字符串，识别码。", "hint": "单个输入文件不超过 40MB，请使用较快的输入输出方式。\n\n对于所有测试点，$1\\leq\\sum n\\leq 2\\times 10^6$，$1\\leq\\sum n^2\\leq10^7$。\n\n对于所有数据，$2\\leq n\\leq1000$，$1\\leq p\\leq n^2$。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | $n\\leq100$，$M=n^2+2n$ | 7 |\n| 2 | $M=3n$ | 11 |\n| 3 | $M=n+2\\lceil\\log_2n\\rceil$ | 23 |\n| 4 | $M=n+2$ | 41 |\n| 5 | $M=n+1$ | 18 |", "locale": "zh-CN"}}}
{"pid": "P9925", "type": "P", "difficulty": 6, "samples": [["8\n1 5\n3 10\n4 8\n9 12\n11 16\n14 15\n20 22\n15 21\n", "3\n1 3\n4 6\n8 7\n"], ["见附件", "见附件"], ["见附件", "见附件"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "POI（波兰）", "2023", "Special Judge", "构造"], "title": "[POI 2023/2024 R1] Zapobiegliwy student", "background": "译自 [XXXI Olimpiada Informatyczna - I etap](https://sio2.mimuw.edu.pl/c/oi31-1/dashboard/) [Zapobiegliwy student](https://sio2.mimuw.edu.pl/c/oi31-1/p/zap/)。", "description": "考虑如下的一个简单问题：\n\n> 你有 $n$ 个线段在数轴上，你要选出尽量多的线段，使它们两两不交。\n\n我知道你一定会做，但你需要解决这个：\n\n你有 $n$ 个线段在数轴上，你要选出尽量多的线段对 $(u_i,v_i)_{i=1}^k$，即最大化 $k$。\n\n满足 $k+1$ 个要求：\n\n- $u_1,u_2,\\cdots,u_k$ 两两不交。\n- $v_1,u_2,u_3,\\cdots,u_k$ 两两不交。\n- $u_1,v_2,u_3,u_4,\\cdots,u_k$ 两两不交。\n- $\\cdots$\n- $u_1,u_2,\\cdots,u_{k-1},v_k$ 两两不交。\n\n其中 $\\forall i$，$u_i$ 与 $v_i$ 不能相同。", "inputFormat": "第一行一个正整数 $n(n\\geq2)$。\n\n接下来 $n$ 行每行两个正整数 $a_i,b_i(1\\leq a_i<b_i\\leq10^9)$，表示一个线段的两个端点。\n\n两个线段 $i,j$ 不交当且仅当 $b_i\\leq a_j$ 或 $b_j\\leq a_i$。", "outputFormat": "第一行一个正整数 $k$。\n\n接下来 $k$ 行，每行两个正整数 $u_i,v_i$，表示一对线段的编号。", "hint": "如果你的第一行正确但是方案不对（可以不输出方案，此时不要有换行），你能得到 $50\\%$ 的分数。\n\n如果你的方案合法并且第一行和答案相差不超过 $1$，你能得到 $15\\%$ 的分数。\n\n| 子任务编号 | 限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | $n\\leq3000$ | 40 |\n| 2 | $n\\leq500000$ | 60 |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2023/2024 R1] Zapobiegliwy student", "background": "译自 [XXXI Olimpiada Informatyczna - I etap](https://sio2.mimuw.edu.pl/c/oi31-1/dashboard/) [Zapobiegliwy student](https://sio2.mimuw.edu.pl/c/oi31-1/p/zap/)。", "description": "考虑如下的一个简单问题：\n\n> 你有 $n$ 个线段在数轴上，你要选出尽量多的线段，使它们两两不交。\n\n我知道你一定会做，但你需要解决这个：\n\n你有 $n$ 个线段在数轴上，你要选出尽量多的线段对 $(u_i,v_i)_{i=1}^k$，即最大化 $k$。\n\n满足 $k+1$ 个要求：\n\n- $u_1,u_2,\\cdots,u_k$ 两两不交。\n- $v_1,u_2,u_3,\\cdots,u_k$ 两两不交。\n- $u_1,v_2,u_3,u_4,\\cdots,u_k$ 两两不交。\n- $\\cdots$\n- $u_1,u_2,\\cdots,u_{k-1},v_k$ 两两不交。\n\n其中 $\\forall i$，$u_i$ 与 $v_i$ 不能相同。", "inputFormat": "第一行一个正整数 $n(n\\geq2)$。\n\n接下来 $n$ 行每行两个正整数 $a_i,b_i(1\\leq a_i<b_i\\leq10^9)$，表示一个线段的两个端点。\n\n两个线段 $i,j$ 不交当且仅当 $b_i\\leq a_j$ 或 $b_j\\leq a_i$。", "outputFormat": "第一行一个正整数 $k$。\n\n接下来 $k$ 行，每行两个正整数 $u_i,v_i$，表示一对线段的编号。", "hint": "如果你的第一行正确但是方案不对（可以不输出方案，此时不要有换行），你能得到 $50\\%$ 的分数。\n\n如果你的方案合法并且第一行和答案相差不超过 $1$，你能得到 $15\\%$ 的分数。\n\n| 子任务编号 | 限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | $n\\leq3000$ | 40 |\n| 2 | $n\\leq500000$ | 60 |\n", "locale": "zh-CN"}}}
{"pid": "P9926", "type": "P", "difficulty": 7, "samples": [["4 6 17\n1 2 4\n1 3 7\n1 4 6\n2 3 8\n2 4 5\n3 4 7\n", "16\n16\n17\n17\n17\n18\n18\n18\n18\n19\n19\n19\n20\n21\n21\n22\n-1\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["O2优化"], "title": "[NFLSPC #6] 所以 k 小生成树怎么做？", "background": "", "description": "给定一张无向带权无自环无重边的连通图，求前 $k$ 小生成树的权值。\n\n- 生成树的权值为其所有边权之和。\n- 两棵生成树不同，当且仅当存在一条边在一棵生成树上，但不在另一棵生成树上。\n- 若第 $i$ 小生成树不存在，则输出 $-1$。", "inputFormat": "第一行三个整数 $n, m, k$。\n\n接下来 $m$ 行，每行三个整数 $u_i, v_i, w_i$，分别表示无向边的两端及其权值。\n", "outputFormat": "输出 $k$ 行，第 $i$ 行一个整数表示第 $i$ 小生成树的权值。", "hint": "对于所有数据，$1\\leq n \\leq 5\\times 10 ^ 4$，$n - 1\\leq m\\leq 10 ^ 5$，$1\\leq k\\leq 10 ^ 5$，$1\\leq mk\\leq 10 ^ 7$，$1\\leq u_i, v_i\\leq n$，$1\\leq w_i\\leq 10 ^ 9$。保证图连通，无自环，无重边。\n\n- 子任务 1（$10$ 分）：$m ^ 2k\\leq 10 ^ 6$。\n- 子任务 2（$20$ 分）：保证每条边至多属于一个简单环。\n- 子任务 3（$20$ 分）：$mk\\leq 10 ^ 6$。\n- 子任务 4（$50$ 分）：无特殊限制。\n\nSource：NFLSPC #6 A by Alex_Wei", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NFLSPC #6] 所以 k 小生成树怎么做？", "background": "", "description": "给定一张无向带权无自环无重边的连通图，求前 $k$ 小生成树的权值。\n\n- 生成树的权值为其所有边权之和。\n- 两棵生成树不同，当且仅当存在一条边在一棵生成树上，但不在另一棵生成树上。\n- 若第 $i$ 小生成树不存在，则输出 $-1$。", "inputFormat": "第一行三个整数 $n, m, k$。\n\n接下来 $m$ 行，每行三个整数 $u_i, v_i, w_i$，分别表示无向边的两端及其权值。\n", "outputFormat": "输出 $k$ 行，第 $i$ 行一个整数表示第 $i$ 小生成树的权值。", "hint": "对于所有数据，$1\\leq n \\leq 5\\times 10 ^ 4$，$n - 1\\leq m\\leq 10 ^ 5$，$1\\leq k\\leq 10 ^ 5$，$1\\leq mk\\leq 10 ^ 7$，$1\\leq u_i, v_i\\leq n$，$1\\leq w_i\\leq 10 ^ 9$。保证图连通，无自环，无重边。\n\n- 子任务 1（$10$ 分）：$m ^ 2k\\leq 10 ^ 6$。\n- 子任务 2（$20$ 分）：保证每条边至多属于一个简单环。\n- 子任务 3（$20$ 分）：$mk\\leq 10 ^ 6$。\n- 子任务 4（$50$ 分）：无特殊限制。\n\nSource：NFLSPC #6 A by Alex_Wei", "locale": "zh-CN"}}}
{"pid": "P9927", "type": "P", "difficulty": 7, "samples": [["2\n1101\n1 1 1 1 1 1 1 1 1 1\n", "(!1|0)\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["提交答案", "Special Judge"], "title": "[NFLSPC #6] 真理祭坛", "background": "天色已晚，围观的人群散得差不多了。人们可能都没有注意到，还有一个瘦小的身影在向真理祭坛跑去。\n\n「你是哪个领域的科学家？怎么就你一个人？」排险者歪了歪头，看着眼前的小 Y 问道。\n\n「我不是科学家。我只是一个高中生。」\n\n「学生？」排险者很困惑，「那你想问什么？」\n\n「我想知道宇宙的终极规律。」\n\n「既然你只是个学生，你认为我该如何让你理解宇宙的规律呢？」\n\n「啊？」小 Y 似乎感到很惊讶，片刻之后，他的脸上出现了些许失望的神情。「宇宙的真理不应该简洁到每个人都能理解吗……难道不是吗？」\n\n「真理可没这么简单。且不说宇宙，我在此随意给你一些『道理』，你能用简洁的语言描述它吗？」\n\n小 Y 抬起头来，看着排险者用全息投影显示在天空中的几串密密麻麻的零和一，陷入了沉思。", "description": "有 $n$ 个 **命题变项**，记作 $P_0, P_1, \\cdots, P_{n - 1}$，其 **真值** 是一个布尔值，要么为 $0$ 要么为 $1$。\n\n我们称一个 **道理** 是一个输入 $n$ 个布尔值、输出一个布尔值的函数，即一个 $\\{0, 1\\}^n \\to \\{0, 1\\}$ 的映射。\n\n满足特定条件的字符串称为 **合式公式**（Well-Formed Formula，WFF），每个合式公式都对应着唯一一个道理，称为该公式的 **真值表**。具体地：\n\n- 一个命题变项 $P_i$ 是合式公式，它的真值表总是输出其所接受的第 $i$ 个输入值（$n$ 个输入值的编号依次为 $0, 1, \\cdots, n - 1$）。\n- 如果 $k$ 个字符串 $A_1, A_2, \\cdots, A_k$（$k \\geq 1$）都是合式公式，则 $(A_1 \\land A_2 \\land \\cdots \\land A_k)$ 也是合式公式，它的真值表在接受输入 $I$ 时输出的值为 $A_1, A_2, \\cdots, A_k$ 分别的真值表接受 $I$ 时输出的值的最小值。\n- 如果 $k$ 个字符串 $A_1, A_2, \\cdots, A_k$（$k \\geq 1$）都是合式公式，则 $(A_1 \\lor A_2 \\lor \\cdots \\lor A_k)$ 也是合式公式，它的真值表在接受输入 $I$ 时输出的值为 $A_1, A_2, \\cdots, A_k$ 分别的真值表接受 $I$ 时输出的值的最大值。\n- 如果 $A$ 是合式公式，则 $\\lnot A$ 也是合式公式，设 $A$ 的真值表接受输入 $I$ 时输出 $x$，则 $\\lnot A$ 的真值表接受 $I$ 时输出 $1 - x$。\n\n定义一个合式公式的 **大小** 为其所包含的 $\\land$ 和 $\\lor$ 的数量。现给定一个道理，请找到一个合式公式，使得其真值表是该道理，在此前提下让公式的大小尽可能小。", "inputFormat": "**本题为提交答案题**，所有数据 `formula1.in` 至 `formula10.in` 已在附加文件中。\n\n输入的第一行包含一个整数 $n$。\n\n输入的第二行包含一个长度为 $2^n$ 的字符串 $a_{0 \\sim 2^n - 1}$，描述给定的道理：如果对于任意 $0 \\leq i < n$，输入的第 $i$ 个值是 $\\left\\lfloor\\frac{x}{2^i}\\right\\rfloor \\bmod 2$，则道理的输出为 $a_x$。\n\n输入的第三行包含 $10$ 个评分参数，具体用处见「说明/提示」。", "outputFormat": "针对给定的 $10$ 个输入文件，你需要分别提交你的输出文件 `formula1.out` 至 `formula10.out`。\n\n每个输出文件包含一行，表示你给出的合式公式。其中括号用 `()` 表示，命题变项 $P_i$ 用数字 $i$ 表示（由于 $n \\leq 10$，这一定是单个字符），$\\land$ 用 `&` 表示，$\\lor$ 用 `|` 表示，$\\lnot$ 用 `!` 表示。**请不要擅自省略括号。**", "hint": "对于所有数据，$1 \\leq n \\leq 10$。\n\n对于每组数据，我们采用如下方式评分：\n\n- 如果你的输出长度大于 $10^5$，得 $0$ 分。\n- 如果你的输出不是合式公式，得 $0$ 分。\n- 如果你的合式公式的真值表与输入给定的道理不同，得 $0$ 分。\n- 如果上述条件都不满足，设 $s_{1 \\sim 10}$ 为评分参数，$S$ 为你的公式的大小，则得分为 $\\sum_{i = 1}^{10}[S \\leq s_i]$。\n\n每组数据满分 $10$ 分，共 $10$ 组数据，总分 $100$ 分（乘以得分系数前）。**保证存在满分解**。\n\n---\n\n我们提供了工具来测试你的输出。\n\n下载附加文件 `checker.cpp` 并编译得到可执行文件 `checker.exe`（Windows）或 `checker`（Linux），其用法如下：\n\n- 在终端中输入 `checker.exe X`（Windows）或 `./checker X`（Linux），或直接运行后输入 `X` 并换行，可以对第 $X$ 组数据 `formulaX.in/out` 进行测试。\n- 在终端中输入 `checker.exe A B`（Windows）或 `./checker A B`（Linux），或直接运行后输入 `A B` 并换行，可以对输入文件名为 $A$、输出文件名为 $B$ 的数据进行测试。\n- 如果输入不合法或输出有错误，会有相应提示。\n- 如果没有错误，则会给出你的合式公式的大小。\n- 输入文件可以与输入格式的描述完全相符，也可以略去评分参数一行。若 checker 检测到存在评分参数一行，还会给出你的得分。\n\nSource：NFLSPC #6 C by chenxia25", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NFLSPC #6] 真理祭坛", "background": "天色已晚，围观的人群散得差不多了。人们可能都没有注意到，还有一个瘦小的身影在向真理祭坛跑去。\n\n「你是哪个领域的科学家？怎么就你一个人？」排险者歪了歪头，看着眼前的小 Y 问道。\n\n「我不是科学家。我只是一个高中生。」\n\n「学生？」排险者很困惑，「那你想问什么？」\n\n「我想知道宇宙的终极规律。」\n\n「既然你只是个学生，你认为我该如何让你理解宇宙的规律呢？」\n\n「啊？」小 Y 似乎感到很惊讶，片刻之后，他的脸上出现了些许失望的神情。「宇宙的真理不应该简洁到每个人都能理解吗……难道不是吗？」\n\n「真理可没这么简单。且不说宇宙，我在此随意给你一些『道理』，你能用简洁的语言描述它吗？」\n\n小 Y 抬起头来，看着排险者用全息投影显示在天空中的几串密密麻麻的零和一，陷入了沉思。", "description": "有 $n$ 个 **命题变项**，记作 $P_0, P_1, \\cdots, P_{n - 1}$，其 **真值** 是一个布尔值，要么为 $0$ 要么为 $1$。\n\n我们称一个 **道理** 是一个输入 $n$ 个布尔值、输出一个布尔值的函数，即一个 $\\{0, 1\\}^n \\to \\{0, 1\\}$ 的映射。\n\n满足特定条件的字符串称为 **合式公式**（Well-Formed Formula，WFF），每个合式公式都对应着唯一一个道理，称为该公式的 **真值表**。具体地：\n\n- 一个命题变项 $P_i$ 是合式公式，它的真值表总是输出其所接受的第 $i$ 个输入值（$n$ 个输入值的编号依次为 $0, 1, \\cdots, n - 1$）。\n- 如果 $k$ 个字符串 $A_1, A_2, \\cdots, A_k$（$k \\geq 1$）都是合式公式，则 $(A_1 \\land A_2 \\land \\cdots \\land A_k)$ 也是合式公式，它的真值表在接受输入 $I$ 时输出的值为 $A_1, A_2, \\cdots, A_k$ 分别的真值表接受 $I$ 时输出的值的最小值。\n- 如果 $k$ 个字符串 $A_1, A_2, \\cdots, A_k$（$k \\geq 1$）都是合式公式，则 $(A_1 \\lor A_2 \\lor \\cdots \\lor A_k)$ 也是合式公式，它的真值表在接受输入 $I$ 时输出的值为 $A_1, A_2, \\cdots, A_k$ 分别的真值表接受 $I$ 时输出的值的最大值。\n- 如果 $A$ 是合式公式，则 $\\lnot A$ 也是合式公式，设 $A$ 的真值表接受输入 $I$ 时输出 $x$，则 $\\lnot A$ 的真值表接受 $I$ 时输出 $1 - x$。\n\n定义一个合式公式的 **大小** 为其所包含的 $\\land$ 和 $\\lor$ 的数量。现给定一个道理，请找到一个合式公式，使得其真值表是该道理，在此前提下让公式的大小尽可能小。", "inputFormat": "**本题为提交答案题**，所有数据 `formula1.in` 至 `formula10.in` 已在附加文件中。\n\n输入的第一行包含一个整数 $n$。\n\n输入的第二行包含一个长度为 $2^n$ 的字符串 $a_{0 \\sim 2^n - 1}$，描述给定的道理：如果对于任意 $0 \\leq i < n$，输入的第 $i$ 个值是 $\\left\\lfloor\\frac{x}{2^i}\\right\\rfloor \\bmod 2$，则道理的输出为 $a_x$。\n\n输入的第三行包含 $10$ 个评分参数，具体用处见「说明/提示」。", "outputFormat": "针对给定的 $10$ 个输入文件，你需要分别提交你的输出文件 `formula1.out` 至 `formula10.out`。\n\n每个输出文件包含一行，表示你给出的合式公式。其中括号用 `()` 表示，命题变项 $P_i$ 用数字 $i$ 表示（由于 $n \\leq 10$，这一定是单个字符），$\\land$ 用 `&` 表示，$\\lor$ 用 `|` 表示，$\\lnot$ 用 `!` 表示。**请不要擅自省略括号。**", "hint": "对于所有数据，$1 \\leq n \\leq 10$。\n\n对于每组数据，我们采用如下方式评分：\n\n- 如果你的输出长度大于 $10^5$，得 $0$ 分。\n- 如果你的输出不是合式公式，得 $0$ 分。\n- 如果你的合式公式的真值表与输入给定的道理不同，得 $0$ 分。\n- 如果上述条件都不满足，设 $s_{1 \\sim 10}$ 为评分参数，$S$ 为你的公式的大小，则得分为 $\\sum_{i = 1}^{10}[S \\leq s_i]$。\n\n每组数据满分 $10$ 分，共 $10$ 组数据，总分 $100$ 分（乘以得分系数前）。**保证存在满分解**。\n\n---\n\n我们提供了工具来测试你的输出。\n\n下载附加文件 `checker.cpp` 并编译得到可执行文件 `checker.exe`（Windows）或 `checker`（Linux），其用法如下：\n\n- 在终端中输入 `checker.exe X`（Windows）或 `./checker X`（Linux），或直接运行后输入 `X` 并换行，可以对第 $X$ 组数据 `formulaX.in/out` 进行测试。\n- 在终端中输入 `checker.exe A B`（Windows）或 `./checker A B`（Linux），或直接运行后输入 `A B` 并换行，可以对输入文件名为 $A$、输出文件名为 $B$ 的数据进行测试。\n- 如果输入不合法或输出有错误，会有相应提示。\n- 如果没有错误，则会给出你的合式公式的大小。\n- 输入文件可以与输入格式的描述完全相符，也可以略去评分参数一行。若 checker 检测到存在评分参数一行，还会给出你的得分。\n\nSource：NFLSPC #6 C by chenxia25", "locale": "zh-CN"}}}
{"pid": "P9928", "type": "P", "difficulty": 3, "samples": [["4 1\n4 2 1 3\n", "3\n2 3 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["Special Judge", "O2优化"], "title": "[NFLSPC #6] 来点不那么魔怔的题面", "background": "", "description": "给定一个 $1\\sim n$ 的排列 $p$ 和一个整数 $k$，要求找到 $p$ 的一个子序列 $\\{p_{i_1}, p_{i_2}, \\cdots, p_{i_m}\\}$（$1\\le i_1 < i_2 < \\cdots < i_m\\le n$）满足：\n\n- 恰好有 $k$ 个 $j$ 满足 $1\\le j\\le m$ 且 $p_{i_j}$ 是 $p_{i_1}, p_{i_2}, \\cdots, p_{i_m}$ 中从小往大数第 $j$ 个。\n\n如果有多解，输出任意一组解即可。如果不存在合法的子序列，输出 $-1$。", "inputFormat": "第一行两个整数 $n, k$。\n\n接下来一行 $n$ 个整数 $p_1, p_2, \\cdots, p_n$ 表示给定的排列。", "outputFormat": "如果无解，输出一行一个整数 $-1$。\n\n否则第一行输出一个整数 $m$ 表示子序列的长度。你需要保证 $1\\le m\\le n$。\n\n接下来一行输出 $m$ 个整数 $i_1, i_2, \\cdots, i_m$ 表示子序列的下标。你需要保证 $1\\le i_j\\le n$ 且 $i_j < i_{j+1}$（$1\\le j < m$）。", "hint": "对于所有数据，$1\\le n\\le 10 ^ 5$，$1\\le k\\le n$，$p_1, p_2, \\cdots, p_n$ 为 $1\\sim n$ 的排列。\n\n- 子任务 1（$10$ 分）：$n\\leq 20$。\n- 子任务 2（$10$ 分）：$k = 2$。\n- 子任务 3（$30$ 分）：$k = 3$。\n- 子任务 4（$30$ 分）：$n\\leq 10 ^ 3$。\n- 子任务 5（$20$ 分）：无特殊限制。\n\nSource：NFLSPC #6 D by tzc_wk", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NFLSPC #6] 来点不那么魔怔的题面", "background": "", "description": "给定一个 $1\\sim n$ 的排列 $p$ 和一个整数 $k$，要求找到 $p$ 的一个子序列 $\\{p_{i_1}, p_{i_2}, \\cdots, p_{i_m}\\}$（$1\\le i_1 < i_2 < \\cdots < i_m\\le n$）满足：\n\n- 恰好有 $k$ 个 $j$ 满足 $1\\le j\\le m$ 且 $p_{i_j}$ 是 $p_{i_1}, p_{i_2}, \\cdots, p_{i_m}$ 中从小往大数第 $j$ 个。\n\n如果有多解，输出任意一组解即可。如果不存在合法的子序列，输出 $-1$。", "inputFormat": "第一行两个整数 $n, k$。\n\n接下来一行 $n$ 个整数 $p_1, p_2, \\cdots, p_n$ 表示给定的排列。", "outputFormat": "如果无解，输出一行一个整数 $-1$。\n\n否则第一行输出一个整数 $m$ 表示子序列的长度。你需要保证 $1\\le m\\le n$。\n\n接下来一行输出 $m$ 个整数 $i_1, i_2, \\cdots, i_m$ 表示子序列的下标。你需要保证 $1\\le i_j\\le n$ 且 $i_j < i_{j+1}$（$1\\le j < m$）。", "hint": "对于所有数据，$1\\le n\\le 10 ^ 5$，$1\\le k\\le n$，$p_1, p_2, \\cdots, p_n$ 为 $1\\sim n$ 的排列。\n\n- 子任务 1（$10$ 分）：$n\\leq 20$。\n- 子任务 2（$10$ 分）：$k = 2$。\n- 子任务 3（$30$ 分）：$k = 3$。\n- 子任务 4（$30$ 分）：$n\\leq 10 ^ 3$。\n- 子任务 5（$20$ 分）：无特殊限制。\n\nSource：NFLSPC #6 D by tzc_wk", "locale": "zh-CN"}}}
{"pid": "P9929", "type": "P", "difficulty": 5, "samples": [["7001 4001 7 5\n1155511307999246176590006\n", "6\n"], ["11083610 7305110 52 32\n4578384821991465584924042474394616310820101790\n", "39\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["O2优化"], "title": "[NFLSPC #6] 挑战大数因子分解", "background": "`NFLSPC #6` 在即，来不了现场的 *SolarPea* 要把自己的题目的 std 发给能去现场的 *PolarSea*。\n\n为了防止有选手窃听他们的通信以获得 std，他们打算使用一个公钥加密算法来确保通信的安全性。\n\n于是 *SolarPea* 使用了他在知乎上看到的有 “最大的加解密速度和安全性” 的算法，这个算法的安全性 “依赖于大数因子分解难题”：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bc5hi2d2.png)\n\n你是一名拥有 `factorization oracle` 的参赛选手，并且你已经获得了公钥和明文。请你利用手上的 `factorization oracle`，破解出 std 吧。", "description": "由于图片可能看不清，我们重新描述这个加密算法：\n\n- 假设 *SolarPea* 要给 *PolarSea* 发一个消息 $M'$，那么他们会进行如下的操作。\n- *PolarSea* 首先生成五个大整数 $P, S_4, S_6, S_7, S_1$，使得 $P < S_6 < S_4P$ 且 $S_5 = S_4P + S_6$ 且 $(S_6\\bmod P) ^ 3 < S_4 ^ 3 < S_1 ^ 3 < (S_1 + 1) ^ 3 < S_7 ^ 3 < P$，并计算 $S_3 = S_4P + S_5$。\n- 然后 *PolarSea* 将 $S_3, S_5, S_7, S_1$ 发给 *SolarPea*。\n- *SolarPea* 拿到了 *PolarSea* 给他发的四个数。首先，他需要构造一个 $M$ 使得 $S_1 < M < S_7$，并且和 *PolarSea* 商量好一个通过 $M$ 算出 $M'$ 的方法（例如若 $M'$ 为比较小的正整数，则可以令 $M = M' + S_1$），这个方法是不保密的，所以拿到 $M$ 就相当于拿到 $M'$ 了，所以你可以不用关心 $M'$ 而是只关心 $M$。\n- *SolarPea* 生成了两个满足 $(S_3 - S_5) ^ 3 < r < w$ 的数 $w, r$，并计算 $C = (S_3 - S_5) ^ 3w + MS_5 + r(S_3 - S_5)$，然后将 $C$ 发给 *PolarSea*。\n- *PolarSea* 只需计算 $\\frac{C \\operatorname{\\bmod} P}{(2S_5 - S_3) \\operatorname{\\bmod} P}$ 即可获得 $M$。\n\n现在你截获了 *PolarSea* 和 *SolarPea* 之间的所有通信（即 $S_3, S_5, S_7, S_1, C$），请你利用已知的信息破解出 $M$。", "inputFormat": "第一行，读入四个整数 $S_3, S_5, S_7, S_1$，表示公钥。\n\n第二行，读入一个整数 $C$，表示密文。", "outputFormat": "输出一行，包含一个值在 $S_1 < M < S_7$ 的整数 $M$，表示破解的明文。可以证明在给定限制下 $M$ 唯一。", "hint": "### 样例 1 解释\n\n生成的 $P=1000$，$S_4=3$，$S_6=1001$，$S_7=7$，$S_1=5$。计算出的 $S_5=4001$，$S_3=7001$。\n\n密文 $M=6$。加密时选取的 $w=42796713439376$，$r=15045364725522$，加密结果 $C=1155511307999246176590006$。\n\n当然，这次加密是很弱的，因为 $6$ 是 $5$ 和 $7$ 中间的唯一整数。\n\n### 数据范围与约定\n\n对于所有数据， $P < 10 ^ {500}$，$C < P^{10}$。\n\n- 子任务 1（$20$ 分）：$P < 10 ^ 6$。\n- 子任务 2（$20$ 分）：$P < 10 ^ {18}$。\n- 子任务 3（$20$ 分）：$P$ 为质数。\n- 子任务 4（$20$ 分）：所有数均为随机生成。\n- 子任务 5（$20$ 分）：无特殊限制。\n\nSource：NFLSPC #6 E by asmend", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NFLSPC #6] 挑战大数因子分解", "background": "`NFLSPC #6` 在即，来不了现场的 *SolarPea* 要把自己的题目的 std 发给能去现场的 *PolarSea*。\n\n为了防止有选手窃听他们的通信以获得 std，他们打算使用一个公钥加密算法来确保通信的安全性。\n\n于是 *SolarPea* 使用了他在知乎上看到的有 “最大的加解密速度和安全性” 的算法，这个算法的安全性 “依赖于大数因子分解难题”：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bc5hi2d2.png)\n\n你是一名拥有 `factorization oracle` 的参赛选手，并且你已经获得了公钥和明文。请你利用手上的 `factorization oracle`，破解出 std 吧。", "description": "由于图片可能看不清，我们重新描述这个加密算法：\n\n- 假设 *SolarPea* 要给 *PolarSea* 发一个消息 $M'$，那么他们会进行如下的操作。\n- *PolarSea* 首先生成五个大整数 $P, S_4, S_6, S_7, S_1$，使得 $P < S_6 < S_4P$ 且 $S_5 = S_4P + S_6$ 且 $(S_6\\bmod P) ^ 3 < S_4 ^ 3 < S_1 ^ 3 < (S_1 + 1) ^ 3 < S_7 ^ 3 < P$，并计算 $S_3 = S_4P + S_5$。\n- 然后 *PolarSea* 将 $S_3, S_5, S_7, S_1$ 发给 *SolarPea*。\n- *SolarPea* 拿到了 *PolarSea* 给他发的四个数。首先，他需要构造一个 $M$ 使得 $S_1 < M < S_7$，并且和 *PolarSea* 商量好一个通过 $M$ 算出 $M'$ 的方法（例如若 $M'$ 为比较小的正整数，则可以令 $M = M' + S_1$），这个方法是不保密的，所以拿到 $M$ 就相当于拿到 $M'$ 了，所以你可以不用关心 $M'$ 而是只关心 $M$。\n- *SolarPea* 生成了两个满足 $(S_3 - S_5) ^ 3 < r < w$ 的数 $w, r$，并计算 $C = (S_3 - S_5) ^ 3w + MS_5 + r(S_3 - S_5)$，然后将 $C$ 发给 *PolarSea*。\n- *PolarSea* 只需计算 $\\frac{C \\operatorname{\\bmod} P}{(2S_5 - S_3) \\operatorname{\\bmod} P}$ 即可获得 $M$。\n\n现在你截获了 *PolarSea* 和 *SolarPea* 之间的所有通信（即 $S_3, S_5, S_7, S_1, C$），请你利用已知的信息破解出 $M$。", "inputFormat": "第一行，读入四个整数 $S_3, S_5, S_7, S_1$，表示公钥。\n\n第二行，读入一个整数 $C$，表示密文。", "outputFormat": "输出一行，包含一个值在 $S_1 < M < S_7$ 的整数 $M$，表示破解的明文。可以证明在给定限制下 $M$ 唯一。", "hint": "### 样例 1 解释\n\n生成的 $P=1000$，$S_4=3$，$S_6=1001$，$S_7=7$，$S_1=5$。计算出的 $S_5=4001$，$S_3=7001$。\n\n密文 $M=6$。加密时选取的 $w=42796713439376$，$r=15045364725522$，加密结果 $C=1155511307999246176590006$。\n\n当然，这次加密是很弱的，因为 $6$ 是 $5$ 和 $7$ 中间的唯一整数。\n\n### 数据范围与约定\n\n对于所有数据， $P < 10 ^ {500}$，$C < P^{10}$。\n\n- 子任务 1（$20$ 分）：$P < 10 ^ 6$。\n- 子任务 2（$20$ 分）：$P < 10 ^ {18}$。\n- 子任务 3（$20$ 分）：$P$ 为质数。\n- 子任务 4（$20$ 分）：所有数均为随机生成。\n- 子任务 5（$20$ 分）：无特殊限制。\n\nSource：NFLSPC #6 E by asmend", "locale": "zh-CN"}}}
{"pid": "P9930", "type": "P", "difficulty": 3, "samples": [["1\n0 1\n", "11\n"]], "limits": {"time": [1000, 1000], "memory": [1048576, 1048576]}, "tags": ["O2优化"], "title": "[NFLSPC #6] 1064 病毒", "background": "你的电脑中了 1064 病毒，现在电脑里储存的所有数字都开始坍缩了！\n\n为了更彻底地毁灭你的电脑，对于十进制下的 $n$ 位数，邪恶的 1064 病毒会将它按照某种规则迭代至少 $n + 1$ 次，以确保你无法还原。\n\n面对 1064 病毒，你手足无措。但是作为 OIer 的你想知道道道道道道道道道道道到到到到到到到到\n\n", "description": "定义数字串为只含有数码 $0\\sim 9$ 的串，奇数数码为 $1, 3, 5, 7, 9$，偶数数码为 $0, 2, 4, 6, 8$。\n\n对数字串 $x$，设其中奇数数码，偶数数码和总数码个数分别为 $a, b, c$，则 $a + b = c = |x|$。定义 $g(x)$ 为将 $a, b, c$ 依次写下得到的数字串，**不忽略前导零**。例如 $g(\\texttt{0}) = \\texttt {011}$，$g(\\texttt{1064}) = \\texttt{134}$，$g(\\texttt {822}) = \\texttt {033}$，$g(\\texttt{1092515503}) = \\texttt{7310}$。\n\n设 $f_k(x)$ 表示将 **数字** $x$ **忽略前导零** 写成数字串 $x'$ 后，将 $g(x')$ 迭代 $k$ 次得到的数字串对应的数字，即设 $x ^ * = g(g(\\cdots g(x')))$（共有 $k$ 个 $g$），则 $f_k(x)$ 为将 $x ^ *$ 写成数字后的结果。\n\n给定 $n, k$（**保证 $n < k$**），求 $\\sum_{i = 0} ^ {10 ^ n - 1} f_k(i)$。\n\n多组数据。", "inputFormat": "第一行一个整数 $T$。\n\n接下来 $T$ 行，每行两个整数 $n, k$ 表示一组数据。", "outputFormat": "对每组数据，输出一行一个整数表示答案。", "hint": "对于所有数据，$1\\leq T\\leq 60$，$0\\leq n < k \\leq 10 ^ 5$，$\\sum k\\leq 10 ^ 5$。\n\n- 测试点 1（$30$ 分）：$n\\leq 5$，$k\\leq 15$。  \n- 测试点 2（$70$ 分）：无特殊限制。\n\nSource：NFLSPC #6 F by Alex_Wei", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NFLSPC #6] 1064 病毒", "background": "你的电脑中了 1064 病毒，现在电脑里储存的所有数字都开始坍缩了！\n\n为了更彻底地毁灭你的电脑，对于十进制下的 $n$ 位数，邪恶的 1064 病毒会将它按照某种规则迭代至少 $n + 1$ 次，以确保你无法还原。\n\n面对 1064 病毒，你手足无措。但是作为 OIer 的你想知道道道道道道道道道道道到到到到到到到到\n\n", "description": "定义数字串为只含有数码 $0\\sim 9$ 的串，奇数数码为 $1, 3, 5, 7, 9$，偶数数码为 $0, 2, 4, 6, 8$。\n\n对数字串 $x$，设其中奇数数码，偶数数码和总数码个数分别为 $a, b, c$，则 $a + b = c = |x|$。定义 $g(x)$ 为将 $a, b, c$ 依次写下得到的数字串，**不忽略前导零**。例如 $g(\\texttt{0}) = \\texttt {011}$，$g(\\texttt{1064}) = \\texttt{134}$，$g(\\texttt {822}) = \\texttt {033}$，$g(\\texttt{1092515503}) = \\texttt{7310}$。\n\n设 $f_k(x)$ 表示将 **数字** $x$ **忽略前导零** 写成数字串 $x'$ 后，将 $g(x')$ 迭代 $k$ 次得到的数字串对应的数字，即设 $x ^ * = g(g(\\cdots g(x')))$（共有 $k$ 个 $g$），则 $f_k(x)$ 为将 $x ^ *$ 写成数字后的结果。\n\n给定 $n, k$（**保证 $n < k$**），求 $\\sum_{i = 0} ^ {10 ^ n - 1} f_k(i)$。\n\n多组数据。", "inputFormat": "第一行一个整数 $T$。\n\n接下来 $T$ 行，每行两个整数 $n, k$ 表示一组数据。", "outputFormat": "对每组数据，输出一行一个整数表示答案。", "hint": "对于所有数据，$1\\leq T\\leq 60$，$0\\leq n < k \\leq 10 ^ 5$，$\\sum k\\leq 10 ^ 5$。\n\n- 测试点 1（$30$ 分）：$n\\leq 5$，$k\\leq 15$。  \n- 测试点 2（$70$ 分）：无特殊限制。\n\nSource：NFLSPC #6 F by Alex_Wei", "locale": "zh-CN"}}}
{"pid": "P9931", "type": "P", "difficulty": 6, "samples": [["3\n5\nI 1 7 1 3\nG 4\nA 2\nG 2\nE\n6\nA 2\nI 2 3 5 1\nE\nG 4\nA 1\nE\n4\nA 1\nG 1\nE\nE\n", "No\n2\nYes\n3\nNo\n@Turing ?\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["O2优化", "动态树 LCT"], "title": "[NFLSPC #6] 挑战停机问题", "background": "作为新时代的 OIer/XCPCer，你已经不满足于挑战 NPC 问题了。你想挑战数学的不可判定性——图灵停机问题。", "description": "图灵给了你一个程序。程序开始运行之初，有且仅有一个变量 $A$，初始值为 $0$。程序共有 $n$ 行，行号为 $1 \\sim n$，每行是如下几种形式之一：\n\n- `A a`：令 $A \\gets A + a$，然后执行下一行。\n- `G x`：执行第 $x$ 行。\n- `I l r x y`：如果 $A \\in [l, r]$ 则执行第 $x$ 行，否则执行第 $y$ 行。\n- `E`：直接结束程序。\n\n保证最后一行是 `E`。\n\n图灵希望你判断这个程序从第一行开始执行会不会结束。为了进一步检验你到底是不是真的会判定停机问题（还是装的？），图灵还要求你给出 $A$ 最终的值，如果程序不会结束且不存在一个时刻使得在其以后 $A$ 不再变化，则输出 `@Turing ?`。", "inputFormat": "本题多测。第一行一个正整数 $T$ 表示数据组数，对于每组数据：\n\n- 第一行一个整数 $n$，表示程序的行数。\n- 接下来 $n$ 行，描述程序。", "outputFormat": "对于每个询问，输出两行：\n\n- 第一行一个字符串 `Yes` 或 `No`，表示程序是否会结束。\n- 第二行一个整数 $A_{0}$ 或字符串 `@Turing ?`，表示 $A$ 最终的值。", "hint": "对于所有数据，$1 \\leq T \\leq 1000$，$1 \\leq n, \\sum n \\leq 10^5$，$1 \\leq a \\leq 10^9$，$0 \\leq l \\leq r \\leq 10^9$，$1 \\leq x, y \\leq n$。保证输入涉及到的所有数字都是整数。\n\n- 子任务 1（15 分）：不存在 `I` 类语句。\n- 子任务 2（20 分）：$r \\leq 100$。\n- 子任务 3（40 分）：$\\sum \\max r \\leq 10^5$。\n- 子任务 4（25 分）：无特殊限制。\n\nSource：NFLSPC #6 G by chenxia25", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NFLSPC #6] 挑战停机问题", "background": "作为新时代的 OIer/XCPCer，你已经不满足于挑战 NPC 问题了。你想挑战数学的不可判定性——图灵停机问题。", "description": "图灵给了你一个程序。程序开始运行之初，有且仅有一个变量 $A$，初始值为 $0$。程序共有 $n$ 行，行号为 $1 \\sim n$，每行是如下几种形式之一：\n\n- `A a`：令 $A \\gets A + a$，然后执行下一行。\n- `G x`：执行第 $x$ 行。\n- `I l r x y`：如果 $A \\in [l, r]$ 则执行第 $x$ 行，否则执行第 $y$ 行。\n- `E`：直接结束程序。\n\n保证最后一行是 `E`。\n\n图灵希望你判断这个程序从第一行开始执行会不会结束。为了进一步检验你到底是不是真的会判定停机问题（还是装的？），图灵还要求你给出 $A$ 最终的值，如果程序不会结束且不存在一个时刻使得在其以后 $A$ 不再变化，则输出 `@Turing ?`。", "inputFormat": "本题多测。第一行一个正整数 $T$ 表示数据组数，对于每组数据：\n\n- 第一行一个整数 $n$，表示程序的行数。\n- 接下来 $n$ 行，描述程序。", "outputFormat": "对于每个询问，输出两行：\n\n- 第一行一个字符串 `Yes` 或 `No`，表示程序是否会结束。\n- 第二行一个整数 $A_{0}$ 或字符串 `@Turing ?`，表示 $A$ 最终的值。", "hint": "对于所有数据，$1 \\leq T \\leq 1000$，$1 \\leq n, \\sum n \\leq 10^5$，$1 \\leq a \\leq 10^9$，$0 \\leq l \\leq r \\leq 10^9$，$1 \\leq x, y \\leq n$。保证输入涉及到的所有数字都是整数。\n\n- 子任务 1（15 分）：不存在 `I` 类语句。\n- 子任务 2（20 分）：$r \\leq 100$。\n- 子任务 3（40 分）：$\\sum \\max r \\leq 10^5$。\n- 子任务 4（25 分）：无特殊限制。\n\nSource：NFLSPC #6 G by chenxia25", "locale": "zh-CN"}}}
{"pid": "P9932", "type": "P", "difficulty": 7, "samples": [["5 25\n-1 0 1 1 0\n0 1 0 2 2\n0 0\n0 1\n0 2\n0 3\n0 4\n1 0\n1 1\n1 2\n1 3\n1 4\n2 0\n2 1\n2 2\n2 3\n2 4\n3 0\n3 1\n3 2\n3 3\n3 4\n4 0\n4 1\n4 2\n4 3\n4 4\n", "0\n-1\n-1\n-1\n-1\n0\n1\n-1\n-1\n-1\n2\n1\n-1\n-1\n-1\n0\n1\n3\n-1\n-1\n0\n-1\n4\n-1\n-1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["交互题", "Special Judge", "O2优化"], "title": "[NFLSPC #6] 树", "background": "# 请不要使用 C++14 (GCC 9) 提交", "description": "给定一棵 $n$ 个点的树，标号从 $0$ 到 $n-1$，每个点有一个 $0$ 到 $n-1$ 之间的颜色。\n\n$q$ 次询问，每次查询 $x$ 的祖先中颜色为 $c$ 的点中离 $x$ 最近的一个（也就是深度最大的一个）的编号，**强制在线**。\n\n**点的颜色在数据生成完之后进行了一次随机打乱（也就是作用了一个均匀随机的排列）**。", "inputFormat": "**由于本题输入量较大，我们采用交互题的方式进行评测**。\n\n你不需要也不应该实现主函数 `main`，你需要实现以下两个函数：\n\n```\nextern \"C\" void init(int n,vector<int> fa,vector<int> col)\n```\n\n* $n$：节点的个数。\n* $fa$：长度为 $n$ 的数组，$fa_i$ 表示节点 $i$ 的父亲。特别地，$fa_0=-1$。\n* $col$：长度为 $n$ 的数组，$col_i$ 表示节点 $i$ 的颜色。再次强调：**$col$ 在数据生成完之后进行了一次随机打乱**。\n* 这个函数会被调用恰好一次，它给了你树的信息。你可以在这次函数调用的时候计算一些需要用到的信息。\n\n```\nextern \"C\"  int query(int x,int c)\n```\n\n* $x$：查询的节点编号。\n* $c$：查询的颜色。\n* 你应该返回 $x$ 的祖先中离 $x$ 最近的颜色为 $c$ 的节点的编号。若不存在这样的节点，返回 `-1`。\n* 这个函数恰好被调用 $q$ 次。\n* 每次调用函数时你并不知道以后的询问，也就是说，询问是 **强制在线** 的。\n\n\n使用下发 grader 测试代码时，输入格式为：\n\n- 第一行输入两个数 $n,q$。\n- 第二行输入 $n$ 个数 $fa_0,\\cdots,fa_{n-1}$。\n- 第三行输入 $n$ 个数 $col_0,\\cdots,col_{n-1}$。\n- 接下来 $q$ 行，每行两个数 $x,c$，表示一组询问。", "outputFormat": "测试代码时，输出格式为：\n\n- $q$ 行，每行一个数，表示答案。\n- 接下来，下发 grader 会输出你的耗时（注意这里并不会检查正确性）。\n\n注意：这里给出的输入输出格式为下发 grader 的输入输出格式，仅为测试使用，**你实现的函数不应该对标准输入输出流进行任何操作**。", "hint": "对于所有数据，$2\\leq n\\leq 2\\times 10^6$，$q=5n\\leq 10^7$，$-1\\leq fa_i<i$，$0\\leq col_i<n$，$fa_0=-1$ 且对任意 $1\\leq i < n$，$fa_i\\geq 0$。\n\n- 子任务 1（$5$ 分）：$n\\leq 1000$。\n- 子任务 2（$20$ 分）：$n\\leq 200000$。\n- 子任务 3（$30$ 分）：$fa_i=i-1$。\n- 子任务 4（$45$ 分）：无特殊限制。\n\n每个子任务评分方式为子任务内所有点的得分取最小值。交互库运行时长不超过 600ms，消耗空间不超过 140MB。\n\n**本题在 OJ 上显示的时限不是真正的时限**。若你的代码没有在规定的时间和空间内正常运行并正确回答所有询问，该测试点获得 0 分。若你实现的函数运行时间不小于 2400ms，你将获得 `Time Limit Exceeded`（实际测试时会通过让 grader 死循环来实现这一点）。否则若你实现的函数共运行了 $x$（$x<2400$） 毫秒，你获得的分数为：\n- $x\\leq 1200$，返回 `Accepted`, 获得该测试点全部分数。\n- $1200<x<2400$，返回 `Partially Correct`, 获得该测试点 $(\\frac {2400 - x} {1200}) ^ 2$ 倍的分数。\n\n**测试点信息上显示的不是真正的耗时，SPJ 详细信息里显示的才是你实现的部分的耗时**。\n\nSource：NFLSPC #6 H by asmend", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NFLSPC #6] 树", "background": "# 请不要使用 C++14 (GCC 9) 提交", "description": "给定一棵 $n$ 个点的树，标号从 $0$ 到 $n-1$，每个点有一个 $0$ 到 $n-1$ 之间的颜色。\n\n$q$ 次询问，每次查询 $x$ 的祖先中颜色为 $c$ 的点中离 $x$ 最近的一个（也就是深度最大的一个）的编号，**强制在线**。\n\n**点的颜色在数据生成完之后进行了一次随机打乱（也就是作用了一个均匀随机的排列）**。", "inputFormat": "**由于本题输入量较大，我们采用交互题的方式进行评测**。\n\n你不需要也不应该实现主函数 `main`，你需要实现以下两个函数：\n\n```\nextern \"C\" void init(int n,vector<int> fa,vector<int> col)\n```\n\n* $n$：节点的个数。\n* $fa$：长度为 $n$ 的数组，$fa_i$ 表示节点 $i$ 的父亲。特别地，$fa_0=-1$。\n* $col$：长度为 $n$ 的数组，$col_i$ 表示节点 $i$ 的颜色。再次强调：**$col$ 在数据生成完之后进行了一次随机打乱**。\n* 这个函数会被调用恰好一次，它给了你树的信息。你可以在这次函数调用的时候计算一些需要用到的信息。\n\n```\nextern \"C\"  int query(int x,int c)\n```\n\n* $x$：查询的节点编号。\n* $c$：查询的颜色。\n* 你应该返回 $x$ 的祖先中离 $x$ 最近的颜色为 $c$ 的节点的编号。若不存在这样的节点，返回 `-1`。\n* 这个函数恰好被调用 $q$ 次。\n* 每次调用函数时你并不知道以后的询问，也就是说，询问是 **强制在线** 的。\n\n\n使用下发 grader 测试代码时，输入格式为：\n\n- 第一行输入两个数 $n,q$。\n- 第二行输入 $n$ 个数 $fa_0,\\cdots,fa_{n-1}$。\n- 第三行输入 $n$ 个数 $col_0,\\cdots,col_{n-1}$。\n- 接下来 $q$ 行，每行两个数 $x,c$，表示一组询问。", "outputFormat": "测试代码时，输出格式为：\n\n- $q$ 行，每行一个数，表示答案。\n- 接下来，下发 grader 会输出你的耗时（注意这里并不会检查正确性）。\n\n注意：这里给出的输入输出格式为下发 grader 的输入输出格式，仅为测试使用，**你实现的函数不应该对标准输入输出流进行任何操作**。", "hint": "对于所有数据，$2\\leq n\\leq 2\\times 10^6$，$q=5n\\leq 10^7$，$-1\\leq fa_i<i$，$0\\leq col_i<n$，$fa_0=-1$ 且对任意 $1\\leq i < n$，$fa_i\\geq 0$。\n\n- 子任务 1（$5$ 分）：$n\\leq 1000$。\n- 子任务 2（$20$ 分）：$n\\leq 200000$。\n- 子任务 3（$30$ 分）：$fa_i=i-1$。\n- 子任务 4（$45$ 分）：无特殊限制。\n\n每个子任务评分方式为子任务内所有点的得分取最小值。交互库运行时长不超过 600ms，消耗空间不超过 140MB。\n\n**本题在 OJ 上显示的时限不是真正的时限**。若你的代码没有在规定的时间和空间内正常运行并正确回答所有询问，该测试点获得 0 分。若你实现的函数运行时间不小于 2400ms，你将获得 `Time Limit Exceeded`（实际测试时会通过让 grader 死循环来实现这一点）。否则若你实现的函数共运行了 $x$（$x<2400$） 毫秒，你获得的分数为：\n- $x\\leq 1200$，返回 `Accepted`, 获得该测试点全部分数。\n- $1200<x<2400$，返回 `Partially Correct`, 获得该测试点 $(\\frac {2400 - x} {1200}) ^ 2$ 倍的分数。\n\n**测试点信息上显示的不是真正的耗时，SPJ 详细信息里显示的才是你实现的部分的耗时**。\n\nSource：NFLSPC #6 H by asmend", "locale": "zh-CN"}}}
{"pid": "P9933", "type": "P", "difficulty": 6, "samples": [["1\n3 30 8\n0 2 1\n6 5 2\n25 4 4\n1\n5\n9\n10\n11\n12\n13\n14\n", "0\n8\n16\n19\n23\n27\n31\n36\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["O2优化"], "title": "[NFLSPC #6] 9.pop_book();", "background": "*Alek 岁*在操场上跑圈。他看到有人超过他，很不爽。于是他采取了以下策略：", "description": "在长度为 $m$ 的环形操场上有 $n$ 个人，第 $i$ 个人在 $t_i$ 时刻从位置 $p_i$ 出发以 $v_i$ 单位长度每秒的速度移动。现在 $0$ 时刻 *Alek 岁*在位置 $0$ 处，速度为 $0$，会跟着经过他的速度最快的人移动。$q$ 次询问 $T_i$ 时刻 *Alek 岁*的移动距离。可以证明这是一个整数。\n\n注：从位置 $0$ 出发逆时针方向 $x$（$0\\leq x < m$）单位长度的位置称为位置 $x$。所有人的运动方向都是逆时针。\n\n多组数据。", "inputFormat": "第一行一个整数 $T$ 表示数据组数。对于每组数据：\n\n- 第一行三个整数 $n, m, q$，分别表示人数，操场长度和询问个数。\n- 接下来 $n$ 行，每行三个整数 $p_i, v_i, t_i$，分别表示第 $i$ 个人出发时的位置，移动速度（单位长度每秒）和出发时间。\n- 接下来 $q$ 行，每行一个整数 $T_i$ 表示一次询问。", "outputFormat": "对于每个询问，输出一行一个整数表示答案。", "hint": "对于所有数据，$1\\leq T\\leq 10 ^ 3$，$1\\leq n, \\sum n\\leq 5\\times 10 ^ 5$，$1\\leq m, q, \\sum q \\leq 10 ^ 6$，$1\\leq v_i, t_i, T_i\\leq 10 ^ 9$，$0\\leq p_i < m$。保证 $t_i$ 单调不降，$T_i$ 单调递增。\n\n- 子任务 1（$10$ 分）：$n\\leq 5$。\n- 子任务 2（$10$ 分）：$n\\leq 50$。\n- 子任务 3（$20$ 分）：$n\\leq 500$。\n- 子任务 4（$20$ 分）：$n\\leq 5\\times 10 ^ 3$。\n- 子任务 5（$20$ 分）：$n\\leq 5\\times 10 ^ 4$。\n- 子任务 6（$20$ 分）：无特殊限制。\n\n**请注意，子任务并没有保证 $\\sum q$ 的数量级**。\n\n本题 IO 量较大，建议使用 `scanf/printf` 或关闭流同步的 `cin/cout` 或快速读入和快速输出。\n\nSource：NFLSPC #6 I by Alex_Wei", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NFLSPC #6] 9.pop_book();", "background": "*Alek 岁*在操场上跑圈。他看到有人超过他，很不爽。于是他采取了以下策略：", "description": "在长度为 $m$ 的环形操场上有 $n$ 个人，第 $i$ 个人在 $t_i$ 时刻从位置 $p_i$ 出发以 $v_i$ 单位长度每秒的速度移动。现在 $0$ 时刻 *Alek 岁*在位置 $0$ 处，速度为 $0$，会跟着经过他的速度最快的人移动。$q$ 次询问 $T_i$ 时刻 *Alek 岁*的移动距离。可以证明这是一个整数。\n\n注：从位置 $0$ 出发逆时针方向 $x$（$0\\leq x < m$）单位长度的位置称为位置 $x$。所有人的运动方向都是逆时针。\n\n多组数据。", "inputFormat": "第一行一个整数 $T$ 表示数据组数。对于每组数据：\n\n- 第一行三个整数 $n, m, q$，分别表示人数，操场长度和询问个数。\n- 接下来 $n$ 行，每行三个整数 $p_i, v_i, t_i$，分别表示第 $i$ 个人出发时的位置，移动速度（单位长度每秒）和出发时间。\n- 接下来 $q$ 行，每行一个整数 $T_i$ 表示一次询问。", "outputFormat": "对于每个询问，输出一行一个整数表示答案。", "hint": "对于所有数据，$1\\leq T\\leq 10 ^ 3$，$1\\leq n, \\sum n\\leq 5\\times 10 ^ 5$，$1\\leq m, q, \\sum q \\leq 10 ^ 6$，$1\\leq v_i, t_i, T_i\\leq 10 ^ 9$，$0\\leq p_i < m$。保证 $t_i$ 单调不降，$T_i$ 单调递增。\n\n- 子任务 1（$10$ 分）：$n\\leq 5$。\n- 子任务 2（$10$ 分）：$n\\leq 50$。\n- 子任务 3（$20$ 分）：$n\\leq 500$。\n- 子任务 4（$20$ 分）：$n\\leq 5\\times 10 ^ 3$。\n- 子任务 5（$20$ 分）：$n\\leq 5\\times 10 ^ 4$。\n- 子任务 6（$20$ 分）：无特殊限制。\n\n**请注意，子任务并没有保证 $\\sum q$ 的数量级**。\n\n本题 IO 量较大，建议使用 `scanf/printf` 或关闭流同步的 `cin/cout` 或快速读入和快速输出。\n\nSource：NFLSPC #6 I by Alex_Wei", "locale": "zh-CN"}}}
{"pid": "P9934", "type": "P", "difficulty": 5, "samples": [["3\nN Z H\nQ N H\nQ Z N\n", "1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["字符串", "O2优化", "哈希 hashing", "字典树 Trie"], "title": "[NFLSPC #6] 绝不能忘记的事……", "background": "> 那件事…… 绝对不能忘记！", "description": "你在电脑内记录了一条绝对不能忘记的事。但是，因为 1064 病毒的入侵，它被电脑忘记了。更可怕的是，1064 病毒似乎拥有某种跨物种传播的能力，导致你也忘记了这件事。\n\n万幸，在 1064 病毒让你和你的电脑忘记这件事之前，你及时将这件事的记录复制了 $n$ 份。但是，由于你和你的电脑在执行这件艰巨的任务的过程中受到 1064 病毒的影响忘记了很多可以忘记的事，所以你进行的操作有点奇怪。\n\n- 首先，这件事的记录是一个长度未知（因为你已经忘记了它的长度）的字符串，称作 **记录串**。对于一份复制，你将记录串切成了三段非空的字符串 **片段**。**不同复制的场合，切割的方案不一定相同**。你暂且将这三份 **片段** 依次称作 **前面**，**中间** 和 **后面**。\n- 因为电脑忘记了很多可以忘记的事，所以某些复制中的某些片段可能被忘记了。具体而言，前面有可能被替换为 `QIANMIANWANGLE`，中间有可能被替换为 `ZHONGJIANWANGLE`，后面有可能被替换为 `HOUMIANWANGLE`；在发生替换的场合，表示电脑 **完全忘记** 了这一段片段；否则，表示电脑 **完全记得** 该片段。\n- 你终于想起了一件绝不能忘记的事：那就是那绝不能忘记的记录串中，**恰出现了一次** `NFLSPC#6QIDONG` 作为连续子串。除此之外，记录串中的所有其它字符都是 **小写英文字符**。并且，因为你和你的电脑始终记得这件事有多么重要，所以你在划分的时候，无意中让某一个片段恰好为 `NFLSPC#6QIDONG`；你的电脑也在每一份记录中忠实地记得这一段片段。\n- 于是，你的电脑最终还记得的东西，就是：$n$ 份复制，每份复制由三段非空字符串构成，依次表示这份复制的三份片段；其中恰有一段为 `NFLSPC#6QIDONG`，另外两段要么是一串仅由小写英文字母构成的非空串，要么是对应的前面/中间/后面忘了。\n- 邪恶的 1064 病毒不肯罢休，它篡改了你电脑中的信息，使得你的 $n$ 份复制不一定是自洽的。\n\n你确信 1064 病毒没有能力篡改过多的信息，并且它绝对敌不过你和你的电脑对彼此牢牢记住的 `NFLSPC#6QIDONG` 的信念。因此，你的复制仍然满足上文中所述的性质（恰有一段是 `NFLSPC#6QIDONG`，另外两段要么忘了要么是小写字母非空串）。\n\n你的目标是，寻找到初始的那绝不能忘记的记录串。这个记录串需要满足的条件是，恰出现一次 `NFLSPC#6QIDONG`，其余字符均是小写英文字符，且其匹配尽量多的复制串。\n\n- 记录串与复制串匹配的要求是，记录串存在一种划分，使得三段划分与复制串的三段分别相同，或者复制串中这段划分忘了（此时本段划分中，记录串为任何非空英文字符串均合法）。\n\n你希望求出该记录串能匹配的最多复制串数目。至于记录串本身，你更希望将它深深地埋藏于心底，因此你不需要求出它。\n\n> 那忘记的事只会使你的心灵更加轻盈 / 那未曾忘记的事则会让你的心灵更加坚硬 /", "inputFormat": "**为了避免输入量过大，输入进行了一定程度的压缩。请务必认真阅读输入格式**。\n\n第一行一个正整数 $n$，表示记录数目。\n\n接下来 $n$ 行，每行三个非空字符串，其中第一段要么是非空小写字符串，要么是 `Q`（表示 `QIANMIANWANGLE`），要么是 `N`（表示 `NFLSPC#6QIDONG`），不存在其它可能；第二段则是非空小写字符串、`Z`（表示 `ZHONGJIANWANGLE`）、`N` 三者之一；最后一段是非空小写字符串、`H`（表示 `HOUMIANWANGLE`）、`N` 三者之一。保证三段中恰有一段为 `N`。", "outputFormat": "一行一个整数，表示所有记录串中，能匹配的最多的复制的数目。", "hint": "对于所有数据，保证输入的所有字符串长度之和不超过 $10 ^ 6$。\n\n- 子任务 1（$20$ 分）：保证复制中除了 `NFLSPC#6QIDONG` 恰出现一次以外，其它部分全部忘记。也即，输入的复制串仅可能为 `N Z H`，`Q N H`，`Q Z N` 三者之一。\n- 子任务 2（$30$ 分）：保证所有复制串的 “后面” 段都是 `NFLSPC#6QIDONG`。也即，输入的复制串必然形如 `* * N`，其中 `*` 指代任意符合格式的输入。\n- 子任务 3（$50$ 分）：无特殊限制。\n\nSource：NFLSPC #6 J by Troverld", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NFLSPC #6] 绝不能忘记的事……", "background": "> 那件事…… 绝对不能忘记！", "description": "你在电脑内记录了一条绝对不能忘记的事。但是，因为 1064 病毒的入侵，它被电脑忘记了。更可怕的是，1064 病毒似乎拥有某种跨物种传播的能力，导致你也忘记了这件事。\n\n万幸，在 1064 病毒让你和你的电脑忘记这件事之前，你及时将这件事的记录复制了 $n$ 份。但是，由于你和你的电脑在执行这件艰巨的任务的过程中受到 1064 病毒的影响忘记了很多可以忘记的事，所以你进行的操作有点奇怪。\n\n- 首先，这件事的记录是一个长度未知（因为你已经忘记了它的长度）的字符串，称作 **记录串**。对于一份复制，你将记录串切成了三段非空的字符串 **片段**。**不同复制的场合，切割的方案不一定相同**。你暂且将这三份 **片段** 依次称作 **前面**，**中间** 和 **后面**。\n- 因为电脑忘记了很多可以忘记的事，所以某些复制中的某些片段可能被忘记了。具体而言，前面有可能被替换为 `QIANMIANWANGLE`，中间有可能被替换为 `ZHONGJIANWANGLE`，后面有可能被替换为 `HOUMIANWANGLE`；在发生替换的场合，表示电脑 **完全忘记** 了这一段片段；否则，表示电脑 **完全记得** 该片段。\n- 你终于想起了一件绝不能忘记的事：那就是那绝不能忘记的记录串中，**恰出现了一次** `NFLSPC#6QIDONG` 作为连续子串。除此之外，记录串中的所有其它字符都是 **小写英文字符**。并且，因为你和你的电脑始终记得这件事有多么重要，所以你在划分的时候，无意中让某一个片段恰好为 `NFLSPC#6QIDONG`；你的电脑也在每一份记录中忠实地记得这一段片段。\n- 于是，你的电脑最终还记得的东西，就是：$n$ 份复制，每份复制由三段非空字符串构成，依次表示这份复制的三份片段；其中恰有一段为 `NFLSPC#6QIDONG`，另外两段要么是一串仅由小写英文字母构成的非空串，要么是对应的前面/中间/后面忘了。\n- 邪恶的 1064 病毒不肯罢休，它篡改了你电脑中的信息，使得你的 $n$ 份复制不一定是自洽的。\n\n你确信 1064 病毒没有能力篡改过多的信息，并且它绝对敌不过你和你的电脑对彼此牢牢记住的 `NFLSPC#6QIDONG` 的信念。因此，你的复制仍然满足上文中所述的性质（恰有一段是 `NFLSPC#6QIDONG`，另外两段要么忘了要么是小写字母非空串）。\n\n你的目标是，寻找到初始的那绝不能忘记的记录串。这个记录串需要满足的条件是，恰出现一次 `NFLSPC#6QIDONG`，其余字符均是小写英文字符，且其匹配尽量多的复制串。\n\n- 记录串与复制串匹配的要求是，记录串存在一种划分，使得三段划分与复制串的三段分别相同，或者复制串中这段划分忘了（此时本段划分中，记录串为任何非空英文字符串均合法）。\n\n你希望求出该记录串能匹配的最多复制串数目。至于记录串本身，你更希望将它深深地埋藏于心底，因此你不需要求出它。\n\n> 那忘记的事只会使你的心灵更加轻盈 / 那未曾忘记的事则会让你的心灵更加坚硬 /", "inputFormat": "**为了避免输入量过大，输入进行了一定程度的压缩。请务必认真阅读输入格式**。\n\n第一行一个正整数 $n$，表示记录数目。\n\n接下来 $n$ 行，每行三个非空字符串，其中第一段要么是非空小写字符串，要么是 `Q`（表示 `QIANMIANWANGLE`），要么是 `N`（表示 `NFLSPC#6QIDONG`），不存在其它可能；第二段则是非空小写字符串、`Z`（表示 `ZHONGJIANWANGLE`）、`N` 三者之一；最后一段是非空小写字符串、`H`（表示 `HOUMIANWANGLE`）、`N` 三者之一。保证三段中恰有一段为 `N`。", "outputFormat": "一行一个整数，表示所有记录串中，能匹配的最多的复制的数目。", "hint": "对于所有数据，保证输入的所有字符串长度之和不超过 $10 ^ 6$。\n\n- 子任务 1（$20$ 分）：保证复制中除了 `NFLSPC#6QIDONG` 恰出现一次以外，其它部分全部忘记。也即，输入的复制串仅可能为 `N Z H`，`Q N H`，`Q Z N` 三者之一。\n- 子任务 2（$30$ 分）：保证所有复制串的 “后面” 段都是 `NFLSPC#6QIDONG`。也即，输入的复制串必然形如 `* * N`，其中 `*` 指代任意符合格式的输入。\n- 子任务 3（$50$ 分）：无特殊限制。\n\nSource：NFLSPC #6 J by Troverld", "locale": "zh-CN"}}}
{"pid": "P9935", "type": "P", "difficulty": 6, "samples": [["3\nnflsalgo Z H\nQ nflspc H\nQ Z qidong\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["字符串", "线段树", "O2优化", "哈希 hashing", "虚树", "字典树 Trie", "AC 自动机"], "title": "[NFLSPC #6] 啊，忘记了。", "background": "> 好像忘了什么事…… 算了，想必不是什么重要的事吧。", "description": "\n\n你在你的电脑上发现了 $n$ 份文本。冥冥之中，你没来由地感觉这似乎全都是一份记录的复制。\n\n- 首先，原始记录是一个长度未知（甚至可以为空）的字符串，称作 **记录串**。对于一份复制，其将记录串切成了三段 **可以为空** 的字符串 **片段**。**每份复制中切割方案不保证相同**。你暂且将这三份 **片段** 依次称作 **前面**，**中间** 和 **后面**。\n- 某些复制中的某些片段可能被忘记了。具体而言，前面有可能被替换为 `QIANMIANWANGLE`，中间有可能被替换为 `ZHONGJIANWANGLE`，后面有可能被替换为 `HOUMIANWANGLE`；在发生替换的场合，表示这一段片段被 **完全遗忘** 了；否则，表示该片段被 **完整保存**。\n- 你有一种预感，记录串中的所有字符都是 **小写英文字符**。\n- $n$ 份复制不一定自洽。\n\n你的目标是，寻找初始的记录串。这个记录串需要满足所有字符均是小写英文字符。你希望其匹配尽量多的复制串。\n\n- 记录串与复制串匹配的要求是，存在记录串的一种划分，使得其中记录串的三段与复制串的三段分别相同，或者复制串中这段划分忘了（此时本段划分中，记录串为任何可以为空的小写英文字符串均合法）。\n\n你希望求出该记录串能匹配的最多复制串数目。**至于记录串本身，你感觉它并不是很重要，所以你不需要求出它**。\n\n> / 我，毋畏遗忘 /", "inputFormat": "**为了避免输入过大，输入进行了一定程度的压缩。请务必认真阅读输入格式**。\n\n第一行一个正整数 $n$，表示记录数目。\n\n接下来 $n$ 行，每行三个非空字符串，其中第一段要么是非空小写字符串，要么是 `Q`（表示 `QIANMIANWANGLE`），要么是 `E` 表示这是一段空串（因为空串不可见所以选取 `E` 作为占位符），不存在其它可能；第二段则是非空小写字符串、`Z`（表示 `ZHONGJIANWANGLE`）、`E` 三者之一；最后一段是非空小写字符串、`H`（表示 `HOUMIANWANGLE`）、`E` 三者之一。", "outputFormat": "一行一个整数，表示所有记录串中，能匹配的最多的复制的数目。\n", "hint": "### 样例 1 解释\n\n你希望这个串是 `nflsalgonflspcqidong`。你确信，不会再有其它串比它更匹配现存的记录了。\n\n### 数据范围与约定\n\n对于所有数据，保证输入的所有字符串长度之和不超过 $5\\times 10 ^ 5$。\n\n- 子任务 1（$30$ 分）：保证所有复制的 “后面” 段都是 `H`。\n- 子任务 2（$70$ 分）：无特殊限制。\n\nSource：NFLSPC #6 K by Troverld", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NFLSPC #6] 啊，忘记了。", "background": "> 好像忘了什么事…… 算了，想必不是什么重要的事吧。", "description": "\n\n你在你的电脑上发现了 $n$ 份文本。冥冥之中，你没来由地感觉这似乎全都是一份记录的复制。\n\n- 首先，原始记录是一个长度未知（甚至可以为空）的字符串，称作 **记录串**。对于一份复制，其将记录串切成了三段 **可以为空** 的字符串 **片段**。**每份复制中切割方案不保证相同**。你暂且将这三份 **片段** 依次称作 **前面**，**中间** 和 **后面**。\n- 某些复制中的某些片段可能被忘记了。具体而言，前面有可能被替换为 `QIANMIANWANGLE`，中间有可能被替换为 `ZHONGJIANWANGLE`，后面有可能被替换为 `HOUMIANWANGLE`；在发生替换的场合，表示这一段片段被 **完全遗忘** 了；否则，表示该片段被 **完整保存**。\n- 你有一种预感，记录串中的所有字符都是 **小写英文字符**。\n- $n$ 份复制不一定自洽。\n\n你的目标是，寻找初始的记录串。这个记录串需要满足所有字符均是小写英文字符。你希望其匹配尽量多的复制串。\n\n- 记录串与复制串匹配的要求是，存在记录串的一种划分，使得其中记录串的三段与复制串的三段分别相同，或者复制串中这段划分忘了（此时本段划分中，记录串为任何可以为空的小写英文字符串均合法）。\n\n你希望求出该记录串能匹配的最多复制串数目。**至于记录串本身，你感觉它并不是很重要，所以你不需要求出它**。\n\n> / 我，毋畏遗忘 /", "inputFormat": "**为了避免输入过大，输入进行了一定程度的压缩。请务必认真阅读输入格式**。\n\n第一行一个正整数 $n$，表示记录数目。\n\n接下来 $n$ 行，每行三个非空字符串，其中第一段要么是非空小写字符串，要么是 `Q`（表示 `QIANMIANWANGLE`），要么是 `E` 表示这是一段空串（因为空串不可见所以选取 `E` 作为占位符），不存在其它可能；第二段则是非空小写字符串、`Z`（表示 `ZHONGJIANWANGLE`）、`E` 三者之一；最后一段是非空小写字符串、`H`（表示 `HOUMIANWANGLE`）、`E` 三者之一。", "outputFormat": "一行一个整数，表示所有记录串中，能匹配的最多的复制的数目。\n", "hint": "### 样例 1 解释\n\n你希望这个串是 `nflsalgonflspcqidong`。你确信，不会再有其它串比它更匹配现存的记录了。\n\n### 数据范围与约定\n\n对于所有数据，保证输入的所有字符串长度之和不超过 $5\\times 10 ^ 5$。\n\n- 子任务 1（$30$ 分）：保证所有复制的 “后面” 段都是 `H`。\n- 子任务 2（$70$ 分）：无特殊限制。\n\nSource：NFLSPC #6 K by Troverld", "locale": "zh-CN"}}}
{"pid": "P9936", "type": "P", "difficulty": 4, "samples": [["6\n2\n822 1064\n2\n1064 822\n4\n1 3 4 2\n4\n2 4 3 1\n6\n2 6 2 1 4 4\n9\n9 9 8 2 4 4 3 5 3\n", "242\n0\n6\n4\n17\n25\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["三分", "O2优化"], "title": "[NFLSPC #6] 等差数列", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/asxexdko.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rzayzc9p.png)", "description": "*Alek 岁*在某知名 OJ *代码力量*上做了 $a_i$ 道难度为 $i$ 的题。他希望做一些题使得 $a_i$ 形成 **公差非正** 的等差数列，这样画出来的统计图表很好看。\n\n尽管 *Alek 岁*一天能做 42 道题，但他依然希望做尽可能少的题达到目标。你需要求出新做题数的最小值。\n\n你可以认为 OJ 上有足够多的各种难度的题目。", "inputFormat": "第一行一个整数 $T$ 表示数据组数。\n\n对于每组数据：\n- 第一行一个整数 $n$ 表示难度总数。\n- 第二行 $n$ 个整数 $a_i$。", "outputFormat": "对于每组数据，输出一行一个整数表示答案。", "hint": "对于所有数据，$1\\leq T\\leq 100$，$1\\leq n, \\sum n\\leq 10 ^ 5$，$1\\leq a_i\\leq 10 ^ 9$。\n\n- 子任务 1（$30$ 分）：$\\sum n \\leq 10 ^ 3$。\n- 子任务 2（$70$ 分）：无特殊限制。\n\nSource：NFLSPC #6 L by Alex_Wei", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NFLSPC #6] 等差数列", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/asxexdko.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rzayzc9p.png)", "description": "*Alek 岁*在某知名 OJ *代码力量*上做了 $a_i$ 道难度为 $i$ 的题。他希望做一些题使得 $a_i$ 形成 **公差非正** 的等差数列，这样画出来的统计图表很好看。\n\n尽管 *Alek 岁*一天能做 42 道题，但他依然希望做尽可能少的题达到目标。你需要求出新做题数的最小值。\n\n你可以认为 OJ 上有足够多的各种难度的题目。", "inputFormat": "第一行一个整数 $T$ 表示数据组数。\n\n对于每组数据：\n- 第一行一个整数 $n$ 表示难度总数。\n- 第二行 $n$ 个整数 $a_i$。", "outputFormat": "对于每组数据，输出一行一个整数表示答案。", "hint": "对于所有数据，$1\\leq T\\leq 100$，$1\\leq n, \\sum n\\leq 10 ^ 5$，$1\\leq a_i\\leq 10 ^ 9$。\n\n- 子任务 1（$30$ 分）：$\\sum n \\leq 10 ^ 3$。\n- 子任务 2（$70$ 分）：无特殊限制。\n\nSource：NFLSPC #6 L by Alex_Wei", "locale": "zh-CN"}}}
{"pid": "P9937", "type": "P", "difficulty": 2, "samples": [["4 0\n1 100 2 3", "2"], ["4 1\n1 100 2 3", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "二分", "USACO", "2021", "O2优化"], "title": "[USACO21OPEN] Acowdemia I B", "background": "", "description": "由于对计算机科学的热爱，以及有朝一日成为 「Bessie 博士」的诱惑，奶牛 Bessie 开始攻读计算机科学博士学位。经过一段时间的学术研究，她已经发表了 $N$ 篇论文（$1 \\le N \\le 10^5$），并且她的第 $i$ 篇论文得到了来自其他研究文献的 $c_i$ 次引用（$0 \\le c_i \\le 10^5$）。\n\nBessie 听说学术成就可以用 $h$ 指数来衡量。$h$ 指数等于使得研究员有至少 $h$ 篇引用次数不少于 $h$ 的论文的最大整数 $h$。例如，如果一名研究员有 $4$ 篇论文，引用次数分别为 $(1,100,2,3)$，则 $h$ 指数为 $2$，然而若引用次数为 $(1,100,3,3)$ 则 $h$ 指数将会是 $3$。\n\n为了提升她的 $h$ 指数，Bessie 计划写一篇综述，并引用一些她曾经写过的论文。由于页数限制，她至多可以在这篇综述中引用 $L$ 篇论文（$0 \\le L \\le 10^5$），并且她只能引用每篇她的论文至多一次。\n\n请帮助 Bessie 求出在写完这篇综述后她可以达到的最大 $h$ 指数。\n\n注意 Bessie 的导师可能会告知她纯粹为了提升 $h$ 指数而写综述存在违反学术道德的嫌疑；我们不建议其他学者模仿 Bessie 的行为。 ", "inputFormat": "输入的第一行包含 $N$ 和 $L$。\n\n第二行包含 $N$ 个空格分隔的整数 $c_1,\\ldots,c_N$。 ", "outputFormat": "输出写完综述后 Bessie 可以达到的最大 $h$ 指数。 ", "hint": "### 样例解释 1\n\nBessie 不能引用任何她曾经写过的论文。上文中提到，$(1,100,2,3)$ 的 $h$ 指数为 $2$。\n\n### 样例解释 2\n\n如果 Bessie 引用她的第三篇论文，引用数会变为 $(1,100,3,3)$。上文中提到，这一引用数的 $h$ 指数为 $3$。\n\n### 测试点性质\n\n- 测试点 $1-7$ 满足 $N\\le 100$。\n- 测试点 $8-10$ 满足 $N\\le 1000$。\n- 测试点 $11-17$ 满足 $N \\le 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO21OPEN] Acowdemia I B", "background": "", "description": "由于对计算机科学的热爱，以及有朝一日成为 「Bessie 博士」的诱惑，奶牛 Bessie 开始攻读计算机科学博士学位。经过一段时间的学术研究，她已经发表了 $N$ 篇论文（$1 \\le N \\le 10^5$），并且她的第 $i$ 篇论文得到了来自其他研究文献的 $c_i$ 次引用（$0 \\le c_i \\le 10^5$）。\n\nBessie 听说学术成就可以用 $h$ 指数来衡量。$h$ 指数等于使得研究员有至少 $h$ 篇引用次数不少于 $h$ 的论文的最大整数 $h$。例如，如果一名研究员有 $4$ 篇论文，引用次数分别为 $(1,100,2,3)$，则 $h$ 指数为 $2$，然而若引用次数为 $(1,100,3,3)$ 则 $h$ 指数将会是 $3$。\n\n为了提升她的 $h$ 指数，Bessie 计划写一篇综述，并引用一些她曾经写过的论文。由于页数限制，她至多可以在这篇综述中引用 $L$ 篇论文（$0 \\le L \\le 10^5$），并且她只能引用每篇她的论文至多一次。\n\n请帮助 Bessie 求出在写完这篇综述后她可以达到的最大 $h$ 指数。\n\n注意 Bessie 的导师可能会告知她纯粹为了提升 $h$ 指数而写综述存在违反学术道德的嫌疑；我们不建议其他学者模仿 Bessie 的行为。 ", "inputFormat": "输入的第一行包含 $N$ 和 $L$。\n\n第二行包含 $N$ 个空格分隔的整数 $c_1,\\ldots,c_N$。 ", "outputFormat": "输出写完综述后 Bessie 可以达到的最大 $h$ 指数。 ", "hint": "### 样例解释 1\n\nBessie 不能引用任何她曾经写过的论文。上文中提到，$(1,100,2,3)$ 的 $h$ 指数为 $2$。\n\n### 样例解释 2\n\n如果 Bessie 引用她的第三篇论文，引用数会变为 $(1,100,3,3)$。上文中提到，这一引用数的 $h$ 指数为 $3$。\n\n### 测试点性质\n\n- 测试点 $1-7$ 满足 $N\\le 100$。\n- 测试点 $8-10$ 满足 $N\\le 1000$。\n- 测试点 $11-17$ 满足 $N \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P9938", "type": "P", "difficulty": 2, "samples": [["1 3\ndean elsie mildred\nelsie mildred dean", "B11\n0B?\n0?B"], ["2 3\nelsie mildred dean\nelsie mildred dean\nelsie dean mildred", "B00\n1B0\n11B"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "USACO", "2021", "O2优化"], "title": "[USACO21OPEN] Acowdemia II B", "background": "", "description": "Bessie 正在申请计算机科学的研究生，并取得了一所久负盛名的计算机科学实验室的面试通知。然而，为了避免冒犯任何人，Bessie 有意先确定实验室的 $N$ 名现有成员的相对资历（$1\\le N\\le 100$）。没有两名实验室成员的资历相同，但确定他们的资历深浅可能并不好办。为此，Bessie 将会对实验室的出版物进行调查。\n\n每份出版物均包含一个作者列表，为所有 $N$ 名实验室成员的一个排列。列表按每名实验室成员对这篇文章的贡献降序排列。如果多名研究员的贡献相等，则按字典序排列。由于更有资历的实验室成员负有更多的管理责任，更有资历的研究员从不会比资历较浅的研究员做出更多的贡献。\n\n例如，在一个由资历较浅的学生 Elsie、资历较深的教授 Mildred、以及十分资深的教授 Dean 组成的实验室中，可能存在一篇论文 Elsie-Mildred-Dean，如果他们做出了不等的贡献（也就是说，Elsie 做出的贡献比 Mildred 更多，Mildred 比 Dean 更多）。然而，也有可能存在一篇论文 Elsie-Dean-Mildred，如果 Mildred 和 Dean 做出了相等的贡献，而 Elsie 做出了更多的贡献。\n\n给定实验室的 $K$ 份出版物（$1\\le K\\le 100$），对于实验室中每对研究员，如果可能的话帮助 Bessie 判断其中谁的资历更深。", "inputFormat": "输入的第一行包含两个整数 $K$ 和 $N$。\n\n第二行包含 $N$ 个空格分隔的字符串，为实验室的成员的名字。每个字符串均由小写字母组成，且至多包含 $10$ 个字符。\n\n以下 $K$ 行，每行包含 $N$ 个空格分隔的字符串，表示一份出版物的作者列表。 ", "outputFormat": "输出 $N$ 行，每行 $N$ 个字符。在第 $i$ 行内，对于所有 $j\\neq i$，当可以确定第 $i$ 名成员比第 $j$ 名成员资历更深时字符 $j$ 为 `1`，当可以确定第 $i$ 名成员比第 $j$ 名成员资历更浅时字符 $j$ 为 `0`，当不能由给定的出版物确定时为 `?`。\n\n第 $i$ 行的字符 $i$ 应为 `B`，因为这是 Bessie 最喜欢的字母。 ", "hint": "### 样例解释 1\n\n在这个样例中，单独一份论文 elsie-mildred-dean 并不能提供足够的信息判断 Elsie 比 Mildred 资历更深或更浅。然而，我们可以推断出 Dean 一定比这两名研究员资历更深，从而资历排序为 Elsie<Mildred<Dean 和 Mildred<Elsie<Dean 均是可能的。 \n\n### 样例解释 2\n\n在这个样例中，唯一能与两篇论文相一致的资历排序为 Elsie<Mildred<Dean，这是因为基于第一个样例所提供的信息，第二篇论文可以帮助我们推断出 Mildred 比 Elsie 的资历更深。 ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO21OPEN] Acowdemia II B", "background": "", "description": "Bessie 正在申请计算机科学的研究生，并取得了一所久负盛名的计算机科学实验室的面试通知。然而，为了避免冒犯任何人，Bessie 有意先确定实验室的 $N$ 名现有成员的相对资历（$1\\le N\\le 100$）。没有两名实验室成员的资历相同，但确定他们的资历深浅可能并不好办。为此，Bessie 将会对实验室的出版物进行调查。\n\n每份出版物均包含一个作者列表，为所有 $N$ 名实验室成员的一个排列。列表按每名实验室成员对这篇文章的贡献降序排列。如果多名研究员的贡献相等，则按字典序排列。由于更有资历的实验室成员负有更多的管理责任，更有资历的研究员从不会比资历较浅的研究员做出更多的贡献。\n\n例如，在一个由资历较浅的学生 Elsie、资历较深的教授 Mildred、以及十分资深的教授 Dean 组成的实验室中，可能存在一篇论文 Elsie-Mildred-Dean，如果他们做出了不等的贡献（也就是说，Elsie 做出的贡献比 Mildred 更多，Mildred 比 Dean 更多）。然而，也有可能存在一篇论文 Elsie-Dean-Mildred，如果 Mildred 和 Dean 做出了相等的贡献，而 Elsie 做出了更多的贡献。\n\n给定实验室的 $K$ 份出版物（$1\\le K\\le 100$），对于实验室中每对研究员，如果可能的话帮助 Bessie 判断其中谁的资历更深。", "inputFormat": "输入的第一行包含两个整数 $K$ 和 $N$。\n\n第二行包含 $N$ 个空格分隔的字符串，为实验室的成员的名字。每个字符串均由小写字母组成，且至多包含 $10$ 个字符。\n\n以下 $K$ 行，每行包含 $N$ 个空格分隔的字符串，表示一份出版物的作者列表。 ", "outputFormat": "输出 $N$ 行，每行 $N$ 个字符。在第 $i$ 行内，对于所有 $j\\neq i$，当可以确定第 $i$ 名成员比第 $j$ 名成员资历更深时字符 $j$ 为 `1`，当可以确定第 $i$ 名成员比第 $j$ 名成员资历更浅时字符 $j$ 为 `0`，当不能由给定的出版物确定时为 `?`。\n\n第 $i$ 行的字符 $i$ 应为 `B`，因为这是 Bessie 最喜欢的字母。 ", "hint": "### 样例解释 1\n\n在这个样例中，单独一份论文 elsie-mildred-dean 并不能提供足够的信息判断 Elsie 比 Mildred 资历更深或更浅。然而，我们可以推断出 Dean 一定比这两名研究员资历更深，从而资历排序为 Elsie<Mildred<Dean 和 Mildred<Elsie<Dean 均是可能的。 \n\n### 样例解释 2\n\n在这个样例中，唯一能与两篇论文相一致的资历排序为 Elsie<Mildred<Dean，这是因为基于第一个样例所提供的信息，第二篇论文可以帮助我们推断出 Mildred 比 Elsie 的资历更深。 ", "locale": "zh-CN"}}}
{"pid": "P9939", "type": "P", "difficulty": 3, "samples": [["4 5\n.CGGC\n.CGCG\nCGCG.\n.CC.C", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "USACO", "2021", "O2优化", "分类讨论"], "title": "[USACO21OPEN] Acowdemia III B", "background": "", "description": "Bessie 是一位忙碌的计算机科学研究生。然而，即使是研究生也需要交友。因此，Farmer John 开设了一片草地，目的是为了帮助 Bessie 与其他奶牛建立持久的友谊。\n\nFarmer John 的草地可以被看做是由正方形方格组成的巨大二维方阵（想象一个巨大的棋盘）。每个方格用如下字符标记：\n\n - `C`，如果这个方格中有一头奶牛。\n - `G`，如果这个方格中有草。\n - `.`，如果这个方格既没有奶牛也没有草。\n\n对于两头想要成为朋友的奶牛，她们必须选择在一个与她们均水平或竖直方向上相邻的有草方格见面。在这个过程中，她们会在这个有草方格中吃草，所以之后的奶牛不能再使用这个方格作为见面地点。一头奶牛可以与多头其他奶牛成为朋友，但是同一对奶牛不能见面并成为朋友多于一次。\n\nFarmer John 希望有许多奶牛可以见面并成为朋友。请求出当这一活动结束时在奶牛之间可以建立的朋友关系的最大数量。 ", "inputFormat": "输入的第一行包含 $N$ 和 $M$（$1\\le N,M\\le 1000$）。\n\n以下 $N$ 行每行包含一个由 $M$ 个字符组成的字符串，表示这个草地。", "outputFormat": "输出在这一活动结束时在奶牛之间可以建立的朋友关系的最大数量", "hint": "### 样例解释 1\n\n如果我们用坐标 $(i,j)$ 标记第 $i$ 行第 $j$ 列的奶牛，则在这个样例中于 $(1,2)$、$(1,5)$、$(2,2)$、$(2,4)$、$(3,1)$、$(3,3)$、$(4,2)$、$(4,3)$ 以及 $(4,5)$ \n存在奶牛。一种使四对奶牛成为朋友的方式如下：\n\n - 位于 $(2,2)$ 和 $(3,3)$ 的奶牛于 $(3,2)$ 一起吃草。\n - 位于 $(2,2)$ 和 $(2,4)$ 的奶牛于 $(2,3)$ 一起吃草。\n - 位于 $(2,4)$ 和 $(3,3)$ 的奶牛于 $(3,4)$ 一起吃草。\n - 位于 $(2,4)$ 和 $(1,5)$ 的奶牛于 $(2,5)$ 一起吃草。\n\n\n### 测试点性质\n\n - 测试点 $2-4$ 满足 $N=2$。\n - 测试点 $5-12$ 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO21OPEN] Acowdemia III B", "background": "", "description": "Bessie 是一位忙碌的计算机科学研究生。然而，即使是研究生也需要交友。因此，Farmer John 开设了一片草地，目的是为了帮助 Bessie 与其他奶牛建立持久的友谊。\n\nFarmer John 的草地可以被看做是由正方形方格组成的巨大二维方阵（想象一个巨大的棋盘）。每个方格用如下字符标记：\n\n - `C`，如果这个方格中有一头奶牛。\n - `G`，如果这个方格中有草。\n - `.`，如果这个方格既没有奶牛也没有草。\n\n对于两头想要成为朋友的奶牛，她们必须选择在一个与她们均水平或竖直方向上相邻的有草方格见面。在这个过程中，她们会在这个有草方格中吃草，所以之后的奶牛不能再使用这个方格作为见面地点。一头奶牛可以与多头其他奶牛成为朋友，但是同一对奶牛不能见面并成为朋友多于一次。\n\nFarmer John 希望有许多奶牛可以见面并成为朋友。请求出当这一活动结束时在奶牛之间可以建立的朋友关系的最大数量。 ", "inputFormat": "输入的第一行包含 $N$ 和 $M$（$1\\le N,M\\le 1000$）。\n\n以下 $N$ 行每行包含一个由 $M$ 个字符组成的字符串，表示这个草地。", "outputFormat": "输出在这一活动结束时在奶牛之间可以建立的朋友关系的最大数量", "hint": "### 样例解释 1\n\n如果我们用坐标 $(i,j)$ 标记第 $i$ 行第 $j$ 列的奶牛，则在这个样例中于 $(1,2)$、$(1,5)$、$(2,2)$、$(2,4)$、$(3,1)$、$(3,3)$、$(4,2)$、$(4,3)$ 以及 $(4,5)$ \n存在奶牛。一种使四对奶牛成为朋友的方式如下：\n\n - 位于 $(2,2)$ 和 $(3,3)$ 的奶牛于 $(3,2)$ 一起吃草。\n - 位于 $(2,2)$ 和 $(2,4)$ 的奶牛于 $(2,3)$ 一起吃草。\n - 位于 $(2,4)$ 和 $(3,3)$ 的奶牛于 $(3,4)$ 一起吃草。\n - 位于 $(2,4)$ 和 $(1,5)$ 的奶牛于 $(2,5)$ 一起吃草。\n\n\n### 测试点性质\n\n - 测试点 $2-4$ 满足 $N=2$。\n - 测试点 $5-12$ 没有额外限制。", "locale": "zh-CN"}}}
