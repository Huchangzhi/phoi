{"pid": "P3635", "type": "P", "difficulty": 6, "samples": [["5 4 \n5 \n3 3 2 \n3 2 0 \n4 2 2 \n5 4 1 \n1 1 3 ", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2012", "APIO"], "title": "[APIO2012] 苦无", "background": "", "description": "苦无 (Kunai) 是一种忍者使用的形状像刀的武器，忍者通过投掷苦无攻击对手。现在有 $N$ 名忍者聚集在一块 $H$ 行 $W$ 列的棋盘式的广场上。每个忍者都站在其所在方块的中心处，任何两个忍者都不在同一个方块上。每个忍者都拿着一个苦无，面朝上、下、左、右四个方向中的一个方向站着。在时刻 $0$，所有忍者同时向其所朝向的方向投掷苦无。\n\n每个苦无将会一直保持其初始的方向，并以单位速度飞行。如果某个时刻一个位置上多于一个的苦无，它们将会相撞并且消失。苦无特别小，可以看成质点。同时，由于忍者的移动速度特别快，他们不会被苦无击中。\n\n在下面的例子中，我们用箭头来表示苦无，而箭头的方向即为苦无的方向。在这些图中，所有的苦无都会相撞后消失。\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4414.png) \n\n在下面的图中，两个粗线箭头表示的苦无不会相撞。其中在第二个和第三个图中，其中一个粗线表示的苦无会与细线表示的苦无相撞后消失，因此不会撞上另一个粗线表示的苦无。\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4415.png) \n\n你的任务是计算经过足够长的时间之后，在这个 $W × H$ 的广场中有多少格子被苦无经过。", "inputFormat": "第一行包含两个被空格隔开的整数 $W$, $H$，表示广场的尺寸为 $W$ 列 $H$ 行。第二行包含一个整数 $N$，表示忍者的数量。\n\n接下来 $N$ 行中，第 $i$ 行有三个以空格分隔的整数 $X_i, Y_i, D_i$, 表示第 $i$ 个忍者处在从左往右的 $X_i$ 列、从上往下的第 $Y_i$ 行，任何两个忍者不在同一个位置。第 $i$ 个忍者面向的方向由 $D_i$ 表示，分别为： \n\n- $D_i = 0$，表示忍者向右；\n- $D_i = 1$，表示忍者向上； \n- $D_i = 2$，表示忍者向左； \n- $D_i = 3$，表示忍者向下。", "outputFormat": "输出一个整数，表示经过足够长的时间之后，在这个 $W × H$ 的广场中被苦无经过的格子数量。", "hint": "对于全部数据，忍者数 $1 \\le N \\le 10^5$，列数 $1 \\le W \\le 10^9$，行数 $1 \\le H \\le 10^9$；\n坐标范围 $1 \\le X_i \\le W$，$1 \\le Y_i \\le H$。\n\n \n- 在 $10\\%$ 的数据中，$N \\le 1000$, $W \\le 1000$, $H \\le 1000$。\n- 在 $40\\%$ 的数据中，$N \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2012] Kunai", "background": "", "description": "Kunai is a knife-shaped weapon used by ninjas, who attack by throwing it. There are $N$ ninjas gathered on a chessboard-like plaza with $H$ rows and $W$ columns. Each ninja stands at the center of a cell, and no two ninjas share the same cell. Each ninja holds one kunai and faces one of the four directions: up, down, left, or right. At time $0$, all ninjas simultaneously throw their kunai in the direction they are facing.\n\nEach kunai keeps its initial direction and flies at unit speed. If, at some moment, more than one kunai is at the same position, they collide and disappear. Kunai are very small and can be treated as point masses. Also, because ninjas move extremely fast, they will not be hit by any kunai.\n\nIn the following example, we use arrows to represent kunai, and the direction of an arrow is the direction of the corresponding kunai. In these figures, all kunai collide and disappear.\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4414.png) \n\nIn the figures below, the two bold arrows represent kunai that will not collide. In the second and third figures, one of the bold-arrow kunai collides with a thin-arrow kunai and disappears, so it will not collide with the other bold-arrow kunai.\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4415.png) \n\nYour task is to compute, after sufficient time has passed, how many cells in this $W \\times H$ plaza are traversed by at least one kunai.", "inputFormat": "The first line contains two integers $W$, $H$ separated by a space, indicating the plaza has $W$ columns and $H$ rows. The second line contains an integer $N$, the number of ninjas.\n\nThe next $N$ lines each contain three integers $X_i$, $Y_i$, $D_i$ separated by spaces. The $i$-th ninja is at column $X_i$ (counted from left to right) and row $Y_i$ (counted from top to bottom). No two ninjas share the same position. The facing direction of the $i$-th ninja is given by $D_i$:\n- $D_i = 0$: facing right;\n- $D_i = 1$: facing up;\n- $D_i = 2$: facing left;\n- $D_i = 3$: facing down.", "outputFormat": "Output one integer: after sufficient time has passed, the number of cells in the $W \\times H$ plaza that are traversed by at least one kunai.", "hint": "For all testdata, $1 \\le N \\le 10^5$, $1 \\le W \\le 10^9$, $1 \\le H \\le 10^9$; coordinate ranges are $1 \\le X_i \\le W$, $1 \\le Y_i \\le H$.\n\n- In $10\\%$ of the testdata, $N \\le 1000$, $W \\le 1000$, $H \\le 1000$.\n- In $40\\%$ of the testdata, $N \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2012] 苦无", "background": "", "description": "苦无 (Kunai) 是一种忍者使用的形状像刀的武器，忍者通过投掷苦无攻击对手。现在有 $N$ 名忍者聚集在一块 $H$ 行 $W$ 列的棋盘式的广场上。每个忍者都站在其所在方块的中心处，任何两个忍者都不在同一个方块上。每个忍者都拿着一个苦无，面朝上、下、左、右四个方向中的一个方向站着。在时刻 $0$，所有忍者同时向其所朝向的方向投掷苦无。\n\n每个苦无将会一直保持其初始的方向，并以单位速度飞行。如果某个时刻一个位置上多于一个的苦无，它们将会相撞并且消失。苦无特别小，可以看成质点。同时，由于忍者的移动速度特别快，他们不会被苦无击中。\n\n在下面的例子中，我们用箭头来表示苦无，而箭头的方向即为苦无的方向。在这些图中，所有的苦无都会相撞后消失。\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4414.png) \n\n在下面的图中，两个粗线箭头表示的苦无不会相撞。其中在第二个和第三个图中，其中一个粗线表示的苦无会与细线表示的苦无相撞后消失，因此不会撞上另一个粗线表示的苦无。\n\n  ![](https://cdn.luogu.com.cn/upload/pic/4415.png) \n\n你的任务是计算经过足够长的时间之后，在这个 $W × H$ 的广场中有多少格子被苦无经过。", "inputFormat": "第一行包含两个被空格隔开的整数 $W$, $H$，表示广场的尺寸为 $W$ 列 $H$ 行。第二行包含一个整数 $N$，表示忍者的数量。\n\n接下来 $N$ 行中，第 $i$ 行有三个以空格分隔的整数 $X_i, Y_i, D_i$, 表示第 $i$ 个忍者处在从左往右的 $X_i$ 列、从上往下的第 $Y_i$ 行，任何两个忍者不在同一个位置。第 $i$ 个忍者面向的方向由 $D_i$ 表示，分别为： \n\n- $D_i = 0$，表示忍者向右；\n- $D_i = 1$，表示忍者向上； \n- $D_i = 2$，表示忍者向左； \n- $D_i = 3$，表示忍者向下。", "outputFormat": "输出一个整数，表示经过足够长的时间之后，在这个 $W × H$ 的广场中被苦无经过的格子数量。", "hint": "对于全部数据，忍者数 $1 \\le N \\le 10^5$，列数 $1 \\le W \\le 10^9$，行数 $1 \\le H \\le 10^9$；\n坐标范围 $1 \\le X_i \\le W$，$1 \\le Y_i \\le H$。\n\n \n- 在 $10\\%$ 的数据中，$N \\le 1000$, $W \\le 1000$, $H \\le 1000$。\n- 在 $40\\%$ 的数据中，$N \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P3636", "type": "P", "difficulty": 6, "samples": [["3 3", "300"], ["64 19260817", "9932"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "曲面", "background": "xht喜欢研究数学函数，他特别喜欢反比例函数。\n", "description": "我们知道，反比例函数xy=a的图象是双曲线。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4375.png) \n\nxht于是想：把它推广到三维是什么样的呢？\n\n\n定义曲面C(k)为**方程xyz=k所确定的曲面**。\n\n\n又定义曲面的美观程度P(k)为曲面C(k)上所有**整点**（x,y,z坐标均为整数）到原点的曼哈顿距离的**平方**之和。\n\n\n（点（x,y,z）到原点的曼哈顿距离为|x|+|y|+|z|）。\n\n现在，xht把一些曲面{C(a),C(a+1)...C(b)}排成一列，你要求出它们美观程度之**和**对10007取模的结果。\n", "inputFormat": "一行两个正整数数a，b\n", "outputFormat": "一行一个数\n\n![](https://cdn.luogu.com.cn/upload/pic/4376.png)\n", "hint": "样例1的解释：\n\n\n在曲面xyz=3上共有12个整点(1,1,3),(1,3,1),(3,1,1),(-1-1,3),(-1,-3,1),(-3,-1,1),(1,-1,-3),(1,-3,-1),(3,-1,-1),(-1,1,-3),(-1,3,-1),(-3,1,-1)。它们到原点的曼哈顿距离的平方之和为5^2\\*12=300。\n\n\n对于20%的数据，a=b<=100\n\n对于另外40%的数据，a,b<=3\\*10^5\n\n对于100%的数据，1<=a,b<=3\\*10^8\n", "locale": "zh-CN", "translations": {"en": {"title": "Surface", "background": "xht likes studying mathematical functions, and he especially likes the inverse proportional function.", "description": "We know that the graph of the inverse proportional function $xy = a$ is a hyperbola.\n\n![](https://cdn.luogu.com.cn/upload/pic/4375.png)\n\nxht then wondered: what would it look like if we extend it to three dimensions?\n\nDefine the surface $C(k)$ as the surface determined by the equation $xyz = k$.\n\nDefine the aesthetic value $P(k)$ of the surface as the sum of the squares of the Manhattan distances to the origin of all lattice points (points whose $x$, $y$, and $z$ coordinates are all integers) on $C(k)$.\n\n(The Manhattan distance from $(x, y, z)$ to the origin is $|x| + |y| + |z|$.)\n\nNow, xht arranges the surfaces $\\{C(a), C(a+1), \\dots, C(b)\\}$ in a row. You are required to compute the sum of their aesthetic values, that is $P(a) + P(a+1) + \\dots + P(b)$, modulo $10007$.", "inputFormat": "One line containing two positive integers $a$, $b$.", "outputFormat": "One line containing a single integer.\n\n![](https://cdn.luogu.com.cn/upload/pic/4376.png)", "hint": "Explanation of Sample 1:\n\nOn the surface $xyz = 3$, there are $12$ lattice points:\n$(1, 1, 3)$, $(1, 3, 1)$, $(3, 1, 1)$, $(-1, -1, 3)$, $(-1, -3, 1)$, $(-3, -1, 1)$, $(1, -1, -3)$, $(1, -3, -1)$, $(3, -1, -1)$, $(-1, 1, -3)$, $(-1, 3, -1)$, $(-3, 1, -1)$. The sum of the squares of their Manhattan distances to the origin is $5^2 \\times 12 = 300$.\n\nConstraints:\n- For $20\\%$ of the testdata, $a = b \\le 100$.\n- For another $40\\%$ of the testdata, $a, b \\le 3 \\times 10^5$.\n- For $100\\%$ of the testdata, $1 \\le a, b \\le 3 \\times 10^8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "曲面", "background": "xht喜欢研究数学函数，他特别喜欢反比例函数。\n", "description": "我们知道，反比例函数xy=a的图象是双曲线。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4375.png) \n\nxht于是想：把它推广到三维是什么样的呢？\n\n\n定义曲面C(k)为**方程xyz=k所确定的曲面**。\n\n\n又定义曲面的美观程度P(k)为曲面C(k)上所有**整点**（x,y,z坐标均为整数）到原点的曼哈顿距离的**平方**之和。\n\n\n（点（x,y,z）到原点的曼哈顿距离为|x|+|y|+|z|）。\n\n现在，xht把一些曲面{C(a),C(a+1)...C(b)}排成一列，你要求出它们美观程度之**和**对10007取模的结果。\n", "inputFormat": "一行两个正整数数a，b\n", "outputFormat": "一行一个数\n\n![](https://cdn.luogu.com.cn/upload/pic/4376.png)\n", "hint": "样例1的解释：\n\n\n在曲面xyz=3上共有12个整点(1,1,3),(1,3,1),(3,1,1),(-1-1,3),(-1,-3,1),(-3,-1,1),(1,-1,-3),(1,-3,-1),(3,-1,-1),(-1,1,-3),(-1,3,-1),(-3,1,-1)。它们到原点的曼哈顿距离的平方之和为5^2\\*12=300。\n\n\n对于20%的数据，a=b<=100\n\n对于另外40%的数据，a,b<=3\\*10^5\n\n对于100%的数据，1<=a,b<=3\\*10^8\n", "locale": "zh-CN"}}}
{"pid": "P3637", "type": "P", "difficulty": 6, "samples": [["3 2 100 3\n1 2 1\n2 3 2\n3 1 3 0\n2 1 2\n3 1 3 0", "97\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "方程组", "background": "从小学开始，我们就一直做各种各样的应用题，其中大多数的题目都可以抽象为解方程组。\n\n为了提高效率，省下时间~~打隔膜~~学习OI，xht 准备开发一个自动解题器。其中的一个核心组件就是解方程组的程序，xht 决定将这个任务交给你。", "description": "一开始，xht 有 $N$ 个变量，记为 $x_1,x_2,\\cdots,x_n$。另有一个常数 $K$，以及 $M$ 个方程，每个方程都形如 $x_a-x_b≡c\\pmod K$。\n\n由于题目可能会变化，xht 需要不时增加一个新的方程，或者删掉一个方程。\n\n同时，xht 会给你一些这样的询问：令变量 $x_a=c$，求另一个变量 $x_b \\bmod K$ 的值。当然，有的时候会因为条件不足，无法解出 $x_b$，那么就输出 $-1$。\n\n数据保证任意时刻两个变量之间最多存在一个方程。保证不会出现自相矛盾的方程组，也不会出现多余的条件（某个方程可以通过其他一些方程推出来）。", "inputFormat": "第一行四个整数 $N,M,K,Q$，含义如上。$Q$ 代表操作的条数。\n\n接下来 $M$ 行，每行三个整数 $a,b,c$，表示方程 $x_a-x_b≡c\\pmod K$。\n\n接下来 $Q$ 行，每行第一个数 $t$ 代表操作种类，\n\n\\* $t=1$，接下来输入 $a,b,c$，代表增加一条方程 $x_a-x_b≡c\\pmod K$；\n\n\\* $t=2$，接下来输入 $a,b$，代表删除 $a,b$ 之间的方程，如果这条方程不存在，则什么也不做；\n\n\\* $t=3$，接下来输入 $a,b,c$，代表询问：令 $x_a=c$，求 $x_b \\bmod K$ 的值；", "outputFormat": "对于每一个 $3$ 操作（询问），输出一行一个数 $x$（$0\\le x<K$），表示 $x_b \\bmod K$，如果条件不足，则输出 $-1$。", "hint": "样例的解释：\n\n一开始有两条方程：$x_1-x_2=1$，$x_2-x_3=2$。\n\n第一次询问，令$x_1=0$，解得$x_3=(-3)\\bmod100=97$。\n\n第二次询问时，删掉了第二条方程，导致条件不足，无法解出 $x_3$，输出 $-1$。\n\n对于 $40\\%$ 的数据，只有询问操作。\n\n对于 $100\\%$ 的数据，$1\\le M<N\\le10^5$，$1\\le Q\\le10^5$，$2\\le K\\le10^3$，$1\\le a,b\\le N$，$0\\le c<K$。\n\n保证所有的 $a\\ne b$。", "locale": "zh-CN", "translations": {"en": {"title": "System of Equations", "background": "Since primary school, we have been doing all kinds of word problems, most of which can be abstracted as solving systems of equations.\n\nTo improve efficiency and save time to ~~play games~~ study OI, xht plans to develop an automatic problem solver. One of its core components is a program for solving systems of equations, and xht has decided to assign this task to you.", "description": "Initially, xht has $N$ variables, denoted by $x_1,x_2,\\cdots,x_n$. There is also a constant $K$, and $M$ equations, each of the form $x_a-x_b≡c\\pmod K$.\n\nSince the problem may change, xht sometimes needs to add a new equation or delete an existing one.\n\nAt the same time, xht will give you some queries: set the variable $x_a=c$, and find the value of another variable $x_b \\bmod K$. Of course, sometimes $x_b$ cannot be determined due to insufficient conditions; in that case, output $-1$.\n\nThe testdata guarantees that at any time there is at most one equation between any two variables. It is guaranteed that no contradictory systems will appear, and no redundant conditions will appear (no equation can be derived from some others).\n\n# Description", "inputFormat": "The first line contains four integers $N,M,K,Q$, as described above. $Q$ is the number of operations.\n\nThe next $M$ lines each contain three integers $a,b,c$, representing the equation $x_a-x_b≡c\\pmod K$.\n\nThe next $Q$ lines, each starting with an integer $t$ indicating the type of operation:\n\n- $t=1$: followed by $a,b,c$, meaning to add an equation $x_a-x_b≡c\\pmod K$;\n- $t=2$: followed by $a,b$, meaning to delete the equation between $a$ and $b$. If this equation does not exist, do nothing;\n- $t=3$: followed by $a,b,c$, meaning a query: set $x_a=c$, and ask for the value of $x_b \\bmod K$.", "outputFormat": "For each operation of type $3$ (query), output one integer $x$ ($0\\le x<K$), representing $x_b \\bmod K$. If the conditions are insufficient, output $-1$.", "hint": "Explanation of the sample:\n\nInitially there are two equations: $x_1-x_2=1$, $x_2-x_3=2$.\n\nIn the first query, set $x_1=0$, and obtain $x_3=(-3)\\bmod100=97$.\n\nIn the second query, the second equation has been deleted, leading to insufficient conditions, so $x_3$ cannot be determined. Output $-1$.\n\nFor $40\\%$ of the testdata, there are only query operations.\n\nFor $100\\%$ of the testdata, $1\\le M<N\\le10^5$, $1\\le Q\\le10^5$, $2\\le K\\le10^3$, $1\\le a,b\\le N$, $0\\le c<K$.\n\nIt is guaranteed that all $a\\ne b$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "方程组", "background": "从小学开始，我们就一直做各种各样的应用题，其中大多数的题目都可以抽象为解方程组。\n\n为了提高效率，省下时间~~打隔膜~~学习OI，xht 准备开发一个自动解题器。其中的一个核心组件就是解方程组的程序，xht 决定将这个任务交给你。", "description": "一开始，xht 有 $N$ 个变量，记为 $x_1,x_2,\\cdots,x_n$。另有一个常数 $K$，以及 $M$ 个方程，每个方程都形如 $x_a-x_b≡c\\pmod K$。\n\n由于题目可能会变化，xht 需要不时增加一个新的方程，或者删掉一个方程。\n\n同时，xht 会给你一些这样的询问：令变量 $x_a=c$，求另一个变量 $x_b \\bmod K$ 的值。当然，有的时候会因为条件不足，无法解出 $x_b$，那么就输出 $-1$。\n\n数据保证任意时刻两个变量之间最多存在一个方程。保证不会出现自相矛盾的方程组，也不会出现多余的条件（某个方程可以通过其他一些方程推出来）。", "inputFormat": "第一行四个整数 $N,M,K,Q$，含义如上。$Q$ 代表操作的条数。\n\n接下来 $M$ 行，每行三个整数 $a,b,c$，表示方程 $x_a-x_b≡c\\pmod K$。\n\n接下来 $Q$ 行，每行第一个数 $t$ 代表操作种类，\n\n\\* $t=1$，接下来输入 $a,b,c$，代表增加一条方程 $x_a-x_b≡c\\pmod K$；\n\n\\* $t=2$，接下来输入 $a,b$，代表删除 $a,b$ 之间的方程，如果这条方程不存在，则什么也不做；\n\n\\* $t=3$，接下来输入 $a,b,c$，代表询问：令 $x_a=c$，求 $x_b \\bmod K$ 的值；", "outputFormat": "对于每一个 $3$ 操作（询问），输出一行一个数 $x$（$0\\le x<K$），表示 $x_b \\bmod K$，如果条件不足，则输出 $-1$。", "hint": "样例的解释：\n\n一开始有两条方程：$x_1-x_2=1$，$x_2-x_3=2$。\n\n第一次询问，令$x_1=0$，解得$x_3=(-3)\\bmod100=97$。\n\n第二次询问时，删掉了第二条方程，导致条件不足，无法解出 $x_3$，输出 $-1$。\n\n对于 $40\\%$ 的数据，只有询问操作。\n\n对于 $100\\%$ 的数据，$1\\le M<N\\le10^5$，$1\\le Q\\le10^5$，$2\\le K\\le10^3$，$1\\le a,b\\le N$，$0\\le c<K$。\n\n保证所有的 $a\\ne b$。", "locale": "zh-CN"}}}
{"pid": "P3638", "type": "P", "difficulty": 6, "samples": [["4 10 5 \n1.........\nAA...x4...\n..A..x....\n2....x....\n..C.3.A...", "5"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["搜索", "2013", "APIO", "记忆化搜索", "队列"], "title": "[APIO2013] 机器人", "background": null, "description": "VRI（Voltron 机器人学会）的工程师建造了 n 个机器人。任意两个兼容的机器人站在同一个格子时可以合并为一个复合机器人。\n\n我们把机器人用 1 至 n 编号（n ≤ 9）。如果两个机器人的编号是连续的，那么它们是兼容的，可以合并成一个复合机器人。最初这 n 个机器人各自都只有唯一的编号。而一个由两个或以上的机器人合并构成的复合机器人拥有两个编号，分别是构成它的所有机器人中最小和最大的编号。\n\n例如，2 号机器人只可以与 1 号或 3 号机器人合并。若 2 号机器人与 3 号机器人合并，可构成编号为 2-3 的复合机器人。如果编号为 2-3 的复合机器人与编 号为 4-6 的复合机器人合并，可构成编号为 2-6 的复合机器人。当所有机器人合并以后则构成 1-n 复合机器人。\n\n工程师把这 n 个机器人放在了一个封闭的房间中，房间四周均是墙。该房间被划分成 w × h 个方格。有些方格有障碍物，机器人不可经过或停留；其余方格允许多个机器人停留，同时允许机器人经过。任何时候一个机器人只占用一个方格。初始时刻，所有机器人均在不同的方格中。\n\n这些原始的机器人不会自发地移动。它们只有被工程师沿 x 轴或 y 轴推动后，才会沿推动的方向不断向前直线移动，直至碰到障碍物或墙停止移动。停止移动后，它会扫描当前的格子是否存在可以与它合并的机器人，如果有，则合并并继续检查，直至不能再合并为止。工程师只能沿水平向左、水平向右、竖直向上、竖直向下四个方向推动机器人，并且，在机器人尚未停止移动时，不允许推动其它机器人，因此任何时刻，房间中都只能有一个机器人移动。\n\n为了帮助机器人转向，工程师在一些格子中放置了转向器。具体地说，转向器分为顺时针转向器（右转器）和逆时针转向器（左转器），顺时针转向器可以使到达该格子的机器人沿顺时针方向转向 90°；逆时针转向器可以使到达该格子的机器人沿逆时针方向转向 90°。\n\n现在，我们将告诉你初始时刻房间内的信息。请你计算工程师最少共计需要推动机器人多少次，才能把所有的 n 个机器人全部合并（如果可能的话）。", "inputFormat": "你的程序必须从标准输入读入。\n\n输入的第 1 行包含 3 个整数 n、w 和 h，用 空格隔开。\n\n输入文件中接下来的 h 行描述初始时刻房间内的信息，每行包含 w 个字符。 这 w × h 个字符中每一个表示房间中的一个格子，意义如下：\n\n‘1’至‘9’：表示该方格中有一个机器人，编号为这个数字；\n\n‘x’：表示该方格有障碍物；\n\n‘A’：表示该方格中有一个逆时针转向器；\n\n‘C’：表示该方格中有一个顺时针转向器；\n\n‘.’：表示该方格为空地。", "outputFormat": "你的程序必须输出到标准输出。输出仅一个整数，表示最少需要推动的次数。 若不能使所有机器人全部合并，输出-1。", "hint": "第一步：向右推动 3 号机器人，当它碰到转向器后会向上继续移动，直至碰 到墙壁停止移动。\n\n第二步：向上推动 4 号机器人，当它碰到墙壁后停止移动，与 3 号机器人合 并，构成 3-4 号机器人\n\n第三步：向上推动 2 号机器人，当它碰到转向器后会向左移动，由于左侧为 墙壁，故停留在原地。\n\n第四步：向右推动 2 号机器人，由于它在一个转向器上，故它会向上移动， 直至碰到墙壁停止移动，与 1 号机器人合并，构成 1-2 号机器人。\n\n第五步：向左推动 3-4 号机器人，当它碰到墙壁后停止移动，与 1-2 号机器 人合并，构成 1-4 号机器人。\n\n\n我们将使用以下 4 类输入测例测试你的程序。\n\n1. （10 分）测例满足 n = 2，w ≤ 10 且 h ≤ 10，没有任何转向器。\n\n2. （20 分）测例满足 n = 2，w ≤ 10 且 h ≤ 10。\n\n3. （30 分）测例满足 n ≤ 9，w ≤ 300 且 h ≤ 300。\n\n4. （40 分）测例满足 n ≤ 9，w ≤ 500 且 h ≤ 500。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2013] Robots", "background": "", "description": "Engineers of VRI (Voltron Robotics Institute) built $n$ robots. Any two compatible robots standing in the same cell can merge into a composite robot.\n\nWe number the robots from $1$ to $n$ ($n \\le 9$). Two robots are compatible if their numbers are consecutive, in which case they can merge into a composite robot. Initially, each of the $n$ robots has a unique number. A composite robot formed by two or more robots carries two numbers: the minimum and maximum among the numbers of all robots that compose it.\n\nFor example, robot $2$ can merge only with robot $1$ or robot $3$. If robot $2$ merges with robot $3$, they form the composite robot $2$–$3$. If the composite robot $2$–$3$ merges with the composite robot $4$–$6$, they form the composite robot $2$–$6$. Once all robots have merged, they form the composite robot $1$–$n$.\n\nThe engineers placed these $n$ robots in a closed room bounded by walls. The room is divided into $w \\times h$ grid cells. Some cells contain obstacles that robots cannot pass through or stop on; other cells allow multiple robots to stop in or pass through. At any time, a robot occupies exactly one cell. Initially, all robots are in distinct cells.\n\nThese original robots do not move on their own. They only move when an engineer pushes them along the $x$-axis or $y$-axis. After being pushed, a robot continues moving straight in that direction until it hits an obstacle or a wall, where it stops. After stopping, it checks whether there are robots in the current cell that it can merge with; if so, it merges and continues checking until no further merge is possible. Engineers may push robots only in four directions: left, right, up, and down. Also, while a robot is still moving, no other robot may be pushed; therefore, at any moment, at most one robot is moving in the room.\n\nTo help robots turn, the engineers placed turners in some cells. Specifically, there are clockwise turners (right-turners) and counterclockwise turners (left-turners). A clockwise turner makes a robot that arrives at that cell turn $90^\\circ$ clockwise; a counterclockwise turner makes it turn $90^\\circ$ counterclockwise.\n\nGiven the initial state of the room, compute the minimum number of pushes needed to merge all $n$ robots (if possible).", "inputFormat": "Your program must read from standard input.\n\nThe first line contains three integers $n$, $w$, and $h$, separated by spaces.\n\nEach of the next $h$ lines describes the initial state of the room and contains $w$ characters. Each of these $w \\times h$ characters represents one cell of the room, with the following meanings:\n- '1' to '9': there is a robot in this cell with that number.\n- 'x': there is an obstacle in this cell.\n- 'A': there is a counterclockwise turner in this cell.\n- 'C': there is a clockwise turner in this cell.\n- '.': this cell is empty.", "outputFormat": "Your program must write to standard output. Output a single integer: the minimum number of pushes required. If it is impossible to merge all robots, output -1.", "hint": "Step 1: Push robot 3 to the right. After it hits a turner, it will continue moving upward until it hits the wall and stops.\n\nStep 2: Push robot 4 upward. After it hits the wall, it stops and merges with robot 3 to form the composite robot 3–4.\n\nStep 3: Push robot 2 upward. After it hits a turner, it moves left. Because there is a wall to the left, it stays in place.\n\nStep 4: Push robot 2 to the right. Since it is on a turner, it will move upward until it hits the wall and stops, then merges with robot 1 to form the composite robot 1–2.\n\nStep 5: Push the composite robot 3–4 to the left. After it hits the wall, it stops and merges with the composite robot 1–2 to form the composite robot 1–4.\n\nWe will use the following four classes of input test cases to test your program.\n1. (10 points) $n = 2$, $w \\le 10$, $h \\le 10$, with no turners.\n2. (20 points) $n = 2$, $w \\le 10$, $h \\le 10$.\n3. (30 points) $n \\le 9$, $w \\le 300$, $h \\le 300$.\n4. (40 points) $n \\le 9$, $w \\le 500$, $h \\le 500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2013] 机器人", "background": null, "description": "VRI（Voltron 机器人学会）的工程师建造了 n 个机器人。任意两个兼容的机器人站在同一个格子时可以合并为一个复合机器人。\n\n我们把机器人用 1 至 n 编号（n ≤ 9）。如果两个机器人的编号是连续的，那么它们是兼容的，可以合并成一个复合机器人。最初这 n 个机器人各自都只有唯一的编号。而一个由两个或以上的机器人合并构成的复合机器人拥有两个编号，分别是构成它的所有机器人中最小和最大的编号。\n\n例如，2 号机器人只可以与 1 号或 3 号机器人合并。若 2 号机器人与 3 号机器人合并，可构成编号为 2-3 的复合机器人。如果编号为 2-3 的复合机器人与编 号为 4-6 的复合机器人合并，可构成编号为 2-6 的复合机器人。当所有机器人合并以后则构成 1-n 复合机器人。\n\n工程师把这 n 个机器人放在了一个封闭的房间中，房间四周均是墙。该房间被划分成 w × h 个方格。有些方格有障碍物，机器人不可经过或停留；其余方格允许多个机器人停留，同时允许机器人经过。任何时候一个机器人只占用一个方格。初始时刻，所有机器人均在不同的方格中。\n\n这些原始的机器人不会自发地移动。它们只有被工程师沿 x 轴或 y 轴推动后，才会沿推动的方向不断向前直线移动，直至碰到障碍物或墙停止移动。停止移动后，它会扫描当前的格子是否存在可以与它合并的机器人，如果有，则合并并继续检查，直至不能再合并为止。工程师只能沿水平向左、水平向右、竖直向上、竖直向下四个方向推动机器人，并且，在机器人尚未停止移动时，不允许推动其它机器人，因此任何时刻，房间中都只能有一个机器人移动。\n\n为了帮助机器人转向，工程师在一些格子中放置了转向器。具体地说，转向器分为顺时针转向器（右转器）和逆时针转向器（左转器），顺时针转向器可以使到达该格子的机器人沿顺时针方向转向 90°；逆时针转向器可以使到达该格子的机器人沿逆时针方向转向 90°。\n\n现在，我们将告诉你初始时刻房间内的信息。请你计算工程师最少共计需要推动机器人多少次，才能把所有的 n 个机器人全部合并（如果可能的话）。", "inputFormat": "你的程序必须从标准输入读入。\n\n输入的第 1 行包含 3 个整数 n、w 和 h，用 空格隔开。\n\n输入文件中接下来的 h 行描述初始时刻房间内的信息，每行包含 w 个字符。 这 w × h 个字符中每一个表示房间中的一个格子，意义如下：\n\n‘1’至‘9’：表示该方格中有一个机器人，编号为这个数字；\n\n‘x’：表示该方格有障碍物；\n\n‘A’：表示该方格中有一个逆时针转向器；\n\n‘C’：表示该方格中有一个顺时针转向器；\n\n‘.’：表示该方格为空地。", "outputFormat": "你的程序必须输出到标准输出。输出仅一个整数，表示最少需要推动的次数。 若不能使所有机器人全部合并，输出-1。", "hint": "第一步：向右推动 3 号机器人，当它碰到转向器后会向上继续移动，直至碰 到墙壁停止移动。\n\n第二步：向上推动 4 号机器人，当它碰到墙壁后停止移动，与 3 号机器人合 并，构成 3-4 号机器人\n\n第三步：向上推动 2 号机器人，当它碰到转向器后会向左移动，由于左侧为 墙壁，故停留在原地。\n\n第四步：向右推动 2 号机器人，由于它在一个转向器上，故它会向上移动， 直至碰到墙壁停止移动，与 1 号机器人合并，构成 1-2 号机器人。\n\n第五步：向左推动 3-4 号机器人，当它碰到墙壁后停止移动，与 1-2 号机器 人合并，构成 1-4 号机器人。\n\n\n我们将使用以下 4 类输入测例测试你的程序。\n\n1. （10 分）测例满足 n = 2，w ≤ 10 且 h ≤ 10，没有任何转向器。\n\n2. （20 分）测例满足 n = 2，w ≤ 10 且 h ≤ 10。\n\n3. （30 分）测例满足 n ≤ 9，w ≤ 300 且 h ≤ 300。\n\n4. （40 分）测例满足 n ≤ 9，w ≤ 500 且 h ≤ 500。", "locale": "zh-CN"}}}
{"pid": "P3639", "type": "P", "difficulty": 6, "samples": [["5 5 1 \n3 5 2 \n1 2 3 \n2 3 5 \n2 4 4 \n4 3 6 \n1 3 \n10 20 30 40 50", "400"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2013", "APIO", "生成树", "连通块"], "title": "[APIO2013] 道路费用", "background": null, "description": "幸福国度可以用 $N$ 个城镇（用 $1$ 到 $N$ 编号）构成的集合来描述，这些城镇 最开始由 $M$ 条双向道路（用 $1$ 到 $M$ 编号）连接。城镇 $1$ 是中央城镇。保证一个人从城镇 $1$ 出发，经过这些道路，可以到达其他的任何一个城市。这些道路都是收费道路，道路 $i$ 的使用者必须向道路的主人支付 $c_i$ 分钱的费用。已知所有的这些 $c_i$ 是互不相等的。最近有 $K$ 条新道路建成，这些道路都属于亿万富豪 $\\text{Mr. Greedy}$。$\\text{Mr. Greedy}$ 可以决定每条新道路的费用（费用可以相同），并且他必须在明天宣布这些费用。\n\n两周以后，幸福国度将举办一个盛况空前的嘉年华！大量的参与者将沿着这些道路前往中央城镇。共计 $p_j$ 个参与者将从城镇 $j$ 出发前往中央城镇。这些人只会沿着一个选出的道路集合前行，并且这些选出的道路将在这件事的前一天公布。根据一个古老的习俗，这些道路将由幸福国度中最有钱的人选出，也就是 $\\text{Mr. Greedy}$。同样根据这个习俗，$\\text{Mr. Greedy}$ 选出的这个道路集合必须使所有选出道路的费用之和最小，并且仍要保证任何人可以从城镇 $j$ 前往城镇 $1$（因此， 这些选出的道路来自将费用作为相应边边权的“最小生成树”）。如果有多个这样的道路集合，$\\text{Mr. Greedy}$ 可以选其中的任何一个，只要满足费用和是最小的。\n\n$\\text{Mr. Greedy}$ 很明确地知道，他从 $K$ 条新道路中获得的收入不只是与费用有关。一条道路的收入等于所有经过这条路的人的花费之和。更准确地讲，如果 $p$ 个人经过道路 $i$，道路 $i$ 产生的收入为 $c_i \\times p$ 的积。注意 $\\text{Mr. Greedy}$ 只能从新道路收取费用，因为原来的道路都不属于他。\n\n$\\text{Mr. Greedy}$ 有一个阴谋。他计划通过操纵费用和道路的选择来最大化他的收入。他希望指定每条新道路的费用（将在明天公布），并且选择嘉年华用的道路（将在嘉年华的前一天公布），使得他在 $K$ 条新道路的收入最大。注意 $\\text{Mr. Greedy}$ 仍然需要遵循选出花费之和最小的道路集合的习俗。\n\n你是一个记者，你想揭露他的计划。为了做成这件事，你必须先写一个程序来确定 $\\text{Mr. Greedy}$ 可以通过他的阴谋获取多少收入。", "inputFormat": "你的程序必须从标准输入读入。第一行包含三个由空格隔开的整数 $N,M,K$。接下来的 $M$ 行描述最开始的 $M$ 条道路。这 $M$ 行中的第 $i$ 行包含由空格隔开的整数 $a_i,b_i,c_i$，表示有一条在 $a_i$ 和 $b_i$ 之间，费用为 $c_i$ 的双向道路。接下来的 $K$ 行描述新建的 $K$ 条道路。这 $K$ 行中的第 $i$ 行包含由空格隔开的整数 $x_i$ 和 $y_i$，表示有一条连接城镇 $x_i$ 和 $y_i$ 的新道路。最后一行包含 $N$ 个由空格隔开的整数，其中的第 $j$ 个为 $p_j$，表示从城镇 $j$ 前往城镇 $1$ 的人数。\n\n输入也满足以下约束条件：$1 \\leq N \\leq 10^5,1 \\leq K \\leq 20,1 \\leq M \\leq 3\\times 10^5$，对每个 $i$ 和 $j$，$1 \\leq c_i,p_j \\leq 10^6$，如果 $i \\neq i'$，则 $c_i \\neq c_{i'}$； \n\n在任意两个城市之间，最多只有一条道路（包括新建的道路）。", "outputFormat": "你的程序必须输出恰好一个整数到标准输出，表示能获得的最大的收入。", "hint": "在样例中，$\\text{Mr. Greedy}$ 应该将新道路 $(1,3)$ 的费用设置为 $5$ 分钱。在这个费用下，他可以选择道路 $(3,5),(1,2),(2,4),(1,3)$ 来最小化总费用，这个费用为 $14$。 从城镇 $3$ 出发的 $30$ 个人和从城镇 $5$ 出发的 $50$ 个人将经过新道路前往城镇 $1$，因此他可以获得为 $(30+50)×5=400$ 分钱的最好收入。\n\n如果我们这样做，将新道路 $(1,3)$ 的费用设置为 $10$ 分钱。根据传统的限制，$\\text{Mr. Greedy}$ 必须选择 $(3,5),(1,2),(2,4),(2,3)$，因为这是唯一费用最小的集合。 因此，在嘉年华的过程中道路 $(1,3)$ 将没有任何收入。\n\n\n我们将使用以下 $5$ 类测例测试你的程序。\n\n1. （国际 $16$ 分，国内 $15$ 分）$N ≤ 10,M ≤ 20,K = 1$；\n\n2. （国际 $18$ 分，国内 $20$ 分）$N ≤ 30,M ≤ 50, K ≤ 10$；\n\n3. （国际 $22$ 分，国内 $20$ 分）$N ≤ 10^3,M ≤ 5\\times 10^3,K ≤ 10$;\n\n4. （国际 $22$ 分，国内 $20$ 分）$N ≤ 10^5,M ≤ 3\\times 10^5, K ≤ 15$；\n\n5. （国际 $22$ 分，国内 $25$ 分）$N ≤ 10^5，M ≤ 3\\times 10^5, K ≤ 20$。\n\n**update: 2024/07/04 删除了两个测试点，并且改为捆绑。**", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2013] Toll", "background": "", "description": "The Kingdom of Happiness can be described as a set of $N$ towns (numbered $1$ to $N$), initially connected by $M$ bidirectional roads (numbered $1$ to $M$). Town $1$ is the central town. It is guaranteed that starting from town $1$, one can reach any other town using these roads. All roads are toll roads: for road $i$, a user must pay $c_i$ cents to the road’s owner. It is known that all $c_i$ are pairwise distinct. Recently, $K$ new roads were built, all owned by $\\text{Mr. Greedy}$. $\\text{Mr. Greedy}$ can decide the toll for each new road (these tolls may be equal), and he must announce these tolls tomorrow.\n\nTwo weeks later, the Kingdom of Happiness will host a grand carnival. A large number of participants will travel along the roads to the central town. In total, $p_j$ participants will start from town $j$ and head to town $1$. These people will travel only along a selected set of roads, and this selected set of roads will be announced the day before the event. According to an ancient custom, this set is chosen by the richest person in the kingdom, namely $\\text{Mr. Greedy}$. By the same custom, the chosen set must minimize the sum of tolls of all selected roads and still ensure that everyone can travel from town $j$ to town $1$ (therefore, the selected roads form a “minimum spanning tree” with respect to the tolls as edge weights). If there are multiple such sets, $\\text{Mr. Greedy}$ may choose any of them, as long as the total toll is minimal.\n\n$\\text{Mr. Greedy}$ understands clearly that his revenue from the $K$ new roads depends not only on the toll values. The revenue of a road equals the total amount paid by all people who pass through it. More precisely, if $p$ people pass through road $i$, the revenue of road $i$ is the product $c_i \\times p$. Note that $\\text{Mr. Greedy}$ can only collect tolls from the new roads, since the original roads are not his.\n\n$\\text{Mr. Greedy}$ has a scheme. He plans to maximize his revenue by manipulating the tolls and the choice of roads. He wants to set the toll for each new road (to be announced tomorrow) and choose the roads used for the carnival (to be announced the day before the carnival) so that his total revenue from the $K$ new roads is maximized. Note that $\\text{Mr. Greedy}$ must still follow the custom of selecting a road set with the minimum total toll.\n\nYou are a journalist and you want to expose his plan. To do this, you must first write a program to determine how much revenue $\\text{Mr. Greedy}$ can obtain through his scheme.", "inputFormat": "Your program must read from standard input. The first line contains three space-separated integers $N, M, K$. The next $M$ lines describe the initial $M$ roads. In these $M$ lines, the $i$-th line contains space-separated integers $a_i, b_i, c_i$, indicating a bidirectional road between $a_i$ and $b_i$ with toll $c_i$. The next $K$ lines describe the $K$ newly built roads. In these $K$ lines, the $i$-th line contains space-separated integers $x_i$ and $y_i$, indicating a new road connecting towns $x_i$ and $y_i$. The last line contains $N$ space-separated integers, where the $j$-th is $p_j$, the number of people traveling from town $j$ to town $1$.\n\nConstraints: $1 \\leq N \\leq 10^5, 1 \\leq K \\leq 20, 1 \\leq M \\leq 3 \\times 10^5$. For each $i$ and $j$, $1 \\leq c_i, p_j \\leq 10^6$, and if $i \\neq i'$, then $c_i \\neq c_{i'}$. Between any two towns, there is at most one road (including newly built roads).", "outputFormat": "Your program must output exactly one integer to standard output, which is the maximum obtainable revenue.", "hint": "In the sample, $\\text{Mr. Greedy}$ should set the toll of the new road $(1,3)$ to $5$ cents. With this toll, he can choose roads $(3,5), (1,2), (2,4), (1,3)$ to minimize the total toll, which is $14$. The $30$ people from town $3$ and the $50$ people from town $5$ will pass through the new road on their way to town $1$, so he can obtain the best revenue of $(30+50)×5=400$ cents.\n\nIf instead we set the toll of the new road $(1,3)$ to $10$ cents, then by the customary constraint $\\text{Mr. Greedy}$ must choose $(3,5), (1,2), (2,4), (2,3)$, because this is the unique set with minimum total toll. Therefore, during the carnival the road $(1,3)$ will bring no revenue.\n\nWe will use the following $5$ types of test cases to evaluate your program.\n\n1. (International $16$ points, Domestic $15$ points) $N \\leq 10, M \\leq 20, K = 1$.\n2. (International $18$ points, Domestic $20$ points) $N \\leq 30, M \\leq 50, K \\leq 10$.\n3. (International $22$ points, Domestic $20$ points) $N \\leq 10^3, M \\leq 5 \\times 10^3, K \\leq 10$.\n4. (International $22$ points, Domestic $20$ points) $N \\leq 10^5, M \\leq 3 \\times 10^5, K \\leq 15$.\n5. (International $22$ points, Domestic $25$ points) $N \\leq 10^5, M \\leq 3 \\times 10^5, K \\leq 20$.\n\nupdate: 2024/07/04 Two test points were removed, and the tests were changed to bundled.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2013] 道路费用", "background": null, "description": "幸福国度可以用 $N$ 个城镇（用 $1$ 到 $N$ 编号）构成的集合来描述，这些城镇 最开始由 $M$ 条双向道路（用 $1$ 到 $M$ 编号）连接。城镇 $1$ 是中央城镇。保证一个人从城镇 $1$ 出发，经过这些道路，可以到达其他的任何一个城市。这些道路都是收费道路，道路 $i$ 的使用者必须向道路的主人支付 $c_i$ 分钱的费用。已知所有的这些 $c_i$ 是互不相等的。最近有 $K$ 条新道路建成，这些道路都属于亿万富豪 $\\text{Mr. Greedy}$。$\\text{Mr. Greedy}$ 可以决定每条新道路的费用（费用可以相同），并且他必须在明天宣布这些费用。\n\n两周以后，幸福国度将举办一个盛况空前的嘉年华！大量的参与者将沿着这些道路前往中央城镇。共计 $p_j$ 个参与者将从城镇 $j$ 出发前往中央城镇。这些人只会沿着一个选出的道路集合前行，并且这些选出的道路将在这件事的前一天公布。根据一个古老的习俗，这些道路将由幸福国度中最有钱的人选出，也就是 $\\text{Mr. Greedy}$。同样根据这个习俗，$\\text{Mr. Greedy}$ 选出的这个道路集合必须使所有选出道路的费用之和最小，并且仍要保证任何人可以从城镇 $j$ 前往城镇 $1$（因此， 这些选出的道路来自将费用作为相应边边权的“最小生成树”）。如果有多个这样的道路集合，$\\text{Mr. Greedy}$ 可以选其中的任何一个，只要满足费用和是最小的。\n\n$\\text{Mr. Greedy}$ 很明确地知道，他从 $K$ 条新道路中获得的收入不只是与费用有关。一条道路的收入等于所有经过这条路的人的花费之和。更准确地讲，如果 $p$ 个人经过道路 $i$，道路 $i$ 产生的收入为 $c_i \\times p$ 的积。注意 $\\text{Mr. Greedy}$ 只能从新道路收取费用，因为原来的道路都不属于他。\n\n$\\text{Mr. Greedy}$ 有一个阴谋。他计划通过操纵费用和道路的选择来最大化他的收入。他希望指定每条新道路的费用（将在明天公布），并且选择嘉年华用的道路（将在嘉年华的前一天公布），使得他在 $K$ 条新道路的收入最大。注意 $\\text{Mr. Greedy}$ 仍然需要遵循选出花费之和最小的道路集合的习俗。\n\n你是一个记者，你想揭露他的计划。为了做成这件事，你必须先写一个程序来确定 $\\text{Mr. Greedy}$ 可以通过他的阴谋获取多少收入。", "inputFormat": "你的程序必须从标准输入读入。第一行包含三个由空格隔开的整数 $N,M,K$。接下来的 $M$ 行描述最开始的 $M$ 条道路。这 $M$ 行中的第 $i$ 行包含由空格隔开的整数 $a_i,b_i,c_i$，表示有一条在 $a_i$ 和 $b_i$ 之间，费用为 $c_i$ 的双向道路。接下来的 $K$ 行描述新建的 $K$ 条道路。这 $K$ 行中的第 $i$ 行包含由空格隔开的整数 $x_i$ 和 $y_i$，表示有一条连接城镇 $x_i$ 和 $y_i$ 的新道路。最后一行包含 $N$ 个由空格隔开的整数，其中的第 $j$ 个为 $p_j$，表示从城镇 $j$ 前往城镇 $1$ 的人数。\n\n输入也满足以下约束条件：$1 \\leq N \\leq 10^5,1 \\leq K \\leq 20,1 \\leq M \\leq 3\\times 10^5$，对每个 $i$ 和 $j$，$1 \\leq c_i,p_j \\leq 10^6$，如果 $i \\neq i'$，则 $c_i \\neq c_{i'}$； \n\n在任意两个城市之间，最多只有一条道路（包括新建的道路）。", "outputFormat": "你的程序必须输出恰好一个整数到标准输出，表示能获得的最大的收入。", "hint": "在样例中，$\\text{Mr. Greedy}$ 应该将新道路 $(1,3)$ 的费用设置为 $5$ 分钱。在这个费用下，他可以选择道路 $(3,5),(1,2),(2,4),(1,3)$ 来最小化总费用，这个费用为 $14$。 从城镇 $3$ 出发的 $30$ 个人和从城镇 $5$ 出发的 $50$ 个人将经过新道路前往城镇 $1$，因此他可以获得为 $(30+50)×5=400$ 分钱的最好收入。\n\n如果我们这样做，将新道路 $(1,3)$ 的费用设置为 $10$ 分钱。根据传统的限制，$\\text{Mr. Greedy}$ 必须选择 $(3,5),(1,2),(2,4),(2,3)$，因为这是唯一费用最小的集合。 因此，在嘉年华的过程中道路 $(1,3)$ 将没有任何收入。\n\n\n我们将使用以下 $5$ 类测例测试你的程序。\n\n1. （国际 $16$ 分，国内 $15$ 分）$N ≤ 10,M ≤ 20,K = 1$；\n\n2. （国际 $18$ 分，国内 $20$ 分）$N ≤ 30,M ≤ 50, K ≤ 10$；\n\n3. （国际 $22$ 分，国内 $20$ 分）$N ≤ 10^3,M ≤ 5\\times 10^3,K ≤ 10$;\n\n4. （国际 $22$ 分，国内 $20$ 分）$N ≤ 10^5,M ≤ 3\\times 10^5, K ≤ 15$；\n\n5. （国际 $22$ 分，国内 $25$ 分）$N ≤ 10^5，M ≤ 3\\times 10^5, K ≤ 20$。\n\n**update: 2024/07/04 删除了两个测试点，并且改为捆绑。**", "locale": "zh-CN"}}}
{"pid": "P3640", "type": "P", "difficulty": 6, "samples": [["3\n2 1 4 2 1\n0\n1 1 2\n2\n0 1\n1 0\n//以上为问题1", "3\n1000000000\nThe value of counter is: 5"], ["4 5\n0 1\n0 2\n0 3\n1 2\n2 3\n//以上为问题2", "3\n0 1 2 1\nThe value of counter is: 18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "APIO", "提交答案", "Special Judge", "最短路", "构造"], "title": "[APIO2013] 出题人", "background": "", "description": "当今世界上各类程序设计竞赛层出不穷。而设计一场好比赛绝非易事，比如给题目设计测试数据就是一项挑战。一组好的测试数据需要对不同的程序有区分度：满足所有要求的程序自然应该得到满分，而那些貌似正确的程序则会在某些特殊数据上出错。\n\n在本题中，你在比赛中的角色反转啦！作为一名久经百战的程序员，你将帮助 Happy Programmer Contest 的命题委员会设计这次比赛的测试数据。本次比赛命题委员会选择了两个图论问题，分为 $8$ 个子任务。委员会写了一些貌似可以解决这些子任务的代码。在给任务设计数据的时候，命题委员会期望其中的一些源程序能够得到满分，而另外的一些则只能得到 $0$ 分或者少许的部分分。现在你将会获得这些源程序（C, C++, Pascal 版本）。对于每个子任务，你需要去产生一组数据 $X$ 使得它能将该任务给定的 $2$ 种源程序 $A$ 和 $B$ 区分开来。更具体地说，生成的数据必须满足如下两个条件:\n\n输入 $X$ 对于源程序 $A$ 一定不会出现超出时间限制（TLE）的问题。\n\n输入 $X$ 一定会导致源程序 $B$ 产生超出时间限制的问题。\n\n此外,命题委员喜欢较小规模的测试数据，希望测试数据最好能够包含不超过 $T$ 个整数。\n\n本题中只关心源程序 $A$ 和 $B$ 是否超时，不关心是否结果正确。\n\n命题委员会选择了单源最短路（SSSP）以及一个被称之为神秘问题（Mystery）的两个图论问题来作为比赛的题目。我们将命题委员会完成的伪代码列在了附录中，而具体的 C、C++ 和 Pascal 源程序被我们放在了下发的文件当中。\n\n### 子任务\n\n参见下表。表中每一行描述了一个子任务。其中前六个子任务与单源最短路相关，子任务 7,8 与神秘问题相关。每个任务所占分数见下表。\n\n ![](https://cdn.luogu.com.cn/upload/pic/4428.png) \n\n对于每个子任务，你的程序给出的输入 $X$ 需要能够将源程序 $A$ 和 $B$ 区分开来，这有这样你才能够得到相应的分数。具体说来，你的分数将由输入 $X$ 中数的个数决定。假设 $X$ 中包含了 $F$ 个整数，子任务的满分为 $S,T$ 是该任务的目标大小，则该测试点的分数将由下式给出:\n\n$$S \\times \\min\\{T / F, 1\\}$$\n\n也就是说，如果你的测试数据 $X$ 中含有不超过 $T$ 个整数，则你将得到该任务的全部得分。\n\n你需要把你的 $8$ 个测试数据命名为 `1.txt` ~ `8.txt`。对于每个子任务 $X$，评测系统将根据如下步骤来确定你将会得到多少分:\n\n- 如果未提交数据，则不得分；\n- 若数据不满足输入格式要求，则不得分；\n- 对源程序 $A$ 运行输入，若发生超时现象，则不得分；\n- 对源程序 $B$ 运行输入，若发生超时现象，则按照前文所述的公式给出该测试点的分数。\n\n题目提供的所有源代码均会维护一个计数器来统计程序的操作次数。在源程序的运行过程中，当该计数器超过了 $10^6$ 次时，那么我们认为程序运行超时。\n\n### 问题 1：单源最短路（SSSP）\n\n给定一个带权有向图 $G$，以及 $G$ 中的两个节点 $s$ 与 $t$，令 $p(s, t)$ 为 $G$ 中从 $s$ 至 $t$ 的最短路长度。如果 $s$ 与 $t$ 不连通，则认为 $p(s, t)=10^9$。在本题中，输入为图 $G$ 以及 $Q$ 个询问 $(s_1, t_1), (s_2, t_2), \\dots, (s_Q, t_Q)$ 。输出则是对这 $Q$ 个询问的相应输出 $p(s_1, t_1), p(s_2 , t_2), \\cdots, p(s_Q, t_Q)$。\n\n\n### 问题 2：神秘问题\n\n给定一个包含 $V$ 个节点 $E$ 条边的无向图 $G$，要求将所有的节点进行编号（编号范围为 $[0, X-1]$），使得所有直接相连的节点均有不同的编号。找出符合题意的最小的 $X$。\n", "inputFormat": "### 问题 1\n\n输入数据包含两部分，其中第一部分使用邻接表来描述带权有向图 $G$。第二部分则描述对 $G$ 的最短路径的查询。\n\n数据第一部分的第一行包含一个整数 $V$，表示 $G$ 中点的个数，所有点的编号为 $0, 1, \\cdots, V - 1$。\n\n接下来 $V$ 行，每行描述一个点的所有边。行中的第一个整数 $n_i$ 描述了节点 $i$ 的出边数量，接下来有 $n_i$ 个整数对 $(j, w)$ 表示有一条从 $i$ 到 $j$，边权为 $w$ 的边。\n\n数据第二部分的第一行包含一个整数 $Q$，表示询问的组数。\n\n接下来 $Q$ 行，第 $k$ 行包含两个整数 $s_k, t_k$，为该询问对应的起点与终点位置。\n\n同一行中任意两个相邻的整数均需要至少一个空格将他们分开。除此之外，数据还需满足如下条件:\n\n- $0 < V \\leq 300$，$n_i$ 是一个非负整数，$0 \\leq j < V$，$\\lvert w \\rvert < 10^6$，$0 \\leq \\sum\\limits_{i = 0}^{V-1} n_i \\leq 5000$，$0 < Q \\leq 10$，$0 \\leq s_k < V, 0 \\leq t_k < V$；\n- 图中没有负权圈。\n\n\n\n### 问题 2\n\n输入数据的第一行包含两个整数 $V$ 和 $E$。\n\n接下来 $E$ 行,每行两个整数 $a, b$，表示 $a$ 与 $b$ 在 $G$ 中直接相连。此外,输入数据应满足如下限制条件:\n\n- $70 < V < 1000$，$1500 < E < 10^6$；\n- 对于所有的边 $(a, b)$，有 $a \\neq b, 0 \\leq a < V, 0 \\leq b < V$，不会重复描述一条边。\n\n", "outputFormat": "### 问题 1\n\n程序将会输出 $Q$ 行，每行一个整数，表示对应的 $p(s_k , t_k)$。而在输出的最后，所有提供的程序都会给出计数器对此输入的数值。\n\n### 问题 2\n\n程序将在第一行输出 $X$，即最小的编号范围，接下来在第二行中给出 $V$ 个整数，依次描述节点 $0$ 至 $V - 1$ 的编号。在输出的最后，所有提供的程序都会给出计数器对此输入的数值。", "hint": "**源代码见附件**。\n\n### 附录：伪代码\n\n接下来是我们提供的所有程序的伪代码；变量 counter 近似描述出了程序的运行时间。评测时将会使用这些伪代码的 C++ 版本来进行评测。\n\n\nFloydWarshall\n\n```cpp\n// pre-condition: the graph is stored in an adjacency matrix M\ncounter = 0\nfor k = 0 to V-1\n    for i = 0 to V-1\n        for j = 0 to V-1\n            increase counter by 1;\n            M[i][j] = min(M[i][j], M[i][k] + M[k][j]);\nfor each query p(s,t)\n    output M[s][t];\n```\n\nOptimizedBellmanFord\n\n```cpp\n// pre-condition: the graph is stored in an adjacency list L\ncounter = 0\nfor each query p(s,t);\n    dist[s] = 0; // s is the source vertex\n    loop V-1 times\n        change = false;\n        for each edge (u,v) in L\n            increase counter by 1;\n            if dist[u] + weight(u,v) < dist[v]\n                dist[v] = dist[u] + weight(u,v);\n                change = true;\n        if change is false // this is the ’optimized’ Bellman Ford\n            break from the outermost loop;\n    output dist[t];\n```\n\nModifiedDijkstra\n\n```cpp\n// pre-condition: the graph is stored in an adjacency list L\ncounter = 0;\nfor each query p(s,t)\n    dist[s] = 0;\n    pq.push(pair(0, s)); // pq is a priority queue\n    while pq is not empty\n        increase counter by 1;\n        (d, u) = the top element of pq;\n        remove the top element from pq;\n        if (d == dist[u])\n            for each edge (u,v) in L\n                if (dist[u] + weight(u,v) ) < dist[v]\n                    dist[v] = dist[u] + weight(u,v);\n                    insert pair (dist[v], v) into the pq;\n    output dist[t];\n```\n\nGamble1\n\n```cpp\nSets X = V;\nlabels vertex i in [0..V-1] with i;\nSets counter = 0; // will never get TLE\n```\nGamble2\n\n```cpp\nSets X = V;\nlabels vertex i in [0..V-1] with i;\nSets counter = 1000001; // force this to get TLE\n```\n\nRecursiveBacktracking\n\n```cpp\nThis algorithm tries X from 2 to V one by one and stops at the first valid X.  \nFor each X, the backtracking routine label vertex 0 with 0, then for each vertex u that has been assigned a label, the backtracking routine tries to assign \nthe smallest possible label up to label X-1 to its neighbor v, and backtracks if necessary.  \n// Please check RecursiveBacktracking.cpp/pas to see \n// the exact lines where the iteration counter is increased by 1\n```\n\n感谢zhouyonglong修改spj\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2013] Problem Setter", "background": "", "description": "All kinds of programming contests are flourishing nowadays. Designing a good contest is by no means easy; for example, creating testdata for problems is a challenge. A good set of testdata should differentiate between different programs: programs that meet all requirements should naturally get full score, while those that look correct may fail on some special data.\n\nIn this problem, your role in the contest is reversed. As a seasoned programmer, you will help the Happy Programmer Contest problem-setting committee design the testdata for this contest. The committee chose two graph problems, split into $8$ subtasks. They wrote some code that seems to solve these subtasks. When designing testdata, the committee expects some of these source programs to receive full score, while others should get $0$ or only a small amount of partial score. You will be given these source programs (C, C++, Pascal versions). For each subtask, you need to produce a dataset $X$ that distinguishes the two given source programs $A$ and $B$ for that subtask. More specifically, the generated data must satisfy the following two conditions:\n\n- On input $X$, source program $A$ will definitely not exceed the time limit (TLE).\n- On input $X$, source program $B$ will definitely exceed the time limit (TLE).\n\nIn addition, the committee prefers small-scale testdata and hopes the testdata contains at most $T$ integers.\n\nIn this problem, we only care whether source programs $A$ and $B$ time out; we do not care whether their results are correct.\n\nThe problem-setting committee chose two graph problems as the contest tasks: Single-Source Shortest Path (SSSP) and a problem called the “Mystery” problem. We list the pseudocode completed by the committee in the appendix, and the specific C, C++ and Pascal source programs are included in the provided files.\n\nSubtasks\n\nSee the table below. Each row describes one subtask. The first six subtasks are related to SSSP, and subtasks 7 and 8 are related to the Mystery problem. The score of each subtask is shown in the table.\n\n![](https://cdn.luogu.com.cn/upload/pic/4428.png)\n\nFor each subtask, the input $X$ produced by your program must be able to distinguish the source programs $A$ and $B$ for that task; only then can you get the corresponding score. Specifically, your score is determined by the number of integers in $X$. Suppose $X$ contains $F$ integers, the full score of the subtask is $S$, and $T$ is the target size for that task. Then the score for this test will be given by:\n\n$$S \\times \\min\\{T / F, 1\\}.$$\n\nThat is, if your testdata $X$ contains at most $T$ integers, you will receive the full score for that subtask.\n\nYou need to name your $8$ test files as 1.txt ~ 8.txt. For each subtask data $X$, the judging system will determine your score according to the following steps:\n\n- If no data is submitted, you receive no score.\n- If the data does not meet the input format requirements, you receive no score.\n- Run source program $A$ on the input; if a timeout occurs, you receive no score.\n- Run source program $B$ on the input; if a timeout occurs, the score for this test is given by the formula above.\n\nAll provided source programs maintain a counter to count the number of operations performed by the program. During execution, when this counter exceeds $10^6$, we consider the program to have timed out.\n\nProblem 1: Single-Source Shortest Path (SSSP)\n\nGiven a weighted directed graph $G$ and two vertices $s$ and $t$ in $G$, let $p(s, t)$ be the length of the shortest path from $s$ to $t$ in $G$. If $s$ and $t$ are not connected, then $p(s, t) = 10^9$. In this problem, the input is the graph $G$ and $Q$ queries $(s_1, t_1), (s_2, t_2), \\dots, (s_Q, t_Q)$. The output is the corresponding values $p(s_1, t_1), p(s_2, t_2), \\cdots, p(s_Q, t_Q)$ for these $Q$ queries.\n\nProblem 2: Mystery\n\nGiven an undirected graph $G$ with $V$ vertices and $E$ edges, you are required to assign labels to all vertices (labels range from $[0, X-1]$), such that any two adjacent vertices have different labels. Find the minimum feasible $X$.\n\nAppendix: Pseudocode\n\nBelow is the pseudocode for all programs we provide; the variable counter roughly describes the running time of the programs. The C++ versions of these pseudocode programs will be used for judging.\n\nFloydWarshall\n\n```cpp\n// pre-condition: the graph is stored in an adjacency matrix M\ncounter = 0\nfor k = 0 to V-1\n    for i = 0 to V-1\n        for j = 0 to V-1\n            increase counter by 1;\n            M[i][j] = min(M[i][j], M[i][k] + M[k][j]);\nfor each query p(s,t)\n    output M[s][t];\n```\n\nOptimizedBellmanFord\n\n```cpp\n// pre-condition: the graph is stored in an adjacency list L\ncounter = 0\nfor each query p(s,t);\n    dist[s] = 0; // s is the source vertex\n    loop V-1 times\n        change = false;\n        for each edge (u,v) in L\n            increase counter by 1;\n            if dist[u] + weight(u,v) < dist[v]\n                dist[v] = dist[u] + weight(u,v);\n                change = true;\n        if change is false // this is the ’optimized’ Bellman Ford\n            break from the outermost loop;\n    output dist[t];\n```\n\nModifiedDijkstra\n\n```cpp\n// pre-condition: the graph is stored in an adjacency list L\ncounter = 0;\nfor each query p(s,t)\n    dist[s] = 0;\n    pq.push(pair(0, s)); // pq is a priority queue\n    while pq is not empty\n        increase counter by 1;\n        (d, u) = the top element of pq;\n        remove the top element from pq;\n        if (d == dist[u])\n            for each edge (u,v) in L\n                if (dist[u] + weight(u,v) ) < dist[v]\n                    dist[v] = dist[u] + weight(u,v);\n                    insert pair (dist[v], v) into the pq;\n    output dist[t];\n```\n\nGamble1\n\n```cpp\nSets X = V;\nlabels vertex i in [0..V-1] with i;\nSets counter = 0; // will never get TLE\n```\nGamble2\n\n```cpp\nSets X = V;\nlabels vertex i in [0..V-1] with i;\nSets counter = 1000001; // force this to get TLE\n```\n\nRecursiveBacktracking\n\n```cpp\nThis algorithm tries X from 2 to V one by one and stops at the first valid X.  \nFor each X, the backtracking routine label vertex 0 with 0, then for each vertex u that has been assigned a label, the backtracking routine tries to assign \nthe smallest possible label up to label X-1 to its neighbor v, and backtracks if necessary.  \n// Please check RecursiveBacktracking.cpp/pas to see \n// the exact lines where the iteration counter is increased by 1\n```", "inputFormat": "Problem 1\n\nThe input consists of two parts. The first part uses an adjacency list to describe the weighted directed graph $G$. The second part describes shortest path queries on $G$.\n\n- The first line of the first part contains an integer $V$, the number of vertices in $G$. All vertices are labeled $0, 1, \\cdots, V - 1$.\n- The next $V$ lines each describe all outgoing edges of one vertex. In the $i$-th line, the first integer $n_i$ is the out-degree of vertex $i$. Then there are $n_i$ integer pairs $(j, w)$, each indicating a directed edge from $i$ to $j$ with weight $w$.\n\nThe first line of the second part contains an integer $Q$, the number of queries.\n\nThen follow $Q$ lines. In the $k$-th line, there are two integers $s_k$ and $t_k$, the source and the target of that query.\n\nAny two adjacent integers on the same line must be separated by at least one space. In addition, the data must satisfy the following constraints:\n\n- $0 < V \\leq 300$, $n_i$ is a non-negative integer, $0 \\leq j < V$, $\\lvert w \\rvert < 10^6$, $0 \\leq \\sum\\limits_{i = 0}^{V-1} n_i \\leq 5000$, $0 < Q \\leq 10$, $0 \\leq s_k < V$, $0 \\leq t_k < V$.\n- The graph contains no negative-weight cycles.\n\nProblem 2\n\n- The first line contains two integers $V$ and $E$.\n- Then follow $E$ lines; each line contains two integers $a$ and $b$, indicating that $a$ and $b$ are adjacent in $G$.\n\nIn addition, the input must satisfy the following constraints:\n\n- $70 < V < 1000$, $1500 < E < 10^6$.\n- For every edge $(a, b)$, we have $a \\neq b$, $0 \\leq a < V$, $0 \\leq b < V$, and no edge is repeated.", "outputFormat": "Problem 1\n\nThe program will output $Q$ lines, one integer per line, representing the corresponding $p(s_k, t_k)$. At the very end, all provided programs will print the value of the counter for this input.\n\nProblem 2\n\nThe program will output $X$ in the first line, i.e., the minimum label range. In the second line, it will output $V$ integers, giving the labels of vertices $0$ to $V - 1$ in order. At the very end, all provided programs will print the value of the counter for this input.", "hint": "Source code is in the attachment.\n\nThanks to zhouyonglong for modifying the SPJ.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2013] 出题人", "background": "", "description": "当今世界上各类程序设计竞赛层出不穷。而设计一场好比赛绝非易事，比如给题目设计测试数据就是一项挑战。一组好的测试数据需要对不同的程序有区分度：满足所有要求的程序自然应该得到满分，而那些貌似正确的程序则会在某些特殊数据上出错。\n\n在本题中，你在比赛中的角色反转啦！作为一名久经百战的程序员，你将帮助 Happy Programmer Contest 的命题委员会设计这次比赛的测试数据。本次比赛命题委员会选择了两个图论问题，分为 $8$ 个子任务。委员会写了一些貌似可以解决这些子任务的代码。在给任务设计数据的时候，命题委员会期望其中的一些源程序能够得到满分，而另外的一些则只能得到 $0$ 分或者少许的部分分。现在你将会获得这些源程序（C, C++, Pascal 版本）。对于每个子任务，你需要去产生一组数据 $X$ 使得它能将该任务给定的 $2$ 种源程序 $A$ 和 $B$ 区分开来。更具体地说，生成的数据必须满足如下两个条件:\n\n输入 $X$ 对于源程序 $A$ 一定不会出现超出时间限制（TLE）的问题。\n\n输入 $X$ 一定会导致源程序 $B$ 产生超出时间限制的问题。\n\n此外,命题委员喜欢较小规模的测试数据，希望测试数据最好能够包含不超过 $T$ 个整数。\n\n本题中只关心源程序 $A$ 和 $B$ 是否超时，不关心是否结果正确。\n\n命题委员会选择了单源最短路（SSSP）以及一个被称之为神秘问题（Mystery）的两个图论问题来作为比赛的题目。我们将命题委员会完成的伪代码列在了附录中，而具体的 C、C++ 和 Pascal 源程序被我们放在了下发的文件当中。\n\n### 子任务\n\n参见下表。表中每一行描述了一个子任务。其中前六个子任务与单源最短路相关，子任务 7,8 与神秘问题相关。每个任务所占分数见下表。\n\n ![](https://cdn.luogu.com.cn/upload/pic/4428.png) \n\n对于每个子任务，你的程序给出的输入 $X$ 需要能够将源程序 $A$ 和 $B$ 区分开来，这有这样你才能够得到相应的分数。具体说来，你的分数将由输入 $X$ 中数的个数决定。假设 $X$ 中包含了 $F$ 个整数，子任务的满分为 $S,T$ 是该任务的目标大小，则该测试点的分数将由下式给出:\n\n$$S \\times \\min\\{T / F, 1\\}$$\n\n也就是说，如果你的测试数据 $X$ 中含有不超过 $T$ 个整数，则你将得到该任务的全部得分。\n\n你需要把你的 $8$ 个测试数据命名为 `1.txt` ~ `8.txt`。对于每个子任务 $X$，评测系统将根据如下步骤来确定你将会得到多少分:\n\n- 如果未提交数据，则不得分；\n- 若数据不满足输入格式要求，则不得分；\n- 对源程序 $A$ 运行输入，若发生超时现象，则不得分；\n- 对源程序 $B$ 运行输入，若发生超时现象，则按照前文所述的公式给出该测试点的分数。\n\n题目提供的所有源代码均会维护一个计数器来统计程序的操作次数。在源程序的运行过程中，当该计数器超过了 $10^6$ 次时，那么我们认为程序运行超时。\n\n### 问题 1：单源最短路（SSSP）\n\n给定一个带权有向图 $G$，以及 $G$ 中的两个节点 $s$ 与 $t$，令 $p(s, t)$ 为 $G$ 中从 $s$ 至 $t$ 的最短路长度。如果 $s$ 与 $t$ 不连通，则认为 $p(s, t)=10^9$。在本题中，输入为图 $G$ 以及 $Q$ 个询问 $(s_1, t_1), (s_2, t_2), \\dots, (s_Q, t_Q)$ 。输出则是对这 $Q$ 个询问的相应输出 $p(s_1, t_1), p(s_2 , t_2), \\cdots, p(s_Q, t_Q)$。\n\n\n### 问题 2：神秘问题\n\n给定一个包含 $V$ 个节点 $E$ 条边的无向图 $G$，要求将所有的节点进行编号（编号范围为 $[0, X-1]$），使得所有直接相连的节点均有不同的编号。找出符合题意的最小的 $X$。\n", "inputFormat": "### 问题 1\n\n输入数据包含两部分，其中第一部分使用邻接表来描述带权有向图 $G$。第二部分则描述对 $G$ 的最短路径的查询。\n\n数据第一部分的第一行包含一个整数 $V$，表示 $G$ 中点的个数，所有点的编号为 $0, 1, \\cdots, V - 1$。\n\n接下来 $V$ 行，每行描述一个点的所有边。行中的第一个整数 $n_i$ 描述了节点 $i$ 的出边数量，接下来有 $n_i$ 个整数对 $(j, w)$ 表示有一条从 $i$ 到 $j$，边权为 $w$ 的边。\n\n数据第二部分的第一行包含一个整数 $Q$，表示询问的组数。\n\n接下来 $Q$ 行，第 $k$ 行包含两个整数 $s_k, t_k$，为该询问对应的起点与终点位置。\n\n同一行中任意两个相邻的整数均需要至少一个空格将他们分开。除此之外，数据还需满足如下条件:\n\n- $0 < V \\leq 300$，$n_i$ 是一个非负整数，$0 \\leq j < V$，$\\lvert w \\rvert < 10^6$，$0 \\leq \\sum\\limits_{i = 0}^{V-1} n_i \\leq 5000$，$0 < Q \\leq 10$，$0 \\leq s_k < V, 0 \\leq t_k < V$；\n- 图中没有负权圈。\n\n\n\n### 问题 2\n\n输入数据的第一行包含两个整数 $V$ 和 $E$。\n\n接下来 $E$ 行,每行两个整数 $a, b$，表示 $a$ 与 $b$ 在 $G$ 中直接相连。此外,输入数据应满足如下限制条件:\n\n- $70 < V < 1000$，$1500 < E < 10^6$；\n- 对于所有的边 $(a, b)$，有 $a \\neq b, 0 \\leq a < V, 0 \\leq b < V$，不会重复描述一条边。\n\n", "outputFormat": "### 问题 1\n\n程序将会输出 $Q$ 行，每行一个整数，表示对应的 $p(s_k , t_k)$。而在输出的最后，所有提供的程序都会给出计数器对此输入的数值。\n\n### 问题 2\n\n程序将在第一行输出 $X$，即最小的编号范围，接下来在第二行中给出 $V$ 个整数，依次描述节点 $0$ 至 $V - 1$ 的编号。在输出的最后，所有提供的程序都会给出计数器对此输入的数值。", "hint": "**源代码见附件**。\n\n### 附录：伪代码\n\n接下来是我们提供的所有程序的伪代码；变量 counter 近似描述出了程序的运行时间。评测时将会使用这些伪代码的 C++ 版本来进行评测。\n\n\nFloydWarshall\n\n```cpp\n// pre-condition: the graph is stored in an adjacency matrix M\ncounter = 0\nfor k = 0 to V-1\n    for i = 0 to V-1\n        for j = 0 to V-1\n            increase counter by 1;\n            M[i][j] = min(M[i][j], M[i][k] + M[k][j]);\nfor each query p(s,t)\n    output M[s][t];\n```\n\nOptimizedBellmanFord\n\n```cpp\n// pre-condition: the graph is stored in an adjacency list L\ncounter = 0\nfor each query p(s,t);\n    dist[s] = 0; // s is the source vertex\n    loop V-1 times\n        change = false;\n        for each edge (u,v) in L\n            increase counter by 1;\n            if dist[u] + weight(u,v) < dist[v]\n                dist[v] = dist[u] + weight(u,v);\n                change = true;\n        if change is false // this is the ’optimized’ Bellman Ford\n            break from the outermost loop;\n    output dist[t];\n```\n\nModifiedDijkstra\n\n```cpp\n// pre-condition: the graph is stored in an adjacency list L\ncounter = 0;\nfor each query p(s,t)\n    dist[s] = 0;\n    pq.push(pair(0, s)); // pq is a priority queue\n    while pq is not empty\n        increase counter by 1;\n        (d, u) = the top element of pq;\n        remove the top element from pq;\n        if (d == dist[u])\n            for each edge (u,v) in L\n                if (dist[u] + weight(u,v) ) < dist[v]\n                    dist[v] = dist[u] + weight(u,v);\n                    insert pair (dist[v], v) into the pq;\n    output dist[t];\n```\n\nGamble1\n\n```cpp\nSets X = V;\nlabels vertex i in [0..V-1] with i;\nSets counter = 0; // will never get TLE\n```\nGamble2\n\n```cpp\nSets X = V;\nlabels vertex i in [0..V-1] with i;\nSets counter = 1000001; // force this to get TLE\n```\n\nRecursiveBacktracking\n\n```cpp\nThis algorithm tries X from 2 to V one by one and stops at the first valid X.  \nFor each X, the backtracking routine label vertex 0 with 0, then for each vertex u that has been assigned a label, the backtracking routine tries to assign \nthe smallest possible label up to label X-1 to its neighbor v, and backtracks if necessary.  \n// Please check RecursiveBacktracking.cpp/pas to see \n// the exact lines where the iteration counter is increased by 1\n```\n\n感谢zhouyonglong修改spj\n", "locale": "zh-CN"}}}
{"pid": "P3641", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2016", "APIO", "交互题", "Special Judge", "O2优化"], "title": "[APIO2016] 最大差分", "background": "## 评测方式\n以下是本题评测方式，与题面不符时以这里为准。\n\n你的代码中不应该包含 `gap.h` 库。\n\n你的代码中需如下进行 `findGap` 和 `MinMax` 函数的声明：\n```cpp\nextern \"C\" void MinMax(long long,long long,long long*,long long*);\nextern \"C\" long long findGap(int,int);\n```\n\n[spj 与交互库](https://www.luogu.com.cn/paste/c4olee2x)\n\n不保证没锅，要是有锅请私信供题人然后 D 死他。", "description": "有 $N$ 个严格递增的非负整数 $a_1, a_2, \\dots, a_N$（$0 \\leq a_1 < a_2 < \\cdots < a_N \\leq 10^{18}$）。你需要找出 $a_{i + 1} - a_i$（$1 \\leq i \\leq N - 1$）里的最大的值。\n\n你的程序不能直接读入这个整数序列，但是你可以通过给定的函数来查询该序列的信息。关于查询函数的细节，请根据你所使用的语言，参考下面的实现细节部分。\n\n你需要实现一个函数,该函数返回 $a_{i + 1} - a_i$（$1 \\leq i \\leq N - 1$）中的最大值。\n\n## 实现细节\n\n**本题只支持 C++（包括 cpp11，cpp14，cpp17）**。\n\n### C/C++\n你需要包含头文件 `gap.h`。\n\n你需要实现一个函数 `findGap(T, N)`，该函数接受下面的参数，并返回一个 `long long` 类型的整数：\n\n- $T$：子任务的编号（$1$ 或者 $2$）\n- $N$：序列的长度\n\n你的函数 `findGap` 可以调用系统提供的查询函数 `MinMax(s, t, &mn, &mx)`，该函数的前两个参数 $s$ 和 $t$ 是 `long long` 类型的整数，后两个参数 `&mn` 和 `&mx` 是 `long long` 类型的整数的指针（`mn` 和 `mx` 是 `long long` 类型的整数）。当 `MinMax(s, t, &mn, &mx)` 返回时，变量 `mn` 将会存储满足 $a_i \\in [s, t]$ 中 $a_i$ 的最小值，变量 `mx` 将会存储满足 $a_i \\in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 `mn` 和 `mx` 都将存储 $-1$。在查询时需要满足 $s \\leq t$，否则程序将会终止，该测试点计为 $0$ 分。\n\n### Pascal\n你需要使用单元 `graderhelperlib`。\n\n你需要实现一个函数 `findGap(T, N)`，该函数接受下面的参数，并返回一个 `Int64` 类型的整数：\n\n- $T$：子任务的编号（$1$ 或者 $2$）（`Integer` 类型）\n- $N$：序列的长度（`LongInt` 类型）\n\n你的函数 `findGap` 可以调用系统提供的查询函数 `MinMax(s, t, mn, mx)`，该函数的前两个参数 $s$ 和 $t$ 是 `Int64` 类型的整数，后两个参数 `mn` 和 `mx` 是传引用方式的 `Int64` 类型的整数（过程内部对这两个变量的修改会影响到外部的对应变量的值）。当 `MinMax(s, t, mn, mx)` 执行完毕时，变量 `mn` 将会存储满足 $a_i \\in [s, t]$ 中 $a_i$ 的最小值，变量 `mx` 将会存储满足 $a_i \\in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 `mn` 和 `mx` 都将存储 $-1$。在查询时需要满足 $s \\leq t$，否则程序将会终止，该测试点计为 $0$ 分。", "inputFormat": "## 样例一\n\n### C/C++\n\n考虑 $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$。\n\n则答案应该是 $3$，可以通过下面的几组对 `MinMax` 的询问获得：\n\n调用 `MinMax(1, 2, &mn, &mx)`，则 `mn` 和 `mx` 皆返回 $2$。\n\n调用 `MinMax(3, 7, &mn, &mx)`，则 `mn` 返回 $3$，`mx` 返回 $6$。\n\n调用 `MinMax(8, 9, &mn, &mx)`，则 `mn` 和 `mx` 皆返回 $8$。\n\n### Pascal\n考虑 $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$。\n\n则答案应该是 $3$，可以通过下面的几组对 `MinMax` 的询问获得：\n\n调用 `MinMax(1, 2, mn, mx)`，则 `mn` 和 `mx` 皆返回 $2$。\n\n调用 `MinMax(3, 7, mn, mx)`，则 `mn` 返回 $3$，`mx` 返回 $6$。\n\n调用 `MinMax(8, 9, mn, mx)`，则 `mn` 和 `mx` 皆返回 $8$。\n\n## 样例评测方式\n\n样例测评系统从标准输入中读入两行。第一行包含两个整数，子任务编号 $T$，和序列长度 $N$。第二行包含 $N$ 个严格递增的非负整数。然后该程序会向标准输出中写入两行，第一行为 `findGap` 的返回值，第二行为花费 $M$ 的值。\n\n下面的输入描述了上面的样例：\n\n```plane\n2 4\n2 3 6 8\n```\n注意实际使用的交互库和 spj 对数据进行了加密。", "outputFormat": "", "hint": "## 限制与约定\n\n对于所有的测试点，有 $2 \\leq N \\leq 100000$。\n\n每一个测试点开始测试之前，$M$ 都将被初始化为 $0$。\n\n子任务 1（$30$ 分）：每一次调用 `MinMax` 都将使 $M$ 加 $1$。为了获得所有分数，需要满足对于该子任务下的所有测试点，都有 $M \\leq \\frac{N + 1}{2}$。\n\n子任务 2（$70$ 分）：定义 $k$ 为调用 `MinMax` 时，区间 $[s, t]$ 中的序列中数的数量。每次调用 `MinMax`，将使 $M$ 加上 $k + 1$。对于每一个测试点，如果 $M \\leq 3N$，你将得到 70 分，否则将得到 $\\dfrac{60}{\\sqrt{\\frac MN + 1} - 1}$ 分。你的该子任务的得分是其下所有测试点中的最低分。\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2016] Maximum Gap", "background": "", "description": "There are $N$ strictly increasing nonnegative integers $a_1, a_2, \\dots, a_N$ with $0 \\leq a_1 < a_2 < \\cdots < a_N \\leq 10^{18}$. You need to find the maximum value among $a_{i + 1} - a_i$ for $1 \\leq i \\leq N - 1$.\n\nYour program cannot read this integer sequence directly, but you can query information about the sequence through the provided function. Please refer to the implementation details below for your language.\n\nYou must implement a function that returns the maximum value of $a_{i + 1} - a_i$ for $1 \\leq i \\leq N - 1$.\n\nJudging method\nThe following judging method applies. If this differs from the main statement, this section prevails.\n\n- Your code must not include the gap.h library.\n- You must declare the functions findGap and MinMax as follows:\n```cpp\nextern \"C\" void MinMax(long long,long long,long long*,long long*);\nextern \"C\" long long findGap(int,int);\n```\n- [spj and interaction library](https://www.luogu.com.cn/paste/c4olee2x)\n- If you encounter issues, please contact the problem provider.\n\nImplementation details\n\nThis problem only supports C++ (including cpp11, cpp14, cpp17).\n\nYou must implement a function findGap(T, N), which takes the following parameters and returns a value of type long long:\n\n- $T$: subtask ID ($1$ or $2$).\n- $N$: the length of the sequence.\n\nYour function findGap may call the system-provided query function MinMax(s, t, &mn, &mx). The first two parameters $s$ and $t$ are of type long long, and the last two parameters &mn and &mx are pointers to long long (mn and mx are long long variables). When MinMax(s, t, &mn, &mx) returns, mn will store the minimum $a_i$ such that $a_i \\in [s, t]$, and mx will store the maximum $a_i$ such that $a_i \\in [s, t]$. If there is no number from the sequence in the interval $[s, t]$, both mn and mx will be set to $-1$. You must ensure $s \\leq t$ when querying; otherwise, the program will terminate and the test will receive a score of $0$.\n\nSample 1\n\nC/C++\n\nConsider $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$.\n\nThe answer should be $3$, which can be obtained using the following queries to MinMax:\n\n- Call MinMax(1, 2, &mn, &mx), then both mn and mx return $2$.\n- Call MinMax(3, 7, &mn, &mx), then mn returns $3$, and mx returns $6$.\n- Call MinMax(8, 9, &mn, &mx), then both mn and mx return $8$.\n\nSample judging method\n\nThe sample judge reads two lines from standard input. The first line contains two integers, the subtask ID $T$ and the sequence length $N$. The second line contains $N$ strictly increasing nonnegative integers. Then the program writes two lines to standard output: the first line is the return value of findGap, and the second line is the value of the cost $M$.\n\nThe following input describes the sample above:\n```plane\n2 4\n2 3 6 8\n```\nNote that the actual interaction library and spj encrypt the testdata.\n\nConstraints and agreements\n\nFor all test cases, $2 \\leq N \\leq 100000$.\n\nBefore each test case starts, $M$ will be initialized to $0$.\n\nSubtask 1 (30 points): Each call to MinMax increases $M$ by $1$. To receive full points, you must ensure $M \\leq \\frac{N + 1}{2}$ for all test cases in this subtask.\n\nSubtask 2 (70 points): Let $k$ be the number of sequence elements within the interval $[s, t]$ for a MinMax call. Each call to MinMax increases $M$ by $k + 1$. For each test case, if $M \\leq 3N$, you will receive 70 points; otherwise, you will receive $\\dfrac{60}{\\sqrt{\\frac MN + 1} - 1}$ points. Your score for this subtask is the minimum over all its test cases.", "inputFormat": "", "outputFormat": "", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2016] 最大差分", "background": "## 评测方式\n以下是本题评测方式，与题面不符时以这里为准。\n\n你的代码中不应该包含 `gap.h` 库。\n\n你的代码中需如下进行 `findGap` 和 `MinMax` 函数的声明：\n```cpp\nextern \"C\" void MinMax(long long,long long,long long*,long long*);\nextern \"C\" long long findGap(int,int);\n```\n\n[spj 与交互库](https://www.luogu.com.cn/paste/c4olee2x)\n\n不保证没锅，要是有锅请私信供题人然后 D 死他。", "description": "有 $N$ 个严格递增的非负整数 $a_1, a_2, \\dots, a_N$（$0 \\leq a_1 < a_2 < \\cdots < a_N \\leq 10^{18}$）。你需要找出 $a_{i + 1} - a_i$（$1 \\leq i \\leq N - 1$）里的最大的值。\n\n你的程序不能直接读入这个整数序列，但是你可以通过给定的函数来查询该序列的信息。关于查询函数的细节，请根据你所使用的语言，参考下面的实现细节部分。\n\n你需要实现一个函数,该函数返回 $a_{i + 1} - a_i$（$1 \\leq i \\leq N - 1$）中的最大值。\n\n## 实现细节\n\n**本题只支持 C++（包括 cpp11，cpp14，cpp17）**。\n\n### C/C++\n你需要包含头文件 `gap.h`。\n\n你需要实现一个函数 `findGap(T, N)`，该函数接受下面的参数，并返回一个 `long long` 类型的整数：\n\n- $T$：子任务的编号（$1$ 或者 $2$）\n- $N$：序列的长度\n\n你的函数 `findGap` 可以调用系统提供的查询函数 `MinMax(s, t, &mn, &mx)`，该函数的前两个参数 $s$ 和 $t$ 是 `long long` 类型的整数，后两个参数 `&mn` 和 `&mx` 是 `long long` 类型的整数的指针（`mn` 和 `mx` 是 `long long` 类型的整数）。当 `MinMax(s, t, &mn, &mx)` 返回时，变量 `mn` 将会存储满足 $a_i \\in [s, t]$ 中 $a_i$ 的最小值，变量 `mx` 将会存储满足 $a_i \\in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 `mn` 和 `mx` 都将存储 $-1$。在查询时需要满足 $s \\leq t$，否则程序将会终止，该测试点计为 $0$ 分。\n\n### Pascal\n你需要使用单元 `graderhelperlib`。\n\n你需要实现一个函数 `findGap(T, N)`，该函数接受下面的参数，并返回一个 `Int64` 类型的整数：\n\n- $T$：子任务的编号（$1$ 或者 $2$）（`Integer` 类型）\n- $N$：序列的长度（`LongInt` 类型）\n\n你的函数 `findGap` 可以调用系统提供的查询函数 `MinMax(s, t, mn, mx)`，该函数的前两个参数 $s$ 和 $t$ 是 `Int64` 类型的整数，后两个参数 `mn` 和 `mx` 是传引用方式的 `Int64` 类型的整数（过程内部对这两个变量的修改会影响到外部的对应变量的值）。当 `MinMax(s, t, mn, mx)` 执行完毕时，变量 `mn` 将会存储满足 $a_i \\in [s, t]$ 中 $a_i$ 的最小值，变量 `mx` 将会存储满足 $a_i \\in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 `mn` 和 `mx` 都将存储 $-1$。在查询时需要满足 $s \\leq t$，否则程序将会终止，该测试点计为 $0$ 分。", "inputFormat": "## 样例一\n\n### C/C++\n\n考虑 $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$。\n\n则答案应该是 $3$，可以通过下面的几组对 `MinMax` 的询问获得：\n\n调用 `MinMax(1, 2, &mn, &mx)`，则 `mn` 和 `mx` 皆返回 $2$。\n\n调用 `MinMax(3, 7, &mn, &mx)`，则 `mn` 返回 $3$，`mx` 返回 $6$。\n\n调用 `MinMax(8, 9, &mn, &mx)`，则 `mn` 和 `mx` 皆返回 $8$。\n\n### Pascal\n考虑 $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$。\n\n则答案应该是 $3$，可以通过下面的几组对 `MinMax` 的询问获得：\n\n调用 `MinMax(1, 2, mn, mx)`，则 `mn` 和 `mx` 皆返回 $2$。\n\n调用 `MinMax(3, 7, mn, mx)`，则 `mn` 返回 $3$，`mx` 返回 $6$。\n\n调用 `MinMax(8, 9, mn, mx)`，则 `mn` 和 `mx` 皆返回 $8$。\n\n## 样例评测方式\n\n样例测评系统从标准输入中读入两行。第一行包含两个整数，子任务编号 $T$，和序列长度 $N$。第二行包含 $N$ 个严格递增的非负整数。然后该程序会向标准输出中写入两行，第一行为 `findGap` 的返回值，第二行为花费 $M$ 的值。\n\n下面的输入描述了上面的样例：\n\n```plane\n2 4\n2 3 6 8\n```\n注意实际使用的交互库和 spj 对数据进行了加密。", "outputFormat": "", "hint": "## 限制与约定\n\n对于所有的测试点，有 $2 \\leq N \\leq 100000$。\n\n每一个测试点开始测试之前，$M$ 都将被初始化为 $0$。\n\n子任务 1（$30$ 分）：每一次调用 `MinMax` 都将使 $M$ 加 $1$。为了获得所有分数，需要满足对于该子任务下的所有测试点，都有 $M \\leq \\frac{N + 1}{2}$。\n\n子任务 2（$70$ 分）：定义 $k$ 为调用 `MinMax` 时，区间 $[s, t]$ 中的序列中数的数量。每次调用 `MinMax`，将使 $M$ 加上 $k + 1$。对于每一个测试点，如果 $M \\leq 3N$，你将得到 70 分，否则将得到 $\\dfrac{60}{\\sqrt{\\frac MN + 1} - 1}$ 分。你的该子任务的得分是其下所有测试点中的最低分。\n", "locale": "zh-CN"}}}
{"pid": "P3642", "type": "P", "difficulty": 7, "samples": [["4 6\n1 5\n2 5\n2 8\n3 3\n3 2\n3 3\n2 9\n4 4\n4 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2016", "APIO", "可并堆", "斜率维护技巧 slope trick"], "title": "[APIO2016] 烟花表演", "background": "", "description": "烟花表演是最引人注目的节日活动之一。在表演中,所有的烟花必须同时爆炸。为了确保安全，烟花被安置在远离开关的位置上，通过一些导火索与开关相连。导火索的连接方式形成一棵树，烟花是树叶，如图所示。火花从开关出发，沿导火索移动。每当火花抵达一个分叉点时，它会扩散到与之相连的所有导火索，继续燃烧。导火索燃烧的速度是一个固定常数。图中展示了六枚烟花 $\\{E_1, E_2, \\dots, E_6\\}$ 的连线布局，以及每根导火索的长度。图中还标注了当在时刻 $0$ 从开关点燃火花时，每一发烟花的爆炸时间。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4429.png) \n\nHyunmin 为烟花表演设计了导火索的连线布局。不幸的是，在他设计的布局中，烟花不一定同时爆炸。我们希望修改一些导火索的长度，让所有烟花在同一时刻爆炸。例如，为了让图中的所有烟花在时刻 $13$ 爆炸，我们可以像下图中左边那样调整导火索长度。类似地，为了让图中的所有烟花在时刻 $14$ 爆炸，我们可以像下图中右边那样调整长度。\n\n ![](https://cdn.luogu.com.cn/upload/pic/4430.png) \n\n修改导火索长度的代价等于修改前后长度之差的绝对值。例如，将上面那副图中布局修改为下面那副图的左边布局的总代价为 $6$，而修改为右边布局的总代价为 $5$。\n\n导火索的长度可以被减为 $0$，同时保持连通性不变。\n\n给定一个导火索的连线布局，你需要编写一个程序，去调整导火索长度，让所有的烟花在同一时刻爆炸，并使得代价最小。\n", "inputFormat": "所有的输入均为正整数。令 $N$ 代表分叉点的数量，$M$ 代表烟花的数量。分叉点从 $1$ 到 $N$ 编号，编号为 $1$ 的分叉点是开关。烟花从 $N + 1$ 到 $N + M$ 编号。\n\n输入第一行为 $N, M$。后面 $N + M - 1$ 行，第 $i$ 行两个整数 $P_{i + 1}, C_{i + 1}$。其中 $P_i$ 满足 $1 \\leq P_i < i$，代表和分叉点或烟花 $i$ 相连的分叉点。$C_i$ 代表连接它们的导火索长度（$1 \\leq C_i \\leq 10^9$）除开关外，每个分叉点和多于 $1$ 条导火索相连，而每发烟花恰好与 $1$ 条导火索相连。\n", "outputFormat": "输出调整导火索长度，让所有烟花同时爆炸，所需要的最小代价。\n", "hint": "【数据规模】\n\n子任务 1（7 分）：$N = 1$，$1 \\leq M \\leq 100$。\n\n子任务 2（19 分）：$1 \\leq N+M \\leq 300$，且开关到任一烟花的距离不超过 $300$。\n\n子任务 3（29 分）：$1 \\leq N+M \\leq 5000$。\n\n子任务 4（45 分）：$1 \\leq N+M \\leq 300000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2016] Fireworks Show", "background": "", "description": "A fireworks show is one of the most eye-catching festival activities. In the show, all fireworks must explode at the same time. For safety, the fireworks are placed away from the switch and connected to the switch by fuses. The fuses form a tree, and the fireworks are the leaves, as shown in the figure. A spark starts at the switch and travels along the fuses. Whenever the spark reaches a junction, it splits and continues burning along all incident fuses. The burning speed of every fuse is a fixed constant. The figure shows the layout connecting six fireworks $\\{E_1, E_2, \\dots, E_6\\}$ and the length of each fuse. It also shows the explosion time of each firework when the spark is ignited at time $0$ at the switch.\n\n![](https://cdn.luogu.com.cn/upload/pic/4429.png)\n\nHyunmin designed the fuse layout for the fireworks show. Unfortunately, in his design, the fireworks do not necessarily explode simultaneously. We want to adjust some fuse lengths so that all fireworks explode at the same time. For example, to make all fireworks in the figure explode at time $13$, we can adjust the fuse lengths as shown on the left below. Similarly, to make all fireworks explode at time $14$, we can adjust the lengths as shown on the right.\n\n![](https://cdn.luogu.com.cn/upload/pic/4430.png)\n\nThe cost of modifying a fuse is the absolute difference between its new length and its original length. For example, changing the top layout to the layout on the left below has a total cost of $6$, while changing it to the layout on the right has a total cost of $5$.\n\nFuse lengths may be reduced to $0$ without changing the connectivity.\n\nGiven a fuse layout, write a program to adjust the fuse lengths so that all fireworks explode at the same time, while minimizing the total cost.", "inputFormat": "All input values are positive integers. Let $N$ be the number of junctions, and $M$ be the number of fireworks. Junctions are numbered from $1$ to $N$, where junction $1$ is the switch. Fireworks are numbered from $N + 1$ to $N + M$.\n\nThe first line contains $N, M$. Each of the next $N + M - 1$ lines describes one edge. For every node $v$ with $2 \\leq v \\leq N + M$, the line for $v$ gives two integers $P_v, C_v$, where $1 \\leq P_v < v$ specifies the junction to which node $v$ is connected, and $C_v$ is the length of the connecting fuse ($1 \\leq C_v \\leq 10^9$). Except for the switch, every junction is connected to more than $1$ fuse, and each firework is connected to exactly $1$ fuse.", "outputFormat": "Output the minimum total cost to adjust the fuse lengths so that all fireworks explode simultaneously.", "hint": "Constraints\n\n- Subtask 1 (7 points): $N = 1$, $1 \\leq M \\leq 100$.\n- Subtask 2 (19 points): $1 \\leq N + M \\leq 300$, and the distance from the switch to any firework is at most $300$.\n- Subtask 3 (29 points): $1 \\leq N + M \\leq 5000$.\n- Subtask 4 (45 points): $1 \\leq N + M \\leq 300000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2016] 烟花表演", "background": "", "description": "烟花表演是最引人注目的节日活动之一。在表演中,所有的烟花必须同时爆炸。为了确保安全，烟花被安置在远离开关的位置上，通过一些导火索与开关相连。导火索的连接方式形成一棵树，烟花是树叶，如图所示。火花从开关出发，沿导火索移动。每当火花抵达一个分叉点时，它会扩散到与之相连的所有导火索，继续燃烧。导火索燃烧的速度是一个固定常数。图中展示了六枚烟花 $\\{E_1, E_2, \\dots, E_6\\}$ 的连线布局，以及每根导火索的长度。图中还标注了当在时刻 $0$ 从开关点燃火花时，每一发烟花的爆炸时间。\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4429.png) \n\nHyunmin 为烟花表演设计了导火索的连线布局。不幸的是，在他设计的布局中，烟花不一定同时爆炸。我们希望修改一些导火索的长度，让所有烟花在同一时刻爆炸。例如，为了让图中的所有烟花在时刻 $13$ 爆炸，我们可以像下图中左边那样调整导火索长度。类似地，为了让图中的所有烟花在时刻 $14$ 爆炸，我们可以像下图中右边那样调整长度。\n\n ![](https://cdn.luogu.com.cn/upload/pic/4430.png) \n\n修改导火索长度的代价等于修改前后长度之差的绝对值。例如，将上面那副图中布局修改为下面那副图的左边布局的总代价为 $6$，而修改为右边布局的总代价为 $5$。\n\n导火索的长度可以被减为 $0$，同时保持连通性不变。\n\n给定一个导火索的连线布局，你需要编写一个程序，去调整导火索长度，让所有的烟花在同一时刻爆炸，并使得代价最小。\n", "inputFormat": "所有的输入均为正整数。令 $N$ 代表分叉点的数量，$M$ 代表烟花的数量。分叉点从 $1$ 到 $N$ 编号，编号为 $1$ 的分叉点是开关。烟花从 $N + 1$ 到 $N + M$ 编号。\n\n输入第一行为 $N, M$。后面 $N + M - 1$ 行，第 $i$ 行两个整数 $P_{i + 1}, C_{i + 1}$。其中 $P_i$ 满足 $1 \\leq P_i < i$，代表和分叉点或烟花 $i$ 相连的分叉点。$C_i$ 代表连接它们的导火索长度（$1 \\leq C_i \\leq 10^9$）除开关外，每个分叉点和多于 $1$ 条导火索相连，而每发烟花恰好与 $1$ 条导火索相连。\n", "outputFormat": "输出调整导火索长度，让所有烟花同时爆炸，所需要的最小代价。\n", "hint": "【数据规模】\n\n子任务 1（7 分）：$N = 1$，$1 \\leq M \\leq 100$。\n\n子任务 2（19 分）：$1 \\leq N+M \\leq 300$，且开关到任一烟花的距离不超过 $300$。\n\n子任务 3（29 分）：$1 \\leq N+M \\leq 5000$。\n\n子任务 4（45 分）：$1 \\leq N+M \\leq 300000$。\n", "locale": "zh-CN"}}}
{"pid": "P3643", "type": "P", "difficulty": 6, "samples": [["2\n1 2\n2 3", "7\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2016", "APIO", "动态规划优化", "排列组合", "前缀和"], "title": "[APIO2016] 划艇", "background": "", "description": "在首尔城中，汉江横贯东西。在汉江的北岸，从西向东星星点点地分布着 $N$ 个划艇学校，编号依次为 $1$ 到 $N$。每个学校都拥有若干艘划艇。同一所学校的所有划艇颜色相同，不同的学校的划艇颜色互不相同。颜色相同的划艇被认为是一样的。每个学校可以选择派出一些划艇参加节日的庆典，也可以选择不派出任何划艇参加。如果编号为 $i$ 的学校选择派出划艇参加庆典，那么，派出的划艇数量可以在 $a_i$ 至 $b_i$ 之间任意选择（$a_i \\leq b_i$）。\n\n值得注意的是，编号为 $i$ 的学校如果选择派出划艇参加庆典，那么它派出的划艇数量必须大于任意一所编号小于它的学校派出的划艇数量。\n\n输入所有学校的 $a_i,b_i$ 的值，求出参加庆典的划艇有多少种可能的情况，必须有至少一艘划艇参加庆典。两种情况不同当且仅当有参加庆典的某种颜色的划艇数量不同。\n", "inputFormat": "第一行包括一个整数 $N$，表示学校的数量。\n\n接下来 $N$ 行，每行包括两个正整数，用来描述一所学校。其中第 $i$ 行包括的两个正整数分别表示 $a_i,b_i$（$1 \\leq a_i \\leq b_i \\leq 10^9$）。\n", "outputFormat": "输出一行，一个整数，表示所有可能的派出划艇的方案数除以 $1,000,000,007$ 得到的余数。\n", "hint": "【样例解释】\n\n在只有一所学校派出划艇的情况下有 $4$ 种方案，两所学校都派出划艇的情况下有 $3$ 种方案，所以答案为 $7$。\n\n【数据范围】\n\n子任务 $1$（$9$ 分）：$1 \\leq N \\leq 500$ 且对于所有的 $1 \\leq i \\leq N$，保证 $a_i=b_i$。\n\n子任务 $2$（$22$ 分）：$1 \\leq N \\leq 500$ 且 $\\sum_{i=1}^N (b_i-a_i) \\leq 10^6$。\n\n子任务 $3$（$27$ 分）：$1 \\leq N \\leq 100$。\n\n子任务 $4$（$42$ 分）：$1 \\leq N \\leq 500$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2016] Boat", "background": "", "description": "In the city of Seoul, the Han River runs east to west. On its north bank, from west to east, there are $N$ rowing schools, numbered $1$ to $N$. Each school owns several boats. All boats from the same school share the same color, and different schools have different colors. Boats of the same color are considered identical. Each school may choose to send some boats to the festival, or choose not to send any. If school $i$ chooses to participate, it may send any number of boats between $a_i$ and $b_i$ inclusive ($a_i \\leq b_i$).\n\nImportantly, if school $i$ participates, the number of boats it sends must be greater than the number sent by any participating school with a smaller index.\n\nGiven all $a_i$ and $b_i$, determine how many possible participation configurations there are, with at least one boat participating. Two configurations are different if and only if there exists some color (i.e., some school) for which the number of participating boats differs.", "inputFormat": "The first line contains an integer $N$, the number of schools.\n\nThe next $N$ lines each describe one school. Line $i$ contains two positive integers $a_i$ and $b_i$ ($1 \\leq a_i \\leq b_i \\leq 10^9$).", "outputFormat": "Output a single line with one integer: the number of possible configurations modulo $1{,}000{,}000{,}007$.", "hint": "Sample explanation:\n\n- When only one school participates, there are $4$ configurations.\n- When both schools participate, there are $3$ configurations.\n- Therefore, the answer is $7$.\n\nConstraints:\n\n- Subtask $1$ (9 points): $1 \\leq N \\leq 500$ and $a_i = b_i$ for all $1 \\leq i \\leq N$.\n- Subtask $2$ (22 points): $1 \\leq N \\leq 500$ and $\\sum_{i=1}^N (b_i - a_i) \\leq 10^6$.\n- Subtask $3$ (27 points): $1 \\leq N \\leq 100$.\n- Subtask $4$ (42 points): $1 \\leq N \\leq 500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2016] 划艇", "background": "", "description": "在首尔城中，汉江横贯东西。在汉江的北岸，从西向东星星点点地分布着 $N$ 个划艇学校，编号依次为 $1$ 到 $N$。每个学校都拥有若干艘划艇。同一所学校的所有划艇颜色相同，不同的学校的划艇颜色互不相同。颜色相同的划艇被认为是一样的。每个学校可以选择派出一些划艇参加节日的庆典，也可以选择不派出任何划艇参加。如果编号为 $i$ 的学校选择派出划艇参加庆典，那么，派出的划艇数量可以在 $a_i$ 至 $b_i$ 之间任意选择（$a_i \\leq b_i$）。\n\n值得注意的是，编号为 $i$ 的学校如果选择派出划艇参加庆典，那么它派出的划艇数量必须大于任意一所编号小于它的学校派出的划艇数量。\n\n输入所有学校的 $a_i,b_i$ 的值，求出参加庆典的划艇有多少种可能的情况，必须有至少一艘划艇参加庆典。两种情况不同当且仅当有参加庆典的某种颜色的划艇数量不同。\n", "inputFormat": "第一行包括一个整数 $N$，表示学校的数量。\n\n接下来 $N$ 行，每行包括两个正整数，用来描述一所学校。其中第 $i$ 行包括的两个正整数分别表示 $a_i,b_i$（$1 \\leq a_i \\leq b_i \\leq 10^9$）。\n", "outputFormat": "输出一行，一个整数，表示所有可能的派出划艇的方案数除以 $1,000,000,007$ 得到的余数。\n", "hint": "【样例解释】\n\n在只有一所学校派出划艇的情况下有 $4$ 种方案，两所学校都派出划艇的情况下有 $3$ 种方案，所以答案为 $7$。\n\n【数据范围】\n\n子任务 $1$（$9$ 分）：$1 \\leq N \\leq 500$ 且对于所有的 $1 \\leq i \\leq N$，保证 $a_i=b_i$。\n\n子任务 $2$（$22$ 分）：$1 \\leq N \\leq 500$ 且 $\\sum_{i=1}^N (b_i-a_i) \\leq 10^6$。\n\n子任务 $3$（$27$ 分）：$1 \\leq N \\leq 100$。\n\n子任务 $4$（$42$ 分）：$1 \\leq N \\leq 500$。\n", "locale": "zh-CN"}}}
{"pid": "P3644", "type": "P", "difficulty": 6, "samples": [["1 5\nB 0 A 4\nB 1 B 3\nA 5 B 7\nB 2 A 6\nB 1 A 7", "24\n"], ["2 5\nB 0 A 4\nB 1 B 3\nA 5 B 7\nB 2 A 6\nB 1 A 7", "22"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "线段树", "堆", "APIO"], "title": "[APIO2015] 巴邻旁之桥", "background": "", "description": "一条东西走向的穆西河将巴邻旁市一分为二，分割成了区域 $A$ 和区域 $B$。\n\n每一块区域沿着河岸都建了恰好 $1000000001$ 栋的建筑，每条岸边的建筑都从 $0$ 编号到 $1000000000$。相邻的每对建筑相隔 $1$ 个单位距离，河的宽度也是 $1$ 个单位长度。区域 $A$ 中的 $i$ 号建筑物恰好与区域 $B$ 中的 $i$ 号建筑物隔河相对。\n\n城市中有 $N$ 个居民。第 $i$ 个居民的房子在区域 $P_i$ 的 $S_i$ 号建筑上，同时他的办公室坐落在 $Q_i$ 区域的 $T_i$ 号建筑上。一个居民的房子和办公室可能分布在河的两岸，这样他就必须要搭乘船只才能从家中去往办公室，这种情况让很多人都觉得不方便。为了使居民们可以开车去工作，政府决定建造不超过 $K$ 座横跨河流的大桥。\n\n由于技术上的原因，每一座桥必须刚好连接河的两岸，桥梁必须严格垂直于河流，并且桥与桥之间不能相交。\n\n当政府建造最多 $K$ 座桥之后，设 $D_i$ 表示第 $i$ 个居民此时开车从家里到办公室的最短距离。请帮助政府建造桥梁，使得 $D_1 + D_2 + \\cdots + D_N$ 最小。\n", "inputFormat": "输入的第一行包含两个正整数 $K$ 和 $N$，分别表示桥的上限数量和居民的数量。\n\n接下来 $N$ 行，每一行包含四个参数：$P_i, S_i, Q_i$ 和 $T_i$，表示第 $i$ 个居民的房子在区域 $P_i$ 的 $S_i$ 号建筑上，且他的办公室位于 $Q_i$ 区域的 $T_i$ 号建筑上。\n\n", "outputFormat": "输出仅为一行，包含一个整数，表示 $D_1 + D_2 + \\cdots + D_N$ 的最小值。\n", "hint": "【数据范围】\n\n所有数据都保证：$P_i$ 和 $Q_i$ 为字符 “A” 和 “B” 中的一个， $0 \\leq S_i, T_i \\leq 1000000000$，同一栋建筑内可能有超过 $1$ 间房子或办公室（或二者的组合，即房子或办公室的数量同时大于等于 $1$）。\n\n子任务 1 （8 分）$K = 1$\n\n$1 \\leq N \\leq 1000$\n\n\n子任务 2 （14 分）$K = 1$\n\n$1 \\leq N \\leq 100000$\n\n\n子任务 3 （9 分）$K = 2$\n\n$1 \\leq N \\leq 100$\n\n\n子任务 4 （32 分）$K = 2$\n\n$1 \\leq N \\leq 1000$\n\n\n子任务 5 （37 分）$K = 2$\n\n$1 \\leq N \\leq 100000$\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2015] Palembang Bridges", "background": "", "description": "An east–west Mu Xi River divides Palembang City into two parts, region $A$ and region $B$.\n\nExactly $1000000001$ buildings are built along each bank. Along each bank, buildings are numbered from $0$ to $1000000000$. Every pair of adjacent buildings is $1$ unit apart, and the river is $1$ unit wide. In region $A$, building $i$ is directly opposite building $i$ in region $B$.\n\nThere are $N$ residents in the city. The $i$-th resident’s home is at building $S_i$ in region $P_i$, and their office is at building $T_i$ in region $Q_i$. A resident’s home and office may lie on different banks of the river, in which case they must take a boat to commute, which many people find inconvenient. To allow residents to drive to work, the government decides to build at most $K$ bridges across the river.\n\nDue to technical reasons, each bridge must connect the two banks exactly, be strictly perpendicular to the river, and no two bridges may intersect.\n\nAfter the government builds at most $K$ bridges, let $D_i$ be the shortest driving distance from the $i$-th resident’s home to their office. Help the government build the bridges to minimize $D_1 + D_2 + \\cdots + D_N$.", "inputFormat": "The first line contains two positive integers $K$ and $N$, the maximum number of bridges and the number of residents.\n\nEach of the next $N$ lines contains four parameters: $P_i$, $S_i$, $Q_i$, and $T_i$, meaning that the $i$-th resident’s home is at building $S_i$ in region $P_i$, and their office is at building $T_i$ in region $Q_i$.", "outputFormat": "Output a single line containing one integer, the minimum value of $D_1 + D_2 + \\cdots + D_N$.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $P_i$ and $Q_i$ are one of the characters \"A\" and \"B\", $0 \\leq S_i, T_i \\leq 1000000000$, and there may be more than $1$ home or office (or both) in the same building.\n\nSubtask 1 (8 points) $K = 1$  \n$1 \\leq N \\leq 1000$.\n\nSubtask 2 (14 points) $K = 1$  \n$1 \\leq N \\leq 100000$.\n\nSubtask 3 (9 points) $K = 2$  \n$1 \\leq N \\leq 100$.\n\nSubtask 4 (32 points) $K = 2$  \n$1 \\leq N \\leq 1000$.\n\nSubtask 5 (37 points) $K = 2$  \n$1 \\leq N \\leq 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2015] 巴邻旁之桥", "background": "", "description": "一条东西走向的穆西河将巴邻旁市一分为二，分割成了区域 $A$ 和区域 $B$。\n\n每一块区域沿着河岸都建了恰好 $1000000001$ 栋的建筑，每条岸边的建筑都从 $0$ 编号到 $1000000000$。相邻的每对建筑相隔 $1$ 个单位距离，河的宽度也是 $1$ 个单位长度。区域 $A$ 中的 $i$ 号建筑物恰好与区域 $B$ 中的 $i$ 号建筑物隔河相对。\n\n城市中有 $N$ 个居民。第 $i$ 个居民的房子在区域 $P_i$ 的 $S_i$ 号建筑上，同时他的办公室坐落在 $Q_i$ 区域的 $T_i$ 号建筑上。一个居民的房子和办公室可能分布在河的两岸，这样他就必须要搭乘船只才能从家中去往办公室，这种情况让很多人都觉得不方便。为了使居民们可以开车去工作，政府决定建造不超过 $K$ 座横跨河流的大桥。\n\n由于技术上的原因，每一座桥必须刚好连接河的两岸，桥梁必须严格垂直于河流，并且桥与桥之间不能相交。\n\n当政府建造最多 $K$ 座桥之后，设 $D_i$ 表示第 $i$ 个居民此时开车从家里到办公室的最短距离。请帮助政府建造桥梁，使得 $D_1 + D_2 + \\cdots + D_N$ 最小。\n", "inputFormat": "输入的第一行包含两个正整数 $K$ 和 $N$，分别表示桥的上限数量和居民的数量。\n\n接下来 $N$ 行，每一行包含四个参数：$P_i, S_i, Q_i$ 和 $T_i$，表示第 $i$ 个居民的房子在区域 $P_i$ 的 $S_i$ 号建筑上，且他的办公室位于 $Q_i$ 区域的 $T_i$ 号建筑上。\n\n", "outputFormat": "输出仅为一行，包含一个整数，表示 $D_1 + D_2 + \\cdots + D_N$ 的最小值。\n", "hint": "【数据范围】\n\n所有数据都保证：$P_i$ 和 $Q_i$ 为字符 “A” 和 “B” 中的一个， $0 \\leq S_i, T_i \\leq 1000000000$，同一栋建筑内可能有超过 $1$ 间房子或办公室（或二者的组合，即房子或办公室的数量同时大于等于 $1$）。\n\n子任务 1 （8 分）$K = 1$\n\n$1 \\leq N \\leq 1000$\n\n\n子任务 2 （14 分）$K = 1$\n\n$1 \\leq N \\leq 100000$\n\n\n子任务 3 （9 分）$K = 2$\n\n$1 \\leq N \\leq 100$\n\n\n子任务 4 （32 分）$K = 2$\n\n$1 \\leq N \\leq 1000$\n\n\n子任务 5 （37 分）$K = 2$\n\n$1 \\leq N \\leq 100000$\n", "locale": "zh-CN"}}}
{"pid": "P3645", "type": "P", "difficulty": 4, "samples": [["5 3\n0 2\n1 1\n4 1", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2015", "APIO", "枚举", "最短路", "分块", "根号分治", "bitset"], "title": "[APIO2015] 雅加达的摩天楼", "background": "", "description": "印尼首都雅加达市有 $N$ 座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为 $0$ 到 $N − 1$。除了这 $N$ 座摩天楼外，雅加达市没有其他摩天楼。\n\n有 $M$ 只叫做 “doge” 的神秘生物在雅加达市居住，它们的编号依次是 $0$ 到 $M − 1$。编号为 $i$ 的 doge 最初居住于编号为 $B_i$ 的摩天楼。每只 doge 都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为 $i$ 的 doge 的跳跃能力为 $P_i$ （$P_i > 0$）。\n\n在一次跳跃中，位于摩天楼 $b$ 而跳跃能力为 $p$ 的 doge 可以跳跃到编号为 $b - p$ （如果 $0 \\leq b - p < N$）或 $b + p$ （如果 $0 \\leq b + p < N$）的摩天楼。\n\n编号为 $0$ 的 doge 是所有 doge 的首领，它有一条紧急的消息要尽快传送给编号为 $1$ 的 doge。任何一个收到消息的 doge 有以下两个选择:\n\n- 跳跃到其他摩天楼上；\n- 将消息传递给它当前所在的摩天楼上的其他 doge。\n\n请帮助 doge 们计算将消息从 $0$ 号 doge 传递到 $1$ 号 doge 所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到 $1$ 号 doge。\n", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$。\n\n接下来 $M$ 行，每行包含两个整数 $B_i$ 和 $P_i$。\n", "outputFormat": "输出一行，表示所需要的最少步数。如果消息永远无法传递到 $1$ 号 doge，输出 $−1$。\n", "hint": "【样例解释】\n\n下面是一种步数为 $5$ 的解决方案：\n\n$0$ 号 doge 跳跃到 $2$ 号摩天楼，再跳跃到 $4$ 号摩天楼（$2$ 步）。\n\n$0$ 号 doge 将消息传递给 $2$ 号 doge。\n\n$2$ 号 doge 跳跃到 $3$ 号摩天楼,接着跳跃到 $2$ 号摩天楼，再跳跃到 $1$ 号摩天楼（$3$ 步）。\n\n$2$ 号 doge 将消息传递给 $1$ 号 doge。\n\n【数据范围】\n\n所有数据都保证 $0 \\leq B_i < N$。\n\n子任务 1 （10 分）$1 \\leq N \\leq 10$\n\n$1 \\leq P_i \\leq 10$\n\n$2 \\leq M \\leq 3$\n\n\n子任务 2 （12 分）$1 \\leq N \\leq 100$\n\n$1 \\leq P_i \\leq 100$\n\n$2 \\leq M \\leq 2000$\n\n\n子任务 3 （14 分）$1 \\leq N \\leq 2000$\n\n$1 \\leq P i ≤ 2000$\n\n$2 \\leq M \\leq 2000$\n\n\n子任务 4 （21 分）$1 \\leq N \\leq 2000$\n\n$1 \\leq P_i \\leq 2000$\n\n$2 \\leq M \\leq 30000$\n\n\n子任务 5 （43 分）$1 \\leq N \\leq 30000$\n\n$1 \\leq P_i \\leq 30000$\n\n$2 \\leq M \\leq 30000$\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2015] Jakarta Skyscrapers", "background": "", "description": "There are $N$ skyscrapers in Jakarta, the capital of Indonesia, arranged in a straight line and numbered from $0$ to $N - 1$ from left to right. There are no other skyscrapers in Jakarta besides these $N$.\n\nThere are $M$ mysterious creatures called \"doge\" living in Jakarta, numbered from $0$ to $M - 1$. Doge $i$ initially lives at skyscraper $B_i$. Each doge has a mysterious power that allows it to jump between skyscrapers. The jumping ability of doge $i$ is $P_i$ ($P_i > 0$).\n\nIn one jump, a doge at skyscraper $b$ with jump ability $p$ can jump to skyscraper $b - p$ (if $0 \\leq b - p < N$) or to skyscraper $b + p$ (if $0 \\leq b + p < N$).\n\nDoge $0$ is the leader of all doges, and it needs to deliver an urgent message to doge $1$ as soon as possible. Any doge that has received the message has two options:\n- Jump to another skyscraper.\n- Pass the message to another doge currently on the same skyscraper.\n\nPlease help the doges compute the minimum total number of jumps required to deliver the message from doge $0$ to doge $1$, or determine that the message can never reach doge $1$.", "inputFormat": "The first line contains two integers $N$ and $M$.\n\nEach of the next $M$ lines contains two integers $B_i$ and $P_i$.", "outputFormat": "Output one line with the minimum number of steps required. If the message can never reach doge $1$, output $-1$.", "hint": "Sample explanation:\n\nBelow is a solution with a total of $5$ jumps:\n\n- Doge $0$ jumps to skyscraper $2$, then jumps to skyscraper $4$ ($2$ jumps).\n- Doge $0$ passes the message to doge $2$.\n- Doge $2$ jumps to skyscraper $3$, then jumps to skyscraper $2$, and then jumps to skyscraper $1$ ($3$ jumps).\n- Doge $2$ passes the message to doge $1$.\n\nConstraints:\n\nAll testdata guarantee $0 \\leq B_i < N$.\n\nSubtask 1 (10 points)\n- $1 \\leq N \\leq 10$\n- $1 \\leq P_i \\leq 10$\n- $2 \\leq M \\leq 3$\n\nSubtask 2 (12 points)\n- $1 \\leq N \\leq 100$\n- $1 \\leq P_i \\leq 100$\n- $2 \\leq M \\leq 2000$\n\nSubtask 3 (14 points)\n- $1 \\leq N \\leq 2000$\n- $1 \\leq P_i \\leq 2000$\n- $2 \\leq M \\leq 2000$\n\nSubtask 4 (21 points)\n- $1 \\leq N \\leq 2000$\n- $1 \\leq P_i \\leq 2000$\n- $2 \\leq M \\leq 30000$\n\nSubtask 5 (43 points)\n- $1 \\leq N \\leq 30000$\n- $1 \\leq P_i \\leq 30000$\n- $2 \\leq M \\leq 30000$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2015] 雅加达的摩天楼", "background": "", "description": "印尼首都雅加达市有 $N$ 座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为 $0$ 到 $N − 1$。除了这 $N$ 座摩天楼外，雅加达市没有其他摩天楼。\n\n有 $M$ 只叫做 “doge” 的神秘生物在雅加达市居住，它们的编号依次是 $0$ 到 $M − 1$。编号为 $i$ 的 doge 最初居住于编号为 $B_i$ 的摩天楼。每只 doge 都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为 $i$ 的 doge 的跳跃能力为 $P_i$ （$P_i > 0$）。\n\n在一次跳跃中，位于摩天楼 $b$ 而跳跃能力为 $p$ 的 doge 可以跳跃到编号为 $b - p$ （如果 $0 \\leq b - p < N$）或 $b + p$ （如果 $0 \\leq b + p < N$）的摩天楼。\n\n编号为 $0$ 的 doge 是所有 doge 的首领，它有一条紧急的消息要尽快传送给编号为 $1$ 的 doge。任何一个收到消息的 doge 有以下两个选择:\n\n- 跳跃到其他摩天楼上；\n- 将消息传递给它当前所在的摩天楼上的其他 doge。\n\n请帮助 doge 们计算将消息从 $0$ 号 doge 传递到 $1$ 号 doge 所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到 $1$ 号 doge。\n", "inputFormat": "输入的第一行包含两个整数 $N$ 和 $M$。\n\n接下来 $M$ 行，每行包含两个整数 $B_i$ 和 $P_i$。\n", "outputFormat": "输出一行，表示所需要的最少步数。如果消息永远无法传递到 $1$ 号 doge，输出 $−1$。\n", "hint": "【样例解释】\n\n下面是一种步数为 $5$ 的解决方案：\n\n$0$ 号 doge 跳跃到 $2$ 号摩天楼，再跳跃到 $4$ 号摩天楼（$2$ 步）。\n\n$0$ 号 doge 将消息传递给 $2$ 号 doge。\n\n$2$ 号 doge 跳跃到 $3$ 号摩天楼,接着跳跃到 $2$ 号摩天楼，再跳跃到 $1$ 号摩天楼（$3$ 步）。\n\n$2$ 号 doge 将消息传递给 $1$ 号 doge。\n\n【数据范围】\n\n所有数据都保证 $0 \\leq B_i < N$。\n\n子任务 1 （10 分）$1 \\leq N \\leq 10$\n\n$1 \\leq P_i \\leq 10$\n\n$2 \\leq M \\leq 3$\n\n\n子任务 2 （12 分）$1 \\leq N \\leq 100$\n\n$1 \\leq P_i \\leq 100$\n\n$2 \\leq M \\leq 2000$\n\n\n子任务 3 （14 分）$1 \\leq N \\leq 2000$\n\n$1 \\leq P i ≤ 2000$\n\n$2 \\leq M \\leq 2000$\n\n\n子任务 4 （21 分）$1 \\leq N \\leq 2000$\n\n$1 \\leq P_i \\leq 2000$\n\n$2 \\leq M \\leq 30000$\n\n\n子任务 5 （43 分）$1 \\leq N \\leq 30000$\n\n$1 \\leq P_i \\leq 30000$\n\n$2 \\leq M \\leq 30000$\n", "locale": "zh-CN"}}}
{"pid": "P3646", "type": "P", "difficulty": 5, "samples": [["6 1 3\n8 1 2 1 5 4", "11\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2015", "APIO", "枚举", "进制", "位运算"], "title": "[APIO2015] 巴厘岛的雕塑", "background": "", "description": "印尼巴厘岛的公路上有许多的雕塑,我们来关注它的一条主干道。\n\n在这条主干道上一共有 $N$ 座雕塑，为方便起见，我们把这些雕塑从 $1$ 到 $N$ 连续地进行标号，其中第 $i$ 座雕塑的年龄是 $Y_i$ 年。为了使这条路的环境更加优美，政府想把这些雕塑分成若干组，并通过在组与组之间种上一些树，来吸引更多的游客来巴厘岛。\n\n下面是将雕塑分组的规则：\n\n这些雕塑必须被分为恰好 $X$ 组，其中 $A \\leq X \\leq B$，每组必须含有至少一个雕塑，每个雕塑也必须属于且只属于一个组。同一组中的所有雕塑必须位于这条路的连续一段上。\n\n当雕塑被分好组后，对于每个组，我们首先计算出该组所有雕塑的年龄和。\n\n计算所有年龄和按位取或的结果。我们这个值把称为这一分组的最终优美度。\n\n请问政府能得到的最小的最终优美度是多少?\n\n备注：将两个非负数 $P$ 和 $Q$ 按位取或是这样进行计算的：\n\n首先把 $P$ 和 $Q$ 转换成二进制。\n\n设 $n_P$ 是 $P$ 的二进制位数，$n_Q$ 是 $Q$ 的二进制位数，$M$ 为 $n_P$ 和 $n_Q$ 中的最大值。$P$ 的二进制表示为 $p_{M-1}p_{M-2} \\dots p_1p_0$，$Q$ 的二进制表示为 $q_{M-1}q_{M-2} \\dots q_1 q_0$，其中 $p_i$ 和 $q_i$ 分别是 $P$ 和 $Q$ 二进制表示下的第 $i$ 位，第 $M -1$ 位是数的最高位，第 $0$ 位是数的最低位。\n\n$P$ 与 $Q$ 按位取或后的结果是： $(p_{M-1}\\mathbin{\\mathrm{OR}} q_{M-1})(p_{M-2}\\mathbin{\\mathrm{OR}}q_{M-2})\\dots (p_1\\mathbin{\\mathrm{OR}} q_1) (p_0\\mathbin{\\mathrm{OR}}q_0)$。其中：$0 \\mathbin{\\mathrm{OR}} 0 = 0$\n\n$0 \\mathbin{\\mathrm{OR}} 1 = 1$\n\n$1 \\mathbin{\\mathrm{OR}} 0 = 1$\n\n$1 \\mathbin{\\mathrm{OR}} 1 = 1$\n", "inputFormat": "输入的第一行包含三个用空格分开的整数 $N, A, B$。\n\n第二行包含 $N$ 个用空格分开的整数 $Y_1, Y_2, \\dots, Y_N$。\n", "outputFormat": "输出一行一个数，表示最小的最终优美度。\n", "hint": "【样例解释】\n\n将这些雕塑分为 $2$ 组，$(8, 1, 2)$ 和 $(1, 5, 4)$，它们的和是 $(11)$ 和 $(10)$，最终优美度是 $(11 \\mathbin{\\mathrm{OR}} 10) = 11$。（不难验证，这也是最终优美度的最小值。）\n\n【数据范围】\n\n子任务 1 （9 分）$1 \\leq N \\leq 20$\n\n$1 \\leq A \\leq B \\leq N$\n\n$0 \\leq Y_i \\leq 1000000000$\n\n\n子任务 2 （16 分）$1 \\leq N \\leq 50$\n\n$1 \\leq A \\leq B \\leq \\min\\{20, N\\}$\n\n$0 \\leq Y_i \\leq 10$\n\n\n子任务 3 （21 分）$1 ≤ N ≤ 100$\n\n$A = 1$\n\n$1 \\leq B \\leq N$\n\n$0 \\leq Y_i \\leq 20$\n\n\n子任务 4 （25 分）$1 \\leq N \\leq 100$\n\n$1 \\leq A \\leq B \\leq N$\n\n$0 \\leq Y_i \\leq 1000000000$\n\n\n子任务 5 （29 分）$1 \\leq N \\leq 2000$\n\n$A = 1$\n\n$1 \\leq B \\leq N$\n\n$0 \\leq Y_i \\leq 1000000000$\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2015] Sculptures in Bali", "background": "", "description": "There are many sculptures along the highways of Bali, Indonesia; we focus on one main road.\n\nThere are $N$ sculptures on this road. For convenience, we number them continuously from $1$ to $N$, and the age of the $i$-th sculpture is $Y_i$ years. To make the environment of this road more beautiful, the government wants to divide these sculptures into several groups and plant some trees between groups to attract more tourists to Bali.\n\nThe rules for grouping the sculptures are as follows:\n\nThe sculptures must be divided into exactly $X$ groups, where $A \\leq X \\leq B$. Each group must contain at least one sculpture, and each sculpture must belong to exactly one group. All sculptures within the same group must occupy a contiguous segment along the road.\n\nAfter the sculptures are grouped, for each group we first compute the sum of ages of all sculptures in that group.\n\nThen we compute the bitwise OR of all these sums. We call this value the final aesthetic value of the grouping.\n\nWhat is the minimum possible final aesthetic value the government can obtain?\n\nNote: The bitwise OR of two nonnegative numbers $P$ and $Q$ is computed as follows:\n\nFirst convert $P$ and $Q$ to binary.\n\nLet $n_P$ be the number of binary digits of $P$, $n_Q$ be that of $Q$, and $M$ be the maximum of $n_P$ and $n_Q$. The binary representation of $P$ is $p_{M-1}p_{M-2} \\dots p_1p_0$, and that of $Q$ is $q_{M-1}q_{M-2} \\dots q_1 q_0$, where $p_i$ and $q_i$ are the $i$-th bits in the binary representations of $P$ and $Q$, respectively. The $(M - 1)$-th bit is the most significant bit, and the $0$-th bit is the least significant bit.\n\nThe result of bitwise OR of $P$ and $Q$ is: $(p_{M-1}\\mathbin{\\mathrm{OR}} q_{M-1})(p_{M-2}\\mathbin{\\mathrm{OR}}q_{M-2})\\dots (p_1\\mathbin{\\mathrm{OR}} q_1) (p_0\\mathbin{\\mathrm{OR}}q_0)$. Where: $0 \\mathbin{\\mathrm{OR}} 0 = 0$\n\n$0 \\mathbin{\\mathrm{OR}} 1 = 1$\n\n$1 \\mathbin{\\mathrm{OR}} 0 = 1$\n\n$1 \\mathbin{\\mathrm{OR}} 1 = 1$.", "inputFormat": "The first line contains three integers $N, A, B$ separated by spaces.\n\nThe second line contains $N$ integers $Y_1, Y_2, \\dots, Y_N$ separated by spaces.", "outputFormat": "Output a single line with one number, the minimum possible final aesthetic value.", "hint": "Sample Explanation:\n\nDivide the sculptures into $2$ groups, $(8, 1, 2)$ and $(1, 5, 4)$. Their sums are $(11)$ and $(10)$, and the final aesthetic value is $(11 \\mathbin{\\mathrm{OR}} 10) = 11$. (It is not hard to verify that this is also the minimum final aesthetic value.)\n\nConstraints:\n\nSubtask 1 (9 points) $1 \\leq N \\leq 20$; $1 \\leq A \\leq B \\leq N$; $0 \\leq Y_i \\leq 1000000000$.\n\nSubtask 2 (16 points) $1 \\leq N \\leq 50$; $1 \\leq A \\leq B \\leq \\min\\{20, N\\}$; $0 \\leq Y_i \\leq 10$.\n\nSubtask 3 (21 points) $1 \\leq N \\leq 100$; $A = 1$; $1 \\leq B \\leq N$; $0 \\leq Y_i \\leq 20$.\n\nSubtask 4 (25 points) $1 \\leq N \\leq 100$; $1 \\leq A \\leq B \\leq N$; $0 \\leq Y_i \\leq 1000000000$.\n\nSubtask 5 (29 points) $1 \\leq N \\leq 2000$; $A = 1$; $1 \\leq B \\leq N$; $0 \\leq Y_i \\leq 1000000000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2015] 巴厘岛的雕塑", "background": "", "description": "印尼巴厘岛的公路上有许多的雕塑,我们来关注它的一条主干道。\n\n在这条主干道上一共有 $N$ 座雕塑，为方便起见，我们把这些雕塑从 $1$ 到 $N$ 连续地进行标号，其中第 $i$ 座雕塑的年龄是 $Y_i$ 年。为了使这条路的环境更加优美，政府想把这些雕塑分成若干组，并通过在组与组之间种上一些树，来吸引更多的游客来巴厘岛。\n\n下面是将雕塑分组的规则：\n\n这些雕塑必须被分为恰好 $X$ 组，其中 $A \\leq X \\leq B$，每组必须含有至少一个雕塑，每个雕塑也必须属于且只属于一个组。同一组中的所有雕塑必须位于这条路的连续一段上。\n\n当雕塑被分好组后，对于每个组，我们首先计算出该组所有雕塑的年龄和。\n\n计算所有年龄和按位取或的结果。我们这个值把称为这一分组的最终优美度。\n\n请问政府能得到的最小的最终优美度是多少?\n\n备注：将两个非负数 $P$ 和 $Q$ 按位取或是这样进行计算的：\n\n首先把 $P$ 和 $Q$ 转换成二进制。\n\n设 $n_P$ 是 $P$ 的二进制位数，$n_Q$ 是 $Q$ 的二进制位数，$M$ 为 $n_P$ 和 $n_Q$ 中的最大值。$P$ 的二进制表示为 $p_{M-1}p_{M-2} \\dots p_1p_0$，$Q$ 的二进制表示为 $q_{M-1}q_{M-2} \\dots q_1 q_0$，其中 $p_i$ 和 $q_i$ 分别是 $P$ 和 $Q$ 二进制表示下的第 $i$ 位，第 $M -1$ 位是数的最高位，第 $0$ 位是数的最低位。\n\n$P$ 与 $Q$ 按位取或后的结果是： $(p_{M-1}\\mathbin{\\mathrm{OR}} q_{M-1})(p_{M-2}\\mathbin{\\mathrm{OR}}q_{M-2})\\dots (p_1\\mathbin{\\mathrm{OR}} q_1) (p_0\\mathbin{\\mathrm{OR}}q_0)$。其中：$0 \\mathbin{\\mathrm{OR}} 0 = 0$\n\n$0 \\mathbin{\\mathrm{OR}} 1 = 1$\n\n$1 \\mathbin{\\mathrm{OR}} 0 = 1$\n\n$1 \\mathbin{\\mathrm{OR}} 1 = 1$\n", "inputFormat": "输入的第一行包含三个用空格分开的整数 $N, A, B$。\n\n第二行包含 $N$ 个用空格分开的整数 $Y_1, Y_2, \\dots, Y_N$。\n", "outputFormat": "输出一行一个数，表示最小的最终优美度。\n", "hint": "【样例解释】\n\n将这些雕塑分为 $2$ 组，$(8, 1, 2)$ 和 $(1, 5, 4)$，它们的和是 $(11)$ 和 $(10)$，最终优美度是 $(11 \\mathbin{\\mathrm{OR}} 10) = 11$。（不难验证，这也是最终优美度的最小值。）\n\n【数据范围】\n\n子任务 1 （9 分）$1 \\leq N \\leq 20$\n\n$1 \\leq A \\leq B \\leq N$\n\n$0 \\leq Y_i \\leq 1000000000$\n\n\n子任务 2 （16 分）$1 \\leq N \\leq 50$\n\n$1 \\leq A \\leq B \\leq \\min\\{20, N\\}$\n\n$0 \\leq Y_i \\leq 10$\n\n\n子任务 3 （21 分）$1 ≤ N ≤ 100$\n\n$A = 1$\n\n$1 \\leq B \\leq N$\n\n$0 \\leq Y_i \\leq 20$\n\n\n子任务 4 （25 分）$1 \\leq N \\leq 100$\n\n$1 \\leq A \\leq B \\leq N$\n\n$0 \\leq Y_i \\leq 1000000000$\n\n\n子任务 5 （29 分）$1 \\leq N \\leq 2000$\n\n$A = 1$\n\n$1 \\leq B \\leq N$\n\n$0 \\leq Y_i \\leq 1000000000$\n", "locale": "zh-CN"}}}
{"pid": "P3647", "type": "P", "difficulty": 6, "samples": [["5\n1 2 10\n1 3 40\n1 4 15\n1 5 20", "60"], ["10\n4 10 2\n1 2 21\n1 3 13\n6 7 1\n7 9 5\n2 4 3\n2 5 8\n1 6 55\n6 8 34", "140"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2014", "APIO", "枚举", "树形 DP"], "title": "[APIO2014] 连珠线", "background": "", "description": "在达芬奇时代，有一个流行的儿童游戏称为连珠线。当然，这个游戏是关于珠子和线的。线是红色或蓝色的，珠子被编号为 $1$ 到 $n$。这个游戏从一个珠子开始，每次会用如下方式添加一个新的珠子：\n\n`Append(w, v)`：一个新的珠子 $w$ 和一个已经添加的珠子 $v$ 用红线连接起来。\n\n`Insert(w, u, v)`：一个新的珠子 $w$ 插入到用红线连起来的两个珠子 $u, v$ 之间。具体过程是删去 $u, v$ 之间红线，分别用蓝线连接 $u, w$ 和 $w, v$。\n\n每条线都有一个长度。游戏结束后，你的最终得分为蓝线长度之和。\n\n给你连珠线游戏结束后的游戏局面，只告诉了你珠子和链的连接方式以及每条线的长度，没有告诉你每条线分别是什么颜色。\n\n你需要写一个程序来找出最大可能得分。即，在所有以给出的最终局面结束的连珠线游戏中找出那个得分最大的，然后输出最大可能得分。\n", "inputFormat": "第一行一个正整数 $n$，表示珠子的数量。珠子从 $1$ 到 $n$ 编号。\n\n接下来 $n - 1$ 行每行三个整数 $a_i, b_i, c_i$。保证 $1 \\leq a_i < b_i \\leq n$。$1 \\leq c_i \\leq 10000$。表示 $a_i$ 号珠子和 $b_i$ 号珠子间连了长度为 $c_i$ 的线。\n", "outputFormat": "输出一个整数，表示最大可能得分。\n", "hint": "【样例描述1】\n\n可以通过如下方式获得 $60$ 分：首先从 $3$ 号珠子开始。\n\n把 $5$ 和 $3$ 连起来。（线长度任意）\n\n在 $3$ 和 $5$ 之间插入 $1$。（线长分别为 $40$ 和 $20$）。\n\n把 $2$ 和 $1$ 用长度为 $10$ 的线连起来。\n\n把 $4$ 和 $1$ 用长度为 $15$ 的线连起来。\n\n\n【限制与约定】\n\n第一个子任务共 13 分，满足 $1 \\leq n \\leq 10$。\n\n第二个子任务共 15 分，满足 $1 \\leq n \\leq 200$。\n\n第三个子任务共 29 分，满足 $1 \\leq n \\leq 10000$。\n\n第四个子任务共 43 分，满足 $1 \\leq n \\leq 200000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2014] Beads and Wires", "background": "", "description": "In the era of Da Vinci, there was a popular children's game called Beads and Wires. As the name suggests, the game involves beads and wires. The wires are either red or blue, and the beads are numbered from $1$ to $n$. The game starts with a single bead, and each time a new bead is added using one of the following operations:\n\n`Append(w, v)`: Connect a new bead $w$ to an already added bead $v$ with a red wire.\n\n`Insert(w, u, v)`: Insert a new bead $w$ between two beads $u$ and $v$ that are connected by a red wire. Specifically, remove the red wire between $u$ and $v$, and connect $u$ to $w$ and $w$ to $v$ with blue wires.\n\nEach wire has a length. After the game ends, your final score is the sum of the lengths of all blue wires.\n\nYou are given the final configuration of the Beads and Wires game: which beads are connected and the length of each wire. However, you are not told the color of each wire.\n\nYour task is to write a program to find the maximum possible score. That is, among all games that could lead to the given final configuration, find the one with the highest score and output that maximum possible score.", "inputFormat": "The first line contains a positive integer $n$, the number of beads. The beads are numbered from $1$ to $n$.\n\nEach of the next $n - 1$ lines contains three integers $a_i, b_i, c_i$. It is guaranteed that $1 \\leq a_i < b_i \\leq n$ and $1 \\leq c_i \\leq 10000$. This means there is a wire of length $c_i$ between beads $a_i$ and $b_i$.", "outputFormat": "Output a single integer, the maximum possible score.", "hint": "[Sample Description 1]\n\nA score of $60$ can be achieved as follows: start from bead $3$.\n\n- Connect $5$ and $3$. (length arbitrary)\n- Insert $1$ between $3$ and $5$. (the lengths are $40$ and $20$ respectively)\n- Connect $2$ to $1$ with a wire of length $10$.\n- Connect $4$ to $1$ with a wire of length $15$.\n\n[Constraints]\n\n- Subtask 1 (13 points): $1 \\leq n \\leq 10$.\n- Subtask 2 (15 points): $1 \\leq n \\leq 200$.\n- Subtask 3 (29 points): $1 \\leq n \\leq 10000$.\n- Subtask 4 (43 points): $1 \\leq n \\leq 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2014] 连珠线", "background": "", "description": "在达芬奇时代，有一个流行的儿童游戏称为连珠线。当然，这个游戏是关于珠子和线的。线是红色或蓝色的，珠子被编号为 $1$ 到 $n$。这个游戏从一个珠子开始，每次会用如下方式添加一个新的珠子：\n\n`Append(w, v)`：一个新的珠子 $w$ 和一个已经添加的珠子 $v$ 用红线连接起来。\n\n`Insert(w, u, v)`：一个新的珠子 $w$ 插入到用红线连起来的两个珠子 $u, v$ 之间。具体过程是删去 $u, v$ 之间红线，分别用蓝线连接 $u, w$ 和 $w, v$。\n\n每条线都有一个长度。游戏结束后，你的最终得分为蓝线长度之和。\n\n给你连珠线游戏结束后的游戏局面，只告诉了你珠子和链的连接方式以及每条线的长度，没有告诉你每条线分别是什么颜色。\n\n你需要写一个程序来找出最大可能得分。即，在所有以给出的最终局面结束的连珠线游戏中找出那个得分最大的，然后输出最大可能得分。\n", "inputFormat": "第一行一个正整数 $n$，表示珠子的数量。珠子从 $1$ 到 $n$ 编号。\n\n接下来 $n - 1$ 行每行三个整数 $a_i, b_i, c_i$。保证 $1 \\leq a_i < b_i \\leq n$。$1 \\leq c_i \\leq 10000$。表示 $a_i$ 号珠子和 $b_i$ 号珠子间连了长度为 $c_i$ 的线。\n", "outputFormat": "输出一个整数，表示最大可能得分。\n", "hint": "【样例描述1】\n\n可以通过如下方式获得 $60$ 分：首先从 $3$ 号珠子开始。\n\n把 $5$ 和 $3$ 连起来。（线长度任意）\n\n在 $3$ 和 $5$ 之间插入 $1$。（线长分别为 $40$ 和 $20$）。\n\n把 $2$ 和 $1$ 用长度为 $10$ 的线连起来。\n\n把 $4$ 和 $1$ 用长度为 $15$ 的线连起来。\n\n\n【限制与约定】\n\n第一个子任务共 13 分，满足 $1 \\leq n \\leq 10$。\n\n第二个子任务共 15 分，满足 $1 \\leq n \\leq 200$。\n\n第三个子任务共 29 分，满足 $1 \\leq n \\leq 10000$。\n\n第四个子任务共 43 分，满足 $1 \\leq n \\leq 200000$。\n", "locale": "zh-CN"}}}
{"pid": "P3648", "type": "P", "difficulty": 6, "samples": [["7 3\n4 1 3 4 0 2 3", "108\n1 3 5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "APIO", "Special Judge", "枚举", "斜率优化", "前缀和"], "title": "[APIO2014] 序列分割", "background": "", "description": "你正在玩一个关于长度为 $n$ 的非负整数序列的游戏。这个游戏中你需要把序列分成 $k + 1$ 个非空的块。为了得到 $k + 1$ 块，你需要重复下面的操作 $k$ 次：\n\n选择一个有超过一个元素的块（初始时你只有一块，即整个序列）。\n\n选择两个相邻元素把这个块从中间分开，得到两个非空的块。\n\n每次操作后你将获得那两个新产生的块的元素和的乘积的分数。你想要最大化最后的总得分。", "inputFormat": "第一行包含两个整数 $n$ 和 $k$。保证 $k + 1 \\leq n$。\n\n第二行包含 $n$ 个非负整数 $a_1, a_2, \\cdots, a_n$ $(0 \\leq a_i \\leq 10^4)$，表示前文所述的序列。", "outputFormat": "第一行输出你能获得的最大总得分。\n\n第二行输出 $k$ 个介于 $1$ 到 $n - 1$ 之间的整数，表示为了使得总得分最大，你每次操作中分开两个块的位置。第 $i$ 个整数 $s_i$ 表示第 $i$ 次操作将在 $s_i$ 和 $s_{i} + 1$ 之间把块分开。\n\n如果有多种方案使得总得分最大，输出任意一种方案即可。", "hint": "你可以通过下面这些操作获得 $108$ 分：\n\n初始时你有一块 $(4, 1, 3, 4, 0, 2, 3)$。在第 $1$ 个元素后面分开，获得 $4 \\times (1 + 3 + 4 + 0 + 2 + 3) = 52$ 分。\n\n你现在有两块 $(4), (1, 3, 4, 0, 2, 3)$。在第 $3$ 个元素后面分开，获得 $(1 + 3) \\times (4 + 0 + 2 + 3) = 36$ 分。\n\n你现在有三块 $(4), (1, 3), (4, 0, 2, 3)$。在第 $5$ 个元素后面分开，获得 $(4 + 0) \\times (2 + 3) = 20$ 分。\n\n所以，经过这些操作后你可以获得四块 $(4), (1, 3), (4, 0), (2, 3)$ 并获得 $52 + 36 + 20 = 108$ 分。\n\n**【限制与约定】**\n\n第一个子任务共 11 分，满足 $1 \\leq k < n \\leq 10$。\n\n第二个子任务共 11 分，满足 $1 \\leq k < n \\leq 50$。\n\n第三个子任务共 11 分，满足 $1 \\leq k < n \\leq 200$。\n\n第四个子任务共 17 分，满足 $2 \\leq n \\leq 1000, 1 \\leq k \\leq \\min\\{n - 1, 200\\}$。\n\n第五个子任务共 21 分，满足 $2 \\leq n \\leq 10000, 1 \\leq k \\leq \\min\\{n - 1, 200\\}$。\n\n第六个子任务共 29 分，满足 $2 \\leq n \\leq 100000, 1 \\leq k \\leq \\min\\{n - 1, 200\\}$。\n\n感谢 @larryzhong  提供的加强数据。", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2014] Split the Sequence", "background": "", "description": "You are playing a game on a sequence of non-negative integers of length $n$. In this game, you need to split the sequence into $k + 1$ non-empty blocks. To obtain $k + 1$ blocks, repeat the following operation $k$ times:\n\n- Choose a block that has more than one element (initially, you have a single block, i.e., the entire sequence).\n- Choose two adjacent elements and split this block between them into two non-empty blocks.\n- After each operation, you gain a score equal to the product of the sums of elements in the two newly created blocks. You want to maximize the final total score.", "inputFormat": "The first line contains two integers $n$ and $k$. It is guaranteed that $k + 1 \\leq n$.\n\nThe second line contains $n$ non-negative integers $a_1, a_2, \\cdots, a_n$ ($0 \\leq a_i \\leq 10^4$), representing the sequence described above.", "outputFormat": "On the first line, output the maximum total score you can obtain.\n\nOn the second line, output $k$ integers between $1$ and $n - 1$, indicating the positions where you split between two elements in each operation to maximize the total score. The $i$-th integer $s_i$ means that at the $i$-th operation you split between positions $s_i$ and $s_i + 1$.\n\nIf there are multiple optimal solutions, output any of them.", "hint": "You can obtain a score of $108$ by the following operations:\n\nInitially, you have one block $(4, 1, 3, 4, 0, 2, 3)$. Split after the 1st element to gain $4 \\times (1 + 3 + 4 + 0 + 2 + 3) = 52$ points.\n\nYou now have two blocks $(4), (1, 3, 4, 0, 2, 3)$. Split after the 3rd element to gain $(1 + 3) \\times (4 + 0 + 2 + 3) = 36$ points.\n\nYou now have three blocks $(4), (1, 3), (4, 0, 2, 3)$. Split after the 5th element to gain $(4 + 0) \\times (2 + 3) = 20$ points.\n\nTherefore, after these operations you obtain four blocks $(4), (1, 3), (4, 0), (2, 3)$ and a total score of $52 + 36 + 20 = 108$.\n\nConstraints:\n- Subtask 1 (11 points): $1 \\leq k < n \\leq 10$.\n- Subtask 2 (11 points): $1 \\leq k < n \\leq 50$.\n- Subtask 3 (11 points): $1 \\leq k < n \\leq 200$.\n- Subtask 4 (17 points): $2 \\leq n \\leq 1000$, $1 \\leq k \\leq \\min\\{n - 1, 200\\}$.\n- Subtask 5 (21 points): $2 \\leq n \\leq 10000$, $1 \\leq k \\leq \\min\\{n - 1, 200\\}$.\n- Subtask 6 (29 points): $2 \\leq n \\leq 100000$, $1 \\leq k \\leq \\min\\{n - 1, 200\\}$.\n\nThanks to @larryzhong for providing strengthened testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2014] 序列分割", "background": "", "description": "你正在玩一个关于长度为 $n$ 的非负整数序列的游戏。这个游戏中你需要把序列分成 $k + 1$ 个非空的块。为了得到 $k + 1$ 块，你需要重复下面的操作 $k$ 次：\n\n选择一个有超过一个元素的块（初始时你只有一块，即整个序列）。\n\n选择两个相邻元素把这个块从中间分开，得到两个非空的块。\n\n每次操作后你将获得那两个新产生的块的元素和的乘积的分数。你想要最大化最后的总得分。", "inputFormat": "第一行包含两个整数 $n$ 和 $k$。保证 $k + 1 \\leq n$。\n\n第二行包含 $n$ 个非负整数 $a_1, a_2, \\cdots, a_n$ $(0 \\leq a_i \\leq 10^4)$，表示前文所述的序列。", "outputFormat": "第一行输出你能获得的最大总得分。\n\n第二行输出 $k$ 个介于 $1$ 到 $n - 1$ 之间的整数，表示为了使得总得分最大，你每次操作中分开两个块的位置。第 $i$ 个整数 $s_i$ 表示第 $i$ 次操作将在 $s_i$ 和 $s_{i} + 1$ 之间把块分开。\n\n如果有多种方案使得总得分最大，输出任意一种方案即可。", "hint": "你可以通过下面这些操作获得 $108$ 分：\n\n初始时你有一块 $(4, 1, 3, 4, 0, 2, 3)$。在第 $1$ 个元素后面分开，获得 $4 \\times (1 + 3 + 4 + 0 + 2 + 3) = 52$ 分。\n\n你现在有两块 $(4), (1, 3, 4, 0, 2, 3)$。在第 $3$ 个元素后面分开，获得 $(1 + 3) \\times (4 + 0 + 2 + 3) = 36$ 分。\n\n你现在有三块 $(4), (1, 3), (4, 0, 2, 3)$。在第 $5$ 个元素后面分开，获得 $(4 + 0) \\times (2 + 3) = 20$ 分。\n\n所以，经过这些操作后你可以获得四块 $(4), (1, 3), (4, 0), (2, 3)$ 并获得 $52 + 36 + 20 = 108$ 分。\n\n**【限制与约定】**\n\n第一个子任务共 11 分，满足 $1 \\leq k < n \\leq 10$。\n\n第二个子任务共 11 分，满足 $1 \\leq k < n \\leq 50$。\n\n第三个子任务共 11 分，满足 $1 \\leq k < n \\leq 200$。\n\n第四个子任务共 17 分，满足 $2 \\leq n \\leq 1000, 1 \\leq k \\leq \\min\\{n - 1, 200\\}$。\n\n第五个子任务共 21 分，满足 $2 \\leq n \\leq 10000, 1 \\leq k \\leq \\min\\{n - 1, 200\\}$。\n\n第六个子任务共 29 分，满足 $2 \\leq n \\leq 100000, 1 \\leq k \\leq \\min\\{n - 1, 200\\}$。\n\n感谢 @larryzhong  提供的加强数据。", "locale": "zh-CN"}}}
{"pid": "P3649", "type": "P", "difficulty": 6, "samples": [["abacaba\n", "7\n"], ["www", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "2014", "APIO", "后缀自动机 SAM", "后缀数组 SA", "回文自动机 PAM"], "title": "[APIO2014] 回文串", "background": "", "description": "给你一个由小写拉丁字母组成的字符串 $s$。我们定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度。\n\n对于给你的这个字符串 $s$，求所有回文子串中的最大存在值。\n", "inputFormat": "一行，一个由小写拉丁字母（a~z）组成的非空字符串 $s$。\n", "outputFormat": "输出一个整数，表示所有回文子串中的最大存在值。\n", "hint": "【样例解释1】\n\n用 $\\lvert s \\rvert$ 表示字符串 $s$ 的长度。\n\n一个字符串 $s_1 s_2 \\dots s_{\\lvert s \\rvert}$ 的子串是一个非空字符串 $s_i s_{i+1} \\dots s_j$，其中 $1 \\leq i \\leq j \\leq \\lvert s \\rvert$。每个字符串都是自己的子串。\n\n一个字符串被称作回文串当且仅当这个字符串从左往右读和从右往左读都是相同的。\n\n这个样例中，有 $7$ 个回文子串 a，b，c，aba，aca，bacab，abacaba。他们的存在值分别为 $4, 2, 1, 6, 3, 5, 7$。\n\n所以回文子串中最大的存在值为 $7$。\n\n\n\n第一个子任务共 8 分，满足 $1 \\leq \\lvert s \\rvert \\leq 100$。\n\n第二个子任务共 15 分，满足 $1 \\leq \\lvert s \\rvert \\leq 1000$。\n\n第三个子任务共 24 分，满足 $1 \\leq \\lvert s \\rvert \\leq 10000$。\n\n第四个子任务共 26 分，满足 $1 \\leq \\lvert s \\rvert \\leq 100000$。\n\n第五个子任务共 27 分，满足 $1 \\leq \\lvert s \\rvert \\leq 300000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[APIO2014] Palindrome", "background": "", "description": "You are given a string $s$ consisting of lowercase Latin letters. We define the existence value of a substring of $s$ as the number of occurrences of this substring in $s$ multiplied by its length.\n\nFor the given string $s$, find the maximum existence value among all palindromic substrings.", "inputFormat": "One line, a non-empty string $s$ consisting of lowercase Latin letters (a~z).", "outputFormat": "Output a single integer, the maximum existence value among all palindromic substrings.", "hint": "Sample Explanation 1\n\nUse $\\lvert s \\rvert$ to denote the length of string $s$.\n\nA substring of a string $s_1 s_2 \\dots s_{\\lvert s \\rvert}$ is a non-empty string $s_i s_{i+1} \\dots s_j$, where $1 \\leq i \\leq j \\leq \\lvert s \\rvert$. Every string is a substring of itself.\n\nA string is called a palindrome if and only if it reads the same from left to right and from right to left.\n\nIn this sample, there are $7$ palindromic substrings a, b, c, aba, aca, bacab, abacaba. Their existence values are $4, 2, 1, 6, 3, 5, 7$, respectively.\n\nTherefore, the maximum existence value among palindromic substrings is $7$.\n\nSubtasks\n\n- Subtask 1 (8 points): $1 \\leq \\lvert s \\rvert \\leq 100$.\n- Subtask 2 (15 points): $1 \\leq \\lvert s \\rvert \\leq 1000$.\n- Subtask 3 (24 points): $1 \\leq \\lvert s \\rvert \\leq 10000$.\n- Subtask 4 (26 points): $1 \\leq \\lvert s \\rvert \\leq 100000$.\n- Subtask 5 (27 points): $1 \\leq \\lvert s \\rvert \\leq 300000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[APIO2014] 回文串", "background": "", "description": "给你一个由小写拉丁字母组成的字符串 $s$。我们定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度。\n\n对于给你的这个字符串 $s$，求所有回文子串中的最大存在值。\n", "inputFormat": "一行，一个由小写拉丁字母（a~z）组成的非空字符串 $s$。\n", "outputFormat": "输出一个整数，表示所有回文子串中的最大存在值。\n", "hint": "【样例解释1】\n\n用 $\\lvert s \\rvert$ 表示字符串 $s$ 的长度。\n\n一个字符串 $s_1 s_2 \\dots s_{\\lvert s \\rvert}$ 的子串是一个非空字符串 $s_i s_{i+1} \\dots s_j$，其中 $1 \\leq i \\leq j \\leq \\lvert s \\rvert$。每个字符串都是自己的子串。\n\n一个字符串被称作回文串当且仅当这个字符串从左往右读和从右往左读都是相同的。\n\n这个样例中，有 $7$ 个回文子串 a，b，c，aba，aca，bacab，abacaba。他们的存在值分别为 $4, 2, 1, 6, 3, 5, 7$。\n\n所以回文子串中最大的存在值为 $7$。\n\n\n\n第一个子任务共 8 分，满足 $1 \\leq \\lvert s \\rvert \\leq 100$。\n\n第二个子任务共 15 分，满足 $1 \\leq \\lvert s \\rvert \\leq 1000$。\n\n第三个子任务共 24 分，满足 $1 \\leq \\lvert s \\rvert \\leq 10000$。\n\n第四个子任务共 26 分，满足 $1 \\leq \\lvert s \\rvert \\leq 100000$。\n\n第五个子任务共 27 分，满足 $1 \\leq \\lvert s \\rvert \\leq 300000$。\n", "locale": "zh-CN"}}}
{"pid": "P3650", "type": "P", "difficulty": 2, "samples": [["5\n20\n4\n1\n24\n21", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "贪心", "USACO", "三分", "枚举"], "title": "[USACO1.3] 滑雪课程设计Ski Course Design", "background": null, "description": "农民约翰的农场里有 $n$ 座山峰，每座山都有一个在 $0$ 到 $100$ 之间的整数的海拔高度。在冬天,因为山上有丰富的积雪，约翰经常开办滑雪训练营。\n\n不幸的是，约翰刚刚得知税法在滑雪训练营方面有新变化，明年开始实施。在仔细阅读法律后，他发现如果滑雪训练营的最高和最低的山峰海拔高度差大于 $17$ 就要收税。因此，如果他改变山峰的高度（使最高与最低的山峰海拔高度差不超过 $17$ ），约翰可以避免支付税收。\n\n如果改变一座山 $x$ 单位的高度成本是 $x^2$ 单位，约翰最少需要付多少钱才能使海拔最高的山峰与海拔最低的山峰的高度之差不超过 $17$。约翰只愿意改变整数单位的高度。", "inputFormat": "输入的第一行是一个整数，代表山峰的数量 $n$。\n\n第 $2$ 行到$(n + 1)$ 行，每行一个整数。第 $i$ 行的整数 $a_i$ 代表第 $i$ 座山的海拔高度。", "outputFormat": "输出一行一个整数，代表约翰需要支付修改山海拔高度的总金额。", "hint": "#### 样例输入输出 1 解释\n\n约翰保持高度为 $4$、$20$ 和 $21$ 的山的高度。他增高高度为 $1$ 的山，变成高度 $4$ ，花费 $3^2 = 9$。他降低了高度为 $24$ 的山变成高度 $21$，也花费 $3 ^ 2 = 9$。因此总共花费 $9 + 9 = 18$。\n\n---\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 1000$，$0 \\leq a_i \\leq 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.3] Ski Course Design", "background": "", "description": "Farmer John has $n$ hills on his farm, each with an integer elevation between $0$ and $100$. In winter, thanks to the abundant snow, he often runs ski training camps.\n\nUnfortunately, John has just learned of a new tax law related to ski training camps that will take effect next year. After carefully reading the law, he found that if the difference between the highest and lowest hill elevations in a camp exceeds $17$, he must pay tax. Therefore, if he adjusts the hill elevations so that the difference between the highest and lowest elevations does not exceed $17$, John can avoid paying the tax.\n\nIf changing a hill’s elevation by $x$ units costs $x^2$ units, what is the minimum total cost for John to ensure that the difference between the highest and lowest elevations does not exceed $17$? John only changes heights by integer amounts.", "inputFormat": "The first line contains an integer $n$, the number of hills.\n\nLines $2$ to $(n + 1)$ each contain one integer. The integer on the $i$-th line $a_i$ represents the elevation of the $i$-th hill.", "outputFormat": "Output a single integer, the total cost John must pay to adjust the hill elevations.", "hint": "Sample 1 explanation:\nJohn keeps the hills of elevations $4$, $20$, and $21$. He raises the hill of elevation $1$ to $4$, costing $3^2 = 9$. He lowers the hill of elevation $24$ to $21$, also costing $3^2 = 9$. Therefore, the total cost is $9 + 9 = 18$.\n\nConstraints:\nFor $100\\%$ of the testdata, $1 \\le n \\le 1000$, $0 \\le a_i \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.3] 滑雪课程设计Ski Course Design", "background": null, "description": "农民约翰的农场里有 $n$ 座山峰，每座山都有一个在 $0$ 到 $100$ 之间的整数的海拔高度。在冬天,因为山上有丰富的积雪，约翰经常开办滑雪训练营。\n\n不幸的是，约翰刚刚得知税法在滑雪训练营方面有新变化，明年开始实施。在仔细阅读法律后，他发现如果滑雪训练营的最高和最低的山峰海拔高度差大于 $17$ 就要收税。因此，如果他改变山峰的高度（使最高与最低的山峰海拔高度差不超过 $17$ ），约翰可以避免支付税收。\n\n如果改变一座山 $x$ 单位的高度成本是 $x^2$ 单位，约翰最少需要付多少钱才能使海拔最高的山峰与海拔最低的山峰的高度之差不超过 $17$。约翰只愿意改变整数单位的高度。", "inputFormat": "输入的第一行是一个整数，代表山峰的数量 $n$。\n\n第 $2$ 行到$(n + 1)$ 行，每行一个整数。第 $i$ 行的整数 $a_i$ 代表第 $i$ 座山的海拔高度。", "outputFormat": "输出一行一个整数，代表约翰需要支付修改山海拔高度的总金额。", "hint": "#### 样例输入输出 1 解释\n\n约翰保持高度为 $4$、$20$ 和 $21$ 的山的高度。他增高高度为 $1$ 的山，变成高度 $4$ ，花费 $3^2 = 9$。他降低了高度为 $24$ 的山变成高度 $21$，也花费 $3 ^ 2 = 9$。因此总共花费 $9 + 9 = 18$。\n\n---\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 1000$，$0 \\leq a_i \\leq 100$。", "locale": "zh-CN"}}}
{"pid": "P3651", "type": "P", "difficulty": 5, "samples": [["4\n2 2\n1 6\n1 3\n3 1", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "枚举", "基环树", "洛谷月赛"], "title": "展翅翱翔之时 (はばたきのとき)", "background": "**船が往くよミライへ旅立とう**\n\n**船只启航 朝未来展开旅途**\n\n**青い空笑ってる（なにがしたい?）**\n\n**湛蓝天空露出微笑（想做些什么?）**\n\n**ヒカリになろうミライを照らしたい**\n\n**化作光芒吧 想就此照亮未来**\n\n**輝きは心からあふれ出してもっと先の景色望むんだ**\n\n**光辉自内心满溢而出 愿能望见更加前方的景色**\n\n**Ah!やっと手にしたミライチケットかざして…！**\n\n**Ah!挥舞起终于得手的未来门票…！**\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4529.png) \n\n我们Aqours，终于闪闪发亮了！\n\n\n2月25和26日，将是我们登上横滨ARENA演唱的日子！\n\n\n而且，还要在全日本、甚至全世界的好多影院进行转播呢！\n\n\n转播好像还是通过中继卫星传输的呢！\n\n\n未来ずら！\n", "description": "不过，好像中继卫星上，出了一些问题呢……\n\n我们的中继卫星一共有 $N$ 颗，编号成 $1$ 到 $N$。不过，好像一个中继卫星可以且仅可以单向地从另一颗中继卫星那儿接收数据。\n\n第 $i$ 颗卫星现在已经被设定到了从第 $A_i$ 颗卫星（称为接收源）那儿接受数据。\n\n不过这些中继卫星的接收源是可以修改的，只不过每次修改要花一定的资金呢。\n\n听说要达成中继的话，这些卫星之间必须**两两之间能够互相（直接或间接）通信**才行啊。\n\n虽然鞠莉家里很有钱，可是这么大的花费，也得提前准备一下呢。\n\n所以，你能帮我们算算这样子一共最少要花多少钱吗？", "inputFormat": "第一行一个整数 $N$。\n\n接下来 $N$ 行，每行 $2$ 个整数 $A_i,C_i$，表示初始时，第 $i$ 个中继卫星从第 $A_i$ 颗卫星处接收数据，以及该卫星调整接收源的所需花费。", "outputFormat": "输出一个整数，表示鞠莉所需准备的最小的花费。\n", "hint": "### 数据范围及约定\n\n- 对于 $10\\%$ 的数据，满足 $N \\le 10$。\n- 对于 $40\\%$ 的数据，满足 $N \\le 15$。\n- 对于 $70\\%$ 的数据，满足 $N \\le 3000$。\n- 对于 $100\\%$ 的数据，满足 $2 \\le N \\le 100000,1 \\le C_i \\le 10^9$。\n\n### 以下是彩蛋\n\n事实上 LoveLive 的直播卫星中继只有一颗星，而且永远都是不加密的。\n\n导致只要有一个卫星锅就可以在家偷偷看直播，也就是传说中的卫星源。\n\nlin_toto：万代南梦宫都把浅水湾给买了，居然只有回放，只好跑到香港 the sky 去看 + 手动滑稽。\n\n至于为什么看转播，eplus 表示 LoveLive 系列演唱会的票大家尽管抽选尽管抢，买得到算我输。\n\n于是 lin_toto 在去年 μ's Final LoveLive 的时候拿肉鸡把 eplus 搞趴下了，然后就买到了。\n\n于是今年 eplus 连抢票都不让抢了，全抽选，抽得到算我输。\n\n然后 lin_toto 就去看转播了。\n", "locale": "zh-CN", "translations": {"en": {"title": "Time to Spread Wings (はばたきのとき)", "background": "**The ship sails on, let's set off toward the future.**\n\n**The ship sets sail, embarking on a journey toward the future.**\n\n**The blue sky is smiling (what do you want to do?).**\n\n**The azure sky is smiling (what do you want to do?).**\n\n**Let's become light; I want to illuminate the future.**\n\n**Become a ray of light; I want to shine on the future.**\n\n**Radiance overflows from the heart; I long to see the scenery even farther ahead.**\n\n**Brilliance wells up from the heart; I wish to behold the view farther ahead.**\n\n**Ah! Raise the future ticket we've finally gotten…!**\n\n**Ah! Wave the future ticket we've finally obtained…!**\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4529.png) \n\nWe, Aqours, have finally begun to shine!\n\nFebruary 25 and 26 will be the days we perform at Yokohama ARENA!\n\nAnd it will be broadcast in many theaters across all of Japan, and even around the world!\n\nIt seems the broadcast is relayed via satellites!\n\nMirai zura!", "description": "However, it seems there is some trouble with the relay satellites…\n\nWe have a total of $N$ relay satellites, numbered $1$ to $N$. Each relay satellite can and only can receive data unidirectionally from exactly one other relay satellite.\n\nThe $i$-th satellite is currently set to receive data from the $A_i$-th satellite (called the source).\n\nThe source of these relay satellites can be modified, but each modification costs some money.\n\nIt is said that to achieve relaying, these satellites must be able to communicate with each other pairwise (directly or indirectly).\n\nAlthough Mari is very rich, expenses this large still need to be planned in advance.\n\nSo, can you help us calculate the minimum total amount of money needed?", "inputFormat": "The first line contains an integer $N$.\n\nThen $N$ lines follow. Each line contains $2$ integers $A_i, C_i$, indicating that initially the $i$-th relay satellite receives data from the $A_i$-th satellite, and the cost required to adjust the source of this satellite.", "outputFormat": "Output a single integer, which is the minimum cost that Mari needs to prepare.", "hint": "### Constraints and Notes\n\n- For $10\\%$ of the testdata, $N \\le 10$.\n- For $40\\%$ of the testdata, $N \\le 15$.\n- For $70\\%$ of the testdata, $N \\le 3000$.\n- For $100\\%$ of the testdata, $2 \\le N \\le 100000$, $1 \\le C_i \\le 10^9$.\n\n### Easter egg\n\nIn fact, LoveLive’s live satellite relay uses only one satellite, and it is never encrypted.\n\nAs a result, as long as you have a satellite dish, you can secretly watch the live broadcast at home — the legendary satellite source.\n\nlin_toto: Bandai Namco even bought out Shallow Water Bay, yet there was only a replay, so I had to go to Hong Kong’s the sky to watch (wry smile).\n\nAs for why watch a relay screening, eplus says for LoveLive series concerts, everyone can enter lotteries and try to buy; if you manage to buy a ticket, I lose.\n\nSo last year during μ's Final LoveLive, lin_toto took down eplus with a botnet and then managed to buy tickets.\n\nThis year, eplus didn’t even allow rush purchases; it was all lotteries. If you get selected, I lose.\n\nSo lin_toto went to watch the relay screening.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "展翅翱翔之时 (はばたきのとき)", "background": "**船が往くよミライへ旅立とう**\n\n**船只启航 朝未来展开旅途**\n\n**青い空笑ってる（なにがしたい?）**\n\n**湛蓝天空露出微笑（想做些什么?）**\n\n**ヒカリになろうミライを照らしたい**\n\n**化作光芒吧 想就此照亮未来**\n\n**輝きは心からあふれ出してもっと先の景色望むんだ**\n\n**光辉自内心满溢而出 愿能望见更加前方的景色**\n\n**Ah!やっと手にしたミライチケットかざして…！**\n\n**Ah!挥舞起终于得手的未来门票…！**\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/4529.png) \n\n我们Aqours，终于闪闪发亮了！\n\n\n2月25和26日，将是我们登上横滨ARENA演唱的日子！\n\n\n而且，还要在全日本、甚至全世界的好多影院进行转播呢！\n\n\n转播好像还是通过中继卫星传输的呢！\n\n\n未来ずら！\n", "description": "不过，好像中继卫星上，出了一些问题呢……\n\n我们的中继卫星一共有 $N$ 颗，编号成 $1$ 到 $N$。不过，好像一个中继卫星可以且仅可以单向地从另一颗中继卫星那儿接收数据。\n\n第 $i$ 颗卫星现在已经被设定到了从第 $A_i$ 颗卫星（称为接收源）那儿接受数据。\n\n不过这些中继卫星的接收源是可以修改的，只不过每次修改要花一定的资金呢。\n\n听说要达成中继的话，这些卫星之间必须**两两之间能够互相（直接或间接）通信**才行啊。\n\n虽然鞠莉家里很有钱，可是这么大的花费，也得提前准备一下呢。\n\n所以，你能帮我们算算这样子一共最少要花多少钱吗？", "inputFormat": "第一行一个整数 $N$。\n\n接下来 $N$ 行，每行 $2$ 个整数 $A_i,C_i$，表示初始时，第 $i$ 个中继卫星从第 $A_i$ 颗卫星处接收数据，以及该卫星调整接收源的所需花费。", "outputFormat": "输出一个整数，表示鞠莉所需准备的最小的花费。\n", "hint": "### 数据范围及约定\n\n- 对于 $10\\%$ 的数据，满足 $N \\le 10$。\n- 对于 $40\\%$ 的数据，满足 $N \\le 15$。\n- 对于 $70\\%$ 的数据，满足 $N \\le 3000$。\n- 对于 $100\\%$ 的数据，满足 $2 \\le N \\le 100000,1 \\le C_i \\le 10^9$。\n\n### 以下是彩蛋\n\n事实上 LoveLive 的直播卫星中继只有一颗星，而且永远都是不加密的。\n\n导致只要有一个卫星锅就可以在家偷偷看直播，也就是传说中的卫星源。\n\nlin_toto：万代南梦宫都把浅水湾给买了，居然只有回放，只好跑到香港 the sky 去看 + 手动滑稽。\n\n至于为什么看转播，eplus 表示 LoveLive 系列演唱会的票大家尽管抽选尽管抢，买得到算我输。\n\n于是 lin_toto 在去年 μ's Final LoveLive 的时候拿肉鸡把 eplus 搞趴下了，然后就买到了。\n\n于是今年 eplus 连抢票都不让抢了，全抽选，抽得到算我输。\n\n然后 lin_toto 就去看转播了。\n", "locale": "zh-CN"}}}
{"pid": "P3652", "type": "P", "difficulty": 6, "samples": [["2 3 1 1\n2 2 2\n4 4 4\n2 1 1\n1 1 1\n1 2 1\n1 3 1\n2 3 4", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流", "洛谷原创"], "title": "csh和zzy的战争", "background": "（背景~~有点~~长，你可以选择读完，也可以选择跳过。）\n\n公元 2040 年，csh 和 zzy 在丑国蛙谷展开了关于非线性配微分方程的正确性与否的相关辩论，史称第四次数学危机。两个人近千页的非人类学术性论文，使整个世界没有其他人听得懂他们在说什么，于是，以 csh 为首的 A 派科学家和以 zzy 为首的 B 派科学家展开了在多次对抗无果之后开始使用武装革命解决，进而引发了全球性的第三次世界大战。作为战争中立派的居润国不想卷入任何一方的斗争，只想喝完手中的咖啡，然而两方元首在多次对抛出橄榄枝无果之后，对居润国提出了一个要求：解决他们在战争中的运送物资问题，当然这个问题早就在 $10^0$ s 内被他们解决，但是居润国却不知道怎么办，而且也不能报上错误的答案，于是就求助了聪明的你们。", "description": "现在有 $n$ 个货物发源地，里面是一些待运送的货物。前方有 $m$ 个中转小岛，而你的目的是将所有货物运到战争前沿的军事基地，其运送规则如下：\n\n1. 小岛只能由特定的货物发源地发货，其中只有几个指定的小岛可以向军事基地发货。\n2. 小岛与小岛之间有 $e$ 条航道，每条航道上有一个权值 $v$ 代表这条道路开通的代价，而两个小岛之间开通货运的代价 $K$ 是两个小岛之间的最短路径长度。\n3. 每个小岛上同时最多不能超过 $w$ 个货物。\n4. 每个小岛一次性至多对外运输 $d$ 个货物，小岛对每个目的地至多送货一次。\n5. 有 $x$ 个特殊货物发源地（不包含在 $n$ 内）会运送 csh 和 zzy 两个人的一些私人的货物，这些货物会被任何一个小岛无条件接受和送出，即不受 3，4 法则的影响。\n6. 整条航路的开发费用为每对小岛开通费用 $K$ 中的最大值 $V$。\n\n请你寻找一个最小的 $V$ 使得所有货物都能按照要求运送到军事基地。", "inputFormat": "第一行 $n$，$m$，$x$，$e$，分别表示货物发源地数目，小岛中转站数目，特殊货物发源地数目和航道数目，货物发源地和特殊货物发源地依次标号为 $1$，$2$，$ \\dots $，$n+x$。\n\n第二行是 $n+x$ 个数 $a_i$，分别每个货物发源地待发送的货物数量。\n\n第三行是 $m$ 个数，分别表示小岛的限制存货量 $w$。\n\n第四行也是 $m$ 个数，分别表示小岛的限制出货量 $d$。\n\n接下来 $m$ 行，每行开头是一个数 $k$ ，表示有 $k$ 个货物发源地（包括特殊货物发源地）与小岛相连，然后是 $k$ 个数，分别表示货物发源地的编号，最后一个数表示小岛是否与军事基地相连，是则为$1$，否则为$0$。\n\n接下来 $e$ 行，每行是三个数 $u$，$v$，$p$ 表示小岛 $u$，$v$ 之间航道的权值为 $p$。", "outputFormat": "一个整数 $V$ ，表示使得所有货物都能按照要求运送到军事基地最小开通费用。", "hint": "对于 $100\\%$ 的数据， $n \\le 3 \\times 10^2$，$e \\le 10^3$。\n\n几个提示：[https://www.luogu.com.cn/discuss/47710](https://www.luogu.com.cn/discuss/47710)。", "locale": "zh-CN", "translations": {"en": {"title": "The War of csh and zzy", "background": "(The background is a bit long. You may read it through or skip it.)\n\nIn A.D. 2040, csh and zzy held a debate in the Frog Valley of the Ugly Country about the correctness of nonlinear partial differential equations, later known as the Fourth Crisis in Mathematics. Their nearly thousand-page, inhumanly academic papers left everyone else unable to understand what they were saying. Consequently, scientists of faction A led by csh and faction B led by zzy, after many fruitless confrontations, turned to armed revolution, triggering the global Third World War. The neutral country Jurun, not wishing to be dragged into the struggle, only wanted to finish its coffee. However, after repeatedly extending an olive branch in vain, the two leaders提出了一个要求: to resolve their logistics problem during the war. Of course, they solved this problem within $10^0$ s, but Jurun did not know what to do and could not submit a wrong answer, so they turned to you smart people for help.", "description": "There are $n$ cargo origins, each with some goods to be shipped. Ahead are $m$ transfer islands, and your goal is to deliver all goods to the front-line military base. The shipping rules are as follows:\n\n1. Each island can accept goods only from specific cargo origins, and only certain designated islands can ship to the military base.\n2. There are $e$ sea lanes between islands. Each sea lane has a weight $p$ representing the cost to open that lane. For any two islands, the cost $K$ to enable cargo shipping between them equals the length of the shortest path between them (sum of edge weights).\n3. At any time, the number of goods simultaneously stored on an island must not exceed its storage limit $w_i$.\n4. Each island can ship out at most $d_i$ goods in total, and to each destination it can deliver at most once.\n5. There are $x$ special cargo origins (not included in $n$) that carry some private goods of csh and zzy. These goods will be unconditionally accepted and forwarded by any island, i.e., they are not subject to rules 3 and 4.\n6. The development cost of the entire route equals $V$, the maximum $K$ among all pairs of islands for which shipping is enabled.\n\nFind the minimal $V$ such that all goods can be delivered to the military base in accordance with the above rules.", "inputFormat": "- The first line contains $n$, $m$, $x$, $e$, denoting the number of cargo origins, the number of transfer islands, the number of special cargo origins, and the number of sea lanes, respectively. The cargo origins and special cargo origins are indexed $1, 2, \\dots, n + x$ in order.\n- The second line contains $n + x$ integers $a_i$, the amount of goods pending shipment at each cargo origin.\n- The third line contains $m$ integers, the storage limits $w_i$ of the islands.\n- The fourth line contains $m$ integers, the outbound shipping limits $d_i$ of the islands.\n- The next $m$ lines describe the connections from origins to islands. Each line starts with an integer $k$, the number of cargo origins (including special ones) connected to this island, followed by $k$ integers listing the indices of those origins, and finally one integer indicating whether this island is connected to the military base (1 for yes, 0 for no).\n- The next $e$ lines each contain three integers $u$, $v$, $p$, indicating there is a sea lane between islands $u$ and $v$ with weight $p$.", "outputFormat": "Output a single integer $V$, the minimal development cost that allows all goods to be delivered to the military base while satisfying the rules.", "hint": "Constraints: For $100\\%$ of the testdata, $n \\le 3 \\times 10^2$, $e \\le 10^3$.\n\nSeveral tips: https://www.luogu.com.cn/discuss/47710.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "csh和zzy的战争", "background": "（背景~~有点~~长，你可以选择读完，也可以选择跳过。）\n\n公元 2040 年，csh 和 zzy 在丑国蛙谷展开了关于非线性配微分方程的正确性与否的相关辩论，史称第四次数学危机。两个人近千页的非人类学术性论文，使整个世界没有其他人听得懂他们在说什么，于是，以 csh 为首的 A 派科学家和以 zzy 为首的 B 派科学家展开了在多次对抗无果之后开始使用武装革命解决，进而引发了全球性的第三次世界大战。作为战争中立派的居润国不想卷入任何一方的斗争，只想喝完手中的咖啡，然而两方元首在多次对抛出橄榄枝无果之后，对居润国提出了一个要求：解决他们在战争中的运送物资问题，当然这个问题早就在 $10^0$ s 内被他们解决，但是居润国却不知道怎么办，而且也不能报上错误的答案，于是就求助了聪明的你们。", "description": "现在有 $n$ 个货物发源地，里面是一些待运送的货物。前方有 $m$ 个中转小岛，而你的目的是将所有货物运到战争前沿的军事基地，其运送规则如下：\n\n1. 小岛只能由特定的货物发源地发货，其中只有几个指定的小岛可以向军事基地发货。\n2. 小岛与小岛之间有 $e$ 条航道，每条航道上有一个权值 $v$ 代表这条道路开通的代价，而两个小岛之间开通货运的代价 $K$ 是两个小岛之间的最短路径长度。\n3. 每个小岛上同时最多不能超过 $w$ 个货物。\n4. 每个小岛一次性至多对外运输 $d$ 个货物，小岛对每个目的地至多送货一次。\n5. 有 $x$ 个特殊货物发源地（不包含在 $n$ 内）会运送 csh 和 zzy 两个人的一些私人的货物，这些货物会被任何一个小岛无条件接受和送出，即不受 3，4 法则的影响。\n6. 整条航路的开发费用为每对小岛开通费用 $K$ 中的最大值 $V$。\n\n请你寻找一个最小的 $V$ 使得所有货物都能按照要求运送到军事基地。", "inputFormat": "第一行 $n$，$m$，$x$，$e$，分别表示货物发源地数目，小岛中转站数目，特殊货物发源地数目和航道数目，货物发源地和特殊货物发源地依次标号为 $1$，$2$，$ \\dots $，$n+x$。\n\n第二行是 $n+x$ 个数 $a_i$，分别每个货物发源地待发送的货物数量。\n\n第三行是 $m$ 个数，分别表示小岛的限制存货量 $w$。\n\n第四行也是 $m$ 个数，分别表示小岛的限制出货量 $d$。\n\n接下来 $m$ 行，每行开头是一个数 $k$ ，表示有 $k$ 个货物发源地（包括特殊货物发源地）与小岛相连，然后是 $k$ 个数，分别表示货物发源地的编号，最后一个数表示小岛是否与军事基地相连，是则为$1$，否则为$0$。\n\n接下来 $e$ 行，每行是三个数 $u$，$v$，$p$ 表示小岛 $u$，$v$ 之间航道的权值为 $p$。", "outputFormat": "一个整数 $V$ ，表示使得所有货物都能按照要求运送到军事基地最小开通费用。", "hint": "对于 $100\\%$ 的数据， $n \\le 3 \\times 10^2$，$e \\le 10^3$。\n\n几个提示：[https://www.luogu.com.cn/discuss/47710](https://www.luogu.com.cn/discuss/47710)。", "locale": "zh-CN"}}}
{"pid": "P3653", "type": "P", "difficulty": 6, "samples": [["1 233", "-1"], ["99999999999899999 99999999999999999", "421"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["O2优化", "枚举", "素数判断,质数,筛法", "前缀和"], "title": "小清新数学题", "background": "**本题时限 3s**\n\n友情提示：https://www.luogu.com.cn/problem/P3601\n", "description": "题目还是简单一点好。\n\n\n我们定义莫比乌斯函数 $\\mu(x)$，如果 $x$ 的每个素因子只出现一次，有 $p$ 个素因子，那么 $\\mu(x)=(-1)^p$，否则 $\\mu(x)=0$。\n\n\n这题要求你求出 $\\sum_{i=l}^r \\mu(i)$。\n", "inputFormat": "一行两个整数 $l,r$。\n", "outputFormat": "一行一个整数表示答案。\n", "hint": "对于 $10\\%$ 的数据，$l,r \\leq 10^6$。\n\n对于 $30\\%$ 的数据，$l,r \\leq 10^{12}$。\n\n对于 $100\\%$ 的数据，$1 \\leq l \\leq r \\leq 10^{18}$，$r-l \\leq 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "A Fresh Math Problem", "background": "Time limit: 3 s.\n\nFriendly reminder: https://www.luogu.com.cn/problem/P3601.", "description": "Let's keep the problem simple.\n\nWe define the Möbius function $\\mu(x)$. If each prime factor of $x$ appears only once and there are $p$ prime factors, then $\\mu(x)=(-1)^p$; otherwise, $\\mu(x)=0$.\n\nYou are asked to compute $\\sum_{i=l}^r \\mu(i)$.", "inputFormat": "One line contains two integers $l,r$.", "outputFormat": "One line contains one integer representing the answer.", "hint": "For $10\\%$ of the testdata, $l,r \\leq 10^6$.\n\nFor $30\\%$ of the testdata, $l,r \\leq 10^{12}$.\n\nFor $100\\%$ of the testdata, $1 \\leq l \\leq r \\leq 10^{18}$, $r-l \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小清新数学题", "background": "**本题时限 3s**\n\n友情提示：https://www.luogu.com.cn/problem/P3601\n", "description": "题目还是简单一点好。\n\n\n我们定义莫比乌斯函数 $\\mu(x)$，如果 $x$ 的每个素因子只出现一次，有 $p$ 个素因子，那么 $\\mu(x)=(-1)^p$，否则 $\\mu(x)=0$。\n\n\n这题要求你求出 $\\sum_{i=l}^r \\mu(i)$。\n", "inputFormat": "一行两个整数 $l,r$。\n", "outputFormat": "一行一个整数表示答案。\n", "hint": "对于 $10\\%$ 的数据，$l,r \\leq 10^6$。\n\n对于 $30\\%$ 的数据，$l,r \\leq 10^{12}$。\n\n对于 $100\\%$ 的数据，$1 \\leq l \\leq r \\leq 10^{18}$，$r-l \\leq 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P3654", "type": "P", "difficulty": 2, "samples": [["5 5 2\n.###.\n##.#.\n..#..\n#..#.\n#.###\n", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "枚举", "洛谷月赛"], "title": "First Step (ファーストステップ)", "background": "> **知らないことばかりなにもかもが（どうしたらいいの？）**    \n**一切的一切 尽是充满了未知数（该如何是好）**   \n**それでも期待で足が軽いよ（ジャンプだ！）**     \n**但我仍因满怀期待而步伐轻盈（起跳吧！）**       \n**温度差なんていつか消しちゃえってね**     \n**冷若冰霜的态度 有朝一日将会消失得无影无踪**      \n**元気だよ元気をだしていくよ**     \n**拿出活力 打起精神向前迈进吧**     \n\n ![](https://cdn.luogu.com.cn/upload/pic/4471.png) \n\n我们 Aqours，要第一次举办演唱会啦！\n\n虽然学生会长看上去不怎么支持我们的样子，可是有了理事长的支持，我们还是被允许在校内的篮球场里歌唱！\n\n歌曲也好好地准备过了，名字叫“[最喜欢的话就没问题！ (ダイスキだったらダイジョウブ！)](https://zh.moegirl.org/%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E8%AF%9D%E5%B0%B1%E6%B2%A1%E9%97%AE%E9%A2%98)“，大家一定会喜欢的吧！\n\n演唱会一定会顺利进行的！\n\n希望不要发生**停电**什么的事故哦……！\n", "description": "可是……这个篮球场，好像很久没有使用过的样子啊……\n\n里面堆满了学校的各种杂物呢……\n\n我们 Aqours 的成员要怎么在里面列队站下呢？\n\n\n我们浦之星女子学院的篮球场是一个 $R$ 行 $C$ 列的矩阵，其中堆满了各种学校的杂物 (用 `#` 表示)，空地 (用 `.` 表示) 好像并不多的样子呢……\n\n我们 Aqours 现在已经一共有 $K$ 个队员了，要歌唱舞蹈起来的话，我们得排成一条 $1\\times K$ 的直线，一个接一个地站在篮球场的空地上呢 (横竖均可)。\n\n我们想知道一共有多少种可行的站位方式呢。\n\nAqours 的真正的粉丝的你，能帮我们算算吗？\n", "inputFormat": "第一行三个整数 $R, C, K$。\n\n接下来的 $R$ 行 $C$ 列，表示浦之星女子学院篮球场。\n", "outputFormat": "总共的站位方式数量。\n", "hint": "|  | $R$ | $C$ | $K$ | 备注 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n|$1\\sim2$|$\\leq 10$|$\\leq 10$|$\\leq \\min(R,C)$|无|\n|$3\\sim4$|$\\leq 100$|$\\leq 100$|$\\leq 1$|无|\n|$5\\sim6$|$\\leq 100$|$\\leq 100$|$\\leq \\min(R,C)$|没有障碍|\n|$7\\sim10$|$\\leq 100$|$\\leq 100$|$\\leq \\min(R,C)$|无|\n\n对于所有数据，$1 \\leq R,C \\leq 100$，$1 \\leq k \\leq \\min(R,C)$。\n\n#### 以下是彩蛋\n\n在 LoveLive!Sunshine!! 动画第一季第三集中，Aqours 队长高海千歌演唱“最喜欢的话就没问题！”到副歌前时，学校因为雷击停电。\n", "locale": "zh-CN", "translations": {"en": {"title": "First Step (ファーストステップ)", "background": "> Everything is full of things I don't know (what should I do?).  \nEverything is entirely full of unknowns (what should I do?).  \nEven so, my steps feel light with anticipation (jump!).  \nBut I still have light steps because I’m full of expectation (jump!).  \nSomeday we’ll make this gap in enthusiasm disappear.  \nThat cold attitude will one day disappear without a trace.  \nI’m fine—I’ll cheer up and keep going.  \nShow your energy, lift your spirits, and move forward.\n\n![](https://cdn.luogu.com.cn/upload/pic/4471.png)\n\nWe, Aqours, are going to hold our first concert!\n\nAlthough the student council president doesn’t seem very supportive, with the chairwoman’s backing, we’ve been allowed to sing on the school’s basketball court!\n\nThe song is ready, titled “[If you really love it, it will be all right! (ダイスキだったらダイジョウブ！)](https://zh.moegirl.org/%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E8%AF%9D%E5%B0%B1%E6%B2%A1%E9%97%AE%E9%A2%98)”, and I’m sure everyone will like it!\n\nThe concert will definitely go smoothly!\n\nI hope nothing like a power outage happens...!", "description": "However... this basketball court seems like it hasn’t been used for a long time.\n\nIt’s piled high with all kinds of school odds and ends.\n\nHow can the members of Aqours line up inside?\n\nOur basketball court at Uranohoshi Girls’ High School is an $R$-by-$C$ grid. It is filled with various school items (denoted by `#`), and it looks like there isn’t much open space (denoted by `.`).\n\nWe now have $K$ members in Aqours. To sing and dance, we need to form a straight line of size $1 \\times K$, standing one after another on empty cells in the court (either horizontally or vertically).\n\nWe want to know how many possible ways there are to stand.\n\nAs a true fan of Aqours, can you help us count?", "inputFormat": "The first line contains three integers $R$, $C$, and $K$.\n\nThe following $R$ lines each contain $C$ characters, representing the basketball court of Uranohoshi Girls’ High School.", "outputFormat": "Output the total number of possible placements.", "hint": "|  | $R$ | $C$ | $K$ | Notes |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1\\sim2$ | $\\leq 10$ | $\\leq 10$ | $\\leq \\min(R, C)$ | None |\n| $3\\sim4$ | $\\leq 100$ | $\\leq 100$ | $\\leq 1$ | None |\n| $5\\sim6$ | $\\leq 100$ | $\\leq 100$ | $\\leq \\min(R, C)$ | No obstacles |\n| $7\\sim10$ | $\\leq 100$ | $\\leq 100$ | $\\leq \\min(R, C)$ | None |\n\nFor all testdata, $1 \\leq R, C \\leq 100$, $1 \\leq K \\leq \\min(R, C)$.\n\nEaster egg: In episode 3 of LoveLive! Sunshine!! season 1, when Chika Takami, the leader of Aqours, sings “If you really love it, it will be all right!” up to just before the chorus, the school loses power due to a lightning strike.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "First Step (ファーストステップ)", "background": "> **知らないことばかりなにもかもが（どうしたらいいの？）**    \n**一切的一切 尽是充满了未知数（该如何是好）**   \n**それでも期待で足が軽いよ（ジャンプだ！）**     \n**但我仍因满怀期待而步伐轻盈（起跳吧！）**       \n**温度差なんていつか消しちゃえってね**     \n**冷若冰霜的态度 有朝一日将会消失得无影无踪**      \n**元気だよ元気をだしていくよ**     \n**拿出活力 打起精神向前迈进吧**     \n\n ![](https://cdn.luogu.com.cn/upload/pic/4471.png) \n\n我们 Aqours，要第一次举办演唱会啦！\n\n虽然学生会长看上去不怎么支持我们的样子，可是有了理事长的支持，我们还是被允许在校内的篮球场里歌唱！\n\n歌曲也好好地准备过了，名字叫“[最喜欢的话就没问题！ (ダイスキだったらダイジョウブ！)](https://zh.moegirl.org/%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E8%AF%9D%E5%B0%B1%E6%B2%A1%E9%97%AE%E9%A2%98)“，大家一定会喜欢的吧！\n\n演唱会一定会顺利进行的！\n\n希望不要发生**停电**什么的事故哦……！\n", "description": "可是……这个篮球场，好像很久没有使用过的样子啊……\n\n里面堆满了学校的各种杂物呢……\n\n我们 Aqours 的成员要怎么在里面列队站下呢？\n\n\n我们浦之星女子学院的篮球场是一个 $R$ 行 $C$ 列的矩阵，其中堆满了各种学校的杂物 (用 `#` 表示)，空地 (用 `.` 表示) 好像并不多的样子呢……\n\n我们 Aqours 现在已经一共有 $K$ 个队员了，要歌唱舞蹈起来的话，我们得排成一条 $1\\times K$ 的直线，一个接一个地站在篮球场的空地上呢 (横竖均可)。\n\n我们想知道一共有多少种可行的站位方式呢。\n\nAqours 的真正的粉丝的你，能帮我们算算吗？\n", "inputFormat": "第一行三个整数 $R, C, K$。\n\n接下来的 $R$ 行 $C$ 列，表示浦之星女子学院篮球场。\n", "outputFormat": "总共的站位方式数量。\n", "hint": "|  | $R$ | $C$ | $K$ | 备注 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n|$1\\sim2$|$\\leq 10$|$\\leq 10$|$\\leq \\min(R,C)$|无|\n|$3\\sim4$|$\\leq 100$|$\\leq 100$|$\\leq 1$|无|\n|$5\\sim6$|$\\leq 100$|$\\leq 100$|$\\leq \\min(R,C)$|没有障碍|\n|$7\\sim10$|$\\leq 100$|$\\leq 100$|$\\leq \\min(R,C)$|无|\n\n对于所有数据，$1 \\leq R,C \\leq 100$，$1 \\leq k \\leq \\min(R,C)$。\n\n#### 以下是彩蛋\n\n在 LoveLive!Sunshine!! 动画第一季第三集中，Aqours 队长高海千歌演唱“最喜欢的话就没问题！”到副歌前时，学校因为雷击停电。\n", "locale": "zh-CN"}}}
