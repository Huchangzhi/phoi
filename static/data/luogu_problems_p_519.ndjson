{"pid": "P11528", "type": "P", "difficulty": 4, "samples": [["7\n11\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n11\n-1 -1\n1 1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n11\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n1 11\n22\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n11 9\n-1 -1\n-1 -1\n22\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n23\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n-1 -1\n22\n-1 -1\n1 1\n-1 -1\n3 1\n-1 -1\n4 2\n-1 -1\n2 6\n-1 -1\n-1 -1\n5 6\n-1 -1\n-1 -1\n7 7\n-1 -1\n-1 -1\n9 8\n-1 -1\n9 10\n-1 -1\n11 10\n-1 -1", "2\n0\n0\n0\n369512\n0\n864"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "THUPC"], "title": "[THUPC 2025 初赛] 乒乓球赛", "background": "", "description": "Menji 喜欢看乒乓球比赛，但由于观赛的人太多，他只能听到一部分的信息。\n\n乒乓球赛一共包含 $T$ 局，一局乒乓球的过程如下：\n\n两位选手分别有得分，用 $s_A$ 和 $s_B$ 表示，初始 $s_A=s_B=0$。\n\n接下来会进行若干个回合，在第 $i$ 个回合，会有一个获胜者 $win_i(win_i\\in\\{\\texttt{A},\\texttt{B}\\})$，若 $win_i=\\texttt{A}$ 则 $A$ 的得分 $+1$，即 $s_A=s_A+1$，否则 $B$ 的得分 $+1$，即 $s_B=s_B+1$。当任意一名选手达到 $11$ 分，且领先另一名选手至少 $2$ 分时（即 $\\max(s_A,s_B)\\geq 11$, $\\max(s_A,s_B)-\\min(s_A,s_B)\\geq 2$），该局**立刻结束**。\n\n对于每一局比赛，Menji 听到了最终该局进行的回合数 $n$，以及一部分时刻结束时的比分，例如 Menji 可能在第 $5$ 回合结束时听到比分是 $3:2$，**但 Menji 并不知道哪一名选手获得了 $3$ 分，只知道其中一名选手获得了 $3$ 分，另外一名选手获得了 $2$ 分**。\n\n具体的，Menji 的信息可以被表示为一个非负整数 $n$，表示该局**恰好**进行了 $n$ 个回合，以及 $2$ 个长为 $n$ 的序列 $a_1\\cdots a_n,b_1\\cdots b_n$。对于每一个 $i(1\\leq i\\leq n)$，若 $a_i=b_i=-1$，则 Menji 没有听到任何第 $i$ 个回合结束时的信息，否则保证 $0\\leq a_i,b_i\\leq n$，表示在第 $i$ 个回合结束时，一定满足 $s_A=a_i,s_B=b_i$ 或 $s_A=b_i,s_B=a_i$。\n\n显然，很多时候 Menji 的信息并不能还原比赛每一局每一回合的获胜者，甚至有时候 Menji 的信息会是错误的。Menji 想要知道，有多少个获胜者序列 $win_1\\cdots win_n$ 满足他已知的所有信息？\n\n由于答案可能很大，请输出答案对 $998244353$ 取模的结果。", "inputFormat": "第一行一个整数 $T(1\\leq T\\leq 10^5)$，表示乒乓球比赛的局数。\n\n对于每一局：\n\n第一行一个整数 $n$，表示比赛**恰好**进行了 $n(1\\leq n\\leq 10^5)$ 回合。\n\n之后 $n$ 行，每行两个整数 $a_i,b_i$，满足 $a_i=b_i=-1$ 或 $0\\leq a_i,b_i\\leq n$，表示 Menji 已知的一部分信息。\n\n保证总回合数不超过 $5\\times 10^5$，即 $\\sum n\\leq 5\\times 10^5$。", "outputFormat": "对于每一局，输出一行一个数，表示可能的获胜者序列个数，对 $998244353$ 取模。", "hint": "### 样例解释\n\n比赛总共进行了 $6$ 局。\n\n- 对于第一局，恰好进行了 $11$ 个回合结束，一定是某一选手连胜了 $11$ 回合，所以获胜者序列一定是全 $\\texttt{A}$ 或是全 $\\texttt{B}$，故答案为 $2$。\n- 对于第二局，恰好进行了 $11$ 个回合结束，但第二回合结束的比分是 $1:1$，最终至多只能达到 $10:1$ 的比分，因此不存在合法的获胜者序列使得恰好 $11$ 回合结束，故答案为 $0$。\n- 对于第三局，显然不可能在 $11$ 个回合内达到 $1:11$ 的比分，故答案为 $0$。\n- 对于第四局，若第 $20$ 个回合的比分达到 $11:9$，则该局会立刻结束，不会进行到第 $22$ 个回合，故答案为 $0$。\n- 对于第五局，双方的得分一定是先达到 $10:10$，之后其中一名选手连胜 $2$ 局，故答案为 $\\dbinom{20}{10}\\times 2 = 369512$。\n- 对于第六局，容易发现不可能恰好进行 $23$ 个回合时结束，故答案为 $0$。\n- 对于第七局，我有一个完美的解释，可惜写不下了。\n\n### 题目来源\n\n题目来自 THUPC2025（2025年清华大学学生程序设计竞赛暨高校邀请赛）初赛，信息来源于 [THUSAAC 仓库](https://gitlink.org.cn/thusaa/thupc2025pre)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2025 初赛] 乒乓球赛", "background": "", "description": "Menji 喜欢看乒乓球比赛，但由于观赛的人太多，他只能听到一部分的信息。\n\n乒乓球赛一共包含 $T$ 局，一局乒乓球的过程如下：\n\n两位选手分别有得分，用 $s_A$ 和 $s_B$ 表示，初始 $s_A=s_B=0$。\n\n接下来会进行若干个回合，在第 $i$ 个回合，会有一个获胜者 $win_i(win_i\\in\\{\\texttt{A},\\texttt{B}\\})$，若 $win_i=\\texttt{A}$ 则 $A$ 的得分 $+1$，即 $s_A=s_A+1$，否则 $B$ 的得分 $+1$，即 $s_B=s_B+1$。当任意一名选手达到 $11$ 分，且领先另一名选手至少 $2$ 分时（即 $\\max(s_A,s_B)\\geq 11$, $\\max(s_A,s_B)-\\min(s_A,s_B)\\geq 2$），该局**立刻结束**。\n\n对于每一局比赛，Menji 听到了最终该局进行的回合数 $n$，以及一部分时刻结束时的比分，例如 Menji 可能在第 $5$ 回合结束时听到比分是 $3:2$，**但 Menji 并不知道哪一名选手获得了 $3$ 分，只知道其中一名选手获得了 $3$ 分，另外一名选手获得了 $2$ 分**。\n\n具体的，Menji 的信息可以被表示为一个非负整数 $n$，表示该局**恰好**进行了 $n$ 个回合，以及 $2$ 个长为 $n$ 的序列 $a_1\\cdots a_n,b_1\\cdots b_n$。对于每一个 $i(1\\leq i\\leq n)$，若 $a_i=b_i=-1$，则 Menji 没有听到任何第 $i$ 个回合结束时的信息，否则保证 $0\\leq a_i,b_i\\leq n$，表示在第 $i$ 个回合结束时，一定满足 $s_A=a_i,s_B=b_i$ 或 $s_A=b_i,s_B=a_i$。\n\n显然，很多时候 Menji 的信息并不能还原比赛每一局每一回合的获胜者，甚至有时候 Menji 的信息会是错误的。Menji 想要知道，有多少个获胜者序列 $win_1\\cdots win_n$ 满足他已知的所有信息？\n\n由于答案可能很大，请输出答案对 $998244353$ 取模的结果。", "inputFormat": "第一行一个整数 $T(1\\leq T\\leq 10^5)$，表示乒乓球比赛的局数。\n\n对于每一局：\n\n第一行一个整数 $n$，表示比赛**恰好**进行了 $n(1\\leq n\\leq 10^5)$ 回合。\n\n之后 $n$ 行，每行两个整数 $a_i,b_i$，满足 $a_i=b_i=-1$ 或 $0\\leq a_i,b_i\\leq n$，表示 Menji 已知的一部分信息。\n\n保证总回合数不超过 $5\\times 10^5$，即 $\\sum n\\leq 5\\times 10^5$。", "outputFormat": "对于每一局，输出一行一个数，表示可能的获胜者序列个数，对 $998244353$ 取模。", "hint": "### 样例解释\n\n比赛总共进行了 $6$ 局。\n\n- 对于第一局，恰好进行了 $11$ 个回合结束，一定是某一选手连胜了 $11$ 回合，所以获胜者序列一定是全 $\\texttt{A}$ 或是全 $\\texttt{B}$，故答案为 $2$。\n- 对于第二局，恰好进行了 $11$ 个回合结束，但第二回合结束的比分是 $1:1$，最终至多只能达到 $10:1$ 的比分，因此不存在合法的获胜者序列使得恰好 $11$ 回合结束，故答案为 $0$。\n- 对于第三局，显然不可能在 $11$ 个回合内达到 $1:11$ 的比分，故答案为 $0$。\n- 对于第四局，若第 $20$ 个回合的比分达到 $11:9$，则该局会立刻结束，不会进行到第 $22$ 个回合，故答案为 $0$。\n- 对于第五局，双方的得分一定是先达到 $10:10$，之后其中一名选手连胜 $2$ 局，故答案为 $\\dbinom{20}{10}\\times 2 = 369512$。\n- 对于第六局，容易发现不可能恰好进行 $23$ 个回合时结束，故答案为 $0$。\n- 对于第七局，我有一个完美的解释，可惜写不下了。\n\n### 题目来源\n\n题目来自 THUPC2025（2025年清华大学学生程序设计竞赛暨高校邀请赛）初赛，信息来源于 [THUSAAC 仓库](https://gitlink.org.cn/thusaa/thupc2025pre)。", "locale": "zh-CN"}}}
{"pid": "P11529", "type": "P", "difficulty": 4, "samples": [["5 2\n3 5\n1 2\n1 3\n2 4\n2 5", "1"], ["10 3\n1 6 8\n1 2\n2 3\n3 4\n4 5\n4 6\n5 7\n5 8\n6 9\n7 10", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "树形 DP", "THUPC"], "title": "[THUPC 2025 初赛] 辞甲猾扎", "background": "", "description": "给你一棵 $n$ 个点的无根树，有 $k$ 个点初始为黑色，其余点初始为灰色，你可以在一开始将一些**灰色**点染成白色。染完后，现在进行如下操作，直到树上不存在灰色点。    \n\n每一轮对所有灰色点**同时**进行如下操作：\n\n1. 检查与该灰色点 $u$ 直接相连的点有没有黑色或白色点，如果没有，则 $u$ 保持灰色。\n2. 如果与 $u$ 直接相连的点有白色点，则 $u$ 变为白色。\n3. 如果与 $u$ 直接相连的点有黑色点，则 $u$ 变为黑色。\n\n这个顺序说明同时与白色和黑色相邻时会被染成白色。  \n\n注意此处对所有灰色点同时进行操作，也就是说在这一轮被染上颜色的点不能作为其它点改变颜色的根据。  \n\n现在求一开始最少染几个点为白色，可以使树最终黑色点不超过 $k$ 个。", "inputFormat": "第一行两个整数 $n,k\\;(1\\le n\\le 10^6,1\\le k \\le n)$，含义见上文。  \n\n第二行 $k$ 个整数，代表一开始被染成黑色的点的标号。  \n\n第 $3\\sim n+2$ 行每行两个整数 $u,v\\;(1\\le u,v\\le n)$，代表一条树上的边。  \n", "outputFormat": "\n一行一个整数，为答案。\n", "hint": "- 对于第一组样例，一开始将 $2$ 号点染白即可\n- 对于第二组样例，一开始将 $3,4,9$ 号点染白为满足条件且数量最小一组方案\n\n#### 题目来源\n\n来自 2025 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2025）初赛。\n\n题解等资源可在 <https://gitlink.org.cn/thusaa/thupc2025pre/tree/master> 查看。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2025 初赛] 辞甲猾扎", "background": "", "description": "给你一棵 $n$ 个点的无根树，有 $k$ 个点初始为黑色，其余点初始为灰色，你可以在一开始将一些**灰色**点染成白色。染完后，现在进行如下操作，直到树上不存在灰色点。    \n\n每一轮对所有灰色点**同时**进行如下操作：\n\n1. 检查与该灰色点 $u$ 直接相连的点有没有黑色或白色点，如果没有，则 $u$ 保持灰色。\n2. 如果与 $u$ 直接相连的点有白色点，则 $u$ 变为白色。\n3. 如果与 $u$ 直接相连的点有黑色点，则 $u$ 变为黑色。\n\n这个顺序说明同时与白色和黑色相邻时会被染成白色。  \n\n注意此处对所有灰色点同时进行操作，也就是说在这一轮被染上颜色的点不能作为其它点改变颜色的根据。  \n\n现在求一开始最少染几个点为白色，可以使树最终黑色点不超过 $k$ 个。", "inputFormat": "第一行两个整数 $n,k\\;(1\\le n\\le 10^6,1\\le k \\le n)$，含义见上文。  \n\n第二行 $k$ 个整数，代表一开始被染成黑色的点的标号。  \n\n第 $3\\sim n+2$ 行每行两个整数 $u,v\\;(1\\le u,v\\le n)$，代表一条树上的边。  \n", "outputFormat": "\n一行一个整数，为答案。\n", "hint": "- 对于第一组样例，一开始将 $2$ 号点染白即可\n- 对于第二组样例，一开始将 $3,4,9$ 号点染白为满足条件且数量最小一组方案\n\n#### 题目来源\n\n来自 2025 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2025）初赛。\n\n题解等资源可在 <https://gitlink.org.cn/thusaa/thupc2025pre/tree/master> 查看。", "locale": "zh-CN"}}}
{"pid": "P11530", "type": "P", "difficulty": 7, "samples": [["4\n1 3 2 4", "..*.."], ["9\n3 4 1 2 8 9 5 6 7", ".1-2#...1-1.1-2#....1-1"], ["4\n2 4 1 3", "-1"], ["7\n7 1 2 6 5 3 4", ".1-2...1-1*.1-2..1-1"], ["8\n1 2 8 6 3 5 4 7", "...2-2.1-2..1-1*..2-1"], ["8\n2 1 3 8 7 5 4 6", ".*...*.1-2.*..1-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "THUPC"], "title": "[THUPC 2025 初赛] 峰回路转", "background": "昼短夜长冬至近。江冽漆黑，但见东云粉。窗外惺忪鸥鹭阵，室中香漫晨炊奋。\n\n朝肄暮劳催彼盹。宵寂观书，灯烬方安寝。请替君劳分重任，逍遥共舞生辰顺。", "description": "K 最近在学古诗文。古诗文的行文不一定按照现代人的习惯，有时是因为古诗文有其特殊的语法结构，有时是因为对仗工整、韵律和谐等主观原因。但是，如果直接在原文旁边标注一个表示正确阅读顺序的排列，不仅在排版上不美观，而且寻找下一个编号也比较麻烦。为了方便阅读，K 设计了一套辅助记号来标注顺序，替代直接标注顺序编号的方式。\n\n辅助记号一共有 3 种：近邻逆接记号、近邻顺接记号、遥远跳转记号。两种近邻记号定义了**相邻两个字符**之间相对的阅读顺序，故其必须出现在相邻两个字符之间，而不能出现在句首或句末；遥远跳转记号在单独使用时仅作用于其**前一个字符**，故其必须出现在单个字符之后，可以出现在句末而不能出现在句首。\n\n近邻逆接记号 `*` 用于表示，在正常阅读顺序中，该记号前的**最后一个**字符应该**紧跟**在该记号后的**第一个**字符之后，如“研表`*`究明，汉字序`*`顺并不定`*`一影阅`*`响读”的正确语序是“研究表明，汉字顺序并不一定影响阅读”。近邻逆接记号可以连续使用，此时表示对应的一整段文字应从后往前逐个阅读。如“林暗草惊风，将军夜引弓”的正常语序是“林暗风惊草，将军夜引弓”，所以可以用“林暗草`*`惊`*`风”来标记主宾换位。\n\n对于较复杂的阅读顺序，可以用遥远跳转记号来辅助理解。例如，“马之千里者，一食或尽粟一石”中，“一石”是修饰“粟”的数量短语，因此按正常语序应为“一食或尽一石粟”。为了标注此类不相邻的顺序交换，可以使用遥远跳转记号来指出需要从后往前依次阅读的一组字符，并称这样的一组字符为遥远跳转结构。为了防止出现混乱，规定对于任意两组遥远跳转结构，要么其中一组的所有字符都在另一组的任意字符之前，要么其中一组的所有字符都位于另一组中连续的某两个字符之间；不允许两组遥远跳转结构的字符在原字符串中交叉出现。因为可能出现多层嵌套，所以遥远跳转记号具有 `p-q` 的形式，其中正整数 `p` 表示内部嵌套的层数，`q` 表示在该组中的顺序。如果一组遥远跳转结构内部没有嵌套任何其它遥远跳转结构，则该组遥远跳转结构的各记号的层数 `p` 均为 $1$，否则为内部嵌套的所有遥远跳转结构的最大层数 $+1$。对于同一组遥远跳转结构，按各字符在原字符串中的出现顺序从后往前依次编号 `q` $=1,2,3,\\cdots$，这一顺序也即实际阅读顺序。在阅读带有辅助记号的文本时，如果一个字符后紧跟着序号 `q` $\\ge 2$ 的遥远跳转记号，则应暂时跳过该字符不读；直到遇到 `q` 恰好为 $1$ 的遥远跳转记号，此时应从后往前依次阅读同组的 `p-1`，`p-2` 等记号前的**单个**字符，直到遇到层数 `p` 更大的遥远跳转记号、另一个层数相同的 `p-1` 的遥远跳转记号（此时这一记号应标记另一组遥远跳转结构），或者碰到开头。\n\n对于上文中取自《马说》的例句，相应的标注方法为“一食或尽粟`1-2`一石`1-1`”。再例如，“入则无法家拂士，出则无敌国外患者，国恒亡，然后知生于忧患而死于安乐也”一句中出现了两处状语后置（“然后知于忧患生而于安乐死也”），其满足要求的标注方法为“然后知生`1-2`于忧患`1-1`而死`1-2`于安乐`1-1`也”。另外，同一组的遥远跳转记号的序号 `q` 一定是降序出现的，即不允许连续出现 `p-2 p-3 p-1` 等情况。\n\n由于近邻逆接记号和遥远跳转记号都可以用来表示与正常阅读方向相反的跳转，规定在读完一个字符后需要紧接着阅读其前一个字符时，**必须**使用近邻逆接记号。这一规定会产生一个问题，即在同一组遥远跳转结构中出现了在原文中相邻的字符时，如果相邻的字符不在遥远跳转结构的开头或结尾，用近邻逆接记号来标注这一堆字符，有可能会导致阅读顺序的歧义。幸好，解决办法并不复杂：只需在出现相邻字符的位置将一个遥远跳转结构拆成两个或多个即可。注意拆开时，每个新的结构的所对应的层数应独立计算。\n\n在使用遥远跳转记号时，默认只更改记号前的**单个**字符的阅读顺序。如果需要将连续的多个字符的阅读顺序推后，则应配合近邻顺接记号 `#`，表示该记号后的**第一个**字符应该**紧跟**在该记号前的**最后一个**字符之后。例如，“今日大风寒，寒风摧树木，严霜结庭兰”一句中，主语“庭兰”和宾语“严霜”的位置发生了对调，故可以标注为“严`1-3#`霜结`1-2`庭兰`1-1`”。出于简洁起见，要求近邻顺接记号必须和序号 `q` $\\ge 2$ 的遥远跳转记号连用，但根据实际需要可以连续使用多个近邻顺接记号，此时在且仅在第一个近邻顺接记号前标注遥远跳转记号。例如，“七八个星天外，两三点雨山前”的正常语序是“天外七八个星，山前两三点雨”，因此可以标注为“七`1-2#`八`#`个`#`星天外`1-1`，两`1-2#`三`#`点`#`雨山前`1-1`”。\n\n在阅读标注有辅助记号的文本时，默认按照正常阅读顺序从前往后处理每个字符。如果遇到一个字符没有标注辅助记号且其前一个字符没有标记近邻顺接记号，应该直接阅读这个字符；否则，先暂时忽略该字符。当遇到标注有序号为 $1$ 的遥远跳转记号的字符（对应忽略了同组的遥远跳转记号及任何相关的近邻顺接记号）或没有标注辅助记号的字符（对应忽略了至少一个近邻逆接记号）时，先阅读这个字符，再按相应规则返回阅读被忽略的字符。\n\n为了防止使用记号时出现歧义，除了上述规则外，还规定：\n\n- 相邻两个字符之间，要么不使用任何辅助记号，要么使用单独的近邻逆接记号，单独的近邻顺接记号，单独的遥远跳转记号，一个遥远跳转记号和一个近邻逆接记号，或一个遥远跳转记号和一个近邻顺接记号。最后一个字符之后要么没有辅助记号，要么有单独的遥远跳转记号。\n- 如果相邻两个字符之间使用了一个遥远跳转记号和任意一种近邻记号的组合，则应将遥远跳转记号标在近邻记号之前。特别地，如果是一个遥远跳转记号和一个近邻逆接记号的组合，则该遥远跳转记号的序号 `q` 必须为 $1$。\n- 对于任意连续的三个字符，不允许混合使用近邻逆接记号和近邻顺接记号（无论是否与遥远跳转记号搭配使用），即不能出现 `.#.*.` 或 `.*.#.` 等未定义的标注方式，其中 `.` 表示单个需要被标注的字符。同理，不允许出现前一个字符标注了近邻顺接记号，后一个字符标注了遥远跳转记号（无论这个遥远跳转记号是否与任意近邻记号组合使用）。\n\n不过，K 发现这套系统并不能标记任意的排列。例如，“绿垂风折笋，红绽雨肥梅”在现代汉语中的语序是“风折绿笋垂，雨肥红梅绽”，它就无法被任意记号的组合表示。因此 K 想知道，对于给定的一个阅读顺序，是否存在一种仅使用上述三种记号的标注方法。如果存在，请帮 K 求出满足简洁要求的唯一标注方法。", "inputFormat": "输入的第一行包含一个正整数 $K$，表示需要标注的原字符串长度。保证 $1\\le K \\le 10^6$。\n\n输入的第二行包含 $K$ 个正整数 $p_1, p_2, \\cdots, p_K$，其中 $p_i$ 表示需要标注的原字符串的第 $i$ 个字符在正确阅读顺序中的位置。保证 $p_1, p_2, \\cdots, p_K$ 是一个 $1, 2, \\cdots, K$ 的排列。", "outputFormat": "输出一个字符串。\n\n如果存在合法的标注方法，则输出满足要求的唯一标注方法，其中用单个 `.` 表示原字符串中的每个字符。\n\n否则，输出 `-1`，表示不存在合法的标注方法。", "hint": "### 样例解释\n\n- 样例 1：“微斯人，吾谁`*`与归？”\n\n- 样例 2：“故`1-2#`国神游`1-1`，多`1-2#`情应笑我`1-1`。”\n\n- 样例 3：\n另外三种不能被表示出来的长度为 $4$ 的阅读顺序为：\n  + $2, 4, 3, 1$；\n  + $3, 1, 4, 2$；\n  + $3, 2, 4, 1$。\n  \n### 题目来源\n\n题目来自 THUPC2025（2025年清华大学学生程序设计竞赛暨高校邀请赛）初赛，信息来源于 [THUSAAC 仓库](https://gitlink.org.cn/thusaa/thupc2025pre)。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2025 初赛] 峰回路转", "background": "昼短夜长冬至近。江冽漆黑，但见东云粉。窗外惺忪鸥鹭阵，室中香漫晨炊奋。\n\n朝肄暮劳催彼盹。宵寂观书，灯烬方安寝。请替君劳分重任，逍遥共舞生辰顺。", "description": "K 最近在学古诗文。古诗文的行文不一定按照现代人的习惯，有时是因为古诗文有其特殊的语法结构，有时是因为对仗工整、韵律和谐等主观原因。但是，如果直接在原文旁边标注一个表示正确阅读顺序的排列，不仅在排版上不美观，而且寻找下一个编号也比较麻烦。为了方便阅读，K 设计了一套辅助记号来标注顺序，替代直接标注顺序编号的方式。\n\n辅助记号一共有 3 种：近邻逆接记号、近邻顺接记号、遥远跳转记号。两种近邻记号定义了**相邻两个字符**之间相对的阅读顺序，故其必须出现在相邻两个字符之间，而不能出现在句首或句末；遥远跳转记号在单独使用时仅作用于其**前一个字符**，故其必须出现在单个字符之后，可以出现在句末而不能出现在句首。\n\n近邻逆接记号 `*` 用于表示，在正常阅读顺序中，该记号前的**最后一个**字符应该**紧跟**在该记号后的**第一个**字符之后，如“研表`*`究明，汉字序`*`顺并不定`*`一影阅`*`响读”的正确语序是“研究表明，汉字顺序并不一定影响阅读”。近邻逆接记号可以连续使用，此时表示对应的一整段文字应从后往前逐个阅读。如“林暗草惊风，将军夜引弓”的正常语序是“林暗风惊草，将军夜引弓”，所以可以用“林暗草`*`惊`*`风”来标记主宾换位。\n\n对于较复杂的阅读顺序，可以用遥远跳转记号来辅助理解。例如，“马之千里者，一食或尽粟一石”中，“一石”是修饰“粟”的数量短语，因此按正常语序应为“一食或尽一石粟”。为了标注此类不相邻的顺序交换，可以使用遥远跳转记号来指出需要从后往前依次阅读的一组字符，并称这样的一组字符为遥远跳转结构。为了防止出现混乱，规定对于任意两组遥远跳转结构，要么其中一组的所有字符都在另一组的任意字符之前，要么其中一组的所有字符都位于另一组中连续的某两个字符之间；不允许两组遥远跳转结构的字符在原字符串中交叉出现。因为可能出现多层嵌套，所以遥远跳转记号具有 `p-q` 的形式，其中正整数 `p` 表示内部嵌套的层数，`q` 表示在该组中的顺序。如果一组遥远跳转结构内部没有嵌套任何其它遥远跳转结构，则该组遥远跳转结构的各记号的层数 `p` 均为 $1$，否则为内部嵌套的所有遥远跳转结构的最大层数 $+1$。对于同一组遥远跳转结构，按各字符在原字符串中的出现顺序从后往前依次编号 `q` $=1,2,3,\\cdots$，这一顺序也即实际阅读顺序。在阅读带有辅助记号的文本时，如果一个字符后紧跟着序号 `q` $\\ge 2$ 的遥远跳转记号，则应暂时跳过该字符不读；直到遇到 `q` 恰好为 $1$ 的遥远跳转记号，此时应从后往前依次阅读同组的 `p-1`，`p-2` 等记号前的**单个**字符，直到遇到层数 `p` 更大的遥远跳转记号、另一个层数相同的 `p-1` 的遥远跳转记号（此时这一记号应标记另一组遥远跳转结构），或者碰到开头。\n\n对于上文中取自《马说》的例句，相应的标注方法为“一食或尽粟`1-2`一石`1-1`”。再例如，“入则无法家拂士，出则无敌国外患者，国恒亡，然后知生于忧患而死于安乐也”一句中出现了两处状语后置（“然后知于忧患生而于安乐死也”），其满足要求的标注方法为“然后知生`1-2`于忧患`1-1`而死`1-2`于安乐`1-1`也”。另外，同一组的遥远跳转记号的序号 `q` 一定是降序出现的，即不允许连续出现 `p-2 p-3 p-1` 等情况。\n\n由于近邻逆接记号和遥远跳转记号都可以用来表示与正常阅读方向相反的跳转，规定在读完一个字符后需要紧接着阅读其前一个字符时，**必须**使用近邻逆接记号。这一规定会产生一个问题，即在同一组遥远跳转结构中出现了在原文中相邻的字符时，如果相邻的字符不在遥远跳转结构的开头或结尾，用近邻逆接记号来标注这一堆字符，有可能会导致阅读顺序的歧义。幸好，解决办法并不复杂：只需在出现相邻字符的位置将一个遥远跳转结构拆成两个或多个即可。注意拆开时，每个新的结构的所对应的层数应独立计算。\n\n在使用遥远跳转记号时，默认只更改记号前的**单个**字符的阅读顺序。如果需要将连续的多个字符的阅读顺序推后，则应配合近邻顺接记号 `#`，表示该记号后的**第一个**字符应该**紧跟**在该记号前的**最后一个**字符之后。例如，“今日大风寒，寒风摧树木，严霜结庭兰”一句中，主语“庭兰”和宾语“严霜”的位置发生了对调，故可以标注为“严`1-3#`霜结`1-2`庭兰`1-1`”。出于简洁起见，要求近邻顺接记号必须和序号 `q` $\\ge 2$ 的遥远跳转记号连用，但根据实际需要可以连续使用多个近邻顺接记号，此时在且仅在第一个近邻顺接记号前标注遥远跳转记号。例如，“七八个星天外，两三点雨山前”的正常语序是“天外七八个星，山前两三点雨”，因此可以标注为“七`1-2#`八`#`个`#`星天外`1-1`，两`1-2#`三`#`点`#`雨山前`1-1`”。\n\n在阅读标注有辅助记号的文本时，默认按照正常阅读顺序从前往后处理每个字符。如果遇到一个字符没有标注辅助记号且其前一个字符没有标记近邻顺接记号，应该直接阅读这个字符；否则，先暂时忽略该字符。当遇到标注有序号为 $1$ 的遥远跳转记号的字符（对应忽略了同组的遥远跳转记号及任何相关的近邻顺接记号）或没有标注辅助记号的字符（对应忽略了至少一个近邻逆接记号）时，先阅读这个字符，再按相应规则返回阅读被忽略的字符。\n\n为了防止使用记号时出现歧义，除了上述规则外，还规定：\n\n- 相邻两个字符之间，要么不使用任何辅助记号，要么使用单独的近邻逆接记号，单独的近邻顺接记号，单独的遥远跳转记号，一个遥远跳转记号和一个近邻逆接记号，或一个遥远跳转记号和一个近邻顺接记号。最后一个字符之后要么没有辅助记号，要么有单独的遥远跳转记号。\n- 如果相邻两个字符之间使用了一个遥远跳转记号和任意一种近邻记号的组合，则应将遥远跳转记号标在近邻记号之前。特别地，如果是一个遥远跳转记号和一个近邻逆接记号的组合，则该遥远跳转记号的序号 `q` 必须为 $1$。\n- 对于任意连续的三个字符，不允许混合使用近邻逆接记号和近邻顺接记号（无论是否与遥远跳转记号搭配使用），即不能出现 `.#.*.` 或 `.*.#.` 等未定义的标注方式，其中 `.` 表示单个需要被标注的字符。同理，不允许出现前一个字符标注了近邻顺接记号，后一个字符标注了遥远跳转记号（无论这个遥远跳转记号是否与任意近邻记号组合使用）。\n\n不过，K 发现这套系统并不能标记任意的排列。例如，“绿垂风折笋，红绽雨肥梅”在现代汉语中的语序是“风折绿笋垂，雨肥红梅绽”，它就无法被任意记号的组合表示。因此 K 想知道，对于给定的一个阅读顺序，是否存在一种仅使用上述三种记号的标注方法。如果存在，请帮 K 求出满足简洁要求的唯一标注方法。", "inputFormat": "输入的第一行包含一个正整数 $K$，表示需要标注的原字符串长度。保证 $1\\le K \\le 10^6$。\n\n输入的第二行包含 $K$ 个正整数 $p_1, p_2, \\cdots, p_K$，其中 $p_i$ 表示需要标注的原字符串的第 $i$ 个字符在正确阅读顺序中的位置。保证 $p_1, p_2, \\cdots, p_K$ 是一个 $1, 2, \\cdots, K$ 的排列。", "outputFormat": "输出一个字符串。\n\n如果存在合法的标注方法，则输出满足要求的唯一标注方法，其中用单个 `.` 表示原字符串中的每个字符。\n\n否则，输出 `-1`，表示不存在合法的标注方法。", "hint": "### 样例解释\n\n- 样例 1：“微斯人，吾谁`*`与归？”\n\n- 样例 2：“故`1-2#`国神游`1-1`，多`1-2#`情应笑我`1-1`。”\n\n- 样例 3：\n另外三种不能被表示出来的长度为 $4$ 的阅读顺序为：\n  + $2, 4, 3, 1$；\n  + $3, 1, 4, 2$；\n  + $3, 2, 4, 1$。\n  \n### 题目来源\n\n题目来自 THUPC2025（2025年清华大学学生程序设计竞赛暨高校邀请赛）初赛，信息来源于 [THUSAAC 仓库](https://gitlink.org.cn/thusaa/thupc2025pre)。", "locale": "zh-CN"}}}
{"pid": "P11531", "type": "P", "difficulty": 6, "samples": [["5 10 3\n3 1 4\n1 3 1\n4 3 1\n3 2 1\n3 5 1\n1 2 2\n2 1 2\n1 4 2\n5 1 2\n1 4 3\n4 5 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "网络流", "最小割", "THUPC"], "title": "[THUPC 2025 初赛] 检查站", "background": "", "description": "小 I 是一个巨大的铁路公司的主管，他管理着 $n$ 个火车站，用 $1$ 至 $n$ 的整数给它们编号。铁路公司有 $c$ 个分部，第 $i$ 个分部的办公室位于火车站 $p_i$。可能有火车站没有分部办公室，一个火车站也有可能有多个分部办公室。\n\n$n$ 个火车站之间由 $m$ 条单向铁路连接，其中第 $i$ 条铁路由火车站 $u_i$ 连向 $v_i$，属于分部 $r_i$ 管辖。为了保证管理方便，分部 $r_i$ 的办公室要么在 $u_i$，要么在 $v_i$。\n\n火车站 $1$（港口）和 $n$（首都）是公司管辖范围内最繁忙的车站。为了保障进口货物安全，根据交通运输部的要求，小 I 需要在一些铁路上设立检查站，使得从火车站 $1$ 到火车站 $n$ 的所有可能路线上都有一个有检查站的铁路。\n\n小 I 可以通知一些分部（也可以不通知任何分部），要求这些分部在它们管理的所有铁路上设立检查站。小 I 想知道，最少需要通知多少个分部才可以达到要求。作为新上任的算法工程师，你准备给小 I 露一手。", "inputFormat": "输入的第一行三个整数 $n,m,c (2 \\le n, m, c \\le 5\\times 10^4)$，分别表示火车站数量、铁路数量和分部数量。\n\n接下来一行 $c$ 个整数 $p_1, p_2, \\cdots, p_c (1 \\le p_i \\le n)$，描述每个分部所在的火车站编号。\n\n接下来 $m$ 行每行三个整数 $u_i, v_i, r_i (1 \\le u_i, v_i \\le n, 1 \\le r_i \\le c)$，描述一条铁路。保证 $p_{r_i} = u_i$ 或 $p_{r_i} = v_i$。", "outputFormat": "输出一行一个整数表示最少需要通知的分部数量。", "hint": "### 样例解释\n\n该样例的铁路组织如下图所示，其中红色、绿色和黑色分别为 1、2、3 分部管辖的铁路。最优策略是通知分部 1 和 3。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yami1v28.png)\n\n### 题目来源\n\n题目来自 THUPC2025（2025年清华大学学生程序设计竞赛暨高校邀请赛）初赛，信息来源于 [THUSAAC 仓库](https://gitlink.org.cn/thusaa/thupc2025pre)。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2025 初赛] 检查站", "background": "", "description": "小 I 是一个巨大的铁路公司的主管，他管理着 $n$ 个火车站，用 $1$ 至 $n$ 的整数给它们编号。铁路公司有 $c$ 个分部，第 $i$ 个分部的办公室位于火车站 $p_i$。可能有火车站没有分部办公室，一个火车站也有可能有多个分部办公室。\n\n$n$ 个火车站之间由 $m$ 条单向铁路连接，其中第 $i$ 条铁路由火车站 $u_i$ 连向 $v_i$，属于分部 $r_i$ 管辖。为了保证管理方便，分部 $r_i$ 的办公室要么在 $u_i$，要么在 $v_i$。\n\n火车站 $1$（港口）和 $n$（首都）是公司管辖范围内最繁忙的车站。为了保障进口货物安全，根据交通运输部的要求，小 I 需要在一些铁路上设立检查站，使得从火车站 $1$ 到火车站 $n$ 的所有可能路线上都有一个有检查站的铁路。\n\n小 I 可以通知一些分部（也可以不通知任何分部），要求这些分部在它们管理的所有铁路上设立检查站。小 I 想知道，最少需要通知多少个分部才可以达到要求。作为新上任的算法工程师，你准备给小 I 露一手。", "inputFormat": "输入的第一行三个整数 $n,m,c (2 \\le n, m, c \\le 5\\times 10^4)$，分别表示火车站数量、铁路数量和分部数量。\n\n接下来一行 $c$ 个整数 $p_1, p_2, \\cdots, p_c (1 \\le p_i \\le n)$，描述每个分部所在的火车站编号。\n\n接下来 $m$ 行每行三个整数 $u_i, v_i, r_i (1 \\le u_i, v_i \\le n, 1 \\le r_i \\le c)$，描述一条铁路。保证 $p_{r_i} = u_i$ 或 $p_{r_i} = v_i$。", "outputFormat": "输出一行一个整数表示最少需要通知的分部数量。", "hint": "### 样例解释\n\n该样例的铁路组织如下图所示，其中红色、绿色和黑色分别为 1、2、3 分部管辖的铁路。最优策略是通知分部 1 和 3。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yami1v28.png)\n\n### 题目来源\n\n题目来自 THUPC2025（2025年清华大学学生程序设计竞赛暨高校邀请赛）初赛，信息来源于 [THUSAAC 仓库](https://gitlink.org.cn/thusaa/thupc2025pre)。\n", "locale": "zh-CN"}}}
{"pid": "P11532", "type": "P", "difficulty": 1, "samples": [], "limits": {"time": [1000], "memory": [524288]}, "tags": ["2025", "THUPC"], "title": "[THUPC 2025 初赛] 好成绩", "background": "蒜薢是炼火中学的一名 OIER。", "description": "作为一名 OIER，蒜薢同学自然需要了解一些普通同学大学才会接触的知识，这些知识是数学方面的。要学习这些知识并不简单，但好在蒜薢遇到了悉心指导她的老师，在老师的帮助下，蒜薢很快掌握了大量技能，包括但不限于计算 $3$ 行 $4$ 列矩阵的行列式、对发散的数列求和并把结果除以 $2$、发明求导符号的特殊中文表示法……总之，蒜薢通过自己的努力学习，成为了实力超强的巨佬。\n\n实力超强的蒜薢自然要打一些实力超强的比赛，在过去的几个月里，蒜薢都在全神贯注地备战 THUPC——THUPC 是一个国际化的大比赛，分为初赛和复赛两轮，初赛取得好成绩的选手不仅可以进入复赛、获得富有设计感的服装，还可能得到优胜小奖品，甚至可能被采访上电视。为了能够在初赛中一鸣惊人，蒜薢废寝忘食地抄写着老师的笔记，自然也就忘记了即将来临的月考。虽然蒜薢在数学方面能力超强，但月考涉及的数学知识和数学方面不同，忘记复习的蒜薢在考场上只能胡乱答题。\n\n不久后，月考的成绩公布了，蒜薢不出意料考得不好。因为考试失利对情绪造成的打击，蒜薢忘记了自己的具体分数，但超强的数学方面能力还是让她快速地记下了另一些相关信息：具体来说，蒜薢的月考数学成绩是一个 $0$ 到 $150$ 之间的整数，它除以 $3$ 得到的余数是 $2$，除以 $5$ 得到的余数是 $3$，除以 $7$ 得到的余数是 $6$。\n\n蒜薢不能根据上面的信息求出自己的月考数学成绩，你能帮帮她吗？", "inputFormat": "本题无需输入。", "outputFormat": "输出一个整数，表示蒜薢的月考数学成绩。", "hint": "薢，音械，是一种一年生草本植物，长在池沼中，叶子浮在水面。\n\n蒜薢的名字是一个谐音梗，但不仅限于此——你想对个对子吗？\n\n#### 题目来源\n\n来自 2025 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2025）初赛。\n\n题解等资源可在 <https://gitlink.org.cn/thusaa/thupc2025pre/tree/master> 查看。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2025 初赛] 好成绩", "background": "蒜薢是炼火中学的一名 OIER。", "description": "作为一名 OIER，蒜薢同学自然需要了解一些普通同学大学才会接触的知识，这些知识是数学方面的。要学习这些知识并不简单，但好在蒜薢遇到了悉心指导她的老师，在老师的帮助下，蒜薢很快掌握了大量技能，包括但不限于计算 $3$ 行 $4$ 列矩阵的行列式、对发散的数列求和并把结果除以 $2$、发明求导符号的特殊中文表示法……总之，蒜薢通过自己的努力学习，成为了实力超强的巨佬。\n\n实力超强的蒜薢自然要打一些实力超强的比赛，在过去的几个月里，蒜薢都在全神贯注地备战 THUPC——THUPC 是一个国际化的大比赛，分为初赛和复赛两轮，初赛取得好成绩的选手不仅可以进入复赛、获得富有设计感的服装，还可能得到优胜小奖品，甚至可能被采访上电视。为了能够在初赛中一鸣惊人，蒜薢废寝忘食地抄写着老师的笔记，自然也就忘记了即将来临的月考。虽然蒜薢在数学方面能力超强，但月考涉及的数学知识和数学方面不同，忘记复习的蒜薢在考场上只能胡乱答题。\n\n不久后，月考的成绩公布了，蒜薢不出意料考得不好。因为考试失利对情绪造成的打击，蒜薢忘记了自己的具体分数，但超强的数学方面能力还是让她快速地记下了另一些相关信息：具体来说，蒜薢的月考数学成绩是一个 $0$ 到 $150$ 之间的整数，它除以 $3$ 得到的余数是 $2$，除以 $5$ 得到的余数是 $3$，除以 $7$ 得到的余数是 $6$。\n\n蒜薢不能根据上面的信息求出自己的月考数学成绩，你能帮帮她吗？", "inputFormat": "本题无需输入。", "outputFormat": "输出一个整数，表示蒜薢的月考数学成绩。", "hint": "薢，音械，是一种一年生草本植物，长在池沼中，叶子浮在水面。\n\n蒜薢的名字是一个谐音梗，但不仅限于此——你想对个对子吗？\n\n#### 题目来源\n\n来自 2025 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2025）初赛。\n\n题解等资源可在 <https://gitlink.org.cn/thusaa/thupc2025pre/tree/master> 查看。", "locale": "zh-CN"}}}
{"pid": "P11533", "type": "P", "difficulty": 4, "samples": [["3 3\n0 0 0\n7 9 2\n7 8 9\n7 8 2\n7 7 7\n8 10 9\n", "1\n"], ["4 3\n5 1 0\n0 1 5\n0 0 0\n7 7 7\n0 5 6\n1 1 1\n8 2 0\n8 1 4\n", "4\n"], ["5 5\n14 11 15 7 15\n0 0 0 0 0\n9 9 14 2 13\n4 3 6 1 0\n2 4 7 0 0\n5 5 0 0 13\n4 4 7 1 0\n4 1 0 2 1\n2 5 0 2 1\n4 0 7 2 12\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "NOISG（新加坡）"], "title": "[NOISG 2023 Finals] Topical", "background": "", "description": "兔子 Benson 正在上飞行员学校！\n\n他需要完成 $n$ 场测试，由 $1\\sim n$ 编号。对于每场测试，有 $k$ 个科目。对于每个科目，Benson 有一个能力值 $p_j$。由于 Benson 还是一名新手，他对于每个科目的初始能力值均为 $0$。\n\n对于每场测试的每个科目，均有一个能力值下限 $r_{i, j}$。而为了完成第 $i$ 场测试，需要满足他每个科目的能力值都不低于这个下限。\n\n若成功完成第 $i$ 场测试，他的能力值将获得提升，且第 $j$ 个科目的能力值将提升 $u_{i, j}$。\n\n**形式化地**：初始，对于所有 $j$，有 $p_j=0$。Benson 能完成一场测试，当且仅当对于所有 $j$，都有 $r_{i, j}\\leq p_j$；完成该场测试后，对于所有 $j$，$p_j$ 的值将增加 $u_{i, j}$。\n\n他可以任意选择完成测试的顺序，但每场测试只能完成一次。请帮助他计算他最多能完成多少场测试。", "inputFormat": "第一行两个正整数 $n, k$，用空格隔开。\n\n接下来 $n$ 行，第 $i$ 行包含 $k$ 个整数 $r_{i, 1}, r_{i, 2}, \\cdots, r_{i, k}$，表示完成第 $i$ 场测试的能力值下限。\n\n接下来 $n$ 行，第 $i$ 行包含 $k$ 个整数 $u_{i, 1}, u_{i, 2}, \\cdots, u_{i, k}$，表示完成第 $i$ 场测试后能力值的增加量。", "outputFormat": "输出一行一个整数，表示 Benson 最多能完成的测试数量。", "hint": "#### 样例 #1 解释\n\nBenson 只能完成第一场测试，其要求为 $[0, 0, 0]$。完成后，他的能力值将变为 $[7, 8, 2]$。此时他不能完成任何一场其余的测试，故答案为 $1$。\n\n#### 数据范围\n\n| Subtask | 分值 | 特殊限制 |\n| :-----------: | :-----------: | :-----------: |\n| $0$ | $0$ | 样例 |\n| $1$ | $12$ | $n=1$ |\n| $2$ | $28$ | $n,k\\leq 100$ |\n| $3$ | $21$ | $k=1$ |\n| $4$ | $39$ | 无 |\n\n对于 $100\\%$ 的数据：\n\n- $1\\leq n, k\\leq 10^6$\n- $n\\cdot k\\leq 10^6$\n- $0\\leq u_{i, j}, r_{i, j}\\leq 10^9$，其中 $1\\leq i\\leq n$ 且 $1\\leq j\\leq k$。\n\n注：由于洛谷限制，数据不完全按照原题分配子任务。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2023 Finals] Topical", "background": "", "description": "兔子 Benson 正在上飞行员学校！\n\n他需要完成 $n$ 场测试，由 $1\\sim n$ 编号。对于每场测试，有 $k$ 个科目。对于每个科目，Benson 有一个能力值 $p_j$。由于 Benson 还是一名新手，他对于每个科目的初始能力值均为 $0$。\n\n对于每场测试的每个科目，均有一个能力值下限 $r_{i, j}$。而为了完成第 $i$ 场测试，需要满足他每个科目的能力值都不低于这个下限。\n\n若成功完成第 $i$ 场测试，他的能力值将获得提升，且第 $j$ 个科目的能力值将提升 $u_{i, j}$。\n\n**形式化地**：初始，对于所有 $j$，有 $p_j=0$。Benson 能完成一场测试，当且仅当对于所有 $j$，都有 $r_{i, j}\\leq p_j$；完成该场测试后，对于所有 $j$，$p_j$ 的值将增加 $u_{i, j}$。\n\n他可以任意选择完成测试的顺序，但每场测试只能完成一次。请帮助他计算他最多能完成多少场测试。", "inputFormat": "第一行两个正整数 $n, k$，用空格隔开。\n\n接下来 $n$ 行，第 $i$ 行包含 $k$ 个整数 $r_{i, 1}, r_{i, 2}, \\cdots, r_{i, k}$，表示完成第 $i$ 场测试的能力值下限。\n\n接下来 $n$ 行，第 $i$ 行包含 $k$ 个整数 $u_{i, 1}, u_{i, 2}, \\cdots, u_{i, k}$，表示完成第 $i$ 场测试后能力值的增加量。", "outputFormat": "输出一行一个整数，表示 Benson 最多能完成的测试数量。", "hint": "#### 样例 #1 解释\n\nBenson 只能完成第一场测试，其要求为 $[0, 0, 0]$。完成后，他的能力值将变为 $[7, 8, 2]$。此时他不能完成任何一场其余的测试，故答案为 $1$。\n\n#### 数据范围\n\n| Subtask | 分值 | 特殊限制 |\n| :-----------: | :-----------: | :-----------: |\n| $0$ | $0$ | 样例 |\n| $1$ | $12$ | $n=1$ |\n| $2$ | $28$ | $n,k\\leq 100$ |\n| $3$ | $21$ | $k=1$ |\n| $4$ | $39$ | 无 |\n\n对于 $100\\%$ 的数据：\n\n- $1\\leq n, k\\leq 10^6$\n- $n\\cdot k\\leq 10^6$\n- $0\\leq u_{i, j}, r_{i, j}\\leq 10^9$，其中 $1\\leq i\\leq n$ 且 $1\\leq j\\leq k$。\n\n注：由于洛谷限制，数据不完全按照原题分配子任务。", "locale": "zh-CN"}}}
{"pid": "P11534", "type": "P", "difficulty": 5, "samples": [["5 3 7\n1 3\n3 5\n2 3\n0 1 2 3 4 5 6\n", "3 2 2 2 1 0 0 \n"], ["6 6 7\n1 6\n1 5\n1 4\n1 3\n1 2\n1 1\n1 2 3 4 5 6 7\n", "15 14 12 9 5 0 0 \n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "颜色段均摊（珂朵莉树 ODT）", "NOISG（新加坡）", "离线处理"], "title": "[NOISG 2023 Finals] Inspections", "background": "", "description": "兔子 Benson 正要造一架飞机！\n\nBenson 的工厂有 $n$ 个机器，由 $1\\sim n$ 编号。每台机器会工作一天，且每一天只能有一台机器工作。他需要制造 $m$ 个部件，由 $1\\sim m$ 编号。每个部件用两个整数 $l_i, r_i$ 表示，其中 $l_i\\leq r_i$。\n\n制造第 $i$ 个部件时，Benson 将依次运行编号为 $l_i, l_i+1,\\cdots,r_i$ 的机器。当一台机器结束工作，下一台机器会立即启动。此外，Benson 会依次制造这 $m$ 个部件。当一个部件制造完毕，下一个部件会立即开始制造。\n\n为了保障机器的安全，工厂设有一个检查系数 $s$。若一台机器已经连续 $s$ 或更多天没有启动，那么这次启动前必须对其进行安全检查。特别地，第一次启动某个机器时无需进行安全检查。\n\nBenson 有 $q$ 个询问 $s_1, s_2, \\cdots, s_q$。对于每个检查系数 $s_j$，请你帮助他计算完成所有部件所需的检查次数。", "inputFormat": "第一行三个正整数 $n, m, q$，用空格隔开。\n\n接下来 $m$ 行，每行两个整数 $l_i,r_i$，描述第 $i$ 个部件。\n\n接下来一行 $q$ 个整数 $s_1,s_2,\\cdots,s_q$，表示 $q$ 个检查系数。", "outputFormat": "输出一行 $q$ 个整数，表示当检查系数为 $s_j$ 时，所需检查机器的次数。", "hint": "#### 样例 #1 解释\n\nBenson 会按照如下顺序启动机器：$1,2,3,3,4,5,2,3$。\n\n第 $4$ 天启动的 $3$ 号机器连续 $0$ 天未启动；\n\n第 $7$ 天启动的 $2$ 号机器连续 $4$ 天未启动；\n\n第 $8$ 天启动的 $3$ 号机器连续 $3$ 天未启动。\n\n当检查系数为 $0$ 时，$3$ 号机器会在第 $4$ 天和第 $8$ 天被安全检查，而 $2$ 号机器会在第 $7$ 天被安全检查。\n\n当检查系数为 $2$ 时，$3$ 号机器会在第 $8$ 天被安全检查，而 $2$ 号机器会在第 $7$ 天被安全检查。\n\n#### 数据范围\n\n| Subtask | 分值 | 特殊限制 |\n| :-----------: | :-----------: | :-----------: |\n| $0$ | $0$ | 样例 |\n| $1$ | $11$ | $n,m,q\\leq 200$ |\n| $2$ | $18$ | $n,m\\leq 2000$ |\n| $3$ | $22$ | $l_i=1$ |\n| $4$ | $26$ | $m\\leq2000$ |\n| $5$ | $23$ | 无 |\n\n对于 $100\\%$ 的数据：\n\n- $1\\leq n, m,q\\leq 2\\times 10^5$\n- $1\\leq l_i\\leq r_i\\leq n$\n- $0\\leq s_j\\leq 10^{12}$\n\n注：由于洛谷限制，数据不完全按照原题分配子任务。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2023 Finals] Inspections", "background": "", "description": "兔子 Benson 正要造一架飞机！\n\nBenson 的工厂有 $n$ 个机器，由 $1\\sim n$ 编号。每台机器会工作一天，且每一天只能有一台机器工作。他需要制造 $m$ 个部件，由 $1\\sim m$ 编号。每个部件用两个整数 $l_i, r_i$ 表示，其中 $l_i\\leq r_i$。\n\n制造第 $i$ 个部件时，Benson 将依次运行编号为 $l_i, l_i+1,\\cdots,r_i$ 的机器。当一台机器结束工作，下一台机器会立即启动。此外，Benson 会依次制造这 $m$ 个部件。当一个部件制造完毕，下一个部件会立即开始制造。\n\n为了保障机器的安全，工厂设有一个检查系数 $s$。若一台机器已经连续 $s$ 或更多天没有启动，那么这次启动前必须对其进行安全检查。特别地，第一次启动某个机器时无需进行安全检查。\n\nBenson 有 $q$ 个询问 $s_1, s_2, \\cdots, s_q$。对于每个检查系数 $s_j$，请你帮助他计算完成所有部件所需的检查次数。", "inputFormat": "第一行三个正整数 $n, m, q$，用空格隔开。\n\n接下来 $m$ 行，每行两个整数 $l_i,r_i$，描述第 $i$ 个部件。\n\n接下来一行 $q$ 个整数 $s_1,s_2,\\cdots,s_q$，表示 $q$ 个检查系数。", "outputFormat": "输出一行 $q$ 个整数，表示当检查系数为 $s_j$ 时，所需检查机器的次数。", "hint": "#### 样例 #1 解释\n\nBenson 会按照如下顺序启动机器：$1,2,3,3,4,5,2,3$。\n\n第 $4$ 天启动的 $3$ 号机器连续 $0$ 天未启动；\n\n第 $7$ 天启动的 $2$ 号机器连续 $4$ 天未启动；\n\n第 $8$ 天启动的 $3$ 号机器连续 $3$ 天未启动。\n\n当检查系数为 $0$ 时，$3$ 号机器会在第 $4$ 天和第 $8$ 天被安全检查，而 $2$ 号机器会在第 $7$ 天被安全检查。\n\n当检查系数为 $2$ 时，$3$ 号机器会在第 $8$ 天被安全检查，而 $2$ 号机器会在第 $7$ 天被安全检查。\n\n#### 数据范围\n\n| Subtask | 分值 | 特殊限制 |\n| :-----------: | :-----------: | :-----------: |\n| $0$ | $0$ | 样例 |\n| $1$ | $11$ | $n,m,q\\leq 200$ |\n| $2$ | $18$ | $n,m\\leq 2000$ |\n| $3$ | $22$ | $l_i=1$ |\n| $4$ | $26$ | $m\\leq2000$ |\n| $5$ | $23$ | 无 |\n\n对于 $100\\%$ 的数据：\n\n- $1\\leq n, m,q\\leq 2\\times 10^5$\n- $1\\leq l_i\\leq r_i\\leq n$\n- $0\\leq s_j\\leq 10^{12}$\n\n注：由于洛谷限制，数据不完全按照原题分配子任务。", "locale": "zh-CN"}}}
{"pid": "P11535", "type": "P", "difficulty": 5, "samples": [["3 2\n0 2 0\n1 2\n2 3\n", "4"], ["11 12\n0 0 0 0 0 0 2 2 1 5 0\n1 2\n2 3\n3 4\n4 5\n5 6\n6 11\n1 7\n7 8\n8 9\n9 11\n1 10\n10 11\n", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "最短路", "NOISG（新加坡）"], "title": "[NOISG 2023 Finals] Airplane", "background": "", "description": "兔子 Benson 正要启动飞机！\n\n有 $n$ 块 Benson 可以飞入的区域，由 $1\\sim n$ 编号。受地形限制，进入第 $i$ 块区域时，需要保证飞机的高度不低于 $a_i$。保证 $a_1=a_n=0$。\n\n此外，由于风况复杂而 Benson 的经验尚不充足（毕竟他是只兔子），他只能在某些特定的航线上双向飞行。具体地，有 $m$ 条航线，由 $1\\sim m$ 编号，其中第 $i$ 条航线 $u_j,v_j$ 表示 Benson 可以在这两块区域间直接飞行。\n\nBenson 发现，他可以通过在直接的航线上飞行，使得这些区域两两可达。\n\n现在，Benson 在 $1$ 号区域，高度为 $0$。他希望降落在 $n$ 号区域，高度自然也为 $0$。每一分钟，Benson 可以跨过一条航线或不移动，并**同时**使飞机的高度上升 $1$、下降 $1$ 或保持不变。注意，当他到达 $i$ 区域时，必须保证飞机的高度不低于 $a_i$。\n\nBenson 想知道，从 $1$ 号区域出发，在 $n$ 号区域降落，所需的最小时间。", "inputFormat": "第一行两个正整数 $n, m$，用空格隔开。\n\n接下来一行 $n$ 个整数 $a_1, a_2,\\cdots, a_n$，表示区域的高度限制。\n\n接下来 $m$ 行，每行两个正整数 $u_j,v_j$，表示一条在 $u_j,v_j$ 间的双向航线。", "outputFormat": "一行一个整数，表示 Benson 所需的最小时间。", "hint": "#### 样例 #1 解释\n\nBenson 从 $1$ 出发，在 $3$ 降落，总共需要 $4$ 分钟：\n\n- 第 $1$ 分钟，Benson 不移动，同时高度从 $0$ 变为 $1$；\n- 第 $2$ 分钟，从 $1$ 移动到 $2$，同时高度从 $1$ 变为 $2$；\n- 第 $3$ 分钟，从 $2$ 移动到 $3$，同时高度从 $2$ 变为 $1$；\n- 第 $4$ 分钟，Benson 不移动，同时高度从 $1$ 变为 $0$。\n\n#### 数据范围\n\n| Subtask | 分值 | 特殊限制 |\n| :-----------: | :-----------: | :-----------: |\n| $0$ | $0$ | 样例 |\n| $1$ | $22$ | $m=n-1,u_j=j,v_j=j+1$ |\n| $2$ | $10$ | $n\\leq 2000$，$m\\leq 4000$，$a_i\\leq 2000$ |\n| $3$ | $31$ | $n\\leq 2000$，$m\\leq 4000$ |\n| $4$ | $37$ | 无 |\n\n对于 $100\\%$ 的数据：\n\n- $1\\leq n\\leq 2\\times 10^5$\n- $1\\leq m\\leq 4\\times 10^5$\n- $0\\leq a_i\\leq 10^8$，$a_1=a_n=0$\n- $1\\leq u_j,v_j\\leq n$，$u_j\\ne v_j$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2023 Finals] Airplane", "background": "", "description": "兔子 Benson 正要启动飞机！\n\n有 $n$ 块 Benson 可以飞入的区域，由 $1\\sim n$ 编号。受地形限制，进入第 $i$ 块区域时，需要保证飞机的高度不低于 $a_i$。保证 $a_1=a_n=0$。\n\n此外，由于风况复杂而 Benson 的经验尚不充足（毕竟他是只兔子），他只能在某些特定的航线上双向飞行。具体地，有 $m$ 条航线，由 $1\\sim m$ 编号，其中第 $i$ 条航线 $u_j,v_j$ 表示 Benson 可以在这两块区域间直接飞行。\n\nBenson 发现，他可以通过在直接的航线上飞行，使得这些区域两两可达。\n\n现在，Benson 在 $1$ 号区域，高度为 $0$。他希望降落在 $n$ 号区域，高度自然也为 $0$。每一分钟，Benson 可以跨过一条航线或不移动，并**同时**使飞机的高度上升 $1$、下降 $1$ 或保持不变。注意，当他到达 $i$ 区域时，必须保证飞机的高度不低于 $a_i$。\n\nBenson 想知道，从 $1$ 号区域出发，在 $n$ 号区域降落，所需的最小时间。", "inputFormat": "第一行两个正整数 $n, m$，用空格隔开。\n\n接下来一行 $n$ 个整数 $a_1, a_2,\\cdots, a_n$，表示区域的高度限制。\n\n接下来 $m$ 行，每行两个正整数 $u_j,v_j$，表示一条在 $u_j,v_j$ 间的双向航线。", "outputFormat": "一行一个整数，表示 Benson 所需的最小时间。", "hint": "#### 样例 #1 解释\n\nBenson 从 $1$ 出发，在 $3$ 降落，总共需要 $4$ 分钟：\n\n- 第 $1$ 分钟，Benson 不移动，同时高度从 $0$ 变为 $1$；\n- 第 $2$ 分钟，从 $1$ 移动到 $2$，同时高度从 $1$ 变为 $2$；\n- 第 $3$ 分钟，从 $2$ 移动到 $3$，同时高度从 $2$ 变为 $1$；\n- 第 $4$ 分钟，Benson 不移动，同时高度从 $1$ 变为 $0$。\n\n#### 数据范围\n\n| Subtask | 分值 | 特殊限制 |\n| :-----------: | :-----------: | :-----------: |\n| $0$ | $0$ | 样例 |\n| $1$ | $22$ | $m=n-1,u_j=j,v_j=j+1$ |\n| $2$ | $10$ | $n\\leq 2000$，$m\\leq 4000$，$a_i\\leq 2000$ |\n| $3$ | $31$ | $n\\leq 2000$，$m\\leq 4000$ |\n| $4$ | $37$ | 无 |\n\n对于 $100\\%$ 的数据：\n\n- $1\\leq n\\leq 2\\times 10^5$\n- $1\\leq m\\leq 4\\times 10^5$\n- $0\\leq a_i\\leq 10^8$，$a_1=a_n=0$\n- $1\\leq u_j,v_j\\leq n$，$u_j\\ne v_j$", "locale": "zh-CN"}}}
{"pid": "P11536", "type": "P", "difficulty": 6, "samples": [["6 2 3\n1 2\n3 4\n1 3\n1 4\n1 5\n", "NO\nYES\nNO\n"], ["10 10 10\n6 9\n6 7\n1 6\n10 10\n5 9\n3 9\n2 10\n5 7\n9 10\n5 10\n7 8\n4 7\n1 6\n2 7\n3 9\n7 7\n2 9\n4 9\n6 6\n5 7\n", "NO\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nYES\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "2023", "分治", "NOISG（新加坡）", "离线处理"], "title": "[NOISG 2023 Finals] Curtains", "background": null, "description": "兔子 Benson 正要在飞机上组织表演！\n\nBenson 有 $n$ 个舞台，由 $1\\sim n$ 编号。他有 $m$ 个幕布，由 $1\\sim m$ 编号。\n\n幕布可以下降——第 $i$ 个幕布下降后，它会遮挡住编号在 $[l_i,r_i]$ 内的舞台。\n\nBenson 将组织 $q$ 次演出，由 $1\\sim q$ 编号。第 $i$ 场演出需要使用编号在 $[s_j,e_j]$ 内的舞台。对于每场演出，Benson 想知道，是否能下降某些幕布，**恰好**遮住表演所需的舞台。\n\n**形式化地**：重新定义区间 $[x,y]$ 只包含当中的整点，即表示集合 $\\{x,x+1,\\cdots,y\\}$。给定 $m$ 个区间 $[l_i,r_i]$，每次询问给定区间 $[s_j,e_j]$，查询是否能选择一些区间，使它们的并恰好为 $[s_j,e_j]$。", "inputFormat": "第一行三个正整数 $n,m,q$，用空格隔开。\n\n接下来 $m$ 行，每行两个整数 $l_i,r_i$，表示幕布能遮挡的舞台区间。\n\n接下来 $q$ 行，每行两个整数 $s_j,e_j$，表示表演所需的舞台区间。", "outputFormat": "对于每组询问，输出一行 `YES` 或 `NO`，表示是否能下降某些幕布，使其恰好遮住表演所需的舞台。", "hint": "#### 数据范围\n\n| Subtask | 分值 | 特殊限制 |\n| :-----------: | :-----------: | :-----------: |\n| $0$ | $0$ | 样例 |\n| $1$ | $3$ | $n,m,q\\leq 200$ |\n| $2$ | $6$ | $n,m,q\\leq 2000$ |\n| $3$ | $15$ | $n\\leq 2000$ |\n| $4$ | $20$ | $s_j=1$ |\n| $5$ | $36$ | $n,m,q\\leq 10^5$ |\n| $6$ | $20$ | 无 |\n\n对于 $100\\%$ 的数据：\n\n- $1\\leq n,m,q\\leq 5\\times 10^5$\n- $1\\leq l_i\\leq r_i\\leq n$\n- $1\\leq s_j\\leq e_j\\leq n$\n\n注：由于洛谷限制，数据不完全按照原题分配子任务。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2023 Finals] Curtains", "background": null, "description": "兔子 Benson 正要在飞机上组织表演！\n\nBenson 有 $n$ 个舞台，由 $1\\sim n$ 编号。他有 $m$ 个幕布，由 $1\\sim m$ 编号。\n\n幕布可以下降——第 $i$ 个幕布下降后，它会遮挡住编号在 $[l_i,r_i]$ 内的舞台。\n\nBenson 将组织 $q$ 次演出，由 $1\\sim q$ 编号。第 $i$ 场演出需要使用编号在 $[s_j,e_j]$ 内的舞台。对于每场演出，Benson 想知道，是否能下降某些幕布，**恰好**遮住表演所需的舞台。\n\n**形式化地**：重新定义区间 $[x,y]$ 只包含当中的整点，即表示集合 $\\{x,x+1,\\cdots,y\\}$。给定 $m$ 个区间 $[l_i,r_i]$，每次询问给定区间 $[s_j,e_j]$，查询是否能选择一些区间，使它们的并恰好为 $[s_j,e_j]$。", "inputFormat": "第一行三个正整数 $n,m,q$，用空格隔开。\n\n接下来 $m$ 行，每行两个整数 $l_i,r_i$，表示幕布能遮挡的舞台区间。\n\n接下来 $q$ 行，每行两个整数 $s_j,e_j$，表示表演所需的舞台区间。", "outputFormat": "对于每组询问，输出一行 `YES` 或 `NO`，表示是否能下降某些幕布，使其恰好遮住表演所需的舞台。", "hint": "#### 数据范围\n\n| Subtask | 分值 | 特殊限制 |\n| :-----------: | :-----------: | :-----------: |\n| $0$ | $0$ | 样例 |\n| $1$ | $3$ | $n,m,q\\leq 200$ |\n| $2$ | $6$ | $n,m,q\\leq 2000$ |\n| $3$ | $15$ | $n\\leq 2000$ |\n| $4$ | $20$ | $s_j=1$ |\n| $5$ | $36$ | $n,m,q\\leq 10^5$ |\n| $6$ | $20$ | 无 |\n\n对于 $100\\%$ 的数据：\n\n- $1\\leq n,m,q\\leq 5\\times 10^5$\n- $1\\leq l_i\\leq r_i\\leq n$\n- $1\\leq s_j\\leq e_j\\leq n$\n\n注：由于洛谷限制，数据不完全按照原题分配子任务。", "locale": "zh-CN"}}}
{"pid": "P11537", "type": "P", "difficulty": 7, "samples": [], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2023", "交互题", "Special Judge", "O2优化", "NOISG（新加坡）"], "title": "[NOISG 2023 Finals] Toxic Gene", "background": "**这是一道交互题。**\n\n本题只支持 C++ 提交，建议使用 C++17。\n\n提交时不需要包含 toxic.h 头文件。\n\n为了确保程序正常编译，你需要在你提交的程序开头加上如下函数声明语句：\n\n```cpp\nint query_sample(std::vector<int> species);\nvoid answer_type(int x, char c);\n```\n\n如遇评测问题，请联系搬题人。", "description": "**建议仔细区分题面中的“种类”和“个体”。**\n\n兔子 Benson 的飞机被有害病毒侵袭了，他必须对此展开调查！\n\nBenson 发现了 $n$ 种病毒，每种病毒恰好属于三个类型之一：普通、强悍和毒害。保证至少有一种毒害病毒。\n\nBenson 必须识别每种病毒的类型。为了分析之，他将使用一个特殊的机器。每一次，他可以选择任意数量的病毒（包括 $0$）制成标本，并将其放入机器中。受机器大小的影响，每个标本里不能有超过 $300$ 个病毒。每个病毒的种类由 Benson 任意指定。\n\n标本放入机器后，其中三个类型的病毒会发生如下反应：\n\n- 当且仅当不存在毒害病毒，普通病毒可以存活。\n\n- 强悍病毒总是存活。\n\n- 毒害病毒产生有害物质并杀死强悍病毒外的所有病毒。因此，毒害病毒总是死亡。\n\n对于每个样本，机器会告诉 Benson 有多少病毒存活。由于机器分析消耗太多时间，Benson 最多只能使用 $600$ 次机器。请帮助 Benson 确定每种病毒的类型：普通、强悍或毒害。\n\n\n### 实现细节\n\n这是一道交互题。你需要实现如下函数：\n\n- `void determine_type(int n)`\n\n每个测试数据中，该函数最多被调用 $100$ 次，每次调用将对应不同的病毒组合。对于每个测试数据，你必须保证所有调用不超过时间限制和空间限制。\n\n你可以通过调用如下函数完成题目：\n\n- `int query_sample(std::vector<int> species)`\n- `void answer_type(int x, char c)`\n\n调用 `query_sample` 函数时，需传入一维数组 `species`，表示标本中你所选择的病毒种类。该数组的大小不能超过 $300$。此外，你可以假定该函数调用结束后，`species` 数组不会改变。\n\n调用 `answer_type` 函数时，需传入一个整数 $x$ 和一个字符 $c$。当你确定第 $x$ 种病毒的类型时，调用该函数，其中 $c$ 是 `R`、`S` 或 `T` 之一，分别表示普通病毒、强悍病毒和毒害病毒。你必须对每种病毒都调用该函数。\n\n下列情况可能导致你收到 Wrong Answer 反馈并立即结束评测：\n\n- `query_sample` 函数或 `answer_type` 函数的调用非法\n- `answer_type` 函数给出的病毒种类有误\n- `determine_type` 函数结束时，存在某种病毒未被 `answer_type` 确认\n- 某次 `determine_type` 函数调用过程中，`query_sample` 被调用了超过 $600$ 次\n\n请注意，题目中的交互库是**非自适应的**，即每个测试数据的答案被提前确定，且不会在交互过程中改变。", "inputFormat": "示例测试程序按如下格式读取输入数据：\n\n第一行两个整数 $tc, n$。$tc$ 表示 `determine_type` 的调用次数。\n\n接下来 $tc$ 行，每行一个字符串，由 `R`、`S` 和 `T` 组成，依次描述每种病毒的类型。", "outputFormat": "示例测试程序按如下格式输出信息：\n\n对于每次 `determine_type` 的调用，输出一行一个整数：若反馈为 Wrong Answer，输出 $-1$；否则输出 `query_sample` 的调用次数。", "hint": "### 调用示例\n\n假定 $n=5$，第一种病毒和第二种病毒是毒害病毒，第三种病毒和第四种病毒是普通病毒，第五种病毒是强悍病毒。该情况可用字符串 `TTRRS` 表达。\n\n你的函数会被这样调用：\n\n- `determine_type(5)`\n\n一个可能的交互过程如下：\n\n- `query_sample([1,2,3,4,5]) = 1`\n所有种类的病毒都被放置在标本中，只有种类 $5$ 的病毒存活，故返回 $1$。\n\n- `query_sample([3,3,4,5]) = 4`\n两个“第三种病毒”、一个“第四种病毒”和一个“第五种病毒”被放置在标本中。由于不存在毒害病毒，所有病毒均存活，故返回 $4$。\n\n此时，程序认为其已经确认所有病毒的类型，故进行了如下 $5$ 次调用：\n\n- `answer_type(1,'T')`\n- `answer_type(2,'T')`\n- `answer_type(3,'R')`\n- `answer_type(4,'R')`\n- `answer_type(5,'S')`\n\n这些函数都没有返回值。当程序正确地确认了 $n=5$ 种病毒的种类，且未使用超过 $600$ 次询问时，会在该测试点中被认为是正确的。\n\n请注意，该示例仅供展示交互过程，不一定存在合理逻辑。\n\n### 得分细则\n\n设 $t$ 表示毒害病毒的数量。保证测试数据中 $n=300$，$1\\leq t\\leq 30$。\n\n某测试点中，你的得分与所有 `determine_type` 调用中，询问次数的最大值有关，设为 $m$。\n\n- 当 $m>600$ 时，得分为 $0$。\n- 当 $340<m\\leq 600$ 时，得分为 $2+7\\times \\frac{600-m}{260}$。\n- 当 $275<m\\leq 340$ 时，得分为 $9+15\\times \\frac{340-m}{65}$。\n- 当 $190<m\\leq 275$ 时，得分为 $24+22\\times \\frac{275-m}{85}$。\n- 当 $150<m\\leq 190$ 时，得分为 $46+54\\times \\frac{190-m}{40}$。\n- 当 $m\\leq 150$ 时，得分为 $100$。\n\n### 程序测试\n\n下发文件中有两个数据可供测试。`sample1.txt` 是上文的【调用示例】，`sample2.txt` 中含有一组 $tc=100,n=300$ 的测试数据。请使用 `compile.sh` 编译并运行你的程序。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2023 Finals] Toxic Gene", "background": "**这是一道交互题。**\n\n本题只支持 C++ 提交，建议使用 C++17。\n\n提交时不需要包含 toxic.h 头文件。\n\n为了确保程序正常编译，你需要在你提交的程序开头加上如下函数声明语句：\n\n```cpp\nint query_sample(std::vector<int> species);\nvoid answer_type(int x, char c);\n```\n\n如遇评测问题，请联系搬题人。", "description": "**建议仔细区分题面中的“种类”和“个体”。**\n\n兔子 Benson 的飞机被有害病毒侵袭了，他必须对此展开调查！\n\nBenson 发现了 $n$ 种病毒，每种病毒恰好属于三个类型之一：普通、强悍和毒害。保证至少有一种毒害病毒。\n\nBenson 必须识别每种病毒的类型。为了分析之，他将使用一个特殊的机器。每一次，他可以选择任意数量的病毒（包括 $0$）制成标本，并将其放入机器中。受机器大小的影响，每个标本里不能有超过 $300$ 个病毒。每个病毒的种类由 Benson 任意指定。\n\n标本放入机器后，其中三个类型的病毒会发生如下反应：\n\n- 当且仅当不存在毒害病毒，普通病毒可以存活。\n\n- 强悍病毒总是存活。\n\n- 毒害病毒产生有害物质并杀死强悍病毒外的所有病毒。因此，毒害病毒总是死亡。\n\n对于每个样本，机器会告诉 Benson 有多少病毒存活。由于机器分析消耗太多时间，Benson 最多只能使用 $600$ 次机器。请帮助 Benson 确定每种病毒的类型：普通、强悍或毒害。\n\n\n### 实现细节\n\n这是一道交互题。你需要实现如下函数：\n\n- `void determine_type(int n)`\n\n每个测试数据中，该函数最多被调用 $100$ 次，每次调用将对应不同的病毒组合。对于每个测试数据，你必须保证所有调用不超过时间限制和空间限制。\n\n你可以通过调用如下函数完成题目：\n\n- `int query_sample(std::vector<int> species)`\n- `void answer_type(int x, char c)`\n\n调用 `query_sample` 函数时，需传入一维数组 `species`，表示标本中你所选择的病毒种类。该数组的大小不能超过 $300$。此外，你可以假定该函数调用结束后，`species` 数组不会改变。\n\n调用 `answer_type` 函数时，需传入一个整数 $x$ 和一个字符 $c$。当你确定第 $x$ 种病毒的类型时，调用该函数，其中 $c$ 是 `R`、`S` 或 `T` 之一，分别表示普通病毒、强悍病毒和毒害病毒。你必须对每种病毒都调用该函数。\n\n下列情况可能导致你收到 Wrong Answer 反馈并立即结束评测：\n\n- `query_sample` 函数或 `answer_type` 函数的调用非法\n- `answer_type` 函数给出的病毒种类有误\n- `determine_type` 函数结束时，存在某种病毒未被 `answer_type` 确认\n- 某次 `determine_type` 函数调用过程中，`query_sample` 被调用了超过 $600$ 次\n\n请注意，题目中的交互库是**非自适应的**，即每个测试数据的答案被提前确定，且不会在交互过程中改变。", "inputFormat": "示例测试程序按如下格式读取输入数据：\n\n第一行两个整数 $tc, n$。$tc$ 表示 `determine_type` 的调用次数。\n\n接下来 $tc$ 行，每行一个字符串，由 `R`、`S` 和 `T` 组成，依次描述每种病毒的类型。", "outputFormat": "示例测试程序按如下格式输出信息：\n\n对于每次 `determine_type` 的调用，输出一行一个整数：若反馈为 Wrong Answer，输出 $-1$；否则输出 `query_sample` 的调用次数。", "hint": "### 调用示例\n\n假定 $n=5$，第一种病毒和第二种病毒是毒害病毒，第三种病毒和第四种病毒是普通病毒，第五种病毒是强悍病毒。该情况可用字符串 `TTRRS` 表达。\n\n你的函数会被这样调用：\n\n- `determine_type(5)`\n\n一个可能的交互过程如下：\n\n- `query_sample([1,2,3,4,5]) = 1`\n所有种类的病毒都被放置在标本中，只有种类 $5$ 的病毒存活，故返回 $1$。\n\n- `query_sample([3,3,4,5]) = 4`\n两个“第三种病毒”、一个“第四种病毒”和一个“第五种病毒”被放置在标本中。由于不存在毒害病毒，所有病毒均存活，故返回 $4$。\n\n此时，程序认为其已经确认所有病毒的类型，故进行了如下 $5$ 次调用：\n\n- `answer_type(1,'T')`\n- `answer_type(2,'T')`\n- `answer_type(3,'R')`\n- `answer_type(4,'R')`\n- `answer_type(5,'S')`\n\n这些函数都没有返回值。当程序正确地确认了 $n=5$ 种病毒的种类，且未使用超过 $600$ 次询问时，会在该测试点中被认为是正确的。\n\n请注意，该示例仅供展示交互过程，不一定存在合理逻辑。\n\n### 得分细则\n\n设 $t$ 表示毒害病毒的数量。保证测试数据中 $n=300$，$1\\leq t\\leq 30$。\n\n某测试点中，你的得分与所有 `determine_type` 调用中，询问次数的最大值有关，设为 $m$。\n\n- 当 $m>600$ 时，得分为 $0$。\n- 当 $340<m\\leq 600$ 时，得分为 $2+7\\times \\frac{600-m}{260}$。\n- 当 $275<m\\leq 340$ 时，得分为 $9+15\\times \\frac{340-m}{65}$。\n- 当 $190<m\\leq 275$ 时，得分为 $24+22\\times \\frac{275-m}{85}$。\n- 当 $150<m\\leq 190$ 时，得分为 $46+54\\times \\frac{190-m}{40}$。\n- 当 $m\\leq 150$ 时，得分为 $100$。\n\n### 程序测试\n\n下发文件中有两个数据可供测试。`sample1.txt` 是上文的【调用示例】，`sample2.txt` 中含有一组 $tc=100,n=300$ 的测试数据。请使用 `compile.sh` 编译并运行你的程序。", "locale": "zh-CN"}}}
{"pid": "P11538", "type": "P", "difficulty": 2, "samples": [["5 3 7\n3 1 4\n3 1 1 1 2 3 1\n", "5\n4\nerror!\nerror!\n2\nerror!\nerror!\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["Code+"], "title": "[Code+#5] 棋子", "background": "**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。", "description": "棋盘从左到右被分割成 $n(n\\le 1000)$ 个格子，从左到右编号为 $1,2,\\dots,n$。棋盘上有 $m(m\\le n)$ 个棋子，编号为 $1,2,\\dots,m$ ，编号为 $i$ 的棋子刚开始摆放在编号为 $p_i$ 的格子上，一个格子最多摆放一个棋子。每次操作小R可以选择一个棋子，将它移动到它右边第一个空着的格子中，如果它右边没有空着的格子了，那么这就是一个非法操作，执行一次非法操作不会对棋盘有任何改变。小 R 依次做了 $k$ 次操作，如果一次操作是合法的，你需要输出这颗棋子移动到的格子的编号，如果是非法的，你需要输出 `error!`。", "inputFormat": "第一行三个整数 $n$、$m$、$k$ ，表示格子数、棋子数和操作数。\n\n第二行 $m$ 个正整数，第 $i$ 个正整数表示 $p_i$ ，即第 $i$ 个棋子的初始位置。\n\n第三行 $k$ 个正整数，第 $i$ 个正整数表示 $x_i$ ，即第 $i$ 次操作选定的棋子的编号。", "outputFormat": "输出 $k$ 行，第$i$行表示第$i$次操作的结果。对于合法操作，输出棋子移动到的位置，对于非法操作，输出一行 `error!`。", "hint": "**数据范围：**\n\n$\\def\\arraystretch{1.21}\n\\begin{array}{|c|c|c|}\\hline\n\\bold{\\small{子任务}}&\\textbf{score}&\\textbf{constraints}\\\\\\hline\n\\text{A}&30&m=1\\\\\\hline\n\\text{B}&70&\\small{无特殊限制}\\\\\\hline\n\\end{array}$\n\n对于所有数据，保证 $1\\le m<n\\le1000$，$1\\le k\\le10000$，$1\\le p_i\\le n,1\\le x_i\\le m$，$p_i$ 互不相等。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Code+#5] 棋子", "background": "**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。", "description": "棋盘从左到右被分割成 $n(n\\le 1000)$ 个格子，从左到右编号为 $1,2,\\dots,n$。棋盘上有 $m(m\\le n)$ 个棋子，编号为 $1,2,\\dots,m$ ，编号为 $i$ 的棋子刚开始摆放在编号为 $p_i$ 的格子上，一个格子最多摆放一个棋子。每次操作小R可以选择一个棋子，将它移动到它右边第一个空着的格子中，如果它右边没有空着的格子了，那么这就是一个非法操作，执行一次非法操作不会对棋盘有任何改变。小 R 依次做了 $k$ 次操作，如果一次操作是合法的，你需要输出这颗棋子移动到的格子的编号，如果是非法的，你需要输出 `error!`。", "inputFormat": "第一行三个整数 $n$、$m$、$k$ ，表示格子数、棋子数和操作数。\n\n第二行 $m$ 个正整数，第 $i$ 个正整数表示 $p_i$ ，即第 $i$ 个棋子的初始位置。\n\n第三行 $k$ 个正整数，第 $i$ 个正整数表示 $x_i$ ，即第 $i$ 次操作选定的棋子的编号。", "outputFormat": "输出 $k$ 行，第$i$行表示第$i$次操作的结果。对于合法操作，输出棋子移动到的位置，对于非法操作，输出一行 `error!`。", "hint": "**数据范围：**\n\n$\\def\\arraystretch{1.21}\n\\begin{array}{|c|c|c|}\\hline\n\\bold{\\small{子任务}}&\\textbf{score}&\\textbf{constraints}\\\\\\hline\n\\text{A}&30&m=1\\\\\\hline\n\\text{B}&70&\\small{无特殊限制}\\\\\\hline\n\\end{array}$\n\n对于所有数据，保证 $1\\le m<n\\le1000$，$1\\le k\\le10000$，$1\\le p_i\\le n,1\\le x_i\\le m$，$p_i$ 互不相等。\n", "locale": "zh-CN"}}}
{"pid": "P11539", "type": "P", "difficulty": 6, "samples": [["4\n4 3 1 2", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["递归", "Catalan 数", "Code+"], "title": "[Code+#5] 方案计数", "background": "**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。\n\n", "description": "小 V 刚考完拓扑，闭区间套让他有点自闭，所以他决定把这一场 CP 安排一下。\n\n我们首先选定一个数据范围 $N$，这里 $N$ 是一个整数。\n\n考虑如下的函数：\n\n```cpp\n// rand_int(l, r) 返回闭区间 [l, r] 中的一个随机整数\nvector<int> ans;\n\nvoid solve(int l, int r) {\n    if (l == r) {\n        ans.push_back(r);\n        return ;\n    }\n    int m = rand_int(l, r - 1);\n    if (rand_int(0, 1) == 0) {\n        solve(l, m);\n        solve(m + 1, r);\n    } else {\n        solve(m + 1, r);\n        solve(l, m);\n    }\n}\n```\n\n我们初始令 $\\texttt{ans}$ 为空，那么调用 $\\texttt{solve(1, N)}$ 之后，$\\texttt{ans}$ 里会存储一个排列。\n\n现在的问题是，给定排列 $P$，问有多少种不同的随机数生成方法可以使这个 $\\texttt{ans}$ 中存储的排列恰好为 $P$。\n\n定义两种随机数生成方式是不同的，当且仅当在函数某次调用 $\\texttt{rand\\_int}$ 时，随机数生成器返回了不同的数。\n\n方案数对 $998244353$ 取模。", "inputFormat": "第一行一个正整数 $N$，保证 $N\\le 5\\times 10^5$。\n\n接下来一行 $N$ 个整数，描述排列 $\\{P_i\\}$。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "**数据范围：**\n\n$\\def\\arraystretch{1.21}\n\\begin{array}{|c|c|c|}\\hline\n\\bold{\\small{子任务}}&\\textbf{score}&\\textbf{constraints}\\\\\\hline\n\\text{A}&20&N\\le5000,P_i=N-i+1\\\\\\hline\n\\text{B}&10&B\\le10^5,P_i=N-i+1\\\\\\hline\n\\text{C}&30&N\\le10^5\\\\\\hline\n\\text{D}&40&N\\le5\\times10^5\\\\\\hline\n\\end{array}$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Code+#5] 方案计数", "background": "**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。\n\n", "description": "小 V 刚考完拓扑，闭区间套让他有点自闭，所以他决定把这一场 CP 安排一下。\n\n我们首先选定一个数据范围 $N$，这里 $N$ 是一个整数。\n\n考虑如下的函数：\n\n```cpp\n// rand_int(l, r) 返回闭区间 [l, r] 中的一个随机整数\nvector<int> ans;\n\nvoid solve(int l, int r) {\n    if (l == r) {\n        ans.push_back(r);\n        return ;\n    }\n    int m = rand_int(l, r - 1);\n    if (rand_int(0, 1) == 0) {\n        solve(l, m);\n        solve(m + 1, r);\n    } else {\n        solve(m + 1, r);\n        solve(l, m);\n    }\n}\n```\n\n我们初始令 $\\texttt{ans}$ 为空，那么调用 $\\texttt{solve(1, N)}$ 之后，$\\texttt{ans}$ 里会存储一个排列。\n\n现在的问题是，给定排列 $P$，问有多少种不同的随机数生成方法可以使这个 $\\texttt{ans}$ 中存储的排列恰好为 $P$。\n\n定义两种随机数生成方式是不同的，当且仅当在函数某次调用 $\\texttt{rand\\_int}$ 时，随机数生成器返回了不同的数。\n\n方案数对 $998244353$ 取模。", "inputFormat": "第一行一个正整数 $N$，保证 $N\\le 5\\times 10^5$。\n\n接下来一行 $N$ 个整数，描述排列 $\\{P_i\\}$。", "outputFormat": "输出一行一个整数，表示答案。", "hint": "**数据范围：**\n\n$\\def\\arraystretch{1.21}\n\\begin{array}{|c|c|c|}\\hline\n\\bold{\\small{子任务}}&\\textbf{score}&\\textbf{constraints}\\\\\\hline\n\\text{A}&20&N\\le5000,P_i=N-i+1\\\\\\hline\n\\text{B}&10&B\\le10^5,P_i=N-i+1\\\\\\hline\n\\text{C}&30&N\\le10^5\\\\\\hline\n\\text{D}&40&N\\le5\\times10^5\\\\\\hline\n\\end{array}$", "locale": "zh-CN"}}}
{"pid": "P11540", "type": "P", "difficulty": 3, "samples": [["4\n0 1 0\n5 6\n5 7\n6 1\n6 2\n7 3\n7 4\n4 2 3 1\n", "1011"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["Code+"], "title": "[Code+#5] 逻辑树", "background": "**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。\n\n", "description": "有一棵树，叫逻辑树。\n\n这个树有根，有 $2N-1$ 个节点，其中 $N$ 个叶子，每个非叶节点恰好有两个孩子。\n\n每个叶子上有一个 01 变量，它的取值可能为 True 或 False。每个非叶节点上有一个逻辑运算符，这个运算可能为 AND 或者 OR。\n\n一个非叶节点的取值定义为它两个儿子的取值，作这个节点上的运算得到的结果。\n\n有一个黑恶势力想知道这个树的根节点的取值，他准备了一个长度为 $N$ 的询问序列 $\\{P_i\\}$，每个叶子在这个序列中恰好出现一次。\n\n黑恶势力会依次询问这些叶子的值，**但是**，如果他发现某一次询问是不必要的，那么他会跳过这个无意义的询问（为了帮助理解，考虑 x AND y 在我们知道 x 为 False 之后，不必知道 y 的值就可推算 x AND y 的值）。\n\n当然，邪恶总是能战胜正义，黑恶势力总能达到他的目的。但是我们可以拖慢他的节奏，你现在可以安排每个叶子的权值，使得黑恶势力询问的次数尽可能多，在此基础上，我们希望这个树的根节点取值尽量为 True。\n\n请你计算一组解，任何一种合法方案都是可以接受的。", "inputFormat": "第一行一个整数 $N$，意义如题面所示。\n\n接下来一行 $N-1$ 个整数，第 $i$ 个数代表节点 $N+i$ 上的运算符，其中 $0$ 表示 `AND`，$1$ 表示 `OR`。\n\n接下来 $2N-2$ 行，每行两个整数，描述一条边。\n\n最后一行 $N$ 个整数，表示黑恶势力的询问序列。\n\n你可以认为 $1\\sim N$ 是叶子，$N+1\\sim 2N-1$ 是非叶节点，且 $N+1$ 是根，输入数据保证每个非叶节点有两个孩子。", "outputFormat": "输出一个长度为 $N$ 的 01串 $S$，其中 $S_i$ 表示第 $i$ 个叶子的取值，$0$ 为 False, $1$ 为 True.", "hint": "**数据范围：**\n\n$\\def\\arraystretch{1.21}\n\\begin{array}{|c|c|c|}\\hline\n\\bold{\\small{子任务}}&\\textbf{score}&\\textbf{constraints}\\\\\\hline\n\\text{A}&40&\\small{树的高度不超过 50}\\\\\\hline\n\\text{B}&60&\\small{无特殊限制}\\\\\\hline\n\\end{array}$\n\n对于所有数据，$N\\le 5\\times 10^5$。\n\n对于所有数据，保证 $1\\le m<n\\le1000$，$1\\le k\\le10000$，$1\\le p_i\\le n,1\\le x_i\\le m$，$p_i$ 互不相等。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Code+#5] 逻辑树", "background": "**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。\n\n", "description": "有一棵树，叫逻辑树。\n\n这个树有根，有 $2N-1$ 个节点，其中 $N$ 个叶子，每个非叶节点恰好有两个孩子。\n\n每个叶子上有一个 01 变量，它的取值可能为 True 或 False。每个非叶节点上有一个逻辑运算符，这个运算可能为 AND 或者 OR。\n\n一个非叶节点的取值定义为它两个儿子的取值，作这个节点上的运算得到的结果。\n\n有一个黑恶势力想知道这个树的根节点的取值，他准备了一个长度为 $N$ 的询问序列 $\\{P_i\\}$，每个叶子在这个序列中恰好出现一次。\n\n黑恶势力会依次询问这些叶子的值，**但是**，如果他发现某一次询问是不必要的，那么他会跳过这个无意义的询问（为了帮助理解，考虑 x AND y 在我们知道 x 为 False 之后，不必知道 y 的值就可推算 x AND y 的值）。\n\n当然，邪恶总是能战胜正义，黑恶势力总能达到他的目的。但是我们可以拖慢他的节奏，你现在可以安排每个叶子的权值，使得黑恶势力询问的次数尽可能多，在此基础上，我们希望这个树的根节点取值尽量为 True。\n\n请你计算一组解，任何一种合法方案都是可以接受的。", "inputFormat": "第一行一个整数 $N$，意义如题面所示。\n\n接下来一行 $N-1$ 个整数，第 $i$ 个数代表节点 $N+i$ 上的运算符，其中 $0$ 表示 `AND`，$1$ 表示 `OR`。\n\n接下来 $2N-2$ 行，每行两个整数，描述一条边。\n\n最后一行 $N$ 个整数，表示黑恶势力的询问序列。\n\n你可以认为 $1\\sim N$ 是叶子，$N+1\\sim 2N-1$ 是非叶节点，且 $N+1$ 是根，输入数据保证每个非叶节点有两个孩子。", "outputFormat": "输出一个长度为 $N$ 的 01串 $S$，其中 $S_i$ 表示第 $i$ 个叶子的取值，$0$ 为 False, $1$ 为 True.", "hint": "**数据范围：**\n\n$\\def\\arraystretch{1.21}\n\\begin{array}{|c|c|c|}\\hline\n\\bold{\\small{子任务}}&\\textbf{score}&\\textbf{constraints}\\\\\\hline\n\\text{A}&40&\\small{树的高度不超过 50}\\\\\\hline\n\\text{B}&60&\\small{无特殊限制}\\\\\\hline\n\\end{array}$\n\n对于所有数据，$N\\le 5\\times 10^5$。\n\n对于所有数据，保证 $1\\le m<n\\le1000$，$1\\le k\\le10000$，$1\\le p_i\\le n,1\\le x_i\\le m$，$p_i$ 互不相等。\n", "locale": "zh-CN"}}}
{"pid": "P11541", "type": "P", "difficulty": 5, "samples": [["7 3\n1 2\n1 3\n3 4\n4 5\n3 6\n2 7\n5 6 4\n1 4 3\n4 6 4\n", "1 2 3 1 1 4 5\n"], ["见附件 down\\2.in", "见附件 down\\2.out "]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["Code+"], "title": "[Code+#5] 路路的图", "background": "**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。", "description": "路路是一个喜欢强连通分量的孩子。他非常喜欢对一张图求出其强连通分量。他认为这个操作是好的。但他并不是总有能力完成这件事。现在，路路给你一张图 $G$，希望你帮他求出这张图的每个强连通分量。由于这张图的边数特别的多，他不会直接输入这张图，而是告诉你它的构造方法：\n\n给出一棵 $n$ 个点（编号为 $1$ 到 $n$）的无根树 $T$ 和 $m$ 条指令 $(a_i,b_i,c_i)$。图 $G$ 刚开始 $n$ 个点，编号也为 $1$ 到 $n$，并且没有边。对于每一条指令 $(a_i,b_i,c_i)$，如果在树上 $b_i$ 到 $x$ 的最短路径长度（经过的边数）不超过 $c_i$，那么你会在 $G$ 中加入一条从 $a_i$ 连向 $x$ 的有向边。\n\n请你帮帮他。", "inputFormat": "第一行两个整数 $n$、$m$；\n\n接下来 $n-1$ 行，每行两个整数 $a$、$b$，表示树 $T$ 中的一条边 $(a,b)$；\n\n接下来 $m$ 行，每行三个整数 $a_i,b_i,c_i$，表示每一条指令。", "outputFormat": "你将会需要输出 $n$ 个整数。其中第 $i$ 个整数 $p_i$ 这么输出：\n\n- $p_1 = 1$；\n\n- 如果点 $i$ 和点 $1$、$2$、……、$(i-1)$ 都不在同一个强连通分量中，那么 $p_i = 1 + \\max\\{p_1,p_2,\\cdots,p_{i-1}\\}$；\n\n- 否则，假设 $i$ 和点 $j< i$ 在一个强连通分量中，并且和点 $1$、$2$、……、$(j-1)$ 都不在同一个强连通分量中，那么 $p_i = p_j$。", "hint": "**数据范围：**\n\n$\\def\\arraystretch{1.21}\n\\begin{array}{|c|c|c|}\\hline\n\\bold{\\small{子任务}}&\\textbf{score}&\\textbf{constraints}\\\\\\hline\n\\text{A}&30&c_i\\le n\\le 50,m\\le 100\\\\\\hline\n\\text{B}&30&c_i\\le50\\\\\\hline\n\\text{C}&30&\\small{无特殊限制}\\\\\\hline\n\\end{array}$\n\n对于所有数据，$n\\le 10^5,m\\le 2\\times 10^5, c_i\\le n$。\n\n**样例解释：**\n\n第一组指令往 $G$ 中加入了从 $5$ 连向每个点的有向边；\n\n第二组指令往 $G$ 中加入了从 $1$ 连向 $1,2,3,4,5,6$ 的有向边；\n\n第三组指令往 $G$ 中加入了从 $4$ 连向每个点的有向边；\n\n最后的强连通分量为 $\\{1,4,5\\}$、$\\{2\\}$、$\\{3\\}$、$\\{6\\}$、$\\{7\\}$。\n\n**注**：由于数据缺失，仅有 $9$ 组测试点。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Code+#5] 路路的图", "background": "**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。", "description": "路路是一个喜欢强连通分量的孩子。他非常喜欢对一张图求出其强连通分量。他认为这个操作是好的。但他并不是总有能力完成这件事。现在，路路给你一张图 $G$，希望你帮他求出这张图的每个强连通分量。由于这张图的边数特别的多，他不会直接输入这张图，而是告诉你它的构造方法：\n\n给出一棵 $n$ 个点（编号为 $1$ 到 $n$）的无根树 $T$ 和 $m$ 条指令 $(a_i,b_i,c_i)$。图 $G$ 刚开始 $n$ 个点，编号也为 $1$ 到 $n$，并且没有边。对于每一条指令 $(a_i,b_i,c_i)$，如果在树上 $b_i$ 到 $x$ 的最短路径长度（经过的边数）不超过 $c_i$，那么你会在 $G$ 中加入一条从 $a_i$ 连向 $x$ 的有向边。\n\n请你帮帮他。", "inputFormat": "第一行两个整数 $n$、$m$；\n\n接下来 $n-1$ 行，每行两个整数 $a$、$b$，表示树 $T$ 中的一条边 $(a,b)$；\n\n接下来 $m$ 行，每行三个整数 $a_i,b_i,c_i$，表示每一条指令。", "outputFormat": "你将会需要输出 $n$ 个整数。其中第 $i$ 个整数 $p_i$ 这么输出：\n\n- $p_1 = 1$；\n\n- 如果点 $i$ 和点 $1$、$2$、……、$(i-1)$ 都不在同一个强连通分量中，那么 $p_i = 1 + \\max\\{p_1,p_2,\\cdots,p_{i-1}\\}$；\n\n- 否则，假设 $i$ 和点 $j< i$ 在一个强连通分量中，并且和点 $1$、$2$、……、$(j-1)$ 都不在同一个强连通分量中，那么 $p_i = p_j$。", "hint": "**数据范围：**\n\n$\\def\\arraystretch{1.21}\n\\begin{array}{|c|c|c|}\\hline\n\\bold{\\small{子任务}}&\\textbf{score}&\\textbf{constraints}\\\\\\hline\n\\text{A}&30&c_i\\le n\\le 50,m\\le 100\\\\\\hline\n\\text{B}&30&c_i\\le50\\\\\\hline\n\\text{C}&30&\\small{无特殊限制}\\\\\\hline\n\\end{array}$\n\n对于所有数据，$n\\le 10^5,m\\le 2\\times 10^5, c_i\\le n$。\n\n**样例解释：**\n\n第一组指令往 $G$ 中加入了从 $5$ 连向每个点的有向边；\n\n第二组指令往 $G$ 中加入了从 $1$ 连向 $1,2,3,4,5,6$ 的有向边；\n\n第三组指令往 $G$ 中加入了从 $4$ 连向每个点的有向边；\n\n最后的强连通分量为 $\\{1,4,5\\}$、$\\{2\\}$、$\\{3\\}$、$\\{6\\}$、$\\{7\\}$。\n\n**注**：由于数据缺失，仅有 $9$ 组测试点。", "locale": "zh-CN"}}}
{"pid": "P11542", "type": "P", "difficulty": 1, "samples": [["3\n3 -4 5\n", "Wo jue de OK"], ["42\n210 42 177 -351 -349 171 638 413 921 149 -929 -230 -706 73 933 741 28 -988 -885 -761 -988 383 562 -192 597 45 226 946 -12 200 -75 -819 -825 -989 617 -106 409 -430 -666 -764 -37 241\n", "Wo jue de bu tai xing\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["Code+"], "title": "[Code+#5] 有人吗？", "background": "**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。", "description": "企鹅高中有很多学生，自然管理起来也就非常麻烦。学校的教务处想要随时统计学校里面有多少个学生，但是他们只有很多来自保卫处的人员来往报告。每个报告的内容为进入了多少个学生，或者出去了多少个学生。所有的报告是非常混乱的，不知道到底哪个报告更早，哪个报告更晚。\n\n现在教务处的企鹅老师想要知道这些报告到底靠不靠谱。这些报告靠谱，当且仅当存在一种对这些报告的排序方式，使得随时随地学校里的学生数量不为负数。当然我们认为初始情况下，学校的学生数量为 $0$。\n\n现在你需要写份程序，自动判断这些报告靠不靠谱。", "inputFormat": "\n每个测试点只有一组数据。\n输入的第一行包含一个正整数 $n$，表示报告的总份数。\n\n接下来一行一共有 $n$ 个由空格隔开的整数，依次表示每份报告的内容。如果数值为正，则表示进入的学生数量。如果数值为负，则表示有学生出去，出去的学生数量为这个数值的绝对值。\n", "outputFormat": "如果这些报告靠谱，输出一个字符串 `Wo jue de OK`。\n\n如果这些报告不靠谱，输出一个字符串 `Wo jue de bu tai xing`。", "hint": "**数据范围：**\n\n对于所有测试点，$n \\le 10^5$，\n\n第二行所有整数的绝对值 $\\le1000$。\n\n**样例解释：**\n\n对于样例一，我们可以认为报告的先后顺序为 $3$，$2$，$1$。\n一开始学校里有 $0$ 位同学。\n得到第 $3$ 份报告后，可以推出现在有 $5$ 位同学。\n得到第 $2$ 份报告后，可以推出现在有 $1$ 位同学。\n得到第 $1$ 份报告后，可以推出现在有 $4$ 位同学。\n所以这些报告靠谱。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Code+#5] 有人吗？", "background": "**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。", "description": "企鹅高中有很多学生，自然管理起来也就非常麻烦。学校的教务处想要随时统计学校里面有多少个学生，但是他们只有很多来自保卫处的人员来往报告。每个报告的内容为进入了多少个学生，或者出去了多少个学生。所有的报告是非常混乱的，不知道到底哪个报告更早，哪个报告更晚。\n\n现在教务处的企鹅老师想要知道这些报告到底靠不靠谱。这些报告靠谱，当且仅当存在一种对这些报告的排序方式，使得随时随地学校里的学生数量不为负数。当然我们认为初始情况下，学校的学生数量为 $0$。\n\n现在你需要写份程序，自动判断这些报告靠不靠谱。", "inputFormat": "\n每个测试点只有一组数据。\n输入的第一行包含一个正整数 $n$，表示报告的总份数。\n\n接下来一行一共有 $n$ 个由空格隔开的整数，依次表示每份报告的内容。如果数值为正，则表示进入的学生数量。如果数值为负，则表示有学生出去，出去的学生数量为这个数值的绝对值。\n", "outputFormat": "如果这些报告靠谱，输出一个字符串 `Wo jue de OK`。\n\n如果这些报告不靠谱，输出一个字符串 `Wo jue de bu tai xing`。", "hint": "**数据范围：**\n\n对于所有测试点，$n \\le 10^5$，\n\n第二行所有整数的绝对值 $\\le1000$。\n\n**样例解释：**\n\n对于样例一，我们可以认为报告的先后顺序为 $3$，$2$，$1$。\n一开始学校里有 $0$ 位同学。\n得到第 $3$ 份报告后，可以推出现在有 $5$ 位同学。\n得到第 $2$ 份报告后，可以推出现在有 $1$ 位同学。\n得到第 $1$ 份报告后，可以推出现在有 $4$ 位同学。\n所以这些报告靠谱。", "locale": "zh-CN"}}}
{"pid": "P11543", "type": "P", "difficulty": 4, "samples": [["3 3\n1 0 1\n1 1 0\n0 1 0\n1 1 0\n0 1 0\n1 1 0\n", "Koyi"], ["6 6\n0 0 1 0 0 1\n1 0 1 1 0 1\n1 0 1 0 0 0\n0 1 1 0 1 0\n1 0 1 0 0 1\n1 1 1 0 1 0\n1 1 0 1 0 0\n0 1 0 0 0 0\n0 1 0 1 0 1\n1 0 0 1 1 1\n1 0 1 0 1 1\n0 0 0 1 1 1\n", "Koyi"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["Code+"], "title": "[Code+#5] 我有矩阵，你有吗？", "background": "**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。", "description": "企鹅豆豆手里有两个 $01$ 矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$。他可以进行两种操作：\n\n1. 选择 $\\mathbf{A}$ 矩阵的一行，然后把这一行的 $0$ 变成 $1$，把 $1$ 变成 $0$。\n2. 选择 $\\mathbf{A}$ 矩阵的一列，然后把这一列的 $0$ 变成 $1$，把 $1$ 变成 $0$。\n\n现在他想知道能不能把 $\\mathbf{A}$ 矩阵通过以上操作变成 $\\mathbf{B}$ 矩阵。保证 $\\mathbf{A}$ 矩阵和 $\\mathbf{B}$ 矩阵的大小一致。\n", "inputFormat": "每个测试点只有一组数据。\n\n输入的第一行包含两个正整数 $n$ 和 $m$，表示 $\\mathbf{A}$ 矩阵的行数。\n接下来 $n$ 行，每行 $m$ 个由空格隔开的整数，表示矩阵 $\\mathbf{A}$。保证矩阵中只有 $0$ 或者 $1$。\n接下来 $n$ 行，每行 $m$ 个由空格隔开的整数，表示矩阵 $\\mathbf{B}$。保证矩阵中只有 $0$ 或者 $1$。\n", "outputFormat": "如果矩阵 $\\mathbf{A}$ 通过以上两种操作可以变成矩阵 $\\mathbf{B}$，输出 `Koyi`，否则输出 `Budexing`。", "hint": "**数据范围：**\n\n对于所有数据，$n \\le 1000,m \\le 1000$。\n\n**样例解释：**\n\n对于样例一，依次对于第一行和第一列分别执行操作 $1$ 和操作 $2$ 即可。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Code+#5] 我有矩阵，你有吗？", "background": "**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。", "description": "企鹅豆豆手里有两个 $01$ 矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$。他可以进行两种操作：\n\n1. 选择 $\\mathbf{A}$ 矩阵的一行，然后把这一行的 $0$ 变成 $1$，把 $1$ 变成 $0$。\n2. 选择 $\\mathbf{A}$ 矩阵的一列，然后把这一列的 $0$ 变成 $1$，把 $1$ 变成 $0$。\n\n现在他想知道能不能把 $\\mathbf{A}$ 矩阵通过以上操作变成 $\\mathbf{B}$ 矩阵。保证 $\\mathbf{A}$ 矩阵和 $\\mathbf{B}$ 矩阵的大小一致。\n", "inputFormat": "每个测试点只有一组数据。\n\n输入的第一行包含两个正整数 $n$ 和 $m$，表示 $\\mathbf{A}$ 矩阵的行数。\n接下来 $n$ 行，每行 $m$ 个由空格隔开的整数，表示矩阵 $\\mathbf{A}$。保证矩阵中只有 $0$ 或者 $1$。\n接下来 $n$ 行，每行 $m$ 个由空格隔开的整数，表示矩阵 $\\mathbf{B}$。保证矩阵中只有 $0$ 或者 $1$。\n", "outputFormat": "如果矩阵 $\\mathbf{A}$ 通过以上两种操作可以变成矩阵 $\\mathbf{B}$，输出 `Koyi`，否则输出 `Budexing`。", "hint": "**数据范围：**\n\n对于所有数据，$n \\le 1000,m \\le 1000$。\n\n**样例解释：**\n\n对于样例一，依次对于第一行和第一列分别执行操作 $1$ 和操作 $2$ 即可。\n", "locale": "zh-CN"}}}
{"pid": "P11544", "type": "P", "difficulty": 6, "samples": [["2\n0 0\n0 1", "3.14159265358979326666666666666233333333"], ["3\n0 1\n3 0\n2 2\n", "11.99210886393877709133\n"], ["见附件", "见附件"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["Special Judge", "Code+"], "title": "[Code+#5] 法师", "background": "**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。", "description": "传说在 $100000$ 年前，有大量陨石即将撞击企鹅大陆。散布在企鹅大陆各个地点的企鹅法师们张开法阵保护企鹅大陆。\n\n每两个法师之间，会生成一个以这两个法师连线为直径的圆形法阵。能被保护的区域就是法阵的并。\n\n每个法师的坐标可以使用一组非负整数 $\\left(X, Y\\right)$ 表示。不存在两个法师在同一个位置。\n\n读完这个故事，企鹅豆豆想到一个问题——能被保护的区域的外侧周长有多长？\n", "inputFormat": "每个测试点只有一组数据。\n\n输入的第一行包含一个正整数 $n$，表示法师人数。\n\n接下来 $n$ 行每行两个非负整数，表示一位法师的坐标位置。保证数值不超过 $10^9$。\n", "outputFormat": "输出一个小数，表示被保护的区域的周长。", "hint": "**数据范围：**\n\n对于所有数据，$2 \\le n \\le 10^5$。\n\n**样例解释：**\n\n对于样例一，显然被保护面积是以这两点连线作为直径的圆形。根据圆的周长计算公式即可得出答案。而且你与标算的相对误差不超过 $10^{-7}$ 即被认为正确。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Code+#5] 法师", "background": "**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。", "description": "传说在 $100000$ 年前，有大量陨石即将撞击企鹅大陆。散布在企鹅大陆各个地点的企鹅法师们张开法阵保护企鹅大陆。\n\n每两个法师之间，会生成一个以这两个法师连线为直径的圆形法阵。能被保护的区域就是法阵的并。\n\n每个法师的坐标可以使用一组非负整数 $\\left(X, Y\\right)$ 表示。不存在两个法师在同一个位置。\n\n读完这个故事，企鹅豆豆想到一个问题——能被保护的区域的外侧周长有多长？\n", "inputFormat": "每个测试点只有一组数据。\n\n输入的第一行包含一个正整数 $n$，表示法师人数。\n\n接下来 $n$ 行每行两个非负整数，表示一位法师的坐标位置。保证数值不超过 $10^9$。\n", "outputFormat": "输出一个小数，表示被保护的区域的周长。", "hint": "**数据范围：**\n\n对于所有数据，$2 \\le n \\le 10^5$。\n\n**样例解释：**\n\n对于样例一，显然被保护面积是以这两点连线作为直径的圆形。根据圆的周长计算公式即可得出答案。而且你与标算的相对误差不超过 $10^{-7}$ 即被认为正确。", "locale": "zh-CN"}}}
{"pid": "P11545", "type": "P", "difficulty": 3, "samples": [["7 6\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n6\n1 1 \n1 2 \n1 3 \n2 1 2\n3 2 3 4\n1 5", "6\n5\n4\n11\n12\n2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["Code+"], "title": "[Code+#5] 监控中心", "background": "**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。", "description": "随着战争的推进，C 国已经在 D 国的 $n$ 个城市中的每个城市，都至少建立了一个情报中心。除此之外，TAC 规划了 $m$ 条双向的信息传输通道，其中第 $i$ 条形如 $(a_i,b_i)$，表示在城市 $a_i$ 和城市 $b_i$ 之间可以直接传递、交换情报。经过合理规划，任意两个城市之间都可以直接或间接地传递情报。\n\n然而 D 国的军队也不是吃素的。在军队的秘密围剿下，一些城市的情报中心可能会被歼灭而失效。如果一个城市 $c$ 的情报中心失效了，那么所有和 $c$ 有传输通道的、还未失效的城市将会无法发送情报，总而将这条错误信息报告到总部。即如果有一条形如 $(a,b)$ 的传输通道，那么就会有这样四种情况：\n\n- $a$ 和 $b$ 的情报中心同时有效，那么传输正常，没有错误信息；\n\n- $a$ 的情报中心有效而 $b$ 的情报中心被歼灭，则 $a$ 的情报中心会报告“无法给 $b$ 发送信息”的错误信息；\n\n- $b$ 的情报中心有效而 $a$ 的情报中心被歼灭，则 $b$ 的情报中心会报告“无法给 $a$ 发送信息”的错误信息；\n\n- $a$ 和 $b$ 的情报中心同时被歼灭，则两个城市都无法发出错误信息。\n\n现在，TAC 有 $q$ 个事件。在每个事件中，TAC 得到了若干条错误信息。请你根据这些错误信息，确定出**被歼灭的**的情报中心的个数。注意：不同的事件是**独立**的；并且**至少存在一个**有效的情报中心。\n", "inputFormat": "第一行两个整数 $n$，$m$，表示城市的个数和传输通道的个数；\n\n接下来 $m$ 行，每行 $(a_i,b_i)$（$1\\le i\\le m$），表示一条传输通道；\n\n接下来一行一个整数 $q$；\n\n接下来 $q$ 行，每行 $c_i+1$ 个数，其中第一个数为 $c_i$ 表示错误信息的个数，接下来有 $c_i$ 个数 $e_1,e_2,\\cdots,e_{c_i}$；其中如果 $e_i > 0$，表示 $a_{e_i}$ 因为无法给 $b_{e_i}$ 发送信息而发出错误信息，否则表示 $b_{-e_i}$ 因为无法给 $a_{-e_i}$ 发送信息而发出错误信息。", "outputFormat": "输出 $q$ 行，每行一个整数，表示每个事件**被歼灭**的情报中心的个数。", "hint": "**数据范围：**\n\n\n$\\def\\arraystretch{1.44}\n\\begin{array}{|c|c|c|}\\hline\n\\bold{\\small{子任务}}&\\textbf{score}&\\textbf{constraints}\\\\\\hline\n\\text{A}&20&1\\le N\\le 10^5,m=n-1,b_i-a_i=1,\\sum c\\le 10^6\\\\\\hline\n\\text{B}&30&1\\le N\\le10^5,m=n-1,\\sum c\\le10^6\\\\\\hline\n\\text{C}&20&m=n-1\\\\\\hline\n\\text{D}&30&\\small{无特殊限制}\\\\\\hline\n\\end{array}$\n\n对于所有数据，保证 $1\\le n\\le 10^6$，$0\\le m\\le 2.5\\times 10^6$，$1\\le q,\\sum_{i=1}^q c_i \\le 10^7$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Code+#5] 监控中心", "background": "**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。", "description": "随着战争的推进，C 国已经在 D 国的 $n$ 个城市中的每个城市，都至少建立了一个情报中心。除此之外，TAC 规划了 $m$ 条双向的信息传输通道，其中第 $i$ 条形如 $(a_i,b_i)$，表示在城市 $a_i$ 和城市 $b_i$ 之间可以直接传递、交换情报。经过合理规划，任意两个城市之间都可以直接或间接地传递情报。\n\n然而 D 国的军队也不是吃素的。在军队的秘密围剿下，一些城市的情报中心可能会被歼灭而失效。如果一个城市 $c$ 的情报中心失效了，那么所有和 $c$ 有传输通道的、还未失效的城市将会无法发送情报，总而将这条错误信息报告到总部。即如果有一条形如 $(a,b)$ 的传输通道，那么就会有这样四种情况：\n\n- $a$ 和 $b$ 的情报中心同时有效，那么传输正常，没有错误信息；\n\n- $a$ 的情报中心有效而 $b$ 的情报中心被歼灭，则 $a$ 的情报中心会报告“无法给 $b$ 发送信息”的错误信息；\n\n- $b$ 的情报中心有效而 $a$ 的情报中心被歼灭，则 $b$ 的情报中心会报告“无法给 $a$ 发送信息”的错误信息；\n\n- $a$ 和 $b$ 的情报中心同时被歼灭，则两个城市都无法发出错误信息。\n\n现在，TAC 有 $q$ 个事件。在每个事件中，TAC 得到了若干条错误信息。请你根据这些错误信息，确定出**被歼灭的**的情报中心的个数。注意：不同的事件是**独立**的；并且**至少存在一个**有效的情报中心。\n", "inputFormat": "第一行两个整数 $n$，$m$，表示城市的个数和传输通道的个数；\n\n接下来 $m$ 行，每行 $(a_i,b_i)$（$1\\le i\\le m$），表示一条传输通道；\n\n接下来一行一个整数 $q$；\n\n接下来 $q$ 行，每行 $c_i+1$ 个数，其中第一个数为 $c_i$ 表示错误信息的个数，接下来有 $c_i$ 个数 $e_1,e_2,\\cdots,e_{c_i}$；其中如果 $e_i > 0$，表示 $a_{e_i}$ 因为无法给 $b_{e_i}$ 发送信息而发出错误信息，否则表示 $b_{-e_i}$ 因为无法给 $a_{-e_i}$ 发送信息而发出错误信息。", "outputFormat": "输出 $q$ 行，每行一个整数，表示每个事件**被歼灭**的情报中心的个数。", "hint": "**数据范围：**\n\n\n$\\def\\arraystretch{1.44}\n\\begin{array}{|c|c|c|}\\hline\n\\bold{\\small{子任务}}&\\textbf{score}&\\textbf{constraints}\\\\\\hline\n\\text{A}&20&1\\le N\\le 10^5,m=n-1,b_i-a_i=1,\\sum c\\le 10^6\\\\\\hline\n\\text{B}&30&1\\le N\\le10^5,m=n-1,\\sum c\\le10^6\\\\\\hline\n\\text{C}&20&m=n-1\\\\\\hline\n\\text{D}&30&\\small{无特殊限制}\\\\\\hline\n\\end{array}$\n\n对于所有数据，保证 $1\\le n\\le 10^6$，$0\\le m\\le 2.5\\times 10^6$，$1\\le q,\\sum_{i=1}^q c_i \\le 10^7$。", "locale": "zh-CN"}}}
{"pid": "P11546", "type": "P", "difficulty": 0, "samples": [["5\n1 1\n2 3\n1 5\n3 4\n2 6", "2\n1 1 1\n2 3 1\n1 5 2\n3 4 1\n2 6 2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2009] 糖果机器 (Day1)", "background": "", "description": "**译自 [BalticOI 2009](http://www.csc.kth.se/contest/boi/tasks.php) Day1 T2「[Candy Machine](http://www.csc.kth.se/contest/boi/candy.pdf)」**\n\n在糖果工厂中，有一台神秘的机器。它生产许多美味的糖果，每一个都与众不同。这个机器有一排输出槽，编号为 $1$ 到 $n$，糖果加工完毕就会从里面出来。没有人真正知道它的工作原理，但是在每一次产品计划之前，它会打印一个列表告诉老板每个糖果会在何时从哪个槽出来。\n\n现在，老板可以安装自动收集车在每个槽下移动，以收集掉落的糖果。当然，糖果不能掉到地上，不然就会碎裂。然而，安装自动收集车的成本极其高昂，老板想尽量少安装自动收集车。\n\n写一个程序计算接住所有糖果需要的自动收集车的数量，它应当尽可能小。此外，你的程序还需要输出每颗糖果会被哪辆收集车接住。收集车每秒可以从一个槽移动到另一个相邻的槽。在生产过程开始前，每辆收集车可以移动到他应当收集的第一个糖果的位置。", "inputFormat": "第一行，一个整数 $n$，表示将要生产的糖果的数量。\n\n以下 $n$ 行，每行两个整数 $s_i$ 和 $t_i$，表示第 $i$ 颗糖果的输出槽和输出时间。每一组 $(s_i,t_i)$ 互不相同。", "outputFormat": "第一行，一个整数 $w$，表示接住所有糖果需要的收集车的数量（尽量小）。\n收集车被编号为 $1$ 到 $w$。\n\n以下 $n$ 行描述每颗糖果会被哪辆收集车接住。\n出于此目的，这 $n$ 行每行三个整数：第 $j$ 颗糖果的输出槽 $s_j$ 和输出时间 $t_j$ 和收集车的编号 $w(j)$。表示在时刻 $t_j$ 收集车 $w(j)$ 会在槽 $s_j$ 下并接到糖果。", "hint": "### 数据范围：\n\n| 数据百分比 | 限制 |\n| :----------: | :----------: |\n| $20 \\%$ | $n \\le 85, w \\le 4$ |\n| $60 \\%$ | $n \\le 8 × 10 ^ {3}$ |\n| $100 \\%$ | $1 \\le n \\le 10 ^ {5}, 0 \\le s_i, t_i \\le 10 ^ {9}$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2009] 糖果机器 (Day1)", "background": "", "description": "**译自 [BalticOI 2009](http://www.csc.kth.se/contest/boi/tasks.php) Day1 T2「[Candy Machine](http://www.csc.kth.se/contest/boi/candy.pdf)」**\n\n在糖果工厂中，有一台神秘的机器。它生产许多美味的糖果，每一个都与众不同。这个机器有一排输出槽，编号为 $1$ 到 $n$，糖果加工完毕就会从里面出来。没有人真正知道它的工作原理，但是在每一次产品计划之前，它会打印一个列表告诉老板每个糖果会在何时从哪个槽出来。\n\n现在，老板可以安装自动收集车在每个槽下移动，以收集掉落的糖果。当然，糖果不能掉到地上，不然就会碎裂。然而，安装自动收集车的成本极其高昂，老板想尽量少安装自动收集车。\n\n写一个程序计算接住所有糖果需要的自动收集车的数量，它应当尽可能小。此外，你的程序还需要输出每颗糖果会被哪辆收集车接住。收集车每秒可以从一个槽移动到另一个相邻的槽。在生产过程开始前，每辆收集车可以移动到他应当收集的第一个糖果的位置。", "inputFormat": "第一行，一个整数 $n$，表示将要生产的糖果的数量。\n\n以下 $n$ 行，每行两个整数 $s_i$ 和 $t_i$，表示第 $i$ 颗糖果的输出槽和输出时间。每一组 $(s_i,t_i)$ 互不相同。", "outputFormat": "第一行，一个整数 $w$，表示接住所有糖果需要的收集车的数量（尽量小）。\n收集车被编号为 $1$ 到 $w$。\n\n以下 $n$ 行描述每颗糖果会被哪辆收集车接住。\n出于此目的，这 $n$ 行每行三个整数：第 $j$ 颗糖果的输出槽 $s_j$ 和输出时间 $t_j$ 和收集车的编号 $w(j)$。表示在时刻 $t_j$ 收集车 $w(j)$ 会在槽 $s_j$ 下并接到糖果。", "hint": "### 数据范围：\n\n| 数据百分比 | 限制 |\n| :----------: | :----------: |\n| $20 \\%$ | $n \\le 85, w \\le 4$ |\n| $60 \\%$ | $n \\le 8 × 10 ^ {3}$ |\n| $100 \\%$ | $1 \\le n \\le 10 ^ {5}, 0 \\le s_i, t_i \\le 10 ^ {9}$ |\n", "locale": "zh-CN"}}}
{"pid": "P11547", "type": "P", "difficulty": 0, "samples": [["100 5\n5 R\n35 L\n46 L\n75 L\n85 R", "0.5"], ["100 8\n9 L\n15 R\n41 L\n33 L\n81 R\n33 R\n100 L\n97 R", "15.500000"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2009", "Special Judge", "BalticOI（波罗的海）"], "title": "[BalticOI 2009] 地铁信号故障（暂无SPJ） (Day1)", "background": "", "description": "**译自 [BalticOI 2009](http://www.csc.kth.se/contest/boi/tasks.php)  Day1 T3「[Subway Signalling Error](http://www.csc.kth.se/contest/boi/subway.pdf)」**\n\nStockholm 城中的地铁由几条线路组成。在这个题目中，我们特别考虑其中一条线路，当出现“信号故障”时问题常发生在这里。\n\n一条线路可以看做两条平行的铁轨，他们在端点处连接。在上部的铁轨中，地铁由右到左行驶，且在下部的铁轨中，地铁由左到右行驶。当一列地铁到达铁轨的端点，它会切换到另一条铁轨并更改方向，这个过程在瞬间内完成。\n\n正常情况下，交通流是连续的且地铁匀速移动（$1$ 距离单位每时间单位）。同时，地铁是均匀分布的，即地铁将定时经过铁轨上的每个地点。你可以忽略地铁接客的时间。\n\n由于信号故障，现在地铁沿着线路随机分布。作为交通调度员，你的任务是尽快还原地铁为均匀分布。写一个程序，对于给定的地铁的位置，问何时能还原。你可以使地铁在任意地点暂停或是改变方向（两项可以同时执行）。如果一列地铁改变了方向，他将切换到另一条铁路。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3g40mnka.png)\n\n图 $1$：两条铁轨的长度都是 $100$。上例中，地铁分别位于 $5$（朝右）,$35$（左）,$46$（左）,$75$（左）及 $85$（右）。一个可行的方案是：待位于 $46$ 的地铁向左移动一个单位后，使它改变方向。这用了一个单位的时间。然而，这并不是最优解，详见样例 $1$。", "inputFormat": "第一行，两个整数 $m$ 和 $n$，分别表示铁轨的长度和地铁的数量。\n\n以下 $n$ 行，每行表示一列地铁，为一个整数 $x_i$ 表示位置和一个字符表示方向（$L$ 表示左，$R$ 表示右）。", "outputFormat": "输出使地铁均匀分布的最短时间。最大误差为 $10^{-6}$。", "hint": "| 数据百分比 | 限制 |\n| :----------: | :----------: |\n| $50 \\%$ | $n \\le 200$ |\n| $100 \\%$ | $100 \\le m \\le 10 ^ {8}, 1 \\le n \\le 10 ^ {6}, 0 \\le x_i \\le m$ |\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[BalticOI 2009] 地铁信号故障（暂无SPJ） (Day1)", "background": "", "description": "**译自 [BalticOI 2009](http://www.csc.kth.se/contest/boi/tasks.php)  Day1 T3「[Subway Signalling Error](http://www.csc.kth.se/contest/boi/subway.pdf)」**\n\nStockholm 城中的地铁由几条线路组成。在这个题目中，我们特别考虑其中一条线路，当出现“信号故障”时问题常发生在这里。\n\n一条线路可以看做两条平行的铁轨，他们在端点处连接。在上部的铁轨中，地铁由右到左行驶，且在下部的铁轨中，地铁由左到右行驶。当一列地铁到达铁轨的端点，它会切换到另一条铁轨并更改方向，这个过程在瞬间内完成。\n\n正常情况下，交通流是连续的且地铁匀速移动（$1$ 距离单位每时间单位）。同时，地铁是均匀分布的，即地铁将定时经过铁轨上的每个地点。你可以忽略地铁接客的时间。\n\n由于信号故障，现在地铁沿着线路随机分布。作为交通调度员，你的任务是尽快还原地铁为均匀分布。写一个程序，对于给定的地铁的位置，问何时能还原。你可以使地铁在任意地点暂停或是改变方向（两项可以同时执行）。如果一列地铁改变了方向，他将切换到另一条铁路。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3g40mnka.png)\n\n图 $1$：两条铁轨的长度都是 $100$。上例中，地铁分别位于 $5$（朝右）,$35$（左）,$46$（左）,$75$（左）及 $85$（右）。一个可行的方案是：待位于 $46$ 的地铁向左移动一个单位后，使它改变方向。这用了一个单位的时间。然而，这并不是最优解，详见样例 $1$。", "inputFormat": "第一行，两个整数 $m$ 和 $n$，分别表示铁轨的长度和地铁的数量。\n\n以下 $n$ 行，每行表示一列地铁，为一个整数 $x_i$ 表示位置和一个字符表示方向（$L$ 表示左，$R$ 表示右）。", "outputFormat": "输出使地铁均匀分布的最短时间。最大误差为 $10^{-6}$。", "hint": "| 数据百分比 | 限制 |\n| :----------: | :----------: |\n| $50 \\%$ | $n \\le 200$ |\n| $100 \\%$ | $100 \\le m \\le 10 ^ {8}, 1 \\le n \\le 10 ^ {6}, 0 \\le x_i \\le m$ |\n", "locale": "zh-CN"}}}
