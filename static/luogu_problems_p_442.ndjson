{"pid": "P9960", "type": "P", "difficulty": 2, "samples": [["4\nbird 2 flies eatsworms\ncow 4 eatsgrass isawesome makesmilk goesmoo\nsheep 1 eatsgrass\ngoat 2 makesmilk eatsgrass", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "2019", "USACO", "O2优化"], "title": "[USACO19JAN] Guess the Animal B", "background": "", "description": "奶牛 Bessie 和她的朋友 Elsie 厌倦了她们的坚果壳游戏，她们想要玩另一个叫做“猜动物”的常见游戏。\n\n游戏开始时，Bessie 会想好一种动物（大部分时候，她想的都是奶牛，这使得游戏相当无聊，但是偶尔 Bessie 也能有些新意，想一些别的）。随后 Elsie 会通过问一些问题来猜出 Bessie 选择的动物。每个问题都是询问这种动物是否具有某个特定的特征，Bessie 对于每个问题回答“是”或“不是”。例如：\n\nElsie：“这种动物是能飞的吗？”  \nBessie：“不是。”  \nElsie：“这种动物是吃草的吗？”  \nBessie：“是。”  \nElsie：“这种动物是能产奶的吗？”  \nBessie：“是。”  \nElsie：“这种动物是会哞哞叫的吗？”  \nBessie：“是。”  \nElsie：“这样的话我想这种动物是奶牛。”  \nBessie：“猜对了！”  \n\n如果我们将所有具备符合 Elsie 到目前为止所提出的问题的特征的动物的集合称为“可行集”，那么 Elsie 会持续进行提问直到可行集仅包含一种动物，然后她会把这种动物作为她的答案。对于每个问题，Elsie 会选择某种动物的一个特征进行询问（即使这个特征并不能进一步帮助她缩小可行集）。她不会关于同一个特征询问两次。\n\n给定 Bessie 和 Elsie 知道的所有动物以及它们的特征，请求出 Elsie 在猜出正确的动物之前能够得到的“是”的回答的最大数量。 ", "inputFormat": "输入的第一行包含动物的数量 $N$（$2\\le N\\le 100$）。以下 $N$ 行每行描述了一种动物。每一行开始是这种动物的名称，接下来是一个整数 $K$（$1\\le K\\le 100$），接下来是这种动物的K个特征。动物的名称和特征是至多 $20$ 个小写字母（`a..z`）组成的字符串。没有两种动物具有完全相同的特征。 ", "outputFormat": "输出游戏结束之前 Elsie 可能得到的“是”的回答的最大数量。 ", "hint": "### 样例解释 1\n\n在这个例子中，Elsie 可能在对话中获得 $3$ 个“是”的回答（题目中的例子），并且不可能进行包含超过 $3$ 个“是”的回答的对话。 ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO19JAN] Guess the Animal B", "background": "", "description": "奶牛 Bessie 和她的朋友 Elsie 厌倦了她们的坚果壳游戏，她们想要玩另一个叫做“猜动物”的常见游戏。\n\n游戏开始时，Bessie 会想好一种动物（大部分时候，她想的都是奶牛，这使得游戏相当无聊，但是偶尔 Bessie 也能有些新意，想一些别的）。随后 Elsie 会通过问一些问题来猜出 Bessie 选择的动物。每个问题都是询问这种动物是否具有某个特定的特征，Bessie 对于每个问题回答“是”或“不是”。例如：\n\nElsie：“这种动物是能飞的吗？”  \nBessie：“不是。”  \nElsie：“这种动物是吃草的吗？”  \nBessie：“是。”  \nElsie：“这种动物是能产奶的吗？”  \nBessie：“是。”  \nElsie：“这种动物是会哞哞叫的吗？”  \nBessie：“是。”  \nElsie：“这样的话我想这种动物是奶牛。”  \nBessie：“猜对了！”  \n\n如果我们将所有具备符合 Elsie 到目前为止所提出的问题的特征的动物的集合称为“可行集”，那么 Elsie 会持续进行提问直到可行集仅包含一种动物，然后她会把这种动物作为她的答案。对于每个问题，Elsie 会选择某种动物的一个特征进行询问（即使这个特征并不能进一步帮助她缩小可行集）。她不会关于同一个特征询问两次。\n\n给定 Bessie 和 Elsie 知道的所有动物以及它们的特征，请求出 Elsie 在猜出正确的动物之前能够得到的“是”的回答的最大数量。 ", "inputFormat": "输入的第一行包含动物的数量 $N$（$2\\le N\\le 100$）。以下 $N$ 行每行描述了一种动物。每一行开始是这种动物的名称，接下来是一个整数 $K$（$1\\le K\\le 100$），接下来是这种动物的K个特征。动物的名称和特征是至多 $20$ 个小写字母（`a..z`）组成的字符串。没有两种动物具有完全相同的特征。 ", "outputFormat": "输出游戏结束之前 Elsie 可能得到的“是”的回答的最大数量。 ", "hint": "### 样例解释 1\n\n在这个例子中，Elsie 可能在对话中获得 $3$ 个“是”的回答（题目中的例子），并且不可能进行包含超过 $3$ 个“是”的回答的对话。 ", "locale": "zh-CN"}}}
{"pid": "P9961", "type": "P", "difficulty": 7, "samples": [["6\n1 4 5 3 2 6\n", "1\n2 3 5 5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "Special Judge", "THUPC"], "title": "[THUPC 2024 初赛] 排序大师", "background": "", "description": "由于你是排序大师，你经常被路过的游客刁难，要求用一些奇怪的操作给序列排序。\n\n由于你是远近闻名的排序大师，邻国的排序萌新小 I 慕名前来拜访，留下了一个长度为 $n$ 的排列 $a_1, a_2 \\cdots, a_n$，并要求你用以下操作将排列升序排序：\n\n- 定义 $a_{i \\sim j} = \\{a_i,a_{i+1},\\cdots, a_j\\}$。选定 $1 \\le i \\le j < k \\le l \\le n$，交换 $a_{i \\sim j}$ 和 $a_{k \\sim l}$，即交换过后序列变为 $a_{1 \\sim i-1}, a_{k \\sim l}, a_{j+1 \\sim k-1}, a_{i \\sim j}, a_{l+1 \\sim n}$。\n\n由于你是因精益求精而远近闻名的排序大师，你需要给出一个排序方案**最小化**操作次数。", "inputFormat": "输入的第一行一个整数 $n(1 \\le n \\le 2000)$ 表示序列长度，第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n (1 \\le a_i \\le n)$ 描述排列。", "outputFormat": "输出的第一行一个整数 $s$ 表示你给出的方案的步数，接下来 $s$ 行每行四个整数 $i,j,k,l$ 表示一次操作。若有多个方案，输出任意一个即可。", "hint": "### 样例 \\#1 解释\n选定 $i = 2, j = 3, k = 5, l = 5$，$\\colorbox{white}{\\color{black}{1}\\color{blue}{45}\\color{black}{3}\\color{red}{2}\\color{black}{6}}$ 变为 $\\colorbox{white}{\\color{black}{1}\\color{red}{2}\\color{black}{3}\\color{blue}{45}\\color{black}{6}}$。\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 初赛] 排序大师", "background": "", "description": "由于你是排序大师，你经常被路过的游客刁难，要求用一些奇怪的操作给序列排序。\n\n由于你是远近闻名的排序大师，邻国的排序萌新小 I 慕名前来拜访，留下了一个长度为 $n$ 的排列 $a_1, a_2 \\cdots, a_n$，并要求你用以下操作将排列升序排序：\n\n- 定义 $a_{i \\sim j} = \\{a_i,a_{i+1},\\cdots, a_j\\}$。选定 $1 \\le i \\le j < k \\le l \\le n$，交换 $a_{i \\sim j}$ 和 $a_{k \\sim l}$，即交换过后序列变为 $a_{1 \\sim i-1}, a_{k \\sim l}, a_{j+1 \\sim k-1}, a_{i \\sim j}, a_{l+1 \\sim n}$。\n\n由于你是因精益求精而远近闻名的排序大师，你需要给出一个排序方案**最小化**操作次数。", "inputFormat": "输入的第一行一个整数 $n(1 \\le n \\le 2000)$ 表示序列长度，第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n (1 \\le a_i \\le n)$ 描述排列。", "outputFormat": "输出的第一行一个整数 $s$ 表示你给出的方案的步数，接下来 $s$ 行每行四个整数 $i,j,k,l$ 表示一次操作。若有多个方案，输出任意一个即可。", "hint": "### 样例 \\#1 解释\n选定 $i = 2, j = 3, k = 5, l = 5$，$\\colorbox{white}{\\color{black}{1}\\color{blue}{45}\\color{black}{3}\\color{red}{2}\\color{black}{6}}$ 变为 $\\colorbox{white}{\\color{black}{1}\\color{red}{2}\\color{black}{3}\\color{blue}{45}\\color{black}{6}}$。\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN"}}}
{"pid": "P9962", "type": "P", "difficulty": 7, "samples": [["10 4\n1 2\n2 3\n2 4\n3 5\n3 6\n3 7\n4 10\n6 8\n8 9\n", "16\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["平衡树", "2024", "凸包", "THUPC", "斜率维护技巧 slope trick", "闵可夫斯基和 Minkowski sum"], "title": "[THUPC 2024 初赛] 一棵树", "background": "", "description": "这里有一棵树，具体的，这是一张有 $n$ 个节点和 $n-1$ 条边组成的无向联通图。\n\n每个节点初始颜色为白色，你需要恰好将其中 $k$ 个节点染成黑色，定义一条边的权值是，断开这条边之后，两个连通块的黑色节点个数之差，定义一棵树的权值为所有边的权值求和，你需要最小化整棵树的权值。", "inputFormat": "第一行两个正整数 $n,k$（$1\\leq k\\leq n\\leq 5\\times10^5$）。\n\n接下来 $n-1$ 行，每行两个正整数 $x,y$ 表示树上的一条边。", "outputFormat": "输出共 $1$ 行，表示最优的染色方案下，这棵树的权值的最小值。", "hint": "### 样例 \\#1 解释\n\n下图展示了一种满足条件的染色方案，边上的数字表示边权。\n\n![fig:sample](https://cdn.luogu.com.cn/upload/image_hosting/9i3ztp9r.png)\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 初赛] 一棵树", "background": "", "description": "这里有一棵树，具体的，这是一张有 $n$ 个节点和 $n-1$ 条边组成的无向联通图。\n\n每个节点初始颜色为白色，你需要恰好将其中 $k$ 个节点染成黑色，定义一条边的权值是，断开这条边之后，两个连通块的黑色节点个数之差，定义一棵树的权值为所有边的权值求和，你需要最小化整棵树的权值。", "inputFormat": "第一行两个正整数 $n,k$（$1\\leq k\\leq n\\leq 5\\times10^5$）。\n\n接下来 $n-1$ 行，每行两个正整数 $x,y$ 表示树上的一条边。", "outputFormat": "输出共 $1$ 行，表示最优的染色方案下，这棵树的权值的最小值。", "hint": "### 样例 \\#1 解释\n\n下图展示了一种满足条件的染色方案，边上的数字表示边权。\n\n![fig:sample](https://cdn.luogu.com.cn/upload/image_hosting/9i3ztp9r.png)\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN"}}}
{"pid": "P9963", "type": "P", "difficulty": 4, "samples": [["3 0.5 1 2\n", "1.000000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2024", "Special Judge", "THUPC"], "title": "[THUPC 2024 初赛] 前缀和", "background": "", "description": "小兰很喜欢随机数。\n\nTA 首先选定了一个实数 $0 < p < 1$，然后生成了 $n$ 个随机数 $x_1,\\dots,x_n$，每个数是独立按照如下方式生成的：\n\n- $x_i$ 有 $p$ 的概率是 $1$，有 $(1-p)p$ 的概率是 $2$，有 $(1-p)^2p$ 的概率是 $3$，以此类推。\n\n生成完这些随机数之后，小艾对这个数列求了前缀和，得到了数列 $y_1,\\dots,y_n$。\n\n给定 $1\\leq l\\leq r\\leq n$，小兰想知道，期望有多少 $y_i$ 落在 $[l, r]$ 内？\n", "inputFormat": "一行输入四个数 $n, p, l, r$。保证 $1\\leq l\\leq r\\leq n\\leq 10^9$，$p$ 的位数不超过 $6$。", "outputFormat": "输出一个实数，表示答案。你需要保证答案的绝对或相对误差不超过 $10^{-6}$。", "hint": "### 样例 \\#1 解释\n\n有 $1/4$ 的概率，$x_1=1$ 而 $x_2>1$，此时只有 $y_1$ 落在 $[1, 2]$ 内。\n\n有 $1/4$ 的概率，$x_1=1$ 且 $x_2=1$，此时 $y_1,y_2$ 落在 $[1, 2]$ 内。\n\n有 $1/4$ 的概率，$x_1=2$，此时只有 $y_1$ 落在 $[1, 2]$ 内。\n\n所以期望是 $1/4\\cdot (1 + 2 + 1) = 1$。\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 初赛] 前缀和", "background": "", "description": "小兰很喜欢随机数。\n\nTA 首先选定了一个实数 $0 < p < 1$，然后生成了 $n$ 个随机数 $x_1,\\dots,x_n$，每个数是独立按照如下方式生成的：\n\n- $x_i$ 有 $p$ 的概率是 $1$，有 $(1-p)p$ 的概率是 $2$，有 $(1-p)^2p$ 的概率是 $3$，以此类推。\n\n生成完这些随机数之后，小艾对这个数列求了前缀和，得到了数列 $y_1,\\dots,y_n$。\n\n给定 $1\\leq l\\leq r\\leq n$，小兰想知道，期望有多少 $y_i$ 落在 $[l, r]$ 内？\n", "inputFormat": "一行输入四个数 $n, p, l, r$。保证 $1\\leq l\\leq r\\leq n\\leq 10^9$，$p$ 的位数不超过 $6$。", "outputFormat": "输出一个实数，表示答案。你需要保证答案的绝对或相对误差不超过 $10^{-6}$。", "hint": "### 样例 \\#1 解释\n\n有 $1/4$ 的概率，$x_1=1$ 而 $x_2>1$，此时只有 $y_1$ 落在 $[1, 2]$ 内。\n\n有 $1/4$ 的概率，$x_1=1$ 且 $x_2=1$，此时 $y_1,y_2$ 落在 $[1, 2]$ 内。\n\n有 $1/4$ 的概率，$x_1=2$，此时只有 $y_1$ 落在 $[1, 2]$ 内。\n\n所以期望是 $1/4\\cdot (1 + 2 + 1) = 1$。\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN"}}}
{"pid": "P9964", "type": "P", "difficulty": 6, "samples": [["3\n^vv\n", "2 0\n"], ["8\nv^v^^^^v\n", "6 15\n"], ["40\nv^vv^v^^v^^vvvv^v^^v^^^vv^^vvvv^v^^v^^^v\n", "14 201\n"], ["56\nv^vvvvvvv^v^^vv^v^^v^^^^v^^v^vvvv^^vvvv^v^^v^^^vv^^vv^v^\n", "24 663\n"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 初赛] 多折较差验证", "background": "", "description": "临海听潮意，入林闻籁鸣。这是一座依山傍水、宁静祥和的小镇，在这里人们很少担心自己家里的物品故障损坏，因为 Kanan 总能帮大家修好。Kanan 是这片地区首屈一指的机械师；虽然她还年轻，但是娴熟的技艺加上慷慨的性格使得她平时总会收到人们的修理委托，据说就连那位遗世独立的魔王遇到了问题都得求助她。在帮人修理时， Kanan 会接触到千奇百怪的使用说明书。其中一些说明书有着不可思议的折叠结构，Kanan 为了理解机械的构造会在修理之前展开说明书，可在修好之后按照原来的折痕折回原状却比修理本身更费劲。\n\n对于所有折痕互相平行的说明书，可以按照说明书上文字的阅读顺序从上到下给每条折痕分别编号 $1, 2, \\cdots, N$，这 $N$ 条折痕将说明书分成了 $(N+1)$ 条纸带。每条折痕可能为两种形态之一：一种是垂直纸面向内凸出，对应将纸的上下两半向前对折；一种是垂直纸面向外凸出，对应将上下两半向后对折。根据折痕截面的形状，分别使用小写字母 `v` 表示向内凸出的折痕，`^` （ASCII 码为 $94$）表示向外凸出的折痕。假设所有纸带的宽度都是一样的，并且折纸的过程中说明书不发生形变，那么沿着一条折痕对折后两侧的纸能够重合，当且仅当两侧的折痕是相反的；即，如果沿着第 $k$ 条折痕折叠，那么对于所有满足 $1\\le k-m<k+m\\le N$ 的正整数 $m$，第 $(k-m)$ 条折痕和第 $(k+m)$ 条折痕的形态是相反的。例如，对于折痕依次为 `v^v^^^^v` 的说明书，可以沿其第 $7$ 条折痕进行折叠。根据定义可知，一张说明书总能沿着第一条或最后一条折痕进行折叠。折叠之后的说明书可以用被折叠的折痕两侧中，剩余折痕数量较多一侧的折痕表示，如 `v^v^^^^v` 沿着第 $7$ 条折痕折叠后得到 `v^v^^^`。如果被折叠的折痕两侧折痕数量相等，那么用哪一侧的折痕表示折叠后的纸都可以，因为折痕在三维空间中是旋转对称的。特别地，对只剩下一条折痕的说明书，即 `v` 或 `^` 进行折叠后，所有 $(N+1)$ 条纸带都重叠在一起，此时称这张说明书被折叠整齐。\n\n虽然按顺序依次折叠每一条折痕，总能将说明书折叠整齐，但 Kanan 觉得这样并不美观。一种美观的折法应该尽量少折，并且每次折的时候折痕两侧应该尽可能的对称。定义一种折法的不对称程度为每次折叠时，被折叠的折痕两侧的折痕数量之差的总和。给出一张说明书的折痕，Kanan 想知道最少需要折多少次才能将这张说明书折叠整齐，以及所有折叠次数最少的折法中，不对称程度的最小值。\n", "inputFormat": "输入的第一行包含一个正整数 $N$，表示折痕的条数。保证 $1\\le N\\le 5000$。\n\n输入的第二行包含一个字符串 $s$，按顺序表示每条折痕。保证 $|s|=N$，且 $s$ 仅由 `v` 和 `^` 组成。", "outputFormat": "输出仅一行，包括两个非负整数，分别表示最少的折叠次数和最小化折叠次数的前提下的最小不对称程度，两个数之间用一个空格隔开。", "hint": "### 样例 \\#1 解释\n\n如果先沿着中间的折痕对折，那么两侧的纸恰好重合，此时再对折一次即可将说明书折叠整齐。\n\n### 子任务\n\n对于所有数据，保证 $1\\le N\\le 5000$，$|s|=N$ 且 $s$ 仅由 `v` 和 `^` 组成。\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 初赛] 多折较差验证", "background": "", "description": "临海听潮意，入林闻籁鸣。这是一座依山傍水、宁静祥和的小镇，在这里人们很少担心自己家里的物品故障损坏，因为 Kanan 总能帮大家修好。Kanan 是这片地区首屈一指的机械师；虽然她还年轻，但是娴熟的技艺加上慷慨的性格使得她平时总会收到人们的修理委托，据说就连那位遗世独立的魔王遇到了问题都得求助她。在帮人修理时， Kanan 会接触到千奇百怪的使用说明书。其中一些说明书有着不可思议的折叠结构，Kanan 为了理解机械的构造会在修理之前展开说明书，可在修好之后按照原来的折痕折回原状却比修理本身更费劲。\n\n对于所有折痕互相平行的说明书，可以按照说明书上文字的阅读顺序从上到下给每条折痕分别编号 $1, 2, \\cdots, N$，这 $N$ 条折痕将说明书分成了 $(N+1)$ 条纸带。每条折痕可能为两种形态之一：一种是垂直纸面向内凸出，对应将纸的上下两半向前对折；一种是垂直纸面向外凸出，对应将上下两半向后对折。根据折痕截面的形状，分别使用小写字母 `v` 表示向内凸出的折痕，`^` （ASCII 码为 $94$）表示向外凸出的折痕。假设所有纸带的宽度都是一样的，并且折纸的过程中说明书不发生形变，那么沿着一条折痕对折后两侧的纸能够重合，当且仅当两侧的折痕是相反的；即，如果沿着第 $k$ 条折痕折叠，那么对于所有满足 $1\\le k-m<k+m\\le N$ 的正整数 $m$，第 $(k-m)$ 条折痕和第 $(k+m)$ 条折痕的形态是相反的。例如，对于折痕依次为 `v^v^^^^v` 的说明书，可以沿其第 $7$ 条折痕进行折叠。根据定义可知，一张说明书总能沿着第一条或最后一条折痕进行折叠。折叠之后的说明书可以用被折叠的折痕两侧中，剩余折痕数量较多一侧的折痕表示，如 `v^v^^^^v` 沿着第 $7$ 条折痕折叠后得到 `v^v^^^`。如果被折叠的折痕两侧折痕数量相等，那么用哪一侧的折痕表示折叠后的纸都可以，因为折痕在三维空间中是旋转对称的。特别地，对只剩下一条折痕的说明书，即 `v` 或 `^` 进行折叠后，所有 $(N+1)$ 条纸带都重叠在一起，此时称这张说明书被折叠整齐。\n\n虽然按顺序依次折叠每一条折痕，总能将说明书折叠整齐，但 Kanan 觉得这样并不美观。一种美观的折法应该尽量少折，并且每次折的时候折痕两侧应该尽可能的对称。定义一种折法的不对称程度为每次折叠时，被折叠的折痕两侧的折痕数量之差的总和。给出一张说明书的折痕，Kanan 想知道最少需要折多少次才能将这张说明书折叠整齐，以及所有折叠次数最少的折法中，不对称程度的最小值。\n", "inputFormat": "输入的第一行包含一个正整数 $N$，表示折痕的条数。保证 $1\\le N\\le 5000$。\n\n输入的第二行包含一个字符串 $s$，按顺序表示每条折痕。保证 $|s|=N$，且 $s$ 仅由 `v` 和 `^` 组成。", "outputFormat": "输出仅一行，包括两个非负整数，分别表示最少的折叠次数和最小化折叠次数的前提下的最小不对称程度，两个数之间用一个空格隔开。", "hint": "### 样例 \\#1 解释\n\n如果先沿着中间的折痕对折，那么两侧的纸恰好重合，此时再对折一次即可将说明书折叠整齐。\n\n### 子任务\n\n对于所有数据，保证 $1\\le N\\le 5000$，$|s|=N$ 且 $s$ 仅由 `v` 和 `^` 组成。\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN"}}}
{"pid": "P9965", "type": "P", "difficulty": 5, "samples": [["2\n1 2\n1 2\n1 0\n", "4 3\n4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2024", "THUPC"], "title": "[THUPC 2024 初赛] 转化", "background": "小 E 在玩 Somzig 游戏的时候因为操作时间不够绷不住了，于是就有了这个题。", "description": "小 E 有 $n$ 种颜色的球，其中第 $i$ 种有 $a_i$ 个。有两类工具，第一类可以把一个指定颜色的球变成一个**任意**颜色的球；第二类可以把一个指定颜色的球变成两个**这种**颜色的球。一个变化之后的球也可以通过工具产生新的变化。关于第 $i$ 种颜色的第一类工具有 $b_i$ 个，第二类工具有 $c_i$ 个。小 E 想知道，如果每一**个**工具最多只能使用一次，那么对于每种颜色 $i$，第 $i$ 种颜色的球最后最多能有多少个。以及，小 E 最后最多能有多少个球。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个整数，其中第 $i$ 个表示 $a_i$。\n\n第三行 $n$ 个整数，其中第 $i$ 个表示 $b_i$。\n\n第四行 $n$ 个整数，其中第 $i$ 个表示 $c_i$。", "outputFormat": "第一行 $n$ 个整数，其中第 $i$ 个表示如果每个工具最多使用一次，那么小 E 最后第 $i$ 种颜色的球最多有多少个。\n\n第二行一个整数，表示如果每个工具最多使用一次，那么小 E 最后最多能有多少个球。", "hint": "### 子任务\n\n保证 $1\\le n \\le 351493$。\n\n保证 $0\\le a_i,b_i,c_i\\le 10^9$。\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 初赛] 转化", "background": "小 E 在玩 Somzig 游戏的时候因为操作时间不够绷不住了，于是就有了这个题。", "description": "小 E 有 $n$ 种颜色的球，其中第 $i$ 种有 $a_i$ 个。有两类工具，第一类可以把一个指定颜色的球变成一个**任意**颜色的球；第二类可以把一个指定颜色的球变成两个**这种**颜色的球。一个变化之后的球也可以通过工具产生新的变化。关于第 $i$ 种颜色的第一类工具有 $b_i$ 个，第二类工具有 $c_i$ 个。小 E 想知道，如果每一**个**工具最多只能使用一次，那么对于每种颜色 $i$，第 $i$ 种颜色的球最后最多能有多少个。以及，小 E 最后最多能有多少个球。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个整数，其中第 $i$ 个表示 $a_i$。\n\n第三行 $n$ 个整数，其中第 $i$ 个表示 $b_i$。\n\n第四行 $n$ 个整数，其中第 $i$ 个表示 $c_i$。", "outputFormat": "第一行 $n$ 个整数，其中第 $i$ 个表示如果每个工具最多使用一次，那么小 E 最后第 $i$ 种颜色的球最多有多少个。\n\n第二行一个整数，表示如果每个工具最多使用一次，那么小 E 最后最多能有多少个球。", "hint": "### 子任务\n\n保证 $1\\le n \\le 351493$。\n\n保证 $0\\le a_i,b_i,c_i\\le 10^9$。\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN"}}}
{"pid": "P9966", "type": "P", "difficulty": 6, "samples": [["2 2 5\n0 0\nMOVE 1 1\nMOVE 0 1\n0 1\nTRIGGER MOVE: MOVE 0 1\nSLACKOFF\n", "Robot 0 moves its right hand towards Robot 1.\nRobot 1 moves its left hand towards Robot 1.\nRobot 0 moves its left hand towards Robot 1.\nRobot 1 moves its left hand towards Robot 0.\nRobot 1 slacks off.\n"], ["2 2 4\n0 1\nACTIVATE 1\nSLACKOFF\n0 1\nSWAP 0 2 2\nMIRROR 0 1\n", "Robot 0 activates Robot 1.\nRobot 1 swaps a line of command with Robot 0.\nRobot 1 slacks off.\nRobot 0 modifies a line of command of Robot 0.\n"], ["3 2 6\n1 2\nACTIVATE 0\nACTIVATE 0\n2 1\nSWAP 0 2 2\nTRIGGER ACTIVATE: REPLACE 0 2 SLACKOFF\n0 1\nTRIGGER MIRROR: SLACKOFF\nSLACKOFF\n", "Robot 0 activates Robot 1.\nRobot 1 swaps a line of command with Robot 2.\nRobot 1 slacks off.\nRobot 2 replaces a line of command of Robot 0.\nRobot 0 slacks off.\nRobot 1 swaps a line of command with Robot 2.\n"], ["3 2 8\n0 1\nSLACKOFF\nTRIGGER MOVE: SLACKOFF\n1 2\nTRIGGER TRIGGER: SLACKOFF\nTRIGGER SLACKOFF: MOVE 0 1\n2 0\nTRIGGER SLACKOFF: MOVE 1 2\nTRIGGER TRIGGER: MOVE 1 1\n", "Robot 0 slacks off.\nRobot 1 moves its left hand towards Robot 2.\nRobot 2 moves its right hand towards Robot 1.\nRobot 1 slacks off.\nRobot 2 moves its right hand towards Robot 0.\nRobot 0 slacks off.\nRobot 1 slacks off.\nRobot 2 moves its right hand towards Robot 2.\n"], ["见附加文件的 5.in。", "见附加文件的 5.ans。"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2024", "THUPC"], "title": "[THUPC 2024 初赛] 机器人", "background": "", "description": "有 $n$ 个机器人围成一圈，编号按照逆时针顺序分别为 $0\\sim n-1$。\n\n每个机器人有两只手。编号为 $i$ 的机器人初始「左手」指向编号 $l_i$ 的机器人，「右手」指向编号 $r_i$ 的机器人。\n\n所有的机器人内部都写有 $m$ 行「指令」，「指令」有以下这些形式：\n\n### 指令\n\n「指令」分为「基础指令」和「高级指令」两种。「高级指令」的功能会更复杂一些，但它们本质上没有多大区别。下面介绍这些「指令」的格式以及它们被「执行」时的效果。文中的“自己”一词均指拥有这条「指令」的机器人。\n\n#### 基础指令\n\n- `SLACKOFF`：**「摸鱼」**，即什么也不做。\n- `MOVE h z`：将第 $h$ 只手向逆时针方向 **「移动」** $z$ 个机器人的位置。当 $h=0$ 时表示「左手」，当 $h=1$ 时表示「右手」，下同。\n- `SWAP h x y`：将第 $h$ 只手指向的机器人的第 $x$ 行「指令」与自己的第 $y$ 行「指令」 **「对调」**。\n- `MIRROR h x`：将第 $h$ 只手指向的机器人的第 $x$ 行「指令」**「镜像」** 取反，即将「指令」中的 $h$ 取反（$0$ 变成 $1$，$1$ 变成 $0$）。特殊地，它对 `SLACKOFF` 指令没有效果；而对 `TRIGGER` 指令，会直接修改「触发」时「执行」的「指令」中的 $h$。\n- `REPLACE h x <COMMAND>`：将第 $h$ 只手指向的机器人的第 $x$ 行「指令」**「替换」** 为 `<COMMAND>`。其中 `<COMMAND>` 为一条完整的「指令」。\n\n#### 高级指令 \n\n- `ACTIVATE h`：**「激活」** 第 $h$ 只手指向的机器人，即按顺序「执行」那个机器人的所有「指令」。前一行「指令」「执行」完毕之后才会「执行」后一行。注意在「执行」前面的「指令」时后面的「指令」可能会发生更改，这时需要「执行」更改后的「指令」。当那个机器人的所有「指令」「执行」完毕后，该「指令」才算「执行」完毕。\n\n- `TRIGGER <COMMANDNAME>: <COMMAND>`：其中 `<COMMANDNAME>` 表示「指令」的名称，即一条「指令」中的第一个全大写单词；`<COMMAND>` 表示一条完整的「基础指令」。`TRIGGER` 指令不会被「执行」，即按顺序「执行」时会跳过该「指令」。但是，当一个 **其他** 机器人「执行」完一条「指令」之后，且「右手」指向自己的时候，自己最靠前的满足如下条件的 `TRIGGER` 指令（如果有）就会被 **「触发」**——「执行」一次对应的 `<COMMAND>`：\n\n  - `<COMMANDNAME>` 不为 `TRIGGER` 时，刚刚「执行」完毕的「指令」为 `<COMMANDNAME>` 指令；\n  - `<COMMANDNAME>` 为 `TRIGGER` 时，刚刚「执行」完毕的「指令」是 `TRIGGER` 指令被「触发」时「执行」的「指令」。\n\n  「执行」完毕后会回到原来的「执行」顺序中。\n\n你需要从 $0$ 号机器人开始按照编号顺序一圈又一圈地「激活」这些机器人，并输出「执行」的前 $k$ 条指令的有关信息。", "inputFormat": "第一行三个正整数 $n,m,k$。\n\n接下来按照编号从小到大的顺序表示 $n$ 个机器人的信息。\n\n对于每个机器人，第一行两个非负整数 $l_i,r_i$ 表示「左手」指向的机器人编号和「右手」指向的机器人编号。\n\n接下来 $m$ 行，按顺序表示机器人的「指令」，「指令」的格式见题目描述。", "outputFormat": "输出 $k$ 行，按顺序描述前 $k$ 条开始「执行」的指令的相关信息，在开始「执行」前输出，每条一行，格式如下：\n\n- 「摸鱼」时输出 `Robot <id> slacks off.`。其中 `<id>` 为一个整数，表示「执行」当前「指令」的机器人编号，下同。\n- 「移动」时输出 `Robot <id> moves its <side> hand towards Robot <id2>.`。其中 `<side>` 为 `left` 或 `right`，表示移动了哪只手（`left` 表示「左手」，`right` 表示「右手」）；`<id2>` 为一个整数，表示移动之后这只手指向的机器人的编号。\n- 「对调」时输出 `Robot <id> swaps a line of command with Robot <id2>.`。其中 `<id2>` 为一个整数，表示与之「对调」「指令」的机器人编号。\n- 「镜像」取反时输出 `Robot <id> modifies a line of command of Robot <id2>.`。其中 `<id2>` 为一个整数，表示被「镜像」取反「指令」的机器人编号。\n- 「替换」时输出 `Robot <id> replaces a line of command of Robot <id2>.`。其中 `<id2>` 为一个整数，表示被「替换」「指令」的机器人编号。\n- 「执行」 `ACTIVATE` 指令「激活」（区别于你的一圈又一圈的「激活」）时输出 `Robot <id> activates Robot <id2>.`。其中  `<id2>` 为一个整数，表示被「激活」的机器人编号。\n- `TRIGGER` 指令由于不会被「执行」就不需要输出，但当它们被「触发」时，仍然需要按照上面的格式输出对应的「基础指令」被「执行」的信息。", "hint": "### 样例 \\#1 解释\n\n`TRIGGER` 指令的「触发」时机是「执行」完毕之后。注意不能「触发」自己的 `TRIGGER` 指令。\n\n### 样例 \\#2 解释\n\n注意在「执行」前面的「指令」时后面的「指令」可能会发生更改，这时需要「执行」更改后的「指令」。\n\n### 样例 \\#3 解释\n\n`ACTIVATE` 指令「激活」另一个机器人时，当那个机器人的所有「指令」「执行」完毕后，该「指令」才算「执行」完毕。\n\n### 样例 \\#4 解释\n\n只有自己最靠前的满足条件的 `TRIGGER` 指令才会被 **「触发」**。\n\n### 样例 \\#5 解释\n\n无私的馈赠？有力的援助？\n\n### 子任务\n\n保证所有的指令的格式均正确。\n\n保证输入文件的长度不超过 $5\\mathtt{MB}$。\n\n保证能够「执行」至少 $k$ 条「指令」。\n\n保证 $2\\le n\\le 100$，$1\\le m \\le 10$，$1\\le k \\le 3\\times 10^5$。\n\n保证 $0\\le l_i,r_i<n$。\n\n保证 $0\\le h \\le 1$，$1\\le x,y \\le m$，$1\\le z<n$。所有输入的数都是整数。\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 初赛] 机器人", "background": "", "description": "有 $n$ 个机器人围成一圈，编号按照逆时针顺序分别为 $0\\sim n-1$。\n\n每个机器人有两只手。编号为 $i$ 的机器人初始「左手」指向编号 $l_i$ 的机器人，「右手」指向编号 $r_i$ 的机器人。\n\n所有的机器人内部都写有 $m$ 行「指令」，「指令」有以下这些形式：\n\n### 指令\n\n「指令」分为「基础指令」和「高级指令」两种。「高级指令」的功能会更复杂一些，但它们本质上没有多大区别。下面介绍这些「指令」的格式以及它们被「执行」时的效果。文中的“自己”一词均指拥有这条「指令」的机器人。\n\n#### 基础指令\n\n- `SLACKOFF`：**「摸鱼」**，即什么也不做。\n- `MOVE h z`：将第 $h$ 只手向逆时针方向 **「移动」** $z$ 个机器人的位置。当 $h=0$ 时表示「左手」，当 $h=1$ 时表示「右手」，下同。\n- `SWAP h x y`：将第 $h$ 只手指向的机器人的第 $x$ 行「指令」与自己的第 $y$ 行「指令」 **「对调」**。\n- `MIRROR h x`：将第 $h$ 只手指向的机器人的第 $x$ 行「指令」**「镜像」** 取反，即将「指令」中的 $h$ 取反（$0$ 变成 $1$，$1$ 变成 $0$）。特殊地，它对 `SLACKOFF` 指令没有效果；而对 `TRIGGER` 指令，会直接修改「触发」时「执行」的「指令」中的 $h$。\n- `REPLACE h x <COMMAND>`：将第 $h$ 只手指向的机器人的第 $x$ 行「指令」**「替换」** 为 `<COMMAND>`。其中 `<COMMAND>` 为一条完整的「指令」。\n\n#### 高级指令 \n\n- `ACTIVATE h`：**「激活」** 第 $h$ 只手指向的机器人，即按顺序「执行」那个机器人的所有「指令」。前一行「指令」「执行」完毕之后才会「执行」后一行。注意在「执行」前面的「指令」时后面的「指令」可能会发生更改，这时需要「执行」更改后的「指令」。当那个机器人的所有「指令」「执行」完毕后，该「指令」才算「执行」完毕。\n\n- `TRIGGER <COMMANDNAME>: <COMMAND>`：其中 `<COMMANDNAME>` 表示「指令」的名称，即一条「指令」中的第一个全大写单词；`<COMMAND>` 表示一条完整的「基础指令」。`TRIGGER` 指令不会被「执行」，即按顺序「执行」时会跳过该「指令」。但是，当一个 **其他** 机器人「执行」完一条「指令」之后，且「右手」指向自己的时候，自己最靠前的满足如下条件的 `TRIGGER` 指令（如果有）就会被 **「触发」**——「执行」一次对应的 `<COMMAND>`：\n\n  - `<COMMANDNAME>` 不为 `TRIGGER` 时，刚刚「执行」完毕的「指令」为 `<COMMANDNAME>` 指令；\n  - `<COMMANDNAME>` 为 `TRIGGER` 时，刚刚「执行」完毕的「指令」是 `TRIGGER` 指令被「触发」时「执行」的「指令」。\n\n  「执行」完毕后会回到原来的「执行」顺序中。\n\n你需要从 $0$ 号机器人开始按照编号顺序一圈又一圈地「激活」这些机器人，并输出「执行」的前 $k$ 条指令的有关信息。", "inputFormat": "第一行三个正整数 $n,m,k$。\n\n接下来按照编号从小到大的顺序表示 $n$ 个机器人的信息。\n\n对于每个机器人，第一行两个非负整数 $l_i,r_i$ 表示「左手」指向的机器人编号和「右手」指向的机器人编号。\n\n接下来 $m$ 行，按顺序表示机器人的「指令」，「指令」的格式见题目描述。", "outputFormat": "输出 $k$ 行，按顺序描述前 $k$ 条开始「执行」的指令的相关信息，在开始「执行」前输出，每条一行，格式如下：\n\n- 「摸鱼」时输出 `Robot <id> slacks off.`。其中 `<id>` 为一个整数，表示「执行」当前「指令」的机器人编号，下同。\n- 「移动」时输出 `Robot <id> moves its <side> hand towards Robot <id2>.`。其中 `<side>` 为 `left` 或 `right`，表示移动了哪只手（`left` 表示「左手」，`right` 表示「右手」）；`<id2>` 为一个整数，表示移动之后这只手指向的机器人的编号。\n- 「对调」时输出 `Robot <id> swaps a line of command with Robot <id2>.`。其中 `<id2>` 为一个整数，表示与之「对调」「指令」的机器人编号。\n- 「镜像」取反时输出 `Robot <id> modifies a line of command of Robot <id2>.`。其中 `<id2>` 为一个整数，表示被「镜像」取反「指令」的机器人编号。\n- 「替换」时输出 `Robot <id> replaces a line of command of Robot <id2>.`。其中 `<id2>` 为一个整数，表示被「替换」「指令」的机器人编号。\n- 「执行」 `ACTIVATE` 指令「激活」（区别于你的一圈又一圈的「激活」）时输出 `Robot <id> activates Robot <id2>.`。其中  `<id2>` 为一个整数，表示被「激活」的机器人编号。\n- `TRIGGER` 指令由于不会被「执行」就不需要输出，但当它们被「触发」时，仍然需要按照上面的格式输出对应的「基础指令」被「执行」的信息。", "hint": "### 样例 \\#1 解释\n\n`TRIGGER` 指令的「触发」时机是「执行」完毕之后。注意不能「触发」自己的 `TRIGGER` 指令。\n\n### 样例 \\#2 解释\n\n注意在「执行」前面的「指令」时后面的「指令」可能会发生更改，这时需要「执行」更改后的「指令」。\n\n### 样例 \\#3 解释\n\n`ACTIVATE` 指令「激活」另一个机器人时，当那个机器人的所有「指令」「执行」完毕后，该「指令」才算「执行」完毕。\n\n### 样例 \\#4 解释\n\n只有自己最靠前的满足条件的 `TRIGGER` 指令才会被 **「触发」**。\n\n### 样例 \\#5 解释\n\n无私的馈赠？有力的援助？\n\n### 子任务\n\n保证所有的指令的格式均正确。\n\n保证输入文件的长度不超过 $5\\mathtt{MB}$。\n\n保证能够「执行」至少 $k$ 条「指令」。\n\n保证 $2\\le n\\le 100$，$1\\le m \\le 10$，$1\\le k \\le 3\\times 10^5$。\n\n保证 $0\\le l_i,r_i<n$。\n\n保证 $0\\le h \\le 1$，$1\\le x,y \\le m$，$1\\le z<n$。所有输入的数都是整数。\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。\n", "locale": "zh-CN"}}}
{"pid": "P9967", "type": "P", "difficulty": 6, "samples": [["5 6 4\n1 1 3 3\n15 9 7 1\n4 2 8 6\n3\n3\n1\n2\n2\n4\n", "91\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2024", "树形 DP", "THUPC"], "title": "[THUPC 2024 初赛] 采矿", "background": "_“我已经买不起第二个机器人了。”_\n\n_“那就雇点人来凑数吧。注意别给死里头。”_", "description": "你是一个矿坑老板。\n\n你的矿坑是二叉树形结构，有 $n$ 个节点。$1$ 号点为地面，对于所有的 $2\\le i\\le n$，$i$ 号节点与更浅层的 $f_i$ 号节点通过通道相连，其中 $f_i<i$，且相同的 $f_i$ 最多出现两次。矿坑的不同节点的产量和开采难度均不相同。对于 $i$ 号节点 $(2\\le i\\le n)$，如果派一个机器人开采，一单位时间内能有 $r_i$ 的产出；如果派一个人类开采，一单位时间内能有 $p_i$ 的产出。地面没有产出。\n\n你有一个机器人，初始位于 $s$ 号节点。你的矿坑里初始没有人类工人。\n\n所有通道与节点都十分狭窄，每个节点都只能容下一名工人（工人包括人类和机器人），每个通道也只能恰好容一名工人通过。在移动的任何时刻，只能有最多一名工人在通道中，其余工人都必须在节点上。\n\n你现在有 $q$ 条计划需要按顺序执行。每个计划分为准备、执行、调整、开采四个阶段。\n\n在准备阶段，人类可以在满足上述移动规则的前提下任意移动，但不能进入或离开矿坑（矿坑内的工人到达 $1$ 号节点不算离开矿坑），因为你在看着他们；移动的顺序和次数均没有限制。机器人不能移动。\n\n在执行阶段，不同计划需要做的事情可能不同，共分为 $4$ 种：\n\n1. 机器人只能沿通道向**更浅**的方向移动，且至少需要经过一条通道。人类不能移动。\n2. 机器人只能沿通道向**更深**的方向移动，且至少需要经过一条通道。人类不能移动。\n3. 使一名人类从 $1$ 号节点进入矿坑（这意味着该阶段开始时 $1$ 号节点上必须没有工人）。除此之外所有工人都不能移动。\n4. 使一名人类从 $1$ 号节点移出矿坑（这意味着该阶段开始时 $1$ 号节点上必须有一名人类）。除此之外所有工人都不能移动。\n\n在调整阶段，限制与准备阶段相同。人类可以在满足上述移动规则的前提下任意移动，但不能进入或离开矿坑；移动的顺序和次数均没有限制。机器人不能移动。\n\n在开采阶段，所有的工人会采一单位时间的矿。所有有工人的非地面节点会根据位于该节点的工人种类计算产出。没有工人的节点没有产出。该计划的产出为所有节点的产出之和。\n\n问按顺序执行完所有计划之后，你所有计划的产出之和最多可以达到多少。", "inputFormat": "第一行三个正整数 $n,q,s$。\n\n第二行 $n-1$ 个整数，其中第 $i$（$1\\le i<n$，下同）个表示 $f_{i+1}$。\n\n第三行 $n-1$ 个整数，其中第 $i$ 个表示 $r_{i+1}$。\n\n第四行 $n-1$ 个整数，其中第 $i$ 个表示 $p_{i+1}$。\n\n接下来 $q$ 行，每行一个整数表示计划的种类，其中第 $i$ 个整数表示第 $i$ 条计划：\n\n- `1` 表示第一种计划：将机器人向更浅的方向移动；\n- `2` 表示第二种计划：将机器人向更深的方向移动；\n- `3` 表示第三种计划：将一名人类从 $1$ 号节点送入矿坑；\n- `4` 表示第四种计划：将一名人类从 $1$ 号节点移出矿坑。", "outputFormat": "如果无论如何你都无法完成你的计划，输出一行 `No solution.`。否则输出一行一个整数，表示你的产出之和的最大值。", "hint": "### 样例 \\#1 解释\n\n一个最优解如下：（一些没有移动的阶段略过不提）\n\n第一个计划的调整阶段：将刚送入 $1$ 号点的人类移动两次到 $5$ 号点。\n\n第一个计划的开采阶段：机器人产出为 $7$，人类产出为 $6$。\n\n第二个计划的调整阶段：将刚送入 $1$ 号点的人类移动到 $2$ 号点。\n\n第二个计划的开采阶段：机器人产出为 $7$，人类产出为 $4+6=10$。\n\n第三个计划的执行阶段：将机器人移动至 $1$ 号点。\n\n第三个计划的调整阶段：将一名人类从 $5$ 号点移动至 $4$ 号点。\n\n第三个计划的开采阶段：机器人产出为 $0$，人类产出为 $4+8=12$。\n\n第四个计划的准备阶段：将一名人类从 $4$ 号点移动至 $5$ 号点。\n\n第四个计划的执行阶段：将机器人移动至 $3$ 号点。\n\n第四个计划的开采阶段：机器人产出为 $9$，人类产出为 $4+6=10$。\n\n第五个计划的执行阶段：将机器人移动至 $4$ 号点。\n\n第五个计划的开采阶段：机器人产出为 $7$，人类产出为 $4+6=10$。\n\n第六个计划的准备阶段：将一名人类从 $2$ 号点移动至 $1$ 号点。\n\n第六个计划的开采阶段：机器人产出为 $7$，人类产出为 $6$。\n\n总的产出为 $7+6+7+10+0+12+9+10+7+10+7+6=91$。\n\n### 子任务\n\n保证 $2\\le n\\le 301$，$1\\le q \\le 600$，$1\\le s\\le n$。\n\n保证 $1\\le f_i < i$，$0\\le r_i,p_i \\le 10^9$。\n\n保证相同的 $f_i$ 最多出现两次。\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 初赛] 采矿", "background": "_“我已经买不起第二个机器人了。”_\n\n_“那就雇点人来凑数吧。注意别给死里头。”_", "description": "你是一个矿坑老板。\n\n你的矿坑是二叉树形结构，有 $n$ 个节点。$1$ 号点为地面，对于所有的 $2\\le i\\le n$，$i$ 号节点与更浅层的 $f_i$ 号节点通过通道相连，其中 $f_i<i$，且相同的 $f_i$ 最多出现两次。矿坑的不同节点的产量和开采难度均不相同。对于 $i$ 号节点 $(2\\le i\\le n)$，如果派一个机器人开采，一单位时间内能有 $r_i$ 的产出；如果派一个人类开采，一单位时间内能有 $p_i$ 的产出。地面没有产出。\n\n你有一个机器人，初始位于 $s$ 号节点。你的矿坑里初始没有人类工人。\n\n所有通道与节点都十分狭窄，每个节点都只能容下一名工人（工人包括人类和机器人），每个通道也只能恰好容一名工人通过。在移动的任何时刻，只能有最多一名工人在通道中，其余工人都必须在节点上。\n\n你现在有 $q$ 条计划需要按顺序执行。每个计划分为准备、执行、调整、开采四个阶段。\n\n在准备阶段，人类可以在满足上述移动规则的前提下任意移动，但不能进入或离开矿坑（矿坑内的工人到达 $1$ 号节点不算离开矿坑），因为你在看着他们；移动的顺序和次数均没有限制。机器人不能移动。\n\n在执行阶段，不同计划需要做的事情可能不同，共分为 $4$ 种：\n\n1. 机器人只能沿通道向**更浅**的方向移动，且至少需要经过一条通道。人类不能移动。\n2. 机器人只能沿通道向**更深**的方向移动，且至少需要经过一条通道。人类不能移动。\n3. 使一名人类从 $1$ 号节点进入矿坑（这意味着该阶段开始时 $1$ 号节点上必须没有工人）。除此之外所有工人都不能移动。\n4. 使一名人类从 $1$ 号节点移出矿坑（这意味着该阶段开始时 $1$ 号节点上必须有一名人类）。除此之外所有工人都不能移动。\n\n在调整阶段，限制与准备阶段相同。人类可以在满足上述移动规则的前提下任意移动，但不能进入或离开矿坑；移动的顺序和次数均没有限制。机器人不能移动。\n\n在开采阶段，所有的工人会采一单位时间的矿。所有有工人的非地面节点会根据位于该节点的工人种类计算产出。没有工人的节点没有产出。该计划的产出为所有节点的产出之和。\n\n问按顺序执行完所有计划之后，你所有计划的产出之和最多可以达到多少。", "inputFormat": "第一行三个正整数 $n,q,s$。\n\n第二行 $n-1$ 个整数，其中第 $i$（$1\\le i<n$，下同）个表示 $f_{i+1}$。\n\n第三行 $n-1$ 个整数，其中第 $i$ 个表示 $r_{i+1}$。\n\n第四行 $n-1$ 个整数，其中第 $i$ 个表示 $p_{i+1}$。\n\n接下来 $q$ 行，每行一个整数表示计划的种类，其中第 $i$ 个整数表示第 $i$ 条计划：\n\n- `1` 表示第一种计划：将机器人向更浅的方向移动；\n- `2` 表示第二种计划：将机器人向更深的方向移动；\n- `3` 表示第三种计划：将一名人类从 $1$ 号节点送入矿坑；\n- `4` 表示第四种计划：将一名人类从 $1$ 号节点移出矿坑。", "outputFormat": "如果无论如何你都无法完成你的计划，输出一行 `No solution.`。否则输出一行一个整数，表示你的产出之和的最大值。", "hint": "### 样例 \\#1 解释\n\n一个最优解如下：（一些没有移动的阶段略过不提）\n\n第一个计划的调整阶段：将刚送入 $1$ 号点的人类移动两次到 $5$ 号点。\n\n第一个计划的开采阶段：机器人产出为 $7$，人类产出为 $6$。\n\n第二个计划的调整阶段：将刚送入 $1$ 号点的人类移动到 $2$ 号点。\n\n第二个计划的开采阶段：机器人产出为 $7$，人类产出为 $4+6=10$。\n\n第三个计划的执行阶段：将机器人移动至 $1$ 号点。\n\n第三个计划的调整阶段：将一名人类从 $5$ 号点移动至 $4$ 号点。\n\n第三个计划的开采阶段：机器人产出为 $0$，人类产出为 $4+8=12$。\n\n第四个计划的准备阶段：将一名人类从 $4$ 号点移动至 $5$ 号点。\n\n第四个计划的执行阶段：将机器人移动至 $3$ 号点。\n\n第四个计划的开采阶段：机器人产出为 $9$，人类产出为 $4+6=10$。\n\n第五个计划的执行阶段：将机器人移动至 $4$ 号点。\n\n第五个计划的开采阶段：机器人产出为 $7$，人类产出为 $4+6=10$。\n\n第六个计划的准备阶段：将一名人类从 $2$ 号点移动至 $1$ 号点。\n\n第六个计划的开采阶段：机器人产出为 $7$，人类产出为 $6$。\n\n总的产出为 $7+6+7+10+0+12+9+10+7+10+7+6=91$。\n\n### 子任务\n\n保证 $2\\le n\\le 301$，$1\\le q \\le 600$，$1\\le s\\le n$。\n\n保证 $1\\le f_i < i$，$0\\le r_i,p_i \\le 10^9$。\n\n保证相同的 $f_i$ 最多出现两次。\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN"}}}
{"pid": "P9968", "type": "P", "difficulty": 5, "samples": [["20\n01001101101101110010\n", "2 11\n5 5\n4 5\n11 1\n4 2\n7 1\n-1 0\n-1 0\n-1 0\n-1 0\n-1 0\n-1 0\n-1 0\n-1 0\n-1 0\n-1 0\n-1 0\n-1 0\n-1 0\n-1 0\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 初赛] 二进制", "background": "", "description": "今天也是喜欢二进制串的一天，小 F 开始玩二进制串的游戏。\n\n小 F 给出了一个这里有一个长为 $n$ 的二进制串 $s$，下标从 $1$ 到 $n$，且 $\\forall i\\in[1,n],s_i\\in \\{0,1\\}$，他想要删除若干二进制子串。\n\n具体的，小 F 做出了 $n$ 次尝试。\n\n在第 $i\\in[1,n]$ 次尝试中，他会先写出正整数 $i$ 的二进制串表示 $t$（无前导零，左侧为高位，例如 $10$ 可以写为 $1010$）。\n\n随后找到这个二进制表示 $t$ 在 $s$ 中从左到右 **第一次** 出现的位置，并删除这个串。\n\n注意，删除后左右部分的串会拼接在一起 **形成一个新的串**，请注意新串下标的改变。\n\n若当前 $t$ 不在 $s$ 中存在，则小 F 对串 $s$ 不作出改变。\n\n你需要回答每一次尝试中，$t$ 在 $s$ 中第一次出现的位置的左端点以及 $t$ 在 $s$ 中出现了多少次。\n\n定义两次出现不同当且仅当出现的位置的左端点不同。\n\n请注意输入输出效率。", "inputFormat": "第一行一个正整数 $n$（$1\\leq n\\leq 1000000$）。\n\n第二行一个长度为 $n$ 的字符串 $s$。保证 $\\forall i\\in[1,n], s_i \\in \\{0, 1\\}$。", "outputFormat": "输出共 $n$ 行，每行两个整数，第 $i$ 行表示小 F 进行第 $i$ 次尝试时开头端点的位置以及相应的字符串出现的次数。\n\n若这次尝试失败，则当前行输出 $-1\\ 0$。", "hint": "### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 初赛] 二进制", "background": "", "description": "今天也是喜欢二进制串的一天，小 F 开始玩二进制串的游戏。\n\n小 F 给出了一个这里有一个长为 $n$ 的二进制串 $s$，下标从 $1$ 到 $n$，且 $\\forall i\\in[1,n],s_i\\in \\{0,1\\}$，他想要删除若干二进制子串。\n\n具体的，小 F 做出了 $n$ 次尝试。\n\n在第 $i\\in[1,n]$ 次尝试中，他会先写出正整数 $i$ 的二进制串表示 $t$（无前导零，左侧为高位，例如 $10$ 可以写为 $1010$）。\n\n随后找到这个二进制表示 $t$ 在 $s$ 中从左到右 **第一次** 出现的位置，并删除这个串。\n\n注意，删除后左右部分的串会拼接在一起 **形成一个新的串**，请注意新串下标的改变。\n\n若当前 $t$ 不在 $s$ 中存在，则小 F 对串 $s$ 不作出改变。\n\n你需要回答每一次尝试中，$t$ 在 $s$ 中第一次出现的位置的左端点以及 $t$ 在 $s$ 中出现了多少次。\n\n定义两次出现不同当且仅当出现的位置的左端点不同。\n\n请注意输入输出效率。", "inputFormat": "第一行一个正整数 $n$（$1\\leq n\\leq 1000000$）。\n\n第二行一个长度为 $n$ 的字符串 $s$。保证 $\\forall i\\in[1,n], s_i \\in \\{0, 1\\}$。", "outputFormat": "输出共 $n$ 行，每行两个整数，第 $i$ 行表示小 F 进行第 $i$ 次尝试时开头端点的位置以及相应的字符串出现的次数。\n\n若这次尝试失败，则当前行输出 $-1\\ 0$。", "hint": "### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN"}}}
{"pid": "P9969", "type": "P", "difficulty": 6, "samples": [["5\n11011\n", "5\n1 1\n1 4\n2 1 2\n3 3 1\n2 3 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "Special Judge", "THUPC"], "title": "[THUPC 2024 初赛] 分治乘法", "background": "", "description": "小艾想要挑战分治乘法。TA 将策略抽象成了如下问题：\n\n现在给定一个目标集合 $T$，该集合是 $\\{1,\\dots,n\\}$ 的一个子集（$1\\leq n\\leq 5\\times 10^5$）。你需要通过一系列操作构造一些集合最后得到 $T$，具体来说有以下三种操作：\n\n- 创造一个大小为一的集合 $|S|=1$。\n- 将已经被构造出的两个不交集合 $A, B$ 并起来，得到 $A\\cup B$。\n- 将已经被构造出的一个集合 $A$ 进行平移，也即 $A+x = \\{ a+x : a\\in A \\}$。\n\n一个已经被构造出的集合可以在之后被使用多次。同时你需要保证操作过程中出现的所有集合都是 $\\{1,\\dots,n\\}$ 的子集。\n\n你的代价是构造出的所有集合的大小之和，你不需要最小化代价，只需要让代价控制不超过 $5\\times 10^6$ 即可。你用的操作数量也不应超过 $10^6$。", "inputFormat": "第一行输入一个正整数 $n$。\n\n接下来一行输入一个 `01` 串，长度为 $n$，第 $x$ 位为 `1` 表示 $x\\in T$，否则 $x\\notin T$，保证 $T$ 非空。", "outputFormat": "第一行输出一个正整数 $m$ 表示你使用的操作数量。\n\n接下来 $m$ 行，每行描述一个操作，设第 $i$ 次操作得到的集合为 $T_i$：\n\n- `1 x` 表示创造一个大小为一的集合 $\\{x\\}$。\n- `2 x y` 表示将不交集合 $T_x, T_y$ 并起来。\n- `3 x y` 表示将已经被构造出的一个集合进行平移，也即 $T_x+y$。\n\n你需要保证所有操作满足题目要求，并且最后一次操作产生的集合是 $T$。", "hint": "### 样例 \\#1 解释\n\n- 第一次操作：创造集合 $T_1=\\{1\\}$。\n- 第二次操作：创造集合 $T_2=\\{4\\}$。\n- 第三次操作：将 $T_1, T_2$ 并起来，得到 $T_3=\\{1,4\\}$。\n- 第四次操作：将 $T_3$ 平移 $1$，得到 $T_4=\\{2,5\\}$。\n- 第五次操作：将 $T_3, T_4$ 并起来，得到 $T_5=\\{1,2,4,5\\}$。这就得到了 $T$。\n\n这个方案的总代价是 $1 + 1 + 2 + 2 + 4 = 10$。\n\n### 提示\n\n如果你的复杂度是好的，请相信常数。\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 初赛] 分治乘法", "background": "", "description": "小艾想要挑战分治乘法。TA 将策略抽象成了如下问题：\n\n现在给定一个目标集合 $T$，该集合是 $\\{1,\\dots,n\\}$ 的一个子集（$1\\leq n\\leq 5\\times 10^5$）。你需要通过一系列操作构造一些集合最后得到 $T$，具体来说有以下三种操作：\n\n- 创造一个大小为一的集合 $|S|=1$。\n- 将已经被构造出的两个不交集合 $A, B$ 并起来，得到 $A\\cup B$。\n- 将已经被构造出的一个集合 $A$ 进行平移，也即 $A+x = \\{ a+x : a\\in A \\}$。\n\n一个已经被构造出的集合可以在之后被使用多次。同时你需要保证操作过程中出现的所有集合都是 $\\{1,\\dots,n\\}$ 的子集。\n\n你的代价是构造出的所有集合的大小之和，你不需要最小化代价，只需要让代价控制不超过 $5\\times 10^6$ 即可。你用的操作数量也不应超过 $10^6$。", "inputFormat": "第一行输入一个正整数 $n$。\n\n接下来一行输入一个 `01` 串，长度为 $n$，第 $x$ 位为 `1` 表示 $x\\in T$，否则 $x\\notin T$，保证 $T$ 非空。", "outputFormat": "第一行输出一个正整数 $m$ 表示你使用的操作数量。\n\n接下来 $m$ 行，每行描述一个操作，设第 $i$ 次操作得到的集合为 $T_i$：\n\n- `1 x` 表示创造一个大小为一的集合 $\\{x\\}$。\n- `2 x y` 表示将不交集合 $T_x, T_y$ 并起来。\n- `3 x y` 表示将已经被构造出的一个集合进行平移，也即 $T_x+y$。\n\n你需要保证所有操作满足题目要求，并且最后一次操作产生的集合是 $T$。", "hint": "### 样例 \\#1 解释\n\n- 第一次操作：创造集合 $T_1=\\{1\\}$。\n- 第二次操作：创造集合 $T_2=\\{4\\}$。\n- 第三次操作：将 $T_1, T_2$ 并起来，得到 $T_3=\\{1,4\\}$。\n- 第四次操作：将 $T_3$ 平移 $1$，得到 $T_4=\\{2,5\\}$。\n- 第五次操作：将 $T_3, T_4$ 并起来，得到 $T_5=\\{1,2,4,5\\}$。这就得到了 $T$。\n\n这个方案的总代价是 $1 + 1 + 2 + 2 + 4 = 10$。\n\n### 提示\n\n如果你的复杂度是好的，请相信常数。\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN"}}}
{"pid": "P9970", "type": "P", "difficulty": 6, "samples": [["6\n0 0 0 1 2 3\n", "2 3 4 0 0 0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2024", "THUPC"], "title": "[THUPC 2024 初赛] 套娃", "background": "", "description": "我们定义一个集合的 $\\operatorname{mex}$ 是最小的不在 $S$ 中的非负整数。\n\n给定一个序列 $a_1,\\dots,a_n$，对于每个 $1\\leq k\\leq n$，我们按照如下方式定义 $b_k$：\n\n- 对于 $a$ 的所有长为 $k$ 的子区间，求出这个子区间构成的数集的 $\\operatorname{mex}$。\n- 对于求出的所有 $\\operatorname{mex}$，求出这个数集自己的 $\\operatorname{mex}$，记为 $b_k$。\n\n请你求出序列 $b$。\n", "inputFormat": "第一行输入一个正整数 $n$（$1\\leq n\\leq 10^5$）。\n\n第二行输入 $n$ 个整数 $a_1,\\dots,a_n$（$0\\leq a_i\\leq n$）。", "outputFormat": "一行输出 $n$ 个整数 $b_1,\\dots,b_n$。", "hint": "### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 初赛] 套娃", "background": "", "description": "我们定义一个集合的 $\\operatorname{mex}$ 是最小的不在 $S$ 中的非负整数。\n\n给定一个序列 $a_1,\\dots,a_n$，对于每个 $1\\leq k\\leq n$，我们按照如下方式定义 $b_k$：\n\n- 对于 $a$ 的所有长为 $k$ 的子区间，求出这个子区间构成的数集的 $\\operatorname{mex}$。\n- 对于求出的所有 $\\operatorname{mex}$，求出这个数集自己的 $\\operatorname{mex}$，记为 $b_k$。\n\n请你求出序列 $b$。\n", "inputFormat": "第一行输入一个正整数 $n$（$1\\leq n\\leq 10^5$）。\n\n第二行输入 $n$ 个整数 $a_1,\\dots,a_n$（$0\\leq a_i\\leq n$）。", "outputFormat": "一行输出 $n$ 个整数 $b_1,\\dots,b_n$。", "hint": "### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN"}}}
{"pid": "P9971", "type": "P", "difficulty": 4, "samples": [["3\n.....\noo...\n.....\n.....\n.....\n.o...\n.o...\n.....\n.....\n.....\n.....\n.....\n.....\n.ooo.\n.....\n", "Far\nFar\nAway\n"]], "limits": {"time": [1000, 1000], "memory": [524288, 524288]}, "tags": ["搜索", "博弈论", "2024", "THUPC"], "title": "[THUPC 2024 初赛] 三步棋", "background": "昼短夜长冬至近。江冽漆黑，但见东云粉。窗外惺忪鸥鹭阵，室中香漫晨炊奋。\n\n朝肄暮劳催彼盹。宵寂观书，灯烬方安寝。请替君劳分重任，逍遥共舞生辰顺。", "description": "K 家里有一条不成文的规矩。如果家里只有 K 和 H 两个人，那么两个人会通过一种叫作“三步棋”的游戏来决定谁做饭。三步棋的规则与五子棋有一些相似之处。众所周知，五子棋是一种先连出五枚己方棋子者获胜的游戏。与五子棋相同的是，三步棋中双方也轮流在网格状的棋盘上摆放棋子，并根据是否连成指定的图案决定胜负。与五子棋不同的是：\n\n1. 三步棋不区分双方的棋子，即可以认为双方执同色棋子进行游戏；\n\n2. 在判定时，指定的图案不能旋转；\n\n3. 如果连成指定的图案时，棋盘上的棋子数量恰好为 $3$ 的倍数，则连成指定的图案的一方获胜，否则判定该方负（即对方获胜）。\n\n例如，如果指定的图案为\n\n```\n.o\noo\n```\n\n且当前盘面为\n\n```\no..o.\no.o..\noo...\no.o..\no..o.\n```\n\n时，认为没有连成给定的折线形图案，其中 `o` 表示棋子，`.` 表示空格；但若接下来在第二行第二列放一枚棋子，则连成了给定的图案，对应的棋子使用 `@` 表示：\n\n```\no..o.\no@o..\n@@...\no.o..\no..o.\n```\n\n此时盘面上恰有 $11$ 枚棋子，而 $11$ 不是 $3$ 的倍数，所以判定放这枚棋子的玩家，也即先手输掉本局。\n\n在 K 家，为了节约时间，通常使用 $5\\times 5$ 的初始为空的棋盘进行三步棋。同时，每次也只会随机选择一个由不超过 $4$ 枚棋子组成的四连通图案。显然三步棋不存在平局，所以 K 和 H 约定由输的一方负责做饭。K 想知道，如果自己和 H 都足够聪明，那么以选中的图案进行的三步棋游戏是否为**先手必胜**；因为如果她更容易赢，她就要偷偷地给自己的妹妹放水。", "inputFormat": "输入文件包含多组数据。\n\n输入的第一行包含一个正整数 $T$，表示数据组数。保证 $1\\le T\\le 200$。\n\n对于每组数据，输入包含 $5$ 行，每行包括一个长度为 $5$ 且仅含 `.` 及 `o` 的字符串，表示指定的图案。保证每组数据中 `o` 至少出现一次，且所有 `o` 组成一个大小不超过 $4$ 的四连通块。", "outputFormat": "对于每组数据输出一行。如果输入的图案为**先手必胜**，则输出 `Far`，否则输出 `Away`。", "hint": "### 样例 \\#1 解释\n\n该样例包含三组数据。\n\n第一组数据输入的图案为 $1$ 行 $2$ 列的 `oo`。显然，无论先手将棋子放在棋盘上的哪个位置，后手都只有两种策略：\n\n- 和先手的棋子连成 `oo`，此时棋盘上只有 $2$ 枚棋子，故后手立即输掉游戏；\n\n- 不和先手的棋子连成 `oo`，但是接下来轮到先手时，先手可以任意连成 `oo`，此时棋盘上恰有 $3$ 枚棋子，故先手取胜。\n\n无论是哪种策略，后手都无法取胜，故对于 `oo` 而言**先手必胜**。\n\n第二组数据输入的图案为 $2$ 行 $1$ 列的图案，与 `oo` 同理，可知为**先手必胜**。\n\n第三组数据输入的图案为 $1$ 行 $3$ 列的 `ooo`，可以证明为先手必败。\n\n### 子任务\n\n保证 $1\\le T\\le 200$。对于每组数据，保证输入的 $5\\times 5$ 的由 `.` 和 `o` 组成的字符矩阵中至少含有一个 `o`，且所有 `o` 组成一个大小不超过 $4$ 的四连通块。\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 初赛] 三步棋", "background": "昼短夜长冬至近。江冽漆黑，但见东云粉。窗外惺忪鸥鹭阵，室中香漫晨炊奋。\n\n朝肄暮劳催彼盹。宵寂观书，灯烬方安寝。请替君劳分重任，逍遥共舞生辰顺。", "description": "K 家里有一条不成文的规矩。如果家里只有 K 和 H 两个人，那么两个人会通过一种叫作“三步棋”的游戏来决定谁做饭。三步棋的规则与五子棋有一些相似之处。众所周知，五子棋是一种先连出五枚己方棋子者获胜的游戏。与五子棋相同的是，三步棋中双方也轮流在网格状的棋盘上摆放棋子，并根据是否连成指定的图案决定胜负。与五子棋不同的是：\n\n1. 三步棋不区分双方的棋子，即可以认为双方执同色棋子进行游戏；\n\n2. 在判定时，指定的图案不能旋转；\n\n3. 如果连成指定的图案时，棋盘上的棋子数量恰好为 $3$ 的倍数，则连成指定的图案的一方获胜，否则判定该方负（即对方获胜）。\n\n例如，如果指定的图案为\n\n```\n.o\noo\n```\n\n且当前盘面为\n\n```\no..o.\no.o..\noo...\no.o..\no..o.\n```\n\n时，认为没有连成给定的折线形图案，其中 `o` 表示棋子，`.` 表示空格；但若接下来在第二行第二列放一枚棋子，则连成了给定的图案，对应的棋子使用 `@` 表示：\n\n```\no..o.\no@o..\n@@...\no.o..\no..o.\n```\n\n此时盘面上恰有 $11$ 枚棋子，而 $11$ 不是 $3$ 的倍数，所以判定放这枚棋子的玩家，也即先手输掉本局。\n\n在 K 家，为了节约时间，通常使用 $5\\times 5$ 的初始为空的棋盘进行三步棋。同时，每次也只会随机选择一个由不超过 $4$ 枚棋子组成的四连通图案。显然三步棋不存在平局，所以 K 和 H 约定由输的一方负责做饭。K 想知道，如果自己和 H 都足够聪明，那么以选中的图案进行的三步棋游戏是否为**先手必胜**；因为如果她更容易赢，她就要偷偷地给自己的妹妹放水。", "inputFormat": "输入文件包含多组数据。\n\n输入的第一行包含一个正整数 $T$，表示数据组数。保证 $1\\le T\\le 200$。\n\n对于每组数据，输入包含 $5$ 行，每行包括一个长度为 $5$ 且仅含 `.` 及 `o` 的字符串，表示指定的图案。保证每组数据中 `o` 至少出现一次，且所有 `o` 组成一个大小不超过 $4$ 的四连通块。", "outputFormat": "对于每组数据输出一行。如果输入的图案为**先手必胜**，则输出 `Far`，否则输出 `Away`。", "hint": "### 样例 \\#1 解释\n\n该样例包含三组数据。\n\n第一组数据输入的图案为 $1$ 行 $2$ 列的 `oo`。显然，无论先手将棋子放在棋盘上的哪个位置，后手都只有两种策略：\n\n- 和先手的棋子连成 `oo`，此时棋盘上只有 $2$ 枚棋子，故后手立即输掉游戏；\n\n- 不和先手的棋子连成 `oo`，但是接下来轮到先手时，先手可以任意连成 `oo`，此时棋盘上恰有 $3$ 枚棋子，故先手取胜。\n\n无论是哪种策略，后手都无法取胜，故对于 `oo` 而言**先手必胜**。\n\n第二组数据输入的图案为 $2$ 行 $1$ 列的图案，与 `oo` 同理，可知为**先手必胜**。\n\n第三组数据输入的图案为 $1$ 行 $3$ 列的 `ooo`，可以证明为先手必败。\n\n### 子任务\n\n保证 $1\\le T\\le 200$。对于每组数据，保证输入的 $5\\times 5$ 的由 `.` 和 `o` 组成的字符矩阵中至少含有一个 `o`，且所有 `o` 组成一个大小不超过 $4$ 的四连通块。\n\n### 题目使用协议\n\n来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。\n\n以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）\n\n1. 任何单位或个人都可以免费使用或转载本仓库的题目；\n\n2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；\n\n3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。", "locale": "zh-CN"}}}
{"pid": "P9972", "type": "P", "difficulty": 7, "samples": [["6 11 1 1 6\n1.0000 1.0000\n1.0000 0.0000 10.0000\n0.7500 0.2500 6.0000\n0.5000 0.0000 1.0000\n0.5000 0.5000 1.0000\n0.2500 0.2500 6.0000\n0.0000 0.0000 10.0000\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n3 5\n3 6\n4 5\n4 6\n5 6\n", "8.105694691387022\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "2024", "Special Judge", "THUPC"], "title": "[THUPC 2024 初赛] 勇闯末日塔", "background": "安宁顷刻今将逝，末日黑云伺隙来。宿命无情何所惧？越其止境冀花开。\n\n为了执行毁灭世界的疯狂计划，一位占用了已死之人躯壳的神秘男子在这颗蓝色的星球上创造出了无数末日塔。这些末日塔会散发出浓密的以太射线，对末日塔附近的几乎所有生物进行精神控制，只有受到特殊加护的人才能免受以太射线控制。\n\n一些受到加护的义勇队对这些末日塔进行了调查，其结果显示：这些末日塔组成了复杂的以太传输网络，持续不断地从大地中吸收以太，并将以太传输到位于帝国的中枢塔。\n\n一队持有特殊加护的英雄决定闯入其中一些末日塔，以期彻底调查并尝试破坏这些末日塔。英雄们破坏掉进入的末日塔后，以太传输网络就会受到影响，因此大家希望选择一些末日塔，将其破坏后能使得网络的最大传输容量降到最低。\n\n作为勇闯末日塔小队的先锋，你再次阅读了小队目前所掌握的所有信息。这次大胆的行动计划最终能否拯救这个世界，眼下恐怕谁都无法事先料定。但为了这颗星球的未来，我们只能放手一搏。", "description": "星球的表面是一个中心位于 $(0, 0, 0)$，半径为 $R$ 的完美球面。星球表面上共有 $N$ 座末日塔，这些令人毛骨悚然的塔构成了以太传输网络的所有节点。\n\n- 末日塔的高度远小于星球半径，因此我们认为第 $i (1 \\le i \\le N)$ 座塔是球面上的一个点 $\\left(x_i, y_i, z_i\\right)$。第 $i$ 座塔的以太传输效率为 $q_i$。\n- 保证 $N$ 座末日塔的位置两两不同。在这 $N$ 座末日塔中，$s$ 号塔是以太吸收点，$t$ 号塔是位于帝国的中枢塔；这两座塔的以太浓度显著高于其它的末日塔，因此只能闯入这两座塔之外的末日塔。\n\n$N$ 座末日塔之间共有 $M$ 条传输通道。第 $j (1 \\le j \\le M)$ 条传输通道连接 $u_j, v_j$ 两座末日塔，让它们可以互相传输以太。\n\n- 传输通道是双向的，但单位时间内以太的流向必须是单向的。\n- 为了节省不必要的成本，传输通道的两端不会连接相同的塔，也不会有两条传输通道连接相同的末日塔对。\n- 为了降低传输距离，第 $i$ 条传输通道沿着 $u_j$ 和 $v_j$ 所在的大圆的劣弧铺设，故其**长度** $r_j$ 为两座末日塔在星球表面的球面距离。为了避免传输通道的互相干扰，**对于任意一条传输通道所对应的劣弧，其他传输通道所对应的劣弧只会在该劣弧的两端点上与该劣弧相交**。保证由同一条传输通道相连的两座末日塔的位置不是对跖点关系。\n  - 如果不知道大圆、劣弧、球面距离和对跖点是什么，可以参考题面最后的提示部分。\n\n受到传输效率和通道长度的影响，每条传输通道有各自传输以太的容量上限。\n\n- 具体而言，每个单位时间内，第 $j$ 条传输通道的**容量上限**为 $\\frac{Kq_{u_j} q_{v_j}}{r_j^2}$，其中 $K$ 是给定的常数，$q_{u_j}, q_{v_j}$ 为该传输通道两端的塔的传输效率，$r_j$ 为这条传输通道的长度。\n\n整张以太传输网络需要将 $s$ 号塔吸收的以太沿着传输通道传输到 $t$ 号塔，并使得单位时间内的以太传输量最大。为此，传输网络会自动确定一个以太传输方案，在满足所有传输通道容量上限的前提下，最大化这一传输量。\n\n- 换句话说，如果将末日塔看作图上的点，传输通道看作边，而传输通道的容量上限对应每条边的容量，那么以太的传输方案应该恰好为 $s$ 到 $t$ 的最大流。\n\n虽然没有任何人能保证闯入末日塔之后就一定能将其破坏，但作为勇闯末日塔小队的先锋，你还是想在出发之前计算一下，如果成功破坏了所有将要闯入的末日塔，传输网络单位时间的最大传输量将会降至多少。\n\n- 如果成功破坏了选择的末日塔，与其相连的所有传输通道的容量都将降至 $0$，其余传输通道容量不发生变化；此时传输网络会自动调节至一个在新的网络中传输量最大的新方案。\n- 在最理想的情况下，小队将有机会调查并破坏 $L$ 座末日塔。因此，需要事先选择 $L$ 座末日塔（均不能是 $s$ 或 $t$），使得当这 $L$ 座末日塔都被成功破坏时，传输网络的新的传输方案的以太传输量尽可能地小。", "inputFormat": "输入的第一行包括五个正整数 $N, M, L, s, t$（$3\\le N\\le 500$，$2\\le M\\le \\frac{N(N-1)}{2}$，$1\\le L\\le \\min\\{8,N-2\\}$，$1\\le s, t\\le N$），分别表示该传输网络包含的末日塔数量，传输通道数量，有机会闯入的末日塔数量，最主要的以太吸收塔的编号和中枢塔的编号。\n\n输入的第二行包括两个实数 $R, K$（$1\\le R\\le 10^3$，$1\\le K\\le 10^3$），分别表示星球的半径和计算以太容量时用到的常数。\n\n接下来 $N$ 行，每行三个实数 $a_i, b_i, q_i$（$0\\le a_i\\le 1$，$0\\le b_i< 2$，$1\\le q_i \\le 10^3$），描述第 $i$ 座末日塔的信息，其中 $q_i$ 表示第 $i$ 座末日塔的传输能力， $a_i$ 和 $b_i$ 共同描述末日塔的位置：令 $\\theta_i = \\pi a_i$，$\\varphi_i = \\pi b_i$（如果你习惯使用角度制而不是弧度制，可以将 $\\pi$ 改为 $180^\\circ$），则 $\\left(x_i, y_i, z_i\\right) = \\left(R \\sin\\theta_i \\cos\\varphi_i, R\\sin\\theta_i \\sin\\varphi_i, R\\cos\\theta_i\\right)$。保证末日塔的位置各不相同。\n\n最后 $M$ 行，每行两个正整数 $u_i, v_i$（$1\\le u_i, v_i\\le N$），表示一条传输通道连接的两座末日塔的编号。保证同一条传输通道连接的两座末日塔不相同且不互为对跖点，没有两条传输通道连接的是相同的末日塔对，且传输网络是连通的。\n\n保证输入的所有实数保留到小数点后第 $4$ 位。", "outputFormat": "输出一个实数，表示如果成功破坏了将要闯入的末日塔，新的传输网络单位时间的最大传输量。当你的输出与标准输出的相对误差或绝对误差不超过 $10^{-6}$ 时，我们认为你的输出是正确的。", "hint": "### 样例 \\#1 解释\n\n以太传输网络如下图所示。图中蓝色球面即为星球表面；紫色点为各末日塔，其中 $P_i$ 对应输入的第 $i$ 座末日塔；黄色的线表示各传输通道。\n\n![样例 1 示意图](https://cdn.luogu.com.cn/upload/image_hosting/4bynt5dl.png)\n\n原来的传输网络单位时间最大传输量为 $188/\\pi^2$。破坏第 $2$ 个末日塔或第 $5$ 个末日塔都能使新的传输网络单位时间的最大传输量降至 $80/\\pi^2$，而破坏第 $3$ 个末日塔或第 $4$ 个末日塔只能使新的传输网络单位时间的最大传输量降至 $94/\\pi^2$，所以应该选择第 $2$ 个或第 $5$ 个末日塔尝试破坏。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 初赛] 勇闯末日塔", "background": "安宁顷刻今将逝，末日黑云伺隙来。宿命无情何所惧？越其止境冀花开。\n\n为了执行毁灭世界的疯狂计划，一位占用了已死之人躯壳的神秘男子在这颗蓝色的星球上创造出了无数末日塔。这些末日塔会散发出浓密的以太射线，对末日塔附近的几乎所有生物进行精神控制，只有受到特殊加护的人才能免受以太射线控制。\n\n一些受到加护的义勇队对这些末日塔进行了调查，其结果显示：这些末日塔组成了复杂的以太传输网络，持续不断地从大地中吸收以太，并将以太传输到位于帝国的中枢塔。\n\n一队持有特殊加护的英雄决定闯入其中一些末日塔，以期彻底调查并尝试破坏这些末日塔。英雄们破坏掉进入的末日塔后，以太传输网络就会受到影响，因此大家希望选择一些末日塔，将其破坏后能使得网络的最大传输容量降到最低。\n\n作为勇闯末日塔小队的先锋，你再次阅读了小队目前所掌握的所有信息。这次大胆的行动计划最终能否拯救这个世界，眼下恐怕谁都无法事先料定。但为了这颗星球的未来，我们只能放手一搏。", "description": "星球的表面是一个中心位于 $(0, 0, 0)$，半径为 $R$ 的完美球面。星球表面上共有 $N$ 座末日塔，这些令人毛骨悚然的塔构成了以太传输网络的所有节点。\n\n- 末日塔的高度远小于星球半径，因此我们认为第 $i (1 \\le i \\le N)$ 座塔是球面上的一个点 $\\left(x_i, y_i, z_i\\right)$。第 $i$ 座塔的以太传输效率为 $q_i$。\n- 保证 $N$ 座末日塔的位置两两不同。在这 $N$ 座末日塔中，$s$ 号塔是以太吸收点，$t$ 号塔是位于帝国的中枢塔；这两座塔的以太浓度显著高于其它的末日塔，因此只能闯入这两座塔之外的末日塔。\n\n$N$ 座末日塔之间共有 $M$ 条传输通道。第 $j (1 \\le j \\le M)$ 条传输通道连接 $u_j, v_j$ 两座末日塔，让它们可以互相传输以太。\n\n- 传输通道是双向的，但单位时间内以太的流向必须是单向的。\n- 为了节省不必要的成本，传输通道的两端不会连接相同的塔，也不会有两条传输通道连接相同的末日塔对。\n- 为了降低传输距离，第 $i$ 条传输通道沿着 $u_j$ 和 $v_j$ 所在的大圆的劣弧铺设，故其**长度** $r_j$ 为两座末日塔在星球表面的球面距离。为了避免传输通道的互相干扰，**对于任意一条传输通道所对应的劣弧，其他传输通道所对应的劣弧只会在该劣弧的两端点上与该劣弧相交**。保证由同一条传输通道相连的两座末日塔的位置不是对跖点关系。\n  - 如果不知道大圆、劣弧、球面距离和对跖点是什么，可以参考题面最后的提示部分。\n\n受到传输效率和通道长度的影响，每条传输通道有各自传输以太的容量上限。\n\n- 具体而言，每个单位时间内，第 $j$ 条传输通道的**容量上限**为 $\\frac{Kq_{u_j} q_{v_j}}{r_j^2}$，其中 $K$ 是给定的常数，$q_{u_j}, q_{v_j}$ 为该传输通道两端的塔的传输效率，$r_j$ 为这条传输通道的长度。\n\n整张以太传输网络需要将 $s$ 号塔吸收的以太沿着传输通道传输到 $t$ 号塔，并使得单位时间内的以太传输量最大。为此，传输网络会自动确定一个以太传输方案，在满足所有传输通道容量上限的前提下，最大化这一传输量。\n\n- 换句话说，如果将末日塔看作图上的点，传输通道看作边，而传输通道的容量上限对应每条边的容量，那么以太的传输方案应该恰好为 $s$ 到 $t$ 的最大流。\n\n虽然没有任何人能保证闯入末日塔之后就一定能将其破坏，但作为勇闯末日塔小队的先锋，你还是想在出发之前计算一下，如果成功破坏了所有将要闯入的末日塔，传输网络单位时间的最大传输量将会降至多少。\n\n- 如果成功破坏了选择的末日塔，与其相连的所有传输通道的容量都将降至 $0$，其余传输通道容量不发生变化；此时传输网络会自动调节至一个在新的网络中传输量最大的新方案。\n- 在最理想的情况下，小队将有机会调查并破坏 $L$ 座末日塔。因此，需要事先选择 $L$ 座末日塔（均不能是 $s$ 或 $t$），使得当这 $L$ 座末日塔都被成功破坏时，传输网络的新的传输方案的以太传输量尽可能地小。", "inputFormat": "输入的第一行包括五个正整数 $N, M, L, s, t$（$3\\le N\\le 500$，$2\\le M\\le \\frac{N(N-1)}{2}$，$1\\le L\\le \\min\\{8,N-2\\}$，$1\\le s, t\\le N$），分别表示该传输网络包含的末日塔数量，传输通道数量，有机会闯入的末日塔数量，最主要的以太吸收塔的编号和中枢塔的编号。\n\n输入的第二行包括两个实数 $R, K$（$1\\le R\\le 10^3$，$1\\le K\\le 10^3$），分别表示星球的半径和计算以太容量时用到的常数。\n\n接下来 $N$ 行，每行三个实数 $a_i, b_i, q_i$（$0\\le a_i\\le 1$，$0\\le b_i< 2$，$1\\le q_i \\le 10^3$），描述第 $i$ 座末日塔的信息，其中 $q_i$ 表示第 $i$ 座末日塔的传输能力， $a_i$ 和 $b_i$ 共同描述末日塔的位置：令 $\\theta_i = \\pi a_i$，$\\varphi_i = \\pi b_i$（如果你习惯使用角度制而不是弧度制，可以将 $\\pi$ 改为 $180^\\circ$），则 $\\left(x_i, y_i, z_i\\right) = \\left(R \\sin\\theta_i \\cos\\varphi_i, R\\sin\\theta_i \\sin\\varphi_i, R\\cos\\theta_i\\right)$。保证末日塔的位置各不相同。\n\n最后 $M$ 行，每行两个正整数 $u_i, v_i$（$1\\le u_i, v_i\\le N$），表示一条传输通道连接的两座末日塔的编号。保证同一条传输通道连接的两座末日塔不相同且不互为对跖点，没有两条传输通道连接的是相同的末日塔对，且传输网络是连通的。\n\n保证输入的所有实数保留到小数点后第 $4$ 位。", "outputFormat": "输出一个实数，表示如果成功破坏了将要闯入的末日塔，新的传输网络单位时间的最大传输量。当你的输出与标准输出的相对误差或绝对误差不超过 $10^{-6}$ 时，我们认为你的输出是正确的。", "hint": "### 样例 \\#1 解释\n\n以太传输网络如下图所示。图中蓝色球面即为星球表面；紫色点为各末日塔，其中 $P_i$ 对应输入的第 $i$ 座末日塔；黄色的线表示各传输通道。\n\n![样例 1 示意图](https://cdn.luogu.com.cn/upload/image_hosting/4bynt5dl.png)\n\n原来的传输网络单位时间最大传输量为 $188/\\pi^2$。破坏第 $2$ 个末日塔或第 $5$ 个末日塔都能使新的传输网络单位时间的最大传输量降至 $80/\\pi^2$，而破坏第 $3$ 个末日塔或第 $4$ 个末日塔只能使新的传输网络单位时间的最大传输量降至 $94/\\pi^2$，所以应该选择第 $2$ 个或第 $5$ 个末日塔尝试破坏。", "locale": "zh-CN"}}}
{"pid": "P9973", "type": "P", "difficulty": 1, "samples": [["You are right, but \"Sao Lei (Winmine)\" is a game whose Chinese name contains two characters while English name contains seven.\n", "AI\n"], ["Ni shuo de dui, dan shi zhe ju hua bu shi yi \"You are right, but \" kai tou de.\n", "Human\n"], ["You are wrong. Here is why. The English name of game \"G****** I*****\" contains 14 characters (including a space), not 7.\n", "Human\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "2024", "THUPC"], "title": "[THUPC 2024 初赛] 你说得对，但是 AIGC", "background": "你说得对，但是**本题不接受提供 hack 数据。**", "description": "你说得对，但是众所周知 AIGC 是当下计算机领域最热门的方向之一，算协的几名成员也对此很有兴趣，经过长时间的奋战，终于研发出了一款全新的语言大模型——ChatSAA。\n\n你说得对，但是当模型即将发布之时，开发团队忽然发现模型存在重大问题——由于开发团队的某名成员沉迷于一款**中文二字英文七字的游戏（见样例）**，导致训练模型时使用的语料库被莫名其妙地污染了，这使得模型生成的句子全都带有一个相同的前缀。\n\n你说得对，但是紧急更换语料库重新训练显然已经来不及了，无奈开发团队只能在文档中注明：本模型的最大**特性（而非 bug）**在于生成文本的**前 19 个字符**，这既是模型独特的防伪标记，也充分彰显了算协团队的人文情怀和文化素养。\n\n你说得对，但是一个微不足道的问题在于：这会让人们一眼就能分辨出哪些句子是由 AI 生成的，这会对那些打算用 AI 来写作业的同学很不友好。\n\n你说得对，但是现在你手里有一些句子，这些句子有的是由 ChatSAA 生成的，有的是人类写的（假设人类没有刻意模仿 ChatSAA 的生成特性），你需要写一个程序来辨别二者。", "inputFormat": "你说得对，但是你的程序应当输入一行，一个字符串 $s$ 表示需要判断的句子，满足 $|s| \\le 200$，且 $s$ 由包括空格在内的 ASCII 可见字符（即 ASCII 码在 $32\\sim 126$ 的字符）组成。", "outputFormat": "你说得对，但是你的程序应当输出一行，一个字符串表示判断结果，如果这句话是 AI 生成的，输出 `AI`，否则输出 `Human`。", "hint": "### 样例 \\#1 解释\n你说得对，但是扫雷（Winmine）是一款中文二字英文七字的游戏。\n\n### 提示\n\n你说得对，但是如果我说这道题的题面是 AI 生成的，阁下又该如何应对？", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[THUPC 2024 初赛] 你说得对，但是 AIGC", "background": "你说得对，但是**本题不接受提供 hack 数据。**", "description": "你说得对，但是众所周知 AIGC 是当下计算机领域最热门的方向之一，算协的几名成员也对此很有兴趣，经过长时间的奋战，终于研发出了一款全新的语言大模型——ChatSAA。\n\n你说得对，但是当模型即将发布之时，开发团队忽然发现模型存在重大问题——由于开发团队的某名成员沉迷于一款**中文二字英文七字的游戏（见样例）**，导致训练模型时使用的语料库被莫名其妙地污染了，这使得模型生成的句子全都带有一个相同的前缀。\n\n你说得对，但是紧急更换语料库重新训练显然已经来不及了，无奈开发团队只能在文档中注明：本模型的最大**特性（而非 bug）**在于生成文本的**前 19 个字符**，这既是模型独特的防伪标记，也充分彰显了算协团队的人文情怀和文化素养。\n\n你说得对，但是一个微不足道的问题在于：这会让人们一眼就能分辨出哪些句子是由 AI 生成的，这会对那些打算用 AI 来写作业的同学很不友好。\n\n你说得对，但是现在你手里有一些句子，这些句子有的是由 ChatSAA 生成的，有的是人类写的（假设人类没有刻意模仿 ChatSAA 的生成特性），你需要写一个程序来辨别二者。", "inputFormat": "你说得对，但是你的程序应当输入一行，一个字符串 $s$ 表示需要判断的句子，满足 $|s| \\le 200$，且 $s$ 由包括空格在内的 ASCII 可见字符（即 ASCII 码在 $32\\sim 126$ 的字符）组成。", "outputFormat": "你说得对，但是你的程序应当输出一行，一个字符串表示判断结果，如果这句话是 AI 生成的，输出 `AI`，否则输出 `Human`。", "hint": "### 样例 \\#1 解释\n你说得对，但是扫雷（Winmine）是一款中文二字英文七字的游戏。\n\n### 提示\n\n你说得对，但是如果我说这道题的题面是 AI 生成的，阁下又该如何应对？", "locale": "zh-CN"}}}
{"pid": "P9974", "type": "P", "difficulty": 3, "samples": [["3 2\n3 2 5\n6 1", "7\n2\n7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "USACO", "2023", "O2优化"], "title": "[USACO23DEC] Candy Cane Feast B", "background": "", "description": "Farmer John 的奶牛对甜食情有独钟，它们尤其喜欢吃糖果棒。FJ 共有 $N$ 头奶牛，每头奶牛都有一个特定的初始高度。他想要喂它们 $M$ 根糖果棒，每根糖果棒的高度也各不相同（$1 \\le N,M \\le 2\\cdot 10^5$）。\n\nFJ 计划按照输入给出的顺序，逐一喂给奶牛们糖果棒。然后，奶牛们会按照输入给出的顺序一个接一个地排队，走向糖果棒，每头奶牛最多吃到与它高度相同的部分（因为它们够不到更高的地方）。即使奶牛吃掉了糖果棒的底部，糖果棒也在最初悬挂的地方保持不动，并不会被降低到地面。如果糖果棒的底部已经高于某头奶牛的高度，那么这头奶牛在它的回合中可能什么也吃不到。每头奶牛轮流吃过后，它们的身高会增加它们吃掉的糖果棒的单位数量，然后农夫约翰挂上下一根糖果棒，奶牛们再次重复这个过程（第一头奶牛再次成为第一个开始吃下一根糖果棒的）。", "inputFormat": "第一行包含 $N$ 和 $M$。\n\n接下来的一行包含 $N$ 头奶牛的初始高度，每头奶牛的高度都在 $[1,10^9]$ 的范围内。\n\n接下来的一行包含 $M$ 根糖果棒的长度，每根糖果棒的长度都在 $[1,10^9]$ 的范围内。", "outputFormat": "输出 $N$ 行，表示每头奶牛最终的高度。\n\n请注意，由于这个问题涉及的整数大小较大，可能需要使用 64 位整数数据类型（例如，在 C/C++ 中使用 `long long` 类型）。", "hint": "### 样例解释 1\n\n第一根糖果棒高度为 $6$ 单位。\n\n- 第一头奶牛吃掉了第一根糖果棒直至高度 $3$ 的部分，之后第一根糖果棒剩余高度 $[3,6]$ 的部分。\n- 第二头奶牛不够高，无法吃掉第一根糖果棒的任何剩余部分。\n- 第三头奶牛额外吃掉了第一根糖果棒的两个单位。第一根糖果棒的剩余高度 $[5,6]$ 的部分未被吃掉。\n\n接下来，每头奶牛根据它吃掉的数量增长，所以奶牛的高度变为 $[3+3, 2+0, 5+2]=[6, 2, 7]$。\n\n第二根糖果棒高度为 $1$ 单位，被第一头奶牛全部吃掉。\n\n### 测试点性质\n\n- 测试点 $2-10$ 满足 $N,M \\le 10^3$。\n- 测试点 $11-14$ 没有额外限制。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO23DEC] Candy Cane Feast B", "background": "", "description": "Farmer John 的奶牛对甜食情有独钟，它们尤其喜欢吃糖果棒。FJ 共有 $N$ 头奶牛，每头奶牛都有一个特定的初始高度。他想要喂它们 $M$ 根糖果棒，每根糖果棒的高度也各不相同（$1 \\le N,M \\le 2\\cdot 10^5$）。\n\nFJ 计划按照输入给出的顺序，逐一喂给奶牛们糖果棒。然后，奶牛们会按照输入给出的顺序一个接一个地排队，走向糖果棒，每头奶牛最多吃到与它高度相同的部分（因为它们够不到更高的地方）。即使奶牛吃掉了糖果棒的底部，糖果棒也在最初悬挂的地方保持不动，并不会被降低到地面。如果糖果棒的底部已经高于某头奶牛的高度，那么这头奶牛在它的回合中可能什么也吃不到。每头奶牛轮流吃过后，它们的身高会增加它们吃掉的糖果棒的单位数量，然后农夫约翰挂上下一根糖果棒，奶牛们再次重复这个过程（第一头奶牛再次成为第一个开始吃下一根糖果棒的）。", "inputFormat": "第一行包含 $N$ 和 $M$。\n\n接下来的一行包含 $N$ 头奶牛的初始高度，每头奶牛的高度都在 $[1,10^9]$ 的范围内。\n\n接下来的一行包含 $M$ 根糖果棒的长度，每根糖果棒的长度都在 $[1,10^9]$ 的范围内。", "outputFormat": "输出 $N$ 行，表示每头奶牛最终的高度。\n\n请注意，由于这个问题涉及的整数大小较大，可能需要使用 64 位整数数据类型（例如，在 C/C++ 中使用 `long long` 类型）。", "hint": "### 样例解释 1\n\n第一根糖果棒高度为 $6$ 单位。\n\n- 第一头奶牛吃掉了第一根糖果棒直至高度 $3$ 的部分，之后第一根糖果棒剩余高度 $[3,6]$ 的部分。\n- 第二头奶牛不够高，无法吃掉第一根糖果棒的任何剩余部分。\n- 第三头奶牛额外吃掉了第一根糖果棒的两个单位。第一根糖果棒的剩余高度 $[5,6]$ 的部分未被吃掉。\n\n接下来，每头奶牛根据它吃掉的数量增长，所以奶牛的高度变为 $[3+3, 2+0, 5+2]=[6, 2, 7]$。\n\n第二根糖果棒高度为 $1$ 单位，被第一头奶牛全部吃掉。\n\n### 测试点性质\n\n- 测试点 $2-10$ 满足 $N,M \\le 10^3$。\n- 测试点 $11-14$ 没有额外限制。\n", "locale": "zh-CN"}}}
{"pid": "P9975", "type": "P", "difficulty": 3, "samples": [["5\n11111", "1"], ["6\n011101", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "二分", "USACO", "2023", "O2优化"], "title": "[USACO23DEC] Cowntact Tracing 2 B", "background": "", "description": "Farmer John 有 $N$ 头奶牛排成一列（$1 \\leq N \\leq 3\\cdot 10^5$）。不幸的是，有一种疾病正在传播。\n\n最初，有一些奶牛被感染。每到夜晚，被感染的奶牛会将疾病传播给它左右两边的奶牛（如果这些奶牛存在的话）。一旦奶牛被感染，她就会持续处于感染状态。\n\n经过一些晚上，Farmer John 意识到情况已经失控，因此他对奶牛进行了检测以确定哪些奶牛感染了疾病。请找出最少有多少头奶牛最初可能感染了这种疾病。", "inputFormat": "第一行为一个整数 $N$，即 Farmer John 拥有的奶牛数量。\n\n接下来一行，包含长度为 $N$ 的由 $1$ 和 $0$ 组成的位串。其中 $1$ 表示一头被感染的奶牛，$0$ 表示一头在经过若干晚之后仍未被感染的奶牛。", "outputFormat": "输出一个整数，表示最少有多少头奶牛可能最初感染了这种疾病。", "hint": "### 样例解释 1\n\n假设只有中间的奶牛最初被感染。那么，奶牛们将按以下顺序被感染：\n\n- 第 $0$ 晚：$00100$（第三只奶牛一开始被感染）\n- 第 $1$ 晚：$01110$（第二和第四只奶牛现在被感染了）\n- 第 $2$ 晚：$11111$（第一和第五只奶牛现在被感染了）\n- 第 $3$ 晚：$11111$（所有的奶牛都已经被感染了，没有新的奶牛被感染）\n- ……\n\n经过两个或更多的晚上，奶牛们的状态即与输入的状态相符。还有许多其他的初始状态和夜晚数量可能导致了输入的状态，例如：\n\n- 第 $0$ 晚：$10001$\n- 第 $1$ 晚：$11011$\n- 第 $2$ 晚：$11111$\n\n或者：\n\n- 第 $0$ 晚：$01001$\n- 第 $1$ 晚：$11111$\n\n或者：\n\n- 第 $0$ 晚：$01000$\n- 第 $1$ 晚：$11100$\n- 第 $2$ 晚：$11110$\n- 第 $3$ 晚：$11111$\n\n所有这些初始状态中至少有一头奶牛被感染。\n\n### 样例解释 2\n\n唯一可能导致这个最终状态的初始状态和夜晚数是：没有经过任何夜晚，输入中的四头感染的奶牛都是从最开始就感染了这种疾病。\n\n### 测试点性质\n\n- 测试点 $3-7$ 满足 $N \\le 1000$。\n- 测试点 $8-12$ 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO23DEC] Cowntact Tracing 2 B", "background": "", "description": "Farmer John 有 $N$ 头奶牛排成一列（$1 \\leq N \\leq 3\\cdot 10^5$）。不幸的是，有一种疾病正在传播。\n\n最初，有一些奶牛被感染。每到夜晚，被感染的奶牛会将疾病传播给它左右两边的奶牛（如果这些奶牛存在的话）。一旦奶牛被感染，她就会持续处于感染状态。\n\n经过一些晚上，Farmer John 意识到情况已经失控，因此他对奶牛进行了检测以确定哪些奶牛感染了疾病。请找出最少有多少头奶牛最初可能感染了这种疾病。", "inputFormat": "第一行为一个整数 $N$，即 Farmer John 拥有的奶牛数量。\n\n接下来一行，包含长度为 $N$ 的由 $1$ 和 $0$ 组成的位串。其中 $1$ 表示一头被感染的奶牛，$0$ 表示一头在经过若干晚之后仍未被感染的奶牛。", "outputFormat": "输出一个整数，表示最少有多少头奶牛可能最初感染了这种疾病。", "hint": "### 样例解释 1\n\n假设只有中间的奶牛最初被感染。那么，奶牛们将按以下顺序被感染：\n\n- 第 $0$ 晚：$00100$（第三只奶牛一开始被感染）\n- 第 $1$ 晚：$01110$（第二和第四只奶牛现在被感染了）\n- 第 $2$ 晚：$11111$（第一和第五只奶牛现在被感染了）\n- 第 $3$ 晚：$11111$（所有的奶牛都已经被感染了，没有新的奶牛被感染）\n- ……\n\n经过两个或更多的晚上，奶牛们的状态即与输入的状态相符。还有许多其他的初始状态和夜晚数量可能导致了输入的状态，例如：\n\n- 第 $0$ 晚：$10001$\n- 第 $1$ 晚：$11011$\n- 第 $2$ 晚：$11111$\n\n或者：\n\n- 第 $0$ 晚：$01001$\n- 第 $1$ 晚：$11111$\n\n或者：\n\n- 第 $0$ 晚：$01000$\n- 第 $1$ 晚：$11100$\n- 第 $2$ 晚：$11110$\n- 第 $3$ 晚：$11111$\n\n所有这些初始状态中至少有一头奶牛被感染。\n\n### 样例解释 2\n\n唯一可能导致这个最终状态的初始状态和夜晚数是：没有经过任何夜晚，输入中的四头感染的奶牛都是从最开始就感染了这种疾病。\n\n### 测试点性质\n\n- 测试点 $3-7$ 满足 $N \\le 1000$。\n- 测试点 $8-12$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P9976", "type": "P", "difficulty": 3, "samples": [["6\n1\n10\n1\n0\n2\n7 3\n8 10\n1 0\n2\n3 6\n10 8\n0 1\n2\n7 3\n8 9\n1 0\n2\n7 7\n8 8\n0 1\n2\n7 3\n8 8\n1 0", "0\n3\n2\n5\n-1\n-1"], ["2\n5\n7 4 1 10 12\n3 4 5 2 1\n2 1 0 3 4\n5\n4 10 12 7 1\n3 1 1 4 5\n2 4 3 1 0", "4\n7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "USACO", "2023", "O2优化"], "title": "[USACO23DEC] Farmer John Actually Farms B", "background": "", "description": "Farmer John 在他的农场上种植了 $N$（$1 \\leq N \\leq 2\\cdot 10^5$） 株芦笋！然而，其中有一些植物存在基因差异，长得比其他植物快。第 $i$ 株植物的初始高度为 $h_i$ 英寸，之后每天，第 $i$ 株植物长高 $a_i$ 英寸。\n\nFJ 更加钟爱其中的一些植物。他将给你一组由不同整数组成的数组 $t_1,\\dots,t_N$，这个数组包含 $0$ 到 $N-1$ 的全部整数。他希望恰好有 $t_i$ 株植物比第 $i$ 株植物高。找到最少要经过多少天，才能满足 FJ 的要求，或者报告这个要求是不可能满足的。", "inputFormat": "**每个测试点中包含多组测试数据。**\n\n第一行为一个整数 $T$，代表测试数据组数（$1 \\leq T \\leq 10$）。\n\n对于每一组测试数据，第一行一个整数 $N$（$1 \\leq N \\leq 2\\cdot 10^5$），表示植物数量。\n\n第二行包含 $N$ 个整数 $h_i$（$1 \\leq h_i \\leq 10^9$），表示第 $i$ 株植物的初始高度。\n\n第三行包含 $N$ 个整数 $a_i$（$1 \\leq a_i \\leq 10^9$），表示第 $i$ 株植物每天增长的高度。\n\n第四行包含 $N$ 个不同的整数 $t_i$，表示 FJ 给你的数组。\n\n保证所有测试数据的 $N$ 的和不超过 $2\\cdot 10^5$。", "outputFormat": "输出 $T$ 行，每行表示一组测试数据的答案。如果要求不可能满足，输出 $-1$。\n\n请注意，由于这个问题涉及的整数大小较大，可能需要使用 64 位整数数据类型（例如，在 C/C++ 中使用 `long long` 类型）。", "hint": "### 样例解释 1\n\n在第一组样例中，有 $6$ 组测试数据。\n\n在第一组测试数据中，只有一株植物，所以要求在第 $0$ 天就已经满足。\n\n在第二组测试数据中，需要让第一株植物比第二株植物矮。第   $1$ 天后，它们的高度为 $15,13$；第 $2$ 天后，它们的高度均为 $23$；第 $3$ 天后，它们的高度为 $31,33$，这是满足要求的第一天。\n\n第三组和第四组测试数据与第二组类似。\n\n在第五组测试数据中，两株植物的初始高度均为 $7$ 英寸，且每天均增长 $8$ 英寸，所以它们的高度永远相同。因此，条件永远无法满足。\n\n在第六组测试数据中，初始高度不满足要求且增长速度均相同，所以条件永远无法满足。\n\n### 样例解释 2\n\n在第二组样例中，有 $2$ 组测试数据。\n\n在第一组测试数据中，第 $4$ 天后的最终高度为 $19, 20, 21, 18, 16$。\n\n在第二组测试数据中，第 $7$ 天后的最终高度为 $25, 17, 19, 35, 36$。\n\n### 测试点性质\n\n- 测试点 $3$ 满足 $N \\le 2$。\n- 测试点 $4-5$ 满足 $N \\le 50$，$a_i, h_i \\le 10^3$。\n- 测试点 $6-8$ 满足 $N \\le 10^3$。\n- 测试点 $9-13$ 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO23DEC] Farmer John Actually Farms B", "background": "", "description": "Farmer John 在他的农场上种植了 $N$（$1 \\leq N \\leq 2\\cdot 10^5$） 株芦笋！然而，其中有一些植物存在基因差异，长得比其他植物快。第 $i$ 株植物的初始高度为 $h_i$ 英寸，之后每天，第 $i$ 株植物长高 $a_i$ 英寸。\n\nFJ 更加钟爱其中的一些植物。他将给你一组由不同整数组成的数组 $t_1,\\dots,t_N$，这个数组包含 $0$ 到 $N-1$ 的全部整数。他希望恰好有 $t_i$ 株植物比第 $i$ 株植物高。找到最少要经过多少天，才能满足 FJ 的要求，或者报告这个要求是不可能满足的。", "inputFormat": "**每个测试点中包含多组测试数据。**\n\n第一行为一个整数 $T$，代表测试数据组数（$1 \\leq T \\leq 10$）。\n\n对于每一组测试数据，第一行一个整数 $N$（$1 \\leq N \\leq 2\\cdot 10^5$），表示植物数量。\n\n第二行包含 $N$ 个整数 $h_i$（$1 \\leq h_i \\leq 10^9$），表示第 $i$ 株植物的初始高度。\n\n第三行包含 $N$ 个整数 $a_i$（$1 \\leq a_i \\leq 10^9$），表示第 $i$ 株植物每天增长的高度。\n\n第四行包含 $N$ 个不同的整数 $t_i$，表示 FJ 给你的数组。\n\n保证所有测试数据的 $N$ 的和不超过 $2\\cdot 10^5$。", "outputFormat": "输出 $T$ 行，每行表示一组测试数据的答案。如果要求不可能满足，输出 $-1$。\n\n请注意，由于这个问题涉及的整数大小较大，可能需要使用 64 位整数数据类型（例如，在 C/C++ 中使用 `long long` 类型）。", "hint": "### 样例解释 1\n\n在第一组样例中，有 $6$ 组测试数据。\n\n在第一组测试数据中，只有一株植物，所以要求在第 $0$ 天就已经满足。\n\n在第二组测试数据中，需要让第一株植物比第二株植物矮。第   $1$ 天后，它们的高度为 $15,13$；第 $2$ 天后，它们的高度均为 $23$；第 $3$ 天后，它们的高度为 $31,33$，这是满足要求的第一天。\n\n第三组和第四组测试数据与第二组类似。\n\n在第五组测试数据中，两株植物的初始高度均为 $7$ 英寸，且每天均增长 $8$ 英寸，所以它们的高度永远相同。因此，条件永远无法满足。\n\n在第六组测试数据中，初始高度不满足要求且增长速度均相同，所以条件永远无法满足。\n\n### 样例解释 2\n\n在第二组样例中，有 $2$ 组测试数据。\n\n在第一组测试数据中，第 $4$ 天后的最终高度为 $19, 20, 21, 18, 16$。\n\n在第二组测试数据中，第 $7$ 天后的最终高度为 $25, 17, 19, 35, 36$。\n\n### 测试点性质\n\n- 测试点 $3$ 满足 $N \\le 2$。\n- 测试点 $4-5$ 满足 $N \\le 50$，$a_i, h_i \\le 10^3$。\n- 测试点 $6-8$ 满足 $N \\le 10^3$。\n- 测试点 $9-13$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P9977", "type": "P", "difficulty": 4, "samples": [["3 5 2\n9 4\n7 6\n5 5", "14"], ["3 5 3\n5 5\n7 6\n9 4", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "USACO", "堆", "2023", "O2优化", "排序"], "title": "[USACO23DEC] Bovine Acrobatics S", "background": "", "description": "Farmer John 决定让他的奶牛表演杂技！首先，FJ 为他的奶牛称重，发现她们有 $N$（$1\\le N\\le 2\\times 10^5$）个不同的体重。具体来说，对于全部的 $i\\in [1,N]$，有 $a_i$ 只奶牛的体重为 $w_i$ 单位（$1\\le a_i\\le 10^9, 1\\le w_i\\le 10^9$）。\n\n他最出名的节目需要奶牛叠成**平衡的奶牛塔**。一座**奶牛塔**是一些奶牛，每只奶牛站在下一只奶牛身上。一座奶牛塔是**平衡的**，当且仅当每一只被踩着的奶牛，都比**直接**踩在它身上的那只奶牛重至少 $K$（$1\\le K\\le 10^9$）单位。每只奶牛都可以成为奶牛塔的一部分。\n\n如果 FJ 想要创造最多 $M$（$1 \\le M \\le 10^9$）座奶牛塔，最多有多少只奶牛可以成为奶牛塔的一部分？", "inputFormat": "第一行包含三个空格分隔的整数 $N$，$M$ 和 $K$。\n\n接下来 $N$ 行，每行包含两个空格分隔的整数 $w_i$ 和 $a_i$。保证所有的 $w_i$ 是不同的。", "outputFormat": "输出当 FJ 采用最佳方案时，奶牛塔中奶牛的最大数目。", "hint": "### 样例解释 1\n\nFJ 可以用体重为 $5,7,9$ 的奶牛创造四座平衡的奶牛塔，再用体重为 $5,7$ 的奶牛创造另一座。\n\n### 样例解释 2\n\nFJ 可以用体重为 $5,9$ 的奶牛创造四座平衡的奶牛塔，再用体重为 $7$ 的一只奶牛创造另一座。或者，他可以用体重为 $5,9$ 的奶牛创造四座平衡的奶牛塔，再用体重为 $5$ 的一只奶牛创造另一座。\n\n### 测试点性质\n\n- 测试点 $3-5$ 满足 $M \\le 5000$ 且奶牛的总数不超过 $5000$。\n- 测试点 $6-11$ 满足奶牛的总数不超过 $2\\cdot 10^5$。\n- 测试点 $12-17$ 没有额外限制。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO23DEC] Bovine Acrobatics S", "background": "", "description": "Farmer John 决定让他的奶牛表演杂技！首先，FJ 为他的奶牛称重，发现她们有 $N$（$1\\le N\\le 2\\times 10^5$）个不同的体重。具体来说，对于全部的 $i\\in [1,N]$，有 $a_i$ 只奶牛的体重为 $w_i$ 单位（$1\\le a_i\\le 10^9, 1\\le w_i\\le 10^9$）。\n\n他最出名的节目需要奶牛叠成**平衡的奶牛塔**。一座**奶牛塔**是一些奶牛，每只奶牛站在下一只奶牛身上。一座奶牛塔是**平衡的**，当且仅当每一只被踩着的奶牛，都比**直接**踩在它身上的那只奶牛重至少 $K$（$1\\le K\\le 10^9$）单位。每只奶牛都可以成为奶牛塔的一部分。\n\n如果 FJ 想要创造最多 $M$（$1 \\le M \\le 10^9$）座奶牛塔，最多有多少只奶牛可以成为奶牛塔的一部分？", "inputFormat": "第一行包含三个空格分隔的整数 $N$，$M$ 和 $K$。\n\n接下来 $N$ 行，每行包含两个空格分隔的整数 $w_i$ 和 $a_i$。保证所有的 $w_i$ 是不同的。", "outputFormat": "输出当 FJ 采用最佳方案时，奶牛塔中奶牛的最大数目。", "hint": "### 样例解释 1\n\nFJ 可以用体重为 $5,7,9$ 的奶牛创造四座平衡的奶牛塔，再用体重为 $5,7$ 的奶牛创造另一座。\n\n### 样例解释 2\n\nFJ 可以用体重为 $5,9$ 的奶牛创造四座平衡的奶牛塔，再用体重为 $7$ 的一只奶牛创造另一座。或者，他可以用体重为 $5,9$ 的奶牛创造四座平衡的奶牛塔，再用体重为 $5$ 的一只奶牛创造另一座。\n\n### 测试点性质\n\n- 测试点 $3-5$ 满足 $M \\le 5000$ 且奶牛的总数不超过 $5000$。\n- 测试点 $6-11$ 满足奶牛的总数不超过 $2\\cdot 10^5$。\n- 测试点 $12-17$ 没有额外限制。\n", "locale": "zh-CN"}}}
{"pid": "P9978", "type": "P", "difficulty": 3, "samples": [["6 3\n1 2 3\n2 3 1", "6"], ["6 3\n1 2 3\n4 5 6", "0"], ["6 4\n1 2 3 4\n4 3 2 5", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["USACO", "2023", "O2优化", "枚举", "分类讨论"], "title": "[USACO23DEC] Cycle Correspondence S", "background": "", "description": "Farmer John 有 $N$（$3 \\le N \\le 5\\cdot 10^5$）座谷仓，其中 $K$ 对不同的谷仓连接在一起。\n\n一开始，Annabelle 为每座谷仓分配了一个 $[1,N]$ 范围内的整数编号，并发现编号为 $a_1,\\dots,a_K$ 的谷仓按照顺序形成了一个环形连接。换句话说，对于所有的 $1 \\le i < K$，谷仓 $a_i$ 和 $a_{i+1}$ 相连，谷仓 $a_K$ 与 $a_1$ 亦相连。所有的 $a_i$ 不相同。\n\n然后，Bessie 也为每个谷仓分配了一个 $[1,N]$ 范围内的整数编号，并发现编号为 $b_1,\\dots,b_K$ 也按照顺序形成了一个环形链接。所有的 $b_i$ 不相同。\n\n一些（可能没有或全部）谷仓被 Annabelle 和 Bessie 分配了相同的编号。计算最多有多少个这样的谷仓。", "inputFormat": "第一行包含 $N$ 和 $K$。\n\n接下来一行包含 $a_1,\\dots,a_K$。\n\n接下来一行包含 $b_1,\\dots,b_K$。", "outputFormat": "分配了相同编号谷仓的最大数量。", "hint": "### 样例解释 1\n\nAnnabelle 和 Bessie 可以为每个谷仓分配相同的编号。\n\n### 样例解释 2\n\nAnnabelle 和 Bessie 无法为任何谷仓分配相同的编号。\n\n### 样例解释 3\n\nAnnabelle 和 Bessie 可以分配编号 $2,3,4,6$ 给相同的谷仓。\n\n### 测试点性质\n\n- 测试点 $4-5$ 满足 $N \\le 8$。\n- 测试点 $6-8$ 满足 $N \\le 5000$。\n- 测试点 $9-15$ 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO23DEC] Cycle Correspondence S", "background": "", "description": "Farmer John 有 $N$（$3 \\le N \\le 5\\cdot 10^5$）座谷仓，其中 $K$ 对不同的谷仓连接在一起。\n\n一开始，Annabelle 为每座谷仓分配了一个 $[1,N]$ 范围内的整数编号，并发现编号为 $a_1,\\dots,a_K$ 的谷仓按照顺序形成了一个环形连接。换句话说，对于所有的 $1 \\le i < K$，谷仓 $a_i$ 和 $a_{i+1}$ 相连，谷仓 $a_K$ 与 $a_1$ 亦相连。所有的 $a_i$ 不相同。\n\n然后，Bessie 也为每个谷仓分配了一个 $[1,N]$ 范围内的整数编号，并发现编号为 $b_1,\\dots,b_K$ 也按照顺序形成了一个环形链接。所有的 $b_i$ 不相同。\n\n一些（可能没有或全部）谷仓被 Annabelle 和 Bessie 分配了相同的编号。计算最多有多少个这样的谷仓。", "inputFormat": "第一行包含 $N$ 和 $K$。\n\n接下来一行包含 $a_1,\\dots,a_K$。\n\n接下来一行包含 $b_1,\\dots,b_K$。", "outputFormat": "分配了相同编号谷仓的最大数量。", "hint": "### 样例解释 1\n\nAnnabelle 和 Bessie 可以为每个谷仓分配相同的编号。\n\n### 样例解释 2\n\nAnnabelle 和 Bessie 无法为任何谷仓分配相同的编号。\n\n### 样例解释 3\n\nAnnabelle 和 Bessie 可以分配编号 $2,3,4,6$ 给相同的谷仓。\n\n### 测试点性质\n\n- 测试点 $4-5$ 满足 $N \\le 8$。\n- 测试点 $6-8$ 满足 $N \\le 5000$。\n- 测试点 $9-15$ 没有额外限制。", "locale": "zh-CN"}}}
{"pid": "P9979", "type": "P", "difficulty": 4, "samples": [["3 7\n0 -1 1\nLFFRFRR", "3"], ["1 5\n0\nFFFFF", "1"], ["5 6\n1 2 3 4 5\nFFRFRF", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "USACO", "2023", "O2优化", "分类讨论"], "title": "[USACO23DEC] Target Practice S", "background": "", "description": "Bessie 是一只仿生牛。在一条数轴上，她正尝试命中 $T$（$1 \\leq T \\leq 10^5$）个位于不同位置的靶子。Bessie 在位置 $0$ 开始行动，并遵循一个长度为 $C$（$1 \\leq C \\leq 10^5$）的命令序列，序列由 `L`、`F` 和 `R` 组成：\n\n- `L`：Bessie 向左移动一个单位距离。\n- `R`：Bessie 向右移动一个单位距离。\n- `F`：Bessie 开枪。如果有一个靶子在 Bessies 当前的位置，这个靶子将被命中并摧毁。它不可以再次被命中。\n\n如果在 Bessie 开始前，你被允许修改序列中的至多一条命令，Bessie 最多可以命中多少靶子？", "inputFormat": "第一行包含 $T$ 和 $C$。\n\n下一行包含 $T$ 个靶子的位置，均为 $[-C,C]$ 范围内的不同整数。\n\n下一行包含长度为 $C$ 的命令序列，仅包含字符 `F`、`L` 和 `R`.", "outputFormat": "输出修改至多一个命令后，Bessie 可以命中的靶子的最大数量。", "hint": "### 样例解释 1\n\n如果你对命令序列不做任何修改，Bessie 将命中两个靶子。\n\n| 命令 | 位置 | 命中的靶子数目 |\n| :----------- | :----------- | :----------- |\n| Start | 0 | 0 |\n| L | -1 | 0 |\n| F | -1 | 1 |\n| F | -1 | 1（无法摧毁靶子超过 1 次） |\n| R | 0 | 1 |\n| F | 0 | 2 |\n| R | 1 | 2 |\n| R | 2 | 2 |\n\n如果你将最后一条命令由 `R` 修改为 `F`，Bessie 将命中三个靶子：\n\n| 命令 | 位置 | 命中的靶子数目 |\n| :----------- | :----------- | :----------- |\n| Start | 0 | 0 |\n| L | -1 | 0 |\n| F | -1 | 1 |\n| F | -1 | 1（无法摧毁靶子超过 1 次） |\n| R | 0 | 1 |\n| F | 0 | 2 |\n| R | 1 | 2 |\n| F | 1 | 3 |\n\n### 样例解释 2\n\n如果命令序列不修改，在位置 $0$ 的唯一一个靶子将被命中。\n\n由于一个靶子不能被多次摧毁，答案为 $1$。\n\n### 测试点性质\n\n- 测试点 $4-6$ 满足 $T,C \\le 1000$。\n- 测试点 $7-15$ 没有额外限制。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO23DEC] Target Practice S", "background": "", "description": "Bessie 是一只仿生牛。在一条数轴上，她正尝试命中 $T$（$1 \\leq T \\leq 10^5$）个位于不同位置的靶子。Bessie 在位置 $0$ 开始行动，并遵循一个长度为 $C$（$1 \\leq C \\leq 10^5$）的命令序列，序列由 `L`、`F` 和 `R` 组成：\n\n- `L`：Bessie 向左移动一个单位距离。\n- `R`：Bessie 向右移动一个单位距离。\n- `F`：Bessie 开枪。如果有一个靶子在 Bessies 当前的位置，这个靶子将被命中并摧毁。它不可以再次被命中。\n\n如果在 Bessie 开始前，你被允许修改序列中的至多一条命令，Bessie 最多可以命中多少靶子？", "inputFormat": "第一行包含 $T$ 和 $C$。\n\n下一行包含 $T$ 个靶子的位置，均为 $[-C,C]$ 范围内的不同整数。\n\n下一行包含长度为 $C$ 的命令序列，仅包含字符 `F`、`L` 和 `R`.", "outputFormat": "输出修改至多一个命令后，Bessie 可以命中的靶子的最大数量。", "hint": "### 样例解释 1\n\n如果你对命令序列不做任何修改，Bessie 将命中两个靶子。\n\n| 命令 | 位置 | 命中的靶子数目 |\n| :----------- | :----------- | :----------- |\n| Start | 0 | 0 |\n| L | -1 | 0 |\n| F | -1 | 1 |\n| F | -1 | 1（无法摧毁靶子超过 1 次） |\n| R | 0 | 1 |\n| F | 0 | 2 |\n| R | 1 | 2 |\n| R | 2 | 2 |\n\n如果你将最后一条命令由 `R` 修改为 `F`，Bessie 将命中三个靶子：\n\n| 命令 | 位置 | 命中的靶子数目 |\n| :----------- | :----------- | :----------- |\n| Start | 0 | 0 |\n| L | -1 | 0 |\n| F | -1 | 1 |\n| F | -1 | 1（无法摧毁靶子超过 1 次） |\n| R | 0 | 1 |\n| F | 0 | 2 |\n| R | 1 | 2 |\n| F | 1 | 3 |\n\n### 样例解释 2\n\n如果命令序列不修改，在位置 $0$ 的唯一一个靶子将被命中。\n\n由于一个靶子不能被多次摧毁，答案为 $1$。\n\n### 测试点性质\n\n- 测试点 $4-6$ 满足 $T,C \\le 1000$。\n- 测试点 $7-15$ 没有额外限制。", "locale": "zh-CN"}}}
