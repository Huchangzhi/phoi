{"pid": "P9820", "type": "P", "difficulty": 4, "samples": [["2 4\nX..X\nX.X.\nX.X.\n.X..", "X.XX\n.X.."]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2020", "上海", "Special Judge", "O2优化", "鸽笼原理", "构造", "ICPC", "Ad-hoc"], "title": "[ICPC 2020 Shanghai R] Mine Sweeper II", "background": "", "description": "A mine-sweeper map $X$ can be expressed as an $n\\times m$ grid. Each cell of the grid is either a mine cell or a non-mine cell. A mine cell has no number on it. Each non-mine cell has a number representing the number of mine cells around it. (A cell is around another cell if they share at least one common point. Thus, every cell that is not on the boundary has $8$ cells around it.) The following is a $16\\times 30$ mine-sweeper map where a flagged cell denotes a mine cell and a blank cell denotes a non-mine cell with number 0.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5bykwzuy.png)\n\nGiven two mine-sweeper maps $A, B$ of size $n\\times m$, you should modify at most $\\left\\lfloor\\frac{nm}{2}\\right\\rfloor$ (i.e. the largest nonnegative integer that is less than or equal to $\\frac{nm}{2}$) cells in $B$ (from a non-mine cell to a mine cell or vice versa) such that the sum of numbers in the non-mine cells in $A$ and the sum of numbers in the non-mine cells in $B$ are the same. (If a map has no non-mine cell, the sum is considered as $0$.)\n\nIf multiple solutions exist, print any of them. If no solution exists, print ``-1`` in one line.", "inputFormat": "The first line contains two integers $n, m\\,(1\\le n,m \\le 1000)$, denoting the size of given mine-sweeper maps.\n\nThe $i$-th line of the following $n$ lines contains a length-$m$ string consisting of  ``.`` and ``X`` denoting the $i$-th row of the mine-sweeper map $A$. A ``.`` denotes for a non-mine cell and an ``X`` denotes for a mine cell.\n\nThe $i$-th line of the following $n$ lines contains a length-$m$ string consisting of  ``.`` and ``X`` denoting the $i$-th row of the mine-sweeper map $B$. A ``.`` denotes for a non-mine cell and an ``X`` denotes for a mine cell.", "outputFormat": "If no solution exists, print ``-1`` in one line.\n\nOtherwise, print $n$ lines denoting the modified mine-sweeper map $B$. The $i$-th line should contain a length-$m$ string consisting of  ``.`` and ``X`` denoting the $i$-th row of the modified map $B$. A ``.`` denotes for a non-mine cell and an ``X`` denotes for a mine cell.\n\nPlease notice that you need not print the numbers on non-mine cells since these numbers can be determined by the output mine-sweeper map.", "hint": "We modify one cell in $B$. Then the sums of the numbers on non-mine cells in $A$ and $B$ both equal $10$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Mine Sweeper II", "background": "", "description": "A mine-sweeper map $X$ can be expressed as an $n\\times m$ grid. Each cell of the grid is either a mine cell or a non-mine cell. A mine cell has no number on it. Each non-mine cell has a number representing the number of mine cells around it. (A cell is around another cell if they share at least one common point. Thus, every cell that is not on the boundary has $8$ cells around it.) The following is a $16\\times 30$ mine-sweeper map where a flagged cell denotes a mine cell and a blank cell denotes a non-mine cell with number 0.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5bykwzuy.png)\n\nGiven two mine-sweeper maps $A, B$ of size $n\\times m$, you should modify at most $\\left\\lfloor\\frac{nm}{2}\\right\\rfloor$ (i.e. the largest nonnegative integer that is less than or equal to $\\frac{nm}{2}$) cells in $B$ (from a non-mine cell to a mine cell or vice versa) such that the sum of numbers in the non-mine cells in $A$ and the sum of numbers in the non-mine cells in $B$ are the same. (If a map has no non-mine cell, the sum is considered as $0$.)\n\nIf multiple solutions exist, print any of them. If no solution exists, print ``-1`` in one line.", "inputFormat": "The first line contains two integers $n, m\\,(1\\le n,m \\le 1000)$, denoting the size of given mine-sweeper maps.\n\nThe $i$-th line of the following $n$ lines contains a length-$m$ string consisting of  ``.`` and ``X`` denoting the $i$-th row of the mine-sweeper map $A$. A ``.`` denotes for a non-mine cell and an ``X`` denotes for a mine cell.\n\nThe $i$-th line of the following $n$ lines contains a length-$m$ string consisting of  ``.`` and ``X`` denoting the $i$-th row of the mine-sweeper map $B$. A ``.`` denotes for a non-mine cell and an ``X`` denotes for a mine cell.", "outputFormat": "If no solution exists, print ``-1`` in one line.\n\nOtherwise, print $n$ lines denoting the modified mine-sweeper map $B$. The $i$-th line should contain a length-$m$ string consisting of  ``.`` and ``X`` denoting the $i$-th row of the modified map $B$. A ``.`` denotes for a non-mine cell and an ``X`` denotes for a mine cell.\n\nPlease notice that you need not print the numbers on non-mine cells since these numbers can be determined by the output mine-sweeper map.", "hint": "We modify one cell in $B$. Then the sums of the numbers on non-mine cells in $A$ and $B$ both equal $10$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Mine Sweeper II", "background": "", "description": "扫雷地图 $X$ 可以表示为一个 $n \\times m$ 的网格。网格中的每个单元格要么是地雷单元格，要么是非地雷单元格。地雷单元格上没有数字。每个非地雷单元格有一个数字，表示其周围地雷单元格的数量。（如果一个单元格与另一个单元格共享至少一个公共点，则它们是相邻的。因此，每个不在边界上的单元格周围有 $8$ 个单元格。）以下是一个 $16 \\times 30$ 的扫雷地图，其中标记的单元格表示地雷单元格，空白单元格表示数字为 0 的非地雷单元格。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5bykwzuy.png)\n\n给定两个大小为 $n \\times m$ 的扫雷地图 $A, B$，你应该在 $B$ 中修改最多 $ \\left\\lfloor \\frac{nm}{2} \\right\\rfloor $（即小于或等于 $\\frac{nm}{2}$ 的最大非负整数）个单元格（从非地雷单元格变为地雷单元格或反之），使得 $A$ 中非地雷单元格的数字之和与 $B$ 中非地雷单元格的数字之和相同。（如果地图中没有非地雷单元格，则和被视为 $0$。）\n\n如果存在多个解，输出其中任意一个。如果不存在解，输出一行 ``-1``。", "inputFormat": "第一行包含两个整数 $n, m\\,(1\\le n,m \\le 1000)$，表示给定的扫雷地图的大小。\n\n接下来的 $n$ 行的第 $i$ 行包含一个长度为 $m$ 的字符串，由 ``.`` 和 ``X`` 组成，表示扫雷地图 $A$ 的第 $i$ 行。``.`` 表示非地雷单元格，``X`` 表示地雷单元格。\n\n接下来的 $n$ 行的第 $i$ 行包含一个长度为 $m$ 的字符串，由 ``.`` 和 ``X`` 组成，表示扫雷地图 $B$ 的第 $i$ 行。``.`` 表示非地雷单元格，``X`` 表示地雷单元格。", "outputFormat": "如果不存在解，输出一行 ``-1``。\n\n否则，输出 $n$ 行表示修改后的扫雷地图 $B$。第 $i$ 行应包含一个长度为 $m$ 的字符串，由 ``.`` 和 ``X`` 组成，表示修改后的地图 $B$ 的第 $i$ 行。``.`` 表示非地雷单元格，``X`` 表示地雷单元格。\n\n请注意，您不需要输出非地雷单元格上的数字，因为这些数字可以通过输出的扫雷地图确定。", "hint": "我们在 $B$ 中修改一个单元格。然后 $A$ 和 $B$ 中非地雷单元格上的数字之和都等于 10。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9821", "type": "P", "difficulty": 5, "samples": [["3\n3 3\n19 26\n8 17", "14\n814\n278"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "上海", "O2优化", "数位 DP", "ICPC"], "title": "[ICPC 2020 Shanghai R] Sum of Log", "background": "", "description": "Given two non-negative integers $X$ and $Y$, determine the value of \n$$ \\sum_{i=0}^{X}\\sum_{j=[i=0]}^{Y}[i\\&j=0]\\lfloor\\log_2(i+j)+1\\rfloor $$\nmodulo $10^9+7$ where\n- $\\&$ denotes bitwise AND;\n- $[A]$ equals 1 if $A$ is true, otherwise $0$;\n- $\\lfloor x\\rfloor$ equals the maximum integer whose value is no more than $x$.", "inputFormat": "The first line contains one integer $T\\,(1\\le T \\le 10^5)$ denoting the number of test cases.\n\nEach of the following $T$ lines contains two integers $X, Y\\,(0\\le X,Y \\le 10^9)$ indicating a test case.", "outputFormat": "For each test case, print one line containing one integer, the answer to the test case.", "hint": "For the first test case:\n- Two $(i,j)$ pairs increase the sum by 1: $(0, 1), (1, 0)$\n- Six $(i,j)$ pairs increase the sum by 2: $(0, 2), (0, 3), (1, 2), (2, 0), (2, 1), (3, 0)$\n\nSo the answer is $1\\times 2 + 2\\times 6 = 14$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Sum of Log", "background": "", "description": "Given two non-negative integers $X$ and $Y$, determine the value of \n$$ \\sum_{i=0}^{X}\\sum_{j=[i=0]}^{Y}[i\\&j=0]\\lfloor\\log_2(i+j)+1\\rfloor $$\nmodulo $10^9+7$ where\n- $\\&$ denotes bitwise AND;\n- $[A]$ equals 1 if $A$ is true, otherwise $0$;\n- $\\lfloor x\\rfloor$ equals the maximum integer whose value is no more than $x$.", "inputFormat": "The first line contains one integer $T\\,(1\\le T \\le 10^5)$ denoting the number of test cases.\n\nEach of the following $T$ lines contains two integers $X, Y\\,(0\\le X,Y \\le 10^9)$ indicating a test case.", "outputFormat": "For each test case, print one line containing one integer, the answer to the test case.", "hint": "For the first test case:\n- Two $(i,j)$ pairs increase the sum by 1: $(0, 1), (1, 0)$\n- Six $(i,j)$ pairs increase the sum by 2: $(0, 2), (0, 3), (1, 2), (2, 0), (2, 1), (3, 0)$\n\nSo the answer is $1\\times 2 + 2\\times 6 = 14$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Sum of Log", "background": "", "description": "给定两个非负整数 $X$ 和 $Y$，计算以下值：  \n$$ \\sum_{i=0}^{X}\\sum_{j=[i=0]}^{Y}[i\\&j=0]\\lfloor\\log_2(i+j)+1\\rfloor $$  \n对 $10^9+7$ 取模，其中  \n- $\\&$ 表示按位与运算；  \n- $[A]$ 的值为 1 如果 $A$ 为真，否则为 0；  \n- $\\lfloor x\\rfloor$ 表示不大于 $x$ 的最大整数。", "inputFormat": "第一行包含一个整数 $T\\,(1\\le T \\le 10^5)$，表示测试用例的数量。  \n\n接下来的 $T$ 行中，每行包含两个整数 $X, Y\\,(0\\le X,Y \\le 10^9)$，表示一个测试用例。", "outputFormat": "对于每个测试用例，输出一行一个整数，表示该测试用例的答案。", "hint": "对于第一个测试用例：  \n- 两个 $(i,j)$ 对使得和增加 1：$(0, 1), (1, 0)$  \n- 六个 $(i,j)$ 对使得和增加 2：$(0, 2), (0, 3), (1, 2), (2, 0), (2, 1), (3, 0)$  \n\n所以答案是 $1\\times 2 + 2\\times 6 = 14$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9822", "type": "P", "difficulty": 3, "samples": [["2\n10000.0 1.0 0.001 9999.0 0.001\n4306.063 4079.874 0.607 1033.423 0.847", "5001000.0000000000\n3827.8370013755"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2020", "二分", "上海", "Special Judge", "O2优化", "ICPC"], "title": "[ICPC 2020 Shanghai R] Walker", "background": "", "description": "As a world-famous traveler, Prof. Pang's research interest is to travel as many places as possible in his life.\n\nWe have a segment $[0, n]$. There are two travelers on it. The first one is on position $p_1$ with velocity $v_1$ (which means s/he can walk $v_1$ unit on the segment per second). The second one is on position $p_2$ with velocity $v_2$.\n\nFrom their respective beginning points, travelers can walk on the segment. They cannot walk outside the segment. Whenever they want to change their direction, they can turn around immediately.\n\nPlease help Prof. Pang to calculate the minimum  possible time by which every position of the segment is passed by at least one traveler.", "inputFormat": "The first line contains one integer $test~(1\\le test\\le 10000)$ -- the number of test cases.\n\nThe $i$-th of the next $test$ lines contains five numbers $n, p_{1, i}, v_{1, i}, p_{2, i}, v_{2, i}$ ($0 < n \\le 10000$, $0\\le p_{1, i},p_{2, i} \\le n$, $0.001 \\le v_{1, i},v_{2, i} \\le 1000$). All numbers have at most $3$ digits after the decimal point.", "outputFormat": "For each test case, we should output one number -- the minimum time that every position of the segment is passed by at least one traveler.\n\nYour answer is considered correct if its absolute or relative error does not exceed $10^{-6}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Walker", "background": "", "description": "As a world-famous traveler, Prof. Pang's research interest is to travel as many places as possible in his life.\n\nWe have a segment $[0, n]$. There are two travelers on it. The first one is on position $p_1$ with velocity $v_1$ (which means s/he can walk $v_1$ unit on the segment per second). The second one is on position $p_2$ with velocity $v_2$.\n\nFrom their respective beginning points, travelers can walk on the segment. They cannot walk outside the segment. Whenever they want to change their direction, they can turn around immediately.\n\nPlease help Prof. Pang to calculate the minimum  possible time by which every position of the segment is passed by at least one traveler.", "inputFormat": "The first line contains one integer $test~(1\\le test\\le 10000)$ -- the number of test cases.\n\nThe $i$-th of the next $test$ lines contains five numbers $n, p_{1, i}, v_{1, i}, p_{2, i}, v_{2, i}$ ($0 < n \\le 10000$, $0\\le p_{1, i},p_{2, i} \\le n$, $0.001 \\le v_{1, i},v_{2, i} \\le 1000$). All numbers have at most $3$ digits after the decimal point.", "outputFormat": "For each test case, we should output one number -- the minimum time that every position of the segment is passed by at least one traveler.\n\nYour answer is considered correct if its absolute or relative error does not exceed $10^{-6}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Walker", "background": "", "description": "作为一名世界闻名的旅行者，Pang 教授的研究兴趣是尽可能多地在他的一生中旅行到各个地方。\n\n我们有一个线段 $[0, n]$。在线段上有两名旅行者。第一位旅行者位于位置 $p_1$，速度为 $v_1$（这意味着他/她每秒可以在线段上行走 $v_1$ 单位）。第二位旅行者位于位置 $p_2$，速度为 $v_2$。\n\n从他们各自的起点开始，旅行者可以在线段上行走。他们不能走出线段。无论何时他们想要改变方向，他们可以立即转身。\n\n请帮助 Pang 教授计算每个位置至少被一名旅行者经过所需的最短时间。", "inputFormat": "第一行包含一个整数 $test~(1\\le test\\le 10000)$ —— 测试用例的数量。\n\n接下来的 $test$ 行中的第 $i$ 行包含五个数字 $n, p_{1, i}, v_{1, i}, p_{2, i}, v_{2, i}$ ($0 < n \\le 10000$, $0\\le p_{1, i},p_{2, i} \\le n$, $0.001 \\le v_{1, i},v_{2, i} \\le 1000$)。所有数字最多有 $3$ 位小数。", "outputFormat": "对于每个测试用例，输出一个数字 —— 每个位置至少被一名旅行者经过所需的最短时间。\n\n如果答案的绝对误差或相对误差不超过 $10^{-6}$，则认为答案是正确的。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9823", "type": "P", "difficulty": 5, "samples": [["1 1", "1"], ["2 3", "2"], ["3 2", "4"], ["4 2", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2020", "上海", "O2优化", "组合数学", "逆元", "ICPC"], "title": "[ICPC 2020 Shanghai R] The Journey of Geor Autumn", "background": "", "description": "Once upon a time, there was a witch named Geor Autumn, who set off on a journey across the world. Along the way, she would meet all kinds of people, from a country full of ICPC competitors to a horse in love with dota---but with each meeting, Geor would become a small part of their story, and her own world would get a little bit bigger.\n\nGeor just arrived at the state of Shu where people love poems. A poem is a permutation $(a_1,\\ldots, a_n)$ of $[n]$. ($(a_1,\\ldots, a_n)$ is a permutation of $[n]$ means that each $a_i$ is an integer in $[1,n]$ and that $a_1,\\ldots, a_n$ are distinct.) One poem is $\\textit{good}$ if for all integer $i$ satisfying $i> k$ and $i\\le n$, $a_i>\\min(a_{i-k}, \\ldots, a_{i-1})$. Here $\\min(a_{i-k}, \\ldots, a_{i-1})$ denotes the minimum value among $a_{i-k}, \\ldots, a_{i-1}$.\n\nHelp Geor calculate how many good poems there are, given $n$ and $k$. To avoid huge numbers, output the answer modulo $998244353$.", "inputFormat": "The first line contains two integers $n$ and $k$ separated by a single space ($1\\le n\\le 10^7$, $1\\le k\\le 10^7$).", "outputFormat": "Output only one integer in one line---the number of good poems modulo $998244353$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] The Journey of Geor Autumn", "background": "", "description": "Once upon a time, there was a witch named Geor Autumn, who set off on a journey across the world. Along the way, she would meet all kinds of people, from a country full of ICPC competitors to a horse in love with dota---but with each meeting, Geor would become a small part of their story, and her own world would get a little bit bigger.\n\nGeor just arrived at the state of Shu where people love poems. A poem is a permutation $(a_1,\\ldots, a_n)$ of $[n]$. ($(a_1,\\ldots, a_n)$ is a permutation of $[n]$ means that each $a_i$ is an integer in $[1,n]$ and that $a_1,\\ldots, a_n$ are distinct.) One poem is $\\textit{good}$ if for all integer $i$ satisfying $i> k$ and $i\\le n$, $a_i>\\min(a_{i-k}, \\ldots, a_{i-1})$. Here $\\min(a_{i-k}, \\ldots, a_{i-1})$ denotes the minimum value among $a_{i-k}, \\ldots, a_{i-1}$.\n\nHelp Geor calculate how many good poems there are, given $n$ and $k$. To avoid huge numbers, output the answer modulo $998244353$.", "inputFormat": "The first line contains two integers $n$ and $k$ separated by a single space ($1\\le n\\le 10^7$, $1\\le k\\le 10^7$).", "outputFormat": "Output only one integer in one line---the number of good poems modulo $998244353$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] The Journey of Geor Autumn", "background": null, "description": "给定 $1 \\le k \\le 10^7$，我们规定满足以下性质的 $1\\sim n$（其中 $ 1\\le n \\le 10^7$） 的排列为“好排列”：\n\n$$\\forall k<i \\le n,~a_i > \\min\\{a_{i-k},a_{i-k+1},...,a_{i-1}\\}$$\n\n求好排列的个数。对 $998244353$ 取模。", "inputFormat": "一行，两个整数 $n,k$。", "outputFormat": "一行，为好排列的个数对 $998244353$ 取模的值。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9824", "type": "P", "difficulty": 6, "samples": [["1\n1", "0"], ["2\n13 24", "26\n13\n0"], ["3\n6 4 7", "33\n21\n12\n8\n4\n0"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2020", "上海", "O2优化", "ICPC"], "title": "[ICPC 2020 Shanghai R] Fountains", "background": "", "description": "Suppose you and your teammate Mixsx will attend the Namomo Camp. The Namomo Camp will happen in $n$ consecutive days. We name the $i$-th day as day $i$ ($1\\le i\\le n$). The cost of day $i$ is $s_i$. \n\nUnfortunately, the schedule of the Namomo Camp conflicts with Mixsx's final exams. Mixsx has final exams every day between day $L$ and day $R$. The exact value of $L$ and $R$ have not been announced by his college so we assume that every pair of integers $L$ and $R$ satisfying $1\\le L\\le R\\le n$ will be chosen with probability $1/(n(n+1)/2)$. He decides to take all the exams and thus be absent from the Namomo Camp from day $L$ to day $R$. His $\\textit{loss}$ will be $\\sum_{i=L}^R s_i$ in this case. \n\nAs Mixsx's teammate, you want Mixsx to give up his final exams and come back to the Namomo Camp. You can prepare $k$ plans before $L$ and $R$ are announced. In the $i$-th plan ($1\\le i\\le k$), you shut the electricity off to his college every day from day $l_i$ to day $r_i$. You can choose the values of $l_i$ and $r_i$ as long as they are two integers satisfying $1\\le l_i\\le r_i\\le n$.\n\nOnce $L$ and $R$ are announced, you can choose a plan $x$ ($1\\le x\\le k$) such that $L\\le l_x\\le r_x\\le R$. Then Mixsx will come back to the Namomo Camp on every day from day $l_x$ to day $r_x$. His loss becomes $\\sum_{i=L}^R s_i-\\sum_{i=l_x}^{r_x} s_i$ in this case. You will choose a plan that minimizes Mixsx's loss. If no plan $x$ satisfies $L\\le l_x\\le r_x\\le R$, Mixsx will attend his final exams normally and his loss is $\\sum_{i=L}^R s_i$.\n\nPlease calculate the minimum possible expected loss $ans_k$ of Mixsx if you choose the $k$ plans optimally. Output $ans_k\\cdot n(n+1)/2$ for every $k$ from $1$ to $n(n+1)/2$.\n\nFormally, given a list of $n$ numbers $s_i$ $(1 \\leq i \\leq n)$, define a loss function $C(L, R) = \\sum_{i=L}^R s_i$. Given an integer $k$ ($1 \\leq k \\leq n (n + 1) / 2$), you should select $2k$ integers $l_1, \\ldots, l_k, r_1,\\ldots, r_k$ satisfying $1\\le l_i\\le r_i\\le n$ for all $1 \\leq i \\leq k$, such that\n\n$$\\sum_{1\\leq L\\leq  R\\leq n} \\left[C(L, R) - \\max_{1\\le i\\le k, L \\leq l_i \\leq r_i \\leq R} C(l_i, r_i) \\right]$$\n\n is minimized. ($\\max_{1\\le i\\le k, L \\leq l_i \\leq r_i \\leq R} C(l_i, r_i)$ is defined as $0$ if no $i$ satisfies $1\\le i\\le k$ and $L \\leq l_i \\leq r_i \\leq R$.) Output the minimized value for every integer $k$ in $[1, n(n + 1) / 2]$. ", "inputFormat": "The first line contains an integer $n~(1 \\leq n \\leq 9)$. The second line contains $n$ space separated integers $s_i~(1 \\leq s_i \\leq 10^9)$.", "outputFormat": "The output contains $n (n + 1) / 2$ integers in their own lines, the expectations when $k = 1, \\ldots, n (n + 1) / 2$ multiplied by $n (n + 1) / 2$. It can be shown that the results are always integers.", "hint": "For the first test case, we only need to consider the case $k = 1$. We can only choose $l_1=r_1=1$. Then the expected loss is $C(1, 1) - C(1, 1) = 0$ and the result is $0 \\times 1 \\times (2) / 2 = 0$.\n\nFor the third test case, consider the case when $k = 3$. We choose $l_1=r_1=1$, $l_2=r_2=3$ and $l_3=1, r_3=3$. The expected loss is $2$. And the result is $2 \\times 6 = 12$.", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Fountains", "background": "", "description": "Suppose you and your teammate Mixsx will attend the Namomo Camp. The Namomo Camp will happen in $n$ consecutive days. We name the $i$-th day as day $i$ ($1\\le i\\le n$). The cost of day $i$ is $s_i$. \n\nUnfortunately, the schedule of the Namomo Camp conflicts with Mixsx's final exams. Mixsx has final exams every day between day $L$ and day $R$. The exact value of $L$ and $R$ have not been announced by his college so we assume that every pair of integers $L$ and $R$ satisfying $1\\le L\\le R\\le n$ will be chosen with probability $1/(n(n+1)/2)$. He decides to take all the exams and thus be absent from the Namomo Camp from day $L$ to day $R$. His $\\textit{loss}$ will be $\\sum_{i=L}^R s_i$ in this case. \n\nAs Mixsx's teammate, you want Mixsx to give up his final exams and come back to the Namomo Camp. You can prepare $k$ plans before $L$ and $R$ are announced. In the $i$-th plan ($1\\le i\\le k$), you shut the electricity off to his college every day from day $l_i$ to day $r_i$. You can choose the values of $l_i$ and $r_i$ as long as they are two integers satisfying $1\\le l_i\\le r_i\\le n$.\n\nOnce $L$ and $R$ are announced, you can choose a plan $x$ ($1\\le x\\le k$) such that $L\\le l_x\\le r_x\\le R$. Then Mixsx will come back to the Namomo Camp on every day from day $l_x$ to day $r_x$. His loss becomes $\\sum_{i=L}^R s_i-\\sum_{i=l_x}^{r_x} s_i$ in this case. You will choose a plan that minimizes Mixsx's loss. If no plan $x$ satisfies $L\\le l_x\\le r_x\\le R$, Mixsx will attend his final exams normally and his loss is $\\sum_{i=L}^R s_i$.\n\nPlease calculate the minimum possible expected loss $ans_k$ of Mixsx if you choose the $k$ plans optimally. Output $ans_k\\cdot n(n+1)/2$ for every $k$ from $1$ to $n(n+1)/2$.\n\nFormally, given a list of $n$ numbers $s_i$ $(1 \\leq i \\leq n)$, define a loss function $C(L, R) = \\sum_{i=L}^R s_i$. Given an integer $k$ ($1 \\leq k \\leq n (n + 1) / 2$), you should select $2k$ integers $l_1, \\ldots, l_k, r_1,\\ldots, r_k$ satisfying $1\\le l_i\\le r_i\\le n$ for all $1 \\leq i \\leq k$, such that\n\n$$\\sum_{1\\leq L\\leq  R\\leq n} \\left[C(L, R) - \\max_{1\\le i\\le k, L \\leq l_i \\leq r_i \\leq R} C(l_i, r_i) \\right]$$\n\n is minimized. ($\\max_{1\\le i\\le k, L \\leq l_i \\leq r_i \\leq R} C(l_i, r_i)$ is defined as $0$ if no $i$ satisfies $1\\le i\\le k$ and $L \\leq l_i \\leq r_i \\leq R$.) Output the minimized value for every integer $k$ in $[1, n(n + 1) / 2]$. ", "inputFormat": "The first line contains an integer $n~(1 \\leq n \\leq 9)$. The second line contains $n$ space separated integers $s_i~(1 \\leq s_i \\leq 10^9)$.", "outputFormat": "The output contains $n (n + 1) / 2$ integers in their own lines, the expectations when $k = 1, \\ldots, n (n + 1) / 2$ multiplied by $n (n + 1) / 2$. It can be shown that the results are always integers.", "hint": "For the first test case, we only need to consider the case $k = 1$. We can only choose $l_1=r_1=1$. Then the expected loss is $C(1, 1) - C(1, 1) = 0$ and the result is $0 \\times 1 \\times (2) / 2 = 0$.\n\nFor the third test case, consider the case when $k = 3$. We choose $l_1=r_1=1$, $l_2=r_2=3$ and $l_3=1, r_3=3$. The expected loss is $2$. And the result is $2 \\times 6 = 12$.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Fountains", "background": "", "description": "假设你和你的队友 Mixsx 将参加 Namomo 训练营。Namomo 训练营将持续 $n$ 天。我们将第 $i$ 天命名为第 $i$ 天（$1 \\le i \\le n$）。第 $i$ 天的费用为 $s_i$。\n\n不幸的是，Namomo 训练营的日程与 Mixsx 的期末考试冲突。Mixsx 在从第 $L$ 天到第 $R$ 天的每一天都有期末考试。他的大学尚未宣布 $L$ 和 $R$ 的确切值，因此我们假设每对整数 $L$ 和 $R$ 满足 $1 \\le L \\le R \\le n$ 的情况将以概率 $1/(n(n+1)/2)$ 被选择。他决定参加所有考试，因此将从第 $L$ 天到第 $R$ 天缺席 Namomo 训练营。在这种情况下，他的损失将是 $\\sum_{i=L}^R s_i$。\n\n作为 Mixsx 的队友，你希望 Mixsx 放弃他的期末考试并回到 Namomo 训练营。在 $L$ 和 $R$ 公布之前，你可以准备 $k$ 个计划。在第 $i$ 个计划中（$1 \\le i \\le k$），你每天从第 $l_i$ 天到第 $r_i$ 天关闭他的大学的电源。你可以选择 $l_i$ 和 $r_i$ 的值，只要它们是满足 $1 \\le l_i \\le r_i \\le n$ 的两个整数。\n\n一旦 $L$ 和 $R$ 被宣布，你可以选择一个计划 $x$（$1 \\le x \\le k$），使得 $L \\le l_x \\le r_x \\le R$。然后 Mixsx 将在从第 $l_x$ 天到第 $r_x$ 天的每一天回到 Namomo 训练营。在这种情况下，他的损失变为 $\\sum_{i=L}^R s_i - \\sum_{i=l_x}^{r_x} s_i$。你将选择一个计划以最小化 Mixsx 的损失。如果没有计划 $x$ 满足 $L \\le l_x \\le r_x \\le R$，Mixsx 将正常参加他的期末考试，他的损失是 $\\sum_{i=L}^R s_i$。\n\n请计算如果你选择 $k$ 个计划最优地，Mixsx 的最小可能期望损失 $ans_k$。输出每个从 $1$ 到 $n(n+1)/2$ 的 $k$ 的 $ans_k \\cdot n(n+1)/2$。\n\n形式上，给定一个 $n$ 个数字 $s_i$ 的列表（$1 \\leq i \\leq n$），定义损失函数 $C(L, R) = \\sum_{i=L}^R s_i$。给定一个整数 $k$（$1 \\leq k \\leq n(n+1)/2$），你应该选择 $2k$ 个整数 $l_1, \\ldots, l_k, r_1, \\ldots, r_k$ 满足对于所有 $1 \\leq i \\leq k$，$1 \\le l_i \\le r_i \\le n$，使得\n\n$$\\sum_{1 \\leq L \\leq R \\leq n} \\left[C(L, R) - \\max_{1 \\le i \\le k, L \\leq l_i \\leq r_i \\leq R} C(l_i, r_i) \\right]$$\n\n被最小化。（如果没有 $i$ 满足 $1 \\le i \\le k$ 且 $L \\leq l_i \\leq r_i \\leq R$，则 $\\max_{1 \\le i \\le k, L \\leq l_i \\leq r_i \\leq R} C(l_i, r_i)$ 定义为 $0$。）输出每个整数 $k$ 在 $[1, n(n+1)/2]$ 中的最小化值。", "inputFormat": "第一行包含一个整数 $n~(1 \\leq n \\leq 9)$。第二行包含 $n$ 个用空格分隔的整数 $s_i~(1 \\leq s_i \\leq 10^9)$。", "outputFormat": "输出包含 $n(n+1)/2$ 个整数，每个整数占一行，表示当 $k = 1, \\ldots, n(n+1)/2$ 时的期望值乘以 $n(n+1)/2$。可以证明结果总是整数。", "hint": "对于第一个测试用例，我们只需要考虑 $k = 1$ 的情况。我们只能选择 $l_1 = r_1 = 1$。然后期望损失是 $C(1, 1) - C(1, 1) = 0$，结果是 $0 \\times 1 \\times (2) / 2 = 0$。\n\n对于第三个测试用例，考虑 $k = 3$ 的情况。我们选择 $l_1 = r_1 = 1$，$l_2 = r_2 = 3$ 和 $l_3 = 1, r_3 = 3$。期望损失是 $2$。结果是 $2 \\times 6 = 12$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9825", "type": "P", "difficulty": 2, "samples": [["3", "2"], ["10", "24"], ["100", "2739"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2020", "数论", "上海", "O2优化", "ICPC"], "title": "[ICPC 2020 Shanghai R] Fibonacci", "background": "", "description": "In mathematics, the Fibonacci numbers, commonly denoted as $f_n$, is a sequence such that each number is the sum of the two preceding numbers, starting with $1$ and $1$. That is, $f_1 = 1, f_2 = 1$ and $f_n = f_{n-2} + f_{n-1}~(n \\ge 3)$.\n\nThus, the beginning of the sequence is $1, 1, 2, 3, 5, 8, 13, 21,\\ldots$ .\n\nGiven $n$, please calculate $\\sum_{i=1}^{n}{\\sum_{j=i+1}^{n}{g(f_i,f_j)}}$, where $g(x,y) = 1$ when $x \\cdot y$ is even, otherwise $g(x,y) = 0$.", "inputFormat": "The only line contains one integer $n~(1\\le n\\le 10^9)$.", "outputFormat": "Output one number -- $\\sum_{i=1}^{n}{\\sum_{j=i+1}^{n}{g(f_i,f_j)}}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Fibonacci", "background": "", "description": "In mathematics, the Fibonacci numbers, commonly denoted as $f_n$, is a sequence such that each number is the sum of the two preceding numbers, starting with $1$ and $1$. That is, $f_1 = 1, f_2 = 1$ and $f_n = f_{n-2} + f_{n-1}~(n \\ge 3)$.\n\nThus, the beginning of the sequence is $1, 1, 2, 3, 5, 8, 13, 21,\\ldots$ .\n\nGiven $n$, please calculate $\\sum_{i=1}^{n}{\\sum_{j=i+1}^{n}{g(f_i,f_j)}}$, where $g(x,y) = 1$ when $x \\cdot y$ is even, otherwise $g(x,y) = 0$.", "inputFormat": "The only line contains one integer $n~(1\\le n\\le 10^9)$.", "outputFormat": "Output one number -- $\\sum_{i=1}^{n}{\\sum_{j=i+1}^{n}{g(f_i,f_j)}}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Fibonacci", "background": "", "description": "在数学中，斐波那契数列通常用 $f_n$ 表示，是一个序列，其中每个数字是前两个数字之和，起始为 $1$ 和 $1$。即 $f_1 = 1, f_2 = 1$，且 $f_n = f_{n-2} + f_{n-1}~(n \\ge 3)$。\n\n因此，该序列的开头是 $1, 1, 2, 3, 5, 8, 13, 21,\\ldots$。\n\n给定 $n$，请计算 $\\sum_{i=1}^{n}{\\sum_{j=i+1}^{n}{g(f_i,f_j)}}$，其中 $g(x,y) = 1$ 当 $x \\cdot y$ 为偶数时，否则 $g(x,y) = 0$。", "inputFormat": "唯一一行包含一个整数 $n~(1\\le n\\le 10^9)$。", "outputFormat": "输出一个数字 -- $\\sum_{i=1}^{n}{\\sum_{j=i+1}^{n}{g(f_i,f_j)}}$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9826", "type": "P", "difficulty": 5, "samples": [["1\n4 2\n0 3\n1 2", "2"], ["1\n14 5\n0 12 13 8 9\n9 2 6 13 5", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "贪心", "2020", "上海", "O2优化", "ICPC"], "title": "[ICPC 2020 Shanghai R] Rice Arrangement", "background": "", "description": "Wowo is a hospitable Xinjiang uncle. $k$ guests will have Uyghur Polo (a traditional Uyghur food) in Wowo's house around a big round table. $n$ ($n\\ge k$) chairs are placed around the table uniformly. Each guest sits on a chair and no two guests sit on the same chair. $k$ bowls of Uyghur Polo are on the table. Each bowl is next to some chair ($\\textbf{with or without}$ some guest sitting on it). No two bowls locate at the same position.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q3gqhsvq.png)\n\nAs a waiter, you are supposed to assign each person with exactly one bowl of Uyghur Polo. The table can be rotated, so each time you can turn it $\\frac{2\\pi}{n}$ degrees clockwise or counterclockwise. The bowls turn with the table while the chairs and guests do not move. When one bowl of Uyghur Polo is in front of a guest, he can either take it or wait for another.\n\nYou want to minimize the total times of table rotating so that everybody can have meals as quickly as possible.\n\n(Formal definition: The boundary of the table is a circle. $n$ chairs are at $n$ points on the circle whose convex hull is a regular polygon with $n$ vertices. We name the points $0,\\ldots, n-1$ in counterclockwise order. The $i$-th bowl is at point $b_i$ ($0\\le b_i<n$) initially. The $i$-th guest is at point $a_i$ ($0\\le a_i < n$) initially. If you turn the table counterclockwise, the bowl at point $b_i$ ($1\\le i\\le k$) will be moved to point $(b_i+ 1) \\bmod n$ after the rotation. If you turn the table clockwise, the bowl at point $b_i$ ($1\\le i\\le k$) will be moved to point $(b_i-1) \\bmod n$ after the rotation. ($x\\bmod n$ is defined as the smallest nonnegative integer $r$ such that $x-r$ is a multiple of $n$.))\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n,k$ ($1\\le n \\le 10^9,1 \\le k \\le \\min(n,1000)$) indicating the size of the table and the number of persons and bowls of Uyghur Polo. \n\nIn the second line, there are $k$ integers $a_1,a_2,\\dots,a_k$ ($0 \\le a_i < n$), indicating the positions of the persons. No two guests share the same position.\n\nIn the third line, there are $k$ integers $b_1,b_2,\\dots,b_k$ ($0 \\le b_i < n$), indicating the initial positions of the bowls. No two bowls of Uyghur Polo locate at the same position.\n\nIt is guaranteed that the sum of $k$ over all test cases does not exceed $5000$.", "outputFormat": "For each test case, output the minimal total times of rotations such that each guest can have exactly one bowl of Uyghur Polo.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Rice Arrangement", "background": "", "description": "Wowo is a hospitable Xinjiang uncle. $k$ guests will have Uyghur Polo (a traditional Uyghur food) in Wowo's house around a big round table. $n$ ($n\\ge k$) chairs are placed around the table uniformly. Each guest sits on a chair and no two guests sit on the same chair. $k$ bowls of Uyghur Polo are on the table. Each bowl is next to some chair ($\\textbf{with or without}$ some guest sitting on it). No two bowls locate at the same position.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q3gqhsvq.png)\n\nAs a waiter, you are supposed to assign each person with exactly one bowl of Uyghur Polo. The table can be rotated, so each time you can turn it $\\frac{2\\pi}{n}$ degrees clockwise or counterclockwise. The bowls turn with the table while the chairs and guests do not move. When one bowl of Uyghur Polo is in front of a guest, he can either take it or wait for another.\n\nYou want to minimize the total times of table rotating so that everybody can have meals as quickly as possible.\n\n(Formal definition: The boundary of the table is a circle. $n$ chairs are at $n$ points on the circle whose convex hull is a regular polygon with $n$ vertices. We name the points $0,\\ldots, n-1$ in counterclockwise order. The $i$-th bowl is at point $b_i$ ($0\\le b_i<n$) initially. The $i$-th guest is at point $a_i$ ($0\\le a_i < n$) initially. If you turn the table counterclockwise, the bowl at point $b_i$ ($1\\le i\\le k$) will be moved to point $(b_i+ 1) \\bmod n$ after the rotation. If you turn the table clockwise, the bowl at point $b_i$ ($1\\le i\\le k$) will be moved to point $(b_i-1) \\bmod n$ after the rotation. ($x\\bmod n$ is defined as the smallest nonnegative integer $r$ such that $x-r$ is a multiple of $n$.))\n", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n,k$ ($1\\le n \\le 10^9,1 \\le k \\le \\min(n,1000)$) indicating the size of the table and the number of persons and bowls of Uyghur Polo. \n\nIn the second line, there are $k$ integers $a_1,a_2,\\dots,a_k$ ($0 \\le a_i < n$), indicating the positions of the persons. No two guests share the same position.\n\nIn the third line, there are $k$ integers $b_1,b_2,\\dots,b_k$ ($0 \\le b_i < n$), indicating the initial positions of the bowls. No two bowls of Uyghur Polo locate at the same position.\n\nIt is guaranteed that the sum of $k$ over all test cases does not exceed $5000$.", "outputFormat": "For each test case, output the minimal total times of rotations such that each guest can have exactly one bowl of Uyghur Polo.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Rice Arrangement", "background": null, "description": "Wowo 是一位好客的新疆大叔。$k$ 位客人将在 Wowo 家中围着一张大圆桌享用维吾尔抓饭（一种传统的维吾尔食物）。圆桌周围均匀地放置了 $n$ 把椅子（$n \\ge k$）。每位客人坐在一把椅子上，并且没有两位客人坐在同一把椅子上。桌子上有 $k$ 碗维吾尔抓饭。每碗抓饭都放在某把椅子旁边（**无论是否**有客人坐在上面）。没有两碗抓饭放在同一位置。\n\n作为服务员，你需要为每个人分配一碗维吾尔抓饭。桌子可以旋转，因此每次你可以顺时针或逆时针旋转 $\\frac{2\\pi}{n}$ 度。碗会随着桌子一起旋转，而椅子和客人不动。当一碗维吾尔抓饭在某位客人面前时，他可以选择拿起它或等待另一碗。\n\n你希望尽量减少桌子旋转的总次数，以便每个人都能尽快用餐。\n\n（正式定义：桌子的边界是一个圆。$n$ 把椅子位于圆上的 $n$ 个点，其凸包是一个有 $n$ 个顶点的正多边形。我们按逆时针顺序将这些点命名为 $0,\\ldots, n-1$。第 $i$ 碗抓饭最初位于点 $b_i$ ($0\\le b_i<n$)。第 $i$ 位客人最初位于点 $a_i$ ($0\\le a_i < n$)。如果你逆时针旋转桌子，位于点 $b_i$ ($1\\le i\\le k$) 的碗将在旋转后移动到点 $(b_i+ 1) \\bmod n$。如果你顺时针旋转桌子，位于点 $b_i$ ($1\\le i\\le k$) 的碗将在旋转后移动到点 $(b_i-1) \\bmod n$。($x\\bmod n$ 定义为最小的非负整数 $r$ 使得 $x-r$ 是 $n$ 的倍数。)）", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含两个整数 $n,k$ ($1\\le n \\le 10^9,1 \\le k \\le \\min(n,1000)$)，表示桌子的大小以及人数和维吾尔抓饭的碗数。\n\n第二行有 $k$ 个整数 $a_1,a_2,\\dots,a_k$ ($0 \\le a_i < n$)，表示客人的位置。没有两位客人共享同一位置。\n\n第三行有 $k$ 个整数 $b_1,b_2,\\dots,b_k$ ($0 \\le b_i < n$)，表示碗的初始位置。没有两碗维吾尔抓饭放在同一位置。\n\n保证所有测试用例中 $k$ 的总和不超过 $5000$。", "outputFormat": "对于每个测试用例，输出使得每位客人能恰好得到一碗维吾尔抓饭的最小旋转总次数。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9827", "type": "P", "difficulty": 4, "samples": [["1 2", "14.2831853072"], ["2 3", "175.4159265359"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "数学", "2020", "上海", "Special Judge", "O2优化", "ICPC"], "title": "[ICPC 2020 Shanghai R] Sky Garden", "background": "", "description": "Prof. Du and Prof. Pang plan to build a sky garden near the city of Allin. In the garden, there will be a plant maze consisting of straight and circular roads.\n\nOn the blueprint of the plant maze, Prof. Du draws $n$ circles indicating the circular roads. All of them have center $(0, 0)$. The radius of the $i$-th circle is $i$.\n\nMeanwhile, Prof. Pang draws $m$ lines on the blueprint indicating the straight roads. All of the lines pass through $(0, 0)$. Each circle is divided into $2m$ parts with equal lengths by these lines.\n\nLet $Q$ be the set of the $n+m$ roads. Let $P$ be the set of all intersections of two different roads in $Q$. Note that each circular road and each straight road have two intersections.\n\nFor two different points $a\\in P$ and $b\\in P$, we define $dis(\\{a, b\\})$ to be the shortest distance one needs to walk from $a$ to $b$ along the roads. Please calculate the sum of $dis(\\{a, b\\})$ for all $\\{a, b\\}\\subseteq P$. ", "inputFormat": "The only line contains two integers $n,m~(1\\le n,m\\le 500)$.", "outputFormat": "Output one number -- the sum of the distances between every pair of points in $P$.\n\nYour answer is considered correct if its absolute or relative error does not exceed $10^{-6}$.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/81sxvtcp.png)\n\n$dis(p_1, p_2)=dis(p_2, p_3)=dis(p_3, p_4)=dis(p_1, p_4)=\\frac{\\pi}{2}$\n\n$dis(p_1, p_5)=dis(p_2, p_5)=dis(p_3, p_5)=dis(p_4, p_5)=1$\n\n$dis(p_1, p_3)=dis(p_2, p_4)=2$", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Sky Garden", "background": "", "description": "Prof. Du and Prof. Pang plan to build a sky garden near the city of Allin. In the garden, there will be a plant maze consisting of straight and circular roads.\n\nOn the blueprint of the plant maze, Prof. Du draws $n$ circles indicating the circular roads. All of them have center $(0, 0)$. The radius of the $i$-th circle is $i$.\n\nMeanwhile, Prof. Pang draws $m$ lines on the blueprint indicating the straight roads. All of the lines pass through $(0, 0)$. Each circle is divided into $2m$ parts with equal lengths by these lines.\n\nLet $Q$ be the set of the $n+m$ roads. Let $P$ be the set of all intersections of two different roads in $Q$. Note that each circular road and each straight road have two intersections.\n\nFor two different points $a\\in P$ and $b\\in P$, we define $dis(\\{a, b\\})$ to be the shortest distance one needs to walk from $a$ to $b$ along the roads. Please calculate the sum of $dis(\\{a, b\\})$ for all $\\{a, b\\}\\subseteq P$. ", "inputFormat": "The only line contains two integers $n,m~(1\\le n,m\\le 500)$.", "outputFormat": "Output one number -- the sum of the distances between every pair of points in $P$.\n\nYour answer is considered correct if its absolute or relative error does not exceed $10^{-6}$.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/81sxvtcp.png)\n\n$dis(p_1, p_2)=dis(p_2, p_3)=dis(p_3, p_4)=dis(p_1, p_4)=\\frac{\\pi}{2}$\n\n$dis(p_1, p_5)=dis(p_2, p_5)=dis(p_3, p_5)=dis(p_4, p_5)=1$\n\n$dis(p_1, p_3)=dis(p_2, p_4)=2$", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Sky Garden", "background": "", "description": "杜教授和庞教授计划在 Allin 市附近建造一个空中花园。在花园中，将有一个由直路和环形路组成的植物迷宫。\n\n在植物迷宫的蓝图上，杜教授画了 $n$ 个圆，表示环形路。所有圆的圆心都是 $(0, 0)$。第 $i$ 个圆的半径是 $i$。\n\n同时，庞教授在蓝图上画了 $m$ 条直线，表示直路。所有的直线都经过 $(0, 0)$。每个圆被这些直线等分成 $2m$ 个部分。\n\n设 $Q$ 为 $n+m$ 条道路的集合。设 $P$ 为 $Q$ 中两条不同道路的所有交点的集合。注意，每条环形路和每条直路都有两个交点。\n\n对于两个不同的点 $a \\in P$ 和 $b \\in P$，我们定义 $dis(\\{a, b\\})$ 为沿着道路从 $a$ 到 $b$ 需要走的最短距离。请计算对于所有 $\\{a, b\\} \\subseteq P$ 的 $dis(\\{a, b\\})$ 的和。", "inputFormat": "唯一一行包含两个整数 $n,m~(1\\le n,m\\le 500)$。", "outputFormat": "输出一个数字——$P$ 中每对点之间距离的总和。\n\n你的答案被认为是正确的，如果其绝对误差或相对误差不超过 $10^{-6}$。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/81sxvtcp.png)\n\n$dis(p_1, p_2)=dis(p_2, p_3)=dis(p_3, p_4)=dis(p_1, p_4)=\\frac{\\pi}{2}$\n\n$dis(p_1, p_5)=dis(p_2, p_5)=dis(p_3, p_5)=dis(p_4, p_5)=1$\n\n$dis(p_1, p_3)=dis(p_2, p_4)=2$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9828", "type": "P", "difficulty": 7, "samples": [["3\n0 1 0 1 0 1\n10 11 10 11 10 11\n999999999 1000000000 999999999 1000000000 999999999 1000000000", "YES\n0 10 999999999"], ["4\n0 1 0 1 0 1\n999999999 1000000000 0 1 0 1\n0 1 999999999 1000000000 0 1\n0 1 0 1 999999999 1000000000", "YES\n0 0 0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "线段树", "上海", "Special Judge", "O2优化", "ICPC"], "title": "[ICPC 2020 Shanghai R] Octasection", "background": "", "description": "\nAt the Namomo Camp, a cute volunteer celebrates her birthday. Wowo buys her a huge cake. (The cake is so big that it has a 3D coordinate system inside.) There are $n$ cuboid shaped pieces of chocolates $\\textbf{in}$ the cake. The $i$-th ($1\\le i\\le n$) chocolate consists of all points $(x,y,z)$ such that $min\\_x[i]\\le x\\le max\\_x[i], min\\_y[i]\\le y\\le max\\_y[i], min\\_z[i]\\le z\\le max\\_z[i]$. $min\\_x,max\\_x, min\\_y,max\\_y, min\\_z, max\\_z$ are $6$ arrays of integers. Chocolates may overlap or touch each other.\n\nThe volunteer wants to distribute the cake to the campers of the Namomo Camp. To show off his knife skill, Wowo decides to cut the cake into pieces by exactly $3$ cuts such that:\n\n- The first cut is a plane whose equation is $x=a$ for some integer $a$ decided by Wowo.\n- The second cut is a plane whose equation is $y=b$ for some integer $b$ decided by Wowo.\n- The third cut is a plane whose equation is $z=c$ for some integer $c$ decided by Wowo.\n- Each chocolate is $\\textbf{touched}$ by at least one cut (i.e. each cuboid has a nonempty intersection with at least one plane).\n\nDecide whether Wowo can cut the cake under the rules. If the answer is yes, output any possible solution.", "inputFormat": "The first line contains a single integer $n$ ($1\\le n\\le 100000$).\n\nThe $i$-th line of the next $n$ lines contains $6$ integers $min\\_x[i],max\\_x[i], min\\_y[i],max\\_y[i], min\\_z[i], max\\_z[i]$ ($-10^9\\le min\\_x[i],max\\_x[i], min\\_y[i],max\\_y[i], min\\_z[i], max\\_z[i]\\le 10^9$, $min\\_x[i]<max\\_x[i]$, $min\\_y[i]<max\\_y[i]$, $min\\_z[i]< max\\_z[i]$).", "outputFormat": "If Wowo can cut the cake under the rules, the first line of the output should contain ``YES`` and the second line should contain $3$ integers $a$, $b$ and $c$ ($-10^9\\le a, b, c\\le 10^9$). If Wowo cannot cut the cake under the rules, output only one line containing ``NO``.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Octasection", "background": "", "description": "\nAt the Namomo Camp, a cute volunteer celebrates her birthday. Wowo buys her a huge cake. (The cake is so big that it has a 3D coordinate system inside.) There are $n$ cuboid shaped pieces of chocolates $\\textbf{in}$ the cake. The $i$-th ($1\\le i\\le n$) chocolate consists of all points $(x,y,z)$ such that $min\\_x[i]\\le x\\le max\\_x[i], min\\_y[i]\\le y\\le max\\_y[i], min\\_z[i]\\le z\\le max\\_z[i]$. $min\\_x,max\\_x, min\\_y,max\\_y, min\\_z, max\\_z$ are $6$ arrays of integers. Chocolates may overlap or touch each other.\n\nThe volunteer wants to distribute the cake to the campers of the Namomo Camp. To show off his knife skill, Wowo decides to cut the cake into pieces by exactly $3$ cuts such that:\n\n- The first cut is a plane whose equation is $x=a$ for some integer $a$ decided by Wowo.\n- The second cut is a plane whose equation is $y=b$ for some integer $b$ decided by Wowo.\n- The third cut is a plane whose equation is $z=c$ for some integer $c$ decided by Wowo.\n- Each chocolate is $\\textbf{touched}$ by at least one cut (i.e. each cuboid has a nonempty intersection with at least one plane).\n\nDecide whether Wowo can cut the cake under the rules. If the answer is yes, output any possible solution.", "inputFormat": "The first line contains a single integer $n$ ($1\\le n\\le 100000$).\n\nThe $i$-th line of the next $n$ lines contains $6$ integers $min\\_x[i],max\\_x[i], min\\_y[i],max\\_y[i], min\\_z[i], max\\_z[i]$ ($-10^9\\le min\\_x[i],max\\_x[i], min\\_y[i],max\\_y[i], min\\_z[i], max\\_z[i]\\le 10^9$, $min\\_x[i]<max\\_x[i]$, $min\\_y[i]<max\\_y[i]$, $min\\_z[i]< max\\_z[i]$).", "outputFormat": "If Wowo can cut the cake under the rules, the first line of the output should contain ``YES`` and the second line should contain $3$ integers $a$, $b$ and $c$ ($-10^9\\le a, b, c\\le 10^9$). If Wowo cannot cut the cake under the rules, output only one line containing ``NO``.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Octasection", "background": "", "description": "在 Namomo 营地，一位可爱的志愿者庆祝她的生日。Wowo 给她买了一个巨大的蛋糕。（蛋糕大到里面有一个三维坐标系。）蛋糕中有 $n$ 块长方体形状的巧克力。第 $i$ 块巧克力（$1 \\le i \\le n$）包含所有满足 $min\\_x[i] \\le x \\le max\\_x[i], min\\_y[i] \\le y \\le max\\_y[i], min\\_z[i] \\le z \\le max\\_z[i]$ 的点 $(x,y,z)$。$min\\_x, max\\_x, min\\_y, max\\_y, min\\_z, max\\_z$ 是 $6$ 个整数数组。巧克力可能会重叠或接触。\n\n志愿者想要将蛋糕分给 Namomo 营地的露营者。为了展示他的刀工，Wowo 决定通过恰好 $3$ 刀将蛋糕切成几块，使得：\n\n- 第一刀是一个方程为 $x=a$ 的平面，其中 $a$ 是 Wowo 决定的某个整数。\n- 第二刀是一个方程为 $y=b$ 的平面，其中 $b$ 是 Wowo 决定的某个整数。\n- 第三刀是一个方程为 $z=c$ 的平面，其中 $c$ 是 Wowo 决定的某个整数。\n- 每块巧克力至少被一刀“碰到”（即每个长方体与至少一个平面有非空交集）。\n\n判断 Wowo 是否可以按照规则切蛋糕。如果答案是肯定的，输出任意一个可能的解决方案。", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 100000$）。\n\n接下来的 $n$ 行中，第 $i$ 行包含 $6$ 个整数 $min\\_x[i], max\\_x[i], min\\_y[i], max\\_y[i], min\\_z[i], max\\_z[i]$（$-10^9 \\le min\\_x[i], max\\_x[i], min\\_y[i], max\\_y[i], min\\_z[i], max\\_z[i] \\le 10^9$，$min\\_x[i] < max\\_x[i]$，$min\\_y[i] < max\\_y[i]$，$min\\_z[i] < max\\_z[i]$）。", "outputFormat": "如果 Wowo 可以按照规则切蛋糕，输出的第一行应为 \"YES\"，第二行应包含 $3$ 个整数 $a$，$b$ 和 $c$（$-10^9 \\le a, b, c \\le 10^9$）。如果 Wowo 不能按照规则切蛋糕，只需输出一行 \"NO\"。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9829", "type": "P", "difficulty": 6, "samples": [["2\n4 4\nLHLH\n0 1\n1 2\n1 3\n2 3\n3 3\nLHH\n0 1\n0 2\n1 2", "yes\nno"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "上海", "O2优化", "双连通分量", "最近公共祖先 LCA", "ICPC"], "title": "[ICPC 2020 Shanghai R] Traveling Merchant", "background": null, "description": "Mr. Lawrence is a traveling merchant who travels between cities and resells products. Basically, to earn from it, he needs to buy products at a very low price and sell them at a higher price. Your task is to tell him whether there exists an endless traveling path that can earn money all the time.\n\nTo make things simple, suppose there are $n$ cities named from $0$ to $n-1$ and $m$ undirected roads each of which connecting two cities. Mr. Lawrence can travel between cities along the roads. Initially he is located at city $0$ and each of the city $i$ has a starting price $c_i$, either $\\text{Low}$ or $\\text{High}$. Due to the law of markets, the price status at city $i$ will change (i.e. $\\text{High}$ price will become $\\text{Low}$ price, or vice versa) after he departs for a neighboring city $j$ from $i$. (City $j$ is a neighboring city of city $i$ when one of the $m$ roads connects city $i$ and city $j$.) For some reasons (e.g. product freshness, traveling fee, tax), he $\\textbf{must}$:\n\n- Start at city $0$ and buy products at city $0$. It is guaranteed that $c_0$ is $\\text{Low}$.\n- When he arrives some city, he either sells products or buys products. It is not allowed for him to do nothing before he leaves the city.\n- After buying products at some city $i$, he must travel to some neighboring city $j$ whose price $c_j$ is $\\text{High}$ and sell the products at city $j$.\n- After selling products at some city $i$, he must travel to some neighboring city $j$ whose price $c_j$ is $\\text{Low}$ and buy the products at city $j$.\n\nAs a result, the path will look like an alternation between ``buy at low price`` and ``sell at high price``.\n\nAn endless earning path is defined as a path consisting of an endless sequence of cities $p_0, p_1,\\dots$ where city $p_i$ and city $p_{i+1}$ has a road, $p_0=0$, and the price alternates, in other words $c_{p_{2k}}=\\text{Low}$ (indicates a buy-in) and $c_{p_{2k+1}}=\\text{High}$ (indicates a sell-out) for $k\\geq0$. Please note here $c_{p_i}$ is the price when $\\textbf{arriving}$ city $p_i$ and this value may be different when he arrives the second time.\n\nYour task is to determine whether there exists any such path.", "inputFormat": "There are several test cases. The first line contains a positive integer $T$ indicating the number of test cases. Each test case begins with two positive integers $n$ and $m$ indicating the number of cities and the number of roads. \n\nThe next line is a string $c$ of length $n$ containing `H` or `L`. The $i$-th ($0\\le i<n$) charactor of $c$ is $H$ if the starting price $c_i$ at city $i$ is $\\text{High}$. The $i$-th ($0\\le i<n$) charactor of $c$ is $L$ if the starting price $c_i$ at city $i$ is $\\text{Low}$. \n\nThe $i$-th line ($1\\le i\\le m$) of the following $m$ lines contains two different cities $u_i$ and $v_i$, indicating a road between $u_i$ and $v_i$.\n\nThe sum of the values of $n$ over all test cases is no more than $200,000$. The sum of the values of $m$ over all test cases is no more than $200,000$. For each test case, $c_i\\in\\{\\text{H},\\text{L}\\}$ holds for each $i\\in \\{0, \\ldots, n-1\\}$. $c_0$ is always $L$. $0\\leq u_i,v_i<n$ and $u_i\\neq v_i$ hold for each $i\\in \\{1,\\ldots, m\\}$. No two roads connect the same pair of cities.", "outputFormat": "For each test case, output a line of ``yes`` or ``no``, indicating whether there exists an endless earning path.", "hint": "In the first sample test case, the endless earning path is $0\\rightarrow 1\\rightarrow 2\\rightarrow 3\\rightarrow 1\\rightarrow 2\\rightarrow 3\\rightarrow \\dots$. In the illustration, cities with $\\text{Low}$ price are filled with stripe.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2ohq2wfi.png)\n\nIn the second sample test case, Mr. Lawrence can only make one move from city $0$ and after that all cities will have $\\text{High}$ price. Thus, no further moves can be made.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fcv1tw87.png)", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Traveling Merchant", "background": null, "description": "Mr. Lawrence is a traveling merchant who travels between cities and resells products. Basically, to earn from it, he needs to buy products at a very low price and sell them at a higher price. Your task is to tell him whether there exists an endless traveling path that can earn money all the time.\n\nTo make things simple, suppose there are $n$ cities named from $0$ to $n-1$ and $m$ undirected roads each of which connecting two cities. Mr. Lawrence can travel between cities along the roads. Initially he is located at city $0$ and each of the city $i$ has a starting price $c_i$, either $\\text{Low}$ or $\\text{High}$. Due to the law of markets, the price status at city $i$ will change (i.e. $\\text{High}$ price will become $\\text{Low}$ price, or vice versa) after he departs for a neighboring city $j$ from $i$. (City $j$ is a neighboring city of city $i$ when one of the $m$ roads connects city $i$ and city $j$.) For some reasons (e.g. product freshness, traveling fee, tax), he $\\textbf{must}$:\n\n- Start at city $0$ and buy products at city $0$. It is guaranteed that $c_0$ is $\\text{Low}$.\n- When he arrives some city, he either sells products or buys products. It is not allowed for him to do nothing before he leaves the city.\n- After buying products at some city $i$, he must travel to some neighboring city $j$ whose price $c_j$ is $\\text{High}$ and sell the products at city $j$.\n- After selling products at some city $i$, he must travel to some neighboring city $j$ whose price $c_j$ is $\\text{Low}$ and buy the products at city $j$.\n\nAs a result, the path will look like an alternation between ``buy at low price`` and ``sell at high price``.\n\nAn endless earning path is defined as a path consisting of an endless sequence of cities $p_0, p_1,\\dots$ where city $p_i$ and city $p_{i+1}$ has a road, $p_0=0$, and the price alternates, in other words $c_{p_{2k}}=\\text{Low}$ (indicates a buy-in) and $c_{p_{2k+1}}=\\text{High}$ (indicates a sell-out) for $k\\geq0$. Please note here $c_{p_i}$ is the price when $\\textbf{arriving}$ city $p_i$ and this value may be different when he arrives the second time.\n\nYour task is to determine whether there exists any such path.", "inputFormat": "There are several test cases. The first line contains a positive integer $T$ indicating the number of test cases. Each test case begins with two positive integers $n$ and $m$ indicating the number of cities and the number of roads. \n\nThe next line is a string $c$ of length $n$ containing `H` or `L`. The $i$-th ($0\\le i<n$) charactor of $c$ is $H$ if the starting price $c_i$ at city $i$ is $\\text{High}$. The $i$-th ($0\\le i<n$) charactor of $c$ is $L$ if the starting price $c_i$ at city $i$ is $\\text{Low}$. \n\nThe $i$-th line ($1\\le i\\le m$) of the following $m$ lines contains two different cities $u_i$ and $v_i$, indicating a road between $u_i$ and $v_i$.\n\nThe sum of the values of $n$ over all test cases is no more than $200,000$. The sum of the values of $m$ over all test cases is no more than $200,000$. For each test case, $c_i\\in\\{\\text{H},\\text{L}\\}$ holds for each $i\\in \\{0, \\ldots, n-1\\}$. $c_0$ is always $L$. $0\\leq u_i,v_i<n$ and $u_i\\neq v_i$ hold for each $i\\in \\{1,\\ldots, m\\}$. No two roads connect the same pair of cities.", "outputFormat": "For each test case, output a line of ``yes`` or ``no``, indicating whether there exists an endless earning path.", "hint": "In the first sample test case, the endless earning path is $0\\rightarrow 1\\rightarrow 2\\rightarrow 3\\rightarrow 1\\rightarrow 2\\rightarrow 3\\rightarrow \\dots$. In the illustration, cities with $\\text{Low}$ price are filled with stripe.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2ohq2wfi.png)\n\nIn the second sample test case, Mr. Lawrence can only make one move from city $0$ and after that all cities will have $\\text{High}$ price. Thus, no further moves can be made.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fcv1tw87.png)", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Traveling Merchant", "background": null, "description": "劳伦斯先生是一位在不同城市转售商品的旅行商人。基本地，为了赚钱，他需要以低价买进商品，再以高价卖出。现在请你为他规划一条可以一直盈利的旅行路线。\n\n简单地说，假设有 $n$ 座城市，标号为 $0$ 到 $n-1$ ，以及 $m$ 条连接特定两座城市的路，劳伦斯先生可以通过这些路到访每座城市。最初劳伦斯先生位于第 $0$ 座城市，并且对于城市 $i$ 都有一个起始价格 $c_i$ 。根据市场规律，当他从城市 $i$ 来到相邻的城市 $j$ 时（当且仅当城市 $i$ 与城市 $j$ 之间有路径相连时，才称 $i$ 与 $j$ 为相邻城市），城市 $i$ 的价格状况会发生变化（高价会变成低价，反之亦然）。而因为一些原因（比如商品的新鲜程度，旅行费用，税务等），他**必须**：\n\n- 从城市 $0$ 出发并在城市 $0$ 购买一些商品。保证城市 $0$ 的起始价格很**低**。\n- 每当他到达一座城市后，他**必须**售卖**或**购买一些商品。\n- 若他在城市 $i$ 购买了商品，他就必须去一座与 $i$ 相邻且价格 $c_j$ **高于** $c_i$ 的城市 $j$ ，并在那里卖掉手中来自城市 $i$ 的商品。\n- 若他在城市 $i$ 售卖了商品，他就必须去一座与 $i$ 相邻且价格 $c_j$ **低于** $c_i$ 的城市 $j$，并在那里购买一些商品。\n\n\n因此，最终路径会始终重复 ``低价购入`` 和 ``高价卖出`` 。\n\n一条无尽的盈利路线由无尽的城市序列 $p_0,p_1 \\dots$ 组成。其中，城市 $p_i$ 与城市 $p_{i+1}$ 之间有路径相连，$p_0 = 0$，且价格高低是交替循环的，也就是说当 $k \\ge 0$ 时，城市 $p_{2k}$ 的价格 $c_{p_{2k}} = \\text{Low}$ (要在这个城市购买商品) 而相邻城市 $p_{2k+1}$ 的价格 $c_{p_{2k+1}} = \\text{High}$ (要在这个城市卖出商品)。\n\n**注意**：$c_{p_i}$ 是 **到达** 城市 $p_i$ 时的价格，而当他第二次到达城市 $p_i$ 时，这个价格可能会因为市场规律而变化。\n\n你需要写一个程序，判断是否有这样一条永远盈利的路径存在。", "inputFormat": "输入有多组数据。所有数据的第一行是一个整型 $T$ 表示数据组数。每组数据的第一行是两个整型 $n$ 和 $m$，表示城市的数量和道路的数量。\n\n每组数据的第二行是一个长度为 $n$ ，由 $H$ 或 $L$ 组成的字符串 $c$ 。字符串 $c$ 的第 $i$ 个字符若为 $H$，则表示城市 $i$ 的起始价格 $c_i$ **高**，反之若为 $L$ 则表示城市 $i$ 的起始价格 $c_i$ **低**。\n\n接下来 $m$ 行，每行输入一组 $u_i$ 和 $v_i$ ，表示一条连接城市 $u_i$ 和城市 $v_i$ 的双向路径。\n\n所有数据中 $n$ 的总和不超过 $200,000$ ，$m$ 的总和也不超过 $200,000$ 。对于每组数据，$c_i\\in\\{\\text{H}, \\text{L}\\}$ 对应每个 $i\\in\\{0, \\dots, n-1\\}$ ，保证 $c_0$ 总为 $L$ 。保证对于每个 $i\\in\\{1,\\dots,m\\}$ ，都有 $0 \\leq u_i,v_i < n$ 且 $u_i \\neq v_i$ 。保证每两座城市之间只有一条路径相连。", "outputFormat": "对于每组数据，输出一行 ``yes`` 或者 ``no`` ，表示是否存在一条无尽的盈利路径。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P9830", "type": "P", "difficulty": 5, "samples": [["2\n2 2\n2 3", "3.236067977499790\n3.605551275463989"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "贪心", "2020", "上海", "Special Judge", "O2优化", "ICPC"], "title": "[ICPC 2020 Shanghai R] Traveling in the Grid World", "background": "", "description": "Consider a grid pattern with $n$ rows and $m$ columns. There are $(n+1)\\times(m+1)$ grid points in total which is the intersections of $n+1$ horizontal lines and $m+1$ vertical lines. We number the horizontal lines from $0$ to $n$ from top to bottom. We number the vertical lines from $0$ to $m$ from left to right. The intersection of horizontal line $i$ and vertical line $j$ is named $(i, j)$ ($0\\le i\\le n, 0\\le j\\le m$).\n\nThere are some constraints when you travel in the grid world. When you are located at point $(x,y)$, you can choose a destination $(x',y')$ and walk to it along the line segment between $(x, y)$ and $(x', y')$. We call this operation a $\\textit{walk}$. A walk is forbidden if there exists another grid point different from $(x, y)$ and $(x', y')$ lying on the line segment between them. You can walk as many times as you want but the directions of two consecutive walks cannot be the same. (Specifically, if you walk from $(x_0, y_0)$ to $(x_1, y_1)$ and then walk from $(x_1, y_1)$ to $(x_2, y_2)$, you must make sure that $(x_0-x_1)(y_1-y_2)\\neq (x_1-x_2)(y_0-y_1)$.) The length of a walk from $(x, y)$ to $(x', y')$ is defined as the Euclidean distance between the two endpoints, $\\sqrt{(x-x')^2+(y'-y)^2}$.\n\nStarting from $(0,0)$, you are planning to arrive at $(n,m)$ by several walks. Because of the annoying rules, you may need some turning points to achieve your goal. Please find the minimum total length of your walks.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n,m$ ($1\\le n,m \\le 10^6$) indicating the size of the grid graph.\n\nIt is guaranteed that the sum of the values of $\\max(n,m)$ over all test cases does not exceed $10^6$.", "outputFormat": "For each test case, output the minimum total length of walks. Your answer will be considered correct if its absolute or relative error does not exceed $10 ^{-9}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Traveling in the Grid World", "background": "", "description": "Consider a grid pattern with $n$ rows and $m$ columns. There are $(n+1)\\times(m+1)$ grid points in total which is the intersections of $n+1$ horizontal lines and $m+1$ vertical lines. We number the horizontal lines from $0$ to $n$ from top to bottom. We number the vertical lines from $0$ to $m$ from left to right. The intersection of horizontal line $i$ and vertical line $j$ is named $(i, j)$ ($0\\le i\\le n, 0\\le j\\le m$).\n\nThere are some constraints when you travel in the grid world. When you are located at point $(x,y)$, you can choose a destination $(x',y')$ and walk to it along the line segment between $(x, y)$ and $(x', y')$. We call this operation a $\\textit{walk}$. A walk is forbidden if there exists another grid point different from $(x, y)$ and $(x', y')$ lying on the line segment between them. You can walk as many times as you want but the directions of two consecutive walks cannot be the same. (Specifically, if you walk from $(x_0, y_0)$ to $(x_1, y_1)$ and then walk from $(x_1, y_1)$ to $(x_2, y_2)$, you must make sure that $(x_0-x_1)(y_1-y_2)\\neq (x_1-x_2)(y_0-y_1)$.) The length of a walk from $(x, y)$ to $(x', y')$ is defined as the Euclidean distance between the two endpoints, $\\sqrt{(x-x')^2+(y'-y)^2}$.\n\nStarting from $(0,0)$, you are planning to arrive at $(n,m)$ by several walks. Because of the annoying rules, you may need some turning points to achieve your goal. Please find the minimum total length of your walks.", "inputFormat": "There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line contains two integers $n,m$ ($1\\le n,m \\le 10^6$) indicating the size of the grid graph.\n\nIt is guaranteed that the sum of the values of $\\max(n,m)$ over all test cases does not exceed $10^6$.", "outputFormat": "For each test case, output the minimum total length of walks. Your answer will be considered correct if its absolute or relative error does not exceed $10 ^{-9}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Traveling in the Grid World", "background": "", "description": "考虑一个由 $n$ 行和 $m$ 列组成的网格图案。总共有 $(n+1)\\times(m+1)$ 个网格点，即 $n+1$ 条水平线和 $m+1$ 条垂直线的交点。我们将水平线从上到下编号为 $0$ 到 $n$。我们将垂直线从左到右编号为 $0$ 到 $m$。水平线 $i$ 和垂直线 $j$ 的交点命名为 $(i, j)$ ($0\\le i\\le n, 0\\le j\\le m$)。\n\n在网格世界中旅行时有一些限制。当你位于点 $(x,y)$ 时，你可以选择一个目的地 $(x',y')$ 并沿着 $(x, y)$ 和 $(x', y')$ 之间的线段走过去。我们称这种操作为一次“行走”。如果在它们之间的线段上存在另一个不同于 $(x, y)$ 和 $(x', y')$ 的网格点，则该行走是被禁止的。你可以走任意多次，但两次连续行走的方向不能相同。（具体来说，如果你从 $(x_0, y_0)$ 走到 $(x_1, y_1)$，然后从 $(x_1, y_1)$ 走到 $(x_2, y_2)$，你必须确保 $(x_0-x_1)(y_1-y_2)\neq (x_1-x_2)(y_0-y_1)$。）从 $(x, y)$ 到 $(x', y')$ 的行走长度定义为两个端点之间的欧几里得距离，$\\sqrt{(x-x')^2+(y'-y)^2}$。\n\n从 $(0,0)$ 出发，你计划通过几次行走到达 $(n,m)$。由于这些烦人的规则，你可能需要一些转折点来实现你的目标。请找出你的行走的最小总长度。", "inputFormat": "有多个测试用例。输入的第一行包含一个整数 $T$，表示测试用例的数量。对于每个测试用例：\n\n第一行包含两个整数 $n,m$ ($1\\le n,m \\le 10^6$)，表示网格图的大小。\n\n保证所有测试用例中 $\\max(n,m)$ 的总和不超过 $10^6$。", "outputFormat": "对于每个测试用例，输出最小的行走总长度。你的答案将被认为是正确的，如果其绝对或相对误差不超过 $10^{-9}$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9831", "type": "P", "difficulty": 3, "samples": [["2\n3 0\ndata/train\ndata/test\nmodel\n3 1\ndata/train\ndata/test\nmodel\ndata/sample", "2\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "上海", "O2优化", "ICPC"], "title": "[ICPC 2020 Shanghai R] Gitignore", "background": "", "description": "Your git project (you don't need to be familiar with git to solve this problem) has some files that should be ignored from synchronizing. You need to calculate the minimum number of lines needed for gitignore.\n\nFormally, your project is a folder. A folder can have files and sub folders. There are no empty folders (i.e. folders without any files or sub folders inside). Initially, the git software will synchronize all the files in your project. However, you can specify some files and folders in the settings (which is called gitignore) to exclude them from synchronizing. For each line in gitignore, you can specify either a file or all the files in a folder. You can $\\textbf{not}$  ignore the whole project folder (i.e. an empty line in gitignore).\n\nYou are given paths for all the files in the project and whether they should be ignored or shouldn't. Your task is to calculate the minimum number of lines for gitignore.", "inputFormat": "The input contains several test cases. The first line contains a single positive integer $T$ which is the number of test cases. For each test case, you are first given two non-negative numbers $n$ and $m$. And then $n$ non-empty lines of file paths that should be $\\textbf{ignored}$, and $m$ non-empty lines of file paths that should $\\textbf{not}$ be ignored.\n\nThe paths are strings containing lower-cased English alphabets and slashes (`/`) only. Slashes are used to separate folders, sub folders and file name. For exapmle, ``a/b/c/d`` indicates folder ``a`` in the project folder, folder ``b`` in folder ``a``, folder ``c`` in ``b`` and file ``d`` in folder ``c``. All the paths are valid, specifically:\n\n- The path is non-empty and it always indicates a file (i.e. the path does not end with a slash).\n- The path does not start with a slash.\n- Folder names and file names are non-empty (i.e. there are no consecutive slashes).\n- File paths are always unique (i.e. all the paths in a test case are different).\n- In a folder, no sub folders and files share the same names. For example, there won't be two files ``a/b/a`` and ``a/b/a/d`` in one test case. However, files ``a/b/a`` and ``a/b/b`` are allowed.\n\n$1\\leq n+m\\leq 100$ holds and in the whole input there are no more than $1,000$ characters in file paths (i.e. the sum of lengths of file path strings in the whole input file is no more than $1,000$).", "outputFormat": "$T$ lines of non-negative integers, the minimum number of gitignore lines for each test case.", "hint": "In the first sample test case, the corresponding gitignore file contains $2$ lines: a folder line ``data/`` and a file name ``model``.\n\nIn the second sample test case, the corresponding gitignore file contains $3$ file lines: ``data/train``, ``data/test`` and ``model``.", "locale": "en", "translations": {"en": {"title": "[ICPC 2020 Shanghai R] Gitignore", "background": "", "description": "Your git project (you don't need to be familiar with git to solve this problem) has some files that should be ignored from synchronizing. You need to calculate the minimum number of lines needed for gitignore.\n\nFormally, your project is a folder. A folder can have files and sub folders. There are no empty folders (i.e. folders without any files or sub folders inside). Initially, the git software will synchronize all the files in your project. However, you can specify some files and folders in the settings (which is called gitignore) to exclude them from synchronizing. For each line in gitignore, you can specify either a file or all the files in a folder. You can $\\textbf{not}$  ignore the whole project folder (i.e. an empty line in gitignore).\n\nYou are given paths for all the files in the project and whether they should be ignored or shouldn't. Your task is to calculate the minimum number of lines for gitignore.", "inputFormat": "The input contains several test cases. The first line contains a single positive integer $T$ which is the number of test cases. For each test case, you are first given two non-negative numbers $n$ and $m$. And then $n$ non-empty lines of file paths that should be $\\textbf{ignored}$, and $m$ non-empty lines of file paths that should $\\textbf{not}$ be ignored.\n\nThe paths are strings containing lower-cased English alphabets and slashes (`/`) only. Slashes are used to separate folders, sub folders and file name. For exapmle, ``a/b/c/d`` indicates folder ``a`` in the project folder, folder ``b`` in folder ``a``, folder ``c`` in ``b`` and file ``d`` in folder ``c``. All the paths are valid, specifically:\n\n- The path is non-empty and it always indicates a file (i.e. the path does not end with a slash).\n- The path does not start with a slash.\n- Folder names and file names are non-empty (i.e. there are no consecutive slashes).\n- File paths are always unique (i.e. all the paths in a test case are different).\n- In a folder, no sub folders and files share the same names. For example, there won't be two files ``a/b/a`` and ``a/b/a/d`` in one test case. However, files ``a/b/a`` and ``a/b/b`` are allowed.\n\n$1\\leq n+m\\leq 100$ holds and in the whole input there are no more than $1,000$ characters in file paths (i.e. the sum of lengths of file path strings in the whole input file is no more than $1,000$).", "outputFormat": "$T$ lines of non-negative integers, the minimum number of gitignore lines for each test case.", "hint": "In the first sample test case, the corresponding gitignore file contains $2$ lines: a folder line ``data/`` and a file name ``model``.\n\nIn the second sample test case, the corresponding gitignore file contains $3$ file lines: ``data/train``, ``data/test`` and ``model``.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2020 Shanghai R] Gitignore", "background": "", "description": "你的 git 项目（你不需要熟悉 git 来解决这个问题）中有一些文件应该被忽略同步。你需要计算 .gitignore 文件中所需的最小行数。\n\n形式上，你的项目是一个文件夹。一个文件夹可以包含文件和子文件夹。没有空文件夹（即没有任何文件或子文件夹的文件夹）。最初，git 软件会同步项目中的所有文件。然而，你可以在设置中指定一些文件和文件夹（即 .gitignore）来排除它们的同步。在 .gitignore 中的每一行，你可以指定一个文件或一个文件夹中的所有文件。你不能忽略整个项目文件夹（即 .gitignore 中的空行）。\n\n你将得到项目中所有文件的路径，以及它们是否应该被忽略。你的任务是计算 .gitignore 的最小行数。", "inputFormat": "输入包含多个测试用例。第一行包含一个正整数 $T$，表示测试用例的数量。对于每个测试用例，首先给出两个非负整数 $n$ 和 $m$。接下来是 $n$ 行非空的文件路径，这些文件路径应该被忽略，接着是 $m$ 行非空的文件路径，这些文件路径不应该被忽略。\n\n路径是仅包含小写英文字母和斜杠（`/`）的字符串。斜杠用于分隔文件夹、子文件夹和文件名。例如，`a/b/c/d` 表示项目文件夹中的文件夹 `a`，文件夹 `a` 中的文件夹 `b`，`b` 中的文件夹 `c`，以及 `c` 中的文件 `d`。所有路径都是有效的，具体来说：\n\n- 路径非空且总是表示一个文件（即路径不以斜杠结尾）。\n- 路径不以斜杠开头。\n- 文件夹名和文件名非空（即没有连续的斜杠）。\n- 文件路径总是唯一的（即一个测试用例中的所有路径都是不同的）。\n- 在一个文件夹中，没有子文件夹和文件共享相同的名称。例如，不会在一个测试用例中出现两个文件 `a/b/a` 和 `a/b/a/d`。然而，文件 `a/b/a` 和 `a/b/b` 是允许的。\n\n$1 \\leq n+m \\leq 100$ 且整个输入中文件路径的字符总数不超过 $1,000$（即整个输入文件中文件路径字符串的长度之和不超过 $1,000$）。", "outputFormat": "$T$ 行非负整数，表示每个测试用例的 .gitignore 的最小行数。", "hint": "在第一个示例测试用例中，.gitignore 文件包含 2 行：一个文件夹行 `data/` 和一个文件名 `model`。\n\n在第二个示例测试用例中，.gitignore 文件包含 3 行文件：`data/train`、`data/test` 和 `model`。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P9832", "type": "P", "difficulty": 4, "samples": [["8 2 9\n1 2\n1 6\n1 7\n1 8\n1 9\n2 2\n2 3\n2 4", "10"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2005", "USACO"], "title": "[USACO05OPEN] Lazy Cows G", "background": "", "description": "地母是这个世界上大地的主宰，在她眼中整个大地呈现两行 $n$ 列的一个状态。在这个大地上如珍珠般散落着各种宝藏，每个宝藏占据一个格子。不过这个消息让天公知道了，他想抢走这些宝藏。地母决定用「无极」牌帆布盖住这些宝藏。\n\n「无极」牌帆布是矩形状的，而且地母现在手头比较紧，她决定用 $k$ 块帆布盖住所有的宝藏。现在希望你求出这 $k$ 块帆布的面积之和的最小值。", "inputFormat": "第一行给出三个数，分别代表宝藏的个数 $m$，帆布的张数 $k$，以及整个大地所呈现的列数 $n$，下面 $m$ 行给出两个数，代表每个宝藏所在的位置。", "outputFormat": "输出一行一个数，帆布面积之和的最小值。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 1.5 \\times 10^7$，$1 \\leq k \\leq m \\leq 10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO05OPEN] Lazy Cows G", "background": "", "description": "地母是这个世界上大地的主宰，在她眼中整个大地呈现两行 $n$ 列的一个状态。在这个大地上如珍珠般散落着各种宝藏，每个宝藏占据一个格子。不过这个消息让天公知道了，他想抢走这些宝藏。地母决定用「无极」牌帆布盖住这些宝藏。\n\n「无极」牌帆布是矩形状的，而且地母现在手头比较紧，她决定用 $k$ 块帆布盖住所有的宝藏。现在希望你求出这 $k$ 块帆布的面积之和的最小值。", "inputFormat": "第一行给出三个数，分别代表宝藏的个数 $m$，帆布的张数 $k$，以及整个大地所呈现的列数 $n$，下面 $m$ 行给出两个数，代表每个宝藏所在的位置。", "outputFormat": "输出一行一个数，帆布面积之和的最小值。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 1.5 \\times 10^7$，$1 \\leq k \\leq m \\leq 10^3$。", "locale": "zh-CN"}}}
{"pid": "P9833", "type": "P", "difficulty": 4, "samples": [["4\n4 4\n5 2\n11 5\n15 10\n25 10\n", "2"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["贪心", "2005", "USACO", "优先队列"], "title": "[USACO05OPEN] Expedition G", "background": null, "description": "一群奶牛抢了一辆卡车决定前往树林里探险，但是由于它们的驾驶技术太糟，油箱在路上给弄破了，所以它们每前进一个单位的路程就会漏掉一个单位的油。\n\n为了修好油箱，奶牛们必须前往最近的城市（不会超过 $10^6$ 单位路程）。  \n在当前位置和城市之间有 $n$ 个加油站．奶牛可以在加油站加 $1$ 到 $100$ 单位的油。  \n\n对于人来说，树林是个危险的地方；对奶牛来说，更是这样。  所以，奶牛要尽可能的少停站加油，幸运的是，这辆卡车的油箱非常大，你可以认为它的容量是无穷大的。  \n卡车在离城 $l$ 个单位时还有 $p$ 个单位的油，你要算出奶牛们至少要停几站才能到城市，或者奶牛们根本到不了城市。", "inputFormat": "第一行，一个整数 $n$。\n\n第二到 $n+1$ 行，每行有两个用空格隔开的整数，描述一个加油站。第一个数表示这个加油站离城市的距离，第二个数表示在这个加油站最多可以加多少油。\n\n第 $n+2$ 行：两个用空格分开的整数 $l$ 和 $p$。", "outputFormat": "一个表示卡车到城市最少要停的次数，如果无法到达输出 `-1`。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 10^4$，$1\\leq p\\leq 1000000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO05OPEN] Expedition G", "background": null, "description": "一群奶牛抢了一辆卡车决定前往树林里探险，但是由于它们的驾驶技术太糟，油箱在路上给弄破了，所以它们每前进一个单位的路程就会漏掉一个单位的油。\n\n为了修好油箱，奶牛们必须前往最近的城市（不会超过 $10^6$ 单位路程）。  \n在当前位置和城市之间有 $n$ 个加油站．奶牛可以在加油站加 $1$ 到 $100$ 单位的油。  \n\n对于人来说，树林是个危险的地方；对奶牛来说，更是这样。  所以，奶牛要尽可能的少停站加油，幸运的是，这辆卡车的油箱非常大，你可以认为它的容量是无穷大的。  \n卡车在离城 $l$ 个单位时还有 $p$ 个单位的油，你要算出奶牛们至少要停几站才能到城市，或者奶牛们根本到不了城市。", "inputFormat": "第一行，一个整数 $n$。\n\n第二到 $n+1$ 行，每行有两个用空格隔开的整数，描述一个加油站。第一个数表示这个加油站离城市的距离，第二个数表示在这个加油站最多可以加多少油。\n\n第 $n+2$ 行：两个用空格分开的整数 $l$ 和 $p$。", "outputFormat": "一个表示卡车到城市最少要停的次数，如果无法到达输出 `-1`。", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 10^4$，$1\\leq p\\leq 1000000$。", "locale": "zh-CN"}}}
{"pid": "P9834", "type": "P", "difficulty": 4, "samples": [["3 3\n0\n120\n240\n1 2\n2 3\n1 3\n", "3"]], "limits": {"time": [350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350, 350], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2005", "USACO"], "title": "[USACO05OPEN] Around the world G", "background": "", "description": "这些年，农夫约翰在国际上交了一大批开农场的朋友。由于他有一段时间没有去见过英国的农夫泰德和荷兰的农夫波尔，所以他想去拜访他们。\n\n他知道每个朋友的农场的经度（是一个从 $0$ 到 $359$ 的整数，我们把地球看成一个圆，经度在此圆上顺时针方向递增）。  \n\n农夫约翰打算乘飞机去拜访他的 $n$ 个朋友（用 $1$ 到 $n$ 来表示）。他知道在这些农场之间有 $m$ 条双向的航线。飞机是沿着地面上最短的路径飞行的（就是圆上的最短弧长）。两个农场之间的航线一定是最短的。\n\n保证如果有两个农场在直径两端，那么它们之间一定不会被某条航线直接连接。\n\n所以任何一次航行都可以被描述成顺时针或是逆时针的．比如说，经度 $30$ 到经度 $35$ 是顺时针的，经度 $350$ 到经度 $10$ 也是顺时针的，而经度 $350$ 到经度 $200$ 是逆时针的。\n\n农夫约翰为了耍酷，决定要经过几个朋友的农场做到环球旅行，他想知道这是否可能，如果可能最少要乘几次飞机。\n\n他想在他最好的朋友（即输入中的第一个）的农场上开始和结束这次旅行。为了保证这是一次环球航行，结束旅行，顺时针经过的路程不能等于逆时针经过的路程。", "inputFormat": "第一行两个用空格隔开的整数 $n$ 和 $m$。\n\n第二到 $n+1$ 行：第 $i+1$ 行有一个整数，表示第 $i$ 个农场的经度。第二行是他的最好的朋友的地址。\n\n第 $n+2$ 过程 $n+m+1$ 行：第 $i+n+1$ 行有两个整数，表示这两个农场之间有航线。", "outputFormat": "一个整数，表示农夫约翰至少要乘几次飞机才能完成环球旅行。每次农夫约翰从一个农场前往另一个农场算作乘一次飞机。如果不可能做到环球旅行则输出 `-1`。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^3$，$1 \\leq m \\leq 2.5 \\times 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO05OPEN] Around the world G", "background": "", "description": "这些年，农夫约翰在国际上交了一大批开农场的朋友。由于他有一段时间没有去见过英国的农夫泰德和荷兰的农夫波尔，所以他想去拜访他们。\n\n他知道每个朋友的农场的经度（是一个从 $0$ 到 $359$ 的整数，我们把地球看成一个圆，经度在此圆上顺时针方向递增）。  \n\n农夫约翰打算乘飞机去拜访他的 $n$ 个朋友（用 $1$ 到 $n$ 来表示）。他知道在这些农场之间有 $m$ 条双向的航线。飞机是沿着地面上最短的路径飞行的（就是圆上的最短弧长）。两个农场之间的航线一定是最短的。\n\n保证如果有两个农场在直径两端，那么它们之间一定不会被某条航线直接连接。\n\n所以任何一次航行都可以被描述成顺时针或是逆时针的．比如说，经度 $30$ 到经度 $35$ 是顺时针的，经度 $350$ 到经度 $10$ 也是顺时针的，而经度 $350$ 到经度 $200$ 是逆时针的。\n\n农夫约翰为了耍酷，决定要经过几个朋友的农场做到环球旅行，他想知道这是否可能，如果可能最少要乘几次飞机。\n\n他想在他最好的朋友（即输入中的第一个）的农场上开始和结束这次旅行。为了保证这是一次环球航行，结束旅行，顺时针经过的路程不能等于逆时针经过的路程。", "inputFormat": "第一行两个用空格隔开的整数 $n$ 和 $m$。\n\n第二到 $n+1$ 行：第 $i+1$ 行有一个整数，表示第 $i$ 个农场的经度。第二行是他的最好的朋友的地址。\n\n第 $n+2$ 过程 $n+m+1$ 行：第 $i+n+1$ 行有两个整数，表示这两个农场之间有航线。", "outputFormat": "一个整数，表示农夫约翰至少要乘几次飞机才能完成环球旅行。每次农夫约翰从一个农场前往另一个农场算作乘一次飞机。如果不可能做到环球旅行则输出 `-1`。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 5 \\times 10^3$，$1 \\leq m \\leq 2.5 \\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P9835", "type": "P", "difficulty": 4, "samples": [["12 1\n1\n2\n3\n3\n3\n2\n1\n3\n2\n2\n1\n2\n", "5"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2005", "USACO"], "title": "[USACO05OPEN] Landscaping G", "background": null, "description": "农夫约翰正在做一次艰难的转型，从养山羊改成养奶牛，他的农场，由于是为养山羊而设计的所以有太多的山，为了养牛就必须将它整平。但是，将山整平是件很花钱的工作，所以他要移走尽可能少的土。\n\n由于农场很细长，所以可以用一个 $n$ 和 $n$ 个整数（范围 $[1,10^6]$）组成的二维的数组来表示，如：\n\n```\n1 2 3 3 3 2 1 3 2 2 1 2\n```\n\n上述农场的侧面图是这样的：\n\n```\n    * * *     *\n  * * * * *   * * *   *\n* * * * * * * * * * * *\n1 2 3 3 3 2 1 3 2 2 1 2\n```\n\n一个或是一些连续等高的地面，如果它左边与右边的海拔都比它低的话，就被称为山顶，上面的例子就有三个山顶。 确定如果要使地图上仅有 $k$ 个山顶，至少要移走多少体积的土（每块地面减少一单位海拔需移走一单位的土）。注意，地面的海拔只能被降低不能被升高。 对于例子，如果要减少到只有 $1$ 个山顶，这需要移走 $2+1+1+1=5$ 个单位的土（`-` 表示移走的土）：\n\n```\n    * * *     -\n  * * * * *   - - -   -\n* * * * * * * * * * * *\n1 2 3 3 3 2 1 3 2 2 1 2\n```", "inputFormat": "第 $1$ 行输入整数 $n$ 和 $k$。\n\n之后 $n$ 行，每行输入一个整数，表示这块地的海拔。", "outputFormat": "如果仅能有 $k$ 个山顶至少要移走多少土。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^3$，$1 \\leq k \\leq 25$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO05OPEN] Landscaping G", "background": null, "description": "农夫约翰正在做一次艰难的转型，从养山羊改成养奶牛，他的农场，由于是为养山羊而设计的所以有太多的山，为了养牛就必须将它整平。但是，将山整平是件很花钱的工作，所以他要移走尽可能少的土。\n\n由于农场很细长，所以可以用一个 $n$ 和 $n$ 个整数（范围 $[1,10^6]$）组成的二维的数组来表示，如：\n\n```\n1 2 3 3 3 2 1 3 2 2 1 2\n```\n\n上述农场的侧面图是这样的：\n\n```\n    * * *     *\n  * * * * *   * * *   *\n* * * * * * * * * * * *\n1 2 3 3 3 2 1 3 2 2 1 2\n```\n\n一个或是一些连续等高的地面，如果它左边与右边的海拔都比它低的话，就被称为山顶，上面的例子就有三个山顶。 确定如果要使地图上仅有 $k$ 个山顶，至少要移走多少体积的土（每块地面减少一单位海拔需移走一单位的土）。注意，地面的海拔只能被降低不能被升高。 对于例子，如果要减少到只有 $1$ 个山顶，这需要移走 $2+1+1+1=5$ 个单位的土（`-` 表示移走的土）：\n\n```\n    * * *     -\n  * * * * *   - - -   -\n* * * * * * * * * * * *\n1 2 3 3 3 2 1 3 2 2 1 2\n```", "inputFormat": "第 $1$ 行输入整数 $n$ 和 $k$。\n\n之后 $n$ 行，每行输入一个整数，表示这块地的海拔。", "outputFormat": "如果仅能有 $k$ 个山顶至少要移走多少土。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^3$，$1 \\leq k \\leq 25$。", "locale": "zh-CN"}}}
{"pid": "P9836", "type": "P", "difficulty": 4, "samples": [["3 60\n8 243 250", "2304"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "贪心", "洛谷原创", "O2优化", "洛谷月赛"], "title": "种树", "background": "小 Rf 不是很喜欢种花，但是他喜欢种树。", "description": "路边有 $n$ 棵树，每棵树的 **高度** 均为正整数，记作 $p_1, p_2 \\dots p_n$。\n\n定义一棵树的 **宽度** 为它高度的正因数个数，这些树能覆盖的距离为它们宽度的乘积，你想请你的朋友们来乘凉，但你发现这些树能覆盖的距离不够多。\n\n于是你买了总量为 $w$ 单位的神奇化肥。你可以施若干次肥，每次你可以使用 $k$ 单位化肥（**要求 $k$ 必须为当前化肥量的正因数**），让任意一棵树的高度乘上 $k$，同时你剩余的化肥量也会除以 $k$。每次施肥的树可任意选择，且每次施肥选择的树不需相同。\n\n你需要最大化这些树所能覆盖的距离，并输出这个最大距离。答案对 $998244353$ 取模。", "inputFormat": "从标准输入中读入数据。\n\n第一行，两个正整数 $n$ 与 $w$。\n\n第二行 $n$ 个正整数 $p_1, p_2 \\dots p_n$。", "outputFormat": "输出到标准输出。\n\n仅一行一个整数，代表答案对 $998244353$ 取模后的结果。", "hint": "**【样例 1 解释】**\n\n+ 第一次施肥，向第一棵树施 $15$ 单位的肥，使其高度变成 $120$，剩余 $4$ 单位的化肥。\n+ 第二次施肥，向第二棵树施 $4$ 单位的肥，使其高度变成 $972$，剩余 $1$ 单位的化肥。\n+ 这时候，三棵树的宽度分别为 $16, 18, 8$，所能覆盖的距离为 $2304$，为最优解。\n\n---\n\n**【样例 2】**\n\n见附件下的 $\\texttt{plant/plant2.in}$ 与 $\\texttt{plant/plant2.ans}$。\n\n---\n\n**【样例 3】**\n\n见附件下的 $\\texttt{plant/plant3.in}$ 与 $\\texttt{plant/plant3.ans}$。\n\n---\n\n**【数据范围】**\n\n| 测试点编号 | $n \\leq$ | $p_i$ | $w$ | 单点分值 |\n| :--------: | :------: | :---: | :---: | :------: |\n| $1 \\sim 5$ | $10^4$ | $=1$ | $=1$ | $1$ |\n| $6 \\sim 10$ | $10^4$ | $\\leq 10^4$ | $=1$ | $3$ |\n| $11 \\sim 15$ | $1$ | $\\leq 10^4$ | $\\leq 10^4$ | $3$ |\n| $16 \\sim 20$ | $5$ | $\\leq 10^4$ | $\\leq 10^4$ | $6$ |\n| $21 \\sim 25$ | $10^4$ | $\\leq 10^4$ | $\\leq 10^4$ | $7$ |\n\n对于 $100 \\%$ 的数据，保证 $1 \\leq n \\leq 10^4$，$1 \\leq p_i \\leq 10^4$，$1 \\leq w \\leq 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "种树", "background": "小 Rf 不是很喜欢种花，但是他喜欢种树。", "description": "路边有 $n$ 棵树，每棵树的 **高度** 均为正整数，记作 $p_1, p_2 \\dots p_n$。\n\n定义一棵树的 **宽度** 为它高度的正因数个数，这些树能覆盖的距离为它们宽度的乘积，你想请你的朋友们来乘凉，但你发现这些树能覆盖的距离不够多。\n\n于是你买了总量为 $w$ 单位的神奇化肥。你可以施若干次肥，每次你可以使用 $k$ 单位化肥（**要求 $k$ 必须为当前化肥量的正因数**），让任意一棵树的高度乘上 $k$，同时你剩余的化肥量也会除以 $k$。每次施肥的树可任意选择，且每次施肥选择的树不需相同。\n\n你需要最大化这些树所能覆盖的距离，并输出这个最大距离。答案对 $998244353$ 取模。", "inputFormat": "从标准输入中读入数据。\n\n第一行，两个正整数 $n$ 与 $w$。\n\n第二行 $n$ 个正整数 $p_1, p_2 \\dots p_n$。", "outputFormat": "输出到标准输出。\n\n仅一行一个整数，代表答案对 $998244353$ 取模后的结果。", "hint": "**【样例 1 解释】**\n\n+ 第一次施肥，向第一棵树施 $15$ 单位的肥，使其高度变成 $120$，剩余 $4$ 单位的化肥。\n+ 第二次施肥，向第二棵树施 $4$ 单位的肥，使其高度变成 $972$，剩余 $1$ 单位的化肥。\n+ 这时候，三棵树的宽度分别为 $16, 18, 8$，所能覆盖的距离为 $2304$，为最优解。\n\n---\n\n**【样例 2】**\n\n见附件下的 $\\texttt{plant/plant2.in}$ 与 $\\texttt{plant/plant2.ans}$。\n\n---\n\n**【样例 3】**\n\n见附件下的 $\\texttt{plant/plant3.in}$ 与 $\\texttt{plant/plant3.ans}$。\n\n---\n\n**【数据范围】**\n\n| 测试点编号 | $n \\leq$ | $p_i$ | $w$ | 单点分值 |\n| :--------: | :------: | :---: | :---: | :------: |\n| $1 \\sim 5$ | $10^4$ | $=1$ | $=1$ | $1$ |\n| $6 \\sim 10$ | $10^4$ | $\\leq 10^4$ | $=1$ | $3$ |\n| $11 \\sim 15$ | $1$ | $\\leq 10^4$ | $\\leq 10^4$ | $3$ |\n| $16 \\sim 20$ | $5$ | $\\leq 10^4$ | $\\leq 10^4$ | $6$ |\n| $21 \\sim 25$ | $10^4$ | $\\leq 10^4$ | $\\leq 10^4$ | $7$ |\n\n对于 $100 \\%$ 的数据，保证 $1 \\leq n \\leq 10^4$，$1 \\leq p_i \\leq 10^4$，$1 \\leq w \\leq 10^4$。", "locale": "zh-CN"}}}
{"pid": "P9837", "type": "P", "difficulty": 6, "samples": [["2 1", "1\n2 1"], ["5 2", "1\n2 3\n4 2 5\n3 5 1 4\n5 4 3 1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "洛谷原创", "Special Judge", "O2优化", "图论建模", "构造", "洛谷月赛", "Ad-hoc"], "title": "汪了个汪", "background": "你说得对，但是小 P 在 [[NOIP2022] 喵了个喵](https://www.luogu.com.cn/problem/P8866) 中没有输出操作次数，获得了 $0$ 分的好成绩。", "description": "小 P 喜欢上了一款叫做《汪了个汪》的游戏。这个游戏有一个牌堆和一个金字塔形的棋盘，总共有 $3$ 关。具体地，如图所示，棋盘的边长为 $n$，第 $i$ 行有 $i$ 个格子，共 $\\dfrac{n(n+1)}{2}$ 个格子。\n\n牌堆中有 $1, 2 \\dots n$ 的数字卡片 **各无穷多张**。你需要将这些数字卡片放到对应的棋盘格子中，每个格子恰好放一张数字卡片，要求满足棋盘的每一行的第一个元素 **互不相同**。\n\n小 P 发现，这个游戏的难度会随着关卡编号而增加：\n\n- 在第 $0$ 关中，你不必满足其他条件。\n- 在第 $1$ 关中，你需要保证一行内相邻的两个数互不相同，且所有由任意一行内相邻两个数组成的 **无序二元组** 互不相同。\n- 在第 $2$ 关中，你需要满足第 $1$ 关的限制，并且一行内的 **所有数** 必须互不相同。\n\n例如，下面是 $n=5$ 时可以通过第 $2$ 关的摆放方式：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zdln26tg.png)\n\n现在给定 $n$ 与关卡编号，请你帮小 P 找出一种合适的摆放方式来通过这一关。可以证明在游戏限制下一定存在一种过关方式。", "inputFormat": "从标准输入中读入数据。\n\n仅一行，包含两个整数 $n, t$，其中 $t$ 表示关卡编号。", "outputFormat": "输出到标准输出。\n\n输出 $n$ 行，第 $i$ 行包含 $i$ 个正整数（以空格分隔），表示棋盘第 $i$ 行从左到右所有的数。\n\n如果有多种合法的解，你可以输出任何一种。", "hint": "**【说明与提示】**\n\n本题下发校验器（`checker.cpp`）。将 `checker.cpp` 编译成可执行文件 `checker` 后，在当前目录执行 `checker woof.in woof.out woof.ans` 即可校验你的答案是否符合规范。其中 `woof.in` 可以替换为对应输入文件名称，`woof.out` 可以替换为对应输出文件名称，也即构造结果。`woof.ans` 可以为任意文件。\n\n返回结果说明：\n\n- `The numbers are not in the valid range.`：说明你的输出不满足每个数字都在 $1\\sim n$ 的范围内。\n- `The first column does not satisfice.`：说明你的输出不满足每行开头的数互不相同。\n- `The pairs of numbers are not distinct.`：说明你的输出不满足所有由任意一行内相邻两个数组成的无序二元组互不相同。\n- `The adjacent numbers are not distinct.`：说明当前关卡编号 $\\ge1$ 且你的输出不满足关卡 $1$ 的条件。\n- `The numbers in a row are not distinct.`：说明当前关卡编号 $\\ge2$ 且你的输出不满足关卡 $2$ 的条件。\n- `Well done.`：说明你的构造满足要求。\n\n---\n\n#### 【数据范围】\n\n| 测试点编号 | $n \\leq$ | $t =$ | 特殊性质 |\n| :--------: | :------: | :---: | :------: |\n| $1$ | $6$ | $0$ | 无 |\n| $2$ | $6$ | $2$ | 无 |\n| $3 \\sim 4$ | $4000$ | $2$ | A |\n| $5 \\sim 7$ | $500$ | $1$ | 无 |\n| $8 \\sim 13$ | $500$ | $2$ | 无 |\n| $14 \\sim 16$ | $4000$ | $1$ | 无 |\n| $17 \\sim 20$ | $4000$ | $2$ | 无 |\n\n+ 特殊性质 A：保证 $n + 1$ 或 $n + 2$ 为质数。\n\n对于 $100 \\%$ 的数据，保证 $1 \\leq n \\leq 4000$，$t \\in \\{0, 1, 2\\}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "汪了个汪", "background": "你说得对，但是小 P 在 [[NOIP2022] 喵了个喵](https://www.luogu.com.cn/problem/P8866) 中没有输出操作次数，获得了 $0$ 分的好成绩。", "description": "小 P 喜欢上了一款叫做《汪了个汪》的游戏。这个游戏有一个牌堆和一个金字塔形的棋盘，总共有 $3$ 关。具体地，如图所示，棋盘的边长为 $n$，第 $i$ 行有 $i$ 个格子，共 $\\dfrac{n(n+1)}{2}$ 个格子。\n\n牌堆中有 $1, 2 \\dots n$ 的数字卡片 **各无穷多张**。你需要将这些数字卡片放到对应的棋盘格子中，每个格子恰好放一张数字卡片，要求满足棋盘的每一行的第一个元素 **互不相同**。\n\n小 P 发现，这个游戏的难度会随着关卡编号而增加：\n\n- 在第 $0$ 关中，你不必满足其他条件。\n- 在第 $1$ 关中，你需要保证一行内相邻的两个数互不相同，且所有由任意一行内相邻两个数组成的 **无序二元组** 互不相同。\n- 在第 $2$ 关中，你需要满足第 $1$ 关的限制，并且一行内的 **所有数** 必须互不相同。\n\n例如，下面是 $n=5$ 时可以通过第 $2$ 关的摆放方式：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zdln26tg.png)\n\n现在给定 $n$ 与关卡编号，请你帮小 P 找出一种合适的摆放方式来通过这一关。可以证明在游戏限制下一定存在一种过关方式。", "inputFormat": "从标准输入中读入数据。\n\n仅一行，包含两个整数 $n, t$，其中 $t$ 表示关卡编号。", "outputFormat": "输出到标准输出。\n\n输出 $n$ 行，第 $i$ 行包含 $i$ 个正整数（以空格分隔），表示棋盘第 $i$ 行从左到右所有的数。\n\n如果有多种合法的解，你可以输出任何一种。", "hint": "**【说明与提示】**\n\n本题下发校验器（`checker.cpp`）。将 `checker.cpp` 编译成可执行文件 `checker` 后，在当前目录执行 `checker woof.in woof.out woof.ans` 即可校验你的答案是否符合规范。其中 `woof.in` 可以替换为对应输入文件名称，`woof.out` 可以替换为对应输出文件名称，也即构造结果。`woof.ans` 可以为任意文件。\n\n返回结果说明：\n\n- `The numbers are not in the valid range.`：说明你的输出不满足每个数字都在 $1\\sim n$ 的范围内。\n- `The first column does not satisfice.`：说明你的输出不满足每行开头的数互不相同。\n- `The pairs of numbers are not distinct.`：说明你的输出不满足所有由任意一行内相邻两个数组成的无序二元组互不相同。\n- `The adjacent numbers are not distinct.`：说明当前关卡编号 $\\ge1$ 且你的输出不满足关卡 $1$ 的条件。\n- `The numbers in a row are not distinct.`：说明当前关卡编号 $\\ge2$ 且你的输出不满足关卡 $2$ 的条件。\n- `Well done.`：说明你的构造满足要求。\n\n---\n\n#### 【数据范围】\n\n| 测试点编号 | $n \\leq$ | $t =$ | 特殊性质 |\n| :--------: | :------: | :---: | :------: |\n| $1$ | $6$ | $0$ | 无 |\n| $2$ | $6$ | $2$ | 无 |\n| $3 \\sim 4$ | $4000$ | $2$ | A |\n| $5 \\sim 7$ | $500$ | $1$ | 无 |\n| $8 \\sim 13$ | $500$ | $2$ | 无 |\n| $14 \\sim 16$ | $4000$ | $1$ | 无 |\n| $17 \\sim 20$ | $4000$ | $2$ | 无 |\n\n+ 特殊性质 A：保证 $n + 1$ 或 $n + 2$ 为质数。\n\n对于 $100 \\%$ 的数据，保证 $1 \\leq n \\leq 4000$，$t \\in \\{0, 1, 2\\}$。", "locale": "zh-CN"}}}
{"pid": "P9838", "type": "P", "difficulty": 6, "samples": [["2\n3 2\n3 6", "13\n14\n"], ["5\n4 1\n4 10\n4 16\n4 20\n4 24", "32\n34\n36\n36\n38"], ["10\n1000000000000000000 1000000000000000000\n1145141919810 19260817998244353\n15 131413141314\n36 93930322810121243\n172 354354645654567654\n666 233\n1048576 2147483648\n1000000007 1000000009\n99824 44353\n10 1", "36226088\n846277092\n1096\n12356\n1239174\n70731494\n274614617\n511280969\n625722816\n330"]], "limits": {"time": [2000, 2000, 2000, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "数学", "洛谷原创", "O2优化", "记忆化搜索", "位运算", "洛谷月赛"], "title": "挑战 NPC IV", "background": "要是什么都和 NPC 问题一样简单就好了啊。", "description": "小 A 想为小 B 写一首情诗。他现在想出了 $n$ 个句子，每个句子的优美度分别为 $1, 2 \\dots n$。小 A 需要按照一定的顺序将他们组合起来，拼成一首完整的诗。换句话说，小 A 需要重新排列这 $n$ 个句子，形成一个 $1 \\sim n$ 的排列 $p_1, p_2\\dots p_n$；第 $i$ 行诗句的优美度就是原先第 $p_i$ 个句子的优美度，也就是 $p_i$。\n\n不过，由于小 A 是位 OIer，所以他的文采并不是很稳定。他实际上会严重高估自己诗句的优美程度。若一条诗句在小 A 眼里的优美度为 $x$，那么小 B 认为它的优美度是 **$x$ 在二进制表示下最低位的 $1$ 的位置**。其中，小 B 认为最低位的位置是 $1$，次低位为 $2$，以此类推。也就是说，小 B 眼中的优美度 $f(x)$ 为 $1 + \\log_2 \\operatorname{lowbit}(x)$。\n\n小 A 知道，小 B 拿到诗后，只会选取诗的一段来看，而她感受到的优美度是所有她读到的诗句之和。具体的，若诗有 $n$ 句，则小 B 会在 $[1, n]$ 的所有长度 $> 0$ 的区间中抽取一个 $[l, r]$，感受到 $\\displaystyle\\sum_{l \\leq i \\leq r}f(p_i)$ 的优美度。小 A 为了衡量一首诗的优美度，决定将一首诗的总优美度定义为 **所有情况下小 B 感受到的优美度之和**。\n\n照理来说，总优美度最大的组合方式必然是最好的。遗憾的是，在小 A 的精密计算下，他发现，只有他选择总优美度恰好为 **第 $k$ 小** 的情诗时，他才最有可能和小 B 走到一起。于是，小 A 想要知道，对于 $n!$ 首本质不同的诗，第 $k$ 小可能的总优美度是多少。两首诗本质相同当且仅当原排列 $p_1 \\dots p_n$ 相同。\n\n小 A 发现这是一个 NPC 问题，他只好来向你求助了。由于总优美度过于巨大，你只需要帮他求出答案对 $998244353$ 取模后的结果。\n\n特别的，小 A 写了 $q$ 组诗句，所以你需要分别回答他的 $q$ 个问题。", "inputFormat": "从标准输入中读入数据。\n\n第一行一个正整数 $q$，表示诗句的组数。\n\n对于每组数据，仅一行两个正整数 $n, k$ 描述小 A 的问题。", "outputFormat": "输出到标准输出。\n\n对于每组诗句，输出一行一个整数，表示第 $k$ 小的总优美度对 $998244353$ 取模后的结果。", "hint": "#### 【样例 1 解释】\n\n例如，当 $p = [1, 3, 2]$ 时，小 B 眼中每句诗的优美度分别为 $[1, 1, 2]$。那么：\n\n- 当 $l = 1$，$r = 1$ 时，优美度之和为 $1$。\n- 当 $l = 2$，$r = 2$ 时，优美度之和为 $1$。\n- 当 $l = 3$，$r = 3$ 时，优美度之和为 $2$。\n- 当 $l = 1$，$r = 2$ 时，优美度之和为 $1 + 1 = 2$。\n- 当 $l = 2$，$r = 3$ 时，优美度之和为 $1 + 2 = 3$。\n- 当 $l = 1$，$r = 3$ 时，优美度之和为 $1 + 1 + 2 = 4$。\n\n所以 $p = [1, 3, 2]$ 的总优美度为 $1 + 1 + 2 + 2 + 3 + 4 = 13$。\n\n对于所有 $3! = 6$ 个排列 $p$，其总优美度从小到大排序后分别为 $13, 13, 13, 13, 14, 14$，因此当 $k = 2$ 与 $k = 6$ 时答案分别为 $13$ 和 $14$。\n\n---\n\n#### 【样例 2】\n\n见附件下的 $\\verb!npc/npc2.in!$ 与 $\\verb!npc/npc2.ans!$。\n\n---\n\n#### 【样例 3】\n\n见附件下的 $\\verb!npc/npc3.in!$ 与 $\\verb!npc/npc3.ans!$。\n\n---\n\n#### 【数据范围】\n\n**本题各测试点时间限制不相同。具体地，每个点的时间限制为 $\\max(q\\times 0.5, 2)\\ \\rm{s}$**。\n\n| 测试点编号 | $n$ | $k \\leq$ | $q = $ |\n| :--------: | :-: | :------: | :----: |\n| $1 \\sim 3$ | $\\leq 10$ | $n!$ | $2$ |\n| $4 \\sim 8$ | $\\leq 10^3$ | $2$ | $7$ |\n| $9 \\sim 13$ | $\\in [10^5, 10^6]$ | $\\min(10^{18}, n!)$ | $7$ |\n| $14 \\sim 17$ | $\\leq 10^6$ | $\\min(10^{18}, n!)$ | $7$ |\n| $18 \\sim 25$ | $\\leq 10^{18}$ | $\\min(10^{18}, n!)$ | $10$|\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^{18}$，$1 \\leq k \\leq \\min(10^{18}, n!)$，$1 \\leq q\\le 10$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "挑战 NPC IV", "background": "要是什么都和 NPC 问题一样简单就好了啊。", "description": "小 A 想为小 B 写一首情诗。他现在想出了 $n$ 个句子，每个句子的优美度分别为 $1, 2 \\dots n$。小 A 需要按照一定的顺序将他们组合起来，拼成一首完整的诗。换句话说，小 A 需要重新排列这 $n$ 个句子，形成一个 $1 \\sim n$ 的排列 $p_1, p_2\\dots p_n$；第 $i$ 行诗句的优美度就是原先第 $p_i$ 个句子的优美度，也就是 $p_i$。\n\n不过，由于小 A 是位 OIer，所以他的文采并不是很稳定。他实际上会严重高估自己诗句的优美程度。若一条诗句在小 A 眼里的优美度为 $x$，那么小 B 认为它的优美度是 **$x$ 在二进制表示下最低位的 $1$ 的位置**。其中，小 B 认为最低位的位置是 $1$，次低位为 $2$，以此类推。也就是说，小 B 眼中的优美度 $f(x)$ 为 $1 + \\log_2 \\operatorname{lowbit}(x)$。\n\n小 A 知道，小 B 拿到诗后，只会选取诗的一段来看，而她感受到的优美度是所有她读到的诗句之和。具体的，若诗有 $n$ 句，则小 B 会在 $[1, n]$ 的所有长度 $> 0$ 的区间中抽取一个 $[l, r]$，感受到 $\\displaystyle\\sum_{l \\leq i \\leq r}f(p_i)$ 的优美度。小 A 为了衡量一首诗的优美度，决定将一首诗的总优美度定义为 **所有情况下小 B 感受到的优美度之和**。\n\n照理来说，总优美度最大的组合方式必然是最好的。遗憾的是，在小 A 的精密计算下，他发现，只有他选择总优美度恰好为 **第 $k$ 小** 的情诗时，他才最有可能和小 B 走到一起。于是，小 A 想要知道，对于 $n!$ 首本质不同的诗，第 $k$ 小可能的总优美度是多少。两首诗本质相同当且仅当原排列 $p_1 \\dots p_n$ 相同。\n\n小 A 发现这是一个 NPC 问题，他只好来向你求助了。由于总优美度过于巨大，你只需要帮他求出答案对 $998244353$ 取模后的结果。\n\n特别的，小 A 写了 $q$ 组诗句，所以你需要分别回答他的 $q$ 个问题。", "inputFormat": "从标准输入中读入数据。\n\n第一行一个正整数 $q$，表示诗句的组数。\n\n对于每组数据，仅一行两个正整数 $n, k$ 描述小 A 的问题。", "outputFormat": "输出到标准输出。\n\n对于每组诗句，输出一行一个整数，表示第 $k$ 小的总优美度对 $998244353$ 取模后的结果。", "hint": "#### 【样例 1 解释】\n\n例如，当 $p = [1, 3, 2]$ 时，小 B 眼中每句诗的优美度分别为 $[1, 1, 2]$。那么：\n\n- 当 $l = 1$，$r = 1$ 时，优美度之和为 $1$。\n- 当 $l = 2$，$r = 2$ 时，优美度之和为 $1$。\n- 当 $l = 3$，$r = 3$ 时，优美度之和为 $2$。\n- 当 $l = 1$，$r = 2$ 时，优美度之和为 $1 + 1 = 2$。\n- 当 $l = 2$，$r = 3$ 时，优美度之和为 $1 + 2 = 3$。\n- 当 $l = 1$，$r = 3$ 时，优美度之和为 $1 + 1 + 2 = 4$。\n\n所以 $p = [1, 3, 2]$ 的总优美度为 $1 + 1 + 2 + 2 + 3 + 4 = 13$。\n\n对于所有 $3! = 6$ 个排列 $p$，其总优美度从小到大排序后分别为 $13, 13, 13, 13, 14, 14$，因此当 $k = 2$ 与 $k = 6$ 时答案分别为 $13$ 和 $14$。\n\n---\n\n#### 【样例 2】\n\n见附件下的 $\\verb!npc/npc2.in!$ 与 $\\verb!npc/npc2.ans!$。\n\n---\n\n#### 【样例 3】\n\n见附件下的 $\\verb!npc/npc3.in!$ 与 $\\verb!npc/npc3.ans!$。\n\n---\n\n#### 【数据范围】\n\n**本题各测试点时间限制不相同。具体地，每个点的时间限制为 $\\max(q\\times 0.5, 2)\\ \\rm{s}$**。\n\n| 测试点编号 | $n$ | $k \\leq$ | $q = $ |\n| :--------: | :-: | :------: | :----: |\n| $1 \\sim 3$ | $\\leq 10$ | $n!$ | $2$ |\n| $4 \\sim 8$ | $\\leq 10^3$ | $2$ | $7$ |\n| $9 \\sim 13$ | $\\in [10^5, 10^6]$ | $\\min(10^{18}, n!)$ | $7$ |\n| $14 \\sim 17$ | $\\leq 10^6$ | $\\min(10^{18}, n!)$ | $7$ |\n| $18 \\sim 25$ | $\\leq 10^{18}$ | $\\min(10^{18}, n!)$ | $10$|\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^{18}$，$1 \\leq k \\leq \\min(10^{18}, n!)$，$1 \\leq q\\le 10$。", "locale": "zh-CN"}}}
{"pid": "P9839", "type": "P", "difficulty": 7, "samples": [["12 3 5\n2 3 1 2 3 4 1 3 1 5 4 3\n1 2 5 6\n5 5 7 12\n3 4 3 7", "D\nB\nA"], ["7 6 3\n2 3 3 3 1 3 3 \n1 2 5 7\n1 1 5 6\n1 3 1 6\n2 3 7 7\n1 3 3 5\n1 2 1 4", "A\nA\nB\nD\nB\nD\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "树形数据结构", "博弈论", "线段树", "洛谷原创", "O2优化", "洛谷月赛"], "title": "四暗刻单骑", "background": "", "description": "Alice 和 Bob 很喜欢打麻将。他们在对麻将规则熟悉后，开始对「四暗刻单骑」感兴趣。而在这局游戏中，Alice 和 Bob 都已经集齐了四暗刻，处于听牌状态并准备「四暗刻单骑」，于是我们将这样的局面简化如下：\n\n- 一张麻将牌可以用一个范围在 $[1, k]$ 内的正整数表示，数字相同的牌相同，数字不同的牌不相同。\n- Alice 和 Bob 手中各有 $1$ 张牌作为手牌。两人轮流进行摸牌，每次摸牌的玩家会得到一张牌堆顶部的牌，Alice 先进行。摸牌后会有 $2$ 张手牌，此时需要选择一张牌打出。打出的牌双方可见。\n- 当摸牌时两张手牌相同时，或当前对方打出的牌和自己目前手牌相同时，该玩家「和牌」并获胜，游戏结束。\n\n若牌摸完后无玩家「和牌」，则判为「荒牌流局」，此时判定两位玩家平局。\n\n现在 Alice 和 Bob 都绝顶聪明，并且已经得知了牌堆顶部的所有牌，以及对方手牌。他们都希望自己可以「和牌」并获胜，若自己无法「和牌」就会尽可能阻止对方「和牌」。\n\n你现在拿到了 $n$ 张麻将牌组成的 $a$ 数组，下标依次为 $1\\dots n$。现在有 $m$ 次询问，每次会给定 $x, y, l, r$ 表示：若目前 Alice 手牌为 $x$，Bob 手牌为 $y$，且 **按顺序** 取出 $a$ 中下标为 $[l, r]$ 的所有牌作为游戏牌堆，其中牌 $a_l$ 位于牌堆顶部，Alice 和 Bob 按要求进行游戏，最后结局如何。\n\n询问之间相互独立。特别地，**保证 $l$ 为奇数**。", "inputFormat": "从标准输入中读入数据。\n\n第一行三个正整数 $n, m, k$。\n\n接下来一行 $n$ 个正整数，依次表示 $a_1, a_2 \\dots a_n$。\n\n接下来 $m$ 行，每行四个正整数 $x,y,l,r$，表示一次询问。", "outputFormat": "输出到标准输出。\n\n对于每次询问，输出一行一个字符：如果 Alice 获胜，输出 `A`；如果 Bob 获胜，输出 `B`；如果平局，输出 `D`。", "hint": "**【样例 1 解释】**\n\n在第 $1$ 组询问中，牌堆自顶至底依次是 $3, 4$，Alice 手牌为 $1$，Bob 手牌为 $2$。不难发现此局面会导致「荒牌流局」。 \n\n在第 $2$ 组询问中，牌堆自顶至底依次是 $1, 3, 1, 5, 4, 3$，Alice 手牌为 $5$，Bob 手牌为 $5$。此时 Bob 只需要一直保留这张 $5$，就可以在摸上下一张 $5$ 时「和牌」；而 Alice 不能打出 $5$，因为一旦打出就会导致 Bob 立刻「和牌」。\n\n在第 $3$ 组询问中，牌堆自顶至底依次是 $1, 2, 3, 4, 1$，Alice 手牌为 $3$，Bob 手牌为 $4$。Alice 第一局摸上一张 $1$，她打出这张 $1$。Bob 第一局摸上一张 $2$，他无论是否打出这张 $2$，Alice 都可以在下回合「和牌」。 \n\n---\n\n#### 【样例 3】\n\n见附件下的 $\\verb!mahjong/mahjong3.in!$ 与 $\\verb!mahjong/mahjong3.ans!$。\n\n---\n\n#### 【样例 4】\n\n见附件下的 $\\verb!mahjong/mahjong4.in!$ 与 $\\verb!mahjong/mahjong4.ans!$。\n\n---\n\n**【数据范围】**\n\n| 测试点编号 | $n\\le$ | $m\\le$ | $k\\le$ | 特殊性质 |\n| :--------: | :----: | :----: | :----: | :------: |\n| $1$ | $3$ | $3$ | $3$ | A, B |\n| $2$ | $5$ | $5$ | $5$ | 无 |\n| $3\\sim 5$ | $100$ | $100$ | $100$ | 无 |\n| $6\\sim 7$ | $2000$ | $2000$ | $2000$ | 无 |\n| $8\\sim 10$ | $5\\times 10^4$ | $50$ | $5\\times 10^4$ | 无 |\n| $11$ | $2\\times 10^5$ | $2\\times 10^5$ | $2$ | 无 |\n| $12$ | $2\\times 10^5$ | $2\\times 10^5$ | $80$ | 无 |\n| $13$ | $2\\times 10^5$ | $2\\times 10^5$ | $2\\times 10^5$ | A, B |\n| $14\\sim 15$ | $2\\times 10^5$ | $2\\times 10^5$ | $2\\times 10^5$ | B |\n| $16$ | $2\\times 10^5$ | $2\\times 10^5$ | $2\\times 10^5$ | C |\n| $17\\sim 20$ | $10^5$ | $10^5$ | $10^5$ | 无 |\n| $21\\sim 25$ | $2\\times 10^5$ | $2\\times 10^5$ | $2\\times 10^5$ | 无 |\n\n+ 特殊性质 A：保证每次询问 $l = 1$。\n+ 特殊性质 B：保证每次询问 $r = n$。\n+ 特殊性质 C：保证每次询问 $x = y$。\n\n对于 $100\\%$ 的数据，保证 $3 \\leq n \\leq 2\\times 10^5$，$1 \\leq m \\leq 2\\times 10^5$，$1 \\leq a_i, x, y \\leq k \\leq n$，$1 \\leq l \\leq r \\leq n$，**保证 $l$ 是奇数**。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "四暗刻单骑", "background": "", "description": "Alice 和 Bob 很喜欢打麻将。他们在对麻将规则熟悉后，开始对「四暗刻单骑」感兴趣。而在这局游戏中，Alice 和 Bob 都已经集齐了四暗刻，处于听牌状态并准备「四暗刻单骑」，于是我们将这样的局面简化如下：\n\n- 一张麻将牌可以用一个范围在 $[1, k]$ 内的正整数表示，数字相同的牌相同，数字不同的牌不相同。\n- Alice 和 Bob 手中各有 $1$ 张牌作为手牌。两人轮流进行摸牌，每次摸牌的玩家会得到一张牌堆顶部的牌，Alice 先进行。摸牌后会有 $2$ 张手牌，此时需要选择一张牌打出。打出的牌双方可见。\n- 当摸牌时两张手牌相同时，或当前对方打出的牌和自己目前手牌相同时，该玩家「和牌」并获胜，游戏结束。\n\n若牌摸完后无玩家「和牌」，则判为「荒牌流局」，此时判定两位玩家平局。\n\n现在 Alice 和 Bob 都绝顶聪明，并且已经得知了牌堆顶部的所有牌，以及对方手牌。他们都希望自己可以「和牌」并获胜，若自己无法「和牌」就会尽可能阻止对方「和牌」。\n\n你现在拿到了 $n$ 张麻将牌组成的 $a$ 数组，下标依次为 $1\\dots n$。现在有 $m$ 次询问，每次会给定 $x, y, l, r$ 表示：若目前 Alice 手牌为 $x$，Bob 手牌为 $y$，且 **按顺序** 取出 $a$ 中下标为 $[l, r]$ 的所有牌作为游戏牌堆，其中牌 $a_l$ 位于牌堆顶部，Alice 和 Bob 按要求进行游戏，最后结局如何。\n\n询问之间相互独立。特别地，**保证 $l$ 为奇数**。", "inputFormat": "从标准输入中读入数据。\n\n第一行三个正整数 $n, m, k$。\n\n接下来一行 $n$ 个正整数，依次表示 $a_1, a_2 \\dots a_n$。\n\n接下来 $m$ 行，每行四个正整数 $x,y,l,r$，表示一次询问。", "outputFormat": "输出到标准输出。\n\n对于每次询问，输出一行一个字符：如果 Alice 获胜，输出 `A`；如果 Bob 获胜，输出 `B`；如果平局，输出 `D`。", "hint": "**【样例 1 解释】**\n\n在第 $1$ 组询问中，牌堆自顶至底依次是 $3, 4$，Alice 手牌为 $1$，Bob 手牌为 $2$。不难发现此局面会导致「荒牌流局」。 \n\n在第 $2$ 组询问中，牌堆自顶至底依次是 $1, 3, 1, 5, 4, 3$，Alice 手牌为 $5$，Bob 手牌为 $5$。此时 Bob 只需要一直保留这张 $5$，就可以在摸上下一张 $5$ 时「和牌」；而 Alice 不能打出 $5$，因为一旦打出就会导致 Bob 立刻「和牌」。\n\n在第 $3$ 组询问中，牌堆自顶至底依次是 $1, 2, 3, 4, 1$，Alice 手牌为 $3$，Bob 手牌为 $4$。Alice 第一局摸上一张 $1$，她打出这张 $1$。Bob 第一局摸上一张 $2$，他无论是否打出这张 $2$，Alice 都可以在下回合「和牌」。 \n\n---\n\n#### 【样例 3】\n\n见附件下的 $\\verb!mahjong/mahjong3.in!$ 与 $\\verb!mahjong/mahjong3.ans!$。\n\n---\n\n#### 【样例 4】\n\n见附件下的 $\\verb!mahjong/mahjong4.in!$ 与 $\\verb!mahjong/mahjong4.ans!$。\n\n---\n\n**【数据范围】**\n\n| 测试点编号 | $n\\le$ | $m\\le$ | $k\\le$ | 特殊性质 |\n| :--------: | :----: | :----: | :----: | :------: |\n| $1$ | $3$ | $3$ | $3$ | A, B |\n| $2$ | $5$ | $5$ | $5$ | 无 |\n| $3\\sim 5$ | $100$ | $100$ | $100$ | 无 |\n| $6\\sim 7$ | $2000$ | $2000$ | $2000$ | 无 |\n| $8\\sim 10$ | $5\\times 10^4$ | $50$ | $5\\times 10^4$ | 无 |\n| $11$ | $2\\times 10^5$ | $2\\times 10^5$ | $2$ | 无 |\n| $12$ | $2\\times 10^5$ | $2\\times 10^5$ | $80$ | 无 |\n| $13$ | $2\\times 10^5$ | $2\\times 10^5$ | $2\\times 10^5$ | A, B |\n| $14\\sim 15$ | $2\\times 10^5$ | $2\\times 10^5$ | $2\\times 10^5$ | B |\n| $16$ | $2\\times 10^5$ | $2\\times 10^5$ | $2\\times 10^5$ | C |\n| $17\\sim 20$ | $10^5$ | $10^5$ | $10^5$ | 无 |\n| $21\\sim 25$ | $2\\times 10^5$ | $2\\times 10^5$ | $2\\times 10^5$ | 无 |\n\n+ 特殊性质 A：保证每次询问 $l = 1$。\n+ 特殊性质 B：保证每次询问 $r = n$。\n+ 特殊性质 C：保证每次询问 $x = y$。\n\n对于 $100\\%$ 的数据，保证 $3 \\leq n \\leq 2\\times 10^5$，$1 \\leq m \\leq 2\\times 10^5$，$1 \\leq a_i, x, y \\leq k \\leq n$，$1 \\leq l \\leq r \\leq n$，**保证 $l$ 是奇数**。", "locale": "zh-CN"}}}
