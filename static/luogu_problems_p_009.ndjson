{"pid": "P3279", "type": "P", "difficulty": 6, "samples": [["3\n1 1 1\n0 0", "abc\n"], ["3\n1 3 1\n0 0", "aba"], ["3\n1 3 1\n2 2", "aaa"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2013", "四川", "线段树", "并查集", "各省省选", "ST 表", "Manacher 算法"], "title": "[SCOI2013] 密码", "background": "", "description": "Fish是一条生活在海里的鱼。有一天他很无聊，就到处去寻宝。他找到了位于海底深处的宫殿，但是一扇带有密码锁的大门却阻止了他的前进。\n\n通过翻阅古籍，Fish 得知了这个密码的相关信息：\n\n1. 该密码的长度为N。\n\n2. 密码仅含小写字母。\n\n3. 以每一个字符为中心的最长回文串长度。\n\n4. 以每两个相邻字符的间隙为中心的最长回文串长度。\n\n很快Fish 发现可能有无数种满足条件的密码。经过分析，他觉得这些密码中字典序最小的一个最有可能是答案，你能帮他找到这个密码么？\n\n注意：对于两个串A和B，如果它们的前i个字符都相同，而A的第i+1个字符比B的第i+1个字符小，那么认为是则称密码A 的字典序小于密码B 的字典序，例如字符串abc 字典序小于字符串acb。如果密码A的字典序比其他所有满足条件的密码的字典序都小，则密码A是这些密码中字典序最小的一个。\n", "inputFormat": "输入由三行组成。第一行仅含一个整数N，表示密码的长度。第二行包含N 个整数，表示以每个字符为中心的最长回文串长度。第三行包含N - 1 个整数，表示每两个相邻字符的间隙为中心的最长回文串长度。\n", "outputFormat": "输出仅一行。输出满足条件的最小字典序密码。古籍中的信息是一定正确的，故一定存在满足条件的密码。\n", "hint": "对于20% 的数据，1 <= n <= 100。\n\n另有30% 的数据，1 <= n <= 1000。\n\n最后50% 的数据，1 <= n <= 10^5。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2013] Password", "background": "", "description": "Fish is a fish that lives in the sea. One day he got bored and went treasure hunting. He found a palace deep on the seabed, but a gate with a combination lock blocked his way.\n\nBy consulting ancient books, Fish learned the following information about the password:\n\n1. The length of the password is $N$.\n2. The password contains only lowercase letters.\n3. The lengths of the longest palindromic substrings centered at each character.\n4. The lengths of the longest palindromic substrings centered between every pair of adjacent characters.\n\nFish soon realized that there might be infinitely many passwords that satisfy the conditions. After some analysis, he believes the lexicographically smallest one among them is most likely the answer. Can you help him find this password?\n\nNote: For two strings $A$ and $B$, if their first $i$ characters are the same, and the $(i+1)$-th character of $A$ is smaller than that of $B$, then $A$ is said to be lexicographically smaller than $B$. For example, the string abc is lexicographically smaller than acb. If the lexicographic order of $A$ is smaller than that of all other passwords that satisfy the conditions, then $A$ is the lexicographically smallest one among them.", "inputFormat": "The input consists of three lines. The first line contains a single integer $N$, the length of the password. The second line contains $N$ integers, giving the lengths of the longest palindromic substrings centered at each character. The third line contains $N-1$ integers, giving the lengths of the longest palindromic substrings centered between every pair of adjacent characters.", "outputFormat": "Output a single line: the lexicographically smallest password that satisfies the conditions. The information from the ancient book is guaranteed to be correct, so there is always at least one valid password.", "hint": "Constraints:\n- For 20% of the testdata, $1 \\le N \\le 100$.\n- For another 30% of the testdata, $1 \\le N \\le 1000$.\n- For the remaining 50% of the testdata, $1 \\le N \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2013] 密码", "background": "", "description": "Fish是一条生活在海里的鱼。有一天他很无聊，就到处去寻宝。他找到了位于海底深处的宫殿，但是一扇带有密码锁的大门却阻止了他的前进。\n\n通过翻阅古籍，Fish 得知了这个密码的相关信息：\n\n1. 该密码的长度为N。\n\n2. 密码仅含小写字母。\n\n3. 以每一个字符为中心的最长回文串长度。\n\n4. 以每两个相邻字符的间隙为中心的最长回文串长度。\n\n很快Fish 发现可能有无数种满足条件的密码。经过分析，他觉得这些密码中字典序最小的一个最有可能是答案，你能帮他找到这个密码么？\n\n注意：对于两个串A和B，如果它们的前i个字符都相同，而A的第i+1个字符比B的第i+1个字符小，那么认为是则称密码A 的字典序小于密码B 的字典序，例如字符串abc 字典序小于字符串acb。如果密码A的字典序比其他所有满足条件的密码的字典序都小，则密码A是这些密码中字典序最小的一个。\n", "inputFormat": "输入由三行组成。第一行仅含一个整数N，表示密码的长度。第二行包含N 个整数，表示以每个字符为中心的最长回文串长度。第三行包含N - 1 个整数，表示每两个相邻字符的间隙为中心的最长回文串长度。\n", "outputFormat": "输出仅一行。输出满足条件的最小字典序密码。古籍中的信息是一定正确的，故一定存在满足条件的密码。\n", "hint": "对于20% 的数据，1 <= n <= 100。\n\n另有30% 的数据，1 <= n <= 1000。\n\n最后50% 的数据，1 <= n <= 10^5。\n", "locale": "zh-CN"}}}
{"pid": "P3280", "type": "P", "difficulty": 6, "samples": [["3 3 2\n2 3 1\n-6 5 -3\n1 3 5\n2 3 2\n2 1 6\n1 3\n", "3\n2\n\n"], ["4 4 0\n1 2 3 4\n5 4 -6 -1\n1 2 4\n2 3 100\n3 4 1\n4 1 4", "6\n1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2013", "四川", "倍增", "各省省选", "生成树"], "title": "[SCOI2013] 摩托车交易", "background": "", "description": "mzry1992 在打完吊针出院之后，买了辆新摩托车，开始了在周边城市的黄金运送生意。在 mzry1992 生活的地方，城市之间是用双向高速公路连接的。另外，每条高速公路有一个载重上限，即在不考虑驾驶员和摩托车重量的情况下，如果所载货物的量超过某个值，则不能驶上该条高速公路。\n\n今年，mzry1992 一共收到了来自 $n$ 个不同城市的 $n$ 份定订单，每个订单要求卖出上限为一定量的黄金，或是要求买入上限为一定量的黄金。由于订单并不是同时发来的，为了维护生意上的名声，mzry1992 不得不按照订单发来的顺序与客户进行交易。他与第i 个客户进行交易的具体步骤是：\n\n1. 前往第 $i$ 个客户所在城市。当然，中途是完全允许经过其他城市的。 \n2. 与第 $i$ 个客户进行交易，在此过程中他希望有限制的让交易额尽量大。具体的限制有两个：    \n(a) 他希望与最后一个客户完成交易后，手上没有剩余黄金。  \n(b) 由于黄金是很贵重的物品，不能出现因为买入过多黄金而造成在以后的运送过程中不得不丢弃黄金的情况。\n\n一开始，mzry1992 位于第一个订单客户所在的城市。现在有一个好消息，有人提供了 mzry1992 免费试用周边城市的列车系统的资格。具体来讲，如果mzry1992希望从 $A$ 城市到达 $B$ 城市，且 $A$、$B$ 城市均有列车站的话，他可以携带着黄金与摩托车从 $A$ 城市乘坐列车到 $B$ 城市，这里假定乘坐列车没有载重限制。\n\n现在已知城市间的交通系统情况和订单情况，请帮助 mzry1992 计算每个向 mzry1992 购买黄金的客户的购买量。\n", "inputFormat": "输入的第一行有三个整数 $n,m,q$，分别表示城市数，连通城市的高速公路数和有列车站的城市数。\n\n接下来的一行有 $n$ 个数，每个数均不相同，且值介于 $1$ 到 $n$ 之间，代表订单的顺序。\n\n第三行有 $n$ 个数，第 $i$ 个数表示 $i$ 号城市的订单的上限额 $b_i$，$b_i$ 为正值表示该订单为买入交易（针对mzry1992 而言），上限为 $b_i$，$b_i$ 为负值表示该订单为卖出交易（同样针对mzry1992 而言）上限为 $-b_i$。\n\n接下来的 $m$ 行每行有三个数，$u, v, w$，表示城市 $u$ 和城市 $v$ 之间有一条载重上限为 $w$ 的高速公路，这里假定所有高速公路都是双向的，城市的序号是从 $1$ 到 $n$ 的。\n\n输入的最后一行有 $q$ 个数，代表有列车站城市的序号。\n", "outputFormat": "按照订单顺序对于每个卖出交易，输出一行，该行只有一个整数 $x$，表示卖出黄金的量。\n", "hint": "### 样例解释\n\n第一组样例：其中一种合法的方案是最初从 $2$ 号城市买入 $5$ 单位的黄金，先走第三条高速公路到 $1$ 号城市，然后再坐列车到 $3$ 号城市，在 $3$ 号城市卖出 $3$ 单位的黄金，然后乘坐列车到 $1$ 城市，在 $1$ 号城市卖出 $2$ 单位的黄金。\n\n\n第二组样例：其中一种合法的方案是最初从 $1$ 号城市买入 $4$ 单位的黄金，走第一条高速公路，在 $2$ 号城市买入 $3$ 单位的黄金，走第二条高速公路，在三城市点卖出 $6$ 单位的黄金，走第三条高速公路，在 $4$ 号城市卖出 $1$ 单位的黄金。\n\n### 数据范围与约定\n\n- 对于 $20\\%$ 数据，$n \\le 100$，$m \\le 200$。\n- 对于 $50\\%$ 数据，$n \\le 3000$，$m \\le 6000$。\n- 对于 $100\\%$ 数据，$1 \\le n \\le 10^5$，$n - 1 \\le m \\le 2\\times 10^5$，$0 \\le q \\le n$，$0 < |b_i| < 10^9$，$0 < w < 10^9$，保证任意两个城市之间是通过高速公路连通的。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2013] Motorcycle Trading", "background": "", "description": "After being discharged from the hospital, mzry1992 bought a new motorcycle and started a gold delivery business among nearby cities. In the place where mzry1992 lives, cities are connected by bidirectional highways. In addition, each highway has a load limit: ignoring the weight of the rider and the motorcycle, if the amount of cargo carried exceeds a certain value, that highway cannot be used.\n\nThis year, mzry1992 received $n$ orders from $n$ different cities. Each order either requests to buy up to a certain amount of gold from him, or to sell up to a certain amount of gold to him. Since orders do not arrive simultaneously, to maintain his reputation, mzry1992 must trade with customers in the order the orders arrive. When trading with the $i$-th customer, he performs the following steps:\n\n1. Travel to the city of the $i$-th customer. Passing through other cities en route is fully allowed.\n2. Trade with the $i$-th customer. In this process, he wants to maximize the transaction amount subject to the following two constraints:\n   (a) After finishing the transaction with the last customer, he must hold no gold.\n   (b) Because gold is valuable, he is not allowed to overbuy in a way that would force him to discard gold later during transportation.\n\nInitially, mzry1992 is located in the city of the first order. Here is some good news: someone has given mzry1992 a free trial to use the railway system among nearby cities. Specifically, if he wants to travel from city $A$ to city $B$, and both $A$ and $B$ have railway stations, then he can carry both gold and his motorcycle by train from $A$ to $B$, assuming there is no load limit on the train.\n\nGiven the transportation network and the orders, please help mzry1992 compute, for each customer who buys gold from him (i.e., his sell transactions), the quantity they purchase.", "inputFormat": "The first line contains three integers $n, m, q$, denoting the number of cities, the number of highways, and the number of cities with railway stations, respectively.\n\nThe second line contains $n$ distinct integers, each between $1$ and $n$, representing a permutation of the cities: the order in which the orders arrive.\n\nThe third line contains $n$ integers, where the $i$-th number is the upper limit $b_i$ of the order in city $i$. If $b_i > 0$, then from the perspective of mzry1992 it is a buy order (he buys gold) with upper limit $b_i$. If $b_i < 0$, then it is a sell order (he sells gold) with upper limit $-b_i$.\n\nEach of the next $m$ lines contains three integers $u, v, w$, meaning there is a bidirectional highway between cities $u$ and $v$ with load limit $w$. City indices are from $1$ to $n$.\n\nThe last line contains $q$ integers, which are the indices of the cities that have railway stations.", "outputFormat": "In the order of the orders, for each sell transaction, output one line containing a single integer $x$, the amount of gold sold.", "hint": "Sample explanation:\n\n- First sample: One valid plan is to initially buy $5$ units of gold in city $2$, take the third highway to city $1$, then take the train to city $3$, sell $3$ units of gold in city $3$, take the train back to city $1$, and sell $2$ units of gold in city $1$.\n- Second sample: One valid plan is to initially buy $4$ units of gold in city $1$, take the first highway, buy $3$ units of gold in city $2$, take the second highway, sell $6$ units of gold in city $3$, take the third highway, and sell $1$ unit of gold in city $4$.\n\nConstraints:\n\n- For $20\\%$ of the testdata, $n \\le 100$, $m \\le 200$.\n- For $50\\%$ of the testdata, $n \\le 3000$, $m \\le 6000$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $n - 1 \\le m \\le 2\\times 10^5$, $0 \\le q \\le n$, $0 < |b_i| < 10^9$, $0 < w < 10^9$. It is guaranteed that any two cities are connected via highways.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2013] 摩托车交易", "background": "", "description": "mzry1992 在打完吊针出院之后，买了辆新摩托车，开始了在周边城市的黄金运送生意。在 mzry1992 生活的地方，城市之间是用双向高速公路连接的。另外，每条高速公路有一个载重上限，即在不考虑驾驶员和摩托车重量的情况下，如果所载货物的量超过某个值，则不能驶上该条高速公路。\n\n今年，mzry1992 一共收到了来自 $n$ 个不同城市的 $n$ 份定订单，每个订单要求卖出上限为一定量的黄金，或是要求买入上限为一定量的黄金。由于订单并不是同时发来的，为了维护生意上的名声，mzry1992 不得不按照订单发来的顺序与客户进行交易。他与第i 个客户进行交易的具体步骤是：\n\n1. 前往第 $i$ 个客户所在城市。当然，中途是完全允许经过其他城市的。 \n2. 与第 $i$ 个客户进行交易，在此过程中他希望有限制的让交易额尽量大。具体的限制有两个：    \n(a) 他希望与最后一个客户完成交易后，手上没有剩余黄金。  \n(b) 由于黄金是很贵重的物品，不能出现因为买入过多黄金而造成在以后的运送过程中不得不丢弃黄金的情况。\n\n一开始，mzry1992 位于第一个订单客户所在的城市。现在有一个好消息，有人提供了 mzry1992 免费试用周边城市的列车系统的资格。具体来讲，如果mzry1992希望从 $A$ 城市到达 $B$ 城市，且 $A$、$B$ 城市均有列车站的话，他可以携带着黄金与摩托车从 $A$ 城市乘坐列车到 $B$ 城市，这里假定乘坐列车没有载重限制。\n\n现在已知城市间的交通系统情况和订单情况，请帮助 mzry1992 计算每个向 mzry1992 购买黄金的客户的购买量。\n", "inputFormat": "输入的第一行有三个整数 $n,m,q$，分别表示城市数，连通城市的高速公路数和有列车站的城市数。\n\n接下来的一行有 $n$ 个数，每个数均不相同，且值介于 $1$ 到 $n$ 之间，代表订单的顺序。\n\n第三行有 $n$ 个数，第 $i$ 个数表示 $i$ 号城市的订单的上限额 $b_i$，$b_i$ 为正值表示该订单为买入交易（针对mzry1992 而言），上限为 $b_i$，$b_i$ 为负值表示该订单为卖出交易（同样针对mzry1992 而言）上限为 $-b_i$。\n\n接下来的 $m$ 行每行有三个数，$u, v, w$，表示城市 $u$ 和城市 $v$ 之间有一条载重上限为 $w$ 的高速公路，这里假定所有高速公路都是双向的，城市的序号是从 $1$ 到 $n$ 的。\n\n输入的最后一行有 $q$ 个数，代表有列车站城市的序号。\n", "outputFormat": "按照订单顺序对于每个卖出交易，输出一行，该行只有一个整数 $x$，表示卖出黄金的量。\n", "hint": "### 样例解释\n\n第一组样例：其中一种合法的方案是最初从 $2$ 号城市买入 $5$ 单位的黄金，先走第三条高速公路到 $1$ 号城市，然后再坐列车到 $3$ 号城市，在 $3$ 号城市卖出 $3$ 单位的黄金，然后乘坐列车到 $1$ 城市，在 $1$ 号城市卖出 $2$ 单位的黄金。\n\n\n第二组样例：其中一种合法的方案是最初从 $1$ 号城市买入 $4$ 单位的黄金，走第一条高速公路，在 $2$ 号城市买入 $3$ 单位的黄金，走第二条高速公路，在三城市点卖出 $6$ 单位的黄金，走第三条高速公路，在 $4$ 号城市卖出 $1$ 单位的黄金。\n\n### 数据范围与约定\n\n- 对于 $20\\%$ 数据，$n \\le 100$，$m \\le 200$。\n- 对于 $50\\%$ 数据，$n \\le 3000$，$m \\le 6000$。\n- 对于 $100\\%$ 数据，$1 \\le n \\le 10^5$，$n - 1 \\le m \\le 2\\times 10^5$，$0 \\le q \\le n$，$0 < |b_i| < 10^9$，$0 < w < 10^9$，保证任意两个城市之间是通过高速公路连通的。\n", "locale": "zh-CN"}}}
{"pid": "P3281", "type": "P", "difficulty": 6, "samples": [["10\n3 1 0 3\n3 1 0 3", "120\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "2013", "四川", "各省省选", "数位 DP", "进制"], "title": "[SCOI2013] 数数", "background": null, "description": "Fish 是一条生活在海里的鱼，有一天他很无聊，就开始数数玩。他数数玩的具体规则是：\n\n1. 确定数数的进制 $B$。\n\n2. 确定一个数数的区间 $[L, R]$。\n\n3. 对于 $[L, R]$ 间的每一个数，把该数视为一个字符串，列出该字符串的每一个（连续的）子串对应的 $B$ 进制数的值。\n\n4. 对所有列出的数求和。现在 Fish 数了一遍数，但是不确定自己的结果是否正确了。由于 $[L, R]$ 较大，他没有多余精力去验证是否正确，你能写一个程序来帮他验证吗？", "inputFormat": "输入包含三行。\n\n第一行仅有一个数 $B$，表示数数的进制。\n\n第二行有 $N+1$ 个数，第一个数为 $N$，表示数 $L$ 在 $B$ 进制下的长度为 $N$，接下里的 $N$ 个数从高位到低位的表示数 $L$ 的具体每一位。\n\n第三行有 $M+ 1$ 个数，第一个数为 $M$，表示数 $R$ 在 $B$ 进制下的长度为 $M$，接下里的 $M$ 个数从高位到低位的表示数 $R$ 的具体每一位。", "outputFormat": "输出仅一行，即按照 Fish 数数规则的结果，结果用 $10$ 进制表示，由于该数可能很大，输出该数模上 $20130427$ 的模数。\n\n数据中有 $r<l$ 的情况，输出的是 $-ans[r+1,l-1]\\bmod 20130427$。", "hint": "**【样例解释】**\n\n$[103, 103]$ 之间仅有数 $103$，该数的所有子串包括$1, 10, 103, 0, 03, 3$，其和为 $120$。\n\n**【数据范围与约定】**\n\n$20\\%$ 数据，$0 \\le L \\le R \\le 10^5$。\n\n$50\\%$ 数据，$2 \\le B \\le 1000，1 \\le N,M \n\\le 1000$。\n\n$100\\%$ 数据，$2 \\le B \\le 10^5，1 \\le N,M \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2013] Counting", "background": "", "description": "Fish is a fish living in the sea. One day he felt bored and started a counting game. The detailed rules are:\n\n1. Fix a base $B$ for counting.\n\n2. Fix an interval $[L, R]$.\n\n3. For each number in $[L, R]$, regard the number as a string, and list the value in base $B$ of each (contiguous) substring of that string.\n\n4. Sum all the listed numbers. Now Fish has finished one round of counting, but he is not sure whether his result is correct. Since $[L, R]$ is large, he does not have the extra energy to verify it. Can you write a program to help him verify it?", "inputFormat": "The input contains three lines.\n\nThe first line contains only one number $B$, which is the base for counting.\n\nThe second line contains $N+1$ numbers. The first number is $N$, meaning that the length of $L$ in base $B$ is $N$. The next $N$ numbers, from the most significant digit to the least significant digit, represent each digit of $L$.\n\nThe third line contains $M+ 1$ numbers. The first number is $M$, meaning that the length of $R$ in base $B$ is $M$. The next $M$ numbers, from the most significant digit to the least significant digit, represent each digit of $R$.", "outputFormat": "Output exactly one line: the result according to Fish’s counting rules, expressed in base $10$. Since the number can be large, output the result modulo $20130427$.\n\nIn the testdata, there may be cases where $r<l$. In such cases, the output is $-ans[r+1,l-1]\\bmod 20130427$.", "hint": "Sample Explanation:\n\n$[103, 103]$ contains only the number 103. All its substrings include 1, 10, 103, 0, 03, 3, and their sum is 120.\n\nConstraints:\n\n$20\\%$ of the testdata: $0 \\le L \\le R \\le 10^5$.\n\n$50\\%$ of the testdata: $2 \\le B \\le 1000, 1 \\le N, M \\le 1000$.\n\n$100\\%$ of the testdata: $2 \\le B \\le 10^5, 1 \\le N, M \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2013] 数数", "background": null, "description": "Fish 是一条生活在海里的鱼，有一天他很无聊，就开始数数玩。他数数玩的具体规则是：\n\n1. 确定数数的进制 $B$。\n\n2. 确定一个数数的区间 $[L, R]$。\n\n3. 对于 $[L, R]$ 间的每一个数，把该数视为一个字符串，列出该字符串的每一个（连续的）子串对应的 $B$ 进制数的值。\n\n4. 对所有列出的数求和。现在 Fish 数了一遍数，但是不确定自己的结果是否正确了。由于 $[L, R]$ 较大，他没有多余精力去验证是否正确，你能写一个程序来帮他验证吗？", "inputFormat": "输入包含三行。\n\n第一行仅有一个数 $B$，表示数数的进制。\n\n第二行有 $N+1$ 个数，第一个数为 $N$，表示数 $L$ 在 $B$ 进制下的长度为 $N$，接下里的 $N$ 个数从高位到低位的表示数 $L$ 的具体每一位。\n\n第三行有 $M+ 1$ 个数，第一个数为 $M$，表示数 $R$ 在 $B$ 进制下的长度为 $M$，接下里的 $M$ 个数从高位到低位的表示数 $R$ 的具体每一位。", "outputFormat": "输出仅一行，即按照 Fish 数数规则的结果，结果用 $10$ 进制表示，由于该数可能很大，输出该数模上 $20130427$ 的模数。\n\n数据中有 $r<l$ 的情况，输出的是 $-ans[r+1,l-1]\\bmod 20130427$。", "hint": "**【样例解释】**\n\n$[103, 103]$ 之间仅有数 $103$，该数的所有子串包括$1, 10, 103, 0, 03, 3$，其和为 $120$。\n\n**【数据范围与约定】**\n\n$20\\%$ 数据，$0 \\le L \\le R \\le 10^5$。\n\n$50\\%$ 数据，$2 \\le B \\le 1000，1 \\le N,M \n\\le 1000$。\n\n$100\\%$ 数据，$2 \\le B \\le 10^5，1 \\le N,M \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3282", "type": "P", "difficulty": 5, "samples": [["4.000000 10.000000\n5\n-2.00000000 9.00000000 3\n1.00000000 7.26794919 10\n-3.00000000 7.26794919 3\n2.00000000 9.00000000 10\n0.00000000 9.00000000 10\n5\n66.60 10\n106.20 3\n88.20 5\n91.80 5\n84.60 5", "34"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "四川", "各省省选"], "title": "[SCOI2013] 泡泡鱼", "background": "", "description": "Fish 是一条生活在海里的鱼，有一天他很无聊，想起了一个人类玩的游戏泡泡龙，于是他打算玩一把泡泡鱼。Fish 并不是特别清楚泡泡龙的规则（我们也是），于是他采用自己定的近似规则。\n\n这里我们把海底想象成一个平面区域，它的上边界离发射点距离为H，左右边界离发射点的距离均为W。\n\n起初时在这个区域的某些位置上有一些各种颜色的泡泡，且每个泡泡的直径为2（这里视泡泡为圆形）。\n\n如果两个相同颜色的泡泡相切，我们就说这两个泡泡相邻。\n\n如果两个相同颜色的泡泡相邻或者可以通过第三个相同颜色的泡泡相连，我们就说这两个泡泡相连。\n\n为了方便描述，我们定义发射点的坐标为(0, 0)，每次Fish 会在发射点以某个给定角度发射某种颜色的泡泡。\n\n如果泡泡撞到墙壁或者其他泡泡（即在某个时间第一次与墙壁或者其他泡泡相切），这个泡泡就会停住。如果这个泡泡与超过一个泡泡相连，那么这些泡泡就会消失，而Fish 就会得到消失泡泡数量的平方的分数值。\n\n请注意，初始时如果有超过两个泡泡相连，这些泡泡并不会消失。现在已知初始泡泡的情况和每次发射泡泡的颜色和角度（相对于+x 轴逆时针方向），请你给出最终的总得分。注意，在上一次发射出去的泡泡停止之前，Fish 不能够继续发射泡泡。\n", "inputFormat": "输入的第一行有两个实数W，H，表示游戏区域的边界坐标，精确到小数点后六位。\n\n接下来一行有一个整数n，表示初始泡泡的个数。\n\n接下来n 行，第i 行首先是两个浮点数xi 和yi，表示第i 个泡泡的圆心坐标，精确到小数点后八位，然后是一个整数ci，表示第i 个泡泡的颜色。\n\n接下来一行有一个整数q，表示发射的泡泡的个数。最后q 行，第i 行首先是一个浮点数ai，精确到小数点后两位，表示第i 次发射的泡泡的角度，然后是一个整数ci，表示第i 次发射的泡泡的颜色。\n\n数据保证刚开始所有的泡泡均在区域内！数据保证泡泡刚发射的位置永远不会停放有泡泡！\n\n由于泡泡会在海水中浮动（以及计算机浮点的精度误差），我们认为当(xa-xb)^2 + (ya-yb)^2  <= (2 [1]\\* 1)^2 + 10^-6成立时，泡泡a 和泡泡b 相切！数据保证初始时不存在相交的泡泡\n", "outputFormat": "输出只有一行，这一行只有一个整数，代表Fish 最后的总得分。\n", "hint": "对于30% 的数据，1 <= n <= 10，1 <= q <= 10。\n\n另有50% 的数据，1 <= n <= 1000，1 <= q <= 1000。\n\n剩下20% 的数据，1 <= n <= 10^5，1 <= q <= 10。\n\n对于所有的数据，有0 < a < 180，0 < W, H <= 1000，1 <= ci <= 100。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2013] Bubble Fish", "background": "", "description": "Fish is a fish living in the sea. One day he felt bored and remembered a human game called Puzzle Bobble, so he decided to play a variant named Bubble Fish. Fish is not very clear about the rules of Puzzle Bobble (neither are we), so he adopts his own approximate rules.\n\nImagine the seabed as a planar region. Its top boundary is at distance $H$ from the launch point, and both the left and right boundaries are at distance $W$ from the launch point.\n\nInitially, there are some bubbles of various colors placed at certain positions within this region, and each bubble has diameter $2$ (bubbles are treated as circles).\n\nIf two bubbles of the same color are tangent, we say these two bubbles are adjacent.\n\nIf two bubbles of the same color are adjacent, or can be connected through a chain of bubbles of the same color, we say these two bubbles are connected.\n\nFor convenience, we define the coordinates of the launch point to be $(0, 0)$. Each time, Fish fires a bubble of a given color from the launch point at a given angle.\n\nIf the bubble hits a wall or another bubble (that is, at the first moment it becomes tangent to the wall or another bubble), it stops. If this bubble becomes connected to more than one bubble of the same color (i.e., the connected component of that color including the new bubble has size at least $3$), then all bubbles in that component disappear, and Fish earns a score equal to the square of the number of disappeared bubbles.\n\nNote that initially, even if there is a connected component of size greater than $2$, those bubbles do not disappear. Given the initial configuration of bubbles and, for each shot, the color and the angle (measured counterclockwise from the $+x$-axis), output the final total score. Note that Fish cannot fire the next bubble until the previously fired bubble has stopped.", "inputFormat": "The first line contains two real numbers $W, H$, the boundary distances of the game region, accurate to six decimal places.\n\nThe next line contains an integer $n$, the number of initial bubbles.\n\nThe following $n$ lines: line $i$ contains two floating-point numbers $x_i$ and $y_i$, the center coordinates of the $i$-th bubble, accurate to eight decimal places, followed by an integer $c_i$, the color of the $i$-th bubble.\n\nThe next line contains an integer $q$, the number of fired bubbles. The last $q$ lines: line $i$ contains a floating-point number $a_i$, accurate to two decimal places, the firing angle of the $i$-th bubble, followed by an integer $c_i$, the color of the $i$-th bubble.\n\nThe testdata guarantees that all initial bubbles lie within the region. It is guaranteed that at the moment of firing, there is never a bubble parked at the launch position.\n\nBecause bubbles float in seawater (and due to floating-point precision), we consider bubbles $a$ and $b$ tangent when\n$(x_a - x_b)^2 + (y_a - y_b)^2 \\le (2 \\cdot 1)^2 + 10^{-6}$.\nThe testdata guarantees that initially there are no intersecting bubbles.", "outputFormat": "Output a single line containing one integer, the final total score of Fish.", "hint": "For 30% of the testdata, $1 \\le n \\le 10$, $1 \\le q \\le 10$.\n\nFor another 50% of the testdata, $1 \\le n \\le 1000$, $1 \\le q \\le 1000$.\n\nFor the remaining 20% of the testdata, $1 \\le n \\le 10^5$, $1 \\le q \\le 10$.\n\nFor all testdata, $0 < a_i < 180$, $0 < W, H \\le 1000$, $1 \\le c_i \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2013] 泡泡鱼", "background": "", "description": "Fish 是一条生活在海里的鱼，有一天他很无聊，想起了一个人类玩的游戏泡泡龙，于是他打算玩一把泡泡鱼。Fish 并不是特别清楚泡泡龙的规则（我们也是），于是他采用自己定的近似规则。\n\n这里我们把海底想象成一个平面区域，它的上边界离发射点距离为H，左右边界离发射点的距离均为W。\n\n起初时在这个区域的某些位置上有一些各种颜色的泡泡，且每个泡泡的直径为2（这里视泡泡为圆形）。\n\n如果两个相同颜色的泡泡相切，我们就说这两个泡泡相邻。\n\n如果两个相同颜色的泡泡相邻或者可以通过第三个相同颜色的泡泡相连，我们就说这两个泡泡相连。\n\n为了方便描述，我们定义发射点的坐标为(0, 0)，每次Fish 会在发射点以某个给定角度发射某种颜色的泡泡。\n\n如果泡泡撞到墙壁或者其他泡泡（即在某个时间第一次与墙壁或者其他泡泡相切），这个泡泡就会停住。如果这个泡泡与超过一个泡泡相连，那么这些泡泡就会消失，而Fish 就会得到消失泡泡数量的平方的分数值。\n\n请注意，初始时如果有超过两个泡泡相连，这些泡泡并不会消失。现在已知初始泡泡的情况和每次发射泡泡的颜色和角度（相对于+x 轴逆时针方向），请你给出最终的总得分。注意，在上一次发射出去的泡泡停止之前，Fish 不能够继续发射泡泡。\n", "inputFormat": "输入的第一行有两个实数W，H，表示游戏区域的边界坐标，精确到小数点后六位。\n\n接下来一行有一个整数n，表示初始泡泡的个数。\n\n接下来n 行，第i 行首先是两个浮点数xi 和yi，表示第i 个泡泡的圆心坐标，精确到小数点后八位，然后是一个整数ci，表示第i 个泡泡的颜色。\n\n接下来一行有一个整数q，表示发射的泡泡的个数。最后q 行，第i 行首先是一个浮点数ai，精确到小数点后两位，表示第i 次发射的泡泡的角度，然后是一个整数ci，表示第i 次发射的泡泡的颜色。\n\n数据保证刚开始所有的泡泡均在区域内！数据保证泡泡刚发射的位置永远不会停放有泡泡！\n\n由于泡泡会在海水中浮动（以及计算机浮点的精度误差），我们认为当(xa-xb)^2 + (ya-yb)^2  <= (2 [1]\\* 1)^2 + 10^-6成立时，泡泡a 和泡泡b 相切！数据保证初始时不存在相交的泡泡\n", "outputFormat": "输出只有一行，这一行只有一个整数，代表Fish 最后的总得分。\n", "hint": "对于30% 的数据，1 <= n <= 10，1 <= q <= 10。\n\n另有50% 的数据，1 <= n <= 1000，1 <= q <= 1000。\n\n剩下20% 的数据，1 <= n <= 10^5，1 <= q <= 10。\n\n对于所有的数据，有0 < a < 180，0 < W, H <= 1000，1 <= ci <= 100。\n", "locale": "zh-CN"}}}
{"pid": "P3283", "type": "P", "difficulty": 6, "samples": [["3 2\n", "17"], ["3 3", "71"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "四川", "各省省选", "深度优先搜索 DFS", "容斥原理"], "title": "[SCOI2013] 火柴棍数字", "background": "", "description": "Fish是一条生活在海里的鱼，有一天他很无聊，于是他去捡了人类扔进海里的垃圾，打算用这些来玩些什么。\n\n他从捡回来的垃圾堆里找到了不少火柴棍，便把这些火柴棍拼成了一个长度为n 的十进制数，每个数字的拼法如下图所示\n\n注意：每个数字占据的宽度和摆放方式是固定的，故以下情况均不合法。 ![](https://cdn.luogu.com.cn/upload/pic/4633.png)\n\n ![](https://cdn.luogu.com.cn/upload/pic/4634.png) \n\n拼完之后他好累，感觉再也不会拼了。他对拼出来的数大小不满意，希望通过移动一些火柴棍的位置来把这个数变得尽量大。\n\n由于太累，他只能最多移动k 根火柴棍。而且由于数字的最低位放在墙边，他不能在该数的低位后面添加数字，但他可以在该数的前面添加数字。\n\n你能帮他算出他移动火柴棍之后的数最大能是多大吗？\n\n注意：火柴棍对于Fish 来说是很贵重的物品，所以不允许折断或丢弃火柴棍。\n\n注意：火柴头的方向不影响数字的辨识，例如下面几种情况都是数字1\n\n![](https://cdn.luogu.com.cn/upload/pic/4635.png)\n", "inputFormat": "输入仅含一行，分别是长度为n 的十进制数x 和最多移动火柴棍的数量k。x 没有前导零。\n", "outputFormat": "输出仅一行，表示移动火柴棍之后的最大数。\n", "hint": "对于30% 的数据，1 <= n <= 10，0 <= k <= 10。\n\n对于100% 的数据，1 <= n <= 500，0 <=k <=3500。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2013] Matchstick Number", "background": "", "description": "Fish is a fish that lives in the sea. One day he was bored, so he picked up trash that humans had thrown into the sea, planning to play with it.\n\nFrom the pile of trash he found many matchsticks, and he used them to form a base-10 number of length $n$. Each digit is assembled as shown in the figures below.\n\nNote: The width and placement of each digit are fixed, so the following cases are all invalid.\n![](https://cdn.luogu.com.cn/upload/pic/4633.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/4634.png)\n\nAfter finishing, he was exhausted and felt he could not build anymore. He was not satisfied with the number he formed and wanted to make it as large as possible by moving some matchsticks.\n\nBecause he is too tired, he can move at most $k$ matchsticks. Also, since the least significant digit is against a wall, he cannot append digits to the low end of the number; however, he may prepend digits to the front of the number.\n\nCan you help him compute the maximum possible number after he moves the matchsticks?\n\nNote: Matchsticks are precious to Fish, so breaking or discarding matchsticks is not allowed.\n\nNote: The orientation of a match head does not affect digit recognition. For example, the following are all the digit 1.\n![](https://cdn.luogu.com.cn/upload/pic/4635.png)", "inputFormat": "The input contains a single line with a base-10 number $x$ of length $n$ and an integer $k$, the maximum number of matchsticks that may be moved. The number $x$ has no leading zero.", "outputFormat": "Output a single line containing the maximum possible number after moving the matchsticks.", "hint": "For 30% of the testdata, $1 \\le n \\le 10$, $0 \\le k \\le 10$.\n\nFor 100% of the testdata, $1 \\le n \\le 500$, $0 \\le k \\le 3500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2013] 火柴棍数字", "background": "", "description": "Fish是一条生活在海里的鱼，有一天他很无聊，于是他去捡了人类扔进海里的垃圾，打算用这些来玩些什么。\n\n他从捡回来的垃圾堆里找到了不少火柴棍，便把这些火柴棍拼成了一个长度为n 的十进制数，每个数字的拼法如下图所示\n\n注意：每个数字占据的宽度和摆放方式是固定的，故以下情况均不合法。 ![](https://cdn.luogu.com.cn/upload/pic/4633.png)\n\n ![](https://cdn.luogu.com.cn/upload/pic/4634.png) \n\n拼完之后他好累，感觉再也不会拼了。他对拼出来的数大小不满意，希望通过移动一些火柴棍的位置来把这个数变得尽量大。\n\n由于太累，他只能最多移动k 根火柴棍。而且由于数字的最低位放在墙边，他不能在该数的低位后面添加数字，但他可以在该数的前面添加数字。\n\n你能帮他算出他移动火柴棍之后的数最大能是多大吗？\n\n注意：火柴棍对于Fish 来说是很贵重的物品，所以不允许折断或丢弃火柴棍。\n\n注意：火柴头的方向不影响数字的辨识，例如下面几种情况都是数字1\n\n![](https://cdn.luogu.com.cn/upload/pic/4635.png)\n", "inputFormat": "输入仅含一行，分别是长度为n 的十进制数x 和最多移动火柴棍的数量k。x 没有前导零。\n", "outputFormat": "输出仅一行，表示移动火柴棍之后的最大数。\n", "hint": "对于30% 的数据，1 <= n <= 10，0 <= k <= 10。\n\n对于100% 的数据，1 <= n <= 500，0 <=k <=3500。\n", "locale": "zh-CN"}}}
{"pid": "P3284", "type": "P", "difficulty": 7, "samples": [["2\n5 1 4 27 3 15", "2700"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2014", "四川", "各省省选"], "title": "[SCOI2014] 方伯伯打扑克", "background": null, "description": "方伯伯有一些空白的扑克牌。方伯伯想要用这些牌来玩一个数学游戏。\n\n方伯伯首先决定好他要用这些空白的扑克牌组成 $m$ 个牌堆，每一堆牌的张数都是 $2$ 的整数次幂。确切地说，第 $i$ 堆（**注意**：从 $0$ 开始计数）牌将会有 $2^{n_i}$ 张牌。方伯伯首先决定好第 $0$ 堆牌要有 $2^{n_0}$ 张牌，然后将这堆牌从上到下按次序标记 $1 \\sim 2^{n_0}$ 的十进制数字。\n\n方伯伯开始游戏前决定要先洗牌，他决定好要洗 $x_0$ 次牌。他洗牌有一个固定的模式，每次洗牌操作等同于以下两个步骤的操作：\n\n1. 将所有奇数位上的牌依次取出组成新的一堆牌。\n2. 将新的一堆牌放在旧有的牌前面。\n\n如当 $n_0=3$ 时，第 $0$ 堆牌从上到下一开始为 ``12345678``，洗一次牌得到 ``13572468``，洗两次牌得到 ``15263748``。\n\n洗完牌后，方伯伯在心中决定好把其中从上往下数第 $l_0$ 到第 $r_0$ 张牌上的数字均加上一个数字 $t_0$，并依次（转换成二进制）异或之后得到一个异或值；方伯伯把第 $0$ 堆牌的这个异或值取模 $\\bmod  \\ 2^{n_0-1}$ 的值记作 $\\mathrm{ans}_0$。\n\n类似地，方伯伯将按同样的方式用剩下的 $m-1$ 个牌堆。具体地说，他决定按照如下几个公式来对每一堆牌组进行游戏：\n1. 对于第 $i$ 堆牌，牌堆中将会有 $2^{n_i}$ 张牌，并从上到下标有 $1\\sim 2^{n_i}$ 的十进制整数。其中，$n_i=(\\mathrm{ans}_{i-1}+i-1) \\bmod 5 \\mathrel{+} \\mathrm{base}$， $\\mathrm{base}$ 是一个方伯伯事先决定好的正整数。\n2. 方伯伯将会先决定好自己用来游戏的牌处于牌堆中的什么位置。方伯伯首先决定好他要看的第一张牌应该是第 $l_i$ 张，其中 $l_i=(2\\mathrm{ans}_{i-1}+l_{i-1}+i-1)\\bmod 2^{n_i} \\mathrel{+} 1$。\n3. 方伯伯接着决定他要看的最后一张牌应该是第 $r_i$ 张，其中 $r_i=\\bigl(\\mathrm{ans}_{i-1}+1+2^{\\lfloor n_i/2 \\rfloor}(l_i\\bmod 2^{\\lfloor n_i/2 \\rfloor})\\bigr)\\bmod 2^{n_i} \\mathrel{+}1$。\n4. 因为上面两个式子并不简单，有可能会产生 $l_i>r_i$ 的结果，此时将它们的值互换。\n5. 想好自己要看什么牌后，方伯伯就会以此决定自己要洗 $x_i$ 次牌，其中 $x_i=(r_i-l_i+t_{i-1}+i-1)\\bmod 2^{n_i}$。\n6. 方伯伯同时还会想好他要给每张牌要加上数字的是 $t_i$，其中 $t_i=(l_i+r_i)\\bmod 2^{n_i}$。\n7. 方伯伯洗完牌后，把其中从上往下数第 $l_i$ 到第 $r_i$ 张牌上的数字均加上数字 $t_i$，并依次（转换成二进制）异或之后得到一个异或值；方伯伯把第 $i$ 堆牌的这个异或值取模 $\\bmod 2^{n_i-1}$ 的值记作 $\\mathrm{ans}_i$，接着回到第一步玩下一个牌堆。\n\n方伯伯听说你有高超的信息学能力，他想知道你能否在他完成游戏前就算出最后一个牌堆，即第 $m-1$ 个牌堆，得到的游戏结果 $\\mathrm{ans}_{m-1}$。你能做到吗？", "inputFormat": "第一行包含一个整数 $m$，表示牌组的个数。\n\n\n接下来一行包含六个整数，分别为 $n_0, x_0 ,l_0 ,r_0, t_0 , \\mathrm{Base}$。", "outputFormat": "输出为一个数，表示最后的答案。", "hint": "## 数据范围\n\n对于 $10\\%$ 的数据，$m\\le 100$。           \n对于 $20\\%$ 的数据，$m\\le 5\\times 10^5$，$n_i\\le 20$，$ \\mathrm{Base}\\le 16$。  \n对于 $60\\%$ 的数据，$m\\le 5\\times 10^5$，$n_i\\le 60$，$\\mathrm{Base}\\le 55$。           \n对于所有数据，$m \\leq 5\\times 10^6,\\ n_i \\leq 60,\\ 0<l_i \\leq r_i \\leq 2^{n_i},\\ 0<x_i,t_i<10^9,\\ \\mathrm{Base} \\leq 55$。\n\n## 样例解释\n\n$ans_0=1$，$n_1=16$，$l_1=7$，$r_1=1795$，$x_1=1791$，$t_1=1802$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2014] Uncle Fang Plays Poker", "background": "", "description": "Uncle Fang has some blank playing cards. He wants to use them to play a math game.\n\nHe first decides to form $m$ piles from these blank cards, with the size of each pile being an integer power of $2$. Specifically, the $i$-th pile (note: indexed from $0$) will have $2^{n_i}$ cards. He first decides that pile $0$ has $2^{n_0}$ cards, and then labels the cards in this pile from top to bottom with the decimal numbers $1 \\sim 2^{n_0}$ in order.\n\nBefore starting the game, Uncle Fang decides to shuffle, and he decides to shuffle $x_0$ times. He has a fixed shuffling pattern: each shuffle is equivalent to the following two steps:\n1. Take out all cards in odd positions (counted from the top) in order to form a new pile.\n2. Place this new pile on top of the remaining old pile.\n\nFor example, when $n_0 = 3$, pile $0$ starts from top to bottom as ``12345678'', after one shuffle it becomes ``13572468'', and after two shuffles it becomes ``15263748''.\n\nAfter shuffling, Uncle Fang decides to add a number $t_0$ to the labels of the cards from the $l_0$-th to the $r_0$-th from top to bottom. He then converts these labels to binary and XORs them in order to obtain a value; he records the value modulo $2^{n_0-1}$ as $\\mathrm{ans}_0$.\n\nSimilarly, Uncle Fang will play with the remaining $m-1$ piles in the same way. Specifically, he decides to operate on each pile according to the following formulas:\n1. For the $i$-th pile, the pile will have $2^{n_i}$ cards, labeled from top to bottom with the decimal integers $1 \\sim 2^{n_i}$. Here,\n   $n_i = (\\mathrm{ans}_{i-1} + i - 1) \\bmod 5 \\mathrel{+} \\mathrm{Base}$, where $\\mathrm{Base}$ is a positive integer decided in advance.\n2. He first decides the position of the first card he will look at, denoted by $l_i$, where\n   $l_i = (2\\mathrm{ans}_{i-1} + l_{i-1} + i - 1) \\bmod 2^{n_i} \\mathrel{+} 1$.\n3. He then decides the position of the last card he will look at, denoted by $r_i$, where\n   $r_i = \\bigl(\\mathrm{ans}_{i-1} + 1 + 2^{\\lfloor n_i/2 \\rfloor}(l_i \\bmod 2^{\\lfloor n_i/2 \\rfloor})\\bigr) \\bmod 2^{n_i} \\mathrel{+} 1$.\n4. Since the above two formulas are not simple, it is possible that $l_i > r_i$. In that case, swap their values.\n5. After deciding which cards to look at, he decides to shuffle $x_i$ times, where\n   $x_i = (r_i - l_i + t_{i-1} + i - 1) \\bmod 2^{n_i}$.\n6. He also decides the number $t_i$ to add to each selected card, where\n   $t_i = (l_i + r_i) \\bmod 2^{n_i}$.\n7. After shuffling, he adds $t_i$ to each card from the $l_i$-th to the $r_i$-th from top to bottom, converts them to binary and XORs them in order to obtain a value; he records the value modulo $2^{n_i-1}$ as $\\mathrm{ans}_i$, and then returns to Step 1 to play with the next pile.\n\nUncle Fang has heard about your outstanding informatics skills. He wants to know whether you can compute in advance the game result $\\mathrm{ans}_{m-1}$ for the last pile, i.e., pile $m-1$. Can you do it?", "inputFormat": "The first line contains an integer $m$, the number of piles.\n\nThe next line contains six integers: $n_0, x_0, l_0, r_0, t_0, \\mathrm{Base}$.", "outputFormat": "Output a single integer, the final answer.", "hint": "Constraints\n- For $10\\%$ of the testdata, $m \\le 100$.\n- For $20\\%$ of the testdata, $m \\le 5\\times 10^5$, $n_i \\le 20$, $\\mathrm{Base} \\le 16$.\n- For $60\\%$ of the testdata, $m \\le 5\\times 10^5$, $n_i \\le 60$, $\\mathrm{Base} \\le 55$.\n- For all testdata, $m \\le 5\\times 10^6,\\ n_i \\le 60,\\ 0 < l_i \\le r_i \\le 2^{n_i},\\ 0 < x_i, t_i < 10^9,\\ \\mathrm{Base} \\le 55$.\n\nSample Explanation\n$\\mathrm{ans}_0 = 1$, $n_1 = 16$, $l_1 = 7$, $r_1 = 1795$, $x_1 = 1791$, $t_1 = 1802$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2014] 方伯伯打扑克", "background": null, "description": "方伯伯有一些空白的扑克牌。方伯伯想要用这些牌来玩一个数学游戏。\n\n方伯伯首先决定好他要用这些空白的扑克牌组成 $m$ 个牌堆，每一堆牌的张数都是 $2$ 的整数次幂。确切地说，第 $i$ 堆（**注意**：从 $0$ 开始计数）牌将会有 $2^{n_i}$ 张牌。方伯伯首先决定好第 $0$ 堆牌要有 $2^{n_0}$ 张牌，然后将这堆牌从上到下按次序标记 $1 \\sim 2^{n_0}$ 的十进制数字。\n\n方伯伯开始游戏前决定要先洗牌，他决定好要洗 $x_0$ 次牌。他洗牌有一个固定的模式，每次洗牌操作等同于以下两个步骤的操作：\n\n1. 将所有奇数位上的牌依次取出组成新的一堆牌。\n2. 将新的一堆牌放在旧有的牌前面。\n\n如当 $n_0=3$ 时，第 $0$ 堆牌从上到下一开始为 ``12345678``，洗一次牌得到 ``13572468``，洗两次牌得到 ``15263748``。\n\n洗完牌后，方伯伯在心中决定好把其中从上往下数第 $l_0$ 到第 $r_0$ 张牌上的数字均加上一个数字 $t_0$，并依次（转换成二进制）异或之后得到一个异或值；方伯伯把第 $0$ 堆牌的这个异或值取模 $\\bmod  \\ 2^{n_0-1}$ 的值记作 $\\mathrm{ans}_0$。\n\n类似地，方伯伯将按同样的方式用剩下的 $m-1$ 个牌堆。具体地说，他决定按照如下几个公式来对每一堆牌组进行游戏：\n1. 对于第 $i$ 堆牌，牌堆中将会有 $2^{n_i}$ 张牌，并从上到下标有 $1\\sim 2^{n_i}$ 的十进制整数。其中，$n_i=(\\mathrm{ans}_{i-1}+i-1) \\bmod 5 \\mathrel{+} \\mathrm{base}$， $\\mathrm{base}$ 是一个方伯伯事先决定好的正整数。\n2. 方伯伯将会先决定好自己用来游戏的牌处于牌堆中的什么位置。方伯伯首先决定好他要看的第一张牌应该是第 $l_i$ 张，其中 $l_i=(2\\mathrm{ans}_{i-1}+l_{i-1}+i-1)\\bmod 2^{n_i} \\mathrel{+} 1$。\n3. 方伯伯接着决定他要看的最后一张牌应该是第 $r_i$ 张，其中 $r_i=\\bigl(\\mathrm{ans}_{i-1}+1+2^{\\lfloor n_i/2 \\rfloor}(l_i\\bmod 2^{\\lfloor n_i/2 \\rfloor})\\bigr)\\bmod 2^{n_i} \\mathrel{+}1$。\n4. 因为上面两个式子并不简单，有可能会产生 $l_i>r_i$ 的结果，此时将它们的值互换。\n5. 想好自己要看什么牌后，方伯伯就会以此决定自己要洗 $x_i$ 次牌，其中 $x_i=(r_i-l_i+t_{i-1}+i-1)\\bmod 2^{n_i}$。\n6. 方伯伯同时还会想好他要给每张牌要加上数字的是 $t_i$，其中 $t_i=(l_i+r_i)\\bmod 2^{n_i}$。\n7. 方伯伯洗完牌后，把其中从上往下数第 $l_i$ 到第 $r_i$ 张牌上的数字均加上数字 $t_i$，并依次（转换成二进制）异或之后得到一个异或值；方伯伯把第 $i$ 堆牌的这个异或值取模 $\\bmod 2^{n_i-1}$ 的值记作 $\\mathrm{ans}_i$，接着回到第一步玩下一个牌堆。\n\n方伯伯听说你有高超的信息学能力，他想知道你能否在他完成游戏前就算出最后一个牌堆，即第 $m-1$ 个牌堆，得到的游戏结果 $\\mathrm{ans}_{m-1}$。你能做到吗？", "inputFormat": "第一行包含一个整数 $m$，表示牌组的个数。\n\n\n接下来一行包含六个整数，分别为 $n_0, x_0 ,l_0 ,r_0, t_0 , \\mathrm{Base}$。", "outputFormat": "输出为一个数，表示最后的答案。", "hint": "## 数据范围\n\n对于 $10\\%$ 的数据，$m\\le 100$。           \n对于 $20\\%$ 的数据，$m\\le 5\\times 10^5$，$n_i\\le 20$，$ \\mathrm{Base}\\le 16$。  \n对于 $60\\%$ 的数据，$m\\le 5\\times 10^5$，$n_i\\le 60$，$\\mathrm{Base}\\le 55$。           \n对于所有数据，$m \\leq 5\\times 10^6,\\ n_i \\leq 60,\\ 0<l_i \\leq r_i \\leq 2^{n_i},\\ 0<x_i,t_i<10^9,\\ \\mathrm{Base} \\leq 55$。\n\n## 样例解释\n\n$ans_0=1$，$n_1=16$，$l_1=7$，$r_1=1795$，$x_1=1791$，$t_1=1802$。", "locale": "zh-CN"}}}
{"pid": "P3285", "type": "P", "difficulty": 6, "samples": [["10 10\n1 2 11\n3 13\n2 5\n3 7\n2 8\n2 10\n2 11\n3 14\n2 18\n4 9", "2\n2\n2\n4\n3\n5\n5\n7\n8\n11"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2014", "四川", "线段树", "各省省选", "平衡树"], "title": "[SCOI2014] 方伯伯的OJ", "background": "", "description": "方伯伯正在做他的 OJ。现在他在处理 OJ 上的用户排名问题。OJ 上注册了 $n$ 个用户，编号为 $1\\sim n$，一开始他们按照编号排名。\n\n方伯伯会按照心情对这些用户做以下四种操作，修改用户的排名和编号：\n\n1. 操作格式为 $1\\ \\ x\\ \\ y$，意味着将编号为 $x$ 的用户编号改为 $y$，而排名不变，执行完该操作后需要输出该用户在队列中的位置，数据保证 $x$ 必然出现在队列中，同时，$y$ 是一个当前不在排名中的编号。\n2. 操作格式为 $2\\ \\ x$，意味着将编号为 $x$ 的用户的排名提升到第一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。\n3. 操作格式为 $3\\ \\ x$，意味着将编号为 $x$ 的用户的排名降到最后一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。\n4. 操作格式为 $4\\ \\ k$，意味着查询当前排名为 $k$ 的用户编号，执行完该操作后需要输出当前操作用户的编号。\n\n但同时为了防止别人监听自己的工作，方伯伯对他的操作进行了加密，即将四种操作的格式分别改为了：\n\n- $1\\ \\ x+a\\ \\ y+a$；\n- $2\\ \\ x+a$；\n- $3\\ \\ x+a$；\n- $4\\ \\ k+a$；\n- 其中 $a$ 为上一次操作得到的输出，一开始 $a=0$。\n\n例如：上一次操作得到的输出是 $5$，这一次操作的输入为：$1\\ \\ 13\\ \\ 15$ 因为这个输入是经过加密后的，所以你应该处理的操作是 $1\\ \\ 8\\ \\ 10$。\n\n现在你截获了方伯伯的所有操作，希望你能给出结果。", "inputFormat": "输入的第 $1$ 行包含 $2$ 个用空格分隔的整数 $n$ 和 $m$，表示初始用户数和操作数。此后有 $m$ 行，每行是一个询问，询问格式如上所示。", "outputFormat": "输出包含 $m$ 行。每行包含一个整数，其中第 $i$ 行的整数表示第 $i$ 个操作的输出。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 10^8$，$1 \\le m \\le 10^5$。\n\n输入保证对于所有的操作 $1,2,3$，$x$ 必然已经出现在队列中，同时对于所有操作 $1$，$1 \\le y \\le 2\\times 10^8$，并且 $y$ 没有出现在队列中。\n\n对于所有操作 $4$，保证 $1 \\le k \\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2014] Uncle Fang's OJ", "background": "", "description": "Uncle Fang is building his OJ. Now he is handling the user ranking problem on the OJ. There are $n$ registered users on the OJ, numbered $1\\sim n$, and initially they are ranked in ascending order of their IDs.\n\nDepending on his mood, Uncle Fang performs the following four operations to modify users’ ranks and IDs:\n\n1. Operation format $1\\ \\ x\\ \\ y$ means: change the user whose ID is $x$ to have ID $y$, while keeping their rank unchanged. After this operation, output that user’s position in the queue. It is guaranteed that $x$ appears in the queue, and $y$ is an ID not currently present in the ranking.\n2. Operation format $2\\ \\ x$ means: move the user whose ID is $x$ to the first position. After this operation, output the rank of user $x$ before the move.\n3. Operation format $3\\ \\ x$ means: move the user whose ID is $x$ to the last position. After this operation, output the rank of user $x$ before the move.\n4. Operation format $4\\ \\ k$ means: query the ID of the user whose current rank is $k$. After this operation, output that user’s ID.\n\nTo prevent others from snooping on his work, Uncle Fang encrypts his operations by changing the four formats to:\n\n- $1\\ \\ x+a\\ \\ y+a$；\n- $2\\ \\ x+a$；\n- $3\\ \\ x+a$；\n- $4\\ \\ k+a$；\n- where $a$ is the output of the previous operation, and initially $a=0$.\n\nExample: if the previous operation’s output is $5$, and this operation’s input is $1\\ \\ 13\\ \\ 15$, since the input is encrypted, the operation you should process is $1\\ \\ 8\\ \\ 10$.\n\nYou have intercepted all of Uncle Fang’s operations. Please produce the results.", "inputFormat": "The first line contains two integers $n$ and $m$, representing the initial number of users and the number of operations. Then follow $m$ lines, each containing one query in the formats described above.", "outputFormat": "Output $m$ lines. The integer on the $i$-th line is the output of the $i$-th operation.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 10^8$, $1 \\le m \\le 10^5$.\n\nIt is guaranteed that for all operations $1,2,3$, $x$ already appears in the queue. For all operations $1$, $1 \\le y \\le 2\\times 10^8$, and $y$ does not appear in the queue.\n\nFor all operations $4$, it is guaranteed that $1 \\le k \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2014] 方伯伯的OJ", "background": "", "description": "方伯伯正在做他的 OJ。现在他在处理 OJ 上的用户排名问题。OJ 上注册了 $n$ 个用户，编号为 $1\\sim n$，一开始他们按照编号排名。\n\n方伯伯会按照心情对这些用户做以下四种操作，修改用户的排名和编号：\n\n1. 操作格式为 $1\\ \\ x\\ \\ y$，意味着将编号为 $x$ 的用户编号改为 $y$，而排名不变，执行完该操作后需要输出该用户在队列中的位置，数据保证 $x$ 必然出现在队列中，同时，$y$ 是一个当前不在排名中的编号。\n2. 操作格式为 $2\\ \\ x$，意味着将编号为 $x$ 的用户的排名提升到第一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。\n3. 操作格式为 $3\\ \\ x$，意味着将编号为 $x$ 的用户的排名降到最后一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。\n4. 操作格式为 $4\\ \\ k$，意味着查询当前排名为 $k$ 的用户编号，执行完该操作后需要输出当前操作用户的编号。\n\n但同时为了防止别人监听自己的工作，方伯伯对他的操作进行了加密，即将四种操作的格式分别改为了：\n\n- $1\\ \\ x+a\\ \\ y+a$；\n- $2\\ \\ x+a$；\n- $3\\ \\ x+a$；\n- $4\\ \\ k+a$；\n- 其中 $a$ 为上一次操作得到的输出，一开始 $a=0$。\n\n例如：上一次操作得到的输出是 $5$，这一次操作的输入为：$1\\ \\ 13\\ \\ 15$ 因为这个输入是经过加密后的，所以你应该处理的操作是 $1\\ \\ 8\\ \\ 10$。\n\n现在你截获了方伯伯的所有操作，希望你能给出结果。", "inputFormat": "输入的第 $1$ 行包含 $2$ 个用空格分隔的整数 $n$ 和 $m$，表示初始用户数和操作数。此后有 $m$ 行，每行是一个询问，询问格式如上所示。", "outputFormat": "输出包含 $m$ 行。每行包含一个整数，其中第 $i$ 行的整数表示第 $i$ 个操作的输出。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 10^8$，$1 \\le m \\le 10^5$。\n\n输入保证对于所有的操作 $1,2,3$，$x$ 必然已经出现在队列中，同时对于所有操作 $1$，$1 \\le y \\le 2\\times 10^8$，并且 $y$ 没有出现在队列中。\n\n对于所有操作 $4$，保证 $1 \\le k \\le n$。", "locale": "zh-CN"}}}
{"pid": "P3286", "type": "P", "difficulty": 6, "samples": [["3 8 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2014", "四川", "各省省选", "O2优化", "枚举", "数位 DP"], "title": "[SCOI2014] 方伯伯的商场之旅", "background": "", "description": "方伯伯有一天去参加一个商场举办的游戏。商场派了一些工作人员排成一行。每个人面前有几堆石子。\n\n说来也巧，位置在 $i$ 的人面前的第 $j$ 堆的石子的数量，刚好是 $i$ 写成 $K$ 进制后的第 $j$ 位。现在方伯伯要玩一个游戏，商场会给方伯伯两个整数 $L,R$。\n\n方伯伯要把位置在 $[L, R]$ 中的每个人的石子都合并成一堆石子。每次操作，他可以选择一个人面前的两堆石子，将其中的一堆中的某些石子移动到另一堆，代价是移动的石子数量 $\\times$ 移动的距离。\n\n商场承诺，方伯伯只要完成任务，就给他一些椰子，代价越小，给他的椰子越多。所以方伯伯很着急，想请你告诉他最少的代价是多少。例如：$10$ 进制下的位置在 $12312$ 的人，合并石子的最少代价为：$1 \\times 2 + 2 \\times 1 + 3 \\times 0 + 1 \\times1 + 2 \\times 2 = 9$即把所有的石子都合并在第三堆。\n", "inputFormat": "输入仅有 $1$ 行，包含 $3$ 个用空格分隔的整数 $L,R,K$，表示商场给方伯伯的 $2$ 个整数，以及进制数。", "outputFormat": "输出仅有 $1$ 行，包含 $1$ 个整数，表示最少的代价。", "hint": "对于 $100\\%$ 的数据，$1 \\le L \\le R \\le 10^{15}, 2 \\le K \\le 20$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2014] Uncle Fang's Trip to the Mall", "background": "", "description": "One day, Uncle Fang went to a game hosted by a mall. The mall arranged some staff members in a line. In front of each person, there are several piles of stones.\n\nBy coincidence, for the person at position $i$, the number of stones in the $j$-th pile is exactly the $j$-th digit of $i$ when written in base $K$. Now Uncle Fang is going to play a game: the mall will give him two integers $L, R$.\n\nUncle Fang needs to merge all the piles in front of each person whose position is in $[L, R]$ into a single pile. In each operation, he may choose two piles in front of one person and move some stones from one pile to the other. The cost is equal to (the number of stones moved) $\\times$ (the distance moved).\n\nThe mall promises that as long as Uncle Fang completes the task, they will give him some coconuts; the smaller the cost, the more coconuts he will receive. So he is anxious and asks you to tell him the minimum cost. For example, for the person at position $12312$ in base $10$, the minimum cost to merge the stones is $1 \\times 2 + 2 \\times 1 + 3 \\times 0 + 1 \\times 1 + 2 \\times 2 = 9$, that is, merge all stones into the third pile.", "inputFormat": "The input consists of only $1$ line containing $3$ space-separated integers $L, R, K$, representing the two integers given by the mall and the base.", "outputFormat": "Output only $1$ line containing $1$ integer, the minimum cost.", "hint": "For $100\\%$ of the testdata, $1 \\le L \\le R \\le 10^{15}$, $2 \\le K \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2014] 方伯伯的商场之旅", "background": "", "description": "方伯伯有一天去参加一个商场举办的游戏。商场派了一些工作人员排成一行。每个人面前有几堆石子。\n\n说来也巧，位置在 $i$ 的人面前的第 $j$ 堆的石子的数量，刚好是 $i$ 写成 $K$ 进制后的第 $j$ 位。现在方伯伯要玩一个游戏，商场会给方伯伯两个整数 $L,R$。\n\n方伯伯要把位置在 $[L, R]$ 中的每个人的石子都合并成一堆石子。每次操作，他可以选择一个人面前的两堆石子，将其中的一堆中的某些石子移动到另一堆，代价是移动的石子数量 $\\times$ 移动的距离。\n\n商场承诺，方伯伯只要完成任务，就给他一些椰子，代价越小，给他的椰子越多。所以方伯伯很着急，想请你告诉他最少的代价是多少。例如：$10$ 进制下的位置在 $12312$ 的人，合并石子的最少代价为：$1 \\times 2 + 2 \\times 1 + 3 \\times 0 + 1 \\times1 + 2 \\times 2 = 9$即把所有的石子都合并在第三堆。\n", "inputFormat": "输入仅有 $1$ 行，包含 $3$ 个用空格分隔的整数 $L,R,K$，表示商场给方伯伯的 $2$ 个整数，以及进制数。", "outputFormat": "输出仅有 $1$ 行，包含 $1$ 个整数，表示最少的代价。", "hint": "对于 $100\\%$ 的数据，$1 \\le L \\le R \\le 10^{15}, 2 \\le K \\le 20$。", "locale": "zh-CN"}}}
{"pid": "P3287", "type": "P", "difficulty": 6, "samples": [["3 1\n2 1 3", "3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2014", "四川", "各省省选", "树状数组", "O2优化"], "title": "[SCOI2014] 方伯伯的玉米田", "background": "", "description": "方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。这排玉米一共有 $N$ 株，它们的高度参差不齐。方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。方伯伯可以选择一个区间，把这个区间的玉米全部拔高 $1$ 单位高度，他可以进行最多 $K$ 次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。问能最多剩多少株玉米，来构成一排美丽的玉米。", "inputFormat": "第一行包含两个整数 $n, K$，分别表示这排玉米的数目以及最多可进行多少次操作。第二行包含 $n$ 个整数，第 $i$ 个数表示这排玉米，从左到右第 $i$ 株玉米的高度 $a_i$。", "outputFormat": "输出一个整数，最多剩下的玉米数。\n", "hint": "$100\\%$ 的数据满足：$2 \\le N \\lt 10^4 $，$2 \\le K \\le 500$，$1 \\leq a_i \\leq 5000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2014] Uncle Fang's Cornfield", "background": "", "description": "While walking along the edge of his farmland, Uncle Fang suddenly noticed that one row of corn looked very unattractive. There are $N$ stalks in this row, and their heights vary. Uncle Fang thinks a non-decreasing sequence is beautiful, so he decides to first raise some stalks and then pull out any stalks that spoil the beauty, so that the heights of the remaining stalks form a non-decreasing sequence. He may choose an interval and increase every stalk in that interval by 1 unit of height; he may perform at most $K$ such operations. He may also freely choose any set of stalks to remove. What is the maximum number of stalks that can remain to form a beautiful row?", "inputFormat": "The first line contains two integers $n$, $K$, denoting the number of stalks in this row and the maximum number of operations allowed, respectively. The second line contains $n$ integers; the $i$-th number is the height $a_i$ of the $i$-th stalk from left to right.", "outputFormat": "Output a single integer, the maximum number of remaining stalks.", "hint": "Constraints: $100\\%$ of the testdata satisfies: $2 \\le N \\lt 10^4 $, $2 \\le K \\le 500$, $1 \\leq a_i \\leq 5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2014] 方伯伯的玉米田", "background": "", "description": "方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。这排玉米一共有 $N$ 株，它们的高度参差不齐。方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。方伯伯可以选择一个区间，把这个区间的玉米全部拔高 $1$ 单位高度，他可以进行最多 $K$ 次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。问能最多剩多少株玉米，来构成一排美丽的玉米。", "inputFormat": "第一行包含两个整数 $n, K$，分别表示这排玉米的数目以及最多可进行多少次操作。第二行包含 $n$ 个整数，第 $i$ 个数表示这排玉米，从左到右第 $i$ 株玉米的高度 $a_i$。", "outputFormat": "输出一个整数，最多剩下的玉米数。\n", "hint": "$100\\%$ 的数据满足：$2 \\le N \\lt 10^4 $，$2 \\le K \\le 500$，$1 \\leq a_i \\leq 5000$。", "locale": "zh-CN"}}}
{"pid": "P3288", "type": "P", "difficulty": 6, "samples": [["5 10\n1 5 13 13 0 412\n2 5 30 18 396 148\n1 5 33 31 0 39\n4 5 22 4 0 786\n4 5 13 32 0 561\n4 5 3 48 0 460\n2 5 32 47 604 258\n5 7 44 37 75 164\n5 7 34 50 925 441\n6 2 26 38 1000 22", "103.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "四川", "各省省选", "网络流", "负权环", "分数规划"], "title": "[SCOI2014] 方伯伯运椰子", "background": null, "description": "四川的方伯伯为了致富，决定引进海南的椰子树。方伯伯的椰子园十分现代化，椰子园中有一套独特的交通系统。\n\n现在用点来表示交通节点，边来表示道路。这样，方伯伯的椰子园就可以看作一个有 $N + 2$ 个交通节点，$M$ 条边的有向无环图。$N + 1$ 号点为入口，$N + 2$ 号点为出口。每条道路都有 $6$ 个参数，$u_i,v_i,a_i,b_i,c_i,d_i$，分别表示该道路从 $u_i$ 号点通向 $v_i$ 号点，将它的容量压缩一次要 $a_i$ 的花费，容量扩大一次要 $b_i$ 的花费，该条道路当前的运输容量上限为 $c_i$，并且每单位运输量通过该道路要 $d_i$ 的费用。\n\n在这个交通网络中，只有一条道路与起点相连。因为弄坏了这条道路就会导致整个交通网络瘫痪，聪明的方伯伯决定绝不对这条道路进行调整，也就是说，现在除了这条道路之外，对其余道路都可以进行调整。\n\n有两种调整方式：\n\n- 选择一条道路，将其进行一次压缩，这条道路的容量会下降 $1$ 单位。\n\n- 选择一条道路，将其进行一次扩容，这条道路的容量会上升 $1$ 单位。\n\n一条道路可以被多次调整。\n\n由于很久以前，方伯伯就请过一个工程师，对这个交通网络进行过一次大的优化调整。所以现在所有的道路都被完全地利用起来了，即每条道路的负荷都是满的（每条道路的流量等于其容量）。\n\n但方伯伯一想到自己的海南椰子会大丰收，就十分担心巨大的运输量下，会导致过多的花费。因此，方伯伯决定至少进行一次调整，调整之后，必须要保持每条道路满负荷，且总交通量不会减少。\n\n设调整后的总费用是 $Y$，调整之前的总费用是 $X$。现在方伯伯想知道，最优调整比率是多少，即假设他进行了  $k$ 次调整，$\\dfrac{X - Y}{k}$ 最大能是多少？\n\n注：总费用 $=$ 交通网络的运输花费 $+$ 调整的花费。", "inputFormat": "第一行包含二个整数 $N, M$。接下来 $M$ 行代表 $M$ 条边，表示这个交通网络，每行六个整数，表示 $u_i,v_i,a_i,b_i,c_i,d_i$。", "outputFormat": "一个浮点数，保留二位小数，表示答案。数据保证答案大于 $0$。", "hint": "对于所有数据，$1 \\le N \\le 5 \\times 10^3$，$1 \\le M \\le 3 \\times 10^3$，$1 \\le u_i, v_i \\le N + 2$，$0 \\le a_i, b_i \\le 500$，$0 \\le c_i \\le 10^4$，$0 \\le d_i \\le 10^3$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2014] Uncle Fang Transports Coconuts", "background": "", "description": "To get rich, Uncle Fang from Sichuan decides to introduce coconut trees from Hainan. His coconut plantation is highly modernized, with a unique transportation system inside.\n\nWe model transportation junctions as nodes and roads as edges. Thus, the plantation can be seen as a directed acyclic graph (DAG) with $N + 2$ transportation nodes and $M$ edges. Node $N + 1$ is the entrance (source), and node $N + 2$ is the exit (sink). Each road has six parameters $u_i, v_i, a_i, b_i, c_i, d_i$, meaning the road goes from node $u_i$ to node $v_i$; compressing its capacity by $1$ unit costs $a_i$; expanding its capacity by $1$ unit costs $b_i$; its current capacity upper bound is $c_i$; and transporting each unit of flow along this road costs $d_i$.\n\nIn this transportation network, there is exactly one edge outgoing from the source. Since damaging this road would paralyze the entire network, the clever Uncle Fang decides never to adjust this road. That is, all other roads can be adjusted.\n\nThere are two types of adjustments:\n- Choose a road and compress it once; the capacity of this road decreases by $1$ unit.\n- Choose a road and expand it once; the capacity of this road increases by $1$ unit.\n\nA road can be adjusted multiple times.\n\nA long time ago, Uncle Fang hired an engineer to optimize this transportation network. So now every road is fully utilized, i.e., the load on each road is at its limit (the flow on each road equals its capacity).\n\nHowever, thinking of the upcoming bumper harvest of Hainan coconuts, Uncle Fang worries that the huge transportation volume will cause excessive costs. Therefore, he decides to perform at least one adjustment. After the adjustments, every road must remain fully utilized, and the total throughput must not decrease.\n\nLet the total cost after adjustments be $Y$, and the total cost before adjustments be $X$. Uncle Fang wants to know the optimal adjustment ratio, i.e., if he performs $k$ adjustments in total, what is the maximum possible value of $\\dfrac{X - Y}{k}$?\n\nNote: total cost $=$ transportation cost $+$ adjustment cost.", "inputFormat": "The first line contains two integers $N, M$. The next $M$ lines describe the $M$ edges of the transportation network. Each line contains six integers $u_i, v_i, a_i, b_i, c_i, d_i$.", "outputFormat": "Output a floating-point number with two decimal places, representing the answer. The testdata guarantees the answer is greater than $0$.", "hint": "Constraints:\nFor all testdata, $1 \\le N \\le 5 \\times 10^3$, $1 \\le M \\le 3 \\times 10^3$, $1 \\le u_i, v_i \\le N + 2$, $0 \\le a_i, b_i \\le 500$, $0 \\le c_i \\le 10^4$, $0 \\le d_i \\le 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2014] 方伯伯运椰子", "background": null, "description": "四川的方伯伯为了致富，决定引进海南的椰子树。方伯伯的椰子园十分现代化，椰子园中有一套独特的交通系统。\n\n现在用点来表示交通节点，边来表示道路。这样，方伯伯的椰子园就可以看作一个有 $N + 2$ 个交通节点，$M$ 条边的有向无环图。$N + 1$ 号点为入口，$N + 2$ 号点为出口。每条道路都有 $6$ 个参数，$u_i,v_i,a_i,b_i,c_i,d_i$，分别表示该道路从 $u_i$ 号点通向 $v_i$ 号点，将它的容量压缩一次要 $a_i$ 的花费，容量扩大一次要 $b_i$ 的花费，该条道路当前的运输容量上限为 $c_i$，并且每单位运输量通过该道路要 $d_i$ 的费用。\n\n在这个交通网络中，只有一条道路与起点相连。因为弄坏了这条道路就会导致整个交通网络瘫痪，聪明的方伯伯决定绝不对这条道路进行调整，也就是说，现在除了这条道路之外，对其余道路都可以进行调整。\n\n有两种调整方式：\n\n- 选择一条道路，将其进行一次压缩，这条道路的容量会下降 $1$ 单位。\n\n- 选择一条道路，将其进行一次扩容，这条道路的容量会上升 $1$ 单位。\n\n一条道路可以被多次调整。\n\n由于很久以前，方伯伯就请过一个工程师，对这个交通网络进行过一次大的优化调整。所以现在所有的道路都被完全地利用起来了，即每条道路的负荷都是满的（每条道路的流量等于其容量）。\n\n但方伯伯一想到自己的海南椰子会大丰收，就十分担心巨大的运输量下，会导致过多的花费。因此，方伯伯决定至少进行一次调整，调整之后，必须要保持每条道路满负荷，且总交通量不会减少。\n\n设调整后的总费用是 $Y$，调整之前的总费用是 $X$。现在方伯伯想知道，最优调整比率是多少，即假设他进行了  $k$ 次调整，$\\dfrac{X - Y}{k}$ 最大能是多少？\n\n注：总费用 $=$ 交通网络的运输花费 $+$ 调整的花费。", "inputFormat": "第一行包含二个整数 $N, M$。接下来 $M$ 行代表 $M$ 条边，表示这个交通网络，每行六个整数，表示 $u_i,v_i,a_i,b_i,c_i,d_i$。", "outputFormat": "一个浮点数，保留二位小数，表示答案。数据保证答案大于 $0$。", "hint": "对于所有数据，$1 \\le N \\le 5 \\times 10^3$，$1 \\le M \\le 3 \\times 10^3$，$1 \\le u_i, v_i \\le N + 2$，$0 \\le a_i, b_i \\le 500$，$0 \\le c_i \\le 10^4$，$0 \\le d_i \\le 10^3$。", "locale": "zh-CN"}}}
{"pid": "P3289", "type": "P", "difficulty": 7, "samples": [["3\n3 4\n1 1\n5 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "四川", "各省省选"], "title": "[SCOI2014] 舌尖上的方伯伯", "background": "", "description": "方伯伯为了吃到最传统最纯净的美食，决定亲自开垦一片菜园。现有一片空地，方伯伯已经规划n个地点准备种上蔬菜。\n\n最新鲜的蔬菜需有最甘甜井水的灌溉，因此方伯伯将要打出两口井，分别记为井A、井B。现在问题来了，在何处打井？每颗蔬菜分别由哪口井来灌溉？方伯伯不善于计算，于是提出以下几个原则，再根据这些原则找方案。原则如下：\n\n1.井必须打在它负责灌溉的蔬菜的正中心，即设它的坐标为(X,Y)，X(Y)为它负责灌溉的所有蔬菜的横(纵)坐标之和的平均值。\n\n2.所有蔬菜都需要被灌溉。3.两口井都必须要灌溉至少一颗蔬菜。4.到A井更近的蔬菜，必须由A井灌溉，到B井更近的蔬菜，必须由B井灌溉。距离相等相等时则可任意一口井灌溉。\n\n当然两口井不能打到同一个位置，多株蔬菜当然也不会种在同一个位置。\n\n方伯伯把他的开垦原则告诉了你，请你告诉他有多少种满足这些原则方案。我们把灌溉1号蔬菜的井记为A号井，那么，只要A灌溉的蔬菜的集合不同，就是一种不同的方案。\n", "inputFormat": "输入1行包含1个整数n，代表方师傅的蔬菜的数目接下来n行，每行包含2个整数，xi，yi，代表第i棵蔬菜的坐标。\n", "outputFormat": "输出包含1个整数，代表方师傅可行的方案数\n", "hint": "1<=n<=60，0<=xi,yi<=60\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2014] Uncle Fang on the Tip of the Tongue", "background": "", "description": "To enjoy the most traditional and pure cuisine, Uncle Fang decides to cultivate a vegetable garden. There is a piece of open land with $n$ planned spots where he intends to plant vegetables.\n\nThe freshest vegetables must be irrigated with the sweetest well water, so Uncle Fang will dig two wells, called well A and well B. The questions are: where to dig the wells, and which vegetables should each well irrigate? Since Uncle Fang is not good at calculations, he proposes the following principles and asks you to find all schemes that satisfy them:\n\n1. Each well must be placed at the centroid of the vegetables it irrigates. That is, if a well’s coordinates are $(X, Y)$, then $X$ (respectively $Y$) equals the average of the $x$ (respectively $y$) coordinates of all vegetables it irrigates.\n2. All vegetables must be irrigated.\n3. Each of the two wells must irrigate at least one vegetable.\n4. Any vegetable that is closer to well A must be irrigated by well A; any vegetable that is closer to well B must be irrigated by well B. When the distances are equal, either well may irrigate that vegetable.\n\nOf course, the two wells cannot be at the same position, and no two vegetables are planted at the same position.\n\nWe define the well that irrigates vegetable $1$ as well A. Two schemes are considered different if and only if the set of vegetables irrigated by well A is different.", "inputFormat": "The first line contains an integer $n$, the number of vegetables.  \nThe next $n$ lines each contain two integers $x_i$, $y_i$, representing the coordinates of the $i$-th vegetable.", "outputFormat": "Output a single integer: the number of feasible schemes.", "hint": "Constraints: $1 \\le n \\le 60$, $0 \\le x_i, y_i \\le 60$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2014] 舌尖上的方伯伯", "background": "", "description": "方伯伯为了吃到最传统最纯净的美食，决定亲自开垦一片菜园。现有一片空地，方伯伯已经规划n个地点准备种上蔬菜。\n\n最新鲜的蔬菜需有最甘甜井水的灌溉，因此方伯伯将要打出两口井，分别记为井A、井B。现在问题来了，在何处打井？每颗蔬菜分别由哪口井来灌溉？方伯伯不善于计算，于是提出以下几个原则，再根据这些原则找方案。原则如下：\n\n1.井必须打在它负责灌溉的蔬菜的正中心，即设它的坐标为(X,Y)，X(Y)为它负责灌溉的所有蔬菜的横(纵)坐标之和的平均值。\n\n2.所有蔬菜都需要被灌溉。3.两口井都必须要灌溉至少一颗蔬菜。4.到A井更近的蔬菜，必须由A井灌溉，到B井更近的蔬菜，必须由B井灌溉。距离相等相等时则可任意一口井灌溉。\n\n当然两口井不能打到同一个位置，多株蔬菜当然也不会种在同一个位置。\n\n方伯伯把他的开垦原则告诉了你，请你告诉他有多少种满足这些原则方案。我们把灌溉1号蔬菜的井记为A号井，那么，只要A灌溉的蔬菜的集合不同，就是一种不同的方案。\n", "inputFormat": "输入1行包含1个整数n，代表方师傅的蔬菜的数目接下来n行，每行包含2个整数，xi，yi，代表第i棵蔬菜的坐标。\n", "outputFormat": "输出包含1个整数，代表方师傅可行的方案数\n", "hint": "1<=n<=60，0<=xi,yi<=60\n", "locale": "zh-CN"}}}
{"pid": "P3290", "type": "P", "difficulty": 7, "samples": [["3 1 1 2\nB\nW\nB\nB", "6\n5"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2016", "四川", "各省省选", "KMP 算法"], "title": "[SCOI2016] 围棋", "background": "", "description": "近日，谷歌研发的围棋 AI——AlphaGo 以 $4:1$ 的比分战胜了曾经的世界冠军李世石，这是人工智能领域的又一里程碑。\n\n与传统的搜索式 AI 不同，AlphaGo 使用了最近十分流行的卷积神经网络模型。在卷积神经网络模型中，棋盘上每一块特定大小的区域都被当做一个窗口。例如棋盘的大小为 $5\\times 6$，窗口大小为 $2\\times 4$，那么棋盘中共有 $12$ 个窗口。此外，模型中预先设定了一些模板，模板的大小与窗口的大小是一样的。\n\n下图展现了一个 $5\\times 6$ 的棋盘和两个 $2\\times 4$ 的模板：\n\n![](https://i.loli.net/2020/03/05/24yfVvrmNScWF5g.jpg)\n\n对于一个模板，只要棋盘中有某个窗口与其完全匹配，我们称这个模板是被激活的，否则称这个模板没有被激活。\n\n例如图中第一个模板就是被激活的，而第二个模板就是没有被激活的。我们要研究的问题是：对于给定的模板，有多少个棋盘可以激活它。\n\n为了简化问题，我们抛开所有围棋的基本规则，只考虑一个 $n\\times m$ 的棋盘，每个位置只能是黑子、白子或无子三种情况，换句话说，这样的棋盘共有 $3^{n\\times m}$ 种。此外，我们会给出 $q$ 个 $2\\times c$ 的模板。\n\n我们希望知道，对于每个模板，有多少种棋盘可以激活它。强调：模板一定是两行的。\n", "inputFormat": "输入数据的第一行包含四个正整数 $n,m,c$ 和 $q$，分别表示棋盘的行数、列数、模板的列数和模板的数量。\n\n随后 $2\\times q$ 行，每连续两行描述一个模板。其中，每行包含 $c$ 个字符，字符一定是 ```W```，```B``` 或 ```X``` 中的一个，表示白子、黑子或无子三种情况的一种。", "outputFormat": "输出应包含 $q$ 行，每行一个整数，表示符合要求的棋盘数量。由于答案可能很大，你只需要输出答案对 $10^9+7$ 取模后的结果即可。\n", "hint": "对于所有测试点：$1\\leq n\\leq 100$，$1\\leq m\\leq 12$，$1\\leq c\\leq 6$，$1\\leq q\\leq 5$。\n\n| 测试点编号 | 约定 |\n| :----------: | :----------: |\n| $1$ | $n=3$，$m=4$，$c=2$ |\n| $2$ | $n=4$，$m=4$，$c=3$ |\n| $3$ | $n=2$，$m=9$，$c=6$ |\n| $4$ | $n=2$，$m=12$，$c=3$ |\n| $5$ | $n=2$，$m=12$，$c=5$ |\n| $6$ | $n=10$，$m=8$，$c=3$ |\n| $7$ | $n=10$，$m=10$，$c=5$ |\n| $8$ | $n=100$，$m=10$，$c=5$ |\n| $9$ | $n=100$，$m=12$，$c=5$ |\n| $10$ | $n=100$，$m=12$，$c=6$ |", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2016] Go", "background": "", "description": "Recently, Google’s Go AI—AlphaGo—defeated the former world champion Lee Sedol by a score of $4:1$, which is another milestone in the field of artificial intelligence.\n\nUnlike traditional search-based AI, AlphaGo uses the now very popular convolutional neural network model. In a convolutional neural network, every region of a specific size on the board is treated as a window. For example, if the board size is $5\\times 6$ and the window size is $2\\times 4$, then there are $12$ windows on the board. In addition, the model has some predefined templates whose size is the same as the window size.\n\nThe following figure shows a $5\\times 6$ board and two $2\\times 4$ templates:\n\n![](https://i.loli.net/2020/03/05/24yfVvrmNScWF5g.jpg)\n\nFor a template, as long as there exists a window on the board that matches it exactly, we say the template is activated; otherwise, the template is not activated.\n\nFor example, in the figure the first template is activated, while the second one is not. The question we study is: for a given template, how many boards can activate it.\n\nTo simplify the problem, we disregard all basic rules of Go and consider only an $n\\times m$ board, where each position can only be one of three states: black stone, white stone, or empty. In other words, there are $3^{n\\times m}$ such boards in total. In addition, we will give $q$ templates of size $2\\times c$.\n\nWe want to know, for each template, how many boards can activate it. Emphasis: templates always have exactly two rows.", "inputFormat": "The first line of input contains four positive integers $n, m, c$ and $q$, representing the number of rows of the board, the number of columns of the board, the number of columns of the template, and the number of templates, respectively.\n\nThen $2\\times q$ lines follow; every consecutive two lines describe one template. Each line contains $c$ characters, and each character is one of ```W```, ```B``` or ```X```, representing white stone, black stone, or empty, respectively.", "outputFormat": "Output should contain $q$ lines, each with one integer, representing the number of boards that meet the requirement. Since the answer can be large, you only need to output the result modulo $10^9+7$.", "hint": "For all test points: $1\\leq n\\leq 100$, $1\\leq m\\leq 12$, $1\\leq c\\leq 6$, $1\\leq q\\leq 5$.\n\n| Test point ID | Settings |\n| :----------: | :----------: |\n| $1$ | $n=3$, $m=4$, $c=2$ |\n| $2$ | $n=4$, $m=4$, $c=3$ |\n| $3$ | $n=2$, $m=9$, $c=6$ |\n| $4$ | $n=2$, $m=12$, $c=3$ |\n| $5$ | $n=2$, $m=12$, $c=5$ |\n| $6$ | $n=10$, $m=8$, $c=3$ |\n| $7$ | $n=10$, $m=10$, $c=5$ |\n| $8$ | $n=100$, $m=10$, $c=5$ |\n| $9$ | $n=100$, $m=12$, $c=5$ |\n| $10$ | $n=100$, $m=12$, $c=6$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2016] 围棋", "background": "", "description": "近日，谷歌研发的围棋 AI——AlphaGo 以 $4:1$ 的比分战胜了曾经的世界冠军李世石，这是人工智能领域的又一里程碑。\n\n与传统的搜索式 AI 不同，AlphaGo 使用了最近十分流行的卷积神经网络模型。在卷积神经网络模型中，棋盘上每一块特定大小的区域都被当做一个窗口。例如棋盘的大小为 $5\\times 6$，窗口大小为 $2\\times 4$，那么棋盘中共有 $12$ 个窗口。此外，模型中预先设定了一些模板，模板的大小与窗口的大小是一样的。\n\n下图展现了一个 $5\\times 6$ 的棋盘和两个 $2\\times 4$ 的模板：\n\n![](https://i.loli.net/2020/03/05/24yfVvrmNScWF5g.jpg)\n\n对于一个模板，只要棋盘中有某个窗口与其完全匹配，我们称这个模板是被激活的，否则称这个模板没有被激活。\n\n例如图中第一个模板就是被激活的，而第二个模板就是没有被激活的。我们要研究的问题是：对于给定的模板，有多少个棋盘可以激活它。\n\n为了简化问题，我们抛开所有围棋的基本规则，只考虑一个 $n\\times m$ 的棋盘，每个位置只能是黑子、白子或无子三种情况，换句话说，这样的棋盘共有 $3^{n\\times m}$ 种。此外，我们会给出 $q$ 个 $2\\times c$ 的模板。\n\n我们希望知道，对于每个模板，有多少种棋盘可以激活它。强调：模板一定是两行的。\n", "inputFormat": "输入数据的第一行包含四个正整数 $n,m,c$ 和 $q$，分别表示棋盘的行数、列数、模板的列数和模板的数量。\n\n随后 $2\\times q$ 行，每连续两行描述一个模板。其中，每行包含 $c$ 个字符，字符一定是 ```W```，```B``` 或 ```X``` 中的一个，表示白子、黑子或无子三种情况的一种。", "outputFormat": "输出应包含 $q$ 行，每行一个整数，表示符合要求的棋盘数量。由于答案可能很大，你只需要输出答案对 $10^9+7$ 取模后的结果即可。\n", "hint": "对于所有测试点：$1\\leq n\\leq 100$，$1\\leq m\\leq 12$，$1\\leq c\\leq 6$，$1\\leq q\\leq 5$。\n\n| 测试点编号 | 约定 |\n| :----------: | :----------: |\n| $1$ | $n=3$，$m=4$，$c=2$ |\n| $2$ | $n=4$，$m=4$，$c=3$ |\n| $3$ | $n=2$，$m=9$，$c=6$ |\n| $4$ | $n=2$，$m=12$，$c=3$ |\n| $5$ | $n=2$，$m=12$，$c=5$ |\n| $6$ | $n=10$，$m=8$，$c=3$ |\n| $7$ | $n=10$，$m=10$，$c=5$ |\n| $8$ | $n=100$，$m=10$，$c=5$ |\n| $9$ | $n=100$，$m=12$，$c=5$ |\n| $10$ | $n=100$，$m=12$，$c=6$ |", "locale": "zh-CN"}}}
{"pid": "P3291", "type": "P", "difficulty": 6, "samples": [["3\n1 1\n1 2\n2 2", "8.0000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "四川", "二分", "各省省选", "枚举", "凸包"], "title": "[SCOI2016] 妖怪", "background": "", "description": "\n邱老师是妖怪爱好者，他有 $n$ 只妖怪，每只妖怪有攻击力 $\\mathrm{atk}$ 和防御力 $\\mathrm{dnf}$ 两种属性。邱老师立志成为妖怪大师，于是他从真新镇出发，踏上未知的旅途，见识不同的风景。\n\n环境对妖怪的战斗力有很大影响，环境 $(a,b)$ 由 $a,b$ 两个参数定义，其中 $a,b$ 为**正实数**。在环境 $(a,b)$ 中，妖怪可以降低自己 $k\\times a$ 点攻击力，提升 $k\\times b$ 点防御力或者提升自己 $k\\times a$ 点攻击力，降低 $k\\times b$ 点防御力。其中 $k$ 为**任意实数**，但是 **$\\mathrm{atk}$ 和 $\\mathrm{dnf}$ 必须始终非负**。\n\n妖怪在环境 $(a,b)$ 中的**战斗力** $\\mathrm{strength}$ 定义为妖怪在该种环境中能达到的最大攻击力和最大防御力之和，即 $\\mathrm{strength}(a,b)=\\max(\\mathrm{atk}(a,b))+\\max(\\mathrm{dnf}(a,b))$。\n\n比如当前环境 $a=3,b=2$，那么攻击力为 $6$，防御力为 $2$ 的妖怪，能达到的最大攻击力为 $9$，最大防御力为 $6$。所以该妖怪在 $a=3,b=2$ 的环境下战斗力为 $15$。\n\n因此，在不同的环境，战斗力最强的妖怪可能发生变化。\n\n作为一名优秀的妖怪训练师，邱老师想发掘每一只妖怪的最大潜力，他想知道在**最为不利的情况下**，他的 $n$ 只妖怪能够达到的最强战斗力值。换言之，存在一组正实数 $(a,b)$ 使得 $n$ 只妖怪在该环境下最强战斗力最低，你需要输出这个最低的战斗力。", "inputFormat": "第一行一个n，表示有 $n$ 只妖怪。\n\n接下来 $n$ 行，每行两个整数 $\\mathrm{atk}_i$ 和 $\\mathrm{dnf}_i$，表示第 $i$ 只妖怪的攻击力和防御力。\n", "outputFormat": "输出在最不利情况下最强妖怪的战斗力值，保留 $4$ 位小数。", "hint": "\n对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$0\\lt \\mathrm{atk},\\mathrm{dnf}\\le 10^8$。\n\nStatement fixed by Starrykiller.", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2016] Monster", "background": "", "description": "Teacher Qiu is a monster enthusiast. He has $n$ monsters, each with two attributes: attack $\\mathrm{atk}$ and defense $\\mathrm{dnf}$. Determined to become a master of monsters, he sets off from Zhenxin Town on an unknown journey to see different sceneries.\n\nThe environment $(a, b)$ is defined by two parameters $a$ and $b$, where $a$ and $b$ are positive real numbers. In environment $(a, b)$, a monster may decrease its attack by $k \\times a$ and increase its defense by $k \\times b$, or increase its attack by $k \\times a$ and decrease its defense by $k \\times b$. Here $k$ can be any real number, but $\\mathrm{atk}$ and $\\mathrm{dnf}$ must always remain non-negative.\n\nIn environment $(a, b)$, the monster’s strength $\\mathrm{strength}$ is defined as the sum of the maximum attack it can achieve and the maximum defense it can achieve in that environment, i.e., $\\mathrm{strength}(a,b)=\\max(\\mathrm{atk}(a,b))+\\max(\\mathrm{dnf}(a,b))$.\n\nFor example, if the current environment has $a=3$, $b=2$, then for a monster with attack $6$ and defense $2$, the maximum achievable attack is $9$ and the maximum achievable defense is $6$. Therefore, this monster’s strength in the environment $a=3$, $b=2$ is $15$.\n\nThus, the strongest monster may change in different environments.\n\nAs an excellent monster trainer, Teacher Qiu wants to discover each monster’s maximum potential. He wants to know, in the most unfavorable case, the strongest strength value that his $n$ monsters can achieve. In other words, there exists a pair of positive real numbers $(a, b)$ such that the strongest strength among the $n$ monsters in that environment is minimized; you need to output this minimum strength.", "inputFormat": "The first line contains an integer $n$, the number of monsters.\n\nEach of the next $n$ lines contains two integers $\\mathrm{atk}_i$ and $\\mathrm{dnf}_i$, denoting the attack and defense of the $i$-th monster.", "outputFormat": "Output the strongest monster’s strength value in the most unfavorable case, with $4$ digits after the decimal point.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le n \\le 10^6$, $0 \\lt \\mathrm{atk}, \\mathrm{dnf} \\le 10^8$.\n\nStatement fixed by Starrykiller.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2016] 妖怪", "background": "", "description": "\n邱老师是妖怪爱好者，他有 $n$ 只妖怪，每只妖怪有攻击力 $\\mathrm{atk}$ 和防御力 $\\mathrm{dnf}$ 两种属性。邱老师立志成为妖怪大师，于是他从真新镇出发，踏上未知的旅途，见识不同的风景。\n\n环境对妖怪的战斗力有很大影响，环境 $(a,b)$ 由 $a,b$ 两个参数定义，其中 $a,b$ 为**正实数**。在环境 $(a,b)$ 中，妖怪可以降低自己 $k\\times a$ 点攻击力，提升 $k\\times b$ 点防御力或者提升自己 $k\\times a$ 点攻击力，降低 $k\\times b$ 点防御力。其中 $k$ 为**任意实数**，但是 **$\\mathrm{atk}$ 和 $\\mathrm{dnf}$ 必须始终非负**。\n\n妖怪在环境 $(a,b)$ 中的**战斗力** $\\mathrm{strength}$ 定义为妖怪在该种环境中能达到的最大攻击力和最大防御力之和，即 $\\mathrm{strength}(a,b)=\\max(\\mathrm{atk}(a,b))+\\max(\\mathrm{dnf}(a,b))$。\n\n比如当前环境 $a=3,b=2$，那么攻击力为 $6$，防御力为 $2$ 的妖怪，能达到的最大攻击力为 $9$，最大防御力为 $6$。所以该妖怪在 $a=3,b=2$ 的环境下战斗力为 $15$。\n\n因此，在不同的环境，战斗力最强的妖怪可能发生变化。\n\n作为一名优秀的妖怪训练师，邱老师想发掘每一只妖怪的最大潜力，他想知道在**最为不利的情况下**，他的 $n$ 只妖怪能够达到的最强战斗力值。换言之，存在一组正实数 $(a,b)$ 使得 $n$ 只妖怪在该环境下最强战斗力最低，你需要输出这个最低的战斗力。", "inputFormat": "第一行一个n，表示有 $n$ 只妖怪。\n\n接下来 $n$ 行，每行两个整数 $\\mathrm{atk}_i$ 和 $\\mathrm{dnf}_i$，表示第 $i$ 只妖怪的攻击力和防御力。\n", "outputFormat": "输出在最不利情况下最强妖怪的战斗力值，保留 $4$ 位小数。", "hint": "\n对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$0\\lt \\mathrm{atk},\\mathrm{dnf}\\le 10^8$。\n\nStatement fixed by Starrykiller.", "locale": "zh-CN"}}}
{"pid": "P3292", "type": "P", "difficulty": 6, "samples": [["4 2\n11 5 7 9\n1 2\n1 3\n1 4\n2 3\n1 4", "14 \n11"]], "limits": {"time": [2000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "四川", "倍增", "各省省选", "线性基"], "title": "[SCOI2016] 幸运数字", "background": "", "description": "\nA 国共有 $n$ 座城市，这些城市由 $n - 1$ 条道路相连，使得任意两座城市可以互达，且路径唯一。每座城市都有一个幸运数字，以纪念碑的形式矗立在这座城市的正中心，作为城市的象征。\n\n一些旅行者希望游览 A 国。旅行者计划乘飞机降落在 $x$ 号城市，沿着 $x$ 号城市到 $y$ 号城市之间那条唯一的路径游览，最终从 $y$ 城市起飞离开 A 国。在经过每一座城市时，游览者就会有机会与这座城市的幸运数字拍照，从而将这份幸运保存到自己身上。然而，幸运是不能简单叠加的，这一点游览者也十分清楚。他们迷信着幸运数字是以异或的方式保留在自己身上的。\n\n例如，游览者拍了 $3$ 张照片，幸运值分别是 $5, 7, 11$，那么最终保留在自己身上的幸运值就是 $5 \\operatorname{xor} 7 \\operatorname{xor} 11 = 9$。\n\n有些聪明的游览者发现，只要选择性地进行拍照，便能获得更大的幸运值。例如在上述三个幸运值中，只选择 $5$ 和 $11$ ，可以保留的幸运值为 $14$ 。现在，一些游览者找到了聪明的你，希望你帮他们计算出在他们的行程安排中可以保留的最大幸运值是多少。", "inputFormat": "第一行包含 $2$ 个正整数 $n, q$，分别表示城市的数量和旅行者数量。\n\n第二行包含 $n$ 个非负整数，其中第 $i$ 个整数 $G_i$ 表示 $i$ 号城市的幸运值。\n\n随后 $n - 1$ 行，每行包含两个正整数 $x, y$，表示 $x$ 号城市和 $y$ 号城市之间有一条道路相连。\n\n随后 $q$ 行，每行包含两个正整数 $x, y$，表示这名旅行者的旅行计划是从 $x$ 号城市到 $y$ 号城市。", "outputFormat": "输出需要包含 $q$ 行，每行包含 $1$ 个非负整数，表示这名旅行者可以保留的最大幸运值。", "hint": "对于 $100 \\%$ 的数据，保证 $n \\leq 2 \\times 10^4, q \\leq 2 \\times 10^5, G_i \\leq 2^{60}$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2016] Lucky Numbers", "background": "", "description": "Country A has $n$ cities connected by $n - 1$ roads, so that any two cities are mutually reachable and the path between them is unique. Each city has a lucky number, which stands at the very center of the city in the form of a monument, serving as the symbol of the city.\n\nSome travelers want to tour Country A. A traveler plans to land in city $x$, travel along the unique path from city $x$ to city $y$, and finally depart from city $y$. When passing through each city, the traveler has a chance to take a photo with that city's lucky number, thereby keeping this luck. However, luck cannot be simply stacked, and the traveler knows this well. They believe that luck is kept on them via xor.\n\nFor example, if a traveler takes $3$ photos with lucky values $5, 7, 11$, then the lucky value finally kept is $5 \\operatorname{xor} 7 \\operatorname{xor} 11 = 9$.\n\nSome smart travelers have found that by selectively taking photos, they can obtain a larger lucky value. For instance, among the three lucky values above, if they only choose $5$ and $11$, the lucky value kept is $14$. Now, some travelers have come to you for help. Given their itineraries, please compute the maximum lucky value they can keep.", "inputFormat": "The first line contains $2$ positive integers $n, q$, denoting the number of cities and the number of travelers.\n\nThe second line contains $n$ non-negative integers, where the $i$-th integer $G_i$ denotes the lucky value of city $i$.\n\nThe next $n - 1$ lines each contain two positive integers $x, y$, indicating that there is a road between city $x$ and city $y$.\n\nThe next $q$ lines each contain two positive integers $x, y$, indicating that this traveler’s plan is to go from city $x$ to city $y$.", "outputFormat": "Output $q$ lines. Each line contains one non-negative integer, the maximum lucky value that this traveler can keep.", "hint": "For $100\\%$ of the testdata, it is guaranteed that $n \\leq 2 \\times 10^4$, $q \\leq 2 \\times 10^5$, $G_i \\leq 2^{60}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2016] 幸运数字", "background": "", "description": "\nA 国共有 $n$ 座城市，这些城市由 $n - 1$ 条道路相连，使得任意两座城市可以互达，且路径唯一。每座城市都有一个幸运数字，以纪念碑的形式矗立在这座城市的正中心，作为城市的象征。\n\n一些旅行者希望游览 A 国。旅行者计划乘飞机降落在 $x$ 号城市，沿着 $x$ 号城市到 $y$ 号城市之间那条唯一的路径游览，最终从 $y$ 城市起飞离开 A 国。在经过每一座城市时，游览者就会有机会与这座城市的幸运数字拍照，从而将这份幸运保存到自己身上。然而，幸运是不能简单叠加的，这一点游览者也十分清楚。他们迷信着幸运数字是以异或的方式保留在自己身上的。\n\n例如，游览者拍了 $3$ 张照片，幸运值分别是 $5, 7, 11$，那么最终保留在自己身上的幸运值就是 $5 \\operatorname{xor} 7 \\operatorname{xor} 11 = 9$。\n\n有些聪明的游览者发现，只要选择性地进行拍照，便能获得更大的幸运值。例如在上述三个幸运值中，只选择 $5$ 和 $11$ ，可以保留的幸运值为 $14$ 。现在，一些游览者找到了聪明的你，希望你帮他们计算出在他们的行程安排中可以保留的最大幸运值是多少。", "inputFormat": "第一行包含 $2$ 个正整数 $n, q$，分别表示城市的数量和旅行者数量。\n\n第二行包含 $n$ 个非负整数，其中第 $i$ 个整数 $G_i$ 表示 $i$ 号城市的幸运值。\n\n随后 $n - 1$ 行，每行包含两个正整数 $x, y$，表示 $x$ 号城市和 $y$ 号城市之间有一条道路相连。\n\n随后 $q$ 行，每行包含两个正整数 $x, y$，表示这名旅行者的旅行计划是从 $x$ 号城市到 $y$ 号城市。", "outputFormat": "输出需要包含 $q$ 行，每行包含 $1$ 个非负整数，表示这名旅行者可以保留的最大幸运值。", "hint": "对于 $100 \\%$ 的数据，保证 $n \\leq 2 \\times 10^4, q \\leq 2 \\times 10^5, G_i \\leq 2^{60}$。", "locale": "zh-CN"}}}
{"pid": "P3293", "type": "P", "difficulty": 6, "samples": [["4 4\n1 2 3 4\n1 4 1 4\n2 3 2 3\n3 2 3 3\n4 1 2 4", "9 \n7 \n6 \n7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000], "memory": [258048, 258048, 258048, 258048, 258048, 258048]}, "tags": ["贪心", "2016", "四川", "各省省选", "可持久化线段树", "可持久化"], "title": "[SCOI2016] 美味", "background": "", "description": "\n一家餐厅有 $n$ 道菜，编号 $1, 2, \\ldots, n$，大家对第 $i$ 道菜的评价值为 $a_i$。有 $m$ 位顾客，第 $i$ 位顾客的期望值为 $b_i$，而他的偏好值为 $x_i$。因此，第 $i$ 位顾客认为第 $j$ 道菜的美味度为 $b_i\\oplus (a_j + x_i)$，$\\oplus$ 表示异或运算。\n\n第 $i$ 位顾客希望从这些菜中挑出他认为最美味的菜，即美味值最大的菜，但由于价格等因素，他只能从第 $l_i$ 道到第 $r_i$ 道中选择。请你帮助他们找出最美味的菜。", "inputFormat": "第 $1$ 行两个整数 $n, m$，表示菜品数和顾客数。\n\n第 $2$ 行 $n$ 个整数 $a_1, a_2, \\ldots, a_n$，表示每道菜的评价值。\n\n第 $3$ 至 $m + 2$ 行，每行四个整数 $b,x,l,r$，表示该位顾客的期望值，偏好值，和可以选择菜品区间。", "outputFormat": "输出 $m$ 行，每行一个整数表示该位顾客选择的最美味的菜的美味值。", "hint": "对于 $100\\%$ 的数据，满足 $1 \\le n \\le 2 \\times 10^5$，$0 \\le a_i,b_i,x_i < 10^5$，$1 \\le l_i \\le r_i \\le n$（$1 \\le i \\le m$），$1 \\le m \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2016] Delicious", "background": "", "description": "A restaurant has $n$ dishes, numbered $1, 2, \\ldots, n$. The evaluation value of dish $i$ is $a_i$. There are $m$ customers. The $i$-th customer's expected value is $b_i$, and their preference value is $x_i$. Therefore, the $i$-th customer considers the deliciousness of dish $j$ to be $b_i \\oplus (a_j + x_i)$, where $\\oplus$ denotes the XOR operation.\n\nThe $i$-th customer wants to pick the dish they consider the most delicious, i.e., the one with the maximum deliciousness value, but due to price and other factors, they can only choose from dishes $l_i$ through $r_i$. Please help them find the most delicious dish.", "inputFormat": "The first line contains two integers $n, m$, the number of dishes and the number of customers.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$, the evaluation value of each dish.\n\nLines $3$ to $m + 2$ each contain four integers $b, x, l, r$, indicating the customer's expected value, preference value, and the allowed range of dishes.", "outputFormat": "Output $m$ lines, each containing one integer, the maximum deliciousness value chosen by that customer.", "hint": "Constraints.\n\nFor $100\\%$ of the testdata, it holds that $1 \\le n \\le 2 \\times 10^5$, $0 \\le a_i, b_i, x_i < 10^5$, $1 \\le l_i \\le r_i \\le n$ ($1 \\le i \\le m$), $1 \\le m \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2016] 美味", "background": "", "description": "\n一家餐厅有 $n$ 道菜，编号 $1, 2, \\ldots, n$，大家对第 $i$ 道菜的评价值为 $a_i$。有 $m$ 位顾客，第 $i$ 位顾客的期望值为 $b_i$，而他的偏好值为 $x_i$。因此，第 $i$ 位顾客认为第 $j$ 道菜的美味度为 $b_i\\oplus (a_j + x_i)$，$\\oplus$ 表示异或运算。\n\n第 $i$ 位顾客希望从这些菜中挑出他认为最美味的菜，即美味值最大的菜，但由于价格等因素，他只能从第 $l_i$ 道到第 $r_i$ 道中选择。请你帮助他们找出最美味的菜。", "inputFormat": "第 $1$ 行两个整数 $n, m$，表示菜品数和顾客数。\n\n第 $2$ 行 $n$ 个整数 $a_1, a_2, \\ldots, a_n$，表示每道菜的评价值。\n\n第 $3$ 至 $m + 2$ 行，每行四个整数 $b,x,l,r$，表示该位顾客的期望值，偏好值，和可以选择菜品区间。", "outputFormat": "输出 $m$ 行，每行一个整数表示该位顾客选择的最美味的菜的美味值。", "hint": "对于 $100\\%$ 的数据，满足 $1 \\le n \\le 2 \\times 10^5$，$0 \\le a_i,b_i,x_i < 10^5$，$1 \\le l_i \\le r_i \\le n$（$1 \\le i \\le m$），$1 \\le m \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3294", "type": "P", "difficulty": 6, "samples": [["2\na\nba", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2016", "四川", "各省省选", "深度优先搜索 DFS", "字典树 Trie"], "title": "[SCOI2016] 背单词", "background": "", "description": "Lweb 面对如山的英语单词，陷入了深深的沉思：我怎么样才能快点学完，然后去玩三国杀呢？这时候睿智的凤老师从远处飘来，他送给了 Lweb 一本计划册和一大缸泡椒，他的计划册是长这样的：\n\n| 序号    | 单词 |\n| ------- | ---- |\n| $1$     |      |\n| $2$     |      |\n| $\\dots$ |      |\n| $n-1$    |      |\n| $n$     |      |\n\n然后凤老师告诉 Lweb ，我知道你要学习的单词总共有 $n$ 个，现在我们从上往下完成计划表，对于一个序号为 $x$ 的单词（序号 $1,\\dots ,x-1$ 都已经被填入）：\n\n1. 如果存在一个单词是它的后缀，并且当前没有被填入表内，那他需要吃 $n \\times n$ 颗泡椒才能学会；\n2. 当它的所有后缀都被填入表内的情况下，如果在 $1,\\dots,x-1$ 的位置上的单词都不是它的后缀，那么你吃 $x$ 颗泡椒就能记住它；\n3. 当它的所有后缀都被填入表内的情况下，如果 $1,\\dots,x-1$ 的位置上存在是它后缀的单词，所有是它后缀的单词中，序号最大为 $y$，那么你只要吃 $x-y$ 颗泡椒就能把它记住。\n\nLweb 是一个吃到辣辣的东西会暴走的奇怪小朋友，所以请你帮助 Lweb ，寻找一种最优的填写单词方案，使得他记住这 $n$ 个单词的情况下，吃最少的泡椒。\n\n形式化题意：\n\n你需要为 $n$ 个字符串排列一个顺序，每个字符串都会产生一定代价。\n\n对于一个字符串 $s$，其所在位置为 $x$：\n\n1. 如果存在至少一个其他字符串是 $s$ 后缀，且这个字符串的位置在 $s$ 后面， $s$ 将产生 $n \\times n$ 的代价。\n\n2. 如果不存在其他字符串是 $s$ 的后缀，则 $s$ 产生 $x$ 的代价。\n\n3. 如果所有是 $s$ 后缀的字符串的位置都在 $s$ 的前面，若这些字符串的位置的最大值为 $y$ ， 则 $s$ 产生 $x-y$ 的代价。\n\n为 $n$ 个字符串排列一个顺序，使总代价最小。", "inputFormat": "输入一个整数 $n$ ，表示 Lweb 要学习的单词数。\n\n接下来 $n$ 行，每行有一个单词（由小写字母构成，且保证任意单词两两互不相同）。", "outputFormat": "Lweb 吃的最少泡椒数。", "hint": "$1\\le n\\le100000$，所有字符的长度总和 $1\\le \\sum|S| \\le510000$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2016] Memorizing Words", "background": "", "description": "Lweb is facing a mountain of English words and falls into deep thought: how can I finish learning quickly and then go play Sanguosha (pinyin)? At this moment, the wise Teacher Feng drifts over from afar. He gives Lweb a planner and a big jar of pickled chili peppers. His planner looks like this:\n\n| Index   | Word |\n| ------- | ---- |\n| $1$     |      |\n| $2$     |      |\n| $\\dots$ |      |\n| $n-1$   |      |\n| $n$     |      |\n\nThen Teacher Feng tells Lweb: I know there are $n$ words you need to learn. We will fill the planner from top to bottom. For the word with index $x$ (the positions $1,\\dots ,x-1$ have already been filled):\n\n1. If there exists a word that is its suffix and has not yet been filled into the table, then he needs to eat $n \\times n$ chili peppers to learn it.\n2. If all of its suffixes have already been filled into the table, and none of the words at positions $1,\\dots ,x-1$ is its suffix, then you can remember it by eating $x$ chili peppers.\n3. If all of its suffixes have already been filled into the table, and among positions $1,\\dots ,x-1$ there exists a word that is its suffix, let the maximum index among its suffixes be $y$. Then you only need to eat $x-y$ chili peppers to remember it.\n\nLweb is a strange kid who goes berserk when he eats spicy things, so please help Lweb find an optimal way to fill the words so that he learns these $n$ words while eating the fewest chili peppers.\n\nFormal statement:\n\nYou need to arrange an order for $n$ strings. Each string incurs a certain cost.\n\nFor a string $s$ at position $x$:\n\n1. If there exists at least one other string that is a suffix of $s$, and that string’s position is after $s$, then $s$ incurs a cost of $n \\times n$.\n2. If no other string is a suffix of $s$, then $s$ incurs a cost of $x$.\n3. If all strings that are suffixes of $s$ appear before $s$, and the maximum position among them is $y$, then $s$ incurs a cost of $x-y$.\n\nArrange an order for the $n$ strings to minimize the total cost.", "inputFormat": "Input an integer $n$, the number of words Lweb needs to learn.\n\nThen follow $n$ lines, each containing one word (lowercase letters only, and all words are pairwise distinct).", "outputFormat": "The minimum number of chili peppers Lweb needs to eat.", "hint": "Constraints: $1\\le n\\le100000$, and the total length of all strings satisfies $1\\le \\sum|S| \\le510000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2016] 背单词", "background": "", "description": "Lweb 面对如山的英语单词，陷入了深深的沉思：我怎么样才能快点学完，然后去玩三国杀呢？这时候睿智的凤老师从远处飘来，他送给了 Lweb 一本计划册和一大缸泡椒，他的计划册是长这样的：\n\n| 序号    | 单词 |\n| ------- | ---- |\n| $1$     |      |\n| $2$     |      |\n| $\\dots$ |      |\n| $n-1$    |      |\n| $n$     |      |\n\n然后凤老师告诉 Lweb ，我知道你要学习的单词总共有 $n$ 个，现在我们从上往下完成计划表，对于一个序号为 $x$ 的单词（序号 $1,\\dots ,x-1$ 都已经被填入）：\n\n1. 如果存在一个单词是它的后缀，并且当前没有被填入表内，那他需要吃 $n \\times n$ 颗泡椒才能学会；\n2. 当它的所有后缀都被填入表内的情况下，如果在 $1,\\dots,x-1$ 的位置上的单词都不是它的后缀，那么你吃 $x$ 颗泡椒就能记住它；\n3. 当它的所有后缀都被填入表内的情况下，如果 $1,\\dots,x-1$ 的位置上存在是它后缀的单词，所有是它后缀的单词中，序号最大为 $y$，那么你只要吃 $x-y$ 颗泡椒就能把它记住。\n\nLweb 是一个吃到辣辣的东西会暴走的奇怪小朋友，所以请你帮助 Lweb ，寻找一种最优的填写单词方案，使得他记住这 $n$ 个单词的情况下，吃最少的泡椒。\n\n形式化题意：\n\n你需要为 $n$ 个字符串排列一个顺序，每个字符串都会产生一定代价。\n\n对于一个字符串 $s$，其所在位置为 $x$：\n\n1. 如果存在至少一个其他字符串是 $s$ 后缀，且这个字符串的位置在 $s$ 后面， $s$ 将产生 $n \\times n$ 的代价。\n\n2. 如果不存在其他字符串是 $s$ 的后缀，则 $s$ 产生 $x$ 的代价。\n\n3. 如果所有是 $s$ 后缀的字符串的位置都在 $s$ 的前面，若这些字符串的位置的最大值为 $y$ ， 则 $s$ 产生 $x-y$ 的代价。\n\n为 $n$ 个字符串排列一个顺序，使总代价最小。", "inputFormat": "输入一个整数 $n$ ，表示 Lweb 要学习的单词数。\n\n接下来 $n$ 行，每行有一个单词（由小写字母构成，且保证任意单词两两互不相同）。", "outputFormat": "Lweb 吃的最少泡椒数。", "hint": "$1\\le n\\le100000$，所有字符的长度总和 $1\\le \\sum|S| \\le510000$。", "locale": "zh-CN"}}}
{"pid": "P3295", "type": "P", "difficulty": 6, "samples": [["4 2\n1 2 3 4\n3 3 3 3", "90"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "四川", "并查集", "各省省选", "枚举", "ST 表"], "title": "[SCOI2016] 萌萌哒", "background": "", "description": "一个长度为 $n$ 的大数，用 $S_1S_2S_3 \\cdots S_n$表示，其中 $S_i$ 表示数的第 $i$ 位, $S_1$ 是数的最高位。告诉你一些限制条件，每个条件表示为四个数，$l_1,r_1,l_2,r_2$，即两个长度相同的区间，表示子串 $S_{l_1}S_{l_1+1}S_{l_1+2} \\cdots S_{r_1}$ 与 $S_{l_2}S_{l_2+1}S_{l_2+2} \\cdots S_{r_2}$ 完全相同。\n\n比如 $n=6$ 时，某限制条件 $l_1=1,r_1=3,l_2=4,r_2=6$ ，那么 $123123$，$351351$ 均满足条件，但是 $12012$，$131141$ 不满足条件，前者数的长度不为 $6$ ，后者第二位与第五位不同。问满足以上所有条件的数有多少个。", "inputFormat": "第一行两个数 $n$ 和 $m$，分别表示大数的长度，以及限制条件的个数。\n\n接下来 $m$ 行，对于第 $i$ 行,有 $4$ 个数 $l_{i_1},r_{i_1},{l_{i_2}},r_{i_2}$，分别表示该限制条件对应的两个区间。\n\n$1\\le n\\le 10^5$，$1\\le m\\le 10^5$，$1\\le l_{i_1},r_{i_1},{l_{i_2}},r_{i_2}\\le n$ ；并且保证 $ r_{i_1}-l_{i_1}=r_{i_2}-l_{i_2}$ 。\n", "outputFormat": "一个数，表示满足所有条件且长度为 $n$ 的大数的个数，答案可能很大，因此输出答案模 $ 10^9+7 $ 的结果即可。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2016] Mengmengda", "background": "", "description": "An $n$-digit number is denoted by $S_1 S_2 S_3 \\cdots S_n$, where $S_i$ is the $i$-th digit and $S_1$ is the most significant digit. You are given several constraints. Each constraint is given by four integers $l_1, r_1, l_2, r_2$, meaning two intervals of the same length, and it requires the substrings $S_{l_1} S_{l_1+1} S_{l_1+2} \\cdots S_{r_1}$ and $S_{l_2} S_{l_2+1} S_{l_2+2} \\cdots S_{r_2}$ to be exactly the same.\n\nFor example, when $n=6$ and there is a constraint $l_1=1, r_1=3, l_2=4, r_2=6$, then 123123 and 351351 both satisfy the condition, but 12012 and 131141 do not. The former is not of length $6$, and in the latter the second and fifth digits differ. Find how many numbers satisfy all the given conditions.", "inputFormat": "The first line contains two integers $n$ and $m$, representing the length of the number and the number of constraints.\n\nEach of the next $m$ lines contains four integers $l_{i_1}, r_{i_1}, {l_{i_2}}, r_{i_2}$ on the $i$-th line, representing the two intervals for that constraint.\n\n$1 \\le n \\le 10^5$, $1 \\le m \\le 10^5$, $1 \\le l_{i_1}, r_{i_1}, {l_{i_2}}, r_{i_2} \\le n$, and it is guaranteed that $r_{i_1} - l_{i_1} = r_{i_2} - l_{i_2}$.", "outputFormat": "Output a single integer, the number of $n$-digit numbers that satisfy all the constraints. Since the answer can be large, output it modulo $10^9+7$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2016] 萌萌哒", "background": "", "description": "一个长度为 $n$ 的大数，用 $S_1S_2S_3 \\cdots S_n$表示，其中 $S_i$ 表示数的第 $i$ 位, $S_1$ 是数的最高位。告诉你一些限制条件，每个条件表示为四个数，$l_1,r_1,l_2,r_2$，即两个长度相同的区间，表示子串 $S_{l_1}S_{l_1+1}S_{l_1+2} \\cdots S_{r_1}$ 与 $S_{l_2}S_{l_2+1}S_{l_2+2} \\cdots S_{r_2}$ 完全相同。\n\n比如 $n=6$ 时，某限制条件 $l_1=1,r_1=3,l_2=4,r_2=6$ ，那么 $123123$，$351351$ 均满足条件，但是 $12012$，$131141$ 不满足条件，前者数的长度不为 $6$ ，后者第二位与第五位不同。问满足以上所有条件的数有多少个。", "inputFormat": "第一行两个数 $n$ 和 $m$，分别表示大数的长度，以及限制条件的个数。\n\n接下来 $m$ 行，对于第 $i$ 行,有 $4$ 个数 $l_{i_1},r_{i_1},{l_{i_2}},r_{i_2}$，分别表示该限制条件对应的两个区间。\n\n$1\\le n\\le 10^5$，$1\\le m\\le 10^5$，$1\\le l_{i_1},r_{i_1},{l_{i_2}},r_{i_2}\\le n$ ；并且保证 $ r_{i_1}-l_{i_1}=r_{i_2}-l_{i_2}$ 。\n", "outputFormat": "一个数，表示满足所有条件且长度为 $n$ 的大数的个数，答案可能很大，因此输出答案模 $ 10^9+7 $ 的结果即可。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3296", "type": "P", "difficulty": 6, "samples": [["4\n1 2\n2 3\n3 4\n0 0 1 1\n1 0 0 0", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2013", "各省省选", "山东", "费用流", "哈希 hashing"], "title": "[SDOI2013] 刺客信条", "background": "", "description": "故事发生在1486 年的意大利，Ezio 原本只是一个文艺复兴时期的贵族，后来因为家族成员受到圣殿骑士的杀害，决心成为一名刺客。最终，凭借着他的努力和出众的天赋，成为了杰出的刺客大师，他不仅是个身手敏捷的武林高手，飞檐走壁擅长各种暗杀术。刺客组织在他的带领下，为被剥削的平民声张正义，赶跑了原本统治意大利的圣殿骑士首领-教皇亚历山大六世。在他的一生中，经历了无数次惊心动魄、扣人心弦的探险和刺杀。\n\n\n曾经有一次，为了寻找Altair 留下的线索和装备，Ezio 在佛罗伦萨中的刺客墓穴进行探索。这个刺客墓穴中有许多密室，且任何两个密室之间只存在一条唯一的路径。这些密室里都有一个刺客标记，他可以启动或者关闭该刺客标记。为了打开储存着线索和装备的储藏室，Ezio 必须操作刺客标记来揭开古老的封印。要想解开这个封印，他需要通过改变某些刺客标记的启动情况，使得所有刺客标记与封印密码“看起来一样”。\n\n\n在这里，“看起来一样”的定义是：存在一种“标记”密室与“密码”密室之间一一对应的关系，使得密室间的连接情况和启动情况相同（提示中有更详细解释）。幸运的是，在Ezio 来到刺客墓穴之前，在Da Vinci 的帮助下，Ezio 已经得知了打开储藏室所需要的密码。\n\n\n而你的任务则是帮助Ezio 找出达成目标所需要最少的改动标记次数。\n", "inputFormat": "第一行给出一个整数n, 表示密室的个数,\n\n\n第二行至第 n 行, 每行绐出两个整数 a 和 b, 表示第 a 个密室和第 b 个密室之间存在一条通道.\n\n\n第 n+1行1 绐出 n 个整数1 分别表示当时每个密室的启动情况 {0表示关闭, 1表示启动).\n\n\n第 n+2 行7 给出 n 个整数, 分别表示密码中每个密室的启动情况.\n", "outputFormat": "输出只有一行，即输出最少改动标记次数\n", "hint": "密室的编号是可以变的！将第三个密室关闭后，在当前标记和密码之间，存在1->4,2->3,3->2,4->1 的对应关系，重新编号后连接情况没有改变，且标记与密码对应。对于更一般的情况，存在一个1 到n 的置换P，使得对于任意密室之间的道路u-v，都一定有密码密室中的道路P(u)-P(v)；如果不存在密室之间的道路u-v，则一定没有密码密室中的道路P(u)-P(v)。\n\n\n对于100%的数据，n<=700，且每个密室至多与11个密室相通\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2013] Assassin's Creed", "background": "", "description": "The story takes place in Italy in the year 1486. Ezio was originally a nobleman of the Renaissance. Later, after members of his family were killed by the Templars, he decided to become an assassin. In the end, with his effort and outstanding talent, he became an excellent Master Assassin. He was not only agile and skilled in martial arts, but also good at all kinds of assassination techniques such as parkour across rooftops. Under his leadership, the assassin brotherhood stood up for the oppressed common people and drove away the original ruler of Italy—the leader of the Templars, Pope Alexander VI. In his lifetime, he experienced countless thrilling adventures and assassinations.\n\nOnce, in order to find the clues and equipment left by Altair, Ezio explored an assassin tomb in Florence. This tomb has many secret rooms, and between any two rooms there is exactly one unique path. Each room has an assassin mark that he can turn on or off. To open the vault storing the clues and equipment, Ezio must operate the marks to lift an ancient seal. To break this seal, he needs to change the on/off state of some marks so that all marks “look the same” as the password.\n\nHere, “look the same” means: there exists a one-to-one correspondence between the rooms in the “mark” configuration and the rooms in the “password” configuration such that both the connections between rooms and the on/off states match (there is a more detailed explanation in the Hint). Fortunately, before Ezio arrived at the tomb, with the help of Da Vinci, he had already learned the required password to open the vault.\n\nYour task is to help Ezio find the minimum number of mark changes required to achieve the goal.", "inputFormat": "- Line 1: An integer n, the number of rooms.\n- Lines 2 to n: Each line contains two integers a and b, indicating there is a passage between room a and room b.\n- Line n+1: n integers, giving the current on/off state of each room (0 means off, 1 means on).\n- Line n+2: n integers, giving the on/off state of each room in the password.", "outputFormat": "Output a single line: the minimum number of mark changes.", "hint": "The room numbering can be changed. After turning off the third room in the current configuration, there exists a correspondence between the current marks and the password: 1 -> 4, 2 -> 3, 3 -> 2, 4 -> 1. After renumbering, the connections do not change, and the marks match the password.\n\nIn the general case, there exists a permutation P of 1 to n such that for any road u - v between rooms in the current configuration, there is a road P(u) - P(v) in the password configuration; and if there is no road u - v in the current configuration, then there is no road P(u) - P(v) in the password configuration.\n\nConstraints: For 100% of the testdata, $n \\le 700$, and each room is adjacent to at most $11$ rooms.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2013] 刺客信条", "background": "", "description": "故事发生在1486 年的意大利，Ezio 原本只是一个文艺复兴时期的贵族，后来因为家族成员受到圣殿骑士的杀害，决心成为一名刺客。最终，凭借着他的努力和出众的天赋，成为了杰出的刺客大师，他不仅是个身手敏捷的武林高手，飞檐走壁擅长各种暗杀术。刺客组织在他的带领下，为被剥削的平民声张正义，赶跑了原本统治意大利的圣殿骑士首领-教皇亚历山大六世。在他的一生中，经历了无数次惊心动魄、扣人心弦的探险和刺杀。\n\n\n曾经有一次，为了寻找Altair 留下的线索和装备，Ezio 在佛罗伦萨中的刺客墓穴进行探索。这个刺客墓穴中有许多密室，且任何两个密室之间只存在一条唯一的路径。这些密室里都有一个刺客标记，他可以启动或者关闭该刺客标记。为了打开储存着线索和装备的储藏室，Ezio 必须操作刺客标记来揭开古老的封印。要想解开这个封印，他需要通过改变某些刺客标记的启动情况，使得所有刺客标记与封印密码“看起来一样”。\n\n\n在这里，“看起来一样”的定义是：存在一种“标记”密室与“密码”密室之间一一对应的关系，使得密室间的连接情况和启动情况相同（提示中有更详细解释）。幸运的是，在Ezio 来到刺客墓穴之前，在Da Vinci 的帮助下，Ezio 已经得知了打开储藏室所需要的密码。\n\n\n而你的任务则是帮助Ezio 找出达成目标所需要最少的改动标记次数。\n", "inputFormat": "第一行给出一个整数n, 表示密室的个数,\n\n\n第二行至第 n 行, 每行绐出两个整数 a 和 b, 表示第 a 个密室和第 b 个密室之间存在一条通道.\n\n\n第 n+1行1 绐出 n 个整数1 分别表示当时每个密室的启动情况 {0表示关闭, 1表示启动).\n\n\n第 n+2 行7 给出 n 个整数, 分别表示密码中每个密室的启动情况.\n", "outputFormat": "输出只有一行，即输出最少改动标记次数\n", "hint": "密室的编号是可以变的！将第三个密室关闭后，在当前标记和密码之间，存在1->4,2->3,3->2,4->1 的对应关系，重新编号后连接情况没有改变，且标记与密码对应。对于更一般的情况，存在一个1 到n 的置换P，使得对于任意密室之间的道路u-v，都一定有密码密室中的道路P(u)-P(v)；如果不存在密室之间的道路u-v，则一定没有密码密室中的道路P(u)-P(v)。\n\n\n对于100%的数据，n<=700，且每个密室至多与11个密室相通\n", "locale": "zh-CN"}}}
{"pid": "P3297", "type": "P", "difficulty": 7, "samples": [["2\n4\n10 10 5 5\n5 6\n3 5\n7 5\n5 3\n17\n14 12 7 6\n7 11\n6 9\n7 7\n1 10\n2 20\n1 6\n2 6\n1 1\n2 2\n5 1\n5 2\n13 1\n12 2\n12 7\n13 7\n12 11\n13 11", "1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2013", "各省省选", "山东", "半平面交"], "title": "[SDOI2013] 逃考", "background": "", "description": "髙考又来了，对于不认真读书的来讲真不是个好消息为了小杨能在家里认真读书，他的亲戚决定驻扎在他的家里监督他学习，有爷爷奶奶、外公外婆、大舅、大嫂、阿姨 ......。\n\n小杨实在是忍无可忍了，这种生活跟监狱有什么区别！为了他亲爱的小红，为了他的 dota， 他决定越狱！\n\n假设小杨的家是个 $n\\times m$ 的矩阵，左下角坐标为（$0,0)$，右上角坐标为（$x_1,y_1)$。小杨有 $n$ 个亲戚，驻扎在矩阵里（位置不同，且不在矩阵的边上）。小杨家里的每个地方都被亲戚监控着，而且只被距离最近的亲戚监控：\n\n也就是说假设小杨所在的位置是（$3,3)$, 亲戚 $A$ 在（$3,0)$，A 距离小杨距离是 $3$；亲戚 $B$ 在（$6,7),$ 则 $B$ 距离小杨距离是 $5$。距离 $A<$ 距离 $B$，所以（$3,3)$ 位置由 $A$ 监控。\n\n如果“最近距离”出现同时有几个亲戚，那么那个位置同时被那几个亲戚监控。\n\n给出小杨的坐标（$x_0,y_0)$。因为被发现的人数越少，越狱成功的机会越大，所以小杨需要你设计一条越狱路线到达矩形的边上，且被发现的人数最少。\n\n小杨做的方向是任意的，也就是说路线上的任意位置 $H$ 需要是实数。\n\n保证一开始小杨只被一个亲戚监控着。", "inputFormat": "第一行一个正整数 $t \\le 3$ 表示数据个数。\n\n接下来 $t$ 个数据：\n\n第一行 $n$ 表示亲戚个数。\n\n第二行 $4$ 个正整数表示举行右上角坐标 $(x_1,y_1)$ 和小杨的坐标 $(x_0,y_0)$。\n\n接下来 $n$ 行，每行 $2$ 个正整数表示一个亲戚的位置。", "outputFormat": "每个数据一个正整数表示越狱被发现人数的最小值\n", "hint": "数据解释 :。\n\n第一个数据，小杨直接往上走，只被 $(5,6)$ 监控过。\n\n第二个数据，小杨被 $(7,7)$ 监控 - 走到 $(9,9)$ 被 $(7,11)$ 监控，然后直接往上走。\n\n数据规模 :\n\n前 $50\\%$ 数据, $n \\le 200$。\n\n其余数据 $n \\le 600$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2013] Escape the Exam", "background": "", "description": "The Gaokao is coming again. For those who don’t study hard, this is really bad news. To make Xiao Yang study at home, his relatives decide to stay at his house and watch him: grandpa and grandma, maternal grandparents, uncle, sister-in-law, aunt, and so on.\n\nXiao Yang can’t stand it anymore. What’s the difference between this life and prison? For his beloved Xiao Hong and for his Dota, he decides to break out!\n\nAssume Xiao Yang’s house is a rectangle with lower-left corner at $ (0,0) $ and upper-right corner at $ (x_1,y_1) $. There are $ n $ relatives staying inside the rectangle (at distinct positions, and none of them lies on the boundary). Every location in the house is watched by the nearest relative(s):\n\nThat is, suppose Xiao Yang is at $ (3,3) $, relative $ A $ is at $ (3,0) $, then the distance from $ A $ to Xiao Yang is $ 3 $; relative $ B $ is at $ (6,7) $, then the distance from $ B $ to Xiao Yang is $ 5 $. Since $ \\text{dist}(A) < \\text{dist}(B) $, the position $ (3,3) $ is watched by $ A $.\n\nIf there are multiple relatives tying for the nearest distance, then that position is watched by all of them simultaneously.\n\nGiven Xiao Yang’s starting position $ (x_0,y_0) $. Since the fewer people who discover him, the greater the chance of a successful escape, your task is to design a route from his starting position to the boundary of the rectangle so that the number of people who discover him is minimized.\n\nXiao Yang may move in any direction; the route can be any continuous path, and all positions along the path may have real coordinates.\n\nIt is guaranteed that at the starting position, Xiao Yang is watched by exactly one relative.", "inputFormat": "- The first line contains a positive integer $ t \\le 3 $, the number of testdata.\n- For each of the $ t $ testdata:\n  - The first line contains an integer $ n $, the number of relatives.\n  - The second line contains four positive integers giving the rectangle’s upper-right corner $ (x_1,y_1) $ and Xiao Yang’s starting position $ (x_0,y_0) $.\n  - Each of the next $ n $ lines contains two positive integers, the position of one relative.", "outputFormat": "For each testdata, output a single positive integer: the minimum possible number of relatives who will discover Xiao Yang during his escape.", "hint": "Explanation:\n\n- In the first dataset, Xiao Yang goes straight up and is only watched by $ (5,6) $.\n- In the second dataset, Xiao Yang is watched by $ (7,7) $, goes to $ (9,9) $ where he is watched by $ (7,11) $, and then goes straight up.\n\nConstraints:\n\n- For the first $ 50\\% $ of the testdata, $ n \\le 200 $.\n- For the remaining testdata, $ n \\le 600 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2013] 逃考", "background": "", "description": "髙考又来了，对于不认真读书的来讲真不是个好消息为了小杨能在家里认真读书，他的亲戚决定驻扎在他的家里监督他学习，有爷爷奶奶、外公外婆、大舅、大嫂、阿姨 ......。\n\n小杨实在是忍无可忍了，这种生活跟监狱有什么区别！为了他亲爱的小红，为了他的 dota， 他决定越狱！\n\n假设小杨的家是个 $n\\times m$ 的矩阵，左下角坐标为（$0,0)$，右上角坐标为（$x_1,y_1)$。小杨有 $n$ 个亲戚，驻扎在矩阵里（位置不同，且不在矩阵的边上）。小杨家里的每个地方都被亲戚监控着，而且只被距离最近的亲戚监控：\n\n也就是说假设小杨所在的位置是（$3,3)$, 亲戚 $A$ 在（$3,0)$，A 距离小杨距离是 $3$；亲戚 $B$ 在（$6,7),$ 则 $B$ 距离小杨距离是 $5$。距离 $A<$ 距离 $B$，所以（$3,3)$ 位置由 $A$ 监控。\n\n如果“最近距离”出现同时有几个亲戚，那么那个位置同时被那几个亲戚监控。\n\n给出小杨的坐标（$x_0,y_0)$。因为被发现的人数越少，越狱成功的机会越大，所以小杨需要你设计一条越狱路线到达矩形的边上，且被发现的人数最少。\n\n小杨做的方向是任意的，也就是说路线上的任意位置 $H$ 需要是实数。\n\n保证一开始小杨只被一个亲戚监控着。", "inputFormat": "第一行一个正整数 $t \\le 3$ 表示数据个数。\n\n接下来 $t$ 个数据：\n\n第一行 $n$ 表示亲戚个数。\n\n第二行 $4$ 个正整数表示举行右上角坐标 $(x_1,y_1)$ 和小杨的坐标 $(x_0,y_0)$。\n\n接下来 $n$ 行，每行 $2$ 个正整数表示一个亲戚的位置。", "outputFormat": "每个数据一个正整数表示越狱被发现人数的最小值\n", "hint": "数据解释 :。\n\n第一个数据，小杨直接往上走，只被 $(5,6)$ 监控过。\n\n第二个数据，小杨被 $(7,7)$ 监控 - 走到 $(9,9)$ 被 $(7,11)$ 监控，然后直接往上走。\n\n数据规模 :\n\n前 $50\\%$ 数据, $n \\le 200$。\n\n其余数据 $n \\le 600$。", "locale": "zh-CN"}}}
{"pid": "P3298", "type": "P", "difficulty": 6, "samples": [["3 3\n1 2 3 4 5 6\n1 2 3 0 0 0\n0 0 0 4 5 6", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "各省省选", "山东", "哈希 hashing", "容斥原理"], "title": "[SDOI2013] 泉", "background": null, "description": "作为光荣的济南泉历史研究小组中的一员，铭铭收集了历史上 $N$ 个不同年份时不同泉区的水流指数，这个指数是一个小于 $2^{30}$ 的非负整数。第 $i$ 个年份时六个泉区的泉水流量指数分别为 $A_{i,1} \\sim A_{i,6}$。\n\n现在铭铭希望知道有多少对不同的年份 $i$ 和 $j$（$i<j$），满足这两年恰好有 $K$ 个泉区的泉水水流指数对应相同。", "inputFormat": "第一行两个整数 $N,K$。\n\n下面 $N$ 行，每行 $6$ 个整数 $A_{i,1} \\sim A_{i,6}$。", "outputFormat": "一行一个整数表示答案。", "hint": "$1 \\le N \\le 10^5$，$0 \\le A_{i,j} \\le 2^{30}$，且保证 $K$ 在 $[0,1,2,3,4,5,6]$ 中均匀随机选取。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2013] Springs", "background": "", "description": "As a proud member of the Jinan Springs History Research Group, Mingming has collected, for $N$ different years, the flow index of different spring zones. This index is a non-negative integer less than $2^{30}$. In year $i$, the flow indices of the six spring zones are $A_{i,1} \\sim A_{i,6}$.\n\nNow Mingming wants to know how many pairs of different years $i$ and $j$ ($i < j$) have exactly $K$ spring zones whose flow indices are equal in those two years.", "inputFormat": "The first line contains two integers $N, K$.\n\nThe next $N$ lines each contain $6$ integers $A_{i,1} \\sim A_{i,6}$.", "outputFormat": "Output a single integer on one line, representing the answer.", "hint": "Constraints: $1 \\le N \\le 10^5$，$0 \\le A_{i,j} \\le 2^{30}$，且保证 $K$ 在 $[0,1,2,3,4,5,6]$ 中均匀随机选取。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2013] 泉", "background": null, "description": "作为光荣的济南泉历史研究小组中的一员，铭铭收集了历史上 $N$ 个不同年份时不同泉区的水流指数，这个指数是一个小于 $2^{30}$ 的非负整数。第 $i$ 个年份时六个泉区的泉水流量指数分别为 $A_{i,1} \\sim A_{i,6}$。\n\n现在铭铭希望知道有多少对不同的年份 $i$ 和 $j$（$i<j$），满足这两年恰好有 $K$ 个泉区的泉水水流指数对应相同。", "inputFormat": "第一行两个整数 $N,K$。\n\n下面 $N$ 行，每行 $6$ 个整数 $A_{i,1} \\sim A_{i,6}$。", "outputFormat": "一行一个整数表示答案。", "hint": "$1 \\le N \\le 10^5$，$0 \\le A_{i,j} \\le 2^{30}$，且保证 $K$ 在 $[0,1,2,3,4,5,6]$ 中均匀随机选取。", "locale": "zh-CN"}}}
{"pid": "P3299", "type": "P", "difficulty": 6, "samples": [["5  2\n3  3\n1  1\n10 8\n4  8\n2  3", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "各省省选", "山东", "凸包"], "title": "[SDOI2013] 保护出题人", "background": null, "description": "出题人铭铭认为给 SDOI2012 出题太可怕了，因为总要被骂，于是他又给 SDOI2013 出题了。\n\n\n参加 SDOI2012 的小朋友们释放出大量的僵尸，企图攻击铭铭的家。而你作为 SDOI2013 的参赛者，你需要保护出题人铭铭。\n\n\n僵尸从唯一一条笔直道路接近，你们需要在铭铭的房门前放置植物攻击僵尸，避免僵尸碰到房子。\n\n\n第一关，一只血量为 $a_1$ 点的僵尸从距离房子 $x_1$ 米处匀速接近，你们放置了攻击力为 $y_1$ 点/秒的植物进行防御；第二关，在上一关基础上，僵尸队列排头增加一只血量为 $a_2$ 点的僵尸，与后一只僵尸距离 $d$ 米，从距离房 $x_2$ 米处匀速接近，你们重新放置攻击力为 $y_2$ 点/秒的植物；……；第 $n$ 关，僵尸队列共有 $n$ 只僵尸，相邻两只僵尸距离 $d$ 米，排头僵尸血量为 $a_n$ 点，排第二的僵尸血量 $a_{n-1}$，以此类推，排头僵尸从距离房子 $x_n$ 米处匀速接近，其余僵尸跟随排头同时接近，你们重新放置攻击力为 $y_n$ 点/秒的植物。\n\n\n每只僵尸直线移动速度均为 $1$ 米/秒，由于植物射击速度远大于僵尸移动速度，可忽略植物子弹在空中的时间。所有僵尸同时出现并接近，因此当一只僵尸死亡后，下一只僵尸立刻开始受到植物子弹的伤害。\n\n\n游戏得分取决于你们放置的植物攻击力的总和 $\\sum \\limits _{i=1} ^{n} y_i$，和越小分数越高，为了追求分数上界，你们每关都要放置攻击力尽量小的植物。\n\n\n作为 SDOI2013 的参赛选手，你们能保护出题人么？", "inputFormat": "第一行两个空格隔开的正整数 $n$ 和 $d$，分别表示关数和相邻僵尸间的距离。\n\n接下来n行每行两个空格隔开的正整数，第 $i+1$ 行为 $A_i$ 和 $X_i$，分别表示相比上一关在僵尸队列排头增加血量为 $A_i$ 点的僵尸，排头僵尸从距离房子 $X_i$ 米处开始接近。", "outputFormat": "一个整数，$n$ 关植物攻击力的最小总和，四舍五入到个位。", "hint": "第一关：距离房子 $3$ 米处有一只血量 $3$ 点的僵尸，植物最小攻击力为 $1.00000$；  \n第二关：距离房子 $1$ 米处有一只血量 $1$ 点的僵尸、$3$ 米处有血量 $3$ 点的僵尸，植物最小攻击力为 $1.33333$；  \n第三关：距离房子 $8$ 米处有一只血量 $10$ 点的僵尸、$10$ 米处有血量 $1$ 点的僵尸、$12$ 米处有血量 $3$ 点的僵尸，植物最小攻击力为 $1.25000$；  \n第四关：距离房子 $8$ 米处有一只血量 $4$ 点的僵尸、$10$ 米处有血量 $10$ 点的僵尸、$12$ 米处有血量 $1$ 点的僵尸、$14$ 米处有血量 $3$ 点的僵尸，植物最小攻击力为 $1.40000$；  \n第五关：距离房子 $3$ 米处有一只血量 $2$ 点的僵尸、 $5$ 米处有血量 $4$ 点的僵尸、$7$ 米处有血量 $10$ 点的僵尸、$9$ 米处有血量 $1$ 点的僵尸、$11$ 米处有血量 $3$ 点的僵尸，植物最小攻击力为 $2.28571$。  \n植物攻击力的最小总和为 $7.26905$。\n\n对于 $100\\%$ 的数据， $ 1\\le n \\le 10^5  ,1 \\le d,x,a \\le 10^{12} $ 。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2013] Protect the Problem Setter", "background": "", "description": "The problem setter Mingming felt that making problems for SDOI2012 was too scary because he would always be blamed, so he made problems again for SDOI2013.\n\nThe kids who participated in SDOI2012 released many zombies, trying to attack Mingming’s home. As a contestant of SDOI2013, you need to protect the problem setter Mingming.\n\nZombies approach along a single straight road. You need to place plants in front of Mingming’s door to attack the zombies, preventing them from reaching the house.\n\nLevel 1: a single zombie with HP $a_1$ starts uniformly approaching from $x_1$ meters away, and you place a plant with attack power $y_1$ points/second to defend. Level 2: based on the previous level, add a new zombie with HP $a_2$ to the front of the queue, at distance $d$ from the next zombie, and the front zombie starts uniformly approaching from $x_2$ meters away; you re-place a plant with attack power $y_2$ points/second. ... Level $n$: there are $n$ zombies in total, adjacent zombies are $d$ meters apart, the front zombie has HP $a_n$, the second has HP $a_{n-1}$, and so on. The front zombie starts uniformly approaching from $x_n$ meters away, and the other zombies follow while approaching at the same time. You re-place a plant with attack power $y_n$ points/second.\n\nEach zombie moves in a straight line at speed $1$ m/s. Since the plants’ firing speed is much higher than the zombies’ movement speed, the bullet travel time in the air can be ignored. All zombies appear and start approaching at the same time. Therefore, when one zombie dies, the next zombie immediately starts taking damage from the plant.\n\nThe game score depends on the total attack power you place, $\\sum \\limits _{i=1} ^{n} y_i$. The smaller the sum, the higher the score. To pursue the best possible score, you should place plants with the smallest possible attack power at every level.\n\nAs a contestant of SDOI2013, can you protect the problem setter?", "inputFormat": "The first line contains two space-separated positive integers $n$ and $d$, representing the number of levels and the distance between adjacent zombies.\n\nThe next $n$ lines each contain two space-separated positive integers. The $(i+1)$-th line contains $A_i$ and $X_i$, meaning that compared to the previous level, a new zombie with HP $A_i$ is added to the front of the queue, and the front zombie starts approaching from a distance of $X_i$ meters from the house.", "outputFormat": "Output an integer: the minimal total attack power over the $n$ levels, rounded to the nearest integer.", "hint": "Level 1: there is one zombie with HP $3$ at distance $3$ meters from the house, and the minimal plant attack power is $1.00000$.  \nLevel 2: there is one zombie with HP $1$ at $1$ meter and one zombie with HP $3$ at $3$ meters, and the minimal plant attack power is $1.33333$.  \nLevel 3: there is one zombie with HP $10$ at $8$ meters, one with HP $1$ at $10$ meters, and one with HP $3$ at $12$ meters, and the minimal plant attack power is $1.25000$.  \nLevel 4: there is one zombie with HP $4$ at $8$ meters, one with HP $10$ at $10$ meters, one with HP $1$ at $12$ meters, and one with HP $3$ at $14$ meters, and the minimal plant attack power is $1.40000$.  \nLevel 5: there is one zombie with HP $2$ at $3$ meters, one with HP $4$ at $5$ meters, one with HP $10$ at $7$ meters, one with HP $1$ at $9$ meters, and one with HP $3$ at $11$ meters, and the minimal plant attack power is $2.28571$.  \nThe minimal total plant attack power is $7.26905$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $1 \\le d, x, a \\le 10^{12}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2013] 保护出题人", "background": null, "description": "出题人铭铭认为给 SDOI2012 出题太可怕了，因为总要被骂，于是他又给 SDOI2013 出题了。\n\n\n参加 SDOI2012 的小朋友们释放出大量的僵尸，企图攻击铭铭的家。而你作为 SDOI2013 的参赛者，你需要保护出题人铭铭。\n\n\n僵尸从唯一一条笔直道路接近，你们需要在铭铭的房门前放置植物攻击僵尸，避免僵尸碰到房子。\n\n\n第一关，一只血量为 $a_1$ 点的僵尸从距离房子 $x_1$ 米处匀速接近，你们放置了攻击力为 $y_1$ 点/秒的植物进行防御；第二关，在上一关基础上，僵尸队列排头增加一只血量为 $a_2$ 点的僵尸，与后一只僵尸距离 $d$ 米，从距离房 $x_2$ 米处匀速接近，你们重新放置攻击力为 $y_2$ 点/秒的植物；……；第 $n$ 关，僵尸队列共有 $n$ 只僵尸，相邻两只僵尸距离 $d$ 米，排头僵尸血量为 $a_n$ 点，排第二的僵尸血量 $a_{n-1}$，以此类推，排头僵尸从距离房子 $x_n$ 米处匀速接近，其余僵尸跟随排头同时接近，你们重新放置攻击力为 $y_n$ 点/秒的植物。\n\n\n每只僵尸直线移动速度均为 $1$ 米/秒，由于植物射击速度远大于僵尸移动速度，可忽略植物子弹在空中的时间。所有僵尸同时出现并接近，因此当一只僵尸死亡后，下一只僵尸立刻开始受到植物子弹的伤害。\n\n\n游戏得分取决于你们放置的植物攻击力的总和 $\\sum \\limits _{i=1} ^{n} y_i$，和越小分数越高，为了追求分数上界，你们每关都要放置攻击力尽量小的植物。\n\n\n作为 SDOI2013 的参赛选手，你们能保护出题人么？", "inputFormat": "第一行两个空格隔开的正整数 $n$ 和 $d$，分别表示关数和相邻僵尸间的距离。\n\n接下来n行每行两个空格隔开的正整数，第 $i+1$ 行为 $A_i$ 和 $X_i$，分别表示相比上一关在僵尸队列排头增加血量为 $A_i$ 点的僵尸，排头僵尸从距离房子 $X_i$ 米处开始接近。", "outputFormat": "一个整数，$n$ 关植物攻击力的最小总和，四舍五入到个位。", "hint": "第一关：距离房子 $3$ 米处有一只血量 $3$ 点的僵尸，植物最小攻击力为 $1.00000$；  \n第二关：距离房子 $1$ 米处有一只血量 $1$ 点的僵尸、$3$ 米处有血量 $3$ 点的僵尸，植物最小攻击力为 $1.33333$；  \n第三关：距离房子 $8$ 米处有一只血量 $10$ 点的僵尸、$10$ 米处有血量 $1$ 点的僵尸、$12$ 米处有血量 $3$ 点的僵尸，植物最小攻击力为 $1.25000$；  \n第四关：距离房子 $8$ 米处有一只血量 $4$ 点的僵尸、$10$ 米处有血量 $10$ 点的僵尸、$12$ 米处有血量 $1$ 点的僵尸、$14$ 米处有血量 $3$ 点的僵尸，植物最小攻击力为 $1.40000$；  \n第五关：距离房子 $3$ 米处有一只血量 $2$ 点的僵尸、 $5$ 米处有血量 $4$ 点的僵尸、$7$ 米处有血量 $10$ 点的僵尸、$9$ 米处有血量 $1$ 点的僵尸、$11$ 米处有血量 $3$ 点的僵尸，植物最小攻击力为 $2.28571$。  \n植物攻击力的最小总和为 $7.26905$。\n\n对于 $100\\%$ 的数据， $ 1\\le n \\le 10^5  ,1 \\le d,x,a \\le 10^{12} $ 。", "locale": "zh-CN"}}}
{"pid": "P3300", "type": "P", "difficulty": 7, "samples": [["4  4\n.O..\nO+O|\n.O.. \n..OO\n4\nQ 1 4\nC 2 4 + \nC 3 4 | \nQ 1 4", "2 \n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "线段树", "并查集", "各省省选", "山东"], "title": "[SDOI2013] 城市规划", "background": "", "description": "A 市的市长打算在海边开发一段地带。这个地带看成是一个 $N \\times M $ 的方格阵。每个格子可以是建筑、道路或者草地。这片地带是要出租给某些公司，但是这些公司的要求很奇怪。他们要求租给他们的建筑要通过道路形成一个连通块。同一个连通块只能租给一家公司。这个 $N\\times M$ 的方格阵是用字符组成的：`O`，`.`，`+`，`|`，`-`，其中 `O` 表示建筑，'.' 表示草地。`|`，`-`，`+` 表示道路，分别表示把上下，左右、上下左右的格子连起来。相邻的 `O` 表示这是一个建筑物。\n\n由于规划可能不太好，可能某些连通块里面只有道路，这里道路是不能出租的！由于最后这块地的选取可能有部分会与其他市共冋开发，所以最后会在这个 $N\\times M$ 中选取一段出来，最后选取出来的是一个 $N_i\\times M$（$0<N_1\\le N$）的地段。A 市的市长想弄要一个规划软件，支持以下功能：\n\n1. 改变一个格子。\n2. 询问某块地带有多少个带建筑的连通块。", "inputFormat": "第一行两个整数 $N, M$，如题意所示\n\n接下来的 $N$ 行，每行 $M$ 个字符表示这片地带的初始情况。  \n\n接下来的一行一个整数 $Q$，表示操作次数。接下来的 $Q$ 行，每行有两种格式：  \n- `C i j k` :  把第 $i$ 行第 $j$ 个格子修改成k；\n- `Q l r`:  询问 $(l, 1) (r, M)$ 这块地带连通块个数。  \n", "outputFormat": "对于每个询问中的 $Q$，输出一行，一个数字，表示当前的连通块个数。\n", "hint": "对于 $100\\%$ 的数据，$N\\le 100000, M\\le 6, Q\\le 10000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2013] Urban Planning", "background": "", "description": "The mayor of City A plans to develop a coastal strip, modeled as an $N \\times M$ grid. Each cell can be a building, a road, or grassland. The strip is to be leased to companies, but the requirements are unusual: the buildings leased to a company must form a single connected component through roads. Each connected component can be leased to only one company.\n\nThe $N \\times M$ grid is represented by the characters `O`, `.`, `+`, `|`, `-`, where `O` denotes a building, `.` denotes grassland. The symbols `|`, `-`, `+` denote roads, connecting up–down, left–right, and both up–down and left–right respectively. Orthogonally adjacent `O` cells are considered part of the same building.\n\nDue to imperfect planning, some connected components may contain only roads; such components cannot be leased. Since the final selected plot may be co-developed with other cities, at the time of querying we will select a sub-rectangle of size $N_i \\times M$ with $(0 < N_i \\le N)$. The mayor wants software that supports:\n1. Modifying a single cell.\n2. Querying how many connected components within a specified strip contain at least one building.", "inputFormat": "- The first line contains two integers $N, M$ as described.\n- The next $N$ lines each contain $M$ characters describing the initial state of the strip.\n- The next line contains an integer $Q$, the number of operations.\n- Each of the following $Q$ lines is in one of the following formats:\n  - `C i j k`: Change the cell at row $i$, column $j$ to character `k`.\n    - `k` is one of `O`, `.`, `+`, `|`, `-`.\n  - `Q l r`: Query the number of connected components that contain at least one building within the sub-rectangle with corners $(l, 1)$ and $(r, M)$.\n\nRows and columns are 1-indexed.", "outputFormat": "For each `Q` operation, output one line with a single integer: the current number of connected components that contain at least one building in the specified strip.", "hint": "Constraints: For $100\\%$ of the testdata, $N \\le 100000$, $M \\le 6$, $Q \\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2013] 城市规划", "background": "", "description": "A 市的市长打算在海边开发一段地带。这个地带看成是一个 $N \\times M $ 的方格阵。每个格子可以是建筑、道路或者草地。这片地带是要出租给某些公司，但是这些公司的要求很奇怪。他们要求租给他们的建筑要通过道路形成一个连通块。同一个连通块只能租给一家公司。这个 $N\\times M$ 的方格阵是用字符组成的：`O`，`.`，`+`，`|`，`-`，其中 `O` 表示建筑，'.' 表示草地。`|`，`-`，`+` 表示道路，分别表示把上下，左右、上下左右的格子连起来。相邻的 `O` 表示这是一个建筑物。\n\n由于规划可能不太好，可能某些连通块里面只有道路，这里道路是不能出租的！由于最后这块地的选取可能有部分会与其他市共冋开发，所以最后会在这个 $N\\times M$ 中选取一段出来，最后选取出来的是一个 $N_i\\times M$（$0<N_1\\le N$）的地段。A 市的市长想弄要一个规划软件，支持以下功能：\n\n1. 改变一个格子。\n2. 询问某块地带有多少个带建筑的连通块。", "inputFormat": "第一行两个整数 $N, M$，如题意所示\n\n接下来的 $N$ 行，每行 $M$ 个字符表示这片地带的初始情况。  \n\n接下来的一行一个整数 $Q$，表示操作次数。接下来的 $Q$ 行，每行有两种格式：  \n- `C i j k` :  把第 $i$ 行第 $j$ 个格子修改成k；\n- `Q l r`:  询问 $(l, 1) (r, M)$ 这块地带连通块个数。  \n", "outputFormat": "对于每个询问中的 $Q$，输出一行，一个数字，表示当前的连通块个数。\n", "hint": "对于 $100\\%$ 的数据，$N\\le 100000, M\\le 6, Q\\le 10000$。\n", "locale": "zh-CN"}}}
{"pid": "P3301", "type": "P", "difficulty": 6, "samples": [["3 10007\n3 1 1 6\n3 3\n3 0 0 5\n\n3 1 1 3\n3 3\n", "3\n6\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "各省省选", "山东", "中国剩余定理 CRT", "组合数学", "容斥原理"], "title": "[SDOI2013] 方程", "background": null, "description": "给定方程\n$x_1+x_2+\\dots +x_{n}=m$。\n\n我们对第 $1 \\sim n_1$ 个变量进行一些限制： $x_{1} \\le a_{1},x_{2} \\le a_{2},\\dots, x_{n_1} \\le a_{n_1}$。\n\n我们对第 $n_1+1\\sim n_1+n_2$ 个变量进行一些限制： $x_{n_1+1} \\ge a_{n_1+1},x_{n_1+2} \\ge a_{n_1+2},\\dots,x_{n_1+n_2} \\ge a_{n_1+n_2}$。\n\n求：在满足这些限制的前提下，该方程正整数解的个数。答案可能很大，请输出对 $p$ 取模后的答案。", "inputFormat": "输入含有多组数据。 \n\n第一行两个正整数 $T,p$。$T$  表示这个测试点内的数据组数，$p$ 的含义见题目描述。\n\n对于每组数据，第一行四个非负整数 $n,n_1,n_2,m$。 \n\n第二行 $n_1+n_2$ 个正整数，表示 $a_{1},a_2,\\dots, a_{n_1+n_2}$。请注意，如果 $n_1+n_2$ 等于 $0$，那么这一行会成为一个空行。", "outputFormat": "共 $T$ 行，每行一个正整数表示取模后的答案。", "hint": "**【样例解释】**\n\n对于第一组数据，三组解为 $(1,3,2)，(1,4,1),(2,3,1) $。  \n对于第二组数据，六组解为 $(1,1,3),(1,2,2),(1,3,1),(2,1,2),(2,2,1),(3,1,1)$。\n\n![](https://cdn.luogu.com.cn/upload/pic/17621.png)\n\n对于 $100\\%$ 的数据，$1\\le T \\le 5$，$1\\le m, n \\le 10^9$，$1 \\le a_i \\le m$，$0 \\le n_1,n_2 \\le \\min(8, m)$ 且 $n_1 + n_2 \\le n$，$1\\le p \\le 437367875$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2013] Equation", "background": "", "description": "Given the equation\n$x_1+x_2+\\dots +x_{n}=m$.\n\nWe impose restrictions on variables $1$ through $n_1$: $x_{1} \\le a_{1},x_{2} \\le a_{2},\\dots, x_{n_1} \\le a_{n_1}$.\n\nWe impose restrictions on variables $n_1+1$ through $n_1+n_2$: $x_{n_1+1} \\ge a_{n_1+1},x_{n_1+2} \\ge a_{n_1+2},\\dots,x_{n_1+n_2} \\ge a_{n_1+n_2}$.\n\nFind the number of positive integer solutions of the equation under these restrictions. The answer can be large; please output it modulo $p$.", "inputFormat": "Multiple test cases.\n\nThe first line contains two positive integers $T,p$. $T$ denotes the number of test cases in this file, and the meaning of $p$ is as described above.\n\nFor each test case, the first line contains four non-negative integers $n,n_1,n_2,m$.\n\nThe second line contains $n_1+n_2$ positive integers, denoting $a_{1},a_2,\\dots, a_{n_1+n_2}$. Note that if $n_1+n_2$ equals $0$, this line will be empty.", "outputFormat": "Output $T$ lines, each containing a single integer representing the answer modulo $p$.", "hint": "【Sample explanation】\n\nFor the first test case, the three solutions are $(1,3,2)$, $(1,4,1)$, $(2,3,1)$.\nFor the second test case, the six solutions are $(1,1,3)$, $(1,2,2)$, $(1,3,1)$, $(2,1,2)$, $(2,2,1)$, $(3,1,1)$.\n\n![](https://cdn.luogu.com.cn/upload/pic/17621.png)\n\nConstraints: For $100\\%$ of the testdata, $1\\le T \\le 5$, $1\\le m, n \\le 10^9$, $1 \\le a_i \\le m$, $0 \\le n_1,n_2 \\le \\min(8, m)$ and $n_1 + n_2 \\le n$, $1\\le p \\le 437367875$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2013] 方程", "background": null, "description": "给定方程\n$x_1+x_2+\\dots +x_{n}=m$。\n\n我们对第 $1 \\sim n_1$ 个变量进行一些限制： $x_{1} \\le a_{1},x_{2} \\le a_{2},\\dots, x_{n_1} \\le a_{n_1}$。\n\n我们对第 $n_1+1\\sim n_1+n_2$ 个变量进行一些限制： $x_{n_1+1} \\ge a_{n_1+1},x_{n_1+2} \\ge a_{n_1+2},\\dots,x_{n_1+n_2} \\ge a_{n_1+n_2}$。\n\n求：在满足这些限制的前提下，该方程正整数解的个数。答案可能很大，请输出对 $p$ 取模后的答案。", "inputFormat": "输入含有多组数据。 \n\n第一行两个正整数 $T,p$。$T$  表示这个测试点内的数据组数，$p$ 的含义见题目描述。\n\n对于每组数据，第一行四个非负整数 $n,n_1,n_2,m$。 \n\n第二行 $n_1+n_2$ 个正整数，表示 $a_{1},a_2,\\dots, a_{n_1+n_2}$。请注意，如果 $n_1+n_2$ 等于 $0$，那么这一行会成为一个空行。", "outputFormat": "共 $T$ 行，每行一个正整数表示取模后的答案。", "hint": "**【样例解释】**\n\n对于第一组数据，三组解为 $(1,3,2)，(1,4,1),(2,3,1) $。  \n对于第二组数据，六组解为 $(1,1,3),(1,2,2),(1,3,1),(2,1,2),(2,2,1),(3,1,1)$。\n\n![](https://cdn.luogu.com.cn/upload/pic/17621.png)\n\n对于 $100\\%$ 的数据，$1\\le T \\le 5$，$1\\le m, n \\le 10^9$，$1 \\le a_i \\le m$，$0 \\le n_1,n_2 \\le \\min(8, m)$ 且 $n_1 + n_2 \\le n$，$1\\le p \\le 437367875$。", "locale": "zh-CN"}}}
{"pid": "P3302", "type": "P", "difficulty": 6, "samples": [["1\n8 4 8\n1 1 2 2 3 3 4 4\n4 7\n1 8\n2 4\n2 1\nQ 8 7 3\nQ 3 5 1\nQ 10 0 0\nL 5 4\nL 3 2\nL 0 7\nQ 9 2 5\nQ 6 1 6", "2 \n2\n1\n4\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2013", "线段树", "各省省选", "山东", "深度优先搜索 DFS", "可持久化线段树", "启发式合并"], "title": "[SDOI2013] 森林", "background": "", "description": "小 Z 有一片森林，含有 $N$ 个节点，每个节点上都有一个非负整数作为权值。初始的时候，森林中有 $M$ 条边。\n\n小Z希望执行 $T$ 个操作，操作有两类：\n\n - `Q x y k` 查询点 $x$ 到点 $y$ 路径上所有的权值中，第 $k$ 小的权值是多少。此操作保证点 $x$ 和点 $y$ 连通，同时这两个节点的路径上至少有 $k$ 个点。\n - `L x y` 在点 $x$ 和点 $y$ 之间连接一条边。保证完成此操作后，仍然是一片森林。\n\n为了体现程序的在线性，我们把输入数据进行了加密。设 $lastans$ 为程序上一次输出的结果，初始的时候 $lastans$ 为 $0$。\n\n对于一个输入的操作 `Q x y k`，其真实操作为 `Q x^lastans y^lastans k^lastans`。\n\n对于一个输入的操作 `L x y`，其真实操作为 `L x^lastans y^lastans`。其中 `^` 运算符表示异或，等价于 Pascal 中的 `xor` 运算符。\n\n请写一个程序来帮助小 Z 完成这些操作。", "inputFormat": "第一行包含一个正整数 $\\mathrm{testcase}$，表示当前测试数据的测试点编号。\n\n第二行包含三个整数 $N,M,T$，分别表示节点数、初始边数、操作数。\n\n第三行包含 $N$ 个非负整数表示 $N$ 个节点上的权值。\n\n接下来 $M$ 行，每行包含两个整数 $x$ 和 $y$，表示初始的时候，点 $x$ 和点 $y$ 之间有一条无向边。\n\n接下来 $T$ 行，每行描述一个操作，格式为 `Q x y k` 或者 `L x y`，其含义见题目描述部分。", "outputFormat": "对于每一个第一类操作，输出一个非负整数表示答案。", "hint": "**样例解释**\n\n对于第一个操作 `Q 8 7 3`，此时 $lastans=0$，所以真实操作为 `Q 8^0 7^0 3^0`，也即 `Q 8 7 3`。点 $8$ 到点 $7$ 的路径上一共有 $5$ 个点，其权值为 $4\\ 1\\ 1\\ 2\\ 4$。这些权值中，第三小的为 $2$，输出 $2$，$lastans$ 变为 $2$。\n\n对于第二个操作 `Q 3 5 1` ，此时 $lastans=2$，所以真实操作为 `Q 3^2 5^2 1^2`，也即 `Q 1 7 3`。点 $1$ 到点 $7$ 的路径上一共有 $4$ 个点，其权值为 $1\\ 1\\ 2\\ 4$ 。这些权值中，第三小的为 $2$，输出 $2$，$lastans$ 变为 $2$。之后的操作类似。\n\n-----\n**数据范围**\n\n| 测试点编号  | $N,M,T$ 的上界 |  `L` 操作   |  `Q` 操作  | 形态 |\n| :---------: | :------------: | :---------: | :--------: | :--: |\n|     $1$     |      $20$      |     N/A     |    N/A     | N/A  |\n|     $2$     |     $200$      |     N/A     |    N/A     | N/A  |\n|  $3\\sim 4$  | $4\\times 10^4$ | 无 `L` 操作 |    N/A     |  链  |\n|  $5\\sim 6$  | $8\\times 10^4$ | 无 `L` 操作 |    N/A     |  链  |\n|  $7\\sim 9$  | $8\\times 10^4$ | 无 `L` 操作 | 保证 $k=1$ | N/A  |\n| $10\\sim 11$ | $4\\times 10^4$ |     N/A     | 保证 $k=1$ | N/A  |\n| $12\\sim 13$ | $8\\times 10^4$ |     N/A     | 保证 $k=1$ | N/A  |\n| $14\\sim 15$ | $4\\times 10^4$ | 无 `L` 操作 |    N/A     | N/A  |\n| $16\\sim 17$ | $8\\times 10^4$ | 无 `L` 操作 |    N/A     | N/A  |\n|    $18$     | $4\\times 10^4$ |     N/A     |    N/A     | N/A  |\n| $19\\sim 20$ | $8\\times 10^4$ |     N/A     |    N/A     | N/A  |\n\n注：N/A 表示没有特殊性。\n\n对于 $100\\%$ 的测试数据，所有节点的编号在 $1\\sim N$ 的范围内。节点上的权值 $\\le 10^9$。$M<N$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2013] Forest", "background": "", "description": "Xiao Z has a forest with $N$ nodes, and each node has a non-negative integer as its weight. Initially, there are $M$ edges in the forest.\n\nXiao Z wants to perform $T$ operations of two types:\n- `Q x y k` Query the $k$-th smallest weight among all the weights on the path from $x$ to $y$. It is guaranteed that $x$ and $y$ are connected, and there are at least $k$ nodes on this path.\n- `L x y` Add an edge between nodes $x$ and $y$. It is guaranteed that after this operation, the graph is still a forest.\n\nTo make the program online, the input is encrypted. Let $lastans$ be the last printed answer, initially $0$.\n\nFor an input operation `Q x y k`, the real operation is `Q x^lastans y^lastans k^lastans`.\n\nFor an input operation `L x y`, the real operation is `L x^lastans y^lastans`. Here the operator `^` denotes bitwise XOR, equivalent to `xor` in Pascal.\n\nPlease write a program to help Xiao Z finish these operations.", "inputFormat": "The first line contains a positive integer $\\mathrm{testcase}$, indicating the test point index of the current testdata.\n\nThe second line contains three integers $N, M, T$, denoting the number of nodes, the number of initial edges, and the number of operations, respectively.\n\nThe third line contains $N$ non-negative integers, representing the weights of the $N$ nodes.\n\nThe next $M$ lines each contain two integers $x$ and $y$, indicating that initially there is an undirected edge between $x$ and $y$.\n\nThe next $T$ lines each describe an operation, in the format `Q x y k` or `L x y`, as defined above.", "outputFormat": "For each operation of the first type, output a non-negative integer as the answer.", "hint": "Sample explanation:\n\nFor the first operation `Q 8 7 3`, at this time $lastans = 0$, so the real operation is `Q 8^0 7^0 3^0`, i.e., `Q 8 7 3`. There are $5$ nodes on the path from $8$ to $7$, and their weights are $4, 1, 1, 2, 4$. Among these weights, the $3$-rd smallest is $2$, so output $2$, and $lastans$ becomes $2$.\n\nFor the second operation `Q 3 5 1`, at this time $lastans = 2$, so the real operation is `Q 3^2 5^2 1^2`, i.e., `Q 1 7 3`. There are $4$ nodes on the path from $1$ to $7$, and their weights are $1, 1, 2, 4$. Among these weights, the $3$-rd smallest is $2$, so output $2$, and $lastans$ becomes $2$. The subsequent operations are similar.\n\n-----\n\nConstraints\n\n| Test point index | Upper bounds of $N, M, T$ | `L` operations | `Q` operations | Structure |\n| :--------------: | :-----------------------: | :------------: | :------------: | :-------: |\n|        $1$       |           $20$            |      N/A       |      N/A       |    N/A    |\n|        $2$       |           $200$           |      N/A       |      N/A       |    N/A    |\n|     $3\\sim 4$    |     $4\\times 10^4$        |  No `L` operations  |      N/A       |   Chain   |\n|     $5\\sim 6$    |     $8\\times 10^4$        |  No `L` operations  |      N/A       |   Chain   |\n|     $7\\sim 9$    |     $8\\times 10^4$        |  No `L` operations  | Guaranteed $k=1$ |    N/A    |\n|    $10\\sim 11$   |     $4\\times 10^4$        |      N/A       | Guaranteed $k=1$ |    N/A    |\n|    $12\\sim 13$   |     $8\\times 10^4$        |      N/A       | Guaranteed $k=1$ |    N/A    |\n|    $14\\sim 15$   |     $4\\times 10^4$        |  No `L` operations  |      N/A       |    N/A    |\n|    $16\\sim 17$   |     $8\\times 10^4$        |  No `L` operations  |      N/A       |    N/A    |\n|       $18$       |     $4\\times 10^4$        |      N/A       |      N/A       |    N/A    |\n|    $19\\sim 20$   |     $8\\times 10^4$        |      N/A       |      N/A       |    N/A    |\n\nNote: N/A means no special property.\n\nFor $100\\%$ of the testdata, all node indices are in the range $1 \\sim N$. Each node’s weight $\\le 10^9$. $M < N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2013] 森林", "background": "", "description": "小 Z 有一片森林，含有 $N$ 个节点，每个节点上都有一个非负整数作为权值。初始的时候，森林中有 $M$ 条边。\n\n小Z希望执行 $T$ 个操作，操作有两类：\n\n - `Q x y k` 查询点 $x$ 到点 $y$ 路径上所有的权值中，第 $k$ 小的权值是多少。此操作保证点 $x$ 和点 $y$ 连通，同时这两个节点的路径上至少有 $k$ 个点。\n - `L x y` 在点 $x$ 和点 $y$ 之间连接一条边。保证完成此操作后，仍然是一片森林。\n\n为了体现程序的在线性，我们把输入数据进行了加密。设 $lastans$ 为程序上一次输出的结果，初始的时候 $lastans$ 为 $0$。\n\n对于一个输入的操作 `Q x y k`，其真实操作为 `Q x^lastans y^lastans k^lastans`。\n\n对于一个输入的操作 `L x y`，其真实操作为 `L x^lastans y^lastans`。其中 `^` 运算符表示异或，等价于 Pascal 中的 `xor` 运算符。\n\n请写一个程序来帮助小 Z 完成这些操作。", "inputFormat": "第一行包含一个正整数 $\\mathrm{testcase}$，表示当前测试数据的测试点编号。\n\n第二行包含三个整数 $N,M,T$，分别表示节点数、初始边数、操作数。\n\n第三行包含 $N$ 个非负整数表示 $N$ 个节点上的权值。\n\n接下来 $M$ 行，每行包含两个整数 $x$ 和 $y$，表示初始的时候，点 $x$ 和点 $y$ 之间有一条无向边。\n\n接下来 $T$ 行，每行描述一个操作，格式为 `Q x y k` 或者 `L x y`，其含义见题目描述部分。", "outputFormat": "对于每一个第一类操作，输出一个非负整数表示答案。", "hint": "**样例解释**\n\n对于第一个操作 `Q 8 7 3`，此时 $lastans=0$，所以真实操作为 `Q 8^0 7^0 3^0`，也即 `Q 8 7 3`。点 $8$ 到点 $7$ 的路径上一共有 $5$ 个点，其权值为 $4\\ 1\\ 1\\ 2\\ 4$。这些权值中，第三小的为 $2$，输出 $2$，$lastans$ 变为 $2$。\n\n对于第二个操作 `Q 3 5 1` ，此时 $lastans=2$，所以真实操作为 `Q 3^2 5^2 1^2`，也即 `Q 1 7 3`。点 $1$ 到点 $7$ 的路径上一共有 $4$ 个点，其权值为 $1\\ 1\\ 2\\ 4$ 。这些权值中，第三小的为 $2$，输出 $2$，$lastans$ 变为 $2$。之后的操作类似。\n\n-----\n**数据范围**\n\n| 测试点编号  | $N,M,T$ 的上界 |  `L` 操作   |  `Q` 操作  | 形态 |\n| :---------: | :------------: | :---------: | :--------: | :--: |\n|     $1$     |      $20$      |     N/A     |    N/A     | N/A  |\n|     $2$     |     $200$      |     N/A     |    N/A     | N/A  |\n|  $3\\sim 4$  | $4\\times 10^4$ | 无 `L` 操作 |    N/A     |  链  |\n|  $5\\sim 6$  | $8\\times 10^4$ | 无 `L` 操作 |    N/A     |  链  |\n|  $7\\sim 9$  | $8\\times 10^4$ | 无 `L` 操作 | 保证 $k=1$ | N/A  |\n| $10\\sim 11$ | $4\\times 10^4$ |     N/A     | 保证 $k=1$ | N/A  |\n| $12\\sim 13$ | $8\\times 10^4$ |     N/A     | 保证 $k=1$ | N/A  |\n| $14\\sim 15$ | $4\\times 10^4$ | 无 `L` 操作 |    N/A     | N/A  |\n| $16\\sim 17$ | $8\\times 10^4$ | 无 `L` 操作 |    N/A     | N/A  |\n|    $18$     | $4\\times 10^4$ |     N/A     |    N/A     | N/A  |\n| $19\\sim 20$ | $8\\times 10^4$ |     N/A     |    N/A     | N/A  |\n\n注：N/A 表示没有特殊性。\n\n对于 $100\\%$ 的测试数据，所有节点的编号在 $1\\sim N$ 的范围内。节点上的权值 $\\le 10^9$。$M<N$。", "locale": "zh-CN"}}}
{"pid": "P3303", "type": "P", "difficulty": 6, "samples": [["12 5", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2013", "各省省选", "山东", "数位 DP"], "title": "[SDOI2013] 淘金", "background": "", "description": "小 Z 在玩一个叫做《淘金者》的游戏。游戏的世界是一个二维坐标。$X$ 轴、$Y$ 轴坐标范围均为$1\\ldots N$。初始的时候，所有的整数坐标点上均有一块金子，共 $N^2$ 块。\n\n一阵风吹过，金子的位置发生了一些变化。细心的小 Z 发现，初始在 $(i,j)$ 坐标处的金子会变到 $(f(i),f(j))$ 坐标处。其中 $f(x)$ 表示 $x$ 各位数字的乘积，例如 $f(99)=81,~f(12)=2,~f(10)=0$。\n\n如果金子变化后的坐标不在 $1\\ldots N$ 的范围内，我们认为这块金子已经被移出游戏。同时可以发现，对于变化之后的游戏局面，某些坐标上的金子数量可能不止一块，而另外一些坐标上可能已经没有金子。这次变化之后，游戏将不会再对金子的位置和数量进行改变，玩家可以开始进行采集工作。\n\n小 Z 很懒，打算只进行 $K$ 次采集。每次采集可以得到某一个坐标上的所有金子，采集之后，该坐标上的金子数变为 $0$。\n\n现在小 Z 希望知道，对于变化之后的游戏局面，在采集次数为 $K$ 的前提下，最多可以采集到多少块金子？ 答案可能很大，小 Z 希望得到对 $10^9+7$ 取模之后的答案。", "inputFormat": "共一行，包含两个正整数 $N, K$。\n", "outputFormat": "一个整数，表示最多可以采集到的金子数量。\n", "hint": "对于 $100\\%$ 的数据，$N \\leq 10^{12}, K \\leq \\min(N^2, 10^5)$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2013] Gold Mining", "background": "", "description": "Xiao Z is playing a game called \"Prospector.\" The game world is a 2D coordinate plane. The ranges of the $X$-axis and $Y$-axis coordinates are both $1\\ldots N$. Initially, there is one piece of gold at every integer coordinate point, for a total of $N^2$ pieces.\n\nA gust of wind blows by, and the positions of the gold pieces change. The observant Xiao Z notices that the piece initially at $(i,j)$ will move to $(f(i),f(j))$. Here $f(x)$ denotes the product of the digits of $x$, for example $f(99)=81,~f(12)=2,~f(10)=0$.\n\nIf the new coordinates of a piece of gold fall outside the range $1\\ldots N$, we consider this piece to have been removed from the game. It can also be observed that in the resulting state, some coordinates may have more than one piece of gold, while some coordinates may have none. After this change, the game will no longer alter the positions or quantities of gold; the player can begin collecting.\n\nXiao Z is lazy and plans to perform only $K$ collections. Each collection can obtain all the gold at a single coordinate; after collecting, the number of gold pieces at that coordinate becomes $0$.\n\nNow Xiao Z wants to know, in the resulting game state, with $K$ collections, what is the maximum number of gold pieces that can be collected? The answer may be large, so Xiao Z wants the answer modulo $10^9+7$.", "inputFormat": "One line containing two positive integers $N, K$.", "outputFormat": "A single integer, the maximum number of gold pieces that can be collected.", "hint": "For $100\\%$ of the testdata, $N \\leq 10^{12}, K \\leq \\min(N^2, 10^5)$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2013] 淘金", "background": "", "description": "小 Z 在玩一个叫做《淘金者》的游戏。游戏的世界是一个二维坐标。$X$ 轴、$Y$ 轴坐标范围均为$1\\ldots N$。初始的时候，所有的整数坐标点上均有一块金子，共 $N^2$ 块。\n\n一阵风吹过，金子的位置发生了一些变化。细心的小 Z 发现，初始在 $(i,j)$ 坐标处的金子会变到 $(f(i),f(j))$ 坐标处。其中 $f(x)$ 表示 $x$ 各位数字的乘积，例如 $f(99)=81,~f(12)=2,~f(10)=0$。\n\n如果金子变化后的坐标不在 $1\\ldots N$ 的范围内，我们认为这块金子已经被移出游戏。同时可以发现，对于变化之后的游戏局面，某些坐标上的金子数量可能不止一块，而另外一些坐标上可能已经没有金子。这次变化之后，游戏将不会再对金子的位置和数量进行改变，玩家可以开始进行采集工作。\n\n小 Z 很懒，打算只进行 $K$ 次采集。每次采集可以得到某一个坐标上的所有金子，采集之后，该坐标上的金子数变为 $0$。\n\n现在小 Z 希望知道，对于变化之后的游戏局面，在采集次数为 $K$ 的前提下，最多可以采集到多少块金子？ 答案可能很大，小 Z 希望得到对 $10^9+7$ 取模之后的答案。", "inputFormat": "共一行，包含两个正整数 $N, K$。\n", "outputFormat": "一个整数，表示最多可以采集到的金子数量。\n", "hint": "对于 $100\\%$ 的数据，$N \\leq 10^{12}, K \\leq \\min(N^2, 10^5)$。\n", "locale": "zh-CN"}}}
{"pid": "P3304", "type": "P", "difficulty": 4, "samples": [["6\n3 1 1000\n1 4 10\n4 2 100\n4 5 50\n4 6 100", "1110 \n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "各省省选", "山东", "深度优先搜索 DFS", "树的直径"], "title": "[SDOI2013] 直径", "background": null, "description": "小 Q 最近学习了一些图论知识。根据课本，有如下定义。树：无回路且连通的无向图，每条边都有正整数的权值来表示其长度。如果一棵树有 $N$ 个节点，可以证明其有且仅有 $N-1$ 条边。\n\n路径：一棵树上，任意两个节点之间最多有一条简单路径。我们用 $\\text{dis}(a,b)$ 表示点 $a$ 和点 $b$ 的路径上各边长度之和。称 $\\text{dis}(a,b)$ 为 $a,b$ 两个节点间的距离。\n\n直径：一棵树上，最长的路径为树的直径。树的直径可能不是唯一的。\n\n现在小 Q 想知道，对于给定的一棵树，其直径的长度是多少，以及有多少条边满足所有的直径都经过该边。", "inputFormat": "第一行包含一个整数 $N$，表示节点数。\n\n接下来 $N-1$ 行，每行三个整数 $a,b,c$，表示点 $a$ 和点 $b$ 之间有一条长度为 $c$ 的无向边。", "outputFormat": "共两行。第一行一个整数，表示直径的长度。第二行一个整数，表示被所有直径经过的边的数量。", "hint": "【样例说明】 \n\n直径共有两条，$3$ 到 $2$ 的路径和 $3$ 到 $6$ 的路径。这两条直径都经过边 $(3,1)$ 和边 $(1, 4)$。\n\n对于 $100\\%$ 的测试数据：$2\\le N\\le 2\\times 10^5$，$1\\le a,b\\le N$，$0\\le c \\le10^9$。输入的图构成一棵树。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2013] Diameter", "background": "", "description": "Xiao Q recently learned some graph theory. According to the textbook, we have the following definitions. A tree is an undirected graph that is connected and acyclic, where each edge has a positive integer weight representing its length. If a tree has $N$ nodes, it can be shown that it has exactly $N-1$ edges.\n\nPath: In a tree, between any two nodes there exists at most one simple path. We use $\\text{dis}(a,b)$ to denote the sum of the lengths of the edges on the path between $a$ and $b$. We call $\\text{dis}(a,b)$ the distance between nodes $a$ and $b$.\n\nDiameter: In a tree, the longest path is called the diameter of the tree. The tree’s diameter may not be unique.\n\nNow Xiao Q wants to know, for a given tree, what the length of its diameter is, and how many edges are traversed by all diameters.", "inputFormat": "The first line contains an integer $N$, the number of nodes.\n\nThe next $N-1$ lines each contain three integers $a,b,c$, indicating there is an undirected edge of length $c$ between nodes $a$ and $b$.", "outputFormat": "Output two lines. The first line contains one integer, the length of the diameter. The second line contains one integer, the number of edges that are traversed by all diameters.", "hint": "[Sample Explanation]\n\nThere are two diameters: the path from $3$ to $2$ and the path from $3$ to $6$. Both diameters pass through edge $(3,1)$ and edge $(1,4)$.\n\nFor $100\\%$ of the testdata: $2 \\le N \\le 2 \\times 10^5$, $1 \\le a,b \\le N$, $0 \\le c \\le 10^9$. The input graph forms a tree.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2013] 直径", "background": null, "description": "小 Q 最近学习了一些图论知识。根据课本，有如下定义。树：无回路且连通的无向图，每条边都有正整数的权值来表示其长度。如果一棵树有 $N$ 个节点，可以证明其有且仅有 $N-1$ 条边。\n\n路径：一棵树上，任意两个节点之间最多有一条简单路径。我们用 $\\text{dis}(a,b)$ 表示点 $a$ 和点 $b$ 的路径上各边长度之和。称 $\\text{dis}(a,b)$ 为 $a,b$ 两个节点间的距离。\n\n直径：一棵树上，最长的路径为树的直径。树的直径可能不是唯一的。\n\n现在小 Q 想知道，对于给定的一棵树，其直径的长度是多少，以及有多少条边满足所有的直径都经过该边。", "inputFormat": "第一行包含一个整数 $N$，表示节点数。\n\n接下来 $N-1$ 行，每行三个整数 $a,b,c$，表示点 $a$ 和点 $b$ 之间有一条长度为 $c$ 的无向边。", "outputFormat": "共两行。第一行一个整数，表示直径的长度。第二行一个整数，表示被所有直径经过的边的数量。", "hint": "【样例说明】 \n\n直径共有两条，$3$ 到 $2$ 的路径和 $3$ 到 $6$ 的路径。这两条直径都经过边 $(3,1)$ 和边 $(1, 4)$。\n\n对于 $100\\%$ 的测试数据：$2\\le N\\le 2\\times 10^5$，$1\\le a,b\\le N$，$0\\le c \\le10^9$。输入的图构成一棵树。", "locale": "zh-CN"}}}
{"pid": "P3305", "type": "P", "difficulty": 6, "samples": [["3 2 1\n1 2 10\n2 3 15", "10\n10.0000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "二分", "各省省选", "网络流", "山东", "Special Judge"], "title": "[SDOI2013] 费用流", "background": "", "description": "Alice 和 Bob 在图论课程上学习了最大流和最小费用最大流的相关知识。\n\n> 最大流问题：给定一张有向图表示运输网络，一个源点 $S$ 和一个汇点 $T$ ，每条边都有最大流量。\n> \n> 一个合法的网络流方案必须满足：\n> \n> 1. 每条边的实际流量都不超过其最大流量且非负；\n> 2. 除了源点 $S$ 和汇点 $T$ 之外，对于其余所有点，都满足该点总流入流量等于该点总流出流量；而 $S$ 点的净流出流量等于 $T$ 点的净流入流量，这个值也即该网络流方案的总运输量。\n>\n> 最大流问题就是对于给定的运输网络，求总运输量最大的网络流方案。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/20ipdo37.png)\n\n上图表示了一个最大流问题。对于每条边，右边的数代表该边的最大流量，左边的数代表在最优解中，该边的实际流量。需要注意到，一个最大流问题的解可能不是唯一的。\n\n对于一张给定的运输网络，Alice 先确定一个最大流，如果有多种解，Alice 可以任选一种；之后 Bob 在每条边上分配单位花费（单位花费必须是非负实数），要求所有边的单位花费之和等于 $P$。\n\n总费用等于每一条边的实际流量乘以该边的单位花费。需要注意到，Bob 在分配单位花费之前，已经知道 Alice 所给出的最大流方案。现在 Alice 希望总费用尽量小，而 Bob 希望总费用尽量大。我们想知道，如果两个人都执行最优策略，最大流的值和总费用分别为多少。\n", "inputFormat": "第一行三个整数 $N,M,P$。$N$ 表示给定运输网络中节点的数量，$M$ 表示有向边的数量，$P$ 的含义见问题描述部分。为了简化问题，我们假设源点 $S$ 是点 $1$，汇点 $T$ 是点 $N$。\n\n接下来 $M$ 行，每行三个整数 $A,B,C$，表示有一条从点 $A$ 到点 $B$ 的有向边，其最大流量是 $C$。", "outputFormat": "第一行一个整数，表示最大流的值。第二行一个实数，表示总费用。建议选手输出四位以上小数。\n", "hint": "**【样例说明】**\n\n对于 Alice，最大流的方案是固定的。两条边的实际流量都为 $10$。\n\n对于 Bob，给第一条边分配 $0.5$ 的费用，第二条边分配 $0.5$ 的费用。总费用为：$10\\times 0.5+10\\times 0.5=10$。可以证明不存在总费用更大的分配方案。\n\n**【数据规模和约定】**\n\n对于 $20\\%$ 的测试数据，所有有向边的最大流量都是 $1$。\n\n对于 $100\\%$ 的测试数据，$N\\le 100$，$M\\le 1000$。\n\n对于 $100\\%$ 的测试数据：所有点的编号在 $1\\sim N$ 范围内，$1 \\le \\text{每条边的最大流量} \\le 50000$，$1\\le P\\le 10$，给定运输网络中不会有起点和终点相同的边。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2013] Cost Flow", "background": "", "description": "Alice and Bob studied maximum flow and minimum-cost maximum flow in their graph theory course.\n\n> Maximum flow problem: Given a directed graph representing a transportation network, a source $S$ and a sink $T$, each edge has a maximum capacity.\n> \n> A valid network flow must satisfy:\n> \n> 1. The actual flow on every edge is non-negative and does not exceed its capacity;\n> 2. Except for the source $S$ and the sink $T$, for every other vertex, the total inflow equals the total outflow; the net outflow from $S$ equals the net inflow to $T$, and this value is the total shipped amount (the value of the flow).\n>\n> The maximum flow problem is to find, for the given network, a flow with the maximum total shipped amount.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/20ipdo37.png)\n\nThe figure above illustrates a maximum flow instance. For each edge, the number on the right is the edge capacity, and the number on the left is the actual flow on that edge in an optimal solution. Note that a maximum flow solution may not be unique.\n\nFor a given transportation network, Alice first determines a maximum flow. If there are multiple solutions, Alice may choose any one of them. After that, Bob assigns a unit cost to each edge (each unit cost must be a non-negative real number), subject to the constraint that the sum of unit costs over all edges equals $P$.\n\nThe total cost equals the actual flow on each edge multiplied by its unit cost, summed over all edges. Note that Bob knows the maximum flow solution chosen by Alice before assigning unit costs. Alice wants to minimize the total cost, while Bob wants to maximize it. We want to know, if both players use optimal strategies, what are the maximum flow value and the total cost.", "inputFormat": "The first line contains three integers $N, M, P$. $N$ is the number of vertices in the transportation network, $M$ is the number of directed edges, and $P$ is as defined in the statement. To simplify the problem, assume the source $S$ is vertex $1$ and the sink $T$ is vertex $N$.\n\nEach of the next $M$ lines contains three integers $A, B, C$, indicating a directed edge from $A$ to $B$ with capacity $C$.", "outputFormat": "Output two lines. The first line contains an integer, the maximum flow value. The second line contains a real number, the total cost. It is recommended to print at least 4 decimal places.", "hint": "**【Sample Explanation】**\n\nFor Alice, the maximum flow is fixed. The actual flow on both edges is $10$.\n\nFor Bob, assign a cost of $0.5$ to the first edge and $0.5$ to the second edge. The total cost is $10 \\times 0.5 + 10 \\times 0.5 = 10$. It can be proven that no assignment yields a larger total cost.\n\n**【Constraints】**\n\nFor $20\\%$ of the testdata, the capacity of every directed edge is $1$.\n\nFor $100\\%$ of the testdata, $N \\le 100$, $M \\le 1000$.\n\nFor $100\\%$ of the testdata: all vertex labels are in the range $1 \\sim N$, $1 \\le \\text{capacity of each edge} \\le 50000$, $1 \\le P \\le 10$, and there are no self-loop edges.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2013] 费用流", "background": "", "description": "Alice 和 Bob 在图论课程上学习了最大流和最小费用最大流的相关知识。\n\n> 最大流问题：给定一张有向图表示运输网络，一个源点 $S$ 和一个汇点 $T$ ，每条边都有最大流量。\n> \n> 一个合法的网络流方案必须满足：\n> \n> 1. 每条边的实际流量都不超过其最大流量且非负；\n> 2. 除了源点 $S$ 和汇点 $T$ 之外，对于其余所有点，都满足该点总流入流量等于该点总流出流量；而 $S$ 点的净流出流量等于 $T$ 点的净流入流量，这个值也即该网络流方案的总运输量。\n>\n> 最大流问题就是对于给定的运输网络，求总运输量最大的网络流方案。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/20ipdo37.png)\n\n上图表示了一个最大流问题。对于每条边，右边的数代表该边的最大流量，左边的数代表在最优解中，该边的实际流量。需要注意到，一个最大流问题的解可能不是唯一的。\n\n对于一张给定的运输网络，Alice 先确定一个最大流，如果有多种解，Alice 可以任选一种；之后 Bob 在每条边上分配单位花费（单位花费必须是非负实数），要求所有边的单位花费之和等于 $P$。\n\n总费用等于每一条边的实际流量乘以该边的单位花费。需要注意到，Bob 在分配单位花费之前，已经知道 Alice 所给出的最大流方案。现在 Alice 希望总费用尽量小，而 Bob 希望总费用尽量大。我们想知道，如果两个人都执行最优策略，最大流的值和总费用分别为多少。\n", "inputFormat": "第一行三个整数 $N,M,P$。$N$ 表示给定运输网络中节点的数量，$M$ 表示有向边的数量，$P$ 的含义见问题描述部分。为了简化问题，我们假设源点 $S$ 是点 $1$，汇点 $T$ 是点 $N$。\n\n接下来 $M$ 行，每行三个整数 $A,B,C$，表示有一条从点 $A$ 到点 $B$ 的有向边，其最大流量是 $C$。", "outputFormat": "第一行一个整数，表示最大流的值。第二行一个实数，表示总费用。建议选手输出四位以上小数。\n", "hint": "**【样例说明】**\n\n对于 Alice，最大流的方案是固定的。两条边的实际流量都为 $10$。\n\n对于 Bob，给第一条边分配 $0.5$ 的费用，第二条边分配 $0.5$ 的费用。总费用为：$10\\times 0.5+10\\times 0.5=10$。可以证明不存在总费用更大的分配方案。\n\n**【数据规模和约定】**\n\n对于 $20\\%$ 的测试数据，所有有向边的最大流量都是 $1$。\n\n对于 $100\\%$ 的测试数据，$N\\le 100$，$M\\le 1000$。\n\n对于 $100\\%$ 的测试数据：所有点的编号在 $1\\sim N$ 范围内，$1 \\le \\text{每条边的最大流量} \\le 50000$，$1\\le P\\le 10$，给定运输网络中不会有起点和终点相同的边。\n", "locale": "zh-CN"}}}
{"pid": "P3306", "type": "P", "difficulty": 5, "samples": [["3\n7 1 1 3 3\n7 2 2 2 0\n7 2 2 2 1\n", "1 \n3 \n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "各省省选", "数论", "山东", "O2优化", "逆元", "大步小步算法 BSGS"], "title": "[SDOI2013] 随机数生成器", "background": "小 W 喜欢读书，尤其喜欢读《约翰克里斯朵夫》。", "description": "最近小 W 准备读一本新书，这本书一共有 $p$ 页，页码范围为 $0 \\sim p-1$。\n\n小 W 很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用 NOI2012 上学习的线性同余法生成一个序列，来决定每天具体读哪一页。\n\n我们用 $x_i$ 来表示通过这种方法生成出来的第 $i$ 个数，也即小 W 第 $i$ 天会读哪一页。这个方法需要设置 $3$ 个参数 $a,b,x_1$，满足 $0\\leq a,b,x_1\\lt p$，且 $a,b,x_1$ 都是整数。按照下面的公式生成出来一系列的整数：\n$$x_{i+1} \\equiv a \\times x_i+b \\pmod p$$\n其中 $\\bmod$ 表示取余操作。\n\n但是这种方法可能导致某两天读的页码一样。\n\n小 W 要读这本书的第 $t$ 页，所以他想知道最早在哪一天能读到第 $t$ 页，或者指出他永远不会读到第 $t$ 页。\n", "inputFormat": "**本题单测试点内有多组测试数据**。\n\n第一行是一个整数 $T$，表示测试数据组数。\n\n接下来 $T$ 行，每行有五个整数 $p, a, b, x_1, t$，表示一组数据。\n", "outputFormat": "对于每组数据，输出一行一个整数表示他最早读到第 $t$ 页是哪一天。如果他永远不会读到第 $t$ 页，输出$-1$。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq T \\leq 50$。\n- $0 \\leq a, b, x_1, t \\lt p$，$2 \\leq p \\leq 10^9$。\n- $p$ 为质数。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2013] Random Number Generator", "background": "Xiao W likes reading, and especially enjoys reading \"Jean-Christophe\".", "description": "Recently, Xiao W plans to read a new book that has $p$ pages, with page numbers ranging from $0 \\sim p-1$.\n\nXiao W is busy, so he can read only one page per day. To make things a bit more interesting, he plans to use the linear congruential method he learned at NOI2012 to generate a sequence to decide which page to read each day.\n\nLet $x_i$ denote the $i$-th number generated by this method, i.e., the page Xiao W will read on day $i$. This method requires three parameters $a, b, x_1$, satisfying $0 \\leq a, b, x_1 \\lt p$, and $a, b, x_1$ are integers. A sequence of integers is generated according to the following formula:\n$$x_{i+1} \\equiv a \\times x_i + b \\pmod p$$\nHere, $\\bmod$ denotes the remainder operation.\n\nHowever, this method may cause the same page number to be read on two different days.\n\nXiao W wants to read page $t$ of this book, so he wants to know the earliest day on which he can read page $t$, or determine that he will never read page $t$.", "inputFormat": "This problem contains multiple test cases in a single test point.\n\nThe first line contains an integer $T$, the number of test cases.\n\nEach of the next $T$ lines contains five integers $p, a, b, x_1, t$, representing one test case.", "outputFormat": "For each test case, output one line with a single integer indicating the earliest day on which he reads page $t$. If he will never read page $t$, output $-1$.", "hint": "#### Constraints\n\n- $1 \\leq T \\leq 50$.\n- $0 \\leq a, b, x_1, t \\lt p$, $2 \\leq p \\leq 10^9$.\n- $p$ is a prime.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2013] 随机数生成器", "background": "小 W 喜欢读书，尤其喜欢读《约翰克里斯朵夫》。", "description": "最近小 W 准备读一本新书，这本书一共有 $p$ 页，页码范围为 $0 \\sim p-1$。\n\n小 W 很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用 NOI2012 上学习的线性同余法生成一个序列，来决定每天具体读哪一页。\n\n我们用 $x_i$ 来表示通过这种方法生成出来的第 $i$ 个数，也即小 W 第 $i$ 天会读哪一页。这个方法需要设置 $3$ 个参数 $a,b,x_1$，满足 $0\\leq a,b,x_1\\lt p$，且 $a,b,x_1$ 都是整数。按照下面的公式生成出来一系列的整数：\n$$x_{i+1} \\equiv a \\times x_i+b \\pmod p$$\n其中 $\\bmod$ 表示取余操作。\n\n但是这种方法可能导致某两天读的页码一样。\n\n小 W 要读这本书的第 $t$ 页，所以他想知道最早在哪一天能读到第 $t$ 页，或者指出他永远不会读到第 $t$ 页。\n", "inputFormat": "**本题单测试点内有多组测试数据**。\n\n第一行是一个整数 $T$，表示测试数据组数。\n\n接下来 $T$ 行，每行有五个整数 $p, a, b, x_1, t$，表示一组数据。\n", "outputFormat": "对于每组数据，输出一行一个整数表示他最早读到第 $t$ 页是哪一天。如果他永远不会读到第 $t$ 页，输出$-1$。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq T \\leq 50$。\n- $0 \\leq a, b, x_1, t \\lt p$，$2 \\leq p \\leq 10^9$。\n- $p$ 为质数。", "locale": "zh-CN"}}}
{"pid": "P3307", "type": "P", "difficulty": 6, "samples": [["1\n2  2", "3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2013", "各省省选", "山东", "最大公约数 gcd", "莫比乌斯反演", "逆元"], "title": "[SDOI2013] 项链", "background": "项链作为人体的装饰品之一，是最早出现的首饰。项链除了具有装饰功能之外，有些项链还具有特殊的显示作用，如天主教徒的十字架链和佛教徒的念珠。\n\n从古至今人们为了美化人体本身，也美化环境，制造了各种不同风格、不同特点、不同样式的项链，满足了不同肤色、不同民族、不同审美观的人的审美需要。就材料而论，首饰市场上的项链有黄金、白银、珠宝等几种。\n\n珍珠项链为珍珠制成的饰品，即将珍珠钻孔后用线串在一起，佩戴于项间，天然珍珠项链具有一定的护养作用。", "description": "最近，铭铭迷恋上了一种项链。与其他珍珠项链基本上相同，不过这种项链的珠子却与众不同，是正三菱柱的泰山石雕刻而成的。\n\n三菱柱的侧面是由正方形构成的，每个侧面都刻有数字。能够让铭铭满意的项链必须满足以下条件：\n\n1. 这串项链由 $n$ 颗珠子构成。\n\n2. 每一个珠子上面的每个数字 $x$，必须满足 $0<x\\le a$，且珠子上面三个数字的最大公约数要恰好为 $1$。\n\n3. 相邻的两个珠子必须不同。两个珠子被认为是相同的，当且仅当它们经过旋转，或者翻转后能够变成一样的。\n\n4. 两串项链如果能够经过旋转变成一样的，那么这两串项链被认为是相同的。 \n\n铭铭很好奇如果给定 $n$ 和 $a$，能够找到多少串不同的项链。由于答案可能很大，所以输出答案模上 $10^{9}+7$ 的值。", "inputFormat": "**本题有多组数据**。\n\n第一行给定一个整数 $T$，表示数据组数。  \n接下来 $T$ 行，每行两个整数 $n$ 和 $a$。\n", "outputFormat": "对于每组数据输出一个整数，表示有多少串不同的项链。", "hint": "满足条件的珠子共有三种：`[1,1,1]`,`[1,1,2]`,`[1,2,2]`。\n\n组成的满足条件的串有：`[1,2]`,`[1,3]`,`[2,3]`。\n\n对于 $100\\%$ 的数据，保证 $1 \\le T \\le 10$，$2 \\le n \\le 10^{14}$，$1 \\le a \\le 10^7$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2013] Necklace", "background": "As one of the body ornaments, the necklace is among the earliest pieces of jewelry. Besides its decorative function, some necklaces also have special symbolic roles, such as the crucifix chain for Catholics and the prayer beads for Buddhists.\n\nFrom ancient times to the present, people have created necklaces of various styles, features, and forms to beautify the human body and the environment, meeting the aesthetic needs of people with different skin tones, ethnicities, and tastes. In terms of materials, necklaces on the jewelry market include gold, silver, gemstones, and more.\n\nA pearl necklace is an ornament made of pearls, which are pierced and strung together to be worn around the neck. Natural pearl necklaces are believed to have certain protective qualities.", "description": "Recently, Mingming has become obsessed with a certain kind of necklace. It is basically the same as other pearl necklaces, but its beads are special: they are carved from Taishan stone into regular triangular prisms.\n\nThe prism has three square lateral faces, and each face is engraved with a number. A necklace that satisfies Mingming must meet the following conditions:\n\n1. The necklace consists of $n$ beads.\n2. On each bead, every number $x$ must satisfy $0 < x \\le a$, and the greatest common divisor of the three numbers on the bead must be exactly $1$.\n3. Adjacent beads must be different. Two beads are considered the same if and only if they can be made identical by rotation or reflection.\n4. Two necklaces are considered the same if they can become identical after a rotation.\n\nMingming is curious: given $n$ and $a$, how many different necklaces are there? Since the answer can be large, output it modulo $10^{9}+7$.", "inputFormat": "This problem contains multiple test cases.\n\nThe first line contains an integer $T$, the number of test cases.  \nThen follow $T$ lines, each containing two integers $n$ and $a$.", "outputFormat": "For each test case, output one integer, the number of different necklaces.", "hint": "There are three kinds of beads that meet the conditions: `[1,1,1]`, `[1,1,2]`, `[1,2,2]`.\n\nThe valid sequences they can form are: `[1,2]`, `[1,3]`, `[2,3]`.\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\le T \\le 10$, $2 \\le n \\le 10^{14}$, $1 \\le a \\le 10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2013] 项链", "background": "项链作为人体的装饰品之一，是最早出现的首饰。项链除了具有装饰功能之外，有些项链还具有特殊的显示作用，如天主教徒的十字架链和佛教徒的念珠。\n\n从古至今人们为了美化人体本身，也美化环境，制造了各种不同风格、不同特点、不同样式的项链，满足了不同肤色、不同民族、不同审美观的人的审美需要。就材料而论，首饰市场上的项链有黄金、白银、珠宝等几种。\n\n珍珠项链为珍珠制成的饰品，即将珍珠钻孔后用线串在一起，佩戴于项间，天然珍珠项链具有一定的护养作用。", "description": "最近，铭铭迷恋上了一种项链。与其他珍珠项链基本上相同，不过这种项链的珠子却与众不同，是正三菱柱的泰山石雕刻而成的。\n\n三菱柱的侧面是由正方形构成的，每个侧面都刻有数字。能够让铭铭满意的项链必须满足以下条件：\n\n1. 这串项链由 $n$ 颗珠子构成。\n\n2. 每一个珠子上面的每个数字 $x$，必须满足 $0<x\\le a$，且珠子上面三个数字的最大公约数要恰好为 $1$。\n\n3. 相邻的两个珠子必须不同。两个珠子被认为是相同的，当且仅当它们经过旋转，或者翻转后能够变成一样的。\n\n4. 两串项链如果能够经过旋转变成一样的，那么这两串项链被认为是相同的。 \n\n铭铭很好奇如果给定 $n$ 和 $a$，能够找到多少串不同的项链。由于答案可能很大，所以输出答案模上 $10^{9}+7$ 的值。", "inputFormat": "**本题有多组数据**。\n\n第一行给定一个整数 $T$，表示数据组数。  \n接下来 $T$ 行，每行两个整数 $n$ 和 $a$。\n", "outputFormat": "对于每组数据输出一个整数，表示有多少串不同的项链。", "hint": "满足条件的珠子共有三种：`[1,1,1]`,`[1,1,2]`,`[1,2,2]`。\n\n组成的满足条件的串有：`[1,2]`,`[1,3]`,`[2,3]`。\n\n对于 $100\\%$ 的数据，保证 $1 \\le T \\le 10$，$2 \\le n \\le 10^{14}$，$1 \\le a \\le 10^7$。", "locale": "zh-CN"}}}
{"pid": "P3308", "type": "P", "difficulty": 6, "samples": [["1\n6\n3 4 4 2 2 3\n2 1 1 1 1 2\n6 5 4 3 2 1", "4 3\n2 3 6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "网络流", "山东", "最小割"], "title": "[SDOI2014] LIS", "background": "", "description": "给定序列 $A$，序列中的每一项 $A_i$ 有删除代价 $B_i$ 和附加属性 $C_i$。请删除若干项，使得 $A$ 的最长上升子序列长度减少至少 $1$，且付出的代价之和最小，并输出方案。\n\n如果有多种方案，请输出将删去项的附加属性排序之后，字典序最小的一种。\n", "inputFormat": "输入包含多组数据。    \n\n输入的第一行包含整数 $T$，表示数据组数。接下来 $4T$ 行描述每组数据。    \n\n每组数据的第一行包含一个整数 $N$，表示 $A$ 的项数。\n\n接下来三行，每行 $N$ 个整数 $A_1\\sim A_n$，$B_1\\sim B_n$，$C_1\\sim C_n$，满足 $1\\le A_i,B_i,C_i \\le 10^9$，且 $C_i$ 两两不同。\n", "outputFormat": "对每组数据，输出两行。第一行包含两个整数 $S,M$，依次表示删去项的代价和与数量；接下来一行 $M$ 个整数，表示删去项在 $A$ 中的的位置，按升序输出。\n", "hint": "【样例说明】\n\n删去 $(A_2,A_3,A_6),(A_1,A_6),(A_2,A_3,A_4,A_5)$ 等都是合法的方案，但$(A_2,A_3,A_6)$ 对应的 $C$ 值的字典序最小。\n\n对于 $100\\%$ 的数据，$1\\le N\\le 700$，$1\\le T\\le 5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] LIS", "background": "", "description": "Given a sequence $A$, each element $A_i$ has a deletion cost $B_i$ and an additional attribute $C_i$. Delete some elements so that the length of the longest increasing subsequence of $A$ decreases by at least $1$, while minimizing the sum of deletion costs, and output the solution.\n\nIf there are multiple solutions, output the one whose deleted elements’ additional attributes, after sorting, form the lexicographically smallest sequence.", "inputFormat": "The input contains multiple test cases.\n\nThe first line contains an integer $T$, the number of test cases. The next $4T$ lines describe the test cases.\n\nFor each test case, the first line contains an integer $N$, the number of elements in $A$.\n\nThe next three lines each contain $N$ integers: $A_1\\sim A_n$, $B_1\\sim B_n$, $C_1\\sim C_n$, satisfying $1\\le A_i,B_i,C_i \\le 10^9$, and all $C_i$ are pairwise distinct.", "outputFormat": "For each test case, output two lines. The first line contains two integers $S, M$, denoting the total deletion cost and the number of deleted elements, respectively. The second line contains $M$ integers, the positions in $A$ of the deleted elements, in increasing order.", "hint": "[Sample explanation]\n\nDeleting $(A_2,A_3,A_6)$, $(A_1,A_6)$, $(A_2,A_3,A_4,A_5)$, etc., are all valid solutions, but $(A_2,A_3,A_6)$ yields the lexicographically smallest sequence of $C$ values.\n\nFor $100\\%$ of the testdata, $1\\le N\\le 700$, $1\\le T\\le 5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] LIS", "background": "", "description": "给定序列 $A$，序列中的每一项 $A_i$ 有删除代价 $B_i$ 和附加属性 $C_i$。请删除若干项，使得 $A$ 的最长上升子序列长度减少至少 $1$，且付出的代价之和最小，并输出方案。\n\n如果有多种方案，请输出将删去项的附加属性排序之后，字典序最小的一种。\n", "inputFormat": "输入包含多组数据。    \n\n输入的第一行包含整数 $T$，表示数据组数。接下来 $4T$ 行描述每组数据。    \n\n每组数据的第一行包含一个整数 $N$，表示 $A$ 的项数。\n\n接下来三行，每行 $N$ 个整数 $A_1\\sim A_n$，$B_1\\sim B_n$，$C_1\\sim C_n$，满足 $1\\le A_i,B_i,C_i \\le 10^9$，且 $C_i$ 两两不同。\n", "outputFormat": "对每组数据，输出两行。第一行包含两个整数 $S,M$，依次表示删去项的代价和与数量；接下来一行 $M$ 个整数，表示删去项在 $A$ 中的的位置，按升序输出。\n", "hint": "【样例说明】\n\n删去 $(A_2,A_3,A_6),(A_1,A_6),(A_2,A_3,A_4,A_5)$ 等都是合法的方案，但$(A_2,A_3,A_6)$ 对应的 $C$ 值的字典序最小。\n\n对于 $100\\%$ 的数据，$1\\le N\\le 700$，$1\\le T\\le 5$。\n", "locale": "zh-CN"}}}
{"pid": "P3309", "type": "P", "difficulty": 6, "samples": [["6 A\nA 3 2\nQ 1 5 1 1\nA 15 14\nA 12 9\nQ 12 8 12 15\nQ 21 18 19 18", "13\n17\n17\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000]}, "tags": ["2014", "线段树", "各省省选", "山东", "向量", "凸包"], "title": "[SDOI2014] 向量集", "background": "", "description": "维护一个向量集合，在线支持以下操作：\n\n- `A x y`（$|x|,|y| \\le 10^8$）：加入向量 $(x,y)$；\n- `Q x y l r`（$|x|,|y| \\le 10^8$，$1 \\le l \\le r \\le t$，其中 $t$ 为已经加入的向量个数）：询问第 $l$ 个到第 $r$ 个加入的向量与向量 $(x,y)$ 的点积的最大值。\n\n集合初始时为空。", "inputFormat": "输入的第一行包含整数 $N(1 \\le N \\le 4 \\times 10^5)$ 和字符 $s$，分别表示操作数和数据类别；\n\n接下来 $N$ 行，每行一个操作，格式如上所述。    \n\n请注意 $s$ 不为 `E` 时，输入中的所有整数都经过了加密。你可以使用以下程序得到原始输入：\n\n```\ninline int decode(int x, long long lastans) {    \n    return x ^ (lastans & 0x7fffffff);\n}\n```\n\n其中 `x` 为程序读入的数，`lastans` 为之前最后一次询问的答案。在第一次询问之前，`lastans` 为 $0$。注：向量 $(x, y)$ 和 $(z, w)$ 的点积定义为 $xz+yw$。", "outputFormat": "对每个 `Q` 操作，输出一个整数表示答案。", "hint": "样例解释：解密之后的输入为\n```\n    6 E\n    A 3 2\n    Q 1 5 1 1\n    A 2 3\n    A 1 4\n    Q 1 5 1 2\n    Q 4 3 2 3\n```\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] Vector Set", "background": "", "description": "Maintain a set of vectors and support the following operations online:\n\n- `A x y` ($|x|, |y| \\le 10^8$): insert the vector $(x, y)$.\n- `Q x y l r` ($|x|, |y| \\le 10^8$, $1 \\le l \\le r \\le t$, where $t$ is the number of vectors already inserted): query the maximum dot product between the vector $(x, y)$ and each of the vectors from the $l$-th to the $r$-th inserted.\n\nInitially, the set is empty.", "inputFormat": "The first line contains an integer $N (1 \\le N \\le 4 \\times 10^5)$ and a character $s$, representing the number of operations and the data category, respectively.\n\nThen follow $N$ lines, each containing one operation in the format described above.\n\nNote that when $s$ is not `E`, all integers in the input are encrypted. You can use the following program to obtain the original input:\n```\ninline int decode(int x, long long lastans) {    \n    return x ^ (lastans & 0x7fffffff);\n}\n```\nHere, $x$ is the number read by your program, and `lastans` is the answer to the most recent previous query. Before the first query, `lastans` is $0$. Note: the dot product of vectors $(x, y)$ and $(z, w)$ is defined as $xz + yw$.", "outputFormat": "For each `Q` operation, output an integer representing the answer.", "hint": "Sample explanation: after decryption, the input is\n```\n    6 E\n    A 3 2\n    Q 1 5 1 1\n    A 2 3\n    A 1 4\n    Q 1 5 1 2\n    Q 4 3 2 3\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 向量集", "background": "", "description": "维护一个向量集合，在线支持以下操作：\n\n- `A x y`（$|x|,|y| \\le 10^8$）：加入向量 $(x,y)$；\n- `Q x y l r`（$|x|,|y| \\le 10^8$，$1 \\le l \\le r \\le t$，其中 $t$ 为已经加入的向量个数）：询问第 $l$ 个到第 $r$ 个加入的向量与向量 $(x,y)$ 的点积的最大值。\n\n集合初始时为空。", "inputFormat": "输入的第一行包含整数 $N(1 \\le N \\le 4 \\times 10^5)$ 和字符 $s$，分别表示操作数和数据类别；\n\n接下来 $N$ 行，每行一个操作，格式如上所述。    \n\n请注意 $s$ 不为 `E` 时，输入中的所有整数都经过了加密。你可以使用以下程序得到原始输入：\n\n```\ninline int decode(int x, long long lastans) {    \n    return x ^ (lastans & 0x7fffffff);\n}\n```\n\n其中 `x` 为程序读入的数，`lastans` 为之前最后一次询问的答案。在第一次询问之前，`lastans` 为 $0$。注：向量 $(x, y)$ 和 $(z, w)$ 的点积定义为 $xz+yw$。", "outputFormat": "对每个 `Q` 操作，输出一个整数表示答案。", "hint": "样例解释：解密之后的输入为\n```\n    6 E\n    A 3 2\n    Q 1 5 1 1\n    A 2 3\n    A 1 4\n    Q 1 5 1 2\n    Q 4 3 2 3\n```\n", "locale": "zh-CN"}}}
{"pid": "P3310", "type": "P", "difficulty": 7, "samples": [["1\n0 1 0 2 0 3\n6\n0 0 3\n0 0 4\n0 0 5\n0 0 6\n0 0 7\n0 0 8", "45\n9\n10\n2\n19\n25"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "各省省选", "山东", "分治", "快速傅里叶变换 FFT"], "title": "[SDOI2014] 括号序列计数", "background": "", "description": "Alice 和 Bob 知道，一个由空格、左括号、右括号组成的序列被称为括号序列。有一类特殊的括号序列被称为\"合法括号序列\"。已知：\n\n- 空串是合法括号序列；\n- 如果 $S_1$ 和 $S_2$ 均是合法括号序列，则 $S_1+S_2$ 是合法括号序列；\n- 如果 $S$是合法括号序列，则 $(+S+)$ 是合法括号序列；\n- 如果 $S$ 是合法括号序列，在 $S$ 的任何位置（包括头尾位置）插入一个空格得到的序列是合法括号序列。\n\n现在 Alice 希望知道：对于某个已知的有限状态自动机中的状态 $s$ 与 $t$ ，存在多少以 $s$ 为起点、$t$ 为终点、长度为 $k$ 的合法括号序列。\n\n有限状态自动机是一个有向图 $G$，由 $n$ 个结点组成，每一个结点表示一个状态，且存在三类以此为起点的有向边。对于每一个状态，其向外的同一类有向边指向同样的状态。三类有向边分别代表三种符号：左括号、右括号和空格。\n\n我们将状态从 $0$ 开始编号。对于第 $i$ 个状态，用 $dfa_{i,0/1/2}$ 分别表示从 $i$ 出发，代表了左括号、右括号和空格的那一类边指向的状态，再用 $dfa2_{i,0/1/2}$ 表示每一类边的个数。对于一条从 $s$ 出发到 $t$ 结束的路径，满足长度为 $k$ 且路径经过的边对应的符号构成的序列组成了一组合法的括号匹配，则称作\"满足 $[G,s,t,k]$ 的合法括号序列\"。\n\n现在，Alice 为 Bob 提供了自动机 $G$，并提出 $Q$ 组询问。对于每一组询问，Alice 会给出 $s,t,k$，她希望 Bob 可以告诉她满足 $[G,s,t,k]$ 的合法括号序列有多少组。她只需要知道答案除以 $47$ 后的余数。", "inputFormat": "第一行一个整数 $n$ 表示状态数，第二到 $n+1$ 行，第 $i$ 行六个整数 $dfa_{i-1,0},dfa2_{i-1,0},dfa_{i-1,1},dfa2_{i-1,1},dfa_{i-1,2},dfa2_{i-1,2}$，描述第 $i-1$ 个状态的出边。\n\n接下来一行一个整数 $q$ 表示询问数，接下来 $q$ 行每行三个整数 $s,t,k$ 描述一组询问。", "outputFormat": "输出 $q$ 行，每行一个整数表示对应询问的答案 $\\bmod\\ 47$ 的结果。\n", "hint": "在样例解释中使用符号 `_` 代表空格。\n\n对于第一组询问长度为 $3$ 的合法括号序列有：\n\n- `___`，合法方案数为 $3^3 = 27$；\n- `_()`、`(_)`、`()_`，合法方案数均为 $1\\times2\\times3=6$。\n\n所以总方案数为 $27+6\\times3=45$。\n\n对于 $100 \\%$ 的数据，$1 \\leq n \\leq 2$，$0 \\leq dfa_{i,j} , s , t < n$，$0 \\leq dfa2_{i,j} < 2^{31}$，$1 \\leq k \\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] Counting Bracket Sequences", "background": "", "description": "Alice and Bob know that a sequence consisting of spaces, left parentheses, and right parentheses is called a bracket sequence. A special type of bracket sequence is called a \"legal bracket sequence.\" It is known that:\n\n- The empty string is a legal bracket sequence.\n- If $S_1$ and $S_2$ are both legal bracket sequences, then $S_1+S_2$ is a legal bracket sequence.\n- If $S$ is a legal bracket sequence, then $(+S+)$ is a legal bracket sequence.\n- If $S$ is a legal bracket sequence, then inserting a space at any position in $S$ (including the beginning and the end) yields a legal bracket sequence.\n\nNow Alice wants to know: for certain states $s$ and $t$ in a given finite state automaton, how many legal bracket sequences of length $k$ start at $s$ and end at $t$.\n\nA finite state automaton is a directed graph $G$ with $n$ nodes, each node representing a state, and there are three categories of outgoing directed edges from each state. For every state, all outgoing edges of the same category point to the same state. The three categories correspond to three symbols: left parenthesis, right parenthesis, and space.\n\nWe number the states starting from $0$. For the $i$-th state, let $dfa_{i,0/1/2}$ denote the target state of the category representing left parenthesis, right parenthesis, and space, respectively, and let $dfa2_{i,0/1/2}$ denote the number of edges in each category. For a path starting from $s$ and ending at $t$, if it has length $k$ and the sequence of symbols corresponding to the edges on the path forms a legal bracket sequence, we call it \"a legal bracket sequence that satisfies $[G,s,t,k]$.\"\n\nNow Alice provides Bob with the automaton $G$ and poses $Q$ queries. For each query, Alice will give $s,t,k$, and she hopes Bob can tell her how many legal bracket sequences satisfy $[G,s,t,k]$. She only needs the answer modulo $47$.", "inputFormat": "The first line contains an integer $n$ denoting the number of states. Lines $2$ through $n+1$, where the $i$-th of them contains six integers $dfa_{i-1,0},dfa2_{i-1,0},dfa_{i-1,1},dfa2_{i-1,1},dfa_{i-1,2},dfa2_{i-1,2}$, describe the outgoing edges of state $i-1$.\n\nThe next line contains an integer $q$ denoting the number of queries. Each of the following $q$ lines contains three integers $s,t,k$ describing one query.", "outputFormat": "Output $q$ lines, each containing one integer, the answer for the corresponding query $\\bmod\\ 47$.", "hint": "In the sample explanation, the symbol `_` represents a space.\n\nFor the first query, the legal bracket sequences of length $3$ are:\n\n- `___`, with the number of legal options being $3^3 = 27$.\n- `_()`, `(_)`, `()_`, each with the number of legal options being $1 \\times 2 \\times 3 = 6$.\n\nTherefore, the total number of options is $27 + 6 \\times 3 = 45$.\n\nConstraints:\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 2$, $0 \\leq dfa_{i,j}, s, t < n$, $0 \\leq dfa2_{i,j} < 2^{31}$, $1 \\leq k \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 括号序列计数", "background": "", "description": "Alice 和 Bob 知道，一个由空格、左括号、右括号组成的序列被称为括号序列。有一类特殊的括号序列被称为\"合法括号序列\"。已知：\n\n- 空串是合法括号序列；\n- 如果 $S_1$ 和 $S_2$ 均是合法括号序列，则 $S_1+S_2$ 是合法括号序列；\n- 如果 $S$是合法括号序列，则 $(+S+)$ 是合法括号序列；\n- 如果 $S$ 是合法括号序列，在 $S$ 的任何位置（包括头尾位置）插入一个空格得到的序列是合法括号序列。\n\n现在 Alice 希望知道：对于某个已知的有限状态自动机中的状态 $s$ 与 $t$ ，存在多少以 $s$ 为起点、$t$ 为终点、长度为 $k$ 的合法括号序列。\n\n有限状态自动机是一个有向图 $G$，由 $n$ 个结点组成，每一个结点表示一个状态，且存在三类以此为起点的有向边。对于每一个状态，其向外的同一类有向边指向同样的状态。三类有向边分别代表三种符号：左括号、右括号和空格。\n\n我们将状态从 $0$ 开始编号。对于第 $i$ 个状态，用 $dfa_{i,0/1/2}$ 分别表示从 $i$ 出发，代表了左括号、右括号和空格的那一类边指向的状态，再用 $dfa2_{i,0/1/2}$ 表示每一类边的个数。对于一条从 $s$ 出发到 $t$ 结束的路径，满足长度为 $k$ 且路径经过的边对应的符号构成的序列组成了一组合法的括号匹配，则称作\"满足 $[G,s,t,k]$ 的合法括号序列\"。\n\n现在，Alice 为 Bob 提供了自动机 $G$，并提出 $Q$ 组询问。对于每一组询问，Alice 会给出 $s,t,k$，她希望 Bob 可以告诉她满足 $[G,s,t,k]$ 的合法括号序列有多少组。她只需要知道答案除以 $47$ 后的余数。", "inputFormat": "第一行一个整数 $n$ 表示状态数，第二到 $n+1$ 行，第 $i$ 行六个整数 $dfa_{i-1,0},dfa2_{i-1,0},dfa_{i-1,1},dfa2_{i-1,1},dfa_{i-1,2},dfa2_{i-1,2}$，描述第 $i-1$ 个状态的出边。\n\n接下来一行一个整数 $q$ 表示询问数，接下来 $q$ 行每行三个整数 $s,t,k$ 描述一组询问。", "outputFormat": "输出 $q$ 行，每行一个整数表示对应询问的答案 $\\bmod\\ 47$ 的结果。\n", "hint": "在样例解释中使用符号 `_` 代表空格。\n\n对于第一组询问长度为 $3$ 的合法括号序列有：\n\n- `___`，合法方案数为 $3^3 = 27$；\n- `_()`、`(_)`、`()_`，合法方案数均为 $1\\times2\\times3=6$。\n\n所以总方案数为 $27+6\\times3=45$。\n\n对于 $100 \\%$ 的数据，$1 \\leq n \\leq 2$，$0 \\leq dfa_{i,j} , s , t < n$，$0 \\leq dfa2_{i,j} < 2^{31}$，$1 \\leq k \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3311", "type": "P", "difficulty": 6, "samples": [["20\n3\n2\n3\n14", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["字符串", "动态规划 DP", "2014", "各省省选", "山东", "O2优化", "数位 DP", "AC 自动机"], "title": "[SDOI2014] 数数", "background": "", "description": "我们称一个正整数 $x$ 是幸运数，当且仅当它的十进制表示中不包含数字串集合 $s$ 中任意一个元素作为其子串。例如当 $s = \\{22, 333, 0233\\}$ 时，$233$ 是幸运数，$2333$、$20233$、$3223$ 不是幸运数。给定 $n$ 和 $s$，计算不大于 $n$ 的幸运数个数。\n\n答案对 $10^9 + 7$ 取模。", "inputFormat": "第一行有一个整数，表示 $n$。\n\n第二行有一个整数，表示 $s$ 中的元素个数 $m$。\n\n接下来 $m$ 行，每行一个数字串 $s_i$，表示 $s$ 中的一个元素。", "outputFormat": "输出一行一个整数，表示答案对 $10^9 + 7$ 取模的结果。", "hint": "#### 样例 1 解释\n\n除了 $3, 13, 2, 12, 20, 14$ 以外，不大于 $20$ 的整数都是幸运数字。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n$1 \\leq n < 10^{1201}$，$1 \\leq m \\leq 100$，$1 \\leq \\sum_{i = 1}^m |s_i| \\leq 1500$，$\\min_{i = 1}^m |s_i| \\geq 1$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。$n$ 没有前导 $0$，但是 $s_i$ 可能有前导 $0$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] Counting", "background": "", "description": "We call a positive integer $x$ a lucky number if and only if its decimal representation does not contain any element from the set $s$ as a substring. For example, when $s = \\{22, 333, 0233\\}$, $233$ is a lucky number, while $2333$, $20233$, and $3223$ are not. Given $n$ and $s$, compute the number of lucky numbers not greater than $n$.\n\nThe answer is taken modulo $10^9 + 7$.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains an integer $m$, the number of elements in $s$.\n\nThe next $m$ lines each contain a digit string $s_i$, representing an element of $s$.", "outputFormat": "Output a single line containing one integer, the answer modulo $10^9 + 7$.", "hint": "#### Sample 1 Explanation\n\nExcept for $3, 13, 2, 12, 20, 14$, all integers not exceeding $20$ are lucky numbers.\n\n#### Constraints\n\nFor all testdata, it is guaranteed that:\n\n$1 \\leq n < 10^{1201}$, $1 \\leq m \\leq 100$, $1 \\leq \\sum_{i = 1}^m |s_i| \\leq 1500$, $\\min_{i = 1}^m |s_i| \\geq 1$, where $|s_i|$ denotes the length of string $s_i$. $n$ has no leading $0$, but $s_i$ may have leading $0$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 数数", "background": "", "description": "我们称一个正整数 $x$ 是幸运数，当且仅当它的十进制表示中不包含数字串集合 $s$ 中任意一个元素作为其子串。例如当 $s = \\{22, 333, 0233\\}$ 时，$233$ 是幸运数，$2333$、$20233$、$3223$ 不是幸运数。给定 $n$ 和 $s$，计算不大于 $n$ 的幸运数个数。\n\n答案对 $10^9 + 7$ 取模。", "inputFormat": "第一行有一个整数，表示 $n$。\n\n第二行有一个整数，表示 $s$ 中的元素个数 $m$。\n\n接下来 $m$ 行，每行一个数字串 $s_i$，表示 $s$ 中的一个元素。", "outputFormat": "输出一行一个整数，表示答案对 $10^9 + 7$ 取模的结果。", "hint": "#### 样例 1 解释\n\n除了 $3, 13, 2, 12, 20, 14$ 以外，不大于 $20$ 的整数都是幸运数字。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n$1 \\leq n < 10^{1201}$，$1 \\leq m \\leq 100$，$1 \\leq \\sum_{i = 1}^m |s_i| \\leq 1500$，$\\min_{i = 1}^m |s_i| \\geq 1$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。$n$ 没有前导 $0$，但是 $s_i$ 可能有前导 $0$。", "locale": "zh-CN"}}}
{"pid": "P3312", "type": "P", "difficulty": 6, "samples": [["2\n4 4 3\n10 10 5", "20\n148"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "树状数组", "山东", "最大公约数 gcd", "莫比乌斯反演", "前缀和"], "title": "[SDOI2014] 数表", "background": "", "description": "有一张 $n\\times m$ 的数表，其第 $i$ 行第 $j$ 列（$1\\le i\\le n$，$1\\le j\\le m$）的数值为能同时整除 $i$ 和 $j$ 的所有自然数之和。给定 $a$，计算数表中不大于 $a$ 的数之和。", "inputFormat": "**输入包含多组数据。**\n\n输入的第一行一个整数 $Q$ 表示测试点内的数据组数。\n\n接下来 $Q$ 行，每行三个整数 $n$，$m$，$a$（$|a|\\le 10^9$）描述一组数据。", "outputFormat": "对每组数据，输出一行一个整数，表示答案模 $2^{31}$ 的值。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$1\\le n,m\\le 10^5$，$1\\le Q\\le 2\\times 10^4$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] Number Table", "background": "", "description": "There is an $n\\times m$ table of numbers. The value at row $i$ and column $j$ ($1\\le i\\le n$, $1\\le j\\le m$) equals the sum of all natural numbers that divide both $i$ and $j$. Given $a$, compute the sum of all numbers in the table that are not greater than $a$.", "inputFormat": "The input contains multiple test cases.\n\nThe first line contains an integer $Q$, the number of test cases.\n\nEach of the next $Q$ lines contains three integers $n$, $m$, $a$ ($|a|\\le 10^9$), describing one test case.", "outputFormat": "For each test case, output one line with a single integer: the answer modulo $2^{31}$.", "hint": "### Constraints and Conventions\n\nFor all testdata, $1\\le n,m\\le 10^5$, $1\\le Q\\le 2\\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 数表", "background": "", "description": "有一张 $n\\times m$ 的数表，其第 $i$ 行第 $j$ 列（$1\\le i\\le n$，$1\\le j\\le m$）的数值为能同时整除 $i$ 和 $j$ 的所有自然数之和。给定 $a$，计算数表中不大于 $a$ 的数之和。", "inputFormat": "**输入包含多组数据。**\n\n输入的第一行一个整数 $Q$ 表示测试点内的数据组数。\n\n接下来 $Q$ 行，每行三个整数 $n$，$m$，$a$（$|a|\\le 10^9$）描述一组数据。", "outputFormat": "对每组数据，输出一行一个整数，表示答案模 $2^{31}$ 的值。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$1\\le n,m\\le 10^5$，$1\\le Q\\le 2\\times 10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P3313", "type": "P", "difficulty": 5, "samples": [["5 6\n3 1\n2 3\n1 2\n3 3\n5 1\n1 2\n1 3\n3 4\n3 5\nQS 1 5\nCC 3 1\nQS 1 5\nCW 3 3\nQS 1 5\nQM 2 4", "8\n9\n11\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "线段树", "各省省选", "山东", "树链剖分", "分块"], "title": "[SDOI2014] 旅行", "background": "", "description": "S 国有 $N$ 个城市，编号从 $1$ 到 $N$。城市间用 $N-1$ 条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。\n\n为了方便，我们用不同的正整数代表各种宗教，S 国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S 国为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。\n\n在 S 国的历史上常会发生以下几种事件：\n\n- `CC x c`：城市 $x$ 的居民全体改信了 $c$ 教；\n- `CW x w`：城市 $x$ 的评级调整为 $w$；\n- `QS x y`：一位旅行者从城市 $x$ 出发，到城市 $y$，并记下了途中留宿过的城市的评级总和；\n- `QM x y`：一位旅行者从城市 $x$ 出发，到城市 $y$，并记下了途中留宿过的城市的评级最大值。\n\n由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。 为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。", "inputFormat": "输入的第一行包含整数 $N,Q$ 依次表示城市数和事件数。\n\n接下来 $N$ 行，第 $i+1$ 行两个整数 $W_i,C_i$ 依次表示记录开始之前，城市 $i$ 的评级和信仰。\n\n接下来 $N-1$ 行每行两个整数 $x,y$ 表示一条双向道路。\n\n接下来 $Q$ 行，每行一个操作，格式如上所述。", "outputFormat": "对每个 `QS` 和 `QM` 事件，输出一行，表示旅行者记下的数字。", "hint": "对于 $100\\%$ 的数据，$N,Q \\leq10^5,C \\leq10^5$\n\n数据保证对所有 `QS` 和 `QM` 事件，起点和终点城市的信仰相同；在任意时刻，城市的评级总是不大于 $10^4$ 的正整数，且宗教值不大于 $C$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] Travel", "background": "", "description": "Country S has $N$ cities, numbered from $1$ to $N$. The cities are connected by $N-1$ undirected roads, forming a structure where starting from any city, one can reach all other cities. Each city believes in a different religion; common beliefs include the Church of the Flying Spaghetti Monster, the Invisible Pink Unicorn, and Jediism.\n\nFor convenience, we use different positive integers to represent various religions. Residents of Country S often travel. They always take the shortest path, and to avoid trouble, they only stay overnight in cities whose religion is the same as theirs. Of course, the destination of the trip also has the same religion as the traveler. Country S assigns a distinct travel rating to each city. Travelers often record the sum or the maximum of the ratings of the cities where they stayed overnight along the way, including the start and end cities.\n\nIn the history of Country S, the following types of events often occur:\n- `CC x c`: All residents of city $x$ convert to religion $c$.\n- `CW x w`: The rating of city $x$ is adjusted to $w$.\n- `QS x y`: A traveler starts from city $x$, goes to city $y$, and records the sum of the ratings of the cities where they stayed overnight along the way.\n- `QM x y`: A traveler starts from city $x$, goes to city $y$, and records the maximum of the ratings of the cities where they stayed overnight along the way.\n\nThe recorded numbers have been lost, but the religion and rating of each city before the records began, as well as the event log itself, are intact. Based on this information, restore the numbers that the travelers recorded. For convenience, we assume that the interval between events is long enough so that during any single trip, all cities’ ratings and religions remain unchanged.", "inputFormat": "The first line contains the integers $N, Q$, representing the number of cities and the number of events, respectively.\n\nThe next $N$ lines: on the $(i+1)$-th line, two integers $W_i, C_i$ denote the initial rating and religion of city $i$ before the records began.\n\nThe next $N-1$ lines each contain two integers $x, y$, indicating an undirected road between cities $x$ and $y$.\n\nThe next $Q$ lines each contain one operation, in one of the formats described above.", "outputFormat": "For each `QS` and `QM` event, output one line containing the number recorded by the traveler.", "hint": "For $100\\%$ of the testdata, $N, Q \\le 10^5$, $C \\le 10^5$.\n\nIt is guaranteed that for all `QS` and `QM` events, the start and end cities have the same religion. At any time, a city’s rating is a positive integer not exceeding $10^4$, and the religion value does not exceed $C$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 旅行", "background": "", "description": "S 国有 $N$ 个城市，编号从 $1$ 到 $N$。城市间用 $N-1$ 条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。\n\n为了方便，我们用不同的正整数代表各种宗教，S 国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S 国为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。\n\n在 S 国的历史上常会发生以下几种事件：\n\n- `CC x c`：城市 $x$ 的居民全体改信了 $c$ 教；\n- `CW x w`：城市 $x$ 的评级调整为 $w$；\n- `QS x y`：一位旅行者从城市 $x$ 出发，到城市 $y$，并记下了途中留宿过的城市的评级总和；\n- `QM x y`：一位旅行者从城市 $x$ 出发，到城市 $y$，并记下了途中留宿过的城市的评级最大值。\n\n由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。 为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。", "inputFormat": "输入的第一行包含整数 $N,Q$ 依次表示城市数和事件数。\n\n接下来 $N$ 行，第 $i+1$ 行两个整数 $W_i,C_i$ 依次表示记录开始之前，城市 $i$ 的评级和信仰。\n\n接下来 $N-1$ 行每行两个整数 $x,y$ 表示一条双向道路。\n\n接下来 $Q$ 行，每行一个操作，格式如上所述。", "outputFormat": "对每个 `QS` 和 `QM` 事件，输出一行，表示旅行者记下的数字。", "hint": "对于 $100\\%$ 的数据，$N,Q \\leq10^5,C \\leq10^5$\n\n数据保证对所有 `QS` 和 `QM` 事件，起点和终点城市的信仰相同；在任意时刻，城市的评级总是不大于 $10^4$ 的正整数，且宗教值不大于 $C$。", "locale": "zh-CN"}}}
{"pid": "P3314", "type": "P", "difficulty": 7, "samples": [["4 4 4\n0 0 0 0\n0 0 0 0\n0 0 0 0\n0 0 0 0\n1 2 2 1\n2 1 1 2\n1 2 2 1\n2 1 1 2\n4 4 2\n0 0 1 1\n0 0 0 0\n1 0 0 0\n0 0 0 0\n1 0 2 2\n0 0 3 0\n0 0 0", "16 96\n12 1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "各省省选", "山东", "轮廓线 DP"], "title": "[SDOI2014] 电路板", "background": "", "description": "对于用户给出的电路图和指定大小的电路板，$\\text{Alice}$ 和 $\\text{Bob}$ 需要将电路在电路板上实现出来。\n\n所谓电路板，可以看作是一个 $n \\times m$ 的格子图。\n\n用户给定的电路由若干电路原件组成，每一个电路原件可能会占用一个或多个格子。这里，我们将被电路原件占据的格子分为两类。\n\n第一类只是纯粹占据了这个格子，之后这个格子不会再被使用，也不会从被占据的位置连出去任何的电路线。这样的格子被我们视作是电路板上的障碍物。\n\n还有一类格子，我们称为是电路原件的接口，上面虽然被电路原件占用，但是仍有可能从其中连出去一些电路线到其它的电路原件上，从而形成电路。\n\n对于电路图中一些链接某两个原件的电路线，我们可以指定为电路板上的 $k$ 个格子对，要求每对格子对之间连一条电路线。\n\n同一个格子可能属于多个格子对（比如一些并联电路）。\n\n任意两条电路线不能相交（但可以连接到同一个有着电路原件的格子中），且电路板上的每一个格子的每一条边都只能经过一条电路线。（所以每一个电路原件的接口上只能接出去最多 $4$ 条不同的电路线）。然而，每一个不被电路原件占用的格子内却可以经过多条电路线。\n\n具体来说：为了保证电路线不相交，可以一条电路线从上边界进入当前格子，从左边界离开这个格子，另外一条电路线可以从下边界进入格子，从右边界出去。（需要注意的是：电路线本身是没有方向感念的，即格子对描述的边关系是无向边。所以这样的方案也可以描述为从左边界进入后从上边界出去，从右边界进入后从下边界出去）相似的方案还有好几种。\n\n现在，$\\text{Alice}$ 希望找到一个可行方案，使得路径的总长度最短。而 $\\text{Bob}$ 则希望知道满足最短长度的方案有多少种。", "inputFormat": "第一行三个整数 $n,m,k$，表示电路板的大小，以及需要连接电路线的格子对个数。\n\n接下来 $m$ 行，每行 $n$ 个整数，为 $0$ 或 $1$。$0$ 代表当前格子可以用，否则表示有障碍，不能使用。\n\n接下来 $k$ 行，每行 $4$ 个整数 $x1,y1,x2,y2$，给出一组格子对，表示对应的电路要连接的两个格子。**格子的行列都从 $0$ 开始编号，所以 $0 \\le x1,x2 < n$，$0 \\le y1,y2 < m$。**\n\n本题有多组数据（最多 $30$ 组），输入文件最后以 `0 0 0` 结束。", "outputFormat": "对于每组数据，输出两个整数，最短电线长度和最短电线长度的方案数。\n\n方案数只需要输出对 $25619849$ 取余数后的结果。 \n\n如果无解，输出 `-1 0`。", "hint": "**样例解释：**\n\n第一组数据：$(1,2)$ 与 $(2,1)$ 之间有 $4$ 条路径，立刻可以发现，最短路径长度和为 $16$。对于每一种可行方案，任意一条 $(1,2)$ 与 $(2,1)$ 之间的路径都可以对应要求的 $4$ 条路径中的任何一条。而若就形态来说，完全不同的方案有 $4$ 种，考虑到排列数 $4! = 24$，所以总的方案为 $96$ 种。\n\n第二组数据：因为有 $3$ 个障碍点，所以可行路径只有一条。\n\n**数据规模：**\n\n对于 $20\\%$ 的数据：$n, m \\le 4$。\n\n对于 $40\\%$ 的数据：$n, m \\le 8$。\n\n对于 $100\\%$ 的数据，$n, m \\le 9$，$k \\le 10$。\n\n此外：\n\n存在 $10\\%$ 的数据：$k=1$。\n\n存在 $30\\%$ 的数据：$k \\le 3$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] Circuit Board", "background": "", "description": "Given a circuit diagram and a circuit board of specified size, $\\text{Alice}$ and $\\text{Bob}$ need to realize the circuit on the board.\n\nYou can regard the circuit board as an $n \\times m$ grid.\n\nThe user’s circuit consists of several components, each of which may occupy one or more cells. We classify the cells occupied by components into two types:\n\n- One type merely occupies the cell; afterward the cell will no longer be used, and no wire will run from that occupied position. Such cells are considered obstacles on the circuit board.\n- The other type are interfaces of components. Although occupied by a component, wires may still be connected from these cells to other components to form the circuit.\n\nFor some wires in the circuit that connect two components, we specify them as $k$ pairs of cells on the board. Each pair must be connected by exactly one wire.\n\nThe same cell may belong to multiple pairs (for example, in some parallel circuits).\n\nAny two wires must not intersect (but they may connect to the same cell that contains a component), and each edge of every cell on the board can be used by at most one wire. Therefore, each component interface can have at most $4$ wires attached. However, a cell not occupied by a component may be traversed by multiple wires.\n\nSpecifically, to ensure that wires do not intersect: one wire can enter a cell from the top edge and leave from the left edge, while another wire can enter from the bottom edge and leave from the right edge. Note that wires themselves are undirected; that is, the relation described by a pair of cells is an undirected edge. So the same configuration can also be described as entering from the left edge and leaving from the top edge, and entering from the right edge and leaving from the bottom edge. There are several similar valid pairings.\n\nNow, $\\text{Alice}$ wants to find a feasible scheme that minimizes the total length of all wires. $\\text{Bob}$ wants to know how many schemes achieve this minimal total length.", "inputFormat": "The first line contains three integers $n, m, k$, denoting the size of the circuit board and the number of pairs of cells that must be connected by wires.\n\nThen follow $n$ lines, each containing $m$ integers, each being $0$ or $1$. A $0$ means the cell is usable; a $1$ means it is an obstacle and cannot be used.\n\nThen follow $k$ lines, each containing $4$ integers $x1,y1,x2,y2$, giving one pair of cells to be connected by a wire. The row and column indices of cells are $0$-based, so $0 \\le x1,x2 < n$ and $0 \\le y1,y2 < m$.\n\nThis problem has multiple testcases (at most $30$). The input ends with a line `0 0 0`.", "outputFormat": "For each testcase, output two integers: the minimal total wire length, and the number of schemes that achieve this minimal length.\n\nOutput the number of schemes modulo $25619849$.\n\nIf there is no solution, output `-1 0`.", "hint": "Sample explanation:\n\n- For the first testcase: there are $4$ paths between $(1,2)$ and $(2,1)$, and it is easy to see that the minimal total path length is $16$. In any feasible scheme, any path between $(1,2)$ and $(2,1)$ can correspond to any of the required $4$ paths. If we consider distinct shapes, there are $4$ different schemes. Taking into account permutations, $4! = 24$, the total number of schemes is $96$.\n- For the second testcase: due to $3$ obstacle cells, there is only one feasible path.\n\nConstraints:\n\n- For $20\\%$ of the testdata: $n, m \\le 4$.\n- For $40\\%$ of the testdata: $n, m \\le 8$.\n- For $100\\%$ of the testdata: $n, m \\le 9$, $k \\le 10$.\n\nIn addition:\n\n- There exists $10\\%$ of the testdata with $k=1$.\n- There exists $30\\%$ of the testdata with $k \\le 3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 电路板", "background": "", "description": "对于用户给出的电路图和指定大小的电路板，$\\text{Alice}$ 和 $\\text{Bob}$ 需要将电路在电路板上实现出来。\n\n所谓电路板，可以看作是一个 $n \\times m$ 的格子图。\n\n用户给定的电路由若干电路原件组成，每一个电路原件可能会占用一个或多个格子。这里，我们将被电路原件占据的格子分为两类。\n\n第一类只是纯粹占据了这个格子，之后这个格子不会再被使用，也不会从被占据的位置连出去任何的电路线。这样的格子被我们视作是电路板上的障碍物。\n\n还有一类格子，我们称为是电路原件的接口，上面虽然被电路原件占用，但是仍有可能从其中连出去一些电路线到其它的电路原件上，从而形成电路。\n\n对于电路图中一些链接某两个原件的电路线，我们可以指定为电路板上的 $k$ 个格子对，要求每对格子对之间连一条电路线。\n\n同一个格子可能属于多个格子对（比如一些并联电路）。\n\n任意两条电路线不能相交（但可以连接到同一个有着电路原件的格子中），且电路板上的每一个格子的每一条边都只能经过一条电路线。（所以每一个电路原件的接口上只能接出去最多 $4$ 条不同的电路线）。然而，每一个不被电路原件占用的格子内却可以经过多条电路线。\n\n具体来说：为了保证电路线不相交，可以一条电路线从上边界进入当前格子，从左边界离开这个格子，另外一条电路线可以从下边界进入格子，从右边界出去。（需要注意的是：电路线本身是没有方向感念的，即格子对描述的边关系是无向边。所以这样的方案也可以描述为从左边界进入后从上边界出去，从右边界进入后从下边界出去）相似的方案还有好几种。\n\n现在，$\\text{Alice}$ 希望找到一个可行方案，使得路径的总长度最短。而 $\\text{Bob}$ 则希望知道满足最短长度的方案有多少种。", "inputFormat": "第一行三个整数 $n,m,k$，表示电路板的大小，以及需要连接电路线的格子对个数。\n\n接下来 $m$ 行，每行 $n$ 个整数，为 $0$ 或 $1$。$0$ 代表当前格子可以用，否则表示有障碍，不能使用。\n\n接下来 $k$ 行，每行 $4$ 个整数 $x1,y1,x2,y2$，给出一组格子对，表示对应的电路要连接的两个格子。**格子的行列都从 $0$ 开始编号，所以 $0 \\le x1,x2 < n$，$0 \\le y1,y2 < m$。**\n\n本题有多组数据（最多 $30$ 组），输入文件最后以 `0 0 0` 结束。", "outputFormat": "对于每组数据，输出两个整数，最短电线长度和最短电线长度的方案数。\n\n方案数只需要输出对 $25619849$ 取余数后的结果。 \n\n如果无解，输出 `-1 0`。", "hint": "**样例解释：**\n\n第一组数据：$(1,2)$ 与 $(2,1)$ 之间有 $4$ 条路径，立刻可以发现，最短路径长度和为 $16$。对于每一种可行方案，任意一条 $(1,2)$ 与 $(2,1)$ 之间的路径都可以对应要求的 $4$ 条路径中的任何一条。而若就形态来说，完全不同的方案有 $4$ 种，考虑到排列数 $4! = 24$，所以总的方案为 $96$ 种。\n\n第二组数据：因为有 $3$ 个障碍点，所以可行路径只有一条。\n\n**数据规模：**\n\n对于 $20\\%$ 的数据：$n, m \\le 4$。\n\n对于 $40\\%$ 的数据：$n, m \\le 8$。\n\n对于 $100\\%$ 的数据，$n, m \\le 9$，$k \\le 10$。\n\n此外：\n\n存在 $10\\%$ 的数据：$k=1$。\n\n存在 $30\\%$ 的数据：$k \\le 3$。", "locale": "zh-CN"}}}
{"pid": "P3315", "type": "P", "difficulty": 7, "samples": [["2 2\n1 2\n3\n4\n4\n0 0 0 1\n1 0 0 1\n1 1 0 1\n0 1 1 0", "7.0000\n10.0000\n8.0000\n10.0000"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "各省省选", "山东", "Special Judge", "高斯消元"], "title": "[SDOI2014] 酗酒者", "background": "", "description": "$\\text{Alice}$ 发现：人在心情不好的时候，便会选择酗酒。这往往与 $\\text{OI}$ 选手比赛胜利后的欢腾庆祝不同，酗酒者喝醉后便会忘记回家的路，然后在大街上无规律地乱走乱逛，同时喊着一些谁也听不懂的话。\n\n这几天，$\\text{Bob}$ 因为考试的原因心情很不好，每天晚上都会在城里面找一处酒吧。喝醉后离开酒吧开始在城市街道中无规律乱走，直到某一时刻，若他碰巧遇到了在夜晚出来看星星的 $\\text{Alice}$，便会被她带回家。\n\n已知 $\\text{Alice}$ 和 $\\text{Bob}$ 所在的城市街道可以被描绘为一个 $N$ 行 $M$ 列的格点地图，$N$ 行依次编号为 $0$ 到 $N-1$，$M$ 列依次编号为 $0$ 到 $M-1$。城市中共有 $N\\times M$ 处路口，每一个路口可以用坐标 $(i,j)$ 表示。若 $i<N$，则 $(i,j)$ 与 $(i+1,j)$ 有无向的连边，边权长度，$p_{(i,j)}$ 表示走过这一条路所需的时间。若 $j<M$，则 $(i,j)$ 与 $(i,j+1)$ 有连无向边，边权长度 $q_{(i,j)}$。\n\n对于给定的两个点 $(u,v)$ 和 $(s,t)$ 分别为 $\\text{Bob}$ 今晚去的酒吧的位置，和 $\\text{Alice}$ 今晚看星星的位置。$\\text{Bob}$ 离开酒吧后，对于每一个路口，他会等概率选择其中之一，然后走向下一个路口。在走到下一个路口之前，$\\text{Bob}$ 不会回头。同时 $\\text{Bob}$ 并不会因为之前走过什么道路而影响之后的行走路线。\n\n具体来说：如果 $\\text{Bob}$ 从 $(3,4)$ 走到 $(3,5)$，他有可能在抵达 $(3,5)$ 后立刻折回 $(3,4)$。对于四叉路口，$\\text{Bob}$ 向每一个方向行走的概率都是 $1/4$，对于三叉路口（这只存在于城市的边界上）则是 $1/3$，对于二叉路口（这只存在于城市的 $4$ 个角落）就是 $1/2$。\n\n$\\text{Alice}$ 希望知道，从 $\\text{Bob}$ 离开酒吧，$\\text{Alice}$ 期望情况下还需要等多久才能等到 $\\text{Bob}$，即对于给定的两个点 $(u,v)$ 与 $(s,t)$，$\\text{Bob}$ 从 $(u,v)$ 走到 $(s,t)$ 的期望用时是多少？", "inputFormat": "第一行 $N$，$M$。\n\n之后 $N-1$ 行，每行 $M$ 个正整数，其中第 $i$ 行第 $j$ 个为 $p_{(i,j)}$。\n\n之后 $N$ 行，每行 $M-1$ 个正整数，其中第 $i$ 行第 $j$ 个为 $q_{(i,j)}$。\n\n单独一行给出一个整数 $Q$，表示总询问次数。\n\n之后 $Q$ 行，每行有 $4$ 个整数 $u$，$v$，$s$，$t$。", "outputFormat": "一共 $Q$ 行，每一行对应一次询问：从 $(u,v)$ 走到 $(s,t)$ 的期望时间是多少？你的答案可以保留任意多位小数，但只有与正确答案的错误率在 $0.1\\%$ 内才算正确。", "hint": "对于 $10\\%$ 的数据，$N \\times M \\le 25$。\n\n对于 $30\\%$ 的数据，$N \\times M \\le 625$。\n\n对于 $50\\%$ 的数据，$N \\times M \\le 2500$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\times M \\le 10^4$，$1 \\le Q \\le 100$。$1 \\le p_{(i,j)},q_{(i,j)} \\le 200$。\n\n此外存在 $10\\%$ 的数据，$\\min(N,M) \\le 10$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] The Drunkard", "background": "", "description": "$\\text{Alice}$ finds that when people are in a bad mood, they tend to drink heavily. Unlike the jubilant celebration after an $\\text{OI}$ contestant’s victory, a drunkard often forgets the way home and wanders randomly around the streets, shouting incomprehensible words.\n\nThese days, $\\text{Bob}$ is in a bad mood due to exams. Every night he finds a bar in the city. After getting drunk and leaving the bar, he begins to wander randomly through the city streets until, at some moment, if he happens to meet $\\text{Alice}$ who is out watching the stars at night, she will take him home.\n\nThe city streets where $\\text{Alice}$ and $\\text{Bob}$ live can be modeled as a grid of $N$ rows and $M$ columns. Rows are numbered from $0$ to $N - 1$, and columns from $0$ to $M - 1$. There are $N \\times M$ intersections in total, and each intersection is denoted by coordinates $(i, j)$. If $i < N - 1$, then $(i, j)$ and $(i + 1, j)$ are connected by an undirected edge whose length is $p_{(i,j)}$, representing the time needed to traverse this road. If $j < M - 1$, then $(i, j)$ and $(i, j + 1)$ are connected by an undirected edge whose length is $q_{(i,j)}$.\n\nGiven two points $(u, v)$ and $(s, t)$, which are the locations of the bar that $\\text{Bob}$ visits tonight and the place where $\\text{Alice}$ watches the stars tonight, respectively. After leaving the bar, at each intersection, $\\text{Bob}$ will choose uniformly at random one of the adjacent intersections and then move to it. Before reaching the next intersection, $\\text{Bob}$ will not turn back mid-edge. Also, $\\text{Bob}$’s future movement is not affected by the roads he has previously taken.\n\nSpecifically: if $\\text{Bob}$ moves from $(3, 4)$ to $(3, 5)$, he may immediately return to $(3, 4)$ after arriving at $(3, 5)$. At a four-way intersection, $\\text{Bob}$ moves in each direction with probability $1/4$; at a three-way intersection (only on the boundary), with probability $1/3$ for each; at a two-way intersection (only at the four corners), with probability $1/2$ for each.\n\n$\\text{Alice}$ wants to know, starting from when $\\text{Bob}$ leaves the bar, how long she expects to wait until meeting $\\text{Bob}$. That is, for the given points $(u, v)$ and $(s, t)$, what is the expected time for $\\text{Bob}$ to go from $(u, v)$ to $(s, t)$?", "inputFormat": "The first line contains $N$, $M$.\n\nThen there are $N - 1$ lines, each containing $M$ positive integers, where the entry in row $i$ and column $j$ is $p_{(i,j)}$.\n\nThen there are $N$ lines, each containing $M - 1$ positive integers, where the entry in row $i$ and column $j$ is $q_{(i,j)}$.\n\nA single line follows with an integer $Q$, the number of queries.\n\nThen $Q$ lines follow, each containing four integers $u$, $v$, $s$, $t$.", "outputFormat": "Output $Q$ lines. For each query, print the expected time for $\\text{Bob}$ to go from $(u, v)$ to $(s, t)$. You may output any number of decimal places, but your answer is considered correct only if the error rate is within $0.1\\%$.", "hint": "For $10\\%$ of the testdata, $N \\times M \\le 25$.\n\nFor $30\\%$ of the testdata, $N \\times M \\le 625$.\n\nFor $50\\%$ of the testdata, $N \\times M \\le 2500$.\n\nFor $100\\%$ of the testdata, $1 \\le N \\times M \\le 10^4$, $1 \\le Q \\le 100$, and $1 \\le p_{(i,j)}, q_{(i,j)} \\le 200$.\n\nAdditionally, for $10\\%$ of the testdata, $\\min(N, M) \\le 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 酗酒者", "background": "", "description": "$\\text{Alice}$ 发现：人在心情不好的时候，便会选择酗酒。这往往与 $\\text{OI}$ 选手比赛胜利后的欢腾庆祝不同，酗酒者喝醉后便会忘记回家的路，然后在大街上无规律地乱走乱逛，同时喊着一些谁也听不懂的话。\n\n这几天，$\\text{Bob}$ 因为考试的原因心情很不好，每天晚上都会在城里面找一处酒吧。喝醉后离开酒吧开始在城市街道中无规律乱走，直到某一时刻，若他碰巧遇到了在夜晚出来看星星的 $\\text{Alice}$，便会被她带回家。\n\n已知 $\\text{Alice}$ 和 $\\text{Bob}$ 所在的城市街道可以被描绘为一个 $N$ 行 $M$ 列的格点地图，$N$ 行依次编号为 $0$ 到 $N-1$，$M$ 列依次编号为 $0$ 到 $M-1$。城市中共有 $N\\times M$ 处路口，每一个路口可以用坐标 $(i,j)$ 表示。若 $i<N$，则 $(i,j)$ 与 $(i+1,j)$ 有无向的连边，边权长度，$p_{(i,j)}$ 表示走过这一条路所需的时间。若 $j<M$，则 $(i,j)$ 与 $(i,j+1)$ 有连无向边，边权长度 $q_{(i,j)}$。\n\n对于给定的两个点 $(u,v)$ 和 $(s,t)$ 分别为 $\\text{Bob}$ 今晚去的酒吧的位置，和 $\\text{Alice}$ 今晚看星星的位置。$\\text{Bob}$ 离开酒吧后，对于每一个路口，他会等概率选择其中之一，然后走向下一个路口。在走到下一个路口之前，$\\text{Bob}$ 不会回头。同时 $\\text{Bob}$ 并不会因为之前走过什么道路而影响之后的行走路线。\n\n具体来说：如果 $\\text{Bob}$ 从 $(3,4)$ 走到 $(3,5)$，他有可能在抵达 $(3,5)$ 后立刻折回 $(3,4)$。对于四叉路口，$\\text{Bob}$ 向每一个方向行走的概率都是 $1/4$，对于三叉路口（这只存在于城市的边界上）则是 $1/3$，对于二叉路口（这只存在于城市的 $4$ 个角落）就是 $1/2$。\n\n$\\text{Alice}$ 希望知道，从 $\\text{Bob}$ 离开酒吧，$\\text{Alice}$ 期望情况下还需要等多久才能等到 $\\text{Bob}$，即对于给定的两个点 $(u,v)$ 与 $(s,t)$，$\\text{Bob}$ 从 $(u,v)$ 走到 $(s,t)$ 的期望用时是多少？", "inputFormat": "第一行 $N$，$M$。\n\n之后 $N-1$ 行，每行 $M$ 个正整数，其中第 $i$ 行第 $j$ 个为 $p_{(i,j)}$。\n\n之后 $N$ 行，每行 $M-1$ 个正整数，其中第 $i$ 行第 $j$ 个为 $q_{(i,j)}$。\n\n单独一行给出一个整数 $Q$，表示总询问次数。\n\n之后 $Q$ 行，每行有 $4$ 个整数 $u$，$v$，$s$，$t$。", "outputFormat": "一共 $Q$ 行，每一行对应一次询问：从 $(u,v)$ 走到 $(s,t)$ 的期望时间是多少？你的答案可以保留任意多位小数，但只有与正确答案的错误率在 $0.1\\%$ 内才算正确。", "hint": "对于 $10\\%$ 的数据，$N \\times M \\le 25$。\n\n对于 $30\\%$ 的数据，$N \\times M \\le 625$。\n\n对于 $50\\%$ 的数据，$N \\times M \\le 2500$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\times M \\le 10^4$，$1 \\le Q \\le 100$。$1 \\le p_{(i,j)},q_{(i,j)} \\le 200$。\n\n此外存在 $10\\%$ 的数据，$\\min(N,M) \\le 10$。", "locale": "zh-CN"}}}
{"pid": "P3316", "type": "P", "difficulty": 7, "samples": [["6\n249999999 499999998\n583333331 83333333\n83333333 333333332\n333333332 999999996\n833333330 749999997\n499999998 833333330\n12\n0 1 872826049 679758020 472526437 270998755 15447952 502239247\n1 833333330 749999997 499999998 833333330 916666663 666666664\n1 833333330 749999997 916666663 666666664 416666665 916666663\n0 1 371653715 747730364 409617871 21996163 118531999 759280767\n1 249999999 499999998 583333331 83333333 666666664 166666666\n0 1 195920917 488293591 322952040 262793733 678458193 506876149\n0 1 203963007 782710007 391614158 831643205 340800821 896322422\n0 1 498571077 461554269 765704840 973009111 152064733 114249255\n1 499999998 833333330 249999999 499999998 999999996 583333331\n0 1 159294077 702544938 787871788 619972292 941209243 950700951\n0 1 791254252 411705638 382076333 263993056 306662346 47793905\n0 1 13359599 513224793 415037020 28305143 48117026 34994422", "out\nout\nin\nin\nout\nout\nout\nin"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "2014", "各省省选", "山东"], "title": "[SDOI2014] 里面还是外面", "background": "upd：\n\n- 数据更新：现在选取了原题的总共 10 个测试点，并删除了其中两个不符合题意的。", "description": "Alice 给出了平面上的一个简单 $N$-多边形。所谓简单 $N$-多边形，包括 $N$ 个给定的端点，和连接相邻点的直线段。特别的，我们认为 1 号点与 $N$ 号点相邻。\n\n对于边界上不同的直线段，保证它们只会在公共端点处相交。有的时候 Alice 会指着平面上一个点，然后问 Bob：“这个点是在多边形的里面呢，还是外面呢，还是在边界上呢？”\n\n这个时候，如果她所指的点是多边形的一个顶点或者在多边形某条边的边界上，都将被认为是在多边形的边界上。还有的时候，Alice 为了加大难度，会删除连接 $a$ 和 $b$ 的边，并插入新的点 $c$（新插入的点保证不与任何已有的端点重合，也不在任何边界上），然后新增 $a$ 到 $c$ 的边与 $b$ 到 $c$ 的边，从而得到一个新的简单多边形。\n\nAlice 保证这样的操作得到的新图形总是简单多边形。Bob 要做的，就是准确回答出 Alice 的提问。而实际上，Alice 的每一次提问都将由 Bob 上一次的回答决定，虽然这个回答是唯一的，但却意味着如果 Bob 不能回答出前一个问题，就不能拿到 Alice 的下一个问题。\n\n不过，Alice 对多边形的修改确实事先准备好的。详细来说：Alice 的每一次修改命令可以看作是一个六元组：$\\langle x_a, y_a, x_b, y_b, x_c, y_c \\rangle$ 表示删除了坐标位置 $(x_a, y_a)$ 与坐标位置 $(x_b, y_b)$ 的点之间的连边，并插入新的点 $(x_c, y_c)$。\n\n这里我们保证坐标为 $(x_a, y_a)$ 的点与坐标为 $(x_b, y_b)$ 的点总是存在的。因为 Alice 保证了所有出现的点（这包括了询问点）的坐标都是非负整数，且都小于 $10^9$，且多边形中（这不包括询问点）任意两个点的 $x$ 坐标不同，$y$ 坐标也不同。所以每一次询问 Alice 将给出 7 个非负整数：$r$，$x_{\\text{in}}$，$y_{\\text{in}}$，$x_{\\text{out}}$，$y_{\\text{out}}$，$x_{\\text{bd}}$，$y_{\\text{bd}}$。而 Alice 这一次询问真正要询问的点 $(X, Y)$ 的坐标将由上一次询问的点 $(x_0, y_0)$ 与上一次询问的回答而决定。例如，若上一次询问的点在多边形外，则：\n$$\nX = (r \\times x_0 + x_{\\text{out}}) \\bmod 10^9\n$$\n$$\nY = (r \\times y_0 + y_{\\text{out}}) \\bmod 10^9\n$$\n对于第一次询问，我们假设 $x_0 = y_0 = 0$，也就是说将 $(0,0)$ 考虑为前一次的询问。", "inputFormat": "输入文件的第一行有一个整数 $N$，表示初始时多边形的点数。\n\n之后 $N$ 行，每行一对非负整数 $x$ 和 $y$（$0 \\leq x, y < 10^9$）。按照某一顺序依次描述了多边形的所有顶点的坐标，并编号为 1 到 $N$。这里我们只认为，对于平面上的一点 $(10^{100}, 10^{100})$ 一定是处在多边形以外的。之后一行有一个整数 $Q$，表示总的操作次数。\n\n之后 $Q$ 行，每行第一个数字 $p$，如果 $p=0$ 则表示询问；如果 $p=1$ 则表示修改。\n- 对于询问，之后给出了 7 个非负整数，它们是：$r$，$x_{\\text{in}}$，$y_{\\text{in}}$，$x_{\\text{out}}$，$y_{\\text{out}}$，$x_{\\text{bd}}$，$y_{\\text{bd}}$\n- 对于修改，之后给出了 6 个整数，它们是：$x_a$，$y_a$，$x_b$，$y_b$，$x_c$，$y_c$", "outputFormat": "对于每一次询问操作，单独输出一行且只包含一个字符串，它或者是 `in`、或者是 `out`、或者是 `bd`（均为小写字符），分别表示询问点在多边形的内、外或边界。\n", "hint": "对于 100% 的数据：$N \\leq 50000$，$Q \\leq 50000$，所有坐标非负且均小于 $10^9$，而 $r$ 或者为 1 或者为 0。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] Inside or Outside", "background": "upd:\n\n- Testdata update: a total of 10 test points from the original problem are selected, and two that did not meet the statement have been removed.", "description": "Alice gives a simple $N$-gon on the plane. A simple $N$-gon consists of $N$ given endpoints and straight segments connecting adjacent points. In particular, we consider vertex $1$ adjacent to vertex $N$.\n\nFor distinct boundary segments, they only intersect at common endpoints. Sometimes Alice points to a point in the plane and asks Bob: “Is this point inside the polygon, outside the polygon, or on the boundary?”\n\nAt that time, if the pointed point is a vertex of the polygon or lies on any edge of the polygon, it is considered to be on the boundary. Sometimes, to increase the difficulty, Alice deletes the edge connecting $a$ and $b$, inserts a new point $c$ (the newly inserted point is guaranteed not to coincide with any existing endpoint and not to lie on any existing edge), and then adds edges from $a$ to $c$ and from $b$ to $c$, thereby obtaining a new simple polygon.\n\nAlice guarantees that the figure obtained by such an operation is always a simple polygon. What Bob has to do is answer Alice’s questions correctly. In fact, each of Alice’s questions will be determined by Bob’s previous answer: although this answer is unique, it implies that if Bob cannot answer the previous question, he cannot get Alice’s next question.\n\nHowever, Alice’s modifications are indeed prepared in advance. In detail: each modification command by Alice can be viewed as a 6-tuple $\\langle x_a, y_a, x_b, y_b, x_c, y_c \\rangle$, which means the edge between $(x_a, y_a)$ and $(x_b, y_b)$ is deleted, and a new point $(x_c, y_c)$ is inserted.\n\nWe guarantee that the points at coordinates $(x_a, y_a)$ and $(x_b, y_b)$ always exist. Because Alice guarantees that all appearing points (this includes query points) have non-negative integer coordinates, all less than $10^9$, and among the polygon’s points (this does not include query points) any two points have distinct $x$-coordinates and also distinct $y$-coordinates. Therefore, for each query Alice will give 7 non-negative integers: $r$, $x_{\\text{in}}$, $y_{\\text{in}}$, $x_{\\text{out}}$, $y_{\\text{out}}$, $x_{\\text{bd}}$, $y_{\\text{bd}}$. The actual query point $(X, Y)$ for this query is determined by the previous query point $(x_0, y_0)$ and the previous answer. For example, if the previous query point was outside the polygon, then:\n$$\nX = (r \\times x_0 + x_{\\text{out}}) \\bmod 10^9\n$$\n$$\nY = (r \\times y_0 + y_{\\text{out}}) \\bmod 10^9\n$$\nFor the first query, assume $x_0 = y_0 = 0$, i.e., treat $(0, 0)$ as the previous query.\n\nSimilarly, if the previous point was inside, replace $x_{\\text{out}}, y_{\\text{out}}$ with $x_{\\text{in}}, y_{\\text{in}}$; if it was on the boundary, use $x_{\\text{bd}}, y_{\\text{bd}}$.", "inputFormat": "The first line contains an integer $N$, the number of vertices of the initial polygon.\n\nThen follow $N$ lines, each with a pair of non-negative integers $x$ and $y$ ($0 \\leq x, y < 10^9$). They describe all vertices of the polygon in some order and are indexed from $1$ to $N$. Here we only assume that the point $(10^{100}, 10^{100})$ in the plane is certainly outside the polygon. The next line contains an integer $Q$, the total number of operations.\n\nEach of the next $Q$ lines starts with a number $p$. If $p = 0$, it is a query; if $p = 1$, it is a modification.\n- For a query, the next 7 non-negative integers are: $r$, $x_{\\text{in}}$, $y_{\\text{in}}$, $x_{\\text{out}}$, $y_{\\text{out}}$, $x_{\\text{bd}}$, $y_{\\text{bd}}$.\n- For a modification, the next 6 integers are: $x_a$, $y_a$, $x_b$, $y_b$, $x_c$, $y_c$.", "outputFormat": "For each query operation, output a single line containing exactly one string: either `in`, `out`, or `bd` (all lowercase), indicating that the query point is inside the polygon, outside the polygon, or on the boundary, respectively.", "hint": "For 100% of the testdata: $N \\leq 50000$, $Q \\leq 50000$, all coordinates are non-negative and less than $10^9$, and $r$ is either $1$ or $0$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 里面还是外面", "background": "upd：\n\n- 数据更新：现在选取了原题的总共 10 个测试点，并删除了其中两个不符合题意的。", "description": "Alice 给出了平面上的一个简单 $N$-多边形。所谓简单 $N$-多边形，包括 $N$ 个给定的端点，和连接相邻点的直线段。特别的，我们认为 1 号点与 $N$ 号点相邻。\n\n对于边界上不同的直线段，保证它们只会在公共端点处相交。有的时候 Alice 会指着平面上一个点，然后问 Bob：“这个点是在多边形的里面呢，还是外面呢，还是在边界上呢？”\n\n这个时候，如果她所指的点是多边形的一个顶点或者在多边形某条边的边界上，都将被认为是在多边形的边界上。还有的时候，Alice 为了加大难度，会删除连接 $a$ 和 $b$ 的边，并插入新的点 $c$（新插入的点保证不与任何已有的端点重合，也不在任何边界上），然后新增 $a$ 到 $c$ 的边与 $b$ 到 $c$ 的边，从而得到一个新的简单多边形。\n\nAlice 保证这样的操作得到的新图形总是简单多边形。Bob 要做的，就是准确回答出 Alice 的提问。而实际上，Alice 的每一次提问都将由 Bob 上一次的回答决定，虽然这个回答是唯一的，但却意味着如果 Bob 不能回答出前一个问题，就不能拿到 Alice 的下一个问题。\n\n不过，Alice 对多边形的修改确实事先准备好的。详细来说：Alice 的每一次修改命令可以看作是一个六元组：$\\langle x_a, y_a, x_b, y_b, x_c, y_c \\rangle$ 表示删除了坐标位置 $(x_a, y_a)$ 与坐标位置 $(x_b, y_b)$ 的点之间的连边，并插入新的点 $(x_c, y_c)$。\n\n这里我们保证坐标为 $(x_a, y_a)$ 的点与坐标为 $(x_b, y_b)$ 的点总是存在的。因为 Alice 保证了所有出现的点（这包括了询问点）的坐标都是非负整数，且都小于 $10^9$，且多边形中（这不包括询问点）任意两个点的 $x$ 坐标不同，$y$ 坐标也不同。所以每一次询问 Alice 将给出 7 个非负整数：$r$，$x_{\\text{in}}$，$y_{\\text{in}}$，$x_{\\text{out}}$，$y_{\\text{out}}$，$x_{\\text{bd}}$，$y_{\\text{bd}}$。而 Alice 这一次询问真正要询问的点 $(X, Y)$ 的坐标将由上一次询问的点 $(x_0, y_0)$ 与上一次询问的回答而决定。例如，若上一次询问的点在多边形外，则：\n$$\nX = (r \\times x_0 + x_{\\text{out}}) \\bmod 10^9\n$$\n$$\nY = (r \\times y_0 + y_{\\text{out}}) \\bmod 10^9\n$$\n对于第一次询问，我们假设 $x_0 = y_0 = 0$，也就是说将 $(0,0)$ 考虑为前一次的询问。", "inputFormat": "输入文件的第一行有一个整数 $N$，表示初始时多边形的点数。\n\n之后 $N$ 行，每行一对非负整数 $x$ 和 $y$（$0 \\leq x, y < 10^9$）。按照某一顺序依次描述了多边形的所有顶点的坐标，并编号为 1 到 $N$。这里我们只认为，对于平面上的一点 $(10^{100}, 10^{100})$ 一定是处在多边形以外的。之后一行有一个整数 $Q$，表示总的操作次数。\n\n之后 $Q$ 行，每行第一个数字 $p$，如果 $p=0$ 则表示询问；如果 $p=1$ 则表示修改。\n- 对于询问，之后给出了 7 个非负整数，它们是：$r$，$x_{\\text{in}}$，$y_{\\text{in}}$，$x_{\\text{out}}$，$y_{\\text{out}}$，$x_{\\text{bd}}$，$y_{\\text{bd}}$\n- 对于修改，之后给出了 6 个整数，它们是：$x_a$，$y_a$，$x_b$，$y_b$，$x_c$，$y_c$", "outputFormat": "对于每一次询问操作，单独输出一行且只包含一个字符串，它或者是 `in`、或者是 `out`、或者是 `bd`（均为小写字符），分别表示询问点在多边形的内、外或边界。\n", "hint": "对于 100% 的数据：$N \\leq 50000$，$Q \\leq 50000$，所有坐标非负且均小于 $10^9$，而 $r$ 或者为 1 或者为 0。", "locale": "zh-CN"}}}
{"pid": "P3317", "type": "P", "difficulty": 6, "samples": [["3\n0 0.5 0.5\n0.5 0 0.5\n0.5 0.5 0", "0.375"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "矩阵树定理", "山东", "Special Judge", "生成树", "期望"], "title": "[SDOI2014] 重建", "background": "", "description": "T 国有 $N$ 个城市，用若干双向道路连接。一对城市之间至多存在一条道路。    \n\n在一次洪水之后，一些道路受损无法通行。虽然已经有人开始调查道路的损毁情况，但直到现在几乎没有消息传回。    \n\n幸运的是，此前 T 国政府调查过每条道路的强度，现在他们希望只利用这些信息估计灾情。具体地，给定每条道路在洪水后仍能通行的概率，请计算仍能通行的道路恰有 $N-1$ 条，且能联通所有城市的概率。\n", "inputFormat": "输入的第一行包含整数 $N$。  \n\n接下来 $N$ 行，每行 $N$ 个实数，第 $i+1$ 行，列的数 $G_{i,j}$ 表示城市 $i$ 与 $j$ 之间仍有道路联通的概率。    \n\n输入保证 $G_{i,j}=G_{j,i}$，且 $G_{i,i}=0$。$G_{i, j}$ 至多包含两位小数。\n", "outputFormat": "输出一个任意位数的实数表示答案。    \n\n你的答案与标准答案相对误差不超过 $10^{-4}$ 即视为正确。\n", "hint": "$1<N\\leq 50$。\n\n数据保证答案非零时，答案不小于 $10^{-4}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2014] Reconstruction", "background": "", "description": "Country T has $N$ cities, connected by several bidirectional roads. Between any pair of cities, there is at most one road.\n\nAfter a flood, some roads were damaged and are no longer passable. Although an investigation into the damage has begun, almost no information has come back so far.\n\nFortunately, the government of Country T had previously investigated the strength of each road, and now they hope to estimate the damage using only this information. Specifically, given for each road the probability that it remains passable after the flood, compute the probability that exactly $N-1$ roads remain passable and they connect all cities.", "inputFormat": "The first line contains the integer $N$.\n\nThen follow $N$ lines, each containing $N$ real numbers. In the $(i+1)$-th line, the number in column $j$, denoted $G_{i,j}$, represents the probability that cities $i$ and $j$ are still connected by a road after the flood.\n\nIt is guaranteed that $G_{i,j}=G_{j,i}$ and $G_{i,i}=0$. Each $G_{i,j}$ contains at most two decimal places.", "outputFormat": "Output a real number representing the answer.\n\nYour answer will be accepted if its relative error does not exceed $10^{-4}$.", "hint": "$1 < N \\leq 50$.\n\nIt is guaranteed that if the answer is non-zero, then it is at least $10^{-4}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2014] 重建", "background": "", "description": "T 国有 $N$ 个城市，用若干双向道路连接。一对城市之间至多存在一条道路。    \n\n在一次洪水之后，一些道路受损无法通行。虽然已经有人开始调查道路的损毁情况，但直到现在几乎没有消息传回。    \n\n幸运的是，此前 T 国政府调查过每条道路的强度，现在他们希望只利用这些信息估计灾情。具体地，给定每条道路在洪水后仍能通行的概率，请计算仍能通行的道路恰有 $N-1$ 条，且能联通所有城市的概率。\n", "inputFormat": "输入的第一行包含整数 $N$。  \n\n接下来 $N$ 行，每行 $N$ 个实数，第 $i+1$ 行，列的数 $G_{i,j}$ 表示城市 $i$ 与 $j$ 之间仍有道路联通的概率。    \n\n输入保证 $G_{i,j}=G_{j,i}$，且 $G_{i,i}=0$。$G_{i, j}$ 至多包含两位小数。\n", "outputFormat": "输出一个任意位数的实数表示答案。    \n\n你的答案与标准答案相对误差不超过 $10^{-4}$ 即视为正确。\n", "hint": "$1<N\\leq 50$。\n\n数据保证答案非零时，答案不小于 $10^{-4}$。\n", "locale": "zh-CN"}}}
{"pid": "P3318", "type": "P", "difficulty": 6, "samples": [["4 4 7 3\nvijosvi\njosvivi\nvijosos\nijosvsv\njos\nvij\nijo\njos", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["字符串", "2015", "各省省选", "山东", "哈希 hashing"], "title": "[SDOI2015] 双旋转字符串", "background": "", "description": "给定两个字符串集合 $\\mathcal{S}$ 和 $\\mathcal{T}$。其中 $S$ 中的所有字符串长度都恰好为 $N$，而 $T$ 中所有字符串长度都恰好为 $M$。且 $N+M$ 恰好为偶数。\n\n如果记 $\\mathcal{S}$ 中字符串全体为 $S_1,S_2,\\dots,S_{Total_S}$，而 $\\mathcal{T}$ 中字符串全体为 $T_1,T_2,\\dots,T_{Total_T}$。现在希望知道有多少对 $\\langle i, j \\rangle$，满足将 $S_i$ 和 $T_j$ 拼接后得到的字符串 $S_i+T_j$ 满足双旋转性。\n\n一个长度为偶数字符串 $W$ 可以表示成两段长度相同的字符串的拼接，即 $W=U+V$。如果 $V$ 可以通过 $U$ 旋转得到，则称 $W$ 是满足双旋转性的。比如说字符串 `vijos` 可以通过旋转得到 `ijosv`,`josvi`,`osvij` 或 `svijo`。那么 `vijosjosvi` 就是满足双旋转性的字符串。", "inputFormat": "第一行输入四个正整数，分别为 $Total_S,Total_T,N,M$，依次表示集合 $\\mathcal{S}$ 的大小，集合 $\\mathcal{T}$ 的大小，集合 $\\mathcal{S}$ 中字符串的长度和集合 $\\mathcal{T}$ 中字符串的长度。\n\n之后 $Total_S$ 行，依次给出 $S$ 中所有的字符串 $S_i$，$1\\le i\\le Total_S$。保证每一个字符串长度都恰为 $N$，且字符串只由 $26$ 个小写字母组成。\n\n之后 $Total_T$ 行，依次给出 $T$ 中所有的字符串 $T_i$，$1\\le i\\le Total_T$。保证每一个字符串长度都恰为 $M$，且字符串只由 $26$ 个小写字母组成。", "outputFormat": "输出一个整数，表示满足要求的数字对 $\\langle i, j \\rangle$ 有多少个。", "hint": "对于 $10\\%$ 的数据，$1\\leq N\\leq 100$，$1\\leq M\\leq 100$，$1\\leq Total_S\\leq 100$，$1\\leq Total_T\\leq 100$。\n\n对于 $30\\%$ 的数据，$1\\leq N\\leq 500$，$1\\leq M\\leq 500$，$1\\leq Total_S\\leq 500$，$1\\leq Total_T\\leq 500$。\n\n对于 $60\\%$ 的数据，$2\\le N\\times Total_S+M\\times Total_T\\le 4\\times 10^5$。\n\n对于 $100\\%$ 的数据，$2\\le N\\times Total_S+M\\times Total_T\\le 4\\times 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Double Rotation Strings", "background": "", "description": "Given two sets of strings $\\mathcal{S}$ and $\\mathcal{T}$. All strings in $\\mathcal{S}$ have length exactly $N$, and all strings in $\\mathcal{T}$ have length exactly $M$. Moreover, $N + M$ is even.\n\nIf we denote all strings in $\\mathcal{S}$ by $S_1, S_2, \\dots, S_{Total_S}$, and all strings in $\\mathcal{T}$ by $T_1, T_2, \\dots, T_{Total_T}$, we want to know how many pairs $\\langle i, j \\rangle$ satisfy that the concatenation $S_i + T_j$ has the double rotation property.\n\nAn even-length string $W$ can be written as the concatenation of two strings of equal length, i.e., $W = U + V$. If $V$ can be obtained from $U$ by a rotation (cyclic shift), then $W$ is said to have the double rotation property. For example, the string `vijos` can be rotated to `ijosv`, `josvi`, `osvij`, or `svijo`. Thus, `vijosjosvi` has the double rotation property.", "inputFormat": "The first line contains four positive integers $Total_S, Total_T, N, M$, denoting respectively the size of set $\\mathcal{S}$, the size of set $\\mathcal{T}$, the length of strings in $\\mathcal{S}$, and the length of strings in $\\mathcal{T}$.\n\nThe next $Total_S$ lines each contain a string $S_i$, $1 \\le i \\le Total_S$. Each string has length exactly $N$, and consists only of the 26 lowercase letters.\n\nThe next $Total_T$ lines each contain a string $T_i$, $1 \\le i \\le Total_T$. Each string has length exactly $M$, and consists only of the 26 lowercase letters.", "outputFormat": "Output a single integer, the number of pairs $\\langle i, j \\rangle$ that satisfy the requirement.", "hint": "For $10\\%$ of the testdata, $1 \\leq N \\leq 100$, $1 \\leq M \\leq 100$, $1 \\leq Total_S \\leq 100$, $1 \\leq Total_T \\leq 100$.\n\nFor $30\\%$ of the testdata, $1 \\leq N \\leq 500$, $1 \\leq M \\leq 500$, $1 \\leq Total_S \\leq 500$, $1 \\leq Total_T \\leq 500$.\n\nFor $60\\%$ of the testdata, $2 \\le N \\times Total_S + M \\times Total_T \\le 4 \\times 10^5$.\n\nFor $100\\%$ of the testdata, $2 \\le N \\times Total_S + M \\times Total_T \\le 4 \\times 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 双旋转字符串", "background": "", "description": "给定两个字符串集合 $\\mathcal{S}$ 和 $\\mathcal{T}$。其中 $S$ 中的所有字符串长度都恰好为 $N$，而 $T$ 中所有字符串长度都恰好为 $M$。且 $N+M$ 恰好为偶数。\n\n如果记 $\\mathcal{S}$ 中字符串全体为 $S_1,S_2,\\dots,S_{Total_S}$，而 $\\mathcal{T}$ 中字符串全体为 $T_1,T_2,\\dots,T_{Total_T}$。现在希望知道有多少对 $\\langle i, j \\rangle$，满足将 $S_i$ 和 $T_j$ 拼接后得到的字符串 $S_i+T_j$ 满足双旋转性。\n\n一个长度为偶数字符串 $W$ 可以表示成两段长度相同的字符串的拼接，即 $W=U+V$。如果 $V$ 可以通过 $U$ 旋转得到，则称 $W$ 是满足双旋转性的。比如说字符串 `vijos` 可以通过旋转得到 `ijosv`,`josvi`,`osvij` 或 `svijo`。那么 `vijosjosvi` 就是满足双旋转性的字符串。", "inputFormat": "第一行输入四个正整数，分别为 $Total_S,Total_T,N,M$，依次表示集合 $\\mathcal{S}$ 的大小，集合 $\\mathcal{T}$ 的大小，集合 $\\mathcal{S}$ 中字符串的长度和集合 $\\mathcal{T}$ 中字符串的长度。\n\n之后 $Total_S$ 行，依次给出 $S$ 中所有的字符串 $S_i$，$1\\le i\\le Total_S$。保证每一个字符串长度都恰为 $N$，且字符串只由 $26$ 个小写字母组成。\n\n之后 $Total_T$ 行，依次给出 $T$ 中所有的字符串 $T_i$，$1\\le i\\le Total_T$。保证每一个字符串长度都恰为 $M$，且字符串只由 $26$ 个小写字母组成。", "outputFormat": "输出一个整数，表示满足要求的数字对 $\\langle i, j \\rangle$ 有多少个。", "hint": "对于 $10\\%$ 的数据，$1\\leq N\\leq 100$，$1\\leq M\\leq 100$，$1\\leq Total_S\\leq 100$，$1\\leq Total_T\\leq 100$。\n\n对于 $30\\%$ 的数据，$1\\leq N\\leq 500$，$1\\leq M\\leq 500$，$1\\leq Total_S\\leq 500$，$1\\leq Total_T\\leq 500$。\n\n对于 $60\\%$ 的数据，$2\\le N\\times Total_S+M\\times Total_T\\le 4\\times 10^5$。\n\n对于 $100\\%$ 的数据，$2\\le N\\times Total_S+M\\times Total_T\\le 4\\times 10^6$。", "locale": "zh-CN"}}}
{"pid": "P3319", "type": "P", "difficulty": 7, "samples": [["9 0\n1 2\n1 3\n1 4\n1 5\n2 6\n2 7\n2 8\n2 9\n2.5", "0.253"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "各省省选", "山东"], "title": "[SDOI2015] 嫁接树", "background": "", "description": "Alice 设计了一个树结构，有 $N$ 个结点（包括根）被依次编号为 $1$ 到 $N$，由 $N-1$ 条边连接。后来，Bob 在上面增加了 $K$ 条原来没有的边（也就是说既不是自环，也不会因此产生重边）并称这样得到的图为” $K$-嫁接树“。\n\n现在 Alice 希望对嫁接树的每一个结点进行染色，允许使用的颜色恰有 $N$ 种，分别编号为 $1$ 到 $N$。Alice 要求相邻两个结点要涂上不同的颜色。假设颜色为 $i$ 的结点有 $t_i$ 个，则 Bob 给出了如下的评价分数：\n\n$$\\mathit{score}=\\dfrac{t_1+\\dfrac{1}{2}t_2+\\dfrac{1}{3}t_3+\\cdots+\\dfrac{1}{N}t_N}{1+P\\times (t_1+2t_2+3t_3+\\cdots+Nt_N)}$$\n\n其中 $P$ 为非负系数。现在，Alice 希望可以找到一种染色方案，使得 Bob 给出来的评分最大。你能帮助他吗？", "inputFormat": "第一行有 $2$ 个整数，依次为 $N$ 和 $K$，如题所述。第二行到第 $N+K$ 行，每行有两个整数 $u$ 和 $v$，依次给出了 $N+K-1$ 条边。**其中，首先给出 $N - 1$ 条树边，其次给出新增加的边**。保证不存在自环，也不存在重边。最后一行给定非负浮点数 $P$。\n\n$K \\le 2$，$1 \\le N \\le 2 \\times 10^5$，$0 \\le P<10$。", "outputFormat": "输出最大的可能评分，四舍五入保留到小数点后第三位。\n", "hint": "2024-10-11 update: 更新了数据精度问题 ", "locale": "zh-CN", "translations": {"en": {"title": "{{[SDOI2015] Grafting Tree}}", "background": "{{}}", "description": "{{Alice designed a tree with $N$ nodes (including the root), numbered consecutively from $1$ to $N$, connected by $N - 1$ edges. Later, Bob added $K$ new edges that did not exist before (i.e., they are neither self-loops nor parallel edges), and called the resulting graph a \"$K$-grafted tree\".\n\nNow Alice wants to color every node of the grafted tree using exactly $N$ available colors, numbered $1$ to $N$. Adjacent nodes must be colored differently. Suppose the number of nodes colored with color $i$ is $t_i$. Bob gives the following score:\n$$\\mathit{score}=\\dfrac{t_1+\\dfrac{1}{2}t_2+\\dfrac{1}{3}t_3+\\cdots+\\dfrac{1}{N}t_N}{1+P\\times (t_1+2t_2+3t_3+\\cdots+Nt_N)}$$\nHere $P$ is a non-negative coefficient. Alice wants to find a coloring that maximizes Bob’s score. Can you help her?}}", "inputFormat": "{{The first line contains $2$ integers $N$ and $K$, as described. Lines $2$ through $N+K$ each contain two integers $u$ and $v$, giving the $N+K-1$ edges. **First, the $N - 1$ tree edges are given, then the newly added edges.** There are no self-loops or parallel edges. The last line contains a non-negative floating-point number $P$.\n\n$K \\le 2$, $1 \\le N \\le 2 \\times 10^5$, $0 \\le P < 10$.}}", "outputFormat": "{{Output the maximum possible score, rounded to three decimal places.}}", "hint": "{{2024-10-11 update: Updated the testdata precision issue.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 嫁接树", "background": "", "description": "Alice 设计了一个树结构，有 $N$ 个结点（包括根）被依次编号为 $1$ 到 $N$，由 $N-1$ 条边连接。后来，Bob 在上面增加了 $K$ 条原来没有的边（也就是说既不是自环，也不会因此产生重边）并称这样得到的图为” $K$-嫁接树“。\n\n现在 Alice 希望对嫁接树的每一个结点进行染色，允许使用的颜色恰有 $N$ 种，分别编号为 $1$ 到 $N$。Alice 要求相邻两个结点要涂上不同的颜色。假设颜色为 $i$ 的结点有 $t_i$ 个，则 Bob 给出了如下的评价分数：\n\n$$\\mathit{score}=\\dfrac{t_1+\\dfrac{1}{2}t_2+\\dfrac{1}{3}t_3+\\cdots+\\dfrac{1}{N}t_N}{1+P\\times (t_1+2t_2+3t_3+\\cdots+Nt_N)}$$\n\n其中 $P$ 为非负系数。现在，Alice 希望可以找到一种染色方案，使得 Bob 给出来的评分最大。你能帮助他吗？", "inputFormat": "第一行有 $2$ 个整数，依次为 $N$ 和 $K$，如题所述。第二行到第 $N+K$ 行，每行有两个整数 $u$ 和 $v$，依次给出了 $N+K-1$ 条边。**其中，首先给出 $N - 1$ 条树边，其次给出新增加的边**。保证不存在自环，也不存在重边。最后一行给定非负浮点数 $P$。\n\n$K \\le 2$，$1 \\le N \\le 2 \\times 10^5$，$0 \\le P<10$。", "outputFormat": "输出最大的可能评分，四舍五入保留到小数点后第三位。\n", "hint": "2024-10-11 update: 更新了数据精度问题 ", "locale": "zh-CN"}}}
{"pid": "P3320", "type": "P", "difficulty": 6, "samples": [["4 5\n1 2 30\n2 3 50\n2 4 60\n2\n3\n4\n2\n1", "0\n100\n220\n220\n280"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "各省省选", "山东", "深度优先搜索 DFS", "最近公共祖先 LCA", "虚树"], "title": "[SDOI2015] 寻宝游戏", "background": "", "description": "小 B 最近正在玩一个寻宝游戏，这个游戏的地图中有 $N$ 个村庄和 $N-1$ 条道路，并且任何两个村庄之间有且仅有一条路径可达。游戏开始时，玩家可以任意选择一个村庄，瞬间转移到这个村庄，然后可以任意在地图的道路上行走，若走到某个村庄中有宝物，则视为找到该村庄内的宝物，直到找到所有宝物并返回到最初转移到的村庄为止。\n\n小 B 希望评测一下这个游戏的难度，因此他需要知道玩家找到所有宝物需要行走的最短路程。但是这个游戏中宝物经常变化，有时某个村庄中会突然出现宝物，有时某个村庄内的宝物会突然消失，因此小 B 需要不断地更新数据，但是小 B 太懒了，不愿意自己计算，因此他向你求助。为了简化问题，我们认为最开始时所有村庄内均没有宝物。", "inputFormat": "第一行，两个整数 $N,M$，其中 $M$ 为宝物的变动次数。\n\n接下来的 $N-1$ 行，每行三个整数 $x,y,z$，表示村庄 $x,y$ 之间有一条长度为 $z$ 的道路。\n\n接下来的 $M$ 行，每行一个整数 $t$，表示一个宝物变动的操作。若该操作前村庄 $t$ 内没有宝物，则操作后村庄内有宝物；若该操作前村庄 $t$ 内有宝物，则操作后村庄内没有宝物。", "outputFormat": "$M$ 行，每行一个整数，其中第 $i$ 行的整数表示第 $i$ 次操作之后玩家找到所有宝物需要行走的最短路程。若只有一个村庄内有宝物，或者所有村庄内都没有宝物，则输出 `0`。", "hint": "- 对于 $10\\%$ 的数据，$1 \\leq N \\leq 100, 1 \\leq M \\leq 100$；\n- 对于 $20\\%$ 的数据，$1 \\leq N \\leq 1000, 1 \\leq M \\leq 1000$；\n- 对于另外 $15\\%$ 的数据，每个村庄最多成为两条道路的端点；\n- 对于 $100\\%$ 的数据，$1 \\leq N \\leq 100000,\\ 1 \\leq M \\leq 100000,\\ 1 \\leq z \\leq 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Treasure Hunt", "background": "", "description": "Xiao B is playing a treasure hunt game. The map has $N$ villages and $N-1$ roads, and there is exactly one path between any two villages. At the beginning, the player may choose any village and instantly teleport to it, then walk arbitrarily along the roads on the map. If the player reaches a village that contains a treasure, that treasure is considered found. The process continues until all treasures are found and the player returns to the village they initially teleported to.\n\nXiao B wants to evaluate the difficulty of this game, so he needs to know the shortest distance a player must walk to find all treasures. However, the treasures in this game change frequently: sometimes a treasure suddenly appears in a village, and sometimes a treasure in a village suddenly disappears. Therefore, Xiao B needs to update the data continuously. Since he is too lazy to do the calculations himself, he asks for your help. To simplify the problem, assume that initially no village contains a treasure.", "inputFormat": "The first line contains two integers $N, M$, where $M$ is the number of treasure changes.\n\nThe next $N-1$ lines each contain three integers $x, y, z$, indicating that there is a road of length $z$ between villages $x$ and $y$.\n\nThe next $M$ lines each contain one integer $t$, representing a treasure toggle operation. If before this operation village $t$ does not contain a treasure, then after the operation it contains a treasure; if before the operation village $t$ contains a treasure, then after the operation it does not.", "outputFormat": "Output $M$ lines, each containing one integer. The integer on the $i$-th line is the shortest distance the player needs to walk to find all treasures after the $i$-th operation. If there is only one village with a treasure, or no village has a treasure, output `0`.", "hint": "- For 10% of the testdata, $1 \\leq N \\leq 100, 1 \\leq M \\leq 100$.\n- For 20% of the testdata, $1 \\leq N \\leq 1000, 1 \\leq M \\leq 1000$.\n- For another 15% of the testdata, each village is incident to at most two roads.\n- For 100% of the testdata, $1 \\leq N \\leq 100000,\\ 1 \\leq M \\leq 100000,\\ 1 \\leq z \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 寻宝游戏", "background": "", "description": "小 B 最近正在玩一个寻宝游戏，这个游戏的地图中有 $N$ 个村庄和 $N-1$ 条道路，并且任何两个村庄之间有且仅有一条路径可达。游戏开始时，玩家可以任意选择一个村庄，瞬间转移到这个村庄，然后可以任意在地图的道路上行走，若走到某个村庄中有宝物，则视为找到该村庄内的宝物，直到找到所有宝物并返回到最初转移到的村庄为止。\n\n小 B 希望评测一下这个游戏的难度，因此他需要知道玩家找到所有宝物需要行走的最短路程。但是这个游戏中宝物经常变化，有时某个村庄中会突然出现宝物，有时某个村庄内的宝物会突然消失，因此小 B 需要不断地更新数据，但是小 B 太懒了，不愿意自己计算，因此他向你求助。为了简化问题，我们认为最开始时所有村庄内均没有宝物。", "inputFormat": "第一行，两个整数 $N,M$，其中 $M$ 为宝物的变动次数。\n\n接下来的 $N-1$ 行，每行三个整数 $x,y,z$，表示村庄 $x,y$ 之间有一条长度为 $z$ 的道路。\n\n接下来的 $M$ 行，每行一个整数 $t$，表示一个宝物变动的操作。若该操作前村庄 $t$ 内没有宝物，则操作后村庄内有宝物；若该操作前村庄 $t$ 内有宝物，则操作后村庄内没有宝物。", "outputFormat": "$M$ 行，每行一个整数，其中第 $i$ 行的整数表示第 $i$ 次操作之后玩家找到所有宝物需要行走的最短路程。若只有一个村庄内有宝物，或者所有村庄内都没有宝物，则输出 `0`。", "hint": "- 对于 $10\\%$ 的数据，$1 \\leq N \\leq 100, 1 \\leq M \\leq 100$；\n- 对于 $20\\%$ 的数据，$1 \\leq N \\leq 1000, 1 \\leq M \\leq 1000$；\n- 对于另外 $15\\%$ 的数据，每个村庄最多成为两条道路的端点；\n- 对于 $100\\%$ 的数据，$1 \\leq N \\leq 100000,\\ 1 \\leq M \\leq 100000,\\ 1 \\leq z \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3321", "type": "P", "difficulty": 6, "samples": [["4 3 1 2\n1 2", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "各省省选", "山东", "素数判断,质数,筛法", "快速傅里叶变换 FFT", "快速数论变换 NTT"], "title": "[SDOI2015] 序列统计", "background": null, "description": "小 C 有一个集合 $S$，里面的元素都是小于 $m$ 的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为 $n$ 的数列，数列中的每个数都属于集合 $S$。  \n\n小 C 用这个生成器生成了许多这样的数列。但是小 C 有一个问题需要你的帮助：给定整数 $x$，求所有可以生成出的，且满足数列中所有数的乘积 $\\bmod \\ m$ 的值等于 $x$ 的不同的数列的有多少个。  \n\n小 C 认为，两个数列 $A$ 和 $B$ 不同，当且仅当 $\\exists i \\text{ s.t. } A_i \\neq B_i$。另外，小 C 认为这个问题的答案可能很大，因此他只需要你帮助他求出答案对 $1004535809$ 取模的值就可以了。", "inputFormat": "一行，四个整数，$n,m,x,|S|$，其中 $|S|$ 为集合 $S$ 中元素个数。  \n第二行，$|S|$ 个整数，表示集合 $S$ 中的所有元素。", "outputFormat": "一行一个整数表示答案。", "hint": "【样例说明】\n\n可以生成的满足要求的不同的数列有 $(1,1,1,1)$、$(1,1,2,2)$、$(1,2,1,2)$、$(1,2,2,1)$、$(2,1,1,2)$、$(2,1,2,1)$、$(2,2,1,1)$、$(2,2,2,2)$。\n\n【数据规模和约定】\n\n对于 $10\\%$ 的数据，$1\\le n \\le 1000$；   \n对于 $30\\%$ 的数据，$3 \\le m \\le 100$；    \n对于 $60\\%$ 的数据，$3 \\le m \\le 800$；   \n对于 $100\\%$ 的数据，$1 \\le n \\le 10^9$，$3 \\le m \\le 8000$，$1\\le x < m$。   \n$m$ 为质数，输入数据保证集合 $S$ 中元素不重复。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Sequence Statistics", "background": "", "description": "Xiao C has a set $S$ whose elements are non-negative integers less than $m$. He wrote a sequence generator that can generate a sequence of length $n$, where every term belongs to the set $S$.\n\nXiao C generated many such sequences. However, he needs your help with the following question: given an integer $x$, count how many different sequences can be generated such that the product of all numbers in the sequence $\\bmod \\ m$ equals $x$.\n\nXiao C considers two sequences $A$ and $B$ different if and only if $\\exists i \\text{ s.t. } A_i \\neq B_i$. Since the answer may be large, he only needs the answer modulo $1004535809$.", "inputFormat": "One line with four integers $n, m, x, |S|$, where $|S|$ is the number of elements in the set $S$.  \nThe second line contains $|S|$ integers, representing all elements of the set $S$.", "outputFormat": "Output a single integer on one line, representing the answer.", "hint": "Sample explanation:\n\nThe different sequences that can be generated and satisfy the requirement are $(1,1,1,1)$, $(1,1,2,2)$, $(1,2,1,2)$, $(1,2,2,1)$, $(2,1,1,2)$, $(2,1,2,1)$, $(2,2,1,1)$, $(2,2,2,2)$.\n\nConstraints:\n\nFor $10\\%$ of the testdata, $1 \\le n \\le 1000$.  \nFor $30\\%$ of the testdata, $3 \\le m \\le 100$.  \nFor $60\\%$ of the testdata, $3 \\le m \\le 800$.  \nFor $100\\%$ of the testdata, $1 \\le n \\le 10^9$, $3 \\le m \\le 8000$, $1 \\le x < m$.  \n$m$ is a prime, and the input guarantees that the elements in set $S$ are distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 序列统计", "background": null, "description": "小 C 有一个集合 $S$，里面的元素都是小于 $m$ 的非负整数。他用程序编写了一个数列生成器，可以生成一个长度为 $n$ 的数列，数列中的每个数都属于集合 $S$。  \n\n小 C 用这个生成器生成了许多这样的数列。但是小 C 有一个问题需要你的帮助：给定整数 $x$，求所有可以生成出的，且满足数列中所有数的乘积 $\\bmod \\ m$ 的值等于 $x$ 的不同的数列的有多少个。  \n\n小 C 认为，两个数列 $A$ 和 $B$ 不同，当且仅当 $\\exists i \\text{ s.t. } A_i \\neq B_i$。另外，小 C 认为这个问题的答案可能很大，因此他只需要你帮助他求出答案对 $1004535809$ 取模的值就可以了。", "inputFormat": "一行，四个整数，$n,m,x,|S|$，其中 $|S|$ 为集合 $S$ 中元素个数。  \n第二行，$|S|$ 个整数，表示集合 $S$ 中的所有元素。", "outputFormat": "一行一个整数表示答案。", "hint": "【样例说明】\n\n可以生成的满足要求的不同的数列有 $(1,1,1,1)$、$(1,1,2,2)$、$(1,2,1,2)$、$(1,2,2,1)$、$(2,1,1,2)$、$(2,1,2,1)$、$(2,2,1,1)$、$(2,2,2,2)$。\n\n【数据规模和约定】\n\n对于 $10\\%$ 的数据，$1\\le n \\le 1000$；   \n对于 $30\\%$ 的数据，$3 \\le m \\le 100$；    \n对于 $60\\%$ 的数据，$3 \\le m \\le 800$；   \n对于 $100\\%$ 的数据，$1 \\le n \\le 10^9$，$3 \\le m \\le 8000$，$1\\le x < m$。   \n$m$ 为质数，输入数据保证集合 $S$ 中元素不重复。", "locale": "zh-CN"}}}
{"pid": "P3322", "type": "P", "difficulty": 5, "samples": [["3\n7 8 5 6 1 2 4 3", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2015", "各省省选", "山东", "排序", "深度优先搜索 DFS"], "title": "[SDOI2015] 排序", "background": null, "description": "小 A 有一个 $1\\sim 2^N$ 的排列 $A_1\\sim A_{2^N}$，他希望将 $A$ 数组从小到大排序,小 $A$ 可以执行的操作有 $N$ 种，每种操作最多可以执行一次，对于所有的 $i(1\\le i\\le N)$，第 $i$ 种操作为将序列从左到右划分为 $2^{N-i+1}$ 段，每段恰好包括 $2^{i-1}$ 个数,然后整体交换其中两段。\n\n小 A 想知道可以将数组 $A$ 从小到大排序的不同的操作序列有多少个。小 A 认为两个操作序列不同，当且仅当操作个数不同，或者至少一个操作不同（种类不同或者操作位置不同）。\n\n下面是一个操作示例: $N=3,A=[3,6,1,2,7,8,5,4]$。\n- 第一次操作，执行第 $3$ 种操作，交换 $A[1..4]$ 和 $A[5..8]$，交换后的 $A$ 为$[7,8,5,4,3,6,1,2]$。\n- 第二次操作，执行第 $1$ 种操作，交换 $A[3]$ 和 $A[5]$，交换后的 $A$ 为$[7,8,3,4,5,6,1,2]$。\n- 第三次操作，执行第 $2$ 种操作，交换 $A[1..2]$ 和 $A[7..8]$，交换后的 $A[1..8]$ 为$[1,2,3,4,5,6,7,8]$。", "inputFormat": "第一行，一个整数 $N$。\n\n第二行，$2^N$ 个整数，$A_1\\sim A_{2^N}$。", "outputFormat": "一个整数表示答案。", "hint": "$100\\%$ 的数据, $1\\le N\\le 12$。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Sorting", "background": "", "description": "Xiao A has a permutation $A_1$ through $A_{2^N}$ of $1$ through $2^N$. He wants to sort array $A$ in ascending order. Xiao A can perform $N$ types of operations, and each type can be used at most once. For every $i$ ($1 \\le i \\le N$), the $i$-th operation splits the sequence from left to right into $2^{N-i+1}$ blocks, each containing exactly $2^{i-1}$ numbers, and then swaps two of these blocks as a whole.\n\nXiao A wants to know how many different sequences of operations can sort array $A$ in ascending order. Two sequences of operations are considered different if and only if the number of operations is different, or at least one operation is different (either the type or the positions are different).\n\nHere is an example of operations: $N = 3$, $A = [3,6,1,2,7,8,5,4]$.\n- First operation: perform the 3rd operation, swap A[1..4] and A[5..8]. After the swap, $A = [7,8,5,4,3,6,1,2]$.\n- Second operation: perform the 1st operation, swap A[3] and A[5]. After the swap, $A = [7,8,3,4,5,6,1,2]$.\n- Third operation: perform the 2nd operation, swap A[1..2] and A[7..8]. After the swap, $A[1..8] = [1,2,3,4,5,6,7,8]$.", "inputFormat": "The first line contains an integer $N$.\n\nThe second line contains $2^N$ integers, $A_1$ through $A_{2^N}$.", "outputFormat": "Output a single integer denoting the answer.", "hint": "Constraints: For 100% of the testdata, $1 \\le N \\le 12$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 排序", "background": null, "description": "小 A 有一个 $1\\sim 2^N$ 的排列 $A_1\\sim A_{2^N}$，他希望将 $A$ 数组从小到大排序,小 $A$ 可以执行的操作有 $N$ 种，每种操作最多可以执行一次，对于所有的 $i(1\\le i\\le N)$，第 $i$ 种操作为将序列从左到右划分为 $2^{N-i+1}$ 段，每段恰好包括 $2^{i-1}$ 个数,然后整体交换其中两段。\n\n小 A 想知道可以将数组 $A$ 从小到大排序的不同的操作序列有多少个。小 A 认为两个操作序列不同，当且仅当操作个数不同，或者至少一个操作不同（种类不同或者操作位置不同）。\n\n下面是一个操作示例: $N=3,A=[3,6,1,2,7,8,5,4]$。\n- 第一次操作，执行第 $3$ 种操作，交换 $A[1..4]$ 和 $A[5..8]$，交换后的 $A$ 为$[7,8,5,4,3,6,1,2]$。\n- 第二次操作，执行第 $1$ 种操作，交换 $A[3]$ 和 $A[5]$，交换后的 $A$ 为$[7,8,3,4,5,6,1,2]$。\n- 第三次操作，执行第 $2$ 种操作，交换 $A[1..2]$ 和 $A[7..8]$，交换后的 $A[1..8]$ 为$[1,2,3,4,5,6,7,8]$。", "inputFormat": "第一行，一个整数 $N$。\n\n第二行，$2^N$ 个整数，$A_1\\sim A_{2^N}$。", "outputFormat": "一个整数表示答案。", "hint": "$100\\%$ 的数据, $1\\le N\\le 12$。", "locale": "zh-CN"}}}
{"pid": "P3323", "type": "P", "difficulty": 7, "samples": [["1\n5 6 4\n1 2\n2 3\n3 5\n1 4\n4 5\n2 5", "NYYYY \nYNNYY \nYNNYN \nYYYNY \nYYNYN"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "各省省选", "山东", "枚举"], "title": "[SDOI2015] 旅行计划", "background": "", "description": "在有 $N$ 座城市的国度，Alice 希望可以开始一场充满传奇的旅行。TA 希望可以从一个城市出发开始旅行，每次前往一个相邻的城市，途中不重复得经过恰好 $K$ 座城市，最后抵达另外一个城市并结束旅行。\n\n需要注意的是，起点与终点也被考虑为经过的城市，也就是说包括起点和终点在内经过的所有城市都是不能重复的。现在，Alice 希望知道哪些城市对 $(u,v)$ 可以作为合法的旅行起点与终点。\n", "inputFormat": "本题每一个测试点有多组测试数据。\n\n第一行给定正整数 $T$ ，表示数据组数。\n\n对于每一组数据来说，第一行给定三个整数 $N$，$M$ 和 $K$，表示城市个数，城市之间的相邻关系个数，还有旅途应该经过的城市个数。\n\n接下来 $M$ 行．每一行给定两个整数 $u$ 和 $v$ ，表示标号为 $u$ 的城市与标号为 $v$ 的城市之间是相邻的，即可以从其中一个城市出发前往另外一个。\n\n$N\\le 1000$，$M\\le 5000$，$2\\le K\\le 7$ 且 $T\\times \\left\\lfloor \\frac k 2 \\right\\rfloor^{\\left\\lfloor \\frac k 2 \\right\\rfloor}\\le 60$\n", "outputFormat": "对于每一组数据，输出 $N$ 行，每行 $N$ 个字符，其中第 $i$ 行第 $j$ 个字符，或者为 `Y` 或者为 `N`，分别表示是否存在从城市 $i$ 出发到城市 $j$ 结束的合法旅行方案。\n", "hint": "24.11.15：增加了 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Travel Plan", "background": "", "description": "In a country with $N$ cities, Alice wants to embark on a legendary journey. They wish to start from a city, each time moving to an adjacent city, visit exactly $K$ cities without repetition along the way, and finally arrive at another city to end the journey.\n\nNote that the starting city and the ending city are also counted among the visited cities. That is, including the start and end, all visited cities must be distinct. Now, Alice wants to know which ordered city pairs $(u, v)$ can serve as a valid start and end for such a journey.", "inputFormat": "Each test file contains multiple test cases.\n\nThe first line contains a positive integer $T$, the number of test cases.\n\nFor each test case, the first line contains three integers $N$, $M$, and $K$, denoting the number of cities, the number of adjacency relations between cities, and the number of cities that the trip should visit.\n\nThe next $M$ lines each contain two integers $u$ and $v$, indicating that city $u$ and city $v$ are adjacent, i.e., you can travel from either city to the other.\n\n$N\\le 1000$, $M\\le 5000$, $2\\le K\\le 7$, and $T\\times \\left\\lfloor \\frac k 2 \\right\\rfloor^{\\left\\lfloor \\frac k 2 \\right\\rfloor}\\le 60$.", "outputFormat": "For each test case, output $N$ lines, each containing $N$ characters. In the $i$-th row, the $j$-th character is either `Y` or `N`, indicating whether there exists a valid travel plan starting from city $i$ and ending at city $j$.", "hint": "2024-11-15: Added hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 旅行计划", "background": "", "description": "在有 $N$ 座城市的国度，Alice 希望可以开始一场充满传奇的旅行。TA 希望可以从一个城市出发开始旅行，每次前往一个相邻的城市，途中不重复得经过恰好 $K$ 座城市，最后抵达另外一个城市并结束旅行。\n\n需要注意的是，起点与终点也被考虑为经过的城市，也就是说包括起点和终点在内经过的所有城市都是不能重复的。现在，Alice 希望知道哪些城市对 $(u,v)$ 可以作为合法的旅行起点与终点。\n", "inputFormat": "本题每一个测试点有多组测试数据。\n\n第一行给定正整数 $T$ ，表示数据组数。\n\n对于每一组数据来说，第一行给定三个整数 $N$，$M$ 和 $K$，表示城市个数，城市之间的相邻关系个数，还有旅途应该经过的城市个数。\n\n接下来 $M$ 行．每一行给定两个整数 $u$ 和 $v$ ，表示标号为 $u$ 的城市与标号为 $v$ 的城市之间是相邻的，即可以从其中一个城市出发前往另外一个。\n\n$N\\le 1000$，$M\\le 5000$，$2\\le K\\le 7$ 且 $T\\times \\left\\lfloor \\frac k 2 \\right\\rfloor^{\\left\\lfloor \\frac k 2 \\right\\rfloor}\\le 60$\n", "outputFormat": "对于每一组数据，输出 $N$ 行，每行 $N$ 个字符，其中第 $i$ 行第 $j$ 个字符，或者为 `Y` 或者为 `N`，分别表示是否存在从城市 $i$ 出发到城市 $j$ 结束的合法旅行方案。\n", "hint": "24.11.15：增加了 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P3324", "type": "P", "difficulty": 6, "samples": [["2 2\n3 10\n4 6\n0 1\n1 1", "1.300000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "二分", "各省省选", "网络流", "山东", "Special Judge"], "title": "[SDOI2015] 星际战争", "background": null, "description": "$3333$ 年，在银河系的某星球上，X 军团和 Y 军团正在激烈地作战。\n\n在战斗的某一阶段，Y 军团一共派遣了 $N$ 个巨型机器人进攻 X 军团的阵地，其中第 $i$ 个巨型机器人的装甲值为 $A_i$。当一个巨型机器人的装甲值减少到 $0$ 或者以下时，这个巨型机器人就被摧毁了。\n\nX 军团有 $M$ 个激光武器，其中第 $i$ 个激光武器每秒可以削减一个巨型机器人 $B_i$ 的装甲值。激光武器的攻击是连续的。\n\n这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y 军团看到自己的巨型机器人被 X 军团一个一个消灭，他们急需下达更多的指令。\n\n为了这个目标，Y 军团需要知道 X 军团最少需要用多长时间才能将 Y 军团的所有巨型机器人摧毁。但是他们不会计算这个问题，因此向你求助。", "inputFormat": "第一行，两个整数，$N,M$。\n\n第二行，$N$ 个整数，$A_1,A_2 \\cdots A_N$。\n\n第三行，$M$ 个整数，$B_1,B_2 \\cdots B_M$。\n\n接下来的 $M$ 行，每行 $N$ 个整数，这些整数均为 $0$ 或者 $1$。这部分中的第 $i$ 行的第 $j$ 个整数为 $0$ 表示第 $i$ 个激光武器不可以攻击第 $j$ 个巨型机器人，为 $1$ 表示第 $i$ 个激光武器可以攻击第 $j$ 个巨型机器人。", "outputFormat": "一行，一个实数，表示 X 军团要摧毁 Y 军团的所有巨型机器人最少需要的时间。输出结果与标准答案的绝对误差不超过 $10^{-3}$ 即视为正确。", "hint": "**【样例说明1】**\n\n战斗开始后的前 $0.5$ 秒，激光武器 $1$ 攻击 $2$ 号巨型机器人，激光武器 $2$ 攻击 $1$ 号巨型机器人。$1$ 号巨型机器人被完全摧毁，$2$ 号巨型机器人还剩余 $8$ 的装甲值；\n\n接下来的 $0.8$ 秒，激光武器 $1$ 、 $2$ 同时攻击 $2$ 号巨型机器人。$2$ 号巨型机器人被完全摧毁。\n\n**【数据范围】**\n\n对于全部的数据，$1 \\le N,M \\le 50$，$1 \\le A_i \\le 10^5$，$1 \\le B_i \\le 1000$，输入数据保证 X 军团一定能摧毁 Y 军团的所有巨型机器人。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Interstellar War", "background": "", "description": "In the year $3333$, on a certain planet in the Milky Way, the X Legion and the Y Legion are fighting fiercely.\n\nAt a certain stage of the battle, the Y Legion sends $N$ giant robots to attack the X Legion’s position. The $i$-th giant robot has an armor value of $A_i$. When a robot’s armor value drops to $0$ or below, the robot is destroyed.\n\nThe X Legion has $M$ laser weapons. The $i$-th laser weapon can reduce the armor of a single giant robot by $B_i$ per second. The laser weapons’ attacks are continuous over time.\n\nThese laser weapons are peculiar: each weapon can attack only certain designated enemies. Seeing their robots being destroyed one after another, the Y Legion urgently needs to issue more commands.\n\nTo this end, the Y Legion needs to know the minimum time the X Legion requires to destroy all of the Y Legion’s giant robots. However, they cannot compute this themselves, so they ask you for help.", "inputFormat": "The first line contains two integers, $N, M$.\n\nThe second line contains $N$ integers, $A_1, A_2 \\cdots A_N$.\n\nThe third line contains $M$ integers, $B_1, B_2 \\cdots B_M$.\n\nEach of the next $M$ lines contains $N$ integers, each being $0$ or $1$. In this part, the $j$-th integer of the $i$-th line is $0$ if the $i$-th laser weapon cannot attack the $j$-th giant robot, and $1$ if it can.", "outputFormat": "Output a single real number: the minimum time required for the X Legion to destroy all of the Y Legion’s giant robots. Answers with an absolute error not exceeding $10^{-3}$ are accepted.", "hint": "- Sample Explanation 1:\n\nFor the first $0.5$ seconds, laser weapon $1$ attacks robot $2$, and laser weapon $2$ attacks robot $1$. Robot $1$ is completely destroyed; robot $2$ has $8$ armor remaining.\n\nFor the next $0.8$ seconds, laser weapons $1$ and $2$ attack robot $2$ simultaneously. Robot $2$ is completely destroyed.\n\n- Constraints:\n\nFor all testdata, $1 \\le N, M \\le 50$, $1 \\le A_i \\le 10^5$, $1 \\le B_i \\le 1000$, and the input guarantees that the X Legion can destroy all of the Y Legion’s giant robots.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 星际战争", "background": null, "description": "$3333$ 年，在银河系的某星球上，X 军团和 Y 军团正在激烈地作战。\n\n在战斗的某一阶段，Y 军团一共派遣了 $N$ 个巨型机器人进攻 X 军团的阵地，其中第 $i$ 个巨型机器人的装甲值为 $A_i$。当一个巨型机器人的装甲值减少到 $0$ 或者以下时，这个巨型机器人就被摧毁了。\n\nX 军团有 $M$ 个激光武器，其中第 $i$ 个激光武器每秒可以削减一个巨型机器人 $B_i$ 的装甲值。激光武器的攻击是连续的。\n\n这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y 军团看到自己的巨型机器人被 X 军团一个一个消灭，他们急需下达更多的指令。\n\n为了这个目标，Y 军团需要知道 X 军团最少需要用多长时间才能将 Y 军团的所有巨型机器人摧毁。但是他们不会计算这个问题，因此向你求助。", "inputFormat": "第一行，两个整数，$N,M$。\n\n第二行，$N$ 个整数，$A_1,A_2 \\cdots A_N$。\n\n第三行，$M$ 个整数，$B_1,B_2 \\cdots B_M$。\n\n接下来的 $M$ 行，每行 $N$ 个整数，这些整数均为 $0$ 或者 $1$。这部分中的第 $i$ 行的第 $j$ 个整数为 $0$ 表示第 $i$ 个激光武器不可以攻击第 $j$ 个巨型机器人，为 $1$ 表示第 $i$ 个激光武器可以攻击第 $j$ 个巨型机器人。", "outputFormat": "一行，一个实数，表示 X 军团要摧毁 Y 军团的所有巨型机器人最少需要的时间。输出结果与标准答案的绝对误差不超过 $10^{-3}$ 即视为正确。", "hint": "**【样例说明1】**\n\n战斗开始后的前 $0.5$ 秒，激光武器 $1$ 攻击 $2$ 号巨型机器人，激光武器 $2$ 攻击 $1$ 号巨型机器人。$1$ 号巨型机器人被完全摧毁，$2$ 号巨型机器人还剩余 $8$ 的装甲值；\n\n接下来的 $0.8$ 秒，激光武器 $1$ 、 $2$ 同时攻击 $2$ 号巨型机器人。$2$ 号巨型机器人被完全摧毁。\n\n**【数据范围】**\n\n对于全部的数据，$1 \\le N,M \\le 50$，$1 \\le A_i \\le 10^5$，$1 \\le B_i \\le 1000$，输入数据保证 X 军团一定能摧毁 Y 军团的所有巨型机器人。", "locale": "zh-CN"}}}
{"pid": "P3325", "type": "P", "difficulty": 7, "samples": [["5\nCC/..\n././/\n..C.C\n/.C..\n/./C/\n1 1\n1 2\n1 3\n1 4\n1 5\n0.3 0.3 0.3 0.3 0.3\n0.3 0.3 0.3 0.3 0.3", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "各省省选", "山东"], "title": "[SDOI2015] 模拟电路", "background": "", "description": "一家著名的芯片公司希望您能帮他们在一些最新的产品上安装可以稳定电压的组件。每块芯片都被设计成 $N\\times M$ 的带插槽的正方形，一个插槽可以安装一块单独的组件，你的任务是尽可能多地插入这些组件。\n\n现代处理器的设计是很复杂的。为了可以稳定电压，你要面对下面几个限制：一些插槽是不可用的。一些插槽已经被其它的组件占据了，因而无法被新的组件使用。内存总线要连接到芯片的水平和垂直的边界上，它们的负载电压需要是安全的。\n\n具体来说，芯片公司提供了 $N$ 组限制条件，分别对应了 $N$ 行。其中对于第 $i$ 行以及第 $i$ 组限制条件，给定非负整数 $T_i$ 与 $T_i$ 个列编号，记为 $r_{i,j}$（$1\\le j\\le T_i$），要求满足：第 $i$ 行的组件数目不能超过指定的 $T_i$ 个列方向上组件数目的和（也就是不超过“第 $r_{i,1}$ 列的组件数目 $+$ 第 $r_{i,2}$ 列的组件数目 $+$ $\\cdots$”）。为了避免插槽过热，给定浮点数 $s_i$（$1\\le i\\le N$） 且 $0\\le s_i\\le 1$，要求第 $i$ 行的组件数不超过总组件数的 $s_i$。同样给定浮点数 $t_i$（$1\\le i\\le N$）且 $0\\le T_i\\le 1$，要求第 $i$ 列的组件数不超过总组件数的 $t_i$。\n\n需要注意的是，已经占据了位置的组件，在统计一行或一列组件总数时，也是要被考虑在内的。而在计算芯片总组件数时．也要将已经占据了位置的组件考虑进去。芯片被描述为一个 $N$ 行，每行 $N$ 个字符的矩阵，其中 `.` 表示开放插槽，`/` 表示不可用插槽，`C` 表示插槽已被一个组件占据。\n", "inputFormat": "第一行给定 $1$ 个正整数，表示芯片的规模 $N$（$1\\le N\\le 40$）。\n\n然后给出 $N$ 行，每行 $N$ 个字符描述插槽，字符为 `.` ， `/` 或 `C` 之一，含义如上所述。\n\n之后 $N$ 行，描述了限制条件。其中第 $i$ 行首先给出非负整数 $T_i$，表示第 $i$ 行的限制条件涉及到的列的个数。之后再给出 $T_i$ 个不重复的整数（都在 $1$ 到 $N$ 的范围中），描述了相关的列。\n\n再下一行，给出了 $N$ 个浮点数依次对应 $s_i$。每一个数字小数点后不超过三位。\n\n再下一行，给出了 $N$ 个浮点数依次对应 $t_i$。每一个数字小数点后不超过三位。\n", "outputFormat": "如果存在合法的策略，输出最多可以再在芯片上安装多少个组件。否则输出 `impossible`。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Analog Circuit", "background": "", "description": "A well-known chip company asks you to help install components that stabilize voltage on some of their latest products. Each chip is designed as an $N \\times N$ grid of slots; a slot can hold a single component. Your task is to insert as many new components as possible.\n\nModern processors are complex. To keep the voltage stable, you must obey several restrictions: some slots are unusable; some slots are already occupied by other components and thus cannot be used for new ones; memory buses attach to the horizontal and vertical boundaries of the chip, and their load voltages must be safe.\n\nSpecifically, the company provides $N$ sets of constraints, one per row. For row $i$ (and its constraint set $i$), you are given a nonnegative integer $T_i$ and $T_i$ column indices $r_{i,j}$ ($1 \\le j \\le T_i$). The requirement is: the number of components in row $i$ must not exceed the sum of the numbers of components in the specified $T_i$ columns (i.e., at most “the number of components in column $r_{i,1}$ + the number of components in column $r_{i,2}$ + $\\cdots$”).\n\nTo avoid slot overheating, you are given a real number $s_i$ ($1 \\le i \\le N$) with $0 \\le s_i \\le 1$, and you must ensure that the number of components in row $i$ does not exceed $s_i$ times the total number of components. Similarly, you are given a real number $t_i$ ($1 \\le i \\le N$) with $0 \\le t_i \\le 1$, and you must ensure that the number of components in column $i$ does not exceed $t_i$ times the total number of components.\n\nNote that slots already occupied by components are counted when computing the number of components in any row or column. They are also counted in the total number of components on the chip. The chip is described by an $N$-row, $N$-column character matrix, where `.` denotes an open slot, `/` denotes an unusable slot, and `C` denotes a slot already occupied by a component.", "inputFormat": "- The first line contains a positive integer $N$ ($1 \\le N \\le 40$), the size of the chip.\n- Then follow $N$ lines, each containing $N$ characters describing the slots, each character being one of `.`, `/`, or `C`, as defined above.\n- Then follow $N$ lines describing the constraint sets. On the $i$-th of these lines, first a nonnegative integer $T_i$ is given, followed by $T_i$ distinct integers (each between $1$ and $N$) specifying the related columns.\n- The next line contains $N$ real numbers, in order, corresponding to $s_i$. Each number has at most three digits after the decimal point.\n- The next line contains $N$ real numbers, in order, corresponding to $t_i$. Each number has at most three digits after the decimal point.", "outputFormat": "If there exists a valid placement strategy, output the maximum number of additional components that can be installed on the chip. Otherwise, output `impossible`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 模拟电路", "background": "", "description": "一家著名的芯片公司希望您能帮他们在一些最新的产品上安装可以稳定电压的组件。每块芯片都被设计成 $N\\times M$ 的带插槽的正方形，一个插槽可以安装一块单独的组件，你的任务是尽可能多地插入这些组件。\n\n现代处理器的设计是很复杂的。为了可以稳定电压，你要面对下面几个限制：一些插槽是不可用的。一些插槽已经被其它的组件占据了，因而无法被新的组件使用。内存总线要连接到芯片的水平和垂直的边界上，它们的负载电压需要是安全的。\n\n具体来说，芯片公司提供了 $N$ 组限制条件，分别对应了 $N$ 行。其中对于第 $i$ 行以及第 $i$ 组限制条件，给定非负整数 $T_i$ 与 $T_i$ 个列编号，记为 $r_{i,j}$（$1\\le j\\le T_i$），要求满足：第 $i$ 行的组件数目不能超过指定的 $T_i$ 个列方向上组件数目的和（也就是不超过“第 $r_{i,1}$ 列的组件数目 $+$ 第 $r_{i,2}$ 列的组件数目 $+$ $\\cdots$”）。为了避免插槽过热，给定浮点数 $s_i$（$1\\le i\\le N$） 且 $0\\le s_i\\le 1$，要求第 $i$ 行的组件数不超过总组件数的 $s_i$。同样给定浮点数 $t_i$（$1\\le i\\le N$）且 $0\\le T_i\\le 1$，要求第 $i$ 列的组件数不超过总组件数的 $t_i$。\n\n需要注意的是，已经占据了位置的组件，在统计一行或一列组件总数时，也是要被考虑在内的。而在计算芯片总组件数时．也要将已经占据了位置的组件考虑进去。芯片被描述为一个 $N$ 行，每行 $N$ 个字符的矩阵，其中 `.` 表示开放插槽，`/` 表示不可用插槽，`C` 表示插槽已被一个组件占据。\n", "inputFormat": "第一行给定 $1$ 个正整数，表示芯片的规模 $N$（$1\\le N\\le 40$）。\n\n然后给出 $N$ 行，每行 $N$ 个字符描述插槽，字符为 `.` ， `/` 或 `C` 之一，含义如上所述。\n\n之后 $N$ 行，描述了限制条件。其中第 $i$ 行首先给出非负整数 $T_i$，表示第 $i$ 行的限制条件涉及到的列的个数。之后再给出 $T_i$ 个不重复的整数（都在 $1$ 到 $N$ 的范围中），描述了相关的列。\n\n再下一行，给出了 $N$ 个浮点数依次对应 $s_i$。每一个数字小数点后不超过三位。\n\n再下一行，给出了 $N$ 个浮点数依次对应 $t_i$。每一个数字小数点后不超过三位。\n", "outputFormat": "如果存在合法的策略，输出最多可以再在芯片上安装多少个组件。否则输出 `impossible`。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3326", "type": "P", "difficulty": 6, "samples": [["2 2\n2 1\n1 1\nR**\n***\n**G\n", "        +-------+\n       /Y\\YYYY'/|\n      /YY.*'YY/G|\n     /.YYYY\\Y/G/|\n    +-------+G.G|\n    |\\GGGGG/|\\:G|\n    |G\\GGG/G|G*G|\n    |GG\\G/GG|G:\\|\n    |GGGXGGG|G'G+-------+\n    |GG/G\\GG|/G/G\\YYYY'/|\n    |G/GGG\\G|G/GG.*'YY/G|\n    |/GGGGG\\|/.GGGG\\Y/G/|\n    +-------+-------+G.G|\n   /Y\\GGGG'/G\\GGGG'/|\\:G|\n  /YY.*'GG/GG.*'GG/G|G*G|\n /.YYYY\\G/.GGGG\\G/G/|G:\\|\n+-------+-------+G.G|G'G+\n|\\GGGGG/|\\GGGGG/|\\:G|/G/\n|G\\GGG/G|G\\GGG/G|G*G|G/\n|GG\\G/GG|GG\\G/GG|G:\\|/\n|GGGXGGG|GGGXGGG|G'G+\n|GG/G\\GG|GG/G\\GG|/G/\n|G/GGG\\G|G/GGG\\G|G/\n|/GGGGG\\|/GGGGG\\|/\n+-------+-------+\n"], ["3 4\n1 1 2 1\n1 2 1 2\n2 1 2 1\n**B\n***\nR*G\n", "                            +-------+\n                           /W\\WWWW'/|\n                          /WW.*'WW/C|\n                         /.WWWW\\W/C/|\n                +-------+-------+-------+\n               /W\\WWWW'/|\\YYYYY/W\\WWWW'/|\n              /WW.*'WW/C|G\\YYY/WW.*'WW/C|\n             /.WWWW\\W/C/|GG\\Y/.WWWW\\W/C/|\n    +-------+-------+-------+-------+C.C|---+\n   /W\\WWWW'/|\\YYYYY/W\\WWWW'/|\\YYYYY/|\\:C|C'/|\n  /WW.*'WW/C|G\\YYY/WW.*'WW/C|G\\YYY/Y|C*C|C/C|\n /.WWWW\\W/C/|GG\\Y/.WWWW\\W/C/|GG\\Y/YY|C:\\|/C/|\n+-------+C.G|GGG+-------+C.G|GGGXYYY|C'C+C.C|\n|\\YYYYY/|\\:G|GG/|\\YYYYY/|\\:G|GG/G\\YY|/C/|\\:C|\n|Y\\YYY/Y|C*G|G/K|Y\\YYY/Y|C*G|G/GGG\\Y|C/C|C*C|\n|YY\\Y/YY|C:\\|/KK|YY\\Y/YY|C:\\|/GGGGG\\|/C/|C:\\|\n|YYYXYYY|C'G+---|YYYXYYY|C'G+-------+C.C|C'C+\n|YY/Y\\YY|/G/G\\KK|YY/Y\\YY|/G/G\\GGGG'/|\\:C|/C/\n|Y/YYY\\Y|G/GG.*'|Y/YYY\\Y|G/GG.*'WW/C|C*C|C/\n|/YYYYY\\|/.YYYY\\|/YYYYY\\|/.WWWW\\W/C/|C:\\|/\n+-------+-------+-------+-------+C.C|C'C+\n|\\YYYYY/|\\YYYYY/|\\YYYYY/|\\YYYYY/|\\:C|/C/\n|Y\\YYY/Y|Y\\YYY/Y|Y\\YYY/Y|Y\\YYY/Y|C*C|C/\n|YY\\Y/YY|YY\\Y/YY|YY\\Y/YY|YY\\Y/YY|C:\\|/\n|YYYXYYY|YYYXYYY|YYYXYYY|YYYXYYY|C'C+\n|YY/Y\\YY|YY/Y\\YY|YY/Y\\YY|YY/Y\\YY|/C/\n|Y/YYY\\Y|Y/YYY\\Y|Y/YYY\\Y|Y/YYY\\Y|C/\n|/YYYYY\\|/YYYYY\\|/YYYYY\\|/YYYYY\\|/\n+-------+-------+-------+-------+"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "各省省选", "山东", "枚举"], "title": "[SDOI2015] 立体图", "background": null, "description": "小渊是个聪明的孩子，他经常会给周围的小朋友们讲些自己认为有趣的内容。最近，他准备给小朋友们讲解彩色水平光源照射下的立体图，并请你帮他在平面上画出来。\n\n小渊有一块面积为 $m\\times n$ 的矩形区域，上面有 $m\\times n$ 个边长为 1 的格子，每个格子上堆了一些同样大小的积木（积木的长宽高都是 $1$）。\n\n为了方便阐述，我们假设这块区域是坐北朝南的，下面我们给出一个例子。\n\n![](https://cdn.luogu.com.cn/upload/pic/22187.png)\n\n小渊想请你打印出这些格子的立体图。我们定义每个积木为如下格式，并且不会做任何翻转旋转，只会严格以这一种形式摆放（左侧是应该打印出来的图样，右侧为对应每一个位置符号的十进制 ASCII，其中 ASCII 为 $32$ 的符号为空格）。\n\n![](https://cdn.luogu.com.cn/upload/pic/22188.png)\n\n在良好的光学环境下，小渊将 $T$ 束平行光同时照射在这些积木上。这些平行光首先满足一定是红绿蓝三基色之一，其次入射角度满足：与 $x$ 轴 $y$ 轴的夹角度数均为 $45^\\circ$ 的倍数；且与 $z$ 轴正方向的夹角或为 $45^\\circ$，或为 $0^\\circ$，或为 $315^\\circ$。\n\n具体来说，我们最多会考虑 $9$ 个方向的不同平行光，它们的入射方向可以被描述为：西北方 $45^\\circ$ 仰角、正北方 $45^\\circ$ 仰角、东北方 $45^\\circ$ 仰角、正西方 $45^\\circ$ 仰角、垂直从上入射光、正东方 $45^\\circ$ 仰角、西南方 $45^\\circ$ 仰角、正南方 $45^\\circ$ 仰角、东南方 $45^\\circ$ 仰角。对于每一个单位积木来说，可以打印出来的三个表面被分为 $12$ 个小三角形。\n\n![](https://cdn.luogu.com.cn/upload/pic/22189.png)\n\n红绿蓝三基色分别用字母 R、G、B 来表示。而二次叠加后的三种颜色青黄紫，分别用 C、Y、P 来表示。对于三次叠加后的颜色，也就是白色，用 W 来表示。", "inputFormat": "第一行有两个正整数 $m,n$，表示区域有 $m$ 行 $n$ 列。之后 $m$ 行，依次由远及近描述了每一行的情况。每一行给出 $n$ 个正整数，表示第 $i$ 行第 $j$ 列中有堆放了多少积木。\n\n之后 $3$ 行，每行三个字符，描述了 $9$ 个对应方向（与地图描述方向相同）的光照颜色。其中每一个字符或者为 RGB 中之一，表示对应的颜色。或者为 `*`，表示没有照射光。这九个方向依次是：西北方 $45^\\circ$ 仰角、正北方 $45^\\circ$ 仰角、东北方 $45^\\circ$ 仰角、正西方 $45^\\circ$ 仰角、垂直从上入射光、正东方 $45^\\circ$ 仰角、西南方 $45^\\circ$ 仰角、正南方 $45^\\circ$ 仰角、东南方 $45^\\circ$ 仰角。", "outputFormat": "输出给出了打印后的效果。其中要求输出结果不含前导空行，结尾也没有额外空行。输出的第一列不能全是空格，且每一行末尾也没有额外空格。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/22190.png)\n\n对于 $15\\%$ 的数据，$1\\leq n,m\\leq100$，没有入射光。\n\n对于 $40\\%$ 的数据，$1\\leq n,m\\leq100$，入射光只有一束，且入射方向一定是东南方。\n\n对于 $100\\%$ 的数据，$1\\leq n,m\\leq100$，每一个位置堆放的积木总数不超过 $100$，入射光颜色可能是 R、G、B 中的任何一种颜色，最多可以有 $9$ 束入射光。", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] 3D Diagram", "background": "", "description": "Xiaoyuan (pinyin) is a smart kid who often explains things he finds interesting to the children around him. Recently, he plans to explain stereograms under colored horizontal light sources to the kids and asks you to help draw them on a plane.\n\nXiaoyuan has a rectangular area of size $m\\times n$ with $m\\times n$ unit squares, each of side length $1$. On each square, some identical blocks are stacked (each block has length, width, and height all equal to $1$).\n\nFor convenience, assume this area faces south with north at the top. Below is an example.\n\n![](https://cdn.luogu.com.cn/upload/pic/22187.png)\n\nXiaoyuan wants you to print the stereogram of these squares. We define each block in the following fixed format, and it will never be flipped or rotated; it is always placed strictly in this single orientation (the left side shows the pattern to be printed, and the right side shows the decimal ASCII for each position; ASCII $32$ is a space).\n\n![](https://cdn.luogu.com.cn/upload/pic/22188.png)\n\nUnder good optical conditions, Xiaoyuan shines $T$ beams of parallel light on these blocks simultaneously. These parallel lights satisfy: each is one of the three primary colors red, green, or blue; the angles with the $x$-axis and $y$-axis are multiples of $45^\\circ$; and the angle with the positive $z$-axis is either $45^\\circ$, $0^\\circ$, or $315^\\circ$.\n\nSpecifically, we consider at most $9$ different directions of parallel light. Their incident directions can be described as: northwest with $45^\\circ$ elevation, due north with $45^\\circ$ elevation, northeast with $45^\\circ$ elevation, due west with $45^\\circ$ elevation, vertical incidence from above, due east with $45^\\circ$ elevation, southwest with $45^\\circ$ elevation, due south with $45^\\circ$ elevation, and southeast with $45^\\circ$ elevation. For each unit block, the three printable faces are divided into $12$ small triangles.\n\n![](https://cdn.luogu.com.cn/upload/pic/22189.png)\n\nThe three primary colors red, green, and blue are represented by the letters R, G, and B. The three secondary colors after double overlap, cyan, yellow, and purple, are represented by C, Y, and P, respectively. For triple overlap, i.e., white, use W.", "inputFormat": "The first line contains two positive integers $m,n$, meaning the area has $m$ rows and $n$ columns. Then $m$ lines follow, describing each row from far to near in order. Each line gives $n$ positive integers, indicating how many blocks are stacked at cell $(i,j)$.\n\nThen there are $3$ lines, each with three characters, describing the colors of light in the $9$ corresponding directions (same directional order as described on the map). Each character is either one of RGB, indicating the corresponding color, or `*`, indicating no incident light. The nine directions, in order, are: northwest with $45^\\circ$ elevation, due north with $45^\\circ$ elevation, northeast with $45^\\circ$ elevation, due west with $45^\\circ$ elevation, vertical incidence from above, due east with $45^\\circ$ elevation, southwest with $45^\\circ$ elevation, due south with $45^\\circ$ elevation, and southeast with $45^\\circ$ elevation.", "outputFormat": "Output the rendered result. The output must not contain a leading blank line, and there must be no extra blank line at the end. The first column must not be all spaces, and there must be no trailing spaces at the end of any line.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/22190.png)\n\nFor $15\\%$ of the testdata, $1\\leq n,m\\leq 100$, and there is no incident light.\n\nFor $40\\%$ of the testdata, $1\\leq n,m\\leq 100$, there is only one incident beam, and its direction is guaranteed to be southeast.\n\nFor $100\\%$ of the testdata, $1\\leq n,m\\leq 100$, the number of blocks stacked at each position does not exceed $100$, the incident light color may be any one of R, G, or B, and there can be at most $9$ incident beams.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 立体图", "background": null, "description": "小渊是个聪明的孩子，他经常会给周围的小朋友们讲些自己认为有趣的内容。最近，他准备给小朋友们讲解彩色水平光源照射下的立体图，并请你帮他在平面上画出来。\n\n小渊有一块面积为 $m\\times n$ 的矩形区域，上面有 $m\\times n$ 个边长为 1 的格子，每个格子上堆了一些同样大小的积木（积木的长宽高都是 $1$）。\n\n为了方便阐述，我们假设这块区域是坐北朝南的，下面我们给出一个例子。\n\n![](https://cdn.luogu.com.cn/upload/pic/22187.png)\n\n小渊想请你打印出这些格子的立体图。我们定义每个积木为如下格式，并且不会做任何翻转旋转，只会严格以这一种形式摆放（左侧是应该打印出来的图样，右侧为对应每一个位置符号的十进制 ASCII，其中 ASCII 为 $32$ 的符号为空格）。\n\n![](https://cdn.luogu.com.cn/upload/pic/22188.png)\n\n在良好的光学环境下，小渊将 $T$ 束平行光同时照射在这些积木上。这些平行光首先满足一定是红绿蓝三基色之一，其次入射角度满足：与 $x$ 轴 $y$ 轴的夹角度数均为 $45^\\circ$ 的倍数；且与 $z$ 轴正方向的夹角或为 $45^\\circ$，或为 $0^\\circ$，或为 $315^\\circ$。\n\n具体来说，我们最多会考虑 $9$ 个方向的不同平行光，它们的入射方向可以被描述为：西北方 $45^\\circ$ 仰角、正北方 $45^\\circ$ 仰角、东北方 $45^\\circ$ 仰角、正西方 $45^\\circ$ 仰角、垂直从上入射光、正东方 $45^\\circ$ 仰角、西南方 $45^\\circ$ 仰角、正南方 $45^\\circ$ 仰角、东南方 $45^\\circ$ 仰角。对于每一个单位积木来说，可以打印出来的三个表面被分为 $12$ 个小三角形。\n\n![](https://cdn.luogu.com.cn/upload/pic/22189.png)\n\n红绿蓝三基色分别用字母 R、G、B 来表示。而二次叠加后的三种颜色青黄紫，分别用 C、Y、P 来表示。对于三次叠加后的颜色，也就是白色，用 W 来表示。", "inputFormat": "第一行有两个正整数 $m,n$，表示区域有 $m$ 行 $n$ 列。之后 $m$ 行，依次由远及近描述了每一行的情况。每一行给出 $n$ 个正整数，表示第 $i$ 行第 $j$ 列中有堆放了多少积木。\n\n之后 $3$ 行，每行三个字符，描述了 $9$ 个对应方向（与地图描述方向相同）的光照颜色。其中每一个字符或者为 RGB 中之一，表示对应的颜色。或者为 `*`，表示没有照射光。这九个方向依次是：西北方 $45^\\circ$ 仰角、正北方 $45^\\circ$ 仰角、东北方 $45^\\circ$ 仰角、正西方 $45^\\circ$ 仰角、垂直从上入射光、正东方 $45^\\circ$ 仰角、西南方 $45^\\circ$ 仰角、正南方 $45^\\circ$ 仰角、东南方 $45^\\circ$ 仰角。", "outputFormat": "输出给出了打印后的效果。其中要求输出结果不含前导空行，结尾也没有额外空行。输出的第一列不能全是空格，且每一行末尾也没有额外空格。", "hint": "![](https://cdn.luogu.com.cn/upload/pic/22190.png)\n\n对于 $15\\%$ 的数据，$1\\leq n,m\\leq100$，没有入射光。\n\n对于 $40\\%$ 的数据，$1\\leq n,m\\leq100$，入射光只有一束，且入射方向一定是东南方。\n\n对于 $100\\%$ 的数据，$1\\leq n,m\\leq100$，每一个位置堆放的积木总数不超过 $100$，入射光颜色可能是 R、G、B 中的任何一种颜色，最多可以有 $9$ 束入射光。", "locale": "zh-CN"}}}
{"pid": "P3327", "type": "P", "difficulty": 6, "samples": [["2\n7 4\n5 6", "110\n121"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2015", "各省省选", "数论", "山东", "最大公约数 gcd", "莫比乌斯反演", "整除分块", "筛法"], "title": "[SDOI2015] 约数个数和", "background": "", "description": "设 $d(x)$ 为 $x$ 的约数个数，给定 $n,m$，求    \n$$\\sum_{i=1}^n\\sum_{j=1}^md(ij)$$\n", "inputFormat": "输入文件包含多组测试数据。   \n第一行，一个整数 $T$，表示测试数据的组数。  \n接下来的 $T$ 行，每行两个整数 $n,m$。\n", "outputFormat": "$T$ 行，每行一个整数，表示你所求的答案。\n", "hint": "【数据范围】   \n对于 $100\\%$ 的数据，$1\\le T,n,m \\le 50000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Sum of Divisor Counts", "background": "", "description": "Let $d(x)$ be the number of divisors of $x$. Given $n, m$, compute\n$$\\sum_{i=1}^n\\sum_{j=1}^m d(ij).$$", "inputFormat": "The input contains multiple test cases.  \nThe first line contains an integer $T$, the number of test cases.  \nEach of the next $T$ lines contains two integers $n, m$.", "outputFormat": "Output $T$ lines, each containing one integer, the required answer.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le T, n, m \\le 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 约数个数和", "background": "", "description": "设 $d(x)$ 为 $x$ 的约数个数，给定 $n,m$，求    \n$$\\sum_{i=1}^n\\sum_{j=1}^md(ij)$$\n", "inputFormat": "输入文件包含多组测试数据。   \n第一行，一个整数 $T$，表示测试数据的组数。  \n接下来的 $T$ 行，每行两个整数 $n,m$。\n", "outputFormat": "$T$ 行，每行一个整数，表示你所求的答案。\n", "hint": "【数据范围】   \n对于 $100\\%$ 的数据，$1\\le T,n,m \\le 50000$。\n", "locale": "zh-CN"}}}
{"pid": "P3328", "type": "P", "difficulty": 6, "samples": [["7 7\n1 0\n3 4 5 6 7 8 9\nquery 2 4\nquery 3 7\nplus 3 5\nquery 2 4\nplus 4 7\nquery 3 7\nquery 1 7", "64 \n1766 \n104 \n7479 \n7687"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "线段树", "各省省选", "山东", "矩阵乘法"], "title": "[SDOI2015] 音质检测", "background": "", "description": "万老板希望在新的智能音乐播放设备 $\\operatorname{IPOOD}$ 中，实现对波文件音质性能的评定。离散的波文件被考虑为长度为 $N$ 的整数序列：$A_1,A_2,\\cdots,A_N$。所谓的音质性能检测，可以评定任何的一个区间范围 $[L,R]$ ，音质性能取决于下述评分：\n\n$$\\sum_{L<i<R}F[A_{i-1}+1]F[A_{i+1}-1] \\operatorname{mod}\\;(10^9+7)$$\n\n其中 $F$ 是可归纳定义的数列，满足 $F_1=1$，$F_2=2$ 且 $F_{k+2}=F_{k+1}+aF_{k}+b$ 对于任何 $k>0$ 成立。\n\n其中 $a$ 和 $b$ 为正整系数。为了可以为用户提供更好的服务体验，并希望对给定的波文件进行修正优化。这一款设备中，还应该支持对波文件的修改。对于给定的区间范围 $[L,R]$ ，允许用户将 $A_L$ 至 $A_R$ 同时增加一，或同时减少一。", "inputFormat": "输入的第一行有两个正整数，波文件的总长度 $N$ ，和总的修改与询问次数 $Q$ 。\n\n第二行有两个整数，分别表示系数 $a$ 和 $b$ 。\n\n之后若干行，一共给出 $N$ 个正整数 $A_1$ 到 $A_N$ ，满足 $1\\leq A_i\\leq 2\\times 10^9$ 。\n\n之后 $Q$ 行，每行是下述三种形式之一：\n- $\\text{plus}\\;L\\;R:$将波文件数列中下标在区间 $[L,R]$ 内的元素每一个都加一。\n- $\\text{minus}\\;L\\;R:$将波文件数列中下标在区间 $[L,R]$ 内的元素每一个都减一。\n- $\\text{query}\\;L\\;R:$询问区间 $[L,R]$ 的音质性能评分。修改和询问中，均保证 $L\\leq R$ ，且保证 $A_i$ 严格大于总的修改次数加一(修改操作包括 $\\text{plus}$ 和 $\\text{minus}$ 两种)。", "outputFormat": "输出若干行，每一行对应一次询问，输出一个整数。\n", "hint": "$N\\leq 3\\times10^5,Q\\leq10^4,0\\leq a,b\\leq10^9$", "locale": "zh-CN", "translations": {"en": {"title": "[SDOI2015] Audio Quality Detection", "background": "", "description": "Boss Wan wants to implement an evaluation of the audio quality performance of wave files in the new smart music player $\\operatorname{IPOOD}$. A discrete wave file is considered as an integer sequence of length $N$: $A_1, A_2, \\cdots, A_N$. The audio quality evaluation can be computed for any interval $[L, R]$, and the score depends on the following expression:\n\n$$\\sum_{L<i<R}F[A_{i-1}+1]F[A_{i+1}-1] \\operatorname{mod}\\;(10^9+7)$$\n\nHere $F$ is an inductively defined sequence, satisfying $F_1=1$, $F_2=2$, and $F_{k+2}=F_{k+1}+aF_{k}+b$ for any $k>0$.\n\nHere $a$ and $b$ are non-negative integer coefficients. To provide a better user experience and to allow optimization of the given wave file, the device should also support modifications to the wave file. For a given interval $[L, R]$, the user is allowed to increase $A_L$ through $A_R$ by one simultaneously, or decrease them by one simultaneously.", "inputFormat": "The first line contains two positive integers: the total length $N$ of the wave file, and the total number $Q$ of modifications and queries.\n\nThe second line contains two integers, the coefficients $a$ and $b$.\n\nThen, over several lines, $N$ positive integers $A_1$ through $A_N$ are given, satisfying $1 \\leq A_i \\leq 2 \\times 10^9$.\n\nThen follow $Q$ lines, each in one of the following three forms:\n- $\\text{plus}\\;L\\;R:$ increase every element with index in $[L, R]$ by one.\n- $\\text{minus}\\;L\\;R:$ decrease every element with index in $[L, R]$ by one.\n- $\\text{query}\\;L\\;R:$ ask for the audio quality score of the interval $[L, R]$. In both modifications and queries, it is guaranteed that $L \\leq R$, and that $A_i$ is strictly greater than the total number of modifications plus one (modification operations include both $\\text{plus}$ and $\\text{minus}$).", "outputFormat": "Output several lines, each corresponding to one query. For each query, output one integer.", "hint": "$N\\leq 3\\times10^5,Q\\leq10^4,0\\leq a,b\\leq10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SDOI2015] 音质检测", "background": "", "description": "万老板希望在新的智能音乐播放设备 $\\operatorname{IPOOD}$ 中，实现对波文件音质性能的评定。离散的波文件被考虑为长度为 $N$ 的整数序列：$A_1,A_2,\\cdots,A_N$。所谓的音质性能检测，可以评定任何的一个区间范围 $[L,R]$ ，音质性能取决于下述评分：\n\n$$\\sum_{L<i<R}F[A_{i-1}+1]F[A_{i+1}-1] \\operatorname{mod}\\;(10^9+7)$$\n\n其中 $F$ 是可归纳定义的数列，满足 $F_1=1$，$F_2=2$ 且 $F_{k+2}=F_{k+1}+aF_{k}+b$ 对于任何 $k>0$ 成立。\n\n其中 $a$ 和 $b$ 为正整系数。为了可以为用户提供更好的服务体验，并希望对给定的波文件进行修正优化。这一款设备中，还应该支持对波文件的修改。对于给定的区间范围 $[L,R]$ ，允许用户将 $A_L$ 至 $A_R$ 同时增加一，或同时减少一。", "inputFormat": "输入的第一行有两个正整数，波文件的总长度 $N$ ，和总的修改与询问次数 $Q$ 。\n\n第二行有两个整数，分别表示系数 $a$ 和 $b$ 。\n\n之后若干行，一共给出 $N$ 个正整数 $A_1$ 到 $A_N$ ，满足 $1\\leq A_i\\leq 2\\times 10^9$ 。\n\n之后 $Q$ 行，每行是下述三种形式之一：\n- $\\text{plus}\\;L\\;R:$将波文件数列中下标在区间 $[L,R]$ 内的元素每一个都加一。\n- $\\text{minus}\\;L\\;R:$将波文件数列中下标在区间 $[L,R]$ 内的元素每一个都减一。\n- $\\text{query}\\;L\\;R:$询问区间 $[L,R]$ 的音质性能评分。修改和询问中，均保证 $L\\leq R$ ，且保证 $A_i$ 严格大于总的修改次数加一(修改操作包括 $\\text{plus}$ 和 $\\text{minus}$ 两种)。", "outputFormat": "输出若干行，每一行对应一次询问，输出一个整数。\n", "hint": "$N\\leq 3\\times10^5,Q\\leq10^4,0\\leq a,b\\leq10^9$", "locale": "zh-CN"}}}
{"pid": "P3329", "type": "P", "difficulty": 6, "samples": [["1\n5 0\n1\n0", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "网络流", "浙江", "分治", "最小割"], "title": "[ZJOI2011] 最小割", "background": null, "description": "小白在图论课上学到了一个新的概念——最小割，下课后小白在笔记本上写下了如下这段话： \n\n对于一个图，某个对图中结点的划分将图中所有结点分成两个部分，如果结点 $s$ 和 $t$ 不在同一个部分中，则称这个划分是关于 $s,t$ 的割。对于带权图来说，将所有顶点处在不同部分的边的权值相加所得到的值定义为这个割的容量，而 $s,t$ 的最小割指的是在关于 $s,t$ 的割中容量最小的割。\n\n现给定一张无向图，小白有若干个形如“图中有多少个无序点对的最小割的容量不超过 $x$ ”的疑问，小蓝虽然很想回答这些问题，但小蓝最近忙着挖木块，于是作为小蓝的好友，你又有任务了。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $T$，表示测试数据组数。\n\n对于每组测试数据，第一行两个整数 $n,m$，表示图的点数和边数。\n\n接下来 $m$ 行，每行三个整数 $u,v,c$ 表示有一条权为 $c$ 的无向边 $(u,v)$。不保证图中无重边。\n\n接下来一行一个整数 $q$ 表示询问的个数，下面 $q$ 行每行一个整数 $x$ 描述一组询问。", "outputFormat": "对于每一组测试数据输出 $q$ 行，每行一个整数表示对应询问的答案。对于满足条件的点对 $(p,q)$ 和点对 $(q,p)$ 只应该在答案中统计一次。\n\n**在两组测试数据之间需要输出一行空行。**", "hint": "对于 $100 \\%$ 的数据，$1 \\leq T \\leq 10$，$1 \\leq n \\leq 150$，$0 \\leq m \\leq 3000$，$0 \\leq x \\leq 2^{31}-1$，$0 \\leq q \\leq 30$，$1\\leq u,v\\leq n$，$0\\leq c\\leq 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2011] Minimum Cut", "background": "", "description": "Xiaobai learned a new concept—minimum cut—in a graph theory class. After class, Xiaobai wrote the following in the notebook:\n\nFor a graph, a partition of the vertices divides all vertices into two parts. If vertices $s$ and $t$ are not in the same part, then this partition is called a cut with respect to $s,t$. For a weighted graph, the sum of the weights of all edges whose endpoints lie in different parts is defined as the capacity of this cut, and the minimum cut of $s,t$ is the cut with the minimum capacity among all cuts with respect to $s,t$.\n\nGiven an undirected graph, Xiaobai has several questions of the form “how many unordered pairs of vertices have minimum-cut capacity not exceeding $x$”. Xiaolan would like to answer these questions but is currently busy mining wooden blocks, so as Xiaolan’s friend, the task falls on you.", "inputFormat": "This problem contains multiple test cases.\n\nThe first line contains an integer $T$, the number of test cases.\n\nFor each test case, the first line contains two integers $n,m$, the number of vertices and edges.\n\nThe next $m$ lines each contain three integers $u,v,c$, indicating an undirected edge $(u,v)$ with weight $c$. Multiple edges are allowed.\n\nThen a line with an integer $q$ follows, the number of queries. Each of the next $q$ lines contains an integer $x$ describing one query.", "outputFormat": "For each test case, output $q$ lines, each containing one integer: the answer to the corresponding query. For a qualifying pair $(p,q)$ and the pair $(q,p)$, count only once.\n\nOutput one empty line between two consecutive test cases.", "hint": "For $100\\%$ of the testdata, $1 \\leq T \\leq 10$, $1 \\leq n \\leq 150$, $0 \\leq m \\leq 3000$, $0 \\leq x \\leq 2^{31}-1$, $0 \\leq q \\leq 30$, $1 \\leq u,v \\leq n$, $0 \\leq c \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2011] 最小割", "background": null, "description": "小白在图论课上学到了一个新的概念——最小割，下课后小白在笔记本上写下了如下这段话： \n\n对于一个图，某个对图中结点的划分将图中所有结点分成两个部分，如果结点 $s$ 和 $t$ 不在同一个部分中，则称这个划分是关于 $s,t$ 的割。对于带权图来说，将所有顶点处在不同部分的边的权值相加所得到的值定义为这个割的容量，而 $s,t$ 的最小割指的是在关于 $s,t$ 的割中容量最小的割。\n\n现给定一张无向图，小白有若干个形如“图中有多少个无序点对的最小割的容量不超过 $x$ ”的疑问，小蓝虽然很想回答这些问题，但小蓝最近忙着挖木块，于是作为小蓝的好友，你又有任务了。", "inputFormat": "**本题有多组测试数据。**\n\n第一行一个整数 $T$，表示测试数据组数。\n\n对于每组测试数据，第一行两个整数 $n,m$，表示图的点数和边数。\n\n接下来 $m$ 行，每行三个整数 $u,v,c$ 表示有一条权为 $c$ 的无向边 $(u,v)$。不保证图中无重边。\n\n接下来一行一个整数 $q$ 表示询问的个数，下面 $q$ 行每行一个整数 $x$ 描述一组询问。", "outputFormat": "对于每一组测试数据输出 $q$ 行，每行一个整数表示对应询问的答案。对于满足条件的点对 $(p,q)$ 和点对 $(q,p)$ 只应该在答案中统计一次。\n\n**在两组测试数据之间需要输出一行空行。**", "hint": "对于 $100 \\%$ 的数据，$1 \\leq T \\leq 10$，$1 \\leq n \\leq 150$，$0 \\leq m \\leq 3000$，$0 \\leq x \\leq 2^{31}-1$，$0 \\leq q \\leq 30$，$1\\leq u,v\\leq n$，$0\\leq c\\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P3330", "type": "P", "difficulty": 6, "samples": [["3\n1 1\n2 1\n2 2", "1 1\n0 1\n3 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "高精度", "2011", "各省省选", "浙江", "组合数学"], "title": "[ZJOI2011] 看电影", "background": "", "description": "到了难得的假期，小白班上组织大家去看电影。但由于假期里看电影的人太多，很难做到让全班看上同一场电影。最后大家在一个偏僻的小胡同里找到了一家电影院，但这家电影院分配座位的方式很特殊，具体方式如下：\n\n电影院的座位共有 $K$ 个，并被标号为 $1 \\sim K$。每个人买完票后会被随机指定一个座位，具体来说是从 $1 \\sim K$ 中等概率随机选取一个正整数，设其为 $L$。\n\n如果编号 $L$ 的座位是空位，则这个座位就分配给此人，否则将 $L$ 加一，继续前面的步骤；如果不存在编号 $L$ 的座位，则该人只能站着看电影，即所谓的站票。\n\n小白班上共有 $N$ 人（包括小白自己），作为数学爱好者，小白想知道全班都能够有座位的概率是多少。\n", "inputFormat": "本题有多组数据。第一行一个整数 $T$ 表示数据组数，接下来 $T$ 行每行两个整数 $N,K$ 表示人数和电影院座位数。", "outputFormat": "对于每一组数据数据输出一行两个整数 $A,B$，表示答案为 $\\frac{A}{B}$。你需要保证 $\\gcd(A,B) = 1$。", "hint": "对于 $100 \\%$ 的数据，$1 \\leq T \\leq 50$，$1 \\leq N,K \\leq 200$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2011] Watching a Movie", "background": "", "description": "During a rare holiday, Xiaobai’s (Xiaobai) class organizes a movie trip. However, because many people watch movies during holidays, it is hard to seat everyone in the same showing. Finally, they find a cinema in a remote alley, but its seating assignment is special, as follows:\n\nThe cinema has $K$ seats, labeled $1 \\sim K$. After buying a ticket, each person is randomly assigned a seat. Specifically, an integer is chosen uniformly at random from $1 \\sim K$, and let it be $L$.\n\nIf seat $L$ is empty, this seat is assigned to the person. Otherwise, increase $L$ by one and repeat the previous step; if there is no seat numbered $L$, then the person has to stand to watch the movie, i.e., a standing ticket.\n\nThere are $N$ people in Xiaobai’s class (including Xiaobai). As a math enthusiast, Xiaobai wants to know the probability that the whole class can get seats.", "inputFormat": "Multiple test cases. The first line contains an integer $T$ denoting the number of test cases. Then each of the next $T$ lines contains two integers $N,K$ denoting the number of people and the number of seats in the cinema.", "outputFormat": "For each test case, output two integers $A,B$ on one line, indicating that the answer is $\\frac{A}{B}$. You need to ensure $\\gcd(A,B) = 1$.", "hint": "For $100 \\%$ of the testdata, $1 \\leq T \\leq 50$, $1 \\leq N,K \\leq 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2011] 看电影", "background": "", "description": "到了难得的假期，小白班上组织大家去看电影。但由于假期里看电影的人太多，很难做到让全班看上同一场电影。最后大家在一个偏僻的小胡同里找到了一家电影院，但这家电影院分配座位的方式很特殊，具体方式如下：\n\n电影院的座位共有 $K$ 个，并被标号为 $1 \\sim K$。每个人买完票后会被随机指定一个座位，具体来说是从 $1 \\sim K$ 中等概率随机选取一个正整数，设其为 $L$。\n\n如果编号 $L$ 的座位是空位，则这个座位就分配给此人，否则将 $L$ 加一，继续前面的步骤；如果不存在编号 $L$ 的座位，则该人只能站着看电影，即所谓的站票。\n\n小白班上共有 $N$ 人（包括小白自己），作为数学爱好者，小白想知道全班都能够有座位的概率是多少。\n", "inputFormat": "本题有多组数据。第一行一个整数 $T$ 表示数据组数，接下来 $T$ 行每行两个整数 $N,K$ 表示人数和电影院座位数。", "outputFormat": "对于每一组数据数据输出一行两个整数 $A,B$，表示答案为 $\\frac{A}{B}$。你需要保证 $\\gcd(A,B) = 1$。", "hint": "对于 $100 \\%$ 的数据，$1 \\leq T \\leq 50$，$1 \\leq N,K \\leq 200$。", "locale": "zh-CN"}}}
{"pid": "P3331", "type": "P", "difficulty": 5, "samples": [["3 2 5\nPNNNN\nPNNNN\nNPPNP\nPNNNP\nNNNNP\nPPNNP", "24"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "各省省选", "浙江"], "title": "[ZJOI2011] 礼物", "background": "", "description": "小白的生日就要到了，小蓝决定送一件自己亲手做的手工艺品使自己的礼物与众不同。具体来说，小蓝已经通过某种方式制作出了一个 $p\\times q\\times r$ 的木块（由 $pqr$ 个单位小木块组成）。\n\n但由于小蓝手艺不精，现在这个木块中的有些单位小木块是有问题的（有裂缝、里面是空心等等），这样的礼物小蓝是不可能直接送出去的。于是小蓝决定在这个木块中再挖出一个 $a\\times a\\times b$ 的子木块（即要求挖出的长方体木块存在两条长度相等的相邻边），当然这个子木块中是不能包含有问题的单位小木块的。\n\n为了使这个木块上能包含更多的图案，小蓝希望从所有可行的方案中挑取 $4ab$ 的值最大的方案。但小蓝光检测木块中哪些地方有问题就已经耗尽了体力，作为小蓝的好友，你能帮帮小蓝吗？\n", "inputFormat": "每个输入文件中仅包含一个测试数据。\n\n第一行包含三个由空格隔开的正整数，$p,q,r$。 \n\n接下来有 $pq$ 行，每行包含 $r$ 个字符，每个字符只可能是 `P`（Poor）或者 `N`（Nice），分别表示该单位小木块有问题或者没问题。具体的说，第 $1+(yp+x-p)$ 行的第 $z$ 个字符描述的是坐标为 $(x,y,z)$ 的小木块情况。\n", "outputFormat": "输出文件仅包含一个整数，表示最佳方案的 $4ab$ 的值。\n", "hint": "对于 $100\\%$ 的数据，$0<p,q,r\\le 150$，输入中至少包含一个 `N`。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2011] Gift", "background": "", "description": "Xiaolan wants to give a unique handmade present for Xiaobai’s upcoming birthday. Specifically, Xiaolan has somehow made a $p\\times q\\times r$ wooden block (composed of $p q r$ unit cubes).\n\nHowever, due to lack of skill, some unit cubes inside this block are defective (cracks, hollow inside, etc.), so Xiaolan cannot give it as-is. Xiaolan decides to carve out an $a\\times a\\times b$ sub-block from it (i.e., the carved rectangular block must have two adjacent edges of equal length). Of course, this sub-block must not contain any defective unit cubes.\n\nTo allow more patterns on the block, Xiaolan wants to choose, among all feasible plans, the one that maximizes the value of $4ab$. But Xiaolan is exhausted after checking which unit cubes are defective. As Xiaolan’s friend, can you help?", "inputFormat": "Each input file contains exactly one testdata.\n\nThe first line contains three positive integers $p, q, r$ separated by spaces.\n\nThen there are $p q$ lines, each containing $r$ characters. Each character is either `P` (Poor) or `N` (Nice), indicating whether the corresponding unit cube is defective or not. Specifically, in line number $1 + (y p + x - p)$, the $z$-th character describes the cube at coordinate $(x, y, z)$.", "outputFormat": "The output contains exactly one integer: the maximum possible value of $4ab$.", "hint": "For $100\\%$ of the testdata, $0 < p, q, r \\le 150$, and the input contains at least one `N`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2011] 礼物", "background": "", "description": "小白的生日就要到了，小蓝决定送一件自己亲手做的手工艺品使自己的礼物与众不同。具体来说，小蓝已经通过某种方式制作出了一个 $p\\times q\\times r$ 的木块（由 $pqr$ 个单位小木块组成）。\n\n但由于小蓝手艺不精，现在这个木块中的有些单位小木块是有问题的（有裂缝、里面是空心等等），这样的礼物小蓝是不可能直接送出去的。于是小蓝决定在这个木块中再挖出一个 $a\\times a\\times b$ 的子木块（即要求挖出的长方体木块存在两条长度相等的相邻边），当然这个子木块中是不能包含有问题的单位小木块的。\n\n为了使这个木块上能包含更多的图案，小蓝希望从所有可行的方案中挑取 $4ab$ 的值最大的方案。但小蓝光检测木块中哪些地方有问题就已经耗尽了体力，作为小蓝的好友，你能帮帮小蓝吗？\n", "inputFormat": "每个输入文件中仅包含一个测试数据。\n\n第一行包含三个由空格隔开的正整数，$p,q,r$。 \n\n接下来有 $pq$ 行，每行包含 $r$ 个字符，每个字符只可能是 `P`（Poor）或者 `N`（Nice），分别表示该单位小木块有问题或者没问题。具体的说，第 $1+(yp+x-p)$ 行的第 $z$ 个字符描述的是坐标为 $(x,y,z)$ 的小木块情况。\n", "outputFormat": "输出文件仅包含一个整数，表示最佳方案的 $4ab$ 的值。\n", "hint": "对于 $100\\%$ 的数据，$0<p,q,r\\le 150$，输入中至少包含一个 `N`。", "locale": "zh-CN"}}}
{"pid": "P3332", "type": "P", "difficulty": 6, "samples": [["2 5\n1 1 2 1\n1 1 2 2\n2 1 1 2\n2 1 1 1\n2 1 2 3", "1\n2\n1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2013", "线段树", "各省省选", "浙江", "树套树", "整体二分"], "title": "[ZJOI2013] K大数查询", "background": "", "description": "你需要维护 $n$ 个可重整数集，集合的编号从 $1$ 到 $n$。  \n这些集合初始都是空集，有 $m$ 个操作：  \n\n- `1 l r c`：表示将 $c$ 加入到编号在 $[l,r]$ 内的集合中  \n- `2 l r c`：表示查询编号在 $[l,r]$ 内的集合的并集中，第 $c$ 大的数是多少。  \n\n注意可重集的并是不去除重复元素的，如 $\\{1,1,4\\}\\cup\\{5,1,4\\}=\\{1,1,4,5,1,4\\}$。\n", "inputFormat": "第一行两个正整数 $n,m$，表示集合个数和操作个数。  \n接下来 $m$ 行，每行四个整数表示一次操作。\n", "outputFormat": "对于每个 $2$ 操作，输出一行一个整数表示答案。\n", "hint": "【样例说明】   \n第 $1$ 次操作在 $1,2$ 号集合中分别加入了一个  $1$。    \n第 $2$ 次操作在 $1,2$ 号集合中分别加入了一个 $2$。   \n第 $3$ 次操作查询 $1$ 号集合中第 $2$ 大的数，答案为 $1$。  \n第 $4$ 次操作查询 $1$ 号集合中第 $1$ 大的数，答案为 $2$。    \n第 $5$ 次操作查询 $1,2$ 号集合的并集 $\\{1,2,1,2\\}$ 中第 $3$ 大的数，答案为 $1$。\n\n【数据范围】  \n$1 \\le n,m \\le 5\\times 10^4$   \n$1\\le l,r \\le n$   \n$1$ 操作中 $|c|\\le n$   \n$2$ 操作中 $1\\le c < 2^{63}$，第 $c$ 大的数存在\n\n---\n\n$\\text{upd 2023.8.23}$：新增加一组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2013] K-th Largest Number Query", "background": "", "description": "You need to maintain $n$ multisets of integers, numbered from $1$ to $n$.  \nAll sets are initially empty. There are $m$ operations:\n\n- `1 l r c`: Add $c$ to every set with index in $[l,r]$.  \n- `2 l r c`: Query the $c$-th largest number in the union of all sets with indices in $[l,r]$.\n\nNote that the union of multisets does not remove duplicates, e.g., $\\{1,1,4\\}\\cup\\{5,1,4\\}=\\{1,1,4,5,1,4\\}$.", "inputFormat": "The first line contains two positive integers $n, m$, the number of sets and the number of operations.  \nEach of the next $m$ lines contains four integers describing one operation.", "outputFormat": "For each operation of type `2`, output one line with a single integer, the answer.", "hint": "[Sample Explanation]  \nThe 1st operation adds one $1$ to sets $1$ and $2$.  \nThe 2nd operation adds one $2$ to sets $1$ and $2$.  \nThe 3rd operation queries the 2nd largest number in set $1$, which is $1$.  \nThe 4th operation queries the 1st largest number in set $1$, which is $2$.  \nThe 5th operation queries the 3rd largest number in the union $\\{1,2,1,2\\}$ of sets $1$ and $2$, which is $1$.\n\nConstraints  \n$1 \\le n,m \\le 5\\times 10^4$  \n$1 \\le l,r \\le n$  \nIn operation `1`, $|c| \\le n$  \nIn operation `2`, $1 \\le c < 2^{63}$, and the $c$-th largest number exists.\n\n---\n\n$\\text{upd 2023.8.23}$：Added a new set of hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2013] K大数查询", "background": "", "description": "你需要维护 $n$ 个可重整数集，集合的编号从 $1$ 到 $n$。  \n这些集合初始都是空集，有 $m$ 个操作：  \n\n- `1 l r c`：表示将 $c$ 加入到编号在 $[l,r]$ 内的集合中  \n- `2 l r c`：表示查询编号在 $[l,r]$ 内的集合的并集中，第 $c$ 大的数是多少。  \n\n注意可重集的并是不去除重复元素的，如 $\\{1,1,4\\}\\cup\\{5,1,4\\}=\\{1,1,4,5,1,4\\}$。\n", "inputFormat": "第一行两个正整数 $n,m$，表示集合个数和操作个数。  \n接下来 $m$ 行，每行四个整数表示一次操作。\n", "outputFormat": "对于每个 $2$ 操作，输出一行一个整数表示答案。\n", "hint": "【样例说明】   \n第 $1$ 次操作在 $1,2$ 号集合中分别加入了一个  $1$。    \n第 $2$ 次操作在 $1,2$ 号集合中分别加入了一个 $2$。   \n第 $3$ 次操作查询 $1$ 号集合中第 $2$ 大的数，答案为 $1$。  \n第 $4$ 次操作查询 $1$ 号集合中第 $1$ 大的数，答案为 $2$。    \n第 $5$ 次操作查询 $1,2$ 号集合的并集 $\\{1,2,1,2\\}$ 中第 $3$ 大的数，答案为 $1$。\n\n【数据范围】  \n$1 \\le n,m \\le 5\\times 10^4$   \n$1\\le l,r \\le n$   \n$1$ 操作中 $|c|\\le n$   \n$2$ 操作中 $1\\le c < 2^{63}$，第 $c$ 大的数存在\n\n---\n\n$\\text{upd 2023.8.23}$：新增加一组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P3333", "type": "P", "difficulty": 6, "samples": [["xiang yao yi zhi ai zhe mou wu de hua yi yao guai zhi si lai shuo tai chang le xiang yao shi xian yi qie meng xiang de hua yi ren lei zhi sheng lai shuo tai duan le\nyao\ntai chang le yao\ntai duan le", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "贪心", "2013", "各省省选", "浙江", "哈希 hashing"], "title": "[ZJOI2013] 丽洁体", "background": null, "description": "平时的练习和考试中，我们经常会碰上这样的题：命题人给出一个例句，要我们类比着写句子。这种往往被称为仿写的题，不单单出现在小学生的考试中，也有时会出现在中考中。许多同学都喜欢做这种题，因为较其它题显得有趣。仿写的句子往往具有 `A__B__C` 的形式，其中 `A`，`B`，`C` 是给定的由一个或多个单词组成的短句，空的部分需要学生填写。当然，考试的时候空在那里也是可以的。例如，“其实天不暗阴云终要散，其实，其实，其实路不远一切会如愿，艰难困苦的日子里我为你祈祷，请你保重每一天”。再比如，“见了大海的汹涌，没见过大山的巍峨，真是遗憾；见了大山的巍峨，没见过，还是遗憾。出发吧，永远出发。 ，人有不老的心情。”\n\n由于现在是网络时代，我们不再只能仿写命题人命的题，我们可以仿写网上各种句子和段落。2011 年 3 月 26 日，某人在博客上发布了的消息就惹来了很多人的仿写。\n\n很难过吧。。。考得完爆了。。。\n\n。。。。。。其实也没什么可以说的。。。都是蒟蒻的借口罢了。。。\n\n。。。自己果然还只是半吊子水平呢。。。。\n\n。。。祝大家都能进省队。。。其实只要不要有遗憾就好了呢。。。\n\n虽然我很遗憾或许不能走下去了。。。。。\n\n886\n\n在网络上广泛流传的仿写，因为在某些地方有独到之处，大都被命名为“某某体”。打开人人，刷新微博，你也能发现这样和那样的体，比如，对不起体，\\*\\* 说明他爱你体等等。金先生注意到了这一现象，他敏锐地认为这是一个很有价值的研究课题，于是就其展开研究，打算发一篇 paper。由于在网上发消息，人们有了更大的灵活度，人们有时因为表达的需要，还往原本固定的 `A, B, C` 中添加一些修饰的词语。这就给辨别一个句子或段落是否是另一个句子或段落的仿写增加了困难。\n\n金先生现在研究一种形如“`A*B*C`”的体作品，其中 `A, B, C` 分别是某个由若干单词组成的短句，`*` 代表 $0$ 个或多个单词。他在网上找了大量的体作品，不过很多体作品不太合乎原作者的格式，也就是相当于在正规的体作品中插入了 0 个或多个单词。\n\n由于数据量太大，金先生无法一个一个看过去，于是想请你帮忙，去掉尽量少的单词，使它成为指定的体。", "inputFormat": "包含 $4$ 行。\n\n第一行是某个也许不规范的体作品 $T$，\n\n接下来三行分别代表 `A`, `B`, `C`。", "outputFormat": "仅一行，包含一个数，即最少的去除单词数。", "hint": "【样例说明】\n\n在上述样例中，不规范的体作品为：“想要一直爱着某物的话，以妖怪之死来说太长了；想要实现一切梦想的话，以人类之生来说太短了”。\n\n规范的体形如：“要 `*` 太长了要 `*` 太短了”。\n\n修改后的规范的体为：“要一直爱着某物的话，以妖怪之死来说太长了；要实现一切梦想的话，以人类之生来说太短了”。\n\n【数据规模与约定】\n\n对于 $20\\%$ 的数据，$1\\le|T|, |A|, |B|, |C|\\le10$。\n\n对于 $40\\%$ 的数据，$1\\le|T|, |A|, |B|, |C|\\le100$。\n\n对于 $70\\%$ 的数据，$1\\le|T|, |A|, |B|, |C|\\le1000$。\n\n对于 $100\\%$ 的数据，$1\\le|T|, |A|, |B|, |C|\\le50000$；所有单词长度不超过 $5$，出现次数不超过 $500$；数据保证答案总存在。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2013] Lijie Style", "background": "", "description": "In practice and exams, we often meet questions like this: the setter gives an example sentence, and we are asked to write a similar sentence by analogy. This kind of question, often called imitation writing, appears not only in elementary school exams but sometimes also in middle school entrance exams. Many students like such questions because they feel more interesting than others. The imitated sentence often has the form “A__B__C”, where A, B, and C are given short phrases made of one or more words, and the blank parts are to be filled by the student. Of course, in exams it is also acceptable to leave the blanks empty. For example: “In fact, the sky is not dark, the dark clouds will eventually scatter; in fact , in fact , in fact the road is not long, everything will go as wished. In the days of hardship and difficulty, I pray for you. Please take care every day.” Another example: “Having seen the surging sea but not the towering mountain is a pity; having seen the towering mountain but not the , it is still a pity. Set out, always set out. , people keep an ageless mood.”\n\nBecause we are in the internet era, we can imitate not only the setter’s prompts but also all kinds of sentences and paragraphs online. On March 26, 2011, someone posted a message on a blog that drew lots of imitations.\n\nSo sad... I totally bombed the test...\n\n...... Actually, there isn't much to say... It's all just excuses from a newbie (ju ruo, 蒟蒻)...\n\n... As expected, I'm still only half-baked...\n\n... I wish everyone can make the provincial team (sheng dui)... Actually, as long as there is no regret, it's fine...\n\nAlthough I regret that maybe I can't keep going...\n\n886 (bye-bye-bye)\n\nImitations that spread widely online are often named “X-style” (“XX ti”) because they have something unique in certain places. Open Renren, refresh Weibo, and you can find this and that style, for example, “Sorry style,” “It shows he loves you style,” and so on. Mr. Jin noticed this phenomenon and thought it would be a valuable research topic, so he began to study it and planned to publish a paper. Because posting messages online gives people more flexibility, sometimes for expression needs people also add some modifiers into the originally fixed $A$, $B$, $C$. This makes it harder to decide whether a sentence or paragraph is an imitation of another sentence or paragraph.\n\nMr. Jin now studies works of the form “$A$*$B$*$C$”, where $A$, $B$, $C$ are short phrases consisting of several words, and “*” stands for 0 or more words. He collected many such works online, but many do not strictly follow the original author’s format, which is equivalent to inserting 0 or more words into a standard work.\n\nBecause the data volume is too large, Mr. Jin cannot check them one by one. He asks you to remove as few words as possible to make it match the specified style.", "inputFormat": "Four lines.\n\nThe first line is a possibly non-standard work $T$.\n\nThe next three lines are $A$, $B$, and $C$, respectively.", "outputFormat": "A single line containing one integer: the minimum number of words to remove.", "hint": "Sample Explanation:\n\nIn the sample above, the non-standard work is: “If you want to keep loving something forever, then, speaking of a demon’s death, it is too long; if you want to realize all dreams, then, speaking of a human’s life, it is too short.”\n\nA standard work has the form: “yao*too long yao*too short” (“要*太长了要*太短了”).\n\nAfter modification, a valid standard work is: “If you want to keep loving something forever, then, speaking of a demon’s death, it is too long; if you want to realize all dreams, then, speaking of a human’s life, it is too short.”\n\nConstraints:\n\n- For 20% of the testdata, $1 \\le |T|, |A|, |B|, |C| \\le 10$.\n- For 40% of the testdata, $1 \\le |T|, |A|, |B|, |C| \\le 100$.\n- For 70% of the testdata, $1 \\le |T|, |A|, |B|, |C| \\le 1000$.\n- For 100% of the testdata, $1 \\le |T|, |A|, |B|, |C| \\le 50000$; all words have length at most $5$, and each distinct word appears at most $500$ times; the testdata guarantees that an answer always exists.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2013] 丽洁体", "background": null, "description": "平时的练习和考试中，我们经常会碰上这样的题：命题人给出一个例句，要我们类比着写句子。这种往往被称为仿写的题，不单单出现在小学生的考试中，也有时会出现在中考中。许多同学都喜欢做这种题，因为较其它题显得有趣。仿写的句子往往具有 `A__B__C` 的形式，其中 `A`，`B`，`C` 是给定的由一个或多个单词组成的短句，空的部分需要学生填写。当然，考试的时候空在那里也是可以的。例如，“其实天不暗阴云终要散，其实，其实，其实路不远一切会如愿，艰难困苦的日子里我为你祈祷，请你保重每一天”。再比如，“见了大海的汹涌，没见过大山的巍峨，真是遗憾；见了大山的巍峨，没见过，还是遗憾。出发吧，永远出发。 ，人有不老的心情。”\n\n由于现在是网络时代，我们不再只能仿写命题人命的题，我们可以仿写网上各种句子和段落。2011 年 3 月 26 日，某人在博客上发布了的消息就惹来了很多人的仿写。\n\n很难过吧。。。考得完爆了。。。\n\n。。。。。。其实也没什么可以说的。。。都是蒟蒻的借口罢了。。。\n\n。。。自己果然还只是半吊子水平呢。。。。\n\n。。。祝大家都能进省队。。。其实只要不要有遗憾就好了呢。。。\n\n虽然我很遗憾或许不能走下去了。。。。。\n\n886\n\n在网络上广泛流传的仿写，因为在某些地方有独到之处，大都被命名为“某某体”。打开人人，刷新微博，你也能发现这样和那样的体，比如，对不起体，\\*\\* 说明他爱你体等等。金先生注意到了这一现象，他敏锐地认为这是一个很有价值的研究课题，于是就其展开研究，打算发一篇 paper。由于在网上发消息，人们有了更大的灵活度，人们有时因为表达的需要，还往原本固定的 `A, B, C` 中添加一些修饰的词语。这就给辨别一个句子或段落是否是另一个句子或段落的仿写增加了困难。\n\n金先生现在研究一种形如“`A*B*C`”的体作品，其中 `A, B, C` 分别是某个由若干单词组成的短句，`*` 代表 $0$ 个或多个单词。他在网上找了大量的体作品，不过很多体作品不太合乎原作者的格式，也就是相当于在正规的体作品中插入了 0 个或多个单词。\n\n由于数据量太大，金先生无法一个一个看过去，于是想请你帮忙，去掉尽量少的单词，使它成为指定的体。", "inputFormat": "包含 $4$ 行。\n\n第一行是某个也许不规范的体作品 $T$，\n\n接下来三行分别代表 `A`, `B`, `C`。", "outputFormat": "仅一行，包含一个数，即最少的去除单词数。", "hint": "【样例说明】\n\n在上述样例中，不规范的体作品为：“想要一直爱着某物的话，以妖怪之死来说太长了；想要实现一切梦想的话，以人类之生来说太短了”。\n\n规范的体形如：“要 `*` 太长了要 `*` 太短了”。\n\n修改后的规范的体为：“要一直爱着某物的话，以妖怪之死来说太长了；要实现一切梦想的话，以人类之生来说太短了”。\n\n【数据规模与约定】\n\n对于 $20\\%$ 的数据，$1\\le|T|, |A|, |B|, |C|\\le10$。\n\n对于 $40\\%$ 的数据，$1\\le|T|, |A|, |B|, |C|\\le100$。\n\n对于 $70\\%$ 的数据，$1\\le|T|, |A|, |B|, |C|\\le1000$。\n\n对于 $100\\%$ 的数据，$1\\le|T|, |A|, |B|, |C|\\le50000$；所有单词长度不超过 $5$，出现次数不超过 $500$；数据保证答案总存在。", "locale": "zh-CN"}}}
{"pid": "P3334", "type": "P", "difficulty": 7, "samples": [["1 2\nHT", "4/1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "各省省选", "浙江"], "title": "[ZJOI2013] 抛硬币", "background": null, "description": "有一枚硬币，抛出正面 `H` 的概率为 $\\frac{a}{b}$，抛出反面 `T` 的概率为 $1-\\frac{a}{b}$。现在TT小朋友开始玩丢硬币的游戏，并且把每次抛出的结果记录下来，正面记为 `H`，反面记为 `T`，于是她得到了一个抛硬币序列 `HTHHT…`。她突然想到一个问题：在抛出正面和反面概率都是 $\\frac{1}{2}$ 的情况下，要使得抛出的序列出现目标序列 `HT`，期望要抛多少次。然而经过 $1$ 秒的思考以后她发现，若第一次抛出的是 `T`，那么还需要期望抛出 `HT` 的次数，如果第一次抛出的是 `H`，则期望只需要抛出 `T` 的次数，而期望抛出 `T` 的次数显然是 $2$。她设抛出 `HT` 的期望次数是 $x$，则得到了方程：\n$$\nx=1+\\left(\\frac{1}{2}\\times x+\\frac{1}{2}\\times 2\\right)\n$$\n解得 $x=4$，所以抛出 `HT` 的期望次数是 $4$ 次。\n\n她在解决了这个弱化很多的问题以后，开始思考对于一般情况下，抛出正反面的概率不一定相同，且抛出的目标序列不一定为 `HT` 时需要的期望步数。然而经过很长一段时间的苦思冥想仍然无果，于是她开始求助于你。", "inputFormat": "第一行两个数 $a,b$。意义如题目描述。\n\n接下来一行一个只包含 `H` 和 `T` 的字符串 $S$。表示要抛出的目标序列。", "outputFormat": "输出仅一行 $\\frac{p}{q}$，其中 $p$ 和 $q$ 均为正整数且互质，表示抛出目标序列 $S$ 所需要的期望步数。\n\n注意，若 $q$ 为 $1$ 时，不省略 `/1`。", "hint": "对于 $50\\%$ 的数据，$a=1,b=2,|S|\\le20$。\n\n对于 $100\\%$ 的数据，$a<b,b\\le100,|S|\\le1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2013] Coin Tossing", "background": "", "description": "There is a coin, with the probability of getting heads `H` being $\\frac{a}{b}$, and the probability of getting tails `T` being $1-\\frac{a}{b}$. Now TT starts playing a coin-tossing game and records each result: heads as `H` and tails as `T`. Thus she obtains a coin-toss sequence like `HTHHT…`. She suddenly wonders: when both probabilities of heads and tails are $\\frac{1}{2}$, what is the expected number of tosses needed for the sequence to contain the target sequence `HT`. However, after thinking for $1$ second, she realizes that if the first toss is `T`, then she still expects to need the number of tosses to obtain `HT`; if the first toss is `H`, then she only needs the expected number of tosses to obtain `T`, which is clearly $2$. Let $x$ be the expected number of tosses to obtain `HT`, then we have:\n$$\nx=1+\\left(\\frac{1}{2}\\times x+\\frac{1}{2}\\times 2\\right)\n$$\nSolving gives $x=4$, so the expected number of tosses to obtain `HT` is $4$.\n\nAfter solving this much simpler problem, she begins to think about the general case, where the probabilities of heads and tails are not necessarily equal, and the target sequence is not necessarily `HT`. However, after a long time of hard thinking, she still gets nowhere, so she turns to you for help.", "inputFormat": "The first line contains two numbers $a, b$, as defined in the description.\n\nThe next line contains a string $S$ consisting only of `H` and `T`, representing the target sequence to obtain.", "outputFormat": "Output a single line $\\frac{p}{q}$, where $p$ and $q$ are positive integers and are coprime, representing the expected number of tosses needed to obtain the target sequence $S$.\n\nNote that if $q$ is $1$, do not omit `/1`.", "hint": "For $50\\%$ of the testdata, $a=1, b=2, |S|\\le 20$.\n\nFor $100\\%$ of the testdata, $a<b, b\\le 100, |S|\\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2013] 抛硬币", "background": null, "description": "有一枚硬币，抛出正面 `H` 的概率为 $\\frac{a}{b}$，抛出反面 `T` 的概率为 $1-\\frac{a}{b}$。现在TT小朋友开始玩丢硬币的游戏，并且把每次抛出的结果记录下来，正面记为 `H`，反面记为 `T`，于是她得到了一个抛硬币序列 `HTHHT…`。她突然想到一个问题：在抛出正面和反面概率都是 $\\frac{1}{2}$ 的情况下，要使得抛出的序列出现目标序列 `HT`，期望要抛多少次。然而经过 $1$ 秒的思考以后她发现，若第一次抛出的是 `T`，那么还需要期望抛出 `HT` 的次数，如果第一次抛出的是 `H`，则期望只需要抛出 `T` 的次数，而期望抛出 `T` 的次数显然是 $2$。她设抛出 `HT` 的期望次数是 $x$，则得到了方程：\n$$\nx=1+\\left(\\frac{1}{2}\\times x+\\frac{1}{2}\\times 2\\right)\n$$\n解得 $x=4$，所以抛出 `HT` 的期望次数是 $4$ 次。\n\n她在解决了这个弱化很多的问题以后，开始思考对于一般情况下，抛出正反面的概率不一定相同，且抛出的目标序列不一定为 `HT` 时需要的期望步数。然而经过很长一段时间的苦思冥想仍然无果，于是她开始求助于你。", "inputFormat": "第一行两个数 $a,b$。意义如题目描述。\n\n接下来一行一个只包含 `H` 和 `T` 的字符串 $S$。表示要抛出的目标序列。", "outputFormat": "输出仅一行 $\\frac{p}{q}$，其中 $p$ 和 $q$ 均为正整数且互质，表示抛出目标序列 $S$ 所需要的期望步数。\n\n注意，若 $q$ 为 $1$ 时，不省略 `/1`。", "hint": "对于 $50\\%$ 的数据，$a=1,b=2,|S|\\le20$。\n\n对于 $100\\%$ 的数据，$a<b,b\\le100,|S|\\le1000$。", "locale": "zh-CN"}}}
{"pid": "P3335", "type": "P", "difficulty": 6, "samples": [["2 5 2\n-1 -1 -1 -1 -1\n-1 -1 -1 -1 -1", "-8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2013", "各省省选", "浙江"], "title": "[ZJOI2013] 蚂蚁寻路", "background": "", "description": "在一个 $n \\times m$ 的棋盘上，每个格子有一个权值，初始时，在某个格子的顶点处一只面朝北的蚂蚁，我们只知道它的行走路线是如何转弯，却不知道每次转弯前走了多长。\n\n蚂蚁转弯是有一定特点的，即它的转弯序列一定是如下的形式：右转，右转，左转，左转，右转，右转…左转，左转，右转，右转，右转。即两次右转和两次左转交替出现的形式，最后两次右转（最后两次一定是右转）后再多加一次右转。我们还知道，蚂蚁不会在同一个位置连续旋转两次，并且蚂蚁行走的路径除了起点以外，不会到达同一个点多次，它最后一定是回到起点然后结束自己的行程，而且蚂蚁只会在棋盘格子的顶点处转弯。\n\n ![](https://cdn.luogu.com.cn/upload/pic/6217.png) \n\n现在已知棋盘大小、每个格子的权值以及左转次数除以 $2$ 的值，问蚂蚁走出的路径围出的封闭图形，权值之和最大可能是多少。\n", "inputFormat": "第一行三个数 $n,m,k$。意义如题目描述。\n\n接下来一个 $n$ 行 $m$ 列的整数矩阵，表示棋盘。\n", "outputFormat": "一个数，表示蚂蚁所走路径围出的图形可能的最大权值和。\n", "hint": "### 样例说明\n\n除了第一行的第二个和第一行的第四个都要围起来才至少合法。\n\n### 数据规模与约定\n\n- $10\\%$ 的数据所有格子中权值均非负。\n- 另 $20\\%$ 的数据 $n=2$。\n- 另 $30\\%$ 的数据 $k=0$。\n- $100\\%$ 的数据 $1 \\le n\\le 100$，$1 \\le m \\le 100$，$0 \\le k \\le 10$，保证存在合法路径，数据有梯度，格子中每个元素的值绝对值不超过 $10000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2013] Ant Pathfinding", "background": "", "description": "On an $n \\times m$ board, each cell has a weight. Initially, there is an ant facing north at the vertex of some cell. We only know how its route turns, but we do not know how far it walks between consecutive turns.\n\nThe ant’s turning sequence has a specific pattern: right, right, left, left, right, right, …, left, left, right, right, right. That is, pairs of right turns and pairs of left turns appear alternately; after the final pair of right turns (the last two are necessarily right turns), one additional right turn is appended. We also know that the ant will not rotate twice consecutively at the same position, the ant’s path will not pass through the same point more than once except for the starting point, it will finally return to the starting point and end its journey, and the ant only turns at grid vertices.\n\n![](https://cdn.luogu.com.cn/upload/pic/6217.png)\n\nGiven the board size, each cell’s weight, and the value of the number of left turns divided by $2$, find the maximum possible sum of weights of the closed shape enclosed by the ant’s path.", "inputFormat": "The first line contains three integers $n, m, k$, as described above.\n\nThen follow an $n$-row, $m$-column integer matrix representing the board.", "outputFormat": "Output a single integer: the maximum possible total weight of the region enclosed by the ant’s path.", "hint": "Sample Explanation:\nAt minimum, both the second cell and the fourth cell in the first row must be enclosed for the path to be valid.\n\nConstraints:\n- $10\\%$ of the testdata have all cell weights nonnegative.\n- Another $20\\%$ of the testdata have $n=2$.\n- Another $30\\%$ of the testdata have $k=0$.\n- For $100\\%$ of the testdata, $1 \\le n\\le 100$, $1 \\le m \\le 100$, $0 \\le k \\le 10$, a valid path is guaranteed to exist, the testdata have gradient, and the absolute value of each cell’s weight does not exceed $10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2013] 蚂蚁寻路", "background": "", "description": "在一个 $n \\times m$ 的棋盘上，每个格子有一个权值，初始时，在某个格子的顶点处一只面朝北的蚂蚁，我们只知道它的行走路线是如何转弯，却不知道每次转弯前走了多长。\n\n蚂蚁转弯是有一定特点的，即它的转弯序列一定是如下的形式：右转，右转，左转，左转，右转，右转…左转，左转，右转，右转，右转。即两次右转和两次左转交替出现的形式，最后两次右转（最后两次一定是右转）后再多加一次右转。我们还知道，蚂蚁不会在同一个位置连续旋转两次，并且蚂蚁行走的路径除了起点以外，不会到达同一个点多次，它最后一定是回到起点然后结束自己的行程，而且蚂蚁只会在棋盘格子的顶点处转弯。\n\n ![](https://cdn.luogu.com.cn/upload/pic/6217.png) \n\n现在已知棋盘大小、每个格子的权值以及左转次数除以 $2$ 的值，问蚂蚁走出的路径围出的封闭图形，权值之和最大可能是多少。\n", "inputFormat": "第一行三个数 $n,m,k$。意义如题目描述。\n\n接下来一个 $n$ 行 $m$ 列的整数矩阵，表示棋盘。\n", "outputFormat": "一个数，表示蚂蚁所走路径围出的图形可能的最大权值和。\n", "hint": "### 样例说明\n\n除了第一行的第二个和第一行的第四个都要围起来才至少合法。\n\n### 数据规模与约定\n\n- $10\\%$ 的数据所有格子中权值均非负。\n- 另 $20\\%$ 的数据 $n=2$。\n- 另 $30\\%$ 的数据 $k=0$。\n- $100\\%$ 的数据 $1 \\le n\\le 100$，$1 \\le m \\le 100$，$0 \\le k \\le 10$，保证存在合法路径，数据有梯度，格子中每个元素的值绝对值不超过 $10000$。\n", "locale": "zh-CN"}}}
{"pid": "P3336", "type": "P", "difficulty": 7, "samples": [["2 0", "1 1"], ["6 9\n4 2\n4 2\n2 0\n4 2\n6 0\n5 1\n2 0\n0 0\n0 0", "1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "贪心", "2013", "各省省选", "浙江", "组合数学"], "title": "[ZJOI2013] 话旧", "background": "", "description": "小林跟着银河队选手去了一趟宇宙比赛，耳濡目染，变得学术起来。回来后，他发现世界大变样了。比丘兽究级进化，成了凤凰兽；金先生因为发了一篇 paper，一跃成为教授，也成为了银河队选拔委员会成员。\n\n一日，小林与金教授聊天。金教授回忆起过去的岁月，那些年他学过的电路原理。他曾经对一种三角波很感兴趣，并且进行了一些探究。小林感到很好奇，于是金教授就将课题形式化地说了一遍。\n\n有一定义在 $[0,N]$ 的连续函数 $f(x)$，其中 $N$ 是整数，满足 $f(0)=f(N)=0$，它的所有极值点在整数处取到，且 $f(x)$ 的**极小值**均是 $0$。对于任意的 $0$ 到 $N-1$ 间的整数 $I$，$f(x)$ 在 $(I, I+1)$ 上是斜率为 $1$ 或 $-1$ 的一次函数。\n\n金先生研究的是，若他知道其中 $K$ 个整点的函数值，那么：\n\n1. 有多少个函数满足条件？\n2. 满足条件的函数中，$f(x)$ 的最大值，最大能是多少？\n\n小林思考了一下，便想出了很好的算法。那么作为经过多年训练的你呢？", "inputFormat": "第一行包含两个用空格隔开的整数 $N,K$。接下来 $K$ 行，每行两个整数，表示 $x_i$ 和 $f(x_i)$。\n", "outputFormat": "一行两个整数，分别对应两个问题的答案。考虑到第一问答案可能很大，你只要输出它除以 $19940417$ 的余数。", "hint": "- 对于 $10\\%$ 的数据，$N \\leq 10$。\n- 对于 $20\\%$ 的数据，$N \\leq 50$。\n- 对于 $30\\%$ 的数据，$N \\leq 100$，$K \\leq 100$。\n- 对于 $50\\%$ 的数据，$N \\leq 10^3$，$K \\leq 10^3$。\n- 对于 $70\\%$ 的数据，$N \\leq 10^5$。\n- 另有 $10\\%$ 的数据，$K=0$。\n- 对于 $100\\%$ 的数据，$ 0 \\leq N \\leq 10^9$，$0 \\leq K \\leq 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2013] Reminiscence", "background": "", "description": "Kobayashi went with the Galaxy Team players to a space contest. Influenced by the experience, he became more academic. After returning, he found the world had changed a lot. Biyomon underwent ultimate evolution and became Phoenixmon; Mr. Jin published a paper, was promoted to professor, and joined the Galaxy Team selection committee.\n\nOne day, Kobayashi chatted with Professor Jin. The professor recalled the years when he studied circuit theory. He was once very interested in a certain triangular wave and explored it. Kobayashi grew curious, so Professor Jin formalized the topic.\n\nThere is a continuous function $f(x)$ defined on $[0,N]$, where $N$ is an integer, satisfying $f(0)=f(N)=0$. All its extrema occur at integer points, and every local minimum of $f(x)$ is $0$. For any integer $I$ between $0$ and $N-1$, on $(I, I+1)$, $f(x)$ is a linear function with slope $1$ or $-1$.\n\nWhat Mr. Jin studies is: if he knows the function values at $K$ integer points, then:\n\n1. How many functions satisfy the conditions?\n2. Among all functions that satisfy the conditions, what is the largest possible value of $\\max f(x)$?\n\nKobayashi thought for a moment and came up with a good algorithm. What about you?", "inputFormat": "The first line contains two integers $N, K$ separated by a space. The next $K$ lines each contain two integers, representing $x_i$ and $f(x_i)$.", "outputFormat": "Output two integers in one line, corresponding to the answers to the two questions. Since the answer to the first question can be large, output it modulo $19940417$.", "hint": "- For 10% of the testdata, $N \\leq 10$.\n- For 20% of the testdata, $N \\leq 50$.\n- For 30% of the testdata, $N \\leq 100$, $K \\leq 100$.\n- For 50% of the testdata, $N \\leq 10^3$, $K \\leq 10^3$.\n- For 70% of the testdata, $N \\leq 10^5$.\n- Additionally, for 10% of the testdata, $K=0$.\n- For 100% of the testdata, $0 \\leq N \\leq 10^9$, $0 \\leq K \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2013] 话旧", "background": "", "description": "小林跟着银河队选手去了一趟宇宙比赛，耳濡目染，变得学术起来。回来后，他发现世界大变样了。比丘兽究级进化，成了凤凰兽；金先生因为发了一篇 paper，一跃成为教授，也成为了银河队选拔委员会成员。\n\n一日，小林与金教授聊天。金教授回忆起过去的岁月，那些年他学过的电路原理。他曾经对一种三角波很感兴趣，并且进行了一些探究。小林感到很好奇，于是金教授就将课题形式化地说了一遍。\n\n有一定义在 $[0,N]$ 的连续函数 $f(x)$，其中 $N$ 是整数，满足 $f(0)=f(N)=0$，它的所有极值点在整数处取到，且 $f(x)$ 的**极小值**均是 $0$。对于任意的 $0$ 到 $N-1$ 间的整数 $I$，$f(x)$ 在 $(I, I+1)$ 上是斜率为 $1$ 或 $-1$ 的一次函数。\n\n金先生研究的是，若他知道其中 $K$ 个整点的函数值，那么：\n\n1. 有多少个函数满足条件？\n2. 满足条件的函数中，$f(x)$ 的最大值，最大能是多少？\n\n小林思考了一下，便想出了很好的算法。那么作为经过多年训练的你呢？", "inputFormat": "第一行包含两个用空格隔开的整数 $N,K$。接下来 $K$ 行，每行两个整数，表示 $x_i$ 和 $f(x_i)$。\n", "outputFormat": "一行两个整数，分别对应两个问题的答案。考虑到第一问答案可能很大，你只要输出它除以 $19940417$ 的余数。", "hint": "- 对于 $10\\%$ 的数据，$N \\leq 10$。\n- 对于 $20\\%$ 的数据，$N \\leq 50$。\n- 对于 $30\\%$ 的数据，$N \\leq 100$，$K \\leq 100$。\n- 对于 $50\\%$ 的数据，$N \\leq 10^3$，$K \\leq 10^3$。\n- 对于 $70\\%$ 的数据，$N \\leq 10^5$。\n- 另有 $10\\%$ 的数据，$K=0$。\n- 对于 $100\\%$ 的数据，$ 0 \\leq N \\leq 10^9$，$0 \\leq K \\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P3337", "type": "P", "difficulty": 6, "samples": [["5 3\n1 5 6 3 4\n2 3 1\n1 5 4\n3 5 2", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2013", "各省省选", "浙江"], "title": "[ZJOI2013] 防守战线", "background": "", "description": "战线可以看作一个长度为 $n$ 的序列，现在需要在这个序列上建塔来防守敌兵，在序列第 $i$ 号位置上建一座塔有 $C_i$ 的花费，且一个位置可以建任意多的塔，费用累加计算。有 $m$ 个区间 $[L_1, R_1], [L_2, R_2], \\cdots, [L_m, R_m]$，在第 $i$ 个区间的范围内要建至少 $D_i$ 座塔。求最少花费。\n", "inputFormat": "第一行为两个数 $n, m$。\n\n接下来一行，有 $n$ 个数，描述 $C$ 数组。\n\n接下来 $m$ 行，每行三个数 $L_i,R_i,D_i$，描述一个区间。\n", "outputFormat": "仅包含一行，一个数，为最少花费。\n", "hint": "【样例说明】\n\n位置 $1$ 建 $2$ 个塔，位置 $3$ 建一个塔，位置 $4$ 建一个塔。花费 $1\\times 2+6+3=11$。\n\n【数据规模】\n\n对于 $20\\%$ 的数据，$n\\le 20$，$m\\le 20$。\n\n对于 $50\\%$ 的数据（包括上部分的数据），$D_i$ 全部为 $1$。\n\n对于 $70\\%$ 的数据（包括上部分的数据），$n\\le 100$，$m\\le 1000$。\n\n对于 $100\\%$ 的数据，$n\\le 1000$，$m\\le 10000$，$1\\le L_i\\le R_i\\le n$，其余数据均 $\\le 10000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2013] Defensive Frontline", "background": "", "description": "The frontline can be viewed as a sequence of length $n$. We need to build towers on this sequence to defend against enemy troops. Building a tower at position $i$ costs $C_i$, and any number of towers can be built at the same position, with costs added together. There are $m$ intervals $[L_1, R_1], [L_2, R_2], \\cdots, [L_m, R_m]$, and within the $i$-th interval, at least $D_i$ towers must be built. Find the minimum cost.", "inputFormat": "The first line contains two numbers $n, m$.\n\nThe next line contains $n$ numbers, describing the $C$ array.\n\nThe next $m$ lines each contain three numbers $L_i, R_i, D_i$, describing an interval.", "outputFormat": "Output a single line with one number: the minimum cost.", "hint": "Sample explanation:\n\nBuild $2$ towers at position $1$, one tower at position $3$, and one tower at position $4$. The cost is $1\\times 2+6+3=11$.\n\nConstraints:\n\n- For $20\\%$ of the testdata, $n \\le 20$, $m \\le 20$.\n- For $50\\%$ of the testdata (including the above), all $D_i$ are $1$.\n- For $70\\%$ of the testdata (including the above), $n \\le 100$, $m \\le 1000$.\n- For $100\\%$ of the testdata, $n \\le 1000$, $m \\le 10000$, $1 \\le L_i \\le R_i \\le n$, and all other values are $\\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2013] 防守战线", "background": "", "description": "战线可以看作一个长度为 $n$ 的序列，现在需要在这个序列上建塔来防守敌兵，在序列第 $i$ 号位置上建一座塔有 $C_i$ 的花费，且一个位置可以建任意多的塔，费用累加计算。有 $m$ 个区间 $[L_1, R_1], [L_2, R_2], \\cdots, [L_m, R_m]$，在第 $i$ 个区间的范围内要建至少 $D_i$ 座塔。求最少花费。\n", "inputFormat": "第一行为两个数 $n, m$。\n\n接下来一行，有 $n$ 个数，描述 $C$ 数组。\n\n接下来 $m$ 行，每行三个数 $L_i,R_i,D_i$，描述一个区间。\n", "outputFormat": "仅包含一行，一个数，为最少花费。\n", "hint": "【样例说明】\n\n位置 $1$ 建 $2$ 个塔，位置 $3$ 建一个塔，位置 $4$ 建一个塔。花费 $1\\times 2+6+3=11$。\n\n【数据规模】\n\n对于 $20\\%$ 的数据，$n\\le 20$，$m\\le 20$。\n\n对于 $50\\%$ 的数据（包括上部分的数据），$D_i$ 全部为 $1$。\n\n对于 $70\\%$ 的数据（包括上部分的数据），$n\\le 100$，$m\\le 1000$。\n\n对于 $100\\%$ 的数据，$n\\le 1000$，$m\\le 10000$，$1\\le L_i\\le R_i\\le n$，其余数据均 $\\le 10000$。\n", "locale": "zh-CN"}}}
{"pid": "P3338", "type": "P", "difficulty": 6, "samples": [["5\n4006373.885184\n15375036.435759\n1717456.469144\n8514941.004912\n1410681.345880", "-16838672.693\n3439.793\n7509018.566\n4595686.886\n10903040.872"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2014", "各省省选", "浙江", "Special Judge", "快速傅里叶变换 FFT"], "title": "[ZJOI2014] 力", "background": "", "description": "给出 $n$ 个数 $q_1,q_2, \\dots q_n$，定义\n\n$$F_j~=~\\sum_{i = 1}^{j - 1} \\frac{q_i \\times q_j}{(i - j)^2}~-~\\sum_{i = j + 1}^{n} \\frac{q_i \\times q_j}{(i - j)^2}$$\n\n$$E_i~=~\\frac{F_i}{q_i}$$\n\n对 $1 \\leq i \\leq n$，求 $E_i$ 的值。\n", "inputFormat": "第一行输入一个整数 $n$。\n\n以下 $n$ 行，每行有一个实数。第 $i+1$ 行的数代表 $q_i$。\n", "outputFormat": "输出 $n$ 行每行一个实数，第 $i$ 行的数字代表 $E_i$。\n\n当你的输出与标准答案相差不超过 $10^{-2}$ 时即被认为正确。", "hint": "【数据范围】   \n对于 $30\\%$ 的数据，$n \\leq 1000$；   \n对于 $50\\%$ 的数据，$n \\leq 6 \\times 10^4$；   \n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$，$0 < q_i < 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2014] Force", "background": "", "description": "Given $n$ numbers $q_1,q_2, \\dots q_n$, define\n\n$$F_j~=~\\sum_{i = 1}^{j - 1} \\frac{q_i \\times q_j}{(i - j)^2}~-~\\sum_{i = j + 1}^{n} \\frac{q_i \\times q_j}{(i - j)^2}$$\n\n$$E_i~=~\\frac{F_i}{q_i}$$\n\nFor $1 \\leq i \\leq n$, find the value of $E_i$.", "inputFormat": "The first line contains an integer $n$.\n\nEach of the following $n$ lines contains a real number. The number on the $(i+1)$-th line represents $q_i$.", "outputFormat": "Output $n$ lines, each containing a real number. The number on the $i$-th line represents $E_i$.\n\nYour output is considered correct if it differs from the standard answer by at most $10^{-2}$.", "hint": "Constraints  \nFor $30\\%$ of the testdata, $n \\leq 1000$.  \nFor $50\\%$ of the testdata, $n \\leq 6 \\times 10^4$.  \nFor $100\\%$ of the testdata, $1 \\leq n \\leq 10^5$, $0 < q_i < 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2014] 力", "background": "", "description": "给出 $n$ 个数 $q_1,q_2, \\dots q_n$，定义\n\n$$F_j~=~\\sum_{i = 1}^{j - 1} \\frac{q_i \\times q_j}{(i - j)^2}~-~\\sum_{i = j + 1}^{n} \\frac{q_i \\times q_j}{(i - j)^2}$$\n\n$$E_i~=~\\frac{F_i}{q_i}$$\n\n对 $1 \\leq i \\leq n$，求 $E_i$ 的值。\n", "inputFormat": "第一行输入一个整数 $n$。\n\n以下 $n$ 行，每行有一个实数。第 $i+1$ 行的数代表 $q_i$。\n", "outputFormat": "输出 $n$ 行每行一个实数，第 $i$ 行的数字代表 $E_i$。\n\n当你的输出与标准答案相差不超过 $10^{-2}$ 时即被认为正确。", "hint": "【数据范围】   \n对于 $30\\%$ 的数据，$n \\leq 1000$；   \n对于 $50\\%$ 的数据，$n \\leq 6 \\times 10^4$；   \n对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^5$，$0 < q_i < 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3339", "type": "P", "difficulty": 7, "samples": [["2 \n1 1 \n1\n2 30 \n197943 \n249832", "Preempt.\nLeapfrog."]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["递推", "2014", "各省省选", "浙江", "进制", "Fibonacci 数列"], "title": "[ZJOI2014] 取石子游戏", "background": "", "description": "Roland. p Sprague 和 Patrick M. Grundy 都是组合游戏的狂热爱好者，但他们素未谋面。\n\n一天，Sprague 在写给 Grundy 的信中向他介绍了一个据称是来自东方的古老游戏一一取石子。\n\n取石子是一个双人博弈游戏。在游戏的一开始，桌面上有几堆石子堆。接下 来，游戏双方轮流进行操作：从桌面上选取一堆石子堆，然后从这一堆里面取走任意多个石子（但不能不取）。当某个人无法操作时则失败，另一方获得胜利。由于条件所限, Sprague 建议在纸上写一排自然数来代表各个石子堆的石子数目，然后两人轮流划数与数；Grundy 欣然应允。\n\n一个月过去了，在 Grundy 连续输了 $5$ 盘游戏之后，他怀疑 Sprague 要诈。经过几天的研究，Grundy 在某天下午发现假设游戏双方都足够聪明，那么给定一个初始状态（一排自然数），可以有很简单的方法来判定先手必胜还是后手必胜，并且可以给出必胜策略！于是 Grundy 决定要进行反击。\n\n翌日，Grundy 在写给 Sprague 的信中建议把游戏的规则改得更复杂一点：首先确定一个常数 $K$。然后，游戏双方的操作改为：每次选择一个数划掉。假设该数为 $x$，操作者可以任选一个正整数a，在划掉之后需要再写上 $x-a$，$x-2a $，$\\cdots$，$x-K \\times a$ 共 $K$ 个数，且 $a$ 需满足 $x-K\\times a \\geq 0$。若这样的 $a$ 不存在，那么操作者就不能划掉这个无。某一方失败的条件依然是他无法操作。\n\n碍于面子，Sprague 当然无法拒绝。不过他也不会坐以待毙，现在他已经得到了和写在纸上的个数。他把这些数据和这个游戏的规则都告诉了你一一一个正在研究如何使用一个尚不存在的机械（你将其命名为计算机）解决实际的数学、物理、经济学）的计算机科学家。\n\n", "inputFormat": "输入文件，第一行是一个正整数，表示数据组数 $T$（Sprague 向你询问的次数）。接下来依次输入 $T$ 组数据，每组数据占 $N + 2$ 行，格式如下：\n\n- 第 $1$ 行是一个空行。\n- 第 $2$ 行，两个正整数，按顺序表示 $N$ 和 $K$。\n- 接下来 $N$ 行，每行一个正整数，表示写在纸上的 $N$ 个数。", "outputFormat": "输出文件共有 $T$ 行。对每组数据，如果先手必胜（先进行操作的玩家拥有必胜策略），则输出 `Preempt.`。若后手必胜，则输出 `Leapfrog.`。若两者皆非，则输出 `Je suis un imbecile.`", "hint": "$10\\%$ 的数据满足：$N \\leq 5$，$K=1$，所有数均小等于 $5$。\n\n$20\\%$ 的数据满足：$N \\leq 100$，$K=1$，所有数均小等于 $10^9$。\n\n$10\\%$ 的数据满足：$N \\leq 100$，$K=2$，所有数均小等于 $10^9$。\n\n$20\\%$ 的数据满足：$N \\leq 100$，$K=2$，所有数均小等于 $10^{18}$。\n\n$20\\%$ 的数据满足：$N \\leq 100$，$K=10$，所有数均小等于 $10^{18}$。\n\n$40\\%$ 的数据满足：$N \\leq 100$，$K=30$，所有数均小等于 $10^{80}$。\n\n$100\\%$ 的数据满足：$T \\leq 10$", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2014] Take-Stones Game", "background": "", "description": "Roland P. Sprague and Patrick M. Grundy are both passionate enthusiasts of combinatorial games, but they have never met.\n\nOne day, in a letter to Grundy, Sprague introduced a supposedly ancient game from the East — Take-Stones.\n\nTake-Stones is a two-player impartial game. At the beginning of the game, there are several piles of stones on the table. Then the players take turns: choose one pile and remove any positive number of stones from that pile (but you must take at least one). The player who cannot make a move loses, and the other player wins. Due to practical constraints, Sprague suggested writing a row of natural numbers on paper to represent the sizes of the piles, and then the two would take turns crossing out and writing numbers; Grundy gladly agreed.\n\nA month passed, and after Grundy had lost $5$ games in a row, he suspected that Sprague was cheating. After several days of study, one afternoon Grundy discovered that if both players are clever enough, then given an initial position (a row of natural numbers), there is a very simple way to determine whether the first player or the second player has a forced win, and even to provide a winning strategy! So Grundy decided to strike back.\n\nThe next day, in a letter to Sprague, Grundy suggested making the rules a bit more complicated: first fix a constant $K$. Then each move is changed to: choose a number and cross it out. Suppose the chosen number is $x$. The player may choose any positive integer a; after crossing out $x$, they must write down $x-a$，$x-2a $，$\\cdots$，$x-K \\times a$ — a total of $K$ numbers — and $a$ must satisfy $x-K\\times a \\geq 0$. If no such a exists, then the player cannot cross out this number. A player still loses if and only if they have no legal move.\n\nFor the sake of pride, Sprague could not refuse. But he would not sit and wait for defeat either. He has already obtained the numbers written on the paper. He tells you this testdata and the rules of the game — you, a computer scientist studying how to use a not-yet-existing machine (which you name a “computer”) to solve practical problems in mathematics, physics, and economics.", "inputFormat": "In the input file, the first line is a positive integer representing the number of test cases $T$ (the number of times Sprague consults you). Then $T$ test cases follow, each occupying $N + 2$ lines, in the following format:\n\n- Line $1$: an empty line.\n- Line $2$: two positive integers, in order, representing $N$ and $K$.\n- The next $N$ lines: each line contains one positive integer, representing the $N$ numbers written on the paper.", "outputFormat": "The output file contains $T$ lines. For each test case, if the first player (the player who moves first) has a winning strategy, print `Preempt.`. If the second player has a winning strategy, print `Leapfrog.`. If neither of the above applies, print `Je suis un imbecile.`.", "hint": "$10\\%$ of the testdata satisfies: $N \\leq 5$, $K=1$, and all numbers are at most $5$.\n\n$20\\%$ of the testdata satisfies: $N \\leq 100$, $K=1$, and all numbers are at most $10^9$.\n\n$10\\%$ of the testdata satisfies: $N \\leq 100$, $K=2$, and all numbers are at most $10^9$.\n\n$20\\%$ of the testdata satisfies: $N \\leq 100$, $K=2$, and all numbers are at most $10^{18}$.\n\n$20\\%$ of the testdata satisfies: $N \\leq 100$, $K=10$, and all numbers are at most $10^{18}$.\n\n$40\\%$ of the testdata satisfies: $N \\leq 100$, $K=30$, and all numbers are at most $10^{80}$.\n\n$100\\%$ of the testdata satisfies: $T \\leq 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2014] 取石子游戏", "background": "", "description": "Roland. p Sprague 和 Patrick M. Grundy 都是组合游戏的狂热爱好者，但他们素未谋面。\n\n一天，Sprague 在写给 Grundy 的信中向他介绍了一个据称是来自东方的古老游戏一一取石子。\n\n取石子是一个双人博弈游戏。在游戏的一开始，桌面上有几堆石子堆。接下 来，游戏双方轮流进行操作：从桌面上选取一堆石子堆，然后从这一堆里面取走任意多个石子（但不能不取）。当某个人无法操作时则失败，另一方获得胜利。由于条件所限, Sprague 建议在纸上写一排自然数来代表各个石子堆的石子数目，然后两人轮流划数与数；Grundy 欣然应允。\n\n一个月过去了，在 Grundy 连续输了 $5$ 盘游戏之后，他怀疑 Sprague 要诈。经过几天的研究，Grundy 在某天下午发现假设游戏双方都足够聪明，那么给定一个初始状态（一排自然数），可以有很简单的方法来判定先手必胜还是后手必胜，并且可以给出必胜策略！于是 Grundy 决定要进行反击。\n\n翌日，Grundy 在写给 Sprague 的信中建议把游戏的规则改得更复杂一点：首先确定一个常数 $K$。然后，游戏双方的操作改为：每次选择一个数划掉。假设该数为 $x$，操作者可以任选一个正整数a，在划掉之后需要再写上 $x-a$，$x-2a $，$\\cdots$，$x-K \\times a$ 共 $K$ 个数，且 $a$ 需满足 $x-K\\times a \\geq 0$。若这样的 $a$ 不存在，那么操作者就不能划掉这个无。某一方失败的条件依然是他无法操作。\n\n碍于面子，Sprague 当然无法拒绝。不过他也不会坐以待毙，现在他已经得到了和写在纸上的个数。他把这些数据和这个游戏的规则都告诉了你一一一个正在研究如何使用一个尚不存在的机械（你将其命名为计算机）解决实际的数学、物理、经济学）的计算机科学家。\n\n", "inputFormat": "输入文件，第一行是一个正整数，表示数据组数 $T$（Sprague 向你询问的次数）。接下来依次输入 $T$ 组数据，每组数据占 $N + 2$ 行，格式如下：\n\n- 第 $1$ 行是一个空行。\n- 第 $2$ 行，两个正整数，按顺序表示 $N$ 和 $K$。\n- 接下来 $N$ 行，每行一个正整数，表示写在纸上的 $N$ 个数。", "outputFormat": "输出文件共有 $T$ 行。对每组数据，如果先手必胜（先进行操作的玩家拥有必胜策略），则输出 `Preempt.`。若后手必胜，则输出 `Leapfrog.`。若两者皆非，则输出 `Je suis un imbecile.`", "hint": "$10\\%$ 的数据满足：$N \\leq 5$，$K=1$，所有数均小等于 $5$。\n\n$20\\%$ 的数据满足：$N \\leq 100$，$K=1$，所有数均小等于 $10^9$。\n\n$10\\%$ 的数据满足：$N \\leq 100$，$K=2$，所有数均小等于 $10^9$。\n\n$20\\%$ 的数据满足：$N \\leq 100$，$K=2$，所有数均小等于 $10^{18}$。\n\n$20\\%$ 的数据满足：$N \\leq 100$，$K=10$，所有数均小等于 $10^{18}$。\n\n$40\\%$ 的数据满足：$N \\leq 100$，$K=30$，所有数均小等于 $10^{80}$。\n\n$100\\%$ 的数据满足：$T \\leq 10$", "locale": "zh-CN"}}}
{"pid": "P3340", "type": "P", "difficulty": 6, "samples": [["6 6\n3 4\n5 6\n1 3\n4 4\n3 3\n2 4\n1 2\n1 3\n2 3\n2 4\n3 5\n5 6\n3\n3 6\n2 4\n4 6", "0.66667 \n0.00000 \n1.67544"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "浙江", "Special Judge"], "title": "[ZJOI2014] 星系调查", "background": null, "description": "银河历 $59451$ 年，在银河系有许许多多已被人类殖民的星系。如果想要在行星系间往来，大家一般使用连接两个行星系的跳跃星门。一个跳跃星门可以把物质在它所连接的两个行星系中互相传送。露露、花花和萱萱被银河系星际联盟调查局任命调查商业巨擘 ZeusLeague+ 的不正当商业行为。\n\n在银河系有 $N$ 个已被 ZeusLeague+ 成功打入市场的行星系，不妨标号为 $1,2,...,N$。而 ZeusLeague+ 在这 $N$ 个行星系之间还拥有自己的 $M$ 个跳跃星门。使用这些跳跃星门，ZeusLeague+ 的物资就可以在这 $N$ 个行星系中两两任意互相传输。由于经费问题，跳跃星门的个数不会超过行星系的个数。\n\n露露在颇费周折之后得到了 ZeusLeague+ 在这 $N$ 个行星系中的各自的贸易总额 $C_i$。\n\n萱萱设计了一个经济学特征指标 $D_i$ 来度量这 $N$ 个行星系的经济学特征。于是，我们可以用二元组 $(C_i,D_i)$ 来表示第 $i$ 个行星系的 XP (Xuan's Position)。现在假设我们有 $k$ 个行星系的 XPs，把它们放置在二维平面上，然后我们用一条直线去拟合这些 XPs。定义一条直线与 XPs的相斥度为这条直线到各个 XP 的 Euclid 距离的平方之和。再令 XPs 的线性假设相斥度为所有直线与 XPs 的相斥度中的最小者。那么，这个值越小，ZeusLeague+ 在这 $k$ 个行星系中的相互贸易活动就越可疑，从而值得进一步调查。花花负责计算许多行星系对 $(u,v)$ 的非可疑度。一条跳跃星门航线的非可疑度被定义为它经过的所有行星系（包括起点和终点）的 XPs 的线性假设相斥度。而一个行星系对 $(u,v)$ 的非可疑度则被定义为所有以 $u$ 为起点，$v$ 为终点的跳跃星门航线的非可疑度中的最小值。一条跳跃星门航线是指从某个行星系开始，通过跳跃星门依次到达某些行星系，然后终止，并且中途不重复经过行星系，这样的一个过程。\n\n花花负责计算许多行星系对 $(u,v)$ 的非可疑度。一条跳跃星门航线的非可疑度被定义为它经过的所有行星系（包括起点和终点）的 XPs 的线性假设相斥度。而一个行星系对 $(u,v)$的非可疑度则被定义为所有以 $u$ 为起点，$v$ 为终点的跳跃星门航线的非可疑度中的最小值。一条跳跃星门航线是指从某个行星系开始，通过跳跃星门依次到达某些行星系，然后终止，并且中途不重复经过行星系，这样的一个过程。\n\n在花花数天夜以继日的工作之后，平行调查组的你——大名鼎鼎的计算机科学家 Hcceleration.Gerk.Gounce 不忍心看到她这样不眠不休，于是你在完成了手头的工作之后决定帮一帮她。", "inputFormat": "第一行是 $N,M$，分别表示这个银河系内的行星系的个数以及跳跃星门的个数。接下来 $N$ 行，每行2个正整数 $C_i,D_i$，表示第 $i$ 个行星系的 XP (Xuan's Position)。接下来的 $M$ 行来描述跳跃星门，每行两个正整数 $u_i,v_i$，表示有一个连接着行星系 $u_i$ 和 $v_i$ 的跳跃星门。注意这个连接是无向的。不会存在自己连向自己的情况。也不会存在重复连接的情况。接下来的一行，有一个正整数 $Q$，表示花花需要计算的非可疑度的行星对数。接下来的 $Q$ 行，每行两个正整数 $s_i,t_i$，表示花花需要计算从 $s_i$ 到 $t_i$ 的非可疑度。", "outputFormat": "总共 $Q$ 行，每一行一个实数，表示花花第 $i$ 次需要计算的答案。你的答案需要和标准答案的差不超过 $0.01$ 才能得分。", "hint": "$1\\leq N,M,Q\\leq 10^5,1\\leq u_i,v_i,s_i,t_i\\leq N,1\\leq C_i,D_i\\leq 100.$\n\n#### 简要题意（by yummy）\n\n在边数不超过结点数的简单无权无向连通图内，每个结点在平面直角坐标系内对应一个坐标。有 $Q$ 组询问，每次给一对结点，找出一条路径，并找出一条直线，使得该路径上结点对应的坐标到直线距离平方和最小，并输出最小值。\n\n[spj 0.01]", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2014] Galaxy Survey", "background": "", "description": "In Galactic Year $59451$, there are many star systems in the Milky Way that have been colonized by humans. To travel between planetary systems, people typically use jump gates that connect two planetary systems. A jump gate can transfer matter between the two planetary systems it connects. Lulu, Huahua, and Xuānxuān are appointed by the Galactic Interstellar Alliance Investigation Bureau to investigate the unfair business practices of the commercial giant ZeusLeague+.\n\nThere are $N$ planetary systems where ZeusLeague+ has successfully entered the market, labeled $1, 2, \\ldots, N$. ZeusLeague+ also owns $M$ jump gates among these $N$ planetary systems. Using these jump gates, ZeusLeague+ can transport goods between any pair of the $N$ planetary systems. Due to budget constraints, the number of jump gates does not exceed the number of planetary systems.\n\nAfter considerable effort, Lulu obtained the total trade volume $C_i$ of ZeusLeague+ in each of the $N$ planetary systems.\n\nXuānxuān designed an economic characteristic index $D_i$ to measure the economic features of these $N$ planetary systems. Thus, we can use the pair $(C_i, D_i)$ to denote the XP (Xuan's Position) of the $i$-th planetary system. Now suppose we have the XPs of $k$ planetary systems and place them on a 2D plane. We then fit a straight line to these XPs. Define the repulsiveness of a straight line with respect to the XPs as the sum of squared Euclidean distances from that line to each XP. Then define the linear-hypothesis repulsiveness of the XPs as the minimum repulsiveness over all straight lines. The smaller this value is, the more suspicious the mutual trade activities of ZeusLeague+ among these $k$ planetary systems are, and thus more deserving of further investigation.\n\nHuahua is responsible for computing the non-suspiciousness of many pairs of planetary systems $(u, v)$. The non-suspiciousness of a jump-gate route is defined as the linear-hypothesis repulsiveness of the XPs of all planetary systems it passes through (including the start and end). The non-suspiciousness of a pair of planetary systems $(u, v)$ is defined as the minimum, over all jump-gate routes starting at $u$ and ending at $v$, of the non-suspiciousness of those routes. A jump-gate route is a process that starts from some planetary system, visits some planetary systems in sequence via jump gates, and then terminates, without visiting any planetary system more than once.\n\nAfter days and nights of work by Huahua, you—the renowned computer scientist Hcceleration.Gerk.Gounce from the parallel investigation team—cannot bear to see her working without rest. Having completed your own tasks, you decide to help her.", "inputFormat": "The first line contains $N, M$, the number of planetary systems in the galaxy and the number of jump gates, respectively. The next $N$ lines each contain two positive integers $C_i, D_i$, representing the XP (Xuan's Position) of the $i$-th planetary system. The next $M$ lines describe the jump gates, each with two positive integers $u_i, v_i$, indicating there is a jump gate connecting planetary systems $u_i$ and $v_i$. Note that this connection is undirected. There are no self-loops and no multiple edges. The next line contains a positive integer $Q$, the number of pairs of planetary systems for which Huahua needs to compute the non-suspiciousness. The following $Q$ lines each contain two positive integers $s_i, t_i$, indicating that Huahua needs to compute the non-suspiciousness from $s_i$ to $t_i$.", "outputFormat": "Output $Q$ lines. Each line contains a real number, which is the answer to Huahua’s $i$-th query. Your answer must differ from the standard answer by no more than $0.01$ to receive credit.", "hint": "$1\\leq N, M, Q\\leq 10^5, 1\\leq u_i, v_i, s_i, t_i\\leq N, 1\\leq C_i, D_i\\leq 100.$\n\nBrief statement (by yummy): In a simple, unweighted, undirected, connected graph with the number of edges not exceeding the number of nodes, each node corresponds to a coordinate in the Cartesian plane. There are $Q$ queries. For each given pair of nodes, find a path and a straight line such that the sum of squared distances from the coordinates of nodes on that path to the line is minimized, and output the minimum value.\n\n[spj 0.01]\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2014] 星系调查", "background": null, "description": "银河历 $59451$ 年，在银河系有许许多多已被人类殖民的星系。如果想要在行星系间往来，大家一般使用连接两个行星系的跳跃星门。一个跳跃星门可以把物质在它所连接的两个行星系中互相传送。露露、花花和萱萱被银河系星际联盟调查局任命调查商业巨擘 ZeusLeague+ 的不正当商业行为。\n\n在银河系有 $N$ 个已被 ZeusLeague+ 成功打入市场的行星系，不妨标号为 $1,2,...,N$。而 ZeusLeague+ 在这 $N$ 个行星系之间还拥有自己的 $M$ 个跳跃星门。使用这些跳跃星门，ZeusLeague+ 的物资就可以在这 $N$ 个行星系中两两任意互相传输。由于经费问题，跳跃星门的个数不会超过行星系的个数。\n\n露露在颇费周折之后得到了 ZeusLeague+ 在这 $N$ 个行星系中的各自的贸易总额 $C_i$。\n\n萱萱设计了一个经济学特征指标 $D_i$ 来度量这 $N$ 个行星系的经济学特征。于是，我们可以用二元组 $(C_i,D_i)$ 来表示第 $i$ 个行星系的 XP (Xuan's Position)。现在假设我们有 $k$ 个行星系的 XPs，把它们放置在二维平面上，然后我们用一条直线去拟合这些 XPs。定义一条直线与 XPs的相斥度为这条直线到各个 XP 的 Euclid 距离的平方之和。再令 XPs 的线性假设相斥度为所有直线与 XPs 的相斥度中的最小者。那么，这个值越小，ZeusLeague+ 在这 $k$ 个行星系中的相互贸易活动就越可疑，从而值得进一步调查。花花负责计算许多行星系对 $(u,v)$ 的非可疑度。一条跳跃星门航线的非可疑度被定义为它经过的所有行星系（包括起点和终点）的 XPs 的线性假设相斥度。而一个行星系对 $(u,v)$ 的非可疑度则被定义为所有以 $u$ 为起点，$v$ 为终点的跳跃星门航线的非可疑度中的最小值。一条跳跃星门航线是指从某个行星系开始，通过跳跃星门依次到达某些行星系，然后终止，并且中途不重复经过行星系，这样的一个过程。\n\n花花负责计算许多行星系对 $(u,v)$ 的非可疑度。一条跳跃星门航线的非可疑度被定义为它经过的所有行星系（包括起点和终点）的 XPs 的线性假设相斥度。而一个行星系对 $(u,v)$的非可疑度则被定义为所有以 $u$ 为起点，$v$ 为终点的跳跃星门航线的非可疑度中的最小值。一条跳跃星门航线是指从某个行星系开始，通过跳跃星门依次到达某些行星系，然后终止，并且中途不重复经过行星系，这样的一个过程。\n\n在花花数天夜以继日的工作之后，平行调查组的你——大名鼎鼎的计算机科学家 Hcceleration.Gerk.Gounce 不忍心看到她这样不眠不休，于是你在完成了手头的工作之后决定帮一帮她。", "inputFormat": "第一行是 $N,M$，分别表示这个银河系内的行星系的个数以及跳跃星门的个数。接下来 $N$ 行，每行2个正整数 $C_i,D_i$，表示第 $i$ 个行星系的 XP (Xuan's Position)。接下来的 $M$ 行来描述跳跃星门，每行两个正整数 $u_i,v_i$，表示有一个连接着行星系 $u_i$ 和 $v_i$ 的跳跃星门。注意这个连接是无向的。不会存在自己连向自己的情况。也不会存在重复连接的情况。接下来的一行，有一个正整数 $Q$，表示花花需要计算的非可疑度的行星对数。接下来的 $Q$ 行，每行两个正整数 $s_i,t_i$，表示花花需要计算从 $s_i$ 到 $t_i$ 的非可疑度。", "outputFormat": "总共 $Q$ 行，每一行一个实数，表示花花第 $i$ 次需要计算的答案。你的答案需要和标准答案的差不超过 $0.01$ 才能得分。", "hint": "$1\\leq N,M,Q\\leq 10^5,1\\leq u_i,v_i,s_i,t_i\\leq N,1\\leq C_i,D_i\\leq 100.$\n\n#### 简要题意（by yummy）\n\n在边数不超过结点数的简单无权无向连通图内，每个结点在平面直角坐标系内对应一个坐标。有 $Q$ 组询问，每次给一对结点，找出一条路径，并找出一条直线，使得该路径上结点对应的坐标到直线距离平方和最小，并输出最小值。\n\n[spj 0.01]", "locale": "zh-CN"}}}
{"pid": "P3341", "type": "P", "difficulty": 6, "samples": [["4 4\n4\n1 1 1 4\n1 2 3 4\n1 3 3 2\n4 1 2 3\n6\n2 3 U R\n2 1 D R\n2 2 L R\n2 4 L D\n3 1 L R\n3 3 L U", "2\n4\n4 3 L U\n3 3 L U\n3 2 R U\n1 2 L R"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2014", "各省省选", "浙江", "Special Judge", "枚举", "队列"], "title": "[ZJOI2014] 消棋子", "background": "", "description": "消棋子是一个有趣的游戏。游戏在一个 $r \\times c$ 的棋盘上进行。棋盘的每个格子，要么是空，要么是一种颜色的棋子。同一种颜色的棋子恰好有两个。每一轮，玩家可以选择一个空格子 $(x, y)$，并选择上下左右四个方向中的两个方向，如果在这两个方向上均存在有棋子的格子，而且沿着这两个方向上第一个遇到的棋子颜色相同，那么，我们将这两个棋子拿走，并称之为合法的操作。否则称这个操作不合法，游戏不会处理这个操作。游戏的目的是消除尽量多的棋子。\n\n给出这样一个游戏和一个人的玩法。你需要： \n1. 指出此人能消去多少棋子。 \n2. 给出一种能消去最多棋子的方案。", "inputFormat": "第一行给出了整数 $r$，$c$。\n\n第二行给出了整数 $n$，表示不同颜色数。\n\n接下来 $n$ 行，第 $i$ 行含四个整数 $a_i, b_i, c_i, d_i$，表示颜色为 $i$ 的两个格子分别是 $(a_i, b_i),\\ (c_i, d_i)$。\n\n然后是一个整数 $m$，表示此人的操作数。接下来 $m$ 行，每行有两个整数和两个字母，代表了他选择的格子，以及两个方向。我们用 $\\texttt{UDLR}$ 分别表示上下左右。", "outputFormat": "第一行输出此人能消去多少棋子。\n\n第二行含一个整数 $k$，表示你给出的方案的操作数。\n\n接下来 $k$ 行，每行两个整数和两个字母，代表你选择的格子以及两个方向。", "hint": "对于所有数据，$1\\leq r,c,n \\leq 10^5$，数据保证答案的操作数 $0\\leq k \\leq 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2014] Remove Pieces", "background": "", "description": "Remove Pieces is an interesting game. The game is played on an $r \\times c$ board. Each cell of the board is either empty or contains a piece of some color. Each color appears exactly twice. In each round, the player can choose an empty cell $(x, y)$ and choose two directions among up, down, left, and right. If, in each of the two chosen directions, there exists a cell containing a piece, and the first piece encountered along each direction has the same color, then we take away those two pieces, and call this a legal move. Otherwise, the move is illegal and the game will not process this move. The goal is to remove as many pieces as possible.\n\nGiven such a game and a person's sequence of moves, you need to:\n1. State how many pieces this person can remove.\n2. Provide a sequence of moves that removes the maximum number of pieces.", "inputFormat": "The first line gives the integers $r$, $c$.\n\nThe second line gives the integer $n$, the number of different colors.\n\nThe next $n$ lines, the $i$-th line contains four integers $a_i, b_i, c_i, d_i$, meaning that the two cells of color $i$ are $(a_i, b_i),\\ (c_i, d_i)$.\n\nThen an integer $m$ follows, the number of this person’s moves. The next $m$ lines each contain two integers and two letters, representing the chosen cell and the two directions. We use $\\texttt{UDLR}$ to denote up, down, left, and right, respectively.", "outputFormat": "The first line outputs how many pieces this person can remove.\n\nThe second line contains an integer $k$, the number of moves in your sequence.\n\nThe next $k$ lines each contain two integers and two letters, representing your chosen cell and the two directions.", "hint": "For all testdata, $1 \\leq r, c, n \\leq 10^5$, and it is guaranteed that in the answer the number of operations satisfies $0 \\leq k \\leq 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2014] 消棋子", "background": "", "description": "消棋子是一个有趣的游戏。游戏在一个 $r \\times c$ 的棋盘上进行。棋盘的每个格子，要么是空，要么是一种颜色的棋子。同一种颜色的棋子恰好有两个。每一轮，玩家可以选择一个空格子 $(x, y)$，并选择上下左右四个方向中的两个方向，如果在这两个方向上均存在有棋子的格子，而且沿着这两个方向上第一个遇到的棋子颜色相同，那么，我们将这两个棋子拿走，并称之为合法的操作。否则称这个操作不合法，游戏不会处理这个操作。游戏的目的是消除尽量多的棋子。\n\n给出这样一个游戏和一个人的玩法。你需要： \n1. 指出此人能消去多少棋子。 \n2. 给出一种能消去最多棋子的方案。", "inputFormat": "第一行给出了整数 $r$，$c$。\n\n第二行给出了整数 $n$，表示不同颜色数。\n\n接下来 $n$ 行，第 $i$ 行含四个整数 $a_i, b_i, c_i, d_i$，表示颜色为 $i$ 的两个格子分别是 $(a_i, b_i),\\ (c_i, d_i)$。\n\n然后是一个整数 $m$，表示此人的操作数。接下来 $m$ 行，每行有两个整数和两个字母，代表了他选择的格子，以及两个方向。我们用 $\\texttt{UDLR}$ 分别表示上下左右。", "outputFormat": "第一行输出此人能消去多少棋子。\n\n第二行含一个整数 $k$，表示你给出的方案的操作数。\n\n接下来 $k$ 行，每行两个整数和两个字母，代表你选择的格子以及两个方向。", "hint": "对于所有数据，$1\\leq r,c,n \\leq 10^5$，数据保证答案的操作数 $0\\leq k \\leq 10^6$。", "locale": "zh-CN"}}}
{"pid": "P3342", "type": "P", "difficulty": 6, "samples": [["2\n0 7 2 3\n0 8 1 4\n4 5 4 1\n8 6 3 2\n16 3 6 7\n32 4 5 8\n1 1 8 5\n2 2 7 6", "0 12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1500], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "各省省选", "浙江", "枚举", "广度优先搜索 BFS", "图论建模"], "title": "[ZJOI2014] 璀灿光华", "background": "", "description": "金先生有一个女朋友没名字。她勤劳勇敢、智慧善良。金先生很喜欢她。为此，金先生用 $a^3$ 块 $1\\times 1 \\times 1$ 的独特的水晶制作了一个边长为 $a$ 的水晶立方体，他要将这个水晶立方体送给他见过最单纯善良的她。\n\n由于水晶立方体太太，不好运送，金先生还是将它拆开来送出。他相信拼好这个水晶立方难不倒聪明的她。\n\n没名字收到了礼物后果然不一会儿就根据说明将水晶立方体拼好了。没名字发现，有 $n$ 块水晶在漆黑安静的夜晚会随机以等概率向上下左右前后六个方向的一个发出穿透光。被光照到的水晶显得格外好看。没名字给每一块不会发光的水晶定义了一个好看程度。水晶立方体在夜晚中的好看程度就是每块被光照到的水晶的好看程度之和。没名字想知道，水晶立方体在夜晚中的好看程度的最小值和最大值。", "inputFormat": "第一行是 $a$，表示水晶立方体的边长。\n接下来 $a^3$ 行，每行若干整数。\n第一个数 $g_i$ 表示第 $i$ 块水晶的好看程度。如果 $g_i=0$，代表这块水晶会发光。接下来 $3\\sim 6$ 个整数，代表与这块水晶有共同面的水晶编号。", "outputFormat": "两个整数，代表水晶立方体在夜晚好看程度的最小值与最大值。", "hint": "对于所有数据，$1<a\\leq 70$，$g_i<10^6$，$n\\leq 8$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2014] Brilliant Light", "background": "", "description": "Mr. Jin has a girlfriend without a name. She is hardworking, brave, wise, and kind. Mr. Jin likes her very much. To this end, he used $a^3$ unique $1\\times 1 \\times 1$ crystal blocks to make a crystal cube with side length $a$. He wants to give this crystal cube to the purest and kindest girl he has ever met.\n\nBecause the crystal cube is too big to transport, Mr. Jin decided to take it apart before sending it. He believes that reassembling the crystal cube will not be difficult for her, since she is smart.\n\nAfter receiving the gift, the nameless girl quickly reassembled the crystal cube according to the instructions. She found that there are $n$ crystals which, in a dark and quiet night, randomly emit a penetrating beam in one of the six directions (up, down, left, right, front, back) with equal probability. Crystals that are illuminated by the beams look especially beautiful. For each crystal that does not emit light, she defined a beauty value. The beauty of the crystal cube at night is the sum of the beauty values of all illuminated crystals. She wants to know the minimum and maximum possible beauty of the crystal cube at night.", "inputFormat": "The first line contains $a$, the side length of the crystal cube.\nThen follow $a^3$ lines, each containing several integers.\nThe first number $g_i$ is the beauty value of the $i$‑th crystal. If $g_i = 0$, this crystal emits light. Then follow 3 to 6 integers, which are the indices of crystals that share a face with this crystal.", "outputFormat": "Output two integers: the minimum and the maximum possible beauty of the crystal cube at night.", "hint": "For all testdata, $1 < a \\leq 70$, $g_i < 10^6$, $n \\leq 8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2014] 璀灿光华", "background": "", "description": "金先生有一个女朋友没名字。她勤劳勇敢、智慧善良。金先生很喜欢她。为此，金先生用 $a^3$ 块 $1\\times 1 \\times 1$ 的独特的水晶制作了一个边长为 $a$ 的水晶立方体，他要将这个水晶立方体送给他见过最单纯善良的她。\n\n由于水晶立方体太太，不好运送，金先生还是将它拆开来送出。他相信拼好这个水晶立方难不倒聪明的她。\n\n没名字收到了礼物后果然不一会儿就根据说明将水晶立方体拼好了。没名字发现，有 $n$ 块水晶在漆黑安静的夜晚会随机以等概率向上下左右前后六个方向的一个发出穿透光。被光照到的水晶显得格外好看。没名字给每一块不会发光的水晶定义了一个好看程度。水晶立方体在夜晚中的好看程度就是每块被光照到的水晶的好看程度之和。没名字想知道，水晶立方体在夜晚中的好看程度的最小值和最大值。", "inputFormat": "第一行是 $a$，表示水晶立方体的边长。\n接下来 $a^3$ 行，每行若干整数。\n第一个数 $g_i$ 表示第 $i$ 块水晶的好看程度。如果 $g_i=0$，代表这块水晶会发光。接下来 $3\\sim 6$ 个整数，代表与这块水晶有共同面的水晶编号。", "outputFormat": "两个整数，代表水晶立方体在夜晚好看程度的最小值与最大值。", "hint": "对于所有数据，$1<a\\leq 70$，$g_i<10^6$，$n\\leq 8$。\n", "locale": "zh-CN"}}}
{"pid": "P3343", "type": "P", "difficulty": 7, "samples": [["5 4\n1 2\n1 5\n4 3\n5 3", "0.800000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "各省省选", "浙江", "期望", "积分", "状压 DP"], "title": "[ZJOI2015] 地震后的幻想乡", "background": "", "description": "傲娇少女幽香是一个很萌很萌的妹子，而且她非常非常地有爱心，很喜欢为幻想乡的人们做一些自己力所能及的事情来帮助他们。 \n\n这不，幻想乡突然发生了地震，所有的道路都崩塌了。现在的首要任务是尽快让幻想乡的交通体系重新建立起来。幻想乡一共有 $n$ 个地方，那么最快的方法当然是修复 $n-1$ 条道路将这 $n$ 个地方都连接起来。 幻想乡这 $n$ 个地方本来是连通的，一共有 $m$ 条边。现在这 $m$ 条边由于地震的关系，全部都毁坏掉了。每条边都有一个修复它需要花费的时间，第 $i$ 条边所需要的时间为 $e_i$。地震发生以后，由于幽香是一位人生经验丰富，见得多了的长者，她根据以前的经验，知道每次地震以后，每个 $e_i$ 会是一个 $0$ 到 $1$ 之间均匀分布的随机实数。并且所有 $e_i$ 都是完全独立的。\n\n现在幽香要出发去帮忙修复道路了，她可以使用一个神奇的大魔法，能够选择需要的那 $n-1$ 条边，同时开始修复，那么修复完成的时间就是这 $n-1$ 条边的 $e_i$ 的最大值。当然幽香会先使用一个更加神奇的大魔法来观察出每条边 $e_i$ 的值，然后再选择完成时间最小的方案。 幽香在走之前，她想知道修复完成的时间的期望是多少呢？", "inputFormat": "第一行两个数 $n,m$，表示地方的数量和边的数量。其中点从 $1$ 到 $n$ 标号。\n\n接下来 $m$ 行，每行两个数 $a,b$，表示点 $a$ 和点 $b$ 之间原来有一条边。这个图不会有重边和自环。", "outputFormat": "一行输出答案，四舍五入保留 $6$ 位小数。\n", "hint": "### 样例解释\n\n对于第一个样例，由于只有四条边，幽香显然只能选择这四条，那么答案就是四条边的 $e_i$ 中最大的数的期望，由提示中的内容，可知答案为 $0.8$。\n\n### 提示 \n\n（以下内容与题意无关，对于解题也不是必要的。） \n\n对于 $n$ 个 $[0,1]$ 之间的随机变量 $x_1,x_2,...,x_n$，第 $k$ 小的那个的期望值是 $k/(n+1)$。  \n\n数据范围： \n\n对于所有数据：$n \\leq 10, \\ m \\leq n(n-1)/2, \\ n,m \\geq 1$。 \n\n对于 $15 \\%$ 的数据：$n \\leq 3$。 \n\n另有 $15 \\%$ 的数据：$n \\leq 10, m=n$。 \n\n另有 $10 \\%$ 的数据：$n \\leq 10, m=n(n-1)/2$。 \n\n另有 $20 \\%$ 的数据：$n \\leq 5$。 \n\n另有 $20 \\%$ 的数据：$n \\leq 8$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2015] Gensokyo After the Earthquake", "background": "", "description": "The tsundere girl Yuuka is very cute and very kind, and she likes to help the people of Gensokyo with what she can.\n\nAn earthquake suddenly struck Gensokyo, and all the roads collapsed. The top priority now is to reestablish the transportation network as soon as possible. There are $n$ places in total, and the fastest way is of course to repair $n-1$ roads to connect all $n$ places. Originally, these $n$ places formed a connected graph with $m$ edges. Due to the earthquake, all $m$ edges were destroyed. Each edge has a repair time; the $i$-th edge requires time $e_i$. Based on past experience, Yuuka knows that after each earthquake, every $e_i$ is an independent random real number uniformly distributed in $[0,1]$, and all $e_i$ are mutually independent.\n\nYuuka is going to help repair the roads. She can use a magical spell to select the required $n-1$ edges and start repairing them simultaneously; the completion time is then the maximum of the $e_i$ on those $n-1$ edges. Of course, Yuuka will first use an even more magical spell to observe the value of each $e_i$, and then choose the plan that minimizes the completion time. Before she leaves, she wants to know the expected value of the completion time.", "inputFormat": "The first line contains two integers $n, m$, the number of places and the number of edges. The vertices are labeled from $1$ to $n$.\n\nThe next $m$ lines each contain two integers $a, b$, indicating that there was originally an edge between vertices $a$ and $b$. The graph has no multiple edges or self-loops.", "outputFormat": "Output one line with the answer, rounded to $6$ decimal places.", "hint": "### Sample Explanation\n\nFor the first sample, since there are only four edges, Yuuka can only choose these four. The answer is the expectation of the maximum among the four $e_i$. As noted in the hint below, the answer is $0.8$.\n\n### Hint\n\n(The following content is unrelated to the problem and is not necessary for solving it.)\n\nFor $n$ random variables $x_1,x_2,\\ldots,x_n$ uniformly distributed in $[0,1]$, the expected value of the $k$-th smallest is $k/(n+1)$.\n\nConstraints:\n\nFor all testdata: $n \\leq 10$, $m \\leq n(n-1)/2$, $n, m \\geq 1$.\n\nFor $15\\%$ of the testdata: $n \\leq 3$.\n\nAdditionally, for $15\\%$ of the testdata: $n \\leq 10$, $m = n$.\n\nAdditionally, for $10\\%$ of the testdata: $n \\leq 10$, $m = n(n-1)/2$.\n\nAdditionally, for $20\\%$ of the testdata: $n \\leq 5$.\n\nAdditionally, for $20\\%$ of the testdata: $n \\leq 8$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2015] 地震后的幻想乡", "background": "", "description": "傲娇少女幽香是一个很萌很萌的妹子，而且她非常非常地有爱心，很喜欢为幻想乡的人们做一些自己力所能及的事情来帮助他们。 \n\n这不，幻想乡突然发生了地震，所有的道路都崩塌了。现在的首要任务是尽快让幻想乡的交通体系重新建立起来。幻想乡一共有 $n$ 个地方，那么最快的方法当然是修复 $n-1$ 条道路将这 $n$ 个地方都连接起来。 幻想乡这 $n$ 个地方本来是连通的，一共有 $m$ 条边。现在这 $m$ 条边由于地震的关系，全部都毁坏掉了。每条边都有一个修复它需要花费的时间，第 $i$ 条边所需要的时间为 $e_i$。地震发生以后，由于幽香是一位人生经验丰富，见得多了的长者，她根据以前的经验，知道每次地震以后，每个 $e_i$ 会是一个 $0$ 到 $1$ 之间均匀分布的随机实数。并且所有 $e_i$ 都是完全独立的。\n\n现在幽香要出发去帮忙修复道路了，她可以使用一个神奇的大魔法，能够选择需要的那 $n-1$ 条边，同时开始修复，那么修复完成的时间就是这 $n-1$ 条边的 $e_i$ 的最大值。当然幽香会先使用一个更加神奇的大魔法来观察出每条边 $e_i$ 的值，然后再选择完成时间最小的方案。 幽香在走之前，她想知道修复完成的时间的期望是多少呢？", "inputFormat": "第一行两个数 $n,m$，表示地方的数量和边的数量。其中点从 $1$ 到 $n$ 标号。\n\n接下来 $m$ 行，每行两个数 $a,b$，表示点 $a$ 和点 $b$ 之间原来有一条边。这个图不会有重边和自环。", "outputFormat": "一行输出答案，四舍五入保留 $6$ 位小数。\n", "hint": "### 样例解释\n\n对于第一个样例，由于只有四条边，幽香显然只能选择这四条，那么答案就是四条边的 $e_i$ 中最大的数的期望，由提示中的内容，可知答案为 $0.8$。\n\n### 提示 \n\n（以下内容与题意无关，对于解题也不是必要的。） \n\n对于 $n$ 个 $[0,1]$ 之间的随机变量 $x_1,x_2,...,x_n$，第 $k$ 小的那个的期望值是 $k/(n+1)$。  \n\n数据范围： \n\n对于所有数据：$n \\leq 10, \\ m \\leq n(n-1)/2, \\ n,m \\geq 1$。 \n\n对于 $15 \\%$ 的数据：$n \\leq 3$。 \n\n另有 $15 \\%$ 的数据：$n \\leq 10, m=n$。 \n\n另有 $10 \\%$ 的数据：$n \\leq 10, m=n(n-1)/2$。 \n\n另有 $20 \\%$ 的数据：$n \\leq 5$。 \n\n另有 $20 \\%$ 的数据：$n \\leq 8$。", "locale": "zh-CN"}}}
{"pid": "P3344", "type": "P", "difficulty": 6, "samples": [["10 10 10000\n6743 2963\n3505 1986\n3565 7235\n1735 5522\n16877 5597\n11621 6\n3100 8243\n1750 6173\n5709 7671\n7915 3915\n14339 -438 3075\n4278 15210 8371\n13996 19000 6750\n17049 -4969 7788\n737 16339 2934\n904 14023 2322\n8982 14759 4311\n13102 11458 5554\n4135 12183 576\n5087 -2459 6787", "10\n10438"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2015", "各省省选", "浙江", "分治"], "title": "[ZJOI2015] 幻想乡 Wi-Fi 搭建计划", "background": "", "description": "傲娇少女幽香是一个很萌很萌的妹子。随着科技的进步，幻想乡的大家也开始使用手机了。这时幽香发现没人来她的太阳花田玩了，她感到很伤心，于是向别人打听了一下，才知道原来大家都嫌弃这里没有 Wi-Fi，手机上网还需要流量。\n\n怎么办呢？幽香决定赶快搭建几个 Wi-Fi 点，让所有人都能在太阳花田里畅快地上网。\n\n我们可以近似地把太阳花田看成一个 $y$ 轴在 $[0,R]$ 之间，$x$ 坐标在 $(-\\infty,+\\infty)$（也就是在 $x$ 轴上无限延伸）的无限长方形。\n\n太阳花田里面有 $n$ 个景点，是游客们经常光顾的，幽香认为只要让这些景点尽量被 Wi-Fi 覆盖，那么游客们就肯定心满意足了。\n\n八云紫表示她可以帮幽香架设 Wi-Fi 路由器。现在通用的路由器，每个的覆盖半径正好也是 $R$。八云紫扫视了一遍地图，发现在太阳花田外面，只有 $m$ 个有网络的地点，她只可以在那里架设路由器。如果你在点 $p$ 搭建了路由器，那么位于 $q$ 的地点，只要 $p$ 和 $q$ 的欧几里得距离小于等于 $R$，$q$ 点就会被 Wi-Fi 覆盖。\n\n同时八云紫表示，架设难度随着地点的不同而不同，所以收费也不一样，在第 $i$ 个位置架设需要 $c_i$ 的钱。\n\n现在幽香想要覆盖尽量多的景点，在这个前提下，幽香也想要尽量节省钱。你能帮助她吗？", "inputFormat": "输入第一行三个整数 $n,m,R$，分别表示景点的数量，网络架设地点的数量和太阳花田的宽度。\n\n接下来 $n$ 行，每行两个整数 $x,y$，满足 $|x|\\le 10^8,0\\le y\\le R$，表示一个景点。两个景点的位置不会重合。\n\n接下来 $m$ 行，每行三个整数 $x,y,c$，满足 $|x|\\le 10^9$，$-10^8\\lt y\\lt 0$ 或者 $R\\lt y\\lt 10^8$，表示一个网络架设点的位置和花费。两个网络架设点不会重合。", "outputFormat": "输出第一行表示最多覆盖的景点数。\n\n第二行表示在覆盖景点数最多的前提下，最少的花费。", "hint": "- 对于 $10\\%$ 的数据，$n,m\\le 20$；\n- 对于另 $30\\%$ 的数据，$n,m\\le 100$，所有网络架设点的 $y$ 坐标都大于 $R$；\n- 对于另 $60\\%$ 的数据，$n,m\\le 100$。\n\n对于全部数据，$1\\le R\\le 10^8,0\\le c\\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2015] Gensokyo Wi-Fi Deployment Plan", "background": "", "description": "The tsundere girl Yuuka is a very cute girl. As technology advances, everyone in Gensokyo has started using mobile phones. Yuuka noticed that no one comes to her sunflower field anymore. Feeling sad, she asked around and learned that everyone dislikes the lack of Wi-Fi there, and mobile data is required to access the Internet.\n\nWhat should she do? Yuuka decides to quickly deploy several Wi-Fi hotspots so that everyone can surf the Internet freely in the sunflower field.\n\nWe can approximate the sunflower field as an infinitely long rectangle with the $y$ coordinate in $[0, R]$ and the $x$ coordinate in $(-\\infty, +\\infty)$ (i.e., extending infinitely along the $x$-axis).\n\nThere are $n$ scenic spots inside the sunflower field that tourists often visit. Yuuka thinks that as long as these spots are covered by Wi-Fi as much as possible, the visitors will be satisfied.\n\nYukari Yakumo says she can help Yuuka set up Wi-Fi routers. Each standard router has a coverage radius of exactly $R$. After surveying the map, Yukari finds that outside the sunflower field there are only $m$ locations with network access, and she can only install routers there. If you install a router at point $p$, then any location $q$ with Euclidean distance between $p$ and $q$ less than or equal to $R$ will be covered by Wi-Fi.\n\nAt the same time, Yukari says that installation difficulty varies by location, so the fee also differs. Installing at the $i$-th location costs $c_i$.\n\nNow Yuuka wants to cover as many scenic spots as possible. Under this condition, she also wants to minimize the total cost. Can you help her?", "inputFormat": "The first line contains three integers $n, m, R$, representing the number of scenic spots, the number of network installation locations, and the width of the sunflower field.\n\nThe next $n$ lines each contain two integers $x, y$, satisfying $|x| \\le 10^8, 0 \\le y \\le R$, describing a scenic spot. No two scenic spots share the same position.\n\nThe next $m$ lines each contain three integers $x, y, c$, satisfying $|x| \\le 10^9$, $-10^8 \\lt y \\lt 0$ or $R \\lt y \\lt 10^8$, describing a network installation location and its cost. No two network installation locations share the same position.", "outputFormat": "The first line outputs the maximum number of scenic spots that can be covered.\n\nThe second line outputs the minimum total cost under the condition that the number of covered scenic spots is maximized.", "hint": "- For $10\\%$ of the testdata, $n, m \\le 20$.\n- For another $30\\%$ of the testdata, $n, m \\le 100$, and all installation locations have $y$-coordinates greater than $R$.\n- For another $60\\%$ of the testdata, $n, m \\le 100$.\n\nFor all testdata, $1 \\le R \\le 10^8$, $0 \\le c \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2015] 幻想乡 Wi-Fi 搭建计划", "background": "", "description": "傲娇少女幽香是一个很萌很萌的妹子。随着科技的进步，幻想乡的大家也开始使用手机了。这时幽香发现没人来她的太阳花田玩了，她感到很伤心，于是向别人打听了一下，才知道原来大家都嫌弃这里没有 Wi-Fi，手机上网还需要流量。\n\n怎么办呢？幽香决定赶快搭建几个 Wi-Fi 点，让所有人都能在太阳花田里畅快地上网。\n\n我们可以近似地把太阳花田看成一个 $y$ 轴在 $[0,R]$ 之间，$x$ 坐标在 $(-\\infty,+\\infty)$（也就是在 $x$ 轴上无限延伸）的无限长方形。\n\n太阳花田里面有 $n$ 个景点，是游客们经常光顾的，幽香认为只要让这些景点尽量被 Wi-Fi 覆盖，那么游客们就肯定心满意足了。\n\n八云紫表示她可以帮幽香架设 Wi-Fi 路由器。现在通用的路由器，每个的覆盖半径正好也是 $R$。八云紫扫视了一遍地图，发现在太阳花田外面，只有 $m$ 个有网络的地点，她只可以在那里架设路由器。如果你在点 $p$ 搭建了路由器，那么位于 $q$ 的地点，只要 $p$ 和 $q$ 的欧几里得距离小于等于 $R$，$q$ 点就会被 Wi-Fi 覆盖。\n\n同时八云紫表示，架设难度随着地点的不同而不同，所以收费也不一样，在第 $i$ 个位置架设需要 $c_i$ 的钱。\n\n现在幽香想要覆盖尽量多的景点，在这个前提下，幽香也想要尽量节省钱。你能帮助她吗？", "inputFormat": "输入第一行三个整数 $n,m,R$，分别表示景点的数量，网络架设地点的数量和太阳花田的宽度。\n\n接下来 $n$ 行，每行两个整数 $x,y$，满足 $|x|\\le 10^8,0\\le y\\le R$，表示一个景点。两个景点的位置不会重合。\n\n接下来 $m$ 行，每行三个整数 $x,y,c$，满足 $|x|\\le 10^9$，$-10^8\\lt y\\lt 0$ 或者 $R\\lt y\\lt 10^8$，表示一个网络架设点的位置和花费。两个网络架设点不会重合。", "outputFormat": "输出第一行表示最多覆盖的景点数。\n\n第二行表示在覆盖景点数最多的前提下，最少的花费。", "hint": "- 对于 $10\\%$ 的数据，$n,m\\le 20$；\n- 对于另 $30\\%$ 的数据，$n,m\\le 100$，所有网络架设点的 $y$ 坐标都大于 $R$；\n- 对于另 $60\\%$ 的数据，$n,m\\le 100$。\n\n对于全部数据，$1\\le R\\le 10^8,0\\le c\\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P3345", "type": "P", "difficulty": 6, "samples": [["10 5\n1 2 1\n2 3 1\n2 4 1\n1 5 1\n2 6 1\n2 7 1\n5 8 1\n7 9 1\n1 10 1\n3 1\n2 1\n8 1\n3 1\n4 1", "0\n1\n4\n5\n6"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2015", "线段树", "各省省选", "点分治", "浙江"], "title": "[ZJOI2015] 幻想乡战略游戏", "background": "", "description": "傲娇少女幽香正在玩一个非常有趣的战略类游戏，本来这个游戏的地图其实还不算太大，幽香还能管得过来，但是不知道为什么现在的网游厂商把游戏的地图越做越大，以至于幽香一眼根本看不过来，更别说和别人打仗了。\n\n在打仗之前，幽香现在面临一个非常基本的管理问题需要解决。\n\n整个地图是一个树结构，一共有 $n$ 块空地，这些空地被 $n-1$ 条带权边连接起来，使得每两个点之间有一条唯一的路径将它们连接起来。\n\n在游戏中，幽香可能在空地上增加或者减少一些军队。同时，幽香可以在一个空地上放置一个补给站。如果补给站在点 $u$ 上，并且空地 $v$ 上有 $d_v$ 个单位的军队，那么幽香每天就要花费 $d_v \\times \\text{dist}(u,v)$ 的金钱来补给这些军队。由于幽香需要补给所有的军队，因此幽香总共就要花费为 $\\sum (d_v \\times \\text{dist}(u,v))$（其中 $1 \\leq v \\leq N$）的代价，$\\text{dist}(u,v)$ 表示 $u$ 和 $v$ 在树上的距离（唯一路径的权和）。\n\n因为游戏的规定，幽香只能选择一个空地作为补给站。在游戏的过程中，幽香可能会在某些空地上制造一些军队，也可能会减少某些空地上的军队，进行了这样的操作以后，出于经济上的考虑，幽香往往可以移动他的补给站从而省一些钱。但是由于这个游戏的地图是在太大了，幽香无法轻易的进行最优的安排，你能帮帮她吗？\n\n你可以假定一开始所有空地上都没有军队。", "inputFormat": "第一行两个数 $n$ 和 $Q$ 分别表示树的点数和幽香操作的个数，其中点从 $1$ 到 $n$ 标号。\n\n接下来 $n-1$ 行，每行三个正整数 $a,b,c$，表示 $a$ 和 $b$ 之间有一条边权为 $c$ 的边。\n\n接下来 $Q$ 行，每行两个数 $u,e$，表示幽香在点 $u$ 上放了 $e$ 单位个军队（如果 $e<0$，就相当于是幽香在 $u$ 上减少了 $|e|$ 单位个军队，说白了就是 $d_u←d_u+e$）。\n\n数据保证任何时刻每个点上的军队数量都是非负的。", "outputFormat": "对于幽香的每个操作，输出操作完成以后，每天的最小花费，也即如果幽香选择最优的补给点进行补给时的花费。\n", "hint": "对于所有数据，$1\\le c\\le 10^3$，$0\\le |e| \\le 10^3$，$1\\le n\\le10^5$，$ 1\\le Q\\le10^5$ 。\n\n非常神奇的是，对于所有数据，这棵树上的点的度数都不超过 $20$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2015] Gensokyo Strategy Game", "background": "", "description": "The tsundere girl Yuuka is playing a very interesting strategy game. At first, the game map was not too large, and Yuuka could still manage it. But for some reason, the online game developers are making the map larger and larger, to the point that Yuuka can no longer take it all in at a glance, let alone fight others.\n\nBefore going to war, Yuuka needs to solve a very basic management problem.\n\nThe entire map is a tree with $n$ empty fields (nodes), connected by $n - 1$ weighted edges, so that there is a unique path between any two nodes.\n\nIn the game, Yuuka may increase or decrease troops on empty fields. At the same time, she can place one supply station on a node. If the supply station is at node $u$, and there are $d_v$ units of troops at node $v$, then Yuuka must spend $d_v \\times \\text{dist}(u,v)$ money per day to supply these troops. Since Yuuka needs to supply all troops, the total cost is $\\sum (d_v \\times \\text{dist}(u,v))$ (where $1 \\le v \\le n$). Here, $\\text{dist}(u,v)$ denotes the distance between $u$ and $v$ on the tree (the sum of weights along the unique path).\n\nDue to the game rules, Yuuka can choose only one node as the supply station. During the game, she may create troops on some nodes or reduce troops on some nodes. After such operations, for economic reasons, she may move the supply station to save money. However, since the map is just too large, Yuuka cannot easily make the optimal arrangement. Can you help her?\n\nYou may assume that initially all nodes have no troops.", "inputFormat": "The first line contains two integers $n$ and $Q$, denoting the number of nodes in the tree and the number of Yuuka’s operations, respectively. Nodes are labeled from $1$ to $n$.\n\nThe next $n - 1$ lines each contain three positive integers $a, b, c$, indicating that there is an edge between $a$ and $b$ with weight $c$.\n\nThe next $Q$ lines each contain two integers $u, e$, meaning Yuuka adds $e$ units of troops at node $u$ (if $e < 0$, that means Yuuka removes $|e|$ units at $u$; in other words, $d_u \\leftarrow d_u + e$).\n\nIt is guaranteed that at any time, the number of troops at each node is non-negative.", "outputFormat": "For each of Yuuka’s operations, output the minimal daily cost after the operation, i.e., the cost if Yuuka chooses the optimal supply station.", "hint": "For all testdata, $1 \\le c \\le 10^3$, $0 \\le |e| \\le 10^3$, $1 \\le n \\le 10^5$, $1 \\le Q \\le 10^5$.\n\nInterestingly, for all testdata, the degree of each node in the tree does not exceed $20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2015] 幻想乡战略游戏", "background": "", "description": "傲娇少女幽香正在玩一个非常有趣的战略类游戏，本来这个游戏的地图其实还不算太大，幽香还能管得过来，但是不知道为什么现在的网游厂商把游戏的地图越做越大，以至于幽香一眼根本看不过来，更别说和别人打仗了。\n\n在打仗之前，幽香现在面临一个非常基本的管理问题需要解决。\n\n整个地图是一个树结构，一共有 $n$ 块空地，这些空地被 $n-1$ 条带权边连接起来，使得每两个点之间有一条唯一的路径将它们连接起来。\n\n在游戏中，幽香可能在空地上增加或者减少一些军队。同时，幽香可以在一个空地上放置一个补给站。如果补给站在点 $u$ 上，并且空地 $v$ 上有 $d_v$ 个单位的军队，那么幽香每天就要花费 $d_v \\times \\text{dist}(u,v)$ 的金钱来补给这些军队。由于幽香需要补给所有的军队，因此幽香总共就要花费为 $\\sum (d_v \\times \\text{dist}(u,v))$（其中 $1 \\leq v \\leq N$）的代价，$\\text{dist}(u,v)$ 表示 $u$ 和 $v$ 在树上的距离（唯一路径的权和）。\n\n因为游戏的规定，幽香只能选择一个空地作为补给站。在游戏的过程中，幽香可能会在某些空地上制造一些军队，也可能会减少某些空地上的军队，进行了这样的操作以后，出于经济上的考虑，幽香往往可以移动他的补给站从而省一些钱。但是由于这个游戏的地图是在太大了，幽香无法轻易的进行最优的安排，你能帮帮她吗？\n\n你可以假定一开始所有空地上都没有军队。", "inputFormat": "第一行两个数 $n$ 和 $Q$ 分别表示树的点数和幽香操作的个数，其中点从 $1$ 到 $n$ 标号。\n\n接下来 $n-1$ 行，每行三个正整数 $a,b,c$，表示 $a$ 和 $b$ 之间有一条边权为 $c$ 的边。\n\n接下来 $Q$ 行，每行两个数 $u,e$，表示幽香在点 $u$ 上放了 $e$ 单位个军队（如果 $e<0$，就相当于是幽香在 $u$ 上减少了 $|e|$ 单位个军队，说白了就是 $d_u←d_u+e$）。\n\n数据保证任何时刻每个点上的军队数量都是非负的。", "outputFormat": "对于幽香的每个操作，输出操作完成以后，每天的最小花费，也即如果幽香选择最优的补给点进行补给时的花费。\n", "hint": "对于所有数据，$1\\le c\\le 10^3$，$0\\le |e| \\le 10^3$，$1\\le n\\le10^5$，$ 1\\le Q\\le10^5$ 。\n\n非常神奇的是，对于所有数据，这棵树上的点的度数都不超过 $20$。", "locale": "zh-CN"}}}
{"pid": "P3346", "type": "P", "difficulty": 6, "samples": [["7 3\n0 2 1 2 1 0 0\n1 2\n3 4\n3 5\n4 6\n5 7\n2 5", "30"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["字符串", "2015", "各省省选", "浙江", "后缀自动机 SAM", "O2优化"], "title": "[ZJOI2015] 诸神眷顾的幻想乡", "background": null, "description": "幽香是全幻想乡里最受人欢迎的萌妹子，这天，是幽香的 $2600$ 岁生日，无数幽香的粉丝到了幽香家门前的太阳花田上来为幽香庆祝生日。\n\n粉丝们非常热情，自发组织表演了一系列节目给幽香看。幽香当然也非常高兴啦。\n\n这时幽香发现了一件非常有趣的事情，太阳花田有 $n$ 块空地。\n\n在过去，幽香为了方便，在这 $n$ 块空地之间修建了 $n-1$ 条边将它们连通起来。\n\n也就是说，这 $n$ 块空地形成了一个树的结构。\n\n有 $n$ 个粉丝来到了太阳花田上。\n\n为了表达对幽香生日的祝贺，他们选择了 $c$ 种颜色的衣服，每种颜色恰好可以用一个 $0$ 到 $c-1$ 之间的整数来表示。\n\n并且每个人都站在一个空地上，每个空地上也只有一个人。\n\n这样，整个太阳花田就花花绿绿了。幽香看到了，感觉也非常开心。\n\n粉丝们策划的一个节目是这样的，选中两个粉丝 $A$ 和 $B$（$A$ 和 $B$ 可以相同），然后 $A$ 所在的空地到 $B$ 所在的空地的路径上的粉丝依次跳起来（包括端点）。\n\n这样幽香就能看到一个长度为 $A$ 到 $B$ 之间路径上的所有粉丝的数目（包括 $A$ 和 $B$）的颜色序列。\n\n一开始大家打算让任意两个粉丝（注意：$A,B$ 和 $B,A$ 是不同的，他们形成的序列刚好相反）都来一次。\n\n但是有人指出这样可能会出现一些一模一样的颜色序列，会导致审美疲劳。\n\n于是他们想问，在这个树上，一共有多少可能的不同的颜色序列幽香可以看到呢？\n\n由于太阳花田的结构比较特殊，只与一个空地相邻的空地数量不超过 $20$ 个。", "inputFormat": "第一行两个正整数 $n,c$，表示空地数量和颜色数量。\n\n第二行有 $n$ 个 $0$ 到 $c-1$ 之间，由空格隔开的整数，依次表示第 $i$ 块空地上的粉丝的衣服颜色。\n\n接下来 $n-1$ 行，每行两个正整数 $u,v$，表示有一条连接空地 $u$ 和空地 $v$ 的边。", "outputFormat": "一行，输出一个整数，表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $15\\%$ 的数据，$n\\le2\\times 10^3$。\n- 另有 $5\\%$ 的数据，所有空地都至多与两个空地相邻。\n- 另有 $5\\%$ 的数据，除一块空地与三个空地相邻外，其他空地都分别至多与两个空地相邻。\n- 另有 $5\\%$ 的数据，除某两块空地与三个空地相邻外，其他空地都分别至多与两个空地相邻。\n- 对于 $100\\%$ 的数据，$1\\le n\\le10^5$，$1\\le c\\le10$，$1 \\leq u, v \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2015] The Fantasy Land Favored by the Gods", "background": "", "description": "Yuuka is the most popular cute girl in all of Gensokyo. Today is her $2600$-th birthday, and countless fans have come to the sunflower field in front of her house to celebrate.\n\nThe fans are very enthusiastic and spontaneously organized a series of performances for Yuuka. Of course, Yuuka is very happy.\n\nAt this moment, Yuuka notices something interesting: the sunflower field has $n$ empty plots.\n\nIn the past, for convenience, Yuuka built $n-1$ edges among these $n$ plots to connect them.\n\nThat is, these $n$ plots form a tree.\n\nThere are $n$ fans who have come to the sunflower field.\n\nTo express their congratulations for Yuuka’s birthday, they chose $c$ colors of clothing, and each color is represented by an integer between $0$ and $c-1$.\n\nEach person stands on exactly one plot, and each plot has exactly one person.\n\nThus, the entire sunflower field becomes colorful. Yuuka sees this and feels very happy.\n\nOne of the planned performances is as follows: select two fans A and B (A and B can be the same), then the fans on the path from A’s plot to B’s plot jump in order (including the endpoints).\n\nIn this way, Yuuka can see a color sequence whose length is the number of fans on the path between A and B (including A and B).\n\nAt first, everyone planned to try all pairs of fans. Note: A, B and B, A are different; the sequences they form are exactly reversed.\n\nHowever, someone pointed out that this might lead to some identical color sequences, causing aesthetic fatigue.\n\nSo they want to ask: on this tree, how many different color sequences can Yuuka possibly see in total?\n\nDue to the special structure of the sunflower field, the number of plots that are adjacent to exactly one plot does not exceed $20$.", "inputFormat": "The first line contains two positive integers $n, c$, denoting the number of plots and the number of colors.\n\nThe second line contains $n$ integers between $0$ and $c-1$, separated by spaces, where the $i$-th integer is the clothing color of the fan on the $i$-th plot.\n\nThe next $n-1$ lines each contain two positive integers $u, v$, indicating that there is an edge connecting plot $u$ and plot $v$.", "outputFormat": "Output a single line with one integer, denoting the answer.", "hint": "Constraints\n\n- For $15\\%$ of the testdata, $n \\le 2 \\times 10^3$.\n- For another $5\\%$ of the testdata, every plot is adjacent to at most two plots.\n- For another $5\\%$ of the testdata, except for one plot that is adjacent to three plots, every other plot is adjacent to at most two plots.\n- For another $5\\%$ of the testdata, except for two plots that are adjacent to three plots, every other plot is adjacent to at most two plots.\n- For $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $1 \\le c \\le 10$, $1 \\le u, v \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2015] 诸神眷顾的幻想乡", "background": null, "description": "幽香是全幻想乡里最受人欢迎的萌妹子，这天，是幽香的 $2600$ 岁生日，无数幽香的粉丝到了幽香家门前的太阳花田上来为幽香庆祝生日。\n\n粉丝们非常热情，自发组织表演了一系列节目给幽香看。幽香当然也非常高兴啦。\n\n这时幽香发现了一件非常有趣的事情，太阳花田有 $n$ 块空地。\n\n在过去，幽香为了方便，在这 $n$ 块空地之间修建了 $n-1$ 条边将它们连通起来。\n\n也就是说，这 $n$ 块空地形成了一个树的结构。\n\n有 $n$ 个粉丝来到了太阳花田上。\n\n为了表达对幽香生日的祝贺，他们选择了 $c$ 种颜色的衣服，每种颜色恰好可以用一个 $0$ 到 $c-1$ 之间的整数来表示。\n\n并且每个人都站在一个空地上，每个空地上也只有一个人。\n\n这样，整个太阳花田就花花绿绿了。幽香看到了，感觉也非常开心。\n\n粉丝们策划的一个节目是这样的，选中两个粉丝 $A$ 和 $B$（$A$ 和 $B$ 可以相同），然后 $A$ 所在的空地到 $B$ 所在的空地的路径上的粉丝依次跳起来（包括端点）。\n\n这样幽香就能看到一个长度为 $A$ 到 $B$ 之间路径上的所有粉丝的数目（包括 $A$ 和 $B$）的颜色序列。\n\n一开始大家打算让任意两个粉丝（注意：$A,B$ 和 $B,A$ 是不同的，他们形成的序列刚好相反）都来一次。\n\n但是有人指出这样可能会出现一些一模一样的颜色序列，会导致审美疲劳。\n\n于是他们想问，在这个树上，一共有多少可能的不同的颜色序列幽香可以看到呢？\n\n由于太阳花田的结构比较特殊，只与一个空地相邻的空地数量不超过 $20$ 个。", "inputFormat": "第一行两个正整数 $n,c$，表示空地数量和颜色数量。\n\n第二行有 $n$ 个 $0$ 到 $c-1$ 之间，由空格隔开的整数，依次表示第 $i$ 块空地上的粉丝的衣服颜色。\n\n接下来 $n-1$ 行，每行两个正整数 $u,v$，表示有一条连接空地 $u$ 和空地 $v$ 的边。", "outputFormat": "一行，输出一个整数，表示答案。", "hint": "#### 数据规模与约定\n\n- 对于 $15\\%$ 的数据，$n\\le2\\times 10^3$。\n- 另有 $5\\%$ 的数据，所有空地都至多与两个空地相邻。\n- 另有 $5\\%$ 的数据，除一块空地与三个空地相邻外，其他空地都分别至多与两个空地相邻。\n- 另有 $5\\%$ 的数据，除某两块空地与三个空地相邻外，其他空地都分别至多与两个空地相邻。\n- 对于 $100\\%$ 的数据，$1\\le n\\le10^5$，$1\\le c\\le10$，$1 \\leq u, v \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P3347", "type": "P", "difficulty": 7, "samples": [["10 10\n0 2 3\n2 3 2\n3 1 3\n1 2 1\n1 0 1\n1 1 0\n3 3 0\n1 2 2\n3 1 1\n3 1 0\n3 1 2 2 3 1 1 2 2 0\n0 0 0 0 0 0 0 1 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 0 0 0 0 0\n0 0 0 1 0 0 0 0 0 0\n1 0 0 0 1 0 0 0 0 0\n1 0 1 0 0 0 0 1 1 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 1 0 0 0 1 0 0 0\n0 0 0 0 0 1 0 0 1 0", "8\n42/1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "二分", "各省省选", "网络流", "浙江"], "title": "[ZJOI2015] 醉熏熏的幻想乡", "background": null, "description": "傲娇少女幽香是一个很萌很萌的妹子，这些天幻想乡的大家都不知道为何还是拼命喝酒。很快酒就供不应求了，为了满足大家的需求，幽香决定在森林里酿酒。\n\n经过调查，幽香发现森林里面有一些地方非常适合酿酒，有一些地方则非常适合存酒。幽香把这些适合酿酒的地方称为酿酒点，不妨认为有 $n$ 个酿酒点，从 $1$ 到 $n$ 标号。同时也有 $m$ 个适合存酒的地方，幽香将它们称为存酒点，从 $1$ 到 $m$ 标号。在一些酿酒点和存酒点之间存在通道，如果酿酒点 $i$ 到存酒点 $j$ 之间存在通道，那么 $i$ 生产的酒就可以被运输到 $j$。\n\n但是在一个地方酿酒是需要消耗幽香的魔力的，由于存在管理上的因素，在酿酒点 $i$，制造 $x$ 升的酒，需要花费 $a_i\\cdot x^2+b_i\\cdot x$ 的魔力，注意 $x$ 不一定是一个非负整数，也可以是一个非负实数，同时在这个点最多只能制造 $c_i$ 升的酒。每个存酒点 $j$ 有一个容量 $d_j$，表示这个存酒点最多能存多少升的酒。\n\n幽香打算存尽量多的酒，那么她需要在一些酿酒点生产一些酒并且通过通道将酒运送到存酒点。当然幽香想要节省自己的魔力，所以想让你帮忙算出在满足要求的情况下，最少花费的魔力是多少？", "inputFormat": "第一行两个正整数 $n$，$m$，表示酿酒点和存酒点的数量。接下来 $n$ 行，第 $i$ 行三个数 $a_i$，$b_i$，$c_i$，表示在酿酒点 $i$ 制造酒的花费系数和上限。接下来一行 $m$ 个整数，一次为每个存酒点的 $d_i$ 值。接下来 $n$ 行，每行 $m$ 个数，其中第 $i$ 行第 $j$ 个表示酿酒点 $i$ 到存酒点 $j$ 有没有通道（$1$ 表示有，$0$ 表示没有）。", "outputFormat": "输出第一行表示幽香最多能存多少升酒（注意这肯定是个整数，直接输出即可）。\n\n输出第二行表示最小花费魔力，注意这肯定是一个有理数，化简后按照 $a/b$ 的形式输出（$0$输出 $0/1$）", "hint": "对于 $30\\%$ 的数据：所有 $a_i=0$。\n\n对于另 $30\\%$ 的数据：最终答案的分母 $\\leq 1000$。\n\n对于 $100\\%$ 的数据：$1\\leq n\\leq100$，$1\\leq m\\leq100$。\n\n对于所有数据，$0\\leq a_i,b_i,c_i,d_i\\leq3$ 且都是整数。同时对于每个 $i$，$a_i+b_i>0$ 的通道的数量不超过 $1000$ 条。\n\n非常神奇的是，对于所有数据存在一个正整数 $X\\leq10^7$，使得存在一个最优解，使得所有路径上运送的酒的体积都是 $1/X$ 的倍数。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2015] Tipsy Gensokyo", "background": "", "description": "The tsundere girl Yuuka is a very cute girl. Recently, for some reason, everyone in Gensokyo has been drinking like crazy. Soon the supply of alcohol cannot keep up with demand. To meet everyone’s needs, Yuuka decides to brew alcohol in the forest.\n\nAfter investigation, Yuuka finds that some places in the forest are very suitable for brewing, while others are very suitable for storage. She calls the places suitable for brewing the brewing sites. Assume there are $n$ brewing sites, numbered from $1$ to $n$. There are also $m$ storage sites, numbered from $1$ to $m$. There are channels between some brewing sites and storage sites. If there is a channel between brewing site $i$ and storage site $j$, then the alcohol produced at $i$ can be transported to $j$.\n\nBrewing at a site consumes Yuuka’s magic. Due to management factors, at brewing site $i$, producing $x$ liters of alcohol costs $a_i \\cdot x^2 + b_i \\cdot x$ magic. Note that $x$ does not have to be a nonnegative integer; it can be any nonnegative real number. Also, at this site at most $c_i$ liters can be produced. Each storage site $j$ has a capacity $d_j$, meaning this storage site can store at most $d_j$ liters of alcohol.\n\nYuuka plans to store as much alcohol as possible, so she will produce some alcohol at certain brewing sites and transport it through the channels to the storage sites. Of course, Yuuka wants to save her magic, so please help her compute, under the requirement of storing the maximum possible amount, what the minimum magic cost is.", "inputFormat": "The first line contains two positive integers $n$, $m$, the numbers of brewing sites and storage sites. The next $n$ lines, on the $i$-th line are three numbers $a_i$, $b_i$, $c_i$, representing the cost coefficients and the production upper bound at brewing site $i$. The next line contains $m$ integers, which are the values $d_j$ for each storage site in order. Then there are $n$ lines, each containing $m$ numbers. On the $i$-th line, the $j$-th number indicates whether there is a channel from brewing site $i$ to storage site $j$ ($1$ means there is, $0$ means there is not).", "outputFormat": "Output the first line as the maximum total liters of alcohol Yuuka can store (note that this is always an integer; just output the integer).\n\nOutput the second line as the minimum magic cost. This is always a rational number; after reduction, output it in the form $a/b$ (if it is $0$, output $0/1$).", "hint": "- For $30\\%$ of the testdata: all $a_i = 0$.\n- For another $30\\%$ of the testdata: the denominator of the final answer is $\\leq 1000$.\n- For $100\\%$ of the testdata: $1 \\leq n \\leq 100$, $1 \\leq m \\leq 100$.\n- For all testdata, $0 \\leq a_i, b_i, c_i, d_i \\leq 3$ and all are integers. Also, for each $i$, the number of channels with $a_i + b_i > 0$ does not exceed $1000$.\n- Interestingly, for all testdata there exists a positive integer $X \\leq 10^7$ such that there is an optimal solution where the amount transported on every path is a multiple of $1/X$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2015] 醉熏熏的幻想乡", "background": null, "description": "傲娇少女幽香是一个很萌很萌的妹子，这些天幻想乡的大家都不知道为何还是拼命喝酒。很快酒就供不应求了，为了满足大家的需求，幽香决定在森林里酿酒。\n\n经过调查，幽香发现森林里面有一些地方非常适合酿酒，有一些地方则非常适合存酒。幽香把这些适合酿酒的地方称为酿酒点，不妨认为有 $n$ 个酿酒点，从 $1$ 到 $n$ 标号。同时也有 $m$ 个适合存酒的地方，幽香将它们称为存酒点，从 $1$ 到 $m$ 标号。在一些酿酒点和存酒点之间存在通道，如果酿酒点 $i$ 到存酒点 $j$ 之间存在通道，那么 $i$ 生产的酒就可以被运输到 $j$。\n\n但是在一个地方酿酒是需要消耗幽香的魔力的，由于存在管理上的因素，在酿酒点 $i$，制造 $x$ 升的酒，需要花费 $a_i\\cdot x^2+b_i\\cdot x$ 的魔力，注意 $x$ 不一定是一个非负整数，也可以是一个非负实数，同时在这个点最多只能制造 $c_i$ 升的酒。每个存酒点 $j$ 有一个容量 $d_j$，表示这个存酒点最多能存多少升的酒。\n\n幽香打算存尽量多的酒，那么她需要在一些酿酒点生产一些酒并且通过通道将酒运送到存酒点。当然幽香想要节省自己的魔力，所以想让你帮忙算出在满足要求的情况下，最少花费的魔力是多少？", "inputFormat": "第一行两个正整数 $n$，$m$，表示酿酒点和存酒点的数量。接下来 $n$ 行，第 $i$ 行三个数 $a_i$，$b_i$，$c_i$，表示在酿酒点 $i$ 制造酒的花费系数和上限。接下来一行 $m$ 个整数，一次为每个存酒点的 $d_i$ 值。接下来 $n$ 行，每行 $m$ 个数，其中第 $i$ 行第 $j$ 个表示酿酒点 $i$ 到存酒点 $j$ 有没有通道（$1$ 表示有，$0$ 表示没有）。", "outputFormat": "输出第一行表示幽香最多能存多少升酒（注意这肯定是个整数，直接输出即可）。\n\n输出第二行表示最小花费魔力，注意这肯定是一个有理数，化简后按照 $a/b$ 的形式输出（$0$输出 $0/1$）", "hint": "对于 $30\\%$ 的数据：所有 $a_i=0$。\n\n对于另 $30\\%$ 的数据：最终答案的分母 $\\leq 1000$。\n\n对于 $100\\%$ 的数据：$1\\leq n\\leq100$，$1\\leq m\\leq100$。\n\n对于所有数据，$0\\leq a_i,b_i,c_i,d_i\\leq3$ 且都是整数。同时对于每个 $i$，$a_i+b_i>0$ 的通道的数量不超过 $1000$ 条。\n\n非常神奇的是，对于所有数据存在一个正整数 $X\\leq10^7$，使得存在一个最优解，使得所有路径上运送的酒的体积都是 $1/X$ 的倍数。", "locale": "zh-CN"}}}
{"pid": "P3348", "type": "P", "difficulty": 7, "samples": [["5 5\n0 1 5\n1 2 4 2\n0 1 4\n2 1 1 3\n2 2 1 3", "1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "各省省选", "浙江"], "title": "[ZJOI2016] 大森林", "background": "", "description": "小 Y 家里有一个大森林，里面有 $n$ 棵树，编号从 $1$ 到 $n$。一开始这些树都只是树苗，只有一个节点，标号为 $1$。这些树都有一个特殊的节点，我们称之为生长节点，这些节点有生长出子节点的能力。\n\n小 Y 掌握了一种魔法，能让第 $l$ 棵树到第 $r$ 棵树的生长节点长出一个子节点。同时她还能修改第 $l$ 棵树到第 $r$ 棵树的生长节点。她告诉了你她使用魔法的记录，你能不能管理她家的森林，并且回答她的询问呢？\n", "inputFormat": "第一行包含 $2$ 个正整数 $n,m$，共有 $n$ 棵树和 $m$ 个操作。\n\n接下来 $m$ 行，每行包含若干非负整数表示一个操作，操作格式为：\n\n`0 l r` 表示将第 $l$ 棵树到第 $r$ 棵树的生长节点下面长出一个子节点，子节点的标号为上一个 $0$ 号操作叶子标号加 $1$（例如，第一个 $0$ 号操作产生的子节点标号为 $2$）， $l$ 到 $r$ 之间的树长出的节点标号都相同。保证 $1\\leq l\\leq r\\leq n$ 。\n\n`1 l r x` 表示将第 $l$ 棵树到第 $r$ 棵树的生长节点改到标号为 $x$ 的节点。对于 $i$ ($l\\leq i\\leq r$) 这棵树，如果标号 $x$ 的点不在其中，那么这个操作对该树不产生影响。保证 $1\\leq l\\leq r\\leq n$，$x$ 不超过当前所有树中节点最大的标号。\n\n`2 x u v` 询问第 $x$ 棵树中节点 $u$ 到节点 $v$ 点的距离，也就是在第 $x$ 棵树中从节点 $u$ 和节点 $v$ 的最短路上边的数量。保证 $1\\leq x\\leq n$，这棵树中节点 $u$ 和节点 $v$ 存在。", "outputFormat": "输出包括若干行，按顺序对于每个小 Y 的询问输出答案。\n", "hint": "对于 $100\\%$ 的数据，$N\\leq 10^5,M\\leq 2\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2016] The Great Forest", "background": "", "description": "Xiao Y has a great forest at home, containing $n$ trees numbered from $1$ to $n$. Initially, each tree is just a sapling with a single node labeled $1$. Each tree has a special node, called the growth node, which can grow a child node.\n\nXiao Y masters a kind of magic that can make the growth nodes of the $l$-th tree to the $r$-th tree each grow one child node. She can also modify the growth nodes of the $l$-th tree to the $r$-th tree. She told you the log of her magic operations. Can you manage her forest and answer her queries?", "inputFormat": "The first line contains $2$ positive integers $n, m$, meaning there are $n$ trees and $m$ operations.\n\nThen follow $m$ lines. Each line contains several non-negative integers describing one operation, in one of the following formats:\n\n`0 l r` Make each growth node of the $l$-th tree to the $r$-th tree grow one child. The label of the new child equals the label generated by the previous operation of type `0` plus $1$ (for example, the first operation of type `0` generates a child with label $2$). The trees from $l$ to $r$ all get a child with the same label. It is guaranteed that $1 \\leq l \\leq r \\leq n$.\n\n`1 l r x` Set the growth node of each tree from the $l$-th to the $r$-th to the node labeled $x$. For the $i$-th tree ($l \\leq i \\leq r$), if the node labeled $x$ is not in that tree, this operation has no effect on that tree. It is guaranteed that $1 \\leq l \\leq r \\leq n$, and $x$ does not exceed the current maximum label among all trees.\n\n`2 x u v` Query the distance between node $u$ and node $v$ in the $x$-th tree, i.e., the number of edges on the shortest path between $u$ and $v$ in the $x$-th tree. It is guaranteed that $1 \\leq x \\leq n$, and nodes $u$ and $v$ exist in this tree.", "outputFormat": "Output several lines. For each of Xiao Y’s queries, print the answer in order.", "hint": "For $100\\%$ of the testdata, $N \\leq 10^5, M \\leq 2 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2016] 大森林", "background": "", "description": "小 Y 家里有一个大森林，里面有 $n$ 棵树，编号从 $1$ 到 $n$。一开始这些树都只是树苗，只有一个节点，标号为 $1$。这些树都有一个特殊的节点，我们称之为生长节点，这些节点有生长出子节点的能力。\n\n小 Y 掌握了一种魔法，能让第 $l$ 棵树到第 $r$ 棵树的生长节点长出一个子节点。同时她还能修改第 $l$ 棵树到第 $r$ 棵树的生长节点。她告诉了你她使用魔法的记录，你能不能管理她家的森林，并且回答她的询问呢？\n", "inputFormat": "第一行包含 $2$ 个正整数 $n,m$，共有 $n$ 棵树和 $m$ 个操作。\n\n接下来 $m$ 行，每行包含若干非负整数表示一个操作，操作格式为：\n\n`0 l r` 表示将第 $l$ 棵树到第 $r$ 棵树的生长节点下面长出一个子节点，子节点的标号为上一个 $0$ 号操作叶子标号加 $1$（例如，第一个 $0$ 号操作产生的子节点标号为 $2$）， $l$ 到 $r$ 之间的树长出的节点标号都相同。保证 $1\\leq l\\leq r\\leq n$ 。\n\n`1 l r x` 表示将第 $l$ 棵树到第 $r$ 棵树的生长节点改到标号为 $x$ 的节点。对于 $i$ ($l\\leq i\\leq r$) 这棵树，如果标号 $x$ 的点不在其中，那么这个操作对该树不产生影响。保证 $1\\leq l\\leq r\\leq n$，$x$ 不超过当前所有树中节点最大的标号。\n\n`2 x u v` 询问第 $x$ 棵树中节点 $u$ 到节点 $v$ 点的距离，也就是在第 $x$ 棵树中从节点 $u$ 和节点 $v$ 的最短路上边的数量。保证 $1\\leq x\\leq n$，这棵树中节点 $u$ 和节点 $v$ 存在。", "outputFormat": "输出包括若干行，按顺序对于每个小 Y 的询问输出答案。\n", "hint": "对于 $100\\%$ 的数据，$N\\leq 10^5,M\\leq 2\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3349", "type": "P", "difficulty": 6, "samples": [["4 3\n1 2\n1 3\n1 4\n4 1\n4 2\n4 3", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2016", "各省省选", "浙江", "枚举", "树形 DP", "容斥原理", "状压 DP"], "title": "[ZJOI2016] 小星星", "background": "", "description": "小 Y 是一个心灵手巧的女孩子，她喜欢手工制作一些小饰品。她有 $n$ 颗小星星，用 $m$ 条彩色的细线串了起来，每条细线连着两颗小星星。\n\n有一天她发现，她的饰品被破坏了，很多细线都被拆掉了。这个饰品只剩下了 $n-1$ 条细线，但通过这些细线，这颗小星星还是被串在一起，也就是这些小星星通过这些细线形成了树。小 Y 找到了这个饰品的设计图纸，她想知道现在饰品中的小星星对应着原来图纸上的哪些小星星。如果现在饰品中两颗小星星有细线相连，那么要求对应的小星星原来的图纸上也有细线相连。小 Y 想知道有多少种可能的对应方式。\n\n只有你告诉了她正确的答案，她才会把小饰品做为礼物送给你呢。\n", "inputFormat": "第一行包含 $2$ 个正整数 $n,m$，表示原来的饰品中小星星的个数和细线的条数。\n\n接下来 $m$ 行，每行包含 $2$ 个正整数 $u,v$，表示原来的饰品中小星星 $u$ 和 $v$ 通过细线连了起来。这里的小星星从 $1$ 开始标号。保证 $u\\neq v$，且每对小星星之间最多只有一条细线相连。\n\n接下来 $n-1$ 行，每行包含 $2$ 个正整数 $u,v$，表示现在的饰品中小星星 $u$ 和 $v$ 通过细线连了起来。保证这些小星星通过细线可以串在一起。", "outputFormat": "输出共 $1$ 行，包含一个整数表示可能的对应方式的数量。\n\n如果不存在可行的对应方式则输出 `0`。", "hint": "对于 $100\\%$ 的数据，$n\\leq 17$，$m\\leq \\frac 12n(n-1)$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2016] Little Stars", "background": "", "description": "Xiao Y is a skillful girl who likes making small handmade accessories. She has $n$ little stars, strung together by $m$ colored thin threads, and each thread connects two stars.\n\nOne day she found that her accessory had been damaged, and many threads were removed. The accessory now has only $n-1$ threads, but through these threads, the stars are still strung together; that is, these stars form a tree through these threads. Xiao Y found the design blueprint and wants to know which original stars on the blueprint correspond to the current stars in the accessory. If two stars are connected by a thread in the current accessory, then the corresponding stars must also be connected by a thread on the original blueprint. Xiao Y wants to know how many possible correspondences there are.\n\nOnly if you tell her the correct answer will she give you the accessory as a gift.", "inputFormat": "The first line contains $2$ positive integers $n, m$, representing the number of stars and the number of threads in the original accessory.\n\nThe next $m$ lines each contain $2$ positive integers $u, v$, indicating that in the original accessory, stars $u$ and $v$ are connected by a thread. The stars are numbered starting from $1$. It is guaranteed that $u\\neq v$, and there is at most one thread between each pair of stars.\n\nThe next $n-1$ lines each contain $2$ positive integers $u, v$, indicating that in the current accessory, stars $u$ and $v$ are connected by a thread. It is guaranteed that these stars are connected through the threads.", "outputFormat": "Output a single line containing one integer, the number of possible correspondences.\n\nIf no feasible correspondence exists, output `0`.", "hint": "For $100\\%$ of the testdata, $n\\leq 17$, $m\\leq \\frac 12n(n-1)$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2016] 小星星", "background": "", "description": "小 Y 是一个心灵手巧的女孩子，她喜欢手工制作一些小饰品。她有 $n$ 颗小星星，用 $m$ 条彩色的细线串了起来，每条细线连着两颗小星星。\n\n有一天她发现，她的饰品被破坏了，很多细线都被拆掉了。这个饰品只剩下了 $n-1$ 条细线，但通过这些细线，这颗小星星还是被串在一起，也就是这些小星星通过这些细线形成了树。小 Y 找到了这个饰品的设计图纸，她想知道现在饰品中的小星星对应着原来图纸上的哪些小星星。如果现在饰品中两颗小星星有细线相连，那么要求对应的小星星原来的图纸上也有细线相连。小 Y 想知道有多少种可能的对应方式。\n\n只有你告诉了她正确的答案，她才会把小饰品做为礼物送给你呢。\n", "inputFormat": "第一行包含 $2$ 个正整数 $n,m$，表示原来的饰品中小星星的个数和细线的条数。\n\n接下来 $m$ 行，每行包含 $2$ 个正整数 $u,v$，表示原来的饰品中小星星 $u$ 和 $v$ 通过细线连了起来。这里的小星星从 $1$ 开始标号。保证 $u\\neq v$，且每对小星星之间最多只有一条细线相连。\n\n接下来 $n-1$ 行，每行包含 $2$ 个正整数 $u,v$，表示现在的饰品中小星星 $u$ 和 $v$ 通过细线连了起来。保证这些小星星通过细线可以串在一起。", "outputFormat": "输出共 $1$ 行，包含一个整数表示可能的对应方式的数量。\n\n如果不存在可行的对应方式则输出 `0`。", "hint": "对于 $100\\%$ 的数据，$n\\leq 17$，$m\\leq \\frac 12n(n-1)$。", "locale": "zh-CN"}}}
{"pid": "P3350", "type": "P", "difficulty": 6, "samples": [["2 2\n2\n3\n6 4\n2\n1 1 2 2\n1 2 2 1", "6\r\n7"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "各省省选", "递归", "浙江", "分治", "最短路"], "title": "[ZJOI2016] 旅行者", "background": "", "description": "小 Y 来到了一个新的城市旅行。她发现了这个城市的布局是网格状的，也就是有  $n$ 条从东到西的道路和  $m$ 条从南到北的道路，这些道路两两相交形成  $n\\times m$ 个路口  $(i,j)$，  $(1\\leq i\\leq n,1\\leq j\\leq m)$  \n\n她发现不同的道路路况不同，所以通过不同的路口需要不同的时间。通过调查发现，从路口  $(i,j)$ 到路口  $(i,j+1)$ 需要时间  $r(i,j)$ ，从路口  $(i,j)$ 到路口  $(i+1,j)$ 需要时间  $c(i,j)$ 。注意这里的道路是双向的。小 Y 有  $q$ 个询问，她想知道从路口  $(x1,y1)$ 到路口  $(x2,y2)$ 最少需要花多少时间。", "inputFormat": "第一行包含 2 个正整数  $n,m$ 表示城市的大小。\n\n接下来  $n$ 行，每行包含  $m-1$ 个整数，第  $i$ 行第  $j$ 个正整数表示从一个路口到另一个路口的时间  $r(i,j)$ 。\n\n接下来  $n-1$ 行，每行包含  $m$ 个整数，第  $i$ 行第  $j$ 个正整数表示从一个路口到另一个路口的时间  $c(i,j)$。\n\n接下来一行，包含一个正整数  $q$，表示小 Y 的询问个数。\n\n接下来  $q$ 行，每行包含  $4$ 个正整数  $x1,y1,x2,y2$，表示两个路口的位置。", "outputFormat": "输出共  $q$ 行，每行包含一个整数表示从一个路口到另一个路口最少需要花的时间。\n", "hint": "### 数据规模与约定\n- $n\\times m \\le 2\\times 10^4$。\n- $q \\le 10^5$。\n- $1 \\le r(i,j),c(i,j) \\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2016] Traveler", "background": "", "description": "Xiao Y came to a new city to travel. She found that the city layout is a grid: there are $n$ roads running from east to west and $m$ roads running from south to north. These roads intersect pairwise to form $n \\times m$ intersections $(i,j)$, where $1 \\le i \\le n, 1 \\le j \\le m$.\n\nShe found that the conditions of different roads vary, so passing through different intersections takes different amounts of time. After investigation, she learned that going from intersection $(i,j)$ to $(i,j+1)$ takes time $r(i,j)$, and going from $(i,j)$ to $(i+1,j)$ takes time $c(i,j)$. Note that the roads are bidirectional. Xiao Y has $q$ queries and wants to know the minimum time needed to travel from intersection $(x_1,y_1)$ to intersection $(x_2,y_2)$.", "inputFormat": "The first line contains 2 positive integers $n, m$, representing the size of the city.\n\nThe next $n$ lines each contain $m-1$ integers. In the $i$-th line, the $j$-th positive integer represents the time $r(i,j)$ to move between adjacent intersections.\n\nThe next $n-1$ lines each contain $m$ integers. In the $i$-th line, the $j$-th positive integer represents the time $c(i,j)$ to move between adjacent intersections.\n\nThe next line contains a single positive integer $q$, the number of Xiao Y’s queries.\n\nThe following $q$ lines each contain 4 positive integers $x_1, y_1, x_2, y_2$, representing the positions of two intersections.", "outputFormat": "Output $q$ lines. Each line contains a single integer, the minimum time required to travel from one intersection to the other.", "hint": "Constraints\n- $n \\times m \\le 2 \\times 10^4$.\n- $q \\le 10^5$.\n- $1 \\le r(i,j), c(i,j) \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2016] 旅行者", "background": "", "description": "小 Y 来到了一个新的城市旅行。她发现了这个城市的布局是网格状的，也就是有  $n$ 条从东到西的道路和  $m$ 条从南到北的道路，这些道路两两相交形成  $n\\times m$ 个路口  $(i,j)$，  $(1\\leq i\\leq n,1\\leq j\\leq m)$  \n\n她发现不同的道路路况不同，所以通过不同的路口需要不同的时间。通过调查发现，从路口  $(i,j)$ 到路口  $(i,j+1)$ 需要时间  $r(i,j)$ ，从路口  $(i,j)$ 到路口  $(i+1,j)$ 需要时间  $c(i,j)$ 。注意这里的道路是双向的。小 Y 有  $q$ 个询问，她想知道从路口  $(x1,y1)$ 到路口  $(x2,y2)$ 最少需要花多少时间。", "inputFormat": "第一行包含 2 个正整数  $n,m$ 表示城市的大小。\n\n接下来  $n$ 行，每行包含  $m-1$ 个整数，第  $i$ 行第  $j$ 个正整数表示从一个路口到另一个路口的时间  $r(i,j)$ 。\n\n接下来  $n-1$ 行，每行包含  $m$ 个整数，第  $i$ 行第  $j$ 个正整数表示从一个路口到另一个路口的时间  $c(i,j)$。\n\n接下来一行，包含一个正整数  $q$，表示小 Y 的询问个数。\n\n接下来  $q$ 行，每行包含  $4$ 个正整数  $x1,y1,x2,y2$，表示两个路口的位置。", "outputFormat": "输出共  $q$ 行，每行包含一个整数表示从一个路口到另一个路口最少需要花的时间。\n", "hint": "### 数据规模与约定\n- $n\\times m \\le 2\\times 10^4$。\n- $q \\le 10^5$。\n- $1 \\le r(i,j),c(i,j) \\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P3351", "type": "P", "difficulty": 7, "samples": [["6 6\n1 2\n1 3\n1 4\n2 3\n2 4\n5 6\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "搜索", "2016", "各省省选", "浙江"], "title": "[ZJOI2016] 电阻网络", "background": "", "description": "小 Y 是一个充满智慧的女孩子，但是她只会使用串并联的方法计算两个节点之间的电阻。现在小 Y 有一个电阻网络问有多少点对 $u, v$（$u \\ne v$）之间的电阻可以用串并联的方法计算出来。\n\n我们来形式化地定义一下点对 $u, v$（$u \\ne v$）之间的电阻能否用串并联的方法计算出来。首先我们把电阻网络看成一个 $n$ 个点 $m$ 条边的图（每个电阻对应一条边）。\n\n令 $S$ 表示从 $u$ 到 $v$ 的所有简单路径（不经过重复的点的路径）上点的并集，也就是对于一个点 $x$，如果存在一条从 $u$ 到 $v$ 的简单路径经过这个点，那么它就在集合 $S$ 中。\n\n如果 $S$ 非空且 $S$ 的导出子图是 $u, v$ 为端点的二端串并联图，那么 $u, v$ 之间的电阻就能用串并联方法计算。\n\n一个有两个不同端点 $s, t$ 的图被称为二端图，其中一个称为源点，另一个称为汇点。两个二端图 $X, Y$ 并联（parallel composition）是指建一个新图，把 $X$ 和 $Y$ 的源点和汇点分别合并起来。两个二端图 $X, Y$ 串联（series composition）是指建一个新图，把 $X$ 的汇点和 $Y$ 的源点合并起来。由若干个两个点一条边的二端图经过一系列串并联变化之后形成的图称为二端串并联图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9xagyluf.png)\n\n集合 $S$ 的导出子图点集为 $S$，边集由原图中两个端点都在 $S$ 中的边构成。", "inputFormat": "第一行包含两个正整数 $n, m$，表示电阻网络中的节点数和电阻数。  \n接下来 $m$ 行，每行包含两个正整数 $u, v$（$1 \\le u, v \\le n$，$u \\ne v$），表示有一个电阻在节点 $u$ 和 $v$ 之间。", "outputFormat": "输出共一行，表示答案，即有多少点对之间的电阻可以使用串并联的方法计算出来。", "hint": "**【样例解释 #1】**\n\n可行的点对有 $(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (5, 6)$。\n\n**【数据范围】**\n\n对于 $10 \\%$ 的数据，$n, m \\le 10$，保证原图连通，并且不存在一个点删去之后使得原图不连通。  \n对于另外 $10 \\%$ 的数据，$n, m \\le 100$，保证原图连通，并且不存在一个点删去之后使得原图不连通。  \n对于 $30 \\%$ 的数据，$n, m \\le 100$。  \n对于 $40 \\%$ 的数据，$n, m \\le 1000$。  \n对于另外 $30 \\%$ 的数据，保证原图连通，并且不存在一个点删去之后使得原图不连通。  \n对于 $100 \\%$ 的数据，$1 \\le n, m \\le {10}^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2016] Resistor Network", "background": "", "description": "Xiao Y is a very smart girl, but she can only compute the resistance between two nodes using series and parallel reductions. Now, given a resistor network, she wants to know how many pairs of vertices $u, v$ ($u \\ne v$) have their resistance computable by series-parallel methods.\n\nWe formalize when the resistance between a pair $u, v$ ($u \\ne v$) can be computed using series-parallel methods. First, regard the resistor network as a graph with $n$ vertices and $m$ edges (each resistor corresponds to an edge).\n\nLet $S$ be the union of the vertices on all simple paths (paths that do not visit a vertex more than once) from $u$ to $v$. In other words, for a vertex $x$, if there exists a simple path from $u$ to $v$ that passes through $x$, then $x \\in S$.\n\nIf $S$ is nonempty and the induced subgraph of $S$ is a two-terminal series-parallel graph with terminals $u$ and $v$, then the resistance between $u$ and $v$ can be computed using series-parallel methods.\n\nA graph with two distinct terminals $s, t$ is called a two-terminal graph, where one is the source and the other is the sink. The parallel composition of two two-terminal graphs $X, Y$ builds a new graph by identifying their sources and their sinks, respectively. The series composition of two two-terminal graphs $X, Y$ builds a new graph by identifying the sink of $X$ with the source of $Y$. A graph formed from several two-terminal graphs consisting of two vertices and one edge, by a sequence of series and parallel compositions, is called a two-terminal series-parallel graph.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9xagyluf.png)\n\nThe induced subgraph of the set $S$ has vertex set $S$, and its edge set consists of edges in the original graph whose both endpoints lie in $S$.", "inputFormat": "The first line contains two positive integers $n, m$, the number of nodes and the number of resistors in the network.  \nEach of the next $m$ lines contains two positive integers $u, v$ ($1 \\le u, v \\le n$, $u \\ne v$), indicating there is a resistor between nodes $u$ and $v$.", "outputFormat": "Output a single line containing the answer: the number of vertex pairs whose resistance can be computed using series-parallel methods.", "hint": "【Sample Explanation #1】\n\nThe feasible pairs are $(1, 2)$, $(1, 3)$, $(1, 4)$, $(2, 3)$, $(2, 4)$, $(5, 6)$.\n\n【Constraints】\n\nFor 10% of the testdata, $n, m \\le 10$, the original graph is connected and has no articulation point.  \nFor another 10% of the testdata, $n, m \\le 100$, the original graph is connected and has no articulation point.  \nFor 30% of the testdata, $n, m \\le 100$.  \nFor 40% of the testdata, $n, m \\le 1000$.  \nFor another 30% of the testdata, the original graph is connected and has no articulation point.  \nFor 100% of the testdata, $1 \\le n, m \\le {10}^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2016] 电阻网络", "background": "", "description": "小 Y 是一个充满智慧的女孩子，但是她只会使用串并联的方法计算两个节点之间的电阻。现在小 Y 有一个电阻网络问有多少点对 $u, v$（$u \\ne v$）之间的电阻可以用串并联的方法计算出来。\n\n我们来形式化地定义一下点对 $u, v$（$u \\ne v$）之间的电阻能否用串并联的方法计算出来。首先我们把电阻网络看成一个 $n$ 个点 $m$ 条边的图（每个电阻对应一条边）。\n\n令 $S$ 表示从 $u$ 到 $v$ 的所有简单路径（不经过重复的点的路径）上点的并集，也就是对于一个点 $x$，如果存在一条从 $u$ 到 $v$ 的简单路径经过这个点，那么它就在集合 $S$ 中。\n\n如果 $S$ 非空且 $S$ 的导出子图是 $u, v$ 为端点的二端串并联图，那么 $u, v$ 之间的电阻就能用串并联方法计算。\n\n一个有两个不同端点 $s, t$ 的图被称为二端图，其中一个称为源点，另一个称为汇点。两个二端图 $X, Y$ 并联（parallel composition）是指建一个新图，把 $X$ 和 $Y$ 的源点和汇点分别合并起来。两个二端图 $X, Y$ 串联（series composition）是指建一个新图，把 $X$ 的汇点和 $Y$ 的源点合并起来。由若干个两个点一条边的二端图经过一系列串并联变化之后形成的图称为二端串并联图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9xagyluf.png)\n\n集合 $S$ 的导出子图点集为 $S$，边集由原图中两个端点都在 $S$ 中的边构成。", "inputFormat": "第一行包含两个正整数 $n, m$，表示电阻网络中的节点数和电阻数。  \n接下来 $m$ 行，每行包含两个正整数 $u, v$（$1 \\le u, v \\le n$，$u \\ne v$），表示有一个电阻在节点 $u$ 和 $v$ 之间。", "outputFormat": "输出共一行，表示答案，即有多少点对之间的电阻可以使用串并联的方法计算出来。", "hint": "**【样例解释 #1】**\n\n可行的点对有 $(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (5, 6)$。\n\n**【数据范围】**\n\n对于 $10 \\%$ 的数据，$n, m \\le 10$，保证原图连通，并且不存在一个点删去之后使得原图不连通。  \n对于另外 $10 \\%$ 的数据，$n, m \\le 100$，保证原图连通，并且不存在一个点删去之后使得原图不连通。  \n对于 $30 \\%$ 的数据，$n, m \\le 100$。  \n对于 $40 \\%$ 的数据，$n, m \\le 1000$。  \n对于另外 $30 \\%$ 的数据，保证原图连通，并且不存在一个点删去之后使得原图不连通。  \n对于 $100 \\%$ 的数据，$1 \\le n, m \\le {10}^5$。", "locale": "zh-CN"}}}
{"pid": "P3352", "type": "P", "difficulty": 6, "samples": [["5 5\n1 5 2 3 4\n", "3152671 3796875 3692207 3623487 3515626\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2016", "各省省选", "浙江"], "title": "[ZJOI2016] 线段树", "background": "", "description": "小 Yuuka 遇到了一个题目：有一个序列 $a_1,a_2,\\ldots,a_n$，$q$ 次操作。每次操作把一个区间内的数改成区间内的最大值，问最后每个数是多少。小 Yuuka 很快地就使用了线段树解决了这个问题。\n\n于是充满智慧的小 Yuuka 想，如果操作是随机的，即在这 $q$ 次操作中每次等概率随机地选择一个区间 $[l,r]$（$1 \\leq l \\leq r \\leq n$），然后将这个区间内的数改成区间内最大值（注意这样的区间共有 $\\frac{n(n+1)}{2}$ 个），最后每个数的期望大小是多少呢？\n\n小 Yuuka 非常热爱随机，所以她给出的输入序列也是随机的（随机方式见数据规模和约定）。\n\n对于每个数，输出它的期望乘 $\\left(\\frac{n(n+1)}{2} \\right)^q$ 再对 $10^9+7$ 取模的值。\n", "inputFormat": "第一行包含两个正整数 $n,q$，表示序列里数的个数和操作的个数。\n\n接下来一行，包含 $n$ 个非负整数 $a_1,a_2,\\ldots,a_n$。\n", "outputFormat": "输出共一行，包含 $n$ 个整数，表示每个数的答案。\n", "hint": "对于所有的测试数据，保证序列中数的大小不超过 $10^9$，并且每个数是 $0$ 到 $10^9$ 之间的随机整数。\n\n|测试点编号|$n$|$q$|\n|:-:|:-:|:-:|\n|1|$\\leq 5$|$\\leq 5$|\n|2|$\\leq 8$|$\\leq 400$|\n|3|$\\leq 12$|$\\leq 400$|\n|4|$\\leq 30$|$\\leq 400$|\n|5|$\\leq 50$|$\\leq 400$|\n|6|$\\leq 100$|$\\leq 400$|\n|7|$\\leq 100$|$\\leq 400$|\n|8|$\\leq 400$|$\\leq 400$|\n|9|$\\leq 400$|$\\leq 400$|\n|10|$\\leq 400$|$\\leq 400$|\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2016] Segment Tree", "background": "", "description": "Little Yuuka encountered a problem: given a sequence $a_1, a_2, \\ldots, a_n$ and $q$ operations. In each operation, choose an interval $[l, r]$ and set all numbers in that interval to the maximum value within the interval. After all operations, what is the final value of each number? Little Yuuka quickly solved this using a segment tree.\n\nThen the wise Little Yuuka wondered: what if the operations are random? That is, in each of the $q$ operations, we choose an interval $[l, r]$ uniformly at random among all intervals with $1 \\leq l \\leq r \\leq n$, and then set all numbers in that interval to the interval maximum (note that there are $\\frac{n(n+1)}{2}$ such intervals). What is the expected final value of each number?\n\nLittle Yuuka loves randomness, so the input sequence is also random (see Constraints and conventions in the Hint).\n\nFor each position, output its expectation multiplied by $\\left(\\frac{n(n+1)}{2} \\right)^q$, then taken modulo $10^9+7$.", "inputFormat": "The first line contains two positive integers $n, q$, the number of elements in the sequence and the number of operations.\n\nThe second line contains $n$ non-negative integers $a_1, a_2, \\ldots, a_n$.", "outputFormat": "Output a single line containing $n$ integers, the answer for each position.", "hint": "For all testdata, the values in the sequence are at most $10^9$, and each number is a random integer between $0$ and $10^9$.\n\n| Test point ID | $n$ | $q$ |\n|:-:|:-:|:-:|\n| 1 | $\\leq 5$ | $\\leq 5$ |\n| 2 | $\\leq 8$ | $\\leq 400$ |\n| 3 | $\\leq 12$ | $\\leq 400$ |\n| 4 | $\\leq 30$ | $\\leq 400$ |\n| 5 | $\\leq 50$ | $\\leq 400$ |\n| 6 | $\\leq 100$ | $\\leq 400$ |\n| 7 | $\\leq 100$ | $\\leq 400$ |\n| 8 | $\\leq 400$ | $\\leq 400$ |\n| 9 | $\\leq 400$ | $\\leq 400$ |\n| 10 | $\\leq 400$ | $\\leq 400$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2016] 线段树", "background": "", "description": "小 Yuuka 遇到了一个题目：有一个序列 $a_1,a_2,\\ldots,a_n$，$q$ 次操作。每次操作把一个区间内的数改成区间内的最大值，问最后每个数是多少。小 Yuuka 很快地就使用了线段树解决了这个问题。\n\n于是充满智慧的小 Yuuka 想，如果操作是随机的，即在这 $q$ 次操作中每次等概率随机地选择一个区间 $[l,r]$（$1 \\leq l \\leq r \\leq n$），然后将这个区间内的数改成区间内最大值（注意这样的区间共有 $\\frac{n(n+1)}{2}$ 个），最后每个数的期望大小是多少呢？\n\n小 Yuuka 非常热爱随机，所以她给出的输入序列也是随机的（随机方式见数据规模和约定）。\n\n对于每个数，输出它的期望乘 $\\left(\\frac{n(n+1)}{2} \\right)^q$ 再对 $10^9+7$ 取模的值。\n", "inputFormat": "第一行包含两个正整数 $n,q$，表示序列里数的个数和操作的个数。\n\n接下来一行，包含 $n$ 个非负整数 $a_1,a_2,\\ldots,a_n$。\n", "outputFormat": "输出共一行，包含 $n$ 个整数，表示每个数的答案。\n", "hint": "对于所有的测试数据，保证序列中数的大小不超过 $10^9$，并且每个数是 $0$ 到 $10^9$ 之间的随机整数。\n\n|测试点编号|$n$|$q$|\n|:-:|:-:|:-:|\n|1|$\\leq 5$|$\\leq 5$|\n|2|$\\leq 8$|$\\leq 400$|\n|3|$\\leq 12$|$\\leq 400$|\n|4|$\\leq 30$|$\\leq 400$|\n|5|$\\leq 50$|$\\leq 400$|\n|6|$\\leq 100$|$\\leq 400$|\n|7|$\\leq 100$|$\\leq 400$|\n|8|$\\leq 400$|$\\leq 400$|\n|9|$\\leq 400$|$\\leq 400$|\n|10|$\\leq 400$|$\\leq 400$|\n", "locale": "zh-CN"}}}
{"pid": "P3353", "type": "P", "difficulty": 2, "samples": [["6 3\n1 2\n2 4\n3 8\n4 4\n5 2\n1000 1", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "线段树", "排序", "前缀和", "双指针 two-pointer"], "title": "在你窗外闪耀的星星", "background": "飞逝的的时光不会模糊我对你的记忆。难以相信从我第一次见到你以来已经过去了 3 年。我仍然还生动地记得，3 年前，在美丽的集美中学，从我看到你微笑着走出教室，你将头向后仰，柔和的晚霞照耀着你玫瑰色的脸颊。我明白，我已经沉醉于你了。之后，经过几个月的观察和窥探，你的优雅与智慧，你对待生活的态度和你对未来的愿望深切地在我心中留下了印象。你是迷人的阳光女孩，我总是梦想着与你分享余生。唉，实际上你远远超过了我最疯狂的梦想。我不知道如何桥起我与你之间的鸿沟。所以我没有任何计划，仅仅只是等待，等待一个适当的机会到来。直到现在，毕业的到来，我意识到我是个傻瓜，我应该创造机会并且抓住它而不只是等待。\n\n\n这些日子里，我和我的朋友、室友、同学一个接一个地分开。我仍无法相信，在挥手之后，这些熟悉的面孔很快就会从我们的生活中消失，仅仅留下回忆。我明天就将离开学校。你已经计划远走高飞，追求你的未来，实现你的梦想。如果没有命运，也许我们不会再次相遇。所以今晚，我正在你的宿舍楼下徘徊，希望能偶然遇见你。但矛盾的是，你的美貌一定会使我心跳加速，我笨拙的舌头也许无法吐出一个字。我不记得我曾多少次经过你的宿舍楼，每次都希望看到你出现在阳台上或是窗台上。我不记得这个想法曾多少次在我的脑海中涌出：打电话叫她一起吃晚饭或是聊聊天。但每次，考虑到你的优秀和我的平凡，胆怯的优势超越勇气驱使我静静地离开。\n\n\n毕业，意味着中学生活的终结。这些光荣与浪漫的时代结束。你可爱的微笑是我原来努力学习的动力，这单相思的爱情会被密封，作为一个我心灵深处的记忆。毕业，也意味着新生活的开始，一个到达光明未来的足迹。我真希望你在国外天天开心，一切顺利。同时，我将努力从幼稚中走出来，变得更加成熟。我的理想将是在现实中追求我的爱与幸福，我永远不会放弃。\n\n\n再见了，我的公主！\n\n\n如果有一天，在某个天涯海角，我们有机会相聚，即使是白发苍苍的男人和女人，在那个时候，我希望我们可以成为好朋友来自豪地分享这个记忆，重温年轻快乐的激情。如果这个机会永远没有到来，我希望我是天空中的星星，在你的窗外闪烁。远远地保佑着你，就像一个朋友，每天晚上陪伴在你左右，一同分享甜美的梦亦或是一同经历可怕的梦。", "description": "现在问题来了：天空可以理解为一条数轴，在这条数轴上分布着许多颗星星，对于每颗星星都有它的位置 $X_i$ 和自身的亮度 $B_i$。**一个位置可能有多颗星星**。而窗户所能看到的范围是一个给出的参数 $W$，我们看到的星星也包括窗户边缘的星星。现在，要你求出调整窗户位置后能看到星星的亮度之和最大值。\n", "inputFormat": "一行 $N,W$，分别代表星星的数量和窗户的宽度。\n\n余下 $N$ 行，输入 $X_i$ 和 $B_i$，代表星星的坐标和亮度。", "outputFormat": "一个数字，代表能看到星星的最大亮度和。\n", "hint": "样例说明：\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/3818.png) \n\n对于 $10\\%$ 的数据，$W=0$（没有边缘）；\n\n对于 $40\\%$ 的数据，$W\\leq 1000$；\n\n对于 $100\\%$ 的数据，$1 \\leq N\\leq 10 ^ 5$，$0 \\leq W\\leq 10 ^ 5$，$1 \\leq X_i\\leq 10 ^ 5$，$1\\leq B_i\\leq 100$。\n\n除 $W=0$ 的情况外，$W$ 均为 $\\geq 3$ 的奇数。\n", "locale": "zh-CN", "translations": {"en": {"title": "The Stars Shining Outside Your Window", "background": "The fleeting passage of time will not blur my memory of you. It is hard to believe that 3 years have passed since I first saw you. I still vividly remember, 3 years ago, at the beautiful Jimei Middle School, when I saw you walk out of the classroom with a smile, tilt your head back, and the soft evening glow lit up your rosy cheeks. I knew I was already enchanted by you. Later, after months of watching and peeking, your grace and wisdom, your attitude toward life, and your hopes for the future left a deep impression on me. You are a charming sunshine girl, and I always dream of spending the rest of my life with you. Alas, in fact you far exceed my wildest dreams. I do not know how to bridge the gap between you and me. So I had no plan, only waiting, waiting for a proper chance to come. Until now, with graduation approaching, I realize I am a fool; I should create chances and seize them, not just wait.\n\nThese days, my friends, roommates, and classmates are parting one by one. I still cannot believe that after we wave goodbye, those familiar faces will soon disappear from our lives, leaving only memories. I will leave school tomorrow. You have planned to go far away, pursue your future, and realize your dreams. Without fate, perhaps we will never meet again. So tonight, I am wandering downstairs by your dormitory, hoping to run into you by chance. But paradoxically, your beauty will certainly make my heart pound, and my clumsy tongue may not utter a word. I do not remember how many times I have passed by your dormitory, each time hoping to see you appear on the balcony or by the window. I do not remember how many times the thought has surged in my mind: call you to have dinner together or just chat. But each time, thinking of your excellence and my ordinariness, timidity outweighs courage and drives me to leave quietly.\n\nGraduation means the end of middle school life. Those glorious and romantic days are over. Your lovely smile was the motivation behind my hard study, and this unrequited love will be sealed as a memory deep in my heart. Graduation also means the start of a new life, a step toward a bright future. I truly wish you happiness every day abroad and all the best. At the same time, I will try to grow out of childishness and become more mature. My ideal is to pursue love and happiness in reality, and I will never give up.\n\nFarewell, my princess.\n\nIf one day, somewhere at the ends of the earth, we have the chance to meet again, even as a gray‑haired man and woman, then I hope we can be good friends, proudly share this memory, and relive the passion of our youthful joy. If that chance never comes, I wish I were a star in the sky, twinkling outside your window. Blessing you from afar, like a friend, by your side every night, sharing sweet dreams with you or going through terrible dreams together.", "description": "Now here is the problem: Think of the sky as a number line. On this number line there are many stars, each with a position $X_i$ and a brightness $B_i$. **Multiple stars may share the same position.** The range a window can see is given by a parameter $W$, and the stars we see also include those on the window’s boundaries. Find the maximum possible sum of brightness of the stars visible after adjusting the position of the window.", "inputFormat": "One line with $N, W$, the number of stars and the width of the window.\n\nEach of the next $N$ lines contains $X_i$ and $B_i$, the coordinate and brightness of a star.", "outputFormat": "One number, the maximum total brightness of the visible stars.", "hint": "Sample explanation:\n\n![](https://cdn.luogu.com.cn/upload/pic/3818.png)\n\nConstraints:\n- For $10\\%$ of the testdata, $W = 0$ (no boundary).\n- For $40\\%$ of the testdata, $W \\leq 1000$.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 10^5$, $0 \\leq W \\leq 10^5$, $1 \\leq X_i \\leq 10^5$, $1 \\leq B_i \\leq 100$.\n- Except for the case $W = 0$, $W$ is an odd integer $\\geq 3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "在你窗外闪耀的星星", "background": "飞逝的的时光不会模糊我对你的记忆。难以相信从我第一次见到你以来已经过去了 3 年。我仍然还生动地记得，3 年前，在美丽的集美中学，从我看到你微笑着走出教室，你将头向后仰，柔和的晚霞照耀着你玫瑰色的脸颊。我明白，我已经沉醉于你了。之后，经过几个月的观察和窥探，你的优雅与智慧，你对待生活的态度和你对未来的愿望深切地在我心中留下了印象。你是迷人的阳光女孩，我总是梦想着与你分享余生。唉，实际上你远远超过了我最疯狂的梦想。我不知道如何桥起我与你之间的鸿沟。所以我没有任何计划，仅仅只是等待，等待一个适当的机会到来。直到现在，毕业的到来，我意识到我是个傻瓜，我应该创造机会并且抓住它而不只是等待。\n\n\n这些日子里，我和我的朋友、室友、同学一个接一个地分开。我仍无法相信，在挥手之后，这些熟悉的面孔很快就会从我们的生活中消失，仅仅留下回忆。我明天就将离开学校。你已经计划远走高飞，追求你的未来，实现你的梦想。如果没有命运，也许我们不会再次相遇。所以今晚，我正在你的宿舍楼下徘徊，希望能偶然遇见你。但矛盾的是，你的美貌一定会使我心跳加速，我笨拙的舌头也许无法吐出一个字。我不记得我曾多少次经过你的宿舍楼，每次都希望看到你出现在阳台上或是窗台上。我不记得这个想法曾多少次在我的脑海中涌出：打电话叫她一起吃晚饭或是聊聊天。但每次，考虑到你的优秀和我的平凡，胆怯的优势超越勇气驱使我静静地离开。\n\n\n毕业，意味着中学生活的终结。这些光荣与浪漫的时代结束。你可爱的微笑是我原来努力学习的动力，这单相思的爱情会被密封，作为一个我心灵深处的记忆。毕业，也意味着新生活的开始，一个到达光明未来的足迹。我真希望你在国外天天开心，一切顺利。同时，我将努力从幼稚中走出来，变得更加成熟。我的理想将是在现实中追求我的爱与幸福，我永远不会放弃。\n\n\n再见了，我的公主！\n\n\n如果有一天，在某个天涯海角，我们有机会相聚，即使是白发苍苍的男人和女人，在那个时候，我希望我们可以成为好朋友来自豪地分享这个记忆，重温年轻快乐的激情。如果这个机会永远没有到来，我希望我是天空中的星星，在你的窗外闪烁。远远地保佑着你，就像一个朋友，每天晚上陪伴在你左右，一同分享甜美的梦亦或是一同经历可怕的梦。", "description": "现在问题来了：天空可以理解为一条数轴，在这条数轴上分布着许多颗星星，对于每颗星星都有它的位置 $X_i$ 和自身的亮度 $B_i$。**一个位置可能有多颗星星**。而窗户所能看到的范围是一个给出的参数 $W$，我们看到的星星也包括窗户边缘的星星。现在，要你求出调整窗户位置后能看到星星的亮度之和最大值。\n", "inputFormat": "一行 $N,W$，分别代表星星的数量和窗户的宽度。\n\n余下 $N$ 行，输入 $X_i$ 和 $B_i$，代表星星的坐标和亮度。", "outputFormat": "一个数字，代表能看到星星的最大亮度和。\n", "hint": "样例说明：\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/3818.png) \n\n对于 $10\\%$ 的数据，$W=0$（没有边缘）；\n\n对于 $40\\%$ 的数据，$W\\leq 1000$；\n\n对于 $100\\%$ 的数据，$1 \\leq N\\leq 10 ^ 5$，$0 \\leq W\\leq 10 ^ 5$，$1 \\leq X_i\\leq 10 ^ 5$，$1\\leq B_i\\leq 100$。\n\n除 $W=0$ 的情况外，$W$ 均为 $\\geq 3$ 的奇数。\n", "locale": "zh-CN"}}}
{"pid": "P3354", "type": "P", "difficulty": 6, "samples": [["4 2\n1 0 1\n1 1 10\n10 2 5\n1 2 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2005", "IOI"], "title": "[IOI 2005] Riv 河流", "background": "", "description": "几乎整个 Byteland 王国都被森林和河流所覆盖。小点的河汇聚到一起，形成了稍大点的河。就这样，所有的河水都汇聚并流进了一条大河，最后这条大河流进了大海。这条大河的入海口处有一个村庄——名叫 Bytetown。\n\n在 Byteland 国，有 $n$ 个伐木的村庄，这些村庄都座落在河边。目前在 Bytetown，有一个巨大的伐木场，它处理着全国砍下的所有木料。木料被砍下后，顺着河流而被运到 Bytetown 的伐木场。Byteland 的国王决定，为了减少运输木料的费用，再额外地建造 $k$ 个伐木场。这 $k$ 个伐木场将被建在其他村庄里。这些伐木场建造后，木料就不用都被送到 Bytetown 了，它们可以在运输过程中第一个碰到的新伐木场被处理。显然，如果伐木场座落的那个村子就不用再付运送木料的费用了。它们可以直接被本村的伐木场处理。\n\n注：所有的河流都不会分叉，形成一棵树，根结点是 Bytetown。\n\n国王的大臣计算出了每个村子每年要产多少木料，你的任务是决定在哪些村子建设伐木场能获得最小的运费。其中运费的计算方法为：每一吨木料每千米 $1$ 分钱。", "inputFormat": "第一行包括两个整数 $n,k$。$n$ 为村庄数，$k$ 为要建的伐木场的数目。除了 Bytetown 外，每个村子依次被命名为 $1,2,3\\ldots n$，Bytetown 被命名为 $0$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行 $3$ 个整数，第 $(i + 1)$ 行的整数分别代表，分别表示每年 $i$ 村子产的木料的块数 $w_i$，离 $i$ 村子下游最近的村子 $v_i$（即 $i$ 村子的父结点），$v_i$ 到 $i$ 的距离 $d_i$（千米）。", "outputFormat": "输出最小花费，单位为分。\n", "hint": "#### 数据规模与约定\n\n- 对于 $50\\%$ 的数据，保证 $n\\le 20$。\n- 对于 $100\\%$ 的数据，保证 $2\\le n\\le 100$，$1\\le k\\le \\min(n,50)$，$0\\le v_i\\le n$，$0\\le w_i\\le 10^4$，$1\\le d_i\\le 10^4$。\n- 保证每年所有的木料流到 bytetown 的运费不超过 $2\\times 10^9$ 分。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2005] Riv River", "background": "", "description": "Almost the entire kingdom of Byteland is covered with forests and rivers. Small rivers merge into slightly larger ones. In this way, all river water converges into a single large river, which eventually flows into the sea. At the mouth of this large river lies a village called Bytetown.\n\nIn Byteland, there are $n$ logging villages located along the rivers. There is currently a large sawmill in Bytetown that processes all the timber cut nationwide. Timber is cut and transported downstream along the rivers to the sawmill in Bytetown. The King of Byteland has decided to reduce transportation costs by building $k$ additional sawmills in other villages. After these sawmills are built, timber no longer needs to be sent all the way to Bytetown; it can be processed at the first new sawmill encountered during transport. Clearly, if a sawmill is located in a village, that village pays no transportation cost for its own timber; it can be processed locally.\n\nNote: The rivers never split; they form a tree whose root is Bytetown.\n\nThe ministers have calculated the annual timber production of each village. Your task is to decide in which villages to build the sawmills to minimize the transportation cost. The cost is calculated as 1 cent per kilometer per ton of timber.", "inputFormat": "The first line contains two integers $n, k$. Here $n$ is the number of villages, and $k$ is the number of sawmills to build. All villages other than Bytetown are named $1, 2, 3, \\ldots, n$, and Bytetown is named $0$.\n\nLines $2$ through $(n + 1)$ each contain three integers. On the $(i + 1)$-th line, the integers are:\n- $w_i$: the amount of timber produced annually by village $i$ (in tons),\n- $v_i$: the nearest downstream village from $i$ (i.e., the parent of village $i$),\n- $d_i$: the distance from $v_i$ to $i$ (in kilometers).", "outputFormat": "Output the minimum total cost, in cents.", "hint": "- Constraints:\n  - For $50\\%$ of the testdata, $n \\le 20$.\n  - For $100\\%$ of the testdata, $2 \\le n \\le 100$, $1 \\le k \\le \\min(n, 50)$, $0 \\le v_i \\le n$, $0 \\le w_i \\le 10^4$, $1 \\le d_i \\le 10^4$.\n  - It is guaranteed that the annual cost of sending all timber to Bytetown does not exceed $2 \\times 10^9$ cents.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2005] Riv 河流", "background": "", "description": "几乎整个 Byteland 王国都被森林和河流所覆盖。小点的河汇聚到一起，形成了稍大点的河。就这样，所有的河水都汇聚并流进了一条大河，最后这条大河流进了大海。这条大河的入海口处有一个村庄——名叫 Bytetown。\n\n在 Byteland 国，有 $n$ 个伐木的村庄，这些村庄都座落在河边。目前在 Bytetown，有一个巨大的伐木场，它处理着全国砍下的所有木料。木料被砍下后，顺着河流而被运到 Bytetown 的伐木场。Byteland 的国王决定，为了减少运输木料的费用，再额外地建造 $k$ 个伐木场。这 $k$ 个伐木场将被建在其他村庄里。这些伐木场建造后，木料就不用都被送到 Bytetown 了，它们可以在运输过程中第一个碰到的新伐木场被处理。显然，如果伐木场座落的那个村子就不用再付运送木料的费用了。它们可以直接被本村的伐木场处理。\n\n注：所有的河流都不会分叉，形成一棵树，根结点是 Bytetown。\n\n国王的大臣计算出了每个村子每年要产多少木料，你的任务是决定在哪些村子建设伐木场能获得最小的运费。其中运费的计算方法为：每一吨木料每千米 $1$ 分钱。", "inputFormat": "第一行包括两个整数 $n,k$。$n$ 为村庄数，$k$ 为要建的伐木场的数目。除了 Bytetown 外，每个村子依次被命名为 $1,2,3\\ldots n$，Bytetown 被命名为 $0$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行 $3$ 个整数，第 $(i + 1)$ 行的整数分别代表，分别表示每年 $i$ 村子产的木料的块数 $w_i$，离 $i$ 村子下游最近的村子 $v_i$（即 $i$ 村子的父结点），$v_i$ 到 $i$ 的距离 $d_i$（千米）。", "outputFormat": "输出最小花费，单位为分。\n", "hint": "#### 数据规模与约定\n\n- 对于 $50\\%$ 的数据，保证 $n\\le 20$。\n- 对于 $100\\%$ 的数据，保证 $2\\le n\\le 100$，$1\\le k\\le \\min(n,50)$，$0\\le v_i\\le n$，$0\\le w_i\\le 10^4$，$1\\le d_i\\le 10^4$。\n- 保证每年所有的木料流到 bytetown 的运费不超过 $2\\times 10^9$ 分。", "locale": "zh-CN"}}}
{"pid": "P3355", "type": "P", "difficulty": 5, "samples": [["3 2\n1 1\n3 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流", "O2优化", "二分图", "最小割", "网络流与线性规划 24 题"], "title": "骑士共存问题", "background": null, "description": "在一个 $n \\times n$ 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。\n\n![](https://cdn.luogu.com.cn/upload/pic/2669.png)\n\n对于给定的 $n \\times n$ 个方格的国际象棋棋盘和障碍标志，计算棋盘上最多可以放置多少个骑士，使得它们彼此互不攻击。", "inputFormat": "第一行有 $2$ 个正整数 $n$ 和 $m$ ，分别表示棋盘的大小和障碍数。接下来的 $m$ 行给出障碍的位置。每行 $2$ 个正整数，表示障碍的方格坐标。", "outputFormat": "将计算出的共存骑士数输出。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 200$，$0 \\leq m \\lt n^2$。", "locale": "zh-CN", "translations": {"en": {"title": "Knights Coexistence Problem", "background": "", "description": "On an $n \\times n$ chessboard, a knight can attack the squares shown in the figure. Some squares on the board are marked as obstacles, and knights are not allowed to enter them.\n\n![](https://cdn.luogu.com.cn/upload/pic/2669.png)\n\nGiven an $n \\times n$ chessboard and the obstacle marks, compute the maximum number of knights that can be placed on the board so that no two knights attack each other.", "inputFormat": "The first line contains $2$ positive integers $n$ and $m$, representing the size of the board and the number of obstacles, respectively. The following $m$ lines give the positions of the obstacles. Each line contains $2$ positive integers, representing the coordinates of an obstructed square.", "outputFormat": "Output the maximum number of knights that can coexist.", "hint": "#### Constraints\n\nFor all test points, it is guaranteed that $1 \\leq n \\leq 200$, $0 \\leq m \\lt n^2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "骑士共存问题", "background": null, "description": "在一个 $n \\times n$ 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。\n\n![](https://cdn.luogu.com.cn/upload/pic/2669.png)\n\n对于给定的 $n \\times n$ 个方格的国际象棋棋盘和障碍标志，计算棋盘上最多可以放置多少个骑士，使得它们彼此互不攻击。", "inputFormat": "第一行有 $2$ 个正整数 $n$ 和 $m$ ，分别表示棋盘的大小和障碍数。接下来的 $m$ 行给出障碍的位置。每行 $2$ 个正整数，表示障碍的方格坐标。", "outputFormat": "将计算出的共存骑士数输出。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 200$，$0 \\leq m \\lt n^2$。", "locale": "zh-CN"}}}
{"pid": "P3356", "type": "P", "difficulty": 6, "samples": [["2\n10\n8\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 1 1 0 0 0\n0 0 0 1 0 2 0 0 0 0\n1 1 0 1 2 0 0 0 0 1\n0 1 0 0 2 0 1 1 0 0\n0 1 0 1 0 0 1 1 0 0\n0 1 2 0 0 0 0 1 0 0\n0 0 0 0 0 0 0 0 0 0", "1 1\n1 1\n1 1\n1 1\n1 0\n1 0\n1 1\n1 1\n1 1\n1 1\n1 0\n1 0\n1 1\n1 0\n1 0\n1 0\n2 1\n2 1\n2 1\n2 1\n2 0\n2 0\n2 0\n2 0\n2 1\n2 0\n2 0\n2 1\n2 0\n2 1\n2 1\n2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["Special Judge", "O2优化", "图论建模", "费用流", "网络流与线性规划 24 题"], "title": "火星探险问题 ", "background": "", "description": "火星探险队的登陆舱将在火星表面着陆，登陆舱内有多部障碍物探测车。登陆舱着陆后，探测车将离开登陆舱向先期到达的传送器方向移动。  \n\n探测车在移动中还必须采集岩石标本。每一块岩石标本由最先遇到它的探测车完成采集。每块岩石标本只能被采集一次。岩石标本被采集后，其他探测车可以从原来岩石标本所在处通过。探测车不能通过有障碍的地面。  \n\n本题限定探测车只能从登陆处沿着向南或向东的方向朝传送器移动，而且多个探测车可以在同一时间占据同一位置。如果某个探测车在到达传送器以前不能继续前进，则该车所采集的岩石标本将全部损失。\n\n\n用一个 $p \\times q$ 网格表示登陆舱与传送器之间的位置。登陆舱的位置在 \n$(x_1,y_1)$ 处，传送器的位置在 $(x_py_q)$ 处。\n\n$$\\begin{bmatrix} (x_1,y_1) & (x_2,y_1) & \\dots & (x_{p-1},y_1) & (x_p,y_1) \\\\ (x_1,y_2) & (x_2,y_2) & \\dots & (x_{p-1},y_2) & (x_p,y_2) \\\\ \\dots & \\dots & \\dots & \\dots & \\dots \\\\ (x_1,y_{q-1}) & (x_2,y_{q-1}) & \\dots & (x_{p-1},y_{q-1}) & (x_p,y_{q-1}) \\\\ (x_1,y_q) & (x_2,y_q) & \\dots & (x_{p-1},y_q) & (x_p,y_q) \\end{bmatrix}$$\n\n给定每个位置的状态，计算探测车的最优移动方案，使到达传送器的探测车的数量最多，而且探测车采集到的岩石标本的数量最多。\n", "inputFormat": "第一行为探测车数 $n$，接下来两行分别为 $p,q$。  \n\n接下来的 $q$ 行是表示登陆舱与传送器之间的位置状态的 $p \\times q$ 网格。  \n用三种数表示火星表面位置的状态：$0$ 表示平坦无障碍，$1$ 表示障碍，$2$ 表示石块。\n", "outputFormat": "每行包含探测车号和一个移动方向，$0$ 表示向南移动，$1$ 表示向东移动。\n", "hint": "【数据范围】\n对于 $100\\%$ 的数据，$1 \\le n,p,q \\le 35$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Mars Exploration Problem", "background": "", "description": "The lander of the Mars exploration team will touch down on the Martian surface. Inside the lander, there are multiple obstacle-detecting rovers. After landing, the rovers will leave the lander and move toward the transmitter that arrived earlier.\n\nWhile moving, the rovers must also collect rock samples. Each rock sample is collected by the first rover that encounters it. Each rock sample can be collected only once. After a rock sample is collected, other rovers may pass through its former location. Rovers cannot pass through obstructed terrain.\n\nIn this problem, rovers are limited to moving from the landing position toward the transmitter only in the south or east direction, and multiple rovers may occupy the same position at the same time. If any rover cannot proceed before reaching the transmitter, all rock samples it collected will be lost.\n\nUse a $p \\times q$ grid to represent the positions between the lander and the transmitter. The lander is at $(x_1,y_1)$, and the transmitter is at $(x_p,y_q)$.\n\n$$\\begin{bmatrix} (x_1,y_1) & (x_2,y_1) & \\dots & (x_{p-1},y_1) & (x_p,y_1) \\\\ (x_1,y_2) & (x_2,y_2) & \\dots & (x_{p-1},y_2) & (x_p,y_2) \\\\ \\dots & \\dots & \\dots & \\dots & \\dots \\\\ (x_1,y_{q-1}) & (x_2,y_{q-1}) & \\dots & (x_{p-1},y_{q-1}) & (x_p,y_{q-1}) \\\\ (x_1,y_q) & (x_2,y_q) & \\dots & (x_{p-1},y_q) & (x_p,y_q) \\end{bmatrix}$$\n\nGiven the state of each position, compute the optimal movement plan so that the number of rovers reaching the transmitter is maximized, and the number of rock samples collected by the rovers is also maximized.", "inputFormat": "The first line contains the number of rovers $n$. The next two lines contain $p$ and $q$, respectively.\n\nThe next $q$ lines describe the $p \\times q$ grid of positions between the lander and the transmitter. Three numbers are used to represent the state of a position: $0$ means flat and unobstructed, $1$ means an obstacle, and $2$ means a rock.", "outputFormat": "Each line contains a rover ID and one movement direction, where $0$ means moving south and $1$ means moving east.", "hint": "Constraints\nFor $100\\%$ of the testdata, $1 \\le n, p, q \\le 35$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "火星探险问题 ", "background": "", "description": "火星探险队的登陆舱将在火星表面着陆，登陆舱内有多部障碍物探测车。登陆舱着陆后，探测车将离开登陆舱向先期到达的传送器方向移动。  \n\n探测车在移动中还必须采集岩石标本。每一块岩石标本由最先遇到它的探测车完成采集。每块岩石标本只能被采集一次。岩石标本被采集后，其他探测车可以从原来岩石标本所在处通过。探测车不能通过有障碍的地面。  \n\n本题限定探测车只能从登陆处沿着向南或向东的方向朝传送器移动，而且多个探测车可以在同一时间占据同一位置。如果某个探测车在到达传送器以前不能继续前进，则该车所采集的岩石标本将全部损失。\n\n\n用一个 $p \\times q$ 网格表示登陆舱与传送器之间的位置。登陆舱的位置在 \n$(x_1,y_1)$ 处，传送器的位置在 $(x_py_q)$ 处。\n\n$$\\begin{bmatrix} (x_1,y_1) & (x_2,y_1) & \\dots & (x_{p-1},y_1) & (x_p,y_1) \\\\ (x_1,y_2) & (x_2,y_2) & \\dots & (x_{p-1},y_2) & (x_p,y_2) \\\\ \\dots & \\dots & \\dots & \\dots & \\dots \\\\ (x_1,y_{q-1}) & (x_2,y_{q-1}) & \\dots & (x_{p-1},y_{q-1}) & (x_p,y_{q-1}) \\\\ (x_1,y_q) & (x_2,y_q) & \\dots & (x_{p-1},y_q) & (x_p,y_q) \\end{bmatrix}$$\n\n给定每个位置的状态，计算探测车的最优移动方案，使到达传送器的探测车的数量最多，而且探测车采集到的岩石标本的数量最多。\n", "inputFormat": "第一行为探测车数 $n$，接下来两行分别为 $p,q$。  \n\n接下来的 $q$ 行是表示登陆舱与传送器之间的位置状态的 $p \\times q$ 网格。  \n用三种数表示火星表面位置的状态：$0$ 表示平坦无障碍，$1$ 表示障碍，$2$ 表示石块。\n", "outputFormat": "每行包含探测车号和一个移动方向，$0$ 表示向南移动，$1$ 表示向东移动。\n", "hint": "【数据范围】\n对于 $100\\%$ 的数据，$1 \\le n,p,q \\le 35$。\n", "locale": "zh-CN"}}}
{"pid": "P3357", "type": "P", "difficulty": 6, "samples": [["4 2\n1 2 7 3\n6 5 8 3\n7 8 10 5\n9 6 13 9 ", "17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "网络流与线性规划 24 题"], "title": "最长k可重线段集问题", "background": "", "description": "给定平面 $x-O-y$ 上 $n$ 个开线段组成的集合 $I$，和一个正整数 $k$ 。试设计一个算法，从开线段集合 $I$ 中选取出开线段集合 $S\\subseteq I$ ,使得在 $x$ 轴上的任何一点 $p$，$S$ 中与直线 $x=p$ 相交的开线段个数不超过 $k$，且$\\sum\\limits_{z\\in S}|z|$达到最大。这样的集合 $S$ 称为开线段集合 $I$ 的最长  $k$ 可重线段集。$\\sum\\limits_{z\\in S}|z|$ 称为最长  $k$ 可重线段集的长度。\n\n对于任何开线段 $z$，设其断点坐标为 $(x_0,y_0)$ 和 $(x_1,y_1)$，则开线段 $z$ 的长度 $|z|$ 定义为：\n$$|z|=\\lfloor\\sqrt{(x_1-x_0)^2+(y_1-y_0)^2}\\rfloor$$\n\n对于给定的开线段集合 $I$ 和正整数 $k$，计算开线段集合 $I$ 的最长 $k$ 可重线段集的长度。\n", "inputFormat": "文件的第一 行有 $2$ 个正整数 $n$ 和 $k$，分别表示开线段的个数和开线段的可重叠数。\n\n接下来的 $n$ 行，每行有 $4$ 个整数，表示开线段的 $2$ 个端点坐标。\n", "outputFormat": "程序运行结束时，输出计算出的最长 $k$ 可重线段集的长度。\n", "hint": "$1\\leq n\\leq 500$，$1 \\leq k \\leq 13$，坐标值在 `int` 范围内。\n", "locale": "zh-CN", "translations": {"en": {"title": "Longest k-Overlap Segment Set Problem", "background": "", "description": "Given a set $I$ of $n$ open line segments in the plane $x-O-y$, and a positive integer $k$. Design an algorithm to select a subset $S \\subseteq I$ such that, for any point $p$ on the $x$-axis, the number of open line segments in $S$ that intersect the line $x = p$ does not exceed $k$, and $\\sum\\limits_{z\\in S} |z|$ is maximized. Such a subset $S$ is called the longest $k$-overlap set of open line segments of $I$. The value $\\sum\\limits_{z\\in S} |z|$ is called the length of the longest $k$-overlap segment set.\n\nFor any open line segment $z$ with endpoints $(x_0, y_0)$ and $(x_1, y_1)$, its length $|z|$ is defined as:\n$$|z|=\\lfloor\\sqrt{(x_1-x_0)^2+(y_1-y_0)^2}\\rfloor$$\n\nGiven the open line segment set $I$ and the positive integer $k$, compute the length of the longest $k$-overlap open segment set of $I$.", "inputFormat": "The first line contains $2$ positive integers $n$ and $k$, denoting the number of open line segments and the allowed overlap count.\n\nThe next $n$ lines each contain $4$ integers, giving the coordinates of the $2$ endpoints of an open line segment.", "outputFormat": "Output the computed length of the longest $k$-overlap segment set.", "hint": "Constraints: $1 \\leq n \\leq 500$, $1 \\leq k \\leq 13$, and all coordinates are within the `int` range.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最长k可重线段集问题", "background": "", "description": "给定平面 $x-O-y$ 上 $n$ 个开线段组成的集合 $I$，和一个正整数 $k$ 。试设计一个算法，从开线段集合 $I$ 中选取出开线段集合 $S\\subseteq I$ ,使得在 $x$ 轴上的任何一点 $p$，$S$ 中与直线 $x=p$ 相交的开线段个数不超过 $k$，且$\\sum\\limits_{z\\in S}|z|$达到最大。这样的集合 $S$ 称为开线段集合 $I$ 的最长  $k$ 可重线段集。$\\sum\\limits_{z\\in S}|z|$ 称为最长  $k$ 可重线段集的长度。\n\n对于任何开线段 $z$，设其断点坐标为 $(x_0,y_0)$ 和 $(x_1,y_1)$，则开线段 $z$ 的长度 $|z|$ 定义为：\n$$|z|=\\lfloor\\sqrt{(x_1-x_0)^2+(y_1-y_0)^2}\\rfloor$$\n\n对于给定的开线段集合 $I$ 和正整数 $k$，计算开线段集合 $I$ 的最长 $k$ 可重线段集的长度。\n", "inputFormat": "文件的第一 行有 $2$ 个正整数 $n$ 和 $k$，分别表示开线段的个数和开线段的可重叠数。\n\n接下来的 $n$ 行，每行有 $4$ 个整数，表示开线段的 $2$ 个端点坐标。\n", "outputFormat": "程序运行结束时，输出计算出的最长 $k$ 可重线段集的长度。\n", "hint": "$1\\leq n\\leq 500$，$1 \\leq k \\leq 13$，坐标值在 `int` 范围内。\n", "locale": "zh-CN"}}}
{"pid": "P3358", "type": "P", "difficulty": 6, "samples": [["4 2\n1 7\n6 8\n7 10\n9 13 ", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["网络流", "O2优化", "网络流与线性规划 24 题"], "title": "最长k可重区间集问题", "background": "", "description": "给定实直线 $\\text{L}$ 上 $n$ 个开区间组成的集合 $\\mathbf{I}$，和一个正整数 $k$，试设计一个算法，从开区间集合 $\\mathbf{I}$ 中选取出开区间集合 $\\mathbf{S}\\subseteq\\mathbf{I}$，使得在实直线 $\\text{L}$ 上的任意一点 $x$，$\\text{S}$ 中包含 $x$ 的开区间个数不超过 $k$，且 $\\sum_{z\\in\\text{S}}\\lvert z\\rvert$ 达到最大（$\\lvert z\\rvert$ 表示开区间 $z$ 的长度）。\n\n这样的集合 $\\mathbf{S}$ 称为开区间集合 $\\mathbf{I}$ 的最长 $k$ 可重区间集。$\\sum_{z\\in\\text{S}}\\lvert z\\rvert$ 称为最长 $k$ 可重区间集的长度。\n\n对于给定的开区间集合 $\\mathbf{I}$ 和正整数 $k$，计算开区间集合 $\\mathbf{I}$ 的最长 $k$ 可重区间集的长度。", "inputFormat": "输入的第一行有 $2$ 个正整数 $n$ 和 $k$，分别表示开区间的个数和开区间的可重叠数。接下来的 $n$ 行，每行有 $2$ 个整数，表示开区间的左右端点坐标 $l,r$，数据保证 $l<r$。", "outputFormat": "输出最长 $k$ 可重区间集的长度。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 500$，$1\\le k\\le 3$，$1 \\le l < r \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Longest k-Overlap Interval Set Problem", "background": "", "description": "Given a set $\\mathbf{I}$ of $n$ open intervals on the real line $\\text{L}$ and a positive integer $k$, design an algorithm to select a set of open intervals $\\mathbf{S} \\subseteq \\mathbf{I}$ such that at any point $x$ on $\\text{L}$, the number of intervals in $\\mathbf{S}$ that contain $x$ is at most $k$, and $\\sum_{z \\in \\text{S}} \\lvert z \\rvert$ is maximized ($\\lvert z \\rvert$ denotes the length of the open interval $z$).\n\nSuch a set $\\mathbf{S}$ is called a longest $k$-overlap interval set of $\\mathbf{I}$. The value $\\sum_{z \\in \\text{S}} \\lvert z \\rvert$ is called the length of a longest $k$-overlap interval set.\n\nGiven the set of open intervals $\\mathbf{I}$ and the positive integer $k$, compute the length of a longest $k$-overlap interval set of $\\mathbf{I}$.", "inputFormat": "The first line contains two positive integers $n$ and $k$, denoting the number of open intervals and the allowed maximum number of overlaps. Each of the next $n$ lines contains two integers, the left and right endpoints $l, r$ of an open interval. It is guaranteed that $l < r$.", "outputFormat": "Output the length of a longest $k$-overlap interval set.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 500$, $1 \\le k \\le 3$, $1 \\le l < r \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最长k可重区间集问题", "background": "", "description": "给定实直线 $\\text{L}$ 上 $n$ 个开区间组成的集合 $\\mathbf{I}$，和一个正整数 $k$，试设计一个算法，从开区间集合 $\\mathbf{I}$ 中选取出开区间集合 $\\mathbf{S}\\subseteq\\mathbf{I}$，使得在实直线 $\\text{L}$ 上的任意一点 $x$，$\\text{S}$ 中包含 $x$ 的开区间个数不超过 $k$，且 $\\sum_{z\\in\\text{S}}\\lvert z\\rvert$ 达到最大（$\\lvert z\\rvert$ 表示开区间 $z$ 的长度）。\n\n这样的集合 $\\mathbf{S}$ 称为开区间集合 $\\mathbf{I}$ 的最长 $k$ 可重区间集。$\\sum_{z\\in\\text{S}}\\lvert z\\rvert$ 称为最长 $k$ 可重区间集的长度。\n\n对于给定的开区间集合 $\\mathbf{I}$ 和正整数 $k$，计算开区间集合 $\\mathbf{I}$ 的最长 $k$ 可重区间集的长度。", "inputFormat": "输入的第一行有 $2$ 个正整数 $n$ 和 $k$，分别表示开区间的个数和开区间的可重叠数。接下来的 $n$ 行，每行有 $2$ 个整数，表示开区间的左右端点坐标 $l,r$，数据保证 $l<r$。", "outputFormat": "输出最长 $k$ 可重区间集的长度。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 500$，$1\\le k\\le 3$，$1 \\le l < r \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3359", "type": "P", "difficulty": 6, "samples": [["4\n1 2 0\n2 3 0\n2 4 0\n3 1 2", "6\n3\n1\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "洛谷原创", "洛谷月赛"], "title": "改造异或树", "background": null, "description": "给定一棵 $n$ 个点的树，每条边上都有一个权值。现在按顺序删掉所有的 $n-1$ 条边，每删掉一条边询问当前有多少条路径满足路径上所有边权值异或和为 $0$。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n-1$ 行，每行三个整数 $a_i,b_i,z_i$，满足 $1\\le ai,bi\\le n$，表示树上编号为 $a_i$ 的点和编号为$b_i$ 的点中间连有一条权值为 $z_i$ 的边。\n\n接下来一行 $n-1$ 个整数，两两之间有一个空格隔开，表示一个 $1\\sim n- 1$ 的排列，表示 $n - 1$ 条边的删边顺序。", "outputFormat": "输出 $n$ 行，每行一个整数，依次表示删掉第 $0\\sim  n - 1$ 条边之后的边权异或和为零的路径数。", "hint": "对于 $20\\%$ 数据，满足 $n\\le 1000$。\n\n对于另外 $30\\%$ 数据，满足所有的 $z_i = 0$。\n\n对于全部数据，满足 $n\\le 10^5,0\\le z_i\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Transform the XOR Tree", "background": "", "description": "You are given a tree with $n$ nodes, and each edge has a weight. Now we delete all $n - 1$ edges one by one in a given order. After deleting each edge, query how many paths currently have the XOR sum of edge weights equal to $0$.", "inputFormat": "The first line contains an integer $n$.\n\nThe next $n - 1$ lines each contain three integers $a_i, b_i, z_i$, with $1 \\le a_i, b_i \\le n$, indicating that there is an edge with weight $z_i$ between nodes numbered $a_i$ and $b_i$.\n\nThe next line contains $n - 1$ integers separated by single spaces, which form a permutation of $1 \\sim n - 1$, representing the deletion order of the $n - 1$ edges.", "outputFormat": "Output $n$ lines, each containing one integer. The $k$-th line (where $k = 0, 1, \\dots, n - 1$) is the number of paths whose XOR sum of edge weights is $0$ after deleting the first $k$ edges in the given order.", "hint": "For $20\\%$ of the testdata, $n \\le 1000$.\n\nFor another $30\\%$ of the testdata, all $z_i = 0$.\n\nFor all testdata, $n \\le 10^5$, $0 \\le z_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "改造异或树", "background": null, "description": "给定一棵 $n$ 个点的树，每条边上都有一个权值。现在按顺序删掉所有的 $n-1$ 条边，每删掉一条边询问当前有多少条路径满足路径上所有边权值异或和为 $0$。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n-1$ 行，每行三个整数 $a_i,b_i,z_i$，满足 $1\\le ai,bi\\le n$，表示树上编号为 $a_i$ 的点和编号为$b_i$ 的点中间连有一条权值为 $z_i$ 的边。\n\n接下来一行 $n-1$ 个整数，两两之间有一个空格隔开，表示一个 $1\\sim n- 1$ 的排列，表示 $n - 1$ 条边的删边顺序。", "outputFormat": "输出 $n$ 行，每行一个整数，依次表示删掉第 $0\\sim  n - 1$ 条边之后的边权异或和为零的路径数。", "hint": "对于 $20\\%$ 数据，满足 $n\\le 1000$。\n\n对于另外 $30\\%$ 数据，满足所有的 $z_i = 0$。\n\n对于全部数据，满足 $n\\le 10^5,0\\le z_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3360", "type": "P", "difficulty": 5, "samples": [["50 \n5 0 10 1 10 1 5 0 10 2 500 1 1000 2 18 1 1000000 4 ", "1500"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["树形 DP"], "title": "偷天换日", "background": "神偷对艺术馆内的名画垂涎欲滴准备大捞一把。", "description": "艺术馆由若干个展览厅和若干条走廊组成。每一条走廊的尽头不是通向一个展览厅，就是分为两个走廊。\n\n每个展览厅内都有若干幅画，每副画都有一个价值。经过走廊和偷画都是要耗费时间的。\n\n警察会在 $n$ 秒时到达进口，如果你此时仍未离开将会遭到逮捕，所以你要计算出在此之前你最多能得到的画的价值。\n\n![](https://cdn.luogu.com.cn/upload/pic/2730.png)", "inputFormat": "第一行一个整数 $n (n \\leq 600)$。\n\n第二行若干组整数 $(t,x)(t \\leq 5,x \\leq 30)$，对于每组整数 ，$t$ 表示进入这个展览厅或经过走廊要耗费 $t$ 秒的时间，若 $x>0$ 表示走廊通向的展览厅内有 $x$ 幅画，否则若 $x=0$ 表示走廊一分为二，接下来 $x$ 对整数 $(w,c)(w \\leq 10^6,c \\leq 5)$ 表示偷一幅价值为 $w$ 的画需要 $c$ 秒的时间。\n\n输入是按深度优先给出的。房间和走廊数不超过 $300$ 个。", "outputFormat": "仅一个整数，表示能获得的最大价值。", "hint": "来源：改编", "locale": "zh-CN", "translations": {"en": {"title": "Steal the Sky, Swap the Sun", "background": "A master thief covets the masterpieces in the art museum and is ready for a big haul.", "description": "The art museum consists of several exhibition rooms and several corridors. Each corridor either ends at an exhibition room, or splits into two corridors.\n\nEach exhibition room contains several paintings, and each painting has a value. Traversing a corridor and stealing a painting both take time.\n\nThe police will arrive at the entrance in $n$ seconds. Find the maximum total value you can obtain without being caught.\n\n![](https://cdn.luogu.com.cn/upload/pic/2730.png)", "inputFormat": "- The first line contains an integer $n$ ($n \\leq 600$).\n- Starting from the second line, a sequence is given in depth-first order. For each entry, read a pair $(t, x)$:\n  - $t$ is the time in seconds to either enter an exhibition room or traverse a corridor.\n  - If $x > 0$, the corridor leads to an exhibition room containing $x$ paintings, followed by $x$ pairs $(w, c)$, where stealing one painting of value $w$ takes $c$ seconds.\n  - If $x = 0$, the corridor splits into two sub-corridors; the descriptions of these two sub-corridors follow immediately in depth-first order.\n  - Constraints: $t, c \\leq 5; x \\leq 30$.\n- The numbers of rooms and corridors do not exceed $300$.\n- The input is given in depth-first order.", "outputFormat": "Output a single integer, the maximum total value that can be obtained.", "hint": "Source: adapted.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "偷天换日", "background": "神偷对艺术馆内的名画垂涎欲滴准备大捞一把。", "description": "艺术馆由若干个展览厅和若干条走廊组成。每一条走廊的尽头不是通向一个展览厅，就是分为两个走廊。\n\n每个展览厅内都有若干幅画，每副画都有一个价值。经过走廊和偷画都是要耗费时间的。\n\n警察会在 $n$ 秒时到达进口，如果你此时仍未离开将会遭到逮捕，所以你要计算出在此之前你最多能得到的画的价值。\n\n![](https://cdn.luogu.com.cn/upload/pic/2730.png)", "inputFormat": "第一行一个整数 $n (n \\leq 600)$。\n\n第二行若干组整数 $(t,x)(t \\leq 5,x \\leq 30)$，对于每组整数 ，$t$ 表示进入这个展览厅或经过走廊要耗费 $t$ 秒的时间，若 $x>0$ 表示走廊通向的展览厅内有 $x$ 幅画，否则若 $x=0$ 表示走廊一分为二，接下来 $x$ 对整数 $(w,c)(w \\leq 10^6,c \\leq 5)$ 表示偷一幅价值为 $w$ 的画需要 $c$ 秒的时间。\n\n输入是按深度优先给出的。房间和走廊数不超过 $300$ 个。", "outputFormat": "仅一个整数，表示能获得的最大价值。", "hint": "来源：改编", "locale": "zh-CN"}}}
{"pid": "P3361", "type": "P", "difficulty": 4, "samples": [["6\n3 5 7 11 13 17", "17.52167"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "洛谷原创", "洛谷月赛"], "title": "Cool loves maids", "background": "Cool 非常喜欢妹子，以至于 Cool 在百度上有一个非常神奇的 ID 【雾】。", "description": "Cool 现在搞清楚了女生宿舍的地形。女生宿舍是由很多栋楼构成的，它们可以被抽象成 $20\\times 20$ 的方格。\n\nCool 的妹子们所处的地方可以被表示为实数类型的坐标。当一个妹子 $(x,y)$ 在楼 $(i,j)$ 中，当且仅当 $i \\le x<i+1$，$j \\le y<j+1$，$i,j\\in \\Z$。两个妹子之间有距离，当且仅当一个妹子所在的楼的横纵坐标均小于另一个妹子所在的楼，此时她们之间的距离为她们自身坐标的曼哈顿距离。\n\n现在 Cool 要搞一个大统计：求 $n$ 个妹子之间所有距离之和。", "inputFormat": "为了避免输入文件过大无法上传在读入方面消耗过多时间，本题采取数据生成方案。\n\n输入包含两行：\n\n- 第一行，一个整数 $n$；\n- 第二行，包含 $6$ 个整数 $\\mathrm{rxa},\\mathrm{rxc},\\mathrm{rya},\\mathrm{ryc},\\mathrm{rza},\\mathrm{rzc}$。\n\n所有的实数都采用如下方式生成：\n\n1. 初始化 $x=y=z=0$；\n2. 重复以下过程：  \n   - $x=(y\\times \\mathrm{rxa}+\\mathrm{rxc})\\bmod \\mathrm{rp}$；\n   - $y=(z\\times \\mathrm{rya}+\\mathrm{ryc})\\bmod \\mathrm{rp}$；\n   - $z=(x\\times \\mathrm{rza}+\\mathrm{rzc})\\bmod \\mathrm{rp}$。\n\n每次得到的实数即为 $(x\\bmod 20)+(y\\bmod 10)\\div 10+(z\\bmod 10)\\div 100$。$\\mathrm{rp}=2333333$。\n\n第 $i$ 个妹子将以第 $2i-1$ 个生成实数为横坐标，第 $2i$ 个生成实数为纵坐标。", "outputFormat": "输出包含一行一个实数，表示 $n$ 个妹子之间所有距离之和的平均值，保留 $5$ 位小数。\n", "hint": "### 数据范围及约定\n\n对于全部数据，保证 $1\\le n\\le 5\\times 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "Cool loves maids", "background": "Cool likes girls very much, to the extent that Cool has a rather mysterious ID on Baidu [fog].", "description": "Cool has now figured out the layout of the women’s dormitory. The dormitory consists of many buildings, which can be abstracted as a $20\\times 20$ grid.\n\nThe places where Cool’s maids are located can be represented by real-valued coordinates. A maid $(x, y)$ is in building $(i, j)$ if and only if $i \\le x < i + 1$, $j \\le y < j + 1$, $i, j \\in \\Z$. The distance between two maids is defined if and only if both the row and column indices of one maid’s building are strictly less than those of the other maid’s building; in that case, their distance is the Manhattan distance between their own coordinates.\n\nNow Cool wants to compile a big statistic: compute the sum of all distances among $n$ maids.", "inputFormat": "To avoid spending too much time on reading due to large input files that cannot be uploaded, this problem uses a data generation scheme.\n\nThe input contains two lines:\n\n- The first line contains an integer $n$.\n- The second line contains $6$ integers $\\mathrm{rxa}, \\mathrm{rxc}, \\mathrm{rya}, \\mathrm{ryc}, \\mathrm{rza}, \\mathrm{rzc}$.\n\nAll real numbers are generated as follows:\n\n1. Initialize $x = y = z = 0$.\n2. Repeat the following process:\n   - $x = (y \\times \\mathrm{rxa} + \\mathrm{rxc}) \\bmod \\mathrm{rp}$;\n   - $y = (z \\times \\mathrm{rya} + \\mathrm{ryc}) \\bmod \\mathrm{rp}$;\n   - $z = (x \\times \\mathrm{rza} + \\mathrm{rzc}) \\bmod \\mathrm{rp}$.\n\nEach time, the real number obtained is $(x \\bmod 20) + (y \\bmod 10) \\div 10 + (z \\bmod 10) \\div 100$. $\\mathrm{rp} = 2333333$.\n\nThe $i$-th maid uses the $(2i - 1)$-th generated real number as the $x$-coordinate, and the $2i$-th generated real number as the $y$-coordinate.", "outputFormat": "Output a single real number on one line, representing the average of all distances among the $n$ maids, with $5$ decimal places.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $1 \\le n \\le 5 \\times 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Cool loves maids", "background": "Cool 非常喜欢妹子，以至于 Cool 在百度上有一个非常神奇的 ID 【雾】。", "description": "Cool 现在搞清楚了女生宿舍的地形。女生宿舍是由很多栋楼构成的，它们可以被抽象成 $20\\times 20$ 的方格。\n\nCool 的妹子们所处的地方可以被表示为实数类型的坐标。当一个妹子 $(x,y)$ 在楼 $(i,j)$ 中，当且仅当 $i \\le x<i+1$，$j \\le y<j+1$，$i,j\\in \\Z$。两个妹子之间有距离，当且仅当一个妹子所在的楼的横纵坐标均小于另一个妹子所在的楼，此时她们之间的距离为她们自身坐标的曼哈顿距离。\n\n现在 Cool 要搞一个大统计：求 $n$ 个妹子之间所有距离之和。", "inputFormat": "为了避免输入文件过大无法上传在读入方面消耗过多时间，本题采取数据生成方案。\n\n输入包含两行：\n\n- 第一行，一个整数 $n$；\n- 第二行，包含 $6$ 个整数 $\\mathrm{rxa},\\mathrm{rxc},\\mathrm{rya},\\mathrm{ryc},\\mathrm{rza},\\mathrm{rzc}$。\n\n所有的实数都采用如下方式生成：\n\n1. 初始化 $x=y=z=0$；\n2. 重复以下过程：  \n   - $x=(y\\times \\mathrm{rxa}+\\mathrm{rxc})\\bmod \\mathrm{rp}$；\n   - $y=(z\\times \\mathrm{rya}+\\mathrm{ryc})\\bmod \\mathrm{rp}$；\n   - $z=(x\\times \\mathrm{rza}+\\mathrm{rzc})\\bmod \\mathrm{rp}$。\n\n每次得到的实数即为 $(x\\bmod 20)+(y\\bmod 10)\\div 10+(z\\bmod 10)\\div 100$。$\\mathrm{rp}=2333333$。\n\n第 $i$ 个妹子将以第 $2i-1$ 个生成实数为横坐标，第 $2i$ 个生成实数为纵坐标。", "outputFormat": "输出包含一行一个实数，表示 $n$ 个妹子之间所有距离之和的平均值，保留 $5$ 位小数。\n", "hint": "### 数据范围及约定\n\n对于全部数据，保证 $1\\le n\\le 5\\times 10^6$。", "locale": "zh-CN"}}}
{"pid": "P3362", "type": "P", "difficulty": 5, "samples": [["10 2 2\n4 5\n8 10", "47\n306"], ["1000 0 1\n720 720", "30"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["数学", "2016", "洛谷原创", "洛谷月赛"], "title": "Cool loves shaxian", "background": "Cool 非常非常喜欢吃沙县,确切地说,他非常非常把各种无辜群众拉到沙县去吃饭(╯‵□′)╯(┻━┻。大家都非常非常想知道沙县到底给了 Cool 多少钱带盐沙县小吃,以便未来威逼利诱 Cool 来请客吃隔壁的 KFC。经过多方追踪,大家发现了带盐费发放的某一些规律ヾ(o◕∀◕)ノヾ。\n", "description": "沙县发放带盐费以壕著称。这家沙县发放带盐费时有个指数 $d$。他会发放 $n$ 轮带盐费，在第 $i$ 轮中，都会发放 $f(i) = \\sum_{k|i} k^d (i \\leq n)$ 这么多的钱。\n\n现在大家有了 $Q$ 个问题，每个问题都形如 Cool 参加从第 $L_i$ 轮到第 $R_i$ 轮的带盐活动，将能获得多少钱。（保证 $1 \\leq L_i \\leq R_i \\leq n$）\n\n由于开在南大街的沙县小吃不是一般的有钱啊，所以呢，我们要计算的是 Cool 收到的钱对 $10^ 9 + 7$ 取模得到的答案。\n", "inputFormat": "输入包含若干行。\n\n第一行，三个整数，$n, d, Q$。（$n\\leq 10^7$，$d\\leq 10^{18}$，$q\\leq 5\\times 10^4$。\n\n接下来的 $Q$ 行,每行两个整数 $L_i, R_i$。\n", "outputFormat": "输出包含 $Q$ 行。\n\n每行一个整数，表示 Cool 得到的带盐费。\n", "hint": "样例 $1$：\n\n$f(4) = 1^2 + 2^2 + 4^2 = 21$\n\n$f(5) =1^2+5^2= 26$\n\n$f(8) + f(9) + f (10) = 85 + 91 + 130= 306$\n\n样例 $2$：\n\n就相当于在数 $720$ 的因数个数呢~\n", "locale": "zh-CN", "translations": {"en": {"title": "Cool loves shaxian", "background": "Cool really, really loves eating at Shaxian. To be precise, he really, really likes dragging all kinds of unsuspecting folks to Shaxian for meals (╯‵□′)╯(┻━┻. Everyone is dying to know how much money Shaxian has paid Cool to \"endorse\" (dàiyán) Shaxian Snacks, so that in the future they can threaten and cajole Cool into treating them to the KFC next door. After much tracking, people discovered some patterns in how the endorsement fees are paid out ヾ(o◕∀◕)ノヾ。", "description": "Shaxian is famous for being lavish when paying endorsement (dàiyán) fees. When this Shaxian pays endorsement fees, it uses an exponent $d$. It will pay fees for $n$ rounds. In the $i$-th round, it pays $f(i) = \\sum_{k|i} k^d (i \\leq n)$ money.\n\nNow there are $Q$ queries. Each query asks: if Cool participates from round $L_i$ to round $R_i$, how much money will he receive? (It is guaranteed that $1 \\leq L_i \\leq R_i \\leq n$.)\n\nSince the Shaxian Snacks on South Street is insanely rich, we need to compute the answer modulo $10^ 9 + 7$.", "inputFormat": "The input contains multiple lines.\n\nThe first line contains three integers, $n, d, Q$ ($n\\leq 10^7$, $d\\leq 10^{18}$, $Q\\leq 5\\times 10^4$).\n\nThe next $Q$ lines each contain two integers $L_i, R_i$.", "outputFormat": "The output contains $Q$ lines.\n\nEach line contains one integer, the amount of endorsement fee Cool receives.", "hint": "Sample 1:\n\n$f(4) = 1^2 + 2^2 + 4^2 = 21$.\n\n$f(5) =1^2+5^2= 26$.\n\n$f(8) + f(9) + f (10) = 85 + 91 + 130= 306$.\n\nSample 2:\n\nThis is essentially the number of divisors of the number $720$~.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Cool loves shaxian", "background": "Cool 非常非常喜欢吃沙县,确切地说,他非常非常把各种无辜群众拉到沙县去吃饭(╯‵□′)╯(┻━┻。大家都非常非常想知道沙县到底给了 Cool 多少钱带盐沙县小吃,以便未来威逼利诱 Cool 来请客吃隔壁的 KFC。经过多方追踪,大家发现了带盐费发放的某一些规律ヾ(o◕∀◕)ノヾ。\n", "description": "沙县发放带盐费以壕著称。这家沙县发放带盐费时有个指数 $d$。他会发放 $n$ 轮带盐费，在第 $i$ 轮中，都会发放 $f(i) = \\sum_{k|i} k^d (i \\leq n)$ 这么多的钱。\n\n现在大家有了 $Q$ 个问题，每个问题都形如 Cool 参加从第 $L_i$ 轮到第 $R_i$ 轮的带盐活动，将能获得多少钱。（保证 $1 \\leq L_i \\leq R_i \\leq n$）\n\n由于开在南大街的沙县小吃不是一般的有钱啊，所以呢，我们要计算的是 Cool 收到的钱对 $10^ 9 + 7$ 取模得到的答案。\n", "inputFormat": "输入包含若干行。\n\n第一行，三个整数，$n, d, Q$。（$n\\leq 10^7$，$d\\leq 10^{18}$，$q\\leq 5\\times 10^4$。\n\n接下来的 $Q$ 行,每行两个整数 $L_i, R_i$。\n", "outputFormat": "输出包含 $Q$ 行。\n\n每行一个整数，表示 Cool 得到的带盐费。\n", "hint": "样例 $1$：\n\n$f(4) = 1^2 + 2^2 + 4^2 = 21$\n\n$f(5) =1^2+5^2= 26$\n\n$f(8) + f(9) + f (10) = 85 + 91 + 130= 306$\n\n样例 $2$：\n\n就相当于在数 $720$ 的因数个数呢~\n", "locale": "zh-CN"}}}
{"pid": "P3363", "type": "P", "difficulty": 6, "samples": [["5 4 3\n1 2\n1 3\n1 4\n4 5\n2 3\n3 5\n2 5\n4 5", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "洛谷原创", "洛谷月赛"], "title": "Cool loves jiaoyi", "background": "Cool 交易得十分熟练。现在 Cool 即将参加一场 NOIP 普及组模拟赛。Cool 什么都不会，他将通过交易来获得每一题的题解 / 标程。", "description": "Cool 的交易对象构成了一个树形结构。\n\n对于每一场轰轰烈烈的交易，都会有一个交易起点和交易终点。在树上从交易起点到交易终点的路径称作交易链，交易链上的所有交易对象都将加入这场交易，交易的代价即为交易对象数。\n\n现在 Cool 面临着 $m$ 场交易，现在 Cool 要钦点 $k$ 场交易，使得存在某个神秘交易对象参与了所有 $k$ 场交易，并且最小化这 $k$ 场交易中代价之差的最大值。", "inputFormat": "输入包含若干行。\n\n第一行三个整数 $n,m,k$，代表交易对象数、交易场数和 Cool 钦定的 $k$。接下来的 $n-1$ 行，每行两个整数 $u,v$ 代表交易对象 $u,v$ 在交易树上相连。\n\n接下来的 $m$ 行，每行两个整数 $s,t$，表示每场交易的交易起点和交易终点（起点终点可以重合）。", "outputFormat": "输出包含一个整数，表示 Cool 钦点的最小的最大代价之差，若不存在这样的 $k$ 场交易，输出 $-1$。", "hint": "### 数据范围\n\n$1\\leq n\\leq 5\\times 10^4,1\\leq k\\leq m\\leq 10^4.$\n\n### 样例解释\n\n选择第 $1,2,3$ 三场交易，则交易对象 $1$ 被同时交易了 $3$ 次，且三场交易的代价分别为 $3,4,4$。他们交易代价之差最大为 $4-3$。此时最优。", "locale": "zh-CN", "translations": {"en": {"title": "Cool loves jiaoyi", "background": "Cool is very skilled at trading. Now Cool is about to take part in a NOIP Junior mock contest. Cool knows nothing, so he will obtain each problem’s editorial / standard solution through trading.", "description": "Cool’s trading partners form a tree.\n\nFor each trade, there is a start and an end. The path from the start to the end on the tree is called the trade chain. All trading partners (nodes) on the trade chain join this trade, and the cost of the trade equals the number of trading partners on the chain.\n\nNow there are $m$ trades. Cool will designate $k$ trades such that there exists a mysterious trading partner who participates in all these $k$ trades, and he wants to minimize the maximum difference of costs among these $k$ trades (i.e., minimize max cost $-$ min cost).", "inputFormat": "The input consists of several lines.\n\n- The first line contains three integers $n, m, k$, representing the number of trading partners, the number of trades, and the designated $k$.\n- Each of the next $n-1$ lines contains two integers $u, v$, indicating that trading partners $u$ and $v$ are connected in the trading tree.\n- Each of the next $m$ lines contains two integers $s, t$, representing the start and end of a trade (the start and end may coincide).", "outputFormat": "Output a single integer, the minimal possible value of the maximum cost difference among the designated trades. If no such set of $k$ trades exists, output $-1$.", "hint": "Constraints\n\n$1\\leq n\\leq 5\\times 10^4, 1\\leq k\\leq m\\leq 10^4.$\n\nSample Explanation\n\nChoose trades $1, 2, 3$. Trading partner $1$ participates in all three trades, and the three costs are $3, 4, 4$. Their maximum cost difference is $4-3$. This is optimal.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Cool loves jiaoyi", "background": "Cool 交易得十分熟练。现在 Cool 即将参加一场 NOIP 普及组模拟赛。Cool 什么都不会，他将通过交易来获得每一题的题解 / 标程。", "description": "Cool 的交易对象构成了一个树形结构。\n\n对于每一场轰轰烈烈的交易，都会有一个交易起点和交易终点。在树上从交易起点到交易终点的路径称作交易链，交易链上的所有交易对象都将加入这场交易，交易的代价即为交易对象数。\n\n现在 Cool 面临着 $m$ 场交易，现在 Cool 要钦点 $k$ 场交易，使得存在某个神秘交易对象参与了所有 $k$ 场交易，并且最小化这 $k$ 场交易中代价之差的最大值。", "inputFormat": "输入包含若干行。\n\n第一行三个整数 $n,m,k$，代表交易对象数、交易场数和 Cool 钦定的 $k$。接下来的 $n-1$ 行，每行两个整数 $u,v$ 代表交易对象 $u,v$ 在交易树上相连。\n\n接下来的 $m$ 行，每行两个整数 $s,t$，表示每场交易的交易起点和交易终点（起点终点可以重合）。", "outputFormat": "输出包含一个整数，表示 Cool 钦点的最小的最大代价之差，若不存在这样的 $k$ 场交易，输出 $-1$。", "hint": "### 数据范围\n\n$1\\leq n\\leq 5\\times 10^4,1\\leq k\\leq m\\leq 10^4.$\n\n### 样例解释\n\n选择第 $1,2,3$ 三场交易，则交易对象 $1$ 被同时交易了 $3$ 次，且三场交易的代价分别为 $3,4,4$。他们交易代价之差最大为 $4-3$。此时最优。", "locale": "zh-CN"}}}
{"pid": "P3364", "type": "P", "difficulty": 6, "samples": [["3\n1 2 3 1\n2 1 2 2\n3 1 3 3", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2016", "洛谷原创", "cdq 分治", "O2优化", "洛谷月赛"], "title": "Cool loves touli", "background": "Cool 一直都很崇拜 touli。\n", "description": "有一天 Cool 和 touli 在打多校，突然开始讨论怎么样的阵容比较厉害。Cool 觉得一个阵容，将他们的等级从低到高排序后，攻击力应该是递增的。Cool 就问 touli 这个阵容最多有几个人。\n\n不过 touli 觉得这个问题实在太 SB，就改变了条件，他认为等级从低到高排序后，对于任意两个排序后相邻的英雄，等级低的英雄的攻击力应该不大于等级高的英雄的力量，等级高的英雄的攻击力应当不小于等级低的英雄的智力。\n\n现在 Cool 想知道若干个英雄中，最多能选出多少个英雄加入阵容。", "inputFormat": "第一行 $n$ 表示有 $n$ 个英雄。\n\n接下来 $n$ 行，每行 $4$ 个整数 $l,s,w,a$，分别表示该英雄的等级、力量、智力、攻击力。", "outputFormat": "一个数,表示最多能选出的英雄个数。\n", "hint": "选择第 $1$ 个和第 $3$ 个英雄，符合条件。对于第 $1$ 个和第 $2$ 个英雄，第 $2$ 个英雄的攻击力小于第 $1$ 个英雄的智力，所以不能同时存在。\n\n$n\\leq 10^5$，$l,s,w,a\\le10^8$，$l$ 互不相同。", "locale": "zh-CN", "translations": {"en": {"title": "Cool loves touli", "background": "Cool has always admired touli.", "description": "One day, while Cool and touli were participating in a multi-school contest, they started discussing what kind of lineup would be strong. Cool thought that in a lineup, after sorting heroes by level from low to high, their attack values should be increasing. Cool then asked touli what the maximum possible size of such a lineup would be.\n\nHowever, touli felt this question was too trivial, so he changed the condition: after sorting by level from low to high, for any two adjacent heroes in this order, the lower-level hero’s attack must be no greater than the higher-level hero’s strength, and the higher-level hero’s attack must be no less than the lower-level hero’s intelligence.\n\nNow Cool wants to know, among several heroes, what is the maximum number of heroes that can be selected to form such a lineup.", "inputFormat": "The first line $n$ indicates there are $n$ heroes.\n\nThe next $n$ lines each contain $4$ integers $l, s, w, a$, representing that hero’s level, strength, intelligence, and attack, respectively.", "outputFormat": "A single integer, the maximum number of heroes that can be selected.", "hint": "Selecting the $1$st and $3$rd heroes satisfies the condition. For the $1$st and $2$nd heroes, the $2$nd hero’s attack is less than the $1$st hero’s intelligence, so they cannot both be in the lineup.\n\nConstraints: $n \\leq 10^5$, $l, s, w, a \\le 10^8$, and the $l$ values are pairwise distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Cool loves touli", "background": "Cool 一直都很崇拜 touli。\n", "description": "有一天 Cool 和 touli 在打多校，突然开始讨论怎么样的阵容比较厉害。Cool 觉得一个阵容，将他们的等级从低到高排序后，攻击力应该是递增的。Cool 就问 touli 这个阵容最多有几个人。\n\n不过 touli 觉得这个问题实在太 SB，就改变了条件，他认为等级从低到高排序后，对于任意两个排序后相邻的英雄，等级低的英雄的攻击力应该不大于等级高的英雄的力量，等级高的英雄的攻击力应当不小于等级低的英雄的智力。\n\n现在 Cool 想知道若干个英雄中，最多能选出多少个英雄加入阵容。", "inputFormat": "第一行 $n$ 表示有 $n$ 个英雄。\n\n接下来 $n$ 行，每行 $4$ 个整数 $l,s,w,a$，分别表示该英雄的等级、力量、智力、攻击力。", "outputFormat": "一个数,表示最多能选出的英雄个数。\n", "hint": "选择第 $1$ 个和第 $3$ 个英雄，符合条件。对于第 $1$ 个和第 $2$ 个英雄，第 $2$ 个英雄的攻击力小于第 $1$ 个英雄的智力，所以不能同时存在。\n\n$n\\leq 10^5$，$l,s,w,a\\le10^8$，$l$ 互不相同。", "locale": "zh-CN"}}}
{"pid": "P3365", "type": "P", "difficulty": 5, "samples": [["3\n2 2 2\n1 0\n1 1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2016", "洛谷原创", "洛谷月赛"], "title": "改造二叉树", "background": "勤奋又善于思考的小 L 接触了信息学竞赛，开始的学习十分顺利。但是，小 L 对数据结构的掌握实在十分渣渣。\n\n所以，小 L 当时卡在了二叉树。", "description": "在计算机科学中，二叉树是每个结点最多有两个子结点的有序树。通常子结点被称作“左孩子”和“右孩子”。二叉树被用作二叉搜索树和二叉堆。随后他又和他人讨论起了二叉搜索树。什么是二叉搜索树呢？二叉搜索树首先是一棵二叉树。设 $key_p$ 表示结点 $p$ 上的数值。对于其中的每个结点 $p$，若其存在左孩子 $lch$，则 $key_p>key_{lch}$；若其存在右孩子 $rch$，则 $key_p<key_{rch}$；注意，本题中的二叉搜索树应满足对于所有结点，其左子树中的 $key$ 小于当前结点的 $key$，其右子树中的 $key$ 大于当前结点的 $key$。（因为小 L 十分喜欢装 xx，所以这里他十分装 xx 的给大家介绍了什么是二叉树和二叉搜索树）。\n\n可是善于思考的小 L 不甘于只学习这些基础的东西。他思考了这样一个问题：现在给定一棵二叉树，可以任意修改结点的数值。修改一个结点的数值算作一次修改，且这个结点不能再被修改。若要将其变成一棵二叉搜索树，且任意时刻结点的数值必须是整数（可以是负整数或 $0$），所要的最少修改次数。\n\n这一定难不倒聪明的你吧！如果你能帮小 L 解决这个问题，也许他会把最后的资产分给你 $\\dfrac{1}{16}$ 哦！", "inputFormat": "第一行一个正整数 $n$ 表示二叉树节点数。\n\n第二行 $n$ 个正整数用空格分隔开，第 $i$ 个数 $a_i$ 表示结点 $i$ 的原始数值。\n\n此后 $n-1$ 行每行两个非负整数 $fa$，$ch$，第 $i+2$ 行描述结点 $i+1$ 的父亲编号 $fa$，以及父子关系 $ch$，（$ch = 0$ 表示 $i+1$ 为左儿子，$ch = 1$ 表示 $i + 1$ 为右儿子）。\n\n为了让你稍微减轻些负担，小 L 规定：结点 $1$ 一定是二叉树的根哦！", "outputFormat": "仅一行包含一个整数，表示最少的修改次数。", "hint": "对于 $20\\%$ 的数据：$n \\leq 10$，$a_i \\leq 100$。\n\n对于 $40\\%$ 的数据：$n \\leq 100$，$a_i \\leq 200$。\n\n对于 $60\\%$ 的数据：$n \\leq 2000$。\n\n对于 $100\\%$ 的数据：$n \\leq 10^5$，$a_i < 2^{31}$。", "locale": "zh-CN", "translations": {"en": {"title": "Transforming a Binary Tree", "background": "Diligent and thoughtful Xiao L started learning for the informatics competition, and the beginning went very well. However, Xiao L’s grasp of data structures was really weak.\n\nSo, Xiao L got stuck on binary trees.", "description": "In computer science, a binary tree is an ordered tree in which each node has at most two children. The children are usually called the “left child” and the “right child.” Binary trees are used as binary search trees and binary heaps. Then he discussed binary search trees with others. What is a binary search tree? A binary search tree is first a binary tree. Let $key_p$ denote the value stored at node $p$. For each node $p$, if it has a left child $lch$, then $key_p > key_{lch}$; if it has a right child $rch$, then $key_p < key_{rch}$. Note that in this problem, the binary search tree must satisfy: for every node, all keys in its left subtree are less than the node’s key, and all keys in its right subtree are greater than the node’s key.\n\nBut thoughtful Xiao L is not satisfied with only learning the basics. He considered this problem: given a binary tree, you can arbitrarily change the values of nodes. Changing the value of a node counts as one modification, and that node cannot be modified again. You want to transform it into a binary search tree, and at any time the value of every node must be an integer (it can be negative or $0$). What is the minimum number of modifications required?\n\nThis surely won’t stump you! If you help Xiao L solve this problem, maybe he will give you $\\dfrac{1}{16}$ of his final assets.", "inputFormat": "The first line contains a positive integer $n$, the number of nodes in the binary tree.\n\nThe second line contains $n$ positive integers separated by spaces. The $i$-th number $a_i$ is the original value of node $i$.\n\nThen follow $n - 1$ lines, each containing two non-negative integers $fa$ and $ch$. The $(i + 2)$-th line describes the parent index $fa$ of node $i + 1$ and the parent-child relation $ch$ ($ch = 0$ means $i + 1$ is the left child, $ch = 1$ means $i + 1$ is the right child).\n\nTo make it a bit easier for you, Xiao L guarantees that node $1$ is the root of the binary tree.", "outputFormat": "Output a single line containing one integer, the minimum number of modifications.", "hint": "Constraints\n\n- For $20\\%$ of the testdata: $n \\leq 10$, $a_i \\leq 100$.\n- For $40\\%$ of the testdata: $n \\leq 100$, $a_i \\leq 200$.\n- For $60\\%$ of the testdata: $n \\leq 2000$.\n- For $100\\%$ of the testdata: $n \\leq 10^5$, $a_i < 2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "改造二叉树", "background": "勤奋又善于思考的小 L 接触了信息学竞赛，开始的学习十分顺利。但是，小 L 对数据结构的掌握实在十分渣渣。\n\n所以，小 L 当时卡在了二叉树。", "description": "在计算机科学中，二叉树是每个结点最多有两个子结点的有序树。通常子结点被称作“左孩子”和“右孩子”。二叉树被用作二叉搜索树和二叉堆。随后他又和他人讨论起了二叉搜索树。什么是二叉搜索树呢？二叉搜索树首先是一棵二叉树。设 $key_p$ 表示结点 $p$ 上的数值。对于其中的每个结点 $p$，若其存在左孩子 $lch$，则 $key_p>key_{lch}$；若其存在右孩子 $rch$，则 $key_p<key_{rch}$；注意，本题中的二叉搜索树应满足对于所有结点，其左子树中的 $key$ 小于当前结点的 $key$，其右子树中的 $key$ 大于当前结点的 $key$。（因为小 L 十分喜欢装 xx，所以这里他十分装 xx 的给大家介绍了什么是二叉树和二叉搜索树）。\n\n可是善于思考的小 L 不甘于只学习这些基础的东西。他思考了这样一个问题：现在给定一棵二叉树，可以任意修改结点的数值。修改一个结点的数值算作一次修改，且这个结点不能再被修改。若要将其变成一棵二叉搜索树，且任意时刻结点的数值必须是整数（可以是负整数或 $0$），所要的最少修改次数。\n\n这一定难不倒聪明的你吧！如果你能帮小 L 解决这个问题，也许他会把最后的资产分给你 $\\dfrac{1}{16}$ 哦！", "inputFormat": "第一行一个正整数 $n$ 表示二叉树节点数。\n\n第二行 $n$ 个正整数用空格分隔开，第 $i$ 个数 $a_i$ 表示结点 $i$ 的原始数值。\n\n此后 $n-1$ 行每行两个非负整数 $fa$，$ch$，第 $i+2$ 行描述结点 $i+1$ 的父亲编号 $fa$，以及父子关系 $ch$，（$ch = 0$ 表示 $i+1$ 为左儿子，$ch = 1$ 表示 $i + 1$ 为右儿子）。\n\n为了让你稍微减轻些负担，小 L 规定：结点 $1$ 一定是二叉树的根哦！", "outputFormat": "仅一行包含一个整数，表示最少的修改次数。", "hint": "对于 $20\\%$ 的数据：$n \\leq 10$，$a_i \\leq 100$。\n\n对于 $40\\%$ 的数据：$n \\leq 100$，$a_i \\leq 200$。\n\n对于 $60\\%$ 的数据：$n \\leq 2000$。\n\n对于 $100\\%$ 的数据：$n \\leq 10^5$，$a_i < 2^{31}$。", "locale": "zh-CN"}}}
{"pid": "P3366", "type": "P", "difficulty": 3, "samples": [["4 5\n1 2 2\n1 3 2\n1 4 3\n2 3 4\n3 4 3", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "并查集", "生成树", "模板题"], "title": "【模板】最小生成树", "background": null, "description": "如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 `orz`。", "inputFormat": "第一行包含两个整数 $N,M$，表示该图共有 $N$ 个结点和 $M$ 条无向边。\n\n接下来 $M$ 行每行包含三个整数 $X_i,Y_i,Z_i$，表示有一条长度为 $Z_i$ 的无向边连接结点 $X_i,Y_i$。", "outputFormat": "如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 `orz`。", "hint": "数据规模：\n\n对于 $20\\%$ 的数据，$N\\le 5$，$M\\le 20$。\n\n对于 $40\\%$ 的数据，$N\\le 50$，$M\\le 2500$。\n\n对于 $70\\%$ 的数据，$N\\le 500$，$M\\le 10^4$。\n\n对于 $100\\%$ 的数据：$1\\le N\\le 5000$，$1\\le M\\le 2\\times 10^5$，$1\\le Z_i \\le 10^4$，$1\\le X_i,Y_i\\le N$。\n\n\n样例解释：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2259.png) \n\n所以最小生成树的总边权为 $2+2+3=7$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Minimum Spanning Tree", "background": "", "description": "As stated, given an undirected graph, compute a minimum spanning tree. If the graph is disconnected, output `orz`.", "inputFormat": "The first line contains two integers $N,M$, representing that the graph has $N$ nodes and $M$ undirected edges.\nThen each of the next $M$ lines contains three integers $X_i,Y_i,Z_i$, indicating there is an undirected edge of length $Z_i$ connecting nodes $X_i$ and $Y_i$.", "outputFormat": "If the graph is connected, output a single integer equal to the sum of the edge lengths in the minimum spanning tree. If the graph is disconnected, output `orz`.", "hint": "Constraints:\n- For 20% of the testdata, $N\\le 5$, $M\\le 20$.\n- For 40% of the testdata, $N\\le 50$, $M\\le 2500$.\n- For 70% of the testdata, $N\\le 500$, $M\\le 10^4$.\n- For 100% of the testdata, $1\\le N\\le 5000$, $1\\le M\\le 2\\times 10^5$, $1\\le Z_i \\le 10^4$, $1\\le X_i,Y_i\\le N$.\n\nSample explanation:\n\n![](https://cdn.luogu.com.cn/upload/pic/2259.png)\n\nTherefore, the total edge weight of the minimum spanning tree is $2+2+3=7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】最小生成树", "background": null, "description": "如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 `orz`。", "inputFormat": "第一行包含两个整数 $N,M$，表示该图共有 $N$ 个结点和 $M$ 条无向边。\n\n接下来 $M$ 行每行包含三个整数 $X_i,Y_i,Z_i$，表示有一条长度为 $Z_i$ 的无向边连接结点 $X_i,Y_i$。", "outputFormat": "如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 `orz`。", "hint": "数据规模：\n\n对于 $20\\%$ 的数据，$N\\le 5$，$M\\le 20$。\n\n对于 $40\\%$ 的数据，$N\\le 50$，$M\\le 2500$。\n\n对于 $70\\%$ 的数据，$N\\le 500$，$M\\le 10^4$。\n\n对于 $100\\%$ 的数据：$1\\le N\\le 5000$，$1\\le M\\le 2\\times 10^5$，$1\\le Z_i \\le 10^4$，$1\\le X_i,Y_i\\le N$。\n\n\n样例解释：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2259.png) \n\n所以最小生成树的总边权为 $2+2+3=7$。", "locale": "zh-CN"}}}
{"pid": "P3367", "type": "P", "difficulty": 3, "samples": [["4 7\n2 1 2\n1 1 2\n2 1 2\n1 3 4\n2 1 4\n1 2 3\n2 1 4", "N\nY\nN\nY\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["并查集", "O2优化", "模板题"], "title": "【模板】并查集", "background": "**本题数据范围已经更新到 $1\\le N\\le 2\\times 10^5$，$1\\le M\\le 10^6$。**", "description": "如题，现在有一个并查集，你需要完成合并和查询操作。\n", "inputFormat": "第一行包含两个整数 $N,M$ ,表示共有 $N$ 个元素和 $M$ 个操作。\n\n接下来 $M$ 行，每行包含三个整数 $Z_i,X_i,Y_i$ 。\n\n当 $Z_i=1$ 时，将 $X_i$ 与 $Y_i$ 所在的集合合并。\n\n当 $Z_i=2$ 时，输出 $X_i$ 与 $Y_i$ 是否在同一集合内，是的输出 \n `Y` ；否则输出 `N` 。", "outputFormat": "对于每一个 $Z_i=2$ 的操作，都有一行输出，每行包含一个大写字母，为 `Y` 或者 `N` 。 ", "hint": "对于 $15\\%$ 的数据，$N \\le 10$，$M \\le 20$。\n\n对于 $35\\%$ 的数据，$N \\le 100$，$M \\le 10^3$。\n\n对于 $50\\%$ 的数据，$1\\le N \\le 10^4$，$1\\le M \\le 2\\times 10^5$。\n\n对于 $100\\%$ 的数据，$1\\le N\\le 2\\times 10^5$，$1\\le M\\le 10^6$，$1 \\le X_i, Y_i \\le N$，$Z_i \\in \\{ 1, 2 \\}$。", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Disjoint Set Union", "background": "**The constraints for this problem have been updated to $1 \\le N \\le 2 \\times 10^5$, $1 \\le M \\le 10^6$.**", "description": "As stated, there is a disjoint set union (union-find). You need to perform union and query operations.", "inputFormat": "The first line contains two integers $N, M$, representing $N$ elements and $M$ operations.\n\nThe next $M$ lines each contain three integers $Z_i, X_i, Y_i$.\n\nWhen $Z_i = 1$, union the sets containing $X_i$ and $Y_i$.\n\nWhen $Z_i = 2$, output whether $X_i$ and $Y_i$ are in the same set. Output `Y` if yes; otherwise output `N`.", "outputFormat": "For each operation with $Z_i = 2$, output one line containing a single uppercase letter, either `Y` or `N`.", "hint": "For $15\\%$ of the testdata, $N \\le 10$, $M \\le 20$.\n\nFor $35\\%$ of the testdata, $N \\le 100$, $M \\le 10^3$.\n\nFor $50\\%$ of the testdata, $1 \\le N \\le 10^4$, $1 \\le M \\le 2 \\times 10^5$.\n\nFor $100\\%$ of the testdata, $1 \\le N \\le 2 \\times 10^5$, $1 \\le M \\le 10^6$, $1 \\le X_i, Y_i \\le N$, $Z_i \\in \\{ 1, 2 \\}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】并查集", "background": "**本题数据范围已经更新到 $1\\le N\\le 2\\times 10^5$，$1\\le M\\le 10^6$。**", "description": "如题，现在有一个并查集，你需要完成合并和查询操作。\n", "inputFormat": "第一行包含两个整数 $N,M$ ,表示共有 $N$ 个元素和 $M$ 个操作。\n\n接下来 $M$ 行，每行包含三个整数 $Z_i,X_i,Y_i$ 。\n\n当 $Z_i=1$ 时，将 $X_i$ 与 $Y_i$ 所在的集合合并。\n\n当 $Z_i=2$ 时，输出 $X_i$ 与 $Y_i$ 是否在同一集合内，是的输出 \n `Y` ；否则输出 `N` 。", "outputFormat": "对于每一个 $Z_i=2$ 的操作，都有一行输出，每行包含一个大写字母，为 `Y` 或者 `N` 。 ", "hint": "对于 $15\\%$ 的数据，$N \\le 10$，$M \\le 20$。\n\n对于 $35\\%$ 的数据，$N \\le 100$，$M \\le 10^3$。\n\n对于 $50\\%$ 的数据，$1\\le N \\le 10^4$，$1\\le M \\le 2\\times 10^5$。\n\n对于 $100\\%$ 的数据，$1\\le N\\le 2\\times 10^5$，$1\\le M\\le 10^6$，$1 \\le X_i, Y_i \\le N$，$Z_i \\in \\{ 1, 2 \\}$。", "locale": "zh-CN"}}}
{"pid": "P3368", "type": "P", "difficulty": 4, "samples": [["5 5\n1 5 4 2 3\n1 2 4 2\n2 3\n1 1 5 -1\n1 3 5 7\n2 4", "6\n10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["树状数组", "差分", "模板题"], "title": "【模板】树状数组 2", "background": null, "description": "如题，已知一个数列，你需要进行下面两种操作：\n\n1. 将某区间每一个数加上 $x$；\n\n2. 求出某一个数的值。", "inputFormat": "第一行包含两个整数 $N$、$M$，分别表示该数列数字的个数和操作的总个数。\n\n第二行包含 $N$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i $ 项的初始值。\n\n接下来 $M$ 行每行包含 $2$ 或 $4$ 个整数，表示一个操作，具体如下：\n\n操作 $1$： 格式：`1 x y k` 含义：将区间 $[x,y]$ 内每个数加上 $k$；\n\n操作 $2$： 格式：`2 x` 含义：输出第 $x$ 个数的值。", "outputFormat": "输出包含若干行整数，即为所有操作 $2$ 的结果。", "hint": "#### 样例 1 解释：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2258.png) \n\n故输出结果为 $6$ 和 $10$。\n\n---\n\n#### 数据规模与约定\n\n对于 $30\\%$ 的数据：$N\\le8$，$M\\le10$；\n\n对于 $70\\%$ 的数据：$N\\le 10^4$，$M\\le10^4$；\n\n对于 $100\\%$ 的数据：$1 \\leq N, M\\le 5\\times10^5$，$1 \\leq x, y \\leq n$，保证任意时刻序列中任意元素的绝对值都不大于 $2^{30}$。", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Fenwick Tree 2", "background": "", "description": "As stated, given a sequence, you need to perform the following two operations:\n1. Add $x$ to every number in a given interval.\n2. Query the value of a specific element.", "inputFormat": "The first line contains two integers $N$ and $M$, representing the number of elements in the sequence and the total number of operations.\n\nThe second line contains $N$ space-separated integers, where the $i$-th number is the initial value of the $i$-th element of the sequence.\n\nEach of the next $M$ lines contains $2$ or $4$ integers describing an operation, as follows:\n\nOperation 1: Format: `1 x y k` Meaning: add $k$ to every number in the interval $[x,y]$.\n\nOperation 2: Format: `2 x` Meaning: output the value of the $x$-th number.", "outputFormat": "Output several lines of integers, which are the results of all type 2 operations.", "hint": "Explanation for Sample 1:\n\n![](https://cdn.luogu.com.cn/upload/pic/2258.png)\n\nTherefore, the outputs are $6$ and $10$.\n\n---\n\nConstraints\n\nFor $30\\%$ of the testdata: $N\\le8$, $M\\le10$.\n\nFor $70\\%$ of the testdata: $N\\le 10^4$, $M\\le10^4$.\n\nFor $100\\%$ of the testdata: $1 \\leq N, M\\le 5\\times10^5$, $1 \\leq x, y \\leq n$. It is guaranteed that at any time, the absolute value of any element in the sequence does not exceed $2^{30}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】树状数组 2", "background": null, "description": "如题，已知一个数列，你需要进行下面两种操作：\n\n1. 将某区间每一个数加上 $x$；\n\n2. 求出某一个数的值。", "inputFormat": "第一行包含两个整数 $N$、$M$，分别表示该数列数字的个数和操作的总个数。\n\n第二行包含 $N$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i $ 项的初始值。\n\n接下来 $M$ 行每行包含 $2$ 或 $4$ 个整数，表示一个操作，具体如下：\n\n操作 $1$： 格式：`1 x y k` 含义：将区间 $[x,y]$ 内每个数加上 $k$；\n\n操作 $2$： 格式：`2 x` 含义：输出第 $x$ 个数的值。", "outputFormat": "输出包含若干行整数，即为所有操作 $2$ 的结果。", "hint": "#### 样例 1 解释：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2258.png) \n\n故输出结果为 $6$ 和 $10$。\n\n---\n\n#### 数据规模与约定\n\n对于 $30\\%$ 的数据：$N\\le8$，$M\\le10$；\n\n对于 $70\\%$ 的数据：$N\\le 10^4$，$M\\le10^4$；\n\n对于 $100\\%$ 的数据：$1 \\leq N, M\\le 5\\times10^5$，$1 \\leq x, y \\leq n$，保证任意时刻序列中任意元素的绝对值都不大于 $2^{30}$。", "locale": "zh-CN"}}}
{"pid": "P3369", "type": "P", "difficulty": 5, "samples": [["10\n1 106465\n4 1\n1 317721\n1 460929\n1 644985\n1 84185\n1 89851\n6 81968\n1 492737\n5 493598", "106465\n84185\n492737"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["平衡树", "模板题"], "title": "【模板】普通平衡树", "background": null, "description": "您需要动态地维护一个可重集合 $M$，并且提供以下操作：\n\n1. 向 $M$ 中插入一个数 $x$。\n2. 从 $M$ 中删除一个数 $x$（若有多个相同的数，应只删除一个）。\n3. 查询 $M$ 中有多少个数比 $x$ 小，并且将得到的答案加一。\n4. 查询如果将 $M$ 从小到大排列后，排名位于第 $x$ 位的数。\n5. 查询 $M$ 中 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。\n6. 查询 $M$ 中 $x$ 的后继（后继定义为大于 $x$，且最小的数）。\n\n对于操作 $3,5,6$，**不保证**当前可重集中存在数 $x$。\n\n对于操作 $5,6$，保证答案一定存在。", "inputFormat": "第一行为 $n$，表示操作的个数，下面 $n$ 行每行有两个数 $\\text{opt}$ 和 $x$，$\\text{opt}$ 表示操作的序号（$ 1 \\leq \\text{opt} \\leq 6 $）。", "outputFormat": "对于操作 $3,4,5,6$ 每行输出一个数，表示对应答案。", "hint": "**【数据范围】** \n\n对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$|x| \\le 10^7$。\n\n来源：Tyvj1728，原名：普通平衡树。\n\n在此鸣谢！", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Ordinary Balanced Tree", "background": "", "description": "You need to dynamically maintain a multiset $M$ and support the following operations:\n\n1. Insert a number $x$ into $M$.\n2. Delete a number $x$ from $M$ (if there are multiple equal numbers, delete only one).\n3. Query how many numbers in $M$ are less than $x$, and then add one to the result (i.e., the rank of $x$).\n4. Query the number whose rank is $x$ when $M$ is sorted in ascending order.\n5. Query the predecessor of $x$ in $M$ (the predecessor is defined as the maximum number that is less than $x$).\n6. Query the successor of $x$ in $M$ (the successor is defined as the minimum number that is greater than $x$).\n\nFor operations 3, 5, and 6, it is **not guaranteed** that $x$ exists in the current multiset.\n\nFor operations 5 and 6, the answer is guaranteed to exist.", "inputFormat": "The first line contains $n$, the number of operations. Each of the next $n$ lines contains two integers $\\text{opt}$ and $x$, where $\\text{opt}$ denotes the operation index ($1 \\leq \\text{opt} \\leq 6$).", "outputFormat": "For operations 3, 4, 5, and 6, output one integer per line, the corresponding answer.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $|x| \\le 10^7$.\n\nSource: Tyvj1728, originally titled: Ordinary Balanced Tree.\n\nSpecial thanks!\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】普通平衡树", "background": null, "description": "您需要动态地维护一个可重集合 $M$，并且提供以下操作：\n\n1. 向 $M$ 中插入一个数 $x$。\n2. 从 $M$ 中删除一个数 $x$（若有多个相同的数，应只删除一个）。\n3. 查询 $M$ 中有多少个数比 $x$ 小，并且将得到的答案加一。\n4. 查询如果将 $M$ 从小到大排列后，排名位于第 $x$ 位的数。\n5. 查询 $M$ 中 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。\n6. 查询 $M$ 中 $x$ 的后继（后继定义为大于 $x$，且最小的数）。\n\n对于操作 $3,5,6$，**不保证**当前可重集中存在数 $x$。\n\n对于操作 $5,6$，保证答案一定存在。", "inputFormat": "第一行为 $n$，表示操作的个数，下面 $n$ 行每行有两个数 $\\text{opt}$ 和 $x$，$\\text{opt}$ 表示操作的序号（$ 1 \\leq \\text{opt} \\leq 6 $）。", "outputFormat": "对于操作 $3,4,5,6$ 每行输出一个数，表示对应答案。", "hint": "**【数据范围】** \n\n对于 $100\\%$ 的数据，$1\\le n \\le 10^5$，$|x| \\le 10^7$。\n\n来源：Tyvj1728，原名：普通平衡树。\n\n在此鸣谢！", "locale": "zh-CN"}}}
{"pid": "P3370", "type": "P", "difficulty": 2, "samples": [["5\nabc\naaaa\nabc\nabcc\n12345", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "哈希 hashing", "模板题"], "title": "【模板】字符串哈希", "background": "", "description": "如题，给定 $N$ 个字符串（第 $i$ 个字符串长度为 $M_i$，字符串内包含数字、大小写字母，大小写敏感），请求出 $N$ 个字符串中共有多少个不同的字符串。\n\n\n**友情提醒：如果真的想好好练习哈希的话，请自觉。**\n", "inputFormat": "第一行包含一个整数 $N$，为字符串的个数。\n\n接下来 $N$ 行每行包含一个字符串，为所提供的字符串。\n", "outputFormat": "输出包含一行，包含一个整数，为不同的字符串个数。\n", "hint": "### 数据范围\n\n对于 $30\\%$ 的数据：$N\\leq 10$，$M_i≈6$，$M_{\\max}\\leq 15$。\n\n对于 $70\\%$ 的数据：$N\\leq 1000$，$M_i≈100$，$M_{\\max}\\leq 150$。\n\n对于 $100\\%$ 的数据：$N\\leq 10000$，$M_i≈1000$，$M_{\\max}\\leq 1500$。\n\n### 样例说明\n\n样例中第一个字符串 $\\tt{abc}$ 和第三个字符串 $\\tt{abc}$ 是一样的，所以所提供字符串的集合为 $\\{\\tt{aaaa},\\tt{abc},\\tt{abcc},\\tt{12345}\\}$，故共计 $4$ 个不同的字符串。\n\n### 拓展阅读\n\n以下的一些试题从不同层面体现出了字符串哈希算法的正确性分析。\n\n- [P12197 Hash Killer I](https://www.luogu.com.cn/problem/P12197)\n- [P12198 Hash Killer II](https://www.luogu.com.cn/problem/P12198)\n- [P12199 （目前无解）Hash Killer III](https://www.luogu.com.cn/problem/P12199)\n- [P12200 Hash Killer Extra](https://www.luogu.com.cn/problem/P12200)\n- [P12201 Hash Killer Phantasm](https://www.luogu.com.cn/problem/P12201)\n- [P7350 「MCOI-04」Dream and Strings](https://www.luogu.com.cn/problem/P7350)", "locale": "zh-CN", "translations": {"en": {"title": "[Template] String Hash", "background": "", "description": "As stated, given $N$ strings (the length of the $i$-th string is $M_i$, and each string contains digits and letters in both cases; it is case-sensitive), find how many distinct strings there are among the $N$ strings.\n\n**Friendly reminder: if you really want to practice hashing seriously, please be self-disciplined.**", "inputFormat": "The first line contains an integer $N$, the number of strings.\n\nThe next $N$ lines each contain one string, the provided strings.", "outputFormat": "Output one line containing one integer, the number of distinct strings.", "hint": "### Constraints\n\nFor $30\\%$ of the testdata: $N \\leq 10$, $M_i \\approx 6$, $M_{\\max} \\leq 15$.\n\nFor $70\\%$ of the testdata: $N \\leq 1000$, $M_i \\approx 100$, $M_{\\max} \\leq 150$.\n\nFor $100\\%$ of the testdata: $N \\leq 10000$, $M_i \\approx 1000$, $M_{\\max} \\leq 1500$.\n\n### Sample Explanation\n\nIn the sample, the first string $\\tt{abc}$ and the third string $\\tt{abc}$ are the same, so the set of provided strings is $\\{\\tt{aaaa}, \\tt{abc}, \\tt{abcc}, \\tt{12345}\\}$, hence there are $4$ distinct strings.\n\n### Further Reading\n\nThe following problems reflect the correctness analysis of string hashing from different aspects.\n\n- [P12197 Hash Killer I](https://www.luogu.com.cn/problem/P12197)\n- [P12198 Hash Killer II](https://www.luogu.com.cn/problem/P12198)\n- [P12199 (currently unsolved) Hash Killer III](https://www.luogu.com.cn/problem/P12199)\n- [P12200 Hash Killer Extra](https://www.luogu.com.cn/problem/P12200)\n- [P12201 Hash Killer Phantasm](https://www.luogu.com.cn/problem/P12201)\n- [P7350 「MCOI-04」Dream and Strings](https://www.luogu.com.cn/problem/P7350)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】字符串哈希", "background": "", "description": "如题，给定 $N$ 个字符串（第 $i$ 个字符串长度为 $M_i$，字符串内包含数字、大小写字母，大小写敏感），请求出 $N$ 个字符串中共有多少个不同的字符串。\n\n\n**友情提醒：如果真的想好好练习哈希的话，请自觉。**\n", "inputFormat": "第一行包含一个整数 $N$，为字符串的个数。\n\n接下来 $N$ 行每行包含一个字符串，为所提供的字符串。\n", "outputFormat": "输出包含一行，包含一个整数，为不同的字符串个数。\n", "hint": "### 数据范围\n\n对于 $30\\%$ 的数据：$N\\leq 10$，$M_i≈6$，$M_{\\max}\\leq 15$。\n\n对于 $70\\%$ 的数据：$N\\leq 1000$，$M_i≈100$，$M_{\\max}\\leq 150$。\n\n对于 $100\\%$ 的数据：$N\\leq 10000$，$M_i≈1000$，$M_{\\max}\\leq 1500$。\n\n### 样例说明\n\n样例中第一个字符串 $\\tt{abc}$ 和第三个字符串 $\\tt{abc}$ 是一样的，所以所提供字符串的集合为 $\\{\\tt{aaaa},\\tt{abc},\\tt{abcc},\\tt{12345}\\}$，故共计 $4$ 个不同的字符串。\n\n### 拓展阅读\n\n以下的一些试题从不同层面体现出了字符串哈希算法的正确性分析。\n\n- [P12197 Hash Killer I](https://www.luogu.com.cn/problem/P12197)\n- [P12198 Hash Killer II](https://www.luogu.com.cn/problem/P12198)\n- [P12199 （目前无解）Hash Killer III](https://www.luogu.com.cn/problem/P12199)\n- [P12200 Hash Killer Extra](https://www.luogu.com.cn/problem/P12200)\n- [P12201 Hash Killer Phantasm](https://www.luogu.com.cn/problem/P12201)\n- [P7350 「MCOI-04」Dream and Strings](https://www.luogu.com.cn/problem/P7350)", "locale": "zh-CN"}}}
{"pid": "P3371", "type": "P", "difficulty": 3, "samples": [["4 6 1\n1 2 2\n2 3 2\n2 4 1\n1 3 5\n3 4 3\n1 4 4", "0 2 4 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "O2优化", "最短路", "模板题"], "title": "【模板】单源最短路径（弱化版）", "background": "本题测试数据为随机数据，在考试中可能会出现构造数据让 SPFA 不通过，如有需要请移步 [P4779](https://www.luogu.com.cn/problem/P4779)。", "description": "如题，给出一个有向图，请输出从某一点出发到所有点的最短路径长度。", "inputFormat": "第一行包含三个整数 $n,m,s$，分别表示点的个数、有向边的个数、出发点的编号。\n\n接下来 $m$ 行每行包含三个整数 $u,v,w$，表示一条 $u \\to v$ 的，长度为 $w$ 的边。", "outputFormat": "输出一行 $n$ 个整数，第 $i$ 个表示 $s$ 到第 $i$ 个点的最短路径，若不能到达则输出 $2^{31}-1$。", "hint": "【数据范围】    \n对于 $20\\%$ 的数据：$1\\le n \\le 5$，$1\\le m \\le 15$；  \n对于 $40\\%$ 的数据：$1\\le n \\le 100$，$1\\le m \\le 10^4$；   \n对于 $70\\%$ 的数据：$1\\le n \\le 1000$，$1\\le m \\le 10^5$；   \n对于 $100\\%$ 的数据：$1 \\le n \\le 10^4$，$1\\le m \\le 5\\times 10^5$，$1\\le u,v\\le n$，$w\\ge 0$，$\\sum w< 2^{31}$，保证数据随机。\n\n**Update 2022/07/29：两个点之间可能有多条边，敬请注意。**\n\n对于真正 $100\\%$ 的数据，请移步 [P4779](https://www.luogu.com.cn/problem/P4779)。请注意，该题与本题数据范围略有不同。\n\n\n样例说明：\n\n![](https://cdn.luogu.com.cn/upload/pic/7641.png)\n\n图片 1 到 3 和 1 到 4 的文字位置调换", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Single-Source Shortest Path (Weakened Version)", "background": "The testdata for this problem is random. In exams, there may be adversarial testdata that makes SPFA fail; if needed, please refer to [P4779](https://www.luogu.org/problemnew/show/P4779).", "description": "As stated, given a directed graph, output the shortest path length from a specified vertex to every vertex.", "inputFormat": "The first line contains three integers $n, m, s$, denoting the number of vertices, the number of directed edges, and the index of the source vertex.\n\nEach of the next $m$ lines contains three integers $u, v, w$, denoting a directed edge $u \\to v$ with length $w$.", "outputFormat": "Output $n$ integers on one line. The $i$-th integer is the shortest path distance from $s$ to vertex $i$. If a vertex is unreachable, output $2^{31} - 1$.", "hint": "- Constraints  \n  For $20\\%$ of the testdata: $1 \\le n \\le 5$, $1 \\le m \\le 15$;  \n  For $40\\%$ of the testdata: $1 \\le n \\le 100$, $1 \\le m \\le 10^4$;  \n  For $70\\%$ of the testdata: $1 \\le n \\le 1000$, $1 \\le m \\le 10^5$;  \n  For $100\\%$ of the testdata: $1 \\le n \\le 10^4$, $1 \\le m \\le 5 \\times 10^5$, $1 \\le u, v \\le n$, $w \\ge 0$, $\\sum w < 2^{31}$; the testdata is guaranteed to be random.\n\n- Update 2022/07/29: There may be multiple edges between two vertices. Please take note.\n\n- For the full $100\\%$ testdata, please refer to [P4779](https://www.luogu.org/problemnew/show/P4779). Note that its constraints differ slightly from this problem.\n\nSample note:\n\n![](https://cdn.luogu.com.cn/upload/pic/7641.png)\n\nIn the image, the text positions for \"1 to 3\" and \"1 to 4\" are swapped.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】单源最短路径（弱化版）", "background": "本题测试数据为随机数据，在考试中可能会出现构造数据让 SPFA 不通过，如有需要请移步 [P4779](https://www.luogu.com.cn/problem/P4779)。", "description": "如题，给出一个有向图，请输出从某一点出发到所有点的最短路径长度。", "inputFormat": "第一行包含三个整数 $n,m,s$，分别表示点的个数、有向边的个数、出发点的编号。\n\n接下来 $m$ 行每行包含三个整数 $u,v,w$，表示一条 $u \\to v$ 的，长度为 $w$ 的边。", "outputFormat": "输出一行 $n$ 个整数，第 $i$ 个表示 $s$ 到第 $i$ 个点的最短路径，若不能到达则输出 $2^{31}-1$。", "hint": "【数据范围】    \n对于 $20\\%$ 的数据：$1\\le n \\le 5$，$1\\le m \\le 15$；  \n对于 $40\\%$ 的数据：$1\\le n \\le 100$，$1\\le m \\le 10^4$；   \n对于 $70\\%$ 的数据：$1\\le n \\le 1000$，$1\\le m \\le 10^5$；   \n对于 $100\\%$ 的数据：$1 \\le n \\le 10^4$，$1\\le m \\le 5\\times 10^5$，$1\\le u,v\\le n$，$w\\ge 0$，$\\sum w< 2^{31}$，保证数据随机。\n\n**Update 2022/07/29：两个点之间可能有多条边，敬请注意。**\n\n对于真正 $100\\%$ 的数据，请移步 [P4779](https://www.luogu.com.cn/problem/P4779)。请注意，该题与本题数据范围略有不同。\n\n\n样例说明：\n\n![](https://cdn.luogu.com.cn/upload/pic/7641.png)\n\n图片 1 到 3 和 1 到 4 的文字位置调换", "locale": "zh-CN"}}}
{"pid": "P3372", "type": "P", "difficulty": 4, "samples": [["5 5\n1 5 4 2 3\n2 2 4\n1 2 3 2\n2 3 4\n1 1 5 1\n2 1 4", "11\n8\n20"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "模板题"], "title": "【模板】线段树 1", "background": "", "description": "如题，已知一个数列 $\\{a_i\\}$，你需要进行下面两种操作：\n\n1. 将某区间每一个数加上 $k$。\n2. 求出某区间每一个数的和。\n", "inputFormat": "第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。\n\n第二行包含 $n$ 个用空格分隔的整数 $a_i$，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。\n\n接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：\n\n1. `1 x y k`：将区间 $[x, y]$ 内每个数加上 $k$。\n2. `2 x y`：输出区间 $[x, y]$ 内每个数的和。", "outputFormat": "输出包含若干行整数，即为所有操作 2 的结果。", "hint": "对于 $15\\%$ 的数据：$n \\le 8$，$m \\le 10$。  \n对于 $35\\%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。    \n对于 $100\\%$ 的数据：$1 \\le n, m \\le {10}^5$，$a_i,k$ 为正数，且任意时刻数列的和不超过 $2\\times 10^{18}$。\n\n**【样例解释】**\n\n![](https://cdn.luogu.com.cn/upload/pic/2251.png)", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Segment Tree 1", "background": "", "description": "As stated, given a sequence $\\{a_i\\}$, you need to perform the following two operations:\n1. Add $k$ to every number in a given interval.\n2. Find the sum of all numbers in a given interval.", "inputFormat": "The first line contains two integers $n, m$, representing the number of elements in the sequence and the total number of operations.\n\nThe second line contains $n$ space-separated integers $a_i$, where the $i$-th integer is the initial value of the $i$-th element.\n\nEach of the next $m$ lines contains $3$ or $4$ integers representing an operation, as follows:\n1. `1 x y k`: add $k$ to every number in the interval $[x, y]$.\n2. `2 x y`: output the sum of all numbers in the interval $[x, y]$.", "outputFormat": "Output several lines of integers, which are the results of all type 2 operations.", "hint": "For 15% of the testdata: $n \\le 8$, $m \\le 10$.\nFor 35% of the testdata: $n \\le {10}^3$, $m \\le {10}^4$.\nFor 100% of the testdata: $1 \\le n, m \\le {10}^5$, $a_i, k$ are positive, and the sum of the sequence at any time does not exceed $2\\times 10^{18}$.\n\nSample Explanation.\n\n![](https://cdn.luogu.com.cn/upload/pic/2251.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】线段树 1", "background": "", "description": "如题，已知一个数列 $\\{a_i\\}$，你需要进行下面两种操作：\n\n1. 将某区间每一个数加上 $k$。\n2. 求出某区间每一个数的和。\n", "inputFormat": "第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。\n\n第二行包含 $n$ 个用空格分隔的整数 $a_i$，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。\n\n接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：\n\n1. `1 x y k`：将区间 $[x, y]$ 内每个数加上 $k$。\n2. `2 x y`：输出区间 $[x, y]$ 内每个数的和。", "outputFormat": "输出包含若干行整数，即为所有操作 2 的结果。", "hint": "对于 $15\\%$ 的数据：$n \\le 8$，$m \\le 10$。  \n对于 $35\\%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。    \n对于 $100\\%$ 的数据：$1 \\le n, m \\le {10}^5$，$a_i,k$ 为正数，且任意时刻数列的和不超过 $2\\times 10^{18}$。\n\n**【样例解释】**\n\n![](https://cdn.luogu.com.cn/upload/pic/2251.png)", "locale": "zh-CN"}}}
{"pid": "P3373", "type": "P", "difficulty": 4, "samples": [["5 5 38\n1 5 4 2 3\n2 1 4 1\n3 2 5\n1 2 4 2\n2 3 5 5\n3 1 4", "17\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "O2优化", "模板题"], "title": "【模板】线段树 2", "background": "", "description": "如题，已知一个数列 $a$，你需要进行下面三种操作：\n\n- 将某区间每一个数乘上 $x$；\n- 将某区间每一个数加上 $x$；\n- 求出某区间每一个数的和。", "inputFormat": "第一行包含三个整数 $n,q,m$，分别表示该数列数字的个数、操作的总个数和模数。\n\n第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值 $a_i$。\n\n接下来 $q$ 行每行包含若干个整数，表示一个操作，具体如下：\n\n操作 $1$： 格式：`1 x y k`  含义：将区间 $[x,y]$ 内每个数乘上 $k$。\n\n操作 $2$： 格式：`2 x y k`  含义：将区间 $[x,y]$ 内每个数加上 $k$。\n\n操作 $3$： 格式：`3 x y`  含义：输出区间 $[x,y]$ 内每个数的和对 $m$ 取模所得的结果。", "outputFormat": "输出包含若干行整数，即为所有操作 $3$ 的结果。", "hint": "【数据范围】\n\n对于 $30\\%$ 的数据：$n \\le 8$，$q \\le 10$。  \n对于 $70\\%$ 的数据：$n \\le 10^3 $，$q \\le 10^4$。  \n对于 $100\\%$ 的数据：$1 \\le n \\le 10^5$，$1 \\le q \\le 10^5,1\\le a_i,k\\le 10^4$。\n\n除样例外，$m = 571373$。\n\n（数据已经过加强 ^\\_^）\n\n样例说明：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2255.png) \n\n故输出应为 $17$、$2$（$40 \\bmod 38 = 2$）。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Segment Tree 2", "background": "", "description": "As stated, given a sequence $a$, you need to perform the following three operations:\n\n- Multiply every number in a given interval by $x$.\n- Add $x$ to every number in a given interval.\n- Find the sum of every number in a given interval.", "inputFormat": "The first line contains three integers $n, q, m$, representing the number of elements in the sequence, the total number of operations, and the modulus.\n\nThe second line contains $n$ space-separated integers, where the $i$-th number is the initial value $a_i$ of the $i$-th element.\n\nEach of the next $q$ lines contains several integers describing an operation, as follows:\n\nOperation 1: Format: `1 x y k`  Meaning: multiply every number in the interval $[x,y]$ by $k$.\n\nOperation 2: Format: `2 x y k`  Meaning: add $k$ to every number in the interval $[x,y]$.\n\nOperation 3: Format: `3 x y`  Meaning: output the sum of every number in the interval $[x,y]$ modulo $m$.", "outputFormat": "Output several lines of integers, which are the results of all operation 3.", "hint": "Constraints:\n\nFor $30\\%$ of the testdata: $n \\le 8$, $q \\le 10$.\nFor $70\\%$ of the testdata: $n \\le 10^3$, $q \\le 10^4$.\nFor $100\\%$ of the testdata: $1 \\le n \\le 10^5$, $1 \\le q \\le 10^5$, $1 \\le a_i, k \\le 10^4$.\n\nExcept for the samples, $m = 571373$.\n\n(The testdata has been strengthened ^\\_^.)\n\nSample explanation:\n\n![](https://cdn.luogu.com.cn/upload/pic/2255.png)\n\nTherefore, the outputs should be $17$ and $2$ ($40 \\bmod 38 = 2$).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】线段树 2", "background": "", "description": "如题，已知一个数列 $a$，你需要进行下面三种操作：\n\n- 将某区间每一个数乘上 $x$；\n- 将某区间每一个数加上 $x$；\n- 求出某区间每一个数的和。", "inputFormat": "第一行包含三个整数 $n,q,m$，分别表示该数列数字的个数、操作的总个数和模数。\n\n第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值 $a_i$。\n\n接下来 $q$ 行每行包含若干个整数，表示一个操作，具体如下：\n\n操作 $1$： 格式：`1 x y k`  含义：将区间 $[x,y]$ 内每个数乘上 $k$。\n\n操作 $2$： 格式：`2 x y k`  含义：将区间 $[x,y]$ 内每个数加上 $k$。\n\n操作 $3$： 格式：`3 x y`  含义：输出区间 $[x,y]$ 内每个数的和对 $m$ 取模所得的结果。", "outputFormat": "输出包含若干行整数，即为所有操作 $3$ 的结果。", "hint": "【数据范围】\n\n对于 $30\\%$ 的数据：$n \\le 8$，$q \\le 10$。  \n对于 $70\\%$ 的数据：$n \\le 10^3 $，$q \\le 10^4$。  \n对于 $100\\%$ 的数据：$1 \\le n \\le 10^5$，$1 \\le q \\le 10^5,1\\le a_i,k\\le 10^4$。\n\n除样例外，$m = 571373$。\n\n（数据已经过加强 ^\\_^）\n\n样例说明：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2255.png) \n\n故输出应为 $17$、$2$（$40 \\bmod 38 = 2$）。", "locale": "zh-CN"}}}
{"pid": "P3374", "type": "P", "difficulty": 4, "samples": [["5 5\n1 5 4 2 3\n1 1 3\n2 2 5\n1 3 -1\n1 4 2\n2 1 4", "14\n16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["树状数组", "模板题"], "title": "【模板】树状数组 1", "background": null, "description": "如题，已知一个数列，你需要进行下面两种操作：\n\n- 将某一个数加上 $x$；\n\n- 求出某区间每一个数的和。", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示该数列数字的个数和操作的总个数。   \n \n第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。\n\n接下来 $m$ 行每行包含 $3$ 个整数，表示一个操作，具体如下：\n\n- `1 x k`  含义：将第 $x$ 个数加上 $k$；\n\n- `2 x y`  含义：输出区间 $[x,y]$ 内每个数的和。", "outputFormat": "输出包含若干行整数，即为所有操作 $2$ 的结果。", "hint": "【数据范围】\n\n对于 $30\\%$ 的数据，$1 \\le n \\le 8$，$1\\le m \\le 10$；   \n对于 $70\\%$ 的数据，$1\\le n,m \\le 10^4$；   \n对于 $100\\%$ 的数据，$1\\le n,m \\le 5\\times 10^5$，$1\\le x\\le y\\le n$，$-2^{31}\\le k<2^{31}$。\n\n数据保证对于任意时刻，$a$ 的任意子区间（包括长度为 $1$ 和 $n$ 的子区间）和均在 $[-2^{31}, 2^{31})$ 范围内。\n\n\n样例说明：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2256.png) \n\n故输出结果 $14$ 和 $16$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Fenwick Tree 1", "background": "", "description": "As stated, given a sequence, you need to perform the following two operations:\n\n- Add $x$ to a certain number.\n- Find the sum of all numbers in a given interval.", "inputFormat": "The first line contains two positive integers $n, m$, representing the number of elements in the sequence and the total number of operations.\n\nThe second line contains $n$ space-separated integers, where the $i$-th number is the initial value of the $i$-th element of the sequence.\n\nEach of the next $m$ lines contains $3$ integers describing an operation, as follows:\n\n- `1 x k` Meaning: add $k$ to the $x$-th number.\n- `2 x y` Meaning: output the sum of all numbers in the interval $[x, y]$.", "outputFormat": "Output several lines of integers, which are the results of all type `2` operations.", "hint": "Constraints\n\nFor $30\\%$ of the testdata, $1 \\le n \\le 8$, $1 \\le m \\le 10$.\nFor $70\\%$ of the testdata, $1 \\le n, m \\le 10^4$.\nFor $100\\%$ of the testdata, $1 \\le n, m \\le 5 \\times 10^5$.\n\nIt is guaranteed that at any time, the sum of any subarray of $a$ (including subarrays of length $1$ and length $n$) lies in the range $[-2^{31}, 2^{31})$.\n\nSample explanation:\n\n![](https://cdn.luogu.com.cn/upload/pic/2256.png)\n\nTherefore, the output is $14$ and $16$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】树状数组 1", "background": null, "description": "如题，已知一个数列，你需要进行下面两种操作：\n\n- 将某一个数加上 $x$；\n\n- 求出某区间每一个数的和。", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示该数列数字的个数和操作的总个数。   \n \n第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。\n\n接下来 $m$ 行每行包含 $3$ 个整数，表示一个操作，具体如下：\n\n- `1 x k`  含义：将第 $x$ 个数加上 $k$；\n\n- `2 x y`  含义：输出区间 $[x,y]$ 内每个数的和。", "outputFormat": "输出包含若干行整数，即为所有操作 $2$ 的结果。", "hint": "【数据范围】\n\n对于 $30\\%$ 的数据，$1 \\le n \\le 8$，$1\\le m \\le 10$；   \n对于 $70\\%$ 的数据，$1\\le n,m \\le 10^4$；   \n对于 $100\\%$ 的数据，$1\\le n,m \\le 5\\times 10^5$，$1\\le x\\le y\\le n$，$-2^{31}\\le k<2^{31}$。\n\n数据保证对于任意时刻，$a$ 的任意子区间（包括长度为 $1$ 和 $n$ 的子区间）和均在 $[-2^{31}, 2^{31})$ 范围内。\n\n\n样例说明：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2256.png) \n\n故输出结果 $14$ 和 $16$。", "locale": "zh-CN"}}}
{"pid": "P3375", "type": "P", "difficulty": 4, "samples": [["ABABABC\nABA\n", "1\n3\n0 0 1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "O2优化", "KMP 算法", "模板题"], "title": "【模板】KMP", "background": null, "description": "给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。  \n现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。\n\n定义一个字符串 $s$ 的 border 为 $s$ 的一个**非 $s$ 本身**的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。  \n对于 $s_2$，你还需要求出对于其每个前缀 $s'$ 的最长 border $t'$ 的长度。", "inputFormat": "第一行为一个字符串，即为 $s_1$。  \n第二行为一个字符串，即为 $s_2$。", "outputFormat": "首先输出若干行，每行一个整数，**按从小到大的顺序**输出 $s_2$ 在 $s_1$ 中出现的位置。  \n最后一行输出 $|s_2|$ 个整数，第 $i$ 个整数表示 $s_2$ 的长度为 $i$ 的前缀的最长 border 长度。", "hint": "### 样例 1 解释\n\n ![](https://cdn.luogu.com.cn/upload/pic/2257.png)。\n \n对于 $s_2$ 长度为 $3$ 的前缀 `ABA`，字符串 `A` 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为 $1$。\n\n\n### 数据规模与约定\n\n**本题采用多测试点捆绑测试，共有 4 个子任务**。\n\n- Subtask 0（30 points）：$|s_1| \\leq 15$，$|s_2| \\leq 5$。\n- Subtask 1（40 points）：$|s_1| \\leq 10^4$，$|s_2| \\leq 10^2$。\n- Subtask 2（30 points）：无特殊约定。\n- Subtask 3（0 points）：Hack。\n\n对于全部的测试点，保证 $1 \\leq |s_1|,|s_2| \\leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。", "locale": "zh-CN", "translations": {"en": {"title": "【Template】KMP", "background": "", "description": "Given two strings $s_1$ and $s_2$, if the substring of $s_1$ on the interval $[l, r]$ is exactly the same as $s_2$, then $s_2$ is said to occur in $s_1$, and its occurrence position is $l$.  \nNow please find all occurrence positions of $s_2$ in $s_1$.\n\nDefine the border of a string $s$ as a substring $t$ of $s$ that is **not the whole $s$**, and satisfies that $t$ is both a prefix and a suffix of $s$.  \nFor $s_2$, you also need to compute, for each of its prefixes $s'$, the length of the longest border $t'$.", "inputFormat": "The first line contains a string, which is $s_1$.  \nThe second line contains a string, which is $s_2$.", "outputFormat": "First output several lines, each with an integer, output the occurrence positions of $s_2$ in $s_1$ in increasing order.  \nThe last line outputs $|s_2|$ integers, where the $i$-th integer denotes the length of the longest border of the prefix of $s_2$ with length $i$.", "hint": "### Explanation for Sample 1\n\n![](https://cdn.luogu.com.cn/upload/pic/2257.png).\n\nFor the length-$3$ prefix `ABA` of $s_2$, the string `A` is both its suffix and its prefix, and it is the longest one, so the longest border length is $1$.\n\n### Constraints and Notes\n\nThis problem uses bundled test points, with 4 subtasks.\n\n- Subtask 0 (30 points): $|s_1| \\leq 15$, $|s_2| \\leq 5$.\n- Subtask 1 (40 points): $|s_1| \\leq 10^4$, $|s_2| \\leq 10^2$.\n- Subtask 2 (30 points): No special constraints.\n- Subtask 3 (0 points): Hack.\n\nFor all test points, it is guaranteed that $1 \\leq |s_1|, |s_2| \\leq 10^6$, and both $s_1$ and $s_2$ contain only uppercase English letters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】KMP", "background": null, "description": "给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。  \n现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。\n\n定义一个字符串 $s$ 的 border 为 $s$ 的一个**非 $s$ 本身**的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。  \n对于 $s_2$，你还需要求出对于其每个前缀 $s'$ 的最长 border $t'$ 的长度。", "inputFormat": "第一行为一个字符串，即为 $s_1$。  \n第二行为一个字符串，即为 $s_2$。", "outputFormat": "首先输出若干行，每行一个整数，**按从小到大的顺序**输出 $s_2$ 在 $s_1$ 中出现的位置。  \n最后一行输出 $|s_2|$ 个整数，第 $i$ 个整数表示 $s_2$ 的长度为 $i$ 的前缀的最长 border 长度。", "hint": "### 样例 1 解释\n\n ![](https://cdn.luogu.com.cn/upload/pic/2257.png)。\n \n对于 $s_2$ 长度为 $3$ 的前缀 `ABA`，字符串 `A` 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为 $1$。\n\n\n### 数据规模与约定\n\n**本题采用多测试点捆绑测试，共有 4 个子任务**。\n\n- Subtask 0（30 points）：$|s_1| \\leq 15$，$|s_2| \\leq 5$。\n- Subtask 1（40 points）：$|s_1| \\leq 10^4$，$|s_2| \\leq 10^2$。\n- Subtask 2（30 points）：无特殊约定。\n- Subtask 3（0 points）：Hack。\n\n对于全部的测试点，保证 $1 \\leq |s_1|,|s_2| \\leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。", "locale": "zh-CN"}}}
{"pid": "P3376", "type": "P", "difficulty": 5, "samples": [["4 5 4 3\n4 2 30\n4 3 20\n2 3 20\n2 1 30\n1 3 30\n", "50\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["网络流", "O2优化", "模板题"], "title": "【模板】网络最大流", "background": "", "description": "如题，给出一个网络图，以及其源点和汇点，求出其网络最大流。\n", "inputFormat": "第一行包含四个正整数 $n,m,s,t$，分别表示点的个数、有向边的个数、源点序号、汇点序号。\n\n接下来 $m$ 行每行包含三个正整数 $u_i,v_i,w_i$，表示第 $i$ 条有向边从 $u_i$ 出发，到达 $v_i$，边权为 $w_i$（即该边最大流量为 $w_i$）。", "outputFormat": "一行，包含一个正整数，即为该网络的最大流。\n", "hint": "#### 样例输入输出 1 解释\n\n ![](https://cdn.luogu.com.cn/upload/pic/2262.png) \n\n题目中存在 $3$ 条路径：\n\n- $4\\to 2\\to 3$，该路线可通过 $20$ 的流量。\n- $4\\to 3$，可通过 $20$ 的流量。\n- $4\\to 2\\to 1\\to 3$，可通过 $10$ 的流量（边 $4\\to 2$ 之前已经耗费了 $20$ 的流量）。\n\n故流量总计 $20+20+10=50$。输出 $50$。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n\\leq10$，$m\\leq25$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n\\leq200$，$1 \\leq m\\leq 5000$，$0 \\leq w\\lt 2^{31}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Network Maximum Flow", "background": "", "description": "As stated, given a network graph and its source and sink, compute the maximum flow of this network.", "inputFormat": "The first line contains four positive integers $n, m, s, t$, denoting the number of vertices, the number of directed edges, the index of the source, and the index of the sink, respectively.\n\nEach of the next $m$ lines contains three positive integers $u_i, v_i, w_i$, meaning that the $i$-th directed edge goes from $u_i$ to $v_i$ with capacity $w_i$ (i.e., the maximum flow on this edge is $w_i$).", "outputFormat": "One line containing a single positive integer, which is the maximum flow of the network.", "hint": "#### Explanation for Sample Input/Output 1\n\n![](https://cdn.luogu.com.cn/upload/pic/2262.png)\n\nThere are $3$ paths in the figure:\n\n- $4 \\to 2 \\to 3$, which can carry a flow of $20$.\n- $4 \\to 3$, which can carry a flow of $20$.\n- $4 \\to 2 \\to 1 \\to 3$, which can carry a flow of $10$ (edge $4 \\to 2$ has already used $20$ units of flow beforehand).\n\nTherefore, the total flow is $20 + 20 + 10 = 50$. Output $50$.\n\n---\n\n#### Constraints\n\n- For $30\\%$ of the testdata, it is guaranteed that $n \\le 10$, $m \\le 25$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\le n \\le 200$, $1 \\le m \\le 5000$, $0 \\le w < 2^{31}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】网络最大流", "background": "", "description": "如题，给出一个网络图，以及其源点和汇点，求出其网络最大流。\n", "inputFormat": "第一行包含四个正整数 $n,m,s,t$，分别表示点的个数、有向边的个数、源点序号、汇点序号。\n\n接下来 $m$ 行每行包含三个正整数 $u_i,v_i,w_i$，表示第 $i$ 条有向边从 $u_i$ 出发，到达 $v_i$，边权为 $w_i$（即该边最大流量为 $w_i$）。", "outputFormat": "一行，包含一个正整数，即为该网络的最大流。\n", "hint": "#### 样例输入输出 1 解释\n\n ![](https://cdn.luogu.com.cn/upload/pic/2262.png) \n\n题目中存在 $3$ 条路径：\n\n- $4\\to 2\\to 3$，该路线可通过 $20$ 的流量。\n- $4\\to 3$，可通过 $20$ 的流量。\n- $4\\to 2\\to 1\\to 3$，可通过 $10$ 的流量（边 $4\\to 2$ 之前已经耗费了 $20$ 的流量）。\n\n故流量总计 $20+20+10=50$。输出 $50$。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n\\leq10$，$m\\leq25$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n\\leq200$，$1 \\leq m\\leq 5000$，$0 \\leq w\\lt 2^{31}$。\n", "locale": "zh-CN"}}}
{"pid": "P3377", "type": "P", "difficulty": 5, "samples": [["5 5\n1 5 4 2 3\n1 1 5\n1 2 5\n2 2\n1 4 2\n2 2", "1\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["可并堆", "模板题"], "title": "【模板】可并堆 1", "background": null, "description": "如题，一开始有 $n$ 个小根堆，每个堆包含且仅包含一个数。接下来需要支持两种操作：\n\n1. `1 x y`：将第 $x$ 个数和第 $y$ 个数所在的小根堆合并（若第 $x$ 或第 $y$ 个数已经被删除或第 $x$ 和第 $y$ 个数在同一个堆内，则无视此操作）。\n\n2. `2 x`：输出第 $x$ 个数所在的堆最小数，并将这个最小数删除（若有多个最小数，优先删除先输入的；若第 $x$ 个数已经被删除，则输出 $-1$ 并无视删除操作）。", "inputFormat": "第一行包含两个正整数 $n, m$，分别表示一开始小根堆的个数和接下来操作的个数。\n\n第二行包含 $n$ 个正整数，其中第 $i$ 个正整数表示第 $i$ 个小根堆初始时包含且仅包含的数。\n\n接下来 $m$ 行每行 $2$ 个或 $3$ 个正整数，表示一条操作，格式如下：\n\n操作 $1$：`1 x y`\n\n操作 $2$：`2 x`", "outputFormat": "输出包含若干行整数，分别依次对应每一个操作 $2$ 所得的结果。", "hint": "**【数据规模】**\n\n对于 $30\\%$ 的数据：$n\\le 10$，$m\\le 10$。  \n对于 $70\\%$ 的数据：$n\\le 10^3$，$m\\le 10^3$。  \n对于 $100\\%$ 的数据：$n\\le 10^5$，$m\\le 10^5$，初始时小根堆中的所有数都在 `int` 范围内。\n\n**【样例解释】**\n\n初始状态下，五个小根堆分别为：$\\{1\\}$、$\\{5\\}$、$\\{4\\}$、$\\{2\\}$、$\\{3\\}$。\n\n第一次操作，将第 $1$ 个数所在的小根堆与第 $5$ 个数所在的小根堆合并，故变为四个小根堆：$\\{1,3\\}$、$\\{5\\}$、$\\{4\\}$、$\\{2\\}$。\n\n第二次操作，将第 $2$ 个数所在的小根堆与第 $5$ 个数所在的小根堆合并，故变为三个小根堆：$\\{1,3,5\\}$、$\\{4\\}$、$\\{2\\}$。\n\n第三次操作，将第 $2$ 个数所在的小根堆的最小值输出并删除，故输出 $1$，第一个数被删除，三个小根堆为：$\\{3,5\\}$、$\\{4\\}$、$\\{2\\}$。\n\n第四次操作，将第 $4$ 个数所在的小根堆与第 $2$ 个数所在的小根堆合并，故变为两个小根堆：$\\{2,3,5\\}$、$\\{4\\}$。\n\n第五次操作，将第 $2$ 个数所在的小根堆的最小值输出并删除，故输出 $2$，第四个数被删除，两个小根堆为：$\\{3,5\\}$、$\\{4\\}$。\n\n故输出依次为 $1$、$2$。", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Meldable Heap 1", "background": "", "description": "As stated, initially there are $n$ min-heaps, each containing exactly one number. Afterwards, you need to support two types of operations:\n\n1. `1 x y`: Merge the min-heap containing the $x$-th number and the min-heap containing the $y$-th number (if the $x$-th or $y$-th number has already been deleted, or if the $x$-th and $y$-th numbers are in the same heap, ignore this operation).\n\n2. `2 x`: Output the minimum number in the heap containing the $x$-th number, and delete this minimum number (if there are multiple minimum numbers, delete the one that was inserted earlier; if the $x$-th number has already been deleted, output $-1$ and ignore the deletion).", "inputFormat": "The first line contains two positive integers $n, m$, representing the initial number of min-heaps and the number of subsequent operations, respectively.\n\nThe second line contains $n$ positive integers, where the $i$-th integer is the only number initially contained in the $i$-th min-heap.\n\nEach of the next $m$ lines contains $2$ or $3$ positive integers, representing one operation in the following formats:\n\nOperation 1: `1 x y`\n\nOperation 2: `2 x`", "outputFormat": "The output contains several lines of integers, each corresponding to the result of an operation of type `2`, in order.", "hint": "【Constraints】\n\nFor $30\\%$ of the testdata: $n \\le 10$, $m \\le 10$.  \nFor $70\\%$ of the testdata: $n \\le 10^3$, $m \\le 10^3$.  \nFor $100\\%$ of the testdata: $n \\le 10^5$, $m \\le 10^5$, and all initial numbers in the min-heaps are within the `int` range.\n\n【Sample Explanation】\n\nInitially, the five min-heaps are: $\\{1\\}$, $\\{5\\}$, $\\{4\\}$, $\\{2\\}$, $\\{3\\}$.\n\nIn the first operation, merge the heap containing the $1$-st number with the heap containing the $5$-th number, resulting in four min-heaps: $\\{1,3\\}$, $\\{5\\}$, $\\{4\\}$, $\\{2\\}$.\n\nIn the second operation, merge the heap containing the $2$-nd number with the heap containing the $5$-th number, resulting in three min-heaps: $\\{1,3,5\\}$, $\\{4\\}$, $\\{2\\}$.\n\nIn the third operation, output and delete the minimum of the heap containing the $2$-nd number, so output $1$; the first number is deleted, and the three min-heaps become: $\\{3,5\\}$, $\\{4\\}$, $\\{2\\}$.\n\nIn the fourth operation, merge the heap containing the $4$-th number with the heap containing the $2$-nd number, resulting in two min-heaps: $\\{2,3,5\\}$, $\\{4\\}$.\n\nIn the fifth operation, output and delete the minimum of the heap containing the $2$-nd number, so output $2$; the fourth number is deleted, and the two min-heaps become: $\\{3,5\\}$, $\\{4\\}$.\n\nTherefore, the outputs are $1$ and $2$ in order.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】可并堆 1", "background": null, "description": "如题，一开始有 $n$ 个小根堆，每个堆包含且仅包含一个数。接下来需要支持两种操作：\n\n1. `1 x y`：将第 $x$ 个数和第 $y$ 个数所在的小根堆合并（若第 $x$ 或第 $y$ 个数已经被删除或第 $x$ 和第 $y$ 个数在同一个堆内，则无视此操作）。\n\n2. `2 x`：输出第 $x$ 个数所在的堆最小数，并将这个最小数删除（若有多个最小数，优先删除先输入的；若第 $x$ 个数已经被删除，则输出 $-1$ 并无视删除操作）。", "inputFormat": "第一行包含两个正整数 $n, m$，分别表示一开始小根堆的个数和接下来操作的个数。\n\n第二行包含 $n$ 个正整数，其中第 $i$ 个正整数表示第 $i$ 个小根堆初始时包含且仅包含的数。\n\n接下来 $m$ 行每行 $2$ 个或 $3$ 个正整数，表示一条操作，格式如下：\n\n操作 $1$：`1 x y`\n\n操作 $2$：`2 x`", "outputFormat": "输出包含若干行整数，分别依次对应每一个操作 $2$ 所得的结果。", "hint": "**【数据规模】**\n\n对于 $30\\%$ 的数据：$n\\le 10$，$m\\le 10$。  \n对于 $70\\%$ 的数据：$n\\le 10^3$，$m\\le 10^3$。  \n对于 $100\\%$ 的数据：$n\\le 10^5$，$m\\le 10^5$，初始时小根堆中的所有数都在 `int` 范围内。\n\n**【样例解释】**\n\n初始状态下，五个小根堆分别为：$\\{1\\}$、$\\{5\\}$、$\\{4\\}$、$\\{2\\}$、$\\{3\\}$。\n\n第一次操作，将第 $1$ 个数所在的小根堆与第 $5$ 个数所在的小根堆合并，故变为四个小根堆：$\\{1,3\\}$、$\\{5\\}$、$\\{4\\}$、$\\{2\\}$。\n\n第二次操作，将第 $2$ 个数所在的小根堆与第 $5$ 个数所在的小根堆合并，故变为三个小根堆：$\\{1,3,5\\}$、$\\{4\\}$、$\\{2\\}$。\n\n第三次操作，将第 $2$ 个数所在的小根堆的最小值输出并删除，故输出 $1$，第一个数被删除，三个小根堆为：$\\{3,5\\}$、$\\{4\\}$、$\\{2\\}$。\n\n第四次操作，将第 $4$ 个数所在的小根堆与第 $2$ 个数所在的小根堆合并，故变为两个小根堆：$\\{2,3,5\\}$、$\\{4\\}$。\n\n第五次操作，将第 $2$ 个数所在的小根堆的最小值输出并删除，故输出 $2$，第四个数被删除，两个小根堆为：$\\{3,5\\}$、$\\{4\\}$。\n\n故输出依次为 $1$、$2$。", "locale": "zh-CN"}}}
{"pid": "P3378", "type": "P", "difficulty": 3, "samples": [["5\n1 2\n1 5\n2\n3\n2\n", "2\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["堆", "O2优化", "模板题"], "title": "【模板】堆", "background": "", "description": "给定一个数列，初始为空，请支持下面三种操作：\n\n1. 给定一个整数 $x$，请将 $x$ 加入到数列中。\n2. 输出数列中最小的数。\n3. 删除数列中最小的数（如果有多个数最小，只删除 $1$ 个）。\n\n\n", "inputFormat": "第一行是一个整数，表示操作的次数 $n$。  \n接下来 $n$ 行，每行表示一次操作。每行首先有一个整数 $op$ 表示操作类型。\n- 若 $op = 1$，则后面有一个整数 $x$，表示要将 $x$ 加入数列。\n- 若 $op = 2$，则表示要求输出数列中的最小数。\n- 若 $op = 3$，则表示删除数列中的最小数。如果有多个数最小，只删除 $1$ 个。", "outputFormat": "对于每个操作 $2$，输出一行一个整数表示答案。", "hint": "**【数据规模与约定】**\n- 对于 $30\\%$ 的数据，保证 $n \\leq 15$。\n- 对于 $70\\%$ 的数据，保证 $n \\leq 10^4$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^6$，$1 \\leq x \\lt 2^{31}$，$op \\in \\{1, 2, 3\\}$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Heap", "background": "", "description": "Given a sequence that is initially empty, support the following three operations:\n1. Given an integer $x$, insert $x$ into the sequence.\n2. Output the smallest number in the sequence.\n3. Delete the smallest number in the sequence (if multiple numbers are smallest, delete only $1$).", "inputFormat": "The first line contains an integer $n$ representing the number of operations.  \nThen follow $n$ lines, each describing one operation. Each line first contains an integer $op$ indicating the operation type.\n- If $op = 1$, then an integer $x$ follows, meaning to insert $x$ into the sequence.\n- If $op = 2$, it means to output the smallest number in the sequence.\n- If $op = 3$, it means to delete the smallest number in the sequence. If multiple numbers are smallest, delete only $1$.", "outputFormat": "For each operation $2$, output one line with one integer representing the answer.", "hint": "**Constraints**\n- For $30\\%$ of the testdata, it is guaranteed that $n \\leq 15$.\n- For $70\\%$ of the testdata, it is guaranteed that $n \\leq 10^4$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 10^6$, $1 \\leq x \\lt 2^{31}$, $op \\in \\{1, 2, 3\\}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】堆", "background": "", "description": "给定一个数列，初始为空，请支持下面三种操作：\n\n1. 给定一个整数 $x$，请将 $x$ 加入到数列中。\n2. 输出数列中最小的数。\n3. 删除数列中最小的数（如果有多个数最小，只删除 $1$ 个）。\n\n\n", "inputFormat": "第一行是一个整数，表示操作的次数 $n$。  \n接下来 $n$ 行，每行表示一次操作。每行首先有一个整数 $op$ 表示操作类型。\n- 若 $op = 1$，则后面有一个整数 $x$，表示要将 $x$ 加入数列。\n- 若 $op = 2$，则表示要求输出数列中的最小数。\n- 若 $op = 3$，则表示删除数列中的最小数。如果有多个数最小，只删除 $1$ 个。", "outputFormat": "对于每个操作 $2$，输出一行一个整数表示答案。", "hint": "**【数据规模与约定】**\n- 对于 $30\\%$ 的数据，保证 $n \\leq 15$。\n- 对于 $70\\%$ 的数据，保证 $n \\leq 10^4$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^6$，$1 \\leq x \\lt 2^{31}$，$op \\in \\{1, 2, 3\\}$。", "locale": "zh-CN"}}}
{"pid": "P3379", "type": "P", "difficulty": 3, "samples": [["5 5 4\n3 1\n2 4\n5 1\n1 4\n2 4\n3 2\n3 5\n1 2\n4 5", "4\n4\n1\n4\n4\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "最近公共祖先 LCA", "模板题"], "title": "【模板】最近公共祖先（LCA）", "background": null, "description": "如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。", "inputFormat": "第一行包含三个正整数 $N,M,S$，分别表示树的结点个数、询问的个数和树根结点的序号。\n\n接下来 $N-1$ 行每行包含两个正整数 $x, y$，表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。\n\n接下来 $M$ 行每行包含两个正整数 $a, b$，表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。", "outputFormat": "输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。", "hint": "对于 $30\\%$ 的数据，$N\\leq 10$，$M\\leq 10$。\n\n对于 $70\\%$ 的数据，$N\\leq 10000$，$M\\leq 10000$。\n\n对于 $100\\%$ 的数据，$1 \\leq N,M\\leq 5\\times10^5$，$1 \\leq x, y,a ,b \\leq N$，**不保证** $a \\neq b$。\n\n\n样例说明：\n\n该树结构如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2282.png) \n\n第一次询问：$2, 4$ 的最近公共祖先，故为 $4$。\n\n第二次询问：$3, 2$ 的最近公共祖先，故为 $4$。\n\n第三次询问：$3, 5$ 的最近公共祖先，故为 $1$。\n\n第四次询问：$1, 2$ 的最近公共祖先，故为 $4$。\n\n第五次询问：$4, 5$ 的最近公共祖先，故为 $4$。\n\n故输出依次为 $4, 4, 1, 4, 4$。\n\n\n2021/10/4 数据更新 @fstqwq：应要求加了两组数据卡掉了暴力跳。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Lowest Common Ancestor (LCA)", "background": "", "description": "As stated, given a rooted multi-branch tree, find the lowest common ancestor of the specified two nodes.", "inputFormat": "The first line contains three positive integers $N,M,S$, which denote the number of nodes in the tree, the number of queries, and the index of the root node, respectively.\n\nEach of the next $N-1$ lines contains two positive integers $x, y$, indicating that there is a directly connected edge between node $x$ and node $y$ (the testdata guarantees the edges form a tree).\n\nEach of the next $M$ lines contains two positive integers $a, b$, asking for the lowest common ancestor of node $a$ and node $b$.", "outputFormat": "Output $M$ lines, each containing one positive integer, which are the answers to the queries in order.", "hint": "Constraints:\n\n- For $30\\%$ of the testdata, $N\\leq 10$, $M\\leq 10$.\n- For $70\\%$ of the testdata, $N\\leq 10000$, $M\\leq 10000$.\n- For $100\\%$ of the testdata, $1 \\leq N,M\\leq 5\\times10^5$, $1 \\leq x, y,a ,b \\leq N$, and it is not guaranteed that $a \\neq b$.\n\nSample explanation:\n\nThe tree structure is as follows:\n\n![](https://cdn.luogu.com.cn/upload/pic/2282.png)\n\n- First query: the lowest common ancestor of $2, 4$ is $4$.\n- Second query: the lowest common ancestor of $3, 2$ is $4$.\n- Third query: the lowest common ancestor of $3, 5$ is $1$.\n- Fourth query: the lowest common ancestor of $1, 2$ is $4$.\n- Fifth query: the lowest common ancestor of $4, 5$ is $4$.\n\nTherefore, the outputs are $4, 4, 1, 4, 4$ in order.\n\n2021/10/4 testdata update @fstqwq: Added two more sets of testdata to block brute-force jumping.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】最近公共祖先（LCA）", "background": null, "description": "如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。", "inputFormat": "第一行包含三个正整数 $N,M,S$，分别表示树的结点个数、询问的个数和树根结点的序号。\n\n接下来 $N-1$ 行每行包含两个正整数 $x, y$，表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。\n\n接下来 $M$ 行每行包含两个正整数 $a, b$，表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。", "outputFormat": "输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。", "hint": "对于 $30\\%$ 的数据，$N\\leq 10$，$M\\leq 10$。\n\n对于 $70\\%$ 的数据，$N\\leq 10000$，$M\\leq 10000$。\n\n对于 $100\\%$ 的数据，$1 \\leq N,M\\leq 5\\times10^5$，$1 \\leq x, y,a ,b \\leq N$，**不保证** $a \\neq b$。\n\n\n样例说明：\n\n该树结构如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/2282.png) \n\n第一次询问：$2, 4$ 的最近公共祖先，故为 $4$。\n\n第二次询问：$3, 2$ 的最近公共祖先，故为 $4$。\n\n第三次询问：$3, 5$ 的最近公共祖先，故为 $1$。\n\n第四次询问：$1, 2$ 的最近公共祖先，故为 $4$。\n\n第五次询问：$4, 5$ 的最近公共祖先，故为 $4$。\n\n故输出依次为 $4, 4, 1, 4, 4$。\n\n\n2021/10/4 数据更新 @fstqwq：应要求加了两组数据卡掉了暴力跳。", "locale": "zh-CN"}}}
{"pid": "P3380", "type": "P", "difficulty": 6, "samples": [["9 6\n4 2 2 1 9 4 0 1 1\n2 1 4 3\n3 4 10\n2 1 4 3\n1 2 5 9\n4 3 9 5\n5 2 8 5", "2\n4\n3\n4\n9"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "平衡树", "树状数组", "树套树", "分块", "模板题"], "title": "【模板】树套树", "background": "", "description": "您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：\n\n1. 查询 $k$ 在区间内的排名；\n2. 查询区间内排名为 $k$ 的值；\n3. 修改某一位置上的数值；\n4. 查询 $k$ 在区间内的前驱（前驱定义为严格小于 $x$，且最大的数，**若不存在输出 `-2147483647`**）；\n5. 查询 $k$ 在区间内的后继（后继定义为严格大于 $x$，且最小的数，**若不存在输出 `2147483647`**）。\n\n对于一组元素，一个数的排名被定义为严格比它小的元素个数加一，而排名为 $k$ 的数被定义为“将元素从小到大排序后排在第 $k$ 位的元素值”。", "inputFormat": "第一行两个数 $n,m$，表示长度为 $n$ 的有序序列和 $m$ 个操作。\n\n第二行有 $n$ 个数，表示有序序列。\n\n下面有 $m$ 行，$opt$ 表示操作标号。\n\n若 $opt=1$，则为操作 $1$，之后有三个数 $l~r~k$，表示查询 $k$ 在区间 $[l,r]$ 的排名。\n\n若 $opt=2$，则为操作 $2$，之后有三个数 $l~r~k$，表示查询区间 $[l,r]$ 内排名为    $k$ 的数。\n\n若 $opt=3$，则为操作 $3$，之后有两个数 $pos~k$，表示将 $pos$ 位置的数修改为 $k$。\n\n若 $opt=4$，则为操作 $4$，之后有三个数 $l~r~k$，表示查询区间 $[l,r]$ 内 $k$ 的前驱。\n\n若 $opt=5$，则为操作 $5$，之后有三个数 $l~r~k$，表示查询区间 $[l,r]$ 内 $k$ 的后继。", "outputFormat": "对于操作 $1,2,4,5$，各输出一行，表示查询结果。", "hint": "$1\\le n,m\\le5\\times 10^4$，序列中的值在任何时刻 $\\in[0,10^8]$。\n\n题目来源：bzoj3196 / Tyvj1730，在此鸣谢。\n\n此数据为洛谷原创。**（特别提醒：此数据不保证操作 4、5 一定存在，故请务必考虑不存在的情况。）**", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Tree of Trees", "background": "", "description": "You need to implement a data structure (you may refer to the problem title) to maintain a sequence, supporting the following operations:\n1. Query the rank of $k$ within a range.\n2. Query the value whose rank is $k$ within a range.\n3. Modify the value at a certain position.\n4. Query the predecessor of $k$ within a range (the predecessor is defined as the largest number that is strictly less than $k$, and if it does not exist, output **`-2147483647`**).\n5. Query the successor of $k$ within a range (the successor is defined as the smallest number that is strictly greater than $k$, and if it does not exist, output **`2147483647`**).\n\nFor a set of elements, the rank of a number is defined as the count of elements strictly smaller than it plus one, and the number with rank $k$ is defined as “the element that would be at position $k$ after sorting the elements in ascending order.”", "inputFormat": "The first line contains two integers $n, m$, denoting a sequence of length $n$ and $m$ operations.\n\nThe second line contains $n$ integers, representing the sequence.\n\nThe next $m$ lines each contain an operation, where $opt$ denotes the operation id.\n\nIf $opt=1$, it is operation 1. Then there are three integers $l~r~k$, meaning: query the rank of $k$ in the range $[l,r]$.\n\nIf $opt=2$, it is operation 2. Then there are three integers $l~r~k$, meaning: query the number whose rank is $k$ in the range $[l,r]$.\n\nIf $opt=3$, it is operation 3. Then there are two integers $pos~k$, meaning: modify the value at position $pos$ to $k$.\n\nIf $opt=4$, it is operation 4. Then there are three integers $l~r~k$, meaning: query the predecessor of $k$ in the range $[l,r]$.\n\nIf $opt=5$, it is operation 5. Then there are three integers $l~r~k$, meaning: query the successor of $k$ in the range $[l,r]$.", "outputFormat": "For operations $1, 2, 4, 5$, output one line for each query, representing the result.", "hint": "Constraints: $1\\le n,m\\le 5\\times 10^4$, and the values in the sequence are always in $[0, 10^8]$ at any time.\n\nProblem source: bzoj3196 / Tyvj1730, with thanks.\n\nThis testdata is original to Luogu. Special reminder: this testdata does not guarantee that the answers for operations 4 and 5 always exist, so please be sure to handle the nonexistence cases.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】树套树", "background": "", "description": "您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：\n\n1. 查询 $k$ 在区间内的排名；\n2. 查询区间内排名为 $k$ 的值；\n3. 修改某一位置上的数值；\n4. 查询 $k$ 在区间内的前驱（前驱定义为严格小于 $x$，且最大的数，**若不存在输出 `-2147483647`**）；\n5. 查询 $k$ 在区间内的后继（后继定义为严格大于 $x$，且最小的数，**若不存在输出 `2147483647`**）。\n\n对于一组元素，一个数的排名被定义为严格比它小的元素个数加一，而排名为 $k$ 的数被定义为“将元素从小到大排序后排在第 $k$ 位的元素值”。", "inputFormat": "第一行两个数 $n,m$，表示长度为 $n$ 的有序序列和 $m$ 个操作。\n\n第二行有 $n$ 个数，表示有序序列。\n\n下面有 $m$ 行，$opt$ 表示操作标号。\n\n若 $opt=1$，则为操作 $1$，之后有三个数 $l~r~k$，表示查询 $k$ 在区间 $[l,r]$ 的排名。\n\n若 $opt=2$，则为操作 $2$，之后有三个数 $l~r~k$，表示查询区间 $[l,r]$ 内排名为    $k$ 的数。\n\n若 $opt=3$，则为操作 $3$，之后有两个数 $pos~k$，表示将 $pos$ 位置的数修改为 $k$。\n\n若 $opt=4$，则为操作 $4$，之后有三个数 $l~r~k$，表示查询区间 $[l,r]$ 内 $k$ 的前驱。\n\n若 $opt=5$，则为操作 $5$，之后有三个数 $l~r~k$，表示查询区间 $[l,r]$ 内 $k$ 的后继。", "outputFormat": "对于操作 $1,2,4,5$，各输出一行，表示查询结果。", "hint": "$1\\le n,m\\le5\\times 10^4$，序列中的值在任何时刻 $\\in[0,10^8]$。\n\n题目来源：bzoj3196 / Tyvj1730，在此鸣谢。\n\n此数据为洛谷原创。**（特别提醒：此数据不保证操作 4、5 一定存在，故请务必考虑不存在的情况。）**", "locale": "zh-CN"}}}
{"pid": "P3381", "type": "P", "difficulty": 5, "samples": [["4 5 4 3\n4 2 30 2\n4 3 20 3\n2 3 20 1\n2 1 30 9\n1 3 40 5", "50 280"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["网络流", "O2优化", "费用流", "模板题"], "title": "【模板】最小费用最大流", "background": "", "description": "\n给出一个包含 $n$ 个点和 $m$ 条边的有向图（下面称其为网络） $G=(V,E)$，该网络上所有点分别编号为 $1 \\sim n$，所有边分别编号为 $1\\sim m$，其中该网络的源点为 $s$，汇点为 $t$，网络上的每条边 $(u,v)$ 都有一个流量限制 $w(u,v)$ 和单位流量的费用 $c(u,v)$。\n\n你需要给每条边 $(u,v)$ 确定一个流量 $f(u,v)$，要求：\n\n1.  $0 \\leq f(u,v) \\leq w(u,v)$（每条边的流量不超过其流量限制）；\n2. $\\forall p \\in \\{V \\setminus \\{s,t\\}\\}$，$\\sum_{(i,p) \\in E}f(i,p)=\\sum_{(p,i)\\in E}f(p,i)$（除了源点和汇点外，其他各点流入的流量和流出的流量相等）；\n3. $\\sum_{(s,i)\\in E}f(s,i)=\\sum_{(i,t)\\in E}f(i,t)$（源点流出的流量等于汇点流入的流量）。\n\n定义网络 $G$ 的流量 $F(G)=\\sum_{(s,i)\\in E}f(s,i)$，网络 $G$ 的费用 $C(G)=\\sum_{(i,j)\\in E} f(i,j) \\times c(i,j)$。\n\n你需要求出该网络的**最小费用最大流**，即在 $F(G)$ 最大的前提下，使 $C(G)$ 最小。", "inputFormat": "输入第一行包含四个整数 $n,m,s,t$，分别代表该网络的点数 $n$，网络的边数 $m$，源点编号 $s$，汇点编号 $t$。\n\n接下来 $m$ 行，每行四个整数 $u_i,v_i,w_i,c_i$，分别代表第 $i$ 条边的起点，终点，流量限制，单位流量费用。", "outputFormat": "输出两个整数，分别为该网络的最大流 $F(G)$，以及在 $F(G)$ 最大的前提下，该网络的最小费用 $C(G)$。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 5\\times 10^3$，$1 \\leq m \\leq 5 \\times 10^4$，$1 \\leq s,t \\leq n$，$u_i \\neq v_i$，$0 \\leq w_i,c_i \\leq 10^3$，且该网络的最大流和最小费用 $\\leq 2^{31}-1$。\n\n输入数据随机生成。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Minimum Cost Maximum Flow", "background": "", "description": "Given a directed graph (hereinafter referred to as a network) $G=(V,E)$ with $n$ vertices and $m$ edges. The vertices are numbered $1 \\sim n$, and the edges are numbered $1 \\sim m$. The source of the network is $s$, and the sink is $t$. Each edge $(u,v)$ has a capacity limit $w(u,v)$ and a unit cost $c(u,v)$.\n\nYou need to assign a flow $f(u,v)$ to each edge $(u,v)$ such that:\n1. $0 \\leq f(u,v) \\leq w(u,v)$ (the flow on each edge does not exceed its capacity limit);\n2. $\\forall p \\in \\{V \\setminus \\{s,t\\}\\}$, $\\sum_{(i,p) \\in E} f(i,p) = \\sum_{(p,i) \\in E} f(p,i)$ (for all vertices except the source and the sink, the total inflow equals the total outflow);\n3. $\\sum_{(s,i) \\in E} f(s,i) = \\sum_{(i,t) \\in E} f(i,t)$ (the total flow leaving the source equals the total flow entering the sink).\n\nDefine the network flow $F(G)=\\sum_{(s,i)\\in E} f(s,i)$ and the network cost $C(G)=\\sum_{(i,j)\\in E} f(i,j) \\times c(i,j)$.\n\nYou need to find the minimum-cost maximum flow of the network, that is, maximize $F(G)$ and, subject to that, minimize $C(G)$.", "inputFormat": "The first line contains four integers $n,m,s,t$, representing the number of vertices, the number of edges, the index of the source, and the index of the sink, respectively.\n\nEach of the next $m$ lines contains four integers $u_i,v_i,w_i,c_i$, representing the start vertex, end vertex, capacity limit, and unit cost of the $i$-th edge.", "outputFormat": "Output two integers: the maximum flow $F(G)$ and, subject to $F(G)$ being maximum, the minimum cost $C(G)$.", "hint": "Constraints:\n\nFor $100\\%$ of the testdata, $1 \\leq n \\leq 5 \\times 10^3$, $1 \\leq m \\leq 5 \\times 10^4$, $1 \\leq s,t \\leq n$, $u_i \\neq v_i$, $0 \\leq w_i,c_i \\leq 10^3$, and the network’s maximum flow and minimum cost $\\leq 2^{31}-1$.\n\nThe testdata is randomly generated.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】最小费用最大流", "background": "", "description": "\n给出一个包含 $n$ 个点和 $m$ 条边的有向图（下面称其为网络） $G=(V,E)$，该网络上所有点分别编号为 $1 \\sim n$，所有边分别编号为 $1\\sim m$，其中该网络的源点为 $s$，汇点为 $t$，网络上的每条边 $(u,v)$ 都有一个流量限制 $w(u,v)$ 和单位流量的费用 $c(u,v)$。\n\n你需要给每条边 $(u,v)$ 确定一个流量 $f(u,v)$，要求：\n\n1.  $0 \\leq f(u,v) \\leq w(u,v)$（每条边的流量不超过其流量限制）；\n2. $\\forall p \\in \\{V \\setminus \\{s,t\\}\\}$，$\\sum_{(i,p) \\in E}f(i,p)=\\sum_{(p,i)\\in E}f(p,i)$（除了源点和汇点外，其他各点流入的流量和流出的流量相等）；\n3. $\\sum_{(s,i)\\in E}f(s,i)=\\sum_{(i,t)\\in E}f(i,t)$（源点流出的流量等于汇点流入的流量）。\n\n定义网络 $G$ 的流量 $F(G)=\\sum_{(s,i)\\in E}f(s,i)$，网络 $G$ 的费用 $C(G)=\\sum_{(i,j)\\in E} f(i,j) \\times c(i,j)$。\n\n你需要求出该网络的**最小费用最大流**，即在 $F(G)$ 最大的前提下，使 $C(G)$ 最小。", "inputFormat": "输入第一行包含四个整数 $n,m,s,t$，分别代表该网络的点数 $n$，网络的边数 $m$，源点编号 $s$，汇点编号 $t$。\n\n接下来 $m$ 行，每行四个整数 $u_i,v_i,w_i,c_i$，分别代表第 $i$ 条边的起点，终点，流量限制，单位流量费用。", "outputFormat": "输出两个整数，分别为该网络的最大流 $F(G)$，以及在 $F(G)$ 最大的前提下，该网络的最小费用 $C(G)$。", "hint": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 5\\times 10^3$，$1 \\leq m \\leq 5 \\times 10^4$，$1 \\leq s,t \\leq n$，$u_i \\neq v_i$，$0 \\leq w_i,c_i \\leq 10^3$，且该网络的最大流和最小费用 $\\leq 2^{31}-1$。\n\n输入数据随机生成。", "locale": "zh-CN"}}}
{"pid": "P3382", "type": "P", "difficulty": 3, "samples": [["3 -0.9981 0.5\n1 -3 -3 1", "-0.41421"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["二分", "三分", "Special Judge"], "title": "三分", "background": "本题可能存在严重精度问题，部分数据下难以通过。本题数据较水，仅供参考。", "description": "如题，给出一个 $N$ 次函数，保证在范围 $[l, r]$ 内存在一点 $x$，使得 $[l, x]$ 上单调增，$[x, r]$ 上单调减。试求出 $x$ 的值。", "inputFormat": "第一行一次包含一个正整数 $N$ 和两个实数 $l, r$，含义如题目描述所示。\n\n第二行包含 $N + 1$ 个实数，从高到低依次表示该 $N$ 次函数各项的系数。", "outputFormat": "输出为一行，包含一个实数，即为 $x$ 的值。若你的答案满足以下二者之一，则算正确：\n- 你的答案 $x'$ 与标准答案 $x$ 的相对或绝对误差不超过 $10^{-5}$。\n- 你的答案 $x'$ 与标准答案 $x$ 对应的函数值，即 $f(x') $ 和 $f(x)$ 的相对或绝对误差不超过 $10^{-5}$。\n\n", "hint": "对于 $100\\%$ 的数据，$6 \\le N \\le 13$，函数系数均在 $[-100,100]$ 内且至多 $15$ 位小数，$|l|,|r|\\leq 10$ 且至多 $15$ 位小数。$l\\leq r$。\n\n**【样例解释】**\n\n ![](https://cdn.luogu.com.cn/upload/pic/2297.png) \n\n如图所示，红色段即为该函数 $f(x) = x^3 - 3 x^2 - 3x + 1$ 在区间 $[-0.9981, 0.5]$ 上的图像。\n\n当 $x = -0.41421$ 时图像位于最高点，故此时函数在 $[l, x]$ 上单调增，$[x, r]$ 上单调减，故 $x = -0.41421$，输出 $-0.41421$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Ternary Search", "background": "This problem may have severe precision issues and can be hard to pass on some testdata. The testdata is relatively weak and is for reference only.", "description": "As stated, you are given an $N$-th degree polynomial. It is guaranteed that within the interval $[l, r]$ there exists a point $x$ such that the function is monotonically increasing on $[l, x]$ and monotonically decreasing on $[x, r]$. Find the value of $x$.", "inputFormat": "The first line contains a positive integer $N$ and two real numbers $l, r$, as described above.\n\nThe second line contains $N + 1$ real numbers, representing the coefficients of the $N$-th degree polynomial from highest degree to lowest.", "outputFormat": "Output one line containing a real number, which is the value of $x$. Your answer is considered correct if it satisfies either of the following:\n- Your answer $x'$ has a relative or absolute error not exceeding $10^{-5}$ compared to the standard answer $x$.\n- The function values corresponding to your answer and the standard answer, that is, $f(x')$ and $f(x)$, have a relative or absolute error not exceeding $10^{-5}$.", "hint": "For $100\\%$ of the testdata, $6 \\le N \\le 13$, the coefficients of the polynomial are in $[-100, 100]$ with up to $15$ decimal places, $|l|, |r| \\le 10$ with up to $15$ decimal places, and $l \\le r$.\n\nSample Explanation:\n\n![](https://cdn.luogu.com.cn/upload/pic/2297.png)\n\nAs shown in the figure, the red segment is the graph of the function $f(x) = x^3 - 3 x^2 - 3x + 1$ on the interval $[-0.9981, 0.5]$.\n\nWhen $x = -0.41421$, the graph reaches its highest point, so the function is monotonically increasing on $[l, x]$ and monotonically decreasing on $[x, r]$. Therefore $x = -0.41421$, and the output is $-0.41421$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "三分", "background": "本题可能存在严重精度问题，部分数据下难以通过。本题数据较水，仅供参考。", "description": "如题，给出一个 $N$ 次函数，保证在范围 $[l, r]$ 内存在一点 $x$，使得 $[l, x]$ 上单调增，$[x, r]$ 上单调减。试求出 $x$ 的值。", "inputFormat": "第一行一次包含一个正整数 $N$ 和两个实数 $l, r$，含义如题目描述所示。\n\n第二行包含 $N + 1$ 个实数，从高到低依次表示该 $N$ 次函数各项的系数。", "outputFormat": "输出为一行，包含一个实数，即为 $x$ 的值。若你的答案满足以下二者之一，则算正确：\n- 你的答案 $x'$ 与标准答案 $x$ 的相对或绝对误差不超过 $10^{-5}$。\n- 你的答案 $x'$ 与标准答案 $x$ 对应的函数值，即 $f(x') $ 和 $f(x)$ 的相对或绝对误差不超过 $10^{-5}$。\n\n", "hint": "对于 $100\\%$ 的数据，$6 \\le N \\le 13$，函数系数均在 $[-100,100]$ 内且至多 $15$ 位小数，$|l|,|r|\\leq 10$ 且至多 $15$ 位小数。$l\\leq r$。\n\n**【样例解释】**\n\n ![](https://cdn.luogu.com.cn/upload/pic/2297.png) \n\n如图所示，红色段即为该函数 $f(x) = x^3 - 3 x^2 - 3x + 1$ 在区间 $[-0.9981, 0.5]$ 上的图像。\n\n当 $x = -0.41421$ 时图像位于最高点，故此时函数在 $[l, x]$ 上单调增，$[x, r]$ 上单调减，故 $x = -0.41421$，输出 $-0.41421$。\n", "locale": "zh-CN"}}}
{"pid": "P3383", "type": "P", "difficulty": 2, "samples": [["100 5\n1\n2\n3\n4\n5", "2\n3\n5\n7\n11"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "O2优化", "素数判断,质数,筛法", "模板题"], "title": "【模板】线性筛素数", "background": "本题已更新，从判断素数改为了查询第 $k$ 小的素数。  \n\n提示：本题输入输出、运算数据量较大。\n\n- 对于 C++ 语言，如果你使用 `cin` 来输入输出，建议使用 `std::ios::sync_with_stdio(0)` 来加速，同时使用 `'\\n'` 换行输出。\n- 对于 Java 语言，使用线性筛并且优化输入输出，也可以在规定时限内通过本题，但是时限可能较紧张。\n- 对于 Python 语言，语言性能差异较大，需要使用到 `numpy` 库的数组以替代列表，且使用埃氏筛法，依然可以在合适的时间和内存消耗下通过本题。", "description": "如题，给定一个范围 $n$，有 $q$ 个询问，每次输出第 $k$ 小的素数。\n", "inputFormat": "第一行包含两个正整数 $n,q$，分别表示查询的范围和查询的个数。\n\n接下来 $q$ 行每行一个正整数 $k$，表示查询第 $k$ 小的素数。", "outputFormat": "输出 $q$ 行，每行一个正整数表示答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$n = 10^8$，$1 \\le q \\le 10^6$，保证查询的素数不大于 $n$。\n\nData by NaCly\\_Fish.\n", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Linear Sieve for Primes", "background": "This problem has been updated: it now asks for querying the $k$-th smallest prime instead of primality testing.\n\nHint: The input/output and computation workload can be large.\n\n- For C++: if you use `cin` for I/O, consider `std::ios::sync_with_stdio(0)` for acceleration, and use `'\\n'` for newlines.\n- For Java: using a linear sieve with optimized I/O can pass within the time limit, though it may be tight.\n- For Python: performance varies widely by implementation; using arrays from the `numpy` library instead of lists, together with the Sieve of Eratosthenes, can still pass within reasonable time and memory limits.", "description": "Given an upper bound $n$ and $q$ queries, for each query output the $k$-th smallest prime number.", "inputFormat": "The first line contains two positive integers $n, q$, representing the query range and the number of queries.\n\nEach of the next $q$ lines contains a positive integer $k$, asking for the $k$-th smallest prime.", "outputFormat": "Output $q$ lines, each containing a single integer as the answer.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $n = 10^8$, $1 \\le q \\le 10^6$, and it is guaranteed that the requested primes do not exceed $n$.\n\nData by NaCly\\_Fish.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】线性筛素数", "background": "本题已更新，从判断素数改为了查询第 $k$ 小的素数。  \n\n提示：本题输入输出、运算数据量较大。\n\n- 对于 C++ 语言，如果你使用 `cin` 来输入输出，建议使用 `std::ios::sync_with_stdio(0)` 来加速，同时使用 `'\\n'` 换行输出。\n- 对于 Java 语言，使用线性筛并且优化输入输出，也可以在规定时限内通过本题，但是时限可能较紧张。\n- 对于 Python 语言，语言性能差异较大，需要使用到 `numpy` 库的数组以替代列表，且使用埃氏筛法，依然可以在合适的时间和内存消耗下通过本题。", "description": "如题，给定一个范围 $n$，有 $q$ 个询问，每次输出第 $k$ 小的素数。\n", "inputFormat": "第一行包含两个正整数 $n,q$，分别表示查询的范围和查询的个数。\n\n接下来 $q$ 行每行一个正整数 $k$，表示查询第 $k$ 小的素数。", "outputFormat": "输出 $q$ 行，每行一个正整数表示答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$n = 10^8$，$1 \\le q \\le 10^6$，保证查询的素数不大于 $n$。\n\nData by NaCly\\_Fish.\n", "locale": "zh-CN"}}}
{"pid": "P3384", "type": "P", "difficulty": 5, "samples": [["5 5 2 24\n7 3 7 8 0 \n1 2\n1 5\n3 1\n4 1\n3 4 2\n3 2 2\n4 5\n1 5 1 3\n2 1 3", "2\n21"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["线段树", "树状数组", "树链剖分", "模板题"], "title": "【模板】重链剖分 / 树链剖分", "background": "", "description": "如题，已知一棵包含 $N$ 个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：\n\n- `1 x y z`，表示将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$。\n\n- `2 x y`，表示求树从 $x$ 到 $y$ 结点最短路径上所有节点的值之和。\n\n- `3 x z`，表示将以 $x$ 为根节点的子树内所有节点值都加上 $z$。\n\n- `4 x`，表示求以 $x$ 为根节点的子树内所有节点值之和。", "inputFormat": "第一行包含 $4$ 个正整数 $N,M,R,P$，分别表示树的结点个数、操作个数、根节点序号和取模数（**即所有的输出结果均对此取模**）。\n\n接下来一行包含 $N$ 个非负整数，分别依次表示各个节点上初始的数值。\n\n接下来 $N-1$ 行每行包含两个整数 $x,y$，表示点 $x$ 和点 $y$ 之间连有一条边（保证无环且连通）。\n\n接下来 $M$ 行每行包含若干个正整数，每行表示一个操作。", "outputFormat": "输出包含若干行，分别依次表示每个操作 $2$ 或操作 $4$ 所得的结果（**对 $P$ 取模**）。", "hint": "**【数据规模】**\n\n对于 $30\\%$ 的数据： $1 \\leq N \\leq 10$，$1 \\leq M \\leq 10$；\n\n对于 $70\\%$ 的数据： $1 \\leq N \\leq {10}^3$，$1 \\leq M \\leq {10}^3$；\n\n对于 $100\\%$ 的数据： $1\\le N \\leq {10}^5$，$1\\le M \\leq {10}^5$，$1\\le R\\le N$，$1\\le P \\le 2^{30}$。所有输入的数均在 `int` 范围内。\n\n**【样例说明】**\n\n树的结构如下：\n\n![](https://cdn.luogu.com.cn/upload/pic/2319.png)\n\n各个操作如下：\n\n![](https://cdn.luogu.com.cn/upload/pic/2320.png)\n\n故输出应依次为 $2$ 和 $21$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Heavy-Light Decomposition / Tree Chain Decomposition", "background": "", "description": "As stated, given a tree with $N$ nodes (connected and acyclic), each node stores a value. Support the following operations:\n\n- `1 x y z`: add $z$ to the value of every node on the shortest path from $x$ to $y$ in the tree.\n- `2 x y`: query the sum of values of all nodes on the shortest path from $x$ to $y$ in the tree.\n- `3 x z`: add $z$ to the value of every node in the subtree rooted at $x$.\n- `4 x`: query the sum of values of all nodes in the subtree rooted at $x$.", "inputFormat": "The first line contains $4$ positive integers $N, M, R, P$, representing the number of nodes in the tree, the number of operations, the index of the root, and the modulus, respectively (i.e., all outputs are taken modulo this).\n\nThe next line contains $N$ non-negative integers, representing the initial value at each node in order.\n\nThe next $N-1$ lines each contain two integers $x, y$, indicating an edge between nodes $x$ and $y$ (guaranteed acyclic and connected).\n\nThe next $M$ lines each contain several positive integers; each line represents one operation.", "outputFormat": "Output several lines, each being the result of operation type `2` or `4` (taken modulo $P$), in order.", "hint": "**[Constraints]**\n\nFor $30\\%$ of the testdata: $1 \\leq N \\leq 10$, $1 \\leq M \\leq 10$.\n\nFor $70\\%$ of the testdata: $1 \\leq N \\leq {10}^3$, $1 \\leq M \\leq {10}^3$.\n\nFor $100\\%$ of the testdata: $1 \\le N \\le {10}^5$, $1 \\le M \\le {10}^5$, $1 \\le R \\le N$, $1 \\le P \\le 2^{30}$. All input numbers are within the `int` range.\n\n**[Sample Explanation]**\n\nThe structure of the tree is as follows:\n\n![](https://cdn.luogu.com.cn/upload/pic/2319.png)\n\nThe operations are as follows:\n\n![](https://cdn.luogu.com.cn/upload/pic/2320.png)\n\nTherefore, the outputs should be $2$ and $21$ in order.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】重链剖分 / 树链剖分", "background": "", "description": "如题，已知一棵包含 $N$ 个结点的树（连通且无环），每个节点上包含一个数值，需要支持以下操作：\n\n- `1 x y z`，表示将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$。\n\n- `2 x y`，表示求树从 $x$ 到 $y$ 结点最短路径上所有节点的值之和。\n\n- `3 x z`，表示将以 $x$ 为根节点的子树内所有节点值都加上 $z$。\n\n- `4 x`，表示求以 $x$ 为根节点的子树内所有节点值之和。", "inputFormat": "第一行包含 $4$ 个正整数 $N,M,R,P$，分别表示树的结点个数、操作个数、根节点序号和取模数（**即所有的输出结果均对此取模**）。\n\n接下来一行包含 $N$ 个非负整数，分别依次表示各个节点上初始的数值。\n\n接下来 $N-1$ 行每行包含两个整数 $x,y$，表示点 $x$ 和点 $y$ 之间连有一条边（保证无环且连通）。\n\n接下来 $M$ 行每行包含若干个正整数，每行表示一个操作。", "outputFormat": "输出包含若干行，分别依次表示每个操作 $2$ 或操作 $4$ 所得的结果（**对 $P$ 取模**）。", "hint": "**【数据规模】**\n\n对于 $30\\%$ 的数据： $1 \\leq N \\leq 10$，$1 \\leq M \\leq 10$；\n\n对于 $70\\%$ 的数据： $1 \\leq N \\leq {10}^3$，$1 \\leq M \\leq {10}^3$；\n\n对于 $100\\%$ 的数据： $1\\le N \\leq {10}^5$，$1\\le M \\leq {10}^5$，$1\\le R\\le N$，$1\\le P \\le 2^{30}$。所有输入的数均在 `int` 范围内。\n\n**【样例说明】**\n\n树的结构如下：\n\n![](https://cdn.luogu.com.cn/upload/pic/2319.png)\n\n各个操作如下：\n\n![](https://cdn.luogu.com.cn/upload/pic/2320.png)\n\n故输出应依次为 $2$ 和 $21$。", "locale": "zh-CN"}}}
{"pid": "P3385", "type": "P", "difficulty": 3, "samples": [["2\n3 4\n1 2 2\n1 3 4\n2 3 1\n3 1 -3\n3 3\n1 2 3\n2 3 4\n3 1 -8\n", "NO\nYES\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["图论", "O2优化", "负权环", "模板题"], "title": "【模板】负环", "background": "", "description": "给定一个 $n$ 个点的有向图，请求出图中是否存在**从顶点 $1$ 出发能到达**的负环。\n\n负环的定义是：一条边权之和为负数的回路。", "inputFormat": "**本题单测试点有多组测试数据**。\n\n输入的第一行是一个整数 $T$，表示测试数据的组数。对于每组数据的格式如下：\n\n第一行有两个整数，分别表示图的点数 $n$ 和接下来给出边信息的条数 $m$。\n\n接下来 $m$ 行，每行三个整数 $u, v, w$。\n\n- 若 $w \\geq 0$，则表示存在一条从 $u$ 至 $v$ 边权为 $w$ 的边，还存在一条从 $v$ 至 $u$ 边权为 $w$ 的边。\n- 若 $w < 0$，则只表示存在一条从 $u$ 至 $v$ 边权为 $w$ 的边。", "outputFormat": "对于每组数据，输出一行一个字符串，若所求负环存在，则输出 `YES`，否则输出 `NO`。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq n \\leq 2 \\times 10^3$，$1 \\leq m \\leq 3 \\times 10^3$。\n- $1 \\leq u, v \\leq n$，$-10^4 \\leq w \\leq 10^4$。\n- $1 \\leq T \\leq 10$。\n\n#### 提示\n\n请注意，$m$ **不是**图的边数。", "locale": "zh-CN", "translations": {"en": {"title": "【Template】Negative Cycle", "background": "", "description": "Given a directed graph with $n$ vertices, determine whether there exists a negative cycle that is **reachable from vertex $1$**.\n\nA negative cycle is defined as a cycle whose sum of edge weights is negative.", "inputFormat": "This problem contains multiple groups of testdata in a single test point.\n\nThe first line contains an integer $T$, representing the number of groups of testdata. For each group, the format is as follows:\n\nThe first line contains two integers, the number of vertices $n$ and the number of lines $m$ of edge information that follow.\n\nThen follow $m$ lines, each with three integers $u, v, w$.\n\n- If $w \\geq 0$, then there exists an edge from $u$ to $v$ with weight $w$, and also an edge from $v$ to $u$ with weight $w$.\n- If $w < 0$, then there exists only an edge from $u$ to $v$ with weight $w$.", "outputFormat": "For each group of testdata, output one line containing a string. Print `YES` if such a negative cycle exists, otherwise print `NO`.", "hint": "#### Constraints and Conventions\n\nFor all test points, it is guaranteed that:\n\n- $1 \\leq n \\leq 2 \\times 10^3$, $1 \\leq m \\leq 3 \\times 10^3$.\n- $1 \\leq u, v \\leq n$, $-10^4 \\leq w \\leq 10^4$.\n- $1 \\leq T \\leq 10$.\n\n#### Hint\n\nPlease note that $m$ is **not** the number of edges of the graph.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】负环", "background": "", "description": "给定一个 $n$ 个点的有向图，请求出图中是否存在**从顶点 $1$ 出发能到达**的负环。\n\n负环的定义是：一条边权之和为负数的回路。", "inputFormat": "**本题单测试点有多组测试数据**。\n\n输入的第一行是一个整数 $T$，表示测试数据的组数。对于每组数据的格式如下：\n\n第一行有两个整数，分别表示图的点数 $n$ 和接下来给出边信息的条数 $m$。\n\n接下来 $m$ 行，每行三个整数 $u, v, w$。\n\n- 若 $w \\geq 0$，则表示存在一条从 $u$ 至 $v$ 边权为 $w$ 的边，还存在一条从 $v$ 至 $u$ 边权为 $w$ 的边。\n- 若 $w < 0$，则只表示存在一条从 $u$ 至 $v$ 边权为 $w$ 的边。", "outputFormat": "对于每组数据，输出一行一个字符串，若所求负环存在，则输出 `YES`，否则输出 `NO`。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq n \\leq 2 \\times 10^3$，$1 \\leq m \\leq 3 \\times 10^3$。\n- $1 \\leq u, v \\leq n$，$-10^4 \\leq w \\leq 10^4$。\n- $1 \\leq T \\leq 10$。\n\n#### 提示\n\n请注意，$m$ **不是**图的边数。", "locale": "zh-CN"}}}
{"pid": "P3386", "type": "P", "difficulty": 4, "samples": [["1 1 1\n1 1\n", "1"], ["4 2 7\n3 1\n1 2\n3 2\n1 1\n4 2\n4 1\n1 1\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "二分图", "模板题"], "title": "【模板】二分图最大匹配", "background": "", "description": "给定一个二分图，其左部点的个数为 $n$，右部点的个数为 $m$，边数为 $e$，求其最大匹配的边数。\n\n左部点从 $1$ 至 $n$ 编号，右部点从 $1$ 至 $m$ 编号。", "inputFormat": "输入的第一行是三个整数，分别代表 $n$，$m$ 和 $e$。\n\n接下来 $e$ 行，每行两个整数 $u, v$，表示存在一条连接左部点 $u$ 和右部点 $v$ 的边。", "outputFormat": "输出一行一个整数，代表二分图最大匹配的边数。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n- $1 \\leq n, m \\leq 500$。\n- $1 \\leq e \\leq 5 \\times 10^4$。\n- $1 \\leq u \\leq n$，$1 \\leq v \\leq m$。\n\n**不保证给出的图没有重边**。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Maximum Bipartite Matching", "background": "", "description": "Given a bipartite graph with $n$ left vertices, $m$ right vertices, and $e$ edges, find the size of its maximum matching.\n\nThe left vertices are numbered from $1$ to $n$, and the right vertices are numbered from $1$ to $m$.", "inputFormat": "The first line contains three integers, representing $n$, $m$, and $e$.\n\nThe next $e$ lines each contain two integers $u, v$, indicating that there is an edge connecting left vertex $u$ and right vertex $v$.", "outputFormat": "Output a single integer on one line, representing the size of the maximum matching of the bipartite graph.", "hint": "#### Constraints\n\nFor all test points, it is guaranteed that:\n- $1 \\leq n, m \\leq 500$.\n- $1 \\leq e \\leq 5 \\times 10^4$.\n- $1 \\leq u \\leq n$, $1 \\leq v \\leq m$.\n\nThe given graph is not guaranteed to be free of multiple edges.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】二分图最大匹配", "background": "", "description": "给定一个二分图，其左部点的个数为 $n$，右部点的个数为 $m$，边数为 $e$，求其最大匹配的边数。\n\n左部点从 $1$ 至 $n$ 编号，右部点从 $1$ 至 $m$ 编号。", "inputFormat": "输入的第一行是三个整数，分别代表 $n$，$m$ 和 $e$。\n\n接下来 $e$ 行，每行两个整数 $u, v$，表示存在一条连接左部点 $u$ 和右部点 $v$ 的边。", "outputFormat": "输出一行一个整数，代表二分图最大匹配的边数。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n- $1 \\leq n, m \\leq 500$。\n- $1 \\leq e \\leq 5 \\times 10^4$。\n- $1 \\leq u \\leq n$，$1 \\leq v \\leq m$。\n\n**不保证给出的图没有重边**。\n", "locale": "zh-CN"}}}
{"pid": "P3387", "type": "P", "difficulty": 4, "samples": [["2 2\n1 1\n1 2\n2 1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "拓扑排序", "强连通分量", "Tarjan", "模板题"], "title": "【模板】缩点", "background": "", "description": "给定一个 $n$ 个点 $m$ 条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。\n\n允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。\n", "inputFormat": "第一行两个正整数 $n,m$。\n\n第二行 $n$ 个整数，其中第 $i$ 个数 $a_i$ 表示点 $i$ 的点权。\n\n第三至 $m+2$ 行，每行两个整数 $u,v$，表示一条 $u\\rightarrow v$ 的有向边。\n", "outputFormat": "共一行，最大的点权之和。\n", "hint": "对于 $100\\%$ 的数据，$1\\le n \\le 10^4$，$1\\le m \\le 10^5$，$0\\le a_i\\le 10^3$。\n\n- 2024-11-1 添加了 [hack 数据](https://www.luogu.com.cn/discuss/964940)；", "locale": "zh-CN", "translations": {"en": {"title": "[Template] SCC Condensation", "background": "", "description": "Given a directed graph with $n$ vertices and $m$ edges, each vertex has a weight. Find a path such that the sum of the weights of the vertices visited is maximized. You only need to output this sum.\n\nYou are allowed to traverse an edge or a vertex multiple times. However, if a vertex is visited repeatedly, its weight is counted only once.", "inputFormat": "The first line contains two positive integers $n, m$.\n\nThe second line contains $n$ integers, where the $i$-th number $a_i$ is the weight of vertex $i$.\n\nLines 3 through $m+2$ each contain two integers $u, v$, indicating a directed edge $u \\rightarrow v$.", "outputFormat": "Output a single line with the maximum sum of vertex weights.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le n \\le 10^4$, $1 \\le m \\le 10^5$, $0 \\le a_i \\le 10^3$.\n\n- 2024-11-1 Added [hack testdata](https://www.luogu.com.cn/discuss/964940).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】缩点", "background": "", "description": "给定一个 $n$ 个点 $m$ 条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。\n\n允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。\n", "inputFormat": "第一行两个正整数 $n,m$。\n\n第二行 $n$ 个整数，其中第 $i$ 个数 $a_i$ 表示点 $i$ 的点权。\n\n第三至 $m+2$ 行，每行两个整数 $u,v$，表示一条 $u\\rightarrow v$ 的有向边。\n", "outputFormat": "共一行，最大的点权之和。\n", "hint": "对于 $100\\%$ 的数据，$1\\le n \\le 10^4$，$1\\le m \\le 10^5$，$0\\le a_i\\le 10^3$。\n\n- 2024-11-1 添加了 [hack 数据](https://www.luogu.com.cn/discuss/964940)；", "locale": "zh-CN"}}}
{"pid": "P3388", "type": "P", "difficulty": 4, "samples": [["6 7\n1 2\n1 3\n1 4\n2 5\n3 5\n4 5\n5 6", "1 \n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["Tarjan", "双连通分量", "模板题"], "title": "【模板】割点（割顶）", "background": "割点", "description": "给出一个 $n$ 个点，$m$ 条边的无向图，求图的割点。", "inputFormat": "第一行输入两个正整数 $n,m$。\n\n下面 $m$ 行每行输入两个正整数 $x,y$ 表示 $x$ 到 $y$ 有一条边。", "outputFormat": "第一行输出割点个数。\n\n第二行按照节点编号从小到大输出节点，用空格隔开。", "hint": "对于全部数据，$1\\leq n \\le 2\\times 10^4$，$1\\leq m \\le 1 \\times 10^5$。\n\n点的编号均大于 $0$ 小于等于 $n$。\n\n**Tarjan 图不一定连通。**", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Articulation Points (Cut Vertices)", "background": "Articulation points.", "description": "Given an undirected graph with $n$ vertices and $m$ edges, find all articulation points of the graph.", "inputFormat": "The first line contains two positive integers $n$ and $m$.\nEach of the next $m$ lines contains two positive integers $x$ and $y$, indicating there is an edge between $x$ and $y$.", "outputFormat": "On the first line, output the number of articulation points.\nOn the second line, output the vertices in increasing order of their indices, separated by spaces.", "hint": "For all testdata, $1\\leq n \\le 2\\times 10^4$, $1\\leq m \\le 1 \\times 10^5$. \nVertex indices are greater than $0$ and at most $n$. \nThe graph is not necessarily connected.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】割点（割顶）", "background": "割点", "description": "给出一个 $n$ 个点，$m$ 条边的无向图，求图的割点。", "inputFormat": "第一行输入两个正整数 $n,m$。\n\n下面 $m$ 行每行输入两个正整数 $x,y$ 表示 $x$ 到 $y$ 有一条边。", "outputFormat": "第一行输出割点个数。\n\n第二行按照节点编号从小到大输出节点，用空格隔开。", "hint": "对于全部数据，$1\\leq n \\le 2\\times 10^4$，$1\\leq m \\le 1 \\times 10^5$。\n\n点的编号均大于 $0$ 小于等于 $n$。\n\n**Tarjan 图不一定连通。**", "locale": "zh-CN"}}}
{"pid": "P3389", "type": "P", "difficulty": 5, "samples": [["3\n1 3 4 5\n1 4 7 3\n9 3 2 2", "-0.97\n5.18\n-2.39"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["Special Judge", "线性代数", "高斯消元", "模板题"], "title": "【模板】高斯消元法", "background": "如果想要更好地测试高斯消元算法模板请在通过此题后尝试通过 [SDOI2006 线性方程组](https://www.luogu.com.cn/problem/P2455) 这一题。", "description": "给定一个线性方程组，对其求解。\n\n$$ \\begin{cases} a_{1, 1} x_1 + a_{1, 2} x_2 + \\cdots + a_{1, n} x_n = b_1 \\\\ a_{2, 1} x_1 + a_{2, 2} x_2 + \\cdots + a_{2, n} x_n = b_2 \\\\ \\cdots \\\\ a_{n,1} x_1 + a_{n, 2} x_2 + \\cdots + a_{n, n} x_n = b_n \\end{cases}$$\n", "inputFormat": "第一行，一个正整数 $n$。\n\n第二至 $n+1$ 行，每行 $n+1$ 个整数，为 $ a_1, a_2, \\dots ,a_n$ 和 $b$，代表一组方程。\n", "outputFormat": "共 $n$ 行，每行一个数，第 $i$ 行为 $x_i$（四舍五入保留 $2$ 位小数）。\n\n如果不存在唯一解或无解，在第一行输出 `No Solution`.\n", "hint": "本题 special judge 用于处理可能由于浮点数问题输出 `-0.00` 的情况。若某个 $x_i$ 的解四舍五入后是 `0.00`，那么你的程序输出 `-0.00` 和输出 `0.00` 都是正确的。\n\n数据范围：$1 \\leq n \\leq 100, \\left | a_i \\right| \\leq {10}^4 , \\left |b \\right| \\leq {10}^4 $。保证数据若有解则所有解均满足 $|x_i|\\le 10^3$，且 $x_i\\pm 10^{-6}$ 和 $x_i$ 四舍五入后的结果相同（即不会因为较小的精度误差导致四舍五入后的结果不同）。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Gaussian Elimination", "background": "If you want to better test the Gaussian elimination template, after solving this problem, try [SDOI2006 线性方程组](https://www.luogu.com.cn/problem/P2455).", "description": "Given a system of linear equations, solve it.\n\n$$ \\begin{cases} a_{1, 1} x_1 + a_{1, 2} x_2 + \\cdots + a_{1, n} x_n = b_1 \\\\ a_{2, 1} x_1 + a_{2, 2} x_2 + \\cdots + a_{2, n} x_n = b_2 \\\\ \\cdots \\\\ a_{n,1} x_1 + a_{n, 2} x_2 + \\cdots + a_{n, n} x_n = b_n \\end{cases}$$", "inputFormat": "The first line contains a positive integer $n$.\n\nLines $2$ to $n+1$ each contain $n+1$ integers, which are $ a_1, a_2, \\dots ,a_n$ and $b$, representing one equation.", "outputFormat": "Output $n$ lines, one number per line. The $i$-th line is $x_i$ (rounded to $2$ decimal places).\n\nIf there is no solution or the solution is not unique, output `No Solution` on the first line.", "hint": "This problem uses a special judge to handle cases where floating-point issues might produce `-0.00`. If some $x_i$ rounds to `0.00`, then both `-0.00` and `0.00` are accepted.\n\nConstraints: $1 \\leq n \\leq 100, \\left | a_i \\right| \\leq {10}^4 , \\left |b \\right| \\leq {10}^4$. It is guaranteed that if there is a solution, then all solutions satisfy $|x_i|\\le 10^3$, and the rounded results of $x_i\\pm 10^{-6}$ and $x_i$ are the same (i.e., small precision errors will not change the rounded result).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】高斯消元法", "background": "如果想要更好地测试高斯消元算法模板请在通过此题后尝试通过 [SDOI2006 线性方程组](https://www.luogu.com.cn/problem/P2455) 这一题。", "description": "给定一个线性方程组，对其求解。\n\n$$ \\begin{cases} a_{1, 1} x_1 + a_{1, 2} x_2 + \\cdots + a_{1, n} x_n = b_1 \\\\ a_{2, 1} x_1 + a_{2, 2} x_2 + \\cdots + a_{2, n} x_n = b_2 \\\\ \\cdots \\\\ a_{n,1} x_1 + a_{n, 2} x_2 + \\cdots + a_{n, n} x_n = b_n \\end{cases}$$\n", "inputFormat": "第一行，一个正整数 $n$。\n\n第二至 $n+1$ 行，每行 $n+1$ 个整数，为 $ a_1, a_2, \\dots ,a_n$ 和 $b$，代表一组方程。\n", "outputFormat": "共 $n$ 行，每行一个数，第 $i$ 行为 $x_i$（四舍五入保留 $2$ 位小数）。\n\n如果不存在唯一解或无解，在第一行输出 `No Solution`.\n", "hint": "本题 special judge 用于处理可能由于浮点数问题输出 `-0.00` 的情况。若某个 $x_i$ 的解四舍五入后是 `0.00`，那么你的程序输出 `-0.00` 和输出 `0.00` 都是正确的。\n\n数据范围：$1 \\leq n \\leq 100, \\left | a_i \\right| \\leq {10}^4 , \\left |b \\right| \\leq {10}^4 $。保证数据若有解则所有解均满足 $|x_i|\\le 10^3$，且 $x_i\\pm 10^{-6}$ 和 $x_i$ 四舍五入后的结果相同（即不会因为较小的精度误差导致四舍五入后的结果不同）。", "locale": "zh-CN"}}}
{"pid": "P3390", "type": "P", "difficulty": 4, "samples": [["2 1\n1 1\n1 1", "1 1\n1 1"], ["3 5\n1 2 3\n4 5 6\n7 8 9", "121824 149688 177552\n275886 338985 402084\n429948 528282 626616"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "O2优化", "矩阵乘法", "模板题"], "title": "【模板】矩阵快速幂", "background": "一个 $m \\times n$ 的**矩阵**是一个由 $m$ 行 $n$ 列元素排列成的矩形阵列。即形如\n\n$$ A = \\begin{bmatrix} a_{1 1} & a_{1 2} & \\cdots & a_{1 n} \\\\ a_{2 1} & a_{2 2} & \\cdots & a_{2 n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{m 1} & a_{m 2} & \\cdots & a_{m n} \\end{bmatrix} \\text{.} $$\n\n本题中认为矩阵中的元素 $a_{i j}$ 是整数。\n\n两个大小分别为 $m \\times n$ 和 $n \\times p$ 的矩阵 $A, B$ **相乘**的结果为一个大小为 $m \\times p$ 的矩阵。将结果矩阵记作 $C$，则\n\n$$ c_{i j} = \\sum_{k = 1}^{n} a_{i k} b_{k j} \\text{,\\qquad($1 \\le i \\le m$, $1 \\le j \\le p$).} $$\n\n而如果 $A$ 的列数与 $B$ 的行数不相等，则无法进行乘法。\n\n可以验证，矩阵乘法满足结合律，即 $(A B) C = A (B C)$。\n\n一个大小为 $n \\times n$ 的矩阵 $A$ 可以与自身进行乘法，得到的仍是大小为 $n \\times n$ 的矩阵，记作 $A^2 = A \\times A$。进一步地，还可以递归地定义任意高次方 $A^k = A \\times A^{k - 1}$，或称 $A^k = \\underbrace{A \\times A \\times \\cdots \\times A}_{k \\text{ 次}}$。\n\n特殊地，定义 $A^0$ 为单位矩阵 $I = \\begin{bmatrix} 1 & 0 & \\cdots & 0 \\\\ 0 & 1 & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 \\end{bmatrix}$。", "description": "给定 $n\\times n$ 的矩阵 $A$，求 $A^k$。\n", "inputFormat": "第一行两个整数 $n,k$。  \n接下来 $n$ 行，每行 $n$ 个整数，第 $i$ 行的第 $j$ 的数表示 $A_{i,j}$。", "outputFormat": "输出 $A^k$\n\n共 $n$ 行，每行 $n$ 个数，第 $i$ 行第 $j$ 个数表示 $(A^k)_{i,j}$，每个元素对 $10^9+7$ 取模。\n", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le n \\le 100$，$0 \\le k \\le 10^{12}$，$|A_{i,j}| \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Matrix Fast Exponentiation", "background": "An $m \\times n$ matrix is a rectangular array of elements arranged in $m$ rows and $n$ columns. That is,\n\n$$ A = \\begin{bmatrix} a_{1 1} & a_{1 2} & \\cdots & a_{1 n} \\\\ a_{2 1} & a_{2 2} & \\cdots & a_{2 n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{m 1} & a_{m 2} & \\cdots & a_{m n} \\end{bmatrix} \\text{.} $$\n\nIn this problem, the elements $a_{i j}$ in a matrix are integers.\n\nGiven matrices $A, B$ of sizes $m \\times n$ and $n \\times p$, respectively, their product is an $m \\times p$ matrix. Denote the result by $C$, then\n\n$$ c_{i j} = \\sum_{k = 1}^{n} a_{i k} b_{k j} \\text{,\\qquad($1 \\le i \\le m$, $1 \\le j \\le p$).} $$\n\nIf the number of columns of $A$ does not equal the number of rows of $B$, the product cannot be computed.\n\nIt can be verified that matrix multiplication is associative, i.e., $(A B) C = A (B C)$.\n\nAn $n \\times n$ matrix $A$ can be multiplied by itself to obtain another $n \\times n$ matrix, denoted $A^2 = A \\times A$. Furthermore, higher powers can be defined recursively as $A^k = A \\times A^{k - 1}$, or $A^k = \\underbrace{A \\times A \\times \\cdots \\times A}_{k \\text{ 次}}$.\n\nIn particular, define $A^0$ as the identity matrix $I = \\begin{bmatrix} 1 & 0 & \\cdots & 0 \\\\ 0 & 1 & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 \\end{bmatrix}$.", "description": "Given an $n \\times n$ matrix $A$, compute $A^k$.", "inputFormat": "The first line contains two integers $n,k$.  \nThen follow $n$ lines, each containing $n$ integers. In row $i$, the $j$-th number denotes $A_{i,j}$.", "outputFormat": "Output $A^k$.\n\nThere are $n$ lines in total, each containing $n$ numbers. The number in row $i$ and column $j$ denotes $(A^k)_{i,j}$. Each element is taken modulo $10^9+7$.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 100$, $0 \\le k \\le 10^{12}$, $|A_{i,j}| \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】矩阵快速幂", "background": "一个 $m \\times n$ 的**矩阵**是一个由 $m$ 行 $n$ 列元素排列成的矩形阵列。即形如\n\n$$ A = \\begin{bmatrix} a_{1 1} & a_{1 2} & \\cdots & a_{1 n} \\\\ a_{2 1} & a_{2 2} & \\cdots & a_{2 n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{m 1} & a_{m 2} & \\cdots & a_{m n} \\end{bmatrix} \\text{.} $$\n\n本题中认为矩阵中的元素 $a_{i j}$ 是整数。\n\n两个大小分别为 $m \\times n$ 和 $n \\times p$ 的矩阵 $A, B$ **相乘**的结果为一个大小为 $m \\times p$ 的矩阵。将结果矩阵记作 $C$，则\n\n$$ c_{i j} = \\sum_{k = 1}^{n} a_{i k} b_{k j} \\text{,\\qquad($1 \\le i \\le m$, $1 \\le j \\le p$).} $$\n\n而如果 $A$ 的列数与 $B$ 的行数不相等，则无法进行乘法。\n\n可以验证，矩阵乘法满足结合律，即 $(A B) C = A (B C)$。\n\n一个大小为 $n \\times n$ 的矩阵 $A$ 可以与自身进行乘法，得到的仍是大小为 $n \\times n$ 的矩阵，记作 $A^2 = A \\times A$。进一步地，还可以递归地定义任意高次方 $A^k = A \\times A^{k - 1}$，或称 $A^k = \\underbrace{A \\times A \\times \\cdots \\times A}_{k \\text{ 次}}$。\n\n特殊地，定义 $A^0$ 为单位矩阵 $I = \\begin{bmatrix} 1 & 0 & \\cdots & 0 \\\\ 0 & 1 & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 \\end{bmatrix}$。", "description": "给定 $n\\times n$ 的矩阵 $A$，求 $A^k$。\n", "inputFormat": "第一行两个整数 $n,k$。  \n接下来 $n$ 行，每行 $n$ 个整数，第 $i$ 行的第 $j$ 的数表示 $A_{i,j}$。", "outputFormat": "输出 $A^k$\n\n共 $n$ 行，每行 $n$ 个数，第 $i$ 行第 $j$ 个数表示 $(A^k)_{i,j}$，每个元素对 $10^9+7$ 取模。\n", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le n \\le 100$，$0 \\le k \\le 10^{12}$，$|A_{i,j}| \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P3391", "type": "P", "difficulty": 5, "samples": [["5 3\n1 3\n1 3\n1 4", "4 3 2 1 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["平衡树", "O2优化", "模板题"], "title": "【模板】文艺平衡树", "background": "", "description": "您需要写一种数据结构（可参考题目标题），来维护一个有序数列。  \n\n其中需要提供以下操作：翻转一个区间，例如原有序序列是 $5\\ 4\\ 3\\ 2\\ 1$，翻转区间是 $[2,4]$ 的话，结果是 $5\\ 2\\ 3\\ 4\\ 1$。\n", "inputFormat": "第一行两个正整数 $n,m$，表示序列长度与操作个数。序列中第 $i$ 项初始为 $i$。  \n接下来 $m$ 行，每行两个正整数 $l,r$，表示翻转的区间。\n", "outputFormat": "输出一行 $n$ 个正整数，表示原始序列经过 $m$ 次变换后的结果。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1 \\le n, m \\leq 100000 $，$1 \\le l \\le r \\le n$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Wenyi Balanced Tree", "background": null, "description": "You need to implement a data structure (you can refer to the title) to maintain an ordered sequence.\n\nIt must support the following operation: reverse a segment. For example, if the original ordered sequence is $5\\ 4\\ 3\\ 2\\ 1$, and the reversed segment is $[2, 4]$, then the result is $5\\ 2\\ 3\\ 4\\ 1$.", "inputFormat": "The first line contains two positive integers $n, m$, denoting the length of the sequence and the number of operations. Initially, the $i$-th element of the sequence is $i$.\n\nThen follow $m$ lines, each containing two positive integers $l, r$, denoting the segment to reverse.", "outputFormat": "Output one line with $n$ positive integers, which is the result after applying $m$ reversals to the original sequence.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n, m \\le 100000$, $1 \\le l \\le r \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】文艺平衡树", "background": "", "description": "您需要写一种数据结构（可参考题目标题），来维护一个有序数列。  \n\n其中需要提供以下操作：翻转一个区间，例如原有序序列是 $5\\ 4\\ 3\\ 2\\ 1$，翻转区间是 $[2,4]$ 的话，结果是 $5\\ 2\\ 3\\ 4\\ 1$。\n", "inputFormat": "第一行两个正整数 $n,m$，表示序列长度与操作个数。序列中第 $i$ 项初始为 $i$。  \n接下来 $m$ 行，每行两个正整数 $l,r$，表示翻转的区间。\n", "outputFormat": "输出一行 $n$ 个正整数，表示原始序列经过 $m$ 次变换后的结果。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1 \\le n, m \\leq 100000 $，$1 \\le l \\le r \\le n$。\n", "locale": "zh-CN"}}}
{"pid": "P3392", "type": "P", "difficulty": 2, "samples": [["4 5\nWRWRW\nBWRWB\nWRWRW\nRWBWR", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2016", "枚举", "洛谷月赛"], "title": "涂条纹", "background": "", "description": "只要一个由 $N \\times M$ 个小方块组成的旗帜符合如下规则，就是合法的图案。\n\n- 从最上方若干行（至少一行）的格子全部是白色的；\n- 接下来若干行（至少一行）的格子全部是蓝色的；\n- 剩下的行（至少一行）全部是红色的；\n\n现有一个棋盘状的布，分成了 $N$ 行 $M$ 列的格子，每个格子是白色蓝色红色之一，小 a 希望把这个布改成合法图案，方法是在一些格子上涂颜料，盖住之前的颜色。\n\n小 A 很懒，希望涂最少的格子，使这块布成为一个合法的图案。", "inputFormat": "第一行是两个整数 $N,M$。\n\n接下来 $N$ 行是一个矩阵，矩阵的每一个小方块是 `W`（白），`B`（蓝），`R`（红）中的一个。", "outputFormat": "一个整数，表示至少需要涂多少块。\n", "hint": "### 样例解释\n\n目标状态是：\n\n```plain\nWWWWW\nBBBBB\nRRRRR\nRRRRR\n```\n一共需要改 $11$ 个格子。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$N,M \\leq 50$。", "locale": "zh-CN", "translations": {"en": {"title": "Painting Stripes", "background": "", "description": "As long as a flag composed of $N \\times M$ small squares meets the following rules, it is a valid pattern.\n- All cells in the top several rows (at least one row) are white.\n- The next several rows (at least one row) are blue.\n- The remaining rows (at least one row) are red.\n\nThere is a cloth divided into $N$ rows and $M$ columns of cells, where each cell is one of white, blue, or red. Xiao A hopes to turn this cloth into a valid pattern by painting some cells to cover their previous colors.\n\nXiao A is lazy and wants to repaint the fewest cells so that the cloth becomes a valid pattern.", "inputFormat": "The first line contains two integers $N, M$.\n\nEach of the next $N$ lines is a string of length $M$, where each character is one of `W` (white), `B` (blue), or `R` (red).", "outputFormat": "A single integer, the minimum number of cells that need to be repainted.", "hint": "### Sample Explanation\n\nTarget state is:\n\n```plain\nWWWWW\nBBBBB\nRRRRR\nRRRRR\n```\nIn total, $11$ cells need to be changed.\n\n### Constraints\n\nFor $100\\%$ of the testdata, $N, M \\leq 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "涂条纹", "background": "", "description": "只要一个由 $N \\times M$ 个小方块组成的旗帜符合如下规则，就是合法的图案。\n\n- 从最上方若干行（至少一行）的格子全部是白色的；\n- 接下来若干行（至少一行）的格子全部是蓝色的；\n- 剩下的行（至少一行）全部是红色的；\n\n现有一个棋盘状的布，分成了 $N$ 行 $M$ 列的格子，每个格子是白色蓝色红色之一，小 a 希望把这个布改成合法图案，方法是在一些格子上涂颜料，盖住之前的颜色。\n\n小 A 很懒，希望涂最少的格子，使这块布成为一个合法的图案。", "inputFormat": "第一行是两个整数 $N,M$。\n\n接下来 $N$ 行是一个矩阵，矩阵的每一个小方块是 `W`（白），`B`（蓝），`R`（红）中的一个。", "outputFormat": "一个整数，表示至少需要涂多少块。\n", "hint": "### 样例解释\n\n目标状态是：\n\n```plain\nWWWWW\nBBBBB\nRRRRR\nRRRRR\n```\n一共需要改 $11$ 个格子。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$N,M \\leq 50$。", "locale": "zh-CN"}}}
{"pid": "P3393", "type": "P", "difficulty": 4, "samples": [["13 21 1 1\n1000 6000\n7\n1 2\n3 7\n2 4\n5 8\n8 9\n2 5\n3 4\n4 7\n9 10\n10 11\n5 9\n7 12\n3 6\n4 5\n1 3\n11 12\n6 7\n8 11\n6 13\n7 8\n12 13", "11000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "洛谷原创", "广度优先搜索 BFS", "最短路", "洛谷月赛"], "title": "逃离僵尸岛", "background": "", "description": "小 a 住的国家被僵尸侵略了！小 a 打算逃离到该国唯一的国际空港逃出这个国家。\n\n\n该国有 $N$ 个城市，城市之间有道路相连。一共有 $M$ 条双向道路。保证没有自环和重边。\n\n\n其中 $K$ 个城市已经被僵尸控制了，如果贸然闯入就会被感染 TAT...所以不能进入。由其中任意城市经过不超过 $S$ 条道路就可以到达的别的城市，就是危险城市。换句话说只要某个城市到任意被僵尸控制的城市距离不超过 $S$，就是危险的。\n\n小 a 住在 $1$ 号城市，国际空港在 $N$ 号城市，这两座城市没有被侵略。小a走每一段道路（从一个城市直接到达另外一个城市）得花一整个白天，所以晚上要住旅店。安全的的城市旅馆比较便宜要 $P$ 元，而被危险的城市，旅馆要进行安保措施，所以会变贵，为 $Q$ 元。所有危险的城市的住宿价格一样，安全的城市也是。在 $1$ 号城市和 $N$ 城市，不需要住店。\n\n\n小 a 比较抠门，所以他希望知道从 $1$ 号城市到 $N$ 号城市所需要的最小花费。\n\n输入数据保证存在路径，可以成功逃离。输入数据保证他可以逃离成功。", "inputFormat": "第一行 4 个整数 $N,M,K,S$。\n\n第二行两个整数 $P,Q$。\n\n接下来 $K$ 行，每行一个整数 $c_i$，表示僵尸侵占的城市编号。\n\n接下来 $M$ 行，$a_i,b_i$，表示一条无向边。\n", "outputFormat": "一个整数表示最低花费。", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/2681.png) \n\n对于 $20\\%$ 数据，$N\\le 50$。\n\n对于 $100\\%$ 数据，$2\\le N\\le 10^5$，$1\\le M\\le 2\\times 10^5$，$0\\le K\\le N - 2$，$0\\le S\\le 10^5$，$1\\le P< Q\\le 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Escape from Zombie Island", "background": "", "description": "The country where Xiao A lives has been invaded by zombies! Xiao A plans to escape the country via the only international airport.\n\nThe country has $N$ cities connected by roads. There are $M$ bidirectional roads. There are no self-loops or multiple edges.\n\nAmong them, $K$ cities have already been taken over by zombies. Entering any such city will result in infection, so these cities cannot be entered. Any city that can be reached from any zombie-controlled city by traversing at most $S$ roads is considered dangerous. In other words, if a city’s distance to any zombie-controlled city is at most $S$, then it is dangerous.\n\nXiao A lives in city $1$, the international airport is in city $N$, and these two cities are not invaded. Xiao A spends an entire day to traverse each single road (moving directly from one city to another), so he must stay at an inn at night. Inns in safe cities are cheaper and cost $P$, while inns in dangerous cities need extra security measures and thus cost $Q$. All dangerous cities share the same lodging price, and so do all safe cities. In cities $1$ and $N$, no lodging is required.\n\nXiao A is frugal, so he wants to know the minimum cost to travel from city $1$ to city $N$.\n\nThe input guarantees that there exists a path and that he can successfully escape.", "inputFormat": "- The first line contains $4$ integers $N, M, K, S$.\n- The second line contains two integers $P, Q$.\n- The next $K$ lines each contain one integer $c_i$, the index of a zombie-controlled city.\n- The next $M$ lines each contain two integers $a_i, b_i$, indicating an undirected edge.", "outputFormat": "Output a single integer, the minimum total cost.", "hint": "![](https://cdn.luogu.com.cn/upload/pic/2681.png) \n\n- For $20\\%$ of the testdata, $N \\le 50$.\n- For $100\\%$ of the testdata, $2 \\le N \\le 10^5$, $1 \\le M \\le 2 \\times 10^5$, $0 \\le K \\le N - 2$, $0 \\le S \\le 10^5$, $1 \\le P < Q \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "逃离僵尸岛", "background": "", "description": "小 a 住的国家被僵尸侵略了！小 a 打算逃离到该国唯一的国际空港逃出这个国家。\n\n\n该国有 $N$ 个城市，城市之间有道路相连。一共有 $M$ 条双向道路。保证没有自环和重边。\n\n\n其中 $K$ 个城市已经被僵尸控制了，如果贸然闯入就会被感染 TAT...所以不能进入。由其中任意城市经过不超过 $S$ 条道路就可以到达的别的城市，就是危险城市。换句话说只要某个城市到任意被僵尸控制的城市距离不超过 $S$，就是危险的。\n\n小 a 住在 $1$ 号城市，国际空港在 $N$ 号城市，这两座城市没有被侵略。小a走每一段道路（从一个城市直接到达另外一个城市）得花一整个白天，所以晚上要住旅店。安全的的城市旅馆比较便宜要 $P$ 元，而被危险的城市，旅馆要进行安保措施，所以会变贵，为 $Q$ 元。所有危险的城市的住宿价格一样，安全的城市也是。在 $1$ 号城市和 $N$ 城市，不需要住店。\n\n\n小 a 比较抠门，所以他希望知道从 $1$ 号城市到 $N$ 号城市所需要的最小花费。\n\n输入数据保证存在路径，可以成功逃离。输入数据保证他可以逃离成功。", "inputFormat": "第一行 4 个整数 $N,M,K,S$。\n\n第二行两个整数 $P,Q$。\n\n接下来 $K$ 行，每行一个整数 $c_i$，表示僵尸侵占的城市编号。\n\n接下来 $M$ 行，$a_i,b_i$，表示一条无向边。\n", "outputFormat": "一个整数表示最低花费。", "hint": " ![](https://cdn.luogu.com.cn/upload/pic/2681.png) \n\n对于 $20\\%$ 数据，$N\\le 50$。\n\n对于 $100\\%$ 数据，$2\\le N\\le 10^5$，$1\\le M\\le 2\\times 10^5$，$0\\le K\\le N - 2$，$0\\le S\\le 10^5$，$1\\le P< Q\\le 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P3395", "type": "P", "difficulty": 3, "samples": [["2\n\n2\n1 1\n2 2\n\n5\n3 3\n3 2\n3 1\n1 2\n1 3\n1 4\n1 5\n2 2", "Yes\nYes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "洛谷原创", "O2优化", "广度优先搜索 BFS", "洛谷比赛"], "title": "路障", "background": "", "description": "B 君站在一个 $n\\times n$ 的棋盘上。最开始，B君站在 $(1,1)$ 这个点，他要走到 $(n,n)$ 这个点。\n\nB 君每秒可以向上下左右的某个方向移动一格，但是很不妙，C 君打算阻止 B 君的计划。\n\n**每秒结束的时刻**，C 君 会在 $(x,y)$ 上摆一个路障。B 君不能走在路障上。\n\nB 君拿到了 C 君准备在哪些点放置路障。所以现在你需要判断，B 君能否成功走到 $(n,n)$。\n\n**保证数据足够弱：也就是说，无需考虑“走到某处然后被一个路障砸死”的情况，因为答案不会出现此类情况。**", "inputFormat": "首先是一个正整数 $T$，表示数据组数。\n\n对于每一组数据：\n\n第一行，一个正整数 $n$。\n\n接下来 $2n-2$ 行，每行两个正整数 $x$ 和 $y$，意义是在那一秒结束后，$(x,y)$ 将被摆上路障。", "outputFormat": "对于每一组数据，输出 `Yes` 或 `No`，回答 B 君能否走到 $(n,n)$。", "hint": "样例解释：\n\n以下 0 表示能走，x 表示不能走，B 表示 B 君现在的位置。从左往右表示时间。\n\n```\nCase 1:\n0 0    0 0    0 B  (已经走到了)\nB 0    x B    x 0\n```\n```\nCase 2:\n0 0 0 0 0    0 0 0 0 0    0 0 0 0 0    0 0 0 0 0\n0 0 0 0 0    0 0 0 0 0    0 0 0 0 0    0 0 0 0 0\n0 0 0 0 0    0 0 x 0 0    0 0 x 0 0    0 0 x 0 0\n0 0 0 0 0    0 0 0 0 0    0 0 x 0 0    0 0 x 0 0\nB 0 0 0 0    0 B 0 0 0    0 0 B 0 0    0 0 x B 0 ......(B君可以走到终点)\n```\n\n数据规模：\n\n防止骗分，数据保证全部手造。\n\n对于 $20\\%$ 的数据，有 $n\\le3$。\n\n对于 $60\\%$ 的数据，有 $n\\le500$。\n\n对于 $100\\%$ 的数据，有 $n\\le1000$。\n\n对于 $100\\%$ 的数据，有 $T\\le10$。", "locale": "zh-CN", "translations": {"en": {"title": "Roadblocks", "background": "# Description\n\nB stands on an $n \\times n$ chessboard. At the beginning, B is at $(1,1)$ and wants to go to $(n,n)$.\n\nEach second, B can move one cell in one of the four directions: up, down, left, or right. However, C plans to stop B.\n\nAt the end of each second, C will place a roadblock at $(x,y)$. B cannot step on a roadblock.\n\nB knows in advance where C will place the roadblocks. Now you need to determine whether B can reach $(n,n)$.\n\nIt is guaranteed that the testdata is weak enough: that is, you do not need to consider the case where B moves to some cell and then gets killed by a roadblock dropping onto that cell, because such cases will not appear in the answers.", "description": "", "inputFormat": "", "outputFormat": "For each test case, output `Yes` or `No`, answering whether B can reach $(n,n)$.", "hint": "Sample explanation:\n\nHere 0 means passable, x means blocked, and B means B's current position. From left to right represents time.\n\n```\nCase 1:\n0 0    0 0    0 B  (already reached)\nB 0    x B    x 0\n```\n```\nCase 2:\n0 0 0 0 0    0 0 0 0 0    0 0 0 0 0    0 0 0 0 0\n0 0 0 0 0    0 0 0 0 0    0 0 0 0 0    0 0 0 0 0\n0 0 0 0 0    0 0 x 0 0    0 0 x 0 0    0 0 x 0 0\n0 0 0 0 0    0 0 0 0 0    0 0 x 0 0    0 0 x 0 0\nB 0 0 0 0    0 B 0 0 0    0 0 B 0 0    0 0 x B 0 ......(B can reach the target)\n```\n\nConstraints:\n\n- To prevent score farming, all testdata are handcrafted.\n- For $20\\%$ of the testdata, $n \\le 3$.\n- For $60\\%$ of the testdata, $n \\le 500$.\n- For $100\\%$ of the testdata, $n \\le 1000$.\n- For $100\\%$ of the testdata, $T \\le 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "路障", "background": "", "description": "B 君站在一个 $n\\times n$ 的棋盘上。最开始，B君站在 $(1,1)$ 这个点，他要走到 $(n,n)$ 这个点。\n\nB 君每秒可以向上下左右的某个方向移动一格，但是很不妙，C 君打算阻止 B 君的计划。\n\n**每秒结束的时刻**，C 君 会在 $(x,y)$ 上摆一个路障。B 君不能走在路障上。\n\nB 君拿到了 C 君准备在哪些点放置路障。所以现在你需要判断，B 君能否成功走到 $(n,n)$。\n\n**保证数据足够弱：也就是说，无需考虑“走到某处然后被一个路障砸死”的情况，因为答案不会出现此类情况。**", "inputFormat": "首先是一个正整数 $T$，表示数据组数。\n\n对于每一组数据：\n\n第一行，一个正整数 $n$。\n\n接下来 $2n-2$ 行，每行两个正整数 $x$ 和 $y$，意义是在那一秒结束后，$(x,y)$ 将被摆上路障。", "outputFormat": "对于每一组数据，输出 `Yes` 或 `No`，回答 B 君能否走到 $(n,n)$。", "hint": "样例解释：\n\n以下 0 表示能走，x 表示不能走，B 表示 B 君现在的位置。从左往右表示时间。\n\n```\nCase 1:\n0 0    0 0    0 B  (已经走到了)\nB 0    x B    x 0\n```\n```\nCase 2:\n0 0 0 0 0    0 0 0 0 0    0 0 0 0 0    0 0 0 0 0\n0 0 0 0 0    0 0 0 0 0    0 0 0 0 0    0 0 0 0 0\n0 0 0 0 0    0 0 x 0 0    0 0 x 0 0    0 0 x 0 0\n0 0 0 0 0    0 0 0 0 0    0 0 x 0 0    0 0 x 0 0\nB 0 0 0 0    0 B 0 0 0    0 0 B 0 0    0 0 x B 0 ......(B君可以走到终点)\n```\n\n数据规模：\n\n防止骗分，数据保证全部手造。\n\n对于 $20\\%$ 的数据，有 $n\\le3$。\n\n对于 $60\\%$ 的数据，有 $n\\le500$。\n\n对于 $100\\%$ 的数据，有 $n\\le1000$。\n\n对于 $100\\%$ 的数据，有 $T\\le10$。", "locale": "zh-CN"}}}
{"pid": "P3396", "type": "P", "difficulty": 4, "samples": [["10 5\n1 2 3 4 5 6 7 8 9 10\nA 2 1\nC 1 20\nA 3 1\nC 5 1\nA 5 0", "25\n41\n11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "O2优化", "根号分治", "洛谷比赛"], "title": "哈希冲突", "background": "众所周知，模数的 hash 会产生冲突。例如，如果模的数 $p=7$，那么 $4$ 和 $11$ 便冲突了。", "description": "B 君对 hash 冲突很感兴趣。他会给出一个正整数序列 $\\text{value}$。\n\n自然，B 君会把这些数据存进 hash 池。$\\text{value}_k$ 会被存进 $(k \\bmod p)$ 这个池。这样就能造成很多冲突。\n\n\nB 君会给定许多个 $p$ 和 $x$，询问在模 $p$ 时，$x$ 这个池内 **数的总和**。\n\n另外，B 君会随时更改 $\\text{value}_k$。每次更改立即生效。\n\n保证 $1\\leq p<n$。", "inputFormat": "第一行，两个正整数 $n$, $m$，其中 $n$ 代表序列长度，$m$ 代表 B 君的操作次数。\n\n\n第一行，$n$ 个正整数，代表初始序列。\n\n\n接下来 $m$ 行，首先是一个字符 $\\text{cmd}$，然后是两个整数 $x,y$。\n\n- 若 $\\text{cmd}=\\text{A}$，则询问在模 $x$ 时，$y$ 池内 **数的总和**。\n\n- 若 $\\text{cmd}=\\text{C}$，则将 $\\text{value}_x$ 修改为 $y$。", "outputFormat": "对于每个询问输出一个正整数，进行回答。", "hint": "#### 样例解释 \n\n`A 2 1` 的答案是 `1+3+5+7+9=25`。\n\n`A 3 1` 的答案是 `20+4+7+10=41`。\n\n`A 5 0` 的答案是 `1+10=11`。\n\n#### 数据规模\n\n对于 $10\\%$的数据，有 $n\\leq 1000$，$m\\leq 1000$。\n\n对于 $60\\%$ 的数据，有 $n\\leq 100000$，$m\\leq 100000$。\n\n对于 $100\\%$ 的数据，有 $n\\leq 150000$，$m\\leq 150000$。\n\n保证所有数据合法，且 $1\\leq \\mathrm{value}_i \\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Hash Collisions", "background": "As is well known, modular hashing produces collisions. For example, if the modulus $p=7$, then $4$ and $11$ collide.", "description": "B is very interested in hash collisions. He will give a sequence of positive integers $\\text{value}$.\n\nNaturally, B will store these data into hash buckets. $\\text{value}_k$ will be stored in the bucket $(k \\bmod p)$. This creates many collisions.\n\nB will give many pairs $p$ and $x$, asking for the sum of numbers in bucket $x$ under modulus $p$.\n\nIn addition, B may change $\\text{value}_k$ at any time. Each change takes effect immediately.\n\nIt is guaranteed that $1 \\leq p < n$.", "inputFormat": "The first line contains two positive integers $n$, $m$, where $n$ is the length of the sequence, and $m$ is the number of operations by B.\n\nThe second line contains $n$ positive integers, representing the initial sequence.\n\nThen $m$ lines follow. Each line starts with a character $\\text{cmd}$, followed by two integers $x$, $y$.\n- If $\\text{cmd}=\\text{A}$, query the sum of numbers in bucket $y$ under modulus $x$.\n- If $\\text{cmd}=\\text{C}$, change $\\text{value}_x$ to $y$.", "outputFormat": "For each query, output one positive integer as the answer.", "hint": "#### Sample Explanation\n\n`A 2 1` has the answer `1+3+5+7+9=25`.\n\n`A 3 1` has the answer `20+4+7+10=41`.\n\n`A 5 0` has the answer `1+10=11`.\n\n#### Constraints\n\nFor $10\\%$ of the testdata, $n \\leq 1000$, $m \\leq 1000$.\n\nFor $60\\%$ of the testdata, $n \\leq 100000$, $m \\leq 100000$.\n\nFor $100\\%$ of the testdata, $n \\leq 150000$, $m \\leq 150000$.\n\nAll testdata are valid, and $1 \\leq \\mathrm{value}_i \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "哈希冲突", "background": "众所周知，模数的 hash 会产生冲突。例如，如果模的数 $p=7$，那么 $4$ 和 $11$ 便冲突了。", "description": "B 君对 hash 冲突很感兴趣。他会给出一个正整数序列 $\\text{value}$。\n\n自然，B 君会把这些数据存进 hash 池。$\\text{value}_k$ 会被存进 $(k \\bmod p)$ 这个池。这样就能造成很多冲突。\n\n\nB 君会给定许多个 $p$ 和 $x$，询问在模 $p$ 时，$x$ 这个池内 **数的总和**。\n\n另外，B 君会随时更改 $\\text{value}_k$。每次更改立即生效。\n\n保证 $1\\leq p<n$。", "inputFormat": "第一行，两个正整数 $n$, $m$，其中 $n$ 代表序列长度，$m$ 代表 B 君的操作次数。\n\n\n第一行，$n$ 个正整数，代表初始序列。\n\n\n接下来 $m$ 行，首先是一个字符 $\\text{cmd}$，然后是两个整数 $x,y$。\n\n- 若 $\\text{cmd}=\\text{A}$，则询问在模 $x$ 时，$y$ 池内 **数的总和**。\n\n- 若 $\\text{cmd}=\\text{C}$，则将 $\\text{value}_x$ 修改为 $y$。", "outputFormat": "对于每个询问输出一个正整数，进行回答。", "hint": "#### 样例解释 \n\n`A 2 1` 的答案是 `1+3+5+7+9=25`。\n\n`A 3 1` 的答案是 `20+4+7+10=41`。\n\n`A 5 0` 的答案是 `1+10=11`。\n\n#### 数据规模\n\n对于 $10\\%$的数据，有 $n\\leq 1000$，$m\\leq 1000$。\n\n对于 $60\\%$ 的数据，有 $n\\leq 100000$，$m\\leq 100000$。\n\n对于 $100\\%$ 的数据，有 $n\\leq 150000$，$m\\leq 150000$。\n\n保证所有数据合法，且 $1\\leq \\mathrm{value}_i \\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P3397", "type": "P", "difficulty": 2, "samples": [["5 3\n2 2 3 3\n3 3 5 5\n1 2 1 4", "0 1 1 1 0\n0 1 1 0 0\n0 1 2 1 1\n0 0 1 1 1\n0 0 1 1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["洛谷原创", "枚举", "前缀和", "差分", "洛谷比赛"], "title": "地毯", "background": "[加强版](/problem/P13787)", "description": "在 $n\\times n$ 的格子上有 $m$ 个地毯。\n\n给出这些地毯的信息，问每个点被多少个地毯覆盖。", "inputFormat": "第一行，两个正整数 $n,m$。意义如题所述。\n\n接下来 $m$ 行，每行两个坐标 $(x_1,y_1)$ 和 $(x_2,y_2)$，代表一块地毯，左上角是 $(x_1,y_1)$，右下角是 $(x_2,y_2)$。", "outputFormat": "输出 $n$ 行，每行 $n$ 个正整数。\n\n第 $i$ 行第 $j$ 列的正整数表示 $(i,j)$ 这个格子被多少个地毯覆盖。", "hint": "### 样例解释\n\n覆盖第一个地毯后：\n\n|$0$|$0$|$0$|$0$|$0$|\n|:-:|:-:|:-:|:-:|:-:|\n|$0$|$1$|$1$|$0$|$0$|\n|$0$|$1$|$1$|$0$|$0$|\n|$0$|$0$|$0$|$0$|$0$|\n|$0$|$0$|$0$|$0$|$0$|\n\n覆盖第一、二个地毯后：\n\n|$0$|$0$|$0$|$0$|$0$|\n|:-:|:-:|:-:|:-:|:-:|\n|$0$|$1$|$1$|$0$|$0$|\n|$0$|$1$|$2$|$1$|$1$|\n|$0$|$0$|$1$|$1$|$1$|\n|$0$|$0$|$1$|$1$|$1$|\n\n覆盖所有地毯后：\n\n|$0$|$1$|$1$|$1$|$0$|\n|:-:|:-:|:-:|:-:|:-:|\n|$0$|$1$|$1$|$0$|$0$|\n|$0$|$1$|$2$|$1$|$1$|\n|$0$|$0$|$1$|$1$|$1$|\n|$0$|$0$|$1$|$1$|$1$|\n\n---\n\n### 数据范围\n\n对于 $20\\%$ 的数据，有 $n\\le 50$，$m\\le 100$。\n\n对于 $100\\%$ 的数据，有 $n,m\\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Carpets", "background": "[Enhanced Version](/problem/P13787)", "description": "On an $n \\times n$ grid, there are $m$ carpets. Given the information of these carpets, determine how many carpets cover each cell.", "inputFormat": "The first line contains two positive integers $n, m$, as described above.\nThen follow $m$ lines. Each line gives two coordinates $(x_1,y_1)$ and $(x_2,y_2)$, representing a carpet whose top-left corner is $(x_1,y_1)$ and bottom-right corner is $(x_2,y_2)$.", "outputFormat": "Output $n$ lines, each containing $n$ non-negative integers.\nThe integer in row $i$ and column $j$ denotes how many carpets cover the cell $(i,j)$.", "hint": "### Sample Explanation\n\nAfter covering the first carpet:\n\n|$0$|$0$|$0$|$0$|$0$|\n|:-:|:-:|:-:|:-:|:-:|\n|$0$|$1$|$1$|$0$|$0$|\n|$0$|$1$|$1$|$0$|$0$|\n|$0$|$0$|$0$|$0$|$0$|\n|$0$|$0$|$0$|$0$|$0$|\n\nAfter covering the first and second carpets:\n\n|$0$|$0$|$0$|$0$|$0$|\n|:-:|:-:|:-:|:-:|:-:|\n|$0$|$1$|$1$|$0$|$0$|\n|$0$|$1$|$2$|$1$|$1$|\n|$0$|$0$|$1$|$1$|$1$|\n|$0$|$0$|$1$|$1$|$1$|\n\nAfter covering all carpets:\n\n|$0$|$1$|$1$|$1$|$0$|\n|:-:|:-:|:-:|:-:|:-:|\n|$0$|$1$|$1$|$0$|$0$|\n|$0$|$1$|$2$|$1$|$1$|\n|$0$|$0$|$1$|$1$|$1$|\n|$0$|$0$|$1$|$1$|$1$|\n\n---\n\n### Constraints\n\nFor $20\\%$ of the testdata, $n \\le 50$, $m \\le 100$.\nFor $100\\%$ of the testdata, $n, m \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "地毯", "background": "[加强版](/problem/P13787)", "description": "在 $n\\times n$ 的格子上有 $m$ 个地毯。\n\n给出这些地毯的信息，问每个点被多少个地毯覆盖。", "inputFormat": "第一行，两个正整数 $n,m$。意义如题所述。\n\n接下来 $m$ 行，每行两个坐标 $(x_1,y_1)$ 和 $(x_2,y_2)$，代表一块地毯，左上角是 $(x_1,y_1)$，右下角是 $(x_2,y_2)$。", "outputFormat": "输出 $n$ 行，每行 $n$ 个正整数。\n\n第 $i$ 行第 $j$ 列的正整数表示 $(i,j)$ 这个格子被多少个地毯覆盖。", "hint": "### 样例解释\n\n覆盖第一个地毯后：\n\n|$0$|$0$|$0$|$0$|$0$|\n|:-:|:-:|:-:|:-:|:-:|\n|$0$|$1$|$1$|$0$|$0$|\n|$0$|$1$|$1$|$0$|$0$|\n|$0$|$0$|$0$|$0$|$0$|\n|$0$|$0$|$0$|$0$|$0$|\n\n覆盖第一、二个地毯后：\n\n|$0$|$0$|$0$|$0$|$0$|\n|:-:|:-:|:-:|:-:|:-:|\n|$0$|$1$|$1$|$0$|$0$|\n|$0$|$1$|$2$|$1$|$1$|\n|$0$|$0$|$1$|$1$|$1$|\n|$0$|$0$|$1$|$1$|$1$|\n\n覆盖所有地毯后：\n\n|$0$|$1$|$1$|$1$|$0$|\n|:-:|:-:|:-:|:-:|:-:|\n|$0$|$1$|$1$|$0$|$0$|\n|$0$|$1$|$2$|$1$|$1$|\n|$0$|$0$|$1$|$1$|$1$|\n|$0$|$0$|$1$|$1$|$1$|\n\n---\n\n### 数据范围\n\n对于 $20\\%$ 的数据，有 $n\\le 50$，$m\\le 100$。\n\n对于 $100\\%$ 的数据，有 $n,m\\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P3398", "type": "P", "difficulty": 4, "samples": [["5 5\n2 5\n4 2\n1 3\n1 4\n5 1 5 1\n2 2 1 4\n4 1 3 4\n3 1 1 5\n3 5 1 4", "Y\nN\nY\nY\nY"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "倍增", "洛谷原创", "最近公共祖先 LCA", "树链剖分", "洛谷月赛"], "title": "仓鼠找 sugar", "background": "", "description": "小仓鼠的和他的基（mei）友（zi）sugar 住在地下洞穴中，每个节点的编号为 $1\\sim n$。地下洞穴是一个树形结构。这一天小仓鼠打算从从他的卧室（$a$）到餐厅（$b$），而他的基友同时要从他的卧室（$c$）到图书馆（$d$）。他们都会走最短路径。现在小仓鼠希望知道，有没有可能在某个地方，可以碰到他的基友？\n\n\n小仓鼠那么弱，还要天天被 zzq 大爷虐，请你快来救救他吧！\n", "inputFormat": "第一行两个正整数 $n$ 和 $q$，表示这棵树节点的个数和询问的个数。\n\n接下来 $n-1$ 行，每行两个正整数 $u$ 和 $v$，表示节点 $u$ 到节点 $v$ 之间有一条边。\n\n接下来 $q$ 行，每行四个正整数 $a$、$b$、$c$ 和 $d$，表示节点编号，也就是一次询问，其意义如上。\n", "outputFormat": "对于每个询问，如果有公共点，输出大写字母 `Y`；否则输出`N`。\n", "hint": "**本题时限 1s，内存限制 128M，因新评测机速度较为接近 NOIP 评测机速度，请注意常数问题带来的影响。**\n\n\n$20\\%$ 的数据 $n, q\\le200$。\n\n$40\\%$ 的数据 $n, q\\le 2\\times10^3$。\n\n$70\\%$ 的数据 $n, q\\le 5\\times10^4$。\n\n$100\\%$ 的数据 $1\\le n, q\\le10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Hamster Looking for sugar", "background": "", "description": "The little hamster and his buddy sugar live in an underground cave, where each node is numbered $1 \\sim n$. The cave forms a tree. One day, the little hamster plans to go from his bedroom ($a$) to the dining room ($b$), while his buddy simultaneously goes from his bedroom ($c$) to the library ($d$). They both take the shortest paths. Now the little hamster wants to know whether it is possible for them to meet somewhere along the way.\n\nThe little hamster is so weak and even gets abused by Master zzq every day. Please come save him!", "inputFormat": "The first line contains two positive integers $n$ and $q$, representing the number of nodes in the tree and the number of queries.\n\nThe next $n - 1$ lines each contain two positive integers $u$ and $v$, indicating that there is an edge between nodes $u$ and $v$.\n\nThe next $q$ lines each contain four positive integers $a$, $b$, $c$, and $d$, representing a query as described above.", "outputFormat": "For each query, if there exists a common point, output the uppercase letter `Y`; otherwise output `N`.", "hint": "Time limit 1 s, memory limit 128 MB. Since the new judge is close to the NOIP judge in speed, please be aware of the impact of constant-factor overhead.\n\nFor 20% of the testdata, $n, q \\le 200$.\n\nFor 40% of the testdata, $n, q \\le 2 \\times 10^3$.\n\nFor 70% of the testdata, $n, q \\le 5 \\times 10^4$.\n\nFor 100% of the testdata, $1 \\le n, q \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "仓鼠找 sugar", "background": "", "description": "小仓鼠的和他的基（mei）友（zi）sugar 住在地下洞穴中，每个节点的编号为 $1\\sim n$。地下洞穴是一个树形结构。这一天小仓鼠打算从从他的卧室（$a$）到餐厅（$b$），而他的基友同时要从他的卧室（$c$）到图书馆（$d$）。他们都会走最短路径。现在小仓鼠希望知道，有没有可能在某个地方，可以碰到他的基友？\n\n\n小仓鼠那么弱，还要天天被 zzq 大爷虐，请你快来救救他吧！\n", "inputFormat": "第一行两个正整数 $n$ 和 $q$，表示这棵树节点的个数和询问的个数。\n\n接下来 $n-1$ 行，每行两个正整数 $u$ 和 $v$，表示节点 $u$ 到节点 $v$ 之间有一条边。\n\n接下来 $q$ 行，每行四个正整数 $a$、$b$、$c$ 和 $d$，表示节点编号，也就是一次询问，其意义如上。\n", "outputFormat": "对于每个询问，如果有公共点，输出大写字母 `Y`；否则输出`N`。\n", "hint": "**本题时限 1s，内存限制 128M，因新评测机速度较为接近 NOIP 评测机速度，请注意常数问题带来的影响。**\n\n\n$20\\%$ 的数据 $n, q\\le200$。\n\n$40\\%$ 的数据 $n, q\\le 2\\times10^3$。\n\n$70\\%$ 的数据 $n, q\\le 5\\times10^4$。\n\n$100\\%$ 的数据 $1\\le n, q\\le10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P3399", "type": "P", "difficulty": 3, "samples": [["3 5\n10\n25\n15\n50\n30\n15\n40\n30", "1125"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2016", "洛谷月赛"], "title": "丝绸之路", "background": "张骞于公元前 138 年曾历尽艰险出使过西域。加强了汉朝与西域各国的友好往来。从那以后，一队队骆驼商队在这漫长的商贸大道上行进，他们越过崇山峻岭，将中国的先进技术带向中亚、西亚和欧洲，将那里的香料、良马传进了我国。每当人们凝望荒凉的大漠孤烟，无不引起对往日商贸、文化繁荣的遐想……", "description": "小仓鼠带着货物，从中国送到安息，丝绸之路包括起点和终点一共有 $N+1$ 个城市，$0$ 号城市是起点长安，$N$ 号城市是终点巴格达。要求不超过 $M$ 天内必须到达终点。一天的时间可以从一个城市到连续的下一个城市。从 $i-1$ 城市到 $i$ 城市距离是 $D_i$。\n\n大家都知道，连续赶路是很辛苦的，所以小仓鼠可以在一个城市时，可以有以下选择：\n\n- 移动：向下一个城市进发\n\n- 休息：呆在原来的城市不动\n\n沙漠天气变化无常，在天气很不好时，前进会遇到很多困难。我们把 $M$ 天的第 $j(1\\le j \\le M)$ 天的气候恶劣值记为 $C_j$。从 $i-1$ 城市移动到 $i$ 城市在第 $j$ 天进发时，需要耗费 $D_i\\times C_j$ 的疲劳度。\n\n不过小仓鼠还是有选择权的，可以避开比较恶劣的天气，休息是不会消耗疲劳值的。现在他想知道整个行程最少要消耗多少疲劳值。", "inputFormat": "第一行 $2$ 个整数 $N$，$M$。\n\n接下来，连续 $N$ 行每行一个整数 $D_j$。\n\n连续 $M$ 行每行一个整数 $C_j$。", "outputFormat": "一个整数，表示最小疲劳度。", "hint": "### 样例解释\n\n第 $1$ 天休息。\n\n第 $2$ 天 $0 \\rightarrow 1$ 疲劳值 $10 \\times 30 = 300$。\n\n第 $3$ 天 $1 \\rightarrow2$ 疲劳值 $25 \\times 15 = 375$。\n\n第 $4$ 天休息。\n\n第 $5$ 天 $2 \\rightarrow3$ 疲劳值 $15 \\times 30 = 450$。\n\n### 数据范围\n\n$1 \\le N \\le M \\le 1000$。\n\n$1 \\le D_i , C_i \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Silk Road", "background": "In 138 BCE, Zhang Qian braved great hardships to serve as an envoy to the Western Regions, strengthening friendly exchanges between the Han dynasty and various states there. Since then, caravans of camels have traveled along this long trade route. They crossed lofty mountains, bringing China’s advanced technologies to Central Asia, West Asia, and Europe, and brought spices and fine horses from those regions into China. Whenever people gaze upon the desolate desert with a solitary plume of smoke, it evokes imagination of the past prosperity of trade and culture.", "description": "A little hamster is delivering goods from China to Baghdad. The Silk Road has $N+1$ cities including the start and the end. City $0$ is the starting point Chang’an, and city $N$ is the destination Baghdad. The hamster must reach the destination in at most $M$ days. In one day, it is possible to travel from one city to the next consecutive city. The distance from city $i-1$ to city $i$ is $D_i$.\n\nAs everyone knows, traveling continuously is exhausting, so when staying in a city, the hamster has two choices:\n- Move: set off toward the next city.\n- Rest: stay in the current city without moving.\n\nDesert weather is unpredictable. When the weather is bad, moving forward is much more difficult. Let the severity of the weather on the $j$-th day ($1 \\le j \\le M$) be $C_j$. If the hamster moves from city $i-1$ to city $i$ on day $j$, it incurs a fatigue of $D_i \\times C_j$.\n\nHowever, the hamster can choose to avoid worse weather; resting consumes no fatigue. Now it wants to know the minimum total fatigue for the whole trip.", "inputFormat": "The first line contains $2$ integers $N$ and $M$.\n\nThe next $N$ lines each contain one integer $D_j$.\n\nThe next $M$ lines each contain one integer $C_j$.", "outputFormat": "Output a single integer, the minimal total fatigue.", "hint": "### Sample Explanation\n\nRest on day $1$.\n\nOn day $2$, $0 \\rightarrow 1$, fatigue $10 \\times 30 = 300$.\n\nOn day $3$, $1 \\rightarrow 2$, fatigue $25 \\times 15 = 375$.\n\nRest on day $4$.\n\nOn day $5$, $2 \\rightarrow 3$, fatigue $15 \\times 30 = 450$.\n\n### Constraints\n\n$1 \\le N \\le M \\le 1000$.\n\n$1 \\le D_i, C_i \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "丝绸之路", "background": "张骞于公元前 138 年曾历尽艰险出使过西域。加强了汉朝与西域各国的友好往来。从那以后，一队队骆驼商队在这漫长的商贸大道上行进，他们越过崇山峻岭，将中国的先进技术带向中亚、西亚和欧洲，将那里的香料、良马传进了我国。每当人们凝望荒凉的大漠孤烟，无不引起对往日商贸、文化繁荣的遐想……", "description": "小仓鼠带着货物，从中国送到安息，丝绸之路包括起点和终点一共有 $N+1$ 个城市，$0$ 号城市是起点长安，$N$ 号城市是终点巴格达。要求不超过 $M$ 天内必须到达终点。一天的时间可以从一个城市到连续的下一个城市。从 $i-1$ 城市到 $i$ 城市距离是 $D_i$。\n\n大家都知道，连续赶路是很辛苦的，所以小仓鼠可以在一个城市时，可以有以下选择：\n\n- 移动：向下一个城市进发\n\n- 休息：呆在原来的城市不动\n\n沙漠天气变化无常，在天气很不好时，前进会遇到很多困难。我们把 $M$ 天的第 $j(1\\le j \\le M)$ 天的气候恶劣值记为 $C_j$。从 $i-1$ 城市移动到 $i$ 城市在第 $j$ 天进发时，需要耗费 $D_i\\times C_j$ 的疲劳度。\n\n不过小仓鼠还是有选择权的，可以避开比较恶劣的天气，休息是不会消耗疲劳值的。现在他想知道整个行程最少要消耗多少疲劳值。", "inputFormat": "第一行 $2$ 个整数 $N$，$M$。\n\n接下来，连续 $N$ 行每行一个整数 $D_j$。\n\n连续 $M$ 行每行一个整数 $C_j$。", "outputFormat": "一个整数，表示最小疲劳度。", "hint": "### 样例解释\n\n第 $1$ 天休息。\n\n第 $2$ 天 $0 \\rightarrow 1$ 疲劳值 $10 \\times 30 = 300$。\n\n第 $3$ 天 $1 \\rightarrow2$ 疲劳值 $25 \\times 15 = 375$。\n\n第 $4$ 天休息。\n\n第 $5$ 天 $2 \\rightarrow3$ 疲劳值 $15 \\times 30 = 450$。\n\n### 数据范围\n\n$1 \\le N \\le M \\le 1000$。\n\n$1 \\le D_i , C_i \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P3400", "type": "P", "difficulty": 5, "samples": [["3 4\n1 1 1 1\n1 0 1 1\n1 1 0 1", "26"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "洛谷原创", "洛谷月赛", "单调栈"], "title": "仓鼠窝", "background": "", "description": "萌萌哒的 Created equal 是一只小仓鼠，小仓鼠自然有仓鼠窝啦。\n\n仓鼠窝是一个由 $n\\times m$ 个格子组成的行数为 $n$、列数为 $m$ 的矩阵。小仓鼠现在想要知道，这个矩阵中有多少个子矩阵。\n\n比如说有一个 $2\\times 3$ 的矩阵，那么 $1\\times 1$ 的子矩阵有 $6$ 个，$1\\times 2$ 的子矩阵有 $4$ 个，$1\\times 3$ 的子矩阵有 $2$ 个，$2\\times 1$ 的子矩阵有 $3$ 个，$2\\times 2$ 的子矩阵有 $2$ 个，$2\\times 3$ 的子矩阵有 $1$ 个，所以子矩阵共有 $6+4+2+3+2+1=18$ 个。\n\n可是仓鼠窝中有的格子被破坏了。现在小仓鼠想要知道，有多少个内部不含被破坏的格子的子矩阵。\n", "inputFormat": "第一行两个正整数 $n$ 和 $m$，分别表示仓鼠窝的行数 $n$，列数 $m$。\n\n接下来 $n$ 行，每行 $m$ 个数，每个数代表对应的格子，非 $0$ 即 $1$。若为 $0$，表示这个格子被破坏；反之代表这个格子是完好无损的。", "outputFormat": "仅一个正整数，表示未被破坏的子矩阵的个数。\n", "hint": "本题时限 $2\\text{s}$，内存限制 $256\\text{M}$，因新评测机速度较为接近 NOIP 评测机速度，请注意常数问题带来的影响。\n\n|    数据编号     |     $n$       |     $m$      |        特殊性质        |\n| :------------: | :-----------: | :----------: | :--------------------: |\n|     $1, 2, 3$    |       $2$       |       $2$      |           无           |\n|        $4$       |      $10$       |      $10$      |           无           |\n|      $5, 6$      |      $2000$     |     $2000$     |   所有格子均未被破坏     |\n|        $7$       |      $2500$     |     $3000$     |  有且仅有一个格子被破坏  |\n|        $8$       |      $3000$     |     $2500$     |  有且仅有一个格子被破坏  |\n|        $9$       |       $200$     |      $200$     |           无           |\n|   $10, 11, 12$   |       $500$     |      $500$     |           无           |\n|     $13, 14$     |      $1000$     |     $1000$     |           无           |\n|       $15$       |      $1000$     |     $1500$     |           无           |\n|       $16$       |      $2500$     |     $2500$     |           无           |\n|       $17$       |      $2500$     |     $3000$     |           无           |\n|       $18$       |      $3000$     |     $2500$     |           无           |\n|     $19, 20$     |      $3000$     |     $3000$     |           无           |", "locale": "zh-CN", "translations": {"en": {"title": "Hamster Nest", "background": "", "description": "The adorable \"Created equal\" is a little hamster, and of course a little hamster has a hamster nest.\n\nThe nest is an $n\\times m$ matrix with $n$ rows and $m$ columns. The little hamster wants to know how many submatrices this matrix has.\n\nFor example, for a $2\\times 3$ matrix, there are $6$ submatrices of size $1\\times 1$, $4$ of size $1\\times 2$, $2$ of size $1\\times 3$, $3$ of size $2\\times 1$, $2$ of size $2\\times 2$, and $1$ of size $2\\times 3$, so in total there are $6+4+2+3+2+1=18$ submatrices.\n\nHowever, some cells in the nest are damaged. Now the little hamster wants to know how many submatrices contain no damaged cells.", "inputFormat": "The first line contains two positive integers $n$ and $m$, denoting the number of rows $n$ and columns $m$ of the nest.\n\nThen follow $n$ lines, each containing $m$ numbers. Each number is either $0$ or $1$. A $0$ means the cell is damaged; otherwise the cell is intact.", "outputFormat": "Output a single integer: the number of submatrices that are undamaged.", "hint": "The time limit is $2\\text{s}$ and the memory limit is $256\\text{M}$. Since the new judge is close in speed to the NOIP judge, please be mindful of the impact of constant factors.\n\n|   Testdata index   |     $n$     |     $m$     |     Special property     |\n| :----------------: | :---------: | :---------: | :----------------------: |\n|       1, 2, 3      |      2      |      2      |           None           |\n|         4          |     10      |     10      |           None           |\n|        5, 6        |    2000     |    2000     |   All cells undamaged    |\n|         7          |    2500     |    3000     |   Exactly one cell broken |\n|         8          |    3000     |    2500     |   Exactly one cell broken |\n|         9          |     200     |     200     |           None           |\n|      10, 11, 12    |     500     |     500     |           None           |\n|        13, 14      |    1000     |    1000     |           None           |\n|         15         |    1000     |    1500     |           None           |\n|         16         |    2500     |    2500     |           None           |\n|         17         |    2500     |    3000     |           None           |\n|         18         |    3000     |    2500     |           None           |\n|        19, 20      |    3000     |    3000     |           None           |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "仓鼠窝", "background": "", "description": "萌萌哒的 Created equal 是一只小仓鼠，小仓鼠自然有仓鼠窝啦。\n\n仓鼠窝是一个由 $n\\times m$ 个格子组成的行数为 $n$、列数为 $m$ 的矩阵。小仓鼠现在想要知道，这个矩阵中有多少个子矩阵。\n\n比如说有一个 $2\\times 3$ 的矩阵，那么 $1\\times 1$ 的子矩阵有 $6$ 个，$1\\times 2$ 的子矩阵有 $4$ 个，$1\\times 3$ 的子矩阵有 $2$ 个，$2\\times 1$ 的子矩阵有 $3$ 个，$2\\times 2$ 的子矩阵有 $2$ 个，$2\\times 3$ 的子矩阵有 $1$ 个，所以子矩阵共有 $6+4+2+3+2+1=18$ 个。\n\n可是仓鼠窝中有的格子被破坏了。现在小仓鼠想要知道，有多少个内部不含被破坏的格子的子矩阵。\n", "inputFormat": "第一行两个正整数 $n$ 和 $m$，分别表示仓鼠窝的行数 $n$，列数 $m$。\n\n接下来 $n$ 行，每行 $m$ 个数，每个数代表对应的格子，非 $0$ 即 $1$。若为 $0$，表示这个格子被破坏；反之代表这个格子是完好无损的。", "outputFormat": "仅一个正整数，表示未被破坏的子矩阵的个数。\n", "hint": "本题时限 $2\\text{s}$，内存限制 $256\\text{M}$，因新评测机速度较为接近 NOIP 评测机速度，请注意常数问题带来的影响。\n\n|    数据编号     |     $n$       |     $m$      |        特殊性质        |\n| :------------: | :-----------: | :----------: | :--------------------: |\n|     $1, 2, 3$    |       $2$       |       $2$      |           无           |\n|        $4$       |      $10$       |      $10$      |           无           |\n|      $5, 6$      |      $2000$     |     $2000$     |   所有格子均未被破坏     |\n|        $7$       |      $2500$     |     $3000$     |  有且仅有一个格子被破坏  |\n|        $8$       |      $3000$     |     $2500$     |  有且仅有一个格子被破坏  |\n|        $9$       |       $200$     |      $200$     |           无           |\n|   $10, 11, 12$   |       $500$     |      $500$     |           无           |\n|     $13, 14$     |      $1000$     |     $1000$     |           无           |\n|       $15$       |      $1000$     |     $1500$     |           无           |\n|       $16$       |      $2500$     |     $2500$     |           无           |\n|       $17$       |      $2500$     |     $3000$     |           无           |\n|       $18$       |      $3000$     |     $2500$     |           无           |\n|     $19, 20$     |      $3000$     |     $3000$     |           无           |", "locale": "zh-CN"}}}
{"pid": "P3401", "type": "P", "difficulty": 6, "samples": [["5 3\n1 2 3\n2 3 3\n2 4 6\n4 5 1\n1 3 4\n2 2 4 7\n1 3 5", "14\n26\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "线段树", "洛谷原创", "树链剖分", "洛谷月赛"], "title": "洛谷树", "background": "萌哒的 Created_equal 小仓鼠种了一棵洛谷树！\n\n（题目背景是辣鸡小仓鼠乱写的 QAQ）。\n", "description": "树是一个无环、连通的无向图，由 $n$ 个点和 $n-1$ 条边构成。树上两个点之间的路径被定义为他们之间的唯一一条简单路径——显然这是一条最短路径。\n\n现在引入一个概念——子路径。假设树上两个点 $p_1$ 和 $p_n$ 之间的路径是 $P = \\langle p_1,p_2,p_3, \\ldots, p_n \\rangle $，那么它的子路径被定义为某一条路径 $P'$，满足 $P'= \\langle p_i,p_{i+1},p_{i+2},\\ldots,p_j \\rangle $，其中 $1\\le i \\le j \\le n$。显然，原路径是一条子路径，任意一个点也可以作为子路径。\n\n我们给每条边赋予一个边权。萌萌哒的 Sugar 问小仓鼠：对于任意两个点 $u$ 和 $v$，你能快速求出，$u$ 到 $v$ 的路径上所有子路径经过的边的边权的 $\\text{xor}$ 值的和是多少。具体地说就是，你把 $u$ 到 $v$ 的路径上所有子路径全部提出来，然后分别把每个子路径上经过的边的边权 $\\text{xor}$ 在一起，最后求出得到的所有 $\\text{xor}$ 值的和。\n\n什么？你不知道 $\\text{xor}$？那就去百度啊！\n\n这时候，fjzzq2002 大爷冒了粗来：窝还要你滋磁修改某条边边权的操作！\n\n小仓鼠那么辣鸡，当然不会做这道题啦。于是他就来向你求救！\n", "inputFormat": "第一行两个正整数 $n$ 和 $q$，表示点的个数，查询和询问的总次数。\n\n接下来 $n-1$ 行，每行两个正整数 $u,v$ 和一个非负整数 $w$，表示 $u$ 和 $v$ 两个点之间有一条边权为 $w$ 的边。\n\n接下来 $q$ 行，格式为 `1 u v` 或 `2 u v w`。   \n如果为 `1 u v` 操作，你需要输出 $u$ 到 $v$ 的路径上所有子路径经过的边的边权的 $\\text{xor}$ 值的和是多少。  \n如果为 `2 u v w` 操作，你需要把 $u$ 到 $v$ 这条边的边权改为 $w$，保证这条边存在。\n", "outputFormat": "对于每个 $1$ 操作，输出答案。\n", "hint": "|测试点编号|$n=$|$q=$|备注|\n|:-:|:-:|:-:|:-:|\n|$1$|$100$|$5$|无|\n|$2$|$100$|$20$|无|\n|$3$|$100$|$100$|无|\n|$4$|$5\\times 10^3$|$10^3$|无|\n|$5$|$5\\times 10^3$|$2\\times 10^3$|无|\n|$6$|$5\\times 10^3$|$3\\times 10^3$|无|\n|$7$|$10^4$|$10^4$|第 $i$ 条边连接第 $i$ 个点和第 $i+1$ 个点，且没有 $2$ 操作|\n|$8$|$10^4$|$2\\times 10^4$|第 $i$ 条边连接第 $i$ 个点和第 $i+1$ 个点，且没有 $2$ 操作|\n|$9$|$10^4$|$10^4$|第 $i$ 条边连接第 $i$ 个点和第 $i+1$ 个点|\n|$10$|$10^4$|$2\\times 10^4$|第 $i$ 条边连接第 $i$ 个点和第 $i+1$ 个点|\n|$11$|$10^4$|$10^4$|没有 $2$ 操作|\n|$12$|$10^4$|$2\\times 10^4$|没有 $2$ 操作|\n|$13$|$2\\times 10^4$|$2\\times 10^4$|没有 $2$ 操作|\n|$14$|$3\\times 10^4$|$3\\times 10^4$|没有 $2$ 操作|\n|$15$|$3\\times 10^4$|$10^4$|无|\n|$16$|$2\\times 10^4$|$2\\times 10^4$|无|\n|$17$|$2\\times 10^4$|$2\\times 10^4$|无|\n|$18$|$3\\times 10^4$|$2\\times 10^4$|无|\n|$19$|$2\\times 10^4$|$3\\times 10^4$|无|\n|$20$|$3\\times 10^4$|$3\\times 10^4$|无|\n\n对于 $100\\%$ 的数据，所有边权小于等于 $1023$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Luogu Tree", "background": "The cute Created_equal little hamster planted a Luogu tree.\n\n(This background was randomly written by the \"laji\" little hamster, QAQ).", "description": "A tree is an undirected, connected graph without cycles, consisting of $n$ vertices and $n-1$ edges. The path between two vertices in a tree is defined as the unique simple path between them; this is obviously a shortest path.\n\nNow we introduce the concept of a subpath. Suppose the path between two vertices $p_1$ and $p_n$ on the tree is $P = \\langle p_1,p_2,p_3, \\ldots, p_n \\rangle$. A subpath is any path $P'$ such that $P'= \\langle p_i,p_{i+1},p_{i+2},\\ldots,p_j \\rangle$, where $1\\le i \\le j \\le n$. Clearly, the original path itself is a subpath, and any single vertex can also be considered a subpath.\n\nWe assign a weight to every edge. The adorable Sugar asks the little hamster: for any two vertices $u$ and $v$, can you quickly find the sum of the $\\text{xor}$ values of edge weights over all subpaths along the path from $u$ to $v$. Specifically, take all subpaths on the path from $u$ to $v$, for each subpath compute the $\\text{xor}$ of the edge weights it traverses, and finally sum up all these $\\text{xor}$ values.\n\nWhat? You do not know $\\text{xor}$? Go Baidu it.\n\nAt this point, fjzzq2002 showed up: I also want you to support an operation that modifies the weight of an edge.\n\nThe little hamster is so \"laji\" that he certainly cannot solve this problem, so he turns to you for help.", "inputFormat": "The first line contains two positive integers $n$ and $q$, denoting the number of vertices and the total number of operations.\n\nEach of the next $n-1$ lines contains two positive integers $u,v$ and a non-negative integer $w$, indicating there is an edge of weight $w$ between vertices $u$ and $v$.\n\nEach of the next $q$ lines is in the format `1 u v` or `2 u v w`.  \nIf it is operation `1 u v`, you need to output the sum of the $\\text{xor}$ values of edge weights over all subpaths on the path from $u$ to $v$.  \nIf it is operation `2 u v w`, you need to change the weight of the edge between $u$ and $v$ to $w$, and it is guaranteed that this edge exists.", "outputFormat": "For each operation of type `1`, output the answer.", "hint": "|Test point id|$n=$|$q=$|Notes|\n|:-:|:-:|:-:|:-:|\n|$1$|$100$|$5$|None|\n|$2$|$100$|$20$|None|\n|$3$|$100$|$100$|None|\n|$4$|$5\\times 10^3$|$10^3$|None|\n|$5$|$5\\times 10^3$|$2\\times 10^3$|None|\n|$6$|$5\\times 10^3$|$3\\times 10^3$|None|\n|$7$|$10^4$|$10^4$|The $i$-th edge connects vertex $i$ and vertex $i+1$, and there is no $2$ operation.|\n|$8$|$10^4$|$2\\times 10^4$|The $i$-th edge connects vertex $i$ and vertex $i+1$, and there is no $2$ operation.|\n|$9$|$10^4$|$10^4$|The $i$-th edge connects vertex $i$ and vertex $i+1$.|\n|$10$|$10^4$|$2\\times 10^4$|The $i$-th edge connects vertex $i$ and vertex $i+1$.|\n|$11$|$10^4$|$10^4$|No $2$ operation.|\n|$12$|$10^4$|$2\\times 10^4$|No $2$ operation.|\n|$13$|$2\\times 10^4$|$2\\times 10^4$|No $2$ operation.|\n|$14$|$3\\times 10^4$|$3\\times 10^4$|No $2$ operation.|\n|$15$|$3\\times 10^4$|$10^4$|None|\n|$16$|$2\\times 10^4$|$2\\times 10^4$|None|\n|$17$|$2\\times 10^4$|$2\\times 10^4$|None|\n|$18$|$3\\times 10^4$|$2\\times 10^4$|None|\n|$19$|$2\\times 10^4$|$3\\times 10^4$|None|\n|$20$|$3\\times 10^4$|$3\\times 10^4$|None|\n\nFor $100\\%$ of the testdata, all edge weights are at most $1023$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "洛谷树", "background": "萌哒的 Created_equal 小仓鼠种了一棵洛谷树！\n\n（题目背景是辣鸡小仓鼠乱写的 QAQ）。\n", "description": "树是一个无环、连通的无向图，由 $n$ 个点和 $n-1$ 条边构成。树上两个点之间的路径被定义为他们之间的唯一一条简单路径——显然这是一条最短路径。\n\n现在引入一个概念——子路径。假设树上两个点 $p_1$ 和 $p_n$ 之间的路径是 $P = \\langle p_1,p_2,p_3, \\ldots, p_n \\rangle $，那么它的子路径被定义为某一条路径 $P'$，满足 $P'= \\langle p_i,p_{i+1},p_{i+2},\\ldots,p_j \\rangle $，其中 $1\\le i \\le j \\le n$。显然，原路径是一条子路径，任意一个点也可以作为子路径。\n\n我们给每条边赋予一个边权。萌萌哒的 Sugar 问小仓鼠：对于任意两个点 $u$ 和 $v$，你能快速求出，$u$ 到 $v$ 的路径上所有子路径经过的边的边权的 $\\text{xor}$ 值的和是多少。具体地说就是，你把 $u$ 到 $v$ 的路径上所有子路径全部提出来，然后分别把每个子路径上经过的边的边权 $\\text{xor}$ 在一起，最后求出得到的所有 $\\text{xor}$ 值的和。\n\n什么？你不知道 $\\text{xor}$？那就去百度啊！\n\n这时候，fjzzq2002 大爷冒了粗来：窝还要你滋磁修改某条边边权的操作！\n\n小仓鼠那么辣鸡，当然不会做这道题啦。于是他就来向你求救！\n", "inputFormat": "第一行两个正整数 $n$ 和 $q$，表示点的个数，查询和询问的总次数。\n\n接下来 $n-1$ 行，每行两个正整数 $u,v$ 和一个非负整数 $w$，表示 $u$ 和 $v$ 两个点之间有一条边权为 $w$ 的边。\n\n接下来 $q$ 行，格式为 `1 u v` 或 `2 u v w`。   \n如果为 `1 u v` 操作，你需要输出 $u$ 到 $v$ 的路径上所有子路径经过的边的边权的 $\\text{xor}$ 值的和是多少。  \n如果为 `2 u v w` 操作，你需要把 $u$ 到 $v$ 这条边的边权改为 $w$，保证这条边存在。\n", "outputFormat": "对于每个 $1$ 操作，输出答案。\n", "hint": "|测试点编号|$n=$|$q=$|备注|\n|:-:|:-:|:-:|:-:|\n|$1$|$100$|$5$|无|\n|$2$|$100$|$20$|无|\n|$3$|$100$|$100$|无|\n|$4$|$5\\times 10^3$|$10^3$|无|\n|$5$|$5\\times 10^3$|$2\\times 10^3$|无|\n|$6$|$5\\times 10^3$|$3\\times 10^3$|无|\n|$7$|$10^4$|$10^4$|第 $i$ 条边连接第 $i$ 个点和第 $i+1$ 个点，且没有 $2$ 操作|\n|$8$|$10^4$|$2\\times 10^4$|第 $i$ 条边连接第 $i$ 个点和第 $i+1$ 个点，且没有 $2$ 操作|\n|$9$|$10^4$|$10^4$|第 $i$ 条边连接第 $i$ 个点和第 $i+1$ 个点|\n|$10$|$10^4$|$2\\times 10^4$|第 $i$ 条边连接第 $i$ 个点和第 $i+1$ 个点|\n|$11$|$10^4$|$10^4$|没有 $2$ 操作|\n|$12$|$10^4$|$2\\times 10^4$|没有 $2$ 操作|\n|$13$|$2\\times 10^4$|$2\\times 10^4$|没有 $2$ 操作|\n|$14$|$3\\times 10^4$|$3\\times 10^4$|没有 $2$ 操作|\n|$15$|$3\\times 10^4$|$10^4$|无|\n|$16$|$2\\times 10^4$|$2\\times 10^4$|无|\n|$17$|$2\\times 10^4$|$2\\times 10^4$|无|\n|$18$|$3\\times 10^4$|$2\\times 10^4$|无|\n|$19$|$2\\times 10^4$|$3\\times 10^4$|无|\n|$20$|$3\\times 10^4$|$3\\times 10^4$|无|\n\n对于 $100\\%$ 的数据，所有边权小于等于 $1023$。\n", "locale": "zh-CN"}}}
{"pid": "P3402", "type": "P", "difficulty": 6, "samples": [["5 6\n1 1 2\n3 1 2\n2 0\n3 1 2\n2 1\n3 1 2", "1\n0\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["并查集", "可持久化", "模板题"], "title": "【模板】可持久化并查集", "background": null, "description": "给定 $n$ 个集合，第 $i$ 个集合内初始状态下只有一个数，为 $i$。\n\n有 $m$ 次操作。操作分为 $3$ 种：\n\n - `1 a b` 合并 $a,b$ 所在集合；\n\n - `2 k` 回到第 $k$ 次操作（执行三种操作中的任意一种都记为一次操作）之后的状态，保证已经进行过至少 $k$ 次操作（不算本次操作），特别的，若 $k=0$，则表示回到初始状态；\n\n - `3 a b` 询问 $a,b$ 是否属于同一集合，如果是则输出 $1$，否则输出 $0$。", "inputFormat": "第一行两个整数，$n,m$。\n\n接下来 $m$ 行，每行先输入一个数 $opt$。若 $opt=2$ 则再输入一个整数 $k$，否则再输入两个整数 $a,b$，描述一次操作。", "outputFormat": "对每个操作 $3$，输出一行一个整数表示答案。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^5$，$1\\le m\\le 2\\times 10^5$，$1 \\le a, b \\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Persistent DSU (Union-Find)", "background": "", "description": "Given $n$ sets, the $i$-th set initially contains only the element $i$.\n\nThere are $m$ operations, of three types:\n- `1 a b` Merge the sets containing $a$ and $b$;\n- `2 k` Revert to the state right after the $k$-th operation (any of the three types counts as one operation). It is guaranteed that at least $k$ operations have already been performed (not counting this one). In particular, if $k=0$, revert to the initial state;\n- `3 a b` Query whether $a$ and $b$ belong to the same set; if yes, output $1$, otherwise output $0$.", "inputFormat": "The first line contains two integers $n$ and $m$.\n\nThen follow $m$ lines. On each line, first read an integer $opt$. If $opt=2$ then read an integer $k$; otherwise read two integers $a, b$, describing one operation.", "outputFormat": "For each operation of type $3$, output one line with one integer indicating the answer.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $1 \\le m \\le 2 \\times 10^5$, $1 \\le a, b \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】可持久化并查集", "background": null, "description": "给定 $n$ 个集合，第 $i$ 个集合内初始状态下只有一个数，为 $i$。\n\n有 $m$ 次操作。操作分为 $3$ 种：\n\n - `1 a b` 合并 $a,b$ 所在集合；\n\n - `2 k` 回到第 $k$ 次操作（执行三种操作中的任意一种都记为一次操作）之后的状态，保证已经进行过至少 $k$ 次操作（不算本次操作），特别的，若 $k=0$，则表示回到初始状态；\n\n - `3 a b` 询问 $a,b$ 是否属于同一集合，如果是则输出 $1$，否则输出 $0$。", "inputFormat": "第一行两个整数，$n,m$。\n\n接下来 $m$ 行，每行先输入一个数 $opt$。若 $opt=2$ 则再输入一个整数 $k$，否则再输入两个整数 $a,b$，描述一次操作。", "outputFormat": "对每个操作 $3$，输出一行一个整数表示答案。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^5$，$1\\le m\\le 2\\times 10^5$，$1 \\le a, b \\le n$。", "locale": "zh-CN"}}}
{"pid": "P3403", "type": "P", "difficulty": 5, "samples": [["15\n4 7 9\n", "9\n"], ["33333333333\n99005 99002 100000\n", "33302114671\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "洛谷原创", "最短路", "洛谷比赛"], "title": "跳楼机", "background": "DJL 为了避免成为一只咸鱼，来找 srwudi 学习压代码的技巧。\n", "description": "Srwudi 的家是一幢 $h$ 层的摩天大楼。由于前来学习的蒟蒻越来越多，srwudi 改造了一个跳楼机，使得访客可以更方便的上楼。\n\n经过改造，srwudi 的跳楼机可以采用以下四种方式移动：\n\n1. 向上移动 $x$ 层；\n2. 向上移动 $y$ 层；\n3. 向上移动 $z$ 层；\n4. 回到第一层。\n\n一个月黑风高的大中午，DJL 来到了 srwudi 的家，现在他在 srwudi 家的第一层，碰巧跳楼机也在第一层。DJL 想知道，他可以乘坐跳楼机前往的楼层数。", "inputFormat": "第一行一个整数 $h$，表示摩天大楼的层数。\n\n第二行三个正整数，分别表示题目中的 $x, y, z$。", "outputFormat": "一行一个整数，表示 DJL 可以到达的楼层数。\n", "hint": "可以到达的楼层有：$1,5,8,9,10,12,13,14,15$。\n\n$1 \\le h \\le 2^{63}-1$，$1 \\le x,y,z \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Jump Elevator", "background": "To avoid becoming a \"salted fish\" (idle person), DJL went to srwudi to learn code golf techniques.", "description": "srwudi's home is a skyscraper with $h$ floors. Because more and more newbies are coming to learn, srwudi modified an elevator so that visitors can go upstairs more easily.\n\nAfter the modification, the elevator can move in the following four ways:\n1. Move up $x$ floors;\n2. Move up $y$ floors;\n3. Move up $z$ floors;\n4. Return to the first floor.\n\nOne day at noon, DJL arrived at srwudi's home. He is now on the first floor, and the elevator happens to be on the first floor as well. DJL wants to know how many floors he can reach by taking the elevator.", "inputFormat": "The first line contains an integer $h$, the number of floors of the skyscraper.\n\nThe second line contains three positive integers, which are $x, y, z$.", "outputFormat": "Output a single integer, the number of floors DJL can reach.", "hint": "Reachable floors include: $1,5,8,9,10,12,13,14,15$.\n\n$1 \\le h \\le 2^{63} - 1$, $1 \\le x, y, z \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "跳楼机", "background": "DJL 为了避免成为一只咸鱼，来找 srwudi 学习压代码的技巧。\n", "description": "Srwudi 的家是一幢 $h$ 层的摩天大楼。由于前来学习的蒟蒻越来越多，srwudi 改造了一个跳楼机，使得访客可以更方便的上楼。\n\n经过改造，srwudi 的跳楼机可以采用以下四种方式移动：\n\n1. 向上移动 $x$ 层；\n2. 向上移动 $y$ 层；\n3. 向上移动 $z$ 层；\n4. 回到第一层。\n\n一个月黑风高的大中午，DJL 来到了 srwudi 的家，现在他在 srwudi 家的第一层，碰巧跳楼机也在第一层。DJL 想知道，他可以乘坐跳楼机前往的楼层数。", "inputFormat": "第一行一个整数 $h$，表示摩天大楼的层数。\n\n第二行三个正整数，分别表示题目中的 $x, y, z$。", "outputFormat": "一行一个整数，表示 DJL 可以到达的楼层数。\n", "hint": "可以到达的楼层有：$1,5,8,9,10,12,13,14,15$。\n\n$1 \\le h \\le 2^{63}-1$，$1 \\le x,y,z \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3405", "type": "P", "difficulty": 2, "samples": [["6\nMIAMI FL\nDALLAS TX\nFLINT MI\nCLEMSON SC\nBOSTON MA\nORLANDO FL", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2016", "USACO"], "title": "[USACO16DEC] Cities and States S", "background": "", "description": "Farmer John 有若干头奶牛。为了训练奶牛们的智力，Farmer John 在谷仓的墙上放了一张美国地图。地图上表明了每个城市及其所在州的代码（前两位大写字母）。\n\n由于奶牛在谷仓里花了很多时间看这张地图，他们开始注意到一些奇怪的关系。例如，FLINT 的前两个字母就是 MIAMI 所在的 `FL` 州，MIAMI 的前两个字母则是 FLINT 所在的 `MI` 州。  \n确切地说，对于两个城市，它们的前两个字母互为对方所在州的名称。\n\n我们称两个城市是一个一对「特殊」的城市，如果他们具有上面的特性，并且来自不同的州。对于总共 $N$ 座城市，奶牛想知道有多少对「特殊」的城市存在。请帮助他们解决这个有趣的地理难题！  ", "inputFormat": "输入共 $N + 1$ 行。\n\n第一行一个正整数 $N$，表示地图上的城市的个数。  \n接下来 $N$ 行，每行两个字符串，分别表示一个城市的名称（$2 \\sim 10$ 个大写字母）和所在州的代码（$2$ 个大写字母）。同一个州内不会有两个同名的城市。", "outputFormat": "输出共一行一个整数，代表特殊的城市对数。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 2 \\times 10 ^ 5$，城市名称长度不超过 $10$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO16DEC] Cities and States S", "background": "", "description": "Farmer John has several cows. To train their intelligence, Farmer John put a map of the United States on the barn wall. The map shows each city and the code of the state it belongs to (2 uppercase letters).\n\nBecause the cows spend a lot of time looking at the map, they start to notice some strange relationships. For example, the first two letters of FLINT are the state of MIAMI, `FL`, and the first two letters of MIAMI are the state of FLINT, `MI`. Precisely, for two cities, the first two letters of each city's name are equal to the other city's state code.\n\nWe call two cities a \"special\" pair if they have the property above and they come from different states. Given $N$ total cities, the cows want to know how many \"special\" pairs exist. Please help them solve this interesting geography puzzle.", "inputFormat": "The input consists of $N + 1$ lines.\n\nThe first line contains a positive integer $N$, the number of cities on the map.  \nEach of the next $N$ lines contains two strings: a city name ($2$ to $10$ uppercase letters) and the code of its state ($2$ uppercase letters). Within the same state, there are no two cities with the same name.", "outputFormat": "Output a single line with one integer, the number of special city pairs.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le N \\le 2 \\times 10^5$, and the city name length is at most $10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO16DEC] Cities and States S", "background": "", "description": "Farmer John 有若干头奶牛。为了训练奶牛们的智力，Farmer John 在谷仓的墙上放了一张美国地图。地图上表明了每个城市及其所在州的代码（前两位大写字母）。\n\n由于奶牛在谷仓里花了很多时间看这张地图，他们开始注意到一些奇怪的关系。例如，FLINT 的前两个字母就是 MIAMI 所在的 `FL` 州，MIAMI 的前两个字母则是 FLINT 所在的 `MI` 州。  \n确切地说，对于两个城市，它们的前两个字母互为对方所在州的名称。\n\n我们称两个城市是一个一对「特殊」的城市，如果他们具有上面的特性，并且来自不同的州。对于总共 $N$ 座城市，奶牛想知道有多少对「特殊」的城市存在。请帮助他们解决这个有趣的地理难题！  ", "inputFormat": "输入共 $N + 1$ 行。\n\n第一行一个正整数 $N$，表示地图上的城市的个数。  \n接下来 $N$ 行，每行两个字符串，分别表示一个城市的名称（$2 \\sim 10$ 个大写字母）和所在州的代码（$2$ 个大写字母）。同一个州内不会有两个同名的城市。", "outputFormat": "输出共一行一个整数，代表特殊的城市对数。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\leq N \\leq 2 \\times 10 ^ 5$，城市名称长度不超过 $10$。", "locale": "zh-CN"}}}
{"pid": "P3406", "type": "P", "difficulty": 3, "samples": [["9 10\n3 1 4 1 5 9 2 6 5 3\n200 100 50\n300 299 100\n500 200 500\n345 234 123\n100 50 100\n600 100 1\n450 400 80\n2 1 10", "6394"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "洛谷原创", "前缀和", "差分", "洛谷月赛"], "title": "海底高铁", "background": "", "description": "该铁路经过 $N$ 个城市，每个城市都有一个站。不过，由于各个城市之间不能协调好，于是乘车每经过两个相邻的城市之间（方向不限），必须单独购买这一小段的车票。第 $i$ 段铁路连接了城市 $i$ 和城市 $i+1(1\\leq i<N)$。如果搭乘的比较远，需要购买多张车票。第 $i$ 段铁路购买纸质单程票需要 $A_i$ 博艾元。\n\n虽然一些事情没有协调好，各段铁路公司也为了方便乘客，推出了 IC 卡。对于第 $i$ 段铁路，需要花 $C_i$ 博艾元的工本费购买一张 IC 卡，然后乘坐这段铁路一次就只要扣 $B_i(B_i<A_i)$ 元。IC 卡可以提前购买，有钱就可以从网上买得到，而不需要亲自去对应的城市购买。工本费不能退，也不能购买车票。每张卡都可以充值任意数额。对于第 $i$ 段铁路的 IC 卡，无法乘坐别的铁路的车。\n\nUim 现在需要出差，要去 $M$ 个城市，从城市 $P_1$ 出发分别按照 $P_1,P_2,P_3,\\cdots,P_M$ 的顺序访问各个城市，可能会多次访问一个城市，且相邻访问的城市位置不一定相邻，而且不会是同一个城市。\n\n现在他希望知道，出差结束后，至少会花掉多少的钱，包括购买纸质车票、买卡和充值的总费用。", "inputFormat": "第一行两个整数，$N,M$。\n\n接下来一行，$M$ 个数字，表示 $P_i$。\n\n接下来 $N-1$ 行，表示第 $i$ 段铁路的 $A_i,B_i,C_i$。", "outputFormat": "一个整数，表示最少花费", "hint": "$2$ 到 $3$ 以及 $8$ 到 $9$ 买票，其余买卡。\n\n对于 $30\\%$ 数据 $M=2$。\n\n对于另外 $30\\%$ 数据 $N\\leq1000，M\\leq1000$。\n\n对于 $100\\%$ 的数据 $M,N\\leq 10^5，A_i,B_i,C_i\\le10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Undersea High-Speed Railway", "background": "", "description": "The railway passes through $N$ cities, each of which has a station. However, because the cities could not coordinate, each time you travel between two adjacent cities (in either direction), you must buy a separate ticket for that segment. Segment $i$ connects city $i$ and city $i+1$ ($1 \\leq i < N$). If you travel farther, you need to buy multiple tickets. A paper one-way ticket for segment $i$ costs $A_i$ Boai yuan.\n\nAlthough coordination fell short, the companies of each segment introduced IC cards for convenience. For segment $i$, you can pay a fee of $C_i$ Boai yuan to purchase an IC card, after which each ride on this segment only deducts $B_i$ ($B_i < A_i$) yuan. IC cards can be purchased online in advance; you do not need to buy them in the corresponding city. The card fee is non-refundable and cannot be used to buy tickets. Each card can be topped up with any amount. An IC card for segment $i$ cannot be used on other segments.\n\nUim needs to go on a business trip to visit $M$ cities, starting from city $P_1$ and visiting cities in the order $P_1, P_2, P_3, \\cdots, P_M$. A city may be visited multiple times; consecutive cities in the sequence are not necessarily adjacent on the line, and they are guaranteed to be different.\n\nNow he wants to know, after the trip ends, what is the minimum amount of money he will spend in total, including the cost of paper tickets, buying IC cards, and the rides paid with IC cards.", "inputFormat": "- The first line contains two integers, $N, M$.\n- The next line contains $M$ integers, representing $P_i$.\n- The next $N - 1$ lines describe the segments: for segment $i$, three integers $A_i, B_i, C_i$.", "outputFormat": "Output a single integer, the minimum total cost.", "hint": "- Buy paper tickets for $2$ to $3$ and $8$ to $9$, and buy IC cards for the others.\n\nConstraints:\n- For $30\\%$ of the testdata, $M = 2$.\n- For another $30\\%$ of the testdata, $N \\leq 1000$, $M \\leq 1000$.\n- For $100\\%$ of the testdata, $M, N \\leq 10^5$, $A_i, B_i, C_i \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "海底高铁", "background": "", "description": "该铁路经过 $N$ 个城市，每个城市都有一个站。不过，由于各个城市之间不能协调好，于是乘车每经过两个相邻的城市之间（方向不限），必须单独购买这一小段的车票。第 $i$ 段铁路连接了城市 $i$ 和城市 $i+1(1\\leq i<N)$。如果搭乘的比较远，需要购买多张车票。第 $i$ 段铁路购买纸质单程票需要 $A_i$ 博艾元。\n\n虽然一些事情没有协调好，各段铁路公司也为了方便乘客，推出了 IC 卡。对于第 $i$ 段铁路，需要花 $C_i$ 博艾元的工本费购买一张 IC 卡，然后乘坐这段铁路一次就只要扣 $B_i(B_i<A_i)$ 元。IC 卡可以提前购买，有钱就可以从网上买得到，而不需要亲自去对应的城市购买。工本费不能退，也不能购买车票。每张卡都可以充值任意数额。对于第 $i$ 段铁路的 IC 卡，无法乘坐别的铁路的车。\n\nUim 现在需要出差，要去 $M$ 个城市，从城市 $P_1$ 出发分别按照 $P_1,P_2,P_3,\\cdots,P_M$ 的顺序访问各个城市，可能会多次访问一个城市，且相邻访问的城市位置不一定相邻，而且不会是同一个城市。\n\n现在他希望知道，出差结束后，至少会花掉多少的钱，包括购买纸质车票、买卡和充值的总费用。", "inputFormat": "第一行两个整数，$N,M$。\n\n接下来一行，$M$ 个数字，表示 $P_i$。\n\n接下来 $N-1$ 行，表示第 $i$ 段铁路的 $A_i,B_i,C_i$。", "outputFormat": "一个整数，表示最少花费", "hint": "$2$ 到 $3$ 以及 $8$ 到 $9$ 买票，其余买卡。\n\n对于 $30\\%$ 数据 $M=2$。\n\n对于另外 $30\\%$ 数据 $N\\leq1000，M\\leq1000$。\n\n对于 $100\\%$ 的数据 $M,N\\leq 10^5，A_i,B_i,C_i\\le10^5$。", "locale": "zh-CN"}}}
{"pid": "P3407", "type": "P", "difficulty": 4, "samples": [["6 6 4\n-10 1\n-6 2\n-4 1\n2 1\n6 2\n18 2\n2\n3\n4\n6", "-8\n2\n4\n12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "洛谷原创", "枚举", "洛谷月赛"], "title": "散步", "background": "", "description": "一条道路上，位置点用整数 $A$ 表示。\n\n当 $A=0$ 时，有一个王宫。当 $A>0$，就是离王宫的东边有 $A$ 米，当 $A<0$，就是离王宫的西边有 $-A$ 米。\n\n道路上，有 $N$ 个住宅从西向东用 $1\\sim N$ 来标号。每个住宅有一个人。住宅只会存在于偶数整数点。\n\n该国国王认为，国民体质下降，必须要多运动，于是下命令所有人都必须出门散步。所有的国民，一秒钟可以走 $1$ 米。每个国民各自向东或者向西走。这些方向你是知道的。命令发出后所有人同时离开家门开始散步。\n\n然而该国的国民个都很健谈，如果在散步途中两个人相遇，就会停下来交谈。正在走路的人碰到已经停下来的人（重合）也会停下来交谈。一但停下来，就会聊到天昏地暗，忘记了散步。\n\n现在命令已经发出了 $T$ 秒，该国有 $Q$ 个重要人物，国王希望能够把握他们的位置。你能帮他解答吗？", "inputFormat": "第一行是 $3$ 个整数，$N,T,Q$\n\n接下来 $N$ 行，每行两个整数 $A_i,R_i$。$A_i$ 是家的坐标，如果 $R_i$ 是 $1$，那么会向东走，如果是 $2$，向西。数据保证 $A_i$ 是升序排序，而且不会有两个人初始位置重合。\n\n接下来 $Q$ 行，每行一个整数，表示国王关心的重要人物。\n", "outputFormat": "$Q$ 行，每行一个整数，表示这个人的坐标。\n", "hint": "$20\\%$ 数据，$N\\le 100,T\\le 10000$。\n\n另外 $20\\%$ 数据，$N\\le 5000$。\n\n另外 $20\\%$ 数据，从最西边数起连续的若干国民全部往东，剩下的全部往西。\n\n$100\\%$ 数据 $A_i$ 为偶数，$|A_i|\\le 10^{18},|T|\\le 10^{18},1\\le Q\\le N\\le 100000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Stroll", "background": "", "description": "On a road, positions are represented by integers $A$.\n\nWhen $A=0$, there is a royal palace. If $A>0$, it means $A$ meters to the east of the palace; if $A<0$, it means $-A$ meters to the west of the palace.\n\nAlong the road, there are $N$ houses labeled $1 \\sim N$ from west to east. Each house has exactly one person. Houses exist only at even integer points.\n\nThe king believes that the citizens’ fitness is declining and orders everyone to go out for a stroll. Every citizen can walk $1$ meter per second. Each citizen walks either east or west; these directions are known to you. All citizens start their stroll simultaneously when the order is issued.\n\nHowever, the citizens are very talkative. If two people meet during the stroll, they stop and talk. If a walking person reaches a point that coincides with someone who has already stopped, they will also stop and talk. Once they stop, they will chat endlessly and forget about the stroll.\n\nNow $T$ seconds have passed since the order was issued. There are $Q$ important persons of interest, and the king wants to know their positions. Can you help him?", "inputFormat": "The first line contains $3$ integers $N, T, Q$.\n\nThe next $N$ lines each contain two integers $A_i, R_i$. $A_i$ is the home coordinate. If $R_i$ is $1$, the person walks east; if it is $2$, the person walks west. It is guaranteed that the $A_i$ are in strictly increasing order and no two people share the same initial position.\n\nThe next $Q$ lines each contain one integer: the index of a person of interest (indexed $1$ to $N$ from west to east).", "outputFormat": "Output $Q$ lines. Each line contains one integer, the coordinate of that person.", "hint": "$20\\%$ of the testdata: $N \\le 100$, $T \\le 10000$.\n\nAnother $20\\%$ of the testdata: $N \\le 5000$.\n\nAnother $20\\%$ of the testdata: starting from the westernmost, some consecutive citizens all walk east, and the remaining citizens all walk west.\n\n$100\\%$ of the testdata: $A_i$ are even, $|A_i| \\le 10^{18}$, $|T| \\le 10^{18}$, $1 \\le Q \\le N \\le 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "散步", "background": "", "description": "一条道路上，位置点用整数 $A$ 表示。\n\n当 $A=0$ 时，有一个王宫。当 $A>0$，就是离王宫的东边有 $A$ 米，当 $A<0$，就是离王宫的西边有 $-A$ 米。\n\n道路上，有 $N$ 个住宅从西向东用 $1\\sim N$ 来标号。每个住宅有一个人。住宅只会存在于偶数整数点。\n\n该国国王认为，国民体质下降，必须要多运动，于是下命令所有人都必须出门散步。所有的国民，一秒钟可以走 $1$ 米。每个国民各自向东或者向西走。这些方向你是知道的。命令发出后所有人同时离开家门开始散步。\n\n然而该国的国民个都很健谈，如果在散步途中两个人相遇，就会停下来交谈。正在走路的人碰到已经停下来的人（重合）也会停下来交谈。一但停下来，就会聊到天昏地暗，忘记了散步。\n\n现在命令已经发出了 $T$ 秒，该国有 $Q$ 个重要人物，国王希望能够把握他们的位置。你能帮他解答吗？", "inputFormat": "第一行是 $3$ 个整数，$N,T,Q$\n\n接下来 $N$ 行，每行两个整数 $A_i,R_i$。$A_i$ 是家的坐标，如果 $R_i$ 是 $1$，那么会向东走，如果是 $2$，向西。数据保证 $A_i$ 是升序排序，而且不会有两个人初始位置重合。\n\n接下来 $Q$ 行，每行一个整数，表示国王关心的重要人物。\n", "outputFormat": "$Q$ 行，每行一个整数，表示这个人的坐标。\n", "hint": "$20\\%$ 数据，$N\\le 100,T\\le 10000$。\n\n另外 $20\\%$ 数据，$N\\le 5000$。\n\n另外 $20\\%$ 数据，从最西边数起连续的若干国民全部往东，剩下的全部往西。\n\n$100\\%$ 数据 $A_i$ 为偶数，$|A_i|\\le 10^{18},|T|\\le 10^{18},1\\le Q\\le N\\le 100000$。\n", "locale": "zh-CN"}}}
{"pid": "P3408", "type": "P", "difficulty": 4, "samples": [["14 5 3\n0 3\n0 3\n1 10\n1 10\n2 3\n2 10\n2 3\n5 10\n7 10\n5 10\n7 10\n5 10\n7 10\n5 10\n", "50\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "恋爱", "background": "", "description": "小 A 爱上了小 B！！！可是小 A 相对小 B 太弱，所以她当然不会同意小 A 的请求。小 A 苦苦追求，最终小 B 就提这样的条件：\n\n- 小 B 有 $n$ 个下属（不包括小 B）组成了树状结构，小 B 在顶端，其他人都有一个直属上司。  \n- 小 B 编号 $0$，其他人编号 $1 \\sim n$。  \n- 对于第 $i$ 人，如果这个人没有下属，那么小 A 可以给他 $A_i$ 元钱，则他会向他的直属上司写一封信，表示小 A 向小 B 求爱；  \n- 如果他的直属下属有占比不小于 $\\dfrac{A_i}{T}$ 的人写信表示小 A 向小 B 求爱，那么他也会向他的直属上司写一封信，表示小 A 向小 B 求爱。    \n- 如果小 B 的直属下属有占比不小于 $\\dfrac{C}{T}$ 的人写信表示小 A 向小 B 求爱，那么她会同意小 A 的请求。\n\n请问小 A 至少需要给多少钱才会让小 B 同意小 A 的求爱。", "inputFormat": "第一行三个整数 $n, T, C$。\n\n然后 $n$ 行，第 $i$ 行两个整数 $B_i, A_i$，$B_i$ 表示 $i$ 的直属上司，保证 $B_i < i$。", "outputFormat": "需要给的钱数。\n", "hint": "对于 $20 \\%$ 的数据，没有直属下属的人数 $\\le 15$。  \n对于 $40 \\%$ 的数据，$n \\le 2000$。  \n另有 $10 \\%$ 的数据，$B_i = 0$。\n另有 $10 \\%$ 的数据，$C = 1$ 且对于有直系下属的人 $T / A_i > n$。  \n另有 $10 \\%$ 的数据，$B_i = i - 1$。\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le 500000$，$1 \\le T \\le {10}^9$，$B_i < i$，$1 \\le A_i \\le T$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Love", "background": "", "description": "Xiao A fell in love with Xiao B!!! However, Xiao A is too weak compared to Xiao B, so she would certainly not agree to Xiao A’s request. After Xiao A’s persistent pursuit, Xiao B set the following conditions:\n\n- Xiao B has $n$ subordinates (excluding Xiao B) forming a tree structure. Xiao B is at the top, and everyone else has exactly one direct superior.\n- Xiao B is numbered $0$, and others are numbered $1 \\sim n$.\n- For the $i$-th person: if this person has no subordinates, then Xiao A can give them $A_i$ yuan, after which they will write a letter to their direct superior, stating that Xiao A is confessing to Xiao B.\n- If at least a proportion of $\\dfrac{A_i}{T}$ among their direct subordinates write letters stating that Xiao A is confessing to Xiao B, then they will also write a letter to their direct superior.\n- If at least a proportion of $\\dfrac{C}{T}$ among Xiao B’s direct subordinates write letters stating that Xiao A is confessing to Xiao B, then she will agree to Xiao A’s request.\n\nPlease determine the minimal total amount of money Xiao A needs to pay to make Xiao B accept Xiao A’s confession.", "inputFormat": "The first line contains three integers $n, T, C$.\n\nThen follow $n$ lines. The $i$-th line contains two integers $B_i, A_i$, where $B_i$ is the direct superior of $i$, and it is guaranteed that $B_i < i$.", "outputFormat": "Output the minimal total amount of money needed.", "hint": "- For $20\\%$ of the testdata, the number of people without direct subordinates $\\le 15$.\n- For $40\\%$ of the testdata, $n \\le 2000$.\n- Additionally, for $10\\%$ of the testdata, $B_i = 0$.\n- Additionally, for $10\\%$ of the testdata, $C = 1$ and for people with direct subordinates $T / A_i > n$.\n- Additionally, for $10\\%$ of the testdata, $B_i = i - 1$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 500000$, $1 \\le T \\le {10}^9$, $B_i < i$, $1 \\le A_i \\le T$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "恋爱", "background": "", "description": "小 A 爱上了小 B！！！可是小 A 相对小 B 太弱，所以她当然不会同意小 A 的请求。小 A 苦苦追求，最终小 B 就提这样的条件：\n\n- 小 B 有 $n$ 个下属（不包括小 B）组成了树状结构，小 B 在顶端，其他人都有一个直属上司。  \n- 小 B 编号 $0$，其他人编号 $1 \\sim n$。  \n- 对于第 $i$ 人，如果这个人没有下属，那么小 A 可以给他 $A_i$ 元钱，则他会向他的直属上司写一封信，表示小 A 向小 B 求爱；  \n- 如果他的直属下属有占比不小于 $\\dfrac{A_i}{T}$ 的人写信表示小 A 向小 B 求爱，那么他也会向他的直属上司写一封信，表示小 A 向小 B 求爱。    \n- 如果小 B 的直属下属有占比不小于 $\\dfrac{C}{T}$ 的人写信表示小 A 向小 B 求爱，那么她会同意小 A 的请求。\n\n请问小 A 至少需要给多少钱才会让小 B 同意小 A 的求爱。", "inputFormat": "第一行三个整数 $n, T, C$。\n\n然后 $n$ 行，第 $i$ 行两个整数 $B_i, A_i$，$B_i$ 表示 $i$ 的直属上司，保证 $B_i < i$。", "outputFormat": "需要给的钱数。\n", "hint": "对于 $20 \\%$ 的数据，没有直属下属的人数 $\\le 15$。  \n对于 $40 \\%$ 的数据，$n \\le 2000$。  \n另有 $10 \\%$ 的数据，$B_i = 0$。\n另有 $10 \\%$ 的数据，$C = 1$ 且对于有直系下属的人 $T / A_i > n$。  \n另有 $10 \\%$ 的数据，$B_i = i - 1$。\n\n对于 $100 \\%$ 的数据，$1 \\le n \\le 500000$，$1 \\le T \\le {10}^9$，$B_i < i$，$1 \\le A_i \\le T$。\n", "locale": "zh-CN"}}}
{"pid": "P3409", "type": "P", "difficulty": 5, "samples": [["20 7 3 3\n30 7 4 3", "27\nOrz mgh!!!"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "扩展欧几里德算法"], "title": "值日班长值周班长", "background": null, "description": "话说，在一个学期共有 $n$ 个值日班长，其中 A 是第 $m$ 个值日班长，共有 $p$ 个值周班长，B 是第 $q$ 个值周班长。假设不考虑假期及其他额外上课休假，以及重排值日班长值周班长，即永远每周上 $5$ 天休息 $2$ 天，且这个学期永远不会结束。请问这学期第几天会第一次遇上 $A$ 是值日班长且 $B$ 是值周班长，若永远不会输出 `Orz mgh!!!`。", "inputFormat": "有多组测试数据。每组数据占 $1$ 行四个数 $n,m,p,q$。保证 $m\\le n$，$q\\le p$。", "outputFormat": "每组数据输出 $1$ 行表示结果。", "hint": "|测试点编号|数据组数|$n$|$p$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|1|$\\le10^4$|$\\le100$|$\\le100$|有|\n|2|$\\le100$|$\\le1000$|$\\le1000$|无|\n|3|$\\le1000$|$\\le10^4$|$\\le10^4$|无|\n|4|$\\le1000$|$\\le10^5$|$\\le10^5$|有|\n|5|$\\le1000$|$\\le10^5$|$\\le10^5$|无|\n|6|$\\le1000$|$\\le10^6$|$\\le10^6$|无|\n|7|$\\le1000$|$\\le10^7$|$\\le10^7$|无|\n|8|$\\le10^4$|$\\le10^7$|$\\le10^7$|有|\n|9|$\\le1000$|$\\le10^9$|$\\le10^9$|有|\n|10|$\\le1000$|$\\le10^9$|$\\le10^9$|无|\n\n特殊性质：$n$ 是 $5$ 的倍数。\n\n对于 $100\\%$ 的测试数据，$1\\le m\\le n\\le 10^9$，$1\\le q\\le p\\le 10^9$，测试数据不超过 $10^4$ 组。**注意测试数据组数的最大值与 $\\bold{n,p}$ 的最大值不会同时取到。**", "locale": "zh-CN", "translations": {"en": {"title": "Daily Duty Monitor and Weekly Duty Monitor", "background": "", "description": "In a semester, there are $n$ daily duty monitors (值日班长), where A is the $m$-th daily duty monitor, and there are $p$ weekly duty monitors (值周班长), where B is the $q$-th weekly duty monitor. Assume we ignore holidays and any other schedule changes, and the daily/weekly duty rotations are never rearranged; that is, every week always has $5$ school days and $2$ rest days, and this semester never ends. On which day of the semester will it first happen that A is the daily duty monitor and B is the weekly duty monitor at the same time? If it never happens, output `Orz mgh!!!`.", "inputFormat": "Multiple test cases. Each test case consists of one line with four integers $n, m, p, q$. It is guaranteed that $m \\le n$ and $q \\le p$.", "outputFormat": "For each test case, output one line with the result.", "hint": "| Test point ID | Number of test cases | $n$ | $p$ | Special property |\n|:-:|:-:|:-:|:-:|:-:|\n| 1 | $\\le 10^4$ | $\\le 100$ | $\\le 100$ | Yes |\n| 2 | $\\le 100$ | $\\le 1000$ | $\\le 1000$ | No |\n| 3 | $\\le 1000$ | $\\le 10^4$ | $\\le 10^4$ | No |\n| 4 | $\\le 1000$ | $\\le 10^5$ | $\\le 10^5$ | Yes |\n| 5 | $\\le 1000$ | $\\le 10^5$ | $\\le 10^5$ | No |\n| 6 | $\\le 1000$ | $\\le 10^6$ | $\\le 10^6$ | No |\n| 7 | $\\le 1000$ | $\\le 10^7$ | $\\le 10^7$ | No |\n| 8 | $\\le 10^4$ | $\\le 10^7$ | $\\le 10^7$ | Yes |\n| 9 | $\\le 1000$ | $\\le 10^9$ | $\\le 10^9$ | Yes |\n| 10 | $\\le 1000$ | $\\le 10^9$ | $\\le 10^9$ | No |\n\nSpecial property: $n$ is a multiple of $5$.\n\nFor $100\\%$ of the testdata, $1 \\le m \\le n \\le 10^9$, $1 \\le q \\le p \\le 10^9$, and the number of test cases does not exceed $10^4$. Note that the maximum number of test cases and the maximum values of $n$ and $p$ will not be reached at the same time.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "值日班长值周班长", "background": null, "description": "话说，在一个学期共有 $n$ 个值日班长，其中 A 是第 $m$ 个值日班长，共有 $p$ 个值周班长，B 是第 $q$ 个值周班长。假设不考虑假期及其他额外上课休假，以及重排值日班长值周班长，即永远每周上 $5$ 天休息 $2$ 天，且这个学期永远不会结束。请问这学期第几天会第一次遇上 $A$ 是值日班长且 $B$ 是值周班长，若永远不会输出 `Orz mgh!!!`。", "inputFormat": "有多组测试数据。每组数据占 $1$ 行四个数 $n,m,p,q$。保证 $m\\le n$，$q\\le p$。", "outputFormat": "每组数据输出 $1$ 行表示结果。", "hint": "|测试点编号|数据组数|$n$|$p$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|1|$\\le10^4$|$\\le100$|$\\le100$|有|\n|2|$\\le100$|$\\le1000$|$\\le1000$|无|\n|3|$\\le1000$|$\\le10^4$|$\\le10^4$|无|\n|4|$\\le1000$|$\\le10^5$|$\\le10^5$|有|\n|5|$\\le1000$|$\\le10^5$|$\\le10^5$|无|\n|6|$\\le1000$|$\\le10^6$|$\\le10^6$|无|\n|7|$\\le1000$|$\\le10^7$|$\\le10^7$|无|\n|8|$\\le10^4$|$\\le10^7$|$\\le10^7$|有|\n|9|$\\le1000$|$\\le10^9$|$\\le10^9$|有|\n|10|$\\le1000$|$\\le10^9$|$\\le10^9$|无|\n\n特殊性质：$n$ 是 $5$ 的倍数。\n\n对于 $100\\%$ 的测试数据，$1\\le m\\le n\\le 10^9$，$1\\le q\\le p\\le 10^9$，测试数据不超过 $10^4$ 组。**注意测试数据组数的最大值与 $\\bold{n,p}$ 的最大值不会同时取到。**", "locale": "zh-CN"}}}
{"pid": "P3410", "type": "P", "difficulty": 6, "samples": [["2 3\n10 1 2 0\n25 2 3 0\n5 6 7", "17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流"], "title": "拍照", "background": "", "description": "小 B 有 $N$ 个下属，现小 B 要带着一些下属让别人拍照。\n\n有 $M$ 个人，每个人都愿意付给小 B 一定钱来和 $N$ 个下属中的一些人进行合影。如果这一些下属没带齐那么就不能拍照，小 B 也不会得到钱。\n\n注意：带下属不是白带的！！！对于每个下属，如果他带了那么小 B 需要给他一些钱，保证当他拍照时配合。", "inputFormat": "第 $1$ 行有 $2$ 个正整数 $M$ 和 $N\\ (1\\leq M, N\\le 100)$。接下来的 $M$ 行，每行是一个要求拍照的人的有关数据。第一个数是他同意支付该合影的费用；接着是该合影需要的若干下属的编号，以一个 $0$ 作为行的结束标记。最后一行的 $N$ 个数是带每个下属的费用。", "outputFormat": "一个数，表示最大收益。小 B 可以一个人也不带。\n", "hint": "对于 $10\\%$ 的数据每个人都要求让全部 $N$ 个人合影。\n\n对于 $30\\%$ 的数据 $N, M\\le 15$。\n\n另有 $10\\%$ 的数据答案为 $0$。\n\n对于 $50\\%$ 的数据 $N, M\\le 40$。\n\n另有 $10\\%$ 的数据每个人只愿意拍一个人。\n\n对于 $100\\%$ 的数据 $1\\leq N, M\\le100$，费用是 $[1, 5\\times 10^8]$ 间的整数。", "locale": "zh-CN", "translations": {"en": {"title": "Taking Photos", "background": "", "description": "Xiao B has $N$ subordinates. Now Xiao B plans to bring some subordinates to have photos taken.\n\nThere are $M$ people; each person is willing to pay Xiao B some money to take a photo with some of the $N$ subordinates. If that set of subordinates is not fully brought, the photo cannot be taken, and Xiao B will not receive the payment.\n\nNote: Bringing subordinates is not free! For each subordinate who is brought, Xiao B needs to pay a fee to ensure cooperation during the photo.", "inputFormat": "The first line contains $2$ positive integers $M$ and $N\\ (1\\leq M, N\\le 100)$. The next $M$ lines each describe one requester’s data. The first number is the fee he agrees to pay for that photo; then follow the IDs of the required subordinates, terminated by a $0$ as the end marker for the line. The last line contains $N$ numbers, the cost to bring each subordinate.", "outputFormat": "A single number, the maximum profit. Xiao B may choose to bring nobody.", "hint": "For $10\\%$ of the testdata, each person requires all $N$ subordinates.\n\nFor $30\\%$ of the testdata, $N, M\\le 15$.\n\nFor another $10\\%$ of the testdata, the answer is $0$.\n\nFor $50\\%$ of the testdata, $N, M\\le 40$.\n\nFor another $10\\%$ of the testdata, each person requires exactly one subordinate.\n\nFor $100\\%$ of the testdata, $1\\leq N, M\\le100$, and fees are integers in $[1, 5\\times 10^8]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "拍照", "background": "", "description": "小 B 有 $N$ 个下属，现小 B 要带着一些下属让别人拍照。\n\n有 $M$ 个人，每个人都愿意付给小 B 一定钱来和 $N$ 个下属中的一些人进行合影。如果这一些下属没带齐那么就不能拍照，小 B 也不会得到钱。\n\n注意：带下属不是白带的！！！对于每个下属，如果他带了那么小 B 需要给他一些钱，保证当他拍照时配合。", "inputFormat": "第 $1$ 行有 $2$ 个正整数 $M$ 和 $N\\ (1\\leq M, N\\le 100)$。接下来的 $M$ 行，每行是一个要求拍照的人的有关数据。第一个数是他同意支付该合影的费用；接着是该合影需要的若干下属的编号，以一个 $0$ 作为行的结束标记。最后一行的 $N$ 个数是带每个下属的费用。", "outputFormat": "一个数，表示最大收益。小 B 可以一个人也不带。\n", "hint": "对于 $10\\%$ 的数据每个人都要求让全部 $N$ 个人合影。\n\n对于 $30\\%$ 的数据 $N, M\\le 15$。\n\n另有 $10\\%$ 的数据答案为 $0$。\n\n对于 $50\\%$ 的数据 $N, M\\le 40$。\n\n另有 $10\\%$ 的数据每个人只愿意拍一个人。\n\n对于 $100\\%$ 的数据 $1\\leq N, M\\le100$，费用是 $[1, 5\\times 10^8]$ 间的整数。", "locale": "zh-CN"}}}
{"pid": "P3411", "type": "P", "difficulty": 5, "samples": [["5\n6 3 7 8 6\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "单调队列"], "title": "序列变换", "background": "", "description": "给定一个长度为 $n$ 的数列 $A_i$。\n\n你可以对数列进行若干次操作，每次操作可以从数列中任选一个数，把它移动到数列的开头或者结尾。\n\n求最少经过多少次操作，可以把数列变成单调不减的。“单调不减”意味着数列中的任意一个数都不大于排在它后边的数。\n", "inputFormat": "第一行是一个正整数 $n$。\n\n第二行是 $n$ 个正整数 $A_i$。\n", "outputFormat": "输出一个整数，表示最少需要的操作次数。\n", "hint": "对于 $30 \\%$ 的数据，满足 $1 \\le n \\le 10$。\n\n对于 $60 \\%$ 的数据，满足 $1 \\le n \\le 1000$。\n\n对于 $100 \\%$ 的数据，满足 $1 \\le n \\le {10}^6$，$1 \\le A_i \\le {10}^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Sequence Transformation", "background": "", "description": "Given a sequence $A_i$ of length $n$.\n\nYou may perform several operations. In each operation, you can choose any number in the sequence and move it to the beginning or to the end of the sequence.\n\nFind the minimum number of operations needed to make the sequence non-decreasing. \"Non-decreasing\" means that every number in the sequence is not greater than the number that follows it.", "inputFormat": "The first line contains a positive integer $n$.\n\nThe second line contains $n$ positive integers $A_i$.", "outputFormat": "Output a single integer, representing the minimum number of operations required.", "hint": "For $30 \\%$ of the testdata, $1 \\le n \\le 10$.\n\nFor $60 \\%$ of the testdata, $1 \\le n \\le 1000$.\n\nFor $100 \\%$ of the testdata, $1 \\le n \\le {10}^6$, $1 \\le A_i \\le {10}^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "序列变换", "background": "", "description": "给定一个长度为 $n$ 的数列 $A_i$。\n\n你可以对数列进行若干次操作，每次操作可以从数列中任选一个数，把它移动到数列的开头或者结尾。\n\n求最少经过多少次操作，可以把数列变成单调不减的。“单调不减”意味着数列中的任意一个数都不大于排在它后边的数。\n", "inputFormat": "第一行是一个正整数 $n$。\n\n第二行是 $n$ 个正整数 $A_i$。\n", "outputFormat": "输出一个整数，表示最少需要的操作次数。\n", "hint": "对于 $30 \\%$ 的数据，满足 $1 \\le n \\le 10$。\n\n对于 $60 \\%$ 的数据，满足 $1 \\le n \\le 1000$。\n\n对于 $100 \\%$ 的数据，满足 $1 \\le n \\le {10}^6$，$1 \\le A_i \\le {10}^6$。\n", "locale": "zh-CN"}}}
{"pid": "P3412", "type": "P", "difficulty": 6, "samples": [["3\n1 2\n1 3\n", "110916041"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "洛谷原创", "概率论", "期望", "洛谷月赛"], "title": "仓鼠找sugar II", "background": "", "description": "小仓鼠和他的基（mei）友（zi）sugar 住在地下洞穴中，每个节点的编号为 $1\\sim n$ 间的一个整数。地下洞穴是一个树形结构（两个洞穴间距离为 $1$）。这一天小仓鼠打算从从他的卧室 $a$（**是任意的**）走到他的基友卧室 $b$（还**是任意的**）（注意，$a$ 有可能等于 $b$）。然而小仓鼠学 OI 学傻了，不知道怎么怎么样才能用最短的路程走到目的地，于是他只能随便乱走。当他在一个节点时，会等概率走到这个点的母亲或者所有孩子节点（例如这个节点有一个母亲节点和两个子节点，那么下一步走到这 $3$ 个节点的概率都是 $\\dfrac{1}{3}$），一旦走到了他基友的卧室，就会停下。\n\n现在小仓鼠希望知道，他走到目的地时，走的步数的期望。这个期望本来是一个有理数，但是为了避免误差，我们要求输出这个有理数对 $998,244,353$ 取模的结果。\n\n形式化地说，可以证明答案可以被表示为既约分数 $\\dfrac{y}{x}$，其中 $x\\not\\equiv 0\\pmod {998,244,353}$。可以证明存在一个唯一的整数 $z$（$0\\le z\\lt 998,244,353$），使得 $xz=y$，你只需要输出 $z$ 的值。\n\n\n小仓鼠那么弱，还要天天被 JOHNKRAM 大爷虐，请你快来救救他吧！", "inputFormat": "第一行一个正整数 $n$，表示这棵树节点的个数。\n\n接下来 $n-1$ 行，每行两个正整数 $u$ 和 $v$，表示节点 $u$ 到节点 $v$ 之间有一条边。", "outputFormat": "一个整数，表示取模后的答案。", "hint": "样例解释：期望的真实值为 $\\dfrac {16}{9}$。\n\n如果 $a$ 是叶子，$b$ 是根，此时期望 $\\mathbb{E}_1=1$，有 $2$ 种情况。\n\n如果 $a$ 是根，$b$ 是叶子，则 $\\displaystyle \\mathbb{E}_2=\\frac{1}{2}+\\frac{3}{4}+\\frac{5}{8}+\\cdots=3$。有 $2$ 种情况。\n\n如果 $a,b$ 是不同的叶子，则 $\\mathbb{E}_3=\\mathbb{E}_2+1=4$。有 $2$ 种情况。\n\n如果 $a=b$，则 $\\mathbb{E}_4=0$。有 $3$ 种情况。\n\n所以答案为 $\\displaystyle \\frac{2\\times 1+2\\times 3+2\\times 4+3\\times 0}{2+2+2+3}=\\frac{16}{9}$。\n\n由于 $110,916,041\\times 9=998,244,369\\equiv 16\\pmod {998,244,353}$，所以输出 $110,916,041$。\n\n对于 $30\\%$ 的数据，$n\\le 5$；\n\n对于 $50\\%$ 的数据，$n\\le 5000$；\n\n对于所有数据，$n\\le 100000$。\n\n$\\text{Statement fixed by @Starrykiller.}$", "locale": "zh-CN", "translations": {"en": {"title": "Hamster Seeks sugar II", "background": "", "description": "The little hamster and his buddy sugar live in an underground cave system. Each node is an integer between $1 \\sim n$. The cave system is a tree (each edge has length $1$). On this day the hamster plans to go from his bedroom $a$ (arbitrary) to his buddy’s bedroom $b$ (also arbitrary) (note that $a$ may be equal to $b$). However, after studying OI too hard, he has gone silly and does not know how to take the shortest path, so he just walks randomly. When he is at a node, he moves with equal probability to its parent or any of its children (for example, if this node has one parent and two children, then the probability of moving to each of these $3$ neighbors is $\\dfrac{1}{3}$). Once he reaches $b$, he stops.\n\nNow the little hamster wants to know the expected number of steps when he reaches the destination. This expectation is a rational number. To avoid precision errors, we ask you to output this rational number modulo $998,244,353$.\n\nFormally, it can be shown that the answer can be written as an irreducible fraction $\\dfrac{y}{x}$, where $x \\not\\equiv 0 \\pmod{998,244,353}$. It can be shown that there exists a unique integer $z$ ($0 \\le z \\lt 998,244,353$) such that $x z \\equiv y \\pmod{998,244,353}$; you only need to output the value of $z$.\n\nThe little hamster is so weak and always gets beaten by JOHNKRAM. Please help him!", "inputFormat": "The first line contains a positive integer $n$, the number of nodes in the tree.\n\nThe next $n-1$ lines each contain two positive integers $u$ and $v$, indicating that there is an edge between nodes $u$ and $v$.", "outputFormat": "Output a single integer, the answer modulo $998,244,353$.", "hint": "Sample explanation: the true expected value is $\\dfrac {16}{9}$.\n\nIf $a$ is a leaf and $b$ is the root, then the expectation is $\\mathbb{E}_1=1$. There are $2$ cases.\n\nIf $a$ is the root and $b$ is a leaf, then $\\displaystyle \\mathbb{E}_2=\\frac{1}{2}+\\frac{3}{4}+\\frac{5}{8}+\\cdots=3$. There are $2$ cases.\n\nIf $a,b$ are different leaves, then $\\mathbb{E}_3=\\mathbb{E}_2+1=4$. There are $2$ cases.\n\nIf $a=b$, then $\\mathbb{E}_4=0$. There are $3$ cases.\n\nSo the answer is $\\displaystyle \\frac{2\\times 1+2\\times 3+2\\times 4+3\\times 0}{2+2+2+3}=\\frac{16}{9}$.\n\nSince $110,916,041\\times 9=998,244,369\\equiv 16\\pmod {998,244,353}$, output $110,916,041$.\n\nFor $30\\%$ of the testdata, $n\\le 5$.\n\nFor $50\\%$ of the testdata, $n\\le 5,000$.\n\nFor all testdata, $n\\le 100,000$.\n\n$\\text{Statement fixed by @Starrykiller.}$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "仓鼠找sugar II", "background": "", "description": "小仓鼠和他的基（mei）友（zi）sugar 住在地下洞穴中，每个节点的编号为 $1\\sim n$ 间的一个整数。地下洞穴是一个树形结构（两个洞穴间距离为 $1$）。这一天小仓鼠打算从从他的卧室 $a$（**是任意的**）走到他的基友卧室 $b$（还**是任意的**）（注意，$a$ 有可能等于 $b$）。然而小仓鼠学 OI 学傻了，不知道怎么怎么样才能用最短的路程走到目的地，于是他只能随便乱走。当他在一个节点时，会等概率走到这个点的母亲或者所有孩子节点（例如这个节点有一个母亲节点和两个子节点，那么下一步走到这 $3$ 个节点的概率都是 $\\dfrac{1}{3}$），一旦走到了他基友的卧室，就会停下。\n\n现在小仓鼠希望知道，他走到目的地时，走的步数的期望。这个期望本来是一个有理数，但是为了避免误差，我们要求输出这个有理数对 $998,244,353$ 取模的结果。\n\n形式化地说，可以证明答案可以被表示为既约分数 $\\dfrac{y}{x}$，其中 $x\\not\\equiv 0\\pmod {998,244,353}$。可以证明存在一个唯一的整数 $z$（$0\\le z\\lt 998,244,353$），使得 $xz=y$，你只需要输出 $z$ 的值。\n\n\n小仓鼠那么弱，还要天天被 JOHNKRAM 大爷虐，请你快来救救他吧！", "inputFormat": "第一行一个正整数 $n$，表示这棵树节点的个数。\n\n接下来 $n-1$ 行，每行两个正整数 $u$ 和 $v$，表示节点 $u$ 到节点 $v$ 之间有一条边。", "outputFormat": "一个整数，表示取模后的答案。", "hint": "样例解释：期望的真实值为 $\\dfrac {16}{9}$。\n\n如果 $a$ 是叶子，$b$ 是根，此时期望 $\\mathbb{E}_1=1$，有 $2$ 种情况。\n\n如果 $a$ 是根，$b$ 是叶子，则 $\\displaystyle \\mathbb{E}_2=\\frac{1}{2}+\\frac{3}{4}+\\frac{5}{8}+\\cdots=3$。有 $2$ 种情况。\n\n如果 $a,b$ 是不同的叶子，则 $\\mathbb{E}_3=\\mathbb{E}_2+1=4$。有 $2$ 种情况。\n\n如果 $a=b$，则 $\\mathbb{E}_4=0$。有 $3$ 种情况。\n\n所以答案为 $\\displaystyle \\frac{2\\times 1+2\\times 3+2\\times 4+3\\times 0}{2+2+2+3}=\\frac{16}{9}$。\n\n由于 $110,916,041\\times 9=998,244,369\\equiv 16\\pmod {998,244,353}$，所以输出 $110,916,041$。\n\n对于 $30\\%$ 的数据，$n\\le 5$；\n\n对于 $50\\%$ 的数据，$n\\le 5000$；\n\n对于所有数据，$n\\le 100000$。\n\n$\\text{Statement fixed by @Starrykiller.}$", "locale": "zh-CN"}}}
{"pid": "P3413", "type": "P", "difficulty": 6, "samples": [["1 100", "10"], ["100 1000", "253"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2016", "洛谷原创", "数位 DP", "洛谷月赛"], "title": "SAC#1 - 萌数", "background": "本题由世界上最蒟蒻的 SOL 提供。\n\n寂月城网站是完美信息教室的官网。地址：<http://191.101.11.174/mgzd>。\n", "description": "蒟蒻 SOL 居然觉得数很萌！\n\n好在在他眼里，并不是所有数都是萌的。只有满足“存在长度至少为 $2$ 的回文子串”的数是萌的——也就是说，$101$ 是萌的，因为 $101$ 本身就是一个回文数；$110$ 是萌的，因为包含回文子串 $11$；但是 $102$ 不是萌的，$1201$ 也不是萌的。\n\n现在 SOL 想知道从 $l$ 到 $r$ 的所有整数中有多少个萌数。\n\n由于答案可能很大，所以只需要输出答案对 $1000000007$（$10^9+7$）的余数。", "inputFormat": "输入包含仅 $1$ 行，包含两个整数：$l$，$r$。", "outputFormat": "输出仅 $1$ 行，包含一个整数，即为答案。\n", "hint": "记 $n$ 为 $r$ 在 $10$ 进制下的位数。\n\n对于 $10\\%$ 的数据，$n \\le 3$。\n\n对于 $30\\%$ 的数据，$n \\le 6$。\n\n对于 $60\\%$ 的数据，$n \\le 9$。\n\n对于全部的数据，$n \\le 1000$，$l < r$。\n\n\n------------\n\n2024/2/4 添加一组 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "SAC#1 - Cute Numbers", "background": "This problem is provided by SOL, the world's most \"juruo\" (noob).\nThe Jiyue City website is the official site of the Perfect Information Classroom. Address: <http://191.101.11.174/mgzd>.", "description": "The newbie SOL thinks numbers are cute!\n\nFortunately, not all numbers are cute in his eyes. A number is cute if and only if there exists a palindromic substring of length at least $2$—that is, 101 is cute because 101 itself is a palindrome; 110 is cute because it contains the palindromic substring 11; but 102 is not cute, and 1201 is not cute.\n\nNow SOL wants to know how many cute numbers there are among all integers from $l$ to $r$.\n\nSince the answer may be large, output the answer modulo $1000000007$ ($10^9+7$).", "inputFormat": "The input contains a single line with two integers: $l$ and $r$.", "outputFormat": "Output a single line containing one integer, the answer.", "hint": "Let $n$ be the number of digits of $r$ in base $10$.\n\nFor $10\\%$ of the testdata, $n \\le 3$.\nFor $30\\%$ of the testdata, $n \\le 6$.\nFor $60\\%$ of the testdata, $n \\le 9$.\nFor all the testdata, $n \\le 1000$, $l < r$.\n\n2024/2/4: One set of hack testdata was added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "SAC#1 - 萌数", "background": "本题由世界上最蒟蒻的 SOL 提供。\n\n寂月城网站是完美信息教室的官网。地址：<http://191.101.11.174/mgzd>。\n", "description": "蒟蒻 SOL 居然觉得数很萌！\n\n好在在他眼里，并不是所有数都是萌的。只有满足“存在长度至少为 $2$ 的回文子串”的数是萌的——也就是说，$101$ 是萌的，因为 $101$ 本身就是一个回文数；$110$ 是萌的，因为包含回文子串 $11$；但是 $102$ 不是萌的，$1201$ 也不是萌的。\n\n现在 SOL 想知道从 $l$ 到 $r$ 的所有整数中有多少个萌数。\n\n由于答案可能很大，所以只需要输出答案对 $1000000007$（$10^9+7$）的余数。", "inputFormat": "输入包含仅 $1$ 行，包含两个整数：$l$，$r$。", "outputFormat": "输出仅 $1$ 行，包含一个整数，即为答案。\n", "hint": "记 $n$ 为 $r$ 在 $10$ 进制下的位数。\n\n对于 $10\\%$ 的数据，$n \\le 3$。\n\n对于 $30\\%$ 的数据，$n \\le 6$。\n\n对于 $60\\%$ 的数据，$n \\le 9$。\n\n对于全部的数据，$n \\le 1000$，$l < r$。\n\n\n------------\n\n2024/2/4 添加一组 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P3414", "type": "P", "difficulty": 3, "samples": [["3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2016", "洛谷原创", "组合数学", "洛谷月赛"], "title": "SAC#1 - 组合数", "background": null, "description": "今天小明学习了组合数，现在他很想知道 $\\sum \\rm{C}_{n}^{i}$ 是多少。其中 $\\rm{C}$ 是组合数（即 $\\rm{C}_{n}^{i}$ 表示 $n$ 个物品无顺序选取 $i$ 个的方案数），$i$ 取从 $0$ 到 $n$ 的所有偶数。\n\n由于答案可能很大，请输出答案对 $6662333$ 的余数。", "inputFormat": "输入仅包含一个整数 $n$。", "outputFormat": "输出一个整数，即为答案。", "hint": "对于 $20\\%$ 的数据，$n \\le 20$；\n\n对于 $50\\%$ 的数据，$n \\le 10^{3}$；\n\n对于 $100\\%$ 的数据，$n \\le 10^{18}$。", "locale": "zh-CN", "translations": {"en": {"title": "SAC#1 - Binomial Coefficients", "background": "", "description": "Today Xiaoming learned about combinations, and now he wants to know the value of $\\sum \\rm{C}_{n}^{i}$. Here $\\rm{C}$ is the binomial coefficient (i.e., $\\rm{C}_{n}^{i}$ denotes the number of ways to choose $i$ items from $n$ items without order), and $i$ ranges over all even integers from $0$ to $n$.\n\nSince the answer may be large, please output the answer modulo $6662333$.", "inputFormat": "The input contains a single integer $n$.", "outputFormat": "Output a single integer, the answer.", "hint": "For 20% of the testdata, $n \\le 20$.\n\nFor 50% of the testdata, $n \\le 10^{3}$.\n\nFor 100% of the testdata, $n \\le 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "SAC#1 - 组合数", "background": null, "description": "今天小明学习了组合数，现在他很想知道 $\\sum \\rm{C}_{n}^{i}$ 是多少。其中 $\\rm{C}$ 是组合数（即 $\\rm{C}_{n}^{i}$ 表示 $n$ 个物品无顺序选取 $i$ 个的方案数），$i$ 取从 $0$ 到 $n$ 的所有偶数。\n\n由于答案可能很大，请输出答案对 $6662333$ 的余数。", "inputFormat": "输入仅包含一个整数 $n$。", "outputFormat": "输出一个整数，即为答案。", "hint": "对于 $20\\%$ 的数据，$n \\le 20$；\n\n对于 $50\\%$ 的数据，$n \\le 10^{3}$；\n\n对于 $100\\%$ 的数据，$n \\le 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P3415", "type": "P", "difficulty": 6, "samples": [["26\n0 5\n1 1\n1 5\n1 9\n3 5\n3 10\n4 0\n4 1\n4 2\n4 4\n4 6\n4 9\n4 11\n5 0\n5 2\n5 4\n5 8\n5 9\n5 10\n5 11\n6 5\n7 5\n8 5\n9 10\n10 2\n10 5", "3\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树"], "title": "祭坛", "background": "在遥远的Dgeak大陆，生活着一种叫做Dar-dzo-nye的怪物。每当这种怪物降临，人们必须整夜对抗怪物而不能安睡。为了乞求这种怪物不再降临，人们决定建造祭坛。\n", "description": "Dgeak大陆可以看成一个用平面直角坐标系表示的巨大平面。在这个平面上，有 n 个Swaryea水晶柱，每个水晶柱可以用一个点表示。\n\n如果 4 个水晶柱依次相连可以构成一个四边形，满足其两条对角线分别平行于 x 轴和 y 轴，并且对角线的交点位于四边形内部（不包括边界），那么这 4 个水晶柱就可以建立一个结界。其中，对角线的交点称作这个结界的中心。\n\n例如下左图中，水晶柱 ABCD 可以建立一个结界，其中心为 O。\n\n![](https://cdn.luogu.com.cn/upload/pic/3591.png)   ![](https://cdn.luogu.com.cn/upload/pic/3592.png)\n\n为了起到抵御Dar-dzo-nye的最佳效果，人们会把祭坛修建在最多层结界的保护中。其中不同层的结界必须有共同的中心，这些结界的边界不能有任何公共点，并且中心处也不能有水晶柱。这里共同中心的结界数量叫做结界的层数。\n\n为了达成这个目的，人们要先利用现有的水晶柱建立若干个结界，然后在某些结界的中心建立祭坛。\n\n例如上右图中，黑色的点表示水晶柱（注意 P 和 O 点不是水晶柱）。祭坛的一个最佳位置为 O 点，可以建立在 3 层结界中，其结界的具体方案见下左图。当然，建立祭坛的最佳位置不一定是唯一，在上右图中，O 点左侧 1 单位的点 P 也可以建立一个在 3 层结界中的祭坛，见下右图。\n\n![](https://cdn.luogu.com.cn/upload/pic/3593.png)   ![](https://cdn.luogu.com.cn/upload/pic/3594.png)\n\n现在人们想知道：\n\n1. 祭坛最佳选址地点所在的结界层数；\n\n2. 祭坛最佳的选址地点共有多少个。\n", "inputFormat": "输入的第一行包含两个正整数 n,表示水晶柱的个数\n\n接下来 n 行，每行包含两个非负整数 x,y，表示每个水晶柱的坐标。保证相同的坐标不会重复出现。\n", "outputFormat": "第一行一个整数，表示祭坛最多可以位于多少个结界的中心\n\n第二行一个整数，表示结界数最多的方案有多少种。\n", "hint": "对于30%的数据 n <= 1000\n\n另外30%的数据 n <= 10000\n\n剩下的40%数据 n <= 100000\n\n保证 0 <= x, y <= n\n", "locale": "zh-CN", "translations": {"en": {"title": "Altar", "background": "On the distant continent of Dgeak, there lives a monster called Dar-dzo-nye. Whenever this monster descends, people must fight it through the night without sleep. To pray that this monster will no longer appear, people decide to build altars.", "description": "The continent of Dgeak can be regarded as a vast plane represented by a Cartesian coordinate system. On this plane, there are n Swaryea crystal pillars, each represented by a point.\n\nIf 4 crystal pillars, connected in order, form a quadrilateral such that its two diagonals are respectively parallel to the x-axis and the y-axis, and the intersection of the diagonals lies strictly inside the quadrilateral (not on the boundary), then these 4 pillars can form a ward. The intersection of the diagonals is called the center of this ward.\n\nFor example, in the left figure below, pillars A, B, C, D can form a ward, whose center is O.\n\n![](https://cdn.luogu.com.cn/upload/pic/3591.png)   ![](https://cdn.luogu.com.cn/upload/pic/3592.png)\n\nTo best resist Dar-dzo-nye, people will place the altar at a location enclosed by the most layers of wards. These different layers must share the same center, their boundaries must be pairwise disjoint, and there must be no crystal pillar at the center. The number of wards sharing the same center is called the number of layers.\n\nTo achieve this, people will first use the existing crystal pillars to form several wards, and then build altars at the centers of some wards.\n\nFor example, in the top-right figure, black dots are crystal pillars (note that points P and O are not crystal pillars). One optimal location is point O, where an altar can be placed within 3 layers of wards; a specific scheme is shown in the bottom-left figure. Of course, the optimal location is not necessarily unique; in the top-right figure, the point P that is 1 unit to the left of O can also host an altar within 3 layers of wards, as shown in the bottom-right figure.\n\n![](https://cdn.luogu.com.cn/upload/pic/3593.png)   ![](https://cdn.luogu.com.cn/upload/pic/3594.png)\n\nNow people want to know:\n1. The number of layers at the best altar location.\n2. How many optimal locations there are.", "inputFormat": "The first line contains one positive integer n, the number of crystal pillars.\nEach of the next n lines contains two non-negative integers x, y, the coordinates of a crystal pillar. It is guaranteed that there are no duplicate coordinates.", "outputFormat": "The first line contains one integer, the maximum number of layers in which an altar can be located.\nThe second line contains one integer, the number of locations that achieve this maximum.", "hint": "Constraints:\n- For 30% of the testdata, $n \\le 1000$.\n- For another 30% of the testdata, $n \\le 10000$.\n- For the remaining 40% of the testdata, $n \\le 100000$.\n- It is guaranteed that $0 \\le x, y \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "祭坛", "background": "在遥远的Dgeak大陆，生活着一种叫做Dar-dzo-nye的怪物。每当这种怪物降临，人们必须整夜对抗怪物而不能安睡。为了乞求这种怪物不再降临，人们决定建造祭坛。\n", "description": "Dgeak大陆可以看成一个用平面直角坐标系表示的巨大平面。在这个平面上，有 n 个Swaryea水晶柱，每个水晶柱可以用一个点表示。\n\n如果 4 个水晶柱依次相连可以构成一个四边形，满足其两条对角线分别平行于 x 轴和 y 轴，并且对角线的交点位于四边形内部（不包括边界），那么这 4 个水晶柱就可以建立一个结界。其中，对角线的交点称作这个结界的中心。\n\n例如下左图中，水晶柱 ABCD 可以建立一个结界，其中心为 O。\n\n![](https://cdn.luogu.com.cn/upload/pic/3591.png)   ![](https://cdn.luogu.com.cn/upload/pic/3592.png)\n\n为了起到抵御Dar-dzo-nye的最佳效果，人们会把祭坛修建在最多层结界的保护中。其中不同层的结界必须有共同的中心，这些结界的边界不能有任何公共点，并且中心处也不能有水晶柱。这里共同中心的结界数量叫做结界的层数。\n\n为了达成这个目的，人们要先利用现有的水晶柱建立若干个结界，然后在某些结界的中心建立祭坛。\n\n例如上右图中，黑色的点表示水晶柱（注意 P 和 O 点不是水晶柱）。祭坛的一个最佳位置为 O 点，可以建立在 3 层结界中，其结界的具体方案见下左图。当然，建立祭坛的最佳位置不一定是唯一，在上右图中，O 点左侧 1 单位的点 P 也可以建立一个在 3 层结界中的祭坛，见下右图。\n\n![](https://cdn.luogu.com.cn/upload/pic/3593.png)   ![](https://cdn.luogu.com.cn/upload/pic/3594.png)\n\n现在人们想知道：\n\n1. 祭坛最佳选址地点所在的结界层数；\n\n2. 祭坛最佳的选址地点共有多少个。\n", "inputFormat": "输入的第一行包含两个正整数 n,表示水晶柱的个数\n\n接下来 n 行，每行包含两个非负整数 x,y，表示每个水晶柱的坐标。保证相同的坐标不会重复出现。\n", "outputFormat": "第一行一个整数，表示祭坛最多可以位于多少个结界的中心\n\n第二行一个整数，表示结界数最多的方案有多少种。\n", "hint": "对于30%的数据 n <= 1000\n\n另外30%的数据 n <= 10000\n\n剩下的40%数据 n <= 100000\n\n保证 0 <= x, y <= n\n", "locale": "zh-CN"}}}
{"pid": "P3416", "type": "P", "difficulty": 3, "samples": [["4\n1 3 5\n5 4 3\n7 2 1\n6 1 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2016", "USACO", "Floyd 算法"], "title": "[USACO16DEC] Moocast S", "background": "", "description": "Farmer John's $N$ cows ($1 \\leq N \\leq 200$) want to organize an emergency\"moo-cast\" system for broadcasting important messages among themselves.\n\n\nInstead of mooing at each-other over long distances, the cows decide to equip themselves with walkie-talkies, one for each cow.  These walkie-talkies each have a limited transmission radius -- a walkie-talkie of power $P$ can only transmit to other cows up to a distance of $P$ away (note that cow A might be able to transmit to cow B even if cow B cannot transmit back, due to cow A's power being larger than that of cow B).  Fortunately, cows can relay messages to one-another along a path consisting of several hops, so it is not necessary for every cow to be able to transmit directly to every other cow.\n\n\nDue to the asymmetrical nature of the walkie-talkie transmission, broadcasts from some cows may be more effective than from other cows in their ability toreach large numbers of recipients (taking relaying into account).  Please  help the cows determine the maximum number of cows that can be reached by a broadcast originating from a single cow.\n\n\n\n\n\n", "inputFormat": "The first line of input contains $N$.\n\n\nThe next $N$ lines each contain the $x$ and $y$ coordinates of a single cow ( integers in the range $0 \\ldots 25,000$) followed by $p$, the power of the walkie-talkie held by this cow.\n", "outputFormat": "Write a single line of output containing the maximum number of cows a broadcast from a single cow can reach.  The originating cow is included in this number.\n\n\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO16DEC] Moocast S", "background": "", "description": "Farmer John's $N$ cows ($1 \\leq N \\leq 200$) want to organize an emergency\"moo-cast\" system for broadcasting important messages among themselves.\n\n\nInstead of mooing at each-other over long distances, the cows decide to equip themselves with walkie-talkies, one for each cow.  These walkie-talkies each have a limited transmission radius -- a walkie-talkie of power $P$ can only transmit to other cows up to a distance of $P$ away (note that cow A might be able to transmit to cow B even if cow B cannot transmit back, due to cow A's power being larger than that of cow B).  Fortunately, cows can relay messages to one-another along a path consisting of several hops, so it is not necessary for every cow to be able to transmit directly to every other cow.\n\n\nDue to the asymmetrical nature of the walkie-talkie transmission, broadcasts from some cows may be more effective than from other cows in their ability toreach large numbers of recipients (taking relaying into account).  Please  help the cows determine the maximum number of cows that can be reached by a broadcast originating from a single cow.\n\n\n\n\n\n", "inputFormat": "The first line of input contains $N$.\n\n\nThe next $N$ lines each contain the $x$ and $y$ coordinates of a single cow ( integers in the range $0 \\ldots 25,000$) followed by $p$, the power of the walkie-talkie held by this cow.\n", "outputFormat": "Write a single line of output containing the maximum number of cows a broadcast from a single cow can reach.  The originating cow is included in this number.\n\n\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO16DEC] Moocast S", "background": "", "description": "约翰农场主的 $N$ 头奶牛想建立一个紧急情况下的“哞哞广播”系统，这样它们就可以在自己中间广播重要信息。\n\n奶牛们想让每头牛装备上一个对讲机，而不是在长距离中向另一头奶牛“哞哞”乱叫。这些对讲机每台都有各自的有效传输半径——一个拥有 $P$ 能量的对讲机只能向距离在 $P$ 以内的牛发送信息（注意可能出现 $A$ 牛对讲机的能量比 $B$ 牛的大，而 $A$ 牛可以给 $B$ 牛发送信息，但 $B$ 牛不能传回信息）。幸运的是，奶牛们可以通过其他奶牛中继，沿着一条跳跃的路径传递信息，因此每个奶牛不必要直接向每个其他奶牛传播。\n\n由于对讲机的不对称性质，来自一些奶牛的广播可能比其他奶牛的广播能够达到更多的接受者（考虑中继的情况）的能力更有效。请帮助奶牛确定来自单个奶牛的广播可以达到的奶牛的最大数量。", "inputFormat": "第一行，一个整数 $N$。\n\n接下来 $N$ 行，第 $i$ 行包括第 $i$ 只牛的坐标 $(x_i,y_i)$，以及这只牛所持有对讲机的能量 $P_i$。", "outputFormat": "一行，一个整数，表示从来自单个奶牛的广播可以达到的奶牛的最大数量。开始的牛也包括在这个数量中。", "hint": "对于 $100\\%$ 的数据，$N\\le200$，$\\forall i \\in [1,N]$，$0\\le x_i,y_i\\le25000$。", "locale": "zh-CN"}}}
{"pid": "P3417", "type": "P", "difficulty": 5, "samples": [["2\n3 123\n3 234", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2005", "POI（波兰）"], "title": "[POI 2005] BANK-Cash Dispenser", "background": "", "description": "The BBB (short for Byteotian Bit Bank) owns the largest net of cash dispensers in Byteotia. The clients of the BBB can draw their money from the cash dispensers on the basis of a cash card and a 4-digit PIN code. Lately, in order to increase their clients' security, the BBB has had a camera installed by each cash dispenser. The cameras transmit the recorded image to the BBB using radio signals. Unfortunately, the signals are being intercepted by a gang of computer thieves. The thieves attempt to discover the 4-digit PIN codes of the BBB clients, whose cash cards they subsequently steal. Being aware of this fact, the BBB clients try to perform redundant movements over the keyboard while entering the PIN. The camera is not able to pick out the keystrokes, it only records the finger movements. Consequently, it is usually not possible to determine the PIN unambiguously. For instance, the client moving his finger over the key 1 and then over the key 5 could have entered the following PIN codes: 1111, 1115, 1155, 1555, 5555. Desperate thieves glean the camera recordings, counting on being able to determine the PIN of a client or at least limiting the number of possible codes on the basis of multiple recordings of his transactions. Having accumulated sequences entered by a particular wealthy client of the BBB, they made you an \"unnegotiable proposition\".\n\nTaskWrite a programme which:\n\nreads from the standard input a description of the recorded sequences of finger movements, which the client has performed whilst entering his PIN,determines the number of distinct PIN codes, which the client can have (i.e. the number of those 4-digit PIN codes, which could have been entered by performing the given finger movement sequences),writes the outcome to the standard output.\n\nBBB（Byteotian Bit Bank的缩写）拥有Byteotia最大的自动提款机网络。 BBB的客户可以根据现金卡和4位数的PIN码从自动柜员机中提取款项。最近，为了提高客户的安全性，BBB已经给每台自动提款机安装了相机。摄像机使用无线电信号将记录的图像发送到BBB。不幸的是，这些信号正被一群电脑盗贼拦截。盗贼试图发现BBB用户的4位PIN码，他们随后窃取了他们的现金卡。意识到这一事实，BBB用户尝试在输入PIN时执行键盘上的冗余动作。相机只能记录手指的动作。因此，通常不可能明确地确定PIN码。例如，用户将手指移动到键1上，然后移动到键5可以输入以下PIN码：1111,1115,1155,1555,5555。绝望的盗贼们收集相机记录，现在盗贼们给你一个手指移动序列，要求你确定用户可以具有的不同PIN码的数量。\n\n写一个程序：\n\n从标准输入读取记录的手指移动序列的描述，用户在输入PIN码时执行的手指移动序列，确定客户端可以具有的不同PIN码的数量（即，这些4位PIN码的数量，这可以通过执行给定的手指移动顺序进入），将结果写入标准输出。\n", "inputFormat": "The first line of the standard input contains a single integer $n$ denoting the number of recorded scenes depicting the action of entering the PIN by the client, $1\\le n\\le 1\\ 000$. In the following $n$ lines there are descriptions of these scenes, a single one per line. The description of each scene consists of two positive integers separated by a single space. The first of those numbers, $t$, denotes the length of the sequence of movements, $1\\le t\\le 10\\ 000$. The other is a $t$-digit number, whose consecutive digits denote consecutive keys, over which the client has moved his finger. The total length of all sequences does not exceed $1\\ 000\\ 000$.\n\n标准输入的第一行包含一个整数n，表示用户输入PIN的动作数，$1\\le n\\le 1\\ 000$。 在以下n行中，对这些动作进行了描述，每行描述一个动作。每个动作的描述由两个由单个空格分开的正整数组成。 这些数中的第一个数字t表示运动序列的长度，$1\\le t\\le 10\\ 000$。另一个是一个t位的正整数，其连续的数字表示连续的键，表示用户移动他的手指到的目标。保证$\\sum t\\le 1\\ 000\\ 000$。\n", "outputFormat": "The first and only line of the output should contain a single positive integer - the number of possible PIN codes of the client.\n\n输出有一行，应包含一个正整数，用户可能的PIN码的数量。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2005] BANK-Cash Dispenser", "background": "", "description": "The BBB (short for Byteotian Bit Bank) owns the largest network of cash dispensers in Byteotia. The clients of the BBB can withdraw money from cash dispensers using a cash card and a 4-digit PIN code. Recently, to increase client security, the BBB has installed a camera by each cash dispenser. The cameras transmit the recorded image to the BBB using radio signals. Unfortunately, these signals are being intercepted by a gang of computer thieves. The thieves try to discover the 4-digit PIN codes of BBB clients, whose cash cards they subsequently steal. Aware of this, BBB clients try to make redundant movements over the keyboard while entering the PIN. The camera cannot pick out the actual keystrokes; it only records the finger movements. Consequently, it is usually impossible to determine the PIN unambiguously. For instance, a client moving a finger over key 1 and then over key 5 could have entered the following PIN codes: 1111, 1115, 1155, 1555, 5555. Desperate thieves analyze the camera recordings, hoping to determine the client’s PIN or at least limit the number of possible codes based on multiple recordings of his transactions. Having accumulated sequences entered by a particular wealthy client of the BBB, they made you an \"unnegotiable proposition\".\n\nTask: Write a program that:\n- reads from standard input a description of the recorded sequences of finger movements performed while entering the PIN,\n- determines the number of distinct 4-digit PIN codes the client can have (i.e., the number of 4-digit PIN codes that could have been entered while performing each of the given finger movement sequences),\n- writes the result to standard output.", "inputFormat": "The first line contains a single integer $n$ denoting the number of recorded scenes of entering the PIN by the client, $1\\le n\\le 1\\ 000$. Each of the following $n$ lines describes one scene and consists of two positive integers separated by a single space. The first number, $t$, denotes the length of the movement sequence, $1\\le t\\le 10\\ 000$. The second is a $t$-digit number whose consecutive digits denote consecutive keys over which the client moved a finger. The total length of all sequences does not exceed $1\\ 000\\ 000$.", "outputFormat": "Print a single positive integer: the number of possible PIN codes of the client.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2005] BANK-Cash Dispenser", "background": "", "description": "The BBB (short for Byteotian Bit Bank) owns the largest net of cash dispensers in Byteotia. The clients of the BBB can draw their money from the cash dispensers on the basis of a cash card and a 4-digit PIN code. Lately, in order to increase their clients' security, the BBB has had a camera installed by each cash dispenser. The cameras transmit the recorded image to the BBB using radio signals. Unfortunately, the signals are being intercepted by a gang of computer thieves. The thieves attempt to discover the 4-digit PIN codes of the BBB clients, whose cash cards they subsequently steal. Being aware of this fact, the BBB clients try to perform redundant movements over the keyboard while entering the PIN. The camera is not able to pick out the keystrokes, it only records the finger movements. Consequently, it is usually not possible to determine the PIN unambiguously. For instance, the client moving his finger over the key 1 and then over the key 5 could have entered the following PIN codes: 1111, 1115, 1155, 1555, 5555. Desperate thieves glean the camera recordings, counting on being able to determine the PIN of a client or at least limiting the number of possible codes on the basis of multiple recordings of his transactions. Having accumulated sequences entered by a particular wealthy client of the BBB, they made you an \"unnegotiable proposition\".\n\nTaskWrite a programme which:\n\nreads from the standard input a description of the recorded sequences of finger movements, which the client has performed whilst entering his PIN,determines the number of distinct PIN codes, which the client can have (i.e. the number of those 4-digit PIN codes, which could have been entered by performing the given finger movement sequences),writes the outcome to the standard output.\n\nBBB（Byteotian Bit Bank的缩写）拥有Byteotia最大的自动提款机网络。 BBB的客户可以根据现金卡和4位数的PIN码从自动柜员机中提取款项。最近，为了提高客户的安全性，BBB已经给每台自动提款机安装了相机。摄像机使用无线电信号将记录的图像发送到BBB。不幸的是，这些信号正被一群电脑盗贼拦截。盗贼试图发现BBB用户的4位PIN码，他们随后窃取了他们的现金卡。意识到这一事实，BBB用户尝试在输入PIN时执行键盘上的冗余动作。相机只能记录手指的动作。因此，通常不可能明确地确定PIN码。例如，用户将手指移动到键1上，然后移动到键5可以输入以下PIN码：1111,1115,1155,1555,5555。绝望的盗贼们收集相机记录，现在盗贼们给你一个手指移动序列，要求你确定用户可以具有的不同PIN码的数量。\n\n写一个程序：\n\n从标准输入读取记录的手指移动序列的描述，用户在输入PIN码时执行的手指移动序列，确定客户端可以具有的不同PIN码的数量（即，这些4位PIN码的数量，这可以通过执行给定的手指移动顺序进入），将结果写入标准输出。\n", "inputFormat": "The first line of the standard input contains a single integer $n$ denoting the number of recorded scenes depicting the action of entering the PIN by the client, $1\\le n\\le 1\\ 000$. In the following $n$ lines there are descriptions of these scenes, a single one per line. The description of each scene consists of two positive integers separated by a single space. The first of those numbers, $t$, denotes the length of the sequence of movements, $1\\le t\\le 10\\ 000$. The other is a $t$-digit number, whose consecutive digits denote consecutive keys, over which the client has moved his finger. The total length of all sequences does not exceed $1\\ 000\\ 000$.\n\n标准输入的第一行包含一个整数n，表示用户输入PIN的动作数，$1\\le n\\le 1\\ 000$。 在以下n行中，对这些动作进行了描述，每行描述一个动作。每个动作的描述由两个由单个空格分开的正整数组成。 这些数中的第一个数字t表示运动序列的长度，$1\\le t\\le 10\\ 000$。另一个是一个t位的正整数，其连续的数字表示连续的键，表示用户移动他的手指到的目标。保证$\\sum t\\le 1\\ 000\\ 000$。\n", "outputFormat": "The first and only line of the output should contain a single positive integer - the number of possible PIN codes of the client.\n\n输出有一行，应包含一个正整数，用户可能的PIN码的数量。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3418", "type": "P", "difficulty": 6, "samples": [["3\n0 0\n2 0\n2 1\n2\n3\n4 1\n6 5\n4 5\n3\n4 0\n6 0\n5 -1", "TAK\nNIE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "并查集", "POI（波兰）", "最短路"], "title": "[POI 2005] PUN-Points", "background": "", "description": "A set of grid points in a plane (points whose both cartesian coordinates are integers) which we shall refer to as the pattern, as well as a group of other sets of grid points on the plane are given. We would like to know which of the sets are similar to the pattern, i.e. which of them can be transformed by rotations, translations, reflections and dilations so that they are identical to the pattern. For instance: the set of points $\\{(0,0),(2,0),(2,1)\\}$ is similar to the set $\\{(6,1),(6,5),(4,5)\\}$, it is however not similar to the set $\\{(4,0),(6,0),(5,-1)\\}$.\n\nTaskWrite a programme which:\n\nreads from the standard input the description of the pattern and the family of the investigated sets of points,determines which of the investigated sets of points are similar to the pattern,writes the outcome to the standard output.\n\n题目描述：\n\n\n给出一个包含平面上格点的集合（格点的定义是xy坐标均为整数），我们将其称作“模式集合”。\n\n\n接下来给出另外的几个包含平面上点的集合。我们想要考察后面给出的哪些集合和“模式集合”是“相似”的，即：该集合可以通过 旋转，平移，翻转，和缩放 使得该集合和“模式集合”完全相同。\n\n\n例：{(0,0),(2,0),(2,1)}这个集合和{(6,1),(6,5),(4,5)}这个集合是相似的，但和{(4,0),(6,0),(5,-1)}这个集合是不相似的。\n\n\n任务：\n\n\n写一个程序，使得\n\n\n能从标准输入读取“模式集合”和需要考察（是否相似）的集合，判断哪些集合和“模式集合”相似，并将结果输出到标准输出\n\n\n输入格式：\n\n\n标准输入的第一行有一个整数 k (1<=k<=25000)，代表“模式集合”中的点数\n\n\n接下来k行，每行两个数，用一个空格分隔，第i+1行的两个数分别代表“模式集合”中第i个点的x坐标和y坐标(-20000<=x,y<=20000)\n\n\n“模式集合”中的点两两不同。\n\n\n接下来一行一个整数n，代表有n个需要考察的集合\n\n\n接下来有n个对需要考察的集合的描述：\n\n\n每个描述的第一行包含一个整数l，代表该集合中的点数(1<=l<=25000)\n\n\n接下来l行每行包含该集合中一个点的x坐标和y坐标，用一个空格分隔(-20000<=x,y<=20000，为整数)\n\n\n包含在同一集合中的点两两不同。\n\n\n输出格式：\n\n\n你的程序应该向标准输出流输出n行，每行代表对于一个需要考察的集合的结果。\n\n\n如果第i个需要考察的集合与“模式集合”相似，则第i行应包含单词TAK，即波兰语中的yes\n\n\n否则第i行应包含单词NIE，即波兰语中的no\n", "inputFormat": "In the first line of the standard input there is a single integer $k$ ($1\\le k\\le 25\\ 000$) - the number of points the pattern consists of. In the following $k$ lines there are pairs of integers, separated by single spaces. The $(i+1)$'st line contains the coordinates of $i$'th point belonging to the pattern: $x_{i}$ and $y_{i}$ ($-20\\ 000\\le x_{i},y_{i} \\le 20\\ 000$). The points forming the pattern are pairwise different. In the next line there is the number of sets to be investigated: $n$ ($1\\le n\\le 20$). Next, there are $n$ descriptions of these sets. The description of each set begins with a line containing a single integer $l$ - the number of points belonging to that particular set($1\\le l\\le 25\\ 000$).These points are described in the following lines, a single point per line. The description of a point consists of two integers separated by a single space - its coordinates $x$ and $y$ ($-20\\ 000\\le x,y\\le 20\\ 000$).The points which belong to the same set are pairwise different.\n", "outputFormat": "Your programme should write to the standard output $n$ lines - one for each of the investigated sets of points. The $i$'th line should contain the word TAK (i.e. yes in Polish), if the $i$'th of the given sets of points is similar to the pattern, or the word NIE (i.e. no in Polish) if the set does not satisfy this condition.\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2005] PUN-Points", "background": "# Description\n\nA set of grid points in the plane (points whose Cartesian coordinates are both integers), called the pattern, is given, as well as several other sets of grid points. We want to determine which of these sets are similar to the pattern, i.e., which can be transformed by rotations, translations, reflections, and dilations so that they become identical to the pattern.\n\nFor example, the set of points {(0, 0), (2, 0), (2, 1)} is similar to the set {(6, 1), (6, 5), (4, 5)}, but it is not similar to the set {(4, 0), (6, 0), (5, −1)}.\n\nWrite a program that:\n- reads the description of the pattern and the family of candidate sets of points from standard input,\n- determines which of the candidate sets of points are similar to the pattern,\n- writes the results to standard output.", "description": "A set of grid points in the plane (points whose Cartesian coordinates are both integers), called the pattern, is given, as well as several other sets of grid points. We want to determine which of these sets are similar to the pattern, i.e., which can be transformed by rotations, translations, reflections, and dilations so that they become identical to the pattern.\n\nFor example, the set of points {(0, 0), (2, 0), (2, 1)} is similar to the set {(6, 1), (6, 5), (4, 5)}, but it is not similar to the set {(4, 0), (6, 0), (5, −1)}.\n\nWrite a program that:\n- reads the description of the pattern and the family of candidate sets of points from standard input,\n- determines which of the candidate sets of points are similar to the pattern,\n- writes the results to standard output.\n\n# Description", "inputFormat": "In the first line of the standard input there is a single integer $k$ ($1\\le k\\le 25\\ 000$) — the number of points in the pattern. In the following $k$ lines there are pairs of integers, separated by single spaces. The $(i+1)$-st line contains the coordinates of the $i$-th point belonging to the pattern: $x_{i}$ and $y_{i}$ ($-20\\ 000\\le x_{i},y_{i} \\le 20\\ 000$). The points forming the pattern are pairwise different.\n\nIn the next line there is the number of sets to be investigated: $n$ ($1\\le n\\le 20$).\n\nNext, there are $n$ descriptions of these sets. The description of each set begins with a line containing a single integer $l$ — the number of points belonging to that particular set ($1\\le l\\le 25\\ 000$). These points are described in the following lines, one point per line. The description of a point consists of two integers separated by a single space — its coordinates $x$ and $y$ ($-20\\ 000\\le x,y\\le 20\\ 000$). The points within the same set are pairwise different.", "outputFormat": "Your program should write to the standard output $n$ lines — one for each of the investigated sets of points. The $i$-th line should contain the word TAK (i.e., yes in Polish) if the $i$-th set of points is similar to the pattern, or the word NIE (i.e., no in Polish) if it is not.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2005] PUN-Points", "background": "", "description": "A set of grid points in a plane (points whose both cartesian coordinates are integers) which we shall refer to as the pattern, as well as a group of other sets of grid points on the plane are given. We would like to know which of the sets are similar to the pattern, i.e. which of them can be transformed by rotations, translations, reflections and dilations so that they are identical to the pattern. For instance: the set of points $\\{(0,0),(2,0),(2,1)\\}$ is similar to the set $\\{(6,1),(6,5),(4,5)\\}$, it is however not similar to the set $\\{(4,0),(6,0),(5,-1)\\}$.\n\nTaskWrite a programme which:\n\nreads from the standard input the description of the pattern and the family of the investigated sets of points,determines which of the investigated sets of points are similar to the pattern,writes the outcome to the standard output.\n\n题目描述：\n\n\n给出一个包含平面上格点的集合（格点的定义是xy坐标均为整数），我们将其称作“模式集合”。\n\n\n接下来给出另外的几个包含平面上点的集合。我们想要考察后面给出的哪些集合和“模式集合”是“相似”的，即：该集合可以通过 旋转，平移，翻转，和缩放 使得该集合和“模式集合”完全相同。\n\n\n例：{(0,0),(2,0),(2,1)}这个集合和{(6,1),(6,5),(4,5)}这个集合是相似的，但和{(4,0),(6,0),(5,-1)}这个集合是不相似的。\n\n\n任务：\n\n\n写一个程序，使得\n\n\n能从标准输入读取“模式集合”和需要考察（是否相似）的集合，判断哪些集合和“模式集合”相似，并将结果输出到标准输出\n\n\n输入格式：\n\n\n标准输入的第一行有一个整数 k (1<=k<=25000)，代表“模式集合”中的点数\n\n\n接下来k行，每行两个数，用一个空格分隔，第i+1行的两个数分别代表“模式集合”中第i个点的x坐标和y坐标(-20000<=x,y<=20000)\n\n\n“模式集合”中的点两两不同。\n\n\n接下来一行一个整数n，代表有n个需要考察的集合\n\n\n接下来有n个对需要考察的集合的描述：\n\n\n每个描述的第一行包含一个整数l，代表该集合中的点数(1<=l<=25000)\n\n\n接下来l行每行包含该集合中一个点的x坐标和y坐标，用一个空格分隔(-20000<=x,y<=20000，为整数)\n\n\n包含在同一集合中的点两两不同。\n\n\n输出格式：\n\n\n你的程序应该向标准输出流输出n行，每行代表对于一个需要考察的集合的结果。\n\n\n如果第i个需要考察的集合与“模式集合”相似，则第i行应包含单词TAK，即波兰语中的yes\n\n\n否则第i行应包含单词NIE，即波兰语中的no\n", "inputFormat": "In the first line of the standard input there is a single integer $k$ ($1\\le k\\le 25\\ 000$) - the number of points the pattern consists of. In the following $k$ lines there are pairs of integers, separated by single spaces. The $(i+1)$'st line contains the coordinates of $i$'th point belonging to the pattern: $x_{i}$ and $y_{i}$ ($-20\\ 000\\le x_{i},y_{i} \\le 20\\ 000$). The points forming the pattern are pairwise different. In the next line there is the number of sets to be investigated: $n$ ($1\\le n\\le 20$). Next, there are $n$ descriptions of these sets. The description of each set begins with a line containing a single integer $l$ - the number of points belonging to that particular set($1\\le l\\le 25\\ 000$).These points are described in the following lines, a single point per line. The description of a point consists of two integers separated by a single space - its coordinates $x$ and $y$ ($-20\\ 000\\le x,y\\le 20\\ 000$).The points which belong to the same set are pairwise different.\n", "outputFormat": "Your programme should write to the standard output $n$ lines - one for each of the investigated sets of points. The $i$'th line should contain the word TAK (i.e. yes in Polish), if the $i$'th of the given sets of points is similar to the pattern, or the word NIE (i.e. no in Polish) if the set does not satisfy this condition.\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3419", "type": "P", "difficulty": 5, "samples": [["3 2 7\n1\n2\n3\n1\n3\n1\n2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2005", "POI（波兰）", "优先队列", "队列"], "title": "[POI 2005] SAM-Toy Cars", "background": null, "description": "Jasio 是一个只有三岁的小男孩，他喜欢玩玩具车。他有 $n$ 辆玩具车被保存在书架上。\n\n架子上的玩具车 Jasio 拿不到，但地板上的他可以拿到。Jasio 的母亲会帮 Jasio 拿架子上的玩具车到地板上。\n\n地板最多只能放 $k$ 辆玩具车。\n\n当地板已经放了 $k$ 辆玩具车时，Jasio 的母亲都会从地板上先拿走一个玩具车放回书架，再拿来 Jasio 想要的玩具车。\n\n现在 Jasio 一共想依次玩 $p$ 个玩具车，问 Jasio 的母亲最少需要拿几次玩具车。（只算拿下来的，不算拿上去的）", "inputFormat": "第一行三个整数 $n,k$ 和 $p$。\n\n接下来 $p$ 行，每一行有且仅有一个整数 $a_i$，表示 Jasio 想玩的玩具车编号。", "outputFormat": "输出一行一个整数，表示最少 Jasio 的母亲最少需要拿玩具车的次数。", "hint": "对于 $100\\%$ 的数据：$1\\le k\\le n\\le 10^5$，$1\\le p\\le 5\\times 10^5$，$1\\le a_i\\le n$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2005] SAM-Toy Cars", "background": "", "description": "Jasio is a three-year-old boy who loves to play with toy cars. He has $n$ toy cars stored on a shelf.\n\nJasio cannot reach the toy cars on the shelf, but he can reach the ones on the floor. Jasio’s mother helps by moving toy cars from the shelf to the floor.\n\nThe floor can hold at most $k$ toy cars.\n\nWhen there are already $k$ toy cars on the floor, Jasio’s mother will first take one toy car from the floor back to the shelf, and then bring the toy car that Jasio wants.\n\nNow Jasio wants to play with $p$ toy cars in order. Determine the minimum number of times his mother needs to take a toy car down. (Only count taking down from the shelf; do not count putting back.)", "inputFormat": "The first line contains three integers $n$, $k$ and $p$.\n\nThe next $p$ lines each contain exactly one integer $a_i$, indicating the ID of the toy car Jasio wants.", "outputFormat": "Output a single integer, the minimum number of times Jasio’s mother needs to take a toy car down.", "hint": "Constraints: For $100\\%$ of the testdata: $1 \\le k \\le n \\le 10^5$, $1 \\le p \\le 5 \\times 10^5$, $1 \\le a_i \\le n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2005] SAM-Toy Cars", "background": null, "description": "Jasio 是一个只有三岁的小男孩，他喜欢玩玩具车。他有 $n$ 辆玩具车被保存在书架上。\n\n架子上的玩具车 Jasio 拿不到，但地板上的他可以拿到。Jasio 的母亲会帮 Jasio 拿架子上的玩具车到地板上。\n\n地板最多只能放 $k$ 辆玩具车。\n\n当地板已经放了 $k$ 辆玩具车时，Jasio 的母亲都会从地板上先拿走一个玩具车放回书架，再拿来 Jasio 想要的玩具车。\n\n现在 Jasio 一共想依次玩 $p$ 个玩具车，问 Jasio 的母亲最少需要拿几次玩具车。（只算拿下来的，不算拿上去的）", "inputFormat": "第一行三个整数 $n,k$ 和 $p$。\n\n接下来 $p$ 行，每一行有且仅有一个整数 $a_i$，表示 Jasio 想玩的玩具车编号。", "outputFormat": "输出一行一个整数，表示最少 Jasio 的母亲最少需要拿玩具车的次数。", "hint": "对于 $100\\%$ 的数据：$1\\le k\\le n\\le 10^5$，$1\\le p\\le 5\\times 10^5$，$1\\le a_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P3420", "type": "P", "difficulty": 3, "samples": [["4\n2\n1\n2\n4", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2005", "并查集", "POI（波兰）", "连通块"], "title": "[POI 2005] SKA-Piggy Banks", "background": "", "description": "Byteazar the Dragon 拥有 $N$ 个小猪存钱罐。每一个存钱罐能够用相应的钥匙打开或者被砸开。Byteazar 已经将钥匙放入到一些存钱罐中。现在已知每个钥匙所在的存钱罐，Byteazar 想要买一辆小汽车，而且需要打开所有的存钱罐。然而，他想要破坏尽量少的存钱罐，帮助 Byteazar 去决策最少要破坏多少存钱罐。", "inputFormat": "\n第一行包括一个整数 $N$ ($1\\le N\\le 1000000$)，表示 Byteazar the Dragon 拥有的存钱罐的数量。\n\n存钱罐（包括它们对应的钥匙）从 $1$ 到 $N$ 编号。\n\n接下来有 $N$ 行：第 $i+1$ 行包括一个整数 $x$，表示第 $i$ 个存钱罐对应的钥匙放置在了第 $x$ 个存钱罐中。\n", "outputFormat": "仅一行：包括一个整数，表示能打开所有存钱罐的情况下，需要破坏的存钱罐的最少数量。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2005] SKA-Piggy Banks", "background": "", "description": "Byteazar the Dragon has $N$ piggy banks. Each piggy bank can be opened with its corresponding key or smashed. Byteazar has placed the keys into some piggy banks. Given, for each key, which piggy bank it is in, Byteazar wants to buy a car and needs to open all piggy banks. However, he wants to destroy as few piggy banks as possible. Help Byteazar decide the minimum number of piggy banks that must be smashed.", "inputFormat": "The first line contains an integer $N$ ($1\\le N\\le 1000000$), representing the number of piggy banks owned by Byteazar the Dragon.\n\nThe piggy banks (including their corresponding keys) are numbered from $1$ to $N$.\n\nThen there are $N$ lines: the $(i+1)$-th line contains an integer $x$, indicating that the key for the $i$-th piggy bank is placed in the $x$-th piggy bank.", "outputFormat": "A single line containing an integer, representing the minimum number of piggy banks that must be smashed in order to be able to open all piggy banks.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2005] SKA-Piggy Banks", "background": "", "description": "Byteazar the Dragon 拥有 $N$ 个小猪存钱罐。每一个存钱罐能够用相应的钥匙打开或者被砸开。Byteazar 已经将钥匙放入到一些存钱罐中。现在已知每个钥匙所在的存钱罐，Byteazar 想要买一辆小汽车，而且需要打开所有的存钱罐。然而，他想要破坏尽量少的存钱罐，帮助 Byteazar 去决策最少要破坏多少存钱罐。", "inputFormat": "\n第一行包括一个整数 $N$ ($1\\le N\\le 1000000$)，表示 Byteazar the Dragon 拥有的存钱罐的数量。\n\n存钱罐（包括它们对应的钥匙）从 $1$ 到 $N$ 编号。\n\n接下来有 $N$ 行：第 $i+1$ 行包括一个整数 $x$，表示第 $i$ 个存钱罐对应的钥匙放置在了第 $x$ 个存钱罐中。\n", "outputFormat": "仅一行：包括一个整数，表示能打开所有存钱罐的情况下，需要破坏的存钱罐的最少数量。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3421", "type": "P", "difficulty": 5, "samples": [["3\n24 28\n15 50\n12 21", "3 0\n0 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2005", "POI（波兰）", "Special Judge", "最大公约数 gcd"], "title": "[POI 2005] SKO-Knights", "background": null, "description": "一个骑士在一个无限的棋盘上移动。它可以执行的每一个动作都由一对整数 $(a,b)$ 来描述——表示这个骑士可以从 $(x,y)$ 移动到 $(x+a,y+b)$ 或者 $(x-a,y-b)$ 。这个骑士有 $n$ 组这样的移动描述，表示了它可以做出的移动。我们保证骑士从 $(0,0)$ 出发移动到的所有位置并非都共线。\n\n如果两个骑士从 $(0,0)$ 出发到达的位置集合全等，我们就说它们是等价的。(请注意，两个骑士可以分别移动不同的步数)。可以证明，对于每一个骑士，都存在另一个仅由两组 $(a,b)$ 描述的骑士与其全等。\n\n你的任务是写一个程序，读入对骑士移动的表示，然后确定两对表示等价的骑士移动的整数，并输出这两对整数。", "inputFormat": "第一行读入一个整数 $n$，表示骑士的移动方式数（$3\\le n\\le 100$）。接下来 $n$ 行为表示骑士移动的整数对，每一行是一对整数 $a_i$ 和 $b_i$，并由一个空格分隔开，$-100\\le a_i,b_i\\le 100,(a_i,b_i)\\neq (0,0)$。", "outputFormat": "第一行输出两个整数 $a$ 和 $b$，并由一个空格分隔。\n\n第二行输出两个整数 $c$ 和 $d$，并由一个空格分隔。\n\n上述整数应满足以下条件：$-10000\\le a,b,c,d\\le 10000$，且输出的两对整数描述的骑士和输入数据中描述的骑士是等价的。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[POI 2005] SKO-Knights", "background": "", "description": "A knight moves on an infinite chessboard. Each move it can perform is described by a pair of integers $(a,b)$, meaning the knight can move from $(x,y)$ to $(x+a,y+b)$ or to $(x-a,y-b)$. Each knight has a set of such move descriptions, representing the moves it can perform. We assume that all positions reachable by a knight starting from $(0,0)$ are not collinear.\n\nWe say two knights are equivalent if they can reach exactly the same set of coordinates from $(0,0)$. (Note that the same knight may reach those squares using different sequences of moves.) It can be shown that for every knight there exists an equivalent knight whose moves can be described by only two pairs of integers.\n\nYour task is to read a set of move descriptions for a knight, determine two pairs of integers that describe an equivalent knight, and output these two pairs.", "inputFormat": "The first line contains an integer $n$ ($3\\le n\\le 100$), the number of move pairs.  \nEach of the next $n$ lines contains a pair of integers $a_i$ and $b_i$ separated by a space, where $-100\\le a_i,b_i\\le 100$ and $(a_i,b_i)\\neq(0,0)$.", "outputFormat": "Output two lines.  \nThe first line contains two integers $a$ and $b$ separated by a space.  \nThe second line contains two integers $c$ and $d$ separated by a space.\n\nThese integers must satisfy $-10000\\le a,b,c,d\\le 10000$, and the two output pairs must describe a knight equivalent to the knight described in the input.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2005] SKO-Knights", "background": null, "description": "一个骑士在一个无限的棋盘上移动。它可以执行的每一个动作都由一对整数 $(a,b)$ 来描述——表示这个骑士可以从 $(x,y)$ 移动到 $(x+a,y+b)$ 或者 $(x-a,y-b)$ 。这个骑士有 $n$ 组这样的移动描述，表示了它可以做出的移动。我们保证骑士从 $(0,0)$ 出发移动到的所有位置并非都共线。\n\n如果两个骑士从 $(0,0)$ 出发到达的位置集合全等，我们就说它们是等价的。(请注意，两个骑士可以分别移动不同的步数)。可以证明，对于每一个骑士，都存在另一个仅由两组 $(a,b)$ 描述的骑士与其全等。\n\n你的任务是写一个程序，读入对骑士移动的表示，然后确定两对表示等价的骑士移动的整数，并输出这两对整数。", "inputFormat": "第一行读入一个整数 $n$，表示骑士的移动方式数（$3\\le n\\le 100$）。接下来 $n$ 行为表示骑士移动的整数对，每一行是一对整数 $a_i$ 和 $b_i$，并由一个空格分隔开，$-100\\le a_i,b_i\\le 100,(a_i,b_i)\\neq (0,0)$。", "outputFormat": "第一行输出两个整数 $a$ 和 $b$，并由一个空格分隔。\n\n第二行输出两个整数 $c$ 和 $d$，并由一个空格分隔。\n\n上述整数应满足以下条件：$-10000\\le a,b,c,d\\le 10000$，且输出的两对整数描述的骑士和输入数据中描述的骑士是等价的。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3422", "type": "P", "difficulty": 5, "samples": [["5\n3 1\n1 2\n5 2\n0 1\n5 4\n", "TAK\nNIE\nTAK\nNIE\nTAK"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "单调队列", "POI（波兰）", "前缀和"], "title": "[POI 2005] LOT-A Journey to Mars", "background": "Byteazar 决定去火星参加一个空间站旅行。", "description": "火星的所有空间站都位于一个圆上，Byteazar 在其中一个空间站登陆然后开始绕圈旅行。  \n\n旅行需要耗费油料，一升油料只能跑 $1$ 米，每个空间站可以补给的油料都有所不同。 \n\nByteazar 每到一个空间站便可以把该空间站的油料全部拿走（他的油箱是没有容量限制的）。但是如果走到某个时候突然没油了那么旅行便失败了。\n\nByteazar 需要决定要在哪个地方登陆使得他能顺利访问完所有的空间站后回到他当初登陆的地方，他登陆后可以选择两个方向中的任意一个进行旅行。", "inputFormat": "第一行一个整数 $n$，代表空间站数量，所有空间站由 $1$ 至 $n$ 进行标号。\n\n之后 $n$ 行，每行两个整数 $p_i,d_i$，第 $i + 1$ 行描述了第 $i$ 号空间站的信息，其中 $p_i$ 表示该空间站可以补给的油量，$d_i$ 则指明了它到 $i+1$ 号空间站的距离，对于 $n$ 号空间站，$d_i$ 表示它和 $1$ 号空间站的距离。", "outputFormat": "输出 $n$ 行，每行一个字符串 `TAK` 或 `NIE`。\n\n若你认为在 $i$ 号空间站登陆是可行的，则需要在第 $i$ 行输出 `TAK`，否则输出 `NIE`。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，$3\\le n\\le10^6$，$p_i \\ge 0$，$d_i>0$，$\\sum d_i,\\sum p_i\\le2\\times10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2005] LOT-A Journey to Mars", "background": "Byteazar decided to travel to Mars to join a space station tour.", "description": "All space stations on Mars lie on a circle. Byteazar lands at one of the stations and then starts traveling around the circle.\n\nTravel consumes fuel: $1$ liter of fuel allows traveling $1$ meter. Each station provides a different amount of fuel.\n\nAt each station, Byteazar may take all the fuel available there (his fuel tank has no capacity limit). However, if at any moment he runs out of fuel while moving, the trip fails.\n\nByteazar needs to decide at which station to land so that he can successfully visit all stations and return to his starting station. After landing, he may choose either direction to travel.", "inputFormat": "The first line contains an integer $n$, the number of stations. The stations are numbered from $1$ to $n$.\n\nThen follow $n$ lines. Each of the next $n$ lines contains two integers $p_i, d_i$. The $(i + 1)$-th line describes station $i$, where $p_i$ is the amount of fuel available at station $i$, and $d_i$ is the distance from station $i$ to station $i + 1$. For station $n$, $d_i$ is the distance from station $n$ to station $1$.", "outputFormat": "Output $n$ lines, each containing the string `TAK` or `NIE`.\n\nIf landing at station $i$ is feasible, print `TAK` on line $i$; otherwise, print `NIE`.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $3 \\le n \\le 10^6$, $p_i \\ge 0$, $d_i > 0$, and $\\sum d_i, \\sum p_i \\le 2 \\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2005] LOT-A Journey to Mars", "background": "Byteazar 决定去火星参加一个空间站旅行。", "description": "火星的所有空间站都位于一个圆上，Byteazar 在其中一个空间站登陆然后开始绕圈旅行。  \n\n旅行需要耗费油料，一升油料只能跑 $1$ 米，每个空间站可以补给的油料都有所不同。 \n\nByteazar 每到一个空间站便可以把该空间站的油料全部拿走（他的油箱是没有容量限制的）。但是如果走到某个时候突然没油了那么旅行便失败了。\n\nByteazar 需要决定要在哪个地方登陆使得他能顺利访问完所有的空间站后回到他当初登陆的地方，他登陆后可以选择两个方向中的任意一个进行旅行。", "inputFormat": "第一行一个整数 $n$，代表空间站数量，所有空间站由 $1$ 至 $n$ 进行标号。\n\n之后 $n$ 行，每行两个整数 $p_i,d_i$，第 $i + 1$ 行描述了第 $i$ 号空间站的信息，其中 $p_i$ 表示该空间站可以补给的油量，$d_i$ 则指明了它到 $i+1$ 号空间站的距离，对于 $n$ 号空间站，$d_i$ 表示它和 $1$ 号空间站的距离。", "outputFormat": "输出 $n$ 行，每行一个字符串 `TAK` 或 `NIE`。\n\n若你认为在 $i$ 号空间站登陆是可行的，则需要在第 $i$ 行输出 `TAK`，否则输出 `NIE`。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，$3\\le n\\le10^6$，$p_i \\ge 0$，$d_i>0$，$\\sum d_i,\\sum p_i\\le2\\times10^9$。", "locale": "zh-CN"}}}
{"pid": "P3423", "type": "P", "difficulty": 4, "samples": [["3\n2 3 5\n2 2 1\n10", "3\n1 1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["动态规划 DP", "2005", "POI（波兰）", "Special Judge"], "title": "[POI 2005] BAN-Bank Notes", "background": "", "description": "`Byteotian Bit Bank(BBB)` 拥有一套先进的货币系统，这个系统一共有 $n$ 种面值的硬币，面值分别为 $b_1,b_2,\\cdots,b_n$。但是每种硬币有数量限制，现在我们想要凑出面值 $k$，求最少要用多少个硬币。数据保证 $k$ 可以被凑出。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数 $b_i$，表示这 $n$ 种硬币的面值。\n\n第三行 $n$ 个整数 $c_i$，表示这 $n$ 种硬币的数量。\n\n第四行一个整数 $k$。", "outputFormat": "第一行一个整数，表示最少需要多少个硬币。\n\n第二行 $n$ 个整数，表示第 $i$ 种硬币需要多少个。\n\n如果有多种方案，输出其中一种即可。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 200$，$1 \\le b_1 < b_2 < \\cdots < b_n \\le 2 \\times 10^4$，$1 \\le c_i \\le 2 \\times 10^4$，$1 \\le k \\le 2 \\times 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2005] BAN-Bank Notes", "background": "", "description": "`Byteotian Bit Bank(BBB)` has an advanced currency system. There are $n$ coin denominations with values $b_1, b_2, \\cdots, b_n$. However, each coin has a limited quantity. Now we want to make a total value of $k$. Find the minimum number of coins needed. It is guaranteed that $k$ can be formed.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n$ integers $b_i$, the denominations of these $n$ types of coins.\n\nThe third line contains $n$ integers $c_i$, the quantity of each of these $n$ types of coins.\n\nThe fourth line contains an integer $k$.", "outputFormat": "The first line contains an integer, the minimum number of coins required.\n\nThe second line contains $n$ integers, where the $i$-th number is how many coins of type $i$ are used.\n\nIf there are multiple solutions, output any one of them.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 200$, $1 \\le b_1 < b_2 < \\cdots < b_n \\le 2 \\times 10^4$, $1 \\le c_i \\le 2 \\times 10^4$, $1 \\le k \\le 2 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2005] BAN-Bank Notes", "background": "", "description": "`Byteotian Bit Bank(BBB)` 拥有一套先进的货币系统，这个系统一共有 $n$ 种面值的硬币，面值分别为 $b_1,b_2,\\cdots,b_n$。但是每种硬币有数量限制，现在我们想要凑出面值 $k$，求最少要用多少个硬币。数据保证 $k$ 可以被凑出。", "inputFormat": "第一行一个整数 $n$。\n\n第二行 $n$ 个整数 $b_i$，表示这 $n$ 种硬币的面值。\n\n第三行 $n$ 个整数 $c_i$，表示这 $n$ 种硬币的数量。\n\n第四行一个整数 $k$。", "outputFormat": "第一行一个整数，表示最少需要多少个硬币。\n\n第二行 $n$ 个整数，表示第 $i$ 种硬币需要多少个。\n\n如果有多种方案，输出其中一种即可。", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 200$，$1 \\le b_1 < b_2 < \\cdots < b_n \\le 2 \\times 10^4$，$1 \\le c_i \\le 2 \\times 10^4$，$1 \\le k \\le 2 \\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P3424", "type": "P", "difficulty": 5, "samples": [["4 0 1 0 1\n5 0 1 0 0 1", "6 1 0 1 0 0 1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2005", "POI（波兰）", "Fibonacci 数列"], "title": "[POI 2005] SUM-Fibonacci Sums", "background": "", "description": "Fibonacci numbers are an integer sequence defined in the following way: $Fib_0=1$, $Fib_1=1$, $Fib_i=Fib_{i-1}+Fib_{i-2}$ (for $i\\ge 2$). The first few numbers in this sequence are: ($1,1,2,3,5,8,\\cdots$).\n\nThe great computer scientist Byteazar is constructing an unusual computer, in which numbers are represented in Fibonacci system i.e. a bit string $(b_1,b_2,\\cdots,b_n)$ denotes the number $b_1\\cdot Fib_1+b_2\\cdot Fib_2+\\cdots+b_n\\cdot Fib_n$. (Note that we do not use $Fib_0$.) Unfortunately, such a representation is ambiguous i.e. the same number can have different representations. The number $42$, for instance, can be written as: $(0,0,0,0,1,0,0,1)$, $(0,0,0,0,1,1,1,0)$ or $(1,1,0,1,0,1,1)$. For this very reason, Byteazar has limited himself to only using representations satisfying the following conditions:\n\nif $n>1$, then $b_n=1$, i.e. the representation of a number does not contain leading zeros.\n\nif $b_i=1$, then $b_{i+1}=0$ (for $i=1,\\cdots,n-1$), i.e. the representation of a number does not contain two (or more) consecutive ones.\n\nThe construction of the computer has proved more demanding than Byteazar supposed. He has difficulties implementing addition. Help him!\n\nTaskWrite a programme which:\n\nreads from the standard input the representations of two positive integers,calculates and writes to the standard output the representation of their sum.", "inputFormat": "The input contains the Fibonacci representations (satisfying the aforementioned conditions) of two positive integers $x$ and $y$ - one in the first, the other in the second line. Each of these representations is in the form of a sequence of non-negative integers, separated by single spaces. The first number in the line denotes the length of the representation $n$, $1\\le n\\le 1\\ 000\\ 000$. It is followed by $n$ zeros and/or ones.\n", "outputFormat": "In the first and only line of the output your programme should write the Fibonacci representation (satisfying the aforementioned conditions) of the sum $x+y$. The representation should be in the form of a sequence of non-negative integers, separated by single spaces, as it has been described in the Input section. The first number in the line denotes the length of the representation $n$, $1\\le n\\le 1\\ 000\\ 000$. It is followed by $n$ zeros and/or ones.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2005] SUM-Fibonacci Sums", "background": "", "description": "Fibonacci numbers are an integer sequence defined in the following way: $Fib_0=1$, $Fib_1=1$, $Fib_i=Fib_{i-1}+Fib_{i-2}$ (for $i\\ge 2$). The first few numbers in this sequence are: ($1,1,2,3,5,8,\\cdots$).\n\nThe great computer scientist Byteazar is constructing an unusual computer, in which numbers are represented in Fibonacci system i.e. a bit string $(b_1,b_2,\\cdots,b_n)$ denotes the number $b_1\\cdot Fib_1+b_2\\cdot Fib_2+\\cdots+b_n\\cdot Fib_n$. (Note that we do not use $Fib_0$.) Unfortunately, such a representation is ambiguous i.e. the same number can have different representations. The number $42$, for instance, can be written as: $(0,0,0,0,1,0,0,1)$, $(0,0,0,0,1,1,1,0)$ or $(1,1,0,1,0,1,1)$. For this very reason, Byteazar has limited himself to only using representations satisfying the following conditions:\n\nif $n>1$, then $b_n=1$, i.e. the representation of a number does not contain leading zeros.\n\nif $b_i=1$, then $b_{i+1}=0$ (for $i=1,\\cdots,n-1$), i.e. the representation of a number does not contain two (or more) consecutive ones.\n\nThe construction of the computer has proved more demanding than Byteazar supposed. He has difficulties implementing addition. Help him!\n\nTaskWrite a programme which:\n\nreads from the standard input the representations of two positive integers,calculates and writes to the standard output the representation of their sum.", "inputFormat": "The input contains the Fibonacci representations (satisfying the aforementioned conditions) of two positive integers $x$ and $y$ - one in the first, the other in the second line. Each of these representations is in the form of a sequence of non-negative integers, separated by single spaces. The first number in the line denotes the length of the representation $n$, $1\\le n\\le 1\\ 000\\ 000$. It is followed by $n$ zeros and/or ones.\n", "outputFormat": "In the first and only line of the output your programme should write the Fibonacci representation (satisfying the aforementioned conditions) of the sum $x+y$. The representation should be in the form of a sequence of non-negative integers, separated by single spaces, as it has been described in the Input section. The first number in the line denotes the length of the representation $n$, $1\\le n\\le 1\\ 000\\ 000$. It is followed by $n$ zeros and/or ones.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2005] SUM-Fibonacci Sums", "background": null, "description": "斐波那契数是一个这样定义的整数：$F(0)=1$，$F(1)=1$，$F(i)=F(i-1)+F(i-2)$  $(i>=2)$，前几个数是这样的 $1, 1, 2, 3, 5, 8, \\ldots$ \n\n伟大的计算机学家 $\\texttt{Byteazar}$ 正在做一个非凡的计算机，其中的数由斐波那契表示！\n\n如一个数列 $b_1, b_2, \\ldots , b_n$ 表示数字 $F(1) \\times b_1+b_2 \\times F(2)+ \\ldots +b_n \\times F(n)$（不使用 $F(0)$ ）。\n\n不幸的是，这样的表示并不明确，即相同的数字可以有不同的表示。比如 $42$ 可以表示为 $(0,0,0,0,1,0,0,1)$，$(0,0,0,0,1,1,1,0)$ 或 $(1,1,0,1,0,1,1)$，于是  $\\texttt{Byteazar}$ 加了一个限制：\n\n- 如果 $n>1$，那么$b_n=1$，即数字的表示不包含前导零。\n- 如果 $b_i=1$，那么 $b_{i+1}=0$，即数字的表示不包含两个（或多个）连续的数字。\n\n这个计算机的建设比  $\\texttt{Byteazar}$ 所认为的要难，现在请你来帮帮他~。\n\n你需要写一个程序：\n\n读取两个正整数的表示，计算并向标准输出写入其和的表示。", "inputFormat": "输入的第一行先是一个正整数 $n$，为 $x$ 的斐波那契表示的长度，接下来的序列是 $x$ 的斐波那契表示。\n\n第二行的第一个数字是一个正整数 $m$，为 $y$ 的斐波那契表示的长度，接下来的序列是 $y$ 的斐波那契表示。", "outputFormat": "输出只有一行程序，应写入 $x+y$ 的和的斐波纳契表示（满足上述条件），同样是先输出一个正整数 $n$ ，表示 $x+y$ 的和的斐波纳契表示的长度，然后再输出 $x+y$ 的和的斐波那契表示。\n\n$1\\leq n,m \\leq 10^6$。\n\n感谢@codesonic 提供的翻译", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3425", "type": "P", "difficulty": 6, "samples": [["4 4\n1 2\n1 3\n1 4\n1 2", "1\n0\n0\n0\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "二分", "POI（波兰）", "网络流", "Special Judge"], "title": "[POI 2005] KOS-Dicing", "background": null, "description": "掷骰子是一种双人游戏，它的结果是完全随机的。最近它在整个 Byteotia 变得非常流行。在 Byteotia 的首都甚至有一个特别的掷骰子业余爱好者俱乐部。俱乐部的老主顾们花时间互相聊天并每隔一阵子就和一个随机选择的对手玩这他们最喜欢的游戏。一天中赢得最多游戏的人会得到“幸运者”头衔。有时晚上俱乐部很安静，只有很少的比赛。这是哪怕赢一场也能获得“幸运者”头衔的时间。\n\n很久很久以前有一个很不走运的人，叫 Byteasar，赢得了这个光荣的头衔。他被深深地震惊了以至于完全忘了他已经赢了多少场。现在他想知道他有多幸运，以及幸运之神是否最终会向他微笑——也许他的运气会变好？他确切地知道在那个幸运的晚上有多少场游戏以及是谁玩的。然而，他不知道结果。Byteasar 希望查明至少要赢几场才能获得“幸运者”头衔。做个好人，帮他满足他的好奇心吧！\n\n- - -\n\n写一个程序：\n\n对于每场游戏读入这场游戏的一对玩家。\n\n找到最小的数 $k$，使得存在一个游戏结果的集合，其中赢最多的玩家赢了 $k$ 场。\n\n输出数 $k$ 和找到的集合中游戏的结果。\n\n玩家从 $1$ 到 $n$ 编号。", "inputFormat": "第一行有两个整数 $n,m$（$1\\le n,m\\le 10^4$）。$n$ 表示玩家数，$m$ 表示游戏数。由一个空格分开。\n\n接下来的 $m$ 行，第 $i$ 行表示第 $i$ 场游戏的玩家编号 $(a_i,b_i)$，由一个空格分开。\n\n一对玩家可能会在这个序列中多次出现。", "outputFormat": "第一行应该包含一个确定的数 $k$。\n\n对于在输入的第 $i$ 行指定的一对玩家 $(a_i,b_i)$，如果在找到的结果集合中 $a_i$ 胜过 $b_i$，则在输出的第 $i$ 行输出 `1`, 否则输出 `0`。", "hint": "$1\\le n,m\\le 10^4$。\n\n样例：\n\n![](https://szkopul.edu.pl/problemset/problem/8OrJo8TOlY9pynt7Tr9jMzzW/site/images/OI12/koszad-img2.gif)", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2005] KOS-Dicing", "background": null, "description": "Dicing is a two-player game and its outcome is fully random. Lately its popularity increases all over Byteotia. There is even a special club for dicing amateurs in the capital city of Byteotia. The club patrons take their time talking to each other and playing their favourite game with a randomly chosen opponent every once in a while. Everyone who wins the most games one day gains the title of the lucky chap. Sometimes it happens that the night at the club is a quiet one and only few games are played. It is a time when even one win can make you a lucky chap.\n\nOnce upon a time a most unlucky fellow, Byteasar, won the glorious title. He was so deeply shocked that he completely forgot how many games he had won. Now he is wondering how good his luck was and whether fortune finally smiled upon him - perhaps his luck changed for good? He knows exactly how many games and between whom were played that lucky night. However, he does not know the results. Byteasar desires to find out what is the smallest number of wins that could provide the title of the lucky chap. Be a good fellow and help him satisfy his curiosity!\n\n- - -\n\nWrite a programme that:\n\nFor each game played reads from the standard input the pair of players who competed in it.\n\nFinds the smallest number $k$, such that a set of games' outcomes exists in which each player wins $k$ games at the most,writes the number $k$ and the results of games in the found set to the standard output.", "inputFormat": "In the first line of the standard input there is a pair of integers $n$ and $m$ separated by a single space, $1\\le n\\le 10000$, $0\\le m\\le 10000$; $n$ denotes the number of players, while $m$ is the number of games. The players are numbered from $1$ to $n$. In the following $m$ lines there are pairs of players' numbers depicting the sequence of games, separated by single spaces. One pair may occur many times in the sequence.", "outputFormat": "The first line of the standard output should contain the determined number $k$. For each pair of players' numbers $a$, $b$ specified in the $i$'th line of the input, in the $i$'th line of the output the number $1$ should be written if the player no. $a$ wins against player no. $b$ in the found set of outcomes, or $0$ otherwise.", "hint": "![](https://szkopul.edu.pl/problemset/problem/8OrJo8TOlY9pynt7Tr9jMzzW/site/images/OI12/koszad-img2.gif)", "locale": "en"}, "zh-CN": {"title": "[POI 2005] KOS-Dicing", "background": null, "description": "掷骰子是一种双人游戏，它的结果是完全随机的。最近它在整个 Byteotia 变得非常流行。在 Byteotia 的首都甚至有一个特别的掷骰子业余爱好者俱乐部。俱乐部的老主顾们花时间互相聊天并每隔一阵子就和一个随机选择的对手玩这他们最喜欢的游戏。一天中赢得最多游戏的人会得到“幸运者”头衔。有时晚上俱乐部很安静，只有很少的比赛。这是哪怕赢一场也能获得“幸运者”头衔的时间。\n\n很久很久以前有一个很不走运的人，叫 Byteasar，赢得了这个光荣的头衔。他被深深地震惊了以至于完全忘了他已经赢了多少场。现在他想知道他有多幸运，以及幸运之神是否最终会向他微笑——也许他的运气会变好？他确切地知道在那个幸运的晚上有多少场游戏以及是谁玩的。然而，他不知道结果。Byteasar 希望查明至少要赢几场才能获得“幸运者”头衔。做个好人，帮他满足他的好奇心吧！\n\n- - -\n\n写一个程序：\n\n对于每场游戏读入这场游戏的一对玩家。\n\n找到最小的数 $k$，使得存在一个游戏结果的集合，其中赢最多的玩家赢了 $k$ 场。\n\n输出数 $k$ 和找到的集合中游戏的结果。\n\n玩家从 $1$ 到 $n$ 编号。", "inputFormat": "第一行有两个整数 $n,m$（$1\\le n,m\\le 10^4$）。$n$ 表示玩家数，$m$ 表示游戏数。由一个空格分开。\n\n接下来的 $m$ 行，第 $i$ 行表示第 $i$ 场游戏的玩家编号 $(a_i,b_i)$，由一个空格分开。\n\n一对玩家可能会在这个序列中多次出现。", "outputFormat": "第一行应该包含一个确定的数 $k$。\n\n对于在输入的第 $i$ 行指定的一对玩家 $(a_i,b_i)$，如果在找到的结果集合中 $a_i$ 胜过 $b_i$，则在输出的第 $i$ 行输出 `1`, 否则输出 `0`。", "hint": "$1\\le n,m\\le 10^4$。\n\n样例：\n\n![](https://szkopul.edu.pl/problemset/problem/8OrJo8TOlY9pynt7Tr9jMzzW/site/images/OI12/koszad-img2.gif)", "locale": "zh-CN"}}}
{"pid": "P3426", "type": "P", "difficulty": 6, "samples": [["ababbababbabababbabababbababbaba", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "树形数据结构", "2005", "POI（波兰）", "KMP 算法"], "title": "[POI 2005] SZA-Template", "background": "", "description": "你打算在纸上印一串字母。\n\n为了完成这项工作，你决定刻一个印章。印章每使用一次，就会将印章上的**所有**字母印到纸上。\n\n同一个位置的相同字符可以印多次。例如：用 `aba` 这个印章可以完成印制 `ababa` 的工作（中间的 `a` 被印了两次）。但是，因为印上去的东西不能被抹掉，在同一位置上印不同字符是不允许的。例如：用 `aba` 这个印章不可以完成印制 `abcba` 的工作。\n\n因为刻印章是一个不太容易的工作，你希望印章的字符串长度尽可能小。", "inputFormat": "输入一个长度不超过 $5 \\times 10^5$ 的非空字符串（只包含小写字母），代表要在纸上印的字符。", "outputFormat": "输出一个整数，代表印章上字符串长度的最小值。", "hint": "印章为 `ababbaba`。\n\n印制过程如下：\n\n```plain\nababbababbabababbabababbababbaba\nababbaba\n     ababbaba\n            ababbaba\n                   ababbaba\n                        ababbaba\n```", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2005] SZA-Template", "background": "", "description": "You plan to print a sequence of letters on paper.\n\nTo accomplish this, you decide to carve a stamp. Each use of the stamp prints **all** the letters on the stamp onto the paper.\n\nThe same character at the same position may be printed multiple times. For example: using the stamp `aba` can produce `ababa` (the middle `a` is printed twice). However, since what has been printed cannot be erased, printing different characters at the same position is not allowed. For example: using the stamp `aba` cannot produce `abcba`.\n\nBecause carving a stamp is not easy, you want the length of the stamp string to be as small as possible.", "inputFormat": "A non-empty string of length at most $5 \\times 10^5$ (containing only lowercase letters), representing the string you want to print on the paper.", "outputFormat": "Output a single integer, the minimal possible length of the stamp string.", "hint": "A stamp is `ababbaba`.\n\nThe printing process is as follows:\n```plain\nababbababbabababbabababbababbaba\nababbaba\n     ababbaba\n            ababbaba\n                   ababbaba\n                        ababbaba\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2005] SZA-Template", "background": "", "description": "你打算在纸上印一串字母。\n\n为了完成这项工作，你决定刻一个印章。印章每使用一次，就会将印章上的**所有**字母印到纸上。\n\n同一个位置的相同字符可以印多次。例如：用 `aba` 这个印章可以完成印制 `ababa` 的工作（中间的 `a` 被印了两次）。但是，因为印上去的东西不能被抹掉，在同一位置上印不同字符是不允许的。例如：用 `aba` 这个印章不可以完成印制 `abcba` 的工作。\n\n因为刻印章是一个不太容易的工作，你希望印章的字符串长度尽可能小。", "inputFormat": "输入一个长度不超过 $5 \\times 10^5$ 的非空字符串（只包含小写字母），代表要在纸上印的字符。", "outputFormat": "输出一个整数，代表印章上字符串长度的最小值。", "hint": "印章为 `ababbaba`。\n\n印制过程如下：\n\n```plain\nababbababbabababbabababbababbaba\nababbaba\n     ababbaba\n            ababbaba\n                   ababbaba\n                        ababbaba\n```", "locale": "zh-CN"}}}
{"pid": "P3427", "type": "P", "difficulty": 6, "samples": [["3 2 10\n1 2\n1 3", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2005", "POI（波兰）"], "title": "[POI 2005] DZI-Hollows", "background": "", "description": "在 Byteotia 有两棵非常高的树，而每一棵的树干上都被挖出了许多洞，高度各不相同。现在 $n$ 只可以飞得非常快的鸟决定住在这些洞里，它们中的一些互相认识因此它们想要访问认识的的鸟。鸟们飞得非常快，而且通常沿着一条直线走。为了避免在飞行中撞到别的鸟，它们决定找到某种居住的方式可以满足下面的条件：\n\n- 任何的鸟都可以访问它认识的鸟，而使访问的路线不与其他鸟访问的路线相交（但是可以有同一个终点）.\n\n此外，还要使每只鸟居住的高度尽量低，保证树洞比鸟多。\n\n我们都知道鸟的大脑很小，所以它们请你帮它们算一共有多少个方法可以满足以上条件，将答案模 $k$ 输出。", "inputFormat": "在标准输入流的第一行有三个整数 $n，m$ 和 $k$，分别表示鸟的数量，鸟的关系数取模数（$2\\le n\\le 1000000,1\\le m\\le 10000000,2\\le k\\le 2000000$）。鸟的编号是 $1$ 到 $n$。\n\n接下来 $m$ 行是鸟的认识关系，第 $i+1$ 行是两个数字 $a_i$和 $b_i$，用一个空格隔开。$1\\le a,b\\le n,a_i\\ne b_i$。每一对认识的鸟只给出一次。\n", "outputFormat": "设 $r$ 表示满足给定约束的鸟类的不同方案数。您的程序应该在标准输出的第一行中输出一个整数 $r\\bmod k$。如果没有方案，则正确的结果为 $0$。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2005] DZI-Hollows", "background": "# Description\n\nThere are two very tall trees in Byteotia, and many hollows have been carved into their trunks at different heights. Now $n$ very fast birds have decided to live in these hollows. Some birds know each other, so they want to visit the birds they know. The birds fly very fast, and they usually fly in straight lines. To avoid colliding in flight, they decide to choose a way to live that satisfies the following condition:\n- Every bird can visit each bird it knows, and the visiting routes do not intersect with the visiting routes of other birds (they may share endpoints).\n\nIn addition, we want each bird to live as low as possible in height, and it is guaranteed that there are more hollows than birds.\n\nWe all know that birds have small brains, so they ask you to count how many ways satisfy the above conditions and output the answer modulo $k$.", "description": "", "inputFormat": "", "outputFormat": "Let $r$ be the number of different arrangements of the birds that satisfy the given constraints. Your program should print a single integer $r \\bmod k$ on the first line of the standard output. If there is no valid arrangement, the correct output is $0$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2005] DZI-Hollows", "background": "", "description": "在 Byteotia 有两棵非常高的树，而每一棵的树干上都被挖出了许多洞，高度各不相同。现在 $n$ 只可以飞得非常快的鸟决定住在这些洞里，它们中的一些互相认识因此它们想要访问认识的的鸟。鸟们飞得非常快，而且通常沿着一条直线走。为了避免在飞行中撞到别的鸟，它们决定找到某种居住的方式可以满足下面的条件：\n\n- 任何的鸟都可以访问它认识的鸟，而使访问的路线不与其他鸟访问的路线相交（但是可以有同一个终点）.\n\n此外，还要使每只鸟居住的高度尽量低，保证树洞比鸟多。\n\n我们都知道鸟的大脑很小，所以它们请你帮它们算一共有多少个方法可以满足以上条件，将答案模 $k$ 输出。", "inputFormat": "在标准输入流的第一行有三个整数 $n，m$ 和 $k$，分别表示鸟的数量，鸟的关系数取模数（$2\\le n\\le 1000000,1\\le m\\le 10000000,2\\le k\\le 2000000$）。鸟的编号是 $1$ 到 $n$。\n\n接下来 $m$ 行是鸟的认识关系，第 $i+1$ 行是两个数字 $a_i$和 $b_i$，用一个空格隔开。$1\\le a,b\\le n,a_i\\ne b_i$。每一对认识的鸟只给出一次。\n", "outputFormat": "设 $r$ 表示满足给定约束的鸟类的不同方案数。您的程序应该在标准输出的第一行中输出一个整数 $r\\bmod k$。如果没有方案，则正确的结果为 $0$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3428", "type": "P", "difficulty": 6, "samples": [["5\n2 2 4\n7 2 3\n4 3 1\n5 7 1\n8 7 1", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["计算几何", "2005", "POI（波兰）"], "title": "[POI 2005] AKC-Special Forces Manoeuvres", "background": "", "description": "一个秘密组织正在沙漠中举行一次军事演习。本次演习的目标是拆除隐藏在沙漠中的一个炸弹。\n\n演习的第一部分是空降作战。每个士兵**按照一定的顺序**从悬停在沙漠上空的直升机上跳下。着陆时，每个士兵都会停在他所在的着陆点。\n\n每个空降兵都有一个生存半径。如果炸弹与他的距离小于或等于这个生存半径的话，空降兵便会牺牲自己引爆炸弹。指挥官希望能派出尽可能少的士兵，但他希望在**最坏情况下**至少有一个士兵能够生还。\n\n整个沙漠可以抽象为一个平面，每个士兵的着陆点可以用一个坐标 $(x,y)$ 表示，他的生存半径我们设为 $r$。所有士兵的信息按照他们跳伞时的顺序给出，即第 $i$ 个士兵跳伞时，前 $i-1$ 个士兵都已经着陆。\n\n你的任务是：从标准输入读入所有士兵的信息，输出最少需要派出的士兵数量。", "inputFormat": "第一行一个整数 $n\\,(2\\le n \\le 2000)$。\n\n接下来 $n$ 行，第 $i$ 行包含三个整数 $x_i,y_i,r_i\\,(-1000\\le x_i,y_i\\le 1000,1\\le r\\le 5000)$，代表第 $i$ 个士兵的着陆坐标为 $(x_i,y_i)$，生存半径为 $r_i$。", "outputFormat": "如果无法让至少一个士兵生还的话，输出 `NIE`。\n\n否则输出一个整数，代表至少需要派出的士兵数量。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/8xbga77o.png)\n\n最坏情况下炸弹位于 $(5,3)$，前三个士兵都会被炸死，第四个士兵会生还。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2005] AKC-Special Forces Manoeuvres", "background": "", "description": "A secret organization is conducting a military exercise in the desert. The goal is to defuse a bomb hidden in the desert.\n\nThe first phase is an airdrop operation. Each paratrooper jumps from a helicopter hovering over the desert in a fixed order. Upon landing, each paratrooper stays at his landing point.\n\nEach paratrooper has a survival radius. If the bomb is at a distance less than or equal to this survival radius, the paratrooper will sacrifice himself to trigger the bomb. The commander wants to send as few paratroopers as possible, but he also wants at least one paratrooper to survive in the worst case.\n\nThe entire desert can be modeled as a plane. Each paratrooper’s landing point is a coordinate $(x, y)$, and we denote his survival radius by $r$. All paratroopers’ information is given in the order they jump: when the $i$-th paratrooper jumps, the first $i-1$ paratroopers have already landed.\n\nYour task is to read all paratroopers’ information from standard input and output the minimum number of paratroopers that must be sent.", "inputFormat": "The first line contains an integer $n$ ($2 \\le n \\le 2000$).\n\nThe next $n$ lines: the $i$-th line contains three integers $x_i, y_i, r_i$ ($-1000 \\le x_i, y_i \\le 1000$, $1 \\le r_i \\le 5000$), indicating that the $i$-th paratrooper lands at $(x_i, y_i)$ with survival radius $r_i$.", "outputFormat": "If it is impossible to have at least one paratrooper survive, output `NIE`.\n\nOtherwise, output a single integer: the minimum number of paratroopers that must be sent.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/8xbga77o.png)\n\nIn the worst case, the bomb is at $(5, 3)$. The first three paratroopers die, and the fourth survives.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2005] AKC-Special Forces Manoeuvres", "background": "", "description": "一个秘密组织正在沙漠中举行一次军事演习。本次演习的目标是拆除隐藏在沙漠中的一个炸弹。\n\n演习的第一部分是空降作战。每个士兵**按照一定的顺序**从悬停在沙漠上空的直升机上跳下。着陆时，每个士兵都会停在他所在的着陆点。\n\n每个空降兵都有一个生存半径。如果炸弹与他的距离小于或等于这个生存半径的话，空降兵便会牺牲自己引爆炸弹。指挥官希望能派出尽可能少的士兵，但他希望在**最坏情况下**至少有一个士兵能够生还。\n\n整个沙漠可以抽象为一个平面，每个士兵的着陆点可以用一个坐标 $(x,y)$ 表示，他的生存半径我们设为 $r$。所有士兵的信息按照他们跳伞时的顺序给出，即第 $i$ 个士兵跳伞时，前 $i-1$ 个士兵都已经着陆。\n\n你的任务是：从标准输入读入所有士兵的信息，输出最少需要派出的士兵数量。", "inputFormat": "第一行一个整数 $n\\,(2\\le n \\le 2000)$。\n\n接下来 $n$ 行，第 $i$ 行包含三个整数 $x_i,y_i,r_i\\,(-1000\\le x_i,y_i\\le 1000,1\\le r\\le 5000)$，代表第 $i$ 个士兵的着陆坐标为 $(x_i,y_i)$，生存半径为 $r_i$。", "outputFormat": "如果无法让至少一个士兵生还的话，输出 `NIE`。\n\n否则输出一个整数，代表至少需要派出的士兵数量。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/8xbga77o.png)\n\n最坏情况下炸弹位于 $(5,3)$，前三个士兵都会被炸死，第四个士兵会生还。", "locale": "zh-CN"}}}
{"pid": "P3429", "type": "P", "difficulty": 6, "samples": [["5\n3 2 3 4\n2 1 3\n4 2 1 4 5\n2 1 3\n1 3", "3\n1 2 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "POI（波兰）", "Special Judge", "高斯消元"], "title": "[POI 2005] DWA-Two Parties", "background": null, "description": "拜占庭国王要举办两个大派对，并且希望邀请更多的居民。\n\n国王从他的丰富经验里知道，如果一个居民在派对上能遇到偶数个的朋友，那他会非常高兴。因此，他要求你邀请国家的居民去两个派对，而使尽可能多的人在他们的聚会上有偶数个的朋友。\n\n认识是一种对称关系，如 $A$ 认识 $B$，那么 $B$ 也认识 $A$。", "inputFormat": "共 $N+1$ 行。\n\n第一行读入一个整数 $N$（$1\\le N\\le 200$），表示居民的数量。\n\n接下来 $N$ 行，第 $i+1$ 行是一个整数 $l_i$，表示第 $i$ 个居民的朋友数量，接着是 $l_i$ 个数，为第 $i$ 个居民的朋友编号。我们假设没有人是自己的朋友。如果 $B$ 出现在了 $A$ 的朋友列表中，那么 $A$ 也会出现在$B$ 的列表中。", "outputFormat": "第一行是一个整数 $M$，是前往第一个派对的人数。第二行 $M$ 个整数，是去第一个派对的居民编号，其余的居民前往第二个派对。\n\n如果有多种答案，你只需要输出一个。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[POI 2005] DWA-Two Parties", "background": "", "description": "The Byzantine king is going to host two large parties and hopes to invite more residents.\n\nFrom his rich experience, the king knows that if a resident meets an even number of friends at the party, they will be very happy. Therefore, he asks you to assign the country's residents to two parties so that as many people as possible have an even number of friends at the party they attend.\n\nAcquaintance is a symmetric relation: if $A$ knows $B$, then $B$ also knows $A$.", "inputFormat": "There are $N+1$ lines in total.\n\nThe first line contains an integer $N$ ($1 \\le N \\le 200$), the number of residents.\n\nIn the next $N$ lines, the $(i+1)$-th line contains an integer $l_i$, the number of friends of the $i$-th resident, followed by $l_i$ integers, which are the indices of the $i$-th resident’s friends. We assume no one is their own friend. If $B$ appears in $A$’s friend list, then $A$ also appears in $B$’s list.", "outputFormat": "The first line contains an integer $M$, the number of people attending the first party. The second line contains $M$ integers, which are the indices of the residents going to the first party; the remaining residents go to the second party.\n\nIf there are multiple valid answers, output any one of them.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2005] DWA-Two Parties", "background": null, "description": "拜占庭国王要举办两个大派对，并且希望邀请更多的居民。\n\n国王从他的丰富经验里知道，如果一个居民在派对上能遇到偶数个的朋友，那他会非常高兴。因此，他要求你邀请国家的居民去两个派对，而使尽可能多的人在他们的聚会上有偶数个的朋友。\n\n认识是一种对称关系，如 $A$ 认识 $B$，那么 $B$ 也认识 $A$。", "inputFormat": "共 $N+1$ 行。\n\n第一行读入一个整数 $N$（$1\\le N\\le 200$），表示居民的数量。\n\n接下来 $N$ 行，第 $i+1$ 行是一个整数 $l_i$，表示第 $i$ 个居民的朋友数量，接着是 $l_i$ 个数，为第 $i$ 个居民的朋友编号。我们假设没有人是自己的朋友。如果 $B$ 出现在了 $A$ 的朋友列表中，那么 $A$ 也会出现在$B$ 的列表中。", "outputFormat": "第一行是一个整数 $M$，是前往第一个派对的人数。第二行 $M$ 个整数，是去第一个派对的居民编号，其余的居民前往第二个派对。\n\n如果有多种答案，你只需要输出一个。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3430", "type": "P", "difficulty": 5, "samples": [["9\n2 5 5 2 7 4 7 3 9\n1 6 8 4 6 3 9 1 8", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "POI（波兰）"], "title": "[POI 2005] DWU-Double-row", "background": "", "description": "$2n$ soldiers are standing in a double-row. They have to be rearranged, so that there are no equally tall soldiers in each row - then we shall say, that the soldiers are set up properly.\n\nA single operation consists in swapping two soldiers who occupy the same position (but in different rows). Your task is to determine the minimum number of swaps necessary to set the soldiers up properly.\n\nExample:\n\nThere is a double-row of $18$ soldiers in the figure. Arrows indicate the swaps that rearrange the soldiers in a proper way.\n\nTaskWrite a programme that:\n\nreads from the standard input the number and heights of soldiers, as they stand initially,determines the minimum number of swaps (of soldiers standing on the same position in different rows) necessary to set up soldiers properly,writes the result to the standard output.\n\n\n**一句话题意By Scarlet：$2n$个数站成两排（每个数在$2n$个数中最多出现两遍），一次操作可以交换任意一列中两个数，求使每行数不重复的最少操作数。**\n", "inputFormat": "In the first line of the input there is one integer $n$, $1\\le n\\le 50\\ 000$. In each of the two rows there are $n$ soldiers standing. In each of the following two lines there are $n$ positive integers separated by single spaces. In the second line there are numbers $x_1,x_2,\\cdots,x_n$, $1\\le x_i\\le 100\\ 000$; $x_i$ denotes the height of the $i$'th soldier in the first line. In the third line there are numbers $y_1,y_2,\\cdots,y_n$, $1\\le y_i\\le 100\\ 000$; $y_i$ denotes the height of the $i$'th soldier in the second line.\n\nIt is guaranteed that in the instances from the test data it is possible to set up soldiers properly.\n", "outputFormat": "In the first and only line of the standard output one integer should be written - the minimum number of swaps necessary to set up soldiers properly.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2005] DWU-Double-row", "background": "", "description": "$2n$ soldiers are standing in a double-row. They have to be rearranged, so that there are no equally tall soldiers in each row - then we shall say, that the soldiers are set up properly.\n\nA single operation consists in swapping two soldiers who occupy the same position (but in different rows). Your task is to determine the minimum number of swaps necessary to set the soldiers up properly.\n\nExample:\n\nThere is a double-row of $18$ soldiers in the figure. Arrows indicate the swaps that rearrange the soldiers in a proper way.\n\nTaskWrite a programme that:\n\nreads from the standard input the number and heights of soldiers, as they stand initially,determines the minimum number of swaps (of soldiers standing on the same position in different rows) necessary to set up soldiers properly,writes the result to the standard output.\n\n\n**一句话题意By Scarlet：$2n$个数站成两排（每个数在$2n$个数中最多出现两遍），一次操作可以交换任意一列中两个数，求使每行数不重复的最少操作数。**\n", "inputFormat": "In the first line of the input there is one integer $n$, $1\\le n\\le 50\\ 000$. In each of the two rows there are $n$ soldiers standing. In each of the following two lines there are $n$ positive integers separated by single spaces. In the second line there are numbers $x_1,x_2,\\cdots,x_n$, $1\\le x_i\\le 100\\ 000$; $x_i$ denotes the height of the $i$'th soldier in the first line. In the third line there are numbers $y_1,y_2,\\cdots,y_n$, $1\\le y_i\\le 100\\ 000$; $y_i$ denotes the height of the $i$'th soldier in the second line.\n\nIt is guaranteed that in the instances from the test data it is possible to set up soldiers properly.\n", "outputFormat": "In the first and only line of the standard output one integer should be written - the minimum number of swaps necessary to set up soldiers properly.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2005] DWU-Double-row", "background": null, "description": "有 $2n$ 个士兵站成两排，他们需要被重新排列，以保证每一排里没有同样高的士兵——这样我们就说，士兵们被合理地安排了位置。 每次操作可以交换两个在同一位置（但不在同一排）的士兵。你的任务是用最少的操作来确保士兵们被合理地安排了位置。 \n\n例如：有 $18$ 个士兵站成两排，箭头标明了重新安排士兵位置的正确方式。\n![](https://cdn.luogu.org/upload/pic/14829.png)\n\n写一个这样的程序： 读入 $n$ 与士兵的身高，以及他们最初所站的位置，确保以最小的交换（站在同一位置的不同排的士兵）的次数来合理地安排士兵的位置，输出操作数。", "inputFormat": "第一行，一个整数 $n$（$1 \\le n \\le 5 \\times {10}^4$）。\n\n第二行有 $n$ 个正整数 $x_1,x_2,\\ldots,x_n$（$1 \\le x_i \\le {10}^5$），表示第一行中士兵的身高。 \n\n第三行有 $n$ 个正整数 $y_1,y_2,\\ldots,y_n$（$1 \\le y_i \\le {10}^5$），表示第二行中士兵的身高。\n\n数据保证你能够合理地安排士兵的位置（即每个数在 $2n$ 个数中最多出现两次）。", "outputFormat": "输出一行一个正整数，表示最少需要操作的次数。\n\n翻译贡献者UID：57699", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3431", "type": "P", "difficulty": 5, "samples": [["8 7 11\n4 3 4\n6 2 4\n2 3 2\n5 6 1\n2 5 2\n1 5 5\n2 1 1\n3 1 1\n7 7 1\n7 4 2\n8 6 2", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2005", "树状数组", "POI（波兰）", "离散化", "扫描线"], "title": "[POI 2005] AUT-The Bus", "background": "", "description": "The streets of Byte City form a regular, chessboardlike network - they are either north-south or west-east directed. We shall call them NS- and WE-streets. Furthermore, each street crosses the whole city. Every NS-street intersects every WE- one and vice versa. The NS-streets are numbered from $1$ to $n$, starting from the westernmost. The WE-streets are numbered from $1$ to $m$, beginning with the southernmost. Each intersection of the $i$'th NS-street with the $j$'th WE-street is denoted by a pair of numbers $(i,j)$ (for $1\\le i\\le n$, $1\\le j\\le m$).\n\nThere is a bus line in Byte City, with intersections serving as bus stops. The bus begins its itinerary by the $(1,1)$ intersection, and finishes by the $(n,m)$ intersection. Moreover, the bus may only travel in the eastern and/or northern direction.\n\nThere are passengers awaiting the bus by some of the intersections. The bus driver wants to choose his route in a way that allows him to take as many of them as possible. (We shall make an assumption that the interior of the bus is spacious enough to take all of the awaiting passengers, regardless of the route chosen.)TaskWrite a programme which:\n\nreads from the standard input a description of the road network and the number of passengers waiting at each intersection,finds, how many passengers the bus can take at the most,writes the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains three positive integers $n$, $m$ and $k$ - denoting the number of NS-streets, the number of WE-streets and the number of intersections by which the passengers await the bus, respectively ($1\\le n\\le 10^9$, $1\\le m\\le 10^9$, $1\\le k\\le 10^5$).\n\nThe following $k$ lines describe the deployment of passengers awaiting the bus, a single line per intersection. In the $(i+1)$'st line there are three positive integers $x_i$, $y_i$ and $p_i$, separated by single spaces, $1\\le x_i\\le n$,$1\\le y_i\\le m$,$1\\le p_i\\le 10^6$ . A triplet of this form signifies that by the intersection$(x_i,y_i)p_i$ passengers await the bus. Each intersection is described in the input data once at the most. The total number of passengers waiting for the bus does not exceed $1\\ 000\\ 000\\ 000$.\n", "outputFormat": "Your programme should write to the standard output one line containing a single integer - the greatest number of passengers the bus can take.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2005] AUT-The Bus", "background": "", "description": "The streets of Byte City form a regular, chessboardlike network - they are either north-south or west-east directed. We shall call them NS- and WE-streets. Furthermore, each street crosses the whole city. Every NS-street intersects every WE- one and vice versa. The NS-streets are numbered from $1$ to $n$, starting from the westernmost. The WE-streets are numbered from $1$ to $m$, beginning with the southernmost. Each intersection of the $i$'th NS-street with the $j$'th WE-street is denoted by a pair of numbers $(i,j)$ (for $1\\le i\\le n$, $1\\le j\\le m$).\n\nThere is a bus line in Byte City, with intersections serving as bus stops. The bus begins its itinerary by the $(1,1)$ intersection, and finishes by the $(n,m)$ intersection. Moreover, the bus may only travel in the eastern and/or northern direction.\n\nThere are passengers awaiting the bus by some of the intersections. The bus driver wants to choose his route in a way that allows him to take as many of them as possible. (We shall make an assumption that the interior of the bus is spacious enough to take all of the awaiting passengers, regardless of the route chosen.)TaskWrite a programme which:\n\nreads from the standard input a description of the road network and the number of passengers waiting at each intersection,finds, how many passengers the bus can take at the most,writes the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains three positive integers $n$, $m$ and $k$ - denoting the number of NS-streets, the number of WE-streets and the number of intersections by which the passengers await the bus, respectively ($1\\le n\\le 10^9$, $1\\le m\\le 10^9$, $1\\le k\\le 10^5$).\n\nThe following $k$ lines describe the deployment of passengers awaiting the bus, a single line per intersection. In the $(i+1)$'st line there are three positive integers $x_i$, $y_i$ and $p_i$, separated by single spaces, $1\\le x_i\\le n$,$1\\le y_i\\le m$,$1\\le p_i\\le 10^6$ . A triplet of this form signifies that by the intersection$(x_i,y_i)p_i$ passengers await the bus. Each intersection is described in the input data once at the most. The total number of passengers waiting for the bus does not exceed $1\\ 000\\ 000\\ 000$.\n", "outputFormat": "Your programme should write to the standard output one line containing a single integer - the greatest number of passengers the bus can take.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2005] AUT-The Bus", "background": "", "description": "字节市的街道形成了一个规则的棋盘状网络——它们要么是南北方向，要么是东西方向。我们称它们为 NS 街道和 WE 街道。此外，每条街道都贯穿整个城市。每条 NS 街道与每条 WE 街道相交，反之亦然。NS 街道从最西边开始编号，从 $1$ 到 $n$。WE 街道从最南边开始编号，从 $1$ 到 $m$。每条第 $i$ 条 NS 街道与第 $j$ 条 WE 街道的交点用一对数字 $(i,j)$ 表示（$1\\le i\\le n$，$1\\le j\\le m$）。  字节市有一条公交线路，交叉点作为公交车站。公交车从 $(1,1)$ 交点开始行程，并在 $(n,m)$ 交点结束。此外，公交车只能向东和/或向北行驶。  在一些交叉点有乘客在等车。公交车司机希望选择一条路线，使他能够尽可能多地接到这些乘客。（我们假设公交车内部空间足够大，可以接收所有等待的乘客，无论选择哪条路线。）任务编写一个程序：  从标准输入读取道路网络的描述和每个交叉点等待的乘客人数，找到公交车最多能接到多少乘客，将结果写入标准输出。 ", "inputFormat": "标准输入的第一行包含三个正整数 $n$，$m$ 和 $k$——分别表示 NS 街道的数量、WE 街道的数量以及乘客等待公交车的交叉点数量（$1\\le n\\le 10^9$，$1\\le m\\le 10^9$，$1\\le k\\le 10^5$）。  接下来的 $k$ 行描述了乘客等待公交车的分布，每个交叉点一行。在第 $(i+1)$ 行有三个正整数 $x_i$，$y_i$ 和 $p_i$，用单个空格分隔，$1\\le x_i\\le n$，$1\\le y_i\\le m$，$1\\le p_i\\le 10^6$。这种形式的三元组表示在交叉点 $(x_i,y_i)$ 有 $p_i$ 名乘客在等待公交车。输入数据中每个交叉点最多描述一次。等待公交车的乘客总数不超过 $1\\ 000\\ 000\\ 000$。 ", "outputFormat": "你的程序应在标准输出中写出一行，包含一个整数——公交车可以接到的最多乘客数。 ", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3432", "type": "P", "difficulty": 6, "samples": [["2\n5 6 7\n5 6 6", "4 5 6\n4 6 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "POI（波兰）"], "title": "[POI 2005] LUS-Mirror Trap", "background": null, "description": "镜子陷阱是由镜子构成的长方体，镜子的反射面对着长方体的内部。在长方体的几何中心放入一个微型激光器（尺寸忽略）。现在我们的任务是把激光向某一个方向发射，并且使光束在回到激光器自身之前，通过的总距离尽可能长。通过的总距离表示为激光束在与镜子反射面平行的三个方向的距离之和，也就是曼哈顿（城市）度量。\n\n不同的侧面相遇的陷阱的边和顶点不会反射激光束，且陷阱的边长是整数。在长方形陷阱中，使用笛卡尔坐标系。坐标系的纵横轴分别平行于陷阱的长和宽，激光器的位置在原点。激光器可以瞄准陷阱内的任意一个点包括反射镜的表面上的点（唯一的例外就是激光器本身，点 $(0,0,0)$）。\n\n我们的任务：\n\n输入这个镜子陷阱的尺寸，通过编写的程序计算出一个点，即激光器指向这一点：这一束激光应在反射镜（但不一定是所有反射镜）反射，但是不与陷阱的边、顶点相交，最后需要回到激光器本身（不需要一定的方向）同时尽可能使得总距离长。", "inputFormat": "输入有多个陷阱。输入的第一行包含一个整数 $K(1 \\le K\\le 1000)$，表示要分析的陷阱数。 在 $2,3,\\dots,K + 1$ 行中，有一个陷阱的描述，每行一个。 陷阱的描述由三个用空格分隔的数字 $x,y,z(5 \\le x,y,z \\le 1000)$ 组成。镜面陷阱的尺寸为 $2x \\times 2y \\times 2z$。", "outputFormat": "输出 $K$ 行。第 $K$ 行应包含第 $K$ 个陷阱的解决方案，由空格分隔的 $3$ 个数 $x,y,z$，表示激光器需要瞄准的点的坐标。\n\n如果有多个不同的正确解决方案，则任意的输出一个。", "hint": "感谢@SLYZ\\_0120 提供翻译。", "locale": "zh-CN", "translations": {"en": {"title": "", "background": "", "description": "A mirror trap is a cuboid made of mirrors, the reflecting sides of which are facing the interior of the cuboid. Precisely in the geometric centre of the cuboid there is a miniature laser (whose dimensions we shall neglect). The task is to aim the laser in such a way that the beam travels the longest total distance possible and returns to the laser itself. By total distance we shall denote the sum of distances traveled by the laser beam in each of the three directions parallel to the edges of the mirrors (i.e. we are using the so called Manhattan (city) metric).\n\nThe dimensions of the trap are even integers. The edges and vertices of the trap, where distinct sides meet, do not reflect the laser beam. Inside the cuboid we shall introduce a cartesian coordinate system. Its axes are parallel to the edges of the trap and the laser shall be placed in the origin. The laser may be aimed at any integer point (a point whose all coordinates are integers) within the trap, the points on the surface of the mirrors included (with the single exception of the laser itself, i.e. the point $(0,0,0)$).\n\nTask\n\nWrite a programme which:\n\nreads from the standard input the dimensions of the mirror trap,calculates such a point, that a laser beam fired from the laser it the direction of this point:\n\nshall be reflected from the mirrors (but not necessarily from all of them),  shall neither intersect an edge nor a vertex of the mirror trap,  shall return to the laser, possibly from a different direction,  shall travel the longest total distance possible (in the sense of the definition provided).\n\nwrites the outcome to the standard output.", "inputFormat": "A single test consists of many mirror traps to be analysed. The first line of the standard input contains a single integer $1\\le K\\le 1000$, denoting the number of traps to be analysed. In the lines $2..K+1$ there are descriptions of the traps, a single per line. The description of the trap consists of three numbers $5\\le x,y,z\\le 1000$, separated by single spaces. The mirror trap has the dimensions of $2x\\times 2y\\times 2z$.", "outputFormat": "Your programme should write exactly $K$ lines to the standard output. The $i$'th line should contain a solution for the $i$'th trap: three integers $k_x,k_y,k_z$separated by single spaces, $-x\\le k_{x}\\le x$, $-y\\le k_{y}\\le y$, $-z\\le k_{z}\\le z$,$ \\{k_{x},k_{y},k_{z}\\}\\neq\\{0,0,0\\}$. Those numbers signify that in the $i$'th trap the laser should be aimed at the point, whose coordinates are $\\{k_{x},k_{y},k_{z}\\}$.\n\nShould there be a greater number of correct solutions, your programme ought to output any one of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2005] LUS-Mirror Trap", "background": null, "description": "镜子陷阱是由镜子构成的长方体，镜子的反射面对着长方体的内部。在长方体的几何中心放入一个微型激光器（尺寸忽略）。现在我们的任务是把激光向某一个方向发射，并且使光束在回到激光器自身之前，通过的总距离尽可能长。通过的总距离表示为激光束在与镜子反射面平行的三个方向的距离之和，也就是曼哈顿（城市）度量。\n\n不同的侧面相遇的陷阱的边和顶点不会反射激光束，且陷阱的边长是整数。在长方形陷阱中，使用笛卡尔坐标系。坐标系的纵横轴分别平行于陷阱的长和宽，激光器的位置在原点。激光器可以瞄准陷阱内的任意一个点包括反射镜的表面上的点（唯一的例外就是激光器本身，点 $(0,0,0)$）。\n\n我们的任务：\n\n输入这个镜子陷阱的尺寸，通过编写的程序计算出一个点，即激光器指向这一点：这一束激光应在反射镜（但不一定是所有反射镜）反射，但是不与陷阱的边、顶点相交，最后需要回到激光器本身（不需要一定的方向）同时尽可能使得总距离长。", "inputFormat": "输入有多个陷阱。输入的第一行包含一个整数 $K(1 \\le K\\le 1000)$，表示要分析的陷阱数。 在 $2,3,\\dots,K + 1$ 行中，有一个陷阱的描述，每行一个。 陷阱的描述由三个用空格分隔的数字 $x,y,z(5 \\le x,y,z \\le 1000)$ 组成。镜面陷阱的尺寸为 $2x \\times 2y \\times 2z$。", "outputFormat": "输出 $K$ 行。第 $K$ 行应包含第 $K$ 个陷阱的解决方案，由空格分隔的 $3$ 个数 $x,y,z$，表示激光器需要瞄准的点的坐标。\n\n如果有多个不同的正确解决方案，则任意的输出一个。", "hint": "感谢@SLYZ\\_0120 提供翻译。", "locale": "zh-CN"}}}
{"pid": "P3433", "type": "P", "difficulty": 7, "samples": [["6\n1 1\n-1 4\n0 -1\n4 1\n0 3\n1 4", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "POI（波兰）"], "title": "[POI 2005] PRA-Dextrogyrate Camel", "background": "", "description": "\nByteotia 由 $N$ 个绿洲组成，且任意三点不共线。Byteasar 住在其中一个绿洲里，并且在其他每个绿洲都有一位熟人。Byteasar 想尽可能多地去拜访他们。他打算骑着他的骆驼出行。这只骆驼像骡子一样倔强，因此以一种特别的方式移动：\n\n- 从某个绿洲出发后，它沿一条直线前进，直到到达另一个绿洲。\n- 骆驼只在绿洲处转向，而且只向右（顺时针）转，转角属于区间 $[0\\degree, 180\\degree]$（在同一个绿洲它只会转一次，也就是说不会通过连续两次各 $100\\degree$ 的转向来达成总计 $200\\degree$ 的转弯）。\n- 骆驼不愿踩着自己留下的足迹返回。\n\n请帮助 Byteasar 规划一条路线，使他能在遵守上述规则的前提下拜访尽量多的朋友。路线必须从 Byteasar 所在的绿洲出发，并最终回到该绿洲。路线应由依次连接所访绿洲的线段组成。除了 Byteasar 的起始绿洲（旅程的起点与终点）外，路线不得经过任意一点两次。\n\n起初，Byteasar 的骆驼面朝某个绿洲，且必须首先朝该方向出发。旅程结束时骆驼面向的方向无关紧要。\n\n### 任务\n\n编写一个程序，完成以下要求：\n\n1. 从标准输入读入骆驼面朝的方向与各个绿洲的坐标；\n2. 计算在遵守规则的情况下，Byteasar 最多可以拜访的朋友数量；\n3. 将结果写到标准输出。\n", "inputFormat": "\n\n标准输入的第一行包含一个整数 $N$（$3 \\le N \\le 1\\ 000$）—— Byteotia 中的绿洲数量。所有绿洲按 $1$ 到 $N$ 编号。Byteasar 居住在编号为 $1$ 的绿洲上，且他的骆驼面朝编号为 $2$ 的绿洲。接下来的 $N$ 行给出各个绿洲的坐标。在第 $(i+1)$ 行，给出两个整数 $x_i, y_i$，分别表示编号为 $i$ 的绿洲的横坐标与纵坐标，二者以一个空格分隔。所有坐标均在区间 $[-16\\ 000, 16\\ 000]$ 内。\n", "outputFormat": "\n标准输出仅一行，输出一个整数—— Byteasar 最多可以拜访的朋友数量。\n", "hint": "\n样例解释：\n\n![](https://cdn.luogu.com.cn/upload/pic/8961.png)\n\n翻译来自 ChatGPT 5。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2005] PRA-Dextrogyrate Camel", "background": "", "description": "\nByteotia consists of $N$ oasis in the desert, no three of which are collinear. Byteasar lives in one of these oasis and moreover he has an acquaintance in every other. Byteasar wants to pay a visit to as many of them as possible. He plans to travel on the back of his camel. The camel is as obstinate as a mule and thus moves in its own peculiar way:\n\nAfter departure from an oasis it moves along a straight line, until it gets to another oasis.\n\nThe camel turns only at oasis, but it turns only right (clockwise) and by an angle from the interval $[0\\degree,180\\degree]$ (the camel makes only one turn at an oasis, i.e. it will not turn by f.i. $200\\degree$ as a result of two subsequent turns by $100\\degree$).\n\nThe camel doesn't want to follow its own footprints.\n\nHelp Byteasar in planning such a route that he will be able to visit as many friends as possible. It should both begin and end in the oasis where Byteasar lives. It has to consist of segments connecting subsequently visited oasis. The route may not pass through any point two times, except the Byteasar's oasis, where the camel turns up twice: at the beginning and the end of the journey.\n\nByteasar's camel is initially facing a certain oasis and it has to start moving toward it. The direction the camel faces after returning from the journey is of no importance.\n\nTaskWrite a programme that:\n\nreads from the standard input the camel's coordinates and the direction it faces as well as the coordinates of the Byteotian oasis,determines the maximum number of friends Byteasar can pay a visit to while sticking to the presented rules,writes the result to the standard output.", "inputFormat": "\nIn the first line of the standard input there is one integer $N$ ($3\\le N\\le 1\\ 000$) - the number of oasis in Byteotia. The oasis are numbered from $1$ to $N$. Byteasar lives in the oasis no. $1$ and his camel is facing the oasis no. $2$. In the following $N$ lines the coordinates of the oasis are given. In the $(i+1)$'th line there are two integers $x_i$, $y_i$ - the horizontal and vertical coordinate of the $i$'th oasis - separated by a single space. All coordinates are from the interval from $-16\\ 000$ to $16\\ 000$.", "outputFormat": "\nIn the first and only line of the standard output your programme should write one integer - the maximum number of friends Byteasar can visit.\n", "hint": "Explanation of the example:\n\n ![](https://cdn.luogu.com.cn/upload/pic/8961.png) ", "locale": "en"}, "zh-CN": {"title": "[POI 2005] PRA-Dextrogyrate Camel", "background": "", "description": "\nByteotia 由 $N$ 个绿洲组成，且任意三点不共线。Byteasar 住在其中一个绿洲里，并且在其他每个绿洲都有一位熟人。Byteasar 想尽可能多地去拜访他们。他打算骑着他的骆驼出行。这只骆驼像骡子一样倔强，因此以一种特别的方式移动：\n\n- 从某个绿洲出发后，它沿一条直线前进，直到到达另一个绿洲。\n- 骆驼只在绿洲处转向，而且只向右（顺时针）转，转角属于区间 $[0\\degree, 180\\degree]$（在同一个绿洲它只会转一次，也就是说不会通过连续两次各 $100\\degree$ 的转向来达成总计 $200\\degree$ 的转弯）。\n- 骆驼不愿踩着自己留下的足迹返回。\n\n请帮助 Byteasar 规划一条路线，使他能在遵守上述规则的前提下拜访尽量多的朋友。路线必须从 Byteasar 所在的绿洲出发，并最终回到该绿洲。路线应由依次连接所访绿洲的线段组成。除了 Byteasar 的起始绿洲（旅程的起点与终点）外，路线不得经过任意一点两次。\n\n起初，Byteasar 的骆驼面朝某个绿洲，且必须首先朝该方向出发。旅程结束时骆驼面向的方向无关紧要。\n\n### 任务\n\n编写一个程序，完成以下要求：\n\n1. 从标准输入读入骆驼面朝的方向与各个绿洲的坐标；\n2. 计算在遵守规则的情况下，Byteasar 最多可以拜访的朋友数量；\n3. 将结果写到标准输出。\n", "inputFormat": "\n\n标准输入的第一行包含一个整数 $N$（$3 \\le N \\le 1\\ 000$）—— Byteotia 中的绿洲数量。所有绿洲按 $1$ 到 $N$ 编号。Byteasar 居住在编号为 $1$ 的绿洲上，且他的骆驼面朝编号为 $2$ 的绿洲。接下来的 $N$ 行给出各个绿洲的坐标。在第 $(i+1)$ 行，给出两个整数 $x_i, y_i$，分别表示编号为 $i$ 的绿洲的横坐标与纵坐标，二者以一个空格分隔。所有坐标均在区间 $[-16\\ 000, 16\\ 000]$ 内。\n", "outputFormat": "\n标准输出仅一行，输出一个整数—— Byteasar 最多可以拜访的朋友数量。\n", "hint": "\n样例解释：\n\n![](https://cdn.luogu.com.cn/upload/pic/8961.png)\n\n翻译来自 ChatGPT 5。", "locale": "zh-CN"}}}
{"pid": "P3434", "type": "P", "difficulty": 3, "samples": [["7 3\n5 6 4 3 6 2 3\n3 2 5", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "POI（波兰）"], "title": "[POI 2006] KRA-The Disks", "background": "", "description": "Johnny 在他生日的那天收到了来自他父母的生日礼物：一个管子和一套圆盘。管子由若干个高度相等的圆柱体组合而成，并且每个圆盘拥有和每段圆柱相同的高度，每个圆柱体上开大小不同的孔。\n\nJohnny 收到这套礼物后，发明了一个小游戏：他按一定顺序将圆盘放入管子当中，他想算出最后一个圆盘会停在哪个深度。\n\n显然，有两种情况会让圆盘停止掉落：其一是圆盘无法通过小孔（即孔的直径小于圆盘的直径），其二则是被其他圆盘挡住。\n\nJohnny 被他自己发明的游戏难住了，他现在把这个问题交给了你，你一定会帮助他解决这个难题的！", "inputFormat": "第一行两个整数 $n$ 和 $m$，分别代表管子的深度和圆盘的数量。\n\n下一行 $n$ 个整数 $r_i$，代表第 $i$ 层管子小孔的直径。\n\n第三行 $m$ 个整数 $k_i$，代表第 $i$ 个放入管子的圆盘的直径。", "outputFormat": "输出一个整数，代表最后一个圆盘会停留在第几层。\n\n如果最后一个圆盘无法放入管子，则输出 $0$。", "hint": "$1 \\leq n,m \\leq 3 \\times 10^5$，$1 \\leq r_i,k_i \\leq 10^9$", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] KRA-The Disks", "background": "", "description": "On his birthday, Johnny received a gift from his parents: a tube and a set of disks. The tube is composed of several cylindrical segments of equal height, and each disk has the same height as one segment. Each cylindrical segment has a hole, and the hole diameters may differ between segments.\n\nJohnny invented a game: he inserts the disks into the tube in a given order and wants to determine at which depth (level) the last disk will stop.\n\nA disk stops falling in two cases: either it cannot pass through a small hole (i.e., the hole’s diameter is smaller than the disk’s diameter), or it is blocked by previously inserted disks.\n\nJohnny is puzzled by his own game. He asks you to solve this problem for him.", "inputFormat": "The first line contains two integers $n$ and $m$, the tube’s depth (number of segments) and the number of disks, respectively.\n\nThe second line contains $n$ integers $r_i$, where $r_i$ is the diameter of the hole in the $i$-th segment of the tube.\n\nThe third line contains $m$ integers $k_i$, where $k_i$ is the diameter of the $i$-th disk inserted into the tube.", "outputFormat": "Output a single integer: the level at which the last disk will rest.\n\nIf the last disk cannot be inserted into the tube, output $0$.", "hint": "Constraints: $1 \\le n,m \\le 3 \\times 10^5$, $1 \\le r_i,k_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2006] KRA-The Disks", "background": "", "description": "Johnny 在他生日的那天收到了来自他父母的生日礼物：一个管子和一套圆盘。管子由若干个高度相等的圆柱体组合而成，并且每个圆盘拥有和每段圆柱相同的高度，每个圆柱体上开大小不同的孔。\n\nJohnny 收到这套礼物后，发明了一个小游戏：他按一定顺序将圆盘放入管子当中，他想算出最后一个圆盘会停在哪个深度。\n\n显然，有两种情况会让圆盘停止掉落：其一是圆盘无法通过小孔（即孔的直径小于圆盘的直径），其二则是被其他圆盘挡住。\n\nJohnny 被他自己发明的游戏难住了，他现在把这个问题交给了你，你一定会帮助他解决这个难题的！", "inputFormat": "第一行两个整数 $n$ 和 $m$，分别代表管子的深度和圆盘的数量。\n\n下一行 $n$ 个整数 $r_i$，代表第 $i$ 层管子小孔的直径。\n\n第三行 $m$ 个整数 $k_i$，代表第 $i$ 个放入管子的圆盘的直径。", "outputFormat": "输出一个整数，代表最后一个圆盘会停留在第几层。\n\n如果最后一个圆盘无法放入管子，则输出 $0$。", "hint": "$1 \\leq n,m \\leq 3 \\times 10^5$，$1 \\leq r_i,k_i \\leq 10^9$", "locale": "zh-CN"}}}
{"pid": "P3435", "type": "P", "difficulty": 4, "samples": [["8\nbabababa", "24"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "2006", "POI（波兰）", "KMP 算法"], "title": "[POI 2006] OKR-Periods of Words", "background": "", "description": "A string is a finite sequence of lower-case (non-capital) letters of the English alphabet. Particularly, it may be an empty sequence, i.e. a sequence of 0 letters. By A=BC we denotes that A is a string obtained by concatenation (joining by writing one immediately after another, i.e. without any space, etc.) of the strings B and C (in this order). A string P is a prefix of the string !, if there is a string B, that A=PB. In other words, prefixes of A are the initial fragments of A. In addition, if P!=A and P is not an empty string, we say, that P is a proper prefix of A.\n\n\nA string Q is a period of Q, if Q is a proper prefix of A and A is a prefix (not necessarily a proper one) of the string QQ. For example, the strings abab and ababab are both periods of the string abababa. The maximum period of a string A is the longest of its periods or the empty string, if A doesn't have any period. For example, the maximum period of ababab is abab. The maximum period of abc is the empty string.\n\nTask Write a programme that:\n\nreads from the standard input the string's length and the string itself,calculates the sum of lengths of maximum periods of all its prefixes,writes the result to the standard output.\n\n\n", "inputFormat": "In the first line of the standard input there is one integer $k$ ($1\\le k\\le 1\\ 000\\ 000$) - the length of the string. In the following line a sequence of exactly $k$ lower-case letters of the English alphabet is written - the string.\n", "outputFormat": "In the first and only line of the standard output your programme should write an integer - the sum of lengths of maximum periods of all prefixes of the string given in the input.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2006] OKR-Periods of Words", "background": "", "description": "A string is a finite sequence of lower-case (non-capital) letters of the English alphabet. Particularly, it may be an empty sequence, i.e. a sequence of 0 letters. By A=BC we denotes that A is a string obtained by concatenation (joining by writing one immediately after another, i.e. without any space, etc.) of the strings B and C (in this order). A string P is a prefix of the string !, if there is a string B, that A=PB. In other words, prefixes of A are the initial fragments of A. In addition, if P!=A and P is not an empty string, we say, that P is a proper prefix of A.\n\n\nA string Q is a period of Q, if Q is a proper prefix of A and A is a prefix (not necessarily a proper one) of the string QQ. For example, the strings abab and ababab are both periods of the string abababa. The maximum period of a string A is the longest of its periods or the empty string, if A doesn't have any period. For example, the maximum period of ababab is abab. The maximum period of abc is the empty string.\n\nTask Write a programme that:\n\nreads from the standard input the string's length and the string itself,calculates the sum of lengths of maximum periods of all its prefixes,writes the result to the standard output.\n\n\n", "inputFormat": "In the first line of the standard input there is one integer $k$ ($1\\le k\\le 1\\ 000\\ 000$) - the length of the string. In the following line a sequence of exactly $k$ lower-case letters of the English alphabet is written - the string.\n", "outputFormat": "In the first and only line of the standard output your programme should write an integer - the sum of lengths of maximum periods of all prefixes of the string given in the input.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2006] OKR-Periods of Words", "background": null, "description": "一个**字符串**是由小写英文字母组成的有限序列。特别地，它也可以是空序列（即长度为 $0$ 的序列）。\n\n如果字符串 $A$ 是通过字符串 $B$ 和 $C$ 按顺序连接（中间没有任何间隔符号）得到的，我们表示为 $A=BC$。\n\n如果存在一个字符串 $B$ 使得 $A=PB$，那么字符串 $P$ 是字符串 $A$ 的**前缀**。此外，如果 $P \\neq A$ 且 $P$ 不是空字符串，我们称 $P$ 是 $A$ 的**真前缀**。\n\n如果 $Q$ 是 $A$ 的真前缀，并且 $A$ 是字符串 $QQ$ 的前缀（不一定是真前缀），那么字符串 $Q$ 是 $A$ 的**周期**。例如，字符串 `abab` 和 `ababab` 都是 `abababa` 的周期。\n\n字符串 $A$ 的**最大周期**是其最长的周期，如果 $A$ 没有周期，则为空字符串。例如，`ababab` 的最大周期是 `abab`；`abc` 的最大周期是空字符串。\n\n---\n\n任务：\n\n编写一个程序，计算该字符串所有前缀的最大周期长度之和。", "inputFormat": "第一行包含一个整数 $k$，表示字符串的长度。 \n\n接下来的一行包含一个由 $k$ 个小写英文字母组成的字符串。", "outputFormat": "单独一行输出一个整数，表示输入字符串所有前缀的最大周期长度之和。", "hint": "（由 Gemini 2.5 Flash 翻译，人工审核）\n\n### 数据范围\n\n对于所有数据，$1\\le k\\le10^6$。", "locale": "zh-CN"}}}
{"pid": "P3436", "type": "P", "difficulty": 5, "samples": [["3 5\n1 2\n1 3\n2 3\n3 4\n3 4", "4\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2006", "POI（波兰）", "拓扑排序", "Tarjan"], "title": "[POI 2006] PRO-Professor Szu", "background": "", "description": "The Byteotian University is situated in the city of Byteion.\n\nApart from the main building the university owns \\(n\\) cottages for its academic staff. The cottages are connected with one - way alleys, however, there could be more than one alley between any two cottages (the alley can also form a loop connecting a building to itself). There are also alleys connecting the cottages to the main building. Byteion has been constructed so that no two alleys intersect in a point different from a cottage or the main building (there can however be bridges or tunnels on alleys). Moreover, each and every alley starts and ends in a cottage or the main building. It is known that a route exists between at least one of the cottages and the main building.\n\nOnce upon a time, the Byteotian University fancied to hire a well - known computer science pundit - professor Szu. As most outstanding scientists professor Szu has a certain peculiarity to him: each day he wishes to go to the university using a different route (a route being a sequence of alleys, each starting at the cottage the previous one ended at; the main building and each of the cottages may be visited many times). The professor considers two routes distinct if they differ by at least one alley (the order matters; two different alleys connecting the very same two cottages are considered distinct).\n\nKnowing the diagram of connections help the university in finding a cottage which has the greatest number of different routes to the main building possible (staying in such a cottage professor Szu will spend the longest time working at the university). Should there be more than one such cottage - find all of them. Should there be more than 36500 possible routes between a certain cottage and the main building we will assume that professor Szu can stay in this particular cottage forever (as he surely cannot live infinitely and 100 years seems a safe guess).\n\n### Task\n\nWrite a programme which:\n- reads from the standard input the diagram of connections between the cottages of Byteion,\n- determines the cottages which Professor Szu could live the longest time in and the longest possible time of habitation,\n- writes the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains two integers $n$ and $m$ ($1\\leq n,m\\leq1000000$) separated by a single space and denoting the number of cottages and alleys in Byteion, respectively (the cottages are numbered from 1 to $n$, and the university main building is denoted by $n + 1$). \n\nIn the following lines (2 to $m + 1$) there are pairs of integers $a_i,b_i$ ($1\\leq a_i,b_i\\leq n + 1$ for $1\\leq i\\leq m$) separated by single spaces and denoting the number of the cottage which the $i$'th alley starts at and the number of the cottage which the $i$'th alley ends at, respectively.", "outputFormat": "The first line of the standard output should contain the largest number of days that professor Szu could spend in Byteion or a single word *zawsze* (i.e. always in Polish) should this number exceed 36500 days. \n\nThe second line of the standard output should contain the number of cottages, living in which the professor can stay in Byteion for the amount of time specified in the first line. \n\nIn the third line of the standard output your programme should write out the numbers of all such cottages, separated by single spaces, and arranged in increasing order. All cottages, which the professor can stay forever in, are considered equal. ", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2006] PRO-Professor Szu", "background": "", "description": "The Byteotian University is situated in the city of Byteion.\n\nApart from the main building the university owns \\(n\\) cottages for its academic staff. The cottages are connected with one - way alleys, however, there could be more than one alley between any two cottages (the alley can also form a loop connecting a building to itself). There are also alleys connecting the cottages to the main building. Byteion has been constructed so that no two alleys intersect in a point different from a cottage or the main building (there can however be bridges or tunnels on alleys). Moreover, each and every alley starts and ends in a cottage or the main building. It is known that a route exists between at least one of the cottages and the main building.\n\nOnce upon a time, the Byteotian University fancied to hire a well - known computer science pundit - professor Szu. As most outstanding scientists professor Szu has a certain peculiarity to him: each day he wishes to go to the university using a different route (a route being a sequence of alleys, each starting at the cottage the previous one ended at; the main building and each of the cottages may be visited many times). The professor considers two routes distinct if they differ by at least one alley (the order matters; two different alleys connecting the very same two cottages are considered distinct).\n\nKnowing the diagram of connections help the university in finding a cottage which has the greatest number of different routes to the main building possible (staying in such a cottage professor Szu will spend the longest time working at the university). Should there be more than one such cottage - find all of them. Should there be more than 36500 possible routes between a certain cottage and the main building we will assume that professor Szu can stay in this particular cottage forever (as he surely cannot live infinitely and 100 years seems a safe guess).\n\n### Task\n\nWrite a programme which:\n- reads from the standard input the diagram of connections between the cottages of Byteion,\n- determines the cottages which Professor Szu could live the longest time in and the longest possible time of habitation,\n- writes the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains two integers $n$ and $m$ ($1\\leq n,m\\leq1000000$) separated by a single space and denoting the number of cottages and alleys in Byteion, respectively (the cottages are numbered from 1 to $n$, and the university main building is denoted by $n + 1$). \n\nIn the following lines (2 to $m + 1$) there are pairs of integers $a_i,b_i$ ($1\\leq a_i,b_i\\leq n + 1$ for $1\\leq i\\leq m$) separated by single spaces and denoting the number of the cottage which the $i$'th alley starts at and the number of the cottage which the $i$'th alley ends at, respectively.", "outputFormat": "The first line of the standard output should contain the largest number of days that professor Szu could spend in Byteion or a single word *zawsze* (i.e. always in Polish) should this number exceed 36500 days. \n\nThe second line of the standard output should contain the number of cottages, living in which the professor can stay in Byteion for the amount of time specified in the first line. \n\nIn the third line of the standard output your programme should write out the numbers of all such cottages, separated by single spaces, and arranged in increasing order. All cottages, which the professor can stay forever in, are considered equal. ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2006] PRO-Professor Szu", "background": "", "description": "某大学校内有一栋主楼，还有 $n$ 栋住宅楼。这些楼之间由一些单向道路连接，但是任意两栋楼之间可能有多条道路，也可能存在起点和终点为同一栋楼的环路。存在住宅楼无法到达主楼的情况，但**保证至少有一间宿舍和主楼之间存在路径**。\n\n现在有一位古怪的教授，他希望每天去主楼上班的路线不同。\n\n一条上班路线中，每栋楼都可以访问任意多次。我们称两条上班路线是**不同的**，当且仅当两条路线中存在**至少**一条路是不同的（两栋楼之间的多条道路被视为是不同的道路）。\n\n现在教授希望知道，从哪些住宅楼前往主楼的上班路线数最多。", "inputFormat": "第一行两个整数 $n,m$，分别为大学内住宅楼的数量和道路的数量。大学内所有住宅楼编号为 $1 \\sim n$，主楼编号为 $n+1$。\n\n接下来 $m$ 行，第 $i$ 行两个整数 $u_i,v_i$，代表大学内存在一条从 $u_i$ 号楼到 $v_i$ 号楼的道路。", "outputFormat": "第一行：如果存在一栋楼到主楼的上班路线数超过了 $36500$，输出 `zawsze`。否则输出一个整数，代表从一栋住宅楼前往主楼的最多上班路线数。\n\n第二行：输出一个整数 $p$，代表有多少栋住宅楼能使前往主楼的上班路线数最大化。特别地，如果最大上班路线数超过了 $36500$，那么这一行请输出能使上班路线数超过 $36500$ 的住宅楼的数量。\n\n第三行：按编号从小到大的顺序输出 $p$ 个整数，代表能使前往主楼的上班路线最大化的住宅楼的编号。特别地，如果最大上班路线数超过了 $36500$，那么这一行请输出所有能使上班路线数超过 $36500$ 的住宅楼的编号。", "hint": "对于 $100\\%$ 的数据，满足 $1\\leq n,m\\leq1000000$ ，$1\\leq u_i,v_i\\leq n + 1$。", "locale": "zh-CN"}}}
{"pid": "P3437", "type": "P", "difficulty": 5, "samples": [["7 5 4\n4 3 2 0 0\n3 3 1 3 0\n7 1 2 0 3\n2 3 3 2 2", "6"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2006", "线段树", "POI（波兰）"], "title": "[POI 2006] TET-Tetris 3D", "background": "", "description": "The authors of the game \"Tetris\" have decided to make a new, three-dimensional version, in which cuboids would fall down on a rectangular platform. The blocks fall down separately in a certain order, just like in the two-dimensional game. A block falls down until it reaches an obstacle: the platform or another block, that has already stopped - then it stops and remains in this exact position till the game is over.\n\nHowever, the authors wanted to change the spirit of the game, turning it from a simple arcade-game into a play far more puzzling. Knowing the order of the falling blocks and their flight path the player's task is to tell the height of the highest point of the arrangement after all blocks have fallen down (and stopped). All the blocks are falling down vertically and do not rotate while falling. For convenience we'll introduce a cartesian coordinate system on the platform, with the center in one of the platform's corners and the axes parallel to the platform's edges.\n\nWrite a programme that automates verification of the player's answer.\n\nTaskWrite a programme that:\n\nreads the descriptions of subsequent falling blocks from the standard input,determines the height of the highest point of the arrangement of blocks after all have fallen down and stopped,writes the result to the standard output.\n\n", "inputFormat": "In the first line of the input there are three integers $D$, $S$ and $N$ ($1\\le N\\le 20\\ 000$, $1\\le D,S\\le 1\\ 000$), separated by single spaces and denoting respectively: the length and the depth of the platform and the number of blocks that are going to fall down on it. In the following $N$ lines the descriptions of subsequent blocks are given, one in each line.\n\nEach description of a block consists of five integers: $d$,$s$,$w$,$x$ and $y$ ($1\\le d$, $0\\le x$, $d+x\\le D$, $1\\le s$, $0\\le y$, $s+y\\le S$, $1\\le w\\le 100\\ 000$), representing a block of length $d$ depth $s$ and height $w$. This very block will be be falling down on the platform with its $d\\times s$ face as the bottom, where the length and depth of the block are parallel to those of the platform. The coordinates of the vertices of the projection of the block on the platform are: $(x,y)$, $(x+d,y)$, $(x,y+s)$ and $(x+d,y+s)$.\n", "outputFormat": "The first and only line of the standard output should contain exactly one integer, the height of the highest point of the arrangement of blocks after all have fallen down and stopped.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2006] TET-Tetris 3D", "background": "", "description": "The authors of the game \"Tetris\" have decided to make a new, three-dimensional version, in which cuboids would fall down on a rectangular platform. The blocks fall down separately in a certain order, just like in the two-dimensional game. A block falls down until it reaches an obstacle: the platform or another block, that has already stopped - then it stops and remains in this exact position till the game is over.\n\nHowever, the authors wanted to change the spirit of the game, turning it from a simple arcade-game into a play far more puzzling. Knowing the order of the falling blocks and their flight path the player's task is to tell the height of the highest point of the arrangement after all blocks have fallen down (and stopped). All the blocks are falling down vertically and do not rotate while falling. For convenience we'll introduce a cartesian coordinate system on the platform, with the center in one of the platform's corners and the axes parallel to the platform's edges.\n\nWrite a programme that automates verification of the player's answer.\n\nTaskWrite a programme that:\n\nreads the descriptions of subsequent falling blocks from the standard input,determines the height of the highest point of the arrangement of blocks after all have fallen down and stopped,writes the result to the standard output.\n\n", "inputFormat": "In the first line of the input there are three integers $D$, $S$ and $N$ ($1\\le N\\le 20\\ 000$, $1\\le D,S\\le 1\\ 000$), separated by single spaces and denoting respectively: the length and the depth of the platform and the number of blocks that are going to fall down on it. In the following $N$ lines the descriptions of subsequent blocks are given, one in each line.\n\nEach description of a block consists of five integers: $d$,$s$,$w$,$x$ and $y$ ($1\\le d$, $0\\le x$, $d+x\\le D$, $1\\le s$, $0\\le y$, $s+y\\le S$, $1\\le w\\le 100\\ 000$), representing a block of length $d$ depth $s$ and height $w$. This very block will be be falling down on the platform with its $d\\times s$ face as the bottom, where the length and depth of the block are parallel to those of the platform. The coordinates of the vertices of the projection of the block on the platform are: $(x,y)$, $(x+d,y)$, $(x,y+s)$ and $(x+d,y+s)$.\n", "outputFormat": "The first and only line of the standard output should contain exactly one integer, the height of the highest point of the arrangement of blocks after all have fallen down and stopped.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2006] TET-Tetris 3D", "background": "", "description": "最近，有人发明了一种三维版的俄罗斯方块。和二维版本类似，一些立方体按照一定的顺序掉落，直到碰到别的方块或是地面才会停止掉落。立方体停止掉落后会一直保持掉落时的位置，直到游戏结束。\n\n你的朋友决定以这个新版本的俄罗斯方块为背景，出一道题。给出每个立方体的掉落顺序和其掉落的轨迹，在所有方块完成掉落后求出最高方块的高度。在这个游戏中，方块均垂直下落，且方块不会旋转或翻转。为了方便描述，我们会建立一个空间直角坐标系，该坐标系的原点为地面的一角，并且坐标轴与地面边缘平行。\n\n现在轮到你解决这个问题了。", "inputFormat": "第一行三个整数 $D,S,N$，分别为地面的长度，宽度，和将要掉落的立方体数量。\n\n接下来 $N$ 行，每行五个整数 $d_i,s_i,w_i,x_i,y_i$，描述一个掉落的立方体。其中 $d_i,s_i,w_i$ 分别代表立方体的长，宽，高。立方体的底面（即长 $\\times$ 宽的那一面）将正对地面。立方体底面四个角在地面的投影坐标分别为 $(x_i,y_i)$，$(x_i+d_i,y_i)$，$(x_i,y_i+s_i)$，$(x_i+d_i,y_i+s_i)$。", "outputFormat": "输出一个整数，即方块掉落结束后最高方块的高度。", "hint": "$1 \\leq N \\leq 20\\,000$，$1 \\leq D,S \\leq 1\\,000$，$d_i,s_i \\geq 1$，$1 \\leq w_i \\leq 100\\,000$，$0 \\leq x_i,d_i+x_i \\leq D$，$0 \\leq y_i,s_i+y_i \\leq S$。", "locale": "zh-CN"}}}
{"pid": "P3438", "type": "P", "difficulty": 6, "samples": [["5 5\n1 1 5 5\n2\n3 3\n4 2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "二分", "单调队列", "POI（波兰）", "广度优先搜索 BFS"], "title": "[POI 2006] ZAB-Frogs", "background": "", "description": "A scourge of frogs destroying all the crop has started in Byteotia. A farmer named Byteasar has decided to fight the vermin with peculiar \"scarefrogs\", that he has set up at certain points of his field. While moving from one place to another, every frog tries to keep as far of them as possible, i.e. maximizes the distance to the closest scarefrog.\n\nThe field that belongs to Byteasar has rectangular shape. The frogs leap in directions parallel to the field's sides and their leaps are unitary (of length 1). The scarefrogs-distance, for a given frog's route, is the minimum of all distances from all scarefrogs at all inter-leap-points of the route.\n\nByteasar already knows the most common starting and destination points of the frogs' routes, therefore he experiments with various deployments of the scarefrogs. He asks you for help, namely he would like you to write a programme that calculates the maximum (over all routes) scarefrogs-distance for a given deployment of scarefrogs - which we call in short the frogshold distance.\n\nTaskWrite a programme that:\n\nreads from the standard input the size of the field, the coordinates of the screfrogs and the source and target position of a frog,determines the frogshold distance (the maximum scarefrogs-distance a frog may achieve while still being able to reach the target point)writes the square of this number to the standard output.\n\n给定一个网格图，其中有一些坏点，要求使起点到终点的路径上的所有点到离该点最近的坏点的最小距离距离最大，求这个最大值。\n", "inputFormat": "The first line of the input contains two integers: $w_x$ and $w_y$ separated by a single space - the breadth and length of the field ($2 \\le w_x, w_y \\le 1000$). The second line of the input contains four integers: $p_x$, $p_y$, $k_x$ and $k_y$ separated by single spaces; $(p_x, p_y)$ is the initial position of the frog, $(k_x, k_y)$is the target (final) position of the frog ($1 \\le p_x, k_x \\le w_x$, $1 \\le p_y, k_y \\le w_y$). The third line of the standard input contains one integer $n$ - these are the coordinates of the ith scarefrog ($1 \\le n \\le w_x \\cdot w_y$). No two scarefrogs occupy the same position and none of them is at the point $(p_x, p_y)$ nor $(k_x, k_y)$.\n", "outputFormat": "In the first and only line of the standard output one integer should be written, namely the square of the frogshold distance. If the frog cannot avoid leaping directly on some scarefrog the result is 0.\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] ZAB-Frogs", "background": "", "description": "A scourge of frogs destroying all the crops has started in Byteotia. A farmer named Byteasar has decided to fight the vermin with peculiar “scarefrogs” that he has set up at certain points of his field. While moving from one place to another, every frog tries to keep as far from them as possible, i.e., it maximizes the distance to the closest scarefrog.\n\nByteasar’s field is rectangular. The frogs leap in directions parallel to the field’s sides, and each leap has unit length 1. For a given route, the scarefrog-distance is the minimum, over all points visited continuously along the route (including the points between leaps), of the distance to the nearest scarefrog.\n\nByteasar already knows the most common starting and destination points of the frogs’ routes, so he experiments with various deployments of scarefrogs. He asks you to compute the maximum (over all routes from the start to the target) scarefrog-distance achievable while still reaching the target. We call this value the frogshold distance. You should output the square of this number.\n\nIn other words, given a grid with some “bad” points (the scarefrogs), find a path from the start to the end that maximizes the minimum distance, over all points on the path, to the nearest bad point, and output this maximum squared.", "inputFormat": "- The first line contains two integers $w_x$ and $w_y$ — the width and height of the field ($2 \\le w_x, w_y \\le 1000$).\n- The second line contains four integers $p_x$, $p_y$, $k_x$ and $k_y$; $(p_x, p_y)$ is the frog’s start position, and $(k_x, k_y)$ is the target position ($1 \\le p_x, k_x \\le w_x$, $1 \\le p_y, k_y \\le w_y$).\n- The third line contains one integer $n$ ($1 \\le n \\le w_x \\cdot w_y$).\n- Each of the next $n$ lines contains two integers $x_i$ and $y_i$ — the coordinates of the $i$-th scarefrog.\n- No two scarefrogs occupy the same position, and none of them is at $(p_x, p_y)$ or $(k_x, k_y)$.", "outputFormat": "Output a single integer — the square of the frogshold distance. If the frog cannot avoid leaping directly onto some scarefrog, output $0$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2006] ZAB-Frogs", "background": "", "description": "A scourge of frogs destroying all the crop has started in Byteotia. A farmer named Byteasar has decided to fight the vermin with peculiar \"scarefrogs\", that he has set up at certain points of his field. While moving from one place to another, every frog tries to keep as far of them as possible, i.e. maximizes the distance to the closest scarefrog.\n\nThe field that belongs to Byteasar has rectangular shape. The frogs leap in directions parallel to the field's sides and their leaps are unitary (of length 1). The scarefrogs-distance, for a given frog's route, is the minimum of all distances from all scarefrogs at all inter-leap-points of the route.\n\nByteasar already knows the most common starting and destination points of the frogs' routes, therefore he experiments with various deployments of the scarefrogs. He asks you for help, namely he would like you to write a programme that calculates the maximum (over all routes) scarefrogs-distance for a given deployment of scarefrogs - which we call in short the frogshold distance.\n\nTaskWrite a programme that:\n\nreads from the standard input the size of the field, the coordinates of the screfrogs and the source and target position of a frog,determines the frogshold distance (the maximum scarefrogs-distance a frog may achieve while still being able to reach the target point)writes the square of this number to the standard output.\n\n给定一个网格图，其中有一些坏点，要求使起点到终点的路径上的所有点到离该点最近的坏点的最小距离距离最大，求这个最大值。\n", "inputFormat": "The first line of the input contains two integers: $w_x$ and $w_y$ separated by a single space - the breadth and length of the field ($2 \\le w_x, w_y \\le 1000$). The second line of the input contains four integers: $p_x$, $p_y$, $k_x$ and $k_y$ separated by single spaces; $(p_x, p_y)$ is the initial position of the frog, $(k_x, k_y)$is the target (final) position of the frog ($1 \\le p_x, k_x \\le w_x$, $1 \\le p_y, k_y \\le w_y$). The third line of the standard input contains one integer $n$ - these are the coordinates of the ith scarefrog ($1 \\le n \\le w_x \\cdot w_y$). No two scarefrogs occupy the same position and none of them is at the point $(p_x, p_y)$ nor $(k_x, k_y)$.\n", "outputFormat": "In the first and only line of the standard output one integer should be written, namely the square of the frogshold distance. If the frog cannot avoid leaping directly on some scarefrog the result is 0.\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3439", "type": "P", "difficulty": 6, "samples": [["3\n2 2 1\n6 2 1\n4 6 1", "4 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2006", "POI（波兰）", "Special Judge"], "title": "[POI 2006] MAG-Warehouse", "background": "", "description": "The streets of the New Byte City form a rectangular grid - those running east-west are simply called streets, while those running north-south are called avenues. To avoid mistakes, we shall call them h-streets and v-streets, respectively. The v-streets are numbered from $1$ to $500\\ 000\\ 000$ eastwards. Similarly, the h-streets are numbered from $1$ to $500\\ 000\\ 000$ northwards. Every v-street crosses every h-street and, conversely, every h-street crosses every v-street. The distance between two consecutive v-streets, as well as between two consecutive h-streets, is exactly one kilometre.\n\n ![](https://cdn.luogu.com.cn/upload/pic/6964.png) \n\nThere are $k$ shops in the city, each one of them is situated at a crossroads. Byteasar, the merchant, supplies every single one of the $k$ shops, and furthermore he returns to some of them several times a day with fresh supplies. Recently he has decided to have a warehouse built, from which the goods would be delivered. For obvious reasons, it should stand at a crossroads. The lorry loaded with goods can supply only one shop per course - it leaves the warehouse, delivers to the shop and returns to the warehouse. The lorry always picks the shortest path from the warehouse to the shop, and the shortest one back (possibly the same one). The distance between points $(x_i, y_i)$ and $(x_j, y_j)$ equals $\\max \\{ |x_i - x_j|, |y_i - y_j| \\}$.\n\nTaskWrite a programme that:\n\nreads the locations of shops, as well as the numbers of their daily deliveries, from the standard inputdetermines such a warehouse's position that the summary distance of the lorry's daily route is minimal,writes the result to the standard output.\n\n给定一个网格图，其上有一堆坏点(整点，同一位置多个)，求一个整点，使得该整点到所有的坏点的**切比雪夫距离**之和最小。\n\n求这个整点位置。(横纵坐标最大)\n", "inputFormat": "The first line of the standard input contains one integer $n$ ($1 \\le n \\le 100\\ 000$), the number of shops in the New Byte City.\n\nThe following $n$ lines contain the shops' descriptions. The $(i+1)$'th line contains three integers $x_i$, $y_i$ and $t_i$ ($1 \\le x_i, y_i \\le 500\\ 000\\ 000$, $1 \\le t_i \\le 1\\ 000\\ 000$), separated by single spaces. This triple means that the $i$'th shop lies at the crossing of $x_i$'th v-street and $y_i$'th h-street and the lorry delivers goods to this shop $t_i$ times a day.\n", "outputFormat": "The first and only line of the standard output should contain two integers $x_m$ and $y_m$, separated by a single space, denoting the optimal position of the warehouse as the crossroads of the $x_m$'th v-street and the $y_m$'th h-street. Should there be many optimal solutions, your programme is to pick one of them arbitrarily.\n", "hint": "感谢@oscar 提供SPJ\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] MAG-Warehouse", "background": "", "description": "The streets of the New Byte City form a rectangular grid — those running east-west are simply called streets, while those running north-south are called avenues. To avoid mistakes, we shall call them h-streets and v-streets, respectively. The v-streets are numbered from $1$ to $500\\ 000\\ 000$ eastwards. Similarly, the h-streets are numbered from $1$ to $500\\ 000\\ 000$ northwards. Every v-street crosses every h-street and, conversely, every h-street crosses every v-street. The distance between two consecutive v-streets, as well as between two consecutive h-streets, is exactly one kilometre.\n\n![](https://cdn.luogu.com.cn/upload/pic/6964.png)\n\nThere are $k$ shops in the city, each one of them situated at a crossroads. Byteasar, the merchant, supplies every single one of the $k$ shops, and furthermore he returns to some of them several times a day with fresh supplies. Recently he has decided to have a warehouse built, from which the goods would be delivered. For obvious reasons, it should stand at a crossroads. The lorry loaded with goods can supply only one shop per course — it leaves the warehouse, delivers to the shop, and returns to the warehouse. The lorry always picks the shortest path from the warehouse to the shop, and the shortest one back (possibly the same one). The distance between points $(x_i, y_i)$ and $(x_j, y_j)$ equals $\\max \\{ |x_i - x_j|, |y_i - y_j| \\}$.\n\nTask: Write a program that:\n- reads the locations of shops, as well as the numbers of their daily deliveries, from the standard input,\n- determines such a warehouse position that the total distance of the lorry’s daily route is minimal,\n- writes the result to the standard output.\n\nGiven a grid graph with a set of “bad points” at integer coordinates (multiplicity allowed at the same location), find an integer lattice point that minimizes the sum of Chebyshev distances to all the bad points. Find such a lattice point position.", "inputFormat": "The first line of the standard input contains one integer $n$ ($1 \\le n \\le 100\\ 000$), the number of shops in the New Byte City.\n\nThe following $n$ lines contain the shops’ descriptions. The $(i+1)$'th line contains three integers $x_i$, $y_i$ and $t_i$ ($1 \\le x_i, y_i \\le 500\\ 000\\ 000$, $1 \\le t_i \\le 1\\ 000\\ 000$), separated by single spaces. This triple means that the $i$'th shop lies at the crossing of the $x_i$'th v-street and the $y_i$'th h-street, and the lorry delivers goods to this shop $t_i$ times a day.", "outputFormat": "The first and only line of the standard output should contain two integers $x_m$ and $y_m$, separated by a single space, denoting the optimal position of the warehouse as the crossroads of the $x_m$'th v-street and the $y_m$'th h-street. Should there are many optimal solutions, your program may pick one of them arbitrarily.", "hint": "Thanks to @oscar for providing the SPJ.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2006] MAG-Warehouse", "background": "", "description": "The streets of the New Byte City form a rectangular grid - those running east-west are simply called streets, while those running north-south are called avenues. To avoid mistakes, we shall call them h-streets and v-streets, respectively. The v-streets are numbered from $1$ to $500\\ 000\\ 000$ eastwards. Similarly, the h-streets are numbered from $1$ to $500\\ 000\\ 000$ northwards. Every v-street crosses every h-street and, conversely, every h-street crosses every v-street. The distance between two consecutive v-streets, as well as between two consecutive h-streets, is exactly one kilometre.\n\n ![](https://cdn.luogu.com.cn/upload/pic/6964.png) \n\nThere are $k$ shops in the city, each one of them is situated at a crossroads. Byteasar, the merchant, supplies every single one of the $k$ shops, and furthermore he returns to some of them several times a day with fresh supplies. Recently he has decided to have a warehouse built, from which the goods would be delivered. For obvious reasons, it should stand at a crossroads. The lorry loaded with goods can supply only one shop per course - it leaves the warehouse, delivers to the shop and returns to the warehouse. The lorry always picks the shortest path from the warehouse to the shop, and the shortest one back (possibly the same one). The distance between points $(x_i, y_i)$ and $(x_j, y_j)$ equals $\\max \\{ |x_i - x_j|, |y_i - y_j| \\}$.\n\nTaskWrite a programme that:\n\nreads the locations of shops, as well as the numbers of their daily deliveries, from the standard inputdetermines such a warehouse's position that the summary distance of the lorry's daily route is minimal,writes the result to the standard output.\n\n给定一个网格图，其上有一堆坏点(整点，同一位置多个)，求一个整点，使得该整点到所有的坏点的**切比雪夫距离**之和最小。\n\n求这个整点位置。(横纵坐标最大)\n", "inputFormat": "The first line of the standard input contains one integer $n$ ($1 \\le n \\le 100\\ 000$), the number of shops in the New Byte City.\n\nThe following $n$ lines contain the shops' descriptions. The $(i+1)$'th line contains three integers $x_i$, $y_i$ and $t_i$ ($1 \\le x_i, y_i \\le 500\\ 000\\ 000$, $1 \\le t_i \\le 1\\ 000\\ 000$), separated by single spaces. This triple means that the $i$'th shop lies at the crossing of $x_i$'th v-street and $y_i$'th h-street and the lorry delivers goods to this shop $t_i$ times a day.\n", "outputFormat": "The first and only line of the standard output should contain two integers $x_m$ and $y_m$, separated by a single space, denoting the optimal position of the warehouse as the crossroads of the $x_m$'th v-street and the $y_m$'th h-street. Should there be many optimal solutions, your programme is to pick one of them arbitrarily.\n", "hint": "感谢@oscar 提供SPJ\n", "locale": "zh-CN"}}}
{"pid": "P3440", "type": "P", "difficulty": 6, "samples": [["5\n1 1 2 3\n1 1 5 1\n3 2 5 5\n4 1 5 10\n3 3 3 1", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "POI（波兰）", "深度优先搜索 DFS", "最小割"], "title": "[POI 2006] SZK-Schools", "background": "", "description": "B 国境内有 $n$ 所学校，每所学校都有一个 $1 \\sim n$ 的编号。\n\n由于管理过于宽松，可能存在两个学校同时用一个编号的情况，当然也存在一个编号没有学校用的情况。\n\n现在国王决定重新给所有学校编号，使得任意两个学校的编号不同。\n\n当然，改变编号是一个很繁重的工作，学校不希望自己的编号改变太多。每个学校都有一个可以接受的新编号区间 $[a,b]$，以及改变编号的单位成本 $k$。如果一个学校的旧编号为 $m$，新编号为 $m'$，那么给这个学校改变编号的成本即为 $k \\times |m'-m|$。\n\n现在你需要告诉国王完成编号更新的最低成本是多少，或者说明这是不可能的。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行四个整数 $m_i,a_i,b_i,k_i$，代表 $i$ 号学校的旧编号为 $m_i$，新编号的范围为 $[a_i,b_i]$，改变编号的单位成本为 $k_i$。", "outputFormat": "如果不存在一种方案，使得任意两个学校的编号不同，输出 `NIE`。\n\n否则输出一个整数，代表最小成本。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le a_i \\le m_i \\le b_i \\le n \\le 200$，$1\\le k_i \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] SZK-Schools", "background": "", "description": "There are $n$ schools in country B, each with an ID from $1 \\sim n$.\n\nDue to lax administration, it may happen that two schools share the same ID, and some IDs may be unused.\n\nNow the king decides to reassign IDs to all schools so that any two schools have different IDs.\n\nHowever, changing IDs is a heavy workload, and schools do not want their IDs to change too much. Each school has an acceptable interval for its new ID $[a,b]$, and a unit cost $k$. If a school’s old ID is $m$ and the new ID is $m'$, then the cost to change this school’s ID is $k \\times |m'-m|$.\n\nYou need to tell the king the minimum total cost to complete the renumbering, or state that it is impossible.", "inputFormat": "The first line contains an integer $n$.\n\nThen follow $n$ lines, each containing four integers $m_i,a_i,b_i,k_i$, meaning that school $i$ has old ID $m_i$, its new ID must be in the range $[a_i,b_i]$, and its unit cost is $k_i$.", "outputFormat": "If there is no assignment such that any two schools have different IDs, output `NIE`.\n\nOtherwise, output a single integer, the minimum total cost.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1\\le a_i \\le m_i \\le b_i \\le n \\le 200$, $1\\le k_i \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2006] SZK-Schools", "background": "", "description": "B 国境内有 $n$ 所学校，每所学校都有一个 $1 \\sim n$ 的编号。\n\n由于管理过于宽松，可能存在两个学校同时用一个编号的情况，当然也存在一个编号没有学校用的情况。\n\n现在国王决定重新给所有学校编号，使得任意两个学校的编号不同。\n\n当然，改变编号是一个很繁重的工作，学校不希望自己的编号改变太多。每个学校都有一个可以接受的新编号区间 $[a,b]$，以及改变编号的单位成本 $k$。如果一个学校的旧编号为 $m$，新编号为 $m'$，那么给这个学校改变编号的成本即为 $k \\times |m'-m|$。\n\n现在你需要告诉国王完成编号更新的最低成本是多少，或者说明这是不可能的。", "inputFormat": "第一行一个整数 $n$。\n\n接下来 $n$ 行，每行四个整数 $m_i,a_i,b_i,k_i$，代表 $i$ 号学校的旧编号为 $m_i$，新编号的范围为 $[a_i,b_i]$，改变编号的单位成本为 $k_i$。", "outputFormat": "如果不存在一种方案，使得任意两个学校的编号不同，输出 `NIE`。\n\n否则输出一个整数，代表最小成本。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le a_i \\le m_i \\le b_i \\le n \\le 200$，$1\\le k_i \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P3441", "type": "P", "difficulty": 6, "samples": [["17 3\n1 2\n3 2\n2 4\n5 2\n5 6\n5 8\n7 8\n9 8\n5 10\n10 13\n13 14\n10 12\n12 11\n15 17\n15 16\n15 10", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2006", "POI（波兰）"], "title": "[POI 2006] MET-Subway", "background": "", "description": "某城市长期进行地铁建设。由于财务管理不善且成本被严重低估，导致没有预留购买列车的资金。结果只建成了过多的车站和部分规划中的隧道——仅能确保任意两个车站之间存在连接。隧道数量（每条隧道都是双向的）比已建成的车站数量少一。剩余资金仅能购置少量列车。\n\n为了挽回颜面，董事会请你规划地铁线路，使得被连接的站点数量最大化。每列列车在指定线路上行驶。线路不能分叉（即同一车站不能有三条隧道属于同一条线路）。不同线路可以包含相同的车站或隧道。\n\n**任务**  \n编写一个程序：\n\n1. 从标准输入读取隧道系统的描述和待规划的地铁线路数量；\n2. 计算指定数量的地铁线路能覆盖的最大站点数；\n3. 将结果输出到标准输出。", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $l$（$2 \\le n \\le 1\\,000\\,000$，$0 \\le l \\le n$），以单个空格分隔。$n$ 表示车站数量，$l$ 表示待规划的地铁线路数量。车站编号为 $1$ 至 $n$。\n\n接下来的 $n-1$ 行，每行包含两个不同的整数，以单个空格分隔。第 $(i+1)$ 行的数字 $1 \\le a_i, b_i \\le n$ 表示第 $i$ 条隧道连接的两个车站编号。", "outputFormat": "标准输出的第一行（也是唯一一行）应包含一个整数，表示列车线路能覆盖的最大站点数。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] MET-Subway", "background": "", "description": "A certain city has been coping with subway construction for a long time. The finances have been mismanaged and the costs have been underestimated to such extent that no funds were foreseen for the purchase of trains. As a result, too many stations and only some of the planned tunnels have been built - barely enough to allow a connection between any two stations to exist. The number of tunnels (each of them is bidirectional) is one less than the number of stations built. From the remaining funds only a handful of trains have been acquired.\n\nTo save their face, the board of directors have asked you to plan subway routes in such a way as to allow maximal number of stations to be connected. Each train travels on a specified route. The routes cannot branch (no three tunnels starting at a single station may belong to the same route). Distinct routes may comprise the same station or tunnel.\n\nTaskWrite a programme which:\n\nreads a description of the tunnel system and the number of subway lines, which are to be planned from the standard input,calculates the maximal number of stations which can be covered by the specified number of subway lines,writes the outcome to the standard output.", "inputFormat": "The first line of the standard input contains two integers $n$ and $l$ ($2 \\le n \\le 1\\ 000\\ 000, 0 \\le l \\le n$) separated by a single space. $n$ denotes the number of stations and $l$ denotes the number of subway lines, which are to be planned. The stations are numbered from $1$ to $n$.\n\nEach of the following $n-1$ lines contains two distinct integers separated by a single space.\n\nThe numbers $1 \\le a_i, b_i \\le n$ in the $(i+1)$'th line denote the numbers of stations connected by $i$'th tunnel.\n", "outputFormat": "The first and only line of the standard output should contain a single integer denoting the maximal number of stations which can be covered by train routes.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2006] MET-Subway", "background": "", "description": "某城市长期进行地铁建设。由于财务管理不善且成本被严重低估，导致没有预留购买列车的资金。结果只建成了过多的车站和部分规划中的隧道——仅能确保任意两个车站之间存在连接。隧道数量（每条隧道都是双向的）比已建成的车站数量少一。剩余资金仅能购置少量列车。\n\n为了挽回颜面，董事会请你规划地铁线路，使得被连接的站点数量最大化。每列列车在指定线路上行驶。线路不能分叉（即同一车站不能有三条隧道属于同一条线路）。不同线路可以包含相同的车站或隧道。\n\n**任务**  \n编写一个程序：\n\n1. 从标准输入读取隧道系统的描述和待规划的地铁线路数量；\n2. 计算指定数量的地铁线路能覆盖的最大站点数；\n3. 将结果输出到标准输出。", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $l$（$2 \\le n \\le 1\\,000\\,000$，$0 \\le l \\le n$），以单个空格分隔。$n$ 表示车站数量，$l$ 表示待规划的地铁线路数量。车站编号为 $1$ 至 $n$。\n\n接下来的 $n-1$ 行，每行包含两个不同的整数，以单个空格分隔。第 $(i+1)$ 行的数字 $1 \\le a_i, b_i \\le n$ 表示第 $i$ 条隧道连接的两个车站编号。", "outputFormat": "标准输出的第一行（也是唯一一行）应包含一个整数，表示列车线路能覆盖的最大站点数。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P3442", "type": "P", "difficulty": 6, "samples": [["5\n4 1\n1 4\n8 9\n11 5\n8 1\n4\n7 2 3\n6 3 -1\n4 5 3\n9 6 -4", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "POI（波兰）", "凸包"], "title": "[POI 2006] NAJ-The Invasion", "background": "", "description": "And so it has come - the Triangles have invaded Byteotia!\n\nByteotia lies on an island, occupying its entire surface.\n\nThe shape of the island is a convex polygon(i.e. a polygon whose each inner angle is smaller than $180\\degree$).\n\nA certain number of software factories are located in Byteotia, each of which generates constant gains or losses.\n\nThe Triangles have decided to occupy such a part of Byteotia which:\n\nis a triangle-shaped area, the vertices of which are three different vertices of the polygon-island,     brings the largest income i.e. the sum of all gains and losses generated by factories within the occupied area is maximal.\n\nWe assume that a factory located on the border or in the vertex of occupied area belongs to that area. A territory which contains no factory brings, obviously, a zero income.\n\nByteasar, the King of Byteotia, is concerned by the amount of losses the Triangles' invasion could generate. Help him by writing a programme which shall calculate the sum of gains and losses generated by factories which the Triangles wish to capture.\n\nTaskWrite a programme which:\n\nreads a decription of Byteotia's shape and the locations of factories from the input file,     determines the maximal value of sum of all gains and losses generated by factories within a triangle, whose vertices are three different vertices of the polygon island,     writes the outcome to the output file.\n\n给定一个凸包， 并给出凸包内部或边上的若干个资源，每个资源都有权值,现在要在凸包上面选择不同的3个点，使得3个点组成的三角形\n内部的资源的权值之和最大。\n\n\n凸包点个数 $n \\le 600$\n\n\n资源个数 $m \\le 10000$\n", "inputFormat": "The first line of the input file contains a single integer $n$ ($3 \\le n \\le 600$), denoting the number of vertices of the polygon-island.\n\nThe following $n$ lines of the input contain two integers each $x_j$ and $y_j$ ($-10\\ 000 \\le x_j, y_j \\le 10\\ 000$), separated by a single space, denoting the coordinates $x$ and $y$ of consecutive vertices of the island, in a clockwise order.\n\nThe $(n+2)$-nd line contains a single integer $m$ ($1 \\le m \\le 10\\ 000$), denoting thetotal number of factories.\n\nIn each of the following $m$ lines there are three integers $x_i'$, $y_i'$ and $w_i$ ($-10\\ 000 \\le x_i', y_i' \\le 10\\ 000$, $-100\\ 000 \\le w_i \\le 100\\ 000$), separated by single spaces, denoting: the coordinates $x$ and $y$ of the $i$-th factory and the gain (for $w_i \\ge 0$) or loss (for $w_i < 0$) this factory generates, respectively. Each factory is situated on the polygon-island i.e. within or on the border of it. Distinct factories may be located in the same place i.e. have the same coordinates.\n", "outputFormat": "The first and only line of the output file should contain a single integer denoting the maximal value of sum of all gains and losses generated by factories within a triangle whose vertices are three different vertices of the polygon-island. Notice that it may happen that the outcome is a negative integer.\n", "hint": "the correct result is:\n\n![](https://cdn.luogu.com.cn/upload/pic/6970.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] NAJ-The Invasion", "background": "", "description": "And so it has come — the Triangles have invaded Byteotia.\n\nByteotia lies on an island, occupying its entire surface. The shape of the island is a convex polygon (i.e., a polygon whose each interior angle is smaller than $180\\degree$).\n\nA certain number of software factories are located in Byteotia, each of which generates constant gains or losses.\n\nThe Triangles have decided to occupy such a part of Byteotia which:\n- is a triangle-shaped area whose vertices are three different vertices of the polygon island, and\n- brings the largest income, i.e., the sum of all gains and losses generated by factories within the occupied area is maximal.\n\nWe assume that a factory located on the border or at a vertex of the occupied area belongs to that area. A territory which contains no factory obviously brings zero income.\n\nByteasar, the King of Byteotia, is concerned about the amount of losses the Triangles' invasion could generate. Help him by writing a program that calculates the sum of gains and losses generated by the factories which the Triangles wish to capture.\n\nTask. Write a program that:\n- reads a description of Byteotia's shape and the locations of factories from the input,\n- determines the maximal sum of gains and losses generated by factories within a triangle whose vertices are three different vertices of the polygon island,\n- writes the result to the output.\n\nGiven a convex hull, and a number of resources (factories) inside or on its boundary, each with a weight, choose three different vertices on the convex hull to form a triangle such that the sum of the weights of the resources strictly inside or on the boundary of the triangle is maximized.\n\nThe number of convex hull vertices $n \\le 600$.\n\nThe number of resources $m \\le 10000$.", "inputFormat": "The first line contains a single integer $n$ ($3 \\le n \\le 600$), denoting the number of vertices of the polygon island.\n\nEach of the following $n$ lines contains two integers $x_j$ and $y_j$ ($-10\\ 000 \\le x_j, y_j \\le 10\\ 000$), separated by a single space, denoting the coordinates $x$ and $y$ of consecutive vertices of the island, in clockwise order.\n\nThe $(n+2)$-nd line contains a single integer $m$ ($1 \\le m \\le 10\\ 000$), denoting the total number of factories.\n\nEach of the following $m$ lines contains three integers $x_i'$, $y_i'$ and $w_i$ ($-10\\ 000 \\le x_i', y_i' \\le 10\\ 000$, $-100\\ 000 \\le w_i \\le 100\\ 000$), separated by single spaces, denoting the coordinates $x$ and $y$ of the $i$-th factory and the gain (for $w_i \\ge 0$) or loss (for $w_i < 0$) this factory generates, respectively. Each factory is situated on the polygon island, i.e., within it or on its border. Distinct factories may be located in the same place, i.e., have the same coordinates.", "outputFormat": "The first and only line should contain a single integer denoting the maximal sum of gains and losses generated by factories within a triangle whose vertices are three different vertices of the polygon island. Notice that it may happen that the outcome is a negative integer.", "hint": "The correct result is:\n\n![](https://cdn.luogu.com.cn/upload/pic/6970.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2006] NAJ-The Invasion", "background": "", "description": "And so it has come - the Triangles have invaded Byteotia!\n\nByteotia lies on an island, occupying its entire surface.\n\nThe shape of the island is a convex polygon(i.e. a polygon whose each inner angle is smaller than $180\\degree$).\n\nA certain number of software factories are located in Byteotia, each of which generates constant gains or losses.\n\nThe Triangles have decided to occupy such a part of Byteotia which:\n\nis a triangle-shaped area, the vertices of which are three different vertices of the polygon-island,     brings the largest income i.e. the sum of all gains and losses generated by factories within the occupied area is maximal.\n\nWe assume that a factory located on the border or in the vertex of occupied area belongs to that area. A territory which contains no factory brings, obviously, a zero income.\n\nByteasar, the King of Byteotia, is concerned by the amount of losses the Triangles' invasion could generate. Help him by writing a programme which shall calculate the sum of gains and losses generated by factories which the Triangles wish to capture.\n\nTaskWrite a programme which:\n\nreads a decription of Byteotia's shape and the locations of factories from the input file,     determines the maximal value of sum of all gains and losses generated by factories within a triangle, whose vertices are three different vertices of the polygon island,     writes the outcome to the output file.\n\n给定一个凸包， 并给出凸包内部或边上的若干个资源，每个资源都有权值,现在要在凸包上面选择不同的3个点，使得3个点组成的三角形\n内部的资源的权值之和最大。\n\n\n凸包点个数 $n \\le 600$\n\n\n资源个数 $m \\le 10000$\n", "inputFormat": "The first line of the input file contains a single integer $n$ ($3 \\le n \\le 600$), denoting the number of vertices of the polygon-island.\n\nThe following $n$ lines of the input contain two integers each $x_j$ and $y_j$ ($-10\\ 000 \\le x_j, y_j \\le 10\\ 000$), separated by a single space, denoting the coordinates $x$ and $y$ of consecutive vertices of the island, in a clockwise order.\n\nThe $(n+2)$-nd line contains a single integer $m$ ($1 \\le m \\le 10\\ 000$), denoting thetotal number of factories.\n\nIn each of the following $m$ lines there are three integers $x_i'$, $y_i'$ and $w_i$ ($-10\\ 000 \\le x_i', y_i' \\le 10\\ 000$, $-100\\ 000 \\le w_i \\le 100\\ 000$), separated by single spaces, denoting: the coordinates $x$ and $y$ of the $i$-th factory and the gain (for $w_i \\ge 0$) or loss (for $w_i < 0$) this factory generates, respectively. Each factory is situated on the polygon-island i.e. within or on the border of it. Distinct factories may be located in the same place i.e. have the same coordinates.\n", "outputFormat": "The first and only line of the output file should contain a single integer denoting the maximal value of sum of all gains and losses generated by factories within a triangle whose vertices are three different vertices of the polygon-island. Notice that it may happen that the outcome is a negative integer.\n", "hint": "the correct result is:\n\n![](https://cdn.luogu.com.cn/upload/pic/6970.png)\n", "locale": "zh-CN"}}}
{"pid": "P3443", "type": "P", "difficulty": 6, "samples": [["6 10\n1 5\n1 3\n4 1\n6 4\n3 6\n3 4\n4 3\n5 6\n6 2\n2 1\n4\n3 1 5 6\n3 3 4 3\n4 4 3 6 4\n3 5 6 2", "TAK\n1\n3\n4\n3\n6\n4\n1\n5\n6\n2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2006", "POI（波兰）", "Special Judge", "欧拉回路"], "title": "[POI 2006] LIS-The Postman", "background": "", "description": "每天早上，忙碌的邮递员需要经过城市的所有街道，完成投递邮件的任务。城市内的所有道路都是单向的，并通过一些路口连接起来。两个路口 $u,v$ 最多只有两条道路直接相连：一条 $u \\to v$，一条 $v \\to u$（也即不存在两条 $u \\to v$ 的街道）。所有路口从 $1$ 到 $n$ 编号。\n\n在路口 $1$，邮递员可以开始他的行程，或是结束他的行程。很长的一段时间里，邮递员可以随意选择他的路线，但最近新出的一条规定打乱了他的计划：每个邮递员得到了若干组路口序列，现在邮递员的路线必须满足如下要求：\n\n- 路线必须从路口 $1$ 开始，在路口 $1$ 结束。\n- 路线必须经过每条街道**恰好**一次。\n- 规定的每个路口序列都必须在路线中**连续**出现。例如：`1 2 1` 这个序列在 `1 2 1 3` 中出现了，而在 `1 2 3 1` 中没有出现（不是连续的）。\n\n现在邮递员找到了你，希望你能告诉他是否存在满足上述条件的路线，如果有的话，也请告诉他一条满足要求的路线。", "inputFormat": "输入第一行两个整数 $n,m$，分别为路口数和街道数。\n\n接下来 $m$ 行，每行两个整数 $a,b$，表示存在一条 $a \\to b$ 的街道。保证相同的街道不会重复给出，也不会有自环。\n\n下一行一个整数 $t$，代表规定的路口序列数。\n\n接下来 $t$ 行，每行第一个整数 $k$，接下来 $k$ 个数，代表一个规定的路口序列。", "outputFormat": "如果存在一个满足条件的路线，输出 `TAK`，否则输出 `NIE`。\n\n如果答案是 `TAK` 的话，请在接下来每行输出一个整数，代表一个满足条件的路线。\n\n设你输出了 $m+1$ 个数，输出的第 $i$ 个数为 $v_i$，你的输出需要满足如下条件：\n\n- $v_1=v_{m+1}=1$。\n- $\\forall 1 \\leq i \\leq m$，都存在 $v_i$ 到 $v_{i+1}$ 的街道。\n- 城市中的每条街道**恰好**出现一次。\n- 规定的每个路口序列都必须在路线中**连续**出现。", "hint": "所有数据均满足：$2 \\leq n \\leq 5 \\times 10^4$，$1 \\leq m \\leq 2 \\times 10^5$，$1 \\leq a,b \\leq n$，$a \\neq b$，$0 \\leq t \\leq 10^4$，$2 \\leq k \\leq 10^5$，$\\sum k \\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] LIS-The Postman", "background": "", "description": "Every morning, a busy postman needs to traverse all the city’s streets to deliver mail. All roads in the city are one-way and connected by intersections. For any two intersections $u, v$, there are at most two streets directly between them: one $u \\to v$ and one $v \\to u$ (i.e., there are no two $u \\to v$ streets). All intersections are numbered from $1$ to $n$.\n\nAt intersection $1$, the postman may start his trip or end his trip. For a long time, the postman could freely choose his route, but a new regulation has disrupted his plan: each postman has been given several sequences of intersections, and now his route must satisfy the following requirements:\n\n- The route must start at intersection $1$ and end at intersection $1$.\n- The route must traverse each street exactly once.\n- Each prescribed sequence of intersections must appear contiguously in the route. For example: the sequence `1 2 1` appears in `1 2 1 3`, but does not appear in `1 2 3 1` (not contiguous).\n\nThe postman asks you to determine whether there exists a route that satisfies the above conditions; if so, also provide one such route.", "inputFormat": "The first line contains two integers $n, m$, the number of intersections and the number of streets.\n\nThe next $m$ lines each contain two integers $a, b$, indicating there is a street $a \\to b$. It is guaranteed that identical streets are not repeated and there are no self-loops.\n\nThe next line contains an integer $t$, the number of prescribed intersection sequences.\n\nThe next $t$ lines each describe one prescribed sequence: the first integer is $k$, followed by $k$ integers giving the sequence.", "outputFormat": "If there exists a route that satisfies the conditions, output `TAK`; otherwise, output `NIE`.\n\nIf the answer is `TAK`, then output the route in the following lines, one integer per line.\n\nSuppose you output $m+1$ integers, where the $i$-th printed integer is $v_i$. Your output must satisfy the following conditions:\n\n- $v_1 = v_{m+1} = 1$.\n- For all $1 \\leq i \\leq m$, there exists a street from $v_i$ to $v_{i+1}$.\n- Each street in the city is used exactly once.\n- Each prescribed intersection sequence appears contiguously in the route.", "hint": "Constraints: $2 \\leq n \\leq 5 \\times 10^4$, $1 \\leq m \\leq 2 \\times 10^5$, $1 \\leq a, b \\leq n$, $a \\neq b$, $0 \\leq t \\leq 10^4$, $2 \\leq k \\leq 10^5$, $\\sum k \\leq 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2006] LIS-The Postman", "background": "", "description": "每天早上，忙碌的邮递员需要经过城市的所有街道，完成投递邮件的任务。城市内的所有道路都是单向的，并通过一些路口连接起来。两个路口 $u,v$ 最多只有两条道路直接相连：一条 $u \\to v$，一条 $v \\to u$（也即不存在两条 $u \\to v$ 的街道）。所有路口从 $1$ 到 $n$ 编号。\n\n在路口 $1$，邮递员可以开始他的行程，或是结束他的行程。很长的一段时间里，邮递员可以随意选择他的路线，但最近新出的一条规定打乱了他的计划：每个邮递员得到了若干组路口序列，现在邮递员的路线必须满足如下要求：\n\n- 路线必须从路口 $1$ 开始，在路口 $1$ 结束。\n- 路线必须经过每条街道**恰好**一次。\n- 规定的每个路口序列都必须在路线中**连续**出现。例如：`1 2 1` 这个序列在 `1 2 1 3` 中出现了，而在 `1 2 3 1` 中没有出现（不是连续的）。\n\n现在邮递员找到了你，希望你能告诉他是否存在满足上述条件的路线，如果有的话，也请告诉他一条满足要求的路线。", "inputFormat": "输入第一行两个整数 $n,m$，分别为路口数和街道数。\n\n接下来 $m$ 行，每行两个整数 $a,b$，表示存在一条 $a \\to b$ 的街道。保证相同的街道不会重复给出，也不会有自环。\n\n下一行一个整数 $t$，代表规定的路口序列数。\n\n接下来 $t$ 行，每行第一个整数 $k$，接下来 $k$ 个数，代表一个规定的路口序列。", "outputFormat": "如果存在一个满足条件的路线，输出 `TAK`，否则输出 `NIE`。\n\n如果答案是 `TAK` 的话，请在接下来每行输出一个整数，代表一个满足条件的路线。\n\n设你输出了 $m+1$ 个数，输出的第 $i$ 个数为 $v_i$，你的输出需要满足如下条件：\n\n- $v_1=v_{m+1}=1$。\n- $\\forall 1 \\leq i \\leq m$，都存在 $v_i$ 到 $v_{i+1}$ 的街道。\n- 城市中的每条街道**恰好**出现一次。\n- 规定的每个路口序列都必须在路线中**连续**出现。", "hint": "所有数据均满足：$2 \\leq n \\leq 5 \\times 10^4$，$1 \\leq m \\leq 2 \\times 10^5$，$1 \\leq a,b \\leq n$，$a \\neq b$，$0 \\leq t \\leq 10^4$，$2 \\leq k \\leq 10^5$，$\\sum k \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3444", "type": "P", "difficulty": 6, "samples": [["12 6 4\n6 0 4 8 0 5\n0 4 5 4 6 0\n0 5 6 5 6 0\n5 4 0 0 5 4", "8"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "POI（波兰）"], "title": "[POI 2006] ORK-Ploughing", "background": "", "description": "Byteasar, the farmer, wants to plough his rectangular field. He can begin with ploughing a slice from any of the field's edges, then he can plough a slice from any unploughed field's edges, and so on, until the whole field is ploughed. After the ploughing of every successive slice, the yet-unploughed field has a rectangular shape. Each slice has a span of $1$, and the length and width of the field are the integers $n$ and $m$.\n\nUnfortunately, Byteasar has only one puny and frail nag (horse) at his disposal for the ploughing. Once the nag starts to plough a slice, it won't stop until the slice is completely ploughed. However, if the slice is to much for the nag to bear, it will die of exhaustion, so Byteasar has to be careful. After every ploughed slice, the nag can rest and gather strength. The difficulty of certain parts of the field varies, but Byteasar is a good farmer and knows his field well, hence he knows every part's ploughing-difficulty.\n\nLet us divide the field into $m\\times n$ unitary squares - these are called tiles in short.\n\nWe identify them by their coordinates $(i,j)$, for $1\\le i\\le m$ and $1\\le j\\le n$.\n\nEach tile has its ploughing-difficulty - a non-negative integer.\n\nLet $t_{i,j}$ denote the difficulty of the tile which coordinates are $(i,j)$.\n\n\nFor every slice, the sum of ploughing-difficulties of the tiles forming it up cannot exceed a certain constant $k$ - lest the nag dies.\n\nA difficult task awaits Byteasar: before ploughing each subsequent slice he has to decide which edge of the field he'll plough, so that the nag won't die. On the other hand, he'd like to plough as few slices as possible.\n\nTaskWrite a programme that:\n\nreads the numbers $k$,$m$ and $n$ from the input file, as well as the ploughing-difficulty coefficients,     determines the best way to plough Byteasar's field,     writes the result to the output file.\n\nByteasar想耕种他那块矩形的田，他每次能耕种矩形的一边（上下左右都行），在他每次耕完后，剩下的田也一定是矩形，每块小区域边长为$1$，耕地的长宽分别为$m$和$n$，不幸的是Byteasar只有一匹老弱的马，从马开始耕地开始，只有当它耕完了一边才会停下休息。但有些地会非常难耕以至于马会非常的累，因此Byteasar需要特别小心。当耕完了一边之后，马可以停下来休息恢复体力。每块地耕种的难度不一，但是Byteasar都非常清楚。我们将地分成$m\\times n$块单位矩形——我们用坐标$(i,j)$来定义它们。每块地都有一个整数$t_{i,j}$,来定义$(i,j)$的耕种难度。所以每次马耕一边地时的难度就是所有它耕种的地的难度总和，对于这匹虚弱的马而言，这个值不能超过他的体力值。Byteasar想知道在马不死掉的情况下最少需要耕多少次才能把地耕完。\n", "inputFormat": "There are three positive integers in the first line of the input file: $k$,$m$ and $n$,separated by single spaces, $1\\le k\\le 200\\ 000\\ 000$,$1\\le m,n\\le 2000$.\n\nIn the following $n$ lines there are the ploughing-difficulty coefficients.\n\nThe line no. $j+1$ contains the coefficients $t_{1,j},t_{2,j}...,t_{n,m}$, separated by single spaces,$0\\le t_{i,j}\\le 100\\ 000$.\n", "outputFormat": "Your programme should write one integer to the output file: the minimum number of slices required to plough the field while satisfying the given conditions. Since we care for animals, we guarantee that the field can be ploughed according to the above rules. But remember, saving the nag is up to you!\n", "hint": "感谢@NaVi\\_Awson 提供翻译\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] ORK-Ploughing", "background": "", "description": "Byteasar, the farmer, wants to plough his rectangular field. He can begin by ploughing a slice from any of the field’s edges; then he can plough a slice from any edge of the remaining unploughed field, and so on, until the whole field is ploughed. After each slice is ploughed, the yet-unploughed field is still a rectangle. Each slice has a span of $1$, and the field is divided into $m\\times n$ unit tiles.\n\nWe identify the tiles by their coordinates $(i,j)$, for $1\\le i\\le m$ and $1\\le j\\le n$. Each tile has a non-negative ploughing-difficulty. Let $t_{i,j}$ denote the difficulty of the tile with coordinates $(i,j)$.\n\nByteasar has only one puny and frail nag (horse). Once the nag starts to plough a slice, it will not stop until the slice is completely ploughed. However, if the slice is too much for the nag to bear, it will die of exhaustion, so Byteasar has to be careful. After every ploughed slice, the nag can rest and gather strength. For every slice, the sum of ploughing-difficulties of the tiles forming it cannot exceed a certain constant $k$.\n\nDetermine the minimum number of slices required to plough the entire field without exceeding the limit $k$ on any slice. It is guaranteed that there exists a way to plough the field according to the above rules.", "inputFormat": "- The first line contains three positive integers $k$, $m$ and $n$, separated by single spaces, where $1\\le k\\le 200\\ 000\\ 000$ and $1\\le m,n\\le 2000$.\n- The next $m$ lines contain the ploughing-difficulty coefficients. Specifically, line $i+1$ ($1\\le i\\le m$) contains $n$ integers $t_{i,1}, t_{i,2}, \\ldots, t_{i,n}$, separated by single spaces, where $0\\le t_{i,j}\\le 100\\ 000$.", "outputFormat": "Output one integer: the minimum number of slices required to plough the field while satisfying the given conditions. It is guaranteed that a valid ploughing exists.", "hint": "Thanks to @NaVi_Awson for the translation.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2006] ORK-Ploughing", "background": "", "description": "Byteasar, the farmer, wants to plough his rectangular field. He can begin with ploughing a slice from any of the field's edges, then he can plough a slice from any unploughed field's edges, and so on, until the whole field is ploughed. After the ploughing of every successive slice, the yet-unploughed field has a rectangular shape. Each slice has a span of $1$, and the length and width of the field are the integers $n$ and $m$.\n\nUnfortunately, Byteasar has only one puny and frail nag (horse) at his disposal for the ploughing. Once the nag starts to plough a slice, it won't stop until the slice is completely ploughed. However, if the slice is to much for the nag to bear, it will die of exhaustion, so Byteasar has to be careful. After every ploughed slice, the nag can rest and gather strength. The difficulty of certain parts of the field varies, but Byteasar is a good farmer and knows his field well, hence he knows every part's ploughing-difficulty.\n\nLet us divide the field into $m\\times n$ unitary squares - these are called tiles in short.\n\nWe identify them by their coordinates $(i,j)$, for $1\\le i\\le m$ and $1\\le j\\le n$.\n\nEach tile has its ploughing-difficulty - a non-negative integer.\n\nLet $t_{i,j}$ denote the difficulty of the tile which coordinates are $(i,j)$.\n\n\nFor every slice, the sum of ploughing-difficulties of the tiles forming it up cannot exceed a certain constant $k$ - lest the nag dies.\n\nA difficult task awaits Byteasar: before ploughing each subsequent slice he has to decide which edge of the field he'll plough, so that the nag won't die. On the other hand, he'd like to plough as few slices as possible.\n\nTaskWrite a programme that:\n\nreads the numbers $k$,$m$ and $n$ from the input file, as well as the ploughing-difficulty coefficients,     determines the best way to plough Byteasar's field,     writes the result to the output file.\n\nByteasar想耕种他那块矩形的田，他每次能耕种矩形的一边（上下左右都行），在他每次耕完后，剩下的田也一定是矩形，每块小区域边长为$1$，耕地的长宽分别为$m$和$n$，不幸的是Byteasar只有一匹老弱的马，从马开始耕地开始，只有当它耕完了一边才会停下休息。但有些地会非常难耕以至于马会非常的累，因此Byteasar需要特别小心。当耕完了一边之后，马可以停下来休息恢复体力。每块地耕种的难度不一，但是Byteasar都非常清楚。我们将地分成$m\\times n$块单位矩形——我们用坐标$(i,j)$来定义它们。每块地都有一个整数$t_{i,j}$,来定义$(i,j)$的耕种难度。所以每次马耕一边地时的难度就是所有它耕种的地的难度总和，对于这匹虚弱的马而言，这个值不能超过他的体力值。Byteasar想知道在马不死掉的情况下最少需要耕多少次才能把地耕完。\n", "inputFormat": "There are three positive integers in the first line of the input file: $k$,$m$ and $n$,separated by single spaces, $1\\le k\\le 200\\ 000\\ 000$,$1\\le m,n\\le 2000$.\n\nIn the following $n$ lines there are the ploughing-difficulty coefficients.\n\nThe line no. $j+1$ contains the coefficients $t_{1,j},t_{2,j}...,t_{n,m}$, separated by single spaces,$0\\le t_{i,j}\\le 100\\ 000$.\n", "outputFormat": "Your programme should write one integer to the output file: the minimum number of slices required to plough the field while satisfying the given conditions. Since we care for animals, we guarantee that the field can be ploughed according to the above rules. But remember, saving the nag is up to you!\n", "hint": "感谢@NaVi\\_Awson 提供翻译\n", "locale": "zh-CN"}}}
{"pid": "P3445", "type": "P", "difficulty": 6, "samples": [["7 2 3", "420"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "POI（波兰）"], "title": "[POI 2006] TAN-Dancing in Circles", "background": null, "description": "幼儿园中有 $N$ 个小朋友在做游戏，每天小朋友们都会有一个尬舞方案（围成 $K$ 个圈尬舞）。\n\n每个圈子里至少有 $L$ 个小朋友，如果在一个方案里有一个小朋友他右面的小朋友和另一个方案里他右面的小朋友不同，那么两个尬舞方案就会被认为是不同的。\n\n你的任务是计算所有不同的尬舞方案的数量，因为结果可能比较大，所以最后输出答案 $d\\bmod 2005$ 的结果。\n\n如果没有符合要求的尬舞方案，输出 $0$。", "inputFormat": "只有一行输入，三个整数 $N,K,L$ （$3\\leq N\\leq 10^9; 1\\leq K\\leq N; 2\\leq L\\leq N$）分别代表小朋友数量，圈子数量，每个圈子里最少的小朋友数。", "outputFormat": "只有一行输出，即合理的尬舞方案数 $d\\bmod2005$。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] TAN-Dancing in Circles", "background": null, "description": "$n$ kids attend a certain kindergarten. Everyday the kids arrange themselves in $k$ circles and dance.\n\nAt least $l$ kids dance in each circle. Two arrangements of children are considered distinct if there is a child who has a different right neighbour in one of the arrangements than in the other.\n\nYour task is to calculate the number of all distinct arrangements modulo $2005$. Should there beno arrangements satisfying the aforementioned conditions, the correct outcome is $0$.\n\nWrite a programme which:\n\nreads the numbers $n$, $k$ and $l$ from the standard input, calculates the number $d'=d \\bmod 2005$, where $d$ denotes the number of distinct arrangements of the children (\"$d \\bmod 2005$\" denotes the remainder of the division of $d$ by $2005$), writes $d'$ to the standard output.", "inputFormat": "The first and only line of the standard input contains three integers separated by single spaces: $n$- the number of children ($3\\le n\\le 10^9$), $k$ - the number of circles ($1\\le k\\le n$) and $l$ - the minimal number of kids in a circle ($2\\le l\\le n$).", "outputFormat": "The first and only line of the standard output should contain a single integer: $d \\bmod2005$.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[POI 2006] TAN-Dancing in Circles", "background": null, "description": "幼儿园中有 $N$ 个小朋友在做游戏，每天小朋友们都会有一个尬舞方案（围成 $K$ 个圈尬舞）。\n\n每个圈子里至少有 $L$ 个小朋友，如果在一个方案里有一个小朋友他右面的小朋友和另一个方案里他右面的小朋友不同，那么两个尬舞方案就会被认为是不同的。\n\n你的任务是计算所有不同的尬舞方案的数量，因为结果可能比较大，所以最后输出答案 $d\\bmod 2005$ 的结果。\n\n如果没有符合要求的尬舞方案，输出 $0$。", "inputFormat": "只有一行输入，三个整数 $N,K,L$ （$3\\leq N\\leq 10^9; 1\\leq K\\leq N; 2\\leq L\\leq N$）分别代表小朋友数量，圈子数量，每个圈子里最少的小朋友数。", "outputFormat": "只有一行输出，即合理的尬舞方案数 $d\\bmod2005$。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3446", "type": "P", "difficulty": 6, "samples": [["6 4\n4 3 2 5", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "POI（波兰）"], "title": "[POI 2006] EST-Aesthetic Text", "background": "", "description": "Let us consider a text consisting of n words numbered from 1 to n. We represent any of its decompositions into k lines by a sequence of numbers (a\\_1,a\\_2...a\\_{k-1}), such that the words with numbers from 1 to a\\_1 are in the first line, the words with umbers from a\\_1 + 1 to a\\_2 are in the second line, and so on, and finally, the words with numbers from a\\_{k-1} + 1 to n are in the last, k-th line.\n\n\nEach word has a certain length (measured in the number of characters). Let length(x) denote the length of the word no. . Furthermore, every two subsequent words in a line are separated by a space of width of a single character. By length of the line we denote the sum of lengths of the words in this line, increased by the number of spaces between them. Let line(w) denote the length of the line no.w . I.e., if the line no.w contains the words with numbers from i to j inclusive, its length is:\n\n\n\n\n\n```cpp\nXXXX (1st line)\nXXX XX (2nd line)\nXXXXX (3rd line)\n```\n\nline(w)=length(i)+..length(j)+(j-i)\n\nAs an example, let us consider a text consisting of 4 words of lengths 4, 3, 2 and 5, respectively, and its decomposition (1,3) into 3 lines. Then the length of the first line is 4, second -6 , and third -5 :\n\nWe shall refer to the number\n\n\n|line(1)-line(2)|+...+|line(k-1)-line(k)|\n\nas the coefficient of aestheticism of a decomposition of the given text into k lines. Particularly, if the decomposition has only one line, its coefficient of aestheticism is 0.\n\n\nNeedles to say, the smaller the coefficient, the more aesthetical the decomposition. We shall consider only these decompositions that have no line whose length exceeds some constant m. Of all such decompositions of a given text into any number of lines we seek the one most aesthetical, i.e. the one with the smallest coefficient of aestheticism. The aforementioned examplary decomposition's coefficient is 3, and that is exactly the minimum coefficient of aestheticism for m=6 and m=7.\n", "inputFormat": "The first line of the standard input contains the numbers $m$ and $n$, $1\\le m\\le 1\\ 000\\ 000$,$1\\le n\\le 2\\ 000$, separated by a single space. The second, last line of the standard input contains $n$ integers, denotingthe lengths of subsequent words, $1\\le length(i)\\le m$ for $i=1,2,\\cdots,n$, separated by single spaces.\n", "outputFormat": "The first and only line of the standard output should contain exactly one integer: the minimumcoefficient of aestheticism for those decompositions, whose every line's length does not exceed $m$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2006] EST-Aesthetic Text", "background": "", "description": "Let us consider a text consisting of n words numbered from 1 to n. We represent any of its decompositions into k lines by a sequence of numbers (a\\_1,a\\_2...a\\_{k-1}), such that the words with numbers from 1 to a\\_1 are in the first line, the words with umbers from a\\_1 + 1 to a\\_2 are in the second line, and so on, and finally, the words with numbers from a\\_{k-1} + 1 to n are in the last, k-th line.\n\n\nEach word has a certain length (measured in the number of characters). Let length(x) denote the length of the word no. . Furthermore, every two subsequent words in a line are separated by a space of width of a single character. By length of the line we denote the sum of lengths of the words in this line, increased by the number of spaces between them. Let line(w) denote the length of the line no.w . I.e., if the line no.w contains the words with numbers from i to j inclusive, its length is:\n\n\n\n\n\n```cpp\nXXXX (1st line)\nXXX XX (2nd line)\nXXXXX (3rd line)\n```\n\nline(w)=length(i)+..length(j)+(j-i)\n\nAs an example, let us consider a text consisting of 4 words of lengths 4, 3, 2 and 5, respectively, and its decomposition (1,3) into 3 lines. Then the length of the first line is 4, second -6 , and third -5 :\n\nWe shall refer to the number\n\n\n|line(1)-line(2)|+...+|line(k-1)-line(k)|\n\nas the coefficient of aestheticism of a decomposition of the given text into k lines. Particularly, if the decomposition has only one line, its coefficient of aestheticism is 0.\n\n\nNeedles to say, the smaller the coefficient, the more aesthetical the decomposition. We shall consider only these decompositions that have no line whose length exceeds some constant m. Of all such decompositions of a given text into any number of lines we seek the one most aesthetical, i.e. the one with the smallest coefficient of aestheticism. The aforementioned examplary decomposition's coefficient is 3, and that is exactly the minimum coefficient of aestheticism for m=6 and m=7.\n", "inputFormat": "The first line of the standard input contains the numbers $m$ and $n$, $1\\le m\\le 1\\ 000\\ 000$,$1\\le n\\le 2\\ 000$, separated by a single space. The second, last line of the standard input contains $n$ integers, denotingthe lengths of subsequent words, $1\\le length(i)\\le m$ for $i=1,2,\\cdots,n$, separated by single spaces.\n", "outputFormat": "The first and only line of the standard output should contain exactly one integer: the minimumcoefficient of aestheticism for those decompositions, whose every line's length does not exceed $m$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2006] EST-Aesthetic Text", "background": "", "description": "让我们考虑一个由 $n$ 个单词组成的文本，这些单词从 1 到 $n$ 编号。我们用一个数列 $(a_1, a_2, \\ldots, a_{k-1})$ 来表示将其分解为 $k$ 行的任意方式，使得编号从 1 到 $a_1$ 的单词在第一行，编号从 $a_1 + 1$ 到 $a_2$ 的单词在第二行，依此类推，最后编号从 $a_{k-1} + 1$ 到 $n$ 的单词在最后一行，即第 $k$ 行。\n\n每个单词都有一定的长度（以字符数衡量）。令 $length(x)$ 表示第 $x$ 个单词的长度。此外，行中的每两个相邻单词之间用一个字符宽度的空格隔开。行的长度被定义为该行中单词长度的总和，加上它们之间的空格数。令 $line(w)$ 表示第 $w$ 行的长度。即，如果第 $w$ 行包含编号从 $i$ 到 $j$ 的单词（包括 $i$ 和 $j$），其长度为：\n\n```cpp\nXXXX (第 1 行)\nXXX XX (第 2 行)\nXXXXX (第 3 行)\n```\n\n$$line(w) = length(i) + \\ldots + length(j) + (j-i)$$\n\n例如，考虑一个由 4 个单词组成的文本，其长度分别为 4, 3, 2 和 5，以及将其分解为 3 行的方式 (1,3)。那么第一行的长度是 4，第二行是 6，第三行是 5：\n\n我们称数值\n\n$$|line(1) - line(2)| + \\ldots + |line(k-1) - line(k)|$$\n\n为将给定文本分解为 $k$ 行的美学系数。特别地，如果分解只有一行，其美学系数为 0。\n\n不言而喻，系数越小，分解越美观。我们只考虑那些没有行长度超过某个常数 $m$ 的分解。在所有这样的分解中，我们寻找最美观的，即美学系数最小的分解。上述示例分解的系数是 3，这正是 $m=6$ 和 $m=7$ 时美学系数的最小值。", "inputFormat": "标准输入的第一行包含两个数字 $m$ 和 $n$，$1 \\le m \\le 1\\ 000\\ 000$，$1 \\le n \\le 2\\ 000$，以单个空格分隔。标准输入的第二行（也是最后一行）包含 $n$ 个整数，表示后续单词的长度，$1 \\le length(i) \\le m$ 对于 $i=1,2,\\cdots,n$，以单个空格分隔。", "outputFormat": "标准输出的第一行且唯一一行应包含一个整数：对于那些每行长度不超过 $m$ 的分解，最小的美学系数。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3447", "type": "P", "difficulty": 6, "samples": [["3\n2 1 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "POI（波兰）"], "title": "[POI 2006] KRY-Crystals", "background": "", "description": "Byteman is a scientist who investigates creation of crystals consisting of atoms of different elements.\n\nHe has designed a special process for creating crystals and has discovered a formula specifying theamount of elements that can be used to create a crystal. Now, he wonders how many differentcrystals can be created in such process.\n\nFor non-negative integers $x$ and $y$, by $x\\bigoplus y$ we shall denote their bit-wise xor. The basic xor forsingle bits is defined by:\n\n$1\\bigoplus 1=0\\bigoplus 0=0$,$0\\bigoplus 1=1\\bigoplus 0=1$.\n\nByteman knows $n$ different elements that can be used to create crystals -these are numbered from $1$ to $n$. For each element $i$ there is an upper bound $m_i$ on number of atoms of this elementthat can be used to create a crystal. Byteman can create one unique crystal composed of $a_i$ atomsof the element $i$ (for $i=1,\\cdots,n$), if and only if:\n\n- $0\\le a_i\\le m_i$ for $i=1,\\cdots,n$\n\n- $a_1\\bigoplus\\cdots\\bigoplus a_n=0$, and\n\n- $a_1+a_2+\\cdots+a_n\\ge 1$.\n\nNote that the last condition is quite obvious and essentially states that every crystal is composed ofat least one atom.\n\nTaskWrite a programme which:\n\nreads form the standard input: the number of elements and the bounds on numbers of atoms    of particular elements,        computes the number of different crystals that can be created,        writes the result to the standard output.", "inputFormat": "The first line of the standard input contains the number of elements $n$, $1\\le n\\le 50$.\n\nThe second, last line of the standard input contains $n$ positive integers $m_1,\\cdots,m_n$, separated by single spaces,$1\\le m_i<2^{32}-1$.\n", "outputFormat": "Your programme should write one integer to the standard output - total number of different crystals  that can be created. You can assume that this number is less than $2^{64}$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2006] KRY-Crystals", "background": "", "description": "Byteman is a scientist who investigates creation of crystals consisting of atoms of different elements.\n\nHe has designed a special process for creating crystals and has discovered a formula specifying theamount of elements that can be used to create a crystal. Now, he wonders how many differentcrystals can be created in such process.\n\nFor non-negative integers $x$ and $y$, by $x\\bigoplus y$ we shall denote their bit-wise xor. The basic xor forsingle bits is defined by:\n\n$1\\bigoplus 1=0\\bigoplus 0=0$,$0\\bigoplus 1=1\\bigoplus 0=1$.\n\nByteman knows $n$ different elements that can be used to create crystals -these are numbered from $1$ to $n$. For each element $i$ there is an upper bound $m_i$ on number of atoms of this elementthat can be used to create a crystal. Byteman can create one unique crystal composed of $a_i$ atomsof the element $i$ (for $i=1,\\cdots,n$), if and only if:\n\n- $0\\le a_i\\le m_i$ for $i=1,\\cdots,n$\n\n- $a_1\\bigoplus\\cdots\\bigoplus a_n=0$, and\n\n- $a_1+a_2+\\cdots+a_n\\ge 1$.\n\nNote that the last condition is quite obvious and essentially states that every crystal is composed ofat least one atom.\n\nTaskWrite a programme which:\n\nreads form the standard input: the number of elements and the bounds on numbers of atoms    of particular elements,        computes the number of different crystals that can be created,        writes the result to the standard output.", "inputFormat": "The first line of the standard input contains the number of elements $n$, $1\\le n\\le 50$.\n\nThe second, last line of the standard input contains $n$ positive integers $m_1,\\cdots,m_n$, separated by single spaces,$1\\le m_i<2^{32}-1$.\n", "outputFormat": "Your programme should write one integer to the standard output - total number of different crystals  that can be created. You can assume that this number is less than $2^{64}$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2006] KRY-Crystals", "background": "", "description": "给定 $n$ 个正整数 $m_1$ 到 $m_n$，对长度为 $n$ 且满足以下条件的整数序列 $a$ 计数：\n- 对于任意 $1\\le i\\le n$，$0\\le a_i\\le m_i$；\n- $a_1\\oplus a_2\\oplus\\cdots\\oplus a_n=0$，其中 $\\oplus$ 为按位异或运算；\n- $a_1+a_2+\\cdots+a_n\\ge1$。", "inputFormat": "第一行有一个正整数 $n$。\n\n第二行有 $n$ 个正整数，表示 $m_1,m_2,\\ldots,m_n$。", "outputFormat": "输出一行一个正整数表示序列的个数。", "hint": "$1\\le n\\le50$。\n\n$1\\le m_i\\le2^{32}-1$。\n\n数据保证答案小于 $2^{64}$。\n\n感谢 @FZzzz @UnyieldingTrilobite 提供翻译。", "locale": "zh-CN"}}}
{"pid": "P3448", "type": "P", "difficulty": 4, "samples": [["0 1 2 1", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "POI（波兰）"], "title": "[POI 2006] MIS-Teddies", "background": "", "description": "Byteoian 是一家专业生产儿童玩具的公司。他们生产的玩具质量上乘，广受好评。\n\n但最近，有人发现他们生产的泰迪熊存在致命缺陷。总共有四种泰迪熊型号：$A1$，$A2$，$B1$，$B2$，一旦将三个字母相同或数字相同的泰迪熊放在一块，就会对泰迪熊造成致命损坏。\n\n如果一种摆放泰迪熊的方案中不存在连续三个字母相同或数字相同的泰迪熊，则称这种摆放方案是**安全的**。\n\n现在你收集了一些泰迪熊，你想要知道有多少种安全的摆放泰迪熊的方案。由于安全的方案可能较多，请输出方案数对 $1\\,000\\,000$ 取模的结果。", "inputFormat": "输入包含四个整数：$n_{A1},n_{A2},n_{B1},n_{B2}$，分别代表 $A1$ 型，$A2$ 型，$B1$ 型，$B2$ 型泰迪熊的数量。", "outputFormat": "输出一个整数，即安全摆放泰迪熊的方案数对 $1\\,000\\,000$ 取模的结果。", "hint": "$0 \\leq n_{A1},n_{A2},n_{B1},n_{B2} \\leq 38$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2006] MIS-Teddies", "background": "", "description": "Byteoian is a company specializing in children's toys. Their products are of high quality and well received.\n\nHowever, it was recently discovered that their teddy bears have a fatal flaw. There are four models of teddy bears: $A1$, $A2$, $B1$, $B2$. If three teddy bears with the same letter or the same digit are placed together, it will cause fatal damage.\n\nAn arrangement of teddy bears is called safe if there are no three consecutive teddy bears with the same letter or the same digit.\n\nYou have collected some teddy bears and want to know how many safe arrangements in a row of all these teddy bears exist. Since the number of safe arrangements can be large, output the result modulo $1\\,000\\,000$.", "inputFormat": "The input contains four integers: $n_{A1}, n_{A2}, n_{B1}, n_{B2}$, which denote the numbers of type $A1$, $A2$, $B1$, and $B2$ teddy bears, respectively.", "outputFormat": "Output a single integer, the number of safe arrangements modulo $1\\,000\\,000$.", "hint": "Constraints: $0 \\leq n_{A1}, n_{A2}, n_{B1}, n_{B2} \\leq 38$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2006] MIS-Teddies", "background": "", "description": "Byteoian 是一家专业生产儿童玩具的公司。他们生产的玩具质量上乘，广受好评。\n\n但最近，有人发现他们生产的泰迪熊存在致命缺陷。总共有四种泰迪熊型号：$A1$，$A2$，$B1$，$B2$，一旦将三个字母相同或数字相同的泰迪熊放在一块，就会对泰迪熊造成致命损坏。\n\n如果一种摆放泰迪熊的方案中不存在连续三个字母相同或数字相同的泰迪熊，则称这种摆放方案是**安全的**。\n\n现在你收集了一些泰迪熊，你想要知道有多少种安全的摆放泰迪熊的方案。由于安全的方案可能较多，请输出方案数对 $1\\,000\\,000$ 取模的结果。", "inputFormat": "输入包含四个整数：$n_{A1},n_{A2},n_{B1},n_{B2}$，分别代表 $A1$ 型，$A2$ 型，$B1$ 型，$B2$ 型泰迪熊的数量。", "outputFormat": "输出一个整数，即安全摆放泰迪熊的方案数对 $1\\,000\\,000$ 取模的结果。", "hint": "$0 \\leq n_{A1},n_{A2},n_{B1},n_{B2} \\leq 38$。", "locale": "zh-CN"}}}
{"pid": "P3449", "type": "P", "difficulty": 6, "samples": [["6\n2 aa\n3 aba\n3 aaa\n6 abaaba\n5 aaaaa\n4 abba", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2006", "POI（波兰）", "哈希 hashing", "字典树 Trie"], "title": "[POI 2006] PAL-Palindromes", "background": "", "description": "Little Johnny enjoys playing with words. He has chosen $n$ palindromes (a palindrome is a wordthat reads the same when the letters composing it are taken in the reverse order, such as dad, eye orracecar for instance) then generated all $n^2$ possible pairs of them and concatenated the pairs intosingle words. Lastly, he counted how many of the so generated words are palindromes themselves.\n\nHowever, Johnny cannot be certain of not having comitted a mistake, so he has asked you to repeatthe very same actions and to give him the outcome. Write a programme which shall perform thistask for you.\n\nTaskWrite a programme which:\n\nreads the palindromes given by Johnny from the standard input,        determines the number of words formed out of pairs of palindromes from the input, which are palindromes    themselves,        writes the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains a single integer $n$, $n\\ge 2$, denoting the number ofpalindromes given by Johnny. The following $n$ lines contain a description of the palindromes. The $(i+1)$'st line contains a single positive integer $a_i$ denoting the length of $i$'th palindrome and apalindrome of $a_i$ small letters of English alphabet. The number $a_i$ is separated from the palindromeby a single space. The palindromes in distinct lines are distinct. The total length of all palindromesdoes not exceed $2\\ 000\\ 000$.\n", "outputFormat": "The first and only line of the standard output should contain a single integer: the number of distinctordered pairs of palindromes which form a palindrome upon being concatenated.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2006] PAL-Palindromes", "background": "", "description": "Little Johnny enjoys playing with words. He has chosen $n$ palindromes (a palindrome is a wordthat reads the same when the letters composing it are taken in the reverse order, such as dad, eye orracecar for instance) then generated all $n^2$ possible pairs of them and concatenated the pairs intosingle words. Lastly, he counted how many of the so generated words are palindromes themselves.\n\nHowever, Johnny cannot be certain of not having comitted a mistake, so he has asked you to repeatthe very same actions and to give him the outcome. Write a programme which shall perform thistask for you.\n\nTaskWrite a programme which:\n\nreads the palindromes given by Johnny from the standard input,        determines the number of words formed out of pairs of palindromes from the input, which are palindromes    themselves,        writes the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains a single integer $n$, $n\\ge 2$, denoting the number ofpalindromes given by Johnny. The following $n$ lines contain a description of the palindromes. The $(i+1)$'st line contains a single positive integer $a_i$ denoting the length of $i$'th palindrome and apalindrome of $a_i$ small letters of English alphabet. The number $a_i$ is separated from the palindromeby a single space. The palindromes in distinct lines are distinct. The total length of all palindromesdoes not exceed $2\\ 000\\ 000$.\n", "outputFormat": "The first and only line of the standard output should contain a single integer: the number of distinctordered pairs of palindromes which form a palindrome upon being concatenated.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2006] PAL-Palindromes", "background": null, "description": "Johnny 喜欢玩文字游戏。\n\n他写下了 $n$ 个回文串，随后将这些串两两组合，合并成一个新串。容易看出，一共会有 $n^2$ 个新串。\n\n两个串组合时顺序是任意的，即 `a` 和 `b` 可以组合成 `ab` 和 `ba`，另外自己和自己组合也是允许的。\n\n现在他想知道这些新串中有多少个回文串，你能帮帮他吗？", "inputFormat": "第一行一个整数 $n$，保证 $n \\ge 2$。\n\n接下来 $n$ 行，第 $i$ 行包含一个数 $a_i$ 和一个长度为 $a_i$ 的回文串。\n\n保证所有串只包含小写字母，且所有串两两不同，所有回文串的长度和不超过 $2 \\times 10^6$。", "outputFormat": "输出一个整数，代表满足条件的新串的数量。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3450", "type": "P", "difficulty": 6, "samples": [["9 4\n12\n9 6\n4 6\n7 9\n1 2\n2 1\n9 7\n7 6\n4 5\n7 8\n8 9\n3 4\n4 3", "5\n1 3 5 6 8"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2006", "POI（波兰）", "Special Judge"], "title": "[POI 2006] ZOS-Sophie", "background": null, "description": "Little Sophie gives a birthday party. She has written a tentative list of her kindergarten friendsshe would like to invite. However, kids are very demanding guests. Mary said she should come, butonly provided Camille and Emily are not present, for they took her doll last week. Little Christopheronly plays with Sophie and Camille and he does not wish to see any other kids at the party. And soon...\n\nSophie considers a party a success if none of the guests invited has objection against any other'spresence. She has decided not to invite certain kids to assure that the party is a success. On theother hand she would like to invite as many kids as possible. Should Sophie not be able to invite atleast $k$ kids she won't give any party at all.\n\n## Task\n\nHelp little Sophie! Write a programme which:\n\n- reads the number of all Sophie's acquaintances $n$, the number $k$ and a description of kids' demands from the standard input,\n\n- verifies if it is possible to invite at least $k$ kids so that the party could be a success,\n\n- if it is not possible, writes the word NIE (i.e. no in Polish)  to the standard output; if it is possible, finds the largest group of kids who could be invited to the party so that it is a success and  writes it to the standard output.", "inputFormat": "The first line of the standard input contains two positive integers separated by a single space:\n\n$n$ - the number of all Sophie's acquaintances ($2 \\le n \\le 1000\\ 000$) and $k$ -the minimal number of kids Sophie wishes to invite to the party($n-10 \\le k < n$). The kids are assigned numbers from therange $1$ to $n$.\n\nThe following lines contain a description of kids' demands. In the second line there is a singleinteger $m$, $1 \\le m \\le 3\\ 000\\ 000$\n\nEach of the following $m$ lines contains a pair of integers $a$, $b$, separated by a single space ($1 \\le a,b, \\le n, a \\neq b$). You can assume that each (ordered) pair appears in the standard input once at the most. The pair $a$, $b$ denotes that the child $a$ does not wish to meet child $b$ at the party.", "outputFormat": "If it is not possible to invite $k$ kids to the party so that it is a success then the first and only line ofthe standard output should contain a single word: NIE.\n\nIf it is possible, then the first line of the standard input should contain a single integer - themaximal number of kids that can be invited to the party so that it is a success.\n\nThe second line of the standard output should contain the numbers of kids to be invited, separated by single spaces, inincreasing order. Should there be more correct answers your programme should write out any oneof them.", "hint": null, "locale": "en", "translations": {"en": {"title": "[POI 2006] ZOS-Sophie", "background": null, "description": "Little Sophie gives a birthday party. She has written a tentative list of her kindergarten friendsshe would like to invite. However, kids are very demanding guests. Mary said she should come, butonly provided Camille and Emily are not present, for they took her doll last week. Little Christopheronly plays with Sophie and Camille and he does not wish to see any other kids at the party. And soon...\n\nSophie considers a party a success if none of the guests invited has objection against any other'spresence. She has decided not to invite certain kids to assure that the party is a success. On theother hand she would like to invite as many kids as possible. Should Sophie not be able to invite atleast $k$ kids she won't give any party at all.\n\n## Task\n\nHelp little Sophie! Write a programme which:\n\n- reads the number of all Sophie's acquaintances $n$, the number $k$ and a description of kids' demands from the standard input,\n\n- verifies if it is possible to invite at least $k$ kids so that the party could be a success,\n\n- if it is not possible, writes the word NIE (i.e. no in Polish)  to the standard output; if it is possible, finds the largest group of kids who could be invited to the party so that it is a success and  writes it to the standard output.", "inputFormat": "The first line of the standard input contains two positive integers separated by a single space:\n\n$n$ - the number of all Sophie's acquaintances ($2 \\le n \\le 1000\\ 000$) and $k$ -the minimal number of kids Sophie wishes to invite to the party($n-10 \\le k < n$). The kids are assigned numbers from therange $1$ to $n$.\n\nThe following lines contain a description of kids' demands. In the second line there is a singleinteger $m$, $1 \\le m \\le 3\\ 000\\ 000$\n\nEach of the following $m$ lines contains a pair of integers $a$, $b$, separated by a single space ($1 \\le a,b, \\le n, a \\neq b$). You can assume that each (ordered) pair appears in the standard input once at the most. The pair $a$, $b$ denotes that the child $a$ does not wish to meet child $b$ at the party.", "outputFormat": "If it is not possible to invite $k$ kids to the party so that it is a success then the first and only line ofthe standard output should contain a single word: NIE.\n\nIf it is possible, then the first line of the standard input should contain a single integer - themaximal number of kids that can be invited to the party so that it is a success.\n\nThe second line of the standard output should contain the numbers of kids to be invited, separated by single spaces, inincreasing order. Should there be more correct answers your programme should write out any oneof them.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[POI 2006] ZOS-Sophie", "background": null, "description": "小 Sophie 要举办生日派对。她列了一个想邀请的幼儿园朋友名单。然而，孩子们是非常挑剔的客人。Mary 说她应该来，但前提是 Camille 和 Emily 不在场，因为她们上周拿走了她的娃娃。小 Christopher 只和 Sophie 以及 Camille 玩，他不希望在派对上看到其他孩子。类似的情况还有很多……\n\nSophie 认为，如果邀请的客人中没有人对其他人的到场有异议，那么派对就是成功的。她决定不邀请某些孩子，以确保派对成功。另一方面，她希望尽可能多地邀请孩子。如果 Sophie 无法邀请至少 $k$ 个孩子，她将不会举办任何派对。\n\n### 任务\n\n帮助小 Sophie！编写一个程序，完成以下任务：\n\n- 从标准输入中读取 Sophie 所有熟人的数量 $n$、数字 $k$ 以及孩子们的要求描述；\n- 验证是否可以邀请至少 $k$ 个孩子，使得派对能够成功；\n- 如果不可能，向标准输出写入单词 NIE（波兰语中的“不”）；如果可能，则找到可以邀请的最大孩子群体，使得派对成功，并将结果写入标准输出。", "inputFormat": "标准输入的第一行包含两个用单个空格分隔的正整数：\n\n$n$ —— Sophie 所有熟人的数量（$2 \\le n \\le 1000\\ 000$），以及 $k$ —— Sophie 希望邀请到派对的最小孩子数量（$n-10 \\le k < n$）。孩子们被分配了从 $1$ 到 $n$ 的编号。\n\n接下来的几行包含孩子们的要求描述。第二行是一个整数 $m$，$1 \\le m \\le 3\\ 000\\ 000$。\n\n接下来的 $m$ 行中，每行包含一对用单个空格分隔的整数 $a$, $b$（$1 \\le a,b \\le n$, $a \\neq b$）。可以假设每对（有序）在标准输入中最多出现一次。这对数字 $a$, $b$ 表示孩子 $a$ 不希望与孩子 $b$ 在派对上见面。", "outputFormat": "如果无法邀请 $k$ 个孩子使得派对成功，则标准输出的第一行且唯一一行应包含一个单词：NIE。\n\n如果可能，则标准输出的第一行应包含一个整数 —— 可以邀请的最大孩子数量，使得派对成功。\n\n标准输出的第二行应包含被邀请孩子的编号，用单个空格分隔，按递增顺序排列。如果有多个正确答案，程序可以输出其中任意一个。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3451", "type": "P", "difficulty": 6, "samples": [["8 15 4\n1 2 3\n1 3 4\n1 4 4\n1 6 2\n1 7 3\n2 3 6\n2 4 2\n2 5 2\n3 4 3\n3 6 3\n3 8 6\n4 5 2\n4 8 6\n5 7 4\n5 8 6\n3\n2 3\n3 4\n3 5", "19"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2007", "POI（波兰）", "O2优化", "最短路", "状压 DP"], "title": "[POI 2007] ATR-Tourist Attractions", "background": "[English Edition](/paste/gu4ksinh)", "description": "给出一张有 $n$ 个点 $m$ 条边的无向图，每条边有边权。  \n\n你需要找一条从 $1$ 到 $n$ 的最短路径，并且这条路径在满足给出的 $g$ 个限制的情况下可以在所有编号从 $2$ 到 $k+1$ 的点上停留过。\n\n每个限制条件形如 $r_i, s_i$，表示停留在 $s_i$ 之前必须先在 $r_i$ 停留过。\n\n**注意，这里的停留不是指经过**。", "inputFormat": "第一行三个整数 $n,m,k$。\n\n之后 $m$ 行，每行三个整数 $p_i, q_i, l_i$，表示在 $p_i$ 和 $q_i$ 之间有一条权为 $l_i$ 的边。\n\n之后一行一个整数 $g$。\n\n之后 $g$ 行，每行两个整数 $r_i, s_i$，表示一个限制条件。", "outputFormat": "输出一行一个整数，表示最短路径的长度。", "hint": "对于 $100\\%$ 的数据， 满足：\n- $2\\le n\\le2\\times10^4$\n- $1\\le m\\le2\\times10^5$\n- $0\\le k\\le\\min(20, n-2)$\n- $1\\le p_i<q_i\\le n$\n- $1\\le l_i\\le 10^3$\n- $r_i, s_i \\in [2,k+1], r_i\\not=s_i$\n- $0\\le g\\le \\frac{k\\cdot (k-1)}{2}$.  \n- 保证不存在重边且一定有解。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2007] ATR-Tourist Attractions", "background": "[English Edition](/paste/gu4ksinh)", "description": "You are given an undirected graph with $n$ vertices and $m$ edges, where each edge has a weight.\n\nYou need to find a shortest path from $1$ to $n$ that, while satisfying the given $g$ constraints, can stop at every vertex numbered from $2$ to $k+1$.\n\nEach constraint is of the form $r_i, s_i$, meaning that you must have stopped at $r_i$ before stopping at $s_i$.\n\nNote that “stop” here does not mean merely passing through.", "inputFormat": "The first line contains three integers $n, m, k$.\n\nEach of the next $m$ lines contains three integers $p_i, q_i, l_i$, meaning there is an edge of weight $l_i$ between $p_i$ and $q_i$.\n\nThe next line contains an integer $g$.\n\nEach of the next $g$ lines contains two integers $r_i, s_i$, representing one constraint.", "outputFormat": "Output a single integer on one line — the length of the shortest path.", "hint": "Constraints:\n- For $100\\%$ of the testdata, the following hold:\n- $2 \\le n \\le 2 \\times 10^4$.\n- $1 \\le m \\le 2 \\times 10^5$.\n- $0 \\le k \\le \\min(20, n-2)$.\n- $1 \\le p_i < q_i \\le n$.\n- $1 \\le l_i \\le 10^3$.\n- $r_i, s_i \\in [2, k+1],\\ r_i \\ne s_i$.\n- There are no multiple edges, and a solution always exists.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2007] ATR-Tourist Attractions", "background": "[English Edition](/paste/gu4ksinh)", "description": "给出一张有 $n$ 个点 $m$ 条边的无向图，每条边有边权。  \n\n你需要找一条从 $1$ 到 $n$ 的最短路径，并且这条路径在满足给出的 $g$ 个限制的情况下可以在所有编号从 $2$ 到 $k+1$ 的点上停留过。\n\n每个限制条件形如 $r_i, s_i$，表示停留在 $s_i$ 之前必须先在 $r_i$ 停留过。\n\n**注意，这里的停留不是指经过**。", "inputFormat": "第一行三个整数 $n,m,k$。\n\n之后 $m$ 行，每行三个整数 $p_i, q_i, l_i$，表示在 $p_i$ 和 $q_i$ 之间有一条权为 $l_i$ 的边。\n\n之后一行一个整数 $g$。\n\n之后 $g$ 行，每行两个整数 $r_i, s_i$，表示一个限制条件。", "outputFormat": "输出一行一个整数，表示最短路径的长度。", "hint": "对于 $100\\%$ 的数据， 满足：\n- $2\\le n\\le2\\times10^4$\n- $1\\le m\\le2\\times10^5$\n- $0\\le k\\le\\min(20, n-2)$\n- $1\\le p_i<q_i\\le n$\n- $1\\le l_i\\le 10^3$\n- $r_i, s_i \\in [2,k+1], r_i\\not=s_i$\n- $0\\le g\\le \\frac{k\\cdot (k-1)}{2}$.  \n- 保证不存在重边且一定有解。", "locale": "zh-CN"}}}
{"pid": "P3452", "type": "P", "difficulty": 5, "samples": [["7 16\n1 3\n1 4\n1 5\n2 3\n3 4\n4 5\n4 7\n4 6\n5 6\n6 7\n2 4\n2 7\n2 5\n3 5\n3 7\n1 7", "3\n1 2 4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "线性数据结构", "POI（波兰）", "深度优先搜索 DFS"], "title": "[POI 2007] BIU-Offices", "background": "", "description": "Bytel is a mobile telephony potentate. Each employee has been issued a company phone, the memory ofwhich holds the numbers of some of his co-workers (all of them have his number in their phones as well).\n\nDue to dynamic growth of their operations the board of directors intends to move company headquaters tonew office buildings. It has been decided - in order to boost work efficiency - that every pair of employeesworking in different buildings should know (reciprocally) each others phone number i.e. the memory of theircompany phone ought to hold necessary phone numbers.\n\nSimultaneously, the board have decided to rent as many office buildings as possible to ensure good workingconditions. Help the board of Bytel to plan the number of office buildings and their size in accordancewith the aforementioned requirements.\n\n## Task\n\nWrite a programme which:\n\nreads the description of employees' phone number lists from the standard input        calculates the maximal number of office buildings and their sizes, satisfying board's conditions        writes the outcome to the standard output.", "inputFormat": "The first line of the standard input consists of two integers: $n$ and $m$ ($2 \\le n \\le 100\\ 000$, $1 \\le m \\le 2\\ 000\\ 000$),separated by single spaces, denoting the number of Bytel employees and the number of pairs of employeeswho have their numbers in company phones, respectively. The employees are numbered from $1$ to $n$.\n\nEach of the following $m$ lines contains a single pair of integers $a_i$ and $b_i$ ($1 \\le a_i < b_i \\le n$ for $1 \\le i \\le m$), separated by a single space, denoting that employees $a_i$ and $b_i$ have their numbers (reciprocally) in company phones' memory. Each pair of integers denoting a pair of employees shall occur once at the most in the standard input.\n", "outputFormat": "The first line of the standard output should contain a single integer: the maximal number of office buildingsthat Bytel should rent. The second should contain a non-decreasing sequence of positive integers, separatedby singe spaces, denoting the sizes of the office buildings (i.e. the numbers of employees working there).\n\nShould there exist more than one correct answer - write out any one of them.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2007] BIU-Offices", "background": "", "description": "Bytel is a mobile telephony potentate. Each employee has been issued a company phone, the memory ofwhich holds the numbers of some of his co-workers (all of them have his number in their phones as well).\n\nDue to dynamic growth of their operations the board of directors intends to move company headquaters tonew office buildings. It has been decided - in order to boost work efficiency - that every pair of employeesworking in different buildings should know (reciprocally) each others phone number i.e. the memory of theircompany phone ought to hold necessary phone numbers.\n\nSimultaneously, the board have decided to rent as many office buildings as possible to ensure good workingconditions. Help the board of Bytel to plan the number of office buildings and their size in accordancewith the aforementioned requirements.\n\n## Task\n\nWrite a programme which:\n\nreads the description of employees' phone number lists from the standard input        calculates the maximal number of office buildings and their sizes, satisfying board's conditions        writes the outcome to the standard output.", "inputFormat": "The first line of the standard input consists of two integers: $n$ and $m$ ($2 \\le n \\le 100\\ 000$, $1 \\le m \\le 2\\ 000\\ 000$),separated by single spaces, denoting the number of Bytel employees and the number of pairs of employeeswho have their numbers in company phones, respectively. The employees are numbered from $1$ to $n$.\n\nEach of the following $m$ lines contains a single pair of integers $a_i$ and $b_i$ ($1 \\le a_i < b_i \\le n$ for $1 \\le i \\le m$), separated by a single space, denoting that employees $a_i$ and $b_i$ have their numbers (reciprocally) in company phones' memory. Each pair of integers denoting a pair of employees shall occur once at the most in the standard input.\n", "outputFormat": "The first line of the standard output should contain a single integer: the maximal number of office buildingsthat Bytel should rent. The second should contain a non-decreasing sequence of positive integers, separatedby singe spaces, denoting the sizes of the office buildings (i.e. the numbers of employees working there).\n\nShould there exist more than one correct answer - write out any one of them.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] BIU-Offices", "background": "", "description": "Bytel 是一家移动通信公司。该公司的每位员工都收到了一部公司生产的电话，电话的通讯录中存储着一些同事的电话号码（每部手机中也都有该手机本身的电话号码）。\n\n由于业务扩张，公司总部需要迁移至新的办公区。为了提高工作效率，董事会决定在不同栋楼工作的每一对员工需要**相互**知道对方的电话号码。即如果 $u$ 和 $v$ 在不同的楼工作，则 $u$ 的通讯录里需要存储 $v$ 的电话号，$v$ 的通讯录里也要存储 $u$ 的电话号码。\n\n同时，董事会决定租用尽可能多的楼，以确保良好的工作条件。现在你需要帮助 Bytel 公司计算出他们需要租用多少栋楼。", "inputFormat": "输入第一行包含两个整数 $n,m$，分别代表公司的员工数和通讯录的信息数，员工从 $1$ 到 $n$ 编号。\n\n接下来 $m$ 行，每行两个整数 $a_i,b_i$，表示 $a_i$ 和 $b_i$ **相互**知道对方的电话号码，保证任意两条信息不重复。", "outputFormat": "输出第一行包含一个整数 $t$：董事会需要租用多少栋办公楼。\n\n第二行包含 $t$ 个整数，第 $i$ 个整数 $c_i$ 表示在第 $i$ 栋建筑工作的员工数量。你的输出需要保证 $c_i$ 是单调不下降的。\n\n如果有多种合法方案，你可以输出任意一种。", "hint": "$2 \\leq n \\leq 10^5$，$1 \\leq m \\leq 2 \\times 10^6$，$1 \\leq a_i \\lt b_i \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P3453", "type": "P", "difficulty": 6, "samples": [["5\n7 4 5 2 5", "7\n7\n8\n7\n7"], ["5\n1 2 3 4 5", "4\n4\n4\n4\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "线段树", "POI（波兰）"], "title": "[POI 2007] DRZ-Trees", "background": "", "description": "Byteasar has a cottage. Lately, he has bought $n$ trees and had them planted all in one row. Byteasar does not,  however, like the order which the trees have been planted in. It particularly annoys him that tall and short  ones have been mixed up, and the composition does not meet his aesthetic criteria.\n\nByteasar has invented a disorder coefficient so as to allow the gardener to comprehend his intentions: thelower the value of the coefficient the prettier the row of trees. It is defined in the following way:\n\n$|h_1-h_2|+|h_2-h_3|+\\cdots+|h_{n-1}-h_n|$, where $h_1,h_2,\\cdots,h_n$ are the heights of consecutive trees in a row.\nReplanting is a very toilsome and cumbersome task, therefore Byteasar has ordered the gardener to replanttwo trees at the most (i.e. interchange their positions). The task of the gardener is to choose the pair to replantin a way that makes the disorder coefficient the smallest.\n\nThe gardener is not sure if he has chosen the correct pair of trees and he fears he may lose his job ifhe is mistaken. Help him: for each tree calculate the minimal disorder coefficient that may be attained byswitching places with any other tree.\n\nTaskWrite a programme which:\n\nreads the height of the consecutive trees in a row from the standard input,        for each tree calculates the minimal disorder coefficient that may be attained should it switch places    with some other tree (or should there be no change at all),        writes the outcome to the standard output.\n\n定义一排树的不整齐程度为相邻两树的高度差的和。设树高分别为 $h _ 1, h _ 2, \\cdots, h _ n$，那么不整齐程度定义为：$|h_1-h_2|+|h_2-h_3|+\\cdots+|h_{n-1}-h_n|$。\n\n请对于每个 $i$ 求出，如果只把 $i$ 和另一棵树交换高度（可以不交换），那么不整齐度最小是多少。\n", "inputFormat": "The first line of the standard input contains one integer $n$ ($2\\le n\\le 50\\ 000$).\n\nThe other contains $n$ integers $h_i$ ($1\\le h_i\\le 100\\ 000\\ 000$)separated by single spaces, denoting the height of the consecutive trees in the row.\n", "outputFormat": "The output should consist of precisely $n$ lines. The $i$'th line should contain a single integer - the smallestdisorder coefficient attainable when considering replanting of the $i$'th tree.\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2007] DRZ-Trees", "background": "", "description": "Byteasar has a cottage. He has bought $n$ trees and had them planted in a single row. He dislikes the current order: tall and short ones are mixed, and the arrangement does not meet his aesthetic criteria.\n\nHe defines the disorder coefficient of a row as the sum of absolute differences of heights of adjacent trees:\n$|h_1 - h_2| + |h_2 - h_3| + \\cdots + |h_{n-1} - h_n|$, where $h_1, h_2, \\cdots, h_n$ are the heights of the trees in order.\n\nReplanting is laborious, so at most two trees may be replanted, i.e., their positions may be swapped. For each position $i$, determine the minimal disorder coefficient that can be achieved by swapping the tree at position $i$ with any other single tree (or by not swapping at all).", "inputFormat": "The first line contains one integer $n$ ($2 \\le n \\le 50\\ 000$).\n\nThe second line contains $n$ integers $h_i$ ($1 \\le h_i \\le 100\\ 000\\ 000$), separated by single spaces, denoting the heights of the trees in order.", "outputFormat": "Output exactly $n$ lines. The $i$-th line should contain a single integer: the minimal disorder coefficient attainable when considering swapping the $i$-th tree with some other tree (or making no change).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2007] DRZ-Trees", "background": "", "description": "Byteasar has a cottage. Lately, he has bought $n$ trees and had them planted all in one row. Byteasar does not,  however, like the order which the trees have been planted in. It particularly annoys him that tall and short  ones have been mixed up, and the composition does not meet his aesthetic criteria.\n\nByteasar has invented a disorder coefficient so as to allow the gardener to comprehend his intentions: thelower the value of the coefficient the prettier the row of trees. It is defined in the following way:\n\n$|h_1-h_2|+|h_2-h_3|+\\cdots+|h_{n-1}-h_n|$, where $h_1,h_2,\\cdots,h_n$ are the heights of consecutive trees in a row.\nReplanting is a very toilsome and cumbersome task, therefore Byteasar has ordered the gardener to replanttwo trees at the most (i.e. interchange their positions). The task of the gardener is to choose the pair to replantin a way that makes the disorder coefficient the smallest.\n\nThe gardener is not sure if he has chosen the correct pair of trees and he fears he may lose his job ifhe is mistaken. Help him: for each tree calculate the minimal disorder coefficient that may be attained byswitching places with any other tree.\n\nTaskWrite a programme which:\n\nreads the height of the consecutive trees in a row from the standard input,        for each tree calculates the minimal disorder coefficient that may be attained should it switch places    with some other tree (or should there be no change at all),        writes the outcome to the standard output.\n\n定义一排树的不整齐程度为相邻两树的高度差的和。设树高分别为 $h _ 1, h _ 2, \\cdots, h _ n$，那么不整齐程度定义为：$|h_1-h_2|+|h_2-h_3|+\\cdots+|h_{n-1}-h_n|$。\n\n请对于每个 $i$ 求出，如果只把 $i$ 和另一棵树交换高度（可以不交换），那么不整齐度最小是多少。\n", "inputFormat": "The first line of the standard input contains one integer $n$ ($2\\le n\\le 50\\ 000$).\n\nThe other contains $n$ integers $h_i$ ($1\\le h_i\\le 100\\ 000\\ 000$)separated by single spaces, denoting the height of the consecutive trees in the row.\n", "outputFormat": "The output should consist of precisely $n$ lines. The $i$'th line should contain a single integer - the smallestdisorder coefficient attainable when considering replanting of the $i$'th tree.\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3454", "type": "P", "difficulty": 6, "samples": [["2\n12\n1 -1\n2 -1\n2 1\n1 1\n1 2\n-1 2\n-1 1\n-2 1\n-2 -1\n-1 -1\n-1 -2\n1 -2\n6\n-1 1\n-2 0\n-1 -1\n1 -1\n2 0\n1 1", "4\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "计算几何", "2007", "POI（波兰）", "KMP 算法"], "title": "[POI 2007] OSI-Axes of Symmetry", "background": "", "description": "Little Johnny - a well-respected young mathematician - has a younger sister, Justina. Johnny likes hissister very much and he gladly helps her with her homework, but, like most scientific minds, he does mindsolving the same problems again. Unfortunately, Justina is a very diligent pupil, and so she asks Johnny toreview her assignments many times, for sake of certainty. One sunny Friday, just before the famous LongMay Weekend1 the math teacher gave many exercises consisting in finding the axes of symmetry of variousgeometric figures. Justina is most likely to spend considerable amount of time solving these tasks. LittleJohnny had arranged himself a trip to the seaside long time before, nevertheless he feels obliged to help hislittle sister. Soon, he has found a solution - it would be best to write a programme that wouldease checking Justina's solutions. Since Johnny is a mathematician, not a computer scientist, and you are hisbest friend, it falls to you to write it.\n\n## Task\n\nWrite a programme that:\n\n- reads the descriptions of the polygons from the standard input,\n\n- determines the number of axes of symmetry for each one of them,\n\n- writes the result to the standard output.\n\n\n给定一个多边形，求对称轴数量。\n", "inputFormat": "In the first line of the input there is one integer $t$ ($1 \\le t \\le 10$) - it is the number of polygons, for which the number of axes of symmetry is to be determined. Next, $t$ descriptions of the polygons follow. The first line of each description contains one integer $n$ ($3 \\le n \\le 100\\ 000$) denoting the number of vertices of the polygon. In each of the following $n$ lines there are two integers $x$ and $y$ ($-100\\ 000\\ 000 \\le x, y \\le 100\\ 000\\ 000$) representing the coordinates of subsequent vertices of the polygon. The polygons need not be convex, but they have no self-intersections - any two sides have at most one common point - their common endpoint, if they actually share it. Furthermore, no pair of consecutive sides is parallel.\n", "outputFormat": "Your programme should output exactly $t$ lines, with the $k$'th line containing a sole integer $n_k$ - the number of axes of symmetry of the $k$'th polygon.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2007] OSI-Axes of Symmetry", "background": "", "description": "Little Johnny - a well-respected young mathematician - has a younger sister, Justina. Johnny likes hissister very much and he gladly helps her with her homework, but, like most scientific minds, he does mindsolving the same problems again. Unfortunately, Justina is a very diligent pupil, and so she asks Johnny toreview her assignments many times, for sake of certainty. One sunny Friday, just before the famous LongMay Weekend1 the math teacher gave many exercises consisting in finding the axes of symmetry of variousgeometric figures. Justina is most likely to spend considerable amount of time solving these tasks. LittleJohnny had arranged himself a trip to the seaside long time before, nevertheless he feels obliged to help hislittle sister. Soon, he has found a solution - it would be best to write a programme that wouldease checking Justina's solutions. Since Johnny is a mathematician, not a computer scientist, and you are hisbest friend, it falls to you to write it.\n\n## Task\n\nWrite a programme that:\n\n- reads the descriptions of the polygons from the standard input,\n\n- determines the number of axes of symmetry for each one of them,\n\n- writes the result to the standard output.\n\n\n给定一个多边形，求对称轴数量。\n", "inputFormat": "In the first line of the input there is one integer $t$ ($1 \\le t \\le 10$) - it is the number of polygons, for which the number of axes of symmetry is to be determined. Next, $t$ descriptions of the polygons follow. The first line of each description contains one integer $n$ ($3 \\le n \\le 100\\ 000$) denoting the number of vertices of the polygon. In each of the following $n$ lines there are two integers $x$ and $y$ ($-100\\ 000\\ 000 \\le x, y \\le 100\\ 000\\ 000$) representing the coordinates of subsequent vertices of the polygon. The polygons need not be convex, but they have no self-intersections - any two sides have at most one common point - their common endpoint, if they actually share it. Furthermore, no pair of consecutive sides is parallel.\n", "outputFormat": "Your programme should output exactly $t$ lines, with the $k$'th line containing a sole integer $n_k$ - the number of axes of symmetry of the $k$'th polygon.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] OSI-Axes of Symmetry", "background": "", "description": "Johnny 是一位非常年轻的数学家，但他此刻正在为他妹妹的数学作业烦恼。\n\n这个周末，他的妹妹需要完成一项作业，计算各种几何图形的对称轴数量。因为 Johnny 这个周末想要去海边旅行，所以他希望他的妹妹能尽快完成这项作业。\n\n于是他找到了擅长编程的你，你一定能帮助他完成这项任务的！", "inputFormat": "输入包含多组数据。\n\n第一行包含一个整数 $t$，代表数据的组数。\n\n对于每组数据，第一行一个整数 $n$，代表多边形的顶点数。\n\n接下来 $n$ 行，每行两个整数 $x_i,y_i$，代表每个顶点的坐标。\n\n输入中的第 $i$ 个顶点会与第 $i+1$ 个顶点连一条边。特别地，输入中的第 $n$ 个顶点会与第一个顶点连一条边。\n\n输入给出的多边形**不保证**是凸多边形，但是保证任意两条边只会在端点处相交，且任意两条相邻的边不共线。", "outputFormat": "对于每组数据，输出一行一个整数，即多边形对称轴的数量。", "hint": "$1 \\leq t \\leq 10$，$3 \\leq n \\leq 10^5$，$-10^8 \\leq x_i,y_i \\leq 10^8$。", "locale": "zh-CN"}}}
{"pid": "P3455", "type": "P", "difficulty": 5, "samples": [["2\n4 5 2\n6 4 3", "3\n2"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2007", "POI（波兰）", "最大公约数 gcd", "莫比乌斯反演", "整除分块"], "title": "[POI 2007] ZAP-Queries", "background": "", "description": "密码学家正在尝试破解一种叫 BSA 的密码。\n\n他发现，在破解一条消息的同时，他还需要回答这样一种问题：\n\n给出 $a,b,d$，求满足 $1 \\leq x \\leq a$，$1 \\leq y \\leq b$，且 $\\gcd(x,y)=d$ 的二元组 $(x,y)$ 的数量。\n\n因为要解决的问题实在太多了，他便过来寻求你的帮助。", "inputFormat": "输入第一行一个整数 $n$，代表要回答的问题个数。\n\n接下来 $n$ 行，每行三个整数 $a,b,d$。", "outputFormat": "对于每组询问，输出一个整数代表答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 5 \\times 10^4$，$1 \\leq d \\leq a,b \\leq 5 \\times 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2007] ZAP-Queries", "background": "", "description": "A cryptographer is trying to break a cipher called BSA.\n\nHe found that while breaking a message, he also needs to answer the following question:\n\nGiven $a,b,d$, count the number of pairs $(x,y)$ such that $1 \\leq x \\leq a$, $1 \\leq y \\leq b$, and $\\gcd(x,y)=d$.\n\nBecause there are so many problems to solve, he asks for your help.", "inputFormat": "The first line contains an integer $n$, the number of queries.\n\nEach of the next $n$ lines contains three integers $a,b,d$.", "outputFormat": "For each query, output a single integer representing the answer.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $1 \\leq n \\leq 5 \\times 10^4$, $1 \\leq d \\leq a,b \\leq 5 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2007] ZAP-Queries", "background": "", "description": "密码学家正在尝试破解一种叫 BSA 的密码。\n\n他发现，在破解一条消息的同时，他还需要回答这样一种问题：\n\n给出 $a,b,d$，求满足 $1 \\leq x \\leq a$，$1 \\leq y \\leq b$，且 $\\gcd(x,y)=d$ 的二元组 $(x,y)$ 的数量。\n\n因为要解决的问题实在太多了，他便过来寻求你的帮助。", "inputFormat": "输入第一行一个整数 $n$，代表要回答的问题个数。\n\n接下来 $n$ 行，每行三个整数 $a,b,d$。", "outputFormat": "对于每组询问，输出一个整数代表答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 5 \\times 10^4$，$1 \\leq d \\leq a,b \\leq 5 \\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P3456", "type": "P", "difficulty": 4, "samples": [["5\n8 8 8 7 7\n7 7 8 8 7\n7 7 7 7 7\n7 8 8 7 8\n7 8 8 8 8", "2 1"], ["5\n5 7 8 3 1\n5 5 7 6 6\n6 6 6 2 8\n5 7 2 5 8\n7 1 0 1 7", "3 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "POI（波兰）", "广度优先搜索 BFS", "深度优先搜索 DFS"], "title": "[POI 2007] GRZ-Ridges and Valleys", "background": "", "description": "Byteasar loves trekking in the hills. During the hikes he explores all the ridges and valleys in vicinity.\n\nTherefore, in order to plan the journey and know how long it will last, he must know the number of ridgesand valleys in the area he is going to visit. And you are to help Byteasar.\n\nByteasar has provided you with a map of the area of his very next expedition. The map is in the shape ofa $n\\times n$ square. For each field $(i,j)$ belonging to the square(for $i,j\\in \\{1,\\cdots,n\\}$), its height $w_{(i,j)}$ is given.\n\nWe say two fields are adjacent if they have a common side or a common vertex (i.e. the field $(i,j)$ is adjacent to the fields $(i-1,j-1)$,$(i-1,j)$,$(i-1,j+1)$,$(i,j-1)$,$(i,j+1)$,$(i+1,j-1)$,$(i+1,j)$,$(i+1,j+1)$, provided that these fields are on the map).\n\nWe say a set of fields $S$ forms a ridge (valley) if:\n\nall the fields in $S$ have the same height,the set $S$ forms a connected part of the map (i.e. from any field in $S$ it is possible to reach any other    field in $S$ while moving only between adjacent fields and without leaving the set $S$),if $s\\in S$ and the field $s'\\notin S$ is adjacent to $s$, then $w_s>w_{s'}$(for a ridge) or $w_s<w_{s'}$ (for a valley).\n\nIn particular, if all the fields on the map have the same height, they form both a ridge and a valley.\n\nYour task is to determine the number of ridges and valleys for the landscape described by the map.\n\nTaskWrite a programme that:\n\nreads from the standard input the description of the map,        determines the number of ridges and valleys for the landscape described by this map,        writes out the outcome to the standard output.\n\n给定一张地势图，求山峰和山谷的数量\n", "inputFormat": "In the first line of the standard input there is one integer $n$ ($2\\le n\\le 1\\ 000$)denoting the size of the map. Ineach of the following $n$ lines there is the description of the successive row of the map. In $(i+1)$'th line(for $i\\in \\{1,\\cdots,n\\}$) there are $n$ integers $w_{(i,1)},\\cdots,w_{(i,n)}$($0\\le w_i\\le 1\\ 000\\ 000\\ 000$), separated by single spaces. Thesedenote the heights of the successive fields of the $i$'th row of the map.\n", "outputFormat": "The first and only line of the standard output should contain two integers separated by a single space -thenumber of ridges followed by the number of valleys for the landscape described by the map.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2007] GRZ-Ridges and Valleys", "background": "", "description": "Byteasar loves trekking in the hills. During the hikes he explores all the ridges and valleys in vicinity.\n\nTherefore, in order to plan the journey and know how long it will last, he must know the number of ridgesand valleys in the area he is going to visit. And you are to help Byteasar.\n\nByteasar has provided you with a map of the area of his very next expedition. The map is in the shape ofa $n\\times n$ square. For each field $(i,j)$ belonging to the square(for $i,j\\in \\{1,\\cdots,n\\}$), its height $w_{(i,j)}$ is given.\n\nWe say two fields are adjacent if they have a common side or a common vertex (i.e. the field $(i,j)$ is adjacent to the fields $(i-1,j-1)$,$(i-1,j)$,$(i-1,j+1)$,$(i,j-1)$,$(i,j+1)$,$(i+1,j-1)$,$(i+1,j)$,$(i+1,j+1)$, provided that these fields are on the map).\n\nWe say a set of fields $S$ forms a ridge (valley) if:\n\nall the fields in $S$ have the same height,the set $S$ forms a connected part of the map (i.e. from any field in $S$ it is possible to reach any other    field in $S$ while moving only between adjacent fields and without leaving the set $S$),if $s\\in S$ and the field $s'\\notin S$ is adjacent to $s$, then $w_s>w_{s'}$(for a ridge) or $w_s<w_{s'}$ (for a valley).\n\nIn particular, if all the fields on the map have the same height, they form both a ridge and a valley.\n\nYour task is to determine the number of ridges and valleys for the landscape described by the map.\n\nTaskWrite a programme that:\n\nreads from the standard input the description of the map,        determines the number of ridges and valleys for the landscape described by this map,        writes out the outcome to the standard output.\n\n给定一张地势图，求山峰和山谷的数量\n", "inputFormat": "In the first line of the standard input there is one integer $n$ ($2\\le n\\le 1\\ 000$)denoting the size of the map. Ineach of the following $n$ lines there is the description of the successive row of the map. In $(i+1)$'th line(for $i\\in \\{1,\\cdots,n\\}$) there are $n$ integers $w_{(i,1)},\\cdots,w_{(i,n)}$($0\\le w_i\\le 1\\ 000\\ 000\\ 000$), separated by single spaces. Thesedenote the heights of the successive fields of the $i$'th row of the map.\n", "outputFormat": "The first and only line of the standard output should contain two integers separated by a single space -thenumber of ridges followed by the number of valleys for the landscape described by the map.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] GRZ-Ridges and Valleys", "background": "", "description": "**译自 POI 2007 Stage 2. Day 0「[Ridges and Valleys](https://szkopul.edu.pl/problemset/problem/rd6H05Dm8ME79sO3U9_f_ga_/site/?key=statement)」**\n\n给定一个 $n \\times n$ 的网格状地图，每个方格 $(i,j)$ 有一个高度 $w_{ij}$。如果两个方格有公共顶点，则它们是相邻的。\n\n定义山峰和山谷如下：\n* 均由地图上的一个连通块组成；\n* 所有方格高度都相同；\n* 周围的方格（即不属于山峰或山谷但与山峰或山谷相邻的格子）高度均大于山谷的高度，或小于山峰的高度。\n\n求地图内山峰和山谷的数量。特别地，如果整个地图方格的高度均相同，则整个地图既是一个山谷，也是一个山峰。", "inputFormat": "第一行一个整数 $n$ （$2 \\le n \\le 1000$），表示地图的大小。\n\n接下来 $n$ 行每行 $n$ 个整数表示地图。第 $i$ 行有 $n$ 个整数 $w_{i1}, w_{i2}, \\ldots, w_{in} (0 \\le w_{ij} \\le 1\\ 000\\ 000\\ 000)$，表示地图第 $i$ 行格子的高度。", "outputFormat": "输出一行两个整数，分别表示山峰和山谷的数量。\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yubj6du3.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ct18655.png)\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2653)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3457", "type": "P", "difficulty": 5, "samples": [["6 9\n-2 -2 -1 -1 -2 -2 -2 -12 -3\n-2 1 -1 2 -8 -12 2 -12 -12\n-5 3 1 1 -12 4 -6 2 -2\n-5 -2 -2 2 -12 -3 4 -3 -1\n-5 -6 -2 2 -12 5 6 2 -1\n-4 -8 -8 -10 -12 -8 -6 -6 -4", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2007", "并查集", "POI（波兰）"], "title": "[POI 2007] POW-The Flood", "background": "", "description": "Byteburg, the capital of Byteotia, is a picturesque city situated in a valley in the midst of mountains. Unfortunately,  recent heavy rainfall has caused a flood - all the Byteburg is now completely under water. Byteasar,  the king of Byteotia, has summoned his most enlightened advisors, including you, to a council. After long  deliberations the council agreed to bring a few pumps, set them up in the flooded area and drain Byteburg.\n\nThe king has asked you to determine the minimum number of pumps sufficing to drain the city.\n\nYou are provided with a map of the city and the valley it is situated in. The map is in the shape of a $m\\times n$ rectangle, divided into unitary squares. For each such square the map tells its height above sea level and alsowhether it is a part of Byteburg or not. The whole area depicted in the map is under water. Furthermore, it issurrounded by much higher mountains, making the outflow of water impossible. Obviously, there is no needto drain the area that does not belong to Byteburg.\n\nEach pump can be placed in any unitary square depicted in the map. The pump will be drawing thewater until its square is completely drained. Of course, the communicating tubes principle makes its work,      so draining one square results in lowering the water level or complete draining of those squares from which      the water can flow down to the one with the pump. Water can flow only between squares with a common side      (or, more exact, squares whose projections onto horizontal plane have a common side, since the squares may       be at different level). Apart from that, the water obviously only flows down.\n\n## Task\n\nWrite a programme that:\n\n- reads description of the map from the standard input,\n\n- determines the minimum number of pumps needed to drain whole Byteburg,\n\n- writes out the outcome to the standard output.", "inputFormat": "In the first line of the standard input there are two integers $m$ and $n$, separated by a single space, $1 \\le n, m \\le 1\\ 000$. The following $m$ lines contain the description of the map. The $(i+1)$'th line describes the $i$'th row of unitary squares in the map. It contains $n$ integers $x_{i,1}, x_{i,2}, ..., x_{i_n}$, separated by single spaces,$-1\\ 000 \\le x_{i,j} \\le 1\\ 000$ ,$x_{i,j} \\ne 1000$ . The number $x_{i,j}$ describes the $j$'th square of the $i$'th line. The ground level in this square is $|x_{i,j}|$ above sea level. If $x_{i,j} > 0$, then the square is part of Byteburg, otherwise it is outside the city. Notice, that the area of Byteburg need not be connected. In fact the city may have several separate parts.\n", "outputFormat": "Your programme should write out one integer to the standard output - the minimum number of pumpsneeded to drain Byteburg.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2007] POW-The Flood", "background": "", "description": "Byteburg, the capital of Byteotia, is a picturesque city situated in a valley in the midst of mountains. Unfortunately,  recent heavy rainfall has caused a flood - all the Byteburg is now completely under water. Byteasar,  the king of Byteotia, has summoned his most enlightened advisors, including you, to a council. After long  deliberations the council agreed to bring a few pumps, set them up in the flooded area and drain Byteburg.\n\nThe king has asked you to determine the minimum number of pumps sufficing to drain the city.\n\nYou are provided with a map of the city and the valley it is situated in. The map is in the shape of a $m\\times n$ rectangle, divided into unitary squares. For each such square the map tells its height above sea level and alsowhether it is a part of Byteburg or not. The whole area depicted in the map is under water. Furthermore, it issurrounded by much higher mountains, making the outflow of water impossible. Obviously, there is no needto drain the area that does not belong to Byteburg.\n\nEach pump can be placed in any unitary square depicted in the map. The pump will be drawing thewater until its square is completely drained. Of course, the communicating tubes principle makes its work,      so draining one square results in lowering the water level or complete draining of those squares from which      the water can flow down to the one with the pump. Water can flow only between squares with a common side      (or, more exact, squares whose projections onto horizontal plane have a common side, since the squares may       be at different level). Apart from that, the water obviously only flows down.\n\n## Task\n\nWrite a programme that:\n\n- reads description of the map from the standard input,\n\n- determines the minimum number of pumps needed to drain whole Byteburg,\n\n- writes out the outcome to the standard output.", "inputFormat": "In the first line of the standard input there are two integers $m$ and $n$, separated by a single space, $1 \\le n, m \\le 1\\ 000$. The following $m$ lines contain the description of the map. The $(i+1)$'th line describes the $i$'th row of unitary squares in the map. It contains $n$ integers $x_{i,1}, x_{i,2}, ..., x_{i_n}$, separated by single spaces,$-1\\ 000 \\le x_{i,j} \\le 1\\ 000$ ,$x_{i,j} \\ne 1000$ . The number $x_{i,j}$ describes the $j$'th square of the $i$'th line. The ground level in this square is $|x_{i,j}|$ above sea level. If $x_{i,j} > 0$, then the square is part of Byteburg, otherwise it is outside the city. Notice, that the area of Byteburg need not be connected. In fact the city may have several separate parts.\n", "outputFormat": "Your programme should write out one integer to the standard output - the minimum number of pumpsneeded to drain Byteburg.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] POW-The Flood", "background": "", "description": "**译自 POI 2007 Stage 2. Day 1「[The Flood](https://szkopul.edu.pl/problemset/problem/VutzcR1iPvGuYRGZgvNksmV1/site/?key=statement)」**\n\n你有一张 $m \\times n$ 的地图，地图上所有点都被洪水淹没了。你知道地图上每个网格的海拔高度，其中一部分点属于 Byteburg 城。你需要放置尽可能少的巨型抽水机，将 Byteburg 城从洪水中解救出来。巨型抽水机会抽干该格子的所有水，直到该格子不被洪水淹没为止。\n\n水会在有公共边的格子间从高向低流动。", "inputFormat": "第一行两个整数 $m,n$（$1 \\le m,n \\le 1000$）。\n\n接下来 $m$ 行每行 $n$ 个整数 $x_{i1}, x_{i2}, \\ldots, x_{in} (-1000 \\le x_{ij} \\lt 1000)$，表示地图。第 $i$ 行第 $j$ 列格子的海拔高度为 $\\lvert x_{ij} \\rvert$，且如果 $x_{ij} \\gt 0$，则这个格子在 Byteburg 城内，否则在城外。不保证 Byteburg 城形成一个连通块。", "outputFormat": "输出一行一个整数，表示最少需要的抽水机的数量。\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6cal4wth.png)\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2654)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3458", "type": "P", "difficulty": 6, "samples": [["5\n2 3 400\n1 4 100\n2 2 655\n3 4 100\n5 3 277", "10 200\n01010"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "POI（波兰）", "Special Judge", "枚举"], "title": "[POI 2007] SKA-Rock Garden", "background": "", "description": "Vicomte de Bajteaux is the owner of a renowned collection of boulders. Up to now, he has kept it in thecellars of his palace, but recently, he has decided to display the collection in his vast gardens.\n\nThe gardens have a shape of rectangle, whose sides are $1\\ 000\\ 000\\ 000$ units long and are parallel to east-westand north-south geographical directions. For each boulder, vicomte has determined coordinates ofthe point, which he would like it to be placed in (the coordinates are simply distances to the southern and    western side of the garden), and gave them to his servants. Unfortunately he has forgot to tell them the orderof the coordinates (i.e. for some of the boulders the first coordinate of a point is the so called \"$y$ coordinate\",i.e. the ordinate, while for others the so called \"$x$ coordinate\", i.e. the abscissa).\n\nThe servants, unaware of thisfact, have placed the boulders assuming customary coordinate ordering (as in standard Cartesian coordinates:\n\nthe abscissa, commonly known as \"$x$ coordinate\", first).\n\nTo protect his collection, vicomte has decided to surround it with a fence. For aesthetic reasons thefence has to be a rectangle, with sides parallel to the sides of the garden. The garden layout has been planned,      so that the total length of the fence be minimal (i.e. in the space of all coordinate orderings, the original          ordering of vicomte requires the minimal length of the fence - we assume that the rectangle may have sides of zero length).\n\nThe servants have to move the boulders so that the length of the fence required is minimal lest their mistake become obvious. Each boulder may only be moved in a way that preserves the coordinate set: by      interchanging its coordinates. As the boulders are heavy, the servants would like to minimize their effort, by      minimizing the weight of the boulders to be moved.\n\n## Task\n\nWrite a programme which:\n\nreads the present positions of the boulders in the gardens and their respective weights, determines a sequence of moves, which minimizes the length of the fence required to protect the    boulders and also minimizes the weight of the boulders to be moved, writes the outcome to the standard output.", "inputFormat": "The first line of the standard input contains a single integer $n$ ($2 \\le n \\le 1\\ 000\\ 000$), denoting the number of boulders in the collection. The following $n$  lines contain three integers $x_i$, $y_i$ and $m_i$ each ($0 \\le x_i, y_i \\le 1\\ 000\\ 000\\ 000$, $1 \\le m \\le 2000$), separated by single spaces, denoting the present coordinates and the weight of $i$'th boulder. No unordered pair of coordinates will appear in the input more than once.\n", "outputFormat": "The first line of the standard output should contain two integers, separated by a single space - the minimal length of fence possible and the minimal weight of the boulders to be moved in order to obtain such a length.\n\n\nThe second line should contain a sequence of $n$ zeros and/or ones - $i$'th element of the sequence should be a one if in the optimal solution the $i$'th boulder is to be moved and zero otherwise. Should more than one correct solutions exist, your programme is to write out any one of them.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2007] SKA-Rock Garden", "background": "", "description": "Vicomte de Bajteaux is the owner of a renowned collection of boulders. Up to now, he has kept it in thecellars of his palace, but recently, he has decided to display the collection in his vast gardens.\n\nThe gardens have a shape of rectangle, whose sides are $1\\ 000\\ 000\\ 000$ units long and are parallel to east-westand north-south geographical directions. For each boulder, vicomte has determined coordinates ofthe point, which he would like it to be placed in (the coordinates are simply distances to the southern and    western side of the garden), and gave them to his servants. Unfortunately he has forgot to tell them the orderof the coordinates (i.e. for some of the boulders the first coordinate of a point is the so called \"$y$ coordinate\",i.e. the ordinate, while for others the so called \"$x$ coordinate\", i.e. the abscissa).\n\nThe servants, unaware of thisfact, have placed the boulders assuming customary coordinate ordering (as in standard Cartesian coordinates:\n\nthe abscissa, commonly known as \"$x$ coordinate\", first).\n\nTo protect his collection, vicomte has decided to surround it with a fence. For aesthetic reasons thefence has to be a rectangle, with sides parallel to the sides of the garden. The garden layout has been planned,      so that the total length of the fence be minimal (i.e. in the space of all coordinate orderings, the original          ordering of vicomte requires the minimal length of the fence - we assume that the rectangle may have sides of zero length).\n\nThe servants have to move the boulders so that the length of the fence required is minimal lest their mistake become obvious. Each boulder may only be moved in a way that preserves the coordinate set: by      interchanging its coordinates. As the boulders are heavy, the servants would like to minimize their effort, by      minimizing the weight of the boulders to be moved.\n\n## Task\n\nWrite a programme which:\n\nreads the present positions of the boulders in the gardens and their respective weights, determines a sequence of moves, which minimizes the length of the fence required to protect the    boulders and also minimizes the weight of the boulders to be moved, writes the outcome to the standard output.", "inputFormat": "The first line of the standard input contains a single integer $n$ ($2 \\le n \\le 1\\ 000\\ 000$), denoting the number of boulders in the collection. The following $n$  lines contain three integers $x_i$, $y_i$ and $m_i$ each ($0 \\le x_i, y_i \\le 1\\ 000\\ 000\\ 000$, $1 \\le m \\le 2000$), separated by single spaces, denoting the present coordinates and the weight of $i$'th boulder. No unordered pair of coordinates will appear in the input more than once.\n", "outputFormat": "The first line of the standard output should contain two integers, separated by a single space - the minimal length of fence possible and the minimal weight of the boulders to be moved in order to obtain such a length.\n\n\nThe second line should contain a sequence of $n$ zeros and/or ones - $i$'th element of the sequence should be a one if in the optimal solution the $i$'th boulder is to be moved and zero otherwise. Should more than one correct solutions exist, your programme is to write out any one of them.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] SKA-Rock Garden", "background": "", "description": "**译自 POI 2007 Stage 2. Day 1「[Skalniak](https://szkopul.edu.pl/problemset/problem/s5ECsFKlMHti0g29uVkdKlQw/site/?key=statement)」**\n\nVicomte de Bajteaux 收藏了许多石头并准备把它们放到花园里。\n\n花园是一个正方形，边长为 $1\\ 000\\ 000\\ 000$。Vicomte de Bajteaux 让他的仆人为他用石头布置花园。但他忘记告诉仆人坐标的顺序，以至于一些点的坐标以 $(x,y)$ 的形式给出，一些点的坐标以 $(y,x)$ 的形式给出，并且石头已经按这样的顺序放好了。\n\n为了保护石头，Vicomte de Bajteaux 按照实际的坐标规划了一排栅栏来围住这些石头，使得栅栏的总长最小。为了美观，栅栏必须是平行于坐标轴的矩形。为了让错误不那么明显，你需要帮助仆人选择一部分石头并将它们从 $(x,y)$ 移动到 $(y,x)$，在最小化栅栏的长度的基础上最小化需要移动的石头的总重。", "inputFormat": "第一行一个整数 $n (1 \\le n \\le 1\\ 000\\ 000)$，表示石头的个数。\n\n接下来 $n$ 行每行三个整数 $x_i, y_i, m_i$（$0 \\le x_i,y_i \\le 1\\ 000\\ 000\\ 000, 1 \\le m_i \\le 2\\ 000$），表示石头当前所在的坐标和重量。\n\n不会有 $x$ 和 $y$ 组成的无序数对出现超过一次。", "outputFormat": "第一行输出两个整数，分别表示栅栏的最小长度和需要移动的石头总重量的最小值。\n\n第二行输出一个长度为 $n$ 的 01 串，表示取到石头总重量最小值的一种移动方案。第 $i$ 个字符为 $1$ 表示需要将第 $i$ 个石头从 $(x_i, y_i)$ 移动到 $(y_i, x_i)$，为 $0$ 则表示不需要。若有多解，输出任意一种解法均可以。\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gjo0jemf.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/09zdeg0c.png)\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2655)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3459", "type": "P", "difficulty": 5, "samples": [["5\n1 2\n1 3\n1 4\n4 5\n4\nW 5\nA 1 4\nW 5\nA 4 5\nW 5\nW 2\nA 1 2\nA 1 3", "2\n1\n0\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "线段树", "树状数组", "POI（波兰）", "深度优先搜索 DFS", "树链剖分", "栈"], "title": "", "background": "", "description": "Byteotia has been eventually touched by globalisation, and so has Byteasar the Postman, who once roamedthe country lanes amidst sleepy hamlets and who now dashes down the motorways. But it is those strolls inthe days of yore that he reminisces about with a touch of tenderness.\n\nIn the olden days $n$ Byteotian villages (numbered from $1$ to $n$) were connected by bidirectional dirt roadsin such a way, that one could reach the village number $1$ (called Bitburg) from any other village in exactlyone way. This unique route passed only through villages with number less or equal to that of the startingvillage. Furthermore, each road connected exactly two distinct villages without passing through any othervillage. The roads did not intersect outside the villages, but tunnels and viaducts were not unheard of.\n\nTime passing by, successive roads were being transformed into motorways. Byteasar remembers distinctly,  when each of the country roads so disappeared. Nowadays, there is not a single country lane left  in Byteotia - all of them have been replaced with motorways, which connect the villages into Byteotian  Megalopolis.\n\nByteasar recalls his trips with post to those villages. Each time he was beginning his journey with letters  to some distinct village in Bitburg. He asks you to calculate, for each such journey (which took place in a      specific moment of time and led from Bitburg to a specified village), how many country roads it led through.\n\nTaskWrite a programme which:\n\nreads from the standard input:\n\ndescriptions of roads that once connected Byteotian villages,    sequence of events: Byteasar's trips and the moments when respective roads were transformed    into motorways,            for each trip, calculates how many country roads Byteasar has had to walk,        writes the outcome to the standard output.", "inputFormat": "In the first line of the standard input there is a single integer $n$ ($1\\le n\\le 250\\ 000$),denoting the number of villages in Byteotia. The following $n-1$ lines contain descriptions of the roads, in the form of two integers $a$,$b$ ($1\\le a<b\\le n$)separated by a single space, denoting the numbers of villages connected with a road. Inthe next line there is a single integer $m$($1\\le m\\le 250\\ 000$),denoting the number of trips Byteasar has made.\n\nThe following $n+m-1$ lines contain descriptions of the events, in chronological order:\n\nA description of the form \"A $a$ $b$\"(for $a<b$) denotes a country road between villages $a$ and $b$ beingtransformed into a motorway in that particular moment.\n\nA description of the from \"W $a$\" denotes Byteasar's trip from Bitburg to village $a$.", "outputFormat": "Your programme should write out exactly $m$ integers to the standard output, one a line, denoting the numberof country roads Byteasar has travelled during his successive trips.", "hint": "", "locale": "en", "translations": {"en": {"title": "", "background": "", "description": "Byteotia has been eventually touched by globalisation, and so has Byteasar the Postman, who once roamedthe country lanes amidst sleepy hamlets and who now dashes down the motorways. But it is those strolls inthe days of yore that he reminisces about with a touch of tenderness.\n\nIn the olden days $n$ Byteotian villages (numbered from $1$ to $n$) were connected by bidirectional dirt roadsin such a way, that one could reach the village number $1$ (called Bitburg) from any other village in exactlyone way. This unique route passed only through villages with number less or equal to that of the startingvillage. Furthermore, each road connected exactly two distinct villages without passing through any othervillage. The roads did not intersect outside the villages, but tunnels and viaducts were not unheard of.\n\nTime passing by, successive roads were being transformed into motorways. Byteasar remembers distinctly,  when each of the country roads so disappeared. Nowadays, there is not a single country lane left  in Byteotia - all of them have been replaced with motorways, which connect the villages into Byteotian  Megalopolis.\n\nByteasar recalls his trips with post to those villages. Each time he was beginning his journey with letters  to some distinct village in Bitburg. He asks you to calculate, for each such journey (which took place in a      specific moment of time and led from Bitburg to a specified village), how many country roads it led through.\n\nTaskWrite a programme which:\n\nreads from the standard input:\n\ndescriptions of roads that once connected Byteotian villages,    sequence of events: Byteasar's trips and the moments when respective roads were transformed    into motorways,            for each trip, calculates how many country roads Byteasar has had to walk,        writes the outcome to the standard output.", "inputFormat": "In the first line of the standard input there is a single integer $n$ ($1\\le n\\le 250\\ 000$),denoting the number of villages in Byteotia. The following $n-1$ lines contain descriptions of the roads, in the form of two integers $a$,$b$ ($1\\le a<b\\le n$)separated by a single space, denoting the numbers of villages connected with a road. Inthe next line there is a single integer $m$($1\\le m\\le 250\\ 000$),denoting the number of trips Byteasar has made.\n\nThe following $n+m-1$ lines contain descriptions of the events, in chronological order:\n\nA description of the form \"A $a$ $b$\"(for $a<b$) denotes a country road between villages $a$ and $b$ beingtransformed into a motorway in that particular moment.\n\nA description of the from \"W $a$\" denotes Byteasar's trip from Bitburg to village $a$.", "outputFormat": "Your programme should write out exactly $m$ integers to the standard output, one a line, denoting the numberof country roads Byteasar has travelled during his successive trips.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] MEG-Megalopolis", "background": null, "description": "Byteotia 最终也被全球化浪潮席卷，邮递员 Byteasar 也不例外。他曾经漫步在宁静的乡间小村中，如今却飞驰在高速公路上。但往昔那些悠闲的漫步，仍让他带着一丝温柔怀念。\n\n过去，$n$ 个 Byteotia 村庄（编号 $1$ 至 $n$）通过双向泥土路相连，其结构满足：\n\n从任意村庄出发到村庄 $1$（称为 Bitburg）存在唯一路径。\n\n该路径仅经过编号小于等于起点村庄的村庄。\n\n每条路直接连接两个不同村庄且不经过其他村庄。\n\n道路不在村庄外交叉（但可能存在隧道或高架桥）。\n\n岁月流转，乡间道路相继被改造成高速公路。Byteasar 清晰地记得每条路消失的时刻。如今，Byteotia 已无乡间小路——它们全被高速公路取代，将村庄连成了 Byteotia 大都市。\n\nByteasar 回想起他去各村送信的旅程。每次他从 Bitburg 出发，前往某个特定村庄。请你计算：对于每次发生在特定时刻、从 Bitburg 到指定村庄的旅程，他途经了多少条乡间道路。\n\n### 任务\n\n编写程序实现：\n\n1. 输入：\n\n- 初始道路连接描述\n\n- 按时间顺序的事件序列（Byteasar 的旅程和道路改造事件）\n\n2. 输出：\n\n- 对每次旅程，计算 Byteasar 经过的乡间道路数量", "inputFormat": "第一行：整数 $n$（$1 \\le n \\le 250,000$），表示村庄数。\n\n接下来 $n-1$ 行：每行两个整数 $a, b$（$1 \\le a < b \\le n$），表示一条连接村庄 $a$ 和 $b$ 的初始道路。\n\n下一行：整数 $m$（$1 \\le m \\le 250,000$），表示旅程次数。\n\n接下来 $n+m-1$ 行：按时间顺序描述事件：\n\n- `A a b`（$a < b$）：村庄 $a$ 和 $b$ 间的道路被改造为高速公路。\n\n- `W a`：Byteasar 从 Bitburg 出发到村庄 $a$ 的旅程查询。", "outputFormat": "输出 $m$ 行，每行一个整数，表示每次旅程中经过的乡间道路数量。", "hint": "翻译：DeepSeek-R1", "locale": "zh-CN"}}}
{"pid": "P3460", "type": "P", "difficulty": 6, "samples": [["5\n5\n2\n3\n1\n4\n1\n4\n3\n5\n2", "2\n5\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2007", "树状数组", "POI（波兰）", "Special Judge", "栈"], "title": "[POI 2007] TET-Tetris Attack", "background": "", "description": "一种名为 *Tetris Attack* 的猜谜游戏风靡 Byteotia。游戏本身非常复杂，因此我们只介绍它的简化规则：\n\n玩家拥有一个有 $2n$ 个元素的栈，一个元素放置在另一个元素上，这样一个组合有 $n$ 个不同的符号标记。对于每个符号，栈中恰好有两个元素用一个符号标记。\n\n玩家可以交换两个相邻元素，即互换他们的位置。交换后，如果有两个相邻的元素标有相同的符号，则将他们都从栈中删除。然后，位于其上方的所有元素都会掉落下来，并且可以造成再次删除。\n\n玩家的目标是以最少的移动次数清空堆栈。请你编写一个程序，找出最少的移动次数及方案。", "inputFormat": "第一行一个整数 $n$。\n\n接下来的 $2n$ 行里给出了栈的初始内容，第 $i+1$ 行包含一个整数 $a_i$（$1 \\leq a_i \\leq n $），表示从底部数起第 $i$ 个元素所标记的符号（每个符号都在栈中出现正好两次）。\n\n最初不存在相邻的两个元素符号相同的情况，保证有不超过 $10^6$ 次操作的方案。", "outputFormat": "第一行一个整数 $m$ ，表示最小的移动次数。\n\n接下来 $m$ 行，每行输出一个数。\n\n第 $i + 1$ 行输出 $p_i$，即表示玩家在第 $i$ 步时选择交换 $p_i$ 与 $p_{i+1}$。\n\n如果存在多个方案，则输出其中任何一个。", "hint": "$1 \\le n \\le 50000$", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2007] TET-Tetris Attack", "background": "", "description": "A puzzle game named Tetris Attack is popular in Byteotia. The game itself is very complex, so we only describe its simplified rules:\n\nThe player has a stack with $2n$ elements, one placed atop another. There are $n$ distinct symbols in total. For each symbol, exactly two elements in the stack are labeled with that symbol.\n\nThe player may swap two adjacent elements, i.e., exchange their positions. After a swap, if two adjacent elements bear the same symbol, remove both from the stack. Then all elements above them fall down, which may trigger further removals.\n\nThe goal is to empty the stack with the fewest moves. Write a program to find the minimum number of moves and one corresponding sequence of swaps.", "inputFormat": "The first line contains an integer $n$.\n\nThe next $2n$ lines give the initial contents of the stack. The $(i+1)$-th line contains an integer $a_i$ ($1 \\leq a_i \\leq n$), indicating that the $i$-th element from the bottom is labeled with symbol $a_i$ (each symbol appears in the stack exactly twice).\n\nInitially, there are no two adjacent elements with the same symbol. It is guaranteed that there exists a solution with at most $10^6$ moves.", "outputFormat": "The first line contains an integer $m$, the minimum number of moves.\n\nThe next $m$ lines each contain one number.\n\nOn the $(i+1)$-th line, output $p_i$, meaning that on the $i$-th step the player swaps positions $p_i$ and $p_{i+1}$.\n\nIf there are multiple valid solutions, output any of them.", "hint": "$1 \\le n \\le 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2007] TET-Tetris Attack", "background": "", "description": "一种名为 *Tetris Attack* 的猜谜游戏风靡 Byteotia。游戏本身非常复杂，因此我们只介绍它的简化规则：\n\n玩家拥有一个有 $2n$ 个元素的栈，一个元素放置在另一个元素上，这样一个组合有 $n$ 个不同的符号标记。对于每个符号，栈中恰好有两个元素用一个符号标记。\n\n玩家可以交换两个相邻元素，即互换他们的位置。交换后，如果有两个相邻的元素标有相同的符号，则将他们都从栈中删除。然后，位于其上方的所有元素都会掉落下来，并且可以造成再次删除。\n\n玩家的目标是以最少的移动次数清空堆栈。请你编写一个程序，找出最少的移动次数及方案。", "inputFormat": "第一行一个整数 $n$。\n\n接下来的 $2n$ 行里给出了栈的初始内容，第 $i+1$ 行包含一个整数 $a_i$（$1 \\leq a_i \\leq n $），表示从底部数起第 $i$ 个元素所标记的符号（每个符号都在栈中出现正好两次）。\n\n最初不存在相邻的两个元素符号相同的情况，保证有不超过 $10^6$ 次操作的方案。", "outputFormat": "第一行一个整数 $m$ ，表示最小的移动次数。\n\n接下来 $m$ 行，每行输出一个数。\n\n第 $i + 1$ 行输出 $p_i$，即表示玩家在第 $i$ 步时选择交换 $p_i$ 与 $p_{i+1}$。\n\n如果存在多个方案，则输出其中任何一个。", "hint": "$1 \\le n \\le 50000$", "locale": "zh-CN"}}}
{"pid": "P3461", "type": "P", "difficulty": 0, "samples": [["8 11\n1 2 6\n3 1 5\n2 3 8\n3 4 9\n3 5 10\n5 4 3\n5 6 9\n6 4 8\n6 8 8\n6 7 7\n8 7 10\n4 2 5 7 8", "42 5\n2 3\n3 5\n5 6\n6 7\n6 8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "POI（波兰）", "Special Judge"], "title": "[POI 2007] KOL-Railway", "background": "", "description": "Byteland Railways encountered a necessity of restructuring and    reduction of the rail network.\n\nAfter a deep analysis of of the rail network it has been decided    which railway stations will be removed and which ones will stay.\n\nIt has been also decided that the rail network should be reduced as far    as possible.\n\nIt remains to choose which railway lines should be removed and which    ones should stay.\n\nThe rail network is composed of rail segments connecting railway    stations.\n\nIt is known that from each station one can travel to every other    station (potentially visiting some intermediate stations).\n\nRail segments are bidirectional.\n\nThere can be at most one rail segment connecting each pair of stations.\n\nEach segment can be assigned a cost of maintenance, which is    a positive integer.\n\nThe rail segments that will remain should be chosen in such    way that:\n\nit is possible to travel between every pair of stations        that are not going to be removed,                  their total cost of maintenance is low (it can be at most two times        greater than the lowest cost that can be achieved, assuming that the        previous condition is satisfied).\n\nAll remaining rail segments will be removed.\n\nRailway lines that will remain can run through stations that will be    removed.\n\nTaskWrite a programme which:\n\nreads a description of the rail network and the stations          that will not be removed from the standard input,                      determines which rail segments should remain and which should          be removed,                      writes out the rail segments that should remain together with the          total cost of their maintenance to the standard output.\n", "inputFormat": "The first line of input contains two positive integers $n$ and $m$, $2\\le n\\le 5\\ 000$, $1\\le m\\le 500\\ 000$($m\\le \\frac{n(n-1)}{2}$),      separated by a single space.\n\n$n$ denotes the number of railway stations and $m$ is the number of rail segments.\n\nRailway stations are numbered from $1$ to $n$.\n\nThe following $m$ lines contain descriptions of the rail      segments, one per line.\n\nEach of these lines contains three positive integers $a$,$b$ and $u$,$1\\le a,b\\le n$,$a\\ne b$,$1\\le u\\le 100\\ 000$.\n\n$a$ and $b$ are the numbers of stations that are connected      by the segment and $u$ is its cost of maintenance.\n\nThe $(m+2)$'th line contains a sequence of integers separated by      single spaces.\n\nThe first one of them is $p$ - the number of stations that should remain      ($1\\le p\\le n$, $p\\cdot m\\le 15\\ 000\\ 000$).\n\nIt is followed by the numbers of these stations in increasing order.\n", "outputFormat": "The first line of output should contain two integers $c$ and $k$ separated by a single space, where $c$ is the total cost of maintenance of the segments that      should remain and $k$ is the number of these segments.\n\nEach of the following $k$ lines should contain two integers $a_i$ and $b_i$, separated by a single space -      the numbers of stations that are connected by the segment.\n\nThe total cost of maintenance of the segments can be at most      two times greater than the lowest achievable total cost.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2007] KOL-Railway", "background": "", "description": "Byteland Railways encountered a necessity of restructuring and    reduction of the rail network.\n\nAfter a deep analysis of of the rail network it has been decided    which railway stations will be removed and which ones will stay.\n\nIt has been also decided that the rail network should be reduced as far    as possible.\n\nIt remains to choose which railway lines should be removed and which    ones should stay.\n\nThe rail network is composed of rail segments connecting railway    stations.\n\nIt is known that from each station one can travel to every other    station (potentially visiting some intermediate stations).\n\nRail segments are bidirectional.\n\nThere can be at most one rail segment connecting each pair of stations.\n\nEach segment can be assigned a cost of maintenance, which is    a positive integer.\n\nThe rail segments that will remain should be chosen in such    way that:\n\nit is possible to travel between every pair of stations        that are not going to be removed,                  their total cost of maintenance is low (it can be at most two times        greater than the lowest cost that can be achieved, assuming that the        previous condition is satisfied).\n\nAll remaining rail segments will be removed.\n\nRailway lines that will remain can run through stations that will be    removed.\n\nTaskWrite a programme which:\n\nreads a description of the rail network and the stations          that will not be removed from the standard input,                      determines which rail segments should remain and which should          be removed,                      writes out the rail segments that should remain together with the          total cost of their maintenance to the standard output.\n", "inputFormat": "The first line of input contains two positive integers $n$ and $m$, $2\\le n\\le 5\\ 000$, $1\\le m\\le 500\\ 000$($m\\le \\frac{n(n-1)}{2}$),      separated by a single space.\n\n$n$ denotes the number of railway stations and $m$ is the number of rail segments.\n\nRailway stations are numbered from $1$ to $n$.\n\nThe following $m$ lines contain descriptions of the rail      segments, one per line.\n\nEach of these lines contains three positive integers $a$,$b$ and $u$,$1\\le a,b\\le n$,$a\\ne b$,$1\\le u\\le 100\\ 000$.\n\n$a$ and $b$ are the numbers of stations that are connected      by the segment and $u$ is its cost of maintenance.\n\nThe $(m+2)$'th line contains a sequence of integers separated by      single spaces.\n\nThe first one of them is $p$ - the number of stations that should remain      ($1\\le p\\le n$, $p\\cdot m\\le 15\\ 000\\ 000$).\n\nIt is followed by the numbers of these stations in increasing order.\n", "outputFormat": "The first line of output should contain two integers $c$ and $k$ separated by a single space, where $c$ is the total cost of maintenance of the segments that      should remain and $k$ is the number of these segments.\n\nEach of the following $k$ lines should contain two integers $a_i$ and $b_i$, separated by a single space -      the numbers of stations that are connected by the segment.\n\nThe total cost of maintenance of the segments can be at most      two times greater than the lowest achievable total cost.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] KOL-Railway", "background": "", "description": "出言不逊铁路系统需要重新布置。通过对铁路网络深入的分析，有一些站点需要被移除，有一些道路也需要被移除。 整个铁路网络可以看做一张由 $n$ 个点，$m$ 条道路组成的无向图。从每一个点出发都可以通过直接或间接的道路到达其它所有点。两个站点之间最多只有一条道路。每一条道路都有一个正整数费用。你的任务是决定哪些点和道路需要被保留。 要求：\n\n1.从每一个没被移除的点出发都能通过直接或间接的没被移除的道路到达其他所有没被移除的点。\n\n2.剩下的道路的费用总和要比较小，即不能超过最优解的两倍。", "inputFormat": "第一行包含两个正整数 $n$、$m$（$2\\leq n\\leq 5\\times 10^3$，$1\\leq m\\leq 5\\times 10^5$），表示点数和边数。 接下来 $m$ 行，每行包含三个正整数 $a$、$b$、$u$（$1\\leq a$、$b\\leq n$，$a\\neq b$，$1\\leq u\\leq 1 \\times 10^5$），表示 $a$ 和 $b$ 之间有一条费用为 $u$ 的道路。 最后一行的开头为一个正整数 $p$（$2\\leq p\\leq n$，$p\\times m\\leq 1.5\\times 10^7$），表示必须要保留的点数。 接下来包含 $p$ 个正整数，按递增顺序依次给出必须保留的点的编号。", "outputFormat": "第一行包含两个正整数 $c$、$k$，其中 $c$ 表示剩余道路的费用总和，$k$ 表示剩余道路的条数。 接下来 $k$ 行，每行包含两个正整数 $a$、$b$，表示一条道路的两个端点。 如有多组解，输出任意一组。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3462", "type": "P", "difficulty": 6, "samples": [["2 4\n13 9\n4 12 2 4", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "贪心", "2007", "POI（波兰）", "进制"], "title": "[POI 2007] ODW-Weights", "background": "", "description": "While moving to a new compound the Byteotian Institute of Experimental Physics has encountered a logisticalproblem - the transfer of its vast collection of precision weights turned out to be non-trivial.\n\nThe Institute has a certain number of containers of limited strength at its disposal. As many weightsas possible are to be put into the containers, the remaining ones will be discarded. There is no limit onthe number of weights to be put in a container apart from the requirement of not exceeding its strength. Acontainer may also be empty.\n\nAny two weights in the Institute have a peculiar property: the mass of one of them is an integer multipleof the mass of the other. Particularly, they may have the same mass.\n\nTaskWrite a programme which:\n\nreads the durabilities of the containers and masses of the weights from the standard input,        determines the maximal number of weights that can be put in the containers,        writes the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains two integers $n$ and $m$($1\\le n,m\\le 100\\ 000$), separated by a singlespace, denoting respectively: the number of containers and the number of weights. The second line of thestandard input consists of $n$ integers $w_i$ ($1\\le w_i\\le 1\\ 000\\ 000\\ 000$ for $1\\le i\\le n$), separated by single spaces,denoting the strengths of containers in milligrammes. In the third line there are $m$ integers $m_j$($1\\le m_j\\le 1\\ 000\\ 000\\ 000$) for $1\\le j\\le m$), separated by single spaces, denoting masses of the weights in milligrammes.\n", "outputFormat": "The first and only line of the standard output should contain a single integer -the maximal number ofweights that can be placed in the containers without exceeding their durability.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2007] ODW-Weights", "background": "", "description": "While moving to a new compound the Byteotian Institute of Experimental Physics has encountered a logisticalproblem - the transfer of its vast collection of precision weights turned out to be non-trivial.\n\nThe Institute has a certain number of containers of limited strength at its disposal. As many weightsas possible are to be put into the containers, the remaining ones will be discarded. There is no limit onthe number of weights to be put in a container apart from the requirement of not exceeding its strength. Acontainer may also be empty.\n\nAny two weights in the Institute have a peculiar property: the mass of one of them is an integer multipleof the mass of the other. Particularly, they may have the same mass.\n\nTaskWrite a programme which:\n\nreads the durabilities of the containers and masses of the weights from the standard input,        determines the maximal number of weights that can be put in the containers,        writes the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains two integers $n$ and $m$($1\\le n,m\\le 100\\ 000$), separated by a singlespace, denoting respectively: the number of containers and the number of weights. The second line of thestandard input consists of $n$ integers $w_i$ ($1\\le w_i\\le 1\\ 000\\ 000\\ 000$ for $1\\le i\\le n$), separated by single spaces,denoting the strengths of containers in milligrammes. In the third line there are $m$ integers $m_j$($1\\le m_j\\le 1\\ 000\\ 000\\ 000$) for $1\\le j\\le m$), separated by single spaces, denoting masses of the weights in milligrammes.\n", "outputFormat": "The first and only line of the standard output should contain a single integer -the maximal number ofweights that can be placed in the containers without exceeding their durability.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] ODW-Weights", "background": "", "description": "在搬迁到一个新的园区时，Byteotian 实验物理研究所遇到了一个后勤问题——转移其庞大的精密砝码收藏变得不那么简单。\n\n研究所有若干个强度有限的容器可供使用。需要尽可能多地将砝码放入容器中，剩下的将被丢弃。除了不超过容器的强度外，放入容器中的砝码数量没有限制。一个容器也可以是空的。\n\n研究所的任意两个砝码有一个特殊的性质：其中一个的质量是另一个质量的整数倍。特别地，它们可能具有相同的质量。\n\n任务编写一个程序：\n\n从标准输入中读取容器的强度和砝码的质量，确定可以放入容器中的最大砝码数量，将结果写入标准输出。\n", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $m$（$1\\le n,m\\le 100\\ 000$），用单个空格分隔，分别表示容器的数量和砝码的数量。标准输入的第二行由 $n$ 个整数 $w_i$（$1\\le w_i\\le 1\\ 000\\ 000\\ 000$，$1\\le i\\le n$）组成，用单个空格分隔，表示容器的强度（单位：毫克）。第三行有 $m$ 个整数 $m_j$（$1\\le m_j\\le 1\\ 000\\ 000\\ 000$，$1\\le j\\le m$），用单个空格分隔，表示砝码的质量（单位：毫克）。\n", "outputFormat": "标准输出的第一行应包含一个整数——可以放入容器中的最大砝码数量，而不超过其强度。\n", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3463", "type": "P", "difficulty": 5, "samples": [["4 3 5 2\n2 0 0\n2 2 1\n3 3 1\n1 1 1\n3 3 0", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2007", "POI（波兰）"], "title": "[POI 2007] EGZ-Driving Exam", "background": "", "description": "The Byteotian driving licence exam takes place in an area in which there are $n$ straight, parallel, unidirectional, north-oriented streets (that is the allowed driving direction is south to north). Each of the streets is exactly $m$ meters long, all of them begin and end on the same level. These streets are numbered from $1$ to $n$ starting the westernmost. There are also $p$ unidirectional, east or west-oriented streets perpendicular to the abovementioned, each one of them connecting a pair of adjacent north-oriented streets. It is also possible that an east-oriented and a west-oriented street overlap, thus forming a bidirectional one.\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/6981.png) \n\nAn exemplary testing area ($n=4, m=3, p=5$).\n\nThe examiner chooses a north-oriented street, at the beginnig of which the examination starts and anothernorth-oriented street, where it is to come to an end. The task of the applicant is to drive from the starting tothe final point, observing the allowed directions.The examiner always chooses as starting point a street, from which it is possible to drive to the endpointof any other north-oriented street.The work of the examiners is a very tedious one, because they always have to start at the beginning ofone of the few suitable streets. The board of directors have decided to build a new testing area on the basis ofpre-existent plans. It has been calculated, that available funds allow for no more than $k$ east or west-orientedstreets to be built. Those new streets are to be constructed in such a way, so as to add the largest possiblenumber of potential starting points (there may or may not exist starting points on the pre-existent plan). Newstreets have to connect pairs of adjacent north-oriented streets.\n\n## Task\n\nWrite a programme which:\n\n- reads a description of the testing area and the number $k$ from the standard input,\n\n- calculates the greatest number of potential new starting points for the examination, generated by adding no more than $k$ east or west-oriented streets,\n\n- writes the outcome to the standard output.\n", "inputFormat": "In the first line of the standard input there are four integers $n$, $m$, $p$ and $k$ ($2 \\le n \\le 100\\ 000$, $1 \\le m, k, \\le 100\\ 000$, $0 \\le p \\le 100\\ 000$), separated by single spaces, denoting respectively: the number of north-oriented streets, the length of each one of them, the number of pre-existent east or west-oriented streets, the maximal number of new streets to be built. The north-oriented streets are numbered from $1$ to $n$, starting with the westernmost.\n\n\nThe following $p$ lines contain three integers each: $n_i$, $m_i$ and $d_i$ ($1 \\le n_i \\le n$, $0 \\le m_i \\le m$, $d_i \\in \\{0, 1\\}$), separated by single spaces, denoting the 'th east-oriented (for $d_i=0$) or west-oriented (for $d_i=1$) street. This street connects north-oriented streets $n$ and $n+1$, intersecting them in points $m_i$ meters distant from their beginning.\n", "outputFormat": "The first and only line of the standard output should contain a single integer, denoting the maximal numberof new examination starting points generated by building no more than $k$ east or west-oriented streets. Thenewly built streets **do not have to** intersect the north-oriented streets in points, whose distance from thebeginning of the street is an integer. The newly built east or west-oriented streets may overlap, thus formingbidirectional streets.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2007] EGZ-Driving Exam", "background": "", "description": "The Byteotian driving licence exam takes place in an area in which there are $n$ straight, parallel, unidirectional, north-oriented streets (that is the allowed driving direction is south to north). Each of the streets is exactly $m$ meters long, all of them begin and end on the same level. These streets are numbered from $1$ to $n$ starting the westernmost. There are also $p$ unidirectional, east or west-oriented streets perpendicular to the abovementioned, each one of them connecting a pair of adjacent north-oriented streets. It is also possible that an east-oriented and a west-oriented street overlap, thus forming a bidirectional one.\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/6981.png) \n\nAn exemplary testing area ($n=4, m=3, p=5$).\n\nThe examiner chooses a north-oriented street, at the beginnig of which the examination starts and anothernorth-oriented street, where it is to come to an end. The task of the applicant is to drive from the starting tothe final point, observing the allowed directions.The examiner always chooses as starting point a street, from which it is possible to drive to the endpointof any other north-oriented street.The work of the examiners is a very tedious one, because they always have to start at the beginning ofone of the few suitable streets. The board of directors have decided to build a new testing area on the basis ofpre-existent plans. It has been calculated, that available funds allow for no more than $k$ east or west-orientedstreets to be built. Those new streets are to be constructed in such a way, so as to add the largest possiblenumber of potential starting points (there may or may not exist starting points on the pre-existent plan). Newstreets have to connect pairs of adjacent north-oriented streets.\n\n## Task\n\nWrite a programme which:\n\n- reads a description of the testing area and the number $k$ from the standard input,\n\n- calculates the greatest number of potential new starting points for the examination, generated by adding no more than $k$ east or west-oriented streets,\n\n- writes the outcome to the standard output.\n", "inputFormat": "In the first line of the standard input there are four integers $n$, $m$, $p$ and $k$ ($2 \\le n \\le 100\\ 000$, $1 \\le m, k, \\le 100\\ 000$, $0 \\le p \\le 100\\ 000$), separated by single spaces, denoting respectively: the number of north-oriented streets, the length of each one of them, the number of pre-existent east or west-oriented streets, the maximal number of new streets to be built. The north-oriented streets are numbered from $1$ to $n$, starting with the westernmost.\n\n\nThe following $p$ lines contain three integers each: $n_i$, $m_i$ and $d_i$ ($1 \\le n_i \\le n$, $0 \\le m_i \\le m$, $d_i \\in \\{0, 1\\}$), separated by single spaces, denoting the 'th east-oriented (for $d_i=0$) or west-oriented (for $d_i=1$) street. This street connects north-oriented streets $n$ and $n+1$, intersecting them in points $m_i$ meters distant from their beginning.\n", "outputFormat": "The first and only line of the standard output should contain a single integer, denoting the maximal numberof new examination starting points generated by building no more than $k$ east or west-oriented streets. Thenewly built streets **do not have to** intersect the north-oriented streets in points, whose distance from thebeginning of the street is an integer. The newly built east or west-oriented streets may overlap, thus formingbidirectional streets.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2007] EGZ-Driving Exam", "background": null, "description": "**译自 POI 2007 Stage 3. Day 2「[Egzamin na prawo jazdy](https://szkopul.edu.pl/problemset/problem/nLSrpyeJ1JnFGbBORYVVavIQ/site/?key=statement)」**\n\nByteotian 驾驶考试所在的区域有 $n$ 条互相平行的自南向北的道路，每条道路长为 $m$ 米，且在同一条水平线上开始、结束。另有 $p$ 条自东向西或自西向东的道路，连接两条相邻的自南向北的道路。注意可能有两条自东向西的道路和自西向东的道路重合，相当于一条双向道路。\n\n![](https://cdn.luogu.com.cn/upload/pic/6981.png)\n\n上图为 $n=4,m=3,p=5$ 的例子。\n\n考生可以选择一条自南向北的道路作为起始点，且从该道路开始必须能到达其它所有**自南向北**的道路。\n\n你需要添加至多 $k$ 条东西向的道路，使得满足条件的起始点最多。", "inputFormat": "第一行四个整数 $n,m,p,k$（$2 \\le n \\le 100\\ 000,1 \\le m,k \\le 100\\ 000,0 \\le p \\le 100\\ 000$），分别表示自南向北的道路数量、这些道路的长度、初始时已有的自东向西或自西向东的道路数量、可以添加的道路的数量。自南向北的道路从西向东编号为 $1 \\ldots n$。\n\n接下来 $p$ 行每行三个整数 $n_i, m_i, d_i (1 \\le n_i \\lt n,0 \\le m_i \\lt m,d_i \\in \\{0,1\\})$，表示一条连接第 $n_i$ 和 $n_i+1$ 条自南向北的道路、且距离起点 $m_i$ 米的东西向道路。$d_i = 0$ 时为向东的道路，$d_i = 1$ 时为向西的道路。", "outputFormat": "输出一行，表示**新产生**的起始点的最大数量。添加的东西向道路**不一定**要在整点和南北向道路相交。自东向西的道路和自西向东的可以重叠，相当于双向道路。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2661)。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3464", "type": "P", "difficulty": 6, "samples": [["166", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2007", "POI（波兰）", "进制"], "title": "[POI 2007] WAG-Quaternary Balance", "background": "", "description": "Byteasar the dragon intends to throw a party, to which he would like to invite many guests. Byteasar wouldalso like to present each guest with an amount of gold to honour the party. Each should receive the sameamount, so that no one's pride is hurt. The dragon is going to weigh out gold for subsequent guests with abeam balance. He has different types of standard masses at his disposal, each type weighing a certain powerof four. Conveniently, Byteasar has lots of the standard masses, hence he may use any number of masses ofany type (power of four) he finds appropriate. Byteasar will always lay the gold on the left weighing basinand the masses on the right or both weighing basins. The dragon wishes to use the least number of massespossible for each weighing. Furthermore, to entertain his guests, Byteasar would like to measure out the goldin unique manner for each person (ie. using different masses or distributing them among the weighing basinsin a different way).\n\nSince dragons' lack of arithmetic skills is legendary, Byteasar has aksed you to write a programme thatwill determine how many guests he may invite, that is, finds the maximum number of ways in which $n$ grammes of gold can be weighed out using the minimum number of masses possible. Should you fare well,you will also get your share!\n\nTaskWrite a programme that:\n\nreads from the standard input the amount of gold (in grammes) which Byteasar intends to present each    guest with,        calculates the number of ways in which this amount of gold can be weighed out using the minimum    number of masses possible,        writes out the remainder of dividing the result by $10^9$ to the standard output.\n\n给定一个数 $n$，要求将 $n$ 表示成一些 $4^k$ 的数之和/差的形式，要求用的数最少，求方案数模 $10^9$ 的结果。\n", "inputFormat": "In the first and only line of the standard input there is one positive integer $n$($1\\le n<10^{1000}$).\n\nIt is the amountof gold (in grammes) which Byteasar intends to present each guest with.\n", "outputFormat": "One integer should be written out to the standard output -the remainder of dividing by $10^9$ the maximumnumber of guests Byteasar can invite (that is, the maximum number of ways in which $n$ grammes of gold canbe weighed out using the minimum number of masses possible).\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2007] WAG-Quaternary Balance", "background": "", "description": "Byteasar the dragon plans to throw a party and give each guest the same amount of gold so that no one feels slighted. He will weigh the gold for each guest using a beam balance. He has standard masses whose weights are powers of four. Conveniently, he has an unlimited supply of each type of mass (each power of four). Byteasar will always place the gold on the left pan, and he may place masses on the right pan or on both pans. He wants to use the fewest masses possible for each weighing. Moreover, to entertain his guests, he would like to measure the gold in a unique way for each person (i.e., using different masses or distributing them between the pans differently).\n\nSince dragons are not known for arithmetic, Byteasar asks you to write a program to determine how many guests he can invite, i.e., the maximum number of ways to weigh out $n$ grams of gold using the minimum number of masses possible. You should output the result modulo $10^9$.\n\nIn other words, given a number $n$, express $n$ as a sum and/or difference of numbers of the form $4^k$, using the fewest terms, and count the number of such representations, modulo $10^9$.", "inputFormat": "The first and only line contains one positive integer $n$ ($1 \\le n < 10^{1000}$), the amount of gold in grams Byteasar intends to give each guest.", "outputFormat": "Print one integer: the remainder modulo $10^9$ of the maximum number of ways to weigh out $n$ grams using the minimum number of masses possible.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2007] WAG-Quaternary Balance", "background": "", "description": "Byteasar the dragon intends to throw a party, to which he would like to invite many guests. Byteasar wouldalso like to present each guest with an amount of gold to honour the party. Each should receive the sameamount, so that no one's pride is hurt. The dragon is going to weigh out gold for subsequent guests with abeam balance. He has different types of standard masses at his disposal, each type weighing a certain powerof four. Conveniently, Byteasar has lots of the standard masses, hence he may use any number of masses ofany type (power of four) he finds appropriate. Byteasar will always lay the gold on the left weighing basinand the masses on the right or both weighing basins. The dragon wishes to use the least number of massespossible for each weighing. Furthermore, to entertain his guests, Byteasar would like to measure out the goldin unique manner for each person (ie. using different masses or distributing them among the weighing basinsin a different way).\n\nSince dragons' lack of arithmetic skills is legendary, Byteasar has aksed you to write a programme thatwill determine how many guests he may invite, that is, finds the maximum number of ways in which $n$ grammes of gold can be weighed out using the minimum number of masses possible. Should you fare well,you will also get your share!\n\nTaskWrite a programme that:\n\nreads from the standard input the amount of gold (in grammes) which Byteasar intends to present each    guest with,        calculates the number of ways in which this amount of gold can be weighed out using the minimum    number of masses possible,        writes out the remainder of dividing the result by $10^9$ to the standard output.\n\n给定一个数 $n$，要求将 $n$ 表示成一些 $4^k$ 的数之和/差的形式，要求用的数最少，求方案数模 $10^9$ 的结果。\n", "inputFormat": "In the first and only line of the standard input there is one positive integer $n$($1\\le n<10^{1000}$).\n\nIt is the amountof gold (in grammes) which Byteasar intends to present each guest with.\n", "outputFormat": "One integer should be written out to the standard output -the remainder of dividing by $10^9$ the maximumnumber of guests Byteasar can invite (that is, the maximum number of ways in which $n$ grammes of gold canbe weighed out using the minimum number of masses possible).\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3465", "type": "P", "difficulty": 5, "samples": [["4 5\n1 2\n2 3\n1 3\n3 4\n1 4", "TAK\n3\n3\n4\n1"], ["4 3\n1 3\n3 4\n2 3", "NIE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "并查集", "POI（波兰）", "Special Judge"], "title": "[POI 2008] CLO-Toll", "background": "", "description": "King Byteasar has yielded under pressure of Byteotian merchants and  hence decided to settle the issue of toll paid by them.\n\nByteotia consists of $n$ towns connected with $m$ bidirectional roads.\n\nEach road connects directly two different towns and no two towns are  connected by more than one direct road.\n\nNote that the roads may lead through tunnels or flyovers.\n\nUntil now each town in Byteotia imposed duty on everyone who  either entered or left the town.\n\nThe merchants, discontented with such situation, lodged a protest  against multiple taxation.\n\nKing Byteasar ruled that the town privileges are now restricted.\n\nAccording to the new royal edict, each town can only charge toll on  merchants travelling by exact one road leading into the town,  regardless of the direction they are travelling in.\n\nFurthermore, for each road, those who travel it cannot be made to pay  the duty to both towns the road connects.\n\nIt remains to determine which town should collect toll from which road.\n\nSolving this problem His Highness has commissioned to you.\n\n## Task\n\nWrite a programme that:\n\n- reads the Byteotian road system's description from the standard input,\n\n- for each town determines on which road it should impose toll, or claims it is impossible,\n\n- writes out the result to the standard output.\n", "inputFormat": "There are two integers in the first line of the standard input: $n$ and $m$ ($1 \\le n \\le 100\\ 000$, $1 \\le n \\le 200\\ 000$), denoting the number of towns and roads in Byteotia, respectively. The towns are numbered from $1$ to $n$. In next $m$ lines descriptions of the roads follow. In line No. $i$ there are two integers $a_i$ and $b_i$ () meaning that towns $a_i$ and $b_i$ are directly connected by a road.\n", "outputFormat": "If collecting the toll in accordance with the royal edict is impossible, your programme should write the word NIE ('no' in Polish) in the first and only line of the standard output. Otherwise, it should write the word TAK ('yes' in Polish) in the first line, while in the following $n$ lines should tell which city collects toll from which road. Line no. $(i+1)$ should tell on which road the town no. $i$ imposes toll. Since town no. $i$ is obviously one endpoint of this road, it is enough to tell what is the other endpoint. Thus if the town no. $i$ imposes toll on the road connecting it with the town no.$j$ , the line no. $(i+1)$ should contain the number $j$. If more than one solution exists, write out one chosen arbitrarily.\n", "hint": "样例1：\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/6984.png) \n\n样例2：\n\n![](https://cdn.luogu.com.cn/upload/pic/6985.png)\n", "locale": "en", "translations": {"en": {"title": "[POI 2008] CLO-Toll", "background": "", "description": "King Byteasar has yielded under pressure of Byteotian merchants and  hence decided to settle the issue of toll paid by them.\n\nByteotia consists of $n$ towns connected with $m$ bidirectional roads.\n\nEach road connects directly two different towns and no two towns are  connected by more than one direct road.\n\nNote that the roads may lead through tunnels or flyovers.\n\nUntil now each town in Byteotia imposed duty on everyone who  either entered or left the town.\n\nThe merchants, discontented with such situation, lodged a protest  against multiple taxation.\n\nKing Byteasar ruled that the town privileges are now restricted.\n\nAccording to the new royal edict, each town can only charge toll on  merchants travelling by exact one road leading into the town,  regardless of the direction they are travelling in.\n\nFurthermore, for each road, those who travel it cannot be made to pay  the duty to both towns the road connects.\n\nIt remains to determine which town should collect toll from which road.\n\nSolving this problem His Highness has commissioned to you.\n\n## Task\n\nWrite a programme that:\n\n- reads the Byteotian road system's description from the standard input,\n\n- for each town determines on which road it should impose toll, or claims it is impossible,\n\n- writes out the result to the standard output.\n", "inputFormat": "There are two integers in the first line of the standard input: $n$ and $m$ ($1 \\le n \\le 100\\ 000$, $1 \\le n \\le 200\\ 000$), denoting the number of towns and roads in Byteotia, respectively. The towns are numbered from $1$ to $n$. In next $m$ lines descriptions of the roads follow. In line No. $i$ there are two integers $a_i$ and $b_i$ () meaning that towns $a_i$ and $b_i$ are directly connected by a road.\n", "outputFormat": "If collecting the toll in accordance with the royal edict is impossible, your programme should write the word NIE ('no' in Polish) in the first and only line of the standard output. Otherwise, it should write the word TAK ('yes' in Polish) in the first line, while in the following $n$ lines should tell which city collects toll from which road. Line no. $(i+1)$ should tell on which road the town no. $i$ imposes toll. Since town no. $i$ is obviously one endpoint of this road, it is enough to tell what is the other endpoint. Thus if the town no. $i$ imposes toll on the road connecting it with the town no.$j$ , the line no. $(i+1)$ should contain the number $j$. If more than one solution exists, write out one chosen arbitrarily.\n", "hint": "样例1：\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/6984.png) \n\n样例2：\n\n![](https://cdn.luogu.com.cn/upload/pic/6985.png)\n", "locale": "en"}, "zh-CN": {"title": "[POI 2008] CLO-Toll", "background": "", "description": "给你 $n$ 个点和 $m$ 条双向边，问能否将其中的一些边改成有向边，使得只考虑有向边的情况下每个点的入度都为 $1$ 。", "inputFormat": "第一行输入 $n,m(1≤n≤100000,1≤m≤200000)$ ，接下来 $m$ 行每行两个数 $a,b$ 表示点 $a$ 和点 $b$ 之间有一条双向边。输入保证没有重边与自环。", "outputFormat": "若没有合法方案，输出 $\\verb!NIE!$，否则先在第一行输出 $\\verb!TAK!$，然后在第 $i+1$ 行输出点 $i$ 的入度是由哪个点出发的边所得到的。\n\n感谢@hdxrie 提供的翻译。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3466", "type": "P", "difficulty": 5, "samples": [["5 3\n3\n9\n2\n3\n1", "2\n3\n9\n2\n2\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "平衡树", "POI（波兰）", "Special Judge"], "title": "[POI 2008] KLO-Building blocks", "background": "", "description": "Byteasar loved to play with building blocks as a child.\n\nHe used to arrange the blocks into $n$ columns of random height  and then organize them in the following manner:\n\nByteasar would choose a number $k$ and try to arrange the blocks in such a way that  some $k$ consecutive columns would be of equal height. Furthermore he always tried to  achieve this goal in a minimum number of moves possible, where a single move consists in:\n\nlaying one block on top of any column      (Byteasar had a huge box with spare blocks, ensuring this move could always be performed),      or              removing the uppermost block from the top of any column.\n\nHowever, Byteasar was never quite sure if his sequence of moves was indeed optimal,  therefore he has asked you to write a programme that will help him solve the problem.\n\nTask    Write a programme that:\n\nreads the number $k$ along with the initial setup of the blocks from the standard input,determines the optimal solution (shortest possible sequence of moves),writes out the solution to the standard output.", "inputFormat": "In the first line of the standard input there are two integers, $n$ and $k$ ($1\\le k\\le n\\le 100\\ 000$), separated by a single space.\n\nEach of the following $n$ lines contains the height of some column;    the line no. $i+1$ contains the integer    $0\\le h_i\\le 1\\ 000\\ 000$ - the height of the $i^{th}$ column,    ie. the number of blocks it consists of.", "outputFormat": "The optimal solution should be written out to the standard output, ie. such arrangement    of blocks that:\n\ncontains $k$ consecutive columns of equal height,                  can be obtained from the initial setup in a minimum possible number of moves.\n\nThe output should consist of $n+1$ lines, each one containing a single integer.\n\nThe number in the first line should be the minimum number of moves needed to get    the desired arrangement.\n\nThe line no. $i+1$ (for $1\\le i\\le n$) should contain the number $h'_i$ -    the final height of the $i^{th}$ column.\n\nIf more than one optimal solution exists, write out one chosen arbitrarily.\n\n", "hint": "$1\\le k\\le n\\le 100\\ 000$，$0\\le h_i\\le 1\\ 000\\ 000$。", "locale": "en", "translations": {"en": {"title": "[POI 2008] KLO-Building blocks", "background": "", "description": "Byteasar loved to play with building blocks as a child.\n\nHe used to arrange the blocks into $n$ columns of random height  and then organize them in the following manner:\n\nByteasar would choose a number $k$ and try to arrange the blocks in such a way that  some $k$ consecutive columns would be of equal height. Furthermore he always tried to  achieve this goal in a minimum number of moves possible, where a single move consists in:\n\nlaying one block on top of any column      (Byteasar had a huge box with spare blocks, ensuring this move could always be performed),      or              removing the uppermost block from the top of any column.\n\nHowever, Byteasar was never quite sure if his sequence of moves was indeed optimal,  therefore he has asked you to write a programme that will help him solve the problem.\n\nTask    Write a programme that:\n\nreads the number $k$ along with the initial setup of the blocks from the standard input,determines the optimal solution (shortest possible sequence of moves),writes out the solution to the standard output.", "inputFormat": "In the first line of the standard input there are two integers, $n$ and $k$ ($1\\le k\\le n\\le 100\\ 000$), separated by a single space.\n\nEach of the following $n$ lines contains the height of some column;    the line no. $i+1$ contains the integer    $0\\le h_i\\le 1\\ 000\\ 000$ - the height of the $i^{th}$ column,    ie. the number of blocks it consists of.", "outputFormat": "The optimal solution should be written out to the standard output, ie. such arrangement    of blocks that:\n\ncontains $k$ consecutive columns of equal height,                  can be obtained from the initial setup in a minimum possible number of moves.\n\nThe output should consist of $n+1$ lines, each one containing a single integer.\n\nThe number in the first line should be the minimum number of moves needed to get    the desired arrangement.\n\nThe line no. $i+1$ (for $1\\le i\\le n$) should contain the number $h'_i$ -    the final height of the $i^{th}$ column.\n\nIf more than one optimal solution exists, write out one chosen arbitrarily.\n\n", "hint": "$1\\le k\\le n\\le 100\\ 000$，$0\\le h_i\\le 1\\ 000\\ 000$。", "locale": "en"}, "zh-CN": {"title": "[POI 2008] KLO-Building blocks", "background": null, "description": "有 $n$ 柱砖，每柱砖有一个高度，我们现在希望有连续 $k$ 柱的高度是一样的。\n\n你可以选择以下两个动作：\n\n1. 从某柱砖的顶端拿一块砖出来,丢掉不要了。\n2. 从仓库中拿出一块砖，放到某一柱，仓库是无限大的。\n\n现在希望用最小次数的动作完成任务，除此之外你还要求输出结束状态时，每柱砖的高度。", "inputFormat": "第一行两个用空格隔开的数表示 $n,k$。\n\n之后 $n$ 行，第 $i+1$ 行一个数表示第 $i$ 柱砖的高度 $h_i$。", "outputFormat": "输出 $n+1$ 行。\n\n第一行一个数表示最小化的答案。\n\n之后 $n$ 行，每行一个数表示结束后每柱砖的高度。", "hint": "本题 SPJ 的提示说明（按照 SPJ 判断顺序给出）：\n\n`Out of Range`：输出的数字不在答案可能的范围内。\n\n`Wrong Solution`：输出方案中不包含连续 $k$ 个相同高度的柱。\n\n`Wrong Result`：提交的程序的步数和输出方案的步数不相等。\n\n`Expected cost = a,found cost = b`：期望步数为 $a$，程序的步数为 $b$。\n\n`OK!Correct Answer!`：答案正确。\n\n$1 \\le k \\le n \\le 10^5$，$0 \\le h_i \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P3467", "type": "P", "difficulty": 3, "samples": [["5\n1 2\n1 3\n2 2\n2 5\n1 4", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2008", "POI（波兰）", "单调栈"], "title": "[POI 2008] PLA-Postering", "background": "", "description": "All the buildings in the east district of Byteburg were built in accordance with the old arbitecture: they stand next to each other with no spacing inbetween. Together they form a very long chain of buildings of diverse    height, extending from east to west.\n\nThe mayor of Byteburg, Byteasar, has decided to have the north face of the chain covered with posters. Byteasar ponders over the minimum number of posters sufficient to    cover the whole north face. The posters have rectangular shape with vertical and horizontal sides. They cannot overlap, but may touch each other, i.e. have common points on the sides. Every poster has to entirely adjoin the walls of certain buildings and the whole surface of the north face has to be covered.\n\nTask Write a programme that:\n\n- reads the description of buildings from the standard input, \n- determines the minimum number of posters needed to entirely cover their north faces, \n- writes out the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains one integer $n$ ($1\\le n\\le 250\\ 000$), denoting the number of buildings the chain      comprises of.\n\nEach of the following $n$ lines contains two integers $d_i$ and $w_i$ ($1\\le d_i,w_i\\le 1\\ 000\\ 000\\ 000$),      separated by a single space, denoting respectively the length and height      of the $i^{th}$ building in the row.", "outputFormat": "The first and only line of the standard output should contain one integer,      the minimum number of rectangular posters that suffice to cover the north faces      of the buildings.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2008] PLA-Postering", "background": "", "description": "All the buildings in the east district of Byteburg were built in accordance with the old arbitecture: they stand next to each other with no spacing inbetween. Together they form a very long chain of buildings of diverse    height, extending from east to west.\n\nThe mayor of Byteburg, Byteasar, has decided to have the north face of the chain covered with posters. Byteasar ponders over the minimum number of posters sufficient to    cover the whole north face. The posters have rectangular shape with vertical and horizontal sides. They cannot overlap, but may touch each other, i.e. have common points on the sides. Every poster has to entirely adjoin the walls of certain buildings and the whole surface of the north face has to be covered.\n\nTask Write a programme that:\n\n- reads the description of buildings from the standard input, \n- determines the minimum number of posters needed to entirely cover their north faces, \n- writes out the outcome to the standard output.\n", "inputFormat": "The first line of the standard input contains one integer $n$ ($1\\le n\\le 250\\ 000$), denoting the number of buildings the chain      comprises of.\n\nEach of the following $n$ lines contains two integers $d_i$ and $w_i$ ($1\\le d_i,w_i\\le 1\\ 000\\ 000\\ 000$),      separated by a single space, denoting respectively the length and height      of the $i^{th}$ building in the row.", "outputFormat": "The first and only line of the standard output should contain one integer,      the minimum number of rectangular posters that suffice to cover the north faces      of the buildings.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2008] PLA-Postering", "background": null, "description": "Byteburg 城市的东区所有建筑都是按照旧式建筑风格建造的：它们一个接一个地紧挨在一起，中间没有任何间隔。它们从东到西排列，形成了一排高度各异的建筑长廊。\n\nByteburg 的市长 Byteasar 决定在这排建筑的北立面上张贴海报。他正在思考，要完全覆盖整个北立面，最少需要多少张矩形海报。这些海报的边是垂直或水平的矩形，不能重叠，但可以相接（即边缘可以重合）。每一张海报必须完全贴合某些建筑的墙面，且所有北立面必须被完全覆盖。\n\n你的任务是写一个程序，完成以下功能：\n\n- 从标准输入中读取建筑的描述，\n- 计算出最少需要多少张海报，才能完全覆盖建筑的北立面，\n- 将结果输出到标准输出。", "inputFormat": "标准输入的第一行包含一个整数 $n$（$1 \\le n \\le 2.5\\times10^5$），表示这一排建筑的数量。\n\n接下来的 $n$ 行中，每行包含两个整数 $d_i$ 和 $w_i$（$1 \\le d_i, w_i \\le 10^9$），分别表示第 $i$ 栋建筑的宽度和高度。", "outputFormat": "标准输出中输出一个整数，表示最少需要多少张矩形海报，才能完全覆盖建筑的北立面。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3468", "type": "P", "difficulty": 6, "samples": [["10\n..........\n..........\n..r.......\n.rrrX.....\nrrrrr.....\n.rrr......\nX.r.......\n.Xr.......\n..........\n..........", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "POI（波兰）"], "title": "[POI 2008] ROB-Robinson", "background": "", "description": "Tossed by the storm on a deserted island, Robinson built himself a boat    so that he could go out to the sea and seek out human domicile.\n\nHe is an experienced sailor, therefore he built the boat with accordance to the rules    of craftsmanship: it has a longitudinal axis of symmetry and an appropriate    shape. The boat's prow is thin, and it widens gradually towards the boat's centre,    only to gradually narrow once again towards the stern.\n\nIn particular, at some point in the middle the boat is wider than both at the    prow and stern.\n\nUnfortunately, Robinson has launched his boat in a most improper space: there    is extremely thick reed all around. It is, moreover, so stiff that the boat    cannot break through. Perhaps Robinson can get to the high seas by carefully    manoeuvring between the reed.\n\nDue to lack of manoeuvrability, the boat can move forward and backward and    even sidewards (leftward or rightward), but it cannot turn.\n\nIt is thus allowed, and may be in fact necessary, that the boat moves with    its stern or broadside to the front.\n\nYou are to judge if Robinson can get to the high seas.\n\nTo make your task easier the island and its surroundings will be    represented by a square map divided into square unit fields, each    occupied by either water, part of Robinson's boat or an obstacle, eg.\n\nland or reed. Initially the boat is set parallel to one of the cardinal    directions, ie. its longitudinal axis of symmetry is parallel to this    direction and the axis bisects the unit fields it is covered with.\n\nWe assume that the high seas starts where the map ends.\n\nHence Robinson may get to the high seas if his boat can leave    the area depicted in the map.\n\nA single move consists in moving the boat to a side-adjacent    field in a chosen direction (north, south, east or west).\n\nThe move is permissible if both before and after it the boat    remains entirely in water (it does not occupy a field with an    obstacle).\n\nTask      You are to write a programme that                        reads the map's description from the standard input,                      calculates the minimum possible number of boat's moves that          suffice to completely leave the area depicted in the map,                      writes out this number to the standard output.\n\n被风暴抛弃在荒岛上的鲁滨逊（又译鲁滨孙）自己造了一条船，这样他就可以出海去寻找有人类居住的地方。\n\n他是一位经验丰富的水手，因此他根据技术规程建造了它。它有一条纵向的对称轴，以及适于航行的外形：船头较尖，向船中逐渐扩宽，到船尾又逐渐收窄。\n\n特别的是，船中的一些点比船头和船尾都宽。\n\n可是很不幸，鲁滨逊在最不合适的位置让他的船下了水：周围有极其厚的芦苇。此外，这条船太僵硬以至于它无法突破芦苇。不过或许鲁滨逊可以通过在芦苇中小心翼翼地操纵船去往公海。\n\n由于船太不灵活，船可以前进、后退甚至横着（向左或向右）移动，但它不能掉头。\n\n允许船的船尾或者船舷在前进行移动，事实上这可能是必要的。\n\n你需要判断鲁滨逊是否可以到达公海。\n\n为了简化你的工作，岛屿和周围的环境将由一张划分成方格的正方形地图表示，每格只可能是水、鲁滨逊船的一部分或障碍物（比如说岛屿和芦苇）。最初船平行于一个主要方向（换句话说，即其纵向对称轴平行于此方向且其平分其覆盖的方格）\n\n我们假定地图之外就是公海。\n\n因此，如果他的船可以离开地图描绘的区域，鲁滨逊也许就能到达公海了。\n\n一步表现为船往选定的方向（北，南，东或西）移动一格。\n\n如果移动前后的船保持整个在水中（不占据任何有障碍物的格子），那么这个移动是合法的。\n\n你的任务是编写一个程序，从标准输入中读取地图的描述，计算船离开地图描述的区域的最少步数，并输出至标准输出。\n", "inputFormat": "The first line contains one integer $3\\le n\\le 2000$, denoting the length of the map's side.\n\nIn each of the following $n$ lines there are $n$ characters      describing successive fields of the map:\n\n$i^{th}$ character in the $(j+1)^{th}$ line tells the contents      of the field $(i,j)$.\n\nThe following characters may appear there:\n\n\".\" - (dot) denotes a field filled with water,             \"X\" - denotes an obstacle (land or reed),             \"r\" - denotes a part of Robinson's boat.\n第一行一个正整数 $$3\\le_n\\le_2000$,$ 表示地图的边长。\n\n接下来 $n$ 行每行 $n$ 个字符表示地图：（此处省略两张图片）第 $(j+1)$ 行的的第 $i$ 个字符表示方格 $(i,j)$。以下的字符可能会在输入中出现：`.`表示一格水，`X` 表示一格障碍物（岛屿或芦苇），`R` 表示鲁滨孙的船的一部分。\n", "outputFormat": "Your programme should write out (in the first and only line of      the standard output) a single positive integer, equal to      the minimum number of boat's moves that suffice to completely      leave the area depicted in the map.\n\nShould getting to the high seas be impossible, write out the word      'NIE' ('no' in Polish).\n\n你的程序应当输出（在标准输出的第一行且仅有一行）一格正整数表示鲁滨逊的船完全离开地图标示的区域需要的最小步数。\n\n如果鲁宾逊无法到达公海，输出一行 `NIE`（波兰语中否定的意思）\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2008] ROB-Robinson", "background": "", "description": "Tossed by a storm onto a deserted island, Robinson built himself a boat so that he could go out to sea and look for human habitation.\n\nHe is an experienced sailor, so he built the boat according to the rules of craftsmanship: it has a longitudinal axis of symmetry and an appropriate shape. The prow is thin, the hull widens gradually toward the middle, and then it narrows again toward the stern. In particular, at some point in the middle the boat is wider than both at the prow and at the stern.\n\nUnfortunately, Robinson launched his boat in the worst possible place: there is extremely thick reed all around. Moreover, it is so stiff that the boat cannot break through. Perhaps Robinson can reach the high seas by carefully maneuvering between the reeds.\n\nBecause the boat is not very maneuverable, it can move forward, backward, and even sideways (left or right), but it cannot turn. It is therefore allowed—and may even be necessary—for the boat to move with its stern or with its broadside leading.\n\nYou are to determine whether Robinson can reach the high seas.\n\nTo make the task precise, the island and its surroundings are represented by a square map divided into unit square cells. Each cell is either water, a part of Robinson’s boat, or an obstacle (e.g., land or reed). Initially, the boat is aligned with one of the cardinal directions, that is, its longitudinal symmetry axis is parallel to that direction and bisects the unit cells it covers.\n\nWe assume that the high seas begin beyond the edge of the map. Hence, Robinson can reach the high seas if his boat can completely leave the area depicted on the map.\n\nA single move consists of shifting the boat by one cell in one of the four directions: north, south, east, or west. A move is permissible if both before and after the move the boat is entirely on water (i.e., it does not occupy any cell with an obstacle).\n\nTask: Write a program that reads the map from standard input, computes the minimum number of moves needed for the boat to completely leave the map, and writes this number to standard output.", "inputFormat": "- The first line contains a single integer $n$ with $3 \\le n \\le 2000$, denoting the side length of the map.\n\n- Each of the following $n$ lines contains $n$ characters describing the map. The $i^{\\text{th}}$ character in the $(j+1)^{\\text{th}}$ line describes cell $(i, j)$. The characters are:\n  - \".\" a cell of water,\n  - \"X\" an obstacle (land or reed),\n  - \"r\" a part of Robinson’s boat.", "outputFormat": "Output a single positive integer: the minimum number of moves needed for the boat to completely leave the map. If it is impossible to reach the high seas, output NIE.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2008] ROB-Robinson", "background": "", "description": "Tossed by the storm on a deserted island, Robinson built himself a boat    so that he could go out to the sea and seek out human domicile.\n\nHe is an experienced sailor, therefore he built the boat with accordance to the rules    of craftsmanship: it has a longitudinal axis of symmetry and an appropriate    shape. The boat's prow is thin, and it widens gradually towards the boat's centre,    only to gradually narrow once again towards the stern.\n\nIn particular, at some point in the middle the boat is wider than both at the    prow and stern.\n\nUnfortunately, Robinson has launched his boat in a most improper space: there    is extremely thick reed all around. It is, moreover, so stiff that the boat    cannot break through. Perhaps Robinson can get to the high seas by carefully    manoeuvring between the reed.\n\nDue to lack of manoeuvrability, the boat can move forward and backward and    even sidewards (leftward or rightward), but it cannot turn.\n\nIt is thus allowed, and may be in fact necessary, that the boat moves with    its stern or broadside to the front.\n\nYou are to judge if Robinson can get to the high seas.\n\nTo make your task easier the island and its surroundings will be    represented by a square map divided into square unit fields, each    occupied by either water, part of Robinson's boat or an obstacle, eg.\n\nland or reed. Initially the boat is set parallel to one of the cardinal    directions, ie. its longitudinal axis of symmetry is parallel to this    direction and the axis bisects the unit fields it is covered with.\n\nWe assume that the high seas starts where the map ends.\n\nHence Robinson may get to the high seas if his boat can leave    the area depicted in the map.\n\nA single move consists in moving the boat to a side-adjacent    field in a chosen direction (north, south, east or west).\n\nThe move is permissible if both before and after it the boat    remains entirely in water (it does not occupy a field with an    obstacle).\n\nTask      You are to write a programme that                        reads the map's description from the standard input,                      calculates the minimum possible number of boat's moves that          suffice to completely leave the area depicted in the map,                      writes out this number to the standard output.\n\n被风暴抛弃在荒岛上的鲁滨逊（又译鲁滨孙）自己造了一条船，这样他就可以出海去寻找有人类居住的地方。\n\n他是一位经验丰富的水手，因此他根据技术规程建造了它。它有一条纵向的对称轴，以及适于航行的外形：船头较尖，向船中逐渐扩宽，到船尾又逐渐收窄。\n\n特别的是，船中的一些点比船头和船尾都宽。\n\n可是很不幸，鲁滨逊在最不合适的位置让他的船下了水：周围有极其厚的芦苇。此外，这条船太僵硬以至于它无法突破芦苇。不过或许鲁滨逊可以通过在芦苇中小心翼翼地操纵船去往公海。\n\n由于船太不灵活，船可以前进、后退甚至横着（向左或向右）移动，但它不能掉头。\n\n允许船的船尾或者船舷在前进行移动，事实上这可能是必要的。\n\n你需要判断鲁滨逊是否可以到达公海。\n\n为了简化你的工作，岛屿和周围的环境将由一张划分成方格的正方形地图表示，每格只可能是水、鲁滨逊船的一部分或障碍物（比如说岛屿和芦苇）。最初船平行于一个主要方向（换句话说，即其纵向对称轴平行于此方向且其平分其覆盖的方格）\n\n我们假定地图之外就是公海。\n\n因此，如果他的船可以离开地图描绘的区域，鲁滨逊也许就能到达公海了。\n\n一步表现为船往选定的方向（北，南，东或西）移动一格。\n\n如果移动前后的船保持整个在水中（不占据任何有障碍物的格子），那么这个移动是合法的。\n\n你的任务是编写一个程序，从标准输入中读取地图的描述，计算船离开地图描述的区域的最少步数，并输出至标准输出。\n", "inputFormat": "The first line contains one integer $3\\le n\\le 2000$, denoting the length of the map's side.\n\nIn each of the following $n$ lines there are $n$ characters      describing successive fields of the map:\n\n$i^{th}$ character in the $(j+1)^{th}$ line tells the contents      of the field $(i,j)$.\n\nThe following characters may appear there:\n\n\".\" - (dot) denotes a field filled with water,             \"X\" - denotes an obstacle (land or reed),             \"r\" - denotes a part of Robinson's boat.\n第一行一个正整数 $$3\\le_n\\le_2000$,$ 表示地图的边长。\n\n接下来 $n$ 行每行 $n$ 个字符表示地图：（此处省略两张图片）第 $(j+1)$ 行的的第 $i$ 个字符表示方格 $(i,j)$。以下的字符可能会在输入中出现：`.`表示一格水，`X` 表示一格障碍物（岛屿或芦苇），`R` 表示鲁滨孙的船的一部分。\n", "outputFormat": "Your programme should write out (in the first and only line of      the standard output) a single positive integer, equal to      the minimum number of boat's moves that suffice to completely      leave the area depicted in the map.\n\nShould getting to the high seas be impossible, write out the word      'NIE' ('no' in Polish).\n\n你的程序应当输出（在标准输出的第一行且仅有一行）一格正整数表示鲁滨逊的船完全离开地图标示的区域需要的最小步数。\n\n如果鲁宾逊无法到达公海，输出一行 `NIE`（波兰语中否定的意思）\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3469", "type": "P", "difficulty": 5, "samples": [["5 5\n1 2\n2 3\n1 3\n3 4\n4 5\n", "8\n8\n16\n14\n8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "POI（波兰）", "Tarjan", "双连通分量"], "title": "[POI 2008] BLO-Blockade", "background": "", "description": "There are exactly $n$ towns in Byteotia.\n\nSome towns are connected by bidirectional roads.\n\nThere are no crossroads outside towns, though there may be bridges,    tunnels and flyovers. Each pair of towns may be connected by at most    one direct road. One can get from any town to any other-directly    or indirectly.\n\nEach town has exactly one citizen.\n\nFor that reason the citizens suffer from loneliness.\n\nIt turns out that each citizen would like to pay a visit to    every other citizen (in his host's hometown), and do it    exactly once. So exactly $n\\cdot (n-1)$ visits should take place.\n\nThat's right, should.\n\nUnfortunately, a general strike of programmers, who    demand an emergency purchase of software, is under way.\n\nAs an act of protest, the programmers plan to block one town of    Byteotia, preventing entering it, leaving it, and even passing through.\n\nAs we speak, they are debating which town to choose so that    the consequences are most severe.\n\nTask    Write a programme that:\n\nreads the Byteotian road system's description from the            standard input,           for each town determines, how many visits could take place            if this town were not blocked by programmers,           writes out the outcome to the standard output.\n\n", "inputFormat": "In the first line of the standard input there are two positive    integers: $n$ and $m$ ($1\\le n\\le 100\\ 000$, $1\\le m\\le 500\\ 000$) denoting the number of towns and roads, respectively.\n\nThe towns are numbered from 1 to $n$.\n\nThe following $m$ lines contain descriptions of the roads.\n\nEach line contains two integers $a$ and $b$ ($1\\le a<b\\le n$) and    denotes a direct road between towns numbered $a$ and $b$.\n", "outputFormat": "Your programme should write out exactly $n$ integers to the standard    output, one number per line. The $i^{th}$ line should contain the number    of visits that could not take place if the programmers blocked the town    no. $i$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2008] BLO-Blockade", "background": "", "description": "There are exactly $n$ towns in Byteotia.\n\nSome towns are connected by bidirectional roads.\n\nThere are no crossroads outside towns, though there may be bridges,    tunnels and flyovers. Each pair of towns may be connected by at most    one direct road. One can get from any town to any other-directly    or indirectly.\n\nEach town has exactly one citizen.\n\nFor that reason the citizens suffer from loneliness.\n\nIt turns out that each citizen would like to pay a visit to    every other citizen (in his host's hometown), and do it    exactly once. So exactly $n\\cdot (n-1)$ visits should take place.\n\nThat's right, should.\n\nUnfortunately, a general strike of programmers, who    demand an emergency purchase of software, is under way.\n\nAs an act of protest, the programmers plan to block one town of    Byteotia, preventing entering it, leaving it, and even passing through.\n\nAs we speak, they are debating which town to choose so that    the consequences are most severe.\n\nTask    Write a programme that:\n\nreads the Byteotian road system's description from the            standard input,           for each town determines, how many visits could take place            if this town were not blocked by programmers,           writes out the outcome to the standard output.\n\n", "inputFormat": "In the first line of the standard input there are two positive    integers: $n$ and $m$ ($1\\le n\\le 100\\ 000$, $1\\le m\\le 500\\ 000$) denoting the number of towns and roads, respectively.\n\nThe towns are numbered from 1 to $n$.\n\nThe following $m$ lines contain descriptions of the roads.\n\nEach line contains two integers $a$ and $b$ ($1\\le a<b\\le n$) and    denotes a direct road between towns numbered $a$ and $b$.\n", "outputFormat": "Your programme should write out exactly $n$ integers to the standard    output, one number per line. The $i^{th}$ line should contain the number    of visits that could not take place if the programmers blocked the town    no. $i$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2008] BLO-Blockade", "background": null, "description": "B 城有 $n$ 个城镇（从 $1$ 到 $n$ 标号）和 $m$ 条双向道路。\n\n每条道路连结两个不同的城镇，没有重复的道路，所有城镇连通。\n\n\n把城镇看作节点，把道路看作边，容易发现，整个城市构成了一个无向图。\n\n请你对于每个节点 $i$ 求出，把与节点 $i$ 关联的所有边去掉以后（不去掉节点 $i$ 本身），无向图有多少个有序点对 $(x,y)$，满足 $x$ 和 $y$ 不连通。\n\n注：这里的“有序点对”可以理解为 $(x,y)$ 和 $(y,x)$ 不相同 $(x\\neq y)$。", "inputFormat": "第一行包含两个整数 $n$ 和 $m$。\n\n接下来 $m$ 行，每行包含两个整数 $a$ 和 $b$，表示城镇 $a$ 和 $b$ 之间存在一条道路。", "outputFormat": "输出共 $n$ 行，每行输出一个整数。\n\n第 $i$ 行输出的整数表示把与节点 $i$ 关联的所有边去掉以后（不去掉节点 $i$ 本身），无向图有多少个有序点对 $(x,y)$，满足 $x$ 和 $y$ 不连通。", "hint": "$n\\le 10^5$，$m\\le5\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P3470", "type": "P", "difficulty": 5, "samples": [["9 2 3 2 1\n---++++++\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "单调队列", "POI（波兰）"], "title": "[POI 2008] BBB-BBB", "background": "", "description": "Byteasar has an account at The Byteotian Bit Bank (BBB in short).\n\nAt the beginning there were $p$ and at the end $q$ bythalers in the account.\n\nEach transaction was either a deposit or a withdrawal of one bythaler.\n\nThe account's balance was never negative.\n\nA bank teller has prepared a bank statement: a strip of paper with a sequence of pluses and minuses in it   (a plus denotes a deposit while minus a withdrawal of one bythaler).\n\nSoon it turned out, that some transactions were not entered correctly.\n\nThe bank teller cannot print another statement, but has to correct the   one already printed instead.\n\nThe statement needs not be consistent with the truth, it will suffice if the sequence of transactions satisfies the following two conditions:\n\nthe final balance is consistent with the initial balance and the sequence of transactions in the statement, according to the sequence of transactions in the statement, the account's balance was never negative.\n\nYou are to calculate the minimum amount of time the bank teller needs to   correct the bank statement.\n\nThe bank teller can:\n\n- in $x$ seconds turn an arbitrarily chosen transaction to its opposite, or \n- in $y$ seconds remove the last transaction and put it at the beginning of the statement.\n\nIf, for example, $p=2,q=3$, then `--++-+-++-+-+` is a correct   statement.\n\nOn the other hand the statement `---++++++` is incorrect, because the account's balance would become negative after the third transaction, and furthermore the final balance should be 3, not 5.\n\nIt can be, however, corrected by turning the second to last symbol to its opposite and placing the last transaction at the beginning of the statement.\n\n### Task\n\nWrite a programme that:\n\n- reads the current bank statement for Byteasar's account (a sequence of pluses and minuses) as well as the numbers $p,q,x$ and $y$ from the standard input.\n- writes out to the standard output the minimum number of seconds needed to correct the statement in a way such that the initial and final balance are consistent and that the balance is never negative.\n", "inputFormat": "The first line contains 5 integers $n,p,q,x$ and $y\\ (1\\le n\\le 1\\ 000\\ 000$, $0\\le p,q\\le 1\\ 000\\ 000$, $1\\le x,y\\le 1000$), separated by single spaces and denoting respectively:\n\nthe number of transactions done by Byteasar, initial and final account     balance and the number of seconds needed to perform a single turn     (change of sign) and move of transaction to the beginning.\n\nThe second line contains a sequence of ![](http://main.edu.pl/images/OI15/bbb-en-tex.18.png) signs (each a plus     or a minus), with no spaces in-between.\n", "outputFormat": "The first and last output line should contain one integer,     the minimum number of seconds needed to correct the statement. If no     corrections are necessary, the number is zero.\n\nYou may assume that a proper sequence of modifications exists for each     test data.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2008] BBB-BBB", "background": "", "description": "Byteasar has an account at The Byteotian Bit Bank (BBB in short).\n\nAt the beginning there were $p$ and at the end $q$ bythalers in the account.\n\nEach transaction was either a deposit or a withdrawal of one bythaler.\n\nThe account's balance was never negative.\n\nA bank teller has prepared a bank statement: a strip of paper with a sequence of pluses and minuses in it   (a plus denotes a deposit while minus a withdrawal of one bythaler).\n\nSoon it turned out, that some transactions were not entered correctly.\n\nThe bank teller cannot print another statement, but has to correct the   one already printed instead.\n\nThe statement needs not be consistent with the truth, it will suffice if the sequence of transactions satisfies the following two conditions:\n\nthe final balance is consistent with the initial balance and the sequence of transactions in the statement, according to the sequence of transactions in the statement, the account's balance was never negative.\n\nYou are to calculate the minimum amount of time the bank teller needs to   correct the bank statement.\n\nThe bank teller can:\n\n- in $x$ seconds turn an arbitrarily chosen transaction to its opposite, or \n- in $y$ seconds remove the last transaction and put it at the beginning of the statement.\n\nIf, for example, $p=2,q=3$, then `--++-+-++-+-+` is a correct   statement.\n\nOn the other hand the statement `---++++++` is incorrect, because the account's balance would become negative after the third transaction, and furthermore the final balance should be 3, not 5.\n\nIt can be, however, corrected by turning the second to last symbol to its opposite and placing the last transaction at the beginning of the statement.\n\n### Task\n\nWrite a programme that:\n\n- reads the current bank statement for Byteasar's account (a sequence of pluses and minuses) as well as the numbers $p,q,x$ and $y$ from the standard input.\n- writes out to the standard output the minimum number of seconds needed to correct the statement in a way such that the initial and final balance are consistent and that the balance is never negative.\n", "inputFormat": "The first line contains 5 integers $n,p,q,x$ and $y\\ (1\\le n\\le 1\\ 000\\ 000$, $0\\le p,q\\le 1\\ 000\\ 000$, $1\\le x,y\\le 1000$), separated by single spaces and denoting respectively:\n\nthe number of transactions done by Byteasar, initial and final account     balance and the number of seconds needed to perform a single turn     (change of sign) and move of transaction to the beginning.\n\nThe second line contains a sequence of ![](http://main.edu.pl/images/OI15/bbb-en-tex.18.png) signs (each a plus     or a minus), with no spaces in-between.\n", "outputFormat": "The first and last output line should contain one integer,     the minimum number of seconds needed to correct the statement. If no     corrections are necessary, the number is zero.\n\nYou may assume that a proper sequence of modifications exists for each     test data.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2008] BBB-BBB", "background": "", "description": "Byteasar 在 Byteotian Bit Bank（简称 BBB）有一个账户。  一开始账户里有 $p$ 个 bythaler，最后有 $q$ 个 bythaler。  每笔交易要么是存入一个 bythaler，要么是取出一个 bythaler。  账户余额从未为负。  一位银行柜员准备了一份银行对账单：一条纸带，上面有一系列的加号和减号（加号表示存入一个 bythaler，减号表示取出一个 bythaler）。  很快发现，有些交易记录不正确。  银行柜员不能打印另一份对账单，但必须修改已经打印的那一份。  对账单不必与事实一致，只要交易序列满足以下两个条件即可：  最终余额与初始余额和对账单中的交易序列一致，根据对账单中的交易序列，账户余额从未为负。  你需要计算银行柜员需要多少最少时间来修正对账单。  银行柜员可以：  - 在 $x$ 秒内将任意选择的交易变为其相反的交易，或者 - 在 $y$ 秒内将最后一笔交易移到对账单的开头。  例如，如果 $p=2,q=3$，那么 `--++-+-++-+-+` 是一个正确的对账单。  另一方面，对账单 `---++++++` 是不正确的，因为账户余额在第三笔交易后会变为负数，而且最终余额应该是 3，而不是 5。  然而，可以通过将倒数第二个符号变为其相反的符号，并将最后一笔交易移到对账单的开头来修正。  ### 任务  编写一个程序：  - 从标准输入中读取 Byteasar 账户的当前对账单（一个加号和减号的序列）以及数字 $p,q,x$ 和 $y$。 - 输出修正对账单所需的最少秒数，使得初始和最终余额一致，并且余额从未为负。 ", "inputFormat": "第一行包含 5 个整数 $n,p,q,x$ 和 $y\\ (1\\le n\\le 1\\ 000\\ 000$, $0\\le p,q\\le 1\\ 000\\ 000$, $1\\le x,y\\le 1000$)，用单个空格分隔，分别表示：  Byteasar 进行的交易数量、初始和最终账户余额、执行一次符号变更和将交易移到开头所需的秒数。  第二行包含一系列符号（每个是加号或减号），中间没有空格。 ", "outputFormat": "输出的第一行和最后一行应包含一个整数，即修正对账单所需的最少秒数。如果不需要修正，则为零。  你可以假设每个测试数据都有一个适当的修改序列。 ", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3471", "type": "P", "difficulty": 6, "samples": [["5 6 7\nababbd\nabbbbd\naaabad\ncaabbd\ncabaad\n2 3 5 4\n5 3 5 5\n3 5 2 2\n1 2 4 3\n2 2 5 1\n1 1 3 3\n4 1 5 6\n", "3\n3\n3\n2\n3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2008", "平衡树", "POI（波兰）", "离散化", "哈希 hashing"], "title": "[POI 2008] POC-Trains", "background": "", "description": "The Trains of Colour Parade begins tomorrow in Byteotia.\n\nIntense preparations are already in progress at the station's auxiliary tracks. There are $n$ parallel tracks at the station, numbered from $1$ to $n$. The train no. $i$ occupies the $i^{th}$ track.\n\nEvery train consists of $l$ cars and each car is painted with one of 26 colours (denoted by non-capital letters of the English alphabet).\n\nWe say that two trains look the same, if their corresponding cars are painted the same colour.\n\nThroughout the parade a crane will switch places of certain pairs of cars. The real parade, however, will take place tomorrow.\n\nToday the train dispatcher, Byteasar, watched the general rehearsal    closely. He even wrote down the sequence of car swaps.\n\nByteasar particularly dislikes many trains looking the same.\n\nFor each train $p$ he would like to calculate the maximum number    of trains that at some moment look the same as the train $p$ at the very same moment.\n\n## Task\n\nWrite a programme that:\n\n- reads descriptions of the trains occupying tracks and the sequence of car swaps,\n\n- for each train determines the maximum number of trains that look the same as it at certain moment,\n\n- writes out the result.\n\n\n给出n个字符串，长度均为len；\n\n有m次操作，每次将两个字符交换；\n\n求每个字符串在任何时点上，与相同的它最多的字符串个数；\n", "inputFormat": "The first line of the input contains three integers $n$, $l$ and $m$ ($2 \\le n \\le 1000$, $1 \\le l \\le 100$, $0 \\le m \\le 100\\ 000$), denoting respectively the number of trains, their common length and the number of car swaps. The following $n$ lines contain descriptions of the trains on successive tracks. The\n\n$k^{th}$ line consists of $l$ small letters of the English alphabet denoting the colours of successive cars of the $k^{th}$ train. Then $m$ lines describing the car swaps follow, in the order of the swaps. The $r^{th}$ line contains four integers $p_1$, $w_1$, $p_2$, $w_2$ ($1 \\le p_1, p_2, \\le n$, $1 \\le w_1, w_2 \\le l$, $p_1 \\ne p_2$ or $w_1 \\ne w_2$) denoting the $r^{th}$ car swap-the car no. $w_1$ of the train no. $p_1$ is swapped with the car no. $w_2$ of the train no. $p_2$.\n", "outputFormat": "Your programme should write out exactly $n$ lines. The $k^[th}$ line should contain one integer-the number of trains looking the same as the train no. $k$ at certain moment.\n", "hint": "The figure presents the successive car swaps:\n\n```cpp\ntrack 1:  ababbd    ababbd    ababbd    ababbd    aaabbd    aaabbd    aaabbd    aaabbd\ntrack 2:  abbbbd    ababbd    ababbd    aaabbd    aaabbd    acabbd    acabbd    acabbd\ntrack 3:  aaabad -> aaabad -> aaabad -> aaabbd -> aaabbd -> aaabbd -> aaabbd -> aaabbd\ntrack 4:  caabbd    caabbd    caabbd    caabbd    cabbbd    cabbbd    cabbbd    dabbbd\ntrack 5:  cabaad    cabbad    caabbd    caabbd    caabbd    aaabbd    aaabbd    aaabbc\n           (0)       (1)       (2)       (3)       (4)       (5)       (6)       (7)\n```\n\nThe number of trains looking the same as either of the trains no. 1, 2 or 3 was maximal at time (4) (when all three looked the same). The number of trains looking the same as the train no. 5 was maximal at time (5) and (6). The number of trains looking the same as the train no. 4 was maximal at time (2).\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2008] POC-Trains", "background": "", "description": "The Trains of Colour Parade begins tomorrow in Byteotia.\n\nIntense preparations are already in progress at the station’s auxiliary tracks. There are $n$ parallel tracks at the station, numbered from $1$ to $n$. Train no. $i$ occupies the $i^{th}$ track.\n\nEvery train consists of $l$ cars, and each car is painted with one of 26 colours (denoted by lowercase letters of the English alphabet).\n\nWe say that two trains look the same if their corresponding cars are painted the same colour.\n\nThroughout the parade a crane will switch places of certain pairs of cars. The real parade, however, will take place tomorrow.\n\nToday the train dispatcher, Byteasar, watched the general rehearsal closely. He even wrote down the sequence of car swaps.\n\nByteasar particularly dislikes many trains looking the same.\n\nFor each train $p$ he would like to calculate the maximum number of trains that, at some moment, look the same as train $p$ at that very moment.\n\nTask\n\nWrite a program that:\n- reads the descriptions of the trains occupying the tracks and the sequence of car swaps,\n- for each train determines the maximum number of trains that look the same as it at some moment,\n- writes out the result.\n\nGiven $n$ strings, each of length $l$.\nThere are $m$ operations, each swapping two characters.\nFor each string, find the maximum number of strings that are identical to it at some moment.", "inputFormat": "The first line of input contains three integers $n$, $l$ and $m$ ($2 \\le n \\le 1000$, $1 \\le l \\le 100$, $0 \\le m \\le 100\\,000$), denoting respectively the number of trains, their common length, and the number of car swaps. The following $n$ lines contain descriptions of the trains on successive tracks.\n\nThe $k^{th}$ of these lines consists of $l$ lowercase letters of the English alphabet, denoting the colours of successive cars of the $k^{th}$ train. Then $m$ lines describing the car swaps follow, in the order of the swaps. The $r^{th}$ line contains four integers $p_1$, $w_1$, $p_2$, $w_2$ ($1 \\le p_1, p_2 \\le n$, $1 \\le w_1, w_2 \\le l$, $p_1 \\ne p_2$ or $w_1 \\ne w_2$), denoting the $r^{th}$ car swap—the car no. $w_1$ of train no. $p_1$ is swapped with the car no. $w_2$ of train no. $p_2$.", "outputFormat": "Your program should write out exactly $n$ lines. The $k^{th}$ line should contain one integer—the number of trains that, at some moment, look the same as train no. $k$.", "hint": "The figure presents the successive car swaps:\n```cpp\ntrack 1:  ababbd    ababbd    ababbd    ababbd    aaabbd    aaabbd    aaabbd    aaabbd\ntrack 2:  abbbbd    ababbd    ababbd    aaabbd    aaabbd    acabbd    acabbd    acabbd\ntrack 3:  aaabad -> aaabad -> aaabad -> aaabbd -> aaabbd -> aaabbd -> aaabbd -> aaabbd\ntrack 4:  caabbd    caabbd    caabbd    caabbd    cabbbd    cabbbd    cabbbd    dabbbd\ntrack 5:  cabaad    cabbad    caabbd    caabbd    caabbd    aaabbd    aaabbd    aaabbc\n           (0)       (1)       (2)       (3)       (4)       (5)       (6)       (7)\n```\n\nThe number of trains looking the same as either of trains no. 1, 2, or 3 was maximal at time (4) (when all three looked the same). The number of trains looking the same as train no. 5 was maximal at times (5) and (6). The number of trains looking the same as train no. 4 was maximal at time (2).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2008] POC-Trains", "background": "", "description": "The Trains of Colour Parade begins tomorrow in Byteotia.\n\nIntense preparations are already in progress at the station's auxiliary tracks. There are $n$ parallel tracks at the station, numbered from $1$ to $n$. The train no. $i$ occupies the $i^{th}$ track.\n\nEvery train consists of $l$ cars and each car is painted with one of 26 colours (denoted by non-capital letters of the English alphabet).\n\nWe say that two trains look the same, if their corresponding cars are painted the same colour.\n\nThroughout the parade a crane will switch places of certain pairs of cars. The real parade, however, will take place tomorrow.\n\nToday the train dispatcher, Byteasar, watched the general rehearsal    closely. He even wrote down the sequence of car swaps.\n\nByteasar particularly dislikes many trains looking the same.\n\nFor each train $p$ he would like to calculate the maximum number    of trains that at some moment look the same as the train $p$ at the very same moment.\n\n## Task\n\nWrite a programme that:\n\n- reads descriptions of the trains occupying tracks and the sequence of car swaps,\n\n- for each train determines the maximum number of trains that look the same as it at certain moment,\n\n- writes out the result.\n\n\n给出n个字符串，长度均为len；\n\n有m次操作，每次将两个字符交换；\n\n求每个字符串在任何时点上，与相同的它最多的字符串个数；\n", "inputFormat": "The first line of the input contains three integers $n$, $l$ and $m$ ($2 \\le n \\le 1000$, $1 \\le l \\le 100$, $0 \\le m \\le 100\\ 000$), denoting respectively the number of trains, their common length and the number of car swaps. The following $n$ lines contain descriptions of the trains on successive tracks. The\n\n$k^{th}$ line consists of $l$ small letters of the English alphabet denoting the colours of successive cars of the $k^{th}$ train. Then $m$ lines describing the car swaps follow, in the order of the swaps. The $r^{th}$ line contains four integers $p_1$, $w_1$, $p_2$, $w_2$ ($1 \\le p_1, p_2, \\le n$, $1 \\le w_1, w_2 \\le l$, $p_1 \\ne p_2$ or $w_1 \\ne w_2$) denoting the $r^{th}$ car swap-the car no. $w_1$ of the train no. $p_1$ is swapped with the car no. $w_2$ of the train no. $p_2$.\n", "outputFormat": "Your programme should write out exactly $n$ lines. The $k^[th}$ line should contain one integer-the number of trains looking the same as the train no. $k$ at certain moment.\n", "hint": "The figure presents the successive car swaps:\n\n```cpp\ntrack 1:  ababbd    ababbd    ababbd    ababbd    aaabbd    aaabbd    aaabbd    aaabbd\ntrack 2:  abbbbd    ababbd    ababbd    aaabbd    aaabbd    acabbd    acabbd    acabbd\ntrack 3:  aaabad -> aaabad -> aaabad -> aaabbd -> aaabbd -> aaabbd -> aaabbd -> aaabbd\ntrack 4:  caabbd    caabbd    caabbd    caabbd    cabbbd    cabbbd    cabbbd    dabbbd\ntrack 5:  cabaad    cabbad    caabbd    caabbd    caabbd    aaabbd    aaabbd    aaabbc\n           (0)       (1)       (2)       (3)       (4)       (5)       (6)       (7)\n```\n\nThe number of trains looking the same as either of the trains no. 1, 2 or 3 was maximal at time (4) (when all three looked the same). The number of trains looking the same as the train no. 5 was maximal at time (5) and (6). The number of trains looking the same as the train no. 4 was maximal at time (2).\n", "locale": "zh-CN"}}}
{"pid": "P3472", "type": "P", "difficulty": 6, "samples": [["8\n2 3 2 2 6 7 8 5\n", "3 5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2008", "POI（波兰）", "Tarjan", "基环树"], "title": "[POI 2008] MAF-Mafia", "background": "", "description": "Mob feud rages in Equatorial Byteotia. The mob bosses have come to the country's capital, Byteburg, to settle the dispute.\n\nNegotiations were very tense, and at one point the trigger-happy participants drew their guns.\n\nEach participant aims at another with a pistol.\n\nShould they go on a killing spree, the shooting will go in accordance with the following code of honour:\n\nthe participants shoot in a certain order, and at any moment at most one of them is shooting, no shooter misses, his target dies instantly, hence he may not shoot afterwards, everyone shoots once, provided he had not been shot before he has a chance to shoot, no participant may change his first target of choice, even if the target is already dead (then the shot causes no further casualties).\n\nAn undertaker watches from afar, as he usually does. After all, the mobsters have never failed to stimulate his business.\n\nHe sees potential profit in the shooting, but he would like to know tight estimations. Precisely he would like to know the minimum and maximum possible death rate.\n\nThe undertaker sees who aims at whom, but does not know the order of shooting.\n\nYou are to write a programme that determines the numbers he is so keen to know.\n\nTask Write a programme that:\n\nreads from the standard input what target each mobster has chosen,                        determines the minimum and maximum number of casualties, writes out the result to the standard output.\n", "inputFormat": "The first line of the standard input contains the number of participants $n$ ($1\\le n\\le 1{,}000{,}000$).\n\nThey are numbered from $1$ to $n$.\n\nThe second line contains $n$ integers $s_1,s_2,\\cdots,s_n$, separated by single spaces, $1\\le s_i\\le n$.\n\n$s_i$ denotes the number of $i^\\mathrm{th}$ participant's target.\n\nNote that it is possible that $s_i=i$ for some $i$ (the nerves, you know).\n", "outputFormat": "Your programme should write out two integers separated by a single      space in the first and only line of the standard output. These numbers      should be, respectively, the minimum and maximum number of casualties resulting from the shooting.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2008] MAF-Mafia", "background": "", "description": "Mob feud rages in Equatorial Byteotia. The mob bosses have come to the country's capital, Byteburg, to settle the dispute.\n\nNegotiations were very tense, and at one point the trigger-happy participants drew their guns.\n\nEach participant aims at another with a pistol.\n\nShould they go on a killing spree, the shooting will go in accordance with the following code of honour:\n\nthe participants shoot in a certain order, and at any moment at most one of them is shooting, no shooter misses, his target dies instantly, hence he may not shoot afterwards, everyone shoots once, provided he had not been shot before he has a chance to shoot, no participant may change his first target of choice, even if the target is already dead (then the shot causes no further casualties).\n\nAn undertaker watches from afar, as he usually does. After all, the mobsters have never failed to stimulate his business.\n\nHe sees potential profit in the shooting, but he would like to know tight estimations. Precisely he would like to know the minimum and maximum possible death rate.\n\nThe undertaker sees who aims at whom, but does not know the order of shooting.\n\nYou are to write a programme that determines the numbers he is so keen to know.\n\nTask Write a programme that:\n\nreads from the standard input what target each mobster has chosen,                        determines the minimum and maximum number of casualties, writes out the result to the standard output.\n", "inputFormat": "The first line of the standard input contains the number of participants $n$ ($1\\le n\\le 1{,}000{,}000$).\n\nThey are numbered from $1$ to $n$.\n\nThe second line contains $n$ integers $s_1,s_2,\\cdots,s_n$, separated by single spaces, $1\\le s_i\\le n$.\n\n$s_i$ denotes the number of $i^\\mathrm{th}$ participant's target.\n\nNote that it is possible that $s_i=i$ for some $i$ (the nerves, you know).\n", "outputFormat": "Your programme should write out two integers separated by a single      space in the first and only line of the standard output. These numbers      should be, respectively, the minimum and maximum number of casualties resulting from the shooting.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2008] MAF-Mafia", "background": "", "description": "在赤道 Byteotia，黑帮之间的争斗愈演愈烈。黑帮老大们来到该国的首都 Byteburg，以解决争端。\n\n谈判非常紧张，在某个时刻，手痒的参与者们拔出了他们的枪。\n\n每个参与者都用手枪瞄准另一个人。\n\n如果他们开始大开杀戒，射击将按照以下荣誉代码进行：\n\n参与者按一定顺序射击，并且在任何时刻最多只有一个人开枪，射手不会失手，他的目标会立即死亡，因此他之后不能再开枪，每个人都开一次枪，前提是他在有机会开枪之前没有被击中，任何参与者都不能改变他最初选择的目标，即使目标已经死了（那么射击不会造成进一步的伤亡）。\n\n一个殡葬承办人从远处观察，正如他通常所做的那样。毕竟，黑帮分子从未让他的生意冷清过。\n\n他在射击中看到了潜在的利润，但他想知道准确的估计。他想知道最小和最大可能的死亡率。\n\n殡葬承办人看到谁瞄准了谁，但不知道射击的顺序。\n\n你需要编写一个程序来确定他如此渴望知道的数字。\n\n任务 编写一个程序：\n\n从标准输入读取每个黑帮分子选择的目标，确定最小和最大伤亡人数，将结果写入标准输出。", "inputFormat": "标准输入的第一行包含参与者的数量 $n$ ($1 \\le n \\le 1{,}000{,}000$)。\n\n他们的编号从 $1$ 到 $n$。\n\n第二行包含 $n$ 个整数 $s_1,s_2,\\cdots,s_n$，用单个空格分隔，$1 \\le s_i \\le n$。\n\n$s_i$ 表示第 $i$ 个参与者的目标编号。\n\n注意，可能存在 $s_i=i$ 的情况（紧张导致的）。", "outputFormat": "你的程序应在标准输出的第一行输出两个用单个空格分隔的整数。这些数字分别是射击导致的最小和最大伤亡人数。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3473", "type": "P", "difficulty": 6, "samples": [["3 5 10\n4 2\n+++++\n++*++\n++++*\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "POI（波兰）"], "title": "[POI 2008] UCI-The Great Escape", "background": "", "description": "Al Bytone, the infamous thief, plans a bank robbery. He knows only too well that the moment he robs the bank a pursuit will be commenced. Unfortunately, Al Bytone is a poor driver and turning left causes him great trouble. This is why he tries to devise such an escape route that at each intersection he would either ride straight ahead or turn right. He is also aware that once he passes through any intersection, the police will come and remain there, waiting for him. Therefore he may pass through any intersection at most once. Furthermore, the police are always present at certain intersections, so Al Bytone will have to avoid these intersections as well (there's no police at the intersections near the bank and near Al Bytone's hideout.)\n\nAl Bytone is planning his escape route. To your great (and rather unpleasant) surprise, he paid you a visit and told to calculate the number of different escape routes leading from the bank to his hideout complying the aforementioned requirements. Needless to say, Al Bytone does not take 'no' as an answer...\n\nThe streets of Byteburg form a rectangular grid. Every street runs either in the North-South or East-West direction, and every two non-parallel streets intersect. The bank is situated to the south of the south-western-most intersection. Al Bytone will start his great escape driving north.\n\n<Task>\n\nWrite a programme that:\n\n- reads from the standard input the location of hideout, descriptions of intersections with police and a positive integer k,\n- calculates the number of different escape routes leading from the bank to the hideout complying the aforementioned requirements,\n- writes out to the standard output this number's residue modulo k.", "inputFormat": "There are three integers in the first line of the standard input, $n$, $m$ and $k$ ($1\\le n,m\\le 100$, $1\\le k\\le 10^9$).\n\nThe numbers $n$ and $m$ denote the number of streets leading in      East-West and North-South direction, respectively.\n\nThe second line contains two integers $x$ and $y$ ($1\\le x\\le n$, $1\\le y\\le m$).\n\nThese represent the hideout's location - at the intersection      of $x^{\\mathrm{th}}$ street leading in Nort…\n", "outputFormat": "Your programme should write out the residue of the number of escape      routes modulo $k$ in the first and only line of the standard output.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2008] UCI-The Great Escape", "background": "", "description": "Al Bytone, the infamous thief, plans a bank robbery. He knows only too well that the moment he robs the bank a pursuit will be commenced. Unfortunately, Al Bytone is a poor driver and turning left causes him great trouble. This is why he tries to devise such an escape route that at each intersection he would either ride straight ahead or turn right. He is also aware that once he passes through any intersection, the police will come and remain there, waiting for him. Therefore he may pass through any intersection at most once. Furthermore, the police are always present at certain intersections, so Al Bytone will have to avoid these intersections as well (there's no police at the intersections near the bank and near Al Bytone's hideout.)\n\nAl Bytone is planning his escape route. To your great (and rather unpleasant) surprise, he paid you a visit and told to calculate the number of different escape routes leading from the bank to his hideout complying the aforementioned requirements. Needless to say, Al Bytone does not take 'no' as an answer...\n\nThe streets of Byteburg form a rectangular grid. Every street runs either in the North-South or East-West direction, and every two non-parallel streets intersect. The bank is situated to the south of the south-western-most intersection. Al Bytone will start his great escape driving north.\n\n<Task>\n\nWrite a programme that:\n\n- reads from the standard input the location of hideout, descriptions of intersections with police and a positive integer k,\n- calculates the number of different escape routes leading from the bank to the hideout complying the aforementioned requirements,\n- writes out to the standard output this number's residue modulo k.", "inputFormat": "There are three integers in the first line of the standard input, $n$, $m$ and $k$ ($1\\le n,m\\le 100$, $1\\le k\\le 10^9$).\n\nThe numbers $n$ and $m$ denote the number of streets leading in      East-West and North-South direction, respectively.\n\nThe second line contains two integers $x$ and $y$ ($1\\le x\\le n$, $1\\le y\\le m$).\n\nThese represent the hideout's location - at the intersection      of $x^{\\mathrm{th}}$ street leading in Nort…\n", "outputFormat": "Your programme should write out the residue of the number of escape      routes modulo $k$ in the first and only line of the standard output.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2008] UCI-The Great Escape", "background": "", "description": "阿尔·拜通，这个臭名昭著的小偷，计划进行银行抢劫。\n\n他非常清楚，一旦他抢劫银行，追捕就会开始。不幸的是，阿尔·拜通是个糟糕的司机，左转对他来说是个大麻烦。这就是为什么他试图设计一个逃跑路线，使得在每个路口他要么直行，要么右转。他也知道，一旦他经过任何一个路口，警察就会到达并留在那里等他。\n\n因此，他最多只能经过每个路口一次。\n\n此外，警察总是在某些路口待命，所以阿尔·拜通也必须避开这些路口（银行附近和阿尔·拜通藏身处附近的路口没有警察）。阿尔·拜通正在计划他的逃跑路线。令你非常（且相当不愉快）惊讶的是，他拜访了你，并要求你计算符合上述要求的从银行到他藏身处的不同逃跑路线的数量。不用说，阿尔·拜通不接受“拒绝”作为答案……\n\nByteburg 的街道形成一个矩形网格。每条街道要么是南北方向，要么是东西方向，并且每两条不平行的街道相交。银行位于最西南路口的南边。\n\n阿尔·拜通将开始他的伟大逃亡，向北行驶。\n\n任务\n\n编写一个程序：\n\n从标准输入读取藏身处的位置、警察所在路口的描述和一个正整数 $k$，计算符合上述要求的从银行到藏身处的不同逃跑路线的数量，并将该数量对 $k$ 取模的结果写入标准输出。", "inputFormat": "标准输入的第一行有三个整数 $n$、$m$ 和 $k$（$1\\le n,m\\le 100$，$1\\le k\\le 10^9$）。\n\n数字 $n$ 和 $m$ 分别表示东西方向和南北方向的街道数量。\n\n第二行包含两个整数 $x$ 和 $y$（$1\\le x\\le n$，$1\\le y\\le m$）。\n\n这些代表藏身处的位置——在第 $x$ 条南北方向街道和第 $y$ 条东西方向街道的交叉口。", "outputFormat": "你的程序应在标准输出的第一行写出逃跑路线数量对 $k$ 取模的结果。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3474", "type": "P", "difficulty": 6, "samples": [["8 4\n1 2 1 3\n25 1 2 1\n4 20 3 3\n3 30 12 2", "2 1 4 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2008", "POI（波兰）", "Special Judge", "前缀和", "单调栈"], "title": "[POI 2008] KUP-Plot purchase", "background": "", "description": "Byteasar is going to buy an industrial plot.\n\nHis fortune is estimated at $k$ bythalers and this is exactly the amount    Byteasar would like to spend on the parcel.\n\nFinding a parcel worth exactly $k$ bythalers, however, is not an easy task.\n\nFor this reason Byteasar is ready to buy a more expensive plot.\n\nHe considers taking out a loan. The Byteotian Credit Bank will grant him    a loan of up to $k$ bythalers. Thus, Byteasar can spend no more than $2k$    bythalers on the parcel and he would like to spend no less than $k$ bythalers.\n\nThe area in which Byteasar wants to buy his parcel is a square with side    length of $n$ metres. The current landlords have set up various prices per square metre. Byteasar has spoken to each one of them and has then prepared a price map    of the area. The map depicts the price of every metre by metre square. Clearly, there    are $n^2$ such squares. Now is the time to find the dream parcel. It has to be rectangular and consist of whole unit squares. Byteasar has already started looking for the plot on the map,    but after many hours he was still unable to find a suitable one. Be a chap and help him!\n\n<Task> \n\nWrite a programme that:\n\nreads the numbers $k$ and $n$ from the standard input,  along with the price map of the area, determines a parcel with price in the interval $[k,2k]$ or states that no such parcel exists, writes out the result to the standard output.\n\n", "inputFormat": "The first line of the standard input contains two integers, $k$ and $n$, separated by a single space, $1\\le k\\le 10^9$, $1\\le n\\le 2000$.\n\nEach of the following $n$ lines contains $n$ non-negative integers, separated by single spaces.\n\n$i^\\mathrm{th}$ number in the line no. $j+1$ denotes the price of unit square with coordinates $(i,j)$.\n\nThe price of one square metre does not exceed $2{,}000{,}000{,}000$ bythalers.\n", "outputFormat": "If no plot with price in the interval $[k,2k]$ exists, your programme should output exactly one line with word `NIE` (NO in Polish).\n\nOtherwise it should print out one line with four positive integers $x_1,y_1,x_2,y_2$ separated by single spaces and denoting the rectangle's      coordinates.\n\n$(x_1,y_1)$ denotes the upper left rectangle corner, while $(x_2,y_2)$ the lower right corner.\n\nThen it consists of the squares: $\\{x,y\\mid x_1\\le x\\le x_2,y_1\\le y\\le y_2\\}$.\n\nThe sum $c$ of prices of the squares forming up this rectangle should satisfy the inequality $k\\le c\\le 2k$.\n\nIf more than one rectangular parcel satisfies this condition, pick one arbitrarily.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2008] KUP-Plot purchase", "background": "", "description": "Byteasar is going to buy an industrial plot.\n\nHis fortune is estimated at $k$ bythalers and this is exactly the amount    Byteasar would like to spend on the parcel.\n\nFinding a parcel worth exactly $k$ bythalers, however, is not an easy task.\n\nFor this reason Byteasar is ready to buy a more expensive plot.\n\nHe considers taking out a loan. The Byteotian Credit Bank will grant him    a loan of up to $k$ bythalers. Thus, Byteasar can spend no more than $2k$    bythalers on the parcel and he would like to spend no less than $k$ bythalers.\n\nThe area in which Byteasar wants to buy his parcel is a square with side    length of $n$ metres. The current landlords have set up various prices per square metre. Byteasar has spoken to each one of them and has then prepared a price map    of the area. The map depicts the price of every metre by metre square. Clearly, there    are $n^2$ such squares. Now is the time to find the dream parcel. It has to be rectangular and consist of whole unit squares. Byteasar has already started looking for the plot on the map,    but after many hours he was still unable to find a suitable one. Be a chap and help him!\n\n<Task> \n\nWrite a programme that:\n\nreads the numbers $k$ and $n$ from the standard input,  along with the price map of the area, determines a parcel with price in the interval $[k,2k]$ or states that no such parcel exists, writes out the result to the standard output.\n\n", "inputFormat": "The first line of the standard input contains two integers, $k$ and $n$, separated by a single space, $1\\le k\\le 10^9$, $1\\le n\\le 2000$.\n\nEach of the following $n$ lines contains $n$ non-negative integers, separated by single spaces.\n\n$i^\\mathrm{th}$ number in the line no. $j+1$ denotes the price of unit square with coordinates $(i,j)$.\n\nThe price of one square metre does not exceed $2{,}000{,}000{,}000$ bythalers.\n", "outputFormat": "If no plot with price in the interval $[k,2k]$ exists, your programme should output exactly one line with word `NIE` (NO in Polish).\n\nOtherwise it should print out one line with four positive integers $x_1,y_1,x_2,y_2$ separated by single spaces and denoting the rectangle's      coordinates.\n\n$(x_1,y_1)$ denotes the upper left rectangle corner, while $(x_2,y_2)$ the lower right corner.\n\nThen it consists of the squares: $\\{x,y\\mid x_1\\le x\\le x_2,y_1\\le y\\le y_2\\}$.\n\nThe sum $c$ of prices of the squares forming up this rectangle should satisfy the inequality $k\\le c\\le 2k$.\n\nIf more than one rectangular parcel satisfies this condition, pick one arbitrarily.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2008] KUP-Plot purchase", "background": "", "description": "Byteasar 打算购买一块工业用地。\n\n他的财富估计为 $k$ bythalers，这正是 Byteasar 想要花在这块地上的金额。\n\n然而，找到一块价值恰好为 $k$ bythalers 的地并不是一件容易的事。\n\n因此，Byteasar 准备购买一块更昂贵的地。\n\n他考虑贷款。Byteotian 信贷银行会为他提供最多 $k$ bythalers 的贷款。因此，Byteasar 可以在这块地上花费不超过 $2k$ bythalers，并且他希望花费不少于 $k$ bythalers。\n\nByteasar 想要购买的地块所在的区域是一个边长为 $n$ 米的正方形。当前的地主为每平方米设定了不同的价格。Byteasar 已经与他们每个人交谈过，并准备了一张该区域的价格地图。地图显示了每平方米的价格。显然，这里有 $n^2$ 个这样的正方形。现在是时候找到梦想中的地块了。它必须是矩形的，并且由完整的单位正方形组成。Byteasar 已经开始在地图上寻找地块，但经过许多小时的努力，他仍然无法找到合适的地块。请帮帮他吧！\n\n任务\n\n编写一个程序：\n\n从标准输入读取数字 $k$ 和 $n$，以及该区域的价格地图，确定一个价格在区间 $[k,2k]$ 内的地块，或者说明不存在这样的地块，将结果写入标准输出。", "inputFormat": "标准输入的第一行包含两个整数 $k$ 和 $n$，用一个空格分隔，$1\\le k\\le 10^9$，$1\\le n\\le 2000$。\n\n接下来的 $n$ 行中的每一行包含 $n$ 个非负整数，用空格分隔。\n\n第 $j+1$ 行的第 $i$ 个数字表示坐标为 $(i,j)$ 的单位正方形的价格。\n\n每平方米的价格不超过 $2,000,000,000$ bythalers。", "outputFormat": "如果不存在价格在区间 $[k,2k]$ 内的地块，你的程序应输出一行，内容为单词 `NIE`（波兰语中的 NO）。\n\n否则，它应该输出一行，包含四个正整数 $x_1,y_1,x_2,y_2$，用空格分隔，表示矩形的坐标。\n\n$(x_1,y_1)$ 表示矩形的左上角，而 $(x_2,y_2)$ 表示右下角。\n\n然后它由这些正方形组成：$\\{x,y\\mid x_1\\le x\\le x_2,y_1\\le y\\le y_2\\}$。\n\n这些正方形的价格总和 $c$ 应满足不等式 $k\\le c\\le 2k$。\n\n如果有多个矩形地块满足此条件，则任意选择一个。", "hint": "给定 $k,n$ 和 $n\\times n$ 的矩阵，求一个子矩形满足权值和在 $[k,2k]$ 之间。\n\n$n<2000$，$1\\le k\\le10^9$，每个价格都是不大于 $2 \\times 10^9$ 的非负整数。\n\n感谢 @cn：苏炯念 提供的 spj。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3475", "type": "P", "difficulty": 5, "samples": [["6 8\n1 2\n1 6\n2 3\n2 5\n2 6\n3 4\n4 5\n5 6\n", "1 2 6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "POI（波兰）", "Special Judge", "枚举", "深度优先搜索 DFS", "模拟退火", "进制", "状压 DP"], "title": "[POI 2008] POD-Subdivision of Kingdom", "background": "[English Edition](/paste/eu7u3hqg)", "description": "给出一张有 $n$ 个点 $m$ 条边的无向图，你需要求出一组合法的方案，使得图被划分为点数均为 $\\frac n2$ 的两个集合，且两个端点在不同集合中的边数最少。", "inputFormat": "第一行两个整数 $n,m$。\n\n之后 $m$ 行，每行两个整数 $a, b$，表示在 $a$ 与 $b$ 之间有一条边。", "outputFormat": "一行 $\\frac n2$ 个整数，表示在你求出的方案中的一个集合的所有点，由编号从小到大排序。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 26$，$1\\le a,b\\le n$，且 $n$ 为偶数。保证没有重边。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2008] POD-Subdivision of Kingdom", "background": "[English Edition](/paste/eu7u3hqg)", "description": "Given an undirected graph with $n$ vertices and $m$ edges, you need to find a valid partition of the vertices into two sets, each of size $\\frac{n}{2}$, such that the number of edges whose endpoints lie in different sets is minimized.", "inputFormat": "The first line contains two integers $n, m$.\n\nThen follow $m$ lines, each containing two integers $a, b$, indicating that there is an edge between $a$ and $b$.", "outputFormat": "Output one line with $\\frac{n}{2}$ integers: all vertices in one of the sets from your partition, sorted in increasing order by their labels.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 26$, $1 \\le a, b \\le n$, and $n$ is even. It is guaranteed that there are no multiple edges.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2008] POD-Subdivision of Kingdom", "background": "[English Edition](/paste/eu7u3hqg)", "description": "给出一张有 $n$ 个点 $m$ 条边的无向图，你需要求出一组合法的方案，使得图被划分为点数均为 $\\frac n2$ 的两个集合，且两个端点在不同集合中的边数最少。", "inputFormat": "第一行两个整数 $n,m$。\n\n之后 $m$ 行，每行两个整数 $a, b$，表示在 $a$ 与 $b$ 之间有一条边。", "outputFormat": "一行 $\\frac n2$ 个整数，表示在你求出的方案中的一个集合的所有点，由编号从小到大排序。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 26$，$1\\le a,b\\le n$，且 $n$ 为偶数。保证没有重边。", "locale": "zh-CN"}}}
{"pid": "P3476", "type": "P", "difficulty": 6, "samples": [["5\n0 0\n1 2\n0 2\n1 0\n1 1\n", "7.0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2008", "POI（波兰）", "深度优先搜索 DFS", "叉积"], "title": "[POI 2008] TRO-Triangles", "background": "", "description": "$n$ pairwise disjoint points in the plane are given ($n\\ge 3$).\n\nThere are $\\dfrac{n(n-1)(n-2)}{6}$ triangles whose    vertices are some pairwise different points among them    (including degenerate triangles, i.e. ones whose vertices are collinear).\n\nWe want to calculate the sum of areas of all the triangles with vertices    in the given points.\n\nThose parts of the plane that belong to many triangles are to be calculated    multiple times. We assume that the area of degenerate triangles (i.e. those    with collinear vertices) is zero.\n\n<Task>\n\nWrite a programme that:\n\nreads from the standard input the coordinates of the points in the plane,                 determines the sum of the areas of all the triangles with vertices in       the given points,                  prints out the result to the standard output.\n\n\n", "inputFormat": "In the first line of the standard input there is one integer $n$ ($3\\le n\\le 3000$) denoting the number of selected points.\n\nEach of the following $n$ lines contains two integers $x_i$ and $y_i$ ($0\\le x_i,y_i\\le 10^4$) separated by a single space and denoting   the coordinates of the $i^\\mathrm{th}$ point (for $i=1,2,\\cdots,n$).\n\nNo pair (ordered) of coordinates appears more than once.\n", "outputFormat": "In the first and only line of the standard output there should be one   real number equal to the sum of the areas of all the triangles with   vertices in the given points. The outcome should be printed out with   exactly one digit after dot and should not differ from the correct value   by more than $0.1$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2008] TRO-Triangles", "background": "", "description": "$n$ pairwise disjoint points in the plane are given ($n\\ge 3$).\n\nThere are $\\dfrac{n(n-1)(n-2)}{6}$ triangles whose    vertices are some pairwise different points among them    (including degenerate triangles, i.e. ones whose vertices are collinear).\n\nWe want to calculate the sum of areas of all the triangles with vertices    in the given points.\n\nThose parts of the plane that belong to many triangles are to be calculated    multiple times. We assume that the area of degenerate triangles (i.e. those    with collinear vertices) is zero.\n\n<Task>\n\nWrite a programme that:\n\nreads from the standard input the coordinates of the points in the plane,                 determines the sum of the areas of all the triangles with vertices in       the given points,                  prints out the result to the standard output.\n\n\n", "inputFormat": "In the first line of the standard input there is one integer $n$ ($3\\le n\\le 3000$) denoting the number of selected points.\n\nEach of the following $n$ lines contains two integers $x_i$ and $y_i$ ($0\\le x_i,y_i\\le 10^4$) separated by a single space and denoting   the coordinates of the $i^\\mathrm{th}$ point (for $i=1,2,\\cdots,n$).\n\nNo pair (ordered) of coordinates appears more than once.\n", "outputFormat": "In the first and only line of the standard output there should be one   real number equal to the sum of the areas of all the triangles with   vertices in the given points. The outcome should be printed out with   exactly one digit after dot and should not differ from the correct value   by more than $0.1$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2008] TRO-Triangles", "background": "", "description": "平面上给定了 $n$ 个两两不相交的点（$n \\ge 3$）。\n\n这些点中有 $\\dfrac{n(n-1)(n-2)}{6}$ 个三角形，其顶点是其中一些两两不同的点（包括退化三角形，即顶点共线的三角形）。\n\n我们想要计算所有以给定点为顶点的三角形的面积之和。\n\n属于多个三角形的平面部分需要多次计算。我们假设退化三角形（即顶点共线的三角形）的面积为零。\n\n<Task>\n\n编写一个程序：\n\n从标准输入读取平面上点的坐标，确定所有以给定点为顶点的三角形的面积之和，输出结果到标准输出。", "inputFormat": "标准输入的第一行有一个整数 $n$（$3 \\le n \\le 3000$），表示选定点的数量。\n\n接下来的 $n$ 行中的每一行包含两个整数 $x_i$ 和 $y_i$（$0 \\le x_i, y_i \\le 10^4$），用一个空格分隔，表示第 $i$ 个点的坐标（对于 $i=1,2,\\cdots,n$）。\n\n没有一对（有序的）坐标会出现多于一次。", "outputFormat": "标准输出的第一行应该是一个实数，等于所有以给定点为顶点的三角形的面积之和。结果应精确到小数点后一位，并且与正确值的误差不超过 $0.1$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3477", "type": "P", "difficulty": 6, "samples": [["4 1000\n2 1 10 2\n", "5\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "POI（波兰）"], "title": "[POI 2008] PER-Permutation", "background": "", "description": "Multiset is a mathematical object similar to a set,    but each member of a multiset may have more than one membership.\n\nJust as with any set, the members of a multiset can be ordered    in many ways. We call each such ordering a permutation    of the multiset. For example, among the permutations of the    multiset{1,1,2,3,3,3,7,8}. there are {2,3,1,3,3,7,1,8}   and{8,7,3,3,3,2,1,1}.\n\nWe will say that one permutation of a given multiset is smaller    (in lexicographic order) than another permutation, if on the first    position that does not match the first permutation has a smaller    element than the other one. All permutations of a given multiset    can be numbered (starting from one) in an increasing order.\n\nTask      Write a programme that   reads the description of a permutation of a multiset and a positive          integerm from the standard input,                      determines the remainder of the rank of that permutation in the          lexicographic ordering modulo m,         writes out the result to the standard output.\n\n多重集合是数学中的一个概念，它的定义很像集合，但是在多重集之中，同一个元素可以出现多次。\n\n\n和集合一样，多重集的的元素可以有很多种元素的排布顺序。我们把它叫作多重集的排列。\n\n\n现在我们定义多重集的某个排列$s_i$比某个排列$s_j$\n\n的大小比较为字典序比较。这样某个多重集的排列可以从小到大得排起来。\n\n\n现在给你一个元素个数为n的多重集的一个排列和m，求这个排列的排名取模m。\n", "inputFormat": "The first line of the standard input holds two integers n($1\\le n \\le 300000$) and m  ($2 \\le m \\le 10^9$ ) ,separated by      a single space. These denote, respectively, the cardinality of the      multiset and \\dots\\ the number m.\n\nThe second line of the standard input contains n positive integers      $a_i$($1\\le a_i \\le 300000$), separated by single spaces and denoting      successive elements of the multiset permutation.\n\n第一行 两个整数n,m\n\n\n第二行 n个数，代表多重集的排列\n", "outputFormat": "The first and only line of the standard output is to hold one integer,      the remainder modulo m of the rank of the input permutation in the      lexicographic ordering.\n\n\n一行一个整数 排名取模m\n", "hint": "感谢@远航之曲 贡献的翻译\n", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2008] PER-Permutation", "background": "", "description": "A multiset is like a set, but elements may appear more than once.\n\nA permutation of a multiset is any ordering of its elements. For example, among the permutations of the multiset {1, 1, 2, 3, 3, 3, 7, 8}, there are {2, 3, 1, 3, 3, 7, 1, 8} and {8, 7, 3, 3, 3, 2, 1, 1}.\n\nWe use lexicographic order to compare two permutations: at the first position where they differ, the permutation with the smaller element is considered smaller. All permutations of a given multiset can be sorted increasingly and numbered starting from 1 (this number is called the rank).\n\nTask: Given a permutation of a multiset of size n and a positive integer m, compute the remainder modulo m of the rank of this permutation in lexicographic order.", "inputFormat": "- The first line contains two integers n and m ($1 \\le n \\le 300000$, $2 \\le m \\le 10^9$): the size of the multiset and the modulus m.\n- The second line contains n positive integers $a_i$ ($1 \\le a_i \\le 300000$), the given permutation of the multiset.", "outputFormat": "Output a single integer: the rank of the given permutation in lexicographic order, taken modulo m.", "hint": "Thanks to @远航之曲 for the translation.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2008] PER-Permutation", "background": "", "description": "Multiset is a mathematical object similar to a set,    but each member of a multiset may have more than one membership.\n\nJust as with any set, the members of a multiset can be ordered    in many ways. We call each such ordering a permutation    of the multiset. For example, among the permutations of the    multiset{1,1,2,3,3,3,7,8}. there are {2,3,1,3,3,7,1,8}   and{8,7,3,3,3,2,1,1}.\n\nWe will say that one permutation of a given multiset is smaller    (in lexicographic order) than another permutation, if on the first    position that does not match the first permutation has a smaller    element than the other one. All permutations of a given multiset    can be numbered (starting from one) in an increasing order.\n\nTask      Write a programme that   reads the description of a permutation of a multiset and a positive          integerm from the standard input,                      determines the remainder of the rank of that permutation in the          lexicographic ordering modulo m,         writes out the result to the standard output.\n\n多重集合是数学中的一个概念，它的定义很像集合，但是在多重集之中，同一个元素可以出现多次。\n\n\n和集合一样，多重集的的元素可以有很多种元素的排布顺序。我们把它叫作多重集的排列。\n\n\n现在我们定义多重集的某个排列$s_i$比某个排列$s_j$\n\n的大小比较为字典序比较。这样某个多重集的排列可以从小到大得排起来。\n\n\n现在给你一个元素个数为n的多重集的一个排列和m，求这个排列的排名取模m。\n", "inputFormat": "The first line of the standard input holds two integers n($1\\le n \\le 300000$) and m  ($2 \\le m \\le 10^9$ ) ,separated by      a single space. These denote, respectively, the cardinality of the      multiset and \\dots\\ the number m.\n\nThe second line of the standard input contains n positive integers      $a_i$($1\\le a_i \\le 300000$), separated by single spaces and denoting      successive elements of the multiset permutation.\n\n第一行 两个整数n,m\n\n\n第二行 n个数，代表多重集的排列\n", "outputFormat": "The first and only line of the standard output is to hold one integer,      the remainder modulo m of the rank of the input permutation in the      lexicographic ordering.\n\n\n一行一个整数 排名取模m\n", "hint": "感谢@远航之曲 贡献的翻译\n", "locale": "zh-CN"}}}
{"pid": "P3478", "type": "P", "difficulty": 4, "samples": [["8\n1 4\n5 6\n4 5\n6 7\n6 8\n2 4\n3 4\n", "7\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "树形数据结构", "2008", "POI（波兰）", "Special Judge", "O2优化", "树形 DP"], "title": "[POI 2008] STA-Station", "background": "", "description": "给定一个 $n$ 个点的树，请求出一个结点，使得以这个结点为根时，所有结点的深度之和最大。\n\n一个结点的深度之定义为该节点到根的简单路径上边的数量。", "inputFormat": "第一行有一个整数，表示树的结点个数 $n$。  \n接下来 $(n - 1)$ 行，每行两个整数 $u, v$，表示存在一条连接 $u, v$ 的边。", "outputFormat": "**本题存在 Special Judge**。\n\n输出一行一个整数表示你选择的结点编号。如果有多个结点符合要求，输出任意一个即可。", "hint": "#### 样例 1 解释\n\n输出 $7$ 和 $8$ 都是正确答案。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 10^6$，$1 \\leq u, v \\leq n$，给出的是一棵树。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2008] STA-Station", "background": "", "description": "Given a tree with $n$ nodes, find a node such that when this node is chosen as the root, the sum of depths of all nodes is maximized.\n\nThe depth of a node is defined as the number of edges on the simple path from that node to the root.", "inputFormat": "The first line contains an integer $n$, the number of nodes in the tree.  \nThe next $(n - 1)$ lines each contain two integers $u, v$, indicating that there is an edge connecting $u$ and $v$.", "outputFormat": "This problem uses Special Judge.\n\nOutput one line with an integer, the index of the chosen node. If multiple nodes satisfy the requirement, output any one of them.", "hint": "Sample 1 Explanation:\n\nOutputting $7$ or $8$ are both correct answers.\n\nConstraints:\n\nFor all test points, it is guaranteed that $1 \\leq n \\leq 10^6$, $1 \\leq u, v \\leq n$, and the input is a tree.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2008] STA-Station", "background": "", "description": "给定一个 $n$ 个点的树，请求出一个结点，使得以这个结点为根时，所有结点的深度之和最大。\n\n一个结点的深度之定义为该节点到根的简单路径上边的数量。", "inputFormat": "第一行有一个整数，表示树的结点个数 $n$。  \n接下来 $(n - 1)$ 行，每行两个整数 $u, v$，表示存在一条连接 $u, v$ 的边。", "outputFormat": "**本题存在 Special Judge**。\n\n输出一行一个整数表示你选择的结点编号。如果有多个结点符合要求，输出任意一个即可。", "hint": "#### 样例 1 解释\n\n输出 $7$ 和 $8$ 都是正确答案。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 10^6$，$1 \\leq u, v \\leq n$，给出的是一棵树。", "locale": "zh-CN"}}}
{"pid": "P3479", "type": "P", "difficulty": 6, "samples": [["12 3 1\n1 12\n3 8\n7 8\n8 9\n2 12\n10 12\n9 12\n4 8\n5 8\n8 11\n6 8\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2009", "POI（波兰）"], "title": "[POI 2009] GAS-Fire Extinguishers", "background": "\n", "description": "Byteasar has had a new palace built. It consists of $n$ chambers and $n-1$ corridors connecting them. Each corridor connects exactly two chambers. The rooms are numbered from $1$ to $n$. There is only a single entrance to the palace, which leads to chamber no. $1$). For each chamber there is exactly one route leading to it from the entrance, without turning back on the way. In other words, the chambers and the corridors form a tree - a connected acyclic graph.\n\nThe fire marshal who is to approve the building demands placing fire extinguishers inside.\n\nThe following are his exact requirements:\n\n- The fire extinguishers should be placed in (some) chambers, and one chamber  may store any number of extinguishers.\n- Each chamber has to be assigned one fire extinguisher, though it may be stored  in another chamber.\n- Each fire extinguisher can be assigned to at most $S$ different chambers.\n- For each room its assigned extinguisher is within the range of $K$ corridors.\n\nByteasar has a week spot for lavish palaces, so it is no surprise he has very little money now, right after completion of another splendid palace.\n\nTherefore he is interested in the minimum number of fire extinguishers sufficient  for satisfying fire marshal's demands.\n\n", "inputFormat": "The first line of the standard input contains three integers $n$, $s$ and $k$ separated by single spaces, $1\\le n\\le 10^5$, $1\\le s\\le n$, $1\\le k\\le 20$.\n\nEach of the following $n-1$ lines holds two integers separated by a single space.\n\nLine no. $i+1$ contains the numbers $x_i,y_i$ denoting the corridor connecting chambers no.$x_i$ and $y_i$.", "outputFormat": "The first and only line of the standard output is to hold one integer - the minimum number of fire extinguishers that have to be installed in palace.\n", "hint": "$1\\leq n,m\\leq 100000, 1\\leq k \\leq 20 , x_i\\geq 1$", "locale": "en", "translations": {"en": {"title": "[POI 2009] GAS-Fire Extinguishers", "background": "\n", "description": "Byteasar has had a new palace built. It consists of $n$ chambers and $n-1$ corridors connecting them. Each corridor connects exactly two chambers. The rooms are numbered from $1$ to $n$. There is only a single entrance to the palace, which leads to chamber no. $1$). For each chamber there is exactly one route leading to it from the entrance, without turning back on the way. In other words, the chambers and the corridors form a tree - a connected acyclic graph.\n\nThe fire marshal who is to approve the building demands placing fire extinguishers inside.\n\nThe following are his exact requirements:\n\n- The fire extinguishers should be placed in (some) chambers, and one chamber  may store any number of extinguishers.\n- Each chamber has to be assigned one fire extinguisher, though it may be stored  in another chamber.\n- Each fire extinguisher can be assigned to at most $S$ different chambers.\n- For each room its assigned extinguisher is within the range of $K$ corridors.\n\nByteasar has a week spot for lavish palaces, so it is no surprise he has very little money now, right after completion of another splendid palace.\n\nTherefore he is interested in the minimum number of fire extinguishers sufficient  for satisfying fire marshal's demands.\n\n", "inputFormat": "The first line of the standard input contains three integers $n$, $s$ and $k$ separated by single spaces, $1\\le n\\le 10^5$, $1\\le s\\le n$, $1\\le k\\le 20$.\n\nEach of the following $n-1$ lines holds two integers separated by a single space.\n\nLine no. $i+1$ contains the numbers $x_i,y_i$ denoting the corridor connecting chambers no.$x_i$ and $y_i$.", "outputFormat": "The first and only line of the standard output is to hold one integer - the minimum number of fire extinguishers that have to be installed in palace.\n", "hint": "$1\\leq n,m\\leq 100000, 1\\leq k \\leq 20 , x_i\\geq 1$", "locale": "en"}, "zh-CN": {"title": "[POI 2009] GAS-Fire Extinguishers", "background": null, "description": "Byteasar 新建了一座宫殿。它由 $n$ 个房间和 $n-1$ 条走廊连接而成。每条走廊正好连接两个房间。房间编号从 $1$ 到 $n$。宫殿只有一个入口，通向编号为 $1$ 的房间。对于每个房间，从入口到它只有一条不回头的路线。换句话说，房间和走廊形成了一棵树——一个连通无环图。\n\n负责批准建筑的消防员要求在内部放置灭火器。\n\n他的具体要求如下：\n\n- 灭火器应放置在（某些）房间中，一个房间可以存放任意数量的灭火器。\n- 每个房间必须分配一个灭火器，尽管它可以存放在另一个房间中。\n- 每个灭火器最多可以分配给 $s$ 个不同的房间。\n- 对于每个房间，其分配的灭火器在 $k$ 条走廊范围内。\n\nByteasar 对奢华的宫殿情有独钟，所以毫不奇怪，在完成另一个辉煌的宫殿后，他现在几乎没有钱。\n\n因此，他对满足消防员要求所需的最少灭火器数量感兴趣。", "inputFormat": "标准输入的第一行包含三个整数 $n$、$s$ 和 $k$，用单个空格分隔，$1 \\le n \\le 10^5$，$1 \\le s \\le n$，$1 \\le k \\le 20$。\n\n接下来的 $n-1$ 行中的每一行包含两个整数，用单个空格分隔。\n\n第 $i+1$ 行包含数字 $x_i,y_i$，表示连接房间编号 $x_i$ 和 $y_i$ 的走廊。", "outputFormat": "标准输出的第一行应包含一个整数——在宫殿中必须安装的最少灭火器数量。", "hint": "$1 \\leq n,s \\leq 100000, 1 \\leq k \\leq 20 , x_i \\geq 1$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3480", "type": "P", "difficulty": 6, "samples": [["2\n2\n2 2\n3\n1 2 4\n", "NIE\nTAK\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["博弈论", "2009", "POI（波兰）"], "title": "[POI 2009] KAM-Pebbles", "background": "", "description": "Johny and Margaret are playing \"pebbles\". Initially there is a certain number of pebbles on a table, grouped in $n$ piles. The piles are next to each other, forming a single row. The arrangement of stones satisfies an additional property that each pile consists of at least as many pebbles as the one to the left (with the obvious exception of the leftmost pile). The players alternately remove any number of pebbles from a single pile of their choice. They have to take care, though, not to make any pile smaller than the one left to it. In other words, the piles have to satisfy the initial property after the move as well. When one of the players cannot make a move (i.e. before his move there are no more pebbles on the table), he loses. Johny always starts, to compensate for Margaret's mastery in this game.\n\nIn fact Margaret is so good that she always makes the best move, and wins the game whenever she has a chance. Therefore Johny asks your help - he would like to know if he stands a chance of beating Margaret with a particular initial arrangement. Write a programme that determines answers to Johny's inquiries.\n", "inputFormat": "In the first line of the standard input there is a single integer $u$ ($1\\le u\\le 10$) denoting the number of initial pebble arrangements to analyse.\n\nThe following $2u$ lines contain descriptions of these arrangements; each one takes exactly two lines.\n\nThe first line of each description contains a single integer $n$, $1\\le n\\le 1000$  - the number of piles.\n\nThe second line of description holds  non-negative integers  separated by single spaces and denoting the numbers of pebbles in successive piles, left to right.\n\nThese numbers satisfy the following inequality $a_1\\le a_2\\le \\cdots \\le a_n$.\n\n\nThe total number of pebbles in any arrangement does not exceed $1000$.\n", "outputFormat": "Precisely $n$ lines should be printed out on the standard output.\n\nThe $i$-th of these lines (for $1\\le i\\le u$) should hold the word TAK (yes in Polish), if Johny can win starting with the $i$-th initial arrangement given in the input, or the word NIE (no in Polish), if Johny is bound to lose that game, assuming optimal play of Margaret.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] KAM-Pebbles", "background": "", "description": "Johny and Margaret are playing \"pebbles\". Initially there is a certain number of pebbles on a table, grouped in $n$ piles. The piles are next to each other, forming a single row. The arrangement of stones satisfies an additional property that each pile consists of at least as many pebbles as the one to the left (with the obvious exception of the leftmost pile). The players alternately remove any number of pebbles from a single pile of their choice. They have to take care, though, not to make any pile smaller than the one left to it. In other words, the piles have to satisfy the initial property after the move as well. When one of the players cannot make a move (i.e. before his move there are no more pebbles on the table), he loses. Johny always starts, to compensate for Margaret's mastery in this game.\n\nIn fact Margaret is so good that she always makes the best move, and wins the game whenever she has a chance. Therefore Johny asks your help - he would like to know if he stands a chance of beating Margaret with a particular initial arrangement. Write a programme that determines answers to Johny's inquiries.\n", "inputFormat": "In the first line of the standard input there is a single integer $u$ ($1\\le u\\le 10$) denoting the number of initial pebble arrangements to analyse.\n\nThe following $2u$ lines contain descriptions of these arrangements; each one takes exactly two lines.\n\nThe first line of each description contains a single integer $n$, $1\\le n\\le 1000$  - the number of piles.\n\nThe second line of description holds  non-negative integers  separated by single spaces and denoting the numbers of pebbles in successive piles, left to right.\n\nThese numbers satisfy the following inequality $a_1\\le a_2\\le \\cdots \\le a_n$.\n\n\nThe total number of pebbles in any arrangement does not exceed $1000$.\n", "outputFormat": "Precisely $n$ lines should be printed out on the standard output.\n\nThe $i$-th of these lines (for $1\\le i\\le u$) should hold the word TAK (yes in Polish), if Johny can win starting with the $i$-th initial arrangement given in the input, or the word NIE (no in Polish), if Johny is bound to lose that game, assuming optimal play of Margaret.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] KAM-Pebbles", "background": null, "description": "有 $n$ 堆石子。除了第一堆外，每堆石子个数都不少于前一堆的石子个数。两人轮流操作。每次操作可以从一堆石子中移走任意多颗石子，但是要保证操作后仍然满足初始时的条件。没有石子可移动的人就输掉了游戏。问先手是否必胜。", "inputFormat": "多组输入，第一行一个整数 $u$ 代表数据组数（$1\\le u\\le 10$）\n\n接下来共 $2u$ 行，每两行代表一组数据：\n\n第一行只有一个整数 $n$（$1\\le n\\le 1000$），表示石子堆数；\n\n第二行有 $n$ 个整数用空格隔开，第 $i$ 个整数 $a_i$ 表示第 $i$ 堆的石子个数，保证 $a_1\\le a_2\\le a_3\\le \\cdots\\le a_n$。\n\n对于每组数据，保证石子总数不超过 $1000$。", "outputFormat": "输出 $u$ 行。在第 $i$ 行，如果第 $i$ 组数据是先手必胜，输出 `TAK`，否则输出 `NIE`。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3481", "type": "P", "difficulty": 6, "samples": [["2\n4 5\n3 1 2 1\n1 3 1 2 1\n7 7\n1 1 2 1 2 1 3\n1 1 2 1 3 1 3\n", "0\n1\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "POI（波兰）"], "title": "[POI 2009] PRZ-Algorithm Speedup", "background": "", "description": "As a punishment for misbehaving, Byteasar is to calculate a certain mysterious and nasty Boolean-valued function $F(x,y)$, which is defined for a pair of positive integer sequences $x=(x_1,x_2,\\cdots,x_n)$, $y=(y_1,y_2,\\cdots,y_n)$ as follows:\n\n- boolean $F(x, y)$\n- if $W(x)\\neq W(y)$ then return $0$ \n- else if $|W(x)|=|W(y)|=1$ then return $1$\n- else return $F(p(x), p(y)) \\wedge F(s(x), s(y))$.\n\nWhere:\n\n- $W(x)$ denotes the set of members of the sequence $x$ (order and repetitions of elements are insignificant),\n- $p(x)$ denotes the longest prefix (initial part of any length) of the sequence $x$, such that $W(x)\\neq W(p(x))$,\n- $s(x)$ denotes the longest suffix (final part of any length) of the sequence $x$, such that $W(x)\\neq W(s(x))$,\n- $\\wedge$ denotes the logical conjunction, $1$ - true, $0$ - false,      and $|z|$ - cardinality of set $z$.\n\nFor example, for the sequence $x=(2,3,7,2,7,4,7,2,4)$ we have: $W(x)=\\{2,3,4,7\\}$, $p(x)=(2,3,7,2,7)$, $s(x)=(7,2,7,4,7,2,4)$. For very large data a programme calculating values of the function $F$ directly from definition is too slow by any standards. Therefore you are to make these calculations as fast as possible.\n\nWrite a programme that reads several pairs of sequences $(x,y)$ from the standard input and    prints out the values $F(x,y)$ on the standard output for every input pair.\n\n", "inputFormat": "The first line of the standard input contains one integer $k$ ($1\\le k\\le 13$) denoting the number of sequence pairs to analyse.\n\nNext $3k$ line hold descriptions of test cases.\n\nThe first line of each description contains two integers $n$ and $m$ ($1\\le n,m\\le 100{,}000$) separated by a single space and denoting the lengths of the first and second sequence, respectively.\n\nThe second line holds $n$ integers $x_i$ ($1\\le x_i\\le 100$) that form the sequence $x$, separated by single spaces.\n\nThe third line holds $m$ integers $y_i$ ($1\\le y_i\\le 100$),    that form the sequence $y$, separated by single spaces.\n", "outputFormat": "The output should consist of exactly $k$ lines; the $i$-th line (for $1\\le i\\le k$) should contain a single integer - 0 or 1 - the value of $F(x, y)$ for $i$-th test case.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] PRZ-Algorithm Speedup", "background": "", "description": "As a punishment for misbehaving, Byteasar is to calculate a certain mysterious and nasty Boolean-valued function $F(x,y)$, which is defined for a pair of positive integer sequences $x=(x_1,x_2,\\cdots,x_n)$, $y=(y_1,y_2,\\cdots,y_n)$ as follows:\n\n- boolean $F(x, y)$\n- if $W(x)\\neq W(y)$ then return $0$ \n- else if $|W(x)|=|W(y)|=1$ then return $1$\n- else return $F(p(x), p(y)) \\wedge F(s(x), s(y))$.\n\nWhere:\n\n- $W(x)$ denotes the set of members of the sequence $x$ (order and repetitions of elements are insignificant),\n- $p(x)$ denotes the longest prefix (initial part of any length) of the sequence $x$, such that $W(x)\\neq W(p(x))$,\n- $s(x)$ denotes the longest suffix (final part of any length) of the sequence $x$, such that $W(x)\\neq W(s(x))$,\n- $\\wedge$ denotes the logical conjunction, $1$ - true, $0$ - false,      and $|z|$ - cardinality of set $z$.\n\nFor example, for the sequence $x=(2,3,7,2,7,4,7,2,4)$ we have: $W(x)=\\{2,3,4,7\\}$, $p(x)=(2,3,7,2,7)$, $s(x)=(7,2,7,4,7,2,4)$. For very large data a programme calculating values of the function $F$ directly from definition is too slow by any standards. Therefore you are to make these calculations as fast as possible.\n\nWrite a programme that reads several pairs of sequences $(x,y)$ from the standard input and    prints out the values $F(x,y)$ on the standard output for every input pair.\n\n", "inputFormat": "The first line of the standard input contains one integer $k$ ($1\\le k\\le 13$) denoting the number of sequence pairs to analyse.\n\nNext $3k$ line hold descriptions of test cases.\n\nThe first line of each description contains two integers $n$ and $m$ ($1\\le n,m\\le 100{,}000$) separated by a single space and denoting the lengths of the first and second sequence, respectively.\n\nThe second line holds $n$ integers $x_i$ ($1\\le x_i\\le 100$) that form the sequence $x$, separated by single spaces.\n\nThe third line holds $m$ integers $y_i$ ($1\\le y_i\\le 100$),    that form the sequence $y$, separated by single spaces.\n", "outputFormat": "The output should consist of exactly $k$ lines; the $i$-th line (for $1\\le i\\le k$) should contain a single integer - 0 or 1 - the value of $F(x, y)$ for $i$-th test case.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] PRZ-Algorithm Speedup", "background": null, "description": "由于行为不端，Byteasar 被要求计算一个神秘且棘手的布尔值函数 $F(x,y)$，该函数定义在一对正整数序列 $x=(x_1,x_2,\\cdots,x_n)$ 和 $y=(y_1,y_2,\\cdots,y_n)$ 上，如下所示：\n\n- 布尔函数 $F(x, y)$\n- 如果 $W(x)\n\\neq W(y)$ 则返回 $0$\n- 否则如果 $|W(x)|=|W(y)|=1$ 则返回 $1$\n- 否则返回 $F(p(x), p(y)) \\wedge F(s(x), s(y))$。\n\n其中：\n\n- $W(x)$ 表示序列 $x$ 的成员集合（元素的顺序和重复无关紧要），\n- $p(x)$ 表示序列 $x$ 的最长前缀（任意长度的初始部分），使得 $W(x)\n\\neq W(p(x))$，\n- $s(x)$ 表示序列 $x$ 的最长后缀（任意长度的末尾部分），使得 $W(x)\n\\neq W(s(x))$，\n- $\\wedge$ 表示逻辑与，1 表示真，0 表示假，$|z|$ 表示集合 $z$ 的基数。\n\n例如，对于序列 $x=(2,3,7,2,7,4,7,2,4)$，我们有：$W(x)=\\{2,3,4,7\\}$，$p(x)=(2,3,7,2,7)$，$s(x)=(7,2,7,4,7,2,4)$。对于非常大的数据，直接从定义计算函数 $F$ 的值的程序速度太慢。因此，你需要尽可能快地进行这些计算。\n\n编写一个程序，从标准输入读取若干对序列 $(x,y)$，并在标准输出中打印每个输入对的 $F(x,y)$ 值。", "inputFormat": "标准输入的第一行包含一个整数 $k$ ($1\\le k\\le 13$)，表示要分析的序列对的数量。\n\n接下来的 $3k$ 行包含测试用例的描述。\n\n每个描述的第一行包含两个整数 $n$ 和 $m$ ($1\\le n,m\\le 100{,}000$)，用单个空格分隔，表示第一和第二序列的长度。\n\n第二行包含 $n$ 个整数 $x_i$ ($1\\le x_i\\le 100$)，形成序列 $x$，以单个空格分隔。\n\n第三行包含 $m$ 个整数 $y_i$ ($1\\le y_i\\le 100$)，形成序列 $y$，以单个空格分隔。", "outputFormat": "输出应由正好 $k$ 行组成；第 $i$ 行（对于 $1\\le i\\le k$）应包含一个整数 - 0 或 1 - 表示第 $i$ 个测试用例的 $F(x, y)$ 值。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3482", "type": "P", "difficulty": 5, "samples": [["6\n2400 2000 1200 2400 1600 4000\n1 4 5 3 6 2\n5 3 2 4 6 1\n", "11200\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "POI（波兰）", "置换"], "title": "[POI 2009] SLO-Elephants", "background": "", "description": "A parade of all elephants is to commence soon at the Byteotian zoo.\n\nThe zoo employees have encouraged these enormous animals to form a single line,  as the manager wills it to be the initial figure of the parade.\n\nUnfortunately, the manager himself came to the parade and did not quite like  what he saw - he had intended an entirely different order of the elephants.\n\nTherefore he enforced his ordering, claiming the animals would seem most  majestic this way, and made the employees reorder the elephants accordingly.\n\nAs a pack of moving elephants can wreak havoc, the employees decided to have  them rearranged by swapping one pair at a time. Luckily the animals need not  stand next to each other in order to swap positions in the line. Making an elephant  move, however, is not as easy as it sounds. In fact, the effort one has to put  into it is proportional to the animal's mass. Hence, the effort involved in  swapping a pair of elephants of respective masses $m_1$ and $m_2$ can be  estimated by $m_1+m_2$. What is the minimum effort involved in rearranging  the elephants according to manager's will?\n\nWrite a programme that:\n\n- reads from the standard input the masses of all elephants from the zoo,        along with their current and desired order in the line,\n- determines a sequence of elephant swaps leading from the initial to the        desired order of animals in the line, such that this sequence minimises        the summary effort involved in all the swaps, \n- prints out the summary effort on the standard output.\n\n\n", "inputFormat": "The first line of the standard input contains a single integer $n$  ($1\\le n\\le 1{,}000{,}000$) denoting the number of elephants in the zoo.\n\nWe assume that the elephants are numbered from $1$ to $n$ to simplify things.\n\nThe second line holds $n$ integers $m_i$ ($100\\le m_i\\le 6{,}500$ dla $1\\le i\\le n$)  separated by single spaces and denoting the masses of respective elephants  (in kilogrammes).\n\nThe third line of input contains $n$ pairwise different integers $a_i$  ($1\\le a_i\\le n$) separated by single spaces and denoting the numbers of successive elephants in the initial ordering.\n\nThe fourth line holds $n$ pairwise different integers $b_i$ ($1 \\le  b_i \\le  n$) separated by single spaces and denoting the numbers of successive elephants in the ordering desired by the zoo manager. You may assume that the sequences $(a_i)$ and $(b_i)$ differ.", "outputFormat": "The first and only line of the standard output should contain a single integer  denoting the minimum summary effort involved in reordering the elephants  from the order represented by the sequence to the one represented by $(b_i)$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] SLO-Elephants", "background": "", "description": "A parade of all elephants is to commence soon at the Byteotian zoo.\n\nThe zoo employees have encouraged these enormous animals to form a single line,  as the manager wills it to be the initial figure of the parade.\n\nUnfortunately, the manager himself came to the parade and did not quite like  what he saw - he had intended an entirely different order of the elephants.\n\nTherefore he enforced his ordering, claiming the animals would seem most  majestic this way, and made the employees reorder the elephants accordingly.\n\nAs a pack of moving elephants can wreak havoc, the employees decided to have  them rearranged by swapping one pair at a time. Luckily the animals need not  stand next to each other in order to swap positions in the line. Making an elephant  move, however, is not as easy as it sounds. In fact, the effort one has to put  into it is proportional to the animal's mass. Hence, the effort involved in  swapping a pair of elephants of respective masses $m_1$ and $m_2$ can be  estimated by $m_1+m_2$. What is the minimum effort involved in rearranging  the elephants according to manager's will?\n\nWrite a programme that:\n\n- reads from the standard input the masses of all elephants from the zoo,        along with their current and desired order in the line,\n- determines a sequence of elephant swaps leading from the initial to the        desired order of animals in the line, such that this sequence minimises        the summary effort involved in all the swaps, \n- prints out the summary effort on the standard output.\n\n\n", "inputFormat": "The first line of the standard input contains a single integer $n$  ($1\\le n\\le 1{,}000{,}000$) denoting the number of elephants in the zoo.\n\nWe assume that the elephants are numbered from $1$ to $n$ to simplify things.\n\nThe second line holds $n$ integers $m_i$ ($100\\le m_i\\le 6{,}500$ dla $1\\le i\\le n$)  separated by single spaces and denoting the masses of respective elephants  (in kilogrammes).\n\nThe third line of input contains $n$ pairwise different integers $a_i$  ($1\\le a_i\\le n$) separated by single spaces and denoting the numbers of successive elephants in the initial ordering.\n\nThe fourth line holds $n$ pairwise different integers $b_i$ ($1 \\le  b_i \\le  n$) separated by single spaces and denoting the numbers of successive elephants in the ordering desired by the zoo manager. You may assume that the sequences $(a_i)$ and $(b_i)$ differ.", "outputFormat": "The first and only line of the standard output should contain a single integer  denoting the minimum summary effort involved in reordering the elephants  from the order represented by the sequence to the one represented by $(b_i)$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] SLO-Elephants", "background": "", "description": "在 Byteotian 动物园，一场大象游行即将开始。动物园的员工鼓励这些庞大的动物排成一列，因为经理希望这是游行的初始形态。不幸的是，经理亲自来到游行现场，对所见的情形并不满意——他原本打算让大象按完全不同的顺序排列。因此，他强制执行了他所设想的顺序，声称这样动物看起来会最为庄严，并让员工按照他的意愿重新排列大象。由于移动大象群可能会造成混乱，员工决定通过一次交换一对大象的方式来重新排列它们。幸运的是，动物们不需要站在一起就可以交换位置。然而，让大象移动并不像听起来那么简单。实际上，所需的努力与动物的质量成正比。因此，交换质量分别为 $m_1$ 和 $m_2$ 的一对大象所需的努力可以估算为 $m_1+m_2$。重新排列大象以符合经理的意愿所需的最小努力是多少？\n\n编写一个程序：\n\n- 从标准输入读取动物园中所有大象的质量，以及它们当前和期望的排列顺序。\n- 确定一个大象交换序列，从初始顺序到期望的动物排列顺序，使得这个序列中的所有交换的总努力最小化。\n- 在标准输出上打印出总的最小努力。", "inputFormat": "标准输入的第一行包含一个整数 $n$ ($1 \\le n \\le 1{,}000{,}000$)，表示动物园中的大象数量。\n\n为了简化问题，我们假设大象的编号从 $1$ 到 $n$。\n\n第二行包含 $n$ 个整数 $m_i$ ($100 \\le m_i \\le 6{,}500$ 对于 $1 \\le i \\le n$)，用空格分隔，表示各个大象的质量（单位：千克）。\n\n输入的第三行包含 $n$ 个两两不同的整数 $a_i$ ($1 \\le a_i \\le n$)，用空格分隔，表示初始排列中连续大象的编号。\n\n第四行包含 $n$ 个两两不同的整数 $b_i$ ($1 \\le b_i \\le n$)，用空格分隔，表示动物园经理期望的排列中连续大象的编号。可以假设序列 $(a_i)$ 和 $(b_i)$ 是不同的。", "outputFormat": "标准输出的第一行应包含一个整数，表示将大象从序列 $(a_i)$ 表示的顺序重新排列到 $(b_i)$ 表示的顺序所需的最小总努力。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3483", "type": "P", "difficulty": 6, "samples": [["6 5 6 1\n1 2\n6 5\n5 1\n3 3\n3 4\n4 1\n2 3 4 3\n", "1 3 2\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2009", "树状数组", "POI（波兰）"], "title": "[POI 2009] STR-Fire Brigade", "background": "", "description": "In the capital of Byteotia, Bytau, the layout of streets is highly regular. Every street leads either from north to south, or from east to west. Therefore every north-south street intersects every east-west street in exactly one spot. Furthermore, along every street its successive intersections are exactly 1 km apart.\n\nBytau is not only the capital, but also one of the oldest cities in Byteotia. No wonder that there are as many as  historic buildings, each at one of the intersections. The City Council cares for their protection very much, and is now concerned with the risk of fire. Hence they have decided to establish two main fire stations in the city. Each monument is going to be protected by the nearest station; by both, should both fire stations be equally close.\n\nHousing is very dense in Bytau, so Euclidean distance is not the measure of choice. The distance between a monument and fire station should rather be defined as the length of the shortest path along the streets between them.\n\nThe City Council has prepared several projects of the stations' location. And you have been asked to determine, for each of them, the number of monuments protected by: the first station only, the second station only, and both stations, respectively.", "inputFormat": "In the first line of the standard input there are four integers $n$, $m$, $z$ and $p$ ($1\\le n,m\\le 1{,}000{,}000{,}000$, $1\\le z,p\\le 100{,}000$)      separated by single spaces and denoting respectively: the number of streets leading from north to south, the number of streets leading from east to west,      the number of historic buildings in Bytau, and the number of projects proposed by the City Council.\n\nThe north-south streets are numbered from $1$ to $n$, west to east. The east-west streets are numbered from $1$ to $m$, north to south. The intersection of $x$-th north-south and $y$-th east-west street will be denoted by the coordinates $(x,y)$.\n\nIn each of the following  lines there are two integers $x_i$ and $y_i$ ($1 ≤ xi ≤ n$, $1 ≤ yi ≤ m$) separated by a single space and denoting the coordinates of the i-th monument. No pair of different monuments is located at the same intersection.\n\nEach of the following $p$ lines contains one proposal of the City Council - four integers $x_{j,1}, y_{j,1}, x_{j,2}, y_{j,2}$ separated by single spaces, $1 ≤ x_{j,1},x_{j,2} ≤ n$, $1 ≤ y_{j,1},y_{j,2} ≤ m$, $(x_{j,1},y_{j,1})≠(x_{j,2},y_{j,2})$. The coordinates $(x_{j,1},y_{j,1})$ and $(x_{j,2},y_{j,2})$ describe the intersections at which the fire stations are to be located according to the $j$-th proposal $(1 ≤ j ≤ p)$.\n\n", "outputFormat": "Your programme should print out exactly $p$ lines on the standard output.\n\nThere should be three integers in the $j$-th line, denoting:\n\nthe number of monuments protected by the first station of $j$-th proposal of the City Council only, the number of monuments protected by the second      station only and the number of monuments protected by both stations, respectively.\n\nThese numbers should be separated by single spaces.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] STR-Fire Brigade", "background": "", "description": "In the capital of Byteotia, Bytau, the layout of streets is highly regular. Every street leads either from north to south, or from east to west. Therefore every north-south street intersects every east-west street in exactly one spot. Furthermore, along every street its successive intersections are exactly 1 km apart.\n\nBytau is not only the capital, but also one of the oldest cities in Byteotia. No wonder that there are as many as  historic buildings, each at one of the intersections. The City Council cares for their protection very much, and is now concerned with the risk of fire. Hence they have decided to establish two main fire stations in the city. Each monument is going to be protected by the nearest station; by both, should both fire stations be equally close.\n\nHousing is very dense in Bytau, so Euclidean distance is not the measure of choice. The distance between a monument and fire station should rather be defined as the length of the shortest path along the streets between them.\n\nThe City Council has prepared several projects of the stations' location. And you have been asked to determine, for each of them, the number of monuments protected by: the first station only, the second station only, and both stations, respectively.", "inputFormat": "In the first line of the standard input there are four integers $n$, $m$, $z$ and $p$ ($1\\le n,m\\le 1{,}000{,}000{,}000$, $1\\le z,p\\le 100{,}000$)      separated by single spaces and denoting respectively: the number of streets leading from north to south, the number of streets leading from east to west,      the number of historic buildings in Bytau, and the number of projects proposed by the City Council.\n\nThe north-south streets are numbered from $1$ to $n$, west to east. The east-west streets are numbered from $1$ to $m$, north to south. The intersection of $x$-th north-south and $y$-th east-west street will be denoted by the coordinates $(x,y)$.\n\nIn each of the following  lines there are two integers $x_i$ and $y_i$ ($1 ≤ xi ≤ n$, $1 ≤ yi ≤ m$) separated by a single space and denoting the coordinates of the i-th monument. No pair of different monuments is located at the same intersection.\n\nEach of the following $p$ lines contains one proposal of the City Council - four integers $x_{j,1}, y_{j,1}, x_{j,2}, y_{j,2}$ separated by single spaces, $1 ≤ x_{j,1},x_{j,2} ≤ n$, $1 ≤ y_{j,1},y_{j,2} ≤ m$, $(x_{j,1},y_{j,1})≠(x_{j,2},y_{j,2})$. The coordinates $(x_{j,1},y_{j,1})$ and $(x_{j,2},y_{j,2})$ describe the intersections at which the fire stations are to be located according to the $j$-th proposal $(1 ≤ j ≤ p)$.\n\n", "outputFormat": "Your programme should print out exactly $p$ lines on the standard output.\n\nThere should be three integers in the $j$-th line, denoting:\n\nthe number of monuments protected by the first station of $j$-th proposal of the City Council only, the number of monuments protected by the second      station only and the number of monuments protected by both stations, respectively.\n\nThese numbers should be separated by single spaces.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] STR-Fire Brigade", "background": "", "description": "在 Byteotia 的首都 Bytau，街道布局非常规则。每条街道要么从北到南，要么从东到西。因此，每一条南北街道与每一条东西街道正好在一个点相交。此外，沿着每条街道，其连续的交叉口之间的距离正好是 1 公里。\n\nBytau 不仅是首都，也是 Byteotia 最古老的城市之一。难怪这里有许多历史建筑，每个都位于一个交叉口。市议会非常重视它们的保护，现在担心火灾的风险。因此，他们决定在城市中建立两个主要的消防站。每个纪念碑将由最近的消防站保护；如果两个消防站距离相等，则由两个消防站共同保护。\n\nBytau 的住房非常密集，因此欧几里得距离不是首选的度量标准。纪念碑与消防站之间的距离应定义为沿街道之间的最短路径的长度。\n\n市议会已经准备了几个消防站位置的方案。现在要求你确定，对于每个方案，分别有多少纪念碑仅由第一个消防站保护，仅由第二个消防站保护，以及由两个消防站共同保护。", "inputFormat": "标准输入的第一行有四个整数 $n$、$m$、$z$ 和 $p$ ($1 \\le n,m \\le 1{,}000{,}000{,}000$, $1 \\le z,p \\le 100{,}000$)，用单个空格分隔，分别表示：从北到南的街道数量，从东到西的街道数量，Bytau 中的历史建筑数量，以及市议会提出的项目数量。\n\n南北街道从 $1$ 到 $n$ 编号，从西到东。东西街道从 $1$ 到 $m$ 编号，从北到南。第 $x$ 条南北街道和第 $y$ 条东西街道的交叉点将用坐标 $(x,y)$ 表示。\n\n在接下来的 $z$ 行中，每行有两个整数 $x_i$ 和 $y_i$ ($1 \\le x_i \\le n$, $1 \\le y_i \\le m$)，用单个空格分隔，表示第 $i$ 个纪念碑的坐标。没有两个不同的纪念碑位于同一个交叉口。\n\n接下来的 $p$ 行中的每一行包含市议会的一个提案 - 四个整数 $x_{j,1}, y_{j,1}, x_{j,2}, y_{j,2}$，用单个空格分隔，$1 \\le x_{j,1},x_{j,2} \\le n$, $1 \\le y_{j,1},y_{j,2} \\le m$, $(x_{j,1},y_{j,1}) \neq (x_{j,2},y_{j,2})$。坐标 $(x_{j,1},y_{j,1})$ 和 $(x_{j,2},y_{j,2})$ 描述了根据第 $j$ 个提案消防站要设置的位置 $(1 \\le j \\le p)$。", "outputFormat": "你的程序应在标准输出中打印出正好 $p$ 行。\n\n在第 $j$ 行中应该有三个整数，分别表示：\n\n仅由市议会第 $j$ 个提案的第一个消防站保护的纪念碑数量，仅由第二个消防站保护的纪念碑数量，以及由两个消防站共同保护的纪念碑数量。\n\n这些数字应以单个空格分隔。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3484", "type": "P", "difficulty": 5, "samples": [["2\nK adeccecced\nN 5\n", "5\nacedccecced addebcecced adebebecced adecbedcced cceccecce\n4\naedddde bdecdde bececde ccedcde\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "POI（波兰）"], "title": "[POI 2009] WYS-Isles in a Triangular Grid", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/kjilqzz8.png)\n\nThe shapes in the figures 1.1, 1.2 and 1.3 are isles. The shape in the figure 1.4 is not an isle. The shapes in the figures 2.2, 2.3 and 2.5 are congruent.\n\nWe aim at obtaining a systematic description, for each n ≤ 10, of all non-congruent isles that can be formed by n triangles with side length 1, and calculating how many such isles there are.\n\nThe boundary of every isle formed by at most ten triangles is a polygonal chain consisting of unitary segments of the grid. It can be revolved about, i.e. it can be contoured without detaching pencil from the sheet, in such a way that its every segment is followed once, and we come back to the initial point. It may happen though that some point has to be crossed more than once (see Figure 2.4).\n\nLuckily, in case of isles formed by at most ten triangles the shape's perimeter is connected (and can be thus contoured without detaching pencil from the sheet), unlike the one in Figure 1.2.\n\nWhile circling around the perimeter, after each unit segment we make a turn of either of the following types:\n\n- a - 120 degrees left,\n- b - 60 degrees left,\n- c - 0 degrees (i.e. no turn, actually),\n- d - 60 degrees right,\n- e - 120 degrees right.\n\nEach cycle around the isle can be described by a word consisting of letters from the set {a,b,c,d,e}, where each letter tells which turn should be made after each successive unit segment the perimeter consists of. The cycle description has as many letters as there are such unit segments. This means we also describe the turn after the last segment of the polygonal chain, even though it is not required to uniquely determine the shape. This redundant letter is, however, very helpful in transforming one description of a cycle around the shape to another one that differs only in the initial point.\n\nThe words cdddcddd, dcdddcdd, cbbbcbbb describe different cycles around the shape of the Figure 2.1.\n\nThe words cbeddcde, adcabcbb, abcbbadc describe different cycles around the shape of the Figure 2.2.\n\nThe words acdabbcb i cddebced describe different cycles around the shape of the Figure 2.3.\n\nIf the inside of the shape is constantly on right hand side during a cycle around some shape, we call such cycle a clockwise cycle.\n\nOne can determine, for each isle, the set of all isles congruent with it and these isles' clockwise cycles. The code of an isle is such a word that:\n\n1. it is a description of a clockwise cycle around the contour of some isle congruent with the latter,\n2. it is the lexicographically smallest of all words satisfying the previous condition.\n\nFor the isle depicted in Figures 2.2 and 2.3, which are congruent, we take into account all clockwise cycles around each of them:\n\n    beddcdec, eddcdecb, ddcdecbe, dcdecbed, cdecbedd, decbeddc, ecbeddcd, cbeddcde\n\nand\n\n    bcedcdde, cedcddeb, edcddebc, dcddebce, cddebced, ddebcedc, debcedcd, ebcedcdd\n\nso their common code is: bcedcdde, the lexicographically smallest of all the words above.\n\nThe code of the isle depicted in Figure 2.4 is: aadecddcddde.\n\nWrite a programme that:\n\nfor a given code of an isle of size k generates the codes of all isles of size k+1 that can be obtained from the latter by adding one triangle to it,\nfor a given integer n generates the codes of all isles of size n.", "inputFormat": "In the first line of the standard input an integer t (1 ≤ t ≤ 5), denoting the number of queries, is given. Each of the following t lines contains a query of some type. The query of type 1 consists of the letter K and a code of an isle formed by at most ten triangles, separated by a single space. The query of type 2 consists of the letter N and an integer n (1 ≤ n ≤ 10), separated by a single space.", "outputFormat": "The answers to the queries should be printed out to the standard output.\n\nFor queries of type 1 the number of distinct codes of isles that can be obtained by adding one triangle from isles congruent to the one described by the given code. In the following line all these codes, separated by single spaces, should be printed in lexicographic order.\n\nFor queries of type 2 the number of distinct codes of isles formed by n triangles should be printed. In the following line all these codes should be printed in lexicographic order.", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] WYS-Isles in a Triangular Grid", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/kjilqzz8.png)\n\nThe shapes in the figures 1.1, 1.2 and 1.3 are isles. The shape in the figure 1.4 is not an isle. The shapes in the figures 2.2, 2.3 and 2.5 are congruent.\n\nWe aim at obtaining a systematic description, for each n ≤ 10, of all non-congruent isles that can be formed by n triangles with side length 1, and calculating how many such isles there are.\n\nThe boundary of every isle formed by at most ten triangles is a polygonal chain consisting of unitary segments of the grid. It can be revolved about, i.e. it can be contoured without detaching pencil from the sheet, in such a way that its every segment is followed once, and we come back to the initial point. It may happen though that some point has to be crossed more than once (see Figure 2.4).\n\nLuckily, in case of isles formed by at most ten triangles the shape's perimeter is connected (and can be thus contoured without detaching pencil from the sheet), unlike the one in Figure 1.2.\n\nWhile circling around the perimeter, after each unit segment we make a turn of either of the following types:\n\n- a - 120 degrees left,\n- b - 60 degrees left,\n- c - 0 degrees (i.e. no turn, actually),\n- d - 60 degrees right,\n- e - 120 degrees right.\n\nEach cycle around the isle can be described by a word consisting of letters from the set {a,b,c,d,e}, where each letter tells which turn should be made after each successive unit segment the perimeter consists of. The cycle description has as many letters as there are such unit segments. This means we also describe the turn after the last segment of the polygonal chain, even though it is not required to uniquely determine the shape. This redundant letter is, however, very helpful in transforming one description of a cycle around the shape to another one that differs only in the initial point.\n\nThe words cdddcddd, dcdddcdd, cbbbcbbb describe different cycles around the shape of the Figure 2.1.\n\nThe words cbeddcde, adcabcbb, abcbbadc describe different cycles around the shape of the Figure 2.2.\n\nThe words acdabbcb i cddebced describe different cycles around the shape of the Figure 2.3.\n\nIf the inside of the shape is constantly on right hand side during a cycle around some shape, we call such cycle a clockwise cycle.\n\nOne can determine, for each isle, the set of all isles congruent with it and these isles' clockwise cycles. The code of an isle is such a word that:\n\n1. it is a description of a clockwise cycle around the contour of some isle congruent with the latter,\n2. it is the lexicographically smallest of all words satisfying the previous condition.\n\nFor the isle depicted in Figures 2.2 and 2.3, which are congruent, we take into account all clockwise cycles around each of them:\n\n    beddcdec, eddcdecb, ddcdecbe, dcdecbed, cdecbedd, decbeddc, ecbeddcd, cbeddcde\n\nand\n\n    bcedcdde, cedcddeb, edcddebc, dcddebce, cddebced, ddebcedc, debcedcd, ebcedcdd\n\nso their common code is: bcedcdde, the lexicographically smallest of all the words above.\n\nThe code of the isle depicted in Figure 2.4 is: aadecddcddde.\n\nWrite a programme that:\n\nfor a given code of an isle of size k generates the codes of all isles of size k+1 that can be obtained from the latter by adding one triangle to it,\nfor a given integer n generates the codes of all isles of size n.", "inputFormat": "In the first line of the standard input an integer t (1 ≤ t ≤ 5), denoting the number of queries, is given. Each of the following t lines contains a query of some type. The query of type 1 consists of the letter K and a code of an isle formed by at most ten triangles, separated by a single space. The query of type 2 consists of the letter N and an integer n (1 ≤ n ≤ 10), separated by a single space.", "outputFormat": "The answers to the queries should be printed out to the standard output.\n\nFor queries of type 1 the number of distinct codes of isles that can be obtained by adding one triangle from isles congruent to the one described by the given code. In the following line all these codes, separated by single spaces, should be printed in lexicographic order.\n\nFor queries of type 2 the number of distinct codes of isles formed by n triangles should be printed. In the following line all these codes should be printed in lexicographic order.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] WYS-Isles in a Triangular Grid", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/image_hosting/kjilqzz8.png)\n\n图 1.1、1.2 和 1.3 中的形状是岛屿。图 1.4 中的形状不是岛屿。图 2.2、2.3 和 2.5 中的形状是全等的。\n\n我们的目标是系统地描述每个 $n \\leq 10$ 的所有不全等的岛屿，这些岛屿可以由边长为 1 的 $n$ 个三角形组成，并计算出这样的岛屿有多少个。\n\n由最多十个三角形组成的每个岛屿的边界是由网格的单位线段组成的多边形链。它可以旋转，即可以在不将笔从纸上抬起的情况下进行轮廓描绘，使得每个线段都被依次经过一次，并回到起始点。然而，可能会出现某些点必须多次经过的情况（见图 2.4）。\n\n幸运的是，由最多十个三角形组成的岛屿的形状的周长是连通的（因此可以在不将笔从纸上抬起的情况下进行轮廓描绘），不像图 1.2 中的那样。\n\n在围绕周长旋转时，每经过一个单位线段，我们会进行以下类型的转向之一：\n\n- a - 向左 120 度，\n- b - 向左 60 度，\n- c - 0 度（即实际上不转向），\n- d - 向右 60 度，\n- e - 向右 120 度。\n\n围绕岛屿的每个循环可以用一个由集合 {a,b,c,d,e} 中的字母组成的单词来描述，其中每个字母表示在组成周长的每个连续单位线段之后应进行的转向。循环描述的字母数量与这样的单位线段数量相同。这意味着我们也描述了多边形链最后一个线段之后的转向，即使这不是唯一确定形状所必需的。然而，这个冗余的字母在将一个形状的循环描述转换为仅在起始点不同的另一个描述时非常有用。\n\n单词 cdddcddd、dcdddcdd、cbbbcbbb 描述了图 2.1 形状的不同循环。\n\n单词 cbeddcde、adcabcbb、abcbbadc 描述了图 2.2 形状的不同循环。\n\n单词 acdabbcb 和 cddebced 描述了图 2.3 形状的不同循环。\n\n如果在围绕某个形状的循环中形状的内部始终在右手边，我们称这样的循环为顺时针循环。\n\n可以确定每个岛屿的所有与之全等的岛屿及其顺时针循环的集合。岛屿的代码是这样的一个单词：\n\n1. 它是围绕与后者全等的某个岛屿的轮廓的顺时针循环的描述，\n2. 在满足上述条件的所有单词中，它是字典序最小的。\n\n对于图 2.2 和 2.3 中描绘的岛屿，它们是全等的，我们考虑围绕每个岛屿的所有顺时针循环：\n\n    beddcdec, eddcdecb, ddcdecbe, dcdecbed, cdecbedd, decbeddc, ecbeddcd, cbeddcde\n\n和\n\n    bcedcdde, cedcddeb, edcddebc, dcddebce, cddebced, ddebcedc, debcedcd, ebcedcdd\n\n因此它们的公共代码是：bcedcdde，这是上述所有单词中字典序最小的。\n\n图 2.4 中描绘的岛屿的代码是：aadecddcddde。\n\n编写一个程序：\n\n对于给定的大小为 $k$ 的岛屿代码，生成通过在其上添加一个三角形可以从中获得的所有大小为 $k+1$ 的岛屿的代码；\n对于给定的整数 $n$，生成由 $n$ 个三角形组成的所有岛屿的代码。", "inputFormat": "标准输入的第一行给出一个整数 $t$（$1 \\leq t \\leq 5$），表示查询的数量。接下来的 $t$ 行中的每一行包含一个某种类型的查询。类型 1 的查询由字母 K 和一个由最多十个三角形组成的岛屿的代码组成，中间用一个空格分隔。类型 2 的查询由字母 N 和一个整数 $n$（$1 \\leq n \\leq 10$）组成，中间用一个空格分隔。", "outputFormat": "查询的答案应输出到标准输出。\n\n对于类型 1 的查询，可以通过从与给定代码描述的岛屿全等的岛屿中添加一个三角形获得的不同代码的数量。在下一行中，所有这些代码应按字典序排列并用空格分隔。\n\n对于类型 2 的查询，应打印由 $n$ 个三角形组成的不同岛屿代码的数量。在下一行中，所有这些代码应按字典序排列。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3485", "type": "P", "difficulty": 6, "samples": [["6 7\n1 2 a\n1 3 x\n1 4 b\n2 6 l\n3 5 y\n4 5 z\n6 5 a\n3\n1 5 3\n", "3 ala\n-1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2009", "POI（波兰）", "Special Judge", "广度优先搜索 BFS"], "title": "[POI 2009] BAJ-The Walk of Bytie-boy", "background": "[English Edition](/paste/9lmt83m9)", "description": "给出一张 $n$ 个点 $m$ 条边的有向图，每条边上有一个字母，并给出一个整数 $d$ 和一个序列 $s_1, s_2, \\dots, s_d$。  \n\n你需要对每一个 $i(1\\le i<n)$ 求出一条从 $s_i$ 到 $s_{i+1}$ 的最短路径满足这条路径上的边上的字母连起来后是回文的。  \n\n不保证每个点最多只在 $s$ 中出现一次。", "inputFormat": "第一行两个整数 $n, m$。\n\n之后 $m$ 行，每行两个整数 $x_i, y_i$ 与一个字母 $c_i$，表示有一条从 $x_i$ 到 $y_i$ 的边，这条边上的字母是 $c_i$。\n\n之后一行一个整数 $d$。\n\n之后一行 $d$ 个整数， 表示序列 $s$。", "outputFormat": "输出共 $d-1$ 行，第 $i$ 行输出一条从 $s_i$ 到 $s_{i+1}$ 的满足条件的路径。  \n\n若不存在这样的路径，则输出 `-1`，否则输出这条路径上的所有字母。  \n\n如果有多条满足条件的路径，任意输出一条即可。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 400$，$1\\le m\\le 6\\times10^4$，$1\\le x_i,y_i\\le n$，$2\\le d\\le100$，$1\\le s_i\\le n$。\n\n同时保证不会出现重边与自环。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2009] BAJ-The Walk of Bytie-boy", "background": "[English Edition](/paste/9lmt83m9)", "description": "You are given a directed graph with $n$ vertices and $m$ edges. Each edge has a letter on it. You are also given an integer $d$ and a sequence $s_1, s_2, \\dots, s_d$.\n\nFor each $i$ ($1 \\le i < d$), you need to find a shortest path from $s_i$ to $s_{i+1}$ such that the letters on the edges of this path, concatenated in order, form a palindrome.\n\nIt is not guaranteed that each vertex appears at most once in $s$.", "inputFormat": "The first line contains two integers $n, m$.\n\nThen follow $m$ lines. Each line contains two integers $x_i, y_i$ and a letter $c_i$, indicating there is a directed edge from $x_i$ to $y_i$, and the letter on this edge is $c_i$.\n\nThe next line contains an integer $d$.\n\nThe last line contains $d$ integers, giving the sequence $s$.", "outputFormat": "Output $d-1$ lines. On the $i$-th line, output a path from $s_i$ to $s_{i+1}$ that satisfies the condition.\n\nIf no such path exists, output `-1`; otherwise, output all letters on this path.\n\nIf there are multiple valid paths, output any one of them.", "hint": "For $100\\%$ of the testdata, $2 \\le n \\le 400$, $1 \\le m \\le 6\\times 10^4$, $1 \\le x_i, y_i \\le n$, $2 \\le d \\le 100$, $1 \\le s_i \\le n$.\n\nIt is also guaranteed that there are no multiple edges or self-loops.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2009] BAJ-The Walk of Bytie-boy", "background": "[English Edition](/paste/9lmt83m9)", "description": "给出一张 $n$ 个点 $m$ 条边的有向图，每条边上有一个字母，并给出一个整数 $d$ 和一个序列 $s_1, s_2, \\dots, s_d$。  \n\n你需要对每一个 $i(1\\le i<n)$ 求出一条从 $s_i$ 到 $s_{i+1}$ 的最短路径满足这条路径上的边上的字母连起来后是回文的。  \n\n不保证每个点最多只在 $s$ 中出现一次。", "inputFormat": "第一行两个整数 $n, m$。\n\n之后 $m$ 行，每行两个整数 $x_i, y_i$ 与一个字母 $c_i$，表示有一条从 $x_i$ 到 $y_i$ 的边，这条边上的字母是 $c_i$。\n\n之后一行一个整数 $d$。\n\n之后一行 $d$ 个整数， 表示序列 $s$。", "outputFormat": "输出共 $d-1$ 行，第 $i$ 行输出一条从 $s_i$ 到 $s_{i+1}$ 的满足条件的路径。  \n\n若不存在这样的路径，则输出 `-1`，否则输出这条路径上的所有字母。  \n\n如果有多条满足条件的路径，任意输出一条即可。", "hint": "对于 $100\\%$ 的数据，$2\\le n\\le 400$，$1\\le m\\le 6\\times10^4$，$1\\le x_i,y_i\\le n$，$2\\le d\\le100$，$1\\le s_i\\le n$。\n\n同时保证不会出现重边与自环。", "locale": "zh-CN"}}}
{"pid": "P3486", "type": "P", "difficulty": 5, "samples": [["7 2\n2 1 8 2 1 0\n3 5 1 0 1\n3 1 2 2\n3 5 6\n3 2\n1\n", "2 5\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "POI（波兰）"], "title": "[POI 2009] KON-Ticket Inspector", "background": "", "description": "Byteasar works as a ticket inspector in a Byteotian National Railways (BNR)    express train that connects Byteburg with Bitwise.\n\nThe third stage of the BNR reform (The never ending saga of BNR reforms and the Bitwise hub was presented in the problems Railway from the third stage of XIV Polish OI and Station from the third stage of XV Polish OI. Their knowledge, however, is not required at all in order to solve this        problem.) has begun. In particular, the salaries system has already been changed.\n\nFor example, to encourage Byteasar and other ticket inspectors to efficient work, their salaries now depend on the number of tickets (passengers) they    inspect. Byteasar is able to control all the passengers on the train in the time between two successive stations, but he is not eager to waste his energy in doing so. Eventually he decided he would check the tickets exactly $k$ times per ride.\n\nBefore setting out, Byteasar is given a detailed summary from which he knows    exactly how many passengers will travel from each station to another. Based    on that he would like to choose the moments of control in such a way that    the number of passengers checked is maximal. Obviously, Byteasar is not    paid extra for checking someone multiple times - that would be pointless,    and would only disturb the passengers. Write a programme that will determine    for Byteasar when he should check the tickets in order to maximise his    revenue.\n", "inputFormat": "In the first line of the standard input two positive integers $n$ and $k$ ($1 ≤ k < n ≤ 600$, $k ≤ 50$) are given. These are separated by a single space and denote, respectively, the number of stations en route and the number of controls Byteasar intends to make. The stations are numbered from $1$ to $n$ in the order of appearance on the route.\n\nIn the next $n-1$ lines the summary on passengers is given. The $(i+1)$-th line contains information on the passengers who enter the train on the station $i$ - it is a sequence of $n-i$ nonnegative integers $x_{i,i+1},x_{i,i+2},…,x_{i,n}$ separated by single spaces. The number $x_{i,j}$ (for $1 ≤ i < j ≤ n$) denotes the number of passengers who enter the train on station $i$ and leave it on station $j$. The total number of passengers (i.e. the sum of all $x_{i,j}$) does not exceed $2{,}000{,}000{,}000$.", "outputFormat": "Your programme should print out (in a single line) an increasing sequence of $k$ integers from the interval from $1$ to $n-1$ separated by single spaces to the standard output. These numbers should be the numbers of stations upon leaving which Byteasar should control the tickets.", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] KON-Ticket Inspector", "background": "", "description": "Byteasar works as a ticket inspector in a Byteotian National Railways (BNR)    express train that connects Byteburg with Bitwise.\n\nThe third stage of the BNR reform (The never ending saga of BNR reforms and the Bitwise hub was presented in the problems Railway from the third stage of XIV Polish OI and Station from the third stage of XV Polish OI. Their knowledge, however, is not required at all in order to solve this        problem.) has begun. In particular, the salaries system has already been changed.\n\nFor example, to encourage Byteasar and other ticket inspectors to efficient work, their salaries now depend on the number of tickets (passengers) they    inspect. Byteasar is able to control all the passengers on the train in the time between two successive stations, but he is not eager to waste his energy in doing so. Eventually he decided he would check the tickets exactly $k$ times per ride.\n\nBefore setting out, Byteasar is given a detailed summary from which he knows    exactly how many passengers will travel from each station to another. Based    on that he would like to choose the moments of control in such a way that    the number of passengers checked is maximal. Obviously, Byteasar is not    paid extra for checking someone multiple times - that would be pointless,    and would only disturb the passengers. Write a programme that will determine    for Byteasar when he should check the tickets in order to maximise his    revenue.\n", "inputFormat": "In the first line of the standard input two positive integers $n$ and $k$ ($1 ≤ k < n ≤ 600$, $k ≤ 50$) are given. These are separated by a single space and denote, respectively, the number of stations en route and the number of controls Byteasar intends to make. The stations are numbered from $1$ to $n$ in the order of appearance on the route.\n\nIn the next $n-1$ lines the summary on passengers is given. The $(i+1)$-th line contains information on the passengers who enter the train on the station $i$ - it is a sequence of $n-i$ nonnegative integers $x_{i,i+1},x_{i,i+2},…,x_{i,n}$ separated by single spaces. The number $x_{i,j}$ (for $1 ≤ i < j ≤ n$) denotes the number of passengers who enter the train on station $i$ and leave it on station $j$. The total number of passengers (i.e. the sum of all $x_{i,j}$) does not exceed $2{,}000{,}000{,}000$.", "outputFormat": "Your programme should print out (in a single line) an increasing sequence of $k$ integers from the interval from $1$ to $n-1$ separated by single spaces to the standard output. These numbers should be the numbers of stations upon leaving which Byteasar should control the tickets.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] KON-Ticket Inspector", "background": "", "description": "有 $n$ 个车站，现在有一辆火车从 $1$ 到 $n$ 驶过，给出 $a_{i,j}$ 代表从 $i$ 站上车 $j$ 站下车的人的个数。列车行驶过程中你有 $K$ 次检票机会，所有当前在车上的人会被检票，问最多能检多少个不同的人的票。", "inputFormat": "第一行正整数 $N,K$，$1≤K＜N≤600$，$K≤50$。接下来 $N-1$ 行，第 $i$ 行第 $j$ 个数描述第 $i$ 站上，到第 $i+j$ 站下的乘客个数。总乘客数 $≤2\\times 10^9$。", "outputFormat": "单调增的 $K$ 个整数，用空格隔开，表示经过哪些站以后查票。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3487", "type": "P", "difficulty": 5, "samples": [["3\n12 5 8 3 15 8 0", "12\n15\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "单调队列", "POI（波兰）"], "title": "[POI 2009] ARC-Architects", "background": "", "description": "给定一个序列 $a_i$（$1\\leq a_i\\leq 10^9$）且 $1\\leq i\\le n$ 且 $n\\leq  \n 1.5\\times 10^7$，和一个整数 $k$（$k\\leq n$ 且 $k\\leq 10^6$），求出 $a$ 的一个长度为 $k$ 的子序列 $a_{b_i}$ 满足：\n\n1. $1\\leq b_1\\leq b_2\\leq \\ldots\\leq b_k$\n2. 在满足 $1$ 的情况下 $a_{b_1}, a_{b_2},\\ldots , a_{b_k}$ 字典序最大。\n", "inputFormat": "第一行一个数 $k$，以下一行，为序列 $a_i$。以一个单独的 $0$ 结束。\n", "outputFormat": "$k$ 行，每行一个数，其中第 $i$ 行为 $a_{b_i}$。\n", "hint": "本题原为交互题，为评测方便，需要将下面的代码粘贴到文件中。\n\n将第一次输入改为 `=inicjuj()` 形式，将之后的每一次输入改为 `=wczytaj()` 形式，将输出改为 `wypisz(jakoscProjektu)` 形式（`jakoscProjektu` 代表你输出的数）。\n\n```cpp\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\n#define MAGIC_BEGIN -435634223\n#define MAGIC_END -324556462\n\n#define MIN_K 1\n#define MAX_K 1000000\n#define MAX_N 15000000\n#define MIN_A 1\n#define MAX_A 1000000000\n#define MIN_TYP 1\n#define MAX_TYP 3\n#define MIN_PAR 0\n#define MAX_PAR 1000000000\n\n#define ERROR 0\n#define CORRECT 1\n\n#define unlikely(x) __builtin_expect(!!(x), 0)\n\nstatic int init = 0; // czy zostala juz wywolana funkcja inicjuj()\nstatic int lib_n; // ile biblioteka podala juz liczb\nstatic int con_k; // ile zawodnik podal liczb\n\nstatic int N, K, A, TYP, PAR; // parametry testu wczytywane z pliku\nstatic int bre, len_sub, bou, is_end; // zmienne pomocnicze\n\nstatic int rand2_status = 198402041;\n\nstatic inline int rand2(int a, int b){\n  rand2_status = rand2_status * 1103515245ll + 12345;\n  int x = rand2_status;\n  if (x < 0) x = -x; // -2^31 sie nie zdarza :D\n  x >>= 1;\n  x = a + x % (b - a + 1);\n  return x;\n}\n\n/* test losowy */\nstatic inline int random_test()\n{\n    return rand2(1, A);\n}\n\n/* test z dlugim podciagiem nierosnacym */\nstatic inline int decreasing_test()\n{\n    int tmp;\n    if(bre == 0) {\n        bre = rand2(0, (N - lib_n + 1 - len_sub));\n        tmp = A;\n        A -= rand2(0, (A - 1) / len_sub);\n        len_sub--;\n    }\n    else {\n        bre--;\n        tmp = rand2(1, A);\n    }\n    return tmp;\n}\n\n/* test z dlugim podciagiem niemalejacym */\nstatic inline int increasing_test()\n{\n    return bou - decreasing_test();\n}\n\nstatic void finish(int res, const char com[])\n{\n    if(res == ERROR)\n        printf(\"%s\\n\", com);\n    exit(0);\n}\n\n/* Inicjuje dane wejsciowe i zwraca liczbe projektow */\nint inicjuj()\n{\n    if(init == 1)\n        finish(ERROR, \"Program zawodnika moze wywolac funkcje inicjuj tylko raz!!!\");\n    init = 1;\n    scanf(\"%d\", &K);\n    if (K > 0){\n      TYP = 0;\n      N = MAX_N + 2;\n      return K;\n    }\n    int magic_begin, magic_end;\n    scanf(\"%d%d\", &magic_begin, &TYP);\n    if(magic_begin != MAGIC_BEGIN || TYP < MIN_TYP || TYP > MAX_TYP)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    scanf(\"%d%d%d%d\", &N, &K, &A, &PAR);\n    if(N < 1 || N > MAX_N || N < K || K > MAX_K || A < MIN_A || A > MAX_A \n        || PAR < MIN_PAR || PAR > MAX_PAR)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    scanf(\"%d\", &magic_end);\n    if(magic_end != MAGIC_END)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    con_k = 0;\n    lib_n = 0;\n    is_end = 0;\n    if(TYP == 2 || TYP == 3) {\n        len_sub = PAR;\n        bre = 0;\n    }\n    if(TYP == 2)\n        bou = A--;\n    return K;\n}\n\n/* Sluzy do wczytania ciagu reprezentujacego jakosci projektow */\nint wczytaj()\n{\n    if(unlikely(init == 0))\n        finish(ERROR, \"Program zawodnika nie wywolal funkcji inicjuj!!!\");\n    if(unlikely(lib_n > N || is_end == 1))\n        finish(ERROR, \"Program zawodnika wywolal funkcje wczytaj po otrzymaniu informacji o koncu ciagu!!!\");\n    if(unlikely(lib_n == N))\n        return 0;\n    lib_n++;\n    switch (TYP) {\n      case 0:\n        scanf(\"%d\", &A);\n        if(A == 0)\n          is_end = 1;\n        return A;\n        break;\n      case 1: return random_test(); break;\n      case 2: return increasing_test(); break;\n      case 3: return decreasing_test(); break;\n      default:\n              finish(ERROR, \"Nieznany typ testu\");\n    }\n    return -1;\n}\n\n/* Sluzy do wypisania wyznaczonego podciagu */\nvoid wypisz(int jakoscProjektu)\n{\n    if(init == 0)\n        finish(ERROR, \"Program zawodnika nie wywolal funkcji inicjuj!!!\");\n    printf(\"%d\\n\", jakoscProjektu);\n    if(++con_k == K)\n        finish(CORRECT, \"\");\n}\n```", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2009] ARC-Architects", "background": "", "description": "Given a sequence $a_i$ ($1 \\le a_i \\le 10^9$) for $1 \\le i \\le n$ with $n \\le 1.5 \\times 10^7$, and an integer $k$ ($k \\le n$ and $k \\le 10^6$), find a subsequence of $a$ of length $k$, denoted $a_{b_i}$, such that:\n\n1. $1 \\le b_1 \\le b_2 \\le \\ldots \\le b_k$.\n2. Subject to 1, the sequence $a_{b_1}, a_{b_2}, \\ldots, a_{b_k}$ is lexicographically maximum.", "inputFormat": "The first line contains a number $k$. The next line contains the sequence $a_i$. The input ends with a single $0$.", "outputFormat": "Output $k$ lines, one number per line. The $i$-th line should be $a_{b_i}$.", "hint": "This problem was originally interactive. For evaluation convenience, paste the following code into your file.\n\nReplace the first input with a call to `inicjuj()`, replace each subsequent input with a call to `wczytaj()`, and replace your output with `wypisz(jakoscProjektu)` (where `jakoscProjektu` is the number you output).\n\n```cpp\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\n#define MAGIC_BEGIN -435634223\n#define MAGIC_END -324556462\n\n#define MIN_K 1\n#define MAX_K 1000000\n#define MAX_N 15000000\n#define MIN_A 1\n#define MAX_A 1000000000\n#define MIN_TYP 1\n#define MAX_TYP 3\n#define MIN_PAR 0\n#define MAX_PAR 1000000000\n\n#define ERROR 0\n#define CORRECT 1\n\n#define unlikely(x) __builtin_expect(!!(x), 0)\n\nstatic int init = 0; // czy zostala juz wywolana funkcja inicjuj()\nstatic int lib_n; // ile biblioteka podala juz liczb\nstatic int con_k; // ile zawodnik podal liczb\n\nstatic int N, K, A, TYP, PAR; // parametry testu wczytywane z pliku\nstatic int bre, len_sub, bou, is_end; // zmienne pomocnicze\n\nstatic int rand2_status = 198402041;\n\nstatic inline int rand2(int a, int b){\n  rand2_status = rand2_status * 1103515245ll + 12345;\n  int x = rand2_status;\n  if (x < 0) x = -x; // -2^31 sie nie zdarza :D\n  x >>= 1;\n  x = a + x % (b - a + 1);\n  return x;\n}\n\n/* test losowy */\nstatic inline int random_test()\n{\n    return rand2(1, A);\n}\n\n/* test z dlugim podciagiem nierosnacym */\nstatic inline int decreasing_test()\n{\n    int tmp;\n    if(bre == 0) {\n        bre = rand2(0, (N - lib_n + 1 - len_sub));\n        tmp = A;\n        A -= rand2(0, (A - 1) / len_sub);\n        len_sub--;\n    }\n    else {\n        bre--;\n        tmp = rand2(1, A);\n    }\n    return tmp;\n}\n\n/* test z dlugim podciagiem niemalejacym */\nstatic inline int increasing_test()\n{\n    return bou - decreasing_test();\n}\n\nstatic void finish(int res, const char com[])\n{\n    if(res == ERROR)\n        printf(\"%s\\n\", com);\n    exit(0);\n}\n\n/* Inicjuje dane wejsciowe i zwraca liczbe projektow */\nint inicjuj()\n{\n    if(init == 1)\n        finish(ERROR, \"Program zawodnika moze wywolac funkcje inicjuj tylko raz!!!\");\n    init = 1;\n    scanf(\"%d\", &K);\n    if (K > 0){\n      TYP = 0;\n      N = MAX_N + 2;\n      return K;\n    }\n    int magic_begin, magic_end;\n    scanf(\"%d%d\", &magic_begin, &TYP);\n    if(magic_begin != MAGIC_BEGIN || TYP < MIN_TYP || TYP > MAX_TYP)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    scanf(\"%d%d%d%d\", &N, &K, &A, &PAR);\n    if(N < 1 || N > MAX_N || N < K || K > MAX_K || A < MIN_A || A > MAX_A \n        || PAR < MIN_PAR || PAR > MAX_PAR)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    scanf(\"%d\", &magic_end);\n    if(magic_end != MAGIC_END)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    con_k = 0;\n    lib_n = 0;\n    is_end = 0;\n    if(TYP == 2 || TYP == 3) {\n        len_sub = PAR;\n        bre = 0;\n    }\n    if(TYP == 2)\n        bou = A--;\n    return K;\n}\n\n/* Sluzy do wczytania ciagu reprezentujacego jakosci projektow */\nint wczytaj()\n{\n    if(unlikely(init == 0))\n        finish(ERROR, \"Program zawodnika nie wywolal funkcji inicjuj!!!\");\n    if(unlikely(lib_n > N || is_end == 1))\n        finish(ERROR, \"Program zawodnika wywolal funkcje wczytaj po otrzymaniu informacji o koncu ciagu!!!\");\n    if(unlikely(lib_n == N))\n        return 0;\n    lib_n++;\n    switch (TYP) {\n      case 0:\n        scanf(\"%d\", &A);\n        if(A == 0)\n          is_end = 1;\n        return A;\n        break;\n      case 1: return random_test(); break;\n      case 2: return increasing_test(); break;\n      case 3: return decreasing_test(); break;\n      default:\n              finish(ERROR, \"Nieznany typ testu\");\n    }\n    return -1;\n}\n\n/* Sluzy do wypisania wyznaczonego podciagu */\nvoid wypisz(int jakoscProjektu)\n{\n    if(init == 0)\n        finish(ERROR, \"Program zawodnika nie wywolal funkcji inicjuj!!!\");\n    printf(\"%d\\n\", jakoscProjektu);\n    if(++con_k == K)\n        finish(CORRECT, \"\");\n}\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2009] ARC-Architects", "background": "", "description": "给定一个序列 $a_i$（$1\\leq a_i\\leq 10^9$）且 $1\\leq i\\le n$ 且 $n\\leq  \n 1.5\\times 10^7$，和一个整数 $k$（$k\\leq n$ 且 $k\\leq 10^6$），求出 $a$ 的一个长度为 $k$ 的子序列 $a_{b_i}$ 满足：\n\n1. $1\\leq b_1\\leq b_2\\leq \\ldots\\leq b_k$\n2. 在满足 $1$ 的情况下 $a_{b_1}, a_{b_2},\\ldots , a_{b_k}$ 字典序最大。\n", "inputFormat": "第一行一个数 $k$，以下一行，为序列 $a_i$。以一个单独的 $0$ 结束。\n", "outputFormat": "$k$ 行，每行一个数，其中第 $i$ 行为 $a_{b_i}$。\n", "hint": "本题原为交互题，为评测方便，需要将下面的代码粘贴到文件中。\n\n将第一次输入改为 `=inicjuj()` 形式，将之后的每一次输入改为 `=wczytaj()` 形式，将输出改为 `wypisz(jakoscProjektu)` 形式（`jakoscProjektu` 代表你输出的数）。\n\n```cpp\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n\n#define MAGIC_BEGIN -435634223\n#define MAGIC_END -324556462\n\n#define MIN_K 1\n#define MAX_K 1000000\n#define MAX_N 15000000\n#define MIN_A 1\n#define MAX_A 1000000000\n#define MIN_TYP 1\n#define MAX_TYP 3\n#define MIN_PAR 0\n#define MAX_PAR 1000000000\n\n#define ERROR 0\n#define CORRECT 1\n\n#define unlikely(x) __builtin_expect(!!(x), 0)\n\nstatic int init = 0; // czy zostala juz wywolana funkcja inicjuj()\nstatic int lib_n; // ile biblioteka podala juz liczb\nstatic int con_k; // ile zawodnik podal liczb\n\nstatic int N, K, A, TYP, PAR; // parametry testu wczytywane z pliku\nstatic int bre, len_sub, bou, is_end; // zmienne pomocnicze\n\nstatic int rand2_status = 198402041;\n\nstatic inline int rand2(int a, int b){\n  rand2_status = rand2_status * 1103515245ll + 12345;\n  int x = rand2_status;\n  if (x < 0) x = -x; // -2^31 sie nie zdarza :D\n  x >>= 1;\n  x = a + x % (b - a + 1);\n  return x;\n}\n\n/* test losowy */\nstatic inline int random_test()\n{\n    return rand2(1, A);\n}\n\n/* test z dlugim podciagiem nierosnacym */\nstatic inline int decreasing_test()\n{\n    int tmp;\n    if(bre == 0) {\n        bre = rand2(0, (N - lib_n + 1 - len_sub));\n        tmp = A;\n        A -= rand2(0, (A - 1) / len_sub);\n        len_sub--;\n    }\n    else {\n        bre--;\n        tmp = rand2(1, A);\n    }\n    return tmp;\n}\n\n/* test z dlugim podciagiem niemalejacym */\nstatic inline int increasing_test()\n{\n    return bou - decreasing_test();\n}\n\nstatic void finish(int res, const char com[])\n{\n    if(res == ERROR)\n        printf(\"%s\\n\", com);\n    exit(0);\n}\n\n/* Inicjuje dane wejsciowe i zwraca liczbe projektow */\nint inicjuj()\n{\n    if(init == 1)\n        finish(ERROR, \"Program zawodnika moze wywolac funkcje inicjuj tylko raz!!!\");\n    init = 1;\n    scanf(\"%d\", &K);\n    if (K > 0){\n      TYP = 0;\n      N = MAX_N + 2;\n      return K;\n    }\n    int magic_begin, magic_end;\n    scanf(\"%d%d\", &magic_begin, &TYP);\n    if(magic_begin != MAGIC_BEGIN || TYP < MIN_TYP || TYP > MAX_TYP)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    scanf(\"%d%d%d%d\", &N, &K, &A, &PAR);\n    if(N < 1 || N > MAX_N || N < K || K > MAX_K || A < MIN_A || A > MAX_A \n        || PAR < MIN_PAR || PAR > MAX_PAR)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    scanf(\"%d\", &magic_end);\n    if(magic_end != MAGIC_END)\n        finish(ERROR, \"Program zawodnika nie moze korzystac z stdin!!!\");\n    con_k = 0;\n    lib_n = 0;\n    is_end = 0;\n    if(TYP == 2 || TYP == 3) {\n        len_sub = PAR;\n        bre = 0;\n    }\n    if(TYP == 2)\n        bou = A--;\n    return K;\n}\n\n/* Sluzy do wczytania ciagu reprezentujacego jakosci projektow */\nint wczytaj()\n{\n    if(unlikely(init == 0))\n        finish(ERROR, \"Program zawodnika nie wywolal funkcji inicjuj!!!\");\n    if(unlikely(lib_n > N || is_end == 1))\n        finish(ERROR, \"Program zawodnika wywolal funkcje wczytaj po otrzymaniu informacji o koncu ciagu!!!\");\n    if(unlikely(lib_n == N))\n        return 0;\n    lib_n++;\n    switch (TYP) {\n      case 0:\n        scanf(\"%d\", &A);\n        if(A == 0)\n          is_end = 1;\n        return A;\n        break;\n      case 1: return random_test(); break;\n      case 2: return increasing_test(); break;\n      case 3: return decreasing_test(); break;\n      default:\n              finish(ERROR, \"Nieznany typ testu\");\n    }\n    return -1;\n}\n\n/* Sluzy do wypisania wyznaczonego podciagu */\nvoid wypisz(int jakoscProjektu)\n{\n    if(init == 0)\n        finish(ERROR, \"Program zawodnika nie wywolal funkcji inicjuj!!!\");\n    printf(\"%d\\n\", jakoscProjektu);\n    if(++con_k == K)\n        finish(CORRECT, \"\");\n}\n```", "locale": "zh-CN"}}}
{"pid": "P3488", "type": "P", "difficulty": 6, "samples": [["4 4 2 1\n1 3\n2 3\n3 3\n2 -1\n", "TAK\nTAK\nNIE\nTAK\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "线段树", "POI（波兰）"], "title": "[POI 2009] LYZ-Ice Skates", "background": "", "description": "Byteasar runs a skate club. Its members meet on a regular basis and train    together, and they always use the club's ice-skates. The skate sizes are    (by convention) numbered from ![](http://main.edu.pl/images/OI16/lyz-en-tex.1.png) to ![](http://main.edu.pl/images/OI16/lyz-en-tex.2.png). Naturally, each club member has    some foot size, but that is not all to it! Skaters have skate size tolerance    factor ![](http://main.edu.pl/images/OI16/lyz-en-tex.3.png): a skater with foot size ![](http://main.edu.pl/images/OI16/lyz-en-tex.4.png) can wear skates with    sizes from ![](http://main.edu.pl/images/OI16/lyz-en-tex.5.png) up to ![](http://main.edu.pl/images/OI16/lyz-en-tex.6.png). It should be noted, though, that    no skater ever wears two skates of different size simultaneously.\n\nTo supply the club, Byteasar bought ![](http://main.edu.pl/images/OI16/lyz-en-tex.7.png) pairs of ice-skates of each size,    i.e. from ![](http://main.edu.pl/images/OI16/lyz-en-tex.8.png) to ![](http://main.edu.pl/images/OI16/lyz-en-tex.9.png). As time passes, some people join the club, just as    some established members leave it. Byteasar worries if he will have enough    skates of appropriate size for every member at each training.\n\nWe assume that initially the club has no members at all. Byteasar will give    you a sequence of ![](http://main.edu.pl/images/OI16/lyz-en-tex.10.png) events of the following form: ![](http://main.edu.pl/images/OI16/lyz-en-tex.11.png) (new) members with    foot size ![](http://main.edu.pl/images/OI16/lyz-en-tex.12.png) have joined/left the club. Right after each such event    Byteasar wants to know whether he has enough skates of appropriate size for    every club member. He asks you to write a programme that will check it for    him.\n", "inputFormat": "The first line of the standard input contains four integers ![](http://main.edu.pl/images/OI16/lyz-en-tex.13.png), ![](http://main.edu.pl/images/OI16/lyz-en-tex.14.png),      ![](http://main.edu.pl/images/OI16/lyz-en-tex.15.png) and ![](http://main.edu.pl/images/OI16/lyz-en-tex.16.png) (![](http://main.edu.pl/images/OI16/lyz-en-tex.17.png), ![](http://main.edu.pl/images/OI16/lyz-en-tex.18.png),      ![](http://main.edu.pl/images/OI16/lyz-en-tex.19.png), ![](http://main.edu.pl/images/OI16/lyz-en-tex.20.png)), separated by single spaces, that      denote, respectively: maximum skate size, number of events, number of      skate pairs of each size Byteasar initially bought, and the skate size      tolerance factor. The following ![](http://main.edu.pl/images/OI16/lyz-en-tex.21.png) lines contain the sequence of ![](http://main.edu.pl/images/OI16/lyz-en-tex.22.png)      events, one per line. The ![](http://main.edu.pl/images/OI16/lyz-en-tex.23.png)-th line (for ![](http://main.edu.pl…\n", "outputFormat": "Your programme should print out ![](http://main.edu.pl/images/OI16/lyz-en-tex.35.png) lines to the standard output.\n\nThe ![](http://main.edu.pl/images/OI16/lyz-en-tex.36.png)-th line (for ![](http://main.edu.pl/images/OI16/lyz-en-tex.37.png)) should either contain the word      TAK (Polish for yes), or the word NIE (Polish for      no), depending on whether Byteasar has the skates of appropriate      size for every club member right after the ![](http://main.edu.pl/images/OI16/lyz-en-tex.38.png)-th event.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] LYZ-Ice Skates", "background": "", "description": "Byteasar runs a skate club. Its members meet on a regular basis and train    together, and they always use the club's ice-skates. The skate sizes are    (by convention) numbered from ![](http://main.edu.pl/images/OI16/lyz-en-tex.1.png) to ![](http://main.edu.pl/images/OI16/lyz-en-tex.2.png). Naturally, each club member has    some foot size, but that is not all to it! Skaters have skate size tolerance    factor ![](http://main.edu.pl/images/OI16/lyz-en-tex.3.png): a skater with foot size ![](http://main.edu.pl/images/OI16/lyz-en-tex.4.png) can wear skates with    sizes from ![](http://main.edu.pl/images/OI16/lyz-en-tex.5.png) up to ![](http://main.edu.pl/images/OI16/lyz-en-tex.6.png). It should be noted, though, that    no skater ever wears two skates of different size simultaneously.\n\nTo supply the club, Byteasar bought ![](http://main.edu.pl/images/OI16/lyz-en-tex.7.png) pairs of ice-skates of each size,    i.e. from ![](http://main.edu.pl/images/OI16/lyz-en-tex.8.png) to ![](http://main.edu.pl/images/OI16/lyz-en-tex.9.png). As time passes, some people join the club, just as    some established members leave it. Byteasar worries if he will have enough    skates of appropriate size for every member at each training.\n\nWe assume that initially the club has no members at all. Byteasar will give    you a sequence of ![](http://main.edu.pl/images/OI16/lyz-en-tex.10.png) events of the following form: ![](http://main.edu.pl/images/OI16/lyz-en-tex.11.png) (new) members with    foot size ![](http://main.edu.pl/images/OI16/lyz-en-tex.12.png) have joined/left the club. Right after each such event    Byteasar wants to know whether he has enough skates of appropriate size for    every club member. He asks you to write a programme that will check it for    him.\n", "inputFormat": "The first line of the standard input contains four integers ![](http://main.edu.pl/images/OI16/lyz-en-tex.13.png), ![](http://main.edu.pl/images/OI16/lyz-en-tex.14.png),      ![](http://main.edu.pl/images/OI16/lyz-en-tex.15.png) and ![](http://main.edu.pl/images/OI16/lyz-en-tex.16.png) (![](http://main.edu.pl/images/OI16/lyz-en-tex.17.png), ![](http://main.edu.pl/images/OI16/lyz-en-tex.18.png),      ![](http://main.edu.pl/images/OI16/lyz-en-tex.19.png), ![](http://main.edu.pl/images/OI16/lyz-en-tex.20.png)), separated by single spaces, that      denote, respectively: maximum skate size, number of events, number of      skate pairs of each size Byteasar initially bought, and the skate size      tolerance factor. The following ![](http://main.edu.pl/images/OI16/lyz-en-tex.21.png) lines contain the sequence of ![](http://main.edu.pl/images/OI16/lyz-en-tex.22.png)      events, one per line. The ![](http://main.edu.pl/images/OI16/lyz-en-tex.23.png)-th line (for ![](http://main.edu.pl…\n", "outputFormat": "Your programme should print out ![](http://main.edu.pl/images/OI16/lyz-en-tex.35.png) lines to the standard output.\n\nThe ![](http://main.edu.pl/images/OI16/lyz-en-tex.36.png)-th line (for ![](http://main.edu.pl/images/OI16/lyz-en-tex.37.png)) should either contain the word      TAK (Polish for yes), or the word NIE (Polish for      no), depending on whether Byteasar has the skates of appropriate      size for every club member right after the ![](http://main.edu.pl/images/OI16/lyz-en-tex.38.png)-th event.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] LYZ-Ice Skates", "background": "", "description": "滑冰俱乐部初始有 $[1,n]$ 号码溜冰鞋各 $k$ 双，已知 $x$ 号脚的人可以穿 $[x,x+d]$ 号码的鞋子。\n\n现在有 $m$ 次操作，每次两个数 $r,x$，表示来了 $x$ 个 $r$ 号脚的人，$x$ 为负则表示离开。在每次操作之后，你需要判断溜冰鞋是否足够。", "inputFormat": "第一行 $4$ 个整数 $n,m,k,d$。\n\n接下来 $m$ 行，每行两个整数 $r_i,x_i$，代表一次操作。", "outputFormat": "$m$ 行，每行一个字符串，若此次操作后满足题意则输出 `TAK`，否则输出 `NIE`。", "hint": "$n\\le 2\\times 10^5,m\\le 5\\times 10^5,k\\le 10^9,1\\le r_i\\le n-d,-10^9\\le x_i\\le 10^9,0\\le d<n$", "locale": "zh-CN"}}}
{"pid": "P3489", "type": "P", "difficulty": 5, "samples": [["6 7 4 2\n2 1 2\n3 2 1 3\n1 2 2 0\n2 3 9 0\n1 4 2 1 2\n2 5 3 0\n4 5 5 2 2 3\n4 6 18 0\n5 6 3 2 1 2\n", "24\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "POI（波兰）", "最短路"], "title": "[POI 2009] WIE-Hexer", "background": "", "description": "Byteasar has become a hexer - a conqueror of monsters.\n\nCurrently he is to return to his hometown Byteburg. The way home, alas, leads through a land full of beasts. Fortunately the habitants, forced to fight the monsters for centuries, have mastered the art of blacksmithery - they are now capable of making special swords that are very efficient against the beasts.\n\nThe land Byteasar wanders through is quite vast: many towns lie there, and many roads connect them.\n\nThese roads do not cross outside the towns (mostly because some of them are underground passages).\n\nByteasar has gathered all practical information about the land (all hexers like to know these things).\n\nHe knows what kind of monsters he may come across each of the roads and how much time he needs to walk it down.\n\nHe also knows in which villages there are blacksmiths and against what kinds of monsters the swords that they make work.\n\nByteasar wants to get back to Byteburg as soon as possible.\n\nAs a hexer he is quite ashamed that he does not know the best route, and that he has no sword on him at the moment.\n\nHelp him find the shortest path to Byteburg such that whenever he could meet some king of monster, previously he would have a chance to get an appropriate sword to fight the beast.\n\nYou need not worry about the number or weight of the swords - every hexer is as strong as an ox, so he can carry (virtually) unlimited number of equipment, swords in particular.\n", "inputFormat": "The first line of the standard input holds four integers: $n,m,p,k$ ($1\\le n\\le 200,0\\le m\\le 3000,1\\le p\\le 13,0\\le k\\le n$),separated by single spaces, that denote respectively:\n\nthe number of towns, the number of roads connecting them,the number of different kinds of monsters and the number of blacksmiths.\n\nThe towns are numbered from $1$ to $n$ in such a way that $n$ is Byteburg's number and $1$ is the number of the village which Byteasar starts in. The monster kinds are numbered from $1$ to $p$.\n\nIn the following $k$ lines the profiles of successive blacksmiths are given,one per line. The $(i+1)$-st line holds the integers $w_i,q_i,r_{i,1}<r_{i,2}<...<r_{i,q_i}$($1\\le w_i\\le n,1\\le q_i\\le p,1\\le r_{i,j}\\le p$),separated by single spaces, that denote respectively: the number of town in which the blacksmith lives, the number of different kinds of monsters against which his swords are efficient, and the kinds of monsters themselves (in increasing order). Note that a town may have more than one blacksmith.\n\nThen $m$ lines with roads' descriptions follow.The $(k+i+1)$-th line holds the integers$v_i,w_i,t_i,s_i,u_{i,1}<u_{i,2}<...<u_{i,s_i}$($1\\le v_i<w_i\\le n,1\\le t_i\\le 500,0\\le s_i\\le p,1\\le u_{i,j}\\le p$)separated by single spaces, that denote respectively: the towns that the road connects, the time needed to walk down the road (same in both directions), the number of different kinds of monsters that may appear on that road, and finally the kinds of monsters themselves (in increasing order). No two roads connect the same pair of towns.\n", "outputFormat": "Your programme is to print out one integer to the standard output -  the minimum summary time required to reach Byteburg.\n\nShould reaching Byteburg be impossible, the number should be $-1$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] WIE-Hexer", "background": "", "description": "Byteasar has become a hexer - a conqueror of monsters.\n\nCurrently he is to return to his hometown Byteburg. The way home, alas, leads through a land full of beasts. Fortunately the habitants, forced to fight the monsters for centuries, have mastered the art of blacksmithery - they are now capable of making special swords that are very efficient against the beasts.\n\nThe land Byteasar wanders through is quite vast: many towns lie there, and many roads connect them.\n\nThese roads do not cross outside the towns (mostly because some of them are underground passages).\n\nByteasar has gathered all practical information about the land (all hexers like to know these things).\n\nHe knows what kind of monsters he may come across each of the roads and how much time he needs to walk it down.\n\nHe also knows in which villages there are blacksmiths and against what kinds of monsters the swords that they make work.\n\nByteasar wants to get back to Byteburg as soon as possible.\n\nAs a hexer he is quite ashamed that he does not know the best route, and that he has no sword on him at the moment.\n\nHelp him find the shortest path to Byteburg such that whenever he could meet some king of monster, previously he would have a chance to get an appropriate sword to fight the beast.\n\nYou need not worry about the number or weight of the swords - every hexer is as strong as an ox, so he can carry (virtually) unlimited number of equipment, swords in particular.\n", "inputFormat": "The first line of the standard input holds four integers: $n,m,p,k$ ($1\\le n\\le 200,0\\le m\\le 3000,1\\le p\\le 13,0\\le k\\le n$),separated by single spaces, that denote respectively:\n\nthe number of towns, the number of roads connecting them,the number of different kinds of monsters and the number of blacksmiths.\n\nThe towns are numbered from $1$ to $n$ in such a way that $n$ is Byteburg's number and $1$ is the number of the village which Byteasar starts in. The monster kinds are numbered from $1$ to $p$.\n\nIn the following $k$ lines the profiles of successive blacksmiths are given,one per line. The $(i+1)$-st line holds the integers $w_i,q_i,r_{i,1}<r_{i,2}<...<r_{i,q_i}$($1\\le w_i\\le n,1\\le q_i\\le p,1\\le r_{i,j}\\le p$),separated by single spaces, that denote respectively: the number of town in which the blacksmith lives, the number of different kinds of monsters against which his swords are efficient, and the kinds of monsters themselves (in increasing order). Note that a town may have more than one blacksmith.\n\nThen $m$ lines with roads' descriptions follow.The $(k+i+1)$-th line holds the integers$v_i,w_i,t_i,s_i,u_{i,1}<u_{i,2}<...<u_{i,s_i}$($1\\le v_i<w_i\\le n,1\\le t_i\\le 500,0\\le s_i\\le p,1\\le u_{i,j}\\le p$)separated by single spaces, that denote respectively: the towns that the road connects, the time needed to walk down the road (same in both directions), the number of different kinds of monsters that may appear on that road, and finally the kinds of monsters themselves (in increasing order). No two roads connect the same pair of towns.\n", "outputFormat": "Your programme is to print out one integer to the standard output -  the minimum summary time required to reach Byteburg.\n\nShould reaching Byteburg be impossible, the number should be $-1$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] WIE-Hexer", "background": "", "description": "Byteasar 成为了一名猎魔人——一个征服怪物的人。\n\n目前他要返回他的家乡 Byteburg。可惜回家的路要经过一个充满野兽的土地。幸运的是，当地居民被迫与怪物斗争了几个世纪，已经掌握了锻造的艺术——他们现在能够制造出对抗野兽非常有效的特殊剑。\n\nByteasar 所经过的土地相当广阔：那里有许多城镇，许多道路连接着它们。\n\n这些道路不会在城镇外交叉（主要是因为其中一些是地下通道）。\n\nByteasar 已经收集了关于这片土地的所有实用信息（所有猎魔人都喜欢知道这些事情）。\n\n他知道在每条路上可能遇到的怪物种类，以及他需要多少时间才能走完这条路。\n\n他还知道在哪些村庄有铁匠，以及他们制作的剑对哪些种类的怪物有效。\n\nByteasar 想尽快回到 Byteburg。\n\n作为一个猎魔人，他对自己不知道最佳路线感到相当羞愧，而且他目前身上没有剑。\n\n帮助他找到到 Byteburg 的最短路径，以便每当他可能遇到某种怪物时，他之前就有机会获得一把合适的剑来对抗野兽。\n\n你不需要担心剑的数量或重量——每个猎魔人都像牛一样强壮，所以他可以携带（几乎）无限数量的装备，特别是剑。", "inputFormat": "标准输入的第一行包含四个整数：$n,m,p,k$ ($1\\le n\\le 200,0\\le m\\le 3000,1\\le p\\le 13,0\\le k\\le n$)，它们分别表示：\n\n城镇的数量，连接它们的道路数量，不同种类的怪物数量和铁匠的数量。\n\n城镇从 $1$ 到 $n$ 编号，其中 $n$ 是 Byteburg 的编号，$1$ 是 Byteasar 开始的村庄编号。怪物种类从 $1$ 到 $p$ 编号。\n\n接下来的 $k$ 行给出了连续铁匠的资料，每行一个。第 $(i+1)$ 行包含整数 $w_i,q_i,r_{i,1}<r_{i,2}<...<r_{i,q_i}$ ($1\\le w_i\\le n,1\\le q_i\\le p,1\\le r_{i,j}\\le p$)，它们分别表示：铁匠所在的城镇编号，他的剑对抗的不同种类怪物的数量，以及怪物种类本身（按升序排列）。注意，一个城镇可能有多个铁匠。\n\n然后是 $m$ 行道路的描述。第 $(k+i+1)$ 行包含整数 $v_i,w_i,t_i,s_i,u_{i,1}<u_{i,2}<...<u_{i,s_i}$ ($1\\le v_i<w_i\\le n,1\\le t_i\\le 500,0\\le s_i\\le p,1\\le u_{i,j}\\le p$)，它们分别表示：道路连接的城镇，走完这条路所需的时间（两个方向相同），这条路上可能出现的不同种类怪物的数量，最后是怪物种类本身（按升序排列）。没有两条道路连接同一对城镇。", "outputFormat": "你的程序应输出一个整数到标准输出——到达 Byteburg 所需的最短总时间。\n\n如果无法到达 Byteburg，则该数字应为 $-1$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3490", "type": "P", "difficulty": 0, "samples": [["2\n1 2\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2009", "POI（波兰）"], "title": "[POI 2009] FIB-Words 2", "background": "", "description": "The following task is a significantly harder version of task Words from the third stage of 16th Polish OI. It wasn't used in the contest itself, but is an extension for those who solved \"Words\" and want more. :-)    Let ![](http://main.edu.pl/images/OI16/fib-en-tex.1.png) be a function acting on strings composed of the digits 0    and 1.\n\nThe function ![](http://main.edu.pl/images/OI16/fib-en-tex.2.png) transforms the string ![](http://main.edu.pl/images/OI16/fib-en-tex.3.png) by replacing (independently    and concurrently) every digit 0 with 1 and every digit    1 with the string ![](http://main.edu.pl/images/OI16/fib-en-tex.4.png).\n\nFor example ![](http://main.edu.pl/images/OI16/fib-en-tex.5.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.6.png)    (i.e. ![](http://main.edu.pl/images/OI16/fib-en-tex.7.png) assigns an empty string to the empty string).\n\nNote that ![](http://main.edu.pl/images/OI16/fib-en-tex.8.png) is an injection, or a one-to-one function.\n\nBy ![](http://main.edu.pl/images/OI16/fib-en-tex.9.png) we denote the function ![](http://main.edu.pl/images/OI16/fib-en-tex.10.png) composed with itself ![](http://main.edu.pl/images/OI16/fib-en-tex.11.png) times.\n\nIn particular, ![](http://main.edu.pl/images/OI16/fib-en-tex.12.png) is the identity function ![](http://main.edu.pl/images/OI16/fib-en-tex.13.png).\n\nWe are interested in the strings of the form ![](http://main.edu.pl/images/OI16/fib-en-tex.14.png)    for ![](http://main.edu.pl/images/OI16/fib-en-tex.15.png) This sequence begins with the following strings:\n\n![](http://main.edu.pl/images/OI16/fib-en-tex.16.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.17.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.18.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.19.png),    ![](http://main.edu.pl/images/OI16/fib-en-tex.20.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.21.png).\n\nWe call the string ![](http://main.edu.pl/images/OI16/fib-en-tex.22.png) a substring of the string ![](http://main.edu.pl/images/OI16/fib-en-tex.23.png) if it occurs    in ![](http://main.edu.pl/images/OI16/fib-en-tex.24.png) as  a contiguous (i.e. one-block) subsequence.\n\nA sequence of integers ![](http://main.edu.pl/images/OI16/fib-en-tex.25.png) is given.\n\nYour task is to check whether a string of the form    ![](http://main.edu.pl/images/OI16/fib-en-tex.26.png)    is a substring of ![](http://main.edu.pl/images/OI16/fib-en-tex.27.png) for some ![](http://main.edu.pl/images/OI16/fib-en-tex.28.png), and if it is,    you shuold find minimal such ![](http://main.edu.pl/images/OI16/fib-en-tex.29.png).\n", "inputFormat": "The first line of the standard input contains a single integer ![](http://main.edu.pl/images/OI16/fib-en-tex.30.png),      ![](http://main.edu.pl/images/OI16/fib-en-tex.31.png).\n\nThe second line of standard input holds ![](http://main.edu.pl/images/OI16/fib-en-tex.32.png) non-negative integers      ![](http://main.edu.pl/images/OI16/fib-en-tex.33.png)(![](http://main.edu.pl/images/OI16/fib-en-tex.34.png)), separated by single spaces.\n", "outputFormat": "Your programme should print out ![](http://main.edu.pl/images/OI16/fib-en-tex.35.png) lines to the standard output,     one for each test unit.\n\nYour programm should print to standard output minimal non-negative integer ![](http://main.edu.pl/images/OI16/fib-en-tex.36.png),     such that ![](http://main.edu.pl/images/OI16/fib-en-tex.37.png) is a substring of      ![](http://main.edu.pl/images/OI16/fib-en-tex.38.png), or NIE (no in Polish) if such ![](http://main.edu.pl/images/OI16/fib-en-tex.39.png) doesn't exist.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] FIB-Words 2", "background": "", "description": "The following task is a significantly harder version of task Words from the third stage of 16th Polish OI. It wasn't used in the contest itself, but is an extension for those who solved \"Words\" and want more. :-)    Let ![](http://main.edu.pl/images/OI16/fib-en-tex.1.png) be a function acting on strings composed of the digits 0    and 1.\n\nThe function ![](http://main.edu.pl/images/OI16/fib-en-tex.2.png) transforms the string ![](http://main.edu.pl/images/OI16/fib-en-tex.3.png) by replacing (independently    and concurrently) every digit 0 with 1 and every digit    1 with the string ![](http://main.edu.pl/images/OI16/fib-en-tex.4.png).\n\nFor example ![](http://main.edu.pl/images/OI16/fib-en-tex.5.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.6.png)    (i.e. ![](http://main.edu.pl/images/OI16/fib-en-tex.7.png) assigns an empty string to the empty string).\n\nNote that ![](http://main.edu.pl/images/OI16/fib-en-tex.8.png) is an injection, or a one-to-one function.\n\nBy ![](http://main.edu.pl/images/OI16/fib-en-tex.9.png) we denote the function ![](http://main.edu.pl/images/OI16/fib-en-tex.10.png) composed with itself ![](http://main.edu.pl/images/OI16/fib-en-tex.11.png) times.\n\nIn particular, ![](http://main.edu.pl/images/OI16/fib-en-tex.12.png) is the identity function ![](http://main.edu.pl/images/OI16/fib-en-tex.13.png).\n\nWe are interested in the strings of the form ![](http://main.edu.pl/images/OI16/fib-en-tex.14.png)    for ![](http://main.edu.pl/images/OI16/fib-en-tex.15.png) This sequence begins with the following strings:\n\n![](http://main.edu.pl/images/OI16/fib-en-tex.16.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.17.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.18.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.19.png),    ![](http://main.edu.pl/images/OI16/fib-en-tex.20.png), ![](http://main.edu.pl/images/OI16/fib-en-tex.21.png).\n\nWe call the string ![](http://main.edu.pl/images/OI16/fib-en-tex.22.png) a substring of the string ![](http://main.edu.pl/images/OI16/fib-en-tex.23.png) if it occurs    in ![](http://main.edu.pl/images/OI16/fib-en-tex.24.png) as  a contiguous (i.e. one-block) subsequence.\n\nA sequence of integers ![](http://main.edu.pl/images/OI16/fib-en-tex.25.png) is given.\n\nYour task is to check whether a string of the form    ![](http://main.edu.pl/images/OI16/fib-en-tex.26.png)    is a substring of ![](http://main.edu.pl/images/OI16/fib-en-tex.27.png) for some ![](http://main.edu.pl/images/OI16/fib-en-tex.28.png), and if it is,    you shuold find minimal such ![](http://main.edu.pl/images/OI16/fib-en-tex.29.png).\n", "inputFormat": "The first line of the standard input contains a single integer ![](http://main.edu.pl/images/OI16/fib-en-tex.30.png),      ![](http://main.edu.pl/images/OI16/fib-en-tex.31.png).\n\nThe second line of standard input holds ![](http://main.edu.pl/images/OI16/fib-en-tex.32.png) non-negative integers      ![](http://main.edu.pl/images/OI16/fib-en-tex.33.png)(![](http://main.edu.pl/images/OI16/fib-en-tex.34.png)), separated by single spaces.\n", "outputFormat": "Your programme should print out ![](http://main.edu.pl/images/OI16/fib-en-tex.35.png) lines to the standard output,     one for each test unit.\n\nYour programm should print to standard output minimal non-negative integer ![](http://main.edu.pl/images/OI16/fib-en-tex.36.png),     such that ![](http://main.edu.pl/images/OI16/fib-en-tex.37.png) is a substring of      ![](http://main.edu.pl/images/OI16/fib-en-tex.38.png), or NIE (no in Polish) if such ![](http://main.edu.pl/images/OI16/fib-en-tex.39.png) doesn't exist.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] FIB-Words 2", "background": "", "description": "以下任务是第 16 届波兰信息学奥林匹克第三阶段任务“Words”的一个显著更难的版本。它并未在比赛中使用，而是为那些解决了“Words”并想要更多挑战的人提供的扩展。令 $f$ 是一个作用于由数字 0 和 1 组成的字符串的函数。\n\n函数 $f$ 将字符串 $s$ 转换为通过独立且同时地将每个数字 0 替换为 1，并将每个数字 1 替换为字符串 $10$。\n\n例如，$f(0) = 1$，$f(1) = 10$（即 $f$ 将空字符串映射为空字符串）。\n\n注意，$f$ 是一个单射，即一对一函数。\n\n我们用 $f^n$ 表示函数 $f$ 自身复合 $n$ 次。\n\n特别地，$f^0$ 是恒等函数 $id$。\n\n我们对形如 $f^n(0)$ 的字符串感兴趣，其中 $n \\geq 0$。这个序列以以下字符串开始：\n\n$f^0(0) = 0$，$f^1(0) = 1$，$f^2(0) = 10$，$f^3(0) = 101$，$f^4(0) = 10110$，$f^5(0) = 10110101$。\n\n如果字符串 $u$ 作为一个连续（即单块）子序列出现在字符串 $v$ 中，我们称字符串 $u$ 是字符串 $v$ 的子串。\n\n给定一个整数序列 $a_1, a_2, \\ldots, a_k$。\n\n你的任务是检查形如 $f^{a_i}(0)$ 的字符串是否是 $f^n(0)$ 的子串，对于某个 $n \\geq 0$，如果是，你需要找到最小的这样的 $n$。", "inputFormat": "标准输入的第一行包含一个整数 $k$，$1 \\leq k \\leq 1000$。\n\n标准输入的第二行包含 $k$ 个非负整数 $a_1, a_2, \\ldots, a_k$（$0 \\leq a_i \\leq 10^9$），以单个空格分隔。", "outputFormat": "你的程序应输出 $k$ 行到标准输出，每个测试单元一行。\n\n你的程序应输出最小的非负整数 $n$，使得 $f^{a_i}(0)$ 是 $f^n(0)$ 的子串，或者如果这样的 $n$ 不存在，则输出 NIE（波兰语中的“否”）。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3491", "type": "P", "difficulty": 5, "samples": [["2\n2\n1 2\n2\n2 0\n", "TAK\nNIE\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "POI（波兰）", "枚举"], "title": "[POI 2009] SLW-Words", "background": "", "description": "Let $h$ be a function acting on strings composed of the digits 0 and 1. The function $h$ transforms the string $w$ by replacing (independently and concurrently) every digit 0 with 1 and every digit 1 with the string \"10\". For example $h(\"1001\") = \"101110\"$, $h(\"\") = \"\"$ (i.e. $h$ assigns an empty string to the empty string). Note that $h$ is an injection, or a one - to - one function. By $h^k$ we denote the function $h$ composed with itself $k$ times. In particular, $h^0$ is the identity function $h^0(w)=w$.\n\nWe are interested in the strings of the form $h^k(\"0\")$ for $k = 0,1,2,3,\\cdots$. This sequence begins with the following strings:\n\n\"0\", \"1\", \"10\", \"101\", \"10110\", \"10110101\".\n\nWe call the string $x$ a substring of the string $y$ if it occurs in $y$ as a contiguous (i.e. one - block) subsequence. A sequence of integers $k_1,k_2,\\cdots,k_n$ is given. Your task is to check whether a string of the form $h^{k_1}(\"0\") \\cdot h^{k_2}(\"0\") \\cdots h^{k_n}(\"0\")$ is a substring of $h^m(\"0\")$ for some $m$.", "inputFormat": "The first line of the standard input contains a single integer $t$, $1 \\leq t \\leq 13$, denoting the number of test units. The first line of each test unit's description contains one integer $n$, $1 \\leq n \\leq 100000$. The second line of each description holds $n$ non - negative integers $k_1,k_2,\\cdots,k_n$, separated by single spaces. The sum of the numbers in the second line of any test unit description does not exceed 10000000.", "outputFormat": "Your programme should print out $t$ lines to the standard output, one for each test unit. Each line corresponding to a test unit should contain one word: TAK (yes in Polish - if $h^{k_1}(\"0\") \\cdot h^{k_2}(\"0\") \\cdots h^{k_n}(\"0\")$ is a substring of $h^m(\"0\")$ for some $m$ in that test unit, or NIE (no in Polish) otherwise. ", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] SLW-Words", "background": "", "description": "Let $h$ be a function acting on strings composed of the digits 0 and 1. The function $h$ transforms the string $w$ by replacing (independently and concurrently) every digit 0 with 1 and every digit 1 with the string \"10\". For example $h(\"1001\") = \"101110\"$, $h(\"\") = \"\"$ (i.e. $h$ assigns an empty string to the empty string). Note that $h$ is an injection, or a one - to - one function. By $h^k$ we denote the function $h$ composed with itself $k$ times. In particular, $h^0$ is the identity function $h^0(w)=w$.\n\nWe are interested in the strings of the form $h^k(\"0\")$ for $k = 0,1,2,3,\\cdots$. This sequence begins with the following strings:\n\n\"0\", \"1\", \"10\", \"101\", \"10110\", \"10110101\".\n\nWe call the string $x$ a substring of the string $y$ if it occurs in $y$ as a contiguous (i.e. one - block) subsequence. A sequence of integers $k_1,k_2,\\cdots,k_n$ is given. Your task is to check whether a string of the form $h^{k_1}(\"0\") \\cdot h^{k_2}(\"0\") \\cdots h^{k_n}(\"0\")$ is a substring of $h^m(\"0\")$ for some $m$.", "inputFormat": "The first line of the standard input contains a single integer $t$, $1 \\leq t \\leq 13$, denoting the number of test units. The first line of each test unit's description contains one integer $n$, $1 \\leq n \\leq 100000$. The second line of each description holds $n$ non - negative integers $k_1,k_2,\\cdots,k_n$, separated by single spaces. The sum of the numbers in the second line of any test unit description does not exceed 10000000.", "outputFormat": "Your programme should print out $t$ lines to the standard output, one for each test unit. Each line corresponding to a test unit should contain one word: TAK (yes in Polish - if $h^{k_1}(\"0\") \\cdot h^{k_2}(\"0\") \\cdots h^{k_n}(\"0\")$ is a substring of $h^m(\"0\")$ for some $m$ in that test unit, or NIE (no in Polish) otherwise. ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] SLW-Words", "background": "", "description": "设 $h$ 是一个作用于由数字 0 和 1 组成的字符串的函数。函数 $h$ 将字符串 $w$ 转换为：独立且同时地将每个数字 0 替换为 1，并将每个数字 1 替换为字符串 \"10\"。例如，$h(\"1001\") = \"101110\"$，$h(\"\") = \"\"$（即 $h$ 将空字符串映射为空字符串）。注意，$h$ 是一个单射，即一对一的函数。$h^k$ 表示函数 $h$ 自身复合 $k$ 次。特别地，$h^0$ 是恒等函数 $h^0(w)=w$。\n\n我们对形如 $h^k(\"0\")$ 的字符串感兴趣，其中 $k = 0,1,2,3,\\cdots$。该序列以以下字符串开始：\n\n\"0\", \"1\", \"10\", \"101\", \"10110\", \"10110101\"。\n\n如果字符串 $x$ 作为一个连续（即单块）子序列出现在字符串 $y$ 中，我们称字符串 $x$ 是字符串 $y$ 的一个子串。给定一个整数序列 $k_1,k_2,\\cdots,k_n$。你的任务是检查形如 $h^{k_1}(\"0\") \\cdot h^{k_2}(\"0\") \\cdots h^{k_n}(\"0\")$ 的字符串是否是某个 $h^m(\"0\")$ 的子串。", "inputFormat": "标准输入的第一行包含一个整数 $t$，$1 \\leq t \\leq 13$，表示测试单元的数量。每个测试单元的描述的第一行包含一个整数 $n$，$1 \\leq n \\leq 100000$。每个描述的第二行包含 $n$ 个非负整数 $k_1,k_2,\\cdots,k_n$，以单个空格分隔。任何测试单元描述的第二行中的数字之和不超过 10000000。", "outputFormat": "你的程序应输出 $t$ 行到标准输出，每行对应一个测试单元。每个对应测试单元的行应包含一个单词：TAK（波兰语中的“是”——如果 $h^{k_1}(\"0\") \\cdot h^{k_2}(\"0\") \\cdots h^{k_n}(\"0\")$ 是某个 $h^m(\"0\")$ 的子串），否则为 NIE（波兰语中的“否”）。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3492", "type": "P", "difficulty": 4, "samples": [["2\n4 3\n1 2 3\n4 5 6\n7 8 9\n10 11 12\n11 10 12\n8 7 9\n5 4 6\n2 1 3\n2 2\n1 2\n3 4\n5 6\n7 8\n", "TAK\nNIE\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2009", "POI（波兰）"], "title": "[POI 2009] TAB-Arrays", "background": "", "description": "Consider an $n \\times m$ table filled with **distinct** integers. The following operations can be performed on the table:  \n\n1. Swapping two rows.  \n2. Swapping two columns.  \n\nWe say that two tables are **similar** if, by applying some sequence of the above operations to the first table, we can obtain the second table.  \n\nWrite a program that determines for a given set of table pairs which pairs contain similar tables.  ", "inputFormat": "The first line of standard input contains a single integer $t$ ($1 \\leq t \\leq 10$), representing the number of table pairs. The subsequent lines describe the table pairs.  \n\nEach table pair description starts with a line containing two integers $n$ and $m$ ($1 \\leq n, m \\leq 1000$), separated by a single space, representing the number of rows and columns of both tables.  \n\nThe next $n$ lines contain the description of the first table. The $i$-th of these lines contains $m$ integers $a_{ij}$ ($-10^6 \\leq a_{ij} \\leq 10^6$), separated by single spaces, representing the numbers in the $i$-th row of the first table.  \n\nThe next $n$ lines contain the description of the second table. The $i$-th of these lines contains $m$ integers $b_{ij}$ ($-10^6 \\leq b_{ij} \\leq 10^6$), separated by single spaces, representing the numbers in the $i$-th row of the second table.  \n\nAll numbers in a single table are distinct.  ", "outputFormat": "Your program should print $t$ lines to standard output. The $k$-th of these lines should contain the word **\"TAK\"** if the tables in the $k$-th input pair are similar, and **\"NIE\"** otherwise.  ", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] TAB-Arrays", "background": "", "description": "Consider an $n \\times m$ table filled with **distinct** integers. The following operations can be performed on the table:  \n\n1. Swapping two rows.  \n2. Swapping two columns.  \n\nWe say that two tables are **similar** if, by applying some sequence of the above operations to the first table, we can obtain the second table.  \n\nWrite a program that determines for a given set of table pairs which pairs contain similar tables.  ", "inputFormat": "The first line of standard input contains a single integer $t$ ($1 \\leq t \\leq 10$), representing the number of table pairs. The subsequent lines describe the table pairs.  \n\nEach table pair description starts with a line containing two integers $n$ and $m$ ($1 \\leq n, m \\leq 1000$), separated by a single space, representing the number of rows and columns of both tables.  \n\nThe next $n$ lines contain the description of the first table. The $i$-th of these lines contains $m$ integers $a_{ij}$ ($-10^6 \\leq a_{ij} \\leq 10^6$), separated by single spaces, representing the numbers in the $i$-th row of the first table.  \n\nThe next $n$ lines contain the description of the second table. The $i$-th of these lines contains $m$ integers $b_{ij}$ ($-10^6 \\leq b_{ij} \\leq 10^6$), separated by single spaces, representing the numbers in the $i$-th row of the second table.  \n\nAll numbers in a single table are distinct.  ", "outputFormat": "Your program should print $t$ lines to standard output. The $k$-th of these lines should contain the word **\"TAK\"** if the tables in the $k$-th input pair are similar, and **\"NIE\"** otherwise.  ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] TAB-Arrays", "background": "", "description": "考虑一个 $n \\times m$ 的表格，其中填充了**互不相同**的整数。可以对该表执行以下操作：  \n\n1. 交换两行。  \n2. 交换两列。  \n\n如果可以通过某种操作序列将第一张表转换为第二张表，我们就称这两张表是**相似的**。  \n\n请编写一个程序，对于给定的一组表格对，判断哪些表格对包含相似的表格。  ", "inputFormat": "标准输入的第一行包含一个整数 $t$（$1 \\leq t \\leq 10$），表示表格对的数量。接下来的行描述这些表格对。  \n\n每个表格对的描述从一行开始，该行包含两个整数 $n$ 和 $m$（$1 \\leq n, m \\leq 1000$），用单个空格分隔，表示两张表格的行数和列数。  \n\n接下来的 $n$ 行描述第一张表格。第 $i$ 行包含 $m$ 个整数 $a_{ij}$（$-10^6 \\leq a_{ij} \\leq 10^6$），用空格分隔，表示第一张表格第 $i$ 行的数字。  \n\n再接下来的 $n$ 行描述第二张表格。第 $i$ 行包含 $m$ 个整数 $b_{ij}$（$-10^6 \\leq b_{ij} \\leq 10^6$），用空格分隔，表示第二张表格第 $i$ 行的数字。  \n\n在同一张表格中，所有数字都互不相同。  ", "outputFormat": "程序应在标准输出打印 $t$ 行。对于第 $k$ 对输入表格，如果它们是相似的，则输出 **\"TAK\"**，否则输出 **\"NIE\"**。  \n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3493", "type": "P", "difficulty": 6, "samples": [["6 9\n-12 -10\n-11 6\n-4 12\n6 14\n16 6\n18 -2\n3 4\n1 5\n2 6\n2 3\n4 5\n3 5\n1 3\n3 6\n1 6\n", "42.0000000000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2009", "POI（波兰）", "Special Judge", "半平面交"], "title": "[POI 2009] WSP-Island", "background": "", "description": "Byteasar is the king of Byteotia, an island in The Ocean of Happiness.\n\nThe island is a convex shape, and all the towns of Byteotia are located on the shore.\n\nOne of these towns is Byteburg, the famous capital of Byteotia.\n\nEvery pair of towns is connected by a road that goes along the line segment between the towns.\n\nSome roads that connect different pairs of towns intersect - there is a crossroad at each such intersection.\n\nBitratio, Byteasar's rival to the throne, had hatched a sordid plot.\n\nWhile Byteasar was travelling from the capital to an adjacent town, Bitratio's people seized Byteburg.\n\nNow Byteasar has to return to Byteburg as soon as possible in order to restore his rule.\n\nUnfortunately, some of the roads are controlled by Bitratio's guerrilla.\n\nByteasar cannot risk the use of such roads, he can however cross them at the crossroads.\n\nNeedless to say, he has to travel along the roads and hence turn only at the crossroads, for otherwise the journey would take far too long.\n\nByteasar's loyal servants have informed him which roads are safe.\n\nByteasar believes your loyalty, and thus entrusts you with a task to find the shortest safe route from the town he is currently in to Byteburg.\n\nByteotia岛屿是一个凸多边形。城市全都在海岸上。按顺时针编号1到n。任意两个城市之间都有一条笔直的道路相连。道路相交处可以自由穿行。有一些道路被游击队控制了，不能走，但是可以经过这条道路与未被控制的道路的交点。问从城市1到n的最短距离。\n", "inputFormat": "In the first line of the standard input two integers ![](http://main.edu.pl/images/OI16/wsp-en-tex.1.png) and ![](http://main.edu.pl/images/OI16/wsp-en-tex.2.png) are given     (![](http://main.edu.pl/images/OI16/wsp-en-tex.3.png), ![](http://main.edu.pl/images/OI16/wsp-en-tex.4.png)),     separated by a single space,     that denote respectively: the number of towns and      the number of roads controlled by Bitratio's guerrilla.\n\nLet us number the towns from ![](http://main.edu.pl/images/OI16/wsp-en-tex.5.png) to ![](http://main.edu.pl/images/OI16/wsp-en-tex.6.png) starting from Byteburg      and moving clockwise along the shore.\n\nBytesar is currently in the town no. ![](http://main.edu.pl/images/OI16/wsp-en-tex.7.png).\n\nEach of the following ![](http://main.edu.pl/images/OI16/wsp-en-tex.8.png) lines holds a pair of integers ![](http://main.edu.pl/images/OI16/wsp-en-tex.9.png) and ![](http://main.edu.pl/images/OI16/wsp-en-tex.10.png)      (![](http://main.edu.pl/images/O…\n", "outputFormat": "Your programme is to print out one floating point number     to the standard output:\n\nthe length of the shortest safe route leading from the town no. ![](http://main.edu.pl/images/OI16/wsp-en-tex.19.png)     to Byteburg.\n\nThe absolute difference between the number returned and the correct one  has to be at most ![](http://main.edu.pl/images/OI16/wsp-en-tex.20.png).\n", "hint": "spj-", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2009] WSP-Island", "background": "# Description\n\nByteasar is the king of Byteotia, an island in the Ocean of Happiness. The island is convex, and all the towns of Byteotia are located on the shore. One of these towns is Byteburg, the capital of Byteotia.\n\nEvery pair of towns is connected by a straight road that follows the line segment between the towns. If two such roads intersect, there is a crossroad at the intersection, and one may freely pass through it.\n\nSome roads are controlled by Bitratio’s guerrilla. Byteasar cannot travel along such roads, but he may cross them at crossroads. He must travel only along roads and may turn only at towns or crossroads.\n\nThe towns are numbered from $1$ to $n$ starting from Byteburg and moving clockwise along the shore. Byteasar is currently in town $s$. Find the length of the shortest safe route from town $s$ to Byteburg (town $1$).", "description": "Byteasar is the king of Byteotia, an island in the Ocean of Happiness. The island is convex, and all the towns of Byteotia are located on the shore. One of these towns is Byteburg, the capital of Byteotia.\n\nEvery pair of towns is connected by a straight road that follows the line segment between the towns. If two such roads intersect, there is a crossroad at the intersection, and one may freely pass through it.\n\nSome roads are controlled by Bitratio’s guerrilla. Byteasar cannot travel along such roads, but he may cross them at crossroads. He must travel only along roads and may turn only at towns or crossroads.\n\nThe towns are numbered from $1$ to $n$ starting from Byteburg and moving clockwise along the shore. Byteasar is currently in town $s$. Find the length of the shortest safe route from town $s$ to Byteburg (town $1$).\n\n# Description", "inputFormat": "- The first line contains two integers $n$ and $m$ — the number of towns and the number of roads controlled by the guerrilla.\n- The second line contains one integer $s$ — the index of the town where Byteasar is currently located.\n- Each of the next $m$ lines contains two integers $a_i$ and $b_i$ ($1 \\le a_i < b_i \\le n$), denoting a road between towns $a_i$ and $b_i$ that is controlled and thus cannot be used for travel (but may be crossed at crossroads).", "outputFormat": "Print a single floating-point number: the length of the shortest safe route from town $s$ to Byteburg (town $1$). The absolute error of your answer must be at most $10^{-4}$.", "hint": "Special judge.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2009] WSP-Island", "background": "", "description": "Byteasar is the king of Byteotia, an island in The Ocean of Happiness.\n\nThe island is a convex shape, and all the towns of Byteotia are located on the shore.\n\nOne of these towns is Byteburg, the famous capital of Byteotia.\n\nEvery pair of towns is connected by a road that goes along the line segment between the towns.\n\nSome roads that connect different pairs of towns intersect - there is a crossroad at each such intersection.\n\nBitratio, Byteasar's rival to the throne, had hatched a sordid plot.\n\nWhile Byteasar was travelling from the capital to an adjacent town, Bitratio's people seized Byteburg.\n\nNow Byteasar has to return to Byteburg as soon as possible in order to restore his rule.\n\nUnfortunately, some of the roads are controlled by Bitratio's guerrilla.\n\nByteasar cannot risk the use of such roads, he can however cross them at the crossroads.\n\nNeedless to say, he has to travel along the roads and hence turn only at the crossroads, for otherwise the journey would take far too long.\n\nByteasar's loyal servants have informed him which roads are safe.\n\nByteasar believes your loyalty, and thus entrusts you with a task to find the shortest safe route from the town he is currently in to Byteburg.\n\nByteotia岛屿是一个凸多边形。城市全都在海岸上。按顺时针编号1到n。任意两个城市之间都有一条笔直的道路相连。道路相交处可以自由穿行。有一些道路被游击队控制了，不能走，但是可以经过这条道路与未被控制的道路的交点。问从城市1到n的最短距离。\n", "inputFormat": "In the first line of the standard input two integers ![](http://main.edu.pl/images/OI16/wsp-en-tex.1.png) and ![](http://main.edu.pl/images/OI16/wsp-en-tex.2.png) are given     (![](http://main.edu.pl/images/OI16/wsp-en-tex.3.png), ![](http://main.edu.pl/images/OI16/wsp-en-tex.4.png)),     separated by a single space,     that denote respectively: the number of towns and      the number of roads controlled by Bitratio's guerrilla.\n\nLet us number the towns from ![](http://main.edu.pl/images/OI16/wsp-en-tex.5.png) to ![](http://main.edu.pl/images/OI16/wsp-en-tex.6.png) starting from Byteburg      and moving clockwise along the shore.\n\nBytesar is currently in the town no. ![](http://main.edu.pl/images/OI16/wsp-en-tex.7.png).\n\nEach of the following ![](http://main.edu.pl/images/OI16/wsp-en-tex.8.png) lines holds a pair of integers ![](http://main.edu.pl/images/OI16/wsp-en-tex.9.png) and ![](http://main.edu.pl/images/OI16/wsp-en-tex.10.png)      (![](http://main.edu.pl/images/O…\n", "outputFormat": "Your programme is to print out one floating point number     to the standard output:\n\nthe length of the shortest safe route leading from the town no. ![](http://main.edu.pl/images/OI16/wsp-en-tex.19.png)     to Byteburg.\n\nThe absolute difference between the number returned and the correct one  has to be at most ![](http://main.edu.pl/images/OI16/wsp-en-tex.20.png).\n", "hint": "spj-", "locale": "zh-CN"}}}
{"pid": "P3494", "type": "P", "difficulty": 6, "samples": [["21\n11XB0XBB00XB11XB0XBBB\n", "2\n4\n5\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "POI（波兰）", "深度优先搜索 DFS", "字典树 Trie"], "title": "[POI 2009] KOD-The Code", "background": "", "description": "The Byteotian Institute of Telecommunication (BIT) sets standards for data transmission in telecommunication networks all over Byteotia.\n\nByteasar, one of the engineers employed at BIT, works on prefix codes - a certain way of representing characters.\n\nFor each and every character of the Byteotian alphabet there is a corresponding sequence of bits, called the code word of that character.\n\nThe code words of all characters have the following properties:\n\nNone of the code words is a prefix (i.e. a leading       fragment) of another code word.\n\nFor example, if 010010 is the code word of the letter   A, then neither the bit sequence 0,   01, 010,  0100 nor 01001   is a code word of another letter.\n\nLikewise, 0100100, 0100101 and longer   sequences starting with 010010 are not code words.\n\nIf a given bit sequence ![](http://main.edu.pl/images/OI16/kod-en-tex.1.png) is a prefix of another code word,       but not the complete code, then each of the bit sequences       ![](http://main.edu.pl/images/OI16/kod-en-tex.2.png) and ![](http://main.edu.pl/images/OI16/kod-en-tex.3.png) (that is, ![](http://main.edu.pl/images/OI16/kod-en-tex.4.png) with zero or one       appended at the end) is a prefix of some code word, or the       complete code word.\n\nFor example, if 0100 is the prefix of the code word of the       letter A, then 01000 and 01001 each       is a prefix of some code word, or a complete code word.\n\nLet us consider the following exemplary prefix code for the alphabet consisting of the characters    A, B, C, D and E:\n\ncharactercode word    A00    B10    C11    D010    E011         Encoding a sequence of characters with a prefix code consists in concatenating the code words of its successive characters.\n\nFor example, the encoding of the sequence BACAEBABAE is 1000110001110001000011.\n\nByteasar noticed that if some leading bits are lost, the sequence may be decoded wrong, or it may even be not decoded at all.\n\nFor example, if five initial bits of the sequence given above are removed, the resulting sequence 10001110001000011 will be decoded as BACBABAE.\n\nThe last five letter (BABAE) are correct, but the first three (BAC) are not.\n\nByteasar further noticed that all the letters after the first E are decoded correct.\n\nHe concluded that whenever all the bits of the code word of E are intact, all the characters succeeding E will be decoded correct.\n\nThe same holds for every encoded sequence obtained from one that contains E.\n\nHe also noticed that the letter D shares this feature, but A, B and C do not.\n\nBecause of the properties of the code words of E and D Byteasar called them synchronising code words.\n\nHe trusted you with the task of writing a programme that finds all the synchronising code words of a given prefix code.\n\nTo save some time, he intends to present you all the code words on his binary monitor.\n\nThis interesting device has four buttons:\n\n0 - append ![](http://main.edu.pl/im…\n", "inputFormat": "In the first line of the standard input there is an integer ![](http://main.edu.pl/images/OI16/kod-en-tex.7.png)      (![](http://main.edu.pl/images/OI16/kod-en-tex.8.png)) denoting the number of buttons pressed      by Byteasar.\n\nIn the following line an ![](http://main.edu.pl/images/OI16/kod-en-tex.9.png) letters long string consisting of the      characters '0', '1', 'B' and      'X' is given; the characters correspond to the buttons,      of course.\n\nEach time the button X is pressed, a code word is      completed and another one starts.\n\nThe code words are numbered starting with 1.\n\nThe sum of lengths of all code words will not exceed ![](http://main.edu.pl/images/OI16/kod-en-tex.10.png).\n", "outputFormat": "The number ![](http://main.edu.pl/images/OI16/kod-en-tex.11.png) of synchronising code words should be printed out in the     first line of the standard output.\n\nThe following ![](http://main.edu.pl/images/OI16/kod-en-tex.12.png) lines should contain the numbers of code words that  are synchronising in increasing order, each in a separate line.\n\nIf the given prefix code contains no synchronising code words, the first  line should contain the number 0, and no more lines should follow.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2009] KOD-The Code", "background": "", "description": "The Byteotian Institute of Telecommunication (BIT) sets standards for data transmission in telecommunication networks all over Byteotia.\n\nByteasar, one of the engineers employed at BIT, works on prefix codes - a certain way of representing characters.\n\nFor each and every character of the Byteotian alphabet there is a corresponding sequence of bits, called the code word of that character.\n\nThe code words of all characters have the following properties:\n\nNone of the code words is a prefix (i.e. a leading       fragment) of another code word.\n\nFor example, if 010010 is the code word of the letter   A, then neither the bit sequence 0,   01, 010,  0100 nor 01001   is a code word of another letter.\n\nLikewise, 0100100, 0100101 and longer   sequences starting with 010010 are not code words.\n\nIf a given bit sequence ![](http://main.edu.pl/images/OI16/kod-en-tex.1.png) is a prefix of another code word,       but not the complete code, then each of the bit sequences       ![](http://main.edu.pl/images/OI16/kod-en-tex.2.png) and ![](http://main.edu.pl/images/OI16/kod-en-tex.3.png) (that is, ![](http://main.edu.pl/images/OI16/kod-en-tex.4.png) with zero or one       appended at the end) is a prefix of some code word, or the       complete code word.\n\nFor example, if 0100 is the prefix of the code word of the       letter A, then 01000 and 01001 each       is a prefix of some code word, or a complete code word.\n\nLet us consider the following exemplary prefix code for the alphabet consisting of the characters    A, B, C, D and E:\n\ncharactercode word    A00    B10    C11    D010    E011         Encoding a sequence of characters with a prefix code consists in concatenating the code words of its successive characters.\n\nFor example, the encoding of the sequence BACAEBABAE is 1000110001110001000011.\n\nByteasar noticed that if some leading bits are lost, the sequence may be decoded wrong, or it may even be not decoded at all.\n\nFor example, if five initial bits of the sequence given above are removed, the resulting sequence 10001110001000011 will be decoded as BACBABAE.\n\nThe last five letter (BABAE) are correct, but the first three (BAC) are not.\n\nByteasar further noticed that all the letters after the first E are decoded correct.\n\nHe concluded that whenever all the bits of the code word of E are intact, all the characters succeeding E will be decoded correct.\n\nThe same holds for every encoded sequence obtained from one that contains E.\n\nHe also noticed that the letter D shares this feature, but A, B and C do not.\n\nBecause of the properties of the code words of E and D Byteasar called them synchronising code words.\n\nHe trusted you with the task of writing a programme that finds all the synchronising code words of a given prefix code.\n\nTo save some time, he intends to present you all the code words on his binary monitor.\n\nThis interesting device has four buttons:\n\n0 - append ![](http://main.edu.pl/im…\n", "inputFormat": "In the first line of the standard input there is an integer ![](http://main.edu.pl/images/OI16/kod-en-tex.7.png)      (![](http://main.edu.pl/images/OI16/kod-en-tex.8.png)) denoting the number of buttons pressed      by Byteasar.\n\nIn the following line an ![](http://main.edu.pl/images/OI16/kod-en-tex.9.png) letters long string consisting of the      characters '0', '1', 'B' and      'X' is given; the characters correspond to the buttons,      of course.\n\nEach time the button X is pressed, a code word is      completed and another one starts.\n\nThe code words are numbered starting with 1.\n\nThe sum of lengths of all code words will not exceed ![](http://main.edu.pl/images/OI16/kod-en-tex.10.png).\n", "outputFormat": "The number ![](http://main.edu.pl/images/OI16/kod-en-tex.11.png) of synchronising code words should be printed out in the     first line of the standard output.\n\nThe following ![](http://main.edu.pl/images/OI16/kod-en-tex.12.png) lines should contain the numbers of code words that  are synchronising in increasing order, each in a separate line.\n\nIf the given prefix code contains no synchronising code words, the first  line should contain the number 0, and no more lines should follow.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2009] KOD-The Code", "background": "", "description": "## 题面翻译", "inputFormat": "定义对一个 $01$ 串进行解码的过程是，每次找到一个前缀，满足它对应一个字符，容易知道这样的前缀是唯一的。将这个字符加入答案，将这个前缀从原串中删掉，如果不存在这样的前缀，则解码的结果是未定义。记 $s$ 解码的结果是 $\\mathrm{decode}(s)$。\n\n设一个字符编码为 $a$，定义它是好的，当且仅当对于任意两个串 $s,t$，对于 $\\mathrm{encode}(s)$ 的任意后缀 $p$，有 $\\mathrm{decode}(p+a)$ 不是未定义，且 $\\mathrm{decode}(p+a+\\mathrm{encode}(t))=\\mathrm{decode}(p+a)+t$。求哪些字符是好的。\n\n\n第一行一个数 $n$，表示操作次数。接下来一行一个长 $n$ 的字符串，其中 `0`/`1` 表示在当前结点添加一个儿子，边权为 `0`/`1`，并移动过去；`B`表示添加一个父亲；`X`表示当前结点是一个字符的编码。保证输入是描述这棵 trie 的最短的可能输入。$n\\leq 3\\times 10^6$ ，所有字符编码的总长 $\\leq 10^8$ 。", "outputFormat": "一行一个数，表示好的字符的数量。\n\n接下来若干行，从小到大输出每个好的字符是第几个`X`生成的。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3496", "type": "P", "difficulty": 4, "samples": [["7 8\n1 2\n3 4\n5 4\n6 4\n7 4\n5 6\n5 7\n6 7", "TAK\nK\nS\nK\nS\nK\nK\nN"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "贪心", "2010", "POI（波兰）", "Special Judge", "广度优先搜索 BFS", "深度优先搜索 DFS"], "title": "[POI 2010] GIL-Guilds", "background": null, "description": "国王 Byteasar 面临一个严峻的问题。\n\n两个相互竞争的贸易组织——裁缝行会（The Tailors Guild）和缝纫行会（The Sewers Guild）同时要求获得许可，在王国每个城镇设立办事处。\n\nByteotia 有 $n$ 个城镇。\n\n其中一些城镇通过双向道路连接。\n\n每个行会都要求：\n\n- 每个城镇必须设有本行会的办事处\n\n- 或者该城镇必须直接连接到一个设有本行会办事处的城镇。\n\n然而，国王怀疑其中有诈。他担心如果存在某个城镇同时设有两个行会的办事处，可能会导致服装垄断。\n\n因此，他请求你的帮助。", "inputFormat": "标准输入的第一行包含两个整数 $n$ ($n \\leq 200000$) 和 $m$ ($m \\leq 500000$)，分别表示 Byteotia 的城镇数量和道路数量。\n\n城镇编号为 $1$ 到 $n$。\n\n接下来 $m$ 行描述道路：输入的第 $i+1$ 行描述第 $i$ 条道路；", "outputFormat": "你的程序应在标准输出的第一行输出一个单词：\n\n- `TAK`（波兰语中的\"是\"）——表示可以按照规则在城镇中设置办事处，或者\n\n- `NIE`（波兰语中的\"否\"）——表示无法满足条件。\n\n如果答案是 `TAK`，则接下来的 $n$ 行应给出一种可行的办事处设置方案。因此第 $i+1$ 行应包含：\n\n- 字母 `K` —— 表示城镇 $i$ 应设有裁缝行会（The Tailors Guild）的办事处，或\n\n- 字母 `S` —— 表示城镇 $i$ 应设有缝纫行会（The Sewers Guild）的办事处，或\n\n- 字母 `N` —— 表示城镇 $i$ 不应设有任何行会的办事处。", "hint": "题目spj贡献者@mengbierr\n\n翻译：DeepSeek-R1", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2010] GIL-Guilds", "background": null, "description": "King Byteasar faces a serious matter.\n\nTwo competing trade organisations, The Tailors Guild and The Sewers Guild asked, at the same time, for permissions to open their offices in each town of the kingdom.\n\nThere are towns in Byteotia.\n\nSome of them are connected with bidirectional roads.\n\nEach of the guilds postulate that every town should:\n\nhave an office of the guild, or be directly connected to another town that does.\n\nThe king, however, suspects foul play. He fears that if there is just a single town holding the offices of both guilds, it could lead to a clothing cartel.\n\nFor this reason he asks your help.", "inputFormat": "Two integers, n(<=200000) and m(<=500000), are given in the first line of the standard input. These denote the number of towns and roads in Byteotia, respectively.\n\nThe towns are numbered from 1 to n.\n\nThen the roads are given as follows: the input line no. i+1 describes the i-th road;", "outputFormat": "Your program should print out one word in the first line of the standard output:\n\nTAK (yes in Polish) - if the offices can be placed in towns according to these rules, or NIE (no in Polish) - in the opposite case.\n\nIf the answers is TAK, then the following n lines should give an exemplary placement of the offices. Thus the line No.i+1 $%$s$%$h$%$o$%$u$%$l$%$d$%$ hold :\n\nthe letter K if there should be an office of The Tailors Guild in the town i, or the letter S if there should be an office of The Sewers Guild in the town i, or the letter N if there should be no office in the town i.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[POI 2010] GIL-Guilds", "background": null, "description": "国王 Byteasar 面临一个严峻的问题。\n\n两个相互竞争的贸易组织——裁缝行会（The Tailors Guild）和缝纫行会（The Sewers Guild）同时要求获得许可，在王国每个城镇设立办事处。\n\nByteotia 有 $n$ 个城镇。\n\n其中一些城镇通过双向道路连接。\n\n每个行会都要求：\n\n- 每个城镇必须设有本行会的办事处\n\n- 或者该城镇必须直接连接到一个设有本行会办事处的城镇。\n\n然而，国王怀疑其中有诈。他担心如果存在某个城镇同时设有两个行会的办事处，可能会导致服装垄断。\n\n因此，他请求你的帮助。", "inputFormat": "标准输入的第一行包含两个整数 $n$ ($n \\leq 200000$) 和 $m$ ($m \\leq 500000$)，分别表示 Byteotia 的城镇数量和道路数量。\n\n城镇编号为 $1$ 到 $n$。\n\n接下来 $m$ 行描述道路：输入的第 $i+1$ 行描述第 $i$ 条道路；", "outputFormat": "你的程序应在标准输出的第一行输出一个单词：\n\n- `TAK`（波兰语中的\"是\"）——表示可以按照规则在城镇中设置办事处，或者\n\n- `NIE`（波兰语中的\"否\"）——表示无法满足条件。\n\n如果答案是 `TAK`，则接下来的 $n$ 行应给出一种可行的办事处设置方案。因此第 $i+1$ 行应包含：\n\n- 字母 `K` —— 表示城镇 $i$ 应设有裁缝行会（The Tailors Guild）的办事处，或\n\n- 字母 `S` —— 表示城镇 $i$ 应设有缝纫行会（The Sewers Guild）的办事处，或\n\n- 字母 `N` —— 表示城镇 $i$ 不应设有任何行会的办事处。", "hint": "题目spj贡献者@mengbierr\n\n翻译：DeepSeek-R1", "locale": "zh-CN"}}}
{"pid": "P3497", "type": "P", "difficulty": 6, "samples": [["4\n1 3 4 2", "TAK\n1 1 2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "线段树", "POI（波兰）", "Special Judge"], "title": "[POI 2010] KOL-Railway", "background": "", "description": "**译自 POI 2010 Stage 1.「[Kolej](https://szkopul.edu.pl/problemset/problem/TJVrS_hRC8W5Q6ZBW6mETAIm/site/?key=statement)」**\n\n一个铁路包含两个侧线 $1$ 和 $2$ ，左边由 $A$ 进入，右边由 $B$ 出去（如下图所示）。  \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bdq72qy0.png)\n\n有 $n$ 个车厢在通道 $A$ 上，编号为 $1$ 到 $n$ ，它们按照 $a_1,a_2,\\cdots ,a_n$ 的顺序进入侧线，想要按照 $1,2,\\cdots ,n$ 的顺序从通道 $B$ 出去。    \n他们可以从 $A$ 到 $1$ 或 $2$ ，然后经过一系列转移从 $B$ 出去（不用考虑容量问题）。求是否能够做到，如果可以，请找出一种方案。", "inputFormat": "第一行一个正整数 $n$ 。  \n第二行 $n$ 个空格隔开的正整数 $a_1,a_2,\\cdots a_n$ 。", "outputFormat": "第一行一个字符串，如果能够做到，输出 ```TAK``` ，否则输出 ```NIE``` 。  \n若能做到，第二行 $n$ 个空格隔开的正整数，表示每个车厢进入的侧线编号。  \n如果有多解，输出任意一种。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2448)。", "hint": "对于 $100\\%$ 的数据，有 $n \\le 1 \\times 10^5$。\n\nTranslated by Diamond_duke，来源 LOJ。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2010] KOL-Railway", "background": "", "description": "A railroad siding consists of two (dead-end) sidetracks 1 and 2.\n\nThe siding is entered by track A, and left by track B (see figure below).\n\nThere are ![](http://main.edu.pl/images/OI17/kol-en-tex.1.png) cars on track A, numbered from ![](http://main.edu.pl/images/OI17/kol-en-tex.2.png) to ![](http://main.edu.pl/images/OI17/kol-en-tex.3.png).\n\nThey are arranged in such a way that they enter the siding in the order    ![](http://main.edu.pl/images/OI17/kol-en-tex.4.png).\n\nThe cars are to be transferred to the siding, so that they leave it by track B    in the order ![](http://main.edu.pl/images/OI17/kol-en-tex.5.png).\n\nEach car is to be transferred once from track A to one of the sidetracks 1 or 2,    and later (possibly after some transfers of the remaining cars) once from that    sidetrack to the track B.\n\nThe sidetracks are long enough to store even the longest trains, so there is    no need to worry about their capacity.", "inputFormat": "The first line of the standard input holds one integer ![](http://main.edu.pl/images/OI17/kol-en-tex.6.png) (![](http://main.edu.pl/images/OI17/kol-en-tex.7.png))      that denotes the number of cars for transfer.\n\nThe second line stores the numbers ![](http://main.edu.pl/images/OI17/kol-en-tex.8.png) that are a permutation of ![](http://main.edu.pl/images/OI17/kol-en-tex.9.png)      (i.e., each ![](http://main.edu.pl/images/OI17/kol-en-tex.10.png) belongs to ![](http://main.edu.pl/images/OI17/kol-en-tex.11.png), and all these numbers are unique),      separated by single spaces.\n", "outputFormat": "The first line of the standard output should contain the word TAK      (yes in Polish) if there is a way of transferring the cars so that they      enter track B in the order ![](http://main.edu.pl/images/OI17/kol-en-tex.12.png), or the word NIE      (no in Polish) if it is impossible.\n\nIf the answer is TAK, the second line should give, separated by      single spaces, the numbers of sidetracks (1 or 2) to which successive cars      ![](http://main.edu.pl/images/OI17/kol-en-tex.13.png) are moved in a correct transfer.\n\nIf there are several ways of making the transfer, choose one arbitrarily.\n", "hint": "对于 $100\\%$ 的数据，有 $n \\le 1 \\times 10^5$。", "locale": "en"}, "zh-CN": {"title": "[POI 2010] KOL-Railway", "background": "", "description": "**译自 POI 2010 Stage 1.「[Kolej](https://szkopul.edu.pl/problemset/problem/TJVrS_hRC8W5Q6ZBW6mETAIm/site/?key=statement)」**\n\n一个铁路包含两个侧线 $1$ 和 $2$ ，左边由 $A$ 进入，右边由 $B$ 出去（如下图所示）。  \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bdq72qy0.png)\n\n有 $n$ 个车厢在通道 $A$ 上，编号为 $1$ 到 $n$ ，它们按照 $a_1,a_2,\\cdots ,a_n$ 的顺序进入侧线，想要按照 $1,2,\\cdots ,n$ 的顺序从通道 $B$ 出去。    \n他们可以从 $A$ 到 $1$ 或 $2$ ，然后经过一系列转移从 $B$ 出去（不用考虑容量问题）。求是否能够做到，如果可以，请找出一种方案。", "inputFormat": "第一行一个正整数 $n$ 。  \n第二行 $n$ 个空格隔开的正整数 $a_1,a_2,\\cdots a_n$ 。", "outputFormat": "第一行一个字符串，如果能够做到，输出 ```TAK``` ，否则输出 ```NIE``` 。  \n若能做到，第二行 $n$ 个空格隔开的正整数，表示每个车厢进入的侧线编号。  \n如果有多解，输出任意一种。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2448)。", "hint": "对于 $100\\%$ 的数据，有 $n \\le 1 \\times 10^5$。\n\nTranslated by Diamond_duke，来源 LOJ。", "locale": "zh-CN"}}}
{"pid": "P3498", "type": "P", "difficulty": 5, "samples": [["21\n1 1 1 2 2 2 3 3 3 1 2 3 3 1 2 2 1 3 3 2 1", "6 1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "POI（波兰）", "Special Judge", "枚举", "哈希 hashing"], "title": "[POI 2010] KOR-Beads", "background": "", "description": "Byteasar once decided to start manufacturing necklaces.\n\nHe subsequently bought a very long string of colourful coral beads for a bargain price.\n\nByteasar now also has a machine that, for a given ![](http://main.edu.pl/images/OI17/kor-en-tex.1.png) (![](http://main.edu.pl/images/OI17/kor-en-tex.2.png)), can cut the string    into pieces (or substrings) of ![](http://main.edu.pl/images/OI17/kor-en-tex.3.png) coral beads (i.e., the first piece consists of the beads no.\n\n![](http://main.edu.pl/images/OI17/kor-en-tex.4.png), the second of ![](http://main.edu.pl/images/OI17/kor-en-tex.5.png), etc.).\n\nIf the length of the string (measured in coral beads) is not a multiple of ![](http://main.edu.pl/images/OI17/kor-en-tex.6.png),    then the last piece is not used, as it has length smaller than ![](http://main.edu.pl/images/OI17/kor-en-tex.7.png).\n\nFrom now on we denote the colours of the beads with positive integers.\n\nByteasar, always praising diversity, wonders how he should choose the number ![](http://main.edu.pl/images/OI17/kor-en-tex.8.png)    in order to get as many different substrings as possible.\n\nThe ends of the long string that will be cut are different: there are specific    beginning and ending (rather than two interchangeable endpoints), and the machine    of course starts cutting at the beginning. On the other hand, in the substrings    obtained from cutting the endpoints are interchangeable, and so the substrings    can be reversed. In other words, the substrings ![](http://main.edu.pl/images/OI17/kor-en-tex.9.png) and ![](http://main.edu.pl/images/OI17/kor-en-tex.10.png) are    identical to us. Write a program that determines the optimum value of ![](http://main.edu.pl/images/OI17/kor-en-tex.11.png) for Byteasar.", "inputFormat": "In the first line of the standard input there is an integer ![](http://main.edu.pl/images/OI17/kor-en-tex.37.png)      (![](http://main.edu.pl/images/OI17/kor-en-tex.38.png)) denoting the length of the string to cut.\n\nIn the second line there are ![](http://main.edu.pl/images/OI17/kor-en-tex.39.png) positive integers ![](http://main.edu.pl/images/OI17/kor-en-tex.40.png)      (![](http://main.edu.pl/images/OI17/kor-en-tex.41.png)), separated by single spaces, that denote      the colours of successive beads in Byteasar's string.\n", "outputFormat": "Two integers, separated by a single space, should be printed out to the first line of the standard ouput:\n\nthe (maximum) number of different substrings that can be obtained with an optimal choice    of parameter ![](http://main.edu.pl/images/OI17/kor-en-tex.42.png), and the number ![](http://main.edu.pl/images/OI17/kor-en-tex.43.png) of such optimal values of ![](http://main.edu.pl/images/OI17/kor-en-tex.44.png).\n\nThe second line should contain ![](http://main.edu.pl/images/OI17/kor-en-tex.45.png) integers separated by single spaces:\n\nthe values of parameter ![](http://main.edu.pl/images/OI17/kor-en-tex.46.png) that yield an optimum solution;    these can be given in arbitrary order.\n\n输出两行，第一行第一个数为最多可以得到的不同子串的个数，第二个数为取到最优解时的不同的k的个数。第二行包含若干个数，为取到最优解时的不同的k 。第二行中的不同的k可以按任意位置输出。\n", "hint": "$1≤n≤2\\times 10^5$，且 $\\forall 1\\le i\\le n$，有 $1\\le a_i\\le n$", "locale": "en", "translations": {"en": {"title": "[POI 2010] KOR-Beads", "background": "", "description": "Byteasar once decided to start manufacturing necklaces.\n\nHe subsequently bought a very long string of colourful coral beads for a bargain price.\n\nByteasar now also has a machine that, for a given ![](http://main.edu.pl/images/OI17/kor-en-tex.1.png) (![](http://main.edu.pl/images/OI17/kor-en-tex.2.png)), can cut the string    into pieces (or substrings) of ![](http://main.edu.pl/images/OI17/kor-en-tex.3.png) coral beads (i.e., the first piece consists of the beads no.\n\n![](http://main.edu.pl/images/OI17/kor-en-tex.4.png), the second of ![](http://main.edu.pl/images/OI17/kor-en-tex.5.png), etc.).\n\nIf the length of the string (measured in coral beads) is not a multiple of ![](http://main.edu.pl/images/OI17/kor-en-tex.6.png),    then the last piece is not used, as it has length smaller than ![](http://main.edu.pl/images/OI17/kor-en-tex.7.png).\n\nFrom now on we denote the colours of the beads with positive integers.\n\nByteasar, always praising diversity, wonders how he should choose the number ![](http://main.edu.pl/images/OI17/kor-en-tex.8.png)    in order to get as many different substrings as possible.\n\nThe ends of the long string that will be cut are different: there are specific    beginning and ending (rather than two interchangeable endpoints), and the machine    of course starts cutting at the beginning. On the other hand, in the substrings    obtained from cutting the endpoints are interchangeable, and so the substrings    can be reversed. In other words, the substrings ![](http://main.edu.pl/images/OI17/kor-en-tex.9.png) and ![](http://main.edu.pl/images/OI17/kor-en-tex.10.png) are    identical to us. Write a program that determines the optimum value of ![](http://main.edu.pl/images/OI17/kor-en-tex.11.png) for Byteasar.", "inputFormat": "In the first line of the standard input there is an integer ![](http://main.edu.pl/images/OI17/kor-en-tex.37.png)      (![](http://main.edu.pl/images/OI17/kor-en-tex.38.png)) denoting the length of the string to cut.\n\nIn the second line there are ![](http://main.edu.pl/images/OI17/kor-en-tex.39.png) positive integers ![](http://main.edu.pl/images/OI17/kor-en-tex.40.png)      (![](http://main.edu.pl/images/OI17/kor-en-tex.41.png)), separated by single spaces, that denote      the colours of successive beads in Byteasar's string.\n", "outputFormat": "Two integers, separated by a single space, should be printed out to the first line of the standard ouput:\n\nthe (maximum) number of different substrings that can be obtained with an optimal choice    of parameter ![](http://main.edu.pl/images/OI17/kor-en-tex.42.png), and the number ![](http://main.edu.pl/images/OI17/kor-en-tex.43.png) of such optimal values of ![](http://main.edu.pl/images/OI17/kor-en-tex.44.png).\n\nThe second line should contain ![](http://main.edu.pl/images/OI17/kor-en-tex.45.png) integers separated by single spaces:\n\nthe values of parameter ![](http://main.edu.pl/images/OI17/kor-en-tex.46.png) that yield an optimum solution;    these can be given in arbitrary order.\n\n输出两行，第一行第一个数为最多可以得到的不同子串的个数，第二个数为取到最优解时的不同的k的个数。第二行包含若干个数，为取到最优解时的不同的k 。第二行中的不同的k可以按任意位置输出。\n", "hint": "$1≤n≤2\\times 10^5$，且 $\\forall 1\\le i\\le n$，有 $1\\le a_i\\le n$", "locale": "en"}, "zh-CN": {"title": "[POI 2010] KOR-Beads", "background": "", "description": "Byteasar 有 $n$ 个珠子，第 $i$ 个颜色为 $a_i$，和一台机器。\n\nByteasar 可以选定一个值 $k$，然后机器会让 $1\\sim k$ 的珠子组成项链 $b_1$，$k+1\\sim 2k$ 的珠子组成项链 $b_2$，以此类推，**最后 $n\\bmod k$ 个珠子不会组成项链，而是被丢弃**。\n\n现在让你求出一个 $k$ 值，使得在 $\\left\\lfloor\\dfrac{n}{k}\\right\\rfloor$ 个项链 $b$ 中，存在 **不同的** 项链数量最多。\n\n项链可以反转，形式化地，$b_x$ 和 $b_y$ 不同，当且仅当存在至少一个 $i$，使得 $b_{x,i}\\ne b_{y,i}$ 且 $b_{x,i} \\ne b_{y,k-i+1}$。\n\n例如 $[1,2,3]$ 和 $[3,2,1]$ 是相同的，而 $[1,2,3]$ 和 $[2,3,1]$ 是不同的。", "inputFormat": "输入两行，第一行为 $n$。\n\n第二行为 $n$ 个正整数，第 $i$ 个正整数代表 $a_i$。", "outputFormat": "输出两行。\n\n第一行两个整数，分别代表不同的项链最多的数量，以及不同的项链最多时，$k$ 的个数。\n\n第二行若干个整数，代表所有能使不同的项链最多的 $k$ 值，这可以按任意顺序输出。\n\n### 【样例解释】\n\n$a$ 为 $[1,1,1,2,2,2,3,3,3,1,2,3,3,1,2,2,1,3,3,2,1]$。\n\n- $k=1$ 的时候，我们得到 $3$ 个不同的项链 $b$：$[1],[2],[3]$。\n- $k=2$ 的时候，我们得到 $6$ 个不同的项链：$[1,1],[1,2],[2,2],[2,3],[3,3],[3,1]$。\n- $k=3$ 的时候，我们得到 $5$ 个不同的项链：$[1,1,1],[2,2,2],[3,3,3],[1,2,3],[3,1,2]$。\n- $k=4$ 的时候，我们得到 $5$ 个不同的项链：$[1,1,1,2],[2,2,3,3],[3,1,2,3],[3,1,2,2],[1,3,3,2]$。", "hint": "对于全部数据，$1\\le n\\le2\\times 10^5$，且 $\\forall 1\\le i\\le n$，有 $1\\le a_i\\le n$。", "locale": "zh-CN"}}}
{"pid": "P3499", "type": "P", "difficulty": 6, "samples": [["3\n4 3 4", "4\n1"], ["1\n6", "1\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2010", "POI（波兰）", "素数判断,质数,筛法"], "title": "[POI 2010] NAJ-Divine Divisor", "background": "POI 2010 Round I - [Divine Divisor](https://szkopul.edu.pl/problemset/problem/hOwg83Xw_OnTpfQ9SroS0OJA/site/?key=statement).", "description": "给出一个 $n$，请你找出最大的 $k$，使得存在 $d>1$，满足 $d^k\\mid n$。\n\n在此基础上，求出满足该条件的 $d$ 有多少个。", "inputFormat": "第一行一个正整数 $m$ 。  \n第二行 $m$ 个空格隔开的正整数 $a_1,a_2,\\cdots ,a_m$ ，则 $n=\\prod_{i=1}^ma_i$ 。", "outputFormat": "第一行一个正整数，表示最大的 $k$ 。  \n第二行也是一个正整数，表示满足 $d>1$ 且 $d^k\\mid n$ 的 $d$ 有多少个。\n", "hint": "对于$100\\%$的数据，$1\\le m\\le 600$，且 $\\forall 1\\le i\\le m$，有 $1\\le a_i\\le 10^{18}$。\n\n如果你输出的第一行或者第二行完全正确，可以获得 $50\\%$ 的分数。\n\n---\n\n作者：Jakub Radoszewski\n\nTranslated By diamond_duke，来自 [LOJ](https://loj.ac/p/2428)。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2010] Divine Divisor", "background": "Source: POI 2010 Round I - [Divine Divisor](https://szkopul.edu.pl/problemset/problem/hOwg83Xw_OnTpfQ9SroS0OJA/site/?key=statement).", "description": "\nAn integer $N > 1$ is given. We say that an integer $d > 1$ is a divisor of $N$ with multiplicity $k > 0$ ($k$ is integer) if $d^k \\mid N$ and $d^{k+1}$ does not divide $N$. For example, the number $N = 18 = 16 \\cdot 3$ has the following divisors: 2 with multiplicity 4, 3 with multiplicity 1, 4 with multiplicity 2, 6 with multiplicity 1, and so on.\n\nWe say that a number $d$ is a *divine divisor* of the number $N$ if $d$ is a divisor of $N$ with multiplicity $k$ and $N$ has no divisors with multiplicities greater than $k$. For example, the sole divine divisor of 48 is 2 (with multiplicity 4), and the divine divisors of 6 are: 2, 3 and 6 (each with multiplicity 1).\n\nYour task is to determine the multiplicity of divine divisors of $N$ and the number of its divine divisors.\n\n### Input\n\n### Output\n### Example\nFor the input data:\n```\n3\n4 3 4\n```\nthe correct result is:\n```\n4\n1\n```\nwhereas for the input:\n```\n1\n6\n```\nthe correct result is:\n```\n1\n3\n```\n\n### Grading\nShould your program print out the correct multiplicity $k$ of a divine divisor of $N$, but fail to print in the second line the correct number $D$ of divine divisors of $N$ (or fail to print that number at all), it will be awarded 50% of the score for that particular test, scaled accordingly if it exceeds half the time limit.\n\n", "inputFormat": "\nThe number $N$ is given on the standard input, though in a somewhat unusual way. The first line holds a single integer $n$ ($1 \\le n \\le 600$). The second line holds $n$ integers $a_i$ ($2 \\le a_i \\le 10^{18}$) separated by single spaces. These denote that $N = a_1 \\cdot a_2 \\cdot \\dots \\cdot a_n$.", "outputFormat": "\nThe first line of the standard output should hold the maximum integer $k$ such that there exists a divisor $d$ of $N$ such that $d^k \\mid N$. The second line should hold a single integer $D$ that is the number of (divine) divisors of $N$ with multiplicity $k$.\n", "hint": "\nShould your program print out the correct multiplicity $k$ of a divine divisor of $N$, but fail to print in the second line the correct number $D$ of divine divisors of $N$ (or fail to print that number at all), it will be awarded 50% of the score for that particular test.\n\nTask author: Jakub Radoszewski.", "locale": "en"}, "zh-CN": {"title": "[POI 2010] NAJ-Divine Divisor", "background": "POI 2010 Round I - [Divine Divisor](https://szkopul.edu.pl/problemset/problem/hOwg83Xw_OnTpfQ9SroS0OJA/site/?key=statement).", "description": "给出一个 $n$，请你找出最大的 $k$，使得存在 $d>1$，满足 $d^k\\mid n$。\n\n在此基础上，求出满足该条件的 $d$ 有多少个。", "inputFormat": "第一行一个正整数 $m$ 。  \n第二行 $m$ 个空格隔开的正整数 $a_1,a_2,\\cdots ,a_m$ ，则 $n=\\prod_{i=1}^ma_i$ 。", "outputFormat": "第一行一个正整数，表示最大的 $k$ 。  \n第二行也是一个正整数，表示满足 $d>1$ 且 $d^k\\mid n$ 的 $d$ 有多少个。\n", "hint": "对于$100\\%$的数据，$1\\le m\\le 600$，且 $\\forall 1\\le i\\le m$，有 $1\\le a_i\\le 10^{18}$。\n\n如果你输出的第一行或者第二行完全正确，可以获得 $50\\%$ 的分数。\n\n---\n\n作者：Jakub Radoszewski\n\nTranslated By diamond_duke，来自 [LOJ](https://loj.ac/p/2428)。", "locale": "zh-CN"}}}
{"pid": "P3500", "type": "P", "difficulty": 3, "samples": [["7\n1 5 4 5 7 8 6\n4\n5\n1 5 5 8 6\n3\n2 2 2\n3\n5 7 8\n4\n1 5 7 4", "TAK\nNIE\nTAK\nNIE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["模拟", "2010", "二分", "POI（波兰）"], "title": "[POI 2010] TES-Intelligence Test", "background": "", "description": "One of the tasks in the Byteotian Intelligence Test (BIT) is to cross out    numbers from an initial sequence in such a way that leaves as a result    certain given sequences.\n\nByteasar longs to become the IQ Master of Byteotia, but he is no good in    this kind of tasks.\n\nBut since practice makes perfect, he intends to practise a lot.\n\nSo much in fact that he asks you to write a program that will facilitate    the training by verifying his answers quickly.", "inputFormat": "The first line of the standard input contains one integer $m$ ($1\\le m\\le 1\\ 000\\ 000$).\n\nThe second line holds $m$ integers $a_1,a_2,\\cdots,a_m$ ($1\\le a_i\\le 1\\ 000\\ 000$ for $1\\le i\\le m$), separated by single spaces,      that constitute the initial sequence of the test.\n\nThe third line of the input holds one integer $n$.\n\nThe following $2n$ lines describe the sequences to be obtained by crossing out      numbers from the initial sequence.\n\nEach sequence's description takes two successive lines.\n\nThe first of these two lines contains an integer $m_i$ ($1\\le m_i\\le 1\\ 000\\ 000$).\n\nThe second contains an $m_i$-element long sequence of integers $b_{i,1},b_{i,2},\\cdots,b_{i,m_i}$($1\\le b_{i,j}\\le 1\\ 000\\ 000$ for $1\\le j\\le m_i$)separated by single spaces. You may assume that the total length on given $n$ sequences does not exceed $1\\ 000\\ 000$.", "outputFormat": "Your program should print out $n$ lines to the standard output.\n\nThe $i$-th line (for $1\\le i\\le n$) should hold one word,      \"TAK\" (yes in Polish) if the $i$-th input sequence can be obtained by      crossing out (i.e., removing) some, not necessarily contiguous, numbers from the initial sequence,      or \"NIE\" (no in Polish) otherwise. Mind you, only the words should be printed,      no quotation marks. Of course, the order of the numbers left after crossing out is important,      as can be seen in the example.", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2010] TES-Intelligence Test", "background": "", "description": "One of the tasks in the Byteotian Intelligence Test (BIT) is to cross out    numbers from an initial sequence in such a way that leaves as a result    certain given sequences.\n\nByteasar longs to become the IQ Master of Byteotia, but he is no good in    this kind of tasks.\n\nBut since practice makes perfect, he intends to practise a lot.\n\nSo much in fact that he asks you to write a program that will facilitate    the training by verifying his answers quickly.", "inputFormat": "The first line of the standard input contains one integer $m$ ($1\\le m\\le 1\\ 000\\ 000$).\n\nThe second line holds $m$ integers $a_1,a_2,\\cdots,a_m$ ($1\\le a_i\\le 1\\ 000\\ 000$ for $1\\le i\\le m$), separated by single spaces,      that constitute the initial sequence of the test.\n\nThe third line of the input holds one integer $n$.\n\nThe following $2n$ lines describe the sequences to be obtained by crossing out      numbers from the initial sequence.\n\nEach sequence's description takes two successive lines.\n\nThe first of these two lines contains an integer $m_i$ ($1\\le m_i\\le 1\\ 000\\ 000$).\n\nThe second contains an $m_i$-element long sequence of integers $b_{i,1},b_{i,2},\\cdots,b_{i,m_i}$($1\\le b_{i,j}\\le 1\\ 000\\ 000$ for $1\\le j\\le m_i$)separated by single spaces. You may assume that the total length on given $n$ sequences does not exceed $1\\ 000\\ 000$.", "outputFormat": "Your program should print out $n$ lines to the standard output.\n\nThe $i$-th line (for $1\\le i\\le n$) should hold one word,      \"TAK\" (yes in Polish) if the $i$-th input sequence can be obtained by      crossing out (i.e., removing) some, not necessarily contiguous, numbers from the initial sequence,      or \"NIE\" (no in Polish) otherwise. Mind you, only the words should be printed,      no quotation marks. Of course, the order of the numbers left after crossing out is important,      as can be seen in the example.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2010] TES-Intelligence Test", "background": "", "description": "**译自 POI 2010 Stage 1.「[Intelligence Test](https://szkopul.edu.pl/problemset/problem/Arkza0f7GKKb-m1YZJulnlMk/site/?key=statement)」**\n\n给出一个母串 $a_1,a_2,a_3,\\cdots ,a_n$ ，若干次询问，每次询问给出一个子串 $b_1,b_2,\\cdots b_m$ ，请你求出这个子串是不是母串的子序列。", "inputFormat": "第一行一个正整数 $n$ 。  \n第二行 $n$ 个空格隔开的正整数 $a_1,a_2,\\cdots ,a_n$ ，表示母串。  \n第三行一个正整数 $q$ ，表示询问次数。  \n接下来 $2 \\times q$ 行，每两行表示一次询问，其中的第一行是一个正整数 $m$ ，第二行是 $m$ 个空格隔开的正整数表示 $b_1,b_2,\\cdots ,b_m$ ，表示询问的子串。", "outputFormat": "输出共 $q$ 行，每行一个字符串。  \n若第 $i$ 次询问的串是母串的子序列，那么第 $i$ 行应为 ```TAK``` ，否则应为 ```NIE``` 。\n\n对于 $100\\%$ 的数据，有 $1\\le n,m,a_i,b_i\\le 1\\ 000\\ 000$ ，且 $\\sum m\\le 1\\ 000\\ 000$ ，这里 $\\sum m$ 表示 $q$ 组询问的 $m$ 之和。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2429)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3501", "type": "P", "difficulty": 5, "samples": [["8\n11001011", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "二分", "POI（波兰）", "哈希 hashing", "Manacher 算法"], "title": "[POI 2010] ANT-Antisymmetry", "background": "", "description": "Byteasar studies certain strings of zeroes and ones.\n\nLet ![](http://main.edu.pl/images/OI17/ant-en-tex.1.png) be such a string. By ![](http://main.edu.pl/images/OI17/ant-en-tex.2.png) we will denote the reversed (i.e., \"read backwards\") string ![](http://main.edu.pl/images/OI17/ant-en-tex.3.png),    and by ![](http://main.edu.pl/images/OI17/ant-en-tex.4.png) we will denote the string obtained from ![](http://main.edu.pl/images/OI17/ant-en-tex.5.png) by changing all the zeroes to ones and ones to zeroes.\n\nByteasar is interested in antisymmetry, while all things symmetric bore him.\n\nAntisymmetry however is not a mere lack of symmetry.\n\nWe will say that a (nonempty) string ![](http://main.edu.pl/images/OI17/ant-en-tex.6.png) is antisymmetric if, for every position ![](http://main.edu.pl/images/OI17/ant-en-tex.7.png) in ![](http://main.edu.pl/images/OI17/ant-en-tex.8.png),    the ![](http://main.edu.pl/images/OI17/ant-en-tex.9.png)-th last character is different than the ![](http://main.edu.pl/images/OI17/ant-en-tex.10.png)-th (first) character.\n\nIn particular, a string ![](http://main.edu.pl/images/OI17/ant-en-tex.11.png) consisting of zeroes and ones is antisymmetric if and only if    ![](http://main.edu.pl/images/OI17/ant-en-tex.12.png).\n\nFor example, the strings 00001111 and 010101 are antisymmetric, while 1001 is not.\n\nIn a given string consisting of zeroes and ones we would like to determine the number of contiguous    nonempty antisymmetric fragments.\n\nDifferent fragments corresponding to the same substrings should be counted multiple times.", "inputFormat": "The first line of the standard input contains an integer ![](http://main.edu.pl/images/OI17/ant-en-tex.13.png) (![](http://main.edu.pl/images/OI17/ant-en-tex.14.png)) that denotes the length of the string.\n\nThe second line gives a string of 0 and/or 1 of length ![](http://main.edu.pl/images/OI17/ant-en-tex.15.png).\n\nThere are no spaces in the string.\n", "outputFormat": "The first and only line of the standard output should contain a single integer,      namely the number of contiguous (non empty) fragments of the given string      that are antisymmetric.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2010] ANT-Antisymmetry", "background": "", "description": "Byteasar studies certain strings of zeroes and ones.\n\nLet ![](http://main.edu.pl/images/OI17/ant-en-tex.1.png) be such a string. By ![](http://main.edu.pl/images/OI17/ant-en-tex.2.png) we will denote the reversed (i.e., \"read backwards\") string ![](http://main.edu.pl/images/OI17/ant-en-tex.3.png),    and by ![](http://main.edu.pl/images/OI17/ant-en-tex.4.png) we will denote the string obtained from ![](http://main.edu.pl/images/OI17/ant-en-tex.5.png) by changing all the zeroes to ones and ones to zeroes.\n\nByteasar is interested in antisymmetry, while all things symmetric bore him.\n\nAntisymmetry however is not a mere lack of symmetry.\n\nWe will say that a (nonempty) string ![](http://main.edu.pl/images/OI17/ant-en-tex.6.png) is antisymmetric if, for every position ![](http://main.edu.pl/images/OI17/ant-en-tex.7.png) in ![](http://main.edu.pl/images/OI17/ant-en-tex.8.png),    the ![](http://main.edu.pl/images/OI17/ant-en-tex.9.png)-th last character is different than the ![](http://main.edu.pl/images/OI17/ant-en-tex.10.png)-th (first) character.\n\nIn particular, a string ![](http://main.edu.pl/images/OI17/ant-en-tex.11.png) consisting of zeroes and ones is antisymmetric if and only if    ![](http://main.edu.pl/images/OI17/ant-en-tex.12.png).\n\nFor example, the strings 00001111 and 010101 are antisymmetric, while 1001 is not.\n\nIn a given string consisting of zeroes and ones we would like to determine the number of contiguous    nonempty antisymmetric fragments.\n\nDifferent fragments corresponding to the same substrings should be counted multiple times.", "inputFormat": "The first line of the standard input contains an integer ![](http://main.edu.pl/images/OI17/ant-en-tex.13.png) (![](http://main.edu.pl/images/OI17/ant-en-tex.14.png)) that denotes the length of the string.\n\nThe second line gives a string of 0 and/or 1 of length ![](http://main.edu.pl/images/OI17/ant-en-tex.15.png).\n\nThere are no spaces in the string.\n", "outputFormat": "The first and only line of the standard output should contain a single integer,      namely the number of contiguous (non empty) fragments of the given string      that are antisymmetric.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2010] ANT-Antisymmetry", "background": "", "description": "**译自 POI 2010 Stage 2. Day 0「[Antisymmetry](https://szkopul.edu.pl/problemset/problem/EDxOyJiFZWb_PYVaYhhnhU0-/site/?key=statement)」**\n\n对于一个 $0/1$ 字符串，如果将这个字符串 $0$ 和 $1$ 取反后，再将整个串反过来和原串一样，就称作「反对称」字符串。比如 $00001111$ 和 $010101$ 就是反对称的，而 $1001$ 就不是。  \n现在给出一个长度为 $n$ 的 $0/1$ 字符串，求它有多少个子串是反对称的，注意这里相同的子串出现在不同的位置会被重复计算。", "inputFormat": "第一行一个正整数 $n$ 。  \n第二行一个长度为 $n$ 的 $0/1$ 字符串。", "outputFormat": "一行一个整数，表示原串的反对称子串个数。", "hint": "样例的 $7$ 个反对称子串分别是：$01$（出现两次），$10$（出现两次），$0101$，$1100$ 和 $001011$。\n\n对于 $100\\%$ 的数据， $1\\le n\\le 500\\ 000$ 。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2452)。", "locale": "zh-CN"}}}
{"pid": "P3502", "type": "P", "difficulty": 6, "samples": [["4 5\nmonika\ntomek\nszymon\nbernard", "23"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2010", "POI（波兰）", "矩阵加速", "AC 自动机"], "title": "[POI 2010] CHO-Hamsters", "background": "", "description": "Byteasar breeds hamsters.\n\nEach hamster has a unique name,    consisting of lower case letters of the English alphabet.\n\n    The hamsters have a vast and comfortable cage.\n\n    Byteasar intends to place a display under the cage to visualize the names of his hamsters.\n\n    This display is simply a sequence of letters, each of which can be either lit or not independently.\n\nOnly one name will be displayed simultaneously.\n\nThe lit letters forming the name have to stand next to each other,    i.e., form a contiguous subsequence.\n\nByteasar wants to be able to display the names of the hamsters on at least ![](http://main.edu.pl/images/OI17/cho-en-tex.1.png) different positions.\n\nHowever, he allows displaying the same name on multiple different positions,    and does not require to be able to display each and every hamster's name.\n\nNote that the occurrences of the names on the display can overlap.\n\nYou can assume that no hamster's name occurs (as a contiguous fragment) in any other hamster's name.\n\nBytesar asks your help in determining the minimum number of letters the display has to have.\n\nIn other words, you are to determine the minimum length of a string    (consisting of non-capital letters of the English alphabet)    that has at least ![](http://main.edu.pl/images/OI17/cho-en-tex.2.png) total occurrences of the hamsters' names (counting multiplicities).\n\n(We say that a string ![](http://main.edu.pl/images/OI17/cho-en-tex.3.png) occurs in the string ![](http://main.edu.pl/images/OI17/cho-en-tex.4.png) if ![](http://main.edu.pl/images/OI17/cho-en-tex.5.png) forms a contiguous fragment of ![](http://main.edu.pl/images/OI17/cho-en-tex.6.png).)\n\n", "inputFormat": "The first line of the standard input holds two integers ![](http://main.edu.pl/images/OI17/cho-en-tex.7.png) and ![](http://main.edu.pl/images/OI17/cho-en-tex.8.png)      (![](http://main.edu.pl/images/OI17/cho-en-tex.9.png), ![](http://main.edu.pl/images/OI17/cho-en-tex.10.png)), separated by a single space, that denote      the number of Byteasar's hamsters and the minimum number of occurrences of the hamsters' names on the display.\n\nEach of the following ![](http://main.edu.pl/images/OI17/cho-en-tex.11.png) lines contains a non-empty string of non-capital letters of the English alphabet      that is the hamster's name.\n\nThe total length of all names does not exceed ![](http://main.edu.pl/images/OI17/cho-en-tex.12.png) letters.\n", "outputFormat": "The first and only line of the standard output should hold a single integer      - the minimum number of letters the display has to have.\n", "hint": "$1\\le n\\le 200$，$1\\le m\\le 10^9$ ，所有字符串的总长 $\\le 10^5$。\n", "locale": "en", "translations": {"en": {"title": "[POI 2010] CHO-Hamsters", "background": "", "description": "Byteasar breeds hamsters.\n\nEach hamster has a unique name,    consisting of lower case letters of the English alphabet.\n\n    The hamsters have a vast and comfortable cage.\n\n    Byteasar intends to place a display under the cage to visualize the names of his hamsters.\n\n    This display is simply a sequence of letters, each of which can be either lit or not independently.\n\nOnly one name will be displayed simultaneously.\n\nThe lit letters forming the name have to stand next to each other,    i.e., form a contiguous subsequence.\n\nByteasar wants to be able to display the names of the hamsters on at least ![](http://main.edu.pl/images/OI17/cho-en-tex.1.png) different positions.\n\nHowever, he allows displaying the same name on multiple different positions,    and does not require to be able to display each and every hamster's name.\n\nNote that the occurrences of the names on the display can overlap.\n\nYou can assume that no hamster's name occurs (as a contiguous fragment) in any other hamster's name.\n\nBytesar asks your help in determining the minimum number of letters the display has to have.\n\nIn other words, you are to determine the minimum length of a string    (consisting of non-capital letters of the English alphabet)    that has at least ![](http://main.edu.pl/images/OI17/cho-en-tex.2.png) total occurrences of the hamsters' names (counting multiplicities).\n\n(We say that a string ![](http://main.edu.pl/images/OI17/cho-en-tex.3.png) occurs in the string ![](http://main.edu.pl/images/OI17/cho-en-tex.4.png) if ![](http://main.edu.pl/images/OI17/cho-en-tex.5.png) forms a contiguous fragment of ![](http://main.edu.pl/images/OI17/cho-en-tex.6.png).)\n\n", "inputFormat": "The first line of the standard input holds two integers ![](http://main.edu.pl/images/OI17/cho-en-tex.7.png) and ![](http://main.edu.pl/images/OI17/cho-en-tex.8.png)      (![](http://main.edu.pl/images/OI17/cho-en-tex.9.png), ![](http://main.edu.pl/images/OI17/cho-en-tex.10.png)), separated by a single space, that denote      the number of Byteasar's hamsters and the minimum number of occurrences of the hamsters' names on the display.\n\nEach of the following ![](http://main.edu.pl/images/OI17/cho-en-tex.11.png) lines contains a non-empty string of non-capital letters of the English alphabet      that is the hamster's name.\n\nThe total length of all names does not exceed ![](http://main.edu.pl/images/OI17/cho-en-tex.12.png) letters.\n", "outputFormat": "The first and only line of the standard output should hold a single integer      - the minimum number of letters the display has to have.\n", "hint": "$1\\le n\\le 200$，$1\\le m\\le 10^9$ ，所有字符串的总长 $\\le 10^5$。\n", "locale": "en"}, "zh-CN": {"title": "[POI 2010] CHO-Hamsters", "background": "", "description": "Byteasar 养了许多仓鼠。\n\n每只仓鼠都有一个唯一的名字，由小写英文字母组成。\n\n这些仓鼠有一个宽敞舒适的笼子。\n\nByteasar 打算在笼子下方放置一个显示器，以可视化显示他仓鼠的名字。\n\n这个显示器只是一个字母序列，每个字母可以独立地亮起或不亮起。\n\n同时只会显示一个名字。\n\n亮起的字母必须相邻，即形成一个连续的子序列。\n\nByteasar 希望能够在至少 $m$ 个不同的位置显示这些仓鼠的名字。\n\n然而，他允许在多个不同的位置显示相同的名字，并且不要求能够显示每一个仓鼠的名字。\n\n注意，名字在显示器上的出现可以重叠。\n\n可以假设没有任何仓鼠的名字会作为连续片段出现在其他仓鼠的名字中。\n\nByteasar 请求你帮助确定显示器需要的最小字母数。\n\n换句话说，你需要确定一个字符串的最小长度（由非大写英文字母组成），使得仓鼠名字的总出现次数（计入重复）至少为 $m$。\n\n（我们说字符串 $A$ 出现在字符串 $B$ 中，如果 $A$ 形成 $B$ 的一个连续片段。）", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $m$ ($1 \\le n \\le 200$, $1 \\le m \\le 10^9$)，用一个空格分隔，表示 Byteasar 的仓鼠数量和显示器上仓鼠名字出现的最小次数。\n\n接下来的 $n$ 行中的每一行包含一个非空的非大写英文字母字符串，表示仓鼠的名字。\n\n所有名字的总长度不超过 $10^5$ 个字母。", "outputFormat": "标准输出的第一行应包含一个整数——显示器需要的最小字母数。", "hint": "$1 \\le n \\le 200$，$1 \\le m \\le 10^9$，所有字符串的总长 $\\le 10^5$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3503", "type": "P", "difficulty": 5, "samples": [["5 6\n1 2 1 1 5\n1 2 3 4 5 6", "5 5 2 1 1 0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "二分", "POI（波兰）", "前缀和", "双指针 two-pointer", "单调栈"], "title": "[POI 2010] KLO-Blocks", "background": null, "description": "Bytie has got a set of wooden blocks for his birthday.\n\nThe blocks are indistinguishable from one another, as they are all cubes of the same size.\n\n    Bytie forms piles by putting one block atop another.\n\nSoon he had a whole rank of such piles, one next to another in a straight line.\n\nOf course, the piles can have different heights.\n\nBytie's father, Byteasar, gave his son a puzzle.\n\nHe gave him a number ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.1.png)  and asked to rearrange the blocks in such a way that    the number of successive piles of height at least ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.1.png)  is maximised.\n\nHowever, Bytie is only ever allowed to pick the top block from a pile strictly    higher than ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.1.png)  and place it atop one of the piles next to it.\n\nFurther, Bytie is not allowed to form new piles, he can only move blocks    between those already existing.", "inputFormat": "In the first line of the standard input there are two integers separated by a single space:\n\n![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.4.png)  (![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.5.png)),  denoting the number of piles, and ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.6.png)  (![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.7.png)),       denoting the number of Byteasar's requests.\n\nThe piles are numbered from ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.8.png)  to ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.9.png). \n\nIn the second line there are ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.10.png)  integers ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.11.png)       separated by single spaces (![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.12.png)). \n\nThe number ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.13.png)  denotes the height of the ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.13.png)-th  pile.\n\nThe third line holds ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.15.png)  integers ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.16.png)  separated by single spaces (![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.17.png)).  These are the subsequent values of the parameter ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.18.png)  for which the puzzle is to be solved. That is, the largest number of successive piles of height at least ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.18.png)  that can be obtained by allowed moves is to be determined for each given value of the parameter ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.18.png).", "outputFormat": "Your program should print out ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.21.png)  integers, separated by single spaces,      to the standard output - the ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.22.png)-th  of which should be the answer to the puzzle      for the given initial piles set-up and the parameter ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.23.png).", "hint": "$1\\le n\\le 10^6$，$1\\le m\\le 50$，$1\\le a_i,k\\le 10^9$", "locale": "en", "translations": {"en": {"title": "[POI 2010] KLO-Blocks", "background": null, "description": "Bytie has got a set of wooden blocks for his birthday.\n\nThe blocks are indistinguishable from one another, as they are all cubes of the same size.\n\n    Bytie forms piles by putting one block atop another.\n\nSoon he had a whole rank of such piles, one next to another in a straight line.\n\nOf course, the piles can have different heights.\n\nBytie's father, Byteasar, gave his son a puzzle.\n\nHe gave him a number ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.1.png)  and asked to rearrange the blocks in such a way that    the number of successive piles of height at least ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.1.png)  is maximised.\n\nHowever, Bytie is only ever allowed to pick the top block from a pile strictly    higher than ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.1.png)  and place it atop one of the piles next to it.\n\nFurther, Bytie is not allowed to form new piles, he can only move blocks    between those already existing.", "inputFormat": "In the first line of the standard input there are two integers separated by a single space:\n\n![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.4.png)  (![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.5.png)),  denoting the number of piles, and ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.6.png)  (![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.7.png)),       denoting the number of Byteasar's requests.\n\nThe piles are numbered from ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.8.png)  to ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.9.png). \n\nIn the second line there are ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.10.png)  integers ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.11.png)       separated by single spaces (![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.12.png)). \n\nThe number ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.13.png)  denotes the height of the ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.13.png)-th  pile.\n\nThe third line holds ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.15.png)  integers ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.16.png)  separated by single spaces (![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.17.png)).  These are the subsequent values of the parameter ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.18.png)  for which the puzzle is to be solved. That is, the largest number of successive piles of height at least ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.18.png)  that can be obtained by allowed moves is to be determined for each given value of the parameter ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.18.png).", "outputFormat": "Your program should print out ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.21.png)  integers, separated by single spaces,      to the standard output - the ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.22.png)-th  of which should be the answer to the puzzle      for the given initial piles set-up and the parameter ![]( https://szkopul.edu.pl/problemset/problem/4BL9eUWjrvT7ecMUJcmSuJI3/site/images/OI17/klo-en-tex.23.png).", "hint": "$1\\le n\\le 10^6$，$1\\le m\\le 50$，$1\\le a_i,k\\le 10^9$", "locale": "en"}, "zh-CN": {"title": "[POI 2010] KLO-Blocks", "background": "", "description": "Bytie 在生日时收到了一套木块。这些木块彼此无法区分，因为它们都是相同大小的立方体。Bytie 通过将一个木块放在另一个木块上形成了堆。不久，他就有了一整排这样的堆，一个接一个地排成一条直线。当然，这些堆的高度可以不同。Bytie 的父亲 Byteasar 给了他一个谜题。他给了他一个数字 $k$，并要求重新排列这些木块，使得高度至少为 $k$ 的连续堆的数量最大化。然而，Bytie 只能从严格高于 $k$ 的堆中取出顶部的木块，并将其放在相邻的堆上。此外，Bytie 不允许形成新的堆，他只能在已经存在的堆之间移动木块。", "inputFormat": "标准输入的第一行有两个用空格分隔的整数：$n$ ($1 \\le n \\le 10^6$)，表示堆的数量，以及 $m$ ($1 \\le m \\le 50$)，表示 Byteasar 的请求数量。堆从 $1$ 编号到 $n$。第二行有 $n$ 个整数 $a_i$，用空格分隔 ($1 \\le a_i \\le 10^9$)。数字 $a_i$ 表示第 $i$ 个堆的高度。第三行有 $m$ 个整数 $k_j$，用空格分隔 ($1 \\le k_j \\le 10^9$)，表示每个请求的参数 $k_j$。", "outputFormat": "你的程序应输出 $m$ 个整数，用空格分隔，其中第 $j$ 个整数是给定初始堆设置和参数 $k_j$ 的谜题答案。", "hint": "$1 \\le n \\le 10^6$，$1 \\le m \\le 50$，$1 \\le a_i, k \\le 10^9$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3504", "type": "P", "difficulty": 6, "samples": [["5 4 10\n5 5\n3 0\n-1 -1\n-3 4\n1 10\n1 0\n-1 0\n1 6\n-2 5", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "POI（波兰）"], "title": "[POI 2010] OWC-Sheep", "background": "", "description": "The habitants of the Byteotian Highland bred sheep for centuries.\n\nEvery sane shepherd has a fenced pasture in the shape of a convex1 polygon    for the sheep to graze on.\n\nEvery sane sheep in turn has its own favourite feeding spot on the pasture where it spends all days.\n\nSometimes however, the sheep want to play. As they play in pairs, every shepherd keeps an even number of sheep,    so that his every sheep has a partner to play with.\n\nThe shepherds are concerned about a decree recently issued by the Byteburg's High Commissioner for Agriculture.\n\nThe decree states that as of the next year the sheep can only graze on triangle-shaped pastures.\n\nThus every shepherd whose pasture is an ![](http://main.edu.pl/images/OI17/owc-en-tex.1.png)-gon for ![](http://main.edu.pl/images/OI17/owc-en-tex.2.png) is to partition it into triangles by putting ![](http://main.edu.pl/images/OI17/owc-en-tex.3.png)    fences inside.\n\nEach single new fence, of course, is going to be a segment connecting two vertices of the polygon (pasture).\n\nAdditionally, the fences can intersect only in these vertices.\n\nA shepherd who does not fulfil these requirements will no longer be subsidized.\n\nByteasar, as a shepherd, has to decide on a way of partitioning his pasture.\n\nIn fact, he is unsure how many partitions are possible. He is only interested in such partitions    that no fence is drawn through a favourite spot of any sheep, and such that every resulting triangle    contains the favourite spots of an even number of sheep, so that these sheep can play in pairs.\n\nHelp Byteasar by writing a program that calculates the number of such partitions!\n", "inputFormat": "The first line of the standard input contains three integers ![](http://main.edu.pl/images/OI17/owc-en-tex.4.png), ![](http://main.edu.pl/images/OI17/owc-en-tex.5.png) and ![](http://main.edu.pl/images/OI17/owc-en-tex.6.png)    (![](http://main.edu.pl/images/OI17/owc-en-tex.7.png), ![](http://main.edu.pl/images/OI17/owc-en-tex.8.png), ![](http://main.edu.pl/images/OI17/owc-en-tex.9.png), ![](http://main.edu.pl/images/OI17/owc-en-tex.10.png)),    separated by single spaces, that denote respectively:\n\nthe number of vertices of the polygon forming the pasture,    the number of the sheep, and a certain positive integer ![](http://main.edu.pl/images/OI17/owc-en-tex.11.png).\n\nEach of the following ![](http://main.edu.pl/images/OI17/owc-en-tex.12.png) lines contains two integers ![](http://main.edu.pl/images/OI17/owc-en-tex.13.png) and ![](http://main.edu.pl/images/OI17/owc-en-tex.14.png)    (![](http://main.edu.pl/images/OI17/owc-en-tex.15.png)), separated by a single space,    de…\n", "outputFormat": "Your program should print one integer on the standard output,    namely the remainder of division by ![](http://main.edu.pl/images/OI17/owc-en-tex.22.png) of the number of partitions of the pasture in triangles,    such that no fence is drawn through a favourite spot of any sheep, and every resulting triangle    contains the favourite spots of an even number of sheep.\n", "hint": "$4\\le n\\le 600$，$2\\le k$，$m\\le 20\\ 000$，$2\\mid k$，$-15\\ 000\\le x_i,y_i,p_i,q_i\\le 15\\ 000$ ，牧场的顶点坐标按顺时针顺序给出，保证羊严格在多边形内部。 \n", "locale": "en", "translations": {"en": {"title": "[POI 2010] OWC-Sheep", "background": "", "description": "The habitants of the Byteotian Highland bred sheep for centuries.\n\nEvery sane shepherd has a fenced pasture in the shape of a convex1 polygon    for the sheep to graze on.\n\nEvery sane sheep in turn has its own favourite feeding spot on the pasture where it spends all days.\n\nSometimes however, the sheep want to play. As they play in pairs, every shepherd keeps an even number of sheep,    so that his every sheep has a partner to play with.\n\nThe shepherds are concerned about a decree recently issued by the Byteburg's High Commissioner for Agriculture.\n\nThe decree states that as of the next year the sheep can only graze on triangle-shaped pastures.\n\nThus every shepherd whose pasture is an ![](http://main.edu.pl/images/OI17/owc-en-tex.1.png)-gon for ![](http://main.edu.pl/images/OI17/owc-en-tex.2.png) is to partition it into triangles by putting ![](http://main.edu.pl/images/OI17/owc-en-tex.3.png)    fences inside.\n\nEach single new fence, of course, is going to be a segment connecting two vertices of the polygon (pasture).\n\nAdditionally, the fences can intersect only in these vertices.\n\nA shepherd who does not fulfil these requirements will no longer be subsidized.\n\nByteasar, as a shepherd, has to decide on a way of partitioning his pasture.\n\nIn fact, he is unsure how many partitions are possible. He is only interested in such partitions    that no fence is drawn through a favourite spot of any sheep, and such that every resulting triangle    contains the favourite spots of an even number of sheep, so that these sheep can play in pairs.\n\nHelp Byteasar by writing a program that calculates the number of such partitions!\n", "inputFormat": "The first line of the standard input contains three integers ![](http://main.edu.pl/images/OI17/owc-en-tex.4.png), ![](http://main.edu.pl/images/OI17/owc-en-tex.5.png) and ![](http://main.edu.pl/images/OI17/owc-en-tex.6.png)    (![](http://main.edu.pl/images/OI17/owc-en-tex.7.png), ![](http://main.edu.pl/images/OI17/owc-en-tex.8.png), ![](http://main.edu.pl/images/OI17/owc-en-tex.9.png), ![](http://main.edu.pl/images/OI17/owc-en-tex.10.png)),    separated by single spaces, that denote respectively:\n\nthe number of vertices of the polygon forming the pasture,    the number of the sheep, and a certain positive integer ![](http://main.edu.pl/images/OI17/owc-en-tex.11.png).\n\nEach of the following ![](http://main.edu.pl/images/OI17/owc-en-tex.12.png) lines contains two integers ![](http://main.edu.pl/images/OI17/owc-en-tex.13.png) and ![](http://main.edu.pl/images/OI17/owc-en-tex.14.png)    (![](http://main.edu.pl/images/OI17/owc-en-tex.15.png)), separated by a single space,    de…\n", "outputFormat": "Your program should print one integer on the standard output,    namely the remainder of division by ![](http://main.edu.pl/images/OI17/owc-en-tex.22.png) of the number of partitions of the pasture in triangles,    such that no fence is drawn through a favourite spot of any sheep, and every resulting triangle    contains the favourite spots of an even number of sheep.\n", "hint": "$4\\le n\\le 600$，$2\\le k$，$m\\le 20\\ 000$，$2\\mid k$，$-15\\ 000\\le x_i,y_i,p_i,q_i\\le 15\\ 000$ ，牧场的顶点坐标按顺时针顺序给出，保证羊严格在多边形内部。 \n", "locale": "en"}, "zh-CN": {"title": "[POI 2010] OWC-Sheep", "background": null, "description": "**译自 POI 2010 Stage 2. Day 2「[Sheep](https://szkopul.edu.pl/problemset/problem/YjtAwdQrSiGcE_RLiEJpGiYE/site/?key=statement)」**\n\nByteasar 有一个凸多边形牧场，里面有一些羊。  \n现在 Byteasar 想要把这个凸多边形划分成若干三角形（划分线不能在牧场中相交，只能在顶点相交），使得每一个三角形里面的羊都有偶数只。  \nByteasar 想知道有多少种方案，你只要输出方案数对 $m$ 取余后的结果即可。", "inputFormat": "第一行三个空格隔开的正整数 $n,k,m$ ，分别表示牧场的顶点数，羊的个数，以及模数。  \n接下来 $n$ 行，每行两个空格隔开的正整数 $x_i,y_i$ ，表示牧场的顶点坐标。  \n接下来 $k$ 行，每行两个空格隔开的正整数 $p_i,q_i$ ，表示羊的坐标。", "outputFormat": "一行一个整数，表示方案数对 $m$ 取模的结果。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2450)。", "hint": "对于所有数据：\n- $4\\le n\\le 600$，$m\\le 20\\ 000$；\n- $2\\le k\\le 20000$，$2\\mid k$；\n- $-15\\ 000\\le x_i,y_i,p_i,q_i\\le 15\\ 000$；\n- 牧场的顶点坐标按顺时针顺序给出；\n- 保证羊严格在多边形内部。", "locale": "zh-CN"}}}
{"pid": "P3505", "type": "P", "difficulty": 6, "samples": [["10 10\n1 3\n3 5\n5 7\n7 9\n2 9\n1 4\n4 6\n6 8\n8 10\n2 10", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "POI（波兰）"], "title": "[POI 2010] TEL-Teleportation", "background": "", "description": "King Byteasar is the ruler of the whole solar system that contains $n$ planets.\n\nThis number is so large that people have abandoned the silly custom of naming the planets    and use numbers instead. The planets are thus conveniently numbered from 1 to $n$.\n\nByteasar's palace is on the planet no. 1, while his military base on the planet no. 2.\n\nA long time ago Byteasar had a teleportation portal established between these two planets,    which allows travelling from either planet to another in two hundred and fifty minutes    (slightly over four hours).\n\nNowadays the teleportation technology is more mature, and the recent teleportation devices shorten    the travel time to just a single hour. Let us note here, that all the portals, both the Byteasar's old one    and the new ones available on the market, are of course bidirectional, and that the teleportation    travel time is irrespective of the distance travelled.\n\nSome planets of the system are already connected with these new teleportation portals.\n\nIn fact, it is already possible to travel between the planets no. 1 and 2 without using the king's private portal,    though this involves several other portals and is thus no faster than the king's portal.\n\nByteasar finds this rather fortunate, as he believes that such possibility would be a security breach.\n\nThe technology itself is increasingly available, and as everyone realises its economic significance,    each pair of planets that are not currently directly connected with a portal are petitioning for establishing    such a connection. Being a wise ruler, Byteasar intends to give his consent to as many constructions as possible,    though keeping himself secure, i.e., not allowing the travel between planets 1 and 2 faster than with his private portal.\n\nHelp the king determine how many portals he can agree to.", "inputFormat": "Two integers are given in the first line of the standard input, $n$ and $m$ ($2\\le n \\le 40000,0\\le m\\le 1000000$), separated by a single space,      denoting the number of planets in Byteasar's realm and the number of new portals      that already exist.\n\nThese teleportation portals are described in the $m$ lines that follow.\n\nEach such line contains two integers $a_i$ and $b_i$ ($1\\le a_i<b_i\\le n$),      separated by a single space, denoting that there is a teleportation portal of the new kind      connecting $a_i$ and $b_i$.\n\nNo pair of numbers appears twice.\n\nYou may assume that the existing network of new portals allows travel from      planet no. 1 to planet no. 2, but in no less than 250 minutes.\n", "outputFormat": "Your program should print out just a single integer, namely the maximum number of portals      Byteasar can agree to without breaching his security.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2010] TEL-Teleportation", "background": "", "description": "King Byteasar is the ruler of the whole solar system that contains $n$ planets.\n\nThis number is so large that people have abandoned the silly custom of naming the planets    and use numbers instead. The planets are thus conveniently numbered from 1 to $n$.\n\nByteasar's palace is on the planet no. 1, while his military base on the planet no. 2.\n\nA long time ago Byteasar had a teleportation portal established between these two planets,    which allows travelling from either planet to another in two hundred and fifty minutes    (slightly over four hours).\n\nNowadays the teleportation technology is more mature, and the recent teleportation devices shorten    the travel time to just a single hour. Let us note here, that all the portals, both the Byteasar's old one    and the new ones available on the market, are of course bidirectional, and that the teleportation    travel time is irrespective of the distance travelled.\n\nSome planets of the system are already connected with these new teleportation portals.\n\nIn fact, it is already possible to travel between the planets no. 1 and 2 without using the king's private portal,    though this involves several other portals and is thus no faster than the king's portal.\n\nByteasar finds this rather fortunate, as he believes that such possibility would be a security breach.\n\nThe technology itself is increasingly available, and as everyone realises its economic significance,    each pair of planets that are not currently directly connected with a portal are petitioning for establishing    such a connection. Being a wise ruler, Byteasar intends to give his consent to as many constructions as possible,    though keeping himself secure, i.e., not allowing the travel between planets 1 and 2 faster than with his private portal.\n\nHelp the king determine how many portals he can agree to.", "inputFormat": "Two integers are given in the first line of the standard input, $n$ and $m$ ($2\\le n \\le 40000,0\\le m\\le 1000000$), separated by a single space,      denoting the number of planets in Byteasar's realm and the number of new portals      that already exist.\n\nThese teleportation portals are described in the $m$ lines that follow.\n\nEach such line contains two integers $a_i$ and $b_i$ ($1\\le a_i<b_i\\le n$),      separated by a single space, denoting that there is a teleportation portal of the new kind      connecting $a_i$ and $b_i$.\n\nNo pair of numbers appears twice.\n\nYou may assume that the existing network of new portals allows travel from      planet no. 1 to planet no. 2, but in no less than 250 minutes.\n", "outputFormat": "Your program should print out just a single integer, namely the maximum number of portals      Byteasar can agree to without breaching his security.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2010] TEL-Teleportation", "background": "", "description": "**译自 POI 2010 Stage 2. Day 2「[Teleportation](https://szkopul.edu.pl/problemset/problem/fKO3YZL0f_UM1nHQNDvw7mku/site/?key=statement)」**\n\n现在有 $n$ 个点，目前在 $1$ 号点和 $2$ 号点之间有一条无向边，长度为 $250\\min$ 。  \n除此之外，还有 $m$ 条无向边，长度都为 $1\\ \\textrm{h}$ （即 $60\\min$）， Byteasar 想知道，还能最多在添加多少条长度为 $1\\ \\textrm{h}$ 的无向边，使得新图无重边无自环，且 $1$ 号点到 $2$ 号点的最短路仍为 $250\\min$ 。", "inputFormat": "第一行两个空格隔开的正整数 $n,m$ 。  \n接下来 $m$ 行，每行两个空格隔开的正整数 $u_i,v_i$ ，描述原有的边。", "outputFormat": "一行一个整数，表示最多添加多少条边，可以使 $1$ 号点到 $2$ 号点的最短路长度保持不变。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2449)。", "hint": "数据保证，$2\\le n\\le 40\\ 000$，$0\\le m\\le 10^6$，$1\\le u_i,v_i\\le n$，保证只考虑已有的边时， $1$ 号点与 $2$ 号点联通，且最短路长度大于 $250\\min$ 。", "locale": "zh-CN"}}}
{"pid": "P3506", "type": "P", "difficulty": 6, "samples": [["7 3\n2 4 3 1 3 5 3\n< > =", "6\n2 4 3 3 5 3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "2010", "线段树", "树状数组", "POI（波兰）", "Special Judge"], "title": "[POI 2010] MOT-Monotonicity 2", "background": "", "description": "This task is a harder version of task Monotonicity from the third stage of 17th Polish OI. It wasn't used in the contest itself.\n\nFor an integer sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.1.png) we define its monotonicity scheme as the sequence    ![](http://main.edu.pl/images/OI17/mot-en-tex.2.png) of symbols ![](http://main.edu.pl/images/OI17/mot-en-tex.3.png), ![](http://main.edu.pl/images/OI17/mot-en-tex.4.png) or ![](http://main.edu.pl/images/OI17/mot-en-tex.5.png).\n\nThe symbol ![](http://main.edu.pl/images/OI17/mot-en-tex.6.png) represents the relation between ![](http://main.edu.pl/images/OI17/mot-en-tex.7.png) and ![](http://main.edu.pl/images/OI17/mot-en-tex.8.png).\n\nFor example, the monotonicity scheme of the sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.9.png) is ![](http://main.edu.pl/images/OI17/mot-en-tex.10.png).\n\nWe say that an integer sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.11.png) with monotonicity scheme    ![](http://main.edu.pl/images/OI17/mot-en-tex.12.png), realizes another monotonicity scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.13.png)    if for every ![](http://main.edu.pl/images/OI17/mot-en-tex.14.png) it holds that ![](http://main.edu.pl/images/OI17/mot-en-tex.15.png).\n\nIn other words, the sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.16.png) can be obtained by repeating the sequence    ![](http://main.edu.pl/images/OI17/mot-en-tex.17.png) and removing appropriate suffix from that repetition.\n\nFor example, the sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.18.png) realizes each and every one of the following schemes:\n\n![](http://main.edu.pl/images/OI17/mot-en-tex.19.png)           ![](http://main.edu.pl/images/OI17/mot-en-tex.20.png)           ![](http://main.edu.pl/images/OI17/mot-en-tex.21.png)           ![](http://main.edu.pl/images/OI17/mot-en-tex.22.png)                  as well as many others.\n\nAn integer sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.23.png) and a monotonicity scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.24.png) are given.\n\nYour task is to find the longest subsequence ![](http://main.edu.pl/images/OI17/mot-en-tex.25.png) (![](http://main.edu.pl/images/OI17/mot-en-tex.26.png))    of the former that realizes the latter.", "inputFormat": "The first line of the standard input holds two integers ![](http://main.edu.pl/images/OI17/mot-en-tex.27.png) and ![](http://main.edu.pl/images/OI17/mot-en-tex.28.png) (![](http://main.edu.pl/images/OI17/mot-en-tex.29.png), ![](http://main.edu.pl/images/OI17/mot-en-tex.30.png)),    separated by a single space, denoting the lengths of the sequences ![](http://main.edu.pl/images/OI17/mot-en-tex.31.png) and monotonicity scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.32.png) respectively.\n\nThe second input line gives the sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.33.png), i.e, it holds ![](http://main.edu.pl/images/OI17/mot-en-tex.34.png) integers ![](http://main.edu.pl/images/OI17/mot-en-tex.35.png) separated by single spaces (![](http://main.edu.pl/images/OI17/mot-en-tex.36.png)).\n\nFinally, the third lines gives the monotonicity scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.37.png), i.e., it holds ![](http://main.edu.pl/images/OI17/mot-en-tex.38.png) s…\n", "outputFormat": "In the first line of the standard output your program should print out a single integer ![](http://main.edu.pl/images/OI17/mot-en-tex.40.png),    the maximum length of a subsequence of ![](http://main.edu.pl/images/OI17/mot-en-tex.41.png) that realizes the scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.42.png).\n\nIn the second line it should print out any such subsequence ![](http://main.edu.pl/images/OI17/mot-en-tex.43.png), separating its elements by single spaces.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2010] MOT-Monotonicity 2", "background": "", "description": "This task is a harder version of task Monotonicity from the third stage of 17th Polish OI. It wasn't used in the contest itself.\n\nFor an integer sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.1.png) we define its monotonicity scheme as the sequence    ![](http://main.edu.pl/images/OI17/mot-en-tex.2.png) of symbols ![](http://main.edu.pl/images/OI17/mot-en-tex.3.png), ![](http://main.edu.pl/images/OI17/mot-en-tex.4.png) or ![](http://main.edu.pl/images/OI17/mot-en-tex.5.png).\n\nThe symbol ![](http://main.edu.pl/images/OI17/mot-en-tex.6.png) represents the relation between ![](http://main.edu.pl/images/OI17/mot-en-tex.7.png) and ![](http://main.edu.pl/images/OI17/mot-en-tex.8.png).\n\nFor example, the monotonicity scheme of the sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.9.png) is ![](http://main.edu.pl/images/OI17/mot-en-tex.10.png).\n\nWe say that an integer sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.11.png) with monotonicity scheme    ![](http://main.edu.pl/images/OI17/mot-en-tex.12.png), realizes another monotonicity scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.13.png)    if for every ![](http://main.edu.pl/images/OI17/mot-en-tex.14.png) it holds that ![](http://main.edu.pl/images/OI17/mot-en-tex.15.png).\n\nIn other words, the sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.16.png) can be obtained by repeating the sequence    ![](http://main.edu.pl/images/OI17/mot-en-tex.17.png) and removing appropriate suffix from that repetition.\n\nFor example, the sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.18.png) realizes each and every one of the following schemes:\n\n![](http://main.edu.pl/images/OI17/mot-en-tex.19.png)           ![](http://main.edu.pl/images/OI17/mot-en-tex.20.png)           ![](http://main.edu.pl/images/OI17/mot-en-tex.21.png)           ![](http://main.edu.pl/images/OI17/mot-en-tex.22.png)                  as well as many others.\n\nAn integer sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.23.png) and a monotonicity scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.24.png) are given.\n\nYour task is to find the longest subsequence ![](http://main.edu.pl/images/OI17/mot-en-tex.25.png) (![](http://main.edu.pl/images/OI17/mot-en-tex.26.png))    of the former that realizes the latter.", "inputFormat": "The first line of the standard input holds two integers ![](http://main.edu.pl/images/OI17/mot-en-tex.27.png) and ![](http://main.edu.pl/images/OI17/mot-en-tex.28.png) (![](http://main.edu.pl/images/OI17/mot-en-tex.29.png), ![](http://main.edu.pl/images/OI17/mot-en-tex.30.png)),    separated by a single space, denoting the lengths of the sequences ![](http://main.edu.pl/images/OI17/mot-en-tex.31.png) and monotonicity scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.32.png) respectively.\n\nThe second input line gives the sequence ![](http://main.edu.pl/images/OI17/mot-en-tex.33.png), i.e, it holds ![](http://main.edu.pl/images/OI17/mot-en-tex.34.png) integers ![](http://main.edu.pl/images/OI17/mot-en-tex.35.png) separated by single spaces (![](http://main.edu.pl/images/OI17/mot-en-tex.36.png)).\n\nFinally, the third lines gives the monotonicity scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.37.png), i.e., it holds ![](http://main.edu.pl/images/OI17/mot-en-tex.38.png) s…\n", "outputFormat": "In the first line of the standard output your program should print out a single integer ![](http://main.edu.pl/images/OI17/mot-en-tex.40.png),    the maximum length of a subsequence of ![](http://main.edu.pl/images/OI17/mot-en-tex.41.png) that realizes the scheme ![](http://main.edu.pl/images/OI17/mot-en-tex.42.png).\n\nIn the second line it should print out any such subsequence ![](http://main.edu.pl/images/OI17/mot-en-tex.43.png), separating its elements by single spaces.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2010] MOT-Monotonicity 2", "background": null, "description": "本题是来自 POI 2010 第三阶段的[单调性](https://www.luogu.com.cn/problem/P3541)一题的加强版，但并没有在那次比赛中被使用。\n\n**译自 POI 2010 「[Monotonicity 2](https://szkopul.edu.pl/problemset/problem/0_pcwjQ6no8LDss0IWNLbb2_/site/?key=statement)」**\n\n对于一个整数序列 $a_1, a_2, ..., a_n$，我们定义其“单调序列\"为一个由 $<$，$>$ 和 $=$ 组成的符号序列 $s_1, s_2, ... s_{n-1}$，其中符号 $s_i$ 表示 $a_i$ 和 $a_{i+1}$ 之间的关系。例如，数列 $2, 4, 3, 3, 5, 3$ 的单调序列为 $<, >, =, <, >$。\n\n对于整数序列 $b_1, b_2, ..., b_{n+1}$ 以及其单调序列 $s_1, s_2, ..., s_n$，如果符号序列 $s_1', s_2', ..., s_k'$ 满足对所有 $1 \\le i \\le n$ 有 $s_i = s_{((i - 1) \\bmod k) + 1}'$，我们就说序列 $s_1, s_2, ..., s_n$ 「实现」了序列 $s_1', s_2', ..., s_k'$。也就是说，序列 $s_1, s_2, ..., s_n$ 可以通过重复多次 $s_1', s_2', ..., s_k'$ 序列并删除一个后缀得到。例如，整数数列 $2, 4, 3, 3, 5, 3$ 至少实现了以下符号序列：\n* $<, >, =$\n* $<, >, =, <, >$\n* $<, >, =, <, >, <, <, =$\n* $<, >, =, <, >, =, >, >$\n\n给定一个整数序列 $a_1, a_2, ..., a_n$ 以及一个单调序列 $s_1, s_2, ..., s_k$，求出原整数序列最长的子序列 $a_{i_1}, a_{i_2}, ..., a_{i_m} (1 \\le i_1 \\lt i_2 \\lt ... \\lt i_m \\le n)$ 使得前者的单调序列实现后者的符号序列。", "inputFormat": "第一行包含用空格分隔的两个整数 $n,k$，分别表示整数序列 $(a_i)$ 的长度和单调序列 $(s_j)$ 的长度。\n\n第二行包含用空格分隔的 $n$ 个整数，表示序列 $a_i$.\n\n第三行包含用空格分隔的 $k$ 个符号，表示符号序列 $s_j$.", "outputFormat": "第一行输出一个整数 $m$，表示序列 $a_1, a_2, ..., a_n$ 的最长的「实现」了单调序列 $s_1, s_2, ..., s_n$ 的子序列。\n\n第二行输出任意一个这样的子序列 $a_{i_1}, a_{i_2}, ..., a_{i_n}$，元素之间用空格分隔。", "hint": "对于 $100\\%$ 的数据， $1 \\le n \\le 500000,1 \\le k \\le 500000 , 1 \\le a_i \\le 1000000 , s_j \\in \\{<, >, =\\}$ 。\n\n感谢 [本帖](https://www.luogu.com.cn/discuss/67056) 提供的 SPJ。翻译来自于 [LibreOJ](https://loj.ac/p/3009)。", "locale": "zh-CN"}}}
{"pid": "P3507", "type": "P", "difficulty": 5, "samples": [["3\n1 3 1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "动态规划 DP", "贪心", "2010", "POI（波兰）"], "title": "[POI 2010] GRA-The Minima Game", "background": "", "description": "Alice and Bob learned the minima game, which they like very much, recently.\n\nThe rules of the game are as follows.\n\nA certain number of cards lies on a table, each inscribed with a positive integer.\n\nThe players make alternate moves, Alice making the first one.\n\nA move consists in picking an arbitrary positive number of cards from the table.\n\nFor such move the player receives a number of points equal to the minimum    of the numbers inscribed on the cards he collected.\n\nThe game ends when the last card is removed from the table.\n\nThe goal of each player is maximizing the difference between their and their opponent's score.\n\nAlice and Bob have duly noted that there is an optimal strategy in the game.\n\nThus they are asking you to write a program that, for a given set of cards,    determines the outcome of the game when both players play optimally.", "inputFormat": "In the first line of the standard input there is one integer ![](http://main.edu.pl/images/OI17/gra-en-tex.1.png) (![](http://main.edu.pl/images/OI17/gra-en-tex.2.png)) given,      denoting the number of cards.\n\nThe second line holds ![](http://main.edu.pl/images/OI17/gra-en-tex.3.png) positive integers ![](http://main.edu.pl/images/OI17/gra-en-tex.4.png) (![](http://main.edu.pl/images/OI17/gra-en-tex.5.png)),      separated by single spaces, that are inscribed on the cards.\n", "outputFormat": "Your program should print out a single line with a single integer to the standard      output - the number of points by which Alice wins over Bob, assuming they both play optimally;      if it is Bob who has more points, the result should be negative.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2010] GRA-The Minima Game", "background": "", "description": "Alice and Bob learned the minima game, which they like very much, recently.\n\nThe rules of the game are as follows.\n\nA certain number of cards lies on a table, each inscribed with a positive integer.\n\nThe players make alternate moves, Alice making the first one.\n\nA move consists in picking an arbitrary positive number of cards from the table.\n\nFor such move the player receives a number of points equal to the minimum    of the numbers inscribed on the cards he collected.\n\nThe game ends when the last card is removed from the table.\n\nThe goal of each player is maximizing the difference between their and their opponent's score.\n\nAlice and Bob have duly noted that there is an optimal strategy in the game.\n\nThus they are asking you to write a program that, for a given set of cards,    determines the outcome of the game when both players play optimally.", "inputFormat": "In the first line of the standard input there is one integer ![](http://main.edu.pl/images/OI17/gra-en-tex.1.png) (![](http://main.edu.pl/images/OI17/gra-en-tex.2.png)) given,      denoting the number of cards.\n\nThe second line holds ![](http://main.edu.pl/images/OI17/gra-en-tex.3.png) positive integers ![](http://main.edu.pl/images/OI17/gra-en-tex.4.png) (![](http://main.edu.pl/images/OI17/gra-en-tex.5.png)),      separated by single spaces, that are inscribed on the cards.\n", "outputFormat": "Your program should print out a single line with a single integer to the standard      output - the number of points by which Alice wins over Bob, assuming they both play optimally;      if it is Bob who has more points, the result should be negative.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2010] GRA-The Minima Game", "background": "", "description": "**译自 POI 2010 Stage 3. Day 1「[The Minima Game](https://szkopul.edu.pl/problemset/problem/3buviDQZWLE83AxVhvJJurgU/site/?key=statement)」**\n\nAlice 和 Bob 玩一个游戏。Alice 先手，两人轮流进行操作，每轮一个玩家可以选择若干张牌（至少一张），并获得相当于这些牌上所写数字的最小值的分数，直到没有牌为止。两人都希望自己的分数与对方分数之差最大。若两个玩家都使用最佳策略，求游戏的最终结果。", "inputFormat": "第一行有一个整数 $n$，表示牌的数量。\n\n接下来一行有 $n$ 个正整数 $k_1, k_2, ..., k_n$，表示牌上所写的数字。", "outputFormat": "输出一行一个整数，表示最终 Alice 的分数与 Bob 分数之差。如果 Bob 的分数更多，你应该输出一个负数。\n\n### 样例解释\n\nAlice 先选择 $3$，得到 $3$ 分。Bob 拿走所有牌并得到 $1$ 分，游戏最后的比分为 $3:1$，因此 Alice 比 Bob 多两分。", "hint": "$1\\le n\\le 10^6$，$1\\le k_i\\le 10^9$。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2455)。", "locale": "zh-CN"}}}
{"pid": "P3508", "type": "P", "difficulty": 0, "samples": [["3 3\n-1 2 1 4\n-1 5 1 7\n-3 8 -2 20\n-1 1 1 2\n-1 4 1 5\n-1 7 1 10", "2\n1 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2010", "线段树", "POI（波兰）"], "title": "[POI 2010] LAT-Lamp", "background": "\n", "description": "In the middle of the night Bitratio turned on the lamp at the entrance to the building that Byteasar lives in.\n\nNow the strong light prevents Byteasar from sleeping.\n\nWhile the lamp does not shine directly on Byteasar's windows, it does so by reflecting in other windows.\n\nDeprived of sleep, Byteasar is becoming irritated.\n\nTo remedy that he tries to occupy his mind, but all he can think of is the light.\n\nThus Byteasar looked out the window and wondered if his neighbours suffer similar torture,    i.e., whether the light shines on their windows as well.\n\nNow that is an interesting question, at least in Byteasar's opinion.\n\nYou learn of the puzzle sooner than you would wish: unable to solve the problem all by himself,    thinking little of sleep now (be it his and yours), Byteasar calls you to ask for help.\n\nYou know him well enough to understand that you too will not get any sleep until you write a program    that solves his problem.\n\nByteasar lives in the building ![](http://main.edu.pl/images/OI17/lat-en-tex.1.png), which has ![](http://main.edu.pl/images/OI17/lat-en-tex.2.png) windows.\n\nThe lamp is situated on a wall at the very bottom of this building.\n\nOpposite the building ![](http://main.edu.pl/images/OI17/lat-en-tex.3.png), exactly 10 meters apart, there is another building, ![](http://main.edu.pl/images/OI17/lat-en-tex.4.png).\n\nThe wall of this ![](http://main.edu.pl/images/OI17/lat-en-tex.5.png)-windowed building is parallel to the wall of ![](http://main.edu.pl/images/OI17/lat-en-tex.6.png), the Byteasar's building.\n\nThe lamp light behaves like you would expect, i.e., in the way predicted by geometrical optics (or ray optics).\n\nNamely the light propagates along rays, and if a ray hits a window, it is reflected.\n\nDue to The Law of Reflection, the angle of the ray's reflection equals the angle of incidence.\n\nWe introduce coordinate systems on the the walls of the two buildings in the following way.\n\nBoth ![](http://main.edu.pl/images/OI17/lat-en-tex.7.png) axes are horizontal, while both ![](http://main.edu.pl/images/OI17/lat-en-tex.8.png) axes are vertical; the axes on both walls are identically oriented,    and the ![](http://main.edu.pl/images/OI17/lat-en-tex.9.png) points of the walls are opposite one another.\n\nThe windows (on either building) are simply rectangles with sides parallel to the axes of the coordinate system.\n\nA ray is reflected only in the interior of any window; it is absorbed on the window's boundary.\n\nIn each building, no two windows share any part of their interiors.\n\nThe lamp is located on the wall of the ![](http://main.edu.pl/images/OI17/lat-en-tex.10.png) building at the point ![](http://main.edu.pl/images/OI17/lat-en-tex.11.png),    which is neither inside nor at the boundary of any window.\n", "inputFormat": "In the first line of the standard input there are two integers ![](http://main.edu.pl/images/OI17/lat-en-tex.12.png) and ![](http://main.edu.pl/images/OI17/lat-en-tex.13.png) (![](http://main.edu.pl/images/OI17/lat-en-tex.14.png)),      separated by a single space, denoting the number of windows in the first and second building respectively.\n\nThe ![](http://main.edu.pl/images/OI17/lat-en-tex.15.png) lines that follow describe the windows in Byteasar's building (the ![](http://main.edu.pl/images/OI17/lat-en-tex.16.png) building), one per line.\n\nThe line no. ![](http://main.edu.pl/images/OI17/lat-en-tex.17.png) (for ![](http://main.edu.pl/images/OI17/lat-en-tex.18.png)) holds four integers ![](http://main.edu.pl/images/OI17/lat-en-tex.19.png), ![](http://main.edu.pl/images/OI17/lat-en-tex.20.png), ![](http://main.edu.pl/images/OI17/lat-en-tex.21.png), ![](http://main.edu.pl/images/OI17/lat-en-tex.22.png)      (![](http://main.edu.pl/images/OI17/lat-en-tex.23.png),      !…\n", "outputFormat": "In the first line of the standard output your program should print the number of windows in the ![](http://main.edu.pl/images/OI17/lat-en-tex.31.png) building      whose interiors are hit by some ray.\n\nYou may assume that in every test instance there will be at least one such window (the Byteasar's window).\n\nIn the second line the numbers of these windows (windows are numbered starting from 1) should be printed in increasing order,      separated by single spaces.\n", "hint": "$-1000 \\le x_{1,i} \\lt x_{2,i} \\le 1000$，$0 \\le y_{1,i} < y_{2,i} \\le 1000$\n", "locale": "en", "translations": {"en": {"title": "[POI 2010] LAT-Lamp", "background": "\n", "description": "In the middle of the night Bitratio turned on the lamp at the entrance to the building that Byteasar lives in.\n\nNow the strong light prevents Byteasar from sleeping.\n\nWhile the lamp does not shine directly on Byteasar's windows, it does so by reflecting in other windows.\n\nDeprived of sleep, Byteasar is becoming irritated.\n\nTo remedy that he tries to occupy his mind, but all he can think of is the light.\n\nThus Byteasar looked out the window and wondered if his neighbours suffer similar torture,    i.e., whether the light shines on their windows as well.\n\nNow that is an interesting question, at least in Byteasar's opinion.\n\nYou learn of the puzzle sooner than you would wish: unable to solve the problem all by himself,    thinking little of sleep now (be it his and yours), Byteasar calls you to ask for help.\n\nYou know him well enough to understand that you too will not get any sleep until you write a program    that solves his problem.\n\nByteasar lives in the building ![](http://main.edu.pl/images/OI17/lat-en-tex.1.png), which has ![](http://main.edu.pl/images/OI17/lat-en-tex.2.png) windows.\n\nThe lamp is situated on a wall at the very bottom of this building.\n\nOpposite the building ![](http://main.edu.pl/images/OI17/lat-en-tex.3.png), exactly 10 meters apart, there is another building, ![](http://main.edu.pl/images/OI17/lat-en-tex.4.png).\n\nThe wall of this ![](http://main.edu.pl/images/OI17/lat-en-tex.5.png)-windowed building is parallel to the wall of ![](http://main.edu.pl/images/OI17/lat-en-tex.6.png), the Byteasar's building.\n\nThe lamp light behaves like you would expect, i.e., in the way predicted by geometrical optics (or ray optics).\n\nNamely the light propagates along rays, and if a ray hits a window, it is reflected.\n\nDue to The Law of Reflection, the angle of the ray's reflection equals the angle of incidence.\n\nWe introduce coordinate systems on the the walls of the two buildings in the following way.\n\nBoth ![](http://main.edu.pl/images/OI17/lat-en-tex.7.png) axes are horizontal, while both ![](http://main.edu.pl/images/OI17/lat-en-tex.8.png) axes are vertical; the axes on both walls are identically oriented,    and the ![](http://main.edu.pl/images/OI17/lat-en-tex.9.png) points of the walls are opposite one another.\n\nThe windows (on either building) are simply rectangles with sides parallel to the axes of the coordinate system.\n\nA ray is reflected only in the interior of any window; it is absorbed on the window's boundary.\n\nIn each building, no two windows share any part of their interiors.\n\nThe lamp is located on the wall of the ![](http://main.edu.pl/images/OI17/lat-en-tex.10.png) building at the point ![](http://main.edu.pl/images/OI17/lat-en-tex.11.png),    which is neither inside nor at the boundary of any window.\n", "inputFormat": "In the first line of the standard input there are two integers ![](http://main.edu.pl/images/OI17/lat-en-tex.12.png) and ![](http://main.edu.pl/images/OI17/lat-en-tex.13.png) (![](http://main.edu.pl/images/OI17/lat-en-tex.14.png)),      separated by a single space, denoting the number of windows in the first and second building respectively.\n\nThe ![](http://main.edu.pl/images/OI17/lat-en-tex.15.png) lines that follow describe the windows in Byteasar's building (the ![](http://main.edu.pl/images/OI17/lat-en-tex.16.png) building), one per line.\n\nThe line no. ![](http://main.edu.pl/images/OI17/lat-en-tex.17.png) (for ![](http://main.edu.pl/images/OI17/lat-en-tex.18.png)) holds four integers ![](http://main.edu.pl/images/OI17/lat-en-tex.19.png), ![](http://main.edu.pl/images/OI17/lat-en-tex.20.png), ![](http://main.edu.pl/images/OI17/lat-en-tex.21.png), ![](http://main.edu.pl/images/OI17/lat-en-tex.22.png)      (![](http://main.edu.pl/images/OI17/lat-en-tex.23.png),      !…\n", "outputFormat": "In the first line of the standard output your program should print the number of windows in the ![](http://main.edu.pl/images/OI17/lat-en-tex.31.png) building      whose interiors are hit by some ray.\n\nYou may assume that in every test instance there will be at least one such window (the Byteasar's window).\n\nIn the second line the numbers of these windows (windows are numbered starting from 1) should be printed in increasing order,      separated by single spaces.\n", "hint": "$-1000 \\le x_{1,i} \\lt x_{2,i} \\le 1000$，$0 \\le y_{1,i} < y_{2,i} \\le 1000$\n", "locale": "en"}, "zh-CN": {"title": "[POI 2010] LAT-Lamp", "background": "", "description": "在半夜，Bitratio 打开了 Byteasar 所住楼房入口处的灯。\n\n现在强光让 Byteasar 无法入睡。\n\n虽然灯光没有直接照射到 Byteasar 的窗户上，但通过其他窗户反射到了他的窗户上。\n\n失去睡眠的 Byteasar 变得烦躁。\n\n为了缓解这种情况，他试图让自己分心，但他能想到的只有灯光。\n\n因此，Byteasar 望向窗外，想知道他的邻居们是否也遭受着类似的折磨，即灯光是否也照射到了他们的窗户上。\n\n至少在 Byteasar 看来，这是一个有趣的问题。\n\n你比预期更早地知道了这个难题：因为无法独自解决这个问题，现在（无论是他的还是你的）对睡眠不再有任何想法，Byteasar 打电话给你寻求帮助。\n\n你对他很了解，知道在你写出一个解决他问题的程序之前，你也无法入睡。\n\nByteasar 住在一栋有 ![](http://main.edu.pl/images/OI17/lat-en-tex.1.png) 个窗户的建筑中。\n\n灯位于这栋建筑的最底部的墙上。\n\n在这栋建筑的对面，正好相隔 10 米，有另一栋建筑，![](http://main.edu.pl/images/OI17/lat-en-tex.4.png)。\n\n这栋有 ![](http://main.edu.pl/images/OI17/lat-en-tex.5.png) 个窗户的建筑的墙与 Byteasar 所住建筑的墙平行。\n\n灯光的行为如你所料，即按照几何光学（或射线光学）的预测。\n\n即光沿着射线传播，如果射线击中窗户，则会被反射。\n\n根据反射定律，射线的反射角等于入射角。\n\n我们在两栋建筑的墙上引入坐标系。\n\n两个 ![](http://main.edu.pl/images/OI17/lat-en-tex.7.png) 轴是水平的，而两个 ![](http://main.edu.pl/images/OI17/lat-en-tex.8.png) 轴是垂直的；两面墙上的坐标轴方向相同，墙上的 ![](http://main.edu.pl/images/OI17/lat-en-tex.9.png) 点彼此相对。\n\n两栋建筑上的窗户都是矩形，边与坐标系的轴平行。\n\n射线仅在任何窗户的内部反射；在窗户的边界上被吸收。\n\n在每栋建筑中，没有两个窗户的内部有任何部分重叠。\n\n灯位于 ![](http://main.edu.pl/images/OI17/lat-en-tex.10.png) 建筑的墙上，位于点 ![](http://main.edu.pl/images/OI17/lat-en-tex.11.png)，既不在任何窗户的内部也不在边界上。", "inputFormat": "标准输入的第一行有两个整数 ![](http://main.edu.pl/images/OI17/lat-en-tex.12.png) 和 ![](http://main.edu.pl/images/OI17/lat-en-tex.13.png) (![](http://main.edu.pl/images/OI17/lat-en-tex.14.png))，用一个空格分隔，表示第一栋和第二栋建筑中的窗户数量。\n\n接下来的 ![](http://main.edu.pl/images/OI17/lat-en-tex.15.png) 行描述了 Byteasar 所住建筑（![](http://main.edu.pl/images/OI17/lat-en-tex.16.png) 建筑）中的窗户，每行一个。\n\n第 ![](http://main.edu.pl/images/OI17/lat-en-tex.17.png) 行（对于 ![](http://main.edu.pl/images/OI17/lat-en-tex.18.png)）包含四个整数 ![](http://main.edu.pl/images/OI17/lat-en-tex.19.png)、![](http://main.edu.pl/images/OI17/lat-en-tex.20.png)、![](http://main.edu.pl/images/OI17/lat-en-tex.21.png)、![](http://main.edu.pl/images/OI17/lat-en-tex.22.png) (![](http://main.edu.pl/images/OI17/lat-en-tex.23.png)、...", "outputFormat": "标准输出的第一行，你的程序应输出 ![](http://main.edu.pl/images/OI17/lat-en-tex.31.png) 建筑中被某些射线击中的窗户数量。\n\n你可以假设在每个测试实例中至少会有一个这样的窗户（即 Byteasar 的窗户）。\n\n在第二行，应以递增顺序打印这些窗户的编号（窗户从 1 开始编号），用单个空格分隔。", "hint": "$-1000 \\le x_{1,i} < x_{2,i} \\le 1000$，$0 \\le y_{1,i} < y_{2,i} \\le 1000$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3509", "type": "P", "difficulty": 5, "samples": [["5 2 4\n1 2 4 7 10", "1 1 3 1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "倍增", "单调队列", "POI（波兰）", "深度优先搜索 DFS"], "title": "[POI 2010] ZAB-Frog", "background": "", "description": "On the bed of one particularly long and straight Byteotian brook there lie $n$ rocks jutting above the water level. Their distances from the brook's spring are $p_1 < p_2 < \\cdots < p_n$ respectively. A small frog sitting on one of these is about to begin its leaping training. Each time the frog leaps to the rock that is the -th closest to the one it is sitting on. Specifically, if the frog is sitting on the rock at position $p_i$, then it will leap onto such $p_j$ that:\n$$\n|\\{ p_a : |p _ a - p _ i| < |p_j - p_i| \\}| \\le k \\text{ and } |\\{ p_a : |p _ a - p _ i| \\le |p_j - p_i| \\}| > k\n$$\nIf $p_j$ is not unique, then the frog chooses among them the rock that is closest to the spring. On which rock the frog will be sitting after $m$ leaps depending on the rock is started from?", "inputFormat": "The first line of the standard input holds three integers, $n$, $k$ and $m$ ($1 \\le k < n \\le 1 \\, 000 \\, 000, 1 \\le m \\le 10^{18}$), separated by single spaces, that denote respectively: the number of rocks, the parameter $k$, and the number of intended leaps. The second line holds $n$ integers $p_j$ ($1 \\le p_1 < p_2 < \\cdots < p_n \\le 10^{18}$), separated by single spaces, that denote the positions of successive rocks on the bed of the brook.", "outputFormat": "Your program should print a single line on the standard output, with $n$ integers $r_1, r_2, \\cdots, r_n$ from the interval $[1, n]$ in it, separated by single spaces. The number $r_i$ denotes the number of the rock that the frog ends on after making $m$ leaps starting from the rock no. $i$ (in the input order).", "hint": "### 样例 #1 解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yyilx2mp.png)\n\nThe figure presents where the frog leaps to (in a single leap) from each and every rock.", "locale": "en", "translations": {"en": {"title": "[POI 2010] ZAB-Frog", "background": "", "description": "On the bed of one particularly long and straight Byteotian brook there lie $n$ rocks jutting above the water level. Their distances from the brook's spring are $p_1 < p_2 < \\cdots < p_n$ respectively. A small frog sitting on one of these is about to begin its leaping training. Each time the frog leaps to the rock that is the -th closest to the one it is sitting on. Specifically, if the frog is sitting on the rock at position $p_i$, then it will leap onto such $p_j$ that:\n$$\n|\\{ p_a : |p _ a - p _ i| < |p_j - p_i| \\}| \\le k \\text{ and } |\\{ p_a : |p _ a - p _ i| \\le |p_j - p_i| \\}| > k\n$$\nIf $p_j$ is not unique, then the frog chooses among them the rock that is closest to the spring. On which rock the frog will be sitting after $m$ leaps depending on the rock is started from?", "inputFormat": "The first line of the standard input holds three integers, $n$, $k$ and $m$ ($1 \\le k < n \\le 1 \\, 000 \\, 000, 1 \\le m \\le 10^{18}$), separated by single spaces, that denote respectively: the number of rocks, the parameter $k$, and the number of intended leaps. The second line holds $n$ integers $p_j$ ($1 \\le p_1 < p_2 < \\cdots < p_n \\le 10^{18}$), separated by single spaces, that denote the positions of successive rocks on the bed of the brook.", "outputFormat": "Your program should print a single line on the standard output, with $n$ integers $r_1, r_2, \\cdots, r_n$ from the interval $[1, n]$ in it, separated by single spaces. The number $r_i$ denotes the number of the rock that the frog ends on after making $m$ leaps starting from the rock no. $i$ (in the input order).", "hint": "### 样例 #1 解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yyilx2mp.png)\n\nThe figure presents where the frog leaps to (in a single leap) from each and every rock.", "locale": "en"}, "zh-CN": {"title": "[POI 2010] ZAB-Frog", "background": null, "description": "在一个特别长且笔直的 Byteotian 小溪的河床上，有 $n$ 块石头露出水面。它们距离小溪源头的距离分别为 $p_1 < p_2 < \\cdots < p_n$。一只小青蛙正坐在其中一块石头上，准备开始它的跳跃训练。每次青蛙跳跃到距离它所在石头第 $k$ 近的石头上。具体来说，如果青蛙坐在位置 $p_i$ 的石头上，那么它将跳到这样的 $p_j$ 上，使得：\n\n$$\n|\\{ p_a : |p _ a - p _ i| < |p_j - p_i| \\}| \\le k \\text{ and } |\\{ p_a : |p _ a - p _ i| \\le |p_j - p_i| \\}| > k\n$$\n\n如果 $p_j$ 不是唯一的，那么青蛙在其中选择距离源头最近的石头。对于每一块石头分别计算，若青蛙从这块石头开始跳跃，经过 $m$ 次跳跃后最终会停留在哪一块石头上？", "inputFormat": "标准输入的第一行包含三个整数 $n$、$k$ 和 $m$（$1 \\le k < n \\le 1\\,000\\,000, 1 \\le m \\le 10^{18}$），用空格分隔，分别表示石头的数量、参数 $k$ 和计划跳跃的次数。第二行包含 $n$ 个整数 $p_j$（$1 \\le p_1 < p_2 < \\cdots < p_n \\le 10^{18}$），用空格分隔，表示小溪河床上连续石头的位置。", "outputFormat": "你的程序应在标准输出上打印一行，包含 $n$ 个整数 $r_1, r_2, \\cdots, r_n$，用空格分隔。数字 $r_i$ 表示从输入顺序中的第 $i$ 块石头开始跳跃 $m$ 次后，青蛙最终停留的石头编号。", "hint": "### 样例 #1 解释：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yyilx2mp.png)\n\n图中展示了青蛙从每块石头跳跃（单次跳跃）到的位置。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3510", "type": "P", "difficulty": 0, "samples": [["6\n1 1 1 1 1 1", "5\n1 1 2 1 1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "单调队列", "POI（波兰）", "哈希 hashing", "级数"], "title": "[POI 2010] JED-Ones", "background": "", "description": "Let $x$ be a sequence of zeros and ones.\n\nAn utterly forlorn one (UFO) in $x$ is the extreme (either first or last) one    that additionally does not neighbour with any other one.\n\nFor instance, the sequence 10001010 has two UFOs,    while the sequence 1101011000 has no UFO,    and the sequence 1000 has only one UFO.\n\nLet us denote the total number of UFOs in the binary representations of the numbers    from 1 to $n$ with $sks(n)$.\n\nFor example,    $sks(5)=5$, $sks(64)=59$, $sks(128)=122$, $sks(256)=249$.\n\nWe will be working with very large numbers.\n\n```plain\nTherefore, we shall represent them in a succinct way.\n```\nSuppose $x$ is a positive integer and $x_2$ is its binary representation    (starting with 1). Then the succinct representation of $x$ is the sequence    $REP(x)$ consisting of positive integers denoting the lengths of successive    blocks of the same digits.\n\nFor example:\n\n$REP(460\\ 288)=REP(1110000011000000000_2)=(3,5,2,9)$ $REP(408)=REP(110011000_2)=(2,2,2,3)$  \n\nYour task is to write a program that finds the sequence $REP(sks(n))$ given $REP(n)$.\n\n", "inputFormat": "The first line of the standard input holds one integer $k$  ($1\\le k\\le 1\\ 000\\ 000$) denoting the length of the succinct representation      of a positive integer $n$.\n\nThe second line of the standard input holds $k$ integers $x_1,x_2,\\cdots,x_k$  ($0<x_i\\le 1\\ 000\\ 000\\ 000$), separated by single spaces.\n\nThe sequence $x_1,x_2,\\cdots,x_k$ forms the succinct representation of the number $n$.\n\nYou may assume that $x_1+x_2+\\cdots+x_k\\le 1\\ 000\\ 000\\ 000$, i.e., $0<n<2^{1\\ 000\\ 000\\ 000}$.\n", "outputFormat": "Your program is to print out two lines to the standard output.\n\nThe first one should contain a single positive integer $l$.\n\nThe second line should hold $l$ positive integers $y_1,y_2,\\cdots,y_l$,      separated by single spaces.\n\nThe sequence $y_1,y_2,\\cdots,y_l$ is to form the succinct representation of $sks(n)$.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2010] JED-Ones", "background": "", "description": "Let $x$ be a sequence of zeros and ones.\n\nAn utterly forlorn one (UFO) in $x$ is the extreme (either first or last) one    that additionally does not neighbour with any other one.\n\nFor instance, the sequence 10001010 has two UFOs,    while the sequence 1101011000 has no UFO,    and the sequence 1000 has only one UFO.\n\nLet us denote the total number of UFOs in the binary representations of the numbers    from 1 to $n$ with $sks(n)$.\n\nFor example,    $sks(5)=5$, $sks(64)=59$, $sks(128)=122$, $sks(256)=249$.\n\nWe will be working with very large numbers.\n\n```plain\nTherefore, we shall represent them in a succinct way.\n```\nSuppose $x$ is a positive integer and $x_2$ is its binary representation    (starting with 1). Then the succinct representation of $x$ is the sequence    $REP(x)$ consisting of positive integers denoting the lengths of successive    blocks of the same digits.\n\nFor example:\n\n$REP(460\\ 288)=REP(1110000011000000000_2)=(3,5,2,9)$ $REP(408)=REP(110011000_2)=(2,2,2,3)$  \n\nYour task is to write a program that finds the sequence $REP(sks(n))$ given $REP(n)$.\n\n", "inputFormat": "The first line of the standard input holds one integer $k$  ($1\\le k\\le 1\\ 000\\ 000$) denoting the length of the succinct representation      of a positive integer $n$.\n\nThe second line of the standard input holds $k$ integers $x_1,x_2,\\cdots,x_k$  ($0<x_i\\le 1\\ 000\\ 000\\ 000$), separated by single spaces.\n\nThe sequence $x_1,x_2,\\cdots,x_k$ forms the succinct representation of the number $n$.\n\nYou may assume that $x_1+x_2+\\cdots+x_k\\le 1\\ 000\\ 000\\ 000$, i.e., $0<n<2^{1\\ 000\\ 000\\ 000}$.\n", "outputFormat": "Your program is to print out two lines to the standard output.\n\nThe first one should contain a single positive integer $l$.\n\nThe second line should hold $l$ positive integers $y_1,y_2,\\cdots,y_l$,      separated by single spaces.\n\nThe sequence $y_1,y_2,\\cdots,y_l$ is to form the succinct representation of $sks(n)$.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2010] JED-Ones", "background": "", "description": "设 $x$ 是一个由 $\\texttt{01}$ 组成的序列。一个 UFO 指的是序列中第一个 $1$ 或者最后一个 $1$ 且不和任何一个 $1$ 相邻。例如 $\\texttt{10001010}$ 有两个 UFO，$\\texttt{1101011000}$ 没有 UFO，$\\texttt{1000}$ 只有一个 UFO。\n\n设 $1$ 到 $n$ 的数的二进制表示中 UFO 的总数为 $sks(n)$。例如，$sks(5)=5, sks(64)=59, sks(128)=122, sks(256)=249$.\n\n我们需要处理非常大的数字。因此 $n$ 会用压缩的形式表示。设 $x$ 是一个正整数 $x_2$ 是其二进制表示（最高位为 $1$），则该数的压缩形式 $REP(x)$ 为一个序列，表示连续相同数位的数量。例如：\n\n$$REP(460288)=REP(1110000011000000000_2)=(3,5,2,9)$$\n\n$$REP(408)=REP(110011000_2)=(2,2,2,3)$$  \n\n已知 $REP(n)$，求 $REP(sks(n))$。", "inputFormat": "第一行有一个整数 $k$，表示一个正整数 $n$ 的压缩形式。  \n接下来一行有 $k$ 个整数 $x _ 1, x _ 2, \\cdots, x _ k$，用空格分隔，表示 $n$ 的压缩形式的序列。保证 $x _ 1 + x _ 2 + \\cdots + x _ k \\le 10 ^ 9$，也就是说 $0<n< 2 ^ {10 ^ 9}$。", "outputFormat": "输出两行，第一行有一个正整数 $l$，第二行有 $l$ 个正整数，用空格分隔，表示 $sks(n)$ 的压缩形式。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3511", "type": "P", "difficulty": 6, "samples": [["4 4\n1 2 2 4\n2 3 3 4\n3 4 4 4\n4 1 5 4", "4\n4 3 2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "二分", "POI（波兰）", "网络流", "Special Judge", "欧拉回路"], "title": "[POI 2010] MOS-Bridges", "background": "", "description": "San Bytecisco is a beautifully situated coastal town. It consists of n small, yet densely populated islands, numbered from 1 to n. Certain islands are connected with bridges, used for (bidirectional) road traffic. Each pair of islands can be connected with at most one bridge. The islands are connected in such a way that every island can be reached from every other by using the bridges only.\n\nByteasar and Bytie are going for a bike trip in San Bytecisco. The will start their ride at the island no. 1. They intend to visit every island, while passing along every bridge once and ending the trip where it began, i.e., the island no. 1. Being quite seasoned riders, they expect some serious trouble from... the wind! After all, it is very windy along the coast, and especially so on the bridges between the islands. Obviously, depending on its speed and direction, the wind makes it hard to cross the bridge in different extent for either direction. For simplicity we will assume for every bridge and direction of crossing, the opposing wind speed is constant.\n\nHelp Byteasar and Bytie to find a route as they desire that will in addition be the least tiresome. Byteasar and Bytie agreed on the maximum opposing wind speed as a measure of a route's tiresomeness.", "inputFormat": "In the first line of the standard input there are two integers separated by a single space: $n$ and $m$ ($2 \\le n \\le 1000$, $1 \\le m \\le 2000$), denoting the number of islands and the number of bridges in San Bytecisco respectively. The islands are numbered from 1 to n, while the bridges from 1 to m. The following  lines specify the bridges. The line no.($n+1$)  contains four integers $a_i,b_i,l_i,p_i$ ($1\\le l_i,p_i \\le 1000$), separated by single spaces. These denote that the bridge no. $i$ connects the islands no. $a$ and $b$. The opposing wind speeds are  when one goes moves from  to , and  if one goes from $a$ to $b$.", "outputFormat": "If there is no route satisfying the requirements of the daring two riders,   the first and only line of the standard output should hold the word NIE   (no in Polish).\n\nOtherwise, the output should have two lines, specifying the least tiresome route   over San Bytecisco.\n\nThe first line should hold the maximum opposing wind speed for that route, i.e.,   the number we wish to minimize.\n\nThe second line should hold ![](http://main.edu.pl/images/OI17/mos-en-tex.28.png) integers, separated by single spaces, giving   the numbers of successive bridges one crosses on the least tiresome route.\n\nShould there be more than one least tiresome route, your program can pick one   arbitrarily.\n", "hint": "$2 \\le n \\le 1000$，$1 \\le m \\le 2000$，$1 \\le a_i,b_i \\le n$，$a_i \\neq b_i$，$1 \\le l_i,p_i \\le 1000$\n", "locale": "en", "translations": {"en": {"title": "[POI 2010] MOS-Bridges", "background": "", "description": "San Bytecisco is a beautifully situated coastal town. It consists of n small, yet densely populated islands, numbered from 1 to n. Certain islands are connected with bridges, used for (bidirectional) road traffic. Each pair of islands can be connected with at most one bridge. The islands are connected in such a way that every island can be reached from every other by using the bridges only.\n\nByteasar and Bytie are going for a bike trip in San Bytecisco. The will start their ride at the island no. 1. They intend to visit every island, while passing along every bridge once and ending the trip where it began, i.e., the island no. 1. Being quite seasoned riders, they expect some serious trouble from... the wind! After all, it is very windy along the coast, and especially so on the bridges between the islands. Obviously, depending on its speed and direction, the wind makes it hard to cross the bridge in different extent for either direction. For simplicity we will assume for every bridge and direction of crossing, the opposing wind speed is constant.\n\nHelp Byteasar and Bytie to find a route as they desire that will in addition be the least tiresome. Byteasar and Bytie agreed on the maximum opposing wind speed as a measure of a route's tiresomeness.", "inputFormat": "In the first line of the standard input there are two integers separated by a single space: $n$ and $m$ ($2 \\le n \\le 1000$, $1 \\le m \\le 2000$), denoting the number of islands and the number of bridges in San Bytecisco respectively. The islands are numbered from 1 to n, while the bridges from 1 to m. The following  lines specify the bridges. The line no.($n+1$)  contains four integers $a_i,b_i,l_i,p_i$ ($1\\le l_i,p_i \\le 1000$), separated by single spaces. These denote that the bridge no. $i$ connects the islands no. $a$ and $b$. The opposing wind speeds are  when one goes moves from  to , and  if one goes from $a$ to $b$.", "outputFormat": "If there is no route satisfying the requirements of the daring two riders,   the first and only line of the standard output should hold the word NIE   (no in Polish).\n\nOtherwise, the output should have two lines, specifying the least tiresome route   over San Bytecisco.\n\nThe first line should hold the maximum opposing wind speed for that route, i.e.,   the number we wish to minimize.\n\nThe second line should hold ![](http://main.edu.pl/images/OI17/mos-en-tex.28.png) integers, separated by single spaces, giving   the numbers of successive bridges one crosses on the least tiresome route.\n\nShould there be more than one least tiresome route, your program can pick one   arbitrarily.\n", "hint": "$2 \\le n \\le 1000$，$1 \\le m \\le 2000$，$1 \\le a_i,b_i \\le n$，$a_i \\neq b_i$，$1 \\le l_i,p_i \\le 1000$\n", "locale": "en"}, "zh-CN": {"title": "[POI 2010] MOS-Bridges", "background": "", "description": "San Bytecisco 是一个风景优美的沿海小镇。\n\n它由一些小而人口稠密的岛屿组成，编号从 $1$ 到 $n$。\n\n某些岛屿之间通过桥梁连接，用于双向的道路交通。\n\n每对岛屿之间最多可以有一座桥。\n\n这些岛屿的连接方式使得每个岛屿都可以通过桥梁到达其他岛屿。\n\nByteasar 和 Bytie 正计划在 San Bytecisco 骑自行车旅行。\n\n他们将从 $1$ 号岛出发。\n\n他们打算访问每个岛屿，同时每座桥只经过一次，并在旅行结束时回到出发地，即 $1$ 号岛。\n\n作为经验丰富的骑手，他们预计会遇到一些严重的麻烦……风！\n\n毕竟，沿海地区风很大，尤其是在岛屿之间的桥上。显然，根据风速和方向，风会在不同程度上使得跨越桥梁变得困难。\n\n为了简单起见，我们假设每座桥和每个跨越方向的逆风速度是恒定的。\n\n帮助 Byteasar 和 Bytie 找到他们想要的路线，并且这条路线的疲劳程度最小。Byteasar 和 Bytie 同意将最大逆风速度作为路线疲劳程度的衡量标准。", "inputFormat": "标准输入的第一行有两个用空格分隔的整数：$n$ 和 $m$（$2 \\le n \\le 1000$，$1 \\le m \\le 2000$），分别表示 San Bytecisco 的岛屿数量和桥梁数量。岛屿编号从 1 到 $n$，桥梁编号从 1 到 $m$。接下来的行指定了桥梁。第 ($n+1$) 行包含四个用空格分隔的整数 $a_i,b_i,l_i,p_i$（$1 \\le l_i,p_i \\le 1000$），表示第 $i$ 号桥连接了第 $a$ 号和第 $b$ 号岛屿。当从 $a$ 到 $b$ 移动时的逆风速度为 $l_i$，而从 $b$ 到 $a$ 移动时的逆风速度为 $p_i$。", "outputFormat": "如果没有满足这两位勇敢骑手要求的路线，标准输出的第一行应为单词 NIE（波兰语中的“不”）。\n\n否则，输出应有两行，指定 San Bytecisco 上最不疲劳的路线。\n\n第一行应包含该路线的最大逆风速度，即我们希望最小化的数字。\n\n第二行应包含 $m$ 个整数，用空格分隔，给出在最不疲劳的路线中依次经过的桥梁编号。\n\n如果有多条最不疲劳的路线，程序可以任意选择一条。", "hint": "$2 \\le n \\le 1000$，$1 \\le m \\le 2000$，$1 \\le a_i,b_i \\le n$，$a_i\\neq b_i$，$1 \\le l_i,p_i \\le 1000$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3512", "type": "P", "difficulty": 3, "samples": [["3 9\n5 1 3 5 8 6 6 9 10", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "单调队列", "POI（波兰）", "队列", "双指针 two-pointer"], "title": "[POI 2010] PIL-Pilots", "background": "POI 2010 Round III - day 2 [Pilots](https://szkopul.edu.pl/problemset/problem/lcU5m2RAICwNHsdzydb8JTQw/site/).\n\n", "description": "\n给定 $n, k$ 和一个长度为 $n$ 的序列，求最长的最大值最小值相差不超过 $k$ 的子段。", "inputFormat": "\n第一行两个由空格隔开的整数 $k, n$（$0\\leq k\\leq 2\\times 10 ^ 9$，$1\\leq n\\leq 3\\times 10 ^ 6$），$k$ 表示设定的极差的最大值，$n$ 表示序列的长度。\n\n第二行 $n$ 个由空格隔开的整数 $a_i$（$1\\leq a_i\\leq 2\\times 10^ 9$）表示序列。\n", "outputFormat": "\n一个整数表示符合条件的子段的长度最大值。\n", "hint": "样例解释：$5, 8, 6, 6$ 和 $8, 6, 6, 9$ 都是满足条件长度为 $4$ 的子段。\n\n---\n\n作者：Piotr Chrząstowski", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2010] Pilots", "background": "Source: POI 2010 Round III - day 2 [Pilots](https://szkopul.edu.pl/problemset/problem/lcU5m2RAICwNHsdzydb8JTQw/site/).\n\n", "description": "In the Byteotian Training Centre, the pilots prepare for missions requiring extraordinary precision and control. One measure of a pilot's capability is the duration he is able to fly along a desired route without deviating too much - simply put, whether he can fly steadily. This is not an easy task, as the simulator is so sensitive that it registers even a slightest move of the yoke¹. At each moment the simulator stores a single parameter describing the yoke's position. Before each training session a certain tolerance level $t$ is set. The pilots' task then is to fly as long as they can in such a way that all the yoke's position measured during the flight differ by at most $t$. In other words, a fragment of the flight starting at time $i$ and ending at time $j$ is within tolerance level $t$ if the position measurements, starting with $i$-th and ending with $j$-th, form such a sequence $a_i, \\dots, a_j$ that for all elements $a_k, a_l$ of this sequence, the inequality $|a_k - a_l| \\le t$ holds.\n\nYour task is to write a program that, given a number $t$ and the sequence of yoke's position measurements, determines the length of the longest fragment of the flight that is within the tolerance level $t$.\n\n1. Flight control device ", "inputFormat": "\nIn the first line of the standard input two integers are given, $t$ and $n$ ($0 \\le t \\le 2\\,000\\,000\\,000$, $1 \\le n \\le 3\\,000\\,000$), separated by a single space, denoting the tolerance level and the number of yoke's position measurements taken. The second line gives those measurements, separated by single spaces. Each measurement is an integer from the interval from $1$ to $2\\,000\\,000\\,000$.\n", "outputFormat": "\nYour program should print a single integer to the standard output: the maximum length of a fragment of the flight that is within the given tolerance level.", "hint": "\n### Explanation of the example:\nThere are two longest fragments, both of length 4: $5, 8, 6, 6$ and $8, 6, 6, 9$.\n\nTask Author: Piotr Chrząstowski.", "locale": "en"}, "zh-CN": {"title": "[POI 2010] PIL-Pilots", "background": "POI 2010 Round III - day 2 [Pilots](https://szkopul.edu.pl/problemset/problem/lcU5m2RAICwNHsdzydb8JTQw/site/).\n\n", "description": "\n给定 $n, k$ 和一个长度为 $n$ 的序列，求最长的最大值最小值相差不超过 $k$ 的子段。", "inputFormat": "\n第一行两个由空格隔开的整数 $k, n$（$0\\leq k\\leq 2\\times 10 ^ 9$，$1\\leq n\\leq 3\\times 10 ^ 6$），$k$ 表示设定的极差的最大值，$n$ 表示序列的长度。\n\n第二行 $n$ 个由空格隔开的整数 $a_i$（$1\\leq a_i\\leq 2\\times 10^ 9$）表示序列。\n", "outputFormat": "\n一个整数表示符合条件的子段的长度最大值。\n", "hint": "样例解释：$5, 8, 6, 6$ 和 $8, 6, 6, 9$ 都是满足条件长度为 $4$ 的子段。\n\n---\n\n作者：Piotr Chrząstowski", "locale": "zh-CN"}}}
{"pid": "P3513", "type": "P", "difficulty": 6, "samples": [["4\n2 2 3\n2 1 3\n3 1 2 4\n1 3", "3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2011", "POI（波兰）", "2-SAT", "构造"], "title": "[POI 2011] KON-Conspiracy", "background": "", "description": "Hostile Bitotia launched a sneak attack on Byteotia and occupied a significant part of its territory.\n\nThe King of Byteotia, Byteasar, intends to organise resistance movement in the occupied area.\n\nByteasar naturally started with selecting the people who will form the skeleton of the movement.\n\nThey are to be partitioned into two groups:\n\nthe conspirators who will operate directly in the occupied territory, and    the support group that will operate inside free Byteotia.\n\nThere is however one issue - the partition has to satisfy the following conditions:\n\nEvery pair of people from the support group have to know each other - this        will make the whole group cooperative and efficient.\n\nThe conspirators must not know each other.\n\nNone of the groups may be empty, i.e., there has to be at least one conspirator        and at least one person in the support group.\n\nByteasar wonders how many ways there are of partitioning selected people into    the two groups.\n\nAnd most of all, whether such partition is possible at all.\n\nAs he has absolutely no idea how to approach this problem, he asks you for help.\n\n\n", "inputFormat": "The first line of the standard input holds one integer $n$ ($2\\le n\\le 5000$),      denoting the number of people engaged in forming the resistance movement.\n\nThese people are numbered from 1 to $n$ (for the sake of conspiracy!).\n\nThe $n$ lines that follow describe who knows who in the group.\n\nThe $i$-th of these lines describes the acquaintances of the person $i$ with a sequence of integers separated by single spaces.\n\nThe first of those numbers, $k_i$ ($0\\le k_i\\le n-1$), denotes the number of acquaintances of the person $i$.\n\nNext in the line there are $k_i$ integers $a_{i,1},a_{i,2},\\cdots,a_{i,k_i}$ - the numbers of $i$'s acquaintances.The numbers $a_{i,j}$ are given in increasing order and satisfy $1\\le a_{i,j}\\le n$,$a_{i,j}\\ne i$. You may assume that if $x$ occurs in the sequence $a_i$ (i.e., among $i$'s acquaintances), then also $i$ occurs in the sequence $a_x$(i.e., among $x$'s acquaintances).\n", "outputFormat": "In the first and only line of the standard output your program should print out one integer:\n\nthe number of ways to partition selected people into the conspirators and the support group.\n\nIf there is no partition satisfying aforementioned conditions, then 0 is obviously the right answer.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] KON-Conspiracy", "background": "", "description": "Hostile Bitotia launched a sneak attack on Byteotia and occupied a significant part of its territory.\n\nThe King of Byteotia, Byteasar, intends to organise resistance movement in the occupied area.\n\nByteasar naturally started with selecting the people who will form the skeleton of the movement.\n\nThey are to be partitioned into two groups:\n\nthe conspirators who will operate directly in the occupied territory, and    the support group that will operate inside free Byteotia.\n\nThere is however one issue - the partition has to satisfy the following conditions:\n\nEvery pair of people from the support group have to know each other - this        will make the whole group cooperative and efficient.\n\nThe conspirators must not know each other.\n\nNone of the groups may be empty, i.e., there has to be at least one conspirator        and at least one person in the support group.\n\nByteasar wonders how many ways there are of partitioning selected people into    the two groups.\n\nAnd most of all, whether such partition is possible at all.\n\nAs he has absolutely no idea how to approach this problem, he asks you for help.\n\n\n", "inputFormat": "The first line of the standard input holds one integer $n$ ($2\\le n\\le 5000$),      denoting the number of people engaged in forming the resistance movement.\n\nThese people are numbered from 1 to $n$ (for the sake of conspiracy!).\n\nThe $n$ lines that follow describe who knows who in the group.\n\nThe $i$-th of these lines describes the acquaintances of the person $i$ with a sequence of integers separated by single spaces.\n\nThe first of those numbers, $k_i$ ($0\\le k_i\\le n-1$), denotes the number of acquaintances of the person $i$.\n\nNext in the line there are $k_i$ integers $a_{i,1},a_{i,2},\\cdots,a_{i,k_i}$ - the numbers of $i$'s acquaintances.The numbers $a_{i,j}$ are given in increasing order and satisfy $1\\le a_{i,j}\\le n$,$a_{i,j}\\ne i$. You may assume that if $x$ occurs in the sequence $a_i$ (i.e., among $i$'s acquaintances), then also $i$ occurs in the sequence $a_x$(i.e., among $x$'s acquaintances).\n", "outputFormat": "In the first and only line of the standard output your program should print out one integer:\n\nthe number of ways to partition selected people into the conspirators and the support group.\n\nIf there is no partition satisfying aforementioned conditions, then 0 is obviously the right answer.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] KON-Conspiracy", "background": null, "description": "敌对的 Bitotia 发动了一次对 Byteotia 的突袭，并占领了其大部分领土。\n\nByteotia 的国王 Byteasar 打算在被占领地区组织抵抗运动。\n\nByteasar 自然地从选择将组成运动骨干的人开始。\n\n他们将被分为两组：\n\n阴谋者将在被占领的领土上直接行动，而支援小组将在自由的 Byteotia 内部运作。\n\n然而，有一个问题——分组必须满足以下条件：\n\n支援小组中的每一对人必须彼此认识——这将使整个小组合作高效。\n\n阴谋者之间不能相互认识。\n\n没有一个小组可以为空，即必须至少有一个阴谋者和至少一个支援小组成员。\n\nByteasar 想知道有多少种方法可以将选定的人分成这两组。\n\n最重要的是，这样的分组是否可能。\n\n由于他完全不知道如何解决这个问题，他向你求助。", "inputFormat": "标准输入的第一行包含一个整数 $n$（$2 \\le n \\le 5000$），表示参与抵抗运动的人数。\n\n这些人被编号为 1 到 $n$（为了保密！）。\n\n接下来的 $n$ 行描述了小组中谁认识谁。\n\n第 $i$ 行描述了第 $i$ 个人的熟人，以用空格分隔的整数序列表示。\n\n这些数字中的第一个，$k_i$（$0 \\le k_i \\le n-1$），表示第 $i$ 个人的熟人数。\n\n接下来是 $k_i$ 个整数 $a_{i,1},a_{i,2},\\cdots,a_{i,k_i}$——$i$ 的熟人的编号。数字 $a_{i,j}$ 按递增顺序给出，并满足 $1 \\le a_{i,j} \\le n$，$a_{i,j} \\neq i$。可以假设如果 $x$ 出现在序列 $a_i$ 中（即在 $i$ 的熟人中），那么 $i$ 也出现在序列 $a_x$ 中（即在 $x$ 的熟人中）。", "outputFormat": "在标准输出的第一行，你的程序应输出一个整数：\n\n将选定的人分为阴谋者和支援小组的方法数。\n\n如果没有满足上述条件的分组，那么显然 $0$ 是正确答案。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3514", "type": "P", "difficulty": 5, "samples": [["5 3\nTWTWT\n5\n1\n7", "1 3\n2 2\nNIE"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "POI（波兰）", "Special Judge", "前缀和"], "title": "[POI 2011] LIZ-Lollipop", "background": "", "description": "Byteasar runs a confectionery in Byteburg.\n\nStrawberry-vanilla flavoured lollipops are the favourite of local children.\n\nThese lollipops are composed of multiple segments of the same length, each    segment of either strawberry or vanilla flavour.\n\nThe price of the lollipop is the sum of the values of its segments, where    a vanilla segment costs one bythaler, while a strawberry segments costs two.\n\nFig. 1: An exemplary lollipop of five segments,      three strawberry flavoured and two vanilla, alternately.\n\nThe price of this lollipop is $8$ bythalers.\n\nCurrently Byteasar is left with only one lollipop, though possibly very long.\n\nAs a salesman, he knows only too well that probably no one will want to buy    the whole lollipop. For this reason he thinks of breaking the lollipop at the    joints of the segments in order to get a shorter lollipop. Each fragment for    sale, of course, must stay in one piece.\n\nByteasar vast experience of a salesman, as well as his understanding of children    psychology, tell him that his young customers will most likely want to spend    all their money on a single lollipop. With this in mind, he wonders for which    values of $k$ the lollipop he has can be broken down in such a way that as a    result one would get, among other pieces, a lollipop worth exactly $k$  bythalers.\n\nNaturally, he is interested in the way of breaking the lollipop as well.\n\nAs this task overwhelms him, he asks you for help.\n\n", "inputFormat": "In the first line of the standard input there are two integers $n$ and $m$      ($1\\le n,m \\le 1\\ 000\\ 000$), separated by a single space.\n\nThese denote, respectively, the number of segments of the last lollipop left      in store, and the number of values of $k$ to consider.\n\nThe lollipop's segments are numbered from 1 to $n$.\n\nThe second line gives an $n$-letter description of the lollipop, consisting      of letters T and W, where T denotes a strawberry flavoured segment, while W - vanilla flavoured;the $i$-th of these letters specifies the flavour of the $i$-th segment.\n\nIn the following $m$ lines successive values of $k$($1\\le k\\le 2\\ 000\\ 000$) to consider are given, one per line.\n", "outputFormat": "Your program should print out exactly $m$ lines, giving, one per line,      the results for successive values of $k$, to the standard output.\n\nIf for a given value of $k$ it is impossible to break the lollipop in such a way that there is a contiguous fragment worth exactly $k$ bythalers, then the word      NIE (no in Polish) should be printed. Otherwise, two integers $l$ and $r$ ($1\\le l\\le r\\le n$), separated by single spaces, should      be printed, such that the fragment of the lollipop composed of the segments      numbered from $l$ to $r$ inclusively is worth exactly $k$ bythalers. If there are multiple such pairs, your program is free to choose one arbitrarily.\n", "hint": "\nSPJ 对于格式的要求较为严格。对于每个询问后，应紧跟一个换行符。在最后一次输出你的答案以及一个换行符后不应有任何输出。\n\n\n由 zhouyonglong 提供 SPJ。\n", "locale": "en", "translations": {"en": {"title": "[POI 2011] LIZ-Lollipop", "background": "", "description": "Byteasar runs a confectionery in Byteburg.\n\nStrawberry-vanilla flavoured lollipops are the favourite of local children.\n\nThese lollipops are composed of multiple segments of the same length, each    segment of either strawberry or vanilla flavour.\n\nThe price of the lollipop is the sum of the values of its segments, where    a vanilla segment costs one bythaler, while a strawberry segments costs two.\n\nFig. 1: An exemplary lollipop of five segments,      three strawberry flavoured and two vanilla, alternately.\n\nThe price of this lollipop is $8$ bythalers.\n\nCurrently Byteasar is left with only one lollipop, though possibly very long.\n\nAs a salesman, he knows only too well that probably no one will want to buy    the whole lollipop. For this reason he thinks of breaking the lollipop at the    joints of the segments in order to get a shorter lollipop. Each fragment for    sale, of course, must stay in one piece.\n\nByteasar vast experience of a salesman, as well as his understanding of children    psychology, tell him that his young customers will most likely want to spend    all their money on a single lollipop. With this in mind, he wonders for which    values of $k$ the lollipop he has can be broken down in such a way that as a    result one would get, among other pieces, a lollipop worth exactly $k$  bythalers.\n\nNaturally, he is interested in the way of breaking the lollipop as well.\n\nAs this task overwhelms him, he asks you for help.\n\n", "inputFormat": "In the first line of the standard input there are two integers $n$ and $m$      ($1\\le n,m \\le 1\\ 000\\ 000$), separated by a single space.\n\nThese denote, respectively, the number of segments of the last lollipop left      in store, and the number of values of $k$ to consider.\n\nThe lollipop's segments are numbered from 1 to $n$.\n\nThe second line gives an $n$-letter description of the lollipop, consisting      of letters T and W, where T denotes a strawberry flavoured segment, while W - vanilla flavoured;the $i$-th of these letters specifies the flavour of the $i$-th segment.\n\nIn the following $m$ lines successive values of $k$($1\\le k\\le 2\\ 000\\ 000$) to consider are given, one per line.\n", "outputFormat": "Your program should print out exactly $m$ lines, giving, one per line,      the results for successive values of $k$, to the standard output.\n\nIf for a given value of $k$ it is impossible to break the lollipop in such a way that there is a contiguous fragment worth exactly $k$ bythalers, then the word      NIE (no in Polish) should be printed. Otherwise, two integers $l$ and $r$ ($1\\le l\\le r\\le n$), separated by single spaces, should      be printed, such that the fragment of the lollipop composed of the segments      numbered from $l$ to $r$ inclusively is worth exactly $k$ bythalers. If there are multiple such pairs, your program is free to choose one arbitrarily.\n", "hint": "\nSPJ 对于格式的要求较为严格。对于每个询问后，应紧跟一个换行符。在最后一次输出你的答案以及一个换行符后不应有任何输出。\n\n\n由 zhouyonglong 提供 SPJ。\n", "locale": "en"}, "zh-CN": {"title": "[POI 2011] LIZ-Lollipop", "background": "", "description": "给一个只有 $1$ 和 $2$ 的序列，每次询问有没有一个子串的和为 $x$。", "inputFormat": "第一行两个整数 $n, m$（$1 \\le n, m \\le 10 ^ 6$）。\n\n第二行一个长为 $n$ 的只含 $\\texttt T$ 和 $\\texttt W$ 的字符串，$\\texttt T$ 代表 $2$，$\\texttt W$ 代表 $1$。\n\n接下来 $m$ 行，每行一个整数 $x$（$1 \\le x \\le 2\\times 10 ^ 6$）表示一次询问。", "outputFormat": "$m$ 行，如果有解则输出两个整数 $l, r$ 表示区间 $[l, r]$ 的和是 $x$，如果无解则输出字符串 `NIE`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3515", "type": "P", "difficulty": 6, "samples": [["6\n5\n3\n2\n4\n2\n4", "2\n3\n5\n3\n5\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2011", "POI（波兰）", "凸完全单调性（wqs 二分）", "四边形不等式", "栈", "决策单调性"], "title": "[POI 2011] Lightning Conductor", "background": "", "description": "Progressive climate change has forced the Byteburg authorities to build a huge lightning conductor that would protect all the buildings within the city. These buildings form a row along a single street, and are numbered from 1 to $n$.\n\nThe heights of the buildings and the lightning conductor are non - negative integers. Byteburg's limited funds allow construction of only a single lightning conductor. Moreover, as you would expect, the higher it will be, the more expensive.\n\nThe lightning conductor of height $p$ located on the roof of the building $i$ (of height $h_i$) protects the building $j$ (of height $h_j$) if the following inequality holds:\n\n$$h_j \\leq h_i + p-\\sqrt{|i - j|}$$\n\nwhere $|i - j|$ denotes the absolute value of the difference between $i$ and $j$.\n\nByteasar, the mayor of Byteburg, asks your help. Write a program that, for every building $i$, determines the minimum height of a lightning conductor that would protect all the buildings if it were put on top of the building $i$.", "inputFormat": "In the first line of the standard input there is a single integer $n$ ($1\\leq n\\leq500,000$) that denotes the number of buildings in Byteburg. Each of the following $n$ lines holds a single integer $h_i$ ($0\\leq h_i\\leq1,000,000,000$) that denotes the height of the $i$ - th building.", "outputFormat": "Your program should print out exactly $n$ lines to the standard output. The $i$ - th line should give a non - negative integer $p_i$ denoting the minimum height of the lightning conductor on the $i$ - th building. ", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] Lightning Conductor", "background": "", "description": "Progressive climate change has forced the Byteburg authorities to build a huge lightning conductor that would protect all the buildings within the city. These buildings form a row along a single street, and are numbered from 1 to $n$.\n\nThe heights of the buildings and the lightning conductor are non - negative integers. Byteburg's limited funds allow construction of only a single lightning conductor. Moreover, as you would expect, the higher it will be, the more expensive.\n\nThe lightning conductor of height $p$ located on the roof of the building $i$ (of height $h_i$) protects the building $j$ (of height $h_j$) if the following inequality holds:\n\n$$h_j \\leq h_i + p-\\sqrt{|i - j|}$$\n\nwhere $|i - j|$ denotes the absolute value of the difference between $i$ and $j$.\n\nByteasar, the mayor of Byteburg, asks your help. Write a program that, for every building $i$, determines the minimum height of a lightning conductor that would protect all the buildings if it were put on top of the building $i$.", "inputFormat": "In the first line of the standard input there is a single integer $n$ ($1\\leq n\\leq500,000$) that denotes the number of buildings in Byteburg. Each of the following $n$ lines holds a single integer $h_i$ ($0\\leq h_i\\leq1,000,000,000$) that denotes the height of the $i$ - th building.", "outputFormat": "Your program should print out exactly $n$ lines to the standard output. The $i$ - th line should give a non - negative integer $p_i$ denoting the minimum height of the lightning conductor on the $i$ - th building. ", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] Lightning Conductor", "background": "", "description": "逐渐变化的气候迫使 Byteburg 当局建造一个巨大的避雷针，以保护城市内的所有建筑物。\n\n这些建筑物沿着一条街道排成一行，编号从 $1$ 到 $n$。\n\n建筑物和避雷针的高度是非负整数。\n\nByteburg 的资金有限，只能建造一个避雷针。\n\n而且，正如你所料，避雷针越高，成本越高。\n\n位于建筑物 $i$（高度为 $h_i$）屋顶上的高度为 $k$ 的避雷针可以保护建筑物 $j$（高度为 $h_j$），如果满足以下不等式：\n\n$$k + h_i \\geq h_j + \\sqrt{|i-j|}$$\n\n其中 $|i - j|$ 表示 $i$ 和 $j$ 之间的绝对差值。\n\nByteburg 的市长 Byteasar 请求你的帮助。\n\n编写一个程序，对于每个建筑物 $i$，确定如果将避雷针放在建筑物 $i$ 上，能够保护所有建筑物的避雷针的最小高度。", "inputFormat": "标准输入的第一行有一个整数 $n$ ($1 \\leq n \\leq 500,000$)，表示 Byteburg 中的建筑物数量。\n\n接下来的 $n$ 行中的每一行包含一个整数 $h_i$ ($0 \\leq h_i \\leq 1,000,000,000$)，表示第 $i$ 个建筑物的高度。", "outputFormat": "你的程序应输出恰好 $n$ 行到标准输出。\n\n第 $i$ 行应给出一个非负整数 $k_i$，表示第 $i$ 个建筑物上避雷针的最小高度。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3516", "type": "P", "difficulty": 5, "samples": [["4\n1 3 2 4", "4\n3a 2b 2a 2b"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2011", "POI（波兰）", "Special Judge", "O2优化", "排序", "构造", "Ad-hoc"], "title": "[POI 2011] PRZ-Shift", "background": "", "description": "Byteasar bought his son Bytie a set of blocks numbered from $1$ to $n$ and arranged them in a row in a certain order.\n\nBytie's goal is to rearrange the blocks so that they are ordered naturally, from the smallest number to the largest.\n\nHowever, the only moves Bytie is allowed to make are:\n\nputting the last block at the very beginning (move a), and                  putting the third block at the very beginning (move b).\n\nHelp Bytie by writing a program that tells whether a given arrangement of    blocks can be properly reordered, and tells the right sequence of moves if it is.\n", "inputFormat": "In the first line of the standard input there is a single integer $n$, $1\\le n\\le 2\\ 000$.\n\nIn the second line there are $n$ integers from the range $1$ to $n$, separated by single spaces.\n\nNo number appears twice, and thus they represent the initial arrangement of the blocks.\n", "outputFormat": "If there is no sequence of moves leading to an arrangement with increasing blocks' numbers, your program should print out \"NIE DA SIE\" (there is no way in Polish), without the quotation marks.\n\nOtherwise there should be a single integer $m$ ($m\\le n^2$), denoting the number of operations, in the first line.\n\nAn operation is a $k$-fold execution of either a or b move.\n\nIf $m>0$, then there should be a sequence of $m$ integers with either a or b appended in the second line.\n\nThus $k$a (for $0<k<n$) denotes the $k$-fold execution of the move a.\n\nAnalogously, $k$b (for $0<k<n$) denotes the $k$-fold execution of the move b.\n\nFurthermore, the characters appended to the numbers in the second line have to alternate.\n\nShould there be more than one solution, your program is free to pick one arbitrarily.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] PRZ-Shift", "background": "", "description": "Byteasar bought his son Bytie a set of blocks numbered from $1$ to $n$ and arranged them in a row in a certain order.\n\nBytie's goal is to rearrange the blocks so that they are ordered naturally, from the smallest number to the largest.\n\nHowever, the only moves Bytie is allowed to make are:\n\nputting the last block at the very beginning (move a), and                  putting the third block at the very beginning (move b).\n\nHelp Bytie by writing a program that tells whether a given arrangement of    blocks can be properly reordered, and tells the right sequence of moves if it is.\n", "inputFormat": "In the first line of the standard input there is a single integer $n$, $1\\le n\\le 2\\ 000$.\n\nIn the second line there are $n$ integers from the range $1$ to $n$, separated by single spaces.\n\nNo number appears twice, and thus they represent the initial arrangement of the blocks.\n", "outputFormat": "If there is no sequence of moves leading to an arrangement with increasing blocks' numbers, your program should print out \"NIE DA SIE\" (there is no way in Polish), without the quotation marks.\n\nOtherwise there should be a single integer $m$ ($m\\le n^2$), denoting the number of operations, in the first line.\n\nAn operation is a $k$-fold execution of either a or b move.\n\nIf $m>0$, then there should be a sequence of $m$ integers with either a or b appended in the second line.\n\nThus $k$a (for $0<k<n$) denotes the $k$-fold execution of the move a.\n\nAnalogously, $k$b (for $0<k<n$) denotes the $k$-fold execution of the move b.\n\nFurthermore, the characters appended to the numbers in the second line have to alternate.\n\nShould there be more than one solution, your program is free to pick one arbitrarily.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] PRZ-Shift", "background": "", "description": "**译自 POI 2011 Round 1. D「[Shift](https://szkopul.edu.pl/problemset/problem/n6S4y9QrbGqYUz64e2O-OV7D/site/?key=statement)」**\n\nByteasar 给他的儿子 Bytie 买了一盒共 $ n $ 块积木，他将这些积木从 $ 1 $ 到 $ n $ 编号，并按照一定的顺序摆成一排。Bytie 要将这些积木按照编号从小到大的顺序重新排列，但他只能做下面两种操作：\n\n* 操作 a：将最后一个积木移到最前面。\n* 操作 b：把第三个积木移到最前面。\n\n我们将连续进行 $ k $ 次同一个操作称为「一块操作」，表示为 $ k a $ 或 $ k b $。  \n你需要帮助 Bytie 写一个程序，告诉他有没有一个操作序列能够使积木按照编号从小到大的顺序重新排列，并告诉他操作序列。", "inputFormat": "输入的第一行包含一个整数 $ n $，表示积木的个数。\n第二行包含 $ n $ 个整数，表示积木初始的排列顺序，没有重复的数字。", "outputFormat": "如果没有一种方案能将积木按照编号从小到大的顺序重新排列，你应当输出 `NIE DA SIE`（波兰语中的 `There is no way`）。\n\n否则，第一行你应当输出一个整数 $ m $，表示操作的**块数**，$ m $ 必须满足 $ m \\le n^2 $。  \n第二行表示这 $ m $ 块操作，每块操作之间用空格隔开。  \n每一块包含操作数 $ k $ 和操作方式，中间**没有**空格，如 `3a`（$ 3 $ 次 a 操作）。  \n需要满足相邻两块操作的种类不同，每块操作中进行的次数 $ 0 \\lt k \\lt n $。", "hint": "对于 $ 100\\% $ 的数据，$ 1 \\le n \\le 2000 $。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2158)，checker 来自于 [帖子](https://www.luogu.com.cn/discuss/70755)。", "locale": "zh-CN"}}}
{"pid": "P3517", "type": "P", "difficulty": 7, "samples": [["7 2\n2 0\n0 4\n4 4\n4 2\n8 2\n11 3\n14 2", "3.00000000\n2\n2.00000000 1.76393202\n11.00000000 1.99998199"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "倍增", "二分", "POI（波兰）", "Special Judge"], "title": "[POI 2011] WYK-Plot", "background": "", "description": "We call any sequence of points in the plane a plot.\n\nWe intend to replace a given plot $(P_1,\\cdots,P_n)$ with another that will    have at most $m$ points ($m\\le n$) in such a way that it \"resembles\" the    original plot best.\n\nThe new plot is created as follows. The sequence of points $P_1,\\cdots,P_n$ can be partitioned into $s$ ($s\\le m$) contiguous subsequences:\n\n$(P_{k_0+1},\\cdots,P_{k_1}),(P_{k_1+1},\\cdots,P_{k_2}),\\cdots,(P_{k_{s-1}+1},\\cdots,P_{k_s})$ where $0=k_0<k_1<k_2<\\cdots<k_s=n$,and afterwards each subsequence $(P_{k_{i-1}+1},\\cdots,P_{k_i})$, for $i=1,\\cdots,s$,is replaced by a new point $Q_i$.\n\nIn that case we say that each of the points $P_{k_{i-1}+1},\\cdots,P_{k_i}$ has been contracted to the point $Q_i$.\n\nAs a result a new plot, represented by the points $Q_1,\\cdots,Q_s$, is created.\n\nThe measure of such plot's resemblance to the original is the maximum distance of all the points $P_1,\\cdots,P_n$ to the point it has been contracted to:\n\n$max_{i=1,\\cdots,s}(max_{j=k_{i-1}+1,\\cdots,k_i}(d(P_j,Q_i)))$    where $d(P_j,Q_i)$ denotes the distance between $P_j$ and $Q_i$, given by the well-known formula:\n\n$d((x_1,y_1),(x_2,y_2))=\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$\n\n ![](https://cdn.luogu.com.cn/upload/pic/6975.png) \n\nAn exemplary plot $P_1,\\cdots,P_7$ and the new plot $(Q_1,Q_2)$, where $(P_1,\\cdots,P_4)$ are contracted to $Q_1$, whereas $(P_5,P_6,P_7)$ to $Q_2$.\n\nFor a given plot consisting of $n$ points, you are to find the plot that    resembles it most while having at most $m$ points,    where the partitioning into contiguous subsequences is arbitrary.\n\nDue to limited precision of floating point operations, a result is deemed    correct if its resemblance to the given plot is larger than the optimum    resemblance by at most $0.000001$.", "inputFormat": "In the first line of the standard input there are two integers $n$ and $m$,      $1\\le m\\le n\\le 100\\ 000$, separated by a single space.\n\nEach of the following $n$ lines holds two integers, separated by a single space.\n\nThe $(i+1)$-th line gives $x_i$,$y_i$,$-1\\ 000\\ 000\\le x_i,y_i\\le 1\\ 000\\ 000$ denoting the coordinates $(x_i,y_i)$ of the point $P_i$.\n", "outputFormat": "In the first line of the standard output one real number $d$ should be printed out,      the resemblance measure of the plot found to the original one.\n\nIn the second line of the standard output there should be another integer $s$, $1\\le s\\le m$.\n\nNext, the following $s$ lines should specify the coordinates of the points $Q_1,\\cdots,Q_s$,one point per line.\n\nThus the $(i+2)$-th line should give two real numbers $u_i$ and $v_i$,      separated by a single space, that denote the coordinates $(u_i,v_i)$ of the point $Q_i$.All the real numbers should be printed with at most 15 digits after the decimal point.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] WYK-Plot", "background": "", "description": "We call any sequence of points in the plane a plot.\n\nWe intend to replace a given plot $(P_1,\\cdots,P_n)$ with another that will    have at most $m$ points ($m\\le n$) in such a way that it \"resembles\" the    original plot best.\n\nThe new plot is created as follows. The sequence of points $P_1,\\cdots,P_n$ can be partitioned into $s$ ($s\\le m$) contiguous subsequences:\n\n$(P_{k_0+1},\\cdots,P_{k_1}),(P_{k_1+1},\\cdots,P_{k_2}),\\cdots,(P_{k_{s-1}+1},\\cdots,P_{k_s})$ where $0=k_0<k_1<k_2<\\cdots<k_s=n$,and afterwards each subsequence $(P_{k_{i-1}+1},\\cdots,P_{k_i})$, for $i=1,\\cdots,s$,is replaced by a new point $Q_i$.\n\nIn that case we say that each of the points $P_{k_{i-1}+1},\\cdots,P_{k_i}$ has been contracted to the point $Q_i$.\n\nAs a result a new plot, represented by the points $Q_1,\\cdots,Q_s$, is created.\n\nThe measure of such plot's resemblance to the original is the maximum distance of all the points $P_1,\\cdots,P_n$ to the point it has been contracted to:\n\n$max_{i=1,\\cdots,s}(max_{j=k_{i-1}+1,\\cdots,k_i}(d(P_j,Q_i)))$    where $d(P_j,Q_i)$ denotes the distance between $P_j$ and $Q_i$, given by the well-known formula:\n\n$d((x_1,y_1),(x_2,y_2))=\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$\n\n ![](https://cdn.luogu.com.cn/upload/pic/6975.png) \n\nAn exemplary plot $P_1,\\cdots,P_7$ and the new plot $(Q_1,Q_2)$, where $(P_1,\\cdots,P_4)$ are contracted to $Q_1$, whereas $(P_5,P_6,P_7)$ to $Q_2$.\n\nFor a given plot consisting of $n$ points, you are to find the plot that    resembles it most while having at most $m$ points,    where the partitioning into contiguous subsequences is arbitrary.\n\nDue to limited precision of floating point operations, a result is deemed    correct if its resemblance to the given plot is larger than the optimum    resemblance by at most $0.000001$.", "inputFormat": "In the first line of the standard input there are two integers $n$ and $m$,      $1\\le m\\le n\\le 100\\ 000$, separated by a single space.\n\nEach of the following $n$ lines holds two integers, separated by a single space.\n\nThe $(i+1)$-th line gives $x_i$,$y_i$,$-1\\ 000\\ 000\\le x_i,y_i\\le 1\\ 000\\ 000$ denoting the coordinates $(x_i,y_i)$ of the point $P_i$.\n", "outputFormat": "In the first line of the standard output one real number $d$ should be printed out,      the resemblance measure of the plot found to the original one.\n\nIn the second line of the standard output there should be another integer $s$, $1\\le s\\le m$.\n\nNext, the following $s$ lines should specify the coordinates of the points $Q_1,\\cdots,Q_s$,one point per line.\n\nThus the $(i+2)$-th line should give two real numbers $u_i$ and $v_i$,      separated by a single space, that denote the coordinates $(u_i,v_i)$ of the point $Q_i$.All the real numbers should be printed with at most 15 digits after the decimal point.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] WYK-Plot", "background": "", "description": "**译自 POI 2011 Round 1. E「[Plot](https://szkopul.edu.pl/problemset/problem/mzrTn1kzVBOAwVYn55LUeAai/site/?key=statement)」**\n\n给定 $n$ 个点 $ \\left( P_1, \\ldots, P_n \\right) $，将其分成不多于 $m$ 个连续的段：\n\n$$ \\left( P_{k_0 + 1}, \\ldots, P_{k_1} \\right), \\left( P_{k_1 + 1}, \\ldots, P_{k_2} \\right), \\ldots, \\left( P_{k_{s - 1}+ 1}, \\ldots, P_{k_s} \\right), $$\n\n其中 $ 0 = k_0 \\lt k_1 \\lt k_2 \\lt \\ldots \\lt k_s = n $，且对于 $ i = 1, \\ldots, s $，子序列 $ \\left( P_{k_{i - 1}+ 1}, \\ldots, P_{k_i} \\right) $ 用一个新点 $Q_i$ 替代。这时我们说 $ P_{k_i - 1}, \\ldots, P_{k_i} $ 这些点被「收缩」到了点 $Q_i$，从而产生一个新的点集 $ Q_1, \\ldots, Q_s $。两个点集的相似度定义为 $ P_1, \\ldots, P_n $ 这些点与其对应的「收缩」后的点距离的最大值：\n\n$$ \\max_{i = 1, \\ldots, s} \\left( \\max_{j = k_{i-1}+1, \\ldots, k_i}\\left( d\\left( P_j, Q_i \\right) \\right) \\right) ,$$\n\n其中 $ d\\left( P_j, Q_i \\right) $ 表示 $P_j$ 和 $Q_i$ 之间的距离，公式为：\n\n$$ d \\left( \\left(x_1, y_1 \\right), \\left( x_2, y_2 \\right) \\right) = \\sqrt{ \\left( x_2 - x_1 \\right)^2 + \\left( y_2 - y_1 \\right)^2 } $$\n\n ![](https://cdn.luogu.com.cn/upload/pic/6975.png) \n\n上图为一个将 $ (P_1, \\ldots, P_7) $ 收缩为 $ ( Q_1, Q_2 ) $ 的例子，其中 $ (P_1, \\ldots, P_4) $ 被收缩为 $ Q_1 $，$ (P_5, P_6, P_7) $ 被收缩为 $Q_2$.\n\n给定 $n$ 个点组成的序列，你需要将其「收缩」为最多 $m$ 个点，使得相似度最小。原序列可以任意切割。受限于浮点数的精度限制，只要答案比最优解多出不超过 $ 0.000001$ 即算正确。", "inputFormat": "第一行两个整数 $n$ 和 $m$，$ 1 \\le m \\le n \\le 100000 $，用一个空格分开。\n\n接下来 $n$ 行每行两个整数，用一个空格分开。第 $i+1$ 行两个整数 $x_i, y_i$（$ -1000000 \\le x_i,y_i \\le 1000000$），表示 $P_i$ 的坐标为 $(x_i, y_i)$.", "outputFormat": "第一行一个实数 $d$，表示与原序列的相似度。\n\n接下来一个整数 $s$，表示收缩后点集的大小。\n\n接下来 $s$ 行表示 $Q_i, \\ldots, Q_s$ 的坐标。每行两个整数 $u_i$ 和 $v_i$ 表示 $Q_i$ 的坐标 $ (u_i, v_i) $。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2159)。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3518", "type": "P", "difficulty": 5, "samples": [["42 5\n28 31 10 38 24", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "2011", "POI（波兰）", "最大公约数 gcd"], "title": "[POI 2011] SEJ-Strongbox", "background": "", "description": "Byteasar is a famous safe-cracker, who renounced his criminal activity and    got into testing and certifying anti-burglary devices.\n\nHe has just received a new kind of strongbox for tests: a combinatorial safe.\n\nA combinatorial safe is something different from a combination safe,    even though it is opened with a rotary dial.\n\nThe dial can be set in $n$ different positions, numbered from 0 to $n-1$.\n\nSetting the dial in some of these positions opens the safe, while in others it does not.\n\nAnd here is the combinatorial property, from which the name comes from:\n\nif $x$ and $y$ are opening positions, then so is $(x+y)\\ mod\\ n$ too;    note that is holds for $x=y$ as well.\n\nByteasar tried $k$ different positions of the dial: $m_1,m_2,\\cdots,m_k$.\n\nThe positions $m_1,m_2,\\cdots,m_{k-1}$ did not open the safe,only the last position $m_k$ did.\n\nByteasar is already tired from checking these $k$ positions and has thus    absolutely no intention of trying the remaining ones.\n\nHe would like to know however, based on what he already knows about the    positions he tried, what is the maximum possible number of positions that    open the safe.\n\nHelp him by writing an appropriate program!", "inputFormat": "The first line of the standard input gives two integers $n$ and $k$,      separated by a single space, $1\\le k\\le 250\\ 000$, $k\\le n\\le 10^{14}$.\n\nThe second line holds $k$ different integers, also separated by single      spaces, $m_1,m_2,\\cdots,m_k$, $0\\le m_i<n$.\n\nYou can assume that the input data correspond to a certain combinatorial      safe that complies with the description above.\n\nIn tests worth approximately 70% of the points it holds that $k\\le 1\\ 000$.\n\nIn some of those tests, worth approximately 20% of the points,      the following conditions hold in addition: $n\\le 10^8$ and $k\\le 100$.\n", "outputFormat": "Your program should print out to the first and only line of the standard output a single integer: the maximum number of the dial's positions that can open the safe.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] SEJ-Strongbox", "background": "", "description": "Byteasar is a famous safe-cracker, who renounced his criminal activity and    got into testing and certifying anti-burglary devices.\n\nHe has just received a new kind of strongbox for tests: a combinatorial safe.\n\nA combinatorial safe is something different from a combination safe,    even though it is opened with a rotary dial.\n\nThe dial can be set in $n$ different positions, numbered from 0 to $n-1$.\n\nSetting the dial in some of these positions opens the safe, while in others it does not.\n\nAnd here is the combinatorial property, from which the name comes from:\n\nif $x$ and $y$ are opening positions, then so is $(x+y)\\ mod\\ n$ too;    note that is holds for $x=y$ as well.\n\nByteasar tried $k$ different positions of the dial: $m_1,m_2,\\cdots,m_k$.\n\nThe positions $m_1,m_2,\\cdots,m_{k-1}$ did not open the safe,only the last position $m_k$ did.\n\nByteasar is already tired from checking these $k$ positions and has thus    absolutely no intention of trying the remaining ones.\n\nHe would like to know however, based on what he already knows about the    positions he tried, what is the maximum possible number of positions that    open the safe.\n\nHelp him by writing an appropriate program!", "inputFormat": "The first line of the standard input gives two integers $n$ and $k$,      separated by a single space, $1\\le k\\le 250\\ 000$, $k\\le n\\le 10^{14}$.\n\nThe second line holds $k$ different integers, also separated by single      spaces, $m_1,m_2,\\cdots,m_k$, $0\\le m_i<n$.\n\nYou can assume that the input data correspond to a certain combinatorial      safe that complies with the description above.\n\nIn tests worth approximately 70% of the points it holds that $k\\le 1\\ 000$.\n\nIn some of those tests, worth approximately 20% of the points,      the following conditions hold in addition: $n\\le 10^8$ and $k\\le 100$.\n", "outputFormat": "Your program should print out to the first and only line of the standard output a single integer: the maximum number of the dial's positions that can open the safe.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] SEJ-Strongbox", "background": null, "description": "有一个密码箱，$0$ 到 $n-1$ 中的某些整数是它的密码。且满足：若 $a$ 和 $b$ 是它的密码，则 $(a+b)\\bmod n$ 也是它的密码（$a$，$b$ 可以相等）。某人试了 $k$ 次密码，前 $k-1$ 次都失败了，最后一次成功了。\n\n问，该密码箱最多有多少种不同的密码。", "inputFormat": "第一行两个整数 $n$，$k$。\n\n第二行为 $k$ 个非负整数 $m_i$，表示每次试的密码。", "outputFormat": "一行一个整数，表示答案。", "hint": "### 数据规模与约定\n\n对于约 $20\\%$ 的数据，满足 $1\\le k\\le 100,n\\le 10^{8}$。\n\n对于约 $70\\%$ 的数据，满足 $1\\le k\\le 1000$。\n\n对于 $100\\%$ 的数据，满足 $1\\le k\\le2.5\\times10^5,k\\le n\\le 10^{14},0\\le m<n$。", "locale": "zh-CN"}}}
{"pid": "P3519", "type": "P", "difficulty": 5, "samples": [["10\naabbaaabab", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "POI（波兰）", "枚举"], "title": "[POI 2011] ROZ-Difference", "background": "", "description": "A word consisting of $n$ lower-case letters of the English alphabet ('a'-'z') is given.\n\nWe would like to choose a non-empty contiguous (i.e. one-piece) fragment    of the word so as to maximise the difference in the number of occurrences    of the most and the least frequent letter in the fragment.\n\nWe are assuming that the least frequent letter has to occur at least once in    the resulting fragment.\n\nIn particular, should the fragment contain occurrences of only one letter,    then the most and the least frequent letter in it coincide.\n\n", "inputFormat": "The first line of the standard input holds one integer $n(1\\le n \\le 1,000,000)$ that denotes the length of the word.\n\nThe second line holds a word consisting of $n$ lower-case letters      of the English alphabet.\n\nIn tests worth at least 30% of the points it additionally holds that $n\\le 100$.\n", "outputFormat": "The first and only line of the standard output is to hold a single integer,      equal to the maximum difference in the number of occurrences of the most      and the least frequent letter that is attained in some non-empty contiguous      fragment of the input word.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] ROZ-Difference", "background": "", "description": "A word consisting of $n$ lower-case letters of the English alphabet ('a'-'z') is given.\n\nWe would like to choose a non-empty contiguous (i.e. one-piece) fragment    of the word so as to maximise the difference in the number of occurrences    of the most and the least frequent letter in the fragment.\n\nWe are assuming that the least frequent letter has to occur at least once in    the resulting fragment.\n\nIn particular, should the fragment contain occurrences of only one letter,    then the most and the least frequent letter in it coincide.\n\n", "inputFormat": "The first line of the standard input holds one integer $n(1\\le n \\le 1,000,000)$ that denotes the length of the word.\n\nThe second line holds a word consisting of $n$ lower-case letters      of the English alphabet.\n\nIn tests worth at least 30% of the points it additionally holds that $n\\le 100$.\n", "outputFormat": "The first and only line of the standard output is to hold a single integer,      equal to the maximum difference in the number of occurrences of the most      and the least frequent letter that is attained in some non-empty contiguous      fragment of the input word.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] ROZ-Difference", "background": "", "description": "给定一个由 $n$ 个小写英文字母（'a'-'z'）组成的单词。\n\n我们希望选择该单词的一个非空连续（即一段）片段，以最大化该片段中出现次数最多的字母与出现次数最少的字母之间的差异。\n\n我们假设出现次数最少的字母在结果片段中至少出现一次。\n\n特别地，如果片段中只包含一种字母的出现，那么其中出现次数最多和最少的字母是相同的。", "inputFormat": "标准输入的第一行包含一个整数 $n(1\\le n \\le 1,000,000)$，表示单词的长度。\n\n第二行包含一个由 $n$ 个小写英文字母组成的单词。\n\n在至少占 30% 分数的测试中，额外保证 $n\\le 100$。", "outputFormat": "标准输出的第一行应包含一个整数，表示在输入单词的某个非空连续片段中，出现次数最多和最少的字母的最大差异。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3520", "type": "P", "difficulty": 5, "samples": [["6 8\n1 2 0 1\n2 3 1 0\n1 3 0 1\n2 4 0 0\n3 5 1 1\n4 5 0 1\n5 6 0 1\n4 6 0 1", "2\n3 1 3 2 1\n3 4 6 5 4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["图论", "2011", "POI（波兰）", "Special Judge", "欧拉回路"], "title": "[POI 2011] SMI-Garbage", "background": "", "description": "有一个可以看成无向图的城市，上面有 $n$ 个点和 $m$ 条边。\n\n每一天，有若干辆垃圾车按照**环形**来跑一圈。并且，**对于一辆垃圾车，** 除了起点以外不能跑两次。\n\n一条路有 $2$ 种状态：清洁的（用 `0` 表示）或不清洁的（用 `1` 表示）。每次垃圾车经过，都会改变这条路的状态。\n\n因为有些路上的人不交垃圾清理费，所以市长想要那些路变得不清洁；除此之外的路要清洁。那么，如何安排垃圾车，才能使得市长目的达到呢？\n\nBy @[dengziyue](/user/387840)\n\n感谢 @cn：苏卿念 提供SPJ", "inputFormat": "输入的第一行包含两个空格分隔的正整数 $n$ 和 $m$ $（ 1 \\leqslant n \\leqslant 100000，1 \\leqslant m \\leqslant 1000000）$，表示图的点数和边数。\n\n接下来 $m$ 行，每行包含四个空格分隔的正整数 $a,b,s,t $（ $1 \\leqslant a \\leqslant b \\leqslant n $ , $s，t \\in \\lbrace0,1\\rbrace$  ） ，表示一条联结结点 $a$ 与 $b$ 的边，初始颜色和目标颜色分别为 $s$ 与 $t$ 。\n\n你可以认为若存在合法方案，则存在一个卡车经过总边数不超过 $5m$ 的方案。\n\n对于 $60\\%$ 分数的数据，有 $ m \\leqslant 10000$。", "outputFormat": "如果不存在合法方案，输出一行 `NIE`（波兰语「否」）；\n\n否则按下列格式输出任意一种方案：\n\n- 第一行包含一个整数 $k$，表示卡车行驶环路的总数；\n- 接下来 $k$ 行，每行描述一条环路：\n   - 首先是一个正整数 $k_i$ 表示环路经过的边数，后接一个空格；\n  - 接下来 $ k_i + 1 $ 个空格分隔的整数，依次表示环路上结点的编号。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2011] SMI-Garbage", "background": "# Description\n\nThere is a city that can be regarded as an undirected graph with $n$ vertices and $m$ edges.\n\nEvery day, several garbage trucks each travel one loop along a cycle. Moreover, for any one garbage truck, it cannot visit any vertex twice except returning to its starting vertex at the end.\n\nEach road has 2 states: clean (denoted by `0`) or dirty (denoted by `1`). Every time a garbage truck passes an edge, the state of that edge toggles.\n\nBecause some people on certain roads do not pay the garbage collection fee, the mayor wants those roads to become dirty; all other roads should be clean. How should we schedule the garbage trucks to achieve the mayor’s goal?\n\nBy @[dengziyue](/user/387840)\n\nThanks to @cn: 苏卿念 for providing the SPJ.", "description": "There is a city that can be regarded as an undirected graph with $n$ vertices and $m$ edges.\n\nEvery day, several garbage trucks each travel one loop along a cycle. Moreover, for any one garbage truck, it cannot visit any vertex twice except returning to its starting vertex at the end.\n\nEach road has 2 states: clean (denoted by `0`) or dirty (denoted by `1`). Every time a garbage truck passes an edge, the state of that edge toggles.\n\nBecause some people on certain roads do not pay the garbage collection fee, the mayor wants those roads to become dirty; all other roads should be clean. How should we schedule the garbage trucks to achieve the mayor’s goal?\n\nBy @[dengziyue](/user/387840)\n\nThanks to @cn: 苏卿念 for providing the SPJ.\n\n# Description", "inputFormat": "The first line contains two positive integers $n$ and $m$ $（ 1 \\leqslant n \\leqslant 100000，1 \\leqslant m \\leqslant 1000000）$, the number of vertices and edges of the graph.\n\nThe next $m$ lines each contain four space-separated integers $a, b, s, t$ （ $1 \\leqslant a \\leqslant b \\leqslant n $ , $s，t \\in \\lbrace0,1\\rbrace$ ）, describing an edge connecting vertices $a$ and $b$, whose initial state and target state are $s$ and $t$, respectively.\n\nYou may assume that if a valid plan exists, then there is a plan in which the total number of edges traversed by all trucks does not exceed $5m$.\n\nFor $60\\%$ of the testdata, $ m \\leqslant 10000$.", "outputFormat": "If no valid plan exists, output a single line `NIE` (Polish for \"no\").\n\nOtherwise, output any valid plan in the following format:\n- The first line contains an integer $k$, the total number of cycles (routes) traveled by the trucks.\n- Then output $k$ lines, each describing one cycle:\n  - First, a positive integer $k_i$ indicating the number of edges on the cycle, followed by a space;\n  - Then $ k_i + 1 $ integers separated by spaces, giving the vertex indices along the cycle in order.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2011] SMI-Garbage", "background": "", "description": "有一个可以看成无向图的城市，上面有 $n$ 个点和 $m$ 条边。\n\n每一天，有若干辆垃圾车按照**环形**来跑一圈。并且，**对于一辆垃圾车，** 除了起点以外不能跑两次。\n\n一条路有 $2$ 种状态：清洁的（用 `0` 表示）或不清洁的（用 `1` 表示）。每次垃圾车经过，都会改变这条路的状态。\n\n因为有些路上的人不交垃圾清理费，所以市长想要那些路变得不清洁；除此之外的路要清洁。那么，如何安排垃圾车，才能使得市长目的达到呢？\n\nBy @[dengziyue](/user/387840)\n\n感谢 @cn：苏卿念 提供SPJ", "inputFormat": "输入的第一行包含两个空格分隔的正整数 $n$ 和 $m$ $（ 1 \\leqslant n \\leqslant 100000，1 \\leqslant m \\leqslant 1000000）$，表示图的点数和边数。\n\n接下来 $m$ 行，每行包含四个空格分隔的正整数 $a,b,s,t $（ $1 \\leqslant a \\leqslant b \\leqslant n $ , $s，t \\in \\lbrace0,1\\rbrace$  ） ，表示一条联结结点 $a$ 与 $b$ 的边，初始颜色和目标颜色分别为 $s$ 与 $t$ 。\n\n你可以认为若存在合法方案，则存在一个卡车经过总边数不超过 $5m$ 的方案。\n\n对于 $60\\%$ 分数的数据，有 $ m \\leqslant 10000$。", "outputFormat": "如果不存在合法方案，输出一行 `NIE`（波兰语「否」）；\n\n否则按下列格式输出任意一种方案：\n\n- 第一行包含一个整数 $k$，表示卡车行驶环路的总数；\n- 接下来 $k$ 行，每行描述一条环路：\n   - 首先是一个正整数 $k_i$ 表示环路经过的边数，后接一个空格；\n  - 接下来 $ k_i + 1 $ 个空格分隔的整数，依次表示环路上结点的编号。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3521", "type": "P", "difficulty": 6, "samples": [["3\n0\n0\n3\n1\n2\n", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2011", "线段树", "POI（波兰）", "O2优化", "线段树合并"], "title": "[POI 2011] ROT-Tree Rotations", "background": "", "description": "给定一颗有 $n$ 个**叶节点**的二叉树。每个叶节点都有一个权值 $p_i$（注意，根不是叶节点），所有叶节点的权值构成了一个 $1 \\sim n$ 的排列。  \n对于这棵二叉树的任何一个结点，保证其要么是叶节点，要么左右两个孩子都存在。  \n现在你可以任选一些节点，交换这些节点的左右子树。  \n在最终的树上，按照先序遍历遍历整棵树并依次写下遇到的叶结点的权值构成一个长度为 $n$ 的排列，你需要最小化这个排列的逆序对数。", "inputFormat": "第一行是一个整数 $n$，表示树的叶节点个数。  \n接下来若干行，使用递归的形式来读入这棵树，读入任意一个子树的信息时，初始时读入其根节点。对于一个结点 $u$，首先有一行一个整数 $x$。\n- 若 $x \\neq 0$，则表示 $u$ 是一个叶节点，其权值为 $x$。\n- 若 $x = 0$，则表示 $u$ 不是叶节点，则接下来若干行读入其左子树信息，左子树读入结束后接下来若干行读入其右子树信息。", "outputFormat": "输出一行一个整数表示最小的逆序对数。", "hint": "### 样例 1 解释\n\n下图中，左图是初始读入的树，右图是操作后的树。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r84e2l05.png)\n\n### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 5 \\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $2 \\leq n \\leq 2 \\times 10^5$， $0 \\leq x \\leq n$，所有叶节点的权值是一个 $1 \\sim n$ 的排列。\n\n### 提示\n\n请注意，$n$ **不是**树的结点个数。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2011] ROT-Tree Rotations", "background": "", "description": "You are given a binary tree with $n$ leaves. Each leaf has a weight $p_i$ (note: the root is not a leaf), and the weights of all leaves form a permutation of $1 \\sim n$.  \nFor any node in this binary tree, it is guaranteed that it is either a leaf, or it has both left and right children.  \nYou may choose any set of nodes and swap their left and right subtrees.  \nOn the final tree, perform a preorder traversal of the whole tree and record the weights of the encountered leaves to form a permutation of length $n$. You need to minimize the number of inversions of this permutation.", "inputFormat": "The first line contains an integer $n$, the number of leaves.  \nIn the following lines, the tree is read recursively. When reading any subtree, start with its root. For a node $u$, first read an integer $x$ on a separate line.\n- If $x \\neq 0$, then $u$ is a leaf and its weight is $x$.\n- If $x = 0$, then $u$ is an internal node; next read the information of its left subtree, and then the information of its right subtree.", "outputFormat": "Output a single integer, the minimal number of inversions.", "hint": "Explanation for Sample 1:\n\nIn the figure below, the left is the initial tree, and the right is the tree after the operations.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r84e2l05.png)\n\nConstraints:\n- For $30\\%$ of the testdata, $n \\leq 5 \\times 10^3$.\n- For $100\\%$ of the testdata, $2 \\leq n \\leq 2 \\times 10^5$, $0 \\leq x \\leq n$, and the weights of all leaves form a permutation of $1 \\sim n$.\n\nNote:\nPlease note that $n$ is not the number of nodes in the tree.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2011] ROT-Tree Rotations", "background": "", "description": "给定一颗有 $n$ 个**叶节点**的二叉树。每个叶节点都有一个权值 $p_i$（注意，根不是叶节点），所有叶节点的权值构成了一个 $1 \\sim n$ 的排列。  \n对于这棵二叉树的任何一个结点，保证其要么是叶节点，要么左右两个孩子都存在。  \n现在你可以任选一些节点，交换这些节点的左右子树。  \n在最终的树上，按照先序遍历遍历整棵树并依次写下遇到的叶结点的权值构成一个长度为 $n$ 的排列，你需要最小化这个排列的逆序对数。", "inputFormat": "第一行是一个整数 $n$，表示树的叶节点个数。  \n接下来若干行，使用递归的形式来读入这棵树，读入任意一个子树的信息时，初始时读入其根节点。对于一个结点 $u$，首先有一行一个整数 $x$。\n- 若 $x \\neq 0$，则表示 $u$ 是一个叶节点，其权值为 $x$。\n- 若 $x = 0$，则表示 $u$ 不是叶节点，则接下来若干行读入其左子树信息，左子树读入结束后接下来若干行读入其右子树信息。", "outputFormat": "输出一行一个整数表示最小的逆序对数。", "hint": "### 样例 1 解释\n\n下图中，左图是初始读入的树，右图是操作后的树。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r84e2l05.png)\n\n### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 5 \\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $2 \\leq n \\leq 2 \\times 10^5$， $0 \\leq x \\leq n$，所有叶节点的权值是一个 $1 \\sim n$ 的排列。\n\n### 提示\n\n请注意，$n$ **不是**树的结点个数。", "locale": "zh-CN"}}}
{"pid": "P3522", "type": "P", "difficulty": 5, "samples": [["6\n6 10\n1 5\n4 8\n2 5\n6 8\n3 5", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2011", "单调队列", "POI（波兰）", "队列"], "title": "[POI 2011] TEM-Temperature", "background": null, "description": "Byteotian 气象研究所（BIM）每天测量气温。\n\n测量是自动完成的，其结果会立即打印出来。\n\n不幸的是，打印机里的墨水早就干了...\n\n然而，BIM的员工直到最近才意识到这一事实，当时Byteotian气象组织（BOM）要求访问这些数据。\n\n一位名叫 Byteasar 的实习生挽救了局面，他系统地记录了 BIM 大楼南北外墙上放置的两个家用酒精温度计报告的温度。\n\n几十年前，多位 BIM 员工就已经确立，建筑南墙上的温度计报告的温度永远不会低于实际温度，而建筑北墙上的温度计则永远不会高于实际温度。\n\n因此，尽管每天的确切温度仍然有些神秘，但它们所处的范围至少是已知的。\n\n幸运的是，对于所有参与者（也许除了 Byteasar 和你）来说，BOM 不需要精确的温度。他们只想知道温度没有下降的最长时间（即连续每天的温度都不低于前一天）。\n\n事实上，BIM 的资深负责人非常清楚，BOM希望这段时间尽可能长。\n\n为了粉饰这一疏忽，他坚持要求拜塔萨尔根据他珍贵的笔记，确定气温可能没有下降的最长时间。\n\n现在，这是 Byteasar 在 BIM 实习期间没有预料到的任务，老实说，他不知道如何解决这个问题。\n\n他请求你帮助编写一个程序，以确定最长的此类时间。", "inputFormat": "在标准输入的第一行中，有一个整数 $n(1\\le n\\le 10^6)$，表示 Byteasar 记录温度的天数。\n\n第 $i+1$ 行给出了当天的测量值。每行包含两个整数，$x$ 和 $y(-10^9\\le x\\le y\\le 10^9)$。这些分别表示两个温度计报告的特定日期的最低和最高可能温度。\n\n在某些总计 $50$ 分的测试中，温度从未降至 $-50$（摄氏度，如果你想知道的话！），也从未超过 $50$。", "outputFormat": null, "hint": "对于 $50\\%$ 的数据，保证 $-50 \\le x,y \\le 50$。\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^6$，$-10^9\\le x\\le y\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": null, "background": null, "description": "The Byteotian Institute of Meteorology (BIM) measures the air temperature  daily.\n\nThe measurement is done automatically, and its result immediately printed.\n\nUnfortunately, the ink in the printer has long dried out...\n\nThe employees of BIM however realised the fact only recently, when the    Byteotian Organisation for Meteorology (BOM) requested access to that data.\n\nAn eager intern by the name of Byteasar saved the day, as he systematically    noted down the temperatures reported by two domestic alcohol thermometers    placed on the north and south outside wall of the BIM building.\n\nIt was established decades ago by various BIM employees that the temperature    reported by the thermometer on the south wall of the building is never lower    than the actual temperature, while that reported by the thermometer on the    north wall of the building is never higher than the actual temperature.\n\nThus even though the exact temperatures for each day remain somewhat of    a mystery, the range they were in is known at least.\n\nFortunately for everyone involved (except Byteasar and you, perhaps),    BOM does not require exact temperatures. They only want to know the longest    period in which the temperature was not dropping (i.e. on each successive    day it was no smaller than on the day before).\n\nIn fact, the veteran head of BIM knows very well that BOM would like this    period as long as possible.\n\nTo whitewash the negligence he insists that Byteasar determines, based on    his valuable notes, the longest period in which the temperature    could have been not dropping.\n\nNow this is a task that Byteasar did not quite expect on his BIM internship,    and he honestly has no idea how to tackle it.\n\nHe asks you for help in writing a program that determines the longest such    period.", "inputFormat": "In the first line of the standard input there is one integer  $ n $ ( $ 1 \\le n \\le 1,000,000 $) that denotes the number of days for which Byteasar took notes on the temperature. The measurements from day are given in the  $ {(i + 1)}$-th line . Each of those lines holds two integers,  $ x $ and  $ y $ ( $ -10^9 \\le x \\le y \\le 10^9 $). These denote, respectively, the minimum and maximum possible temperature on that particular day, as reported by the two thermometers.\n\nIn some of the tests, worth 50 points in total, the temperatures never drop below  $ -50 $ degrees (Celsius, in case you wonder!) and never exceeds  $ 50 $ degrees ( $ -50 \\le x \\le y \\le 50 $).", "outputFormat": "In the first and only line of the standard output your program should print a single integer, namely the maximum number of days for which the temperature in Byteotia could have been not dropping.", "hint": null, "locale": "en"}, "zh-CN": {"title": "[POI 2011] TEM-Temperature", "background": null, "description": "Byteotian 气象研究所（BIM）每天测量气温。\n\n测量是自动完成的，其结果会立即打印出来。\n\n不幸的是，打印机里的墨水早就干了...\n\n然而，BIM的员工直到最近才意识到这一事实，当时Byteotian气象组织（BOM）要求访问这些数据。\n\n一位名叫 Byteasar 的实习生挽救了局面，他系统地记录了 BIM 大楼南北外墙上放置的两个家用酒精温度计报告的温度。\n\n几十年前，多位 BIM 员工就已经确立，建筑南墙上的温度计报告的温度永远不会低于实际温度，而建筑北墙上的温度计则永远不会高于实际温度。\n\n因此，尽管每天的确切温度仍然有些神秘，但它们所处的范围至少是已知的。\n\n幸运的是，对于所有参与者（也许除了 Byteasar 和你）来说，BOM 不需要精确的温度。他们只想知道温度没有下降的最长时间（即连续每天的温度都不低于前一天）。\n\n事实上，BIM 的资深负责人非常清楚，BOM希望这段时间尽可能长。\n\n为了粉饰这一疏忽，他坚持要求拜塔萨尔根据他珍贵的笔记，确定气温可能没有下降的最长时间。\n\n现在，这是 Byteasar 在 BIM 实习期间没有预料到的任务，老实说，他不知道如何解决这个问题。\n\n他请求你帮助编写一个程序，以确定最长的此类时间。", "inputFormat": "在标准输入的第一行中，有一个整数 $n(1\\le n\\le 10^6)$，表示 Byteasar 记录温度的天数。\n\n第 $i+1$ 行给出了当天的测量值。每行包含两个整数，$x$ 和 $y(-10^9\\le x\\le y\\le 10^9)$。这些分别表示两个温度计报告的特定日期的最低和最高可能温度。\n\n在某些总计 $50$ 分的测试中，温度从未降至 $-50$（摄氏度，如果你想知道的话！），也从未超过 $50$。", "outputFormat": null, "hint": "对于 $50\\%$ 的数据，保证 $-50 \\le x,y \\le 50$。\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^6$，$-10^9\\le x\\le y\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P3523", "type": "P", "difficulty": 6, "samples": [["7 2\n1 0 1 1 0 1 1\n1 3\n2 3\n3 4\n4 5\n5 6\n5 7", "1\n"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2011", "二分", "POI（波兰）", "树形 DP"], "title": "[POI 2011] DYN-Dynamite", "background": "", "description": "The Byteotian Cave is composed of $n$ chambers and $n-1$ corridors that       connect them.  For every pair of chambers there is unique way to move       from one of them to another without leaving the cave.\n\nDynamite charges are set up in certain chambers.\n\nA fuse is laid along every corridor.\n\nIn every chamber the fuses from the adjacent corridors meet at one point,       and are further connected to the dynamite charge if there is one in the       chamber.  It takes exactly one unit of time for the fuse between two       neighbouring chambers to burn, and the dynamite charge explodes in the       instant that fire reaches the chamber it is inside.\n\nWe would like to light the fuses in some $m$ chambers (at the joints of       fuses) in such a way that all the dynamite charges explode in the shortest       time possible since the fuses are lit.  Write a program that will determine       the minimum such time possible.\n", "inputFormat": "The first line of the standard input holds two integers $n$ and $m$($1\\le m\\le n\\le 300\\ 000$), separated by a single space, that denote, respectively, the number of chambers in the cave and the number of chambers in which fire can be set to the fuses.\n\nThe chambers are numbered from 1 to $n$.\n\nThe next line contains $n$ integers $d_1,d_2,\\cdots,d_n$ ($d_i\\in \\{0,1\\}$), separated by single spaces.\n\nIf $d_i=1$, then there is dynamite in the $i$-th chamber, and if $d_i=0$, there is none.The following $n-1$ lines specify the corridors of the cave. Each of them holds two integers $a,b$($1\\le a<b\\le n$), separated by a single space, denoting that there is a corridor connecting the chambers $a$ and $b$. Every corridor appears exactly once in the description.\n\nYou may assume that in tests worth 10% of the points it holds additionally that $n\\le 10$ , while in tests worth 40% of the points it holds that $n\\le 1\\ 000$\n", "outputFormat": "The first and only line of the standard output should hold a single         integer, equal to the minimum time it takes from lighting the fuses         to the explosion of all the charges.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] DYN-Dynamite", "background": "", "description": "The Byteotian Cave is composed of $n$ chambers and $n-1$ corridors that       connect them.  For every pair of chambers there is unique way to move       from one of them to another without leaving the cave.\n\nDynamite charges are set up in certain chambers.\n\nA fuse is laid along every corridor.\n\nIn every chamber the fuses from the adjacent corridors meet at one point,       and are further connected to the dynamite charge if there is one in the       chamber.  It takes exactly one unit of time for the fuse between two       neighbouring chambers to burn, and the dynamite charge explodes in the       instant that fire reaches the chamber it is inside.\n\nWe would like to light the fuses in some $m$ chambers (at the joints of       fuses) in such a way that all the dynamite charges explode in the shortest       time possible since the fuses are lit.  Write a program that will determine       the minimum such time possible.\n", "inputFormat": "The first line of the standard input holds two integers $n$ and $m$($1\\le m\\le n\\le 300\\ 000$), separated by a single space, that denote, respectively, the number of chambers in the cave and the number of chambers in which fire can be set to the fuses.\n\nThe chambers are numbered from 1 to $n$.\n\nThe next line contains $n$ integers $d_1,d_2,\\cdots,d_n$ ($d_i\\in \\{0,1\\}$), separated by single spaces.\n\nIf $d_i=1$, then there is dynamite in the $i$-th chamber, and if $d_i=0$, there is none.The following $n-1$ lines specify the corridors of the cave. Each of them holds two integers $a,b$($1\\le a<b\\le n$), separated by a single space, denoting that there is a corridor connecting the chambers $a$ and $b$. Every corridor appears exactly once in the description.\n\nYou may assume that in tests worth 10% of the points it holds additionally that $n\\le 10$ , while in tests worth 40% of the points it holds that $n\\le 1\\ 000$\n", "outputFormat": "The first and only line of the standard output should hold a single         integer, equal to the minimum time it takes from lighting the fuses         to the explosion of all the charges.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] DYN-Dynamite", "background": null, "description": "Byteotian 洞穴由 $n$ 个房间和连接它们的 $n-1$ 条走廊组成。对于每一对房间，有一条唯一的路径可以在不离开洞穴的情况下从一个房间移动到另一个房间。\n\n某些房间中设置了炸药。\n\n每条走廊上都铺设了导火索。\n\n在每个房间中，相邻走廊的导火索在一个点相遇，并进一步连接到房间内的炸药（如果房间内有炸药）。导火索在两个相邻房间之间燃烧需要恰好一个时间单位，当火焰到达房间时，房间内的炸药立即爆炸。\n\n我们希望在 $m$ 个房间（导火索的连接点）点燃导火索，使得所有炸药在点燃导火索后以最短的时间爆炸。编写一个程序来确定可能的最短时间。", "inputFormat": "标准输入的第一行包含两个整数 $n$ 和 $m$（$1 \\le m \\le n \\le 300\\ 000$），用一个空格分隔，分别表示洞穴中的房间数量和可以点燃导火索的房间数量。\n\n房间从 $1$ 到 $n$ 编号。\n\n下一行包含 $n$ 个整数 $d_1,d_2,\\cdots,d_n$（$d_i \\in \\{0,1\\}$），用空格分隔。\n\n如果 $d_i=1$，则第 $i$ 个房间中有炸药，如果 $d_i=0$，则没有。接下来的 $n-1$ 行指定了洞穴的走廊。每行包含两个整数 $a,b$（$1 \\le a < b \\le n$），用空格分隔，表示有一条走廊连接房间 $a$ 和 $b$。每条走廊在描述中恰好出现一次。", "outputFormat": "标准输出的第一行应包含一个整数，表示从点燃导火索到所有炸药爆炸所需的最短时间。", "hint": "对于 $10\\%$ 的数据，$1 \\le n \\le 10$。\n\n对于 $40\\%$ 的数据，$1 \\le n \\le 10^3$。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3524", "type": "P", "difficulty": 4, "samples": [["6 10\n2 5\n1 4\n1 5\n2 4\n1 3\n4 5\n4 6\n3 5\n3 4\n3 6", "2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "POI（波兰）", "Special Judge", "构造"], "title": "[POI 2011] IMP-Party", "background": "本题数据极大，评测时可能需要较长时间等待。", "description": "```plain\nByteasar intends to throw up a party.\n```\nNaturally, he would like it to be a success.  Furthermore, Byteasar is quite certain that to make it so it suffices if all invited guests  know each other.  He is currently trying to come up with a list of his friends he would like to invite.\n\nByteasar has $n$ friends, where $n$ is divisible by 3.\n\n```plain\nFortunately, most of Byteasar's friends know one another.\n```\nFurthermore, Byteasar recalls that he once attended a party where there were $\\frac{2}{3}n$ of his friends, and where everyone knew everyone else.\n\nUnfortunately, Byteasar does not quite remember anything else from that    party.\n\n\nIn particular, he has no idea which of his friends attended it.\n\nByteasar does not feel obliged to throw a huge party, but he would like to    invite at least \\frac{n}{3} of his friends.\n\n\n\nHe has no idea how to choose them, so he asks you for help.", "inputFormat": "In the first line of the standard input two integers, $n$ and $m$ ($3\\le n\\le 3\\ 000$, $\\frac{\\frac{2}{3}n(\\frac{2}{3}n-1)}{2}\\leq m\\leq \\frac{n(n-1)}{2}$), are given,separated by a single space.  These denote the number of Byteasar's friends and the number of pairs of his friends who know each other, respectively.\n\nByteasar's friends are numbered from 1 to $n$.\n\nEach of the following $m$ lines holds two integers separated by a single      space.\n\nThe numbers in line no. $i+1$ (for $i=1,2,...,m$) are $a_i$ and $b_i$($1\\le a_i<b_i\\le n$), separated by a single space, which denote that the persons $a_i$ and $b_i$ know each other. Every pair of numbers appears at most once on the input.\n", "outputFormat": "In the first and only line of the standard output your program should      print $\\frac{n}{3}$ numbers, separated by single spaces, in increasing      order.  These number should specify the numbers of Byteasar's friends whom      he should invite to the party.  As there are multiple solutions, pick one      arbitrarily.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] IMP-Party", "background": "本题数据极大，评测时可能需要较长时间等待。", "description": "```plain\nByteasar intends to throw up a party.\n```\nNaturally, he would like it to be a success.  Furthermore, Byteasar is quite certain that to make it so it suffices if all invited guests  know each other.  He is currently trying to come up with a list of his friends he would like to invite.\n\nByteasar has $n$ friends, where $n$ is divisible by 3.\n\n```plain\nFortunately, most of Byteasar's friends know one another.\n```\nFurthermore, Byteasar recalls that he once attended a party where there were $\\frac{2}{3}n$ of his friends, and where everyone knew everyone else.\n\nUnfortunately, Byteasar does not quite remember anything else from that    party.\n\n\nIn particular, he has no idea which of his friends attended it.\n\nByteasar does not feel obliged to throw a huge party, but he would like to    invite at least \\frac{n}{3} of his friends.\n\n\n\nHe has no idea how to choose them, so he asks you for help.", "inputFormat": "In the first line of the standard input two integers, $n$ and $m$ ($3\\le n\\le 3\\ 000$, $\\frac{\\frac{2}{3}n(\\frac{2}{3}n-1)}{2}\\leq m\\leq \\frac{n(n-1)}{2}$), are given,separated by a single space.  These denote the number of Byteasar's friends and the number of pairs of his friends who know each other, respectively.\n\nByteasar's friends are numbered from 1 to $n$.\n\nEach of the following $m$ lines holds two integers separated by a single      space.\n\nThe numbers in line no. $i+1$ (for $i=1,2,...,m$) are $a_i$ and $b_i$($1\\le a_i<b_i\\le n$), separated by a single space, which denote that the persons $a_i$ and $b_i$ know each other. Every pair of numbers appears at most once on the input.\n", "outputFormat": "In the first and only line of the standard output your program should      print $\\frac{n}{3}$ numbers, separated by single spaces, in increasing      order.  These number should specify the numbers of Byteasar's friends whom      he should invite to the party.  As there are multiple solutions, pick one      arbitrarily.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] IMP-Party", "background": null, "description": "**译自 POI 2011 Round 3. Day 1. A「[Party](https://szkopul.edu.pl/problemset/problem/PCtteC6gKwc2ZikW8nUZzfyh/site/?key=statement)」**\n\nByteasar 打算举行一次聚会。他自然想要这次聚会成功进行。此外，Byteasar 确信只要邀请的嘉宾都互相认识就可以了。他目前在试着写一份邀请名单。\n\nByteasar 有 $n$ 个朋友，这里 $n$ 可以被 $3$ 整除。幸运的是，Byteasar 的朋友大部分都互相认识。并且 Byteasar 想起了一次他参加的聚会，那次聚会有 $ \\frac{2}{3}n $ 个他的朋友参加，并且他们都互相认识。不幸的是，关于那次聚会的具体细节他不记得了……总的来说，他忘了是他的哪些朋友参加了。\n\nByteasar 认为他没有义务举办一个大型聚会，但他想邀请 $ \\frac{n}{3} $ 个他的朋友。他不知道邀请谁，所以请你帮他。", "inputFormat": "输入的第一行包含两个整数 $n,m$，表示 Byteasar 的朋友数和互相认识的朋友对数；\n\n接下来 $m$ 行，每行两个整数 $a_i,b_i$， 表示朋友 $a_i,b_i$ 互相认识。每一对数最多在输入中出现一次。", "outputFormat": "按编号升序，输出一行 $ \\frac{n}{3} $ 个数，表示 Byteasar 要邀请的朋友编号。如果有多组解，输出任意一组均可。\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yjpf686v.png)\n\n编号为 $1,3,4,5$ 的朋友互相认识。然而对于任意一对互相认识的朋友，如 $2,4$，都可以作为正确答案。即，这一对朋友并不一定来自于之前提到的那个四元组。", "hint": "对于全部数据，$ 3 \\le n \\le 3000 , \\frac{\\frac{2}{3}n(\\frac{2}{3}n-1)}{2} \\le m \\le \\frac{n(n-1)}{2}, 1 \\le a_i \\lt b_i \\le n $。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2166)。", "locale": "zh-CN"}}}
{"pid": "P3525", "type": "P", "difficulty": 5, "samples": [["9\n3 6\n2 4\n2 6\n2 5\n1 7\n2 7\n8 9\n7 8", "-1\n23\n-1\n-1\n-1\n-1\n-1\n-1\n-1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "树形数据结构", "2011", "POI（波兰）"], "title": "[POI 2011] INS-Inspection", "background": "", "description": "The railway network of the Byteotian Railways (BR) consists of bidirectional    tracks connecting certain pairs of stations.\n\nEach pair of stations is connected by at most one segment of tracks.\n\nFurthermore, there is a unique route from every station to every other station.\n\n(The route may consist of several segments of tracks, but it may not pass through any station more than once.) Byteasar is an undercover inspector of the BR.\n\nHis job is to pick one of the stations (denote it by $S$) for centre of his operations and to travel to all other stations.\n\nHis journey should be as follows:\n\nByteasar starts in station $S$.\n\nNext, he picks one of the stations he did not yet control and goes to it along the shortest path (by train, of course), inspects the station, and        then goes back to $S$.\n\nThe crooked employees of BR warn one another of Byteasar's comings.\n\nTo deceive them, Byteasar picks the next station for control in such a way that he sets off from the station $S$ in different direction than the last time, i.e., along a different segment of tracks leaving from $S$.\n\nEach station (except $S$) is inspected exactly once.\n\nAfter inspecting the last station Byteasar does not come back        to $S$.\n\nThe travel time along every segment of tracks takes the same amount of time:\n\none hour.\n\nByteasar intends to consider all the stations as the initial station $S$.\n\nFor each of them he wants to know the order of inspecting the remaining stations that minimises the total travel time, provided that it is possible at all for that particular $S$.\n\n", "inputFormat": "The first line of the standard input contains a single integer $n$($1\\le n\\le 1\\ 000\\ 000$) that denotes the number of stations.\n\nThese are numbered from 1 to $n$.\n\nThe following $n-1$ lines specify the track segments, one per line.\n\nEach of them holds two integers $a,b$ ($1\\le a,b\\le n$, $a\\ne b$),      separated by a single space, indicating that there is a track segment      connecting the stations $a$ and $b$.\n\nEach track segments appears exactly once in the description.\n\nIn tests worth at least 30% of the points it holds additionally that $n\\le 2\\ 000$.\n", "outputFormat": "Your program should print $n$ lines on the standard output,each holding a single integer.\n\nThe one in the $i$-th line should be the minimum number of hours Byteasar has to spend travelling to inspect the stations when $S=i$ - if inspecting them all is possible for $S=i$;if it is not, the $i$-th line should hold the number $-1$.\n", "hint": "\n", "locale": "en", "translations": {"en": {"title": "[POI 2011] INS-Inspection", "background": "", "description": "The railway network of the Byteotian Railways (BR) consists of bidirectional    tracks connecting certain pairs of stations.\n\nEach pair of stations is connected by at most one segment of tracks.\n\nFurthermore, there is a unique route from every station to every other station.\n\n(The route may consist of several segments of tracks, but it may not pass through any station more than once.) Byteasar is an undercover inspector of the BR.\n\nHis job is to pick one of the stations (denote it by $S$) for centre of his operations and to travel to all other stations.\n\nHis journey should be as follows:\n\nByteasar starts in station $S$.\n\nNext, he picks one of the stations he did not yet control and goes to it along the shortest path (by train, of course), inspects the station, and        then goes back to $S$.\n\nThe crooked employees of BR warn one another of Byteasar's comings.\n\nTo deceive them, Byteasar picks the next station for control in such a way that he sets off from the station $S$ in different direction than the last time, i.e., along a different segment of tracks leaving from $S$.\n\nEach station (except $S$) is inspected exactly once.\n\nAfter inspecting the last station Byteasar does not come back        to $S$.\n\nThe travel time along every segment of tracks takes the same amount of time:\n\none hour.\n\nByteasar intends to consider all the stations as the initial station $S$.\n\nFor each of them he wants to know the order of inspecting the remaining stations that minimises the total travel time, provided that it is possible at all for that particular $S$.\n\n", "inputFormat": "The first line of the standard input contains a single integer $n$($1\\le n\\le 1\\ 000\\ 000$) that denotes the number of stations.\n\nThese are numbered from 1 to $n$.\n\nThe following $n-1$ lines specify the track segments, one per line.\n\nEach of them holds two integers $a,b$ ($1\\le a,b\\le n$, $a\\ne b$),      separated by a single space, indicating that there is a track segment      connecting the stations $a$ and $b$.\n\nEach track segments appears exactly once in the description.\n\nIn tests worth at least 30% of the points it holds additionally that $n\\le 2\\ 000$.\n", "outputFormat": "Your program should print $n$ lines on the standard output,each holding a single integer.\n\nThe one in the $i$-th line should be the minimum number of hours Byteasar has to spend travelling to inspect the stations when $S=i$ - if inspecting them all is possible for $S=i$;if it is not, the $i$-th line should hold the number $-1$.\n", "hint": "\n", "locale": "en"}, "zh-CN": {"title": "[POI 2011] INS-Inspection", "background": "", "description": "Byteotian Railways（BR）的铁路网络由双向轨道组成，这些轨道连接某些车站对。每对车站最多由一段轨道连接。此外，从每个车站到每个其他车站都有唯一的路线。（该路线可能由几段轨道组成，但不能经过任何车站多于一次。）Byteasar 是 BR 的一名卧底检查员。他的任务是选择一个车站（记为 $S$）作为他的行动中心，并前往所有其他车站。他的旅程应如下进行：Byteasar 从车站 $S$ 出发。接下来，他选择一个尚未检查的车站，沿最短路径（当然是乘火车）前往该车站，检查车站，然后返回 $S$。BR 的腐败员工互相警告 Byteasar 的到来。为了欺骗他们，Byteasar 选择下一个要检查的车站，使得他从车站 $S$ 出发的方向与上次不同，即沿着从 $S$ 出发的不同轨道段。每个车站（除了 $S$）恰好被检查一次。在检查完最后一个车站后，Byteasar 不返回 $S$。沿每段轨道的旅行时间相同：一小时。Byteasar 打算将所有车站都考虑为初始车站 $S$。对于每个车站，他想知道检查剩余车站的顺序，以最小化总旅行时间，前提是对于该特定 $S$ 这是可能的。", "inputFormat": "标准输入的第一行包含一个整数 $n$（$1 \\le n \\le 1\\ 000\\ 000$），表示车站的数量。这些车站从 1 到 $n$ 编号。接下来的 $n-1$ 行指定轨道段，每行一个。每行包含两个整数 $a,b$（$1 \\le a,b \\le n$, $a \ne b$），用一个空格分隔，表示有一段轨道连接车站 $a$ 和 $b$。每段轨道在描述中恰好出现一次。在至少价值 30% 的测试中，额外条件是 $n \\le 2\\ 000$。", "outputFormat": "你的程序应在标准输出上打印 $n$ 行，每行包含一个整数。第 $i$ 行的整数应为 Byteasar 在 $S=i$ 时检查车站所需的最少小时数——如果对于 $S=i$ 检查所有车站是可能的；如果不可能，第 $i$ 行应为数字 $-1$。", "hint": "题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P3526", "type": "P", "difficulty": 7, "samples": [["3\nABIABUABIAB\nBABBAB\nBABURBAB", "01001101001\n010010\n01000010"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2011", "POI（波兰）", "构造"], "title": "[POI 2011] OKR-Periodicity", "background": "", "description": "Byteasar, the king of Bitotia, has ordained a reform of his subjects' names. The names of Bitotians often contain repeating phrases, e.g., the name Abiabuab has two occurrences of the phrase abia. Byteasar intends to change the names of his subjects to sequences of bits matching the lengths of their original names. Also, he would very much like to reflect the original repetitions in the new names.\n\nIn the following, for simplicity, we will identify the upper- and lower-case letters in the names. For any sequence of characters (letters or bits) $w = w_1w_2\\cdots w_k$ we say that the integer $p$ ($1\\leq p < k$) is a period of $w$ if $w_i = w_{i + p}$ for all $i = 1,\\cdots,k - p$. We denote the set of all periods of $w$ by $Per(w)$. For example, $Per(\\texttt{ABIABUABIAB})=\\{6,9\\}$, $Per(\\texttt{01001010010})=\\{5,8,10\\}$, and $Per(\\texttt{0000})=\\{1,2,3\\}$.\n\nByteasar has decided that every name is to be changed to a sequence of bits that:\n- has length matching that of the original name,\n- has the same set of periods as the original name,\n- is the smallest (lexicographically. The sequence of bits $x_1x_2\\cdots x_k$ is lexicographically smaller than the sequence of bits $y_1y_2\\cdots y_k$ if for some $i$, $1\\leq i\\leq k$, we have $x_i < y_i$ and for all $j = 1,\\cdots,i - 1$ we have $x_j = y_j$.  ) sequence of bits satisfying the previous conditions.\n\nFor example, the name ABIABUABIAB should be changed to 01001101001, BABBAB to 010010, and BABURBAB to 01000010.\nByteasar has asked you to write a program that would facilitate the translation of his subjects' current names into new ones. If you succeed, you may keep your current name as a reward!", "inputFormat": "In the first line of the standard input there is a single integer $k$ - the number of names to be translated ($1\\leq k\\leq20$). The names are given in the following lines, one in each line. Each name consists of no less than and no more than 200,000 upper-case (capital) letters (of the English alphabet).\n\nIn the test worth 30% of the points each name consists of at most 20 letters.", "outputFormat": "Your program should print $k$ lines to the standard output. Each successive line should hold a sequence of zeroes and ones (without spaces in between) corresponding to the names given on the input. If an appropriate sequence of bits does not exists for some names, then \"XXX\" (without quotation marks) should be printed for that name. ", "hint": "\n", "locale": "en", "translations": {"en": {"title": "[POI 2011] OKR-Periodicity", "background": "", "description": "Byteasar, the king of Bitotia, has ordained a reform of his subjects' names. The names of Bitotians often contain repeating phrases, e.g., the name Abiabuab has two occurrences of the phrase abia. Byteasar intends to change the names of his subjects to sequences of bits matching the lengths of their original names. Also, he would very much like to reflect the original repetitions in the new names.\n\nIn the following, for simplicity, we will identify the upper- and lower-case letters in the names. For any sequence of characters (letters or bits) $w = w_1w_2\\cdots w_k$ we say that the integer $p$ ($1\\leq p < k$) is a period of $w$ if $w_i = w_{i + p}$ for all $i = 1,\\cdots,k - p$. We denote the set of all periods of $w$ by $Per(w)$. For example, $Per(\\texttt{ABIABUABIAB})=\\{6,9\\}$, $Per(\\texttt{01001010010})=\\{5,8,10\\}$, and $Per(\\texttt{0000})=\\{1,2,3\\}$.\n\nByteasar has decided that every name is to be changed to a sequence of bits that:\n- has length matching that of the original name,\n- has the same set of periods as the original name,\n- is the smallest (lexicographically. The sequence of bits $x_1x_2\\cdots x_k$ is lexicographically smaller than the sequence of bits $y_1y_2\\cdots y_k$ if for some $i$, $1\\leq i\\leq k$, we have $x_i < y_i$ and for all $j = 1,\\cdots,i - 1$ we have $x_j = y_j$.  ) sequence of bits satisfying the previous conditions.\n\nFor example, the name ABIABUABIAB should be changed to 01001101001, BABBAB to 010010, and BABURBAB to 01000010.\nByteasar has asked you to write a program that would facilitate the translation of his subjects' current names into new ones. If you succeed, you may keep your current name as a reward!", "inputFormat": "In the first line of the standard input there is a single integer $k$ - the number of names to be translated ($1\\leq k\\leq20$). The names are given in the following lines, one in each line. Each name consists of no less than and no more than 200,000 upper-case (capital) letters (of the English alphabet).\n\nIn the test worth 30% of the points each name consists of at most 20 letters.", "outputFormat": "Your program should print $k$ lines to the standard output. Each successive line should hold a sequence of zeroes and ones (without spaces in between) corresponding to the names given on the input. If an appropriate sequence of bits does not exists for some names, then \"XXX\" (without quotation marks) should be printed for that name. ", "hint": "\n", "locale": "en"}, "zh-CN": {"title": "[POI 2011] OKR-Periodicity", "background": null, "description": "比托蒂亚的国王 Byteasar 下令对他的臣民的名字进行改革。\n\n比托蒂亚人的名字通常包含重复的短语，例如，名字 Abiabuabiab 包含两次出现的短语 abiab。Byteasar 打算将他的臣民的名字改为与原名长度相匹配的 01 串。\n\n此外，他非常希望在新名字中反映原始的周期。\n\n对于任何字符序列（字母或 01 串）$w = w_1w_2\\cdots w_k$，我们说整数 $p\\ (1\\leq p < k)$ 是 $w$ 的周期，如果 $w_i = w_{i + p}$ 对于所有 $i = 1,\\cdots,k - p$ 都成立。\n\n我们用 $Per(w)$ 表示 $w$ 的所有周期的集合。\n\n例如，$Per(\\texttt{ABIABUABIAB})=\\{6,9\\},Per(\\texttt{01001010010})=\\{5,8,10\\},Per(\\texttt{0000})=\\{1,2,3\\}$。\n\nByteasar 决定将每个名字串 $S$ 改为一个 01 串 $T$，该串是满足 $|S|=|T|$ 且 $Per(S)=Per(T)$ 条件的字典序最小的 01 串。\n\n例如，名字 `ABIABUABIAB` 应该改为 `01001101001`，`BABBAB` 改为 `010010`，`BABURBAB` 改为 `01000010`。\n\nByteasar 要求你编写一个程序，帮助将他的臣民的当前名字翻译成新名字。\n\n如果你成功了，你可以作为奖励保留你现在的名字！", "inputFormat": "第一行一个整数 $k$ 表示需要翻译的名字数量 ($1\\leq k\\leq20$)。\n\n名字在接下来的行中给出，每行一个。\n\n每个名字由不多于 $200000$ 个英文大写字母组成。\n\n在 $30\\%$ 的数据中，每个名字最多由 $20$ 个字母组成。", "outputFormat": "你的程序应该向标准输出打印 $k$ 行。\n\n每个连续的行应包含与输入中给出的名字对应的零和一的序列（中间没有空格）。\n\n如果某些名字不存在合适的比特序列，则应为该名字打印 \"XXX\"（不带引号）。", "hint": "对于 $100\\%$ 的数据，$1\\leq k\\leq20$，单个名字长度不超过 $200000$。", "locale": "zh-CN"}}}
{"pid": "P3527", "type": "P", "difficulty": 6, "samples": [["3 5\n1 3 2 1 3\n10 5 7\n3\n4 2 4\n1 3 1\n3 5 2", "3\nNIE\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["2011", "二分", "树状数组", "POI（波兰）", "O2优化", "整体二分", "离线处理"], "title": "[POI 2011] MET-Meteors", "background": "", "description": "Byteotian Interstellar Union (BIU) has recently discovered a new planet in a nearby galaxy.  The planet is unsuitable for colonisation due to strange  meteor showers, which on the other hand make it an exceptionally interesting  object of study.\n\nThe member states of BIU have already placed space stations close to the  planet's orbit.  The stations' goal is to take samples of the rocks flying by.\n\nThe BIU Commission has partitioned the orbit into $m$ sectors, numbered  from $1$ to $m$, where the sectors $1$ and $m$ are adjacent.  In each sector  there is a single space station, belonging to one of the $n$ member states.\n\nEach state has declared a number of meteor samples it intends to gather before  the mission ends.  Your task is to determine, for each state, when it can  stop taking samples, based on the meter shower predictions for the years to  come.\n\n\n", "inputFormat": "The first line of the standard input gives two integers, $n$ and $m$ ($1\\le n,m\\le 300\\ 000$), separated by a single space, that denote,respectively, the number of BIU member states and the number of sectors    the orbit has been partitioned into.\n\nIn the second line there are $m$ integers $o_i$ ($1\\le o_i\\le n$),separated by single spaces, that denote the states owning stations in    successive sectors.\n\nIn the third line there are $n$ integers $p_i$ ($1\\le p_i\\le 10^9$),separated by single spaces, that denote the numbers of meteor samples that the successive states intend to gather.\n\nIn the fourth line there is a single integer $k$ ($1\\le k\\le 300\\ 000$) that denotes the number of meteor showers predictions. The following $k$ lines specify the (predicted) meteor showers chronologically. The $i$-th of these lines holds three integers $l_i,r_i,a_i$ (separated by single spaces), which denote that a meteor shower is expected in sectors $l_i,l_{i+1},...,r_i$(if $l_i\\le r_i$) or sectors $l_i,l_{i+1},...,m,1,...,r_i$ (if $l_i>r_i$) , which should provide each station in those sectors with $a_i$ meteor samples ($1\\le a_i\\le 10^9$).\n", "outputFormat": "Your program should print $n$ lines on the standard output.\n\nThe $i$-th of them should contain a single integer $w_i$, denoting the number of shower after which the stations belonging to the $i$-th state are    expected to gather at least $p_i$ samples, or the word NIE (Polish for no) if that state is not expected to gather enough samples in the foreseeable future.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] MET-Meteors", "background": "", "description": "Byteotian Interstellar Union (BIU) has recently discovered a new planet in a nearby galaxy.  The planet is unsuitable for colonisation due to strange  meteor showers, which on the other hand make it an exceptionally interesting  object of study.\n\nThe member states of BIU have already placed space stations close to the  planet's orbit.  The stations' goal is to take samples of the rocks flying by.\n\nThe BIU Commission has partitioned the orbit into $m$ sectors, numbered  from $1$ to $m$, where the sectors $1$ and $m$ are adjacent.  In each sector  there is a single space station, belonging to one of the $n$ member states.\n\nEach state has declared a number of meteor samples it intends to gather before  the mission ends.  Your task is to determine, for each state, when it can  stop taking samples, based on the meter shower predictions for the years to  come.\n\n\n", "inputFormat": "The first line of the standard input gives two integers, $n$ and $m$ ($1\\le n,m\\le 300\\ 000$), separated by a single space, that denote,respectively, the number of BIU member states and the number of sectors    the orbit has been partitioned into.\n\nIn the second line there are $m$ integers $o_i$ ($1\\le o_i\\le n$),separated by single spaces, that denote the states owning stations in    successive sectors.\n\nIn the third line there are $n$ integers $p_i$ ($1\\le p_i\\le 10^9$),separated by single spaces, that denote the numbers of meteor samples that the successive states intend to gather.\n\nIn the fourth line there is a single integer $k$ ($1\\le k\\le 300\\ 000$) that denotes the number of meteor showers predictions. The following $k$ lines specify the (predicted) meteor showers chronologically. The $i$-th of these lines holds three integers $l_i,r_i,a_i$ (separated by single spaces), which denote that a meteor shower is expected in sectors $l_i,l_{i+1},...,r_i$(if $l_i\\le r_i$) or sectors $l_i,l_{i+1},...,m,1,...,r_i$ (if $l_i>r_i$) , which should provide each station in those sectors with $a_i$ meteor samples ($1\\le a_i\\le 10^9$).\n", "outputFormat": "Your program should print $n$ lines on the standard output.\n\nThe $i$-th of them should contain a single integer $w_i$, denoting the number of shower after which the stations belonging to the $i$-th state are    expected to gather at least $p_i$ samples, or the word NIE (Polish for no) if that state is not expected to gather enough samples in the foreseeable future.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] MET-Meteors", "background": null, "description": "Byteotian Interstellar Union \n\n有 $n$ 个成员国。现在它发现了一颗新的星球，这颗星球的轨道被分为 $m$ 份（第 $m$ 份和第 $1$ 份相邻），第 $i$ 份上有第 $o_i$ 个国家的太空站。\n\n这个星球经常会下陨石雨。BIU 已经预测了接下来 $k$ 场陨石雨的情况。\n\nBIU 的第 $i$ 个成员国希望能够收集 $p_i$ 单位的陨石样本。你的任务是判断对于每个国家，它需要在第几次陨石雨之后，才能收集足够的陨石。", "inputFormat": "第一行是两个数 $n,m$。\n\n第二行有 $m$ 个数，第 $i$ 个数 $o_i$ 表示第 $i$ 段轨道上有第 $o_i$ 个国家的太空站。\n\n第三行有 $n$ 个数，第 $i$ 个数 $p_i$ 表示第 $i$ 个国家希望收集的陨石数量。\n\n第四行有一个数 $k$，表示 BIU 预测了接下来的 $k$ 场陨石雨。 接下来 $k$ 行，每行有三个数 $l_i,r_i,a_i$ ，表示第 $k$ 场陨石雨的发生地点在从 $l_i$ 顺时针到 $r_i$ 的区间中（如果 $l_i \\leq r_i$，则是 $l_i, l_i + 1 \n\\cdots, r_i$，否则就是 $l_i, l_i + 1, \n\\cdots m - 1, m, 1, 2, \\cdots r_i$），向区间中的每个太空站提供 $a_i$ 单位的陨石样本。", "outputFormat": "输出 $n$ 行。第 $i$ 行的数 $w_i$ 表示第 $i$ 个国家在第 $w_i$ 波陨石雨之后能够收集到足够的陨石样本。如果到第 $k$ 波结束后仍然收集不到，输出 `NIE`。", "hint": "$1\\le n,m,k\\le 3\\cdot10^5$；\n\n$1\\le p_i,a_i\\le 10^9$；", "locale": "zh-CN"}}}
{"pid": "P3528", "type": "P", "difficulty": 5, "samples": [["4\n1 42\n2 6 9\n3 8 4 8\n1 12", "3 8 4 12 2 9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2011", "POI（波兰）", "Special Judge", "枚举"], "title": "[POI 2011] PAT-Sticks", "background": "", "description": "Little Johnny was given a birthday present by his grandparents.\n\nThis present is a box of sticks of various lengths and colours.\n\nJohnny wonders if there are three sticks in the set he has been given    that would form a triangle with different-coloured sides.\n\nLet us note that Johnny is interested in non-degenerate triangles only, i.e.,    those with positive area.\n", "inputFormat": "In the first line of the standard input an integer $k$ ($3\\le k\\le 50$) is given, which is the number of different colours of sticks.\n\nThe colours themselves are numbered from $1$ to $k$.\n\nThe following $k$ lines contain descriptions of the sticks of particular      colours.\n\nThe line no. $i+1$ holds integers that describe the sticks of colour $i$,separated by single spaces.\n\nThe first of these numbers, $n_i$ ($1\\le n_i\\le 1\\ 000\\ 000$), denotes the number of sticks of colour $i$.\n\nIt is followed, in the same line, by $n_i$ integers denoting the lengths of the sticks of colour $i$.All lengths are positive and do not exceed $1\\ 000\\ 000\\ 000$.Furthermore, the total number of all sticks does not exceed $1\\ 000\\ 000$.\n", "outputFormat": "Your program should print (on the first and only line of the standard output) either:\n\nsix integers, separated by single spaces, that describe the construction          of a triangle with different-coloured sides as follows:\n\nthe colour and the length of the first stick, the colour and the length          of the second stick, and the colour and the length of the third stick,                      or the word NIE (Polish for no) if no such triple of          sticks exists.\n\nIf there are multiple triples of different-coloured sticks that give rise      to a triangle, your program may pick one such triple arbitrarily.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] PAT-Sticks", "background": "", "description": "Little Johnny was given a birthday present by his grandparents.\n\nThis present is a box of sticks of various lengths and colours.\n\nJohnny wonders if there are three sticks in the set he has been given    that would form a triangle with different-coloured sides.\n\nLet us note that Johnny is interested in non-degenerate triangles only, i.e.,    those with positive area.\n", "inputFormat": "In the first line of the standard input an integer $k$ ($3\\le k\\le 50$) is given, which is the number of different colours of sticks.\n\nThe colours themselves are numbered from $1$ to $k$.\n\nThe following $k$ lines contain descriptions of the sticks of particular      colours.\n\nThe line no. $i+1$ holds integers that describe the sticks of colour $i$,separated by single spaces.\n\nThe first of these numbers, $n_i$ ($1\\le n_i\\le 1\\ 000\\ 000$), denotes the number of sticks of colour $i$.\n\nIt is followed, in the same line, by $n_i$ integers denoting the lengths of the sticks of colour $i$.All lengths are positive and do not exceed $1\\ 000\\ 000\\ 000$.Furthermore, the total number of all sticks does not exceed $1\\ 000\\ 000$.\n", "outputFormat": "Your program should print (on the first and only line of the standard output) either:\n\nsix integers, separated by single spaces, that describe the construction          of a triangle with different-coloured sides as follows:\n\nthe colour and the length of the first stick, the colour and the length          of the second stick, and the colour and the length of the third stick,                      or the word NIE (Polish for no) if no such triple of          sticks exists.\n\nIf there are multiple triples of different-coloured sticks that give rise      to a triangle, your program may pick one such triple arbitrarily.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] PAT-Sticks", "background": "", "description": "小 Johnny 收到了祖父母送的生日礼物。\n\n这个礼物是一盒各种长度和颜色的木棍。\n\nJohnny 想知道，他收到的这些木棍中是否存在三根木棍，能够组成一个边长颜色各不相同的三角形。\n\n需要注意的是，Johnny 只对非退化三角形感兴趣，即面积为正的三角形。", "inputFormat": "输入的第一行包含一个整数 $k$（$3 \\leq k \\leq 50$），表示木棍的不同颜色数量。颜色本身编号为 $1$ 到 $k$。\n\n接下来的 $k$ 行描述了每种颜色的木棍。第 $i+1$ 行描述了颜色为 $i$ 的木棍，包含若干个用空格分隔的整数。第一个整数 $n_i$（$1 \\leq n_i \\leq 1\\,000\\,000$）表示颜色为 $i$ 的木棍数量。随后是 $n_i$ 个整数，表示这些木棍的长度。所有长度均为正整数且不超过 $1\\,000\\,000\\,000$。此外，所有木棍的总数不超过 $1\\,000\\,000$。", "outputFormat": "你的程序应在标准输出的第一行（也是唯一一行）输出以下内容之一：\n\n- 六个整数，用空格分隔，描述一个边长颜色各不相同的三角形的构造方式，依次为：第一根木棍的颜色和长度，第二根木棍的颜色和长度，以及第三根木棍的颜色和长度；  \n- 或者输出单词 `NIE`（波兰语中的“无”），表示不存在这样的三根木棍。\n\n如果存在多个满足条件的三根木棍，你的程序可以任意选择其中一个输出。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3529", "type": "P", "difficulty": 6, "samples": [["2 4 3 15 4\n1 1\n2 3\n1 4\n1 3", "3 12\n1 4 0\n2 3 0\n1 1 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "POI（波兰）", "Special Judge", "费用流"], "title": "[POI 2011] PRO-Programming Contest", "background": "", "description": "Bartie and his friends compete in the Team Programming Contest.\n\nThere are $n$ contestants on each team, and each team has access to $n$ computers.\n\nThe contest lasts $t$ minutes, during which the contestants are to solve $m$ programming problems.\n\nFurthermore, penalties are imposed on the teams: solving a problem $s$ minutes since the beginning of the contest amounts to $s$ penal points.\n\nThe team that solved the most problems wins the contest, with ties broken in    favour of the team with smaller penalty.\n\nOn the contest day Bartie quickly glances over the problem statements and    distributes them among his teammates.\n\nHe knows his team so well that he can exactly assess who is able to solve    which problem.\n\nSolving any problem takes any contestant that is able to solve it exactly $r$ minutes of using the computer.\n\nBartie's team did not fare well in this year's contest.\n\nBartie is obsessed with the thought that it might be his fault, due to wrong    decisions regarding the distribution of problems.\n\nHe asks you to write a program that, given what Bartie knew at the beginning    of the contest, determines the best possible result of Bytie's team, together    with the assignment of problems to team members that attains the result.\n", "inputFormat": "Five integers $n$, $m$, $r$, $t$, and $k$ ($1\\le n,m\\le 500$, $1\\le r,t\\le 1\\ 000\\ 000$) are given in the first line of the standard input, separated by single spaces.\n\nThese denote, respectively:\n\nthe number of contestants on a team, the number of problems, the time it      takes a contestant to solve a problem, the duration of the contest,and the number of contestant-problem pairs given on the input.\n\nEach of the following $k$ lines holds two integers $a$ and $b$($1\\le a\\le n$,$1\\le b\\le m$), separated by a single space, denoting that the contestant $a$ is able to solve the problem $b$.Each such pair appears at most once in the input.\n\nIn tests worth at least 30% of the points it additionally holds that $n,m\\le 100$.\n", "outputFormat": "In the first line of the standard output the best possible result of Bytie's      team should be printed as two numbers separated by a single space:\n\nthe number of solved problems $z$ and the total penal points.\n\nAn exemplary assignment of problems that attains this result should be given in the following $z$ lines.\n\nEach of those should hold three integers $a$, $b$ and $c$ ($1\\le a\\le n$,$1\\le b\\le m$, $0\\le c\\le t-r$),separated by single spaces, signifying that the contestant $a$ should start solving the problem $b$ at time $c$(the contest starts at time $0$).No contestant should be assigned a problem that they cannot solve. If more that one optimal assignment exists, your program can output any of them.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2011] PRO-Programming Contest", "background": "", "description": "Bartie and his friends compete in the Team Programming Contest.\n\nThere are $n$ contestants on each team, and each team has access to $n$ computers.\n\nThe contest lasts $t$ minutes, during which the contestants are to solve $m$ programming problems.\n\nFurthermore, penalties are imposed on the teams: solving a problem $s$ minutes since the beginning of the contest amounts to $s$ penal points.\n\nThe team that solved the most problems wins the contest, with ties broken in    favour of the team with smaller penalty.\n\nOn the contest day Bartie quickly glances over the problem statements and    distributes them among his teammates.\n\nHe knows his team so well that he can exactly assess who is able to solve    which problem.\n\nSolving any problem takes any contestant that is able to solve it exactly $r$ minutes of using the computer.\n\nBartie's team did not fare well in this year's contest.\n\nBartie is obsessed with the thought that it might be his fault, due to wrong    decisions regarding the distribution of problems.\n\nHe asks you to write a program that, given what Bartie knew at the beginning    of the contest, determines the best possible result of Bytie's team, together    with the assignment of problems to team members that attains the result.\n", "inputFormat": "Five integers $n$, $m$, $r$, $t$, and $k$ ($1\\le n,m\\le 500$, $1\\le r,t\\le 1\\ 000\\ 000$) are given in the first line of the standard input, separated by single spaces.\n\nThese denote, respectively:\n\nthe number of contestants on a team, the number of problems, the time it      takes a contestant to solve a problem, the duration of the contest,and the number of contestant-problem pairs given on the input.\n\nEach of the following $k$ lines holds two integers $a$ and $b$($1\\le a\\le n$,$1\\le b\\le m$), separated by a single space, denoting that the contestant $a$ is able to solve the problem $b$.Each such pair appears at most once in the input.\n\nIn tests worth at least 30% of the points it additionally holds that $n,m\\le 100$.\n", "outputFormat": "In the first line of the standard output the best possible result of Bytie's      team should be printed as two numbers separated by a single space:\n\nthe number of solved problems $z$ and the total penal points.\n\nAn exemplary assignment of problems that attains this result should be given in the following $z$ lines.\n\nEach of those should hold three integers $a$, $b$ and $c$ ($1\\le a\\le n$,$1\\le b\\le m$, $0\\le c\\le t-r$),separated by single spaces, signifying that the contestant $a$ should start solving the problem $b$ at time $c$(the contest starts at time $0$).No contestant should be assigned a problem that they cannot solve. If more that one optimal assignment exists, your program can output any of them.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2011] PRO-Programming Contest", "background": "", "description": "**译自 POI 2011 Round 3. Day 2. C「[Programming Contest](https://szkopul.edu.pl/problemset/problem/VwDLJhYqi1z_sZrb2NyfvQ5e/site/?key=statement)」**\n\nBartie 和他的朋友们都在打团体程序设计竞赛。每个队有 $n$ 名队员，每个队可以用 $n$ 台电脑。比赛持续 $t$ 分钟，比赛中选手们要解决 $m$ 道程序设计题目。此外，比赛会按如下规则记罚时：比赛开始 $s$ 分钟通过了一道题，则罚时加 $s$ 分。解题数目最多的队伍获胜，如果解题数目相同，罚时最少的队伍获胜。\n\n在一次比赛中，Bartie 迅速浏览了全部题目并且把题目分配给了队友。他十分了解队友，并可以把题目分配给能解决这道题的人。对于每个选手，解决一道题的时间都恰好是 $r$ 分钟。\n\nBartie 的队伍在今年的比赛中表现不佳。Bartie 确信这是他的问题，是由于他分配问题失误造成的。他想让你写个程序，给出 Bartie 在比赛前知道的信息，请求出 Bartie 的队伍可能的最好成绩和分配题目的方式。", "inputFormat": "第一行五个整数 $n,m,r,t,k$，分别表示一个队中的队员数，题目数，队员解决一道题的用时，比赛的时间长度和队员-题目对数；\n\n接下来 $k$ 行，每行两个数 $a,b$，表示队员 $a$ 可以解决问题 $b$。每一个有序对在输入中最多出现一次。", "outputFormat": "第一行输出两个整数，用一个空格隔开，分别表示解出的题目总数 $z$ 和最少总罚时。\n\n接下来 $z$ 行，每行输出三个整数 $a,b,c\\ (1 \\le a \\le n , 1 \\le b \\le m , 0 \\le c \\le t-r)$，表示队员 $a$ 在时刻 $c$ 时开始解决题目 $b$（比赛开始于时刻 $0$）。你不能把一道题分配给不会解决它的人。如果有多种分配方案，输出任意一组均可。", "hint": "对于全部数据，$ 1 \\le n, m \\le 500 , 1 \\le r, t \\le 1000000, 1 \\le a \\le n , 1 \\le b \\le m $\n\n对于 $30\\%$ 的分数，$n,m\\le 100$。\n\n翻译来自于 [LibreOJ](https://loj.ac/p/2171)。", "locale": "zh-CN"}}}
{"pid": "P3530", "type": "P", "difficulty": 5, "samples": [["4 2 2\n1 2\n3 4\n1 4\n3 1\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2012", "POI（波兰）", "负权环", "Tarjan", "差分约束", "Floyd 算法"], "title": "[POI 2012] FES-Festival", "background": "在 Byteburg 举办了一场慈善活动，你是其中一个筹款人。不幸的是，你错过了一些有趣的活动，包括一场越野赛。\n\n谜题爱好者 Byteasar 承诺：如果你能解开他的谜题，他会捐一大笔钱。", "description": "你不知道越野赛的结果，但 Byteasar 会告诉你部分信息。现在，他要你答出：所有参赛者最多能达到多少种不同的成绩，而不违背他给的条件。（他们中的一些人可能平局，也就是同时到达终点，这种情况只算有一种成绩）。\n\nByteasar 告诉你，所有参赛者的成绩都是整数秒。他还会为你提供了一些参赛者成绩的关系。具体是：他会给你一些数对 $(A, B)$，表示 $A$ 的成绩正好比 $B$ 快 $1$ 秒；他还会给你一些数对 $(C, D)$，表示 $C$ 的成绩不比 $D$ 慢。而你要回答的是：所有参赛者最多能达到多少种不同的成绩，而不违背他给的条件。\n\n请你编程解决这个谜题。", "inputFormat": "第一行有三个整数 $n, m_{1}, m_{2}$，分别表示选手人数、数对 $(A, B)$ 的数目、数对 $(C, D)$ 的数目。\n\n接下来 $m_1$ 行，每行两个整数 $a_{i}, b_{i}$（$a_{i} \\ne b_{i}$）。这表示选手 $a_{i}$ 的成绩恰比 $b_{i}$ 小 $1$ 秒。\n\n接下来 $m_{2}$ 行，每行两个整数 $c_{i}, d_{i}$（$c_{i} \\ne d_{i}$）。这表示选手 $c_{i}$ 的成绩不比 $d_{i}$ 的成绩差（也就是花的时间不会更多）。", "outputFormat": "如果有解，输出一行一个整数，表示所有选手最多能拿到的成绩的种数。  \n如果无解，输出 `NIE`。", "hint": "答案为 $3$，情况为：$t_3=1, t_1=t_4=2, t_2=3$。  \n（$t_i$ 表示参赛者 $i$ 花的时间）\n\n**【数据范围】**\n\n对于 $15\\%$ 的数据，$n \\le 10$。  \n对于 $100\\%$ 的数据，$2 \\le n \\le 600$，$1 \\le m_{1} + m_{2} \\le {10}^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2012] FES-Festival", "background": "A charity event was held in Byteburg, and you are one of the fundraisers. Unfortunately, you missed some interesting activities, including a cross-country race.\n\nPuzzle enthusiast Byteasar promises: if you can solve his puzzle, he will donate a large sum of money.", "description": "You do not know the results of the race, but Byteasar will tell you partial information. Now, you are asked to answer: what is the maximum number of distinct finishing times that all participants can have without violating his conditions? Some of them may tie (i.e., finish at the same time), and such ties count as one distinct time.\n\nByteasar tells you that all finishing times are integer seconds. He will also provide some relations between the participants’ times. Specifically, he will give you some pairs $(A, B)$, meaning that $A$’s time is exactly $1$ second less than $B$’s; and some pairs $(C, D)$, meaning that $C$’s time is not greater than $D$’s. Your task is to compute the maximum possible number of distinct finishing times for all participants that satisfies these conditions.\n\nPlease write a program to solve this puzzle.", "inputFormat": "The first line contains three integers $n, m_{1}, m_{2}$, denoting the number of participants, the number of pairs $(A, B)$, and the number of pairs $(C, D)$, respectively.\n\nThe next $m_{1}$ lines each contain two integers $a_{i}, b_{i}$ ($a_{i} \\ne b_{i}$). This means participant $a_{i}$’s time is exactly $1$ second less than participant $b_{i}$’s.\n\nThe next $m_{2}$ lines each contain two integers $c_{i}, d_{i}$ ($c_{i} \\ne d_{i}$). This means participant $c_{i}$’s time is not greater than participant $d_{i}$’s.", "outputFormat": "If there is a solution, output a single integer on one line, representing the maximum number of distinct finishing times among all participants.  \nIf there is no solution, output `NIE`.", "hint": "The answer is $3$, with $t_3 = 1$, $t_1 = t_4 = 2$, $t_2 = 3$.  \n($t_i$ denotes the time spent by participant $i$.)\n\nConstraints\n\n- For $15\\%$ of the testdata, $n \\le 10$.\n- For $100\\%$ of the testdata, $2 \\le n \\le 600$, $1 \\le m_{1} + m_{2} \\le 10^{5}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2012] FES-Festival", "background": "在 Byteburg 举办了一场慈善活动，你是其中一个筹款人。不幸的是，你错过了一些有趣的活动，包括一场越野赛。\n\n谜题爱好者 Byteasar 承诺：如果你能解开他的谜题，他会捐一大笔钱。", "description": "你不知道越野赛的结果，但 Byteasar 会告诉你部分信息。现在，他要你答出：所有参赛者最多能达到多少种不同的成绩，而不违背他给的条件。（他们中的一些人可能平局，也就是同时到达终点，这种情况只算有一种成绩）。\n\nByteasar 告诉你，所有参赛者的成绩都是整数秒。他还会为你提供了一些参赛者成绩的关系。具体是：他会给你一些数对 $(A, B)$，表示 $A$ 的成绩正好比 $B$ 快 $1$ 秒；他还会给你一些数对 $(C, D)$，表示 $C$ 的成绩不比 $D$ 慢。而你要回答的是：所有参赛者最多能达到多少种不同的成绩，而不违背他给的条件。\n\n请你编程解决这个谜题。", "inputFormat": "第一行有三个整数 $n, m_{1}, m_{2}$，分别表示选手人数、数对 $(A, B)$ 的数目、数对 $(C, D)$ 的数目。\n\n接下来 $m_1$ 行，每行两个整数 $a_{i}, b_{i}$（$a_{i} \\ne b_{i}$）。这表示选手 $a_{i}$ 的成绩恰比 $b_{i}$ 小 $1$ 秒。\n\n接下来 $m_{2}$ 行，每行两个整数 $c_{i}, d_{i}$（$c_{i} \\ne d_{i}$）。这表示选手 $c_{i}$ 的成绩不比 $d_{i}$ 的成绩差（也就是花的时间不会更多）。", "outputFormat": "如果有解，输出一行一个整数，表示所有选手最多能拿到的成绩的种数。  \n如果无解，输出 `NIE`。", "hint": "答案为 $3$，情况为：$t_3=1, t_1=t_4=2, t_2=3$。  \n（$t_i$ 表示参赛者 $i$ 花的时间）\n\n**【数据范围】**\n\n对于 $15\\%$ 的数据，$n \\le 10$。  \n对于 $100\\%$ 的数据，$2 \\le n \\le 600$，$1 \\le m_{1} + m_{2} \\le {10}^5$。", "locale": "zh-CN"}}}
{"pid": "P3531", "type": "P", "difficulty": 3, "samples": [["3\nABC\nBCA\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "树状数组", "POI（波兰）", "O2优化"], "title": "[POI 2012] LIT-Letters", "background": "", "description": "给出两个长度相同的的只含大写字母的字符串 $a, b$，每次可以交换 $a$ 中相邻两个字符，求最少的交换次数，使得 $a$ 交换后的得到的字符串与 $b$ 相同。", "inputFormat": "输入的第一行是一个整数，代表字符串的长度 $n$。\n\n第二行是一个长度为 $n$ 的字符串，代表 $a$。\n\n第三行是一个长度为 $n$ 的字符串，代表 $b$。", "outputFormat": "输出一行一个整数，代表最少的交换次数。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 10^3$。\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^6$，$a, b$ 中只含大写字母，且数据保证 $a$ 可以变成 $b$。", "locale": "zh-CN", "translations": {"en": {"title": "[POI 2012] LIT-Letters", "background": "", "description": "Given two strings $a$, $b$ of equal length, each consisting only of uppercase letters, you may swap two adjacent characters in $a$ at a time. Find the minimum number of swaps needed so that the string obtained from $a$ becomes identical to $b$.", "inputFormat": "The first line contains an integer $n$, the length of the strings.\n\nThe second line contains a string of length $n$, denoting $a$.\n\nThe third line contains a string of length $n$, denoting $b$.", "outputFormat": "Output a single integer on one line, the minimum number of swaps.", "hint": "#### Constraints\n\n- For 30% of the testdata, it is guaranteed that $n \\leq 10^3$.\n- For 100% of the testdata, $1 \\leq n \\leq 10^6$, $a$, $b$ contain only uppercase letters, and the testdata guarantees that $a$ can be transformed into $b$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[POI 2012] LIT-Letters", "background": "", "description": "给出两个长度相同的的只含大写字母的字符串 $a, b$，每次可以交换 $a$ 中相邻两个字符，求最少的交换次数，使得 $a$ 交换后的得到的字符串与 $b$ 相同。", "inputFormat": "输入的第一行是一个整数，代表字符串的长度 $n$。\n\n第二行是一个长度为 $n$ 的字符串，代表 $a$。\n\n第三行是一个长度为 $n$ 的字符串，代表 $b$。", "outputFormat": "输出一行一个整数，代表最少的交换次数。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n \\leq 10^3$。\n- 对于 $100\\%$ 的数据，$1 \\leq n \\leq 10^6$，$a, b$ 中只含大写字母，且数据保证 $a$ 可以变成 $b$。", "locale": "zh-CN"}}}
