{"pid": "P1181", "type": "P", "difficulty": 2, "samples": [["5 6\n4 2 4 5 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心"], "title": "数列分段 Section I", "background": null, "description": "对于给定的一个长度为 $N$ 的正整数数列 $A_i$，现要将其分成**连续**的若干段，并且每段和不超过 $M$（可以等于 $M$），问最少能将其分成多少段使得满足要求。", "inputFormat": "第1行包含两个正整数 $N,M$，表示了数列 $A_i$ 的长度与每段和的最大值，第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$，如题目所述。", "outputFormat": "一个正整数，输出最少划分的段数。", "hint": "对于 $20\\%$ 的数据，有 $N≤10$；\n\n对于 $40\\%$ 的数据，有 $N≤1000$；\n\n对于 $100\\%$ 的数据，有 $N≤10^5,M≤10^9$，$M$ 大于所有数的最大值，$A_i$ 之和不超过 $10^9$。\n\n\n将数列如下划分：\n\n$[4][2 4][5 1]$\n\n第一段和为 $4$，第 $2$ 段和为 $6$，第 $3$ 段和为 $6$ 均满足和不超过 $M=6$，并可以证明 $3$ 是最少划分的段数。", "locale": "zh-CN", "translations": {"en": {"title": "Sequence Segmentation Section I", "background": "", "description": "Given a sequence $A_i$ of length $N$ consisting of non-negative integers, split it into several consecutive segments such that the sum of each segment does not exceed $M$ (it can be equal to $M$). Find the minimum number of segments needed to meet the requirement.", "inputFormat": "The first line contains two positive integers $N, M$, representing the length of the sequence $A_i$ and the maximum allowed sum of each segment. The second line contains $N$ space-separated non-negative integers $A_i$, as described.", "outputFormat": "Output a single integer: the minimum number of segments.", "hint": "For $20\\%$ of the testdata, there is $N≤10$.\n\nFor $40\\%$ of the testdata, there is $N≤1000$.\n\nFor $100\\%$ of the testdata, there are $N≤100000, M≤10^9$, $M$ is greater than the maximum element, and the sum of $A_i$ does not exceed $10^9$.\n\nSplit the sequence as follows:\n\n$[4][2 4][5 1]$\n\nThe sum of the first segment is $4$, the sum of the $2$nd segment is $6$, and the sum of the $3$rd segment is $6$, all not exceeding $M=6$. It can be proven that $3$ is the minimum number of segments.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数列分段 Section I", "background": null, "description": "对于给定的一个长度为 $N$ 的正整数数列 $A_i$，现要将其分成**连续**的若干段，并且每段和不超过 $M$（可以等于 $M$），问最少能将其分成多少段使得满足要求。", "inputFormat": "第1行包含两个正整数 $N,M$，表示了数列 $A_i$ 的长度与每段和的最大值，第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$，如题目所述。", "outputFormat": "一个正整数，输出最少划分的段数。", "hint": "对于 $20\\%$ 的数据，有 $N≤10$；\n\n对于 $40\\%$ 的数据，有 $N≤1000$；\n\n对于 $100\\%$ 的数据，有 $N≤10^5,M≤10^9$，$M$ 大于所有数的最大值，$A_i$ 之和不超过 $10^9$。\n\n\n将数列如下划分：\n\n$[4][2 4][5 1]$\n\n第一段和为 $4$，第 $2$ 段和为 $6$，第 $3$ 段和为 $6$ 均满足和不超过 $M=6$，并可以证明 $3$ 是最少划分的段数。", "locale": "zh-CN"}}}
{"pid": "P1182", "type": "P", "difficulty": 3, "samples": [["5 3\n4 2 4 5 1", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "二分", "前缀和"], "title": "数列分段 Section II", "background": "", "description": "对于给定的一个长度为 $N$ 的正整数数列 $A_{1\\sim N}$，现要将其分成 $M$（$M\\leq N$）段，并要求每段连续，且每段和的最大值最小。\n\n关于最大值最小：\n\n例如一数列 $4\\ 2\\ 4\\ 5\\ 1$ 要分成 $3$ 段。\n\n将其如下分段：\n\n$$[4\\ 2][4\\ 5][1]$$\n\n第一段和为 $6$，第 $2$ 段和为 $9$，第 $3$ 段和为 $1$，和最大值为 $9$。\n\n将其如下分段：\n\n$$[4][2\\ 4][5\\ 1]$$\n\n第一段和为 $4$，第 $2$ 段和为 $6$，第 $3$ 段和为 $6$，和最大值为 $6$。\n\n并且无论如何分段，最大值不会小于 $6$。\n\n所以可以得到要将数列 $4\\ 2\\ 4\\ 5\\ 1$ 要分成 $3$ 段，每段和的最大值最小为 $6$。\n", "inputFormat": "第 $1$ 行包含两个正整数 $N,M$。  \n\n第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$，含义如题目所述。\n", "outputFormat": "一个正整数，即每段和最大值最小为多少。\n", "hint": "对于 $20\\%$ 的数据，$N\\leq 10$。\n\n对于 $40\\%$ 的数据，$N\\leq 1000$。\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 10^5$，$M\\leq N$，$A_i < 10^8$， 答案不超过 $10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Sequence Partitioning Section II", "background": "", "description": "Given a sequence of positive integers $A_{1\\sim N}$ of length $N$, you need to partition it into $M$ ($M \\leq N$) contiguous segments, such that the maximum segment sum is minimized.\n\nAbout minimizing the maximum:\n\nFor example, consider the sequence $4\\ 2\\ 4\\ 5\\ 1$ to be divided into $3$ segments.\n\nPartition it as:\n$$[4\\ 2][4\\ 5][1]$$\nThe sum of the first segment is $6$, the sum of the second segment is $9$, the sum of the third segment is $1$, and the maximum of these sums is $9$.\n\nPartition it as:\n$$[4][2\\ 4][5\\ 1]$$\nThe sum of the first segment is $4$, the sum of the second segment is $6$, the sum of the third segment is $6$, and the maximum of these sums is $6$.\n\nMoreover, no matter how you partition it, the maximum will not be smaller than $6$.\n\nTherefore, for the sequence $4\\ 2\\ 4\\ 5\\ 1$ divided into $3$ segments, the minimum possible maximum segment sum is $6$.", "inputFormat": "The first line contains two positive integers $N, M$.\n\nThe second line contains $N$ space-separated non-negative integers $A_i$, as described above.", "outputFormat": "A single positive integer: the minimum possible value of the maximum segment sum.", "hint": "Constraints:\n- For $20\\%$ of the testdata, $N \\leq 10$.\n- For $40\\%$ of the testdata, $N \\leq 1000$.\n- For $100\\%$ of the testdata, $1 \\leq N \\leq 10^5$, $M \\leq N$, $A_i < 10^8$, and the answer does not exceed $10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数列分段 Section II", "background": "", "description": "对于给定的一个长度为 $N$ 的正整数数列 $A_{1\\sim N}$，现要将其分成 $M$（$M\\leq N$）段，并要求每段连续，且每段和的最大值最小。\n\n关于最大值最小：\n\n例如一数列 $4\\ 2\\ 4\\ 5\\ 1$ 要分成 $3$ 段。\n\n将其如下分段：\n\n$$[4\\ 2][4\\ 5][1]$$\n\n第一段和为 $6$，第 $2$ 段和为 $9$，第 $3$ 段和为 $1$，和最大值为 $9$。\n\n将其如下分段：\n\n$$[4][2\\ 4][5\\ 1]$$\n\n第一段和为 $4$，第 $2$ 段和为 $6$，第 $3$ 段和为 $6$，和最大值为 $6$。\n\n并且无论如何分段，最大值不会小于 $6$。\n\n所以可以得到要将数列 $4\\ 2\\ 4\\ 5\\ 1$ 要分成 $3$ 段，每段和的最大值最小为 $6$。\n", "inputFormat": "第 $1$ 行包含两个正整数 $N,M$。  \n\n第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$，含义如题目所述。\n", "outputFormat": "一个正整数，即每段和最大值最小为多少。\n", "hint": "对于 $20\\%$ 的数据，$N\\leq 10$。\n\n对于 $40\\%$ 的数据，$N\\leq 1000$。\n\n对于 $100\\%$ 的数据，$1\\leq N\\leq 10^5$，$M\\leq N$，$A_i < 10^8$， 答案不超过 $10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P1183", "type": "P", "difficulty": 3, "samples": [["10\n0 0\n4 0\n4 1\n3 1\n3 3\n2 3\n2 2\n1 2\n1 3\n0 3", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["计算几何", "叉积"], "title": "多边形的面积", "background": "", "description": "给出一个没有缺口的简单多边形，它的边是垂直或者水平的，要求计算多边形的面积。\n\n多边形被放置在一个 $xOy$ 的笛卡尔平面上，它所有的边都平行于两条坐标轴之一。然后按逆时针方向给出各顶点的坐标值。所有的坐标值都是整数，因此多边形的面积也为整数。\n\n**注意：可能存在连续的三个顶点在一条直线上的情况**。", "inputFormat": "第一行给出多边形的顶点数 $n$ 。\n\n接下来 $n$ 行，每行给出多边形一个顶点的坐标值 $x$ 和 $y$，用空格隔开。\n\n顶点按逆时针方向逐个给出。多边形最后是靠从最后一个顶点到第一个顶点画一条边来封闭的。", "outputFormat": "一行，一个整数，表示多边形的面积。\n", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 100$，$-200 \\le x,y \\le 200$。", "locale": "zh-CN", "translations": {"en": {"title": "Area of a Polygon", "background": "", "description": "Given a simple polygon without holes whose edges are vertical or horizontal, compute the area of the polygon.\n\nThe polygon is placed on an $xOy$ Cartesian plane, and all its edges are parallel to one of the two coordinate axes. The vertex coordinates are given in counterclockwise order. All coordinates are integers, so the area of the polygon is also an integer.\n\nNote: There may be three consecutive vertices that are collinear.", "inputFormat": "The first line contains the number of vertices $n$.\n\nThe next $n$ lines each contain the coordinates $x$ and $y$ of a vertex, separated by a space.\n\nThe vertices are given one by one in counterclockwise order. The polygon is closed by drawing an edge from the last vertex to the first.", "outputFormat": "One line with a single integer, representing the area of the polygon.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 100$, $-200 \\le x, y \\le 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "多边形的面积", "background": "", "description": "给出一个没有缺口的简单多边形，它的边是垂直或者水平的，要求计算多边形的面积。\n\n多边形被放置在一个 $xOy$ 的笛卡尔平面上，它所有的边都平行于两条坐标轴之一。然后按逆时针方向给出各顶点的坐标值。所有的坐标值都是整数，因此多边形的面积也为整数。\n\n**注意：可能存在连续的三个顶点在一条直线上的情况**。", "inputFormat": "第一行给出多边形的顶点数 $n$ 。\n\n接下来 $n$ 行，每行给出多边形一个顶点的坐标值 $x$ 和 $y$，用空格隔开。\n\n顶点按逆时针方向逐个给出。多边形最后是靠从最后一个顶点到第一个顶点画一条边来封闭的。", "outputFormat": "一行，一个整数，表示多边形的面积。\n", "hint": "对于 $100\\%$ 的数据，$1 \\le n \\le 100$，$-200 \\le x,y \\le 200$。", "locale": "zh-CN"}}}
{"pid": "P1184", "type": "P", "difficulty": 2, "samples": [["1 2\nWC\nCLASS\nWC\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "洛谷原创", "哈希 hashing"], "title": "高手之在一起", "background": "高手是可以复活的，这点我们大家都知道。", "description": "高手列出了一个详尽的日程表，这次他要追求的则是一个心灵纯洁的小萝莉。他和她都是要上课的，但是也会有时间空闲，于是高手决定无时无刻都要跟着她。为了她，高手决定转学到一年级。\n\n现在高手已经花重金买下了她的日程表，每一天都会有她的行踪。现在列出了高手方便去的地方。其中方便去的地方可以去无限次，不方便去的地方不能去。\n\n一共有 $n$ 个方便去的地点，$m$ 天。高手想知道他在这 $m$ 天中，最多能和她在一起多久。不方便去的地方是不会列出的。", "inputFormat": "第一行两个整数 $n,m$。  \n\n接下来 $n$ 行，每行一个地名，高手方便去的地方。  \n\n接下来 $m$ 行，每行一个地名，她这一天在的地方。\n\n**地名中可能有空格。**", "outputFormat": "一个整数，他们在同一个地方的天数。", "hint": "$1 \\leq m \\leq 10^6$，$1 \\leq n \\leq 20$。", "locale": "zh-CN", "translations": {"en": {"title": "Being Together with the Expert", "background": "An expert can be resurrected; we all know that.", "description": "The expert has drawn up a detailed schedule. This time, he wants to pursue a pure-hearted little girl. Both he and she have classes, but there will also be free time, so the expert decides to follow her at all times. For her, the expert decides to transfer to first grade.\n\nNow the expert has spent a lot of money to buy her schedule, which shows where she will be each day. A list of places convenient for the expert to go is also provided. He can visit convenient places any number of times, while inconvenient places cannot be visited.\n\nThere are $n$ convenient places to go and $m$ days. The expert wants to know the maximum number of days, within these $m$ days, that he can be together with her. Inconvenient places are not listed.", "inputFormat": "The first line contains two integers $n, m$.  \nThen follow $n$ lines, each with the name of a place that is convenient for the expert to go.  \nThen follow $m$ lines, each with the name of the place where she is on that day.\n\n**Place names may contain spaces.**", "outputFormat": "An integer: the number of days they are at the same place.", "hint": "$1 \\leq m \\leq 10^6$, $1 \\leq n \\leq 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "高手之在一起", "background": "高手是可以复活的，这点我们大家都知道。", "description": "高手列出了一个详尽的日程表，这次他要追求的则是一个心灵纯洁的小萝莉。他和她都是要上课的，但是也会有时间空闲，于是高手决定无时无刻都要跟着她。为了她，高手决定转学到一年级。\n\n现在高手已经花重金买下了她的日程表，每一天都会有她的行踪。现在列出了高手方便去的地方。其中方便去的地方可以去无限次，不方便去的地方不能去。\n\n一共有 $n$ 个方便去的地点，$m$ 天。高手想知道他在这 $m$ 天中，最多能和她在一起多久。不方便去的地方是不会列出的。", "inputFormat": "第一行两个整数 $n,m$。  \n\n接下来 $n$ 行，每行一个地名，高手方便去的地方。  \n\n接下来 $m$ 行，每行一个地名，她这一天在的地方。\n\n**地名中可能有空格。**", "outputFormat": "一个整数，他们在同一个地方的天数。", "hint": "$1 \\leq m \\leq 10^6$，$1 \\leq n \\leq 20$。", "locale": "zh-CN"}}}
{"pid": "P1185", "type": "P", "difficulty": 4, "samples": [["2 0\n", "  o  \n / \\ \no   o\n"], ["4 0", "           o           \n          / \\          \n         /   \\         \n        /     \\        \n       /       \\       \n      /         \\      \n     o           o     \n    / \\         / \\    \n   /   \\       /   \\   \n  o     o     o     o  \n / \\   / \\   / \\   / \\ \no   o o   o o   o o   o"], ["4 3\n3 2\n4 1\n3 4\n", "           o           \n          / \\          \n         /   \\         \n        /     \\        \n       /       \\       \n      /         \\      \n     o           o     \n    /           /      \n   /           /       \n  o           o        \n   \\         / \\       \n    o       o   o      "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟"], "title": "绘制二叉树", "background": "", "description": "二叉树是一种基本的数据结构，它要么为空，要么由根结点，左子树和右子树组成，同时左子树和右子树也分别是二叉树。\n\n当一颗二叉树高度为 $m-1$ 时，共有 $m$ 层。若一棵二叉树除第 $m$ 层外，其他各层的结点数都达到最大，且叶子结点都在第 $m$ 层时，则其为一棵满二叉树。\n\n现在，需要你用程序来绘制一棵二叉树，它由一棵满二叉树去掉若干结点而成。对于一棵满二叉树，我们需要按照以下要求绘制：\n\n1. 结点用小写字母 `o` 表示，对于一个父亲结点，用 `/` 连接左子树，用 `\\` 连接右子树。\n\n2. 定义 $[i,j]$ 为位于第 $i$ 行第 $j$ 列的某个字符。若 $[i,j]$ 为 `/` ，那么 $[i-1,j+1]$ 与 $[i+1,j-1]$ 要么为 `o` ，要么为 `/`。若 $[i,j]$ 为 `\\` ，那么 $[i-1,j-1]$ 与 $[i+1,j+1]$ 要么为 `o`，要么为 `\\` 。同样，若 $[i,j]$ 为第 $1\\sim m-1$ 层的某个结点 `o` ，那么 $[i+1,j-1]$ 为 `/`，$[i+1,j+1]$ 为 `\\`。\n\n3. 对于第 $m$ 层结点也就是叶子结点点，若两个属于同一个父亲，那么它们之间由 $3$ 个空格隔开；若两个结点相邻但不属于同一个父亲，那么它们之间由 $1$ 个空格隔开。第 $m$ 层左数第 $1$ 个结点之前没有空格。\n\n最后需要在一棵绘制好的满二叉树上删除 $n$ 个结点（包括这个结点的左右子树，以及与父亲的连接），原有的字符用空格替换（空格为 `ASCII 32`，若输出 `ASCII 0` 会被算作错误答案）。", "inputFormat": "第 $1$ 行包含 $2$ 个正整数 $m$ 和 $n$，为需要绘制的二叉树层数和需要删除的结点数。\n\n接下来 $n$ 行，每行两个正整数，表示删除第 $i$ 层的第 $j$ 个结点。", "outputFormat": "按照题目要求绘制的二叉树。\n", "hint": "$30\\%$ 的数据满足：$n=0$；\n\n$50\\%$ 的数据满足：$2\\le m\\le 5$；\n\n$100\\%$ 的数据满足：$2\\le m\\le10,0\\le n\\le 10,1<i\\le M,j\\le 2^{i-1}$。", "locale": "zh-CN", "translations": {"en": {"title": "Drawing a Binary Tree", "background": "", "description": "A binary tree is a basic data structure. It is either empty, or consists of a root node, a left subtree, and a right subtree. The left and right subtrees are also binary trees.\n\nWhen a binary tree has height $m-1$, it has $m$ levels. If, in a binary tree, every level except level $m$ has the maximum possible number of nodes and all leaf nodes are on level $m$, then it is a full binary tree.\n\nNow you are required to write a program to draw a binary tree that is obtained by removing some nodes from a full binary tree. For a full binary tree, draw it according to the following rules:\n\n1. Nodes are represented by the lowercase letter `o`. For a parent node, use `/` to connect to its left child and `\\` to connect to its right child.\n\n2. Define $[i,j]$ as the character located at row $i$ and column $j$. If $[i,j]$ is `/`, then $[i-1,j+1]$ and $[i+1,j-1]$ must be either `o` or `/`. If $[i,j]$ is `\\`, then $[i-1,j-1]$ and $[i+1,j+1]$ must be either `o` or `\\`. Likewise, if $[i,j]$ is a node `o` on levels $1\\sim m-1$, then $[i+1,j-1]$ is `/` and $[i+1,j+1]$ is `\\`.\n\n3. For the nodes on level $m$ (the leaves): if two leaves share the same parent, they are separated by 3 spaces; if two leaves are adjacent but do not share the same parent, they are separated by 1 space. There is no space before the first (leftmost) node on level $m$.\n\nFinally, after drawing a full binary tree, delete $n$ nodes from it (each deletion removes that node, its left and right subtrees, and its connection to its parent). Replace all removed characters with spaces (the space is `ASCII 32`; outputting `ASCII 0` will be judged as a wrong answer).", "inputFormat": "The first line contains two positive integers $m$ and $n$, the number of levels of the binary tree to draw and the number of nodes to delete.\n\nThe next $n$ lines each contain two positive integers, indicating deletion of the $j$-th node on level $i$.", "outputFormat": "Output the binary tree drawn according to the requirements.", "hint": "30% of the testdata satisfy: $n=0$.\n\n50% of the testdata satisfy: $2\\le m\\le 5$.\n\n100% of the testdata satisfy: $2\\le m\\le10,0\\le n\\le 10,1<i\\le m,j\\le 2^{i-1}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "绘制二叉树", "background": "", "description": "二叉树是一种基本的数据结构，它要么为空，要么由根结点，左子树和右子树组成，同时左子树和右子树也分别是二叉树。\n\n当一颗二叉树高度为 $m-1$ 时，共有 $m$ 层。若一棵二叉树除第 $m$ 层外，其他各层的结点数都达到最大，且叶子结点都在第 $m$ 层时，则其为一棵满二叉树。\n\n现在，需要你用程序来绘制一棵二叉树，它由一棵满二叉树去掉若干结点而成。对于一棵满二叉树，我们需要按照以下要求绘制：\n\n1. 结点用小写字母 `o` 表示，对于一个父亲结点，用 `/` 连接左子树，用 `\\` 连接右子树。\n\n2. 定义 $[i,j]$ 为位于第 $i$ 行第 $j$ 列的某个字符。若 $[i,j]$ 为 `/` ，那么 $[i-1,j+1]$ 与 $[i+1,j-1]$ 要么为 `o` ，要么为 `/`。若 $[i,j]$ 为 `\\` ，那么 $[i-1,j-1]$ 与 $[i+1,j+1]$ 要么为 `o`，要么为 `\\` 。同样，若 $[i,j]$ 为第 $1\\sim m-1$ 层的某个结点 `o` ，那么 $[i+1,j-1]$ 为 `/`，$[i+1,j+1]$ 为 `\\`。\n\n3. 对于第 $m$ 层结点也就是叶子结点点，若两个属于同一个父亲，那么它们之间由 $3$ 个空格隔开；若两个结点相邻但不属于同一个父亲，那么它们之间由 $1$ 个空格隔开。第 $m$ 层左数第 $1$ 个结点之前没有空格。\n\n最后需要在一棵绘制好的满二叉树上删除 $n$ 个结点（包括这个结点的左右子树，以及与父亲的连接），原有的字符用空格替换（空格为 `ASCII 32`，若输出 `ASCII 0` 会被算作错误答案）。", "inputFormat": "第 $1$ 行包含 $2$ 个正整数 $m$ 和 $n$，为需要绘制的二叉树层数和需要删除的结点数。\n\n接下来 $n$ 行，每行两个正整数，表示删除第 $i$ 层的第 $j$ 个结点。", "outputFormat": "按照题目要求绘制的二叉树。\n", "hint": "$30\\%$ 的数据满足：$n=0$；\n\n$50\\%$ 的数据满足：$2\\le m\\le 5$；\n\n$100\\%$ 的数据满足：$2\\le m\\le10,0\\le n\\le 10,1<i\\le M,j\\le 2^{i-1}$。", "locale": "zh-CN"}}}
{"pid": "P1186", "type": "P", "difficulty": 6, "samples": [["5 7\n1 2 8\n1 4 10\n2 3 9\n2 4 10\n2 5 1\n3 4 7\n3 5 10\n", "27"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "线段树", "枚举", "最短路"], "title": "玛丽卡", "background": "", "description": "麦克找了个新女朋友，玛丽卡对他非常恼火并伺机报复。\n\n因为她和他们不住在同一个城市，因此她开始准备她的长途旅行。\n\n在这个国家中每两个城市之间最多只有一条路相通，并且我们知道从一个城市到另一个城市路上所需花费的时间。\n\n麦克在车中无意中听到有一条路正在维修，并且那儿正堵车，但没听清楚到底是哪一条路。无论哪一条路正在维修，从玛丽卡所在的城市都能到达麦克所在的城市。\n\n玛丽卡将只从不堵车的路上通过，并且她将按最短路线行车。麦克希望知道在最糟糕的情况下玛丽卡到达他所在的城市需要多长时间，这样他就能保证他的女朋友离开该城市足够远。\n\n编写程序，帮助麦克找出玛丽卡按最短路线通过不堵车道路到达他所在城市所需的最长时间（用分钟表示）。\n", "inputFormat": "第一行有两个用空格隔开的数 $N$ 和 $M$，分别表示城市的数量以及城市间道路的数量。$1 \\le N \\le 1000$，$1 \\le M \\le N \\times (N - 1)/2$。城市用数字 $1 \\sim N$ 标识，麦克在城市 $1$ 中，玛丽卡在城市 $N$ 中。  \n\n接下来的 $M$ 行中每行包含三个用空格隔开的数 $A,B,V$。其中 $1 \\le A, B \\le N$，$1 \\le V \\le 1000$。这些数字表示在 $A$ 和城市 $B$ 中间有一条双行道，并且在 $V$ 分钟内就能通过。", "outputFormat": "一行，写出用分钟表示的最长时间，在这段时间中，无论哪条路在堵车，玛丽卡应该能够到达麦克处，如果少于这个时间的话，则必定存在一条路，该条路一旦堵车，玛丽卡就不能够赶到麦克处。", "hint": "感谢 Imakf 提供的三组 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "Marika", "background": "", "description": "Mike got a new girlfriend, which made Marika very angry and eager to take revenge.\n\nSince she does not live in the same city as them, she starts preparing for a long trip.\n\nIn this country, between any two cities there is at most one road, and we know the time needed to travel from one city to another.\n\nMike happened to overhear that some road is under repair and is jammed, but he did not catch which road it is. No matter which single road is under repair, it is still possible to get from Marika’s city to Mike’s city.\n\nMarika will travel only on non-jammed roads, and she will follow a shortest route. Mike wants to know, in the worst case, how long it will take Marika to reach his city, so that he can make sure his new girlfriend is far enough away from that city.\n\nWrite a program to help Mike find the maximum time (in minutes) that Marika needs to reach his city by a shortest route using only non-jammed roads.", "inputFormat": "The first line contains two space-separated integers $N$ and $M$, the number of cities and the number of roads, respectively. $1 \\le N \\le 1000$, $1 \\le M \\le N \\times (N - 1)/2$. The cities are labeled $1 \\sim N$, Mike is in city $1$, and Marika is in city $N$.\n\nEach of the next $M$ lines contains three space-separated integers $A, B, V$. Here $1 \\le A, B \\le N$, $1 \\le V \\le 1000$. These numbers mean there is a bidirectional road between city $A$ and city $B$, and it takes $V$ minutes to travel it.", "outputFormat": "Output a single line with the maximum time in minutes such that, no matter which single road is jammed, Marika can reach Mike within this time by a shortest route over non-jammed roads; if the time were any smaller, then there would exist some road which, once jammed, would prevent Marika from reaching Mike within that time.", "hint": "Thanks to Imakf for providing three sets of hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "玛丽卡", "background": "", "description": "麦克找了个新女朋友，玛丽卡对他非常恼火并伺机报复。\n\n因为她和他们不住在同一个城市，因此她开始准备她的长途旅行。\n\n在这个国家中每两个城市之间最多只有一条路相通，并且我们知道从一个城市到另一个城市路上所需花费的时间。\n\n麦克在车中无意中听到有一条路正在维修，并且那儿正堵车，但没听清楚到底是哪一条路。无论哪一条路正在维修，从玛丽卡所在的城市都能到达麦克所在的城市。\n\n玛丽卡将只从不堵车的路上通过，并且她将按最短路线行车。麦克希望知道在最糟糕的情况下玛丽卡到达他所在的城市需要多长时间，这样他就能保证他的女朋友离开该城市足够远。\n\n编写程序，帮助麦克找出玛丽卡按最短路线通过不堵车道路到达他所在城市所需的最长时间（用分钟表示）。\n", "inputFormat": "第一行有两个用空格隔开的数 $N$ 和 $M$，分别表示城市的数量以及城市间道路的数量。$1 \\le N \\le 1000$，$1 \\le M \\le N \\times (N - 1)/2$。城市用数字 $1 \\sim N$ 标识，麦克在城市 $1$ 中，玛丽卡在城市 $N$ 中。  \n\n接下来的 $M$ 行中每行包含三个用空格隔开的数 $A,B,V$。其中 $1 \\le A, B \\le N$，$1 \\le V \\le 1000$。这些数字表示在 $A$ 和城市 $B$ 中间有一条双行道，并且在 $V$ 分钟内就能通过。", "outputFormat": "一行，写出用分钟表示的最长时间，在这段时间中，无论哪条路在堵车，玛丽卡应该能够到达麦克处，如果少于这个时间的话，则必定存在一条路，该条路一旦堵车，玛丽卡就不能够赶到麦克处。", "hint": "感谢 Imakf 提供的三组 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P1187", "type": "P", "difficulty": 2, "samples": [["3 3\n111\n212\n111", "38\n"], ["3 4\n1000\n0010\n0000\n", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "3D模型", "background": "", "description": "一座城市建立在规则的 $n \\times m$ 网格上，并且网格均由 $1 \\times 1$ 正方形构成。在每个网格上都可以有一个建筑，建筑由若干个 $1 \\times 1 \\times 1$ 的立方体搭建而成（也就是所有建筑的底部都在同一平面上的）。几个典型的城市模型如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2fxam89n.png)\n\n现在给出每个网格上建筑的高度，即每个网格上建筑由多少个立方体搭建而成，要求这个建筑模型的表面积是多少。", "inputFormat": "第 $1$ 行包含 $2$ 个正整数 $n,m$，为城市模型的长与宽。\n\n接下来 $n$ 行，每行 $m$ 个数字字符，描述了网格每个格子高度（可见所有建筑高度都大于等于 $0$ 且小于等于 $9$）。", "outputFormat": "一个非负整数，为城市模型的表面积。\n", "hint": "- $20\\%$的数据满足：$n, m \\leq 10$；\n- $40\\%$的数据满足：$n, m \\leq 100$；\n- $100\\%$的数据满足：$1 \\leq n, m \\leq 1000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "3D Model", "background": "", "description": "A city is built on a regular $n \\times m$ grid, where each cell is a $1 \\times 1$ square. Each cell may contain a building, which is constructed from some number of $1 \\times 1 \\times 1$ cubes (that is, all building bases lie on the same plane). Several typical city models are shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2fxam89n.png)\n\nNow the height of the building on each grid cell is given, i.e., how many cubes are stacked on that cell. Determine the surface area of this city model.", "inputFormat": "The first line contains 2 positive integers $n, m$, the length and width of the city model.\n\nThen follow $n$ lines, each containing $m$ digit characters, describing the height of each cell (all building heights are greater than or equal to $0$ and less than or equal to $9$).", "outputFormat": "A non-negative integer: the surface area of the city model.", "hint": "- 20% of the testdata satisfy: $n, m \\leq 10$;\n- 40% of the testdata satisfy: $n, m \\leq 100$;\n- 100% of the testdata satisfy: $1 \\leq n, m \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "3D模型", "background": "", "description": "一座城市建立在规则的 $n \\times m$ 网格上，并且网格均由 $1 \\times 1$ 正方形构成。在每个网格上都可以有一个建筑，建筑由若干个 $1 \\times 1 \\times 1$ 的立方体搭建而成（也就是所有建筑的底部都在同一平面上的）。几个典型的城市模型如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2fxam89n.png)\n\n现在给出每个网格上建筑的高度，即每个网格上建筑由多少个立方体搭建而成，要求这个建筑模型的表面积是多少。", "inputFormat": "第 $1$ 行包含 $2$ 个正整数 $n,m$，为城市模型的长与宽。\n\n接下来 $n$ 行，每行 $m$ 个数字字符，描述了网格每个格子高度（可见所有建筑高度都大于等于 $0$ 且小于等于 $9$）。", "outputFormat": "一个非负整数，为城市模型的表面积。\n", "hint": "- $20\\%$的数据满足：$n, m \\leq 10$；\n- $40\\%$的数据满足：$n, m \\leq 100$；\n- $100\\%$的数据满足：$1 \\leq n, m \\leq 1000$。\n", "locale": "zh-CN"}}}
{"pid": "P1188", "type": "P", "difficulty": 3, "samples": [["13 3\n6 12 1\n2 9 0\n10 13 8\n", "6\n7\n8\n9\n10\n11\n12\n2\n3\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "PASTE", "background": "", "description": "我们用文本处理器来处理一个特殊的文本文件，该文本文件共有 $N$ 行文本，每一行文本仅包含一个自然数，第一行为 $1$、第二行为 $2$，以此类推至 $N$ 行为自然数 $N$。\n\n假设对该文本文件执行一次“剪切和粘贴”操作含义如下：首先选定连续的若干行文本，“剪切”操作将选定的文本从文件中剪下，而“粘贴”操作将剪切下来的文本插入到文件中的其他地方。\n\n编写一个程序求出在进行了连续若干次“剪切和粘贴”操作后，文本文件中前十行的内容。\n", "inputFormat": "第一行包含两个用空格隔开的自然数 $N$ 和 $K$，$N$ 表示文件的总行数 $(10≤N≤100,000)$，$K$ 表示“剪切和粘贴”的总次数$(1≤k≤1000)$。\n\n下面$K$行每一行包含一次“剪切和粘贴”操作的执行信息，每行包含三个用空格隔开自然数 $A,B,C$，其中 $1≤A≤B≤N,0≤C≤N-(B-A+1)$。$A$ 和 $B$ 表示选定文本的第一行和最后一行，$C$ 表示被剪切下来的文本待插入处的前一行，如果 $C$ 等于 $0$ 则被剪切下来的的文本将被插入到文件的开头。\n", "outputFormat": "由十行组成，其中包含所有的操作都完成后的文本文件中前十行所包含的数字。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "PASTE", "background": "", "description": "We use a text processor to handle a special text file with $N$ lines. Each line contains exactly one natural number: the first line is $1$, the second line is $2$, and so on, up to line $N$ which is the natural number $N$.\n\nA single \"cut and paste\" operation is defined as follows: first choose a consecutive block of lines. The \"cut\" operation removes the selected lines from the file, and the \"paste\" operation inserts the removed block into another position in the file.\n\nWrite a program to determine the contents of the first ten lines of the text file after performing several \"cut and paste\" operations in sequence.", "inputFormat": "The first line contains two natural numbers $N$ and $K$, where $N$ is the total number of lines in the file $(10 \\le N \\le 100{,}000)$, and $K$ is the total number of \"cut and paste\" operations $(1 \\le K \\le 1000)$.\n\nEach of the next $K$ lines describes one \"cut and paste\" operation with three space-separated natural numbers $A, B, C$, where $1 \\le A \\le B \\le N$, $0 \\le C \\le N - (B - A + 1)$. $A$ and $B$ are the first and last line numbers of the selected block. $C$ is the line number immediately preceding the insertion position of the cut block; if $C = 0$, the block is inserted at the beginning of the file.", "outputFormat": "Output ten lines, which are the numbers contained in the first ten lines of the text file after all operations have been completed.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "PASTE", "background": "", "description": "我们用文本处理器来处理一个特殊的文本文件，该文本文件共有 $N$ 行文本，每一行文本仅包含一个自然数，第一行为 $1$、第二行为 $2$，以此类推至 $N$ 行为自然数 $N$。\n\n假设对该文本文件执行一次“剪切和粘贴”操作含义如下：首先选定连续的若干行文本，“剪切”操作将选定的文本从文件中剪下，而“粘贴”操作将剪切下来的文本插入到文件中的其他地方。\n\n编写一个程序求出在进行了连续若干次“剪切和粘贴”操作后，文本文件中前十行的内容。\n", "inputFormat": "第一行包含两个用空格隔开的自然数 $N$ 和 $K$，$N$ 表示文件的总行数 $(10≤N≤100,000)$，$K$ 表示“剪切和粘贴”的总次数$(1≤k≤1000)$。\n\n下面$K$行每一行包含一次“剪切和粘贴”操作的执行信息，每行包含三个用空格隔开自然数 $A,B,C$，其中 $1≤A≤B≤N,0≤C≤N-(B-A+1)$。$A$ 和 $B$ 表示选定文本的第一行和最后一行，$C$ 表示被剪切下来的文本待插入处的前一行，如果 $C$ 等于 $0$ 则被剪切下来的的文本将被插入到文件的开头。\n", "outputFormat": "由十行组成，其中包含所有的操作都完成后的文本文件中前十行所包含的数字。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1189", "type": "P", "difficulty": 3, "samples": [["4 5\n.....\n.X...\n...*X\nX.X..\n3\nNORTH\nWEST\nSOUTH", ".....\n*X*..\n*.*.X\nX.X..\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "广度优先搜索 BFS", "深度优先搜索 DFS", "记忆化搜索", "迭代加深搜索"], "title": "SEARCH", "background": "", "description": "年轻的拉尔夫开玩笑地从一个小镇上偷走了一辆车，但他没想到的是那辆车属于警察局，并且车上装有用于发射车子移动路线的装置。\n\n那个装置太旧了，以至于只能发射关于那辆车的移动路线的方向信息。\n\n编写程序，通过使用一张小镇的地图帮助警察局找到那辆车。程序必须能表示出该车最终所有可能的位置。\n\n小镇的地图是矩形的，上面的符号用来标明哪儿可以行车哪儿不行。$\\verb!.!$ 表示小镇上那块地方是可以行车的，而符号 $\\verb!X!$ 表示此处不能行车。拉尔夫所开小车的初始位置用字符的 $\\verb!*!$ 表示，且汽车能从初始位置通过。\n\n汽车能向四个方向移动：向北（向上），向南（向下），向西（向左），向东（向右）。\n\n拉尔夫所开小车的行动路线是通过一组给定的方向来描述的。在每个给定的方向，拉尔夫驾驶小车通过小镇上一个或更多的可行车地点。\n", "inputFormat": "输入文件的第一行包含两个用空格隔开的自然数 $R$ 和 $C$，$1\\le R\\le 50$，$1\\le C\\le 50$，分别表示小镇地图中的行数和列数。\n\n以下的 $R$ 行中每行都包含一组 $C$ 个符号（$\\verb!.!$ 或 $\\verb!X!$ 或 $\\verb!*!$）用来描述地图上相应的部位。\n\n接下来的第 $R+2$ 行包含一个自然数 $N$，$1\\le N\\le 1000$，表示一组方向的长度。\n\n接下来的 $N$ 行幅行包含下述单词中的任一个：`NORTH`（北）、`SOUTH`（南）、`WEST`（西）和 `EAST`（东），表示汽车移动的方向，任何两个连续的方向都不相同。\n", "outputFormat": "用 $R$ 行表示的小镇的地图（像输入文件中一样），字符 $\\verb!*!$ 应该仅用来表示汽车最终可能出现的位置。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "SEARCH", "background": "", "description": "Young Ralph jokingly stole a car from a small town, but he did not expect that the car belonged to the police department and that it was equipped with a device that broadcasts the car’s movement route.\n\nThe device is so old that it can only broadcast the directions of the car’s movement.\n\nWrite a program to help the police department find the car using a map of the town. The program must indicate all possible final positions of the car.\n\nThe town map is rectangular, and symbols mark where driving is allowed or not. $\\verb!.!$ denotes a drivable cell in the town, while $\\verb!X!$ denotes a non-drivable cell. The car’s initial position is marked with the character $\\verb!*!$, and that cell is drivable.\n\nThe car can move in four directions: north (up), south (down), west (left), and east (right).\n\nThe car’s route is described by a given sequence of directions. For each given direction, Ralph drives the car through one or more drivable cells of the town.", "inputFormat": "The first line of the input file contains two natural numbers $R$ and $C$, $1 \\le R \\le 50$, $1 \\le C \\le 50$, representing the number of rows and columns of the town map, respectively.\n\nEach of the next $R$ lines contains a sequence of $C$ symbols ($\\verb!.!$ or $\\verb!X!$ or $\\verb!*!$) describing the corresponding part of the map.\n\nThe $(R+2)$-th line contains a natural number $N$, $1 \\le N \\le 1000$, representing the length of the sequence of directions.\n\nEach of the next $N$ lines contains one of the following words: `NORTH` (north), `SOUTH` (south), `WEST` (west), and `EAST` (east), indicating the direction of movement. Any two consecutive directions are different.", "outputFormat": "Output the town map in $R$ lines (as in the input file). The character $\\verb!*!$ should be used only to denote the car’s possible final positions.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "SEARCH", "background": "", "description": "年轻的拉尔夫开玩笑地从一个小镇上偷走了一辆车，但他没想到的是那辆车属于警察局，并且车上装有用于发射车子移动路线的装置。\n\n那个装置太旧了，以至于只能发射关于那辆车的移动路线的方向信息。\n\n编写程序，通过使用一张小镇的地图帮助警察局找到那辆车。程序必须能表示出该车最终所有可能的位置。\n\n小镇的地图是矩形的，上面的符号用来标明哪儿可以行车哪儿不行。$\\verb!.!$ 表示小镇上那块地方是可以行车的，而符号 $\\verb!X!$ 表示此处不能行车。拉尔夫所开小车的初始位置用字符的 $\\verb!*!$ 表示，且汽车能从初始位置通过。\n\n汽车能向四个方向移动：向北（向上），向南（向下），向西（向左），向东（向右）。\n\n拉尔夫所开小车的行动路线是通过一组给定的方向来描述的。在每个给定的方向，拉尔夫驾驶小车通过小镇上一个或更多的可行车地点。\n", "inputFormat": "输入文件的第一行包含两个用空格隔开的自然数 $R$ 和 $C$，$1\\le R\\le 50$，$1\\le C\\le 50$，分别表示小镇地图中的行数和列数。\n\n以下的 $R$ 行中每行都包含一组 $C$ 个符号（$\\verb!.!$ 或 $\\verb!X!$ 或 $\\verb!*!$）用来描述地图上相应的部位。\n\n接下来的第 $R+2$ 行包含一个自然数 $N$，$1\\le N\\le 1000$，表示一组方向的长度。\n\n接下来的 $N$ 行幅行包含下述单词中的任一个：`NORTH`（北）、`SOUTH`（南）、`WEST`（西）和 `EAST`（东），表示汽车移动的方向，任何两个连续的方向都不相同。\n", "outputFormat": "用 $R$ 行表示的小镇的地图（像输入文件中一样），字符 $\\verb!*!$ 应该仅用来表示汽车最终可能出现的位置。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1190", "type": "P", "difficulty": 2, "samples": [["5 3\n4 4 1 2 1\n", "4"], ["8 4\n23 71 87 32 70 93 80 76\n", "163"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "贪心", "2010", "NOIP 普及组"], "title": "[NOIP 2010 普及组] 接水问题", "background": "", "description": "学校里有一个水房，水房里一共装有 $m$ 个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为 $1$。\n\n现在有 $n$ 名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从 $1$ 到 $n$ 编号，$i$ 号同学的接水量为 $w_i$。接水开始时，$1$ 到 $m$ 号同学各占一个水龙头，并同时打开水龙头接水。当其中某名同学 $j$ 完成其接水量要求 $w_j$ 后，下一名排队等候接水的同学 $k$ 马上接替 $j$ 同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即 $j$ 同学第 $x$ 秒结束时完成接水，则 $k$ 同学第 $x+1$ 秒立刻开始接水。若当前接水人数 $n'$ 不足 $m$，则只有 $n'$ 个龙头供水，其它 $m - n'$ 个龙头关闭。\n\n现在给出 $n$ 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。\n", "inputFormat": "第一行两个整数 $n$ 和 $m$，用一个空格隔开，分别表示接水人数和龙头个数。\n\n第二行 $n$ 个整数 $w_1,w_2,\\ldots,w_n$，每两个整数之间用一个空格隔开，$w_i$ 表示 $i$ 号同学的接水量。", "outputFormat": "一个整数，表示接水所需的总时间。\n", "hint": "【输入输出样例 \\#1 说明】\n\n第 $1$ 秒，$3$ 人接水。第 $1$ 秒结束时，$1,2,3$ 号同学每人的已接水量为 $1,3$ 号同学接完水，$4$ 号同学接替 $3$ 号同学开始接水。\n\n第 $2$ 秒，$3$ 人接水。第 $2$ 秒结束时，$1,2$ 号同学每人的已接水量为 $2,4$ 号同学的已接水量为 $1$。\n\n第 $3$ 秒，$3$ 人接水。第 $3$ 秒结束时，$1,2$ 号同学每人的已接水量为 $3,4$ 号同学的已接水量为 $2$。$4$ 号同学接完水，$5$ 号同学接替 $4$ 号同学开始接水。\n\n第 $4$ 秒，$3$ 人接水。第 $4$ 秒结束时，$1,2$ 号同学每人的已接水量为 $4,5$ 号同学的已接水量为 $1$。$1,2,5$ 号同学接完水，即所有人完成接水的总接水时间为 $4$ 秒。\n\n【数据范围】\n\n$1 \\le n \\le {10}^4$，$1 \\le m \\le 100$，$m \\le n$；\n\n$1 \\le w_i \\le 100$。\n\nNOIP2010 普及组 第二题\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2010 Junior] Fetching Water Problem", "background": "", "description": "There is a water room in the school with a total of $m$ faucets that students can use. Each faucet supplies water at an equal rate of $1$ unit per second.\n\nNow $n$ students are preparing to fetch water, and their initial order is fixed. Number the students from $1$ to $n$ according to this order, and let the required amount for student $i$ be $w_i$. At the start, students $1$ through $m$ each occupy one faucet and start fetching water simultaneously. When some student $j$ finishes their required amount $w_j$, the next student $k$ in the queue immediately takes $j$’s place and starts fetching water. This handover is instantaneous, and no water is wasted. Specifically, if student $j$ finishes at the end of second $x$, then student $k$ starts at second $x+1$. If the current number of students fetching water is $n' < m$, then only $n'$ faucets supply water, and the remaining $m - n'$ faucets are closed.\n\nGiven the required amounts for the $n$ students and following the rules above, determine how many seconds it takes for all students to finish fetching water.", "inputFormat": "The first line contains two integers $n$ and $m$, separated by a space, representing the number of students and the number of faucets.\n\nThe second line contains $n$ integers $w_1,w_2,\\ldots,w_n$, separated by single spaces, where $w_i$ is the required amount for student $i$.", "outputFormat": "Output a single integer representing the total time required.", "hint": "[Sample I/O #1 Explanation]\n\nIn the 1st second, 3 students are fetching water. At the end of the 1st second, students 1, 2, and 3 have each fetched 1 unit. Student 3 finishes, and student 4 takes student 3’s place to start fetching water.\n\nIn the 2nd second, 3 students are fetching water. At the end of the 2nd second, students 1 and 2 have each fetched 2 units, and student 4 has fetched 1 unit.\n\nIn the 3rd second, 3 students are fetching water. At the end of the 3rd second, students 1 and 2 have each fetched 3 units, and student 4 has fetched 2 units. Student 4 finishes, and student 5 takes student 4’s place to start fetching water.\n\nIn the 4th second, 3 students are fetching water. At the end of the 4th second, students 1 and 2 have each fetched 4 units, and student 5 has fetched 1 unit. Students 1, 2, and 5 finish, so the total time for everyone to finish is 4 seconds.\n\nConstraints\n\n$1 \\le n \\le 10^4$, $1 \\le m \\le 100$, $m \\le n$;\n\n$1 \\le w_i \\le 100$.\n\nNOIP 2010 Junior Problem 2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2010 普及组] 接水问题", "background": "", "description": "学校里有一个水房，水房里一共装有 $m$ 个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为 $1$。\n\n现在有 $n$ 名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从 $1$ 到 $n$ 编号，$i$ 号同学的接水量为 $w_i$。接水开始时，$1$ 到 $m$ 号同学各占一个水龙头，并同时打开水龙头接水。当其中某名同学 $j$ 完成其接水量要求 $w_j$ 后，下一名排队等候接水的同学 $k$ 马上接替 $j$ 同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即 $j$ 同学第 $x$ 秒结束时完成接水，则 $k$ 同学第 $x+1$ 秒立刻开始接水。若当前接水人数 $n'$ 不足 $m$，则只有 $n'$ 个龙头供水，其它 $m - n'$ 个龙头关闭。\n\n现在给出 $n$ 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。\n", "inputFormat": "第一行两个整数 $n$ 和 $m$，用一个空格隔开，分别表示接水人数和龙头个数。\n\n第二行 $n$ 个整数 $w_1,w_2,\\ldots,w_n$，每两个整数之间用一个空格隔开，$w_i$ 表示 $i$ 号同学的接水量。", "outputFormat": "一个整数，表示接水所需的总时间。\n", "hint": "【输入输出样例 \\#1 说明】\n\n第 $1$ 秒，$3$ 人接水。第 $1$ 秒结束时，$1,2,3$ 号同学每人的已接水量为 $1,3$ 号同学接完水，$4$ 号同学接替 $3$ 号同学开始接水。\n\n第 $2$ 秒，$3$ 人接水。第 $2$ 秒结束时，$1,2$ 号同学每人的已接水量为 $2,4$ 号同学的已接水量为 $1$。\n\n第 $3$ 秒，$3$ 人接水。第 $3$ 秒结束时，$1,2$ 号同学每人的已接水量为 $3,4$ 号同学的已接水量为 $2$。$4$ 号同学接完水，$5$ 号同学接替 $4$ 号同学开始接水。\n\n第 $4$ 秒，$3$ 人接水。第 $4$ 秒结束时，$1,2$ 号同学每人的已接水量为 $4,5$ 号同学的已接水量为 $1$。$1,2,5$ 号同学接完水，即所有人完成接水的总接水时间为 $4$ 秒。\n\n【数据范围】\n\n$1 \\le n \\le {10}^4$，$1 \\le m \\le 100$，$m \\le n$；\n\n$1 \\le w_i \\le 100$。\n\nNOIP2010 普及组 第二题\n", "locale": "zh-CN"}}}
{"pid": "P1191", "type": "P", "difficulty": 3, "samples": [["4\nWWBW\nBBWB\nWBWW\nWBWB", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "枚举"], "title": "矩形", "background": "", "description": "给出一个 $n \\times n$ 的矩阵，矩阵中，有些格子被染成白色，有些格子被染成黑色，现要求矩阵中白色**矩形**的数量。", "inputFormat": "第一行，一个整数 $n$，表示矩形的大小。\n\n接下来 $n$ 行，每行 $n$ 个字符，这些字符为 $\\verb!W!$ 或 $\\verb!B!$。其中 $\\verb!W!$ 表示白格，$\\verb!B!$ 表示黑格。\n", "outputFormat": "一个正整数，为白色矩形数量。\n", "hint": "对于$30\\%$的数据，$n ≤ 50$；\n\n对于$100\\%$的数据，$n ≤ 150$；\n", "locale": "zh-CN", "translations": {"en": {"title": "Rectangle", "background": "", "description": "You are given an $n \\times n$ matrix. In the matrix, some cells are colored white and some are colored black. Find the number of white rectangles in the matrix.", "inputFormat": "The first line contains an integer $n$, denoting the size of the matrix.\nThen follow $n$ lines, each containing $n$ characters. Each character is $\\verb!W!$ or $\\verb!B!$. Here, $\\verb!W!$ denotes a white cell, and $\\verb!B!$ denotes a black cell.", "outputFormat": "Output a single positive integer: the number of white rectangles.", "hint": "For $30\\%$ of the testdata, $n ≤ 50$.\nFor $100\\%$ of the testdata, $n ≤ 150$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "矩形", "background": "", "description": "给出一个 $n \\times n$ 的矩阵，矩阵中，有些格子被染成白色，有些格子被染成黑色，现要求矩阵中白色**矩形**的数量。", "inputFormat": "第一行，一个整数 $n$，表示矩形的大小。\n\n接下来 $n$ 行，每行 $n$ 个字符，这些字符为 $\\verb!W!$ 或 $\\verb!B!$。其中 $\\verb!W!$ 表示白格，$\\verb!B!$ 表示黑格。\n", "outputFormat": "一个正整数，为白色矩形数量。\n", "hint": "对于$30\\%$的数据，$n ≤ 50$；\n\n对于$100\\%$的数据，$n ≤ 150$；\n", "locale": "zh-CN"}}}
{"pid": "P1192", "type": "P", "difficulty": 2, "samples": [["5 2", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "Fibonacci 数列", "线性递推"], "title": "台阶问题", "background": "", "description": "有 $N$ 级台阶，你一开始在底部，每次可以向上迈 $1\\sim K$ 级台阶，问到达第 $N$ 级台阶有多少种不同方式。", "inputFormat": "两个正整数 $N,K$。", "outputFormat": "一个正整数 $ans\\pmod{100003}$，为到达第 $N$ 级台阶的不同方式数。", "hint": "- 对于 $20\\%$ 的数据，$1\\leq N\\leq10$，$1\\leq K\\leq3$；\n- 对于 $40\\%$ 的数据，$1\\leq N\\leq1000$；\n- 对于 $100\\%$ 的数据，$1\\leq N\\leq100000$，$1\\leq K\\leq100$。", "locale": "zh-CN", "translations": {"en": {"title": "Staircase Problem", "background": "", "description": "There are $N$ steps. You start at the bottom, and each time you can climb $1\\sim K$ steps upward. How many different ways are there to reach the $N$-th step?", "inputFormat": "Two positive integers $N,K$.", "outputFormat": "A single positive integer $ans\\pmod{100003}$, the number of different ways to reach the $N$-th step.", "hint": "- For $20\\%$ of the testdata, $1\\leq N\\leq10$, $1\\leq K\\leq3$.\n- For $40\\%$ of the testdata, $1\\leq N\\leq1000$.\n- For $100\\%$ of the testdata, $1\\leq N\\leq100000$, $1\\leq K\\leq100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "台阶问题", "background": "", "description": "有 $N$ 级台阶，你一开始在底部，每次可以向上迈 $1\\sim K$ 级台阶，问到达第 $N$ 级台阶有多少种不同方式。", "inputFormat": "两个正整数 $N,K$。", "outputFormat": "一个正整数 $ans\\pmod{100003}$，为到达第 $N$ 级台阶的不同方式数。", "hint": "- 对于 $20\\%$ 的数据，$1\\leq N\\leq10$，$1\\leq K\\leq3$；\n- 对于 $40\\%$ 的数据，$1\\leq N\\leq1000$；\n- 对于 $100\\%$ 的数据，$1\\leq N\\leq100000$，$1\\leq K\\leq100$。", "locale": "zh-CN"}}}
{"pid": "P1193", "type": "P", "difficulty": 3, "samples": [["4 4\n501 502 503 504\n2 3 5 7\n50 30 10 5 93 50 1\n10\n501 2 10\n501 2 80\n501 2 70\n502 3 0\n502 3 0\n504 5 100\n503 7 0\n503 7 0\n503 7 0\n503 7 10\n", "480\n372\nUse Luogu!\n"], ["2 3\n101 102\n1 2 3\n70 60 50 1 80 100 0\n6\n101 1 100\n101 2 100\n101 3 100\n102 1 100\n102 2 100\n102 3 100\n", "500\n650\nForget it...\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "洛谷原创", "洛谷月赛"], "title": "洛谷团队训练 VS 传统团队训练", "background": "“在中学的信息学教育领域，[洛谷](/)无疑是一个相当受欢迎的辅助网站。同时有百余所学校正在通过洛谷进行信息学竞赛（以后简称 OI）的教育。洛谷之所以如此受欢迎，是因为洛谷创新的将 OI 教育的几乎每一个环节都搬到了线上，无论是学校的竞赛教练还是学生，均可以仅仅使用这一个网站来进行练习，提升自己的能力。”\n\n\n——摘自《厦门中小学教育科学研究》，2015 年 2 月号。", "description": "XX 中学的两位信息组的教练正在为学校信息组是否应当将洛谷作为主要的训练工具而争论不休，最后决定采取一个量化的办法来决定是否迁移。\n\n该中学的原来训练方法是，在机房的教师机里面用 cena 装载好测试数据，装载数据所需要 $T_a$ 时间，每一道题目都要装载。学生写好代码后，可以跑到教师机上收取程序并进行评测。但由于需要往返的路程，因此每跑一次就要浪费 $T_b$ 时间。所以也允许学生在自己的机子上装载好测试数据，可以根据自己的需要选择装载的题目，这需要花费和在教师机装载数据一样的时间 $T_a$，但是每次评测花费的时间就减少为 $T_c$。此外，该中学可能会用 Excel 记录各位同学的训练情况，如果某位同学的某道题的得分高于表格里的记录，那就会花费 $T_d$ 时间将这个成绩更新，否则就不必费那个事了，如果之前没有提交过这道题视为表格记录的程序为 $0$ 分。\n\n而在洛谷中，只需要将题目和测试数据上传到洛谷，花费 $T_a$ 时间。每次评测学生只需花费 $T_c$ 时间即可。记录成绩？那是洛谷的事儿，一提交完就帮你整理好了表格根本不费时间。\n\n看起来可以省下不少时间吧。。然而，支持传统训练方法的教练认为，洛谷并非 $100 \\%$ 的稳定，在有的情况会无法提供服务，因此首先要将洛谷的耗时除以它的可用度（一个小于 $100\\%$ 的数字 $A\\%$）并去掉小数点。又因为传统观念不易纠正，总是有不信任将题目数据交给洛谷这样的想法（kkksc03：怪我咯？），因此使用洛谷的耗时还要再加上一个罚时 $H$ 以做公平比较。\n\n现在给出该中学的训练情况，希望你帮两位教练分析一下到底该如何选择。", "inputFormat": "第一行，两个整数 $N, M$，代表题目数量与学生数量。\n\n第二行，$N$ 个整数 $P_1, P_2, \\ldots, P_N$，为涉及的题目编号。\n\n第三行，$M$ 个整数 $S_1, S_2, \\ldots, S_M$，为学生的学号。\n\n第四行，七个整数 $T_a, T_b, T_c, T_d, A, H, E$，前六个数字的意义见题目描述，$E$ 如果是 $1$ 那么在 Excel 中记录成绩，如果是 $0$ 则不记录。\n\n第五行，一个整数 $R$，代表评测数量。\n\n接下来 $R$ 行，评测记录，每行是 $\\mathit{Pr}_i, \\mathit{Sr}_i, \\mathit{Sc}_i$，分别为该次评测的题目号、学号以及成绩。", "outputFormat": "三行。\n\n第一行为传统方法的的耗时。\n\n第二行为使用洛谷包括罚时在内的耗时。\n\n第三行是结论，如果使用洛谷的时间小于传统方法的时间，那么输出 `Use Luogu!`。否则输出 `Forget it...`。", "hint": "**【样例解释 #1】**\n\n使用传统方法的话，装载 $4$ 道题目需要 $4 \\times 50=200$，$2$ 号同学和 $7$ 号同学使用教师机所需要的时间分别为 $30 \\times 3=90$、$30 \\times 4 = 120$，但是明显自己装载 cena 只需要 $50+10 \\times 3=80$、$50+10 \\times 4=90$ 更优。而 $3,5$ 同学则使用教师机就好，耗时 $60,30$。$2$ 号同学的前两次评测单调递增，所以额外花费 $2 \\times 5=10$ 时间记录，$3$ 号同学太弱了都是 $0$ 分所以没必要记录了，$5$ 与 $7$ 各耗费 $5$ 时间。所以这种情况总时间耗时为 $200+80+90+60+30+10+5+5=480$。\n\n使用洛谷的话，装载题目耗费 $200$，$10$ 次评测共耗费 $10 \\times10=100$，考虑稳定性时间为 $(200+100) / 93\\% = 322$，所以最后总耗时为 $322+50=372$，所以决定使用洛谷。\n\n**【数据范围】**\n\n其中 $50\\%$ 数据中，不需要进行成绩的 Excel 记录。\n\n其中 $50\\%$ 数据中，题目编号和学号均大于等于 $0$，小于等于 $1000$。\n\n（这两种情况，可能会重叠）\n\n对于 $100\\%$ 的数据，保证 $1 \\le n,m \\le 1000$，$1 \\le T_a, T_b, T_c,T_d,H \\le 10000$，$1 \\le R < 100000$，$0 \\le \\mathit{Sc}_i \\le 100$，$1 \\le A \\le 100$，学号和题目号在 ${10}^8$ 之内。\n\n实际上，根据超级监控颁发的证书，洛谷 2015 年第一季度可靠性（SLA）为 $99.36 \\%$。同时观念也是可以改变的。\n\n洛谷的优点很多都是不能量化的，其精华在于社区。和全国的 OIer 一起学习交流，不很好吗？\n\n最后插一句，去年的【榨取 kkksc03】的布告依然有效，详情。", "locale": "zh-CN", "translations": {"en": {"title": "Luogu Team Training vs Traditional Team Training", "background": "“In the field of secondary-school informatics education, [Luogu](/) is undoubtedly a very popular auxiliary website. At the same time, more than one hundred schools are using Luogu for informatics competitions (hereafter referred to as OI). The reason Luogu is so popular is that it innovatively moves almost every step of OI education online. Both school coaches and students can use this one website to practice and improve their skills.”\n\n— From “Xiamen Primary and Secondary Education Science Research,” February 2015 issue.", "description": "Two coaches of the informatics group at XX Middle School are debating whether the school’s informatics group should adopt Luogu as the primary training tool. They decide to use a quantitative approach to decide whether to switch.\n\nThe school’s original training method is as follows: on the teacher’s machine in the computer room, use cena to load the testdata. Loading the data takes time $T_a$, and this must be done for each problem. After a student finishes writing code, they can go to the teacher’s machine to submit and evaluate the program. However, because of the round trip, each evaluation incurs a waste of time $T_b$. Therefore, students are also allowed to load the testdata on their own machines, and they can choose which problems to load as needed. This takes the same time $T_a$ as loading on the teacher’s machine, but the time spent per evaluation is reduced to $T_c$. In addition, the school may use Excel to record each student’s training progress. If a student’s score on a problem is higher than the score recorded in the sheet, it will take time $T_d$ to update that record; otherwise no time is spent. If the student has not previously submitted that problem, the recorded score is considered to be $0$.\n\nWith Luogu, you only need to upload the problems and testdata to Luogu, taking time $T_a$. Each evaluation then takes only time $T_c$. Recording scores? That’s Luogu’s job—once a submission is completed, the platform organizes the table for you, taking no time.\n\nIt seems this could save quite a bit of time... However, the coach who supports the traditional method argues that Luogu is not $100 \\%$ stable and may be unavailable in some cases. Therefore, first divide Luogu’s total time by its availability (a number less than $100 \\%$, denoted $A\\%$) and remove the fractional part. Furthermore, because traditional perceptions are hard to change and there is always distrust in handing problem data to Luogu (kkksc03: “Blame me?”), add a penalty time $H$ to Luogu’s total for a fair comparison.\n\nGiven the school’s training scenario, please help the two coaches analyze which choice to make.", "inputFormat": "- The first line contains two integers $N, M$, the number of problems and the number of students.\n- The second line contains $N$ integers $P_1, P_2, \\ldots, P_N$, the problem IDs involved.\n- The third line contains $M$ integers $S_1, S_2, \\ldots, S_M$, the student IDs.\n- The fourth line contains seven integers $T_a, T_b, T_c, T_d, A, H, E$. The meanings of the first six numbers are as described above. If $E$ is $1$, scores are recorded in Excel; if $E$ is $0$, they are not recorded.\n- The fifth line contains a single integer $R$, the number of evaluations.\n- The next $R$ lines each contain an evaluation record, with $\\mathit{Pr}_i, \\mathit{Sr}_i, \\mathit{Sc}_i$ denoting the problem ID, the student ID, and the score for that evaluation, respectively.", "outputFormat": "Output three lines.\n\n- The first line is the total time for the traditional method.\n- The second line is the total time for using Luogu, including the penalty time.\n- The third line is the conclusion. If the time using Luogu is less than the time for the traditional method, output `Use Luogu!`. Otherwise, output `Forget it...`.", "hint": "【Sample Explanation #1】\n\nUsing the traditional method, loading $4$ problems takes $4 \\times 50 = 200$. For students No. $2$ and No. $7$, the times to use the teacher’s machine are $30 \\times 3 = 90$ and $30 \\times 4 = 120$, respectively. However, clearly loading cena locally costs only $50 + 10 \\times 3 = 80$ and $50 + 10 \\times 4 = 90$, which are better. Students No. $3$ and No. $5$ should just use the teacher’s machine, costing $60$ and $30$. Student No. $2$’s first two evaluations are strictly increasing, so recording takes an extra $2 \\times 5 = 10$ time. Student No. $3$ is too weak and always gets $0$, so no need to record. Students No. $5$ and No. $7$ each incur $5$. Therefore, the total time is $200 + 80 + 90 + 60 + 30 + 10 + 5 + 5 = 480$.\n\nUsing Luogu, uploading the problems takes $200$. The $10$ evaluations cost $10 \\times 10 = 100$. Considering availability, the time is $$(200+100) / 93\\% = 322,$$ so the final total time is $322 + 50 = 372$. Therefore, choose Luogu.\n\nConstraints\n\n- In $50\\%$ of the testdata, Excel score recording is not required.\n- In $50\\%$ of the testdata, both problem IDs and student IDs are between $0$ and $1000$, inclusive.\n  (These two cases may overlap.)\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\le N, M \\le 1000$, $1 \\le T_a, T_b, T_c, T_d, H \\le 10000$, $1 \\le R < 100000$, $0 \\le \\mathit{Sc}_i \\le 100$, $1 \\le A \\le 100$, and student IDs and problem IDs are less than $10^8$.\n\nIn fact, according to the certificate issued by Supervision, Luogu’s reliability (SLA) for Q1 2015 was $99.36 \\%$. Also, perceptions can be changed.\n\nMany of Luogu’s advantages are not quantifiable. Its essence lies in the community. Isn’t it great to learn and communicate with OIers nationwide?\n\nOne last note: last year’s “[Squeeze kkksc03]” notice is still valid; see details.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "洛谷团队训练 VS 传统团队训练", "background": "“在中学的信息学教育领域，[洛谷](/)无疑是一个相当受欢迎的辅助网站。同时有百余所学校正在通过洛谷进行信息学竞赛（以后简称 OI）的教育。洛谷之所以如此受欢迎，是因为洛谷创新的将 OI 教育的几乎每一个环节都搬到了线上，无论是学校的竞赛教练还是学生，均可以仅仅使用这一个网站来进行练习，提升自己的能力。”\n\n\n——摘自《厦门中小学教育科学研究》，2015 年 2 月号。", "description": "XX 中学的两位信息组的教练正在为学校信息组是否应当将洛谷作为主要的训练工具而争论不休，最后决定采取一个量化的办法来决定是否迁移。\n\n该中学的原来训练方法是，在机房的教师机里面用 cena 装载好测试数据，装载数据所需要 $T_a$ 时间，每一道题目都要装载。学生写好代码后，可以跑到教师机上收取程序并进行评测。但由于需要往返的路程，因此每跑一次就要浪费 $T_b$ 时间。所以也允许学生在自己的机子上装载好测试数据，可以根据自己的需要选择装载的题目，这需要花费和在教师机装载数据一样的时间 $T_a$，但是每次评测花费的时间就减少为 $T_c$。此外，该中学可能会用 Excel 记录各位同学的训练情况，如果某位同学的某道题的得分高于表格里的记录，那就会花费 $T_d$ 时间将这个成绩更新，否则就不必费那个事了，如果之前没有提交过这道题视为表格记录的程序为 $0$ 分。\n\n而在洛谷中，只需要将题目和测试数据上传到洛谷，花费 $T_a$ 时间。每次评测学生只需花费 $T_c$ 时间即可。记录成绩？那是洛谷的事儿，一提交完就帮你整理好了表格根本不费时间。\n\n看起来可以省下不少时间吧。。然而，支持传统训练方法的教练认为，洛谷并非 $100 \\%$ 的稳定，在有的情况会无法提供服务，因此首先要将洛谷的耗时除以它的可用度（一个小于 $100\\%$ 的数字 $A\\%$）并去掉小数点。又因为传统观念不易纠正，总是有不信任将题目数据交给洛谷这样的想法（kkksc03：怪我咯？），因此使用洛谷的耗时还要再加上一个罚时 $H$ 以做公平比较。\n\n现在给出该中学的训练情况，希望你帮两位教练分析一下到底该如何选择。", "inputFormat": "第一行，两个整数 $N, M$，代表题目数量与学生数量。\n\n第二行，$N$ 个整数 $P_1, P_2, \\ldots, P_N$，为涉及的题目编号。\n\n第三行，$M$ 个整数 $S_1, S_2, \\ldots, S_M$，为学生的学号。\n\n第四行，七个整数 $T_a, T_b, T_c, T_d, A, H, E$，前六个数字的意义见题目描述，$E$ 如果是 $1$ 那么在 Excel 中记录成绩，如果是 $0$ 则不记录。\n\n第五行，一个整数 $R$，代表评测数量。\n\n接下来 $R$ 行，评测记录，每行是 $\\mathit{Pr}_i, \\mathit{Sr}_i, \\mathit{Sc}_i$，分别为该次评测的题目号、学号以及成绩。", "outputFormat": "三行。\n\n第一行为传统方法的的耗时。\n\n第二行为使用洛谷包括罚时在内的耗时。\n\n第三行是结论，如果使用洛谷的时间小于传统方法的时间，那么输出 `Use Luogu!`。否则输出 `Forget it...`。", "hint": "**【样例解释 #1】**\n\n使用传统方法的话，装载 $4$ 道题目需要 $4 \\times 50=200$，$2$ 号同学和 $7$ 号同学使用教师机所需要的时间分别为 $30 \\times 3=90$、$30 \\times 4 = 120$，但是明显自己装载 cena 只需要 $50+10 \\times 3=80$、$50+10 \\times 4=90$ 更优。而 $3,5$ 同学则使用教师机就好，耗时 $60,30$。$2$ 号同学的前两次评测单调递增，所以额外花费 $2 \\times 5=10$ 时间记录，$3$ 号同学太弱了都是 $0$ 分所以没必要记录了，$5$ 与 $7$ 各耗费 $5$ 时间。所以这种情况总时间耗时为 $200+80+90+60+30+10+5+5=480$。\n\n使用洛谷的话，装载题目耗费 $200$，$10$ 次评测共耗费 $10 \\times10=100$，考虑稳定性时间为 $(200+100) / 93\\% = 322$，所以最后总耗时为 $322+50=372$，所以决定使用洛谷。\n\n**【数据范围】**\n\n其中 $50\\%$ 数据中，不需要进行成绩的 Excel 记录。\n\n其中 $50\\%$ 数据中，题目编号和学号均大于等于 $0$，小于等于 $1000$。\n\n（这两种情况，可能会重叠）\n\n对于 $100\\%$ 的数据，保证 $1 \\le n,m \\le 1000$，$1 \\le T_a, T_b, T_c,T_d,H \\le 10000$，$1 \\le R < 100000$，$0 \\le \\mathit{Sc}_i \\le 100$，$1 \\le A \\le 100$，学号和题目号在 ${10}^8$ 之内。\n\n实际上，根据超级监控颁发的证书，洛谷 2015 年第一季度可靠性（SLA）为 $99.36 \\%$。同时观念也是可以改变的。\n\n洛谷的优点很多都是不能量化的，其精华在于社区。和全国的 OIer 一起学习交流，不很好吗？\n\n最后插一句，去年的【榨取 kkksc03】的布告依然有效，详情。", "locale": "zh-CN"}}}
{"pid": "P1194", "type": "P", "difficulty": 3, "samples": [["1 1\n0\n", "1"], ["3 3\n0 2 4\n2 0 2\n4 2 0\n", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["图论", "生成树"], "title": "买礼物", "background": "", "description": "又到了一年一度的明明生日了，明明想要买 $B$ 样东西，巧的是，这 $B$ 样东西价格都是 $A$ 元。\n\n但是，商店老板说最近有促销活动，也就是：\n\n如果你买了第 $I$ 样东西，再买第 $J$ 样，那么就可以只花 $K_{I,J}$ 元，更巧的是，$K_{I,J}$ 竟然等于 $K_{J,I}$。\n\n现在明明想知道，他最少要花多少钱。", "inputFormat": "第一行两个整数，$A,B$。\n\n接下来 $B$ 行，每行 $B$ 个数，第 $I$ 行第 $J$ 个为 $K_{I,J}$。\n\n我们保证 $K_{I,J}=K_{J,I}$ 并且 $K_{I,I}=0$。\n\n特别的，如果 $K_{I,J}=0$，那么表示这两样东西之间不会导致优惠。\n\n注意 $K_{I,J}$ **可能大于** $A$。", "outputFormat": "一个整数，为最小要花的钱数。\n", "hint": "样例解释 $2$。\n\n先买第 $2$ 样东西，花费 $3$ 元，接下来因为优惠，买 $1,3$ 样都只要 $2$ 元，共 $7$ 元。\n\n（同时满足多个“优惠”的时候，聪明的明明当然不会选择用 $4$ 元买剩下那件，而选择用 $2$ 元。）\n\n数据规模\n\n对于 $30\\%$ 的数据，$1\\le B\\le 10$。\n\n对于 $100\\%$ 的数据，$1\\le B\\le500,0\\le A,K_{I,J}\\le1000$。\n\n2018.7.25新添数据一组", "locale": "zh-CN", "translations": {"en": {"title": "Buying Gifts", "background": "", "description": "It is Mingming’s birthday again. Mingming wants to buy $B$ kinds of items, and coincidentally, each of these $B$ items is priced at $A$ yuan.\n\nHowever, the shop owner says there is a promotion:\n\nIf you have bought item $I$, then when you buy item $J$, you only need to pay $K_{I,J}$ yuan. Moreover, $K_{I,J}$ happens to equal $K_{J,I}$.\n\nNow Mingming wants to know the minimum amount of money he has to spend.", "inputFormat": "The first line contains two integers, $A,B$.\n\nThen there are $B$ lines, each containing $B$ numbers. The $I$-th line and $J$-th number is $K_{I,J}$.\n\nWe guarantee $K_{I,J}=K_{J,I}$ and $K_{I,I}=0$.\n\nIn particular, if $K_{I,J}=0$, it means there is no discount between these two items.\n\nNote that $K_{I,J}$ may be greater than $A$.", "outputFormat": "Output a single integer, the minimum total amount of money required.", "hint": "Explanation for Sample $2$.\n\nBuy item $2$ first, spending 3 yuan. Then, due to the promotion, buying items $1$ and $3$ each costs 2 yuan, for a total of 7 yuan.\n\n(When multiple “discounts” apply at the same time, clever Mingming will of course not choose to pay 4 yuan for the remaining one, but choose to pay 2 yuan.)\n\nConstraints\n\nFor $30\\%$ of the testdata, $1\\le B\\le 10$.\n\nFor $100\\%$ of the testdata, $1\\le B\\le500,0\\le A,K_{I,J}\\le1000$.\n\nAdded one more set of testdata on 2018.7.25.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "买礼物", "background": "", "description": "又到了一年一度的明明生日了，明明想要买 $B$ 样东西，巧的是，这 $B$ 样东西价格都是 $A$ 元。\n\n但是，商店老板说最近有促销活动，也就是：\n\n如果你买了第 $I$ 样东西，再买第 $J$ 样，那么就可以只花 $K_{I,J}$ 元，更巧的是，$K_{I,J}$ 竟然等于 $K_{J,I}$。\n\n现在明明想知道，他最少要花多少钱。", "inputFormat": "第一行两个整数，$A,B$。\n\n接下来 $B$ 行，每行 $B$ 个数，第 $I$ 行第 $J$ 个为 $K_{I,J}$。\n\n我们保证 $K_{I,J}=K_{J,I}$ 并且 $K_{I,I}=0$。\n\n特别的，如果 $K_{I,J}=0$，那么表示这两样东西之间不会导致优惠。\n\n注意 $K_{I,J}$ **可能大于** $A$。", "outputFormat": "一个整数，为最小要花的钱数。\n", "hint": "样例解释 $2$。\n\n先买第 $2$ 样东西，花费 $3$ 元，接下来因为优惠，买 $1,3$ 样都只要 $2$ 元，共 $7$ 元。\n\n（同时满足多个“优惠”的时候，聪明的明明当然不会选择用 $4$ 元买剩下那件，而选择用 $2$ 元。）\n\n数据规模\n\n对于 $30\\%$ 的数据，$1\\le B\\le 10$。\n\n对于 $100\\%$ 的数据，$1\\le B\\le500,0\\le A,K_{I,J}\\le1000$。\n\n2018.7.25新添数据一组", "locale": "zh-CN"}}}
{"pid": "P1195", "type": "P", "difficulty": 3, "samples": [["3 1 2\n1 2 1\n", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "并查集", "生成树"], "title": "口袋的天空", "background": "小杉坐在教室里，透过口袋一样的窗户看口袋一样的天空。\n\n有很多云飘在那里，看起来很漂亮，小杉想摘下那样美的几朵云，做成棉花糖。\n", "description": "给你云朵的个数 $N$，再给你 $M$ 个关系，表示哪些云朵可以连在一起。\n\n现在小杉要把所有云朵连成 $K$ 个棉花糖，一个棉花糖最少要用掉一朵云，小杉想知道他怎么连，花费的代价最小。\n", "inputFormat": "第一行有三个数 $N,M,K$。\n\n接下来 $M$ 行每行三个数 $X,Y,L$，表示 $X$ 云和 $Y$ 云可以通过 $L$ 的代价连在一起。\n\n\n", "outputFormat": "对每组数据输出一行，仅有一个整数，表示最小的代价。\n\n如果怎么连都连不出 $K$ 个棉花糖，请输出 `No Answer`。\n", "hint": "对于 $30\\%$ 的数据，$1 \\le N \\le 100$，$1\\le M \\le 10^3$；\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^3$，$1 \\le M \\le 10^4$，$1 \\le K \\le 10$，$1 \\le X,Y \\le N$，$0 \\le L<10^4$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Pocket's Sky", "background": "Xiaoshan sits in the classroom, looking through a pocket-like window at a pocket-like sky. Many clouds are floating there and look beautiful; Xiaoshan wants to pick a few of those lovely clouds and make cotton candy.", "description": "You are given the number of clouds $N$, and then $M$ relations indicating which clouds can be connected.\n\nNow Xiaoshan wants to connect all clouds into exactly $K$ cotton candies (connected components). Each cotton candy must use at least one cloud. He wants to know how to connect them so that the total cost is minimized.", "inputFormat": "The first line contains three integers $N, M, K$.\n\nEach of the next $M$ lines contains three integers $X, Y, L$, meaning cloud $X$ and cloud $Y$ can be connected at a cost of $L$.", "outputFormat": "Output one line containing a single integer, the minimum total cost.\n\nIf it is impossible to obtain exactly $K$ cotton candies, output `No Answer`.", "hint": "Constraints:\n- For $30\\%$ of the testdata, $1 \\le N \\le 100$, $1 \\le M \\le 10^3$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 10^3$, $1 \\le M \\le 10^4$, $1 \\le K \\le 10$, $1 \\le X, Y \\le N$, $0 \\le L < 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "口袋的天空", "background": "小杉坐在教室里，透过口袋一样的窗户看口袋一样的天空。\n\n有很多云飘在那里，看起来很漂亮，小杉想摘下那样美的几朵云，做成棉花糖。\n", "description": "给你云朵的个数 $N$，再给你 $M$ 个关系，表示哪些云朵可以连在一起。\n\n现在小杉要把所有云朵连成 $K$ 个棉花糖，一个棉花糖最少要用掉一朵云，小杉想知道他怎么连，花费的代价最小。\n", "inputFormat": "第一行有三个数 $N,M,K$。\n\n接下来 $M$ 行每行三个数 $X,Y,L$，表示 $X$ 云和 $Y$ 云可以通过 $L$ 的代价连在一起。\n\n\n", "outputFormat": "对每组数据输出一行，仅有一个整数，表示最小的代价。\n\n如果怎么连都连不出 $K$ 个棉花糖，请输出 `No Answer`。\n", "hint": "对于 $30\\%$ 的数据，$1 \\le N \\le 100$，$1\\le M \\le 10^3$；\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^3$，$1 \\le M \\le 10^4$，$1 \\le K \\le 10$，$1 \\le X,Y \\le N$，$0 \\le L<10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P1196", "type": "P", "difficulty": 4, "samples": [["4\nM 2 3\nC 1 2\nM 2 4\nC 4 2", "-1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2002", "并查集", "NOI"], "title": "[NOI2002] 银河英雄传说", "background": "公元 $5801$ 年，地球居民迁至金牛座 $\\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。\n\n宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。", "description": "杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \\ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  \n\n然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。\n\n在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。\n\n作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。\n\n最终的决战已经展开，银河的历史又翻过了一页……", "inputFormat": "第一行有一个整数 $T$（$1 \\le T \\le 5 \\times 10^5$），表示总共有 $T$ 条指令。\n\n以下有 $T$ 行，每行有一条指令。指令有两种格式：\n\n1. `M i j`：$i$ 和 $j$ 是两个整数（$1 \\le i,j \\le 30000$），表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第 $i$ 号战舰与第 $j$ 号战舰不在同一列。\n\n2. `C i j`：$i$ 和 $j$ 是两个整数（$1 \\le i,j \\le 30000$），表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。\n\n每条指令中都保证 $i\\neq j$。", "outputFormat": "依次对输入的每一条指令进行分析和处理：\n\n- 如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息。\n- 如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第 $i$ 号战舰与第 $j$ 号战舰之间布置的战舰数目。如果第 $i$ 号战舰与第 $j$ 号战舰当前不在同一列上，则输出 $-1$。", "hint": "### 样例解释\n\n战舰位置图：表格中阿拉伯数字表示战舰编号。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2002] Legend of the Galactic Heroes", "background": "In the year $5801$ AD, the inhabitants of Earth migrated to the second planet of Taurus $\\alpha$, where they proclaimed the founding of the Galactic Federation. In the same year, the calendar was changed to the Cosmic Era, and expansion toward the depths of the Milky Way began.\n\nIn Cosmic Era $799$, the two major military groups of the galaxy went to war in the Barmilian starfield. The \"Taishan Yading\" Group dispatched fleet commander Reinhard with more than $100{,}000$ warships, while the \"Qitun Shanhe\" Group appointed Yang Wen-li to organize $30{,}000$ warships to meet the enemy.", "description": "Yang Wen-li excels at troop deployment and cleverly uses various tactics to win many battles with fewer forces, which inevitably led to some pride. In this decisive battle, he divided the battlefield of the Barmilian starfield into $30000$ columns, numbered $1, 2, \\ldots, 30000$ in order. Then, he numbered his warships $1, 2, \\ldots, 30000$, placing warship $i$ in column $i$, forming a \"single-file long snake\" formation to lure the enemy deeper. This is the initial formation. When the invading enemy arrives, Yang will repeatedly issue merge commands to concentrate most of the warships into a few columns for a dense attack. A merge command is `M i j`, meaning the entire warship queue containing warship $i$, as a whole (head at the front and tail at the back), is appended to the tail of the warship queue containing warship $j$. Clearly, a warship queue is composed of one or more warships that are in the same column. Executing a merge command will increase the size of a queue.\n\nHowever, the cunning Reinhard has already taken the strategic initiative. During the battle, through a vast intelligence network, he can eavesdrop on Yang’s fleet maneuver commands at any time.\n\nWhile Yang issues commands to maneuver the fleet, Reinhard will also issue query commands to promptly learn the current distribution of Yang’s warships: `C i j`. This command asks the computer whether Yang’s warships $i$ and $j$ are currently in the same column. If they are in the same column, it asks how many warships are placed between them.\n\nAs a seasoned senior programmer, you are required to write a program to process Yang’s commands and answer Reinhard’s queries.\n\nThe decisive battle has begun, and another page in the galaxy’s history has turned.", "inputFormat": "The first line contains an integer $T$ ($1 \\le T \\le 5 \\times 10^5$), indicating there are $T$ instructions in total.\n\nThen follow $T$ lines, each containing one instruction. There are two formats:\n\n1. `M i j`: $i$ and $j$ are two integers ($1 \\le i, j \\le 30000$), representing the warship IDs involved. This instruction is a fleet maneuver command issued by Yang that Reinhard has intercepted, and it is guaranteed that warships $i$ and $j$ are not in the same column.\n\n2. `C i j`: $i$ and $j$ are two integers ($1 \\le i, j \\le 30000$), representing the warship IDs involved. This instruction is a query issued by Reinhard.\n\nIt is guaranteed that in every instruction $i \\ne j$.", "outputFormat": "Process each input instruction in order:\n\n- If it is a fleet maneuver command issued by Yang, the fleet formation changes; your program should record the change but must not output anything.\n- If it is a query issued by Reinhard, output one line containing a single integer: if warships $i$ and $j$ are in the same column, output the number of warships placed strictly between them; otherwise, output $-1$.", "hint": "Sample explanation\n\nWarship position diagram: in the table, Arabic numerals denote warship IDs.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2002] 银河英雄传说", "background": "公元 $5801$ 年，地球居民迁至金牛座 $\\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。\n\n宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。", "description": "杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \\ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  \n\n然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。\n\n在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。\n\n作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。\n\n最终的决战已经展开，银河的历史又翻过了一页……", "inputFormat": "第一行有一个整数 $T$（$1 \\le T \\le 5 \\times 10^5$），表示总共有 $T$ 条指令。\n\n以下有 $T$ 行，每行有一条指令。指令有两种格式：\n\n1. `M i j`：$i$ 和 $j$ 是两个整数（$1 \\le i,j \\le 30000$），表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第 $i$ 号战舰与第 $j$ 号战舰不在同一列。\n\n2. `C i j`：$i$ 和 $j$ 是两个整数（$1 \\le i,j \\le 30000$），表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。\n\n每条指令中都保证 $i\\neq j$。", "outputFormat": "依次对输入的每一条指令进行分析和处理：\n\n- 如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息。\n- 如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第 $i$ 号战舰与第 $j$ 号战舰之间布置的战舰数目。如果第 $i$ 号战舰与第 $j$ 号战舰当前不在同一列上，则输出 $-1$。", "hint": "### 样例解释\n\n战舰位置图：表格中阿拉伯数字表示战舰编号。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tkmxbxks.png)", "locale": "zh-CN"}}}
{"pid": "P1197", "type": "P", "difficulty": 4, "samples": [["8 13\n0 1\n1 6\n6 5\n5 0\n0 6\n1 2\n2 3\n3 4\n4 5\n7 1\n7 2\n7 6\n3 6\n5\n1\n6\n3\n5\n7\n", "1\n1\n1\n2\n3\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "并查集", "各省省选", "江苏", "连通块", "离线处理"], "title": "[JSOI2008] 星球大战", "background": null, "description": "很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治着整个星系。\n\n某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。\n\n但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。\n\n现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。", "inputFormat": "输入文件第一行包含两个整数 $n,m$，分别表示星球的数目和以太隧道的数目。星球用 $0 \\sim n-1$ 的整数编号。\n\n接下来的 $m$ 行，每行包括两个整数 $x,y$，表示星球 $x$ 和星球 $y$ 之间有“以太”隧道，可以直接通讯。\n\n接下来的一行为一个整数 $k$，表示将遭受攻击的星球的数目。\n\n接下来的 $k$ 行，每行有一个整数，按照顺序列出了帝国军的攻击目标。这 $k$ 个数互不相同，且都在 $0$ 到 $n-1$ 的范围内。", "outputFormat": "第一行是开始时星球的连通块个数。接下来的 $k$ 行，每行一个整数，表示经过该次打击后现存星球的连通块个数。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le m \\le 2\\times 10^5$，$1\\le n \\le 2m$，$x \\neq y$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Star Wars", "background": "", "description": "A long time ago, in a galaxy far away, a dark empire ruled the entire galaxy with its superweapon.\n\nOne day, by a stroke of chance, a rebel force destroyed the empire’s superweapon and captured almost all the planets in the galaxy. These planets are directly or indirectly connected through special “aether” tunnels.\n\nBut the good times did not last. Soon, the empire rebuilt its superweapon. With its power, the empire began systematically destroying the planets occupied by the rebels. As more planets were destroyed, the communication channels between planets also became unreliable.\n\nNow, the leader of the rebels assigns you a task: given the original connectivity of the “aether” tunnels between planets and the order in which the empire attacks the planets, compute as quickly as possible the number of connected components of the planets occupied by the rebels after each strike. (If two planets can be connected directly or indirectly through the existing aether tunnels, then they are in the same connected component.)", "inputFormat": "The first line contains two integers $n,m$, the number of planets and the number of aether tunnels. The planets are numbered by integers $0 \\sim n-1$.\n\nEach of the next $m$ lines contains two integers $x,y$, indicating there is an “aether” tunnel between planet $x$ and planet $y$, allowing direct communication.\n\nThe next line contains an integer $k$, the number of planets that will be attacked.\n\nEach of the next $k$ lines contains one integer, listing the empire’s attack targets in order. These $k$ numbers are pairwise distinct and all lie in the range $0$ to $n-1$.", "outputFormat": "The first line contains the number of connected components of the planets at the beginning. Each of the next $k$ lines contains one integer, the number of connected components of the remaining planets after that strike.", "hint": "**Constraints**\n\nFor $100\\%$ of the testdata, $1\\le m \\le 2\\times 10^5$, $1\\le n \\le 2m$, $x \\neq y$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] 星球大战", "background": null, "description": "很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治着整个星系。\n\n某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。\n\n但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。\n\n现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。", "inputFormat": "输入文件第一行包含两个整数 $n,m$，分别表示星球的数目和以太隧道的数目。星球用 $0 \\sim n-1$ 的整数编号。\n\n接下来的 $m$ 行，每行包括两个整数 $x,y$，表示星球 $x$ 和星球 $y$ 之间有“以太”隧道，可以直接通讯。\n\n接下来的一行为一个整数 $k$，表示将遭受攻击的星球的数目。\n\n接下来的 $k$ 行，每行有一个整数，按照顺序列出了帝国军的攻击目标。这 $k$ 个数互不相同，且都在 $0$ 到 $n-1$ 的范围内。", "outputFormat": "第一行是开始时星球的连通块个数。接下来的 $k$ 行，每行一个整数，表示经过该次打击后现存星球的连通块个数。", "hint": "**【数据范围】**\n\n对于 $100\\%$ 的数据，$1\\le m \\le 2\\times 10^5$，$1\\le n \\le 2m$，$x \\neq y$。", "locale": "zh-CN"}}}
{"pid": "P1198", "type": "P", "difficulty": 4, "samples": [["5 100\nA 96\nQ 1\nA 97\nQ 1\nQ 2\n", "96\n93\n96\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "线段树", "二分", "各省省选", "江苏", "栈", "ST 表", "单调栈"], "title": "[JSOI2008] 最大数", "background": "", "description": "现在请求你维护一个数列，要求提供以下两种操作：\n\n1.  查询操作。\n\n语法：`Q L`\n\n功能：查询当前数列中末尾 $L$ 个数中的最大的数，并输出这个数的值。\n\n限制：$L$ 不超过当前数列的长度。$(L > 0)$\n\n2. 插入操作。\n\n语法：`A n`\n\n功能：将 $n$ 加上 $t$，其中 $t$ 是最近一次查询操作的答案（如果还未执行过查询操作，则 $t=0$），并将所得结果对一个固定的常数 $D$ 取模，将所得答案插入到数列的末尾。\n\n限制：$n$ 是整数（可能为负数）并且在长整范围内。\n\n注意：初始时数列是空的，没有一个数。\n", "inputFormat": "第一行两个整数，$M$ 和 $D$，其中 $M$ 表示操作的个数，$D$ 如上文中所述。\n\n接下来的 $M$ 行，每行一个字符串，描述一个具体的操作。语法如上文所述。", "outputFormat": "对于每一个查询操作，你应该按照顺序依次输出结果，每个结果占一行。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq M \\leq 2 \\times 10^5$，$1 \\leq D \\leq 2 \\times 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[JSOI2008] Maximum Number", "background": "", "description": "You are asked to maintain a sequence and support the following two operations:\n\n1. Query operation.\n\nSyntax: `Q L`\n\nFunction: Query the maximum number among the last $L$ numbers in the current sequence, and output its value.\n\nConstraint: $L$ does not exceed the current length of the sequence. $(L > 0)$\n\n2. Insert operation.\n\nSyntax: `A n`\n\nFunction: Add $t$ to $n$, where $t$ is the answer to the most recent query operation (if no query has been performed yet, then $t = 0$). Then take the result modulo a fixed constant $D$, and insert the obtained value at the end of the sequence.\n\nConstraint: $n$ is an integer (possibly negative) and within the 64-bit signed integer range.\n\nNote: Initially, the sequence is empty and contains no numbers.", "inputFormat": "The first line contains two integers, $M$ and $D$, where $M$ is the number of operations and $D$ is the fixed constant mentioned above.\n\nEach of the next $M$ lines contains one string describing a specific operation, with syntax as described above.", "outputFormat": "For each query operation, output the result in order, one per line.", "hint": "Constraints\n\nFor all testdata, it is guaranteed that $1 \\leq M \\leq 2 \\times 10^5$, $1 \\leq D \\leq 2 \\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JSOI2008] 最大数", "background": "", "description": "现在请求你维护一个数列，要求提供以下两种操作：\n\n1.  查询操作。\n\n语法：`Q L`\n\n功能：查询当前数列中末尾 $L$ 个数中的最大的数，并输出这个数的值。\n\n限制：$L$ 不超过当前数列的长度。$(L > 0)$\n\n2. 插入操作。\n\n语法：`A n`\n\n功能：将 $n$ 加上 $t$，其中 $t$ 是最近一次查询操作的答案（如果还未执行过查询操作，则 $t=0$），并将所得结果对一个固定的常数 $D$ 取模，将所得答案插入到数列的末尾。\n\n限制：$n$ 是整数（可能为负数）并且在长整范围内。\n\n注意：初始时数列是空的，没有一个数。\n", "inputFormat": "第一行两个整数，$M$ 和 $D$，其中 $M$ 表示操作的个数，$D$ 如上文中所述。\n\n接下来的 $M$ 行，每行一个字符串，描述一个具体的操作。语法如上文所述。", "outputFormat": "对于每一个查询操作，你应该按照顺序依次输出结果，每个结果占一行。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq M \\leq 2 \\times 10^5$，$1 \\leq D \\leq 2 \\times 10^9$。", "locale": "zh-CN"}}}
{"pid": "P1199", "type": "P", "difficulty": 3, "samples": [["6 \n5 28 16 29 27 \n23 3 20 1 \n8 32 26 \n33 11 \n12 \n", "1\n32\n\n"], ["8 \n42 24 10 29 27 12 58 \n31 8 16 26 80 6 \n25 3 36 11 5 \n33 20 17 13 \n15 77 9 \n4 50 \n19 ", "1\n77"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "博弈论", "2010", "NOIP 普及组"], "title": "[NOIP 2010 普及组] 三国游戏", "background": null, "description": "小涵很喜欢电脑游戏，这些天他正在玩一个叫做《三国》的游戏。\n\n在游戏中，小涵和计算机各执一方，组建各自的军队进行对战。游戏中共有 $N$ 位武将（$N$ 为偶数且不小于 $4$），任意两个武将之间有一个“默契值”，表示若此两位武将作为一对组合作战时，该组合的威力有多大。游戏开始前，所有武将都是自由的（称为自由武将，一旦某个自由武将被选中作为某方军队的一员，那么他就不再是自由武将了），换句话说，所谓的自由武将不属于任何一方。\n\n游戏开始，小涵和计算机要从自由武将中挑选武将组成自己的军队，规则如下：小涵先从自由武将中选出一个加入自己的军队，然后计算机也从自由武将中选出一个加入计算机方的军队。接下来一直按照“小涵 $\\to$ 计算机 $\\to$ 小涵 $\\to\\dots$ ”的顺序选择武将，直到所有的武将被双方均分完。然后，程序自动从双方军队中各挑出一对默契值最高的武将组合代表自己的军队进行二对二比武，拥有更高默契值的一对武将组合获胜，表示两军交战，拥有获胜武将组合的一方获胜。\n\n已知计算机一方选择武将的原则是尽量破坏对手下一步将形成的最强组合，它采取的具体策略如下：任何时刻，轮到计算机挑选时，它会尝试将对手军队中的每个武将与当前每个自由武将进行一一配对，找出所有配对中默契值最高的那对武将组合，并将该组合中的自由武将选入自己的军队。 下面举例说明计算机的选将策略，例如，游戏中一共有 $6$ 个武将，他们相互之间的默契值如下表所示：\n\n| 武将编号 |  1   |  2   |  3   |  4   |  5   |  6   |\n| :------: | :--: | :--: | :--: | :--: | :--: | :--: |\n|  **1**   |      | $5$  | $28$ | $16$ | $29$ | $27$ |\n|  **2**   | $5$  |      | $23$ | $3$  | $20$ | $1$  |\n|  **3**   | $28$ | $23$ |      | $8$  | $32$ | $26$ |\n|  **4**   | $16$ | $3$  | $8$  |      | $33$ | $11$ |\n|  **5**   | $29$ | $20$ | $32$ | $33$ |      | $12$ |\n|  **6**   | $27$ | $1$  | $26$ | $11$ | $12$ |      |\n\n双方选将过程如下所示：\n\n|        | 小涵 | 轮到计算机时可选的自由武将 |  计算机    |  计算机选将说明    |\n| :----: | :--: | :----------: | :--: | :--: |\n| 第一轮 | $5$ | $1,2,3,4,6$ | $\\color{magenta}4$ | 小涵手中的 $5$ 号武将与 $4$ 号的默契值最高，所以计算机选择 $4$ 号。 |\n| 第二轮 | $5,3$ | $1,2,6$ | $4,\\color{magenta}1$ |  小涵手中的 $5$ 号和 $3$ 号武将与自由武将中配对可产生的最大默契值为 $29$，是由 $5$ 号与 $1$ 号配对产生的，所以计算机选择 $1$ 号。  |\n| 第三轮 | $5,3,6$ | $2$ | $4,1,\\color{magenta}2$ |      |\n\n小涵想知道，如果计算机在一局游戏中始终坚持上面这个策略，那么自己有没有可能必胜？如果有，在所有可能的胜利结局中，自己那对用于比武的武将组合的默契值最大是多少？  \n\n假设整个游戏过程中，对战双方任何时候均能看到自由武将队中的武将和对方军队的武将。为了简化问题，保证对于不同的武将组合，其默契值均不相同。", "inputFormat": "共 $N$ 行。\n\n第一行为一个偶数 $N$，表示武将的个数。\n\n第 $2$ 行到第 $N$ 行里，第 $i+1$ 行有 $N-i$ 个非负整数，每两个数之间用一个空格隔开，表示 $i$ 号武将和 $i+1,i+2,\\dots,N $ 号武将之间的默契值（$0 \\le \\text{默契值} \\le 10^9$）。", "outputFormat": "共一或二行。\n\n若对于给定的游戏输入，存在可以让小涵获胜的选将顺序，则输出 $ 1$，并另起一行输出所有获胜的情况中，小涵最终选出的武将组合的最大默契值。如果不存在可以让小涵获胜的选将顺序，则输出 $0$。", "hint": "**数据范围**\n\n对于 $ 40\\%$ 的数据有 $N≤10$。\n\n对于 $ 70\\%$ 的数据有 $ N≤18$。\n\n对于 $100\\%$ 的数据有 $4\\le N≤500$。保证对于不同的武将组合，其默契值均不相同。\n\nNOIP2010 普及组 第四题", "locale": "zh-CN", "translations": {"en": {"title": "{{[NOIP 2010 Junior] Three Kingdoms Game}}", "background": "{{}}", "description": "{{Xiaohan loves computer games, and these days he is playing a game called \"Three Kingdoms.\"\n\nIn the game, Xiaohan and the computer control opposing sides, each assembling their own army to battle. There are $ N $ generals in total (where $ N $ is even and at least $ 4 $). Between any two generals there is a \"synergy value,\" indicating how powerful a pair would be if they fight together. Before the game starts, all generals are free (called free generals; once a free general is chosen as a member of a side's army, he is no longer a free general). In other words, free generals do not belong to any side.\n\nWhen the game begins, Xiaohan and the computer take turns selecting generals from the free generals to form their armies, following these rules: Xiaohan first selects one free general to join his army, then the computer selects one free general to join the computer's army. They continue selecting in the order \"Xiaohan → computer → Xiaohan → …\" until all generals are evenly split between the two sides. Then, the program automatically selects from each army the pair of generals with the highest synergy value to represent that army in a two-on-two duel. The side whose pair has the higher synergy value wins the duel; that side wins the battle.\n\nIt is known that the computer's principle for choosing is to disrupt the opponent's strongest possible pair on the opponent's next move as much as possible. Its specific strategy is as follows: whenever it is the computer's turn, it tries pairing each general already in the opponent's army with each current free general, finds the pair with the highest synergy value among all such pairings, and then picks the free general from that pair into its own army. For example, suppose there are $ 6 $ generals in total, and their pairwise synergy values are as shown below:\n\n| General ID |  1   |  2   |  3   |  4   |  5   |  6   |\n| :--------: | :--: | :--: | :--: | :--: | :--: | :--: |\n|   **1**    |      | $5$  | $28$ | $16$ | $29$ | $27$ |\n|   **2**    | $5$  |      | $23$ | $3$  | $20$ | $1$  |\n|   **3**    | $28$ | $23$ |      | $8$  | $32$ | $26$ |\n|   **4**    | $16$ | $3$  | $8$  |      | $33$ | $11$ |\n|   **5**    | $29$ | $20$ | $32$ | $33$ |      | $12$ |\n|   **6**    | $27$ | $1$  | $26$ | $11$ | $12$ |      |\n\nThe selection process is as follows:\n\n|        | Xiaohan | Free generals available to the computer on its turn | Computer | Computer's choice explanation |\n| :----: | :-----: | :-------------------------------------------------: | :------: | :---------------------------: |\n| Round 1 | $5$ | $1,2,3,4,6$ | $\\color{magenta}4$ | The synergy value between Xiaohan's $5$ and $4$ is the highest, so the computer selects $4$. |\n| Round 2 | $5,3$ | $1,2,6$ | $4,\\color{magenta}1$ | The maximum synergy value that can be formed by pairing Xiaohan's $5$ and $3$ with a free general is $29$, produced by pairing $5$ with $1$, so the computer selects $1$. |\n| Round 3 | $5,3,6$ | $2$ | $4,1,\\color{magenta}2$ |  |\n\nXiaohan wants to know: if the computer always sticks to the above strategy in a game, is it possible for him to force a win? If yes, among all possible winning outcomes, what is the maximum synergy value of the pair of generals he finally uses for the duel?\n\nAssume that throughout the game, both sides can always see the free generals and the opponent's chosen generals. To simplify the problem, it is guaranteed that for different pairs of generals, their synergy values are all distinct.}}", "inputFormat": "{{A total of $ N $ lines.\n\nThe first line contains an even integer $ N $, the number of generals.\n\nFrom the $ 2 $-nd line to the $ N $-th line, line $ i+1 $ contains $ N-i $ non-negative integers separated by single spaces, representing the synergy values between general $ i $ and generals $ i+1,i+2,\\dots,N $ ($0 \\le \\text{默契值} \\le 10^9$).}}", "outputFormat": "{{One or two lines in total.\n\nIf there exists a selection sequence that allows Xiaohan to win for the given input, output $ 1$, and on the next line output the maximum synergy value of Xiaohan's final chosen pair among all winning cases. If no such selection sequence exists, output $0$.}}", "hint": "{{Constraints\n\nFor $ 40\\% $ of the testdata, $N≤10$.\n\nFor $ 70\\% $ of the testdata, $ N≤18$.\n\nFor $ 100\\% $ of the testdata, $4\\le N≤500$. It is guaranteed that for different pairs of generals, their synergy values are all distinct.\n\nNOIP 2010 Junior Problem 4.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2010 普及组] 三国游戏", "background": null, "description": "小涵很喜欢电脑游戏，这些天他正在玩一个叫做《三国》的游戏。\n\n在游戏中，小涵和计算机各执一方，组建各自的军队进行对战。游戏中共有 $N$ 位武将（$N$ 为偶数且不小于 $4$），任意两个武将之间有一个“默契值”，表示若此两位武将作为一对组合作战时，该组合的威力有多大。游戏开始前，所有武将都是自由的（称为自由武将，一旦某个自由武将被选中作为某方军队的一员，那么他就不再是自由武将了），换句话说，所谓的自由武将不属于任何一方。\n\n游戏开始，小涵和计算机要从自由武将中挑选武将组成自己的军队，规则如下：小涵先从自由武将中选出一个加入自己的军队，然后计算机也从自由武将中选出一个加入计算机方的军队。接下来一直按照“小涵 $\\to$ 计算机 $\\to$ 小涵 $\\to\\dots$ ”的顺序选择武将，直到所有的武将被双方均分完。然后，程序自动从双方军队中各挑出一对默契值最高的武将组合代表自己的军队进行二对二比武，拥有更高默契值的一对武将组合获胜，表示两军交战，拥有获胜武将组合的一方获胜。\n\n已知计算机一方选择武将的原则是尽量破坏对手下一步将形成的最强组合，它采取的具体策略如下：任何时刻，轮到计算机挑选时，它会尝试将对手军队中的每个武将与当前每个自由武将进行一一配对，找出所有配对中默契值最高的那对武将组合，并将该组合中的自由武将选入自己的军队。 下面举例说明计算机的选将策略，例如，游戏中一共有 $6$ 个武将，他们相互之间的默契值如下表所示：\n\n| 武将编号 |  1   |  2   |  3   |  4   |  5   |  6   |\n| :------: | :--: | :--: | :--: | :--: | :--: | :--: |\n|  **1**   |      | $5$  | $28$ | $16$ | $29$ | $27$ |\n|  **2**   | $5$  |      | $23$ | $3$  | $20$ | $1$  |\n|  **3**   | $28$ | $23$ |      | $8$  | $32$ | $26$ |\n|  **4**   | $16$ | $3$  | $8$  |      | $33$ | $11$ |\n|  **5**   | $29$ | $20$ | $32$ | $33$ |      | $12$ |\n|  **6**   | $27$ | $1$  | $26$ | $11$ | $12$ |      |\n\n双方选将过程如下所示：\n\n|        | 小涵 | 轮到计算机时可选的自由武将 |  计算机    |  计算机选将说明    |\n| :----: | :--: | :----------: | :--: | :--: |\n| 第一轮 | $5$ | $1,2,3,4,6$ | $\\color{magenta}4$ | 小涵手中的 $5$ 号武将与 $4$ 号的默契值最高，所以计算机选择 $4$ 号。 |\n| 第二轮 | $5,3$ | $1,2,6$ | $4,\\color{magenta}1$ |  小涵手中的 $5$ 号和 $3$ 号武将与自由武将中配对可产生的最大默契值为 $29$，是由 $5$ 号与 $1$ 号配对产生的，所以计算机选择 $1$ 号。  |\n| 第三轮 | $5,3,6$ | $2$ | $4,1,\\color{magenta}2$ |      |\n\n小涵想知道，如果计算机在一局游戏中始终坚持上面这个策略，那么自己有没有可能必胜？如果有，在所有可能的胜利结局中，自己那对用于比武的武将组合的默契值最大是多少？  \n\n假设整个游戏过程中，对战双方任何时候均能看到自由武将队中的武将和对方军队的武将。为了简化问题，保证对于不同的武将组合，其默契值均不相同。", "inputFormat": "共 $N$ 行。\n\n第一行为一个偶数 $N$，表示武将的个数。\n\n第 $2$ 行到第 $N$ 行里，第 $i+1$ 行有 $N-i$ 个非负整数，每两个数之间用一个空格隔开，表示 $i$ 号武将和 $i+1,i+2,\\dots,N $ 号武将之间的默契值（$0 \\le \\text{默契值} \\le 10^9$）。", "outputFormat": "共一或二行。\n\n若对于给定的游戏输入，存在可以让小涵获胜的选将顺序，则输出 $ 1$，并另起一行输出所有获胜的情况中，小涵最终选出的武将组合的最大默契值。如果不存在可以让小涵获胜的选将顺序，则输出 $0$。", "hint": "**数据范围**\n\n对于 $ 40\\%$ 的数据有 $N≤10$。\n\n对于 $ 70\\%$ 的数据有 $ N≤18$。\n\n对于 $100\\%$ 的数据有 $4\\le N≤500$。保证对于不同的武将组合，其默契值均不相同。\n\nNOIP2010 普及组 第四题", "locale": "zh-CN"}}}
{"pid": "P1200", "type": "P", "difficulty": 1, "samples": [["COMETQ\nHVNGAT", "GO"], ["ABSTAR\nUSACO", "STAY"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "数学", "USACO"], "title": "[USACO1.1] 你的飞碟在这儿 Your Ride Is Here", "background": null, "description": "众所周知，在每一个彗星后都有一只 UFO。这些 UFO 时常来收集地球上的忠诚支持者。不幸的是，他们的飞碟每次出行都只能带上一组支持者。因此，他们要用一种聪明的方案让这些小组提前知道谁会被彗星带走。他们为每个彗星起了一个名字，通过这些名字来决定这个小组是不是被带走的那个特定的小组（你认为是谁给这些彗星取的名字呢？）。关于如何搭配的细节会在下面告诉你；你的任务是写一个程序，通过小组名和彗星名来决定这个小组是否能被那颗彗星后面的 UFO 带走。\n\n\n小组名和彗星名都以下列方式转换成一个数字：最终的数字就是名字中所有字母的积，其中 $\\texttt A$ 是 $1$，$\\texttt Z$ 是 $26$。例如，$\\texttt{USACO}$ 小组就是 $21 \\times 19 \\times 1 \\times 3 \\times 15=17955$。如果小组的数字 $\\bmod 47$ 等于彗星的数字 $\\bmod 47$，你就得告诉这个小组需要准备好被带走！（记住“$a \\bmod b$”是 $a$ 除以 $b$ 的余数，例如 $34 \\bmod 10$ 等于 $4$）\n\n\n写出一个程序，读入彗星名和小组名并算出用上面的方案能否将两个名字搭配起来，如果能搭配，就输出 `GO`，否则输出 `STAY`。小组名和彗星名均是没有空格或标点的一串大写字母（不超过 $6$ 个字母）。", "inputFormat": "第 1 行：一个长度为 $1$ 到 $6$ 的大写字母串，表示彗星的名字。\n\n第 2 行：一个长度为 $1$ 到 $6$ 的大写字母串，表示队伍的名字。", "outputFormat": null, "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 1.1", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.1] Your Ride Is Here", "background": null, "description": "As everyone knows, there is a UFO behind every comet. These UFOs often come to gather loyal supporters on Earth. Unfortunately, their saucer can take only one group of supporters on each trip. Therefore, they use a clever scheme to let the groups know in advance who will be taken by a comet. They give each comet a name and use these names to decide whether a particular group is the one to be taken (who do you think names these comets?). The details of how to match are given below; your task is to write a program that, given a group name and a comet name, decides whether the group will be taken by the UFO behind that comet.\n\nBoth the group name and the comet name are converted into a number as follows: the final number is the product of the values of all letters in the name, where $\\texttt A$ is $1$ and $\\texttt Z$ is $26$. For example, the group $\\texttt{USACO}$ yields $21 \\times 19 \\times 1 \\times 3 \\times 15 = 17955$. If the group’s number $\\bmod 47$ equals the comet’s number $\\bmod 47$, you should tell the group to get ready to go! (Remember that \"$a \\bmod b$\" is the remainder when $a$ is divided by $b$; for example, $34 \\bmod 10$ equals $4$.)\n\nWrite a program that reads the comet name and the group name and determines whether the two names match under the scheme above. If they match, output `GO`; otherwise, output `STAY`. Both the group name and the comet name are strings of uppercase letters with no spaces or punctuation (at most $6$ letters).", "inputFormat": "Line 1: An uppercase string of length $1$ to $6$, the comet's name.\n\nLine 2: An uppercase string of length $1$ to $6$, the group's name.", "outputFormat": null, "hint": "Problem translation from NOCOW.\n\nUSACO Training Section 1.1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.1] 你的飞碟在这儿 Your Ride Is Here", "background": null, "description": "众所周知，在每一个彗星后都有一只 UFO。这些 UFO 时常来收集地球上的忠诚支持者。不幸的是，他们的飞碟每次出行都只能带上一组支持者。因此，他们要用一种聪明的方案让这些小组提前知道谁会被彗星带走。他们为每个彗星起了一个名字，通过这些名字来决定这个小组是不是被带走的那个特定的小组（你认为是谁给这些彗星取的名字呢？）。关于如何搭配的细节会在下面告诉你；你的任务是写一个程序，通过小组名和彗星名来决定这个小组是否能被那颗彗星后面的 UFO 带走。\n\n\n小组名和彗星名都以下列方式转换成一个数字：最终的数字就是名字中所有字母的积，其中 $\\texttt A$ 是 $1$，$\\texttt Z$ 是 $26$。例如，$\\texttt{USACO}$ 小组就是 $21 \\times 19 \\times 1 \\times 3 \\times 15=17955$。如果小组的数字 $\\bmod 47$ 等于彗星的数字 $\\bmod 47$，你就得告诉这个小组需要准备好被带走！（记住“$a \\bmod b$”是 $a$ 除以 $b$ 的余数，例如 $34 \\bmod 10$ 等于 $4$）\n\n\n写出一个程序，读入彗星名和小组名并算出用上面的方案能否将两个名字搭配起来，如果能搭配，就输出 `GO`，否则输出 `STAY`。小组名和彗星名均是没有空格或标点的一串大写字母（不超过 $6$ 个字母）。", "inputFormat": "第 1 行：一个长度为 $1$ 到 $6$ 的大写字母串，表示彗星的名字。\n\n第 2 行：一个长度为 $1$ 到 $6$ 的大写字母串，表示队伍的名字。", "outputFormat": null, "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 1.1", "locale": "zh-CN"}}}
