{"pid": "P8868", "type": "P", "difficulty": 6, "samples": [["0 2\n2 1\n1 2\n1\n1 2", "8"], ["见附件下的 match/match2.in。", "见附件下的 match/match2.ans。"], ["见附件下的 match/match3.in。", "见附件下的 match/match3.ans。"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "2022", "NOIP 提高组", "O2优化"], "title": "[NOIP2022] 比赛", "background": "", "description": "小 N 和小 O 会在 2022 年 11 月参加一场盛大的程序设计大赛 NOIP！小 P 会作为裁判主持竞赛。小 N 和小 O 各自率领了一支 $n$ 个人的队伍，选手在每支队伍内都是从 $1$ 到 $n$ 编号。每一个选手都有相应的程序设计水平。具体的，小 N 率领的队伍中，编号为 $i$（$1 \\leq i \\leq n$）的选手的程序设计水平为 $a _ i$；小 O 率领的队伍中，编号为 $i$（$1 \\leq i \\leq n$）的选手的程序设计水平为 $b _ i$。特别地，$\\{a _ i\\}$ 和 $\\{b _ i\\}$ 还分别构成了从 $1$ 到 $n$ 的排列。\n\n每场比赛前，考虑到路途距离，选手连续参加比赛等因素，小 P 会选择两个参数 $l, r$（$1 \\leq l \\leq r \\leq n$），表示这一场比赛会邀请两队中编号属于 $[l, r]$ 的所有选手来到现场准备比赛。在比赛现场，小 N 和小 O 会以掷骰子的方式挑选出参数 $p, q$（$l \\leq p \\leq q \\leq r$），只有编号属于 $[p, q]$ 的选手才能参赛。为了给观众以最精彩的比赛，两队都会派出编号在 $[p, q]$ 内的、程序设计水平值最大的选手参加比赛。假定小 N 派出的选手水平为 $m _ a$，小 O 派出的选手水平为 $m _ b$，则比赛的精彩程度为 $m _ a \\times m _ b$。\n\nNOIP 总共有 $Q$ 场比赛，每场比赛的参数 $l, r$ 都已经确定，但是 $p, q$ 还没有抽取。小 P 想知道，对于每一场比赛，在其所有可能的 $p, q$（$l \\leq p \\leq q \\leq r$）参数下的比赛的精彩程度之和。由于答案可能非常之大，你只需要对每一场答案输出结果对 $2 ^ {64}$ 取模的结果即可。", "inputFormat": "第一行包含两个正整数 $T, n$，分别表示测试点编号和参赛人数。如果数据为样例则保证 $T = 0$。\n\n第二行包含 $n$ 个正整数，第 $i$ 个正整数为 $a _ i$，表示小 N 队伍中编号为 $i$ 的选手的程序设计水平。\n\n第三行包含 $n$ 个正整数，第 $i$ 个正整数为 $b _ i$，表示小 O 队伍中编号为 $i$ 的选手的程序设计水平。\n\n第四行包含一个正整数 $Q$，表示比赛场数。\n\n接下来的 $Q$ 行，第 $i$ 行包含两个正整数 $l _ i, r _ i$，表示第 $i$ 场比赛的参数 $l, r$。", "outputFormat": "输出 $Q$ 行，第 $i$ 行包含一个非负整数，表示第 $i$ 场比赛中所有可能的比赛的精彩程度之和对 $2 ^ {64}$ 取模的结果。", "hint": "**【样例 1 解释】**\n\n当 $p = 1, q = 2$ 的时候，小 N 会派出 $1$ 号选手，小 O 会派出 $2$ 号选手，比赛精彩程度为 $2 \\times 2 = 4$。\n\n当 $p = 1, q = 1$ 的时候，小 N 会派出 $1$ 号选手，小 O 会派出 $1$ 号选手，比赛精彩程度为 $2 \\times 1 = 2$。\n\n当 $p = 2, q = 2$ 的时候，小 N 会派出 $2$ 号选手，小 O 会派出 $2$ 号选手，比赛精彩程度为 $1 \\times 2 = 2$。\n\n**【样例 2】**\n\n该样例满足测试点 $1 \\sim 2$ 的限制。\n\n**【样例 3】**\n\n该样例满足测试点 $3 \\sim 5$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，保证：$1 \\leq n, Q \\leq 2.5 \\times 10 ^ 5$，$1 \\leq l _ i \\leq r _ i \\leq n$，$1 \\leq a _ i, b _ i \\leq n$ 且 $\\{a _ i\\}$ 和 $\\{b _ i\\}$ 分别构成了从 $1$ 到 $n$ 的排列。\n\n::cute-table{tuack}\n\n| 测试点 | $n$ | $Q$ | 特殊性质 A | 特殊性质 B |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1, 2$ | $\\leq 30$ | $\\leq 30$ | 是 | 是 |\n| $3, 4, 5$ | $\\leq 3,000$ | $\\leq 3,000$ | ^ | ^ |\n| $6, 7$ | $\\leq 10 ^ 5$ | $\\leq 5$ | ^ | ^ |\n| $8, 9$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ | ^ |\n| $10, 11$ | $\\leq 10 ^ 5$ | ^ | 否 | 否 |\n| $12, 13$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ | ^ |\n| $14, 15$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | 是 | 是 |\n| $16, 17$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n| $18, 19$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | ^ | 否 |\n| $20, 21$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n| $22, 23$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | 否 | ^ |\n| $24, 25$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n\n特殊性质 A：保证 $a$ 是均匀随机生成的 $1 \\sim n$ 的排列。\n\n特殊性质 B：保证 $b$ 是均匀随机生成的 $1 \\sim n$ 的排列。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP2022] Competition", "background": "", "description": "Xiao N and Xiao O will take part in the grand programming contest NOIP in November 2022, and Xiao P will serve as the judge. Xiao N and Xiao O each lead a team of $n$ people, and players in each team are numbered from $1$ to $n$. Every player has a programming skill level. Specifically, in Xiao N's team, the player with index $i$ ($1 \\leq i \\leq n$) has skill level $a _ i$; in Xiao O's team, the player with index $i$ ($1 \\leq i \\leq n$) has skill level $b _ i$. In particular, $\\{a _ i\\}$ and $\\{b _ i\\}$ each form a permutation of $1$ to $n$.\n\nBefore each match, considering factors such as travel distance and players competing in consecutive matches, Xiao P chooses two parameters $l, r$ ($1 \\leq l \\leq r \\leq n$), meaning that for this match all players whose indices are in $[l, r]$ from both teams will come to the venue to get ready. At the venue, Xiao N and Xiao O will pick parameters $p, q$ by rolling dice ($l \\leq p \\leq q \\leq r$), and only players with indices in $[p, q]$ are eligible to compete. To deliver the most exciting match to the audience, both teams will send the player with the maximum programming skill value whose index lies in $[p, q]$. Suppose Xiao N sends a player with skill $m _ a$, and Xiao O sends a player with skill $m _ b$; then the excitement of the match is $m _ a \\times m _ b$.\n\nThere are $Q$ matches in total in NOIP. For each match, the parameters $l, r$ are fixed, but $p, q$ have not yet been drawn. Xiao P wants to know, for each match, the sum of the excitement values over all possible choices of $p, q$ ($l \\leq p \\leq q \\leq r$). Since the answer can be very large, for each match you only need to output the result modulo $2 ^ {64}$.", "inputFormat": "The first line contains two positive integers $T, n$, denoting the test point id and the number of participants, respectively. If the input is a sample, it is guaranteed that $T = 0$.\n\nThe second line contains $n$ positive integers; the $i$-th integer is $a _ i$, the programming skill level of the player with index $i$ in Xiao N's team.\n\nThe third line contains $n$ positive integers; the $i$-th integer is $b _ i$, the programming skill level of the player with index $i$ in Xiao O's team.\n\nThe fourth line contains a positive integer $Q$, the number of matches.\n\nEach of the next $Q$ lines contains two positive integers $l _ i, r _ i$, the parameters $l, r$ for the $i$-th match.", "outputFormat": "Output $Q$ lines. The $i$-th line should contain a non-negative integer, which is the sum of the excitement values over all possible matches for the $i$-th query, modulo $2 ^ {64}$.", "hint": "【Sample 1 Explanation】\n\nWhen $p = 1, q = 2$, Xiao N will send player $1$, and Xiao O will send player $2$, so the excitement is $2 \\times 2 = 4$.\n\nWhen $p = 1, q = 1$, Xiao N will send player $1$, and Xiao O will send player $1$, so the excitement is $2 \\times 1 = 2$.\n\nWhen $p = 2, q = 2$, Xiao N will send player $2$, and Xiao O will send player $2$, so the excitement is $1 \\times 2 = 2$.\n\n【Sample 2】\n\nThis sample satisfies the constraints of test points $1 \\sim 2$.\n\n【Sample 3】\n\nThis sample satisfies the constraints of test points $3 \\sim 5$.\n\n【Constraints】\n\nFor all testdata, it is guaranteed that: $1 \\leq n, Q \\leq 2.5 \\times 10 ^ 5$, $1 \\leq l _ i \\leq r _ i \\leq n$, $1 \\leq a _ i, b _ i \\leq n$, and $\\{a _ i\\}$ and $\\{b _ i\\}$ each form a permutation of $1$ to $n$.\n\n::cute-table{tuack}\n| Test points | $n$ | $Q$ | Special property A | Special property B |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1, 2$ | $\\leq 30$ | $\\leq 30$ | Yes | Yes |\n| $3, 4, 5$ | $\\leq 3,000$ | $\\leq 3,000$ | ^ | ^ |\n| $6, 7$ | $\\leq 10 ^ 5$ | $\\leq 5$ | ^ | ^ |\n| $8, 9$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ | ^ |\n| $10, 11$ | $\\leq 10 ^ 5$ | ^ | No | No |\n| $12, 13$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ | ^ |\n| $14, 15$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | Yes | Yes |\n| $16, 17$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n| $18, 19$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | ^ | No |\n| $20, 21$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n| $22, 23$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | No | ^ |\n| $24, 25$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n\nSpecial property A: It is guaranteed that $a$ is a uniformly random permutation of $1 \\sim n$.\n\nSpecial property B: It is guaranteed that $b$ is a uniformly random permutation of $1 \\sim n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP2022] 比赛", "background": "", "description": "小 N 和小 O 会在 2022 年 11 月参加一场盛大的程序设计大赛 NOIP！小 P 会作为裁判主持竞赛。小 N 和小 O 各自率领了一支 $n$ 个人的队伍，选手在每支队伍内都是从 $1$ 到 $n$ 编号。每一个选手都有相应的程序设计水平。具体的，小 N 率领的队伍中，编号为 $i$（$1 \\leq i \\leq n$）的选手的程序设计水平为 $a _ i$；小 O 率领的队伍中，编号为 $i$（$1 \\leq i \\leq n$）的选手的程序设计水平为 $b _ i$。特别地，$\\{a _ i\\}$ 和 $\\{b _ i\\}$ 还分别构成了从 $1$ 到 $n$ 的排列。\n\n每场比赛前，考虑到路途距离，选手连续参加比赛等因素，小 P 会选择两个参数 $l, r$（$1 \\leq l \\leq r \\leq n$），表示这一场比赛会邀请两队中编号属于 $[l, r]$ 的所有选手来到现场准备比赛。在比赛现场，小 N 和小 O 会以掷骰子的方式挑选出参数 $p, q$（$l \\leq p \\leq q \\leq r$），只有编号属于 $[p, q]$ 的选手才能参赛。为了给观众以最精彩的比赛，两队都会派出编号在 $[p, q]$ 内的、程序设计水平值最大的选手参加比赛。假定小 N 派出的选手水平为 $m _ a$，小 O 派出的选手水平为 $m _ b$，则比赛的精彩程度为 $m _ a \\times m _ b$。\n\nNOIP 总共有 $Q$ 场比赛，每场比赛的参数 $l, r$ 都已经确定，但是 $p, q$ 还没有抽取。小 P 想知道，对于每一场比赛，在其所有可能的 $p, q$（$l \\leq p \\leq q \\leq r$）参数下的比赛的精彩程度之和。由于答案可能非常之大，你只需要对每一场答案输出结果对 $2 ^ {64}$ 取模的结果即可。", "inputFormat": "第一行包含两个正整数 $T, n$，分别表示测试点编号和参赛人数。如果数据为样例则保证 $T = 0$。\n\n第二行包含 $n$ 个正整数，第 $i$ 个正整数为 $a _ i$，表示小 N 队伍中编号为 $i$ 的选手的程序设计水平。\n\n第三行包含 $n$ 个正整数，第 $i$ 个正整数为 $b _ i$，表示小 O 队伍中编号为 $i$ 的选手的程序设计水平。\n\n第四行包含一个正整数 $Q$，表示比赛场数。\n\n接下来的 $Q$ 行，第 $i$ 行包含两个正整数 $l _ i, r _ i$，表示第 $i$ 场比赛的参数 $l, r$。", "outputFormat": "输出 $Q$ 行，第 $i$ 行包含一个非负整数，表示第 $i$ 场比赛中所有可能的比赛的精彩程度之和对 $2 ^ {64}$ 取模的结果。", "hint": "**【样例 1 解释】**\n\n当 $p = 1, q = 2$ 的时候，小 N 会派出 $1$ 号选手，小 O 会派出 $2$ 号选手，比赛精彩程度为 $2 \\times 2 = 4$。\n\n当 $p = 1, q = 1$ 的时候，小 N 会派出 $1$ 号选手，小 O 会派出 $1$ 号选手，比赛精彩程度为 $2 \\times 1 = 2$。\n\n当 $p = 2, q = 2$ 的时候，小 N 会派出 $2$ 号选手，小 O 会派出 $2$ 号选手，比赛精彩程度为 $1 \\times 2 = 2$。\n\n**【样例 2】**\n\n该样例满足测试点 $1 \\sim 2$ 的限制。\n\n**【样例 3】**\n\n该样例满足测试点 $3 \\sim 5$ 的限制。\n\n**【数据范围】**\n\n对于所有数据，保证：$1 \\leq n, Q \\leq 2.5 \\times 10 ^ 5$，$1 \\leq l _ i \\leq r _ i \\leq n$，$1 \\leq a _ i, b _ i \\leq n$ 且 $\\{a _ i\\}$ 和 $\\{b _ i\\}$ 分别构成了从 $1$ 到 $n$ 的排列。\n\n::cute-table{tuack}\n\n| 测试点 | $n$ | $Q$ | 特殊性质 A | 特殊性质 B |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1, 2$ | $\\leq 30$ | $\\leq 30$ | 是 | 是 |\n| $3, 4, 5$ | $\\leq 3,000$ | $\\leq 3,000$ | ^ | ^ |\n| $6, 7$ | $\\leq 10 ^ 5$ | $\\leq 5$ | ^ | ^ |\n| $8, 9$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ | ^ |\n| $10, 11$ | $\\leq 10 ^ 5$ | ^ | 否 | 否 |\n| $12, 13$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ | ^ |\n| $14, 15$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | 是 | 是 |\n| $16, 17$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n| $18, 19$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | ^ | 否 |\n| $20, 21$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n| $22, 23$ | $\\leq 10 ^ 5$ | $\\leq 10 ^ 5$ | 否 | ^ |\n| $24, 25$ | $\\leq 2.5 \\times 10 ^ 5$ | $\\leq 2.5 \\times 10 ^ 5$ | ^ | ^ |\n\n特殊性质 A：保证 $a$ 是均匀随机生成的 $1 \\sim n$ 的排列。\n\n特殊性质 B：保证 $b$ 是均匀随机生成的 $1 \\sim n$ 的排列。", "locale": "zh-CN"}}}
{"pid": "P8869", "type": "P", "difficulty": 1, "samples": [["-1 2", "1"], ["0 -4", "0"], ["-12345 -54321", "-12345"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "传智杯"], "title": "[传智杯 #5 初赛] A-莲子的软件工程学", "background": "在宇宙射线的轰击下，莲子电脑里的一些她自己预定义的函数被损坏了。\n\n对于一名理科生来说，各种软件在学习和研究中是非常重要的。为了尽快恢复她电脑上的软件的正常使用，她需要尽快地重新编写这么一些函数。", "description": "具体而言，给定两个整数 $a,b$，保证 $b\\neq 0$。莲子要实现这样一个函数 $\\operatorname{fun}(a,b)$ 来将 $b$ 的符号转移到 $a$ 上。\n\n具体而言，$\\operatorname{fun}(a,b)=\\operatorname{sgn}(b)\\times |a|$。其中，$\\operatorname{sgn}(b)=\\begin{cases}1&b>0\\\\-1&b<0\\end{cases}$\n\n换而言之：\n\n- 如果 $b$ 是正数，那么 $\\operatorname{fun}(a,b)=+|a|=|a|$；\n- 如果 $b$ 是负数，那么 $\\operatorname{fun}(a,b)=-|a|$。\n", "inputFormat": "- 共一行两个整数 $a,b$。", "outputFormat": "- 共一行一个整数 $\\operatorname{fun}(a,b)$ 的值。", "hint": "对于全部数据，保证 $a,b$ 在 $32$ 位有符号整型范围内，并且 $b \\neq 0$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] A-莲子的软件工程学", "background": "在宇宙射线的轰击下，莲子电脑里的一些她自己预定义的函数被损坏了。\n\n对于一名理科生来说，各种软件在学习和研究中是非常重要的。为了尽快恢复她电脑上的软件的正常使用，她需要尽快地重新编写这么一些函数。", "description": "具体而言，给定两个整数 $a,b$，保证 $b\\neq 0$。莲子要实现这样一个函数 $\\operatorname{fun}(a,b)$ 来将 $b$ 的符号转移到 $a$ 上。\n\n具体而言，$\\operatorname{fun}(a,b)=\\operatorname{sgn}(b)\\times |a|$。其中，$\\operatorname{sgn}(b)=\\begin{cases}1&b>0\\\\-1&b<0\\end{cases}$\n\n换而言之：\n\n- 如果 $b$ 是正数，那么 $\\operatorname{fun}(a,b)=+|a|=|a|$；\n- 如果 $b$ 是负数，那么 $\\operatorname{fun}(a,b)=-|a|$。\n", "inputFormat": "- 共一行两个整数 $a,b$。", "outputFormat": "- 共一行一个整数 $\\operatorname{fun}(a,b)$ 的值。", "hint": "对于全部数据，保证 $a,b$ 在 $32$ 位有符号整型范围内，并且 $b \\neq 0$。", "locale": "zh-CN"}}}
{"pid": "P8870", "type": "P", "difficulty": 2, "samples": [["5 4\n3 3 2 1 1\n3 2 2 1", "4 2 1 1 0\n"], ["10 1\n10 9 8 7 6 5 4 3 2 1\n0\n", "10 9 8 7 6 5 4 3 2 1\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "传智杯"], "title": "[传智杯 #5 初赛] B-莲子的机械动力学", "background": "**【题目背景和题目描述的两个题面是完全等价的，您可以选择阅读其中一部分。】**\n\n专攻超统一物理学的莲子，对机械结构的运动颇有了解。如下图所示，是一个三进制加法计算器的（超简化）示意图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l6gm0j36.png)\n\n一个四位的三进制整数，从低到高位，标为 $x_1,x_2,x_3,x_4$。换言之，这个数可以写成 $\\overline{x_4x_3x_2x_1}_{(3)}$。把它放在这四个齿轮里，对应箭头指向的数字就是现在这位的数值。\n\n在这种机械式计算机里，我们通过齿轮的啮合来实现数位间的连接。通过不同齿轮半径的比例来确定进制。图中所有浅灰色的小齿轮的半径，比上使用皮带相接的较大齿轮的半径，都是 $1:3$。那么小齿轮每转动一圈，大齿轮就转动 $\\dfrac{1}{3}$ 圈，也就是刚好一个数码的角度。\n\n于是，我们通过控制齿轮的半径实现了 $3$ 进制的进位。\n\n如果需要实现三进制加法，则只需要在对应数位拨动对应的数码长度即可。\n\n如下是个例子，实现 $\\overline{1021}_{(3)}+\\overline{0021}_{(3)}=\\overline{1112}_{(3)}$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4kcgnp7j.png)\n\n初始时齿轮的状态如上。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dcd66l5v.png)\n\n把第一个齿轮拨动一个单位长度，变为如上图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oiexg3yw.png)\n\n把第二个齿轮拨动两个单位长度，变为如上图所示。读数，得到结果 $\\overline{1112}_{(3)}$。\n\n---\n\n现在莲子设计了如下图所示的机械结构。对于从左往右数的第 $i$ 枚齿轮，它上面的浅色小齿轮与第 $i+1$ 枚齿轮上的深色小齿轮的半径之比为 $1:(i+2)$。也就是说，第 $i$ 枚齿轮每转动 $1$ 圈，第 $i+1$ 枚齿轮转过的角度恰好为它上面的一个数码。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zi1d0qnn.png)\n\n莲子想要知道，在这样的特别的进制表示下，给定 $a,b$，那么计算出的 $a+b$ 的结果是多少。\n", "description": "题目背景的问题可以转化为如下描述：\n\n给定两个长度分别为 $n,m$ 的整数 $a,b$，计算它们的和。\n\n但是要注意的是，这里的 $a,b$ 采用了某种特殊的进制表示法。最终的结果也会采用该种表示法。具体而言，从低位往高位数起，第 $i$ 位采用的是 $i+1$ 进制。换言之，相较于十进制下每一位的「逢 $10$ 进 $1$」，该种进制下第 $i$ 位是「逢 $i+1$ 进 $1$」。\n\n下图所示，左边是十进制的竖式加法；右边是这种特殊进制的竖式加法。图中的红色加号表示上一位发生了进位。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/px92d6yd.png)", "inputFormat": "- 第一行有两个整数 $n,m$，分别表示 $a$ 和 $b$ 的位数。\n- 第二行有 $n$ 个整数，中间用空格隔开，**从高到低位**描述 $a$ 的每个数码。\n- 第三行有 $m$ 个整数，中间用空格隔开，**从高到低位**描述 $b$ 的每个数码。", "outputFormat": "- 输出有若干个整数，从高到低位输出 $a+b$ 在这种特殊表示法下的结果。", "hint": "对于全部数据，保证 $1\\le n,m\\le 2\\times 10^5$，从低位往高位数起有 $a_i\\in[0,i]$，$b_i\\in[0,i]$。请使用 Java 或 Python 语言作答的选手注意输入输出时的效率。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] B-莲子的机械动力学", "background": "**【题目背景和题目描述的两个题面是完全等价的，您可以选择阅读其中一部分。】**\n\n专攻超统一物理学的莲子，对机械结构的运动颇有了解。如下图所示，是一个三进制加法计算器的（超简化）示意图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l6gm0j36.png)\n\n一个四位的三进制整数，从低到高位，标为 $x_1,x_2,x_3,x_4$。换言之，这个数可以写成 $\\overline{x_4x_3x_2x_1}_{(3)}$。把它放在这四个齿轮里，对应箭头指向的数字就是现在这位的数值。\n\n在这种机械式计算机里，我们通过齿轮的啮合来实现数位间的连接。通过不同齿轮半径的比例来确定进制。图中所有浅灰色的小齿轮的半径，比上使用皮带相接的较大齿轮的半径，都是 $1:3$。那么小齿轮每转动一圈，大齿轮就转动 $\\dfrac{1}{3}$ 圈，也就是刚好一个数码的角度。\n\n于是，我们通过控制齿轮的半径实现了 $3$ 进制的进位。\n\n如果需要实现三进制加法，则只需要在对应数位拨动对应的数码长度即可。\n\n如下是个例子，实现 $\\overline{1021}_{(3)}+\\overline{0021}_{(3)}=\\overline{1112}_{(3)}$\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4kcgnp7j.png)\n\n初始时齿轮的状态如上。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dcd66l5v.png)\n\n把第一个齿轮拨动一个单位长度，变为如上图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oiexg3yw.png)\n\n把第二个齿轮拨动两个单位长度，变为如上图所示。读数，得到结果 $\\overline{1112}_{(3)}$。\n\n---\n\n现在莲子设计了如下图所示的机械结构。对于从左往右数的第 $i$ 枚齿轮，它上面的浅色小齿轮与第 $i+1$ 枚齿轮上的深色小齿轮的半径之比为 $1:(i+2)$。也就是说，第 $i$ 枚齿轮每转动 $1$ 圈，第 $i+1$ 枚齿轮转过的角度恰好为它上面的一个数码。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zi1d0qnn.png)\n\n莲子想要知道，在这样的特别的进制表示下，给定 $a,b$，那么计算出的 $a+b$ 的结果是多少。\n", "description": "题目背景的问题可以转化为如下描述：\n\n给定两个长度分别为 $n,m$ 的整数 $a,b$，计算它们的和。\n\n但是要注意的是，这里的 $a,b$ 采用了某种特殊的进制表示法。最终的结果也会采用该种表示法。具体而言，从低位往高位数起，第 $i$ 位采用的是 $i+1$ 进制。换言之，相较于十进制下每一位的「逢 $10$ 进 $1$」，该种进制下第 $i$ 位是「逢 $i+1$ 进 $1$」。\n\n下图所示，左边是十进制的竖式加法；右边是这种特殊进制的竖式加法。图中的红色加号表示上一位发生了进位。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/px92d6yd.png)", "inputFormat": "- 第一行有两个整数 $n,m$，分别表示 $a$ 和 $b$ 的位数。\n- 第二行有 $n$ 个整数，中间用空格隔开，**从高到低位**描述 $a$ 的每个数码。\n- 第三行有 $m$ 个整数，中间用空格隔开，**从高到低位**描述 $b$ 的每个数码。", "outputFormat": "- 输出有若干个整数，从高到低位输出 $a+b$ 在这种特殊表示法下的结果。", "hint": "对于全部数据，保证 $1\\le n,m\\le 2\\times 10^5$，从低位往高位数起有 $a_i\\in[0,i]$，$b_i\\in[0,i]$。请使用 Java 或 Python 语言作答的选手注意输入输出时的效率。", "locale": "zh-CN"}}}
{"pid": "P8871", "type": "P", "difficulty": 2, "samples": [["#include<iostream>\nusing namespace std;\nint main(){\n    int a, b;\n    cin >> a >> b;\n    cout << a + b << endl;\n    cout << a - b << endl;\n    cout << a * b << endl;\n    cout << a / b << endl;\n    return 0;\n}\n", " 1 #include<iostream>\n 2 using namespace std;\n 3 int main(){\n 4     int a, b;\n 5     cin >> a >> b;\n 6     cout << a + b << endl;\n 7     cout << a - b << endl;\n 8     cout << a * b << endl;\n 9     cout << a / b << endl;\n10     return 0;\n11 }\n"], ["public class Main {\n    public static void main(String[] args) throws Exception {\n        int b = 0, c = 0;\n        for (int a = 123; a < 333; a++) {\n            int[] array = new int[10];\n            Boolean flag = true;\n            b = a * 2;\n            c = a * 3;\n            array[a / 100] = 1;\n            array[a / 10 % 10] = 1;\n            array[a % 10] = 1;\n\n            array[b / 100] = 1;\n            array[b / 10 % 10] = 1;\n            array[b % 10] = 1;\n\n            array[c / 100] = 1;\n            array[c / 10 % 10] = 1;\n            array[c % 10] = 1;\n            for (int i = 1; i < array.length; i++) {\n                if (array[i] != 1) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag)\n                System.out.println(a + \" \" + b + \" \" + c);\n        }\n    }\n}", " 1 public class Main {\n 2     public static void main(String[] args) throws Exception {\n 3         int b = 0, c = 0;\n 4         for (int a = 123; a < 333; a++) {\n 5             int[] array = new int[10];\n 6             Boolean flag = true;\n 7             b = a * 2;\n 8             c = a * 3;\n 9             array[a / 100] = 1;\n10             array[a / 10 % 10] = 1;\n11             array[a % 10] = 1;\n12 \n13             array[b / 100] = 1;\n14             array[b / 10 % 10] = 1;\n15             array[b % 10] = 1;\n16 \n17             array[c / 100] = 1;\n18             array[c / 10 % 10] = 1;\n19             array[c % 10] = 1;\n20             for (int i = 1; i < array.length; i++) {\n21                 if (array[i] != 1) {\n22                     flag = false;\n23                     break;\n24                 }\n25             }\n26             if (flag)\n27                 System.out.println(a + \" \" + b + \" \" + c);\n28         }\n29     }\n30 }\n"], ["Tao hua kai yo li hua kai, jie jie mei mei dong qi lai;\nTao hua kai yo li hua kai, jie jie mei mei tiao qi lai.\n    Gei ni zi ji, chun yi mai huai (yi ya yo);\n    Gei xin shang ren, chun se man kai.\nTao hua kai yo li hua kai, jie jie mei mei dong qi lai; \nTao hua kai yo li hua kai, jie jie mei mei tiao qi lai.\n    Gei tong bao men, chun yi man huai, hai hai yo;\n    Gei zhe da di, chun se quan kai!!!\nCong na nu jiang nan, dao mo he bei,\n    Dao chu dou you hua rong ming mei.\nLai hui hui shou, zai diao ge tou,\n    Wu xian chun guang zai wo xiong.\nCong jing cheng, dao yuan ye,\n    Dao chu dou you sheng de xi yue.\nLai hui hui shou, zai yan ran huang ge tou,\n    Wu xian CHUN GUANG XIAN ZU GUO!!!\nTao hua kai yo li hua kai, Jiong xian mei mei dong qi lai;\nTao hua kai yo li hua kai, Jie jie mei mei tiao qi lai.\n    Gei ni zi ji, chun yi mai huai chun yi man huai yi ya yo;\n    Gei xin shang ren, chun se man kai chun se man kai.\nTao hua kai yo li hua kai, Jie jie mei mei dong qi lai;\nTao hua kai yo li hua kai, Jie jie mei mei tiao qi lai.\n    Gei tong bao men, chun yi man huai, hai hai yo;\n    Gei zhe da di, chun se quan kai!!!\nCong na nu jiang nan, dao mo he bei,\n    Dao chu dou you hua rong ming mei.\nLai hui hui shou, zai diao ge tou,\n    Wu xian chun guang zai wo xiong.\nCong jing cheng, dao yuan ye,\n    Dao chu dou you sheng de xi yue.\nLai hui hui shou, zai yan ran huang ge tou,\n    Wu xian CHUN GUANG XIAN ZU GUO!!!\nLai hui hui shou, zai yan ran huang ge tou,\n    Wu xian CHUN GUANG XIAN ZU GUO!!!\n", " 1 Tao hua kai yo li hua kai, jie jie mei mei dong qi lai;\n 2 Tao hua kai yo li hua kai, jie jie mei mei tiao qi lai.\n 3     Gei ni zi ji, chun yi mai huai (yi ya yo);\n 4     Gei xin shang ren, chun se man kai.\n 5 Tao hua kai yo li hua kai, jie jie mei mei dong qi lai; \n 6 Tao hua kai yo li hua kai, jie jie mei mei tiao qi lai.\n 7     Gei tong bao men, chun yi man huai, hai hai yo;\n 8     Gei zhe da di, chun se quan kai!!!\n 9 Cong na nu jiang nan, dao mo he bei,\n10     Dao chu dou you hua rong ming mei.\n11 Lai hui hui shou, zai diao ge tou,\n12     Wu xian chun guang zai wo xiong.\n13 Cong jing cheng, dao yuan ye,\n14     Dao chu dou you sheng de xi yue.\n15 Lai hui hui shou, zai yan ran huang ge tou,\n16     Wu xian CHUN GUANG XIAN ZU GUO!!!\n17 Tao hua kai yo li hua kai, Jiong xian mei mei dong qi lai;\n18 Tao hua kai yo li hua kai, Jie jie mei mei tiao qi lai.\n19     Gei ni zi ji, chun yi mai huai chun yi man huai yi ya yo;\n20     Gei xin shang ren, chun se man kai chun se man kai.\n21 Tao hua kai yo li hua kai, Jie jie mei mei dong qi lai;\n22 Tao hua kai yo li hua kai, Jie jie mei mei tiao qi lai.\n23     Gei tong bao men, chun yi man huai, hai hai yo;\n24     Gei zhe da di, chun se quan kai!!!\n25 Cong na nu jiang nan, dao mo he bei,\n26     Dao chu dou you hua rong ming mei.\n27 Lai hui hui shou, zai diao ge tou,\n28     Wu xian chun guang zai wo xiong.\n29 Cong jing cheng, dao yuan ye,\n30     Dao chu dou you sheng de xi yue.\n31 Lai hui hui shou, zai yan ran huang ge tou,\n32     Wu xian CHUN GUANG XIAN ZU GUO!!!\n33 Lai hui hui shou, zai yan ran huang ge tou,\n34     Wu xian CHUN GUANG XIAN ZU GUO!!!\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "传智杯"], "title": "[传智杯 #5 初赛] C-莲子的排版设计学", "background": "> 你现在不能休息，周围有 deadline 在游荡。\n\n莲子正在赶自己的程序设计作业。除了完成程序代码的编写，对提交上去的作业进行排版以对助教留下良好印象同样重要。\n\n而众所周知，文章里面的代码和一些特殊性质的文本是要附上行号的，然而它们的篇幅往往都很长，手动去加容易出现失误。因此，莲子决定自力更生造轮子，写一个行号生成器。", "description": "莲子希望实现这样一个功能：输入一份文本文件，并给该文件加上行号。\n\n以下是本题中三个基本概念的定义：\n\n- **文本字符**由 $\\textsf{ASCII}$ 中所有的可视字符，以及空格（$\\textsf{ASCII}=32$）组成。\n- **一行字符**由若干个（可以为 $0$ 个）文本字符，以及在末尾**恰好一个**换行符（$\\textsf{ASCII}=10$）组成。\n- **文本文件**由若干个（至少为 $1$ 个）一行字符组成。文本文件的行数就是组成它的行的数量。\n\n以下是本题中添加行号的方法：\n\n- 设该文本文件一共有 $m$ 行。设正整数 $m$ 的字宽为 $s$。那么，在每一行的开头会有 $s+1$ 的长度用来显示行号。\n- 对于第 $i$ 行，假设 $i$ 的字宽为 $t$，那么这一行行号将会显示为 $\\underbrace{\\texttt{␣␣...␣}}_{s-t\\text{ 个}}\\ i\\ \\texttt{␣}$，其中 $\\texttt{␣}$ 表示空格。\n\n以下是一个例子：\n\n\n$$\\boxed{\\begin{aligned}\n&\\verb!#include<iostream>!\\\\\n&\\verb!using namespace std;!\\\\\n&\\verb!int main(){!\\\\\n&\\verb!    int a, b;!\\\\\n&\\verb!    cin >> a >> b;!\\\\\n&\\verb!    cout << a + b << endl;!\\\\\n&\\verb!    cout << a - b << endl;!\\\\\n&\\verb!    cout << a * b << endl;!\\\\\n&\\verb!    cout << a / b << endl;!\\\\\n&\\verb!    return 0;!\\\\\n&\\verb!}!\n\\end{aligned}} \\Rightarrow\n\\boxed{\\begin{aligned}\n&\\verb! 1 #include<iostream>!\\\\\n&\\verb! 2 using namespace std;!\\\\\n&\\verb! 3 int main(){!\\\\\n&\\verb! 4     int a, b;!\\\\\n&\\verb! 5     cin >> a >> b;!\\\\\n&\\verb! 6     cout << a + b << endl;!\\\\\n&\\verb! 7     cout << a - b << endl;!\\\\\n&\\verb! 8     cout << a * b << endl;!\\\\\n&\\verb! 9     cout << a / b << endl;!\\\\\n&\\verb!10     return 0;!\\\\\n&\\verb!11 }!\n\\end{aligned}}\n$$\n\n为了便于读者观察，这里将所有的空格换成用来表示空格的 $\\verb!␣!$ 字符。\n\n$$\\boxed{\\begin{aligned}\n&\\verb!#include<iostream>!\\\\\n&\\verb!using␣namespace␣std;!\\\\\n&\\verb!int␣main(){!\\\\\n&\\verb!␣␣␣␣int␣a,␣b;!\\\\\n&\\verb!␣␣␣␣cin␣>>␣a␣>>␣b;!\\\\\n&\\verb!␣␣␣␣cout␣<<␣a␣+␣b␣<<␣endl;!\\\\\n&\\verb!␣␣␣␣cout␣<<␣a␣-␣b␣<<␣endl;!\\\\\n&\\verb!␣␣␣␣cout␣<<␣a␣*␣b␣<<␣endl;!\\\\\n&\\verb!␣␣␣␣cout␣<<␣a␣/␣b␣<<␣endl;!\\\\\n&\\verb!␣␣␣␣return␣0;!\\\\\n&\\verb!}!\n\\end{aligned}} \\Rightarrow\n\\boxed{\\begin{aligned}\n&\\verb!␣1␣#include<iostream>!\\\\\n&\\verb!␣2␣using␣namespace␣std;!\\\\\n&\\verb!␣3␣int␣main(){!\\\\\n&\\verb!␣4␣␣␣␣␣int␣a,␣b;!\\\\\n&\\verb!␣5␣␣␣␣␣cin␣>>␣a␣>>␣b;!\\\\\n&\\verb!␣6␣␣␣␣␣cout␣<<␣a␣+␣b␣<<␣endl;!\\\\\n&\\verb!␣7␣␣␣␣␣cout␣<<␣a␣-␣b␣<<␣endl;!\\\\\n&\\verb!␣8␣␣␣␣␣cout␣<<␣a␣*␣b␣<<␣endl;!\\\\\n&\\verb!␣9␣␣␣␣␣cout␣<<␣a␣/␣b␣<<␣endl;!\\\\\n&\\verb!10␣␣␣␣␣return␣0;!\\\\\n&\\verb!11␣}!\n\\end{aligned}}\n$$", "inputFormat": "输入包含若干行，为原始的文本文件。", "outputFormat": "输出包含若干行，为加上行号后的文本文件。", "hint": "### 数据范围及约定\n\n对于全部数据，保证输入的文本文件的字符总数（包括换行符在内），不超过 $2\\times 10^4$。同时，保证输入数据合法。\n\n评测时，会忽略选手输出文件的行末空格与文末换行。因此选手可以自行决定行尾是否要输出多余空格。请使用 Java 或 Python 语言作答的选手注意输入输出时的效率。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] C-莲子的排版设计学", "background": "> 你现在不能休息，周围有 deadline 在游荡。\n\n莲子正在赶自己的程序设计作业。除了完成程序代码的编写，对提交上去的作业进行排版以对助教留下良好印象同样重要。\n\n而众所周知，文章里面的代码和一些特殊性质的文本是要附上行号的，然而它们的篇幅往往都很长，手动去加容易出现失误。因此，莲子决定自力更生造轮子，写一个行号生成器。", "description": "莲子希望实现这样一个功能：输入一份文本文件，并给该文件加上行号。\n\n以下是本题中三个基本概念的定义：\n\n- **文本字符**由 $\\textsf{ASCII}$ 中所有的可视字符，以及空格（$\\textsf{ASCII}=32$）组成。\n- **一行字符**由若干个（可以为 $0$ 个）文本字符，以及在末尾**恰好一个**换行符（$\\textsf{ASCII}=10$）组成。\n- **文本文件**由若干个（至少为 $1$ 个）一行字符组成。文本文件的行数就是组成它的行的数量。\n\n以下是本题中添加行号的方法：\n\n- 设该文本文件一共有 $m$ 行。设正整数 $m$ 的字宽为 $s$。那么，在每一行的开头会有 $s+1$ 的长度用来显示行号。\n- 对于第 $i$ 行，假设 $i$ 的字宽为 $t$，那么这一行行号将会显示为 $\\underbrace{\\texttt{␣␣...␣}}_{s-t\\text{ 个}}\\ i\\ \\texttt{␣}$，其中 $\\texttt{␣}$ 表示空格。\n\n以下是一个例子：\n\n\n$$\\boxed{\\begin{aligned}\n&\\verb!#include<iostream>!\\\\\n&\\verb!using namespace std;!\\\\\n&\\verb!int main(){!\\\\\n&\\verb!    int a, b;!\\\\\n&\\verb!    cin >> a >> b;!\\\\\n&\\verb!    cout << a + b << endl;!\\\\\n&\\verb!    cout << a - b << endl;!\\\\\n&\\verb!    cout << a * b << endl;!\\\\\n&\\verb!    cout << a / b << endl;!\\\\\n&\\verb!    return 0;!\\\\\n&\\verb!}!\n\\end{aligned}} \\Rightarrow\n\\boxed{\\begin{aligned}\n&\\verb! 1 #include<iostream>!\\\\\n&\\verb! 2 using namespace std;!\\\\\n&\\verb! 3 int main(){!\\\\\n&\\verb! 4     int a, b;!\\\\\n&\\verb! 5     cin >> a >> b;!\\\\\n&\\verb! 6     cout << a + b << endl;!\\\\\n&\\verb! 7     cout << a - b << endl;!\\\\\n&\\verb! 8     cout << a * b << endl;!\\\\\n&\\verb! 9     cout << a / b << endl;!\\\\\n&\\verb!10     return 0;!\\\\\n&\\verb!11 }!\n\\end{aligned}}\n$$\n\n为了便于读者观察，这里将所有的空格换成用来表示空格的 $\\verb!␣!$ 字符。\n\n$$\\boxed{\\begin{aligned}\n&\\verb!#include<iostream>!\\\\\n&\\verb!using␣namespace␣std;!\\\\\n&\\verb!int␣main(){!\\\\\n&\\verb!␣␣␣␣int␣a,␣b;!\\\\\n&\\verb!␣␣␣␣cin␣>>␣a␣>>␣b;!\\\\\n&\\verb!␣␣␣␣cout␣<<␣a␣+␣b␣<<␣endl;!\\\\\n&\\verb!␣␣␣␣cout␣<<␣a␣-␣b␣<<␣endl;!\\\\\n&\\verb!␣␣␣␣cout␣<<␣a␣*␣b␣<<␣endl;!\\\\\n&\\verb!␣␣␣␣cout␣<<␣a␣/␣b␣<<␣endl;!\\\\\n&\\verb!␣␣␣␣return␣0;!\\\\\n&\\verb!}!\n\\end{aligned}} \\Rightarrow\n\\boxed{\\begin{aligned}\n&\\verb!␣1␣#include<iostream>!\\\\\n&\\verb!␣2␣using␣namespace␣std;!\\\\\n&\\verb!␣3␣int␣main(){!\\\\\n&\\verb!␣4␣␣␣␣␣int␣a,␣b;!\\\\\n&\\verb!␣5␣␣␣␣␣cin␣>>␣a␣>>␣b;!\\\\\n&\\verb!␣6␣␣␣␣␣cout␣<<␣a␣+␣b␣<<␣endl;!\\\\\n&\\verb!␣7␣␣␣␣␣cout␣<<␣a␣-␣b␣<<␣endl;!\\\\\n&\\verb!␣8␣␣␣␣␣cout␣<<␣a␣*␣b␣<<␣endl;!\\\\\n&\\verb!␣9␣␣␣␣␣cout␣<<␣a␣/␣b␣<<␣endl;!\\\\\n&\\verb!10␣␣␣␣␣return␣0;!\\\\\n&\\verb!11␣}!\n\\end{aligned}}\n$$", "inputFormat": "输入包含若干行，为原始的文本文件。", "outputFormat": "输出包含若干行，为加上行号后的文本文件。", "hint": "### 数据范围及约定\n\n对于全部数据，保证输入的文本文件的字符总数（包括换行符在内），不超过 $2\\times 10^4$。同时，保证输入数据合法。\n\n评测时，会忽略选手输出文件的行末空格与文末换行。因此选手可以自行决定行尾是否要输出多余空格。请使用 Java 或 Python 语言作答的选手注意输入输出时的效率。", "locale": "zh-CN"}}}
{"pid": "P8872", "type": "P", "difficulty": 3, "samples": [["3 2\n5 1 4", "0"], ["8 0\n1 2 3 4 5 6 7 8", "7\n"], ["8 3\n1 5 5 5 6 6 9 10\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "传智杯"], "title": "[传智杯 #5 初赛] D-莲子的物理热力学", "background": "莲子正在研究分子的运动。\n\n每个分子都有一个速度，约定正方向为正，负方向为负。分子的数量极多，速度又并不一致，看上去杂乱无章。于是莲子希望调整部分分子的速度，使得最终分子们看上去整齐。", "description": "莲子给定了 $n$ 个整数 $a_1,a_2,\\cdots a_n$，描述每个分子。现在她可以进行**至多** $m$ 次操作（也可以一次也不进行），每次操作可以执行以下两条之一：\n\n- 选择 $i$，满足 $a_i=\\min_j\\{a_j\\}$，然后将 $a_i$ 变为 $\\max_j\\{a_j\\}$。\n- 选择 $i$，满足 $a_i=\\max_j\\{a_j\\}$，然后将 $a_i$ 变为 $\\min_j\\{a_j\\}$。\n\n现在莲子希望需要最小化最终序列的极差（最大值减去最小值的差）。请求出最小的极差。\n\n---\n\n例如，对于序列 $a=\\{5,1,4\\}$，可以进行如下几次操作：\n\n- 选择 $i=1$，满足 $a_1=5$ 是当前的最大值 $5$，可以将 $a_1$ 修改成当前的最小值 $1$，此时序列变成 $\\{1,1,4\\}$；\n- 再选 $i=2$，满足 $a_2=1$ 是当前的最小值 $1$，可以将 $a_2$ 修改成当前的最大值 $4$，此时序列变成 $\\{1,4,4\\}$。 \n\n这两次操作后得到的序列为 $\\{1,4,4\\}$。最大值减去最小值的差为 $|4-1|=3$。\n\n当然，这种操作方式得到的极差并非最小。最优策略是，先将最大值 $a_1=5$ 变成目前的最小值 $1$，再把此时的最大值 $a_3=4$ 变成目前的最小值 $1$。此时序列为 $\\{1,1,1\\}$，得到的极差 $|1-1|=0$ 是所有策略中最小的。\n\n", "inputFormat": "- 第一行有两个正整数 $n,m$，分别表示序列的长度和你最多可以进行的操作次数。\n- 第二行有 $n$ 个整数 $a$，描述给定的序列。", "outputFormat": "- 输出共一行一个整数，表示最优策略下能得到的最小极差。", "hint": "### 样例解释\n\n样例 $1$：$\\{5,1,4\\}\\to\\{1,1,4\\}\\to\\{1,1,1\\}$，极差为 $0$。  \n样例 $2$：$\\{1,2,3,4,5,6,7,8\\}$，什么也做不了，极差为 $7$。  \n样例 $3$：$\\{1,5,5,5,6,6,9,10\\}\\to\\{10,5,5,5,6,6,9,10\\}\\to\\{5,5,5,5,6,6,9,10\\}\\to\\{5,5,5,5,6,6,9,5\\}$，极差为 $4$。\n\n### 数据范围及约定\n\n对于全部数据，保证 $1\\le n \\le 10^5$，$0\\le m\\le10^9$，$|a_i|\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] D-莲子的物理热力学", "background": "莲子正在研究分子的运动。\n\n每个分子都有一个速度，约定正方向为正，负方向为负。分子的数量极多，速度又并不一致，看上去杂乱无章。于是莲子希望调整部分分子的速度，使得最终分子们看上去整齐。", "description": "莲子给定了 $n$ 个整数 $a_1,a_2,\\cdots a_n$，描述每个分子。现在她可以进行**至多** $m$ 次操作（也可以一次也不进行），每次操作可以执行以下两条之一：\n\n- 选择 $i$，满足 $a_i=\\min_j\\{a_j\\}$，然后将 $a_i$ 变为 $\\max_j\\{a_j\\}$。\n- 选择 $i$，满足 $a_i=\\max_j\\{a_j\\}$，然后将 $a_i$ 变为 $\\min_j\\{a_j\\}$。\n\n现在莲子希望需要最小化最终序列的极差（最大值减去最小值的差）。请求出最小的极差。\n\n---\n\n例如，对于序列 $a=\\{5,1,4\\}$，可以进行如下几次操作：\n\n- 选择 $i=1$，满足 $a_1=5$ 是当前的最大值 $5$，可以将 $a_1$ 修改成当前的最小值 $1$，此时序列变成 $\\{1,1,4\\}$；\n- 再选 $i=2$，满足 $a_2=1$ 是当前的最小值 $1$，可以将 $a_2$ 修改成当前的最大值 $4$，此时序列变成 $\\{1,4,4\\}$。 \n\n这两次操作后得到的序列为 $\\{1,4,4\\}$。最大值减去最小值的差为 $|4-1|=3$。\n\n当然，这种操作方式得到的极差并非最小。最优策略是，先将最大值 $a_1=5$ 变成目前的最小值 $1$，再把此时的最大值 $a_3=4$ 变成目前的最小值 $1$。此时序列为 $\\{1,1,1\\}$，得到的极差 $|1-1|=0$ 是所有策略中最小的。\n\n", "inputFormat": "- 第一行有两个正整数 $n,m$，分别表示序列的长度和你最多可以进行的操作次数。\n- 第二行有 $n$ 个整数 $a$，描述给定的序列。", "outputFormat": "- 输出共一行一个整数，表示最优策略下能得到的最小极差。", "hint": "### 样例解释\n\n样例 $1$：$\\{5,1,4\\}\\to\\{1,1,4\\}\\to\\{1,1,1\\}$，极差为 $0$。  \n样例 $2$：$\\{1,2,3,4,5,6,7,8\\}$，什么也做不了，极差为 $7$。  \n样例 $3$：$\\{1,5,5,5,6,6,9,10\\}\\to\\{10,5,5,5,6,6,9,10\\}\\to\\{5,5,5,5,6,6,9,10\\}\\to\\{5,5,5,5,6,6,9,5\\}$，极差为 $4$。\n\n### 数据范围及约定\n\n对于全部数据，保证 $1\\le n \\le 10^5$，$0\\le m\\le10^9$，$|a_i|\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P8873", "type": "P", "difficulty": 3, "samples": [["9\n1\n10\n100\n1000\n10000\n100000\n1000000\n10000000\n100000000", "0\n1\n6\n-9\n-11\n-128\n406\n1629\n5154"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "二分", "传智杯"], "title": "[传智杯 #5 初赛] E-梅莉的市场经济学", "background": "梅莉这个学期选修了经济学。但是主修心理学的她实在不擅长经济领域的分析，为此她时常抱怨自己学不会，想退课。\n\n但是如果现在退掉的话这学期的学分就不够啦，因此她根据“梦中”的经历，“胡诌”了一个简单到不现实的市场模型，并依据这个模型编起了 essay。为了方便地编出图表，她需要写一个程序来查询每个时刻的市场贸易差。", "description": "市场每一天的贸易差可以视为一个有周期性规律的数列 $a$：$\\color{red}[0],\\color{blue}[0,\\allowbreak 1,\\allowbreak 0,\\allowbreak -1,\\allowbreak 0],\\color{red}[0,\\allowbreak 1,\\allowbreak 2,\\allowbreak 1,\\allowbreak 0,\\allowbreak -1,\\allowbreak -2,\\allowbreak -1,\\allowbreak 0],\\allowbreak \\color{blue}[0,\\allowbreak 1,\\allowbreak 2,\\allowbreak 3,\\allowbreak 2,\\allowbreak 1,\\allowbreak 0,\\allowbreak -1,\\allowbreak -2,\\allowbreak -3,\\allowbreak -2,\\allowbreak -1,\\allowbreak 0]\\dots$ 具体而言，$a$ 可以被分为无穷段，第 $i$ 段的内容为 $\\{0,\\allowbreak 1,\\allowbreak \\cdots,\\allowbreak i,\\allowbreak i-1,\\allowbreak \\cdots,0,\\allowbreak -1,\\allowbreak \\cdots,\\allowbreak -i,\\allowbreak -i+1,\\allowbreak \\cdots 0\\}$。如下图所示，是将 $a$ 数列内的前一些点绘制在坐标轴上的情况：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wrl89jka.png)\n\n现在梅莉对市场发起了 $q$ 次询问，每次她会给定一个 $k$，希望求出 $a_k$ 是多少。", "inputFormat": "- 第一行有一个正整数 $q$，表示询问次数。\n- 接下来 $q$ 行，每行一个正整数 $k$，描述每次询问。", "outputFormat": "- 输出共 $q$ 行。对于每次询问，输出对应的结果。", "hint": "对于所有数据，$1 \\leq q \\leq 10^5$，$1 \\leq k \\leq 4\\times 10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] E-梅莉的市场经济学", "background": "梅莉这个学期选修了经济学。但是主修心理学的她实在不擅长经济领域的分析，为此她时常抱怨自己学不会，想退课。\n\n但是如果现在退掉的话这学期的学分就不够啦，因此她根据“梦中”的经历，“胡诌”了一个简单到不现实的市场模型，并依据这个模型编起了 essay。为了方便地编出图表，她需要写一个程序来查询每个时刻的市场贸易差。", "description": "市场每一天的贸易差可以视为一个有周期性规律的数列 $a$：$\\color{red}[0],\\color{blue}[0,\\allowbreak 1,\\allowbreak 0,\\allowbreak -1,\\allowbreak 0],\\color{red}[0,\\allowbreak 1,\\allowbreak 2,\\allowbreak 1,\\allowbreak 0,\\allowbreak -1,\\allowbreak -2,\\allowbreak -1,\\allowbreak 0],\\allowbreak \\color{blue}[0,\\allowbreak 1,\\allowbreak 2,\\allowbreak 3,\\allowbreak 2,\\allowbreak 1,\\allowbreak 0,\\allowbreak -1,\\allowbreak -2,\\allowbreak -3,\\allowbreak -2,\\allowbreak -1,\\allowbreak 0]\\dots$ 具体而言，$a$ 可以被分为无穷段，第 $i$ 段的内容为 $\\{0,\\allowbreak 1,\\allowbreak \\cdots,\\allowbreak i,\\allowbreak i-1,\\allowbreak \\cdots,0,\\allowbreak -1,\\allowbreak \\cdots,\\allowbreak -i,\\allowbreak -i+1,\\allowbreak \\cdots 0\\}$。如下图所示，是将 $a$ 数列内的前一些点绘制在坐标轴上的情况：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wrl89jka.png)\n\n现在梅莉对市场发起了 $q$ 次询问，每次她会给定一个 $k$，希望求出 $a_k$ 是多少。", "inputFormat": "- 第一行有一个正整数 $q$，表示询问次数。\n- 接下来 $q$ 行，每行一个正整数 $k$，描述每次询问。", "outputFormat": "- 输出共 $q$ 行。对于每次询问，输出对应的结果。", "hint": "对于所有数据，$1 \\leq q \\leq 10^5$，$1 \\leq k \\leq 4\\times 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P8874", "type": "P", "difficulty": 3, "samples": [["6 40 5 3\n10 20 30\n15 25 35\n6 8 12\n6 12 18\n8 16 24\n8 12 40\n1 2 3 4 5 6\n1 4\n2 3\n1 2\n2 5\n1 3\n1 2\n2 1\n1 5\n2 3\n1 3\n2 4\n1 4\n1 6\n2 2\n1 3\n2 1\n1 3\n2 1", "Merry"], ["6 9961 5 3\n10 20 30\n15 25 35\n6 8 12\n6 12 18\n8 16 24\n8 12 40\n1 2 3 4 5 6\n1 4\n2 3\n1 2\n2 5\n1 3\n1 2\n2 1\n1 5\n2 3\n1 3\n2 4\n1 4\n1 6\n2 2\n1 3\n2 1\n1 3\n2 1", "10099 9946"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "传智杯"], "title": "[传智杯 #5 初赛] F-二人的大富翁游戏", "background": "作为大学生，莲子和梅莉有着比高中时更为闲暇的课余时光。在没有课的时候，她们喜欢玩大富翁这一游戏，在游玩过程中交流自己的喜怒哀乐。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/u7z3486k.png)\n\n如图所示，是一个 $n=10$ 的大富翁地图。玩家在圆格子上行动。而方格子则可以建造建筑物。每个圆格子唯一对应一个方格子。\n\n**（友情提示：赌博是不对的）**", "description": "莲子和梅莉在玩大富翁游戏。这个大富翁游戏是由传智播客定制的，**与一般的大富翁游戏在玩法上有略微区别**，因此也被称为传智大富翁。\n\n大富翁游戏是由 $n$ 个格子组成，编号逆时针地从 $1,2,\\dots,n$，构成了一个环。莲子和梅莉起始在编号为 $1$ 的格子。莲子和梅莉最开始都有 $m$ 元资金。每一个回合，莲子先投掷骰子，再是梅莉投掷骰子。每一方行动时，设骰子最上面的数字为 $k$，则行动方逆时针移动 $k$ 步。在移动的过程中，行动者所经过的每一个格子应当都分为两种情况：\n\n- 如果当前格子（假设编号为 $i$）上有建筑物，而且建筑物是自己的，则行动方可以获得额外的 $a_i$ 元资金。\n- 如果当前格子上有建筑物，但是建筑物是对方的，则行动方要将自己的 $a_i$ 元资金转移给对方。\n\n在行动结束后亦有两种情况：\n\n- 如果当前格子（设编号为 $i$）上没有建筑物，则行动方可以选择花费 $C_{i,0}$ 元资金（前提要求行动者当前的资金大于等于 $C_{i,0}$）搭建建筑物，此时 $a_i$ 被初始化为 $C_{i,0}$。\n- 如果当前格子的建筑物是行动方的，假设当前是一座 $j$ 等级的建筑物，那么行动方可以选择用 $C_{i,j}$ 元为建筑物升级，功效是使得 $a_i \\gets a_i+C_{i,j}$。这里，$C_{i,j}$ 表示将第 $i$ 个格子上的第 $j$ 等级的建筑物升级到第 $j+1$ 等级的建筑物所需花费的资金。同一回合内可以多次升级建筑。特别地，建筑物的等级上限为 $L$。如果当前建筑物等级已经到达上限则无法升级。\n- 在所有建筑操作结束后，操作权转移给另一方。\n\n两人都操作完一轮回合后，圆环上的每个建筑物都会提供给拥有者资金，具体来说，第 $i$ 格上的建筑物会给其拥有者提供 $d_i$ 的资金。游戏结束当且仅当存在一个人在它行动过程中或者结束时的资金为负数。此时这个人成为输家（换而言之，允许中途过程资金为 $0$）。\n\n给定莲子和梅莉的 $q$ 个回合的每次操作，请问谁会是输家呢？", "inputFormat": "第一行输入四个正整数 $n,m,q,L$，表示格子数、初始资金、回合次数和建筑物等级上限。\n\n第二行开始，往下 $n$ 行，每行输入 $L$ 个正整数，表示 $C_{i,j}$，其中 $j$ 是从 $0$ 到 $L-1$。\n\n第 $(n+2)$ 行输入 $n$ 个正整数表示 $d_i$。\n\n第 $(n+3)$ 行开始，往下若干行，每行只会有两种可能的情况：\n\n- $\\texttt{1 k}$，表示当前行动方投掷了骰子，最上面的点数是 $k$。之后行动者会逆时针移动 $k$ 步。\n- $\\texttt{2 k}$，表示当前行动方在当前位置**建造或者升级**了建筑物共 $k$ 次。\n  - 在此过程中，当前位置已经有了对方建筑物则忽略此操作；\n  - 如果资金不够升级 $k$ 次，则只升级到资金允许范围内的最高等级；\n  - 在此过程中，如果进行下一次升级，建筑物等级超过 $L$，则后续的所有升级忽略处理。\n\n特别地，规定除了第一次外，每次 $\\texttt{1 k}$ 操作出现时意味着行动者的切换。也就是说，第一次输入 $\\texttt{1 k}$ 操作时，行动方是莲子，第二次是梅莉，第三次是莲子……以此类推。值得注意的是，$\\texttt{2 k}$ 操作出现**并不会**切换行动者。\n\n此外，**保证每个 $\\bm 1$ 操作后面最多跟随 $\\bm 1$ 个 $\\bm 2$ 操作**。", "outputFormat": "如果已经分出了输赢，则输出谁是输家（如果莲子输，则输出 $\\texttt{Renko}$；如果梅莉输，则输出 $\\texttt{Merry}$）；\n\n如果没有分出输赢，则按照先莲子，后梅莉的顺序输出她们现在有的资金数。", "hint": "**【样例解释 1】**\n\n第一回合，莲子首先走 $4$ 步，到达编号为 $5$ 的格子，同时尝试建造与升级 $3$ 次第五个格子的建筑物，但是 $C_{5,0}+C_{5,1}+C_{5,2}=48$，所以只能把建筑物造到 $2$ 级。此时莲子手上还有 $16$ 元。    \n接着梅莉走了两步，到达编号为 $3$ 的格子，同时尝试建造与升级 $5$ 次第三个格子的建筑物，$C_{3,0}+C_{3,1}+C_{3,2}=26$，而造五次会超过等级上限 $L$，因此只能升到 $3$ 次，此时梅莉手上还有 $14$ 元。    \n回合结束后每个建筑物都会提供给拥有者 $d_i$ 的资金，也就是说莲子此时手上有 $21$ 元，梅莉手上有 $17$ 元。    \n第二回合，莲子首先走 $3$ 步，到达编号为 $2$ 的格子。梅莉接着走 $2$ 步，到达编号为 $5$ 的格子，收取 $a_i$ 元。而 $a_i=24$，因此梅莉的资金被扣成了负数，从而输出 $\\texttt{Merry}$。\n\n**【样例解释 2】**\n\n仅在初始资金与第一组样例有一定变化，因此在这些回合中无法决出胜负，因此输出两人手上现有的资金。\n\n**【数据范围】**\n\n对于所有数据，保证 $1 \\leq n,L\\leq 100$，$1 \\leq q \\leq 10^4$，$1 \\leq m,C_{i,j},d_i \\leq 10^6$，$1 \\leq k \\leq 10^3$（你可以不必在意怎么获得一个 $k$ 面的骰子）。数据保证 $1$ 操作次数恰好为 $2\\times q$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] F-二人的大富翁游戏", "background": "作为大学生，莲子和梅莉有着比高中时更为闲暇的课余时光。在没有课的时候，她们喜欢玩大富翁这一游戏，在游玩过程中交流自己的喜怒哀乐。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/u7z3486k.png)\n\n如图所示，是一个 $n=10$ 的大富翁地图。玩家在圆格子上行动。而方格子则可以建造建筑物。每个圆格子唯一对应一个方格子。\n\n**（友情提示：赌博是不对的）**", "description": "莲子和梅莉在玩大富翁游戏。这个大富翁游戏是由传智播客定制的，**与一般的大富翁游戏在玩法上有略微区别**，因此也被称为传智大富翁。\n\n大富翁游戏是由 $n$ 个格子组成，编号逆时针地从 $1,2,\\dots,n$，构成了一个环。莲子和梅莉起始在编号为 $1$ 的格子。莲子和梅莉最开始都有 $m$ 元资金。每一个回合，莲子先投掷骰子，再是梅莉投掷骰子。每一方行动时，设骰子最上面的数字为 $k$，则行动方逆时针移动 $k$ 步。在移动的过程中，行动者所经过的每一个格子应当都分为两种情况：\n\n- 如果当前格子（假设编号为 $i$）上有建筑物，而且建筑物是自己的，则行动方可以获得额外的 $a_i$ 元资金。\n- 如果当前格子上有建筑物，但是建筑物是对方的，则行动方要将自己的 $a_i$ 元资金转移给对方。\n\n在行动结束后亦有两种情况：\n\n- 如果当前格子（设编号为 $i$）上没有建筑物，则行动方可以选择花费 $C_{i,0}$ 元资金（前提要求行动者当前的资金大于等于 $C_{i,0}$）搭建建筑物，此时 $a_i$ 被初始化为 $C_{i,0}$。\n- 如果当前格子的建筑物是行动方的，假设当前是一座 $j$ 等级的建筑物，那么行动方可以选择用 $C_{i,j}$ 元为建筑物升级，功效是使得 $a_i \\gets a_i+C_{i,j}$。这里，$C_{i,j}$ 表示将第 $i$ 个格子上的第 $j$ 等级的建筑物升级到第 $j+1$ 等级的建筑物所需花费的资金。同一回合内可以多次升级建筑。特别地，建筑物的等级上限为 $L$。如果当前建筑物等级已经到达上限则无法升级。\n- 在所有建筑操作结束后，操作权转移给另一方。\n\n两人都操作完一轮回合后，圆环上的每个建筑物都会提供给拥有者资金，具体来说，第 $i$ 格上的建筑物会给其拥有者提供 $d_i$ 的资金。游戏结束当且仅当存在一个人在它行动过程中或者结束时的资金为负数。此时这个人成为输家（换而言之，允许中途过程资金为 $0$）。\n\n给定莲子和梅莉的 $q$ 个回合的每次操作，请问谁会是输家呢？", "inputFormat": "第一行输入四个正整数 $n,m,q,L$，表示格子数、初始资金、回合次数和建筑物等级上限。\n\n第二行开始，往下 $n$ 行，每行输入 $L$ 个正整数，表示 $C_{i,j}$，其中 $j$ 是从 $0$ 到 $L-1$。\n\n第 $(n+2)$ 行输入 $n$ 个正整数表示 $d_i$。\n\n第 $(n+3)$ 行开始，往下若干行，每行只会有两种可能的情况：\n\n- $\\texttt{1 k}$，表示当前行动方投掷了骰子，最上面的点数是 $k$。之后行动者会逆时针移动 $k$ 步。\n- $\\texttt{2 k}$，表示当前行动方在当前位置**建造或者升级**了建筑物共 $k$ 次。\n  - 在此过程中，当前位置已经有了对方建筑物则忽略此操作；\n  - 如果资金不够升级 $k$ 次，则只升级到资金允许范围内的最高等级；\n  - 在此过程中，如果进行下一次升级，建筑物等级超过 $L$，则后续的所有升级忽略处理。\n\n特别地，规定除了第一次外，每次 $\\texttt{1 k}$ 操作出现时意味着行动者的切换。也就是说，第一次输入 $\\texttt{1 k}$ 操作时，行动方是莲子，第二次是梅莉，第三次是莲子……以此类推。值得注意的是，$\\texttt{2 k}$ 操作出现**并不会**切换行动者。\n\n此外，**保证每个 $\\bm 1$ 操作后面最多跟随 $\\bm 1$ 个 $\\bm 2$ 操作**。", "outputFormat": "如果已经分出了输赢，则输出谁是输家（如果莲子输，则输出 $\\texttt{Renko}$；如果梅莉输，则输出 $\\texttt{Merry}$）；\n\n如果没有分出输赢，则按照先莲子，后梅莉的顺序输出她们现在有的资金数。", "hint": "**【样例解释 1】**\n\n第一回合，莲子首先走 $4$ 步，到达编号为 $5$ 的格子，同时尝试建造与升级 $3$ 次第五个格子的建筑物，但是 $C_{5,0}+C_{5,1}+C_{5,2}=48$，所以只能把建筑物造到 $2$ 级。此时莲子手上还有 $16$ 元。    \n接着梅莉走了两步，到达编号为 $3$ 的格子，同时尝试建造与升级 $5$ 次第三个格子的建筑物，$C_{3,0}+C_{3,1}+C_{3,2}=26$，而造五次会超过等级上限 $L$，因此只能升到 $3$ 次，此时梅莉手上还有 $14$ 元。    \n回合结束后每个建筑物都会提供给拥有者 $d_i$ 的资金，也就是说莲子此时手上有 $21$ 元，梅莉手上有 $17$ 元。    \n第二回合，莲子首先走 $3$ 步，到达编号为 $2$ 的格子。梅莉接着走 $2$ 步，到达编号为 $5$ 的格子，收取 $a_i$ 元。而 $a_i=24$，因此梅莉的资金被扣成了负数，从而输出 $\\texttt{Merry}$。\n\n**【样例解释 2】**\n\n仅在初始资金与第一组样例有一定变化，因此在这些回合中无法决出胜负，因此输出两人手上现有的资金。\n\n**【数据范围】**\n\n对于所有数据，保证 $1 \\leq n,L\\leq 100$，$1 \\leq q \\leq 10^4$，$1 \\leq m,C_{i,j},d_i \\leq 10^6$，$1 \\leq k \\leq 10^3$（你可以不必在意怎么获得一个 $k$ 面的骰子）。数据保证 $1$ 操作次数恰好为 $2\\times q$。", "locale": "zh-CN"}}}
{"pid": "P8875", "type": "P", "difficulty": 4, "samples": [["3 4\n1 2 3 4\n5 6 7 8\n9 10 11 12\n2 2\n1 0\n0 1\n2\n1 1 3 4\n1 2 3 3\n", "40\n20\n"], ["4 4\n1 3 2 4\n5 4 2 3\n4 1 2 3\n3 4 4 3\n1 3\n1 0 0\n3\n1 1 3 4\n2 2 4 4\n1 2 3 2\n", "14\n17\n0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["前缀和", "差分", "传智杯"], "title": "[传智杯 #5 初赛] G-二人的花纹纸游戏", "background": "梅莉买到了一张特殊的带有花纹的纸。整张纸的图案可以视为，由一个较小的图案，沿着横向与纵向无限循环而成。同时，这个基本图案部分透明，部分不透明。\n\n于是，如果将这张纸覆盖在书本上，那么一些字可以被看见，另一些字看不见。\n\n莲子突发奇想：假使她制作一张很大很大的数表，将花纹纸覆盖在上面，那么就会有很多数字被遮挡。那些没有被遮挡的数字的和是多少呢？", "description": "事实上，二人的问题可以转化成如下描述：给定一个 $n$ 行 $m$ 列的普通矩阵 $A$，以及一个 $r$ 行 $c$ 列的 $01$ 矩阵 $B$。$B$ 中为 $1$ 的格子是黑色，不透明；为 $0$ 的格子是透明的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6z0uo690.png)\n\n使用 $B$ 矩阵，循环生成一个**无穷大**的矩阵 $M$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/laycum3q.png)\n\n现在有 $q$ 次询问。每次将 $M$ 矩阵左上角和 $(x_1,y_1)$ 对齐，此时此时会有一些 $A$ 中的元素被遮挡，另一些元素可以被看见。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dtpe8m5u.png)\n\n求出此时，$A$ 当中以 $(x_1,y_1)$ 作为左上角，$(x_2,y_2)$ 作为右下角的子矩阵中，可以被看见的元素之和。结果对 $998{,}244{,}353$ 取模。\n\n在上面的例子里，$(x_1,y_1)=(2,3)$，$(x_2,y_2)=(4,7)$。可以被看见的元素之和为 $a_{2,3}+a_{2,5}+a_{2,6}+a_{3,5}+a_{4,3}+a_{4,5}+a_{4,6}$。\n\n### 形式化题面\n\n给定一个 $n$ 行 $m$ 列的普通矩阵 $A$，以及一个 $r$ 行 $c$ 列的 $01$ 矩阵 $B$。使用 $B$ 矩阵，生成一个**无穷大**的矩阵 $M$：\n\n$$M=\n\\begin{pmatrix}\nB & B & B  &\\cdots \\\\\nB & B & B  &\\cdots \\\\\nB & B & B  &\\cdots \\\\\n\\vdots &\\vdots &\\vdots &\n\\end{pmatrix}\n=\\begin{pmatrix}\nb_{1,1} & b_{1,2} & \\cdots & b_{1,c} & b_{1,1} & b_{1,2} & \\cdots & b_{1,c} & b_{1,1} & \\cdots \\\\\nb_{2,1} & b_{2,2} & \\cdots & b_{2,c} & b_{2,1} & b_{2,2} & \\cdots & b_{2,c} & b_{2,1} & \\cdots \\\\\n\\vdots & \\vdots & & \\vdots & \\vdots & \\vdots & & \\vdots & \\vdots &  \\\\\nb_{r,1} & b_{r,2} & \\cdots & b_{r,c} & b_{r,1} & b_{r,2} & \\cdots & b_{r,c} & b_{r,1} & \\cdots \\\\\nb_{1,1} & b_{1,2} & \\cdots & b_{1,c} & b_{1,1} & b_{1,2} & \\cdots & b_{1,c} & b_{1,1} & \\cdots \\\\\nb_{2,1} & b_{2,2} & \\cdots & b_{2,c} & b_{2,1} & b_{2,2} & \\cdots & b_{2,c} & b_{2,1} & \\cdots \\\\\n\\vdots & \\vdots & & \\vdots & \\vdots & \\vdots & & \\vdots & \\vdots &  \\\\\nb_{r,1} & b_{r,2} & \\cdots & b_{r,c} & b_{r,1} & b_{r,2} & \\cdots & b_{r,c} & b_{r,1} & \\cdots \\\\\n\\vdots & \\vdots & & \\vdots & \\vdots & \\vdots & & \\vdots & \\vdots &  \\\\\n\\end{pmatrix}$$\n\n现在有 $q$ 次询问，每次给出一个子矩阵的左上角坐标 $(x_1,y_1)$ 和右下角坐标 $(x_2,y_2)$，你需要求出：\n\n$$S=\\left(\\sum_{i=x_1}^{x_2}\\sum_{j=y_1}^{y_2}a_{i,j}\\times [M_{i-x_1+1,j-y_1+1}=0] \\right)\\bmod 998{,}244{,}353$$\n\n其中 $[P]$ 表示艾弗森括号。若 $P$ 为真，则 $[P]=1$，否则 $[P]=0$。", "inputFormat": "- 第一行有两个正整数 $n,m$，描述矩阵 $A$ 的大小。\n- 接下来 $n$ 行 $m$ 列，每行一个非负整数，描述 $A$ 中的元素 $a_{i,j}$。\n- 下一行有两个正整数 $r,c$，描述矩阵 $B$ 的大小。\n- 接下来 $r$ 行 $c$ 列，每行一个非负整数，描述 $B$ 中的元素 $b_{i,j}$。\n- 下一行有一个正整数 $q$，表示询问的次数。\n- 接下来 $q$ 行，每行有四个正整数 $x_1,y_1,x_2,y_2$，描述一组询问。保证 $x_1\\le x_2$，$y_1\\le y_2$。", "outputFormat": "- 输出共 $q$ 行。每行输出该次询问的答案。", "hint": "### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z7yeiipu.png)\n\n- 对于第一次询问，结果为 $2+4+5+7+10+12=40$；\n- 对于第二次询问，结果为 $3+6+11=20$。\n\n### 数据范围及约定\n\n对于全部数据，保证 $1\\le n,m\\le 10^3$，$1\\le q\\le 10^4$，$1\\le r,c\\le 50$，$0\\le a_{i,j}<998{,}244{,}353$，$b_{i,j}\\in\\{0,1\\}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] G-二人的花纹纸游戏", "background": "梅莉买到了一张特殊的带有花纹的纸。整张纸的图案可以视为，由一个较小的图案，沿着横向与纵向无限循环而成。同时，这个基本图案部分透明，部分不透明。\n\n于是，如果将这张纸覆盖在书本上，那么一些字可以被看见，另一些字看不见。\n\n莲子突发奇想：假使她制作一张很大很大的数表，将花纹纸覆盖在上面，那么就会有很多数字被遮挡。那些没有被遮挡的数字的和是多少呢？", "description": "事实上，二人的问题可以转化成如下描述：给定一个 $n$ 行 $m$ 列的普通矩阵 $A$，以及一个 $r$ 行 $c$ 列的 $01$ 矩阵 $B$。$B$ 中为 $1$ 的格子是黑色，不透明；为 $0$ 的格子是透明的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6z0uo690.png)\n\n使用 $B$ 矩阵，循环生成一个**无穷大**的矩阵 $M$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/laycum3q.png)\n\n现在有 $q$ 次询问。每次将 $M$ 矩阵左上角和 $(x_1,y_1)$ 对齐，此时此时会有一些 $A$ 中的元素被遮挡，另一些元素可以被看见。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dtpe8m5u.png)\n\n求出此时，$A$ 当中以 $(x_1,y_1)$ 作为左上角，$(x_2,y_2)$ 作为右下角的子矩阵中，可以被看见的元素之和。结果对 $998{,}244{,}353$ 取模。\n\n在上面的例子里，$(x_1,y_1)=(2,3)$，$(x_2,y_2)=(4,7)$。可以被看见的元素之和为 $a_{2,3}+a_{2,5}+a_{2,6}+a_{3,5}+a_{4,3}+a_{4,5}+a_{4,6}$。\n\n### 形式化题面\n\n给定一个 $n$ 行 $m$ 列的普通矩阵 $A$，以及一个 $r$ 行 $c$ 列的 $01$ 矩阵 $B$。使用 $B$ 矩阵，生成一个**无穷大**的矩阵 $M$：\n\n$$M=\n\\begin{pmatrix}\nB & B & B  &\\cdots \\\\\nB & B & B  &\\cdots \\\\\nB & B & B  &\\cdots \\\\\n\\vdots &\\vdots &\\vdots &\n\\end{pmatrix}\n=\\begin{pmatrix}\nb_{1,1} & b_{1,2} & \\cdots & b_{1,c} & b_{1,1} & b_{1,2} & \\cdots & b_{1,c} & b_{1,1} & \\cdots \\\\\nb_{2,1} & b_{2,2} & \\cdots & b_{2,c} & b_{2,1} & b_{2,2} & \\cdots & b_{2,c} & b_{2,1} & \\cdots \\\\\n\\vdots & \\vdots & & \\vdots & \\vdots & \\vdots & & \\vdots & \\vdots &  \\\\\nb_{r,1} & b_{r,2} & \\cdots & b_{r,c} & b_{r,1} & b_{r,2} & \\cdots & b_{r,c} & b_{r,1} & \\cdots \\\\\nb_{1,1} & b_{1,2} & \\cdots & b_{1,c} & b_{1,1} & b_{1,2} & \\cdots & b_{1,c} & b_{1,1} & \\cdots \\\\\nb_{2,1} & b_{2,2} & \\cdots & b_{2,c} & b_{2,1} & b_{2,2} & \\cdots & b_{2,c} & b_{2,1} & \\cdots \\\\\n\\vdots & \\vdots & & \\vdots & \\vdots & \\vdots & & \\vdots & \\vdots &  \\\\\nb_{r,1} & b_{r,2} & \\cdots & b_{r,c} & b_{r,1} & b_{r,2} & \\cdots & b_{r,c} & b_{r,1} & \\cdots \\\\\n\\vdots & \\vdots & & \\vdots & \\vdots & \\vdots & & \\vdots & \\vdots &  \\\\\n\\end{pmatrix}$$\n\n现在有 $q$ 次询问，每次给出一个子矩阵的左上角坐标 $(x_1,y_1)$ 和右下角坐标 $(x_2,y_2)$，你需要求出：\n\n$$S=\\left(\\sum_{i=x_1}^{x_2}\\sum_{j=y_1}^{y_2}a_{i,j}\\times [M_{i-x_1+1,j-y_1+1}=0] \\right)\\bmod 998{,}244{,}353$$\n\n其中 $[P]$ 表示艾弗森括号。若 $P$ 为真，则 $[P]=1$，否则 $[P]=0$。", "inputFormat": "- 第一行有两个正整数 $n,m$，描述矩阵 $A$ 的大小。\n- 接下来 $n$ 行 $m$ 列，每行一个非负整数，描述 $A$ 中的元素 $a_{i,j}$。\n- 下一行有两个正整数 $r,c$，描述矩阵 $B$ 的大小。\n- 接下来 $r$ 行 $c$ 列，每行一个非负整数，描述 $B$ 中的元素 $b_{i,j}$。\n- 下一行有一个正整数 $q$，表示询问的次数。\n- 接下来 $q$ 行，每行有四个正整数 $x_1,y_1,x_2,y_2$，描述一组询问。保证 $x_1\\le x_2$，$y_1\\le y_2$。", "outputFormat": "- 输出共 $q$ 行。每行输出该次询问的答案。", "hint": "### 样例 1 解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z7yeiipu.png)\n\n- 对于第一次询问，结果为 $2+4+5+7+10+12=40$；\n- 对于第二次询问，结果为 $3+6+11=20$。\n\n### 数据范围及约定\n\n对于全部数据，保证 $1\\le n,m\\le 10^3$，$1\\le q\\le 10^4$，$1\\le r,c\\le 50$，$0\\le a_{i,j}<998{,}244{,}353$，$b_{i,j}\\in\\{0,1\\}$。", "locale": "zh-CN"}}}
{"pid": "P8876", "type": "P", "difficulty": 5, "samples": [["8 3 3 4\n4 3 1\n4 4 1\n3 3 2\n3 4 2\n4 5 2\n5 4 2\n2 4 3\n4 1 4\n", "3\n"], ["8 2 3 4\n4 3 1\n4 4 1\n3 3 2\n3 4 2\n4 5 2\n5 4 2\n2 4 3\n4 1 4\n", "1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["搜索", "广度优先搜索 BFS", "传智杯"], "title": "[传智杯 #5 初赛] H-二人的世界", "background": "莲子设计了一个三维立体空间软件。这个软件可以模拟真实的物理引擎，包括实体方块和水流方块。然而，同时计算大量水流会对软件造成不小的负荷。\n\n于是，莲子希望找到这样一种算法，快速计算这些水流模拟后的结果。", "description": "莲子设计的水流模型是这样的：\n\n考虑一个三维空间。这个空间内有 $n$ 个正方体。我们使用坐标 $(x_i,y_i,h_i)$ 描述每个正方体的位置。这些正方体，可以被称作**实体方块**。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sotibgh2.png)\n\n现在将会在这张图中模拟一种水流机制。具体而言，我们会定义**水方块**。水方块会有一个强度 $s$，范围是 $[1,k]$。\n\n### 运行逻辑\n\n- 假定 $(x,y,h)$ 处有强度为 $s$ 的水方块，且 $(x,y,h-1)$ 位置没有实体方块，那么下一时刻 $(x,y,h-1)$ 位置会生成强度为 $k$ 的水方块。**注意**：无论此时 $s$ 的值是多少，在 $(x,y,h-1)$ 位置生成的水方块的强度都是 $k$。\n- 假定 $(x,y,h)$ 处有强度为 $s$ 的水方块，且 $s>1$，且 $(x,y,h-1)$ 位置有实体方块，那么会进行**扩散操作**。\n- 如果下一时刻，某个位置 $(x,y,h)$ 同时有多个水方块会生成，那么最终生成的水方块的强度，是这些可能生成的水方块里，最大的强度。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mn8iqp4l.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/suq9jiqx.png)\n\n### 扩散操作\n\n**考虑到扩散操作比较抽象，建议结合图示理解**。\n\n对于水方块 $(x,y,h)$，它会在高度 $h$ 的平面上进行寻路。为了考虑这个过程，我们考虑这个高度为 $h$ 的平面：\n\n- 如果空间里 $(x,y,h)$ 位置有实体方块存在，那么平面上 $(x,y)$ 处**不可经过**。否则，如果没有实体方块，那么 $(x,y)$ 处**可以经过**。\n- 在 $(x,y)$ **可以经过**的情况下，如果空间里 $(x,y,h-1)$ 位置没有实体方块存在，那么平面上 $(x,y)$ 位置称为**目标位置**。目标位置可以不止一个。\n\n根据扩散的前提条件，可知平面上 $(x,y)$ 位置可以经过，但不是目标位置。\n\n从平面上 $(x,y)$ 处出发，进行路径的搜索。每次在 $(a,b)$ 位置会向 $(a+1,b),(a-1,b),(a,b+1),(a,b-1)$ 位置扩展。搜索过程会找到距离 $(x,y)$ 位置**最近**的，且距离不超过 $s-1$ 的**所有**目标位置，或者找不到这样的目标位置。\n\n- 如果存在这样的目标位置，那么在到达目标位置的最短路的方向上，下一时刻会生成一个强度为 $s-1$ 的水方块。\n- 如果不存在这样的目标位置，那么下一时刻，会向 $(x+1,y),(x-1,y),(x,y+1),(x,y-1)$ 位置都生成强度为 $s-1$ 的水方块（如果这个位置可以到达的话）。\n\n请结合图示理解扩散过程。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9sw2uf0u.png)\n\n如图所示。$S$ 处是平面上该水方块所在的位置。白色的方块是目标位置，打 $\\times$ 的方块是不可经过的位置。我们计算出 $S$ 到达最近的目标位置的最小值 $d_{\\min}=5$，图中标出来的**红色路径**就是三条可能的最短路。\n\n如果 $s>5$，那么下一时刻，在**蓝色箭头**处会有强度为 $s-1$ 的水方块生成。否则，若 $5\\ge s>1$，那么下一时刻除了蓝色箭头外，灰色路径对应的方向**也会生成**强度为 $s-1$ 的水方块。\n\n---\n\n为了检验水流模型的合理性以及其运行效率，莲子提出了这个问题：在 $(x_0,y_0,10^9+1)$ 处，有一个强度为 $k$ 的水方块。询问：在经过充分长的时间后（比如经过了 $10^{9961^{9961}}$ 时刻），有多少个点对 $(a,b)$，满足在 $(a,b,-1)$ 位置，会有水方块生成过。", "inputFormat": "- 第一行有两个正整数 $n,k$ 和两个整数 $x_0,y_0$，描述实体方块的个数、水方块最大强度，以及初始水方块的位置。\n- 接下来 $n$ 行，每行三个整数 $x_i,y_i,h_i$，描述每个实体方块的位置。保证不存在两个位置完全相同的实体方块。", "outputFormat": "- 输出共一行一个整数，表示有多少个点对 $(a,b)$，使得充分长时间后 $(a,b,-1)$ 位置有水方块生成过。", "hint": "### 样例 1 解释\n\n（图片实在太难画啦，将就一下吧。）为了防止方块阻挡导致看不见，方块全部换成了透明的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i94wjdgb.png)\n\n初始状态下一根水流柱从高空落下，落在了方块 $(3,4,2)$ 上，进行了扩散。水方块的坐标为 $(3,4,3)$，强度为 $3$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e8d9vtl8.png)\n\n- 如图 $3$，根据寻路机制，它会在 $(3,5,3)$ 和 $(4,4,3)$ 上生成强度为 $2$ 的水方块。\n- 如图 $4$，生成的两个支流下方都没有方块，于是在 $(3,5,2)$ 和 $(4,4,2)$ 上生成强度为 $3$ 的水方块。\n- 如图 $5$，水方块 $(3,5,2)$ 下方依旧没有实体方块，于是在 $(3,5,1)$ 生成了强度为 $3$ 的水方块，一直流到 $(3,5,-1)$；水方块 $(4,4,2)$ 下方有实体方块，于是在 $(4,3,2)$ 生成了强度为 $2$ 的水方块。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g5n7min2.png)\n\n下面只关心水方块 $(4,3,2)$。它下面有实体方块 $(4,3,1)$，于是它向两边扩散，生成强度均为 $1$ 的两个水方块。这两个方块下面都不再有实体方块，于是**一直往下流**到 $(4,2,-1)$ 和 $(5,3,-1)$。\n\n因此，最终一共会有三个位置 $(3,5,-1)$、$(4,2,-1)$、$(5,3,-1)$ 有水方块经过。\n\n### 数据范围及约定\n\n对于所有数据，$1\\le n\\le 10^5$，$1\\le k\\le 10^9$，$0\\le |x_i|,|y_i|\\le 10^9$，$0\\le h_i\\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] H-二人的世界", "background": "莲子设计了一个三维立体空间软件。这个软件可以模拟真实的物理引擎，包括实体方块和水流方块。然而，同时计算大量水流会对软件造成不小的负荷。\n\n于是，莲子希望找到这样一种算法，快速计算这些水流模拟后的结果。", "description": "莲子设计的水流模型是这样的：\n\n考虑一个三维空间。这个空间内有 $n$ 个正方体。我们使用坐标 $(x_i,y_i,h_i)$ 描述每个正方体的位置。这些正方体，可以被称作**实体方块**。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sotibgh2.png)\n\n现在将会在这张图中模拟一种水流机制。具体而言，我们会定义**水方块**。水方块会有一个强度 $s$，范围是 $[1,k]$。\n\n### 运行逻辑\n\n- 假定 $(x,y,h)$ 处有强度为 $s$ 的水方块，且 $(x,y,h-1)$ 位置没有实体方块，那么下一时刻 $(x,y,h-1)$ 位置会生成强度为 $k$ 的水方块。**注意**：无论此时 $s$ 的值是多少，在 $(x,y,h-1)$ 位置生成的水方块的强度都是 $k$。\n- 假定 $(x,y,h)$ 处有强度为 $s$ 的水方块，且 $s>1$，且 $(x,y,h-1)$ 位置有实体方块，那么会进行**扩散操作**。\n- 如果下一时刻，某个位置 $(x,y,h)$ 同时有多个水方块会生成，那么最终生成的水方块的强度，是这些可能生成的水方块里，最大的强度。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mn8iqp4l.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/suq9jiqx.png)\n\n### 扩散操作\n\n**考虑到扩散操作比较抽象，建议结合图示理解**。\n\n对于水方块 $(x,y,h)$，它会在高度 $h$ 的平面上进行寻路。为了考虑这个过程，我们考虑这个高度为 $h$ 的平面：\n\n- 如果空间里 $(x,y,h)$ 位置有实体方块存在，那么平面上 $(x,y)$ 处**不可经过**。否则，如果没有实体方块，那么 $(x,y)$ 处**可以经过**。\n- 在 $(x,y)$ **可以经过**的情况下，如果空间里 $(x,y,h-1)$ 位置没有实体方块存在，那么平面上 $(x,y)$ 位置称为**目标位置**。目标位置可以不止一个。\n\n根据扩散的前提条件，可知平面上 $(x,y)$ 位置可以经过，但不是目标位置。\n\n从平面上 $(x,y)$ 处出发，进行路径的搜索。每次在 $(a,b)$ 位置会向 $(a+1,b),(a-1,b),(a,b+1),(a,b-1)$ 位置扩展。搜索过程会找到距离 $(x,y)$ 位置**最近**的，且距离不超过 $s-1$ 的**所有**目标位置，或者找不到这样的目标位置。\n\n- 如果存在这样的目标位置，那么在到达目标位置的最短路的方向上，下一时刻会生成一个强度为 $s-1$ 的水方块。\n- 如果不存在这样的目标位置，那么下一时刻，会向 $(x+1,y),(x-1,y),(x,y+1),(x,y-1)$ 位置都生成强度为 $s-1$ 的水方块（如果这个位置可以到达的话）。\n\n请结合图示理解扩散过程。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9sw2uf0u.png)\n\n如图所示。$S$ 处是平面上该水方块所在的位置。白色的方块是目标位置，打 $\\times$ 的方块是不可经过的位置。我们计算出 $S$ 到达最近的目标位置的最小值 $d_{\\min}=5$，图中标出来的**红色路径**就是三条可能的最短路。\n\n如果 $s>5$，那么下一时刻，在**蓝色箭头**处会有强度为 $s-1$ 的水方块生成。否则，若 $5\\ge s>1$，那么下一时刻除了蓝色箭头外，灰色路径对应的方向**也会生成**强度为 $s-1$ 的水方块。\n\n---\n\n为了检验水流模型的合理性以及其运行效率，莲子提出了这个问题：在 $(x_0,y_0,10^9+1)$ 处，有一个强度为 $k$ 的水方块。询问：在经过充分长的时间后（比如经过了 $10^{9961^{9961}}$ 时刻），有多少个点对 $(a,b)$，满足在 $(a,b,-1)$ 位置，会有水方块生成过。", "inputFormat": "- 第一行有两个正整数 $n,k$ 和两个整数 $x_0,y_0$，描述实体方块的个数、水方块最大强度，以及初始水方块的位置。\n- 接下来 $n$ 行，每行三个整数 $x_i,y_i,h_i$，描述每个实体方块的位置。保证不存在两个位置完全相同的实体方块。", "outputFormat": "- 输出共一行一个整数，表示有多少个点对 $(a,b)$，使得充分长时间后 $(a,b,-1)$ 位置有水方块生成过。", "hint": "### 样例 1 解释\n\n（图片实在太难画啦，将就一下吧。）为了防止方块阻挡导致看不见，方块全部换成了透明的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/i94wjdgb.png)\n\n初始状态下一根水流柱从高空落下，落在了方块 $(3,4,2)$ 上，进行了扩散。水方块的坐标为 $(3,4,3)$，强度为 $3$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e8d9vtl8.png)\n\n- 如图 $3$，根据寻路机制，它会在 $(3,5,3)$ 和 $(4,4,3)$ 上生成强度为 $2$ 的水方块。\n- 如图 $4$，生成的两个支流下方都没有方块，于是在 $(3,5,2)$ 和 $(4,4,2)$ 上生成强度为 $3$ 的水方块。\n- 如图 $5$，水方块 $(3,5,2)$ 下方依旧没有实体方块，于是在 $(3,5,1)$ 生成了强度为 $3$ 的水方块，一直流到 $(3,5,-1)$；水方块 $(4,4,2)$ 下方有实体方块，于是在 $(4,3,2)$ 生成了强度为 $2$ 的水方块。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g5n7min2.png)\n\n下面只关心水方块 $(4,3,2)$。它下面有实体方块 $(4,3,1)$，于是它向两边扩散，生成强度均为 $1$ 的两个水方块。这两个方块下面都不再有实体方块，于是**一直往下流**到 $(4,2,-1)$ 和 $(5,3,-1)$。\n\n因此，最终一共会有三个位置 $(3,5,-1)$、$(4,2,-1)$、$(5,3,-1)$ 有水方块经过。\n\n### 数据范围及约定\n\n对于所有数据，$1\\le n\\le 10^5$，$1\\le k\\le 10^9$，$0\\le |x_i|,|y_i|\\le 10^9$，$0\\le h_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P8877", "type": "P", "difficulty": 6, "samples": [["8\n1 1 0 1 0 0 0 1\n0 0 1 0 1 1 0 0\n1 1 3 2 2 1 4", "14\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["树形 DP", "虚树", "传智杯"], "title": "[传智杯 #5 初赛] I-不散的宴会", "background": "学校正在组织宴会。\n\n莲子和梅莉发现，学校的结构十分复杂。学生之间存在着部门与上司的关系。每一个部门内部，都呈现出连成一条线的上司关系。一个部门内等级最高的学生，又可能受限于另外某个部门内的某个学生。\n\n莲子和梅莉同样参加了宴会。但是她们对参加学生有自己的评判。例如，她对某些部门比较喜欢，对另一些部门则不感兴趣。同时对位居不同等级的学生同样有着不同的看法。\n\n正如某个经典问题所描述的一样，每个学生都不希望与自己的直接上司共同参加宴会。\n\n梅莉想要知道，最好情况下，有多少个参加宴会的学生是她喜欢的。", "description": "学生社会可以被看作一个排列成等腰直角三角形的节点阵列。该节点阵列共有 $n$ 行，第 $i$ 行共有 $i$ 个节点。我们将第 $i$ 行第 $j$ 列的节点，标号为 $(i,j)$。\n\n- 这些节点具有权值。具体而言，节点 $(i,j)$ 的权值为 $r_i\\oplus c_j$，其中 $r$ 和 $c$ 是给定的 $01$ 序列，$\\oplus$ 是**二进制异或**操作。\n- 这些节点有边相连。具体而言，对于 $1\\le i< n$，$1\\le j\\le i$，会有一条边连接 $(i,j)$ 和 $(i+1,j)$。此外，对于 $2\\le i\\le n$，还会有边连接 $(i,i)$ 和 $(i-1,a_i)$。其中 $a$ 是给定的序列。\n\n现在你需要从这些节点中，选出一些节点，使得这些节点间**两两不存在边相连**，最大化选出来的节点的**权值之和**。\n\n如下图所示，是 $n=8$ 的一个例子。黑色节点权值为 $1$，白色节点权值为 $0$。\n\n**注**：图片中只象征性地给出了部分 $r_i$ 和 $c_i$ 的值。该图片上实际 $\\def\\t{,\\allowbreak}r=\\{1\\t 1\\t 0\\t 1\\t 0\\t 0\\t 0\\t 1\\}\\t c=\\{0\\t 0\\t 1\\t 0\\t 1\\t 1\\t 0\\t 0\\}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/582ii4nj.png)", "inputFormat": "- 第一行有一个正整数 $n$，描述节点阵列的大小。\n- 第二行有 $n$ 个整数 $0$ 或者 $1$，描述 $r_i$ 的值。\n- 第三行有 $n$ 个整数 $0$ 或者 $1$，描述 $c_i$ 的值。\n- 第四行有 $n-1$ 个正整数，其中第 $i$ 个数描述 $a_{i+1}$ 的值。", "outputFormat": "- 输出共一行一个整数，描述选出的节点的权值之和的最大值。", "hint": "### 样例解释\n\n一种可能的选择方案如下图所示。橘红色方块表示选中的节点。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gpwn8ekv.png)\n\n### 数据范围及约定\n\n对于全部数据，保证 $1\\le n\\le 10^6$，$r_i\\in\\{0,1\\}$，$c_i\\in\\{0,1\\}$，$1\\le a_i<i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[传智杯 #5 初赛] I-不散的宴会", "background": "学校正在组织宴会。\n\n莲子和梅莉发现，学校的结构十分复杂。学生之间存在着部门与上司的关系。每一个部门内部，都呈现出连成一条线的上司关系。一个部门内等级最高的学生，又可能受限于另外某个部门内的某个学生。\n\n莲子和梅莉同样参加了宴会。但是她们对参加学生有自己的评判。例如，她对某些部门比较喜欢，对另一些部门则不感兴趣。同时对位居不同等级的学生同样有着不同的看法。\n\n正如某个经典问题所描述的一样，每个学生都不希望与自己的直接上司共同参加宴会。\n\n梅莉想要知道，最好情况下，有多少个参加宴会的学生是她喜欢的。", "description": "学生社会可以被看作一个排列成等腰直角三角形的节点阵列。该节点阵列共有 $n$ 行，第 $i$ 行共有 $i$ 个节点。我们将第 $i$ 行第 $j$ 列的节点，标号为 $(i,j)$。\n\n- 这些节点具有权值。具体而言，节点 $(i,j)$ 的权值为 $r_i\\oplus c_j$，其中 $r$ 和 $c$ 是给定的 $01$ 序列，$\\oplus$ 是**二进制异或**操作。\n- 这些节点有边相连。具体而言，对于 $1\\le i< n$，$1\\le j\\le i$，会有一条边连接 $(i,j)$ 和 $(i+1,j)$。此外，对于 $2\\le i\\le n$，还会有边连接 $(i,i)$ 和 $(i-1,a_i)$。其中 $a$ 是给定的序列。\n\n现在你需要从这些节点中，选出一些节点，使得这些节点间**两两不存在边相连**，最大化选出来的节点的**权值之和**。\n\n如下图所示，是 $n=8$ 的一个例子。黑色节点权值为 $1$，白色节点权值为 $0$。\n\n**注**：图片中只象征性地给出了部分 $r_i$ 和 $c_i$ 的值。该图片上实际 $\\def\\t{,\\allowbreak}r=\\{1\\t 1\\t 0\\t 1\\t 0\\t 0\\t 0\\t 1\\}\\t c=\\{0\\t 0\\t 1\\t 0\\t 1\\t 1\\t 0\\t 0\\}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/582ii4nj.png)", "inputFormat": "- 第一行有一个正整数 $n$，描述节点阵列的大小。\n- 第二行有 $n$ 个整数 $0$ 或者 $1$，描述 $r_i$ 的值。\n- 第三行有 $n$ 个整数 $0$ 或者 $1$，描述 $c_i$ 的值。\n- 第四行有 $n-1$ 个正整数，其中第 $i$ 个数描述 $a_{i+1}$ 的值。", "outputFormat": "- 输出共一行一个整数，描述选出的节点的权值之和的最大值。", "hint": "### 样例解释\n\n一种可能的选择方案如下图所示。橘红色方块表示选中的节点。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gpwn8ekv.png)\n\n### 数据范围及约定\n\n对于全部数据，保证 $1\\le n\\le 10^6$，$r_i\\in\\{0,1\\}$，$c_i\\in\\{0,1\\}$，$1\\le a_i<i$。", "locale": "zh-CN"}}}
{"pid": "P8878", "type": "P", "difficulty": 5, "samples": [["6 2\n1 1 4 5 1 4\n2 4 2 100 3\n3 5 1 97 5", "1 4 52 44 6 4"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["线段树", "O2优化", "置换"], "title": "『STA - R1』好吃的智慧果子", "background": "在上古时代，$-(2077^{-1}\\ \\ (mod=2035))$ 年，$\\mathfrak{Morlin}$ 种下了一棵非常珍贵的$\\colorbox{black}{\\textcolor{red}{\\textbf{智♂慧♂树♂}}}$，被 $\\mathfrak{char\\_phi}$ 看见了。\n\n过了 $114810$ 年，树上结出了 $\\colorbox{black}{\\textcolor{blue}{\\textbf{智♂慧♂果♂子♂}}}$。  \n又过了 $1919514$ 年，果子成熟了，$\\mathfrak{char\\_phi}$ 非常馋。\n\n$\\mathfrak{char\\_phi}$ 十分想吃果子，但是~~神机妙算的~~ $\\mathfrak{Morlin}$ 早就知道 $\\mathfrak{char\\_phi}$ 想要吃他的果子，所以把每个果子都装进了密码箱。\n\n现在，$\\mathfrak{char\\_phi}$ 把偷果子这项重任托付给了你。  ", "description": "**形式化题面**\n\n维护一个序列 $\\{a_n\\}$，每次操作给五个非负整数 $l, r, k, p, c$，对于所有 $i\\in[l,r]$，将 $a_i\\gets (f_{a_i}^k+c)\\bmod p$。\n\n其中 $f$ 是 Fibonacci 数列，定义为：\n$$f_n=\\begin{cases}n&n\\leqslant 1\\\\f_{n-1}+f_{n-2}&n>1\\end{cases}$$\n***\n\n**原题面**\n\n~~神机妙算的~~ $\\mathfrak{Morlin}$ 早就知道 $\\mathfrak{char\\_phi}$ 很聪明，所以他会不定时改密码。\n\n每个密码箱上有一个数字，组成了数列 $\\{a_n\\}$。\n\n关于密码有 $m$ 次操作，每次操作给定五个整数 $l, r, k, p, c$，表示将满足 $l \\leqslant i \\leqslant r$ 将 $a_i$ 变成 $(f_{a_i}^k+c) \\bmod p$（$f_i$ 代表斐波那契数列的第 $i$ 项；保证 $l \\leqslant r$）。\n\n$\\mathfrak{char\\_phi}$ 搞了一个记录器记录下了 $\\mathfrak{Morlin}$ 的操作。现在，他把记录器给了你，希望你能在 $\\mathfrak{Morlin}$ 操作完后搞出所有密码箱的密码。", "inputFormat": "第一行，两个整数 $n, m$，表示果子的数量和操作次数。\n\n第二行，$n$ 个整数为数列 $a$，表示每个密码箱上的数字。\n\n接下来 $m$ 行，表示 $\\mathfrak{Morlin}$ 的操作 $l, r, k, p, c$。", "outputFormat": "一行，表示所有密码箱的密码，每个密码间使用空格隔开。", "hint": "**【数据范围】**\n\n**本题采用捆绑测试。**\n\n| Subtask | $\\bm{n,m\\leqslant}$ | 分值 | 特殊性质 |\n| :--: | :--: | :--: | :--: |\n| $1$ | $10^3$ | $10$ | 无 |\n| $2$ | $10^5$ | $10$ | $p \\leqslant 2$ |\n| $3$ | $10^5$ | $20$ | $p \\leqslant 3$ |\n| $4$ | $10^5$ | $60$ | 无 |\n\n对于 $100\\%$ 的数据，$1 \\leqslant n, m \\leqslant 10^5$，$1 \\leqslant a_i, p, k \\leqslant 100$，$0 \\leqslant c \\leqslant 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『STA - R1』好吃的智慧果子", "background": "在上古时代，$-(2077^{-1}\\ \\ (mod=2035))$ 年，$\\mathfrak{Morlin}$ 种下了一棵非常珍贵的$\\colorbox{black}{\\textcolor{red}{\\textbf{智♂慧♂树♂}}}$，被 $\\mathfrak{char\\_phi}$ 看见了。\n\n过了 $114810$ 年，树上结出了 $\\colorbox{black}{\\textcolor{blue}{\\textbf{智♂慧♂果♂子♂}}}$。  \n又过了 $1919514$ 年，果子成熟了，$\\mathfrak{char\\_phi}$ 非常馋。\n\n$\\mathfrak{char\\_phi}$ 十分想吃果子，但是~~神机妙算的~~ $\\mathfrak{Morlin}$ 早就知道 $\\mathfrak{char\\_phi}$ 想要吃他的果子，所以把每个果子都装进了密码箱。\n\n现在，$\\mathfrak{char\\_phi}$ 把偷果子这项重任托付给了你。  ", "description": "**形式化题面**\n\n维护一个序列 $\\{a_n\\}$，每次操作给五个非负整数 $l, r, k, p, c$，对于所有 $i\\in[l,r]$，将 $a_i\\gets (f_{a_i}^k+c)\\bmod p$。\n\n其中 $f$ 是 Fibonacci 数列，定义为：\n$$f_n=\\begin{cases}n&n\\leqslant 1\\\\f_{n-1}+f_{n-2}&n>1\\end{cases}$$\n***\n\n**原题面**\n\n~~神机妙算的~~ $\\mathfrak{Morlin}$ 早就知道 $\\mathfrak{char\\_phi}$ 很聪明，所以他会不定时改密码。\n\n每个密码箱上有一个数字，组成了数列 $\\{a_n\\}$。\n\n关于密码有 $m$ 次操作，每次操作给定五个整数 $l, r, k, p, c$，表示将满足 $l \\leqslant i \\leqslant r$ 将 $a_i$ 变成 $(f_{a_i}^k+c) \\bmod p$（$f_i$ 代表斐波那契数列的第 $i$ 项；保证 $l \\leqslant r$）。\n\n$\\mathfrak{char\\_phi}$ 搞了一个记录器记录下了 $\\mathfrak{Morlin}$ 的操作。现在，他把记录器给了你，希望你能在 $\\mathfrak{Morlin}$ 操作完后搞出所有密码箱的密码。", "inputFormat": "第一行，两个整数 $n, m$，表示果子的数量和操作次数。\n\n第二行，$n$ 个整数为数列 $a$，表示每个密码箱上的数字。\n\n接下来 $m$ 行，表示 $\\mathfrak{Morlin}$ 的操作 $l, r, k, p, c$。", "outputFormat": "一行，表示所有密码箱的密码，每个密码间使用空格隔开。", "hint": "**【数据范围】**\n\n**本题采用捆绑测试。**\n\n| Subtask | $\\bm{n,m\\leqslant}$ | 分值 | 特殊性质 |\n| :--: | :--: | :--: | :--: |\n| $1$ | $10^3$ | $10$ | 无 |\n| $2$ | $10^5$ | $10$ | $p \\leqslant 2$ |\n| $3$ | $10^5$ | $20$ | $p \\leqslant 3$ |\n| $4$ | $10^5$ | $60$ | 无 |\n\n对于 $100\\%$ 的数据，$1 \\leqslant n, m \\leqslant 10^5$，$1 \\leqslant a_i, p, k \\leqslant 100$，$0 \\leqslant c \\leqslant 10^9$。", "locale": "zh-CN"}}}
{"pid": "P8879", "type": "P", "difficulty": 6, "samples": [["5\n1 2 3 4 5", "-13.7500000"], ["10\n1000 1 2 8 9 5 4 1000 -40 1000", "-403015.7500000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["Special Judge", "单调栈", "保序回归"], "title": "『STA - R1』Crossnews", "background": "Informational problems make us better.", "description": "定义两个序列 $\\{a_n\\}$，$\\{b_n\\}$ 的联合权值为\n$$\\operatorname{unval}(a,b)=\\sum_{i=1}^nb_i(b_i-a_i)$$\n\n现给定一个序列 $\\{a_n\\}$，求满足 $\\operatorname{unval}(a,b)$ 最小的单调不减序列 $\\{b\\}$，只需输出 $\\operatorname{unval}(a,b)$ 的值即可。\n\n注意，$\\{b\\}$ 中的元素不一定要为整数。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个整数表示 $a_i$。", "outputFormat": "一行一个答案。", "hint": "提示：如果你不会做这道题，可以问问 [APJifengc](/user/279652)。\n***\n\n样例 1 解释：使得联合权值取到最小值的 $\\{b\\}$ 为 `0.5 1 1.5 2 2.5`。\n\n***\n数据范围和约定：\n$$\n\\newcommand{\\arraystretch}{1.5}\n\\begin{array}{c|c|c|c}\\hline\\hline\n\\textbf{Subtask} & \\bm{n}\\le & \\textbf{分值} & \\textbf{特殊性质}\\\\\\hline\n\\textsf{1} & 100 & 10 & \\textbf{无} \\\\\\hline\n\\textsf{2} & 10^6 & 5 & \\{a\\}\\textbf{ 全部相等} \\\\\\hline\n\\textsf{3} & 10^6 & 5 & \\{a\\}\\textbf{ 单调不减} \\\\\\hline\n\\textsf{4} & 10^4 & 30 & \\textbf{无} \\\\\\hline\n\\textsf{5} & 10^6 & 50 & \\textbf{无}\n\\\\\\hline\\hline\n\\end{array}\n$$\n\n对于全部数据，有 $1\\le n\\le 10^6$，$|a_i|\\le 10^3$。\n\n***\n\n评分规则：\n\n本题使用 Special Judge，如果你的答案是 $pans$，标准答案是 $cans$，则你将获得\n$$\\min\\Bigg\\{100,\\Bigg\\lfloor\\dfrac{0.1}{\\min\\Big\\{|pans-cans|,\\Big|\\dfrac{|pans-cans|}{cans}\\Big|\\Big\\}}\\Bigg\\rfloor\\Bigg\\}$$\n分。\n\n**每个 Subtask 内捆绑测试**。即取 Subtask 内得分最小的作为 Subtask 得分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『STA - R1』Crossnews", "background": "Informational problems make us better.", "description": "定义两个序列 $\\{a_n\\}$，$\\{b_n\\}$ 的联合权值为\n$$\\operatorname{unval}(a,b)=\\sum_{i=1}^nb_i(b_i-a_i)$$\n\n现给定一个序列 $\\{a_n\\}$，求满足 $\\operatorname{unval}(a,b)$ 最小的单调不减序列 $\\{b\\}$，只需输出 $\\operatorname{unval}(a,b)$ 的值即可。\n\n注意，$\\{b\\}$ 中的元素不一定要为整数。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个整数表示 $a_i$。", "outputFormat": "一行一个答案。", "hint": "提示：如果你不会做这道题，可以问问 [APJifengc](/user/279652)。\n***\n\n样例 1 解释：使得联合权值取到最小值的 $\\{b\\}$ 为 `0.5 1 1.5 2 2.5`。\n\n***\n数据范围和约定：\n$$\n\\newcommand{\\arraystretch}{1.5}\n\\begin{array}{c|c|c|c}\\hline\\hline\n\\textbf{Subtask} & \\bm{n}\\le & \\textbf{分值} & \\textbf{特殊性质}\\\\\\hline\n\\textsf{1} & 100 & 10 & \\textbf{无} \\\\\\hline\n\\textsf{2} & 10^6 & 5 & \\{a\\}\\textbf{ 全部相等} \\\\\\hline\n\\textsf{3} & 10^6 & 5 & \\{a\\}\\textbf{ 单调不减} \\\\\\hline\n\\textsf{4} & 10^4 & 30 & \\textbf{无} \\\\\\hline\n\\textsf{5} & 10^6 & 50 & \\textbf{无}\n\\\\\\hline\\hline\n\\end{array}\n$$\n\n对于全部数据，有 $1\\le n\\le 10^6$，$|a_i|\\le 10^3$。\n\n***\n\n评分规则：\n\n本题使用 Special Judge，如果你的答案是 $pans$，标准答案是 $cans$，则你将获得\n$$\\min\\Bigg\\{100,\\Bigg\\lfloor\\dfrac{0.1}{\\min\\Big\\{|pans-cans|,\\Big|\\dfrac{|pans-cans|}{cans}\\Big|\\Big\\}}\\Bigg\\rfloor\\Bigg\\}$$\n分。\n\n**每个 Subtask 内捆绑测试**。即取 Subtask 内得分最小的作为 Subtask 得分。", "locale": "zh-CN"}}}
{"pid": "P8880", "type": "P", "difficulty": 3, "samples": [["3\n2 1 0", "2 0 1\n0 1 2"], ["4\n1 3 0 2", "-1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["Special Judge", "O2优化"], "title": "无知时诋毁原神", "background": "纳西妲很喜欢排列。\n\n![](https://img2.huashi6.com/images/resource/thumbnail/2022/07/28/14225_32552389084.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)\n\n画师 pid：72405030", "description": "纳西妲有一个 $0\\sim n-1$ 的排列 $c$。她希望你构造两个同样为 $0\\sim n-1$ 的排列的 $a,b$，满足 $\\forall i\\in[1,n],c_i=(a_i+b_i)\\bmod n$。如果纳西妲的要求无法被满足，请输出 $-1$。", "inputFormat": "第一行，一个整数 $n$。\n\n第二行，$n$ 个整数，表示排列 $c$。", "outputFormat": "如果不存在满足要求的构造，输出一行 $-1$。\n\n否则，输出两行，每行 $n$ 个整数，第一行为 $a_i$，第二行为 $b_i$。", "hint": "### 数据范围\n\n- $\\text{Subtask 1(30 pts)}$：$n\\le 10$。\n- $\\text{Subtask 2(20 pts)}$：保证有解。\n- $\\text{Subtask 3(50 pts)}$：无特殊性质。\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^5$，$c$ 构成一个排列。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "无知时诋毁原神", "background": "纳西妲很喜欢排列。\n\n![](https://img2.huashi6.com/images/resource/thumbnail/2022/07/28/14225_32552389084.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)\n\n画师 pid：72405030", "description": "纳西妲有一个 $0\\sim n-1$ 的排列 $c$。她希望你构造两个同样为 $0\\sim n-1$ 的排列的 $a,b$，满足 $\\forall i\\in[1,n],c_i=(a_i+b_i)\\bmod n$。如果纳西妲的要求无法被满足，请输出 $-1$。", "inputFormat": "第一行，一个整数 $n$。\n\n第二行，$n$ 个整数，表示排列 $c$。", "outputFormat": "如果不存在满足要求的构造，输出一行 $-1$。\n\n否则，输出两行，每行 $n$ 个整数，第一行为 $a_i$，第二行为 $b_i$。", "hint": "### 数据范围\n\n- $\\text{Subtask 1(30 pts)}$：$n\\le 10$。\n- $\\text{Subtask 2(20 pts)}$：保证有解。\n- $\\text{Subtask 3(50 pts)}$：无特殊性质。\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^5$，$c$ 构成一个排列。", "locale": "zh-CN"}}}
{"pid": "P8881", "type": "P", "difficulty": 3, "samples": [["1\n5 4\n1 3\n1 2\n3 4\n2 5", "1.000"], ["1\n4 4\n1 2\n2 3\n3 1\n4 3", "0.000"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "O2优化"], "title": "懂事时理解原神", "background": "胡桃喜欢用 dfs 求最短路，尽管这有可能会得到错误的答案。\n\n![](https://img2.huashi6.com/images/resource/2021/03/01/8812956h7p1.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)\n\n画师 pid：6657532", "description": "具体地，给定一个有 $n$ 个点和 $m$ 条边的无向无权图。则 dfs 求最短路的算法伪代码具体如下：\n\n```\nvis[], dis[]\ndfs(u):\n\tvis[u] = 1\n\t记所有满足 u,v 之间有边且 !vis[v] 的点 v 构成的序列为 S\n\t以随机的顺序遍历 S: \n\t\tdis[v] = dis[u] + 1\n\t\tdfs(v)\nsolve():\n\tfor i in [1, n]: \n    \tdis[i] = -1;\n        vis[i] = 0\n\tdis[1] = 0\n\tdfs(1)\n```\n\n其中，```以随机的顺序遍历 S``` 可以被理解为随机打乱 $S$，得到每一种结果的概率均为 $\\frac{1}{|S|!}$，并按照打乱后的顺序遍历。\n\n现在，胡桃想要知道，如果她调用函数 ```solve()```，得到的最短路数组 ```dis[]``` 完全正确的概率有多大。```dis[]``` 被认为完全正确，当且仅当 $\\forall i\\in[1,n]$，```dis[i]``` 的值均等于从 $1$ 到 $i$ 的最短路长度（特别地，若 $1$ 无法走到 $i$，则认为 $1$ 到 $i$ 的最短路长度为 $-1$）。", "inputFormat": "**本题多组询问。** 第一行输入一个数 $T$，表示询问组数。\n\n对于每组询问：\n\n第一行，两个整数 $n,m$。\n\n第二行至第 $m+1$ 行，每行两个整数 $u,v$，表示 $u,v$ 之间有一条边。", "outputFormat": "对于每组询问，输出一个实数，为 ```dis[]``` 数组完全正确的概率。**你需要输出答案保留三位小数（四舍五入）后的结果。**", "hint": "- 对于 $20\\%$ 的数据，$n,m\\le 10$。\n- 对于 $50\\%$ 的数据，$n,m\\le 1000$。\n- 对于另外 $30\\%$ 的数据，保证所给出的图为一仙人掌（任意一条边至多只出现在一条环上）。\n- 对于 $100\\%$ 的数据，$1\\le n,m\\le 50000，1\\le T\\le 10$，保证所输入的图无重边、自环。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "懂事时理解原神", "background": "胡桃喜欢用 dfs 求最短路，尽管这有可能会得到错误的答案。\n\n![](https://img2.huashi6.com/images/resource/2021/03/01/8812956h7p1.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)\n\n画师 pid：6657532", "description": "具体地，给定一个有 $n$ 个点和 $m$ 条边的无向无权图。则 dfs 求最短路的算法伪代码具体如下：\n\n```\nvis[], dis[]\ndfs(u):\n\tvis[u] = 1\n\t记所有满足 u,v 之间有边且 !vis[v] 的点 v 构成的序列为 S\n\t以随机的顺序遍历 S: \n\t\tdis[v] = dis[u] + 1\n\t\tdfs(v)\nsolve():\n\tfor i in [1, n]: \n    \tdis[i] = -1;\n        vis[i] = 0\n\tdis[1] = 0\n\tdfs(1)\n```\n\n其中，```以随机的顺序遍历 S``` 可以被理解为随机打乱 $S$，得到每一种结果的概率均为 $\\frac{1}{|S|!}$，并按照打乱后的顺序遍历。\n\n现在，胡桃想要知道，如果她调用函数 ```solve()```，得到的最短路数组 ```dis[]``` 完全正确的概率有多大。```dis[]``` 被认为完全正确，当且仅当 $\\forall i\\in[1,n]$，```dis[i]``` 的值均等于从 $1$ 到 $i$ 的最短路长度（特别地，若 $1$ 无法走到 $i$，则认为 $1$ 到 $i$ 的最短路长度为 $-1$）。", "inputFormat": "**本题多组询问。** 第一行输入一个数 $T$，表示询问组数。\n\n对于每组询问：\n\n第一行，两个整数 $n,m$。\n\n第二行至第 $m+1$ 行，每行两个整数 $u,v$，表示 $u,v$ 之间有一条边。", "outputFormat": "对于每组询问，输出一个实数，为 ```dis[]``` 数组完全正确的概率。**你需要输出答案保留三位小数（四舍五入）后的结果。**", "hint": "- 对于 $20\\%$ 的数据，$n,m\\le 10$。\n- 对于 $50\\%$ 的数据，$n,m\\le 1000$。\n- 对于另外 $30\\%$ 的数据，保证所给出的图为一仙人掌（任意一条边至多只出现在一条环上）。\n- 对于 $100\\%$ 的数据，$1\\le n,m\\le 50000，1\\le T\\le 10$，保证所输入的图无重边、自环。", "locale": "zh-CN"}}}
{"pid": "P8882", "type": "P", "difficulty": 4, "samples": [["2\n1\n4\nAdd 1\nUpd 2\nDel 3\nDel 1", "1\n2\n1\n1\n1\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化"], "title": "成熟时追随原神", "background": "可莉喜欢生活在树上。\n\n![](https://img2.huashi6.com/images/resource/2021/04/29/8945867h9p0.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)\n\n画师 pid：4787895", "description": "可莉生活在一颗有根树上，初始节点从 $1$ 到 $n$ 编号。为了方便可莉的出行，蒙德人决定从每个非叶子节点出发，修建一条新道路。具体而言，对与每个非叶子节点 $u$，蒙德人会从其子节点中均匀随机选取一个点 $v$，并在 $u$ 和 $v$ 之间修建一条新道路。显然，这些新修建的道路连成了许多的连通块。为了帮助他们的修建，你需要告诉蒙德人，连通块个数的期望是多少。\n\n可莉听说这个任务后，认为它对于你而言太简单了。因此，她决定添加一些对于树的修改操作：\n\n- $\\text{Add}\\ u$：在节点 $u$ 下添加一子结点，编号为 $n+i$，其中 $i$ 为操作编号。保证操作前结点 $u$ 存在。\n- $\\text{Del}\\ u$：删除结点 $u$。保证操作前结点 $u$ 存在且为叶子结点。\n- $\\text{Upd}\\ u$：将树根变为 $u$。保证操作前结点 $u$ 存在。\n\n同时，对于任意时刻，保证树不会被删空。\n\n对于初始的树和每次修改之后所得的树，你都需要回答一遍上述的问题。注意，$m$ 次修改之间不独立，但是蒙德人每次修建的新道路不受上一次结果的影响。", "inputFormat": "第一行，一个整数 $n$，表示初始树的大小。\n\n第二行至第 $n$ 行，每行输入一个整数，第 $i$ 行将给出 $f_i$，即初始树中 $i$ 的父节点。初始时，节点 $1$ 为树根。\n\n第 $n+1$ 行，一个整数 $m$，表示修改操作个数。\n\n第 $n+2$ 行至第 $n+m+1$ 行，每行输入一个修改操作，形式见 **题目描述**。", "outputFormat": "输出共 $m+1$ 行。\n\n第 $1$ 行，为初始时的答案。\n\n第 $2$ 行至第 $m+1$ 行，第 $i$ 行应输出第 $i-1$ 次修改操作后的答案。\n\n所有输出均对 $998244353$ 取模。具体而言，如果答案为 $\\frac{p}{q}$，你应当输出一个满足 $xq\\equiv p\\pmod {998244353}$ 的 $x$。", "hint": "$$\n\\begin{array}{|c|c|c|c|}\\hline\n\\textbf{测试点编号}& { n\\le} & {m\\le} & \\textbf{特殊性质} \\cr\\hline\n1\\sim 3 & 5 & 5 & - \\cr\\hline\n4\\sim 7 & 1000 & 1000 &- \\cr\\hline\n8\\sim 10 & 10^5 & 0 & - \\cr\\hline\n11\\sim 13 & 10^5 & 2\\times 10^5 & \\textbf{AB}\\cr\\hline\n14\\sim 16 & 2\\times 10^5 & 5\\times 10^4 & \\textbf{A} \\cr\\hline\n17\\sim 20 & 2\\times 10^5 & 2\\times 10^5 & - \\cr\\hline\n\\end{array}\n$$\n\n- 特殊性质 $\\textbf{A}$：保证不存在 $\\text{Upd}$ 操作。\n- 特殊性质 $\\textbf{B}$：保证不存在 $\\text{Del}$ 操作。\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 2\\times 10^5$。保证 $1\\le f_i<i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "成熟时追随原神", "background": "可莉喜欢生活在树上。\n\n![](https://img2.huashi6.com/images/resource/2021/04/29/8945867h9p0.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)\n\n画师 pid：4787895", "description": "可莉生活在一颗有根树上，初始节点从 $1$ 到 $n$ 编号。为了方便可莉的出行，蒙德人决定从每个非叶子节点出发，修建一条新道路。具体而言，对与每个非叶子节点 $u$，蒙德人会从其子节点中均匀随机选取一个点 $v$，并在 $u$ 和 $v$ 之间修建一条新道路。显然，这些新修建的道路连成了许多的连通块。为了帮助他们的修建，你需要告诉蒙德人，连通块个数的期望是多少。\n\n可莉听说这个任务后，认为它对于你而言太简单了。因此，她决定添加一些对于树的修改操作：\n\n- $\\text{Add}\\ u$：在节点 $u$ 下添加一子结点，编号为 $n+i$，其中 $i$ 为操作编号。保证操作前结点 $u$ 存在。\n- $\\text{Del}\\ u$：删除结点 $u$。保证操作前结点 $u$ 存在且为叶子结点。\n- $\\text{Upd}\\ u$：将树根变为 $u$。保证操作前结点 $u$ 存在。\n\n同时，对于任意时刻，保证树不会被删空。\n\n对于初始的树和每次修改之后所得的树，你都需要回答一遍上述的问题。注意，$m$ 次修改之间不独立，但是蒙德人每次修建的新道路不受上一次结果的影响。", "inputFormat": "第一行，一个整数 $n$，表示初始树的大小。\n\n第二行至第 $n$ 行，每行输入一个整数，第 $i$ 行将给出 $f_i$，即初始树中 $i$ 的父节点。初始时，节点 $1$ 为树根。\n\n第 $n+1$ 行，一个整数 $m$，表示修改操作个数。\n\n第 $n+2$ 行至第 $n+m+1$ 行，每行输入一个修改操作，形式见 **题目描述**。", "outputFormat": "输出共 $m+1$ 行。\n\n第 $1$ 行，为初始时的答案。\n\n第 $2$ 行至第 $m+1$ 行，第 $i$ 行应输出第 $i-1$ 次修改操作后的答案。\n\n所有输出均对 $998244353$ 取模。具体而言，如果答案为 $\\frac{p}{q}$，你应当输出一个满足 $xq\\equiv p\\pmod {998244353}$ 的 $x$。", "hint": "$$\n\\begin{array}{|c|c|c|c|}\\hline\n\\textbf{测试点编号}& { n\\le} & {m\\le} & \\textbf{特殊性质} \\cr\\hline\n1\\sim 3 & 5 & 5 & - \\cr\\hline\n4\\sim 7 & 1000 & 1000 &- \\cr\\hline\n8\\sim 10 & 10^5 & 0 & - \\cr\\hline\n11\\sim 13 & 10^5 & 2\\times 10^5 & \\textbf{AB}\\cr\\hline\n14\\sim 16 & 2\\times 10^5 & 5\\times 10^4 & \\textbf{A} \\cr\\hline\n17\\sim 20 & 2\\times 10^5 & 2\\times 10^5 & - \\cr\\hline\n\\end{array}\n$$\n\n- 特殊性质 $\\textbf{A}$：保证不存在 $\\text{Upd}$ 操作。\n- 特殊性质 $\\textbf{B}$：保证不存在 $\\text{Del}$ 操作。\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 2\\times 10^5$。保证 $1\\le f_i<i$。", "locale": "zh-CN"}}}
{"pid": "P8883", "type": "P", "difficulty": 5, "samples": [["3\n10\n32678\n9686985\n", "3\n12814\n3797988"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "Special Judge", "O2优化"], "title": "幻想中成为原神", "background": "钟离很喜欢数学题。", "description": "其中一个问题是这样的：定义一个丘丘人是可以被击杀的，当且仅当存在一个大于 $1$ 的完全平方数能够整除它的编号。比如，$12$ 号丘丘人就是可以被击杀的，因为它能够被 $4$ 整除；$15$ 号丘丘人则不能被击杀。请计算编号为 $1\\sim n$ 中的丘丘人中能够被击杀的个数。由于钟离秉承着“差不多得了”的做事理念，因此，他允许你的答案与真正的答案有着不超过 $2\\times10^4$ 的绝对误差。", "inputFormat": "**本题多组询问**。第一行输入一个数 $T$，表示询问组数。\n\n每组询问输入一行，一个正整数 $n$。", "outputFormat": "对于每组询问，输出一行一个整数，表示编号为 $1\\sim n$ 中的丘丘人中能够被击杀的个数。", "hint": "#### 样例解释\n\n$1\\sim 10$ 中，只有 $4,8,9$ 这 $3$ 个丘丘人可以被击杀，因此答案为 $3$。\n\n需要注意的是，由于你的答案被允许与标准答案有 $2\\times 10^4$ 的绝对误差，因此 $-2,3,20003$ 等输出都将被认为是正确的。\n\n#### 数据范围\n\n- $\\text{Subtask 1(10 pts)}$：$n\\le 10^5$。\n- $\\text{Subtask 2(20 pts)}$：$n\\le 10^7$。\n- $\\text{Subtask 3(20 pts)}$：$n\\le 10^9$。\n- $\\text{Subtask 4(20 pts)}$：$T=1$。\n- $\\text{Subtask 5(30 pts)}$：无特殊性质。\n\n对于 $100\\%$ 数据，满足 $1\\le n\\le 10^{18}$，$1\\le T\\le 10^4$，保证 $n$ 在范围内随机得到。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "幻想中成为原神", "background": "钟离很喜欢数学题。", "description": "其中一个问题是这样的：定义一个丘丘人是可以被击杀的，当且仅当存在一个大于 $1$ 的完全平方数能够整除它的编号。比如，$12$ 号丘丘人就是可以被击杀的，因为它能够被 $4$ 整除；$15$ 号丘丘人则不能被击杀。请计算编号为 $1\\sim n$ 中的丘丘人中能够被击杀的个数。由于钟离秉承着“差不多得了”的做事理念，因此，他允许你的答案与真正的答案有着不超过 $2\\times10^4$ 的绝对误差。", "inputFormat": "**本题多组询问**。第一行输入一个数 $T$，表示询问组数。\n\n每组询问输入一行，一个正整数 $n$。", "outputFormat": "对于每组询问，输出一行一个整数，表示编号为 $1\\sim n$ 中的丘丘人中能够被击杀的个数。", "hint": "#### 样例解释\n\n$1\\sim 10$ 中，只有 $4,8,9$ 这 $3$ 个丘丘人可以被击杀，因此答案为 $3$。\n\n需要注意的是，由于你的答案被允许与标准答案有 $2\\times 10^4$ 的绝对误差，因此 $-2,3,20003$ 等输出都将被认为是正确的。\n\n#### 数据范围\n\n- $\\text{Subtask 1(10 pts)}$：$n\\le 10^5$。\n- $\\text{Subtask 2(20 pts)}$：$n\\le 10^7$。\n- $\\text{Subtask 3(20 pts)}$：$n\\le 10^9$。\n- $\\text{Subtask 4(20 pts)}$：$T=1$。\n- $\\text{Subtask 5(30 pts)}$：无特殊性质。\n\n对于 $100\\%$ 数据，满足 $1\\le n\\le 10^{18}$，$1\\le T\\le 10^4$，保证 $n$ 在范围内随机得到。", "locale": "zh-CN"}}}
{"pid": "P8884", "type": "P", "difficulty": 3, "samples": [["3 3 5\n1 2\n1 3\n2 1\n3 2\n3 3\n3\n1 2 2 3 0\n1 2 3 3 4\n1 2\n1 3\n2 3\n3 3\n1 1 2 3 2\n1 3\n2 2", "NO\nYES\nNO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化"], "title": "「JEOI-R1」棋", "background": "| 出题 | 标程 | 数据 | 验题 | 题解 |\n| -----------: | -----------: | -----------: | -----------: | -----------: |\n | [RedNebula](/user/478829) | [RedNebula](/user/478829) | [RedNebula](/user/478829) and [gyyyyx](/user/554574) | [gyyyyx](/user/554574) | [RedNebula](/user/478829) |\n \n[RedNebula](/user/478829) 和 [_JF_](/user/361141) 在下一盘棋，然后……", "description": "现在有一个 $n\\times m$ 的棋盘，从上到下依次是 $1\\sim n$ 行，从左到右依次是 $1\\sim m$ 列，一个位于第 $x$ 行第 $y$ 列的位置被标记为 $(x,y)$。共有 $c$ 个棋子，**不重叠**地摆放在棋盘的某些位置上。一个位于 $(x,y)$ 的棋子可以走向 $(x-1,y-1),(x-1,y+1),(x+1,y-1),(x+1,y+1)$（如果这些位置**存在**且其上**没有棋子**）。\n\n现有若干询问，每次询问给定 $x_1,y_1,x_2,y_2,p$，然后给定 $p$ 个位置，表示一个子矩阵的左上角位置为 $(x_1,y_1)$，右下角位置为 $(x_2,y_2)$，问是否可以移动棋子（无次数限制）使得矩阵内**有且仅有**给定的 $p$ 个位置上有棋子。**询问之间相互独立。**\n\n为了减少程序时间复杂度的常数影响，**建议使用更快的读入方式。**", "inputFormat": "第一行三个正整数 $n,m,c$，表示棋盘的列数、行数和已有的棋子数。\n\n接下来 $c$ 行，一行两个整数 $a_i,b_i$，表示有一个棋子位于 $a_i$ 行 $b_i$ 列处。\n\n接下来一行一个正整数 $q$。\n\n接下来 $q$ 组询问。每一组询问第一行是五个正整数 $x_1,y_1,x_2,y_2,p$，接下来 $p$ 行每行两个正整数 $c_i,d_i$，表示只希望矩阵内有棋子的位置。", "outputFormat": "对于每个询问，如果可以移动棋子（无次数限制）使得矩阵内有且仅有给定的位置上有棋子，输出 `YES`，否则输出 `NO`。", "hint": "**【样例解释 \\#1】**\n\n解释以 `0` 代表空位，`1` 代表放置了棋子的位置。\n\n初始状态：\n\n```plain\n011\n100\n011\n```\n\n对于第一个询问，可以证明 $(1,2)$ 处的棋子无法移出 $(1,2)$ 到 $(2,3)$ 的矩阵。\n\n对于第二个询问，考虑把 $(3,2)$ 处的棋子移到 $(2,3)$，得：\n\n```plain\n011\n101\n001\n```\n\n满足询问要求。移动方式不唯一。\n\n对于第三个询问，可以证明 $(2,1)$ 处的棋子无法移出 $(1,1)$ 到 $(2,3)$ 的矩阵。\n\n**【数据范围】**\n\n对于 $25\\%$ 的数据，$n,m,q\\le 10$，$c\\le 20$。\n\n对于另外 $25\\%$ 的数据，保证 $a_i+b_i\\equiv 0 \\pmod 2$，$c_i+d_i\\equiv 0 \\pmod 2$。\n\n对于另外 $25\\%$ 的数据，保证 $n\\cdot m-c\\le(x_2-x_1+1)\\cdot (y_2-y_1+1)-p$。\n\n对于 $100\\%$ 的数据，$2\\le n,m\\le 10^5$，$1\\le c,q\\le 10^5$，$c\\le n\\cdot m$，$1\\le a_i\\le n$，$1\\le b_i\\le m$，$\\sum p\\le 2\\times 10^5$。对于每个询问，$1\\le p\\le (x_2-x_1+1)\\cdot (y_2-y_1+1)$，$x_1\\le c_i\\le x_2$，$y_1\\le d_i\\le y_2$。\n\n**【提示与说明】**\n\n提供一种较快的读入一个 `int` 类型非负整数的方式。调用下文中的 `read()`，其作用是返回输入中的一个非负整数，同时读取其后的一个字符。\n\n```cpp\nint read() {\n  int x(0);\n  char c(getchar());\n  while (c < '0' || c > '9') c = getchar();\n  while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  return x;\n}\n```", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「JEOI-R1」棋", "background": "| 出题 | 标程 | 数据 | 验题 | 题解 |\n| -----------: | -----------: | -----------: | -----------: | -----------: |\n | [RedNebula](/user/478829) | [RedNebula](/user/478829) | [RedNebula](/user/478829) and [gyyyyx](/user/554574) | [gyyyyx](/user/554574) | [RedNebula](/user/478829) |\n \n[RedNebula](/user/478829) 和 [_JF_](/user/361141) 在下一盘棋，然后……", "description": "现在有一个 $n\\times m$ 的棋盘，从上到下依次是 $1\\sim n$ 行，从左到右依次是 $1\\sim m$ 列，一个位于第 $x$ 行第 $y$ 列的位置被标记为 $(x,y)$。共有 $c$ 个棋子，**不重叠**地摆放在棋盘的某些位置上。一个位于 $(x,y)$ 的棋子可以走向 $(x-1,y-1),(x-1,y+1),(x+1,y-1),(x+1,y+1)$（如果这些位置**存在**且其上**没有棋子**）。\n\n现有若干询问，每次询问给定 $x_1,y_1,x_2,y_2,p$，然后给定 $p$ 个位置，表示一个子矩阵的左上角位置为 $(x_1,y_1)$，右下角位置为 $(x_2,y_2)$，问是否可以移动棋子（无次数限制）使得矩阵内**有且仅有**给定的 $p$ 个位置上有棋子。**询问之间相互独立。**\n\n为了减少程序时间复杂度的常数影响，**建议使用更快的读入方式。**", "inputFormat": "第一行三个正整数 $n,m,c$，表示棋盘的列数、行数和已有的棋子数。\n\n接下来 $c$ 行，一行两个整数 $a_i,b_i$，表示有一个棋子位于 $a_i$ 行 $b_i$ 列处。\n\n接下来一行一个正整数 $q$。\n\n接下来 $q$ 组询问。每一组询问第一行是五个正整数 $x_1,y_1,x_2,y_2,p$，接下来 $p$ 行每行两个正整数 $c_i,d_i$，表示只希望矩阵内有棋子的位置。", "outputFormat": "对于每个询问，如果可以移动棋子（无次数限制）使得矩阵内有且仅有给定的位置上有棋子，输出 `YES`，否则输出 `NO`。", "hint": "**【样例解释 \\#1】**\n\n解释以 `0` 代表空位，`1` 代表放置了棋子的位置。\n\n初始状态：\n\n```plain\n011\n100\n011\n```\n\n对于第一个询问，可以证明 $(1,2)$ 处的棋子无法移出 $(1,2)$ 到 $(2,3)$ 的矩阵。\n\n对于第二个询问，考虑把 $(3,2)$ 处的棋子移到 $(2,3)$，得：\n\n```plain\n011\n101\n001\n```\n\n满足询问要求。移动方式不唯一。\n\n对于第三个询问，可以证明 $(2,1)$ 处的棋子无法移出 $(1,1)$ 到 $(2,3)$ 的矩阵。\n\n**【数据范围】**\n\n对于 $25\\%$ 的数据，$n,m,q\\le 10$，$c\\le 20$。\n\n对于另外 $25\\%$ 的数据，保证 $a_i+b_i\\equiv 0 \\pmod 2$，$c_i+d_i\\equiv 0 \\pmod 2$。\n\n对于另外 $25\\%$ 的数据，保证 $n\\cdot m-c\\le(x_2-x_1+1)\\cdot (y_2-y_1+1)-p$。\n\n对于 $100\\%$ 的数据，$2\\le n,m\\le 10^5$，$1\\le c,q\\le 10^5$，$c\\le n\\cdot m$，$1\\le a_i\\le n$，$1\\le b_i\\le m$，$\\sum p\\le 2\\times 10^5$。对于每个询问，$1\\le p\\le (x_2-x_1+1)\\cdot (y_2-y_1+1)$，$x_1\\le c_i\\le x_2$，$y_1\\le d_i\\le y_2$。\n\n**【提示与说明】**\n\n提供一种较快的读入一个 `int` 类型非负整数的方式。调用下文中的 `read()`，其作用是返回输入中的一个非负整数，同时读取其后的一个字符。\n\n```cpp\nint read() {\n  int x(0);\n  char c(getchar());\n  while (c < '0' || c > '9') c = getchar();\n  while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  return x;\n}\n```", "locale": "zh-CN"}}}
{"pid": "P8885", "type": "P", "difficulty": 6, "samples": [["5\n100?1\n5\n1 5\n1 4\n2 5\n3 4\n1 3", "1\n0\n1\n1\n1"], ["20\n1110??01001010?1?110\n20\n1 20\n5 16\n11 16\n10 13\n5 14\n13 17\n1 18\n1 7\n6 9\n15 19\n12 17\n17 18\n4 11\n3 13\n13 15\n18 19\n2 8\n7 13\n4 15\n9 18", "3\n2\n2\n0\n4\n2\n13\n3\n0\n1\n3\n1\n2\n2\n2\n1\n2\n1\n1\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP"], "title": "「JEOI-R1」子序列", "background": "| 出题 | 标程 | 数据 | 验题 | 题解 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| [Pekemetier](/user/146070) | [Pekemetier](/user/146070) | [Pekemetier](/user/146070) | [cq_zry](https://www.luogu.com.cn/user/734533) & [lOlAKME](/user/768786) | [Pekemetier](/user/146070) |\n", "description": "给定一个仅包含 `0`、`1` 和 `?` 的字符串，你需要将字符串中的每个 `?` 分别替换成 `0` 或 `1` 之一。也就是说替换成一个 $01$ 字符串。求有多少种替换方案，使得替换后的字符串满足：恰好拥有奇数个**不同的**子序列（包含空串）的非空子串的个数为奇数。特别地，如果字符串中不包含 `?`，应将其自身视为唯一的替换方案。\n\n每个数据点会给定一个字符串 $s$ ，然后每次对 $s$ 的一个子串进行询问，答案对 $998244353$ 取模。", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个长为 $n$ 的字符串 $s$，仅包含 `0`、`1` 和 `?`。\n\n第三行一个整数 $m$ 表示询问次数。\n\n接下来 $m$ 行，每行两个整数 $l,r$ 表示对子串 $s_{l,r}$ 进行一次询问。", "outputFormat": "输出 $m$ 行，每行一个整数表示答案，对 $998244353$ 取模。\n\n不存在合法方案则输出 `0`。", "hint": "**【样例解释】**\n\n对于【样例\\#1】的第一个询问 `1 5`，有 $2$ 种替换方案，分别为字符串 `10001` 和 `10011`。\n\n其中 `10001` 有 $3$ 个子串满足不同的子序列的个数为奇数：`10001`，拥有 $15$ 个不同的子序列；$s'_ {2,3}$ 和 $s'_ {3,4}$ 均为 `00`，都拥有 $3$ 个不同的子序列。\n\n而 `10011` 则拥有 $4$ 个子串满足不同的子序列的个数为奇数，分别为 `1001`、`00`、`0011`、`11`。\n\n`10001` 有奇数个子串满足子序列个数为奇数，因此计入答案；而 `10011` 有偶数个，因此不计入答案。\n\n对于【样例#2】的第一个询问 `1 20`，$s_{1,20}$ 有 $4$ 个 `?`，因此有 $2^4=16$ 种替换方案。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $n\\leq$ | $m\\leq$ | 特殊性质 | $\\text{Score}$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $10$ |  | $10$ |\n| $2$ | $100$ | $100$ | $s$ 不包含 `?` | $10$ |\n| $3$ | $500$ | $500$ | $s$ 不包含 `?` | $20$ |\n| $4$ | $1000$ | $1000$ |  | $20$ |\n| $5$ | $5000$ | $5000$ |  | $10$ |\n| $6$ | $5000$ | $10^5$ |  | $10$ |\n| $7$ | $5\\times10^4$ | $3\\times 10^5$ |  | $20$ |\n\n对于 $100\\%$ 的数据，满足 $1\\leq n\\leq 5\\times10^4$，$1\\leq m\\leq 3\\times10^5$，$s$ 仅包含 `0`、`1` 和 `?`。\n\n---\n\n**【提示与说明】**\n\n子串：在原来的字符串中选出一段连续字符组成的字符串。一个长为 $n$ 的字符串有 $\\frac{n(n+1)}{2}$ 个子串。例如字符串 `121` 共有 $6$ 个子串，分别为 `1`、`2`、`1`、`12`、`21`、`121`。注意在本题中，空串不算一个子串。\n\n子序列：在原来的字符串中任意删去若干个字符（也可以不删）形成的的字符串。例如字符串 `0110` 拥有 $11$ 个不同的子序列，分别为空串、`0`、`1`、`00`、`01`、`10`、`11`、`010`、`011`、`110`、`0110`。注意在本题中，空串也算一个子序列。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「JEOI-R1」子序列", "background": "| 出题 | 标程 | 数据 | 验题 | 题解 |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n| [Pekemetier](/user/146070) | [Pekemetier](/user/146070) | [Pekemetier](/user/146070) | [cq_zry](https://www.luogu.com.cn/user/734533) & [lOlAKME](/user/768786) | [Pekemetier](/user/146070) |\n", "description": "给定一个仅包含 `0`、`1` 和 `?` 的字符串，你需要将字符串中的每个 `?` 分别替换成 `0` 或 `1` 之一。也就是说替换成一个 $01$ 字符串。求有多少种替换方案，使得替换后的字符串满足：恰好拥有奇数个**不同的**子序列（包含空串）的非空子串的个数为奇数。特别地，如果字符串中不包含 `?`，应将其自身视为唯一的替换方案。\n\n每个数据点会给定一个字符串 $s$ ，然后每次对 $s$ 的一个子串进行询问，答案对 $998244353$ 取模。", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个长为 $n$ 的字符串 $s$，仅包含 `0`、`1` 和 `?`。\n\n第三行一个整数 $m$ 表示询问次数。\n\n接下来 $m$ 行，每行两个整数 $l,r$ 表示对子串 $s_{l,r}$ 进行一次询问。", "outputFormat": "输出 $m$ 行，每行一个整数表示答案，对 $998244353$ 取模。\n\n不存在合法方案则输出 `0`。", "hint": "**【样例解释】**\n\n对于【样例\\#1】的第一个询问 `1 5`，有 $2$ 种替换方案，分别为字符串 `10001` 和 `10011`。\n\n其中 `10001` 有 $3$ 个子串满足不同的子序列的个数为奇数：`10001`，拥有 $15$ 个不同的子序列；$s'_ {2,3}$ 和 $s'_ {3,4}$ 均为 `00`，都拥有 $3$ 个不同的子序列。\n\n而 `10011` 则拥有 $4$ 个子串满足不同的子序列的个数为奇数，分别为 `1001`、`00`、`0011`、`11`。\n\n`10001` 有奇数个子串满足子序列个数为奇数，因此计入答案；而 `10011` 有偶数个，因此不计入答案。\n\n对于【样例#2】的第一个询问 `1 20`，$s_{1,20}$ 有 $4$ 个 `?`，因此有 $2^4=16$ 种替换方案。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试**。\n\n| $\\text{Subtask}$ | $n\\leq$ | $m\\leq$ | 特殊性质 | $\\text{Score}$ |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10$ | $10$ |  | $10$ |\n| $2$ | $100$ | $100$ | $s$ 不包含 `?` | $10$ |\n| $3$ | $500$ | $500$ | $s$ 不包含 `?` | $20$ |\n| $4$ | $1000$ | $1000$ |  | $20$ |\n| $5$ | $5000$ | $5000$ |  | $10$ |\n| $6$ | $5000$ | $10^5$ |  | $10$ |\n| $7$ | $5\\times10^4$ | $3\\times 10^5$ |  | $20$ |\n\n对于 $100\\%$ 的数据，满足 $1\\leq n\\leq 5\\times10^4$，$1\\leq m\\leq 3\\times10^5$，$s$ 仅包含 `0`、`1` 和 `?`。\n\n---\n\n**【提示与说明】**\n\n子串：在原来的字符串中选出一段连续字符组成的字符串。一个长为 $n$ 的字符串有 $\\frac{n(n+1)}{2}$ 个子串。例如字符串 `121` 共有 $6$ 个子串，分别为 `1`、`2`、`1`、`12`、`21`、`121`。注意在本题中，空串不算一个子串。\n\n子序列：在原来的字符串中任意删去若干个字符（也可以不删）形成的的字符串。例如字符串 `0110` 拥有 $11$ 个不同的子序列，分别为空串、`0`、`1`、`00`、`01`、`10`、`11`、`010`、`011`、`110`、`0110`。注意在本题中，空串也算一个子序列。", "locale": "zh-CN"}}}
{"pid": "P8886", "type": "P", "difficulty": 4, "samples": [["2\n5\n..###\n#.#.#\n#..##\n...#.\n.###.\n5\n..#..\n##..#\n#.#..\n..#..\n.#...", "2\n2"], ["4\n5\n...*.\n*##*.\n#..*.\n#*###\n.....\n5\n.#*..\n.**.#\n###.*\n***.*\n**...\n5\n.**..\n***.#\n###.*\n***.*\n*****\n5\n.**..\n***.#\n###..\n***.*\n***..", "4\n2\n"], ["见下发文件portal1.in", "见下发文件portal1.ans"], ["见下发文件portal2.in", "见下发文件portal2.ans"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "O2优化", "图论建模", "最短路"], "title": "[DMOI-R1] Portal", "background": "出题人正在玩一款叫 Portal 的游戏。但由于他太菜了，于是找来了你，让你帮他过几个他过不去的关卡。\n\n什么？你说你不会玩？\n\n玩家需要通过传送门枪到达出口。利用传送门枪射击可开出两种门，分别是橙色门和蓝色门，两面都可作入口及出口。在创造门的时候，另一道同样颜色的门会消失，即是说同时间不可能存在两道同色的门，最多只可同时存在一道蓝色及一道橙色的门。\n\n两道传送门在三维空间之中的两个地点创造出视觉上及物理上的连系，传送门的立点只限于平面，玩家从门出来时会自动配合地心吸力调整身体水平。\n\n出题人把所有希望都寄托于你身上了哟。哦，对了，因为出题人是个白嫖党，因此他拥有的是盗版 Portal。", "description": "在一个 $n \\times n$ 的二维平面图上，用 $(x,y)$ 表示地图第 $x$ 行第 $y$ 列。每个点都是墙、虚空和地面中的一种，分别用 `#`，`*`，`.` 表示。玩家只能站在地面上。**地图之外都是墙。**\n\n你手里有一个传送门枪，可以发射蓝色和橙色的传送门，只能朝上下左右四个方向使用。\n\n在选定一个方向和颜色后，将会在该方向上第一个碰到的墙的墙面上建造选定颜色的传送门，并摧毁之前建造的这种颜色的传送门。两种颜色的传送门不能被建立在同一墙面。\n\n玩家可以朝上下左右四个方向的空地移动。玩家还可以在不同色传送门之间穿梭。假如玩家朝一堵墙移动并且墙面上有传送门，并且当前已经建立了两个传送门，那么会从另一个传送门出来（必须保证出来也站在陆地上）。\n\n出来的时候，玩家会站在另一个门外的空地上，**四个方向都可以。**\n\n一开始玩家站在 $(1,1)$，目的地是 $(n,n)$。求最少使用多少次传送门枪才能到达目的地。\n\n**注意哦，这里的使用指的是穿过多少面传送门。**", "inputFormat": "第一行一个正整数 $T$ 表示数据组数。\n\n每组数据第一行一个正整数 $n$ 表示平面图的行数和列数。\n\n接下来 $n$ 行每行 $n$ 个字符只包含 `#`，`*`，`.` 三种字符表示地图。", "outputFormat": "对于每组数据输出一个数表示最少需要使用传送门枪的次数。无法到达输出 `-1`。如果起点或终点不为陆地，那么直接结束程序。", "hint": "### 样例1解释\n\n我们用白色格子表示空地，黑色格子表示墙，蓝色格子表示蓝色传送门，橙色格子表示橙色传送门，可以画出第一局的如下地图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s16tq3vq.png)\n\n走到橙色传送门处，从橙色传送门进入，蓝色传送门出即可。\n\n而第二局地图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v7q0izdk.png)\n\n\n走到蓝色传送门处，从蓝色传送门进入，橙色传送门出即可。\n\n### 数据范围\n\n对于 $20\\%$ 的数据，$n \\le 10$。\n\n对于 $60\\%$ 的数据，$n \\le 100$。\n\n对于另外 $10\\%$ 的数据，$T=1$ 且不存在虚空。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 500$，$1 \\le T \\le 10$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[DMOI-R1] Portal", "background": "出题人正在玩一款叫 Portal 的游戏。但由于他太菜了，于是找来了你，让你帮他过几个他过不去的关卡。\n\n什么？你说你不会玩？\n\n玩家需要通过传送门枪到达出口。利用传送门枪射击可开出两种门，分别是橙色门和蓝色门，两面都可作入口及出口。在创造门的时候，另一道同样颜色的门会消失，即是说同时间不可能存在两道同色的门，最多只可同时存在一道蓝色及一道橙色的门。\n\n两道传送门在三维空间之中的两个地点创造出视觉上及物理上的连系，传送门的立点只限于平面，玩家从门出来时会自动配合地心吸力调整身体水平。\n\n出题人把所有希望都寄托于你身上了哟。哦，对了，因为出题人是个白嫖党，因此他拥有的是盗版 Portal。", "description": "在一个 $n \\times n$ 的二维平面图上，用 $(x,y)$ 表示地图第 $x$ 行第 $y$ 列。每个点都是墙、虚空和地面中的一种，分别用 `#`，`*`，`.` 表示。玩家只能站在地面上。**地图之外都是墙。**\n\n你手里有一个传送门枪，可以发射蓝色和橙色的传送门，只能朝上下左右四个方向使用。\n\n在选定一个方向和颜色后，将会在该方向上第一个碰到的墙的墙面上建造选定颜色的传送门，并摧毁之前建造的这种颜色的传送门。两种颜色的传送门不能被建立在同一墙面。\n\n玩家可以朝上下左右四个方向的空地移动。玩家还可以在不同色传送门之间穿梭。假如玩家朝一堵墙移动并且墙面上有传送门，并且当前已经建立了两个传送门，那么会从另一个传送门出来（必须保证出来也站在陆地上）。\n\n出来的时候，玩家会站在另一个门外的空地上，**四个方向都可以。**\n\n一开始玩家站在 $(1,1)$，目的地是 $(n,n)$。求最少使用多少次传送门枪才能到达目的地。\n\n**注意哦，这里的使用指的是穿过多少面传送门。**", "inputFormat": "第一行一个正整数 $T$ 表示数据组数。\n\n每组数据第一行一个正整数 $n$ 表示平面图的行数和列数。\n\n接下来 $n$ 行每行 $n$ 个字符只包含 `#`，`*`，`.` 三种字符表示地图。", "outputFormat": "对于每组数据输出一个数表示最少需要使用传送门枪的次数。无法到达输出 `-1`。如果起点或终点不为陆地，那么直接结束程序。", "hint": "### 样例1解释\n\n我们用白色格子表示空地，黑色格子表示墙，蓝色格子表示蓝色传送门，橙色格子表示橙色传送门，可以画出第一局的如下地图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s16tq3vq.png)\n\n走到橙色传送门处，从橙色传送门进入，蓝色传送门出即可。\n\n而第二局地图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/v7q0izdk.png)\n\n\n走到蓝色传送门处，从蓝色传送门进入，橙色传送门出即可。\n\n### 数据范围\n\n对于 $20\\%$ 的数据，$n \\le 10$。\n\n对于 $60\\%$ 的数据，$n \\le 100$。\n\n对于另外 $10\\%$ 的数据，$T=1$ 且不存在虚空。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 500$，$1 \\le T \\le 10$。", "locale": "zh-CN"}}}
{"pid": "P8887", "type": "P", "difficulty": 3, "samples": [["3\n2 5 493\n3 8 3219\n8 4 1294", "B won\nA won\nB won"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "博弈论", "洛谷原创", "O2优化"], "title": "[DMOI-R1] 柯基棋", "background": "小 A 和小 B 都是爱狗人士，且绝顶聪明，尤其喜爱柯基，于是他们发明了“柯基棋”。", "description": "小 A 和小 B 在一个 $n \\times n$ 的棋盘内轮流下棋。小 A 先手，小 B 后手。设当前有一只“柯基”被下在了棋盘的 $(x,y)$ 处，那么棋盘内的 $(x-1,y-1)$，$(x-1,y+1)$，$(x+1,y-1)$，$(x+1,y+1)$ 处都会变为这只“柯基”的地盘，也就不能再放一只“柯基”。当一个人不能再放下一只“柯基”时，他就输了。\n\n可惜，小 C 却不怎么喜欢柯基，所以他很反对小 A 和小 B 玩“柯基”棋，于是他非常喜欢捣乱棋局。当小 A 和小 B 一共下了 $x_i$ 只“柯基”时，小 C 就会以当前 $w \\times w$ 棋盘的中心为中心，扩大棋盘为 $(w+2) \\times (w+2)$，他一共会捣乱 $q$ 次。\n\n而你的任务是要判断这局棋是小 A 赢还是小 B 赢，如果小 A  赢，输出 `A won`，否则输出 `B won`。\n\n由于他们两个人比较贪玩，所以他们一共会玩 $T$ 局。\n\n**注意**：\n\n1. 当小 A 和小 B 已经将原来的棋盘下到不能再下时，他们会直接跳转到小 C 下一次的捣乱（如果有）。\n\n2. 小 A 和小 B 知道小 C 会捣乱，且会按照自己的最优策略走。\n\n由于数据过大，$x_i$ 由数据随机生成器给出。", "inputFormat": "第一行一个正整数 $T$，表示 $T$ 组数据。\n\n每组数据一行三个正整数 $n,q,seed$，其中 $seed$ 的作用见提示说明。", "outputFormat": "共 $T$ 行，每一行输出一个字符串 `A won` 或 `B won`。", "hint": "### 随机数据生成器\n\n每一轮游戏的 $x_i$ 由下方的生成器给出：\n\n```cpp\nunsigned long long x[10000005];\nunsigned long long xor_shift(unsigned long long &seed){\n  return seed^=seed>>12, seed^=seed<<25, seed^=seed>>27, seed*0x2545F4914F6CDD1D;\n}\nint main(){\n  //your code here\n  int n,q;\n  unsigned long long seed;\n  cin>>n>>q>>seed;\n  for(int i=1;i<=q;i++){\n\tx[i]=x[i-1]+((xor_shift(seed)%(unsigned long long)(2*2)+1))*2;\n  }\n  //your code here\n  return 0;\n}\n```\n\n### 样例解释\n\n对于第一局游戏，$x_i$ 数组如下：`6 8 16 18 22`。\n\n对于第二局游戏，$x_i$ 数组如下：`8 14 16 24 32 36 38 40`。\n\n对于第三局游戏，$x_i$ 数组如下：`4 8 10 16`。\n\n### 数据范围\n\n对于 $20\\%$ 的数据，$n,q\\leq100$。\n\n对于 $50\\%$ 的数据，$n,q\\leq10000$。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 10,2\\leq n,q,\\sum q \\leq 10^7$，$x_i \\equiv 0 \\pmod 2\\ (i\\in[1,q]),0 \\le seed \\le 10^7$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[DMOI-R1] 柯基棋", "background": "小 A 和小 B 都是爱狗人士，且绝顶聪明，尤其喜爱柯基，于是他们发明了“柯基棋”。", "description": "小 A 和小 B 在一个 $n \\times n$ 的棋盘内轮流下棋。小 A 先手，小 B 后手。设当前有一只“柯基”被下在了棋盘的 $(x,y)$ 处，那么棋盘内的 $(x-1,y-1)$，$(x-1,y+1)$，$(x+1,y-1)$，$(x+1,y+1)$ 处都会变为这只“柯基”的地盘，也就不能再放一只“柯基”。当一个人不能再放下一只“柯基”时，他就输了。\n\n可惜，小 C 却不怎么喜欢柯基，所以他很反对小 A 和小 B 玩“柯基”棋，于是他非常喜欢捣乱棋局。当小 A 和小 B 一共下了 $x_i$ 只“柯基”时，小 C 就会以当前 $w \\times w$ 棋盘的中心为中心，扩大棋盘为 $(w+2) \\times (w+2)$，他一共会捣乱 $q$ 次。\n\n而你的任务是要判断这局棋是小 A 赢还是小 B 赢，如果小 A  赢，输出 `A won`，否则输出 `B won`。\n\n由于他们两个人比较贪玩，所以他们一共会玩 $T$ 局。\n\n**注意**：\n\n1. 当小 A 和小 B 已经将原来的棋盘下到不能再下时，他们会直接跳转到小 C 下一次的捣乱（如果有）。\n\n2. 小 A 和小 B 知道小 C 会捣乱，且会按照自己的最优策略走。\n\n由于数据过大，$x_i$ 由数据随机生成器给出。", "inputFormat": "第一行一个正整数 $T$，表示 $T$ 组数据。\n\n每组数据一行三个正整数 $n,q,seed$，其中 $seed$ 的作用见提示说明。", "outputFormat": "共 $T$ 行，每一行输出一个字符串 `A won` 或 `B won`。", "hint": "### 随机数据生成器\n\n每一轮游戏的 $x_i$ 由下方的生成器给出：\n\n```cpp\nunsigned long long x[10000005];\nunsigned long long xor_shift(unsigned long long &seed){\n  return seed^=seed>>12, seed^=seed<<25, seed^=seed>>27, seed*0x2545F4914F6CDD1D;\n}\nint main(){\n  //your code here\n  int n,q;\n  unsigned long long seed;\n  cin>>n>>q>>seed;\n  for(int i=1;i<=q;i++){\n\tx[i]=x[i-1]+((xor_shift(seed)%(unsigned long long)(2*2)+1))*2;\n  }\n  //your code here\n  return 0;\n}\n```\n\n### 样例解释\n\n对于第一局游戏，$x_i$ 数组如下：`6 8 16 18 22`。\n\n对于第二局游戏，$x_i$ 数组如下：`8 14 16 24 32 36 38 40`。\n\n对于第三局游戏，$x_i$ 数组如下：`4 8 10 16`。\n\n### 数据范围\n\n对于 $20\\%$ 的数据，$n,q\\leq100$。\n\n对于 $50\\%$ 的数据，$n,q\\leq10000$。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 10,2\\leq n,q,\\sum q \\leq 10^7$，$x_i \\equiv 0 \\pmod 2\\ (i\\in[1,q]),0 \\le seed \\le 10^7$。\n", "locale": "zh-CN"}}}
