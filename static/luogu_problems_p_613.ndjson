{"pid": "P13435", "type": "P", "difficulty": 2, "samples": [["3\n115\n1051\n6233", "Case #1: 151\nCase #2: 1105\nCase #3: 6323"]], "limits": {"time": [2000, 3000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2009", "Google Code Jam"], "title": "[GCJ 2009 #1B] The Next Number", "background": "", "description": "You are writing out a list of numbers. Your list contains all numbers with exactly $D_i$ digits in its decimal representation which are equal to $i$, for each $i$ between 1 and 9, inclusive. You are writing them out in ascending order.\n\nFor example, you might be writing every number with two '1's and one '5'. Your list would begin 115, 151, 511, 1015, 1051.\n\nGiven $N$, the last number you wrote, compute what the next number in the list will be.", "inputFormat": "The first line of input contains an integer $T$, the number of test cases in the input. $T$ lines follow, one for each test case, each containing a single integer $N$.\n", "outputFormat": "For each test case, output\n\nCase #$X$: $K$\n\nwhere $X$ is the test case number, starting from 1, and $K$ is the next integer in the list.", "hint": "**Limits**\n\n**Small dataset(9 Pts)**\n\n- Time limit: ~~20~~ 2 seconds.\n- $1 \\leq T \\leq 50$\n- $1 \\leq N \\leq 10^6$\n\n**Large dataset(26 Pts)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq T \\leq 500$\n- $1 \\leq N \\leq 10^{20}$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #1B] The Next Number", "background": "", "description": "You are writing out a list of numbers. Your list contains all numbers with exactly $D_i$ digits in its decimal representation which are equal to $i$, for each $i$ between 1 and 9, inclusive. You are writing them out in ascending order.\n\nFor example, you might be writing every number with two '1's and one '5'. Your list would begin 115, 151, 511, 1015, 1051.\n\nGiven $N$, the last number you wrote, compute what the next number in the list will be.", "inputFormat": "The first line of input contains an integer $T$, the number of test cases in the input. $T$ lines follow, one for each test case, each containing a single integer $N$.\n", "outputFormat": "For each test case, output\n\nCase #$X$: $K$\n\nwhere $X$ is the test case number, starting from 1, and $K$ is the next integer in the list.", "hint": "**Limits**\n\n**Small dataset(9 Pts)**\n\n- Time limit: ~~20~~ 2 seconds.\n- $1 \\leq T \\leq 50$\n- $1 \\leq N \\leq 10^6$\n\n**Large dataset(26 Pts)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq T \\leq 500$\n- $1 \\leq N \\leq 10^{20}$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #1B] The Next Number", "background": "", "description": "你正在写一个数字列表。对于每个 $1 \\leq i \\leq 9$，你的列表包含所有十进制表示中恰好有 $D_i$ 个 $i$ 的数。你将这些数按升序排列。\n\n例如，你可能正在写所有恰好包含两个 '1' 和一个 '5' 的数。你的列表将以 115、151、511、1015、1051 开头。\n\n现在，给定 $N$，即你刚刚写下的最后一个数，请你计算列表中的下一个数是多少。", "inputFormat": "输入的第一行包含一个整数 $T$，表示测试用例的数量。接下来 $T$ 行，每行一个整数 $N$。\n", "outputFormat": "对于每个测试用例，输出\n\nCase #$X$: $K$\n\n其中 $X$ 是测试用例编号（从 1 开始），$K$ 是列表中的下一个整数。", "hint": "**限制条件**\n\n**小数据集（9 分）**\n\n- 时间限制：2 秒。\n- $1 \\leq T \\leq 50$\n- $1 \\leq N \\leq 10^6$\n\n**大数据集（26 分）**\n\n- 时间限制：3 秒。\n- $1 \\leq T \\leq 500$\n- $1 \\leq N \\leq 10^{20}$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13436", "type": "P", "difficulty": 5, "samples": [["2\n5 3\n2+1-2\n+3-4+\n5+2+1\n-4-0-\n9+5+1\n20 30 40\n3 2\n2+1\n+4+\n5+1\n2 20", "Case #1:\n1+5+5+9\n3+4+5+9+9\n4+9+9+9+9\nCase #2:\n2\n5+5+5+5"]], "limits": {"time": [3000, 12000], "memory": [1048576, 1048576]}, "tags": ["数学", "图论", "2009", "数论", "广度优先搜索 BFS", "Google Code Jam"], "title": "[GCJ 2009 #1B] Square Math", "background": "", "description": "Say we have a square that has $W$ cells on each side and, therefore, $W^2$ cells total. Let's go further and fill each cell with one of the following:\n\n* A digit from 0 to 9;\n* The addition sign (+);\n* The subtraction sign (-).\n\nIf, finally, we add a constraint that no 2 digits are horizontally or vertically adjacent and no 2 operators (+ or -) are horizontally or vertically adjacent, then our square can be called an \"arithmetic square\".\n\nSquare Math is the name of a puzzle where, given an arithmetic square, we start from any numeric cell and move either horizontally or vertically a cell at a time, finally ending in a numerical cell. The mathematical expression we get from the traversal is evaluated to get a single value. For example:\n\n```\n2+3\n+4-\n1+0\n```\n\nThe above is a valid arithmetic square of size $W = 3$. If we start from \"2\", move horizontally right, then vertically down, we'll get \"2+4\", which gives a value of \"6\". If we further move horizontally right, then vertically up, we'll get \"2+4-3\", which is equal to \"3\".\n\nIn Square Math, there is no limit to how many times you can use a particular cell. It is perfectly legal to move from a cell to its neighbor, then back to the original cell. Given an arithmetic square and a list of queries, your task is to find a Square Math expression which evaluates to each query.", "inputFormat": "The first line of input contains a single integer, $T$. $T$ test cases follow. The first line of each test case contains 2 integers, $W$ and $Q$. $W$ lines follow, each containing $W$ characters, representing the arithmetic square. Don't worry, all arithmetic squares in the input are well-formed. The following line contains a space separated list of $Q$ integers, representing the values which need to be computed by using Square Math (the queries). You can assume that all given values will have at least one possible Square Math solution.", "outputFormat": "For each test case, begin output with \"Case #$X$:\" on a line by itself, where $X$ is the test case number, starting from 1. Then, for each query within the test case, print the Square Math expression which evaluates to the query on a line by itself.\n\nIn the case where there are multiple possible Square Math expressions, print the one that is shortest. If there is still a tie, print the lexicographically smallest expression. Remember that '+' is lexicographically smaller than '-'.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 60$\n\n**Small dataset**\n\n- Time limit: ~~30~~ 3 seconds.\n- $2 \\leq W \\leq 10$\n- $1 \\leq Q \\leq 20$\n- $1 \\leq \\text{each query} \\leq 50$\n\n**Large dataset**\n\n- Time limit: ~~60~~ 12 seconds.\n- $2 \\leq W \\leq 20$\n- $1 \\leq Q \\leq 50$\n- $1 \\leq \\text{each query} \\leq 250$", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #1B] Square Math", "background": "", "description": "Say we have a square that has $W$ cells on each side and, therefore, $W^2$ cells total. Let's go further and fill each cell with one of the following:\n\n* A digit from 0 to 9;\n* The addition sign (+);\n* The subtraction sign (-).\n\nIf, finally, we add a constraint that no 2 digits are horizontally or vertically adjacent and no 2 operators (+ or -) are horizontally or vertically adjacent, then our square can be called an \"arithmetic square\".\n\nSquare Math is the name of a puzzle where, given an arithmetic square, we start from any numeric cell and move either horizontally or vertically a cell at a time, finally ending in a numerical cell. The mathematical expression we get from the traversal is evaluated to get a single value. For example:\n\n```\n2+3\n+4-\n1+0\n```\n\nThe above is a valid arithmetic square of size $W = 3$. If we start from \"2\", move horizontally right, then vertically down, we'll get \"2+4\", which gives a value of \"6\". If we further move horizontally right, then vertically up, we'll get \"2+4-3\", which is equal to \"3\".\n\nIn Square Math, there is no limit to how many times you can use a particular cell. It is perfectly legal to move from a cell to its neighbor, then back to the original cell. Given an arithmetic square and a list of queries, your task is to find a Square Math expression which evaluates to each query.", "inputFormat": "The first line of input contains a single integer, $T$. $T$ test cases follow. The first line of each test case contains 2 integers, $W$ and $Q$. $W$ lines follow, each containing $W$ characters, representing the arithmetic square. Don't worry, all arithmetic squares in the input are well-formed. The following line contains a space separated list of $Q$ integers, representing the values which need to be computed by using Square Math (the queries). You can assume that all given values will have at least one possible Square Math solution.", "outputFormat": "For each test case, begin output with \"Case #$X$:\" on a line by itself, where $X$ is the test case number, starting from 1. Then, for each query within the test case, print the Square Math expression which evaluates to the query on a line by itself.\n\nIn the case where there are multiple possible Square Math expressions, print the one that is shortest. If there is still a tie, print the lexicographically smallest expression. Remember that '+' is lexicographically smaller than '-'.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 60$\n\n**Small dataset**\n\n- Time limit: ~~30~~ 3 seconds.\n- $2 \\leq W \\leq 10$\n- $1 \\leq Q \\leq 20$\n- $1 \\leq \\text{each query} \\leq 50$\n\n**Large dataset**\n\n- Time limit: ~~60~~ 12 seconds.\n- $2 \\leq W \\leq 20$\n- $1 \\leq Q \\leq 50$\n- $1 \\leq \\text{each query} \\leq 250$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #1B] Square Math", "background": "", "description": "假设我们有一个边长为 $W$ 的正方形网格，因此总共有 $W^2$ 个格子。我们进一步规定，每个格子可以填入以下内容之一：\n\n- 一个 $0$ 到 $9$ 的数字；\n- 加号（+）；\n- 减号（-）。\n\n如果我们再加上如下约束：任意两个数字不能在水平方向或竖直方向相邻，任意两个运算符（+ 或 -）也不能在水平方向或竖直方向相邻，那么这样的正方形就称为一个“算术方格”。\n\nSquare Math 是这样一种谜题：给定一个算术方格，我们可以从任意一个数字格子出发，每次可以水平或竖直移动一格，最终在一个数字格子结束。我们按照经过的格子的内容，拼接成一个数学表达式并计算其值。例如：\n\n```\n2+3\n+4-\n1+0\n```\n\n上面是一个 $W=3$ 的合法算术方格。如果我们从“2”出发，向右水平移动，再向下垂直移动，就得到“2+4”，其值为 $6$。如果我们再向右水平移动，再向上垂直移动，就得到“2+4-3”，其值为 $3$。\n\n在 Square Math 中，对同一个格子的使用次数没有限制。也就是说，可以从某个格子移动到相邻格，再返回原格，这样的路径是允许的。给定一个算术方格和若干个查询值，请你为每个查询值找到一个 Square Math 路径，使得对应的表达式计算结果等于该值。\n", "inputFormat": "第一行是一个整数 $T$，表示测试用例数。接下来有 $T$ 组测试数据。每组测试数据的第一行包含两个整数 $W$ 和 $Q$。接下来 $W$ 行，每行 $W$ 个字符，表示算术方格。保证所有输入的算术方格都是合法的。再接下来一行，包含 $Q$ 个用空格分隔的整数，表示需要通过 Square Math 得到的目标值（查询）。保证每个目标值至少有一种合法的 Square Math 表达式可以实现。\n", "outputFormat": "对于每组测试数据，先输出一行 \"Case #$X$:\"，其中 $X$ 是测试编号（从 1 开始）。然后对于本组中的每个查询，输出一行对应的 Square Math 表达式。\n\n如果有多种可能的表达式，输出最短的那一个。如果仍有多个最短表达式，输出字典序最小的那个。注意，'+' 的字典序小于 '-'。\n", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 60$\n\n**小数据集**\n\n- 时间限制：3 秒\n- $2 \\leq W \\leq 10$\n- $1 \\leq Q \\leq 20$\n- $1 \\leq$ 每个查询 $\\leq 50$\n\n**大数据集**\n\n- 时间限制：12 秒\n- $2 \\leq W \\leq 20$\n- $1 \\leq Q \\leq 50$\n- $1 \\leq$ 每个查询 $\\leq 250$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13437", "type": "P", "difficulty": 2, "samples": [["3\n11001001\ncats\nzig", "Case #1: 201\nCase #2: 75\nCase #3: 11"]], "limits": {"time": [2000, 2000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2009", "进制", "Google Code Jam"], "title": "[GCJ 2009 #1C] All Your Base", "background": "", "description": "In A.D. 2100, aliens came to Earth. They wrote a message in a cryptic language, and next to it they wrote a series of symbols. We've come to the conclusion that the symbols indicate a number: the number of seconds before war begins!\n\nUnfortunately we have no idea what each symbol means. We've decided that each symbol indicates one digit, but we aren't sure what each digit means or what base the aliens are using. For example, if they wrote \"ab2ac999\", they could have meant \"31536000\" in base 10 -- exactly one year -- or they could have meant \"12314555\" in base 6 -- 398951 seconds, or about four and a half days. We are sure of three things: the number is positive; like us, the aliens will never start a number with a zero; and they aren't using unary (base 1).\n\nYour job is to determine the minimum possible number of seconds before war begins.", "inputFormat": "The first line of input contains a single integer, $T$. $T$ test cases follow. Each test case is a string on a line by itself. The line will contain only characters in the 'a' to 'z' and '0' to '9' ranges (with no spaces and no punctuation), representing the message the aliens left us. The test cases are independent, and can be in different bases with the symbols meaning different things.\n", "outputFormat": "For each test case, output a line in the following format:\n\nCase #$X$: $V$\n\nWhere $X$ is the case number (starting from 1) and $V$ is the minimum number of seconds before war begins.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$\n- The answer will never exceed $10^{18}$\n\n**Small dataset(8 Pts)**\n\n- $1 \\leq \\text{the length of each line} < 10$\n\n**Large dataset(15 Pts)**\n\n- $1 \\leq \\text{the length of each line} < 61$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #1C] All Your Base", "background": "", "description": "In A.D. 2100, aliens came to Earth. They wrote a message in a cryptic language, and next to it they wrote a series of symbols. We've come to the conclusion that the symbols indicate a number: the number of seconds before war begins!\n\nUnfortunately we have no idea what each symbol means. We've decided that each symbol indicates one digit, but we aren't sure what each digit means or what base the aliens are using. For example, if they wrote \"ab2ac999\", they could have meant \"31536000\" in base 10 -- exactly one year -- or they could have meant \"12314555\" in base 6 -- 398951 seconds, or about four and a half days. We are sure of three things: the number is positive; like us, the aliens will never start a number with a zero; and they aren't using unary (base 1).\n\nYour job is to determine the minimum possible number of seconds before war begins.", "inputFormat": "The first line of input contains a single integer, $T$. $T$ test cases follow. Each test case is a string on a line by itself. The line will contain only characters in the 'a' to 'z' and '0' to '9' ranges (with no spaces and no punctuation), representing the message the aliens left us. The test cases are independent, and can be in different bases with the symbols meaning different things.\n", "outputFormat": "For each test case, output a line in the following format:\n\nCase #$X$: $V$\n\nWhere $X$ is the case number (starting from 1) and $V$ is the minimum number of seconds before war begins.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$\n- The answer will never exceed $10^{18}$\n\n**Small dataset(8 Pts)**\n\n- $1 \\leq \\text{the length of each line} < 10$\n\n**Large dataset(15 Pts)**\n\n- $1 \\leq \\text{the length of each line} < 61$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #1C] All Your Base", "background": "", "description": "公元 2100 年，外星人来到了地球。他们用一种神秘的语言写下了一条信息，并在旁边写下了一串符号。我们推测这些符号表示一个数字：距离战争爆发还有多少秒！\n\n遗憾的是，我们完全不知道每个符号代表什么。我们认为每个符号都代表着一个数字，但我们不确定每个数字的含义，也不清楚外星人用的是什么进制。例如，如果他们写下了 \"ab2ac999\"，这可能意味着十进制下的 \"31536000\"——恰好是一年——也可能是六进制下的 \"12314555\"——也就是 398951 秒，约等于四天半。我们可以确定三件事：这个数字是正数；和我们一样，外星人绝不会让数字以零开头；他们不会使用一进制（即基数为 1）。\n\n你的任务是确定距离战争爆发的最小可能秒数。", "inputFormat": "输入的第一行包含一个整数 $T$。接下来有 $T$ 个测试用例。每个测试用例为一行字符串，单独占一行。每一行只包含 'a' 到 'z' 和 '0' 到 '9' 范围内的字符（没有空格和标点），代表外星人留下的信息。各个测试用例相互独立，进制和符号含义可以各不相同。\n", "outputFormat": "对于每个测试用例，输出一行，格式如下：\n\nCase #$X$: $V$\n\n其中 $X$ 是测试用例编号（从 1 开始），$V$ 是距离战争爆发的最小可能秒数。", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 100$\n- 答案不会超过 $10^{18}$\n\n**小数据集（8 分）**\n\n- 每行长度 $1 \\leq \\text{长度} < 10$\n\n**大数据集（15 分）**\n\n- 每行长度 $1 \\leq \\text{长度} < 61$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13438", "type": "P", "difficulty": 4, "samples": [["3\n3\n3 0 -4 0 0 3\n-3 -2 -1 3 0 0\n-3 -1 2 0 3 0\n3\n-5 0 0 1 0 0\n-7 0 0 1 0 0\n-6 3 0 1 0 0\n4\n1 2 3 1 2 3\n3 2 1 3 2 1\n1 0 0 0 0 -1\n0 10 0 0 -10 -1", "Case #1: 0.00000000 1.00000000\nCase #2: 1.00000000 6.00000000\nCase #3: 3.36340601 1.00000000"]], "limits": {"time": [2000, 2000], "memory": [1048576, 1048576]}, "tags": ["数学", "2009", "三分", "Special Judge", "Google Code Jam"], "title": "[GCJ 2009 #1C] Center of Mass", "background": "", "description": "You are studying a swarm of $N$ fireflies. Each firefly is moving in a straight line at a constant speed. You are standing at the center of the universe, at position $(0, 0, 0)$. Each firefly has the same mass, and you want to know how close the center of the swarm will get to your location (the origin).\n\nYou know the position and velocity of each firefly at $t = 0$, and are only interested in $t \\geq 0$. The fireflies have constant velocity, and may pass freely through all of space, including each other and you. Let $M(t)$ be the location of the center of mass of the $N$ fireflies at time $t$. Let $d(t)$ be the distance between your position and $M(t)$ at time $t$. Find the minimum value of $d(t)$, $d_{\\text{min}}$, and the earliest time when $d(t) = d_{\\text{min}}$, $t_{\\text{min}}$.", "inputFormat": "The first line of input contains a single integer $T$, the number of test cases. Each test case starts with a line that contains an integer $N$, the number of fireflies, followed by $N$ lines of the form\n\n$x\\ y\\ z\\ v_x\\ v_y\\ v_z$\n\nEach of these lines describes one firefly: $(x, y, z)$ is its initial position at time $t = 0$, and $(v_x, v_y, v_z)$ is its velocity.\n", "outputFormat": "For each test case, output\n\nCase #$X$: $d_{\\text{min}}$ $t_{\\text{min}}$\n\nwhere $X$ is the test case number, starting from 1. Any answer with absolute or relative error of at most $10^{-5}$ will be accepted.", "hint": "**Notes**\n\nGiven $N$ points $(x_i, y_i, z_i)$, their center of the mass is the point $(x_c, y_c, z_c)$, where:\n\n- $x_c = (x_1 + x_2 + \\ldots + x_N) / N$\n- $y_c = (y_1 + y_2 + \\ldots + y_N) / N$\n- $z_c = (z_1 + z_2 + \\ldots + z_N) / N$\n\n**Limits**\n\n- All the numbers in the input will be integers.\n- $1 \\leq T \\leq 100$\n- The values of $x$, $y$, $z$, $v_x$, $v_y$, and $v_z$ will be between $-5000$ and $5000$, inclusive.\n\n**Small dataset(10 Pts)**\n\n- $3 \\leq N \\leq 10$\n\n**Large dataset(17 Pts)**\n\n- $3 \\leq N \\leq 500$", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #1C] Center of Mass", "background": "", "description": "You are studying a swarm of $N$ fireflies. Each firefly is moving in a straight line at a constant speed. You are standing at the center of the universe, at position $(0, 0, 0)$. Each firefly has the same mass, and you want to know how close the center of the swarm will get to your location (the origin).\n\nYou know the position and velocity of each firefly at $t = 0$, and are only interested in $t \\geq 0$. The fireflies have constant velocity, and may pass freely through all of space, including each other and you. Let $M(t)$ be the location of the center of mass of the $N$ fireflies at time $t$. Let $d(t)$ be the distance between your position and $M(t)$ at time $t$. Find the minimum value of $d(t)$, $d_{\\text{min}}$, and the earliest time when $d(t) = d_{\\text{min}}$, $t_{\\text{min}}$.", "inputFormat": "The first line of input contains a single integer $T$, the number of test cases. Each test case starts with a line that contains an integer $N$, the number of fireflies, followed by $N$ lines of the form\n\n$x\\ y\\ z\\ v_x\\ v_y\\ v_z$\n\nEach of these lines describes one firefly: $(x, y, z)$ is its initial position at time $t = 0$, and $(v_x, v_y, v_z)$ is its velocity.\n", "outputFormat": "For each test case, output\n\nCase #$X$: $d_{\\text{min}}$ $t_{\\text{min}}$\n\nwhere $X$ is the test case number, starting from 1. Any answer with absolute or relative error of at most $10^{-5}$ will be accepted.", "hint": "**Notes**\n\nGiven $N$ points $(x_i, y_i, z_i)$, their center of the mass is the point $(x_c, y_c, z_c)$, where:\n\n- $x_c = (x_1 + x_2 + \\ldots + x_N) / N$\n- $y_c = (y_1 + y_2 + \\ldots + y_N) / N$\n- $z_c = (z_1 + z_2 + \\ldots + z_N) / N$\n\n**Limits**\n\n- All the numbers in the input will be integers.\n- $1 \\leq T \\leq 100$\n- The values of $x$, $y$, $z$, $v_x$, $v_y$, and $v_z$ will be between $-5000$ and $5000$, inclusive.\n\n**Small dataset(10 Pts)**\n\n- $3 \\leq N \\leq 10$\n\n**Large dataset(17 Pts)**\n\n- $3 \\leq N \\leq 500$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #1C] Center of Mass", "background": "", "description": "你正在研究一群 $N$ 只萤火虫。每只萤火虫都以恒定速度沿直线运动。你站在宇宙的中心，即位置 $(0, 0, 0)$。每只萤火虫的质量都相同，你想知道这群萤火虫的质心距离你的位置（原点）最近会有多近。\n\n你已知每只萤火虫在 $t = 0$ 时的初始位置和速度，且只关心 $t \\geq 0$ 的情形。萤火虫们速度恒定，可以自由穿越空间，包括互相穿过和穿过你。设 $M(t)$ 表示 $N$ 只萤火虫在时刻 $t$ 的质心位置，$d(t)$ 表示你的位置到 $M(t)$ 的距离。请你求出 $d(t)$ 的最小值 $d_{\\text{min}}$，以及最早使 $d(t) = d_{\\text{min}}$ 的时刻 $t_{\\text{min}}$。\n", "inputFormat": "输入的第一行包含一个整数 $T$，表示测试用例数。每个测试用例第一行为一个整数 $N$，表示萤火虫的数量，接下来有 $N$ 行，每行格式如下：\n\n$x\\ y\\ z\\ v_x\\ v_y\\ v_z$\n\n每行描述一只萤火虫：$(x, y, z)$ 是其在 $t = 0$ 时的初始位置，$(v_x, v_y, v_z)$ 是其速度。", "outputFormat": "对于每个测试用例，输出\n\nCase #$X$: $d_{\\text{min}}$ $t_{\\text{min}}$\n\n其中 $X$ 是测试编号（从 1 开始），$d_{\\text{min}}$ 是最小距离，$t_{\\text{min}}$ 是达到最小距离的最早时刻。你的答案只要绝对误差或相对误差不超过 $10^{-5}$ 即视为正确。\n", "hint": "**说明**\n\n给定 $N$ 个点 $(x_i, y_i, z_i)$，它们的质心为 $(x_c, y_c, z_c)$，其中：\n\n- $x_c = (x_1 + x_2 + \\ldots + x_N) / N$\n- $y_c = (y_1 + y_2 + \\ldots + y_N) / N$\n- $z_c = (z_1 + z_2 + \\ldots + z_N) / N$\n\n**限制条件**\n\n- 输入中的所有数均为整数。\n- $1 \\leq T \\leq 100$\n- $x$、$y$、$z$、$v_x$、$v_y$、$v_z$ 的取值范围均为 $-5000$ 到 $5000$，包含端点。\n\n**小数据集（10 分）**\n\n- $3 \\leq N \\leq 10$\n\n**大数据集（17 分）**\n\n- $3 \\leq N \\leq 500$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13439", "type": "P", "difficulty": 4, "samples": [["2\n8 1\n3\n20 3\n3 6 14", "Case #1: 7\nCase #2: 35"]], "limits": {"time": [2000, 3000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2009", "区间 DP", "Google Code Jam"], "title": "[GCJ 2009 #1C] Bribe the Prisoners", "background": "", "description": "In a kingdom there are prison cells (numbered $1$ to $P$) built to form a straight line segment. Cells number $i$ and $i+1$ are adjacent, and prisoners in adjacent cells are called \"neighbours.\" A wall with a window separates adjacent cells, and neighbours can communicate through that window.\n\nAll prisoners live in peace until a prisoner is released. When that happens, the released prisoner's neighbours find out, and each communicates this to his other neighbour. That prisoner passes it on to his other neighbour, and so on until they reach a prisoner with no other neighbour (because he is in cell $1$, or in cell $P$, or the other adjacent cell is empty). A prisoner who discovers that another prisoner has been released will angrily break everything in his cell, unless he is bribed with a gold coin. So, after releasing a prisoner in cell $A$, all prisoners housed on either side of cell $A$ - until cell $1$, cell $P$ or an empty cell - need to be bribed.\n\nAssume that each prison cell is initially occupied by exactly one prisoner, and that only one prisoner can be released per day. Given the list of $Q$ prisoners to be released in $Q$ days, find the minimum total number of gold coins needed as bribes if the prisoners may be released in any order.\n\nNote that each bribe only has an effect for one day. If a prisoner who was bribed yesterday hears about another released prisoner today, then he needs to be bribed again.", "inputFormat": "The first line of input gives the number of cases, $N$. $N$ test cases follow. Each case consists of 2 lines. The first line is formatted as\n\n$P \\ Q$\n\nwhere $P$ is the number of prison cells and $Q$ is the number of prisoners to be released.\n\nThis will be followed by a line with $Q$ distinct cell numbers (of the prisoners to be released), space separated, sorted in ascending order.\n", "outputFormat": "For each test case, output one line in the format\n\nCase #$X$: $C$\n\nwhere $X$ is the case number, starting from $1$, and $C$ is the minimum number of gold coins needed as bribes.", "hint": "**Sample Explanation**\n\nIn the second sample case, you first release the person in cell 14, then cell 6, then cell 3. The number of gold coins needed is $19 + 12 + 4 = 35$. If you instead release the person in cell 6 first, the cost will be $19 + 4 + 13 = 36$.\n\n**Limits**\n\n- $1 \\leq N \\leq 100$\n- $Q \\leq P$\n- Each cell number is between $1$ and $P$, inclusive.\n\n**Small dataset**\n\n- Time limit: ~~20~~ 2 seconds.\n- $1 \\leq P \\leq 100$\n- $1 \\leq Q \\leq 5$\n\n**Large dataset**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq P \\leq 10000$\n- $1 \\leq Q \\leq 100$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #1C] Bribe the Prisoners", "background": "", "description": "In a kingdom there are prison cells (numbered $1$ to $P$) built to form a straight line segment. Cells number $i$ and $i+1$ are adjacent, and prisoners in adjacent cells are called \"neighbours.\" A wall with a window separates adjacent cells, and neighbours can communicate through that window.\n\nAll prisoners live in peace until a prisoner is released. When that happens, the released prisoner's neighbours find out, and each communicates this to his other neighbour. That prisoner passes it on to his other neighbour, and so on until they reach a prisoner with no other neighbour (because he is in cell $1$, or in cell $P$, or the other adjacent cell is empty). A prisoner who discovers that another prisoner has been released will angrily break everything in his cell, unless he is bribed with a gold coin. So, after releasing a prisoner in cell $A$, all prisoners housed on either side of cell $A$ - until cell $1$, cell $P$ or an empty cell - need to be bribed.\n\nAssume that each prison cell is initially occupied by exactly one prisoner, and that only one prisoner can be released per day. Given the list of $Q$ prisoners to be released in $Q$ days, find the minimum total number of gold coins needed as bribes if the prisoners may be released in any order.\n\nNote that each bribe only has an effect for one day. If a prisoner who was bribed yesterday hears about another released prisoner today, then he needs to be bribed again.", "inputFormat": "The first line of input gives the number of cases, $N$. $N$ test cases follow. Each case consists of 2 lines. The first line is formatted as\n\n$P \\ Q$\n\nwhere $P$ is the number of prison cells and $Q$ is the number of prisoners to be released.\n\nThis will be followed by a line with $Q$ distinct cell numbers (of the prisoners to be released), space separated, sorted in ascending order.\n", "outputFormat": "For each test case, output one line in the format\n\nCase #$X$: $C$\n\nwhere $X$ is the case number, starting from $1$, and $C$ is the minimum number of gold coins needed as bribes.", "hint": "**Sample Explanation**\n\nIn the second sample case, you first release the person in cell 14, then cell 6, then cell 3. The number of gold coins needed is $19 + 12 + 4 = 35$. If you instead release the person in cell 6 first, the cost will be $19 + 4 + 13 = 36$.\n\n**Limits**\n\n- $1 \\leq N \\leq 100$\n- $Q \\leq P$\n- Each cell number is between $1$ and $P$, inclusive.\n\n**Small dataset**\n\n- Time limit: ~~20~~ 2 seconds.\n- $1 \\leq P \\leq 100$\n- $1 \\leq Q \\leq 5$\n\n**Large dataset**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq P \\leq 10000$\n- $1 \\leq Q \\leq 100$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #1C] Bribe the Prisoners", "background": "", "description": "在一个王国里，有一些牢房（编号为 $1$ 到 $P$），这些牢房排成一条直线。编号为 $i$ 和 $i+1$ 的牢房是相邻的，相邻牢房中的囚犯被称为“邻居”。相邻牢房之间有一堵带窗户的墙，邻居们可以通过窗户进行交流。\n\n所有囚犯本来相安无事，直到有囚犯被释放。当某个囚犯被释放时，他的邻居会得知这个消息，并且每个邻居会把这个消息传递给他的另一个邻居。如此传递下去，直到消息传到没有其他邻居的囚犯（即处在第 $1$ 号牢房、第 $P$ 号牢房，或其相邻牢房已空的囚犯）。每当某个囚犯得知有其他囚犯被释放时，除非他被贿赂一枚金币，否则他会愤怒地砸坏自己牢房里的所有东西。因此，当释放编号为 $A$ 的囚犯时，$A$ 号牢房两侧的所有囚犯——从 $A$ 向左直到第 $1$ 号牢房、向右直到第 $P$ 号牢房或遇到空牢房为止——都需要被贿赂。\n\n假设每个牢房最初都正好关押着一名囚犯，并且每天只能释放一个囚犯。给定 $Q$ 个将要被释放的囚犯（共需 $Q$ 天），请你计算，如果可以任意选择释放顺序，最少需要多少金币用于贿赂。\n\n注意，每一次贿赂只对当天有效。如果某个囚犯昨天被贿赂了，今天又听说有囚犯被释放，他还需要再次被贿赂。\n", "inputFormat": "输入的第一行是测试用例数 $N$。接下来有 $N$ 组测试数据。每组数据包含两行。第一行为：\n\n$P \\ Q$\n\n其中 $P$ 是牢房的总数，$Q$ 是需要释放的囚犯数。\n\n接下来一行包含 $Q$ 个不同的牢房编号（要被释放的囚犯所在牢房），用空格分隔，按升序排列。", "outputFormat": "对于每组测试数据，输出一行，格式如下：\n\nCase #$X$: $C$\n\n其中 $X$ 是测试编号（从 $1$ 开始），$C$ 是最少需要的金币数。", "hint": "**样例说明**\n\n在第二个样例中，假如你先释放 14 号牢房的囚犯，再释放 6 号，最后释放 3 号，所需金币数为 $19 + 12 + 4 = 35$。如果你先释放 6 号，再释放 3 号，最后释放 14 号，所需金币数为 $19 + 4 + 13 = 36$。\n\n**限制条件**\n\n- $1 \\leq N \\leq 100$\n- $Q \\leq P$\n- 每个牢房编号均为 $1$ 到 $P$ 之间的整数\n\n**小数据集**\n\n- 时间限制：2 秒\n- $1 \\leq P \\leq 100$\n- $1 \\leq Q \\leq 5$\n\n**大数据集**\n\n- 时间限制：3 秒\n- $1 \\leq P \\leq 10000$\n- $1 \\leq Q \\leq 100$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13440", "type": "P", "difficulty": 2, "samples": [["3\n2\n10\n11\n3\n001\n100\n010\n4\n1110\n1100\n1100\n1000", "Case #1: 0\nCase #2: 2\nCase #3: 4"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2009", "Google Code Jam"], "title": "[GCJ 2009 #2] Crazy Rows", "background": "", "description": "You are given an $N \\times N$ matrix with $0$ and $1$ values. You can swap any two adjacent rows of the matrix.\n\nYour goal is to have all the $1$ values in the matrix below or on the main diagonal. That is, for each $X$ where $1 \\leq X \\leq N$, there must be no $1$ values in row $X$ that are to the right of column $X$.\n\nReturn the minimum number of row swaps you need to achieve the goal.", "inputFormat": "The first line of input gives the number of cases, $T$. $T$ test cases follow.\n\nThe first line of each test case has one integer, $N$. Each of the next $N$ lines contains $N$ characters. Each character is either $0$ or $1$.\n", "outputFormat": "For each test case, output\n\nCase #X: K\n\nwhere $X$ is the test case number, starting from $1$, and $K$ is the minimum number of row swaps needed to have all the $1$ values in the matrix below or on the main diagonal.\n\nYou are guaranteed that there is a solution for each test case.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 60$\n\n**Small dataset(6 Pts)**\n\n- $1 \\leq N \\leq 8$\n\n**Large dataset(10 Pts)**\n\n- $1 \\leq N \\leq 40$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #2] Crazy Rows", "background": "", "description": "You are given an $N \\times N$ matrix with $0$ and $1$ values. You can swap any two adjacent rows of the matrix.\n\nYour goal is to have all the $1$ values in the matrix below or on the main diagonal. That is, for each $X$ where $1 \\leq X \\leq N$, there must be no $1$ values in row $X$ that are to the right of column $X$.\n\nReturn the minimum number of row swaps you need to achieve the goal.", "inputFormat": "The first line of input gives the number of cases, $T$. $T$ test cases follow.\n\nThe first line of each test case has one integer, $N$. Each of the next $N$ lines contains $N$ characters. Each character is either $0$ or $1$.\n", "outputFormat": "For each test case, output\n\nCase #X: K\n\nwhere $X$ is the test case number, starting from $1$, and $K$ is the minimum number of row swaps needed to have all the $1$ values in the matrix below or on the main diagonal.\n\nYou are guaranteed that there is a solution for each test case.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 60$\n\n**Small dataset(6 Pts)**\n\n- $1 \\leq N \\leq 8$\n\n**Large dataset(10 Pts)**\n\n- $1 \\leq N \\leq 40$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #2] Crazy Rows", "background": "", "description": "给定一个 $N \\times N$ 的矩阵，矩阵中的元素仅为 $0$ 或 $1$。你可以交换矩阵中任意两行相邻的行。\n\n你的目标是让矩阵中所有的 $1$ 都位于主对角线之下或在主对角线上。也就是说，对于每个 $X$，$1 \\leq X \\leq N$，第 $X$ 行中不能有 $1$ 出现在第 $X$ 列右侧的位置。\n\n请你返回实现目标所需的最小行交换次数。", "inputFormat": "输入的第一行包含一个整数 $T$，表示测试用例的数量。接下来是 $T$ 组测试数据。\n\n每组测试数据的第一行为一个整数 $N$。接下来的 $N$ 行，每行包含 $N$ 个字符，每个字符为 $0$ 或 $1$。", "outputFormat": "对于每组测试数据，输出一行：\n\nCase #X: K\n\n其中 $X$ 是测试用例编号（从 $1$ 开始），$K$ 是实现目标所需的最小行交换次数。\n\n保证每个测试用例都有解。", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 60$\n\n**小数据集（6 分）**\n\n- $1 \\leq N \\leq 8$\n\n**大数据集（10 分）**\n\n- $1 \\leq N \\leq 40$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13441", "type": "P", "difficulty": 5, "samples": [["3\n2 2 1\n.#\n##\n3 3 1\n...\n###\n###\n3 2 1\n..\n#.\n..", "Case #1: No\nCase #2: Yes 3\nCase #3: No"]], "limits": {"time": [4000, 6000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2009", "Google Code Jam"], "title": "[GCJ 2009 #2] A Digging Problem", "background": "", "description": "The cave is on fire and there is smoke everywhere! You are trying to dig your way to the bottom of the cave where you can breathe. The problem is that there are some air holes inside the cave, and you don't want to fall too much or you will get hurt.\n\nThe cave is represented as an $R \\times C$ matrix with air holes and solid rock cells. You start at position $(1, 1)$, which is in the top-left corner. You can move one cell at a time, left or right, if that cell is empty (an air hole). After moving, if the cell below is empty, you fall down until you hit solid rock or the bottom of the cave. The falling distance must be at most $F$, or you will get hurt. You must reach the bottom of the cave without getting hurt. While falling you cannot move left or right.\n\nYou can also \"dig\", turning a cell that contains solid rock into an air hole. The cell that you dig can be one of two cells: the one to your right and below, or the one to your left and below. The cell above the one you are digging has to be empty. While falling you cannot dig.\n\nYour goal is not only to get to the bottom of the cave, but also to \"dig\" as few cells as possible.\n\nLet's describe the operations with a concrete example:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0gox1vrt.png)\n\n- You start at $(1, 1)$ and move right $3$ times to position $(1, 4)$, just like the picture.\n- You dig the rock at position $(2, 5)$. Cell \"A\" becomes empty.\n- You move right one position and since there is no cell below you fall $3$ cells to position $(4, 5)$. You dig the rock at position $(5, 6)$. Cell \"B\" becomes empty.\n- You move right one position and since there is no cell below you fall $1$ cell to position $(5, 6)$.\n- You have reached the bottom of the cave by digging $2$ cells.", "inputFormat": "The first line of input gives the number of cases, $N$. $N$ test cases follow. The first line of each case is formatted as\n\n$R$ $C$ $F$\n\nwhere $R$ is the number of rows in the cave, $C$ is the number of columns in the cave, and $F$ is the maximum distance you can fall without getting hurt.\n\nThis is followed by $R$, rows each of which contains $C$ characters. Each character can be one of two things:\n\n* \\# for a solid rock\n* . for an air hole\n\nThe top-left cell will always be empty, and the cell below it will be a solid rock.", "outputFormat": "For each test case, output one line in the format\n\nCase #X: No/Yes [D]\n\nwhere $X$ is the case number, starting from $1$. Output \"No\" if you cannot reach the bottom of the cave. Output \"Yes $D$\" if the bottom of the cave can be reached and the minimum number of cells that need digging is $D$.", "hint": "**Limits**\n\n- $1 \\leq N \\leq 50$\n- $1 \\leq F < R$\n\n**Small dataset**\n\n- Time limit: ~~40~~ 4 seconds.\n- $2 \\leq R \\leq 10$\n- $2 \\leq C \\leq 6$\n\n**Large dataset**\n\n- Time limit: ~~60~~ 6 seconds.\n- $2 \\leq R \\leq 50$\n- $2 \\leq C \\leq 50$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #2] A Digging Problem", "background": "", "description": "The cave is on fire and there is smoke everywhere! You are trying to dig your way to the bottom of the cave where you can breathe. The problem is that there are some air holes inside the cave, and you don't want to fall too much or you will get hurt.\n\nThe cave is represented as an $R \\times C$ matrix with air holes and solid rock cells. You start at position $(1, 1)$, which is in the top-left corner. You can move one cell at a time, left or right, if that cell is empty (an air hole). After moving, if the cell below is empty, you fall down until you hit solid rock or the bottom of the cave. The falling distance must be at most $F$, or you will get hurt. You must reach the bottom of the cave without getting hurt. While falling you cannot move left or right.\n\nYou can also \"dig\", turning a cell that contains solid rock into an air hole. The cell that you dig can be one of two cells: the one to your right and below, or the one to your left and below. The cell above the one you are digging has to be empty. While falling you cannot dig.\n\nYour goal is not only to get to the bottom of the cave, but also to \"dig\" as few cells as possible.\n\nLet's describe the operations with a concrete example:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0gox1vrt.png)\n\n- You start at $(1, 1)$ and move right $3$ times to position $(1, 4)$, just like the picture.\n- You dig the rock at position $(2, 5)$. Cell \"A\" becomes empty.\n- You move right one position and since there is no cell below you fall $3$ cells to position $(4, 5)$. You dig the rock at position $(5, 6)$. Cell \"B\" becomes empty.\n- You move right one position and since there is no cell below you fall $1$ cell to position $(5, 6)$.\n- You have reached the bottom of the cave by digging $2$ cells.", "inputFormat": "The first line of input gives the number of cases, $N$. $N$ test cases follow. The first line of each case is formatted as\n\n$R$ $C$ $F$\n\nwhere $R$ is the number of rows in the cave, $C$ is the number of columns in the cave, and $F$ is the maximum distance you can fall without getting hurt.\n\nThis is followed by $R$, rows each of which contains $C$ characters. Each character can be one of two things:\n\n* \\# for a solid rock\n* . for an air hole\n\nThe top-left cell will always be empty, and the cell below it will be a solid rock.", "outputFormat": "For each test case, output one line in the format\n\nCase #X: No/Yes [D]\n\nwhere $X$ is the case number, starting from $1$. Output \"No\" if you cannot reach the bottom of the cave. Output \"Yes $D$\" if the bottom of the cave can be reached and the minimum number of cells that need digging is $D$.", "hint": "**Limits**\n\n- $1 \\leq N \\leq 50$\n- $1 \\leq F < R$\n\n**Small dataset**\n\n- Time limit: ~~40~~ 4 seconds.\n- $2 \\leq R \\leq 10$\n- $2 \\leq C \\leq 6$\n\n**Large dataset**\n\n- Time limit: ~~60~~ 6 seconds.\n- $2 \\leq R \\leq 50$\n- $2 \\leq C \\leq 50$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #2] A Digging Problem", "background": "", "description": "洞穴着火了，到处都是烟雾！你正试图挖掘一条通路，前往洞穴的底部，在那里你才能呼吸。问题在于，洞穴里有一些空气洞（空洞），你又不希望坠落得太深，否则会受伤。\n\n洞穴被表示为一个 $R \\times C$ 的矩阵，由空气洞和坚硬岩石单元格组成。你从位置 $(1, 1)$（即左上角）开始。你可以每次向左或向右移动一个单元格，前提是该单元格是空的（即空气洞）。移动之后，如果你下方的单元格是空气洞，你会一直下落，直到落到坚硬岩石上或洞穴底部为止。下落的距离不能超过 $F$，否则你会受伤。你必须在不受伤的情况下到达洞穴底部。下落过程中你不能左右移动。\n\n你还可以“挖掘”，即将一个坚硬岩石单元格变为空气洞。你可以挖掘的单元格只能是你右下方或左下方的单元格。你挖掘的那个格子的上方必须是空气洞。在下落过程中你不能挖掘。\n\n你的目标不仅是到达洞穴底部，还要尽可能少地进行挖掘。\n\n让我们用一个具体的例子来描述操作过程：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0gox1vrt.png)\n\n- 你从 $(1, 1)$ 开始，向右移动 $3$ 次到达 $(1, 4)$，如图所示。\n- 你挖掘了 $(2, 5)$ 位置的岩石，单元格 “A” 变为空气洞。\n- 你向右移动一格，由于下方没有单元格，你会下落 $3$ 格到 $(4, 5)$。你挖掘 $(5, 6)$ 位置的岩石，单元格 “B” 变为空气洞。\n- 你向右移动一格，由于下方没有单元格，你会下落 $1$ 格到 $(5, 6)$。\n- 你已经通过挖掘 $2$ 个单元格到达了洞穴底部。", "inputFormat": "输入的第一行为一个整数 $N$，表示测试用例数量。接下来有 $N$ 组测试数据。每组测试数据的第一行为：\n\n$R\\ C\\ F$\n\n其中 $R$ 表示洞穴的行数，$C$ 表示洞穴的列数，$F$ 表示你能安全下落的最大距离。\n\n接下来有 $R$ 行，每行含有 $C$ 个字符。每个字符可能为：\n\n- \\# 表示坚硬岩石\n- . 表示空气洞\n\n左上角的单元格一定是空气洞，其下方的单元格一定是坚硬岩石。", "outputFormat": "对于每组测试数据，输出一行，格式如下：\n\nCase #X: No/Yes [D]\n\n其中 $X$ 是测试编号（从 $1$ 开始）。如果你无法到达洞穴底部，输出 “No”；如果可以到达，输出 “Yes $D$”，其中 $D$ 是最少需要挖掘的单元格数。\n", "hint": "**限制条件**\n\n- $1 \\leq N \\leq 50$\n- $1 \\leq F < R$\n\n**小数据集**\n\n- 时间限制：4 秒\n- $2 \\leq R \\leq 10$\n- $2 \\leq C \\leq 6$\n\n**大数据集**\n\n- 时间限制：6 秒\n- $2 \\leq R \\leq 50$\n- $2 \\leq C \\leq 50$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13442", "type": "P", "difficulty": 6, "samples": [["3\n3 4\n1 2 3 4\n2 3 4 6\n6 5 4 3\n3 3\n5 5 5\n4 4 6\n4 5 4\n5 2\n1 1\n2 2\n5 4\n4 4\n4 1", "Case #1: 2\nCase #2: 3\nCase #3: 2"]], "limits": {"time": [2000, 3000], "memory": [1048576, 1048576]}, "tags": ["2009", "网络流", "二分图", "Google Code Jam"], "title": "[GCJ 2009 #2] Stock Charts", "background": "", "description": "You're in the middle of writing your newspaper's end-of-year economics summary, and you've decided that you want to show a number of charts to demonstrate how different stocks have performed over the course of the last year. You've already decided that you want to show the price of $n$ different stocks, all at the same $k$ points of the year.\n\nA simple chart of one stock's price would draw lines between the points $(0, \\text{price}_0)$, $(1, \\text{price}_1)$, ..., $(k-1, \\text{price}_{k-1})$, where $\\text{price}_i$ is the price of the stock at the $i$th point in time.\n\nIn order to save space, you have invented the concept of an overlaid chart. An overlaid chart is the combination of one or more simple charts, and shows the prices of multiple stocks (simply drawing a line for each one). In order to avoid confusion between the stocks shown in a chart, the lines in an overlaid chart may not cross or touch.\n\nGiven a list of $n$ stocks' prices at each of $k$ time points, determine the minimum number of overlaid charts you need to show all of the stocks' prices.", "inputFormat": "The first line of input will contain a single integer $T$, the number of test cases. After this will follow $T$ test cases on different lines, each of the form:\n\n$n$ $k$\n\n$\\text{price}_{0,0}$ $\\text{price}_{0,1}$ ... $\\text{price}_{0,k-1}$\n\n$\\text{price}_{1,0}$ $\\text{price}_{1,1}$ ... $\\text{price}_{1,k-1}$\n\n...\n\n$\\text{price}_{n-1,0}$ $\\text{price}_{n-1,1}$ ... $\\text{price}_{n-1,k-1}$\n\nWhere $\\text{price}_{i,j}$ is an integer, the price of the $i$th stock at time $j$.\n", "outputFormat": "For each test case, a single line containing \"Case #$X$: $Y$\", where $X$ is the number of the test-case (1-indexed) and $Y$ is the minimum number of overlaid charts needed to show the prices of all of the stocks.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$\n- $2 \\leq k \\leq 25$\n- $0 \\leq \\text{price}_{i,j} \\leq 1000000$\n\n**Small Input**\n\n- Time limit: ~~20~~ 2 seconds.\n- $1 \\leq n \\leq 16$\n\n**Large Input**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq n \\leq 100$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #2] Stock Charts", "background": "", "description": "You're in the middle of writing your newspaper's end-of-year economics summary, and you've decided that you want to show a number of charts to demonstrate how different stocks have performed over the course of the last year. You've already decided that you want to show the price of $n$ different stocks, all at the same $k$ points of the year.\n\nA simple chart of one stock's price would draw lines between the points $(0, \\text{price}_0)$, $(1, \\text{price}_1)$, ..., $(k-1, \\text{price}_{k-1})$, where $\\text{price}_i$ is the price of the stock at the $i$th point in time.\n\nIn order to save space, you have invented the concept of an overlaid chart. An overlaid chart is the combination of one or more simple charts, and shows the prices of multiple stocks (simply drawing a line for each one). In order to avoid confusion between the stocks shown in a chart, the lines in an overlaid chart may not cross or touch.\n\nGiven a list of $n$ stocks' prices at each of $k$ time points, determine the minimum number of overlaid charts you need to show all of the stocks' prices.", "inputFormat": "The first line of input will contain a single integer $T$, the number of test cases. After this will follow $T$ test cases on different lines, each of the form:\n\n$n$ $k$\n\n$\\text{price}_{0,0}$ $\\text{price}_{0,1}$ ... $\\text{price}_{0,k-1}$\n\n$\\text{price}_{1,0}$ $\\text{price}_{1,1}$ ... $\\text{price}_{1,k-1}$\n\n...\n\n$\\text{price}_{n-1,0}$ $\\text{price}_{n-1,1}$ ... $\\text{price}_{n-1,k-1}$\n\nWhere $\\text{price}_{i,j}$ is an integer, the price of the $i$th stock at time $j$.\n", "outputFormat": "For each test case, a single line containing \"Case #$X$: $Y$\", where $X$ is the number of the test-case (1-indexed) and $Y$ is the minimum number of overlaid charts needed to show the prices of all of the stocks.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$\n- $2 \\leq k \\leq 25$\n- $0 \\leq \\text{price}_{i,j} \\leq 1000000$\n\n**Small Input**\n\n- Time limit: ~~20~~ 2 seconds.\n- $1 \\leq n \\leq 16$\n\n**Large Input**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq n \\leq 100$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #2] Stock Charts", "background": "", "description": "你正在撰写报社的年度经济总结，目前你决定用几张图表来展示不同股票在过去一年的表现。你已经决定要展示 $n$ 支不同股票在一年中 $k$ 个时刻的价格。\n\n一支股票的简单走势图，就是在平面上连接 $(0, \\text{price}_0)$、$(1, \\text{price}_1)$、……、$(k-1, \\text{price}_{k-1})$ 这些点，其中 $\\text{price}_i$ 表示该股票在第 $i$ 个时刻的价格。\n\n为了节省版面，你发明了“叠加图表”的概念。一个叠加图表是由一条或多条简单走势图组成的，展示多支股票的价格（每支股票画一条线）。为了避免混淆，叠加图表中的不同股票曲线不能相交或相触。\n\n给定 $n$ 支股票在 $k$ 个时刻的价格，请你计算，至少需要多少张叠加图表，才能展示所有股票的价格。\n", "inputFormat": "输入的第一行为一个整数 $T$，表示测试用例数。接下来是 $T$ 组测试数据，每组格式如下：\n\n$n\\ k$\n\n$\\text{price}_{0,0}\\ \\text{price}_{0,1}\\ \\ldots\\ \\text{price}_{0,k-1}$\n\n$\\text{price}_{1,0}\\ \\text{price}_{1,1}\\ \\ldots\\ \\text{price}_{1,k-1}$\n\n……\n\n$\\text{price}_{n-1,0}\\ \\text{price}_{n-1,1}\\ \\ldots\\ \\text{price}_{n-1,k-1}$\n\n其中 $\\text{price}_{i,j}$ 为第 $i$ 支股票在第 $j$ 个时刻的价格。", "outputFormat": "对于每组测试数据，输出一行：\n\nCase #$X$: $Y$\n\n其中 $X$ 是测试用例编号（从 1 开始），$Y$ 是展示所有股票价格所需的最少叠加图表数。", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 100$\n- $2 \\leq k \\leq 25$\n- $0 \\leq \\text{price}_{i,j} \\leq 1000000$\n\n**小数据集**\n\n- 时间限制：2 秒\n- $1 \\leq n \\leq 16$\n\n**大数据集**\n\n- 时间限制：3 秒\n- $1 \\leq n \\leq 100$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13443", "type": "P", "difficulty": 5, "samples": [["2\n3\n20 10 2\n20 20 2\n40 10 3\n3\n20 10 3\n30 10 3\n40 10 3", "Case #1: 7.000000\nCase #2: 8.000000"]], "limits": {"time": [6000, 12000], "memory": [1048576, 1048576]}, "tags": ["数学", "计算几何", "2009", "二分", "Special Judge", "Google Code Jam"], "title": "[GCJ 2009 #2] Watering Plants", "background": "", "description": "In your greenhouse, you have a number of plants which you need to water.\n\nEach of the plants takes up an area which is a circle. No two of the plants overlap or touch each other.\n\nYou are going to buy two sprinklers. Each of the sprinklers will spray everything within a circle of radius $R$ with water.\n\nOne of the sprinklers will run in the morning, and one will run at night. For you to be satisfied that a plant will get enough water, either the whole area of the plant must be watered in the morning, or the whole area of the plant must be watered at night. So each of the circles representing a plant must be completely in one or both of the two circles representing the area the sprinklers can water.\n\nGiven the location and radius of each of the plants, find the minimum radius $R$ so that it is possible to place the two sprinklers to water all the plants. The sprinklers will be installed on the ceiling, so a sprinkler's position can be inside the area of a plant.", "inputFormat": "* One line containing an integer $C$, the number of test cases in the input file.\n\nFor each test case, there will be:\n\n* One line containing $N$, where $N$ is the number of plants you have.\n* $N$ lines, one for each plant, containing three integers \"$X$ $Y$ $R$\", where $(X, Y)$ are the coordinates of the center of the plant, and $R$ is the radius of the plant.\n", "outputFormat": "For each test case:\n\n* One line containing the string \"Case #$x$: $R$\" where $x$ is the number of the test case, starting from 1, and $R$ is the minimum radius of the sprinklers.\n\nAny answer with absolute or relative error of at most $10^{-5}$ will be accepted.", "hint": "**Sample Explanation**\n\nIn the first case, a sprinkler of radius at least 7 centered at $(20,15)$ will water the first two plants. A sprinkler of radius at least 3 will water the plant at $(40,10)$.\n\nIn the second case, one of the two sprinklers will need a radius of at least 8. Note that the plant at $(30,10)$ must be covered entirely by one of the two sprinklers.\n\n**Limits**\n\n- $1 \\leq X \\leq 1000$\n- $1 \\leq Y \\leq 1000$\n- $1 \\leq R \\leq 100$\n\n**Small Input(5 Pts)**\n\n- Time limit: ~~30~~ 6 seconds.\n- $1 \\leq C \\leq 10$\n- $1 \\leq N \\leq 3$\n\n**Large Input(25 Pts)**\n\n- Time limit: ~~60~~ 12 seconds.\n- $1 \\leq C \\leq 30$\n- $1 \\leq N \\leq 40$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #2] Watering Plants", "background": "", "description": "In your greenhouse, you have a number of plants which you need to water.\n\nEach of the plants takes up an area which is a circle. No two of the plants overlap or touch each other.\n\nYou are going to buy two sprinklers. Each of the sprinklers will spray everything within a circle of radius $R$ with water.\n\nOne of the sprinklers will run in the morning, and one will run at night. For you to be satisfied that a plant will get enough water, either the whole area of the plant must be watered in the morning, or the whole area of the plant must be watered at night. So each of the circles representing a plant must be completely in one or both of the two circles representing the area the sprinklers can water.\n\nGiven the location and radius of each of the plants, find the minimum radius $R$ so that it is possible to place the two sprinklers to water all the plants. The sprinklers will be installed on the ceiling, so a sprinkler's position can be inside the area of a plant.", "inputFormat": "* One line containing an integer $C$, the number of test cases in the input file.\n\nFor each test case, there will be:\n\n* One line containing $N$, where $N$ is the number of plants you have.\n* $N$ lines, one for each plant, containing three integers \"$X$ $Y$ $R$\", where $(X, Y)$ are the coordinates of the center of the plant, and $R$ is the radius of the plant.\n", "outputFormat": "For each test case:\n\n* One line containing the string \"Case #$x$: $R$\" where $x$ is the number of the test case, starting from 1, and $R$ is the minimum radius of the sprinklers.\n\nAny answer with absolute or relative error of at most $10^{-5}$ will be accepted.", "hint": "**Sample Explanation**\n\nIn the first case, a sprinkler of radius at least 7 centered at $(20,15)$ will water the first two plants. A sprinkler of radius at least 3 will water the plant at $(40,10)$.\n\nIn the second case, one of the two sprinklers will need a radius of at least 8. Note that the plant at $(30,10)$ must be covered entirely by one of the two sprinklers.\n\n**Limits**\n\n- $1 \\leq X \\leq 1000$\n- $1 \\leq Y \\leq 1000$\n- $1 \\leq R \\leq 100$\n\n**Small Input(5 Pts)**\n\n- Time limit: ~~30~~ 6 seconds.\n- $1 \\leq C \\leq 10$\n- $1 \\leq N \\leq 3$\n\n**Large Input(25 Pts)**\n\n- Time limit: ~~60~~ 12 seconds.\n- $1 \\leq C \\leq 30$\n- $1 \\leq N \\leq 40$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #2] Watering Plants", "background": "", "description": "在你的温室里，有若干株植物需要浇水。\n\n每株植物占据一个圆形区域。任意两株植物不会重叠，也不会相互接触。\n\n你打算购买两台喷洒器。每台喷洒器可以将半径为 $R$ 的圆形区域全部喷洒到水。\n\n其中一台喷洒器将在早晨运行，另一台将在夜晚运行。为了让你满意，必须保证每株植物要么在早晨被完全浇水，要么在夜晚被完全浇水。也就是说，代表每株植物的圆形区域，必须被完全包含在两台喷洒器中的某一台（或两台）喷洒的圆形区域内。\n\n给定每株植物的坐标和半径，请你求出能够放置两台喷洒器、使所有植物都被满足要求地浇水时，喷洒器所需的最小半径 $R$。喷洒器将被安装在天花板上，因此喷洒器的位置可以在植物的圆形区域内部。", "inputFormat": "- 第一行包含一个整数 $C$，表示测试用例的数量。\n\n对于每个测试用例：\n\n- 第一行包含一个整数 $N$，表示植物的数量。\n- 接下来 $N$ 行，每行包含三个整数 \"$X\\ Y\\ R$\"，表示一株植物的圆心坐标为 $(X, Y)$，半径为 $R$。", "outputFormat": "对于每个测试用例：\n\n- 输出一行，格式为 \"Case #$x$: $R$\"，其中 $x$ 是测试用例编号（从 1 开始），$R$ 是所需的最小喷洒器半径。\n\n只要你的答案的绝对误差或相对误差不超过 $10^{-5}$，即可被接受。", "hint": "**样例解释**\n\n在第一个样例中，半径至少为 $7$ 且圆心在 $(20,15)$ 的喷洒器可以覆盖前两株植物。半径至少为 $3$ 的喷洒器可以覆盖位于 $(40,10)$ 的植物。\n\n在第二个样例中，两台喷洒器中至少有一台的半径需要达到 $8$。注意，位于 $(30,10)$ 的植物必须被某一台喷洒器完全覆盖。\n\n**限制条件**\n\n- $1 \\leq X \\leq 1000$\n- $1 \\leq Y \\leq 1000$\n- $1 \\leq R \\leq 100$\n\n**小数据集（5 分）**\n\n- 时间限制：6 秒\n- $1 \\leq C \\leq 10$\n- $1 \\leq N \\leq 3$\n\n**大数据集（25 分）**\n\n- 时间限制：12 秒\n- $1 \\leq C \\leq 30$\n- $1 \\leq N \\leq 40$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13444", "type": "P", "difficulty": 5, "samples": [["4\n5 4\n....\n#..#\n#xx#\n#oo#\n#..#\n7 7\n.######\n.x....#\n.x....#\n..#oo.#\n..#...#\n.######\n.######\n4 10\n##########\n#.x...o..#\n#.x...o..#\n##########\n3 4\n.#x.\n.ow.\n....", "Case #1: 2\nCase #2: 8\nCase #3: 8\nCase #4: 2"]], "limits": {"time": [3000, 5000], "memory": [1048576, 1048576]}, "tags": ["2009", "广度优先搜索 BFS", "Google Code Jam"], "title": "[GCJ 2009 #3] EZ-Sokoban", "background": "", "description": "Sokoban is a famous Japanese puzzle game. Sokoban is Japanese for \"warehouse keeper\". In this game, your goal is to push boxes to their designated locations in the warehouse. To push a box, the area behind the box and in front of the box must be empty. This is because you stand behind the box when pushing and you can push only one box at a time. You cannot push a box out of the board and you cannot stand outside the board when pushing a box.\n\nFor example, in this picture:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/449dtvoj.png)\n\nBox 1 can be pushed in any of the four directions because the four spaces adjacent to it are empty. Box 2 can only be pushed east or west; it cannot be pushed north or south because the space to its south is not empty. Box 3 cannot be pushed in any direction. Box 4 can only be pushed east or west because there is a wall south of it.\nSokoban was proved to be a P-Space complete problem, but we deal with an easier variation here. In our variation of Sokoban, boxes have strong magnets inside and they have to stick together almost all the time. Under \"stable\" conditions, all boxes should be connected, edge to edge. This means that from any box we can get to any other box by going through boxes that share an edge. If you push a box and boxes are no longer connected, you are in \"dangerous mode\". In dangerous mode, the next push must make the boxes connected again.\n\nFor example, in this picture:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sf431enx.png)\n\nThe situation is stable, since all 4 boxes are connected, edge to edge. Let's assume that you decided to push the northmost box west:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5xwhygv7.png)\n\nNow, we are in dangerous mode since the northmost box is not connected to any other boxes. The next push must return us to a stable position. For example, we can push that northmost box south:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x8g8d58g.png)\n\nMaking the boxes stable again.\nA Sokoban puzzle consists of a board, initial configuration of the boxes and the final configuration (where we want the boxes to be at the end). Given an EZ-Sokoban puzzle, find a solution that makes the minimum number of box moves, or decide that it can't be solved. The final and initial configurations will not be in \"dangerous\" mode.\n\nTo simplify things, we will assume that you, the warehouse keeper, can jump at any time to any empty spot on the board.", "inputFormat": "The first line in the input file contains the number of cases, $T$.\n\nEach case consists of several lines. The first line contains $R$ and $C$, the number of rows and columns of the board, separated by one space. This is followed by $R$ lines. Each line contains $C$ characters describing the board:\n\n* '.' is an empty spot\n* '#' is a wall\n* 'x' is a goal (where a box should be at the end)\n* 'o' is a box\n* 'w' is both a box and a goal\n\nThe number of boxes will be equal to the number of goals.", "outputFormat": "For each test case, output\n\nCase #$X$: $K$\n\nwhere $X$ is the test case number, starting from 1, and $K$ is the minimum number of box moves that are needed to solve the puzzle or -1 if it cannot be solved.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 50$\n- $1 \\leqslant R, C \\leqslant 12$\n\n**Small dataset(7 Pts)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leqslant \\text{the number of boxes} \\leqslant 2$\n\n**Large dataset(10 Pts)**\n\n- Time limit: ~~45~~ 5 seconds.\n- $1 \\leqslant \\text{the number of boxes} \\leqslant 5$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #3] EZ-Sokoban", "background": "", "description": "Sokoban is a famous Japanese puzzle game. Sokoban is Japanese for \"warehouse keeper\". In this game, your goal is to push boxes to their designated locations in the warehouse. To push a box, the area behind the box and in front of the box must be empty. This is because you stand behind the box when pushing and you can push only one box at a time. You cannot push a box out of the board and you cannot stand outside the board when pushing a box.\n\nFor example, in this picture:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/449dtvoj.png)\n\nBox 1 can be pushed in any of the four directions because the four spaces adjacent to it are empty. Box 2 can only be pushed east or west; it cannot be pushed north or south because the space to its south is not empty. Box 3 cannot be pushed in any direction. Box 4 can only be pushed east or west because there is a wall south of it.\nSokoban was proved to be a P-Space complete problem, but we deal with an easier variation here. In our variation of Sokoban, boxes have strong magnets inside and they have to stick together almost all the time. Under \"stable\" conditions, all boxes should be connected, edge to edge. This means that from any box we can get to any other box by going through boxes that share an edge. If you push a box and boxes are no longer connected, you are in \"dangerous mode\". In dangerous mode, the next push must make the boxes connected again.\n\nFor example, in this picture:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sf431enx.png)\n\nThe situation is stable, since all 4 boxes are connected, edge to edge. Let's assume that you decided to push the northmost box west:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5xwhygv7.png)\n\nNow, we are in dangerous mode since the northmost box is not connected to any other boxes. The next push must return us to a stable position. For example, we can push that northmost box south:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x8g8d58g.png)\n\nMaking the boxes stable again.\nA Sokoban puzzle consists of a board, initial configuration of the boxes and the final configuration (where we want the boxes to be at the end). Given an EZ-Sokoban puzzle, find a solution that makes the minimum number of box moves, or decide that it can't be solved. The final and initial configurations will not be in \"dangerous\" mode.\n\nTo simplify things, we will assume that you, the warehouse keeper, can jump at any time to any empty spot on the board.", "inputFormat": "The first line in the input file contains the number of cases, $T$.\n\nEach case consists of several lines. The first line contains $R$ and $C$, the number of rows and columns of the board, separated by one space. This is followed by $R$ lines. Each line contains $C$ characters describing the board:\n\n* '.' is an empty spot\n* '#' is a wall\n* 'x' is a goal (where a box should be at the end)\n* 'o' is a box\n* 'w' is both a box and a goal\n\nThe number of boxes will be equal to the number of goals.", "outputFormat": "For each test case, output\n\nCase #$X$: $K$\n\nwhere $X$ is the test case number, starting from 1, and $K$ is the minimum number of box moves that are needed to solve the puzzle or -1 if it cannot be solved.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 50$\n- $1 \\leqslant R, C \\leqslant 12$\n\n**Small dataset(7 Pts)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leqslant \\text{the number of boxes} \\leqslant 2$\n\n**Large dataset(10 Pts)**\n\n- Time limit: ~~45~~ 5 seconds.\n- $1 \\leqslant \\text{the number of boxes} \\leqslant 5$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #3] EZ-Sokoban", "background": "", "description": "Sokoban 是一款著名的日本益智游戏。Sokoban 在日语中意为“仓库管理员”。在这款游戏中，你的目标是将箱子推到仓库中指定的位置。推箱子时，箱子的前后方都必须是空的。这是因为你在推箱子时需要站在箱子的后面，并且每次只能推一个箱子。你不能把箱子推出棋盘，也不能在推箱子时站在棋盘外。\n\n例如，在下图中：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/449dtvoj.png)\n\n箱子 1 可以向任意四个方向推动，因为它四周的格子都是空的。箱子 2 只能向东或向西推动；它不能向北或向南推动，因为其南侧的格子不是空的。箱子 3 不能向任何方向推动。箱子 4 只能向东或向西推动，因为其南侧有一堵墙。\n\nSokoban 已被证明是一个 **P-Space 完全** 问题，但我们这里讨论的是一个更简单的变体。在我们的 EZ-Sokoban 变体中，箱子内部装有强力磁铁，必须几乎始终保持相互连接。在“稳定”状态下，所有箱子都必须边与边相连。也就是说，从任意一个箱子出发，都可以通过依次经过与其相邻的箱子，到达任意其他箱子。如果你推动了一个箱子，导致箱子们不再连通，你就进入了“危险模式”。在危险模式下，下一步推动必须使得所有箱子重新连通。\n\n例如，在下图中：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sf431enx.png)\n\n当前状态是稳定的，因为所有 4 个箱子都通过边相连。假设你决定将最北边的箱子向西推动：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5xwhygv7.png)\n\n现在处于危险模式，因为最北边的箱子与其他箱子不再连通。下一步推动必须让箱子们重新变为连通状态。例如，你可以将最北边的箱子向南推动：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x8g8d58g.png)\n\n这样箱子们又重新连接，回到了稳定状态。\n\n一个 Sokoban 谜题由棋盘、箱子的初始布局以及目标布局（即希望箱子最终达到的位置）组成。给定一个 EZ-Sokoban 谜题，请你求出使箱子移动次数最少的解，或者判断该谜题无解。初始和目标布局都不会处于“危险模式”。\n\n为了简化问题，假设你（仓库管理员）可以随时跳到棋盘上的任意空位。", "inputFormat": "输入文件的第一行包含一个整数 $T$，表示测试用例的数量。\n\n每个测试用例包含若干行。第一行为 $R$ 和 $C$，分别表示棋盘的行数和列数，用一个空格分隔。接下来 $R$ 行，每行包含 $C$ 个字符，描述棋盘：\n\n- '.' 表示空格\n- '#' 表示墙\n- 'x' 表示目标点（箱子最终应在此处）\n- 'o' 表示箱子\n- 'w' 表示箱子和目标点重合\n\n箱子的数量等于目标点的数量。\n", "outputFormat": "对于每个测试用例，输出\n\nCase #$X$: $K$\n\n其中 $X$ 是测试用例编号（从 1 开始），$K$ 是解题所需的最少箱子移动次数。如果无解，则输出 $-1$。\n", "hint": "**限制条件**\n\n- $1 \\leqslant T \\leqslant 50$\n- $1 \\leqslant R, C \\leqslant 12$\n\n**小数据集（7 分）**\n\n- 时间限制：3 秒\n- $1 \\leqslant$ 箱子数量 $\\leqslant 2$\n\n**大数据集（10 分）**\n\n- 时间限制：5 秒\n- $1 \\leqslant$ 箱子数量 $\\leqslant 5$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13445", "type": "P", "difficulty": 6, "samples": [["2\nehw+hwww 5\n6\nwhere\nwhen\nwhat\nwhether\nwho\nwhose\na+e+i+o+u 3\n4\napple\norange\nwatermelon\nbanana", "Case #1: 15 1032 7522 6864 253\nCase #2: 12 96 576"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2009", "Google Code Jam"], "title": "[GCJ 2009 #3] Alphabetomials", "background": "", "description": "As we all know, there is a big difference between polynomials of degree $4$ and those of degree $5$. The question of the non-existence of a closed formula for the roots of general degree $5$ polynomials produced the famous Galois theory, which, as far as the author sees, bears no relation to our problem here.\n\nWe consider only the multi-variable polynomials of degree up to $4$, over $26$ variables, represented by the set of $26$ lowercase English letters. Here is one such polynomial:\n\n$\\text{aber} + \\text{aab} + \\text{c}$\n\nGiven a string $s$, we evaluate the polynomial on it. The evaluation gives $p(S)$ as follows: Each variable is substituted with the number of appearances of that letter in $S$. For example, take the polynomial above, and let $S = \\text{\"abracadabra edgar\"}$. There are six a's, two b's, one c, one e, and three r's. So\n\n$p(S) = 6 \\times 2 \\times 1 \\times 3 + 6 \\times 6 \\times 2 + 1 = 109.$\n\nGiven a dictionary of distinct words that consist of only lower case letters, we call a string $S$ a $d$-phrase if\n\n$S = \"S_1 \\ S_2 \\ S_3 \\ \\ldots \\ S_d\",$\n\nwhere $S_i$ is any word in the dictionary, for $1 \\leqslant i \\leqslant d$. i.e., $S$ is in the form of $d$ dictionary words separated with spaces. Given a number $K \\leqslant 10$, your task is, for each $1 \\leqslant d \\leqslant K$, to compute the sum of $p(S)$ over all the $d$-phrases. Since the answers might be big, you are asked to compute the remainder when the answer is divided by $10009$.", "inputFormat": "The first line contains the number of cases $T$. $T$ test cases follow. The format of each test case is:\n\nA line containing an expression $p$ for the multi-variable polynomial, as described below in this section, then a space, then follows an integer $K$.\n\nA line with an integer $n$, the number of words in the dictionary.\n\nThen $n$ lines, each with a word, consists of only lower case letters. No word will be repeated in the same test case.\n\nWe always write a polynomial in the form of a sum of terms; each term is a product of variables. We write $a^{t}$ simply as $t$ a's concatenated together. For example, $a^{2} b$ is written as $aab$. Variables in each term are always lexicographically non-decreasing.\n", "outputFormat": "For each test case, output a single line in the form\n\nCase #X: $sum_{1}$ $sum _{2}$ $\\ldots$ $sum _{k}$\n\nwhere $X$ is the case number starting from 1, and sum $_{i}$ is the sum of $p(S)$, where $S$ ranges over all $i$-phrases, modulo 10009.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 100$.\n- The string $p$ consists of one or more terms joined by '+'. It will not start nor end with a '+'. There will be at most 5 terms for each $p$. Each term consists at least 1 and at most 4 lower case letters, sorted in non-decreasing order. No two terms in the same polynomial will be the same.\n- Each word is non-empty, consists only of lower case English letters, and will not be longer than 50 characters. No word will be repeated in the same dictionary.\n\n**Small dataset**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leqslant {n} \\leqslant 20$\n- $1 \\leqslant {K} \\leqslant 5$\n\n**Large dataset**\n\n- Time limit: ~~60~~ 6 seconds.\n- $1 \\leqslant {n} \\leqslant 100$\n- $1 \\leqslant {K} \\leqslant 10$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #3] Alphabetomials", "background": "", "description": "As we all know, there is a big difference between polynomials of degree $4$ and those of degree $5$. The question of the non-existence of a closed formula for the roots of general degree $5$ polynomials produced the famous Galois theory, which, as far as the author sees, bears no relation to our problem here.\n\nWe consider only the multi-variable polynomials of degree up to $4$, over $26$ variables, represented by the set of $26$ lowercase English letters. Here is one such polynomial:\n\n$\\text{aber} + \\text{aab} + \\text{c}$\n\nGiven a string $s$, we evaluate the polynomial on it. The evaluation gives $p(S)$ as follows: Each variable is substituted with the number of appearances of that letter in $S$. For example, take the polynomial above, and let $S = \\text{\"abracadabra edgar\"}$. There are six a's, two b's, one c, one e, and three r's. So\n\n$p(S) = 6 \\times 2 \\times 1 \\times 3 + 6 \\times 6 \\times 2 + 1 = 109.$\n\nGiven a dictionary of distinct words that consist of only lower case letters, we call a string $S$ a $d$-phrase if\n\n$S = \"S_1 \\ S_2 \\ S_3 \\ \\ldots \\ S_d\",$\n\nwhere $S_i$ is any word in the dictionary, for $1 \\leqslant i \\leqslant d$. i.e., $S$ is in the form of $d$ dictionary words separated with spaces. Given a number $K \\leqslant 10$, your task is, for each $1 \\leqslant d \\leqslant K$, to compute the sum of $p(S)$ over all the $d$-phrases. Since the answers might be big, you are asked to compute the remainder when the answer is divided by $10009$.", "inputFormat": "The first line contains the number of cases $T$. $T$ test cases follow. The format of each test case is:\n\nA line containing an expression $p$ for the multi-variable polynomial, as described below in this section, then a space, then follows an integer $K$.\n\nA line with an integer $n$, the number of words in the dictionary.\n\nThen $n$ lines, each with a word, consists of only lower case letters. No word will be repeated in the same test case.\n\nWe always write a polynomial in the form of a sum of terms; each term is a product of variables. We write $a^{t}$ simply as $t$ a's concatenated together. For example, $a^{2} b$ is written as $aab$. Variables in each term are always lexicographically non-decreasing.\n", "outputFormat": "For each test case, output a single line in the form\n\nCase #X: $sum_{1}$ $sum _{2}$ $\\ldots$ $sum _{k}$\n\nwhere $X$ is the case number starting from 1, and sum $_{i}$ is the sum of $p(S)$, where $S$ ranges over all $i$-phrases, modulo 10009.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 100$.\n- The string $p$ consists of one or more terms joined by '+'. It will not start nor end with a '+'. There will be at most 5 terms for each $p$. Each term consists at least 1 and at most 4 lower case letters, sorted in non-decreasing order. No two terms in the same polynomial will be the same.\n- Each word is non-empty, consists only of lower case English letters, and will not be longer than 50 characters. No word will be repeated in the same dictionary.\n\n**Small dataset**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leqslant {n} \\leqslant 20$\n- $1 \\leqslant {K} \\leqslant 5$\n\n**Large dataset**\n\n- Time limit: ~~60~~ 6 seconds.\n- $1 \\leqslant {n} \\leqslant 100$\n- $1 \\leqslant {K} \\leqslant 10$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #3] Alphabetomials", "background": "", "description": "众所周知，$4$ 次多项式与 $5$ 次多项式之间有着很大的区别。关于一般 $5$ 次多项式根不存在求根公式的问题，催生了著名的**Galois 理论**，不过据作者所知，这与我们这里的问题并无关系。\n\n我们只考虑至多 $4$ 次的多元多项式，变量为 $26$ 个小写英文字母。例如，下面是一个这样的多项式：\n\n$\\text{aber} + \\text{aab} + \\text{c}$\n\n给定一个字符串 $S$，我们可以用它来计算该多项式的值 $p(S)$，具体方法如下：将每个变量替换为该字母在 $S$ 中出现的次数。例如，对于上述多项式，若 $S = \\text{\"abracadabra edgar\"}$，则其中有 $6$ 个 a，$2$ 个 b，$1$ 个 c，$1$ 个 e，$3$ 个 r。因此，\n\n$$\np(S) = 6 \\times 2 \\times 1 \\times 3 + 6 \\times 6 \\times 2 + 1 = 109。\n$$\n\n给定一个只包含小写字母且各不相同的单词字典，我们称一个字符串 $S$ 为 $d$-短语（$d$-phrase），如果\n\n$$\nS = \"S_1\\ S_2\\ S_3\\ \\ldots\\ S_d\"\n$$\n\n其中 $S_i$ 是字典中的任意单词，$1 \\leqslant i \\leqslant d$。也就是说，$S$ 是由 $d$ 个字典单词用空格隔开拼成的。给定一个 $K \\leqslant 10$，请你对每个 $1 \\leqslant d \\leqslant K$，计算所有 $d$-短语的 $p(S)$ 之和。由于答案可能很大，请输出对 $10009$ 取余后的结果。", "inputFormat": "第一行包含测试用例数量 $T$。接下来是 $T$ 组测试数据。每组测试数据格式如下：\n\n第一行包含一个多元多项式表达式 $p$（格式见下文说明），后接一个空格和整数 $K$。\n\n第二行是整数 $n$，表示字典中单词的数量。\n\n接下来 $n$ 行，每行一个只含小写字母的单词。每个测试用例中不会有重复单词。\n\n多项式总是写成若干项的和，每项是若干变量的乘积。$a^t$ 就写作 $t$ 个 a 连在一起。例如 $a^2b$ 写作 $aab$。每一项中的变量都按字典序非递减排列。\n", "outputFormat": "对于每个测试用例，输出一行，格式如下：\n\nCase #$X$: $sum_1\\ sum_2\\ \\ldots\\ sum_k$\n\n其中 $X$ 是测试编号（从 $1$ 开始），$sum_i$ 表示所有 $i$-短语的 $p(S)$ 之和，对 $10009$ 取余。\n", "hint": "**限制条件**\n\n- $1 \\leqslant T \\leqslant 100$。\n- 字符串 $p$ 由一个或多个项用加号连接，不以加号开头或结尾。每个 $p$ 最多有 $5$ 项。每项至少 $1$ 个、至多 $4$ 个小写字母，且字母按非递减字典序排列。同一多项式内不会有重复项。\n- 每个单词非空，仅含小写英文字母，长度不超过 $50$。同一测试用例中不会有重复单词。\n\n**小数据集**\n\n- 时间限制：3 秒\n- $1 \\leqslant n \\leqslant 20$\n- $1 \\leqslant K \\leqslant 5$\n\n**大数据集**\n\n- 时间限制：6 秒\n- $1 \\leqslant n \\leqslant 100$\n- $1 \\leqslant K \\leqslant 10$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13446", "type": "P", "difficulty": 6, "samples": [["3\n3\n10 10\n8 15\n12 7\n5\n1 1\n2 1\n3 1\n4 1\n5 1\n3\n1 1\n2 2\n3 1", "Case #1: 1\nCase #2: 2\nCase #3: 3"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["图论", "2009", "平面图", "Google Code Jam"], "title": "[GCJ 2009 #3] Football Team", "background": "", "description": "A football team will be standing in rows to have a photograph taken. The location of each player will be given by two integers $x$ and $y$, where $y$ gives the number of the row, and $x$ gives the distance of the player from the left edge of the row. The $x$ values will be all different.\n\nIn order to make the photo more interesting, you're going to make sure players who are near each other have shirts of different colors. To do this, you set the following rule:\n\nFor each player $P$:\n\n- The closest player to the right of $P$ in the same row, if there is such a player, must have a different shirt color.\n- The closest player to the right of $P$ in the previous row, if there is such a player, must have a different shirt color.\n- The closest player to the right of $P$ in the next row, if there is such a player, must have a different shirt color.\n\nMore formally, if there is a player at $(x_1, y_1)$ and $(x_2, y_2)$, where $x_1 < x_2$, then those two players must have different shirt colors if:\n\n- $y_1 - 1 \\leq y_2 \\leq y_1 + 1$, and\n- there is no $x_3$ such that there is a player at $(x_3, y_2)$ and $x_1 < x_3 < x_2$.\n\nFind the minimum number of distinct shirt colors required so that this is possible.", "inputFormat": "The first line of input contains a single integer $T$, the number of test cases. Each test case starts with a line that contains an integer $N$, the number of players, followed by $N$ lines of the form\n\n$x$ $y$\n\neach specifying the position of one player.", "outputFormat": "For each test case, output\n\nCase #X: $c$\n\nwhere $X$ is the test case number, starting from 1, and $c$ is the minimum number of colors required.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 100$\n- $1 \\leqslant x \\leqslant 1000$\n- The values of $x$ will all be different.\n\n**Small dataset(8 Pts)**\n\n- $1 \\leqslant y \\leqslant 15$\n- $1 \\leqslant N \\leqslant 100$\n\n**Large dataset(19 Pts)**\n\n- $1 \\leqslant y \\leqslant 30$\n- $1 \\leqslant N \\leqslant 1000$", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #3] Football Team", "background": "", "description": "A football team will be standing in rows to have a photograph taken. The location of each player will be given by two integers $x$ and $y$, where $y$ gives the number of the row, and $x$ gives the distance of the player from the left edge of the row. The $x$ values will be all different.\n\nIn order to make the photo more interesting, you're going to make sure players who are near each other have shirts of different colors. To do this, you set the following rule:\n\nFor each player $P$:\n\n- The closest player to the right of $P$ in the same row, if there is such a player, must have a different shirt color.\n- The closest player to the right of $P$ in the previous row, if there is such a player, must have a different shirt color.\n- The closest player to the right of $P$ in the next row, if there is such a player, must have a different shirt color.\n\nMore formally, if there is a player at $(x_1, y_1)$ and $(x_2, y_2)$, where $x_1 < x_2$, then those two players must have different shirt colors if:\n\n- $y_1 - 1 \\leq y_2 \\leq y_1 + 1$, and\n- there is no $x_3$ such that there is a player at $(x_3, y_2)$ and $x_1 < x_3 < x_2$.\n\nFind the minimum number of distinct shirt colors required so that this is possible.", "inputFormat": "The first line of input contains a single integer $T$, the number of test cases. Each test case starts with a line that contains an integer $N$, the number of players, followed by $N$ lines of the form\n\n$x$ $y$\n\neach specifying the position of one player.", "outputFormat": "For each test case, output\n\nCase #X: $c$\n\nwhere $X$ is the test case number, starting from 1, and $c$ is the minimum number of colors required.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 100$\n- $1 \\leqslant x \\leqslant 1000$\n- The values of $x$ will all be different.\n\n**Small dataset(8 Pts)**\n\n- $1 \\leqslant y \\leqslant 15$\n- $1 \\leqslant N \\leqslant 100$\n\n**Large dataset(19 Pts)**\n\n- $1 \\leqslant y \\leqslant 30$\n- $1 \\leqslant N \\leqslant 1000$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #3] Football Team", "background": "", "description": "一支足球队将要分排站好拍照。每位球员的位置由两个整数 $x$ 和 $y$ 给出，其中 $y$ 表示排号，$x$ 表示该球员距离本排左边缘的距离。所有球员的 $x$ 值都互不相同。\n\n为了让照片更有趣，你希望相邻的球员穿不同颜色的球衣。为此，你设定了如下规则：\n\n对于每一个球员 $P$：\n\n- 如果 $P$ 这一排中，右侧最近的球员存在，则他们两人的球衣颜色必须不同。\n- 如果 $P$ 的上一排中，右侧最近的球员存在，则他们的球衣颜色必须不同。\n- 如果 $P$ 的下一排中，右侧最近的球员存在，则他们的球衣颜色必须不同。\n\n更正式地说，若存在球员分别在 $(x_1, y_1)$ 和 $(x_2, y_2)$，且 $x_1 < x_2$，那么当满足以下条件时，这两名球员的球衣颜色必须不同：\n\n- $y_1 - 1 \\leq y_2 \\leq y_1 + 1$，并且\n- 不存在 $x_3$ 使得在 $(x_3, y_2)$ 有球员，且 $x_1 < x_3 < x_2$。\n\n请你求出，满足上述要求所需的最少球衣颜色数。", "inputFormat": "输入的第一行包含一个整数 $T$，表示测试用例数量。每组测试用例的第一行为一个整数 $N$，表示球员数量，接下来 $N$ 行，每行两个整数 $x\\ y$，表示一名球员的位置。\n", "outputFormat": "对于每组测试用例，输出\n\nCase #X: $c$\n\n其中 $X$ 是测试用例编号（从 $1$ 开始），$c$ 是所需的最少颜色数。", "hint": "**限制条件**\n\n- $1 \\leqslant T \\leqslant 100$\n- $1 \\leqslant x \\leqslant 1000$\n- 所有 $x$ 值均互不相同。\n\n**小数据集（8 分）**\n\n- $1 \\leqslant y \\leqslant 15$\n- $1 \\leqslant N \\leqslant 100$\n\n**大数据集（19 分）**\n\n- $1 \\leqslant y \\leqslant 30$\n- $1 \\leqslant N \\leqslant 1000$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13447", "type": "P", "difficulty": 6, "samples": [["3\n1 2\n1 7\n12 110", "Case #1: 1\nCase #2: 12\nCase #3: 2466"]], "limits": {"time": [4500, 4500], "memory": [1048576, 1048576]}, "tags": ["数学", "2009", "组合数学", "Google Code Jam"], "title": "[GCJ 2009 #3] Interesting Ranges", "background": "", "description": "A positive integer is a palindrome if its decimal representation (without leading zeros) is a palindromic string (a string that reads the same forwards and backwards). For example, the numbers $5$, $77$, $363$, $4884$, $11111$, $12121$ and $349943$ are palindromes.\n\nA range of integers is interesting if it contains an even number of palindromes. The range $[L, R]$, with $L \\leqslant R$, is defined as the sequence of integers from $L$ to $R$ (inclusive): $(L, L+1, L+2, \\ldots, R-1, R)$. $L$ and $R$ are the range's first and last numbers.\n\nThe range $[L_1, R_1]$ is a subrange of $[L, R]$ if $L \\leqslant L_1 \\leqslant R_1 \\leqslant R$. Your job is to determine how many interesting subranges of $[L, R]$ there are.\n", "inputFormat": "The first line of input gives the number of test cases, $T$. $T$ test cases follow. Each test case is a single line containing two positive integers, $L$ and $R$ (in that order), separated by a space.\n", "outputFormat": "For each test case, output one line. That line should contain \"Case #x: y\", where $x$ is the case number starting with $1$, and $y$ is the number of interesting subranges of $[L, R]$, modulo $1000000007$.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 120$\n\n**Small dataset(9 Pts)**\n\n- $1 \\leqslant L \\leqslant R \\leqslant 10^{13}$\n\n**Large dataset(23 Pts)**\n\n- $1 \\leqslant L \\leqslant R \\leqslant 10^{100}$", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 #3] Interesting Ranges", "background": "", "description": "A positive integer is a palindrome if its decimal representation (without leading zeros) is a palindromic string (a string that reads the same forwards and backwards). For example, the numbers $5$, $77$, $363$, $4884$, $11111$, $12121$ and $349943$ are palindromes.\n\nA range of integers is interesting if it contains an even number of palindromes. The range $[L, R]$, with $L \\leqslant R$, is defined as the sequence of integers from $L$ to $R$ (inclusive): $(L, L+1, L+2, \\ldots, R-1, R)$. $L$ and $R$ are the range's first and last numbers.\n\nThe range $[L_1, R_1]$ is a subrange of $[L, R]$ if $L \\leqslant L_1 \\leqslant R_1 \\leqslant R$. Your job is to determine how many interesting subranges of $[L, R]$ there are.\n", "inputFormat": "The first line of input gives the number of test cases, $T$. $T$ test cases follow. Each test case is a single line containing two positive integers, $L$ and $R$ (in that order), separated by a space.\n", "outputFormat": "For each test case, output one line. That line should contain \"Case #x: y\", where $x$ is the case number starting with $1$, and $y$ is the number of interesting subranges of $[L, R]$, modulo $1000000007$.", "hint": "**Limits**\n\n- $1 \\leqslant T \\leqslant 120$\n\n**Small dataset(9 Pts)**\n\n- $1 \\leqslant L \\leqslant R \\leqslant 10^{13}$\n\n**Large dataset(23 Pts)**\n\n- $1 \\leqslant L \\leqslant R \\leqslant 10^{100}$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 #3] Interesting Ranges", "background": "", "description": "如果一个正整数的十进制表示（不含前导零）是回文字符串（即正着读和反着读都一样），那么这个数就是回文数。例如，$5$、$77$、$363$、$4884$、$11111$、$12121$ 和 $349943$ 都是回文数。\n\n如果一个区间内包含偶数个回文数，则称该区间是**有趣的**。区间 $[L, R]$，其中 $L \\leqslant R$，定义为从 $L$ 到 $R$ 的所有整数组成的序列：$(L, L+1, L+2, \\ldots, R-1, R)$。$L$ 和 $R$ 分别是区间的起点和终点。\n\n如果 $L \\leqslant L_1 \\leqslant R_1 \\leqslant R$，则区间 $[L_1, R_1]$ 是 $[L, R]$ 的一个**子区间**。你的任务是统计 $[L, R]$ 的所有有趣子区间的个数。\n", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据为一行，包含两个正整数 $L$ 和 $R$（按顺序），用空格分隔。\n", "outputFormat": "对于每组测试数据，输出一行，格式如下：\n\nCase #$x$: $y$\n\n其中 $x$ 表示测试编号（从 $1$ 开始），$y$ 表示 $[L, R]$ 中有趣子区间的个数，对 $1000000007$ 取模。\n", "hint": "**限制条件**\n\n- $1 \\leqslant T \\leqslant 120$\n\n**小数据集（9 分）**\n\n- $1 \\leqslant L \\leqslant R \\leqslant 10^{13}$\n\n**大数据集（23 分）**\n\n- $1 \\leqslant L \\leqslant R \\leqslant 10^{100}$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13448", "type": "P", "difficulty": 5, "samples": [["2\n1 1\n2 2\n4 2\n3 2 4\n2 3", "Case #1: 1+0/1\nCase #2: 5+1/8"]], "limits": {"time": [6000, 6000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2009", "期望", "Google Code Jam"], "title": "[GCJ 2009 Finals] Year of More Code Jam", "background": "", "description": "A new year brings a new calendar, new challenges, and a lot of new fun in life. Some things, however, never change. There are still many great programming contests to be held, and our heroine Sphinny's passion for them remains unchanged.\n\nThere are several tournaments Sphinny is interested in. Each tournament will consist of a number of rounds. The organizer of each tournament has not decided on what date the tournament will start, but has decided how many rounds there will be in the tournament and how many days after the start date each round will be.\n\nIn some situations, two or more rounds (from different tournaments) can be scheduled on the same day. As Sphinny is so keen on problem solving, she will be happier if more rounds are scheduled on the same day. Her happiness value is computed as follows: for each day on which there are $S$ rounds, her happiness will be increased by $S^2$. Her happiness starts at $0$ (don't worry — $0$ is a happy place to start).\n\nIn the picture below there are three tournaments, each represented by a different color, and Sphinny's total happiness is $20$. One tournament starts on the second day of the year, one starts on the fifth day of the year, and one starts on the sixth day of the year.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qyyc8jir.png)\n\nThere are $N$ days in the year. Each tournament will begin on any of the $N$ days with equal probability. The big question for this year is what the expected value of Sphinny's happiness is.\n\nAs a perfectionist, she is not going to solve the problem approximately. Instead, she wants to know the result exactly. The number of tournaments is $T$, and there are $N^T$ equally likely ways to select the start dates of the tournaments. She is going to express her expected happiness as $K + A/B$, where $K$ and $B$ are positive integers and $A$ is a non-negative integer less than $B$. If $A$ is zero then $B$ must be one, otherwise $A$ and $B$ must not have a common factor greater than one.\n\nIf a tournament starts late enough in the year, some of its rounds might be scheduled during the next year. Those rounds do not contribute to Sphinny's happiness this year.", "inputFormat": "The first line of the input is a single integer $C$, the number of test cases. $C$ tests follow. The first line of each test case is in the form\n\n$N \\ T$\n\nwhere $N$ is the number of days in the year, and $T$ is the number of tournaments. $T$ lines then follow, one for each tournament, in the format\n\n$m \\ d_2 \\ d_3 \\ \\ldots \\ d_m$\n\nindicating that there are $m$ rounds, and the $i$-th round will be held on day $d_i$ of the tournament. The first round of a tournament is held on day $1$ ($d_1 = 1$).\n", "outputFormat": "For each test, output one line of the form\n\nCase #$X$: $K+A/B$\n\nwhere $X$ is the case number, starting from $1$, and $K$, $A$ and $B$ are as described above.", "hint": "**Limits**\n\n- $1 \\leq C \\leq 50$\n- $1 \\leq N \\leq 10^{9}$\n- $2 \\leq m \\leq 50$\n- $1 < d_2 < d_3 < \\ldots < d_m \\leq 10000$\n\n**Small dataset(5 Pts)**\n\n- $1 \\leq T \\leq 2$\n\n**Large dataset(12 Pts)**\n\n- $1 \\leq T \\leq 50$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 Finals] Year of More Code Jam", "background": "", "description": "A new year brings a new calendar, new challenges, and a lot of new fun in life. Some things, however, never change. There are still many great programming contests to be held, and our heroine Sphinny's passion for them remains unchanged.\n\nThere are several tournaments Sphinny is interested in. Each tournament will consist of a number of rounds. The organizer of each tournament has not decided on what date the tournament will start, but has decided how many rounds there will be in the tournament and how many days after the start date each round will be.\n\nIn some situations, two or more rounds (from different tournaments) can be scheduled on the same day. As Sphinny is so keen on problem solving, she will be happier if more rounds are scheduled on the same day. Her happiness value is computed as follows: for each day on which there are $S$ rounds, her happiness will be increased by $S^2$. Her happiness starts at $0$ (don't worry — $0$ is a happy place to start).\n\nIn the picture below there are three tournaments, each represented by a different color, and Sphinny's total happiness is $20$. One tournament starts on the second day of the year, one starts on the fifth day of the year, and one starts on the sixth day of the year.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qyyc8jir.png)\n\nThere are $N$ days in the year. Each tournament will begin on any of the $N$ days with equal probability. The big question for this year is what the expected value of Sphinny's happiness is.\n\nAs a perfectionist, she is not going to solve the problem approximately. Instead, she wants to know the result exactly. The number of tournaments is $T$, and there are $N^T$ equally likely ways to select the start dates of the tournaments. She is going to express her expected happiness as $K + A/B$, where $K$ and $B$ are positive integers and $A$ is a non-negative integer less than $B$. If $A$ is zero then $B$ must be one, otherwise $A$ and $B$ must not have a common factor greater than one.\n\nIf a tournament starts late enough in the year, some of its rounds might be scheduled during the next year. Those rounds do not contribute to Sphinny's happiness this year.", "inputFormat": "The first line of the input is a single integer $C$, the number of test cases. $C$ tests follow. The first line of each test case is in the form\n\n$N \\ T$\n\nwhere $N$ is the number of days in the year, and $T$ is the number of tournaments. $T$ lines then follow, one for each tournament, in the format\n\n$m \\ d_2 \\ d_3 \\ \\ldots \\ d_m$\n\nindicating that there are $m$ rounds, and the $i$-th round will be held on day $d_i$ of the tournament. The first round of a tournament is held on day $1$ ($d_1 = 1$).\n", "outputFormat": "For each test, output one line of the form\n\nCase #$X$: $K+A/B$\n\nwhere $X$ is the case number, starting from $1$, and $K$, $A$ and $B$ are as described above.", "hint": "**Limits**\n\n- $1 \\leq C \\leq 50$\n- $1 \\leq N \\leq 10^{9}$\n- $2 \\leq m \\leq 50$\n- $1 < d_2 < d_3 < \\ldots < d_m \\leq 10000$\n\n**Small dataset(5 Pts)**\n\n- $1 \\leq T \\leq 2$\n\n**Large dataset(12 Pts)**\n\n- $1 \\leq T \\leq 50$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 Finals] Year of More Code Jam", "background": "", "description": "新的一年带来了新的日历、新的挑战，以及生活中更多的乐趣。然而，有些事情永远不会改变。精彩的编程比赛依旧层出不穷，而我们的主角 Sphinny 对这些比赛的热情始终如一。\n\nSphinny 对若干项锦标赛感兴趣。每项锦标赛都包含若干轮。每项锦标赛的主办方尚未确定比赛的开始日期，但已经决定了该锦标赛将包含多少轮，以及每一轮距离比赛开始日的天数。\n\n在某些情况下，不同锦标赛的若干轮可能会安排在同一天举行。由于 Sphinny 非常热爱解题，如果同一天有更多的轮次举行，她会更加开心。她的幸福值计算方式如下：对于每一天，若当天有 $S$ 轮比赛，则她的幸福值增加 $S^2$。她的初始幸福值为 $0$（别担心——$0$ 也是个很幸福的起点）。\n\n下图展示了三项锦标赛，每种颜色代表一项锦标赛，Sphinny 的总幸福值为 $20$。有一项锦标赛在当年的第 $2$ 天开始，一项在第 $5$ 天开始，一项在第 $6$ 天开始。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qyyc8jir.png)\n\n一年共有 $N$ 天。每项锦标赛都可以等概率地在这 $N$ 天中的任意一天开始。今年的大问题是：Sphinny 的期望幸福值是多少？\n\n作为一个完美主义者，她不会只求近似解，而是想要精确的答案。锦标赛的数量为 $T$，因此一共有 $N^T$ 种等可能的锦标赛开始日期的组合。她希望将期望幸福值写成 $K+A/B$ 的形式，其中 $K$ 和 $B$ 为正整数，$A$ 为非负整数且 $A < B$。如果 $A$ 为零，则 $B$ 必须为 $1$；否则 $A$ 和 $B$ 不能有大于 $1$ 的公因数。\n\n如果某项锦标赛开始得太晚，导致其某些轮次安排在下一年，则这些轮次不会对 Sphinny 当年的幸福值产生任何贡献。\n", "inputFormat": "输入的第一行为一个整数 $C$，表示测试用例数量。接下来有 $C$ 组测试数据。每组测试数据的第一行为\n\n$N\\ T$\n\n其中 $N$ 表示一年中的天数，$T$ 表示锦标赛数量。接下来有 $T$ 行，每行描述一项锦标赛，格式如下：\n\n$m\\ d_2\\ d_3\\ \\ldots\\ d_m$\n\n表示该锦标赛共有 $m$ 轮，第 $i$ 轮将在该锦标赛开始后的第 $d_i$ 天举行。每项锦标赛的第一轮总是在第 $1$ 天举行（即 $d_1=1$）。\n", "outputFormat": "对于每组测试数据，输出一行，格式如下：\n\nCase #$X$: $K+A/B$\n\n其中 $X$ 为测试编号（从 $1$ 开始），$K$、$A$、$B$ 的含义如上所述。\n", "hint": "**限制条件**\n\n- $1 \\leq C \\leq 50$\n- $1 \\leq N \\leq 10^{9}$\n- $2 \\leq m \\leq 50$\n- $1 < d_2 < d_3 < \\ldots < d_m \\leq 10000$\n\n**小数据集（5 分）**\n\n- $1 \\leq T \\leq 2$\n\n**大数据集（12 分）**\n\n- $1 \\leq T \\leq 50$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13449", "type": "P", "difficulty": 6, "samples": [["1\n10\n0 0\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n8 8\n9 9", "Case #1: 5.656854"]], "limits": {"time": [15000, 30000], "memory": [1048576, 1048576]}, "tags": ["计算几何", "2009", "递归", "Special Judge", "分治", "排序", "Google Code Jam"], "title": "[GCJ 2009 Finals] Min Perimeter", "background": "", "description": "You will be given a set of points with integer coordinates. You are asked to compute the smallest perimeter of a triangle with distinct vertexes from this set of points.", "inputFormat": "The first line of the input data gives you the number of cases, $T$. $T$ test cases follow. Each test case contains on the first line the integer $n$, the number of points in the set. $n$ lines follow, each line containing two integer numbers $x_i$, $y_i$. These are the coordinates of the $i$-th point. There may not be more than one point at the same coordinates.\n", "outputFormat": "For each test case, output:\n\nCase #X: Y\n\nwhere $X$ is the number of the test case and $Y$ is the minimum perimeter. Answers with a relative or absolute error of at most $10^{-5}$ will be considered correct. Degenerate triangles — triangles with zero area — are ok.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 15$\n- $0 \\leq x_i, y_i \\leq 10^9$\n\n**Small dataset(5 Pts)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $3 \\leq n \\leq 10000$\n\n**Large dataset(15 Pts)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $3 \\leq n \\leq 1000000$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 Finals] Min Perimeter", "background": "", "description": "You will be given a set of points with integer coordinates. You are asked to compute the smallest perimeter of a triangle with distinct vertexes from this set of points.", "inputFormat": "The first line of the input data gives you the number of cases, $T$. $T$ test cases follow. Each test case contains on the first line the integer $n$, the number of points in the set. $n$ lines follow, each line containing two integer numbers $x_i$, $y_i$. These are the coordinates of the $i$-th point. There may not be more than one point at the same coordinates.\n", "outputFormat": "For each test case, output:\n\nCase #X: Y\n\nwhere $X$ is the number of the test case and $Y$ is the minimum perimeter. Answers with a relative or absolute error of at most $10^{-5}$ will be considered correct. Degenerate triangles — triangles with zero area — are ok.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 15$\n- $0 \\leq x_i, y_i \\leq 10^9$\n\n**Small dataset(5 Pts)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $3 \\leq n \\leq 10000$\n\n**Large dataset(15 Pts)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $3 \\leq n \\leq 1000000$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 Finals] Min Perimeter", "background": "", "description": "你将得到一组整数坐标的点集。你的任务是计算，从这些点中选取三个互不相同的点作为顶点，能够构成的三角形的最小周长。\n", "inputFormat": "输入的第一行为一个整数 $T$，表示测试用例的数量。接下来有 $T$ 组测试数据。每组测试数据的第一行为一个整数 $n$，表示点的数量。接下来的 $n$ 行，每行包含两个整数 $x_i$、$y_i$，表示第 $i$ 个点的坐标。不会有两个点的坐标完全相同。\n", "outputFormat": "对于每组测试数据，输出一行：\n\nCase #$X$: $Y$\n\n其中 $X$ 是测试用例编号，$Y$ 是最小周长。只要你的答案的绝对误差或相对误差不超过 $10^{-5}$，就会被认为是正确答案。退化三角形（即面积为零的三角形）也是允许的。\n", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 15$\n- $0 \\leq x_i, y_i \\leq 10^9$\n\n**小数据集（5 分）**\n\n- 时间限制：15 秒\n- $3 \\leq n \\leq 10000$\n\n**大数据集（15 分）**\n\n- 时间限制：30 秒\n- $3 \\leq n \\leq 1000000$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13450", "type": "P", "difficulty": 6, "samples": [["3\n2 2\nad\nc.\n3 3\n.a.\na.z\n.z.\n4 4\n....\n.g..\n.cj.\n....", "Case #1: 23\nCase #2: 7569\nCase #3: 0"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2009", "容斥原理", "状压 DP", "Google Code Jam"], "title": "[GCJ 2009 Finals] Doubly-sorted Grid", "background": "", "description": "A rectangular grid with lower case English letters in each cell is called doubly sorted if in each row the letters are non-decreasing from the left to the right, and in each column the letters are non-decreasing from the top to the bottom. In the following examples, the first two grids are doubly sorted, while the other two are not:\n\n```\nabc    ace    aceg    base\ndef    ade    cdef    base\nghi    bdg    xxyy    base\n```\n\nYou are given a partially-filled grid, where some of the cells are filled with letters. Your task is to compute the number of ways you can fill the rest of the cells so that the resulting grid is doubly sorted. The answer might be a big number; you need to output the number of ways modulo $10007$.", "inputFormat": "The first line of input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line containing two integers $R$ and $C$, the number of rows and the number of columns respectively. This is followed by $R$ lines, each containing a string of length $C$, giving the partially-filled grid. Each character in the grid is either a lower-case English letter, or '.', indicating that the cell is not filled yet.\n", "outputFormat": "For each test case, output one line. That line should contain \"Case #$X$: $y$\", where $X$ is the case number starting with 1, and $y$ is the number of possible doubly-sorted grids, modulo $10007$.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 40$\n- Each character in the partially-filled grid is either '.' or a lower-case English letter.\n\n**Small dataset(10 Pts)**\n\n- Time limit: ~~60~~ 5 seconds.\n- $1 \\leq R, C \\leq 4$\n\n**Large dataset(20 Pts)**\n\n- Time limit: ~~120~~ 10 seconds.\n- $1 \\leq R, C \\leq 10$", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 Finals] Doubly-sorted Grid", "background": "", "description": "A rectangular grid with lower case English letters in each cell is called doubly sorted if in each row the letters are non-decreasing from the left to the right, and in each column the letters are non-decreasing from the top to the bottom. In the following examples, the first two grids are doubly sorted, while the other two are not:\n\n```\nabc    ace    aceg    base\ndef    ade    cdef    base\nghi    bdg    xxyy    base\n```\n\nYou are given a partially-filled grid, where some of the cells are filled with letters. Your task is to compute the number of ways you can fill the rest of the cells so that the resulting grid is doubly sorted. The answer might be a big number; you need to output the number of ways modulo $10007$.", "inputFormat": "The first line of input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line containing two integers $R$ and $C$, the number of rows and the number of columns respectively. This is followed by $R$ lines, each containing a string of length $C$, giving the partially-filled grid. Each character in the grid is either a lower-case English letter, or '.', indicating that the cell is not filled yet.\n", "outputFormat": "For each test case, output one line. That line should contain \"Case #$X$: $y$\", where $X$ is the case number starting with 1, and $y$ is the number of possible doubly-sorted grids, modulo $10007$.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 40$\n- Each character in the partially-filled grid is either '.' or a lower-case English letter.\n\n**Small dataset(10 Pts)**\n\n- Time limit: ~~60~~ 5 seconds.\n- $1 \\leq R, C \\leq 4$\n\n**Large dataset(20 Pts)**\n\n- Time limit: ~~120~~ 10 seconds.\n- $1 \\leq R, C \\leq 10$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 Finals] Doubly-sorted Grid", "background": "", "description": "如果一个矩形网格的每一行中的字母都从左到右非递减，并且每一列中的字母都从上到下非递减，则称该网格是**双重有序**（doubly sorted）的。下面的例子中，前两个网格是双重有序的，而后两个不是：\n\n```\nabc ace aceg base\ndef ade cdef base\nghi bdg xxyy base\n```\n\n现在给你一个部分填充的网格，其中有些格子已经填入了字母。你的任务是计算有多少种方式可以填充剩余的格子，使得最终得到的网格是双重有序的。答案可能很大，请输出方案数对 $10007$ 取模后的结果。\n", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为两个整数 $R$ 和 $C$，分别表示网格的行数和列数。接下来 $R$ 行，每行一个长度为 $C$ 的字符串，表示部分填充的网格。网格中的每个字符要么是小写英文字母，要么是 '.'（表示该格未填）。\n", "outputFormat": "对于每组测试数据，输出一行，格式如下：\n\nCase #$X$: $y$\n\n其中 $X$ 是测试编号（从 $1$ 开始），$y$ 是方案数对 $10007$ 取模的结果。", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 40$\n- 部分填充的网格中每个字符要么是 '.'，要么是小写英文字母。\n\n**小数据集（10 分）**\n\n- 时间限制：5 秒\n- $1 \\leq R, C \\leq 4$\n\n**大数据集（20 分）**\n\n- 时间限制：10 秒\n- $1 \\leq R, C \\leq 10$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13451", "type": "P", "difficulty": 6, "samples": [["1\n5\n0 1 7 10\n0 -1 7 10\n5 0 1 -15\n10 0 6 10\n15 1 2 -20", "Case #1: 5"]], "limits": {"time": [6000, 6000], "memory": [1048576, 1048576]}, "tags": ["2009", "网络流", "最小割", "Google Code Jam"], "title": "[GCJ 2009 Finals] Wi-fi Towers", "background": "", "description": "You are given a network of wireless towers. Each tower has a range and can send data to neighboring towers as long as the distance is less than or equal to the sending tower's range.\n\nThe towers are using an old communication protocol $A$, but there is a new, better protocol $B$ available. We are thinking about upgrading some towers to send data using protocol $B$ to achieve better bandwidth.\n\nThere is one important restriction: if a tower $T$ is using the new protocol $B$, every tower within $T$'s range must also be running protocol $B$, so that they can understand the data sent from $T$. The reverse is not necessary — towers running the new protocol $B$ can be sent data from towers using the old protocol $A$.\n\nYour task is to select the best set of towers to upgrade from protocol $A$ to protocol $B$. There is some benefit to upgrading a tower, but there are also installation costs. So each tower will have a score, which can be positive or negative, which is the value of upgrading the tower. Choose the set of towers to upgrade in such a way that the total score of the upgraded towers is maximized.", "inputFormat": "The first line contains the number of test cases, $T$. Each test case starts with the number of towers, $n$. The following $n$ lines each contain 4 integers: $x$, $y$, $r$, $s$. They describe a tower at coordinates $x$, $y$ having a range of $r$ and a score (value of updating to the new protocol) of $s$.\n", "outputFormat": "For each test case, output:\n\nCase #$X$: score\n\nwhere $X$ is the test case number, starting from 1, and score is the total score for the best choice of towers.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 55$\n- $-10000 \\leq x, y \\leq 10000$\n- $1 \\leq r \\leq 20000$\n- $-1000 \\leq s \\leq 1000$\n- No two towers will have the same coordinates.\n\n**Small dataset(3 Pts)**\n\n- $1 \\leq n \\leq 15$\n\n**Large dataset(25 Pts)**\n\n- $1 \\leq n \\leq 500$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 Finals] Wi-fi Towers", "background": "", "description": "You are given a network of wireless towers. Each tower has a range and can send data to neighboring towers as long as the distance is less than or equal to the sending tower's range.\n\nThe towers are using an old communication protocol $A$, but there is a new, better protocol $B$ available. We are thinking about upgrading some towers to send data using protocol $B$ to achieve better bandwidth.\n\nThere is one important restriction: if a tower $T$ is using the new protocol $B$, every tower within $T$'s range must also be running protocol $B$, so that they can understand the data sent from $T$. The reverse is not necessary — towers running the new protocol $B$ can be sent data from towers using the old protocol $A$.\n\nYour task is to select the best set of towers to upgrade from protocol $A$ to protocol $B$. There is some benefit to upgrading a tower, but there are also installation costs. So each tower will have a score, which can be positive or negative, which is the value of upgrading the tower. Choose the set of towers to upgrade in such a way that the total score of the upgraded towers is maximized.", "inputFormat": "The first line contains the number of test cases, $T$. Each test case starts with the number of towers, $n$. The following $n$ lines each contain 4 integers: $x$, $y$, $r$, $s$. They describe a tower at coordinates $x$, $y$ having a range of $r$ and a score (value of updating to the new protocol) of $s$.\n", "outputFormat": "For each test case, output:\n\nCase #$X$: score\n\nwhere $X$ is the test case number, starting from 1, and score is the total score for the best choice of towers.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 55$\n- $-10000 \\leq x, y \\leq 10000$\n- $1 \\leq r \\leq 20000$\n- $-1000 \\leq s \\leq 1000$\n- No two towers will have the same coordinates.\n\n**Small dataset(3 Pts)**\n\n- $1 \\leq n \\leq 15$\n\n**Large dataset(25 Pts)**\n\n- $1 \\leq n \\leq 500$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 Finals] Wi-fi Towers", "background": "", "description": "你将得到一个由无线信号塔组成的网络。每个信号塔都有一定的覆盖半径，并且只要相邻信号塔之间的距离不超过发送塔的覆盖半径，就可以向其发送数据。\n\n这些信号塔目前使用的是旧的通信协议 $A$，但现在有一种更新、更好的协议 $B$ 可供升级。我们正在考虑将部分信号塔升级为协议 $B$，以获得更好的带宽。\n\n但有一个重要的限制：如果某个信号塔 $T$ 升级为新协议 $B$，那么在 $T$ 覆盖范围内的所有信号塔也必须升级为协议 $B$，以便它们能够理解 $T$ 发送的数据。反过来则不要求——使用新协议 $B$ 的信号塔可以接收来自旧协议 $A$ 的信号。\n\n你的任务是选择一组信号塔进行升级，使得升级后信号塔的总得分最大。每个信号塔升级的价值（即得分）可能为正也可能为负。你需要选择升级哪些信号塔，使得升级塔的总得分最大。", "inputFormat": "第一行为测试用例数 $T$。每组测试数据首先给出一个整数 $n$，表示信号塔的数量。接下来的 $n$ 行，每行包含 $4$ 个整数：$x$、$y$、$r$、$s$，分别表示信号塔的坐标 $(x, y)$，覆盖半径 $r$，以及升级该塔的得分 $s$。\n", "outputFormat": "对于每组测试数据，输出：\n\nCase #$X$: score\n\n其中 $X$ 是测试编号（从 $1$ 开始），score 是你所能获得的最大总得分。", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 55$\n- $-10000 \\leq x, y \\leq 10000$\n- $1 \\leq r \\leq 20000$\n- $-1000 \\leq s \\leq 1000$\n- 不会有两个信号塔的坐标完全相同。\n\n**小数据集（3 分）**\n\n- $1 \\leq n \\leq 15$\n\n**大数据集（25 分）**\n\n- $1 \\leq n \\leq 500$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13452", "type": "P", "difficulty": 6, "samples": [["4\n3\nred red blue yellow blue yellow\n3\nred blue yellow red blue yellow\n3\nred blue yellow blue yellow red\n3\nred red blue blue yellow yellow", "Case #1: 2\nCase #2: -1\nCase #3: 3\nCase #4: 1"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2009", "Google Code Jam"], "title": "[GCJ 2009 Finals] Marbles", "background": "", "description": "You have $2n$ marbles on a square grid. The marbles are colored in $n$ different colors such that there are exactly $2$ marbles of each color. The marbles are placed at the coordinates $(1,0)$, $(2,0)$, ..., $(2n, 0)$.\n\nYour task is to draw a path for each color that joins the two marbles of that color. Each path should be composed of vertical or horizontal line segments between grid points. No two paths can intersect or touch each other. No path may cross the $y=0$ line. Each path can only touch the $y=0$ line at the position of the two marbles it is connecting, so the first and last line segment of each path must be vertical.\n\nGiven an arrangement of marbles, return the minimum height of a solution, or return -1 if no solution exists. The height is defined as the difference between the highest and lowest Y-coordinates of the paths used.\n\nAn example:\n\n```\nred red blue yellow blue yellow\n```\n\nOne solution would be:\n\n```\n +---+    +-----------+\n |   |    |           |\nred red blue yellow blue yellow\n                 |           |\n                 +-----------+\n```\n\nThe minimum height is $2$ in this case.", "inputFormat": "The first line of input gives the number of cases, $T$. $T$ test cases follow. The first line of each case contains $n$, the number of different colors for the marbles. The next line contains a string of $2n$ words separated by spaces which correspond to the colors of the marbles, in order from left to right. Each color is a string of lower case letters ('a' .. 'z') no longer than 10 characters. There will be exactly $n$ different colors and each color will appear exactly twice.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: \", where $x$ is the case number (starting from 1), followed by the height of any optimal solution, or -1 if no solution exists.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50.$\n\n**Small dataset(7 Pts)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq n \\leq 20.$\n\n**Large dataset(32 Pts)**\n\n- Time limit: ~~60~~ 6 seconds.\n- $1 \\leq n \\leq 500.$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 Finals] Marbles", "background": "", "description": "You have $2n$ marbles on a square grid. The marbles are colored in $n$ different colors such that there are exactly $2$ marbles of each color. The marbles are placed at the coordinates $(1,0)$, $(2,0)$, ..., $(2n, 0)$.\n\nYour task is to draw a path for each color that joins the two marbles of that color. Each path should be composed of vertical or horizontal line segments between grid points. No two paths can intersect or touch each other. No path may cross the $y=0$ line. Each path can only touch the $y=0$ line at the position of the two marbles it is connecting, so the first and last line segment of each path must be vertical.\n\nGiven an arrangement of marbles, return the minimum height of a solution, or return -1 if no solution exists. The height is defined as the difference between the highest and lowest Y-coordinates of the paths used.\n\nAn example:\n\n```\nred red blue yellow blue yellow\n```\n\nOne solution would be:\n\n```\n +---+    +-----------+\n |   |    |           |\nred red blue yellow blue yellow\n                 |           |\n                 +-----------+\n```\n\nThe minimum height is $2$ in this case.", "inputFormat": "The first line of input gives the number of cases, $T$. $T$ test cases follow. The first line of each case contains $n$, the number of different colors for the marbles. The next line contains a string of $2n$ words separated by spaces which correspond to the colors of the marbles, in order from left to right. Each color is a string of lower case letters ('a' .. 'z') no longer than 10 characters. There will be exactly $n$ different colors and each color will appear exactly twice.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: \", where $x$ is the case number (starting from 1), followed by the height of any optimal solution, or -1 if no solution exists.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50.$\n\n**Small dataset(7 Pts)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq n \\leq 20.$\n\n**Large dataset(32 Pts)**\n\n- Time limit: ~~60~~ 6 seconds.\n- $1 \\leq n \\leq 500.$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 Finals] Marbles", "background": "", "description": "在一个方格坐标系上，你有 $2n$ 个弹珠。这些弹珠被涂成 $n$ 种不同的颜色，每种颜色恰好有 $2$ 个弹珠。所有弹珠被依次放在坐标 $(1,0)$、$(2,0)$、$\\ldots$、$(2n, 0)$ 上。\n\n你的任务是为每种颜色画一条路径，将该颜色的两个弹珠连接起来。每条路径应由若干条垂直或水平的线段组成，且这些线段必须连接在网格点上。任意两条路径不能相交或相触。任意一条路径都不能穿过 $y=0$ 这条直线。每条路径只能在它所连接的两个弹珠的位置与 $y=0$ 相接，因此每条路径的首尾线段必须是竖直的。\n\n给定弹珠的排列方式，返回一个解方案的最小高度，如果不存在合法解，则返回 $-1$。高度定义为所有路径所经过的最大 $Y$ 坐标与最小 $Y$ 坐标之差。\n\n例如：\n\n```\nred red blue yellow blue yellow\n```\n\n一种可行的解法如下：\n\n```\n +---+    +-----------+\n |   |    |           |\nred red blue yellow blue yellow\n                 |           |\n                 +-----------+\n```\n\n在这个例子中，最小高度为 $2$。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组的第一行为 $n$，表示弹珠颜色种类数。下一行为 $2n$ 个用空格分隔的单词，按从左到右顺序分别表示每个弹珠的颜色。每个颜色由小写字母（'a' 到 'z'）组成，长度不超过 $10$ 个字符。每种颜色恰好出现两次。\n", "outputFormat": "对于每组测试数据，输出一行，格式如下：\n\nCase #$x$: \n\n其中 $x$ 是测试编号（从 $1$ 开始），后接一个最优解的最小高度。如果不存在合法解，输出 $-1$。", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 50.$\n\n**小数据集（7 分）**\n\n- 时间限制：3 秒\n- $1 \\leq n \\leq 20.$\n\n**大数据集（32 分）**\n\n- 时间限制：6 秒\n- $1 \\leq n \\leq 500.$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13453", "type": "P", "difficulty": 7, "samples": [["1\n5 50\n95 50\n1\n50 50 10", "Case #1:\n0.7656121\n1437.986\n1437.986\n6809.104"]], "limits": {"time": [5000, 30000], "memory": [1048576, 1048576]}, "tags": ["计算几何", "2009", "Special Judge", "Google Code Jam"], "title": "[GCJ 2009 Finals] Lights", "background": "", "description": "In a big, square room there are two point light sources: one is red and the other is green. There are also $n$ circular pillars.\n\nLight travels in straight lines and is absorbed by walls and pillars. The pillars therefore cast shadows: they do not let light through. There are places in the room where no light reaches (black), where only one of the two light sources reaches (red or green), and places where both lights reach (yellow). Compute the total area of each of the four colors in the room. Do not include the area of the pillars.", "inputFormat": "* One line containing the number of test cases, $T$.\n\nEach test case contains, in order:\n\n* One line containing the coordinates $x$, $y$ of the red light source.\n* One line containing the coordinates $x$, $y$ of the green light source.\n* One line containing the number of pillars $n$.\n* $n$ lines describing the pillars. Each contains 3 numbers $x$, $y$, $r$. The pillar is a disk with the center $(x, y)$ and radius $r$.\n\nThe room is the square described by $0 \\leq x, y \\leq 100$. Pillars, room walls and light sources are all disjoint, they do not overlap or touch.", "outputFormat": "For each test case, output:\n\n```\nCase #X:\nblack area\nred area\ngreen area\nyellow area\n```\n\nwhere $X$ is the test case number, starting from 1, and each area is a real number.\n\nAny answer with absolute or relative error of at most $10^{-5}$ will be accepted.", "hint": "**Limits**\n\n- All input numbers are integers.\n- $1 \\leq T \\leq 15$\n- $0 \\leq x, y \\leq 100$\n- $1 \\leq r \\leq 49$\n\n**Small dataset(21 Pts)**\n\n- Time limit: ~~20~~ 5 seconds.\n- $0 \\leq n \\leq 1$\n\n**Large dataset(45 Pts)**\n\n- Time limit: ~~90~~ 30 seconds.\n- $0 \\leq n \\leq 50$", "locale": "en", "translations": {"en": {"title": "[GCJ 2009 Finals] Lights", "background": "", "description": "In a big, square room there are two point light sources: one is red and the other is green. There are also $n$ circular pillars.\n\nLight travels in straight lines and is absorbed by walls and pillars. The pillars therefore cast shadows: they do not let light through. There are places in the room where no light reaches (black), where only one of the two light sources reaches (red or green), and places where both lights reach (yellow). Compute the total area of each of the four colors in the room. Do not include the area of the pillars.", "inputFormat": "* One line containing the number of test cases, $T$.\n\nEach test case contains, in order:\n\n* One line containing the coordinates $x$, $y$ of the red light source.\n* One line containing the coordinates $x$, $y$ of the green light source.\n* One line containing the number of pillars $n$.\n* $n$ lines describing the pillars. Each contains 3 numbers $x$, $y$, $r$. The pillar is a disk with the center $(x, y)$ and radius $r$.\n\nThe room is the square described by $0 \\leq x, y \\leq 100$. Pillars, room walls and light sources are all disjoint, they do not overlap or touch.", "outputFormat": "For each test case, output:\n\n```\nCase #X:\nblack area\nred area\ngreen area\nyellow area\n```\n\nwhere $X$ is the test case number, starting from 1, and each area is a real number.\n\nAny answer with absolute or relative error of at most $10^{-5}$ will be accepted.", "hint": "**Limits**\n\n- All input numbers are integers.\n- $1 \\leq T \\leq 15$\n- $0 \\leq x, y \\leq 100$\n- $1 \\leq r \\leq 49$\n\n**Small dataset(21 Pts)**\n\n- Time limit: ~~20~~ 5 seconds.\n- $0 \\leq n \\leq 1$\n\n**Large dataset(45 Pts)**\n\n- Time limit: ~~90~~ 30 seconds.\n- $0 \\leq n \\leq 50$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2009 Finals] Lights", "background": "", "description": "在一个大的正方形房间里，有两个点光源：一个是红色的，另一个是绿色的。房间里还有 $n$ 根圆柱形立柱。\n\n光线沿直线传播，并会被墙壁和立柱吸收。因此，立柱会产生阴影：它们不会让光线穿透。在房间的某些区域，光线无法到达（黑色）；有些区域只有一个光源能够照射到（红色或绿色）；还有一些区域两个光源的光线都能照到（黄色）。请你计算房间内每种颜色区域的总面积。不要计算立柱本身的面积。", "inputFormat": "- 第一行包含一个整数 $T$，表示测试用例的数量。\n\n每个测试用例依次包含：\n\n- 一行，包含红色光源的坐标 $x$、$y$。\n- 一行，包含绿色光源的坐标 $x$、$y$。\n- 一行，包含立柱的数量 $n$。\n- 接下来 $n$ 行，每行包含三个数 $x$、$y$、$r$，表示一个立柱的圆心坐标为 $(x, y)$，半径为 $r$。\n\n房间是一个满足 $0 \\leq x, y \\leq 100$ 的正方形。立柱、房间的墙壁和光源都是互不相交、互不接触的。\n", "outputFormat": "对于每个测试用例，输出：\n\n```\nCase #X:\nblack area\nred area\ngreen area\nyellow area\n```\n\n其中 $X$ 是测试编号（从 1 开始），每个面积为一个实数。\n\n只要你的答案的绝对误差或相对误差不超过 $10^{-5}$，即可被接受。", "hint": "**限制条件**\n\n- 所有输入数据均为整数。\n- $1 \\leq T \\leq 15$\n- $0 \\leq x, y \\leq 100$\n- $1 \\leq r \\leq 49$\n\n**小数据集（21 分）**\n\n- 时间限制：5 秒\n- $0 \\leq n \\leq 1$\n\n**大数据集（45 分）**\n\n- 时间限制：30 秒\n- $0 \\leq n \\leq 50$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13454", "type": "P", "difficulty": 2, "samples": [["2\n5\nYeehaw\nNSM\nDont Ask\nB9\nGoogol\n10\nYeehaw\nYeehaw\nGoogol\nB9\nGoogol\nNSM\nB9\nNSM\nDont Ask\nGoogol\n5\nYeehaw\nNSM\nDont Ask\nB9\nGoogol\n7\nGoogol\nDont Ask\nNSM\nNSM\nYeehaw\nYeehaw\nGoogol", "Case #1: 1\nCase #2: 0"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2008", "Google Code Jam"], "title": "[GCJ 2008 Qualification] Saving the Universe", "background": "", "description": "The urban legend goes that if you go to the Google homepage and search for \"Google\", the universe will implode. We have a secret to share... It is true! Please don't try it, or tell anyone. All right, maybe not. We are just kidding.\n\nThe same is not true for a universe far far away. In that universe, if you search on any search engine for that search engine's name, the universe does implode!\n\nTo combat this, people came up with an interesting solution. All queries are pooled together. They are passed to a central system that decides which query goes to which search engine. The central system sends a series of queries to one search engine, and can switch to another at any time. Queries must be processed in the order they're received. The central system must never send a query to a search engine whose name matches the query. In order to reduce costs, the number of switches should be minimized.\n\nYour task is to tell us how many times the central system will have to switch between search engines, assuming that we program it optimally.", "inputFormat": "The first line of the input file contains the number of cases, $N$. $N$ test cases follow.\n\nEach case starts with the number $S$ -- the number of search engines. The next $S$ lines each contain the name of a search engine. Each search engine name is no more than one hundred characters long and contains only uppercase letters, lowercase letters, spaces, and numbers. There will not be two search engines with the same name.\n\nThe following line contains a number $Q$ -- the number of incoming queries. The next $Q$ lines will each contain a query. Each query will be the name of a search engine in the case.\n", "outputFormat": "For each input case, you should output:\n\nCase #$X$: $Y$\n\nwhere $X$ is the number of the test case and $Y$ is the number of search engine switches. Do not count the initial choice of a search engine as a switch.", "hint": "**Sample Explanation**\n\nIn the first case, one possible solution is to start by using Dont Ask, and switch to NSM after query number 8.\n\nFor the second case, you can use B9, and not need to make any switches.\n\n**Limits**\n\n- $0 < N \\leq 20$\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $2 \\leq S \\leq 10$\n- $0 \\leq Q \\leq 100$\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $2 \\leq S \\leq 100$\n- $0 \\leq Q \\leq 1000$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2008 Qualification] Saving the Universe", "background": "", "description": "The urban legend goes that if you go to the Google homepage and search for \"Google\", the universe will implode. We have a secret to share... It is true! Please don't try it, or tell anyone. All right, maybe not. We are just kidding.\n\nThe same is not true for a universe far far away. In that universe, if you search on any search engine for that search engine's name, the universe does implode!\n\nTo combat this, people came up with an interesting solution. All queries are pooled together. They are passed to a central system that decides which query goes to which search engine. The central system sends a series of queries to one search engine, and can switch to another at any time. Queries must be processed in the order they're received. The central system must never send a query to a search engine whose name matches the query. In order to reduce costs, the number of switches should be minimized.\n\nYour task is to tell us how many times the central system will have to switch between search engines, assuming that we program it optimally.", "inputFormat": "The first line of the input file contains the number of cases, $N$. $N$ test cases follow.\n\nEach case starts with the number $S$ -- the number of search engines. The next $S$ lines each contain the name of a search engine. Each search engine name is no more than one hundred characters long and contains only uppercase letters, lowercase letters, spaces, and numbers. There will not be two search engines with the same name.\n\nThe following line contains a number $Q$ -- the number of incoming queries. The next $Q$ lines will each contain a query. Each query will be the name of a search engine in the case.\n", "outputFormat": "For each input case, you should output:\n\nCase #$X$: $Y$\n\nwhere $X$ is the number of the test case and $Y$ is the number of search engine switches. Do not count the initial choice of a search engine as a switch.", "hint": "**Sample Explanation**\n\nIn the first case, one possible solution is to start by using Dont Ask, and switch to NSM after query number 8.\n\nFor the second case, you can use B9, and not need to make any switches.\n\n**Limits**\n\n- $0 < N \\leq 20$\n\n**Small dataset (5 Pts, Test set 1 - Visible)**\n\n- $2 \\leq S \\leq 10$\n- $0 \\leq Q \\leq 100$\n\n**Large dataset (20 Pts, Test set 2 - Hidden)**\n\n- $2 \\leq S \\leq 100$\n- $0 \\leq Q \\leq 1000$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2008 Qualification] Saving the Universe", "background": null, "description": "有一个都市传说：如果你在 Google 首页搜索“Google”，宇宙就会崩溃。我们有个秘密要告诉你……这是真的！请不要尝试，也不要告诉别人。好吧，其实不是，我们只是开玩笑。\n\n但在遥远的另一个宇宙中，情况却并非如此。在那个宇宙里，如果你在任何搜索引擎上搜索该搜索引擎的名字，宇宙真的会崩溃！\n\n为了解决这个问题，人们想出了一个有趣的办法。所有的查询会被集中到一起，然后交给一个中央系统来决定每个查询由哪个搜索引擎处理。中央系统会将一系列查询发送给某个搜索引擎，并且可以随时切换到另一个搜索引擎。所有查询必须按照收到的顺序处理。中央系统绝不能将一个查询发送给名字与该查询相同的搜索引擎。为了降低成本，切换搜索引擎的次数应尽量少。\n\n你的任务是：假设我们以最优方式编程，请你告诉我们中央系统需要切换多少次搜索引擎。", "inputFormat": "输入文件的第一行包含测试用例数 $N$。接下来有 $N$ 组测试数据。\n\n每组测试数据首先包含一个整数 $S$，表示搜索引擎的数量。接下来的 $S$ 行，每行包含一个搜索引擎的名字。每个搜索引擎名字不超过一百个字符，只包含大写字母、小写字母、空格和数字。不会有两个搜索引擎名字相同。\n\n接下来一行包含一个整数 $Q$，表示收到的查询数量。接下来的 $Q$ 行，每行包含一个查询。每个查询都是本组测试数据中某个搜索引擎的名字。", "outputFormat": "对于每组输入数据，输出：\n\nCase #$X$: $Y$\n\n其中 $X$ 是测试用例编号，$Y$ 是切换搜索引擎的次数。初始选择搜索引擎不计为一次切换。", "hint": "**样例解释**\n\n在第一个测试用例中，一种可行的方案是先使用 Dont Ask，在第 8 个查询后切换到 NSM。\n\n在第二个测试用例中，你可以一直使用 B9，无需切换。\n\n**数据范围**\n\n- $0 < N \\leq 20$\n\n**小数据集（5 分，测试点 1 - 可见）**\n\n- $2 \\leq S \\leq 10$\n- $0 \\leq Q \\leq 100$\n\n**大数据集（20 分，测试点 2 - 隐藏）**\n\n- $2 \\leq S \\leq 100$\n- $0 \\leq Q \\leq 1000$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
