{"pid": "P11698", "type": "P", "difficulty": 4, "samples": [["42\n179", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "Special Judge", "ROIR（俄罗斯）"], "title": "[ROIR 2025] 不完全质数", "background": "翻译自 [ROIR 2025 D1T2](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day1.pdf)。$%标题解析 by GPT：在俄语中，**\"простые числа\"**（质数）是由**\"простой\"**（简单的、普通的）和**\"число\"**（数字、数）构成的短语，表示“质数”这一数学概念。当在 **\"простые\"** 后加上 **\"-оват-\"** 后缀（即变为 **\"простоватые\"**），这个词的含义就发生了变化。**\"-оват-\"** 是俄语中的一个后缀，用于形容词或名词，通常会带有一种轻微的、不完全的含义，或者带有一种贬义或降低的语气。**\"-оват-\"** 后缀通常表示某物处于某种状态，但并不是完全符合该状态或标准，带有一些“接近但不完全”的意味。它强调了某种特性，但并不完全具备。例如：- **\"молодой\"**（年轻的）变成 **\"молодоватый\"**（有点年轻、不完全年轻）。- **\"сильный\"**（强的）变成 **\"сильноватый\"**（有点强，但不完全强）。在这种情况下，**\"простоватые\"** 由 **\"простой\"**（简单的）加上 **\"-оват-\"** 后缀构成，表示“有点简单的”或者“接近简单的”，即“简单但不完全是质数”的意思。所以，**\"простоватые числа\"** 指的是“接近质数的数字”，即这些数字的数字乘积是质数，但并不完全符合质数的定义。$", "description": "如果一个数字在十进制表示下的各位数字之积是一个质数，则称这个数为“不完全质数”。例如，$12$ 是一个不完全质数，因为 $1 \\times 2 = 2$ 是质数；但是 $29$ 不是不完全质数，因为 $2 \\times 9 = 18$ 不是质数。\n\n现在，你需要计算出 $[l,r]$ 的不完全质数的数量。", "inputFormat": "第一行包含一个整数 $l$（$1 \\leq l \\leq 10^{100000}$）。  \n第二行包含一个整数 $r$（$l \\leq r \\leq 10^{100000}$）。\n\n请注意：输入中的数字非常大，无法直接存储在大多数编程语言的标准整型数据中，例如 C++。因此，需要以特殊的方式读取输入，例如将其作为字符串读取。", "outputFormat": "输出一个整数，表示 $[l,r]$ 的不完全质数的数量。", "hint": "本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。\n\n| 子任务 | 分数  | 特殊性质 |\n|:------------:|:-------:|:----------:|\n| $1  $        |$ 19  $  | $1 \\leq l \\leq r \\leq 10^6$ | 第一错误 |\n| $2  $        | $26  $  | $1 \\leq l \\leq r \\leq 10^{18}$ | 第一错误 |\n| $3  $        | $12  $  | $l = 1, r = 10^k$，其中 $1 \\leq k \\leq 10^5$ | 第一错误 |\n| $4 $         | $18 $   | $1 \\leq l \\leq r \\leq 10^{1000}$ | 第一、二错误 |\n| $5$          | $25$    | 无 | - |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2025] 不完全质数", "background": "翻译自 [ROIR 2025 D1T2](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day1.pdf)。$%标题解析 by GPT：在俄语中，**\"простые числа\"**（质数）是由**\"простой\"**（简单的、普通的）和**\"число\"**（数字、数）构成的短语，表示“质数”这一数学概念。当在 **\"простые\"** 后加上 **\"-оват-\"** 后缀（即变为 **\"простоватые\"**），这个词的含义就发生了变化。**\"-оват-\"** 是俄语中的一个后缀，用于形容词或名词，通常会带有一种轻微的、不完全的含义，或者带有一种贬义或降低的语气。**\"-оват-\"** 后缀通常表示某物处于某种状态，但并不是完全符合该状态或标准，带有一些“接近但不完全”的意味。它强调了某种特性，但并不完全具备。例如：- **\"молодой\"**（年轻的）变成 **\"молодоватый\"**（有点年轻、不完全年轻）。- **\"сильный\"**（强的）变成 **\"сильноватый\"**（有点强，但不完全强）。在这种情况下，**\"простоватые\"** 由 **\"простой\"**（简单的）加上 **\"-оват-\"** 后缀构成，表示“有点简单的”或者“接近简单的”，即“简单但不完全是质数”的意思。所以，**\"простоватые числа\"** 指的是“接近质数的数字”，即这些数字的数字乘积是质数，但并不完全符合质数的定义。$", "description": "如果一个数字在十进制表示下的各位数字之积是一个质数，则称这个数为“不完全质数”。例如，$12$ 是一个不完全质数，因为 $1 \\times 2 = 2$ 是质数；但是 $29$ 不是不完全质数，因为 $2 \\times 9 = 18$ 不是质数。\n\n现在，你需要计算出 $[l,r]$ 的不完全质数的数量。", "inputFormat": "第一行包含一个整数 $l$（$1 \\leq l \\leq 10^{100000}$）。  \n第二行包含一个整数 $r$（$l \\leq r \\leq 10^{100000}$）。\n\n请注意：输入中的数字非常大，无法直接存储在大多数编程语言的标准整型数据中，例如 C++。因此，需要以特殊的方式读取输入，例如将其作为字符串读取。", "outputFormat": "输出一个整数，表示 $[l,r]$ 的不完全质数的数量。", "hint": "本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。\n\n| 子任务 | 分数  | 特殊性质 |\n|:------------:|:-------:|:----------:|\n| $1  $        |$ 19  $  | $1 \\leq l \\leq r \\leq 10^6$ | 第一错误 |\n| $2  $        | $26  $  | $1 \\leq l \\leq r \\leq 10^{18}$ | 第一错误 |\n| $3  $        | $12  $  | $l = 1, r = 10^k$，其中 $1 \\leq k \\leq 10^5$ | 第一错误 |\n| $4 $         | $18 $   | $1 \\leq l \\leq r \\leq 10^{1000}$ | 第一、二错误 |\n| $5$          | $25$    | 无 | - |", "locale": "zh-CN"}}}
{"pid": "P11699", "type": "P", "difficulty": 6, "samples": [["8\n9 1 8 1 5 2 3 6\n3 3 1 3 3 2 1\n", "0\n4\n0\n0\n0\n13\n20"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "Special Judge", "ROIR（俄罗斯）"], "title": "[ROIR 2025] 酸雨", "background": "翻译自 [ROIR 2025 D1T3](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day1.pdf)。", "description": "有 $n$ 个模块被运送到金星上用于组装实验室。模块按顺序排列，第 $i$ 个模块的高度为 $h_i$。\n\n组装工作将由一台特殊的机器人来完成。在组装过程中，连续的模块段将逐渐合并，而模块在排列中的顺序不会改变。最初，每个模块都是一个独立的段，段的编号从 $1$ 到 $n$，与模块的编号顺序相同。如果有两个相邻的模块段 $A = [i, i+1, \\dots, i+p-1]$ 和 $B = [i+p, i+p+1, \\dots, i+p+q-1]$，那么它们合并后变成段 $AB = [i, i+1, \\dots, i+p-1, i+p, i+p+1, \\dots, i+p+q-1]$。\n\n组装指令由 $n-1$ 条指令组成。每条指令包含一个数字 $k_j$。执行该指令后，编号为 $k_j$ 和 $k_j + 1$ 的模块段合并为一个新段，合并后的段占据原来两个段的位置，并重新对段进行编号，从 $k_j + 2$ 开始，后面的段的编号依次减 $1$。执行完所有指令后，所有段将合并为一个段。\n\n金星上常年下酸雨，因此在组装过程中，必须在每次合并后了解每个段中可能积累的液体量。设一个段包含高度为 $h_l, h_{l+1}, \\dots, h_r$ 的模块。对于其中任意一个模块 $p$，其中 $l \\leq p \\leq r$，我们定义该模块 $p$ 在该段的深度 $d_p$ 如下：\n\n首先计算左侧最大高度 $l_p = \\max\\{ h_l, h_{l+1}, \\dots, h_p \\}$ 和右侧最大高度 $r_p = \\max\\{ h_p, h_{p+1}, \\dots, h_r \\}$。这分别是该段中模块 $p$ 左侧和右侧的最大高度。该模块 $p$ 的深度定义为 $d_p = \\min(l_p, r_p) - h_p$，显然 $d_p > 0$。段的容量定义为该段所有模块的深度之和，即 $w = d_l + d_{l+1} + \\dots + d_r$。\n\n给定一系列合并操作，请在每次合并后输出合并段的容量。", "inputFormat": "第一行包含一个整数 $n$，表示模块的数量（$2 \\leq n \\leq 10^5$）。\n\n第二行包含 $n$ 个整数 $h_1, h_2, \\dots, h_n$（$1 \\leq h_i \\leq 10^9$），表示每个模块的高度。\n\n第三行包含 $n-1$ 个整数，表示合并操作的指令，每个指令用一个整数 $k_j$ 表示（$1 \\leq k_j \\leq n-j$）。", "outputFormat": "输出 $n-1$ 个整数，用换行隔开，表示每次合并后，合并段的容量。", "hint": "下图显示了样例中指令执行的过程，每个模块上方标出了其深度，并显示了新段的容量。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/na9xfgva.png)\n\n本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。\n\n| 子任务 | 分数 | 特殊性质 |\n| :------: | :----: | :--------: |\n| $1$      | $13  $ | $n \\leq 100$ |\n| $2 $     | $13  $ | $n \\leq 1000$ |\n| $3  $    | $13  $ | $h_i \\leq 10$ |\n| $4  $    | $13  $ | $\\exist i,h_1 \\ge h_2 \\ge \\dots \\ge h_i \\leq \\dots \\leq h_n$ |\n| $5  $    | $7  $  | 所有查询中 $k_j = 1$ |\n| $6  $    | $13$   | $n \\leq 40000$ |\n| $7  $    | $28$   | 无 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2025] 酸雨", "background": "翻译自 [ROIR 2025 D1T3](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day1.pdf)。", "description": "有 $n$ 个模块被运送到金星上用于组装实验室。模块按顺序排列，第 $i$ 个模块的高度为 $h_i$。\n\n组装工作将由一台特殊的机器人来完成。在组装过程中，连续的模块段将逐渐合并，而模块在排列中的顺序不会改变。最初，每个模块都是一个独立的段，段的编号从 $1$ 到 $n$，与模块的编号顺序相同。如果有两个相邻的模块段 $A = [i, i+1, \\dots, i+p-1]$ 和 $B = [i+p, i+p+1, \\dots, i+p+q-1]$，那么它们合并后变成段 $AB = [i, i+1, \\dots, i+p-1, i+p, i+p+1, \\dots, i+p+q-1]$。\n\n组装指令由 $n-1$ 条指令组成。每条指令包含一个数字 $k_j$。执行该指令后，编号为 $k_j$ 和 $k_j + 1$ 的模块段合并为一个新段，合并后的段占据原来两个段的位置，并重新对段进行编号，从 $k_j + 2$ 开始，后面的段的编号依次减 $1$。执行完所有指令后，所有段将合并为一个段。\n\n金星上常年下酸雨，因此在组装过程中，必须在每次合并后了解每个段中可能积累的液体量。设一个段包含高度为 $h_l, h_{l+1}, \\dots, h_r$ 的模块。对于其中任意一个模块 $p$，其中 $l \\leq p \\leq r$，我们定义该模块 $p$ 在该段的深度 $d_p$ 如下：\n\n首先计算左侧最大高度 $l_p = \\max\\{ h_l, h_{l+1}, \\dots, h_p \\}$ 和右侧最大高度 $r_p = \\max\\{ h_p, h_{p+1}, \\dots, h_r \\}$。这分别是该段中模块 $p$ 左侧和右侧的最大高度。该模块 $p$ 的深度定义为 $d_p = \\min(l_p, r_p) - h_p$，显然 $d_p > 0$。段的容量定义为该段所有模块的深度之和，即 $w = d_l + d_{l+1} + \\dots + d_r$。\n\n给定一系列合并操作，请在每次合并后输出合并段的容量。", "inputFormat": "第一行包含一个整数 $n$，表示模块的数量（$2 \\leq n \\leq 10^5$）。\n\n第二行包含 $n$ 个整数 $h_1, h_2, \\dots, h_n$（$1 \\leq h_i \\leq 10^9$），表示每个模块的高度。\n\n第三行包含 $n-1$ 个整数，表示合并操作的指令，每个指令用一个整数 $k_j$ 表示（$1 \\leq k_j \\leq n-j$）。", "outputFormat": "输出 $n-1$ 个整数，用换行隔开，表示每次合并后，合并段的容量。", "hint": "下图显示了样例中指令执行的过程，每个模块上方标出了其深度，并显示了新段的容量。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/na9xfgva.png)\n\n本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。\n\n| 子任务 | 分数 | 特殊性质 |\n| :------: | :----: | :--------: |\n| $1$      | $13  $ | $n \\leq 100$ |\n| $2 $     | $13  $ | $n \\leq 1000$ |\n| $3  $    | $13  $ | $h_i \\leq 10$ |\n| $4  $    | $13  $ | $\\exist i,h_1 \\ge h_2 \\ge \\dots \\ge h_i \\leq \\dots \\leq h_n$ |\n| $5  $    | $7  $  | 所有查询中 $k_j = 1$ |\n| $6  $    | $13$   | $n \\leq 40000$ |\n| $7  $    | $28$   | 无 |", "locale": "zh-CN"}}}
{"pid": "P11700", "type": "P", "difficulty": 6, "samples": [["5 3\n2 1 2 3 2\n", "24"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "Special Judge", "ROIR（俄罗斯）"], "title": "[ROIR 2025] 寻找宝藏", "background": "翻译自 [ROIR 2025 D1T4](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day1.pdf)。", "description": "为了寻找有用的矿产资源，科学家们开发了一种特殊的扫描仪。\n\n假设搜索区域是一个包含 $k$ 行和 $n$ 列的表格。行号从上到下编号为 $1$ 到 $k$，列号从左到右编号为 $1$ 到 $n$。每个单元格中可能含有矿产资源。  \n\n扫描仪的工作原理如下：它可以从第 $p$ 列启动，并返回扫描区域内包含矿产资源的单元格数。扫描区域包括第 $p$ 列的所有单元格、第 $p-1$ 列的前 $k-1$ 个单元格、第 $p-2$ 列的前 $k-2$ 个单元格，以此类推。下图展示了当 $k=3$，$n=5$ 时，所有可能的 $p$ 值的扫描区域。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/91a4kisv.png)\n\n现在，给定扫描仪返回的每个 $p$ 值的结果，记为 $b_p$，即在第 $p$ 列的扫描区域内，矿产资源的数量。如果一个表格的矿产资源分布能匹配扫描仪的返回值，则称这个表格是“合法的”。比如，若扫描仪返回值为 $[2, 1, 2, 3, 2]$，则其中一个合法的表格可能如下所示（含有矿产的单元格用黑色三角形表示）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yez7rrpa.png)\n\n你需要根据给定的扫描结果，确定合法表格的数量，并输出其对 $10^9 + 7$ 取模的结果。注意，扫描仪可能存在故障，导致没有任何合法的表格，这种情况下应输出 $0$。", "inputFormat": "第一行输入两个整数 $n, k$，分别表示列数和行数（$1 \\leq n \\leq 200, 1 \\leq k \\leq 7$）。\n\n第二行输入 $n$ 个整数 $b_1, b_2, \\dots, b_n$，表示扫描仪返回的每个列的矿产数量（$0 \\leq b_i \\leq k^2$）。", "outputFormat": "输出一个整数，表示正确表格的数量对 $10^9 + 7$ 取模的结果。如果没有正确的表格，输出 $0$。", "hint": "本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。\n\n\n| 子任务 | 分数 | 特殊性质 |\n|:--------:|:------:|:----------:|\n| $1$      | $7   $ | $k \\leq 2$ | 第一子任务 |\n| $2 $     | $9    $| $k \\leq 3$ | 第一、二子任务 |\n| $3  $    | $9   $ | $k \\leq 4$ | 第一、二、三子任务 |\n| $4  $    | $20  $ | $k \\leq 5$ | 第一至四子任务 |\n| $5  $    | $15 $  | $k \\leq 6$ | 第一至五子任务 |\n| $6  $    | $10 $  | $1 \\leq n \\cdot k \\leq 25$ | 第一至五子任务 |\n| $7$      | $30$   | 无 | 第一至六子任务 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2025] 寻找宝藏", "background": "翻译自 [ROIR 2025 D1T4](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day1.pdf)。", "description": "为了寻找有用的矿产资源，科学家们开发了一种特殊的扫描仪。\n\n假设搜索区域是一个包含 $k$ 行和 $n$ 列的表格。行号从上到下编号为 $1$ 到 $k$，列号从左到右编号为 $1$ 到 $n$。每个单元格中可能含有矿产资源。  \n\n扫描仪的工作原理如下：它可以从第 $p$ 列启动，并返回扫描区域内包含矿产资源的单元格数。扫描区域包括第 $p$ 列的所有单元格、第 $p-1$ 列的前 $k-1$ 个单元格、第 $p-2$ 列的前 $k-2$ 个单元格，以此类推。下图展示了当 $k=3$，$n=5$ 时，所有可能的 $p$ 值的扫描区域。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/91a4kisv.png)\n\n现在，给定扫描仪返回的每个 $p$ 值的结果，记为 $b_p$，即在第 $p$ 列的扫描区域内，矿产资源的数量。如果一个表格的矿产资源分布能匹配扫描仪的返回值，则称这个表格是“合法的”。比如，若扫描仪返回值为 $[2, 1, 2, 3, 2]$，则其中一个合法的表格可能如下所示（含有矿产的单元格用黑色三角形表示）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yez7rrpa.png)\n\n你需要根据给定的扫描结果，确定合法表格的数量，并输出其对 $10^9 + 7$ 取模的结果。注意，扫描仪可能存在故障，导致没有任何合法的表格，这种情况下应输出 $0$。", "inputFormat": "第一行输入两个整数 $n, k$，分别表示列数和行数（$1 \\leq n \\leq 200, 1 \\leq k \\leq 7$）。\n\n第二行输入 $n$ 个整数 $b_1, b_2, \\dots, b_n$，表示扫描仪返回的每个列的矿产数量（$0 \\leq b_i \\leq k^2$）。", "outputFormat": "输出一个整数，表示正确表格的数量对 $10^9 + 7$ 取模的结果。如果没有正确的表格，输出 $0$。", "hint": "本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。\n\n\n| 子任务 | 分数 | 特殊性质 |\n|:--------:|:------:|:----------:|\n| $1$      | $7   $ | $k \\leq 2$ | 第一子任务 |\n| $2 $     | $9    $| $k \\leq 3$ | 第一、二子任务 |\n| $3  $    | $9   $ | $k \\leq 4$ | 第一、二、三子任务 |\n| $4  $    | $20  $ | $k \\leq 5$ | 第一至四子任务 |\n| $5  $    | $15 $  | $k \\leq 6$ | 第一至五子任务 |\n| $6  $    | $10 $  | $1 \\leq n \\cdot k \\leq 25$ | 第一至五子任务 |\n| $7$      | $30$   | 无 | 第一至六子任务 |", "locale": "zh-CN"}}}
{"pid": "P11701", "type": "P", "difficulty": 3, "samples": [["64 1 100", "1"], ["64 1 300", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2025", "Special Judge", "ROIR（俄罗斯）"], "title": "[ROIR 2025] 平方差", "background": "翻译自 [ROIR 2025 D2T1](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day2.pdf)。", "description": "给定 $l$，$r$ 和 $d$，求有多少个自然数对 $(x,y)$ 满足 $l \\leq y^2 < x^2 \\leq r$ 且 $x^2-y^2=d$。", "inputFormat": "输入三个整数 $d$、$l$ 和 $r$（$1 \\leq d \\leq 10^9$，$1 \\leq l \\leq r \\leq 10^{18}$）。", "outputFormat": "输出满足条件的 $(x,y)$ 的数量。", "hint": "样例解释：\n\n在第一个样例中，符合条件的数对是 $(10,6)$。  \n在第二个样例中，符合条件的数对还有 $(17,15)%loj 上样例解释有误$。\n\n本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。\n\n| 子任务 | 分数 | 特殊性质 |\n|:---:|:---:|:---:|\n| $1  $ |$ 18  $| $1 \\leq d \\leq 10^3$, $1 \\leq l \\leq r \\leq 10^3$  | 第一子任务 |\n| $2  $ | $19  $| $1 \\leq d \\leq 10^5$, $1 \\leq l \\leq r \\leq 10^5$  | 第一、二子任务 |\n| $3  $ | $20  $| $1 \\leq d \\leq 10^7$, $1 \\leq l \\leq r \\leq 10^7$  | 第一、二、三子任务 |\n| $4  $ | $21 $ | $1 \\leq d \\leq 10^9$, $1 \\leq l \\leq r \\leq 10^{10}$  | 第一至三子任务 |\n| $5 $  | $22$  | 无 | 第一至四子任务 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2025] 平方差", "background": "翻译自 [ROIR 2025 D2T1](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day2.pdf)。", "description": "给定 $l$，$r$ 和 $d$，求有多少个自然数对 $(x,y)$ 满足 $l \\leq y^2 < x^2 \\leq r$ 且 $x^2-y^2=d$。", "inputFormat": "输入三个整数 $d$、$l$ 和 $r$（$1 \\leq d \\leq 10^9$，$1 \\leq l \\leq r \\leq 10^{18}$）。", "outputFormat": "输出满足条件的 $(x,y)$ 的数量。", "hint": "样例解释：\n\n在第一个样例中，符合条件的数对是 $(10,6)$。  \n在第二个样例中，符合条件的数对还有 $(17,15)%loj 上样例解释有误$。\n\n本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。\n\n| 子任务 | 分数 | 特殊性质 |\n|:---:|:---:|:---:|\n| $1  $ |$ 18  $| $1 \\leq d \\leq 10^3$, $1 \\leq l \\leq r \\leq 10^3$  | 第一子任务 |\n| $2  $ | $19  $| $1 \\leq d \\leq 10^5$, $1 \\leq l \\leq r \\leq 10^5$  | 第一、二子任务 |\n| $3  $ | $20  $| $1 \\leq d \\leq 10^7$, $1 \\leq l \\leq r \\leq 10^7$  | 第一、二、三子任务 |\n| $4  $ | $21 $ | $1 \\leq d \\leq 10^9$, $1 \\leq l \\leq r \\leq 10^{10}$  | 第一至三子任务 |\n| $5 $  | $22$  | 无 | 第一至四子任务 |", "locale": "zh-CN"}}}
{"pid": "P11702", "type": "P", "difficulty": 4, "samples": [["4 2\n2 1 3 4", "6\n"], ["5 4\n2 1 3 4 1", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "Special Judge", "ROIR（俄罗斯）"], "title": "[ROIR 2025] 不平衡划分", "background": "翻译自 [ROIR 2025 D2T2](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day2.pdf)。", "description": "给定一个非负整数数组 $[a_1, a_2, \\dots, a_n]$。考虑将该数组划分成 $k$ 个非空的连续子段。我们称划分方案的“不平衡度”为这些子段和中的最大值与最小值之差。你需要求出将该数组划分成 $k$ 个子段时的最大不平衡度。\n\n例如，如果数组为 $[2, 1, 3, 4]$，$k=2$，则：\n- 划分为 $[2, 1, 3][4]$ 时，不平衡度为 $6 - 4 = 2$；\n- 划分为 $[2, 1][3, 4]$ 时，不平衡度为 $7 - 3 = 4$；\n- 划分为 $[2][1, 3, 4]$ 时，不平衡度为 $8 - 2 = 6$。\n\n其中最后一种情况的不平衡度最大。", "inputFormat": "第一行输入两个整数 $n$ 和 $k$（$2 \\le k \\le n \\le 300000$），分别表示数组的长度和需要划分的子段的数量。\n\n第二行包含 $n$ 个整数 $a_1,a_2,\\dots,a_n$（$0 \\le a_i \\le 10^9$）。", "outputFormat": "输出一个整数，即将该数组划分为 $k$ 个子段时的最大不平衡度。", "hint": "在样例二中，最优划分方案是 $[2][1][3, 4][1]$。其中最大子段和为 $3 + 4 = 7$，最小子段和为 $1$，因此不平衡度为 $7 - 1 = 6$。\n\n本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。\n\n| 子任务 | 分数 | 特殊性质 |\n|:---:|:---:|:---:|\n| $1$ | $11$ | $n \\le 15$ | 第一错误 | |\n| $2$ | $11$ | $k = 2$ | 第一错误 | |\n| $3$ | $21$ | $k = 3$ | 第一错误 | |\n| $4$ | $15$ | $n \\le 300$ | 1 | 第一错误 |\n| $5$ | $21$ | $n \\le 3000$ | 1, 4 | 第一错误 |\n| $6$ |$ 21 $| 无 | 1-5 | 第一错误 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2025] 不平衡划分", "background": "翻译自 [ROIR 2025 D2T2](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day2.pdf)。", "description": "给定一个非负整数数组 $[a_1, a_2, \\dots, a_n]$。考虑将该数组划分成 $k$ 个非空的连续子段。我们称划分方案的“不平衡度”为这些子段和中的最大值与最小值之差。你需要求出将该数组划分成 $k$ 个子段时的最大不平衡度。\n\n例如，如果数组为 $[2, 1, 3, 4]$，$k=2$，则：\n- 划分为 $[2, 1, 3][4]$ 时，不平衡度为 $6 - 4 = 2$；\n- 划分为 $[2, 1][3, 4]$ 时，不平衡度为 $7 - 3 = 4$；\n- 划分为 $[2][1, 3, 4]$ 时，不平衡度为 $8 - 2 = 6$。\n\n其中最后一种情况的不平衡度最大。", "inputFormat": "第一行输入两个整数 $n$ 和 $k$（$2 \\le k \\le n \\le 300000$），分别表示数组的长度和需要划分的子段的数量。\n\n第二行包含 $n$ 个整数 $a_1,a_2,\\dots,a_n$（$0 \\le a_i \\le 10^9$）。", "outputFormat": "输出一个整数，即将该数组划分为 $k$ 个子段时的最大不平衡度。", "hint": "在样例二中，最优划分方案是 $[2][1][3, 4][1]$。其中最大子段和为 $3 + 4 = 7$，最小子段和为 $1$，因此不平衡度为 $7 - 1 = 6$。\n\n本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。\n\n| 子任务 | 分数 | 特殊性质 |\n|:---:|:---:|:---:|\n| $1$ | $11$ | $n \\le 15$ | 第一错误 | |\n| $2$ | $11$ | $k = 2$ | 第一错误 | |\n| $3$ | $21$ | $k = 3$ | 第一错误 | |\n| $4$ | $15$ | $n \\le 300$ | 1 | 第一错误 |\n| $5$ | $21$ | $n \\le 3000$ | 1, 4 | 第一错误 |\n| $6$ |$ 21 $| 无 | 1-5 | 第一错误 |", "locale": "zh-CN"}}}
{"pid": "P11703", "type": "P", "difficulty": 4, "samples": [["2 4\n1\n2\n2\n3 1", "No"], ["2 4\n1\n2\n2\n2 1", "Yes\n1\n1\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "Special Judge", "ROIR（俄罗斯）"], "title": "[ROIR 2025] 个人 OI 比赛的原则", "background": "翻译自 [ROIR 2025 D2T3](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day2.pdf)。", "description": "重温一下个人参加 OI 比赛的原则：每道题都要有分！不能有题目得零分。\n\n让我们模拟一个 OI 比赛的过程。假设比赛中有 $n$ 道题目，第 $i$ 道题目包含 $k_i$ 个子任务，第 $i$ 道题目的第 $j$ 个子任务可以获得 $c_{i, j}$ 分。子任务之间是独立的，因此你可以在每道题中选择任意数量的子任务来解答。但是，你不能一个子任务都不选，因为那样这道题得分就是 $0$ 分，这违反了原则。\n\n你想知道，是否可以在遵守原则的前提下，恰好获得 $s$ 分。", "inputFormat": "第一行输入两个整数 $n$ 和 $s$（$1 \\leq n \\leq 100000$，$1 \\leq s \\leq 100000$），分别表示比赛中的题目数量和所需的总得分。接下来 $2n$ 行输入题目的描述，每道题目的描述包含两行：\n\n- 第 $i$ 道题目的第一行包含一个整数 $k_i$（$1 \\leq k_i \\leq 100000$），表示第 $i$ 道题目有多少个子任务。\n- 第 $i$ 道题目的第二行包含 $k_i$ 个整数 $c_{i,1}, c_{i,2}, \\dots, c_{i,k_i}$（$1 \\leq c_{i,j} \\leq 100000$），表示各个子任务的分值。\n\n保证 $k_1 + k_2 + \\dots + k_n \\leq 100000$，且 $(k_1 + k_2 + \\dots + k_n) \\cdot s \\leq 10^7$。", "outputFormat": "如果无解，输出 `No`。\n\n否则，第一行输出 `Yes`。接下来，输出每道题目选择的子任务。\n\n对于第 $i$ 道题目，先输出一行一个整数 $m_i$（$1 \\leq m_i \\leq k_i$），表示你选择的子任务数量。接下来在下一行输出 $m_i$ 个不同的整数 $p_{i, 1}, p_{i, 2}, \\dots, p_{i, m_i}$（$1 \\leq p_{i, j} \\leq k_i$），表示你选择的第 $i$ 道题目的子任务编号。\n\n如果有多个方案可以获得恰好 $s$ 分，可以输出其中任意一个。", "hint": "本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。\n\n| 子任务 | 分数 | 特殊性质 |\n| :--: | :--: | :--: |\n| $1$ | $8$ | $n = 1$ | — | 第一种错误 |\n| $2$ | $10$ | $n = 2$ | — | 第一种错误 |\n| $3$ | $6$ | $k_1 + k_2 + \\dots + k_n \\leq 20$ | — | 第一种错误 |\n| $4$ | $6$ | $k_i = 1$ | — | 第一种错误 |\n| $5$ | $15$ | $n \\cdot s \\leq 100000$, $s \\leq 1000$ | 第三种错误 | — |\n| $6$ | $55$ | 无 | 第1至第5种错误 | — |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2025] 个人 OI 比赛的原则", "background": "翻译自 [ROIR 2025 D2T3](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day2.pdf)。", "description": "重温一下个人参加 OI 比赛的原则：每道题都要有分！不能有题目得零分。\n\n让我们模拟一个 OI 比赛的过程。假设比赛中有 $n$ 道题目，第 $i$ 道题目包含 $k_i$ 个子任务，第 $i$ 道题目的第 $j$ 个子任务可以获得 $c_{i, j}$ 分。子任务之间是独立的，因此你可以在每道题中选择任意数量的子任务来解答。但是，你不能一个子任务都不选，因为那样这道题得分就是 $0$ 分，这违反了原则。\n\n你想知道，是否可以在遵守原则的前提下，恰好获得 $s$ 分。", "inputFormat": "第一行输入两个整数 $n$ 和 $s$（$1 \\leq n \\leq 100000$，$1 \\leq s \\leq 100000$），分别表示比赛中的题目数量和所需的总得分。接下来 $2n$ 行输入题目的描述，每道题目的描述包含两行：\n\n- 第 $i$ 道题目的第一行包含一个整数 $k_i$（$1 \\leq k_i \\leq 100000$），表示第 $i$ 道题目有多少个子任务。\n- 第 $i$ 道题目的第二行包含 $k_i$ 个整数 $c_{i,1}, c_{i,2}, \\dots, c_{i,k_i}$（$1 \\leq c_{i,j} \\leq 100000$），表示各个子任务的分值。\n\n保证 $k_1 + k_2 + \\dots + k_n \\leq 100000$，且 $(k_1 + k_2 + \\dots + k_n) \\cdot s \\leq 10^7$。", "outputFormat": "如果无解，输出 `No`。\n\n否则，第一行输出 `Yes`。接下来，输出每道题目选择的子任务。\n\n对于第 $i$ 道题目，先输出一行一个整数 $m_i$（$1 \\leq m_i \\leq k_i$），表示你选择的子任务数量。接下来在下一行输出 $m_i$ 个不同的整数 $p_{i, 1}, p_{i, 2}, \\dots, p_{i, m_i}$（$1 \\leq p_{i, j} \\leq k_i$），表示你选择的第 $i$ 道题目的子任务编号。\n\n如果有多个方案可以获得恰好 $s$ 分，可以输出其中任意一个。", "hint": "本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。\n\n| 子任务 | 分数 | 特殊性质 |\n| :--: | :--: | :--: |\n| $1$ | $8$ | $n = 1$ | — | 第一种错误 |\n| $2$ | $10$ | $n = 2$ | — | 第一种错误 |\n| $3$ | $6$ | $k_1 + k_2 + \\dots + k_n \\leq 20$ | — | 第一种错误 |\n| $4$ | $6$ | $k_i = 1$ | — | 第一种错误 |\n| $5$ | $15$ | $n \\cdot s \\leq 100000$, $s \\leq 1000$ | 第三种错误 | — |\n| $6$ | $55$ | 无 | 第1至第5种错误 | — |", "locale": "zh-CN"}}}
{"pid": "P11704", "type": "P", "difficulty": 6, "samples": [["3 4 2\n2 2\n2 3", "6"], ["3 4 3\n3 1\n2 3\n1 4", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "LGV 引理", "Special Judge", "ROIR（俄罗斯）"], "title": "[ROIR 2025] 旅行路线", "background": "翻译自 [ROIR 2025 D2T4](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day2.pdf)。", "description": "一群学生来到一座新城市游览，决定参观这里的名胜古迹。这座城市可以看作一个 $n \\times m$ 的矩形网格，其中某些格子上有景点。\n\n他们从格子 $(1, 1)$ 开始旅程，想要先到达格子 $(n, m)$，然后再返回起点。此外，城市中有 $k$ 个景点，位于格子 $(x_1, y_1), \\dots, (x_k, y_k)$，他们一定要全部参观到。\n\n![原题一个不明觉厉的配图](https://cdn.luogu.com.cn/upload/image_hosting/spktsj97.png)\n\n他们可以花费一分钟从格子 $(a, b)$ 移动到与之相邻（即满足 $|a - c| + |b - d| = 1$）的格子 $(c, d)$。显然，完成整个路线至少需要 $2n + 2m - 4$ 分钟。\n\n我们称一条路线为“有趣的”，如果它满足以下条件：\n\n- 完成该路线所需的时间恰好是 $2n + 2m - 4$ 分钟；\n- 路线中的每个格子最多经过一次；\n- 路线必须经过所有包含景点的格子。\n\n请帮助他们计算一共有多少条不同的有趣的路线。由于结果可能很大，只需要输出其对 $10^9 + 7$ 取模的结果。", "inputFormat": "第一行输入三个整数  $n$，$m$ 和 $k$（$3 \\leq n, m \\leq 10^6$，$0 \\leq k \\leq 2000$）。\n\n接下来 $k$ 行，每行包含两个整数 $x_i$ 和 $y_i$（$1 \\leq x_i \\leq n$，$1 \\leq y_i \\leq m$）。保证所有的 $(x_i, y_i)$ 都是不同的，即 $\\forall (i, j), x_i \\neq x_j \\vee y_i \\neq y_j$。", "outputFormat": "输出一个整数，表示有趣的路线的数量对 $10^9 + 7$ 取模的结果。", "hint": "下图展示了样例一中所有有趣的路线，其中带有星号的格子存在名胜古迹。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kzbt6reo.png)\n\n本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。\n\n|子任务|分数|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$5$|$n=3$，$m, k \\leq 100$|\n|$2$|$9$|$n, m, k \\leq 5$|\n|$3$|$6$|$n, m, k \\leq 8$|\n|$4$|$17$|$n, m, k \\leq 30$|\n|$5$|$16$|$n, m, k \\leq 100$|\n|$6$|$8$|$k=0$|\n|$7$|$11$|$k=1$|\n|$8$|$12$|$k \\leq 16$|\n|$9$|$9$|$k \\leq 100$|\n|$10$|$7$|无|$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[ROIR 2025] 旅行路线", "background": "翻译自 [ROIR 2025 D2T4](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day2.pdf)。", "description": "一群学生来到一座新城市游览，决定参观这里的名胜古迹。这座城市可以看作一个 $n \\times m$ 的矩形网格，其中某些格子上有景点。\n\n他们从格子 $(1, 1)$ 开始旅程，想要先到达格子 $(n, m)$，然后再返回起点。此外，城市中有 $k$ 个景点，位于格子 $(x_1, y_1), \\dots, (x_k, y_k)$，他们一定要全部参观到。\n\n![原题一个不明觉厉的配图](https://cdn.luogu.com.cn/upload/image_hosting/spktsj97.png)\n\n他们可以花费一分钟从格子 $(a, b)$ 移动到与之相邻（即满足 $|a - c| + |b - d| = 1$）的格子 $(c, d)$。显然，完成整个路线至少需要 $2n + 2m - 4$ 分钟。\n\n我们称一条路线为“有趣的”，如果它满足以下条件：\n\n- 完成该路线所需的时间恰好是 $2n + 2m - 4$ 分钟；\n- 路线中的每个格子最多经过一次；\n- 路线必须经过所有包含景点的格子。\n\n请帮助他们计算一共有多少条不同的有趣的路线。由于结果可能很大，只需要输出其对 $10^9 + 7$ 取模的结果。", "inputFormat": "第一行输入三个整数  $n$，$m$ 和 $k$（$3 \\leq n, m \\leq 10^6$，$0 \\leq k \\leq 2000$）。\n\n接下来 $k$ 行，每行包含两个整数 $x_i$ 和 $y_i$（$1 \\leq x_i \\leq n$，$1 \\leq y_i \\leq m$）。保证所有的 $(x_i, y_i)$ 都是不同的，即 $\\forall (i, j), x_i \\neq x_j \\vee y_i \\neq y_j$。", "outputFormat": "输出一个整数，表示有趣的路线的数量对 $10^9 + 7$ 取模的结果。", "hint": "下图展示了样例一中所有有趣的路线，其中带有星号的格子存在名胜古迹。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kzbt6reo.png)\n\n本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。\n\n|子任务|分数|特殊性质|\n|:-:|:-:|:-:|\n|$1$|$5$|$n=3$，$m, k \\leq 100$|\n|$2$|$9$|$n, m, k \\leq 5$|\n|$3$|$6$|$n, m, k \\leq 8$|\n|$4$|$17$|$n, m, k \\leq 30$|\n|$5$|$16$|$n, m, k \\leq 100$|\n|$6$|$8$|$k=0$|\n|$7$|$11$|$k=1$|\n|$8$|$12$|$k \\leq 16$|\n|$9$|$9$|$k \\leq 100$|\n|$10$|$7$|无|$", "locale": "zh-CN"}}}
{"pid": "P11705", "type": "P", "difficulty": 4, "samples": [["abababbab\npqp", "5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "交互题", "KMP 算法", "KOI（韩国）"], "title": "「KTSC 2020 R1」字符串查找", "background": "\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <bits/stdc++.h>\n\nint findP(char T[], char P[], int N, int M);\n  \n```\n\n题目译自 [2020년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2020/) T1「 [문자열 찾기](https://assets.ioikorea.kr/ioitst/2020/1/match/match_statement.pdf)」\n\n", "description": "对于由小写英文字母组成的两个字符串 $A$ 和 $B$，当满足以下条件时，称这两个字符串实际上相同：\n\n1. $A$ 和 $B$ 的长度相同。\n2. 对于所有可能的整数 $i$ 和 $j$，如果 $A$ 的第 $i$ 个字符和第 $j$ 个字符相同，则 $B$ 的第 $i$ 个字符和第 $j$ 个字符也相同。\n3. 对于所有可能的整数 $i$ 和 $j$，如果 $A$ 的第 $i$ 个字符和第 $j$ 个字符不同，则 $B$ 的第 $i$ 个字符和第 $j$ 个字符也不同。\n\n例如，$A=a b a$ 和 $B=p q p$ 是实际上相同的字符串。但是，$A=a b c a$ 和 $B=a b c b$ 不是实际上相同的字符串。\n\n编写一个程序，你将会得到字符串 $T$ 和 $P$，计算 $T$ 的连续子字符串中与 $P$ 实际上相同的子字符串的数量。\n\n例如，$T=a b a b a b b a b$ 和 $P=p q p$，$T$ 中从左到右的子字符串 $a b a, b a b, a b a, b a b, b a b$ 有 $5$ 个与 $P$ 实际上相同。\n\n你需要实现以下函数：\n\n`int findP(char T[], char P[], int N, int M);`\n\n- `T` 是长度为 $N+1$ 的字符数组。\n- `P` 是长度为 $M+1$ 的字符数组。\n- `T` 和 `P` 分别存储了长度为 $N$ 和 $M$ 的小写英文字母字符串。`T` 和 `P` 的最后一个位置存储了 `'\\0'`。\n- `findP` 函数返回 `T` 的连续子字符串中与 `P` 实际上相同的子字符串的数量。\n\n你需要提交一份代码，该代码中实现以下函数：\n\n`int findP(char T[], char P[], int N, int M);`\n\n该函数应按照上述描述工作。当然，你可以创建其他函数并在内部使用。提交的代码不应执行输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：字符串 $T$\n- 第 $2$ 行：字符串 $P$\n", "outputFormat": "示例评测程序将输出你的代码中 `findP()` 函数返回的值。", "hint": "### 样例说明 #1\n| 函数调用 | 返回值 |\n| :----------: | :----------: |\n| `findP(\"abababbab\", \"pqp\", 9, 3)\t` | `5` |\n\n### 数据范围\n对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 10^6$\n- $1 \\leq M \\leq N$\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$8$|$N=M$|\n|$2$|$5$|$1 \\leq N \\leq 100$|\n|$3$|$12$|$1 \\leq N \\leq 2,000$|\n|$4$|$75$|无附加限制|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KTSC 2020 R1」字符串查找", "background": "\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <bits/stdc++.h>\n\nint findP(char T[], char P[], int N, int M);\n  \n```\n\n题目译自 [2020년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2020/) T1「 [문자열 찾기](https://assets.ioikorea.kr/ioitst/2020/1/match/match_statement.pdf)」\n\n", "description": "对于由小写英文字母组成的两个字符串 $A$ 和 $B$，当满足以下条件时，称这两个字符串实际上相同：\n\n1. $A$ 和 $B$ 的长度相同。\n2. 对于所有可能的整数 $i$ 和 $j$，如果 $A$ 的第 $i$ 个字符和第 $j$ 个字符相同，则 $B$ 的第 $i$ 个字符和第 $j$ 个字符也相同。\n3. 对于所有可能的整数 $i$ 和 $j$，如果 $A$ 的第 $i$ 个字符和第 $j$ 个字符不同，则 $B$ 的第 $i$ 个字符和第 $j$ 个字符也不同。\n\n例如，$A=a b a$ 和 $B=p q p$ 是实际上相同的字符串。但是，$A=a b c a$ 和 $B=a b c b$ 不是实际上相同的字符串。\n\n编写一个程序，你将会得到字符串 $T$ 和 $P$，计算 $T$ 的连续子字符串中与 $P$ 实际上相同的子字符串的数量。\n\n例如，$T=a b a b a b b a b$ 和 $P=p q p$，$T$ 中从左到右的子字符串 $a b a, b a b, a b a, b a b, b a b$ 有 $5$ 个与 $P$ 实际上相同。\n\n你需要实现以下函数：\n\n`int findP(char T[], char P[], int N, int M);`\n\n- `T` 是长度为 $N+1$ 的字符数组。\n- `P` 是长度为 $M+1$ 的字符数组。\n- `T` 和 `P` 分别存储了长度为 $N$ 和 $M$ 的小写英文字母字符串。`T` 和 `P` 的最后一个位置存储了 `'\\0'`。\n- `findP` 函数返回 `T` 的连续子字符串中与 `P` 实际上相同的子字符串的数量。\n\n你需要提交一份代码，该代码中实现以下函数：\n\n`int findP(char T[], char P[], int N, int M);`\n\n该函数应按照上述描述工作。当然，你可以创建其他函数并在内部使用。提交的代码不应执行输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：字符串 $T$\n- 第 $2$ 行：字符串 $P$\n", "outputFormat": "示例评测程序将输出你的代码中 `findP()` 函数返回的值。", "hint": "### 样例说明 #1\n| 函数调用 | 返回值 |\n| :----------: | :----------: |\n| `findP(\"abababbab\", \"pqp\", 9, 3)\t` | `5` |\n\n### 数据范围\n对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 10^6$\n- $1 \\leq M \\leq N$\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$8$|$N=M$|\n|$2$|$5$|$1 \\leq N \\leq 100$|\n|$3$|$12$|$1 \\leq N \\leq 2,000$|\n|$4$|$75$|无附加限制|", "locale": "zh-CN"}}}
{"pid": "P11706", "type": "P", "difficulty": 7, "samples": [["3 5 2\n2 4\n0 2\n1 3\n2 1\n3 5\n", "1\n3\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "交互题", "KOI（韩国）"], "title": "「KTSC 2020 R1」穿越", "background": "\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nvoid init(int N, int M, std::vector<int> Y1, std::vector<int> Y2);\nlong long minimize(int A, int B);\n  \n```\n\n题目译自 [2020년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2020/) T2「 [뚫기](https://assets.ioikorea.kr/ioitst/2020/1/breakthru/breakthru_statement.pdf)」\n\n", "description": "在不久的将来，新加坡流行一种叫做「穿越」的游戏。游戏规则很简单：玩家需要控制一个楔形飞船从左到右穿过一个 $N \\times M$ 的隧道。隧道中有 $N$ 个绿色障碍物阻挡飞船前进。障碍物位于每个格子的左侧墙壁上，跨越多个格子的连续障碍物被视为一个障碍物。为了方便描述，飞船前进的方向为 $x$ 轴，与之垂直的方向为 $y$ 轴。在相同的 $x$ 坐标上只能有一个障碍物。\n\n例如，下图展示了一个 $11 \\times 6$ 的隧道，其中有 $11$ 个障碍物。最左边的障碍物从 $(0,2)$ 到 $(0,5)$，最右边的障碍物从 $(10,1)$ 到 $(10,5)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/eq3mr1t2.png)\n\n飞船在每个格子中可以进行两种移动之一。第一种移动是瞬移。瞬移是将飞船从当前格子移动到相同 $x$ 坐标的任意格子。无论移动到哪个格子，瞬移的费用始终为 $A$。例如，下图展示了飞船从 $(0,1)$ 瞬移到 $(0,5)$ 的情况，费用为 $A$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wtg3pdnf.png)\n\n飞船的第二种移动是前进，费用为 $0$。即使前进方向上有障碍物，飞船也可以穿过障碍物，但这会产生费用 $B$。例如，下图展示了飞船从 $(6,5)$ 前进到 $(7,5)$ 的情况，由于 $(7,5)$ 有障碍物，费用为 $B$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2hjgs26e.png)\n\n当飞船完全穿过隧道时，游戏结束。游戏得分是飞船穿过隧道时产生的总费用。显然，得分越低越好。游戏开始时，玩家可以选择飞船的初始 $y$ 坐标，且不产生费用。游戏结束时，飞船的 $y$ 坐标无关紧要。\n\n即使隧道的大小和障碍物的位置相同，费用 $A$ 和 $B$ 的变化也会影响游戏得分和飞船的最佳移动策略。你需要实现以下两个函数，利用给定的隧道大小和障碍物位置，在每次费用 $A$ 和 $B$ 变化时，计算可能的最低游戏得分。\n\n```\nvoid init(int N, int M, int Y1[], int Y2[]);\n```\n\n- 该函数在程序开始时调用一次。\n- 参数 $N$ 和 $M$ 表示隧道的大小 $N \\times M$。\n- 参数 $Y1$ 和 $Y2$ 是表示障碍物位置的数组，长度为 $N$。如果从 $(X, Y_1[X])$ 到 $(X, Y_2[X])$ 有一个障碍物，则 $Y1[X]$ 和 $Y2[X]$ 分别表示 $Y_1$ 和 $Y_2$。\n\n```\nlong long minimize(int A, int B);\n```\n\n- 参数 $A$ 是飞船瞬移一次的费用，$B$ 是飞船穿过一次障碍物的费用。该函数返回飞船穿过隧道所需的最小费用。\n\n你需要提交一个代码，该代码中实现以下函数：\n\n```\nvoid init(int N, int M, int Y1[], int Y2[]);\nlong long minimize(int A, int B);\n```\n\n这些函数应按照上述描述工作。当然，你可以创建其他函数并在内部使用。提交的代码不应执行输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,M\\,Q$（$N \\times M$：隧道的大小，$Q$：查询的数量）\n- 第 $2+i\\ (0 \\leq i \\leq N-1)$ 行：$Y_1\\,Y_2$（$x$ 坐标为 $i$ 的障碍物的 $y$ 坐标位置从 $Y_1$ 到 $Y_2$）\n- 第 $2+N+i\\ (0 \\leq i \\leq Q-1)$ 行：$A\\,B$（$A$：瞬移费用，$B$：穿过障碍物的费用）\n", "outputFormat": "示例评测程序对每个查询调用你的代码中的 `minimize()` 函数，并输出返回值。", "hint": "### 样例说明 #1\n| 函数调用 | 返回值 |\n| :----------: | :----------: |\n|`init(3, 5, {2, 0, 1}, {4, 2, 3})`||\t\n|`minimize(2, 1)`|$1$|\n|`minimize(3, 5)`|$3$|\n\n### 数据范围\n对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 10^4$\n- $1 \\leq M \\leq 10^{9}$\n- $1 \\leq Q \\leq 10^{6}$\n- $0 \\leq Y_1 \\leq Y_2 \\leq M-1$\n- $0 \\leq A, B \\leq 10^{9}$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 分值 | 子任务附加限制 |\n| :----------: | :----------: | :----------: |\n|$1$|$7$|$Q=1, N \\leq 3,000, M \\leq 3,000$|\n|$2$|$22$|$Q \\leq 50$|\n|$3$|$19$|$N \\leq 500$|\n|$4$|$21$|$N \\leq 2,500$|\n|$5$|$31$|无附加限制|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KTSC 2020 R1」穿越", "background": "\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nvoid init(int N, int M, std::vector<int> Y1, std::vector<int> Y2);\nlong long minimize(int A, int B);\n  \n```\n\n题目译自 [2020년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2020/) T2「 [뚫기](https://assets.ioikorea.kr/ioitst/2020/1/breakthru/breakthru_statement.pdf)」\n\n", "description": "在不久的将来，新加坡流行一种叫做「穿越」的游戏。游戏规则很简单：玩家需要控制一个楔形飞船从左到右穿过一个 $N \\times M$ 的隧道。隧道中有 $N$ 个绿色障碍物阻挡飞船前进。障碍物位于每个格子的左侧墙壁上，跨越多个格子的连续障碍物被视为一个障碍物。为了方便描述，飞船前进的方向为 $x$ 轴，与之垂直的方向为 $y$ 轴。在相同的 $x$ 坐标上只能有一个障碍物。\n\n例如，下图展示了一个 $11 \\times 6$ 的隧道，其中有 $11$ 个障碍物。最左边的障碍物从 $(0,2)$ 到 $(0,5)$，最右边的障碍物从 $(10,1)$ 到 $(10,5)$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/eq3mr1t2.png)\n\n飞船在每个格子中可以进行两种移动之一。第一种移动是瞬移。瞬移是将飞船从当前格子移动到相同 $x$ 坐标的任意格子。无论移动到哪个格子，瞬移的费用始终为 $A$。例如，下图展示了飞船从 $(0,1)$ 瞬移到 $(0,5)$ 的情况，费用为 $A$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wtg3pdnf.png)\n\n飞船的第二种移动是前进，费用为 $0$。即使前进方向上有障碍物，飞船也可以穿过障碍物，但这会产生费用 $B$。例如，下图展示了飞船从 $(6,5)$ 前进到 $(7,5)$ 的情况，由于 $(7,5)$ 有障碍物，费用为 $B$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2hjgs26e.png)\n\n当飞船完全穿过隧道时，游戏结束。游戏得分是飞船穿过隧道时产生的总费用。显然，得分越低越好。游戏开始时，玩家可以选择飞船的初始 $y$ 坐标，且不产生费用。游戏结束时，飞船的 $y$ 坐标无关紧要。\n\n即使隧道的大小和障碍物的位置相同，费用 $A$ 和 $B$ 的变化也会影响游戏得分和飞船的最佳移动策略。你需要实现以下两个函数，利用给定的隧道大小和障碍物位置，在每次费用 $A$ 和 $B$ 变化时，计算可能的最低游戏得分。\n\n```\nvoid init(int N, int M, int Y1[], int Y2[]);\n```\n\n- 该函数在程序开始时调用一次。\n- 参数 $N$ 和 $M$ 表示隧道的大小 $N \\times M$。\n- 参数 $Y1$ 和 $Y2$ 是表示障碍物位置的数组，长度为 $N$。如果从 $(X, Y_1[X])$ 到 $(X, Y_2[X])$ 有一个障碍物，则 $Y1[X]$ 和 $Y2[X]$ 分别表示 $Y_1$ 和 $Y_2$。\n\n```\nlong long minimize(int A, int B);\n```\n\n- 参数 $A$ 是飞船瞬移一次的费用，$B$ 是飞船穿过一次障碍物的费用。该函数返回飞船穿过隧道所需的最小费用。\n\n你需要提交一个代码，该代码中实现以下函数：\n\n```\nvoid init(int N, int M, int Y1[], int Y2[]);\nlong long minimize(int A, int B);\n```\n\n这些函数应按照上述描述工作。当然，你可以创建其他函数并在内部使用。提交的代码不应执行输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,M\\,Q$（$N \\times M$：隧道的大小，$Q$：查询的数量）\n- 第 $2+i\\ (0 \\leq i \\leq N-1)$ 行：$Y_1\\,Y_2$（$x$ 坐标为 $i$ 的障碍物的 $y$ 坐标位置从 $Y_1$ 到 $Y_2$）\n- 第 $2+N+i\\ (0 \\leq i \\leq Q-1)$ 行：$A\\,B$（$A$：瞬移费用，$B$：穿过障碍物的费用）\n", "outputFormat": "示例评测程序对每个查询调用你的代码中的 `minimize()` 函数，并输出返回值。", "hint": "### 样例说明 #1\n| 函数调用 | 返回值 |\n| :----------: | :----------: |\n|`init(3, 5, {2, 0, 1}, {4, 2, 3})`||\t\n|`minimize(2, 1)`|$1$|\n|`minimize(3, 5)`|$3$|\n\n### 数据范围\n对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 10^4$\n- $1 \\leq M \\leq 10^{9}$\n- $1 \\leq Q \\leq 10^{6}$\n- $0 \\leq Y_1 \\leq Y_2 \\leq M-1$\n- $0 \\leq A, B \\leq 10^{9}$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 分值 | 子任务附加限制 |\n| :----------: | :----------: | :----------: |\n|$1$|$7$|$Q=1, N \\leq 3,000, M \\leq 3,000$|\n|$2$|$22$|$Q \\leq 50$|\n|$3$|$19$|$N \\leq 500$|\n|$4$|$21$|$N \\leq 2,500$|\n|$5$|$31$|无附加限制|", "locale": "zh-CN"}}}
{"pid": "P11707", "type": "P", "difficulty": 6, "samples": [["4\n1 2\n2 2\n2 1\n1 1\n", "2"], ["4\n1 2\n3 3\n4 1\n2 3\n", "6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "交互题", "KOI（韩国）"], "title": "「KTSC 2020 R1」捷径", "background": "\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include<vector>\n\nlong long shortcut(int N, std::vector<long long> X, std::vector<long long> Y);\n  \n```\n\n题目译自 [2020년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2020/) T3「 [지름길](https://assets.ioikorea.kr/ioitst/2020/1/shortcut/shortcut_statement.pdf)」\n\n", "description": "有 $N$ 个城市分布在平面上的不同位置。这些城市用 $1$ 到 $N$ 的整数表示。\n\n城市 $i$ 和城市 $i+1$ 之间有一条道路，记为 $R_{i} (i=1, \\ldots, N-1)$。因此，总共有 $N-1$ 条道路。对于每个 $i=1, \\ldots, N-1$，城市 $i$ 的坐标为 $\\left(x_{i}, y_{i}\\right)$，道路 $R_{i}$ 的长度为 $\\left|x_{i}-x_{i+1}\\right|+\\left|y_{i}-y_{i+1}\\right|$。\n\n城市 $i$ 和 $j$ 之间的路径 $P$ 是从 $i$ 到 $j$ 经过的道路集合。路径 $P$ 的长度是 $P$ 中所有道路长度的总和。我们对城市的直径感兴趣。直径是所有城市之间最短路径长度的最大值。当然，上述城市的直径等于城市 $1$ 和城市 $N$ 之间路径的长度。\n\n我们计划在上述城市中选择一对城市，在它们之间新建一条道路。记这条新道路为 $R_{\\text{new}}$，如果 $R_{\\text{new}}$ 连接城市 $a$ 和 $b$，则 $R_{\\text{new}}$ 的长度为 $\\left|x_{a}-x_{b}\\right|+\\left|y_{a}-y_{b}\\right|$。问题是如何选择 $R_{\\text{new}}$ 使得城市的直径最小。\n\n给定 $N$ 个城市的位置，编写一个程序，选择 $R_{\\text{new}}$ 使城市的直径最小，并输出最小的直径值。\n\n例如，下图中有 $4$ 个城市和连接城市之间的 $3$ 条道路（实线）。可以新建的道路有 $3$ 条（$1$ 和 $4$ 之间，$1$ 和 $3$ 之间，$4$ 和 $2$ 之间）。在这些候选中，如图所示，在 $4$ 和 $2$ 之间新建一条道路（虚线），城市的直径为 $6$，这是最小值。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jsaygnsq.png)\n\n你需要为代码实现以下函数，并使用该函数提交答案。\n\n`long long shortcut(int N, long long X[], long long Y[]);`\n\n- 参数 `N` 是城市的数量，`X[0..N-1]` 和 `Y[0..N-1]` 分别表示每个城市的 $x$ 坐标和 $y$ 坐标。`X[]` 和 `Y[]` 是大小为 $N$ 的数组，`X[i]` 和 `Y[i]` 分别表示城市 $i+1$ 的 $x$ 坐标和 $y$ 坐标。你需要使用该函数提交结果。返回值是新建道路后城市的最小直径。\n\n你需要提交一份代码，该代码中实现以下函数：\n\n`long long shortcut(int N, long long X[], long long Y[]);`\n\n该函数应按照上述描述工作。当然，你可以创建其他函数并在内部使用。提交的代码不应执行输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n第 $1$ 行：$N$，$N$ 表示城市的数量  \n第 $2 \\sim(N+1)$ 行：第 $i$ 行包含两个整数 $x$ 和 $y$，表示城市 $i-1$ 的坐标 $(x, y)$\n", "outputFormat": "示例评测程序输出新建道路后城市的最小直径。", "hint": "对于所有输入数据，满足：\n\n- $3 \\leq N \\leq 2.5\\cdot 10^5$\n- $-10^{9} \\leq x, y \\leq 10^{9}$\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$4$|$N \\leq 40$|\n|$2$|$6$|$N \\leq 100$|\n|$3$|$12$|$N \\leq 300$|\n|$4$|$25$|$N \\leq 2,000$|\n|$5$|$40$|$N \\leq 50,000$|\n|$6$|$13$|无附加限制|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KTSC 2020 R1」捷径", "background": "\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include<vector>\n\nlong long shortcut(int N, std::vector<long long> X, std::vector<long long> Y);\n  \n```\n\n题目译自 [2020년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2020/) T3「 [지름길](https://assets.ioikorea.kr/ioitst/2020/1/shortcut/shortcut_statement.pdf)」\n\n", "description": "有 $N$ 个城市分布在平面上的不同位置。这些城市用 $1$ 到 $N$ 的整数表示。\n\n城市 $i$ 和城市 $i+1$ 之间有一条道路，记为 $R_{i} (i=1, \\ldots, N-1)$。因此，总共有 $N-1$ 条道路。对于每个 $i=1, \\ldots, N-1$，城市 $i$ 的坐标为 $\\left(x_{i}, y_{i}\\right)$，道路 $R_{i}$ 的长度为 $\\left|x_{i}-x_{i+1}\\right|+\\left|y_{i}-y_{i+1}\\right|$。\n\n城市 $i$ 和 $j$ 之间的路径 $P$ 是从 $i$ 到 $j$ 经过的道路集合。路径 $P$ 的长度是 $P$ 中所有道路长度的总和。我们对城市的直径感兴趣。直径是所有城市之间最短路径长度的最大值。当然，上述城市的直径等于城市 $1$ 和城市 $N$ 之间路径的长度。\n\n我们计划在上述城市中选择一对城市，在它们之间新建一条道路。记这条新道路为 $R_{\\text{new}}$，如果 $R_{\\text{new}}$ 连接城市 $a$ 和 $b$，则 $R_{\\text{new}}$ 的长度为 $\\left|x_{a}-x_{b}\\right|+\\left|y_{a}-y_{b}\\right|$。问题是如何选择 $R_{\\text{new}}$ 使得城市的直径最小。\n\n给定 $N$ 个城市的位置，编写一个程序，选择 $R_{\\text{new}}$ 使城市的直径最小，并输出最小的直径值。\n\n例如，下图中有 $4$ 个城市和连接城市之间的 $3$ 条道路（实线）。可以新建的道路有 $3$ 条（$1$ 和 $4$ 之间，$1$ 和 $3$ 之间，$4$ 和 $2$ 之间）。在这些候选中，如图所示，在 $4$ 和 $2$ 之间新建一条道路（虚线），城市的直径为 $6$，这是最小值。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jsaygnsq.png)\n\n你需要为代码实现以下函数，并使用该函数提交答案。\n\n`long long shortcut(int N, long long X[], long long Y[]);`\n\n- 参数 `N` 是城市的数量，`X[0..N-1]` 和 `Y[0..N-1]` 分别表示每个城市的 $x$ 坐标和 $y$ 坐标。`X[]` 和 `Y[]` 是大小为 $N$ 的数组，`X[i]` 和 `Y[i]` 分别表示城市 $i+1$ 的 $x$ 坐标和 $y$ 坐标。你需要使用该函数提交结果。返回值是新建道路后城市的最小直径。\n\n你需要提交一份代码，该代码中实现以下函数：\n\n`long long shortcut(int N, long long X[], long long Y[]);`\n\n该函数应按照上述描述工作。当然，你可以创建其他函数并在内部使用。提交的代码不应执行输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n第 $1$ 行：$N$，$N$ 表示城市的数量  \n第 $2 \\sim(N+1)$ 行：第 $i$ 行包含两个整数 $x$ 和 $y$，表示城市 $i-1$ 的坐标 $(x, y)$\n", "outputFormat": "示例评测程序输出新建道路后城市的最小直径。", "hint": "对于所有输入数据，满足：\n\n- $3 \\leq N \\leq 2.5\\cdot 10^5$\n- $-10^{9} \\leq x, y \\leq 10^{9}$\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$4$|$N \\leq 40$|\n|$2$|$6$|$N \\leq 100$|\n|$3$|$12$|$N \\leq 300$|\n|$4$|$25$|$N \\leq 2,000$|\n|$5$|$40$|$N \\leq 50,000$|\n|$6$|$13$|无附加限制|", "locale": "zh-CN"}}}
{"pid": "P11708", "type": "P", "difficulty": 5, "samples": [["1 1\n.\n", "1"], ["2 3\n...\n...\n", "1\n"], ["3 3\n...\n..#\n.##\n", "1"], ["3 3\n.##\n#..\n#..\n", "0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "交互题", "KOI（韩国）"], "title": "「KTSC 2020 R1」涂色", "background": "\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include<vector>\n\nlong long shortcut(int N, std::vector<long long> X, std::vector<long long> Y);\n  \n```\n\n题目译自 [2020년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2020/) T4「 [칠하기](https://assets.ioikorea.kr/ioitst/2020/1/paint/paint_statement.pdf)」\n\n", "description": "有一个由 $N \\times M$ 个格子组成的网格。网格中的一些格子是障碍物，不能通过，其他格子是可以通过的。现在我们要按照以下规则给可以通过的格子涂色。\n\n1. 从 $N \\times M$ 个格子中的一个可以通过的格子开始，作为当前格子。起始的当前格子可以是任何一个可以通过的格子。\n2. 从当前格子选择一个方向（上/下/左/右），一直移动到网格的边界或遇到障碍物为止。注意，中途不能停下。\n3. 如果移动过程中是水平方向（左或右），则所有水平移动经过的格子都涂成黄色。开始移动的格子也涂成黄色。如果移动过程中是垂直方向（上或下），则所有垂直移动经过的格子都涂成蓝色。开始移动的格子也涂成蓝色。（如果移动方向上立即遇到障碍物，无法移动，则开始的格子也会被涂色。）\n4. 如果所有可以通过的格子至少被涂成一次黄色，并且至少被涂成一次蓝色，则涂色成功并结束涂色。\n5. 如果没有达到上述条件，则从停止的格子，即最后一个可以移动的格子开始，重复步骤 2-4。如果无论如何重复这些步骤，都无法使所有可以通过的格子至少被涂成一次黄色，并且至少被涂成一次蓝色，则失败。\n\n例如，考虑以下例子。在一个 $2 \\times 3$ 的网格中，所有格子都是可以通过的。如果从左上角的 $(0,0)$ 开始，如左图和中图所示，无论如何移动，都无法使所有可以通过的格子至少被涂成一次蓝色，并且至少被涂成一次黄色。相反，如果从 $(0,1)$ 开始，如右图所示移动，则可以使所有可以通过的格子至少被涂成一次蓝色，并且至少被涂成一次黄色。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dutuf4ot.png)\n\n给定网格的大小和布局，我们需要判断是否可以使所有可以通过的格子被涂成蓝色和黄色。你需要实现以下函数来解决这个问题：\n\n`int yellowblue(int N, int M, vector<string> V);`\n\n- 该函数只会被调用一次。\n- 参数 $N$ 和 $M$ 表示网格的大小。\n- 参数 $V$ 是表示网格状态的字符串数组，长度为 $N$。$V$ 的每个字符串长度为 $M$。如果网格的 $(i, j)$ 格子是可以通过的，则 $V[i]$ 的第 $j$ 个字符为 `.`；如果是障碍物，则为 `#`。\n- 如果可以使所有可以通过的格子至少被涂成一次蓝色，并且至少被涂成一次黄色，则返回 `1`；否则返回 `0`。\n\n你需要提交一份代码，该代码中实现以下函数：\n\n`int yellowblue(int N, int M, vector<string> V);`\n\n该函数应按照上述描述工作。当然，你可以创建其他函数并在内部使用。提交的代码不应执行输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,M$（$N$：网格的行数，$M$：网格的列数）\n- 第 $2+i (0 \\leq i \\leq N-1)$ 行：由 `.` 和 `#` 组成的长度为 $M$ 的字符串。如果字符串的第 $j$ 个字符为 `.`，则表示网格的 $(i, j-1)$ 格子是可以通过的；如果为 `#`，则表示是障碍物。\n", "outputFormat": "示例评测程序将输出你的代码中 `yellowblue()` 函数返回的值。", "hint": "对于所有输入数据，满足：\n\n- $1 \\leq N, M \\leq 1,000$\n- 整个网格中至少有一个可以通过的格子。\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$30$|$N, M \\leq 50$|\n|$2$|$70$|无附加限制|", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KTSC 2020 R1」涂色", "background": "\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include<vector>\n\nlong long shortcut(int N, std::vector<long long> X, std::vector<long long> Y);\n  \n```\n\n题目译自 [2020년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2020/) T4「 [칠하기](https://assets.ioikorea.kr/ioitst/2020/1/paint/paint_statement.pdf)」\n\n", "description": "有一个由 $N \\times M$ 个格子组成的网格。网格中的一些格子是障碍物，不能通过，其他格子是可以通过的。现在我们要按照以下规则给可以通过的格子涂色。\n\n1. 从 $N \\times M$ 个格子中的一个可以通过的格子开始，作为当前格子。起始的当前格子可以是任何一个可以通过的格子。\n2. 从当前格子选择一个方向（上/下/左/右），一直移动到网格的边界或遇到障碍物为止。注意，中途不能停下。\n3. 如果移动过程中是水平方向（左或右），则所有水平移动经过的格子都涂成黄色。开始移动的格子也涂成黄色。如果移动过程中是垂直方向（上或下），则所有垂直移动经过的格子都涂成蓝色。开始移动的格子也涂成蓝色。（如果移动方向上立即遇到障碍物，无法移动，则开始的格子也会被涂色。）\n4. 如果所有可以通过的格子至少被涂成一次黄色，并且至少被涂成一次蓝色，则涂色成功并结束涂色。\n5. 如果没有达到上述条件，则从停止的格子，即最后一个可以移动的格子开始，重复步骤 2-4。如果无论如何重复这些步骤，都无法使所有可以通过的格子至少被涂成一次黄色，并且至少被涂成一次蓝色，则失败。\n\n例如，考虑以下例子。在一个 $2 \\times 3$ 的网格中，所有格子都是可以通过的。如果从左上角的 $(0,0)$ 开始，如左图和中图所示，无论如何移动，都无法使所有可以通过的格子至少被涂成一次蓝色，并且至少被涂成一次黄色。相反，如果从 $(0,1)$ 开始，如右图所示移动，则可以使所有可以通过的格子至少被涂成一次蓝色，并且至少被涂成一次黄色。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dutuf4ot.png)\n\n给定网格的大小和布局，我们需要判断是否可以使所有可以通过的格子被涂成蓝色和黄色。你需要实现以下函数来解决这个问题：\n\n`int yellowblue(int N, int M, vector<string> V);`\n\n- 该函数只会被调用一次。\n- 参数 $N$ 和 $M$ 表示网格的大小。\n- 参数 $V$ 是表示网格状态的字符串数组，长度为 $N$。$V$ 的每个字符串长度为 $M$。如果网格的 $(i, j)$ 格子是可以通过的，则 $V[i]$ 的第 $j$ 个字符为 `.`；如果是障碍物，则为 `#`。\n- 如果可以使所有可以通过的格子至少被涂成一次蓝色，并且至少被涂成一次黄色，则返回 `1`；否则返回 `0`。\n\n你需要提交一份代码，该代码中实现以下函数：\n\n`int yellowblue(int N, int M, vector<string> V);`\n\n该函数应按照上述描述工作。当然，你可以创建其他函数并在内部使用。提交的代码不应执行输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,M$（$N$：网格的行数，$M$：网格的列数）\n- 第 $2+i (0 \\leq i \\leq N-1)$ 行：由 `.` 和 `#` 组成的长度为 $M$ 的字符串。如果字符串的第 $j$ 个字符为 `.`，则表示网格的 $(i, j-1)$ 格子是可以通过的；如果为 `#`，则表示是障碍物。\n", "outputFormat": "示例评测程序将输出你的代码中 `yellowblue()` 函数返回的值。", "hint": "对于所有输入数据，满足：\n\n- $1 \\leq N, M \\leq 1,000$\n- 整个网格中至少有一个可以通过的格子。\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$30$|$N, M \\leq 50$|\n|$2$|$70$|无附加限制|", "locale": "zh-CN"}}}
{"pid": "P11709", "type": "P", "difficulty": 4, "samples": [["7 4 20\n1 3\n0 2\n2 6\n3 8\n3 1\n2 0\n1 8", "4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "交互题", "KOI（韩国）"], "title": "「KTSC 2020 R2」魔法转盘", "background": "\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nlong long findMinClicks(int M, int R, std::vector <std::pair<int, int> > P);\n  \n```\n\n题目译自 [2020년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2020/) T1「 [마법의 다이얼](https://assets.ioikorea.kr/ioitst/2020/1/dial/dial_statement.pdf)」\n\n", "description": "在持续的算法学习中感到疲惫的京根，想去另一个世界休息几天。有一天，他听说了一个通往另一个世界的门的位置，于是他去了那里。那里有一扇通往另一个世界的门，但门被锁住了，门上有一个巨大的转盘锁。\n\n这个锁由上下排列的 $M$ 个转盘组成。每个转盘有 $R$ 个格子，可以左右旋转到不同的格子。每个格子上可能有一个点，也可能没有点。每个转盘至少有一个点。通过旋转转盘，使得在某个位置上所有格子都垂直对齐有点，门就会打开。每个转盘可以单独旋转。由于转盘非常重，旋转起来很费力，所以希望旋转的总格子数最少。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zwu5rgb4.png)\n\n上图展示了一个转盘的例子。最佳方法之一是：将第一个转盘向左旋转一格，第二个转盘向左旋转两格，第三个转盘向右旋转一格，第四个转盘不旋转，总共旋转 $4$ 格。\n\n给定转盘的大小和点的位置，编写一个程序，计算最少需要旋转多少格才能打开门。点的位置由转盘编号和格子编号的坐标表示。最上面的转盘是 $0$ 号转盘，向下编号依次增加，最下面的转盘是 $M-1$ 号转盘。为了确定格子编号，任意相同位置的（即垂直对齐的）格子编号为 $0$，向右编号依次增加。$0$ 号格子的左边是 $R-1$ 号格子。给定的点的坐标不会重复。\n\n你需要实现以下函数：\n\n`long long findMinClicks(int M, int R, vector< pair<int, int> > P);`\n\n- 参数 $M$ 是转盘的数量。\n- 参数 $R$ 是每个转盘的格子数。\n- 参数 $P$ 是一个包含 $N$ 个整数对的数组。每个整数对的第一个数是转盘编号，第二个数是格子编号。给定的点的坐标不会重复。\n- 函数 `findMinClicks()` 返回打开门所需的最少旋转格子数。\n\n该函数应按照上述描述工作。当然，你可以创建其他函数并在内部使用。提交的代码不应执行输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：整数 $N\\,M\\,R$\n- 第 $2 \\sim N+1$ 行：整数 $D_{i}\\,C_{i}$，其中 $(D_{i}, C_{i})$ 是第 $i$ 个点的坐标。", "outputFormat": "示例评测程序将输出你的代码中 `findMinClicks()` 函数返回的值。", "hint": "对于所有输入数据，满足：\n\n- $1 \\leq R \\leq 10^{9}$\n- $1 \\leq N \\leq \\min(MR, 5\\cdot 10^5)$\n- $1 \\leq M \\leq N$\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$10$|$1 \\leq N \\leq 5000,1 \\leq R \\leq 5000$|\n|$2$|$15$|$1 \\leq M \\leq 5000,1 \\leq R \\leq 5000$|\n|$3$|$16$|$1 \\leq N \\leq 5000$|\n|$4$|$109$|无附加限制|\n\n本题满分为 $150$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KTSC 2020 R2」魔法转盘", "background": "\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nlong long findMinClicks(int M, int R, std::vector <std::pair<int, int> > P);\n  \n```\n\n题目译自 [2020년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2020/) T1「 [마법의 다이얼](https://assets.ioikorea.kr/ioitst/2020/1/dial/dial_statement.pdf)」\n\n", "description": "在持续的算法学习中感到疲惫的京根，想去另一个世界休息几天。有一天，他听说了一个通往另一个世界的门的位置，于是他去了那里。那里有一扇通往另一个世界的门，但门被锁住了，门上有一个巨大的转盘锁。\n\n这个锁由上下排列的 $M$ 个转盘组成。每个转盘有 $R$ 个格子，可以左右旋转到不同的格子。每个格子上可能有一个点，也可能没有点。每个转盘至少有一个点。通过旋转转盘，使得在某个位置上所有格子都垂直对齐有点，门就会打开。每个转盘可以单独旋转。由于转盘非常重，旋转起来很费力，所以希望旋转的总格子数最少。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zwu5rgb4.png)\n\n上图展示了一个转盘的例子。最佳方法之一是：将第一个转盘向左旋转一格，第二个转盘向左旋转两格，第三个转盘向右旋转一格，第四个转盘不旋转，总共旋转 $4$ 格。\n\n给定转盘的大小和点的位置，编写一个程序，计算最少需要旋转多少格才能打开门。点的位置由转盘编号和格子编号的坐标表示。最上面的转盘是 $0$ 号转盘，向下编号依次增加，最下面的转盘是 $M-1$ 号转盘。为了确定格子编号，任意相同位置的（即垂直对齐的）格子编号为 $0$，向右编号依次增加。$0$ 号格子的左边是 $R-1$ 号格子。给定的点的坐标不会重复。\n\n你需要实现以下函数：\n\n`long long findMinClicks(int M, int R, vector< pair<int, int> > P);`\n\n- 参数 $M$ 是转盘的数量。\n- 参数 $R$ 是每个转盘的格子数。\n- 参数 $P$ 是一个包含 $N$ 个整数对的数组。每个整数对的第一个数是转盘编号，第二个数是格子编号。给定的点的坐标不会重复。\n- 函数 `findMinClicks()` 返回打开门所需的最少旋转格子数。\n\n该函数应按照上述描述工作。当然，你可以创建其他函数并在内部使用。提交的代码不应执行输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：整数 $N\\,M\\,R$\n- 第 $2 \\sim N+1$ 行：整数 $D_{i}\\,C_{i}$，其中 $(D_{i}, C_{i})$ 是第 $i$ 个点的坐标。", "outputFormat": "示例评测程序将输出你的代码中 `findMinClicks()` 函数返回的值。", "hint": "对于所有输入数据，满足：\n\n- $1 \\leq R \\leq 10^{9}$\n- $1 \\leq N \\leq \\min(MR, 5\\cdot 10^5)$\n- $1 \\leq M \\leq N$\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$10$|$1 \\leq N \\leq 5000,1 \\leq R \\leq 5000$|\n|$2$|$15$|$1 \\leq M \\leq 5000,1 \\leq R \\leq 5000$|\n|$3$|$16$|$1 \\leq N \\leq 5000$|\n|$4$|$109$|无附加限制|\n\n本题满分为 $150$ 分。", "locale": "zh-CN"}}}
{"pid": "P11710", "type": "P", "difficulty": 6, "samples": [["6\n1 2 3 2 3 1", "2\n0 1 4\n2 3 5"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "交互题", "Special Judge", "KOI（韩国）"], "title": "「KTSC 2020 R2」一二三", "background": "\n\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nvoid maximize(std::vector<int> A);\nvoid answer(int i, int j, int k);\n  \n```\n\n题目译自 [2020년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2020/) T2「 [하나 둘 셋](https://assets.ioikorea.kr/ioitst/2020/1/onetwothree/onetwothree_statement.pdf)」\n\n", "description": "有一个长度为 $N$ 的数组 $A$，这个数组只包含数字 $1$、$2$ 和 $3$。我们需要在这个数组中找到尽可能多的满足以下条件的三元组 $(i, j, k)$：\n\n对于数组中的三个索引 $i, j, k \\quad(0 \\leq i < j < k < N)$，要么 $A[i]=1, A[j]=2, A[k]=3$，要么 $A[i]=3, A[j]=2, A[k]=1$。并且，每个索引最多只能出现在一个三元组中。\n\n例如，给定 $A=\\{1,2,3,2,3,1\\}$，满足条件的三元组是 $(0,1,4)$ 和 $(2,3,5)$。$(A[0]=1, A[1]=2, A[4]=3)$ 和 $(A[2]=3, A[3]=2, A[5]=1)$。\n\n编写一个程序，在给定数组 $A$ 的情况下，找到尽可能多的满足条件的三元组 $(i, j, k)$。\n\n你需要实现以下函数：\n\n`void maximize(vector<int> A);`\n\n- 参数 `A` 是一个长度为 `N` 的 `vector`，只包含数字 $1$、$2$ 和 $3$。函数 `maximize` 需要在数组 `A` 中找到尽可能多的满足条件的三元组 $(i, j, k)$，并且对于找到的每个三元组 $(i, j, k)$，调用 `grader` 的 `answer(int i, int j, int k)` 函数一次。如果有多种方法找到最大数量的三元组，可以任选一种。三元组的调用顺序无关紧要。例如，对于问题中的示例，可以先调用 `answer(0,1,4)`，再调用 `answer(2,3,5)`，也可以先调用 `answer(2,3,5)`，再调用 `answer(0,1,4)`。", "inputFormat": "评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2$ 行：$N$ 个整数，每个整数为 $1$、$2$ 或 $3$", "outputFormat": "评测程序将首先输出 `maximize` 函数调用 `answer(i, j, k)` 函数的次数，然后对于每次 `answer(i, j, k)` 调用，输出 $i, j, k$ 的值。", "hint": "### 样例说明 #1\n以下是样例中函数调用及其结果的顺序：\n\n| 函数调用 | 返回值 |\n| :----------: | :----------: |\n|`maximize({1, 2, 3, 2, 3, 1})`|`2`|\n|`answer(0,1,4)`|`0 1 4`|\n|`answer(2,3,5)`|`2 3 5`|\n\n### 数据范围\n对于所有输入数据，满足：\n\n- $3 \\leq N \\leq 15,000$\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$14$|$N \\leq 18$|\n|$2$|$29$|$N \\leq 100$|\n|$3$|$53$|$N \\leq 3,000$|\n|$4$|$54$|无附加限制|\n\n本题满分为 $150$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KTSC 2020 R2」一二三", "background": "\n\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nvoid maximize(std::vector<int> A);\nvoid answer(int i, int j, int k);\n  \n```\n\n题目译自 [2020년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2020/) T2「 [하나 둘 셋](https://assets.ioikorea.kr/ioitst/2020/1/onetwothree/onetwothree_statement.pdf)」\n\n", "description": "有一个长度为 $N$ 的数组 $A$，这个数组只包含数字 $1$、$2$ 和 $3$。我们需要在这个数组中找到尽可能多的满足以下条件的三元组 $(i, j, k)$：\n\n对于数组中的三个索引 $i, j, k \\quad(0 \\leq i < j < k < N)$，要么 $A[i]=1, A[j]=2, A[k]=3$，要么 $A[i]=3, A[j]=2, A[k]=1$。并且，每个索引最多只能出现在一个三元组中。\n\n例如，给定 $A=\\{1,2,3,2,3,1\\}$，满足条件的三元组是 $(0,1,4)$ 和 $(2,3,5)$。$(A[0]=1, A[1]=2, A[4]=3)$ 和 $(A[2]=3, A[3]=2, A[5]=1)$。\n\n编写一个程序，在给定数组 $A$ 的情况下，找到尽可能多的满足条件的三元组 $(i, j, k)$。\n\n你需要实现以下函数：\n\n`void maximize(vector<int> A);`\n\n- 参数 `A` 是一个长度为 `N` 的 `vector`，只包含数字 $1$、$2$ 和 $3$。函数 `maximize` 需要在数组 `A` 中找到尽可能多的满足条件的三元组 $(i, j, k)$，并且对于找到的每个三元组 $(i, j, k)$，调用 `grader` 的 `answer(int i, int j, int k)` 函数一次。如果有多种方法找到最大数量的三元组，可以任选一种。三元组的调用顺序无关紧要。例如，对于问题中的示例，可以先调用 `answer(0,1,4)`，再调用 `answer(2,3,5)`，也可以先调用 `answer(2,3,5)`，再调用 `answer(0,1,4)`。", "inputFormat": "评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2$ 行：$N$ 个整数，每个整数为 $1$、$2$ 或 $3$", "outputFormat": "评测程序将首先输出 `maximize` 函数调用 `answer(i, j, k)` 函数的次数，然后对于每次 `answer(i, j, k)` 调用，输出 $i, j, k$ 的值。", "hint": "### 样例说明 #1\n以下是样例中函数调用及其结果的顺序：\n\n| 函数调用 | 返回值 |\n| :----------: | :----------: |\n|`maximize({1, 2, 3, 2, 3, 1})`|`2`|\n|`answer(0,1,4)`|`0 1 4`|\n|`answer(2,3,5)`|`2 3 5`|\n\n### 数据范围\n对于所有输入数据，满足：\n\n- $3 \\leq N \\leq 15,000$\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$14$|$N \\leq 18$|\n|$2$|$29$|$N \\leq 100$|\n|$3$|$53$|$N \\leq 3,000$|\n|$4$|$54$|无附加限制|\n\n本题满分为 $150$ 分。", "locale": "zh-CN"}}}
{"pid": "P11711", "type": "P", "difficulty": 6, "samples": [["11 2\n1 2\n3 2\n4 3\n4 5\n6 5\n8 4\n7 8\n8 9\n10 9\n11 10\n3 5 7 4\n3 6 7 10", "3\n7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "交互题", "KOI（韩国）"], "title": "「KTSC 2020 R2」列车的移动", "background": "\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nvoid init(int N, std::vector<int> X, std::vector<int> Y);\n\nlong long train(std::vector<int> Z);\n  \n```\n\n题目译自 [2020년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2020/) T4「 [열차의 이동](https://assets.ioikorea.kr/ioitst/2020/1/train/train_statement.pdf)」\n\n", "description": "调车场是连接或分离列车车厢并进行维护和保养的地方。调车场中有可以移动列车的轨道。我们将用图来表示轨道上列车车厢的位置。图中的每条边表示列车的一个车厢所在的位置，因此列车在图中表示为一条路径。在这条路径上，所有的顶点和边都必须不同。特别地，问题中给出的图总是树形结构。\n\n列车可以沿着轨道移动。列车的移动是分阶段进行的，每个阶段列车的一端车厢移动到相邻的另一条边上。具体来说，对于表示列车的路径 $P$，一次移动的结果是将 $P$ 的一端顶点和相邻的 $P$ 之外的边和顶点添加到 $P$ 中，并将另一端的顶点和边从 $P$ 中移除（见图 1）。注意，每个阶段路径的长度保持不变。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n0s1u7qn.png)\n\n给定初始和最终列车位置的长度为 $m$ 的路径 $P$ 和 $Q$。路径的长度是路径中包含的边的数量。这里，路径 $P$ 和 $Q$ 之间没有任何共享的边。换句话说，$P$ 和 $Q$ 没有同时经过的边。我们需要将路径 $P$ 移动到最终成为路径 $Q$。此时，需要找到最少的移动步数。\n\n给定包含 $n$ 个顶点的树 $T$ 以及初始和最终列车位置的长度为 $m$ 的路径 $P$ 和 $Q$，编写一个程序，检查是否可以将 $P$ 移动到 $Q$，如果可以，输出最少的移动步数。\n\n例如，在图 2 中，给定长度为 $2$ 的两个路径 $P$ 和 $Q$，它们没有任何共享的边。可以看到，从路径 $P$ 移动到路径 $Q$ 需要 $5$ 步，这是最少的移动步数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fqetn4o5.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d7xab533.png)\n\n你需要为管理员实现以下两个函数：\n\n`void init(int n, vector<int> X, vector<int> Y);`\n\n- 该函数在程序开始时调用一次。树的顶点数量为 $n$，顶点编号从 $1$ 到 $n$。`X` 和 `Y` 是大小为 $n-1$ 的 `vector`，表示树的每条边为 $(X[i], Y[i])$。\n\n`long long train(vector<int> Z);`\n\n- 参数 `Z` 是大小为 $4$ 的 `vector`，表示初始路径 $P$ 的两个端点 `Z[0]` 和 `Z[1]`，以及最终路径 $Q$ 的两个端点 `Z[2]` 和 `Z[3]`。函数返回将 $P$ 移动到 $Q$ 的最少步骤数。如果无法移动，则返回 `-1`。\n\n这些函数应按照上述描述工作。当然，你可以创建其他函数并在内部使用。提交的代码不应执行输入输出操作或访问其他文件。\n\n", "inputFormat": "评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$n\\,q$，$n$ 表示树的顶点数量，树的顶点编号从 $1$ 到 $n$，$q$ 表示查询的数量\n- 接下来的 $n-1$ 行：$x\\,y$，表示树的一条边 $(x, y)$，$1 \\le x \\neq y \\le n$\n- 接下来的 $q$ 行：$a\\,b\\,c\\,d$，表示初始路径 $P$ 的两个端点 $a$ 和 $b$，最终路径 $Q$ 的两个端点 $c$ 和 $d$\n\n", "outputFormat": "评测程序将输出函数 `train` 的返回值。如果无法移动，则输出 `-1`。", "hint": "### 样例说明 #1\n以下是样例中函数调用及其结果的顺序：\n\n| 函数调用 | 返回值 |\n| :----------: | :----------: |\n|`init(11, {1,3,4,4,6,8,7,8,10,11}, {2,2,3,5,5,4,8,9,9,10})`||\n|`train({3,5,7,4})`|$3$|\n|`train({3,6,7,10})`|$7$|\n\n### 数据范围\n对于所有输入数据，满足：\n\n- $3 \\leq n \\leq 2.5\\times 10^5$\n- $1 \\leq q \\leq 2.5\\times 10^5$\n- 所有查询中路径 $P$ 的长度总和 $\\leq 10^6$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$11$|$n \\leq 80, q \\leq 80$|\n|$2$|$18$|路径 $P$ 的长度 $\\leq 2$|\n|$3$|$34$|路径 $P$ 的长度 $\\leq 100$，所有路径 $P$ 的长度总和 $\\leq 2.5\\times 10^5$|\n|$4$|$36$|$n \\leq 1000, q \\leq 1000$|\n|$5$|$51$|无附加限制|\n\n本题满分为 $150$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KTSC 2020 R2」列车的移动", "background": "\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nvoid init(int N, std::vector<int> X, std::vector<int> Y);\n\nlong long train(std::vector<int> Z);\n  \n```\n\n题目译自 [2020년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2020/) T4「 [열차의 이동](https://assets.ioikorea.kr/ioitst/2020/1/train/train_statement.pdf)」\n\n", "description": "调车场是连接或分离列车车厢并进行维护和保养的地方。调车场中有可以移动列车的轨道。我们将用图来表示轨道上列车车厢的位置。图中的每条边表示列车的一个车厢所在的位置，因此列车在图中表示为一条路径。在这条路径上，所有的顶点和边都必须不同。特别地，问题中给出的图总是树形结构。\n\n列车可以沿着轨道移动。列车的移动是分阶段进行的，每个阶段列车的一端车厢移动到相邻的另一条边上。具体来说，对于表示列车的路径 $P$，一次移动的结果是将 $P$ 的一端顶点和相邻的 $P$ 之外的边和顶点添加到 $P$ 中，并将另一端的顶点和边从 $P$ 中移除（见图 1）。注意，每个阶段路径的长度保持不变。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n0s1u7qn.png)\n\n给定初始和最终列车位置的长度为 $m$ 的路径 $P$ 和 $Q$。路径的长度是路径中包含的边的数量。这里，路径 $P$ 和 $Q$ 之间没有任何共享的边。换句话说，$P$ 和 $Q$ 没有同时经过的边。我们需要将路径 $P$ 移动到最终成为路径 $Q$。此时，需要找到最少的移动步数。\n\n给定包含 $n$ 个顶点的树 $T$ 以及初始和最终列车位置的长度为 $m$ 的路径 $P$ 和 $Q$，编写一个程序，检查是否可以将 $P$ 移动到 $Q$，如果可以，输出最少的移动步数。\n\n例如，在图 2 中，给定长度为 $2$ 的两个路径 $P$ 和 $Q$，它们没有任何共享的边。可以看到，从路径 $P$ 移动到路径 $Q$ 需要 $5$ 步，这是最少的移动步数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fqetn4o5.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d7xab533.png)\n\n你需要为管理员实现以下两个函数：\n\n`void init(int n, vector<int> X, vector<int> Y);`\n\n- 该函数在程序开始时调用一次。树的顶点数量为 $n$，顶点编号从 $1$ 到 $n$。`X` 和 `Y` 是大小为 $n-1$ 的 `vector`，表示树的每条边为 $(X[i], Y[i])$。\n\n`long long train(vector<int> Z);`\n\n- 参数 `Z` 是大小为 $4$ 的 `vector`，表示初始路径 $P$ 的两个端点 `Z[0]` 和 `Z[1]`，以及最终路径 $Q$ 的两个端点 `Z[2]` 和 `Z[3]`。函数返回将 $P$ 移动到 $Q$ 的最少步骤数。如果无法移动，则返回 `-1`。\n\n这些函数应按照上述描述工作。当然，你可以创建其他函数并在内部使用。提交的代码不应执行输入输出操作或访问其他文件。\n\n", "inputFormat": "评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$n\\,q$，$n$ 表示树的顶点数量，树的顶点编号从 $1$ 到 $n$，$q$ 表示查询的数量\n- 接下来的 $n-1$ 行：$x\\,y$，表示树的一条边 $(x, y)$，$1 \\le x \\neq y \\le n$\n- 接下来的 $q$ 行：$a\\,b\\,c\\,d$，表示初始路径 $P$ 的两个端点 $a$ 和 $b$，最终路径 $Q$ 的两个端点 $c$ 和 $d$\n\n", "outputFormat": "评测程序将输出函数 `train` 的返回值。如果无法移动，则输出 `-1`。", "hint": "### 样例说明 #1\n以下是样例中函数调用及其结果的顺序：\n\n| 函数调用 | 返回值 |\n| :----------: | :----------: |\n|`init(11, {1,3,4,4,6,8,7,8,10,11}, {2,2,3,5,5,4,8,9,9,10})`||\n|`train({3,5,7,4})`|$3$|\n|`train({3,6,7,10})`|$7$|\n\n### 数据范围\n对于所有输入数据，满足：\n\n- $3 \\leq n \\leq 2.5\\times 10^5$\n- $1 \\leq q \\leq 2.5\\times 10^5$\n- 所有查询中路径 $P$ 的长度总和 $\\leq 10^6$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$11$|$n \\leq 80, q \\leq 80$|\n|$2$|$18$|路径 $P$ 的长度 $\\leq 2$|\n|$3$|$34$|路径 $P$ 的长度 $\\leq 100$，所有路径 $P$ 的长度总和 $\\leq 2.5\\times 10^5$|\n|$4$|$36$|$n \\leq 1000, q \\leq 1000$|\n|$5$|$51$|无附加限制|\n\n本题满分为 $150$ 分。", "locale": "zh-CN"}}}
{"pid": "P11712", "type": "P", "difficulty": 6, "samples": [["4 4\n1 2\n1 3\n2 4\n3 4\n", "1\n"], ["4 4\n1 2\n1 3\n1 4\n2 3\n", "3"], ["4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n", "3"], ["5 10\n1 2\n1 3\n1 4\n1 5\n2 3\n2 4\n2 5\n3 4\n3 5\n4 5\n", "0"], ["12 16\n1 2\n2 3\n3 4\n4 1\n5 6\n6 7\n7 8\n8 9\n9 10\n10 11\n11 12\n12 5\n1 5\n2 7\n3 9\n4 11\n", "2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "交互题", "KOI（韩国）"], "title": "「KTSC 2020 R2」冰战", "background": "\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nvoid maximize(std::vector<int> A);\n  \n```\n\n题目译自 [2020년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2020/) T4「 [아이싱](https://assets.ioikorea.kr/ioitst/2020/1/ising/ising_statement.pdf)」\n\n", "description": "冰战是一款在中学生和高中生中非常流行的在线一对一对战游戏。游戏公司决定扩展这款游戏，开发了冰战 II，这是一款专为团队对战设计的游戏，允许团队 I 和团队 Sing 之间进行对战。冰战 II 利用玩家在冰战中的对战记录，以独特的方式组建团队。具体来说，在冰战中进行过一对一对战的两个玩家必须分属不同的团队。每个团队至少有一名成员，两个团队的人数可以不同。\n\n例如，下表展示了四名玩家 $A$、$B$、$C$、$D$ 在冰战中的对战记录，以及在冰战 II 中的团队组成。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wkzjmryp.png)\n\n然而，冰战 II 服务器将在 $3$ 分钟后开放，但发现了一个致命问题。例如，如果玩家 $A$、$B$、$C$ 都曾互相对战过，他们必须分别加入不同的团队，这使得无法组成团队 I 和团队 Sing。\n\n为了解决这个问题，我们决定删除最少数量的对战记录。例如，考虑下图中四名玩家 $A$、$B$、$C$、$D$ 的冰战对战记录（左图）。在这种情况下，至少需要删除一条记录，如果删除 $A-B$（中图），则可以组成两个团队（右图）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rz81m6i9.png)\n\n另一个例子，考虑以下冰战对战记录。在这种情况下，至少需要删除两条对战记录，如果删除 $A-B$ 和 $C-D$，则可以组成两个团队。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s1fdb74r.png)\n\n但是，游戏将在 $3$ 分钟后上线，因此最多只能删除两条记录。如果需要删除三条或更多记录，可能需要推迟上线。\n\n在这种情况下，游戏公司想知道有多少种不同的方法可以删除最少数量的对战记录，以便组成两个团队。也就是说，当需要删除的最少对战记录数量为 $K$ 时，计算大小为 $K$ 的可删除对战记录子集的数量。\n\n在样例 2 中，删除 $\\{A-B\\}, \\{A-C\\}$ 或 $\\{B-C\\}$ 都可以组成两个团队，因此答案是 $3$。在样例 3 中，删除 $\\{A-B, C-D\\}, \\{A-C, B-D\\}$ 或 $\\{A-D, B-C\\}$ 都可以组成两个团队，因此答案是 $3$。\n\n你需要实现以下函数，利用给定的冰战对战记录，计算有多少种不同的方法可以删除最少数量的对战记录，以便组成两个团队。在这种情况下，删除对战记录的顺序不重要。如果无法通过删除两条或更少的记录来进行游戏，则返回 `0`。如果不需要删除任何记录，则返回 `1`，因为这是最快的唯一方法。\n\n`long long count_ways(int N, vector<int> U, vector<int> V);`\n\n- 参数 `N` 是玩家数量，`U` 和 `V` 是大小为 $M$ 的 `vector`，表示玩家 $U_{i}$ 和 $V_{i}$ 之间有冰战对战记录。函数返回删除最少数量的对战记录以组成两个团队的不同方法的数量。如果需要删除三条或更多记录，则返回 `0`。\n\n该函数应按照上述描述工作。当然，你可以创建其他函数并在内部使用。提交的代码不应执行输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,M$，$N$ 表示玩家数量，$M$ 表示冰战对战记录数量\n- 第 $2+i (0 \\leq i \\leq M-1)$ 行：$U_{i}\\,V_{i}$（玩家 $U_{i}$ 和玩家 $V_{i}$ 之间的冰战对战记录）\n", "outputFormat": "示例评测程序将输出你的代码中 `count_ways()` 函数返回的值。", "hint": "### 样例说明 #1\n以下是样例 1 中函数调用及其返回值：\n| 调用函数 | 返回值 |\n| :----------: | :----------: |\n|`count(4, {1,1,2,3}, {2,3,4,4})`|`1`|\n\n### 数据范围\n对于所有输入数据，满足：\n\n- $3 \\leq N \\leq 2.5\\times 10^5$\n- $N-1 \\leq M \\leq 2.5\\times 10^5$\n- $1 \\leq U_{i}, V_{i} \\leq N (0 \\leq i \\leq M-1)$\n- $U_{i} \\neq V_{i}$\n- $U_{i}=U_{j}$ 且 $V_{i}=V_{j}$ 时 $i=j$\n- 任何两个玩家通过对战记录直接或间接相关\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$10$|$N \\leq 200, M \\leq 200$|\n|$2$|$23$|$N \\leq 5000, M \\leq 5000$|\n|$3$|$11$|$N \\leq 500$|\n|$4$|$25$|$N \\leq 5000$|\n|$5$|$31$|$M-N \\leq 200$|\n|$6$|$50$|无附加限制|\n\n本题满分为 $150$ 分。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "「KTSC 2020 R2」冰战", "background": "\n**请使用 C++17 或 C++20 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include <vector>\n\nvoid maximize(std::vector<int> A);\n  \n```\n\n题目译自 [2020년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2020/) T4「 [아이싱](https://assets.ioikorea.kr/ioitst/2020/1/ising/ising_statement.pdf)」\n\n", "description": "冰战是一款在中学生和高中生中非常流行的在线一对一对战游戏。游戏公司决定扩展这款游戏，开发了冰战 II，这是一款专为团队对战设计的游戏，允许团队 I 和团队 Sing 之间进行对战。冰战 II 利用玩家在冰战中的对战记录，以独特的方式组建团队。具体来说，在冰战中进行过一对一对战的两个玩家必须分属不同的团队。每个团队至少有一名成员，两个团队的人数可以不同。\n\n例如，下表展示了四名玩家 $A$、$B$、$C$、$D$ 在冰战中的对战记录，以及在冰战 II 中的团队组成。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wkzjmryp.png)\n\n然而，冰战 II 服务器将在 $3$ 分钟后开放，但发现了一个致命问题。例如，如果玩家 $A$、$B$、$C$ 都曾互相对战过，他们必须分别加入不同的团队，这使得无法组成团队 I 和团队 Sing。\n\n为了解决这个问题，我们决定删除最少数量的对战记录。例如，考虑下图中四名玩家 $A$、$B$、$C$、$D$ 的冰战对战记录（左图）。在这种情况下，至少需要删除一条记录，如果删除 $A-B$（中图），则可以组成两个团队（右图）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rz81m6i9.png)\n\n另一个例子，考虑以下冰战对战记录。在这种情况下，至少需要删除两条对战记录，如果删除 $A-B$ 和 $C-D$，则可以组成两个团队。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s1fdb74r.png)\n\n但是，游戏将在 $3$ 分钟后上线，因此最多只能删除两条记录。如果需要删除三条或更多记录，可能需要推迟上线。\n\n在这种情况下，游戏公司想知道有多少种不同的方法可以删除最少数量的对战记录，以便组成两个团队。也就是说，当需要删除的最少对战记录数量为 $K$ 时，计算大小为 $K$ 的可删除对战记录子集的数量。\n\n在样例 2 中，删除 $\\{A-B\\}, \\{A-C\\}$ 或 $\\{B-C\\}$ 都可以组成两个团队，因此答案是 $3$。在样例 3 中，删除 $\\{A-B, C-D\\}, \\{A-C, B-D\\}$ 或 $\\{A-D, B-C\\}$ 都可以组成两个团队，因此答案是 $3$。\n\n你需要实现以下函数，利用给定的冰战对战记录，计算有多少种不同的方法可以删除最少数量的对战记录，以便组成两个团队。在这种情况下，删除对战记录的顺序不重要。如果无法通过删除两条或更少的记录来进行游戏，则返回 `0`。如果不需要删除任何记录，则返回 `1`，因为这是最快的唯一方法。\n\n`long long count_ways(int N, vector<int> U, vector<int> V);`\n\n- 参数 `N` 是玩家数量，`U` 和 `V` 是大小为 $M$ 的 `vector`，表示玩家 $U_{i}$ 和 $V_{i}$ 之间有冰战对战记录。函数返回删除最少数量的对战记录以组成两个团队的不同方法的数量。如果需要删除三条或更多记录，则返回 `0`。\n\n该函数应按照上述描述工作。当然，你可以创建其他函数并在内部使用。提交的代码不应执行输入输出操作或访问其他文件。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,M$，$N$ 表示玩家数量，$M$ 表示冰战对战记录数量\n- 第 $2+i (0 \\leq i \\leq M-1)$ 行：$U_{i}\\,V_{i}$（玩家 $U_{i}$ 和玩家 $V_{i}$ 之间的冰战对战记录）\n", "outputFormat": "示例评测程序将输出你的代码中 `count_ways()` 函数返回的值。", "hint": "### 样例说明 #1\n以下是样例 1 中函数调用及其返回值：\n| 调用函数 | 返回值 |\n| :----------: | :----------: |\n|`count(4, {1,1,2,3}, {2,3,4,4})`|`1`|\n\n### 数据范围\n对于所有输入数据，满足：\n\n- $3 \\leq N \\leq 2.5\\times 10^5$\n- $N-1 \\leq M \\leq 2.5\\times 10^5$\n- $1 \\leq U_{i}, V_{i} \\leq N (0 \\leq i \\leq M-1)$\n- $U_{i} \\neq V_{i}$\n- $U_{i}=U_{j}$ 且 $V_{i}=V_{j}$ 时 $i=j$\n- 任何两个玩家通过对战记录直接或间接相关\n\n详细子任务附加限制及分值如下表所示。\n\n| Subtask | 分值 | 约束 |\n| :----------: | :----------: | :----------: |\n|$1$|$10$|$N \\leq 200, M \\leq 200$|\n|$2$|$23$|$N \\leq 5000, M \\leq 5000$|\n|$3$|$11$|$N \\leq 500$|\n|$4$|$25$|$N \\leq 5000$|\n|$5$|$31$|$M-N \\leq 200$|\n|$6$|$50$|无附加限制|\n\n本题满分为 $150$ 分。", "locale": "zh-CN"}}}
{"pid": "P11713", "type": "P", "difficulty": 6, "samples": [["4 2\n0\n1\n2\n3", "3.5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "CTT（清华集训/北大集训）"], "title": "[清华集训 2014] 玛里苟斯", "background": "", "description": "魔法之龙玛里苟斯最近在为加基森拍卖师的削弱而感到伤心，于是他想了一道数学题。\n\n$S$ 是一个可重集合，$S = \\{a_1, a_2, \\dots, a_n \\}$。\n\n等概率随机取 $S$ 的一个子集 $A = \\{a_{i_1}, \\dots, a_{i_m}\\}$。\n\n计算出 $A$ 中所有元素异或 $x$，求 $x^k$ 的期望。", "inputFormat": "第一行两个正整数 $n,k$。\n\n以下 $n$ 行每行一个整数，表示 $a_i$。", "outputFormat": "如果结果是整数，直接输出。如果结果是小数（显然这个小数是有限的），输出精确值（末尾不加多余的 $0$）。", "hint": "数据保证，$1 \\leq n \\leq 100000$，$1 \\leq k \\leq 5$，$a_i \\geq 0$。最终答案小于 $2^{63}$。$k = 1,2,3,4,5$ 各自占用 $20\\%$ 的数据。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2014] 玛里苟斯", "background": "", "description": "魔法之龙玛里苟斯最近在为加基森拍卖师的削弱而感到伤心，于是他想了一道数学题。\n\n$S$ 是一个可重集合，$S = \\{a_1, a_2, \\dots, a_n \\}$。\n\n等概率随机取 $S$ 的一个子集 $A = \\{a_{i_1}, \\dots, a_{i_m}\\}$。\n\n计算出 $A$ 中所有元素异或 $x$，求 $x^k$ 的期望。", "inputFormat": "第一行两个正整数 $n,k$。\n\n以下 $n$ 行每行一个整数，表示 $a_i$。", "outputFormat": "如果结果是整数，直接输出。如果结果是小数（显然这个小数是有限的），输出精确值（末尾不加多余的 $0$）。", "hint": "数据保证，$1 \\leq n \\leq 100000$，$1 \\leq k \\leq 5$，$a_i \\geq 0$。最终答案小于 $2^{63}$。$k = 1,2,3,4,5$ 各自占用 $20\\%$ 的数据。", "locale": "zh-CN"}}}
{"pid": "P11714", "type": "P", "difficulty": 7, "samples": [["5 15\n4 3\n4 2\n2 5\n2 1\n1 2\n5 1\n3 2\n4 1\n1 4\n5 4\n3 4\n5 3\n2 3\n1 5\n3 1", "9390"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "容斥原理", "CTT（清华集训/北大集训）", "集合幂级数，子集卷积"], "title": "[清华集训 2014] 主旋律", "background": "", "description": "响应主旋律的号召，大家决定让这个班级充满爱，现在班级里面有 $n$ 个男生。\n\n如果 $a$ 爱着 $b$，那么就相当于 $a$ 和 $b$ 之间有一条 $a \\rightarrow b$ 的有向边。如果这 $n$ 个点的图是强联通的，那么就认为这个班级是充满爱的。\n\n不幸的是，有一些不好的事情发生了，现在每一条边都可能被摧毁。我作为爱的使者，想知道有多少种摧毁的方式，使得这个班级任然充满爱呢？（说人话就是有多少边的子集删去之后整个图仍然强联通。）", "inputFormat": "第一行两个数 $n$ 和 $m$，表示班级里的男生数和爱的关系数。\n\n接下来 $m$ 行，每行两个数 $a$ 和 $b$，表示男生 $a$ 爱着男生 $b$。同时 $a$ 不等于 $b$。\n\n所有男生从 $1$ 到 $n$ 标号。\n\n同一条边不会出现两遍，但可能出现 $a$ 爱着 $b$，$b$ 也爱着 $a$ 的情况，这是两条不同的边。", "outputFormat": "输出一行一个整数,表示对 $10^9 + 7$ 取模后的答案。", "hint": "- 对于 20% 的数据满足: $n \\leq 5$；\n- 对于 50% 的数据满足: $n \\leq 8$；\n- 对于 70% 的数据满足: $n \\leq 10$；\n- 对于 100% 的数据满足: $n \\leq 15, 0 \\leq m \\leq n(n - 1)$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2014] 主旋律", "background": "", "description": "响应主旋律的号召，大家决定让这个班级充满爱，现在班级里面有 $n$ 个男生。\n\n如果 $a$ 爱着 $b$，那么就相当于 $a$ 和 $b$ 之间有一条 $a \\rightarrow b$ 的有向边。如果这 $n$ 个点的图是强联通的，那么就认为这个班级是充满爱的。\n\n不幸的是，有一些不好的事情发生了，现在每一条边都可能被摧毁。我作为爱的使者，想知道有多少种摧毁的方式，使得这个班级任然充满爱呢？（说人话就是有多少边的子集删去之后整个图仍然强联通。）", "inputFormat": "第一行两个数 $n$ 和 $m$，表示班级里的男生数和爱的关系数。\n\n接下来 $m$ 行，每行两个数 $a$ 和 $b$，表示男生 $a$ 爱着男生 $b$。同时 $a$ 不等于 $b$。\n\n所有男生从 $1$ 到 $n$ 标号。\n\n同一条边不会出现两遍，但可能出现 $a$ 爱着 $b$，$b$ 也爱着 $a$ 的情况，这是两条不同的边。", "outputFormat": "输出一行一个整数,表示对 $10^9 + 7$ 取模后的答案。", "hint": "- 对于 20% 的数据满足: $n \\leq 5$；\n- 对于 50% 的数据满足: $n \\leq 8$；\n- 对于 70% 的数据满足: $n \\leq 10$；\n- 对于 100% 的数据满足: $n \\leq 15, 0 \\leq m \\leq n(n - 1)$。", "locale": "zh-CN"}}}
{"pid": "P11715", "type": "P", "difficulty": 6, "samples": [["4 4 4\n2 2\n2 4\n3 2\n4 4\n4\n1 1\n1 4\n3 3\n2 2", "1\n0\n1\n0"], ["1000 2 10\n426 2\n595 2\n665 1\n447 2\n604 2\n202 1\n26 1\n79 1\n291 2\n6 2\n10\n932 1\n857 2\n31 1\n458 1\n793 1\n691 1\n438 1\n404 1\n541 1\n872 2", "18156\n27456\n235\n1496\n26496\n8034\n96\n2373\n4982\n26496"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "轮廓线 DP", "CTT（清华集训/北大集训）"], "title": "[清华集训 2014] 简单回路", "background": "", "description": "在一个有障碍点的 $n$ 行 $m$ 列的网格图中，我们用 $(x,y)$ 来表示第 $x$ 行第 $y$ 列的格子。如果该网格图中的回路满足下面两个条件：\n\n1. 不经过任何一个障碍点\n2. 回路不自交\n\n则我们称该回路为合法的简单回路。\n\n现在有 $Q$ 个询问，每次询问有多少条合法的简单回路经过了 $(x,y)$ 与 $(x+1,y)$ 之间的边。", "inputFormat": "第一行输入三个非负整数 $n,m,k$，表示 $n$ 行 $m$ 列的网格图中有 $k$ 个障碍点。\n\n接下来 $k$ 行，每行两个正整数 $x,y$ $(1 \\leq x \\leq n,1 \\leq y \\leq m)$，表示 $(x,y)$ 为一个障碍点（可能重复）\n\n接下来一个整数 $Q$，表示 $Q$ 个询问。\n\n接下来 $Q$ 行，每行两个正整数 $x,y$ $(1 \\leq x \\leq n-1, 1 \\leq y \\leq m)$，询问有多少条合法的简单回路经过了格子 $(x,y)$ 与 $(x+1,y)$ 之间的边。", "outputFormat": "输出 $Q$ 行，每行对应一组询问。请将答案 $\\bmod (1000000000+7)$ 之后输出。", "hint": "| 测试点编号 | $n$       | $m$       | $k$       | $q$       |\n|:------------:|:---------:|:---------:|:---------:|:---------:|\n| $1$          | $100$     | $1$       | $≤ 100$   | $≤ 100$   |\n| $2$          | $1000$    | $2$       | $≤ 100$   | $≤ 100$   |\n| $3$          | $1000$    | $2$       | $≤ 100$   | $≤ 100$   |\n| $4$          | $1000$    | $3$       | $≤ 100$   | $≤ 100$   |\n| $5$          | $1000$    | $5$       | $≤ 100$   | $≤ 100$   |\n| $6$          | $1000$    | $6$       | $≤ 100$   | $≤ 100$   |\n| $7$          | $1000$    | $6$       | $≤ 100$   | $≤ 10000$ |\n| $8$          | $1000$    | $6$       | $≤ 100$   | $≤ 10000$ |\n| $9$          | $1000$    | $6$       | $≤ 100$   | $≤ 10000$ |\n| $10$         | $1000$    | $6$       | $≤ 100$   | $≤ 10000$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2014] 简单回路", "background": "", "description": "在一个有障碍点的 $n$ 行 $m$ 列的网格图中，我们用 $(x,y)$ 来表示第 $x$ 行第 $y$ 列的格子。如果该网格图中的回路满足下面两个条件：\n\n1. 不经过任何一个障碍点\n2. 回路不自交\n\n则我们称该回路为合法的简单回路。\n\n现在有 $Q$ 个询问，每次询问有多少条合法的简单回路经过了 $(x,y)$ 与 $(x+1,y)$ 之间的边。", "inputFormat": "第一行输入三个非负整数 $n,m,k$，表示 $n$ 行 $m$ 列的网格图中有 $k$ 个障碍点。\n\n接下来 $k$ 行，每行两个正整数 $x,y$ $(1 \\leq x \\leq n,1 \\leq y \\leq m)$，表示 $(x,y)$ 为一个障碍点（可能重复）\n\n接下来一个整数 $Q$，表示 $Q$ 个询问。\n\n接下来 $Q$ 行，每行两个正整数 $x,y$ $(1 \\leq x \\leq n-1, 1 \\leq y \\leq m)$，询问有多少条合法的简单回路经过了格子 $(x,y)$ 与 $(x+1,y)$ 之间的边。", "outputFormat": "输出 $Q$ 行，每行对应一组询问。请将答案 $\\bmod (1000000000+7)$ 之后输出。", "hint": "| 测试点编号 | $n$       | $m$       | $k$       | $q$       |\n|:------------:|:---------:|:---------:|:---------:|:---------:|\n| $1$          | $100$     | $1$       | $≤ 100$   | $≤ 100$   |\n| $2$          | $1000$    | $2$       | $≤ 100$   | $≤ 100$   |\n| $3$          | $1000$    | $2$       | $≤ 100$   | $≤ 100$   |\n| $4$          | $1000$    | $3$       | $≤ 100$   | $≤ 100$   |\n| $5$          | $1000$    | $5$       | $≤ 100$   | $≤ 100$   |\n| $6$          | $1000$    | $6$       | $≤ 100$   | $≤ 100$   |\n| $7$          | $1000$    | $6$       | $≤ 100$   | $≤ 10000$ |\n| $8$          | $1000$    | $6$       | $≤ 100$   | $≤ 10000$ |\n| $9$          | $1000$    | $6$       | $≤ 100$   | $≤ 10000$ |\n| $10$         | $1000$    | $6$       | $≤ 100$   | $≤ 10000$ |", "locale": "zh-CN"}}}
{"pid": "P11716", "type": "P", "difficulty": 6, "samples": [["6 10\n1 0\n-3.6 7.2 3.6\n9.7 0.4 0.5\n8.8 -4.7 0.5\n9.6 8.2 -5.7\n0.3 -9.9 1.5\n0.5 -5.7 -1.0\n0 1.3 1.92 0.13 1.85\n1 1.98 1.55 1.2 2.360183811\n1 8.2 0.9 2.1 9.981091248\n1 -7.4 -44.0 11.2 83.061927835\n1 20.8 -9.6 -11.8 31.598039153\n0 10.0 11.2 -19.73 -19.1\n0 13.0 7.3 28.6 22.6\n0 4.0 22.3 -17.6 1.3\n1 -3.2 -14.0 16.6 30.9549661993\n0 7.0 -3.1 5.8 -0.9", "1\n6\n2\n3\n1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "CTT（清华集训/北大集训）"], "title": "[清华集训 2014] 卡常数", "background": "在某个诡异的地方，有一座智慧之城，那里的人民平均智商为 192，智商低于 150 的人都被称为弱智。智慧之城的市长名叫卡常（Karp-de-Chant），他 12 岁时在智慧之城中心大学 Cross Institute 获得博士学位，两年后发明了一种数列 —— 卡常数（Karp-de-Chant Number），该数列可用来解决或优化数论、图论等领域的多种经典难题。后来，卡常数被 Trajan（智慧之城的副市长）用 spaly 树进行扩展后，威力大大增加，可以在线性时间内解决各种网络流问题和其它一些难题。卡常和 Trajan 因此分别被选为正、副市长，他们和智慧之城内的另一些智者一起，领导人民共同建设人类智慧，发挥创造和改进的能力。", "description": "然而某一天，智慧之城突然受到了反人类智慧者的袭击，反人类智慧者在城内设置了 $N$ 个摄像头（由于他们的智商很低，只会用摄像头这种垃圾玩意），企图监视城内的人们。卡常、Trajan 决定找到这些摄像头并摧毁它们。\n\n智慧之城里有一个用扩展卡常数原理设计的发射器，将其放在合适位置并设置半径以后，所有位于球心为这个发射器的位置、半径为指定值的球面上的目标都能被发现。在卡常、Trajan 的带领下，智慧之城的人们用这个发射器进行了若干次实验，并发现了一些摄像头的位置。比较囧的是，每次发射都能且仅能发现一个摄像头，但是，反馈回来的结果貌似有些不对劲……\n\n后来人们终于找到了这 $N$ 个摄像头的位置，并发现在他们用发射器进行实验的过程中，某些摄像头被移位——这就是导致反馈结果不对劲的原因。但是，在对实验结果进行分析的时候，人们却肿么也回忆不起每次实验发现的摄像头是哪个了（可能是遭遇了灵异事件导致脑抽），只知道每次实验时发射器的位置和半径。你的任务就是，根据实验数据（为了防止被反人类智慧者窃取，已经进行了加密）找出每次实验时被发射器找到的摄像头的编号。", "inputFormat": "第一行两个正整数 $N,M$，表示摄像头数量（摄像头以 $1$ 到 $N$ 编号）和事件数量。\n\n第二行两个实数 $a,b$，表示加密参数。\n\n接下来 $N$ 行，每行三个实数 $(x, y, z)$，表示 $1$ 到 $N$ 号摄像头的初始位置坐标。\n\n接下来 $M$ 行，每行描述一个事件，有两种可能的事件（保证其中实数的精度充分高）：\n\n1. $0$ $i$ $x$ $y$ $z$，表示将编号为 $i$ 的摄像头的坐标改为 $(x, y, z)$；\n2. $1$ $x$ $y$ $z$ $r$，表示进行一次实验，将发射器放在 $(x, y, z)$ 处并设置半径为 $r$，数据保证每次实验能且仅能发现一个摄像头；\n\n加密方式：设函数 $f(x)=ax-b \\sin x$，对于所有事件中的参数（$i,x,y,z,r$），均加密成 $f(\\mathrm{last\\_res} \\times 原值 + 1)$，其中 $\\mathrm{last\\_res}$ 为上一个实验事件的返回值（即发现的摄像头编号），若之前未进行过实验则 $\\mathrm{last\\_res} = 0.1$。", "outputFormat": "对于每个实验事件，输出发现的摄像头编号，一个一行。", "hint": "| 测试点编号 | $n$       | $m$       | 附加信息          |\n|:------------:|:---------:|:---------:|:-------------------:|\n| $1$          | $1024$    | $1024$    | 无                |\n| $2$          | $2048$    | $2048$    | 无                 |\n| $3$          | $32768$   | $32768$   | 没有摄像头移位事件                  |\n| $4$          | $32768$   | $65536$   | 没有摄像头移位事件 |\n| $5$          | $65536$   | $65536$   | 没有摄像头移位事件                  |\n| $6$          | $32768$   | $32768$   | 无                  |\n| $7$          | $32768$   | $65536$   | 无                  |\n| $8$          | $65536$   | $32768$   | 无                |\n| $9$          | $65536$   | $65536$   | 无                  |\n| $10$         | $65536$   | $65536$   | 无                  |\n\n所有的测试点满足 $0 \\leq b < a < 5$，坐标的绝对值均不超过 $100$，所有坐标均为随机生成且至少精确到 $10^{-5}$。\n\n为尽可能减小精度误差，建议 C/C++ 使用 long double 类型、Pascal 使用 EXTENDED 类型存储实数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2014] 卡常数", "background": "在某个诡异的地方，有一座智慧之城，那里的人民平均智商为 192，智商低于 150 的人都被称为弱智。智慧之城的市长名叫卡常（Karp-de-Chant），他 12 岁时在智慧之城中心大学 Cross Institute 获得博士学位，两年后发明了一种数列 —— 卡常数（Karp-de-Chant Number），该数列可用来解决或优化数论、图论等领域的多种经典难题。后来，卡常数被 Trajan（智慧之城的副市长）用 spaly 树进行扩展后，威力大大增加，可以在线性时间内解决各种网络流问题和其它一些难题。卡常和 Trajan 因此分别被选为正、副市长，他们和智慧之城内的另一些智者一起，领导人民共同建设人类智慧，发挥创造和改进的能力。", "description": "然而某一天，智慧之城突然受到了反人类智慧者的袭击，反人类智慧者在城内设置了 $N$ 个摄像头（由于他们的智商很低，只会用摄像头这种垃圾玩意），企图监视城内的人们。卡常、Trajan 决定找到这些摄像头并摧毁它们。\n\n智慧之城里有一个用扩展卡常数原理设计的发射器，将其放在合适位置并设置半径以后，所有位于球心为这个发射器的位置、半径为指定值的球面上的目标都能被发现。在卡常、Trajan 的带领下，智慧之城的人们用这个发射器进行了若干次实验，并发现了一些摄像头的位置。比较囧的是，每次发射都能且仅能发现一个摄像头，但是，反馈回来的结果貌似有些不对劲……\n\n后来人们终于找到了这 $N$ 个摄像头的位置，并发现在他们用发射器进行实验的过程中，某些摄像头被移位——这就是导致反馈结果不对劲的原因。但是，在对实验结果进行分析的时候，人们却肿么也回忆不起每次实验发现的摄像头是哪个了（可能是遭遇了灵异事件导致脑抽），只知道每次实验时发射器的位置和半径。你的任务就是，根据实验数据（为了防止被反人类智慧者窃取，已经进行了加密）找出每次实验时被发射器找到的摄像头的编号。", "inputFormat": "第一行两个正整数 $N,M$，表示摄像头数量（摄像头以 $1$ 到 $N$ 编号）和事件数量。\n\n第二行两个实数 $a,b$，表示加密参数。\n\n接下来 $N$ 行，每行三个实数 $(x, y, z)$，表示 $1$ 到 $N$ 号摄像头的初始位置坐标。\n\n接下来 $M$ 行，每行描述一个事件，有两种可能的事件（保证其中实数的精度充分高）：\n\n1. $0$ $i$ $x$ $y$ $z$，表示将编号为 $i$ 的摄像头的坐标改为 $(x, y, z)$；\n2. $1$ $x$ $y$ $z$ $r$，表示进行一次实验，将发射器放在 $(x, y, z)$ 处并设置半径为 $r$，数据保证每次实验能且仅能发现一个摄像头；\n\n加密方式：设函数 $f(x)=ax-b \\sin x$，对于所有事件中的参数（$i,x,y,z,r$），均加密成 $f(\\mathrm{last\\_res} \\times 原值 + 1)$，其中 $\\mathrm{last\\_res}$ 为上一个实验事件的返回值（即发现的摄像头编号），若之前未进行过实验则 $\\mathrm{last\\_res} = 0.1$。", "outputFormat": "对于每个实验事件，输出发现的摄像头编号，一个一行。", "hint": "| 测试点编号 | $n$       | $m$       | 附加信息          |\n|:------------:|:---------:|:---------:|:-------------------:|\n| $1$          | $1024$    | $1024$    | 无                |\n| $2$          | $2048$    | $2048$    | 无                 |\n| $3$          | $32768$   | $32768$   | 没有摄像头移位事件                  |\n| $4$          | $32768$   | $65536$   | 没有摄像头移位事件 |\n| $5$          | $65536$   | $65536$   | 没有摄像头移位事件                  |\n| $6$          | $32768$   | $32768$   | 无                  |\n| $7$          | $32768$   | $65536$   | 无                  |\n| $8$          | $65536$   | $32768$   | 无                |\n| $9$          | $65536$   | $65536$   | 无                  |\n| $10$         | $65536$   | $65536$   | 无                  |\n\n所有的测试点满足 $0 \\leq b < a < 5$，坐标的绝对值均不超过 $100$，所有坐标均为随机生成且至少精确到 $10^{-5}$。\n\n为尽可能减小精度误差，建议 C/C++ 使用 long double 类型、Pascal 使用 EXTENDED 类型存储实数。", "locale": "zh-CN"}}}
{"pid": "P11717", "type": "P", "difficulty": 5, "samples": [["2\n5 10\n0 1 0 2 3 0 0 4 0 5\n2 0 3 0 0 1 0 5 4 0\n4 2 1 0 0 0 3 0 5 0\n0 3 0 4 0 5 0 1 2 0\n1 0 0 3 2 4 5 0 0 0\n5 10\n0 1 0 2 3 0 0 4 0 5\n2 0 3 0 0 1 0 5 4 0\n4 2 1 0 0 0 3 0 5 0\n0 3 0 4 0 5 0 1 2 0\n1 0 0 3 2 4 5 0 0 0", "4 5 3 1 2\n5 4 3 1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2014", "Special Judge", "CTT（清华集训/北大集训）"], "title": "[清华集训 2014] 矩阵变换", "background": "", "description": "给出一个 $N$ 行 $M$ 列的矩阵 $A$，保证满足以下性质:\n\n1. $M > N$。\n2. 矩阵中每个数都是 $[0, N]$ 中的自然数。\n3. 每行中, $[1, N]$ 中每个自然数都恰好出现一次。这意味着每行中 $0$ 恰好出现 $M - N$ 次。\n4. 每列中，$[1, N]$ 中每个自然数至多出现一次。\n\n现在我们要在每行中选取一个非零数，并把这个数之后的数赋值为这个数。我们希望保持上面的性质 $4$，即每列中，$[1, N]$ 中每个自然数仍然至多出现一次。", "inputFormat": "第一行一个正整数 $T$，表示数据组数。\n\n后面包含 $T$ 组数据，各组数据之间无空行。每组数据以两个正整数 $N, M$ 开始，接下来 $N$ 行，每行 $M$ 个用空格隔开的整数，意义如题所述。", "outputFormat": "对于每组数据输出一行。如果有解，则输出 $N$ 个整数，依次表示每一行取的数是多少。（这应该是一个 $1$ 到 $N$ 的排列）如果无解，则输出任意卖萌表情。", "hint": "### 样例解释\n\n两组输入数据是相同的。由于结果不唯一，你可以给出任意一组合法答案。\n\n### 数据范围\n\n- 对于 20% 的数据，$M < 8, T < 8$。\n- 对于 40% 的数据，$N < 8, T < 8$。\n- 对于 100% 的数据，$N < 200, M < 400, T < 50$。\n\n卖萌表情包括但不限于“\\(^o^)/” (不含引号)。\n\n由于输入数据较大，请自行优化输入方法。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[清华集训 2014] 矩阵变换", "background": "", "description": "给出一个 $N$ 行 $M$ 列的矩阵 $A$，保证满足以下性质:\n\n1. $M > N$。\n2. 矩阵中每个数都是 $[0, N]$ 中的自然数。\n3. 每行中, $[1, N]$ 中每个自然数都恰好出现一次。这意味着每行中 $0$ 恰好出现 $M - N$ 次。\n4. 每列中，$[1, N]$ 中每个自然数至多出现一次。\n\n现在我们要在每行中选取一个非零数，并把这个数之后的数赋值为这个数。我们希望保持上面的性质 $4$，即每列中，$[1, N]$ 中每个自然数仍然至多出现一次。", "inputFormat": "第一行一个正整数 $T$，表示数据组数。\n\n后面包含 $T$ 组数据，各组数据之间无空行。每组数据以两个正整数 $N, M$ 开始，接下来 $N$ 行，每行 $M$ 个用空格隔开的整数，意义如题所述。", "outputFormat": "对于每组数据输出一行。如果有解，则输出 $N$ 个整数，依次表示每一行取的数是多少。（这应该是一个 $1$ 到 $N$ 的排列）如果无解，则输出任意卖萌表情。", "hint": "### 样例解释\n\n两组输入数据是相同的。由于结果不唯一，你可以给出任意一组合法答案。\n\n### 数据范围\n\n- 对于 20% 的数据，$M < 8, T < 8$。\n- 对于 40% 的数据，$N < 8, T < 8$。\n- 对于 100% 的数据，$N < 200, M < 400, T < 50$。\n\n卖萌表情包括但不限于“\\(^o^)/” (不含引号)。\n\n由于输入数据较大，请自行优化输入方法。", "locale": "zh-CN"}}}
