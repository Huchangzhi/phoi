{"pid": "P6259", "type": "P", "difficulty": 5, "samples": [["4 8 5 7\n.......#\n..#....#\n.###...#\n.....###\nR=lll\nG=ub(B)\nB=ub(m)lib(l)(m)\nH=ib()(mmHllmll)\nI=III\n1 1 w\nG\n1 1 e\nG\n2 2 n\nG\n2 6 w\nBR\n4 1 s\nib(lib()(mmm))(mmmm)\n1 1 e\nH\n2 2 s\nI\n", "1 1 w\ninf\n1 1 w\n2 4 s\n4 4 e\n1 4 e\ninf\n"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["模拟", "2019", "O2优化", "ICPC", "WF"], "title": "[ICPC 2019 WF] Karel the Robot", "background": "### Warning: If you submit a malicious program, you will be banned.\n### 警告：恶意提交本题将被封号。", "description": "Did you know that the word \"robot\" is almost 100 years old? It was first introduced in 1920, in the science-fiction theatrical play $R.U.R.$ , written by Karel Capek. As a tribute to this Czech writer, an educational programming language was named Karel many years later at Stanford University. Your task is to implement an interpreter of a simplified version of this programming language.\n\nThe Karel programming language controls a robot named Karel, who lives in a grid of unit squares. Some of the squares are free, while others contain a barrier. Karel always occupies one of the free squares and faces one of the four cardinal directions. The two basic commands are \"move forward\" and \"turn left.\" The language also provides simple conditional and looping statements. The main educational potential of the language lies in the possibility of defining new procedures for more complex tasks.\n\nOur simplified version of the language can be described by the following grammar:\n\n```plain\n<program> := \"\" | <command> <program>\n<command> := \"m\" | \"l\" | <proc-call> |\n             \"i\" <condition> \"(\" <program> \")(\" <program> \")\" |\n             \"u\" <condition> \"(\" <program> \")\"\n<condition> := \"b\" | \"n\" | \"s\" | \"e\" | \"w\"\n<proc-call> := <uppercase-letter>\n<proc-def> := <uppercase-letter> \"=\" <program>\n```\nThere are five types of commands:\n\n- $\\texttt m$ (\"move forward\") advances Karel's position by one grid square in its current heading, unless there is a barrier, in which case the command has no effect.\n- $\\texttt l$ (\"turn left\") makes Karel turn left $90$ degrees.\n- $\\texttt X$ where $\\texttt X$ is any uppercase letter, invokes the procedure named $\\texttt X$. \n- $\\texttt i$ (\"if\") followed by a single-letter condition, and two programs in parentheses. If the condition is satisfied, the first program is executed. Otherwise, the second program is executed.\n- $\\texttt u$ (\"until\") followed by a single-letter condition, and a program in parentheses. If the condition is satisfied, nothing is done. Otherwise, the program is executed and then the command is repeated.\n\nA condition can be either '$b$', which is satisfied if and only if there is a barrier in the next square in Karel's current heading, or one of the four directional letters `n`, `s`, `e`, or `w`, which is satisfied if and only if Karel's current heading is north, south, east, or west, respectively.\n\n\nFor instance, a simple program `ub(m)` can be understood to mean: “keep moving forward until there is a barrier,\" while `un(l)` means \"turn to the north.\" A procedure definition `R=lll` defines a new procedure `R` which effectively means \"turn right.\"\n", "inputFormat": "The first line of input contains four integers $r, c, d$ and $e$, where $r$ and $c$ $(1 \\leq r, c \\leq 40)$ are the dimensions of the grid in which Karel lives, $d$ $(0 \\leq d \\leq 26)$ is the number of procedure definitions, and $e$ $(1 \\leq e \\leq 10)$ is the number of programs to be executed.\n\nThen follow $r$ lines describing the grid (running north to south), each containing c characters (running west to east), each character being either `.` (denoting a free square) or `#` (denoting a barrier). All squares outside this given area are considered barriers, which means Karel may never leave the area.\n\nEach of the next $d$ lines contains a procedure definition, associating a procedure name (one uppercase letter) with a program forming the procedure body. No procedure name is defined more than once. Procedure bodies may contain invocations of procedures that have not yet been defined.\n\nThe last $2e$ lines describe the programs to be executed. Each such description consists of a pair of lines. The first line of each pair contains two integers $i$ and $j$ and a character $h$, where $i$ $(1 \\leq i\\leq r)$ is the row and $j$ $(1 \\leq j \\leq c)$ is the column of Karel's initial position, and $h \\in \\{ \\texttt n, \\texttt s, \\texttt e, \\texttt w\\}$ represents Karel's initial heading. It is guaranteed that the initial position is a free square. The second line of each pair contains a program to be executed from that initial position.\n\nAll procedure bodies and all programs to be executed are at least $1$ and at most $100$ characters long, syntactically correct, and only contain invocations of procedures that are defined. The lines with procedure definitions and programs to be executed contain no whitespace characters.\n", "outputFormat": "For each program execution, output the final position of Karel after the complete program is executed from the respective initial position. Follow the format used to describe initial positions, that is, two numbers and a directional character. If a particular execution never terminates, output `inf` instead.\n", "hint": "Source: ICPC World Finals 2019.", "locale": "en", "translations": {"en": {"title": "[ICPC 2019 WF] Karel the Robot", "background": "### Warning: If you submit a malicious program, you will be banned.\n### 警告：恶意提交本题将被封号。", "description": "Did you know that the word \"robot\" is almost 100 years old? It was first introduced in 1920, in the science-fiction theatrical play $R.U.R.$ , written by Karel Capek. As a tribute to this Czech writer, an educational programming language was named Karel many years later at Stanford University. Your task is to implement an interpreter of a simplified version of this programming language.\n\nThe Karel programming language controls a robot named Karel, who lives in a grid of unit squares. Some of the squares are free, while others contain a barrier. Karel always occupies one of the free squares and faces one of the four cardinal directions. The two basic commands are \"move forward\" and \"turn left.\" The language also provides simple conditional and looping statements. The main educational potential of the language lies in the possibility of defining new procedures for more complex tasks.\n\nOur simplified version of the language can be described by the following grammar:\n\n```plain\n<program> := \"\" | <command> <program>\n<command> := \"m\" | \"l\" | <proc-call> |\n             \"i\" <condition> \"(\" <program> \")(\" <program> \")\" |\n             \"u\" <condition> \"(\" <program> \")\"\n<condition> := \"b\" | \"n\" | \"s\" | \"e\" | \"w\"\n<proc-call> := <uppercase-letter>\n<proc-def> := <uppercase-letter> \"=\" <program>\n```\nThere are five types of commands:\n\n- $\\texttt m$ (\"move forward\") advances Karel's position by one grid square in its current heading, unless there is a barrier, in which case the command has no effect.\n- $\\texttt l$ (\"turn left\") makes Karel turn left $90$ degrees.\n- $\\texttt X$ where $\\texttt X$ is any uppercase letter, invokes the procedure named $\\texttt X$. \n- $\\texttt i$ (\"if\") followed by a single-letter condition, and two programs in parentheses. If the condition is satisfied, the first program is executed. Otherwise, the second program is executed.\n- $\\texttt u$ (\"until\") followed by a single-letter condition, and a program in parentheses. If the condition is satisfied, nothing is done. Otherwise, the program is executed and then the command is repeated.\n\nA condition can be either '$b$', which is satisfied if and only if there is a barrier in the next square in Karel's current heading, or one of the four directional letters `n`, `s`, `e`, or `w`, which is satisfied if and only if Karel's current heading is north, south, east, or west, respectively.\n\n\nFor instance, a simple program `ub(m)` can be understood to mean: “keep moving forward until there is a barrier,\" while `un(l)` means \"turn to the north.\" A procedure definition `R=lll` defines a new procedure `R` which effectively means \"turn right.\"\n", "inputFormat": "The first line of input contains four integers $r, c, d$ and $e$, where $r$ and $c$ $(1 \\leq r, c \\leq 40)$ are the dimensions of the grid in which Karel lives, $d$ $(0 \\leq d \\leq 26)$ is the number of procedure definitions, and $e$ $(1 \\leq e \\leq 10)$ is the number of programs to be executed.\n\nThen follow $r$ lines describing the grid (running north to south), each containing c characters (running west to east), each character being either `.` (denoting a free square) or `#` (denoting a barrier). All squares outside this given area are considered barriers, which means Karel may never leave the area.\n\nEach of the next $d$ lines contains a procedure definition, associating a procedure name (one uppercase letter) with a program forming the procedure body. No procedure name is defined more than once. Procedure bodies may contain invocations of procedures that have not yet been defined.\n\nThe last $2e$ lines describe the programs to be executed. Each such description consists of a pair of lines. The first line of each pair contains two integers $i$ and $j$ and a character $h$, where $i$ $(1 \\leq i\\leq r)$ is the row and $j$ $(1 \\leq j \\leq c)$ is the column of Karel's initial position, and $h \\in \\{ \\texttt n, \\texttt s, \\texttt e, \\texttt w\\}$ represents Karel's initial heading. It is guaranteed that the initial position is a free square. The second line of each pair contains a program to be executed from that initial position.\n\nAll procedure bodies and all programs to be executed are at least $1$ and at most $100$ characters long, syntactically correct, and only contain invocations of procedures that are defined. The lines with procedure definitions and programs to be executed contain no whitespace characters.\n", "outputFormat": "For each program execution, output the final position of Karel after the complete program is executed from the respective initial position. Follow the format used to describe initial positions, that is, two numbers and a directional character. If a particular execution never terminates, output `inf` instead.\n", "hint": "Source: ICPC World Finals 2019.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2019 WF] Karel the Robot", "background": "", "description": "你知道“机器人”这个词已经快 100 年了吗？它首次出现在 1920 年，由 Karel Capek 编写的科幻戏剧 $R.U.R.$ 中。为了向这位捷克作家致敬，许多年后斯坦福大学将一种教育编程语言命名为 Karel。你的任务是实现这种编程语言的简化版本的解释器。\n\nKarel 编程语言控制一个名叫 Karel 的机器人，它生活在一个单位方格的网格中。一些方格是空的，而另一些则包含障碍物。Karel 总是占据一个空的方格，并面向四个基本方向之一。两个基本命令是“前进”和“左转”。该语言还提供简单的条件和循环语句。该语言的主要教育潜力在于可以定义新的过程来完成更复杂的任务。\n\n我们的简化版本的语言可以通过以下语法描述：\n\n```plain\n<program> := \"\" | <command> <program>\n<command> := \"m\" | \"l\" | <proc-call> |\n             \"i\" <condition> \"(\" <program> \")(\" <program> \")\" |\n             \"u\" <condition> \"(\" <program> \")\"\n<condition> := \"b\" | \"n\" | \"s\" | \"e\" | \"w\"\n<proc-call> := <uppercase-letter>\n<proc-def> := <uppercase-letter> \"=\" <program>\n```\n\n有五种类型的命令：\n\n- $\\texttt m$（“前进”）使 Karel 在其当前方向上前进一个网格单元，除非前方有障碍物，在这种情况下命令无效。\n- $\\texttt l$（“左转”）使 Karel 左转 $90$ 度。\n- $\\texttt X$，其中 $\\texttt X$ 是任何大写字母，调用名为 $\\texttt X$ 的过程。\n- $\\texttt i$（“如果”）后跟一个单字母条件和两个括号中的程序。如果条件满足，则执行第一个程序。否则，执行第二个程序。\n- $\\texttt u$（“直到”）后跟一个单字母条件和一个括号中的程序。如果条件满足，则不执行任何操作。否则，执行程序，然后重复该命令。\n\n条件可以是 '$b$'，当且仅当在 Karel 当前方向的下一个方格中有障碍物时满足，或者是四个方向字母之一 `n`、`s`、`e` 或 `w`，当且仅当 Karel 当前方向分别为北、南、东或西时满足。\n\n例如，一个简单的程序 `ub(m)` 可以理解为：“一直前进直到遇到障碍物”，而 `un(l)` 意味着“转向北”。过程定义 `R=lll` 定义了一个新过程 `R`，其有效含义是“右转”。", "inputFormat": "输入的第一行包含四个整数 $r, c, d$ 和 $e$，其中 $r$ 和 $c$ $(1 \\leq r, c \\leq 40)$ 是 Karel 所在网格的维度，$d$ $(0 \\leq d \\leq 26)$ 是过程定义的数量，$e$ $(1 \\leq e \\leq 10)$ 是要执行的程序数量。\n\n接下来是 $r$ 行描述网格（从北到南），每行包含 $c$ 个字符（从西到东），每个字符要么是 `.`（表示空方格），要么是 `#`（表示障碍物）。该给定区域外的所有方格都被视为障碍物，这意味着 Karel 永远不能离开该区域。\n\n接下来的 $d$ 行中的每一行包含一个过程定义，将一个过程名称（一个大写字母）与形成过程主体的程序关联。没有过程名称被定义多于一次。过程主体可以包含尚未定义的过程调用。\n\n最后 $2e$ 行描述要执行的程序。每个这样的描述由一对行组成。每对的第一行包含两个整数 $i$ 和 $j$ 以及一个字符 $h$，其中 $i$ $(1 \\leq i \\leq r)$ 是行，$j$ $(1 \\leq j \\leq c)$ 是 Karel 的初始位置的列，$h \\in \\{ \\texttt n, \\texttt s, \\texttt e, \\texttt w\\}$ 表示 Karel 的初始方向。保证初始位置是一个空方格。每对的第二行包含一个要从该初始位置执行的程序。\n\n所有过程主体和所有要执行的程序长度至少为 $1$ 且最多为 $100$ 个字符，语法正确，并且只包含已定义的过程调用。包含过程定义和要执行的程序的行不包含空格字符。", "outputFormat": "对于每个程序执行，输出从各自初始位置执行完整程序后 Karel 的最终位置。遵循用于描述初始位置的格式，即两个数字和一个方向字符。如果某个执行永远不会终止，则输出 `inf`。", "hint": "来源：ICPC 世界总决赛 2019。\n\n题面翻译由 ChatGPT-4o 提供。", "locale": "zh-CN"}}}
{"pid": "P6260", "type": "P", "difficulty": 6, "samples": [["3 3\n2 2 2\n4 2 1\n4 4 1", "1\n2\n2"], ["6 4\n3 1 2 2\n4 3 2 2\n6 6 3 2\n7 3 4 3\n3 4 2 4\n2 3 3 5", "1\n2\n5\n5\n4\n3\n"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "O2优化", "ICPC", "WF"], "title": "[ICPC 2019 WF] Miniature Golf", "background": "### Warning: If you submit a malicious program, you will be banned.\n### 警告：恶意提交本题将被封号。\n", "description": "A group of friends has just played a round of miniature golf. Miniature golf courses consist of a number of holes. Each player takes a turn to play each hole by hitting a ball repeatedly until it drops into the hole.\nA player's score on that hole is the number of times they hit the ball. \nTo prevent incompetent players slowing down the game too much, there is also an upper limit $l$ (a positive integer) on the score: if a player has hit the ball $l$ times without the ball dropping into the hole, the score for that hole is recorded as $l$ and that player's turn is over. The total score of each player is simply the sum of their scores on all the holes. Naturally, a lower score is considered better.\n\nThere is only one problem: none of the players can remember the value of the integer $l$. They decide that they will not apply any upper limit while playing, allowing each player to keep playing until the ball\ndrops into the hole. After the game they intend to look up the value of $l$ and adjust the scores, replacing any score on a hole that is larger than $l$ with $l$.\n\nThe game has just finished, but the players have not yet looked up $l$. They wonder what their best possible ranks are. For this problem, the rank of a player is the number of players who achieved an equal or lower total score after the scores are adjusted with $l$. For example, if the adjusted scores of the players are $3, 5, 5, 4,$ and $3$, then their ranks are $2, 5, 5, 3$ and $2$ respectively.\n\nGiven the scores of the players on each hole, determine the smallest possible rank for each player.", "inputFormat": "The first line of input contains two integers $p$ and $h$, where $p$ $(2 \\leq p \\leq 500)$ is the number of players and $h$ $(1 \\leq h \\leq 50)$ is the number of holes. The next $p$ lines each contain $h$ positive integers. The $j^{th}$ number on the $i^{th}$ of these lines is the score for player $i$ on hole $j$, and does not exceed $10^9$.\n", "outputFormat": "Output a line with the minimum possible rank for each player, in the same order as players are listed in the input.", "hint": "Source: ICPC World Finals 2019 Problem J: Miniature Golf.", "locale": "en", "translations": {"en": {"title": "[ICPC 2019 WF] Miniature Golf", "background": "### Warning: If you submit a malicious program, you will be banned.\n### 警告：恶意提交本题将被封号。\n", "description": "A group of friends has just played a round of miniature golf. Miniature golf courses consist of a number of holes. Each player takes a turn to play each hole by hitting a ball repeatedly until it drops into the hole.\nA player's score on that hole is the number of times they hit the ball. \nTo prevent incompetent players slowing down the game too much, there is also an upper limit $l$ (a positive integer) on the score: if a player has hit the ball $l$ times without the ball dropping into the hole, the score for that hole is recorded as $l$ and that player's turn is over. The total score of each player is simply the sum of their scores on all the holes. Naturally, a lower score is considered better.\n\nThere is only one problem: none of the players can remember the value of the integer $l$. They decide that they will not apply any upper limit while playing, allowing each player to keep playing until the ball\ndrops into the hole. After the game they intend to look up the value of $l$ and adjust the scores, replacing any score on a hole that is larger than $l$ with $l$.\n\nThe game has just finished, but the players have not yet looked up $l$. They wonder what their best possible ranks are. For this problem, the rank of a player is the number of players who achieved an equal or lower total score after the scores are adjusted with $l$. For example, if the adjusted scores of the players are $3, 5, 5, 4,$ and $3$, then their ranks are $2, 5, 5, 3$ and $2$ respectively.\n\nGiven the scores of the players on each hole, determine the smallest possible rank for each player.", "inputFormat": "The first line of input contains two integers $p$ and $h$, where $p$ $(2 \\leq p \\leq 500)$ is the number of players and $h$ $(1 \\leq h \\leq 50)$ is the number of holes. The next $p$ lines each contain $h$ positive integers. The $j^{th}$ number on the $i^{th}$ of these lines is the score for player $i$ on hole $j$, and does not exceed $10^9$.\n", "outputFormat": "Output a line with the minimum possible rank for each player, in the same order as players are listed in the input.", "hint": "Source: ICPC World Finals 2019 Problem J: Miniature Golf.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2019 WF] Miniature Golf", "background": "", "description": "几个朋友玩了一场小型的高尔夫。这种小型的高尔夫是由若干个洞组成的。每个玩家轮流玩这个游戏，不停地击球直到球落到每个洞里。玩家在一个洞上的得分是他击球的次数。为了防止捣乱的玩家把游戏速度放慢太多，游戏规则中也会给一个上限$l$（一个正整数）来控制分数：如果一个玩家在一个洞上已经击球$l$次，但是球还没有落到洞里，那么这个玩家在这个洞上的得分就是$l$，并且这个玩家的回合就结束了。一个玩家的总得分就是他在各个洞上的得分之和。自然地，在这个游戏中，分越低越好。\n\n但是有一个问题：没有玩家记得$l$的值。玩家们决定在玩的时候不设置$l$的值，允许每个玩家不断击球，直到球掉到洞里。玩完游戏，他们准备设置$l$的值，并更改那些在洞上的分数大于$l$的值。\n\n游戏结束了，但他们还没有设置$l$。他们想知道自己的最佳排名是什么。一个人的排名是在所有人中，得分比这个人低或和这个人相等的人数（包含自己）。比如，当五个人的得分分别是 $3,5,5,4,3$，那么他们的排名就是 $2,5,5,3,2$。\n\n给你每个玩家在每个洞上的得分，为每一个玩家求出最小的可能的排名。", "inputFormat": "第一行：两个整数 $p$ 和 $h$，$p$（$2 \\le p \\le 500$）是玩家个数，$h$（$1 \\le h \\le 50$）是洞的个数。\n\n接下来$p$行，每行$h$个正整数，第$i$行第$j$列的数表示第$i$个玩家在第$j$个洞上的得分，这些数都不会超过$10^9$。", "outputFormat": "输出 $p$ 行，每行一个正整数，第 $i$ 行表示第 $i$ 个玩家的最小排名。", "hint": "来源：ICPC World Finals 2019 Problem J \n\n题目名称：Miniature Golf", "locale": "zh-CN"}}}
{"pid": "P6261", "type": "P", "difficulty": 7, "samples": [["4\n1 2 3\n6 2 3\n10 2 3\n16 3 4", "0.4\n0\n0.2\n0.171428571429\n0.228571428571"], ["6\n4 1 5\n9 8 7\n13 3 5\n21 5 7\n30 9 1\n2019 20 0", "0.166666666667\n0.466666666667\n0.150000000000\n0.108333333333\n0.091666666667\n0.016666666667\n0.000000000000"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2019", "Special Judge", "O2优化", "ICPC", "WF"], "title": "[ICPC 2019 WF] Traffic Blights", "background": "", "description": "Cars! Where do they come from? Where do they go? Nobody knows. They appear where roads have been built, as if out of nowhere. Some say that no two cars are alike. Some say that if you look closely, you can see the pale ghosts of miserable humans inside them, trapped forever—particularly in\nthe morning and late afternoon. What scientific eye could frame their fearful symmetry?\n\nWell, yours, hopefully. As part of your government's Urban Traffic Control department, you are trying to write a paper on local traffic congestion. It is too dangerous to observe cars in the wild, of course, but you have been given some data on the traffic lights along your town's Main Street, and you would like to do some theoretical calculations about how well-synchronized they are.\n\nMain Street is set out on a line, with traffic lights placed at various points along it. Each traffic light cycles between red and green with a fixed period, being red for $r$ seconds, then green for $g$ seconds, then red for $r$ seconds, and so on. The values of $r$ and $g$ may be different for different traffic lights. At time $0$, all the lights have just turned red.\n\nAssume that an \"ideal\" car mystically appears at the west end of Main Street at a uniformly random real-valued time in the interval $[0, 2019!]$ (where $k!$ is the product of the first $k$ positive integers), driving eastwards at a slow crawl of $1$ meter/second until it hits a red light. What is the probability that it will make it through all the lights without being forced to stop? If it does hit a red light, which one is it likely to hit first?\n\nWrite a program to answer these questions.", "inputFormat": "The first line of input contains an integer $n$ ($1 \\leq n \\leq 500$), the number of traffic lights. Each of the following $n$ lines contains three integers $x$, $r$, and $g$ describing a traffic light, where $x$ ($1 \\leq x \\leq 10^5$) is the position of the light along Main Street in meters, and $r$ and $g$ ($0 \\leq r, g$ and $1 \\leq r + g \\leq 100$) are the durations in seconds of the red and green portions of the light's period (so the light is red from time $0$ to $r$, from time $r + g$ to $2r + g$, and so on).\n\nThe west end of Main Street is at position $0$, and the lights are listed in order of strictly increasing position.", "outputFormat": "For each of the $n$ lights, output a line containing the probability that this light will be the first red light an \"ideal\" car hits. Then output a line containing the probability that an \"ideal\" car makes it all the way without stopping. Your answers should have an absolute error of at most $10^-6$.", "hint": "Source: ICPC 2019 World Finals.", "locale": "en", "translations": {"en": {"title": "[ICPC 2019 WF] Traffic Blights", "background": "", "description": "Cars! Where do they come from? Where do they go? Nobody knows. They appear where roads have been built, as if out of nowhere. Some say that no two cars are alike. Some say that if you look closely, you can see the pale ghosts of miserable humans inside them, trapped forever—particularly in\nthe morning and late afternoon. What scientific eye could frame their fearful symmetry?\n\nWell, yours, hopefully. As part of your government's Urban Traffic Control department, you are trying to write a paper on local traffic congestion. It is too dangerous to observe cars in the wild, of course, but you have been given some data on the traffic lights along your town's Main Street, and you would like to do some theoretical calculations about how well-synchronized they are.\n\nMain Street is set out on a line, with traffic lights placed at various points along it. Each traffic light cycles between red and green with a fixed period, being red for $r$ seconds, then green for $g$ seconds, then red for $r$ seconds, and so on. The values of $r$ and $g$ may be different for different traffic lights. At time $0$, all the lights have just turned red.\n\nAssume that an \"ideal\" car mystically appears at the west end of Main Street at a uniformly random real-valued time in the interval $[0, 2019!]$ (where $k!$ is the product of the first $k$ positive integers), driving eastwards at a slow crawl of $1$ meter/second until it hits a red light. What is the probability that it will make it through all the lights without being forced to stop? If it does hit a red light, which one is it likely to hit first?\n\nWrite a program to answer these questions.", "inputFormat": "The first line of input contains an integer $n$ ($1 \\leq n \\leq 500$), the number of traffic lights. Each of the following $n$ lines contains three integers $x$, $r$, and $g$ describing a traffic light, where $x$ ($1 \\leq x \\leq 10^5$) is the position of the light along Main Street in meters, and $r$ and $g$ ($0 \\leq r, g$ and $1 \\leq r + g \\leq 100$) are the durations in seconds of the red and green portions of the light's period (so the light is red from time $0$ to $r$, from time $r + g$ to $2r + g$, and so on).\n\nThe west end of Main Street is at position $0$, and the lights are listed in order of strictly increasing position.", "outputFormat": "For each of the $n$ lights, output a line containing the probability that this light will be the first red light an \"ideal\" car hits. Then output a line containing the probability that an \"ideal\" car makes it all the way without stopping. Your answers should have an absolute error of at most $10^-6$.", "hint": "Source: ICPC 2019 World Finals.", "locale": "en"}, "zh-CN": {"title": "[ICPC 2019 WF] Traffic Blights", "background": "", "description": "Main 街坐落在一条东西向的直线上，上面有若干位置互异的红绿灯。每个红绿灯以某个固定周期在红绿之间循环。更具体地，它会先持续 $r$ 秒的红灯，再持续 $g$ 秒的绿灯，再持续 $r$ 秒的红灯...如此往复。对于不同的红绿灯，$r$ 和 $g$ 的值可能不同。在时刻 $0$，所有的红绿灯都恰好刚变为红灯。\n\n假设此时有一辆“理想”汽车在前 $2019!$ 秒中的一个随机实数时刻神秘地出现在了 Main 街的最西端，向东以 $1~ \\rm m/s$ 龟速行驶，直到遇到第一个红灯时停下，那么它有多大的概率通过所有红绿灯？如果它停下来了，那么它在每个红绿灯处停下的概率有多大？", "inputFormat": "第一行一个整数 $n$（$1\\le n\\le 500$） 表示红绿灯的数量。\n\n接下来每行三个整数 $x,r,g$（$1\\le x \\le 10^5$，$0\\le r,g$ 且 $1\\le r+g\\le 100$）， 描述一个位置在从西往东 $x$ 米处的，红灯持续时间为 $r$，绿灯持续时间为 $g$ 的红绿灯。\n\n最西侧即 $x=0$ 处，保证 $x$ 严格递增。", "outputFormat": "前 $n$ 行第 $i$ 行每行输出一个实数表示在第 $i$ 个红绿灯停下的概率。\n\n第 $n + 1$ 行输出一个实数表示通过所有红绿灯的概率。\n\n你需要保证绝对误差不超过 $10^{-6}$.", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6262", "type": "P", "difficulty": 7, "samples": [["10 3 5 6", "273459417"], ["2 1 3 4", "21"], ["20010910 666 1 1", "773849796"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "集训队互测", "O2优化"], "title": "[集训队互测 2019] 神树大人挥动魔杖", "background": "### 警告：恶意提交本题将被封号。\n\n神树大人想要做一根魔杖，这样他就可以使用「鸽子固定咒」把神 J 固定住了。\n\n第一天，神树大人在自己身上找了一根木头。神树大人使用了树顶上连神 J 都够不到的树枝。由于这根木头不能被凡人所理解，所以神树大人称它为「迷之木」。\n\n第二天，神树大人需要为施法创造环境。于是神树大人花了数小时造了一个完整的魔法世界，由于这个世界不能被凡人所理解，所以神树大人称它为「大象世界」。\n\n第三天，神树大人需要对迷之木附魔。于是神树大人写了一段咒语并让它在大象世界里运行，由于这段咒语不能被凡人所理解，所以神树大人称它为「花之语」。\n\n神树大人邀请神 J 来到大象世界游玩，神 J 迟了若干天才到。神 J 见神树大人嘴里念念有词，便问道：「你在干什么？」神树大人立即掏出迷之木，对准神 J 大喊道：\n\n「system call Joker remove pigeon protection！system call Joker Δεσμευτική！system call Joker ログアウト禁止！...」\n\n神 J 立刻被固定住了。神树大人很满意，于是离开了大象世界，并命令神 J 留在里面做题。由于这些题不能被凡人所理解，所以神 J 只把简化版给了你。", "description": "有一排 $n$ 个格子，有 $m$ 个人，初始都在 $1$ 号格。\n\n每个人可以选择往前跳一格或者跳两格，跳一格的方法数为 $p$，跳两格的方法数为 $q$，跳出 $n$ 个格子则停止，注意在第 $n$ 个格子仍然能选择跳一或两格。\n\n你需要计算有多少种方法使得每个格子都至少被一个人踩过。", "inputFormat": "第一行输入四个整数，$n,m,p,q$。", "outputFormat": "输出答案对 $998244353$ 取模。", "hint": "#### 数据范围及约定\n\n- 对于 $100\\%$ 的数据，满足 $1 \\le n \\le 10^9$，$1 \\le m \\le 6 \\times 10^4$，$1 \\le p,q \\in [0,998244353)$。\n\n各子任务限制如下：\n\n- 子任务 $1$（ $20$ 分）：$1 \\le n \\le 10^9$，$1 \\le m \\le 100$；\n- 子任务 $2$（ $10$ 分）：$1 \\le n \\le 10^3$；\n- 子任务 $3$（ $10$ 分）：$1 \\le n \\le 10^5$；\n- 子任务 $4$（ $20$ 分）：$1 \\le n \\le 10^9$，$1 \\le m \\le 3 \\times 10^4$，$p=q=1$；\n- 子任务 $5$（ $40$ 分）：无特殊限制；", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[集训队互测 2019] 神树大人挥动魔杖", "background": "### 警告：恶意提交本题将被封号。\n\n神树大人想要做一根魔杖，这样他就可以使用「鸽子固定咒」把神 J 固定住了。\n\n第一天，神树大人在自己身上找了一根木头。神树大人使用了树顶上连神 J 都够不到的树枝。由于这根木头不能被凡人所理解，所以神树大人称它为「迷之木」。\n\n第二天，神树大人需要为施法创造环境。于是神树大人花了数小时造了一个完整的魔法世界，由于这个世界不能被凡人所理解，所以神树大人称它为「大象世界」。\n\n第三天，神树大人需要对迷之木附魔。于是神树大人写了一段咒语并让它在大象世界里运行，由于这段咒语不能被凡人所理解，所以神树大人称它为「花之语」。\n\n神树大人邀请神 J 来到大象世界游玩，神 J 迟了若干天才到。神 J 见神树大人嘴里念念有词，便问道：「你在干什么？」神树大人立即掏出迷之木，对准神 J 大喊道：\n\n「system call Joker remove pigeon protection！system call Joker Δεσμευτική！system call Joker ログアウト禁止！...」\n\n神 J 立刻被固定住了。神树大人很满意，于是离开了大象世界，并命令神 J 留在里面做题。由于这些题不能被凡人所理解，所以神 J 只把简化版给了你。", "description": "有一排 $n$ 个格子，有 $m$ 个人，初始都在 $1$ 号格。\n\n每个人可以选择往前跳一格或者跳两格，跳一格的方法数为 $p$，跳两格的方法数为 $q$，跳出 $n$ 个格子则停止，注意在第 $n$ 个格子仍然能选择跳一或两格。\n\n你需要计算有多少种方法使得每个格子都至少被一个人踩过。", "inputFormat": "第一行输入四个整数，$n,m,p,q$。", "outputFormat": "输出答案对 $998244353$ 取模。", "hint": "#### 数据范围及约定\n\n- 对于 $100\\%$ 的数据，满足 $1 \\le n \\le 10^9$，$1 \\le m \\le 6 \\times 10^4$，$1 \\le p,q \\in [0,998244353)$。\n\n各子任务限制如下：\n\n- 子任务 $1$（ $20$ 分）：$1 \\le n \\le 10^9$，$1 \\le m \\le 100$；\n- 子任务 $2$（ $10$ 分）：$1 \\le n \\le 10^3$；\n- 子任务 $3$（ $10$ 分）：$1 \\le n \\le 10^5$；\n- 子任务 $4$（ $20$ 分）：$1 \\le n \\le 10^9$，$1 \\le m \\le 3 \\times 10^4$，$p=q=1$；\n- 子任务 $5$（ $40$ 分）：无特殊限制；", "locale": "zh-CN"}}}
{"pid": "P6263", "type": "P", "difficulty": 1, "samples": [["AON=BOO;", "1\n0\n0\n1\n1\n0\n3\n2\n"], ["PRINT'NY'[NASLA]", "2\n1\n0\n2\n4\n1\n1\n5"], ["VIDI,KO,JE,DOSA", "1\n1\n3\n1\n1\n6\n2 \n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["字符串", "2014", "COCI（克罗地亚）"], "title": "[COCI 2014/2015 #3] STROJOPIS", "background": null, "description": "正确的打字正成为文化的重要组成部分。如果你仍然没有使用所有的十根手指来打字，你必须重新学习打字——然后你会打字更快，感觉更舒适和愉快。\n\n有很多网站教你正确打字。下图描述了基本原理：用同一根手指按所需的键是同一颜色的。黄色键需要用小指按下，蓝色键需要用无名指，绿色键需要用中指，红色键需要用食指。自然，左手按键盘的左侧（从 `5`、`T`、`G`、`B` 开始向左的键），右手按右侧（从 `6`、`Y`、`H`、`N` 开始向右的键），拇指负责空格。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qhsm2dkz.png)\n\n您的任务是输出每根手指（拇指除外）正确输入给定字符串的分别按下的次数。", "inputFormat": "仅一行一个字符串 $s$。字符串不包含空格，只包含上面图像中包含的字符。", "outputFormat": "输出必须由八行组成，每行一个整数，表示**从左到右**观察到的每个手指的按键次数（拇指除外）。", "hint": "#### 数据规模与约定\n\n令 $|s|$ 表示输入字符串的长度，则对于 $100\\%$ 的数据，有 $1\\le |s|\\le 50$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2014/2015 #3] STROJOPIS", "background": null, "description": "正确的打字正成为文化的重要组成部分。如果你仍然没有使用所有的十根手指来打字，你必须重新学习打字——然后你会打字更快，感觉更舒适和愉快。\n\n有很多网站教你正确打字。下图描述了基本原理：用同一根手指按所需的键是同一颜色的。黄色键需要用小指按下，蓝色键需要用无名指，绿色键需要用中指，红色键需要用食指。自然，左手按键盘的左侧（从 `5`、`T`、`G`、`B` 开始向左的键），右手按右侧（从 `6`、`Y`、`H`、`N` 开始向右的键），拇指负责空格。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qhsm2dkz.png)\n\n您的任务是输出每根手指（拇指除外）正确输入给定字符串的分别按下的次数。", "inputFormat": "仅一行一个字符串 $s$。字符串不包含空格，只包含上面图像中包含的字符。", "outputFormat": "输出必须由八行组成，每行一个整数，表示**从左到右**观察到的每个手指的按键次数（拇指除外）。", "hint": "#### 数据规模与约定\n\n令 $|s|$ 表示输入字符串的长度，则对于 $100\\%$ 的数据，有 $1\\le |s|\\le 50$。", "locale": "zh-CN"}}}
{"pid": "P6264", "type": "P", "difficulty": 3, "samples": [["3 4 2\n1 2\n2 3\n3 2", "1"], ["3 3 1\n1 2\n2 3\n3 1", "-1"], ["4 5 2\n1 3\n2 3\n3 2\n5 1", "3"]], "limits": {"time": [800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["图论", "2014", "O2优化", "COCI（克罗地亚）"], "title": "[COCI 2014/2015 #3] DOM", "background": "", "description": "在一个养老院里，$n$ 位老人正在看电视。这个电视节目由 $m$ 个频道组成，数字从 $1$ 到 $m$ 不等。每个老人都有自己喜欢和讨厌的电视频道。\n\n如果电视正在播放某个老人讨厌的频道，他会站起来，慢慢走向电视机，把频道换成他最喜欢的，然后回到舒适的椅子上。如果有多个老人讨厌现在的频道，他们中最年轻的会站起来，把频道换成他最喜欢的，其余的人都会坐着。\n\n当然，在一次更换频道后，另一位老人可能会觉得新频道无法忍受，所以他会更换该频道。鉴于老人们很顽固，这种情况可能会无限期地持续下去。\n\n对于老人们最喜欢和讨厌的频道以及电视上的初始频道，确定老人们保持快乐所需的频道更改次数。", "inputFormat": "输入的第一行包含三个整数 $n,m$ 和 $p$，分别表示养老院里老人的数量，  电视频道的数量和在电视上显示的初始频道。\n\n以下 $n$ 行中的每一行都包含两个整数 $a_i$ 和 $b_i$，分别表示每个老人最喜欢和最讨厌的频道。\n\n老人的输入顺序是按年龄从小到大排列的。", "outputFormat": "仅一行，输出必须包含所需的频道更改数。如果更改无限期地继续，则输出 `-1`。", "hint": "#### 样例输入输出 1 解释\n最初，电视上是 $2$ 频道。这个频道惹恼了最年轻和最年长的老人，所以最年轻的人站起来，把频道他最喜欢的改成 $1$ 频道，这样每个人都可以一起看 $1$ 频道。\n#### 数据规模与约定\n\n- 对于 $50\\%$ 的数据，保证 $1\\le n,m\\le 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1\\le n,m\\le 10^5$，$1\\le p\\le m$，$1\\le a_i, b_i\\le m$，$a_i \\neq b_i$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2014/2015 #3] DOM", "background": "", "description": "在一个养老院里，$n$ 位老人正在看电视。这个电视节目由 $m$ 个频道组成，数字从 $1$ 到 $m$ 不等。每个老人都有自己喜欢和讨厌的电视频道。\n\n如果电视正在播放某个老人讨厌的频道，他会站起来，慢慢走向电视机，把频道换成他最喜欢的，然后回到舒适的椅子上。如果有多个老人讨厌现在的频道，他们中最年轻的会站起来，把频道换成他最喜欢的，其余的人都会坐着。\n\n当然，在一次更换频道后，另一位老人可能会觉得新频道无法忍受，所以他会更换该频道。鉴于老人们很顽固，这种情况可能会无限期地持续下去。\n\n对于老人们最喜欢和讨厌的频道以及电视上的初始频道，确定老人们保持快乐所需的频道更改次数。", "inputFormat": "输入的第一行包含三个整数 $n,m$ 和 $p$，分别表示养老院里老人的数量，  电视频道的数量和在电视上显示的初始频道。\n\n以下 $n$ 行中的每一行都包含两个整数 $a_i$ 和 $b_i$，分别表示每个老人最喜欢和最讨厌的频道。\n\n老人的输入顺序是按年龄从小到大排列的。", "outputFormat": "仅一行，输出必须包含所需的频道更改数。如果更改无限期地继续，则输出 `-1`。", "hint": "#### 样例输入输出 1 解释\n最初，电视上是 $2$ 频道。这个频道惹恼了最年轻和最年长的老人，所以最年轻的人站起来，把频道他最喜欢的改成 $1$ 频道，这样每个人都可以一起看 $1$ 频道。\n#### 数据规模与约定\n\n- 对于 $50\\%$ 的数据，保证 $1\\le n,m\\le 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1\\le n,m\\le 10^5$，$1\\le p\\le m$，$1\\le a_i, b_i\\le m$，$a_i \\neq b_i$。", "locale": "zh-CN"}}}
{"pid": "P6265", "type": "P", "difficulty": 3, "samples": [["3\n1 5 4\n7 11 3\n9 13 5\n", "28\n........####\n####....#..#\n#..#..###..#\n#..#..#....#\n#..#..#....#\n************\n"], ["6\n2 8 7\n5 13 5\n2 18 3\n23 26 5\n20 31 7\n21 30 10", "61\n...................#########.\n...................#.......#.\n...................#.......#.\n######............##.......##\n#....#............#.........#\n#....######.......#.........#\n#.........#.......#.........#\n#.........######..#.........#\n#..............#..#.........#\n#..............#..#.........#\n*****************************\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["2014", "O2优化", "COCI（克罗地亚）"], "title": "[COCI 2014/2015 #3] SILUETA", "background": "画家文森特有一次发现自己身处一个摩天大楼林立的大都市，于是他立刻下来画画，陶醉于这一美妙的景象。由于一些普通程序员无法理解的原因，文森特决定只画眼前摩天大楼的轮廓。不幸的是，在他完成这幅杰作一周后，这幅画被烧了。\n\n为了重建这幅画，文森特向各个方向寻求帮助，现在轮到你了！", "description": "从你的角度来看，文森特的摩天大楼是长方形的，它的边平行于坐标轴，一边位于横坐标上。图片的横坐标应该用字符 `*` 表示，摩天大楼的轮廓用 `#` 表示，其余部分用 `.` 表示。图像的左边缘必须以摩天大楼开始，而图像的右边缘必须以摩天大楼结束。此外，为了验证数学家得到的结果，输出给定轮廓的周长，而不是计算横坐标上的边。", "inputFormat": "第一行输入包含一个整数 $n$，即摩天大楼的数量。\n\n以下 $n$ 行中的每一行都包含三个整数 $l_i,r_i$ 和 $h_i$，分别表示第 $i$ 座摩天大楼的位置。在笛卡尔坐标系中，这座摩天大楼被认为是一个矩形，左下角在 $(l_i,0)$ 中，右上角在 $(r_i,h_i)$ 中。", "outputFormat": "第一行输出一个整数，表示摩天大楼轮廓的周长。\n\n接下来的 $h+1$ 行，其中 $h+1$ 是最高摩天大楼的高度，必须包含题目描述中描述的文森特的绘图。", "hint": "#### 样例输入输出 1 解释 \n\n如下图，蓝色表示摩天大楼的轮廓（字符 `#`），而黄色是文森特绘画中横坐标的一部分（字符 `*`）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ynl2n5os.png)\n\n#### 数据规模与约定\n\n- 对于 $50\\%$ 的数据，保证 $1\\le n\\le 100$，$1\\le l_i,r_i,h_i\\le 100$。\n- 对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^4$，$1\\le l_i,r_i,h_i\\le 10^3$，$3 \\leq r_i - l_i \\leq 10^3$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COCI 2014/2015 #3] SILUETA", "background": "画家文森特有一次发现自己身处一个摩天大楼林立的大都市，于是他立刻下来画画，陶醉于这一美妙的景象。由于一些普通程序员无法理解的原因，文森特决定只画眼前摩天大楼的轮廓。不幸的是，在他完成这幅杰作一周后，这幅画被烧了。\n\n为了重建这幅画，文森特向各个方向寻求帮助，现在轮到你了！", "description": "从你的角度来看，文森特的摩天大楼是长方形的，它的边平行于坐标轴，一边位于横坐标上。图片的横坐标应该用字符 `*` 表示，摩天大楼的轮廓用 `#` 表示，其余部分用 `.` 表示。图像的左边缘必须以摩天大楼开始，而图像的右边缘必须以摩天大楼结束。此外，为了验证数学家得到的结果，输出给定轮廓的周长，而不是计算横坐标上的边。", "inputFormat": "第一行输入包含一个整数 $n$，即摩天大楼的数量。\n\n以下 $n$ 行中的每一行都包含三个整数 $l_i,r_i$ 和 $h_i$，分别表示第 $i$ 座摩天大楼的位置。在笛卡尔坐标系中，这座摩天大楼被认为是一个矩形，左下角在 $(l_i,0)$ 中，右上角在 $(r_i,h_i)$ 中。", "outputFormat": "第一行输出一个整数，表示摩天大楼轮廓的周长。\n\n接下来的 $h+1$ 行，其中 $h+1$ 是最高摩天大楼的高度，必须包含题目描述中描述的文森特的绘图。", "hint": "#### 样例输入输出 1 解释 \n\n如下图，蓝色表示摩天大楼的轮廓（字符 `#`），而黄色是文森特绘画中横坐标的一部分（字符 `*`）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ynl2n5os.png)\n\n#### 数据规模与约定\n\n- 对于 $50\\%$ 的数据，保证 $1\\le n\\le 100$，$1\\le l_i,r_i,h_i\\le 100$。\n- 对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^4$，$1\\le l_i,r_i,h_i\\le 10^3$，$3 \\leq r_i - l_i \\leq 10^3$。", "locale": "zh-CN"}}}
{"pid": "P6267", "type": "P", "difficulty": 3, "samples": [["9", "3"], ["11", "2"], ["12", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2002", "各省省选", "上海"], "title": "[SHOI2002] N的连续数拆分", "background": "", "description": "所有的正整数均可以表示为一个、两个或者多个连续正整数的和。\n\n给定一个不超过 $9\\times 10^{14}$ 的正整数，求出它可以用几种不同的方法表示成连续正整数之和。例如给出 $9$，则有三种方式：$9,4+5,2+3+4$。", "inputFormat": "输入一个正整数 $n$，表示要被拆分的正整数。", "outputFormat": "输出方法个数。", "hint": "$n \\leq 9\\times 10^{14}$", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[SHOI2002] N的连续数拆分", "background": "", "description": "所有的正整数均可以表示为一个、两个或者多个连续正整数的和。\n\n给定一个不超过 $9\\times 10^{14}$ 的正整数，求出它可以用几种不同的方法表示成连续正整数之和。例如给出 $9$，则有三种方式：$9,4+5,2+3+4$。", "inputFormat": "输入一个正整数 $n$，表示要被拆分的正整数。", "outputFormat": "输出方法个数。", "hint": "$n \\leq 9\\times 10^{14}$", "locale": "zh-CN"}}}
{"pid": "P6268", "type": "P", "difficulty": 5, "samples": [["8 6\n0 2\n2 3\n3 5\n1 4\n1 6\n3 1", "5"], ["20 5\n5 2\n4 3\n18 17\n0 11\n13 3\n", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2002", "各省省选", "网络流", "上海", "图论建模", "二分图"], "title": "[SHOI2002] 舞会", "background": "", "description": "某学校要召开一个舞会。已知学校所有 $n$ 名学生中，有些学生曾经互相跳过舞。当然跳过舞的学生一定是一个男生和一个女生。在这个舞会上，要求被邀请的学生中的任何一对男生和女生互相都不能跳过舞。求这个舞会最多能邀请多少个学生参加。", "inputFormat": "输入的第一行是 $n$ 和 $m$ 。其中 $n$ 是可选的学生的总数， $m$ 是已知跳过舞的学生的对数 ( $n \\leq 1000$ ， $m \\leq 2000$ ）。\n\n然后有 $m$ 行，每行包括两个非负整数，表示这两个编号的学生曾经跳过舞。学生的编号从 $0$ 号到 $n - 1$ 号。", "outputFormat": "输出文件仅一行，为一个数字，即能够邀请的最多的学生数。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[SHOI2002] 舞会", "background": "", "description": "某学校要召开一个舞会。已知学校所有 $n$ 名学生中，有些学生曾经互相跳过舞。当然跳过舞的学生一定是一个男生和一个女生。在这个舞会上，要求被邀请的学生中的任何一对男生和女生互相都不能跳过舞。求这个舞会最多能邀请多少个学生参加。", "inputFormat": "输入的第一行是 $n$ 和 $m$ 。其中 $n$ 是可选的学生的总数， $m$ 是已知跳过舞的学生的对数 ( $n \\leq 1000$ ， $m \\leq 2000$ ）。\n\n然后有 $m$ 行，每行包括两个非负整数，表示这两个编号的学生曾经跳过舞。学生的编号从 $0$ 号到 $n - 1$ 号。", "outputFormat": "输出文件仅一行，为一个数字，即能够邀请的最多的学生数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6269", "type": "P", "difficulty": 3, "samples": [["6", "9"], ["11", "30"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "图论", "2002", "各省省选", "上海"], "title": "[SHOI2002] 空中都市", "background": "", "description": "在未来的空中都市中，有很多个小岛（城区）。现在要求在这些小岛之间架一座桥梁，每座桥是指在两个岛之间的通道。\n\n有个约定，如果 $A$ 与 $B$ 之间有桥，$B$ 与 $C$ 之间有桥，则 $A$ 与 $C$ 之间就不能再架桥了，即对于城市中的任意三个岛，不能在其中的两两之间都架上桥。在这样的约定下，要求架的桥的数量最多。当然不必考虑具体的空间结构问题。", "inputFormat": "输入文件只包含一行，其中仅包含一个非负整数 $n (0 \\leq n \\leq 1000)$，表示小岛的数量。", "outputFormat": "输出文件也只包含一行，即表示最多能架设的桥梁数量。", "hint": "", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[SHOI2002] 空中都市", "background": "", "description": "在未来的空中都市中，有很多个小岛（城区）。现在要求在这些小岛之间架一座桥梁，每座桥是指在两个岛之间的通道。\n\n有个约定，如果 $A$ 与 $B$ 之间有桥，$B$ 与 $C$ 之间有桥，则 $A$ 与 $C$ 之间就不能再架桥了，即对于城市中的任意三个岛，不能在其中的两两之间都架上桥。在这样的约定下，要求架的桥的数量最多。当然不必考虑具体的空间结构问题。", "inputFormat": "输入文件只包含一行，其中仅包含一个非负整数 $n (0 \\leq n \\leq 1000)$，表示小岛的数量。", "outputFormat": "输出文件也只包含一行，即表示最多能架设的桥梁数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P6270", "type": "P", "difficulty": 7, "samples": [["2\n3 7\n1 7\n1 6\n5 1\n2 7\n1 7\n7 1", "7 5\n0 1 5\n1 3 1\n0 1 7\n0 2 6\n0 3 1\n0 3\n0 1 7\n1 2 1\n0 2 1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2014", "Special Judge", "湖北"], "title": "[湖北省队互测 2014] 十万人的地铁", "background": "", "description": "从前有两个人叫陆仁甲和陆仁乙，他们去搭地铁。\n\n陆仁甲要从循礼门出发去广埠屯，而陆仁乙要从广埠屯出发去循礼门。\n\n作为地铁的脑残粉，陆仁甲和陆仁乙很清楚武汉地铁收费的规则。\n\n武汉地铁 $2$ 号线是一条直线，一共 $m$ 个地铁站，依次编号为 $1,\\cdots,m$。\n\n搭乘地铁需要刷一种叫武汉通的公交卡。进站时刷一次，出站时刷一次，在出站时会根据起始站和终点站之间的距离给武汉通扣费。即，如果设 $cost(i, j)$ 表示从编号为 $i$ 的地铁站进，从编号为 $j$ 的地铁站出的代价，则：\n\n$$cost(i,j)=|i-j|$$\n\n机智的陆仁甲和陆仁乙发现，乘车时的起始站是在进站刷卡时记录在武汉通上面的。而且计费跟乘车时间无关，你可以在 $i$ 站进站，在地铁上玩一整天后从 $j$ 站出站，还是付出 $cost(i,j)$ 的代价。\n\n于是陆仁甲和陆仁乙灵机一动，想出了一个绝妙的免费乘车方案。\n\n首先，陆仁甲从循礼门站进站出发，在中途的螃蟹岬站下车逗留。与此同时，陆仁乙从广埠屯站进站出发，也在中途的螃蟹岬站下车逗留。\n\n接着陆仁甲与陆仁乙在螃蟹岬站会面，交换武汉通。\n\n最后，陆仁甲乘地铁前往广埠屯站，此时陆仁甲的武汉通记录的起始站是广埠屯站，所以扣费 $0$ 元。\n\n陆仁乙乘地铁前往循礼门站，此时陆仁乙的武汉通记录的起始站是循礼门站，所以也扣费 $0$ 元。\n\n这样他们就完成了一次免费乘车。\n\n于是陆仁甲和陆仁乙开始思考：假设有 $n$ 个人来搭地铁，分别编号为 $1,\\cdots,n$，第 $i$ 人从第 $s_i$ 站出发去第 $e_i$ 站 $s_i\\ne e_i$，沿最短路坐地铁。即：\n\n- 若 $s_i<e_i$ 则依次经过 $s_i,s_i+1,\\cdots,e_i-1,e_i$。\n- 若 $s_i>e_i$ 则依次经过 $s_i,s_i-1,\\cdots,e_i+1,e_i$。\n\n那么假设他们足够聪明，会在中途下车换票，那么他们乘车的**最小**总代价是多少？\n\n具体乘车方式说明如下：\n\n- 一开始，所有人刷卡进站，第 $i$ 个人在第 $s_i$ 站。\n- 每次可以进行如下两个操作之一：\n- $0\\;x\\;y$：让编号为 $x$ 的人乘地铁到第 $y$ 站下车。**不允许绕路**，即必须往接近 $e_x$ 的方向乘车。而且**不允许从原地出发前往原地**，即 $y$ 不能是第 $x$ 个人现在所在的地铁站编号。你需要保证 $1\\le x\\le n,1\\le y\\le m$。\n- $1\\;x\\;y$：让编号为 $x$ 的人和编号为 $y$ 的人交换武汉通。注意**此时在同一个地铁站的两人**才可以交换车票。你需要保证 $1\\le x\\le n,1\\le y\\le n$。\n- 每次操作时，没有在操作中提到的人会在原地逗留。\n- 所有操作结束后，所有人一起刷卡出站。注意要保证**第 $\\boldsymbol i$ 个人此时在第 $\\boldsymbol{e_i}$ 站**。\n- 最后要使得所有人出站后，武汉通上扣费总和**最小**。求一个最小的乘车方案。\n\n陆仁甲和陆仁乙当然知道怎么做啦！但是他们想考考你……", "inputFormat": "第一行一个正整数 $T$，表示有几组数据。接下来有 $T$ 个数据，对于每组数据：\n\n第一行两个用空格隔开的正整数 $n,m$。表示有 $n$ 个人，$m$ 个地铁站。\n\n接下来 $n$ 行每行两个用空格隔开的正整数 $s_i,e_i$。表示第 $i$ 个人的起始站和终点站。（$s_i\\ne e_i,1\\le s_i,e_i\\le m$）", "outputFormat": "对于每组数据，输出一个最优方案。如果有多组都能让扣费总和最小，输出任意一组即可。\n\n第一行有两个用空格隔开的非负整数 $ans,s$，分别表示最小总代价和操作数。操作数不能太大，要满足 $s\\le400000$。\n\n接下来 $s$ 行每行三个正整数 $type\\;x\\;y$ 表示一个操作。（$type\\in\\{0,1\\}$，$x,y$ 的限制如前所述）", "hint": "对于所有数据，$T\\le6$。\n\n| 编号 | $\\boldsymbol n$ | $\\boldsymbol m$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $=2$ | $=1000$ |\n| $2$ | $=100$ | $=2$ |\n| $3$ | $=4$ | $=5$ |\n| $4$ | $\\le40$ | $\\le100$ |\n| $5\\sim6$ | $\\le100$ | $\\le1000$ |\n| $7\\sim8$ | $\\le2000$ | $\\le2\\times10^4$ |\n| $9$ | $\\le6\\times10^4$ | $\\le10^5$ |\n| $10$ | $\\le10^5$ | $\\le10^6$ |\n\n\n（本题纯属 VFleaKing 脑洞……亲测表示进站再出站扣费 $1.8$ 元，所以不要尝试模仿题目描述中的行为……）\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[湖北省队互测 2014] 十万人的地铁", "background": "", "description": "从前有两个人叫陆仁甲和陆仁乙，他们去搭地铁。\n\n陆仁甲要从循礼门出发去广埠屯，而陆仁乙要从广埠屯出发去循礼门。\n\n作为地铁的脑残粉，陆仁甲和陆仁乙很清楚武汉地铁收费的规则。\n\n武汉地铁 $2$ 号线是一条直线，一共 $m$ 个地铁站，依次编号为 $1,\\cdots,m$。\n\n搭乘地铁需要刷一种叫武汉通的公交卡。进站时刷一次，出站时刷一次，在出站时会根据起始站和终点站之间的距离给武汉通扣费。即，如果设 $cost(i, j)$ 表示从编号为 $i$ 的地铁站进，从编号为 $j$ 的地铁站出的代价，则：\n\n$$cost(i,j)=|i-j|$$\n\n机智的陆仁甲和陆仁乙发现，乘车时的起始站是在进站刷卡时记录在武汉通上面的。而且计费跟乘车时间无关，你可以在 $i$ 站进站，在地铁上玩一整天后从 $j$ 站出站，还是付出 $cost(i,j)$ 的代价。\n\n于是陆仁甲和陆仁乙灵机一动，想出了一个绝妙的免费乘车方案。\n\n首先，陆仁甲从循礼门站进站出发，在中途的螃蟹岬站下车逗留。与此同时，陆仁乙从广埠屯站进站出发，也在中途的螃蟹岬站下车逗留。\n\n接着陆仁甲与陆仁乙在螃蟹岬站会面，交换武汉通。\n\n最后，陆仁甲乘地铁前往广埠屯站，此时陆仁甲的武汉通记录的起始站是广埠屯站，所以扣费 $0$ 元。\n\n陆仁乙乘地铁前往循礼门站，此时陆仁乙的武汉通记录的起始站是循礼门站，所以也扣费 $0$ 元。\n\n这样他们就完成了一次免费乘车。\n\n于是陆仁甲和陆仁乙开始思考：假设有 $n$ 个人来搭地铁，分别编号为 $1,\\cdots,n$，第 $i$ 人从第 $s_i$ 站出发去第 $e_i$ 站 $s_i\\ne e_i$，沿最短路坐地铁。即：\n\n- 若 $s_i<e_i$ 则依次经过 $s_i,s_i+1,\\cdots,e_i-1,e_i$。\n- 若 $s_i>e_i$ 则依次经过 $s_i,s_i-1,\\cdots,e_i+1,e_i$。\n\n那么假设他们足够聪明，会在中途下车换票，那么他们乘车的**最小**总代价是多少？\n\n具体乘车方式说明如下：\n\n- 一开始，所有人刷卡进站，第 $i$ 个人在第 $s_i$ 站。\n- 每次可以进行如下两个操作之一：\n- $0\\;x\\;y$：让编号为 $x$ 的人乘地铁到第 $y$ 站下车。**不允许绕路**，即必须往接近 $e_x$ 的方向乘车。而且**不允许从原地出发前往原地**，即 $y$ 不能是第 $x$ 个人现在所在的地铁站编号。你需要保证 $1\\le x\\le n,1\\le y\\le m$。\n- $1\\;x\\;y$：让编号为 $x$ 的人和编号为 $y$ 的人交换武汉通。注意**此时在同一个地铁站的两人**才可以交换车票。你需要保证 $1\\le x\\le n,1\\le y\\le n$。\n- 每次操作时，没有在操作中提到的人会在原地逗留。\n- 所有操作结束后，所有人一起刷卡出站。注意要保证**第 $\\boldsymbol i$ 个人此时在第 $\\boldsymbol{e_i}$ 站**。\n- 最后要使得所有人出站后，武汉通上扣费总和**最小**。求一个最小的乘车方案。\n\n陆仁甲和陆仁乙当然知道怎么做啦！但是他们想考考你……", "inputFormat": "第一行一个正整数 $T$，表示有几组数据。接下来有 $T$ 个数据，对于每组数据：\n\n第一行两个用空格隔开的正整数 $n,m$。表示有 $n$ 个人，$m$ 个地铁站。\n\n接下来 $n$ 行每行两个用空格隔开的正整数 $s_i,e_i$。表示第 $i$ 个人的起始站和终点站。（$s_i\\ne e_i,1\\le s_i,e_i\\le m$）", "outputFormat": "对于每组数据，输出一个最优方案。如果有多组都能让扣费总和最小，输出任意一组即可。\n\n第一行有两个用空格隔开的非负整数 $ans,s$，分别表示最小总代价和操作数。操作数不能太大，要满足 $s\\le400000$。\n\n接下来 $s$ 行每行三个正整数 $type\\;x\\;y$ 表示一个操作。（$type\\in\\{0,1\\}$，$x,y$ 的限制如前所述）", "hint": "对于所有数据，$T\\le6$。\n\n| 编号 | $\\boldsymbol n$ | $\\boldsymbol m$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $=2$ | $=1000$ |\n| $2$ | $=100$ | $=2$ |\n| $3$ | $=4$ | $=5$ |\n| $4$ | $\\le40$ | $\\le100$ |\n| $5\\sim6$ | $\\le100$ | $\\le1000$ |\n| $7\\sim8$ | $\\le2000$ | $\\le2\\times10^4$ |\n| $9$ | $\\le6\\times10^4$ | $\\le10^5$ |\n| $10$ | $\\le10^5$ | $\\le10^6$ |\n\n\n（本题纯属 VFleaKing 脑洞……亲测表示进站再出站扣费 $1.8$ 元，所以不要尝试模仿题目描述中的行为……）\n", "locale": "zh-CN"}}}
{"pid": "P6271", "type": "P", "difficulty": 6, "samples": [["3 2 \n2 1 \n5 1", "1100"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "莫比乌斯反演", "湖北"], "title": "[湖北省队互测2014] 一个人的数论", "background": "题目来源：$2014$ 年湖北省队互测Week1\n\n资源来源：[链接](https://tieba.baidu.com/p/3050650090?red_tag=3002680446)", "description": "有一天 hjy96 想到了一个数论问题:\n\n对于一个非负整数 $d$ 和一个正整数 $n$，定义 $f_d(n)$ 为所有小于 $n$ 且与 $n$ 互质的正整数的 $d$ 次方之和。如 $f_3(10) = 1^3 +3^3 +7^3 +9^3$。\n\n现给定 $d, n$，求 $f_d(n)$ 的值。输出答案对 $10^9 + 7$ 取模后的结果。 \n\nhjy96 当然知道怎么做啦! 但是他想考考你......", "inputFormat": "由于 $n$ 可能很大，我们给出 $n$ 的质因数分解式。\n\n$$\nn=\\prod_{i=1}^{w} p_{i}^{\\alpha_{i}}\n$$\n\n第一行有用空格隔开的一个非负整数 $d$, 一个正整数 $w$。\n接下来 $w$ 行，每行有两个用空格隔开的正整数 $p_i$, $\\alpha_i$。(保证 $p_i$ 为素数且互不相同)", "outputFormat": "一行，一个非负整数表示 $f_d(n)$ 对 $10^9 + 7$ 取模后的结果。", "hint": "#### 数据规模与约定\n\n各测试点信息如下表\n\n| 编号 | $d$ | 特殊限制 |\n| :---: | :---: | :---------: |\n| 1 | $\\leq 100$ | $n \\leq 10^5$ |\n| 2 | $=0$ | 无 |\n| 3 | $=1$ | 无 |\n| 4 | $=2$ | 无 |\n| 5 | $\\leq 100$ | $w = 1$，$ \\alpha_1 = 1$ |\n| 6 | $\\leq 100$ | $w = 1$，$ \\alpha_1 = 1$ |\n| 7 | $\\leq 100$ | $ \\prod_{i = 1}^w (\\alpha_i + 1) \\leq 10^5$ |\n| 8 | $\\leq 100$ | $w \\leq 16$ |\n| 9 | $\\leq 100$ | 无 |\n| 10 | $\\leq 100$ | 无 |\n\n对于全部的测试点，保证 $1 \\leq w \\leq 10^3$，$2 \\leq p_i \\leq 10^9$，$1 \\leq \\alpha_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[湖北省队互测2014] 一个人的数论", "background": "题目来源：$2014$ 年湖北省队互测Week1\n\n资源来源：[链接](https://tieba.baidu.com/p/3050650090?red_tag=3002680446)", "description": "有一天 hjy96 想到了一个数论问题:\n\n对于一个非负整数 $d$ 和一个正整数 $n$，定义 $f_d(n)$ 为所有小于 $n$ 且与 $n$ 互质的正整数的 $d$ 次方之和。如 $f_3(10) = 1^3 +3^3 +7^3 +9^3$。\n\n现给定 $d, n$，求 $f_d(n)$ 的值。输出答案对 $10^9 + 7$ 取模后的结果。 \n\nhjy96 当然知道怎么做啦! 但是他想考考你......", "inputFormat": "由于 $n$ 可能很大，我们给出 $n$ 的质因数分解式。\n\n$$\nn=\\prod_{i=1}^{w} p_{i}^{\\alpha_{i}}\n$$\n\n第一行有用空格隔开的一个非负整数 $d$, 一个正整数 $w$。\n接下来 $w$ 行，每行有两个用空格隔开的正整数 $p_i$, $\\alpha_i$。(保证 $p_i$ 为素数且互不相同)", "outputFormat": "一行，一个非负整数表示 $f_d(n)$ 对 $10^9 + 7$ 取模后的结果。", "hint": "#### 数据规模与约定\n\n各测试点信息如下表\n\n| 编号 | $d$ | 特殊限制 |\n| :---: | :---: | :---------: |\n| 1 | $\\leq 100$ | $n \\leq 10^5$ |\n| 2 | $=0$ | 无 |\n| 3 | $=1$ | 无 |\n| 4 | $=2$ | 无 |\n| 5 | $\\leq 100$ | $w = 1$，$ \\alpha_1 = 1$ |\n| 6 | $\\leq 100$ | $w = 1$，$ \\alpha_1 = 1$ |\n| 7 | $\\leq 100$ | $ \\prod_{i = 1}^w (\\alpha_i + 1) \\leq 10^5$ |\n| 8 | $\\leq 100$ | $w \\leq 16$ |\n| 9 | $\\leq 100$ | 无 |\n| 10 | $\\leq 100$ | 无 |\n\n对于全部的测试点，保证 $1 \\leq w \\leq 10^3$，$2 \\leq p_i \\leq 10^9$，$1 \\leq \\alpha_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P6272", "type": "P", "difficulty": 7, "samples": [["5 10 \nC 1 1 1 \nC 2 1 2 \nQ 1 2 \nC 4 4 4 \nC 5 5 5 \nQ 4 5 \nQ 3 3 \nC 4 2 3 \nC 4 4 4 \nQ 3 4", "2\n4\n3\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2014", "湖北"], "title": "[湖北省队互测2014] 没有人的算术", "background": "题目来源：$2014$ 年湖北省队互测Week1\n\n资源来源：[链接](https://tieba.baidu.com/p/3050650090?red_tag=3002680446)", "description": "万物初始之前，宇宙是无边无际混沌的黑暗，只有上帝之灵穿行其间。\n\n上帝对这无边的黑暗十分不满，就一挥手说:“要有光”，于是世间就有了光。从此，世间 就有了昼与夜的交替。这是上帝创世的第一天。\n\n第二天，上帝仍不满意眼前空洞的景象，就一挥手说：“要有零”。于是世间出现了第一个数：$0$。\n\n第三天，上帝对只有 $0$ 很不满意，就一挥手说：“要有非零数”。于是上帝开始创造新数，每个新数用一个已经创造出来的数的有序对表示，即：\n\n$$\nx = (x_L, x_R)\n$$\n\n于是世间出现了 $(0, 0), (0, (0, 0)), ((0, 0), 0), ((0, 0), (0, 0)), ...$。到了晚上，各种各样千奇百怪的数在大地上奔腾。\n（注：上帝造的这个 “数” 与普通的自然数、有理数之类的不同，这种数是以如上所述的方式递归定义的，总是数对里面是数对，拆分到最后会得到不可再拆的 $0$）\n\n第四天，上帝看到各个数不分彼此，就一挥手说：“要有区别”。于是为了区分每个数，上帝定义等于：\n\n1.  $0 = 0$ 。\n\n2.  对于任意 $x_L, x_R, y_L, y_R$，若 $x_L = y_L$ 且 $x_R = y_R$，则 $(x_L, x_R) = (y_L, y_R)$。\n\n3.  对于任意 $x, y$，$x = y$ 当且仅当满足以上条件之一。反之记作 $x \\not = y$。\n\n第五天，上帝看到各个数乱成一团，就一挥手说：“要有序”。于是为了比较每个数，上帝定义小于：\n\n1. 对于任意 $x$，若 $x\\not = 0$，则 $0 < x$。\n2. 对于任意 $x_L, x_R, y_L, y_R$，若 $x_L < y_L$，则 $(x_L, x_R) < (y_L, y_R)$ 。\n3. 对于任意 $x_L, x_R, y_L, y_R$，若 $x_L = y_L$ 且 $x_R < y_R$，则 $(x_L, x_R) < (y_L, y_R)$。\n4. 对于任意 $x, y$，$x < y$ 当且仅当满足以上条件之一。反之记作 $x\\not < y$。\n\n在此基础上定义小于等于：$x ≤ y \\iff x < y$ 或 $x = y$ 。容易发现：\n\n1. $x ≤ y, y ≤ x ⇒ x = y$ 。\n2. $x ≤ y, y ≤ z ⇒ x ≤ z$ 。\n3. $x ≤ y$ 或 $y ≤ x$ 。\n\n进而定义：\n\n1. $x > y \\Longleftrightarrow  y < x$ 。\n2. $x ≥ y \\Longleftrightarrow   x\\not < y$。\n\n\f至此万物欣欣向荣，和睦一堂。\n\n第六天，由于之前沉迷与算术而忘记去造核酸和蛋白质，所以上帝没办法造人。但是上帝不甘心，就一挥手说：“要有跳蚤”，于是用泥巴捏出了神奇生物跳蚤。\n\n上帝用五天的时间造出天地万物，又在第六天造出了唯一的生命——跳蚤。上帝看到天地万物井然有序、生生不息，自己造的跳蚤正在开心地和数学玩耍，很高兴，便决定把第七天作为休息的日子。\n\n跳蚤每天的生活很简单。一天开始时，他会取一个长度为 $n$ 的数组 $a[1,2,\\cdots,n]$，初始时均为 $0$。\n\n接着他会不断地做下列两件事之一：\n\n1. 在头脑中产生三个正整数 $l, r, k$，然后把 $a[k]$ 重新赋值为 $(a[l], a[r])$ 。特别地，如果 $l = k$ 或 $r = k$ 也是合法的，这不会导致错误，因为跳蚤总是先默默算出 $(a[l], a[r])$ 再给 $a[k]$ 赋值。\n\n    保证 $1 ≤ l, r, k ≤ n$。\n\n2. 在头脑中产生两个正整数 $l, r$，然后计算 $a[l], a[l + 1], \\cdots, a[r − 1], a[r]$ 中的最大值。\n\n     保证 $1 ≤ l ≤ r ≤ n$。\n\n跳蚤当然知道怎么做啦！但是他想考考你……", "inputFormat": "第一行两个正整数 $n, m$，表示长度为 $n$ 的数组，共 $m$ 个操作。接下来 $m$ 行每行表示一个操作:\n\n1. `C l r k` : 赋值操作，执行 $ a[k] = (a[l], a[r])$ 。\n\n2. `Q l r`: 询问操作，计算 $a[l], a[l + 1], ..., a[r − 1], a[r]$ 中的最大值。输出最大值对应的下标。 如果有多个最大值那么取下标最小的那一个。", "outputFormat": "对于每个询问操作输出一行表示相应的结果。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/bj1dxhbv.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[湖北省队互测2014] 没有人的算术", "background": "题目来源：$2014$ 年湖北省队互测Week1\n\n资源来源：[链接](https://tieba.baidu.com/p/3050650090?red_tag=3002680446)", "description": "万物初始之前，宇宙是无边无际混沌的黑暗，只有上帝之灵穿行其间。\n\n上帝对这无边的黑暗十分不满，就一挥手说:“要有光”，于是世间就有了光。从此，世间 就有了昼与夜的交替。这是上帝创世的第一天。\n\n第二天，上帝仍不满意眼前空洞的景象，就一挥手说：“要有零”。于是世间出现了第一个数：$0$。\n\n第三天，上帝对只有 $0$ 很不满意，就一挥手说：“要有非零数”。于是上帝开始创造新数，每个新数用一个已经创造出来的数的有序对表示，即：\n\n$$\nx = (x_L, x_R)\n$$\n\n于是世间出现了 $(0, 0), (0, (0, 0)), ((0, 0), 0), ((0, 0), (0, 0)), ...$。到了晚上，各种各样千奇百怪的数在大地上奔腾。\n（注：上帝造的这个 “数” 与普通的自然数、有理数之类的不同，这种数是以如上所述的方式递归定义的，总是数对里面是数对，拆分到最后会得到不可再拆的 $0$）\n\n第四天，上帝看到各个数不分彼此，就一挥手说：“要有区别”。于是为了区分每个数，上帝定义等于：\n\n1.  $0 = 0$ 。\n\n2.  对于任意 $x_L, x_R, y_L, y_R$，若 $x_L = y_L$ 且 $x_R = y_R$，则 $(x_L, x_R) = (y_L, y_R)$。\n\n3.  对于任意 $x, y$，$x = y$ 当且仅当满足以上条件之一。反之记作 $x \\not = y$。\n\n第五天，上帝看到各个数乱成一团，就一挥手说：“要有序”。于是为了比较每个数，上帝定义小于：\n\n1. 对于任意 $x$，若 $x\\not = 0$，则 $0 < x$。\n2. 对于任意 $x_L, x_R, y_L, y_R$，若 $x_L < y_L$，则 $(x_L, x_R) < (y_L, y_R)$ 。\n3. 对于任意 $x_L, x_R, y_L, y_R$，若 $x_L = y_L$ 且 $x_R < y_R$，则 $(x_L, x_R) < (y_L, y_R)$。\n4. 对于任意 $x, y$，$x < y$ 当且仅当满足以上条件之一。反之记作 $x\\not < y$。\n\n在此基础上定义小于等于：$x ≤ y \\iff x < y$ 或 $x = y$ 。容易发现：\n\n1. $x ≤ y, y ≤ x ⇒ x = y$ 。\n2. $x ≤ y, y ≤ z ⇒ x ≤ z$ 。\n3. $x ≤ y$ 或 $y ≤ x$ 。\n\n进而定义：\n\n1. $x > y \\Longleftrightarrow  y < x$ 。\n2. $x ≥ y \\Longleftrightarrow   x\\not < y$。\n\n\f至此万物欣欣向荣，和睦一堂。\n\n第六天，由于之前沉迷与算术而忘记去造核酸和蛋白质，所以上帝没办法造人。但是上帝不甘心，就一挥手说：“要有跳蚤”，于是用泥巴捏出了神奇生物跳蚤。\n\n上帝用五天的时间造出天地万物，又在第六天造出了唯一的生命——跳蚤。上帝看到天地万物井然有序、生生不息，自己造的跳蚤正在开心地和数学玩耍，很高兴，便决定把第七天作为休息的日子。\n\n跳蚤每天的生活很简单。一天开始时，他会取一个长度为 $n$ 的数组 $a[1,2,\\cdots,n]$，初始时均为 $0$。\n\n接着他会不断地做下列两件事之一：\n\n1. 在头脑中产生三个正整数 $l, r, k$，然后把 $a[k]$ 重新赋值为 $(a[l], a[r])$ 。特别地，如果 $l = k$ 或 $r = k$ 也是合法的，这不会导致错误，因为跳蚤总是先默默算出 $(a[l], a[r])$ 再给 $a[k]$ 赋值。\n\n    保证 $1 ≤ l, r, k ≤ n$。\n\n2. 在头脑中产生两个正整数 $l, r$，然后计算 $a[l], a[l + 1], \\cdots, a[r − 1], a[r]$ 中的最大值。\n\n     保证 $1 ≤ l ≤ r ≤ n$。\n\n跳蚤当然知道怎么做啦！但是他想考考你……", "inputFormat": "第一行两个正整数 $n, m$，表示长度为 $n$ 的数组，共 $m$ 个操作。接下来 $m$ 行每行表示一个操作:\n\n1. `C l r k` : 赋值操作，执行 $ a[k] = (a[l], a[r])$ 。\n\n2. `Q l r`: 询问操作，计算 $a[l], a[l + 1], ..., a[r − 1], a[r]$ 中的最大值。输出最大值对应的下标。 如果有多个最大值那么取下标最小的那一个。", "outputFormat": "对于每个询问操作输出一行表示相应的结果。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/bj1dxhbv.png)", "locale": "zh-CN"}}}
{"pid": "P6273", "type": "P", "difficulty": 4, "samples": [["8\nabccbabc", "4"], ["7\nabcABCC", "1"], ["20\nSwSSSwwwwSwSwwSwwwwS", "22"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2017", "枚举", "eJOI（欧洲）", "前缀和"], "title": "[eJOI 2017] 魔法", "background": "", "description": "给定一个长度为 $n$ 的字符串 $S$。设 $S$ 中不同的字符数为 $k$ 。\n\n定义字符串的子串为该字符串某一连续段。\n\n而 ***有魔法的子串*** 被定义为 $S$ **的某一非空子串，满足该子串中不同的字符数为** $k$ **，且每个字符的出现的次数都相同**。\n\n你需要求出给定字符串 $S$ 的不同的 有魔法的子串 的个数。\n\n若两个子串的左右端点不同，则这两个子串不同。", "inputFormat": "第一行：一个整数 $n$ 表示字符串长度。\n\n第二行：一个字符串 $S$ 。", "outputFormat": "一个整数表示答案 $\\bmod (10^9+7)$ 的值。", "hint": "#### 【输入输出样例解释】\n\n**样例 1 解释**\n\n- 满足条件的子串有： $\\texttt{abc},\\texttt{cba},\\texttt{abc},\\texttt{abccba}$\n\n**样例 2 解释**\n\n- 仅子串 $\\texttt{abcABC}$ 为 有魔法的子串（区分大小写，即 $\\texttt{a}\\ne \\texttt{A}$）。\n\n**样例 3 解释**\n\n- 其中一个是 $\\texttt{SwSwwS}$。\n\n#### 【数据规模与约定】\n\n**本题采用多测试点捆绑测试，共有 4 个子任务**。\n\n- Subtask 1（10 points）：$2\\le n\\le 100$。\n- Subtask 2（20 points）：$2\\le n\\le 2\\times 10^3$。\n- Subtask 3（30 points）：$2\\le n\\le 10^5,k=2$ （即 $S$ 中只有两种字符）。\n- Subtask 4（40 points）：无其他限制。\n\n对于所有数据，保证 $2\\le n\\le 10^5$，字符集为 $ [\\texttt{a},\\texttt{z}] \\cup [\\texttt{A},\\texttt{Z}]$\n\n#### 【说明】\n\n原题来自：[eJOI 2017](www.ejoi.org) Problem A [Magic](http://ejoi.org/wp-content/themes/ejoi/assets/pdfs/tasks_day_1/EN/magic_statement-en.pdf)\n\n翻译提供：@[```_Wallace_```](https://www.luogu.com.cn/user/61430)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[eJOI 2017] 魔法", "background": "", "description": "给定一个长度为 $n$ 的字符串 $S$。设 $S$ 中不同的字符数为 $k$ 。\n\n定义字符串的子串为该字符串某一连续段。\n\n而 ***有魔法的子串*** 被定义为 $S$ **的某一非空子串，满足该子串中不同的字符数为** $k$ **，且每个字符的出现的次数都相同**。\n\n你需要求出给定字符串 $S$ 的不同的 有魔法的子串 的个数。\n\n若两个子串的左右端点不同，则这两个子串不同。", "inputFormat": "第一行：一个整数 $n$ 表示字符串长度。\n\n第二行：一个字符串 $S$ 。", "outputFormat": "一个整数表示答案 $\\bmod (10^9+7)$ 的值。", "hint": "#### 【输入输出样例解释】\n\n**样例 1 解释**\n\n- 满足条件的子串有： $\\texttt{abc},\\texttt{cba},\\texttt{abc},\\texttt{abccba}$\n\n**样例 2 解释**\n\n- 仅子串 $\\texttt{abcABC}$ 为 有魔法的子串（区分大小写，即 $\\texttt{a}\\ne \\texttt{A}$）。\n\n**样例 3 解释**\n\n- 其中一个是 $\\texttt{SwSwwS}$。\n\n#### 【数据规模与约定】\n\n**本题采用多测试点捆绑测试，共有 4 个子任务**。\n\n- Subtask 1（10 points）：$2\\le n\\le 100$。\n- Subtask 2（20 points）：$2\\le n\\le 2\\times 10^3$。\n- Subtask 3（30 points）：$2\\le n\\le 10^5,k=2$ （即 $S$ 中只有两种字符）。\n- Subtask 4（40 points）：无其他限制。\n\n对于所有数据，保证 $2\\le n\\le 10^5$，字符集为 $ [\\texttt{a},\\texttt{z}] \\cup [\\texttt{A},\\texttt{Z}]$\n\n#### 【说明】\n\n原题来自：[eJOI 2017](www.ejoi.org) Problem A [Magic](http://ejoi.org/wp-content/themes/ejoi/assets/pdfs/tasks_day_1/EN/magic_statement-en.pdf)\n\n翻译提供：@[```_Wallace_```](https://www.luogu.com.cn/user/61430)", "locale": "zh-CN"}}}
{"pid": "P6274", "type": "P", "difficulty": 5, "samples": [["6\n", "28"], ["203021", "33628"], ["60357056536", "907882"], ["12156144", "104757552"]], "limits": {"time": [650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650, 650], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2017", "eJOI（欧洲）"], "title": "[eJOI 2017] 六", "background": "", "description": "Elly 正在研究关于 正整数 $N$ 的一些性质，发现 $N$ 有不多于 $6$ 个不同的质因数。\n\n接下来，她以一种特定的方式来生成的一个列表，一开始列表为空。她先写下了 $N$ 的一个大于一的因数 $x$ ，加入列表前，她先要确保 在所有已经在列表中的数中， 不能有 **超过** $1$ **个** 数与 $x$ **不互质**。\n\n------------------------------\n\n举个例子，当 $N=12156144$ 时：\n\n合法的列表有： $ (42), (616, 6, 91, 23),(91, 616, 6, 23), (66, 7), (66, 7, 7, 23, 299, 66), \\\\(143, 13, 66),(42,12156144),\\text{etc.} $\n\n而不合法的有：之一是 $(5,11)$，原因是 $5$ 不是 $N$ 的因子；还有一个是 $ (66, 13, 143)$ ，原因是 $143$ 与其他两个数都不互质。\n\n-----------------------\n\n现在 Elly 希望你计算出给定的 $N$，可以生成几个不同的合法的列表。\n\n**若两个列表长度不同，或存在一个位置使得两个列表的该位置的值不同，那么我们说这两个列表不同的**。", "inputFormat": "一个整数：$N$。", "outputFormat": "一个整数，表示列表的个数 $\\bmod (10^9+7)$ 的值。", "hint": "#### 【输入输出样例解释】\n\n**样例 1 解释**\n\n满足条件的列表有：$(2), (2, 2),\n(2, 2, 3), (2, 2, 3, 3), (2, 3), (2, 3, 2), (2, 3, 2, 3), (2, 3, 3), (2, 3, 3, 2), \\\\ (2, 6), (2, 6,3), (3), (3, 2), (3, 2, 2), (3, 2, 2, 3), (3, 2, 3), (3, 2, 3, 2), (3, 3),\\\\ (3, 3, 2), (3, 3, 2,2), (3, 6), (3, 6, 2), (6), (6, 2), (6, 2, 3), (6, 3), (6, 3, 2), (6, 6)$\n\n以上共 $28$ 种。\n\n**样例 4 解释**\n\n真正的答案为 $14104757650$。\n\n输出 $14104757650 \\bmod (10^9+7)=104757552$\n\n#### 【数据规模与约定】\n\n- 对于所有数据，保证 $1\\le N\\le 10^{15}$\n- 对于约 $30\\%$ 的数据，保证 $N$ 至多有 $2$ 个质因数。\n- 对于约 $60\\%$ 的数据，保证 $N$ 至多有 $4$ 个质因数。\n- 对于 $100\\%$ 的数据，保证 $N$ 至多有 $6$ 个质因数。\n\n#### 【说明】\n\n原题来自：[eJOI 2017](www.ejoi.org) Problem B [Six](http://ejoi.org/wp-content/themes/ejoi/assets/pdfs/tasks_day_1/EN/six_statement-en.pdf)\n\n翻译提供：@[```_Wallace_```](https://www.luogu.com.cn/user/61430)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[eJOI 2017] 六", "background": "", "description": "Elly 正在研究关于 正整数 $N$ 的一些性质，发现 $N$ 有不多于 $6$ 个不同的质因数。\n\n接下来，她以一种特定的方式来生成的一个列表，一开始列表为空。她先写下了 $N$ 的一个大于一的因数 $x$ ，加入列表前，她先要确保 在所有已经在列表中的数中， 不能有 **超过** $1$ **个** 数与 $x$ **不互质**。\n\n------------------------------\n\n举个例子，当 $N=12156144$ 时：\n\n合法的列表有： $ (42), (616, 6, 91, 23),(91, 616, 6, 23), (66, 7), (66, 7, 7, 23, 299, 66), \\\\(143, 13, 66),(42,12156144),\\text{etc.} $\n\n而不合法的有：之一是 $(5,11)$，原因是 $5$ 不是 $N$ 的因子；还有一个是 $ (66, 13, 143)$ ，原因是 $143$ 与其他两个数都不互质。\n\n-----------------------\n\n现在 Elly 希望你计算出给定的 $N$，可以生成几个不同的合法的列表。\n\n**若两个列表长度不同，或存在一个位置使得两个列表的该位置的值不同，那么我们说这两个列表不同的**。", "inputFormat": "一个整数：$N$。", "outputFormat": "一个整数，表示列表的个数 $\\bmod (10^9+7)$ 的值。", "hint": "#### 【输入输出样例解释】\n\n**样例 1 解释**\n\n满足条件的列表有：$(2), (2, 2),\n(2, 2, 3), (2, 2, 3, 3), (2, 3), (2, 3, 2), (2, 3, 2, 3), (2, 3, 3), (2, 3, 3, 2), \\\\ (2, 6), (2, 6,3), (3), (3, 2), (3, 2, 2), (3, 2, 2, 3), (3, 2, 3), (3, 2, 3, 2), (3, 3),\\\\ (3, 3, 2), (3, 3, 2,2), (3, 6), (3, 6, 2), (6), (6, 2), (6, 2, 3), (6, 3), (6, 3, 2), (6, 6)$\n\n以上共 $28$ 种。\n\n**样例 4 解释**\n\n真正的答案为 $14104757650$。\n\n输出 $14104757650 \\bmod (10^9+7)=104757552$\n\n#### 【数据规模与约定】\n\n- 对于所有数据，保证 $1\\le N\\le 10^{15}$\n- 对于约 $30\\%$ 的数据，保证 $N$ 至多有 $2$ 个质因数。\n- 对于约 $60\\%$ 的数据，保证 $N$ 至多有 $4$ 个质因数。\n- 对于 $100\\%$ 的数据，保证 $N$ 至多有 $6$ 个质因数。\n\n#### 【说明】\n\n原题来自：[eJOI 2017](www.ejoi.org) Problem B [Six](http://ejoi.org/wp-content/themes/ejoi/assets/pdfs/tasks_day_1/EN/six_statement-en.pdf)\n\n翻译提供：@[```_Wallace_```](https://www.luogu.com.cn/user/61430)", "locale": "zh-CN"}}}
{"pid": "P6275", "type": "P", "difficulty": 5, "samples": [["2\n..\n..", "28"], ["4\n..W.\n..WW\nWW..\n...W", "2304"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "2020", "USACO", "组合数学"], "title": "[USACO20OPEN] Sprinklers 2: Return of the Alfalfa P", "background": "", "description": "Farmer John 有一块小的田地，形状为一个 $N$ 行 $N$ 列的一个方阵，对于所有的 $1 \\le i,j \\le N$，从上往下的第 $i$ 行的从左往右第 $j$ 个方格记为 $(i,j)$。他有兴趣在他的田地里种植甜玉米和苜蓿。为此，他需要安装一些特殊的洒水器。  \n在方格 $(I,J)$ 中的甜玉米洒水器可以喷洒到所有左下方的方格：即满足 $I \\le i$ 以及 $j \\le J$ 的 $(i,j)$。\n\n在方格 $(I,J)$ 中的苜蓿洒水器可以喷洒到所有右上方的方格：即满足 $i \\le I$ 以及 $J \\le j$ 的 $(i,j)$。\n\n被一个或多个甜玉米洒水器喷洒到的方格可以长出甜玉米；被一个或多个苜蓿洒水器喷洒到的方格可以长出苜蓿。但是被两种洒水器均喷洒到（或均喷洒不到）的方格什么也长不出来。\n\n帮助 Farmer John 求出在他的田地里安装洒水器的方案数（ $\\bmod \\ 10^9 + 7$），每个方格至多安装一个洒水器，使得每个方格均能生长作物（即被恰好一种洒水器喷洒到）。\n\n某些方格正被长毛奶牛占据；这不会阻止这些方格生长作物，但是这些方格里不能安装洒水器。", "inputFormat": "输入的第一行包含一个整数 $N$。  \n对于每一个 $1\\le i\\le N$，第 $i+1$ 行包含一个长为 $N$ 的字符串，表示方阵的第 $i$ 行。字符串中的每个字符为 `W`（表示被一头长毛奶牛占据的方格）或 `.`（未被占据）。", "outputFormat": "输出安装洒水器的方案数 $\\bmod \\ 10^9+7$ 的结果。", "hint": "#### 样例 $1$ 解释：\n以下是所有十四种可以使得 $(1,1)$ 生长甜玉米的方式。（译注：`C` 表示 sweet corn，即甜玉米；`A` 表示 alfalfa，即苜蓿）\n\n```plain\nCC  .C  CA  CC  .C  CA  CA  C.  CA  C.  CC  .C  CC  .C\nCC, CC, CC, .C, .C, .C, CA, CA, .A, .A, C., C., .., ..\n```\n\n#### 样例 $2$ 提示：\n\n这个样例满足第一个子任务的限制。\n\n-----\n\n对于 $100\\%$ 的数据，满足 $1 \\le N \\le 2000$。\n\n共 $16$ 个测试点，其中 $1\\sim 2$ 为样例，其余性质如下：\n\n对于测试点 $3 \\sim 4$，满足 $N \\le 10$ 且最多有 $10$ 个未被占据的格子。  \n对于测试点 $5 \\sim 9$，满足 $N \\le 200$。  \n对于测试点 $10 \\sim 16$，无特殊限制。\n\n---\n\n出题人：Benjamin Qi", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20OPEN] Sprinklers 2: Return of the Alfalfa P", "background": "", "description": "Farmer John 有一块小的田地，形状为一个 $N$ 行 $N$ 列的一个方阵，对于所有的 $1 \\le i,j \\le N$，从上往下的第 $i$ 行的从左往右第 $j$ 个方格记为 $(i,j)$。他有兴趣在他的田地里种植甜玉米和苜蓿。为此，他需要安装一些特殊的洒水器。  \n在方格 $(I,J)$ 中的甜玉米洒水器可以喷洒到所有左下方的方格：即满足 $I \\le i$ 以及 $j \\le J$ 的 $(i,j)$。\n\n在方格 $(I,J)$ 中的苜蓿洒水器可以喷洒到所有右上方的方格：即满足 $i \\le I$ 以及 $J \\le j$ 的 $(i,j)$。\n\n被一个或多个甜玉米洒水器喷洒到的方格可以长出甜玉米；被一个或多个苜蓿洒水器喷洒到的方格可以长出苜蓿。但是被两种洒水器均喷洒到（或均喷洒不到）的方格什么也长不出来。\n\n帮助 Farmer John 求出在他的田地里安装洒水器的方案数（ $\\bmod \\ 10^9 + 7$），每个方格至多安装一个洒水器，使得每个方格均能生长作物（即被恰好一种洒水器喷洒到）。\n\n某些方格正被长毛奶牛占据；这不会阻止这些方格生长作物，但是这些方格里不能安装洒水器。", "inputFormat": "输入的第一行包含一个整数 $N$。  \n对于每一个 $1\\le i\\le N$，第 $i+1$ 行包含一个长为 $N$ 的字符串，表示方阵的第 $i$ 行。字符串中的每个字符为 `W`（表示被一头长毛奶牛占据的方格）或 `.`（未被占据）。", "outputFormat": "输出安装洒水器的方案数 $\\bmod \\ 10^9+7$ 的结果。", "hint": "#### 样例 $1$ 解释：\n以下是所有十四种可以使得 $(1,1)$ 生长甜玉米的方式。（译注：`C` 表示 sweet corn，即甜玉米；`A` 表示 alfalfa，即苜蓿）\n\n```plain\nCC  .C  CA  CC  .C  CA  CA  C.  CA  C.  CC  .C  CC  .C\nCC, CC, CC, .C, .C, .C, CA, CA, .A, .A, C., C., .., ..\n```\n\n#### 样例 $2$ 提示：\n\n这个样例满足第一个子任务的限制。\n\n-----\n\n对于 $100\\%$ 的数据，满足 $1 \\le N \\le 2000$。\n\n共 $16$ 个测试点，其中 $1\\sim 2$ 为样例，其余性质如下：\n\n对于测试点 $3 \\sim 4$，满足 $N \\le 10$ 且最多有 $10$ 个未被占据的格子。  \n对于测试点 $5 \\sim 9$，满足 $N \\le 200$。  \n对于测试点 $10 \\sim 16$，无特殊限制。\n\n---\n\n出题人：Benjamin Qi", "locale": "zh-CN"}}}
{"pid": "P6276", "type": "P", "difficulty": 7, "samples": [["5 1000000007", "369329541"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2020", "USACO", "组合数学", "容斥原理", "生成函数"], "title": "[USACO20OPEN] Exercise P", "background": "", "description": "Farmer John（又）想到了一个新的奶牛晨练方案！  \n如同之前，Farmer John 的 $N$ 头奶牛站成一排。对于 $1\\le i\\le N$ 的每一个 $i$，从左往右第 $i$ 头奶牛的编号为 $i$。他告诉她们重复以下步骤，直到奶牛们与她们开始时的顺序相同。\n\n给定长为 $N$ 的一个排列 $A$，奶牛们改变她们的顺序，使得在改变之前从左往右第 $i$ 头奶牛在改变之后为从左往右第 $A_i$ 头。  \n例如，如果 $A=(1,2,3,4,5)$，那么奶牛们总共进行一步就回到了同样的顺序。如果 $A=(2,3,1,5,4)$，那么奶牛们总共进行六步之后回到起始的顺序。每步之后奶牛们从左往右的顺序如下：\n\n0 步：$(1,2,3,4,5)$  \n1 步：$(3,1,2,5,4)$  \n2 步：$(2,3,1,4,5)$  \n3 步：$(1,2,3,5,4)$  \n4 步：$(3,1,2,4,5)$  \n5 步：$(2,3,1,5,4)$  \n6 步：$(1,2,3,4,5)$  \n**请你计算出所有可能的 $N!$ 种长为 $N$ 的排列 $A$ 回到起始顺序需要的步数的乘积。**\n\n由于这个数字可能非常大，输出答案模 $M$ 的余数（$10^8\\le M\\le 10^9+7$，$M$ 是质数）。\n\n-----\n\n使用 C++ 的选手可以使用 [KACTL](https://github.com/kth-competitive-programming/kactl/blob/master/content/various/FastMod.h) 中的这一代码。这一名为 [Barrett 模乘](https://en.wikipedia.org/wiki/Barrett_reduction) 的算法可以以比通常计算快上数倍的速度计算 $a \\% b$，其中 $b>1$ 为一个编译时未知的常数。（不幸的是，我们没有找到对于 Java 的这样的优化）。（译注：中文选手可以参考 几种取模优化方法[（译自 min-25 的博客）](https://loj.ac/article/327)）\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef __uint128_t L;\nstruct FastMod {\n    ull b, m;\n    FastMod(ull b) : b(b), m(ull((L(1) << 64) / b)) {}\n    ull reduce(ull a) {\n        ull q = (ull)((L(m) * a) >> 64);\n        ull r = a - q * b; // can be proven that 0 <= r < 2*b\n        return r >= b ? r - b : r;\n    }\n};\nFastMod F(2);\n\nint main() {\n    int M = 1000000007; F = FastMod(M);\n    ull x = 10ULL*M+3; \n    cout << x << \" \" << F.reduce(x) << \"\\n\"; // 10000000073 3\n}\n```", "inputFormat": "输入一行包含 $N$ 和 $M$。", "outputFormat": "输出一个整数。", "hint": "#### 样例解释：\n对于每一个 $1\\le i\\le N$，以下序列的第 $i$ 个元素等于奶牛需要使用 $i$ 步的排列数量：$[1,25,20,30,24,20]$。所以答案等于 $1^1\\cdot 2^{25}\\cdot 3^{20}\\cdot 4^{30}\\cdot 5^{24}\\cdot 6^{20}\\equiv 369329541\\pmod{10^9+7}$。\n\n**注意：这个问题的内存限制增加为 512 MB。**\n\n---\n对于 $100\\%$ 的数据，满足 $1\\le N\\le 7500$。\n\n共 $16$ 个测试点，其中 $1$ 为样例，其余性质如下：\n\n测试点  $2$ 满足 $N=8$。  \n测试点 $3\\sim 5$ 满足 $N\\le 50$。  \n测试点 $6\\sim 8$ 满足 $N\\le 500$。  \n测试点 $9\\sim 12$ 满足 $N\\le 3000$。  \n测试点 $13\\sim 16$ 没有额外限制。\n\n----\n  \n出题人：Benjamin Qi", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20OPEN] Exercise P", "background": "", "description": "Farmer John（又）想到了一个新的奶牛晨练方案！  \n如同之前，Farmer John 的 $N$ 头奶牛站成一排。对于 $1\\le i\\le N$ 的每一个 $i$，从左往右第 $i$ 头奶牛的编号为 $i$。他告诉她们重复以下步骤，直到奶牛们与她们开始时的顺序相同。\n\n给定长为 $N$ 的一个排列 $A$，奶牛们改变她们的顺序，使得在改变之前从左往右第 $i$ 头奶牛在改变之后为从左往右第 $A_i$ 头。  \n例如，如果 $A=(1,2,3,4,5)$，那么奶牛们总共进行一步就回到了同样的顺序。如果 $A=(2,3,1,5,4)$，那么奶牛们总共进行六步之后回到起始的顺序。每步之后奶牛们从左往右的顺序如下：\n\n0 步：$(1,2,3,4,5)$  \n1 步：$(3,1,2,5,4)$  \n2 步：$(2,3,1,4,5)$  \n3 步：$(1,2,3,5,4)$  \n4 步：$(3,1,2,4,5)$  \n5 步：$(2,3,1,5,4)$  \n6 步：$(1,2,3,4,5)$  \n**请你计算出所有可能的 $N!$ 种长为 $N$ 的排列 $A$ 回到起始顺序需要的步数的乘积。**\n\n由于这个数字可能非常大，输出答案模 $M$ 的余数（$10^8\\le M\\le 10^9+7$，$M$ 是质数）。\n\n-----\n\n使用 C++ 的选手可以使用 [KACTL](https://github.com/kth-competitive-programming/kactl/blob/master/content/various/FastMod.h) 中的这一代码。这一名为 [Barrett 模乘](https://en.wikipedia.org/wiki/Barrett_reduction) 的算法可以以比通常计算快上数倍的速度计算 $a \\% b$，其中 $b>1$ 为一个编译时未知的常数。（不幸的是，我们没有找到对于 Java 的这样的优化）。（译注：中文选手可以参考 几种取模优化方法[（译自 min-25 的博客）](https://loj.ac/article/327)）\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef __uint128_t L;\nstruct FastMod {\n    ull b, m;\n    FastMod(ull b) : b(b), m(ull((L(1) << 64) / b)) {}\n    ull reduce(ull a) {\n        ull q = (ull)((L(m) * a) >> 64);\n        ull r = a - q * b; // can be proven that 0 <= r < 2*b\n        return r >= b ? r - b : r;\n    }\n};\nFastMod F(2);\n\nint main() {\n    int M = 1000000007; F = FastMod(M);\n    ull x = 10ULL*M+3; \n    cout << x << \" \" << F.reduce(x) << \"\\n\"; // 10000000073 3\n}\n```", "inputFormat": "输入一行包含 $N$ 和 $M$。", "outputFormat": "输出一个整数。", "hint": "#### 样例解释：\n对于每一个 $1\\le i\\le N$，以下序列的第 $i$ 个元素等于奶牛需要使用 $i$ 步的排列数量：$[1,25,20,30,24,20]$。所以答案等于 $1^1\\cdot 2^{25}\\cdot 3^{20}\\cdot 4^{30}\\cdot 5^{24}\\cdot 6^{20}\\equiv 369329541\\pmod{10^9+7}$。\n\n**注意：这个问题的内存限制增加为 512 MB。**\n\n---\n对于 $100\\%$ 的数据，满足 $1\\le N\\le 7500$。\n\n共 $16$ 个测试点，其中 $1$ 为样例，其余性质如下：\n\n测试点  $2$ 满足 $N=8$。  \n测试点 $3\\sim 5$ 满足 $N\\le 50$。  \n测试点 $6\\sim 8$ 满足 $N\\le 500$。  \n测试点 $9\\sim 12$ 满足 $N\\le 3000$。  \n测试点 $13\\sim 16$ 没有额外限制。\n\n----\n  \n出题人：Benjamin Qi", "locale": "zh-CN"}}}
{"pid": "P6277", "type": "P", "difficulty": 7, "samples": [["5\n1 2\n2 3\n3 4\n3 5", "1\n1\n3\n24\n120"], ["8\n1 3\n2 3\n3 4\n4 5\n5 6\n6 7\n6 8", "1\n1\n1\n6\n30\n180\n5040\n40320"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2020", "USACO", "连通块", "组合数学", "容斥原理", "Ad-hoc"], "title": "[USACO20OPEN] Circus P", "background": "", "description": "Farmer John 马戏团中的 $N$ 头奶牛正在为即将到来的演出做准备。演出全部在一棵节点编号为 $1\\ldots N$ 的树上举行。演出的“初始状态”被定义为一个整数 $K$（$1\\leq K\\leq N$）使得奶牛 $1\\ldots K$ 分布在树上的节点上，并且没有任何两头牛位于相同的节点。\n\n在一场演出中，奶牛们可以“移动”任意次数。在一次“移动”中，一头奶牛可以从自己当前所处的节点移动到一个未被占据的相邻节点。如果一个状态可以通过一系列移动到达另一个状态，我们就称这两个初始状态是等价的。\n\n对于每一个 $1\\leq K\\leq N$，你需要帮助奶牛确定有多少类等价的初始状态。即选出最多的起始状态数目，使得它们两两不等价。由于数字可能很大，所以只需输出答案 $\\bmod \\ 10^9+7$ 的结果。\n\n\n", "inputFormat": "第一行一个整数 $N$。\n\n接下来的 $N-1$ 行，每行两个整数 $a_i,b_i$，表示树中有一条连接 $a_i$ 和 $b_i$ 的边。", "outputFormat": "输出共 $N$ 行，对于每一个 $1\\leq i\\leq N$，在第 $i$ 行输出 $K=i$ 时的答案 $\\bmod \\ 10^9+7$ 的结果。", "hint": "#### 样例 $1$ 解释：\n对于 $K=1$ 和 $K=2$，任何两个状态都可以互相到达。\n\n然后考虑 $K=3$，令 $c_i$ 表示奶牛 $i$ 的位置，则状态 $(c_1,c_2,c_3)=(1,2,3)$ 等价于状态 $(1,2,5)$ 和 $(1,3,2)$，但不等价于状态 $(2,1,3)$。\n\n-----\n\n对于 $100\\%$ 的数据，保证 $1 \\le N \\le 10^5$。\n\n共 $20$ 个测试点，其中 $1\\sim 2$ 为样例，其余性质如下：\n\n对于测试点 $3 \\sim 4$，满足 $N \\leq 8$。  \n对于测试点 $5 \\sim 7$，满足 $N \\leq 16$。  \n对于测试点 $8 \\sim 10$，满足 $N \\leq 100$，且这个树为“星形”，最多有一个度数大于 $2$ 的节点。  \n对于测试点 $11 \\sim 15$，满足 $N \\leq 100$。  \n对于测试点 $16 \\sim 20$，无特殊限制。\n\n------\n\n出题人：Dhruv Rohatgi", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20OPEN] Circus P", "background": "", "description": "Farmer John 马戏团中的 $N$ 头奶牛正在为即将到来的演出做准备。演出全部在一棵节点编号为 $1\\ldots N$ 的树上举行。演出的“初始状态”被定义为一个整数 $K$（$1\\leq K\\leq N$）使得奶牛 $1\\ldots K$ 分布在树上的节点上，并且没有任何两头牛位于相同的节点。\n\n在一场演出中，奶牛们可以“移动”任意次数。在一次“移动”中，一头奶牛可以从自己当前所处的节点移动到一个未被占据的相邻节点。如果一个状态可以通过一系列移动到达另一个状态，我们就称这两个初始状态是等价的。\n\n对于每一个 $1\\leq K\\leq N$，你需要帮助奶牛确定有多少类等价的初始状态。即选出最多的起始状态数目，使得它们两两不等价。由于数字可能很大，所以只需输出答案 $\\bmod \\ 10^9+7$ 的结果。\n\n\n", "inputFormat": "第一行一个整数 $N$。\n\n接下来的 $N-1$ 行，每行两个整数 $a_i,b_i$，表示树中有一条连接 $a_i$ 和 $b_i$ 的边。", "outputFormat": "输出共 $N$ 行，对于每一个 $1\\leq i\\leq N$，在第 $i$ 行输出 $K=i$ 时的答案 $\\bmod \\ 10^9+7$ 的结果。", "hint": "#### 样例 $1$ 解释：\n对于 $K=1$ 和 $K=2$，任何两个状态都可以互相到达。\n\n然后考虑 $K=3$，令 $c_i$ 表示奶牛 $i$ 的位置，则状态 $(c_1,c_2,c_3)=(1,2,3)$ 等价于状态 $(1,2,5)$ 和 $(1,3,2)$，但不等价于状态 $(2,1,3)$。\n\n-----\n\n对于 $100\\%$ 的数据，保证 $1 \\le N \\le 10^5$。\n\n共 $20$ 个测试点，其中 $1\\sim 2$ 为样例，其余性质如下：\n\n对于测试点 $3 \\sim 4$，满足 $N \\leq 8$。  \n对于测试点 $5 \\sim 7$，满足 $N \\leq 16$。  \n对于测试点 $8 \\sim 10$，满足 $N \\leq 100$，且这个树为“星形”，最多有一个度数大于 $2$ 的节点。  \n对于测试点 $11 \\sim 15$，满足 $N \\leq 100$。  \n对于测试点 $16 \\sim 20$，无特殊限制。\n\n------\n\n出题人：Dhruv Rohatgi", "locale": "zh-CN"}}}
{"pid": "P6278", "type": "P", "difficulty": 4, "samples": [["5\n5 2 3 3 0", "0\n4\n4\n5\n7"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2020", "线段树", "USACO", "树状数组", "扫描线"], "title": "[USACO20OPEN] Haircut G", "background": null, "description": "Farmer John 由于对整理他难以整平的头发感到疲惫，于是决定去理发。他有一排 $N$ 缕头发，第 $i$ 缕头发初始时长度为 $A_i$ 微米（$0\\le A_i\\le N$）。理想情况下，他想要他的头发在长度上单调不降，所以他定义他的头发的“不良度”为逆序对的数量：满足 $i < j$ 及 $A_i > A_j$ 的二元对 $(i,j)$。  \n对于每一个 $j=0,1,\\ldots,N-1$，Farmer John 想要知道他所有长度大于 $j$ 的头发的长度均减少到 $j$ 时他的头发的不良度。\n\n-----\n\n（有趣的事实：人类平均确实有大约 $10^5$ 根头发！）", "inputFormat": "输入的第一行包含 $N$。  \n第二行包含 $A_1,A_2,\\ldots,A_N$。", "outputFormat": "对于每一个 $j=0,1,\\ldots,N-1$，用一行输出 Farmer John 头发的不良度。\n\n-----\n\n  \n**注意这个问题涉及到的整数大小可能需要使用 $64$ 位整数型存储（例如，C/C++ 中的“long long”）。**", "hint": "#### 样例解释：\n\n输出的第四行描述了 Farmer John 的头发长度减少到 $3$ 时的逆序对数量。   \n$A=[3,2,3,3,0]$ 有五个逆序对：$A_1>A_2,\\,A_1>A_5,\\,A_2>A_5,\\,A_3>A_5,$ 和 $A_4>A_5$。\n\n----\n\n对于 $100\\%$ 的数据，$1\\le N\\le 10^5$。\n\n共 $13$ 个测试点，其中 $1$ 为样例，其余性质如下：\n  \n测试点 $2$ 满足 $N\\le 100$。  \n测试点 $3\\sim 5$ 满足 $N\\le 5000$。  \n测试点 $6\\sim 13$ 没有额外限制。  \n\n-----\n\n\n出题人：Dhruv Rohatgi", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20OPEN] Haircut G", "background": null, "description": "Farmer John 由于对整理他难以整平的头发感到疲惫，于是决定去理发。他有一排 $N$ 缕头发，第 $i$ 缕头发初始时长度为 $A_i$ 微米（$0\\le A_i\\le N$）。理想情况下，他想要他的头发在长度上单调不降，所以他定义他的头发的“不良度”为逆序对的数量：满足 $i < j$ 及 $A_i > A_j$ 的二元对 $(i,j)$。  \n对于每一个 $j=0,1,\\ldots,N-1$，Farmer John 想要知道他所有长度大于 $j$ 的头发的长度均减少到 $j$ 时他的头发的不良度。\n\n-----\n\n（有趣的事实：人类平均确实有大约 $10^5$ 根头发！）", "inputFormat": "输入的第一行包含 $N$。  \n第二行包含 $A_1,A_2,\\ldots,A_N$。", "outputFormat": "对于每一个 $j=0,1,\\ldots,N-1$，用一行输出 Farmer John 头发的不良度。\n\n-----\n\n  \n**注意这个问题涉及到的整数大小可能需要使用 $64$ 位整数型存储（例如，C/C++ 中的“long long”）。**", "hint": "#### 样例解释：\n\n输出的第四行描述了 Farmer John 的头发长度减少到 $3$ 时的逆序对数量。   \n$A=[3,2,3,3,0]$ 有五个逆序对：$A_1>A_2,\\,A_1>A_5,\\,A_2>A_5,\\,A_3>A_5,$ 和 $A_4>A_5$。\n\n----\n\n对于 $100\\%$ 的数据，$1\\le N\\le 10^5$。\n\n共 $13$ 个测试点，其中 $1$ 为样例，其余性质如下：\n  \n测试点 $2$ 满足 $N\\le 100$。  \n测试点 $3\\sim 5$ 满足 $N\\le 5000$。  \n测试点 $6\\sim 13$ 没有额外限制。  \n\n-----\n\n\n出题人：Dhruv Rohatgi", "locale": "zh-CN"}}}
{"pid": "P6279", "type": "P", "difficulty": 5, "samples": [["9 12\n1 2\n4 2\n5 8\n4 6\n6 9\n2 9\n8 7\n8 3\n7 1\n9 4\n3 5\n3 4", "1\n2\n3\n1\n1\n2\n3\n2\n3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2020", "USACO", "并查集", "启发式合并"], "title": "[USACO20OPEN] Favorite Colors G", "background": "", "description": "Farmer John 的 $N$ 头奶牛每头都有一种最喜欢的颜色。奶牛们的编号为 $1\\ldots N$，每种颜色也可以用 $1\\ldots N$ 中的一个整数表示。  \n存在 $M$ 对奶牛 $(a,b)$，奶牛 $b$ 仰慕奶牛 $a$。有可能 $a=b$，此时一头奶牛仰慕她自己。对于任意颜色 $c$，如果奶牛 $x$ 和 $y$ 都仰慕一头喜欢颜色 $c$ 的奶牛，那么 $x$ 和 $y$ 喜欢的颜色相同。\n\n给定这些信息，求一种奶牛喜欢颜色的分配方案，使得每头奶牛最喜欢的颜色中不同颜色的数量最大。由于存在多种符合这一性质的分配方案，输出字典序最小的（这意味着你应当依次最小化分配给奶牛 $1 \\ldots N$ 的颜色）。", "inputFormat": "输入的第一行包含 $N$ 和 $M$。  \n以下 $M$ 行每行包含两个空格分隔的整数 $a$ 和 $b$（$1\\le a,b\\le N$），表示奶牛 $b$ 仰慕奶牛 $a$。同一对奶牛可能会在输入中多次出现。", "outputFormat": "对于 $1\\ldots N$ 中的每一个 $i$，用一行输出分配给奶牛 $i$ 的颜色。", "hint": "#### 样例解释：\n\n在下图中，用粗边框圆表示的是最喜欢颜色 $1$ 的奶牛。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iratxzf8.png)\n\n-----\n\n对于 $100\\%$ 的数据，$1\\le N,M\\le 2\\times 10^5$。\n\n共 $10$ 个测试点，其中 $1$ 为样例，其余性质如下：\n \n测试点 $2\\sim 3$ 满足 $N,M\\le 10^3$。  \n测试点 $4\\sim 10$ 没有额外限制。\n\n-----\n\n出题人：William Lin，Benjamin Qi", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO20OPEN] Favorite Colors G", "background": "", "description": "Farmer John 的 $N$ 头奶牛每头都有一种最喜欢的颜色。奶牛们的编号为 $1\\ldots N$，每种颜色也可以用 $1\\ldots N$ 中的一个整数表示。  \n存在 $M$ 对奶牛 $(a,b)$，奶牛 $b$ 仰慕奶牛 $a$。有可能 $a=b$，此时一头奶牛仰慕她自己。对于任意颜色 $c$，如果奶牛 $x$ 和 $y$ 都仰慕一头喜欢颜色 $c$ 的奶牛，那么 $x$ 和 $y$ 喜欢的颜色相同。\n\n给定这些信息，求一种奶牛喜欢颜色的分配方案，使得每头奶牛最喜欢的颜色中不同颜色的数量最大。由于存在多种符合这一性质的分配方案，输出字典序最小的（这意味着你应当依次最小化分配给奶牛 $1 \\ldots N$ 的颜色）。", "inputFormat": "输入的第一行包含 $N$ 和 $M$。  \n以下 $M$ 行每行包含两个空格分隔的整数 $a$ 和 $b$（$1\\le a,b\\le N$），表示奶牛 $b$ 仰慕奶牛 $a$。同一对奶牛可能会在输入中多次出现。", "outputFormat": "对于 $1\\ldots N$ 中的每一个 $i$，用一行输出分配给奶牛 $i$ 的颜色。", "hint": "#### 样例解释：\n\n在下图中，用粗边框圆表示的是最喜欢颜色 $1$ 的奶牛。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iratxzf8.png)\n\n-----\n\n对于 $100\\%$ 的数据，$1\\le N,M\\le 2\\times 10^5$。\n\n共 $10$ 个测试点，其中 $1$ 为样例，其余性质如下：\n \n测试点 $2\\sim 3$ 满足 $N,M\\le 10^3$。  \n测试点 $4\\sim 10$ 没有额外限制。\n\n-----\n\n出题人：William Lin，Benjamin Qi", "locale": "zh-CN"}}}
