{"pid": "P3858", "type": "P", "difficulty": 7, "samples": [["2\n2 2 3\n...\nX.X\n\nX.X\nXXX\n2 2 3\n.X.\n.X.\n\n.X.\n.X.\n", "yes\nno\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "天津"], "title": "[TJOI2008] 贪吃蛇", "background": "佳佳和金明在玩一个新版的对战型贪吃蛇游戏：在一个长方体中，某些格子是障碍物，其余的格子里都有食物。佳佳把贪吃蛇放到其中一个有食物的格子中，然后金明控制贪吃蛇移动一步到相邻的有食物的格子中，然后佳佳再控制它移动一步，就这样双方轮流进行下去。要注意的是移动的时候只能向上下左右前后的六个方向之一移动，且不能走出长方体的边界（当然，有障碍物的格子也是不能走的）。并且游戏要求贪吃蛇每步都必须能吃到新的食物，即不能走回以前经过的格子（包括起点也不能走回）。游戏进行到某方不能再按照上述规则移动蛇时，这一方就输掉了。\n", "description": "佳佳和金明都是十分聪明的孩子，他们在游戏中总是会选择对自己最有利的策略。因为贪吃蛇的初始位置是由佳佳指定的，现在佳佳想知道，能不能找到这样一个初始位置使得自己一定可以获胜呢？\n", "inputFormat": "输入文件的第一行包含一个整数N，表示此文件包含的测试样例数。接下来就是N组样例的描述。\n\n每组样例描述的第一行包含三个整数H,R,C，表示长方体的高度，长度和宽度。接下来是H个R行C列的矩阵，每个矩阵描述此长方体的一层。矩阵包含的字符只有’.’和’X’两种，其中’.’表示初始时有食物的格子，’X’表示障碍。这H个矩阵描述之间都用一个空行隔开。\n", "outputFormat": "输出N行，表示对应的游戏中佳佳是不是一定可以获胜。如果佳佳可以获胜，输出“yes”，否则输出“no”。\n", "hint": "对于40%的数据，H \\* R \\* C ≤ 16\n\n对于100%的数据，H \\* R \\* C ≤ 100,  N ≤ 10\n\n输入数据保证每个长方体至少包含一个不是障碍物的格子。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2008] Snake", "background": "Jiajia and Jinming are playing a new competitive version of the Snake game in a rectangular prism. Some cells are obstacles, and every other cell initially contains food. Jiajia places the snake on a cell that has food. Then Jinming moves the snake one step to an adjacent cell that has food; then Jiajia moves it one step; they alternate in this way. A move may go only in one of the six directions: up, down, left, right, front, or back. The snake cannot leave the rectangular prism or enter an obstacle cell. Moreover, every move must eat new food: the snake may not revisit any previously visited cell, including the starting cell. When a player can no longer move the snake under these rules, that player loses.", "description": "Jiajia and Jinming are very smart and always play optimally. Since the snake’s starting position is chosen by Jiajia, she wants to know whether she can pick a starting cell that guarantees her a win.", "inputFormat": "The first line contains an integer N, the number of test cases. Each test case begins with a line containing three integers H, R, and C, denoting the height, length, and width of the rectangular prism. Then follow H matrices of R rows and C columns; each matrix describes one layer of the prism. Each matrix contains only the characters '.' and 'X', where '.' means a cell initially with food and 'X' means an obstacle. The H layer descriptions are separated by a blank line.", "outputFormat": "Output N lines, each indicating whether Jiajia can guarantee a win in the corresponding game. Output \"yes\" if she can, otherwise output \"no\".", "hint": "- For 40% of the testdata, $H \\times R \\times C \\le 16$.\n- For 100% of the testdata, $H \\times R \\times C \\le 100$, $N \\le 10$.\n- The input guarantees that each rectangular prism contains at least one cell that is not an obstacle.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2008] 贪吃蛇", "background": "佳佳和金明在玩一个新版的对战型贪吃蛇游戏：在一个长方体中，某些格子是障碍物，其余的格子里都有食物。佳佳把贪吃蛇放到其中一个有食物的格子中，然后金明控制贪吃蛇移动一步到相邻的有食物的格子中，然后佳佳再控制它移动一步，就这样双方轮流进行下去。要注意的是移动的时候只能向上下左右前后的六个方向之一移动，且不能走出长方体的边界（当然，有障碍物的格子也是不能走的）。并且游戏要求贪吃蛇每步都必须能吃到新的食物，即不能走回以前经过的格子（包括起点也不能走回）。游戏进行到某方不能再按照上述规则移动蛇时，这一方就输掉了。\n", "description": "佳佳和金明都是十分聪明的孩子，他们在游戏中总是会选择对自己最有利的策略。因为贪吃蛇的初始位置是由佳佳指定的，现在佳佳想知道，能不能找到这样一个初始位置使得自己一定可以获胜呢？\n", "inputFormat": "输入文件的第一行包含一个整数N，表示此文件包含的测试样例数。接下来就是N组样例的描述。\n\n每组样例描述的第一行包含三个整数H,R,C，表示长方体的高度，长度和宽度。接下来是H个R行C列的矩阵，每个矩阵描述此长方体的一层。矩阵包含的字符只有’.’和’X’两种，其中’.’表示初始时有食物的格子，’X’表示障碍。这H个矩阵描述之间都用一个空行隔开。\n", "outputFormat": "输出N行，表示对应的游戏中佳佳是不是一定可以获胜。如果佳佳可以获胜，输出“yes”，否则输出“no”。\n", "hint": "对于40%的数据，H \\* R \\* C ≤ 16\n\n对于100%的数据，H \\* R \\* C ≤ 100,  N ≤ 10\n\n输入数据保证每个长方体至少包含一个不是障碍物的格子。\n", "locale": "zh-CN"}}}
{"pid": "P3859", "type": "P", "difficulty": 3, "samples": [["3 4\n9 5 5\n0 1 2\n1 2 2\n2 3 2\n2 5 3\n", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "各省省选", "背包 DP", "天津"], "title": "[TJOI2008] 小偷", "background": "一位著名的小偷进入了一个充满宝石的储藏室，这个储藏室是由一连串房间构成的，房间的标号从 $0$ 开始，想进入第 $i$ 个房间就必须从第 $i-1$ 个房间进入，如图：\n\n![](https://cdn.luogu.com.cn/upload/pic/6100.png)\n", "description": "上图为三个房间的情况，黑色的部分为连通两个房间的门，从左向右的编号分别为 $0,1,2\\cdots$。已知当小偷从第 $0$ 个门进入储藏室时，储藏室的计时系统开始计时，每个门都有自己的关闭时间。每个屋里有不同种类的宝石，对于每种宝石，它的价值和小偷拿走它所耗费的时间也是不同的，为了简化问题，我们设想小偷在各个屋子之间走动的时间可以忽略不计，而且所有屋子里各种宝石的数量都是无限多的，那么请问小偷在能成功逃出来的情况下，可能获得宝石的最大价值。\n\n附：对于每扇门，小偷都必须在严格早于此门关闭的时候出来才可以。", "inputFormat": "每组测试数据的第一行有两个整数 $N$ 和 $M$，分别代表储藏室有 $N$ 个房间，并且有 $M$ 种宝石。第二行中会有 $N$ 个正整数，分别表示第 $i$ 个门关闭的时间（门的编号从 $0$ 开始），接下来的 $M$ 行，每行有三个整数 $r,v$ 和 $t$，分别代表这种宝石所在的房间编号为 $r$，它的价值为 $v$，小偷拿走它所耗费的时间为 $t$。", "outputFormat": "输出小偷在成功逃出储藏室的情况下获得宝石的最大价值。\n", "hint": "### 样例解释\n\n虽然在第 $2$ 个房间中价值为 $5$ 的宝石好，但是不如拿两次价值为 $3$ 的宝石，在拿两次第 $0$ 房间中价值为 $1$ 的宝石，总价值为 $8$。\n\n### 数据范围及约定\n\n对于 $100\\%$ 的数据，储藏室的屋子数量不超过 $50$，每扇门关闭的时间不超过 $1000$，并且宝石的数量不超过 $100$，价值不超过 $1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2008] Thief", "background": "A famous thief enters a storage room full of gems. This storage is a chain of rooms, numbered from $0$. To enter room $i$, one must come from room $i-1$, as shown in the figure.\n\n![](https://cdn.luogu.com.cn/upload/pic/6100.png)", "description": "The figure above shows the case of three rooms. The black parts are the doors connecting two adjacent rooms, numbered from left to right as $0,1,2\\cdots$. When the thief enters the storage through door $0$, the timing system starts, and each door has its own closing time. Each room contains different kinds of gems. For each kind of gem, its value and the time the thief spends to take one are different. To simplify the problem, we assume the time to move between rooms is negligible, and the quantities of every kind of gem in all rooms are unlimited. What is the maximum total value of gems the thief can obtain while still being able to escape successfully?\n\nNote: For each door, the thief must exit through it strictly before it closes.", "inputFormat": "For each test case, the first line contains two integers $N$ and $M$, representing that the storage has $N$ rooms and there are $M$ kinds of gems. The second line contains $N$ positive integers, where the $i$-th integer denotes the closing time of door $i$ (doors are numbered from $0$). The next $M$ lines each contain three integers $r$, $v$ and $t$, meaning that this kind of gem is located in room $r$, its value is $v$, and it takes time $t$ for the thief to take one.", "outputFormat": "Output the maximum total value of gems the thief can obtain while successfully escaping the storage.", "hint": "### Sample Explanation\n\nAlthough the gem worth $5$ in room $2$ looks good, it is better to take two gems worth $3$, and then take two gems worth $1$ in room $0$, for a total value of $8$.\n\n### Constraints and Conventions\n\nFor $100\\%$ of the testdata, the number of rooms does not exceed $50$, the closing time of each door does not exceed $1000$, the number of gem types does not exceed $100$, and each value does not exceed $1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2008] 小偷", "background": "一位著名的小偷进入了一个充满宝石的储藏室，这个储藏室是由一连串房间构成的，房间的标号从 $0$ 开始，想进入第 $i$ 个房间就必须从第 $i-1$ 个房间进入，如图：\n\n![](https://cdn.luogu.com.cn/upload/pic/6100.png)\n", "description": "上图为三个房间的情况，黑色的部分为连通两个房间的门，从左向右的编号分别为 $0,1,2\\cdots$。已知当小偷从第 $0$ 个门进入储藏室时，储藏室的计时系统开始计时，每个门都有自己的关闭时间。每个屋里有不同种类的宝石，对于每种宝石，它的价值和小偷拿走它所耗费的时间也是不同的，为了简化问题，我们设想小偷在各个屋子之间走动的时间可以忽略不计，而且所有屋子里各种宝石的数量都是无限多的，那么请问小偷在能成功逃出来的情况下，可能获得宝石的最大价值。\n\n附：对于每扇门，小偷都必须在严格早于此门关闭的时候出来才可以。", "inputFormat": "每组测试数据的第一行有两个整数 $N$ 和 $M$，分别代表储藏室有 $N$ 个房间，并且有 $M$ 种宝石。第二行中会有 $N$ 个正整数，分别表示第 $i$ 个门关闭的时间（门的编号从 $0$ 开始），接下来的 $M$ 行，每行有三个整数 $r,v$ 和 $t$，分别代表这种宝石所在的房间编号为 $r$，它的价值为 $v$，小偷拿走它所耗费的时间为 $t$。", "outputFormat": "输出小偷在成功逃出储藏室的情况下获得宝石的最大价值。\n", "hint": "### 样例解释\n\n虽然在第 $2$ 个房间中价值为 $5$ 的宝石好，但是不如拿两次价值为 $3$ 的宝石，在拿两次第 $0$ 房间中价值为 $1$ 的宝石，总价值为 $8$。\n\n### 数据范围及约定\n\n对于 $100\\%$ 的数据，储藏室的屋子数量不超过 $50$，每扇门关闭的时间不超过 $1000$，并且宝石的数量不超过 $100$，价值不超过 $1000$。", "locale": "zh-CN"}}}
{"pid": "P3860", "type": "P", "difficulty": 4, "samples": [["3 2\n100\n200\n300\n", "800\n2\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "天津"], "title": "[TJOI2009] 火星人的手机", "background": "你应火星人之邀为他们设计一款新型的手机。我们知道在标准的地球人手机上，数字键共有 $10$ 个，$26$ 个字母 `a`…`z` 分别与某个数字键相关联，并且一个数字键上的若干字母必须是字母表中连续的一段。比如下图是地球手机的一个标准方案：\n\n![](https://cdn.luogu.com.cn/upload/pic/6103.png)\n", "description": "我们要输入一个字母，必须连续按它所在的数字键若干次，次数即为这个字母在这个键的第几个位置。例如在上图的方案中，若我们要输入 `C`，就需要按三次数字键 `2`；若要输入 `M`，需按一次数字键 `6`。\n\n火星人手机的构造与地球人手机类似，上面有 $M$ 个火星数字键，你需要把火星文的 $N$ 个字母放置在这 $M$ 个键上。（同样要求一个数字键上必须是连续的若干个火星字母）现在给定一段火星文中各个字母的出现次数，你设计的手机必须使得输入这段文字所需的按键次数最少。\n", "inputFormat": "输入文件的第一行包括两个数字 $N$ 和 $M$，分别表示火星文字母数和火星手机的按键数。接下来有 $N$ 行，每行包含一个数字，依次表示每个字母在文章中的出现次数。这个次数不超过 $1000$。\n", "outputFormat": "输出文件的第一行包括一个数字，表示最少的按键次数。\n\n接下来的 $M$ 行表示一种设计方案：每行包含一个数，依次表示每个数字键上有几个火星字母。（这些数字可以为 $0$）\n\n如果有多种方案可以得到最少的按键次数，你需要输出第一个数字键上包含字母最少的方案；如果仍有多种方案，你需要在其中选择第二个数字键上字母最少的方案；依此类推。\n", "hint": "### 数据范围及约定\n\n对于 $100\\%$ 的数据，$1\\le N \\le 500$，$1 \\le M \\le 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2009] Martian's Mobile Phone", "background": "At the invitation of the Martians, you are to design a new type of phone for them. We know that a standard Earth phone has $10$ numeric keys, the $26$ letters `a`…`z` are each associated with some numeric key, and the letters on any single numeric key must form a contiguous segment of the alphabet. For example, the figure below shows a standard scheme for an Earth phone:\n\n![](https://cdn.luogu.com.cn/upload/pic/6103.png)", "description": "To input a letter, we must press its numeric key several times consecutively; the number of presses equals the letter’s position on that key. For example, in the scheme above, to input `C`, we press numeric key `2` three times; to input `M`, we press numeric key `6` once.\n\nThe Martian phone is similar to the Earth phone: it has $M$ Martian numeric keys, and you need to place the $N$ letters of the Martian alphabet onto these $M$ keys. (Likewise, the letters on any single numeric key must be a contiguous block of Martian letters.) Now, given the occurrence count of each letter in a passage of Martian text, your design must minimize the total number of key presses required to input this passage.", "inputFormat": "The first line of input contains two numbers, $N$ and $M$, the number of Martian letters and the number of keys on the Martian phone, respectively. The next $N$ lines each contain one number, in order, giving the occurrence count of each letter in the passage. Each count does not exceed $1000$.", "outputFormat": "The first line of output contains a single number, the minimum total number of key presses.\n\nThe next $M$ lines describe one design: each line contains a number, in order, indicating how many Martian letters are placed on each numeric key. (These numbers may be $0$.)\n\nIf multiple designs achieve the same minimum, output the one with the fewest letters on the first numeric key; if still tied, among those choose the one with the fewest letters on the second numeric key; and so on.", "hint": "### Constraints\n\nFor $100\\%$ of the data, $1 \\le N \\le 500$, $1 \\le M \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2009] 火星人的手机", "background": "你应火星人之邀为他们设计一款新型的手机。我们知道在标准的地球人手机上，数字键共有 $10$ 个，$26$ 个字母 `a`…`z` 分别与某个数字键相关联，并且一个数字键上的若干字母必须是字母表中连续的一段。比如下图是地球手机的一个标准方案：\n\n![](https://cdn.luogu.com.cn/upload/pic/6103.png)\n", "description": "我们要输入一个字母，必须连续按它所在的数字键若干次，次数即为这个字母在这个键的第几个位置。例如在上图的方案中，若我们要输入 `C`，就需要按三次数字键 `2`；若要输入 `M`，需按一次数字键 `6`。\n\n火星人手机的构造与地球人手机类似，上面有 $M$ 个火星数字键，你需要把火星文的 $N$ 个字母放置在这 $M$ 个键上。（同样要求一个数字键上必须是连续的若干个火星字母）现在给定一段火星文中各个字母的出现次数，你设计的手机必须使得输入这段文字所需的按键次数最少。\n", "inputFormat": "输入文件的第一行包括两个数字 $N$ 和 $M$，分别表示火星文字母数和火星手机的按键数。接下来有 $N$ 行，每行包含一个数字，依次表示每个字母在文章中的出现次数。这个次数不超过 $1000$。\n", "outputFormat": "输出文件的第一行包括一个数字，表示最少的按键次数。\n\n接下来的 $M$ 行表示一种设计方案：每行包含一个数，依次表示每个数字键上有几个火星字母。（这些数字可以为 $0$）\n\n如果有多种方案可以得到最少的按键次数，你需要输出第一个数字键上包含字母最少的方案；如果仍有多种方案，你需要在其中选择第二个数字键上字母最少的方案；依此类推。\n", "hint": "### 数据范围及约定\n\n对于 $100\\%$ 的数据，$1\\le N \\le 500$，$1 \\le M \\le 100$。\n", "locale": "zh-CN"}}}
{"pid": "P3861", "type": "P", "difficulty": 5, "samples": [["1\n688", "6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["动态规划 DP", "数论", "洛谷原创", "O2优化", "洛谷月赛"], "title": "拆分", "background": "", "description": "给定一个整数 $n$，求将 $n$ 分解为互不相同的不小于 $2$ 的整数的乘积的方案数。答案模 $998244353$。\n", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行一个整数 $n$，意义如描述所述。\n", "outputFormat": "一共 $T$ 行，每行一个整数，表示答案。\n", "hint": "样例中，因为\n\n$688 = 2 \\times 4 \\times 86= 2 \\times 8 \\times 43= 2 \\times 344= 4 \\times 172= 8 \\times 86= 16 \\times 43$\n\n所以答案为 $6$\n\n\n\n对于 $10\\%$ 的数据，保证 $n$ 为质数\n\n对于 $20\\%$ 的数据，保证 $2 \\leq n \\leq 10^4$\n\n对于 $50\\%$ 的数据，保证 $ 2  \\leq n \\leq 10^7$\n\n对于 $100\\%$ 的数据， 保证 $ 2 \\leq n \\leq 10^{12}$\n\n所有数据满足 $1 \\leq T \\leq 5$\n", "locale": "zh-CN", "translations": {"en": {"title": "Splitting", "background": "", "description": "Given an integer $n$, find the number of ways to factor $n$ into a product of pairwise distinct integers each at least $2$. Output the answer modulo $998244353$.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\nThe next $T$ lines each contain an integer $n$, as described.", "outputFormat": "Output $T$ lines, each containing a single integer, the answer.", "hint": "In the sample, because\n\n$688 = 2 \\times 4 \\times 86= 2 \\times 8 \\times 43= 2 \\times 344= 4 \\times 172= 8 \\times 86= 16 \\times 43$\n\nthe answer is $6$.\n\nFor $10\\%$ of the testdata, $n$ is prime.\nFor $20\\%$ of the testdata, $2 \\leq n \\leq 10^4$.\nFor $50\\%$ of the testdata, $ 2  \\leq n \\leq 10^7$.\nFor $100\\%$ of the testdata, $ 2 \\leq n \\leq 10^{12}$.\nAll testdata satisfy $1 \\leq T \\leq 5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "拆分", "background": "", "description": "给定一个整数 $n$，求将 $n$ 分解为互不相同的不小于 $2$ 的整数的乘积的方案数。答案模 $998244353$。\n", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行一个整数 $n$，意义如描述所述。\n", "outputFormat": "一共 $T$ 行，每行一个整数，表示答案。\n", "hint": "样例中，因为\n\n$688 = 2 \\times 4 \\times 86= 2 \\times 8 \\times 43= 2 \\times 344= 4 \\times 172= 8 \\times 86= 16 \\times 43$\n\n所以答案为 $6$\n\n\n\n对于 $10\\%$ 的数据，保证 $n$ 为质数\n\n对于 $20\\%$ 的数据，保证 $2 \\leq n \\leq 10^4$\n\n对于 $50\\%$ 的数据，保证 $ 2  \\leq n \\leq 10^7$\n\n对于 $100\\%$ 的数据， 保证 $ 2 \\leq n \\leq 10^{12}$\n\n所有数据满足 $1 \\leq T \\leq 5$\n", "locale": "zh-CN"}}}
{"pid": "P3862", "type": "P", "difficulty": 5, "samples": [["4\n3\n4\n5\n6", "0\n3\n22\n133"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["图论", "递推", "洛谷原创", "O2优化", "组合数学", "洛谷月赛"], "title": "数圈", "background": "", "description": "求 $n$ 个点的无向完全图删去一条边之后圈的个数，答案模 $998244353$。\n\n\n注：圈指的是任选一个顶点为起点，沿着不重复的边，经过不重复的顶点为途径，之后又回到起点的闭合途径。\n", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行一个整数 $n$，意义如描述所述。\n", "outputFormat": "一共 $T$ 行，每行一个整数，表示答案。\n", "hint": "前 $10\\%$ 的数据满足 $3 \\leq n \\leq 10$\n\n另外 $20\\%$ 的数据满足 $ 9.99\\times 10^2  \\leq n \\leq 10^3$\n\n另外 $30\\%$ 的数据满足 $ 9.99\\times 10^4 \\leq n \\leq 10^5$\n\n另外 $40\\%$ 的数据满足 $ 9.99\\times 10^8 \\leq n \\leq 10^9$\n\n所有数据满足 $1 \\leq T \\leq 10$\n", "locale": "zh-CN", "translations": {"en": {"title": "Counting Cycles", "background": "", "description": "Compute the number of cycles in the undirected complete graph on $n$ vertices after deleting one edge, and output the answer modulo $998244353$.\n\nNote: A “cycle” means choosing any vertex as the starting point, following non-repeating edges, visiting non-repeating vertices along the way, and then returning to the starting vertex to form a closed path.", "inputFormat": "The first line contains an integer $T$, indicating the number of test cases.\n\nThe next $T$ lines each contain an integer $n$, as described above.", "outputFormat": "Output $T$ lines, each containing one integer, representing the answer.", "hint": "For the first $10\\%$ of the testdata, $3 \\leq n \\leq 10$.\n\nFor an additional $20\\%$ of the testdata, $ 9.99\\times 10^2  \\leq n \\leq 10^3$.\n\nFor an additional $30\\%$ of the testdata, $ 9.99\\times 10^4 \\leq n \\leq 10^5$.\n\nFor the remaining $40\\%$ of the testdata, $ 9.99\\times 10^8 \\leq n \\leq 10^9$.\n\nAll testdata satisfy $1 \\leq T \\leq 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数圈", "background": "", "description": "求 $n$ 个点的无向完全图删去一条边之后圈的个数，答案模 $998244353$。\n\n\n注：圈指的是任选一个顶点为起点，沿着不重复的边，经过不重复的顶点为途径，之后又回到起点的闭合途径。\n", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n接下来 $T$ 行，每行一个整数 $n$，意义如描述所述。\n", "outputFormat": "一共 $T$ 行，每行一个整数，表示答案。\n", "hint": "前 $10\\%$ 的数据满足 $3 \\leq n \\leq 10$\n\n另外 $20\\%$ 的数据满足 $ 9.99\\times 10^2  \\leq n \\leq 10^3$\n\n另外 $30\\%$ 的数据满足 $ 9.99\\times 10^4 \\leq n \\leq 10^5$\n\n另外 $40\\%$ 的数据满足 $ 9.99\\times 10^8 \\leq n \\leq 10^9$\n\n所有数据满足 $1 \\leq T \\leq 10$\n", "locale": "zh-CN"}}}
{"pid": "P3863", "type": "P", "difficulty": 6, "samples": [["3 3\n1 3 5\n2 1 2\n1 1 2 -3\n2 1 1", "0\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["洛谷原创", "O2优化", "排序", "分块", "扫描线", "洛谷月赛"], "title": "序列", "background": "", "description": "给定一个长度为 $n$ 的序列，给出 $q$ 个操作，形如：\n\n$1~l~r~x$ 表示将序列下标介于 $[l,r]$ 的元素加上 $x$ （请注意，$x$ 可能为负）\n\n$2~p~y$ 表示查询 $a_p$ 在过去的多少秒时间内不小于 $y$ （不包括这一秒，细节请参照样例）\n\n开始时为第 $0$ 秒，第 $i$ 个操作发生在第 $i$ 秒。\n", "inputFormat": "第一行两个整数 $n,q$，意义如描述所述。\n\n接下来一行 $n$ 个整数 $a_i$，表示序列的每个元素的初始值。\n\n接下来 $q$ 行，每行第一个数为 $\\text{opt}$，表示这次操作的类型。如果 $\\text{opt} = 1$，后面紧跟三个整数 $l, r, x$，意义如描述所述；如果 $\\text{opt} = 2$，后面紧跟两个整数 $p, y$，意义如描述所述。\n", "outputFormat": "对于每个操作 $2$，在一行内输出一个数表示答案。\n", "hint": "样例一说明：位置 $1$ 在第 $0$ 秒到第 $3$ 秒的值为 $1,1,-2,-2$。对于第一个查询，第 $0$ 到 $1-1=0$ 秒中时间不小于 $2$；对于第二个查询，第 $0$ 到第 $3-1=2$ 秒时间不小于 $1$，分别为第 $0$ 秒，第 $1$ 秒。\n\n\n对于 $30\\%$ 的数据，保证 $n,q \\leq 1000$\n\n对于 $70\\%$ 的数据，保证 $n,q \\leq 50000$\n\n对于 $100\\%$ 的数据，保证 $2 \\leq n,q \\leq 100000$， $1 \\leq l \\leq r \\leq n$， $1 \\leq p \\leq n$，$-10^9 \\leq x,y,a_i \\leq 10^9$\n", "locale": "zh-CN", "translations": {"en": {"title": "Sequence", "background": "", "description": "Given a sequence of length $n$, there are $q$ operations of the following forms.\n\n$1~l~r~x$ means adding $x$ to each element with index in $[l,r]$ (note that $x$ may be negative).\n\n$2~p~y$ means querying for how many seconds in the past $a_p$ has been at least $y$ (excluding the current second; see the sample for details).\n\nTime starts at second $0$, and the $i$-th operation occurs at second $i$.", "inputFormat": "The first line contains two integers $n,q$, as described.\n\nThe second line contains $n$ integers $a_i$, the initial values of the sequence.\n\nEach of the next $q$ lines starts with $\\text{opt}$, indicating the type of this operation. If $\\text{opt} = 1$, it is followed by three integers $l, r, x$, as described. If $\\text{opt} = 2$, it is followed by two integers $p, y$, as described.", "outputFormat": "For each operation of type $2$, output one integer on a single line indicating the answer.", "hint": "Explanation for Sample 1: at position $1$, the values from second $0$ to second $3$ are $1,1,-2,-2$. For the first query, during seconds $0$ to $1-1=0$, the value is not less than $2$. For the second query, during seconds $0$ to $3-1=2$, the value is not less than $1$, namely at second $0$ and second $1$.\n\nFor $30\\%$ of the testdata, $n,q \\leq 1000$.\n\nFor $70\\%$ of the testdata, $n,q \\leq 50000$.\n\nFor $100\\%$ of the testdata, $2 \\leq n,q \\leq 100000$, $1 \\leq l \\leq r \\leq n$, $1 \\leq p \\leq n$, $-10^9 \\leq x,y,a_i \\leq 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "序列", "background": "", "description": "给定一个长度为 $n$ 的序列，给出 $q$ 个操作，形如：\n\n$1~l~r~x$ 表示将序列下标介于 $[l,r]$ 的元素加上 $x$ （请注意，$x$ 可能为负）\n\n$2~p~y$ 表示查询 $a_p$ 在过去的多少秒时间内不小于 $y$ （不包括这一秒，细节请参照样例）\n\n开始时为第 $0$ 秒，第 $i$ 个操作发生在第 $i$ 秒。\n", "inputFormat": "第一行两个整数 $n,q$，意义如描述所述。\n\n接下来一行 $n$ 个整数 $a_i$，表示序列的每个元素的初始值。\n\n接下来 $q$ 行，每行第一个数为 $\\text{opt}$，表示这次操作的类型。如果 $\\text{opt} = 1$，后面紧跟三个整数 $l, r, x$，意义如描述所述；如果 $\\text{opt} = 2$，后面紧跟两个整数 $p, y$，意义如描述所述。\n", "outputFormat": "对于每个操作 $2$，在一行内输出一个数表示答案。\n", "hint": "样例一说明：位置 $1$ 在第 $0$ 秒到第 $3$ 秒的值为 $1,1,-2,-2$。对于第一个查询，第 $0$ 到 $1-1=0$ 秒中时间不小于 $2$；对于第二个查询，第 $0$ 到第 $3-1=2$ 秒时间不小于 $1$，分别为第 $0$ 秒，第 $1$ 秒。\n\n\n对于 $30\\%$ 的数据，保证 $n,q \\leq 1000$\n\n对于 $70\\%$ 的数据，保证 $n,q \\leq 50000$\n\n对于 $100\\%$ 的数据，保证 $2 \\leq n,q \\leq 100000$， $1 \\leq l \\leq r \\leq n$， $1 \\leq p \\leq n$，$-10^9 \\leq x,y,a_i \\leq 10^9$\n", "locale": "zh-CN"}}}
{"pid": "P3864", "type": "P", "difficulty": 3, "samples": [["4734\nNMSL\nGREG\nLSDC\n....(太多了不写了)", "GREG\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [230000, 230000, 230000, 230000, 230000, 230000, 230000, 230000, 230000, 230000, 230000, 230000, 230000, 230000, 230000]}, "tags": ["模拟", "字符串", "搜索", "USACO", "枚举", "深度优先搜索 DFS"], "title": "[USACO1.2] 命名那个数字 Name That Number", "background": "", "description": "在威斯康辛州牛守志大农场经营者之中，都习惯于请会计部门用连续数字给母牛打上烙印。但是,母牛本身并没感到这个系统的便利,它们更喜欢用它们喜欢的名字来呼叫它们的同伴，而不是用像这个的语句：“C'mon, #4364, 相处愉快。”请写一个程序来帮助可怜的牧牛工将一只母牛的烙印编号翻译成一个可能的名字。因为母牛们现在都有手机了，可以按照下表来转换数字为字母：\n\n| 数字 | 对应字母 |\n|:-:|:-:|\n| $2$ | A,B,C |\n| $3$ | D,E,F |\n| $4$ | G,H,I |\n| $5$ | J,K,L |\n| $6$ | M,N,O |\n| $7$ | P,R,S |\n| $8$ | T,U,V |\n| $9$ | W,X,Y |\n\n请注意没有字符 `Q` 和字符 `Z`。\n\n牛群们可接受的名字都被放在这样一个叫作 \"[dict.txt](https://usaco.training/usaco/namenumdict.txt)\" 的文件中，它包含一连串的少于 $5000$ 个（准确地说是 $4617$ 个）可被接受的牛的名字。(所有的名字都是大写的且已按字典序排列) 请读入母牛的编号并返回那些能从编号翻译出来并且在字典中的名字。举例来说，编号 $4734$  能产生的 $81$ 个名字中只有一个 \"`GREG`\" 是有效的（在字典中）。\n\n写一个程序来对给出的编号打印出所有的有效名字，如果没有则输出 `NONE`。", "inputFormat": "第一行一行包含一个编号，长度 $1$ 到 $12$。\n\n接下来若干行，每行一个字符串表示可以被接受的名字。", "outputFormat": "以字典顺序输出一个有效名字的不重复列表，一行一个名字。如果没有有效名字，输出 `NONE`。 ", "hint": "$4734$ 所能产生的所有组合如下：\n\n```\nGPDG GPDH GPDI GPEG GPEH GPEI GPFG GPFH GPFI GRDG GRDH GRDI GREG GREH GREI GRFG GRFH GRFI GSDG GSDH GSDI GSEG GSEH GSEI GSFG GSFH GSFI HPDG HPDH HPDI HPEG HPEH HPEI HPFG HPFH HPFI HRDG HRDH HRDI HREG HREH HREI HRFG HRFH HRFI HSDG HSDH HSDI HSEG HSEH HSEI HSFG HSFH HSFI IPDG IPDH IPDI IPEG IPEH IPEI IPFG IPFH IPFI IRDG IRDH IRDI IREG IREH IREI IRFG IRFH IRFI ISDG ISDH ISDI ISEG ISEH ISEI ISFG ISFH ISFI\n```", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.2] Name That Number", "background": "", "description": "Among dairy farmers in Wisconsin, it is customary for the accounting department to brand cows with consecutive numbers. The cows themselves do not find this system convenient; they prefer to call their companions by their favorite names rather than with phrases like \"C'mon, #4364, be friendly.\" Please write a program to help the poor cowhands translate a cow's brand number into a possible name. Since cows now all have cell phones, you can convert digits to letters according to the table below.\n\n| Digit | Letters |\n|:-:|:-:|\n| $2$ | A,B,C |\n| $3$ | D,E,F |\n| $4$ | G,H,I |\n| $5$ | J,K,L |\n| $6$ | M,N,O |\n| $7$ | P,R,S |\n| $8$ | T,U,V |\n| $9$ | W,X,Y |\n\nNote that the letters `Q` and `Z` are not present.\n\nThe set of acceptable cow names is stored in a file called \"[dict.txt](https://usaco.training/usaco/namenumdict.txt)\", which contains a sequence of fewer than $5000$ (specifically, $4617$) acceptable names. All names are uppercase and already sorted in lexicographical order. Read the cow's number and return those names that can be translated from the number and appear in the dictionary. For example, among the $81$ names generated by the number $4734$, only \"`GREG`\" is valid (i.e., present in the dictionary).\n\nWrite a program to print all valid names for the given number. If there are none, output `NONE`.", "inputFormat": "The first line contains a number of length $1$ to $12$.\n\nThe following lines (until EOF), one per line, each contain a string representing an acceptable name.", "outputFormat": "Output a deduplicated list of valid names in lexicographical order, one name per line. If there are no valid names, output `NONE`.", "hint": "All combinations producible from $4734$ are as follows:\n\n```\nGPDG GPDH GPDI GPEG GPEH GPEI GPFG GPFH GPFI GRDG GRDH GRDI GREG GREH GREI GRFG GRFH GRFI GSDG GSDH GSDI GSEG GSEH GSEI GSFG GSFH GSFI HPDG HPDH HPDI HPEG HPEH HPEI HPFG HPFH HPFI HRDG HRDH HRDI HREG HREH HREI HRFG HRFH HRFI HSDG HSDH HSDI HSEG HSEH HSEI HSFG HSFH HSFI IPDG IPDH IPDI IPEG IPEH IPEI IPFG IPFH IPFI IRDG IRDH IRDI IREG IREH IREI IRFG IRFH IRFI ISDG ISDH ISDI ISEG ISEH ISEI ISFG ISFH ISFI\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.2] 命名那个数字 Name That Number", "background": "", "description": "在威斯康辛州牛守志大农场经营者之中，都习惯于请会计部门用连续数字给母牛打上烙印。但是,母牛本身并没感到这个系统的便利,它们更喜欢用它们喜欢的名字来呼叫它们的同伴，而不是用像这个的语句：“C'mon, #4364, 相处愉快。”请写一个程序来帮助可怜的牧牛工将一只母牛的烙印编号翻译成一个可能的名字。因为母牛们现在都有手机了，可以按照下表来转换数字为字母：\n\n| 数字 | 对应字母 |\n|:-:|:-:|\n| $2$ | A,B,C |\n| $3$ | D,E,F |\n| $4$ | G,H,I |\n| $5$ | J,K,L |\n| $6$ | M,N,O |\n| $7$ | P,R,S |\n| $8$ | T,U,V |\n| $9$ | W,X,Y |\n\n请注意没有字符 `Q` 和字符 `Z`。\n\n牛群们可接受的名字都被放在这样一个叫作 \"[dict.txt](https://usaco.training/usaco/namenumdict.txt)\" 的文件中，它包含一连串的少于 $5000$ 个（准确地说是 $4617$ 个）可被接受的牛的名字。(所有的名字都是大写的且已按字典序排列) 请读入母牛的编号并返回那些能从编号翻译出来并且在字典中的名字。举例来说，编号 $4734$  能产生的 $81$ 个名字中只有一个 \"`GREG`\" 是有效的（在字典中）。\n\n写一个程序来对给出的编号打印出所有的有效名字，如果没有则输出 `NONE`。", "inputFormat": "第一行一行包含一个编号，长度 $1$ 到 $12$。\n\n接下来若干行，每行一个字符串表示可以被接受的名字。", "outputFormat": "以字典顺序输出一个有效名字的不重复列表，一行一个名字。如果没有有效名字，输出 `NONE`。 ", "hint": "$4734$ 所能产生的所有组合如下：\n\n```\nGPDG GPDH GPDI GPEG GPEH GPEI GPFG GPFH GPFI GRDG GRDH GRDI GREG GREH GREI GRFG GRFH GRFI GSDG GSDH GSDI GSEG GSEH GSEI GSFG GSFH GSFI HPDG HPDH HPDI HPEG HPEH HPEI HPFG HPFH HPFI HRDG HRDH HRDI HREG HREH HREI HRFG HRFH HRFI HSDG HSDH HSDI HSEG HSEH HSEI HSFG HSFH HSFI IPDG IPDH IPDI IPEG IPEH IPEI IPFG IPFH IPFI IRDG IRDH IRDI IREG IREH IREI IRFG IRFH IRFI ISDG ISDH ISDI ISEG ISEH ISEI ISFG ISFH ISFI\n```", "locale": "zh-CN"}}}
{"pid": "P3865", "type": "P", "difficulty": 3, "samples": [["8 8\n9 3 1 7 5 6 0 8\n1 6\n1 5\n2 7\n2 6\n1 8\n4 8\n3 7\n1 8", "9\n9\n7\n7\n9\n8\n7\n9"]], "limits": {"time": [800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["倍增", "O2优化", "ST 表", "模板题"], "title": "【模板】ST 表 & RMQ 问题", "background": "这是一道 ST 表经典题——静态区间最大值\n\n**请注意最大数据时限只有 0.8s，数据强度不低，请务必保证你的每次查询复杂度为 $O(1)$。若使用更高时间复杂度算法不保证能通过。**\n\n如果您认为您的代码时间复杂度正确但是 TLE，可以尝试使用快速读入：\n\n```cpp\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\treturn x*f;\n}\n```\n\n函数返回值为读入的第一个整数。\n\n**快速读入作用仅为加快读入，并非强制使用。**", "description": "给定一个长度为 $N$ 的数列，和 $ M $ 次询问，求出每一次询问的区间内数字的最大值。", "inputFormat": "第一行包含两个整数 $N,M$，分别表示数列的长度和询问的个数。\n\n第二行包含 $N$ 个整数（记为 $a_i$），依次表示数列的第 $i$ 项。\n\n接下来 $M$ 行，每行包含两个整数 $l_i,r_i$，表示查询的区间为 $[l_i,r_i]$。", "outputFormat": "输出包含 $M$ 行，每行一个整数，依次表示每一次询问的结果。", "hint": "对于 $30\\%$ 的数据，满足 $1\\le N,M\\le 10$。\n\n对于 $70\\%$ 的数据，满足 $1\\le N,M\\le {10}^5$。\n\n对于 $100\\%$ 的数据，满足 $1\\le N\\le {10}^5$，$1\\le M\\le 2\\times{10}^6$，$a_i\\in[0,{10}^9]$，$1\\le l_i\\le r_i\\le N$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] ST Table & RMQ Problem", "background": "This is a classic ST table problem — static range maximum.\n\nPlease note that the maximum time limit for the largest testdata is only 0.8 s, and the data is not weak. Please ensure that the time complexity per query is $O(1)$. If you use a higher time complexity algorithm, it is not guaranteed to pass.\n\nIf you believe your code has the correct time complexity but gets TLE, you can try fast input:\n\n```cpp\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\treturn x*f;\n}\n```\n\nThe function returns the first integer read.\n\nFast input is only for speeding up input and is not mandatory.", "description": "Given a sequence of length $N$ and $M$ queries, for each query, find the maximum number in the specified interval.", "inputFormat": "The first line contains two integers $N, M$, representing the length of the sequence and the number of queries.\n\nThe second line contains $N$ integers (denoted as $a_i$), representing the $i$-th element of the sequence in order.\n\nThe next $M$ lines each contain two integers $l_i, r_i$, indicating that the query interval is $[l_i, r_i]$.", "outputFormat": "Output $M$ lines, each containing one integer, representing the answer to each query in order.", "hint": "- For 30% of the testdata, $1 \\le N, M \\le 10$.\n- For 70% of the testdata, $1 \\le N, M \\le {10}^5$.\n- For 100% of the testdata, $1 \\le N \\le {10}^5$, $1 \\le M \\le 2 \\times {10}^6$, $a_i \\in [0, {10}^9]$, $1 \\le l_i \\le r_i \\le N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】ST 表 & RMQ 问题", "background": "这是一道 ST 表经典题——静态区间最大值\n\n**请注意最大数据时限只有 0.8s，数据强度不低，请务必保证你的每次查询复杂度为 $O(1)$。若使用更高时间复杂度算法不保证能通过。**\n\n如果您认为您的代码时间复杂度正确但是 TLE，可以尝试使用快速读入：\n\n```cpp\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}\n\treturn x*f;\n}\n```\n\n函数返回值为读入的第一个整数。\n\n**快速读入作用仅为加快读入，并非强制使用。**", "description": "给定一个长度为 $N$ 的数列，和 $ M $ 次询问，求出每一次询问的区间内数字的最大值。", "inputFormat": "第一行包含两个整数 $N,M$，分别表示数列的长度和询问的个数。\n\n第二行包含 $N$ 个整数（记为 $a_i$），依次表示数列的第 $i$ 项。\n\n接下来 $M$ 行，每行包含两个整数 $l_i,r_i$，表示查询的区间为 $[l_i,r_i]$。", "outputFormat": "输出包含 $M$ 行，每行一个整数，依次表示每一次询问的结果。", "hint": "对于 $30\\%$ 的数据，满足 $1\\le N,M\\le 10$。\n\n对于 $70\\%$ 的数据，满足 $1\\le N,M\\le {10}^5$。\n\n对于 $100\\%$ 的数据，满足 $1\\le N\\le {10}^5$，$1\\le M\\le 2\\times{10}^6$，$a_i\\in[0,{10}^9]$，$1\\le l_i\\le r_i\\le N$。", "locale": "zh-CN"}}}
{"pid": "P3866", "type": "P", "difficulty": 6, "samples": [["4 3\n1 2 1\n1 10 1\n1 0 -1\n1 1 1", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "最小割", "天津"], "title": "[TJOI2009] 战争游戏", "background": "小R正在玩一个战争游戏。游戏地图是一个M行N列的矩阵，每个格子可能是障碍物，也可能是空地，在游戏开始时有若干支敌军分散在不同的空地格子中。每支敌军都可以从当前所在的格子移动到四个相邻的格子之一，但是不能移动到包含障碍物的格子。如果敌军移动出了地图的边界，那么战争就失败了。\n", "description": "现在你的任务是，在敌军开始移动前，通过飞机轰炸使得某些原本是空地的格子变得不可通行，这样就有可能阻止敌军移出地图边界（出于某种特殊的考虑，你不能直接轰炸敌军所在的格子）。由于地形不同的原因，把每个空地格子轰炸成不可通行所需的炸药数目可能是不同的，你需要计算出要阻止敌军所需的最少的炸药数。\n", "inputFormat": "输入文件的第一行包含两个数M和N，分别表示矩阵的长和宽。接下来M行，每行包含用空格隔开的N个数字，每个数字表示一个格子的情况：若数字为-1，表示这个格子是障碍物；若数字为0，表示这个格子里有一支敌军；若数字为一个正数x，表示这个格子是空地，且把它轰炸成不可通行所需的炸药数为x。\n\n地图上的敌军数量不为1，即地图上有多个0。", "outputFormat": "输出一个数字，表示所需的最少炸药数。数据保证有解存在。\n", "hint": "对50%的数据，1 ≤ M,N ≤ 10\n\n对100%的数据，1 ≤ M,N ≤ 30\n\n矩阵里的每个数不超过100\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2009] War Game", "background": "Xiao R is playing a war game. The map is an $M$-row, $N$-column grid. Each cell may be an obstacle or empty. At the start of the game, several enemy units are scattered across different empty cells. Each enemy unit can move from its current cell to one of the four adjacent cells, but it cannot move into a cell that contains an obstacle. If an enemy unit moves outside the map boundary, the war is lost.", "description": "Before the enemies start moving, your task is to use airstrikes to turn some originally empty cells into impassable cells, which may prevent the enemies from leaving the map. For special reasons, you cannot bomb any cell currently occupied by an enemy unit. Due to terrain differences, the amount of explosives needed to bomb each empty cell into an impassable cell may vary. You need to compute the minimum total amount of explosives required to prevent the enemies from moving out of the map boundary.", "inputFormat": "The first line contains two integers $M$ and $N$, the numbers of rows and columns of the grid. The next $M$ lines each contain $N$ space-separated integers, describing the grid cells:\n- If the number is $-1$, the cell is an obstacle.\n- If the number is $0$, there is an enemy unit in this cell.\n- If the number is a positive integer $x$, the cell is empty, and $x$ units of explosives are needed to bomb it into an impassable cell.\n\nThe number of enemy units on the map is not equal to $1$ (i.e., there are at least two cells with $0$).", "outputFormat": "Output a single number: the minimum total amount of explosives required. The testdata guarantee that a solution exists.", "hint": "- For 50% of the testdata, $1 \\le M, N \\le 10$.\n- For 100% of the testdata, $1 \\le M, N \\le 30$.\n- Every number in the matrix does not exceed $100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2009] 战争游戏", "background": "小R正在玩一个战争游戏。游戏地图是一个M行N列的矩阵，每个格子可能是障碍物，也可能是空地，在游戏开始时有若干支敌军分散在不同的空地格子中。每支敌军都可以从当前所在的格子移动到四个相邻的格子之一，但是不能移动到包含障碍物的格子。如果敌军移动出了地图的边界，那么战争就失败了。\n", "description": "现在你的任务是，在敌军开始移动前，通过飞机轰炸使得某些原本是空地的格子变得不可通行，这样就有可能阻止敌军移出地图边界（出于某种特殊的考虑，你不能直接轰炸敌军所在的格子）。由于地形不同的原因，把每个空地格子轰炸成不可通行所需的炸药数目可能是不同的，你需要计算出要阻止敌军所需的最少的炸药数。\n", "inputFormat": "输入文件的第一行包含两个数M和N，分别表示矩阵的长和宽。接下来M行，每行包含用空格隔开的N个数字，每个数字表示一个格子的情况：若数字为-1，表示这个格子是障碍物；若数字为0，表示这个格子里有一支敌军；若数字为一个正数x，表示这个格子是空地，且把它轰炸成不可通行所需的炸药数为x。\n\n地图上的敌军数量不为1，即地图上有多个0。", "outputFormat": "输出一个数字，表示所需的最少炸药数。数据保证有解存在。\n", "hint": "对50%的数据，1 ≤ M,N ≤ 10\n\n对100%的数据，1 ≤ M,N ≤ 30\n\n矩阵里的每个数不超过100\n", "locale": "zh-CN"}}}
{"pid": "P3867", "type": "P", "difficulty": 5, "samples": [["4 2", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 10000, 10000, 10000, 10000, 10000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2009", "各省省选", "O2优化", "枚举", "天津"], "title": "[TJOI2009] 排列计数", "background": null, "description": "我们知道，$1,2,...,N$ 这个 $N$ 个数的排列共有 $N!$ 种情况。现在你的任务是，求出在这 $N!$ 种排列中，任意相邻两数之差不超过 $K$ 的排列共有多少个。\n\n因为结果可能很大，你只需输出结果对 $10^9+7$ 取模后的值即可。", "inputFormat": "输入只有一行，包含用空格隔开的两个数：$N, K$。", "outputFormat": "输出满足要求的排列个数对 $10^9+7$ 取模后的结果。", "hint": "在 $30 \\%$ 的数据中，$N \\le 12$\n\n在 $100 \\%$ 的数据中，$N \\le 50,K \\le 4$\n\n每个测试点时限 10 秒。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2009] Permutation Counting", "background": "", "description": "We know there are $N!$ permutations of the $N$ numbers $1,2,...,N$. Your task is to count how many of these permutations have the property that the difference between any two adjacent numbers does not exceed $K$.\n\nSince the result may be large, output the answer modulo $10^9+7$.", "inputFormat": "The input contains a single line with two space-separated integers: $N, K$.", "outputFormat": "Output the number of valid permutations modulo $10^9+7$.", "hint": "On 30% of the testdata, $N \\le 12$.\n\nOn 100% of the testdata, $N \\le 50$, $K \\le 4$.\n\nTime limit per test point: 10 seconds.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2009] 排列计数", "background": null, "description": "我们知道，$1,2,...,N$ 这个 $N$ 个数的排列共有 $N!$ 种情况。现在你的任务是，求出在这 $N!$ 种排列中，任意相邻两数之差不超过 $K$ 的排列共有多少个。\n\n因为结果可能很大，你只需输出结果对 $10^9+7$ 取模后的值即可。", "inputFormat": "输入只有一行，包含用空格隔开的两个数：$N, K$。", "outputFormat": "输出满足要求的排列个数对 $10^9+7$ 取模后的结果。", "hint": "在 $30 \\%$ 的数据中，$N \\le 12$\n\n在 $100 \\%$ 的数据中，$N \\le 50,K \\le 4$\n\n每个测试点时限 10 秒。", "locale": "zh-CN"}}}
{"pid": "P3868", "type": "P", "difficulty": 5, "samples": [["3\n1 2 3\n2 3 5\n", "23"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2009", "各省省选", "扩展欧几里德算法", "中国剩余定理 CRT", "天津"], "title": "[TJOI2009] 猜数字", "background": "", "description": "现有两组数字，每组 $k$ 个。\n\n第一组中的数字分别用 $a_1,a_2,\\cdots ,a_k$ 表示，第二组中的数字分别用 $b_1,b_2,\\cdots ,b_k$ 表示。\n\n其中第二组中的数字是两两互素的。求最小的 $n\\in \\mathbb{N}$，满足对于 $\\forall i\\in [1,k]$，有 $b_i | (n-a_i)$。", "inputFormat": "第一行一个整数 $k$。\n\n第二行 $k$ 个整数，表示：$a_1,a_2,\\cdots ,a_k$。\n\n第三行 $k$ 个整数，表示：$b_1,b_2,\\cdots ,b_k$。", "outputFormat": "输出一行一个整数，为所求的答案 $n$。", "hint": "对于 $100\\%$ 的数据：\n\n$1\\le k \\le 10$，$|a_i|\\le 10^9$，$1\\le b_i\\le 6\\times 10^3$，$\\prod_{i=1}^k b_i\\le 10^{18}$。\n\n每个测试点时限 $1$ 秒。\n\n注意：对于 ```C/C++``` 语言，对 $64$ 位整型数应声明为 ```long long```。\n\n若使用 ```scanf```，```printf``` 函数（以及 ```fscanf```，```fprintf``` 等），应采用 ```%lld``` 标识符。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2009] Guess the Number", "background": "", "description": "There are two groups of numbers, each with $k$ elements.\n\nThe numbers in the first group are denoted by $a_1,a_2,\\cdots ,a_k$, and the numbers in the second group are denoted by $b_1,b_2,\\cdots ,b_k$.\n\nThe numbers in the second group are pairwise coprime. Find the smallest $n\\in \\mathbb{N}$ such that for $\\forall i\\in [1,k]$, $b_i | (n-a_i)$ holds.", "inputFormat": "The first line contains an integer $k$.\n\nThe second line contains $k$ integers: $a_1,a_2,\\cdots ,a_k$.\n\nThe third line contains $k$ integers: $b_1,b_2,\\cdots ,b_k$.", "outputFormat": "Output a single integer, which is the required answer $n$.", "hint": "Constraints:\n\n$1\\le k \\le 10$，$|a_i|\\le 10^9$，$1\\le b_i\\le 6\\times 10^3$，$\\prod_{i=1}^k b_i\\le 10^{18}$.\n\nTime limit per test case: 1 second.\n\nNote: For ```C/C++``` language, 64-bit integers should be declared as ```long long```.\n\nIf using ```scanf``` and ```printf``` (as well as ```fscanf```, ```fprintf```, etc.), use the ```%lld``` specifier.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2009] 猜数字", "background": "", "description": "现有两组数字，每组 $k$ 个。\n\n第一组中的数字分别用 $a_1,a_2,\\cdots ,a_k$ 表示，第二组中的数字分别用 $b_1,b_2,\\cdots ,b_k$ 表示。\n\n其中第二组中的数字是两两互素的。求最小的 $n\\in \\mathbb{N}$，满足对于 $\\forall i\\in [1,k]$，有 $b_i | (n-a_i)$。", "inputFormat": "第一行一个整数 $k$。\n\n第二行 $k$ 个整数，表示：$a_1,a_2,\\cdots ,a_k$。\n\n第三行 $k$ 个整数，表示：$b_1,b_2,\\cdots ,b_k$。", "outputFormat": "输出一行一个整数，为所求的答案 $n$。", "hint": "对于 $100\\%$ 的数据：\n\n$1\\le k \\le 10$，$|a_i|\\le 10^9$，$1\\le b_i\\le 6\\times 10^3$，$\\prod_{i=1}^k b_i\\le 10^{18}$。\n\n每个测试点时限 $1$ 秒。\n\n注意：对于 ```C/C++``` 语言，对 $64$ 位整型数应声明为 ```long long```。\n\n若使用 ```scanf```，```printf``` 函数（以及 ```fscanf```，```fprintf``` 等），应采用 ```%lld``` 标识符。", "locale": "zh-CN"}}}
{"pid": "P3869", "type": "P", "difficulty": 4, "samples": [["5 5\nS.#..\n#####\n..#..\n##.#.\n...#T\n6\n1 5 4 2\n1 4 3 3\n5 1 3 3\n1 4 4 5\n1 2 1 3\n1 5 2 1\n", "22"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2009", "各省省选", "O2优化", "天津", "状压 DP"], "title": "[TJOI2009] 宝藏", "background": "", "description": "为了寻找传说中的宝藏，小明走进了一个迷宫，我们用一个 $r$ 行 $c$ 列的矩阵来描述这个迷宫，矩阵的每个位置表示一个方块区域：\n\n- 字符 `.` 表示可以通过的方格。\n- 字符 `#` 表示不能通过的方格。\n- 在迷宫中有 $k$ 个机关，第 $i$ 个机关工作方式为：  \n  - 每当小明走上第 $r_i$ 行，$c_i$ 列的格子时，位于第 $R_i$ 行，$C_i$ 列的格子改变状态（如果这个格子此时可以通过，此后就变为不能通过；如果此时不能通过，此后可以通过。最左上角的格子是第 $1$ 行第 $1$ 列）。\n\n现给出当前小明的位置，宝藏的位置，迷宫中每个格子的状态，以及所有机关的描述，问小明至少还要走多少步才能拿到宝藏（不能走出迷宫的边界，在开始时刻，小明和宝藏所在的位置都是可以通过的，机关不会出现在起点和终点，也不会影响这两个格子）。\n", "inputFormat": "输入数据的第 $1$ 行是两个整数：$r$ 和 $c$。\n\n输入数据的第 $2$ 行到第 $r+1$ 行，每行是一个长度为 $c$ 的字符串，描述迷宫的当前状态：`.` 表示此时可以通过的格子，`#` 表示此时不能通过的格子，`S` 表示起点，`T` 表示宝藏的位置。\n\n输入数据的第 $r+2$ 行是一个整数 $k$，表示机关的数目。接下来有 $k$ 行，每一行包含 $4$ 个整数 $r_i,c_i,R_i,C_i$，用来描述一个机关。\n", "outputFormat": "输出一个整数：小明最少需要走多少步才能拿到宝藏。测试数据保证可以找到宝藏。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$5 \\le r, c \\le 30$，$0 \\le k \\le 10$，$1 \\le r_i,R_i\\le r$，$1 \\le c_i,C_i \\le c$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2009] Treasure", "background": "", "description": "To search for the legendary treasure, Xiao Ming enters a maze. We describe this maze with an $r$-by-$c$ matrix, where each position represents a square cell:\n\n- The character `.` means the cell is passable.\n- The character `#` means the cell is impassable.\n- There are $k$ mechanisms in the maze. The $i$-th mechanism works as follows:\n  - Whenever Xiao Ming steps onto the cell at row $r_i$, column $c_i$, the cell at row $R_i$, column $C_i$ toggles its state (if that cell is passable at that moment, it becomes impassable afterward; if it is impassable, it becomes passable afterward. The top-left cell is row $1$, column $1$).\n\nGiven Xiao Ming’s current position, the treasure’s position, the current state of every cell in the maze, and all mechanism descriptions, determine the minimum number of steps Xiao Ming still needs to reach the treasure (he cannot move outside the maze boundary. At the start, both Xiao Ming’s cell and the treasure’s cell are passable. No mechanism appears at the start or the end, and no mechanism affects these two cells).", "inputFormat": "The first line contains two integers: $r$ and $c$.\n\nLines $2$ to $r+1$ each contain a string of length $c$, describing the current state of the maze: `.` means a passable cell, `#` means an impassable cell, `S` marks the start, and `T` marks the treasure’s position.\n\nLine $r+2$ contains an integer $k$, the number of mechanisms. Then $k$ lines follow, each containing $4$ integers $r_i, c_i, R_i, C_i$, describing one mechanism.", "outputFormat": "Output a single integer: the minimum number of steps Xiao Ming needs to reach the treasure. The testdata guarantees the treasure is reachable.", "hint": "Constraints\n\nFor all testdata, $5 \\le r, c \\le 30$, $0 \\le k \\le 10$, $1 \\le r_i, R_i \\le r$, $1 \\le c_i, C_i \\le c$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2009] 宝藏", "background": "", "description": "为了寻找传说中的宝藏，小明走进了一个迷宫，我们用一个 $r$ 行 $c$ 列的矩阵来描述这个迷宫，矩阵的每个位置表示一个方块区域：\n\n- 字符 `.` 表示可以通过的方格。\n- 字符 `#` 表示不能通过的方格。\n- 在迷宫中有 $k$ 个机关，第 $i$ 个机关工作方式为：  \n  - 每当小明走上第 $r_i$ 行，$c_i$ 列的格子时，位于第 $R_i$ 行，$C_i$ 列的格子改变状态（如果这个格子此时可以通过，此后就变为不能通过；如果此时不能通过，此后可以通过。最左上角的格子是第 $1$ 行第 $1$ 列）。\n\n现给出当前小明的位置，宝藏的位置，迷宫中每个格子的状态，以及所有机关的描述，问小明至少还要走多少步才能拿到宝藏（不能走出迷宫的边界，在开始时刻，小明和宝藏所在的位置都是可以通过的，机关不会出现在起点和终点，也不会影响这两个格子）。\n", "inputFormat": "输入数据的第 $1$ 行是两个整数：$r$ 和 $c$。\n\n输入数据的第 $2$ 行到第 $r+1$ 行，每行是一个长度为 $c$ 的字符串，描述迷宫的当前状态：`.` 表示此时可以通过的格子，`#` 表示此时不能通过的格子，`S` 表示起点，`T` 表示宝藏的位置。\n\n输入数据的第 $r+2$ 行是一个整数 $k$，表示机关的数目。接下来有 $k$ 行，每一行包含 $4$ 个整数 $r_i,c_i,R_i,C_i$，用来描述一个机关。\n", "outputFormat": "输出一个整数：小明最少需要走多少步才能拿到宝藏。测试数据保证可以找到宝藏。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$5 \\le r, c \\le 30$，$0 \\le k \\le 10$，$1 \\le r_i,R_i\\le r$，$1 \\le c_i,C_i \\le c$。\n", "locale": "zh-CN"}}}
{"pid": "P3870", "type": "P", "difficulty": 4, "samples": [["4 5\n0 1 2\n0 2 4\n1 2 3\n0 2 4\n1 1 4\n", "1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "线段树", "各省省选", "分块", "天津", "bitset"], "title": "[TJOI2009] 开关", "background": "", "description": "现有 $n$ 盏灯排成一排，从左到右依次编号为：$1$，$2$，……，$n$。然后依次执行 $m$ 项操作。\n\n操作分为两种：\n\n1. 指定一个区间 $[a,b]$，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开）；\n2. 指定一个区间 $[a,b]$，要求你输出这个区间内有多少盏灯是打开的。\n\n**灯在初始时都是关着的。**", "inputFormat": "第一行有两个整数 $n$ 和 $m$，分别表示灯的数目和操作的数目。\n\n接下来有 $m$ 行，每行有三个整数，依次为：$c$、$a$、$b$。其中 $c$ 表示操作的种类。\n\n- 当 $c$ 的值为 $0$ 时，表示是第一种操作。\n- 当 $c$ 的值为 $1$ 时，表示是第二种操作。\n\n$a$ 和 $b$ 则分别表示了操作区间的左右边界。", "outputFormat": "每当遇到第二种操作时，输出一行，包含一个整数，表示此时在查询的区间中打开的灯的数目。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $2\\le n\\le 10^5$，$1\\le m\\le 10^5$，$1\\le a,b\\le n$，$c\\in\\{0,1\\}$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2009] Switches", "background": "", "description": "There are $n$ lights in a row, numbered from left to right as $1, 2, \\ldots, n$. Then $m$ operations are performed in order.\n\nThere are two types of operations:\n1. Given an interval $[a, b]$, flip the state of every light whose index is in this interval (turn on lights that are off, and turn off lights that are on).\n2. Given an interval $[a, b]$, output how many lights are on within this interval.\n\nAll lights are initially off.", "inputFormat": "The first line contains two integers $n$ and $m$, the number of lights and the number of operations, respectively.\n\nEach of the next $m$ lines contains three integers $c$, $a$, and $b$, where $c$ denotes the type of operation.\n- If $c = 0$, it is the first type of operation.\n- If $c = 1$, it is the second type of operation.\n\n$a$ and $b$ are the left and right boundaries of the operation interval, respectively.", "outputFormat": "For each operation of the second type, output one line containing an integer, the number of lights that are on in the queried interval.", "hint": "Constraints.\n\nFor all testdata, it is guaranteed that $2 \\le n \\le 10^5$, $1 \\le m \\le 10^5$, $1 \\le a, b \\le n$, and $c \\in \\{0, 1\\}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2009] 开关", "background": "", "description": "现有 $n$ 盏灯排成一排，从左到右依次编号为：$1$，$2$，……，$n$。然后依次执行 $m$ 项操作。\n\n操作分为两种：\n\n1. 指定一个区间 $[a,b]$，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开）；\n2. 指定一个区间 $[a,b]$，要求你输出这个区间内有多少盏灯是打开的。\n\n**灯在初始时都是关着的。**", "inputFormat": "第一行有两个整数 $n$ 和 $m$，分别表示灯的数目和操作的数目。\n\n接下来有 $m$ 行，每行有三个整数，依次为：$c$、$a$、$b$。其中 $c$ 表示操作的种类。\n\n- 当 $c$ 的值为 $0$ 时，表示是第一种操作。\n- 当 $c$ 的值为 $1$ 时，表示是第二种操作。\n\n$a$ 和 $b$ 则分别表示了操作区间的左右边界。", "outputFormat": "每当遇到第二种操作时，输出一行，包含一个整数，表示此时在查询的区间中打开的灯的数目。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $2\\le n\\le 10^5$，$1\\le m\\le 10^5$，$1\\le a,b\\le n$，$c\\in\\{0,1\\}$。", "locale": "zh-CN"}}}
{"pid": "P3871", "type": "P", "difficulty": 4, "samples": [["6\n1 2 13 14 15 16\n5\nadd 5\nadd 3\nmid\nadd 20\nmid\n", "5\n13\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "平衡树", "O2优化", "排序", "天津"], "title": "[TJOI2010] 中位数", "background": "", "description": "给定一个由 $N$ 个元素组成的整数序列，现在有两种操作：\n\n- $\\texttt{1 add }\\textit{a}$：在该序列的最后添加一个整数 $a$，组成长度为 $N + 1$ 的整数序列。\n- $\\texttt{2 mid}$：输出当前序列的中位数。\n\n中位数是指将一个序列按照从小到大排序后处在中间位置的数。（若序列长度为偶数，则指处在中间位置的两个数中较小的那个）\n\n例 $1$：$[1, 2, 13, 14, 15, 16]$ 中位数为 $13$。  \n例 $2$：$[1, 3, 5, 7, 10, 11, 17]$ 中位数为 $7$。  \n例 $3$：$[1, 1, 1, 2, 3]$ 中位数为 $1$。\n", "inputFormat": "第一行为初始序列长度 $N$。第二行为 $N$ 个整数，表示整数序列，数字之间用空格分隔。第三行为操作数 $M$，即要进行 $M$ 次操作。下面为 $M$ 行，每行输入格式如题意所述。\n", "outputFormat": "对于每个 $\\verb!mid!$ 操作输出中位数的值。", "hint": "### 数据范围及约定\n\n- 对于 $30\\%$ 的数据，$1 ≤ N ≤ 10,000$，$0 ≤ M ≤ 1,000$。\n- 对于 $100\\%$ 的数据，$1 ≤ N ≤ 100,000$，$0 ≤ M ≤ 10,000$。\n\n序列中整数的绝对值不超过 $10^9$，序列中的数可能有重复。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Median", "background": "", "description": "Given an integer sequence of $N$ elements, there are two operations:\n\n- $\\texttt{1 add }\\textit{a}$: Append an integer $a$ to the end of the sequence, forming a sequence of length $N + 1$.\n- $\\texttt{2 mid}$: Output the median of the current sequence.\n\nThe median is the number that lies in the middle after sorting the sequence in non-decreasing order. If the sequence length is even, it is the smaller of the two middle numbers.\n\nExample 1: $[1, 2, 13, 14, 15, 16]$ has median $13$.  \nExample 2: $[1, 3, 5, 7, 10, 11, 17]$ has median $7$.  \nExample 3: $[1, 1, 1, 2, 3]$ has median $1$.", "inputFormat": "The first line contains the initial sequence length $N$.  \nThe second line contains $N$ integers, representing the sequence, separated by spaces.  \nThe third line contains the number of operations $M$, meaning you will perform $M$ operations.  \nThen follow $M$ lines, each in the format described above.", "outputFormat": "For each $\\verb!mid!$ operation, output the value of the median.", "hint": "### Constraints\n\n- For $30\\%$ of the testdata, $1 \\le N \\le 10{,}000$, $0 \\le M \\le 1{,}000$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 100{,}000$, $0 \\le M \\le 10{,}000$.\n\nThe absolute value of each integer in the sequence does not exceed $10^9$, and numbers in the sequence may repeat.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 中位数", "background": "", "description": "给定一个由 $N$ 个元素组成的整数序列，现在有两种操作：\n\n- $\\texttt{1 add }\\textit{a}$：在该序列的最后添加一个整数 $a$，组成长度为 $N + 1$ 的整数序列。\n- $\\texttt{2 mid}$：输出当前序列的中位数。\n\n中位数是指将一个序列按照从小到大排序后处在中间位置的数。（若序列长度为偶数，则指处在中间位置的两个数中较小的那个）\n\n例 $1$：$[1, 2, 13, 14, 15, 16]$ 中位数为 $13$。  \n例 $2$：$[1, 3, 5, 7, 10, 11, 17]$ 中位数为 $7$。  \n例 $3$：$[1, 1, 1, 2, 3]$ 中位数为 $1$。\n", "inputFormat": "第一行为初始序列长度 $N$。第二行为 $N$ 个整数，表示整数序列，数字之间用空格分隔。第三行为操作数 $M$，即要进行 $M$ 次操作。下面为 $M$ 行，每行输入格式如题意所述。\n", "outputFormat": "对于每个 $\\verb!mid!$ 操作输出中位数的值。", "hint": "### 数据范围及约定\n\n- 对于 $30\\%$ 的数据，$1 ≤ N ≤ 10,000$，$0 ≤ M ≤ 1,000$。\n- 对于 $100\\%$ 的数据，$1 ≤ N ≤ 100,000$，$0 ≤ M ≤ 10,000$。\n\n序列中整数的绝对值不超过 $10^9$，序列中的数可能有重复。", "locale": "zh-CN"}}}
{"pid": "P3872", "type": "P", "difficulty": 6, "samples": [["2 2\n100 -50\n1 2 49\n2 1 10\n", "51"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "图论建模", "最小割", "天津"], "title": "[TJOI2010] 电影迷", "background": null, "description": "小A是一个电影迷，他收集了上百部的电影，打算从中挑出若干部在假期看完。他根据自己的口味和网上的介绍，对每部电影 $X$ 都打了一个分数 $v_X$，表示自己喜欢的程度。这个分数的范围在 $-1000$ 至 $1000$ 之间，越大表示越喜欢。小A每看一部电影 $X$，他的体验值就会加上 $v_X$。\n\n另外，因为某些电影是组成一个系列的，比如著名的《终结者》系列、《黑客帝国》系列等等，如果小A只看了前一部而没有看后一部的话，他就会觉得不是很爽。准确来讲，对于任意两部不同的电影 $X,Y$，他们可能存在一个依赖值 $d_{X,Y}$，表示如果小A看了 $X$ 但是没看 $Y$，他的体验值就会减少 $d_{X,Y}$。（注意与观看的顺序无关，只要两部都看过，就不会减少体验值）\n\n现在他要选出若干电影来看，使得得到的总的体验值最大。如果他无法得到正的体验值，就输出 $0$。", "inputFormat": "输入的第一行是两个整数：电影总数 $N$ 和依赖关系数目 $M$。第二行包含用空格隔开的 $N$ 个数，表示对每部电影的打分。接下来 $M$ 行，每行包含三个整数 $X,Y,d_{X,Y}$，表示一个依赖关系。每个有序对 $(X,Y)$ 最多出现一次。$\\pod{1\\le X,Y\\le N}$", "outputFormat": "输出一个整数，表示小A能得到的最大体验值。", "hint": "如果小A只看电影 $1$，体验值为 $100-49=51$。如果只看电影2，体验值为 $-50-10=-60$。如果两部都看，体验值为 $100+(-50)=50$。所以应该只看电影 $1$。\n\n### 数据规模与约定\n\n对于 $20\\%$ 的数据，$1\\le N\\le 15$。\n\n对于 $100\\%$ 的数据，$1\\le N\\le 100,-1000\\le v_X \\le 1000,0<d_{X,Y}\\le 1000$\n\n每个测试点时限1秒", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Movie Buff", "background": "", "description": "Xiao A is a movie buff. He has collected hundreds of movies and plans to pick some to watch during the holidays. Based on his taste and online information, he assigned to each movie $X$ a score $v_X$ indicating how much he likes it. The score range is from $-1000$ to $1000$, and a larger score means he likes it more. Each time Xiao A watches a movie $X$, his experience increases by $v_X$.\n\nIn addition, because some movies belong to the same series (for example, the famous Terminator series, The Matrix series, etc.), if Xiao A watches an earlier one but not a later one, he will feel uncomfortable. More precisely, for any two distinct movies $X, Y$, there may be a dependency value $d_{X,Y}$, meaning that if Xiao A watches $X$ but not $Y$, his experience will decrease by $d_{X,Y}$. (Note that the viewing order does not matter; as long as both are watched, there is no penalty.)\n\nNow he wants to select some movies to watch to maximize the total experience. If he cannot obtain a positive experience, output $0$.", "inputFormat": "- The first line contains two integers: the total number of movies $N$ and the number of dependency relations $M$.\n- The second line contains $N$ space-separated numbers, the scores for each movie.\n- Each of the next $M$ lines contains three integers $X, Y, d_{X,Y}$, representing a dependency relation.\n- Each ordered pair $(X, Y)$ appears at most once. $1 \\le X, Y \\le N$.", "outputFormat": "Output one integer, the maximum experience Xiao A can obtain.", "hint": "If Xiao A only watches movie $1$, the experience is $100 - 49 = 51$. If he only watches movie $2$, the experience is $-50 - 10 = -60$. If he watches both, the experience is $100 + (-50) = 50$. Therefore, he should only watch movie $1$.\n\nConstraints:\n- For $20\\%$ of the testdata, $1 \\le N \\le 15$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 100$, $-1000 \\le v_X \\le 1000$, $0 < d_{X,Y} \\le 1000$.\n- Time limit per test point is 1 second.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 电影迷", "background": null, "description": "小A是一个电影迷，他收集了上百部的电影，打算从中挑出若干部在假期看完。他根据自己的口味和网上的介绍，对每部电影 $X$ 都打了一个分数 $v_X$，表示自己喜欢的程度。这个分数的范围在 $-1000$ 至 $1000$ 之间，越大表示越喜欢。小A每看一部电影 $X$，他的体验值就会加上 $v_X$。\n\n另外，因为某些电影是组成一个系列的，比如著名的《终结者》系列、《黑客帝国》系列等等，如果小A只看了前一部而没有看后一部的话，他就会觉得不是很爽。准确来讲，对于任意两部不同的电影 $X,Y$，他们可能存在一个依赖值 $d_{X,Y}$，表示如果小A看了 $X$ 但是没看 $Y$，他的体验值就会减少 $d_{X,Y}$。（注意与观看的顺序无关，只要两部都看过，就不会减少体验值）\n\n现在他要选出若干电影来看，使得得到的总的体验值最大。如果他无法得到正的体验值，就输出 $0$。", "inputFormat": "输入的第一行是两个整数：电影总数 $N$ 和依赖关系数目 $M$。第二行包含用空格隔开的 $N$ 个数，表示对每部电影的打分。接下来 $M$ 行，每行包含三个整数 $X,Y,d_{X,Y}$，表示一个依赖关系。每个有序对 $(X,Y)$ 最多出现一次。$\\pod{1\\le X,Y\\le N}$", "outputFormat": "输出一个整数，表示小A能得到的最大体验值。", "hint": "如果小A只看电影 $1$，体验值为 $100-49=51$。如果只看电影2，体验值为 $-50-10=-60$。如果两部都看，体验值为 $100+(-50)=50$。所以应该只看电影 $1$。\n\n### 数据规模与约定\n\n对于 $20\\%$ 的数据，$1\\le N\\le 15$。\n\n对于 $100\\%$ 的数据，$1\\le N\\le 100,-1000\\le v_X \\le 1000,0<d_{X,Y}\\le 1000$\n\n每个测试点时限1秒", "locale": "zh-CN"}}}
{"pid": "P3873", "type": "P", "difficulty": 5, "samples": [["2 3\n4 5\n6 7\n", "59"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "2010", "各省省选", "矩阵加速", "线性递推", "构造", "天津"], "title": "[TJOI2010] 天气预报", "background": "", "description": "A 公司的天气预报系统的原理如下：用一个大于等于 $0$，小于等于 $4146$ 的整数来表示这一天的天气情况，在预测未来某一天的天气情况时，要根据此前 $n$ 天的天气情况来预测，如果用 $w_i$ 表示第 $i$ 天的天气情况（$i>n$），那么 $w_i=(a_1\\times w_{i-1}+a_2\\times w_{i-2}+\\cdots+a_{n}\\times w_{i-n})\\mod4147$，其中 $a_1,a_2,\\cdots ,a_n$ 是已知常数。现给出前 $n$ 天的天气情况，问第 $m$ 天的天气预测结果是什么。", "inputFormat": "输入数据的第一行是两个正整数 $n$ 和 $m$，第二行有 $n$ 个非负整数，分别为 $w_n,w_{n-1},\\cdots,w_1$。第三行又有 $n$ 个非负整数，分别表示 $a_1,a_2,\\ldots,a_n$。", "outputFormat": "输出一个整数，表示对第 $m$ 天的天气预测结果。", "hint": "$1\\le n\\le 100$，$n<m\\le10^7$，$0\\le a_i,w_i\\le 4146$。\n\n每个测试点时限 1.5 秒", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Weather Forecast", "background": "", "description": "Company A's weather forecasting system works as follows: it represents the weather of a day by an integer greater than or equal to $0$ and less than or equal to $4146$. To predict the weather of some future day, it uses the weather of the previous $n$ days. If we denote the weather of day $i$ by $w_i$ ($i>n$), then $w_i=(a_1\\times w_{i-1}+a_2\\times w_{i-2}+\\cdots+a_{n}\\times w_{i-n})\\mod4147$, where $a_1,a_2,\\cdots ,a_n$ are known constants. Given the weather of the first $n$ days, find the prediction for day $m$.", "inputFormat": "The first line of input contains two positive integers $n$ and $m$. The second line contains $n$ non-negative integers, namely $w_n,w_{n-1},\\cdots,w_1$. The third line contains $n$ non-negative integers, namely $a_1,a_2,\\ldots,a_n$.", "outputFormat": "Output a single integer, which is the predicted weather for day $m$.", "hint": "$1\\le n\\le 100$, $n<m\\le10^7$, $0\\le a_i,w_i\\le 4146$.\n\nTime limit per test point: 1.5 seconds.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 天气预报", "background": "", "description": "A 公司的天气预报系统的原理如下：用一个大于等于 $0$，小于等于 $4146$ 的整数来表示这一天的天气情况，在预测未来某一天的天气情况时，要根据此前 $n$ 天的天气情况来预测，如果用 $w_i$ 表示第 $i$ 天的天气情况（$i>n$），那么 $w_i=(a_1\\times w_{i-1}+a_2\\times w_{i-2}+\\cdots+a_{n}\\times w_{i-n})\\mod4147$，其中 $a_1,a_2,\\cdots ,a_n$ 是已知常数。现给出前 $n$ 天的天气情况，问第 $m$ 天的天气预测结果是什么。", "inputFormat": "输入数据的第一行是两个正整数 $n$ 和 $m$，第二行有 $n$ 个非负整数，分别为 $w_n,w_{n-1},\\cdots,w_1$。第三行又有 $n$ 个非负整数，分别表示 $a_1,a_2,\\ldots,a_n$。", "outputFormat": "输出一个整数，表示对第 $m$ 天的天气预测结果。", "hint": "$1\\le n\\le 100$，$n<m\\le10^7$，$0\\le a_i,w_i\\le 4146$。\n\n每个测试点时限 1.5 秒", "locale": "zh-CN"}}}
{"pid": "P3874", "type": "P", "difficulty": 5, "samples": [["3 1\n20 10 20\n1 1 1\n1 2\n2 3\n", "20.00"], ["3 2\n20 10 20\n1 1 1\n1 2\n2 3\n", "16.67"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2010", "二分", "各省省选", "树形 DP", "分数规划", "天津"], "title": "[TJOI2010] 砍树", "background": "小 A 在果园里发现了一棵结满果子的树，于是他就打起了坏主意，他打算把树的一部分砍下来带回家。", "description": "我们可以把这棵树表示成一个树型的结构，也就是说，任意两个点之间有且仅有一条路径。在每个点 $i$ 处都结着一个水果，每个水果有一个价值 $v_i$ 和重量 $w_i$。小 A 想带走树的一部分（或全部），包含至少 $K$ 个结点（也就是至少 $K$ 个水果），且这些水果的平均价值尽可能高。平均价值是指水果总的价值除以总的重量。注意小 A 砍下的树必须是在原来的树中连通的一部分。", "inputFormat": "第一行包含两个数 $N$ 和 $K$，分别表示树的结点数和小 A 至少应带走的水果数。\n\n第二行包含空格隔开的 $N$ 个数，分别表示每个结点处水果的价值 $v_i$。\n\n第三行包含空格隔开的 $N$ 个数，分别表示每个水果的重量 $w_i$。\n\n按下来 $N-1$ 行，每行包含两个数 $a_i$ 和 $b_i$（$1 \\le a_i,b_i \\le N$），表示在结点 $a_i$ 和 $b_i$ 之间有一条边。输入保证是一棵正确的树结构。", "outputFormat": "输出一行，包含一个数，表示最大可能的平均价值。四舍五入到小数点后两位。\n", "hint": "### 数据规模与约定\n\n- 对 $20\\%$ 的数据，$1 \\le N \\le 16$；\n- 对 $100\\%$ 的数据，$1 \\le N \\le 100$，$1 \\le K \\le N$，$1 \\le v_i \\le 10000$，$1 \\le w_i \\le 10000$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Cutting the Tree", "background": "Xiao A found a tree full of fruits in an orchard, and he came up with a mischievous idea: he plans to cut off part of the tree and take it home.", "description": "We can represent this tree as a tree-structured graph, meaning there is exactly one path between any two nodes. At each node $i$, there is a fruit with value $v_i$ and weight $w_i$. Xiao A wants to take away a connected part (or the whole) of the tree that contains at least $K$ nodes (that is, at least $K$ fruits), such that the average value of these fruits is as high as possible. The average value is defined as the total value of the fruits divided by their total weight. Note that the part Xiao A cuts must be a connected subgraph of the original tree.", "inputFormat": "The first line contains two numbers $N$ and $K$, representing the number of nodes in the tree and the minimum number of fruits Xiao A should take.\n\nThe second line contains $N$ space-separated numbers, representing the value $v_i$ of the fruit at each node.\n\nThe third line contains $N$ space-separated numbers, representing the weight $w_i$ of each fruit.\n\nThe next $N - 1$ lines each contain two numbers $a_i$ and $b_i$ ($1 \\le a_i, b_i \\le N$), indicating that there is an edge between nodes $a_i$ and $b_i$. The input is guaranteed to describe a valid tree.", "outputFormat": "Output one line containing a single number, the maximum possible average value, rounded to two decimal places.", "hint": "- Constraints:\n  - For $20\\%$ of the testdata, $1 \\le N \\le 16$.\n  - For $100\\%$ of the testdata, $1 \\le N \\le 100$, $1 \\le K \\le N$, $1 \\le v_i \\le 10000$, $1 \\le w_i \\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 砍树", "background": "小 A 在果园里发现了一棵结满果子的树，于是他就打起了坏主意，他打算把树的一部分砍下来带回家。", "description": "我们可以把这棵树表示成一个树型的结构，也就是说，任意两个点之间有且仅有一条路径。在每个点 $i$ 处都结着一个水果，每个水果有一个价值 $v_i$ 和重量 $w_i$。小 A 想带走树的一部分（或全部），包含至少 $K$ 个结点（也就是至少 $K$ 个水果），且这些水果的平均价值尽可能高。平均价值是指水果总的价值除以总的重量。注意小 A 砍下的树必须是在原来的树中连通的一部分。", "inputFormat": "第一行包含两个数 $N$ 和 $K$，分别表示树的结点数和小 A 至少应带走的水果数。\n\n第二行包含空格隔开的 $N$ 个数，分别表示每个结点处水果的价值 $v_i$。\n\n第三行包含空格隔开的 $N$ 个数，分别表示每个水果的重量 $w_i$。\n\n按下来 $N-1$ 行，每行包含两个数 $a_i$ 和 $b_i$（$1 \\le a_i,b_i \\le N$），表示在结点 $a_i$ 和 $b_i$ 之间有一条边。输入保证是一棵正确的树结构。", "outputFormat": "输出一行，包含一个数，表示最大可能的平均价值。四舍五入到小数点后两位。\n", "hint": "### 数据规模与约定\n\n- 对 $20\\%$ 的数据，$1 \\le N \\le 16$；\n- 对 $100\\%$ 的数据，$1 \\le N \\le 100$，$1 \\le K \\le N$，$1 \\le v_i \\le 10000$，$1 \\le w_i \\le 10000$。", "locale": "zh-CN"}}}
{"pid": "P3875", "type": "P", "difficulty": 5, "samples": [["3\n1 3 4 3\n6 7 6 3\n4 6 7 6\n", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "线段树", "各省省选", "扫描线", "天津"], "title": "[TJOI2010] 被污染的河流", "background": "有一座城市，城市里有许多条人工河，河流的流向都是水平或者竖直的。为了方便市民用水，政府将河流设计成网格状。在水平方向上和竖直方向上，相邻河流的距离都是 $1$ 公里。河流围出许多格子，每个格子就是一个社区，社区里的居民可以到社区周边四条河段中的任意一处打水喝。\n", "description": "郁闷的是，不久之后，有些不法商人修建了工厂，污染了河流。河边许多居民喝了被污染的水，生病了。政府派出专员小强调查污染情况。地理专家小强行动迅速，很快给出了污染分布。他给出了一张污染清单。清单列出了被污染的河段，所有能喝到该河段水的居民都有可能生病（河段的端点处忽略不计）。但是，笨笨的小强怎么也算不出具体会有多少个社区的居民会生病，所以，他请你来帮帮忙。\n\n![](https://cdn.luogu.com.cn/upload/pic/6840.png)\n", "inputFormat": "输入文件的第一行是一个整数 $N$，表示被污染的河段的数目。\n\n接下来 $N$ 行，每行 $4$ 个整数 $x_1,y_1,x_2,y_2$，表示被污染河段的起始位置和结束位置。每行输入的两个位置保证不重合，并且满足 $x_1=x_2$ 或 $y_1=y_2$。\n", "outputFormat": "输出一个整数 $A$，表示有 $A$ 个社区的居民会喝到被污染的水。\n", "hint": "- 对于 $10\\%$ 的数据，$1 \\le  x_1,y_1,x_2,y_2 \\le 100$，$1\\le N \\le 100$；\n- 对于 $30\\%$ 的数据，$1 \\le x_1,y_1,x_2,y_2 \\le 10^4$，$1\\le N \\le 100$；\n- 对于 $100\\%$ 的数据，$1 \\le x_1,y_1,x_2,y_2 \\le 10^5$，$1\\le N \\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Polluted Rivers", "background": "There is a city with many artificial rivers, each flowing either horizontally or vertically. For residents’ convenience, the rivers are arranged in a grid. The distance between adjacent rivers in both the horizontal and vertical directions is $1$ kilometer. The rivers enclose many cells, each of which is a community. Residents of a community can fetch water at any of the four river segments surrounding the community.", "description": "Unfortunately, not long after, some unscrupulous business owners built factories and polluted the rivers. Many residents living by the rivers drank polluted water and became ill. The government sent an investigator, Xiaoqiang (pinyin), to examine the pollution. The geography expert Xiaoqiang acted quickly and soon produced a pollution report. The report lists the polluted river segments. All residents who can fetch water from any such segment may get sick (the endpoints of a segment are ignored). However, Xiaoqiang could not figure out exactly how many communities’ residents would become ill, so he has asked for your help.\n\n![](https://cdn.luogu.com.cn/upload/pic/6840.png)", "inputFormat": "The first line contains an integer $N$, the number of polluted river segments.\n\nEach of the next $N$ lines contains $4$ integers $x_1, y_1, x_2, y_2$, giving the start and end positions of a polluted segment. The two positions on each line are guaranteed to be distinct and satisfy $x_1 = x_2$ or $y_1 = y_2$.", "outputFormat": "Output a single integer $A$, indicating that there are $A$ communities whose residents will drink polluted water.", "hint": "- For $10\\%$ of the testdata, $1 \\le x_1, y_1, x_2, y_2 \\le 100$, $1 \\le N \\le 100$.\n- For $30\\%$ of the testdata, $1 \\le x_1, y_1, x_2, y_2 \\le 10^4$, $1 \\le N \\le 100$.\n- For $100\\%$ of the testdata, $1 \\le x_1, y_1, x_2, y_2 \\le 10^5$, $1 \\le N \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 被污染的河流", "background": "有一座城市，城市里有许多条人工河，河流的流向都是水平或者竖直的。为了方便市民用水，政府将河流设计成网格状。在水平方向上和竖直方向上，相邻河流的距离都是 $1$ 公里。河流围出许多格子，每个格子就是一个社区，社区里的居民可以到社区周边四条河段中的任意一处打水喝。\n", "description": "郁闷的是，不久之后，有些不法商人修建了工厂，污染了河流。河边许多居民喝了被污染的水，生病了。政府派出专员小强调查污染情况。地理专家小强行动迅速，很快给出了污染分布。他给出了一张污染清单。清单列出了被污染的河段，所有能喝到该河段水的居民都有可能生病（河段的端点处忽略不计）。但是，笨笨的小强怎么也算不出具体会有多少个社区的居民会生病，所以，他请你来帮帮忙。\n\n![](https://cdn.luogu.com.cn/upload/pic/6840.png)\n", "inputFormat": "输入文件的第一行是一个整数 $N$，表示被污染的河段的数目。\n\n接下来 $N$ 行，每行 $4$ 个整数 $x_1,y_1,x_2,y_2$，表示被污染河段的起始位置和结束位置。每行输入的两个位置保证不重合，并且满足 $x_1=x_2$ 或 $y_1=y_2$。\n", "outputFormat": "输出一个整数 $A$，表示有 $A$ 个社区的居民会喝到被污染的水。\n", "hint": "- 对于 $10\\%$ 的数据，$1 \\le  x_1,y_1,x_2,y_2 \\le 100$，$1\\le N \\le 100$；\n- 对于 $30\\%$ 的数据，$1 \\le x_1,y_1,x_2,y_2 \\le 10^4$，$1\\le N \\le 100$；\n- 对于 $100\\%$ 的数据，$1 \\le x_1,y_1,x_2,y_2 \\le 10^5$，$1\\le N \\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P3876", "type": "P", "difficulty": 6, "samples": [["2\n7 2\n3 1 2 4\n4 2 4 5 7\n3 1\n2 1 1\n", "Yes\nNo\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "天津"], "title": "[TJOI2010] 数字序列", "background": "", "description": "考虑一个由数字0,1,2,3组成的长度为n的序列，如果它是一个合法序列，那么它应当满足以下两个条件：\n\n1) 序列中任意相邻的两元素没有出现模式{'00', '11', '22', '33', '02', '20', '23', '32', '13', '31'}中的任一种;\n\n2) 序列满足m个约束条件，每个约束条件的形式均为：{p1, p2, ... pL}，它表示序列中的p1, p2, ..., pL这些位置的值不同。例如约束条件{1, 5, 11}表示序列中的第一个，第五个和第十一个元素两两各不相同。\n\n现在已知序列长度n，约束条件个数m以及这m个约束条件，问是否存在这样的合法序列。\n", "inputFormat": "输入文件的第一行是一个正整数T，表示文件中包含T组测试数据。从文件的第二行开始，将依次给出所有的测试数据。每个测试数据的第一行是两个整数n和m，它们的涵义如上面题目描述中所示。接下来有m行，每行描述一个约束条件，其中在描述第i个约束条件的行中，第一个数字是表示这个约束条件包含多少个元素的正整数Li，后面由Li个正整数给出第i个约束的具体情况。\n", "outputFormat": "共输出T行，对每组测试数据输出一行，如果存在满足条件的合法序列，输出\"Yes\"；否则，输出\"No\"。\n", "hint": "T ≤ 10，1 ≤ n ≤ 100000，0 ≤ m ≤ 5000，1 ≤ Li ≤ 100，1 ≤ pi ≤ n\n\n每个测试点时限1秒\n\n第一组样例中，序列0103012是满足要求的一个合法序列。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Number Sequence", "background": "", "description": "Consider a sequence of length $n$ over digits 0, 1, 2, 3. If it is a valid sequence, it must satisfy both of the following:\n\n1) No adjacent pair appears as any pattern in {'00', '11', '22', '33', '02', '20', '23', '32', '13', '31'}.\n\n2) The sequence satisfies $m$ constraints. Each constraint is of the form {p1, p2, ... pL}, meaning the values at positions $p_1, p_2, \\ldots, p_L$ are pairwise distinct. For example, the constraint {1, 5, 11} means the 1st, 5th, and 11th elements are all different.\n\nGiven $n$, $m$, and these $m$ constraints, determine whether such a valid sequence exists.", "inputFormat": "The first line contains a positive integer $T$, the number of test cases. For each test case, the first line contains two integers $n$ and $m$ as described above. Then there are $m$ lines, each describing one constraint: in the $i$-th line, the first integer $L_i$ is the size of the constraint, followed by $L_i$ positive integers giving the positions in the $i$-th constraint.", "outputFormat": "Output $T$ lines. For each test case, print Yes if a valid sequence exists; otherwise, print No.", "hint": "Constraints:\n\n$T \\le 10$, $1 \\le n \\le 100000$, $0 \\le m \\le 5000$, $1 \\le L_i \\le 100$, $1 \\le p_i \\le n$.\n\nTime limit per test point: 1 second.\n\nIn the first sample, the sequence 0103012 is a valid sequence.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 数字序列", "background": "", "description": "考虑一个由数字0,1,2,3组成的长度为n的序列，如果它是一个合法序列，那么它应当满足以下两个条件：\n\n1) 序列中任意相邻的两元素没有出现模式{'00', '11', '22', '33', '02', '20', '23', '32', '13', '31'}中的任一种;\n\n2) 序列满足m个约束条件，每个约束条件的形式均为：{p1, p2, ... pL}，它表示序列中的p1, p2, ..., pL这些位置的值不同。例如约束条件{1, 5, 11}表示序列中的第一个，第五个和第十一个元素两两各不相同。\n\n现在已知序列长度n，约束条件个数m以及这m个约束条件，问是否存在这样的合法序列。\n", "inputFormat": "输入文件的第一行是一个正整数T，表示文件中包含T组测试数据。从文件的第二行开始，将依次给出所有的测试数据。每个测试数据的第一行是两个整数n和m，它们的涵义如上面题目描述中所示。接下来有m行，每行描述一个约束条件，其中在描述第i个约束条件的行中，第一个数字是表示这个约束条件包含多少个元素的正整数Li，后面由Li个正整数给出第i个约束的具体情况。\n", "outputFormat": "共输出T行，对每组测试数据输出一行，如果存在满足条件的合法序列，输出\"Yes\"；否则，输出\"No\"。\n", "hint": "T ≤ 10，1 ≤ n ≤ 100000，0 ≤ m ≤ 5000，1 ≤ Li ≤ 100，1 ≤ pi ≤ n\n\n每个测试点时限1秒\n\n第一组样例中，序列0103012是满足要求的一个合法序列。\n", "locale": "zh-CN"}}}
{"pid": "P3877", "type": "P", "difficulty": 6, "samples": [["4\n3 4\n##..\n....\n....\n3 4\n##..\n....\n#...\n3 4\n##..\n#...\n#...\n3 4\n####\n#..#\n####\n", "YES\nNO\nYES\nNO\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "网络流", "天津"], "title": "[TJOI2010] 打扫房间", "background": "", "description": "学校新建了一批宿舍，值日生小A要把所有的空房间都打扫一遍。这些宿舍的布局很奇怪，整个建筑物里所有的房间组成一个N \\* M的矩阵，每个房间的东南西北四面墙上都有一个门通向隔壁房间。另外有些房间是堆放杂物的，无需打扫。小A想设计若干条打扫路线，使得恰好进出每个需打扫的房间各一次，而且进出每个房间不能通过同一个门。要求每条路线都是一个闭合的环线，并且每条路线经过的房间数大于2。\n\n如下面两图所示均为满足要求的打扫方案（灰色格子为放杂物的房间）：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6841.png) \n\n小A发现对于某些房间布局是不存在这样的满足要求的方案的。他请你写一个程序计算一下，对于一种给定的房间布局，满足要求的方案是否存在。\n", "inputFormat": "输入文件的第一行是一个整数T (1 ≤ T ≤ 10)，表示该文件中一共有T组数据。接下来依次是T组数据的信息。每组数据的第一行包含两个整数N和M，接下来的N行，每行包含M个字符，表示一个房间布局。字符'.'表示该房间需要打扫，'#'表示该房间是堆放杂物的，无需打扫。\n", "outputFormat": "共输出T行，对每组数据输出一行，为\"YES\"或\"NO\"，表示打扫方案存在与否。\n", "hint": "对50%的数据，3 ≤ N,M ≤ 12\n\n对100%的数据，3 ≤ N,M ≤ 30\n\n每个测试点时限1秒\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2010] Cleaning the Room", "background": "", "description": "A new batch of dormitories has been built at the school, and the student on duty, Xiao A, needs to clean all empty rooms. The layout of these dormitories is unusual: all rooms in the building form an $N \\times M$ grid. Each room has a door on each of its north, south, east, and west walls leading to the adjacent room. Some rooms are used for storage and do not need to be cleaned. Xiao A wants to design several cleaning routes such that each room that needs cleaning is entered and exited exactly once, and the same door must not be used to both enter and leave that room. Each route must be a closed cycle, and each route must pass through more than 2 rooms.\n\nAs shown in the two figures below, both are valid cleaning plans (gray cells are rooms used for storage):\n\n![](https://cdn.luogu.com.cn/upload/pic/6841.png)\n\nXiao A finds that for certain layouts, no plan satisfying the requirements exists. He asks you to write a program to determine, for a given room layout, whether a valid plan exists.", "inputFormat": "The first line contains an integer $T$ ($1 \\le T \\le 10$), indicating that there are $T$ groups of testdata in the file. Then follow the descriptions of the $T$ groups of testdata. For each group, the first line contains two integers $N$ and $M$. The next $N$ lines each contain $M$ characters describing a room layout. A '.' means the room needs cleaning; a '#' means the room is used for storage and does not need cleaning.", "outputFormat": "Output $T$ lines. For each group, output one line, either \"YES\" or \"NO\", indicating whether such a cleaning plan exists.", "hint": "- For 50% of the testdata, $3 \\le N, M \\le 12$.\n- For 100% of the testdata, $3 \\le N, M \\le 30$.\n- Time limit per test point: 1 second.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2010] 打扫房间", "background": "", "description": "学校新建了一批宿舍，值日生小A要把所有的空房间都打扫一遍。这些宿舍的布局很奇怪，整个建筑物里所有的房间组成一个N \\* M的矩阵，每个房间的东南西北四面墙上都有一个门通向隔壁房间。另外有些房间是堆放杂物的，无需打扫。小A想设计若干条打扫路线，使得恰好进出每个需打扫的房间各一次，而且进出每个房间不能通过同一个门。要求每条路线都是一个闭合的环线，并且每条路线经过的房间数大于2。\n\n如下面两图所示均为满足要求的打扫方案（灰色格子为放杂物的房间）：\n\n ![](https://cdn.luogu.com.cn/upload/pic/6841.png) \n\n小A发现对于某些房间布局是不存在这样的满足要求的方案的。他请你写一个程序计算一下，对于一种给定的房间布局，满足要求的方案是否存在。\n", "inputFormat": "输入文件的第一行是一个整数T (1 ≤ T ≤ 10)，表示该文件中一共有T组数据。接下来依次是T组数据的信息。每组数据的第一行包含两个整数N和M，接下来的N行，每行包含M个字符，表示一个房间布局。字符'.'表示该房间需要打扫，'#'表示该房间是堆放杂物的，无需打扫。\n", "outputFormat": "共输出T行，对每组数据输出一行，为\"YES\"或\"NO\"，表示打扫方案存在与否。\n", "hint": "对50%的数据，3 ≤ N,M ≤ 12\n\n对100%的数据，3 ≤ N,M ≤ 30\n\n每个测试点时限1秒\n", "locale": "zh-CN"}}}
