{"pid": "P11224", "type": "P", "difficulty": 7, "samples": [["4 5\nCCBCB\nCCBBB\nCCCBB\nCCCBB", "1 1 0 2 0\n1 1 0 0 0\n3 3 3 0 0\n3 3 3 0 0"], ["7 5\nCCCBB\nBCBBB\nBCCCB\nBCCCB\nCCCCC\nBBBBB\nBCCCB", "1 1 1 0 0\n0 2 0 0 0\n0 3 3 3 0\n0 3 3 3 0\n4 4 4 4 4\n0 0 0 0 0\n0 5 5 5 0"], ["5 11\nBBCCCBCCCBC\nBCCBCBBCCCC\nCCCCBCCCCCC\nBCBCCCBCCCB\nCCCCBCBBCCB", "0 0 1 1 1 0 2 2 2 0 3\n0 4 4 0 5 0 0 6 6 6 3\n7 7 7 7 0 8 8 6 6 6 3\n0 9 0 10 10 10 0 6 6 6 0\n11 11 11 11 0 12 0 0 13 13 0"]], "limits": {"time": [15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000, 15000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "网络流", "Special Judge", "二分图", "COTS（克罗地亚）"], "title": "[COTS 2019] 挑战 Izazov", "background": "\n译自 [Izborne Pripreme 2019 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2019/) D2T1。$\\texttt{15s,0.5G}$。", "description": "\n给定 $N\\times M$ 的黑白矩阵。用尽可能少数量的矩形覆盖住所有黑色格子，要求：\n- 每个黑色格子**恰好被一个**矩形覆盖；\n- 任意两个矩形不重叠；\n- 矩形不覆盖白色格子。\n\n并输出方案。", "inputFormat": "第一行，两个正整数 $N,M$。\n\n接下来一个 $N\\times M$ 的矩阵，每个位置是 $\\texttt{C}$ 或者 $\\texttt{B}$。其中，$\\texttt{C}$ 代表黑色（克罗地亚语「crno」），$\\texttt{B}$ 代表白色（克罗地亚语「bijelo」）。\n", "outputFormat": "\n输出 $N$ 行，每行 $M$ 个数，表示你的方案：\n- 未被覆盖的区域，用 $0$ 表示；\n- 否则，设使用了 $K$ 个矩形，将矩形用 $1\\sim K$ 标号后，对应位置用覆盖它的矩形编号表示。\n\n每一行相邻的数要用空格隔开。", "hint": "\n\n对于 $100\\%$ 的数据，保证 $1\\le N,M\\le 500$。\n\n\n| 测试点编号 | $N,M\\le $    | 得分 |  \n| :--: | :--: |:--: |  \n| $ 1\\sim 5 $    | $ 26 $ |   $ 25 $   |  \n| $ 6\\sim 10 $    | $ 100 $ |  $ 25 $   |  \n| $ 11\\sim 15 $    | $ 250 $ | $ 25 $   |  \n| $ 16\\sim 20 $    | $ 500 $ |$ 25 $   |  \n\n【计分方式】\n\n如果你输出的是最优解，得满分。\n\n否则，设最优解用的矩形数量为 $A$，你的解用的矩形数量为 $B$，该测试点得分为 $0.75\\cdot (A/B)^{10}\\cdot 5$ 分。 ", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COTS 2019] 挑战 Izazov", "background": "\n译自 [Izborne Pripreme 2019 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2019/) D2T1。$\\texttt{15s,0.5G}$。", "description": "\n给定 $N\\times M$ 的黑白矩阵。用尽可能少数量的矩形覆盖住所有黑色格子，要求：\n- 每个黑色格子**恰好被一个**矩形覆盖；\n- 任意两个矩形不重叠；\n- 矩形不覆盖白色格子。\n\n并输出方案。", "inputFormat": "第一行，两个正整数 $N,M$。\n\n接下来一个 $N\\times M$ 的矩阵，每个位置是 $\\texttt{C}$ 或者 $\\texttt{B}$。其中，$\\texttt{C}$ 代表黑色（克罗地亚语「crno」），$\\texttt{B}$ 代表白色（克罗地亚语「bijelo」）。\n", "outputFormat": "\n输出 $N$ 行，每行 $M$ 个数，表示你的方案：\n- 未被覆盖的区域，用 $0$ 表示；\n- 否则，设使用了 $K$ 个矩形，将矩形用 $1\\sim K$ 标号后，对应位置用覆盖它的矩形编号表示。\n\n每一行相邻的数要用空格隔开。", "hint": "\n\n对于 $100\\%$ 的数据，保证 $1\\le N,M\\le 500$。\n\n\n| 测试点编号 | $N,M\\le $    | 得分 |  \n| :--: | :--: |:--: |  \n| $ 1\\sim 5 $    | $ 26 $ |   $ 25 $   |  \n| $ 6\\sim 10 $    | $ 100 $ |  $ 25 $   |  \n| $ 11\\sim 15 $    | $ 250 $ | $ 25 $   |  \n| $ 16\\sim 20 $    | $ 500 $ |$ 25 $   |  \n\n【计分方式】\n\n如果你输出的是最优解，得满分。\n\n否则，设最优解用的矩形数量为 $A$，你的解用的矩形数量为 $B$，该测试点得分为 $0.75\\cdot (A/B)^{10}\\cdot 5$ 分。 ", "locale": "zh-CN"}}}
{"pid": "P11225", "type": "P", "difficulty": 6, "samples": [["5 5 2\n1 2 1\n1 3 3\n2 3 4\n3 4 1\n4 5 1\n1 10\n4 2", "3"], ["7 8 3\n1 2 5\n2 3 3\n3 4 5\n1 4 1\n4 5 7\n5 6 2\n6 7 1\n4 7 4\n3 3\n7 3\n6 2", "5"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "网络流", "二分图", "COTS（克罗地亚）"], "title": "[COTS 2019] 疏散 Sklonište", "background": "\n译自 [Izborne Pripreme 2019 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2019/) D2T2。$\\texttt{4s,0.5G}$。", "description": "\n给定 $N$ 个点 $M$ 条边的无向连通图，边有边权。有 $K$ 个关键点 $A_1,A_2,\\cdots,A_K$，**容量**为 $S_1,S_2,\\cdots,S_K$。\n\n图中的居民要疏散。也就是说，你需要构造一个序列 $B_1,B_2,\\cdots,B_N$，使得：\n\n- $\\forall 1\\le i\\le N$，$1\\le B_i\\le K$；\n- 对于 $1\\le i\\le K$，定义 $\\displaystyle \\mathrm{cnt}_i=\\sum_{1\\le j\\le N} [B_j=i]$，也就是 $i$ 在 $B$ 序列中出现的次数。则 $\\mathrm{cnt}_i\\le S_i$。\n\n定义序列 $B$ 的**疏散时间**为 $\\displaystyle \\max_{1\\le i\\le N} \\operatorname{dist}(i,A_{B_i})$，其中 $\\operatorname{dist}(u,v)$ 指图中 $u,v$ 间最短路的长度。\n\n求出疏散时间的最小值。保证 $\\sum_i S_i\\ge N$。\n", "inputFormat": "\n第一行，三个正整数 $N,M,K$；\n\n接下来 $M$ 行，每行三个正整数 $u,v,w$，描述一条无向边 $(u,v)$，边权为 $w$。保证 $u\\neq v$。\n\n接下来 $K$ 行，每行两个正整数描述 $A_i,S_i$。\n\n保证 $\\sum_i S_i\\ge N$。", "outputFormat": "\n输出一行一个数，表示答案。", "hint": "\n对于 $100\\%$ 的数据，保证：\n- $1\\le N\\le 10^5$；\n- $N-1\\le M\\le 3\\times 10^5$；\n- $1\\le K\\le 17$；\n- 给定图连通，无自环；\n- $1\\le w,S_i\\le 10^9$；\n- $1\\le u,v,A_i\\le N$；\n- $S_i$ 两两不同；\n- $\\sum_i S_i\\ge N$。\n\n\n| 子任务编号 | $N\\le $ | $M\\le $ | $K\\le$    | 得分 |  \n| :--: | :--: |:--: |  :--: | :--: | \n| $ 1 $    | $ 100 $ |   $ 500 $   |  $5$ | $30$ |\n| $ 2 $    | $ 10^5 $ |  $ 3\\times 10^5 $   |  $10 $ | $30$ |\n| $ 3 $    | $ 10^5 $ | $ 3\\times 10^5 $   |  $17$ |  $40$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COTS 2019] 疏散 Sklonište", "background": "\n译自 [Izborne Pripreme 2019 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2019/) D2T2。$\\texttt{4s,0.5G}$。", "description": "\n给定 $N$ 个点 $M$ 条边的无向连通图，边有边权。有 $K$ 个关键点 $A_1,A_2,\\cdots,A_K$，**容量**为 $S_1,S_2,\\cdots,S_K$。\n\n图中的居民要疏散。也就是说，你需要构造一个序列 $B_1,B_2,\\cdots,B_N$，使得：\n\n- $\\forall 1\\le i\\le N$，$1\\le B_i\\le K$；\n- 对于 $1\\le i\\le K$，定义 $\\displaystyle \\mathrm{cnt}_i=\\sum_{1\\le j\\le N} [B_j=i]$，也就是 $i$ 在 $B$ 序列中出现的次数。则 $\\mathrm{cnt}_i\\le S_i$。\n\n定义序列 $B$ 的**疏散时间**为 $\\displaystyle \\max_{1\\le i\\le N} \\operatorname{dist}(i,A_{B_i})$，其中 $\\operatorname{dist}(u,v)$ 指图中 $u,v$ 间最短路的长度。\n\n求出疏散时间的最小值。保证 $\\sum_i S_i\\ge N$。\n", "inputFormat": "\n第一行，三个正整数 $N,M,K$；\n\n接下来 $M$ 行，每行三个正整数 $u,v,w$，描述一条无向边 $(u,v)$，边权为 $w$。保证 $u\\neq v$。\n\n接下来 $K$ 行，每行两个正整数描述 $A_i,S_i$。\n\n保证 $\\sum_i S_i\\ge N$。", "outputFormat": "\n输出一行一个数，表示答案。", "hint": "\n对于 $100\\%$ 的数据，保证：\n- $1\\le N\\le 10^5$；\n- $N-1\\le M\\le 3\\times 10^5$；\n- $1\\le K\\le 17$；\n- 给定图连通，无自环；\n- $1\\le w,S_i\\le 10^9$；\n- $1\\le u,v,A_i\\le N$；\n- $S_i$ 两两不同；\n- $\\sum_i S_i\\ge N$。\n\n\n| 子任务编号 | $N\\le $ | $M\\le $ | $K\\le$    | 得分 |  \n| :--: | :--: |:--: |  :--: | :--: | \n| $ 1 $    | $ 100 $ |   $ 500 $   |  $5$ | $30$ |\n| $ 2 $    | $ 10^5 $ |  $ 3\\times 10^5 $   |  $10 $ | $30$ |\n| $ 3 $    | $ 10^5 $ | $ 3\\times 10^5 $   |  $17$ |  $40$ |", "locale": "zh-CN"}}}
{"pid": "P11226", "type": "P", "difficulty": 5, "samples": [["3\nwar\nzag\nwro", "agorwzbcdefhijklmnpqstuvxy\nagorzwbcdefhijklmnpqstuvxy\ngorawzbcdefhijklmnpqstuvxy"], ["3\nb\nab\naa", "bacdefghijklmnopqrstuvwxyz\nnemoguce\nabcdefghijklmnopqrstuvwxyz"], ["7\nbcada\ndbaab\nbbabc\nababb\naacdf\nbcdff\nbaddb", "cbadfeghijklmnopqrstuvwxyz\ncdabfeghijklmnopqrstuvwxyz\nbacdfeghijklmnopqrstuvwxyz\nnemoguce\nabcdfeghijklmnopqrstuvwxyz\ncbdafeghijklmnopqrstuvwxyz\nnemoguce"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "Special Judge", "拓扑排序", "字典树 Trie", "构造", "COTS（克罗地亚）"], "title": "[COTS 2019] 排名 Vezuv", "background": "\n译自 [Izborne Pripreme 2019 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2019/) D2T3。$\\texttt{1.5s,0.5G}$。", "description": "\n\n在某场 ICPC Regional 中，组委会决定用队伍名的字典序来决定排名。不幸的是，对于队名以字母 $\\texttt{z}$ 开头的队伍，这是相当不公平的。\n\n经过讨论，组委会决定：随机抽取一个 $26$ 个字母的排列，用字母的排列对应的字典序来决定排名。\n\n有 $N$ 支队伍参加了这场比赛，队伍名都为小写英文字母。\n\nEtna 写了一个程序枚举了 $26!$ 个排列，以期找到能使每个队伍夺冠的排列。但是这个程序至今都没有跑出结果。\n\n所以她找来了你，为每个队伍构造一个排列，使得这支队伍夺冠。\n", "inputFormat": "\n第一行，一个正整数 $N$；\n\n接下来 $N$ 行，第 $i$ 行一个字符串，表示第 $i$ 支队伍的队伍名。\n\n保证队伍名两两不同。", "outputFormat": "\n输出 $N$ 行：\n- 如果可能使得这支队伍获胜，输出一个 $26$ 个字母的排列；\n- 否则，输出 `nemoguce`（克罗地亚语「不可能」）。", "hint": "\n令 $L$ 为字符串总长度，$|\\Sigma|$ 为字符串字符集大小。\n\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le N\\le 25\\, 000$；\n- $1\\le L\\le 10^6$；\n- 队伍名两两不同；\n- $1\\le |\\Sigma|\\le 26$。\n\n\n| 子任务编号 | $N\\le $ | $L\\le $ | $\\vert\\Sigma\\vert\\le$    | 得分 |  \n| :--: | :--: |:--: |  :--: | :--: | \n| $ 1 $    | $ 100 $ |   $ 10^4 $   |  $6$ | $13$ |\n| $ 2 $    | $ 350 $ |  $ 10^4 $   |  $26 $ | $32$ |\n| $ 3 $    | $ 25\\, 000 $ | $ 10^6 $   |  $26$ |  $55$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[COTS 2019] 排名 Vezuv", "background": "\n译自 [Izborne Pripreme 2019 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2019/) D2T3。$\\texttt{1.5s,0.5G}$。", "description": "\n\n在某场 ICPC Regional 中，组委会决定用队伍名的字典序来决定排名。不幸的是，对于队名以字母 $\\texttt{z}$ 开头的队伍，这是相当不公平的。\n\n经过讨论，组委会决定：随机抽取一个 $26$ 个字母的排列，用字母的排列对应的字典序来决定排名。\n\n有 $N$ 支队伍参加了这场比赛，队伍名都为小写英文字母。\n\nEtna 写了一个程序枚举了 $26!$ 个排列，以期找到能使每个队伍夺冠的排列。但是这个程序至今都没有跑出结果。\n\n所以她找来了你，为每个队伍构造一个排列，使得这支队伍夺冠。\n", "inputFormat": "\n第一行，一个正整数 $N$；\n\n接下来 $N$ 行，第 $i$ 行一个字符串，表示第 $i$ 支队伍的队伍名。\n\n保证队伍名两两不同。", "outputFormat": "\n输出 $N$ 行：\n- 如果可能使得这支队伍获胜，输出一个 $26$ 个字母的排列；\n- 否则，输出 `nemoguce`（克罗地亚语「不可能」）。", "hint": "\n令 $L$ 为字符串总长度，$|\\Sigma|$ 为字符串字符集大小。\n\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le N\\le 25\\, 000$；\n- $1\\le L\\le 10^6$；\n- 队伍名两两不同；\n- $1\\le |\\Sigma|\\le 26$。\n\n\n| 子任务编号 | $N\\le $ | $L\\le $ | $\\vert\\Sigma\\vert\\le$    | 得分 |  \n| :--: | :--: |:--: |  :--: | :--: | \n| $ 1 $    | $ 100 $ |   $ 10^4 $   |  $6$ | $13$ |\n| $ 2 $    | $ 350 $ |  $ 10^4 $   |  $26 $ | $32$ |\n| $ 3 $    | $ 25\\, 000 $ | $ 10^6 $   |  $26$ |  $55$ |", "locale": "zh-CN"}}}
{"pid": "P11227", "type": "P", "difficulty": 1, "samples": [["1\nSA", "51"], ["4\nDQ\nH3\nDQ\nDT", "49"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2024", "O2优化", "CSP-J 入门级"], "title": "[CSP-J 2024] 扑克牌", "background": null, "description": "小 P 从同学小 Q 那儿借来一副 $n$ 张牌的扑克牌。\n\n本题中我们不考虑大小王，此时每张牌具有两个属性：花色和点数。花色共有 $4$ 种：方片、草花、红桃和黑桃。点数共有 $13$ 种，从小到大分别为 $\\tt{A 2 3 4 5 6 7 8 9 T J Q K}$。注意：点数 $10$ 在本题中记为 $\\tt T$。\n\n我们称一副扑克牌是**完整**的，当且仅当对于每一种花色和每一种点数，都**恰好**有一张牌具有对应的花色和点数。由此，一副完整的扑克牌恰好有 $4 \\times 13 = 52$ 张牌。以下图片展示了一副完整的扑克牌里所有的 52 张牌。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qj53w3yq.png)\n\n小 P 借来的牌可能不是完整的，为此小 P 准备再向同学小 S 借若干张牌。可以认为小 S 每种牌都有无限张，因此小 P 可以任意选择借来的牌。小 P 想知道他至少得向小 S 借多少张牌，才能让从小 S 和小 Q 借来的牌中，可以选出 $52$ 张牌构成一副完整的扑克牌。\n\n为了方便你的输入，我们使用字符 $\\tt D$ 代表方片，字符 $\\tt C$ 代表草花，字符 $\\tt H$ 代表红桃，字符 $\\tt S$ 代表黑桃，这样每张牌可以通过一个长度为 $2$ 的字符串表示，其中第一个字符表示这张牌的花色，第二个字符表示这张牌的点数，例如 $\\tt{CA}$ 表示草花 $\\tt A$，$\\tt{ST}$ 表示黑桃 $\\tt T$（黑桃 10）。", "inputFormat": "输入的第一行包含一个整数 $n$ 表示牌数。\n\n接下来 $n$ 行：\n\n每行包含一个长度为 $2$ 的字符串描述一张牌，其中第一个字符描述其花色，第二个字符描述其点数。", "outputFormat": "输出一行一个整数，表示最少还需要向小 S 借几张牌才能凑成一副完整的扑克牌。", "hint": "**【样例 1 解释】**\n\n这一副牌中包含一张黑桃 $\\tt A$，小 P 还需要借除了黑桃 $\\tt A$ 以外的 51 张牌以构成一副完整的扑克牌。\n\n**【样例 2 解释】**\n\n这一副牌中包含两张方片 $\\tt Q$、一张方片 $\\tt T$（方片 10）以及一张红桃 3，小 P 还需要借除了红桃 3、方片 $\\tt T$ 和方片 $\\tt Q$ 以外的 $49$ 张牌。\n\n**【样例 3 解释】**\n\n见选手目录下的 poker/poker3.in 与 poker/poker3.ans。\n\n这一副扑克牌是完整的，故不需要再借任何牌。\n\n该样例满足所有牌按照点数从小到大依次输入，点数相同时按照方片、草花、红桃、黑桃的顺序依次输入。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1 \\leq n \\leq 52$，输入的 $n$ 个字符串每个都代表一张合法的扑克牌，即字符串长度为 $2$，且第一个字符为 $\\tt{D C H S}$ 中的某个字符，第二个字符为 $\\tt{A 2 3 4 5 6 7 8 9 T J Q K}$ 中的某个字符。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $1$ | A |\n| $2\\sim 4$ | $52$ | ^ |\n| $5\\sim 7$ | ^ | B |\n| $8\\sim 10$ | ^ | 无 |\n\n特殊性质 A：保证输入的 $n$ 张牌两两不同。\n\n特殊性质 B：保证所有牌按照点数从小到大依次输入，点数相同时按照方片、草花、红桃、黑桃的顺序依次输入。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-J 2024] 扑克牌", "background": null, "description": "小 P 从同学小 Q 那儿借来一副 $n$ 张牌的扑克牌。\n\n本题中我们不考虑大小王，此时每张牌具有两个属性：花色和点数。花色共有 $4$ 种：方片、草花、红桃和黑桃。点数共有 $13$ 种，从小到大分别为 $\\tt{A 2 3 4 5 6 7 8 9 T J Q K}$。注意：点数 $10$ 在本题中记为 $\\tt T$。\n\n我们称一副扑克牌是**完整**的，当且仅当对于每一种花色和每一种点数，都**恰好**有一张牌具有对应的花色和点数。由此，一副完整的扑克牌恰好有 $4 \\times 13 = 52$ 张牌。以下图片展示了一副完整的扑克牌里所有的 52 张牌。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qj53w3yq.png)\n\n小 P 借来的牌可能不是完整的，为此小 P 准备再向同学小 S 借若干张牌。可以认为小 S 每种牌都有无限张，因此小 P 可以任意选择借来的牌。小 P 想知道他至少得向小 S 借多少张牌，才能让从小 S 和小 Q 借来的牌中，可以选出 $52$ 张牌构成一副完整的扑克牌。\n\n为了方便你的输入，我们使用字符 $\\tt D$ 代表方片，字符 $\\tt C$ 代表草花，字符 $\\tt H$ 代表红桃，字符 $\\tt S$ 代表黑桃，这样每张牌可以通过一个长度为 $2$ 的字符串表示，其中第一个字符表示这张牌的花色，第二个字符表示这张牌的点数，例如 $\\tt{CA}$ 表示草花 $\\tt A$，$\\tt{ST}$ 表示黑桃 $\\tt T$（黑桃 10）。", "inputFormat": "输入的第一行包含一个整数 $n$ 表示牌数。\n\n接下来 $n$ 行：\n\n每行包含一个长度为 $2$ 的字符串描述一张牌，其中第一个字符描述其花色，第二个字符描述其点数。", "outputFormat": "输出一行一个整数，表示最少还需要向小 S 借几张牌才能凑成一副完整的扑克牌。", "hint": "**【样例 1 解释】**\n\n这一副牌中包含一张黑桃 $\\tt A$，小 P 还需要借除了黑桃 $\\tt A$ 以外的 51 张牌以构成一副完整的扑克牌。\n\n**【样例 2 解释】**\n\n这一副牌中包含两张方片 $\\tt Q$、一张方片 $\\tt T$（方片 10）以及一张红桃 3，小 P 还需要借除了红桃 3、方片 $\\tt T$ 和方片 $\\tt Q$ 以外的 $49$ 张牌。\n\n**【样例 3 解释】**\n\n见选手目录下的 poker/poker3.in 与 poker/poker3.ans。\n\n这一副扑克牌是完整的，故不需要再借任何牌。\n\n该样例满足所有牌按照点数从小到大依次输入，点数相同时按照方片、草花、红桃、黑桃的顺序依次输入。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1 \\leq n \\leq 52$，输入的 $n$ 个字符串每个都代表一张合法的扑克牌，即字符串长度为 $2$，且第一个字符为 $\\tt{D C H S}$ 中的某个字符，第二个字符为 $\\tt{A 2 3 4 5 6 7 8 9 T J Q K}$ 中的某个字符。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n \\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $1$ | A |\n| $2\\sim 4$ | $52$ | ^ |\n| $5\\sim 7$ | ^ | B |\n| $8\\sim 10$ | ^ | 无 |\n\n特殊性质 A：保证输入的 $n$ 张牌两两不同。\n\n特殊性质 B：保证所有牌按照点数从小到大依次输入，点数相同时按照方片、草花、红桃、黑桃的顺序依次输入。", "locale": "zh-CN"}}}
{"pid": "P11228", "type": "P", "difficulty": 2, "samples": [["2\n1 5 4\n1 1 2\n....x\n5 5 20\n1 1 0\n.....\n.xxx.\n.x.x.\n..xx.\nx....", "3\n13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "2024", "O2优化", "CSP-J 入门级"], "title": "[CSP-J 2024] 地图探险", "background": null, "description": "小 A 打算前往一片丛林去探险。丛林的地理环境十分复杂，为了防止迷路，他先派遣了一个机器人前去探路。\n\n丛林的地图可以用一个 $n$ 行 $m$ 列的字符表来表示。我们将第 $i$ 行第 $j$ 列的位置的坐标记作 $(i, j)(1 \\leq i \\leq n$，$1 \\leq j \\leq m)$。如果这个位置的字符为 $\\tt x$，即代表这个位置上有障碍，不可通过。反之，若这个位置的字符为 $\\tt.$，即代表这个位置是一片空地，可以通过。\n\n这个机器人的状态由位置和朝向两部分组成。其中位置由坐标 $(x, y)(1 \\leq x \\leq n$，$1 \\leq y \\leq m)$ 刻画，它表示机器人处在地图上第 $x$ 行第 $y$ 列的位置。而朝向用一个 $0 \\sim 3$ 的整数 $d$ 表示，其中 $d = 0$ 代表向东，$d = 1$ 代表向南，$d = 2$ 代表向西，$d = 3$ 代表向北。\n\n初始时，机器人的位置为 $(x_0, y_0)$，朝向为 $d_0$。**保证初始时机器人所在的位置为空地**。接下来机器人将要进行 $k$ 次操作。每一步，机器人将按照如下的模式操作：\n\n1. 假设机器人当前处在的位置为 $(x, y)$，朝向为 $d$。则它的方向上的下一步的位置 $(x^′, y^′)$ 定义如下：若 $d = 0$，则令 $(x^′, y^′) = (x, y + 1)$，若 $d = 1$，则令 $(x^′, y^′) = (x + 1, y)$，若 $d = 2$，则令 $(x^′, y^′) = (x, y - 1)$，若 $d = 3$，则令 $(x^′, y^′) = (x - 1, y)$。\n\n2. 接下来，机器人判断它下一步的位置是否在地图内，且是否为空地。具体地说，它判断 $(x^′, y^′)$ 是否满足 $1 \\leq x^′ \\leq n, 1 \\leq y^′ \\leq m$，且 $(x^′, y^′)$ 位置上是空地。如果条件成立，则机器人会向前走一步。它新的位置变为 $(x^′, y^′)$，且朝向不变。如果条件不成立，则它会执行“向右转”操作。也就是说，令 $d^′ = (d + 1) \\bmod 4$（即 $d + 1$ 除以 $4$ 的余数），且它所处的位置保持不变，但朝向由 $d$ 变为 $d^′$。\n\n小 A 想要知道，在机器人执行完 $k$ 步操作之后，地图上所有被机器人经过的位置（包括起始位置）有几个。", "inputFormat": "**本题有多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示数据组数。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n\n第一行包含三个正整数 $n, m, k$。其中 $n, m$ 表示地图的行数和列数，$k$ 表示机器人执行操作的次数。\n\n第二行包含两个正整数 $x_0, y_0$ 和一个非负整数 $d_0$。\n\n接下来 $n$ 行，每行包含一个长度为 $m$ 的字符串。保证字符串中只包含 $\\tt{x}$ 和 $\\tt{.}$ 两个字符。其中，第 $x$ 行的字符串的第 $y$ 个字符代表的位置为 $(x, y)$。这个位置是 $\\tt{x}$ 即代表它是障碍，否则代表它是空地。数据保证机器人初始时所在的位置为空地。", "outputFormat": "对于每组数据：输出一行包含一个正整数，表示地图上所有被机器人经过的位置（包括起始位置）的个数。", "hint": "**【样例 1 解释】**\n\n该样例包含两组数据。对第一组数据，机器人的状态以如下方式变化：\n1. 初始时，机器人位于位置 $(1, 1)$，方向朝西（用数字 $2$ 代表）。\n2. 第一步，机器人发现它下一步的位置 $(1, 0)$ 不在地图内，因此，它会执行“向右转”操作。此时，它的位置仍然为 $(1, 1)$，但方向朝北（用数字 $3$ 代表）。\n3. 第二步，机器人发现它下一步的位置 $(0, 1)$ 不在地图内，因此，它仍然会执行“向右转”操作。此时，它的位置仍然为 $(1, 1)$，但方向朝东（用数字 $0$ 代表）。\n4. 第三步，机器人发现它下一步的位置 $(1, 2)$ 在地图内，且为空地。因此，它会向东走一步。此时，它的位置变为 $(1, 2)$，方向仍然朝东。\n5. 第四步，机器人发现它下一步的位置 $(1, 3)$ 在地图内，且为空地。因此，它会向东走一步。此时，它的位置变为 $(1, 3)$，方向仍然朝东。\n\n因此，四步之后，机器人经过的位置有三个，分别为 $(1, 1),(1, 2),(1, 3)$。\n\n对第二组数据，机器人依次执行的操作指令为：向东走到 $(1, 2)$，向东走到 $(1, 3)$，向东走到 $(1, 4)$，向东走到 $(1, 5)$，向右转，向南走到 $(2, 5)$，向南走到 $(3, 5)$，向南走到 $(4, 5)$，向南走到 $(5, 5)$，向右转，向西走到 $(5, 4)$，向西走到 $(5, 3)$，向西走到 $(5, 2)$，向右转，向北走到 $(4, 2)$，向右转，向右转，向南走到 $(5, 2)$，向右转，向右转。\n\n**【样例 2】**\n\n见选手目录下的 explore/explore2.in 与 explore/explore2.ans。\n\n该样例满足第 $3\\sim 4$ 个测试点的限制条件。\n\n**【样例 3】**\n\n见选手目录下的 explore/explore3.in 与 explore/explore3.ans。\n\n该样例满足第 $5$ 个测试点的限制条件。\n\n**【样例 4】**\n\n见选手目录下的 explore/explore4.in 与 explore/explore4.ans。\n\n该样例满足第 $6$ 个测试点的限制条件。\n\n**【样例 5】**\n\n见选手目录下的 explore/explore5.in 与 explore/explore5.ans。\n\n该样例满足第 $8 \\sim 10$ 个测试点的限制条件。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1 \\leq T \\leq 5$，$1 \\leq n, m \\leq 10^3$，$1 \\leq k \\leq 10^6$，$1 \\leq x_0 \\leq n$，$1 \\leq y_0 \\leq m$，$0 \\leq d_0 \\leq 3$，且机器人的起始位置为空地。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n$ | $m$ | $k$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $=1$ | $\\leq 2$ | $=1$ | 无 |\n| $2$ | ^ | ^ | ^ | ^ |\n| $3$ | $\\leq 10^2$ | $\\leq 10^2$ | ^ | ^ |\n| $4$ | ^ | ^ | ^ | ^ |\n| $5$ | $=1$ | $\\leq 10^3$ | $\\leq 2\\times 10^3$ | 地图上所有位置均为空地 |\n| $6$ | ^ | ^ | ^ | 无|\n| $7$ | $\\leq 10^3$ | ^ | $\\leq 10^6$ |  地图上所有位置均为空地 |\n| $8$ | ^ | ^ | ^ | 无 |\n| $9$ | ^ | ^ | ^ | ^ |\n| $10$ | ^ | ^ | ^ | ^ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-J 2024] 地图探险", "background": null, "description": "小 A 打算前往一片丛林去探险。丛林的地理环境十分复杂，为了防止迷路，他先派遣了一个机器人前去探路。\n\n丛林的地图可以用一个 $n$ 行 $m$ 列的字符表来表示。我们将第 $i$ 行第 $j$ 列的位置的坐标记作 $(i, j)(1 \\leq i \\leq n$，$1 \\leq j \\leq m)$。如果这个位置的字符为 $\\tt x$，即代表这个位置上有障碍，不可通过。反之，若这个位置的字符为 $\\tt.$，即代表这个位置是一片空地，可以通过。\n\n这个机器人的状态由位置和朝向两部分组成。其中位置由坐标 $(x, y)(1 \\leq x \\leq n$，$1 \\leq y \\leq m)$ 刻画，它表示机器人处在地图上第 $x$ 行第 $y$ 列的位置。而朝向用一个 $0 \\sim 3$ 的整数 $d$ 表示，其中 $d = 0$ 代表向东，$d = 1$ 代表向南，$d = 2$ 代表向西，$d = 3$ 代表向北。\n\n初始时，机器人的位置为 $(x_0, y_0)$，朝向为 $d_0$。**保证初始时机器人所在的位置为空地**。接下来机器人将要进行 $k$ 次操作。每一步，机器人将按照如下的模式操作：\n\n1. 假设机器人当前处在的位置为 $(x, y)$，朝向为 $d$。则它的方向上的下一步的位置 $(x^′, y^′)$ 定义如下：若 $d = 0$，则令 $(x^′, y^′) = (x, y + 1)$，若 $d = 1$，则令 $(x^′, y^′) = (x + 1, y)$，若 $d = 2$，则令 $(x^′, y^′) = (x, y - 1)$，若 $d = 3$，则令 $(x^′, y^′) = (x - 1, y)$。\n\n2. 接下来，机器人判断它下一步的位置是否在地图内，且是否为空地。具体地说，它判断 $(x^′, y^′)$ 是否满足 $1 \\leq x^′ \\leq n, 1 \\leq y^′ \\leq m$，且 $(x^′, y^′)$ 位置上是空地。如果条件成立，则机器人会向前走一步。它新的位置变为 $(x^′, y^′)$，且朝向不变。如果条件不成立，则它会执行“向右转”操作。也就是说，令 $d^′ = (d + 1) \\bmod 4$（即 $d + 1$ 除以 $4$ 的余数），且它所处的位置保持不变，但朝向由 $d$ 变为 $d^′$。\n\n小 A 想要知道，在机器人执行完 $k$ 步操作之后，地图上所有被机器人经过的位置（包括起始位置）有几个。", "inputFormat": "**本题有多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示数据组数。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n\n第一行包含三个正整数 $n, m, k$。其中 $n, m$ 表示地图的行数和列数，$k$ 表示机器人执行操作的次数。\n\n第二行包含两个正整数 $x_0, y_0$ 和一个非负整数 $d_0$。\n\n接下来 $n$ 行，每行包含一个长度为 $m$ 的字符串。保证字符串中只包含 $\\tt{x}$ 和 $\\tt{.}$ 两个字符。其中，第 $x$ 行的字符串的第 $y$ 个字符代表的位置为 $(x, y)$。这个位置是 $\\tt{x}$ 即代表它是障碍，否则代表它是空地。数据保证机器人初始时所在的位置为空地。", "outputFormat": "对于每组数据：输出一行包含一个正整数，表示地图上所有被机器人经过的位置（包括起始位置）的个数。", "hint": "**【样例 1 解释】**\n\n该样例包含两组数据。对第一组数据，机器人的状态以如下方式变化：\n1. 初始时，机器人位于位置 $(1, 1)$，方向朝西（用数字 $2$ 代表）。\n2. 第一步，机器人发现它下一步的位置 $(1, 0)$ 不在地图内，因此，它会执行“向右转”操作。此时，它的位置仍然为 $(1, 1)$，但方向朝北（用数字 $3$ 代表）。\n3. 第二步，机器人发现它下一步的位置 $(0, 1)$ 不在地图内，因此，它仍然会执行“向右转”操作。此时，它的位置仍然为 $(1, 1)$，但方向朝东（用数字 $0$ 代表）。\n4. 第三步，机器人发现它下一步的位置 $(1, 2)$ 在地图内，且为空地。因此，它会向东走一步。此时，它的位置变为 $(1, 2)$，方向仍然朝东。\n5. 第四步，机器人发现它下一步的位置 $(1, 3)$ 在地图内，且为空地。因此，它会向东走一步。此时，它的位置变为 $(1, 3)$，方向仍然朝东。\n\n因此，四步之后，机器人经过的位置有三个，分别为 $(1, 1),(1, 2),(1, 3)$。\n\n对第二组数据，机器人依次执行的操作指令为：向东走到 $(1, 2)$，向东走到 $(1, 3)$，向东走到 $(1, 4)$，向东走到 $(1, 5)$，向右转，向南走到 $(2, 5)$，向南走到 $(3, 5)$，向南走到 $(4, 5)$，向南走到 $(5, 5)$，向右转，向西走到 $(5, 4)$，向西走到 $(5, 3)$，向西走到 $(5, 2)$，向右转，向北走到 $(4, 2)$，向右转，向右转，向南走到 $(5, 2)$，向右转，向右转。\n\n**【样例 2】**\n\n见选手目录下的 explore/explore2.in 与 explore/explore2.ans。\n\n该样例满足第 $3\\sim 4$ 个测试点的限制条件。\n\n**【样例 3】**\n\n见选手目录下的 explore/explore3.in 与 explore/explore3.ans。\n\n该样例满足第 $5$ 个测试点的限制条件。\n\n**【样例 4】**\n\n见选手目录下的 explore/explore4.in 与 explore/explore4.ans。\n\n该样例满足第 $6$ 个测试点的限制条件。\n\n**【样例 5】**\n\n见选手目录下的 explore/explore5.in 与 explore/explore5.ans。\n\n该样例满足第 $8 \\sim 10$ 个测试点的限制条件。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1 \\leq T \\leq 5$，$1 \\leq n, m \\leq 10^3$，$1 \\leq k \\leq 10^6$，$1 \\leq x_0 \\leq n$，$1 \\leq y_0 \\leq m$，$0 \\leq d_0 \\leq 3$，且机器人的起始位置为空地。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n$ | $m$ | $k$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $=1$ | $\\leq 2$ | $=1$ | 无 |\n| $2$ | ^ | ^ | ^ | ^ |\n| $3$ | $\\leq 10^2$ | $\\leq 10^2$ | ^ | ^ |\n| $4$ | ^ | ^ | ^ | ^ |\n| $5$ | $=1$ | $\\leq 10^3$ | $\\leq 2\\times 10^3$ | 地图上所有位置均为空地 |\n| $6$ | ^ | ^ | ^ | 无|\n| $7$ | $\\leq 10^3$ | ^ | $\\leq 10^6$ |  地图上所有位置均为空地 |\n| $8$ | ^ | ^ | ^ | 无 |\n| $9$ | ^ | ^ | ^ | ^ |\n| $10$ | ^ | ^ | ^ | ^ |", "locale": "zh-CN"}}}
{"pid": "P11229", "type": "P", "difficulty": 3, "samples": [["5\n1\n2\n3\n6\n18", "-1\n1\n7\n6\n208"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "数学", "贪心", "2024", "O2优化", "构造", "CSP-J 入门级", "分类讨论"], "title": "[CSP-J 2024] 小木棍", "background": null, "description": "小 S 喜欢收集小木棍。在收集了 $n$ 根长度相等的小木棍之后，他闲来无事，便用它们拼起了数字。用小木棍拼每种数字的方法如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8zubqass.png)\n\n现在小 S 希望拼出一个**正**整数，满足如下条件：\n\n- 拼出这个数**恰好**使用 $n$ 根小木棍；\n- 拼出的数没有前导 $0$；\n- 在满足以上两个条件的前提下，这个数尽可能小。\n\n小 S 想知道这个数是多少，可 $n$ 很大，把木棍整理清楚就把小 S 折腾坏了，所以你需要帮他解决这个问题。如果不存在正整数满足以上条件，你需要输出 $-1$ 进行报告。", "inputFormat": "本题有多组测试数据。\n\n输入的第一行包含一个正整数 $T$，表示数据组数。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n\n一行包含一个整数 $n$，表示木棍数。", "outputFormat": "对于每组数据：输出一行，如果存在满足题意的正整数，输出这个数；否则输出 $-1$。", "hint": "**【样例 1 解释】**\n\n- 对于第一组测试数据，不存在任何一个正整数可以使用恰好一根小木棍摆出，故输出 $-1$。\n- 对于第四组测试数据，注意 $0$ 并不是一个满足要求的方案。摆出 $9$、$41$ 以及 $111$ 都恰好需要 $6$ 根小木棍，但它们不是摆出的数最小的方案。\n- 对于第五组测试数据，摆出 $208$ 需要 $5 + 6 + 7 = 18$ 根小木棍。可以证明摆出任何一个小于 $208$ 的正整数需要的小木棍数都不是 $18$。注意尽管拼出 $006$ 也需要 $18$ 根小木棍，但因为这个数有前导零，因此并不是一个满足要求的方案。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1 \\leq T \\leq 50$，$1 \\leq n \\leq 10^5$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $20$ | 无 |\n| $2$ | $50$ | ^ |\n| $3$ | $10^3$ | A |\n| $4,5$ | $10^5$ | ^ |\n| $6$ | $10^3$ | B |\n| $7,8$ | $10^5$ | ^ |\n| $9$ | $10^3$ | 无 |\n| $10$ | $10^5$ | ^ |\n\n特殊性质 A：保证 $n$ 是 $7$ 的倍数且 $n \\geq 100$。\n\n特殊性质 B：保证存在整数 $k$ 使得 $n = 7k + 1$，且 $n \\geq 100$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-J 2024] 小木棍", "background": null, "description": "小 S 喜欢收集小木棍。在收集了 $n$ 根长度相等的小木棍之后，他闲来无事，便用它们拼起了数字。用小木棍拼每种数字的方法如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8zubqass.png)\n\n现在小 S 希望拼出一个**正**整数，满足如下条件：\n\n- 拼出这个数**恰好**使用 $n$ 根小木棍；\n- 拼出的数没有前导 $0$；\n- 在满足以上两个条件的前提下，这个数尽可能小。\n\n小 S 想知道这个数是多少，可 $n$ 很大，把木棍整理清楚就把小 S 折腾坏了，所以你需要帮他解决这个问题。如果不存在正整数满足以上条件，你需要输出 $-1$ 进行报告。", "inputFormat": "本题有多组测试数据。\n\n输入的第一行包含一个正整数 $T$，表示数据组数。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n\n一行包含一个整数 $n$，表示木棍数。", "outputFormat": "对于每组数据：输出一行，如果存在满足题意的正整数，输出这个数；否则输出 $-1$。", "hint": "**【样例 1 解释】**\n\n- 对于第一组测试数据，不存在任何一个正整数可以使用恰好一根小木棍摆出，故输出 $-1$。\n- 对于第四组测试数据，注意 $0$ 并不是一个满足要求的方案。摆出 $9$、$41$ 以及 $111$ 都恰好需要 $6$ 根小木棍，但它们不是摆出的数最小的方案。\n- 对于第五组测试数据，摆出 $208$ 需要 $5 + 6 + 7 = 18$ 根小木棍。可以证明摆出任何一个小于 $208$ 的正整数需要的小木棍数都不是 $18$。注意尽管拼出 $006$ 也需要 $18$ 根小木棍，但因为这个数有前导零，因此并不是一个满足要求的方案。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1 \\leq T \\leq 50$，$1 \\leq n \\leq 10^5$。\n\n::cute-table{tuack}\n\n| 测试点编号 | $n\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $20$ | 无 |\n| $2$ | $50$ | ^ |\n| $3$ | $10^3$ | A |\n| $4,5$ | $10^5$ | ^ |\n| $6$ | $10^3$ | B |\n| $7,8$ | $10^5$ | ^ |\n| $9$ | $10^3$ | 无 |\n| $10$ | $10^5$ | ^ |\n\n特殊性质 A：保证 $n$ 是 $7$ 的倍数且 $n \\geq 100$。\n\n特殊性质 B：保证存在整数 $k$ 使得 $n = 7k + 1$，且 $n \\geq 100$。", "locale": "zh-CN"}}}
{"pid": "P11230", "type": "P", "difficulty": 5, "samples": [["1\n3 3 7\n5 1 2 3 4 1\n3 1 2 5\n3 5 1 6\n1 2\n1 4\n2 4\n3 4\n6 6\n1 1\n7 7", "1\n0\n1\n0\n1\n0\n0"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "图论", "2024", "O2优化", "最短路", "CSP-J 入门级"], "title": "[CSP-J 2024] 接龙", "background": null, "description": "在玩惯了成语接龙之后，小 J 和他的朋友们发明了一个新的接龙规则。\n\n总共有 $n$ 个人参与这个接龙游戏，第 $i$ 个人会获得一个整数序列 $S_i$ 作为他的词库。\n\n一次游戏分为若干轮，每一轮规则如下：\n\n- $n$ 个人中的某个人 $p$ 带着他的词库 $S_p$ 进行接龙。若这不是游戏的第一轮，那么这一轮进行接龙的人不能与上一轮相同，但可以与上上轮或更往前的轮相同。\n- 接龙的人选择一个长度在 $[2, k]$ 的 $S_p$ 的连续子序列 $A$ 作为这一轮的**接龙序列**，其中 $k$ 是给定的常数。若这是游戏的第一轮，那么 $A$ 需要以元素 $1$ 开头，否则 $A$ 需要以上一轮的接龙序列的最后一个元素开头。\n  - 序列 $A$ 是序列 $S$ 的连续子序列当且仅当可以通过删除 $S$ 的开头和结尾的若干元素（可以不删除）得到 $A$。\n\n为了强调合作，小 J 给了 $n$ 个参与游戏的人 $q$ 个任务，第 $j$ 个任务需要这 $n$ 个人进行一次游戏，在这次游戏里进行恰好 $r_j$ 轮接龙，且最后一轮的接龙序列的最后一个元素恰好为 $c_j$。为了保证任务的可行性，小 J 请来你判断这 $q$ 个任务是否可以完成的，即是否存在一个可能的游戏过程满足任务条件。", "inputFormat": "**本题有多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示数据组数。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n\n第一行包含三个整数 $n, k, q$，分别表示参与游戏的人数、接龙序列长度上限以及任务个数。\n\n接下来 $n$ 行：\n\n第 $i$ 行包含 $(l_i + 1)$ 个整数 $l_i, S_{i,1}, S_{i,2}, \\dots , S_{i,l_i}$，其中第一个整数 $l_i$ 表示序列 $S_i$ 的长度，接下来 $l_i$ 个整数描述序列 $S_i$。\n\n接下来 $q$ 行：\n\n第 $j$ 行包含两个整数 $r_j, c_j$，描述一个任务。", "outputFormat": "对于每个任务：输出一行包含一个整数，若任务可以完成输出 1，否则输出 0。", "hint": "**【样例 1 解释】**\n\n在下文中，我们使用 $\\{A_i\\} = \\{A_1, A_2, \\dots , A_r\\}$ 表示一轮游戏中所有的接龙序列，$\\{p_i\\} = \\{p_1, p_2, \\dots , p_r\\}$ 表示对应的接龙的人的编号。由于所有字符均为一位数字，为了方便我们直接使用数字字符串表示序列。\n\n- 对于第一组询问，$p_1 = 1$、$A_1 = 12$ 是一个满足条件的游戏过程。\n- 对于第二组询问，可以证明任务不可完成。注意 $p_1 = 1$、$A_1 = 1234$ 不是合法的游戏过程，因为此时 $|A_1| = 4 > k$。\n- 对于第三组询问，$\\{p_i\\} = \\{2, 1\\}$、$\\{A_i\\} = \\{12, 234\\}$ 是一个满足条件的游戏过程。\n- 对于第四组询问，可以证明任务不可完成。注意 $\\{p_i\\} = \\{2, 1, 1\\}、\\{A_i\\} = \\{12, 23, 34\\}$ 不是一个合法的游戏过程，因为尽管所有的接龙序列长度均不超过 $k$，但第二轮和第三轮由同一个人接龙，不符合要求。\n- 对于第五组询问，$\\{p_i\\} = \\{1, 2, 3, 1, 2, 3\\}$、$\\{A_i\\} = \\{12, 25, 51, 12, 25, 516\\}$ 是一个满足条件的游戏过程。\n-  对于第六组询问，可以证明任务不可完成。注意每个接龙序列的长度必须大于等于 $2$，因此 $A_1 = 1$ 不是一个合法的游戏过程。\n- 对于第七组询问，所有人的词库均不存在字符 $\\tt 7$，因此任务显然不可完成。\n\n**【样例 2】**\n\n见选手目录下的 chain/chain2.in 与 chain/chain2.ans。\n\n该样例满足测试点 1 的特殊性质。\n\n**【样例 3】**\n\n见选手目录下的 chain/chain3.in 与 chain/chain3.ans。\n\n该样例满足测试点 2 的特殊性质。\n\n**【样例 4】**\n\n见选手目录下的 chain/chain4.in 与 chain/chain4.ans。\n\n该样例满足特殊性质 A，其中前两组测试数据满足 $n \\leq 1000$、$r \\leq 10$、单组测试数据内所有词库的长度和 $\\leq 2000$、$q \\leq 1000$。\n\n**【样例 5】**\n\n见选手目录下的 chain/chain5.in 与 chain/chain5.ans。\n\n该样例满足特殊性质 B，其中前两组测试数据满足 $n \\leq 1000$、$r \\leq 10$、单组测试数据内所有词库的长度和 $\\leq 2000$、$q \\leq 1000$。\n\n**【样例 6】**\n\n见选手目录下的 chain/chain6.in 与 chain/chain6.ans。\n\n该样例满足特殊性质 C，其中前两组测试数据满足 $n \\leq 1000$、$r \\leq 10$、单组测试数据内所有词库的长度和 $\\leq 2000$、$q \\leq 1000$。\n\n**【数据范围】**\n\n对于所有测试数据，保证：\n- $1 \\leq T \\leq 5$；\n- $1 \\leq n \\leq 10^5$，$2 \\leq k \\leq 2 \\times 10^5$，$1 \\leq q \\leq 10^5$；\n- $1 \\leq l_i \\leq 2 \\times 10^5$，$1 \\leq S_{i,j} \\leq 2 \\times 10^5$；\n- $1 \\leq r_j \\leq 10^2$，$1 \\leq c_j \\leq 2 \\times 10^5$；\n- 设 $\\sum l$ 为**单组测试数据内**所有 $l_i$ 的和，则 $\\sum l\\leq 2\\times 10^5$。\n\n::cute-table{tuack}\n\n| 测试点 | $n\\leq$ | $r\\leq$ | $\\sum l\\leq$ | $q\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10^3$ | $1$ | $2000$ | $10^3$ | 无 |\n| $2,3$ | $10$ | $5$ | $20$ | $10^2$ | ^ |\n| $4,5$ | $10^3$ | $10$ | $2000$ | $10^3$ | A |\n| $6$ | $10^5$ | $10^2$ | $2\\times 10^5$ | $10^5$ | ^ |\n| $7,8$ | $10^3$ | $10$ | $2000$ | $10^3$ | B |\n| $9,10$ | $10^5$ | $10^2$ | $2\\times 10^5$ | $10^5$ | ^ |\n| $11,12$ | $10^3$ | $10$ | $2000$ | $10^3$ | C |\n| $13,14$ | $10^5$ | $10^2$ | $2\\times 10^5$ | $10^5$ | ^ |\n| $15\\sim 17$ | $10^3$ | $10$ | $2000$ | $10^3$ | 无 |\n| $18\\sim 20$ | $10^5$ | $10^2$ | $2\\times 10^5$ | $10^5$ | ^ |\n\n特殊性质 A：保证 $k = 2 \\times 10^5$。\n\n特殊性质 B：保证 $k ≤ 5$。\n\n特殊性质 C：保证在单组测试数据中，任意一个字符在词库中出现次数之和均不超过 $5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-J 2024] 接龙", "background": null, "description": "在玩惯了成语接龙之后，小 J 和他的朋友们发明了一个新的接龙规则。\n\n总共有 $n$ 个人参与这个接龙游戏，第 $i$ 个人会获得一个整数序列 $S_i$ 作为他的词库。\n\n一次游戏分为若干轮，每一轮规则如下：\n\n- $n$ 个人中的某个人 $p$ 带着他的词库 $S_p$ 进行接龙。若这不是游戏的第一轮，那么这一轮进行接龙的人不能与上一轮相同，但可以与上上轮或更往前的轮相同。\n- 接龙的人选择一个长度在 $[2, k]$ 的 $S_p$ 的连续子序列 $A$ 作为这一轮的**接龙序列**，其中 $k$ 是给定的常数。若这是游戏的第一轮，那么 $A$ 需要以元素 $1$ 开头，否则 $A$ 需要以上一轮的接龙序列的最后一个元素开头。\n  - 序列 $A$ 是序列 $S$ 的连续子序列当且仅当可以通过删除 $S$ 的开头和结尾的若干元素（可以不删除）得到 $A$。\n\n为了强调合作，小 J 给了 $n$ 个参与游戏的人 $q$ 个任务，第 $j$ 个任务需要这 $n$ 个人进行一次游戏，在这次游戏里进行恰好 $r_j$ 轮接龙，且最后一轮的接龙序列的最后一个元素恰好为 $c_j$。为了保证任务的可行性，小 J 请来你判断这 $q$ 个任务是否可以完成的，即是否存在一个可能的游戏过程满足任务条件。", "inputFormat": "**本题有多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示数据组数。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n\n第一行包含三个整数 $n, k, q$，分别表示参与游戏的人数、接龙序列长度上限以及任务个数。\n\n接下来 $n$ 行：\n\n第 $i$ 行包含 $(l_i + 1)$ 个整数 $l_i, S_{i,1}, S_{i,2}, \\dots , S_{i,l_i}$，其中第一个整数 $l_i$ 表示序列 $S_i$ 的长度，接下来 $l_i$ 个整数描述序列 $S_i$。\n\n接下来 $q$ 行：\n\n第 $j$ 行包含两个整数 $r_j, c_j$，描述一个任务。", "outputFormat": "对于每个任务：输出一行包含一个整数，若任务可以完成输出 1，否则输出 0。", "hint": "**【样例 1 解释】**\n\n在下文中，我们使用 $\\{A_i\\} = \\{A_1, A_2, \\dots , A_r\\}$ 表示一轮游戏中所有的接龙序列，$\\{p_i\\} = \\{p_1, p_2, \\dots , p_r\\}$ 表示对应的接龙的人的编号。由于所有字符均为一位数字，为了方便我们直接使用数字字符串表示序列。\n\n- 对于第一组询问，$p_1 = 1$、$A_1 = 12$ 是一个满足条件的游戏过程。\n- 对于第二组询问，可以证明任务不可完成。注意 $p_1 = 1$、$A_1 = 1234$ 不是合法的游戏过程，因为此时 $|A_1| = 4 > k$。\n- 对于第三组询问，$\\{p_i\\} = \\{2, 1\\}$、$\\{A_i\\} = \\{12, 234\\}$ 是一个满足条件的游戏过程。\n- 对于第四组询问，可以证明任务不可完成。注意 $\\{p_i\\} = \\{2, 1, 1\\}、\\{A_i\\} = \\{12, 23, 34\\}$ 不是一个合法的游戏过程，因为尽管所有的接龙序列长度均不超过 $k$，但第二轮和第三轮由同一个人接龙，不符合要求。\n- 对于第五组询问，$\\{p_i\\} = \\{1, 2, 3, 1, 2, 3\\}$、$\\{A_i\\} = \\{12, 25, 51, 12, 25, 516\\}$ 是一个满足条件的游戏过程。\n-  对于第六组询问，可以证明任务不可完成。注意每个接龙序列的长度必须大于等于 $2$，因此 $A_1 = 1$ 不是一个合法的游戏过程。\n- 对于第七组询问，所有人的词库均不存在字符 $\\tt 7$，因此任务显然不可完成。\n\n**【样例 2】**\n\n见选手目录下的 chain/chain2.in 与 chain/chain2.ans。\n\n该样例满足测试点 1 的特殊性质。\n\n**【样例 3】**\n\n见选手目录下的 chain/chain3.in 与 chain/chain3.ans。\n\n该样例满足测试点 2 的特殊性质。\n\n**【样例 4】**\n\n见选手目录下的 chain/chain4.in 与 chain/chain4.ans。\n\n该样例满足特殊性质 A，其中前两组测试数据满足 $n \\leq 1000$、$r \\leq 10$、单组测试数据内所有词库的长度和 $\\leq 2000$、$q \\leq 1000$。\n\n**【样例 5】**\n\n见选手目录下的 chain/chain5.in 与 chain/chain5.ans。\n\n该样例满足特殊性质 B，其中前两组测试数据满足 $n \\leq 1000$、$r \\leq 10$、单组测试数据内所有词库的长度和 $\\leq 2000$、$q \\leq 1000$。\n\n**【样例 6】**\n\n见选手目录下的 chain/chain6.in 与 chain/chain6.ans。\n\n该样例满足特殊性质 C，其中前两组测试数据满足 $n \\leq 1000$、$r \\leq 10$、单组测试数据内所有词库的长度和 $\\leq 2000$、$q \\leq 1000$。\n\n**【数据范围】**\n\n对于所有测试数据，保证：\n- $1 \\leq T \\leq 5$；\n- $1 \\leq n \\leq 10^5$，$2 \\leq k \\leq 2 \\times 10^5$，$1 \\leq q \\leq 10^5$；\n- $1 \\leq l_i \\leq 2 \\times 10^5$，$1 \\leq S_{i,j} \\leq 2 \\times 10^5$；\n- $1 \\leq r_j \\leq 10^2$，$1 \\leq c_j \\leq 2 \\times 10^5$；\n- 设 $\\sum l$ 为**单组测试数据内**所有 $l_i$ 的和，则 $\\sum l\\leq 2\\times 10^5$。\n\n::cute-table{tuack}\n\n| 测试点 | $n\\leq$ | $r\\leq$ | $\\sum l\\leq$ | $q\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $10^3$ | $1$ | $2000$ | $10^3$ | 无 |\n| $2,3$ | $10$ | $5$ | $20$ | $10^2$ | ^ |\n| $4,5$ | $10^3$ | $10$ | $2000$ | $10^3$ | A |\n| $6$ | $10^5$ | $10^2$ | $2\\times 10^5$ | $10^5$ | ^ |\n| $7,8$ | $10^3$ | $10$ | $2000$ | $10^3$ | B |\n| $9,10$ | $10^5$ | $10^2$ | $2\\times 10^5$ | $10^5$ | ^ |\n| $11,12$ | $10^3$ | $10$ | $2000$ | $10^3$ | C |\n| $13,14$ | $10^5$ | $10^2$ | $2\\times 10^5$ | $10^5$ | ^ |\n| $15\\sim 17$ | $10^3$ | $10$ | $2000$ | $10^3$ | 无 |\n| $18\\sim 20$ | $10^5$ | $10^2$ | $2\\times 10^5$ | $10^5$ | ^ |\n\n特殊性质 A：保证 $k = 2 \\times 10^5$。\n\n特殊性质 B：保证 $k ≤ 5$。\n\n特殊性质 C：保证在单组测试数据中，任意一个字符在词库中出现次数之和均不超过 $5$。", "locale": "zh-CN"}}}
{"pid": "P11231", "type": "P", "difficulty": 2, "samples": [["5\n1 2 3 1 2", "2"], ["10\n136 136 136 2417 136 136 2417 136 136 136", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2024", "O2优化", "CSP-S 提高级"], "title": "[CSP-S 2024] 决斗", "background": null, "description": "今天是小 Q 的生日，他得到了 $n$ 张卡牌作为礼物。这些卡牌属于火爆的“决斗怪兽”，其中，第 $i$ 张卡代表一只攻击力为 $r_i$，防御力也为 $r_i$ 的怪兽。\n\n一场游戏分为若干回合。每回合，小 Q 会选择某只怪兽 $i$ 以及**另一只**怪兽 $j(i \\neq j)$，并让怪兽 $i$ 向怪兽 $j$ 发起攻击。此时，若怪兽 $i$ 的攻击力小于等于怪兽 $j$ 的防御力，则无事发生；否则，怪兽 $j$ 的防御被打破，怪兽 $j$ 退出游戏不再参与到剩下的游戏中。一只怪兽在整场游戏中**至多**只能发起一次攻击。当未退出游戏的怪兽都已发起过攻击时，游戏结束。\n\n小 Q 希望决定一组攻击顺序，使得在游戏结束时，未退出游戏的怪兽数量尽可能少。", "inputFormat": "输入的第一行包含一个正整数 $n$，表示卡牌的个数。\n\n输入的第二行包含 $n$ 个正整数，其中第 $i$ 个正整数表示第 $i$ 个怪兽的攻击力及防御力 $r_i$。", "outputFormat": "输出一行包含一个整数表示游戏结束时未退出游戏的怪兽数量的最小值。", "hint": "**【样例 1 解释】**\n\n其中一种最优方案为：第一回合让第 $2$ 只怪兽向第 $1$ 只怪兽发起攻击，第二回合让第 $5$ 只怪兽向第 $4$ 只怪兽发起攻击，第三回合让第 $3$ 只怪兽向第 $5$ 只怪兽发起攻击。此时没有退出游戏的怪兽都进行过攻击，游戏结束。可以证明没有更优的攻击顺序。\n\n**【样例 3】**\n\n见选手目录下的 duel/duel3.in 与 duel/duel3.ans。\n\n该样例满足 $\\forall 1 \\leq i \\leq n, r_i \\leq 2$。\n\n**【样例 4】**\n\n见选手目录下的 duel/duel4.in 与 duel/duel4.ans。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1 \\leq n \\leq 10^5$，$1 \\leq r_i \\leq 10^5$。\n\n::cute-table{tuack}\n\n| 测试点 | $n$ | $r_i$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 4$ | $\\leq 10$ | $\\leq 10^5$ | 无特殊性质 |\n| $5\\sim 10$ | $\\leq 10^5$ | $\\leq 2$ | ^ |\n| $11\\sim 15$ | $\\leq 30$ | $\\leq 10^5$ | 特殊性质 A |\n| $16\\sim 20$ | $\\leq 10^5$ | ^ | 无特殊性质 |\n\n特殊性质 A：保证每个 $r_i$ 在可能的值域中独立均匀随机生成。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-S 2024] 决斗", "background": null, "description": "今天是小 Q 的生日，他得到了 $n$ 张卡牌作为礼物。这些卡牌属于火爆的“决斗怪兽”，其中，第 $i$ 张卡代表一只攻击力为 $r_i$，防御力也为 $r_i$ 的怪兽。\n\n一场游戏分为若干回合。每回合，小 Q 会选择某只怪兽 $i$ 以及**另一只**怪兽 $j(i \\neq j)$，并让怪兽 $i$ 向怪兽 $j$ 发起攻击。此时，若怪兽 $i$ 的攻击力小于等于怪兽 $j$ 的防御力，则无事发生；否则，怪兽 $j$ 的防御被打破，怪兽 $j$ 退出游戏不再参与到剩下的游戏中。一只怪兽在整场游戏中**至多**只能发起一次攻击。当未退出游戏的怪兽都已发起过攻击时，游戏结束。\n\n小 Q 希望决定一组攻击顺序，使得在游戏结束时，未退出游戏的怪兽数量尽可能少。", "inputFormat": "输入的第一行包含一个正整数 $n$，表示卡牌的个数。\n\n输入的第二行包含 $n$ 个正整数，其中第 $i$ 个正整数表示第 $i$ 个怪兽的攻击力及防御力 $r_i$。", "outputFormat": "输出一行包含一个整数表示游戏结束时未退出游戏的怪兽数量的最小值。", "hint": "**【样例 1 解释】**\n\n其中一种最优方案为：第一回合让第 $2$ 只怪兽向第 $1$ 只怪兽发起攻击，第二回合让第 $5$ 只怪兽向第 $4$ 只怪兽发起攻击，第三回合让第 $3$ 只怪兽向第 $5$ 只怪兽发起攻击。此时没有退出游戏的怪兽都进行过攻击，游戏结束。可以证明没有更优的攻击顺序。\n\n**【样例 3】**\n\n见选手目录下的 duel/duel3.in 与 duel/duel3.ans。\n\n该样例满足 $\\forall 1 \\leq i \\leq n, r_i \\leq 2$。\n\n**【样例 4】**\n\n见选手目录下的 duel/duel4.in 与 duel/duel4.ans。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1 \\leq n \\leq 10^5$，$1 \\leq r_i \\leq 10^5$。\n\n::cute-table{tuack}\n\n| 测试点 | $n$ | $r_i$ | 特殊性质 |\n| :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 4$ | $\\leq 10$ | $\\leq 10^5$ | 无特殊性质 |\n| $5\\sim 10$ | $\\leq 10^5$ | $\\leq 2$ | ^ |\n| $11\\sim 15$ | $\\leq 30$ | $\\leq 10^5$ | 特殊性质 A |\n| $16\\sim 20$ | $\\leq 10^5$ | ^ | 无特殊性质 |\n\n特殊性质 A：保证每个 $r_i$ 在可能的值域中独立均匀随机生成。", "locale": "zh-CN"}}}
{"pid": "P11232", "type": "P", "difficulty": 4, "samples": [["1\n5 5 15 3\n0 3 0\n12 4 0\n1 1 4\n5 5 -2\n6 4 -4\n2 5 8 9 15", "3 3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "数学", "贪心", "二分", "2024", "O2优化", "排序", "CSP-S 提高级", "分类讨论"], "title": "[CSP-S 2024] 超速检测", "background": null, "description": "小 D 新入职了某国的交管部门，他的第一个任务是负责国家的一条长度为 $L$ 的南北主干道的车辆超速检测。为了考考小 D，上司首先需要他解决一个简化的场景。\n\n这个周末，主干道上预计出现 $n$ 辆车，其中第 $i$ 辆车从主干道上距离最南端 $d_i$ 的位置驶入，以 $v_i$ 的初速度和 $a_i$ 的加速度做匀加速运动向北行驶。我们只考虑从南向北的车辆，故 $v_i > 0$，但 $a_i$ 可正可负，也可以为零。当车辆行驶到主干道最北端（即距离最南端为 $L$ 的位置）或速度降为 $0$（这只可能在 $a_i < 0$ 时发生）时，我们认为该车驶离主干道。\n\n主干道上设置了 $m$ 个测速仪，其中第 $j$ 个测速仪位于主干道上距离最南端 $p_j$ 的位置，每个测速仪可以设置开启或关闭。当某辆车经过某个开启的测速仪时，若这辆车的瞬时速度**超过**了道路限速 $V$，那么这辆车就会被判定为超速。注意当车辆驶入与驶出主干道时，如果在对应位置有一个开启的测速仪，这个测速仪也会对这辆车进行测速。\n\n上司首先想知道，如果所有测速仪都是开启的，那么这 $n$ 辆车中会有多少辆车被判定为超速。\n\n其次，为了节能，部门想关闭一部分测速仪。然而，他们不希望漏掉超速的车，也就是说，当 $n$ 辆车里的某辆车在所有测速仪都开启时被判定为超速，他们希望在关闭一部分测速仪以后它依然被判定为超速。上司还想知道在这样的条件下最多可以关闭多少测速仪。\n\n由于 $n$ 很大，上司允许小 D 使用编程解决这两个问题，于是小 D 找到了你。\n\n如果你对于加速度并不熟悉，小 D 贴心地在本题的“提示”部分提供了有关加速度的公式。", "inputFormat": "输入的第一行包含一个正整数 $T$，表示数据组数。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n\n第一行包含四个整数 $n, m, L, V$，分别表示车辆数量、测速仪数量、主干道长度和道路限速。\n\n接下来 $n$ 行：\n\n第 $i$ 行包含三个整数 $d_i, v_i, a_i$ 描述一辆车。\n\n最后一行包含 $m$ 个整数 $p_1, p_2, \\dots , p_m$ 描述道路上所有测速仪的位置。", "outputFormat": "对于每组数据：输出一行包含两个整数，第一个整数为所有测速仪都开启时被判定为超速的车辆数量，第二个整数为在不漏掉超速车辆的前提下最多可以关闭的测速仪数量。", "hint": "**【样例 1 解释】**\n\n在该组测试数据中，主干道长度为 $15$，限速为 $3$，在距离最南端 $2, 5, 8, 9, 15$ 的位置各设有一个测速仪。\n- 第一辆车在最南端驶入，以 $3$ 的速度匀速行驶。这辆车在整个路段上都没有超速。\n- 第二辆车在距离最南端 $12$ 的位置驶入，以 $4$ 的速度匀速行驶。在最北端驶离主干道时，它会被距离最南端 $15$ 的测速仪判定为超速。\n- 第三辆车在距离最南端 $1$ 的位置驶入，以 $1$ 的初速度、$4$ 的加速度行驶。其在行驶了 $\\frac{3^2-1^2}{2\\times 4}=1$ 的距离，即到达 $2$ 的位置时，速度变为 $3$，并在之后一直超速。因此这辆车会被除了距离最南端 $2$ 的测速仪以外的其他测速仪判定为超速。\n- 第四辆车在距离最南端 $5$ 的位置驶入，以 $5$ 的初速度、$-2$ 的加速度行驶。其在行驶了 $\\frac{3^2-5^2}{2\\times (-2)}$ 的距离，即到达 $9$ 的位置时，速度变为 $3$。因此这辆车在距离最南端 $[5, 9)$ 时超速，会被距离最南端 $5$ 和 $8$ 的两个测速仪判定为超速。\n- 第五辆车在距离最南端 $6$ 的位置驶入，以 $4$ 的初速度、$−4$ 的加速度行驶。在其行驶了 $\\frac{3^2-4^2}{2\\times (-4)}=\\frac{7}{8}$ 的距离后，即这辆车到达 $6\\frac{7}{8}$ 的位置时，其速度变为 $3$。因此这辆车在距离最南端 $[6,6\\frac{7}{8})$ 时超速，但这段区间内没有测速仪，因此不会被判定为超速。\n\n因此第二、三、四辆车会被判定为超速，输出的第一个数为 $3$。\n\n我们可以关闭距离最南端 $2, 8, 9$ 的三个测速仪，保留 $5$ 和 $15$ 的两个测速仪，此时三辆之前被判定为超速的车依然被判定为超速。可以证明不存在更优方案，因此输出的第二个数为 $3$。\n\n**【样例 2】**\n\n见选手目录下的 detect/detect2.in 与 detect/detect2.ans。\n\n该组样例满足 $n, m \\leq 10$。\n\n**【样例 3】**\n\n见选手目录下的 detect/detect3.in 与 detect/detect3.ans。\n\n该组样例满足特殊性质 A，其中前十组测试数据满足 $n, m \\leq 3000$。\n\n**【样例 4】**\n\n见选手目录下的 detect/detect4.in 与 detect/detect4.ans。\n\n该组样例满足特殊性质 B，其中前十组测试数据满足 $n, m \\leq 3000$。\n\n**【样例 5】**\n\n见选手目录下的 detect/detect5.in 与 detect/detect5.ans。\n\n该组样例满足特殊性质 C，其中前十组测试数据满足 $n, m \\leq 3000$。\n\n**【数据范围】**\n\n对于所有测试数据，保证：\n\n- $1 \\leq T \\leq 20$；\n- $1 \\leq n, m \\leq 10^5$，$1 \\leq L \\leq 10^6$，$1 \\leq V \\leq 10^3$；\n- $0 \\leq d_i < L$，$1 \\leq v_i \\leq 10^3$，$|a_i| \\leq 10^3$；\n- $0 \\leq p_1 < p_2 < \\dots < p_m \\leq L$。\n\n::cute-table{tuack}\n\n| 测试点 | $n,m\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $10$ | 无 |\n| $2$ | $20$ | ^ |\n| $3$ | $3000$ | A |\n| $4$ | $10^5$ | ^ |\n| $5$ | $3000$ | B |\n| $6$ | $10^5$ | ^ |\n| $7$ | $3000$ | C |\n| $8$ | $10^5$ | ^ |\n| $9$ | $3000$ | 无 |\n| $10$ | $10^5$ | ^ |\n\n特殊性质 A：保证 $a_i = 0$。\n\n特殊性质 B：保证 $a_i > 0$。\n\n特殊性质 C：保证 $a_i < 0$，且所有车都不在最北端驶离主干道。\n\n**【提示】**\n\n与加速度有关的定义和公式如下：\n\n- 匀加速运动是指物体在运动过程中，加速度保持不变的运动，即每单位时间内速度的变化量是恒定的。\n- 当一辆车的初速度为 $v_0$、加速度 $a\\neq 0$，做匀加速运动，则 $t$ 时刻后它的速度 $v_1 = v_0 + a \\times t$，它的位移（即行驶路程）$s=v_0\\times t+0.5\\times a\\times t^2$。\n- 当一辆车的初速度为 $v_0$、加速度 $a \\neq 0$，做匀加速运动，则当它的位移（即行驶路程）为 $s$ 时，这辆车的瞬时速度为 $\\sqrt{v_0^2+2\\times a\\times s}$。\n- 当一辆车的初速度为 $v_0$、加速度 $a \\neq 0$，在它的位移（即行驶路程）为 $\\frac{v_1^2-v_0^2}{2a}$ 时，这辆车的瞬时速度为 $v_1$。\n\n如果你使用浮点数进行计算，需要注意潜在的精度问题。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-S 2024] 超速检测", "background": null, "description": "小 D 新入职了某国的交管部门，他的第一个任务是负责国家的一条长度为 $L$ 的南北主干道的车辆超速检测。为了考考小 D，上司首先需要他解决一个简化的场景。\n\n这个周末，主干道上预计出现 $n$ 辆车，其中第 $i$ 辆车从主干道上距离最南端 $d_i$ 的位置驶入，以 $v_i$ 的初速度和 $a_i$ 的加速度做匀加速运动向北行驶。我们只考虑从南向北的车辆，故 $v_i > 0$，但 $a_i$ 可正可负，也可以为零。当车辆行驶到主干道最北端（即距离最南端为 $L$ 的位置）或速度降为 $0$（这只可能在 $a_i < 0$ 时发生）时，我们认为该车驶离主干道。\n\n主干道上设置了 $m$ 个测速仪，其中第 $j$ 个测速仪位于主干道上距离最南端 $p_j$ 的位置，每个测速仪可以设置开启或关闭。当某辆车经过某个开启的测速仪时，若这辆车的瞬时速度**超过**了道路限速 $V$，那么这辆车就会被判定为超速。注意当车辆驶入与驶出主干道时，如果在对应位置有一个开启的测速仪，这个测速仪也会对这辆车进行测速。\n\n上司首先想知道，如果所有测速仪都是开启的，那么这 $n$ 辆车中会有多少辆车被判定为超速。\n\n其次，为了节能，部门想关闭一部分测速仪。然而，他们不希望漏掉超速的车，也就是说，当 $n$ 辆车里的某辆车在所有测速仪都开启时被判定为超速，他们希望在关闭一部分测速仪以后它依然被判定为超速。上司还想知道在这样的条件下最多可以关闭多少测速仪。\n\n由于 $n$ 很大，上司允许小 D 使用编程解决这两个问题，于是小 D 找到了你。\n\n如果你对于加速度并不熟悉，小 D 贴心地在本题的“提示”部分提供了有关加速度的公式。", "inputFormat": "输入的第一行包含一个正整数 $T$，表示数据组数。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n\n第一行包含四个整数 $n, m, L, V$，分别表示车辆数量、测速仪数量、主干道长度和道路限速。\n\n接下来 $n$ 行：\n\n第 $i$ 行包含三个整数 $d_i, v_i, a_i$ 描述一辆车。\n\n最后一行包含 $m$ 个整数 $p_1, p_2, \\dots , p_m$ 描述道路上所有测速仪的位置。", "outputFormat": "对于每组数据：输出一行包含两个整数，第一个整数为所有测速仪都开启时被判定为超速的车辆数量，第二个整数为在不漏掉超速车辆的前提下最多可以关闭的测速仪数量。", "hint": "**【样例 1 解释】**\n\n在该组测试数据中，主干道长度为 $15$，限速为 $3$，在距离最南端 $2, 5, 8, 9, 15$ 的位置各设有一个测速仪。\n- 第一辆车在最南端驶入，以 $3$ 的速度匀速行驶。这辆车在整个路段上都没有超速。\n- 第二辆车在距离最南端 $12$ 的位置驶入，以 $4$ 的速度匀速行驶。在最北端驶离主干道时，它会被距离最南端 $15$ 的测速仪判定为超速。\n- 第三辆车在距离最南端 $1$ 的位置驶入，以 $1$ 的初速度、$4$ 的加速度行驶。其在行驶了 $\\frac{3^2-1^2}{2\\times 4}=1$ 的距离，即到达 $2$ 的位置时，速度变为 $3$，并在之后一直超速。因此这辆车会被除了距离最南端 $2$ 的测速仪以外的其他测速仪判定为超速。\n- 第四辆车在距离最南端 $5$ 的位置驶入，以 $5$ 的初速度、$-2$ 的加速度行驶。其在行驶了 $\\frac{3^2-5^2}{2\\times (-2)}$ 的距离，即到达 $9$ 的位置时，速度变为 $3$。因此这辆车在距离最南端 $[5, 9)$ 时超速，会被距离最南端 $5$ 和 $8$ 的两个测速仪判定为超速。\n- 第五辆车在距离最南端 $6$ 的位置驶入，以 $4$ 的初速度、$−4$ 的加速度行驶。在其行驶了 $\\frac{3^2-4^2}{2\\times (-4)}=\\frac{7}{8}$ 的距离后，即这辆车到达 $6\\frac{7}{8}$ 的位置时，其速度变为 $3$。因此这辆车在距离最南端 $[6,6\\frac{7}{8})$ 时超速，但这段区间内没有测速仪，因此不会被判定为超速。\n\n因此第二、三、四辆车会被判定为超速，输出的第一个数为 $3$。\n\n我们可以关闭距离最南端 $2, 8, 9$ 的三个测速仪，保留 $5$ 和 $15$ 的两个测速仪，此时三辆之前被判定为超速的车依然被判定为超速。可以证明不存在更优方案，因此输出的第二个数为 $3$。\n\n**【样例 2】**\n\n见选手目录下的 detect/detect2.in 与 detect/detect2.ans。\n\n该组样例满足 $n, m \\leq 10$。\n\n**【样例 3】**\n\n见选手目录下的 detect/detect3.in 与 detect/detect3.ans。\n\n该组样例满足特殊性质 A，其中前十组测试数据满足 $n, m \\leq 3000$。\n\n**【样例 4】**\n\n见选手目录下的 detect/detect4.in 与 detect/detect4.ans。\n\n该组样例满足特殊性质 B，其中前十组测试数据满足 $n, m \\leq 3000$。\n\n**【样例 5】**\n\n见选手目录下的 detect/detect5.in 与 detect/detect5.ans。\n\n该组样例满足特殊性质 C，其中前十组测试数据满足 $n, m \\leq 3000$。\n\n**【数据范围】**\n\n对于所有测试数据，保证：\n\n- $1 \\leq T \\leq 20$；\n- $1 \\leq n, m \\leq 10^5$，$1 \\leq L \\leq 10^6$，$1 \\leq V \\leq 10^3$；\n- $0 \\leq d_i < L$，$1 \\leq v_i \\leq 10^3$，$|a_i| \\leq 10^3$；\n- $0 \\leq p_1 < p_2 < \\dots < p_m \\leq L$。\n\n::cute-table{tuack}\n\n| 测试点 | $n,m\\leq$ | 特殊性质 |\n| :----------: | :----------: | :----------: |\n| $1$ | $10$ | 无 |\n| $2$ | $20$ | ^ |\n| $3$ | $3000$ | A |\n| $4$ | $10^5$ | ^ |\n| $5$ | $3000$ | B |\n| $6$ | $10^5$ | ^ |\n| $7$ | $3000$ | C |\n| $8$ | $10^5$ | ^ |\n| $9$ | $3000$ | 无 |\n| $10$ | $10^5$ | ^ |\n\n特殊性质 A：保证 $a_i = 0$。\n\n特殊性质 B：保证 $a_i > 0$。\n\n特殊性质 C：保证 $a_i < 0$，且所有车都不在最北端驶离主干道。\n\n**【提示】**\n\n与加速度有关的定义和公式如下：\n\n- 匀加速运动是指物体在运动过程中，加速度保持不变的运动，即每单位时间内速度的变化量是恒定的。\n- 当一辆车的初速度为 $v_0$、加速度 $a\\neq 0$，做匀加速运动，则 $t$ 时刻后它的速度 $v_1 = v_0 + a \\times t$，它的位移（即行驶路程）$s=v_0\\times t+0.5\\times a\\times t^2$。\n- 当一辆车的初速度为 $v_0$、加速度 $a \\neq 0$，做匀加速运动，则当它的位移（即行驶路程）为 $s$ 时，这辆车的瞬时速度为 $\\sqrt{v_0^2+2\\times a\\times s}$。\n- 当一辆车的初速度为 $v_0$、加速度 $a \\neq 0$，在它的位移（即行驶路程）为 $\\frac{v_1^2-v_0^2}{2a}$ 时，这辆车的瞬时速度为 $v_1$。\n\n如果你使用浮点数进行计算，需要注意潜在的精度问题。", "locale": "zh-CN"}}}
{"pid": "P11233", "type": "P", "difficulty": 5, "samples": [["3\n3\n1 2 1\n4\n1 2 3 4\n8\n3 5 2 5 1 2 1 4", "1\n0\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "线段树", "2024", "O2优化", "动态规划优化", "CSP-S 提高级"], "title": "[CSP-S 2024] 染色", "background": null, "description": "给定一个长度为 $n$ 的正整数数组 $A$，其中所有数从左至右排成一排。\n\n你需要将 $A$ 中的每个数染成红色或蓝色之一，然后按如下方式计算最终得分：\n\n设 $C$ 为长度为 $n$ 的整数数组，对于 $A$ 中的每个数 $A_i$（$1 \\leq i \\leq n$）：\n\n- 如果 $A_i$ 左侧没有与其同色的数，则令 $C_i = 0$。\n- 否则，记其左侧**与其最靠近的同色数**为 $A_j$，若 $A_i = A_j$，则令 $C_i = A_i$，否则令 $C_i = 0$。\n\n你的最终得分为 $C$ 中所有整数的和，即 $\\sum \\limits_{i=1}^n C_i$。你需要最大化最终得分，请求出最终得分的最大值。", "inputFormat": "**本题有多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示数据组数。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n\n第一行包含一个正整数 $n$，表示数组长度。\n\n第二行包含 $n$ 个正整数 $A_1, A_2, \\dots, A_n$，表示数组 $A$ 中的元素。", "outputFormat": "对于每组数据：输出一行包含一个非负整数，表示最终得分的最大可能值。", "hint": "**【样例 1 解释】**\n\n对于第一组数据，以下为三种可能的染色方案：\n\n1. 将 $A_1, A_2$ 染成红色，将 $A_3$ 染成蓝色（$\\red{1}\\red{2}\\blue{1}$），其得分计算方式如下：\n- 对于 $A_1$，由于其左侧没有红色的数，所以 $C_1 = 0$。\n- 对于 $A_2$，其左侧与其最靠近的红色数为 $A_1$。由于 $A_1 \\neq A_2$，所以 $C_2 = 0$。\n- 对于 $A_3$，由于其左侧没有蓝色的数，所以 $C_3 = 0$。    \n该方案最终得分为 $C_1 + C_2 + C_3 = 0$。\n2. 将 $A_1, A_2, A_3$ 全部染成红色（$\\red{121}$），其得分计算方式如下：\n- 对于 $A_1$，由于其左侧没有红色的数，所以 $C_1 = 0$。\n- 对于 $A_2$，其左侧与其最靠近的红色数为 $A_1$。由于 $A_1 \\neq A_2$，所以 $C_2 = 0$。\n- 对于 $A_3$，其左侧与其最靠近的红色数为 $A_2$。由于 $A_2 \\neq A_3$，所以 $C_3 = 0$。    \n该方案最终得分为 $C_1 + C_2 + C_3 = 0$。\n3. 将 $A_1, A_3$ 染成红色，将 $A_2$ 染成蓝色（$\\red{1}\\blue{2}\\red{1}$），其得分计算方式如下：\n- 对于 $A_1$，由于其左侧没有红色的数，所以 $C_1 = 0$。\n- 对于 $A_2$，由于其左侧没有蓝色的数，所以 $C_2 = 0$。\n- 对于 $A_3$，其左侧与其最靠近的红色数为 $A_1$。由于 $A_1 = A_3$，所以 $C_3 = A_3 = 1$。    \n该方案最终得分为 $C_1 + C_2 + C_3 = 1$。\n\n可以证明，没有染色方案使得最终得分大于 $1$。\n\n对于第二组数据，可以证明，任何染色方案的最终得分都是 $0$。\n\n对于第三组数据，一种最优的染色方案为将 $A_1, A_2, A_4, A_5, A_7$ 染为红色，将 $A_3, A_6, A_8$ 染为蓝色（$\\red{35}\\blue{2}\\red{51}\\blue{2}\\red{1}\\blue{4}$），其对应 $C = [0, 0, 0, 5, 0, 2, 1, 0]$，最终得分为 $8$。\n\n**【样例 2】**\n\n见选手目录下的 color/color2.in 与 color/color2.ans。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1\\leq T\\leq 10$，$2\\leq n\\leq 2\\times 10^5$，$1\\leq A_i\\leq 10^6$。\n\n::cute-table{tuack}\n\n| 测试点 | $n$ | $A_i$ |\n| :----------: | :----------: | :----------: |\n| $1\\sim 4$ | $\\leq 15$ | $\\leq 15$ |\n| $5\\sim 7$ | $\\leq 10^2$ | $\\leq 10^2$ |\n| $8\\sim 10$ | $\\leq 2000$ | $\\leq 2000$ |\n| $11,12$ | $\\leq 2\\times 10^4$ | $\\leq 10^6$ |\n| $13\\sim 15$ | $\\leq 2\\times 10^5$ | $\\leq 10$ |\n| $16\\sim 20$ | ^ | $\\leq 10^6$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-S 2024] 染色", "background": null, "description": "给定一个长度为 $n$ 的正整数数组 $A$，其中所有数从左至右排成一排。\n\n你需要将 $A$ 中的每个数染成红色或蓝色之一，然后按如下方式计算最终得分：\n\n设 $C$ 为长度为 $n$ 的整数数组，对于 $A$ 中的每个数 $A_i$（$1 \\leq i \\leq n$）：\n\n- 如果 $A_i$ 左侧没有与其同色的数，则令 $C_i = 0$。\n- 否则，记其左侧**与其最靠近的同色数**为 $A_j$，若 $A_i = A_j$，则令 $C_i = A_i$，否则令 $C_i = 0$。\n\n你的最终得分为 $C$ 中所有整数的和，即 $\\sum \\limits_{i=1}^n C_i$。你需要最大化最终得分，请求出最终得分的最大值。", "inputFormat": "**本题有多组测试数据。**\n\n输入的第一行包含一个正整数 $T$，表示数据组数。\n\n接下来包含 $T$ 组数据，每组数据的格式如下：\n\n第一行包含一个正整数 $n$，表示数组长度。\n\n第二行包含 $n$ 个正整数 $A_1, A_2, \\dots, A_n$，表示数组 $A$ 中的元素。", "outputFormat": "对于每组数据：输出一行包含一个非负整数，表示最终得分的最大可能值。", "hint": "**【样例 1 解释】**\n\n对于第一组数据，以下为三种可能的染色方案：\n\n1. 将 $A_1, A_2$ 染成红色，将 $A_3$ 染成蓝色（$\\red{1}\\red{2}\\blue{1}$），其得分计算方式如下：\n- 对于 $A_1$，由于其左侧没有红色的数，所以 $C_1 = 0$。\n- 对于 $A_2$，其左侧与其最靠近的红色数为 $A_1$。由于 $A_1 \\neq A_2$，所以 $C_2 = 0$。\n- 对于 $A_3$，由于其左侧没有蓝色的数，所以 $C_3 = 0$。    \n该方案最终得分为 $C_1 + C_2 + C_3 = 0$。\n2. 将 $A_1, A_2, A_3$ 全部染成红色（$\\red{121}$），其得分计算方式如下：\n- 对于 $A_1$，由于其左侧没有红色的数，所以 $C_1 = 0$。\n- 对于 $A_2$，其左侧与其最靠近的红色数为 $A_1$。由于 $A_1 \\neq A_2$，所以 $C_2 = 0$。\n- 对于 $A_3$，其左侧与其最靠近的红色数为 $A_2$。由于 $A_2 \\neq A_3$，所以 $C_3 = 0$。    \n该方案最终得分为 $C_1 + C_2 + C_3 = 0$。\n3. 将 $A_1, A_3$ 染成红色，将 $A_2$ 染成蓝色（$\\red{1}\\blue{2}\\red{1}$），其得分计算方式如下：\n- 对于 $A_1$，由于其左侧没有红色的数，所以 $C_1 = 0$。\n- 对于 $A_2$，由于其左侧没有蓝色的数，所以 $C_2 = 0$。\n- 对于 $A_3$，其左侧与其最靠近的红色数为 $A_1$。由于 $A_1 = A_3$，所以 $C_3 = A_3 = 1$。    \n该方案最终得分为 $C_1 + C_2 + C_3 = 1$。\n\n可以证明，没有染色方案使得最终得分大于 $1$。\n\n对于第二组数据，可以证明，任何染色方案的最终得分都是 $0$。\n\n对于第三组数据，一种最优的染色方案为将 $A_1, A_2, A_4, A_5, A_7$ 染为红色，将 $A_3, A_6, A_8$ 染为蓝色（$\\red{35}\\blue{2}\\red{51}\\blue{2}\\red{1}\\blue{4}$），其对应 $C = [0, 0, 0, 5, 0, 2, 1, 0]$，最终得分为 $8$。\n\n**【样例 2】**\n\n见选手目录下的 color/color2.in 与 color/color2.ans。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$1\\leq T\\leq 10$，$2\\leq n\\leq 2\\times 10^5$，$1\\leq A_i\\leq 10^6$。\n\n::cute-table{tuack}\n\n| 测试点 | $n$ | $A_i$ |\n| :----------: | :----------: | :----------: |\n| $1\\sim 4$ | $\\leq 15$ | $\\leq 15$ |\n| $5\\sim 7$ | $\\leq 10^2$ | $\\leq 10^2$ |\n| $8\\sim 10$ | $\\leq 2000$ | $\\leq 2000$ |\n| $11,12$ | $\\leq 2\\times 10^4$ | $\\leq 10^6$ |\n| $13\\sim 15$ | $\\leq 2\\times 10^5$ | $\\leq 10$ |\n| $16\\sim 20$ | ^ | $\\leq 10^6$ |", "locale": "zh-CN"}}}
{"pid": "P11234", "type": "P", "difficulty": 7, "samples": [["5 5\n0 0 0 0 0\n5 4 1 2 3\n1001\n10\n1\n4\n2 1 0 0\n1 2 1 0\n0 2 3 1\n2 2 0 1", "5\n19\n7\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "递推", "递归", "2024", "O2优化", "深度优先搜索 DFS", "树形 DP", "差分", "CSP-S 提高级"], "title": "[CSP-S 2024] 擂台游戏", "background": "", "description": "小 S 想要举办一场擂台游戏，如果共有 $2^k$ 名选手参加，那么游戏分为 $k$ 轮进行：\n\n- 第一轮编号为 $1, 2$ 的选手进行一次对局，编号为 $3, 4$ 的选手进行一次对局，以此类推，编号为 $2^k - 1, 2^k$ 的选手进行一次对局。\n- 第二轮在只保留第一轮的胜者的前提下，相邻的两位依次进行一场对局。\n- 以此类推，第 $k - 1$ 轮在只保留第 $k - 2$ 轮的 $4$ 位胜者的前提下，前两位、后两位分别进行对局，也就是所谓的半决赛。\n- 第 $k$ 轮即为半决赛两位胜者的决赛。\n\n确定了游戏晋级的规则后，小 S 将比赛的规则设置为了擂台赛。具体而言，每位选手都有一个能力值 $a_1, a_2, \\dots , a_{2^k}$，能力值为 $[0,2^{31}-1]$ 之内的整数。对于每场比赛，会先抽签决定一个数 $0/1$，我们将第 $R$ 轮的第 $G$ 场比赛抽到的数记为 $d_{R,G}$。抽到 $0$ 则表示表示编号小的选手为擂主，抽到 $1$ 则表示编号大的选手为擂主。擂主获胜当且仅当他的能力值 $a\\geq R$。也就是说，游戏的胜负只取决于**擂主的能力值**与**当前比赛是第几轮**的大小关系，**与另一位的能力值无关**。\n\n现在，小 S 先后陆续收到了 $n$ 位选手的报名信息，他们分别告知了小 S 自己的能力值。小 S 会按照报名的先后顺序对选手进行编号为 $1, 2, \\dots, n$。小 S 关心的是，补充**尽量少**的选手使总人数为 $2$ 的整次幂，且所有选手进行一次完整的擂台游戏后，所有可能成为总冠军的选手的**编号之和**是多少。\n\n形式化地，设 $k$ 是最小的非负整数使得 $2^k\\geq n$，那么应当补充 $(2^k-n)$ 名选手，且补充的选手的能力值可以任取 $[0,2^{31}-1]$ 之内的整数。**如果补充的选手有可能取胜，也应当计入答案中**。\n\n当然小 S 觉得这个问题还是太简单了，所以他给了你 $m$ 个询问 $c_1,c_2,\\dots,c_m$。小 S 希望你帮忙对于每个 $c_i$ 求出，在只收到前 $c_i$ 位选手的报名信息时，这个问题的答案是多少。", "inputFormat": "**本题的测试点包含有多组测试数据。** 但不同测试数据只是通过修改 $a_1, a_2, \\dots , a_n$ 得到，其他内容均保持不变，请参考以下格式。其中 $\\oplus$ 代表异或运算符，$a \\bmod b$ 代表 $a$ 除以 $b$ 的余数。\n\n输入的第一行包含两个正整数 $n, m$，表示报名的选手数量和询问的数量。\n\n输入的第二行包含 $n$ 个非负整数 $a'_1,a'_2,\\dots,a'_n$，这列数将用来计算真正的能力值。\n\n输入的第三行包含 $m$ 个正整数 $c_1, c_2, \\dots , c_m$，表示询问。\n\n设 $K$ 是使得 $2^K \\geq n$ 的最小的非负整数，接下来的 $K$ 行当中，第 $R$ 行包含 $2^{K-R}$ 个数（无空格），其中第 $G$ 个数表示第 $R$ 轮的第 $G$ 场比赛抽签得到的 $d_{R,G}=0/1$。\n\n注意，由于询问只是将人数凑齐到 $2^k\\geq c_i$，这里的 $k\\leq K$，因此你未必会用到全部的输入值。\n\n接下来一行包含一个正整数 $T$，表示有 $T$ 组测试数据。\n\n接下来共 $T$ 行，每行描述一组数据，包含 $4$ 个非负整数 $X_0,X_1,X_2,X_3$，该组数据的能力值 $a_i=a'_i \\oplus X_{i\\bmod 4}$，其中 $1\\leq i\\leq n$。", "outputFormat": "共输出 $T$ 行，对于每组数据，设 $A_i$ 为第 $i$（$1 \\leq i \\leq m$）组询问的答案，你只需要输出一行包含一个整数，表示 $(1\\times A_1) \\oplus (2\\times A_2) \\oplus \\dots \\oplus (m\\times A_m)$ 的结果。", "hint": "**【样例 1 解释】**\n\n共有 $T = 4$ 组数据，这里只解释第一组。$5$ 名选手的真实能力值为 $[1, 0, 0, 2, 1]$。$5$ 组询问分别是对长度为 $5, 4, 1, 2, 3$ 的前缀进行的。\n\n1. 对于长度为 $1$ 的前缀，由于只有 $1$ 号一个人，因此答案为 $1$。\n2. 对于长度为 $2$ 的前缀，由于 $2$ 个人已经是 $2$ 的幂次，因此不需要进行扩充。根据抽签 $d_{1,1} = 1$ 可知 $2$ 号为擂主，由于 $a_2 < 1$，因此 $1$ 号获胜，答案为 $1$。\n3. 对于长度为 $3$ 的前缀，首先 $1$ 号、$2$ 号比赛是 $1$ 号获胜（因为 $d_{1,1} = 1$，故 $2$ 号为擂主，$a_2 < 1$），然后虽然 $4$ 号能力值还不知道，但 $3$ 号、$4$ 号比赛一定是 $4$ 号获胜（因为 $d_{1,2} = 0$，故 $3$ 号为擂主，$a_3 < 1$），而决赛 $1$ 号、$4$ 号谁获胜都有可能（因为 $d_{2,1} = 1$，故 $4$ 号为擂主，如果 $a_4 < 2$ 则 $1$ 号获胜，$a_4 \\geq 2$ 则 $4$ 号获胜）。综上所述，答案为 $1 + 4 = 5$。\n4. 对于长度为 $4$ 的前缀，我们根据上一条的分析得知，由于 $a_4 \\geq 2$ ，所以决赛获胜的是 $4$ 号。\n5. 对于长度为 $5$ 的前缀，可以证明，可能获胜的选手包括 $4$ 号、$7$ 号、$8$ 号，答案为 $19$。\n\n因此，该组测试数据的答案为 $(1 \\times 19) \\oplus (2 \\times 4) \\oplus (3 \\times 1) \\oplus (4 \\times 1) \\oplus (5 \\times 5) = 5$。\n\n**【样例 2】**\n\n见选手目录下的 arena/arena2.in 与 arena/arena2.ans。\n\n这组样例满足特殊性质 A。\n\n**【样例 3】**\n\n见选手目录下的 arena/arena3.in 与 arena/arena3.ans。\n\n这组样例满足特殊性质 B。\n\n**【样例 4】**\n\n见选手目录下的 arena/arena4.in 与 arena/arena4.ans。\n\n**【样例 5】**\n\n见选手目录下的 arena/arena5.in 与 arena/arena5.ans。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$2 \\leq n, m \\leq 10^5$，$0 \\leq a_i, X_j < 2^{31}$，$1 \\leq c_i \\leq n$，$1 \\leq T \\leq 256$。\n\n::cute-table{tuack}\n\n| 测试点 | $T=$ | $n,m\\leq$ | 特殊性质 A | 特殊性质 B |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 3$ | $1$ | $8$ | 否 | 否 |\n| $4,5$ | ^ | $500$ | 是 | ^ |\n| $6\\sim 8$ | ^ | ^ | 否 | 是 |\n| $9,10$ | ^ | $5000$ | ^ | 否 |\n| $11,12$ | ^ | $10^5$ | 是 | ^ |\n| $13\\sim 15$ | ^ | ^ | 否 | 是 |\n| $16,17$ | $4$ | ^ | ^ | 否 |\n| $18,19$ | $16$ | ^ | ^ | ^ |\n| $20,21$ | $64$ | ^ | ^ | ^ |\n| $22,23$ | $128$ | ^ | ^ | ^ |\n| $24,25$ | $256$ | ^ | ^ | ^ |\n\n\n特殊性质 A：保证询问的 $c_i$ 均为 $2$ 的幂次。\n\n特殊性质 B：保证所有的 $d_{R,G} = 0$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[CSP-S 2024] 擂台游戏", "background": "", "description": "小 S 想要举办一场擂台游戏，如果共有 $2^k$ 名选手参加，那么游戏分为 $k$ 轮进行：\n\n- 第一轮编号为 $1, 2$ 的选手进行一次对局，编号为 $3, 4$ 的选手进行一次对局，以此类推，编号为 $2^k - 1, 2^k$ 的选手进行一次对局。\n- 第二轮在只保留第一轮的胜者的前提下，相邻的两位依次进行一场对局。\n- 以此类推，第 $k - 1$ 轮在只保留第 $k - 2$ 轮的 $4$ 位胜者的前提下，前两位、后两位分别进行对局，也就是所谓的半决赛。\n- 第 $k$ 轮即为半决赛两位胜者的决赛。\n\n确定了游戏晋级的规则后，小 S 将比赛的规则设置为了擂台赛。具体而言，每位选手都有一个能力值 $a_1, a_2, \\dots , a_{2^k}$，能力值为 $[0,2^{31}-1]$ 之内的整数。对于每场比赛，会先抽签决定一个数 $0/1$，我们将第 $R$ 轮的第 $G$ 场比赛抽到的数记为 $d_{R,G}$。抽到 $0$ 则表示表示编号小的选手为擂主，抽到 $1$ 则表示编号大的选手为擂主。擂主获胜当且仅当他的能力值 $a\\geq R$。也就是说，游戏的胜负只取决于**擂主的能力值**与**当前比赛是第几轮**的大小关系，**与另一位的能力值无关**。\n\n现在，小 S 先后陆续收到了 $n$ 位选手的报名信息，他们分别告知了小 S 自己的能力值。小 S 会按照报名的先后顺序对选手进行编号为 $1, 2, \\dots, n$。小 S 关心的是，补充**尽量少**的选手使总人数为 $2$ 的整次幂，且所有选手进行一次完整的擂台游戏后，所有可能成为总冠军的选手的**编号之和**是多少。\n\n形式化地，设 $k$ 是最小的非负整数使得 $2^k\\geq n$，那么应当补充 $(2^k-n)$ 名选手，且补充的选手的能力值可以任取 $[0,2^{31}-1]$ 之内的整数。**如果补充的选手有可能取胜，也应当计入答案中**。\n\n当然小 S 觉得这个问题还是太简单了，所以他给了你 $m$ 个询问 $c_1,c_2,\\dots,c_m$。小 S 希望你帮忙对于每个 $c_i$ 求出，在只收到前 $c_i$ 位选手的报名信息时，这个问题的答案是多少。", "inputFormat": "**本题的测试点包含有多组测试数据。** 但不同测试数据只是通过修改 $a_1, a_2, \\dots , a_n$ 得到，其他内容均保持不变，请参考以下格式。其中 $\\oplus$ 代表异或运算符，$a \\bmod b$ 代表 $a$ 除以 $b$ 的余数。\n\n输入的第一行包含两个正整数 $n, m$，表示报名的选手数量和询问的数量。\n\n输入的第二行包含 $n$ 个非负整数 $a'_1,a'_2,\\dots,a'_n$，这列数将用来计算真正的能力值。\n\n输入的第三行包含 $m$ 个正整数 $c_1, c_2, \\dots , c_m$，表示询问。\n\n设 $K$ 是使得 $2^K \\geq n$ 的最小的非负整数，接下来的 $K$ 行当中，第 $R$ 行包含 $2^{K-R}$ 个数（无空格），其中第 $G$ 个数表示第 $R$ 轮的第 $G$ 场比赛抽签得到的 $d_{R,G}=0/1$。\n\n注意，由于询问只是将人数凑齐到 $2^k\\geq c_i$，这里的 $k\\leq K$，因此你未必会用到全部的输入值。\n\n接下来一行包含一个正整数 $T$，表示有 $T$ 组测试数据。\n\n接下来共 $T$ 行，每行描述一组数据，包含 $4$ 个非负整数 $X_0,X_1,X_2,X_3$，该组数据的能力值 $a_i=a'_i \\oplus X_{i\\bmod 4}$，其中 $1\\leq i\\leq n$。", "outputFormat": "共输出 $T$ 行，对于每组数据，设 $A_i$ 为第 $i$（$1 \\leq i \\leq m$）组询问的答案，你只需要输出一行包含一个整数，表示 $(1\\times A_1) \\oplus (2\\times A_2) \\oplus \\dots \\oplus (m\\times A_m)$ 的结果。", "hint": "**【样例 1 解释】**\n\n共有 $T = 4$ 组数据，这里只解释第一组。$5$ 名选手的真实能力值为 $[1, 0, 0, 2, 1]$。$5$ 组询问分别是对长度为 $5, 4, 1, 2, 3$ 的前缀进行的。\n\n1. 对于长度为 $1$ 的前缀，由于只有 $1$ 号一个人，因此答案为 $1$。\n2. 对于长度为 $2$ 的前缀，由于 $2$ 个人已经是 $2$ 的幂次，因此不需要进行扩充。根据抽签 $d_{1,1} = 1$ 可知 $2$ 号为擂主，由于 $a_2 < 1$，因此 $1$ 号获胜，答案为 $1$。\n3. 对于长度为 $3$ 的前缀，首先 $1$ 号、$2$ 号比赛是 $1$ 号获胜（因为 $d_{1,1} = 1$，故 $2$ 号为擂主，$a_2 < 1$），然后虽然 $4$ 号能力值还不知道，但 $3$ 号、$4$ 号比赛一定是 $4$ 号获胜（因为 $d_{1,2} = 0$，故 $3$ 号为擂主，$a_3 < 1$），而决赛 $1$ 号、$4$ 号谁获胜都有可能（因为 $d_{2,1} = 1$，故 $4$ 号为擂主，如果 $a_4 < 2$ 则 $1$ 号获胜，$a_4 \\geq 2$ 则 $4$ 号获胜）。综上所述，答案为 $1 + 4 = 5$。\n4. 对于长度为 $4$ 的前缀，我们根据上一条的分析得知，由于 $a_4 \\geq 2$ ，所以决赛获胜的是 $4$ 号。\n5. 对于长度为 $5$ 的前缀，可以证明，可能获胜的选手包括 $4$ 号、$7$ 号、$8$ 号，答案为 $19$。\n\n因此，该组测试数据的答案为 $(1 \\times 19) \\oplus (2 \\times 4) \\oplus (3 \\times 1) \\oplus (4 \\times 1) \\oplus (5 \\times 5) = 5$。\n\n**【样例 2】**\n\n见选手目录下的 arena/arena2.in 与 arena/arena2.ans。\n\n这组样例满足特殊性质 A。\n\n**【样例 3】**\n\n见选手目录下的 arena/arena3.in 与 arena/arena3.ans。\n\n这组样例满足特殊性质 B。\n\n**【样例 4】**\n\n见选手目录下的 arena/arena4.in 与 arena/arena4.ans。\n\n**【样例 5】**\n\n见选手目录下的 arena/arena5.in 与 arena/arena5.ans。\n\n**【数据范围】**\n\n对于所有测试数据，保证：$2 \\leq n, m \\leq 10^5$，$0 \\leq a_i, X_j < 2^{31}$，$1 \\leq c_i \\leq n$，$1 \\leq T \\leq 256$。\n\n::cute-table{tuack}\n\n| 测试点 | $T=$ | $n,m\\leq$ | 特殊性质 A | 特殊性质 B |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1\\sim 3$ | $1$ | $8$ | 否 | 否 |\n| $4,5$ | ^ | $500$ | 是 | ^ |\n| $6\\sim 8$ | ^ | ^ | 否 | 是 |\n| $9,10$ | ^ | $5000$ | ^ | 否 |\n| $11,12$ | ^ | $10^5$ | 是 | ^ |\n| $13\\sim 15$ | ^ | ^ | 否 | 是 |\n| $16,17$ | $4$ | ^ | ^ | 否 |\n| $18,19$ | $16$ | ^ | ^ | ^ |\n| $20,21$ | $64$ | ^ | ^ | ^ |\n| $22,23$ | $128$ | ^ | ^ | ^ |\n| $24,25$ | $256$ | ^ | ^ | ^ |\n\n\n特殊性质 A：保证询问的 $c_i$ 均为 $2$ 的幂次。\n\n特殊性质 B：保证所有的 $d_{R,G} = 0$。", "locale": "zh-CN"}}}
{"pid": "P11235", "type": "P", "difficulty": 7, "samples": [["10\n2 4 3 9 9 9 9 9 9 1\n2\n0 2\n0 9", "3 1\n20 3"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2024", "交互题", "KOI（韩国）"], "title": "[KTSC 2024 R1] 最大化平均值", "background": "**请勿用 C++14 (GCC 9) 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include<vector>\n#include<array>\nvoid initialize(std::vector<int> A);\nstd::array<long long, 2> maximum_average(int i, int j);\n```\n\n题目保证时限在标程的十倍以上，交互库代码运行很快。", "description": "**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T1 「[평균 최대화](https://assets.ioikorea.kr/ioitst/2024/1/average/average_statement.pdf)」**\n\n给定一个由正整数组成的长度为 $m$ $(m \\geq 2)$ 的序列 $x[0], \\cdots, x[m-1]$，如果该序列满足以下条件，则称其为**封闭序列**：\n\n- 对于所有 $k$ $(1 \\leq k \\leq m-2)$，$x[k] > x[0]$ 且 $x[k] > x[m-1]$。\n\n也就是说，如果序列 $x$ 的两端元素都小于中间的所有元素，那么 $x$ 就是一个封闭序列。例如，$[3,7,8,4,2]$ 和 $[7,7]$ 是封闭序列，但 $[5,8,4,6,7]$ 和 $[3,3,4]$ 不是封闭序列。注意，长度为 $2$ 的所有序列都是封闭序列，而长度小于等于 $1$ 的序列不是封闭序列。\n\n给定一个长度为 $K$ 的序列 $X[0], \\cdots, X[K-1]$，定义**剔除操作**为选择一个封闭序列 $X[i], \\cdots, X[j]$，并从序列中移除 $X[i+1], \\cdots, X[j-1]$（即将序列变为 $X[0], \\cdots, X[i], X[j], \\cdots, X[K-1]$）。定义 $f(X)$ 为通过任意次数的剔除操作（可以不使用，也可以多次使用）得到的最终序列的最大平均值。\n\n例如，$f([1,3,2,100,97,98,2,3,4,1])=43$，可以通过以下剔除操作实现：\n\n- 选择 $i=0, j=2$，将序列变为 $[1,2,100,97,98,2,3,4,1]$。\n- 选择 $i=5, j=8$，将序列变为 $[1,2,100,97,98,2,1]$。\n- 最终序列为 $[1,2,100,97,98,2,1]$，其平均值为 $(1+2+100+97+98+2+1) / 7=43$。\n\n给定一个由正整数组成的长度为 $N$ 的序列 $A[0], \\cdots, A[N-1]$。对于每个给定的封闭序列 $(i, j)$，你需要计算 $f(A[i], \\cdots, A[j])$ 的值。\n\n你需要实现以下函数：\n\n```cpp\nvoid initialize(std::vector<int> A);\n```\n- 该函数只会被调用一次，并且在其他所有函数调用之前调用。\n- `A`：大小为 $N$ 的整数数组。\n- 如果需要进行预处理或设置全局变量，可以在此函数中实现。\n\n```cpp\nstd::array<long long, 2> maximum_average(int i, int j);\n```\n- $0 \\leq i < j \\leq N-1$，且 $A[i], \\cdots, A[j]$ 是一个封闭序列。\n- 该函数应返回 $f(A[i], \\cdots, A[j])=s / t$，其中 $[s, t]$ 是一个数组。\n- $s$ 和 $t$ 是 $1$ 到 $10^{18}$ 之间的整数。可以证明，对于所有满足约束条件的输入，答案总能表示为这种形式的分数。\n- 该函数会被调用 $Q$ 次。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2$ 行：$A[0]\\,A[1]\\,\\cdots \\,A[N-1]$\n- 第 $3$ 行：$Q$\n- 第 $3+k$ $(1 \\leq k \\leq Q)$ 行：$i[k]\\,j[k]$（第 $k$ 次调用 `maximum_average` 函数的参数）", "outputFormat": "示例评测程序输出：\n\n- 第 $k$ 行：第 $k$ 次调用 `maximum_average` 返回的数组中的两个整数\n", "hint": "对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 3\\cdot 10^5$\n- $1 \\leq Q \\leq 6\\cdot 10^5$\n- 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$1 \\leq A[i] \\leq 10^7$\n- 对于所有 `maximum_average` 调用，$0 \\leq i < j \\leq N-1$，且 $A[i], \\cdots, A[j]$ 是一个封闭序列。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $5$ | $N \\leq 15$ |\n| $2$ | $6$ | $N \\leq 50$ |\n| $3$ | $13$ | $N \\leq 250$ |\n| $4$ | $7$ | 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$A[i] \\leq 4$ |\n| $5$ | $12$ | $N \\leq 5000$ |\n| $6$ | $17$ | $A$ 是一个封闭序列；$Q=1$，且调用 `maximum_average(0, N-1)`，即只需计算整个序列 $A$ 的答案 |\n| $7$ | $8$ | 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$A[i] \\leq 20$ |\n| $8$ | $32$ | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2024 R1] 最大化平均值", "background": "**请勿用 C++14 (GCC 9) 提交本题**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include<vector>\n#include<array>\nvoid initialize(std::vector<int> A);\nstd::array<long long, 2> maximum_average(int i, int j);\n```\n\n题目保证时限在标程的十倍以上，交互库代码运行很快。", "description": "**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T1 「[평균 최대화](https://assets.ioikorea.kr/ioitst/2024/1/average/average_statement.pdf)」**\n\n给定一个由正整数组成的长度为 $m$ $(m \\geq 2)$ 的序列 $x[0], \\cdots, x[m-1]$，如果该序列满足以下条件，则称其为**封闭序列**：\n\n- 对于所有 $k$ $(1 \\leq k \\leq m-2)$，$x[k] > x[0]$ 且 $x[k] > x[m-1]$。\n\n也就是说，如果序列 $x$ 的两端元素都小于中间的所有元素，那么 $x$ 就是一个封闭序列。例如，$[3,7,8,4,2]$ 和 $[7,7]$ 是封闭序列，但 $[5,8,4,6,7]$ 和 $[3,3,4]$ 不是封闭序列。注意，长度为 $2$ 的所有序列都是封闭序列，而长度小于等于 $1$ 的序列不是封闭序列。\n\n给定一个长度为 $K$ 的序列 $X[0], \\cdots, X[K-1]$，定义**剔除操作**为选择一个封闭序列 $X[i], \\cdots, X[j]$，并从序列中移除 $X[i+1], \\cdots, X[j-1]$（即将序列变为 $X[0], \\cdots, X[i], X[j], \\cdots, X[K-1]$）。定义 $f(X)$ 为通过任意次数的剔除操作（可以不使用，也可以多次使用）得到的最终序列的最大平均值。\n\n例如，$f([1,3,2,100,97,98,2,3,4,1])=43$，可以通过以下剔除操作实现：\n\n- 选择 $i=0, j=2$，将序列变为 $[1,2,100,97,98,2,3,4,1]$。\n- 选择 $i=5, j=8$，将序列变为 $[1,2,100,97,98,2,1]$。\n- 最终序列为 $[1,2,100,97,98,2,1]$，其平均值为 $(1+2+100+97+98+2+1) / 7=43$。\n\n给定一个由正整数组成的长度为 $N$ 的序列 $A[0], \\cdots, A[N-1]$。对于每个给定的封闭序列 $(i, j)$，你需要计算 $f(A[i], \\cdots, A[j])$ 的值。\n\n你需要实现以下函数：\n\n```cpp\nvoid initialize(std::vector<int> A);\n```\n- 该函数只会被调用一次，并且在其他所有函数调用之前调用。\n- `A`：大小为 $N$ 的整数数组。\n- 如果需要进行预处理或设置全局变量，可以在此函数中实现。\n\n```cpp\nstd::array<long long, 2> maximum_average(int i, int j);\n```\n- $0 \\leq i < j \\leq N-1$，且 $A[i], \\cdots, A[j]$ 是一个封闭序列。\n- 该函数应返回 $f(A[i], \\cdots, A[j])=s / t$，其中 $[s, t]$ 是一个数组。\n- $s$ 和 $t$ 是 $1$ 到 $10^{18}$ 之间的整数。可以证明，对于所有满足约束条件的输入，答案总能表示为这种形式的分数。\n- 该函数会被调用 $Q$ 次。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2$ 行：$A[0]\\,A[1]\\,\\cdots \\,A[N-1]$\n- 第 $3$ 行：$Q$\n- 第 $3+k$ $(1 \\leq k \\leq Q)$ 行：$i[k]\\,j[k]$（第 $k$ 次调用 `maximum_average` 函数的参数）", "outputFormat": "示例评测程序输出：\n\n- 第 $k$ 行：第 $k$ 次调用 `maximum_average` 返回的数组中的两个整数\n", "hint": "对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 3\\cdot 10^5$\n- $1 \\leq Q \\leq 6\\cdot 10^5$\n- 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$1 \\leq A[i] \\leq 10^7$\n- 对于所有 `maximum_average` 调用，$0 \\leq i < j \\leq N-1$，且 $A[i], \\cdots, A[j]$ 是一个封闭序列。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $5$ | $N \\leq 15$ |\n| $2$ | $6$ | $N \\leq 50$ |\n| $3$ | $13$ | $N \\leq 250$ |\n| $4$ | $7$ | 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$A[i] \\leq 4$ |\n| $5$ | $12$ | $N \\leq 5000$ |\n| $6$ | $17$ | $A$ 是一个封闭序列；$Q=1$，且调用 `maximum_average(0, N-1)`，即只需计算整个序列 $A$ 的答案 |\n| $7$ | $8$ | 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$A[i] \\leq 20$ |\n| $8$ | $32$ | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P11236", "type": "P", "difficulty": 7, "samples": [["5\n2 1 1 3 4\n5\n1 0 4\n2 2 3\n1 2 4\n2 1 2\n1 0 2", "5\n5\n4"], ["7\n1 1 1 1 2 2 2\n5\n1 0 6\n1 2 4\n2 6 4\n1 4 6\n1 0 6", "4\n3\n4\n5"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2024", "交互题", "KOI（韩国）"], "title": "[KTSC 2024 R1] 水果游戏", "background": "**请勿用 C++14 (GCC 9) 提交**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include<vector>\nvoid prepare_game(std::vector<int> A);\nint play_game(int l, int r);\nvoid update_game(int p, int v);\n```", "description": "**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T2 「[과일 게임](https://assets.ioikorea.kr/ioitst/2024/1/fruitgame/fruitgame_statement.pdf)」**\n\n水果游戏是一款将各种水果合并成更大水果的游戏。游戏板可以表示为一个序列 $X[0], X[1], \\cdots, X[K-1]$，其中每个数字代表一种水果的编号，编号越大，水果越大。\n\n玩家可以执行合并操作，将相邻且相同的两个水果合并成更大的水果。合并操作定义如下：\n\n合并：在表示为 $X[0], X[1], \\cdots, X[K-1]$ 的游戏板上，选择一个整数 $0 \\leq i \\leq K-2$，如果 $X[i]=X[i+1]$，则将游戏板变为 $X[0], \\cdots, X[i-1], X[i]+1, X[i+2], \\cdots, X[K-1]$。\n\n玩家的目标是，在给定初始游戏板的情况下，通过 $0$ 次或多次合并操作，尽可能生成更大的水果。\n\n例如，游戏板 $X=[2,1,1,3,2]$，因为 $X[1]=X[2]$，选择 $i=1$ 进行合并操作，游戏板变为 $X=[2,2,3,2]$。然后，因为 $X[0]=X[1]$，选择 $i=0$ 进行合并操作，游戏板变为 $X=[3,3,2]$。最后，因为 $X[0]=X[1]$，选择 $i=0$ 进行合并操作，游戏板变为 $X=[4,2]$。这样可以得到编号为 $4$ 的水果，这是可以得到的最大水果编号。\n\n给定一个长度为 $N$ 的序列 $A$，序列中的元素可以在中途发生变化，并且这些变化是累积的。每当给定一个满足 $0 \\leq l \\leq r \\leq N-1$ 的整数对 $(l, r)$ 时，你需要计算由 $A[l], \\cdots, A[r]$ 表示的游戏板上可以得到的最大水果编号。序列的元素变化或给定的整数对的次数总共为 $Q$ 次。\n\n你需要实现以下函数：\n\n```cpp\nvoid prepare_game(std::vector<int> A);\n```\n- `A`：大小为 $N$ 的整数数组。\n- 该函数只会被调用一次，并且在其他所有函数调用之前调用。\n- 如果需要进行预处理或设置全局变量，可以在此函数中实现。\n\n```cpp\nint play_game(int l, int r);\n```\n- 该函数应返回由 $A[l], \\cdots, A[r]$ 组成的游戏板上可以得到的最大水果编号。\n- 该函数会被调用多次。\n\n```cpp\nvoid update_game(int p, int v);\n```\n- 该函数应将 $A[p]$ 的值更改为 $v$。\n- `play_game` 函数或 `update_game` 函数的调用次数总共为 $Q$ 次。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2$ 行：$A[0]\\,A[1]\\,\\cdots\\,A[N-1]$\n- 第 $3$ 行：$Q$\n- 第 $3+i$ $(1 \\leq i \\leq Q)$ 行：如果调用 `play_game` 函数，则为 `1 l r`；如果调用 `update_game` 函数，则为 `2 p v`", "outputFormat": "示例评测程序输出：\n\n- 第 $i$ 行：第 $i$ 次调用 `play_game` 函数返回的值", "hint": "对于所有输入数据，满足：\n\n- $1 \\leq N, Q \\leq 10^5$\n- 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$1 \\leq A[i] \\leq 10$\n- 对于所有 `play_game` 调用，$0 \\leq l \\leq r \\leq N-1$\n- 对于所有 `update_game` 调用，$0 \\leq p \\leq N-1, 1 \\leq v \\leq 10$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $5$ | $N \\leq 10,Q \\leq 10$ |\n| $2$ | $6$ | $N \\leq 600,Q \\leq 600$ |\n| $3$ | $8$ | $N \\leq 4000,Q \\leq 4000$；对于所有 $i$ $(0 \\leq i \\leq N-1)$，$A[i] \\leq 2$；对于所有 `update_game` 调用，$v \\leq 2$ |\n| $4$ | $15$ | $N \\leq 4000,Q \\leq 4000$ |\n| $5$ | $12$ | 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$A[i] \\leq 2$；对于所有 `update_game` 调用，$v \\leq 2$ |\n| $6$ | $14$ | 不会调用 `update_game` |\n| $7$ | $40$ | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2024 R1] 水果游戏", "background": "**请勿用 C++14 (GCC 9) 提交**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include<vector>\nvoid prepare_game(std::vector<int> A);\nint play_game(int l, int r);\nvoid update_game(int p, int v);\n```", "description": "**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T2 「[과일 게임](https://assets.ioikorea.kr/ioitst/2024/1/fruitgame/fruitgame_statement.pdf)」**\n\n水果游戏是一款将各种水果合并成更大水果的游戏。游戏板可以表示为一个序列 $X[0], X[1], \\cdots, X[K-1]$，其中每个数字代表一种水果的编号，编号越大，水果越大。\n\n玩家可以执行合并操作，将相邻且相同的两个水果合并成更大的水果。合并操作定义如下：\n\n合并：在表示为 $X[0], X[1], \\cdots, X[K-1]$ 的游戏板上，选择一个整数 $0 \\leq i \\leq K-2$，如果 $X[i]=X[i+1]$，则将游戏板变为 $X[0], \\cdots, X[i-1], X[i]+1, X[i+2], \\cdots, X[K-1]$。\n\n玩家的目标是，在给定初始游戏板的情况下，通过 $0$ 次或多次合并操作，尽可能生成更大的水果。\n\n例如，游戏板 $X=[2,1,1,3,2]$，因为 $X[1]=X[2]$，选择 $i=1$ 进行合并操作，游戏板变为 $X=[2,2,3,2]$。然后，因为 $X[0]=X[1]$，选择 $i=0$ 进行合并操作，游戏板变为 $X=[3,3,2]$。最后，因为 $X[0]=X[1]$，选择 $i=0$ 进行合并操作，游戏板变为 $X=[4,2]$。这样可以得到编号为 $4$ 的水果，这是可以得到的最大水果编号。\n\n给定一个长度为 $N$ 的序列 $A$，序列中的元素可以在中途发生变化，并且这些变化是累积的。每当给定一个满足 $0 \\leq l \\leq r \\leq N-1$ 的整数对 $(l, r)$ 时，你需要计算由 $A[l], \\cdots, A[r]$ 表示的游戏板上可以得到的最大水果编号。序列的元素变化或给定的整数对的次数总共为 $Q$ 次。\n\n你需要实现以下函数：\n\n```cpp\nvoid prepare_game(std::vector<int> A);\n```\n- `A`：大小为 $N$ 的整数数组。\n- 该函数只会被调用一次，并且在其他所有函数调用之前调用。\n- 如果需要进行预处理或设置全局变量，可以在此函数中实现。\n\n```cpp\nint play_game(int l, int r);\n```\n- 该函数应返回由 $A[l], \\cdots, A[r]$ 组成的游戏板上可以得到的最大水果编号。\n- 该函数会被调用多次。\n\n```cpp\nvoid update_game(int p, int v);\n```\n- 该函数应将 $A[p]$ 的值更改为 $v$。\n- `play_game` 函数或 `update_game` 函数的调用次数总共为 $Q$ 次。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2$ 行：$A[0]\\,A[1]\\,\\cdots\\,A[N-1]$\n- 第 $3$ 行：$Q$\n- 第 $3+i$ $(1 \\leq i \\leq Q)$ 行：如果调用 `play_game` 函数，则为 `1 l r`；如果调用 `update_game` 函数，则为 `2 p v`", "outputFormat": "示例评测程序输出：\n\n- 第 $i$ 行：第 $i$ 次调用 `play_game` 函数返回的值", "hint": "对于所有输入数据，满足：\n\n- $1 \\leq N, Q \\leq 10^5$\n- 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$1 \\leq A[i] \\leq 10$\n- 对于所有 `play_game` 调用，$0 \\leq l \\leq r \\leq N-1$\n- 对于所有 `update_game` 调用，$0 \\leq p \\leq N-1, 1 \\leq v \\leq 10$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $5$ | $N \\leq 10,Q \\leq 10$ |\n| $2$ | $6$ | $N \\leq 600,Q \\leq 600$ |\n| $3$ | $8$ | $N \\leq 4000,Q \\leq 4000$；对于所有 $i$ $(0 \\leq i \\leq N-1)$，$A[i] \\leq 2$；对于所有 `update_game` 调用，$v \\leq 2$ |\n| $4$ | $15$ | $N \\leq 4000,Q \\leq 4000$ |\n| $5$ | $12$ | 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$A[i] \\leq 2$；对于所有 `update_game` 调用，$v \\leq 2$ |\n| $6$ | $14$ | 不会调用 `update_game` |\n| $7$ | $40$ | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P11237", "type": "P", "difficulty": 6, "samples": [["4 3\n0 1 557912\n0 2 517656\n0 3 275807\n3 265381 0 1000000\n0 190435 2 12345\n0 195025 3 67890", "833719 265381\n517656 190435\n275807 195025"], ["6 4\n0 1 2\n1 2 2\n2 3 10\n1 4 8\n2 5 16\n3 4 0 3\n3 2 0 1\n3 19 0 9\n3 20 0 19", "6 1\n10 1\n1 1\n13 10"], ["10 10\n4 9 7\n2 8 8\n9 0 4\n9 1 5\n3 1 1\n7 6 2\n1 2 5\n6 2 10\n5 9 2\n3 1 5 9\n0 6 5 7\n5 6 9 6\n2 5 1 7\n0 2 6 4\n5 6 2 10\n5 5 0 10\n7 4 1 8\n9 1 8 7\n8 5 4 5", "18 1\n13 3\n4 1\n17 5\n13 1\n4 1\n6 5\n29 4\n22 1\n5 1"], ["10 10\n6 7 1\n8 5 1\n8 2 4\n3 9 4\n4 1 4\n9 7 7\n0 4 3\n1 3 4\n8 4 7\n3 5 0 2\n1 7 7 2\n6 9 8 5\n2 7 0 5\n3 5 2 4\n3 10 0 5\n2 8 0 7\n6 8 7 2\n1 4 8 2\n2 8 5 7", "11 5\n16 7\n31 9\n4 1\n19 5\n11 10\n31 8\n1 6\n15 4\n3 1"]], "limits": {"time": [1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200, 1200], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["二分", "2024", "交互题", "Special Judge", "树链剖分", "KOI（韩国）"], "title": "[KTSC 2024 R1] 警察与小偷", "background": "**请勿使用 C++14 (GCC 9) 提交**。\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include<vector>\n#include<array>\nstd::vector<std::array<long long, 2>> police_thief(std::vector<int> A, std::vector<int> B, std::vector<int> D, std::vector<int> P, std::vector<int> V1, std::vector<int> T, std::vector<int> V2);\n```", "description": "**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T3 「[경찰과 도둑](https://assets.ioikorea.kr/ioitst/2024/1/police/police_statement.pdf)」**\n\nKOI 村由 $N$ 座房子和连接这些房子的 $N-1$ 条双向道路组成。任意两座不同的房子都可以通过这些道路互相到达。也就是说，KOI 村的道路网络是一个树结构。\n\nKOI 村的房子编号从 $0$ 到 $N-1$，道路编号从 $0$ 到 $N-2$。对于编号为 $i$ 的道路，它连接了编号为 $A[i]$ 和 $B[i]$ 的房子，长度为 $D[i]$ 米。\n\n最近，KOI 村频繁发生盗窃事件，村民们非常困扰。为了应对这种情况，村里决定在某个房子里安排警察待命，以便在小偷出现时迅速抓捕。村民们想知道在不同情况下，警察需要多长时间才能抓住小偷。\n\n你将会得到 $Q$ 个场景，每个场景编号从 $0$ 到 $Q-1$。每个场景如下：\n\n- 在第 $j$ 个场景中，警察从编号为 $P[j]$ 的房子出发，最大速度为 $V1[j]$ 米/秒。\n- 在第 $j$ 个场景中，小偷从编号为 $T[j]$ 的房子出发，最大速度为 $V2[j]$ 米/秒。\n- 警察和小偷出发的房子不同，即 $P[j] \\neq T[j]$。\n- 房子的大小可以忽略不计，因此可以将房子视为一个点。道路的宽度也可以忽略不计，因此可以将道路视为一条线段。道路之间不相交。\n- 警察和小偷可以在 KOI 村内自由移动，速度不超过各自的最大速度。可以选择不移动。\n- 如果警察和小偷在同一个位置，警察就能抓住小偷。这个位置可以是房子，也可以是道路的中间。\n- 在每个场景中，警察和小偷都知道对方的速度，并且随时知道对方的位置。\n- 警察和小偷都会采用最优策略。警察会尽快抓住小偷，而小偷会尽量拖延被抓住的时间。可以证明，在最优策略下，小偷一定会在有限时间内被抓住。\n\n你需要计算每个场景中，小偷被抓住所需的时间。\n\n你需要实现以下函数：\n\n```cpp\nstd::vector<std::array<long long, 2>> police_thief(std::vector<int> A, std::vector<int> B, std::vector<int> D, std::vector<int> P, std::vector<int> V1, std::vector<int> T, std::vector<int> V2);\n```\n\n- `A, B, D`：大小为 $N-1$ 的整数数组。对于每条编号为 $i$ 的道路，它连接了编号为 $A[i]$ 和 $B[i]$ 的房子，长度为 $D[i]$ 米。\n- `P, V1, T, V2`：大小为 $Q$ 的整数数组。对于第 $j$ 个场景，警察从编号为 $P[j]$ 的房子出发，最大速度为 $V1[j]$ 米/秒，小偷从编号为 $T[j]$ 的房子出发，最大速度为 $V2[j]$ 米/秒。\n- 该函数返回一个大小为 $Q$ 的数组 $C$，每个元素是一个大小为 $2$ 的数组。对于第 $j$ 个场景，小偷被抓住所需的时间（以秒为单位）表示为分数 $C[j][0] / C[j][1]$。\n- $C[j][0] / C[j][1]$ 可以不是最简分数，但 $C[j][0]$ 和 $C[j][1]$ 必须是 $1$ 到 $10^{18}$ 之间的整数。可以证明，对于所有满足约束条件的输入，答案总能表示为这种形式的分数。\n\n注意，提交的代码中不应包含任何输入输出操作。\n", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,Q$\n- 第 $2+i$ $(0 \\leq i \\leq N-2)$ 行：$A[i]\\,B[i]\\,D[i]$\n- 第 $1+N+j$ $(0 \\leq j \\leq Q-1)$ 行：$P[j]\\,V1[j]\\,T[j]\\,V2[j]$", "outputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,Q$\n- 第 $2+i$ $(0 \\leq i \\leq N-2)$ 行：$A[i]\\,B[i]\\,D[i]$\n- 第 $1+N+j$ $(0 \\leq j \\leq Q-1)$ 行：$P[j]\\,V1[j]\\,T[j]\\,V2[j]$\n\n假设 `police_thief` 返回的数组为 $C$。示例评测程序将输出：\n\n- 第 $1+j$ $(0 \\leq j \\leq Q-1)$ 行：$C[j][0]\\,C[j][1]$\n", "hint": "对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 10^5$\n- $1 \\leq Q \\leq 10^5$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$0 \\leq A[i], B[i] \\leq N-1$ 且 $A[i] \\neq B[i]$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$1 \\leq D[i] \\leq 10^6$\n- KOI 村是一棵树的结构\n- 对于所有 $j$ $(0 \\leq j \\leq Q-1)$，$0 \\leq P[j], T[j] \\leq N-1$ 且 $P[j] \\neq T[j]$\n- 对于所有 $j$ $(0 \\leq j \\leq Q-1)$，$1 \\leq V1[j], V2[j] \\leq 10^6$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $15$ | $N \\leq 5000, Q \\leq 5000$ |\n| $2$ | $21$ | $N \\leq 50000,Q \\leq 50000$ |\n| $3$ | $5$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$A[i]=i, B[i]=i+1$ |\n| $4$ | $6$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$A[i]=0, B[i]=i+1$ |\n| $5$ | $14$ | 对于所有 $j$ $(0 \\leq j \\leq Q-1)$，$V1[j] \\leq V2[j]$ |\n| $6$ | $9$ | 对于所有 $j$ $(0 \\leq j \\leq Q-1)$，$P[j]$ 和 $T[j]$ 之间的道路数量不超过 $10$ 条 |\n| $7$ | $9$ | 对于所有 $j$ $(0 \\leq j \\leq Q-1)$，$P[j]=0$ |\n| $8$ | $10$ | 对于所有 $j$ $(0 \\leq j \\leq Q-1)$，$T[j]=0$ |\n| $9$ | $11$ | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2024 R1] 警察与小偷", "background": "**请勿使用 C++14 (GCC 9) 提交**。\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include<vector>\n#include<array>\nstd::vector<std::array<long long, 2>> police_thief(std::vector<int> A, std::vector<int> B, std::vector<int> D, std::vector<int> P, std::vector<int> V1, std::vector<int> T, std::vector<int> V2);\n```", "description": "**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T3 「[경찰과 도둑](https://assets.ioikorea.kr/ioitst/2024/1/police/police_statement.pdf)」**\n\nKOI 村由 $N$ 座房子和连接这些房子的 $N-1$ 条双向道路组成。任意两座不同的房子都可以通过这些道路互相到达。也就是说，KOI 村的道路网络是一个树结构。\n\nKOI 村的房子编号从 $0$ 到 $N-1$，道路编号从 $0$ 到 $N-2$。对于编号为 $i$ 的道路，它连接了编号为 $A[i]$ 和 $B[i]$ 的房子，长度为 $D[i]$ 米。\n\n最近，KOI 村频繁发生盗窃事件，村民们非常困扰。为了应对这种情况，村里决定在某个房子里安排警察待命，以便在小偷出现时迅速抓捕。村民们想知道在不同情况下，警察需要多长时间才能抓住小偷。\n\n你将会得到 $Q$ 个场景，每个场景编号从 $0$ 到 $Q-1$。每个场景如下：\n\n- 在第 $j$ 个场景中，警察从编号为 $P[j]$ 的房子出发，最大速度为 $V1[j]$ 米/秒。\n- 在第 $j$ 个场景中，小偷从编号为 $T[j]$ 的房子出发，最大速度为 $V2[j]$ 米/秒。\n- 警察和小偷出发的房子不同，即 $P[j] \\neq T[j]$。\n- 房子的大小可以忽略不计，因此可以将房子视为一个点。道路的宽度也可以忽略不计，因此可以将道路视为一条线段。道路之间不相交。\n- 警察和小偷可以在 KOI 村内自由移动，速度不超过各自的最大速度。可以选择不移动。\n- 如果警察和小偷在同一个位置，警察就能抓住小偷。这个位置可以是房子，也可以是道路的中间。\n- 在每个场景中，警察和小偷都知道对方的速度，并且随时知道对方的位置。\n- 警察和小偷都会采用最优策略。警察会尽快抓住小偷，而小偷会尽量拖延被抓住的时间。可以证明，在最优策略下，小偷一定会在有限时间内被抓住。\n\n你需要计算每个场景中，小偷被抓住所需的时间。\n\n你需要实现以下函数：\n\n```cpp\nstd::vector<std::array<long long, 2>> police_thief(std::vector<int> A, std::vector<int> B, std::vector<int> D, std::vector<int> P, std::vector<int> V1, std::vector<int> T, std::vector<int> V2);\n```\n\n- `A, B, D`：大小为 $N-1$ 的整数数组。对于每条编号为 $i$ 的道路，它连接了编号为 $A[i]$ 和 $B[i]$ 的房子，长度为 $D[i]$ 米。\n- `P, V1, T, V2`：大小为 $Q$ 的整数数组。对于第 $j$ 个场景，警察从编号为 $P[j]$ 的房子出发，最大速度为 $V1[j]$ 米/秒，小偷从编号为 $T[j]$ 的房子出发，最大速度为 $V2[j]$ 米/秒。\n- 该函数返回一个大小为 $Q$ 的数组 $C$，每个元素是一个大小为 $2$ 的数组。对于第 $j$ 个场景，小偷被抓住所需的时间（以秒为单位）表示为分数 $C[j][0] / C[j][1]$。\n- $C[j][0] / C[j][1]$ 可以不是最简分数，但 $C[j][0]$ 和 $C[j][1]$ 必须是 $1$ 到 $10^{18}$ 之间的整数。可以证明，对于所有满足约束条件的输入，答案总能表示为这种形式的分数。\n\n注意，提交的代码中不应包含任何输入输出操作。\n", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,Q$\n- 第 $2+i$ $(0 \\leq i \\leq N-2)$ 行：$A[i]\\,B[i]\\,D[i]$\n- 第 $1+N+j$ $(0 \\leq j \\leq Q-1)$ 行：$P[j]\\,V1[j]\\,T[j]\\,V2[j]$", "outputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,Q$\n- 第 $2+i$ $(0 \\leq i \\leq N-2)$ 行：$A[i]\\,B[i]\\,D[i]$\n- 第 $1+N+j$ $(0 \\leq j \\leq Q-1)$ 行：$P[j]\\,V1[j]\\,T[j]\\,V2[j]$\n\n假设 `police_thief` 返回的数组为 $C$。示例评测程序将输出：\n\n- 第 $1+j$ $(0 \\leq j \\leq Q-1)$ 行：$C[j][0]\\,C[j][1]$\n", "hint": "对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 10^5$\n- $1 \\leq Q \\leq 10^5$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$0 \\leq A[i], B[i] \\leq N-1$ 且 $A[i] \\neq B[i]$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$1 \\leq D[i] \\leq 10^6$\n- KOI 村是一棵树的结构\n- 对于所有 $j$ $(0 \\leq j \\leq Q-1)$，$0 \\leq P[j], T[j] \\leq N-1$ 且 $P[j] \\neq T[j]$\n- 对于所有 $j$ $(0 \\leq j \\leq Q-1)$，$1 \\leq V1[j], V2[j] \\leq 10^6$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $15$ | $N \\leq 5000, Q \\leq 5000$ |\n| $2$ | $21$ | $N \\leq 50000,Q \\leq 50000$ |\n| $3$ | $5$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$A[i]=i, B[i]=i+1$ |\n| $4$ | $6$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$A[i]=0, B[i]=i+1$ |\n| $5$ | $14$ | 对于所有 $j$ $(0 \\leq j \\leq Q-1)$，$V1[j] \\leq V2[j]$ |\n| $6$ | $9$ | 对于所有 $j$ $(0 \\leq j \\leq Q-1)$，$P[j]$ 和 $T[j]$ 之间的道路数量不超过 $10$ 条 |\n| $7$ | $9$ | 对于所有 $j$ $(0 \\leq j \\leq Q-1)$，$P[j]=0$ |\n| $8$ | $10$ | 对于所有 $j$ $(0 \\leq j \\leq Q-1)$，$T[j]=0$ |\n| $9$ | $11$ | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P11238", "type": "P", "difficulty": 5, "samples": [["5\n0 1 1\n1 2 2 \n0 3 3\n0 4 2", "80"], ["5 \n0 1 3 \n0 2 2\n0 3 2\n0 4 1", "78"], ["6 \n0 1 3 \n1 2 1\n2 3 4\n3 4 1\n4 5 5", "284"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2024", "交互题", "树的直径", "KOI（韩国）"], "title": "[KTSC 2024 R1] 铁路 2", "background": "**请勿用 C++14 (GCC 9) 提交。**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include<vector>\nint travel(std::vector<int> U, std::vector<int> V, std::vector<int> W);\n```", "description": "**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T4 「[철도 2](https://assets.ioikorea.kr/ioitst/2024/1/railroad2/railroad2_statement.pdf)」**\n\nIOI 国有 $N$ 个城市和连接这些城市的 $N-1$ 条双向铁路，任意两个不同的城市都可以通过铁路互相到达。也就是说，IOI 国的铁路网络是一个树结构。城市编号从 $0$ 到 $N-1$，铁路编号从 $0$ 到 $N-2$。对于每条编号为 $i$ 的铁路，它连接了编号为 $U[i]$ 和 $V[i]$ 的城市，长度为 $W[i]$。\n\n在 IOI 国的任何一个城市出发，都可以乘坐直达列车直接到达另一个城市。也就是说，对于所有 $u,v$ $(0 \\leq u, v \\leq N-1, u \\neq v)$ 的 $N(N-1)$ 个城市对 $(u, v)$，从 $u$ 城市出发到达 $v$ 城市的直达列车存在。乘坐这趟直达列车时，直到到达 $v$ 城市之前不能下车，这趟列车的耗时等于 IOI 国铁路网络中从 $u$ 城市到 $v$ 城市的唯一简单路径上所有铁路的长度之和。\n\n作为铁路爱好者，你喜欢长时间乘坐一列火车，享受悠闲的时光。因此，乘坐耗时长的直达列车会让你感到更大的乐趣。\n\n具体来说，对于两个不同的城市 $x, y$，乐趣 $\\operatorname{joy}(x, y)$ 定义为满足以下条件的最大正整数 $D$：\n\n- 从 $x$ 城市出发，乘坐耗时至少为 $D$ 的直达列车，经过有限次后到达 $y$ 城市。\n\n你需要编写一个程序，计算满足 $0 \\leq x, y \\leq N-1, x \\neq y$ 的所有 $N(N-1)$ 个城市对 $(x, y)$ 的 $\\operatorname{joy}(x, y)$ 之和，并对 $1000000007\\left(=10^{9}+7\\right)$ 取模。\n\n你需要实现以下函数：\n\n```cpp\nint travel(std::vector<int> U, std::vector<int> V, std::vector<int> W);\n```\n\n- 该函数只会被调用一次。\n- `U, V, W`：大小为 $N-1$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq N-2)$，存在一条连接 $U[i]$ 和 $V[i]$ 的长度为 $W[i]$ 的铁路。\n- 该函数需要返回满足 $0 \\leq x, y \\leq N-1, x \\neq y$ 的所有 $N(N-1)$ 个城市对 $(x, y)$ 的 $\\operatorname{joy}(x, y)$ 之和，并对 $1000000007\\left(=10^{9}+7\\right)$ 取模。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2+i$ $(0 \\leq i \\leq N-2)$ 行：$U[i]\\,V[i]\\,W[i]$", "outputFormat": "示例评测程序将输出：\n\n- 第 $1$ 行：`travel` 函数返回的值", "hint": "对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 5\\cdot 10^5$\n- IOI 国的铁路网络是一个树结构\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$0 \\leq U[i], V[i] \\leq N-1 ; U[i] \\neq V[i]$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$1 \\leq W[i] \\leq 10^9$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $3$ | $N \\leq 50$ |\n| $2$ | $6$ | $N \\leq 500$ |\n| $3$ | $19$ | $N \\leq 2000$ |\n| $4$ | $5$ | $N \\leq 8000$；<br>对于所有 $i$ $(0 \\leq i \\leq N-2)$，$U[i]=0$ |\n| $5$ | $7$ | $N \\leq 8000$；<br>对于所有 $i$ $(0 \\leq i \\leq N-2)$，$U[i]=i, V[i]=i+1$ |\n| $6$ | $15$ | $N \\leq 8000$ |\n| $7$ | $4$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$U[i]=0$ |\n| $8$ | $11$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$U[i]=i ; V[i]=i+1$ |\n| $9$ | $30$ | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2024 R1] 铁路 2", "background": "**请勿用 C++14 (GCC 9) 提交。**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include<vector>\nint travel(std::vector<int> U, std::vector<int> V, std::vector<int> W);\n```", "description": "**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T4 「[철도 2](https://assets.ioikorea.kr/ioitst/2024/1/railroad2/railroad2_statement.pdf)」**\n\nIOI 国有 $N$ 个城市和连接这些城市的 $N-1$ 条双向铁路，任意两个不同的城市都可以通过铁路互相到达。也就是说，IOI 国的铁路网络是一个树结构。城市编号从 $0$ 到 $N-1$，铁路编号从 $0$ 到 $N-2$。对于每条编号为 $i$ 的铁路，它连接了编号为 $U[i]$ 和 $V[i]$ 的城市，长度为 $W[i]$。\n\n在 IOI 国的任何一个城市出发，都可以乘坐直达列车直接到达另一个城市。也就是说，对于所有 $u,v$ $(0 \\leq u, v \\leq N-1, u \\neq v)$ 的 $N(N-1)$ 个城市对 $(u, v)$，从 $u$ 城市出发到达 $v$ 城市的直达列车存在。乘坐这趟直达列车时，直到到达 $v$ 城市之前不能下车，这趟列车的耗时等于 IOI 国铁路网络中从 $u$ 城市到 $v$ 城市的唯一简单路径上所有铁路的长度之和。\n\n作为铁路爱好者，你喜欢长时间乘坐一列火车，享受悠闲的时光。因此，乘坐耗时长的直达列车会让你感到更大的乐趣。\n\n具体来说，对于两个不同的城市 $x, y$，乐趣 $\\operatorname{joy}(x, y)$ 定义为满足以下条件的最大正整数 $D$：\n\n- 从 $x$ 城市出发，乘坐耗时至少为 $D$ 的直达列车，经过有限次后到达 $y$ 城市。\n\n你需要编写一个程序，计算满足 $0 \\leq x, y \\leq N-1, x \\neq y$ 的所有 $N(N-1)$ 个城市对 $(x, y)$ 的 $\\operatorname{joy}(x, y)$ 之和，并对 $1000000007\\left(=10^{9}+7\\right)$ 取模。\n\n你需要实现以下函数：\n\n```cpp\nint travel(std::vector<int> U, std::vector<int> V, std::vector<int> W);\n```\n\n- 该函数只会被调用一次。\n- `U, V, W`：大小为 $N-1$ 的整数数组。对于每个 $i$ $(0 \\leq i \\leq N-2)$，存在一条连接 $U[i]$ 和 $V[i]$ 的长度为 $W[i]$ 的铁路。\n- 该函数需要返回满足 $0 \\leq x, y \\leq N-1, x \\neq y$ 的所有 $N(N-1)$ 个城市对 $(x, y)$ 的 $\\operatorname{joy}(x, y)$ 之和，并对 $1000000007\\left(=10^{9}+7\\right)$ 取模。\n\n注意，提交的代码中不应包含任何输入输出操作。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2+i$ $(0 \\leq i \\leq N-2)$ 行：$U[i]\\,V[i]\\,W[i]$", "outputFormat": "示例评测程序将输出：\n\n- 第 $1$ 行：`travel` 函数返回的值", "hint": "对于所有输入数据，满足：\n\n- $2 \\leq N \\leq 5\\cdot 10^5$\n- IOI 国的铁路网络是一个树结构\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$0 \\leq U[i], V[i] \\leq N-1 ; U[i] \\neq V[i]$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$1 \\leq W[i] \\leq 10^9$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $3$ | $N \\leq 50$ |\n| $2$ | $6$ | $N \\leq 500$ |\n| $3$ | $19$ | $N \\leq 2000$ |\n| $4$ | $5$ | $N \\leq 8000$；<br>对于所有 $i$ $(0 \\leq i \\leq N-2)$，$U[i]=0$ |\n| $5$ | $7$ | $N \\leq 8000$；<br>对于所有 $i$ $(0 \\leq i \\leq N-2)$，$U[i]=i, V[i]=i+1$ |\n| $6$ | $15$ | $N \\leq 8000$ |\n| $7$ | $4$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$U[i]=0$ |\n| $8$ | $11$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$U[i]=i ; V[i]=i+1$ |\n| $9$ | $30$ | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P11239", "type": "P", "difficulty": 7, "samples": [["3 5 2\n0 2\n0 2\n1 1\n1 1\n1 1", "5"], ["250 8 50\n0 200\n40 140\n49 49\n50 150\n100 190\n149 199\n199 199\n75 249", "17"], ["250 8 49\n0 200\n40 140\n49 49\n50 150\n100 190\n149 199\n199 199\n75 249", "19"], ["100 6 50\n0 99\n0 70\n0 10\n20 30\n40 50\n60 70", "6"], ["1000000000000 2 1\n0 999999999999\n0 999999999999", "2000000000000"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["贪心", "线段树", "2024", "离散化", "交互题", "动态规划优化", "KOI（韩国）"], "title": "[KTSC 2024 R2] 跳跃游戏", "background": "**请使用 C++17 或 C++20 提交**\n\n你需要在程序开头加入如下代码：\n```cpp\n#include<vector>\nlong long play_game(long long N, int Q, long long K, std::vector<long long> L, std::vector<long long> R);\n```", "description": "**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T2 「[점프 게임](https://assets.ioikorea.kr/ioitst/2024/2/jumpgame/jumpgame_statement.pdf)」**\n\nKOI 公司推出的跳跃游戏是一款通过多次跳跃穿越 $N$ 个踏板的游戏。具体来说，游戏中有 $N$ 个踏板按顺序排列在一条直线上，每个踏板从左到右依次编号为 $0, 1, \\ldots, N-1$。游戏开始时，主角站在最左边的 $0$ 号踏板上，初始得分为 $0$。\n\n对于每个 $i$ $(0 \\leq i \\leq N-1)$，主角可以选择走一步或跳跃。如果选择走一步，主角将移动到 $i+1$ 号踏板，得分不变。如果选择跳跃，主角将移动到 $i+K$ 号踏板，得分增加 $A[i]$。其中 $K$ 是预先设定的常数。游戏在主角到达 $N-1$ 号踏板的右侧时成功结束。也就是说，主角到达编号为 $N, N+1, \\ldots$ 的踏板时，游戏结束——这些编号大于等于 $N$ 的踏板实际上不存在，但表示主角已经越过了 $N-1$ 号踏板。游戏的目标是通过合理控制主角的行动，使得分最大化并成功结束游戏。\n\n喜欢网络直播的尚赫偶尔会玩 KOI 公司的跳跃游戏。虽然他自己玩得很开心，但观众们却反应平平。跳跃游戏不受欢迎的原因在于游戏非常困难且枯燥。首先，这款游戏的踏板数量可以多达 $10^{12}$ 个。其次，即使是 KOI 公司的优秀开发者也无法设计出如此多的踏板，因此他们采用了一种相对简单的方法来生成每个踏板。开发者们最初将所有 $A[i]$ 设置为 $0$，然后进行 $Q$ 次操作：对于每个 $j$ $(0 \\leq j \\leq Q-1)$，他们选择一个区间 $0 \\leq L[j] \\leq R[j] \\leq N-1$，将 $A[L[j]], A[L[j]+1], A[L[j]+2], \\ldots, A[R[j]]$ 的值增加 $1$。所有操作完成后的数组 $A$ 就是游戏中每个踏板跳跃时获得的得分。\n\n你是一名制作计算机科学视频的创作者，决定制作一个关于如何以最高得分完成 KOI 公司的跳跃游戏的视频。你认为这个视频会在尚赫的观众中大受欢迎，但你担心游戏规模太大，难以找到高效的算法。克服所有困难，在给定的 5 小时内成为这款游戏的高手吧！\n\n你需要实现以下函数：\n\n```cpp\nlong long play_game(long long N, int Q, long long K, std::vector<long long> L, std::vector<long long> R);\n```\n\n- `N`：游戏中存在的踏板数量。\n- `Q`：开发者执行的操作次数。\n- `K`：跳跃后到达的下一个踏板的编号。\n- `L, R`：大小为 $Q$ 的整数数组。\n- 该函数返回一个整数，表示跳跃游戏结束时可以获得的最高得分。\n- 该函数在每个测试点中只会被调用一次。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,Q\\,K$\n- 第 $2+i$ $(0 \\leq i \\leq Q-1)$ 行：$L[i]\\,R[i]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $1$ 行：`play_game` 返回的值", "hint": "对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 10^{12}$\n- $1 \\leq Q \\leq 2.5\\cdot 10^5$\n- $1 \\leq K \\leq N$\n- 对于所有 $j$ $(0 \\leq j \\leq Q-1)$，$0 \\leq L[j] \\leq R[j] \\leq N-1$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $6$ | $N \\leq 2.5\\cdot 10^5$ |\n| $2$ | $2$ | $K=1$ |\n| $3$ | $13$ | $2 K \\geq N$|\n| $4$ | $15$ | $5 K \\geq N$ |\n| $5$ | $16$ | $Q \\leq 500$ |\n| $6$ | $7$ | $Q \\leq 5000$ |\n| $7$ | $41$ | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2024 R2] 跳跃游戏", "background": "**请使用 C++17 或 C++20 提交**\n\n你需要在程序开头加入如下代码：\n```cpp\n#include<vector>\nlong long play_game(long long N, int Q, long long K, std::vector<long long> L, std::vector<long long> R);\n```", "description": "**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T2 「[점프 게임](https://assets.ioikorea.kr/ioitst/2024/2/jumpgame/jumpgame_statement.pdf)」**\n\nKOI 公司推出的跳跃游戏是一款通过多次跳跃穿越 $N$ 个踏板的游戏。具体来说，游戏中有 $N$ 个踏板按顺序排列在一条直线上，每个踏板从左到右依次编号为 $0, 1, \\ldots, N-1$。游戏开始时，主角站在最左边的 $0$ 号踏板上，初始得分为 $0$。\n\n对于每个 $i$ $(0 \\leq i \\leq N-1)$，主角可以选择走一步或跳跃。如果选择走一步，主角将移动到 $i+1$ 号踏板，得分不变。如果选择跳跃，主角将移动到 $i+K$ 号踏板，得分增加 $A[i]$。其中 $K$ 是预先设定的常数。游戏在主角到达 $N-1$ 号踏板的右侧时成功结束。也就是说，主角到达编号为 $N, N+1, \\ldots$ 的踏板时，游戏结束——这些编号大于等于 $N$ 的踏板实际上不存在，但表示主角已经越过了 $N-1$ 号踏板。游戏的目标是通过合理控制主角的行动，使得分最大化并成功结束游戏。\n\n喜欢网络直播的尚赫偶尔会玩 KOI 公司的跳跃游戏。虽然他自己玩得很开心，但观众们却反应平平。跳跃游戏不受欢迎的原因在于游戏非常困难且枯燥。首先，这款游戏的踏板数量可以多达 $10^{12}$ 个。其次，即使是 KOI 公司的优秀开发者也无法设计出如此多的踏板，因此他们采用了一种相对简单的方法来生成每个踏板。开发者们最初将所有 $A[i]$ 设置为 $0$，然后进行 $Q$ 次操作：对于每个 $j$ $(0 \\leq j \\leq Q-1)$，他们选择一个区间 $0 \\leq L[j] \\leq R[j] \\leq N-1$，将 $A[L[j]], A[L[j]+1], A[L[j]+2], \\ldots, A[R[j]]$ 的值增加 $1$。所有操作完成后的数组 $A$ 就是游戏中每个踏板跳跃时获得的得分。\n\n你是一名制作计算机科学视频的创作者，决定制作一个关于如何以最高得分完成 KOI 公司的跳跃游戏的视频。你认为这个视频会在尚赫的观众中大受欢迎，但你担心游戏规模太大，难以找到高效的算法。克服所有困难，在给定的 5 小时内成为这款游戏的高手吧！\n\n你需要实现以下函数：\n\n```cpp\nlong long play_game(long long N, int Q, long long K, std::vector<long long> L, std::vector<long long> R);\n```\n\n- `N`：游戏中存在的踏板数量。\n- `Q`：开发者执行的操作次数。\n- `K`：跳跃后到达的下一个踏板的编号。\n- `L, R`：大小为 $Q$ 的整数数组。\n- 该函数返回一个整数，表示跳跃游戏结束时可以获得的最高得分。\n- 该函数在每个测试点中只会被调用一次。", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,Q\\,K$\n- 第 $2+i$ $(0 \\leq i \\leq Q-1)$ 行：$L[i]\\,R[i]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $1$ 行：`play_game` 返回的值", "hint": "对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 10^{12}$\n- $1 \\leq Q \\leq 2.5\\cdot 10^5$\n- $1 \\leq K \\leq N$\n- 对于所有 $j$ $(0 \\leq j \\leq Q-1)$，$0 \\leq L[j] \\leq R[j] \\leq N-1$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $6$ | $N \\leq 2.5\\cdot 10^5$ |\n| $2$ | $2$ | $K=1$ |\n| $3$ | $13$ | $2 K \\geq N$|\n| $4$ | $15$ | $5 K \\geq N$ |\n| $5$ | $16$ | $Q \\leq 500$ |\n| $6$ | $7$ | $Q \\leq 5000$ |\n| $7$ | $41$ | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P11240", "type": "P", "difficulty": 5, "samples": [["1\n6\n1 2 3 1 2 1", "Correct : 4 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2024", "交互题", "KOI（韩国）"], "title": "[KTSC 2024 R2] 回文判定", "background": "**请使用 C++17 或 C++20 提交**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include<vector>\nint guess_palindromicity(int N);\nint count_pair(int x, int y, int z);\nint find_character(int x, std::vector<int> Y);\n```", "description": "**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T3 「[팰린드롬 판별하기](https://assets.ioikorea.kr/ioitst/2024/2/palindrome/palindrome_statement.pdf)」**\n\nKOI 公司为了宣传算法比赛，推出了一个新活动！要参加这个活动，你需要判断 KOI 公司秘密序列 $S$ 是否是回文。\n\n当一个序列翻转后与原序列相同，这个序列就是回文。也就是说，长度为 $N$ 的序列 $S$ 是回文，当且仅当对于所有 $i$ $(0 \\leq i \\leq N-1)$，都有 $S[i] = S[N-1-i]$。例如，$[1,2,3,2,1]$ 和 $[1,2,2,1]$ 是回文，而 $[1,2,3,1]$ 和 $[1,2,2]$ 不是回文。\n\n你知道秘密序列 $S$ 的长度 $N$，并且 $S$ 是由 $1$ 到 $5000$ 之间的整数组成的。为了帮助活动参与者，KOI 公司提供了两种特殊的机器：\n\n- `count_pair` 机器需要输入三个不同的数 $x, y, z$。它会返回 $S[x], S[y], S[z]$ 中相同元素的对数。例如，如果 $S[x] = S[y] = S[z]$，机器会返回 `3`。\n- `find_character` 机器需要输入一个整数 $x$ 和一个整数列表 $Y$。如果 $S[x] = S[y]$ 且 $y$ 在列表 $Y$ 中，机器返回 `1`，否则返回 `0`。\n- 两种机器输入的所有数必须是 $0$ 到 $N-1$ 之间的整数。\n- `find_character` 机器输入的 $Y$ 的总大小不能超过 $N$。\n\n你需要尽可能少地使用机器来判断秘密序列 $S$ 是否是回文。\n\n你需要实现以下函数：\n\n```cpp\nint guess_palindromicity(int N);\n```\n\n- `N`：序列 $S$ 的长度。\n- 如果 $S$ 是回文，函数返回 `1`，否则返回 `0`。\n- 该函数在一个测试用例中可能被调用多次。\n\n程序可以调用以下函数：\n\n```cpp\nint count_pair(int x, int y, int z);\n```\n\n- $x, y, z$ 必须是 $0$ 到 $N-1$ 之间的不同整数。\n- 该函数返回 $S[x], S[y], S[z]$ 中相同元素的对数。\n- 在每次 `guess_palindromicity` 调用中，该函数的调用次数不能超过 $2N$ 次。\n\n```cpp\nint find_character(int x, vector<int> Y);\n```\n\n- $x$ 和 $Y$ 的所有元素必须是 $0$ 到 $N-1$ 之间的整数。\n- 如果 $S[x] = S[y]$ 且 $y \\in Y$，函数返回 `1`，否则返回 `0`。\n- 在每次 `guess_palindromicity` 调用中，该函数的调用次数不能超过 $N$ 次。\n- 在每次 `guess_palindromicity` 调用中，调用该函数的 $Y$ 的总大小不能超过 $N$。\n", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2$ 行：$S[0]\\,S[1]\\,\\ldots\\,S[N-1]$", "outputFormat": "如果程序判定为 `Accepted`，示例评测程序输出 `Correct : A B`，其中 A 是 `count_pair` 的调用次数，$B$ 是 `find_character` 的调用次数。\n\n如果程序判定为 `Wrong Answer`，示例评测程序输出 `Wrong : MSG`，其中 `MSG` 为以下之一：\n\n- `Wrong Input`：输入格式错误。\n- `Invalid Query`：查询值错误。\n- `Wrong Guess`：$S$ 是回文但 `guess_palindromicity` 返回 `0`，或相反。", "hint": "对于所有输入数据，满足：\n\n- $5 \\leq N \\leq 5000$\n- 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$1 \\leq S[i] \\leq 5000$\n- 一个测试用例中给定的 $N$ 的总和为 $M$，满足 $5 \\leq M \\leq 5000$\n\n在这个问题中，评测程序是非自适应的（NOT adaptive）。这意味着 $S$ 在评测程序执行开始时固定，不会根据查询而改变。\n\n## 部分问题\n\n每次 `guess_palindromicity` 调用的评分如下。你的提交得分是所有测试用例中 `guess_palindromicity` 调用得分的最小值。\n\n每次 `guess_palindromicity` 调用中，`count_pair` 函数的调用次数为 $A$，`find_character` 函数的调用次数为 $B$。\n\n如果程序未正常结束，或 `guess_palindromicity` 返回错误值，得分为 $0$。若 `guess_palindromicity` 返回正确值，得分如下表所示：\n\n| 条件 | 得分 |\n| :---: | :---: |\n| $A \\leq 2N, 2 \\leq B \\leq N$ | $15$ |\n| $N < A \\leq 2N, B \\leq 1$ | $50$ |\n| $\\left\\lfloor\\frac{N}{2}\\right\\rfloor + 2 < A \\leq N, B \\leq 1$ | $70$ |\n| $A = \\left\\lfloor\\frac{N}{2}\\right\\rfloor + 2, B \\leq 1$ | $90$ |\n| $A \\leq \\left\\lfloor\\frac{N}{2}\\right\\rfloor + 1, B \\leq 1$ | $100$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2024 R2] 回文判定", "background": "**请使用 C++17 或 C++20 提交**\n\n你需要在程序开头加入如下代码：\n\n```cpp\n#include<vector>\nint guess_palindromicity(int N);\nint count_pair(int x, int y, int z);\nint find_character(int x, std::vector<int> Y);\n```", "description": "**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T3 「[팰린드롬 판별하기](https://assets.ioikorea.kr/ioitst/2024/2/palindrome/palindrome_statement.pdf)」**\n\nKOI 公司为了宣传算法比赛，推出了一个新活动！要参加这个活动，你需要判断 KOI 公司秘密序列 $S$ 是否是回文。\n\n当一个序列翻转后与原序列相同，这个序列就是回文。也就是说，长度为 $N$ 的序列 $S$ 是回文，当且仅当对于所有 $i$ $(0 \\leq i \\leq N-1)$，都有 $S[i] = S[N-1-i]$。例如，$[1,2,3,2,1]$ 和 $[1,2,2,1]$ 是回文，而 $[1,2,3,1]$ 和 $[1,2,2]$ 不是回文。\n\n你知道秘密序列 $S$ 的长度 $N$，并且 $S$ 是由 $1$ 到 $5000$ 之间的整数组成的。为了帮助活动参与者，KOI 公司提供了两种特殊的机器：\n\n- `count_pair` 机器需要输入三个不同的数 $x, y, z$。它会返回 $S[x], S[y], S[z]$ 中相同元素的对数。例如，如果 $S[x] = S[y] = S[z]$，机器会返回 `3`。\n- `find_character` 机器需要输入一个整数 $x$ 和一个整数列表 $Y$。如果 $S[x] = S[y]$ 且 $y$ 在列表 $Y$ 中，机器返回 `1`，否则返回 `0`。\n- 两种机器输入的所有数必须是 $0$ 到 $N-1$ 之间的整数。\n- `find_character` 机器输入的 $Y$ 的总大小不能超过 $N$。\n\n你需要尽可能少地使用机器来判断秘密序列 $S$ 是否是回文。\n\n你需要实现以下函数：\n\n```cpp\nint guess_palindromicity(int N);\n```\n\n- `N`：序列 $S$ 的长度。\n- 如果 $S$ 是回文，函数返回 `1`，否则返回 `0`。\n- 该函数在一个测试用例中可能被调用多次。\n\n程序可以调用以下函数：\n\n```cpp\nint count_pair(int x, int y, int z);\n```\n\n- $x, y, z$ 必须是 $0$ 到 $N-1$ 之间的不同整数。\n- 该函数返回 $S[x], S[y], S[z]$ 中相同元素的对数。\n- 在每次 `guess_palindromicity` 调用中，该函数的调用次数不能超过 $2N$ 次。\n\n```cpp\nint find_character(int x, vector<int> Y);\n```\n\n- $x$ 和 $Y$ 的所有元素必须是 $0$ 到 $N-1$ 之间的整数。\n- 如果 $S[x] = S[y]$ 且 $y \\in Y$，函数返回 `1`，否则返回 `0`。\n- 在每次 `guess_palindromicity` 调用中，该函数的调用次数不能超过 $N$ 次。\n- 在每次 `guess_palindromicity` 调用中，调用该函数的 $Y$ 的总大小不能超过 $N$。\n", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N$\n- 第 $2$ 行：$S[0]\\,S[1]\\,\\ldots\\,S[N-1]$", "outputFormat": "如果程序判定为 `Accepted`，示例评测程序输出 `Correct : A B`，其中 A 是 `count_pair` 的调用次数，$B$ 是 `find_character` 的调用次数。\n\n如果程序判定为 `Wrong Answer`，示例评测程序输出 `Wrong : MSG`，其中 `MSG` 为以下之一：\n\n- `Wrong Input`：输入格式错误。\n- `Invalid Query`：查询值错误。\n- `Wrong Guess`：$S$ 是回文但 `guess_palindromicity` 返回 `0`，或相反。", "hint": "对于所有输入数据，满足：\n\n- $5 \\leq N \\leq 5000$\n- 对于所有 $i$ $(0 \\leq i \\leq N-1)$，$1 \\leq S[i] \\leq 5000$\n- 一个测试用例中给定的 $N$ 的总和为 $M$，满足 $5 \\leq M \\leq 5000$\n\n在这个问题中，评测程序是非自适应的（NOT adaptive）。这意味着 $S$ 在评测程序执行开始时固定，不会根据查询而改变。\n\n## 部分问题\n\n每次 `guess_palindromicity` 调用的评分如下。你的提交得分是所有测试用例中 `guess_palindromicity` 调用得分的最小值。\n\n每次 `guess_palindromicity` 调用中，`count_pair` 函数的调用次数为 $A$，`find_character` 函数的调用次数为 $B$。\n\n如果程序未正常结束，或 `guess_palindromicity` 返回错误值，得分为 $0$。若 `guess_palindromicity` 返回正确值，得分如下表所示：\n\n| 条件 | 得分 |\n| :---: | :---: |\n| $A \\leq 2N, 2 \\leq B \\leq N$ | $15$ |\n| $N < A \\leq 2N, B \\leq 1$ | $50$ |\n| $\\left\\lfloor\\frac{N}{2}\\right\\rfloor + 2 < A \\leq N, B \\leq 1$ | $70$ |\n| $A = \\left\\lfloor\\frac{N}{2}\\right\\rfloor + 2, B \\leq 1$ | $90$ |\n| $A \\leq \\left\\lfloor\\frac{N}{2}\\right\\rfloor + 1, B \\leq 1$ | $100$ |", "locale": "zh-CN"}}}
{"pid": "P11241", "type": "P", "difficulty": 6, "samples": [], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["点分治", "2024", "交互题", "KOI（韩国）"], "title": "[KTSC 2024 R2] 病毒", "background": "**请用 C++14 或 C++17 提交本题**\n\n你需要在代码开头加入如下代码：\n\n```cpp\n#include<vector>\nstd::vector<long long> find_spread(int N, int M, std::vector<int> A, std::vector<int> B, std::vector<int> P, std::vector<int> D, std::vector<int> C);\n```", "description": "**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T4 「[바이러스](https://assets.ioikorea.kr/ioitst/2024/2/virus/virus_statement.pdf)」**\n\n由于上次新冠疫情的严重影响，KOI 城市决定为未来可能发生的疫情做好充分准备。为此，KOI 城市希望分析当前城市结构对病毒的脆弱程度。\n\nKOI 城市由 $N$ 个地点和 $N-1$ 条双向道路组成，任意两个不同的地点都可以通过这些道路互相到达。也就是说，城市的道路网络是一个树结构。每个地点用 $0$ 到 $N-1$ 的不同整数表示。由于城市的道路网络是树结构，对于任意两个地点 $u$ 和 $v$，从 $u$ 到 $v$ 的唯一简单路径上的边数定义为 $u$ 和 $v$ 之间的距离。\n\nKOI 城市有 $M$ 名居民。对于每个 $j$ $(0 \\leq j \\leq M-1)$，第 $j$ 个人住在 $P[j]$ 号地点，并且可以到达距离 $P[j]$ 不超过 $D[j]$ 的地点。\n\nKOI 城市的病毒学家们建立了一个模型来模拟病毒在两个人之间的传播过程。对于每个 $0 \\leq v \\leq N-1$，第 $v$ 号地点的传播时间用一个正整数 $C[v]$ 表示。假设第 $j$ 个人在时间 $t$ 首次感染病毒，并且第 $k$ 个人从第 $j$ 个人那里接收到病毒。如果存在一个地点 $w$，使得 $w$ 号地点与 $P[j]$ 号地点的距离不超过 $D[j]$，且 $w$ 号地点与 $P[k]$ 号地点的距离不超过 $D[k]$，那么 $w$ 号地点就是传播的媒介。\n\n如果没有这样的传播媒介，第 $k$ 个人不会直接从第 $j$ 个人那里感染病毒（当然，他可能通过其他人间接感染）。如果存在传播媒介，那么在所有可能的传播媒介中，选择传播时间最短的地点 $x$。如果第 $k$ 个人在时间 $t+C[x]$ 之前没有感染病毒，那么他将在时间 $t+C[x]$ 被第 $j$ 个人感染。病毒以这种方式在所有不同的两个人之间传播。\n\n在上述模型下，KOI 城市的研究人员希望计算当第 $0$ 个人在时间 $0$ 感染病毒时，其他人何时感染病毒。你需要计算对于每个 $0 \\leq j \\leq M-1$，第 $j$ 个人首次感染病毒的时间。如果第 $j$ 个人没有感染病毒，则记录为 $-1$。\n\n你需要实现以下函数：\n\n```cpp\nstd::vector<long long> find_spread(int N, int M, std::vector<int> A, std::vector<int> B, std::vector<int> P, std::vector<int> D, std::vector<int> C);\n```\n\n- `N`：KOI 城市的地点数量。\n- `M`：KOI 城市的居民数量。\n- `A, B`：长度为 $N-1$ 的数组。对于每个 $i$ $(0 \\leq i \\leq N-2)$，存在一条连接 $A[i]$ 和 $B[i]$ 的道路。每条道路在两个数组中只出现一次。\n- `P, D`：长度为 $M$ 的数组。对于每个 $j$ $(0 \\leq j \\leq M-1)$，第 $j$ 个人住在 $P[j]$ 号地点，并且可以到达距离 $P[j]$ 不超过 $D[j]$ 的地点。\n- `C`：长度为 $N$ 的数组。对于每个 $v$ $(0 \\leq v \\leq N-1)$，第 $v$ 号地点的传播时间为 $C[v]$。\n- 该函数返回一个长度为 $M$ 的数组 $T$。对于每个 $j$ $(0 \\leq j \\leq M-1)$，如果第 $j$ 个人感染病毒，$T[j]$ 表示他首次感染病毒的时间；如果没有感染，则为 $-1$。\n- 该函数在每个测试用例中只会被调用一次。\n", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,M$\n- 第 $2+i$ $(0 \\leq i \\leq N-2)$ 行：$A[i]\\,B[i]$\n- 第 $1+N+j$ $(0 \\leq j \\leq M-1)$ 行：$P[j]\\,D[j]$\n- 第 $1+N+M$ 行：$C[0]\\,C[1]\\,\\ldots\\,C[N-1]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $1+j$ $(0 \\leq j \\leq M-1)$ 行：函数 `find_spread` 返回的数组的第 $j$ 个元素", "hint": "对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 10^5$\n- $1 \\leq M \\leq 10^5$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$0 \\leq A[i], B[i] \\leq N-1, A[i] \\neq B[i]$\n- 对于所有 $j$ $(0 \\leq j \\leq M-1)$，$0 \\leq P[j], D[j] \\leq N-1$\n- 对于所有 $v$ $(0 \\leq v \\leq N-1)$，$1 \\leq C[v] \\leq 10^{9}$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $5$ | $N \\leq 500, M \\leq 500$；<br>对于所有 $i$ $(0 \\leq i \\leq N-2)$，$A[i]=i, B[i]=i+1$ |\n| $2$ | $8$ | $N \\leq 5000, M \\leq 5000$；<br>对于所有 $i$ $(0 \\leq i \\leq N-2)$，$A[i]=i, B[i]=i+1$ |\n| $3$ | $27$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$A[i]=i, B[i]=i+1$ |\n| $4$ | $5$ | $N \\leq 500, M \\leq 500$ |\n| $5$ | $8$ | $N \\leq 5000, M \\leq 5000$ |\n| $6$ | $47$ | 无附加限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[KTSC 2024 R2] 病毒", "background": "**请用 C++14 或 C++17 提交本题**\n\n你需要在代码开头加入如下代码：\n\n```cpp\n#include<vector>\nstd::vector<long long> find_spread(int N, int M, std::vector<int> A, std::vector<int> B, std::vector<int> P, std::vector<int> D, std::vector<int> C);\n```", "description": "**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 2차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T4 「[바이러스](https://assets.ioikorea.kr/ioitst/2024/2/virus/virus_statement.pdf)」**\n\n由于上次新冠疫情的严重影响，KOI 城市决定为未来可能发生的疫情做好充分准备。为此，KOI 城市希望分析当前城市结构对病毒的脆弱程度。\n\nKOI 城市由 $N$ 个地点和 $N-1$ 条双向道路组成，任意两个不同的地点都可以通过这些道路互相到达。也就是说，城市的道路网络是一个树结构。每个地点用 $0$ 到 $N-1$ 的不同整数表示。由于城市的道路网络是树结构，对于任意两个地点 $u$ 和 $v$，从 $u$ 到 $v$ 的唯一简单路径上的边数定义为 $u$ 和 $v$ 之间的距离。\n\nKOI 城市有 $M$ 名居民。对于每个 $j$ $(0 \\leq j \\leq M-1)$，第 $j$ 个人住在 $P[j]$ 号地点，并且可以到达距离 $P[j]$ 不超过 $D[j]$ 的地点。\n\nKOI 城市的病毒学家们建立了一个模型来模拟病毒在两个人之间的传播过程。对于每个 $0 \\leq v \\leq N-1$，第 $v$ 号地点的传播时间用一个正整数 $C[v]$ 表示。假设第 $j$ 个人在时间 $t$ 首次感染病毒，并且第 $k$ 个人从第 $j$ 个人那里接收到病毒。如果存在一个地点 $w$，使得 $w$ 号地点与 $P[j]$ 号地点的距离不超过 $D[j]$，且 $w$ 号地点与 $P[k]$ 号地点的距离不超过 $D[k]$，那么 $w$ 号地点就是传播的媒介。\n\n如果没有这样的传播媒介，第 $k$ 个人不会直接从第 $j$ 个人那里感染病毒（当然，他可能通过其他人间接感染）。如果存在传播媒介，那么在所有可能的传播媒介中，选择传播时间最短的地点 $x$。如果第 $k$ 个人在时间 $t+C[x]$ 之前没有感染病毒，那么他将在时间 $t+C[x]$ 被第 $j$ 个人感染。病毒以这种方式在所有不同的两个人之间传播。\n\n在上述模型下，KOI 城市的研究人员希望计算当第 $0$ 个人在时间 $0$ 感染病毒时，其他人何时感染病毒。你需要计算对于每个 $0 \\leq j \\leq M-1$，第 $j$ 个人首次感染病毒的时间。如果第 $j$ 个人没有感染病毒，则记录为 $-1$。\n\n你需要实现以下函数：\n\n```cpp\nstd::vector<long long> find_spread(int N, int M, std::vector<int> A, std::vector<int> B, std::vector<int> P, std::vector<int> D, std::vector<int> C);\n```\n\n- `N`：KOI 城市的地点数量。\n- `M`：KOI 城市的居民数量。\n- `A, B`：长度为 $N-1$ 的数组。对于每个 $i$ $(0 \\leq i \\leq N-2)$，存在一条连接 $A[i]$ 和 $B[i]$ 的道路。每条道路在两个数组中只出现一次。\n- `P, D`：长度为 $M$ 的数组。对于每个 $j$ $(0 \\leq j \\leq M-1)$，第 $j$ 个人住在 $P[j]$ 号地点，并且可以到达距离 $P[j]$ 不超过 $D[j]$ 的地点。\n- `C`：长度为 $N$ 的数组。对于每个 $v$ $(0 \\leq v \\leq N-1)$，第 $v$ 号地点的传播时间为 $C[v]$。\n- 该函数返回一个长度为 $M$ 的数组 $T$。对于每个 $j$ $(0 \\leq j \\leq M-1)$，如果第 $j$ 个人感染病毒，$T[j]$ 表示他首次感染病毒的时间；如果没有感染，则为 $-1$。\n- 该函数在每个测试用例中只会被调用一次。\n", "inputFormat": "示例评测程序按以下格式读取输入：\n\n- 第 $1$ 行：$N\\,M$\n- 第 $2+i$ $(0 \\leq i \\leq N-2)$ 行：$A[i]\\,B[i]$\n- 第 $1+N+j$ $(0 \\leq j \\leq M-1)$ 行：$P[j]\\,D[j]$\n- 第 $1+N+M$ 行：$C[0]\\,C[1]\\,\\ldots\\,C[N-1]$", "outputFormat": "示例评测程序按以下格式输出：\n\n- 第 $1+j$ $(0 \\leq j \\leq M-1)$ 行：函数 `find_spread` 返回的数组的第 $j$ 个元素", "hint": "对于所有输入数据，满足：\n\n- $1 \\leq N \\leq 10^5$\n- $1 \\leq M \\leq 10^5$\n- 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$0 \\leq A[i], B[i] \\leq N-1, A[i] \\neq B[i]$\n- 对于所有 $j$ $(0 \\leq j \\leq M-1)$，$0 \\leq P[j], D[j] \\leq N-1$\n- 对于所有 $v$ $(0 \\leq v \\leq N-1)$，$1 \\leq C[v] \\leq 10^{9}$\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 分值 | 附加限制 |\n| :-: | :-: | :-: |\n| $1$ | $5$ | $N \\leq 500, M \\leq 500$；<br>对于所有 $i$ $(0 \\leq i \\leq N-2)$，$A[i]=i, B[i]=i+1$ |\n| $2$ | $8$ | $N \\leq 5000, M \\leq 5000$；<br>对于所有 $i$ $(0 \\leq i \\leq N-2)$，$A[i]=i, B[i]=i+1$ |\n| $3$ | $27$ | 对于所有 $i$ $(0 \\leq i \\leq N-2)$，$A[i]=i, B[i]=i+1$ |\n| $4$ | $5$ | $N \\leq 500, M \\leq 500$ |\n| $5$ | $8$ | $N \\leq 5000, M \\leq 5000$ |\n| $6$ | $47$ | 无附加限制 |", "locale": "zh-CN"}}}
{"pid": "P11242", "type": "P", "difficulty": 2, "samples": [["4\n2 3 4 5", "8\n"], ["7\n6 6 7 8 4 2 4", "14\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "洛谷原创", "O2优化", "树论", "洛谷月赛"], "title": "碧树", "background": "[English statement](https://www.luogu.com.cn/problem/U505210). **You must submit your code at the Chinese version of the statement.**\n\n小 T 不知道交流是什么。\n\n是为了弄懂一串奇怪的符号，然后再把它放入他人的大脑吗？\n\n是为了得到一些抽象的知识，然后再用它打破自己的习惯吗？\n\n为了交流，小 T 最终决定接通了 $\\text{220V}$ 的电压。", "description": "> t1k1x1ww。\n\n小 T 注视着这一串自己不能理解的符号，决定先和你交流一个 OI 题目。\n\n小 T 有一棵有根树，它共有 $k$ 个叶子结点，同时他还告诉了你，其叶子结点的深度分别为 $a_1\\dots a_k$。请你帮他计算，这棵树最少包含多少个结点。小 T 保证存在至少一棵这样的树。\n\n如果您不熟悉题面中的若干定义，我们乐意提醒您：\n\n- 图上的 **简单路径** 指一条经过顶点不重复、经过边不重复的路径。\n- 一棵 **树** 是一张联通，且任意两点之间有且仅有一条简单路径的图。在一棵树里，我们会选择一个节点为根结点。\n- 树上的 **叶子结点** 为不是根结点，且度数为 $1$ 的结点。\n- 树上一个节点的 **深度** 是该结点到根结点的简单路径上结点的个数。", "inputFormat": "第一行一个整数 $k$。\n\n接下来一行 $k$ 个整数，描述 $a_1\\dots a_k$。", "outputFormat": "仅一行一个整数，表示答案。", "hint": "### 样例解释\n\n- 对于第一组数据，下面是一棵可能的树：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kh6cgtyp.png?x-oss-process=image/resize,m_lfit,h_400,w_400)\n\n其大小为 $8$，其中叶子 $3, 5, 6, 8$ 的深度分别为 $2, 3, 4, 5$。容易证明没有大小 $\\leq 7$ 的树符合题意。\n\n### 数据规模与约定\n\n**本题采用捆绑测试和子任务依赖。**\n\n- Subtask 0（0 pts）：样例。\n- Subtask 1（30 pts）：$k = 2$。\n- Subtask 2（30 pts）：$a_1 = a_2 = \\dots = a_k$。\n- Subtask 3（40 pts）：无特殊限制。依赖于子任务 $0 \\sim 2$。\n\n对于所有数据，保证 $1 \\leq k \\leq 10^5$，$2 \\leq a_i \\leq 10^5$，且保证存在至少一棵这样的树。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "碧树", "background": "[English statement](https://www.luogu.com.cn/problem/U505210). **You must submit your code at the Chinese version of the statement.**\n\n小 T 不知道交流是什么。\n\n是为了弄懂一串奇怪的符号，然后再把它放入他人的大脑吗？\n\n是为了得到一些抽象的知识，然后再用它打破自己的习惯吗？\n\n为了交流，小 T 最终决定接通了 $\\text{220V}$ 的电压。", "description": "> t1k1x1ww。\n\n小 T 注视着这一串自己不能理解的符号，决定先和你交流一个 OI 题目。\n\n小 T 有一棵有根树，它共有 $k$ 个叶子结点，同时他还告诉了你，其叶子结点的深度分别为 $a_1\\dots a_k$。请你帮他计算，这棵树最少包含多少个结点。小 T 保证存在至少一棵这样的树。\n\n如果您不熟悉题面中的若干定义，我们乐意提醒您：\n\n- 图上的 **简单路径** 指一条经过顶点不重复、经过边不重复的路径。\n- 一棵 **树** 是一张联通，且任意两点之间有且仅有一条简单路径的图。在一棵树里，我们会选择一个节点为根结点。\n- 树上的 **叶子结点** 为不是根结点，且度数为 $1$ 的结点。\n- 树上一个节点的 **深度** 是该结点到根结点的简单路径上结点的个数。", "inputFormat": "第一行一个整数 $k$。\n\n接下来一行 $k$ 个整数，描述 $a_1\\dots a_k$。", "outputFormat": "仅一行一个整数，表示答案。", "hint": "### 样例解释\n\n- 对于第一组数据，下面是一棵可能的树：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/kh6cgtyp.png?x-oss-process=image/resize,m_lfit,h_400,w_400)\n\n其大小为 $8$，其中叶子 $3, 5, 6, 8$ 的深度分别为 $2, 3, 4, 5$。容易证明没有大小 $\\leq 7$ 的树符合题意。\n\n### 数据规模与约定\n\n**本题采用捆绑测试和子任务依赖。**\n\n- Subtask 0（0 pts）：样例。\n- Subtask 1（30 pts）：$k = 2$。\n- Subtask 2（30 pts）：$a_1 = a_2 = \\dots = a_k$。\n- Subtask 3（40 pts）：无特殊限制。依赖于子任务 $0 \\sim 2$。\n\n对于所有数据，保证 $1 \\leq k \\leq 10^5$，$2 \\leq a_i \\leq 10^5$，且保证存在至少一棵这样的树。", "locale": "zh-CN"}}}
{"pid": "P11243", "type": "P", "difficulty": 3, "samples": [["5\n5\n<<<<\n7\n<=><=<\n9\n=<<><==<\n11\n>=<<=>>>=>\n13\n=><<=<=>=><>\n", "10\n9\n13\n29\n25\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["递推", "洛谷原创", "O2优化", "洛谷月赛", "双指针 two-pointer"], "title": "繁花", "background": "[English statement](https://www.luogu.com.cn/problem/U505208). **You must submit your code at the Chinese version of the statement.**\n\n我已经知道，在设置好循环播放时就已经知道，我是在麻痹自己，在逃避问题。\n\n我承认如此，可捞起那些沉于水底的细节时，却一瞬间突然和所有所有真实的心跳共鸣。\n\n那时总想的太少，现在常想得太多，不知所措似荒塘里的绿藻蔓延着。\n\n然而这世间情感太多，小 R 也只能体会更开心和更难过。", "description": "小 R 想对上面的问题进行探究，她想先做一些统计，于是她抽象了这个问题。\n\n小 R 有 $n$ 个未知量 $a_1\\dots a_n$，对每个 $1 \\leq i < n$，她都比较了 $a_i$ 和 $a_{i+1}$ 并写下了一个字符 $c_i \\in \\{\\texttt <, \\texttt >, \\texttt =\\}$，表示两个未知量之间的比较结果。具体地：\n\n- 若 $c_i = \\texttt >$，则 $a_i > a_{i+1}$；\n- 若 $c_i = \\texttt <$，则 $a_i < a_{i+1}$；\n- 否则（$c_i = \\texttt =$），表示 $a_i = a_{i+1}$。\n\n小 R 称 $\\bm{a_i}$ **比** $\\bm{a_j}$ **更开心**，当且仅当对任何 **满足上述 $\\bm{n - 1}$ 条约束的** $[a_1, \\dots, a_n] \\in \\mathbb R^n$，都有 $a_i < a_j$。请你帮她数出 $1 \\leq i, j \\leq n$ 且 $a_i$ 比 $a_j$ 更开心的整数数对 $(i, j)$ 个数。\n\n因为要循环播放，所以有多组数据。", "inputFormat": "**本题有多组数据。**\n\n第一行，一个整数 $T$，表示数据组数。对于每组数据：\n\n- 第一行一个整数 $n$。\n- 接下来一行，一个长度为 $n - 1$ 的字符串 $c_1c_2\\dots c_{n-1}$。", "outputFormat": "对于每组数据，输出仅一行一个整数，表示符合条件的整数数对个数。", "hint": "### 样例解释\n\n- 对于第一组数据，$a_i$ 比 $a_j$ 开心当且仅当 $1 \\leq i < j \\leq n$，故共有 $\\frac{5\\times 4}{2} = 10$ 对合法的 $(i, j)$。\n- 对于第二组数据，合法的 $(i, j)$ 分别为：$(1, 2), (1, 3), (4, 2), (4, 3), (4, 5), (4, 6), (4, 7), (5, 7), (6, 7)$，共 $9$ 对。\n- 对于其他几组数据，聪明的读者可以自行验证。\n\n### 数据规模与约定\n\n**本题采用捆绑测试和子任务依赖。**\n\n- Subtask 0（0 pts）：样例。\n- Subtask 1（10 pts）：$n \\leq 8$，$T \\leq 8$。\n- Subtask 2（20 pts）：$n \\leq 5000$，$T \\leq 8$。依赖于子任务 $0, 1$。\n- Subtask 3（20 pts）：$c_i \\neq \\texttt =$。\n- Subtask 4（50 pts）：无特殊限制。依赖于子任务 $0 \\sim 3$。\n\n对于所有数据，保证 $2 \\leq n \\leq 2\\times 10^5$，$1 \\leq T \\leq 10^4$，$c_i \\in \\{\\texttt <, \\texttt >, \\texttt =\\}$，$\\sum n \\leq 5\\times 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "繁花", "background": "[English statement](https://www.luogu.com.cn/problem/U505208). **You must submit your code at the Chinese version of the statement.**\n\n我已经知道，在设置好循环播放时就已经知道，我是在麻痹自己，在逃避问题。\n\n我承认如此，可捞起那些沉于水底的细节时，却一瞬间突然和所有所有真实的心跳共鸣。\n\n那时总想的太少，现在常想得太多，不知所措似荒塘里的绿藻蔓延着。\n\n然而这世间情感太多，小 R 也只能体会更开心和更难过。", "description": "小 R 想对上面的问题进行探究，她想先做一些统计，于是她抽象了这个问题。\n\n小 R 有 $n$ 个未知量 $a_1\\dots a_n$，对每个 $1 \\leq i < n$，她都比较了 $a_i$ 和 $a_{i+1}$ 并写下了一个字符 $c_i \\in \\{\\texttt <, \\texttt >, \\texttt =\\}$，表示两个未知量之间的比较结果。具体地：\n\n- 若 $c_i = \\texttt >$，则 $a_i > a_{i+1}$；\n- 若 $c_i = \\texttt <$，则 $a_i < a_{i+1}$；\n- 否则（$c_i = \\texttt =$），表示 $a_i = a_{i+1}$。\n\n小 R 称 $\\bm{a_i}$ **比** $\\bm{a_j}$ **更开心**，当且仅当对任何 **满足上述 $\\bm{n - 1}$ 条约束的** $[a_1, \\dots, a_n] \\in \\mathbb R^n$，都有 $a_i < a_j$。请你帮她数出 $1 \\leq i, j \\leq n$ 且 $a_i$ 比 $a_j$ 更开心的整数数对 $(i, j)$ 个数。\n\n因为要循环播放，所以有多组数据。", "inputFormat": "**本题有多组数据。**\n\n第一行，一个整数 $T$，表示数据组数。对于每组数据：\n\n- 第一行一个整数 $n$。\n- 接下来一行，一个长度为 $n - 1$ 的字符串 $c_1c_2\\dots c_{n-1}$。", "outputFormat": "对于每组数据，输出仅一行一个整数，表示符合条件的整数数对个数。", "hint": "### 样例解释\n\n- 对于第一组数据，$a_i$ 比 $a_j$ 开心当且仅当 $1 \\leq i < j \\leq n$，故共有 $\\frac{5\\times 4}{2} = 10$ 对合法的 $(i, j)$。\n- 对于第二组数据，合法的 $(i, j)$ 分别为：$(1, 2), (1, 3), (4, 2), (4, 3), (4, 5), (4, 6), (4, 7), (5, 7), (6, 7)$，共 $9$ 对。\n- 对于其他几组数据，聪明的读者可以自行验证。\n\n### 数据规模与约定\n\n**本题采用捆绑测试和子任务依赖。**\n\n- Subtask 0（0 pts）：样例。\n- Subtask 1（10 pts）：$n \\leq 8$，$T \\leq 8$。\n- Subtask 2（20 pts）：$n \\leq 5000$，$T \\leq 8$。依赖于子任务 $0, 1$。\n- Subtask 3（20 pts）：$c_i \\neq \\texttt =$。\n- Subtask 4（50 pts）：无特殊限制。依赖于子任务 $0 \\sim 3$。\n\n对于所有数据，保证 $2 \\leq n \\leq 2\\times 10^5$，$1 \\leq T \\leq 10^4$，$c_i \\in \\{\\texttt <, \\texttt >, \\texttt =\\}$，$\\sum n \\leq 5\\times 10^5$。", "locale": "zh-CN"}}}
