{"pid": "P12925", "type": "P", "difficulty": 5, "samples": [["5 4\n01010", "01111"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["POI（波兰）", "2023", "矩阵加速", "bitset"], "title": "[POI 2022/2023 R2] 病毒 / Wirus", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/5020)。", "description": "**题目译自 [XXX Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi30-2/dashboard/) [Wirus](https://szkopul.edu.pl/problemset/problem/c9kbLOJVLHiQDcmiNo8Pa4w6/statement/)**\n\nBajtosia 在 Bajtocja 最先进的生物实验室工作，她的团队研究一种新型病毒。该病毒的基因型仅由两种基因组成，记为 $0$ 和 $1$，总计 $n$ 个基因，可表示为序列 $(X_1, X_2, \\ldots, X_n)$，其中每个 $X_i$ 为 $0$ 或 $1$。\n\n不幸的是，这种病毒以独特但规律的方式变异。每天，左侧第一个基因 $X_1$ 脱离，变为 $X_1 \\oplus X_2$（$\\oplus$ 表示异或运算），然后附着到序列右侧。因此，基因型 $(X_1, X_2, \\ldots, X_n)$ 变异后为 $(X_2, X_3, \\ldots, X_n, X_1 \\oplus X_2)$。\n\nBajtosia 需要预测病毒在 $d$ 天后的基因型。你能帮助她吗？", "inputFormat": "第一行包含两个整数 $n, d$ $(2 \\leq n \\leq 700, 1 \\leq d \\leq 10^{15})$，分别表示基因型长度和变异天数。\n\n第二行包含一个长度为 $n$ 的字符串，由字符 $X_1, X_2, \\ldots, X_n$ $(X_i \\in \\{0, 1\\})$ 组成，第 $i$ 个字符表示第 $i$ 个基因的类型。", "outputFormat": "输出一行，包含长度为 $n$ 的字符串，表示 $d$ 天后病毒的基因型，格式与输入相同。", "hint": "**样例 1 解释**\n\n病毒基因型每日变化如下：\n\n$$\n01010 \\to 10101 \\to 01011 \\to 10111 \\to 01111\n$$\n\n**附加样例**\n\n1. $n=10, d=30$，初始基因型 $1010000101$，答案为 $0110110110$。  \n2. $n=100, d=2000000$，初始基因型 $000\\ldots000$，答案为 $000\\ldots000$。  \n3. $n=700, d=10^{15}$，初始基因型 $111\\ldots111$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$    | $d \\leq 100$             | $7$  |\n| $2$    | $d \\leq 2000000$         | $12$ |\n| $3$    | $n \\leq 100$             | $65$ |\n| $4$    | 无附加限制               | $16$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2022/2023 R2] 病毒 / Wirus", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/5020)。", "description": "**题目译自 [XXX Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi30-2/dashboard/) [Wirus](https://szkopul.edu.pl/problemset/problem/c9kbLOJVLHiQDcmiNo8Pa4w6/statement/)**\n\nBajtosia 在 Bajtocja 最先进的生物实验室工作，她的团队研究一种新型病毒。该病毒的基因型仅由两种基因组成，记为 $0$ 和 $1$，总计 $n$ 个基因，可表示为序列 $(X_1, X_2, \\ldots, X_n)$，其中每个 $X_i$ 为 $0$ 或 $1$。\n\n不幸的是，这种病毒以独特但规律的方式变异。每天，左侧第一个基因 $X_1$ 脱离，变为 $X_1 \\oplus X_2$（$\\oplus$ 表示异或运算），然后附着到序列右侧。因此，基因型 $(X_1, X_2, \\ldots, X_n)$ 变异后为 $(X_2, X_3, \\ldots, X_n, X_1 \\oplus X_2)$。\n\nBajtosia 需要预测病毒在 $d$ 天后的基因型。你能帮助她吗？", "inputFormat": "第一行包含两个整数 $n, d$ $(2 \\leq n \\leq 700, 1 \\leq d \\leq 10^{15})$，分别表示基因型长度和变异天数。\n\n第二行包含一个长度为 $n$ 的字符串，由字符 $X_1, X_2, \\ldots, X_n$ $(X_i \\in \\{0, 1\\})$ 组成，第 $i$ 个字符表示第 $i$ 个基因的类型。", "outputFormat": "输出一行，包含长度为 $n$ 的字符串，表示 $d$ 天后病毒的基因型，格式与输入相同。", "hint": "**样例 1 解释**\n\n病毒基因型每日变化如下：\n\n$$\n01010 \\to 10101 \\to 01011 \\to 10111 \\to 01111\n$$\n\n**附加样例**\n\n1. $n=10, d=30$，初始基因型 $1010000101$，答案为 $0110110110$。  \n2. $n=100, d=2000000$，初始基因型 $000\\ldots000$，答案为 $000\\ldots000$。  \n3. $n=700, d=10^{15}$，初始基因型 $111\\ldots111$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$    | $d \\leq 100$             | $7$  |\n| $2$    | $d \\leq 2000000$         | $12$ |\n| $3$    | $n \\leq 100$             | $65$ |\n| $4$    | 无附加限制               | $16$ |", "locale": "zh-CN"}}}
{"pid": "P12926", "type": "P", "difficulty": 5, "samples": [["6\n1 2\n2 3\n3 4\n3 5\n5 6\n1 2 1\n1\n5 6\nA + 2", "1\n3"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["博弈论", "树状数组", "POI（波兰）", "2023", "树的重心"], "title": "[POI 2022/2023 R2] 涂色游戏 / Gra w kolorowanie", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/5021)。", "description": "**题目译自 [XXX Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi30-2/dashboard/) [Gra w kolorowanie](https://szkopul.edu.pl/problemset/problem/BefzQSkyOOBhuycp8gvD8XdG/statement/)**\n\n涂色游戏的棋盘由 $n$ 个格子组成，编号从 $1$ 到 $n$，部分格子相邻，恰有 $n-1$ 对相邻格子，且任意两格子可通过相邻格子连通（棋盘构成一棵树）。\n\n游戏由两名玩家参与。初始时，所有格子为白色，除一个格子涂为红色（属于玩家一）和另一个格子涂为蓝色（属于玩家二）。玩家轮流行动，每次选择一个自身颜色的格子 $u$，并将其相邻的任一白色格子 $v$ 涂为同色。无法行动的玩家输掉游戏。\n\n我们想知道，玩家一在哪些初始格子选择下能确保获胜，即无论玩家二如何行动，玩家一总有制胜策略。具体而言，给定格子集合 $A$ 和 $B$，计算满足以下条件的不同格子对 $(a, b)$ 数量：初始红色格子 $a \\in A$，初始蓝色格子 $b \\in B$，且玩家一有制胜策略。\n\n程序需处理集合 $A$ 和 $B$ 的 $q$ 次更新，每次添加或移除一个格子，输出每次更新后满足条件的 $(a, b)$ 对数量。", "inputFormat": "第一行包含一个整数 $n$ $(1 \\leq n \\leq 500000)$，表示棋盘格子数。\n\n接下来的 $n-1$ 行，每行包含两个整数 $u, v$ $(1 \\leq u, v \\leq n)$，表示格子 $u$ 和 $v$ 相邻。\n\n下一行包含三个整数 $S_A, S_B, q$ $(1 \\leq S_A, S_B \\leq n, 0 \\leq q \\leq 500000)$，分别表示集合 $A$ 和 $B$ 的初始大小及更新次数。\n\n下一行包含 $S_A$ 个互不相同的整数（属于 $\\{1, \\ldots, n\\}$），表示集合 $A$ 的格子编号。\n\n下一行包含 $S_B$ 个互不相同的整数（属于 $\\{1, \\ldots, n\\}$），表示集合 $B$ 的格子编号。\n\n接下来的 $q$ 行，每行包含两个字符 $z, t$ 和一个整数 $w$ $(z \\in \\{\\texttt{A}, \\texttt{B}\\}, t \\in \\{\\texttt{+}, \\texttt{-}\\}, 1 \\leq w \\leq n)$，分别表示操作的集合（$A$ 或 $B$）、操作类型（$\\texttt{+}$ 为添加，$\\texttt{-}$ 为移除）和格子编号 $w$。保证每次操作有效（添加时 $w$ 不在集合，移除时 $w$ 在集合）。\n\n集合 $A$ 和 $B$ 可不互斥，计数的 $(a, b)$ 对要求 $a \\neq b$。", "outputFormat": "输出 $q+1$ 行，第 $i$ 行包含一个整数，表示前 $i-1$ 次更新后，满足条件的 $(a, b)$ 对数量。特别地，第一行表示初始集合 $A$ 和 $B$ 的结果。", "hint": "**样例 1 解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/98x0wc08.png)\n\n初始时，$A=\\{1\\}, B=\\{5, 6\\}$，可选初始对 $(a, b)$ 为 $(1, 5)$ 和 $(1, 6)$。  \n- 对 $(1, 5)$：玩家一涂格子 $2$，玩家二涂格子 $3$，玩家一无格子可涂，输。  \n- 对 $(1, 6)$：玩家一涂格子 $2$，玩家二涂格子 $5$，玩家一涂格子 $3$，玩家二无格子可涂，输。  \n仅 $(1, 6)$ 使玩家一获胜，输出 $1$。  \n\n更新后，$A=\\{1, 2\\}, B=\\{5, 6\\}$，玩家一在 $(1, 5), (2, 5), (2, 6)$ 有制胜策略，输出 $3$。\n\n**附加样例**\n\n1. $n=10, q=0$，格子 $i>1$ 连接格子 $1$，$A=\\{1, 2, 3\\}, B=\\{4, 5, 6\\}$，答案为 $9$。\n2. $n=200, q=0$，格子 $i>1$ 连接格子 $i-1$，$A=\\{1, 2, 3\\}, B=\\{1, 2, 3\\}$，答案为 $3$。\n3. $n=2000, q=0$，格子 $i>1$ 连接格子 $\\lfloor i/2 \\rfloor$，$A=B=\\{1, 2, \\ldots, n\\}$，答案为 $2411948$。\n4. $n=500000, q=0$，格子 $i>1$ 连接格子 $\\lfloor i/2 \\rfloor$，$A=B=\\{1, 2, \\ldots, n\\}$，答案为 $150744198828$。\n5. $n=500000, q=1$，格子 $i>1$ 连接格子 $i-1$，$A=\\{1, 2, 3\\}, B=\\{1\\}$，更新移除 $B$ 的格子 $1$。\n6. $n=500000, q=1$，格子 $i>1$ 连接格子 $i-1$，$A=\\{1, 2, 3\\}, B=\\{1, 2, 3\\}$，更新移除 $B$ 的格子 $3$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$    | $q=0, n \\leq 10$         | $8$  |\n| $2$    | $q=0, n \\leq 200$        | $10$ |\n| $3$    | $q=0, n \\leq 2000$       | $18$ |\n| $4$    | $q=0$                    | $30$ |\n| $5$    | $z=\\texttt{B}$           | $16$ |\n| $6$    | 无附加限制               | $18$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2022/2023 R2] 涂色游戏 / Gra w kolorowanie", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/5021)。", "description": "**题目译自 [XXX Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi30-2/dashboard/) [Gra w kolorowanie](https://szkopul.edu.pl/problemset/problem/BefzQSkyOOBhuycp8gvD8XdG/statement/)**\n\n涂色游戏的棋盘由 $n$ 个格子组成，编号从 $1$ 到 $n$，部分格子相邻，恰有 $n-1$ 对相邻格子，且任意两格子可通过相邻格子连通（棋盘构成一棵树）。\n\n游戏由两名玩家参与。初始时，所有格子为白色，除一个格子涂为红色（属于玩家一）和另一个格子涂为蓝色（属于玩家二）。玩家轮流行动，每次选择一个自身颜色的格子 $u$，并将其相邻的任一白色格子 $v$ 涂为同色。无法行动的玩家输掉游戏。\n\n我们想知道，玩家一在哪些初始格子选择下能确保获胜，即无论玩家二如何行动，玩家一总有制胜策略。具体而言，给定格子集合 $A$ 和 $B$，计算满足以下条件的不同格子对 $(a, b)$ 数量：初始红色格子 $a \\in A$，初始蓝色格子 $b \\in B$，且玩家一有制胜策略。\n\n程序需处理集合 $A$ 和 $B$ 的 $q$ 次更新，每次添加或移除一个格子，输出每次更新后满足条件的 $(a, b)$ 对数量。", "inputFormat": "第一行包含一个整数 $n$ $(1 \\leq n \\leq 500000)$，表示棋盘格子数。\n\n接下来的 $n-1$ 行，每行包含两个整数 $u, v$ $(1 \\leq u, v \\leq n)$，表示格子 $u$ 和 $v$ 相邻。\n\n下一行包含三个整数 $S_A, S_B, q$ $(1 \\leq S_A, S_B \\leq n, 0 \\leq q \\leq 500000)$，分别表示集合 $A$ 和 $B$ 的初始大小及更新次数。\n\n下一行包含 $S_A$ 个互不相同的整数（属于 $\\{1, \\ldots, n\\}$），表示集合 $A$ 的格子编号。\n\n下一行包含 $S_B$ 个互不相同的整数（属于 $\\{1, \\ldots, n\\}$），表示集合 $B$ 的格子编号。\n\n接下来的 $q$ 行，每行包含两个字符 $z, t$ 和一个整数 $w$ $(z \\in \\{\\texttt{A}, \\texttt{B}\\}, t \\in \\{\\texttt{+}, \\texttt{-}\\}, 1 \\leq w \\leq n)$，分别表示操作的集合（$A$ 或 $B$）、操作类型（$\\texttt{+}$ 为添加，$\\texttt{-}$ 为移除）和格子编号 $w$。保证每次操作有效（添加时 $w$ 不在集合，移除时 $w$ 在集合）。\n\n集合 $A$ 和 $B$ 可不互斥，计数的 $(a, b)$ 对要求 $a \\neq b$。", "outputFormat": "输出 $q+1$ 行，第 $i$ 行包含一个整数，表示前 $i-1$ 次更新后，满足条件的 $(a, b)$ 对数量。特别地，第一行表示初始集合 $A$ 和 $B$ 的结果。", "hint": "**样例 1 解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/98x0wc08.png)\n\n初始时，$A=\\{1\\}, B=\\{5, 6\\}$，可选初始对 $(a, b)$ 为 $(1, 5)$ 和 $(1, 6)$。  \n- 对 $(1, 5)$：玩家一涂格子 $2$，玩家二涂格子 $3$，玩家一无格子可涂，输。  \n- 对 $(1, 6)$：玩家一涂格子 $2$，玩家二涂格子 $5$，玩家一涂格子 $3$，玩家二无格子可涂，输。  \n仅 $(1, 6)$ 使玩家一获胜，输出 $1$。  \n\n更新后，$A=\\{1, 2\\}, B=\\{5, 6\\}$，玩家一在 $(1, 5), (2, 5), (2, 6)$ 有制胜策略，输出 $3$。\n\n**附加样例**\n\n1. $n=10, q=0$，格子 $i>1$ 连接格子 $1$，$A=\\{1, 2, 3\\}, B=\\{4, 5, 6\\}$，答案为 $9$。\n2. $n=200, q=0$，格子 $i>1$ 连接格子 $i-1$，$A=\\{1, 2, 3\\}, B=\\{1, 2, 3\\}$，答案为 $3$。\n3. $n=2000, q=0$，格子 $i>1$ 连接格子 $\\lfloor i/2 \\rfloor$，$A=B=\\{1, 2, \\ldots, n\\}$，答案为 $2411948$。\n4. $n=500000, q=0$，格子 $i>1$ 连接格子 $\\lfloor i/2 \\rfloor$，$A=B=\\{1, 2, \\ldots, n\\}$，答案为 $150744198828$。\n5. $n=500000, q=1$，格子 $i>1$ 连接格子 $i-1$，$A=\\{1, 2, 3\\}, B=\\{1\\}$，更新移除 $B$ 的格子 $1$。\n6. $n=500000, q=1$，格子 $i>1$ 连接格子 $i-1$，$A=\\{1, 2, 3\\}, B=\\{1, 2, 3\\}$，更新移除 $B$ 的格子 $3$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$    | $q=0, n \\leq 10$         | $8$  |\n| $2$    | $q=0, n \\leq 200$        | $10$ |\n| $3$    | $q=0, n \\leq 2000$       | $18$ |\n| $4$    | $q=0$                    | $30$ |\n| $5$    | $z=\\texttt{B}$           | $16$ |\n| $6$    | 无附加限制               | $18$ |", "locale": "zh-CN"}}}
{"pid": "P12927", "type": "P", "difficulty": 4, "samples": [["5 1 1 1", "12"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["POI（波兰）", "2023"], "title": "[POI 2022/2023 R2] 车厢 / Wagony", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/5022)。", "description": "**题目译自 [XXX Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi30-2/dashboard/) [Wagony](https://szkopul.edu.pl/problemset/problem/UtJx9fM6UT2oxXFenSPjiz5C/statement/)**\n\n在一维铁轨上停放着 $n$ 个车厢，初始时各车厢互不连接。每次操作可将相邻的两组已连接车厢合并，前提是两组车厢数量差不超过 $d$。合并耗时取决于两组车厢数量。你的任务是将所有车厢合并成一个含 $n$ 个车厢的列车。\n\n合并含 $w$ 个车厢的组与含 $v$ 个车厢的组（满足 $|w-v| \\leq d$）的成本由奇特函数 $(a w + b v) \\bmod 1001$ 计算。", "inputFormat": "第一行包含四个正整数 $n, d, a, b$ $(1 \\leq n \\leq 10^{16}, 1 \\leq d, a, b \\leq 1000)$，分别表示车厢总数、数量差上限和成本函数参数。", "outputFormat": "输出一个整数，表示将 $n$ 个车厢合并成一个列车的最小成本。", "hint": "**样例 1 解释**\n\n我们将第一个车厢与第二个车厢连接（成本 $2$），第三个车厢与第四个车厢连接（成本 $2$），然后再与第五个车厢连接（成本 $3$），最后将两个形成的车厢组连接（成本 $5$）。\n\n**附加样例**\n\n1. $n=10, d=3, a=2, b=3$。\n2. $n=10^5, d=1000, a=3, b=5$。\n3. $n=10^{16}, d=300, a=3, b=5$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$    | $n \\leq 100000$          | $21$ |\n| $2$    | $d \\leq 300$             | $46$ |\n| $3$    | 无附加限制               | $33$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2022/2023 R2] 车厢 / Wagony", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/5022)。", "description": "**题目译自 [XXX Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi30-2/dashboard/) [Wagony](https://szkopul.edu.pl/problemset/problem/UtJx9fM6UT2oxXFenSPjiz5C/statement/)**\n\n在一维铁轨上停放着 $n$ 个车厢，初始时各车厢互不连接。每次操作可将相邻的两组已连接车厢合并，前提是两组车厢数量差不超过 $d$。合并耗时取决于两组车厢数量。你的任务是将所有车厢合并成一个含 $n$ 个车厢的列车。\n\n合并含 $w$ 个车厢的组与含 $v$ 个车厢的组（满足 $|w-v| \\leq d$）的成本由奇特函数 $(a w + b v) \\bmod 1001$ 计算。", "inputFormat": "第一行包含四个正整数 $n, d, a, b$ $(1 \\leq n \\leq 10^{16}, 1 \\leq d, a, b \\leq 1000)$，分别表示车厢总数、数量差上限和成本函数参数。", "outputFormat": "输出一个整数，表示将 $n$ 个车厢合并成一个列车的最小成本。", "hint": "**样例 1 解释**\n\n我们将第一个车厢与第二个车厢连接（成本 $2$），第三个车厢与第四个车厢连接（成本 $2$），然后再与第五个车厢连接（成本 $3$），最后将两个形成的车厢组连接（成本 $5$）。\n\n**附加样例**\n\n1. $n=10, d=3, a=2, b=3$。\n2. $n=10^5, d=1000, a=3, b=5$。\n3. $n=10^{16}, d=300, a=3, b=5$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$    | $n \\leq 100000$          | $21$ |\n| $2$    | $d \\leq 300$             | $46$ |\n| $3$    | 无附加限制               | $33$ |", "locale": "zh-CN"}}}
{"pid": "P12928", "type": "P", "difficulty": 4, "samples": [["3\n2 3 1", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "POI（波兰）", "2023", "位运算", "bitset"], "title": "[POI 2022/2023 R2] 伐木工人 / Drwale", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/5023)。", "description": "**题目译自 [XXX Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi30-2/dashboard/) [Drwale](https://szkopul.edu.pl/problemset/problem/fh8k3DcWsZB3OwD8rSLJw7SQ/statement/)**\n\n两位伐木工 Bajtek 和 Bitek 以相同速度砍伐 $n$ 块木材，初始堆放在一起。第 $i$ 块木材需耗时 $a_i$ 分钟。每次某位伐木工完成当前木材后，从堆顶取下一块。若两人同时完成，Bajtek 优先取木材。\n\n你的任务是计算在最不利排列下，伐木工完成所有砍伐的最晚时间。\n", "inputFormat": "第一行包含一个整数 $n$ $(1 \\leq n \\leq 10^6)$，表示木材数量。\n\n第二行包含 $n$ 个正整数 $a_1, a_2, \\ldots, a_n$，表示每块木材的砍伐时间。  \n\n设 $A = a_1 + a_2 + \\ldots + a_n$ 为总砍伐时间，满足 $A \\leq 5000000$。", "outputFormat": "输出一个整数，表示伐木工完成砍伐的最长可能时间。", "hint": "**样例 1 解释**\n\n若木材按顺序 $1, 2, 3$ 排列（耗时 $1, 2, 3$），可达结果 $4$。Bajtek 先取木材 $1$（耗时 $1$），Bitek 取木材 $2$（耗时 $2$）。$1$ 分钟后，Bajtek 取木材 $3$（耗时 $3$）。$4$ 分钟后，所有木材砍伐完成。\n\n**附加样例**\n\n1. $n=6, a_i = i$，答案为 $13$。  \n2. $n=1000, a_i = 1$，答案为 $500$。  \n3. $n=10, a_i = 2^{i-1}$，答案为 $767$。  \n4. $n=2, a_i = 2500000$，答案为 $2500000$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$    | $n \\leq 10$              | $5$  |\n| $2$    | $A \\leq 500$             | $15$ |\n| $3$    | $A \\leq 10000$           | $20$ |\n| $4$    | $A \\leq 100000$          | $20$ |\n| $5$    | $A \\leq 1000000$         | $20$ |\n| $6$    | 无附加限制               | $20$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2022/2023 R2] 伐木工人 / Drwale", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/5023)。", "description": "**题目译自 [XXX Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi30-2/dashboard/) [Drwale](https://szkopul.edu.pl/problemset/problem/fh8k3DcWsZB3OwD8rSLJw7SQ/statement/)**\n\n两位伐木工 Bajtek 和 Bitek 以相同速度砍伐 $n$ 块木材，初始堆放在一起。第 $i$ 块木材需耗时 $a_i$ 分钟。每次某位伐木工完成当前木材后，从堆顶取下一块。若两人同时完成，Bajtek 优先取木材。\n\n你的任务是计算在最不利排列下，伐木工完成所有砍伐的最晚时间。\n", "inputFormat": "第一行包含一个整数 $n$ $(1 \\leq n \\leq 10^6)$，表示木材数量。\n\n第二行包含 $n$ 个正整数 $a_1, a_2, \\ldots, a_n$，表示每块木材的砍伐时间。  \n\n设 $A = a_1 + a_2 + \\ldots + a_n$ 为总砍伐时间，满足 $A \\leq 5000000$。", "outputFormat": "输出一个整数，表示伐木工完成砍伐的最长可能时间。", "hint": "**样例 1 解释**\n\n若木材按顺序 $1, 2, 3$ 排列（耗时 $1, 2, 3$），可达结果 $4$。Bajtek 先取木材 $1$（耗时 $1$），Bitek 取木材 $2$（耗时 $2$）。$1$ 分钟后，Bajtek 取木材 $3$（耗时 $3$）。$4$ 分钟后，所有木材砍伐完成。\n\n**附加样例**\n\n1. $n=6, a_i = i$，答案为 $13$。  \n2. $n=1000, a_i = 1$，答案为 $500$。  \n3. $n=10, a_i = 2^{i-1}$，答案为 $767$。  \n4. $n=2, a_i = 2500000$，答案为 $2500000$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$    | $n \\leq 10$              | $5$  |\n| $2$    | $A \\leq 500$             | $15$ |\n| $3$    | $A \\leq 10000$           | $20$ |\n| $4$    | $A \\leq 100000$          | $20$ |\n| $5$    | $A \\leq 1000000$         | $20$ |\n| $6$    | 无附加限制               | $20$ |", "locale": "zh-CN"}}}
{"pid": "P12929", "type": "P", "difficulty": 5, "samples": [["4 4 2\n3 4 5 1\n1 2\n2 4\n1 3\n3 4", "13\n5\n6\n1"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["POI（波兰）", "2023", "状压 DP"], "title": "[POI 2022/2023 R2] 攀登 / Wspinaczka", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/5024)。", "description": "**题目译自 [XXX Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi30-2/dashboard/) [Wspinaczka](https://szkopul.edu.pl/problemset/problem/dqDbPTjXtS9KK9xXHD4qAiie/statement/)**\n\nBajtocka 山是 Bajtocja 的最高峰，沿途有一条风景如画的登山步道。步道上有 $n$ 个位于不同高度的林间空地，第 $i$ 个空地位于 $i$ 米高度。$m$ 条登山路径（有时为绕过某些空地的栈桥）连接这些空地，每条路径通向上方。每块空地有其摄影吸引力，用整数表示。\n\n为确保安全，禁止离开指定路径！此地天气瞬息万变，常有暴雨侵袭，游客只能在空地的专用凉亭避雨。因此，每条路径连接的空地高度差不超过 $k$ 米。\n\nBajtocka 摄影协会（BKF）的 $n$ 名摄影师计划登上 Bajtocka 山。他们将一起攀登至某空地 $p$，然后分散行动。每人仅沿登山路径向上移动，拍摄途经空地的照片（因技术限制，仅能在空地拍摄，无法在路径上拍出好照片）。每人可选择任意空地结束行程。\n\n最后，摄影师们会计算探险的风景值——所有拍摄空地的摄影吸引力之和（每块空地最多贡献一张照片的吸引力值）。\n\nBKF 尚未决定从哪块空地 $p$ 开始并分散。请帮助他们，为每种可能的 $p$ 选择计算从该空地开始探险的最大风景值。", "inputFormat": "第一行包含三个整数 $n, m, k$ $(2 \\leq n \\leq 100000, 1 \\leq m \\leq 800000, 1 \\leq k \\leq 8)$，分别表示空地数、路径数和路径最大高度差。\n\n第二行包含 $n$ 个整数 $f_1, \\ldots, f_n$ $(1 \\leq f_i \\leq 10^9)$，表示各空地的摄影吸引力。\n\n接下来的 $m$ 行，每行包含两个整数 $a_i, b_i$ $(1 \\leq a_i < b_i \\leq n, b_i \\leq a_i + k)$，表示从空地 $a_i$ 到 $b_i$ 的路径。路径互不相同。", "outputFormat": "输出 $n$ 行，第 $i$ 行包含一个整数，表示从空地 $p=i$ 开始并分散的最大风景值。", "hint": "**附加样例**\n\n1. $n=5, m=4, k=1$，$f_i = 2^{i-1}$。  \n2. $n=30, k=2$，$f_i = 998244353 - 2^{i-1}$，每块空地有路径到后两块空地（若存在）。  \n3. $n=1000, k=8$，$f_i = i$，每块空地有路径到编号不互质的空地。  \n4. $n=100000, k=8$，$f_i = 1$，空地间有路径当十进制表示有公共数字。  \n5. $n=100000, k=8$，每块空地有路径到距离为偶数的空地。\n\n所有测试数据均满足路径仅连接高度差不超过 $k$ 米的空地。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$    | 除最后空地外，每块空地向上有恰一条路径       | $10$ |\n| $2$    | $n \\leq 1000$                                | $10$ |\n| $3$    | $f_i = 1$ 对每个 $i$                         | $20$ |\n| $4$    | $k \\leq 2$                                   | $15$ |\n| $5$    | 无附加限制                                   | $45$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2022/2023 R2] 攀登 / Wspinaczka", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/5024)。", "description": "**题目译自 [XXX Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi30-2/dashboard/) [Wspinaczka](https://szkopul.edu.pl/problemset/problem/dqDbPTjXtS9KK9xXHD4qAiie/statement/)**\n\nBajtocka 山是 Bajtocja 的最高峰，沿途有一条风景如画的登山步道。步道上有 $n$ 个位于不同高度的林间空地，第 $i$ 个空地位于 $i$ 米高度。$m$ 条登山路径（有时为绕过某些空地的栈桥）连接这些空地，每条路径通向上方。每块空地有其摄影吸引力，用整数表示。\n\n为确保安全，禁止离开指定路径！此地天气瞬息万变，常有暴雨侵袭，游客只能在空地的专用凉亭避雨。因此，每条路径连接的空地高度差不超过 $k$ 米。\n\nBajtocka 摄影协会（BKF）的 $n$ 名摄影师计划登上 Bajtocka 山。他们将一起攀登至某空地 $p$，然后分散行动。每人仅沿登山路径向上移动，拍摄途经空地的照片（因技术限制，仅能在空地拍摄，无法在路径上拍出好照片）。每人可选择任意空地结束行程。\n\n最后，摄影师们会计算探险的风景值——所有拍摄空地的摄影吸引力之和（每块空地最多贡献一张照片的吸引力值）。\n\nBKF 尚未决定从哪块空地 $p$ 开始并分散。请帮助他们，为每种可能的 $p$ 选择计算从该空地开始探险的最大风景值。", "inputFormat": "第一行包含三个整数 $n, m, k$ $(2 \\leq n \\leq 100000, 1 \\leq m \\leq 800000, 1 \\leq k \\leq 8)$，分别表示空地数、路径数和路径最大高度差。\n\n第二行包含 $n$ 个整数 $f_1, \\ldots, f_n$ $(1 \\leq f_i \\leq 10^9)$，表示各空地的摄影吸引力。\n\n接下来的 $m$ 行，每行包含两个整数 $a_i, b_i$ $(1 \\leq a_i < b_i \\leq n, b_i \\leq a_i + k)$，表示从空地 $a_i$ 到 $b_i$ 的路径。路径互不相同。", "outputFormat": "输出 $n$ 行，第 $i$ 行包含一个整数，表示从空地 $p=i$ 开始并分散的最大风景值。", "hint": "**附加样例**\n\n1. $n=5, m=4, k=1$，$f_i = 2^{i-1}$。  \n2. $n=30, k=2$，$f_i = 998244353 - 2^{i-1}$，每块空地有路径到后两块空地（若存在）。  \n3. $n=1000, k=8$，$f_i = i$，每块空地有路径到编号不互质的空地。  \n4. $n=100000, k=8$，$f_i = 1$，空地间有路径当十进制表示有公共数字。  \n5. $n=100000, k=8$，每块空地有路径到距离为偶数的空地。\n\n所有测试数据均满足路径仅连接高度差不超过 $k$ 米的空地。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务编号 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$    | 除最后空地外，每块空地向上有恰一条路径       | $10$ |\n| $2$    | $n \\leq 1000$                                | $10$ |\n| $3$    | $f_i = 1$ 对每个 $i$                         | $20$ |\n| $4$    | $k \\leq 2$                                   | $15$ |\n| $5$    | 无附加限制                                   | $45$ |", "locale": "zh-CN"}}}
{"pid": "P12930", "type": "P", "difficulty": 5, "samples": [["12\n68 69 54 64 68 64 70 67\n78 62 98 87", "4 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "USACO", "树状数组"], "title": "[USACO4.3] 逢低吸纳 Buy Low, Buy Lower 加强版", "background": "[P2687](https://www.luogu.com.cn/problem/P2687) 加强版。在本题中，$N\\leq 10^6$，且输出方案数需要对 $10^9+7$ 取模。", "description": "“逢低吸纳”是炒股的一条成功秘诀。如果你想成为一个成功的投资者，就要遵守这条秘诀：“逢低吸纳，越低越买”。\n\n这句话的意思是：每次你购买股票时的股价一定要比你上次购买时的股价低。按照这个规则购买股票的次数越多越好，看看你最多能按这个规则买几次。\n\n给定连续的 $N$ 天中每天的股价。你可以在任何一天购买一次股票，但是购买时的股价一定要比你上次购买时的股价低。写一个程序，求出最多能买几次股票，和最优方案数对 $10^9+7$ 取模的结果。\n\n以下面这个表为例，某几天的股价是：\n\n|天数    |股价    |\n|:-------|:-------|\n|$1$|$68$|\n|$2$|$69$|\n|$3$|$54$|\n|$4$|$64$|\n|$5$|$68$|\n|$6$|$64$|\n|$7$|$70$|\n|$8$|$67$|\n|$9$|$78$|\n|$10$|$62$|\n|$11$|$98$|\n|$12$|$87$|\n\n\n这个例子中，如果每次买股票时的股价都比上一次买时低，那么最多能买 $4$ 次股票。一种买法如下（可能有其他的买法）：\n\n\n|天数    |股价    |\n|:-------|:-------|\n|$2$|$69$|\n|$5$|$68$|\n|$6$|$64$|\n|$10$|$62$|", "inputFormat": "第 $1$ 行：一个整数 $N$，表示能买股票的天数。\n\n以后多行，输入 $N$ 个非负整数（可能分多行），第 $i$ 个正整数表示第 $i$ 天的股价。这些非负整数大小不会超过 $2^{32}-1$。", "outputFormat": "一行两个整数，表示按每次买股票时的股价都比上一次买时低的要求最多能够买进股票的天数，和能够买进这些天数的股票的股票购买方案数量，对 $10^9+7$ 取模。\n\n两个方案不相同当且仅当这两个方案中所购买的股票的价格序列不相同。", "hint": "$1 \\le N \\le 10^6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO4.3] 逢低吸纳 Buy Low, Buy Lower 加强版", "background": "[P2687](https://www.luogu.com.cn/problem/P2687) 加强版。在本题中，$N\\leq 10^6$，且输出方案数需要对 $10^9+7$ 取模。", "description": "“逢低吸纳”是炒股的一条成功秘诀。如果你想成为一个成功的投资者，就要遵守这条秘诀：“逢低吸纳，越低越买”。\n\n这句话的意思是：每次你购买股票时的股价一定要比你上次购买时的股价低。按照这个规则购买股票的次数越多越好，看看你最多能按这个规则买几次。\n\n给定连续的 $N$ 天中每天的股价。你可以在任何一天购买一次股票，但是购买时的股价一定要比你上次购买时的股价低。写一个程序，求出最多能买几次股票，和最优方案数对 $10^9+7$ 取模的结果。\n\n以下面这个表为例，某几天的股价是：\n\n|天数    |股价    |\n|:-------|:-------|\n|$1$|$68$|\n|$2$|$69$|\n|$3$|$54$|\n|$4$|$64$|\n|$5$|$68$|\n|$6$|$64$|\n|$7$|$70$|\n|$8$|$67$|\n|$9$|$78$|\n|$10$|$62$|\n|$11$|$98$|\n|$12$|$87$|\n\n\n这个例子中，如果每次买股票时的股价都比上一次买时低，那么最多能买 $4$ 次股票。一种买法如下（可能有其他的买法）：\n\n\n|天数    |股价    |\n|:-------|:-------|\n|$2$|$69$|\n|$5$|$68$|\n|$6$|$64$|\n|$10$|$62$|", "inputFormat": "第 $1$ 行：一个整数 $N$，表示能买股票的天数。\n\n以后多行，输入 $N$ 个非负整数（可能分多行），第 $i$ 个正整数表示第 $i$ 天的股价。这些非负整数大小不会超过 $2^{32}-1$。", "outputFormat": "一行两个整数，表示按每次买股票时的股价都比上一次买时低的要求最多能够买进股票的天数，和能够买进这些天数的股票的股票购买方案数量，对 $10^9+7$ 取模。\n\n两个方案不相同当且仅当这两个方案中所购买的股票的价格序列不相同。", "hint": "$1 \\le N \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P12931", "type": "P", "difficulty": 4, "samples": [["5\n0 1 1 0 1", "2"], ["6\n500 20 900 0 900 70", "7"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "树状数组", "离散化", "NOISG（新加坡）"], "title": "[NOISG 2020 Prelim] Mountains", "background": "企鹅 Pengu 和他的朋友们生活在南极洲。虽然企鹅不会飞，但他们渴望体验翱翔天际的感觉。为了满足大家的愿望，Pengu 决定借助科技的力量——滑翔伞。", "description": "幸运的是，在南极横贯山脉中有 $n$ 座山峰。这些山峰从左到右依次编号为 $1$ 到 $n$，第 $i$ 座山峰的高度为 $H_i$。\n\nPengu 决定选择三座山峰 $x,y,z$，他打算在山峰 $y$ 上建立起飞站，在山峰 $x$ 和 $z$ 上分别设置接收站。企鹅们将从山峰 $y$ 滑翔至山峰 $x$ 或 $z$。\n\n为了容纳更多企鹅并避免空中相撞，山峰 $x$ 必须位于山峰 $y$ 左侧，山峰 $z$ 必须位于山峰 $y$ 右侧，并且山峰 $x$ 和 $z$ 的高度必须都**严格小于**山峰 $y$。\n\nPengu 非常严谨，他想统计所有满足条件的选择方案。请你帮他计算，满足以下条件的三元组 $(x,y,z)$ 有多少个：\n\n- $1 \\leq x < y < z \\leq n$；\n- $H_x < H_y$ 且 $H_z < H_y$。", "inputFormat": "第一行包含一个整数 $n$，表示山峰的数量。\n\n第二行包含 $n$ 个整数，第 $i$ 个整数表示第 $i$ 座山峰的高度 $H_i$。", "outputFormat": "输出一个整数，表示满足条件的方案总数。", "hint": "【样例解释】\n\n对于样例 #1：\n\n- 共有 $2$ 组满足条件的三元组：$(1,2,4)$、$(1,3,4)$。\n\n对于样例 #2：\n\n- 共有 $7$ 组满足条件的三元组：$(1,3,4)$、$(1,3,6)$、$(1,5,6)$、$(2,3,4)$、$(2,3,6)$、$(2,5,6)$、$(4,5,6)$。\n\n【数据范围】\n\n- $3 \\leq n \\leq 3 \\times 10^5$；\n- $0 \\leq H_i \\leq 10^{18}$。\n\n| 子任务编号 | 分值 |                      额外限制                       |\n| :--------: | :--: | :-------------------------------------------------: |\n|    $1$     | $2$  | $H_i$ 单调不减（即 $H_i \\leq H_j$，对任意 $i < j$） |\n|    $2$     | $4$  |                 $0 \\leq H_i \\leq 1$                 |\n|    $3$     | $9$  |                $0 \\leq H_i \\leq 99$                 |\n|    $4$     | $36$ |                    $n \\leq 500$                     |\n|    $5$     | $28$ |                    $n \\leq 10^4$                    |\n|    $6$     | $9$  |               $0 \\leq H_i \\leq 10^5$                |\n|    $7$     | $12$ |                     无额外限制                      |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2020 Prelim] Mountains", "background": "企鹅 Pengu 和他的朋友们生活在南极洲。虽然企鹅不会飞，但他们渴望体验翱翔天际的感觉。为了满足大家的愿望，Pengu 决定借助科技的力量——滑翔伞。", "description": "幸运的是，在南极横贯山脉中有 $n$ 座山峰。这些山峰从左到右依次编号为 $1$ 到 $n$，第 $i$ 座山峰的高度为 $H_i$。\n\nPengu 决定选择三座山峰 $x,y,z$，他打算在山峰 $y$ 上建立起飞站，在山峰 $x$ 和 $z$ 上分别设置接收站。企鹅们将从山峰 $y$ 滑翔至山峰 $x$ 或 $z$。\n\n为了容纳更多企鹅并避免空中相撞，山峰 $x$ 必须位于山峰 $y$ 左侧，山峰 $z$ 必须位于山峰 $y$ 右侧，并且山峰 $x$ 和 $z$ 的高度必须都**严格小于**山峰 $y$。\n\nPengu 非常严谨，他想统计所有满足条件的选择方案。请你帮他计算，满足以下条件的三元组 $(x,y,z)$ 有多少个：\n\n- $1 \\leq x < y < z \\leq n$；\n- $H_x < H_y$ 且 $H_z < H_y$。", "inputFormat": "第一行包含一个整数 $n$，表示山峰的数量。\n\n第二行包含 $n$ 个整数，第 $i$ 个整数表示第 $i$ 座山峰的高度 $H_i$。", "outputFormat": "输出一个整数，表示满足条件的方案总数。", "hint": "【样例解释】\n\n对于样例 #1：\n\n- 共有 $2$ 组满足条件的三元组：$(1,2,4)$、$(1,3,4)$。\n\n对于样例 #2：\n\n- 共有 $7$ 组满足条件的三元组：$(1,3,4)$、$(1,3,6)$、$(1,5,6)$、$(2,3,4)$、$(2,3,6)$、$(2,5,6)$、$(4,5,6)$。\n\n【数据范围】\n\n- $3 \\leq n \\leq 3 \\times 10^5$；\n- $0 \\leq H_i \\leq 10^{18}$。\n\n| 子任务编号 | 分值 |                      额外限制                       |\n| :--------: | :--: | :-------------------------------------------------: |\n|    $1$     | $2$  | $H_i$ 单调不减（即 $H_i \\leq H_j$，对任意 $i < j$） |\n|    $2$     | $4$  |                 $0 \\leq H_i \\leq 1$                 |\n|    $3$     | $9$  |                $0 \\leq H_i \\leq 99$                 |\n|    $4$     | $36$ |                    $n \\leq 500$                     |\n|    $5$     | $28$ |                    $n \\leq 10^4$                    |\n|    $6$     | $9$  |               $0 \\leq H_i \\leq 10^5$                |\n|    $7$     | $12$ |                     无额外限制                      |", "locale": "zh-CN"}}}
{"pid": "P12932", "type": "P", "difficulty": 5, "samples": [["1 5 3 -5 -4\n10\n1 1 1 1 1\n1 1 1", "30"], ["1 3 5 -10 -5\n10\n1 1 1\n1 1 1 1 1", "10"], ["4 7 4 0 0\n1 2 3 4\n3 1 2 1 4 1 1\n1 2 3 4", "7"], ["4 8 4 0 -3\n1 2 3 4\n3 1 2 1 1 4 1 1\n1 2 3 4", "-1"], ["4 8 4 -3 0\n1 2 3 4\n3 1 2 1 1 4 1 1\n1 2 3 4", "2"], ["6 10 6 -2 -1\n1 2 3 4 5 6\n3 1 5 2 6 1 5 1 1 4\n1 2 3 4 5 6", "4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "NOISG（新加坡）"], "title": "[NOISG 2020 Prelim] Visiting Singapore", "background": "", "description": "新加坡每天都会举办一场活动，记 $Σ = \\{1, 2, \\ldots, K\\}$ 表示所有可能的活动集合。参加第 $i$ 个活动可以让你的幸福值增加 $V[i]$。\n\n假设连续 $n$ 天内举办的活动依次为 $S[1], S[2], \\ldots, S[n]$（同一活动可能多次出现）。\n\n你想依次参加 $m$ 个指定活动 $T[1], T[2], \\ldots, T[m]$（同样可能重复）。因此，你计划选择某一天飞往新加坡，第 $i$ 天到达，第 $j$ 天离开。你也可以选择不去新加坡。\n\n在新加坡停留期间，你尝试依次完成 $T[1]$ 至 $T[m]$ 的活动：\n\n- 成功参加第 $T[i]$ 个活动，幸福值增加 $V[T[i]]$；\n- 若跳过连续的 $T[p]$ 至 $T[q]$，幸福值减少 $A + (q - p + 1)B$；\n- 此外，在新加坡期间，若连续 $d$ 天未参加任何活动，幸福值减少 $A + dB$。更具体地说，若你仅在第 $p$ 天和第 $q$ 天参加了活动，且 $q \\geq p + 2$，中间未参加任何活动，幸福值减少 $A + (q - p - 1)B$。\n\n你想最大化自己的幸福值。请计算最大可能的幸福值。", "inputFormat": "第一行包含五个整数 $K, n, m, A, B$，含义如下：\n\n- $K$：活动种类数；\n- $n$：总天数；\n- $m$：目标活动数量；\n- $A, B$：负数，分别表示跳过惩罚参数。\n\n第二行包含 $K$ 个正整数，第 $i$ 个整数表示第 $i$ 个活动带来的幸福值 $V[i]$。\n\n第三行包含 $n$ 个整数，第 $i$ 个整数 $S[i]$ 表示第 $i$ 天举办的活动，范围 $1 \\sim K$。\n\n第四行包含 $m$ 个整数，第 $i$ 个整数 $T[i]$ 表示你计划依次参加的活动，范围 $1 \\sim K$。\n", "outputFormat": "输出一行，表示在最优安排下可以获得的最大幸福值。", "hint": "【样例解释】\n\n对于样例 #1：\n\n在这个例子中，$K = 1,\\ n = 5,\\ m = 3,\\ A = -5,\\ B = -4$。\n由于只有一种类型的活动，且 $m \\leq n$，一种可行的最优方案是第 $1$ 天去新加坡，第 $m$ 天离开。\n\n由于每个活动的幸福值是 $10$，且 $m = 3$，所以最优幸福值是 $30$。\n\n对于样例 #2：\n\n由于只有一种类型的活动，且 $n > m$，一种可行的最优方案是第 $1$ 天去新加坡，第 $n$ 天离开。\n同时，我们需要跳过 $T[m - n + 1]$ 到 $T[n]$ 这几个目标活动。\n\n由于每个活动的幸福值是 $10$，$n = 3,\\ m = 5$，因此前 $3$ 个目标活动可以尝试，获得幸福值 $10 \\times 3 = 30$。\n跳过最后 $2$ 个目标活动，幸福值减少 $A + 2B = -10 + 2(-5) = -20$。\n\n因此，总幸福值是 $10$。\n\n对于样例 #3：\n\n最优方案是尝试第 $2$ 天的 $S[2] = 1$，第 $3$ 天的 $S[3] = 2$ 和第 $5$ 天的 $S[5] = 4$。\n获得的幸福值是 $1 + 2 + 4 = 7$。\n\n对于样例 #4：\n\n最优方案是尝试第 $5$ 天的 $S[5] = 1$ 和第 $6$ 天的 $S[6] = 4$。\n幸福值是 $1 + 4 - (2 \\times 3) = -1$。\n\n对于样例 #5：\n\n最优方案是尝试第 $5$ 天的 $S[5] = 1$ 和第 $6$ 天的 $S[6] = 4$。\n跳过 $T[2]$ 和 $T[3]$，幸福值减少 $-3$。\n幸福值是 $1 + 4 - 3 = 2$。\n\n对于样例 #6：\n\n最优方案是在第 $2$ 天到达新加坡，第 $5$ 天离开。\n该方案尝试了第 $2$ 天的 $S[2] = 1$，第 $3$ 天的 $S[3] = 5$ 和第 $5$ 天的 $S[5] = 6$。\n我们跳过了 $T[2]$ 到 $T[4]$，因此幸福值减少 $-2 + 3 \\times (-1) = -5$。\n我们跳过了第 $4$ 天，幸福值减少 $-2 + (-1) = -3$。\n幸福值是 $1 + 5 + 6 - 5 - 3 = 4$。\n\n【数据范围】\n\n- $1 \\leq K \\leq 1000$\n- $1 \\leq n, m \\leq 5000$\n- $-100 \\leq A, B \\leq 0$\n- $1 \\leq V[i] \\leq 100$\n\n| 子任务编号 | 分值 |           额外限制           |\n| :--------: | :--: | :--------------------------: |\n|    $1$     | $4$  | $K = 1,\\ m \\leq n \\leq 10^3$ |\n|    $2$     | $6$  |  $K = 1,\\ n < m \\leq 10^3$   |\n|    $3$     | $12$ |         $A = B = 0$          |\n|    $4$     | $7$  |           $A = 0$            |\n|    $5$     | $8$  |           $B = 0$            |\n|    $6$     | $13$ |        $n,\\ m < 100$         |\n|    $7$     | $50$ |          无额外限制          |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2020 Prelim] Visiting Singapore", "background": "", "description": "新加坡每天都会举办一场活动，记 $Σ = \\{1, 2, \\ldots, K\\}$ 表示所有可能的活动集合。参加第 $i$ 个活动可以让你的幸福值增加 $V[i]$。\n\n假设连续 $n$ 天内举办的活动依次为 $S[1], S[2], \\ldots, S[n]$（同一活动可能多次出现）。\n\n你想依次参加 $m$ 个指定活动 $T[1], T[2], \\ldots, T[m]$（同样可能重复）。因此，你计划选择某一天飞往新加坡，第 $i$ 天到达，第 $j$ 天离开。你也可以选择不去新加坡。\n\n在新加坡停留期间，你尝试依次完成 $T[1]$ 至 $T[m]$ 的活动：\n\n- 成功参加第 $T[i]$ 个活动，幸福值增加 $V[T[i]]$；\n- 若跳过连续的 $T[p]$ 至 $T[q]$，幸福值减少 $A + (q - p + 1)B$；\n- 此外，在新加坡期间，若连续 $d$ 天未参加任何活动，幸福值减少 $A + dB$。更具体地说，若你仅在第 $p$ 天和第 $q$ 天参加了活动，且 $q \\geq p + 2$，中间未参加任何活动，幸福值减少 $A + (q - p - 1)B$。\n\n你想最大化自己的幸福值。请计算最大可能的幸福值。", "inputFormat": "第一行包含五个整数 $K, n, m, A, B$，含义如下：\n\n- $K$：活动种类数；\n- $n$：总天数；\n- $m$：目标活动数量；\n- $A, B$：负数，分别表示跳过惩罚参数。\n\n第二行包含 $K$ 个正整数，第 $i$ 个整数表示第 $i$ 个活动带来的幸福值 $V[i]$。\n\n第三行包含 $n$ 个整数，第 $i$ 个整数 $S[i]$ 表示第 $i$ 天举办的活动，范围 $1 \\sim K$。\n\n第四行包含 $m$ 个整数，第 $i$ 个整数 $T[i]$ 表示你计划依次参加的活动，范围 $1 \\sim K$。\n", "outputFormat": "输出一行，表示在最优安排下可以获得的最大幸福值。", "hint": "【样例解释】\n\n对于样例 #1：\n\n在这个例子中，$K = 1,\\ n = 5,\\ m = 3,\\ A = -5,\\ B = -4$。\n由于只有一种类型的活动，且 $m \\leq n$，一种可行的最优方案是第 $1$ 天去新加坡，第 $m$ 天离开。\n\n由于每个活动的幸福值是 $10$，且 $m = 3$，所以最优幸福值是 $30$。\n\n对于样例 #2：\n\n由于只有一种类型的活动，且 $n > m$，一种可行的最优方案是第 $1$ 天去新加坡，第 $n$ 天离开。\n同时，我们需要跳过 $T[m - n + 1]$ 到 $T[n]$ 这几个目标活动。\n\n由于每个活动的幸福值是 $10$，$n = 3,\\ m = 5$，因此前 $3$ 个目标活动可以尝试，获得幸福值 $10 \\times 3 = 30$。\n跳过最后 $2$ 个目标活动，幸福值减少 $A + 2B = -10 + 2(-5) = -20$。\n\n因此，总幸福值是 $10$。\n\n对于样例 #3：\n\n最优方案是尝试第 $2$ 天的 $S[2] = 1$，第 $3$ 天的 $S[3] = 2$ 和第 $5$ 天的 $S[5] = 4$。\n获得的幸福值是 $1 + 2 + 4 = 7$。\n\n对于样例 #4：\n\n最优方案是尝试第 $5$ 天的 $S[5] = 1$ 和第 $6$ 天的 $S[6] = 4$。\n幸福值是 $1 + 4 - (2 \\times 3) = -1$。\n\n对于样例 #5：\n\n最优方案是尝试第 $5$ 天的 $S[5] = 1$ 和第 $6$ 天的 $S[6] = 4$。\n跳过 $T[2]$ 和 $T[3]$，幸福值减少 $-3$。\n幸福值是 $1 + 4 - 3 = 2$。\n\n对于样例 #6：\n\n最优方案是在第 $2$ 天到达新加坡，第 $5$ 天离开。\n该方案尝试了第 $2$ 天的 $S[2] = 1$，第 $3$ 天的 $S[3] = 5$ 和第 $5$ 天的 $S[5] = 6$。\n我们跳过了 $T[2]$ 到 $T[4]$，因此幸福值减少 $-2 + 3 \\times (-1) = -5$。\n我们跳过了第 $4$ 天，幸福值减少 $-2 + (-1) = -3$。\n幸福值是 $1 + 5 + 6 - 5 - 3 = 4$。\n\n【数据范围】\n\n- $1 \\leq K \\leq 1000$\n- $1 \\leq n, m \\leq 5000$\n- $-100 \\leq A, B \\leq 0$\n- $1 \\leq V[i] \\leq 100$\n\n| 子任务编号 | 分值 |           额外限制           |\n| :--------: | :--: | :--------------------------: |\n|    $1$     | $4$  | $K = 1,\\ m \\leq n \\leq 10^3$ |\n|    $2$     | $6$  |  $K = 1,\\ n < m \\leq 10^3$   |\n|    $3$     | $12$ |         $A = B = 0$          |\n|    $4$     | $7$  |           $A = 0$            |\n|    $5$     | $8$  |           $B = 0$            |\n|    $6$     | $13$ |        $n,\\ m < 100$         |\n|    $7$     | $50$ |          无额外限制          |", "locale": "zh-CN"}}}
{"pid": "P12933", "type": "P", "difficulty": 4, "samples": [["6 2 7\n10 4 7 18 11\n5 8 2 4 8 12", "2\n3 5"], ["6 2 38\n10 4 7 18 11\n5 8 2 4 8 12", "1\n4"], ["6 1 12\n10 4 7 18 11\n5 8 2 4 8 12", "1\n5"], ["12 1 2\n1 1 1 1 1 1 1 1 1 1 1\n1 2 3 4 5 6 6 5 4 3 2 1", "1\n6"], ["10 3 1\n2 2 2 2 2 2 2 2 2\n3 7 5 6 8 4 3 2 2 9", "3\n3 4 5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "树形数据结构", "2020", "Special Judge", "双指针 two-pointer", "NOISG（新加坡）"], "title": "[NOISG 2020 Prelim] Solar Storm", "background": "", "description": "Squeaky 老鼠是宇宙飞船的船长，正在执行探索太阳系边界的任务。飞船呈长条状，沿着飞船的长度方向有一条笔直的通道，$N$ 个舱室连接在通道的不同位置。舱室从左到右编号为 $1$ 到 $N$，相邻舱室之间的距离不一定相等。\n\n每个舱室 $i$（$1 \\leq i \\leq N$）中都有重要的设备，用于支持飞船的运行，设备的重要性用正整数 $v_i$ 表示。相邻舱室之间有电缆连接，设备可以通过其他舱室远程控制。\n\n然而，一场太阳风暴即将袭击飞船！太阳风暴会释放大量带电粒子，如果不加保护，将会损坏飞船上的设备。\n\n幸运的是，船员随船携带了 $S$ 个防护盾。每个防护盾可以放置在任意舱室，也可以选择不使用。每个防护盾能在其所在位置产生磁场，保护半径为 $K$ 米，半径范围内的所有舱室设备都能被保护（包括防护盾所在的舱室）。\n\n需要注意：\n\n- 通道本身无需保护，因为电缆不受带电粒子的影响；\n- 为了方便后续操作，Squeaky 希望所有被保护的舱室之间可以相互控制设备；\n- 具体而言，如果两个被保护的舱室之间存在未被保护的舱室，则无法相互控制设备，这是不允许的。\n\n请你作为工程师，帮助 Squeaky 确定防护盾的最优放置方案，最大化被保护舱室的重要性总和，并保证控制连通性。", "inputFormat": "第一行三个整数 $N,\\ S,\\ K$，分别表示舱室数量、防护盾数量、防护盾的保护半径（单位：米）。\n\n第二行 $N - 1$ 个整数 $d_i$，第 $i$ 个舱室与第 $i+1$ 个舱室之间的距离。\n\n第三行 $N$ 个整数 $v_i$，第 $i$ 个舱室的重要性。\n", "outputFormat": "第一行一个整数 $T$，表示实际使用的防护盾数量，$0 \\leq T \\leq S$。\n\n第二行 $T$ 个整数，表示放置防护盾的舱室编号，顺序不限。若有多种方案都能达到最优，输出任意一种均可。\n", "hint": "【样例解释】\n\n对于样例 #1：  \n\n飞船的结构如下：  \n\n部署两个防护盾的最优位置是在第 $3$ 和第 $5$ 个舱室。  \n\n第 $3$ 个舱室的防护盾将保护第 $2, 3, 4$ 个舱室；第 $5$ 个舱室的防护盾将保护第 $5$ 个舱室。  \n\n注意，舱室 $4$ 和 $5$ 之间的通道没有完全被保护，这是允许的，因为通道上的电缆不会受到损害。  \n\n请注意，如果将两个防护盾部署在第 $3$ 和第 $6$ 个舱室，这不是一个合法方案，因为第 $5$ 个舱室会被太阳风暴损坏，导致第 $6$ 个舱室的船员无法控制第 $2, 3, 4$ 个舱室的设备。  \n\n对于样例 #2：  \n\n飞船的结构与样例 $1$ 相同，但防护盾的半径更大。  \n\n在第 $4$ 个舱室部署一个防护盾足以保护所有舱室。  \n\n注意，还有许多其他可接受的方案。  \n\n其他一些可选方案包括：  \n- 仅在第 $3$ 个舱室部署一个防护盾；  \n- 分别在第 $3$ 和第 $5$ 个舱室各部署一个防护盾；  \n- 在第 $3$ 个舱室部署两个防护盾。  \n\n所有能够最大化被保护舱室总重要性的合法方案都会被接受。  \n\n对于样例 #3：  \n\n飞船的结构与样例 $1$ 相同。  \n\n在第 $5$ 个舱室部署防护盾可以保护第 $5$ 和第 $6$ 个舱室，这是最优方案。  \n\n注意，同样也可以选择将防护盾部署在第 $6$ 个舱室，这也是最优的。  \n\n对于样例 #4：  \n\n最优方案是在第 $6$ 个舱室部署防护盾，这将保护第 $4, 5, 6, 7, 8$ 个舱室。  \n\n注意，同样也可以选择在第 $7$ 个舱室部署防护盾，这也是最优的。  \n\n对于样例 #5：  \n\n部署三个防护盾的最优位置是第 $3, 4, 5$ 个舱室。  \n\n【数据范围】\n\n- $1 \\leq S \\leq N \\leq 10^6$  \n- $1 \\leq K \\leq 10^{12}$  \n- $1 \\leq d_i \\leq 10^6$  \n- $1 \\leq v_i \\leq 10^6$  \n\n| 子任务编号 | 分值 |                           附加限制                           |\n| :--------: | :--: | :----------------------------------------------------------: |\n|    $1$     | $10$ | $S = 1,\\ N \\leq 10^4,\\ K \\leq 10^9,\\ d_i \\leq 10^5,\\ v_i \\leq 10^5$ |\n|    $2$     | $7$  |                      $S = 1,\\ d_i = 1$                       |\n|    $3$     | $11$ |                           $S = 1$                            |\n|    $4$     | $8$  |                      $K = 1,\\ d_i = 2$                       |\n|    $5$     | $18$ |                        $N \\leq 10^4$                         |\n|    $6$     | $16$ |                         $S \\leq 50$                          |\n|    $7$     | $30$ |                          无附加限制                          |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2020 Prelim] Solar Storm", "background": "", "description": "Squeaky 老鼠是宇宙飞船的船长，正在执行探索太阳系边界的任务。飞船呈长条状，沿着飞船的长度方向有一条笔直的通道，$N$ 个舱室连接在通道的不同位置。舱室从左到右编号为 $1$ 到 $N$，相邻舱室之间的距离不一定相等。\n\n每个舱室 $i$（$1 \\leq i \\leq N$）中都有重要的设备，用于支持飞船的运行，设备的重要性用正整数 $v_i$ 表示。相邻舱室之间有电缆连接，设备可以通过其他舱室远程控制。\n\n然而，一场太阳风暴即将袭击飞船！太阳风暴会释放大量带电粒子，如果不加保护，将会损坏飞船上的设备。\n\n幸运的是，船员随船携带了 $S$ 个防护盾。每个防护盾可以放置在任意舱室，也可以选择不使用。每个防护盾能在其所在位置产生磁场，保护半径为 $K$ 米，半径范围内的所有舱室设备都能被保护（包括防护盾所在的舱室）。\n\n需要注意：\n\n- 通道本身无需保护，因为电缆不受带电粒子的影响；\n- 为了方便后续操作，Squeaky 希望所有被保护的舱室之间可以相互控制设备；\n- 具体而言，如果两个被保护的舱室之间存在未被保护的舱室，则无法相互控制设备，这是不允许的。\n\n请你作为工程师，帮助 Squeaky 确定防护盾的最优放置方案，最大化被保护舱室的重要性总和，并保证控制连通性。", "inputFormat": "第一行三个整数 $N,\\ S,\\ K$，分别表示舱室数量、防护盾数量、防护盾的保护半径（单位：米）。\n\n第二行 $N - 1$ 个整数 $d_i$，第 $i$ 个舱室与第 $i+1$ 个舱室之间的距离。\n\n第三行 $N$ 个整数 $v_i$，第 $i$ 个舱室的重要性。\n", "outputFormat": "第一行一个整数 $T$，表示实际使用的防护盾数量，$0 \\leq T \\leq S$。\n\n第二行 $T$ 个整数，表示放置防护盾的舱室编号，顺序不限。若有多种方案都能达到最优，输出任意一种均可。\n", "hint": "【样例解释】\n\n对于样例 #1：  \n\n飞船的结构如下：  \n\n部署两个防护盾的最优位置是在第 $3$ 和第 $5$ 个舱室。  \n\n第 $3$ 个舱室的防护盾将保护第 $2, 3, 4$ 个舱室；第 $5$ 个舱室的防护盾将保护第 $5$ 个舱室。  \n\n注意，舱室 $4$ 和 $5$ 之间的通道没有完全被保护，这是允许的，因为通道上的电缆不会受到损害。  \n\n请注意，如果将两个防护盾部署在第 $3$ 和第 $6$ 个舱室，这不是一个合法方案，因为第 $5$ 个舱室会被太阳风暴损坏，导致第 $6$ 个舱室的船员无法控制第 $2, 3, 4$ 个舱室的设备。  \n\n对于样例 #2：  \n\n飞船的结构与样例 $1$ 相同，但防护盾的半径更大。  \n\n在第 $4$ 个舱室部署一个防护盾足以保护所有舱室。  \n\n注意，还有许多其他可接受的方案。  \n\n其他一些可选方案包括：  \n- 仅在第 $3$ 个舱室部署一个防护盾；  \n- 分别在第 $3$ 和第 $5$ 个舱室各部署一个防护盾；  \n- 在第 $3$ 个舱室部署两个防护盾。  \n\n所有能够最大化被保护舱室总重要性的合法方案都会被接受。  \n\n对于样例 #3：  \n\n飞船的结构与样例 $1$ 相同。  \n\n在第 $5$ 个舱室部署防护盾可以保护第 $5$ 和第 $6$ 个舱室，这是最优方案。  \n\n注意，同样也可以选择将防护盾部署在第 $6$ 个舱室，这也是最优的。  \n\n对于样例 #4：  \n\n最优方案是在第 $6$ 个舱室部署防护盾，这将保护第 $4, 5, 6, 7, 8$ 个舱室。  \n\n注意，同样也可以选择在第 $7$ 个舱室部署防护盾，这也是最优的。  \n\n对于样例 #5：  \n\n部署三个防护盾的最优位置是第 $3, 4, 5$ 个舱室。  \n\n【数据范围】\n\n- $1 \\leq S \\leq N \\leq 10^6$  \n- $1 \\leq K \\leq 10^{12}$  \n- $1 \\leq d_i \\leq 10^6$  \n- $1 \\leq v_i \\leq 10^6$  \n\n| 子任务编号 | 分值 |                           附加限制                           |\n| :--------: | :--: | :----------------------------------------------------------: |\n|    $1$     | $10$ | $S = 1,\\ N \\leq 10^4,\\ K \\leq 10^9,\\ d_i \\leq 10^5,\\ v_i \\leq 10^5$ |\n|    $2$     | $7$  |                      $S = 1,\\ d_i = 1$                       |\n|    $3$     | $11$ |                           $S = 1$                            |\n|    $4$     | $8$  |                      $K = 1,\\ d_i = 2$                       |\n|    $5$     | $18$ |                        $N \\leq 10^4$                         |\n|    $6$     | $16$ |                         $S \\leq 50$                          |\n|    $7$     | $30$ |                          无附加限制                          |", "locale": "zh-CN"}}}
{"pid": "P12934", "type": "P", "difficulty": 5, "samples": [["2\n5 7 1\n1 9 2", "5"], ["3\n1 10 4\n6 12 3\n9 13 2", "4"], ["3\n1 13 4\n6 11 2\n9 13 3", "4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Apprentice Learning Trajectory", "background": "", "description": "Abigail is an apprentice studying to become a blacksmith. She wants to plan her learning trajectory and make as many swords as possible on her way to becoming a famous expert.\n\nThere are $n$ masters willing to host her as their apprentice. The $i$-th master will start working at the minute $a_i$ and end working at the minute $b_i$, working for a total of $b_i - a_i$ minutes. During this interval of time, Abigail can work at this master's forge. She can enter and leave the forge several times and produce one or several swords upon each arrival. However, in order to produce a sword under supervision of the $i$-th master she has to work there for $t_i$ minutes in a row. She can't leave the sword unfinished and continue working on it upon her next arrival to this forge.\n\nHelp Abigail make an optimal plan and calculate the maximum number of swords she can produce under the supervision of $n$ masters.", "inputFormat": "The first line contains integer $n$ ($1 \\le n \\le 200\\,000$) --- the number of masters.\n\nEach of the next $n$ lines contains three integers $a_i, b_i, t_i$ ($1 \\le a_i < a_i + t_i \\le b_i \\le 10^{18}$) --- the start and the end time of master's work, and the time needed to make one sword in their forge.", "outputFormat": "Output the maximum number of swords Abigail can produce using the optimal learning trajectory.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/pt30ioq8.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Apprentice Learning Trajectory", "background": "", "description": "Abigail is an apprentice studying to become a blacksmith. She wants to plan her learning trajectory and make as many swords as possible on her way to becoming a famous expert.\n\nThere are $n$ masters willing to host her as their apprentice. The $i$-th master will start working at the minute $a_i$ and end working at the minute $b_i$, working for a total of $b_i - a_i$ minutes. During this interval of time, Abigail can work at this master's forge. She can enter and leave the forge several times and produce one or several swords upon each arrival. However, in order to produce a sword under supervision of the $i$-th master she has to work there for $t_i$ minutes in a row. She can't leave the sword unfinished and continue working on it upon her next arrival to this forge.\n\nHelp Abigail make an optimal plan and calculate the maximum number of swords she can produce under the supervision of $n$ masters.", "inputFormat": "The first line contains integer $n$ ($1 \\le n \\le 200\\,000$) --- the number of masters.\n\nEach of the next $n$ lines contains three integers $a_i, b_i, t_i$ ($1 \\le a_i < a_i + t_i \\le b_i \\le 10^{18}$) --- the start and the end time of master's work, and the time needed to make one sword in their forge.", "outputFormat": "Output the maximum number of swords Abigail can produce using the optimal learning trajectory.", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/pt30ioq8.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Apprentice Learning Trajectory", "background": "", "description": "Abigail 是一名学徒，正在学习成为一名铁匠。她希望规划自己的学习轨迹，并在成为著名专家的道路上尽可能多地锻造剑。\n\n共有 $n$ 位大师愿意收她为徒。第 $i$ 位大师将在第 $a_i$ 分钟开始工作，并在第 $b_i$ 分钟结束工作，总共工作 $b_i - a_i$ 分钟。在这段时间内，Abigail 可以在这位大师的铁匠铺中工作。她可以多次进入和离开铁匠铺，并在每次到达时锻造一把或多把剑。然而，为了在第 $i$ 位大师的指导下锻造一把剑，她必须连续工作 $t_i$ 分钟。她不能留下未完成的剑，并在下次到达铁匠铺时继续锻造。\n\n请帮助 Abigail 制定一个最优计划，并计算她在 $n$ 位大师的指导下可以锻造的剑的最大数量。", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 200\\,000$）—— 大师的数量。\n\n接下来的 $n$ 行，每行包含三个整数 $a_i$, $b_i$, $t_i$（$1 \\le a_i < a_i + t_i \\le b_i \\le 10^{18}$）—— 大师工作的开始和结束时间，以及在其铁匠铺中锻造一把剑所需的时间。\n", "outputFormat": "输出 Abigail 使用最优学习轨迹可以锻造的剑的最大数量。\n", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/pt30ioq8.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12935", "type": "P", "difficulty": 3, "samples": [["BBWWBB", "3"], ["BWWB", "0"], ["BBWBB", "0"], ["OOOWWW", "0"], ["WWWOOOOOOWWW", "7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Balls of Buma", "background": "", "description": "Balph is learning to play a game called Buma. In this game, he is given a row of colored balls. He has to choose the color of one new ball and the place to insert it (between two balls, or to the left of all the balls, or to the right of all the balls).\n\nWhen the ball is inserted the following happens repeatedly: if some segment of balls of the same color became longer as a result of a previous action and its length became at least $3$, then all the balls of this segment are eliminated. \n\nConsider, for example, a row of balls $\\tt{AAABBBWWBB}$. Suppose Balph chooses a ball of color $\\tt{W}$ and the place to insert it after the sixth ball, i.e. to the left of the two $\\tt{W}$ s. After Balph inserts this ball, the balls of color $\\tt{W}$ are eliminated, since this segment was made longer and has length $3$ now, so the row becomes $\\texttt{AAABBBBB}$. The balls of color $\\tt{B}$ are eliminated now, because the segment of balls of color $\\tt{B}$ became longer and has length $5$ now. Thus, the row becomes $\\texttt{AAA}$. However, none of the balls are eliminated now, because there is no elongated segment.\n\nHelp Balph count the number of possible ways to choose a color of a new ball and a place to insert it that leads to the elimination of all the balls.", "inputFormat": "The only line contains a non-empty string of uppercase English letters of length at most $3 \\cdot 10^5$. Each letter represents a ball with the corresponding color.", "outputFormat": "Output the number of ways to choose a color and a position of a new ball in order to eliminate all the balls.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Balls of Buma", "background": "", "description": "Balph is learning to play a game called Buma. In this game, he is given a row of colored balls. He has to choose the color of one new ball and the place to insert it (between two balls, or to the left of all the balls, or to the right of all the balls).\n\nWhen the ball is inserted the following happens repeatedly: if some segment of balls of the same color became longer as a result of a previous action and its length became at least $3$, then all the balls of this segment are eliminated. \n\nConsider, for example, a row of balls $\\tt{AAABBBWWBB}$. Suppose Balph chooses a ball of color $\\tt{W}$ and the place to insert it after the sixth ball, i.e. to the left of the two $\\tt{W}$ s. After Balph inserts this ball, the balls of color $\\tt{W}$ are eliminated, since this segment was made longer and has length $3$ now, so the row becomes $\\texttt{AAABBBBB}$. The balls of color $\\tt{B}$ are eliminated now, because the segment of balls of color $\\tt{B}$ became longer and has length $5$ now. Thus, the row becomes $\\texttt{AAA}$. However, none of the balls are eliminated now, because there is no elongated segment.\n\nHelp Balph count the number of possible ways to choose a color of a new ball and a place to insert it that leads to the elimination of all the balls.", "inputFormat": "The only line contains a non-empty string of uppercase English letters of length at most $3 \\cdot 10^5$. Each letter represents a ball with the corresponding color.", "outputFormat": "Output the number of ways to choose a color and a position of a new ball in order to eliminate all the balls.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Balls of Buma", "background": "", "description": "Balph 正在学习玩一款名为 Buma 的游戏。在这个游戏中，他会得到一排彩色球。他需要选择一个新球的颜色以及插入的位置（在两个球之间、所有球的左侧或所有球的右侧）。\n\n当球被插入后，以下情况会反复发生：如果某个颜色相同的球段由于之前的操作变长，并且其长度达到至少 $3$，那么该球段的所有球都会被消除。\n\n例如，考虑一排球 $\\tt{AAABBBWWBB}$。假设 Balph 选择了一个颜色为 $\\tt{W}$ 的球，并将其插入到第六个球之后，即两个 $\\tt{W}$ 的左侧。在 Balph 插入这个球后，$\\tt{W}$ 颜色的球段变长，长度变为 $3$，因此这些球会被消除，此时球排变为 $\\texttt{AAABBBBB}$。接着，$\\tt{B}$ 颜色的球段变长，长度变为 $5$，因此这些球也会被消除，球排变为 $\\texttt{AAA}$。此时没有球段再被拉长，因此消除过程结束。\n\n请帮助 Balph 计算有多少种选择新球颜色和插入位置的方式，可以导致所有球被消除。", "inputFormat": "仅一行，包含一个长度不超过 $3 \\cdot 10^5$ 的非空字符串，由大写英文字母组成。每个字母代表一个对应颜色的球。\n", "outputFormat": "输出选择新球颜色和插入位置的方式数，使得所有球被消除。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12936", "type": "P", "difficulty": 7, "samples": [["5\n2 2 3 2 1", "4\n2 1 2\n2 2 3\n2 3 1\n3 3 4 5"], ["4\n3 3 2 2", "-1"], ["6\n1 2 1 1 2 1", "-1"], ["15\n1 4 3 2 2 2 2 2 4 4 2 2 2 2 2", "3\n9 1 2 3 4 5 6 7 8 3\n7 2 9 10 11 12 13 10\n5 2 14 9 15 10"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Cactus Revenge", "background": "", "description": "NE(E)RC featured a number of problems in previous years about cactuses --- connected undirected graphs in which every edge belongs to at most one simple cycle. Intuitively, a $\\textit{cactus}$ is a generalization of a tree where some cycles are allowed. The traditional cactus that was initially used in NEERC 2005 problem is given on the second picture in the Examples section.\n\nYou are given $n$ integers $d_1, d_2, \\ldots, d_n$. Construct any cactus with $n$ vertices such that vertex $i$ has degree $d_i$ (i.e. exactly $d_i$ incident edges), or determine that no such cactus exists. Parallel edges and loops are not allowed.", "inputFormat": "The first line contains a single integer $n$ ($2 \\le n \\le 2\\,000$) --- the number of vertices in the cactus.\n\nThe second line contains $n$ integers $d_1, d_2, \\ldots, d_n$ ($1 \\le d_i \\le n-1$) --- the desired vertex degrees.", "outputFormat": "If it's impossible to construct a cactus satisfying the conditions, output a single integer $-1$.\n\nOtherwise, by tradition, output the constructed cactus as a set of edge-distinct paths.\n\nIn the first line output an integer $m$ --- the number of such paths. Each of the following $m$ lines should contain a path in the graph. A path should start with an integer $k_i$ ($k_i \\ge 2$) followed by $k_i$ integers from $1$ to $n$. These $k_i$ integers should represent consecutive vertices of this path. Adjacent vertices in the path should be distinct. The path can visit the same vertex multiple times, but every edge of the cactus should be traversed exactly once in the whole output. ", "hint": "**Sample 1**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bsskq1wa.png)\n\n**Sample 4**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/et4kgcwn.png)\n\nBoth in the second and the third example, there exist graphs that satisfy the given conditions but none of them are cactuses.", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Cactus Revenge", "background": "", "description": "NE(E)RC featured a number of problems in previous years about cactuses --- connected undirected graphs in which every edge belongs to at most one simple cycle. Intuitively, a $\\textit{cactus}$ is a generalization of a tree where some cycles are allowed. The traditional cactus that was initially used in NEERC 2005 problem is given on the second picture in the Examples section.\n\nYou are given $n$ integers $d_1, d_2, \\ldots, d_n$. Construct any cactus with $n$ vertices such that vertex $i$ has degree $d_i$ (i.e. exactly $d_i$ incident edges), or determine that no such cactus exists. Parallel edges and loops are not allowed.", "inputFormat": "The first line contains a single integer $n$ ($2 \\le n \\le 2\\,000$) --- the number of vertices in the cactus.\n\nThe second line contains $n$ integers $d_1, d_2, \\ldots, d_n$ ($1 \\le d_i \\le n-1$) --- the desired vertex degrees.", "outputFormat": "If it's impossible to construct a cactus satisfying the conditions, output a single integer $-1$.\n\nOtherwise, by tradition, output the constructed cactus as a set of edge-distinct paths.\n\nIn the first line output an integer $m$ --- the number of such paths. Each of the following $m$ lines should contain a path in the graph. A path should start with an integer $k_i$ ($k_i \\ge 2$) followed by $k_i$ integers from $1$ to $n$. These $k_i$ integers should represent consecutive vertices of this path. Adjacent vertices in the path should be distinct. The path can visit the same vertex multiple times, but every edge of the cactus should be traversed exactly once in the whole output. ", "hint": "**Sample 1**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bsskq1wa.png)\n\n**Sample 4**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/et4kgcwn.png)\n\nBoth in the second and the third example, there exist graphs that satisfy the given conditions but none of them are cactuses.", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Cactus Revenge", "background": "", "description": "在往年的 NE(E)RC 竞赛中，曾多次出现关于仙人掌（cactus）的问题——这是一种连通无向图，其中每条边最多属于一个简单环。直观地说，仙人掌是树的推广，允许存在某些环。NEERC 2005 年题目中使用的传统仙人掌示例见样例部分的第二张图。\n\n给定 $n$ 个整数 $d_1, d_2, \\ldots, d_n$。请构造一个具有 $n$ 个顶点的仙人掌，使得顶点 $i$ 的度数为 $d_i$（即恰好有 $d_i$ 条相连的边），或者判定这样的仙人掌不存在。图中不允许出现平行边或自环。", "inputFormat": "第一行包含一个整数 $n$（$2 \\le n \\le 2\\,000$）——仙人掌的顶点数。\n\n第二行包含 $n$ 个整数 $d_1, d_2, \\ldots, d_n$（$1 \\le d_i \\le n-1$）——每个顶点期望的度数。\n", "outputFormat": "如果无法构造满足条件的仙人掌，输出一个整数 $-1$。\n\n否则，按照传统方式，将构造的仙人掌以边不重复的路径集合形式输出。\n\n第一行输出一个整数 $m$——路径的数量。接下来的 $m$ 行，每行描述一条路径。路径应以一个整数 $k_i$（$k_i \\ge 2$）开头，后跟 $k_i$ 个 $1$ 到 $n$ 的整数。这些整数表示路径中连续的顶点。路径中相邻顶点必须不同。路径可以多次访问同一顶点，但仙人掌的每条边在整个输出中必须恰好被遍历一次。\n", "hint": "**样例 1**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bsskq1wa.png)\n\n**样例 4**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/et4kgcwn.png)\n\n在第二个和第三个样例中，虽然存在满足给定度数的图，但它们都不是仙人掌。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12937", "type": "P", "difficulty": 6, "samples": [["3\n1 1 1\n1 0 1\n1 1 1\n1 1 1\n0 0 0\n1 0 1", "Possible\n1 1 1\n2\n3 2\n1 3"], ["2\n1 1 1\n0 0 1\n1 1 1\n1 1 0", "Impossible"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] DevOps Best Practices", "background": "", "description": "Daisy is a senior software engineer at RainyDay, LLC. She has just implemented three new features in their product: the first feature makes their product work, the second one makes their product fast, and the third one makes their product correct.\nThe company encourages at least some testing of new features, so Daisy appointed her intern Demid to write some tests for the new features.\n\nInterestingly enough, these three features pass all the tests on Demid's development server, which has index 1, but might fail the tests on some other servers.\n\nAfter Demid has completed this task, Daisy appointed you to deploy these three features to all $n$~servers of your company. For every feature $f$ and every server $s$, Daisy told you whether she wants the feature $f$ to be deployed on the server $s$. If she wants it to be deployed, it must be done even if the feature $f$ fails the tests on the server $s$. If she does not want it to be deployed, you may not deploy it there.\n\nYour company has two important instruments for the deployment of new features to servers: Continuous Deployment (CD) and Continuous Testing (CT). CD can be established between several pairs of servers, forming a directed graph. CT can be set up on some set of servers.\n\nIf CD is configured from the server $s_1$ to the server $s_2$ then every time $s_1$ receives a new feature $f$ the system starts the following deployment process of $f$ to $s_2$:\n\n- If the feature $f$ is already deployed on the server $s_2$, then nothing is done.\n- Otherwise, if CT is not set up on the server $s_1$, then the server $s_1$ just deploys the feature $f$ to the server $s_2$ without any testing.\n- Otherwise, the server $s_1$ runs tests for the feature $f$. If the tests fail on the server $s_1$, nothing is done. If the tests pass, then the server $s_1$ deploys the feature $f$ to the server $s_2$. \n\nYou are to configure the CD/CT system, and after that Demid will deploy all three features on his development server. Your CD/CT system must deploy each feature exactly to the set of servers that Daisy wants.\n\nYour company does not have a lot of computing resources, so you can establish CD from one server to another at most $264$ times.", "inputFormat": "The first line contains integer $n$ ($2 \\le n \\le 256$) --- the number of servers in your company.\n\nNext $n$ lines contain three integers each. The $j$-th integer in the $i$-th line is $1$ if Daisy wants the $j$-th feature to be deployed to the $i$-th server, or $0$ otherwise.\n\nNext $n$ lines contain three integers each. The $j$-th integer in the $i$-th line is $1$ if tests pass for the $j$-th feature on the $i$-th server, or $0$ otherwise.\n\nDemid's development server has index $1$. It is guaranteed that Daisy wants all three features to be deployed to the server number 1, and all three features pass their tests on the server number 1.", "outputFormat": "If it is impossible to configure CD/CT system with CD being set up between at most $264$ pairs of servers, then output the single line  $\\texttt{Impossible}$.\n\nOtherwise, the first line of the output must contain the line $\\texttt{Possible}$.\n\nNext line must contain $n$ space-separated integers --- the configuration of CT. The $i$-th integer should be $1$ if you set up CT on the $i$-th server, or $0$ otherwise.\n\nNext line must contain the integer $m$ ($0 \\le m \\le 264$) --- the number of CD pairs you want to set up.\n\nEach of the next $m$ lines must describe CD configuration, each line with two integers $s_i$ and $t_i$ ($1 \\le s_i, t_i \\le n$; $s_i \\ne t_i$), establishing automated deployment of new features from the server $s_i$ to the server $t_i$.", "hint": "CD/CT system for the first sample test is shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/stnjo553.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2019] DevOps Best Practices", "background": "", "description": "Daisy is a senior software engineer at RainyDay, LLC. She has just implemented three new features in their product: the first feature makes their product work, the second one makes their product fast, and the third one makes their product correct.\nThe company encourages at least some testing of new features, so Daisy appointed her intern Demid to write some tests for the new features.\n\nInterestingly enough, these three features pass all the tests on Demid's development server, which has index 1, but might fail the tests on some other servers.\n\nAfter Demid has completed this task, Daisy appointed you to deploy these three features to all $n$~servers of your company. For every feature $f$ and every server $s$, Daisy told you whether she wants the feature $f$ to be deployed on the server $s$. If she wants it to be deployed, it must be done even if the feature $f$ fails the tests on the server $s$. If she does not want it to be deployed, you may not deploy it there.\n\nYour company has two important instruments for the deployment of new features to servers: Continuous Deployment (CD) and Continuous Testing (CT). CD can be established between several pairs of servers, forming a directed graph. CT can be set up on some set of servers.\n\nIf CD is configured from the server $s_1$ to the server $s_2$ then every time $s_1$ receives a new feature $f$ the system starts the following deployment process of $f$ to $s_2$:\n\n- If the feature $f$ is already deployed on the server $s_2$, then nothing is done.\n- Otherwise, if CT is not set up on the server $s_1$, then the server $s_1$ just deploys the feature $f$ to the server $s_2$ without any testing.\n- Otherwise, the server $s_1$ runs tests for the feature $f$. If the tests fail on the server $s_1$, nothing is done. If the tests pass, then the server $s_1$ deploys the feature $f$ to the server $s_2$. \n\nYou are to configure the CD/CT system, and after that Demid will deploy all three features on his development server. Your CD/CT system must deploy each feature exactly to the set of servers that Daisy wants.\n\nYour company does not have a lot of computing resources, so you can establish CD from one server to another at most $264$ times.", "inputFormat": "The first line contains integer $n$ ($2 \\le n \\le 256$) --- the number of servers in your company.\n\nNext $n$ lines contain three integers each. The $j$-th integer in the $i$-th line is $1$ if Daisy wants the $j$-th feature to be deployed to the $i$-th server, or $0$ otherwise.\n\nNext $n$ lines contain three integers each. The $j$-th integer in the $i$-th line is $1$ if tests pass for the $j$-th feature on the $i$-th server, or $0$ otherwise.\n\nDemid's development server has index $1$. It is guaranteed that Daisy wants all three features to be deployed to the server number 1, and all three features pass their tests on the server number 1.", "outputFormat": "If it is impossible to configure CD/CT system with CD being set up between at most $264$ pairs of servers, then output the single line  $\\texttt{Impossible}$.\n\nOtherwise, the first line of the output must contain the line $\\texttt{Possible}$.\n\nNext line must contain $n$ space-separated integers --- the configuration of CT. The $i$-th integer should be $1$ if you set up CT on the $i$-th server, or $0$ otherwise.\n\nNext line must contain the integer $m$ ($0 \\le m \\le 264$) --- the number of CD pairs you want to set up.\n\nEach of the next $m$ lines must describe CD configuration, each line with two integers $s_i$ and $t_i$ ($1 \\le s_i, t_i \\le n$; $s_i \\ne t_i$), establishing automated deployment of new features from the server $s_i$ to the server $t_i$.", "hint": "CD/CT system for the first sample test is shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/stnjo553.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] DevOps Best Practices", "background": "", "description": "**Daisy** 是 RainyDay 公司的一名高级软件工程师。她刚刚为产品实现了三个新功能：第一个功能使产品能够运行，第二个功能使产品运行得更快，第三个功能使产品运行得更正确。公司鼓励对新功能进行至少一些测试，因此 Daisy 指派她的实习生 **Demid** 为这些新功能编写测试用例。\n\n有趣的是，这三个功能在 Demid 的开发服务器（编号为 1）上通过了所有测试，但在其他某些服务器上可能会测试失败。\n\nDemid 完成任务后，Daisy 指派你将这三个功能部署到公司的所有 $n$ 台服务器上。对于每个功能 $f$ 和每台服务器 $s$，Daisy 会告诉你她是否希望将功能 $f$ 部署到服务器 $s$ 上。如果她希望部署，即使功能 $f$ 在服务器 $s$ 上测试失败也必须部署；如果她不希望部署，则不能部署。\n\n公司有两种重要的部署工具：持续部署（CD）和持续测试（CT）。CD 可以在多对服务器之间建立有向图形式的连接，而 CT 可以配置在某些服务器上。\n\n如果从服务器 $s_1$ 到服务器 $s_2$ 配置了 CD，那么每当 $s_1$ 接收到新功能 $f$ 时，系统会启动以下部署流程将 $f$ 部署到 $s_2$：\n\n1. 如果功能 $f$ 已经部署在服务器 $s_2$ 上，则不进行任何操作。\n2. 否则，如果服务器 $s_1$ 未配置 CT，则 $s_1$ 会直接将功能 $f$ 部署到 $s_2$，不进行测试。\n3. 否则，服务器 $s_1$ 会对功能 $f$ 运行测试。如果测试失败，则不进行任何操作；如果测试通过，则将功能 $f$ 部署到 $s_2$。\n\n你需要配置 CD/CT 系统，之后 Demid 会将所有三个功能部署到他的开发服务器上。你的 CD/CT 系统必须确保每个功能仅被部署到 Daisy 指定的服务器集合。\n\n由于公司计算资源有限，你最多只能建立 $264$ 条 CD 连接。", "inputFormat": "第一行包含一个整数 $n$（$2 \\le n \\le 256$）——公司服务器的数量。\n\n接下来的 $n$ 行，每行包含三个整数。第 $i$ 行的第 $j$ 个整数为 $1$ 表示 Daisy 希望将第 $j$ 个功能部署到第 $i$ 台服务器，否则为 $0$。\n\n再接下来的 $n$ 行，每行包含三个整数。第 $i$ 行的第 $j$ 个整数为 $1$ 表示第 $j$ 个功能在第 $i$ 台服务器上测试通过，否则为 $0$。\n\nDemid 的开发服务器编号为 $1$。数据保证 Daisy 希望将所有三个功能部署到服务器 1，且所有三个功能在服务器 1 上测试通过。", "outputFormat": "如果无法在最多建立 $264$ 条 CD 连接的情况下配置 CD/CT 系统，则输出一行 `Impossible`。\n\n否则，输出的第一行应为 `Possible`。\n\n第二行应包含 $n$ 个用空格分隔的整数——CT 的配置。第 $i$ 个整数为 $1$ 表示你在第 $i$ 台服务器上设置了 CT，否则为 $0$。\n\n第三行应包含一个整数 $m$（$0 \\le m \\le 264$）——你设置的 CD 连接数量。\n\n接下来的 $m$ 行，每行描述一条 CD 连接，包含两个整数 $s_i$ 和 $t_i$（$1 \\le s_i, t_i \\le n$；$s_i \\ne t_i$），表示从服务器 $s_i$ 到服务器 $t_i$ 建立了自动部署通道。", "hint": "第一个样例测试的 CD/CT 系统配置如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/stnjo553.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12938", "type": "P", "difficulty": 4, "samples": [["5 3\n6 3 4 2 8\n3 7 5 6 7\n5 2 4 7 9", "2\n3 1"], ["2 1\n1 1", "0"], ["3 3\n2 3 8\n4 2 9\n3 1 7", "3\n1 2 3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2019", "Special Judge", "枚举", "排序", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Elections", "background": "", "description": "Byteburg Senate elections are coming. Usually \"United Byteland\", the ruling Byteland party, takes all the seats in the Senate to ensure stability and sustainable development. But this year there is one opposition candidate in one of the constituencies. Even one opposition member can disturb the stability in the Senate, so the head of the Party asks you to ensure that the opposition candidate will not be elected.\n\nThere are $n$ candidates, numbered from 1 to $n$. Candidate $n$ is the opposition candidate. There are $m$ polling stations in the constituency, numbered from 1 to $m$. You know the number of votes cast for each candidate at each polling station. The only thing you can do to prevent the election of the opposition candidate is to cancel the election results at some polling stations. The opposition candidate will be elected if the sum of the votes cast in their favor at all non-canceled stations will be **strictly greater** than the analogous sum for every other candidate. \n\nYour task is to prevent the election of the opposition candidate by canceling the election results at the minimal possible number of polling stations. Notice that solution always exists, because if you cancel the elections at all polling stations, the number of votes for each candidate will be 0, and the opposition candidate will not be elected.", "inputFormat": "The first line of the input contains two integers $n$ and $m$ ($2\\le n\\le 100$; $1\\le m \\le 100$) --- the number of candidates and the number of polling stations. The next $m$ lines contain the election results at each polling station with $n$ numbers on each line. In the $i$-th line the $j$-th number is $a_{i,j}$ --- the number of votes cast for the candidate $j$ at the station $i$ ($0\\le a_{i,j} \\le 1\\,000$).", "outputFormat": "In the first line output integer $k$ --- the minimal number of the polling stations in which you need to cancel the election results. In the second line output $k$ integers --- the indices of canceled polling stations, in any order. If there are multiple ways to cancel results at $k$ stations, output any one of them.", "hint": "In the first example, the candidates from 1 to 5 received 14, 12, 13, 15, and 24 votes correspondingly. The opposition candidate has the most votes. However, if you cancel the election results at the first and the third polling stations, then only the result from the second polling station remains and the vote sums become 3, 7, 5, 6, and 7, without the opposition candidate being in the lead anymore. ", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Elections", "background": "", "description": "Byteburg Senate elections are coming. Usually \"United Byteland\", the ruling Byteland party, takes all the seats in the Senate to ensure stability and sustainable development. But this year there is one opposition candidate in one of the constituencies. Even one opposition member can disturb the stability in the Senate, so the head of the Party asks you to ensure that the opposition candidate will not be elected.\n\nThere are $n$ candidates, numbered from 1 to $n$. Candidate $n$ is the opposition candidate. There are $m$ polling stations in the constituency, numbered from 1 to $m$. You know the number of votes cast for each candidate at each polling station. The only thing you can do to prevent the election of the opposition candidate is to cancel the election results at some polling stations. The opposition candidate will be elected if the sum of the votes cast in their favor at all non-canceled stations will be **strictly greater** than the analogous sum for every other candidate. \n\nYour task is to prevent the election of the opposition candidate by canceling the election results at the minimal possible number of polling stations. Notice that solution always exists, because if you cancel the elections at all polling stations, the number of votes for each candidate will be 0, and the opposition candidate will not be elected.", "inputFormat": "The first line of the input contains two integers $n$ and $m$ ($2\\le n\\le 100$; $1\\le m \\le 100$) --- the number of candidates and the number of polling stations. The next $m$ lines contain the election results at each polling station with $n$ numbers on each line. In the $i$-th line the $j$-th number is $a_{i,j}$ --- the number of votes cast for the candidate $j$ at the station $i$ ($0\\le a_{i,j} \\le 1\\,000$).", "outputFormat": "In the first line output integer $k$ --- the minimal number of the polling stations in which you need to cancel the election results. In the second line output $k$ integers --- the indices of canceled polling stations, in any order. If there are multiple ways to cancel results at $k$ stations, output any one of them.", "hint": "In the first example, the candidates from 1 to 5 received 14, 12, 13, 15, and 24 votes correspondingly. The opposition candidate has the most votes. However, if you cancel the election results at the first and the third polling stations, then only the result from the second polling station remains and the vote sums become 3, 7, 5, 6, and 7, without the opposition candidate being in the lead anymore. ", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Elections", "background": "", "description": "Byteland 参议院选举即将到来。通常情况下，执政党“联合 Byteland”会占据参议院所有席位以确保稳定和可持续发展。但今年有一个选区出现了一名反对派候选人。即使只有一名反对派成员也可能扰乱参议院的稳定，因此党首要求你确保这名反对派候选人不会当选。\n\n共有 $n$ 名候选人，编号从 1 到 $n$。候选人 $n$ 是反对派候选人。该选区有 $m$ 个投票站，编号从 1 到 $m$。你已知每个投票站中每位候选人的得票数。为了防止反对派候选人当选，你唯一能做的就是取消部分投票站的选举结果。如果反对派候选人在所有未被取消的投票站中获得的**总票数严格大于**其他每位候选人的总票数，则该候选人将当选。\n\n你的任务是通过取消尽可能少数量的投票站的选举结果，阻止反对派候选人当选。注意，解决方案一定存在，因为如果取消所有投票站的选举结果，每位候选人的得票数将为 0，反对派候选人将不会当选。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $m$（$2 \\le n \\le 100$；$1 \\le m \\le 100$）——候选人数量和投票站数量。接下来的 $m$ 行包含每个投票站的选举结果，每行有 $n$ 个数字。第 $i$ 行的第 $j$ 个数字是 $a_{i,j}$——投票站 $i$ 中候选人 $j$ 的得票数（$0 \\le a_{i,j} \\le 1\\,000$）。\n", "outputFormat": "第一行输出整数 $k$——需要取消选举结果的投票站的最小数量。第二行输出 $k$ 个整数——被取消的投票站的编号，顺序任意。如果有多种取消 $k$ 个投票站的方案，输出其中任意一种即可。\n", "hint": "在第一个示例中，编号 1 至 5 的候选人分别获得了 14、12、13、15 和 24 票。反对派候选人的票数最多。然而，如果取消第一个和第三个投票站的选举结果，则仅保留第二个投票站的结果，此时总票数变为 3、7、5、6 和 7，反对派候选人不再领先。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12939", "type": "P", "difficulty": 6, "samples": [["4 5 4 2\n1 3 3 4\n7 8", "Yes\n1 5\n1 6\n2 7\n6 3\n3 7\n9 4\n3 8\n4 8"], ["4 3 3 1\n3 2 2\n6", "No"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "Special Judge", "ICPC", "Prüfer 序列", "NERC/NEERC"], "title": "[NERC 2019] Foolprüf Security", "background": "", "description": "Alice and Bob obtained a map of the secret underground facility. The facility consists of $n$ $\\emph{security units}$ and $m$ $\\emph{chemical labs}$, connected by bidirectional tunnels. The map of this facility forms a $\\emph{tree}$: there are exactly $n + m - 1$ tunnels, and there are no cycles. Vertices corresponding to security units have numbers from $1$ to $n$, chemical labs have numbers from $n+1$ to $n+m$. Each tunnel connects a security unit to a chemical lab; there are no tunnels between two security units or two chemical labs.\n\nIn case Alice or Bob gets captured, they decided to split the map into two pieces. To do that, they calculated the $\\emph{Prüfer code}$ of the tree. Alice then saved some of the numbers between $1$ and $n$ to her data storage in the same order as they go in the original code, and Bob saved some of the numbers from $n+1$ to $n+m$ to his storage in the same way.\n\nA Prüfer code of a tree on $k$ vertices is a sequence of $k - 2$ integers from $1$ to $k$, constructed as follows. Find the leaf (a vertex with degree one) with the smallest label, remove it from the tree, then print the label of its only neighbor. Repeat this $k - 3$ more times, until only one edge remains. The printed sequence of $k - 2$ vertex labels is the Prüfer code.\n\nAlice and Bob safely returned and they are ready to combine their data to restore the original map. They could make a mistake during the backup, meaning no such map exists. Alice and Bob need your help to restore any possible map of the facility consistent with the collected data, so that both Alice's and Bob's parts are subsequences of the Prüfer code of the map.", "inputFormat": "The first line of the input contains four integers $n$, $m$, $k_a$, and $k_b$ ($2 \\le n, m \\le 10^5$; $1 \\le k_a, k_b$; $k_a + k_b \\le n + m - 2$).\nThe second line contains $k_a$ integers $a_1, a_2, \\ldots, a_{k_a}$ ($1 \\le a_i \\le n$) --- Alice's part of the map.\nThe third line contains $k_b$ integers $b_1, b_2, \\ldots, b_{k_b}$ ($n + 1 \\le b_i \\le n + m$) --- Bob's part of the map.", "outputFormat": "If there's no such map, print $\\tt{No}$.\n\nOtherwise, print $\\tt{Yes}$ on the first line, followed by $n + m - 1$ lines describing the possible facility map. Each line should contain two integers $u_i$ and $v_i$ --- the security unit and the chemical lab connected by the $i$-th tunnel of the facility.", "hint": "The Prüfer code of the tree in the first example is $(\\underline{7}, \\mathbf{1}, 6, \\mathbf{3}, \\mathbf{3}, \\underline{8}, \\mathbf{4})$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6z6yk20m.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Foolprüf Security", "background": "", "description": "Alice and Bob obtained a map of the secret underground facility. The facility consists of $n$ $\\emph{security units}$ and $m$ $\\emph{chemical labs}$, connected by bidirectional tunnels. The map of this facility forms a $\\emph{tree}$: there are exactly $n + m - 1$ tunnels, and there are no cycles. Vertices corresponding to security units have numbers from $1$ to $n$, chemical labs have numbers from $n+1$ to $n+m$. Each tunnel connects a security unit to a chemical lab; there are no tunnels between two security units or two chemical labs.\n\nIn case Alice or Bob gets captured, they decided to split the map into two pieces. To do that, they calculated the $\\emph{Prüfer code}$ of the tree. Alice then saved some of the numbers between $1$ and $n$ to her data storage in the same order as they go in the original code, and Bob saved some of the numbers from $n+1$ to $n+m$ to his storage in the same way.\n\nA Prüfer code of a tree on $k$ vertices is a sequence of $k - 2$ integers from $1$ to $k$, constructed as follows. Find the leaf (a vertex with degree one) with the smallest label, remove it from the tree, then print the label of its only neighbor. Repeat this $k - 3$ more times, until only one edge remains. The printed sequence of $k - 2$ vertex labels is the Prüfer code.\n\nAlice and Bob safely returned and they are ready to combine their data to restore the original map. They could make a mistake during the backup, meaning no such map exists. Alice and Bob need your help to restore any possible map of the facility consistent with the collected data, so that both Alice's and Bob's parts are subsequences of the Prüfer code of the map.", "inputFormat": "The first line of the input contains four integers $n$, $m$, $k_a$, and $k_b$ ($2 \\le n, m \\le 10^5$; $1 \\le k_a, k_b$; $k_a + k_b \\le n + m - 2$).\nThe second line contains $k_a$ integers $a_1, a_2, \\ldots, a_{k_a}$ ($1 \\le a_i \\le n$) --- Alice's part of the map.\nThe third line contains $k_b$ integers $b_1, b_2, \\ldots, b_{k_b}$ ($n + 1 \\le b_i \\le n + m$) --- Bob's part of the map.", "outputFormat": "If there's no such map, print $\\tt{No}$.\n\nOtherwise, print $\\tt{Yes}$ on the first line, followed by $n + m - 1$ lines describing the possible facility map. Each line should contain two integers $u_i$ and $v_i$ --- the security unit and the chemical lab connected by the $i$-th tunnel of the facility.", "hint": "The Prüfer code of the tree in the first example is $(\\underline{7}, \\mathbf{1}, 6, \\mathbf{3}, \\mathbf{3}, \\underline{8}, \\mathbf{4})$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6z6yk20m.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Foolprüf Security", "background": "", "description": "Alice 和 Bob 获得了一份秘密地下设施的地图。该设施由 $n$ 个**安全单元**和 $m$ 个**化学实验室**组成，通过双向隧道连接。该设施的地图构成一棵**树**：共有 $n + m - 1$ 条隧道，且不存在环路。安全单元对应的顶点编号为 $1$ 至 $n$，化学实验室的编号为 $n+1$ 至 $n+m$。每条隧道连接一个安全单元和一个化学实验室；不存在连接两个安全单元或两个化学实验室的隧道。\n\n为了防止 Alice 或 Bob 被捕，他们决定将地图分成两部分。为此，他们计算了这棵树的 **Prüfer 编码**。Alice 随后将原始编码中 $1$ 至 $n$ 的部分数字按顺序保存到她的数据存储中，Bob 则保存了 $n+1$ 至 $n+m$ 的部分数字，同样按原始编码的顺序存储。\n\n一棵 $k$ 个顶点的树的 Prüfer 编码是一个长度为 $k - 2$ 的序列，其中每个数字的取值范围是 $1$ 至 $k$，构造方式如下：找到标号最小的叶子节点（度数为 1 的顶点），将其从树中移除，并记录其唯一邻居的标号。重复此过程 $k - 3$ 次，直到只剩一条边。记录的 $k - 2$ 个顶点标号序列即为 Prüfer 编码。\n\nAlice 和 Bob 安全返回后，准备将他们的数据合并以恢复原始地图。但他们在备份时可能出错，导致不存在符合条件的地图。他们需要你的帮助来恢复任意一种可能的地图，使得 Alice 和 Bob 保存的部分都是该地图 Prüfer 编码的子序列。\n", "inputFormat": "输入的第一行包含四个整数 $n$、$m$、$k_a$ 和 $k_b$（$2 \\le n, m \\le 10^5$；$1 \\le k_a, k_b$；$k_a + k_b \\le n + m - 2$）。  \n第二行包含 $k_a$ 个整数 $a_1, a_2, \\ldots, a_{k_a}$（$1 \\le a_i \\le n$）——Alice 保存的地图部分。  \n第三行包含 $k_b$ 个整数 $b_1, b_2, \\ldots, b_{k_b}$（$n + 1 \\le b_i \\le n + m$）——Bob 保存的地图部分。\n", "outputFormat": "如果不存在符合条件的地图，输出 $\\tt{No}$。\n\n否则，第一行输出 $\\tt{Yes}$，随后输出 $n + m - 1$ 行描述可能的地图。每行包含两个整数 $u_i$ 和 $v_i$，表示设施的第 $i$ 条隧道连接的安全单元和化学实验室。\n", "hint": "第一个示例中树的 Prüfer 编码为 $(\\underline{7}, \\mathbf{1}, 6, \\mathbf{3}, \\mathbf{3}, \\underline{8}, \\mathbf{4})$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6z6yk20m.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12940", "type": "P", "difficulty": 7, "samples": [["2 20\n25 100", "47.50000000000000000"], ["4 30\n60 50 60 80", "171.25000000000000000"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Game Relics", "background": "", "description": "Esports is a form of competitive sports using video games. \nDota 2 is one of the most popular competitive video games in Esports. Recently, a new video game Dota 3 was released. In Dota 3 a player can buy some relics for their hero. Relics are counters that track hero's actions and statistics in a game.\n\nGloria likes to play Dota 3, so she wants to buy all $n$ available relics for her favorite hero.\n\nRelics can be bought using an in-game currency called shards. Each relic has its own price --- $c_i$ shards for the $i$-th relic. A player can buy a relic using one of the following options:\n- Pay $c_i$ shards to buy the $i$-th relic;\n- Pay $x$ shards and randomly get one of all $n$ relics. The probability of getting a relic is the same for all $n$ relics. If a duplicate relic is received, then the relic is recycled and $\\frac{x}{2}$ shards are given back to the player.\n\nGloria wants to buy all $n$ relics. Help her minimize the expected number of shards she spends to buy all the relics.", "inputFormat": "The first line contains two integers $n$ and $x$ ($1 \\le n \\le 100$; $1 \\le x \\le 10\\,000$) --- the number of relics and the cost to receive a random relic.\n\nThe second line consists of $n$ integers $c_1, c_2, \\ldots, c_n$ ($x \\le c_i \\le 10\\,000$; $\\sum{c_i} \\le 10\\,000$) --- the prices of $n$ relics.", "outputFormat": "Print a single real number --- the minimum expected number of shards that Gloria must spend to buy all the relics.\n\nThe absolute or relative error should not exceed $10^{-9}$.", "hint": "In the first example, the optimal strategy is to randomly get one of the two relics paying $20$ shards. Then there are two scenarios. \n\nThe first one happens if Gloria receives the first relic. Then she keeps getting random relics until she obtains the second relic. The expected number of shards to spend in this scenario is $20 + 30 = 50$.\n\nIn the second scenario, Gloria initially gets the second relic. Then it is better to buy the first relic for $25$ shards, so the expected number of shards to spend in this scenario is $20 + 25 = 45$.\n\nThus, the expected number of shards to spend is $\\frac{50 + 45}{2} = 47.5$.", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Game Relics", "background": "", "description": "Esports is a form of competitive sports using video games. \nDota 2 is one of the most popular competitive video games in Esports. Recently, a new video game Dota 3 was released. In Dota 3 a player can buy some relics for their hero. Relics are counters that track hero's actions and statistics in a game.\n\nGloria likes to play Dota 3, so she wants to buy all $n$ available relics for her favorite hero.\n\nRelics can be bought using an in-game currency called shards. Each relic has its own price --- $c_i$ shards for the $i$-th relic. A player can buy a relic using one of the following options:\n- Pay $c_i$ shards to buy the $i$-th relic;\n- Pay $x$ shards and randomly get one of all $n$ relics. The probability of getting a relic is the same for all $n$ relics. If a duplicate relic is received, then the relic is recycled and $\\frac{x}{2}$ shards are given back to the player.\n\nGloria wants to buy all $n$ relics. Help her minimize the expected number of shards she spends to buy all the relics.", "inputFormat": "The first line contains two integers $n$ and $x$ ($1 \\le n \\le 100$; $1 \\le x \\le 10\\,000$) --- the number of relics and the cost to receive a random relic.\n\nThe second line consists of $n$ integers $c_1, c_2, \\ldots, c_n$ ($x \\le c_i \\le 10\\,000$; $\\sum{c_i} \\le 10\\,000$) --- the prices of $n$ relics.", "outputFormat": "Print a single real number --- the minimum expected number of shards that Gloria must spend to buy all the relics.\n\nThe absolute or relative error should not exceed $10^{-9}$.", "hint": "In the first example, the optimal strategy is to randomly get one of the two relics paying $20$ shards. Then there are two scenarios. \n\nThe first one happens if Gloria receives the first relic. Then she keeps getting random relics until she obtains the second relic. The expected number of shards to spend in this scenario is $20 + 30 = 50$.\n\nIn the second scenario, Gloria initially gets the second relic. Then it is better to buy the first relic for $25$ shards, so the expected number of shards to spend in this scenario is $20 + 25 = 45$.\n\nThus, the expected number of shards to spend is $\\frac{50 + 45}{2} = 47.5$.", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Game Relics", "background": "", "description": "电子竞技是一种使用电子游戏进行的竞技运动。Dota 2 是电子竞技中最受欢迎的竞技游戏之一。最近，一款新游戏 Dota 3 发布了。在 Dota 3 中，玩家可以为自己的英雄购买一些**圣物**。圣物是用于追踪英雄在游戏中行为和统计数据的计数器。\n\nGloria 喜欢玩 Dota 3，因此她想为她最喜欢的英雄购买所有 $n$ 件可用的圣物。\n\n圣物可以使用游戏内货币\"碎片\"购买。每件圣物都有自己的价格——第 $i$ 件圣物需要 $c_i$ 碎片。玩家可以通过以下两种方式购买圣物：\n- 支付 $c_i$ 碎片直接购买第 $i$ 件圣物；\n- 支付 $x$ 碎片随机获得所有 $n$ 件圣物中的一件。每件圣物被获得的概率相同。如果获得重复的圣物，则该圣物会被回收，并返还 $\\frac{x}{2}$ 碎片给玩家。\n\nGloria 想要购买所有 $n$ 件圣物。请帮助她最小化购买所有圣物所需的期望碎片数量。", "inputFormat": "第一行包含两个整数 $n$ 和 $x$（$1 \\le n \\le 100$；$1 \\le x \\le 10\\,000$）——圣物的数量和随机获取一件圣物的花费。\n\n第二行包含 $n$ 个整数 $c_1, c_2, \\ldots, c_n$（$x \\le c_i \\le 10\\,000$；$\\sum{c_i} \\le 10\\,000$）——$n$ 件圣物的价格。\n", "outputFormat": "输出一个实数——Gloria 购买所有圣物所需的最小期望碎片数量。\n\n绝对误差或相对误差不应超过 $10^{-9}$。", "hint": "在第一个示例中，最优策略是先花费 $20$ 碎片随机获取两件圣物中的一件。之后会出现两种情况：\n\n第一种情况是 Gloria 获得了第一件圣物。然后她需要继续随机获取圣物，直到获得第二件圣物。这种情况下的期望花费是 $20 + 30 = 50$ 碎片。\n\n第二种情况是 Gloria 一开始就获得了第二件圣物。这时最好直接花费 $25$ 碎片购买第一件圣物，因此这种情况下的期望花费是 $20 + 25 = 45$ 碎片。\n\n因此，总的期望花费为 $\\frac{50 + 45}{2} = 47.5$ 碎片。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12941", "type": "P", "difficulty": 7, "samples": [["5\n3\n1 3 2\n3\n1 2 3\n1\n1\n10\n6 10 4 2 7 9 5 8 3 1\n10\n2 4 6 9 1 8 10 5 3 7", "1 3 2\n10 20 10\n1\n2 3 4 5 3 1 3 5 4 2\n1 2 3 4 5 6 7 8 9 10"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Help BerLine", "background": "", "description": "Very soon, the new cell phone services provider \"BerLine\" will begin its work in Berland!\n\nThe start of customer service is planned along the main street of the capital. There are $n$ base stations that are already installed. They are located one after another along the main street in the order from the $1$-st to the $n$-th from left to right. \n\nCurrently, all these base stations are turned off. They will be turned on one by one, one base station per day, according to some permutation $p = [p_1, p_2, \\dots, p_n]$ ($ 1 \\le p_i \\le n$), where $p_i$ is the index of a base station that will be turned on on the $i$-th day. Thus, it will take $n$ days to turn on all base stations.\n\nEach base station is characterized by its operating frequency $f_i$ --- an integer between $1$ and $24$, inclusive.\n\nThere is an important requirement for operating frequencies of base stations. Consider an arbitrary moment in time. For any phone owner, if we consider all base stations turned on in the access area of their phone, then in this set of base stations there should be at least one whose operating frequency is unique among the frequencies of these stations. Since the power of the phone and the position are not known in advance, this means that for any nonempty subsegment of turned on base stations, at least one of them has to have the operating frequency that is unique among the stations of this subsegment.\n\nFor example, let's take a look at a case of $n = 7$, all $n$ stations are turned on, and their frequencies are equal to $f = [1, 2, 1, 3, 1, 2, 1]$. Consider any subsegment of the base stations --- there is a base station with a unique frequency within this subsegment. However, if $f = [1, 2, 1, 2, 3, 2, 1]$, then there is no unique frequency on the segment $[1, 2, 1, 2]$ from the index $1$ to the index $4$, inclusive.\n\nYour task is to assign a frequency from $1$ to $24$ to each of $n$ base stations in such a way that the frequency requirement is met at every moment. Remember that the base stations are turned on in the order of the given permutation $p$.", "inputFormat": "The first line of the input contains an integer $t$ ($1 \\le t \\le 50$)~--- the number of test cases in the input. Then $t$ test case descriptions follow.\n\nThe first line of a test case contains an integer $n$ ($ 1 \\le n \\le 8\\,500$) --- the number of \"BerLine\" base stations.\n\nThe following line contains $n$ distinct integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$) --- the order in which the base stations are turned on, i.e. on the $i$-th day the base station with the index $p_i$ is turned on.\n\nIt is guaranteed that a correct answer exists for all test cases in the input.", "outputFormat": "The first line of the input contains an integer $t$ ($1 \\le t \\le 50$)~--- the number of test cases in the input. Then $t$ test case descriptions follow.\n\nThe first line of a test case contains an integer $n$ ($ 1 \\le n \\le 8\\,500$) --- the number of \"BerLine\" base stations.\n\nThe following line contains $n$ distinct integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$) --- the order in which the base stations are turned on, i.e. on the $i$-th day the base station with the index $p_i$ is turned on.\n\nIt is guaranteed that a correct answer exists for all test cases in the input.", "hint": "In the first test case $n = 3$ and $p = [1, 3, 2]$. The base stations can be assigned frequencies $[1, 3, 2]$.\n\n- Day 1: only the base station $1$ is turned on, its frequency is $1$.\n- Day 2: the base stations $1$ and $3$ are turned on, their frequencies are $[1, 2]$.\n- Day 3: all base stations are turned on, their frequencies are $[1, 3, 2]$ (in the direction along the street).\n\nOn each day, each nonempty subsegment of turned on base stations has a base station with a unique frequency among this subsegment. It can be shown that three distinct frequencies are necessary in this test case.", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Help BerLine", "background": "", "description": "Very soon, the new cell phone services provider \"BerLine\" will begin its work in Berland!\n\nThe start of customer service is planned along the main street of the capital. There are $n$ base stations that are already installed. They are located one after another along the main street in the order from the $1$-st to the $n$-th from left to right. \n\nCurrently, all these base stations are turned off. They will be turned on one by one, one base station per day, according to some permutation $p = [p_1, p_2, \\dots, p_n]$ ($ 1 \\le p_i \\le n$), where $p_i$ is the index of a base station that will be turned on on the $i$-th day. Thus, it will take $n$ days to turn on all base stations.\n\nEach base station is characterized by its operating frequency $f_i$ --- an integer between $1$ and $24$, inclusive.\n\nThere is an important requirement for operating frequencies of base stations. Consider an arbitrary moment in time. For any phone owner, if we consider all base stations turned on in the access area of their phone, then in this set of base stations there should be at least one whose operating frequency is unique among the frequencies of these stations. Since the power of the phone and the position are not known in advance, this means that for any nonempty subsegment of turned on base stations, at least one of them has to have the operating frequency that is unique among the stations of this subsegment.\n\nFor example, let's take a look at a case of $n = 7$, all $n$ stations are turned on, and their frequencies are equal to $f = [1, 2, 1, 3, 1, 2, 1]$. Consider any subsegment of the base stations --- there is a base station with a unique frequency within this subsegment. However, if $f = [1, 2, 1, 2, 3, 2, 1]$, then there is no unique frequency on the segment $[1, 2, 1, 2]$ from the index $1$ to the index $4$, inclusive.\n\nYour task is to assign a frequency from $1$ to $24$ to each of $n$ base stations in such a way that the frequency requirement is met at every moment. Remember that the base stations are turned on in the order of the given permutation $p$.", "inputFormat": "The first line of the input contains an integer $t$ ($1 \\le t \\le 50$)~--- the number of test cases in the input. Then $t$ test case descriptions follow.\n\nThe first line of a test case contains an integer $n$ ($ 1 \\le n \\le 8\\,500$) --- the number of \"BerLine\" base stations.\n\nThe following line contains $n$ distinct integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$) --- the order in which the base stations are turned on, i.e. on the $i$-th day the base station with the index $p_i$ is turned on.\n\nIt is guaranteed that a correct answer exists for all test cases in the input.", "outputFormat": "The first line of the input contains an integer $t$ ($1 \\le t \\le 50$)~--- the number of test cases in the input. Then $t$ test case descriptions follow.\n\nThe first line of a test case contains an integer $n$ ($ 1 \\le n \\le 8\\,500$) --- the number of \"BerLine\" base stations.\n\nThe following line contains $n$ distinct integers $p_1, p_2, \\dots, p_n$ ($1 \\le p_i \\le n$) --- the order in which the base stations are turned on, i.e. on the $i$-th day the base station with the index $p_i$ is turned on.\n\nIt is guaranteed that a correct answer exists for all test cases in the input.", "hint": "In the first test case $n = 3$ and $p = [1, 3, 2]$. The base stations can be assigned frequencies $[1, 3, 2]$.\n\n- Day 1: only the base station $1$ is turned on, its frequency is $1$.\n- Day 2: the base stations $1$ and $3$ are turned on, their frequencies are $[1, 2]$.\n- Day 3: all base stations are turned on, their frequencies are $[1, 3, 2]$ (in the direction along the street).\n\nOn each day, each nonempty subsegment of turned on base stations has a base station with a unique frequency among this subsegment. It can be shown that three distinct frequencies are necessary in this test case.", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Help BerLine", "background": "", "description": "很快，新的手机服务提供商 **BerLine** 将在 Berland 开始运营！\n\n客户服务的启动计划沿着首都的主街进行。已经有 $n$ 个基站安装完毕，它们沿着主街从左到右依次排列，编号从 $1$ 到 $n$。\n\n目前，所有这些基站都处于关闭状态。它们将按照某个排列 $p = [p_1, p_2, \\dots, p_n]$（$1 \\le p_i \\le n$）依次开启，每天开启一个基站，其中 $p_i$ 表示第 $i$ 天开启的基站编号。因此，开启所有基站需要 $n$ 天时间。\n\n每个基站都有一个工作频率 $f_i$ —— 这是一个介于 $1$ 到 $24$ 之间的整数。\n\n对于基站的工作频率有一个重要要求：考虑任意时刻，对于任何手机用户，如果查看其手机信号覆盖范围内所有已开启的基站，那么在这些基站中至少有一个的工作频率在该组基站中是唯一的。由于手机的信号强度和用户位置事先未知，这意味着对于任何非空的已开启基站子段，其中至少有一个基站的工作频率在该子段中是唯一的。\n\n例如，假设 $n = 7$，所有基站都已开启，且其频率为 $f = [1, 2, 1, 3, 1, 2, 1]$。对于任意子段，该子段内都存在一个频率唯一的基站。但如果 $f = [1, 2, 1, 2, 3, 2, 1]$，则子段 $[1, 2, 1, 2]$（从第 $1$ 个到第 $4$ 个基站）中没有频率是唯一的。\n\n你的任务是为每个基站分配一个 $1$ 到 $24$ 之间的频率，使得在任意时刻（按照给定排列 $p$ 开启基站的过程中）都满足上述频率要求。", "inputFormat": "输入的第一行包含一个整数 $t$（$1 \\le t \\le 50$）—— 测试用例的数量。接下来是 $t$ 个测试用例的描述。\n\n每个测试用例的第一行包含一个整数 $n$（$1 \\le n \\le 8\\,500$）—— **BerLine** 基站的数量。\n\n第二行包含 $n$ 个不同的整数 $p_1, p_2, \\dots, p_n$（$1 \\le p_i \\le n$）—— 基站开启的顺序，即第 $i$ 天开启编号为 $p_i$ 的基站。\n\n保证所有测试用例都存在正确的解。", "outputFormat": "对于每个测试用例，输出一行 $n$ 个整数 $f_1, f_2, \\dots, f_n$（$1 \\le f_i \\le 24$）—— 分配给每个基站的工作频率。如果有多个解，输出任意一个即可。\n", "hint": "在第一个测试用例中，$n = 3$，$p = [1, 3, 2]$。可以给基站分配频率 $[1, 3, 2]$。\n\n- 第 1 天：只有基站 $1$ 开启，其频率为 $1$。\n- 第 2 天：基站 $1$ 和 $3$ 开启，频率为 $[1, 2]$。\n- 第 3 天：所有基站开启，频率为 $[1, 3, 2]$（沿街道方向排列）。\n\n在每一天，任何非空的已开启基站子段中都有一个频率唯一的基站。可以证明，在这个测试用例中必须使用三个不同的频率。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12942", "type": "P", "difficulty": 6, "samples": [["2\n3\n\n>\n\n<\n\n>\n\n<\n\n>\n\n>\n\n3\n\n<\n\n<\n\n<\n\n>\n\n>\n", "\n\n? 1 3\n\n? 4 2\n\n? 4 5\n\n? 6 5\n\n? 3 4\n\n? 5 6\n\n!\n\n? 3 4\n\n? 4 2\n\n? 5 3\n\n? 6 4\n\n? 3 1\n\n!"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Intriguing Selection", "background": "", "description": "$\\emph{This is an interactive problem.}$\n\nYou are the head coach of a chess club. The club has $2n$ players, each player has some $\\emph{strength}$ which can be represented by a number, and all those numbers are distinct. The strengths of the players are not known to you.\n\nYou need to select $n$ players who would represent your club in the upcoming championship. Naturally, you want to select $n$ players with the highest strengths.\n\nYou can organize matches between the players to do that. In every match, you pick two players, they play some games, and you learn which one of the two has higher strength. You can wait for the outcome of a match before deciding who will participate in the next one.\n\nHowever, you do not want to know $\\emph{exactly}$ how those $n$ players compare between themselves, as that would make the championship itself less $\\emph{intriguing}$. More formally, you must reach a state where there is exactly one way to choose $n$ players with the highest strengths that is consistent with the outcomes of the matches you organized, but there must be at least two possible orderings of those $n$ players by strength that are consistent with the outcomes of the matches you organized.\n\n### Interaction Protocol\n\nYour program has to process multiple test cases in one run. First, it should read the integer $t$ ($t \\ge 1$) --- the number of test cases. Then, it should process the test cases one by one.\n\nIn each test case, your program should start by reading the integer $n$ ($3 \\le n \\le 100$) --- the number of players to select out of $2n$ players. The sum of squares of the values of $n$ over all test cases does not exceed $10\\,000$.\n\nThen your program can organize matches zero or more times. To organize a match, your program should print a match description formatted as $\\tt{?\\ i\\ j}$ --- a question mark followed by two distinct numbers of players participating in the match. The players are numbered from 1 to $2n$, inclusive. Remember to flush the output after printing the match description. Then your program should read the match outcome --- it will be either the greater-than character ($\\tt{>}$), if the first player in the match description has higher strength, or the less-than character ($\\tt{<}$), if the second player in the match description has higher strength.\n\nYour program can organize at most $4n^2$ matches. After it is done organizing matches, it should print the exclamation mark ($\\tt{!}$) and continue to the next test case, or exit gracefully if this was the last test case. Remember to flush the output after printing the exclamation mark.\n\nThere must be exactly one way to choose $n$ players with the highest strength that is consistent with the outcomes of the matches you organized, but there must be at least two possible orderings of those $n$ players by their strength that are consistent with the outcomes of the matches you organized.\n\nThe judging program picks some distinct numbers as the strengths of all players before your program starts organizing matches and uses them to answer the requests.", "inputFormat": "See Interaction Protocol", "outputFormat": "See Interaction Protocol", "hint": "In the example, the players in the first test case are sorted by strength in decreasing order. From the matches in the example output, we can deduce that players 1, 2, and 3 have the highest strength, but we do not know how the player 1 compares to the player 2.", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Intriguing Selection", "background": "", "description": "$\\emph{This is an interactive problem.}$\n\nYou are the head coach of a chess club. The club has $2n$ players, each player has some $\\emph{strength}$ which can be represented by a number, and all those numbers are distinct. The strengths of the players are not known to you.\n\nYou need to select $n$ players who would represent your club in the upcoming championship. Naturally, you want to select $n$ players with the highest strengths.\n\nYou can organize matches between the players to do that. In every match, you pick two players, they play some games, and you learn which one of the two has higher strength. You can wait for the outcome of a match before deciding who will participate in the next one.\n\nHowever, you do not want to know $\\emph{exactly}$ how those $n$ players compare between themselves, as that would make the championship itself less $\\emph{intriguing}$. More formally, you must reach a state where there is exactly one way to choose $n$ players with the highest strengths that is consistent with the outcomes of the matches you organized, but there must be at least two possible orderings of those $n$ players by strength that are consistent with the outcomes of the matches you organized.\n\n### Interaction Protocol\n\nYour program has to process multiple test cases in one run. First, it should read the integer $t$ ($t \\ge 1$) --- the number of test cases. Then, it should process the test cases one by one.\n\nIn each test case, your program should start by reading the integer $n$ ($3 \\le n \\le 100$) --- the number of players to select out of $2n$ players. The sum of squares of the values of $n$ over all test cases does not exceed $10\\,000$.\n\nThen your program can organize matches zero or more times. To organize a match, your program should print a match description formatted as $\\tt{?\\ i\\ j}$ --- a question mark followed by two distinct numbers of players participating in the match. The players are numbered from 1 to $2n$, inclusive. Remember to flush the output after printing the match description. Then your program should read the match outcome --- it will be either the greater-than character ($\\tt{>}$), if the first player in the match description has higher strength, or the less-than character ($\\tt{<}$), if the second player in the match description has higher strength.\n\nYour program can organize at most $4n^2$ matches. After it is done organizing matches, it should print the exclamation mark ($\\tt{!}$) and continue to the next test case, or exit gracefully if this was the last test case. Remember to flush the output after printing the exclamation mark.\n\nThere must be exactly one way to choose $n$ players with the highest strength that is consistent with the outcomes of the matches you organized, but there must be at least two possible orderings of those $n$ players by their strength that are consistent with the outcomes of the matches you organized.\n\nThe judging program picks some distinct numbers as the strengths of all players before your program starts organizing matches and uses them to answer the requests.", "inputFormat": "See Interaction Protocol", "outputFormat": "See Interaction Protocol", "hint": "In the example, the players in the first test case are sorted by strength in decreasing order. From the matches in the example output, we can deduce that players 1, 2, and 3 have the highest strength, but we do not know how the player 1 compares to the player 2.", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Intriguing Selection", "background": "", "description": "**这是一道交互题。**\n\n你是一家国际象棋俱乐部的总教练。俱乐部共有 $2n$ 名选手，每位选手都有一个独特的**实力值**（用数字表示），但这些实力值对你来说是未知的。\n\n你需要从中选出 $n$ 名选手代表俱乐部参加即将到来的锦标赛。自然，你希望选出实力最强的 $n$ 名选手。\n\n为此，你可以组织选手之间的比赛。每场比赛你需要选择两名选手进行对决，之后你会知道两人中谁的实力更强。你可以根据比赛结果来决定下一场比赛的参与者。\n\n但你不希望**完全**了解这 $n$ 名选手之间的具体实力排名，因为那样会让锦标赛本身变得不够**引人入胜**。更正式地说，你需要达到这样一种状态：根据已进行的比赛结果，恰好存在一种方式可以选出实力最强的 $n$ 名选手，但同时这些选手之间至少存在两种不同的实力排名顺序与比赛结果一致。\n\n### 交互协议\n\n你的程序需要处理多个测试用例。首先读取整数 $t$（$t \\ge 1$）表示测试用例数量，然后依次处理每个测试用例。\n\n在每个测试用例中：\n1. 首先读取整数 $n$（$3 \\le n \\le 100$），表示需要从 $2n$ 名选手中选出 $n$ 名。所有测试用例的 $n$ 的平方和不超过 $10\\,000$。\n2. 然后可以组织若干场比赛。要组织比赛，需要输出格式为 `? i j` 的指令（问号后跟两个不同的选手编号）。选手编号为 $1$ 到 $2n$。输出后需要刷新输出缓冲区。\n3. 之后读取比赛结果：`>` 表示第一个选手更强，`<` 表示第二个选手更强。\n4. 最多可以组织 $4n^2$ 场比赛。结束后输出 `!` 并处理下一个测试用例（或结束程序）。输出 `!` 后也需要刷新输出缓冲区。\n\n最终必须满足：\n- 根据比赛结果，恰好有一种方式可以选出实力最强的 $n$ 名选手\n- 但这些选手之间至少存在两种可能的实力排名顺序与比赛结果一致\n\n评测系统会在程序开始前为所有选手分配不同的实力值，并根据这些值回答比赛结果。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "在第一个测试用例中，选手按实力降序排列。根据示例中的比赛结果可以确定选手 1、2、3 是最强的三人，但我们无法确定选手 1 和 2 之间的具体强弱关系。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12943", "type": "P", "difficulty": 4, "samples": [["3\n11\n1 5 1 5 1 5 1 1 1 1 5\n6\n1 2 2 2 2 1\n5\n4 3 3 1 2", "3\n3\n4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Just Arrange the Icons", "background": "", "description": "BerPhone X is almost ready for release with $n$ applications being preinstalled on the phone. A $\\textit{category}$ of an application characterizes a genre or a theme of this application (like \"game\", \"business\", or \"education\"). The categories are given as integers between $1$ and $n$, inclusive; the $i$-th application has category $c_i$. \n\nYou can choose $m$ --- the number of screens and $s$ --- the size of each screen. You need to fit all $n$ icons of the applications (one icon representing one application) meeting the following requirements:\n\n- On each screen, all the icons must belong to applications of the same category (but different screens can contain icons of applications of the same category);\n- Each screen must be either completely filled with icons (the number of icons on the screen is equal to $s$) or almost filled with icons (the number of icons is equal to $s-1$).\n\nYour task is to find the minimal possible number of screens $m$.", "inputFormat": "The first line contains an integer $t$ ($1 \\le t \\le 10\\,000$) --- the number of test cases in the input. Then $t$ test cases follow.\n\nThe first line of each test case contains an integer $n$ ($1 \\le n \\le 2\\cdot10^6$) --- the number of the icons. The second line contains $n$ integers $c_1, c_2, \\dots, c_n$ ($1 \\le c_i \\le n$), where $c_i$ is the category of the $i$-th application.\n\nIt is guaranteed that the sum of the values of $n$ for all test cases in the input does not exceed $2\\cdot 10^6$.", "outputFormat": "Print $t$ integers --- the answers to the given test cases in the order they follow in the input. The answer to a test case is an integer $m$ --- the minimum number of screens on which all $n$ icons can be placed satisfying the given requirements.", "hint": "In the first test case of the example, all the icons can be placed on three screens of size $4$: a screen with $4$ icons of the category $1$, a screen with $3$ icons of the category $1$, and a screen with $4$ icons of the category $5$.", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Just Arrange the Icons", "background": "", "description": "BerPhone X is almost ready for release with $n$ applications being preinstalled on the phone. A $\\textit{category}$ of an application characterizes a genre or a theme of this application (like \"game\", \"business\", or \"education\"). The categories are given as integers between $1$ and $n$, inclusive; the $i$-th application has category $c_i$. \n\nYou can choose $m$ --- the number of screens and $s$ --- the size of each screen. You need to fit all $n$ icons of the applications (one icon representing one application) meeting the following requirements:\n\n- On each screen, all the icons must belong to applications of the same category (but different screens can contain icons of applications of the same category);\n- Each screen must be either completely filled with icons (the number of icons on the screen is equal to $s$) or almost filled with icons (the number of icons is equal to $s-1$).\n\nYour task is to find the minimal possible number of screens $m$.", "inputFormat": "The first line contains an integer $t$ ($1 \\le t \\le 10\\,000$) --- the number of test cases in the input. Then $t$ test cases follow.\n\nThe first line of each test case contains an integer $n$ ($1 \\le n \\le 2\\cdot10^6$) --- the number of the icons. The second line contains $n$ integers $c_1, c_2, \\dots, c_n$ ($1 \\le c_i \\le n$), where $c_i$ is the category of the $i$-th application.\n\nIt is guaranteed that the sum of the values of $n$ for all test cases in the input does not exceed $2\\cdot 10^6$.", "outputFormat": "Print $t$ integers --- the answers to the given test cases in the order they follow in the input. The answer to a test case is an integer $m$ --- the minimum number of screens on which all $n$ icons can be placed satisfying the given requirements.", "hint": "In the first test case of the example, all the icons can be placed on three screens of size $4$: a screen with $4$ icons of the category $1$, a screen with $3$ icons of the category $1$, and a screen with $4$ icons of the category $5$.", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Just Arrange the Icons", "background": "", "description": "BerPhone X 即将发布，手机预装了 $n$ 个应用程序。每个应用程序都有一个**类别**，用于描述该应用的类型或主题（如\"游戏\"、\"商业\"或\"教育\"）。类别用 $1$ 到 $n$ 之间的整数表示，第 $i$ 个应用程序的类别为 $c_i$。\n\n你需要选择两个参数：\n- $m$ —— 屏幕数量\n- $s$ —— 每个屏幕的容量\n\n要求将所有 $n$ 个应用图标（每个图标代表一个应用）按照以下规则排列：\n\n1. 同一屏幕上的所有图标必须属于同一类别的应用（不同屏幕可以包含同一类别的图标）；\n2. 每个屏幕必须要么完全填满图标（图标数量等于 $s$），要么几乎填满（图标数量等于 $s-1$）。\n\n你的任务是找出满足条件的最小屏幕数量 $m$。", "inputFormat": "第一行包含一个整数 $t$（$1 \\le t \\le 10\\,000$）—— 测试用例的数量。随后是 $t$ 个测试用例。\n\n每个测试用例的第一行包含一个整数 $n$（$1 \\le n \\le 2 \\cdot 10^6$）—— 图标数量。第二行包含 $n$ 个整数 $c_1, c_2, \\dots, c_n$（$1 \\le c_i \\le n$），其中 $c_i$ 表示第 $i$ 个应用的类别。\n\n保证所有测试用例的 $n$ 之和不超过 $2 \\cdot 10^6$。", "outputFormat": "输出 $t$ 个整数 —— 按输入顺序给出每个测试用例的答案。每个答案是一个整数 $m$，表示满足条件所需的最小屏幕数量。\n", "hint": "在第一个测试用例中，所有图标可以排列在 3 个容量为 4 的屏幕上：\n- 1 个屏幕放置 4 个类别 1 的图标\n- 1 个屏幕放置 3 个类别 1 的图标\n- 1 个屏幕放置 4 个类别 5 的图标\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12944", "type": "P", "difficulty": 0, "samples": [["3\n1\n11\n123456", "0\n1\n127"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Key Storage", "background": "", "description": "Karl is developing a key storage service. Each user has a positive integer key.\n\nKarl knows that storing keys in plain text is bad practice. So, instead of storing a key, he decided to store a fingerprint of a key. However, using some existing fingerprint algorithm looked too boring to him, so he invented his own one.\n\nKarl's fingerprint is calculated by the following process: divide the given integer by 2, then divide the result by 3, then divide the result by 4, and so on, until we get a result that equals zero (we are speaking about integer division each time). \nThe fingerprint is defined as the multiset of the remainders of these divisions. \n\nFor example, this is how Karl's fingerprint algorithm is applied to the key 11: 11 divided by 2 has remainder 1 and result 5, then 5 divided by 3 has remainder 2 and result 1, and 1 divided by 4 has remainder 1 and result 0. Thus, the key 11 produces the sequence of remainders $[1, 2, 1]$ and has the fingerprint multiset $\\{1, 1, 2\\}$.\n\nKsenia wants to prove that Karl's fingerprint algorithm is not very good. For example, she found that both keys 178800 and 123456 produce the fingerprint of $\\{0, 0, 0, 0, 2, 3, 3, 4\\}$. Thus, users are at risk of fingerprint collision with some commonly used and easy to guess keys like 123456.\n\nKsenia wants to make her words more persuasive. She wants to calculate the number of other keys that have the same fingerprint as the keys in the given list of some commonly used keys. Your task is to help her.", "inputFormat": "The first line contains an integer $t$ ($1 \\le t \\le 50\\,000$) --- the number of commonly used keys to examine. \nEach of the next $t$ lines contains one integer $k_i$ ($1 \\le k_i \\le 10^{18}$) --- the key itself. ", "outputFormat": "For each of the keys print one integer --- the number of other keys that have the same fingerprint. ", "hint": "The other key with the same fingerprint as 11 is 15. 15 produces a sequence of remainders $[1, 1, 2]$. So both numbers have the fingerprint multiset $\\{1, 1, 2\\}$.", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Key Storage", "background": "", "description": "Karl is developing a key storage service. Each user has a positive integer key.\n\nKarl knows that storing keys in plain text is bad practice. So, instead of storing a key, he decided to store a fingerprint of a key. However, using some existing fingerprint algorithm looked too boring to him, so he invented his own one.\n\nKarl's fingerprint is calculated by the following process: divide the given integer by 2, then divide the result by 3, then divide the result by 4, and so on, until we get a result that equals zero (we are speaking about integer division each time). \nThe fingerprint is defined as the multiset of the remainders of these divisions. \n\nFor example, this is how Karl's fingerprint algorithm is applied to the key 11: 11 divided by 2 has remainder 1 and result 5, then 5 divided by 3 has remainder 2 and result 1, and 1 divided by 4 has remainder 1 and result 0. Thus, the key 11 produces the sequence of remainders $[1, 2, 1]$ and has the fingerprint multiset $\\{1, 1, 2\\}$.\n\nKsenia wants to prove that Karl's fingerprint algorithm is not very good. For example, she found that both keys 178800 and 123456 produce the fingerprint of $\\{0, 0, 0, 0, 2, 3, 3, 4\\}$. Thus, users are at risk of fingerprint collision with some commonly used and easy to guess keys like 123456.\n\nKsenia wants to make her words more persuasive. She wants to calculate the number of other keys that have the same fingerprint as the keys in the given list of some commonly used keys. Your task is to help her.", "inputFormat": "The first line contains an integer $t$ ($1 \\le t \\le 50\\,000$) --- the number of commonly used keys to examine. \nEach of the next $t$ lines contains one integer $k_i$ ($1 \\le k_i \\le 10^{18}$) --- the key itself. ", "outputFormat": "For each of the keys print one integer --- the number of other keys that have the same fingerprint. ", "hint": "The other key with the same fingerprint as 11 is 15. 15 produces a sequence of remainders $[1, 1, 2]$. So both numbers have the fingerprint multiset $\\{1, 1, 2\\}$.", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Key Storage", "background": "", "description": "Karl 正在开发一个密钥存储服务。每个用户都有一个正整数密钥。\n\nKarl 知道明文存储密钥是不安全的做法。因此，他决定不直接存储密钥，而是存储密钥的**指纹**。不过他觉得使用现有的指纹算法太无聊了，于是自己发明了一种新的算法。\n\nKarl 的指纹算法计算过程如下：\n1. 将给定的整数除以 2（整数除法）\n2. 将结果除以 3\n3. 继续除以 4\n4. 依此类推，直到结果为 0\n指纹定义为这些除法运算产生的余数组成的**多重集**。\n\n例如，对密钥 11 应用该算法：\n- 11 ÷ 2 = 5 余 1\n- 5 ÷ 3 = 1 余 2\n- 1 ÷ 4 = 0 余 1\n因此密钥 11 产生的余数序列是 $[1, 2, 1]$，指纹多重集为 $\\{1, 1, 2\\}$。\n\nKsenia 想证明 Karl 的指纹算法并不完善。例如她发现密钥 178800 和 123456 都会产生相同的指纹 $\\{0, 0, 0, 0, 2, 3, 3, 4\\}$。这意味着像 123456 这样常用且容易猜测的密钥可能会与其他密钥产生指纹冲突。\n\nKsenia 想用更有说服力的数据来证明这一点。她需要计算与给定常用密钥列表中的密钥具有相同指纹的其他密钥数量。你的任务就是帮助她完成这个计算。", "inputFormat": "第一行包含一个整数 $t$（$1 \\le t \\le 50\\,000$）—— 需要检查的常用密钥数量。\n接下来的 $t$ 行，每行包含一个整数 $k_i$（$1 \\le k_i \\le 10^{18}$）—— 密钥值。\n", "outputFormat": "对于每个密钥，输出一个整数 —— 与该密钥具有相同指纹的其他密钥数量。\n", "hint": "与密钥 11 具有相同指纹的另一个密钥是 15。15 产生的余数序列是 $[1, 1, 2]$，因此这两个密钥的指纹多重集都是 $\\{1, 1, 2\\}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12945", "type": "P", "difficulty": 4, "samples": [["3 2 2\nabcdef", "af\nbc\ned"], ["2 3 1\nabcabc", "aab\nbcc"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2019] Lexicography", "background": "", "description": "Lucy likes letters. She studied the definition of the lexicographical order at school and plays with it.\n\nAt first, she tried to construct the lexicographically smallest word out of given letters. It was so easy! Then she tried to build multiple words and minimize one of them. This was much harder!\n\nFormally, Lucy wants to make $n$ words of length $l$ each out of the given $n \\cdot l$ letters, so that the $k$-th of them in the lexicographic order is lexicographically as small as possible.", "inputFormat": "The first line contains three integers $n$, $l$, and $k$ ($1\\le k \\le n \\le 1\\,000$; $1 \\le l \\le 1\\,000$) --- the total number of words, the length of each word, and the index of the word Lucy wants to minimize.\n\nThe next line contains a string of $n \\cdot l$ lowercase letters of the English alphabet.", "outputFormat": "Output $n$ words of $l$ letters each, one per line, using the letters from the input. Words must be sorted in the lexicographic order, and the $k$-th of them must be lexicographically as small as possible. If there are multiple answers with the smallest $k$-th word, output any of them.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2019] Lexicography", "background": "", "description": "Lucy likes letters. She studied the definition of the lexicographical order at school and plays with it.\n\nAt first, she tried to construct the lexicographically smallest word out of given letters. It was so easy! Then she tried to build multiple words and minimize one of them. This was much harder!\n\nFormally, Lucy wants to make $n$ words of length $l$ each out of the given $n \\cdot l$ letters, so that the $k$-th of them in the lexicographic order is lexicographically as small as possible.", "inputFormat": "The first line contains three integers $n$, $l$, and $k$ ($1\\le k \\le n \\le 1\\,000$; $1 \\le l \\le 1\\,000$) --- the total number of words, the length of each word, and the index of the word Lucy wants to minimize.\n\nThe next line contains a string of $n \\cdot l$ lowercase letters of the English alphabet.", "outputFormat": "Output $n$ words of $l$ letters each, one per line, using the letters from the input. Words must be sorted in the lexicographic order, and the $k$-th of them must be lexicographically as small as possible. If there are multiple answers with the smallest $k$-th word, output any of them.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2019] Lexicography", "background": "", "description": "Lucy 喜欢字母。她在学校学习了字典序的定义，并经常用它来做游戏。\n\n起初，她尝试用给定的字母构造字典序最小的单词。这很简单！然后她尝试构造多个单词，并最小化其中某一个单词的字典序。这就难多了！\n\n具体来说，Lucy 希望用给定的 $n \\cdot l$ 个字母构造 $n$ 个长度为 $l$ 的单词，使得这些单词按字典序排列时，第 $k$ 个单词的字典序尽可能小。\n", "inputFormat": "第一行包含三个整数 $n$、$l$ 和 $k$（$1 \\le k \\le n \\le 1\\,000$；$1 \\le l \\le 1\\,000$）—— 单词总数、每个单词的长度，以及 Lucy 想要最小化的单词序号。\n\n第二行包含一个由 $n \\cdot l$ 个小写英文字母组成的字符串。", "outputFormat": "输出 $n$ 个长度为 $l$ 的单词，每个单词占一行，使用输入中的字母。这些单词必须按字典序排列，且其中第 $k$ 个单词的字典序要尽可能小。如果有多个解都能使第 $k$ 个单词字典序最小，输出其中任意一个即可。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12946", "type": "P", "difficulty": 2, "samples": [["2\n0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n4\nABC\nBC\nBCD\nCDE\n0 1 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n3\nCDE\nDEF\nEFG", "Case #1: NO\nCase #2: YES"]], "limits": {"time": [20000, 20000, 20000], "memory": [2097152, 2097152, 2097152]}, "tags": ["字符串", "2023", "哈希 hashing", "Google Code Jam"], "title": "[GCJ Farewell Round #1] Colliding Encoding", "background": "", "description": "Alan just had his first cryptography class in school today. He decided to apply what he learned and come up with his own cipher. He will map each English letter from `A` to `Z` to a decimal digit $0$ through $9$. He will then try to encode each word to a string consisting of decimal digits by replacing each letter in the word with its mapped digit.\n\nIn his excitement, Alan failed to notice that there are $26$ letters in the English alphabet and only $10$ decimal digits. As a result, there might be collisions, that is, pairs of different words whose encoding is the same.\n\nGiven a list of $N$ words that Alan wants to encode and the mapping that he uses, can you find out if there would be any collisions between words on the list?", "inputFormat": "The first line of the input gives the number of test cases, T. T test cases follow.\n\nThe first line of each test case contains 26 decimal digits (integers between 0 and 9, inclusive) $D_A$, $D_B$, …, $D_Z$, representing the mapping that Alan uses. A letter $\\alpha$ is mapped to digit $D_\\alpha$.\n\nThe second line of each test case contains N, the number of words Alan will encode.\n\nThe $i$-th of the last N lines contains a string $S_i$, representing the $i$-th word Alan will encode.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either `YES`, if there is at least one pair of different words from the list whose encoding coincides, and NO otherwise.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the mapping for A is 0, for B is 1, for C is 2, for D is 3, and for E is 3. With this mapping, ABC is encoded as 012, BC is encoded as 12, BCD as 123, and CDE as 233. Since all of these encodings are distinct, there are no collisions.\n\nIn Sample Case #2, the mapping for C is 2, for D is 3, for E is 3, for F is 3, and for G is 3. With this mapping, CDE is encoded as 233, DEF as 333, and EFG as 333. Since the encoding for DEF and EFG is the same, there is a collision.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{D}_{\\alpha} \\leq 9$, for all $\\alpha$.\n- $1 \\leq$ the length of $\\mathbf{S}_{i} \\leq 10$, for all $i$.\n- Each character of $\\mathbf{S}_{i}$ is an uppercase English letter A through Z, for all $i$.\n- $\\mathbf{S}_{i} \\neq \\mathbf{S}_{j}$, for all $i \\neq j$.\n\n**Test Set 1 (4Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 2 (10Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 6 \\times 10^{4}$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #1] Colliding Encoding", "background": "", "description": "Alan just had his first cryptography class in school today. He decided to apply what he learned and come up with his own cipher. He will map each English letter from `A` to `Z` to a decimal digit $0$ through $9$. He will then try to encode each word to a string consisting of decimal digits by replacing each letter in the word with its mapped digit.\n\nIn his excitement, Alan failed to notice that there are $26$ letters in the English alphabet and only $10$ decimal digits. As a result, there might be collisions, that is, pairs of different words whose encoding is the same.\n\nGiven a list of $N$ words that Alan wants to encode and the mapping that he uses, can you find out if there would be any collisions between words on the list?", "inputFormat": "The first line of the input gives the number of test cases, T. T test cases follow.\n\nThe first line of each test case contains 26 decimal digits (integers between 0 and 9, inclusive) $D_A$, $D_B$, …, $D_Z$, representing the mapping that Alan uses. A letter $\\alpha$ is mapped to digit $D_\\alpha$.\n\nThe second line of each test case contains N, the number of words Alan will encode.\n\nThe $i$-th of the last N lines contains a string $S_i$, representing the $i$-th word Alan will encode.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either `YES`, if there is at least one pair of different words from the list whose encoding coincides, and NO otherwise.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the mapping for A is 0, for B is 1, for C is 2, for D is 3, and for E is 3. With this mapping, ABC is encoded as 012, BC is encoded as 12, BCD as 123, and CDE as 233. Since all of these encodings are distinct, there are no collisions.\n\nIn Sample Case #2, the mapping for C is 2, for D is 3, for E is 3, for F is 3, and for G is 3. With this mapping, CDE is encoded as 233, DEF as 333, and EFG as 333. Since the encoding for DEF and EFG is the same, there is a collision.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{D}_{\\alpha} \\leq 9$, for all $\\alpha$.\n- $1 \\leq$ the length of $\\mathbf{S}_{i} \\leq 10$, for all $i$.\n- Each character of $\\mathbf{S}_{i}$ is an uppercase English letter A through Z, for all $i$.\n- $\\mathbf{S}_{i} \\neq \\mathbf{S}_{j}$, for all $i \\neq j$.\n\n**Test Set 1 (4Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 2 (10Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 6 \\times 10^{4}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #1] Colliding Encoding", "background": "", "description": "**Alan** 今天在学校上了第一节密码学课程。他决定运用所学知识，设计自己的加密方式。他计划将字母 `A` 到 `Z` 分别映射到十进制数字 $0$ 到 $9$。然后，他会将每个单词中的字母替换为对应的数字，从而将单词编码为一个由数字组成的字符串。\n\n由于过于兴奋，**Alan** 没有注意到英文字母共有 $26$ 个，而十进制数字只有 $10$ 个。因此，可能会出现**碰撞**，即不同的单词被编码为相同的字符串。\n\n给定 **Alan** 想要编码的 $N$ 个单词及其使用的映射规则，请判断列表中是否存在至少一对单词会发生碰撞。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。随后是 $T$ 个测试用例。\n\n每个测试用例的第一行包含 $26$ 个十进制数字（$0$ 到 $9$ 的整数）$D_A$, $D_B$, …, $D_Z$，表示 **Alan** 使用的映射规则。字母 $\\alpha$ 被映射为数字 $D_\\alpha$。\n\n每个测试用例的第二行包含一个整数 $N$，表示 **Alan** 需要编码的单词数量。\n\n接下来的 $N$ 行中，第 $i$ 行包含一个字符串 $S_i$，表示 **Alan** 要编码的第 $i$ 个单词。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 为 `YES`（如果列表中至少存在一对不同单词的编码相同）或 `NO`（否则）。\n", "hint": "**样例解释**\n\n在样例 #1 中，`A` 映射为 $0$，`B` 为 $1$，`C` 为 $2$，`D` 为 $3$，`E` 为 $3$。此时，`ABC` 编码为 $012$，`BC` 为 $12$，`BCD` 为 $123$，`CDE` 为 $233$。由于所有编码均不同，因此没有碰撞。\n\n在样例 #2 中，`C` 映射为 $2$，`D` 为 $3$，`E` 为 $3$，`F` 为 $3$，`G` 为 $3$。此时，`CDE` 编码为 $233$，`DEF` 和 `EFG` 均为 $333$。由于 `DEF` 和 `EFG` 的编码相同，因此存在碰撞。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $\\alpha$，$0 \\leq \\mathbf{D}_{\\alpha} \\leq 9$。\n- 对于所有 $i$，$1 \\leq \\mathbf{S}_{i}$ 的长度 $\\leq 10$。\n- 对于所有 $i$，$\\mathbf{S}_{i}$ 的每个字符均为大写字母 `A` 到 `Z`。\n- 对于所有 $i \\neq j$，$\\mathbf{S}_{i} \\neq \\mathbf{S}_{j}$。\n\n**测试集 1（4 分，可见判定）**\n\n- $1 \\leq \\mathbf{N} \\leq 100$。\n\n**测试集 2（10 分，可见判定）**\n\n- $1 \\leq \\mathbf{N} \\leq 6 \\times 10^{4}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12947", "type": "P", "difficulty": 2, "samples": [["3\n10 3 3\n2 7 9\n10 2 3\n2 7 9\n10 2 4\n2 3 7 9", "Case #1: 2\nCase #2: IMPOSSIBLE\nCase #3: 4"]], "limits": {"time": [10000, 10000, 10000], "memory": [2097152, 2097152, 2097152]}, "tags": ["贪心", "2023", "Google Code Jam"], "title": "[GCJ Farewell Round #1] Illumination Optimization", "background": "", "description": "Onyaomale is leading a project to exchange the lightbulbs from street lights along a freeway from incandescent ones to LED lightbulbs that are both more energy-efficient and powerful. She started by taking all the old incandescent lightbulbs out, and is now focused on installing the new LED ones. Because the new lightbulbs are more powerful, Onyaomale thinks it is possible that some street lights are not necessary and she can save even more energy by not using them.\n\nWe model the freeway as a straight line measuring $\\mathbf{M}$ meters that goes from west to east. The $x$-th meter is a point that is $x$ meters to the east of the western end of the freeway. If a street light is located at the $x$-th meter, and a lightbulb with an illumination radius of $\\mathbf{R}$ meters is installed on it, then the street light illuminates the segment of freeway starting at the $\\max(0, x - \\mathbf{R})$-th meter and ending at the $\\min(\\mathbf{M}, x + \\mathbf{R})$-th meter, inclusive. Onyaomale needs to install lightbulbs in such a way that every point of the freeway is illuminated by at least one of them. Notice that this includes illuminating points that are not an integer number of meters away from the freeway endpoints. Street lights that are left without a lightbulb do not illuminate anything.\n\nGiven the length of the freeway in meters $\\mathbf{M}$, the illumination radius of the new lightbulbs $\\mathbf{R}$ and the locations of all street lights, find the minimum number of lightbulbs Onyaomale needs to install to illuminate the whole freeway, or report that it is impossible to do so.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line contains three integers $\\mathbf{M}$, $\\mathbf{R}$, and $\\mathbf{N}$: the length, in meters, of the freeway, the illumination radius, in meters, of the lightbulbs and the number of street lights, respectively. The second line of a test case contains $\\mathbf{N}$ sorted integers $\\mathbf{X}_1$, $\\mathbf{X}_2$, $\\ldots$, $\\mathbf{X}_\\mathbf{N}$ representing the meters of the freeway where street lights are located.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of lightbulbs Onyaomale needs to install to illuminate the whole freeway, if it is possible. If there is no way to illuminate the entire freeway using the current street lights, $y$ should be IMPOSSIBLE instead.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, Onyaomale can illuminate the entire freeway by placing bulbs in the western-most and middle street lights only, leaving the eastern-most one unused. With these two lights covering $[0,5]$ and $[4,10]$, the entire freeway $([0,10])$ is illuminated.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jbc1t6nr.png)\n\nIn Sample Case #2, Onyaomale has the same configuration as in Sample Case #1, but with weaker lightbulbs. In this case, there is no way for her to illuminate the entire freeway. In particular, even if all the street lights are lit, the middle point between the $4$-th and $5$-th meters would still not be illuminated.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ruj47i6y.png)\n\nFor Sample Case #3 Onyaomale has an additional street light at the $3$-th meter, compared to Sample Case #2, while all other conditions are the same. In this case, installing a lightbulb in every street light is the only way to have the entire freeway illuminated.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/090hfaye.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100.$\n- $1 \\leq \\mathbf{M} \\leq 10^{9}.$\n- $1 \\leq \\mathbf{R} \\leq 10^{9}.$\n- $0 \\leq \\mathbf{X}_{1}.$\n- $\\mathbf{X}_{i} < \\mathbf{X}_{i+1}, \\text{ for all } i.$\n- $\\mathbf{X}_{\\mathbf{N}} \\leq \\mathbf{M}.$\n\n**Test Set 1 (4Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10.$\n\n**Test Set 2 (10Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10^{5}.$\n", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #1] Illumination Optimization", "background": "", "description": "Onyaomale is leading a project to exchange the lightbulbs from street lights along a freeway from incandescent ones to LED lightbulbs that are both more energy-efficient and powerful. She started by taking all the old incandescent lightbulbs out, and is now focused on installing the new LED ones. Because the new lightbulbs are more powerful, Onyaomale thinks it is possible that some street lights are not necessary and she can save even more energy by not using them.\n\nWe model the freeway as a straight line measuring $\\mathbf{M}$ meters that goes from west to east. The $x$-th meter is a point that is $x$ meters to the east of the western end of the freeway. If a street light is located at the $x$-th meter, and a lightbulb with an illumination radius of $\\mathbf{R}$ meters is installed on it, then the street light illuminates the segment of freeway starting at the $\\max(0, x - \\mathbf{R})$-th meter and ending at the $\\min(\\mathbf{M}, x + \\mathbf{R})$-th meter, inclusive. Onyaomale needs to install lightbulbs in such a way that every point of the freeway is illuminated by at least one of them. Notice that this includes illuminating points that are not an integer number of meters away from the freeway endpoints. Street lights that are left without a lightbulb do not illuminate anything.\n\nGiven the length of the freeway in meters $\\mathbf{M}$, the illumination radius of the new lightbulbs $\\mathbf{R}$ and the locations of all street lights, find the minimum number of lightbulbs Onyaomale needs to install to illuminate the whole freeway, or report that it is impossible to do so.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line contains three integers $\\mathbf{M}$, $\\mathbf{R}$, and $\\mathbf{N}$: the length, in meters, of the freeway, the illumination radius, in meters, of the lightbulbs and the number of street lights, respectively. The second line of a test case contains $\\mathbf{N}$ sorted integers $\\mathbf{X}_1$, $\\mathbf{X}_2$, $\\ldots$, $\\mathbf{X}_\\mathbf{N}$ representing the meters of the freeway where street lights are located.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of lightbulbs Onyaomale needs to install to illuminate the whole freeway, if it is possible. If there is no way to illuminate the entire freeway using the current street lights, $y$ should be IMPOSSIBLE instead.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, Onyaomale can illuminate the entire freeway by placing bulbs in the western-most and middle street lights only, leaving the eastern-most one unused. With these two lights covering $[0,5]$ and $[4,10]$, the entire freeway $([0,10])$ is illuminated.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jbc1t6nr.png)\n\nIn Sample Case #2, Onyaomale has the same configuration as in Sample Case #1, but with weaker lightbulbs. In this case, there is no way for her to illuminate the entire freeway. In particular, even if all the street lights are lit, the middle point between the $4$-th and $5$-th meters would still not be illuminated.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ruj47i6y.png)\n\nFor Sample Case #3 Onyaomale has an additional street light at the $3$-th meter, compared to Sample Case #2, while all other conditions are the same. In this case, installing a lightbulb in every street light is the only way to have the entire freeway illuminated.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/090hfaye.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100.$\n- $1 \\leq \\mathbf{M} \\leq 10^{9}.$\n- $1 \\leq \\mathbf{R} \\leq 10^{9}.$\n- $0 \\leq \\mathbf{X}_{1}.$\n- $\\mathbf{X}_{i} < \\mathbf{X}_{i+1}, \\text{ for all } i.$\n- $\\mathbf{X}_{\\mathbf{N}} \\leq \\mathbf{M}.$\n\n**Test Set 1 (4Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10.$\n\n**Test Set 2 (10Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10^{5}.$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #1] Illumination Optimization", "background": "", "description": "**Onyaomale** 正在领导一个项目，将高速公路沿线路灯的白炽灯泡更换为更节能且亮度更高的 LED 灯泡。她已将所有旧白炽灯泡拆除，现在专注于安装新的 LED 灯泡。由于新灯泡亮度更高，**Onyaomale** 认为部分路灯可能不再必要，通过停用这些路灯可以进一步节省能源。\n\n我们将高速公路建模为一条从西向东延伸、长度为 $\\mathbf{M}$ 米的直线。第 $x$ 米表示距离高速公路西端 $x$ 米的点。如果一盏路灯位于第 $x$ 米处，并安装了照明半径为 $\\mathbf{R}$ 米的灯泡，则该路灯会照亮从第 $\\max(0, x - \\mathbf{R})$ 米到第 $\\min(\\mathbf{M}, x + \\mathbf{R})$ 米（含端点）的高速公路段。**Onyaomale** 需要以最少数量的灯泡安装方案，确保高速公路的每个点都被至少一盏灯照亮。注意，这包括非整米距离的点。未安装灯泡的路灯不会照亮任何区域。\n\n给定高速公路的长度 $\\mathbf{M}$、新灯泡的照明半径 $\\mathbf{R}$ 以及所有路灯的位置，求 **Onyaomale** 需要安装的最少灯泡数量以满足全路段照明需求。如果无法实现全路段照明，则报告不可能。\n", "inputFormat": "输入的第一行包含测试用例数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含两行：第一行是三个整数 $\\mathbf{M}$、$\\mathbf{R}$ 和 $\\mathbf{N}$，分别表示高速公路长度（米）、灯泡照明半径（米）和路灯数量；第二行包含 $\\mathbf{N}$ 个按升序排列的整数 $\\mathbf{X}_1, \\mathbf{X}_2, \\ldots, \\mathbf{X}_\\mathbf{N}$，表示路灯所在的位置（米）。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为最少需要安装的灯泡数量。如果无法实现全路段照明，则 $y$ 为 `IMPOSSIBLE`。\n", "hint": "**样例解释**\n\n在样例 #1 中，**Onyaomale** 只需在最西侧和中间的路灯上安装灯泡，无需使用最东侧的灯。这两个灯泡分别覆盖 $[0,5]$ 和 $[4,10]$，因此整个高速公路 $[0,10]$ 均被照亮。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jbc1t6nr.png)\n\n在样例 #2 中，配置与样例 #1 相同，但灯泡照明半径更小。此时无法实现全路段照明。即使所有路灯均点亮，第 $4$ 米与第 $5$ 米之间的中点仍未被覆盖。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ruj47i6y.png)\n\n在样例 #3 中，相比样例 #2 新增了一盏位于第 $3$ 米的路灯。此时必须为所有路灯安装灯泡才能实现全路段照明。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/090hfaye.png)\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{M} \\leq 10^{9}$。\n- $1 \\leq \\mathbf{R} \\leq 10^{9}$。\n- $0 \\leq \\mathbf{X}_{1}$。\n- 对所有 $i$，满足 $\\mathbf{X}_{i} < \\mathbf{X}_{i+1}$。\n- $\\mathbf{X}_{\\mathbf{N}} \\leq \\mathbf{M}$。\n\n**测试集 1（4 分，可见判定）**\n\n- $1 \\leq \\mathbf{N} \\leq 10$。\n\n**测试集 2（10 分，可见判定）**\n\n- $1 \\leq \\mathbf{N} \\leq 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12948", "type": "P", "difficulty": 3, "samples": [["2\n4\n3 8 8 2\n5\n3 8 2 2 8", "Case #1: 3 8 2\nCase #2: IMPOSSIBLE"]], "limits": {"time": [20000, 20000, 20000], "memory": [2097152, 2097152, 2097152]}, "tags": ["2023", "Google Code Jam"], "title": "[GCJ Farewell Round #1] Rainbow Sort", "background": "", "description": "Your friend Charles gives you a challenge. He puts $\\mathbf{N}$ cards on a table and arranges them in a line in an order that he chooses. Each card has a single color, and each color can be on one or more cards.\n\nCharles then asks you to write a positive integer on each card without altering his chosen order such that:\n\n1. The integers you write appear in non-decreasing order when cards are read from left to right.\n2. Cards of the same color have the same integer written on them.\n3. Cards of different colors have different integers written on them.\n\nFinally, Charles wants you to order the colors in increasing order of written integer. For example, if blue cards have a 2, red cards have a 5, and green cards have a 3, the color order would be blue, green, red.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow.\n\nEach test case begins with a line containing the integer $\\mathbf{N}$. The next line contains $\\mathbf{N}$ integers, $\\mathbf{S}_1$, $\\mathbf{S}_2$, $\\ldots$, $\\mathbf{S}_\\mathbf{N}$, where $\\mathbf{S}_i$ represents the color of the $i$-th card from the left.", "outputFormat": "For each test case, output one line containing Case #x: y, where $x$ is the test case number (starting from 1) and $y$ is the set of colors, once each, listed in the requested order. If it is impossible to write integers in the given cards while adhering to all the rules, $y$ must be IMPOSSIBLE instead.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 3 different colors on 4 cards. One possible solution is to write the following integers, in order: 1, 2, 2, and 3. Notice that the same integer (2) is written on both cards of color 8. Then, the order of the colors is 3, 8, 2.\n\nIn Sample Case #2, let $c_8$ and $c_2$ be the integers written in cards of color 8 and 2, respectively. If $c_2 > c_8$ then the rightmost two cards would not have their integers in non-decreasing order. If $c_2 < c_8$ that would happen to the second and third card from the left. Finally, $c_8 = c_2$ is forbidden by one of the rules. Therefore, there is no valid way of writing the integers in this case.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100.$\n- $1 \\leq \\mathbf{S}_{i} \\leq 10^{5}, \\text{ for all } i.$\n\n**Test Set 1 (4Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10.$\n\n**Test Set 2 (10Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10^{5}.$\n", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #1] Rainbow Sort", "background": "", "description": "Your friend Charles gives you a challenge. He puts $\\mathbf{N}$ cards on a table and arranges them in a line in an order that he chooses. Each card has a single color, and each color can be on one or more cards.\n\nCharles then asks you to write a positive integer on each card without altering his chosen order such that:\n\n1. The integers you write appear in non-decreasing order when cards are read from left to right.\n2. Cards of the same color have the same integer written on them.\n3. Cards of different colors have different integers written on them.\n\nFinally, Charles wants you to order the colors in increasing order of written integer. For example, if blue cards have a 2, red cards have a 5, and green cards have a 3, the color order would be blue, green, red.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow.\n\nEach test case begins with a line containing the integer $\\mathbf{N}$. The next line contains $\\mathbf{N}$ integers, $\\mathbf{S}_1$, $\\mathbf{S}_2$, $\\ldots$, $\\mathbf{S}_\\mathbf{N}$, where $\\mathbf{S}_i$ represents the color of the $i$-th card from the left.", "outputFormat": "For each test case, output one line containing Case #x: y, where $x$ is the test case number (starting from 1) and $y$ is the set of colors, once each, listed in the requested order. If it is impossible to write integers in the given cards while adhering to all the rules, $y$ must be IMPOSSIBLE instead.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 3 different colors on 4 cards. One possible solution is to write the following integers, in order: 1, 2, 2, and 3. Notice that the same integer (2) is written on both cards of color 8. Then, the order of the colors is 3, 8, 2.\n\nIn Sample Case #2, let $c_8$ and $c_2$ be the integers written in cards of color 8 and 2, respectively. If $c_2 > c_8$ then the rightmost two cards would not have their integers in non-decreasing order. If $c_2 < c_8$ that would happen to the second and third card from the left. Finally, $c_8 = c_2$ is forbidden by one of the rules. Therefore, there is no valid way of writing the integers in this case.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100.$\n- $1 \\leq \\mathbf{S}_{i} \\leq 10^{5}, \\text{ for all } i.$\n\n**Test Set 1 (4Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10.$\n\n**Test Set 2 (10Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10^{5}.$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #1] Rainbow Sort", "background": "", "description": "你的朋友 **Charles** 给你出了一个挑战。他在桌上排列了 $\\mathbf{N}$ 张卡片，并按他选择的顺序排成一条直线。每张卡片有一种颜色，同一种颜色可能出现在多张卡片上。\n\n**Charles** 要求你在不改变他原有排列顺序的前提下，为每张卡片写上一个正整数，满足以下条件：\n\n1. 当从左到右阅读卡片时，卡片上的数字必须是非递减的。\n2. 相同颜色的卡片必须写上相同的数字。\n3. 不同颜色的卡片必须写上不同的数字。\n\n最后，**Charles** 希望你按照数字从小到大的顺序排列这些颜色。例如，如果蓝色卡片写的是 2，红色卡片写的是 5，绿色卡片写的是 3，那么颜色顺序应为蓝色、绿色、红色。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。\n\n每个测试用例的第一行包含一个整数 $\\mathbf{N}$。接下来一行包含 $\\mathbf{N}$ 个整数 $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{N}$，其中 $\\mathbf{S}_i$ 表示从左数第 $i$ 张卡片的颜色。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是按要求顺序排列的颜色集合（每个颜色仅出现一次）。如果无法在满足所有规则的情况下为卡片写上数字，则 $y$ 应为 `IMPOSSIBLE`。\n", "hint": "**样例解释**\n\n在样例 #1 中，4 张卡片共有 3 种不同颜色。一种可行的解决方案是按顺序写上以下数字：1、2、2、3。注意颜色为 8 的两张卡片都写上了相同的数字 2。因此，颜色的顺序为 3、8、2。\n\n在样例 #2 中，设 $c_8$ 和 $c_2$ 分别为颜色 8 和 2 的卡片上写的数字。如果 $c_2 > c_8$，那么最右侧的两张卡片上的数字将不是非递减的；如果 $c_2 < c_8$，则左侧第二和第三张卡片会出现同样的问题；而 $c_8 = c_2$ 又违反了规则之一。因此，这种情况下没有有效的解决方案。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i$，$1 \\leq \\mathbf{S}_{i} \\leq 10^{5}$。\n\n**测试集 1（4 分，可见判定）**\n- $1 \\leq \\mathbf{N} \\leq 10$。\n\n**测试集 2（10 分，可见判定）**\n- $1 \\leq \\mathbf{N} \\leq 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12949", "type": "P", "difficulty": 3, "samples": [["2\n5\n31", "Case #1: E\nCase #2: C"]], "limits": {"time": [20000, 20000, 20000], "memory": [2097152, 2097152, 2097152]}, "tags": ["数学", "倍增", "二分", "2023", "Google Code Jam"], "title": "[GCJ Farewell Round #1] ASCII Art", "background": "", "description": "Cody-Jamal has heard about generative artificial intelligence producing art. He is excited about the new art opportunities, but also worried about human-created art being displaced. He thought a good compromise would be to use computers to create art that humans simply cannot.\n\nSince Cody-Jamal is just beginning at computer-generated art, he started simple. He wants to create an immense string that shows the English alphabet in a doubly-repeated way, to represent its ubiquity and permanence.\n\nCody-Jamal wrote the following program:\n\n```python\nfor i = 1 to 1e100:\n    for letter = A to Z:\n        print letter i times\n```\n\nHere $1 \\mathrm{e} 100$ represents the integer $10^{100}$. For example:\n\n* When $i=1$, the program prints $\\mathrm{ABCD} \\ldots . . \\mathrm{XYZ}$.\n* When $i=2$, the program prints $\\mathrm{AABBCC} \\ldots \\mathrm{XXYYZZ}$.\n* When $i=3$, the program prints $\\mathrm{AAABBBCCC} \\ldots \\mathrm{XXXYYYZZZ}$.\n\nOf course, Cody-Jamal's program takes a long time to finish. Can you help him know what the $\\mathbf{N}$-th printed letter will be without waiting for it to be printed?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of a single line with an integer $\\mathbf{N}$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the $\\mathbf{N}$-th character printed by Cody-Jamal's program.", "hint": "**Sample Explanation**\n\nThe first 35 letters printed by Cody-Jamal's program are ABCDEFGHIJKLMNOPQRSTUVWXYZAABBCCDDE… Therefore, the 5th printed character is E and the 31st is C.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\nTest Set 1 (9 Pts, Visible Verdict)\n\n- $1 \\leq \\mathbf{N} \\leq 10^{6}$.\n\nTest Set 2 (20 Pts, Visible Verdict)\n\n- $1 \\leq \\mathbf{N} \\leq 10^{12}$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #1] ASCII Art", "background": "", "description": "Cody-Jamal has heard about generative artificial intelligence producing art. He is excited about the new art opportunities, but also worried about human-created art being displaced. He thought a good compromise would be to use computers to create art that humans simply cannot.\n\nSince Cody-Jamal is just beginning at computer-generated art, he started simple. He wants to create an immense string that shows the English alphabet in a doubly-repeated way, to represent its ubiquity and permanence.\n\nCody-Jamal wrote the following program:\n\n```python\nfor i = 1 to 1e100:\n    for letter = A to Z:\n        print letter i times\n```\n\nHere $1 \\mathrm{e} 100$ represents the integer $10^{100}$. For example:\n\n* When $i=1$, the program prints $\\mathrm{ABCD} \\ldots . . \\mathrm{XYZ}$.\n* When $i=2$, the program prints $\\mathrm{AABBCC} \\ldots \\mathrm{XXYYZZ}$.\n* When $i=3$, the program prints $\\mathrm{AAABBBCCC} \\ldots \\mathrm{XXXYYYZZZ}$.\n\nOf course, Cody-Jamal's program takes a long time to finish. Can you help him know what the $\\mathbf{N}$-th printed letter will be without waiting for it to be printed?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of a single line with an integer $\\mathbf{N}$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the $\\mathbf{N}$-th character printed by Cody-Jamal's program.", "hint": "**Sample Explanation**\n\nThe first 35 letters printed by Cody-Jamal's program are ABCDEFGHIJKLMNOPQRSTUVWXYZAABBCCDDE… Therefore, the 5th printed character is E and the 31st is C.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\nTest Set 1 (9 Pts, Visible Verdict)\n\n- $1 \\leq \\mathbf{N} \\leq 10^{6}$.\n\nTest Set 2 (20 Pts, Visible Verdict)\n\n- $1 \\leq \\mathbf{N} \\leq 10^{12}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #1] ASCII Art", "background": "", "description": "**Cody-Jamal** 听说了生成式人工智能创作艺术的事情。他对这种新的艺术创作方式感到兴奋，但同时也担心人类创作的艺术会被取代。他认为一个很好的折衷方案是利用计算机来创作人类无法完成的艺术作品。\n\n由于 **Cody-Jamal** 刚刚开始接触计算机生成艺术，他决定从简单的开始。他想创建一个巨大的字符串，以双重重复的方式展示英文字母，以表现字母的普遍性和永恒性。\n\n**Cody-Jamal** 编写了以下程序：\n\n```\nfor i = 1 to 1e100:\n    for letter = A to Z:\n        print letter i times\n```\n\n这里 $1 \\mathrm{e} 100$ 表示整数 $10^{100}$。例如：\n\n* 当 $i=1$ 时，程序会输出 $\\mathrm{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$（26 个字母各出现 1 次）\n* 当 $i=2$ 时，程序会输出 $\\mathrm{AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ}$（26 个字母各出现 2 次）\n* 当 $i=3$ 时，程序会输出 $\\mathrm{AAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQRRRSSSTTTUUUVVVWWWXXXYYYZZZ}$（26 个字母各出现 3 次）\n\n显然，**Cody-Jamal** 的这个程序需要运行极其漫长的时间。你能在不实际运行程序的情况下，直接计算出程序输出的第 $\\mathbf{N}$ 个字符是什么吗？", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$（$1 \\leq \\mathbf{T} \\leq 100$）。随后是 $\\mathbf{T}$ 个测试用例，每个测试用例单独占一行，包含一个整数 $\\mathbf{N}$（$1 \\leq \\mathbf{N} \\leq 10^{12}$）。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是程序输出的第 $\\mathbf{N}$ 个字母（大写）。\n", "hint": "程序输出的字符序列开始部分为：\n- $i=1$: A(1), B(2), C(3), D(4), E(5),..., Z(26)\n- $i=2$: A(27-28), B(29-30), C(31-32),..., Z(78)\n- ...\n\n因此：\n- 第 5 个字符是 E\n- 第 31 个字符是 C（位于第二轮的 C 部分）\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$\n\n**测试集 1（9 分，可见判定）**\n- $1 \\leq \\mathbf{N} \\leq 10^{6}$\n\n**测试集 2（20 分，可见判定）**\n- $1 \\leq \\mathbf{N} \\leq 10^{12}$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12950", "type": "P", "difficulty": 3, "samples": [["3\nPRSSP\nRRRRRRR\nRSPRPSPRS", "Case #1: 2\nCase #2: 4\nCase #3: 0"]], "limits": {"time": [10000, 10000, 10000], "memory": [2097152, 2097152, 2097152]}, "tags": ["动态规划 DP", "贪心", "2023", "Google Code Jam"], "title": "[GCJ Farewell Round #1] Untie", "background": "", "description": "A group of people are sitting in a circle, playing a special version of rock, paper, scissors. In this game, each person chooses rock, paper, or scissors in secret and then everyone reveals their choice to everyone else. Each person then compares their selection to their two neighbors, and can win, lose, or tie against each of them independently. The only way to tie is when both people make the same choice.\n\nYou want to make it so that no game is a tie. For each player, you can let them keep their choice, or you can ask them to change to any of the other two options (you choose to which one). What is the minimum number of people you need to request a change from to ensure that there are no ties between neighbors after those changes are made?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line represents a test case and contains a string $\\mathbf{C}$. The $i$-th character of $\\mathbf{C}$ represents the original choice of the $i$-th person in clockwise order using an uppercase $\\mathbf{R}$ to mean rock, an uppercase $\\mathbf{P}$ to mean paper, and an uppercase $\\mathbf{S}$ to mean scissors.\n", "outputFormat": "For each test case, output one line containing Case # $x: y$, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of changes that are required such that no two neighbors end up with the same choice.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is a pair of neighbors that both chose paper (the first and last character of the input) and another pair that both chose scissors. Therefore, we need at least two changes. One way of doing it with two changes is to change the leftmost paper to scissors and the rightmost scissors to rock, to obtain SRSRP.\n\nIn Sample Case #2, all 7 participants chose rock. If we change at most 3 selections, there will be at least 4 remaining rocks, and at least two of them will be neighbors. Therefore, the minimum number of changes is at least 4. One way to achieve exactly 4 is to get PRSRPRS.\n\nIn Sample Case #3, no pair of neighbors tied, so no changes are needed.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{C}$ is either an uppercase $\\mathbf{R}$, an uppercase $\\mathbf{P}$, or an uppercase $\\mathbf{s}$.\n\nTest Set 1 (9 Pts, Visible Verdict)\n\n- $3 \\leq$ the length of $\\mathbf{C} \\leq 10$.\n\nTest Set 2 (20 Pts, Visible Verdict)\n\n- $3 \\leq$ the length of $\\mathbf{C} \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #1] Untie", "background": "", "description": "A group of people are sitting in a circle, playing a special version of rock, paper, scissors. In this game, each person chooses rock, paper, or scissors in secret and then everyone reveals their choice to everyone else. Each person then compares their selection to their two neighbors, and can win, lose, or tie against each of them independently. The only way to tie is when both people make the same choice.\n\nYou want to make it so that no game is a tie. For each player, you can let them keep their choice, or you can ask them to change to any of the other two options (you choose to which one). What is the minimum number of people you need to request a change from to ensure that there are no ties between neighbors after those changes are made?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line represents a test case and contains a string $\\mathbf{C}$. The $i$-th character of $\\mathbf{C}$ represents the original choice of the $i$-th person in clockwise order using an uppercase $\\mathbf{R}$ to mean rock, an uppercase $\\mathbf{P}$ to mean paper, and an uppercase $\\mathbf{S}$ to mean scissors.\n", "outputFormat": "For each test case, output one line containing Case # $x: y$, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of changes that are required such that no two neighbors end up with the same choice.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is a pair of neighbors that both chose paper (the first and last character of the input) and another pair that both chose scissors. Therefore, we need at least two changes. One way of doing it with two changes is to change the leftmost paper to scissors and the rightmost scissors to rock, to obtain SRSRP.\n\nIn Sample Case #2, all 7 participants chose rock. If we change at most 3 selections, there will be at least 4 remaining rocks, and at least two of them will be neighbors. Therefore, the minimum number of changes is at least 4. One way to achieve exactly 4 is to get PRSRPRS.\n\nIn Sample Case #3, no pair of neighbors tied, so no changes are needed.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{C}$ is either an uppercase $\\mathbf{R}$, an uppercase $\\mathbf{P}$, or an uppercase $\\mathbf{s}$.\n\nTest Set 1 (9 Pts, Visible Verdict)\n\n- $3 \\leq$ the length of $\\mathbf{C} \\leq 10$.\n\nTest Set 2 (20 Pts, Visible Verdict)\n\n- $3 \\leq$ the length of $\\mathbf{C} \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #1] Untie", "background": "", "description": "一群人围坐成一圈，正在玩一个特殊版本的石头剪刀布游戏。在这个游戏中，每个人秘密选择石头、布或剪刀，然后所有人同时向其他人展示自己的选择。每个人会将自己的选择与左右两位邻居进行比较，可能分别对每位邻居获胜、落败或平局。只有当两人选择相同时才会出现平局。\n\n你希望调整游戏结果，使得没有任何相邻两人出现平局。对于每位玩家，你可以选择保留其原有选择，或者要求他们更改为另外两个选项中的任意一个（由你决定改为哪个）。为了确保在调整后所有相邻玩家的选择都不相同，最少需要改变多少人的选择？", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 行，每行表示一个测试用例，包含一个字符串 $\\mathbf{C}$。$\\mathbf{C}$ 的第 $i$ 个字符表示顺时针方向第 $i$ 个人的初始选择，其中大写字母 $\\mathbf{R}$ 表示石头，$\\mathbf{P}$ 表示布，$\\mathbf{S}$ 表示剪刀。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是为了确保相邻玩家最终选择不同所需的最少改变次数。\n", "hint": "**样例解释**\n\n在样例 #1 中，存在一对相邻玩家都选择布（输入的首尾字符），以及另一对相邻玩家都选择剪刀。因此至少需要两次改变。其中一种实现方式是：将最左侧的布改为剪刀，最右侧的剪刀改为石头，得到 SRSRP。\n\n在样例 #2 中，所有 7 位参与者都选择了石头。如果最多改变 3 次选择，那么至少会剩下 4 个石头，其中至少有两个是相邻的。因此最少需要改变 4 次。其中一种实现方式是得到 PRSRPRS。\n\n在样例 #3 中，没有任何相邻玩家出现平局，因此不需要改变。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $\\mathbf{C}$ 的每个字符都是大写字母 $\\mathbf{R}$、$\\mathbf{P}$ 或 $\\mathbf{S}$。\n\n**测试集 1（9 分，可见判定）**\n- $3 \\leq \\mathbf{C}$ 的长度 $\\leq 10$。\n\n**测试集 2（20 分，可见判定）**\n- $3 \\leq \\mathbf{C}$ 的长度 $\\leq 1000$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12951", "type": "P", "difficulty": 3, "samples": [["3\n5\n30 50 40 20 10\n1 2 4 5\n5\n20 20 80 10 10\n1 4 2 5\n4\n90 10 10 10\n1 4 1 4", "Case #1: 120\nCase #2: 100\nCase #3: 90"]], "limits": {"time": [30000, 30000, 30000], "memory": [2097152, 2097152, 2097152]}, "tags": ["贪心", "2023", "前缀和", "Google Code Jam"], "title": "[GCJ Farewell Round #2] Collecting Pancakes", "background": "", "description": "Alice and Bob both have a sweet tooth, and they are going to play a game to collect pancakes. There are $\\mathbf{N}$ pancake stacks lined up on the table labeled from 1 to $\\mathbf{N}$. The $i$-th stack has exactly $\\mathbf{A}_{i}$ pancakes. Alice and Bob are going to collect pancakes by alternating turns claiming full stacks. For the first turn, Alice must choose a stack labeled between $\\mathbf{L}_{\\mathrm{a}}$ and $\\mathbf{R}_{\\mathrm{a}}$, inclusive, and claim it. Then, Bob must choose a stack labeled between $\\mathbf{L}_{\\mathrm{b}}$ and $\\mathbf{R}_{\\mathrm{b}}$, inclusive, and different from the one chosen by Alice, and claim it.\n\nIn subsequent turns, each of them must choose an unclaimed stack that is adjacent to a stack they claimed themselves before. That is, for Alice to claim stack $i$ on one of her turns other than the first, she must have claimed either stack $i-1$ or stack $i+1$ in one of her previous turns. The same is true for Bob. If at some point there is no valid choice for either player, they skip that turn and claim no stack.\n\nThe game ends when every stack is claimed. At that point, Alice collects all pancakes from all stacks she claimed, and Bob collects all pancakes in all stacks he claimed.\n\nAlice wants to get as many pancakes as possible for herself, and Bob wants to get as many pancakes as possible for himself. Can you help Alice find out the maximum number of pancakes she can collect if they both play optimally?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of three lines.\n\nThe first line of each test case contains an integer $\\mathbf{N}$, representing the number of pancake stacks.\n\nThe second line contains $\\mathbf{N}$ integers $\\mathbf{A}_{1}, \\mathbf{A}_{2}, \\ldots, \\mathbf{A}_{\\mathbf{N}}$, where $\\mathbf{A}_{i}$ denotes the number of pancakes in stack $i$.\n\nThe third line contains 4 integers $\\mathbf{L}_{\\mathrm{a}}, \\mathbf{R}_{\\mathrm{a}}, \\mathbf{L}_{\\mathrm{b}}$, and $\\mathbf{R}_{\\mathrm{b}}$, the inclusive ranges of pancake stack labels Alice and Bob can choose for their first turn, respectively.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of pancakes Alice can collect after playing the game optimally.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 5 pancake stacks with 30, 50, 40, 20, 10 pancakes in them. Alice can choose the first or second stack at the beginning of the game, and Bob can choose the fourth or fifth stack to begin with. One way in which they both play optimally is:\n\n1. At the beginning, Alice claims stack 2, then Bob claims stack 4.\n2. Alice claims stack 3 in her second turn, then Bob claims stack 5 in his second turn.\n3. Alice claims stack 1 in her third turn, then the game ends because all stacks have been claimed.\n\nAt the end of the game, Alice claimed stacks 1, 2, and 3 and Bob claimed stacks 4 and 5. The number of pancakes Alice collects is $30 + 50 + 40 = 120$.\n\nIn Sample Case #2, one way of optimal play is:\n\n1. At the beginning, Alice claims stack 3, then Bob claims stack 2.\n2. Alice claims stack 4 in her second turn, then Bob claims stack 1 in his second turn.\n3. Alice claims stack 5 in her third turn, then the game ends because all stacks have been claimed.\n\nThe number of pancakes Alice collects is $80 + 10 + 10 = 100$.\n\nIn Sample Case #3, both can claim any stack in their first turn. Since stack 1 is more valuable than everything else combined, Alice claims it before Bob does. Then, Bob can claim stack 2, making Alice have to skip all her subsequent turns. Alice still finishes with 90 pancakes and Bob with just 30.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{A}_{i} \\leq 10^{9}$, for all $i$.\n- $1 \\leq \\mathbf{L}_{\\mathrm{a}} \\leq \\mathbf{R}_{\\mathrm{a}} \\leq \\mathbf{N}$\n- $1 \\leq \\mathbf{L}_{\\mathrm{b}} \\leq \\mathbf{R}_{\\mathrm{b}} \\leq \\mathbf{N}$\n- It is not the case that $\\mathbf{L}_{\\mathrm{a}} \\leq \\mathbf{L}_{\\mathrm{b}}=\\mathbf{R}_{\\mathrm{b}} \\leq \\mathbf{R}_{\\mathrm{a}}$. (Bob is guaranteed to be able to pick a stack for his first turn regardless of Alice's choice.)\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #2] Collecting Pancakes", "background": "", "description": "Alice and Bob both have a sweet tooth, and they are going to play a game to collect pancakes. There are $\\mathbf{N}$ pancake stacks lined up on the table labeled from 1 to $\\mathbf{N}$. The $i$-th stack has exactly $\\mathbf{A}_{i}$ pancakes. Alice and Bob are going to collect pancakes by alternating turns claiming full stacks. For the first turn, Alice must choose a stack labeled between $\\mathbf{L}_{\\mathrm{a}}$ and $\\mathbf{R}_{\\mathrm{a}}$, inclusive, and claim it. Then, Bob must choose a stack labeled between $\\mathbf{L}_{\\mathrm{b}}$ and $\\mathbf{R}_{\\mathrm{b}}$, inclusive, and different from the one chosen by Alice, and claim it.\n\nIn subsequent turns, each of them must choose an unclaimed stack that is adjacent to a stack they claimed themselves before. That is, for Alice to claim stack $i$ on one of her turns other than the first, she must have claimed either stack $i-1$ or stack $i+1$ in one of her previous turns. The same is true for Bob. If at some point there is no valid choice for either player, they skip that turn and claim no stack.\n\nThe game ends when every stack is claimed. At that point, Alice collects all pancakes from all stacks she claimed, and Bob collects all pancakes in all stacks he claimed.\n\nAlice wants to get as many pancakes as possible for herself, and Bob wants to get as many pancakes as possible for himself. Can you help Alice find out the maximum number of pancakes she can collect if they both play optimally?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of three lines.\n\nThe first line of each test case contains an integer $\\mathbf{N}$, representing the number of pancake stacks.\n\nThe second line contains $\\mathbf{N}$ integers $\\mathbf{A}_{1}, \\mathbf{A}_{2}, \\ldots, \\mathbf{A}_{\\mathbf{N}}$, where $\\mathbf{A}_{i}$ denotes the number of pancakes in stack $i$.\n\nThe third line contains 4 integers $\\mathbf{L}_{\\mathrm{a}}, \\mathbf{R}_{\\mathrm{a}}, \\mathbf{L}_{\\mathrm{b}}$, and $\\mathbf{R}_{\\mathrm{b}}$, the inclusive ranges of pancake stack labels Alice and Bob can choose for their first turn, respectively.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of pancakes Alice can collect after playing the game optimally.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 5 pancake stacks with 30, 50, 40, 20, 10 pancakes in them. Alice can choose the first or second stack at the beginning of the game, and Bob can choose the fourth or fifth stack to begin with. One way in which they both play optimally is:\n\n1. At the beginning, Alice claims stack 2, then Bob claims stack 4.\n2. Alice claims stack 3 in her second turn, then Bob claims stack 5 in his second turn.\n3. Alice claims stack 1 in her third turn, then the game ends because all stacks have been claimed.\n\nAt the end of the game, Alice claimed stacks 1, 2, and 3 and Bob claimed stacks 4 and 5. The number of pancakes Alice collects is $30 + 50 + 40 = 120$.\n\nIn Sample Case #2, one way of optimal play is:\n\n1. At the beginning, Alice claims stack 3, then Bob claims stack 2.\n2. Alice claims stack 4 in her second turn, then Bob claims stack 1 in his second turn.\n3. Alice claims stack 5 in her third turn, then the game ends because all stacks have been claimed.\n\nThe number of pancakes Alice collects is $80 + 10 + 10 = 100$.\n\nIn Sample Case #3, both can claim any stack in their first turn. Since stack 1 is more valuable than everything else combined, Alice claims it before Bob does. Then, Bob can claim stack 2, making Alice have to skip all her subsequent turns. Alice still finishes with 90 pancakes and Bob with just 30.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{A}_{i} \\leq 10^{9}$, for all $i$.\n- $1 \\leq \\mathbf{L}_{\\mathrm{a}} \\leq \\mathbf{R}_{\\mathrm{a}} \\leq \\mathbf{N}$\n- $1 \\leq \\mathbf{L}_{\\mathrm{b}} \\leq \\mathbf{R}_{\\mathrm{b}} \\leq \\mathbf{N}$\n- It is not the case that $\\mathbf{L}_{\\mathrm{a}} \\leq \\mathbf{L}_{\\mathrm{b}}=\\mathbf{R}_{\\mathrm{b}} \\leq \\mathbf{R}_{\\mathrm{a}}$. (Bob is guaranteed to be able to pick a stack for his first turn regardless of Alice's choice.)\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #2] Collecting Pancakes", "background": "", "description": "**Alice** 和 **Bob** 都喜欢吃甜食，他们准备玩一个收集煎饼的游戏。桌上有 $\\mathbf{N}$ 叠煎饼排成一列，编号从 1 到 $\\mathbf{N}$。第 $i$ 叠煎饼恰好有 $\\mathbf{A}_{i}$ 个。**Alice** 和 **Bob** 将轮流选择整叠煎饼来收集。第一回合，**Alice** 必须选择一个编号在 $[\\mathbf{L}_{\\mathrm{a}}, \\mathbf{R}_{\\mathrm{a}}]$ 范围内的煎饼叠并收集它。接着，**Bob** 必须选择一个编号在 $[\\mathbf{L}_{\\mathrm{b}}, \\mathbf{R}_{\\mathrm{b}}]$ 范围内且不同于 **Alice** 所选叠的煎饼叠并收集它。\n\n在后续回合中，每个人都必须选择一个未被收集且与之前自己收集过的叠相邻的煎饼叠。也就是说，**Alice** 在非首回合选择第 $i$ 叠时，她必须在此前的某个回合中收集过第 $i-1$ 叠或第 $i+1$ 叠。**Bob** 也遵循同样的规则。如果在某一回合中某位玩家没有合法选择，则该玩家跳过此回合，不收集任何煎饼叠。\n\n游戏在所有煎饼叠都被收集时结束。此时，**Alice** 将获得她收集的所有叠中的煎饼总数，**Bob** 则获得他收集的所有叠中的煎饼总数。\n\n**Alice** 希望自己获得的煎饼尽可能多，而 **Bob** 则希望自己获得的煎饼尽可能多。在双方都采取最优策略的情况下，你能帮 **Alice** 计算出她最多能获得多少煎饼吗？\n", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例，每个测试用例包含三行。\n\n每个测试用例的第一行包含一个整数 $\\mathbf{N}$，表示煎饼叠的数量。\n\n第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{A}_{1}, \\mathbf{A}_{2}, \\ldots, \\mathbf{A}_{\\mathbf{N}}$，其中 $\\mathbf{A}_{i}$ 表示第 $i$ 叠煎饼的数量。\n\n第三行包含 4 个整数 $\\mathbf{L}_{\\mathrm{a}}, \\mathbf{R}_{\\mathrm{a}}, \\mathbf{L}_{\\mathrm{b}}, \\mathbf{R}_{\\mathrm{b}}$，分别表示 **Alice** 和 **Bob** 首回合可选煎饼叠编号的闭区间范围。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 **Alice** 在双方最优策略下能获得的最大煎饼数量。\n", "hint": "**样例解释**\n\n在样例 #1 中，5 叠煎饼的数量分别为 30、50、40、20、10。**Alice** 首回合可选择第 1 或第 2 叠，**Bob** 首回合可选择第 4 或第 5 叠。双方的一种最优策略如下：\n\n1. **Alice** 首回合选择第 2 叠，**Bob** 选择第 4 叠。\n2. **Alice** 第二回合选择第 3 叠，**Bob** 选择第 5 叠。\n3. **Alice** 第三回合选择第 1 叠，游戏结束。\n\n最终 **Alice** 收集了第 1、2、3 叠，获得 $30 + 50 + 40 = 120$ 个煎饼。\n\n在样例 #2 中，一种最优策略为：\n\n1. **Alice** 首回合选择第 3 叠，**Bob** 选择第 2 叠。\n2. **Alice** 第二回合选择第 4 叠，**Bob** 选择第 1 叠。\n3. **Alice** 第三回合选择第 5 叠，游戏结束。\n\n**Alice** 共获得 $80 + 10 + 10 = 100$ 个煎饼。\n\n在样例 #3 中，双方首回合可选择任意叠。由于第 1 叠的价值超过其他叠的总和，**Alice** 会优先选择它。接着 **Bob** 只能选择第 2 叠，导致 **Alice** 后续无法操作。最终 **Alice** 获得 90 个煎饼，**Bob** 仅获得 30 个。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对所有 $i$，$1 \\leq \\mathbf{A}_{i} \\leq 10^{9}$。\n- $1 \\leq \\mathbf{L}_{\\mathrm{a}} \\leq \\mathbf{R}_{\\mathrm{a}} \\leq \\mathbf{N}$。\n- $1 \\leq \\mathbf{L}_{\\mathrm{b}} \\leq \\mathbf{R}_{\\mathrm{b}} \\leq \\mathbf{N}$。\n- 保证不存在 $\\mathbf{L}_{\\mathrm{a}} \\leq \\mathbf{L}_{\\mathrm{b}}=\\mathbf{R}_{\\mathrm{b}} \\leq \\mathbf{R}_{\\mathrm{a}}$ 的情况（即 **Bob** 首回合总能选择合法叠）。\n\n**测试集 1（4 分，可见判定）**\n- $2 \\leq \\mathbf{N} \\leq 100$。\n\n**测试集 2（10 分，可见判定）**\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12952", "type": "P", "difficulty": 4, "samples": [["3\n5 5 4\n1 4 5 5 4\n3 4 2\n3 4 3\n2 4 2\n1 4", "Case #1: 3\nCase #2: 0\nCase #3: IMPOSSIBLE"]], "limits": {"time": [5000, 5000, 5000], "memory": [2097152, 2097152, 2097152]}, "tags": ["数学", "2023", "扩展欧几里德算法", "Google Code Jam"], "title": "[GCJ Farewell Round #2] Intruder Outsmarting", "background": "", "description": "Amiria is a cautious internet user, and as such, she is setting up two-factor authentication for her accounts. She is using a special type of security key as an extra precaution to outsmart any intruders that may want to take it. Amiria's security key requires a code to activate. To enter the code, one must place it on wheels with numbers, similar to code padlocks.\n\nAmiria's security key has a sequence of $\\mathbf{W}$ wheels. Each wheel has the numbers 1 through $\\mathbf{N}$ printed in order. By one wheel rotation, the user can move the currently shown integer either to the next or the previous integer. Numbers on the wheel wrap around. This means the number after $\\mathbf{N}$ is 1 and the number before 1 is $\\mathbf{N}$.\n\nThere is no hidden password. To activate Amiria's security key, a person needs to move the wheels such that the sequence of numbers shown is palindromic. That is, the sequence of numbers is the same when read from left to right and from right to left. To slow down intruders, Amiria rigged the security key such that the wheels only rotate in increments of $\\mathbf{D}$. That is, on a move, a wheel that is currently showing $x$ can be made to show $x - \\mathbf{D}$ or $x + \\mathbf{D}$, applying the proper wraparound. That is, if $x - \\mathbf{D} < 1$ the actual number shown after the operation is $x - \\mathbf{D} + \\mathbf{N}$, and if $x + \\mathbf{D} > \\mathbf{N}$ the actual number shown is $x + \\mathbf{D} - \\mathbf{N}$.\n\nAmiria wants to check how much this system would slow down an intruder trying to use her security key. Given the number of wheels and the number currently shown on each wheel, find the minimum number of operations needed to make the sequence of shown numbers palindromic, or report that it is impossible to do so.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains 3 integers $\\mathbf{W}$, $\\mathbf{N}$, and $\\mathbf{D}$: the number of wheels in Amiria's security key, the number of integers shown in each of those wheels, and the fixed increment that Amiria rigged for every wheel. The second line of a test case contains $\\mathbf{W}$ integers $\\mathbf{X}_{1}, \\mathbf{X}_{2}, \\ldots, \\mathbf{X}_{\\mathbf{W}}$, where $\\mathbf{X}_{i}$ is the number currently shown in the $i$-th wheel from left to right.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of operations needed to make the sequence of shown numbers palindromic. If there is no way to make the sequence of shown numbers palindromic through the allowed operations, $y$ must be IMPOSSIBLE instead.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the sequence can be made $5 \\ 4 \\ 5 \\ 4 \\ 5$, which is palindromic, with 3 operations by using one addition operation on the first and fourth wheels, and one subtraction operation on the fifth wheel. There is no way to make the sequence palindromic with fewer moves.\n\nIn Sample Case #2 the sequence is already palindromic, so we do not need any operations.\n\nIn Sample Case #3, both numbers would need to be equal for the sequence to be palindromic. Since wheel values can only move by 2 and both current numbers have different parity, that cannot be done.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D} \\leq \\mathbf{N}-1$.\n- $1 \\leq \\mathbf{X}_{\\mathbf{i}} \\leq \\mathbf{N}$, for all $i$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{W} \\leq 5$.\n- $2 \\leq \\mathbf{N} \\leq 5$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{W} \\leq 1000$.\n- $2 \\leq \\mathbf{N} \\leq 10^{9}$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #2] Intruder Outsmarting", "background": "", "description": "Amiria is a cautious internet user, and as such, she is setting up two-factor authentication for her accounts. She is using a special type of security key as an extra precaution to outsmart any intruders that may want to take it. Amiria's security key requires a code to activate. To enter the code, one must place it on wheels with numbers, similar to code padlocks.\n\nAmiria's security key has a sequence of $\\mathbf{W}$ wheels. Each wheel has the numbers 1 through $\\mathbf{N}$ printed in order. By one wheel rotation, the user can move the currently shown integer either to the next or the previous integer. Numbers on the wheel wrap around. This means the number after $\\mathbf{N}$ is 1 and the number before 1 is $\\mathbf{N}$.\n\nThere is no hidden password. To activate Amiria's security key, a person needs to move the wheels such that the sequence of numbers shown is palindromic. That is, the sequence of numbers is the same when read from left to right and from right to left. To slow down intruders, Amiria rigged the security key such that the wheels only rotate in increments of $\\mathbf{D}$. That is, on a move, a wheel that is currently showing $x$ can be made to show $x - \\mathbf{D}$ or $x + \\mathbf{D}$, applying the proper wraparound. That is, if $x - \\mathbf{D} < 1$ the actual number shown after the operation is $x - \\mathbf{D} + \\mathbf{N}$, and if $x + \\mathbf{D} > \\mathbf{N}$ the actual number shown is $x + \\mathbf{D} - \\mathbf{N}$.\n\nAmiria wants to check how much this system would slow down an intruder trying to use her security key. Given the number of wheels and the number currently shown on each wheel, find the minimum number of operations needed to make the sequence of shown numbers palindromic, or report that it is impossible to do so.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains 3 integers $\\mathbf{W}$, $\\mathbf{N}$, and $\\mathbf{D}$: the number of wheels in Amiria's security key, the number of integers shown in each of those wheels, and the fixed increment that Amiria rigged for every wheel. The second line of a test case contains $\\mathbf{W}$ integers $\\mathbf{X}_{1}, \\mathbf{X}_{2}, \\ldots, \\mathbf{X}_{\\mathbf{W}}$, where $\\mathbf{X}_{i}$ is the number currently shown in the $i$-th wheel from left to right.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of operations needed to make the sequence of shown numbers palindromic. If there is no way to make the sequence of shown numbers palindromic through the allowed operations, $y$ must be IMPOSSIBLE instead.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the sequence can be made $5 \\ 4 \\ 5 \\ 4 \\ 5$, which is palindromic, with 3 operations by using one addition operation on the first and fourth wheels, and one subtraction operation on the fifth wheel. There is no way to make the sequence palindromic with fewer moves.\n\nIn Sample Case #2 the sequence is already palindromic, so we do not need any operations.\n\nIn Sample Case #3, both numbers would need to be equal for the sequence to be palindromic. Since wheel values can only move by 2 and both current numbers have different parity, that cannot be done.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D} \\leq \\mathbf{N}-1$.\n- $1 \\leq \\mathbf{X}_{\\mathbf{i}} \\leq \\mathbf{N}$, for all $i$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{W} \\leq 5$.\n- $2 \\leq \\mathbf{N} \\leq 5$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{W} \\leq 1000$.\n- $2 \\leq \\mathbf{N} \\leq 10^{9}$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #2] Intruder Outsmarting", "background": "", "description": "**Amiria** 是一个谨慎的互联网用户，因此她正在为账户设置双重认证。她使用一种特殊的安全密钥作为额外防护，以智胜那些可能想要窃取它的入侵者。**Amiria** 的安全密钥需要一个激活码。要输入这个激活码，必须将其放置在带有数字的转轮上，类似于密码挂锁。\n\n**Amiria** 的安全密钥由 $\\mathbf{W}$ 个转轮组成。每个转轮上按顺序印有数字 1 到 $\\mathbf{N}$。通过一次转轮旋转，用户可以将当前显示的数字移动到下一个或上一个数字。转轮上的数字是循环的，这意味着 $\\mathbf{N}$ 的下一个数字是 1，而 1 的前一个数字是 $\\mathbf{N}$。\n\n这里没有隐藏密码。要激活 **Amiria** 的安全密钥，需要调整转轮，使得显示的数字序列是回文的。也就是说，数字序列从左到右和从右到左读起来是一样的。为了减慢入侵者的速度，**Amiria** 对安全密钥进行了设置，使得转轮只能以 $\\mathbf{D}$ 的增量旋转。也就是说，在一次操作中，当前显示数字 $x$ 的转轮可以调整为显示 $x - \\mathbf{D}$ 或 $x + \\mathbf{D}$，并应用适当的循环调整。具体来说，如果 $x - \\mathbf{D} < 1$，则操作后实际显示的数字是 $x - \\mathbf{D} + \\mathbf{N}$；如果 $x + \\mathbf{D} > \\mathbf{N}$，则实际显示的数字是 $x + \\mathbf{D} - \\mathbf{N}$。\n\n**Amiria** 想检查这个系统会如何减慢试图使用她安全密钥的入侵者。给定转轮的数量和每个转轮当前显示的数字，找到使显示的数字序列成为回文所需的最少操作次数，或者报告这是不可能的。\n", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含两行。测试用例的第一行包含 3 个整数 $\\mathbf{W}$、$\\mathbf{N}$ 和 $\\mathbf{D}$：分别表示 **Amiria** 安全密钥中的转轮数量、每个转轮上显示的数字数量，以及 **Amiria** 设置的固定增量。测试用例的第二行包含 $\\mathbf{W}$ 个整数 $\\mathbf{X}_{1}, \\mathbf{X}_{2}, \\ldots, \\mathbf{X}_{\\mathbf{W}}$，其中 $\\mathbf{X}_{i}$ 是从左到右第 $i$ 个转轮当前显示的数字。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是使显示的数字序列成为回文所需的最少操作次数。如果无法通过允许的操作使数字序列成为回文，则 $y$ 应为 `IMPOSSIBLE`。\n", "hint": "**样例解释**\n\n在样例 #1 中，可以通过 3 次操作将序列调整为 $5 \\ 4 \\ 5 \\ 4 \\ 5$，这是一个回文序列。具体操作为：对第一个和第四个转轮进行一次加法操作，对第五个转轮进行一次减法操作。无法用更少的操作使序列成为回文。\n\n在样例 #2 中，序列已经是回文的，因此不需要任何操作。\n\n在样例 #3 中，要使序列成为回文，两个数字必须相同。由于转轮只能以 2 的增量移动，而当前两个数字的奇偶性不同，因此无法实现。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{D} \\leq \\mathbf{N}-1$。\n- 对所有 $i$，$1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{N}$。\n\n**测试集 1（4 分，可见判定）**\n- $2 \\leq \\mathbf{W} \\leq 5$。\n- $2 \\leq \\mathbf{N} \\leq 5$。\n\n**测试集 2（10 分，可见判定）**\n- $2 \\leq \\mathbf{W} \\leq 1000$。\n- $2 \\leq \\mathbf{N} \\leq 10^{9}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12953", "type": "P", "difficulty": 3, "samples": [["2\n3 2\n1 2 3\n6 4\n2 7 11 19 5 3", "Case #1: 2 1 2\nCase #2: 4 4 4 4 3 4"]], "limits": {"time": [20000, 20000, 20000], "memory": [2097152, 2097152, 2097152]}, "tags": ["递推", "二分", "2023", "Google Code Jam"], "title": "[GCJ Farewell Round #2] Spacious Sets", "background": "", "description": "Ada and John are best friends. Since they are getting bored, Ada asks John to solve a puzzle for her.\n\nA set $S$ is considered *spacious* if the absolute difference between each pair of distinct elements of $S$ is at least $\\mathbf{K}$, that is, $|x - y| \\geq \\mathbf{K}$ for all $x, y \\in S$, with $x \\neq y$.\n\nAda has a list of distinct integers $\\mathbf{A}$ of size $\\mathbf{N}$, and an integer $\\mathbf{K}$. For each $\\mathbf{A}_i$, she asks John to find the maximum size of a set $S_i$ made of elements from $\\mathbf{A}$, such that $S_i$ contains $\\mathbf{A}_i$ and is spacious.\n\nNote: The sets $S_i$ do not need to be made of consecutive elements from the list.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of each test case contains two integers $\\mathbf{N}$ and $\\mathbf{K}$. The next line contains $\\mathbf{N}$ integers $\\mathbf{A}_1 \\mathbf{A}_2 \\ldots \\mathbf{A}_{\\mathbf{N}}$.\n", "outputFormat": "For each test case, output one line containing Case # $x$: $y_1 \\ y_2 \\ldots \\ y_{\\mathbf{N}}$, where $x$ is the test case number (starting from 1) and $y_i$ is the maximum size of a spacious set of elements from $\\mathbf{A}$ that contains $\\mathbf{A}_i$.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, a spacious set cannot contain $1$ and $2$, nor it can contain $2$ and $3$. That implies that $S_2 = \\{2\\}$ and using $S_1 = S_3 = \\{1, 3\\}$ makes them of maximum size.\n\nIn Sample Case #2, possible sets of maximum size are:\n\n* $S_1 = S_2 = S_3 = S_4 = \\{2, 7, 11, 19\\}$,\n* $S_5 = \\{11, 19, 5\\}$, and\n* $S_6 = \\{7, 11, 19, 3\\}$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $-10^9 \\leq \\mathbf{A}_i \\leq 10^9$, for all $i$.\n- $\\mathbf{A}_i \\neq \\mathbf{A}_j$, for all $i \\neq j$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10$.\n- $1 \\leq \\mathbf{K} \\leq 100$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{K} \\leq 10^9$.\n\nFor at most 15 cases:\n\n- $1 \\leq \\mathbf{N} \\leq 10^5$.\n\nFor the remaining cases:\n\n- $1 \\leq \\mathbf{N} \\leq 10^3$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #2] Spacious Sets", "background": "", "description": "Ada and John are best friends. Since they are getting bored, Ada asks John to solve a puzzle for her.\n\nA set $S$ is considered *spacious* if the absolute difference between each pair of distinct elements of $S$ is at least $\\mathbf{K}$, that is, $|x - y| \\geq \\mathbf{K}$ for all $x, y \\in S$, with $x \\neq y$.\n\nAda has a list of distinct integers $\\mathbf{A}$ of size $\\mathbf{N}$, and an integer $\\mathbf{K}$. For each $\\mathbf{A}_i$, she asks John to find the maximum size of a set $S_i$ made of elements from $\\mathbf{A}$, such that $S_i$ contains $\\mathbf{A}_i$ and is spacious.\n\nNote: The sets $S_i$ do not need to be made of consecutive elements from the list.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of each test case contains two integers $\\mathbf{N}$ and $\\mathbf{K}$. The next line contains $\\mathbf{N}$ integers $\\mathbf{A}_1 \\mathbf{A}_2 \\ldots \\mathbf{A}_{\\mathbf{N}}$.\n", "outputFormat": "For each test case, output one line containing Case # $x$: $y_1 \\ y_2 \\ldots \\ y_{\\mathbf{N}}$, where $x$ is the test case number (starting from 1) and $y_i$ is the maximum size of a spacious set of elements from $\\mathbf{A}$ that contains $\\mathbf{A}_i$.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, a spacious set cannot contain $1$ and $2$, nor it can contain $2$ and $3$. That implies that $S_2 = \\{2\\}$ and using $S_1 = S_3 = \\{1, 3\\}$ makes them of maximum size.\n\nIn Sample Case #2, possible sets of maximum size are:\n\n* $S_1 = S_2 = S_3 = S_4 = \\{2, 7, 11, 19\\}$,\n* $S_5 = \\{11, 19, 5\\}$, and\n* $S_6 = \\{7, 11, 19, 3\\}$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $-10^9 \\leq \\mathbf{A}_i \\leq 10^9$, for all $i$.\n- $\\mathbf{A}_i \\neq \\mathbf{A}_j$, for all $i \\neq j$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10$.\n- $1 \\leq \\mathbf{K} \\leq 100$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{K} \\leq 10^9$.\n\nFor at most 15 cases:\n\n- $1 \\leq \\mathbf{N} \\leq 10^5$.\n\nFor the remaining cases:\n\n- $1 \\leq \\mathbf{N} \\leq 10^3$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #2] Spacious Sets", "background": "", "description": "**Ada** 和 **John** 是最好的朋友。由于他们感到无聊，**Ada** 让 **John** 为她解决一个谜题。\n\n一个集合 $S$ 被称为 **宽松的**，如果其中任意两个不同元素的绝对差至少为 $\\mathbf{K}$，即对于所有 $x, y \\in S$ 且 $x \\neq y$，都有 $|x - y| \\geq \\mathbf{K}$。\n\n**Ada** 有一个包含 $\\mathbf{N}$ 个不同整数的列表 $\\mathbf{A}$ 和一个整数 $\\mathbf{K}$。对于每个 $\\mathbf{A}_i$，她要求 **John** 找出由 $\\mathbf{A}$ 中元素构成的最大尺寸的集合 $S_i$，使得 $S_i$ 包含 $\\mathbf{A}_i$ 并且是宽松的。\n\n注意：集合 $S_i$ 不需要由列表中连续的元素构成。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{K}$。第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{A}_1 \\mathbf{A}_2 \\ldots \\mathbf{A}_{\\mathbf{N}}$。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y_1 y_2 ... y_N`，其中 $x$ 是测试用例编号（从 1 开始），$y_i$ 是包含 $\\mathbf{A}_i$ 的最大宽松集合的尺寸。", "hint": "**样例解释**\n\n在样例 #1 中，一个宽松集合不能同时包含 1 和 2，也不能同时包含 2 和 3。这意味着 $S_2 = \\{2\\}$，而使用 $S_1 = S_3 = \\{1, 3\\}$ 可以使它们的尺寸最大化。\n\n在样例 #2 中，可能的尺寸最大集合为：\n\n* $S_1 = S_2 = S_3 = S_4 = \\{2, 7, 11, 19\\}$，\n* $S_5 = \\{11, 19, 5\\}$，\n* $S_6 = \\{7, 11, 19, 3\\}$。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对所有 $i$，$-10^9 \\leq \\mathbf{A}_i \\leq 10^9$。\n- 对所有 $i \\neq j$，$\\mathbf{A}_i \\neq \\mathbf{A}_j$。\n\n**测试集 1（4 分，可见判定）**\n- $1 \\leq \\mathbf{N} \\leq 10$。\n- $1 \\leq \\mathbf{K} \\leq 100$。\n\n**测试集 2（10 分，可见判定）**\n- $1 \\leq \\mathbf{K} \\leq 10^9$。\n\n对于最多 15 个测试用例：\n- $1 \\leq \\mathbf{N} \\leq 10^5$。\n\n对于其余测试用例：\n- $1 \\leq \\mathbf{N} \\leq 10^3$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12954", "type": "P", "difficulty": 5, "samples": [["4\n4 3\n3\n1 2 3\n2\n1 4\n3\n4 1 3\n4 4\n2\n1 2\n2\n3 4\n2\n3 2\n2\n4 1\n4 3\n2\n1 2\n2\n3 4\n2\n3 2\n4 3\n2\n1 2\n2\n3 4\n4\n4 1 2 3", "Case #1: 1\nCase #2: 0\nCase #3: 3\nCase #4: 1"]], "limits": {"time": [40000, 40000, 40000], "memory": [2097152, 2097152, 2097152]}, "tags": ["2023", "图论建模", "Tarjan", "双连通分量", "Google Code Jam"], "title": "[GCJ Farewell Round #2] Railroad Maintenance", "background": "", "description": "You are in charge of the maintenance of a railroad network. The network consists of $\\mathbf{N}$ stations and $\\mathbf{L}$ train lines. Each train line serves a fixed list of stations bidirectionally (trains turn around in the first and last stations of the list). Transfers from one line to another in a station are possible, which means a trip in the network from station $a$ to station $b$ is possible if there is a list of train lines such that the first one serves station $a$, the last one serves station $b$, and for any consecutive pair of train lines in the list there is at least one station that they both serve.\n\nThe easiest way to do maintenance is to shut down entire lines, one at a time. However, some train lines may be essential. A train line is essential if removing it would make at least one trip between a pair of stations not possible.\n\nGiven the list of existing train lines, calculate how many of them are essential.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{N}$ and $\\mathbf{L}$: the number of stations and train lines in the network. Then, $\\mathbf{L}$ groups of 2 lines follow. The first line of the $i$-th group contains a single integer $\\mathbf{K}_i$ the number of stations served by the $i$-th train line. The second line of the $i$-th group contains $\\mathbf{K}_i$ integers $\\mathbf{S}_{i,1}, \\mathbf{S}_{i,2}, \\ldots, \\mathbf{S}_{i,\\mathbf{K}_i}$ representing the stations served by the $i$-th train line.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of train lines that are essential.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the first train line is essential because it is the only one serving station $2$. Since shutting any other line down would not make travel between at least one pair of stations impossible, they are not essential.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hstw804z.png)\n\nIn Sample Case #2, no line is essential.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iodjuwf1.png)\n\nSample Case #3 is similar to Sample Case #2, but missing the last train line. That makes all remaining train lines essential.\n\nIn Sample Case #4, the last train line is essential as there is no way to go from station $1$ to station $4$ without it. As in Sample Case #1, since this train line already connects every station, no other line is essential.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xcha3btp.png)\n\n**Sample Explanation**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{K}_i \\leq \\mathbf{N}$ for all $i$.\n- $1 \\leq \\mathbf{S}_{i,j} \\leq \\mathbf{N}$, for all $i, j$.\n- $\\mathbf{S}_{i,j} \\neq \\mathbf{S}_{i,j'}$, for all $i, j, j'$ such that $j \\neq j'$ (Each train line serves a station at most once).\n\nThe trip between all pairs of stations is possible as per the definition above when no train line is shut down.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.\n- $1 \\leq \\mathbf{L} \\leq 100$.\n- $\\mathbf{K}_1 + \\mathbf{K}_2 + \\cdots + \\mathbf{K}_\\mathbf{L} \\leq 200$.\n\n**Test Set 2 (20 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10^5$.\n- $1 \\leq \\mathbf{L} \\leq 10^5$.\n- $\\mathbf{K}_1 + \\mathbf{K}_2 + \\cdots + \\mathbf{K}_\\mathbf{L} \\leq 2 \\times 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #2] Railroad Maintenance", "background": "", "description": "You are in charge of the maintenance of a railroad network. The network consists of $\\mathbf{N}$ stations and $\\mathbf{L}$ train lines. Each train line serves a fixed list of stations bidirectionally (trains turn around in the first and last stations of the list). Transfers from one line to another in a station are possible, which means a trip in the network from station $a$ to station $b$ is possible if there is a list of train lines such that the first one serves station $a$, the last one serves station $b$, and for any consecutive pair of train lines in the list there is at least one station that they both serve.\n\nThe easiest way to do maintenance is to shut down entire lines, one at a time. However, some train lines may be essential. A train line is essential if removing it would make at least one trip between a pair of stations not possible.\n\nGiven the list of existing train lines, calculate how many of them are essential.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{N}$ and $\\mathbf{L}$: the number of stations and train lines in the network. Then, $\\mathbf{L}$ groups of 2 lines follow. The first line of the $i$-th group contains a single integer $\\mathbf{K}_i$ the number of stations served by the $i$-th train line. The second line of the $i$-th group contains $\\mathbf{K}_i$ integers $\\mathbf{S}_{i,1}, \\mathbf{S}_{i,2}, \\ldots, \\mathbf{S}_{i,\\mathbf{K}_i}$ representing the stations served by the $i$-th train line.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of train lines that are essential.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the first train line is essential because it is the only one serving station $2$. Since shutting any other line down would not make travel between at least one pair of stations impossible, they are not essential.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hstw804z.png)\n\nIn Sample Case #2, no line is essential.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iodjuwf1.png)\n\nSample Case #3 is similar to Sample Case #2, but missing the last train line. That makes all remaining train lines essential.\n\nIn Sample Case #4, the last train line is essential as there is no way to go from station $1$ to station $4$ without it. As in Sample Case #1, since this train line already connects every station, no other line is essential.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xcha3btp.png)\n\n**Sample Explanation**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{K}_i \\leq \\mathbf{N}$ for all $i$.\n- $1 \\leq \\mathbf{S}_{i,j} \\leq \\mathbf{N}$, for all $i, j$.\n- $\\mathbf{S}_{i,j} \\neq \\mathbf{S}_{i,j'}$, for all $i, j, j'$ such that $j \\neq j'$ (Each train line serves a station at most once).\n\nThe trip between all pairs of stations is possible as per the definition above when no train line is shut down.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.\n- $1 \\leq \\mathbf{L} \\leq 100$.\n- $\\mathbf{K}_1 + \\mathbf{K}_2 + \\cdots + \\mathbf{K}_\\mathbf{L} \\leq 200$.\n\n**Test Set 2 (20 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10^5$.\n- $1 \\leq \\mathbf{L} \\leq 10^5$.\n- $\\mathbf{K}_1 + \\mathbf{K}_2 + \\cdots + \\mathbf{K}_\\mathbf{L} \\leq 2 \\times 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #2] Railroad Maintenance", "background": "", "description": "你负责一个铁路网络的维护工作。该网络由 $\\mathbf{N}$ 个车站和 $\\mathbf{L}$ 条铁路线组成。每条铁路线双向服务于一个固定的车站列表（列车在列表的第一个和最后一个车站调头）。在一个车站可以从一条线路换乘到另一条线路，这意味着从车站 $a$ 到车站 $b$ 的行程是可行的，如果存在一个铁路线列表，其中第一条线路服务于车站 $a$，最后一条线路服务于车站 $b$，并且对于列表中任意两条相邻的铁路线，至少存在一个车站同时被这两条线路服务。\n\n最简单的维护方式是每次关闭整条铁路线。然而，有些铁路线可能是**关键线路**。一条铁路线是关键线路，如果移除它后会导致至少一对车站之间的行程变得不可能。\n\n给定现有的铁路线列表，计算其中有多少条是关键线路。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例以一行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{L}$ 开始：分别表示网络中的车站数量和铁路线数量。接着是 $\\mathbf{L}$ 组数据，每组包含 2 行。第 $i$ 组的第一行包含一个整数 $\\mathbf{K}_i$，表示第 $i$ 条铁路线服务的车站数量。第 $i$ 组的第二行包含 $\\mathbf{K}_i$ 个整数 $\\mathbf{S}_{i,1}, \\mathbf{S}_{i,2}, \\ldots, \\mathbf{S}_{i,\\mathbf{K}_i}$，表示第 $i$ 条铁路线服务的车站。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是关键铁路线的数量。\n", "hint": "**样例解释**\n\n在样例 #1 中，第一条铁路线是关键线路，因为它是唯一服务于车站 $2$ 的线路。由于关闭其他任何线路都不会导致至少一对车站之间的行程变得不可能，因此它们不是关键线路。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hstw804z.png)\n\n在样例 #2 中，没有关键线路。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iodjuwf1.png)\n\n样例 #3 与样例 #2 类似，但缺少最后一条铁路线。这使得剩余的所有铁路线都成为关键线路。\n\n在样例 #4 中，最后一条铁路线是关键线路，因为没有它就无法从车站 $1$ 到达车站 $4$。与样例 #1 类似，由于这条铁路线已经连接了所有车站，其他线路都不是关键线路。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xcha3btp.png)\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对所有 $i$，$2 \\leq \\mathbf{K}_i \\leq \\mathbf{N}$。\n- 对所有 $i, j$，$1 \\leq \\mathbf{S}_{i,j} \\leq \\mathbf{N}$。\n- 对所有 $i, j, j'$ 且 $j \\neq j'$，$\\mathbf{S}_{i,j} \\neq \\mathbf{S}_{i,j'}$（每条铁路线中每个车站最多出现一次）。\n\n根据上述定义，当没有铁路线被关闭时，所有车站对之间的行程都是可行的。\n\n**测试集 1（9 分，可见判定）**\n- $2 \\leq \\mathbf{N} \\leq 100$。\n- $1 \\leq \\mathbf{L} \\leq 100$。\n- $\\mathbf{K}_1 + \\mathbf{K}_2 + \\cdots + \\mathbf{K}_\\mathbf{L} \\leq 200$。\n\n**测试集 2（20 分，可见判定）**\n- $2 \\leq \\mathbf{N} \\leq 10^5$。\n- $1 \\leq \\mathbf{L} \\leq 10^5$。\n- $\\mathbf{K}_1 + \\mathbf{K}_2 + \\cdots + \\mathbf{K}_\\mathbf{L} \\leq 2 \\times 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12955", "type": "P", "difficulty": 5, "samples": [["3\n4\n2 3 4 3\n4 3 2 1\n4\n2 3 4 1\n1 3 1 3\n7\n3 5 2 5 3 7 6\n3 4 6 3 5 1 2", "Case #1: 4\nCase #2: 5\nCase #3: 10"]], "limits": {"time": [40000, 40000, 40000], "memory": [2097152, 2097152, 2097152]}, "tags": ["2023", "Google Code Jam"], "title": "[GCJ Farewell Round #2] Railroad Management", "background": "", "description": "You are in charge of the management of a railroad network. The network consists of $\\mathbf{N}$ stations. Each station $i$ needs to ship goods to exactly one other station $\\mathbf{D}_i$. Station $i$ will send exactly one shipment, in a train with exactly $\\mathbf{C}_i$ railroad cars.\n\nYou get all the shipment information well in advance, so you plan on saving on railroad cars by reusing them. If station $i$ sends $n$ railroad cars to station $\\mathbf{D}_i$, then $\\mathbf{D}_i$ can add those railroad cars to its supply to use for its own shipment if it did not already happen.\n\nFormally, you must give an initial supply of railroad cars to each station (some stations may get 0) and provide an order for the shipments so that, by the time station $i$ must ship, the number of railroad cars between its initial supply and any previous shipments that arrived at $i$ must be at least the number it needs for its own shipment $\\mathbf{C}_i$. You cannot send more than $\\mathbf{C}_i$ cars in a shipment out of station $i$, even if the station has more than $\\mathbf{C}_i$ available.\n\nFor example, suppose that station 1 sends a train carrying exactly 3 railroad cars to station 4. Now, if station 4 needs 2 cars, it could reuse 2 of the cars it received from station 1. And if station 4 needs to send 5 cars, it can reuse all 3 cars received from station 1 and add 2 of its own supply. Note that when station 4 needs to send 2 cars, it cannot send all 3 it received from station 1.\n\nGiven the shipment information, what is the minimum number of railroad cars you need to distribute for the stations' initial supplies, such that you can do all shipments in some order?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 3 lines. The first line contains a single integer $\\mathbf{N}$, the number of stations in the network. The second line contains $\\mathbf{N}$ integers $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{N}$ and the third and last line contains $\\mathbf{N}$ integers $\\mathbf{C}_1, \\mathbf{C}_2, \\ldots, \\mathbf{C}_\\mathbf{N}$. These represent that station $i$ must send a train of exactly $\\mathbf{C}_i$ railroad cars to station $\\mathbf{D}_i$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of railroad cars you need to distribute among the stations so that all shipments can be performed.", "hint": "**Sample Explanation**\n\nIn Sample Case #1 one optimal way is to do the shipments in increasing order of departure station. That requires sending 4 cars to station 1. But after that, each station receives enough cars for its shipment, for a total of 4 overall. Since no cars arrive at station 1, it definitely needs the initial 4, so this is also the minimum possible.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rzy2faew.png)\n\nIn Sample Case #2 one minimal way is to supply 1 car to station 3 and 2 cars each to stations and 2 and 4, for a total of 5. Then, we can start with the shipment $3 \\rightarrow 4$ which gets one additional car to station 4. This makes station 4 have the 3 cars it needs to ship $4 \\rightarrow 1$. Station 1 now has 3 cars which is enough to do $1 \\rightarrow 2$ with a single car, taking the total at station 2 to 3 cars, enough to do the final shipment $2 \\rightarrow 3$. Notice that the shipment $1 \\rightarrow 2$ cannot bring extra cars to station 2, even though there are cars available and it would be helpful to do so. There are other ways to do all shipments with 5 initial cars, but no way to do it with less.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ax0frede.png)\n\nIn Sample Case #3, one optimal starting number of cars is 3 cars at stations 1 and 4 and 2 cars at stations 5 and 7.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D}_{\\mathbf{i}} \\leq \\mathbf{N}$, for all $i$.\n- $\\mathbf{D}_{\\mathbf{i}} \\neq i$, for all $i$.\n- $1 \\leq \\mathbf{C}_{\\mathbf{i}} \\leq 10^{9}$, for all $i$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 8$.\n\n**Test Set 2 (20 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #2] Railroad Management", "background": "", "description": "You are in charge of the management of a railroad network. The network consists of $\\mathbf{N}$ stations. Each station $i$ needs to ship goods to exactly one other station $\\mathbf{D}_i$. Station $i$ will send exactly one shipment, in a train with exactly $\\mathbf{C}_i$ railroad cars.\n\nYou get all the shipment information well in advance, so you plan on saving on railroad cars by reusing them. If station $i$ sends $n$ railroad cars to station $\\mathbf{D}_i$, then $\\mathbf{D}_i$ can add those railroad cars to its supply to use for its own shipment if it did not already happen.\n\nFormally, you must give an initial supply of railroad cars to each station (some stations may get 0) and provide an order for the shipments so that, by the time station $i$ must ship, the number of railroad cars between its initial supply and any previous shipments that arrived at $i$ must be at least the number it needs for its own shipment $\\mathbf{C}_i$. You cannot send more than $\\mathbf{C}_i$ cars in a shipment out of station $i$, even if the station has more than $\\mathbf{C}_i$ available.\n\nFor example, suppose that station 1 sends a train carrying exactly 3 railroad cars to station 4. Now, if station 4 needs 2 cars, it could reuse 2 of the cars it received from station 1. And if station 4 needs to send 5 cars, it can reuse all 3 cars received from station 1 and add 2 of its own supply. Note that when station 4 needs to send 2 cars, it cannot send all 3 it received from station 1.\n\nGiven the shipment information, what is the minimum number of railroad cars you need to distribute for the stations' initial supplies, such that you can do all shipments in some order?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 3 lines. The first line contains a single integer $\\mathbf{N}$, the number of stations in the network. The second line contains $\\mathbf{N}$ integers $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{N}$ and the third and last line contains $\\mathbf{N}$ integers $\\mathbf{C}_1, \\mathbf{C}_2, \\ldots, \\mathbf{C}_\\mathbf{N}$. These represent that station $i$ must send a train of exactly $\\mathbf{C}_i$ railroad cars to station $\\mathbf{D}_i$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of railroad cars you need to distribute among the stations so that all shipments can be performed.", "hint": "**Sample Explanation**\n\nIn Sample Case #1 one optimal way is to do the shipments in increasing order of departure station. That requires sending 4 cars to station 1. But after that, each station receives enough cars for its shipment, for a total of 4 overall. Since no cars arrive at station 1, it definitely needs the initial 4, so this is also the minimum possible.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rzy2faew.png)\n\nIn Sample Case #2 one minimal way is to supply 1 car to station 3 and 2 cars each to stations and 2 and 4, for a total of 5. Then, we can start with the shipment $3 \\rightarrow 4$ which gets one additional car to station 4. This makes station 4 have the 3 cars it needs to ship $4 \\rightarrow 1$. Station 1 now has 3 cars which is enough to do $1 \\rightarrow 2$ with a single car, taking the total at station 2 to 3 cars, enough to do the final shipment $2 \\rightarrow 3$. Notice that the shipment $1 \\rightarrow 2$ cannot bring extra cars to station 2, even though there are cars available and it would be helpful to do so. There are other ways to do all shipments with 5 initial cars, but no way to do it with less.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ax0frede.png)\n\nIn Sample Case #3, one optimal starting number of cars is 3 cars at stations 1 and 4 and 2 cars at stations 5 and 7.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D}_{\\mathbf{i}} \\leq \\mathbf{N}$, for all $i$.\n- $\\mathbf{D}_{\\mathbf{i}} \\neq i$, for all $i$.\n- $1 \\leq \\mathbf{C}_{\\mathbf{i}} \\leq 10^{9}$, for all $i$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 8$.\n\n**Test Set 2 (20 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #2] Railroad Management", "background": "", "description": "你负责管理一个铁路运输网络。该网络由 $\\mathbf{N}$ 个车站组成。每个车站 $i$ 需要向另一个车站 $\\mathbf{D}_i$ 运输货物。车站 $i$ 将发送恰好一趟列车，该列车包含恰好 $\\mathbf{C}_i$ 节车厢。\n\n你提前获得了所有运输信息，因此计划通过重复使用车厢来节省资源。如果车站 $i$ 向车站 $\\mathbf{D}_i$ 发送了 $n$ 节车厢，那么车站 $\\mathbf{D}_i$ 可以将这些车厢加入自己的资源库以供后续使用（前提是这些车厢尚未被使用过）。\n\n具体来说，你需要为每个车站分配初始车厢数量（某些车站可能分配 0 节），并确定运输顺序，使得当车站 $i$ 需要进行运输时，其初始分配的车厢数量加上之前到达该站的车厢数量至少等于其运输需求 $\\mathbf{C}_i$。注意：即使车站 $i$ 当前拥有的车厢数量多于 $\\mathbf{C}_i$，每次运输也只能发送恰好 $\\mathbf{C}_i$ 节车厢。\n\n例如，假设车站 1 向车站 4 发送了 3 节车厢。如果车站 4 需要 2 节车厢，它可以重复使用从车站 1 接收的 2 节车厢。如果车站 4 需要发送 5 节车厢，它可以重复使用从车站 1 接收的 3 节车厢，并额外使用自己初始分配的 2 节。需要注意的是，当车站 4 只需要发送 2 节车厢时，它不能发送从车站 1 接收的全部 3 节车厢。\n\n给定运输信息，问：在所有可能的运输顺序中，车站初始分配的车厢总数的最小值是多少？", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含 3 行：第一行是一个整数 $\\mathbf{N}$，表示车站数量；第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{N}$；第三行包含 $\\mathbf{N}$ 个整数 $\\mathbf{C}_1, \\mathbf{C}_2, \\ldots, \\mathbf{C}_\\mathbf{N}$。这表示车站 $i$ 需要向车站 $\\mathbf{D}_i$ 发送恰好 $\\mathbf{C}_i$ 节车厢。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是满足所有运输需求所需的最少初始车厢总数。\n", "hint": "**样例解释**\n\n在样例 #1 中，最优方案是按照车站编号递增的顺序进行运输。这需要为车站 1 初始分配 4 节车厢。之后每个车站都能从接收的车厢中获得足够的资源，因此初始车厢总数为 4。由于没有车厢到达车站 1，它必须初始拥有全部 4 节车厢，因此这也是可能的最小值。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rzy2faew.png)\n\n在样例 #2 中，一种最优方案是为车站 3 分配 1 节车厢，为车站 2 和 4 各分配 2 节车厢，总计 5 节。然后可以先执行运输 $3 \\rightarrow 4$，这将为车站 4 增加 1 节车厢。此时车站 4 拥有 3 节车厢，足以完成运输 $4 \\rightarrow 1$。车站 1 现在有 3 节车厢，可以完成运输 $1 \\rightarrow 2$（只发送 1 节），使车站 2 的车厢总数达到 3 节，足以完成最后的运输 $2 \\rightarrow 3$。注意运输 $1 \\rightarrow 2$ 不能额外发送更多车厢，即使这对后续运输有帮助。存在其他使用 5 节初始车厢的方案，但无法使用更少的初始车厢完成所有运输。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ax0frede.png)\n\n在样例 #3 中，一种最优方案是为车站 1 和 4 各分配 3 节车厢，为车站 5 和 7 各分配 2 节车厢。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对所有 $i$，$1 \\leq \\mathbf{D}_i \\leq \\mathbf{N}$。\n- 对所有 $i$，$\\mathbf{D}_i \\neq i$。\n- 对所有 $i$，$1 \\leq \\mathbf{C}_i \\leq 10^9$。\n\n**测试集 1（9 分，可见判定）**\n- $2 \\leq \\mathbf{N} \\leq 8$。\n\n**测试集 2（20 分，可见判定）**\n- $2 \\leq \\mathbf{N} \\leq 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12956", "type": "P", "difficulty": 3, "samples": [["3\n3\nCO DEJ AM\n3\nCODE JA M\n2\nABABABAB AAA", "Case #1: POSSIBLE\nCO DEJ MA\nCase #2: POSSIBLE\nCODE JA M\nCase #3: IMPOSSIBLE"]], "limits": {"time": [5000, 5000, 5000], "memory": [2097152, 2097152, 2097152]}, "tags": ["2023", "Special Judge", "Google Code Jam"], "title": "[GCJ Farewell Round #3] Game Sort: Part 1", "background": null, "description": "Note: The main parts of the statements of the problems \"Game Sort: Part 1\" and \"Game Sort: Part 2\" are identical, except for the last paragraph. The problems can otherwise be solved independently.\n\nAmir and Badari are playing a sorting game. The game starts with a string $\\mathbf{S}$ and an integer $\\mathbf{P}$ being chosen by an impartial judge. Then, Amir has to split $\\mathbf{S}$ into exactly $\\mathbf{P}$ contiguous non-empty parts (substrings). For example, if $\\mathbf{S} = \\text{CODEJAM}$ was the chosen string and $\\mathbf{P} = 3$, Amir could split it up as $[\\text{COD}, \\text{EJA}, \\text{M}]$ or as $[\\text{CO}, \\text{D}, \\text{EJAM}]$, but not as $[\\text{COD}, \\text{EJAM}]$, $[\\text{COD}, \\text{JA}, \\text{M}]$, $[\\text{EJA}, \\text{COD}, \\text{M}]$, nor as $[\\text{CODE}, \\text{EJA}, \\text{M}]$.\n\nThen, Badari must rearrange the letters within each part to make the list of parts be sorted in non-decreasing lexicographical order. If she can, then she wins. Otherwise, Amir wins.\n\nGiven the partition Amir made, can you help Badari win the game, or say that it is not possible?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains a single integer $\\mathbf{P}$, the number of parts Amir made. The second line contains $\\mathbf{P}$ strings $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{P}$, representing the $\\mathbf{P}$ parts, in order.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either $\\text{POSSIBLE}$ if Badari can win the game, or $\\text{IMPOSSIBLE}$ if she cannot. If she can win the game, output a second line containing $t_1 t_2 \\ldots t_\\mathbf{P}$ where $t_i$ is a rearrangement of the letters of $\\mathbf{S}_i$, and $t_i$ is lexicographically earlier than or equal to $t_{i+1}$, for all $i$. If there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, Badari could also win in 5 other ways. Two of them are $[\\text{CO}, \\text{JED}, \\text{MA}]$ and $[\\text{CO}, \\text{EJD}, \\text{MA}]$.\n\nIn Sample Case #2, Badari can win simply by leaving all parts as Amir gave it to her, but other ways are also possible.\n\nIn Sample Case #3 Amir has guaranteed a win for himself leaving Badari no winning option.\n\n**Limits**\n\n$1 \\leq \\mathbf{T} \\leq 100$.\n\nEach character of $\\mathbf{S}_i$ is an English uppercase letter A through Z, for all $i$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{P} \\leq 3$.\n- $1 \\leq \\text{the length of } \\mathbf{S}_i \\leq 8$, for all $i$.\n\n**Test Set 2 (9 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{P} \\leq 100$.\n- $1 \\leq \\text{the length of } \\mathbf{S}_i \\leq 100$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #3] Game Sort: Part 1", "background": null, "description": "Note: The main parts of the statements of the problems \"Game Sort: Part 1\" and \"Game Sort: Part 2\" are identical, except for the last paragraph. The problems can otherwise be solved independently.\n\nAmir and Badari are playing a sorting game. The game starts with a string $\\mathbf{S}$ and an integer $\\mathbf{P}$ being chosen by an impartial judge. Then, Amir has to split $\\mathbf{S}$ into exactly $\\mathbf{P}$ contiguous non-empty parts (substrings). For example, if $\\mathbf{S} = \\text{CODEJAM}$ was the chosen string and $\\mathbf{P} = 3$, Amir could split it up as $[\\text{COD}, \\text{EJA}, \\text{M}]$ or as $[\\text{CO}, \\text{D}, \\text{EJAM}]$, but not as $[\\text{COD}, \\text{EJAM}]$, $[\\text{COD}, \\text{JA}, \\text{M}]$, $[\\text{EJA}, \\text{COD}, \\text{M}]$, nor as $[\\text{CODE}, \\text{EJA}, \\text{M}]$.\n\nThen, Badari must rearrange the letters within each part to make the list of parts be sorted in non-decreasing lexicographical order. If she can, then she wins. Otherwise, Amir wins.\n\nGiven the partition Amir made, can you help Badari win the game, or say that it is not possible?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains a single integer $\\mathbf{P}$, the number of parts Amir made. The second line contains $\\mathbf{P}$ strings $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{P}$, representing the $\\mathbf{P}$ parts, in order.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either $\\text{POSSIBLE}$ if Badari can win the game, or $\\text{IMPOSSIBLE}$ if she cannot. If she can win the game, output a second line containing $t_1 t_2 \\ldots t_\\mathbf{P}$ where $t_i$ is a rearrangement of the letters of $\\mathbf{S}_i$, and $t_i$ is lexicographically earlier than or equal to $t_{i+1}$, for all $i$. If there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, Badari could also win in 5 other ways. Two of them are $[\\text{CO}, \\text{JED}, \\text{MA}]$ and $[\\text{CO}, \\text{EJD}, \\text{MA}]$.\n\nIn Sample Case #2, Badari can win simply by leaving all parts as Amir gave it to her, but other ways are also possible.\n\nIn Sample Case #3 Amir has guaranteed a win for himself leaving Badari no winning option.\n\n**Limits**\n\n$1 \\leq \\mathbf{T} \\leq 100$.\n\nEach character of $\\mathbf{S}_i$ is an English uppercase letter A through Z, for all $i$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{P} \\leq 3$.\n- $1 \\leq \\text{the length of } \\mathbf{S}_i \\leq 8$, for all $i$.\n\n**Test Set 2 (9 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{P} \\leq 100$.\n- $1 \\leq \\text{the length of } \\mathbf{S}_i \\leq 100$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #3] Game Sort: Part 1", "background": null, "description": "**注意**：问题 **Game Sort: Part 1** 和 **Game Sort: Part 2** 的题目描述主要部分相同，仅最后一段不同。这两个问题可以独立解决。\n\nAmir 和 Badari 正在玩一个排序游戏。游戏开始时，一位公正的裁判会选择一个字符串 $\\mathbf{S}$ 和一个整数 $\\mathbf{P}$。然后，Amir 需要将 $\\mathbf{S}$ 分割成恰好 $\\mathbf{P}$ 个连续的非空部分（子字符串）。例如，如果选择的字符串是 $\\mathbf{S} = \\text{CODEJAM}$ 且 $\\mathbf{P} = 3$，Amir 可以将其分割为 $[\\text{COD}, \\text{EJA}, \\text{M}]$ 或 $[\\text{CO}, \\text{D}, \\text{EJAM}]$，但不能分割为 $[\\text{COD}, \\text{EJAM}]$、$[\\text{COD}, \\text{JA}, \\text{M}]$、$[\\text{EJA}, \\text{COD}, \\text{M}]$ 或 $[\\text{CODE}, \\text{EJA}, \\text{M}]$。\n\n接着，Badari 必须对每个部分的字母重新排列，使得这些部分按字典序非递减的顺序排列。如果她能完成，则她获胜；否则，Amir 获胜。\n\n给定 Amir 的分割方案，你能帮助 Badari 赢得游戏，或者判断这是否不可能吗？", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 个测试用例。每个测试用例包含两行：第一行是一个整数 $\\mathbf{P}$，表示 Amir 分割的部分数量；第二行包含 $\\mathbf{P}$ 个字符串 $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{P}$，按顺序表示分割后的部分。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 `POSSIBLE`（如果 Badari 可以获胜）或 `IMPOSSIBLE`（如果她不能）。如果她可以获胜，则额外输出一行，包含 $t_1 t_2 \\ldots t_\\mathbf{P}$，其中 $t_i$ 是 $\\mathbf{S}_i$ 的字母重新排列后的结果，且对于所有 $i$，$t_i$ 的字典序不大于 $t_{i+1}$。如果有多种解，输出任意一种即可。", "hint": "**样例解释**\n\n在样例 #1 中，Badari 还可以通过其他 5 种方式获胜，其中两种是 $[\\text{CO}, \\text{JED}, \\text{MA}]$ 和 $[\\text{CO}, \\text{EJD}, \\text{MA}]$。\n\n在样例 #2 中，Badari 可以直接保留 Amir 给出的分割方案获胜，但其他方式也是可行的。\n\n在样例 #3 中，Amir 确保了 Badari 无法获胜。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i$，$\\mathbf{S}_i$ 的每个字符均为大写字母 A 到 Z。\n\n**测试集 1（4 分，可见判定）**\n\n- $2 \\leq \\mathbf{P} \\leq 3$。\n- 对于所有 $i$，$1 \\leq \\mathbf{S}_i \\text{ 的长度} \\leq 8$。\n\n**测试集 2（9 分，隐藏判定）**\n\n- $2 \\leq \\mathbf{P} \\leq 100$。\n- 对于所有 $i$，$1 \\leq \\mathbf{S}_i \\text{ 的长度} \\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12957", "type": "P", "difficulty": 3, "samples": [["4\n5 4\n121 312 271 422 75\n199 464 160 234 368\n271 -109 -70 371\n2 2\n1 3\n4 4\n4 -1\n2 2\n1 4\n4 3\n4 -1\n1 10\n1\n2\n-987654321 -987654321 -987654321 -987654321 -987654321 987654321 987654321 987654321 987654321 987654323", "Case #1: 1 0 1 1\nCase #2: 2 0\nCase #3: 1 1\nCase #4: 0 0 0 0 0 0 0 0 0 1"]], "limits": {"time": [20000, 20000, 40000], "memory": [2097152, 2097152, 2097152]}, "tags": ["模拟", "堆", "2023", "Google Code Jam"], "title": "[GCJ Farewell Round #3] Immunization Operation", "background": "", "description": "Making every vaccine available to the entire world population is a complicated problem in many respects. Ñambi is leading the charge to optimize delivery. To reduce the access barriers as much as possible, she is trying to have automated robots deliver and apply vaccines directly in patients' homes.\n\nIn the current iteration, the robot that Ñambi is designing will work on a single street that runs from west to east. As such, the robot accepts a single command 'move $x$ meters'. If $x$ is positive, the robot moves $x$ meters to the east. If $x$ is negative, the robot moves $-x$ meters to the west.\n\nThe robot is loaded at the start of the day with the information about all immunizations it must provide that day. Each of these pieces of information consists of the current location of the vaccine, for pickup, and the location of the patient that must receive it, for delivery. Each vaccine is custom-made for one patient. Of course, the delivery location of a vaccine is never the same as its own pickup location. The robot must pick up the vaccine before it delivers it to the patient.\n\nThe robot is programmed to automatically pick up and load onto its cargo area vaccines when it passes through their pickup locations for the first time. The robot is also programmed to deliver the vaccine to its recipient as soon as it passes through their location if the vaccine was already picked up. Ñambi wants to track how many vaccinations happen after each movement command. A vaccination happens when the vaccine is delivered. Notice that the vaccine might be picked up during any of the previous commands, or during the same command, but before delivery.\n\nThe following picture illustrates one possible scenario (Sample Case #1 below). The smiley face represents the initial position of the robot, and the long black line is the street. The marks above the line are the pickup locations and the marks below are the delivery locations. Finally, the arrows below represent the moves the robot makes, in order from top to bottom, labeled with how many deliveries are completed during the move.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/05p9howp.png)\n\nThis is what happens during each move, in order:\n\n* Move 1. The robot picks up vaccines 5 and 1, then delivers vaccine 1, and then picks up vaccine 3 just as the move is finishing. Notice that the robot passes through the delivery location for vaccine 3, but since that happens before picking vaccine 3 up, it cannot deliver it.\n* Move 2. The robot passes through the delivery locations of vaccines 1 and 4. However, vaccine 1 is already delivered and vaccine 4 has not been picked up, so no vaccination is finished.\n* Move 3. The robot delivers vaccine 3.\n* Move 4. The robot picks up vaccine 2, delivers vaccine 5 and picks up vaccine 4.\n\nNotice that vaccine 2 and 4 were picked up but not delivered because the delivery location of vaccine 2 was never reached, and the delivery location of vaccine 4 was not reached after the vaccine had been picked up.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 4 lines. The first line of a test case contains 2 integers $\\mathbf{V}$ and $\\mathbf{M}$, the number of vaccinations and the number of move commands.\n\nThe second line of a test case contains $\\mathbf{V}$ integers $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots, \\mathbf{P}_\\mathbf{V}$, representing that the $i$-th vaccine must be picked up exactly $\\mathbf{P}_i$ meters to the east of the robot's initial location. Note that several vaccines can have the same pickup location.\n\nThe third line contains $\\mathbf{V}$ integers $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{V}$, representing that the $i$-th vaccine must be delivered exactly $\\mathbf{D}_i$ meters to the east of the robot's initial location. Note that several vaccines can have the same delivery location.\n\nThe final line of a test case contains $\\mathbf{M}$ integers $\\mathbf{X}_1, \\mathbf{X}_2, \\ldots, \\mathbf{X}_\\mathbf{M}$, where the absolute value of $\\mathbf{X}_j$ is the number of meters the robot must move for the $j$-th movement command. The $j$-th move must be towards the east if $\\mathbf{X}_j$ is positive, and towards the west if it is negative. Notice that the vaccinations can happen in an order different than the numbering of the input, but movement commands happen in the given order.", "outputFormat": "For each test case, output one line containing `case #x: y1 y2 ... yM`, where $x$ is the test case number (starting from 1) and $y_j$ is the number of vaccinations completed while performing the $j$-th given movement command.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained and illustrated in the problem statement.\n\nIn Sample Case #2 and Sample Case #3, notice that it is possible to pick up and deliver vaccines in the same move only if the pickup place is visited first. In addition, notice that it is possible pick up and to deliver exactly as a move is ending.\n\nSample Case #4, the robot moves $987654321$ meters to the west five times, then $987654321$ meters to the east four times, then $987654323$ meters to the east. The only pickup and delivery are both made in the final move. Note that the commands can be very extreme so the robot can be at some point very far away from its initial position, either west or east.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{P}_i \\leq 10^9$, for all $i$.\n- $1 \\leq \\mathbf{D}_i \\leq 10^9$, for all $i$.\n- $\\mathbf{P}_i \\neq \\mathbf{D}_i$, for all $i$.\n- $-10^9 \\leq \\mathbf{X}_j \\leq 10^9$, for all $j$.\n- $\\mathbf{X}_j \\neq 0$, for all $j$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $1 \\leq \\mathbf{V} \\leq 100$.\n- $1 \\leq \\mathbf{M} \\leq 100$.\n\n**Test Set 2 (9 Pts, Hidden Verdict)**\n\n- Time limit: 40 seconds.\n- $1 \\leq \\mathbf{V} \\leq 10^5$.\n- $1 \\leq \\mathbf{M} \\leq 10^5$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #3] Immunization Operation", "background": "", "description": "Making every vaccine available to the entire world population is a complicated problem in many respects. Ñambi is leading the charge to optimize delivery. To reduce the access barriers as much as possible, she is trying to have automated robots deliver and apply vaccines directly in patients' homes.\n\nIn the current iteration, the robot that Ñambi is designing will work on a single street that runs from west to east. As such, the robot accepts a single command 'move $x$ meters'. If $x$ is positive, the robot moves $x$ meters to the east. If $x$ is negative, the robot moves $-x$ meters to the west.\n\nThe robot is loaded at the start of the day with the information about all immunizations it must provide that day. Each of these pieces of information consists of the current location of the vaccine, for pickup, and the location of the patient that must receive it, for delivery. Each vaccine is custom-made for one patient. Of course, the delivery location of a vaccine is never the same as its own pickup location. The robot must pick up the vaccine before it delivers it to the patient.\n\nThe robot is programmed to automatically pick up and load onto its cargo area vaccines when it passes through their pickup locations for the first time. The robot is also programmed to deliver the vaccine to its recipient as soon as it passes through their location if the vaccine was already picked up. Ñambi wants to track how many vaccinations happen after each movement command. A vaccination happens when the vaccine is delivered. Notice that the vaccine might be picked up during any of the previous commands, or during the same command, but before delivery.\n\nThe following picture illustrates one possible scenario (Sample Case #1 below). The smiley face represents the initial position of the robot, and the long black line is the street. The marks above the line are the pickup locations and the marks below are the delivery locations. Finally, the arrows below represent the moves the robot makes, in order from top to bottom, labeled with how many deliveries are completed during the move.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/05p9howp.png)\n\nThis is what happens during each move, in order:\n\n* Move 1. The robot picks up vaccines 5 and 1, then delivers vaccine 1, and then picks up vaccine 3 just as the move is finishing. Notice that the robot passes through the delivery location for vaccine 3, but since that happens before picking vaccine 3 up, it cannot deliver it.\n* Move 2. The robot passes through the delivery locations of vaccines 1 and 4. However, vaccine 1 is already delivered and vaccine 4 has not been picked up, so no vaccination is finished.\n* Move 3. The robot delivers vaccine 3.\n* Move 4. The robot picks up vaccine 2, delivers vaccine 5 and picks up vaccine 4.\n\nNotice that vaccine 2 and 4 were picked up but not delivered because the delivery location of vaccine 2 was never reached, and the delivery location of vaccine 4 was not reached after the vaccine had been picked up.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 4 lines. The first line of a test case contains 2 integers $\\mathbf{V}$ and $\\mathbf{M}$, the number of vaccinations and the number of move commands.\n\nThe second line of a test case contains $\\mathbf{V}$ integers $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots, \\mathbf{P}_\\mathbf{V}$, representing that the $i$-th vaccine must be picked up exactly $\\mathbf{P}_i$ meters to the east of the robot's initial location. Note that several vaccines can have the same pickup location.\n\nThe third line contains $\\mathbf{V}$ integers $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{V}$, representing that the $i$-th vaccine must be delivered exactly $\\mathbf{D}_i$ meters to the east of the robot's initial location. Note that several vaccines can have the same delivery location.\n\nThe final line of a test case contains $\\mathbf{M}$ integers $\\mathbf{X}_1, \\mathbf{X}_2, \\ldots, \\mathbf{X}_\\mathbf{M}$, where the absolute value of $\\mathbf{X}_j$ is the number of meters the robot must move for the $j$-th movement command. The $j$-th move must be towards the east if $\\mathbf{X}_j$ is positive, and towards the west if it is negative. Notice that the vaccinations can happen in an order different than the numbering of the input, but movement commands happen in the given order.", "outputFormat": "For each test case, output one line containing `case #x: y1 y2 ... yM`, where $x$ is the test case number (starting from 1) and $y_j$ is the number of vaccinations completed while performing the $j$-th given movement command.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained and illustrated in the problem statement.\n\nIn Sample Case #2 and Sample Case #3, notice that it is possible to pick up and deliver vaccines in the same move only if the pickup place is visited first. In addition, notice that it is possible pick up and to deliver exactly as a move is ending.\n\nSample Case #4, the robot moves $987654321$ meters to the west five times, then $987654321$ meters to the east four times, then $987654323$ meters to the east. The only pickup and delivery are both made in the final move. Note that the commands can be very extreme so the robot can be at some point very far away from its initial position, either west or east.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{P}_i \\leq 10^9$, for all $i$.\n- $1 \\leq \\mathbf{D}_i \\leq 10^9$, for all $i$.\n- $\\mathbf{P}_i \\neq \\mathbf{D}_i$, for all $i$.\n- $-10^9 \\leq \\mathbf{X}_j \\leq 10^9$, for all $j$.\n- $\\mathbf{X}_j \\neq 0$, for all $j$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $1 \\leq \\mathbf{V} \\leq 100$.\n- $1 \\leq \\mathbf{M} \\leq 100$.\n\n**Test Set 2 (9 Pts, Hidden Verdict)**\n\n- Time limit: 40 seconds.\n- $1 \\leq \\mathbf{V} \\leq 10^5$.\n- $1 \\leq \\mathbf{M} \\leq 10^5$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #3] Immunization Operation", "background": null, "description": "为全球人口提供疫苗是一个涉及多方面的复杂问题。**Ñambi** 正致力于优化疫苗配送流程。为了尽可能降低接种门槛，她尝试使用自动化机器人直接将疫苗配送到患者家中并完成接种。\n\n在当前的方案中，**Ñambi** 设计的机器人将在一条东西走向的街道上工作。机器人接受单一指令“移动 $x$ 米”：若 $x$ 为正，则向东移动 $x$ 米；若 $x$ 为负，则向西移动 $x$ 米。\n\n机器人每天启动时会加载当天需完成的所有疫苗接种信息。每条信息包含疫苗的当前位置（用于取货）和患者位置（用于配送）。每支疫苗均为特定患者定制，且配送位置永远不会与取货位置相同。机器人必须在配送疫苗前先取货。\n\n机器人编程逻辑如下：\n- 首次经过疫苗取货位置时，自动取货并装载至货舱。\n- 若已取货的疫苗对应的患者位置被经过，则立即完成配送。\n**Ñambi** 需要统计每条移动指令后完成的疫苗接种次数。疫苗接种发生在疫苗被配送时。注意：疫苗可能在同一指令的移动过程中被取货（需在配送前完成取货）。\n\n下图展示了样例 #1 的场景：笑脸为机器人初始位置，黑线为街道。上方标记为取货位置，下方标记为配送位置，底部箭头按从上到下的顺序标注了每次移动完成的配送次数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/05p9howp.png)\n\n各次移动的具体过程：\n1. **移动 1**：取货疫苗 5 和 1 → 配送疫苗 1 → 在移动结束时取货疫苗 3。注意：虽然经过疫苗 3 的配送位置，但因未取货，无法配送。\n2. **移动 2**：经过疫苗 1 和 4 的配送位置。疫苗 1 已配送，疫苗 4 未取货，故无配送。\n3. **移动 3**：配送疫苗 3。\n4. **移动 4**：取货疫苗 2 → 配送疫苗 5 → 取货疫苗 4。疫苗 2 和 4 未被配送（疫苗 2 的配送位置未到达，疫苗 4 的配送位置在取货前已通过）。", "inputFormat": "输入第一行包含测试用例数量 $\\mathbf{T}$。每个测试用例包含 4 行：\n1. 两个整数 $\\mathbf{V}$（疫苗接种数）和 $\\mathbf{M}$（移动指令数）。\n2. $\\mathbf{V}$ 个整数 $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots, \\mathbf{P}_\\mathbf{V}$，表示第 $i$ 支疫苗的取货位置在初始位置以东 $\\mathbf{P}_i$ 米处（允许多支疫苗同一取货点）。\n3. $\\mathbf{V}$ 个整数 $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{V}$，表示第 $i$ 支疫苗的配送位置在初始位置以东 $\\mathbf{D}_i$ 米处（允许多支疫苗同一配送点）。\n4. $\\mathbf{M}$ 个整数 $\\mathbf{X}_1, \\mathbf{X}_2, \\ldots, \\mathbf{X}_\\mathbf{M}$，第 $j$ 次移动的米数为 $|\\mathbf{X}_j|$，方向为东（$\\mathbf{X}_j > 0$）或西（$\\mathbf{X}_j < 0$）。疫苗接种顺序可能与输入编号不同，但移动指令按给定顺序执行。", "outputFormat": "对每个测试用例，输出一行 `Case #x: y1 y2 ... yM`，其中 $x$ 为测试用例编号（从 1 开始），$y_j$ 为第 $j$ 次移动完成的疫苗接种次数。", "hint": "**样例解释**\n- **样例 #1**：题目描述中的图示场景。\n- **样例 #2 和 #3**：若取货位置先于配送位置被访问，则同一移动中可完成取货和配送。移动结束时也可能完成操作。\n- **样例 #4**：机器人先向西移动 5 次（每次 987654321 米），再向东移动 4 次（每次 987654321 米），最后向东移动 987654323 米。唯一一次取货和配送均在最后一次移动中完成。移动指令的数值可能极大。\n\n**限制条件**\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{P}_i, \\mathbf{D}_i \\leq 10^9$，且 $\\mathbf{P}_i \\neq \\mathbf{D}_i$。\n- $\\mathbf{X}_j \\in [-10^9, 10^9]$ 且 $\\mathbf{X}_j \\neq 0$。\n\n**测试集 1（4 分，可见判定）**\n- 时间限制：20 秒。\n- $1 \\leq \\mathbf{V}, \\mathbf{M} \\leq 100$。\n\n**测试集 2（9 分，隐藏判定）**\n- 时间限制：40 秒。\n- $1 \\leq \\mathbf{V}, \\mathbf{M} \\leq 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12958", "type": "P", "difficulty": 4, "samples": [["2\n5 2\n3 3 6 2 2\n3 1 1 3\n7 3\n2 4 7 2 2 1 8\n6 1 7 3 1 3", "Case #1: 1\nCase #2: 7"]], "limits": {"time": [40000, 40000, 40000], "memory": [2097152, 2097152, 2097152]}, "tags": ["树状数组", "2023", "Google Code Jam"], "title": "[GCJ Farewell Round #3] Evolutionary Algorithms", "background": "", "description": "Ada is working on a science project for school. She is studying evolution and she would like to compare how different species of organisms would perform when trying to solve a coding competition problem.\n\nThe $\\mathbf{N}$ species are numbered with integers between 1 and $\\mathbf{N}$, inclusive. Species 1 has no direct ancestor, and all other species have exactly one direct ancestor each, from which they directly evolved. A (not necessarily direct) ancestor of species $x$ is any other species $y$ such that $y$ can be reached from $x$ by moving one or more times to a species direct ancestor starting from $x$. In this way, species 1 is a (direct or indirect) ancestor of every other species.\n\nThrough complex genetic simulations, she calculated the average score each of the $\\mathbf{N}$ species would get in a particular coding competition. $\\mathbf{S}_i$ is that average score for species $i$.\n\nAda is looking for interesting triplets to showcase in her presentation. An interesting triplet is defined as an ordered triplet of distinct species $(a, b, c)$ such that:\n\n1. Species $b$ is a (direct or indirect) ancestor of species $a$.\n2. Species $b$ is not a (direct or indirect) ancestor of species $c$.\n3. Species $b$ has an average score strictly more than $\\mathbf{K}$ times higher than both of those of $a$ and $c$. That is, $\\mathbf{S}_b \\geq \\mathbf{K} \\times \\max(\\mathbf{S}_a, \\mathbf{S}_c) + 1$.\n\nGiven the species scores and ancestry relationships, help Ada by writing a program to count the total number of interesting triplets.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow.\n\nThe first line of each test case contains two integers $\\mathbf{N}$ and $\\mathbf{K}$, denoting the number of species and the factor which determines interesting triplets, respectively.\n\nThe second line of each test case contains $\\mathbf{N}$ integers $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{N}$, where $\\mathbf{S}_i$ denotes the average score of species $i$.\n\nThe third line of each test case contains $\\mathbf{N} - 1$ integers $\\mathbf{P}_2, \\mathbf{P}_3, \\ldots, \\mathbf{P}_\\mathbf{N}$, meaning species $\\mathbf{P}_i$ is the direct ancestor of species $i$.", "outputFormat": "For each test case, output one line containing `case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the total number of interesting triplets according to Ada's definition.", "hint": "**Sample Explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4o5vn91i.png)\n\nIn Sample Case #1, there is only one possible interesting triplet: $(5, 3, 4)$. Indeed, we can verify that:\n\n1. Species $b = 3$ is an ancestor of species $a = 5$.\n2. Species $b = 3$ is not an ancestor of species $c = 4$.\n3. The score of species $b = 3$ is more than $\\mathbf{K}$ times higher than the scores of both $a = 5$ and $c = 4$: $6 = \\mathbf{S}_3 \\geq \\mathbf{K} \\times \\max(\\mathbf{S}_4, \\mathbf{S}_5) + 1 = 2 \\times \\max(2, 2) + 1 = 5$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vi8pvu68.png)\n\nIn Sample Case #2, there are seven interesting triplets:\n\n* $(4, 3, 1)$\n* $(4, 3, 6)$\n* $(4, 7, 1)$\n* $(4, 7, 5)$\n* $(4, 7, 6)$\n* $(5, 3, 1)$\n* $(5, 3, 6)$\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{K} \\leq 10^9$.\n- $1 \\leq \\mathbf{S}_i \\leq 10^9$, for all $i$.\n- $1 \\leq \\mathbf{P}_i \\leq \\mathbf{N}$, for all $i$.\n- Species 1 is a (direct or indirect) ancestor of all other species.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $3 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 2 (16 Pts, Hidden Verdict)**\n\nFor at most 30 cases:\n\n- $3 \\leq \\mathbf{N} \\leq 2 \\times 10^5$.\n\nFor the remaining cases:\n\n- $3 \\leq \\mathbf{N} \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #3] Evolutionary Algorithms", "background": "", "description": "Ada is working on a science project for school. She is studying evolution and she would like to compare how different species of organisms would perform when trying to solve a coding competition problem.\n\nThe $\\mathbf{N}$ species are numbered with integers between 1 and $\\mathbf{N}$, inclusive. Species 1 has no direct ancestor, and all other species have exactly one direct ancestor each, from which they directly evolved. A (not necessarily direct) ancestor of species $x$ is any other species $y$ such that $y$ can be reached from $x$ by moving one or more times to a species direct ancestor starting from $x$. In this way, species 1 is a (direct or indirect) ancestor of every other species.\n\nThrough complex genetic simulations, she calculated the average score each of the $\\mathbf{N}$ species would get in a particular coding competition. $\\mathbf{S}_i$ is that average score for species $i$.\n\nAda is looking for interesting triplets to showcase in her presentation. An interesting triplet is defined as an ordered triplet of distinct species $(a, b, c)$ such that:\n\n1. Species $b$ is a (direct or indirect) ancestor of species $a$.\n2. Species $b$ is not a (direct or indirect) ancestor of species $c$.\n3. Species $b$ has an average score strictly more than $\\mathbf{K}$ times higher than both of those of $a$ and $c$. That is, $\\mathbf{S}_b \\geq \\mathbf{K} \\times \\max(\\mathbf{S}_a, \\mathbf{S}_c) + 1$.\n\nGiven the species scores and ancestry relationships, help Ada by writing a program to count the total number of interesting triplets.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow.\n\nThe first line of each test case contains two integers $\\mathbf{N}$ and $\\mathbf{K}$, denoting the number of species and the factor which determines interesting triplets, respectively.\n\nThe second line of each test case contains $\\mathbf{N}$ integers $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{N}$, where $\\mathbf{S}_i$ denotes the average score of species $i$.\n\nThe third line of each test case contains $\\mathbf{N} - 1$ integers $\\mathbf{P}_2, \\mathbf{P}_3, \\ldots, \\mathbf{P}_\\mathbf{N}$, meaning species $\\mathbf{P}_i$ is the direct ancestor of species $i$.", "outputFormat": "For each test case, output one line containing `case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the total number of interesting triplets according to Ada's definition.", "hint": "**Sample Explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4o5vn91i.png)\n\nIn Sample Case #1, there is only one possible interesting triplet: $(5, 3, 4)$. Indeed, we can verify that:\n\n1. Species $b = 3$ is an ancestor of species $a = 5$.\n2. Species $b = 3$ is not an ancestor of species $c = 4$.\n3. The score of species $b = 3$ is more than $\\mathbf{K}$ times higher than the scores of both $a = 5$ and $c = 4$: $6 = \\mathbf{S}_3 \\geq \\mathbf{K} \\times \\max(\\mathbf{S}_4, \\mathbf{S}_5) + 1 = 2 \\times \\max(2, 2) + 1 = 5$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vi8pvu68.png)\n\nIn Sample Case #2, there are seven interesting triplets:\n\n* $(4, 3, 1)$\n* $(4, 3, 6)$\n* $(4, 7, 1)$\n* $(4, 7, 5)$\n* $(4, 7, 6)$\n* $(5, 3, 1)$\n* $(5, 3, 6)$\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{K} \\leq 10^9$.\n- $1 \\leq \\mathbf{S}_i \\leq 10^9$, for all $i$.\n- $1 \\leq \\mathbf{P}_i \\leq \\mathbf{N}$, for all $i$.\n- Species 1 is a (direct or indirect) ancestor of all other species.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $3 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 2 (16 Pts, Hidden Verdict)**\n\nFor at most 30 cases:\n\n- $3 \\leq \\mathbf{N} \\leq 2 \\times 10^5$.\n\nFor the remaining cases:\n\n- $3 \\leq \\mathbf{N} \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #3] Evolutionary Algorithms", "background": null, "description": "Ada 正在为学校的科学项目工作。她研究生物进化，并希望比较不同物种在解决编程竞赛问题时的表现。\n\n共有 $\\mathbf{N}$ 个物种，编号为 1 到 $\\mathbf{N}$。物种 1 没有直接祖先，其他每个物种都有且仅有一个直接祖先。物种 $x$ 的（直接或间接）祖先是指从 $x$ 出发，通过一次或多次向上追溯直接祖先能到达的任何其他物种 $y$。因此，物种 1 是所有其他物种的（直接或间接）祖先。\n\n通过复杂的遗传模拟，她计算了每个物种在特定编程竞赛中的平均得分 $\\mathbf{S}_i$（$i$ 为物种编号）。\n\nAda 希望在她的展示中呈现一些有趣的三元组。一个有趣的三元组定义为满足以下条件的有序三元组 $(a, b, c)$（$a, b, c$ 为不同物种）：\n\n1. 物种 $b$ 是物种 $a$ 的（直接或间接）祖先。\n2. 物种 $b$ **不是**物种 $c$ 的（直接或间接）祖先。\n3. 物种 $b$ 的平均得分严格大于 $\\mathbf{K}$ 倍 $\\max(\\mathbf{S}_a, \\mathbf{S}_c)$，即 $\\mathbf{S}_b \\geq \\mathbf{K} \\times \\max(\\mathbf{S}_a, \\mathbf{S}_c) + 1$。\n\n给定物种得分和祖先关系，编写程序计算所有满足条件的有趣三元组数量。", "inputFormat": "输入第一行包含测试用例数量 $\\mathbf{T}$。每个测试用例包含三行：\n1. 两个整数 $\\mathbf{N}$（物种数）和 $\\mathbf{K}$（判定系数）。\n2. $\\mathbf{N}$ 个整数 $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{N}$，表示各物种的平均得分。\n3. $\\mathbf{N} - 1$ 个整数 $\\mathbf{P}_2, \\mathbf{P}_3, \\ldots, \\mathbf{P}_\\mathbf{N}$，表示物种 $i$ 的直接祖先为 $\\mathbf{P}_i$。", "outputFormat": "对每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为有趣三元组的总数。", "hint": "**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4o5vn91i.png)\n\n在样例 #1 中，唯一满足条件的三元组是 $(5, 3, 4)$。验证如下：\n1. 物种 3 是物种 5 的祖先。\n2. 物种 3 不是物种 4 的祖先。\n3. $\\mathbf{S}_3 = 6 \\geq 2 \\times \\max(2, 2) + 1 = 5$（设 $\\mathbf{K} = 2$）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vi8pvu68.png)\n\n在样例 #2 中，共有 7 个有趣三元组：\n- $(4, 3, 1)$\n- $(4, 3, 6)$\n- $(4, 7, 1)$\n- $(4, 7, 5)$\n- $(4, 7, 6)$\n- $(5, 3, 1)$\n- $(5, 3, 6)$\n\n**限制条件**\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{K} \\leq 10^9$。\n- $1 \\leq \\mathbf{S}_i \\leq 10^9$。\n- 物种 1 是所有其他物种的祖先。\n\n**测试集 1（7 分，可见判定）**\n- $3 \\leq \\mathbf{N} \\leq 1000$。\n\n**测试集 2（16 分，隐藏判定）**\n- 最多 30 个测试用例：$3 \\leq \\mathbf{N} \\leq 2 \\times 10^5$。\n- 其余测试用例：$3 \\leq \\mathbf{N} \\leq 1000$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12959", "type": "P", "difficulty": 4, "samples": [["2\n5 5 3\n1 2 1\n2 3 2\n2 4 1\n2 5 1\n4 5 1\n1 3\n3 4\n5 1\n3 1 2\n1 3 1\n1 2\n1 3", "Case #1: 1\nCase #2: 1"], ["1\n4 5 2\n1 2 3\n1 3 3\n3 4 7\n2 3 3\n2 4 6\n1 2\n1 4", "Case #1: 2"]], "limits": {"time": [20000, 20000, 40000, 120000], "memory": [2097152, 2097152, 2097152, 2097152]}, "tags": ["图论", "并查集", "2023", "Google Code Jam"], "title": "[GCJ Farewell Round #3] The Decades of Coding Competitions", "background": "", "description": "It has been almost 15 years since Sphinny became the premiere programming contestant by mastering the art of scheduling contests. She has grown alongside Coding Competitions and graduated into a programming contest organizer, and her Programming Club League (PCL) is the most popular sport in her city.\n\nThere are $\\mathbf{N}$ bus stops in Sphinny's city, and $\\mathbf{M}$ express bus routes. Each route bidirectionally connects two different bus stops, called their endpoints. Because of the popularity of PCL, the driver of each bus routes cheers for exactly one club.\n\nSphinny has to pick up the contest materials for the $j$-th contest at bus stop $\\mathbf{P}_j$ and then the contest will be run in bus stop $\\mathbf{C}_j$. She can only use the given bus routes to travel between them. Formally, a path for Sphinny to go from $\\mathbf{P}_j$ to $\\mathbf{C}_j$ is a list of bus routes such that each two consecutive routes have a common endpoint. Also the first route in the path has $\\mathbf{P}_j$ as an endpoint and the last one has $\\mathbf{C}_j$ as an endpoint. Notice that the same bus route can be used multiple times in a path. If Sphinny's path from $\\mathbf{P}_j$ to $\\mathbf{C}_j$ contains one or more bus routes whose driver cheers for club $c$, then club $c$ will join the contest. Otherwise, club $c$ will not join the contest. For organizational reasons, Sphinny needs the number of clubs in each contest to be an odd number.\n\nGiven the layout of Sphinny's city's bus routes and the contests' details, find out for how many contests there exists a path for Sphinny to take that can ensure an odd number of clubs joining it.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow.\n\nThe first line of each test case contains three integers $\\mathbf{N}$, $\\mathbf{M}$, and $\\mathbf{Q}$: the number of bus stops, bus routes, and contests, respectively.\n\nThen, $\\mathbf{M}$ lines follow representing a different bus route each. The $i$-th of these lines contains three integers $\\mathbf{U}_i$, $\\mathbf{V}_i$, and $\\mathbf{K}_i$, meaning that the $i$-th bus route connects bus stops $\\mathbf{U}_i$ and $\\mathbf{V}_i$ and its driver cheers for club $\\mathbf{K}_i$.\n\nFinally, the last $\\mathbf{Q}$ lines represent a contest each. The $j$-th of these lines contains two integers $\\mathbf{P}_j$ and $\\mathbf{C}_j$, representing that materials for the $j$-th contest need to be picked up at bus stop $\\mathbf{P}_j$ and the contest needs to be run at bus stop $\\mathbf{C}_j$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of contests for which Sphinny can find a path that ensures an odd number of clubs join it.", "hint": "**Sample Explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/axkzo8s5.png)\n\nSample Case #1 is pictured above. In the first two contests, both clubs (green and blue) must be involved in it no matter what path is chosen. For the last contest, it is possible to involve only the green club by using the path through bus stops $1, 2, 4, 5$.\n\nFor Sample Case #2, the first contest is not possible because there is no path to go from bus stop $1$ to bus stop $2$. For the second contest, there is a path including the only bus route going bus stop $1$ to bus stop $3$, therefore yielding a contest involving exactly $1$ club, which is an acceptable odd number of clubs.\n\nThe following additional sample fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ycyh0jsk.png)\n\nThis additional Sample Case is pictured above. In this case, both contests can be done with an odd number of clubs. An example path that achieves that is shown in the picture.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{U}_i \\leq \\mathbf{N}$, for all $i$.\n- $1 \\leq \\mathbf{V}_i \\leq \\mathbf{N}$, for all $i$.\n- $\\mathbf{U}_i \\neq \\mathbf{V}_i$, for all $i$\n- $(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{U}_j, \\mathbf{V}_j)$ and $(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{V}_j, \\mathbf{U}_j)$, for all $i \\neq j$. (No two bus routes have the same pair of endpoints.)\n- $1 \\leq \\mathbf{P}_j \\leq \\mathbf{N}$, for all $j$.\n- $1 \\leq \\mathbf{C}_j \\leq \\mathbf{N}$, for all $j$.\n- $\\mathbf{P}_j \\neq \\mathbf{C}_j$, for all $j$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $2 \\leq \\mathbf{N} \\leq 500$.\n- $1 \\leq \\mathbf{M} \\leq 500$.\n- $1 \\leq \\mathbf{Q} \\leq 500$.\n- $1 \\leq \\mathbf{K}_j \\leq 2$, for all $j$.\n\n**Test Set 2 (6 Pts, Visible Verdict)**\n\n- Time limit: 40 seconds.\n- $2 \\leq \\mathbf{N} \\leq 500$.\n- $1 \\leq \\mathbf{M} \\leq 500$.\n- $1 \\leq \\mathbf{Q} \\leq 500$.\n- $1 \\leq \\mathbf{K}_j \\leq 100$, for all $j$.\n\n**Test Set 3 (10 Pts, Hidden Verdict)**\n\n- Time limit: 120 seconds.\n- $2 \\leq \\mathbf{N} \\leq 10000$.\n- $1 \\leq \\mathbf{M} \\leq 10000$.\n- $1 \\leq \\mathbf{Q} \\leq 10000$.\n- $1 \\leq \\mathbf{K}_j \\leq 100$, for all $j$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #3] The Decades of Coding Competitions", "background": "", "description": "It has been almost 15 years since Sphinny became the premiere programming contestant by mastering the art of scheduling contests. She has grown alongside Coding Competitions and graduated into a programming contest organizer, and her Programming Club League (PCL) is the most popular sport in her city.\n\nThere are $\\mathbf{N}$ bus stops in Sphinny's city, and $\\mathbf{M}$ express bus routes. Each route bidirectionally connects two different bus stops, called their endpoints. Because of the popularity of PCL, the driver of each bus routes cheers for exactly one club.\n\nSphinny has to pick up the contest materials for the $j$-th contest at bus stop $\\mathbf{P}_j$ and then the contest will be run in bus stop $\\mathbf{C}_j$. She can only use the given bus routes to travel between them. Formally, a path for Sphinny to go from $\\mathbf{P}_j$ to $\\mathbf{C}_j$ is a list of bus routes such that each two consecutive routes have a common endpoint. Also the first route in the path has $\\mathbf{P}_j$ as an endpoint and the last one has $\\mathbf{C}_j$ as an endpoint. Notice that the same bus route can be used multiple times in a path. If Sphinny's path from $\\mathbf{P}_j$ to $\\mathbf{C}_j$ contains one or more bus routes whose driver cheers for club $c$, then club $c$ will join the contest. Otherwise, club $c$ will not join the contest. For organizational reasons, Sphinny needs the number of clubs in each contest to be an odd number.\n\nGiven the layout of Sphinny's city's bus routes and the contests' details, find out for how many contests there exists a path for Sphinny to take that can ensure an odd number of clubs joining it.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow.\n\nThe first line of each test case contains three integers $\\mathbf{N}$, $\\mathbf{M}$, and $\\mathbf{Q}$: the number of bus stops, bus routes, and contests, respectively.\n\nThen, $\\mathbf{M}$ lines follow representing a different bus route each. The $i$-th of these lines contains three integers $\\mathbf{U}_i$, $\\mathbf{V}_i$, and $\\mathbf{K}_i$, meaning that the $i$-th bus route connects bus stops $\\mathbf{U}_i$ and $\\mathbf{V}_i$ and its driver cheers for club $\\mathbf{K}_i$.\n\nFinally, the last $\\mathbf{Q}$ lines represent a contest each. The $j$-th of these lines contains two integers $\\mathbf{P}_j$ and $\\mathbf{C}_j$, representing that materials for the $j$-th contest need to be picked up at bus stop $\\mathbf{P}_j$ and the contest needs to be run at bus stop $\\mathbf{C}_j$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of contests for which Sphinny can find a path that ensures an odd number of clubs join it.", "hint": "**Sample Explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/axkzo8s5.png)\n\nSample Case #1 is pictured above. In the first two contests, both clubs (green and blue) must be involved in it no matter what path is chosen. For the last contest, it is possible to involve only the green club by using the path through bus stops $1, 2, 4, 5$.\n\nFor Sample Case #2, the first contest is not possible because there is no path to go from bus stop $1$ to bus stop $2$. For the second contest, there is a path including the only bus route going bus stop $1$ to bus stop $3$, therefore yielding a contest involving exactly $1$ club, which is an acceptable odd number of clubs.\n\nThe following additional sample fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ycyh0jsk.png)\n\nThis additional Sample Case is pictured above. In this case, both contests can be done with an odd number of clubs. An example path that achieves that is shown in the picture.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{U}_i \\leq \\mathbf{N}$, for all $i$.\n- $1 \\leq \\mathbf{V}_i \\leq \\mathbf{N}$, for all $i$.\n- $\\mathbf{U}_i \\neq \\mathbf{V}_i$, for all $i$\n- $(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{U}_j, \\mathbf{V}_j)$ and $(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{V}_j, \\mathbf{U}_j)$, for all $i \\neq j$. (No two bus routes have the same pair of endpoints.)\n- $1 \\leq \\mathbf{P}_j \\leq \\mathbf{N}$, for all $j$.\n- $1 \\leq \\mathbf{C}_j \\leq \\mathbf{N}$, for all $j$.\n- $\\mathbf{P}_j \\neq \\mathbf{C}_j$, for all $j$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $2 \\leq \\mathbf{N} \\leq 500$.\n- $1 \\leq \\mathbf{M} \\leq 500$.\n- $1 \\leq \\mathbf{Q} \\leq 500$.\n- $1 \\leq \\mathbf{K}_j \\leq 2$, for all $j$.\n\n**Test Set 2 (6 Pts, Visible Verdict)**\n\n- Time limit: 40 seconds.\n- $2 \\leq \\mathbf{N} \\leq 500$.\n- $1 \\leq \\mathbf{M} \\leq 500$.\n- $1 \\leq \\mathbf{Q} \\leq 500$.\n- $1 \\leq \\mathbf{K}_j \\leq 100$, for all $j$.\n\n**Test Set 3 (10 Pts, Hidden Verdict)**\n\n- Time limit: 120 seconds.\n- $2 \\leq \\mathbf{N} \\leq 10000$.\n- $1 \\leq \\mathbf{M} \\leq 10000$.\n- $1 \\leq \\mathbf{Q} \\leq 10000$.\n- $1 \\leq \\mathbf{K}_j \\leq 100$, for all $j$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #3] The Decades of Coding Competitions", "background": "", "description": "自 **Sphinny** 通过掌握竞赛排程的艺术成为顶尖编程选手以来，已经过去了近 15 年。她与 **Coding Competitions** 一同成长，并转型为一名编程竞赛组织者，而她创立的 **Programming Club League (PCL)** 已成为她所在城市最受欢迎的运动。\n\n**Sphinny** 的城市中有 $\\mathbf{N}$ 个公交站点和 $\\mathbf{M}$ 条快速公交线路。每条线路双向连接两个不同的公交站点（称为端点）。由于 **PCL** 的流行，每条公交线路的司机恰好为一个俱乐部加油。\n\n**Sphinny** 需要在第 $j$ 场比赛前从公交站点 $\\mathbf{P}_j$ 取比赛材料，然后在公交站点 $\\mathbf{C}_j$ 举办比赛。她只能使用给定的公交线路在两者之间通行。形式上，**Sphinny** 从 $\\mathbf{P}_j$ 到 $\\mathbf{C}_j$ 的路径是一个公交线路列表，其中每两条相邻线路有一个共同的端点，且第一条线路的端点为 $\\mathbf{P}_j$，最后一条线路的端点为 $\\mathbf{C}_j$。注意，同一条公交线路可以在路径中多次使用。如果 **Sphinny** 从 $\\mathbf{P}_j$ 到 $\\mathbf{C}_j$ 的路径中包含一条或多条司机为俱乐部 $c$ 加油的公交线路，则俱乐部 $c$ 会参加比赛；否则，俱乐部 $c$ 不会参加比赛。出于组织原因，**Sphinny** 需要每场比赛参加的俱乐部数量为奇数。\n\n给定 **Sphinny** 所在城市的公交线路布局和比赛详情，计算有多少场比赛存在一条路径，使得参加的俱乐部数量为奇数。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。\n\n每个测试用例的第一行包含三个整数 $\\mathbf{N}$、$\\mathbf{M}$ 和 $\\mathbf{Q}$，分别表示公交站点的数量、公交线路的数量和比赛的数量。\n\n接下来是 $\\mathbf{M}$ 行，每行表示一条公交线路。第 $i$ 行包含三个整数 $\\mathbf{U}_i$、$\\mathbf{V}_i$ 和 $\\mathbf{K}_i$，表示第 $i$ 条公交线路连接公交站点 $\\mathbf{U}_i$ 和 $\\mathbf{V}_i$，且其司机为俱乐部 $\\mathbf{K}_i$ 加油。\n\n最后是 $\\mathbf{Q}$ 行，每行表示一场比赛。第 $j$ 行包含两个整数 $\\mathbf{P}_j$ 和 $\\mathbf{C}_j$，表示第 $j$ 场比赛的材料需要在公交站点 $\\mathbf{P}_j$ 取，并在公交站点 $\\mathbf{C}_j$ 举办比赛。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是满足条件的比赛数量。\n", "hint": "**样例解释**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/axkzo8s5.png)\n\n样例 #1 如上图所示。在前两场比赛中，无论选择哪条路径，两个俱乐部（绿色和蓝色）都必须参加。对于最后一场比赛，可以通过路径 $1, 2, 4, 5$ 仅让绿色俱乐部参加。\n\n对于样例 #2，第一场比赛无法进行，因为没有从公交站点 $1$ 到 $2$ 的路径。第二场比赛有一条路径包含从公交站点 $1$ 到 $3$ 的唯一公交线路，因此恰好有 $1$ 个俱乐部参加，这是一个可接受的奇数。\n\n以下附加样例（样例组 #2）符合测试集 2 的限制，但不会用于测试您的提交。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ycyh0jsk.png)\n\n此附加样例如上图所示。在这种情况下，两场比赛均可通过奇数个俱乐部完成。图中展示了一条满足条件的路径。\n\n**限制**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i$，$1 \\leq \\mathbf{U}_i \\leq \\mathbf{N}$。\n- 对于所有 $i$，$1 \\leq \\mathbf{V}_i \\leq \\mathbf{N}$。\n- 对于所有 $i$，$\\mathbf{U}_i \\neq \\mathbf{V}_i$。\n- 对于所有 $i \\neq j$，$(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{U}_j, \\mathbf{V}_j)$ 且 $(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{V}_j, \\mathbf{U}_j)$。（没有两条公交线路具有相同的端点对。）\n- 对于所有 $j$，$1 \\leq \\mathbf{P}_j \\leq \\mathbf{N}$。\n- 对于所有 $j$，$1 \\leq \\mathbf{C}_j \\leq \\mathbf{N}$。\n- 对于所有 $j$，$\\mathbf{P}_j \\neq \\mathbf{C}_j$。\n\n**测试集 1（7 分，可见评测结果）**\n\n- 时间限制：20 秒。\n- $2 \\leq \\mathbf{N} \\leq 500$。\n- $1 \\leq \\mathbf{M} \\leq 500$。\n- $1 \\leq \\mathbf{Q} \\leq 500$。\n- 对于所有 $j$，$1 \\leq \\mathbf{K}_j \\leq 2$。\n\n**测试集 2（6 分，可见评测结果）**\n\n- 时间限制：40 秒。\n- $2 \\leq \\mathbf{N} \\leq 500$。\n- $1 \\leq \\mathbf{M} \\leq 500$。\n- $1 \\leq \\mathbf{Q} \\leq 500$。\n- 对于所有 $j$，$1 \\leq \\mathbf{K}_j \\leq 100$。\n\n**测试集 3（10 分，隐藏评测结果）**\n\n- 时间限制：120 秒。\n- $2 \\leq \\mathbf{N} \\leq 10000$。\n- $1 \\leq \\mathbf{M} \\leq 10000$。\n- $1 \\leq \\mathbf{Q} \\leq 10000$。\n- 对于所有 $j$，$1 \\leq \\mathbf{K}_j \\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12960", "type": "P", "difficulty": 7, "samples": [["3\n3 CODEJAM\n2 ABABABABAAAA\n3 AABBCDEEFGHIJJKLMNOPQRRSTUVWXYZZ", "Case #1: POSSIBLE\nC O DEJAM\nCase #2: POSSIBLE\nABABABABA AAA\nCase #3: IMPOSSIBLE"]], "limits": {"time": [40000, 40000, 40000], "memory": [2097152, 2097152, 2097152]}, "tags": ["贪心", "2023", "Special Judge", "构造", "Google Code Jam"], "title": "[GCJ Farewell Round #3] Game Sort: Part 2", "background": "", "description": "Note: The main parts of the statements of the problems \"Game Sort: Part 1\" and \"Game Sort: Part 2\" are identical, except for the last paragraph. The problems can otherwise be solved independently.\n\nAmir and Badari are playing a sorting game. The game starts with a string $\\mathbf{S}$ and an integer $\\mathbf{P}$ being chosen by an impartial judge. Then, Amir has to split $\\mathbf{S}$ into exactly $\\mathbf{P}$ contiguous non-empty parts (substrings). For example, if $\\mathbf{S} = \\text{CODEJAM}$ was the chosen string and $\\mathbf{P} = 3$, Amir could split it up as $[\\text{COD}, \\text{EJA}, \\text{M}]$ or as $[\\text{CO}, \\text{D}, \\text{EJAM}]$, but not as $[\\text{COD}, \\text{EJAM}]$, $[\\text{COD}, \\text{JA}, \\text{M}]$, $[\\text{EJA}, \\text{COD}, \\text{M}]$, nor as $[\\text{CODE}, \\text{EJA}, \\text{M}]$.\n\nThen, Badari must rearrange the letters within each part to make the list of parts be sorted in non-decreasing lexicographical order. If she can, then she wins. Otherwise, Amir wins.\n\nGiven the initial string and number of parts, can you help Amir win the game by choosing his parts in a way Badari cannot win herself? If not, say that it is not possible.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow, each describing a single test case containing an integer $\\mathbf{P}$ and a string $\\mathbf{S}$, the number of parts and string to be partitioned, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either `POSSIBLE` if Amir can win the game, or `IMPOSSIBLE` if he cannot. If he can win the game, output a second line containing $t_1 t_2 \\ldots t_p$ where $t_i$ is the $i$-th part of the winning partition you found for Amir. If there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is no way for Badari to rearrange $\\text{DEJAM}$ to be lexicographically after $\\text{O}$, so Amir guaranteed a win.\n\nIn Sample Case #2, $\\text{AAA}$ is guaranteed to be earlier than any rearrangement of a string containing more than 3 letters, so Amir also wins.\n\nIn Sample Case #3, all possible partitions result in a list of parts that is already sorted in lexicographical order, so Amir cannot possibly win.\n\n**Limits**\n\n$1 \\leq \\mathbf{T} \\leq 100$.\n\nEach character of $\\mathbf{S}$ is an English uppercase letter A through Z.\n\n**Test Set 1 (8 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{P} \\leq 3$.\n- $\\mathbf{P} \\leq \\text{the length of } \\mathbf{S} \\leq 100$.\n\n**Test Set 2 (20 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{P} \\leq 100$.\n- $\\mathbf{P} \\leq \\text{the length of } \\mathbf{S} \\leq 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #3] Game Sort: Part 2", "background": "", "description": "Note: The main parts of the statements of the problems \"Game Sort: Part 1\" and \"Game Sort: Part 2\" are identical, except for the last paragraph. The problems can otherwise be solved independently.\n\nAmir and Badari are playing a sorting game. The game starts with a string $\\mathbf{S}$ and an integer $\\mathbf{P}$ being chosen by an impartial judge. Then, Amir has to split $\\mathbf{S}$ into exactly $\\mathbf{P}$ contiguous non-empty parts (substrings). For example, if $\\mathbf{S} = \\text{CODEJAM}$ was the chosen string and $\\mathbf{P} = 3$, Amir could split it up as $[\\text{COD}, \\text{EJA}, \\text{M}]$ or as $[\\text{CO}, \\text{D}, \\text{EJAM}]$, but not as $[\\text{COD}, \\text{EJAM}]$, $[\\text{COD}, \\text{JA}, \\text{M}]$, $[\\text{EJA}, \\text{COD}, \\text{M}]$, nor as $[\\text{CODE}, \\text{EJA}, \\text{M}]$.\n\nThen, Badari must rearrange the letters within each part to make the list of parts be sorted in non-decreasing lexicographical order. If she can, then she wins. Otherwise, Amir wins.\n\nGiven the initial string and number of parts, can you help Amir win the game by choosing his parts in a way Badari cannot win herself? If not, say that it is not possible.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow, each describing a single test case containing an integer $\\mathbf{P}$ and a string $\\mathbf{S}$, the number of parts and string to be partitioned, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either `POSSIBLE` if Amir can win the game, or `IMPOSSIBLE` if he cannot. If he can win the game, output a second line containing $t_1 t_2 \\ldots t_p$ where $t_i$ is the $i$-th part of the winning partition you found for Amir. If there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is no way for Badari to rearrange $\\text{DEJAM}$ to be lexicographically after $\\text{O}$, so Amir guaranteed a win.\n\nIn Sample Case #2, $\\text{AAA}$ is guaranteed to be earlier than any rearrangement of a string containing more than 3 letters, so Amir also wins.\n\nIn Sample Case #3, all possible partitions result in a list of parts that is already sorted in lexicographical order, so Amir cannot possibly win.\n\n**Limits**\n\n$1 \\leq \\mathbf{T} \\leq 100$.\n\nEach character of $\\mathbf{S}$ is an English uppercase letter A through Z.\n\n**Test Set 1 (8 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{P} \\leq 3$.\n- $\\mathbf{P} \\leq \\text{the length of } \\mathbf{S} \\leq 100$.\n\n**Test Set 2 (20 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{P} \\leq 100$.\n- $\\mathbf{P} \\leq \\text{the length of } \\mathbf{S} \\leq 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #3] Game Sort: Part 2", "background": "", "description": "注意：问题 **Game Sort: Part 1** 和 **Game Sort: Part 2** 的题目描述主要部分相同，仅最后一段不同。这两个问题可以独立解决。\n\n**Amir** 和 **Badari** 正在玩一个排序游戏。游戏开始时，一位公正的裁判会选择一个字符串 $\\mathbf{S}$ 和一个整数 $\\mathbf{P}$。然后，**Amir** 需要将 $\\mathbf{S}$ 分割成恰好 $\\mathbf{P}$ 个连续的非空部分（子字符串）。例如，如果选中的字符串是 $\\mathbf{S} = \\text{CODEJAM}$ 且 $\\mathbf{P} = 3$，**Amir** 可以将其分割为 $[\\text{COD}, \\text{EJA}, \\text{M}]$ 或 $[\\text{CO}, \\text{D}, \\text{EJAM}]$，但不能分割为 $[\\text{COD}, \\text{EJAM}]$、$[\\text{COD}, \\text{JA}, \\text{M}]$、$[\\text{EJA}, \\text{COD}, \\text{M}]$ 或 $[\\text{CODE}, \\text{EJA}, \\text{M}]$。\n\n接着，**Badari** 必须重新排列每个部分的字母，使得这些部分按字典序非递减顺序排列。如果她能成功，则她获胜；否则，**Amir** 获胜。\n\n给定初始字符串和分割数量，你能帮助 **Amir** 通过选择一种 **Badari** 无法获胜的分割方式来赢得游戏吗？如果不可能，请说明无法实现。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 行，每行描述一个测试用例，包含一个整数 $\\mathbf{P}$ 和一个字符串 $\\mathbf{S}$，分别表示分割数量和待分割的字符串。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 `POSSIBLE`（如果 **Amir** 可以赢得游戏）或 `IMPOSSIBLE`（如果他不能）。如果可以赢得游戏，则额外输出一行，包含 $t_1 t_2 \\ldots t_p$，其中 $t_i$ 是你为 **Amir** 找到的获胜分割的第 $i$ 部分。如果有多种解，可以输出其中任意一种。\n", "hint": "**样例解释**\n\n在样例 #1 中，**Badari** 无法将 $\\text{DEJAM}$ 重新排列为字典序大于 $\\text{O}$ 的字符串，因此 **Amir** 确保了胜利。\n\n在样例 #2 中，$\\text{AAA}$ 的字典序必然小于任何包含超过 3 个字母的字符串的重排结果，因此 **Amir** 也获胜。\n\n在样例 #3 中，所有可能的分割方式都会使得部分列表已经按字典序排列，因此 **Amir** 无法获胜。\n\n**限制**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $\\mathbf{S}$ 的每个字符均为大写字母 A 到 Z。\n\n**测试集 1（8 分，可见评测结果）**\n\n- $2 \\leq \\mathbf{P} \\leq 3$。\n- $\\mathbf{P} \\leq \\mathbf{S} \\text{ 的长度} \\leq 100$。\n\n**测试集 2（20 分，隐藏评测结果）**\n\n- $2 \\leq \\mathbf{P} \\leq 100$。\n- $\\mathbf{P} \\leq \\mathbf{S} \\text{ 的长度} \\leq 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12961", "type": "P", "difficulty": 5, "samples": [["3\n2 3 2\n2\n3 3\n1 1\n2 3\n3 4 2\n2 3\n3 3 4\n1 3\n1 2\n3 4 1\n2 3\n3 3 4\n2 2", "Case #1: 2.0 1.8\nCase #2: 2.19047619 2.47619048\nCase #3: 2.2857142857"]], "limits": {"time": [20000, 20000, 40000], "memory": [2097152, 2097152, 2097152]}, "tags": ["2023", "Special Judge", "树形 DP", "Google Code Jam"], "title": "[GCJ Farewell Round #4] Indispensable Overpass", "background": "", "description": "A modern railroad system built in Ekiya's town bumped into a major hurdle: the main freeway running north to south. $\\mathbf{W}$ stations have already been built and connected on the western side of the freeway and $\\mathbf{E}$ on the eastern side. One more connection is needed between a western and an eastern station, but because the freeway is in the way, that connection needs to be built using an overpass.\n\nEkiya is assessing which stations would be most convenient to connect with the overpass. As part of that assessment, she wants to know how the average length (in number of stations) of a path within the system might change with each possible option.\n\nA path between stations $s$ and $t$ is a list of distinct stations that starts with $s$, ends with $t$, and such that any two consecutive stations on the list share a connection. The railroad system currently has $\\mathbf{W}$ stations on the western side, connected through $\\mathbf{W}-1$ connections such that there is exactly one path between any two distinct western stations. Similarly, there are $\\mathbf{E}$ eastern stations connected through $\\mathbf{E}-1$ connections such that there is exactly one path between any two distinct eastern stations. After the overpass connection is built connecting one western and one eastern station, there will be exactly one path between any two distinct stations.\n\nA complete map is a map that has $\\mathbf{W}+\\mathbf{E}-1$ total connections and exactly one path between any pair of stations. The average distance of a complete map is the average of the length of paths between all pairs of different stations. The length of a path is one less than the length of the list of stations that defines it (e.g., the path between directly connected stations has a length of 1).\n\nAs an example, the picture below illustrates a scenario with $\\mathbf{W}=2$ stations on the west side and $\\mathbf{E}=3$ stations on the east side. There are 2 possible overpasses shown.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7o2t0xms.png)\n\nThis table shows the lengths of the paths between pairs of stations if each overpass were to be built.\n\n| West 1 | West 2 | 1 ↔ 1 | 2 ↔ 3 |\n| :---: | :---: | :---: | :---: |\n| West 1 | East 1 | 1 | 3 |\n| West 1 | East 2 | 3 | 3 |\n| West 1 | East 3 | 2 | 2 |\n| West 2 | East 1 | 2 | 2 |\n| West 2 | East 2 | 4 | 2 |\n| West 2 | East 3 | 3 | 1 |\n| East 1 | East 2 | 2 | 2 |\n| East 1 | East 3 | 1 | 1 |\n| East 2 | East 3 | 1 | 1 |\n|  | Average: | 2 | 1.8 |\n\nGiven the current stations and connections, and a list of options for the overpass connection, help Ekiya by calculating the average distance of the map that would result if that option was the only overpass connection built.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line with three integers $\\mathbf{W}$, $\\mathbf{E}$, and $\\mathbf{C}$, the number of western and eastern stations, and the number of options for the overpass connection, respectively. Western stations are numbered between $1$ and $\\mathbf{W}$ and eastern connections are numbered between $1$ and $\\mathbf{E}$.\n\nThe second line of a test case contains $\\mathbf{W}-1$ integers $\\mathbf{X}_1$, $\\mathbf{X}_2$, $\\ldots$, $\\mathbf{X}_{\\mathbf{W}-1}$ representing that the $i$-th existing connection among western stations connects western stations $i$ and $\\mathbf{X}_i$.\n\nThe third line of a test case contains $\\mathbf{E}-1$ integers $\\mathbf{F}_1$, $\\mathbf{F}_2$, $\\ldots$, $\\mathbf{F}_{\\mathbf{E}-1}$ representing that the $j$-th existing connection among eastern stations connects eastern stations $j$ and $\\mathbf{F}_j$.\n\nFinally, the last $\\mathbf{C}$ lines of a test case describe the options for the overpass connection. The $k$-th of these lines contains two integers $\\mathbf{A}_k$ and $\\mathbf{B}_k$ representing the western and eastern stations, respectively, that the $k$-th option for an overpass connection would connect.", "outputFormat": "For each test case, output one line containing `Case #x:` $y_1$ $y_2$ $\\cdots$ $y_{\\mathbf{C}}$, where $x$ is the test case number (starting from $1$) and $y_k$ is the average distance of the map resulting in adding the $k$-th option as an overpass connection to all existing connections.\n\n$y_1$, $y_2$, $\\ldots$ and $y_k$ will be considered correct if they are within an absolute or relative error of $10^{-6}$ of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explanation**\n\nSample Case #1 is explained and illustrated in the problem statement. Sample Case #2 and Sample Case #3 are illustrated below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5w12npwf.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{W} \\leq 10^{5}$.\n- $2 \\leq \\mathbf{E} \\leq 10^{5}$.\n- $i+1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{W}$, for all $i$. (This implies that there is exactly one path between each pair of western stations.)\n- $j+1 \\leq \\mathbf{F}_{j} \\leq \\mathbf{E}$, for all $j$. (This implies that there is exactly one path between each pair of eastern stations.)\n- $1 \\leq \\mathbf{A}_{k} \\leq \\mathbf{W}$, for all $k$.\n- $1 \\leq \\mathbf{B}_{k} \\leq \\mathbf{E}$, for all $k$.\n- $(\\mathbf{A}_{k}, \\mathbf{B}_{k}) \\neq (\\mathbf{A}_{\\ell}, \\mathbf{B}_{\\ell})$, for all $k \\neq \\ell$. (Each listed overpass connection is different.)\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $1 \\leq \\mathbf{C} \\leq 2$.\n\n**Test Set 2 (7 Pts, Hidden Verdict)**\n\n- Time limit: 40 seconds.\n- $1 \\leq \\mathbf{C} \\leq 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #4] Indispensable Overpass", "background": "", "description": "A modern railroad system built in Ekiya's town bumped into a major hurdle: the main freeway running north to south. $\\mathbf{W}$ stations have already been built and connected on the western side of the freeway and $\\mathbf{E}$ on the eastern side. One more connection is needed between a western and an eastern station, but because the freeway is in the way, that connection needs to be built using an overpass.\n\nEkiya is assessing which stations would be most convenient to connect with the overpass. As part of that assessment, she wants to know how the average length (in number of stations) of a path within the system might change with each possible option.\n\nA path between stations $s$ and $t$ is a list of distinct stations that starts with $s$, ends with $t$, and such that any two consecutive stations on the list share a connection. The railroad system currently has $\\mathbf{W}$ stations on the western side, connected through $\\mathbf{W}-1$ connections such that there is exactly one path between any two distinct western stations. Similarly, there are $\\mathbf{E}$ eastern stations connected through $\\mathbf{E}-1$ connections such that there is exactly one path between any two distinct eastern stations. After the overpass connection is built connecting one western and one eastern station, there will be exactly one path between any two distinct stations.\n\nA complete map is a map that has $\\mathbf{W}+\\mathbf{E}-1$ total connections and exactly one path between any pair of stations. The average distance of a complete map is the average of the length of paths between all pairs of different stations. The length of a path is one less than the length of the list of stations that defines it (e.g., the path between directly connected stations has a length of 1).\n\nAs an example, the picture below illustrates a scenario with $\\mathbf{W}=2$ stations on the west side and $\\mathbf{E}=3$ stations on the east side. There are 2 possible overpasses shown.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7o2t0xms.png)\n\nThis table shows the lengths of the paths between pairs of stations if each overpass were to be built.\n\n| West 1 | West 2 | 1 ↔ 1 | 2 ↔ 3 |\n| :---: | :---: | :---: | :---: |\n| West 1 | East 1 | 1 | 3 |\n| West 1 | East 2 | 3 | 3 |\n| West 1 | East 3 | 2 | 2 |\n| West 2 | East 1 | 2 | 2 |\n| West 2 | East 2 | 4 | 2 |\n| West 2 | East 3 | 3 | 1 |\n| East 1 | East 2 | 2 | 2 |\n| East 1 | East 3 | 1 | 1 |\n| East 2 | East 3 | 1 | 1 |\n|  | Average: | 2 | 1.8 |\n\nGiven the current stations and connections, and a list of options for the overpass connection, help Ekiya by calculating the average distance of the map that would result if that option was the only overpass connection built.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line with three integers $\\mathbf{W}$, $\\mathbf{E}$, and $\\mathbf{C}$, the number of western and eastern stations, and the number of options for the overpass connection, respectively. Western stations are numbered between $1$ and $\\mathbf{W}$ and eastern connections are numbered between $1$ and $\\mathbf{E}$.\n\nThe second line of a test case contains $\\mathbf{W}-1$ integers $\\mathbf{X}_1$, $\\mathbf{X}_2$, $\\ldots$, $\\mathbf{X}_{\\mathbf{W}-1}$ representing that the $i$-th existing connection among western stations connects western stations $i$ and $\\mathbf{X}_i$.\n\nThe third line of a test case contains $\\mathbf{E}-1$ integers $\\mathbf{F}_1$, $\\mathbf{F}_2$, $\\ldots$, $\\mathbf{F}_{\\mathbf{E}-1}$ representing that the $j$-th existing connection among eastern stations connects eastern stations $j$ and $\\mathbf{F}_j$.\n\nFinally, the last $\\mathbf{C}$ lines of a test case describe the options for the overpass connection. The $k$-th of these lines contains two integers $\\mathbf{A}_k$ and $\\mathbf{B}_k$ representing the western and eastern stations, respectively, that the $k$-th option for an overpass connection would connect.", "outputFormat": "For each test case, output one line containing `Case #x:` $y_1$ $y_2$ $\\cdots$ $y_{\\mathbf{C}}$, where $x$ is the test case number (starting from $1$) and $y_k$ is the average distance of the map resulting in adding the $k$-th option as an overpass connection to all existing connections.\n\n$y_1$, $y_2$, $\\ldots$ and $y_k$ will be considered correct if they are within an absolute or relative error of $10^{-6}$ of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explanation**\n\nSample Case #1 is explained and illustrated in the problem statement. Sample Case #2 and Sample Case #3 are illustrated below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5w12npwf.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{W} \\leq 10^{5}$.\n- $2 \\leq \\mathbf{E} \\leq 10^{5}$.\n- $i+1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{W}$, for all $i$. (This implies that there is exactly one path between each pair of western stations.)\n- $j+1 \\leq \\mathbf{F}_{j} \\leq \\mathbf{E}$, for all $j$. (This implies that there is exactly one path between each pair of eastern stations.)\n- $1 \\leq \\mathbf{A}_{k} \\leq \\mathbf{W}$, for all $k$.\n- $1 \\leq \\mathbf{B}_{k} \\leq \\mathbf{E}$, for all $k$.\n- $(\\mathbf{A}_{k}, \\mathbf{B}_{k}) \\neq (\\mathbf{A}_{\\ell}, \\mathbf{B}_{\\ell})$, for all $k \\neq \\ell$. (Each listed overpass connection is different.)\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $1 \\leq \\mathbf{C} \\leq 2$.\n\n**Test Set 2 (7 Pts, Hidden Verdict)**\n\n- Time limit: 40 seconds.\n- $1 \\leq \\mathbf{C} \\leq 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #4] Indispensable Overpass", "background": null, "description": "Ekiya 所在城镇新建的现代铁路系统遇到了一个主要障碍：一条贯穿南北的高速公路。高速公路西侧已经建造并连接了 $\\mathbf{W}$ 个车站，东侧则有 $\\mathbf{E}$ 个车站。现在需要在西侧和东侧车站之间再建立一条连接，但由于高速公路的阻隔，这条连接必须通过一座立交桥来实现。\n\nEkiya 正在评估哪些车站组合最适合通过立交桥连接。作为评估的一部分，她想知道系统内路径的平均长度（以车站数量计）会如何随每种可能的连接方案而变化。\n\n车站 $s$ 和 $t$ 之间的路径是指一个由不同车站组成的列表，该列表以 $s$ 开头、以 $t$ 结尾，且列表中任意两个连续车站之间存在连接。当前铁路系统中，西侧的 $\\mathbf{W}$ 个车站通过 $\\mathbf{W}-1$ 条连接构成，使得任意两个不同的西侧车站之间恰好存在一条路径。类似地，东侧的 $\\mathbf{E}$ 个车站通过 $\\mathbf{E}-1$ 条连接构成，使得任意两个不同的东侧车站之间也恰好存在一条路径。在建立连接一个西侧车站和一个东侧车站的立交桥后，任意两个不同车站之间将恰好存在一条路径。\n\n一个完整地图是指具有 $\\mathbf{W}+\\mathbf{E}-1$ 条总连接，且任意两个车站之间恰好存在一条路径的地图。完整地图的平均距离是指所有不同车站对之间路径长度的平均值。路径长度是指定义该路径的车站列表长度减 1（例如，直接连接的两个车站之间的路径长度为 1）。\n\n举例说明，下图展示了 $\\mathbf{W}=2$ 个西侧车站和 $\\mathbf{E}=3$ 个东侧车站的场景，图中显示了 2 种可能的立交桥方案。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7o2t0xms.png)\n\n下表展示了每种立交桥方案下各车站对之间的路径长度。\n\n| 起点 | 终点 | 1 ↔ 1 | 2 ↔ 3 |\n| :---: | :---: | :---: | :---: |\n| 西 1 | 西 2 | 1 | 1 |\n| 西 1 | 东 1 | 1 | 3 |\n| 西 1 | 东 2 | 3 | 3 |\n| 西 1 | 东 3 | 2 | 2 |\n| 西 2 | 东 1 | 2 | 2 |\n| 西 2 | 东 2 | 4 | 2 |\n| 西 2 | 东 3 | 3 | 1 |\n| 东 1 | 东 2 | 2 | 2 |\n| 东 1 | 东 3 | 1 | 1 |\n| 东 2 | 东 3 | 1 | 1 |\n|  | 平均值： | 2 | 1.8 |\n\n给定当前的车站和连接情况，以及立交桥连接方案的列表，请帮助 Ekiya 计算每种方案作为唯一立交桥连接时，所形成地图的平均距离。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含三个整数 $\\mathbf{W}$、$\\mathbf{E}$ 和 $\\mathbf{C}$，分别表示西侧和东侧车站的数量，以及立交桥连接方案的数量。西侧车站编号为 $1$ 到 $\\mathbf{W}$，东侧车站编号为 $1$ 到 $\\mathbf{E}$。\n\n测试用例的第二行包含 $\\mathbf{W}-1$ 个整数 $\\mathbf{X}_1, \\mathbf{X}_2, \\ldots, \\mathbf{X}_{\\mathbf{W}-1}$，表示西侧车站的第 $i$ 条现有连接连接了西侧车站 $i$ 和 $\\mathbf{X}_i$。\n\n测试用例的第三行包含 $\\mathbf{E}-1$ 个整数 $\\mathbf{F}_1, \\mathbf{F}_2, \\ldots, \\mathbf{F}_{\\mathbf{E}-1}$，表示东侧车站的第 $j$ 条现有连接连接了东侧车站 $j$ 和 $\\mathbf{F}_j$。\n\n最后，测试用例的最后 $\\mathbf{C}$ 行描述了立交桥连接方案。其中第 $k$ 行包含两个整数 $\\mathbf{A}_k$ 和 $\\mathbf{B}_k$，表示第 $k$ 种立交桥方案将连接的西侧和东侧车站。", "outputFormat": "对于每个测试用例，输出一行 `Case #x:` $y_1$ $y_2$ $\\cdots$ $y_{\\mathbf{C}}$，其中 $x$ 是测试用例编号（从 $1$ 开始），$y_k$ 表示添加第 $k$ 种立交桥方案后所形成地图的平均距离。\n\n$y_1$, $y_2$, $\\ldots$, $y_k$ 只要与正确答案的绝对误差或相对误差不超过 $10^{-6}$ 即视为正确。有关误差说明及可接受的实数格式，请参阅 FAQ。", "hint": "**样例解释**\n\n样例 #1 已在题目描述中解释并图示。样例 #2 和样例 #3 图示如下。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5w12npwf.png)\n\n**限制**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{W} \\leq 10^{5}$。\n- $2 \\leq \\mathbf{E} \\leq 10^{5}$。\n- 对所有 $i$，$i+1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{W}$。（这意味着任意两个西侧车站之间恰好存在一条路径。）\n- 对所有 $j$，$j+1 \\leq \\mathbf{F}_{j} \\leq \\mathbf{E}$。（这意味着任意两个东侧车站之间恰好存在一条路径。）\n- 对所有 $k$，$1 \\leq \\mathbf{A}_{k} \\leq \\mathbf{W}$。\n- 对所有 $k$，$1 \\leq \\mathbf{B}_{k} \\leq \\mathbf{E}$。\n- 对所有 $k \\neq \\ell$，$(\\mathbf{A}_{k}, \\mathbf{B}_{k}) \\neq (\\mathbf{A}_{\\ell}, \\mathbf{B}_{\\ell})$。（列出的每种立交桥连接方案均不相同。）\n\n**测试集 1（5 分，可见评测结果）**\n\n- 时间限制：20 秒。\n- $1 \\leq \\mathbf{C} \\leq 2$。\n\n**测试集 2（7 分，隐藏评测结果）**\n\n- 时间限制：40 秒。\n- $1 \\leq \\mathbf{C} \\leq 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12962", "type": "P", "difficulty": 6, "samples": [["3\nABCABAC CABABA 3\n3 6\n7 6\n6 5\nBANANA HABANA 2\n5 4\n5 5\nABC ABD 1\n2 1", "Case #1: 1 4 3\nCase #2: 4 1\nCase #3: 0"]], "limits": {"time": [20000, 20000, 20000], "memory": [2097152, 2097152, 2097152]}, "tags": ["2023", "后缀自动机 SAM", "ST 表", "后缀数组 SA", "Google Code Jam"], "title": "[GCJ Farewell Round #4] Genetic Sequences", "background": "", "description": "Margaret researches genetic sequences. She is analysing two sequences $\\mathbf{A}$ and $\\mathbf{B}$ from a new kind of life that does not use the typical four letter genetic alphabet. The code for the genetic sequences conveniently requires 26 letters represented by the uppercase English letters 'A' through 'Z'.\n\nMargaret wants to compare the sequences $\\mathbf{A}$ and $\\mathbf{B}$. The best way to do this is to do a series of sequence analysis tests. Each test involves taking a prefix from $\\mathbf{A}$ containing only the first $\\mathbf{P}$ letters from $\\mathbf{A}$, which is called the $\\mathbf{A}$-prefix. Each test also involves taking a suffix from $\\mathbf{B}$ containing only the last $\\mathbf{S}$ letters from $\\mathbf{B}$, which is called the $\\mathbf{B}$-suffix. Margaret then needs to compare the $\\mathbf{A}$-prefix to the $\\mathbf{B}$-suffix. A substring is a subsequence of contiguous letters. A substring from the $\\mathbf{A}$-prefix matches the $\\mathbf{B}$-suffix if the $\\mathbf{B}$-suffix starts with that substring. That is, the substring is a prefix of the $\\mathbf{B}$-suffix. The result of a test is the length of the longest substring from the $\\mathbf{A}$-prefix that matches the $\\mathbf{B}$-suffix.\n\nMargaret needs some software to determine the outcome of a batch of $\\mathbf{Q}$ sequence analysis tests. Note that each test is independent. Margaret has many copies of $\\mathbf{A}$ and $\\mathbf{B}$ and a new one is used for each test.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case begins with a line containing two strings and an integer, $\\mathbf{A}$, $\\mathbf{B}$, and $\\mathbf{Q}$ respectively. Each test case ends with $\\mathbf{Q}$ lines, the $i$-th of which contains two integers $\\mathbf{P}_i$ and $\\mathbf{S}_i$, which are the prefix and suffix sizes for the $i$-th sequence analysis test.\n", "outputFormat": "For each test case, output one line containing Case #$x$: $y_1$ $y_2$ $\\ldots$ $y_{\\mathbf{Q}}$, where $x$ is the test case number (starting from 1) and $y_i$ is the answer to the $i$-th query in the input.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 3 tests. The prefix $\\mathbf{A B C}$ from $\\mathbf{A}$ and the complete suffix $\\mathbf{C A B A B A}$ from $\\mathbf{B}$ are compared in the first test. The answer is 1, since $\\mathbf{c}$ is the longest substring that is contained in $\\mathbf{A B C}$ and is a prefix of $\\mathbf{C A B A B A}$. In the second test, $\\mathbf{A B C A B A C}$ is tested against $\\mathbf{C A B A B A}$ and the longest match is $\\mathbf{C A B A}$. In the third test, $\\mathbf{A B C A B A}$ is tested against $\\mathbf{A B A B A}$ and the longest match is $\\mathbf{A B A}$.\n\nIn Sample Case #2, there are 2 tests. In the first, $\\mathbf{B A N A N}$ is tested against $\\mathbf{B A N A}$, and the longest match is $\\mathbf{B A N A}$. In the second, $\\mathbf{B A N A N}$ is tested against $\\mathbf{A B A N A}$, and the longest match is $\\mathbf{A}$.\n\nIn Sample Case #3, there is one test. In it, $\\mathbf{A B}$ is tested against $\\mathbf{d}$. Since there is no match the answer is 0.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{P}_{i} \\leq$ the length of $\\mathbf{A}$.\n- $1 \\leq \\mathbf{S}_{i} \\leq$ the length of $\\mathbf{B}$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{A} \\leq 3000$.\n- $1 \\leq$ the length of $\\mathbf{B} \\leq 3000$.\n- $1 \\leq \\mathbf{Q} \\leq 3000$.\n\n**Test Set 2 (17 Pts, Hidden Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{A} \\leq 10^{5}$.\n- $1 \\leq$ the length of $\\mathbf{B} \\leq 10^{5}$.\n- The sum of the lengths of $\\mathbf{A}$ over all test cases is $\\leq 5 \\times 10^{5}$\n- The sum of the lengths of $\\mathbf{B}$ over all test cases is $\\leq 5 \\times 10^{5}$\n- $1 \\leq \\mathbf{Q} \\leq 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #4] Genetic Sequences", "background": "", "description": "Margaret researches genetic sequences. She is analysing two sequences $\\mathbf{A}$ and $\\mathbf{B}$ from a new kind of life that does not use the typical four letter genetic alphabet. The code for the genetic sequences conveniently requires 26 letters represented by the uppercase English letters 'A' through 'Z'.\n\nMargaret wants to compare the sequences $\\mathbf{A}$ and $\\mathbf{B}$. The best way to do this is to do a series of sequence analysis tests. Each test involves taking a prefix from $\\mathbf{A}$ containing only the first $\\mathbf{P}$ letters from $\\mathbf{A}$, which is called the $\\mathbf{A}$-prefix. Each test also involves taking a suffix from $\\mathbf{B}$ containing only the last $\\mathbf{S}$ letters from $\\mathbf{B}$, which is called the $\\mathbf{B}$-suffix. Margaret then needs to compare the $\\mathbf{A}$-prefix to the $\\mathbf{B}$-suffix. A substring is a subsequence of contiguous letters. A substring from the $\\mathbf{A}$-prefix matches the $\\mathbf{B}$-suffix if the $\\mathbf{B}$-suffix starts with that substring. That is, the substring is a prefix of the $\\mathbf{B}$-suffix. The result of a test is the length of the longest substring from the $\\mathbf{A}$-prefix that matches the $\\mathbf{B}$-suffix.\n\nMargaret needs some software to determine the outcome of a batch of $\\mathbf{Q}$ sequence analysis tests. Note that each test is independent. Margaret has many copies of $\\mathbf{A}$ and $\\mathbf{B}$ and a new one is used for each test.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case begins with a line containing two strings and an integer, $\\mathbf{A}$, $\\mathbf{B}$, and $\\mathbf{Q}$ respectively. Each test case ends with $\\mathbf{Q}$ lines, the $i$-th of which contains two integers $\\mathbf{P}_i$ and $\\mathbf{S}_i$, which are the prefix and suffix sizes for the $i$-th sequence analysis test.\n", "outputFormat": "For each test case, output one line containing Case #$x$: $y_1$ $y_2$ $\\ldots$ $y_{\\mathbf{Q}}$, where $x$ is the test case number (starting from 1) and $y_i$ is the answer to the $i$-th query in the input.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 3 tests. The prefix $\\mathbf{A B C}$ from $\\mathbf{A}$ and the complete suffix $\\mathbf{C A B A B A}$ from $\\mathbf{B}$ are compared in the first test. The answer is 1, since $\\mathbf{c}$ is the longest substring that is contained in $\\mathbf{A B C}$ and is a prefix of $\\mathbf{C A B A B A}$. In the second test, $\\mathbf{A B C A B A C}$ is tested against $\\mathbf{C A B A B A}$ and the longest match is $\\mathbf{C A B A}$. In the third test, $\\mathbf{A B C A B A}$ is tested against $\\mathbf{A B A B A}$ and the longest match is $\\mathbf{A B A}$.\n\nIn Sample Case #2, there are 2 tests. In the first, $\\mathbf{B A N A N}$ is tested against $\\mathbf{B A N A}$, and the longest match is $\\mathbf{B A N A}$. In the second, $\\mathbf{B A N A N}$ is tested against $\\mathbf{A B A N A}$, and the longest match is $\\mathbf{A}$.\n\nIn Sample Case #3, there is one test. In it, $\\mathbf{A B}$ is tested against $\\mathbf{d}$. Since there is no match the answer is 0.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{P}_{i} \\leq$ the length of $\\mathbf{A}$.\n- $1 \\leq \\mathbf{S}_{i} \\leq$ the length of $\\mathbf{B}$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{A} \\leq 3000$.\n- $1 \\leq$ the length of $\\mathbf{B} \\leq 3000$.\n- $1 \\leq \\mathbf{Q} \\leq 3000$.\n\n**Test Set 2 (17 Pts, Hidden Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{A} \\leq 10^{5}$.\n- $1 \\leq$ the length of $\\mathbf{B} \\leq 10^{5}$.\n- The sum of the lengths of $\\mathbf{A}$ over all test cases is $\\leq 5 \\times 10^{5}$\n- The sum of the lengths of $\\mathbf{B}$ over all test cases is $\\leq 5 \\times 10^{5}$\n- $1 \\leq \\mathbf{Q} \\leq 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #4] Genetic Sequences", "background": "", "description": "Margaret 正在研究基因序列。她正在分析一种新型生命体的两个序列 $\\mathbf{A}$ 和 $\\mathbf{B}$，这种生命体不使用典型的四字母遗传密码。基因序列的编码方便地使用了 26 个大写英文字母 'A' 到 'Z' 来表示。\n\nMargaret 想要比较序列 $\\mathbf{A}$ 和 $\\mathbf{B}$。最佳方法是进行一系列序列分析测试。每个测试需要从 $\\mathbf{A}$ 中取出一个前缀（称为 $\\mathbf{A}$-前缀），包含 $\\mathbf{A}$ 的前 $\\mathbf{P}$ 个字母；同时从 $\\mathbf{B}$ 中取出一个后缀（称为 $\\mathbf{B}$-后缀），包含 $\\mathbf{B}$ 的最后 $\\mathbf{S}$ 个字母。然后 Margaret 需要比较 $\\mathbf{A}$-前缀和 $\\mathbf{B}$-后缀。子串是指连续的字母子序列。如果 $\\mathbf{B}$-后缀以某个 $\\mathbf{A}$-前缀的子串开头，即该子串是 $\\mathbf{B}$-后缀的前缀，则称该子串与 $\\mathbf{B}$-后缀匹配。测试的结果是 $\\mathbf{A}$-前缀中能与 $\\mathbf{B}$-后缀匹配的最长子串的长度。\n\nMargaret 需要一些软件来确定一批 $\\mathbf{Q}$ 个序列分析测试的结果。注意每个测试都是独立的。Margaret 有 $\\mathbf{A}$ 和 $\\mathbf{B}$ 的多个副本，每个测试都使用新的副本。\n", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含两个字符串和一个整数，分别是 $\\mathbf{A}$、$\\mathbf{B}$ 和 $\\mathbf{Q}$。每个测试用例的最后是 $\\mathbf{Q}$ 行，第 $i$ 行包含两个整数 $\\mathbf{P}_i$ 和 $\\mathbf{S}_i$，表示第 $i$ 个序列分析测试的前缀和后缀大小。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y1 y2 ... yQ`，其中 $x$ 是测试用例编号（从 1 开始），$y_i$ 是第 $i$ 个查询的答案。\n", "hint": "**样例解释**\n\n在样例 #1 中，有 3 个测试。第一个测试比较 $\\mathbf{A}$ 的前缀 $\\mathbf{A B C}$ 和 $\\mathbf{B}$ 的完整后缀 $\\mathbf{C A B A B A}$。答案是 1，因为 $\\mathbf{C}$ 是 $\\mathbf{A B C}$ 中包含的最长子串，且是 $\\mathbf{C A B A B A}$ 的前缀。第二个测试比较 $\\mathbf{A B C A B A C}$ 和 $\\mathbf{C A B A B A}$，最长匹配是 $\\mathbf{C A B A}$。第三个测试比较 $\\mathbf{A B C A B A}$ 和 $\\mathbf{A B A B A}$，最长匹配是 $\\mathbf{A B A}$。\n\n在样例 #2 中，有 2 个测试。第一个测试比较 $\\mathbf{B A N A N}$ 和 $\\mathbf{B A N A}$，最长匹配是 $\\mathbf{B A N A}$。第二个测试比较 $\\mathbf{B A N A N}$ 和 $\\mathbf{A B A N A}$，最长匹配是 $\\mathbf{A}$。\n\n在样例 #3 中，有一个测试。比较 $\\mathbf{A B}$ 和 $\\mathbf{D}$。由于没有匹配，答案是 0。\n\n**限制**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{P}_i \\leq \\mathbf{A}$ 的长度。\n- $1 \\leq \\mathbf{S}_i \\leq \\mathbf{B}$ 的长度。\n\n**测试集 1（5 分，可见评测结果）**\n\n- $1 \\leq \\mathbf{A}$ 的长度 $\\leq 3000$。\n- $1 \\leq \\mathbf{B}$ 的长度 $\\leq 3000$。\n- $1 \\leq \\mathbf{Q} \\leq 3000$。\n\n**测试集 2（17 分，隐藏评测结果）**\n\n- $1 \\leq \\mathbf{A}$ 的长度 $\\leq 10^5$。\n- $1 \\leq \\mathbf{B}$ 的长度 $\\leq 10^5$。\n- 所有测试用例中 $\\mathbf{A}$ 的长度总和 $\\leq 5 \\times 10^5$。\n- 所有测试用例中 $\\mathbf{B}$ 的长度总和 $\\leq 5 \\times 10^5$。\n- $1 \\leq \\mathbf{Q} \\leq 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12963", "type": "P", "difficulty": 7, "samples": [["4\n1 2\naZ\n4 4\na..c\n**.*\n.Y.#\nbX#Z\n2 2\na*\n*Z\n2 7\na*bcd*.\n...*F#.", "Case #1: aZ\nCase #2: aY bX bY cY\nCase #3: NONE\nCase #4: dF"]], "limits": {"time": [60000, 60000, 60000], "memory": [2097152, 2097152, 2097152]}, "tags": ["2023", "广度优先搜索 BFS", "Google Code Jam"], "title": "[GCJ Farewell Round #4] Hey Google, Drive!", "background": "", "description": "The Google Assistant and Android Auto teams are collaborating on a new prototype car that can be driven via voice commands. The early prototype works through a phone connected to a car simulator. Unfortunately, one of the early testers dropped their phone in the toilet, damaging the microphone and making it harder to use the new feature. Since they do not want to miss out on the opportunity, they want your help to use it anyway.\n\nThe early prototype moves on a simple grid of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns and only understands 4 very simple voice commands: north, south, east, and west. Each command makes the car try to move exactly one cell in the corresponding direction. Because of the microphone issues, however, the system may mishear and interchange north and south, and separately, east and west. That means that a command of north may make the car move north or south, a command of south may make the car move south or north, and similarly both commands east and west may make the car move east or west when issued. In all cases, both movement options can happen with equal probability $(1 / 2)$.\n\nThe tester set up a driving grid such that each cell can contain either a wall, a hazard, or be empty. If a command would make the car move into a wall, or outside the grid, it does nothing instead. If a command makes the car move into a hazard, the car cannot execute any more commands.\n\nThe tester has marked some empty cells of the grid as interesting starts and others as interesting finishes. A pair of an interesting start and an interesting finish is drivable if there is a strategy to drive the car through voice commands from the start that makes it end at the finish with probability at least $1-10^{-10^{100}}$. A strategy can choose which command to issue and when to stop depending on the outcome of the previous commands. Notice that if the car moves into a hazard it stops moving, so it cannot make it to the finish. The tester wants your help finding the list of all drivable pairs.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{R}$ and $\\mathbf{C}$, the number of rows and columns of the grid. Then, $\\mathbf{R}$ lines follow containing a string of $\\mathbf{C}$ characters each. The $j$-th character on the $i$-th of these lines $\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$ represents the grid in the $i$-th row and $j$-th column as follows:\n\n*   A period (. ) represents an uninteresting empty cell.\n*   A hash symbol (#) represents a cell containing a wall.\n*   An asterisk (*) represents a cell containing a hazard.\n*   An English lowercase letter (a through z) represents an empty cell that is an interesting start.\n*   An English uppercase letter (A through z) represents an empty cell that is an interesting finish.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is NONE if there are no drivable pairs. Otherwise, $y$ must be a series of 2 character strings separated by spaces, representing all drivable pairs with the start letter first and the finish letter second, in alphabetical order.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, simply repeating the west command until reaching the finish is a viable strategy. Each time there is a $1 / 2$ probability of reaching the finish and a $1 / 2$ probability of staying in the same place. Thus, the probability of not reaching the finish in $10^{101}$ or fewer steps is $2^{-10^{101}}<10^{-10^{100}}$.\n\nIn Sample Case #2 a similar strategy as in Sample Case #1 can be used to get the car from any position in the top row (1) to any other with probability as high as desired, and similarly for all non-wall positions in the third row from the top (2). Analogously, but using the south command, the car can move between non-wall positions on the third column from the left (3).\n\nFrom both a and c we can use (1) to get to the third column from the left, then (3) to get right next to $\\mathrm{Y}$ and then (2) to get to $\\mathrm{Y}$ making both $\\mathrm{aY}$ and $\\mathrm{cY}$ drivable. Notice, however, that safely using the north or south commands from the third row can only be done in the third column, or otherwise the car may go into a hazard. Therefore, there is no safe way to move the car from the third to the fourth row, making $\\mathrm{aX}$ and $\\mathrm{cX}$ not drivable.\n\nFrom $\\mathrm{b}$, however, the car can use a similar strategy to get to $\\mathrm{x}$, and from $\\mathrm{x}$ the car can get to $\\mathrm{Y}$ by using the north or south command repeatedly (and stop when reaching $\\mathrm{Y}$, never risking going into the hazard above).\n\nFinally, the finish $\\mathrm{z}$ is completely isolated, so it cannot be part of a drivable pair.\n\nIn Sample Case #3, every path from the interesting start to the interesting finish goes through a hazard, which makes the pair not drivable.\n\nIn Sample Case #4, only the interesting start $\\mathrm{d}$ has a viable strategy to get to the finish $\\mathrm{F}$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$ is either a period (.), a hash symbol (#), an asterisk (*) or a lowercase or uppercase English letter, for all $i, j$.\n- The set $\\left\\{\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}\\right.$ for all $\\left.i, j\\right\\}$ contains at least 1 lowercase and at least 1 uppercase English letter.\n- Each lowercase and uppercase letter appears at most once among all $\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{R} \\leq 20$.\n- $1 \\leq \\mathbf{C} \\leq 20$.\n\n**Test Set 2 (17 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{R} \\leq 100$.\n- $1 \\leq \\mathbf{C} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #4] Hey Google, Drive!", "background": "", "description": "The Google Assistant and Android Auto teams are collaborating on a new prototype car that can be driven via voice commands. The early prototype works through a phone connected to a car simulator. Unfortunately, one of the early testers dropped their phone in the toilet, damaging the microphone and making it harder to use the new feature. Since they do not want to miss out on the opportunity, they want your help to use it anyway.\n\nThe early prototype moves on a simple grid of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns and only understands 4 very simple voice commands: north, south, east, and west. Each command makes the car try to move exactly one cell in the corresponding direction. Because of the microphone issues, however, the system may mishear and interchange north and south, and separately, east and west. That means that a command of north may make the car move north or south, a command of south may make the car move south or north, and similarly both commands east and west may make the car move east or west when issued. In all cases, both movement options can happen with equal probability $(1 / 2)$.\n\nThe tester set up a driving grid such that each cell can contain either a wall, a hazard, or be empty. If a command would make the car move into a wall, or outside the grid, it does nothing instead. If a command makes the car move into a hazard, the car cannot execute any more commands.\n\nThe tester has marked some empty cells of the grid as interesting starts and others as interesting finishes. A pair of an interesting start and an interesting finish is drivable if there is a strategy to drive the car through voice commands from the start that makes it end at the finish with probability at least $1-10^{-10^{100}}$. A strategy can choose which command to issue and when to stop depending on the outcome of the previous commands. Notice that if the car moves into a hazard it stops moving, so it cannot make it to the finish. The tester wants your help finding the list of all drivable pairs.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{R}$ and $\\mathbf{C}$, the number of rows and columns of the grid. Then, $\\mathbf{R}$ lines follow containing a string of $\\mathbf{C}$ characters each. The $j$-th character on the $i$-th of these lines $\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$ represents the grid in the $i$-th row and $j$-th column as follows:\n\n*   A period (. ) represents an uninteresting empty cell.\n*   A hash symbol (#) represents a cell containing a wall.\n*   An asterisk (*) represents a cell containing a hazard.\n*   An English lowercase letter (a through z) represents an empty cell that is an interesting start.\n*   An English uppercase letter (A through z) represents an empty cell that is an interesting finish.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is NONE if there are no drivable pairs. Otherwise, $y$ must be a series of 2 character strings separated by spaces, representing all drivable pairs with the start letter first and the finish letter second, in alphabetical order.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, simply repeating the west command until reaching the finish is a viable strategy. Each time there is a $1 / 2$ probability of reaching the finish and a $1 / 2$ probability of staying in the same place. Thus, the probability of not reaching the finish in $10^{101}$ or fewer steps is $2^{-10^{101}}<10^{-10^{100}}$.\n\nIn Sample Case #2 a similar strategy as in Sample Case #1 can be used to get the car from any position in the top row (1) to any other with probability as high as desired, and similarly for all non-wall positions in the third row from the top (2). Analogously, but using the south command, the car can move between non-wall positions on the third column from the left (3).\n\nFrom both a and c we can use (1) to get to the third column from the left, then (3) to get right next to $\\mathrm{Y}$ and then (2) to get to $\\mathrm{Y}$ making both $\\mathrm{aY}$ and $\\mathrm{cY}$ drivable. Notice, however, that safely using the north or south commands from the third row can only be done in the third column, or otherwise the car may go into a hazard. Therefore, there is no safe way to move the car from the third to the fourth row, making $\\mathrm{aX}$ and $\\mathrm{cX}$ not drivable.\n\nFrom $\\mathrm{b}$, however, the car can use a similar strategy to get to $\\mathrm{x}$, and from $\\mathrm{x}$ the car can get to $\\mathrm{Y}$ by using the north or south command repeatedly (and stop when reaching $\\mathrm{Y}$, never risking going into the hazard above).\n\nFinally, the finish $\\mathrm{z}$ is completely isolated, so it cannot be part of a drivable pair.\n\nIn Sample Case #3, every path from the interesting start to the interesting finish goes through a hazard, which makes the pair not drivable.\n\nIn Sample Case #4, only the interesting start $\\mathrm{d}$ has a viable strategy to get to the finish $\\mathrm{F}$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$ is either a period (.), a hash symbol (#), an asterisk (*) or a lowercase or uppercase English letter, for all $i, j$.\n- The set $\\left\\{\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}\\right.$ for all $\\left.i, j\\right\\}$ contains at least 1 lowercase and at least 1 uppercase English letter.\n- Each lowercase and uppercase letter appears at most once among all $\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{R} \\leq 20$.\n- $1 \\leq \\mathbf{C} \\leq 20$.\n\n**Test Set 2 (17 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{R} \\leq 100$.\n- $1 \\leq \\mathbf{C} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #4] Hey Google, Drive!", "background": "", "description": "Google Assistant 和 Android Auto 团队正在合作开发一款可以通过语音命令驾驶的新型原型车。早期原型通过连接汽车模拟器的手机工作。不幸的是，一位早期测试者将手机掉进了马桶，导致麦克风损坏，使得新功能更难使用。由于他们不想错过这个机会，因此希望你能帮助他们继续使用。\n\n早期原型在一个简单的 $\\mathbf{R}$ 行 $\\mathbf{C}$ 列的网格上移动，仅能理解 4 个非常简单的语音命令：north（北）、south（南）、east（东）和 west（西）。每个命令会使汽车尝试向对应方向移动一格。但由于麦克风问题，系统可能会混淆 north 和 south，以及 east 和 west。这意味着 north 命令可能使汽车向北或向南移动，south 命令可能使汽车向南或向北移动，类似地，east 和 west 命令也可能使汽车向东或向西移动。在所有情况下，两种移动选项的概率均为 $(1 / 2)$。\n\n测试者设置了一个驾驶网格，每个单元格可以是墙壁、危险区域或空地。如果命令会使汽车移动到墙壁或网格外，则汽车不会移动。如果命令会使汽车移动到危险区域，则汽车无法执行更多命令。\n\n测试者将一些空单元格标记为有趣的起点，另一些标记为有趣的终点。如果一个有趣的起点和有趣的终点组成的配对满足：存在一种通过语音命令驾驶汽车从起点出发的策略，使得汽车以至少 $1-10^{-10^{100}}$ 的概率到达终点，则该配对是可驾驶的。策略可以根据之前命令的结果选择发出哪个命令以及何时停止。注意，如果汽车移动到危险区域，它将停止移动，因此无法到达终点。测试者希望你帮助找出所有可驾驶的配对。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含两个整数 $\\mathbf{R}$ 和 $\\mathbf{C}$，表示网格的行数和列数。接下来是 $\\mathbf{R}$ 行，每行包含一个长度为 $\\mathbf{C}$ 的字符串。第 $i$ 行的第 $j$ 个字符 $\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$ 表示网格的第 $i$ 行第 $j$ 列，具体如下：\n\n*   句点 (.) 表示不感兴趣的空单元格。\n*   井号 (#) 表示包含墙壁的单元格。\n*   星号 (*) 表示包含危险区域的单元格。\n*   小写英文字母 (a 到 z) 表示作为有趣起点的空单元格。\n*   大写英文字母 (A 到 Z) 表示作为有趣终点的空单元格。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 NONE（如果没有可驾驶的配对）。否则，$y$ 必须是由空格分隔的一系列 2 字符字符串，表示所有可驾驶的配对，起点字母在前，终点字母在后，按字母顺序排列。\n", "hint": "**样例解释**\n\n在样例 #1 中，简单地重复 west 命令直到到达终点是一种可行的策略。每次有 $1 / 2$ 的概率到达终点，$1 / 2$ 的概率停留在原地。因此，在 $10^{101}$ 步或更少步内未到达终点的概率为 $2^{-10^{101}}<10^{-10^{100}}$。\n\n在样例 #2 中，类似于样例 #1 的策略可以用于将汽车从顶行（1）的任何位置以任意高的概率移动到其他位置，类似地也适用于从顶部数第三行（2）的所有非墙壁位置。类似地，但使用 south 命令，汽车可以在从左数第三列（3）的非墙壁位置之间移动。\n\n从 a 和 c 出发，可以使用（1）到达从左数第三列，然后使用（3）到达 $\\mathrm{Y}$ 旁边，再使用（2）到达 $\\mathrm{Y}$，因此 $\\mathrm{aY}$ 和 $\\mathrm{cY}$ 是可驾驶的。然而，从第三行安全使用 north 或 south 命令只能在第三列进行，否则汽车可能会进入危险区域。因此，无法将汽车从第三行安全移动到第四行，因此 $\\mathrm{aX}$ 和 $\\mathrm{cX}$ 不可驾驶。\n\n从 $\\mathrm{b}$ 出发，可以使用类似策略到达 $\\mathrm{X}$，然后从 $\\mathrm{X}$ 出发，通过重复使用 north 或 south 命令（并在到达 $\\mathrm{Y}$ 时停止，避免进入上方的危险区域）到达 $\\mathrm{Y}$。\n\n最后，终点 $\\mathrm{Z}$ 完全孤立，因此无法成为可驾驶配对的一部分。\n\n在样例 #3 中，从有趣起点到有趣终点的每条路径都经过危险区域，因此该配对不可驾驶。\n\n在样例 #4 中，只有有趣起点 $\\mathrm{d}$ 存在可行的策略到达终点 $\\mathrm{F}$。\n\n**限制**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i, j$，$\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$ 是句点 (.)、井号 (#)、星号 (*) 或小写或大写英文字母。\n- 集合 $\\left\\{\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}\\right.$ 对于所有 $\\left.i, j\\right\\}$ 至少包含 1 个小写和 1 个大写英文字母。\n- 每个小写和大写字母在所有 $\\mathbf{G}_{\\mathbf{i}, \\mathbf{j}}$ 中最多出现一次。\n\n**测试集 1（5 分，可见评测结果）**\n\n- $1 \\leq \\mathbf{R} \\leq 20$。\n- $1 \\leq \\mathbf{C} \\leq 20$。\n\n**测试集 2（17 分，隐藏评测结果）**\n\n- $1 \\leq \\mathbf{R} \\leq 100$。\n- $1 \\leq \\mathbf{C} \\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12964", "type": "P", "difficulty": 6, "samples": [["4\no..=>..\n...o>..........\n.=.\n.........o........", "Case #1: 3\nCase #2: 0\nCase #3: 1\nCase #4: 131072"]], "limits": {"time": [20000, 20000, 40000], "memory": [2097152, 2097152, 2097152]}, "tags": ["动态规划 DP", "2023", "Google Code Jam"], "title": "[GCJ Farewell Round #4] Old Gold", "background": "", "description": "A long, long time ago (7 years) you were in a West-East road in southeast Asia known to contain at least one gold nugget, with a limited but reliable gold detector. After getting immensely rich with that gold, you have tried and got bored of every conceivable activity. While wandering around your huge mansion you found some notes from that gold hunt.\n\nThe notes are in the form of a diagram of the road. For each kilometer of road, you have one of 5 markings:\n\n*   $<$, indicating that the closest gold nugget is to the West,\n*   $=$, indicating that the closest gold nuggets to the East and to the West are at the same distance, and no gold nugget is at that position,\n*   $>$, indicating that the closest gold nugget is to the East,\n*   o, indicating that there is a gold nugget at that position, or\n*   ., indicating that nothing is known about that location.\n\nSince each of the $k$ unknown (.) positions could contain or not contain a gold nugget independently, you want to find out how many of the $2^{k}$ placements of gold are compatible with all your notes and result in the road overall containing at least one gold nugget. Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^{9}+7$ ($1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line contains a string $\\mathbf{S}$ representing a single test case. The $i$-th character of $\\mathbf{S}$ represents the marking in your notes for the $i$-th kilometer of road, from West to East, using the code explained above.\n", "outputFormat": "For each test case, output one line containing case #$x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is the number of different gold placements that are compatible with your notes, modulo the prime $10^{9}+7$ ($1000000007$).", "hint": "**Sample Explanation**\nIn Sample Case #1, there are three valid placements resulting in roads $\\mathrm{o} \\mathrm{o}<=>\\mathrm{o}<$, $\\mathrm{o} \\mathrm{o}<=>\\mathrm{oo}$ and $\\mathrm{o}<<=>\\mathrm{o}$.\n\nIn Sample Case #2, there is no valid placement.\n\nIn Sample Case #3, the only valid placement results in road $\\mathrm{o}=\\mathrm{o}$. Note that a valid placement must always result in a road containing at least one gold nugget.\n\nIn Sample Case #4, all $2^{17}$ placements are valid. In this case, a placement selecting to leave all the unknown (.) positions empty (without a gold nugget) is valid because the road overall still has one gold nugget in such a placement.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{S}$ is either $<$ (less than), $=$ (equals), $>$ (greater than), o (lowercase o), or . (period).\n- At least 1 and not all characters of $\\mathbf{S}$ are . (period).\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $2 \\leq$ the length of $\\mathbf{S} \\leq 100$.\n\n**Test Set 2 (17 Pts, Hidden Verdict)**\n\n- Time limit: 40 seconds.\n- $2 \\leq$ the length of $\\mathbf{S} \\leq 5 \\times 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #4] Old Gold", "background": "", "description": "A long, long time ago (7 years) you were in a West-East road in southeast Asia known to contain at least one gold nugget, with a limited but reliable gold detector. After getting immensely rich with that gold, you have tried and got bored of every conceivable activity. While wandering around your huge mansion you found some notes from that gold hunt.\n\nThe notes are in the form of a diagram of the road. For each kilometer of road, you have one of 5 markings:\n\n*   $<$, indicating that the closest gold nugget is to the West,\n*   $=$, indicating that the closest gold nuggets to the East and to the West are at the same distance, and no gold nugget is at that position,\n*   $>$, indicating that the closest gold nugget is to the East,\n*   o, indicating that there is a gold nugget at that position, or\n*   ., indicating that nothing is known about that location.\n\nSince each of the $k$ unknown (.) positions could contain or not contain a gold nugget independently, you want to find out how many of the $2^{k}$ placements of gold are compatible with all your notes and result in the road overall containing at least one gold nugget. Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^{9}+7$ ($1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line contains a string $\\mathbf{S}$ representing a single test case. The $i$-th character of $\\mathbf{S}$ represents the marking in your notes for the $i$-th kilometer of road, from West to East, using the code explained above.\n", "outputFormat": "For each test case, output one line containing case #$x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is the number of different gold placements that are compatible with your notes, modulo the prime $10^{9}+7$ ($1000000007$).", "hint": "**Sample Explanation**\nIn Sample Case #1, there are three valid placements resulting in roads $\\mathrm{o} \\mathrm{o}<=>\\mathrm{o}<$, $\\mathrm{o} \\mathrm{o}<=>\\mathrm{oo}$ and $\\mathrm{o}<<=>\\mathrm{o}$.\n\nIn Sample Case #2, there is no valid placement.\n\nIn Sample Case #3, the only valid placement results in road $\\mathrm{o}=\\mathrm{o}$. Note that a valid placement must always result in a road containing at least one gold nugget.\n\nIn Sample Case #4, all $2^{17}$ placements are valid. In this case, a placement selecting to leave all the unknown (.) positions empty (without a gold nugget) is valid because the road overall still has one gold nugget in such a placement.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{S}$ is either $<$ (less than), $=$ (equals), $>$ (greater than), o (lowercase o), or . (period).\n- At least 1 and not all characters of $\\mathbf{S}$ are . (period).\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $2 \\leq$ the length of $\\mathbf{S} \\leq 100$.\n\n**Test Set 2 (17 Pts, Hidden Verdict)**\n\n- Time limit: 40 seconds.\n- $2 \\leq$ the length of $\\mathbf{S} \\leq 5 \\times 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #4] Old Gold", "background": null, "description": "很久很久以前（7 年前），你曾在东南亚一条东西向的道路上寻找黄金，这条道路已知至少含有一块金块。当时你使用了一个有限但可靠的金块探测器。在靠这些黄金暴富后，你尝试并厌倦了所有能想到的活动。某天，你在巨大的豪宅中闲逛时，发现了当年寻金时的一些笔记。\n\n这些笔记以道路示意图的形式记录。对于道路的每一公里，笔记上有以下 5 种标记之一：\n\n*   $<$，表示最近的金块位于西侧，\n*   $=$，表示东西两侧最近的金块距离相等，且当前位置没有金块，\n*   $>$，表示最近的金块位于东侧，\n*   o，表示当前位置有金块，或\n*   .，表示该位置信息未知。\n\n由于每个未知位置（.）可以独立地选择是否放置金块，你需要计算在所有 $2^{k}$ 种可能的金块分布中，有多少种分布既符合所有笔记记录，又能保证整条道路上至少存在一块金块。由于结果可能非常大，只需输出结果对质数 $10^{9}+7$（即 $1000000007$）取模后的余数。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 行，每行包含一个字符串 $\\mathbf{S}$，表示一个测试用例。字符串 $\\mathbf{S}$ 的第 $i$ 个字符表示从西向东第 $i$ 公里处的标记，使用上述代码表示。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是符合笔记记录的金块分布数量，对质数 $10^{9}+7$ 取模后的结果。", "hint": "**样例解释**\n\n在样例 #1 中，有三种有效的金块分布，分别对应道路 $\\mathrm{o} \\mathrm{o}<=>\\mathrm{o}<$、$\\mathrm{o} \\mathrm{o}<=>\\mathrm{oo}$ 和 $\\mathrm{o}<<=>>\\mathrm{o}$。\n\n在样例 #2 中，没有有效的金块分布。\n\n在样例 #3 中，唯一有效的分布对应道路 $\\mathrm{o}=\\mathrm{o}$。注意有效的分布必须保证整条道路上至少有一块金块。\n\n在样例 #4 中，所有 $2^{17}$ 种分布都有效。在这种情况下，即使选择在所有未知位置（.）不放置金块，整条道路仍有一块金块，因此这种分布也是有效的。\n\n**限制**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 字符串 $\\mathbf{S}$ 的每个字符是 $<$（小于）、$=$（等于）、$>$（大于）、o（小写字母 o）或 .（句点）之一。\n- $\\mathbf{S}$ 中至少有 1 个但并非全部字符是 .（句点）。\n\n**测试集 1（5 分，可见评测结果）**\n\n- 时间限制：20 秒。\n- $2 \\leq \\mathbf{S}$ 的长度 $\\leq 100$。\n\n**测试集 2（17 分，隐藏评测结果）**\n\n- 时间限制：40 秒。\n- $2 \\leq \\mathbf{S}$ 的长度 $\\leq 5 \\times 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12965", "type": "P", "difficulty": 6, "samples": [["2\n4 5\n\n\n\n\n\n1 2\n1 3\n1 4\n2 4\n3 4\n\n4 4\n\n\n\n\n1 2\n1 3\n2 4\n3 4", "\n\n1 2\n1 3\n4 2\n4 3\n1 4\n\n\n\n\n\n1 2 4 2\n\n1 2\n1 4\n3 2\n3 4\n\n\n\n\n2 1 3 4"]], "limits": {"time": [30000, 30000], "memory": [2097152, 2097152]}, "tags": ["2023", "交互题", "Special Judge", "Google Code Jam"], "title": "[GCJ Farewell Round #4] Ring-Preserving Networks", "background": "", "description": "A research consortium is building a new datacenter. In the datacenter, a set of computers is set up to work together and communicate via a network. The network works only with direct bidirectional links between computers. After the success of their name-preserving networks, they decided to do other designs with guaranteed properties.\n\nThe consortium has asked you to submit a design of a ring-preserving network. We define a ring of a network as an ordering of all the computers of the network such that any two computers that are consecutive in the ordering have a direct link between them, and the same is true for the first and last computers in the ordering.\n\nA ring-preserving network is a network design that can efficiently find a ring of itself even after losing the original computer identifications. You need to submit several network designs that are ring-preserving.\n\nTo evaluate your network designs, the research consortium has set up an automated program. You will be asked for network designs specifying the exact number of computers $\\mathbf{C}$ and the exact number of bidirectional links $\\mathbf{L}$ it must contain. You must assign each computer a unique ID between 1 and $\\mathbf{C}$ and list the $\\mathbf{L}$ links using the IDs to refer to the links' endpoints. The evaluating program will receive that design and send back a copy of the network design with the following changes:\n\n*   the unique IDs have been permuted uniformly at random (that is, each ID is now equally likely to be on any of the computers),\n*   every link is listed with the smallest ID first (using the new IDs), and\n*   the set of links is listed in increasing order of the first endpoint (using the new IDs), breaking ties by smallest second endpoint (i.e., lexicographical order).\n\nYou need to be able to find a ring of the modified network. It does not need to be the original ring.\n\n### Interactive Protocol\n\nThis is an interactive problem. You should make sure you have read the information in the Interactive Problems section of our FAQ.\n\nInitially, your program should read a single line containing an integer, $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nFor each test case, your program must first read a line containing two integers $\\mathbf{C}$ and $\\mathbf{L}$: the number of computers and links to include in the network design.\n\nThen, you need to create a network design with $\\mathbf{C}$ computers and $\\mathbf{L}$ links and print exactly $\\mathbf{L}$ lines representing that design. Each of these lines must contain two integers $\\mathrm{A}$ and $\\mathrm{B}$ each, representing a different link between computers $\\mathrm{A}$ and $\\mathrm{B}$, where $A \\neq B$. Notice that if you list link $\\mathrm{A} \\mathrm{B}$, you may not list $\\mathrm{A} \\mathrm{B}$ nor $\\mathrm{B} \\mathrm{A}$ again.\n\nUpon reading your network design, the judge will send you $\\mathbf{L}$ lines back representing the permuted design. The $i$-th of these lines contains two integers $\\mathbf{U}_{\\mathbf{i}}$ and $\\mathbf{V}_{\\mathbf{i}}$ representing a bidirectional link between the computers with new ids $\\mathbf{U}_{\\mathbf{i}}$ and $\\mathbf{V}_{\\mathbf{i}}$. The copy is generated using a permutation chosen uniformly at random from all possible permutations, and independently of any other choices.\n\nTo finish a test case, you need to send the judge a single line with $\\mathbf{C}$ integers $x_{1}, x_{2}, \\ldots, x_{\\mathbf{C}}$, representing a ring of the permuted design. That is, the set of lines the judge sent back must include either $x_{1} x_{\\mathbf{C}}$ or $x_{\\mathbf{C}} x_{1}$, and, for all $i$, it must include either $x_{i} x_{i+1}$ or $x_{i+1} x_{i}$.\n\nYou should not send additional information to the judge after solving all test cases. In other words, if your program keeps printing to standard output after printing the list of $x s$ for the last test case, you will receive a Wrong Answer judgment.\n\nIf at any point the judge reads from your program malformed input (wrong number of tokens, non-integer tokens or out of range numbers) it will immediately stop and assume Wrong Answer. However, if your program happens to remain waiting for input from the judge, it may end up exceeding the time limit and receiving a Time Limit Exceeded judgement. On the other hand, if you commit a recoverable error (sending over a network with a repeated connection, or a connection from a computer to itself, or sending a ring that repeats a computer or that uses an edge that does not exist in the permuted version) the judge will continue to communicate with your program trying to finish, but the overall judgement will be Wrong Answer.\n\nNotice that you are allowed to submit the same network design for different test cases, as long as that design complies with all restrictions for both cases. Additionally, the seed for random generation in the judge is fixed, so sending the same set of original network designs in the same order will get back the same set of copies.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nCase 2 is correct, but Case 1 is not, so the final judgement is Wrong Answer.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $3 \\leq \\mathbf{C} \\leq 10000$.\n- $\\mathbf{C} \\leq \\mathbf{L} \\leq \\mathbf{C} \\times (\\mathbf{C} - 1) / 2$.\n- $1 \\leq \\mathbf{U}_{\\mathbf{i}} < \\mathbf{V}_{\\mathbf{i}} \\leq \\mathbf{C}$, for all $i$.\n- $\\mathbf{U}_{\\mathbf{i}} \\leq \\mathbf{U}_{\\mathbf{i+1}}$, for all $i$.\n- If $\\mathbf{U}_{\\mathbf{i}} = \\mathbf{U}_{\\mathbf{i+1}}$ then $\\mathbf{V}_{\\mathbf{i}} \\leq \\mathbf{V}_{\\mathbf{i+1}}$, for all $i$.\n- There exist permutations $f$ of length $\\mathbf{C}$ and $g$ of length $\\mathbf{L}$ such that, for each $i$, if $A \\ B$ is the $g(i)$-th line in your original design, then $\\{\\mathbf{U}_{\\mathbf{i}}, \\mathbf{V}_{\\mathbf{i}}\\} = \\{f(A), f(B)\\}$. (The given links result from applying a permutation of computer IDs to the ones you gave, and then sorting the links lexicographically).\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $\\mathbf{L} \\leq \\mathbf{C} + 10$.\n\n**Test Set 2 (17 Pts, Hidden Verdict)**\n\n- $\\mathbf{L} \\leq 20000$.", "locale": "en", "translations": {"en": {"title": "[GCJ Farewell Round #4] Ring-Preserving Networks", "background": "", "description": "A research consortium is building a new datacenter. In the datacenter, a set of computers is set up to work together and communicate via a network. The network works only with direct bidirectional links between computers. After the success of their name-preserving networks, they decided to do other designs with guaranteed properties.\n\nThe consortium has asked you to submit a design of a ring-preserving network. We define a ring of a network as an ordering of all the computers of the network such that any two computers that are consecutive in the ordering have a direct link between them, and the same is true for the first and last computers in the ordering.\n\nA ring-preserving network is a network design that can efficiently find a ring of itself even after losing the original computer identifications. You need to submit several network designs that are ring-preserving.\n\nTo evaluate your network designs, the research consortium has set up an automated program. You will be asked for network designs specifying the exact number of computers $\\mathbf{C}$ and the exact number of bidirectional links $\\mathbf{L}$ it must contain. You must assign each computer a unique ID between 1 and $\\mathbf{C}$ and list the $\\mathbf{L}$ links using the IDs to refer to the links' endpoints. The evaluating program will receive that design and send back a copy of the network design with the following changes:\n\n*   the unique IDs have been permuted uniformly at random (that is, each ID is now equally likely to be on any of the computers),\n*   every link is listed with the smallest ID first (using the new IDs), and\n*   the set of links is listed in increasing order of the first endpoint (using the new IDs), breaking ties by smallest second endpoint (i.e., lexicographical order).\n\nYou need to be able to find a ring of the modified network. It does not need to be the original ring.\n\n### Interactive Protocol\n\nThis is an interactive problem. You should make sure you have read the information in the Interactive Problems section of our FAQ.\n\nInitially, your program should read a single line containing an integer, $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nFor each test case, your program must first read a line containing two integers $\\mathbf{C}$ and $\\mathbf{L}$: the number of computers and links to include in the network design.\n\nThen, you need to create a network design with $\\mathbf{C}$ computers and $\\mathbf{L}$ links and print exactly $\\mathbf{L}$ lines representing that design. Each of these lines must contain two integers $\\mathrm{A}$ and $\\mathrm{B}$ each, representing a different link between computers $\\mathrm{A}$ and $\\mathrm{B}$, where $A \\neq B$. Notice that if you list link $\\mathrm{A} \\mathrm{B}$, you may not list $\\mathrm{A} \\mathrm{B}$ nor $\\mathrm{B} \\mathrm{A}$ again.\n\nUpon reading your network design, the judge will send you $\\mathbf{L}$ lines back representing the permuted design. The $i$-th of these lines contains two integers $\\mathbf{U}_{\\mathbf{i}}$ and $\\mathbf{V}_{\\mathbf{i}}$ representing a bidirectional link between the computers with new ids $\\mathbf{U}_{\\mathbf{i}}$ and $\\mathbf{V}_{\\mathbf{i}}$. The copy is generated using a permutation chosen uniformly at random from all possible permutations, and independently of any other choices.\n\nTo finish a test case, you need to send the judge a single line with $\\mathbf{C}$ integers $x_{1}, x_{2}, \\ldots, x_{\\mathbf{C}}$, representing a ring of the permuted design. That is, the set of lines the judge sent back must include either $x_{1} x_{\\mathbf{C}}$ or $x_{\\mathbf{C}} x_{1}$, and, for all $i$, it must include either $x_{i} x_{i+1}$ or $x_{i+1} x_{i}$.\n\nYou should not send additional information to the judge after solving all test cases. In other words, if your program keeps printing to standard output after printing the list of $x s$ for the last test case, you will receive a Wrong Answer judgment.\n\nIf at any point the judge reads from your program malformed input (wrong number of tokens, non-integer tokens or out of range numbers) it will immediately stop and assume Wrong Answer. However, if your program happens to remain waiting for input from the judge, it may end up exceeding the time limit and receiving a Time Limit Exceeded judgement. On the other hand, if you commit a recoverable error (sending over a network with a repeated connection, or a connection from a computer to itself, or sending a ring that repeats a computer or that uses an edge that does not exist in the permuted version) the judge will continue to communicate with your program trying to finish, but the overall judgement will be Wrong Answer.\n\nNotice that you are allowed to submit the same network design for different test cases, as long as that design complies with all restrictions for both cases. Additionally, the seed for random generation in the judge is fixed, so sending the same set of original network designs in the same order will get back the same set of copies.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nCase 2 is correct, but Case 1 is not, so the final judgement is Wrong Answer.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $3 \\leq \\mathbf{C} \\leq 10000$.\n- $\\mathbf{C} \\leq \\mathbf{L} \\leq \\mathbf{C} \\times (\\mathbf{C} - 1) / 2$.\n- $1 \\leq \\mathbf{U}_{\\mathbf{i}} < \\mathbf{V}_{\\mathbf{i}} \\leq \\mathbf{C}$, for all $i$.\n- $\\mathbf{U}_{\\mathbf{i}} \\leq \\mathbf{U}_{\\mathbf{i+1}}$, for all $i$.\n- If $\\mathbf{U}_{\\mathbf{i}} = \\mathbf{U}_{\\mathbf{i+1}}$ then $\\mathbf{V}_{\\mathbf{i}} \\leq \\mathbf{V}_{\\mathbf{i+1}}$, for all $i$.\n- There exist permutations $f$ of length $\\mathbf{C}$ and $g$ of length $\\mathbf{L}$ such that, for each $i$, if $A \\ B$ is the $g(i)$-th line in your original design, then $\\{\\mathbf{U}_{\\mathbf{i}}, \\mathbf{V}_{\\mathbf{i}}\\} = \\{f(A), f(B)\\}$. (The given links result from applying a permutation of computer IDs to the ones you gave, and then sorting the links lexicographically).\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $\\mathbf{L} \\leq \\mathbf{C} + 10$.\n\n**Test Set 2 (17 Pts, Hidden Verdict)**\n\n- $\\mathbf{L} \\leq 20000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ Farewell Round #4] Ring-Preserving Networks", "background": "", "description": "一个研究联盟正在建设一个新的数据中心。在数据中心中，一组计算机通过网络相互连接和通信。该网络仅通过计算机之间的直接双向链路工作。在他们成功开发了**名称保持网络**后，决定开发其他具有保证特性的设计。\n\n该联盟要求你提交一种**环保持网络**的设计方案。我们将网络的**环**定义为网络中所有计算机的一个排列顺序，使得排列中任意两个相邻计算机之间存在直接链路，且排列的首尾计算机之间也存在直接链路。\n\n**环保持网络**是一种网络设计方案，即使在丢失原始计算机标识后，仍能高效找到自身的环。你需要提交多个满足环保持特性的网络设计。\n\n为了评估你的网络设计，研究联盟设置了一个自动化程序。你需要根据指定的计算机数量 $\\mathbf{C}$ 和双向链路数量 $\\mathbf{L}$ 提交网络设计。你必须为每台计算机分配一个 1 到 $\\mathbf{C}$ 之间的唯一 ID，并用这些 ID 列出 $\\mathbf{L}$ 条链路。评估程序会接收该设计，并返回一个经过以下修改的网络设计副本：\n\n*   唯一 ID 被均匀随机排列（即每个新 ID 可能出现在任意计算机上），\n*   每条链路按新 ID 从小到大排列，\n*   链路集合按第一个端点的升序排列（使用新 ID），若第一个端点相同则按第二个端点的升序排列（即字典序）。\n\n你需要能够从修改后的网络中找到至少一个环。这个环不需要是原始环。\n\n### 交互协议\n\n这是一个交互式问题。请确保你已阅读我们 FAQ 中关于交互式问题的部分。\n\n最初，你的程序应读取一个整数 $\\mathbf{T}$，表示测试用例的数量。然后，需要处理 $\\mathbf{T}$ 个测试用例。\n\n对于每个测试用例，你的程序首先读取一行包含两个整数 $\\mathbf{C}$ 和 $\\mathbf{L}$，分别表示网络设计中的计算机数量和链路数量。\n\n然后，你需要创建一个包含 $\\mathbf{C}$ 台计算机和 $\\mathbf{L}$ 条链路的网络设计，并打印恰好 $\\mathbf{L}$ 行表示该设计。每行包含两个不同的整数 $\\mathrm{A}$ 和 $\\mathrm{B}$，表示计算机 $\\mathrm{A}$ 和 $\\mathrm{B}$ 之间的一条链路（$A \\neq B$）。注意，如果你列出了链路 $\\mathrm{A} \\mathrm{B}$，就不能再列出 $\\mathrm{A} \\mathrm{B}$ 或 $\\mathrm{B} \\mathrm{A}$。\n\n在读取你的网络设计后，评测系统会返回 $\\mathbf{L}$ 行表示经过排列的设计。第 $i$ 行包含两个整数 $\\mathbf{U}_{\\mathbf{i}}$ 和 $\\mathbf{V}_{\\mathbf{i}}$，表示新 ID 为 $\\mathbf{U}_{\\mathbf{i}}$ 和 $\\mathbf{V}_{\\mathbf{i}}$ 的计算机之间的双向链路。该副本使用从所有可能排列中均匀随机选择的排列生成，且与其他选择独立。\n\n要完成一个测试用例，你需要向评测系统发送一行包含 $\\mathbf{C}$ 个整数 $x_{1}, x_{2}, \\ldots, x_{\\mathbf{C}}$，表示排列后设计中的一个环。即，评测系统返回的链路集合中必须包含 $x_{1} x_{\\mathbf{C}}$ 或 $x_{\\mathbf{C}} x_{1}$，并且对于所有 $i$，必须包含 $x_{i} x_{i+1}$ 或 $x_{i+1} x_{i}$。\n\n在处理完所有测试用例后，你不应再向评测系统发送任何信息。换句话说，如果在打印最后一个测试用例的环列表后，你的程序继续向标准输出打印内容，将被判为错误答案。\n\n如果在任何时候评测系统从你的程序中读取到格式错误的输入（令牌数量错误、非整数令牌或超出范围的数字），它将立即停止并判定为错误答案。然而，如果你的程序在等待评测系统的输入时超时，可能会被判为超出时间限制。另一方面，如果你犯了一个可恢复的错误（发送的网络中包含重复连接、自环连接，或发送的环中重复使用计算机或使用了排列后版本中不存在的边），评测系统会继续与你的程序通信以完成测试，但最终判定仍为错误答案。\n\n请注意，你可以在不同的测试用例中提交相同的网络设计，只要该设计同时满足所有限制条件。此外，评测系统中的随机生成种子是固定的，因此以相同顺序提交相同的原始网络设计集将获得相同的副本集。\n", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "**样例解释**\n\n第一组样例是错误的，第二组样例是正确的，因此最后的评判为 Wrong Answer。\n\n**限制**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $3 \\leq \\mathbf{C} \\leq 10000$。\n- $\\mathbf{C} \\leq \\mathbf{L} \\leq \\mathbf{C} \\times (\\mathbf{C} - 1) / 2$。\n- 对于所有 $i$，$1 \\leq \\mathbf{U}_{\\mathbf{i}} < \\mathbf{V}_{\\mathbf{i}} \\leq \\mathbf{C}$。\n- 对于所有 $i$，$\\mathbf{U}_{\\mathbf{i}} \\leq \\mathbf{U}_{\\mathbf{i+1}}$。\n- 如果 $\\mathbf{U}_{\\mathbf{i}} = \\mathbf{U}_{\\mathbf{i+1}}$，则对于所有 $i$，$\\mathbf{V}_{\\mathbf{i}} \\leq \\mathbf{V}_{\\mathbf{i+1}}$。\n- 存在长度为 $\\mathbf{C}$ 的排列 $f$ 和长度为 $\\mathbf{L}$ 的排列 $g$，使得对于每个 $i$，如果 $A \\ B$ 是你的原始设计中的第 $g(i)$ 行，则 $\\{\\mathbf{U}_{\\mathbf{i}}, \\mathbf{V}_{\\mathbf{i}}\\} = \\{f(A), f(B)\\}$。（给定的链路是通过对计算机 ID 进行排列并对链路按字典序排序后得到的）。\n\n**测试集 1（5 分，可见评测结果）**\n\n- $\\mathbf{L} \\leq \\mathbf{C} + 10$。\n\n**测试集 2（17 分，隐藏评测结果）**\n\n- $\\mathbf{L} \\leq 20000$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12966", "type": "P", "difficulty": 5, "samples": [["6 10 \n1 1\n5 2\n200 6\n9 2\n6 2\n100 1", "310"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2025", "排序", "CCO（加拿大）"], "title": "[CCO 2025] Asteroid Mining", "background": "", "description": "It is the year 2017 and Ryan is an asteroid miner. He makes a living by mining asteroids and selling them at the CCO (Celestial Cargo Outpost).\n\nOn his latest mining expedition, he has mined $N$ mineral chunks where the $i$-th chunk has a value $v_i$ and a mass $m_i$. Ryan plans to transport a set of chunks to the CCO with his rocket, but he only has enough fuel to last one more trip. He calculated that the maximum total mass he can safely carry on his rocket is $M$. Due to Ryan's mining technique, the chunks exhibit a special property: for any two mineral chunks, one's mass is divisible by the other chunk's mass.\n\nHelp Ryan find the maximum total value he can ship to CCO while adhering to his rocket's constraints.", "inputFormat": "The first line will contain two space-separated integers $N$ ($1 \\leq N \\leq 500000$) and $M$ ($1 \\leq M \\leq 10^{12}$).\n\nThe next $N$ lines will each contain two space-separated integers $v_i$ ($1 \\leq v_i \\leq 10^{12}$) and $m_i$ ($1 \\leq m_i \\leq 10^{12}$), representing the value and mass of the $i$-th mineral chunk respectively. **Additionally, for any two mineral chunks $i, j$ ($1 \\leq i, j \\leq N$), either $m_i \\mid m_j$ or $m_j \\mid m_i$, where $a \\mid b$ means that $a$ is a divisor of $b$ (i.e., $\\frac{b}{a}$ is an integer).**", "outputFormat": "On one line, output one integer, the maximum total value Ryan can ship to CCO.", "hint": "**Sample Explanation**\n\nRyan can take all the chucks except the second and fifth chucks to achieve a total value of $1 + 200 + 9 + 100 = 310$. Note that the total mass of the chunks is $1 + 6 + 2 + 1 = 10$. We can show that this is optimal.\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $N$ | Bounds on $M$ | Additional Constraints |\n| :---: | :---: | :---: | :---: |\n| 2 marks | $N = 2$ | $1 \\leq M \\leq 10^4$ | None |\n| 2 marks | $1 \\leq N \\leq 20$ | $1 \\leq M \\leq 10^4$ | None |\n| 4 marks | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 10^4$ | None |\n| 6 marks | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 10^8$ | None |\n| 2 marks | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^8$ | All $m_i$ are equal. |\n| 3 marks | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^8$ | At most 2 distinct $m_i$. |\n| 6 marks | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^{12}$ | None |\n", "locale": "en", "translations": {"en": {"title": "[CCO 2025] Asteroid Mining", "background": "", "description": "It is the year 2017 and Ryan is an asteroid miner. He makes a living by mining asteroids and selling them at the CCO (Celestial Cargo Outpost).\n\nOn his latest mining expedition, he has mined $N$ mineral chunks where the $i$-th chunk has a value $v_i$ and a mass $m_i$. Ryan plans to transport a set of chunks to the CCO with his rocket, but he only has enough fuel to last one more trip. He calculated that the maximum total mass he can safely carry on his rocket is $M$. Due to Ryan's mining technique, the chunks exhibit a special property: for any two mineral chunks, one's mass is divisible by the other chunk's mass.\n\nHelp Ryan find the maximum total value he can ship to CCO while adhering to his rocket's constraints.", "inputFormat": "The first line will contain two space-separated integers $N$ ($1 \\leq N \\leq 500000$) and $M$ ($1 \\leq M \\leq 10^{12}$).\n\nThe next $N$ lines will each contain two space-separated integers $v_i$ ($1 \\leq v_i \\leq 10^{12}$) and $m_i$ ($1 \\leq m_i \\leq 10^{12}$), representing the value and mass of the $i$-th mineral chunk respectively. **Additionally, for any two mineral chunks $i, j$ ($1 \\leq i, j \\leq N$), either $m_i \\mid m_j$ or $m_j \\mid m_i$, where $a \\mid b$ means that $a$ is a divisor of $b$ (i.e., $\\frac{b}{a}$ is an integer).**", "outputFormat": "On one line, output one integer, the maximum total value Ryan can ship to CCO.", "hint": "**Sample Explanation**\n\nRyan can take all the chucks except the second and fifth chucks to achieve a total value of $1 + 200 + 9 + 100 = 310$. Note that the total mass of the chunks is $1 + 6 + 2 + 1 = 10$. We can show that this is optimal.\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $N$ | Bounds on $M$ | Additional Constraints |\n| :---: | :---: | :---: | :---: |\n| 2 marks | $N = 2$ | $1 \\leq M \\leq 10^4$ | None |\n| 2 marks | $1 \\leq N \\leq 20$ | $1 \\leq M \\leq 10^4$ | None |\n| 4 marks | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 10^4$ | None |\n| 6 marks | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 10^8$ | None |\n| 2 marks | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^8$ | All $m_i$ are equal. |\n| 3 marks | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^8$ | At most 2 distinct $m_i$. |\n| 6 marks | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^{12}$ | None |\n", "locale": "en"}, "zh-CN": {"title": "[CCO 2025] Asteroid Mining", "background": "", "description": "现在是 2017 年，**Ryan** 是一名小行星矿工。他以开采小行星并在 **CCO**（天体货运前哨站）出售矿物为生。\n\n在最近的一次采矿探险中，他开采了 $N$ 块矿物，其中第 $i$ 块矿物的价值为 $v_i$，质量为 $m_i$。**Ryan** 计划用他的火箭将一组矿物运送到 **CCO**，但他只剩下足够进行一次飞行的燃料。他计算出火箭能够安全携带的最大总质量为 $M$。由于 **Ryan** 的采矿技术，这些矿物具有一个特殊性质：对于任意两块矿物，其中一块的质量可以被另一块的质量整除。\n\n帮助 **Ryan** 在火箭的限制下找到他能运送到 **CCO** 的最大总价值。", "inputFormat": "第一行包含两个以空格分隔的整数 $N$（$1 \\leq N \\leq 500000$）和 $M$（$1 \\leq M \\leq 10^{12}$）。\n\n接下来的 $N$ 行，每行包含两个以空格分隔的整数 $v_i$（$1 \\leq v_i \\leq 10^{12}$）和 $m_i$（$1 \\leq m_i \\leq 10^{12}$），分别表示第 $i$ 块矿物的价值和质量。**此外，对于任意两块矿物 $i, j$（$1 \\leq i, j \\leq N$），要么 $m_i \\mid m_j$，要么 $m_j \\mid m_i$，其中 $a \\mid b$ 表示 $a$ 是 $b$ 的因数（即 $\\frac{b}{a}$ 是整数）。**\n", "outputFormat": "输出一行，包含一个整数，表示 **Ryan** 能运送到 **CCO** 的最大总价值。\n", "hint": "**样例解释**\n\n**Ryan** 可以携带除第二块和第五块之外的所有矿物，以获得总价值 $1 + 200 + 9 + 100 = 310$。注意，这些矿物的总质量为 $1 + 6 + 2 + 1 = 10$。可以证明这是最优解。\n\n以下表格展示了 25 分的分布情况：\n\n| 分值 | $N$ 的范围 | $M$ 的范围 | 额外约束 |\n| :---: | :---: | :---: | :---: |\n| 2 分 | $N = 2$ | $1 \\leq M \\leq 10^4$ | 无 |\n| 2 分 | $1 \\leq N \\leq 20$ | $1 \\leq M \\leq 10^4$ | 无 |\n| 4 分 | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 10^4$ | 无 |\n| 6 分 | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 10^8$ | 无 |\n| 2 分 | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^8$ | 所有 $m_i$ 相等。 |\n| 3 分 | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^8$ | 最多 2 种不同的 $m_i$。 |\n| 6 分 | $1 \\leq N \\leq 500000$ | $1 \\leq M \\leq 10^{12}$ | 无 |\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12967", "type": "P", "difficulty": 6, "samples": [["8 3\n1 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8", "1"], ["14 5\n1 2\n1 3\n3 4\n3 5\n1 6\n6 7\n7 8\n7 9\n2 10\n10 11\n10 12\n10 13\n10 14", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "CCO（加拿大）"], "title": "[CCO 2025] Tree Decorations", "background": "", "description": "Mateo recently found the perfect decorations for his Christmas tree — more trees!\n\nSpecifically, his Christmas tree is a rooted tree $T$ initially with $M$ nodes, all painted green. He has another rooted tree $D$ that he uses as a reference for his decorations. Mateo uses the following process to put on all of his decorations:\n\n- For each node $i$ in $D$, he creates a **copy** of the subtree rooted at $i$. Let this copy be $C_i$. Then, he paints the nodes of $C_i$ red. Finally, he chooses some green node in $T$ to be the parent of the root of $C_i$ by connecting them with an edge.\n\nAfter applying all the decorations, $T$ ends up containing $N$ nodes. Unfortunately, he realized that he had forgotten to record what $D$ is! To make things worse, he accidentally spilled water on $T$, washing off all the colour from the nodes. After all that, he labels the root of $T$ as 1, and then labels the rest of the nodes from 2 to $N$.\n\nThe only information he currently has is the final state of $T$, as well as $M$. Help him find the number of possible $D$ that he could have started with, where two possibilities are considered different if they are structurally distinct.\n\nRooted trees $A$ and $B$ are said to be structurally identical if and only if they have the same number of nodes $S$, and there is a way to label $A$'s nodes from 1 to $S$ and $B$'s nodes from 1 to $S$ such that:\n\n- Their roots are labeled the same.\n- Nodes labeled $x$ and $y$ in $A$ are connected by an edge if and only if nodes labeled $x$ and $y$ in $B$ are connected by an edge.\n\nOtherwise, $A$ and $B$ are considered structurally distinct.", "inputFormat": "The first line of input contains two space-separated integers $N$ and $M$.\n\nThe next $N - 1$ lines each contain two space-separated integers $u_i$ and $v_i$ ($1 \\leq u_i, v_i \\leq N$, $u_i \\neq v_i$), describing an edge in $T$ connecting nodes $u_i$ and $v_", "outputFormat": "Output the number of possible $D$ that he could have started with, where two possibilities are considered different if they are structurally distinct.", "hint": "**Sample 1 Explanation**\n\nIt is provable that the only possible $D$ is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/prs3i0ia.png)\n\nWe can get $T$ the following way:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/es4cbjcu.png)\n\nIn the diagram above, the red parts are added as decorations, while the green, filled-in part represents the initial state of $T$. The dotted lines represent the edges connecting the decorations to the tree.\n\n**Sample 2 Explanation**\n\nThe first possibility for $D$ is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xn2gjm2q.png)\n\nUsing this, we can get $T$ the following way:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yu3ac03q.png)\n\nThe second possibility for $D$ is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d7m3kjgj.png)\n\nUsing this, we can get $T$ the following way:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7lulazk0.png)\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $N$ | Bounds on $M$ |\n|:---------------:|:---------------:|:----------------:|\n| 2 marks       | $2 \\leq N \\leq 10$ | $M = 1$        |\n| 3 marks       | $2 \\leq N \\leq 200$ | $M = 1$        |\n| 2 marks       | $2 \\leq N \\leq 500000$ | $M = 1$        |\n| 6 marks       | $2 \\leq N \\leq 200$ | $1 \\leq M < N$ |\n| 4 marks       | $2 \\leq N \\leq 2000$ | $1 \\leq M < N$ |\n| 8 marks       | $2 \\leq N \\leq 500000$ | $1 \\leq M < N$ |", "locale": "en", "translations": {"en": {"title": "[CCO 2025] Tree Decorations", "background": "", "description": "Mateo recently found the perfect decorations for his Christmas tree — more trees!\n\nSpecifically, his Christmas tree is a rooted tree $T$ initially with $M$ nodes, all painted green. He has another rooted tree $D$ that he uses as a reference for his decorations. Mateo uses the following process to put on all of his decorations:\n\n- For each node $i$ in $D$, he creates a **copy** of the subtree rooted at $i$. Let this copy be $C_i$. Then, he paints the nodes of $C_i$ red. Finally, he chooses some green node in $T$ to be the parent of the root of $C_i$ by connecting them with an edge.\n\nAfter applying all the decorations, $T$ ends up containing $N$ nodes. Unfortunately, he realized that he had forgotten to record what $D$ is! To make things worse, he accidentally spilled water on $T$, washing off all the colour from the nodes. After all that, he labels the root of $T$ as 1, and then labels the rest of the nodes from 2 to $N$.\n\nThe only information he currently has is the final state of $T$, as well as $M$. Help him find the number of possible $D$ that he could have started with, where two possibilities are considered different if they are structurally distinct.\n\nRooted trees $A$ and $B$ are said to be structurally identical if and only if they have the same number of nodes $S$, and there is a way to label $A$'s nodes from 1 to $S$ and $B$'s nodes from 1 to $S$ such that:\n\n- Their roots are labeled the same.\n- Nodes labeled $x$ and $y$ in $A$ are connected by an edge if and only if nodes labeled $x$ and $y$ in $B$ are connected by an edge.\n\nOtherwise, $A$ and $B$ are considered structurally distinct.", "inputFormat": "The first line of input contains two space-separated integers $N$ and $M$.\n\nThe next $N - 1$ lines each contain two space-separated integers $u_i$ and $v_i$ ($1 \\leq u_i, v_i \\leq N$, $u_i \\neq v_i$), describing an edge in $T$ connecting nodes $u_i$ and $v_", "outputFormat": "Output the number of possible $D$ that he could have started with, where two possibilities are considered different if they are structurally distinct.", "hint": "**Sample 1 Explanation**\n\nIt is provable that the only possible $D$ is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/prs3i0ia.png)\n\nWe can get $T$ the following way:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/es4cbjcu.png)\n\nIn the diagram above, the red parts are added as decorations, while the green, filled-in part represents the initial state of $T$. The dotted lines represent the edges connecting the decorations to the tree.\n\n**Sample 2 Explanation**\n\nThe first possibility for $D$ is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xn2gjm2q.png)\n\nUsing this, we can get $T$ the following way:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yu3ac03q.png)\n\nThe second possibility for $D$ is:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d7m3kjgj.png)\n\nUsing this, we can get $T$ the following way:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7lulazk0.png)\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $N$ | Bounds on $M$ |\n|:---------------:|:---------------:|:----------------:|\n| 2 marks       | $2 \\leq N \\leq 10$ | $M = 1$        |\n| 3 marks       | $2 \\leq N \\leq 200$ | $M = 1$        |\n| 2 marks       | $2 \\leq N \\leq 500000$ | $M = 1$        |\n| 6 marks       | $2 \\leq N \\leq 200$ | $1 \\leq M < N$ |\n| 4 marks       | $2 \\leq N \\leq 2000$ | $1 \\leq M < N$ |\n| 8 marks       | $2 \\leq N \\leq 500000$ | $1 \\leq M < N$ |", "locale": "en"}, "zh-CN": {"title": "[CCO 2025] Tree Decorations", "background": "", "description": "**Mateo** 最近为他的圣诞树找到了完美的装饰品——更多的树！\n\n具体来说，他的圣诞树是一棵初始有 $M$ 个节点、全部涂成绿色的有根树 $T$。他还有另一棵用作装饰参考的有根树 $D$。**Mateo** 通过以下步骤完成所有装饰：\n\n- 对于 $D$ 中的每个节点 $i$，他创建一份以 $i$ 为根的子树**副本**，记为 $C_i$。然后，他将 $C_i$ 的所有节点涂成红色。最后，他选择 $T$ 中的某个绿色节点作为 $C_i$ 根节点的父节点，并通过一条边将它们连接起来。\n\n完成所有装饰后，$T$ 最终包含 $N$ 个节点。不幸的是，他忘记记录 $D$ 的具体形态了！更糟的是，他不小心将水洒在 $T$ 上，导致所有节点的颜色都被洗掉了。之后，他将 $T$ 的根节点标记为 1，其余节点依次标记为 2 到 $N$。\n\n目前他唯一掌握的信息是 $T$ 的最终形态以及 $M$ 的值。请帮助他计算可能的初始树 $D$ 的数量（若两棵树结构不同，则视为不同的可能性）。\n\n若两棵有根树 $A$ 和 $B$ 满足以下条件，则称它们是**结构相同**的：\n- 节点数 $S$ 相同；\n- 存在一种对 $A$ 和 $B$ 的节点分别从 1 到 $S$ 的标号方式，使得：\n  - 它们的根节点标号相同；\n  - $A$ 中标号为 $x$ 和 $y$ 的节点之间有边当且仅当 $B$ 中标号为 $x$ 和 $y$ 的节点之间有边。\n\n否则，$A$ 和 $B$ 被视为**结构不同**。", "inputFormat": "第一行输入包含两个以空格分隔的整数 $N$ 和 $M$。\n\n接下来的 $N - 1$ 行，每行包含两个以空格分隔的整数 $u_i$ 和 $v_i$（$1 \\leq u_i, v_i \\leq N$，$u_i \\neq v_i$），表示 $T$ 中连接节点 $u_i$ 和 $v_i$ 的一条边。\n", "outputFormat": "输出可能的初始树 $D$ 的数量（结构不同的树视为不同情况）。\n", "hint": "**样例 1 解释**\n\n可以证明，唯一可能的 $D$ 如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/prs3i0ia.png)\n\n通过以下方式可以得到 $T$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/es4cbjcu.png)\n\n上图中，红色部分为添加的装饰，绿色填充部分表示 $T$ 的初始状态，虚线表示连接装饰品的边。\n\n**样例 2 解释**\n\n第一种可能的 $D$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xn2gjm2q.png)\n\n通过以下方式可以得到 $T$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yu3ac03q.png)\n\n第二种可能的 $D$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d7m3kjgj.png)\n\n通过以下方式可以得到 $T$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7lulazk0.png)\n\n以下表格展示了 25 分的分布情况：\n\n| 分值   | $N$ 的范围          | $M$ 的范围          |\n|:------:|:-------------------:|:-------------------:|\n| 2 分   | $2 \\leq N \\leq 10$  | $M = 1$             |\n| 3 分   | $2 \\leq N \\leq 200$ | $M = 1$             |\n| 2 分   | $2 \\leq N \\leq 500000$ | $M = 1$          |\n| 6 分   | $2 \\leq N \\leq 200$ | $1 \\leq M < N$      |\n| 4 分   | $2 \\leq N \\leq 2000$ | $1 \\leq M < N$     |\n| 8 分   | $2 \\leq N \\leq 500000$ | $1 \\leq M < N$  |\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12968", "type": "P", "difficulty": 7, "samples": [["4 100", "141"], ["7 10000000000", "16926961207710"]], "limits": {"time": [30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000, 30000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "CCO（加拿大）"], "title": "[CCO 2025] Balanced Integer", "background": "**Abusing judging resources leads to an account ban.**\n\nYou can self-test the first three test cases of each Subtask at the link: https://www.luogu.com.cn/problem/U576602 to avoid long judging wait times.", "description": "Since the CCO often uses integers, Alice needs to learn about the integers! A positive integer $n$ can be written in base $b$ as the sequence $d_{m-1}d_{m-2} \\ldots d_{1}d_{0}$ if the following hold:\n\n- Each digit $d_{i}$ is between 0 and $b-1$, inclusive.\n- $d_{m-1}>0$.\n- $n=d_{m-1} \\times b^{m-1}+d_{m-2} \\times b^{m-2}+\\cdots+d_{1} \\times b^{1}+d_{0} \\times b^{0}$.\n\n\nFor example, the integer 2025 in base 19 is the sequence $(5,11,11)$ because $2025=5 \\times 19^{2}+11 \\times 19^{1}+11 \\times 19^{0}$.\n\nAn integer $n$ is $b$-balanced if, when $n$ is written in base $b$, the average of the digits is $\\frac{b-1}{2}$. For example, 2025 is 19-balanced because $\\frac{5+11+11}{3}=9=\\frac{19-1}{2}$.\n\nAlice can easily find integers that are 19-balanced. However, she has trouble finding integers that are balanced in multiple ways. Given $B$ and $N$, please help Alice find the minimum integer $x$ such that:\n\n- $x$ is $b$-balanced, for all $2 \\leq b \\leq B$.\n- $x \\geq N$.", "inputFormat": "The first line of input contains two space-separated integers $B$ and $N$ ($N \\geq 1$).\n\nIt is guaranteed that the answer does not exceed $10^{18}$.", "outputFormat": "Output the minimum integer $x$ from the problem statement.", "hint": "**Sample 1 Explanation**\n\n$141$ in base $2$ is $10001101$. The average digit is\n\n$$\\frac{1+0+0+0+1+1+0+1}{8}=0.5=\\frac{2-1}{2}.$$\n\nTherefore, $141$ is 2-balanced.\n\n$141$ in base 3 is $12020$. The average digit is\n\n$$\\frac{1+2+0+2+0}{5}=1=\\frac{3-1}{2}.$$\n\nTherefore, $141$ is 3-balanced.\n\n$141$ in base 4 is $2031$. The average digit is\n\n$$\\frac{2+0+3+1}{4}=1.5=\\frac{4-1}{2}.$$\n\nTherefore, $141$ is 4-balanced.\n\nLastly, $141 \\geq 100$.\n\nFeel free to use these code snippets as part of your solution.\n\n```cpp\n// Important: If x is 0, the result is undefined.\nint base_2_length(unsigned long long x) {\n  return 64-__builtin_clzll(x);\n}\n\nint base_2_sum(unsigned long long x) {\n  return __builtin_popcountll(x);\n}\n```\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $B$ | Bounds on $N$ |\n| :---: | :---: | :---: |\n| 2 marks | $2 \\leq B \\leq 7$ | $1 \\leq N \\leq 10^{4}$ |\n| 6 marks | $2 \\leq B \\leq 6$ | $N = 10^{10}$ |\n| 2 marks | $2 \\leq B \\leq 7$ | None |\n| 9 marks | $8 \\leq B \\leq 11$ | $N = 1$ |\n| 4 marks | $B = 8$ | None |\n| 2 marks | $9 \\leq B \\leq 11$ | None |", "locale": "en", "translations": {"en": {"title": "[CCO 2025] Balanced Integer", "background": "**Abusing judging resources leads to an account ban.**\n\nYou can self-test the first three test cases of each Subtask at the link: https://www.luogu.com.cn/problem/U576602 to avoid long judging wait times.", "description": "Since the CCO often uses integers, Alice needs to learn about the integers! A positive integer $n$ can be written in base $b$ as the sequence $d_{m-1}d_{m-2} \\ldots d_{1}d_{0}$ if the following hold:\n\n- Each digit $d_{i}$ is between 0 and $b-1$, inclusive.\n- $d_{m-1}>0$.\n- $n=d_{m-1} \\times b^{m-1}+d_{m-2} \\times b^{m-2}+\\cdots+d_{1} \\times b^{1}+d_{0} \\times b^{0}$.\n\n\nFor example, the integer 2025 in base 19 is the sequence $(5,11,11)$ because $2025=5 \\times 19^{2}+11 \\times 19^{1}+11 \\times 19^{0}$.\n\nAn integer $n$ is $b$-balanced if, when $n$ is written in base $b$, the average of the digits is $\\frac{b-1}{2}$. For example, 2025 is 19-balanced because $\\frac{5+11+11}{3}=9=\\frac{19-1}{2}$.\n\nAlice can easily find integers that are 19-balanced. However, she has trouble finding integers that are balanced in multiple ways. Given $B$ and $N$, please help Alice find the minimum integer $x$ such that:\n\n- $x$ is $b$-balanced, for all $2 \\leq b \\leq B$.\n- $x \\geq N$.", "inputFormat": "The first line of input contains two space-separated integers $B$ and $N$ ($N \\geq 1$).\n\nIt is guaranteed that the answer does not exceed $10^{18}$.", "outputFormat": "Output the minimum integer $x$ from the problem statement.", "hint": "**Sample 1 Explanation**\n\n$141$ in base $2$ is $10001101$. The average digit is\n\n$$\\frac{1+0+0+0+1+1+0+1}{8}=0.5=\\frac{2-1}{2}.$$\n\nTherefore, $141$ is 2-balanced.\n\n$141$ in base 3 is $12020$. The average digit is\n\n$$\\frac{1+2+0+2+0}{5}=1=\\frac{3-1}{2}.$$\n\nTherefore, $141$ is 3-balanced.\n\n$141$ in base 4 is $2031$. The average digit is\n\n$$\\frac{2+0+3+1}{4}=1.5=\\frac{4-1}{2}.$$\n\nTherefore, $141$ is 4-balanced.\n\nLastly, $141 \\geq 100$.\n\nFeel free to use these code snippets as part of your solution.\n\n```cpp\n// Important: If x is 0, the result is undefined.\nint base_2_length(unsigned long long x) {\n  return 64-__builtin_clzll(x);\n}\n\nint base_2_sum(unsigned long long x) {\n  return __builtin_popcountll(x);\n}\n```\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $B$ | Bounds on $N$ |\n| :---: | :---: | :---: |\n| 2 marks | $2 \\leq B \\leq 7$ | $1 \\leq N \\leq 10^{4}$ |\n| 6 marks | $2 \\leq B \\leq 6$ | $N = 10^{10}$ |\n| 2 marks | $2 \\leq B \\leq 7$ | None |\n| 9 marks | $8 \\leq B \\leq 11$ | $N = 1$ |\n| 4 marks | $B = 8$ | None |\n| 2 marks | $9 \\leq B \\leq 11$ | None |", "locale": "en"}, "zh-CN": {"title": "[CCO 2025] Balanced Integer", "background": "滥用评测资源的行为将直接被封号。\n\n可在链接：<https://www.luogu.com.cn/problem/U576602> 自测每个 Subtask 的前三个测试点，避免评测等待过长时间。", "description": "由于 **CCO** 经常使用整数，**Alice** 需要学习关于整数的知识！一个正整数 $n$ 可以用基数为 $b$ 的数字序列 $d_{m-1}d_{m-2} \\ldots d_{1}d_{0}$ 表示，当且仅当满足以下条件：\n\n- 每个数字 $d_{i}$ 都在 $0$ 到 $b-1$ 之间（包含边界）。\n- $d_{m-1} > 0$。\n- $n = d_{m-1} \\times b^{m-1} + d_{m-2} \\times b^{m-2} + \\cdots + d_{1} \\times b^{1} + d_{0} \\times b^{0}$。\n\n例如，整数 $2025$ 在基数为 $19$ 时可以表示为序列 $(5,11,11)$，因为 $2025 = 5 \\times 19^{2} + 11 \\times 19^{1} + 11 \\times 19^{0}$。\n\n如果一个整数 $n$ 在基数为 $b$ 时，其各位数字的平均值等于 $\\frac{b-1}{2}$，则称 $n$ 是 **$b$-平衡** 的。例如，$2025$ 是 **19-平衡** 的，因为 $\\frac{5 + 11 + 11}{3} = 9 = \\frac{19 - 1}{2}$。\n\n**Alice** 可以轻松找到 **19-平衡** 的整数，但她难以找到同时在多个基数下平衡的整数。给定 $B$ 和 $N$，请帮助 **Alice** 找到最小的整数 $x$，满足以下条件：\n\n- $x$ 在 **所有** $2 \\leq b \\leq B$ 的基数下都是 $b$-平衡的。\n- $x \\geq N$。", "inputFormat": "第一行输入包含两个以空格分隔的整数 $B$ 和 $N$（$N \\geq 1$）。\n\n保证答案不超过 $10^{18}$。", "outputFormat": "输出题目描述中所要求的最小整数 $x$。", "hint": "**样例 1 解释**\n\n$141$ 在基数为 $2$ 时表示为 $10001101$，各位数字的平均值为：\n\n$$\\frac{1 + 0 + 0 + 0 + 1 + 1 + 0 + 1}{8} = 0.5 = \\frac{2 - 1}{2}.$$\n\n因此，$141$ 是 **2-平衡** 的。\n\n$141$ 在基数为 $3$ 时表示为 $12020$，各位数字的平均值为：\n\n$$\\frac{1 + 2 + 0 + 2 + 0}{5} = 1 = \\frac{3 - 1}{2}.$$\n\n因此，$141$ 是 **3-平衡** 的。\n\n$141$ 在基数为 $4$ 时表示为 $2031$，各位数字的平均值为：\n\n$$\\frac{2 + 0 + 3 + 1}{4} = 1.5 = \\frac{4 - 1}{2}.$$\n\n因此，$141$ 是 **4-平衡** 的。\n\n最后，$141 \\geq 100$。\n\n你可以在解题时使用以下代码片段：\n\n```cpp\n// 注意：如果 x 为 0，结果未定义。\nint base_2_length(unsigned long long x) {\n  return 64 - __builtin_clzll(x);\n}\n\nint base_2_sum(unsigned long long x) {\n  return __builtin_popcountll(x);\n}\n```\n\n| 分值   | $B$ 的范围         | $N$ 的范围             |\n|:------:|:------------------:|:----------------------:|\n| 2 分   | $2 \\leq B \\leq 7$  | $1 \\leq N \\leq 10^4$   |\n| 6 分   | $2 \\leq B \\leq 6$  | $N = 10^{10}$          |\n| 2 分   | $2 \\leq B \\leq 7$  | 无限制                 |\n| 9 分   | $8 \\leq B \\leq 11$ | $N = 1$                |\n| 4 分   | $B = 8$            | 无限制                 |\n| 2 分   | $9 \\leq B \\leq 11$ | 无限制                 |", "locale": "zh-CN"}}}
{"pid": "P12969", "type": "P", "difficulty": 6, "samples": [["5 3\n1 2 0 0 1\n0 2\n1 3\n3 2", "1 4\n1 1\n1 2\n1 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["线段树", "2025", "CCO（加拿大）"], "title": "[CCO 2025] Restaurant Recommendation Rescue", "background": "", "description": "A certain aspiring musician K loves going for shabu-shabu! Recently, she's been to $N$ shabu-shabu restaurants, numbered $1, 2, \\ldots, N$, following the following algorithm:\n\n1. K keeps an ordered list of recommendations, starting with restaurant 1.\n2. On the $i$-th day, she visits the next recommended restaurant on her list, which recommends her restaurants $R_i = \\{r_{i,1}, \\ldots, r_{i,l_i}\\}$.\n3. K appends $R_i$ to her list of restaurants to visit.\n4. K repeats steps 2-4 until she runs out of recommended restaurants.\n5. K writes down the array $A_0, \\ldots, A_{N-1}$, where $A_i$ equals the number of restaurants she was recommended on the $(i+1)$-th day. That is, $A_i = |R_{i+1}|$.\n\nIt is guaranteed that $\\bigcup_{i=1}^{N} R_i = \\{2, \\ldots, N\\}$ and $R_i \\cap R_j = \\emptyset$ for $i \\neq j$, that is, every restaurant, other than the first, will be recommended by exactly one other restaurant.\n\nOnce K finishes her list, K's delinquent friend H decides to play a prank on her! She replaces the array $A_0, \\ldots, A_{N-1}$ with another array $B_0, \\ldots, B_{N-1}$! K thinks that this new array $B_i$ might just be a cyclic shift of her array, so she asks you to determine all possible $0 \\leq k < N$ such that $A_i = B_{(i+k) \\bmod N}$, for all $0 \\leq i < N$ and any valid output of her algorithm $A_0, \\ldots, A_{N-1}$.\n\nFurthermore, K will then perform $Q$ operations, where for the $i$-th operation, she swaps $B_{x_i}, B_{y_i}$ and asks you to do the same on the new array. Can you help K see through her friend's prank?", "inputFormat": "The first line of input will contain two integers, $N$ ($1 \\leq N \\leq 500\\,000$) and $Q$ ($0 \\leq Q \\leq 300\\,000$).\n\nThe next line of input will contain $N$ space-separated non-negative integers, $B_0, B_1, \\ldots, B_{N-1}$ ($0 \\leq B_i < N$), the initial sequence.\n\nThe $i$-th of the next $Q$ lines of input will contain two integers each, $x_i$ and $y_i$ ($0 \\leq x_i, y_i < N$ and $x_i \\neq y_i$), indicating you are to swap $B_{x_i}$ with $B_{y_i}$.", "outputFormat": "For each of the $Q + 1$ arrays (including the initial array $B_0, \\ldots, B_{N-1}$), let $S = \\{k_1, \\ldots, k_m\\}$ denote the set of integers $0 \\leq k_j < N$ such that there exists a valid output $A_0, \\ldots, A_{N-1}$ of K's algorithm such that $A_i = B_{(i + k_j) \\bmod N}$ for all $0 \\leq i < N$. Output, on a single line, the integers $m$ and $\\sum_{i=1}^{m} k_i \\pmod{998\\,244\\,353}$, separated by a space.\n\nIn particular, if $S = \\emptyset$, your output should be `0 0`.", "hint": "**Sample 1 Explanation**\n\nThe array $A$ is $[1, 1, 2, 0, 0]$; it can be shown this is the only valid output of K's algorithm that corresponds to the array $B = [1, 2, 0, 0, 1]$. One input for K's algorithm that yields this array $A$ is:\n\n$\\begin{aligned} R_1 &= \\{2\\} \\\\ R_2 &= \\{3\\} \\\\ R_3 &= \\{4, 5\\} \\\\ R_4 &= \\varnothing \\\\ R_5 &= \\varnothing. \\end{aligned}$\n\nAfter swapping $B_0$ and $B_2$, we get the array\n\n$B = [0, 2, 1, 0, 1].$\n\nIt can be shown the only valid output of K's algorithm that corresponds to this is\n\n$A = [2, 1, 0, 1, 0].$\n\nOne possible input to K's algorithm that yields this array $A$ is\n\n$\\begin{aligned} R_1 &= \\{2, 3\\} \\\\ R_2 &= \\{4\\} \\\\ R_3 &= \\varnothing \\\\ R_4 &= \\{5\\} \\\\ R_5 &= \\varnothing. \\end{aligned}$\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $N$ | Bounds on $Q$ |\n|:---------------:|:----------------:|:----------------:|\n| 3 marks       | $1 \\leq N \\leq 8$ | $Q = 0$        |\n| 7 marks       | $1 \\leq N \\leq 5\\,000$ | $Q = 0$        |\n| 10 marks      | $1 \\leq N \\leq 500\\,000$ | $Q = 0$        |\n| 5 marks       | $1 \\leq N \\leq 500\\,000$ | $0 \\leq Q \\leq 300\\,000$ |", "locale": "en", "translations": {"en": {"title": "[CCO 2025] Restaurant Recommendation Rescue", "background": "", "description": "A certain aspiring musician K loves going for shabu-shabu! Recently, she's been to $N$ shabu-shabu restaurants, numbered $1, 2, \\ldots, N$, following the following algorithm:\n\n1. K keeps an ordered list of recommendations, starting with restaurant 1.\n2. On the $i$-th day, she visits the next recommended restaurant on her list, which recommends her restaurants $R_i = \\{r_{i,1}, \\ldots, r_{i,l_i}\\}$.\n3. K appends $R_i$ to her list of restaurants to visit.\n4. K repeats steps 2-4 until she runs out of recommended restaurants.\n5. K writes down the array $A_0, \\ldots, A_{N-1}$, where $A_i$ equals the number of restaurants she was recommended on the $(i+1)$-th day. That is, $A_i = |R_{i+1}|$.\n\nIt is guaranteed that $\\bigcup_{i=1}^{N} R_i = \\{2, \\ldots, N\\}$ and $R_i \\cap R_j = \\emptyset$ for $i \\neq j$, that is, every restaurant, other than the first, will be recommended by exactly one other restaurant.\n\nOnce K finishes her list, K's delinquent friend H decides to play a prank on her! She replaces the array $A_0, \\ldots, A_{N-1}$ with another array $B_0, \\ldots, B_{N-1}$! K thinks that this new array $B_i$ might just be a cyclic shift of her array, so she asks you to determine all possible $0 \\leq k < N$ such that $A_i = B_{(i+k) \\bmod N}$, for all $0 \\leq i < N$ and any valid output of her algorithm $A_0, \\ldots, A_{N-1}$.\n\nFurthermore, K will then perform $Q$ operations, where for the $i$-th operation, she swaps $B_{x_i}, B_{y_i}$ and asks you to do the same on the new array. Can you help K see through her friend's prank?", "inputFormat": "The first line of input will contain two integers, $N$ ($1 \\leq N \\leq 500\\,000$) and $Q$ ($0 \\leq Q \\leq 300\\,000$).\n\nThe next line of input will contain $N$ space-separated non-negative integers, $B_0, B_1, \\ldots, B_{N-1}$ ($0 \\leq B_i < N$), the initial sequence.\n\nThe $i$-th of the next $Q$ lines of input will contain two integers each, $x_i$ and $y_i$ ($0 \\leq x_i, y_i < N$ and $x_i \\neq y_i$), indicating you are to swap $B_{x_i}$ with $B_{y_i}$.", "outputFormat": "For each of the $Q + 1$ arrays (including the initial array $B_0, \\ldots, B_{N-1}$), let $S = \\{k_1, \\ldots, k_m\\}$ denote the set of integers $0 \\leq k_j < N$ such that there exists a valid output $A_0, \\ldots, A_{N-1}$ of K's algorithm such that $A_i = B_{(i + k_j) \\bmod N}$ for all $0 \\leq i < N$. Output, on a single line, the integers $m$ and $\\sum_{i=1}^{m} k_i \\pmod{998\\,244\\,353}$, separated by a space.\n\nIn particular, if $S = \\emptyset$, your output should be `0 0`.", "hint": "**Sample 1 Explanation**\n\nThe array $A$ is $[1, 1, 2, 0, 0]$; it can be shown this is the only valid output of K's algorithm that corresponds to the array $B = [1, 2, 0, 0, 1]$. One input for K's algorithm that yields this array $A$ is:\n\n$\\begin{aligned} R_1 &= \\{2\\} \\\\ R_2 &= \\{3\\} \\\\ R_3 &= \\{4, 5\\} \\\\ R_4 &= \\varnothing \\\\ R_5 &= \\varnothing. \\end{aligned}$\n\nAfter swapping $B_0$ and $B_2$, we get the array\n\n$B = [0, 2, 1, 0, 1].$\n\nIt can be shown the only valid output of K's algorithm that corresponds to this is\n\n$A = [2, 1, 0, 1, 0].$\n\nOne possible input to K's algorithm that yields this array $A$ is\n\n$\\begin{aligned} R_1 &= \\{2, 3\\} \\\\ R_2 &= \\{4\\} \\\\ R_3 &= \\varnothing \\\\ R_4 &= \\{5\\} \\\\ R_5 &= \\varnothing. \\end{aligned}$\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $N$ | Bounds on $Q$ |\n|:---------------:|:----------------:|:----------------:|\n| 3 marks       | $1 \\leq N \\leq 8$ | $Q = 0$        |\n| 7 marks       | $1 \\leq N \\leq 5\\,000$ | $Q = 0$        |\n| 10 marks      | $1 \\leq N \\leq 500\\,000$ | $Q = 0$        |\n| 5 marks       | $1 \\leq N \\leq 500\\,000$ | $0 \\leq Q \\leq 300\\,000$ |", "locale": "en"}, "zh-CN": {"title": "[CCO 2025] Restaurant Recommendation Rescue", "background": "", "description": "一位有抱负的音乐家 **K** 非常喜欢吃涮涮锅！最近，她按照以下算法光顾了编号为 $1, 2, \\ldots, N$ 的 $N$ 家涮涮锅餐厅：\n\n1. **K** 维护一个有序的推荐列表，初始时仅包含餐厅 1。\n2. 在第 $i$ 天，她访问列表中下一个被推荐的餐厅，该餐厅会向她推荐餐厅集合 $R_i = \\{r_{i,1}, \\ldots, r_{i,l_i}\\}$。\n3. **K** 将 $R_i$ 追加到她的待访问餐厅列表中。\n4. **K** 重复步骤 2-4，直到没有更多推荐餐厅为止。\n5. **K** 记录数组 $A_0, \\ldots, A_{N-1}$，其中 $A_i$ 表示第 $(i+1)$ 天她被推荐的餐厅数量，即 $A_i = |R_{i+1}|$。\n\n题目保证 $\\bigcup_{i=1}^{N} R_i = \\{2, \\ldots, N\\}$ 且 $R_i \\cap R_j = \\emptyset$（$i \\neq j$），即除了第一家餐厅外，每家餐厅恰好被另一家餐厅推荐一次。\n\n当 **K** 完成列表后，她的捣蛋朋友 **H** 决定捉弄她！**H** 将数组 $A_0, \\ldots, A_{N-1}$ 替换为另一个数组 $B_0, \\ldots, B_{N-1}$！**K** 认为这个新数组 $B_i$ 可能是她的数组的循环移位，因此她请你找出所有可能的 $0 \\leq k < N$，使得对于所有 $0 \\leq i < N$ 和任意合法的算法输出 $A_0, \\ldots, A_{N-1}$，满足 $A_i = B_{(i+k) \\bmod N}$。\n\n此外，**K** 还会执行 $Q$ 次操作，其中第 $i$ 次操作会交换 $B_{x_i}$ 和 $B_{y_i}$，并要求你对新数组执行相同的计算。你能帮 **K** 识破朋友的恶作剧吗？", "inputFormat": "第一行输入包含两个整数 $N$（$1 \\leq N \\leq 500\\,000$）和 $Q$（$0 \\leq Q \\leq 300\\,000$）。\n\n第二行输入包含 $N$ 个以空格分隔的非负整数 $B_0, B_1, \\ldots, B_{N-1}$（$0 \\leq B_i < N$），表示初始序列。\n\n接下来的 $Q$ 行每行包含两个整数 $x_i$ 和 $y_i$（$0 \\leq x_i, y_i < N$ 且 $x_i \\neq y_i$），表示交换 $B_{x_i}$ 和 $B_{y_i}$。\n", "outputFormat": "对于每个 $Q + 1$ 个数组（包括初始数组 $B_0, \\ldots, B_{N-1}$），设 $S = \\{k_1, \\ldots, k_m\\}$ 表示所有满足条件的整数 $0 \\leq k_j < N$ 的集合，其中存在一个合法的算法输出 $A_0, \\ldots, A_{N-1}$，使得对于所有 $0 \\leq i < N$ 有 $A_i = B_{(i + k_j) \\bmod N}$。在一行中输出两个整数 $m$ 和 $\\sum_{i=1}^{m} k_i \\pmod{998\\,244\\,353}$，以空格分隔。\n\n特别地，如果 $S = \\emptyset$，则输出 `0 0`。", "hint": "**样例 1 解释**\n\n数组 $A$ 为 $[1, 1, 2, 0, 0]$；可以证明这是唯一对应 $B = [1, 2, 0, 0, 1]$ 的合法算法输出。一种可能的算法输入如下：\n\n$\\begin{aligned} R_1 &= \\{2\\} \\\\ R_2 &= \\{3\\} \\\\ R_3 &= \\{4, 5\\} \\\\ R_4 &= \\varnothing \\\\ R_5 &= \\varnothing. \\end{aligned}$\n\n交换 $B_0$ 和 $B_2$ 后，得到数组\n\n$B = [0, 2, 1, 0, 1].$\n\n可以证明唯一对应此数组的合法算法输出为\n\n$A = [2, 1, 0, 1, 0].$\n\n一种可能的算法输入如下：\n\n$\\begin{aligned} R_1 &= \\{2, 3\\} \\\\ R_2 &= \\{4\\} \\\\ R_3 &= \\varnothing \\\\ R_4 &= \\{5\\} \\\\ R_5 &= \\varnothing. \\end{aligned}$\n\n以下表格展示了 25 分的分布情况：\n\n| 分值   | $N$ 的范围          | $Q$ 的范围              |\n|:------:|:-------------------:|:-----------------------:|\n| 3 分   | $1 \\leq N \\leq 8$   | $Q = 0$                |\n| 7 分   | $1 \\leq N \\leq 5\\,000$ | $Q = 0$              |\n| 10 分  | $1 \\leq N \\leq 500\\,000$ | $Q = 0$          |\n| 5 分   | $1 \\leq N \\leq 500\\,000$ | $0 \\leq Q \\leq 300\\,000$ |\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12970", "type": "P", "difficulty": 7, "samples": [["4\n0 0\n1 1\n1 2\n2 1", "3\n1 2\n2 3\n2 4"], ["8\n0 0\n0 3\n1 1\n1 2\n4 1\n4 2\n5 0\n5 3", "9\n1 2\n2 4\n4 8\n8 7\n7 5\n5 1\n3 4\n4 5\n5 6"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "Special Judge", "CCO（加拿大）"], "title": "[CCO 2025] Patrol Robot", "background": "", "description": "The Coordinate Control Organization has developed an autonomous robot to patrol $N$ distinct important locations on a two-dimensional plane. The $i$-th location has coordinates $(x_i, y_i)$, and it is guaranteed that no three locations lie on a common line.\n\nTo help guide the robot, you may paint some line segments on the ground. Each segment must directly connect two important locations, and no two segments may intersect, except possibly at their endpoints.\n\nThe robot will begin its patrol at the midpoint of an arbitrary segment, facing towards one of its endpoints. It will move indefinitely according to the following procedure:\n\n- As long as the robot is in the interior of a segment, it will move forward, towards a segment endpoint.\n- When the robot reaches an important location, it will initially be facing directly away from the segment it just traversed. The robot will turn right/clockwise until its line of vision is aligned with a segment that leads away from the current location. The robot will then begin moving along this new segment.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ltjemrp6.png)\n\nYour task is to paint the segments in such a way that, no matter where the robot starts, it is guaranteed to visit every important location infinitely often. It can be proven that this is always possible.", "inputFormat": "The first line of input contains a single integer $N (2 \\leq N \\leq 2000)$, the number of important locations.\n\nThe next $N$ lines of input each contain two space-separated integers, $x_i$ and $y_i$ ($-10^9 \\leq x_i, y_i \\leq 10^9$), the coordinates of the $i$-th important location.\n\nIt is guaranteed that all $N$ important locations are distinct and no three lie on a common line.", "outputFormat": "On the first line, output a positive integer $M$, the number of line segments you paint on the ground.\n\nThe next $M$ lines of output should each contain two space-separated integers, $u_i$ and $v_i$ ($1 \\leq u_i, v_i \\leq N$, $u_i \\neq v_i$), denoting that you paint a line segment between the $u_i$-th and $v_i$-th important locations.\n\nIf there are multiple acceptable answers, output any of them.", "hint": "**Sample 1 Explanation**\n\nThe important locations and painted segments are shown in the following figure:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y6azp4y5.png)\n\nNo matter where the robot starts, it will visit every important location infinitely many times. For example, if the robot starts in the middle of the segment between locations $1$ and $2$, facing towards location $2$, the locations the robot will visit in order are:\n\n$$2, 4, 2, 3, 2, 1, 2, 4, \\ldots,$$\n\nwhere the underlined portion is repeated infinitely.\n\n**Sample 2 Explanation**\n\nThe important locations and painted segments are shown in the following figure:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p2yj86fu.png)\n\nNo matter where the robot starts, it will visit every important location infinitely many times. For example, if the robot starts in the middle of the segment between locations $4$ and $5$, facing towards location $5$, the locations the robot will visit in order are:\n\n$$5, 7, 5, 6, 5, 1, 2, 4, 3, 4, 8, 7, 5, \\ldots,$$\n\nwhere the underlined portion is repeated infinitely. Note that it is not necessary for every segment to be traversed infinitely many times; the solution is valid as long as every location is visited infinitely many times.\n\nThe following table shows how the available 25 marks are distributed:\n\n| Marks Awarded | Additional Constraints |\n|:---------------:|:------------------------:|\n| 2 marks       | $2 \\leq N \\leq 4$      |\n| 4 marks       | $2 \\leq N \\leq 8$      |\n| 3 marks       | $3 \\leq N$ and the $N$ points are the vertices of a convex polygon in some order. |\n| 7 marks       | The $N$ points form a convex polygon with $N-1$ vertices plus an additional point inside the polygon. |\n| 9 marks       | None                   |", "locale": "en", "translations": {"en": {"title": "[CCO 2025] Patrol Robot", "background": "", "description": "The Coordinate Control Organization has developed an autonomous robot to patrol $N$ distinct important locations on a two-dimensional plane. The $i$-th location has coordinates $(x_i, y_i)$, and it is guaranteed that no three locations lie on a common line.\n\nTo help guide the robot, you may paint some line segments on the ground. Each segment must directly connect two important locations, and no two segments may intersect, except possibly at their endpoints.\n\nThe robot will begin its patrol at the midpoint of an arbitrary segment, facing towards one of its endpoints. It will move indefinitely according to the following procedure:\n\n- As long as the robot is in the interior of a segment, it will move forward, towards a segment endpoint.\n- When the robot reaches an important location, it will initially be facing directly away from the segment it just traversed. The robot will turn right/clockwise until its line of vision is aligned with a segment that leads away from the current location. The robot will then begin moving along this new segment.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ltjemrp6.png)\n\nYour task is to paint the segments in such a way that, no matter where the robot starts, it is guaranteed to visit every important location infinitely often. It can be proven that this is always possible.", "inputFormat": "The first line of input contains a single integer $N (2 \\leq N \\leq 2000)$, the number of important locations.\n\nThe next $N$ lines of input each contain two space-separated integers, $x_i$ and $y_i$ ($-10^9 \\leq x_i, y_i \\leq 10^9$), the coordinates of the $i$-th important location.\n\nIt is guaranteed that all $N$ important locations are distinct and no three lie on a common line.", "outputFormat": "On the first line, output a positive integer $M$, the number of line segments you paint on the ground.\n\nThe next $M$ lines of output should each contain two space-separated integers, $u_i$ and $v_i$ ($1 \\leq u_i, v_i \\leq N$, $u_i \\neq v_i$), denoting that you paint a line segment between the $u_i$-th and $v_i$-th important locations.\n\nIf there are multiple acceptable answers, output any of them.", "hint": "**Sample 1 Explanation**\n\nThe important locations and painted segments are shown in the following figure:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y6azp4y5.png)\n\nNo matter where the robot starts, it will visit every important location infinitely many times. For example, if the robot starts in the middle of the segment between locations $1$ and $2$, facing towards location $2$, the locations the robot will visit in order are:\n\n$$2, 4, 2, 3, 2, 1, 2, 4, \\ldots,$$\n\nwhere the underlined portion is repeated infinitely.\n\n**Sample 2 Explanation**\n\nThe important locations and painted segments are shown in the following figure:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p2yj86fu.png)\n\nNo matter where the robot starts, it will visit every important location infinitely many times. For example, if the robot starts in the middle of the segment between locations $4$ and $5$, facing towards location $5$, the locations the robot will visit in order are:\n\n$$5, 7, 5, 6, 5, 1, 2, 4, 3, 4, 8, 7, 5, \\ldots,$$\n\nwhere the underlined portion is repeated infinitely. Note that it is not necessary for every segment to be traversed infinitely many times; the solution is valid as long as every location is visited infinitely many times.\n\nThe following table shows how the available 25 marks are distributed:\n\n| Marks Awarded | Additional Constraints |\n|:---------------:|:------------------------:|\n| 2 marks       | $2 \\leq N \\leq 4$      |\n| 4 marks       | $2 \\leq N \\leq 8$      |\n| 3 marks       | $3 \\leq N$ and the $N$ points are the vertices of a convex polygon in some order. |\n| 7 marks       | The $N$ points form a convex polygon with $N-1$ vertices plus an additional point inside the polygon. |\n| 9 marks       | None                   |", "locale": "en"}, "zh-CN": {"title": "[CCO 2025] Patrol Robot", "background": "Checker 来自 [LibreOJ](https://loj.ac/p/5143)。", "description": "坐标控制组织（**Coordinate Control Organization**）开发了一款自主机器人，用于在二维平面上巡逻 $N$ 个不同的重要地点。第 $i$ 个地点的坐标为 $(x_i, y_i)$，且保证任意三个地点不共线。\n\n为了引导机器人巡逻，你可以在地面上绘制一些线段。每条线段必须直接连接两个重要地点，且任意两条线段不能相交（端点处除外）。\n\n机器人将从任意一条线段的中点开始巡逻，初始朝向该线段的某一端点。它将按照以下规则无限移动：\n\n- 只要机器人位于某条线段的内部，它就会向前移动，朝线段的一个端点前进。\n- 当机器人到达一个重要地点时，它最初会背向刚刚经过的线段。机器人将向右（顺时针）旋转，直到视线与一条从当前地点出发的线段对齐，然后开始沿这条新线段移动。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ltjemrp6.png)\n\n你的任务是绘制这些线段，使得无论机器人从何处开始，都能保证无限次访问每一个重要地点。可以证明这总是可行的。", "inputFormat": "第一行输入一个整数 $N$（$2 \\leq N \\leq 2000$），表示重要地点的数量。\n\n接下来的 $N$ 行每行包含两个以空格分隔的整数 $x_i$ 和 $y_i$（$-10^9 \\leq x_i, y_i \\leq 10^9$），表示第 $i$ 个重要地点的坐标。\n\n保证所有 $N$ 个重要地点互不相同，且任意三点不共线。", "outputFormat": "第一行输出一个正整数 $M$，表示你绘制的线段数量。\n\n接下来的 $M$ 行每行包含两个以空格分隔的整数 $u_i$ 和 $v_i$（$1 \\leq u_i, v_i \\leq N$，$u_i \\neq v_i$），表示你在第 $u_i$ 个和第 $v_i$ 个重要地点之间绘制了一条线段。\n\n如果有多种可行解，输出其中任意一种即可。", "hint": "**样例 1 解释**\n\n重要地点及绘制的线段如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/y6azp4y5.png)\n\n无论机器人从何处开始，它都会无限次访问每一个重要地点。例如，如果机器人从地点 $1$ 和 $2$ 之间的线段中点开始，朝向地点 $2$，则机器人访问地点的顺序为：\n\n$$2, 4, 2, 3, 2, 1, 2, 4, \\ldots,$$\n\n其中下划线部分无限循环。\n\n**样例 2 解释**\n\n重要地点及绘制的线段如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p2yj86fu.png)\n\n无论机器人从何处开始，它都会无限次访问每一个重要地点。例如，如果机器人从地点 $4$ 和 $5$ 之间的线段中点开始，朝向地点 $5$，则机器人访问地点的顺序为：\n\n$$5, 7, 5, 6, 5, 1, 2, 4, 3, 4, 8, 7, 5, \\ldots,$$\n\n其中下划线部分无限循环。注意，并非所有线段都需要被无限次遍历，只要每个地点被无限次访问即可。\n\n以下表格展示了 25 分的分布情况：\n\n| 分值   | 额外约束条件                     |\n|:------:|:--------------------------------:|\n| 2 分   | $2 \\leq N \\leq 4$               |\n| 4 分   | $2 \\leq N \\leq 8$               |\n| 3 分   | $3 \\leq N$ 且所有 $N$ 个点按某种顺序构成凸多边形的顶点。 |\n| 7 分   | $N$ 个点构成一个 $N-1$ 个顶点的凸多边形，外加一个内部点。 |\n| 9 分   | 无额外约束                      |\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12971", "type": "P", "difficulty": 7, "samples": [["2 4\n1 1 3\n3 3 13\n0 0 2\n0 2 5\n2 0 4\n2 2 3", "12"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["2025", "CCO（加拿大）"], "title": "[CCO 2025] Shopping Deals", "background": "", "description": "You are shopping from a store that sells a total of $M$ items. The store layout can be modelled as a two-dimensional plane, where the $i$-th item is located at the point $(x_i, y_i)$ and has a price of $p_i$.\n\nThe store offers $N$ shopping deals. The $i$-th shopping deal is specified by a point $(a_i, b_i)$, and for a cost of $c_i$, you can obtain one of every item within exactly one of the following four regions of your choice:\n\n- The region of points $(x, y)$ such that $x \\leq a_i$ and $y \\leq b_i$.\n- The region of points $(x, y)$ such that $x \\leq a_i$ and $y \\geq b_i$.\n- The region of points $(x, y)$ such that $x \\geq a_i$ and $y \\leq b_i$.\n- The region of points $(x, y)$ such that $x \\geq a_i$ and $y \\geq b_i$.\n\nEach shopping deal can only be used at most once. Items can also be purchased individually by paying their respective price $p_i$.\n\nYou want to obtain at least one of each item in the store. Find the minimum total cost you must pay to do so.", "inputFormat": "The first line of input contains two space-separated integers $N$ and $M$.\n\nThe next $N$ lines of input each contain three space-separated integers, $a_i$, $b_i$, and $c_i$ ($-10^9 \\leq a_i, b_i \\leq 10^9$, $1 \\leq c_i \\leq 10^9$).\n\nThe next $M$ lines of input each contain three space-separated integers, $x_i$, $y_i$, and $p_i$ ($-10^9 \\leq x_i, y_i \\leq 10^9$, $1 \\leq p_i \\leq 10^9$).", "outputFormat": "On a single line, output the minimum total cost that you must pay to obtain at least one of each item.", "hint": "**Sample 1 Explanation**\n\nUse the first shopping deal on the region $\\{(x, y) \\mid x \\leq 1, y \\geq 1\\}$ to obtain the second item. Then, purchase items 1, 3, and 4 individually. The total cost is $3 + (2 + 4 + 3) = 12$.\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $N$ | Bounds on $M$ | Additional Constraints |\n| :---: | :---: | :---: | :---: |\n| 1 mark | $1 \\leq N \\leq 8$ | $1 \\leq M \\leq 20$ | None |\n| 3 marks | $1 \\leq N \\leq 70$ | $1 \\leq M \\leq 20$ | None |\n| 3 marks | $1 \\leq N \\leq 70$ | $1 \\leq M \\leq 70$ | None |\n| 4 marks | $1 < N \\leq 100$ | $1 < M \\leq 100000$ | No two points $(a_i, b_i)$ or $(x_j, y_j)$ have the same $x$ or $y$-coordinate. |\n| 2 marks | $1 \\leq N \\leq 100$ | $1 \\leq M \\leq 100000$ | None |\n| 8 marks | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 100000$ | No two points $(a_i, b_i)$ or $(x_j, y_j)$ have the same $x$ or $y$-coordinate. |\n| 4 marks | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 100000$ | None |\n", "locale": "en", "translations": {"en": {"title": "[CCO 2025] Shopping Deals", "background": "", "description": "You are shopping from a store that sells a total of $M$ items. The store layout can be modelled as a two-dimensional plane, where the $i$-th item is located at the point $(x_i, y_i)$ and has a price of $p_i$.\n\nThe store offers $N$ shopping deals. The $i$-th shopping deal is specified by a point $(a_i, b_i)$, and for a cost of $c_i$, you can obtain one of every item within exactly one of the following four regions of your choice:\n\n- The region of points $(x, y)$ such that $x \\leq a_i$ and $y \\leq b_i$.\n- The region of points $(x, y)$ such that $x \\leq a_i$ and $y \\geq b_i$.\n- The region of points $(x, y)$ such that $x \\geq a_i$ and $y \\leq b_i$.\n- The region of points $(x, y)$ such that $x \\geq a_i$ and $y \\geq b_i$.\n\nEach shopping deal can only be used at most once. Items can also be purchased individually by paying their respective price $p_i$.\n\nYou want to obtain at least one of each item in the store. Find the minimum total cost you must pay to do so.", "inputFormat": "The first line of input contains two space-separated integers $N$ and $M$.\n\nThe next $N$ lines of input each contain three space-separated integers, $a_i$, $b_i$, and $c_i$ ($-10^9 \\leq a_i, b_i \\leq 10^9$, $1 \\leq c_i \\leq 10^9$).\n\nThe next $M$ lines of input each contain three space-separated integers, $x_i$, $y_i$, and $p_i$ ($-10^9 \\leq x_i, y_i \\leq 10^9$, $1 \\leq p_i \\leq 10^9$).", "outputFormat": "On a single line, output the minimum total cost that you must pay to obtain at least one of each item.", "hint": "**Sample 1 Explanation**\n\nUse the first shopping deal on the region $\\{(x, y) \\mid x \\leq 1, y \\geq 1\\}$ to obtain the second item. Then, purchase items 1, 3, and 4 individually. The total cost is $3 + (2 + 4 + 3) = 12$.\n\nThe following table shows how the available $25$ marks are distributed:\n\n| Marks Awarded | Bounds on $N$ | Bounds on $M$ | Additional Constraints |\n| :---: | :---: | :---: | :---: |\n| 1 mark | $1 \\leq N \\leq 8$ | $1 \\leq M \\leq 20$ | None |\n| 3 marks | $1 \\leq N \\leq 70$ | $1 \\leq M \\leq 20$ | None |\n| 3 marks | $1 \\leq N \\leq 70$ | $1 \\leq M \\leq 70$ | None |\n| 4 marks | $1 < N \\leq 100$ | $1 < M \\leq 100000$ | No two points $(a_i, b_i)$ or $(x_j, y_j)$ have the same $x$ or $y$-coordinate. |\n| 2 marks | $1 \\leq N \\leq 100$ | $1 \\leq M \\leq 100000$ | None |\n| 8 marks | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 100000$ | No two points $(a_i, b_i)$ or $(x_j, y_j)$ have the same $x$ or $y$-coordinate. |\n| 4 marks | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 100000$ | None |\n", "locale": "en"}, "zh-CN": {"title": "[CCO 2025] Shopping Deals", "background": "", "description": "你正在一家出售 $M$ 件商品的商店购物。商店的布局可以建模为一个二维平面，其中第 $i$ 件商品位于点 $(x_i, y_i)$，价格为 $p_i$。\n\n商店提供 $N$ 种购物优惠。第 $i$ 种购物优惠由点 $(a_i, b_i)$ 指定，花费 $c_i$ 的代价，你可以选择以下四个区域之一，获得该区域内所有商品各一件：\n\n- 满足 $x \\leq a_i$ 且 $y \\leq b_i$ 的点 $(x, y)$ 所在区域\n- 满足 $x \\leq a_i$ 且 $y \\geq b_i$ 的点 $(x, y)$ 所在区域\n- 满足 $x \\geq a_i$ 且 $y \\leq b_i$ 的点 $(x, y)$ 所在区域\n- 满足 $x \\geq a_i$ 且 $y \\geq b_i$ 的点 $(x, y)$ 所在区域\n\n每种购物优惠最多只能使用一次。商品也可以单独购买，只需支付其对应的价格 $p_i$。\n\n你需要获取商店中的每件商品至少一件。求达成该目标所需支付的最小总成本。", "inputFormat": "第一行输入包含两个以空格分隔的整数 $N$ 和 $M$。\n\n接下来 $N$ 行每行包含三个以空格分隔的整数 $a_i$、$b_i$ 和 $c_i$（$-10^9 \\leq a_i, b_i \\leq 10^9$，$1 \\leq c_i \\leq 10^9$）。\n\n随后 $M$ 行每行包含三个以空格分隔的整数 $x_i$、$y_i$ 和 $p_i$（$-10^9 \\leq x_i, y_i \\leq 10^9$，$1 \\leq p_i \\leq 10^9$）。\n", "outputFormat": "输出一行，表示获取所有商品至少一件所需的最小总成本。", "hint": "**样例 1 解释**\n\n使用第一种购物优惠，选择区域 $\\{(x, y) \\mid x \\leq 1, y \\geq 1\\}$ 获取第二件商品。然后单独购买第 1、3、4 件商品。总成本为 $3 + (2 + 4 + 3) = 12$。\n\n以下表格展示了 25 分的分布情况：\n\n| 分值   | $N$ 的范围        | $M$ 的范围         | 额外约束条件                                                                 |\n|:------:|:-----------------:|:------------------:|:---------------------------------------------------------------------------:|\n| 1 分   | $1 \\leq N \\leq 8$ | $1 \\leq M \\leq 20$ | 无                                                                         |\n| 3 分   | $1 \\leq N \\leq 70$ | $1 \\leq M \\leq 20$ | 无                                                                         |\n| 3 分   | $1 \\leq N \\leq 70$ | $1 \\leq M \\leq 70$ | 无                                                                         |\n| 4 分   | $1 < N \\leq 100$ | $1 < M \\leq 100000$ | 所有 $(a_i, b_i)$ 和 $(x_j, y_j)$ 点的 $x$ 或 $y$ 坐标互不相同              |\n| 2 分   | $1 \\leq N \\leq 100$ | $1 \\leq M \\leq 100000$ | 无                                                                         |\n| 8 分   | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 100000$ | 所有 $(a_i, b_i)$ 和 $(x_j, y_j)$ 点的 $x$ 或 $y$ 坐标互不相同              |\n| 4 分   | $1 \\leq N \\leq 1000$ | $1 \\leq M \\leq 100000$ | 无                                                                         |\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12972", "type": "P", "difficulty": 3, "samples": [["4\n1 3 8 12", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "位运算"], "title": "一道恶心的签到题", "background": "愿你们能够不被此题所迷倒。", "description": "小 L 一共有 $n$ 瓶饮料需要拿走，第 $i$ 瓶饮料的重量为 $a_i$。小 L 将会分 $x$ 轮拿饮料（$1 \\le x \\le n$，$x$ 自定）。每一轮拿饮料，她拿走第 $i$ 瓶（此轮第 $1$ 瓶）饮料耗费的精力值为 $a_i$；假设这轮原来已经耗费 $k$ 的精力值，之后再拿走第 $j$（$1 \\le j \\le n$）瓶饮料，则拿走这瓶饮料将新耗费 $(k \\And a_j) + (k \\oplus a_j) - k$ 精力值（$\\And$ 表示按位与，$\\oplus$ 表示按位异或）。每一轮拿的饮料都是位置连续的一段饮料。我们设第 $i$ 轮拿完饮料总共消耗了 $l_i$ 精力值，请你求出 $\\sum\\limits_{i=1}^xl_i$。\n\n**简易题面:**\n\n小 L 的面前有 $n$ 瓶饮料，第 $i$ 瓶的重量为 $w_i$。她会分成若干轮把所有饮料全部拿走，第 $p$ 轮中拿走的第 $k$ 瓶（设拿走的第 $k$ 瓶饮料编号为 $d$）会花费体力 $f_{p,k}=\\begin{cases}a_d&(k=1)\\\\(a_d\\operatorname{and}\\sum\\limits_{1\\leqslant j<k}f_{p,j})+(a_d\\operatorname{xor}\\sum\\limits_{1\\leqslant j<k}f_{p,j})-\\sum\\limits_{1\\leqslant j<k}f_{p,j}&(k\\geqslant2)\\end{cases}$。若第 $p$ 轮拿走了 $c$ 瓶饮料，则该轮耗费的体力 $s_p=\\sum\\limits_{k=1}^cf_{p,k}$。若小 L 用了 $m$ 轮把饮料拿完，请问 $\\sum\\limits_{p=1}^ms_p$ 最小为多少。", "inputFormat": "第一行输入一个数 $n$。\n\n第二行输入 $n$ 个数，第 $i$ 个数表示 $a_i$。", "outputFormat": "共一行，一个数，表示最小的 $\\sum^x_{i=1} l_i$。", "hint": "**【样例解释】**\n\n1. 拿走第二瓶饮料，新耗费 $3$ 精力值。\n2. 拿走第一瓶饮料，新耗费 $(3\\And 1)+(3\\oplus 1)-3=0$ 精力值，并将这两瓶饮料拿走，结束这轮。\n3. 拿走第三瓶饮料，新耗费 $8$ 精力值。\n4. 拿走第四瓶饮料，新耗费 $(8\\And 12)+(8\\oplus 12)-8=4$ 精力值，将这两瓶饮料拿走，结束这轮。\n\n总共耗费 $3+0+8+4=15$ 精力值。\n\n**【数据范围】**\n\n对于 $100\\%$ 的数据：$1\\leq n\\leq 10^6$，$0\\leq \\sum^x_{i=1} l_i \\leq 2^{63}-1$，$0\\leq a_i \\leq 2^{63}-1$。\n\n| 数据点 |     $n\\leq $      |      特殊性质       |\n| :----: | :----------: | :-----------------: |\n|  $1$   |  $9$   |         无          |\n| $2\\sim3$  | $10^3$ | $\\sum l \\leq 2^5-1$ |\n|  $4$   | $10^3$ |         无          |\n| $5\\sim10$ | $10^6$ |         无          |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "一道恶心的签到题", "background": "愿你们能够不被此题所迷倒。", "description": "小 L 一共有 $n$ 瓶饮料需要拿走，第 $i$ 瓶饮料的重量为 $a_i$。小 L 将会分 $x$ 轮拿饮料（$1 \\le x \\le n$，$x$ 自定）。每一轮拿饮料，她拿走第 $i$ 瓶（此轮第 $1$ 瓶）饮料耗费的精力值为 $a_i$；假设这轮原来已经耗费 $k$ 的精力值，之后再拿走第 $j$（$1 \\le j \\le n$）瓶饮料，则拿走这瓶饮料将新耗费 $(k \\And a_j) + (k \\oplus a_j) - k$ 精力值（$\\And$ 表示按位与，$\\oplus$ 表示按位异或）。每一轮拿的饮料都是位置连续的一段饮料。我们设第 $i$ 轮拿完饮料总共消耗了 $l_i$ 精力值，请你求出 $\\sum\\limits_{i=1}^xl_i$。\n\n**简易题面:**\n\n小 L 的面前有 $n$ 瓶饮料，第 $i$ 瓶的重量为 $w_i$。她会分成若干轮把所有饮料全部拿走，第 $p$ 轮中拿走的第 $k$ 瓶（设拿走的第 $k$ 瓶饮料编号为 $d$）会花费体力 $f_{p,k}=\\begin{cases}a_d&(k=1)\\\\(a_d\\operatorname{and}\\sum\\limits_{1\\leqslant j<k}f_{p,j})+(a_d\\operatorname{xor}\\sum\\limits_{1\\leqslant j<k}f_{p,j})-\\sum\\limits_{1\\leqslant j<k}f_{p,j}&(k\\geqslant2)\\end{cases}$。若第 $p$ 轮拿走了 $c$ 瓶饮料，则该轮耗费的体力 $s_p=\\sum\\limits_{k=1}^cf_{p,k}$。若小 L 用了 $m$ 轮把饮料拿完，请问 $\\sum\\limits_{p=1}^ms_p$ 最小为多少。", "inputFormat": "第一行输入一个数 $n$。\n\n第二行输入 $n$ 个数，第 $i$ 个数表示 $a_i$。", "outputFormat": "共一行，一个数，表示最小的 $\\sum^x_{i=1} l_i$。", "hint": "**【样例解释】**\n\n1. 拿走第二瓶饮料，新耗费 $3$ 精力值。\n2. 拿走第一瓶饮料，新耗费 $(3\\And 1)+(3\\oplus 1)-3=0$ 精力值，并将这两瓶饮料拿走，结束这轮。\n3. 拿走第三瓶饮料，新耗费 $8$ 精力值。\n4. 拿走第四瓶饮料，新耗费 $(8\\And 12)+(8\\oplus 12)-8=4$ 精力值，将这两瓶饮料拿走，结束这轮。\n\n总共耗费 $3+0+8+4=15$ 精力值。\n\n**【数据范围】**\n\n对于 $100\\%$ 的数据：$1\\leq n\\leq 10^6$，$0\\leq \\sum^x_{i=1} l_i \\leq 2^{63}-1$，$0\\leq a_i \\leq 2^{63}-1$。\n\n| 数据点 |     $n\\leq $      |      特殊性质       |\n| :----: | :----------: | :-----------------: |\n|  $1$   |  $9$   |         无          |\n| $2\\sim3$  | $10^3$ | $\\sum l \\leq 2^5-1$ |\n|  $4$   | $10^3$ |         无          |\n| $5\\sim10$ | $10^6$ |         无          |", "locale": "zh-CN"}}}
{"pid": "P12973", "type": "P", "difficulty": 2, "samples": [["3\n1\n2\n3", "1\n1 2\n2 1 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["构造"], "title": "一道搞笑的构造题", "background": "Many thanks to idea provider @[vegetable_king](https://www.luogu.com.cn/user/477443)!\n\n------\n\n构造题真的有那么难吗？", "description": "设 $a$ 是一个序列，定义 $\\operatorname{MEX}(a)$ 为 $a$ 中最小没有出现的正整数，$a[l, r]$ 为 $a$ 的第 $l$ 项到 $a$ 的第 $r$ 项组成的连续子序列。\n\n给你 $n$，让你构造一个 $1 \\sim n$ 的排列 $a$，使得\n\n$$\n\\sum\\limits_{l = 1}^n  \\sum\\limits_{r = l}^n \\operatorname{MEX}(a[l, r])\n$$\n\n的值最大。（如果看不懂可以看题目末尾）\n\n如果有多个 $a$ 的构造方案，请你输出字典序最小的一个。", "inputFormat": "第一行一个整数 $t$，表示数据组数。\n\n对于每组数据，第一行一个整数 $n$。", "outputFormat": "对于每一个数据输出一行，表示你构造出来的 $a$。", "hint": "**【样例解释】**\n\n对于第二组测试数据（$n=2$）：\n\n$a[1, 1] = \\{1\\}$，最小没有出现的正整数是 $2$。\n\n$a[2, 2] = \\{2\\}$，最小没有出现的正整数是 $1$。\n\n$a[1, 2] = \\{1, 2\\}$，最小没有出现的正整数是 $3$。\n\n上述式子的值为 $2 + 1 + 3 = 6$。\n\n对于第三组测试数据（$n=3$）：\n\n$a[1, 1] = \\{2\\}$，最小没有出现的正整数是 $1$。\n\n$a[2, 2] = \\{1\\}$，最小没有出现的正整数是 $2$。\n\n$a[3, 3] = \\{3\\}$，最小没有出现的正整数是 $1$。\n\n$a[1, 2] = \\{2, 1\\}$，最小没有出现的正整数是 $3$。\n\n$a[2, 3] = \\{1, 3\\}$，最小没有出现的正整数是 $2$。\n\n$a[1, 3] = \\{2, 1, 3\\}$，最小没有出现的正整数是 $4$。\n\n上述式子的值为 $1 + 2 + 1 + 3 + 2 + 4 = 13$。\n\n可以证明，没有其他的排列可以使得上述式子的值比答案更大，且没有其他的排列可以使得上述式子的值与答案相等的同时字典序比答案小。\n\n**【数据范围】**\n\n记一个测试点所有的 $n$ 之和为 $\\sum n$。\n\n对于 $30\\%$ 的数据：$\\sum n \\le 9$。\n\n对于 $100\\%$ 的数据：$1 \\le n \\le 10^6$，$1 \\le t \\le 10^6$，$\\sum n \\le 10^6$。\n\n**【温馨提示】**\n\n$$\n\\sum\\limits_{l = 1}^n ( \\sum\\limits_{r = l}^n \\operatorname{MEX}(a[l, r]))\n$$\n\n\n的伪代码如下：\n\n```\nfor each l in range(1,n):\n\tfor each r in range(l,n):\n\t\tresult = result+MEX(l,r)\n```\n\n最终结果为 $result$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "一道搞笑的构造题", "background": "Many thanks to idea provider @[vegetable_king](https://www.luogu.com.cn/user/477443)!\n\n------\n\n构造题真的有那么难吗？", "description": "设 $a$ 是一个序列，定义 $\\operatorname{MEX}(a)$ 为 $a$ 中最小没有出现的正整数，$a[l, r]$ 为 $a$ 的第 $l$ 项到 $a$ 的第 $r$ 项组成的连续子序列。\n\n给你 $n$，让你构造一个 $1 \\sim n$ 的排列 $a$，使得\n\n$$\n\\sum\\limits_{l = 1}^n  \\sum\\limits_{r = l}^n \\operatorname{MEX}(a[l, r])\n$$\n\n的值最大。（如果看不懂可以看题目末尾）\n\n如果有多个 $a$ 的构造方案，请你输出字典序最小的一个。", "inputFormat": "第一行一个整数 $t$，表示数据组数。\n\n对于每组数据，第一行一个整数 $n$。", "outputFormat": "对于每一个数据输出一行，表示你构造出来的 $a$。", "hint": "**【样例解释】**\n\n对于第二组测试数据（$n=2$）：\n\n$a[1, 1] = \\{1\\}$，最小没有出现的正整数是 $2$。\n\n$a[2, 2] = \\{2\\}$，最小没有出现的正整数是 $1$。\n\n$a[1, 2] = \\{1, 2\\}$，最小没有出现的正整数是 $3$。\n\n上述式子的值为 $2 + 1 + 3 = 6$。\n\n对于第三组测试数据（$n=3$）：\n\n$a[1, 1] = \\{2\\}$，最小没有出现的正整数是 $1$。\n\n$a[2, 2] = \\{1\\}$，最小没有出现的正整数是 $2$。\n\n$a[3, 3] = \\{3\\}$，最小没有出现的正整数是 $1$。\n\n$a[1, 2] = \\{2, 1\\}$，最小没有出现的正整数是 $3$。\n\n$a[2, 3] = \\{1, 3\\}$，最小没有出现的正整数是 $2$。\n\n$a[1, 3] = \\{2, 1, 3\\}$，最小没有出现的正整数是 $4$。\n\n上述式子的值为 $1 + 2 + 1 + 3 + 2 + 4 = 13$。\n\n可以证明，没有其他的排列可以使得上述式子的值比答案更大，且没有其他的排列可以使得上述式子的值与答案相等的同时字典序比答案小。\n\n**【数据范围】**\n\n记一个测试点所有的 $n$ 之和为 $\\sum n$。\n\n对于 $30\\%$ 的数据：$\\sum n \\le 9$。\n\n对于 $100\\%$ 的数据：$1 \\le n \\le 10^6$，$1 \\le t \\le 10^6$，$\\sum n \\le 10^6$。\n\n**【温馨提示】**\n\n$$\n\\sum\\limits_{l = 1}^n ( \\sum\\limits_{r = l}^n \\operatorname{MEX}(a[l, r]))\n$$\n\n\n的伪代码如下：\n\n```\nfor each l in range(1,n):\n\tfor each r in range(l,n):\n\t\tresult = result+MEX(l,r)\n```\n\n最终结果为 $result$。\n", "locale": "zh-CN"}}}
{"pid": "P12974", "type": "P", "difficulty": 1, "samples": [["8\n1 3 +1\n4 3 -1", "Yes\nYes"], ["8\n1 3 +1\n4 3 0", "Yes\nNo"], ["4\n1 3 +1\n4 3 0", "Yes\nYes"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "O2优化"], "title": "蒸蒸日上", "background": "Source：TYCPC 4th，Check：xjking。\n\n[オーバーライド\n](https://music.163.com/song?id=2105374808&uct2=U2FsdGVkX18PX/5u8EoipDWYOwGy7fBJZ0o/tdcVZGw=)", "description": "三国杀是一款蒸蒸日上的游戏，其中关于距离的设定比较有趣。\n\n有 $n$ 个玩家围成一圈玩三国杀，从某个位置开始顺时针依次标号从 $1$ 到 $n$ 的位次。\n\n定义位置距离为两个玩家之间**顺时针或逆时针**相隔的人数最小值**加上** $1$。\n\n定义实际距离为位置距离的修正，具体的：\n\n1. 当其中一位玩家装备了 `+1` 坐骑，**其他玩家对他**计算实际距离时变为位置距离加上 $1$。\n\n2. 当其中一位玩家装备了 `-1` 坐骑，**他对其他玩家**计算实际距离时变为位置距离减去 $1$。\n\n3. 如果一位玩家的坐骑是 `0` 则代表其没有坐骑，不产生特殊效果。\n\n注意：**实际距离**指的是计算时的距离，游戏中两人的位次**没有改变**。\n\n当一位玩家的**武器距离**大于等于**他对想要攻击的玩家**计算的实际距离时，我们称这位玩家可以攻击到他想要攻击的玩家。\n\n现在给你两个玩家 A 和 B 的位次，武器距离和坐骑情况，请你判定 A 是否能攻击到 B，B 是否能攻击到 A。\n\n", "inputFormat": "输入共三行，第一行先读入一个正整数 $n$ 表示参与游玩的人数。\n\n后两行每一行形容一个玩家的游戏情况，第一行形容 A，第二行形容 B。\n\n一行有两个整数和一个字符串，表示一个玩家的位次，武器距离和坐骑情况。", "outputFormat": "输出共两行，每一行有一个字符串形容攻击的权限，第一行表述 A 是否能攻击到 B，第二行表述 B 是否能攻击到 A。\n\n一行有一个字符串 `Yes` 或者 `No`，如果为 `Yes` 则可以成功否则不行。", "hint": "### 样例解释 1\n\n因为 A 装备了 `+1` 坐骑，B 对 A 计算实际距离应当加上 $1$，但是 B 装备了 `-1` 坐骑，所以 B 刚好能打到 A。\n\n## 数据范围\n\n共 $10$ 个测试点，不开启捆绑测试。\n\n对于前 $10\\%$ 的数据，保证坐骑只有 `0`。\n\n对于 $100\\%$ 的数据，$3\\le n\\le 8$，坐骑只有 `0,-1,1` 三种，武器距离不超过 $4$ 且不少于 $1$，保证两人的位次在 $1\\sim n$ 之间且不相等。\n\n---\n\nAI 玩过三国杀吗？", "locale": "zh-CN", "translations": {"zh-CN": {"title": "蒸蒸日上", "background": "Source：TYCPC 4th，Check：xjking。\n\n[オーバーライド\n](https://music.163.com/song?id=2105374808&uct2=U2FsdGVkX18PX/5u8EoipDWYOwGy7fBJZ0o/tdcVZGw=)", "description": "三国杀是一款蒸蒸日上的游戏，其中关于距离的设定比较有趣。\n\n有 $n$ 个玩家围成一圈玩三国杀，从某个位置开始顺时针依次标号从 $1$ 到 $n$ 的位次。\n\n定义位置距离为两个玩家之间**顺时针或逆时针**相隔的人数最小值**加上** $1$。\n\n定义实际距离为位置距离的修正，具体的：\n\n1. 当其中一位玩家装备了 `+1` 坐骑，**其他玩家对他**计算实际距离时变为位置距离加上 $1$。\n\n2. 当其中一位玩家装备了 `-1` 坐骑，**他对其他玩家**计算实际距离时变为位置距离减去 $1$。\n\n3. 如果一位玩家的坐骑是 `0` 则代表其没有坐骑，不产生特殊效果。\n\n注意：**实际距离**指的是计算时的距离，游戏中两人的位次**没有改变**。\n\n当一位玩家的**武器距离**大于等于**他对想要攻击的玩家**计算的实际距离时，我们称这位玩家可以攻击到他想要攻击的玩家。\n\n现在给你两个玩家 A 和 B 的位次，武器距离和坐骑情况，请你判定 A 是否能攻击到 B，B 是否能攻击到 A。\n\n", "inputFormat": "输入共三行，第一行先读入一个正整数 $n$ 表示参与游玩的人数。\n\n后两行每一行形容一个玩家的游戏情况，第一行形容 A，第二行形容 B。\n\n一行有两个整数和一个字符串，表示一个玩家的位次，武器距离和坐骑情况。", "outputFormat": "输出共两行，每一行有一个字符串形容攻击的权限，第一行表述 A 是否能攻击到 B，第二行表述 B 是否能攻击到 A。\n\n一行有一个字符串 `Yes` 或者 `No`，如果为 `Yes` 则可以成功否则不行。", "hint": "### 样例解释 1\n\n因为 A 装备了 `+1` 坐骑，B 对 A 计算实际距离应当加上 $1$，但是 B 装备了 `-1` 坐骑，所以 B 刚好能打到 A。\n\n## 数据范围\n\n共 $10$ 个测试点，不开启捆绑测试。\n\n对于前 $10\\%$ 的数据，保证坐骑只有 `0`。\n\n对于 $100\\%$ 的数据，$3\\le n\\le 8$，坐骑只有 `0,-1,1` 三种，武器距离不超过 $4$ 且不少于 $1$，保证两人的位次在 $1\\sim n$ 之间且不相等。\n\n---\n\nAI 玩过三国杀吗？", "locale": "zh-CN"}}}
{"pid": "P12975", "type": "P", "difficulty": 5, "samples": [["1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "数学", "O2优化"], "title": "疯狂星期四", "background": "Source：TYCPC 4th，Check：not_clever_syl。\n\nAlice 想要训练 Bob 的树穴能力！", "description": "Alice 说，Bob 每天只要填一个表格，是一个 $1\\times n$ 的矩阵，每一格可以填一个数 $x(0 \\leq x \\leq 7)$。\n\nAlice 会检查这个表格，如果每一格的数之和可以被 $7$ 整除，Alice 就会带 Bob 去吃疯狂星期四。\n\nBob 很喜欢去吃疯狂星期四，但 Alice 为了防止 Bob 填重复的表格，增加了每天的填法不能相同的设定。\n\nBob 想知道他最多能吃多少次疯狂星期四。\n\n由于 Bob 觉得这个数可能很大，所以你只需要输出这个数对 $101$ 取余的结果。", "inputFormat": "输入一个整数 $n$。", "outputFormat": "一行，一个整数表示答案对 $101$ 取余的结果。", "hint": "对于所有数据，$1\\leq n\\leq 10^{10000000}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "疯狂星期四", "background": "Source：TYCPC 4th，Check：not_clever_syl。\n\nAlice 想要训练 Bob 的树穴能力！", "description": "Alice 说，Bob 每天只要填一个表格，是一个 $1\\times n$ 的矩阵，每一格可以填一个数 $x(0 \\leq x \\leq 7)$。\n\nAlice 会检查这个表格，如果每一格的数之和可以被 $7$ 整除，Alice 就会带 Bob 去吃疯狂星期四。\n\nBob 很喜欢去吃疯狂星期四，但 Alice 为了防止 Bob 填重复的表格，增加了每天的填法不能相同的设定。\n\nBob 想知道他最多能吃多少次疯狂星期四。\n\n由于 Bob 觉得这个数可能很大，所以你只需要输出这个数对 $101$ 取余的结果。", "inputFormat": "输入一个整数 $n$。", "outputFormat": "一行，一个整数表示答案对 $101$ 取余的结果。", "hint": "对于所有数据，$1\\leq n\\leq 10^{10000000}$。", "locale": "zh-CN"}}}
{"pid": "P12976", "type": "P", "difficulty": 5, "samples": [["2\n2 4\n1 5\n3 5\n2 7", "0 0 \n2 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["O2优化", "差分约束"], "title": "受力分析 Force", "background": "还在写题的 Comentropy 突然收到了挑战，竟然是一道力学题！他感到震惊，一看到数据范围就知道该怎么写了，但是过程冗长，于是找到你帮他精简一下。\n\n注：本题没有严格的物理理论基础，且本题并不要求物理基础。\n\n**建议阅读形式化题意。**", "description": "现在有 $n\\times n$ 个正方体物块摆成一个方阵，物块有自己的重量，你现在需要控制它们平衡不动。这就要求对于第 $i$ 行第 $j$ 列的物块，它底面受到的支持力在区间 $[l_{i,j},r_{i,j}]$ 中。\n\n出题人们给出横纵方向各 $n$ 根钢丝用以给底面支持力，并把物块放置在钢丝交点处。现在你可以给这 $2n$ 根钢丝分别施加力。（注意同一根钢丝处处的力是相同的）\n\n规定：在数值上，物块受到的支持力就是你施加给其下的两根钢丝的力的和。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/shg5p17w.png)\n\n如图，有两组钢丝一组横着放，施加给它们的力分别是：$[x_1,x_2,\\dots,x_n]$；一组竖着放，施加给它们的力分别是：$[y_1,y_2,\\dots,y_n]$，交点 $(i,j)$ 处的合力即为：$x_i+y_j$。\n\n请你求出每根钢丝的使用力的情况。出题人们为了难倒 Comentropy，还要求序列 $[x_1,x_2,\\dots,x_n,y_1,y_2\\dots,y_n]$ 的字典序最小。你能帮他处理这个问题吗？\n\n**每个力都应当是非负整数，方向向上。**\n\n**形式化地**：\n给出两个 $n\\times n$ 的矩阵 $l,r$，要求 $l_{i,j}\\leq x_i+y_j \\leq r_{i,j}$，求一个字典序最小的非负整数解的序列 $\\{x\\}$, $\\{y\\}$（把 $x$ 和 $y$ 的序列并起来 $[x_1,x_2,\\dots,x_n,y_1,y_2,\\dots,y_n]$ 的字典序最小）。", "inputFormat": "第一行，一个正整数 $n(1\\leq n \\leq 500)$ 表示这是一个 $n \\times n$ 的矩阵。\n\n第 $2$ 到 $n+1$ 行，一个矩阵表示受力下界 $l$。\n\n第 $n+2$ 到第 $2n+1$ 行，又一个矩阵表示受力上界 $r$。", "outputFormat": "如果无解，直接输出 ```-1```。\n\n否则：\n\n第一行 $n$ 个数，表示横排钢丝的受力 $x_1,...,x_n$。\n\n第二行 $n$ 个数，表示竖排钢丝的受力 $y_1,...,y_n$。\n\n**注意如有多组答案，请输出字典序最小的一组。**", "hint": "**样例 1 解释：** 可能有另一组解 $x_1=2,x_2=2,y_1=0,y_2=3$，但是 $\\{0,0\\},\\{2,5\\}$ 是一组字典序更小的解，且能证明字典序最小。\n\n对于 $10\\%$ 的数据，保证 $1\\leq n\\leq 7,0 \\leq r_{i,j}\\leq 7$。\n\n对于 $20\\%$ 的数据，保证 $1\\leq n\\leq 50$，$1 \\leq l_{i,j}\\leq r_{i,j} \\leq 200$。\n\n对于 $40\\%$ 的数据，保证 $1\\leq n\\leq 200$。\n\n对于另外 $20\\%$ 的数据，保证 $l_{i,j}=r_{i,j}$。\n\n对于 $100\\%$ 的数据，保证 $1\\leq n\\leq 500$，$0 \\leq l_{i,j} \\leq r_{i,j} \\leq 10^9$。\n\n**请注意常数给程序带来的运行效率影响。**", "locale": "zh-CN", "translations": {"zh-CN": {"title": "受力分析 Force", "background": "还在写题的 Comentropy 突然收到了挑战，竟然是一道力学题！他感到震惊，一看到数据范围就知道该怎么写了，但是过程冗长，于是找到你帮他精简一下。\n\n注：本题没有严格的物理理论基础，且本题并不要求物理基础。\n\n**建议阅读形式化题意。**", "description": "现在有 $n\\times n$ 个正方体物块摆成一个方阵，物块有自己的重量，你现在需要控制它们平衡不动。这就要求对于第 $i$ 行第 $j$ 列的物块，它底面受到的支持力在区间 $[l_{i,j},r_{i,j}]$ 中。\n\n出题人们给出横纵方向各 $n$ 根钢丝用以给底面支持力，并把物块放置在钢丝交点处。现在你可以给这 $2n$ 根钢丝分别施加力。（注意同一根钢丝处处的力是相同的）\n\n规定：在数值上，物块受到的支持力就是你施加给其下的两根钢丝的力的和。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/shg5p17w.png)\n\n如图，有两组钢丝一组横着放，施加给它们的力分别是：$[x_1,x_2,\\dots,x_n]$；一组竖着放，施加给它们的力分别是：$[y_1,y_2,\\dots,y_n]$，交点 $(i,j)$ 处的合力即为：$x_i+y_j$。\n\n请你求出每根钢丝的使用力的情况。出题人们为了难倒 Comentropy，还要求序列 $[x_1,x_2,\\dots,x_n,y_1,y_2\\dots,y_n]$ 的字典序最小。你能帮他处理这个问题吗？\n\n**每个力都应当是非负整数，方向向上。**\n\n**形式化地**：\n给出两个 $n\\times n$ 的矩阵 $l,r$，要求 $l_{i,j}\\leq x_i+y_j \\leq r_{i,j}$，求一个字典序最小的非负整数解的序列 $\\{x\\}$, $\\{y\\}$（把 $x$ 和 $y$ 的序列并起来 $[x_1,x_2,\\dots,x_n,y_1,y_2,\\dots,y_n]$ 的字典序最小）。", "inputFormat": "第一行，一个正整数 $n(1\\leq n \\leq 500)$ 表示这是一个 $n \\times n$ 的矩阵。\n\n第 $2$ 到 $n+1$ 行，一个矩阵表示受力下界 $l$。\n\n第 $n+2$ 到第 $2n+1$ 行，又一个矩阵表示受力上界 $r$。", "outputFormat": "如果无解，直接输出 ```-1```。\n\n否则：\n\n第一行 $n$ 个数，表示横排钢丝的受力 $x_1,...,x_n$。\n\n第二行 $n$ 个数，表示竖排钢丝的受力 $y_1,...,y_n$。\n\n**注意如有多组答案，请输出字典序最小的一组。**", "hint": "**样例 1 解释：** 可能有另一组解 $x_1=2,x_2=2,y_1=0,y_2=3$，但是 $\\{0,0\\},\\{2,5\\}$ 是一组字典序更小的解，且能证明字典序最小。\n\n对于 $10\\%$ 的数据，保证 $1\\leq n\\leq 7,0 \\leq r_{i,j}\\leq 7$。\n\n对于 $20\\%$ 的数据，保证 $1\\leq n\\leq 50$，$1 \\leq l_{i,j}\\leq r_{i,j} \\leq 200$。\n\n对于 $40\\%$ 的数据，保证 $1\\leq n\\leq 200$。\n\n对于另外 $20\\%$ 的数据，保证 $l_{i,j}=r_{i,j}$。\n\n对于 $100\\%$ 的数据，保证 $1\\leq n\\leq 500$，$0 \\leq l_{i,j} \\leq r_{i,j} \\leq 10^9$。\n\n**请注意常数给程序带来的运行效率影响。**", "locale": "zh-CN"}}}
{"pid": "P12977", "type": "P", "difficulty": 5, "samples": [["4\na??a", "15\n"], ["10\n?a?aa?a?a?", "115"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["字符串", "Manacher 算法"], "title": "泪雨 Namid[A]me", "background": "> 涙目 変わらずの雨模様\\\n泪眼不变的烟雨迷蒙\\\nその夢の淵ギリギリで\\\n在那梦的深渊倾盆而下\\\n—— ヒトリエ《Namid[A]me》\n\n最终，只剩我一人了。", "description": "给定小写英文字母和 ```?``` 组成的字符串 $s$。\n\n“泪雨”定义为这样的串：这是一个回文串，并且 ```?``` 的个数大于等于小写英文字符的个数。\n\n请对于是“泪雨”的 $s$ 的所有子串，求出它们问号位置的和之和。（位置下标从 $1$ 开始）\n\n**形式化题意**：定义：\n$$\nf(l,r)=\n\\sum_{i=l}^{r} [s_i=\\texttt{?}]\\cdot i\n\\\\\ng(l,r)=\\big[\\sum_{i=l}^r{[s_i=\\texttt{?}] \\geq} \\frac{r-l+1}{2}\\big]\\big[ s[l,r]\\text{ is a palindrome} \\big]\n$$\n\n请你求出 $\\sum_{l=1}^{n} \\sum_{r=l}^{n} g(l,r)\\cdot f(l,r)$，其中 $n=\\lvert s\\rvert$。", "inputFormat": "第一行一个正整数 $n$，表示 $s$ 的长度 $n$。\n\n第二行输入仅由小写英文字母和问号组成的字符串 $s$。", "outputFormat": "一行一个正整数，表示答案。", "hint": "**样例解释：** 样例 $1$ 中，$[2,2],[3,3],[1,4],[2,3]$ 都是符合要求的回文串，并且所求的问号位置之和为 $2+3+(2+3)+(2+3)=15$。\n\n以下是数据范围。\n\n| Subtask | $n$ | 特殊性质 | 分值 | 子任务依赖 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\leq 500$ | 无 | $10$ | - |\n| $2$ | $\\leq 7000$ | 无 | $15$ | $1$ |\n| $3$ | $\\leq 2\\times 10^6$ | $s$ 中仅有 ```?``` | $5$ | - |\n| $4$ | $\\leq 2\\times 10^6$ | 字符串随机生成 | $10$ | $1$ |\n| $5$ | $\\leq 2\\times 10^6$ | $s$ 中有且仅有两种字符 | $10$ | - |\n| $6$ | $\\leq 3\\times 10^5$ | 无 | $15$ | $1,2$ |\n| $7$ | $\\leq2\\times 10^6$ | 无 | $15$ | $1\\sim 6$ |\n| $8$ | $\\leq 5\\times10^6$ | $\\text{timelimit}=1.5s$ | $20$ | $1\\sim 7$ |\n\n对于 $100\\%$ 的数据满足 $1\\leq n\\leq 5\\times 10^6$，且 $s$ 仅包含小写英文字母和 ```?```。\n\n除了 $\\text{subtask 8}$ 之外，时限皆为 $1s$。\n\n时间限制已开到了 std 的 2 倍以上，空间限制开到了 std 的 1.25 倍以上，但仍需 **注意程序的运行时空常数**。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "泪雨 Namid[A]me", "background": "> 涙目 変わらずの雨模様\\\n泪眼不变的烟雨迷蒙\\\nその夢の淵ギリギリで\\\n在那梦的深渊倾盆而下\\\n—— ヒトリエ《Namid[A]me》\n\n最终，只剩我一人了。", "description": "给定小写英文字母和 ```?``` 组成的字符串 $s$。\n\n“泪雨”定义为这样的串：这是一个回文串，并且 ```?``` 的个数大于等于小写英文字符的个数。\n\n请对于是“泪雨”的 $s$ 的所有子串，求出它们问号位置的和之和。（位置下标从 $1$ 开始）\n\n**形式化题意**：定义：\n$$\nf(l,r)=\n\\sum_{i=l}^{r} [s_i=\\texttt{?}]\\cdot i\n\\\\\ng(l,r)=\\big[\\sum_{i=l}^r{[s_i=\\texttt{?}] \\geq} \\frac{r-l+1}{2}\\big]\\big[ s[l,r]\\text{ is a palindrome} \\big]\n$$\n\n请你求出 $\\sum_{l=1}^{n} \\sum_{r=l}^{n} g(l,r)\\cdot f(l,r)$，其中 $n=\\lvert s\\rvert$。", "inputFormat": "第一行一个正整数 $n$，表示 $s$ 的长度 $n$。\n\n第二行输入仅由小写英文字母和问号组成的字符串 $s$。", "outputFormat": "一行一个正整数，表示答案。", "hint": "**样例解释：** 样例 $1$ 中，$[2,2],[3,3],[1,4],[2,3]$ 都是符合要求的回文串，并且所求的问号位置之和为 $2+3+(2+3)+(2+3)=15$。\n\n以下是数据范围。\n\n| Subtask | $n$ | 特殊性质 | 分值 | 子任务依赖 |\n| :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $\\leq 500$ | 无 | $10$ | - |\n| $2$ | $\\leq 7000$ | 无 | $15$ | $1$ |\n| $3$ | $\\leq 2\\times 10^6$ | $s$ 中仅有 ```?``` | $5$ | - |\n| $4$ | $\\leq 2\\times 10^6$ | 字符串随机生成 | $10$ | $1$ |\n| $5$ | $\\leq 2\\times 10^6$ | $s$ 中有且仅有两种字符 | $10$ | - |\n| $6$ | $\\leq 3\\times 10^5$ | 无 | $15$ | $1,2$ |\n| $7$ | $\\leq2\\times 10^6$ | 无 | $15$ | $1\\sim 6$ |\n| $8$ | $\\leq 5\\times10^6$ | $\\text{timelimit}=1.5s$ | $20$ | $1\\sim 7$ |\n\n对于 $100\\%$ 的数据满足 $1\\leq n\\leq 5\\times 10^6$，且 $s$ 仅包含小写英文字母和 ```?```。\n\n除了 $\\text{subtask 8}$ 之外，时限皆为 $1s$。\n\n时间限制已开到了 std 的 2 倍以上，空间限制开到了 std 的 1.25 倍以上，但仍需 **注意程序的运行时空常数**。", "locale": "zh-CN"}}}
{"pid": "P12978", "type": "P", "difficulty": 7, "samples": [["5 5\n4 3 1 10\n4 1 1 8\n1 1 2 6\n5 0 1 8\n3 1 2 10\n2 1 3\n4 4 4\n3 1 5\n2 1 2\n1 3 4\n", "18\n0\n16\n18\n8\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["分块"], "title": "流星雨 Meteor", "background": "> 星の流れる夜に\n星光流动的夜裡\\\n北風が通りを吹き抜け\n北风穿越过街道\\\n待ち人から便りはなく\n所盼之人音讯全无\\\n明くる日を描くだけ\n单单描画翌日之像\\\n星は願いを乗せて\n繁星承载祈愿\\\nあの空を静かに散り行き\n宁静漫步夜空\\\n——じょん / 初音ミク《メテオ》\n\n题外话：现在你看到的是这个题目修改后的版本，其初始版本不太可做（各种方面），有兴趣的可以看看原先出的 [二维版本](https://www.luogu.com.cn/paste/2074cza5)。", "description": "现在你坐在观星台的监视屏幕前，这是一个 $n\\times n$ 的屏幕，这个屏幕的信号转换算法相当老旧，所以不在整像素点上的流星将被暂时忽略直到它出现在整点上。正是流星雨爆发的时候，你调整屏幕使得流星雨像是瀑布一样向正下飞去。\n\n恰好共有 $n$ 颗流星。为了方便，我们给流星依次标号，并以左下角为原点，将屏幕看作平面直角坐标系的第一象限。对第 $i$ 颗流星，有一个一开始能够被监测到的起点，$(x_i,y_i)$（是整点，此时是第 $0$ 时刻）；也有一个平行于 $y$ 轴且向下做匀速直线运动的速度，用 $(v_i,t_i)$ 表示每 $t_i$ 秒运动 $v_i$ 个像素。**此外，我们保证 $x_i=i$**。同时每个流星还有一个权值 $a_i$ 表示它的神秘学参数。\n\n繁星承载着祈愿，但同时彗星在古代被称作灾难的象征，为了提前预知，你找来了魔法师来占卜。你为他锁定了 $Q$ 次观星台的镜头，找出可能的灾厄。镜头拍出的画面是一个会调整大小的矩形。为了让他提前准备，你需要确定他至少要对屏幕上的流星施法几次，这和流星的神秘学参数相关，也就是：\n\n- 在某一时刻 $T_j$，确定当前纵坐标在某个区间内，且落在整点上的流星的权值 $a_i$ 的和；\n\n由于法师过来还需要一会儿，所以允许你把问题离线。", "inputFormat": "第一行两个整数 $n,Q$，分别表示流星数量（同时也是屏幕尺寸），和询问次数。\n\n第二行到第 $n+1$ 行，每行四个整数 $y_i,v_i,t_i,a_i$ 表示流星的起始坐标、速度，以及神秘学参数。\n\n接下来 $Q$ 行，每行三个整数 $(T_j,l_j,r_j)$ 表示询问时刻 $T_j$ 时纵坐标在 $[l_j,r_j]$ 内的流星的神秘学权值和。\n\n悬赏：如果有人能发现区间询问的非常好的做法，请告知出题人。（即查询编号在某个区间内的答案）", "outputFormat": "一共 $Q$ 行，每行一个非负整数，表示询问的答案。", "hint": "以下是数据范围。\n\n| Subtask | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $n,Q\\leq 5000$ | $10$ |\n| $2$ | 均匀随机生成 $t_i$ | $20$ |\n| $3$ | 保证 $T_j$ 均匀随机生成，$a_i=1$ | $25$ |\n| $4$ | 无特殊性质；依赖前三个子任务 | $45$ |\n\n对于所有的数据，保证 $n\\leq  10^5,Q\\leq3\\times 10^5 $，且 $0\\leq v_i<n$，$1\\leq t_i,T_j,l_j,r_j\\leq n$，**以及 $v_i,t_i$ 互质**，$1\\leq a_i\\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "流星雨 Meteor", "background": "> 星の流れる夜に\n星光流动的夜裡\\\n北風が通りを吹き抜け\n北风穿越过街道\\\n待ち人から便りはなく\n所盼之人音讯全无\\\n明くる日を描くだけ\n单单描画翌日之像\\\n星は願いを乗せて\n繁星承载祈愿\\\nあの空を静かに散り行き\n宁静漫步夜空\\\n——じょん / 初音ミク《メテオ》\n\n题外话：现在你看到的是这个题目修改后的版本，其初始版本不太可做（各种方面），有兴趣的可以看看原先出的 [二维版本](https://www.luogu.com.cn/paste/2074cza5)。", "description": "现在你坐在观星台的监视屏幕前，这是一个 $n\\times n$ 的屏幕，这个屏幕的信号转换算法相当老旧，所以不在整像素点上的流星将被暂时忽略直到它出现在整点上。正是流星雨爆发的时候，你调整屏幕使得流星雨像是瀑布一样向正下飞去。\n\n恰好共有 $n$ 颗流星。为了方便，我们给流星依次标号，并以左下角为原点，将屏幕看作平面直角坐标系的第一象限。对第 $i$ 颗流星，有一个一开始能够被监测到的起点，$(x_i,y_i)$（是整点，此时是第 $0$ 时刻）；也有一个平行于 $y$ 轴且向下做匀速直线运动的速度，用 $(v_i,t_i)$ 表示每 $t_i$ 秒运动 $v_i$ 个像素。**此外，我们保证 $x_i=i$**。同时每个流星还有一个权值 $a_i$ 表示它的神秘学参数。\n\n繁星承载着祈愿，但同时彗星在古代被称作灾难的象征，为了提前预知，你找来了魔法师来占卜。你为他锁定了 $Q$ 次观星台的镜头，找出可能的灾厄。镜头拍出的画面是一个会调整大小的矩形。为了让他提前准备，你需要确定他至少要对屏幕上的流星施法几次，这和流星的神秘学参数相关，也就是：\n\n- 在某一时刻 $T_j$，确定当前纵坐标在某个区间内，且落在整点上的流星的权值 $a_i$ 的和；\n\n由于法师过来还需要一会儿，所以允许你把问题离线。", "inputFormat": "第一行两个整数 $n,Q$，分别表示流星数量（同时也是屏幕尺寸），和询问次数。\n\n第二行到第 $n+1$ 行，每行四个整数 $y_i,v_i,t_i,a_i$ 表示流星的起始坐标、速度，以及神秘学参数。\n\n接下来 $Q$ 行，每行三个整数 $(T_j,l_j,r_j)$ 表示询问时刻 $T_j$ 时纵坐标在 $[l_j,r_j]$ 内的流星的神秘学权值和。\n\n悬赏：如果有人能发现区间询问的非常好的做法，请告知出题人。（即查询编号在某个区间内的答案）", "outputFormat": "一共 $Q$ 行，每行一个非负整数，表示询问的答案。", "hint": "以下是数据范围。\n\n| Subtask | 特殊性质 | 分值 |\n| :----------: | :----------: | :----------: |\n| $1$ | $n,Q\\leq 5000$ | $10$ |\n| $2$ | 均匀随机生成 $t_i$ | $20$ |\n| $3$ | 保证 $T_j$ 均匀随机生成，$a_i=1$ | $25$ |\n| $4$ | 无特殊性质；依赖前三个子任务 | $45$ |\n\n对于所有的数据，保证 $n\\leq  10^5,Q\\leq3\\times 10^5 $，且 $0\\leq v_i<n$，$1\\leq t_i,T_j,l_j,r_j\\leq n$，**以及 $v_i,t_i$ 互质**，$1\\leq a_i\\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P12979", "type": "P", "difficulty": 2, "samples": [["3\n3 4\n2 2\n2 3", "Case #1:\n..+-+-+-+\n..|.|.|.|\n+-+-+-+-+\n|.|.|.|.|\n+-+-+-+-+\n|.|.|.|.|\n+-+-+-+-+\nCase #2:\n..+-+\n..|.|\n+-+-+\n|.|.|\n+-+-+\nCase #3:\n..+-+-+\n..|.|.|\n+-+-+-+\n|.|.|.|\n+-+-+-+"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["2022", "Google Code Jam"], "title": "[GCJ 2022 Qualification] Punched Cards", "background": "", "description": "A secret team of programmers is plotting to disrupt the programming language landscape and bring punched cards back by introducing a new language called Punched Card Python that lets people code in Python using punched cards! Like good disrupters, they are going to launch a viral campaign to promote their new language before even having the design for a prototype. For the campaign, they want to draw punched cards of different sizes in ASCII art.\n\nThe ASCII art of a punched card they want to draw is similar to an $\\mathbf{R} \\times \\mathbf{C}$ matrix without the top-left cell. That means, it has $(\\mathbf{R} \\cdot \\mathbf{C}) - 1$ cells in total. Each cell is drawn in ASCII art as a period (.) surrounded by dashes (-) above and below, pipes (|) to the left and right, and plus signs (+) for each corner. Adjacent cells share the common characters in the border. Periods (.) are used to align the cells in the top row.\n\nFor example, the following is a punched card with $\\mathbf{R} = 3$ rows and $\\mathbf{C} = 4$ columns:\n\n```\n..+-+-+-+\n..|.|.|.|\n+-+-+-+-+\n|.|.|.|.|\n+-+-+-+-+\n|.|.|.|.|\n+-+-+-+-+\n```\n\nThere are more examples with other sizes in the samples below. Given the integers $\\mathbf{R}$ and $\\mathbf{C}$ describing the size of a punched card, print the ASCII art drawing of it as described above.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow, each describing a different test case with two integers $\\mathbf{R}$ and $\\mathbf{C}$: the number of rows and columns of the punched card that must be drawn.\n", "outputFormat": "For each test case, output one line containing `Case #x:`, where $x$ is the test case number (starting from 1). Then, output $(2 \\cdot \\mathbf{R}) + 1$ additional lines with the ASCII art drawing of a punched card with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one described in the problem statement. Sample Cases #2 and #3 are additional examples. Notice that the output for each case contains exactly $\\mathbf{R} \\cdot \\mathbf{C} + 3$ periods.\n\n**Limits**\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 81$.\n- $2 \\leq \\mathbf{R} \\leq 10$.\n- $2 \\leq \\mathbf{C} \\leq 10$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 Qualification] Punched Cards", "background": "", "description": "A secret team of programmers is plotting to disrupt the programming language landscape and bring punched cards back by introducing a new language called Punched Card Python that lets people code in Python using punched cards! Like good disrupters, they are going to launch a viral campaign to promote their new language before even having the design for a prototype. For the campaign, they want to draw punched cards of different sizes in ASCII art.\n\nThe ASCII art of a punched card they want to draw is similar to an $\\mathbf{R} \\times \\mathbf{C}$ matrix without the top-left cell. That means, it has $(\\mathbf{R} \\cdot \\mathbf{C}) - 1$ cells in total. Each cell is drawn in ASCII art as a period (.) surrounded by dashes (-) above and below, pipes (|) to the left and right, and plus signs (+) for each corner. Adjacent cells share the common characters in the border. Periods (.) are used to align the cells in the top row.\n\nFor example, the following is a punched card with $\\mathbf{R} = 3$ rows and $\\mathbf{C} = 4$ columns:\n\n```\n..+-+-+-+\n..|.|.|.|\n+-+-+-+-+\n|.|.|.|.|\n+-+-+-+-+\n|.|.|.|.|\n+-+-+-+-+\n```\n\nThere are more examples with other sizes in the samples below. Given the integers $\\mathbf{R}$ and $\\mathbf{C}$ describing the size of a punched card, print the ASCII art drawing of it as described above.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow, each describing a different test case with two integers $\\mathbf{R}$ and $\\mathbf{C}$: the number of rows and columns of the punched card that must be drawn.\n", "outputFormat": "For each test case, output one line containing `Case #x:`, where $x$ is the test case number (starting from 1). Then, output $(2 \\cdot \\mathbf{R}) + 1$ additional lines with the ASCII art drawing of a punched card with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one described in the problem statement. Sample Cases #2 and #3 are additional examples. Notice that the output for each case contains exactly $\\mathbf{R} \\cdot \\mathbf{C} + 3$ periods.\n\n**Limits**\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 81$.\n- $2 \\leq \\mathbf{R} \\leq 10$.\n- $2 \\leq \\mathbf{C} \\leq 10$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 Qualification] Punched Cards", "background": "", "description": "一个秘密程序员团队正计划颠覆编程语言的格局，通过引入一种名为 **Punched Card Python** 的新语言让穿孔卡片重出江湖！这种语言允许人们使用穿孔卡片编写 Python 代码。像优秀的颠覆者一样，他们甚至还没有原型设计，就准备发起一场病毒式营销活动来推广这门新语言。为了这场活动，他们需要用 ASCII 艺术绘制不同尺寸的穿孔卡片。\n\n他们想要绘制的穿孔卡片的 ASCII 艺术类似于一个没有左上角单元格的 $\\mathbf{R} \\times \\mathbf{C}$ 矩阵。也就是说，总共有 $(\\mathbf{R} \\cdot \\mathbf{C}) - 1$ 个单元格。每个单元格在 ASCII 艺术中被绘制为一个由上下短横线（-）、左右竖线（|）、角落加号（+）包围的句点（.）。相邻单元格共享边框上的共同字符。句点（.）用于对齐顶行的单元格。\n\n例如，以下是一个 $\\mathbf{R} = 3$ 行、$\\mathbf{C} = 4$ 列的穿孔卡片：\n\n```\n..+-+-+-+\n..|.|.|.|\n+-+-+-+-+\n|.|.|.|.|\n+-+-+-+-+\n|.|.|.|.|\n+-+-+-+-+\n```\n\n下方样例中还有其他尺寸的示例。给定描述穿孔卡片尺寸的整数 $\\mathbf{R}$ 和 $\\mathbf{C}$，按照上述要求打印其 ASCII 艺术绘图。\n", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 行，每行描述一个不同的测试用例，包含两个整数 $\\mathbf{R}$ 和 $\\mathbf{C}$：表示需要绘制的穿孔卡片的行数和列数。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x:`，其中 $x$ 是测试用例编号（从 1 开始）。然后，额外输出 $(2 \\cdot \\mathbf{R}) + 1$ 行，包含 $\\mathbf{R}$ 行 $\\mathbf{C}$ 列穿孔卡片的 ASCII 艺术绘图。\n", "hint": "**样例解释**\n\n样例 #1 是题目描述中的示例。样例 #2 和 #3 是额外示例。注意，每个用例的输出恰好包含 $\\mathbf{R} \\cdot \\mathbf{C} + 3$ 个句点。\n\n**限制条件**\n\n**测试集 1（11 分，可见评测结果）**\n\n- $1 \\leq \\mathbf{T} \\leq 81$。\n- $2 \\leq \\mathbf{R} \\leq 10$。\n- $2 \\leq \\mathbf{C} \\leq 10$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12980", "type": "P", "difficulty": 2, "samples": [["3\n300000 200000 300000 500000\n300000 200000 500000 300000\n300000 500000 300000 200000\n1000000 1000000 0 0\n0 1000000 1000000 1000000\n999999 999999 999999 999999\n768763 148041 178147 984173\n699508 515362 534729 714381\n949704 625054 946212 951187", "Case #1: 300000 200000 300000 200000\nCase #2: IMPOSSIBLE\nCase #3: 400001 100002 100003 399994"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "2022", "Special Judge", "Google Code Jam"], "title": "[GCJ 2022 Qualification] 3D Printing", "background": "", "description": "You are part of the executive committee of the Database Design Day festivities. You are in charge of promotions and want to print three D's to create a logo of the contest. You can choose any color you want to print them, but all three have to be printed in the same color.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n2ye797y.png)\n\nYou were given three printers and will use each one to print one of the D's. All printers use ink from 4 individual cartridges of different colors (cyan, magenta, yellow, and black) to form any color. For these printers, a color is uniquely defined by 4 non-negative integers $c$, $m$, $y$, and $k$, which indicate the number of ink units of cyan, magenta, yellow, and black ink (respectively) needed to make the color.\n\nThe total amount of ink needed to print a single D is exactly $10^6$ units. For example, printing a D in pure yellow would use $10^6$ units of yellow ink and $0$ from all others. Printing a D in the Code Jam red uses $0$ units of cyan ink, $500000$ units of magenta ink, $450000$ units of yellow ink, and $50000$ units of black ink.\n\nTo print a color, a printer must have at least the required amount of ink for each of its $4$ color cartridges. Given the number of units of ink each printer has in each cartridge, output any color, defined as $4$ non-negative integers that add up to $10^6$, such that all three printers have enough ink to print it.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 3 lines. The $i$-th line of a test case contains 4 integers $\\mathbf{C}_i$, $\\mathbf{M}_i$, $\\mathbf{Y}_i$, and $\\mathbf{K}_i$, representing the number of ink units in the $i$-th printer's cartridge for the colors cyan, magenta, yellow, and black, respectively.\n", "outputFormat": "For each test case, output one line containing case #$x$: $r$, where $x$ is the test case number (starting from 1) and $r$ is IMPOSSIBLE if there is no color that can be printed by all 3 printers. Otherwise, $r$ must be equal to \"$c$ $m$ $y$ $k$\" where $c$, $m$, $y$, and $k$ are non-negative integers that add up to $10^6$ and $c \\leq \\mathbf{C}_i$, $m \\leq \\mathbf{M}_i$, $y \\leq \\mathbf{Y}_i$, and $k \\leq \\mathbf{K}_i$, for all $i$.\n\nIf there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nSample Case #1 is the image provided above. The proposed color is using up all of the ink in the cyan, magenta, and yellow cartridges of the first printer and all of the ink in the black cartridge of the last printer. This means that no additional unit of ink could be used from any of the 4 ink colors, so the given sample output is the only possible output for this case.\n\nIn Sample Case #2, magenta is the only color that both the first and second printers have, so our only chance would be to use $10^6$ units of magenta. Unfortunately, the third printer does not have quite enough, making this case impossible.\n\nIn Sample Case #3, other correct outputs are: \"400000 100000 100000 400000\", \"300000 0 0 700000\", and \"350000 140000 160000 350000\", among lots of others. Notice that \"300000 140000 160000 700000\" would not be a valid answer because, even though there is enough ink in all printers to do that, the total number of ink units must be exactly $10^6$.\n\n**Limits**\n\n**Test Set 1 (Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{C}_i \\leq 10^6$, for all $i$.\n- $0 \\leq \\mathbf{M}_i \\leq 10^6$, for all $i$.\n- $0 \\leq \\mathbf{Y}_i \\leq 10^6$, for all $i$.\n- $0 \\leq \\mathbf{K}_i \\leq 10^6$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 Qualification] 3D Printing", "background": "", "description": "You are part of the executive committee of the Database Design Day festivities. You are in charge of promotions and want to print three D's to create a logo of the contest. You can choose any color you want to print them, but all three have to be printed in the same color.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n2ye797y.png)\n\nYou were given three printers and will use each one to print one of the D's. All printers use ink from 4 individual cartridges of different colors (cyan, magenta, yellow, and black) to form any color. For these printers, a color is uniquely defined by 4 non-negative integers $c$, $m$, $y$, and $k$, which indicate the number of ink units of cyan, magenta, yellow, and black ink (respectively) needed to make the color.\n\nThe total amount of ink needed to print a single D is exactly $10^6$ units. For example, printing a D in pure yellow would use $10^6$ units of yellow ink and $0$ from all others. Printing a D in the Code Jam red uses $0$ units of cyan ink, $500000$ units of magenta ink, $450000$ units of yellow ink, and $50000$ units of black ink.\n\nTo print a color, a printer must have at least the required amount of ink for each of its $4$ color cartridges. Given the number of units of ink each printer has in each cartridge, output any color, defined as $4$ non-negative integers that add up to $10^6$, such that all three printers have enough ink to print it.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 3 lines. The $i$-th line of a test case contains 4 integers $\\mathbf{C}_i$, $\\mathbf{M}_i$, $\\mathbf{Y}_i$, and $\\mathbf{K}_i$, representing the number of ink units in the $i$-th printer's cartridge for the colors cyan, magenta, yellow, and black, respectively.\n", "outputFormat": "For each test case, output one line containing case #$x$: $r$, where $x$ is the test case number (starting from 1) and $r$ is IMPOSSIBLE if there is no color that can be printed by all 3 printers. Otherwise, $r$ must be equal to \"$c$ $m$ $y$ $k$\" where $c$, $m$, $y$, and $k$ are non-negative integers that add up to $10^6$ and $c \\leq \\mathbf{C}_i$, $m \\leq \\mathbf{M}_i$, $y \\leq \\mathbf{Y}_i$, and $k \\leq \\mathbf{K}_i$, for all $i$.\n\nIf there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nSample Case #1 is the image provided above. The proposed color is using up all of the ink in the cyan, magenta, and yellow cartridges of the first printer and all of the ink in the black cartridge of the last printer. This means that no additional unit of ink could be used from any of the 4 ink colors, so the given sample output is the only possible output for this case.\n\nIn Sample Case #2, magenta is the only color that both the first and second printers have, so our only chance would be to use $10^6$ units of magenta. Unfortunately, the third printer does not have quite enough, making this case impossible.\n\nIn Sample Case #3, other correct outputs are: \"400000 100000 100000 400000\", \"300000 0 0 700000\", and \"350000 140000 160000 350000\", among lots of others. Notice that \"300000 140000 160000 700000\" would not be a valid answer because, even though there is enough ink in all printers to do that, the total number of ink units must be exactly $10^6$.\n\n**Limits**\n\n**Test Set 1 (Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{C}_i \\leq 10^6$, for all $i$.\n- $0 \\leq \\mathbf{M}_i \\leq 10^6$, for all $i$.\n- $0 \\leq \\mathbf{Y}_i \\leq 10^6$, for all $i$.\n- $0 \\leq \\mathbf{K}_i \\leq 10^6$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 Qualification] 3D Printing", "background": "", "description": "你是数据库设计日庆祝活动的组委会成员之一，负责宣传工作，并计划打印三个 **D** 字来设计比赛标志。你可以选择任何颜色打印它们，但所有三个 **D** 必须使用相同的颜色。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n2ye797y.png)\n\n你拿到了三台打印机，每台将用于打印其中一个 **D**。所有打印机都使用 4 种不同颜色（青色、品红色、黄色和黑色）的独立墨盒来调配颜色。对于这些打印机，一种颜色由 4 个非负整数 $c$、$m$、$y$ 和 $k$ 唯一确定，分别表示调配该颜色所需的青色、品红色、黄色和黑色墨水的单位数。\n\n打印单个 **D** 所需的墨水总量恰好是 $10^6$ 单位。例如，纯黄色打印一个 **D** 需要 $10^6$ 单位黄色墨水，其余颜色为 $0$；而用 Code Jam 红色打印则需要 $0$ 单位青色墨水、$500000$ 单位品红色墨水、$450000$ 单位黄色墨水和 $50000$ 单位黑色墨水。\n\n要打印某种颜色，打印机必须在每个颜色的墨盒中至少有该颜色所需的墨水单位数。给定每台打印机各墨盒中的墨水单位数，输出任意一种满足以下条件的颜色（定义为 4 个非负整数，其和为 $10^6$）：所有三台打印机均有足够墨水打印该颜色。\n", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含 3 行，第 $i$ 行包含 4 个整数 $\\mathbf{C}_i$、$\\mathbf{M}_i$、$\\mathbf{Y}_i$ 和 $\\mathbf{K}_i$，分别表示第 $i$ 台打印机的青色、品红色、黄色和黑色墨盒中的墨水单位数。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: r`，其中 $x$ 是测试用例编号（从 1 开始），$r$ 为 `IMPOSSIBLE`（如果不存在所有三台打印机均可打印的颜色），否则 $r$ 应为 `\"c m y k\"`。这里 $c$、$m$、$y$ 和 $k$ 是非负整数，满足 $c + m + y + k = 10^6$，且对于所有 $i$ 有 $c \\leq \\mathbf{C}_i$、$m \\leq \\mathbf{M}_i$、$y \\leq \\mathbf{Y}_i$ 和 $k \\leq \\mathbf{K}_i$。\n\n若存在多组解，输出任意一组均可。", "hint": "\n## 说明/提示\n\n**样例解释**\n\n样例 #1 对应题目描述中的图片。给出的颜色方案用尽了第一台打印机的青色、品红色和黄色墨盒的所有墨水，以及最后一台打印机的黑色墨盒的所有墨水。这意味着无法再从任何颜色的墨盒中多用一单位墨水，因此该样例输出是此案例唯一可能的解。\n\n在样例 #2 中，品红色是前两台打印机唯一共有的颜色，因此唯一可能的方案是使用 $10^6$ 单位品红色墨水。但第三台打印机的品红色墨水不足，导致此案例无解。\n\n在样例 #3 中，其他正确输出包括 `\"400000 100000 100000 400000\"`、`\"300000 0 0 700000\"` 和 `\"350000 140000 160000 350000\"` 等。注意 `\"300000 140000 160000 700000\"` 不是有效答案，因为尽管所有打印机均有足够墨水，但墨水单位总数必须严格等于 $10^6$。\n\n**限制条件**\n\n**测试集 1（可见评测结果）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $0 \\leq \\mathbf{C}_i \\leq 10^6$，对所有 $i$ 成立。\n- $0 \\leq \\mathbf{M}_i \\leq 10^6$，对所有 $i$ 成立。\n- $0 \\leq \\mathbf{Y}_i \\leq 10^6$，对所有 $i$ 成立。\n- $0 \\leq \\mathbf{K}_i \\leq 10^6$，对所有 $i$ 成立。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12981", "type": "P", "difficulty": 2, "samples": [["4\n4\n6 10 12 8\n6\n5 4 5 4 4 4\n10\n10 10 7 6 7 4 4 5 7 4\n1\n10", "Case #1: 4\nCase #2: 5\nCase #3: 9\nCase #4: 1"]], "limits": {"time": [5000, 5000, 15000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2022", "排序", "Google Code Jam"], "title": "[GCJ 2022 Qualification] d1000000", "background": "", "description": "While the most typical type of dice have 6 sides, each of which shows a different integer 1 through 6, there are many games that use other types. In particular, a $d_k$ is a die with $k$ sides, each of which shows a different integer 1 through $k$. A $d6$ is a typical die, a $d4$ has four sides, and a $d1000000$ has one million sides.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b9fu60so.png)\n\nIn this problem, we start with a collection of $\\mathbf{N}$ dice. The $i$-th die is a $d\\mathbf{S}_i$, that is, it has $\\mathbf{S}_i$ sides showing integers 1 through $\\mathbf{S}_i$. A straight of length $\\ell$ starting at $x$ is the list of integers $x$, $x + 1$, $\\cdots$, $x + (\\ell - 1)$. We want to choose some of the dice (possibly all) and pick one number from each to form a straight. What is the longest straight we can form in this way?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in two lines. The firstline of a test case contains a single integer $\\mathbf{N}$, the number of dice in the game. The second line contains $\\mathbf{N}$ integers $\\mathbf{S}_1$, $\\mathbf{S}_2$, $\\cdots$, $\\mathbf{S}_\\mathbf{N}$, each representing the number of sides of a different die.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of input dice that can be put in a straight.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are multiple ways to form a straight using all $4$ dice. One possible way is shown in the image above.\n\nIn Sample Case #2, since none of the dice can show an integer greater than $5$, there is no way to have a straight with more than $5$ dice. There are multiple ways to form a straight with exactly $5$ dice. For example, pick the integers $4$ and $5$ for both $d5$'s and then integers $1, 2$, and $3$ for three of the $d4$'s to form $1, 2, 3, 4, 5$.\n\nIn Sample Case #3, it is possible to form the straight $1, 2, 3, 4, 5, 6, 7, 8, 9$ by discarding one $d4$ and using the $d4$'s, $d5$, and $d6$ to get $1$ through $4$; the $d7$'s to get $5$ through $7$; and the $d10$'s to get $8$ and $9$. There is no way to form a straight of length $10$, so this is the best that can be done.\n\nIn Sample Case #4, we can only form a straight of length $1$, but we can do so by picking any integer for the $d10$ we are given.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10$.\n- $4 \\leq \\mathbf{S}_i \\leq 20$, for all $i$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10^5$.\n- $4 \\leq \\mathbf{S}_i \\leq 10^6$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 Qualification] d1000000", "background": "", "description": "While the most typical type of dice have 6 sides, each of which shows a different integer 1 through 6, there are many games that use other types. In particular, a $d_k$ is a die with $k$ sides, each of which shows a different integer 1 through $k$. A $d6$ is a typical die, a $d4$ has four sides, and a $d1000000$ has one million sides.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b9fu60so.png)\n\nIn this problem, we start with a collection of $\\mathbf{N}$ dice. The $i$-th die is a $d\\mathbf{S}_i$, that is, it has $\\mathbf{S}_i$ sides showing integers 1 through $\\mathbf{S}_i$. A straight of length $\\ell$ starting at $x$ is the list of integers $x$, $x + 1$, $\\cdots$, $x + (\\ell - 1)$. We want to choose some of the dice (possibly all) and pick one number from each to form a straight. What is the longest straight we can form in this way?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in two lines. The firstline of a test case contains a single integer $\\mathbf{N}$, the number of dice in the game. The second line contains $\\mathbf{N}$ integers $\\mathbf{S}_1$, $\\mathbf{S}_2$, $\\cdots$, $\\mathbf{S}_\\mathbf{N}$, each representing the number of sides of a different die.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of input dice that can be put in a straight.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are multiple ways to form a straight using all $4$ dice. One possible way is shown in the image above.\n\nIn Sample Case #2, since none of the dice can show an integer greater than $5$, there is no way to have a straight with more than $5$ dice. There are multiple ways to form a straight with exactly $5$ dice. For example, pick the integers $4$ and $5$ for both $d5$'s and then integers $1, 2$, and $3$ for three of the $d4$'s to form $1, 2, 3, 4, 5$.\n\nIn Sample Case #3, it is possible to form the straight $1, 2, 3, 4, 5, 6, 7, 8, 9$ by discarding one $d4$ and using the $d4$'s, $d5$, and $d6$ to get $1$ through $4$; the $d7$'s to get $5$ through $7$; and the $d10$'s to get $8$ and $9$. There is no way to form a straight of length $10$, so this is the best that can be done.\n\nIn Sample Case #4, we can only form a straight of length $1$, but we can do so by picking any integer for the $d10$ we are given.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10$.\n- $4 \\leq \\mathbf{S}_i \\leq 20$, for all $i$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10^5$.\n- $4 \\leq \\mathbf{S}_i \\leq 10^6$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 Qualification] d1000000", "background": null, "description": "虽然最常见的骰子有 6 个面，每个面显示 1 到 6 的不同整数，但许多游戏会使用其他类型的骰子。特别地，$d_k$ 表示一个有 $k$ 个面的骰子，每个面显示 1 到 $k$ 的不同整数。$d_6$ 是标准骰子，$d_4$ 有四个面，而 $d_{1000000}$ 有一百万个面。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b9fu60so.png)\n\n在这个问题中，我们从一个包含 $\\mathbf{N}$ 个骰子的集合开始。第 $i$ 个骰子是 $d_{\\mathbf{S}_i}$，即它有 $\\mathbf{S}_i$ 个面，分别显示 $1$ 到 $\\mathbf{S}_i$ 的整数。从 $x$ 开始、长度为 $\\ell$ 的顺子是指整数序列 $x$, $x + 1$, $\\cdots$, $x + (\\ell - 1)$。我们需要选择部分（或全部）骰子，并从每个骰子中选取一个数字来组成一个顺子。用这种方式我们能组成的最长顺子有多长？", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例由两行描述：第一行包含一个整数 $\\mathbf{N}$，表示游戏中的骰子数量；第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{S}_1$, $\\mathbf{S}_2$, $\\cdots$, $\\mathbf{S}_\\mathbf{N}$，分别表示每个骰子的面数。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是能组成顺子的最长骰子数量。", "hint": "**样例解释**\n\n在样例 #1 中，有多个方法可以用所有 $4$ 个骰子组成一个顺子。上图展示了一种可能的方式。\n\n在样例 #2 中，由于所有骰子的最大面数都不超过 $5$，因此无法组成超过 $5$ 个骰子的顺子。有多种方法可以组成恰好 $5$ 个骰子的顺子，例如：从两个 $d_5$ 中选取 $4$ 和 $5$，再从三个 $d_4$ 中选取 $1$、$2$ 和 $3$，形成顺子 $1, 2, 3, 4, 5$。\n\n在样例 #3 中，可以通过丢弃一个 $d_4$ 并使用剩余的 $d_4$、$d_5$ 和 $d_6$ 获取 $1$ 到 $4$，用 $d_7$ 获取 $5$ 到 $7$，用 $d_{10}$ 获取 $8$ 和 $9$，从而组成顺子 $1, 2, 3, 4, 5, 6, 7, 8, 9$。无法组成长度为 $10$ 的顺子，因此这是最优解。\n\n在样例 #4 中，我们只能组成长度为 $1$ 的顺子，但可以通过从给定的 $d_{10}$ 中任选一个数字来实现。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n\n**测试集 1（9 分，可见评测结果）**\n\n- $1 \\leq \\mathbf{N} \\leq 10$。\n- $4 \\leq \\mathbf{S}_i \\leq 20$，对所有 $i$ 成立。\n\n**测试集 2（11 分，可见评测结果）**\n\n- $1 \\leq \\mathbf{N} \\leq 10^5$。\n- $4 \\leq \\mathbf{S}_i \\leq 10^6$，对所有 $i$ 成立。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12982", "type": "P", "difficulty": 3, "samples": [["3\n4\n60 20 40 50\n0 1 1 2\n5\n3 2 1 4 5\n0 1 1 1 0\n8\n100 100 100 90 80 100 90 100\n0 1 2 1 2 3 1 3", "Case #1: 110\nCase #2: 14\nCase #3: 490"]], "limits": {"time": [5000, 5000, 5000, 10000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["2022", "拓扑排序", "Google Code Jam"], "title": "[GCJ 2022 Qualification] Chain Reactions", "background": "", "description": "Wile lives alone in the desert, so he entertains himself by building complicated machines that run on chain reactions. Each machine consists of $\\mathbf{N}$ modules indexed $1, 2, \\ldots, \\mathbf{N}$. Each module may point at one other module with a lower index. If not, it points at the abyss.\n\nModules that are not pointed at by any others are called *initiators*. Wile can manually trigger initiators. When a module is triggered, it triggers the module it is pointing at (if any) which in turn may trigger a third module (if it points at one), and so on, until the chain would hit the abyss or an already triggered module. This is called a *chain reaction*.\n\nEach of the $\\mathbf{N}$ modules has a fun factor $\\mathbf{F}_i$. The fun Wile gets from a chain reaction is the largest fun factor of all modules that triggered in that chain reaction. Wile is going to trigger each initiator module once, in some order. The overall fun Wile gets from the session is the sum of the fun he gets from each chain reaction.\n\nFor example, suppose Wile has 4 modules with fun factors $\\mathbf{F}_1 = 60$, $\\mathbf{F}_2 = 20$, $\\mathbf{F}_3 = 40$, and $\\mathbf{F}_4 = 50$ and module 1 points at the abyss, modules 2 and 3 at module 1, and module 4 at module 2. There are two initiators (3 and 4) that Wile must trigger, in some order.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/v8jwu5d8)\n\nAs seen above, if Wile manually triggers module 4 first, modules 4, 2, and 1 will get triggered in the same chain reaction, for a fun of $\\max(50, 20, 60) = 60$. Then, when Wile triggers module 3, module 3 will get triggered alone (module 1 cannot get triggered again), for a fun of 40, and an overall fun for the session of $60 + 40 = 100$.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/94l7nhpi)\n\nHowever, if Wile manually triggers module 3 first, modules 3 and 1 will get triggered in the same chain reaction, for a fun of $\\max(40, 60) = 60$. Then, when Wile triggers module 4, modules 4 and 2 will get triggered in the same chain reaction, for a fun of $\\max(50, 20) = 50$, and an overall fun for the session of $60 + 50 = 110$.\n\nGiven the fun factors and the setup of the modules, compute the maximum fun Wile can get if he triggers the initiators in the best possible order.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow, each described using 3 lines. Each test case starts with a line with a single integer $\\mathbf{N}$, the number of modules Wile has. The second line contains $\\mathbf{N}$ integers $\\mathbf{F}_1, \\mathbf{F}_2, \\ldots, \\mathbf{F}_\\mathbf{N}$ where $\\mathbf{F}_i$ is the fun factor of the $i$-th module. The third line contains $\\mathbf{N}$ integers $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots \\mathbf{P}_\\mathbf{N}$. If $\\mathbf{P}_i = 0$, that means module $i$ points at the abyss. Otherwise, module $i$ points at module $\\mathbf{P}_i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum fun Wile can have by manually triggering the initiators in the best possible order.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained in the problem statement.\n\nIn Sample Case #2, there are $4$ initiators (modules $2$ through $5$), so there are $4$ chain reactions. Activating them in order $3, 5, 4, 2$ yields chains of fun $3, 5, 4, 2$ for an overall fun of $14$. Notice that we are summing the four highest fun numbers in the input, so there is no way to get more than that.\n\nIn Sample Case #3, an optimal activation order of the $5$ initiators is $4, 5, 7, 6, 8$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{F}_i \\leq 10^9$.\n- $0 \\leq \\mathbf{P}_i \\leq i - 1$, for all $i$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- Time limit: 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 10$.\n\n**Test Set 2 (12 Pts, Visible Verdict)**\n\n- Time limit: 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 3 (5 Pts, Hidden Verdict)**\n\n- Time limit: 10 seconds.\n- $1 \\leq \\mathbf{N} \\leq 100000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 Qualification] Chain Reactions", "background": "", "description": "Wile lives alone in the desert, so he entertains himself by building complicated machines that run on chain reactions. Each machine consists of $\\mathbf{N}$ modules indexed $1, 2, \\ldots, \\mathbf{N}$. Each module may point at one other module with a lower index. If not, it points at the abyss.\n\nModules that are not pointed at by any others are called *initiators*. Wile can manually trigger initiators. When a module is triggered, it triggers the module it is pointing at (if any) which in turn may trigger a third module (if it points at one), and so on, until the chain would hit the abyss or an already triggered module. This is called a *chain reaction*.\n\nEach of the $\\mathbf{N}$ modules has a fun factor $\\mathbf{F}_i$. The fun Wile gets from a chain reaction is the largest fun factor of all modules that triggered in that chain reaction. Wile is going to trigger each initiator module once, in some order. The overall fun Wile gets from the session is the sum of the fun he gets from each chain reaction.\n\nFor example, suppose Wile has 4 modules with fun factors $\\mathbf{F}_1 = 60$, $\\mathbf{F}_2 = 20$, $\\mathbf{F}_3 = 40$, and $\\mathbf{F}_4 = 50$ and module 1 points at the abyss, modules 2 and 3 at module 1, and module 4 at module 2. There are two initiators (3 and 4) that Wile must trigger, in some order.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/v8jwu5d8)\n\nAs seen above, if Wile manually triggers module 4 first, modules 4, 2, and 1 will get triggered in the same chain reaction, for a fun of $\\max(50, 20, 60) = 60$. Then, when Wile triggers module 3, module 3 will get triggered alone (module 1 cannot get triggered again), for a fun of 40, and an overall fun for the session of $60 + 40 = 100$.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/94l7nhpi)\n\nHowever, if Wile manually triggers module 3 first, modules 3 and 1 will get triggered in the same chain reaction, for a fun of $\\max(40, 60) = 60$. Then, when Wile triggers module 4, modules 4 and 2 will get triggered in the same chain reaction, for a fun of $\\max(50, 20) = 50$, and an overall fun for the session of $60 + 50 = 110$.\n\nGiven the fun factors and the setup of the modules, compute the maximum fun Wile can get if he triggers the initiators in the best possible order.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow, each described using 3 lines. Each test case starts with a line with a single integer $\\mathbf{N}$, the number of modules Wile has. The second line contains $\\mathbf{N}$ integers $\\mathbf{F}_1, \\mathbf{F}_2, \\ldots, \\mathbf{F}_\\mathbf{N}$ where $\\mathbf{F}_i$ is the fun factor of the $i$-th module. The third line contains $\\mathbf{N}$ integers $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots \\mathbf{P}_\\mathbf{N}$. If $\\mathbf{P}_i = 0$, that means module $i$ points at the abyss. Otherwise, module $i$ points at module $\\mathbf{P}_i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum fun Wile can have by manually triggering the initiators in the best possible order.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained in the problem statement.\n\nIn Sample Case #2, there are $4$ initiators (modules $2$ through $5$), so there are $4$ chain reactions. Activating them in order $3, 5, 4, 2$ yields chains of fun $3, 5, 4, 2$ for an overall fun of $14$. Notice that we are summing the four highest fun numbers in the input, so there is no way to get more than that.\n\nIn Sample Case #3, an optimal activation order of the $5$ initiators is $4, 5, 7, 6, 8$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{F}_i \\leq 10^9$.\n- $0 \\leq \\mathbf{P}_i \\leq i - 1$, for all $i$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- Time limit: 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 10$.\n\n**Test Set 2 (12 Pts, Visible Verdict)**\n\n- Time limit: 5 seconds.\n- $1 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 3 (5 Pts, Hidden Verdict)**\n\n- Time limit: 10 seconds.\n- $1 \\leq \\mathbf{N} \\leq 100000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 Qualification] Chain Reactions", "background": "", "description": "Wile 独自生活在沙漠中，他通过建造复杂的连锁反应机器来自娱自乐。每台机器由 $\\mathbf{N}$ 个模块组成，编号为 $1, 2, \\ldots, \\mathbf{N}$。每个模块会指向一个编号比它小的模块，如果没有可指向的模块，则指向虚空。\n\n没有被任何其他模块指向的模块称为**启动器**。Wile 可以手动触发启动器。当一个模块被触发时，它会触发它所指向的模块（如果有的话），后者可能继续触发第三个模块（如果它指向某个模块），依此类推，直到链条到达虚空或已经触发过的模块为止。这被称为**连锁反应**。\n\n每个 $\\mathbf{N}$ 个模块都有一个乐趣值 $\\mathbf{F}_i$。Wile 从一次连锁反应中获得的乐趣是该连锁反应中所有被触发模块的乐趣值的最大值。Wile 将按某种顺序依次触发每个启动器模块一次。整个过程中 Wile 获得的总乐趣是每次连锁反应所获乐趣的总和。\n\n例如，假设 Wile 有 4 个模块，乐趣值分别为 $\\mathbf{F}_1 = 60$、$\\mathbf{F}_2 = 20$、$\\mathbf{F}_3 = 40$ 和 $\\mathbf{F}_4 = 50$，模块 1 指向虚空，模块 2 和 3 指向模块 1，模块 4 指向模块 2。此时有两个启动器（3 和 4），Wile 需要按某种顺序触发它们。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/v8jwu5d8)\n\n如上图所示，如果 Wile 先手动触发模块 4，模块 4、2 和 1 会在同一次连锁反应中被触发，乐趣值为 $\\max(50, 20, 60) = 60$。接着，当 Wile 触发模块 3 时，模块 3 会单独被触发（模块 1 无法再次触发），乐趣值为 40，整个过程的总乐趣为 $60 + 40 = 100$。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/94l7nhpi)\n\n然而，如果 Wile 先手动触发模块 3，模块 3 和 1 会在同一次连锁反应中被触发，乐趣值为 $\\max(40, 60) = 60$。接着，当 Wile 触发模块 4 时，模块 4 和 2 会在同一次连锁反应中被触发，乐趣值为 $\\max(50, 20) = 50$，整个过程的总乐趣为 $60 + 50 = 110$。\n\n给定模块的乐趣值和指向关系，计算 Wile 在最优触发顺序下能获得的最大总乐趣。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例，每个测试用例由 3 行描述。每个测试用例的第一行包含一个整数 $\\mathbf{N}$，表示 Wile 拥有的模块数量。第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{F}_1, \\mathbf{F}_2, \\ldots, \\mathbf{F}_\\mathbf{N}$，其中 $\\mathbf{F}_i$ 是第 $i$ 个模块的乐趣值。第三行包含 $\\mathbf{N}$ 个整数 $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots \\mathbf{P}_\\mathbf{N}$。如果 $\\mathbf{P}_i = 0$，表示模块 $i$ 指向虚空；否则，模块 $i$ 指向模块 $\\mathbf{P}_i$。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 Wile 在最优触发顺序下能获得的最大总乐趣。\n", "hint": "**样例解释**\n\n样例 #1 是题目描述中解释的案例。\n\n在样例 #2 中，有 $4$ 个启动器（模块 $2$ 到 $5$），因此有 $4$ 次连锁反应。按顺序 $3, 5, 4, 2$ 触发它们，得到的连锁反应乐趣值分别为 $3, 5, 4, 2$，总乐趣为 $14$。注意我们是在对输入中的四个最大乐趣值求和，因此无法获得更大的值。\n\n在样例 #3 中，$5$ 个启动器的最优触发顺序是 $4, 5, 7, 6, 8$。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{F}_i \\leq 10^9$。\n- $0 \\leq \\mathbf{P}_i \\leq i - 1$，对所有 $i$ 成立。\n\n**测试集 1（10 分，可见评测结果）**\n\n- 时间限制：5 秒。\n- $1 \\leq \\mathbf{N} \\leq 10$。\n\n**测试集 2（12 分，可见评测结果）**\n\n- 时间限制：5 秒。\n- $1 \\leq \\mathbf{N} \\leq 1000$。\n\n**测试集 3（5 分，隐藏评测结果）**\n\n- 时间限制：10 秒。\n- $1 \\leq \\mathbf{N} \\leq 100000$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12983", "type": "P", "difficulty": 6, "samples": [["1\n5 3\n4 1\n\n5 2\n\n4 1\n\n1 3", "\n\n\nT 5\n\nW\n\nT 1\n\nE 5"]], "limits": {"time": [120000], "memory": [1048576]}, "tags": ["2022", "交互题", "Special Judge", "概率论", "期望", "Google Code Jam"], "title": "[GCJ 2022 Qualification] Twisty Little Passages", "background": null, "description": "You are investigating a cave. The cave has $\\mathbf{N}$ rooms. There are underground passages that bidirectionally connect some pairs of rooms. Each room has at least one passage connected to it. No passage goes from a room to itself, and no two rooms are connected by more than one passage.\n\nWhen in a room, you can identify what room you are in and see how many passages it connects to, but you cannot distinguish the passages. You want to estimate the number of passages that exist in the cave. You are allowed to do up to $\\mathbf{K}$ operations. An operation is either:\n\n* be magically teleported to a room of your choice, or\n* walk through a random passage connected to the room you are in, taking you to the room at the other end of that passage.\n\nWhen you decide to walk through a passage, you are unable to choose which one, because they are all alike. A passage is chosen for you uniformly at random.\n\nYou begin the investigation in an arbitrary room. Estimate the number of passages between rooms in the cave with at most $\\mathbf{K}$ operations.\n\nIf $E$ is your estimate and $P$ is the actual number of passages, your solution is considered correct for a test case if and only if $P \\cdot 2/3 \\leq E \\leq P \\cdot 4/3$.\n\nTo pass a test set, your solution must be correct for at least 90% of the test cases in that set.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing an integer, $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nFor each test case, your program must first read a line containing two integers $\\mathbf{N}$ and $\\mathbf{K}$: the number of rooms in the cave, and the maximum number of room operations you are allowed. Rooms are numbered between $1$ and $\\mathbf{N}$. The cave is determined at the beginning of the test case – it won't be changed while you explore it. Then, your program must process up to $\\mathbf{K} + 1$ exchanges.\n\nThe $i$-th exchange starts with you reading a line containing two integers $\\mathbf{R}_i$ and $\\mathbf{P}_i$, representing the number of the room you are currently in and the number of passages it connects to. Then, you must output a single line containing one of the following:\n\n* A single uppercase $\\mathbf{w}$: this means you want to walk through a random passage.\n* A single uppercase $\\mathbf{t}$ and an integer $S$: this means you want to teleport to room $S$.\n* A single uppercase $\\mathbf{e}$ and an integer $E$: this means you want to finish exploring and estimate that the cave contains $E$ passages.\n\nAfter an estimation operation, the judge will immediately start the next test case if there is one, regardless of the correctness of your estimation. If there is no next test case, the judge will wait for you to finish without any further output.\n\nIf the judge receives an invalidly formatted line from your program at any moment, or if your $(\\mathbf{K} + 1)$-th exchange for a test case is not an estimation operation, the judge will print a single number $-1$ and will not print any further output. If your program continues to wait for the judge after receiving a $-1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\n(It can be shown that the actual number of passages is either 4 or 5. The two possible graphs for this test case are shown below.)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ve57bfoy.png)\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n**Test Set 1 (29 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 10^5$.\n- $K = 8000$.\n- Each room has at least one passage connected to it.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 Qualification] Twisty Little Passages", "background": null, "description": "You are investigating a cave. The cave has $\\mathbf{N}$ rooms. There are underground passages that bidirectionally connect some pairs of rooms. Each room has at least one passage connected to it. No passage goes from a room to itself, and no two rooms are connected by more than one passage.\n\nWhen in a room, you can identify what room you are in and see how many passages it connects to, but you cannot distinguish the passages. You want to estimate the number of passages that exist in the cave. You are allowed to do up to $\\mathbf{K}$ operations. An operation is either:\n\n* be magically teleported to a room of your choice, or\n* walk through a random passage connected to the room you are in, taking you to the room at the other end of that passage.\n\nWhen you decide to walk through a passage, you are unable to choose which one, because they are all alike. A passage is chosen for you uniformly at random.\n\nYou begin the investigation in an arbitrary room. Estimate the number of passages between rooms in the cave with at most $\\mathbf{K}$ operations.\n\nIf $E$ is your estimate and $P$ is the actual number of passages, your solution is considered correct for a test case if and only if $P \\cdot 2/3 \\leq E \\leq P \\cdot 4/3$.\n\nTo pass a test set, your solution must be correct for at least 90% of the test cases in that set.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing an integer, $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nFor each test case, your program must first read a line containing two integers $\\mathbf{N}$ and $\\mathbf{K}$: the number of rooms in the cave, and the maximum number of room operations you are allowed. Rooms are numbered between $1$ and $\\mathbf{N}$. The cave is determined at the beginning of the test case – it won't be changed while you explore it. Then, your program must process up to $\\mathbf{K} + 1$ exchanges.\n\nThe $i$-th exchange starts with you reading a line containing two integers $\\mathbf{R}_i$ and $\\mathbf{P}_i$, representing the number of the room you are currently in and the number of passages it connects to. Then, you must output a single line containing one of the following:\n\n* A single uppercase $\\mathbf{w}$: this means you want to walk through a random passage.\n* A single uppercase $\\mathbf{t}$ and an integer $S$: this means you want to teleport to room $S$.\n* A single uppercase $\\mathbf{e}$ and an integer $E$: this means you want to finish exploring and estimate that the cave contains $E$ passages.\n\nAfter an estimation operation, the judge will immediately start the next test case if there is one, regardless of the correctness of your estimation. If there is no next test case, the judge will wait for you to finish without any further output.\n\nIf the judge receives an invalidly formatted line from your program at any moment, or if your $(\\mathbf{K} + 1)$-th exchange for a test case is not an estimation operation, the judge will print a single number $-1$ and will not print any further output. If your program continues to wait for the judge after receiving a $-1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\n(It can be shown that the actual number of passages is either 4 or 5. The two possible graphs for this test case are shown below.)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ve57bfoy.png)\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n**Test Set 1 (29 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 10^5$.\n- $K = 8000$.\n- Each room has at least one passage connected to it.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 Qualification] Twisty Little Passages", "background": null, "description": "你正在调查一个洞穴。洞穴中有 $\\mathbf{N}$ 个房间，某些房间之间通过双向的地下通道相连。每个房间至少连接一条通道。没有通道从一个房间指向自身，且任意两个房间之间最多只有一条通道。\n\n当身处某个房间时，你可以识别当前所在的房间编号并查看它连接了多少条通道，但无法区分具体是哪条通道。你需要估算洞穴中存在的通道总数。你最多可以进行 $\\mathbf{K}$ 次操作，每次操作可以是以下两种之一：\n\n* **魔法传送**：立即传送到任意一个你选择的房间。\n* **随机行走**：从当前房间随机选择一条连接通道走过去（所有通道被选中的概率均等），到达该通道另一端的房间。\n\n你从任意一个房间开始调查。通过最多 $\\mathbf{K}$ 次操作，估算洞穴中房间之间的通道总数。\n\n设 $E$ 是你的估算值，$P$ 是实际通道数量，当且仅当满足 $P \\cdot 2/3 \\leq E \\leq P \\cdot 4/3$ 时，你的答案被视为正确。要通过一个测试集，至少需要答对该测试集中 90% 的测试用例。\n\n### 交互协议\n\n这是一个交互题。\n\n初始时，你的程序需读取一个整数 $\\mathbf{T}$，表示测试用例数量。接着处理 $\\mathbf{T}$ 个测试用例。\n\n对于每个测试用例，你的程序首先读取一行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{K}$，分别表示洞穴中的房间数量和允许的最大操作次数。房间编号为 $1$ 到 $\\mathbf{N}$。洞穴结构在测试用例开始时确定，不会在探索过程中改变。之后，程序需处理最多 $\\mathbf{K} + 1$ 次交互。\n\n第 $i$ 次交互开始时，你需要读取一行包含两个整数 $\\mathbf{R}_i$ 和 $\\mathbf{P}_i$，表示当前所在房间编号及其连接的通道数量。接着，输出以下三种指令之一：\n\n* 单个大写字母 $\\mathbf{W}$：表示选择随机行走。\n* 单个大写字母 $\\mathbf{T}$ 和一个整数 $S$：表示传送到房间 $S$。\n* 单个大写字母 $\\mathbf{E}$ 和一个整数 $E$：表示结束探索并估算通道总数为 $E$。\n\n在输出估算指令后，无论估算是否正确，裁判将立即开始下一个测试用例（如果存在）。如果没有更多测试用例，裁判将静默等待程序结束。\n\n如果裁判在任何时刻收到非法格式的输入，或某测试用例的第 $(\\mathbf{K} + 1)$ 次交互未输出估算指令，裁判将输出 $-1$ 并终止交互。若此时程序仍在等待输入，将因超时被判为 **Time Limit Exceeded**。注意：需确保程序及时退出以避免超时错误。若内存超限或程序运行时错误，将得到相应判果。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**样例解释**\n\n（可以证明，实际的通道数为 4 或 5。该测试用例的两种可能图示如下图所示。）\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ve57bfoy.png)\n\n可通过本地测试工具或平台进行调试。本地测试时需同时运行交互工具（如我们提供的交互运行器）。更多说明详见工具文件内的注释。\n\n测试工具的使用说明已内嵌在注释中。建议添加自定义测试用例。请注意：该工具**并非**真实评测系统，实际行为可能存在差异。\n\n**限制条件**\n\n**测试集 1（29 分，可见判果）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{N} \\leq 10^5$。\n- $K = 8000$。\n- 每个房间至少连接一条通道。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12984", "type": "P", "difficulty": 2, "samples": [["3\nPEEL\nAAAAAAAAAA\nCODEJAMDAY", "Case #1: PEEEEL\nCase #2: AAAAAAAAAA\nCase #3: CCODDEEJAAMDAAY"]], "limits": {"time": [2000, 2000, 2000], "memory": [1048576, 1048576, 1048576]}, "tags": ["字符串", "贪心", "2022", "Google Code Jam"], "title": "[GCJ 2022 #1A] Double or One Thing", "background": "", "description": "You are given a string of uppercase English letters. You can highlight any number of the letters (possibly all or none of them). The highlighted letters do not need to be consecutive. Then, a new string is produced by processing the letters from left to right: non-highlighted letters are appended once to the new string, while highlighted letters are appended twice.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q5ybwo42.png)\n\nFor example, if the initial string is HELLOWORLD, you could highlight the H, the first and last Ls and the last o to obtain\n\nHELLOWORLD $\\Rightarrow$ HHELLLOWOORLLD. Similarly, if you highlight nothing, you obtain HELLOWORLD, and if you highlight all of the letters, you obtain HHEELLLLOOWWOORRLLDD. Notice how each occurrence of the same letter can be highlighted independently.\n\nGiven a string, there are multiple strings that can be obtained as a result of this process, depending on the highlighting choices. Among all of those strings, output the one that appears first in alphabetical (also known as lexicographical) order.\n\nNote: A string $s$ appears before a different string $t$ in alphabetical order if $s$ is a prefix of $t$ or if at the first place $s$ and $t$ differ, the letter in $s$ is earlier in the alphabet than the letter in $t$. For example, these strings are in alphabetical order: CODE, HELLO, HI, HIM, HOME, JAM.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in a single line containing a single string $\\mathbf{S}$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the string that comes first alphabetically from the set of strings that can be produced from $\\mathbf{S}$ by the process described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, these are all the strings that can be obtained, in alphabetical order: PEEEEL, PEEEELL, PEEEL, PEEELL, PEEL, PEELL, PPEEEEL, PPEEEELL, PPEEEL, PPEEELL, PPEEL, and PPEELL.\n\nIn Sample Case #2, every string that can be obtained contains only As. The shortest of those is alphabetically first, because it is a prefix of all others.\n\nIn Sample Case #3, there are 1024 possible strings which can be generated from CODEJAMDAY out of which CCODDEEJAAMDAAY is the lexicographically smallest one.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{S}$ is an uppercase letter from the English alphabet.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 10$.\n\n**Test Set 2 (15 Pts, Hidden Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1A] Double or One Thing", "background": "", "description": "You are given a string of uppercase English letters. You can highlight any number of the letters (possibly all or none of them). The highlighted letters do not need to be consecutive. Then, a new string is produced by processing the letters from left to right: non-highlighted letters are appended once to the new string, while highlighted letters are appended twice.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q5ybwo42.png)\n\nFor example, if the initial string is HELLOWORLD, you could highlight the H, the first and last Ls and the last o to obtain\n\nHELLOWORLD $\\Rightarrow$ HHELLLOWOORLLD. Similarly, if you highlight nothing, you obtain HELLOWORLD, and if you highlight all of the letters, you obtain HHEELLLLOOWWOORRLLDD. Notice how each occurrence of the same letter can be highlighted independently.\n\nGiven a string, there are multiple strings that can be obtained as a result of this process, depending on the highlighting choices. Among all of those strings, output the one that appears first in alphabetical (also known as lexicographical) order.\n\nNote: A string $s$ appears before a different string $t$ in alphabetical order if $s$ is a prefix of $t$ or if at the first place $s$ and $t$ differ, the letter in $s$ is earlier in the alphabet than the letter in $t$. For example, these strings are in alphabetical order: CODE, HELLO, HI, HIM, HOME, JAM.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in a single line containing a single string $\\mathbf{S}$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the string that comes first alphabetically from the set of strings that can be produced from $\\mathbf{S}$ by the process described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, these are all the strings that can be obtained, in alphabetical order: PEEEEL, PEEEELL, PEEEL, PEEELL, PEEL, PEELL, PPEEEEL, PPEEEELL, PPEEEL, PPEEELL, PPEEL, and PPEELL.\n\nIn Sample Case #2, every string that can be obtained contains only As. The shortest of those is alphabetically first, because it is a prefix of all others.\n\nIn Sample Case #3, there are 1024 possible strings which can be generated from CODEJAMDAY out of which CCODDEEJAAMDAAY is the lexicographically smallest one.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{S}$ is an uppercase letter from the English alphabet.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 10$.\n\n**Test Set 2 (15 Pts, Hidden Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1A] Double or One Thing", "background": "", "description": "给定一个由大写英文字母组成的字符串。你可以选择高亮其中任意数量的字母（可以是全部、部分或不选）。被高亮的字母不需要是连续的。然后，通过从左到右处理字母生成一个新字符串：未高亮的字母在新字符串中只出现一次，而被高亮的字母会重复出现两次。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/q5ybwo42.png)\n\n例如，初始字符串为 HELLOWORLD 时，你可以高亮 H、第一个和最后一个 L 以及最后一个 O，得到：HELLOWORLD $\\Rightarrow$ HHELLLOWOORLLD。类似地，如果什么都不高亮，得到的是原字符串 HELLOWORLD；如果全部高亮，则得到 HHEELLLLOOWWOORRLLDD。注意：相同的字母可以独立选择是否高亮。\n\n对于一个给定的字符串，根据高亮选择的不同，可以生成多种不同的结果字符串。在所有可能的生成字符串中，输出按字典序排列最靠前的一个。\n\n注：若字符串 $s$ 是字符串 $t$ 的前缀，或者 $s$ 和 $t$ 在第一个不同字符处 $s$ 的字母在字母表中更靠前，则认为 $s$ 在字典序中排在 $t$ 之前。例如以下字符串按字典序排列为：CODE, HELLO, HI, HIM, HOME, JAM。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例，每个测试用例单独一行，包含一个字符串 $\\mathbf{S}$。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是通过上述过程从 $\\mathbf{S}$ 生成的所有可能字符串中字典序最小的那个。", "hint": "**样例解释**\n\n在样例 #1 中，所有可能的生成字符串按字典序排列为：PEEEEL, PEEEELL, PEEEL, PEEELL, PEEL, PEELL, PPEEEEL, PPEEEELL, PPEEEL, PPEEELL, PPEEL 和 PPEELL。\n\n在样例 #2 中，所有可能的生成字符串都只包含字母 A，其中最短的字符串字典序最靠前，因为它是其他所有字符串的前缀。\n\n在样例 #3 中，从 CODEJAMDAY 可以生成 1024 种不同的字符串，其中 CCODDEEJAAMDAAY 是字典序最小的一个。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 字符串 $\\mathbf{S}$ 中的每个字符都是大写英文字母。\n\n**测试集 1（10 分，可见评测结果）**\n\n- $1 \\leq$ 字符串 $\\mathbf{S}$ 的长度 $\\leq 10$。\n\n**测试集 2（15 分，隐藏评测结果）**\n\n- $1 \\leq$ 字符串 $\\mathbf{S}$ 的长度 $\\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12985", "type": "P", "difficulty": 5, "samples": [["2\n3\n\n10 4 9\n\n3\n\n10 8 12", "\n\n5 1 3\n\n1 10 5\n\n5 2 3\n\n12 8"]], "limits": {"time": [5000], "memory": [1048576]}, "tags": ["数学", "贪心", "2022", "交互题", "Special Judge", "进制", "构造", "Google Code Jam"], "title": "[GCJ 2022 #1A] Equal Sum", "background": "", "description": "You are given a set of distinct integers. You need to separate them into two non-empty subsets such that each element belongs to exactly one of them and the sum of all elements of each subset is the same.\n\nAn anonymous tip told us that the problem above was unlikely to be solved in polynomial time (or something like that), so we decided to change it. Now you get to decide what half of the integers are!\n\nThis is an interactive problem with three phases. In phase 1, you choose $\\mathbf{N}$ distinct integers. In phase 2, you are given another $\\mathbf{N}$ integers that are distinct from each other and from the ones you chose in phase 1. In phase 3, you have to partition those $2\\mathbf{N}$ integers into two subsets, both of which sum to the same amount. All $2\\mathbf{N}$ integers are to be between 1 and $10^9$, inclusive, and it is guaranteed that they sum up to an even number.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing an integer, $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nFor each test case, your program must first read a line containing a single integer $\\mathbf{N}$. Then, it must output a line containing $\\mathbf{N}$ distinct integers $A_1, A_2, \\ldots, A_{\\mathbf{N}}$. Each of these integers must be between 1 and $10^9$, inclusive. After that, your program must read a line containing $\\mathbf{N}$ additional integers $B_1, B_2, \\ldots, B_{\\mathbf{N}}$. Finally, your program must output a line containing between 1 and $2\\mathbf{N}-1$ integers from among $A_1, A_2, \\ldots, A_{\\mathbf{N}}, B_1, B_2, \\ldots, B_{\\mathbf{N}}$: the ones chosen to be part of the first subset. The integers from $A$ and $B$ that you do not output are considered to be part of the other subset.\n\nThe next test case starts immediately if there is one. If this was the last test case, the judge will expect no more output and will send no further input to your program. In addition, all $\\mathbf{T}$ test cases are always processed, regardless of whether the final output from your program is correct or not.\n\nNote: It can be shown that given the limits for this problem, there exists a sequence $A_1, A_2, \\ldots, A_{\\mathbf{N}}$ such that any sequence $B_1, B_2, \\ldots, B_{\\mathbf{N}}$ results in a set of $2\\mathbf{N}$ integers that can be separated into two subsets with equal sums.\n\nIf the judge receives an invalidly formatted or invalid line (like outputting an unexpected number of integers, or integers out of range, or repeated integers in a line) from your program at any moment, the judge will print a single number -1 and will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nIn the sample interaction above, the solution gets all cases right and would receive a correct verdict. Notice that the value for $\\mathbf{N}$ does not conform to the limits for the Test Set and is used to simplify the example only. Notice that the judge could have given the solution the integers $\\{2, 7, 100\\}$ for the first case, making it impossible for the solution to find a valid partition into subsets of equal sum.\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n**Test Set 1 (Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{N} = 100$.\n- $1 \\leq \\mathbf{B}_i \\leq 10^9$, for all $i$.\n- $\\mathbf{B}_i \\neq A_j$, for all $i, j$.\n- $\\mathbf{B}_i \\neq \\mathbf{B}_j$, for all $i \\neq j$.\n- For each test case, the judge will choose the $\\mathbf{B}_i$s such that the sum of all $2\\mathbf{N}$ integers is even.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1A] Equal Sum", "background": "", "description": "You are given a set of distinct integers. You need to separate them into two non-empty subsets such that each element belongs to exactly one of them and the sum of all elements of each subset is the same.\n\nAn anonymous tip told us that the problem above was unlikely to be solved in polynomial time (or something like that), so we decided to change it. Now you get to decide what half of the integers are!\n\nThis is an interactive problem with three phases. In phase 1, you choose $\\mathbf{N}$ distinct integers. In phase 2, you are given another $\\mathbf{N}$ integers that are distinct from each other and from the ones you chose in phase 1. In phase 3, you have to partition those $2\\mathbf{N}$ integers into two subsets, both of which sum to the same amount. All $2\\mathbf{N}$ integers are to be between 1 and $10^9$, inclusive, and it is guaranteed that they sum up to an even number.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing an integer, $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nFor each test case, your program must first read a line containing a single integer $\\mathbf{N}$. Then, it must output a line containing $\\mathbf{N}$ distinct integers $A_1, A_2, \\ldots, A_{\\mathbf{N}}$. Each of these integers must be between 1 and $10^9$, inclusive. After that, your program must read a line containing $\\mathbf{N}$ additional integers $B_1, B_2, \\ldots, B_{\\mathbf{N}}$. Finally, your program must output a line containing between 1 and $2\\mathbf{N}-1$ integers from among $A_1, A_2, \\ldots, A_{\\mathbf{N}}, B_1, B_2, \\ldots, B_{\\mathbf{N}}$: the ones chosen to be part of the first subset. The integers from $A$ and $B$ that you do not output are considered to be part of the other subset.\n\nThe next test case starts immediately if there is one. If this was the last test case, the judge will expect no more output and will send no further input to your program. In addition, all $\\mathbf{T}$ test cases are always processed, regardless of whether the final output from your program is correct or not.\n\nNote: It can be shown that given the limits for this problem, there exists a sequence $A_1, A_2, \\ldots, A_{\\mathbf{N}}$ such that any sequence $B_1, B_2, \\ldots, B_{\\mathbf{N}}$ results in a set of $2\\mathbf{N}$ integers that can be separated into two subsets with equal sums.\n\nIf the judge receives an invalidly formatted or invalid line (like outputting an unexpected number of integers, or integers out of range, or repeated integers in a line) from your program at any moment, the judge will print a single number -1 and will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nIn the sample interaction above, the solution gets all cases right and would receive a correct verdict. Notice that the value for $\\mathbf{N}$ does not conform to the limits for the Test Set and is used to simplify the example only. Notice that the judge could have given the solution the integers $\\{2, 7, 100\\}$ for the first case, making it impossible for the solution to find a valid partition into subsets of equal sum.\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n**Test Set 1 (Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{N} = 100$.\n- $1 \\leq \\mathbf{B}_i \\leq 10^9$, for all $i$.\n- $\\mathbf{B}_i \\neq A_j$, for all $i, j$.\n- $\\mathbf{B}_i \\neq \\mathbf{B}_j$, for all $i \\neq j$.\n- For each test case, the judge will choose the $\\mathbf{B}_i$s such that the sum of all $2\\mathbf{N}$ integers is even.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1A] Equal Sum", "background": "", "description": "给定一组互不相同的整数，你需要将它们分成两个非空子集，使得每个元素恰好属于其中一个子集，且两个子集中所有元素的和相等。\n\n匿名提示称上述问题不太可能在多项式时间内解决（或类似结论），因此我们决定修改题目。现在，你可以自行决定其中一半的整数！\n\n这是一个包含三个阶段的交互题：\n1. **阶段1**：你选择 $\\mathbf{N}$ 个互不相同的整数。\n2. **阶段2**：系统会额外提供 $\\mathbf{N}$ 个整数，这些整数彼此不同且与你选择的整数不同。\n3. **阶段3**：你需要将这 $2\\mathbf{N}$ 个整数划分为两个和相等的子集。\n\n所有整数的取值范围为 $1$ 到 $10^9$（含），且保证它们的总和为偶数。\n\n### 交互协议\n\n这是一个交互问题。\n\n初始时，你的程序需读取一个整数 $\\mathbf{T}$ 表示测试用例数量，随后处理 $\\mathbf{T}$ 个测试用例。\n\n对于每个测试用例：\n1. 程序先读取一个整数 $\\mathbf{N}$。\n2. 程序输出一行包含 $\\mathbf{N}$ 个互不相同的整数 $A_1, A_2, \\ldots, A_{\\mathbf{N}}$（每个整数在 $1$ 到 $10^9$ 范围内）。\n3. 程序读取一行包含 $\\mathbf{N}$ 个额外整数 $B_1, B_2, \\ldots, B_{\\mathbf{N}}$。\n4. 程序输出一行包含 $1$ 到 $2\\mathbf{N}-1$ 个整数（从 $A$ 和 $B$ 的并集中选择），表示第一个子集的元素。未输出的元素自动归入第二个子集。\n\n当前测试用例结束后，立即处理下一个（若存在）。所有测试用例均会被处理，无论最终输出是否正确。\n\n注意：可以证明在本题限制下，存在至少一组 $A_1, A_2, \\ldots, A_{\\mathbf{N}}$ 使得对任意给定的 $B_1, B_2, \\ldots, B_{\\mathbf{N}}$，都能将 $2\\mathbf{N}$ 个整数划分为和相等的两个子集。\n\n若程序在任何时刻输出格式非法（如整数数量不符、范围越界或重复），裁判将返回 $-1$ 并终止交互。若程序未及时退出，将判为 **Time Limit Exceeded**。内存超限或运行时错误将得到相应判果。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**样例解释**\n\n上述样例交互中，程序正确解决了所有测试用例。注意：样例中的 $\\mathbf{N}$ 值不符合实际测试集限制，仅用于简化示例。若裁判在第一用例中给出 $\\{2, 7, 100\\}$，则可能无法找到合法划分。\n\n可使用本地测试工具或平台调试。本地测试需配合交互运行器（详见工具文件注释）。\n\n**限制条件**\n\n**测试集 1（可见判果）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $\\mathbf{N} = 100$。\n- $1 \\leq \\mathbf{B}_i \\leq 10^9$（对所有 $i$）。\n- $\\mathbf{B}_i \\neq A_j$（对所有 $i, j$）。\n- $\\mathbf{B}_i \\neq \\mathbf{B}_j$（对所有 $i \\neq j$）。\n- 每个测试用例中，裁判选择的 $\\mathbf{B}_i$ 保证 $2\\mathbf{N}$ 个整数的和为偶数。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12986", "type": "P", "difficulty": 5, "samples": [["3\n3 1\n1\n2\n1\n2 3\n1 2 1\n2 1 2\n3 3\n3 1 1\n3 3 3\n2 3 3", "Case #1: 4\nCase #2: 12\nCase #3: 20"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2022", "Google Code Jam"], "title": "[GCJ 2022 #1A] Weightlifting", "background": "", "description": "You are following a prescribed training for weightlifting. The training consists of a series of exercises that you must do in order. Each exercise requires a specific set of weights to be placed on a machine.\n\nThere are $\\mathbf{W}$ types of different weights. For example, an exercise may require 3 weights of type A and 1 weight of type B, while the next requires 2 weights each of types A, C, and D.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0e2my7uz.png)\n\nThe weights are placed on the machine as a stack. Formally, with a single operation, you can either add a new weight of any type to the top of the stack, or remove the weight that is currently at the top of the stack.\n\nYou can load the weights for each exercise onto the machine's stack in any order. So, if you place the weight of type B at the bottom in the first exercise of the example above, you will have to take all the weights off before putting on the weights for the second exercise. On the other hand, if you place the weight of type B third from the bottom, you can leave two of the weights of type A on the bottom of the stack to be part of the next exercise's set, saving you some time.\n\nGiven the amount of weights of each type needed for each exercise, find the minimum number of operations needed to do them all. You must complete the exercises in the order given. The machine stack starts out empty, and you must leave it empty after you finish with all your exercises.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing 2 integers $\\mathbf{E}$ and $\\mathbf{W}$: the number of exercises and the number of types of weights. Weight types are numbered between 1 and $\\mathbf{W}$. Then, $\\mathbf{E}$ lines follow. The $i$-th of these lines contains $\\mathbf{W}$ integers $\\mathbf{X}_{i,1}$, $\\mathbf{X}_{i,2}$, $\\ldots$, $\\mathbf{X}_{i,\\mathbf{W}}$ representing that the $i$-th exercise requires exactly $\\mathbf{X}_{i,j}$ weights of type $j$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of machine stack operations needed to run through all your exercises.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is only one type of weight. The first exercise needs 1 weight, the second needs 2 weights, and the third needs 1 weight. You can complete the exercise in 4 operations as follows:\n\n1. Add a weight onto the stack. You do the first exercise.\n2. Add a weight onto the stack. You do the second exercise.\n3. Remove a weight from the top of the stack. You do the third exercise.\n4. Remove a weight from the top of the stack. Now the stack becomes empty.\n\nIn Sample Case #2, one way to complete the exercises in 12 operations is as follows:\n\n1. Add a weight of type 2.\n2. Add a weight of type 3.\n3. Add a weight of type 1.\n4. Add a weight of type 2. Now the stack contains weights of types 2, 3, 1, 2 from bottom to top. You do the first exercise.\n5. Remove a weight of type 2 from the top of the stack.\n6. Add a weight of type 3.\n7. Add a weight of type 1. Now the stack contains weights of types 2, 3, 1, 3, 1 from bottom to top. You do the second exercise.\n8. Remove a weight of type 1 from the top of the stack.\n9. Remove a weight of type 3 from the top of the stack.\n10. Remove a weight of type 1 from the top of the stack.\n11. Remove a weight of type 3 from the top of the stack.\n12. Remove a weight of type 2 from the top of the stack. Now the stack becomes empty.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{X}_{i,1} + \\mathbf{X}_{i,2} + \\cdots + \\mathbf{X}_{i,\\mathbf{W}}$, for all $i$. (Each exercise requires at least one weight.)\n\n**Test Set 1 (13 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{E} \\leq 10$.\n- $1 \\leq \\mathbf{W} \\leq 3$.\n- $0 \\leq \\mathbf{X}_{i,j} \\leq 3$, for all $i, j$.\n\n**Test Set 2 (31 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{E} \\leq 100$.\n- $1 \\leq \\mathbf{W} \\leq 100$.\n- $0 \\leq \\mathbf{X}_{i,j} \\leq 100$, for all $i, j$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1A] Weightlifting", "background": "", "description": "You are following a prescribed training for weightlifting. The training consists of a series of exercises that you must do in order. Each exercise requires a specific set of weights to be placed on a machine.\n\nThere are $\\mathbf{W}$ types of different weights. For example, an exercise may require 3 weights of type A and 1 weight of type B, while the next requires 2 weights each of types A, C, and D.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0e2my7uz.png)\n\nThe weights are placed on the machine as a stack. Formally, with a single operation, you can either add a new weight of any type to the top of the stack, or remove the weight that is currently at the top of the stack.\n\nYou can load the weights for each exercise onto the machine's stack in any order. So, if you place the weight of type B at the bottom in the first exercise of the example above, you will have to take all the weights off before putting on the weights for the second exercise. On the other hand, if you place the weight of type B third from the bottom, you can leave two of the weights of type A on the bottom of the stack to be part of the next exercise's set, saving you some time.\n\nGiven the amount of weights of each type needed for each exercise, find the minimum number of operations needed to do them all. You must complete the exercises in the order given. The machine stack starts out empty, and you must leave it empty after you finish with all your exercises.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing 2 integers $\\mathbf{E}$ and $\\mathbf{W}$: the number of exercises and the number of types of weights. Weight types are numbered between 1 and $\\mathbf{W}$. Then, $\\mathbf{E}$ lines follow. The $i$-th of these lines contains $\\mathbf{W}$ integers $\\mathbf{X}_{i,1}$, $\\mathbf{X}_{i,2}$, $\\ldots$, $\\mathbf{X}_{i,\\mathbf{W}}$ representing that the $i$-th exercise requires exactly $\\mathbf{X}_{i,j}$ weights of type $j$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of machine stack operations needed to run through all your exercises.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is only one type of weight. The first exercise needs 1 weight, the second needs 2 weights, and the third needs 1 weight. You can complete the exercise in 4 operations as follows:\n\n1. Add a weight onto the stack. You do the first exercise.\n2. Add a weight onto the stack. You do the second exercise.\n3. Remove a weight from the top of the stack. You do the third exercise.\n4. Remove a weight from the top of the stack. Now the stack becomes empty.\n\nIn Sample Case #2, one way to complete the exercises in 12 operations is as follows:\n\n1. Add a weight of type 2.\n2. Add a weight of type 3.\n3. Add a weight of type 1.\n4. Add a weight of type 2. Now the stack contains weights of types 2, 3, 1, 2 from bottom to top. You do the first exercise.\n5. Remove a weight of type 2 from the top of the stack.\n6. Add a weight of type 3.\n7. Add a weight of type 1. Now the stack contains weights of types 2, 3, 1, 3, 1 from bottom to top. You do the second exercise.\n8. Remove a weight of type 1 from the top of the stack.\n9. Remove a weight of type 3 from the top of the stack.\n10. Remove a weight of type 1 from the top of the stack.\n11. Remove a weight of type 3 from the top of the stack.\n12. Remove a weight of type 2 from the top of the stack. Now the stack becomes empty.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{X}_{i,1} + \\mathbf{X}_{i,2} + \\cdots + \\mathbf{X}_{i,\\mathbf{W}}$, for all $i$. (Each exercise requires at least one weight.)\n\n**Test Set 1 (13 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{E} \\leq 10$.\n- $1 \\leq \\mathbf{W} \\leq 3$.\n- $0 \\leq \\mathbf{X}_{i,j} \\leq 3$, for all $i, j$.\n\n**Test Set 2 (31 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{E} \\leq 100$.\n- $1 \\leq \\mathbf{W} \\leq 100$.\n- $0 \\leq \\mathbf{X}_{i,j} \\leq 100$, for all $i, j$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1A] Weightlifting", "background": "", "description": "你正在按照一套举重训练计划进行训练。该训练由一系列必须按顺序完成的动作组成，每个动作需要在器械上放置特定的配重组合。\n\n共有 $\\mathbf{W}$ 种不同类型的配重。例如，某个动作可能需要 3 个 A 型配重和 1 个 B 型配重，而下一个动作可能需要 2 个 A 型、2 个 C 型和 2 个 D 型配重。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0e2my7uz.png)\n\n配重以**堆栈**形式放置在器械上。每次操作你可以：\n- 将任意类型的新配重添加到堆栈顶部\n- 或移除当前位于堆栈顶部的配重\n\n每个动作所需的配重可以按任意顺序装载。例如，若在第一个动作中将 B 型配重放在最底层，那么在装载第二个动作的配重前需要清空所有配重；但若将 B 型配重放在倒数第三层，则可保留底部的两个 A 型配重用于下一个动作，从而减少操作次数。\n\n给定每个动作所需的各类配重数量，计算完成所有训练所需的最少操作次数。训练必须按给定顺序完成，器械堆栈初始为空，训练结束后也必须恢复为空栈。", "inputFormat": "第一行输入测试用例数量 $\\mathbf{T}$。每个测试用例首行包含两个整数 $\\mathbf{E}$（动作数量）和 $\\mathbf{W}$（配重类型数，编号为 1 到 $\\mathbf{W}$）。随后 $\\mathbf{E}$ 行中，第 $i$ 行包含 $\\mathbf{W}$ 个整数 $\\mathbf{X}_{i,1}, \\mathbf{X}_{i,2}, \\ldots, \\mathbf{X}_{i,\\mathbf{W}}$，表示第 $i$ 个动作需要 $\\mathbf{X}_{i,j}$ 个 $j$ 型配重。\n", "outputFormat": "对每个测试用例输出 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为完成所有训练的最少操作次数。\n", "hint": "**样例解释**\n\n样例 #1 仅含 1 种配重类型：\n1. 添加 1 个配重（完成第 1 个动作）\n2. 再添加 1 个配重（完成第 2 个动作）\n3. 移除 1 个配重（完成第 3 个动作）\n4. 移除最后 1 个配重（恢复空栈）\n\n样例 #2 的 12 次操作方案：\n1. 添加 2 型 → [2]\n2. 添加 3 型 → [2,3] \n3. 添加 1 型 → [2,3,1]\n4. 添加 2 型 → [2,3,1,2]（完成第 1 个动作）\n5. 移除 2 型 → [2,3,1]\n6. 添加 3 型 → [2,3,1,3]\n7. 添加 1 型 → [2,3,1,3,1]（完成第 2 个动作）\n8-12. 按 1→3→1→3→2 顺序移除所有配重\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$\n- 每个动作至少需要 1 个配重（$\\mathbf{X}_{i,1} + \\cdots + \\mathbf{X}_{i,\\mathbf{W}} \\geq 1$）\n\n**测试集 1（13 分，可见判果）**\n- $1 \\leq \\mathbf{E} \\leq 10$\n- $1 \\leq \\mathbf{W} \\leq 3$ \n- $0 \\leq \\mathbf{X}_{i,j} \\leq 3$\n\n**测试集 2（31 分，隐藏判果）**\n- $1 \\leq \\mathbf{E} \\leq 100$\n- $1 \\leq \\mathbf{W} \\leq 100$\n- $0 \\leq \\mathbf{X}_{i,j} \\leq 100$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12987", "type": "P", "difficulty": 2, "samples": [["4\n2\n1 5\n4\n1 4 2 3\n5\n10 10 10 10 10\n4\n7 1 3 1000000", "Case #1: 2\nCase #2: 3\nCase #3: 5\nCase #4: 2"]], "limits": {"time": [2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2022", "Google Code Jam"], "title": "[GCJ 2022 #1B] Pancake Deque", "background": "", "description": "Pancakes are normally served in stacks, but the Infinite House of Pancakes embraces change! The restaurant's new advertising hook is to serve the pancakes from a deque, or double-ended queue.\n\nYou are a server at the restaurant, and your job is to serve every pancake in the deque. Customers will arrive one at a time, and each one gets a single pancake. You must serve each customer either the leftmost or rightmost pancake in the deque; the choice is yours. When a pancake is served, it disappears from the deque, exposing the pancake that was next to it. Or, once there is only one pancake left, your only choice is to serve that one, and then your job is complete!\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jn04ll9k.png)\n\nEach pancake has a deliciousness level. Because customers do not get to choose which pancakes they get, each customer only has to pay for their pancake if it is at least as delicious as each of the pancakes that all of the previous customers got. (The first customer always pays for their pancake, since in that case there are no previous customers.)\n\nHow many customers will pay for their pancake, if you serve the pancakes in an order that maximizes that number?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case is described with two lines. The first line of a test case contains a single integer $N$, the number of pancakes in the pancake deque. The second line of a test case contains $N$ integers $D_1$, $D_2$, $\\ldots$, $D_N$, where $D_i$ is the deliciousness level of the $i$-th pancake from the left in the deque.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of customers who pay for their pancakes, if you serve the pancakes in an order that maximizes that number.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are two possible orders in which you can serve the pancakes. If you serve the pancake with deliciousness level 5 first, only that one is paid for. If you serve the pancake with deliciousness level 1 first, both are paid for.\n\nSample Case #2 is the image shown in the problem statement. The following are the possible orders (by deliciousness level) in which the pancakes can be served. The underlined pancakes are the ones that customers pay for.\n\n* $\\underline{1}, 4, 2, 3$\n* $\\underline{1}, 4, 3, 2$\n* $\\underline{1}, \\underline{3}, 4, 2$\n* $\\underline{1}, \\underline{3}, 2, \\underline{4}$\n* $\\underline{3}, 1, \\underline{4}, 2$\n* $\\underline{3}, 1, 2, \\underline{4}$\n* $\\underline{3}, 2, 1, \\underline{4}$\n* $\\underline{3}, 2, \\underline{4}, 1$\n\nAs you can see, there are some orders in which 3 pancakes are paid for, and none in which all 4 are.\n\nIn Sample Case #3, all pancakes are paid for regardless of the serving order.\n\nIn Sample Case #4, regardless of which pancake you serve first, the two in the middle will never be paid for. The best you can do is serve the pancake with deliciousness 7 before the pancake with deliciousness 1000000.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D}_{\\mathbf{i}} \\leq 10^{6}$, for all $i$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 20$.\n\n**Test Set 2 (8 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 3 (10 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1B] Pancake Deque", "background": "", "description": "Pancakes are normally served in stacks, but the Infinite House of Pancakes embraces change! The restaurant's new advertising hook is to serve the pancakes from a deque, or double-ended queue.\n\nYou are a server at the restaurant, and your job is to serve every pancake in the deque. Customers will arrive one at a time, and each one gets a single pancake. You must serve each customer either the leftmost or rightmost pancake in the deque; the choice is yours. When a pancake is served, it disappears from the deque, exposing the pancake that was next to it. Or, once there is only one pancake left, your only choice is to serve that one, and then your job is complete!\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jn04ll9k.png)\n\nEach pancake has a deliciousness level. Because customers do not get to choose which pancakes they get, each customer only has to pay for their pancake if it is at least as delicious as each of the pancakes that all of the previous customers got. (The first customer always pays for their pancake, since in that case there are no previous customers.)\n\nHow many customers will pay for their pancake, if you serve the pancakes in an order that maximizes that number?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case is described with two lines. The first line of a test case contains a single integer $N$, the number of pancakes in the pancake deque. The second line of a test case contains $N$ integers $D_1$, $D_2$, $\\ldots$, $D_N$, where $D_i$ is the deliciousness level of the $i$-th pancake from the left in the deque.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of customers who pay for their pancakes, if you serve the pancakes in an order that maximizes that number.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are two possible orders in which you can serve the pancakes. If you serve the pancake with deliciousness level 5 first, only that one is paid for. If you serve the pancake with deliciousness level 1 first, both are paid for.\n\nSample Case #2 is the image shown in the problem statement. The following are the possible orders (by deliciousness level) in which the pancakes can be served. The underlined pancakes are the ones that customers pay for.\n\n* $\\underline{1}, 4, 2, 3$\n* $\\underline{1}, 4, 3, 2$\n* $\\underline{1}, \\underline{3}, 4, 2$\n* $\\underline{1}, \\underline{3}, 2, \\underline{4}$\n* $\\underline{3}, 1, \\underline{4}, 2$\n* $\\underline{3}, 1, 2, \\underline{4}$\n* $\\underline{3}, 2, 1, \\underline{4}$\n* $\\underline{3}, 2, \\underline{4}, 1$\n\nAs you can see, there are some orders in which 3 pancakes are paid for, and none in which all 4 are.\n\nIn Sample Case #3, all pancakes are paid for regardless of the serving order.\n\nIn Sample Case #4, regardless of which pancake you serve first, the two in the middle will never be paid for. The best you can do is serve the pancake with deliciousness 7 before the pancake with deliciousness 1000000.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D}_{\\mathbf{i}} \\leq 10^{6}$, for all $i$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 20$.\n\n**Test Set 2 (8 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 3 (10 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1B] Pancake Deque", "background": "", "description": "煎饼通常以堆叠的形式供应，但**无限煎饼屋**勇于变革！该餐厅的新广告噱头是将煎饼以双端队列（deque）的形式供应。\n\n你是餐厅的服务员，你的工作是从双端队列中供应所有煎饼。顾客会依次到来，每位顾客获得一个煎饼。你必须为每位顾客供应当前双端队列的最左端或最右端的煎饼，选择权在你手中。当一个煎饼被供应后，它会从队列中消失，露出相邻的煎饼。或者，当只剩一个煎饼时，你只能供应它，此时你的工作就完成了！\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jn04ll9k.png)\n\n每个煎饼有一个美味值。由于顾客无法选择自己获得的煎饼，只有当一个煎饼的美味值**不低于**之前所有顾客获得的煎饼的美味值时，该顾客才需要为其煎饼付费。（第一位顾客总是需要付费，因为此时没有之前的顾客。）\n\n如果你以最大化付费顾客数量的顺序供应煎饼，有多少顾客会为其煎饼付费？", "inputFormat": "输入的第一行包含测试用例的数量 $T$。随后是 $T$ 个测试用例。每个测试用例由两行描述：第一行包含一个整数 $N$，表示双端队列中煎饼的数量；第二行包含 $N$ 个整数 $D_1, D_2, \\ldots, D_N$，其中 $D_i$ 表示队列中从左数第 $i$ 个煎饼的美味值。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是以最大化付费顾客数量的顺序供应煎饼时的付费顾客数。\n", "hint": "**样例解释**\n\n在样例 #1 中，有两种供应煎饼的顺序。如果先供应美味值为 5 的煎饼，则只有该顾客付费；如果先供应美味值为 1 的煎饼，则两位顾客都会付费。\n\n样例 #2 对应题目描述中的图片。以下是可能的供应顺序（按美味值），下划线的煎饼表示顾客需要付费：\n- $\\underline{1}, 4, 2, 3$\n- $\\underline{1}, 4, 3, 2$\n- $\\underline{1}, \\underline{3}, 4, 2$\n- $\\underline{1}, \\underline{3}, 2, \\underline{4}$\n- $\\underline{3}, 1, \\underline{4}, 2$\n- $\\underline{3}, 1, 2, \\underline{4}$\n- $\\underline{3}, 2, 1, \\underline{4}$\n- $\\underline{3}, 2, \\underline{4}, 1$\n\n可以看到，某些顺序下会有 3 个煎饼被付费，但没有一种顺序能让所有 4 个煎饼都付费。\n\n在样例 #3 中，无论以何种顺序供应，所有煎饼都会被付费。\n\n在样例 #4 中，无论先供应哪个煎饼，中间的两个煎饼都不会被付费。最佳策略是先供应美味值为 7 的煎饼，再供应美味值为 1000000 的煎饼。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq D_i \\leq 10^6$（对所有 $i$ 成立）。\n\n**测试集 1（7 分，可见判定）**\n\n- $2 \\leq N \\leq 20$。\n\n**测试集 2（8 分，可见判定）**\n\n- $2 \\leq N \\leq 100$。\n\n**测试集 3（10 分，隐藏判定）**\n\n- $2 \\leq N \\leq 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12988", "type": "P", "difficulty": 4, "samples": [["2\n3 3\n30 10 40\n20 50 60\n60 60 50\n5 2\n1 1000000000\n500000000 1000000000\n1 1000000000\n500000000 1\n1 1000000000", "Case #1: 110\nCase #2: 4999999996"]], "limits": {"time": [5000, 5000, 5000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2022", "Google Code Jam"], "title": "[GCJ 2022 #1B] Controlled Inflation", "background": "", "description": "The lines at the air pump at your gas station are getting too long! You want to optimize the process to help customers more quickly inflate their tires, sports balls, giant parade balloon animals, and other products.\n\nThe pump is automatic: you set the pressure to a specific number of pascals and plug the pump into the inflatable product, and it will inflate as needed to that exact pressure. There are only two buttons on the pump: up and down. They increase and decrease the target pressure, respectively, by exactly $1$ pascal.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9382itkr.png)\n\nThere is a line of $\\mathbf{N}$ customers, each of whom brings exactly $\\mathbf{P}$ products that they need to get inflated by the pump. You know the target pressure of each product. You can inflate the products from a customer in any order you want, but you cannot change the order of the customers. Specifically, you must inflate all products from the $i$-th customer before inflating any from the $(i+1)$-th customer. In between handling two products, if those two products have different target pressures, you need to use the buttons on the pump.\n\nThe pump is initially set to 0 pascals, and it can be left at any number after all products of all customers have been inflated. If you order the products of each customer optimally, what is the minimum number of button presses you need?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers, $\\mathbf{N}$ and $\\mathbf{P}$: the number of customers and the number of products each customer brings, respectively. Then, $\\mathbf{N}$ lines follow. The $i$-th of these lines contains $\\mathbf{P}$ integers $\\mathbf{X}_{\\mathbf{i}, 1}, \\mathbf{X}_{\\mathbf{i}, 2}, \\ldots, \\mathbf{X}_{\\mathbf{i}, \\mathbf{P}}$, representing that the $j$-th product that the $i$-th customer brings has a target pressure of $\\mathbf{X}_{\\mathbf{i}, \\mathbf{j}}$ pascals.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of button presses needed to inflate all products according to their specified pressures.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, an optimal way to use the pump is:\n\n1. press up 10 times, setting the pump to 10; pump the product (from customer 1) that needs 10 pascals,\n2. press up 30 times, setting the pump to 40; pump the product (from customer 1) that needs 40 pascals,\n3. press down 10 times, setting the pump to 30; pump the product (from customer 1) that needs 30 pascals,\n4. press down 10 times, setting the pump to 20; pump the product (from customer 2) that needs 20 pascals,\n5. press up 30 times, setting the pump to 50; pump the product (from customer 2) that needs 50 pascals,\n6. press up 10 times, setting the pump to 60; pump the product (from customer 2) and the two products (from customer 3) that need 60 pascals, and finally\n7. press down 10 times, setting the pump to 50; pump the product (from customer 3) that needs 50 pascals.\n\nThis is a total of 110 button presses.\n\nIn Sample Case #2, notice that the answer can be larger than $2^{32}$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{X}_{\\mathbf{i}, \\mathbf{j}} \\leq 10^{9}$, for all $i, j$.\n\n**Test Set 1 (14 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10$.\n- $2 \\leq \\mathbf{P} \\leq 3$.\n\n**Test Set 2 (21 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 1000$.\n- $2 \\leq \\mathbf{P} \\leq 100$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1B] Controlled Inflation", "background": "", "description": "The lines at the air pump at your gas station are getting too long! You want to optimize the process to help customers more quickly inflate their tires, sports balls, giant parade balloon animals, and other products.\n\nThe pump is automatic: you set the pressure to a specific number of pascals and plug the pump into the inflatable product, and it will inflate as needed to that exact pressure. There are only two buttons on the pump: up and down. They increase and decrease the target pressure, respectively, by exactly $1$ pascal.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9382itkr.png)\n\nThere is a line of $\\mathbf{N}$ customers, each of whom brings exactly $\\mathbf{P}$ products that they need to get inflated by the pump. You know the target pressure of each product. You can inflate the products from a customer in any order you want, but you cannot change the order of the customers. Specifically, you must inflate all products from the $i$-th customer before inflating any from the $(i+1)$-th customer. In between handling two products, if those two products have different target pressures, you need to use the buttons on the pump.\n\nThe pump is initially set to 0 pascals, and it can be left at any number after all products of all customers have been inflated. If you order the products of each customer optimally, what is the minimum number of button presses you need?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers, $\\mathbf{N}$ and $\\mathbf{P}$: the number of customers and the number of products each customer brings, respectively. Then, $\\mathbf{N}$ lines follow. The $i$-th of these lines contains $\\mathbf{P}$ integers $\\mathbf{X}_{\\mathbf{i}, 1}, \\mathbf{X}_{\\mathbf{i}, 2}, \\ldots, \\mathbf{X}_{\\mathbf{i}, \\mathbf{P}}$, representing that the $j$-th product that the $i$-th customer brings has a target pressure of $\\mathbf{X}_{\\mathbf{i}, \\mathbf{j}}$ pascals.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of button presses needed to inflate all products according to their specified pressures.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, an optimal way to use the pump is:\n\n1. press up 10 times, setting the pump to 10; pump the product (from customer 1) that needs 10 pascals,\n2. press up 30 times, setting the pump to 40; pump the product (from customer 1) that needs 40 pascals,\n3. press down 10 times, setting the pump to 30; pump the product (from customer 1) that needs 30 pascals,\n4. press down 10 times, setting the pump to 20; pump the product (from customer 2) that needs 20 pascals,\n5. press up 30 times, setting the pump to 50; pump the product (from customer 2) that needs 50 pascals,\n6. press up 10 times, setting the pump to 60; pump the product (from customer 2) and the two products (from customer 3) that need 60 pascals, and finally\n7. press down 10 times, setting the pump to 50; pump the product (from customer 3) that needs 50 pascals.\n\nThis is a total of 110 button presses.\n\nIn Sample Case #2, notice that the answer can be larger than $2^{32}$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{X}_{\\mathbf{i}, \\mathbf{j}} \\leq 10^{9}$, for all $i, j$.\n\n**Test Set 1 (14 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10$.\n- $2 \\leq \\mathbf{P} \\leq 3$.\n\n**Test Set 2 (21 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 1000$.\n- $2 \\leq \\mathbf{P} \\leq 100$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1B] Controlled Inflation", "background": "", "description": "你所在的加油站充气泵前的队伍越来越长了！你希望优化流程，帮助顾客更快速地给轮胎、运动球、巨型气球动物等产品充气。\n\n充气泵是自动的：你可以将目标气压设置为特定的帕斯卡数值，将泵连接到充气产品上，它就会按需充气到该精确气压。泵上只有两个按钮：**上**和**下**。它们分别将目标气压精确地增加或减少 $1$ 帕斯卡。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9382itkr.png)\n\n共有 $\\mathbf{N}$ 位顾客排队，每位顾客携带恰好 $\\mathbf{P}$ 个需要充气的产品。你知道每个产品的目标气压。你可以按任意顺序处理每位顾客的产品，但**不能**改变顾客的顺序。具体来说，你必须处理完第 $i$ 位顾客的所有产品后，才能开始处理第 $(i+1)$ 位顾客的产品。在处理两个产品之间，如果它们的目标气压不同，你需要使用泵上的按钮调整气压。\n\n充气泵初始气压为 0 帕斯卡，处理完所有顾客的所有产品后可以停留在任意气压值。如果你能优化每位顾客的产品处理顺序，最少需要按下多少次按钮？\n", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{P}$，分别表示顾客的数量和每位顾客携带的产品数量。接下来是 $\\mathbf{N}$ 行，第 $i$ 行包含 $\\mathbf{P}$ 个整数 $\\mathbf{X}_{\\mathbf{i}, 1}, \\mathbf{X}_{\\mathbf{i}, 2}, \\ldots, \\mathbf{X}_{\\mathbf{i}, \\mathbf{P}}$，表示第 $i$ 位顾客的第 $j$ 个产品的目标气压为 $\\mathbf{X}_{\\mathbf{i}, \\mathbf{j}}$ 帕斯卡。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是按照指定气压充气所有产品所需的最少按钮按压次数。\n", "hint": "**样例解释**\n\n在样例 #1 中，一种最优的充气方式是：\n\n1. 按 **上** 按钮 10 次，将气压设为 10；为顾客 1 的气压需求为 10 的产品充气，\n2. 按 **上** 按钮 30 次，将气压设为 40；为顾客 1 的气压需求为 40 的产品充气，\n3. 按 **下** 按钮 10 次，将气压设为 30；为顾客 1 的气压需求为 30 的产品充气，\n4. 按 **下** 按钮 10 次，将气压设为 20；为顾客 2 的气压需求为 20 的产品充气，\n5. 按 **上** 按钮 30 次，将气压设为 50；为顾客 2 的气压需求为 50 的产品充气，\n6. 按 **上** 按钮 10 次，将气压设为 60；为顾客 2 和顾客 3 的气压需求为 60 的三个产品充气，\n7. 最后按 **下** 按钮 10 次，将气压设为 50；为顾客 3 的气压需求为 50 的产品充气。\n\n总计需要 110 次按钮按压。\n\n在样例 #2 中，请注意答案可能超过 $2^{32}$。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{X}_{\\mathbf{i}, \\mathbf{j}} \\leq 10^9$（对所有 $i, j$ 成立）。\n\n**测试集 1（14 分，可见判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 10$。\n- $2 \\leq \\mathbf{P} \\leq 3$。\n\n**测试集 2（21 分，隐藏判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 1000$。\n- $2 \\leq \\mathbf{P} \\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12989", "type": "P", "difficulty": 6, "samples": [["1\n\n3\n\n0", "\n00110011\n\n00011001"]], "limits": {"time": [10000, 10000], "memory": [1048576, 1048576]}, "tags": ["2022", "交互题", "Special Judge", "构造", "Ad-hoc", "Google Code Jam"], "title": "[GCJ 2022 #1B] ASeDatAb", "background": "", "description": "A research consortium has been looking for the best possible database for three years, but they are still having problems. The database stores values as records that hold 8-bit binary strings. Unfortunately, their implementation of the function to set the value of a record is flawed.\n\nEach record of the database is an 8-bit binary string. The bits of the binary string are indexed from 0 to 7 from left to right. When an instruction to set a specific record to a new value $V$ is received, instead of setting the value to $V$ the database does the following:\n\n1. Choose an integer $r$ between 0 and 7, inclusive, and let $W$ be like $V$ but rotated by $r$ to the right. That is, the $((i + r) \\bmod 8)$-th bit of $W$ is the $i$-th bit of $V$.\n2. Replace the current value $X$ of the record with $X$ XOR $W$. That is, the new value of the record has a 1 as its $i$-th bit if and only if the $i$-th bits of $X$ and $W$ are different.\n3. Finally, return the number of bits that are 1 in the new value to the user.\n\nLuckily, it turns out that no matter what the initial value is or what rotation values the database chooses, it is always possible to reset the value of a record to have all bits be 0 with no more than 300 uses of this operation. Implement a program to interact with the database that does this.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing an integer $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nAt the beginning of each test case, the record in the database is set to a value that is not $00000000$. In each test case, your program must process up to $300$ exchanges.\n\nThe $i$-th exchange starts with you outputting a single line containing a single 8-bit binary string to be used as the value $V$ for the operation above. Then, the judge program performs the operation as described and sends you a single line containing a single integer $\\mathbf{N}_{\\mathbf{i}}$ representing the number of bits that are equal to 1 in the updated value of the record.\n\n* If $\\mathbf{N}_{\\mathbf{i}}=0$, it means that you have succeeded and you must start the next test case, or finish the program if it was the last one.\n* If $\\mathbf{N}_{\\mathbf{i}}=-1$ it means that this was the 300-th exchange of the test case but the record never got to a value of all zeroes, so the test is failed. No further test cases will be processed.\n* If $1 \\leq \\mathbf{N}_{\\mathbf{i}} \\leq 8$, it means that the updated value of the record has $\\mathbf{N}_{\\mathbf{i}}$ ones and you may proceed to the next exchange to keep trying to make it contain only zeroes.\n\nYour solution is considered correct if and only if you succeed in setting the value of the record to $00000000$ for all test cases.\n\nIf the judge receives an invalidly formatted or invalid line from your program at any moment, the judge will print a single number $-1$ and will not print any further output. If you receive a $-1$, you must finish correctly and without exceeding the time or memory limits to receive a Wrong Answer judgement. Otherwise, you will receive a judgement informing the exceeded resource or the incorrect termination condition.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently. \n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $-1 \\leq \\mathbf{N}_{\\mathbf{i}} \\leq 8$ for all $i$.\n\n**Test Set 1 (25 Pts, Visible Verdict)**\n\nThe initial value of the record is chosen uniformly at random from all 8-bit binary strings that are not $00000000$.\n\nEach rotation value is chosen uniformly at random, and independently of all previous choices and interactions.\n\n**Test Set 2 (15 Pts, Visible Verdict)**\n\nThe judge is adversarial. This means, among other things, that the judge can change the initial value or rotation values as long as it is consistent with all interactions. The initial value is guaranteed to never be $00000000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1B] ASeDatAb", "background": "", "description": "A research consortium has been looking for the best possible database for three years, but they are still having problems. The database stores values as records that hold 8-bit binary strings. Unfortunately, their implementation of the function to set the value of a record is flawed.\n\nEach record of the database is an 8-bit binary string. The bits of the binary string are indexed from 0 to 7 from left to right. When an instruction to set a specific record to a new value $V$ is received, instead of setting the value to $V$ the database does the following:\n\n1. Choose an integer $r$ between 0 and 7, inclusive, and let $W$ be like $V$ but rotated by $r$ to the right. That is, the $((i + r) \\bmod 8)$-th bit of $W$ is the $i$-th bit of $V$.\n2. Replace the current value $X$ of the record with $X$ XOR $W$. That is, the new value of the record has a 1 as its $i$-th bit if and only if the $i$-th bits of $X$ and $W$ are different.\n3. Finally, return the number of bits that are 1 in the new value to the user.\n\nLuckily, it turns out that no matter what the initial value is or what rotation values the database chooses, it is always possible to reset the value of a record to have all bits be 0 with no more than 300 uses of this operation. Implement a program to interact with the database that does this.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing an integer $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nAt the beginning of each test case, the record in the database is set to a value that is not $00000000$. In each test case, your program must process up to $300$ exchanges.\n\nThe $i$-th exchange starts with you outputting a single line containing a single 8-bit binary string to be used as the value $V$ for the operation above. Then, the judge program performs the operation as described and sends you a single line containing a single integer $\\mathbf{N}_{\\mathbf{i}}$ representing the number of bits that are equal to 1 in the updated value of the record.\n\n* If $\\mathbf{N}_{\\mathbf{i}}=0$, it means that you have succeeded and you must start the next test case, or finish the program if it was the last one.\n* If $\\mathbf{N}_{\\mathbf{i}}=-1$ it means that this was the 300-th exchange of the test case but the record never got to a value of all zeroes, so the test is failed. No further test cases will be processed.\n* If $1 \\leq \\mathbf{N}_{\\mathbf{i}} \\leq 8$, it means that the updated value of the record has $\\mathbf{N}_{\\mathbf{i}}$ ones and you may proceed to the next exchange to keep trying to make it contain only zeroes.\n\nYour solution is considered correct if and only if you succeed in setting the value of the record to $00000000$ for all test cases.\n\nIf the judge receives an invalidly formatted or invalid line from your program at any moment, the judge will print a single number $-1$ and will not print any further output. If you receive a $-1$, you must finish correctly and without exceeding the time or memory limits to receive a Wrong Answer judgement. Otherwise, you will receive a judgement informing the exceeded resource or the incorrect termination condition.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently. \n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $-1 \\leq \\mathbf{N}_{\\mathbf{i}} \\leq 8$ for all $i$.\n\n**Test Set 1 (25 Pts, Visible Verdict)**\n\nThe initial value of the record is chosen uniformly at random from all 8-bit binary strings that are not $00000000$.\n\nEach rotation value is chosen uniformly at random, and independently of all previous choices and interactions.\n\n**Test Set 2 (15 Pts, Visible Verdict)**\n\nThe judge is adversarial. This means, among other things, that the judge can change the initial value or rotation values as long as it is consistent with all interactions. The initial value is guaranteed to never be $00000000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1B] ASeDatAb", "background": "", "description": "一个研究联盟花费三年时间寻找最佳数据库，但仍存在问题。该数据库以 8 位二进制字符串形式存储记录值。遗憾的是，他们实现记录值设置功能的方式存在缺陷。\n\n数据库的每条记录都是一个 8 位二进制字符串，其位索引从左到右为 0 至 7。当收到将特定记录设置为新值 $V$ 的指令时，数据库并不会直接将其设为 $V$，而是执行以下操作：\n\n1. 选择一个 0 到 7 之间的整数 $r$，并生成 $V$ 向右循环移动 $r$ 位后的值 $W$。即 $W$ 的第 $((i + r) \\bmod 8)$ 位等于 $V$ 的第 $i$ 位。\n2. 将记录的当前值 $X$ 更新为 $X$ 与 $W$ 的异或值（即新值的第 $i$ 位为 1 当且仅当 $X$ 和 $W$ 的第 $i$ 位不同）。\n3. 最后向用户返回新值中 1 的位数。\n\n幸运的是，无论初始值如何或数据库如何选择旋转值，总能通过不超过 300 次操作将记录值重置为全 0。请编写一个程序与数据库交互完成此任务。\n\n### 交互协议\n\n本题为交互题。\n\n初始时，你的程序应读取一个整数 $\\mathbf{T}$ 表示测试用例数量，随后处理 $\\mathbf{T}$ 个测试用例。\n\n每个测试用例开始时，数据库记录会被设为非 $00000000$ 的值。每个测试用例中，你的程序最多可进行 300 轮交互。\n\n每轮交互流程：\n1. 你输出一个 8 位二进制字符串作为操作值 $V$\n2. 评测系统执行前述操作后，返回一个整数 $\\mathbf{N_{i}}$ 表示更新后记录值中 1 的位数\n   - 若 $\\mathbf{N_{i}}=0$ 表示成功，应开始下一测试用例（或程序终止）\n   - 若 $\\mathbf{N_{i}}=-1$ 表示第 300 次操作仍未归零，测试失败（后续用例不再处理）\n   - 若 $1 \\leq \\mathbf{N_{i}} \\leq 8$ 可继续尝试\n\n只有当所有测试用例均成功将记录值归零时，解答才被视为正确。\n\n若检测到非法输出，评测系统将返回 -1 并终止。收到 -1 后需正常退出以避免资源错误判定。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "可使用测试工具进行本地测试（需与代码并行运行）。工具说明详见其注释，注意该工具**并非**真实评测系统。\n\n**数据范围**\n- $1 \\leq \\mathbf{T} \\leq 100$\n- $-1 \\leq \\mathbf{N_{i}} \\leq 8$\n\n**测试集 1（25 分，可见判定）**\n- 初始值为均匀随机生成的非全零 8 位二进制数\n- 旋转值均为独立均匀随机选择\n\n**测试集 2（15 分，可见判定）**\n- 评测系统采用对抗策略（可动态调整初始值和旋转值）\n- 保证初始值不为全零\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12990", "type": "P", "difficulty": 4, "samples": [["6\n5\nCODE JAM MIC EEL ZZZZZ\n6\nCODE JAM MIC EEL ZZZZZ EEK\n2\nOY YO\n2\nHASH CODE\n6\nA AA BB A BA BB\n2\nCAT TAX", "Case #1: ZZZZZJAMMICCODEEEL\nCase #2: IMPOSSIBLE\nCase #3: IMPOSSIBLE\nCase #4: IMPOSSIBLE\nCase #5: BBBBBAAAAA\nCase #6: IMPOSSIBLE"]], "limits": {"time": [5000, 5000, 5000], "memory": [1048576, 1048576, 1048576]}, "tags": ["字符串", "贪心", "2022", "Special Judge", "Google Code Jam"], "title": "[GCJ 2022 #1C] Letter Blocks", "background": "", "description": "It is a rainy day, so you are indoors building towers of letter blocks. A letter block is a wooden cube that has a letter printed on one of its sides. The font used for the letters makes the blocks have a clear orientation: that is, there is only one side that can be pointed down (toward the floor) and one side that can be pointed up (toward the ceiling).\n\nYou have built multiple separate towers so far. Now you want to combine all of them into a single megatower by choosing one of your towers as the base, then picking up another tower (without changing the order of its blocks) and stacking the whole thing on top of that, and so on, until all towers have been used.\n\nAs an additional constraint for the megatower, for any two blocks that have the same letter, all blocks between them must also have that letter. That is, each letter of the alphabet that appears in the megatower needs to appear in one contiguous group (of one or more blocks).\n\nFor example, consider the following three possible megatowers. (These are separate examples, not built from the same original towers. Also note that the different block sizes are just for fun and are not part of the problem.)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s3qed2k7.png)\n\nThe leftmost two megatowers are valid, since each letter appears in a contiguous group. However, the rightmost megatower is not valid, because there is a B in between two Cs.\n\nGiven the towers that you have built so far, can you stack them all up into a valid megatower?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described by two lines. The first line consists of a single integer $\\mathbf{N}$, the number of towers that are currently built. The second line consists of $\\mathbf{N}$ strings $\\mathbf{S}_{1}, \\mathbf{S}_{2}, \\ldots, \\mathbf{S}_{\\mathbf{N}}$ representing the towers. Each of these strings consists of only uppercase letters. The $i$-th letter of each of these strings is the letter on the $i$-th block from the bottom in the represented tower.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a string representing a valid megatower as described above, or the word IMPOSSIBLE if no valid megatower can be built. (Notice that the string IMPOSSIBLE can never itself represent a valid megatower, since the two $\\mathbf{i}$ s have other letters in between.)", "hint": "**Sample Explanation 1**\n\nIn Sample Case #1, `JAMMICCODEEELZZZZZ` and `ZZZZZJAMMICCODEEEL` are the only two valid outputs.\n\nIn Sample Case #2, recall that all towers must be used in the megatower, so even though the first five towers together would form a valid megatower (as in Sample Case #1), the additional `EEK` makes the case impossible. No matter how the `EEL` and `EEK` towers are stacked relative to each other, there will be at least two non-contiguous groups of `E`s.\n\nIn Sample Case #3, no matter how you stack the towers, either the two `O`s are not contiguous or the two Ys are not contiguous.\n\nIn Sample Case #4, there are non-H letters in between the `H`s of `HASH`, so this case is also impossible.\n\nIn Sample Case #5, this answer is the only valid one. Also notice that the towers are not necessarily all distinct.\n\nIn Sample Case #6, no matter how you stack the towers, the two `A`s cannot be contiguous.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\text{the length of } \\mathbf{S}_i \\leq 10$, for all $i$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 6$.\n\n**Test Set 2 (15 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1C] Letter Blocks", "background": "", "description": "It is a rainy day, so you are indoors building towers of letter blocks. A letter block is a wooden cube that has a letter printed on one of its sides. The font used for the letters makes the blocks have a clear orientation: that is, there is only one side that can be pointed down (toward the floor) and one side that can be pointed up (toward the ceiling).\n\nYou have built multiple separate towers so far. Now you want to combine all of them into a single megatower by choosing one of your towers as the base, then picking up another tower (without changing the order of its blocks) and stacking the whole thing on top of that, and so on, until all towers have been used.\n\nAs an additional constraint for the megatower, for any two blocks that have the same letter, all blocks between them must also have that letter. That is, each letter of the alphabet that appears in the megatower needs to appear in one contiguous group (of one or more blocks).\n\nFor example, consider the following three possible megatowers. (These are separate examples, not built from the same original towers. Also note that the different block sizes are just for fun and are not part of the problem.)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s3qed2k7.png)\n\nThe leftmost two megatowers are valid, since each letter appears in a contiguous group. However, the rightmost megatower is not valid, because there is a B in between two Cs.\n\nGiven the towers that you have built so far, can you stack them all up into a valid megatower?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described by two lines. The first line consists of a single integer $\\mathbf{N}$, the number of towers that are currently built. The second line consists of $\\mathbf{N}$ strings $\\mathbf{S}_{1}, \\mathbf{S}_{2}, \\ldots, \\mathbf{S}_{\\mathbf{N}}$ representing the towers. Each of these strings consists of only uppercase letters. The $i$-th letter of each of these strings is the letter on the $i$-th block from the bottom in the represented tower.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a string representing a valid megatower as described above, or the word IMPOSSIBLE if no valid megatower can be built. (Notice that the string IMPOSSIBLE can never itself represent a valid megatower, since the two $\\mathbf{i}$ s have other letters in between.)", "hint": "**Sample Explanation 1**\n\nIn Sample Case #1, `JAMMICCODEEELZZZZZ` and `ZZZZZJAMMICCODEEEL` are the only two valid outputs.\n\nIn Sample Case #2, recall that all towers must be used in the megatower, so even though the first five towers together would form a valid megatower (as in Sample Case #1), the additional `EEK` makes the case impossible. No matter how the `EEL` and `EEK` towers are stacked relative to each other, there will be at least two non-contiguous groups of `E`s.\n\nIn Sample Case #3, no matter how you stack the towers, either the two `O`s are not contiguous or the two Ys are not contiguous.\n\nIn Sample Case #4, there are non-H letters in between the `H`s of `HASH`, so this case is also impossible.\n\nIn Sample Case #5, this answer is the only valid one. Also notice that the towers are not necessarily all distinct.\n\nIn Sample Case #6, no matter how you stack the towers, the two `A`s cannot be contiguous.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\text{the length of } \\mathbf{S}_i \\leq 10$, for all $i$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 6$.\n\n**Test Set 2 (15 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1C] Letter Blocks", "background": "", "description": "这是一个雨天，所以你待在室内搭建字母积木塔。一个**字母积木**是一个木制立方体，其一面印有一个字母。使用的字体使积木具有明确的方向性：即只有一个面可以朝下（朝向地板），一个面可以朝上（朝向天花板）。\n\n目前你已经搭建了多个独立的塔。现在你想将它们全部组合成一个**超级塔**：选择其中一座塔作为基底，然后拿起另一座塔（不改变其积木顺序）将其整体堆叠在基底上，以此类推，直到所有塔都被使用。\n\n超级塔还有一个额外限制：对于任意两个相同字母的积木，它们之间的所有积木也必须是该字母。也就是说，字母表中每个出现在超级塔中的字母必须出现在一个连续的组中（一个或多个积木）。\n\n例如，以下是三个可能的超级塔（这些是独立的示例，并非由相同的原始塔构建而成。另外请注意，积木的不同大小仅为趣味性，不属于题目的一部分）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s3qed2k7.png)\n\n最左侧的两个超级塔是合法的，因为每个字母都出现在一个连续的组中。但最右侧的超级塔不合法，因为两个 `C` 之间有一个 `B`。\n\n给定你目前已搭建的塔，能否将它们全部堆叠成一个合法的超级塔？", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 个测试用例。每个测试用例由两行描述。第一行是一个整数 $\\mathbf{N}$，表示当前搭建的塔的数量。第二行包含 $\\mathbf{N}$ 个字符串 $\\mathbf{S}_{1}, \\mathbf{S}_{2}, \\ldots, \\mathbf{S}_{\\mathbf{N}}$，表示这些塔。每个字符串仅由大写字母组成。每个字符串的第 $i$ 个字母表示对应塔中从底部数第 $i$ 个积木的字母。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是表示合法超级塔的字符串，或者如果无法构建合法超级塔，则输出单词 `IMPOSSIBLE`。（注意，字符串 `IMPOSSIBLE` 本身永远不可能表示合法的超级塔，因为两个 `i` 之间有其他字母。）\n", "hint": "**样例解释 1**\n\n在样例 #1 中，`JAMMICCODEEELZZZZZ` 和 `ZZZZZJAMMICCODEEEL` 是仅有的两种合法输出。\n\n在样例 #2 中，请注意所有塔都必须用于超级塔，因此即使前五座塔可以组成一个合法超级塔（如样例 #1），额外的 `EEK` 使得该用例无法实现。无论 `EEL` 和 `EEK` 塔如何堆叠，至少会有两组不连续的 `E`。\n\n在样例 #3 中，无论怎样堆叠塔，要么两个 `O` 不连续，要么两个 `Y` 不连续。\n\n在样例 #4 中，`HASH` 的 `H` 之间有非 `H` 字母，因此该用例也无法实现。\n\n在样例 #5 中，这是唯一的合法答案。另外请注意，塔不一定是完全不同的。\n\n在样例 #6 中，无论怎样堆叠塔，两个 `A` 都无法连续。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i$，$1 \\leq \\text{字符串 } \\mathbf{S}_i \\text{ 的长度} \\leq 10$。\n\n**测试集 1（10 分，可见判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 6$。\n\n**测试集 2（15 分，可见判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12991", "type": "P", "difficulty": 6, "samples": [["4\n2 1\n-2 6\n2 1\n-10 10\n1 1\n0\n3 1\n2 -2 2", "Case #1: 3\nCase #2: IMPOSSIBLE\nCase #3: -1000000000000000000\nCase #4: 2"], ["3\n3 10\n-2 3 6\n6 2\n-2 2 1 -2 4 -1\n1 12\n-5", "Case #1: 0\nCase #2: -1 15\nCase #3: 1 1 1 1 1 1 1 1 1 1 1"]], "limits": {"time": [5000, 5000, 10000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "2022", "Special Judge", "构造", "Google Code Jam"], "title": "[GCJ 2022 #1C] Squary", "background": "", "description": "Addition and squaring do not commute. That is, the square of the sum of all elements of a list of integers is not necessarily equal to the sum of the squares of those same elements. However, this is true for some lists; one example is $[3,-2,6]$, because $(3+(-2)+6)^{2}=49=3^{2}+(-2)^{2}+6^{2}$. Let us call these lists squary.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qa49q9z1.png)\n\nGiven a (not necessarily squary) list of relatively small integers, we want to know whether it is possible to add at least $1$ and at most $\\mathbf{K}$ more elements such that the final list is squary. Each added element must be an integer between $-10^{18}$ and $10^{18}$, inclusive, and these do not have to be distinct from each other or from the initial list's elements.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in two lines. The first line contains two integers $\\mathbf{N}$ and $\\mathbf{K}$, the number of elements of the initial list and the maximum number of elements you may add, respectively. The second line contains $\\mathbf{N}$ integers $\\mathbf{E}_{1}, \\mathbf{E}_{2}, \\ldots, \\mathbf{E}_{\\mathbf{N}}$, representing the $\\mathbf{N}$ elements of the initial list.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1). If it is possible to add at least 1 and at most $\\mathbf{K}$ elements (each an integer between $-10^{18}$ and $10^{18}$, inclusive) to the initial list such that the square of the sum of its elements equals the sum of the squares of its elements, $y$ should be $z_{1} z_{2} \\ldots z_{r}$, where $1 \\leq r \\leq \\mathbf{K}$ and the $z_{i}$ values are the additional elements. If there is no way to accomplish this, $y$ should be IMPOSSIBLE.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we can end up with the example list given in the problem statement.\n\nIn Sample Case #2, we have to add exactly one element. If we call that element $x$, the sum of the entire list is $x$ and its square is $x^{2}$. The sum of the squares of all elements, on the other hand, is $x^{2}+10^{2}+(-10)^{2}=x^{2}+200 \\neq x^{2}$, so the case is impossible.\n\nIn Sample Case #3, any integer in the $\\left[-10^{18}, 10^{18}\\right]$ range is a valid answer.\n\nIn Sample Case #4, notice that the input might contain duplicate elements, and that it is valid to create even more duplicates with the elements you choose to add.\n\nSample 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nIn Case #1 of the additional samples, we are given the example list from the problem statement, which is already squary, but we need to add at least one element to it. Adding a 0 keeps the list squary.\n\nIn Case #3 of the additional samples, we present one of multiple possible valid answers. Notice that it is permissible to add fewer than $\\mathbf{K}$ elements; here $\\mathbf{K}$ is 12 but we have only added 11 elements.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100 .$\n- $1 \\leq \\mathbf{N} \\leq 1000 .$\n- $-1000 \\leq \\mathbf{E}_{\\mathbf{i}} \\leq 1000$, for all $i$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- Time limit: 5 seconds.\n- $\\mathbf{K}=1$.\n\n**Test Set 2 (22 Pts, Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $2 \\leq \\mathbf{K} \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1C] Squary", "background": "", "description": "Addition and squaring do not commute. That is, the square of the sum of all elements of a list of integers is not necessarily equal to the sum of the squares of those same elements. However, this is true for some lists; one example is $[3,-2,6]$, because $(3+(-2)+6)^{2}=49=3^{2}+(-2)^{2}+6^{2}$. Let us call these lists squary.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qa49q9z1.png)\n\nGiven a (not necessarily squary) list of relatively small integers, we want to know whether it is possible to add at least $1$ and at most $\\mathbf{K}$ more elements such that the final list is squary. Each added element must be an integer between $-10^{18}$ and $10^{18}$, inclusive, and these do not have to be distinct from each other or from the initial list's elements.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in two lines. The first line contains two integers $\\mathbf{N}$ and $\\mathbf{K}$, the number of elements of the initial list and the maximum number of elements you may add, respectively. The second line contains $\\mathbf{N}$ integers $\\mathbf{E}_{1}, \\mathbf{E}_{2}, \\ldots, \\mathbf{E}_{\\mathbf{N}}$, representing the $\\mathbf{N}$ elements of the initial list.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1). If it is possible to add at least 1 and at most $\\mathbf{K}$ elements (each an integer between $-10^{18}$ and $10^{18}$, inclusive) to the initial list such that the square of the sum of its elements equals the sum of the squares of its elements, $y$ should be $z_{1} z_{2} \\ldots z_{r}$, where $1 \\leq r \\leq \\mathbf{K}$ and the $z_{i}$ values are the additional elements. If there is no way to accomplish this, $y$ should be IMPOSSIBLE.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we can end up with the example list given in the problem statement.\n\nIn Sample Case #2, we have to add exactly one element. If we call that element $x$, the sum of the entire list is $x$ and its square is $x^{2}$. The sum of the squares of all elements, on the other hand, is $x^{2}+10^{2}+(-10)^{2}=x^{2}+200 \\neq x^{2}$, so the case is impossible.\n\nIn Sample Case #3, any integer in the $\\left[-10^{18}, 10^{18}\\right]$ range is a valid answer.\n\nIn Sample Case #4, notice that the input might contain duplicate elements, and that it is valid to create even more duplicates with the elements you choose to add.\n\nSample 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nIn Case #1 of the additional samples, we are given the example list from the problem statement, which is already squary, but we need to add at least one element to it. Adding a 0 keeps the list squary.\n\nIn Case #3 of the additional samples, we present one of multiple possible valid answers. Notice that it is permissible to add fewer than $\\mathbf{K}$ elements; here $\\mathbf{K}$ is 12 but we have only added 11 elements.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100 .$\n- $1 \\leq \\mathbf{N} \\leq 1000 .$\n- $-1000 \\leq \\mathbf{E}_{\\mathbf{i}} \\leq 1000$, for all $i$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- Time limit: 5 seconds.\n- $\\mathbf{K}=1$.\n\n**Test Set 2 (22 Pts, Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $2 \\leq \\mathbf{K} \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1C] Squary", "background": "", "description": "加法与平方运算不可交换。也就是说，一个整数列表中所有元素的和的平方，不一定等于这些元素各自的平方和。然而，某些列表满足这一性质，例如 $[3,-2,6]$，因为 $(3+(-2)+6)^{2}=49=3^{2}+(-2)^{2}+6^{2}$。我们将这样的列表称为**平方性列表**。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qa49q9z1.png)\n\n给定一个（不一定是平方性的）由较小整数构成的列表，我们想知道是否可以通过添加至少 $1$ 个、至多 $\\mathbf{K}$ 个元素，使得最终的列表具有平方性。每个添加的元素必须是介于 $-10^{18}$ 和 $10^{18}$（含）之间的整数，且这些元素不必互不相同，也不必与初始列表中的元素不同。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 个测试用例。每个测试用例由两行描述。第一行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{K}$，分别表示初始列表的元素数量和最多可添加的元素数量。第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{E}_{1}, \\mathbf{E}_{2}, \\ldots, \\mathbf{E}_{\\mathbf{N}}$，表示初始列表的 $\\mathbf{N}$ 个元素。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始）。如果可以通过添加至少 1 个、至多 $\\mathbf{K}$ 个元素（每个元素介于 $-10^{18}$ 和 $10^{18}$ 之间）使得列表元素的平方和等于元素和的平方，则 $y$ 应为 $z_{1} z_{2} \\ldots z_{r}$，其中 $1 \\leq r \\leq \\mathbf{K}$，$z_{i}$ 为添加的元素。如果无法实现，则 $y$ 应为 `IMPOSSIBLE`。", "hint": "**样例解释**\n\n在样例 #1 中，我们可以得到题目描述中的示例列表。\n\n在样例 #2 中，必须恰好添加一个元素 $x$。此时整个列表的和为 $x$，其平方为 $x^{2}$。而所有元素的平方和为 $x^{2}+10^{2}+(-10)^{2}=x^{2}+200 \\neq x^{2}$，因此该用例无法实现。\n\n在样例 #3 中，$\\left[-10^{18}, 10^{18}\\right]$ 范围内的任意整数均为合法答案。\n\n在样例 #4 中，注意输入可能包含重复元素，且通过添加元素创建更多重复也是合法的。\n\n样例 2 符合测试集 2 的限制，但不会用于测试你的提交。\n\n在附加样例的用例 #1 中，我们给出了题目描述中的示例列表（已是平方性列表），但需要至少添加一个元素。添加 0 可以保持列表的平方性。\n\n在附加样例的用例 #3 中，我们展示了一种可能的合法答案。注意可以添加少于 $\\mathbf{K}$ 个元素；此处 $\\mathbf{K}=12$，但我们仅添加了 11 个元素。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{N} \\leq 1000$。\n- 对所有 $i$，$-1000 \\leq \\mathbf{E}_{\\mathbf{i}} \\leq 1000$。\n\n**测试集 1（9 分，可见判定）**\n\n- 时间限制：5 秒。\n- $\\mathbf{K}=1$。\n\n**测试集 2（22 分，可见判定）**\n\n- 时间限制：10 秒。\n- $2 \\leq \\mathbf{K} \\leq 1000$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12992", "type": "P", "difficulty": 7, "samples": [["3\n5 2\n5 1\n6 3", "Case #1: 428571432\nCase #2: 571428576\nCase #3: 47619048"]], "limits": {"time": [20000, 20000, 60000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2022", "组合数学", "Google Code Jam"], "title": "[GCJ 2022 #1C] Intranets", "background": "", "description": "Apricot Rules LLC is developing a new simplified networking protocol and wants to show off their routing algorithm. In their design, a network consists of $\\mathbf{M}$ machines numbered from 1 to $\\mathbf{M}$, and each pair of machines is connected by a direct link. Each of the links is given a unique integer priority value between 1 and $(\\mathbf{M} \\times (\\mathbf{M} - 1)/2)$ and each machine routes traffic according to those priorities.\n\nUnfortunately, the routing algorithm is too aggressive and will route all traffic from a machine through the highest priority link connected to it. This may make some groups of machines isolated from others.\n\nFormally, we say that a machine $m$ uses a link $\\ell$ if (and only if) $\\ell$ is the highest priority link connected to $m$. We also say that a link is active if it is used by at least one of the two machines it connects. Given the link priorities, the original network becomes partitioned into disjoint intranets. Two machines belong to the same intranet if and only if there is some path between them using only active links.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hi8p2brt.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/aiu45d35.png)\n\nFor example, as seen in the left image above, only the links with priorities 6 and 5 are active. This creates two disjoint intranets. However, in the example on the right, three links are active, which results in one intranet consisting of all 4 machines.\n\nAs part of the quality assurance team at Apricot Rules LLC, you are investigating the extent of the problem. You are interested in knowing the probability of there being exactly $\\mathbf{K}$ intranets if the priorities are assigned uniformly at random from among the $(\\mathbf{M} \\times (\\mathbf{M} - 1)/2)!$ ways of doing so.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in a single line containing two integers $\\mathbf{M}$ and $\\mathbf{K}$ : the number of machines and the target number of intranets, respectively.", "outputFormat": "For each test case, output one line containing Case # $x: y$, where $x$ is the test case number (starting from 1) and $y$ is the sought probability computed modulo the prime $10^{9}+7$ ($1000000007$), which is defined precisely as follows. Represent the probability as as an irreducible fraction $p / q$ (with $p$ and $q$ being non-negative integers that minimize $p+q$ ). Then, $y$ must equal $p \\cdot q^{-1} \\bmod 10^{9}+7$, where $q^{-1}$ is the modular multiplicative inverse of $q$ with respect to the modulus $10^{9}+7$. It can be shown that under the constraints of this problem, such a number $y$ always exists and is unique.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, consider the following situation. Let's call $\\mathbf{M}=5$ machines $1,2,3,4,5$ and denote the link connecting machine $a$ and machine $b$ by $(a, b)$. Assume that the priorities of links $(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)$ are $9,8,7,6,5,4,3,2,1,10$, respectively. Then machines 1 and 2 use link $(1,2)$, machine 3 uses link $(1,3)$, and machines 4 and 5 use link $(4,5)$. Thus three links $(1,2),(1,3),(4,5)$ are active, and there are two intranets $\\{1,2,3\\}$ and $\\{4,5\\}$. Since $\\mathbf{K}=2$, this situation counts the answer.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uoy2l0x6.png)\n\nWe can find that there are $1555200$ ways to assign the priorities to have exactly $2$ intranets among $10 !=3628800$ ways, so the probability is $3 / 7$.\n\nIn Sample Case #2, the probability is $4 / 7$.\n\nIn Sample Case #3, the probability is $1 / 21$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 50$.\n- $1 \\leq \\mathbf{K} \\leq \\mathbf{M} / 2$.\n\n**Test Set 1 (17 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $2 \\leq \\mathbf{M} \\leq 50$.\n\n**Test Set 2 (27 Pts, Hidden Verdict)**\n\n- Time limit: 60 seconds.\n- $2 \\leq \\mathbf{M} \\leq 5 \\times 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #1C] Intranets", "background": "", "description": "Apricot Rules LLC is developing a new simplified networking protocol and wants to show off their routing algorithm. In their design, a network consists of $\\mathbf{M}$ machines numbered from 1 to $\\mathbf{M}$, and each pair of machines is connected by a direct link. Each of the links is given a unique integer priority value between 1 and $(\\mathbf{M} \\times (\\mathbf{M} - 1)/2)$ and each machine routes traffic according to those priorities.\n\nUnfortunately, the routing algorithm is too aggressive and will route all traffic from a machine through the highest priority link connected to it. This may make some groups of machines isolated from others.\n\nFormally, we say that a machine $m$ uses a link $\\ell$ if (and only if) $\\ell$ is the highest priority link connected to $m$. We also say that a link is active if it is used by at least one of the two machines it connects. Given the link priorities, the original network becomes partitioned into disjoint intranets. Two machines belong to the same intranet if and only if there is some path between them using only active links.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hi8p2brt.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/aiu45d35.png)\n\nFor example, as seen in the left image above, only the links with priorities 6 and 5 are active. This creates two disjoint intranets. However, in the example on the right, three links are active, which results in one intranet consisting of all 4 machines.\n\nAs part of the quality assurance team at Apricot Rules LLC, you are investigating the extent of the problem. You are interested in knowing the probability of there being exactly $\\mathbf{K}$ intranets if the priorities are assigned uniformly at random from among the $(\\mathbf{M} \\times (\\mathbf{M} - 1)/2)!$ ways of doing so.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in a single line containing two integers $\\mathbf{M}$ and $\\mathbf{K}$ : the number of machines and the target number of intranets, respectively.", "outputFormat": "For each test case, output one line containing Case # $x: y$, where $x$ is the test case number (starting from 1) and $y$ is the sought probability computed modulo the prime $10^{9}+7$ ($1000000007$), which is defined precisely as follows. Represent the probability as as an irreducible fraction $p / q$ (with $p$ and $q$ being non-negative integers that minimize $p+q$ ). Then, $y$ must equal $p \\cdot q^{-1} \\bmod 10^{9}+7$, where $q^{-1}$ is the modular multiplicative inverse of $q$ with respect to the modulus $10^{9}+7$. It can be shown that under the constraints of this problem, such a number $y$ always exists and is unique.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, consider the following situation. Let's call $\\mathbf{M}=5$ machines $1,2,3,4,5$ and denote the link connecting machine $a$ and machine $b$ by $(a, b)$. Assume that the priorities of links $(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)$ are $9,8,7,6,5,4,3,2,1,10$, respectively. Then machines 1 and 2 use link $(1,2)$, machine 3 uses link $(1,3)$, and machines 4 and 5 use link $(4,5)$. Thus three links $(1,2),(1,3),(4,5)$ are active, and there are two intranets $\\{1,2,3\\}$ and $\\{4,5\\}$. Since $\\mathbf{K}=2$, this situation counts the answer.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uoy2l0x6.png)\n\nWe can find that there are $1555200$ ways to assign the priorities to have exactly $2$ intranets among $10 !=3628800$ ways, so the probability is $3 / 7$.\n\nIn Sample Case #2, the probability is $4 / 7$.\n\nIn Sample Case #3, the probability is $1 / 21$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 50$.\n- $1 \\leq \\mathbf{K} \\leq \\mathbf{M} / 2$.\n\n**Test Set 1 (17 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $2 \\leq \\mathbf{M} \\leq 50$.\n\n**Test Set 2 (27 Pts, Hidden Verdict)**\n\n- Time limit: 60 seconds.\n- $2 \\leq \\mathbf{M} \\leq 5 \\times 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #1C] Intranets", "background": "", "description": "Apricot Rules LLC 公司正在开发一种新的简化网络协议，并希望展示其路由算法。在他们的设计中，网络由编号从 1 到 $\\mathbf{M}$ 的 $\\mathbf{M}$ 台机器组成，每对机器之间通过一条直接链路连接。每条链路被赋予一个唯一的整数优先级，优先级值介于 1 到 $(\\mathbf{M} \\times (\\mathbf{M} - 1)/2)$ 之间，每台机器根据这些优先级来路由流量。\n\n遗憾的是，该路由算法过于激进，会将一台机器的所有流量都通过与其连接的最高优先级链路进行路由。这可能导致某些机器组与其他机器组隔离。\n\n正式地说，我们说一台机器 $m$ 使用一条链路 $\\ell$，当且仅当 $\\ell$ 是与 $m$ 连接的优先级最高的链路。我们还称一条链路是**活跃的**，如果它被其连接的两台机器中的至少一台使用。根据链路优先级，原始网络将被划分为若干个不相交的**内联网**。两台机器属于同一个内联网，当且仅当它们之间存在一条仅由活跃链路组成的路径。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hi8p2brt.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/aiu45d35.png)\n\n例如，如上图左侧所示，只有优先级为 6 和 5 的链路是活跃的。这形成了两个不相交的内联网。然而，右侧的示例中有三条活跃链路，结果形成了一个包含所有 4 台机器的内联网。\n\n作为 Apricot Rules LLC 公司质量保证团队的一员，你正在调查这个问题的严重程度。你感兴趣的是，如果优先级是从 $(\\mathbf{M} \\times (\\mathbf{M} - 1)/2)!$ 种可能的分配方式中均匀随机选择的，那么恰好形成 $\\mathbf{K}$ 个内联网的概率是多少。\n", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例由一行描述，包含两个整数 $\\mathbf{M}$ 和 $\\mathbf{K}$，分别表示机器的数量和目标内联网的数量。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是所求概率对质数 $10^{9}+7$（$1000000007$）取模后的结果。具体定义如下：将概率表示为不可约分数 $p/q$（其中 $p$ 和 $q$ 是非负整数，且 $p+q$ 最小），则 $y$ 必须等于 $p \\cdot q^{-1} \\bmod 10^{9}+7$，其中 $q^{-1}$ 是 $q$ 在模 $10^{9}+7$ 下的模逆元。可以证明，在本问题的约束条件下，这样的 $y$ 总是存在且唯一。\n", "hint": "**样例解释**\n\n在样例 #1 中，考虑以下情况。设 $\\mathbf{M}=5$ 台机器为 $1,2,3,4,5$，并将连接机器 $a$ 和机器 $b$ 的链路记为 $(a, b)$。假设链路 $(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)$ 的优先级分别为 $9,8,7,6,5,4,3,2,1,10$。那么机器 1 和 2 使用链路 $(1,2)$，机器 3 使用链路 $(1,3)$，机器 4 和 5 使用链路 $(4,5)$。因此，三条链路 $(1,2),(1,3),(4,5)$ 是活跃的，形成了两个内联网 $\\{1,2,3\\}$ 和 $\\{4,5\\}$。由于 $\\mathbf{K}=2$，这种情况计入答案。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uoy2l0x6.png)\n\n我们可以发现，在 $10! = 3628800$ 种优先级分配方式中，有 $1555200$ 种方式会恰好形成 $2$ 个内联网，因此概率为 $3/7$。\n\n在样例 #2 中，概率为 $4/7$。\n\n在样例 #3 中，概率为 $1/21$。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 50$。\n- $1 \\leq \\mathbf{K} \\leq \\mathbf{M}/2$。\n\n**测试集 1（17 分，可见判定）**\n\n- 时间限制：20 秒。\n- $2 \\leq \\mathbf{M} \\leq 50$。\n\n**测试集 2（27 分，隐藏判定）**\n\n- 时间限制：60 秒。\n- $2 \\leq \\mathbf{M} \\leq 5 \\times 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12993", "type": "P", "difficulty": 4, "samples": [["4\n5 4\n5 3\n5 12\n3 1", "Case #1: 2\n2 17\n18 25\nCase #2: IMPOSSIBLE\nCase #3: 2\n11 22\n22 25\nCase #4: IMPOSSIBLE"]], "limits": {"time": [5000, 5000, 20000, 20000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "贪心", "2022", "Special Judge", "构造", "Google Code Jam"], "title": "[GCJ 2022 #2] Spiraling Into Control", "background": "", "description": "As punishment for being naughty, Dante has been trapped in a strange house with many rooms. The house is an $\\mathbf{N} \\times \\mathbf{N}$ grid of rooms, with $\\mathbf{N}$ odd and greater than 1. The upper left room is numbered 1 , and then the other rooms are numbered $2,3, \\ldots, \\mathbf{N}^{2}$, in a clockwise spiral pattern. That is, the numbering proceeds along the top row of the grid and then makes a 90 degree turn to the right whenever a grid boundary or an already numbered room is encountered, and finishes in the central room of the grid. Because $\\mathbf{N}$ is odd, there is always a room in the exact center of the house, and it is always numbered $\\mathbf{N}^{2}$.\n\nFor example, here are the room numberings for houses with $\\mathbf{N}=3$ and $\\mathbf{N}=5$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/agyafjba.png)\n\nDante starts off in room 1 and is trying to reach the central room (room $\\mathbf{N}^{2}$ ). Throughout his journey, he can only make moves from his current room to higher-numbered, adjacent rooms. (Two rooms must share an edge - not just a corner - to be adjacent.)\n\nDante knows that he could walk from room to room in consecutive numerical order - i.e., if he is currently in room $x$, he would move to room $x+1$, and so on. This would take him exactly $\\mathbf{N}^{2}-1$ moves. But Dante wants to do things his way! Specifically, he wants to reach the central room in exactly $\\mathbf{K}$ moves, for some $\\mathbf{K}$ strictly less than $\\mathbf{N}^{2}-1$.\n\nDante can accomplish this by taking one or more shortcuts. A shortcut is a move between rooms that are not consecutively numbered.\n\nFor example, in the $5 \\times 5$ house above,\n\n- If Dante is at $1$, he cannot move to $17$, but he can move to $2$ or to $16$. The move to $2$ is not a shortcut, since $1+1=2$. The move to $16$ is a shortcut, since $1+1 \\neq 16$.\n- From $2$, it is possible to move to $3$ (not a shortcut) or to $17$ (a shortcut), but not to $1,16$, or $18$.\n- From $24$, Dante can only move to $25$ (not a shortcut).\n- It is not possible to move out of room $25$.\n\nAs a specific example using the $5 \\times 5$ house above, suppose that $\\mathbf{K}=4$. One option is for Dante to move from $1$ to $2$, then move from $2$ to $17$ (which is a shortcut), then move from $17$ to $18$, then move from $18$ to $25$ (which is another shortcut). This is illustrated below (the red arrows represent shortcuts):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/010wa6d8.png)\n\nCan you help Dante find a sequence of exactly $\\mathbf{K}$ moves that gets him to the central room, or tell him that it is impossible?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of one line with two integers $\\mathbf{N}$ and $\\mathbf{K}$, where $\\mathbf{N}$ is the dimension of the house (i.e. the number of rows of rooms, which is the same as the number of columns of rooms), and $\\mathbf{K}$ is the exact number of moves that Dante wants to make while traveling from room 1 to room $\\mathbf{N}^{2}$.", "outputFormat": "For each test case, output one line containing `Case x: y`, where $x$ is the test case number (starting from 1).\n\nIf no valid sequence of exactly $\\mathbf{K}$ moves will get Dante to the central room, $y$ must be IMPOSSIBLE.\n\nOtherwise, $y$ must be an integer: the number of times that Dante takes a shortcut, as described above. (Notice that because Dante wants to finish in strictly less than $\\mathbf{N}^{2}-1$ moves, he must always use at least one shortcut.) Then, output $y$ more lines of two integers each. The $i$-th of these lines represents the $i$-th time in Dante's journey that he takes a shortcut, i.e., he moves from some room $a_{i}$ to another room $b_{i}$ such that $a_{i}+1<b_{i}$.\n\nNotice that because these lines follow the order of the journey, $a_{i}<a_{i+1}$ for all $1 \\leq i<y$.", "hint": "**Sample Explanation**\n\nSample Case #1 is described in the problem statement. Dante's route is $1 \\rightarrow 2 \\rightarrow 17 \\rightarrow 18 \\rightarrow 25$. Because $1 \\rightarrow 2$ and $17 \\rightarrow 18$ are moves between consecutively numbered rooms, they are not included in the output. Only the shortcuts $(2 \\rightarrow 17$ and $18 \\rightarrow 25)$ are included.\n\nIn Sample Case #2, there is no solution. (Recall that there is no way for Dante to move diagonally.)\n\nIn Sample Case #3, observe that $22$ appears both as the end of one shortcut and the start of the next. It would not be valid to include the line $11\\ 22\\ 25$ in the output; each line must represent a single shortcut.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5ee9lv8u.png)\n\nThere is another solution that uses only one shortcut: Dante can move from $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6$, then move from $6 \\rightarrow 19$ (a shortcut), then move from $19 \\rightarrow 20 \\rightarrow 21 \\rightarrow 22 \\rightarrow 23 \\rightarrow 24 \\rightarrow 25$. This is also valid; there is no requirement to minimize (or maximize) the number of shortcuts taken.\n\nIn Sample Case #4, Dante cannot get to the central room ($9$, in this case) in just one move.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{K}<\\mathbf{N}^{2}-1$.\n- $\\mathbf{N} \\bmod \\quad 2 \\equiv 1$. ($\\mathbf{N}$ is odd.)\n\n**Test Set 1 (3 Pts, Visible Verdict)**\n\n- Time limit: 5 seconds.\n- $3 \\leq \\mathbf{N} \\leq 9$.\n\n**Test Set 2 (4 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $3 \\leq \\mathbf{N} \\leq 39$.\n\n**Test Set 3 (13 Pts, Hidden Verdict)**\n\n- Time limit: 20 seconds.\n- $3 \\leq \\mathbf{N} \\leq 9999$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #2] Spiraling Into Control", "background": "", "description": "As punishment for being naughty, Dante has been trapped in a strange house with many rooms. The house is an $\\mathbf{N} \\times \\mathbf{N}$ grid of rooms, with $\\mathbf{N}$ odd and greater than 1. The upper left room is numbered 1 , and then the other rooms are numbered $2,3, \\ldots, \\mathbf{N}^{2}$, in a clockwise spiral pattern. That is, the numbering proceeds along the top row of the grid and then makes a 90 degree turn to the right whenever a grid boundary or an already numbered room is encountered, and finishes in the central room of the grid. Because $\\mathbf{N}$ is odd, there is always a room in the exact center of the house, and it is always numbered $\\mathbf{N}^{2}$.\n\nFor example, here are the room numberings for houses with $\\mathbf{N}=3$ and $\\mathbf{N}=5$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/agyafjba.png)\n\nDante starts off in room 1 and is trying to reach the central room (room $\\mathbf{N}^{2}$ ). Throughout his journey, he can only make moves from his current room to higher-numbered, adjacent rooms. (Two rooms must share an edge - not just a corner - to be adjacent.)\n\nDante knows that he could walk from room to room in consecutive numerical order - i.e., if he is currently in room $x$, he would move to room $x+1$, and so on. This would take him exactly $\\mathbf{N}^{2}-1$ moves. But Dante wants to do things his way! Specifically, he wants to reach the central room in exactly $\\mathbf{K}$ moves, for some $\\mathbf{K}$ strictly less than $\\mathbf{N}^{2}-1$.\n\nDante can accomplish this by taking one or more shortcuts. A shortcut is a move between rooms that are not consecutively numbered.\n\nFor example, in the $5 \\times 5$ house above,\n\n- If Dante is at $1$, he cannot move to $17$, but he can move to $2$ or to $16$. The move to $2$ is not a shortcut, since $1+1=2$. The move to $16$ is a shortcut, since $1+1 \\neq 16$.\n- From $2$, it is possible to move to $3$ (not a shortcut) or to $17$ (a shortcut), but not to $1,16$, or $18$.\n- From $24$, Dante can only move to $25$ (not a shortcut).\n- It is not possible to move out of room $25$.\n\nAs a specific example using the $5 \\times 5$ house above, suppose that $\\mathbf{K}=4$. One option is for Dante to move from $1$ to $2$, then move from $2$ to $17$ (which is a shortcut), then move from $17$ to $18$, then move from $18$ to $25$ (which is another shortcut). This is illustrated below (the red arrows represent shortcuts):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/010wa6d8.png)\n\nCan you help Dante find a sequence of exactly $\\mathbf{K}$ moves that gets him to the central room, or tell him that it is impossible?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of one line with two integers $\\mathbf{N}$ and $\\mathbf{K}$, where $\\mathbf{N}$ is the dimension of the house (i.e. the number of rows of rooms, which is the same as the number of columns of rooms), and $\\mathbf{K}$ is the exact number of moves that Dante wants to make while traveling from room 1 to room $\\mathbf{N}^{2}$.", "outputFormat": "For each test case, output one line containing `Case x: y`, where $x$ is the test case number (starting from 1).\n\nIf no valid sequence of exactly $\\mathbf{K}$ moves will get Dante to the central room, $y$ must be IMPOSSIBLE.\n\nOtherwise, $y$ must be an integer: the number of times that Dante takes a shortcut, as described above. (Notice that because Dante wants to finish in strictly less than $\\mathbf{N}^{2}-1$ moves, he must always use at least one shortcut.) Then, output $y$ more lines of two integers each. The $i$-th of these lines represents the $i$-th time in Dante's journey that he takes a shortcut, i.e., he moves from some room $a_{i}$ to another room $b_{i}$ such that $a_{i}+1<b_{i}$.\n\nNotice that because these lines follow the order of the journey, $a_{i}<a_{i+1}$ for all $1 \\leq i<y$.", "hint": "**Sample Explanation**\n\nSample Case #1 is described in the problem statement. Dante's route is $1 \\rightarrow 2 \\rightarrow 17 \\rightarrow 18 \\rightarrow 25$. Because $1 \\rightarrow 2$ and $17 \\rightarrow 18$ are moves between consecutively numbered rooms, they are not included in the output. Only the shortcuts $(2 \\rightarrow 17$ and $18 \\rightarrow 25)$ are included.\n\nIn Sample Case #2, there is no solution. (Recall that there is no way for Dante to move diagonally.)\n\nIn Sample Case #3, observe that $22$ appears both as the end of one shortcut and the start of the next. It would not be valid to include the line $11\\ 22\\ 25$ in the output; each line must represent a single shortcut.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5ee9lv8u.png)\n\nThere is another solution that uses only one shortcut: Dante can move from $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6$, then move from $6 \\rightarrow 19$ (a shortcut), then move from $19 \\rightarrow 20 \\rightarrow 21 \\rightarrow 22 \\rightarrow 23 \\rightarrow 24 \\rightarrow 25$. This is also valid; there is no requirement to minimize (or maximize) the number of shortcuts taken.\n\nIn Sample Case #4, Dante cannot get to the central room ($9$, in this case) in just one move.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{K}<\\mathbf{N}^{2}-1$.\n- $\\mathbf{N} \\bmod \\quad 2 \\equiv 1$. ($\\mathbf{N}$ is odd.)\n\n**Test Set 1 (3 Pts, Visible Verdict)**\n\n- Time limit: 5 seconds.\n- $3 \\leq \\mathbf{N} \\leq 9$.\n\n**Test Set 2 (4 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $3 \\leq \\mathbf{N} \\leq 39$.\n\n**Test Set 3 (13 Pts, Hidden Verdict)**\n\n- Time limit: 20 seconds.\n- $3 \\leq \\mathbf{N} \\leq 9999$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #2] Spiraling Into Control", "background": "", "description": "由于调皮捣蛋，但丁被关进了一间由许多房间组成的奇怪房子。这栋房子是一个 $\\mathbf{N} \\times \\mathbf{N}$ 的网格状房间布局，其中 $\\mathbf{N}$ 为奇数且大于 1。左上角的房间编号为 1，其余房间按顺时针螺旋顺序依次编号为 $2, 3, \\ldots, \\mathbf{N}^{2}$。具体来说，编号从网格的顶行开始，每当遇到网格边界或已编号的房间时，向右转 90 度，最终到达网格正中央的房间。因为 $\\mathbf{N}$ 是奇数，房子中心始终有一个房间，其编号恒为 $\\mathbf{N}^{2}$。\n\n例如，下图展示了 $\\mathbf{N}=3$ 和 $\\mathbf{N}=5$ 时的房间编号：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/agyafjba.png)\n\n但丁从房间 1 出发，试图抵达中心房间（编号 $\\mathbf{N}^{2}$）。在行进过程中，他只能从当前房间移动到编号更大且相邻的房间（两房间必须共享一条边，而非仅共享一个角落）。\n\n但丁知道他可以按连续数字顺序移动——即若当前位于房间 $x$，则下一步移动到 $x+1$，依此类推。这样恰好需要 $\\mathbf{N}^{2}-1$ 步。但他想按自己的方式行动！具体来说，他希望**恰好用 $\\mathbf{K}$ 步**到达中心房间，其中 $\\mathbf{K}$ 严格小于 $\\mathbf{N}^{2}-1$。\n\n为此，但丁需要通过一个或多个**捷径**实现。捷径是指两个非连续编号房间之间的移动。\n\n以 $\\mathbf{N}=5$ 的房屋为例：\n\n- 若但丁位于 $1$，他不能移动到 $17$，但可移动到 $2$ 或 $16$。移动到 $2$ 不是捷径（因为 $1+1=2$），而移动到 $16$ 是捷径（因为 $1+1 \\neq 16$）。\n- 从 $2$ 可移动到 $3$（非捷径）或 $17$（捷径），但不能移动到 $1$、$16$ 或 $18$。\n- 从 $24$ 只能移动到 $25$（非捷径）。\n- 无法从房间 $25$ 移出。\n\n更具体的例子：当 $\\mathbf{N}=5$ 且 $\\mathbf{K}=4$ 时，一种可行方案是 $1 \\rightarrow 2 \\rightarrow 17$（捷径）$\\rightarrow 18 \\rightarrow 25$（捷径）。如下图所示（红色箭头代表捷径）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/010wa6d8.png)\n\n请你帮助但丁找到恰好 $\\mathbf{K}$ 步到达中心房间的路径，或判断其不可能。", "inputFormat": "第一行输入测试用例数量 $\\mathbf{T}$。随后 $\\mathbf{T}$ 行，每行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{K}$，分别表示房屋的维度（行列数）和但丁期望的移动步数。\n", "outputFormat": "对于每个测试用例，输出一行 `Case x: y`，其中 $x$ 为用例编号（从 1 开始）。\n\n若无法用恰好 $\\mathbf{K}$ 步到达中心房间，$y$ 为 **IMPOSSIBLE**。\n\n否则，$y$ 为但丁使用的捷径数量（因 $\\mathbf{K} < \\mathbf{N}^{2}-1$，至少需一次捷径）。随后输出 $y$ 行，每行两个整数 $a_i$ 和 $b_i$，表示第 $i$ 次捷径是从 $a_i$ 移动到 $b_i$（满足 $a_i+1 < b_i$）。\n\n注意：这些行需按行进顺序排列，即对所有 $1 \\leq i < y$ 有 $a_i < a_{i+1}$。", "hint": "**样例解释**\n\n样例 #1 对应题目描述中的示例。但丁的路径为 $1 \\rightarrow 2 \\rightarrow 17 \\rightarrow 18 \\rightarrow 25$。其中 $1 \\rightarrow 2$ 和 $17 \\rightarrow 18$ 是连续移动，故仅输出捷径 $(2 \\rightarrow 17$ 和 $18 \\rightarrow 25)$。\n\n样例 #2 无解（注意但丁无法斜向移动）。\n\n样例 #3 中，数字 $22$ 既是前一次捷径的终点，也是下一次的起点。输出中不能合并为 $11\\ 22\\ 25$，每行必须代表单独一次捷径。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5ee9lv8u.png)\n\n另一种仅需一次捷径的方案：$1 \\rightarrow 2 \\rightarrow \\ldots \\rightarrow 6 \\rightarrow 19$（捷径）$\\rightarrow 20 \\rightarrow \\ldots \\rightarrow 25$。此方案同样有效，不要求最小化或最大化捷径次数。\n\n样例 #4 中，但丁无法一步到达中心房间（此处为 $9$）。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{K} < \\mathbf{N}^{2}-1$。\n- $\\mathbf{N} \\bmod 2 \\equiv 1$（$\\mathbf{N}$ 为奇数）。\n\n**测试集 1（3 分，可见判定）**\n\n- 时间限制：5 秒。\n- $3 \\leq \\mathbf{N} \\leq 9$。\n\n**测试集 2（4 分，可见判定）**\n\n- 时间限制：20 秒。\n- $3 \\leq \\mathbf{N} \\leq 39$。\n\n**测试集 3（13 分，隐藏判定）**\n\n- 时间限制：20 秒。\n- $3 \\leq \\mathbf{N} \\leq 9999$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12994", "type": "P", "difficulty": 5, "samples": [["3\n2\n8\n50", "Case #1: 4\nCase #2: 24\nCase #3: 812"]], "limits": {"time": [10000, 10000, 15000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "2022", "Google Code Jam"], "title": "[GCJ 2022 #2] Pixelated Circle", "background": "", "description": "Typical computer images are matrices of pixels, with each pixel being a small square of a specific color. Drawing lines that are not perfectly parallel to the axes of the pixel matrix results in imperfections. Drawing circles is an extreme example where those imperfections arise.\n\nSuppose we have a picture consisting of $2 \\mathbf{R}+1$ by $2 \\mathbf{R}+1$ pixels, and we number the rows and columns of pixels between $-\\mathbf{R}$ and $\\mathbf{R}$, such that the center pixel is at row 0 and column 0 . Initially, all pixels are white. Then, a circle of radius $\\mathbf{R}$ and centered in the picture can be drawn in black by the following pseudocode, where `set_pixel_to_black` $(x, y)$ makes the pixel at row $x$ and column $y$ be colored black.\n\n```\ndraw_circle_perimeter(R):\n  for x between -R and R, inclusive {\n    y = round(sqrt(R * R - x * x))   # round to nearest integer, breaking ties towards zero\n    set_pixel_to_black(x, y)\n    set_pixel_to_black(x, -y)\n    set_pixel_to_black(y, x)\n    set_pixel_to_black(-y, x)\n  }\n```\n\nNotice that some pixels may be set to black more than once by the code, but the operation is idempotent (that is, calling `set_pixel_to_black` on a pixel that is already black changes nothing).\n\nThe following is pseudocode for a function to draw a filled circle (starting from an all-white picture).\n\n```\ndraw_circle_filled(R):\n  for x between -R and R, inclusive {\n    for y between -R and R, inclusive {\n      if round(sqrt(x * x + y * y)) <= R:\n        set_pixel_to_black(x, y)\n    }\n  }\n```\n\nAnd finally, the following is pseudocode to incorrectly draw a filled circle:\n\n```\ndraw_circle_filled_wrong(R):\n  for r between 0 and R, inclusive {\n    draw_circle_perimeter(r)\n  }\n```\n\nGiven $\\mathbf{R}$, calculate the number of pixels that would have different colors between a picture in which `draw_circle_filled` $(\\mathbf{R})$ is called and another one in which draw_circle_filled_wrong $(\\mathbf{R})$ is called.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in a single line containing a single integer $\\mathbf{R}$, the radius of the circle to draw.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of pixels that would have different colors between a picture in which draw_circle_filled $(\\mathbf{R})$ is called and another one in which draw_circle_filled_wrong $(\\mathbf{R})$ is called.", "hint": "In Sample Case #1, $21$ pixels are drawn in black by calling `draw_circle_filled(2)` (shown in the left picture). 17 pixels are drawn in black by calling `draw_circle_filled_wrong(2)` (shown in the right picture). Four pixels would have different colors between the two pictures: $(-1,-1),(-1,1),(1,-1)$, and $(1,1)$, where $(x, y)$ represents the pixel at row $x$ and column $y$, with the rows and columns numbered as described in the statement.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mon7gnuv.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/7e8vljtj.png)\n\nIn Sample Case #2, the following pictures are the images generated by calling `draw_circle_filled(8)` (left) and `draw_circle_filled_wrong(8)` (right).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ropx4q0k.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/hmbxyi6p.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $1 \\leq \\mathbf{R} \\leq 100$.\n\n**Test Set 2 (Hidden Verdict)**\n\n- Time limit: 15 seconds.\n- $1 \\leq \\mathbf{R} \\leq 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #2] Pixelated Circle", "background": "", "description": "Typical computer images are matrices of pixels, with each pixel being a small square of a specific color. Drawing lines that are not perfectly parallel to the axes of the pixel matrix results in imperfections. Drawing circles is an extreme example where those imperfections arise.\n\nSuppose we have a picture consisting of $2 \\mathbf{R}+1$ by $2 \\mathbf{R}+1$ pixels, and we number the rows and columns of pixels between $-\\mathbf{R}$ and $\\mathbf{R}$, such that the center pixel is at row 0 and column 0 . Initially, all pixels are white. Then, a circle of radius $\\mathbf{R}$ and centered in the picture can be drawn in black by the following pseudocode, where `set_pixel_to_black` $(x, y)$ makes the pixel at row $x$ and column $y$ be colored black.\n\n```\ndraw_circle_perimeter(R):\n  for x between -R and R, inclusive {\n    y = round(sqrt(R * R - x * x))   # round to nearest integer, breaking ties towards zero\n    set_pixel_to_black(x, y)\n    set_pixel_to_black(x, -y)\n    set_pixel_to_black(y, x)\n    set_pixel_to_black(-y, x)\n  }\n```\n\nNotice that some pixels may be set to black more than once by the code, but the operation is idempotent (that is, calling `set_pixel_to_black` on a pixel that is already black changes nothing).\n\nThe following is pseudocode for a function to draw a filled circle (starting from an all-white picture).\n\n```\ndraw_circle_filled(R):\n  for x between -R and R, inclusive {\n    for y between -R and R, inclusive {\n      if round(sqrt(x * x + y * y)) <= R:\n        set_pixel_to_black(x, y)\n    }\n  }\n```\n\nAnd finally, the following is pseudocode to incorrectly draw a filled circle:\n\n```\ndraw_circle_filled_wrong(R):\n  for r between 0 and R, inclusive {\n    draw_circle_perimeter(r)\n  }\n```\n\nGiven $\\mathbf{R}$, calculate the number of pixels that would have different colors between a picture in which `draw_circle_filled` $(\\mathbf{R})$ is called and another one in which draw_circle_filled_wrong $(\\mathbf{R})$ is called.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in a single line containing a single integer $\\mathbf{R}$, the radius of the circle to draw.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of pixels that would have different colors between a picture in which draw_circle_filled $(\\mathbf{R})$ is called and another one in which draw_circle_filled_wrong $(\\mathbf{R})$ is called.", "hint": "In Sample Case #1, $21$ pixels are drawn in black by calling `draw_circle_filled(2)` (shown in the left picture). 17 pixels are drawn in black by calling `draw_circle_filled_wrong(2)` (shown in the right picture). Four pixels would have different colors between the two pictures: $(-1,-1),(-1,1),(1,-1)$, and $(1,1)$, where $(x, y)$ represents the pixel at row $x$ and column $y$, with the rows and columns numbered as described in the statement.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mon7gnuv.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/7e8vljtj.png)\n\nIn Sample Case #2, the following pictures are the images generated by calling `draw_circle_filled(8)` (left) and `draw_circle_filled_wrong(8)` (right).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ropx4q0k.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/hmbxyi6p.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $1 \\leq \\mathbf{R} \\leq 100$.\n\n**Test Set 2 (Hidden Verdict)**\n\n- Time limit: 15 seconds.\n- $1 \\leq \\mathbf{R} \\leq 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #2] Pixelated Circle", "background": "", "description": "典型的计算机图像是由像素组成的矩阵，每个像素是一个特定颜色的小方块。绘制不完美平行于像素矩阵坐标轴的线条会导致瑕疵，而绘制圆形则是这种瑕疵的极端例子。\n\n假设我们有一张由 $2 \\mathbf{R}+1$ 行 $2 \\mathbf{R}+1$ 列像素组成的图片，像素的行和列编号从 $-\\mathbf{R}$ 到 $\\mathbf{R}$，中心像素位于第 0 行第 0 列。初始时，所有像素均为白色。然后，可以通过以下伪代码绘制一个半径为 $\\mathbf{R}$ 且居中的黑色圆，其中 `set_pixel_to_black` $(x, y)$ 将第 $x$ 行第 $y$ 列的像素设为黑色：\n\n```\ndraw_circle_perimeter(R):\n  for x between -R and R, inclusive {\n    y = round(sqrt(R * R - x * x))   # round to nearest integer, breaking ties towards zero\n    set_pixel_to_black(x, y)\n    set_pixel_to_black(x, -y)\n    set_pixel_to_black(y, x)\n    set_pixel_to_black(-y, x)\n  }\n```\n\n注意，某些像素可能被多次设为黑色，但该操作是幂等的（即对已经是黑色的像素调用 `set_pixel_to_black` 不会有任何效果）。\n\n以下是绘制实心圆的伪代码（从全白图片开始）：\n\n```\ndraw_circle_filled(R):\n  for x between -R and R, inclusive {\n    for y between -R and R, inclusive {\n      if round(sqrt(x * x + y * y)) <= R:\n        set_pixel_to_black(x, y)\n    }\n  }\n```\n\n最后，以下是错误绘制实心圆的伪代码：\n\n```\ndraw_circle_filled_wrong(R):\n  for r between 0 and R, inclusive {\n    draw_circle_perimeter(r)\n  }\n```\n\n给定 $\\mathbf{R}$，计算在调用 `draw_circle_filled` $(\\mathbf{R})$ 和调用 `draw_circle_filled_wrong` $(\\mathbf{R})$ 的两张图片中颜色不同的像素数量。\n", "inputFormat": "第一行输入测试用例数量 $\\mathbf{T}$。随后 $\\mathbf{T}$ 行，每行包含一个整数 $\\mathbf{R}$，表示要绘制的圆的半径。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为用例编号（从 1 开始），$y$ 为两张图片中颜色不同的像素数量。\n", "hint": "在样例 #1 中，调用 `draw_circle_filled(2)` 会绘制 21 个黑色像素（左图），调用 `draw_circle_filled_wrong(2)` 会绘制 17 个黑色像素（右图）。两张图片中有 4 个像素颜色不同：$(-1,-1)$、$(-1,1)$、$(1,-1)$ 和 $(1,1)$，其中 $(x, y)$ 表示第 $x$ 行第 $y$ 列的像素，行列编号如题目描述所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mon7gnuv.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/7e8vljtj.png)\n\n在样例 #2 中，左图和右图分别是调用 `draw_circle_filled(8)` 和 `draw_circle_filled_wrong(8)` 生成的图片。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ropx4q0k.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/hmbxyi6p.png)\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n\n**测试集 1（5 分，可见判定）**\n\n- 时间限制：10 秒。\n- $1 \\leq \\mathbf{R} \\leq 100$。\n\n**测试集 2（隐藏判定）**\n\n- 时间限制：15 秒。\n- $1 \\leq \\mathbf{R} \\leq 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12995", "type": "P", "difficulty": 6, "samples": [["4\n2\n-3 0\n-1 0\n3 0\n-2 -1\n-2 1\n1\n0 0\n1 1\n2 2\n3\n10 0\n-10 0\n0 0\n0 5\n-1 0\n5 0\n0 -5\n2\n3 4\n3 4\n5 7\n3 4\n5 7", "Case #1: POSSIBLE\n2 2\n1 3\nCase #2: IMPOSSIBLE\nCase #3: POSSIBLE\n3 2\n2 4\n1 3\nCase #4: POSSIBLE\n1 2\n2 3"]], "limits": {"time": [10000, 10000, 45000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2022", "网络流", "Special Judge", "二分图", "Google Code Jam"], "title": "[GCJ 2022 #2] Saving the Jelly", "background": "", "description": "Mr. Jolly teaches football (or soccer, for US speakers) to $\\mathbf{N}$ children numbered from 1 to $\\mathbf{N}$. He has taken to leaving sweets on the field where the games take place, one for each child. After the game is finished, each child can grab and eat one sweet as their reward.\n\nThe children are tired after games, so each child wants to grab the sweet closest to them (using Euclidean distance). This could lead to fights - if the same sweet is closest to two or more children. To avoid that, after the game all the children stop where they are, and Mr. Jolly calls out their names, one by one. When a child's name is called, they grab the closest sweet to them (out of the ones that weren't already grabbed, of course). In the case where two or more sweets are tied for the smallest distance, Mr. Jolly can decide which one the child grabs.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h3px6piy.png)\n\nThis has worked very well for Mr. Jolly for a while now, but today disaster struck! While laying out the sweets, Mr. Jolly accidentally dropped his blueberry jelly that he planned to eat after all the children go home. So now there are $\\mathbf{N}$ children on the field, and $\\mathbf{N}+1$ sweets. The sweets are numbered from 1 to $\\mathbf{N}+1$, with sweet 1 being Mr. Jolly's blueberry jelly. Is there a way for Mr. Jolly to save his blueberry jelly by calling the children's names in such an order that the blueberry jelly is the one sweet left over?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test begins with a line containing a single integer, $\\mathbf{N}$, the number of children on the field. The next $\\mathbf{N}$ lines describe the positions of the children. Each of these lines contains two integers, $\\mathbf{X}_{\\mathbf{i}}$ and $\\mathbf{Y}_{\\mathbf{i}}$, representing the position of the $i$-th child after the game ends. Then there are $\\mathbf{N}+1$ more lines that describe the positions of sweets after the game, where the first of the sweets is Mr. Jolly's blueberry jelly. Each of these lines contains two integers, $\\mathbf{X}_{\\mathbf{j}}$ and $\\mathbf{Y}_{\\mathbf{j}}$, representing the position of the $j$-th sweet.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if there is no way Mr. Jolly can choose the children (and break ties for the closest sweet) to leave his blueberry jelly uneaten. Otherwise, if Mr. Jolly can save his blueberry jelly, $y$ is POSSIBLE. If Mr. Jolly can save his jelly, output $\\mathbf{N}$ additional lines representing the order the children will go and which jellies they will pick. The $i$-th line should contain two integers $A_{i}$ and $B_{i}$ representing that child $A_{i}$ will go next and will pick sweet $B_{i}$. The sweet $B_{i}$ must be the closest (or tied for the closest) sweet to child $A_{i}$ when they go to pick their sweet.", "hint": "**Sample Explanation**\n\nSample Case #1 is illustrated in the image above. Notice that each child is equally close to each of the two non-blueberry-jelly sweets. In our solution, Mr. Jolly assigns the second sweet to the second child and the third sweet to the first child, successfully leaving the first sweet (the blueberry jelly) for himself.\n\nIn Sample Case #2, the sole child is closer to the blueberry jelly than to the other sweet, so Mr. Jolly cannot prevent his precious blueberry jelly from being eaten.\n\nIn Sample Case #3, we present one of many solutions; it is actually possible to call the children in any order.\n\nIn Sample Case #4, note that children might share the same position, sweets might share the same position, and children and sweets might share the same position.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $-10^{9} \\leq \\mathbf{X}_{\\mathbf{i}} \\leq 10^{9}$, for all $i$.\n- $-10^{9} \\leq \\mathbf{Y}_{\\mathbf{i}} \\leq 10^{9}$, for all $i$.\n- $-10^{9} \\leq \\mathbf{X}_{\\mathbf{j}} \\leq 10^{9}$, for all $j$.\n- $-10^{9} \\leq \\mathbf{Y}_{\\mathbf{j}} \\leq 10^{9}$, for all $j$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $1 \\leq \\mathbf{N} \\leq 10$.\n\n**Test Set 2 (18 Pts, Hidden Verdict)**\n\n- Time limit: 45 seconds.\n- $1 \\leq \\mathbf{N} \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #2] Saving the Jelly", "background": "", "description": "Mr. Jolly teaches football (or soccer, for US speakers) to $\\mathbf{N}$ children numbered from 1 to $\\mathbf{N}$. He has taken to leaving sweets on the field where the games take place, one for each child. After the game is finished, each child can grab and eat one sweet as their reward.\n\nThe children are tired after games, so each child wants to grab the sweet closest to them (using Euclidean distance). This could lead to fights - if the same sweet is closest to two or more children. To avoid that, after the game all the children stop where they are, and Mr. Jolly calls out their names, one by one. When a child's name is called, they grab the closest sweet to them (out of the ones that weren't already grabbed, of course). In the case where two or more sweets are tied for the smallest distance, Mr. Jolly can decide which one the child grabs.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h3px6piy.png)\n\nThis has worked very well for Mr. Jolly for a while now, but today disaster struck! While laying out the sweets, Mr. Jolly accidentally dropped his blueberry jelly that he planned to eat after all the children go home. So now there are $\\mathbf{N}$ children on the field, and $\\mathbf{N}+1$ sweets. The sweets are numbered from 1 to $\\mathbf{N}+1$, with sweet 1 being Mr. Jolly's blueberry jelly. Is there a way for Mr. Jolly to save his blueberry jelly by calling the children's names in such an order that the blueberry jelly is the one sweet left over?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test begins with a line containing a single integer, $\\mathbf{N}$, the number of children on the field. The next $\\mathbf{N}$ lines describe the positions of the children. Each of these lines contains two integers, $\\mathbf{X}_{\\mathbf{i}}$ and $\\mathbf{Y}_{\\mathbf{i}}$, representing the position of the $i$-th child after the game ends. Then there are $\\mathbf{N}+1$ more lines that describe the positions of sweets after the game, where the first of the sweets is Mr. Jolly's blueberry jelly. Each of these lines contains two integers, $\\mathbf{X}_{\\mathbf{j}}$ and $\\mathbf{Y}_{\\mathbf{j}}$, representing the position of the $j$-th sweet.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if there is no way Mr. Jolly can choose the children (and break ties for the closest sweet) to leave his blueberry jelly uneaten. Otherwise, if Mr. Jolly can save his blueberry jelly, $y$ is POSSIBLE. If Mr. Jolly can save his jelly, output $\\mathbf{N}$ additional lines representing the order the children will go and which jellies they will pick. The $i$-th line should contain two integers $A_{i}$ and $B_{i}$ representing that child $A_{i}$ will go next and will pick sweet $B_{i}$. The sweet $B_{i}$ must be the closest (or tied for the closest) sweet to child $A_{i}$ when they go to pick their sweet.", "hint": "**Sample Explanation**\n\nSample Case #1 is illustrated in the image above. Notice that each child is equally close to each of the two non-blueberry-jelly sweets. In our solution, Mr. Jolly assigns the second sweet to the second child and the third sweet to the first child, successfully leaving the first sweet (the blueberry jelly) for himself.\n\nIn Sample Case #2, the sole child is closer to the blueberry jelly than to the other sweet, so Mr. Jolly cannot prevent his precious blueberry jelly from being eaten.\n\nIn Sample Case #3, we present one of many solutions; it is actually possible to call the children in any order.\n\nIn Sample Case #4, note that children might share the same position, sweets might share the same position, and children and sweets might share the same position.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $-10^{9} \\leq \\mathbf{X}_{\\mathbf{i}} \\leq 10^{9}$, for all $i$.\n- $-10^{9} \\leq \\mathbf{Y}_{\\mathbf{i}} \\leq 10^{9}$, for all $i$.\n- $-10^{9} \\leq \\mathbf{X}_{\\mathbf{j}} \\leq 10^{9}$, for all $j$.\n- $-10^{9} \\leq \\mathbf{Y}_{\\mathbf{j}} \\leq 10^{9}$, for all $j$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $1 \\leq \\mathbf{N} \\leq 10$.\n\n**Test Set 2 (18 Pts, Hidden Verdict)**\n\n- Time limit: 45 seconds.\n- $1 \\leq \\mathbf{N} \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #2] Saving the Jelly", "background": "", "description": "Jolly 先生正在教编号为 1 到 $\\mathbf{N}$ 的 $\\mathbf{N}$ 个孩子踢足球（或称 soccer，针对美国读者）。他习惯在比赛场地上放置糖果，每个孩子一颗。比赛结束后，每个孩子可以拿走并吃掉一颗作为奖励。\n\n孩子们在比赛后很累，所以每个孩子都想拿离自己最近的糖果（使用欧几里得距离计算）。这可能导致冲突——如果同一颗糖果是多个孩子最近的。为避免这种情况，比赛结束后所有孩子停在原地，Jolly 先生会依次点名。当被点到名时，孩子会拿走离自己最近的糖果（当然，只能选未被拿走的糖果）。当有多颗糖果距离最近且相同时，Jolly 先生可以决定孩子拿哪一颗。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h3px6piy.png)\n\n这个方法一直很有效，但今天出问题了！Jolly 先生在布置糖果时，不小心把他准备在孩子们回家后享用的蓝莓果冻也放在了场地上。现在场上有 $\\mathbf{N}$ 个孩子和 $\\mathbf{N}+1$ 颗糖果。糖果编号为 1 到 $\\mathbf{N}+1$，其中 1 号是 Jolly 先生的蓝莓果冻。是否存在一种点名顺序，使得最后剩下的糖果正好是蓝莓果冻？", "inputFormat": "第一行输入测试用例数量 $\\mathbf{T}$。随后 $\\mathbf{T}$ 个测试用例，每个用例第一行是一个整数 $\\mathbf{N}$ 表示孩子数量。接下来 $\\mathbf{N}$ 行描述孩子的位置，每行两个整数 $\\mathbf{X}_{\\mathbf{i}}$ 和 $\\mathbf{Y}_{\\mathbf{i}}$ 表示第 $i$ 个孩子的坐标。随后 $\\mathbf{N}+1$ 行描述糖果位置，其中第一颗是蓝莓果冻，每行两个整数 $\\mathbf{X}_{\\mathbf{j}}$ 和 $\\mathbf{Y}_{\\mathbf{j}}$ 表示第 $j$ 颗糖果的坐标。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是用例编号（从 1 开始）。若无法保留蓝莓果冻，$y$ 为 IMPOSSIBLE；否则为 POSSIBLE。若可能，还需输出 $\\mathbf{N}$ 行表示点名顺序和选择的糖果，每行两个整数 $A_{i}$ 和 $B_{i}$，表示孩子 $A_{i}$ 被点名并选择糖果 $B_{i}$（选择时 $B_{i}$ 必须是该孩子最近的糖果之一）。\n", "hint": "**样例解释**\n\n样例 #1 如上图所示。每个孩子到两颗非果冻糖果的距离相等。解决方案中，Jolly 先生让 2 号孩子拿 2 号糖果，1 号孩子拿 3 号糖果，成功保留 1 号糖果（蓝莓果冻）。\n\n样例 #2 中，唯一的孩子离蓝莓果冻比其他糖果更近，Jolly 先生无法保住果冻。\n\n样例 #3 展示了一种可能的解，实际上可以任意顺序点名。\n\n样例 #4 中注意孩子可能位置重合、糖果可能位置重合、孩子和糖果也可能位置重合。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$\n- 所有坐标的绝对值不超过 $10^{9}$\n\n**测试集 1（10 分，可见判定）**\n\n- 时间限制：10 秒\n- $1 \\leq \\mathbf{N} \\leq 10$\n\n**测试集 2（18 分，隐藏判定）**\n\n- 时间限制：45 秒\n- $1 \\leq \\mathbf{N} \\leq 1000$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12996", "type": "P", "difficulty": 6, "samples": [["4\n5 0\n3 0\n6 0\n8 0\n10 1\n15 1\n5 10\n3 0\n6 0\n8 0\n10 1\n15 1\n5 1\n3 0\n6 0\n8 0\n10 1\n15 1\n2 0\n1000000000 0\n-1000000000 1", "Case #1: 52\nCase #2: 56\nCase #3: 54\nCase #4: 4000000000"]], "limits": {"time": [40000, 40000, 40000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2022", "Google Code Jam"], "title": "[GCJ 2022 #2] I, O Bot", "background": "", "description": "To welcome attendees to a developers' conference on Jupiter's moon of Io, the organizers inflated many giant beach balls. Each ball is in roughly the shape of either a 1 or a 0, since those look sort of like the letters I and O. The conference just ended, and so now the beach balls need to be cleaned up. Luckily, the beach ball cleanup robot, BALL-E, is on the job!\n\nThe conference was held on an infinite horizontal line, with station 0 in the middle, stations 1, 2, … to the right, and stations $-1, -2, \\ldots$ to the left. Station 0 contains the conference's only beach ball storage warehouse. Each other station contains at most one beach ball.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/88wnnnxw.png)\n\nBALL-E has two storage compartments, each of which can hold a single beach ball. One compartment can only hold 1-shaped balls and the other can only hold 0-shaped balls. (The 1-shaped balls are more oblong than the 0-shaped balls, so neither shape of ball will fit in the other shape's compartment.)\n\nBALL-E initially has both the 0 and 1 compartments empty, and it starts off at station 0. The robot can do the following things:\n\n* Move left one station or right one station. This costs 1 unit of power.\n* If there is a ball at the current station, and BALL-E is not already storing a ball of that shape, it can put the ball in the appropriate compartment. This takes 0 units of power.\n* If there is a ball at the current station, BALL-E can compress it so that its shape becomes the other shape. That is, a 1-shaped ball becomes a 0-shaped ball, or vice versa. It takes $\\mathbf{C}$ units of power to do this. Note that BALL-E may not change the shape of a ball that it has already put into one of its compartments.\n* If BALL-E is at station 0 and is storing at least one ball, it can deposit all balls from its compartment(s) into the beach ball storage warehouse. This takes 0 units of power and leaves both compartments empty.\n\nNotice that if BALL-E moves to a station and there is a ball there, BALL-E is not required to pick it up immediately, even if the robot has an open compartment for it. Also, if BALL-E moves to the station with the warehouse, it is not required to deposit any balls it has.\n\nFind the minimum number of units of power needed for BALL-E to transfer all of the balls to the warehouse, using only the moves described above.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow.\n\nThe first line of each test case contains two integers, $\\mathbf{N}$ and $\\mathbf{C}$: the number of balls and the amount of power units needed to change the shape of a ball, respectively.\n\nThe next $\\mathbf{N}$ lines describe the positions (i.e., station numbers) and the shapes of the balls. The $i$-th line contains two integers, $\\mathbf{X}_{\\mathbf{i}}$ and $\\mathbf{S}_{\\mathbf{i}}$: the position and the shape of the $i$-th ball, respectively.", "outputFormat": "For each test case, output one line containing case # $x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of units of power needed to transfer all of the balls to the warehouse, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1 (illustrated in the statement), there are $\\mathbf{N} = 5$ balls and $\\mathbf{C} = 0$. One optimal strategy is to make three round trips from (and back to) the warehouse:\n\n* First round trip: Move to station 3, pick up the 0 ball there and store it in the 0 compartment, move back to station 0, and deposit the ball in the warehouse. This takes 6 units of power.\n* Second round trip: Move to station 8, pick up the 0 ball there, and store it in the 0 compartment. Move to station 6, change the 0 ball there into a 1 ball, and pick it up and store it in the 1 compartment. Move to station 0 and deposit both balls in the warehouse. This takes 16 units of power. (Recall that in this case, it takes 0 units of power to change a ball's shape.)\n* Third round trip: Move to station 10. Change the 1 ball there into a 0 ball, and pick it up and store it in the 0 compartment. Move to station 15. Pick up the 1 ball there and store it in the 1 compartment. Move to station 0 and deposit both balls in the warehouse. This takes 30 units of power.\n\nThe total number of units of power needed to collect all the balls is 52.\n\nSample Case #2 is like Sample Case #1, but now with $\\mathbf{C} = 10$. Now BALL-E has to use at least 56 units of power:\n\n* First round trip: Get the ball from station 3. This takes 6 units of power.\n* Second round trip: Get the differently-shaped balls from stations 6 and 10. (These are a 0 and a 1, respectively, so there is no need to change the shape of either of them.) This takes 20 units of power.\n* Third round trip: Get the differently-shaped balls from stations 8 and 15. This takes 30 units of power.\n\nSample Case #3 is also like Sample Case #1, but now with $\\mathbf{C} = 1$. Here, BALL-E needs at least 54 units of power:\n\n* First round trip: Get the ball from station 3. This takes 6 units of power.\n* Second round trip: Get the ball from station 8. When passing through station 6 on the way back, change the shape of the ball there and get it. This takes 17 units of power.\n* Third round trip: Do the same with the balls at stations 15 and 10. This takes 31 units of power.\n\nIn Sample Case #4, one optimal strategy is for BALL-E to move to station $-1000000000$, get the 1 ball there, move to station $1000000000$, get the 0 ball there, and then return to station 0 to deposit both of them.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{S}_{\\mathbf{i}} \\leq 1$, for all $i$.\n- $-10^{9} \\leq \\mathbf{X}_{\\mathbf{i}} \\leq 10^{9}$, for all $i$.\n- $0 \\leq \\mathbf{C} \\leq 10^{9}$.\n- $\\mathbf{X}_{\\mathbf{i}} \\neq 0$, for all $i$.\n- All $\\mathbf{X}_{\\mathbf{i}}$ are distinct.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\nFor at most 15 cases:\n\n- $1 \\leq \\mathbf{N} \\leq 5000$.\n\nFor the remaining cases:\n\n- $1 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 2 (20 Pts, Hidden Verdict)**\n\nFor at most 15 cases:\n\n- $1 \\leq \\mathbf{N} \\leq 10^{5}$.\n\nFor the remaining cases:\n\n- $1 \\leq \\mathbf{N} \\leq 5000$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #2] I, O Bot", "background": "", "description": "To welcome attendees to a developers' conference on Jupiter's moon of Io, the organizers inflated many giant beach balls. Each ball is in roughly the shape of either a 1 or a 0, since those look sort of like the letters I and O. The conference just ended, and so now the beach balls need to be cleaned up. Luckily, the beach ball cleanup robot, BALL-E, is on the job!\n\nThe conference was held on an infinite horizontal line, with station 0 in the middle, stations 1, 2, … to the right, and stations $-1, -2, \\ldots$ to the left. Station 0 contains the conference's only beach ball storage warehouse. Each other station contains at most one beach ball.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/88wnnnxw.png)\n\nBALL-E has two storage compartments, each of which can hold a single beach ball. One compartment can only hold 1-shaped balls and the other can only hold 0-shaped balls. (The 1-shaped balls are more oblong than the 0-shaped balls, so neither shape of ball will fit in the other shape's compartment.)\n\nBALL-E initially has both the 0 and 1 compartments empty, and it starts off at station 0. The robot can do the following things:\n\n* Move left one station or right one station. This costs 1 unit of power.\n* If there is a ball at the current station, and BALL-E is not already storing a ball of that shape, it can put the ball in the appropriate compartment. This takes 0 units of power.\n* If there is a ball at the current station, BALL-E can compress it so that its shape becomes the other shape. That is, a 1-shaped ball becomes a 0-shaped ball, or vice versa. It takes $\\mathbf{C}$ units of power to do this. Note that BALL-E may not change the shape of a ball that it has already put into one of its compartments.\n* If BALL-E is at station 0 and is storing at least one ball, it can deposit all balls from its compartment(s) into the beach ball storage warehouse. This takes 0 units of power and leaves both compartments empty.\n\nNotice that if BALL-E moves to a station and there is a ball there, BALL-E is not required to pick it up immediately, even if the robot has an open compartment for it. Also, if BALL-E moves to the station with the warehouse, it is not required to deposit any balls it has.\n\nFind the minimum number of units of power needed for BALL-E to transfer all of the balls to the warehouse, using only the moves described above.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow.\n\nThe first line of each test case contains two integers, $\\mathbf{N}$ and $\\mathbf{C}$: the number of balls and the amount of power units needed to change the shape of a ball, respectively.\n\nThe next $\\mathbf{N}$ lines describe the positions (i.e., station numbers) and the shapes of the balls. The $i$-th line contains two integers, $\\mathbf{X}_{\\mathbf{i}}$ and $\\mathbf{S}_{\\mathbf{i}}$: the position and the shape of the $i$-th ball, respectively.", "outputFormat": "For each test case, output one line containing case # $x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of units of power needed to transfer all of the balls to the warehouse, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1 (illustrated in the statement), there are $\\mathbf{N} = 5$ balls and $\\mathbf{C} = 0$. One optimal strategy is to make three round trips from (and back to) the warehouse:\n\n* First round trip: Move to station 3, pick up the 0 ball there and store it in the 0 compartment, move back to station 0, and deposit the ball in the warehouse. This takes 6 units of power.\n* Second round trip: Move to station 8, pick up the 0 ball there, and store it in the 0 compartment. Move to station 6, change the 0 ball there into a 1 ball, and pick it up and store it in the 1 compartment. Move to station 0 and deposit both balls in the warehouse. This takes 16 units of power. (Recall that in this case, it takes 0 units of power to change a ball's shape.)\n* Third round trip: Move to station 10. Change the 1 ball there into a 0 ball, and pick it up and store it in the 0 compartment. Move to station 15. Pick up the 1 ball there and store it in the 1 compartment. Move to station 0 and deposit both balls in the warehouse. This takes 30 units of power.\n\nThe total number of units of power needed to collect all the balls is 52.\n\nSample Case #2 is like Sample Case #1, but now with $\\mathbf{C} = 10$. Now BALL-E has to use at least 56 units of power:\n\n* First round trip: Get the ball from station 3. This takes 6 units of power.\n* Second round trip: Get the differently-shaped balls from stations 6 and 10. (These are a 0 and a 1, respectively, so there is no need to change the shape of either of them.) This takes 20 units of power.\n* Third round trip: Get the differently-shaped balls from stations 8 and 15. This takes 30 units of power.\n\nSample Case #3 is also like Sample Case #1, but now with $\\mathbf{C} = 1$. Here, BALL-E needs at least 54 units of power:\n\n* First round trip: Get the ball from station 3. This takes 6 units of power.\n* Second round trip: Get the ball from station 8. When passing through station 6 on the way back, change the shape of the ball there and get it. This takes 17 units of power.\n* Third round trip: Do the same with the balls at stations 15 and 10. This takes 31 units of power.\n\nIn Sample Case #4, one optimal strategy is for BALL-E to move to station $-1000000000$, get the 1 ball there, move to station $1000000000$, get the 0 ball there, and then return to station 0 to deposit both of them.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{S}_{\\mathbf{i}} \\leq 1$, for all $i$.\n- $-10^{9} \\leq \\mathbf{X}_{\\mathbf{i}} \\leq 10^{9}$, for all $i$.\n- $0 \\leq \\mathbf{C} \\leq 10^{9}$.\n- $\\mathbf{X}_{\\mathbf{i}} \\neq 0$, for all $i$.\n- All $\\mathbf{X}_{\\mathbf{i}}$ are distinct.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\nFor at most 15 cases:\n\n- $1 \\leq \\mathbf{N} \\leq 5000$.\n\nFor the remaining cases:\n\n- $1 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 2 (20 Pts, Hidden Verdict)**\n\nFor at most 15 cases:\n\n- $1 \\leq \\mathbf{N} \\leq 10^{5}$.\n\nFor the remaining cases:\n\n- $1 \\leq \\mathbf{N} \\leq 5000$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #2] I, O Bot", "background": "", "description": "为了欢迎开发者参加在木星卫星 Io 上举办的会议，主办方充起了许多巨型沙滩球。每个球的形状大致是数字 1 或 0，因为它们看起来有点像字母 I 和 O。会议刚结束，现在需要清理这些沙滩球。幸运的是，沙滩球清理机器人 BALL-E 已经准备就绪！\n\n会议场地是一条无限延伸的水平线，0 号站点位于中央，1、2...号站点在右侧，-1、-2...号站点在左侧。0 号站点设有会议唯一的沙滩球仓库，其他每个站点最多放置一个沙滩球。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/88wnnnxw.png)\n\nBALL-E 有两个存储舱，每个只能容纳一个沙滩球。一个舱专门存放 1 形球，另一个专门存放 0 形球（1 形球比 0 形球更长，因此两种球无法互换舱室）。\n\nBALL-E 初始时两个舱都为空，且位于 0 号站点。机器人可以执行以下操作：\n\n* 向左或向右移动一个站点，消耗 1 单位能量。\n* 若当前站点有球，且 BALL-E 未存储同类型球，可将球放入对应舱室，不消耗能量。\n* 若当前站点有球，可花费 $\\mathbf{C}$ 单位能量将其形状转换（1 形变 0 形，或反之）。注意已存入舱室的球不可转换。\n* 若在 0 号站点且存有球，可将所有球存入仓库，不消耗能量且清空舱室。\n\n注意 BALL-E 移动到有球的站点时不必立即拾取，即使有空闲舱室；移动到仓库站点时也不必立即存球。\n\n请计算 BALL-E 将所有球运到仓库所需的最小能量。", "inputFormat": "第一行输入测试用例数 $\\mathbf{T}$。每个用例包含：\n- 首行两个整数 $\\mathbf{N}$（球的数量）和 $\\mathbf{C}$（转换球形的能量消耗）。\n- 随后 $\\mathbf{N}$ 行，每行两个整数 $\\mathbf{X}_{\\mathbf{i}}$（站点编号）和 $\\mathbf{S}_{\\mathbf{i}}$（球形状，0 或 1）。\n", "outputFormat": "每个用例输出一行 `Case #x: y`，其中 $x$ 为用例编号，$y$ 为最小能量消耗。\n", "hint": "**样例解释**\n\n在样例 #1（题目描述中已图示）中，$\\mathbf{N} = 5$ 个球且 $\\mathbf{C} = 0$。最优策略需要分三趟往返仓库：\n\n* **第一趟**：移动到 3 号站点，拾取那里的 0 形球存入 0 号舱，返回 0 号站点存入仓库。消耗 6 单位能量。\n* **第二趟**：移动到 8 号站点拾取 0 形球，途经 6 号站点时将其 0 形球转换为 1 形球并拾取，返回仓库存入两球。消耗 16 单位能量（注意此时转换不耗能）。\n* **第三趟**：移动到 10 号站点将其 1 形球转换为 0 形球并拾取，再到 15 号站点拾取 1 形球，返回仓库存入。消耗 30 单位能量。  \n总消耗：$6+16+30=52$ 单位能量。\n\n样例 #2 与 #1 类似，但 $\\mathbf{C} = 10$。此时需至少 56 单位能量：\n* 分三次单独收集 (3号)、(6号与10号)、(8号与15号) 的球，避免转换操作。\n\n样例 #3 中 $\\mathbf{C} = 1$，需 54 单位能量：\n* 第一趟：收集 3 号球（6 能量）\n* 第二趟：收集 8 号球，并在返回时转换并拾取 6 号球（17 能量）\n* 第三趟：对 15 号和 10 号球重复类似操作（31 能量）\n\n样例 #4 中，最优策略为：\n1. 移动到 $-10^9$ 号站点拾取 1 形球\n2. 移动到 $10^9$ 号站点拾取 0 形球\n3. 返回仓库  \n总移动距离 $4 \\times 10^9$，故消耗 4000000000 单位能量。\n\n**数据范围**\n- $1 \\leq \\mathbf{T} \\leq 100$\n- 所有坐标绝对值 $\\leq 10^9$\n- 转换能耗 $0 \\leq \\mathbf{C} \\leq 10^9$\n- 保证所有站点坐标非零且不重复\n\n**测试集 1（11 分，可见判定）**\n- 最多 15 个用例：$1 \\leq \\mathbf{N} \\leq 5000$\n- 其余用例：$1 \\leq \\mathbf{N} \\leq 100$\n\n**测试集 2（20 分，隐藏判定）**\n- 最多 15 个用例：$1 \\leq \\mathbf{N} \\leq 10^5$\n- 其余用例：$1 \\leq \\mathbf{N} \\leq 5000$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12997", "type": "P", "difficulty": 5, "samples": [["2 4 8\n1 4 3 2\n\n0\n1 4 3 2\n\n1\n2 1 4 3\n\n1", "\n\n1 2 3 2\n\n\n1 2 3 2\n\n\n4 4 4 4"]], "limits": {"time": [20000, 20000, 20000], "memory": [106496, 106496, 106496]}, "tags": ["数学", "2022", "交互题", "Special Judge", "期望", "Google Code Jam"], "title": "[GCJ 2022 #3] Revenge of GoroSort", "background": "", "description": "**In this problem, when something is said to be chosen at random, it means uniformly at random from among all valid possibilities, and independently of any other choice.**\n\nCode Jam contestants once helped the mighty Goro sort an array of integers. (You do not need to read that problem to solve this one.) Once again, Goro needs your help. He has $\\mathbf{N}$ boxes lined up on the table in a single row, numbered 1 through $\\mathbf{N}$ from left to right. Each box has exactly one ball inside. Balls are also numbered 1 through $\\mathbf{N}$. Goro wants ball $i$ to end up in box $i$, for all $i$. That is, he wants to leave the balls in sorted order. Unfortunately, that is not initially the case.\n\nWhen Goro bumps the table with his powerful fists, balls pop up in the air and fall back in boxes. Goro can do this so accurately that exactly one ball falls into each box. A ball may fall into the same box it came out of, or into a different one.\n\nBetter yet, Goro also has the ability to assign colors to boxes before each bump. Then, he can bump the table in such a way that balls coming out of a box of color $c$ always fall into a box of color $c$. As impressive as this accuracy is, Goro does not have any more control than that. Within each color, balls end up assigned to boxes at random.\n\nFor example, suppose the balls appear in the order $1, 4, 3, 6, 5, 2$ (as seen above). He might choose — not necessarily optimally — to give the first box the color red, the second and sixth boxes the color green, and the third through fifth boxes the color blue. Then, after Goro bumps the table,\n\n- The 1 in the first box falls back into the same box, because that is the only red box.\n- The 4 and 2 in the second and sixth boxes remain in place with probability $\\frac{1}{2}$, and switch places with probability $\\frac{1}{2}$.\n- The 3, 6, 5 in the third, fourth, and fifth boxes end up in one of the following orders, each with probability $\\frac{1}{6}$:\n  - $3, 6, 5$\n  - $3, 5, 6$\n  - $6, 3, 5$\n  - $6, 5, 3$\n  - $5, 3, 6$\n  - $5, 6, 3$\n\nSo, for example, the probability of the bump leaving the balls in the order $1, 2, 3, 5, 6, 4$ is $\\frac{1}{12}$. If Goro got this or some other non-sorted result, he would have to designate a set of box colors for the next round, and so on, until he eventually arrives at the sorted $1, 2, 3, 4, 5, 6$. Goro can assign colors to boxes in any way before each bump, regardless of previous assignments.\n\nCan you help Goro implement a better strategy that will efficiently sort the balls? It is guaranteed that the balls start in a random non-sorted order.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing three integers, $T$ $N$ $K$: the number of test cases, the number of boxes per test case, and the total number of bumps allowed for all test cases combined. Then, $T$ test cases must be processed.\n\nEach test case begins with the judge sending one line with $N$ integers, with each integer from 1 to $N$ appearing exactly once, and with the list chosen at random from all non-sorted lists. Then you must engage in a series of interactions with the judge. Each interaction works as follows:\n\n- You send one line of $N$ integers $C_1, C_2, \\ldots, C_N$, in which each integer is between 1 and $N$, inclusive. Each $C_i$ represents that you are assigning color $C_i$ to box $i$ for the next bump. You may choose how many colors there are and how they are numbered, but you must assign a color to each box.\n- The judge simulates the bump as explained in the statement. If this results in the balls being in sorted order:\n    - If this interaction was the $K$-th interaction across all test cases, and this was not the last test case, the judge sends one line with the integer $-1$ and does not output anything further.\n    - Otherwise, the judge sends one line with the integer 1 and then immediately begins the next test case, if there is one. If this was the last test case, your program must exit without error and without sending anything further.\n- Otherwise, the balls are not sorted, and:\n    - If this interaction was the $K$-th across all test cases, or if you provided an invalid line (e.g., too few integers, or color numbers out of range), the judge sends one line with the integer $-1$ and does not output anything further.\n    - If this was not your $K$-th interaction, the judge sends one line with the integer 0, and then another line with $N$ integers, with each integer from 1 to $N$ appearing exactly once, and in non-sorted order, representing the new order of the balls, that is, the $i$-th of these integers is the ball that fell into box $i$. Then you must begin another interaction.\n\nAs usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment. Also, if your program continues to wait for the judge after receiving a $-1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error.\n\nBe advised that the judge uses the same source of randomness each time, so in the absence of other errors (e.g. Time Limit Exceeded, Memory Limit Exceeded), submitting the exact same code twice will yield the same outcome twice.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nNote that the sample interaction does not satisfy the constraints of any of the test sets. It is only presented to clarify the input and output format.\n\n**Limits**\n\n- $\\mathbf{T} = 1000$.\n- $\\mathbf{N} = 100$.\n\n**Test Set 1 (8 Pts, Visible Verdict)**\n\n- $\\mathbf{K} = 16500$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $\\mathbf{K} = 12500$.\n\n**Test Set 3 (3 Pts, Visible Verdict)**\n\n- $\\mathbf{K} = 11500$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #3] Revenge of GoroSort", "background": "", "description": "**In this problem, when something is said to be chosen at random, it means uniformly at random from among all valid possibilities, and independently of any other choice.**\n\nCode Jam contestants once helped the mighty Goro sort an array of integers. (You do not need to read that problem to solve this one.) Once again, Goro needs your help. He has $\\mathbf{N}$ boxes lined up on the table in a single row, numbered 1 through $\\mathbf{N}$ from left to right. Each box has exactly one ball inside. Balls are also numbered 1 through $\\mathbf{N}$. Goro wants ball $i$ to end up in box $i$, for all $i$. That is, he wants to leave the balls in sorted order. Unfortunately, that is not initially the case.\n\nWhen Goro bumps the table with his powerful fists, balls pop up in the air and fall back in boxes. Goro can do this so accurately that exactly one ball falls into each box. A ball may fall into the same box it came out of, or into a different one.\n\nBetter yet, Goro also has the ability to assign colors to boxes before each bump. Then, he can bump the table in such a way that balls coming out of a box of color $c$ always fall into a box of color $c$. As impressive as this accuracy is, Goro does not have any more control than that. Within each color, balls end up assigned to boxes at random.\n\nFor example, suppose the balls appear in the order $1, 4, 3, 6, 5, 2$ (as seen above). He might choose — not necessarily optimally — to give the first box the color red, the second and sixth boxes the color green, and the third through fifth boxes the color blue. Then, after Goro bumps the table,\n\n- The 1 in the first box falls back into the same box, because that is the only red box.\n- The 4 and 2 in the second and sixth boxes remain in place with probability $\\frac{1}{2}$, and switch places with probability $\\frac{1}{2}$.\n- The 3, 6, 5 in the third, fourth, and fifth boxes end up in one of the following orders, each with probability $\\frac{1}{6}$:\n  - $3, 6, 5$\n  - $3, 5, 6$\n  - $6, 3, 5$\n  - $6, 5, 3$\n  - $5, 3, 6$\n  - $5, 6, 3$\n\nSo, for example, the probability of the bump leaving the balls in the order $1, 2, 3, 5, 6, 4$ is $\\frac{1}{12}$. If Goro got this or some other non-sorted result, he would have to designate a set of box colors for the next round, and so on, until he eventually arrives at the sorted $1, 2, 3, 4, 5, 6$. Goro can assign colors to boxes in any way before each bump, regardless of previous assignments.\n\nCan you help Goro implement a better strategy that will efficiently sort the balls? It is guaranteed that the balls start in a random non-sorted order.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing three integers, $T$ $N$ $K$: the number of test cases, the number of boxes per test case, and the total number of bumps allowed for all test cases combined. Then, $T$ test cases must be processed.\n\nEach test case begins with the judge sending one line with $N$ integers, with each integer from 1 to $N$ appearing exactly once, and with the list chosen at random from all non-sorted lists. Then you must engage in a series of interactions with the judge. Each interaction works as follows:\n\n- You send one line of $N$ integers $C_1, C_2, \\ldots, C_N$, in which each integer is between 1 and $N$, inclusive. Each $C_i$ represents that you are assigning color $C_i$ to box $i$ for the next bump. You may choose how many colors there are and how they are numbered, but you must assign a color to each box.\n- The judge simulates the bump as explained in the statement. If this results in the balls being in sorted order:\n    - If this interaction was the $K$-th interaction across all test cases, and this was not the last test case, the judge sends one line with the integer $-1$ and does not output anything further.\n    - Otherwise, the judge sends one line with the integer 1 and then immediately begins the next test case, if there is one. If this was the last test case, your program must exit without error and without sending anything further.\n- Otherwise, the balls are not sorted, and:\n    - If this interaction was the $K$-th across all test cases, or if you provided an invalid line (e.g., too few integers, or color numbers out of range), the judge sends one line with the integer $-1$ and does not output anything further.\n    - If this was not your $K$-th interaction, the judge sends one line with the integer 0, and then another line with $N$ integers, with each integer from 1 to $N$ appearing exactly once, and in non-sorted order, representing the new order of the balls, that is, the $i$-th of these integers is the ball that fell into box $i$. Then you must begin another interaction.\n\nAs usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment. Also, if your program continues to wait for the judge after receiving a $-1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error.\n\nBe advised that the judge uses the same source of randomness each time, so in the absence of other errors (e.g. Time Limit Exceeded, Memory Limit Exceeded), submitting the exact same code twice will yield the same outcome twice.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nNote that the sample interaction does not satisfy the constraints of any of the test sets. It is only presented to clarify the input and output format.\n\n**Limits**\n\n- $\\mathbf{T} = 1000$.\n- $\\mathbf{N} = 100$.\n\n**Test Set 1 (8 Pts, Visible Verdict)**\n\n- $\\mathbf{K} = 16500$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $\\mathbf{K} = 12500$.\n\n**Test Set 3 (3 Pts, Visible Verdict)**\n\n- $\\mathbf{K} = 11500$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #3] Revenge of GoroSort", "background": "", "description": "**在本问题中，当提到“随机选择”时，均指从所有有效可能性中均匀随机且独立地选择。**\n\nCode Jam 的参赛者曾帮助强大的 Goro 对一个整数数组进行排序（无需阅读该问题即可解决本题）。现在，Goro 再次需要你的帮助。他有 $\\mathbf{N}$ 个盒子排成一行放在桌子上，从左到右编号为 1 到 $\\mathbf{N}$。每个盒子中恰好有一个球。球的编号也是 1 到 $\\mathbf{N}$。Goro 希望球 $i$ 最终位于盒子 $i$ 中，即他希望将球按顺序排列。然而，初始状态并非如此。\n\n当 Goro 用他强壮的拳头敲击桌子时，球会弹到空中并落回盒子中。Goro 可以精确控制，使得每个盒子恰好落回一个球。球可能落回原来的盒子，也可能落入其他盒子。\n\n更厉害的是，Goro 还能在每次敲击前为盒子分配颜色。然后，他可以以某种方式敲击桌子，使得从颜色为 $c$ 的盒子中弹出的球总是落入颜色为 $c$ 的盒子中。尽管这种控制力令人印象深刻，但 Goro 无法进一步干预——在每个颜色组内，球的分配是完全随机的。\n\n例如，假设球的初始顺序为 $1, 4, 3, 6, 5, 2$（如上所述）。他可能会选择（不一定最优）将第一个盒子设为红色，第二个和第六个盒子设为绿色，第三到第五个盒子设为蓝色。敲击桌子后：\n\n- 第一个盒子中的 1 会落回原盒子，因为这是唯一的红色盒子。\n- 第二个和第六个盒子中的 4 和 2 有 $\\frac{1}{2}$ 的概率保持原位，也有 $\\frac{1}{2}$ 的概率交换位置。\n- 第三、四、五个盒子中的 3、6、5 会以 $\\frac{1}{6}$ 的概率变为以下任意一种顺序：\n  - $3, 6, 5$\n  - $3, 5, 6$\n  - $6, 3, 5$\n  - $6, 5, 3$\n  - $5, 3, 6$\n  - $5, 6, 3$\n\n因此，例如，敲击后球变为 $1, 2, 3, 5, 6, 4$ 的概率是 $\\frac{1}{12}$。如果 Goro 得到这个或其他非排序结果，他需要为下一轮重新分配盒子颜色，直到最终达到排序状态 $1, 2, 3, 4, 5, 6$。Goro 可以在每次敲击前以任意方式分配颜色，不受之前分配的影响。\n\n你能帮助 Goro 实现一种更高效的策略来排序球吗？题目保证球的初始顺序是随机且非排序的。\n\n### 交互协议\n\n这是一个交互式问题。\n\n最初，你的程序应读取一行，包含三个整数 $T$、$N$、$K$：测试用例的数量、每个测试用例的盒子数量以及所有测试用例允许的总敲击次数。然后，需要处理 $T$ 个测试用例。\n\n每个测试用例开始时，评测机会发送一行 $N$ 个整数，每个整数从 1 到 $N$ 恰好出现一次，且列表是从所有非排序列表中随机选择的。之后，你需要与评测机进行一系列交互。每次交互如下：\n\n- 你发送一行 $N$ 个整数 $C_1, C_2, \\ldots, C_N$，每个整数在 1 到 $N$ 之间（含）。$C_i$ 表示你将颜色 $C_i$ 分配给盒子 $i$ 用于下一次敲击。你可以选择颜色的数量和编号方式，但必须为每个盒子分配一个颜色。\n- 评测机模拟敲击过程（如题目描述）。如果敲击后球已排序：\n  - 如果这是所有测试用例中的第 $K$ 次交互，且不是最后一个测试用例，评测机会发送一行整数 $-1$ 并停止输出。\n  - 否则，评测机会发送一行整数 1，并立即开始下一个测试用例（如果有）。如果是最后一个测试用例，你的程序必须无错误退出且不再发送任何内容。\n- 如果球未排序：\n  - 如果这是所有测试用例中的第 $K$ 次交互，或你提供了无效输入（如整数不足、颜色编号越界），评测机会发送一行整数 $-1$ 并停止输出。\n  - 否则，评测机会发送一行整数 0，接着另一行 $N$ 个整数（每个 1 到 $N$ 恰好出现一次且非排序），表示球的新顺序（第 $i$ 个整数是落入盒子 $i$ 的球）。然后你需要开始下一次交互。\n\n通常，如果内存超限或程序运行时错误，你将收到相应的判题结果。此外，如果在收到 $-1$ 后程序仍在等待评测机，将因超时被判为 Time Limit Exceeded。注意，你有责任及时退出程序以避免超时错误。\n\n请注意，评测机每次使用相同的随机源，因此在没有其他错误（如超时、内存超限）的情况下，提交完全相同的代码两次将得到相同的结果。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "**样例解释**\n\n注意，样例交互不满足任何测试集的约束，仅用于说明输入输出格式。\n\n**限制**\n\n- $\\mathbf{T} = 1000$。\n- $\\mathbf{N} = 100$。\n\n**测试集 1（8 分，可见判题结果）**\n\n- $\\mathbf{K} = 16500$。\n\n**测试集 2（10 分，可见判题结果）**\n\n- $\\mathbf{K} = 12500$。\n\n**测试集 3（3 分，可见判题结果）**\n\n- $\\mathbf{K} = 11500$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12998", "type": "P", "difficulty": 5, "samples": [["3\n3 2\n1 1\n1 1\n1 1 2\n5 2\n1 1\n1 2\n1 2 1 2 2\n3 3\n1 2\n1 2\n2 2\n1 1 3", "Case #1: 2\nCase #2: 9\nCase #3: 1"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["线段树", "2022", "Google Code Jam"], "title": "[GCJ 2022 #3] Duck, Duck, Geese", "background": "", "description": "In the game \"Duck, Duck, Goose\", all players but one sit on the floor and form a circle. The remaining player walks around the circle calling each player \"duck\" until they select one sitting player and, while touching their head, call them \"goose\" instead. At that point, the goose chases the selecting player and our interest in the game fades.\n\nIn the new game \"Duck, Duck, Geese\", the walking player instead chooses a contiguous subset of at least two (but not all) sitting players to be \"geese\"! Furthermore, each sitting player is wearing a hat. Each hat is one of $\\mathbf{C}$ possible colors, numbered 1 through $\\mathbf{C}$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0d1hucqa.png)\n\nFor each color $i$, the quantity of selected geese wearing a hat of color $i$ must be either 0 or between $\\mathbf{A}_i$ and $\\mathbf{B}_i$, inclusive.\n\nCan you help count the number of choices that fulfill these requirements? Two choices are considered different if there is some player that is included in one choice but not the other.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{N}$ and $\\mathbf{C}$: the number of sitting players and hat colors, respectively. Then, $\\mathbf{C}$ lines follow. The $i$-th of these lines contains two integers $\\mathbf{A}_i$ and $\\mathbf{B}_i$, as explained above. The last line of a test case contains $\\mathbf{N}$ integers $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots, \\mathbf{P}_\\mathbf{N}$ representing that the $j$-th sitting player in clockwise order (starting from an arbitrary one) is wearing a hat of color $\\mathbf{P}_j$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of sets of at least 2 and at most $\\mathbf{N} - 1$ contiguously sitting players that fulfill all the color requirements.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the total number of players chosen as geese must be 2. There are only three possible ways to select 2 players. The following color configurations are possible: $[1, 1]$, $[1, 2]$, and $[2, 1]$. The first one has two players wearing hats of color 1, so it is not valid, but the other two are valid. Therefore the answer is 2.\n\nSample Case #2 is the one illustrated in the statement, with color 1 being yellow and color 2 being blue. The total number of players chosen as geese in this case must be between 2 and 3, because selecting 4 geese would require at least one color to be out of bounds. For cases with 2 geese, the only requirement is that we do not select 2 geese both wearing hats of color 1; all 5 such selections are valid. If choosing 3 geese, the options are $[1, 2, 1]$, $[2, 1, 2]$, $[1, 2, 2]$, $[2, 2, 1]$, or $[2, 1, 2]$. All but the first one are valid, adding another 4 valid options, for a total of 9.\n\nIn Sample Case #3, notice that there can be hat colors that nobody is wearing. In this case, since there is only 1 player wearing hat color 3 and 1 is not in range, the only valid way is to pick 0 players wearing that hat color.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{C} \\leq \\mathbf{N}$.\n- $0 \\leq \\mathbf{A}_i \\leq \\mathbf{B}_i \\leq \\mathbf{N}$, for all $i$.\n- $1 \\leq \\mathbf{P}_j \\leq \\mathbf{C}$, for all $j$.\n\n**Test Set 1 (12 Pts, Visible Verdict)**\n\n- $3 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 2 (13 Pts, Hidden Verdict)**\n\n- $3 \\leq \\mathbf{N} \\leq 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #3] Duck, Duck, Geese", "background": "", "description": "In the game \"Duck, Duck, Goose\", all players but one sit on the floor and form a circle. The remaining player walks around the circle calling each player \"duck\" until they select one sitting player and, while touching their head, call them \"goose\" instead. At that point, the goose chases the selecting player and our interest in the game fades.\n\nIn the new game \"Duck, Duck, Geese\", the walking player instead chooses a contiguous subset of at least two (but not all) sitting players to be \"geese\"! Furthermore, each sitting player is wearing a hat. Each hat is one of $\\mathbf{C}$ possible colors, numbered 1 through $\\mathbf{C}$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0d1hucqa.png)\n\nFor each color $i$, the quantity of selected geese wearing a hat of color $i$ must be either 0 or between $\\mathbf{A}_i$ and $\\mathbf{B}_i$, inclusive.\n\nCan you help count the number of choices that fulfill these requirements? Two choices are considered different if there is some player that is included in one choice but not the other.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{N}$ and $\\mathbf{C}$: the number of sitting players and hat colors, respectively. Then, $\\mathbf{C}$ lines follow. The $i$-th of these lines contains two integers $\\mathbf{A}_i$ and $\\mathbf{B}_i$, as explained above. The last line of a test case contains $\\mathbf{N}$ integers $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots, \\mathbf{P}_\\mathbf{N}$ representing that the $j$-th sitting player in clockwise order (starting from an arbitrary one) is wearing a hat of color $\\mathbf{P}_j$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of sets of at least 2 and at most $\\mathbf{N} - 1$ contiguously sitting players that fulfill all the color requirements.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the total number of players chosen as geese must be 2. There are only three possible ways to select 2 players. The following color configurations are possible: $[1, 1]$, $[1, 2]$, and $[2, 1]$. The first one has two players wearing hats of color 1, so it is not valid, but the other two are valid. Therefore the answer is 2.\n\nSample Case #2 is the one illustrated in the statement, with color 1 being yellow and color 2 being blue. The total number of players chosen as geese in this case must be between 2 and 3, because selecting 4 geese would require at least one color to be out of bounds. For cases with 2 geese, the only requirement is that we do not select 2 geese both wearing hats of color 1; all 5 such selections are valid. If choosing 3 geese, the options are $[1, 2, 1]$, $[2, 1, 2]$, $[1, 2, 2]$, $[2, 2, 1]$, or $[2, 1, 2]$. All but the first one are valid, adding another 4 valid options, for a total of 9.\n\nIn Sample Case #3, notice that there can be hat colors that nobody is wearing. In this case, since there is only 1 player wearing hat color 3 and 1 is not in range, the only valid way is to pick 0 players wearing that hat color.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{C} \\leq \\mathbf{N}$.\n- $0 \\leq \\mathbf{A}_i \\leq \\mathbf{B}_i \\leq \\mathbf{N}$, for all $i$.\n- $1 \\leq \\mathbf{P}_j \\leq \\mathbf{C}$, for all $j$.\n\n**Test Set 1 (12 Pts, Visible Verdict)**\n\n- $3 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 2 (13 Pts, Hidden Verdict)**\n\n- $3 \\leq \\mathbf{N} \\leq 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #3] Duck, Duck, Geese", "background": "", "description": "在游戏 \"Duck, Duck, Goose\" 中，除一名玩家外，其余玩家坐在地板上围成一个圈。剩下的玩家绕着圈走，依次称呼每个坐着的玩家为 \"duck\"，直到他们选择一名坐着的玩家，轻拍其头部并称其为 \"goose\"。此时，\"goose\" 会追逐选择者，而我们对游戏的兴趣就此消失。\n\n在新游戏 \"Duck, Duck, Geese\" 中，行走的玩家改为选择一个连续的、至少包含两名（但非全部）坐着的玩家作为 \"geese\"！此外，每名坐着的玩家都戴着一顶帽子。每顶帽子是 $\\mathbf{C}$ 种可能颜色中的一种，编号为 1 到 $\\mathbf{C}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0d1hucqa.png)\n\n对于每种颜色 $i$，被选为 \"geese\" 的玩家中戴颜色 $i$ 帽子的数量必须为 0，或在 $\\mathbf{A}_i$ 和 $\\mathbf{B}_i$ 之间（含端点）。\n\n你能帮忙计算满足这些要求的选择数量吗？如果某个玩家在一个选择中被包含而在另一个选择中未被包含，则这两个选择被视为不同。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{C}$：分别表示坐着的玩家数量和帽子颜色数量。接下来是 $\\mathbf{C}$ 行，第 $i$ 行包含两个整数 $\\mathbf{A}_i$ 和 $\\mathbf{B}_i$，如上所述。每个测试用例的最后一行包含 $\\mathbf{N}$ 个整数 $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots, \\mathbf{P}_\\mathbf{N}$，表示按顺时针方向（从任意一个玩家开始）的第 $j$ 名坐着的玩家戴的帽子颜色为 $\\mathbf{P}_j$。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是满足所有颜色要求的、连续坐着的玩家集合的数量（集合大小至少为 2，最多为 $\\mathbf{N} - 1$）。\n", "hint": "**样例解释**\n\n在样例 #1 中，被选为 \"geese\" 的玩家总数必须为 2。只有三种选择 2 名玩家的方式。可能的帽子颜色配置为：$[1, 1]$、$[1, 2]$ 和 $[2, 1]$。第一种有两名玩家戴颜色 1 的帽子，因此无效，但后两种有效。因此答案为 2。\n\n样例 #2 是题目描述中图示的情况，颜色 1 为黄色，颜色 2 为蓝色。此时被选为 \"geese\" 的玩家总数必须在 2 到 3 之间，因为选择 4 名 \"geese\" 会导致至少一种颜色超出范围。对于选择 2 名 \"geese\" 的情况，唯一的要求是不能选择两名都戴颜色 1 帽子的玩家；所有 5 种此类选择均有效。如果选择 3 名 \"geese\"，选项为 $[1, 2, 1]$、$[2, 1, 2]$、$[1, 2, 2]$、$[2, 2, 1]$ 或 $[2, 1, 2]$。除第一种外，其余均有效，因此又增加了 4 种有效选项，总计 9 种。\n\n在样例 #3 中，注意可能存在无人佩戴的帽子颜色。由于只有一名玩家戴颜色 3 的帽子，而 1 不在范围内，因此唯一有效的方式是选择 0 名戴该颜色帽子的玩家。\n\n**限制**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{C} \\leq \\mathbf{N}$。\n- 对于所有 $i$，$0 \\leq \\mathbf{A}_i \\leq \\mathbf{B}_i \\leq \\mathbf{N}$。\n- 对于所有 $j$，$1 \\leq \\mathbf{P}_j \\leq \\mathbf{C}$。\n\n**测试集 1（12 分，可见判题结果）**\n\n- $3 \\leq \\mathbf{N} \\leq 1000$。\n\n**测试集 2（13 分，隐藏判题结果）**\n\n- $3 \\leq \\mathbf{N} \\leq 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12999", "type": "P", "difficulty": 5, "samples": [["4\n3\n2 1 1\n3 3 2\n6\n3 1 4 1 2 3\n5 3 5 2 4 5\n20\n2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 1 1\n3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 20 2\n19\n2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 1 1\n3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 19 3", "Case #1: IMPOSSIBLE\nCase #2: TSHIRT\nCase #3: HCJKSHCJKSHCJKSHCJKS\nCase #4: CODEJAMROCKSTHEMOST"]], "limits": {"time": [20000, 20000, 45000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "2022", "Special Judge", "拓扑排序", "Google Code Jam"], "title": "[GCJ 2022 #3] Mascot Maze", "background": "", "description": "The Google Coding Competitions team is setting up a new theme park. As in any good theme park, we want to have actors dressed up as mascots to interact with visitors. Because we are in a rush to open, we decided to use the letters from CODE JAM, KICK START, and HASH CODE as mascots, for a total of 13 different mascots (the letters `ACDEHIJKMORST`).\n\nThe park's only attraction is a maze that has a set of $\\mathbf{N}$ rooms numbered from 1 to $\\mathbf{N}$. Each room has a left exit and a right exit. Each exit takes the visitor to another room. Exits cannot be used in reverse; for example, if room 2 has an exit to room 3, you cannot go back from room 3 to room 2 unless room 3 also happens to have an exit to room 2.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8fuhdtgj.png)\n\nWe want to place exactly one of our 13 mascots in each room. Each letter may be present in zero, one, or more rooms of the maze. To increase variety, we want to place mascots so that any three (not necessarily distinct) rooms that a visitor can visit consecutively have three different mascots.\n\nCan you help us choose a mascot for each room such that this goal is met, or let us know that it cannot be done?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 3 lines. The first line contains a single integer $\\mathbf{N}$, representing the number of rooms in the maze. The second line contains $\\mathbf{N}$ integers $\\mathbf{L}_1, \\mathbf{L}_2, \\ldots, \\mathbf{L}_\\mathbf{N}$, representing that the left exit from room $i$ leads to room $\\mathbf{L}_i$. The third and last line contains $\\mathbf{N}$ integers $\\mathbf{R}_1, \\mathbf{R}_2, \\ldots, \\mathbf{R}_\\mathbf{N}$, representing that the right exit from room $i$ leads to room $\\mathbf{R}_i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `IMPOSSIBLE` if there is no way to assign mascots while obeying the rules explained above. Otherwise, $y$ is an $\\mathbf{N}$ character long string. The $i$-th character of $y$ should be an uppercase letter from the set `ACDEHIJKMORST`, representing that you wish to assign that mascot to the $i$-th room.", "hint": "**Sample Explanation**\n\nSample Case #1 is the image in the problem statement. It is possible to visit rooms 1, 2, and 1 consecutively (which visits room 1 twice), so the case is impossible.\n\nSample Case #2 has the following layout (blue arrows represent the left exits and red arrows represent the right exits):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ykiviiry.png)\n\nOne of many valid answers is to assign mascots as indicated. Notice that although we do not need to assign two $\\tau$ mascots in this case, we have done so in a way that does not break the rules.\n\nSample Cases #3 and #4 are possible, but require the use of multiple copies of some mascots.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{L}_i \\neq i$, for all $i$. $\\mathbf{R}_i \\neq i$, for all $i$. $1 \\leq \\mathbf{L}_i < \\mathbf{R}_i \\leq \\mathbf{N}$, for all $i$.\n\n**Test Set 1 (12 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $3 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 2 (13 Pts, Hidden Verdict)**\n\n- Time limit: 45 seconds.\n- $3 \\leq \\mathbf{N} \\leq 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #3] Mascot Maze", "background": "", "description": "The Google Coding Competitions team is setting up a new theme park. As in any good theme park, we want to have actors dressed up as mascots to interact with visitors. Because we are in a rush to open, we decided to use the letters from CODE JAM, KICK START, and HASH CODE as mascots, for a total of 13 different mascots (the letters `ACDEHIJKMORST`).\n\nThe park's only attraction is a maze that has a set of $\\mathbf{N}$ rooms numbered from 1 to $\\mathbf{N}$. Each room has a left exit and a right exit. Each exit takes the visitor to another room. Exits cannot be used in reverse; for example, if room 2 has an exit to room 3, you cannot go back from room 3 to room 2 unless room 3 also happens to have an exit to room 2.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8fuhdtgj.png)\n\nWe want to place exactly one of our 13 mascots in each room. Each letter may be present in zero, one, or more rooms of the maze. To increase variety, we want to place mascots so that any three (not necessarily distinct) rooms that a visitor can visit consecutively have three different mascots.\n\nCan you help us choose a mascot for each room such that this goal is met, or let us know that it cannot be done?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 3 lines. The first line contains a single integer $\\mathbf{N}$, representing the number of rooms in the maze. The second line contains $\\mathbf{N}$ integers $\\mathbf{L}_1, \\mathbf{L}_2, \\ldots, \\mathbf{L}_\\mathbf{N}$, representing that the left exit from room $i$ leads to room $\\mathbf{L}_i$. The third and last line contains $\\mathbf{N}$ integers $\\mathbf{R}_1, \\mathbf{R}_2, \\ldots, \\mathbf{R}_\\mathbf{N}$, representing that the right exit from room $i$ leads to room $\\mathbf{R}_i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `IMPOSSIBLE` if there is no way to assign mascots while obeying the rules explained above. Otherwise, $y$ is an $\\mathbf{N}$ character long string. The $i$-th character of $y$ should be an uppercase letter from the set `ACDEHIJKMORST`, representing that you wish to assign that mascot to the $i$-th room.", "hint": "**Sample Explanation**\n\nSample Case #1 is the image in the problem statement. It is possible to visit rooms 1, 2, and 1 consecutively (which visits room 1 twice), so the case is impossible.\n\nSample Case #2 has the following layout (blue arrows represent the left exits and red arrows represent the right exits):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ykiviiry.png)\n\nOne of many valid answers is to assign mascots as indicated. Notice that although we do not need to assign two $\\tau$ mascots in this case, we have done so in a way that does not break the rules.\n\nSample Cases #3 and #4 are possible, but require the use of multiple copies of some mascots.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{L}_i \\neq i$, for all $i$. $\\mathbf{R}_i \\neq i$, for all $i$. $1 \\leq \\mathbf{L}_i < \\mathbf{R}_i \\leq \\mathbf{N}$, for all $i$.\n\n**Test Set 1 (12 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $3 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 2 (13 Pts, Hidden Verdict)**\n\n- Time limit: 45 seconds.\n- $3 \\leq \\mathbf{N} \\leq 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #3] Mascot Maze", "background": "", "description": "Google 编程竞赛团队正在筹建一个新的主题公园。和所有优秀的主题公园一样，我们希望让演员装扮成吉祥物与游客互动。由于开业在即，我们决定使用 CODE JAM、KICK START 和 HASH CODE 中的字母作为吉祥物，共计 13 种不同的吉祥物（字母 `ACDEHIJKMORST`）。\n\n公园唯一的景点是一个由 $\\mathbf{N}$ 个房间组成的迷宫，房间编号从 1 到 $\\mathbf{N}$。每个房间都有一个左出口和一个右出口。每个出口会将游客带到另一个房间。出口不能反向使用；例如，如果房间 2 有一个出口通向房间 3，你不能从房间 3 返回到房间 2，除非房间 3 恰好也有一个出口通向房间 2。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8fuhdtgj.png)\n\n我们希望在每个房间放置恰好一个这 13 种吉祥物。每个字母可以在迷宫的零个、一个或多个房间中出现。为了增加多样性，我们希望这样放置吉祥物：游客连续访问的任意三个（不一定不同）房间中的吉祥物必须互不相同。\n\n你能帮助我们为每个房间选择一个吉祥物来满足这一目标吗？或者告诉我们这是不可能实现的？\n", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含 3 行。第一行是一个整数 $\\mathbf{N}$，表示迷宫中的房间数量。第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{L}_1, \\mathbf{L}_2, \\ldots, \\mathbf{L}_\\mathbf{N}$，表示房间 $i$ 的左出口通向房间 $\\mathbf{L}_i$。第三行包含 $\\mathbf{N}$ 个整数 $\\mathbf{R}_1, \\mathbf{R}_2, \\ldots, \\mathbf{R}_\\mathbf{N}$，表示房间 $i$ 的右出口通向房间 $\\mathbf{R}_i$。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 `IMPOSSIBLE`（如果无法按照上述规则分配吉祥物）。否则，$y$ 是一个长度为 $\\mathbf{N}$ 的字符串，其第 $i$ 个字符是大写字母 `ACDEHIJKMORST` 中的一个，表示你希望分配给第 $i$ 个房间的吉祥物。\n", "hint": "**样例解释**\n\n样例 #1 对应题目描述中的图片。游客可以连续访问房间 1、2、1（其中房间 1 被访问两次），因此这种情况不可能满足要求。\n\n样例 #2 的布局如下（蓝色箭头表示左出口，红色箭头表示右出口）：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ykiviiry.png)\n\n众多有效解之一如输出所示。注意虽然我们不需要分配两个 $\\tau$ 吉祥物，但当前的分配方式不会违反规则。\n\n样例 #3 和 #4 是可行的，但需要重复使用某些吉祥物。\n\n**限制**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i$，$\\mathbf{L}_i \\neq i$ 且 $\\mathbf{R}_i \\neq i$。\n- 对于所有 $i$，$1 \\leq \\mathbf{L}_i < \\mathbf{R}_i \\leq \\mathbf{N}$。\n\n**测试集 1（12 分，可见判题结果）**\n\n- 时间限制：20 秒。\n- $3 \\leq \\mathbf{N} \\leq 100$。\n\n**测试集 2（13 分，隐藏判题结果）**\n\n- 时间限制：45 秒。\n- $3 \\leq \\mathbf{N} \\leq 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13000", "type": "P", "difficulty": 7, "samples": [["2\n3\n\n\n\n1\n1\n3\n\n\n4\n\n\n\n2\n3\n2 1 3\n\n\n2\n2 3\n\n\n-1", "\n\n\n1 2\n1 3\n\n\n\n2\n1 2\n\n1 2\n2 3\n2 4\n\n\n\n1\n4\n\n\n1\n1"]], "limits": {"time": [60000, 60000], "memory": [1048576, 1048576]}, "tags": ["模拟", "博弈论", "2022", "交互题", "Special Judge", "构造", "分类讨论", "SG 函数", "Google Code Jam"], "title": "[GCJ 2022 #3] Win As Second\t", "background": "", "description": "Ueli and Vreni are playing a game. The game's board is a tree with $\\mathbf{N}$ vertices, all initially colored blue. They alternate turns, with Ueli going first. In each turn, a player must choose a blue vertex, together with any subset (possibly none or all) of its blue neighbors, and color all those vertices red. If at the start of a players' turn, all vertices are red, then that player loses the game and the other player wins the game.\n\nIn the example game below, Ueli colored vertex 3 red in their first turn. Then, Vreni chose vertex 2 for their turn and colored both it and its neighbor (vertex 1) red. Because all vertices are now red, Ueli loses and Vreni wins.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xw0xc7is.png)\n\nUeli and Vreni have noticed that it is much easier for Ueli to win this game because he has the first turn. Therefore they have adopted the following procedure: first, Ueli chooses an integer $\\mathbf{N}$. Then, Vreni chooses any tree with $\\mathbf{N}$ vertices. And then they start playing as described above, with Ueli taking the first turn.\n\nVreni is hopeful that being able to choose the tree can help her overcome the disadvantage of going second. Can you demonstrate how Vreni can win games in this setup?\n\n### Interactive Protocol\n\nThis is an interactive problem. You should make sure you have read the information in the Interactive Problems section of our FAQ.\n\nInitially, your program should read a single line containing an integer, $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nFor each test case, your program must first read a line containing a single integer $\\mathbf{N}$, the number of vertices that Ueli has chosen. Then, your program must output $\\mathbf{N}-1$ lines describing the edges of the tree Vreni should choose. The nodes of the tree are numbered 1 through $\\mathbf{N}$. Each line must represent a distinct edge of the tree with 2 integers between 1 and $\\mathbf{N}$: the two vertices the edge connects. The edges must represent a tree. The two integers within a line may be in either order, and the $\\mathbf{N}-1$ lines themselves may be in any order.\n\nAfter that, your program must read a line containing a single integer $\\mathbf{M}$, the number of games that you need to play on this tree. These games are played independently; in other words, all vertices of the tree are blue at the start of each game.\n\nFor each of the $\\mathbf{M}$ games, you need to process some number of exchanges until the game is over. Each exchange consists of a turn from each player.\n\nFor each exchange, your program must read two lines describing Ueli's turn first. The first of those lines will contain an integer $\\mathbf{K}$, denoting the number of blue vertices to be colored red. The second of those lines will contain $\\mathbf{K}$ distinct integers $\\mathbf{A}_1, \\mathbf{A}_2, \\ldots, \\mathbf{A}_\\mathbf{K}$ describing the blue vertices to be colored red. $\\mathbf{K}$ will be at least 1, and each $\\mathbf{A}_i$ will be between 1 and $\\mathbf{N}$, inclusive. Vertices $\\mathbf{A}_2, \\mathbf{A}_3, \\ldots, \\mathbf{A}_\\mathbf{K}$ will all be neighbors of vertex $\\mathbf{A}_1$.\n\nAfter that, your program must output Vreni's choice for their turn in the same format: the first line with the number of blue vertices to be colored red, followed by the second line with the numbers of those vertices, in such an order that all vertices except the first one are neighbors of the first one.\n\nIf all vertices are red after Vreni's turn, it means that Vreni has won and this game is over. The next game starts immediately if there is one. If this was the last game for this test case, then the next test case starts immediately if there is one. If this was the last test case, the judge will send no further input to your program, and the program must send no further output.\n\nOn the other hand, if all vertices are red after Ueli's move, it means that Vreni has lost and therefore your program did not pass the test case. In this case, instead of starting a new exchange by printing the last move that colors all remaining blue vertices red, the judge will print a single number -1 and will not print any further output, and will not process any further games or test cases.\n\nIf the judge receives an invalidly formatted or invalid line (like outputting an unexpected number of integers, or integers out of range, or outputting a set of edges that do not form a tree, or trying to color a vertex that is already red, or trying to color a vertex that is not a neighbor of the first vertex colored in this turn) from your program at any moment, the judge will also print a single number -1 and will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n\nThe judge is deterministic. In other words, if you make two attempts that print the same numbers, you will get the same inputs from the judge. However, of course the judge can make different moves in different games on the same tree.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "Note that the sample interaction does not satisfy the constraints of either test set, as its $\\mathbf{N}$ values are too small. It is only presented to clarify the input and output format.\n\nBelow is an illustration of Case #2, Game #1 at the beginning and after each turn:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cccz3vlj.png)\n\nBelow is an illustration of Case #2, Game #2 at the beginning and after each turn:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0b2qkj8q.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{M} \\leq 50.$\n\n**Test Set 1 (13 Pts, Visible Verdict)**\n\n- $\\mathbf{T}=1$.\n- $\\mathbf{N}=30$.\n\n**Test Set 2 (Hidden Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 10.$\n- $31 \\leq \\mathbf{N} \\leq 40.$\n- No two test cases use the same value of $\\mathbf{N}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 #3] Win As Second\t", "background": "", "description": "Ueli and Vreni are playing a game. The game's board is a tree with $\\mathbf{N}$ vertices, all initially colored blue. They alternate turns, with Ueli going first. In each turn, a player must choose a blue vertex, together with any subset (possibly none or all) of its blue neighbors, and color all those vertices red. If at the start of a players' turn, all vertices are red, then that player loses the game and the other player wins the game.\n\nIn the example game below, Ueli colored vertex 3 red in their first turn. Then, Vreni chose vertex 2 for their turn and colored both it and its neighbor (vertex 1) red. Because all vertices are now red, Ueli loses and Vreni wins.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xw0xc7is.png)\n\nUeli and Vreni have noticed that it is much easier for Ueli to win this game because he has the first turn. Therefore they have adopted the following procedure: first, Ueli chooses an integer $\\mathbf{N}$. Then, Vreni chooses any tree with $\\mathbf{N}$ vertices. And then they start playing as described above, with Ueli taking the first turn.\n\nVreni is hopeful that being able to choose the tree can help her overcome the disadvantage of going second. Can you demonstrate how Vreni can win games in this setup?\n\n### Interactive Protocol\n\nThis is an interactive problem. You should make sure you have read the information in the Interactive Problems section of our FAQ.\n\nInitially, your program should read a single line containing an integer, $\\mathbf{T}$, the number of test cases. Then, $\\mathbf{T}$ test cases must be processed.\n\nFor each test case, your program must first read a line containing a single integer $\\mathbf{N}$, the number of vertices that Ueli has chosen. Then, your program must output $\\mathbf{N}-1$ lines describing the edges of the tree Vreni should choose. The nodes of the tree are numbered 1 through $\\mathbf{N}$. Each line must represent a distinct edge of the tree with 2 integers between 1 and $\\mathbf{N}$: the two vertices the edge connects. The edges must represent a tree. The two integers within a line may be in either order, and the $\\mathbf{N}-1$ lines themselves may be in any order.\n\nAfter that, your program must read a line containing a single integer $\\mathbf{M}$, the number of games that you need to play on this tree. These games are played independently; in other words, all vertices of the tree are blue at the start of each game.\n\nFor each of the $\\mathbf{M}$ games, you need to process some number of exchanges until the game is over. Each exchange consists of a turn from each player.\n\nFor each exchange, your program must read two lines describing Ueli's turn first. The first of those lines will contain an integer $\\mathbf{K}$, denoting the number of blue vertices to be colored red. The second of those lines will contain $\\mathbf{K}$ distinct integers $\\mathbf{A}_1, \\mathbf{A}_2, \\ldots, \\mathbf{A}_\\mathbf{K}$ describing the blue vertices to be colored red. $\\mathbf{K}$ will be at least 1, and each $\\mathbf{A}_i$ will be between 1 and $\\mathbf{N}$, inclusive. Vertices $\\mathbf{A}_2, \\mathbf{A}_3, \\ldots, \\mathbf{A}_\\mathbf{K}$ will all be neighbors of vertex $\\mathbf{A}_1$.\n\nAfter that, your program must output Vreni's choice for their turn in the same format: the first line with the number of blue vertices to be colored red, followed by the second line with the numbers of those vertices, in such an order that all vertices except the first one are neighbors of the first one.\n\nIf all vertices are red after Vreni's turn, it means that Vreni has won and this game is over. The next game starts immediately if there is one. If this was the last game for this test case, then the next test case starts immediately if there is one. If this was the last test case, the judge will send no further input to your program, and the program must send no further output.\n\nOn the other hand, if all vertices are red after Ueli's move, it means that Vreni has lost and therefore your program did not pass the test case. In this case, instead of starting a new exchange by printing the last move that colors all remaining blue vertices red, the judge will print a single number -1 and will not print any further output, and will not process any further games or test cases.\n\nIf the judge receives an invalidly formatted or invalid line (like outputting an unexpected number of integers, or integers out of range, or outputting a set of edges that do not form a tree, or trying to color a vertex that is already red, or trying to color a vertex that is not a neighbor of the first vertex colored in this turn) from your program at any moment, the judge will also print a single number -1 and will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n\nThe judge is deterministic. In other words, if you make two attempts that print the same numbers, you will get the same inputs from the judge. However, of course the judge can make different moves in different games on the same tree.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "Note that the sample interaction does not satisfy the constraints of either test set, as its $\\mathbf{N}$ values are too small. It is only presented to clarify the input and output format.\n\nBelow is an illustration of Case #2, Game #1 at the beginning and after each turn:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cccz3vlj.png)\n\nBelow is an illustration of Case #2, Game #2 at the beginning and after each turn:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0b2qkj8q.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{M} \\leq 50.$\n\n**Test Set 1 (13 Pts, Visible Verdict)**\n\n- $\\mathbf{T}=1$.\n- $\\mathbf{N}=30$.\n\n**Test Set 2 (Hidden Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 10.$\n- $31 \\leq \\mathbf{N} \\leq 40.$\n- No two test cases use the same value of $\\mathbf{N}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 #3] Win As Second", "background": "", "description": "Ueli 和 Vreni 正在玩一个游戏。游戏棋盘是一棵有 $\\mathbf{N}$ 个顶点的树，初始所有顶点都是蓝色的。两人轮流操作，Ueli 先手。在每个回合中，玩家必须选择一个蓝色顶点及其任意数量（可以是零个或全部）的蓝色邻居顶点，并将这些顶点全部染红。如果在某个玩家的回合开始时所有顶点都是红色，则该玩家输掉游戏，另一方获胜。\n\n在下面的示例游戏中，Ueli 在第一回合将顶点 3 染红。然后，Vreni 选择顶点 2 并在她的回合中将其及其邻居（顶点 1）染红。由于所有顶点都已变红，Ueli 输掉游戏，Vreni 获胜。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xw0xc7is.png)\n\nUeli 和 Vreni 注意到，由于 Ueli 先手，他更容易获胜。因此他们采用了以下规则：首先，Ueli 选择一个整数 $\\mathbf{N}$；然后，Vreni 选择任意一棵有 $\\mathbf{N}$ 个顶点的树；接着他们按照上述规则开始游戏，Ueli 先手。\n\nVreni 希望通过选择树的结构来克服后手的劣势。你能展示 Vreni 如何在这种设定下获胜吗？\n\n### 交互协议\n\n这是一个交互式问题。请确保你已阅读常见问题中关于交互式问题的部分。\n\n开始时，你的程序应读取一个整数 $\\mathbf{T}$，表示测试用例的数量。然后处理 $\\mathbf{T}$ 个测试用例。\n\n对于每个测试用例，你的程序首先读取一个整数 $\\mathbf{N}$，表示 Ueli 选择的顶点数量。然后，你的程序需要输出 $\\mathbf{N}-1$ 行来描述 Vreni 应选择的树结构。树的顶点编号为 1 到 $\\mathbf{N}$。每行表示树的一条边，包含两个 1 到 $\\mathbf{N}$ 的整数，表示该边连接的两个顶点。这些边必须构成一棵树。每行中的两个整数顺序不限，$\\mathbf{N}-1$ 行的顺序也不限。\n\n之后，你的程序需要读取一个整数 $\\mathbf{M}$，表示需要在该树上进行的游戏数量。这些游戏是独立的，即每局游戏开始时所有顶点均为蓝色。\n\n对于每局游戏，你需要处理若干轮交互，直到游戏结束。每轮交互包含双方各一个回合。\n\n对于每轮交互，你的程序首先读取两行描述 Ueli 的回合。第一行是一个整数 $\\mathbf{K}$，表示要染红的蓝色顶点数量。第二行包含 $\\mathbf{K}$ 个互不相同的整数 $\\mathbf{A}_1, \\mathbf{A}_2, \\ldots, \\mathbf{A}_\\mathbf{K}$，表示要染红的蓝色顶点。$\\mathbf{K}$ 至少为 1，每个 $\\mathbf{A}_i$ 在 1 到 $\\mathbf{N}$ 之间。顶点 $\\mathbf{A}_2, \\mathbf{A}_3, \\ldots, \\mathbf{A}_\\mathbf{K}$ 都必须是 $\\mathbf{A}_1$ 的邻居。\n\n然后，你的程序需要以相同格式输出 Vreni 的回合选择：第一行输出要染红的蓝色顶点数量，第二行输出这些顶点的编号，且除第一个顶点外，其他顶点都必须是第一个顶点的邻居。\n\n如果 Vreni 的回合后所有顶点变红，则 Vreni 获胜，该局游戏结束。如果有下一局游戏，则立即开始；如果是该测试用例的最后一局游戏，则立即开始下一个测试用例（如果有）；如果是最后一个测试用例，评测机将不再发送输入，你的程序也不应再输出。\n\n如果在 Ueli 的回合后所有顶点已变红，则 Vreni 输掉游戏，你的程序未通过该测试用例。此时，评测机会输出 -1 并不再处理后续输入，你的程序应适时退出。\n\n如果评测机在任何时刻收到无效输入或输出（如格式错误、越界整数、非树结构的边、试图染红已为红色的顶点或不符合邻居条件的顶点），评测机也会输出 -1 并终止交互。若你的程序在收到 -1 后仍等待输入，将因超时而判为 Time Limit Exceeded。请注意，你有责任确保程序及时退出以避免超时错误。\n\n评测机的行为是确定性的。即相同的输出会得到相同的输入。但同一棵树上的不同游戏可能会有不同操作。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "注意样例交互不满足任何测试集的约束（$\\mathbf{N}$ 值过小），仅用于说明输入输出格式。\n\n下图展示了测试用例 #2 中游戏 #1 的初始状态及每回合后的变化：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cccz3vlj.png)\n\n下图展示了测试用例 #2 中游戏 #2 的初始状态及每回合后的变化：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0b2qkj8q.png)\n\n**限制**\n\n- $1 \\leq \\mathbf{M} \\leq 50$。\n\n**测试集 1（13 分，可见判题结果）**\n\n- $\\mathbf{T}=1$。\n- $\\mathbf{N}=30$。\n\n**测试集 2（隐藏判题结果）**\n\n- $1 \\leq \\mathbf{T} \\leq 10$。\n- $31 \\leq \\mathbf{N} \\leq 40$。\n- 不同测试用例的 $\\mathbf{N}$ 值互不相同。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13001", "type": "P", "difficulty": 5, "samples": [["4\n5 5 5 1\n1 2\n1 3\n2 4\n3 4\n4 5\n5 5 5 2\n1 2\n1 3\n2 4\n3 4\n4 5\n3 1 2 3\n1 3\n2 1 1 2\n1 2", "Case #1: SAFE\nCase #2: 4\nCase #3: SAFE\nCase #4: 2"]], "limits": {"time": [10000, 10000, 60000], "memory": [1048576, 1048576, 1048576]}, "tags": ["图论", "2022", "广度优先搜索 BFS", "Google Code Jam"], "title": "[GCJ 2022 Finals] Wonderland Chase", "background": "", "description": "Alice is trapped in Wonderland's labyrinth, being chased by the Queen of Hearts and her herald! The labyrinth is a set of $\\mathbf{J}$ junctions numbered 1 through $\\mathbf{J}$, connected by $\\mathbf{C}$ bidirectional corridors.\n\nAlice and the Queen of Hearts take turns making moves, and each knows the location of the other at all times. A move (by either of them) consists of either staying at the current junction or moving to another one that is connected to it by a corridor.\n\nThe Queen's herald, however, announces the next move the Queen makes in advance. That means that before anyone makes a move, he announces the Queen's first move. Then, Alice moves first. Then, each time the Queen moves, she must respect the previous announcement, and then decide her next move so the herald can announce it. Alice hears the announcements, so she always knows the Queen's next move before making her own.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5dctftu9.png)\n\nIf Alice and the Queen are at the same junction after either of them moves, then Alice is caught. Otherwise, the pursuit continues. After $10^{9}$ total moves (half of them for Alice and half for the Queen), if Alice and the Queen are not in the same junction, then the Queen will give up and Alice will be safe.\n\nAlice chooses her moves optimally to escape. If she cannot escape, she chooses her moves to maximize the total number of moves until she is caught. The Queen chooses her moves optimally to try to catch Alice in as few total moves as possible.\n\nGiven the labyrinth's layout and the initial locations of both the Queen and Alice, find out whether Alice will be caught by the Queen and, if so, in how many moves.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing four integers $\\mathbf{J}$, $\\mathbf{C}$, $\\mathbf{A}$, and $\\mathbf{Q}$: the number of junctions, the number of corridors, the junction where Alice starts, and the junction where the Queen starts, respectively. Then, $\\mathbf{C}$ lines follow. The $i$-th of these lines contains two integers $\\mathbf{U}_i$ and $\\mathbf{V}_i$, indicating that the $i$-th corridor bidirectionally connects junctions $\\mathbf{U}_i$ and $\\mathbf{V}_i$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `SAFE` if Alice can avoid being caught for $10^9$ total moves. Otherwise, $y$ is the total number of moves (including Alice's and the Queen's) that it takes for the Queen to catch Alice.", "hint": "Sample Case #1 is the one pictured in the problem statement. Alice's optimal first move is to move to junction 4.\n\nSample Case #2 is the same as Sample Case #1 but the Queen starts at junction 2. The Queen can catch Alice by first announcing a move to junction 4. If Alice were to move to junction 4, she would be caught in 2 moves. Alice can evade capture for an extra 2 moves by staying put and waiting until the Queen then moves to junction 5 where she is located.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tbatx4qf.png)\n\nIn Sample Case #3, the Queen cannot reach Alice no matter what she does.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f4qvfxc7.png)\n\nIn Sample Case #4, the Queen can begin by announcing that she will move to Alice's current junction. Alice has to move before then. If Alice moves to where the Queen already is, she gets caught immediately; if Alice remains in place, then she gets caught when the Queen moves. The second option is better, since it requires 2 total moves (Alice's and the Queen's) instead of 1.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2ac9iwif.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{A} \\leq \\mathbf{J}$.\n- $1 \\leq \\mathbf{Q} \\leq \\mathbf{J}$.\n- $\\mathbf{A} \\neq \\mathbf{Q}$.\n- $1 \\leq \\mathbf{U}_i < \\mathbf{V}_i \\leq \\mathbf{J}$, for all $i$.\n- $(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{U}_j, \\mathbf{V}_j)$, for all $i \\neq j$.\n\n**Test Set 1 (Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $2 \\leq \\mathbf{J} \\leq 30$.\n- $1 \\leq \\mathbf{C} \\leq 60$.\n\n**Test Set 2 (Hidden Verdict)**\n\n- Time limit: 60 seconds.\n- $2 \\leq \\mathbf{J} \\leq 10^5$.\n- $1 \\leq \\mathbf{C} \\leq 2 \\times 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 Finals] Wonderland Chase", "background": "", "description": "Alice is trapped in Wonderland's labyrinth, being chased by the Queen of Hearts and her herald! The labyrinth is a set of $\\mathbf{J}$ junctions numbered 1 through $\\mathbf{J}$, connected by $\\mathbf{C}$ bidirectional corridors.\n\nAlice and the Queen of Hearts take turns making moves, and each knows the location of the other at all times. A move (by either of them) consists of either staying at the current junction or moving to another one that is connected to it by a corridor.\n\nThe Queen's herald, however, announces the next move the Queen makes in advance. That means that before anyone makes a move, he announces the Queen's first move. Then, Alice moves first. Then, each time the Queen moves, she must respect the previous announcement, and then decide her next move so the herald can announce it. Alice hears the announcements, so she always knows the Queen's next move before making her own.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5dctftu9.png)\n\nIf Alice and the Queen are at the same junction after either of them moves, then Alice is caught. Otherwise, the pursuit continues. After $10^{9}$ total moves (half of them for Alice and half for the Queen), if Alice and the Queen are not in the same junction, then the Queen will give up and Alice will be safe.\n\nAlice chooses her moves optimally to escape. If she cannot escape, she chooses her moves to maximize the total number of moves until she is caught. The Queen chooses her moves optimally to try to catch Alice in as few total moves as possible.\n\nGiven the labyrinth's layout and the initial locations of both the Queen and Alice, find out whether Alice will be caught by the Queen and, if so, in how many moves.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing four integers $\\mathbf{J}$, $\\mathbf{C}$, $\\mathbf{A}$, and $\\mathbf{Q}$: the number of junctions, the number of corridors, the junction where Alice starts, and the junction where the Queen starts, respectively. Then, $\\mathbf{C}$ lines follow. The $i$-th of these lines contains two integers $\\mathbf{U}_i$ and $\\mathbf{V}_i$, indicating that the $i$-th corridor bidirectionally connects junctions $\\mathbf{U}_i$ and $\\mathbf{V}_i$.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `SAFE` if Alice can avoid being caught for $10^9$ total moves. Otherwise, $y$ is the total number of moves (including Alice's and the Queen's) that it takes for the Queen to catch Alice.", "hint": "Sample Case #1 is the one pictured in the problem statement. Alice's optimal first move is to move to junction 4.\n\nSample Case #2 is the same as Sample Case #1 but the Queen starts at junction 2. The Queen can catch Alice by first announcing a move to junction 4. If Alice were to move to junction 4, she would be caught in 2 moves. Alice can evade capture for an extra 2 moves by staying put and waiting until the Queen then moves to junction 5 where she is located.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tbatx4qf.png)\n\nIn Sample Case #3, the Queen cannot reach Alice no matter what she does.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f4qvfxc7.png)\n\nIn Sample Case #4, the Queen can begin by announcing that she will move to Alice's current junction. Alice has to move before then. If Alice moves to where the Queen already is, she gets caught immediately; if Alice remains in place, then she gets caught when the Queen moves. The second option is better, since it requires 2 total moves (Alice's and the Queen's) instead of 1.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2ac9iwif.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{A} \\leq \\mathbf{J}$.\n- $1 \\leq \\mathbf{Q} \\leq \\mathbf{J}$.\n- $\\mathbf{A} \\neq \\mathbf{Q}$.\n- $1 \\leq \\mathbf{U}_i < \\mathbf{V}_i \\leq \\mathbf{J}$, for all $i$.\n- $(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{U}_j, \\mathbf{V}_j)$, for all $i \\neq j$.\n\n**Test Set 1 (Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $2 \\leq \\mathbf{J} \\leq 30$.\n- $1 \\leq \\mathbf{C} \\leq 60$.\n\n**Test Set 2 (Hidden Verdict)**\n\n- Time limit: 60 seconds.\n- $2 \\leq \\mathbf{J} \\leq 10^5$.\n- $1 \\leq \\mathbf{C} \\leq 2 \\times 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 Finals] Wonderland Chase", "background": "", "description": "**Alice** 被困在仙境的迷宫中，正被**红心皇后**和她的传令官追赶！迷宫由 $\\mathbf{J}$ 个编号为 1 到 $\\mathbf{J}$ 的交叉点和 $\\mathbf{C}$ 条双向走廊连接而成。\n\n**Alice** 和**红心皇后**轮流移动，双方始终知道对方的位置。每次移动（无论是谁）可以选择停留在当前交叉点，或通过走廊移动到相邻的交叉点。\n\n然而，皇后的传令官会提前宣布皇后下一步的移动计划。这意味着在任何人移动之前，他会先宣布皇后的第一步移动。接着，**Alice** 先移动。之后，每次皇后移动时，她必须遵守之前的宣布，并决定下一步移动以便传令官宣布。**Alice** 会听到这些宣布，因此她总是能在自己移动前知道皇后的下一步计划。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5dctftu9.png)\n\n如果 **Alice** 和皇后在任意一方移动后处于同一交叉点，则 **Alice** 被抓住。否则，追逐继续。若在总共 $10^{9}$ 次移动（**Alice** 和皇后各占一半）后，两人仍未处于同一交叉点，则皇后会放弃，**Alice** 安全逃脱。\n\n**Alice** 会以最优策略选择移动以逃脱。若无法逃脱，她会选择最大化被抓住前的移动次数。皇后则会以最优策略尝试在尽可能少的移动次数内抓住 **Alice**。\n\n给定迷宫的布局以及 **Alice** 和皇后的初始位置，判断 **Alice** 是否会被皇后抓住，如果是，计算需要多少次移动。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含四个整数 $\\mathbf{J}$、$\\mathbf{C}$、$\\mathbf{A}$ 和 $\\mathbf{Q}$：分别表示交叉点数量、走廊数量、**Alice** 的起始交叉点和皇后的起始交叉点。接着是 $\\mathbf{C}$ 行，每行包含两个整数 $\\mathbf{U}_i$ 和 $\\mathbf{V}_i$，表示第 $i$ 条走廊双向连接交叉点 $\\mathbf{U}_i$ 和 $\\mathbf{V}_i$。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 为 `SAFE` 表示 **Alice** 能在 $10^9$ 次移动内避免被抓住；否则 $y$ 是皇后抓住 **Alice** 所需的总移动次数（包括 **Alice** 和皇后的移动）。\n", "hint": "样例 #1 对应题目描述中的图示。**Alice** 的最优第一步是移动到交叉点 4。\n\n样例 #2 与样例 #1 相同，但皇后起始于交叉点 2。皇后可以通过先宣布移动到交叉点 4 来抓住 **Alice**。若 **Alice** 移动到交叉点 4，她将在 2 次移动后被抓住。 **Alice** 可以选择停留，直到皇后移动到交叉点 5，从而将捕获时间延长至 4 次移动。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/tbatx4qf.png)\n\n样例 #3 中，皇后无论如何都无法到达 **Alice** 所在位置。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f4qvfxc7.png)\n\n样例 #4 中，皇后可以宣布直接移动到 **Alice** 当前所在的交叉点。**Alice** 必须在皇后移动前行动。若 **Alice** 移动到皇后所在位置，她会立即被抓住；若停留原地，则会在皇后移动时被抓住。第二种选择更优，因为需要 2 次总移动（**Alice** 和皇后各一次）而非 1 次。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2ac9iwif.png)\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{A} \\leq \\mathbf{J}$。\n- $1 \\leq \\mathbf{Q} \\leq \\mathbf{J}$。\n- $\\mathbf{A} \\neq \\mathbf{Q}$。\n- 对所有 $i$，$1 \\leq \\mathbf{U}_i < \\mathbf{V}_i \\leq \\mathbf{J}$。\n- 对所有 $i \\neq j$，$(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{U}_j, \\mathbf{V}_j)$。\n\n**测试集 1（可见判定）**\n\n- 时间限制：10 秒。\n- $2 \\leq \\mathbf{J} \\leq 30$。\n- $1 \\leq \\mathbf{C} \\leq 60$。\n\n**测试集 2（隐藏判定）**\n\n- 时间限制：60 秒。\n- $2 \\leq \\mathbf{J} \\leq 10^5$。\n- $1 \\leq \\mathbf{C} \\leq 2 \\times 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13002", "type": "P", "difficulty": 7, "samples": [["2\n2 1 2\n1 2 3\n1 2 1 1 1\n2 1 2 2 2\n4 2 4\n4 3 10\n-4 -3 20\n1 3 4 3 11\n2 4 0 0 16\n3 1 6 3 9\n4 2 0 0 16", "Case #1: 1\nCase #2: 2"]], "limits": {"time": [20000, 20000, 60000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2022", "强连通分量", "Google Code Jam"], "title": "[GCJ 2022 Finals] Goose, Goose, Ducks?", "background": "", "description": "The first international Geese conference just wrapped up, and even though it should have been a happy occasion, it was bittersweet. The organizers found a paper with detailed plans of a duck infiltration. Now, they are trying to identify the infiltrating group from among the attendees.\n\nThe document that they found contained a list of $\\mathbf{M}$ triples of integers $(\\mathbf{X}_i, \\mathbf{Y}_i, \\mathbf{C}_i)$ meaning the ducks would meet exactly $\\mathbf{C}_i$ seconds after the start of the conference at point $(\\mathbf{X}_i, \\mathbf{Y}_i)$, which is $\\mathbf{X}_i$ meters east and $\\mathbf{Y}_i$ meters north of the center of the conference floor. Each goose may or may not have been at those specific points at those specific times, but every duck certainly was.\n\nBoth ducks and geese walk at a maximum speed of one meter per second, which means an attendee that is at point $(x, y)$ at time $t$ can reach any point of the form $(x + \\Delta_x, y + \\Delta_y)$ by time $t + \\Delta_t$ as long as $\\Delta_x^2 + \\Delta_y^2 \\leq \\Delta_t^2$. Each attendee's position at time 0 can be any point, independently of the other attendees.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mq68x9yi.png)\n\nAfter the discovery, the group held a questioning session to try to identify the ducks. During that session, attendees issued a series of statements, one at a time. The $j$-th of those, in the order they were issued, was made by attendee $\\mathbf{A}_j$, claiming that both they and attendee $\\mathbf{B}_j$ were at point $(\\mathbf{U}_j, \\mathbf{V}_j)$ exactly $\\mathbf{D}_j$ seconds after the start of the conference. Points in statements may or may not be points where duck meetings happened.\n\nStatements from geese are always true, but ducks may lie. Moreover, ducks know which attendees are ducks and which are geese. To avoid getting caught easily, ducks only make statements that are consistent with all statements previously made by geese. Note that statements made by geese are consistent with all ducks being at all duck meetings.\n\nIt may not be possible to determine all the ducks with the information provided. However, knowing the minimum number of ducks will at least provide a lower bound on the level of duck activity. Note that there was at least one duck. Find this minimum number of ducks.\n\nFormally, a hypothesis $H$ is a partition of all attendees into a set of ducks (named $H$-ducks) and geese (named $H$-geese). $H$ is consistent with a set of statements $S$ if there exists a path for each attendee moving at most one meter per second such that:\n\n* all $H$-ducks were at all duck meetings and\n* for each statement in $S$ claiming that $A$ saw $B$ at point $P$ at time $T$, both $A$ and $B$'s paths went through point $P$ at time $T$.\n\nA hypothesis $H$ is feasible under a set of statements $S$ if:\n\n* $H$-ducks is not empty (i.e., there was at least one duck),\n* the subset of all statements from $S$ made by members of $H$-geese is consistent with $H$ (i.e., statements from geese are always true), and\n* for each statement $s \\in S$ made by a member of $H$-ducks, if $P \\subseteq S$ is the subset of statements made by members of $H$-geese issued before $s$, there exists a hypothesis $H'$ (which may or may not be equal to $H$) such that $\\{s\\} \\cup P$ is consistent with $H'$ (i.e., ducks do not contradict previous statements made by geese).\n\nNotice that the hypotheses $H$ such that $H$-ducks contains all attendees is always feasible.\n\nFind the minimum size of $H$-ducks over all feasible hypotheses $H$.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing three integers, $\\mathbf{N}$, $\\mathbf{M}$, and $\\mathbf{S}$, representing the numbers of attendees, duck meetings, and statements, respectively. The next $\\mathbf{M}$ lines each describe a different duck meeting with three integers $\\mathbf{X}_i$, $\\mathbf{Y}_i$, and $\\mathbf{C}_i$, representing that there was a meeting at point $(\\mathbf{X}_i, \\mathbf{Y}_i)$, held exactly $\\mathbf{C}_i$ seconds after the start of the conference. Then, the last $\\mathbf{S}$ lines of a test case each describe a statement. The $j$-th of these lines describes the $j$-th issued statement with five integers $\\mathbf{A}_j$, $\\mathbf{B}_j$, $\\mathbf{U}_j$, $\\mathbf{V}_j$, and $\\mathbf{D}_j$, representing that attendee $\\mathbf{A}_j$ stated that they and attendee $\\mathbf{B}_j$ were both at point $(\\mathbf{U}_j, \\mathbf{V}_j)$ exactly $\\mathbf{D}_j$ seconds after the start of the conference.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of ducks that might have infiltrated the conference.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, attendee 1 being the only duck is a feasible hypothesis.\n\nIn Sample Case #2, attendees 2 and 4 being the only ducks is a feasible hypothesis. Note that there is at least one duck, so all attendees being geese is not feasible.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 50$.\n- $-10^9 \\leq \\mathbf{X}_i \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y}_i \\leq 10^9$, for all $i$.\n- $1 \\leq \\mathbf{C}_i \\leq 10^9$, for all $i$.\n- $\\mathbf{C}_i < \\mathbf{C}_{i+1}$, for all $i$.\n- $(\\mathbf{X}_i - \\mathbf{X}_{i+1})^2 + (\\mathbf{Y}_i - \\mathbf{Y}_{i+1})^2 \\leq (\\mathbf{C}_i - \\mathbf{C}_{i+1})^2$, for all $i$.\n- $1 \\leq \\mathbf{A}_j \\leq \\mathbf{N}$, for all $j$.\n- $1 \\leq \\mathbf{B}_j \\leq \\mathbf{N}$, for all $j$.\n- $\\mathbf{A}_j \\neq \\mathbf{B}_j$, for all $j$.\n- $-10^9 \\leq \\mathbf{U}_j \\leq 10^9$, for all $j$.\n- $-10^9 \\leq \\mathbf{V}_j \\leq 10^9$, for all $j$.\n- $1 \\leq \\mathbf{D}_j \\leq 10^9$, for all $j$.\n- $(\\mathbf{A}_j, \\mathbf{B}_j, \\mathbf{U}_j, \\mathbf{V}_j, \\mathbf{D}_j) \\neq (\\mathbf{A}_k, \\mathbf{B}_k, \\mathbf{U}_k, \\mathbf{V}_k, \\mathbf{D}_k)$, for all $j \\neq k$.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $2 \\leq \\mathbf{N} \\leq 50$.\n- $1 \\leq \\mathbf{M} \\leq 50$.\n- $1 \\leq \\mathbf{S} \\leq 50$.\n\n**Test Set 2 (24 Pts, Hidden Verdict)**\n\n- Time limit: 60 seconds.\n- $2 \\leq \\mathbf{N} \\leq 10^5$.\n- $1 \\leq \\mathbf{M} \\leq 10^5$.\n- $1 \\leq \\mathbf{S} \\leq 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 Finals] Goose, Goose, Ducks?", "background": "", "description": "The first international Geese conference just wrapped up, and even though it should have been a happy occasion, it was bittersweet. The organizers found a paper with detailed plans of a duck infiltration. Now, they are trying to identify the infiltrating group from among the attendees.\n\nThe document that they found contained a list of $\\mathbf{M}$ triples of integers $(\\mathbf{X}_i, \\mathbf{Y}_i, \\mathbf{C}_i)$ meaning the ducks would meet exactly $\\mathbf{C}_i$ seconds after the start of the conference at point $(\\mathbf{X}_i, \\mathbf{Y}_i)$, which is $\\mathbf{X}_i$ meters east and $\\mathbf{Y}_i$ meters north of the center of the conference floor. Each goose may or may not have been at those specific points at those specific times, but every duck certainly was.\n\nBoth ducks and geese walk at a maximum speed of one meter per second, which means an attendee that is at point $(x, y)$ at time $t$ can reach any point of the form $(x + \\Delta_x, y + \\Delta_y)$ by time $t + \\Delta_t$ as long as $\\Delta_x^2 + \\Delta_y^2 \\leq \\Delta_t^2$. Each attendee's position at time 0 can be any point, independently of the other attendees.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mq68x9yi.png)\n\nAfter the discovery, the group held a questioning session to try to identify the ducks. During that session, attendees issued a series of statements, one at a time. The $j$-th of those, in the order they were issued, was made by attendee $\\mathbf{A}_j$, claiming that both they and attendee $\\mathbf{B}_j$ were at point $(\\mathbf{U}_j, \\mathbf{V}_j)$ exactly $\\mathbf{D}_j$ seconds after the start of the conference. Points in statements may or may not be points where duck meetings happened.\n\nStatements from geese are always true, but ducks may lie. Moreover, ducks know which attendees are ducks and which are geese. To avoid getting caught easily, ducks only make statements that are consistent with all statements previously made by geese. Note that statements made by geese are consistent with all ducks being at all duck meetings.\n\nIt may not be possible to determine all the ducks with the information provided. However, knowing the minimum number of ducks will at least provide a lower bound on the level of duck activity. Note that there was at least one duck. Find this minimum number of ducks.\n\nFormally, a hypothesis $H$ is a partition of all attendees into a set of ducks (named $H$-ducks) and geese (named $H$-geese). $H$ is consistent with a set of statements $S$ if there exists a path for each attendee moving at most one meter per second such that:\n\n* all $H$-ducks were at all duck meetings and\n* for each statement in $S$ claiming that $A$ saw $B$ at point $P$ at time $T$, both $A$ and $B$'s paths went through point $P$ at time $T$.\n\nA hypothesis $H$ is feasible under a set of statements $S$ if:\n\n* $H$-ducks is not empty (i.e., there was at least one duck),\n* the subset of all statements from $S$ made by members of $H$-geese is consistent with $H$ (i.e., statements from geese are always true), and\n* for each statement $s \\in S$ made by a member of $H$-ducks, if $P \\subseteq S$ is the subset of statements made by members of $H$-geese issued before $s$, there exists a hypothesis $H'$ (which may or may not be equal to $H$) such that $\\{s\\} \\cup P$ is consistent with $H'$ (i.e., ducks do not contradict previous statements made by geese).\n\nNotice that the hypotheses $H$ such that $H$-ducks contains all attendees is always feasible.\n\nFind the minimum size of $H$-ducks over all feasible hypotheses $H$.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing three integers, $\\mathbf{N}$, $\\mathbf{M}$, and $\\mathbf{S}$, representing the numbers of attendees, duck meetings, and statements, respectively. The next $\\mathbf{M}$ lines each describe a different duck meeting with three integers $\\mathbf{X}_i$, $\\mathbf{Y}_i$, and $\\mathbf{C}_i$, representing that there was a meeting at point $(\\mathbf{X}_i, \\mathbf{Y}_i)$, held exactly $\\mathbf{C}_i$ seconds after the start of the conference. Then, the last $\\mathbf{S}$ lines of a test case each describe a statement. The $j$-th of these lines describes the $j$-th issued statement with five integers $\\mathbf{A}_j$, $\\mathbf{B}_j$, $\\mathbf{U}_j$, $\\mathbf{V}_j$, and $\\mathbf{D}_j$, representing that attendee $\\mathbf{A}_j$ stated that they and attendee $\\mathbf{B}_j$ were both at point $(\\mathbf{U}_j, \\mathbf{V}_j)$ exactly $\\mathbf{D}_j$ seconds after the start of the conference.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of ducks that might have infiltrated the conference.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, attendee 1 being the only duck is a feasible hypothesis.\n\nIn Sample Case #2, attendees 2 and 4 being the only ducks is a feasible hypothesis. Note that there is at least one duck, so all attendees being geese is not feasible.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 50$.\n- $-10^9 \\leq \\mathbf{X}_i \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y}_i \\leq 10^9$, for all $i$.\n- $1 \\leq \\mathbf{C}_i \\leq 10^9$, for all $i$.\n- $\\mathbf{C}_i < \\mathbf{C}_{i+1}$, for all $i$.\n- $(\\mathbf{X}_i - \\mathbf{X}_{i+1})^2 + (\\mathbf{Y}_i - \\mathbf{Y}_{i+1})^2 \\leq (\\mathbf{C}_i - \\mathbf{C}_{i+1})^2$, for all $i$.\n- $1 \\leq \\mathbf{A}_j \\leq \\mathbf{N}$, for all $j$.\n- $1 \\leq \\mathbf{B}_j \\leq \\mathbf{N}$, for all $j$.\n- $\\mathbf{A}_j \\neq \\mathbf{B}_j$, for all $j$.\n- $-10^9 \\leq \\mathbf{U}_j \\leq 10^9$, for all $j$.\n- $-10^9 \\leq \\mathbf{V}_j \\leq 10^9$, for all $j$.\n- $1 \\leq \\mathbf{D}_j \\leq 10^9$, for all $j$.\n- $(\\mathbf{A}_j, \\mathbf{B}_j, \\mathbf{U}_j, \\mathbf{V}_j, \\mathbf{D}_j) \\neq (\\mathbf{A}_k, \\mathbf{B}_k, \\mathbf{U}_k, \\mathbf{V}_k, \\mathbf{D}_k)$, for all $j \\neq k$.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $2 \\leq \\mathbf{N} \\leq 50$.\n- $1 \\leq \\mathbf{M} \\leq 50$.\n- $1 \\leq \\mathbf{S} \\leq 50$.\n\n**Test Set 2 (24 Pts, Hidden Verdict)**\n\n- Time limit: 60 seconds.\n- $2 \\leq \\mathbf{N} \\leq 10^5$.\n- $1 \\leq \\mathbf{M} \\leq 10^5$.\n- $1 \\leq \\mathbf{S} \\leq 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 Finals] Goose, Goose, Ducks?", "background": "", "description": "首届国际鹅类大会刚刚结束，尽管这本应是一件值得高兴的事，却让人五味杂陈。组织者发现了一份文件，详细记录了鸭子的渗透计划。现在，他们正试图从与会者中找出这群渗透者。\n\n找到的文件中包含 $\\mathbf{M}$ 个整数三元组 $(\\mathbf{X}_i, \\mathbf{Y}_i, \\mathbf{C}_i)$，表示鸭子们会在会议开始后恰好 $\\mathbf{C}_i$ 秒在点 $(\\mathbf{X}_i, \\mathbf{Y}_i)$ 处集合，该点位于会议大厅中心以东 $\\mathbf{X}_i$ 米、以北 $\\mathbf{Y}_i$ 米处。每只鹅可能在这些特定时间出现在这些特定地点，也可能没有，但每只鸭子一定都在。\n\n鸭子和鹅的最大行走速度均为每秒 1 米，这意味着在时间 $t$ 处于点 $(x, y)$ 的与会者可以在时间 $t + \\Delta_t$ 前到达任何形如 $(x + \\Delta_x, y + \\Delta_y)$ 的点，只要满足 $\\Delta_x^2 + \\Delta_y^2 \\leq \\Delta_t^2$。每位与会者在时间 0 时的位置可以是任意点，与其他与会者无关。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mq68x9yi.png)\n\n发现文件后，组织者召开了一场质询会以试图识别鸭子。在质询过程中，与会者依次发表了一系列声明。按发表顺序，第 $j$ 条声明由与会者 $\\mathbf{A}_j$ 作出，声称他们和与会者 $\\mathbf{B}_j$ 在会议开始后恰好 $\\mathbf{D}_j$ 秒时位于点 $(\\mathbf{U}_j, \\mathbf{V}_j)$。声明中的点可能是也可能不是鸭子集合的地点。\n\n**鹅的声明总是真实的，但鸭子可能撒谎**。此外，鸭子知道哪些与会者是鸭子，哪些是鹅。为了避免轻易暴露，鸭子只会发表与之前鹅作出的所有声明一致的声明。注意，鹅的声明与所有鸭子都参加了所有鸭子集合是一致的。\n\n根据提供的信息，可能无法确定所有鸭子。然而，知道鸭子的最小数量至少可以为鸭子活动的活跃程度提供一个下限。注意，至少存在一只鸭子。请找出这一最小数量。\n\n形式化地，假设 $H$ 是将所有与会者划分为鸭子集合（称为 $H$-鸭子）和鹅集合（称为 $H$-鹅）的一种分类。$H$ 与一组声明 $S$ 一致的条件是：存在每位与会者以不超过每秒 1 米的速度移动的路径，满足：\n\n* 所有 $H$-鸭子都参加了所有鸭子集合；\n* 对于 $S$ 中每一条声称 $A$ 在时间 $T$ 于点 $P$ 看到 $B$ 的声明，$A$ 和 $B$ 的路径在时间 $T$ 都经过点 $P$。\n\n假设 $H$ 在一组声明 $S$ 下是可行的，如果：\n\n* $H$-鸭子非空（即至少存在一只鸭子），\n* $S$ 中由 $H$-鹅成员作出的所有声明的子集与 $H$ 一致（即鹅的声明总是真实的），\n* 对于 $S$ 中由 $H$-鸭子成员作出的每一条声明 $s$，如果 $P \\subseteq S$ 是在 $s$ 之前由 $H$-鹅成员作出的声明的子集，则存在一个假设 $H'$（可能与 $H$ 相同也可能不同）使得 $\\{s\\} \\cup P$ 与 $H'$ 一致（即鸭子不会与之前鹅的声明矛盾）。\n\n注意，$H$-鸭子包含所有与会者的假设 $H$ 总是可行的。\n\n求出所有可行假设 $H$ 中 $H$-鸭子集合的最小大小。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含三个整数 $\\mathbf{N}$、$\\mathbf{M}$ 和 $\\mathbf{S}$，分别表示与会者数量、鸭子集合数量和声明数量。接下来的 $\\mathbf{M}$ 行每行描述一个鸭子集合，包含三个整数 $\\mathbf{X}_i$、$\\mathbf{Y}_i$ 和 $\\mathbf{C}_i$，表示在点 $(\\mathbf{X}_i, \\mathbf{Y}_i)$ 处有一个集合，时间为会议开始后恰好 $\\mathbf{C}_i$ 秒。然后，每个测试用例的最后 $\\mathbf{S}$ 行描述声明。第 $j$ 行描述第 $j$ 条声明，包含五个整数 $\\mathbf{A}_j$、$\\mathbf{B}_j$、$\\mathbf{U}_j$、$\\mathbf{V}_j$ 和 $\\mathbf{D}_j$，表示与会者 $\\mathbf{A}_j$ 声称他们和与会者 $\\mathbf{B}_j$ 在会议开始后恰好 $\\mathbf{D}_j$ 秒时位于点 $(\\mathbf{U}_j, \\mathbf{V}_j)$。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是可能渗透会议的最小鸭子数量。\n", "hint": "**样例解释**\n\n在样例 #1 中，与会者 1 是唯一的鸭子是一个可行的假设。\n\n在样例 #2 中，与会者 2 和 4 是唯一的鸭子是一个可行的假设。注意，至少存在一只鸭子，因此所有与会者都是鹅的假设不可行。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 50$。\n- $-10^9 \\leq \\mathbf{X}_i \\leq 10^9$，对所有 $i$。\n- $-10^9 \\leq \\mathbf{Y}_i \\leq 10^9$，对所有 $i$。\n- $1 \\leq \\mathbf{C}_i \\leq 10^9$，对所有 $i$。\n- $\\mathbf{C}_i < \\mathbf{C}_{i+1}$，对所有 $i$。\n- $(\\mathbf{X}_i - \\mathbf{X}_{i+1})^2 + (\\mathbf{Y}_i - \\mathbf{Y}_{i+1})^2 \\leq (\\mathbf{C}_i - \\mathbf{C}_{i+1})^2$，对所有 $i$。\n- $1 \\leq \\mathbf{A}_j \\leq \\mathbf{N}$，对所有 $j$。\n- $1 \\leq \\mathbf{B}_j \\leq \\mathbf{N}$，对所有 $j$。\n- $\\mathbf{A}_j \\neq \\mathbf{B}_j$，对所有 $j$。\n- $-10^9 \\leq \\mathbf{U}_j \\leq 10^9$，对所有 $j$。\n- $-10^9 \\leq \\mathbf{V}_j \\leq 10^9$，对所有 $j$。\n- $1 \\leq \\mathbf{D}_j \\leq 10^9$，对所有 $j$。\n- $(\\mathbf{A}_j, \\mathbf{B}_j, \\mathbf{U}_j, \\mathbf{V}_j, \\mathbf{D}_j) \\neq (\\mathbf{A}_k, \\mathbf{B}_k, \\mathbf{U}_k, \\mathbf{V}_k, \\mathbf{D}_k)$，对所有 $j \\neq k$。\n\n**测试集 1（11 分，可见判定）**\n\n- 时间限制：20 秒。\n- $2 \\leq \\mathbf{N} \\leq 50$。\n- $1 \\leq \\mathbf{M} \\leq 50$。\n- $1 \\leq \\mathbf{S} \\leq 50$。\n\n**测试集 2（24 分，隐藏判定）**\n\n- 时间限制：60 秒。\n- $2 \\leq \\mathbf{N} \\leq 10^5$。\n- $1 \\leq \\mathbf{M} \\leq 10^5$。\n- $1 \\leq \\mathbf{S} \\leq 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13003", "type": "P", "difficulty": 6, "samples": [["5\n2 2\n2 1\n1 2\n3 4\n2 3\n1 2\n3 2\n1 3\n3 6\n1 2\n1 3\n2 1\n2 3\n3 1\n3 2\n3 4\n1 2\n2 1\n1 3\n3 1\n4 6\n1 2\n1 4\n2 3\n3 2\n3 4\n4 1", "Case #1: 7\n1 2 1 2 1 2 1\nCase #2: IMPOSSIBLE\nCase #3: 7\n1 2 3 1 3 2 1\nCase #4: IMPOSSIBLE\nCase #5: 9\n1 4 1 2 3 2 3 4 1"]], "limits": {"time": [10000, 10000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2022", "网络流", "Special Judge", "欧拉回路", "二分图", "Google Code Jam"], "title": "[GCJ 2022 Finals] Slide Parade", "background": "", "description": "Gooli is a huge company that owns $\\mathbf{B}$ buildings in a hilly area, numbered 1 through $\\mathbf{B}$. Six years ago, Gooli built slides that allowed employees to go from one building to another. Each slide allows anyone to go from the slide's origin building to the slide's destination building, but not the other way around. Gooli's CEO is very proud of their slides and wants to organize a parade through the slides. She has tasked Melek, Gooli's Head of Transportation and a problem-solving enthusiast, with designing the parade's route.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/njzcunb7.png)\n\nShe has some requirements for the parade route in mind:\n\n* It must start and end at building 1, where her office is located.\n* It must visit each building the same number of times. Being in building 1 at the start of the route does not count as a visit.\n* It must use each slide at least once.\n* It must have at most $10^6$ steps.\n\nGiven the layout of buildings and slides, help Melek find a route that satisfies all of the CEO's requirements, if one exists.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{B}$ and $\\mathbf{S}$: the number of buildings and slides, respectively. Then, $\\mathbf{S}$ lines follow. The $i$-th of these lines contains two integers $\\mathbf{U}_i$ and $\\mathbf{V}_i$, indicating that the $i$-th slide goes from building $\\mathbf{U}_i$ to building $\\mathbf{V}_i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1). If there is no route that fulfills all the requirements, $y$ must be `IMPOSSIBLE`. If there is, $y$ must be an integer between $\\mathbf{S} + 1$ and $10^6 + 1$, inclusive, representing the length of one such route you want to exhibit. In that case, output another line containing $y$ integers $z_1$ $z_2$ $\\dots$ $z_y$, where $z_j$ is the $j$-th building in your proposed route. Notice that $z_1 = z_y = 1$ and that each building must appear the same number of times among the $z_j$, except for building 1, which appears exactly one extra time.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, another acceptable parade route is one that goes from building 1 to building 2 and then back for a total of 2 steps.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/udzlxptm.png)\n\nIn Sample Case #2, there are no slides leading to building 1, so no valid parade can exist.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pp27u0fj.png)\n\nIn Sample Case #3, the parade route the sample output exhibits goes through each building twice.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e7pjon34.png)\n\nSample Case #4 is pictured below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ff4gi295.png)\n\nSample Case #5 is the one illustrated in the problem statement. In the parade route in the sample output, the slides from 2 to 3 and from 4 to 1 are used twice, but the rest of the slides are used only once each.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{U}_i \\leq \\mathbf{B}$, for all $i$.\n- $1 \\leq \\mathbf{V}_i \\leq \\mathbf{B}$, for all $i$.\n- $\\mathbf{U}_i \\neq \\mathbf{V}_i$, for all $i$.\n- $(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{U}_j, \\mathbf{V}_j)$, for all $i \\neq j$.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $2 \\leq \\mathbf{B} \\leq 10$.\n- $2 \\leq \\mathbf{S} \\leq 10$.\n\n**Test Set 2 (24 Pts, Hidden Verdict)**\n\n- Time limit: 20 seconds.\n- $2 \\leq \\mathbf{B} \\leq 200$.\n- $2 \\leq \\mathbf{S} \\leq 5000$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 Finals] Slide Parade", "background": "", "description": "Gooli is a huge company that owns $\\mathbf{B}$ buildings in a hilly area, numbered 1 through $\\mathbf{B}$. Six years ago, Gooli built slides that allowed employees to go from one building to another. Each slide allows anyone to go from the slide's origin building to the slide's destination building, but not the other way around. Gooli's CEO is very proud of their slides and wants to organize a parade through the slides. She has tasked Melek, Gooli's Head of Transportation and a problem-solving enthusiast, with designing the parade's route.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/njzcunb7.png)\n\nShe has some requirements for the parade route in mind:\n\n* It must start and end at building 1, where her office is located.\n* It must visit each building the same number of times. Being in building 1 at the start of the route does not count as a visit.\n* It must use each slide at least once.\n* It must have at most $10^6$ steps.\n\nGiven the layout of buildings and slides, help Melek find a route that satisfies all of the CEO's requirements, if one exists.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{B}$ and $\\mathbf{S}$: the number of buildings and slides, respectively. Then, $\\mathbf{S}$ lines follow. The $i$-th of these lines contains two integers $\\mathbf{U}_i$ and $\\mathbf{V}_i$, indicating that the $i$-th slide goes from building $\\mathbf{U}_i$ to building $\\mathbf{V}_i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1). If there is no route that fulfills all the requirements, $y$ must be `IMPOSSIBLE`. If there is, $y$ must be an integer between $\\mathbf{S} + 1$ and $10^6 + 1$, inclusive, representing the length of one such route you want to exhibit. In that case, output another line containing $y$ integers $z_1$ $z_2$ $\\dots$ $z_y$, where $z_j$ is the $j$-th building in your proposed route. Notice that $z_1 = z_y = 1$ and that each building must appear the same number of times among the $z_j$, except for building 1, which appears exactly one extra time.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, another acceptable parade route is one that goes from building 1 to building 2 and then back for a total of 2 steps.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/udzlxptm.png)\n\nIn Sample Case #2, there are no slides leading to building 1, so no valid parade can exist.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pp27u0fj.png)\n\nIn Sample Case #3, the parade route the sample output exhibits goes through each building twice.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e7pjon34.png)\n\nSample Case #4 is pictured below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ff4gi295.png)\n\nSample Case #5 is the one illustrated in the problem statement. In the parade route in the sample output, the slides from 2 to 3 and from 4 to 1 are used twice, but the rest of the slides are used only once each.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{U}_i \\leq \\mathbf{B}$, for all $i$.\n- $1 \\leq \\mathbf{V}_i \\leq \\mathbf{B}$, for all $i$.\n- $\\mathbf{U}_i \\neq \\mathbf{V}_i$, for all $i$.\n- $(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{U}_j, \\mathbf{V}_j)$, for all $i \\neq j$.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $2 \\leq \\mathbf{B} \\leq 10$.\n- $2 \\leq \\mathbf{S} \\leq 10$.\n\n**Test Set 2 (24 Pts, Hidden Verdict)**\n\n- Time limit: 20 seconds.\n- $2 \\leq \\mathbf{B} \\leq 200$.\n- $2 \\leq \\mathbf{S} \\leq 5000$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 Finals] Slide Parade", "background": null, "description": "**Gooli** 是一家巨型公司，在一个丘陵地区拥有 $\\mathbf{B}$ 栋编号为 1 到 $\\mathbf{B}$ 的建筑。六年前，Gooli 修建了滑梯，允许员工从一栋建筑滑向另一栋建筑。每个滑梯只能从其出发建筑滑向目标建筑，而不能反向滑行。Gooli 的 CEO 对公司的滑梯系统非常自豪，并希望组织一场滑梯游戏。她将设计路线的任务交给了 **Melek**——Gooli 的交通主管兼解题爱好者。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/njzcunb7.png)\n\nCEO 对路线提出了以下要求：\n\n* 路线必须从建筑 1（她的办公室所在地）出发并最终回到建筑 1。\n* 每栋建筑的访问次数必须相同。起点位于建筑 1 不算作对建筑 1 的一次访问。\n* 每条滑梯必须至少被使用一次。\n* 路线长度不超过 $10^6$ 步。\n\n给定建筑和滑梯的布局，帮助 Melek 找到一条满足 CEO 所有要求的路线（如果存在）。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含两个整数 $\\mathbf{B}$ 和 $\\mathbf{S}$，分别表示建筑数量和滑梯数量。接下来的 $\\mathbf{S}$ 行每行包含两个整数 $\\mathbf{U}_i$ 和 $\\mathbf{V}_i$，表示第 $i$ 条滑梯从建筑 $\\mathbf{U}_i$ 通向建筑 $\\mathbf{V}_i$。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始）。如果不存在满足所有要求的路线，$y$ 应为 `IMPOSSIBLE`。如果存在，$y$ 必须是一个介于 $\\mathbf{S} + 1$ 到 $10^6 + 1$ 之间的整数，表示你建议的路线长度。此时，还需输出第二行，包含 $y$ 个整数 $z_1\\ z_2\\ \\dots\\ z_y$，其中 $z_j$ 表示路线中第 $j$ 栋建筑的编号。注意 $z_1 = z_y = 1$，且所有建筑（除建筑 1 外）在 $z_j$ 中的出现次数必须相同，而建筑 1 恰好多出现一次。", "hint": "**样例解释**\n\n在样例 #1 中，另一条可接受的路线是从建筑 1 滑到建筑 2 再返回，总步数为 2 步。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/udzlxptm.png)\n\n在样例 #2 中，没有滑梯通向建筑 1，因此不存在有效路线。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/pp27u0fj.png)\n\n在样例 #3 中，样例输出展示的路线使每栋建筑被访问两次。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e7pjon34.png)\n\n样例 #4 如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ff4gi295.png)\n\n样例 #5 是题目描述中图示的案例。在样例输出的路线中，从 2 到 3 和从 4 到 1 的滑梯被使用了两次，其余滑梯各使用一次。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{U}_i \\leq \\mathbf{B}$，对所有 $i$。\n- $1 \\leq \\mathbf{V}_i \\leq \\mathbf{B}$，对所有 $i$。\n- $\\mathbf{U}_i \\neq \\mathbf{V}_i$，对所有 $i$。\n- $(\\mathbf{U}_i, \\mathbf{V}_i) \\neq (\\mathbf{U}_j, \\mathbf{V}_j)$，对所有 $i \\neq j$。\n\n**测试集 1（11 分，可见判定）**\n\n- 时间限制：10 秒。\n- $2 \\leq \\mathbf{B} \\leq 10$。\n- $2 \\leq \\mathbf{S} \\leq 10$。\n\n**测试集 2（24 分，隐藏判定）**\n\n- 时间限制：20 秒。\n- $2 \\leq \\mathbf{B} \\leq 200$。\n- $2 \\leq \\mathbf{S} \\leq 5000$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13004", "type": "P", "difficulty": 6, "samples": [["4\n4\n??.C\n2 3 1 3\n4\n????\n2 3 1 3\n6\n?.????\n6 6 6 6 6 5\n34\n????????????????????????????????CC\n2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 33", "Case #1: 1\nCase #2: 2\nCase #3: 15\nCase #4: 294967268"]], "limits": {"time": [10000, 10000, 10000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2022", "概率论", "基环树", "Google Code Jam"], "title": "[GCJ 2022 Finals] Schrödinger and Pavlov", "background": "", "description": " _The story, all names, characters, and incidents portrayed in this problem statement are fictitious. No identification with actual persons is intended or should be inferred._ \n\nIt is 1935 and a meeting between two Nobel prize winners is producing astonishing results. Schrödinger, a famous physicist, invited Pavlov, a famous physiologist, to see his experiments with cats in boxes. Pavlov brought his dog with him to keep up with his own research, and the combination proved interesting, to say the least.\n\nSchrödinger had a row of $\\mathbf{N}$ boxes. Some boxes definitely contain a cat, some boxes definitely do not contain a cat, and some boxes may or may not contain a cat. Each box is only big enough to hold a single cat. Each box is also equipped with a special quantum tunnel, that allows the cat in the box to move to some other specific box if the destination was empty. The tunnels work in a single direction.\n\nCats are usually mellow and quiet and do not use the tunnels unless they become startled. When a third unannounced guest rings the bell, Pavlov's dog gets excited immediately and starts running and barking. The dog starts at box 1 and runs towards box $\\mathbf{N}$. As the dog runs, it passes right next to each box, one at a time. When it passes next to a box that contains a cat, the cat in that box becomes startled. The startled cat checks the available tunnel and, if the destination box is empty, uses it to escape. If the destination box is occupied, the cat stays in its current box. The same cat can be startled more than once if they move to a box the dog will get to afterwards, and will proceed in the same way every time it is startled (using only the newly available tunnel each subsequent time).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xcqaev9m.png)\n\nAfter Pavlov's dog finally stops right next to the last box, Pavlov asks Schrödinger whether there is a cat in that last box. Schrödinger, true to his fame, replies that he does not know. Pavlov notices that the answer may depend on whether or not there were cats in the unknown boxes. Moreover, he also notices that because there are $k$ unknown boxes, there are $2^k$ possible *initial configurations*, one for each combination of statuses of the unknown boxes. Pavlov tells Schrödinger that they should try to calculate how many of the $2^k$ initial configurations would result in having a cat in the last box. You are asked to recreate that calculation. Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^9 + 7$ (1000000007).\n\n*Neither cats, nor dogs, nor Nobel prize winners were harmed in the making of this problem statement.*", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow, each described by exactly three lines. The first line of a test case contains a single integer $\\mathbf{N}$, the number of boxes in Schrödinger's experiment. Boxes are numbered between 1 and $\\mathbf{N}$, in the order Pavlov's dog passes them by. The second line of a test case contains a single string $\\mathbf{S}$ of $\\mathbf{N}$ characters. The $i$-th character of $\\mathbf{S}$ (counting from left to right) represents the contents of box $i$: it is an uppercase 'c' if the box contains a cat, a period '.' if the box does not contain a cat and a question mark '?' if it is unknown whether the box contains a cat or not. The third line of a test case contains $\\mathbf{N}$ integers $\\mathbf{B}_1$, $\\mathbf{B}_2$, $\\dots$, $\\mathbf{B}_\\mathbf{N}$, representing that there is a tunnel going out of box $i$ and into box $\\mathbf{B}_i$, for all $i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of initial configurations that would result in a cat being in the last box and unable to escape despite hearing the barking, modulo the prime $10^9 + 7$ ($1000000007$).", "hint": "**Sample Explanation**\n\nSample Case #1 is illustrated in the problem statement. There are 4 possible configurations:\n\n*   `...C`: the dog runs through the first 3 boxes without changing anything because there is no cat there. Then, when it gets to the last box, the cat hears it and escapes to box 3. Therefore, there is no cat in the last box in this case.\n*   `C..C`: when the dog barks near box 1, that startles the cat that goes through the tunnel to get to box 2, which was empty. Then, the same cat gets startled again when the dog barks near box 2 and gets to box 3. And when the dog barks next to box 3, the cat hears it and returns to box 1. Therefore, when the dog gets to box 4 and the other cats hears it, box 3 is empty so the cat escapes and the last box ends up empty.\n*   `.C.C`: This case is very similar to the previous one. After the dog goes through the first box and nothing happens, the state is the same as before, so the ultimate result is the same: last box empty.\n*   `CC.C`: In this case, the cat in the first box cannot escape when it hears the dog, so it remains in box 1. Then, when the cat in box 2 gets startled it escapes to box 3 leaving a state of `C.CC`. When the dog gets to the box 3, the cat currently there cannot escape to box 1 so the state remains the same. Finally, when the dog gets to the last box, the cat that is there cannot escape because box 3 is occupied this time. So, in this case, the last box ends up with a cat after the dog ends its journey.\n\nOut of the 4 possibilities, only 1 (the last one) ends up with a cat in the last box, so the answer is 1.\n\nIn Sample Case #2, the tunnels are set up the same as in Sample Case #1. Since no tunnel ends at the last box, the configurations that start with no cat at the last box will also not end with a cat there, so we do not need to count them. Then, we have 8 additional configurations. The 4 we considered for Sample Case #1, out of which only 1 ends up with a cat at the last box. The remaining 4 configurations are: `..CC`, `C.CC`, `.CCC`, `CCCC`. From these additional 4 configurations, only in the last one listed a cat ends up in the last box, for a total of 2 overall.\n\nIn Sample Case #3, notice that for a cat to remain in the last box after the dog barks near it, both that box and box 5 must be occupied then (otherwise, either there is no cat in the last box, or it will escape to box 5). Since there is no tunnel going into box 5, a cat must start there. As long as there is another cat in any other box, box 6 will get (or remain) occupied before the cat in box 5 gets an opportunity to escape, so all of those will end up with a cat in the last box. As we argued before, a single cat is not enough. Thus, we need to count the number of configurations with a cat in box 5 and at least one other cat. There are $2^4$ configurations with a cat in box 5, and out of those, only 1 has no other cat, so the answer is $2^4 - 1 = 15$.\n\nIn Sample Case #4, in all of the $2^k$ ways in which the $k$ unknown boxes may exist a cat would be left in the last box.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 1234$.\n- the length of $\\mathbf{S} = \\mathbf{N}$.\nE- ach character of $\\mathbf{S}$ is either an upper case 'c', a period '.' or a question mark '?'.\n- $1 \\leq \\mathbf{B}_i \\leq \\mathbf{N}$, for all $i$.\n- $\\mathbf{B}_i \\neq i$, for all $i$.\n\n**Test Set 1 (8 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 100$.\n- $i - 5 \\leq \\mathbf{B}_i \\leq i + 5$, for all $i$. (All tunnels connect to nearby boxes.)\n\n**Test Set 2 (42 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 5000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 Finals] Schrödinger and Pavlov", "background": "", "description": " _The story, all names, characters, and incidents portrayed in this problem statement are fictitious. No identification with actual persons is intended or should be inferred._ \n\nIt is 1935 and a meeting between two Nobel prize winners is producing astonishing results. Schrödinger, a famous physicist, invited Pavlov, a famous physiologist, to see his experiments with cats in boxes. Pavlov brought his dog with him to keep up with his own research, and the combination proved interesting, to say the least.\n\nSchrödinger had a row of $\\mathbf{N}$ boxes. Some boxes definitely contain a cat, some boxes definitely do not contain a cat, and some boxes may or may not contain a cat. Each box is only big enough to hold a single cat. Each box is also equipped with a special quantum tunnel, that allows the cat in the box to move to some other specific box if the destination was empty. The tunnels work in a single direction.\n\nCats are usually mellow and quiet and do not use the tunnels unless they become startled. When a third unannounced guest rings the bell, Pavlov's dog gets excited immediately and starts running and barking. The dog starts at box 1 and runs towards box $\\mathbf{N}$. As the dog runs, it passes right next to each box, one at a time. When it passes next to a box that contains a cat, the cat in that box becomes startled. The startled cat checks the available tunnel and, if the destination box is empty, uses it to escape. If the destination box is occupied, the cat stays in its current box. The same cat can be startled more than once if they move to a box the dog will get to afterwards, and will proceed in the same way every time it is startled (using only the newly available tunnel each subsequent time).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xcqaev9m.png)\n\nAfter Pavlov's dog finally stops right next to the last box, Pavlov asks Schrödinger whether there is a cat in that last box. Schrödinger, true to his fame, replies that he does not know. Pavlov notices that the answer may depend on whether or not there were cats in the unknown boxes. Moreover, he also notices that because there are $k$ unknown boxes, there are $2^k$ possible *initial configurations*, one for each combination of statuses of the unknown boxes. Pavlov tells Schrödinger that they should try to calculate how many of the $2^k$ initial configurations would result in having a cat in the last box. You are asked to recreate that calculation. Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^9 + 7$ (1000000007).\n\n*Neither cats, nor dogs, nor Nobel prize winners were harmed in the making of this problem statement.*", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow, each described by exactly three lines. The first line of a test case contains a single integer $\\mathbf{N}$, the number of boxes in Schrödinger's experiment. Boxes are numbered between 1 and $\\mathbf{N}$, in the order Pavlov's dog passes them by. The second line of a test case contains a single string $\\mathbf{S}$ of $\\mathbf{N}$ characters. The $i$-th character of $\\mathbf{S}$ (counting from left to right) represents the contents of box $i$: it is an uppercase 'c' if the box contains a cat, a period '.' if the box does not contain a cat and a question mark '?' if it is unknown whether the box contains a cat or not. The third line of a test case contains $\\mathbf{N}$ integers $\\mathbf{B}_1$, $\\mathbf{B}_2$, $\\dots$, $\\mathbf{B}_\\mathbf{N}$, representing that there is a tunnel going out of box $i$ and into box $\\mathbf{B}_i$, for all $i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of initial configurations that would result in a cat being in the last box and unable to escape despite hearing the barking, modulo the prime $10^9 + 7$ ($1000000007$).", "hint": "**Sample Explanation**\n\nSample Case #1 is illustrated in the problem statement. There are 4 possible configurations:\n\n*   `...C`: the dog runs through the first 3 boxes without changing anything because there is no cat there. Then, when it gets to the last box, the cat hears it and escapes to box 3. Therefore, there is no cat in the last box in this case.\n*   `C..C`: when the dog barks near box 1, that startles the cat that goes through the tunnel to get to box 2, which was empty. Then, the same cat gets startled again when the dog barks near box 2 and gets to box 3. And when the dog barks next to box 3, the cat hears it and returns to box 1. Therefore, when the dog gets to box 4 and the other cats hears it, box 3 is empty so the cat escapes and the last box ends up empty.\n*   `.C.C`: This case is very similar to the previous one. After the dog goes through the first box and nothing happens, the state is the same as before, so the ultimate result is the same: last box empty.\n*   `CC.C`: In this case, the cat in the first box cannot escape when it hears the dog, so it remains in box 1. Then, when the cat in box 2 gets startled it escapes to box 3 leaving a state of `C.CC`. When the dog gets to the box 3, the cat currently there cannot escape to box 1 so the state remains the same. Finally, when the dog gets to the last box, the cat that is there cannot escape because box 3 is occupied this time. So, in this case, the last box ends up with a cat after the dog ends its journey.\n\nOut of the 4 possibilities, only 1 (the last one) ends up with a cat in the last box, so the answer is 1.\n\nIn Sample Case #2, the tunnels are set up the same as in Sample Case #1. Since no tunnel ends at the last box, the configurations that start with no cat at the last box will also not end with a cat there, so we do not need to count them. Then, we have 8 additional configurations. The 4 we considered for Sample Case #1, out of which only 1 ends up with a cat at the last box. The remaining 4 configurations are: `..CC`, `C.CC`, `.CCC`, `CCCC`. From these additional 4 configurations, only in the last one listed a cat ends up in the last box, for a total of 2 overall.\n\nIn Sample Case #3, notice that for a cat to remain in the last box after the dog barks near it, both that box and box 5 must be occupied then (otherwise, either there is no cat in the last box, or it will escape to box 5). Since there is no tunnel going into box 5, a cat must start there. As long as there is another cat in any other box, box 6 will get (or remain) occupied before the cat in box 5 gets an opportunity to escape, so all of those will end up with a cat in the last box. As we argued before, a single cat is not enough. Thus, we need to count the number of configurations with a cat in box 5 and at least one other cat. There are $2^4$ configurations with a cat in box 5, and out of those, only 1 has no other cat, so the answer is $2^4 - 1 = 15$.\n\nIn Sample Case #4, in all of the $2^k$ ways in which the $k$ unknown boxes may exist a cat would be left in the last box.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 1234$.\n- the length of $\\mathbf{S} = \\mathbf{N}$.\nE- ach character of $\\mathbf{S}$ is either an upper case 'c', a period '.' or a question mark '?'.\n- $1 \\leq \\mathbf{B}_i \\leq \\mathbf{N}$, for all $i$.\n- $\\mathbf{B}_i \\neq i$, for all $i$.\n\n**Test Set 1 (8 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 100$.\n- $i - 5 \\leq \\mathbf{B}_i \\leq i + 5$, for all $i$. (All tunnels connect to nearby boxes.)\n\n**Test Set 2 (42 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 5000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 Finals] Schrödinger and Pavlov", "background": "", "description": "_本题目中所有故事、名称、角色和情节均为虚构。如有雷同，纯属巧合。_\n\n1935 年，两位诺贝尔奖得主的会面产生了惊人的结果。著名物理学家**薛定谔**邀请著名生理学家**巴甫洛夫**参观他的\"猫在箱子里\"的实验。巴甫洛夫带着他的狗一同前来以继续自己的研究，两者的实验相结合产生了有趣的现象。\n\n薛定谔有一排 $\\mathbf{N}$ 个箱子。某些箱子中肯定有一只猫，某些箱子肯定没有猫，还有些箱子可能有也可能没有猫。每个箱子只能容纳一只猫。每个箱子还配备了一个特殊的**量子隧道**，允许箱子里的猫移动到另一个特定的箱子（前提是目标箱子是空的）。隧道的运作是单向的。\n\n猫通常很安静，除非受到惊吓才会使用隧道。当一位不速之客按响门铃时，巴甫洛夫的狗立即兴奋起来，开始边跑边叫。狗从 1 号箱子开始，一直跑到 $\\mathbf{N}$ 号箱子。当它经过一个有猫的箱子时，会惊吓到里面的猫。受惊的猫会检查可用的隧道：如果目标箱子是空的，就会通过隧道逃跑；如果目标箱子已被占据，猫就会留在原地。同一只猫可能会被多次惊吓（如果它移动到了狗还未经过的箱子），每次受惊时都会以相同的方式检查隧道（但每次只能使用新位置的隧道）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xcqaev9m.png)\n\n当狗最终停在最后一个箱子旁时，巴甫洛夫问薛定谔最后一个箱子里是否有猫。薛定谔（不出所料）回答说他不知道。巴甫洛夫意识到，答案取决于那些未知箱子中是否有猫。由于有 $k$ 个未知箱子，共有 $2^k$ 种可能的**初始配置**（每种对应未知箱子状态的一种组合）。巴甫洛夫建议他们应该计算有多少种初始配置会导致最后一个箱子里有猫。你需要重现这个计算过程。由于结果可能非常大，只需输出其对质数 $10^9 + 7$（1000000007）取模的值。\n\n*在本题描述过程中，没有猫、狗或诺贝尔奖得主受到伤害。*", "inputFormat": "输入的第一行给出测试用例数量 $\\mathbf{T}$。随后每个测试用例由三行组成：第一行是整数 $\\mathbf{N}$（箱子数量，编号为 1 到 $\\mathbf{N}$）；第二行是长度为 $\\mathbf{N}$ 的字符串 $\\mathbf{S}$，其中第 $i$ 个字符表示 $i$ 号箱子的初始状态（'c'表示有猫，'.'表示无猫，'?'表示未知）；第三行包含 $\\mathbf{N}$ 个整数 $\\mathbf{B}_1, \\mathbf{B}_2, \\dots, \\mathbf{B}_\\mathbf{N}$，表示从 $i$ 号箱子出发的隧道通向 $\\mathbf{B}_i$ 号箱子。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是会导致最后一个箱子最终有猫的初始配置数量（模 $10^9 + 7$）。\n", "hint": "**样例解释**\n\n样例 #1 的情况如题目描述所示。4 种可能的初始配置中，只有 `CC.C` 会导致最后一个箱子最终有猫。\n\n样例 #2 中，由于没有隧道通向最后一个箱子，只有当最后一个箱子初始有猫时才可能最终有猫。经分析共有 2 种符合条件的配置。\n\n样例 #3 中，要使最后一个箱子最终有猫，必须满足：5 号箱子初始有猫，且至少还有一个其他箱子有猫。符合条件的配置共有 $2^4 - 1 = 15$ 种。\n\n样例 #4 中，对于所有 $2^k$ 种可能的初始配置，最后一个箱子最终都会有猫。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 1234$\n- $\\mathbf{S}$ 的长度等于 $\\mathbf{N}$\n- $\\mathbf{S}$ 的每个字符是大写的 'c'、'.' 或 '?'\n- $1 \\leq \\mathbf{B}_i \\leq \\mathbf{N}$ 且 $\\mathbf{B}_i \\neq i$（所有 $i$）\n\n**测试集 1（8 分，可见判定）**\n\n- $1 \\leq \\mathbf{N} \\leq 100$\n- $i - 5 \\leq \\mathbf{B}_i \\leq i + 5$（所有隧道都连接到附近的箱子）\n\n**测试集 2（42 分，隐藏判定）**\n\n- $1 \\leq \\mathbf{N} \\leq 5000$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13005", "type": "P", "difficulty": 7, "samples": [["3\n9\n8 2\n10 2\n2 0\n0 5\n2 3\n10 4\n10 0\n8 3\n2 4\n7\n0 0\n0 3\n3 0\n0 1\n1 0\n1 1\n2 2\n3\n0 0\n0 1\n0 2", "Case #1: 3\n3 4 5\n1 7 9\n6 2 8\nCase #2: 2\n2 3 1\n6 5 4\nCase #3: 0"]], "limits": {"time": [15000, 15000, 15000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "计算几何", "2022", "Special Judge", "构造", "Google Code Jam"], "title": "[GCJ 2022 Finals] Triangles", "background": "", "description": "You are given a set $P$ of $\\mathbf{N}$ distinct points in the two-dimensional plane. You want to find a maximum set of triangles such that:\n\n*   Each vertex of a triangle in your set is a point from $P$ and each point in $P$ is a vertex of at most one triangle in your set.\n*   Each triangle in your set has positive area (i.e., its 3 vertices are not collinear).\n*   For any two sides of triangles in your set, their intersection is either empty or an endpoint of one of them.\n*   For any two triangles in your set, the intersection of the areas strictly inside those triangles is either empty or equal to one of them.\n\nFor example, the set of triangles depicted below meets the definition above.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jxq6yve2.png)\n\nOn the other hand, each pair of a yellow and a red triangle in the picture below does not meet the definition.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oyhps85j.png)", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing a single integer $\\mathbf{N}$. Then, $\\mathbf{N}$ lines follow. The $i$-th of these lines contains two integers $\\mathbf{X}_i$ and $\\mathbf{Y}_i$ representing the coordinates of the $i$-th point.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum size of a set of triangles with the desired properties. Then, output $y$ more lines. The $j$-th of those lines must contain $p_j$ $q_j$ $r_j$ representing that the $j$-th triangle in your proposed set has the $p_j$-th, $q_j$-th, and $r_j$-th points in the input as vertices. Points in the input are numbered starting from 1.", "hint": "Sample Case #1 is illustrated below. Notice that there are other valid ways to construct a maximum number of triangles.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x975q63y.png)\n\nSample Case #2 is illustrated below. As before, there are other valid ways to construct 2 triangles.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ca1oxq2.png)\n\nIn Sample Case #3, the 3 given points are collinear, so it is not possible to make a valid triangle with them.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $-10^9 \\leq \\mathbf{X}_i \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y}_i \\leq 10^9$, for all $i$.\n- $(\\mathbf{X}_i, \\mathbf{Y}_i) \\neq (\\mathbf{X}_j, \\mathbf{Y}_j)$, for all $i \\neq j$.\n\n**Test Set 1 (8 Pts, Visible Verdict)**\n\n- $3 \\leq \\mathbf{N} \\leq 12$.\n\n**Test Set 2 (42 Pts, Hidden Verdict)**\n\n- $3 \\leq \\mathbf{N} \\leq 3000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2022 Finals] Triangles", "background": "", "description": "You are given a set $P$ of $\\mathbf{N}$ distinct points in the two-dimensional plane. You want to find a maximum set of triangles such that:\n\n*   Each vertex of a triangle in your set is a point from $P$ and each point in $P$ is a vertex of at most one triangle in your set.\n*   Each triangle in your set has positive area (i.e., its 3 vertices are not collinear).\n*   For any two sides of triangles in your set, their intersection is either empty or an endpoint of one of them.\n*   For any two triangles in your set, the intersection of the areas strictly inside those triangles is either empty or equal to one of them.\n\nFor example, the set of triangles depicted below meets the definition above.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jxq6yve2.png)\n\nOn the other hand, each pair of a yellow and a red triangle in the picture below does not meet the definition.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oyhps85j.png)", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing a single integer $\\mathbf{N}$. Then, $\\mathbf{N}$ lines follow. The $i$-th of these lines contains two integers $\\mathbf{X}_i$ and $\\mathbf{Y}_i$ representing the coordinates of the $i$-th point.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum size of a set of triangles with the desired properties. Then, output $y$ more lines. The $j$-th of those lines must contain $p_j$ $q_j$ $r_j$ representing that the $j$-th triangle in your proposed set has the $p_j$-th, $q_j$-th, and $r_j$-th points in the input as vertices. Points in the input are numbered starting from 1.", "hint": "Sample Case #1 is illustrated below. Notice that there are other valid ways to construct a maximum number of triangles.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x975q63y.png)\n\nSample Case #2 is illustrated below. As before, there are other valid ways to construct 2 triangles.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ca1oxq2.png)\n\nIn Sample Case #3, the 3 given points are collinear, so it is not possible to make a valid triangle with them.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $-10^9 \\leq \\mathbf{X}_i \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y}_i \\leq 10^9$, for all $i$.\n- $(\\mathbf{X}_i, \\mathbf{Y}_i) \\neq (\\mathbf{X}_j, \\mathbf{Y}_j)$, for all $i \\neq j$.\n\n**Test Set 1 (8 Pts, Visible Verdict)**\n\n- $3 \\leq \\mathbf{N} \\leq 12$.\n\n**Test Set 2 (42 Pts, Hidden Verdict)**\n\n- $3 \\leq \\mathbf{N} \\leq 3000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2022 Finals] Triangles", "background": "", "description": "给定二维平面上的一个点集 $P$，包含 $\\mathbf{N}$ 个互不相同的点。你需要找到一个最大的三角形集合满足以下条件：\n\n* 集合中每个三角形的顶点都来自 $P$，且 $P$ 中的每个点最多作为一个三角形的一个顶点。\n* 集合中的每个三角形面积必须为正（即三个顶点不共线）。\n* 对于集合中任意两个三角形的边，它们的交集要么为空，要么是其中一条边的端点。\n* 对于集合中任意两个三角形，它们内部区域的交集要么为空，要么完全等于其中一个三角形。\n\n下图展示的三角形集合满足以上所有条件：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jxq6yve2.png)\n\n而下图中任意一对黄色和红色三角形的组合都不满足条件：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oyhps85j.png)", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后每个测试用例的第一行是一个整数 $\\mathbf{N}$，接着 $\\mathbf{N}$ 行，每行包含两个整数 $\\mathbf{X}_i$ 和 $\\mathbf{Y}_i$，表示第 $i$ 个点的坐标。\n", "outputFormat": "对于每个测试用例，首先输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是满足条件的三角形集合的最大大小。然后输出 $y$ 行，每行三个整数 $p_j\\ q_j\\ r_j$，表示第 $j$ 个三角形由输入中的第 $p_j$、$q_j$ 和 $r_j$ 个点组成（点从 1 开始编号）。\n", "hint": "**样例解释**\n\n样例 #1 如下图所示。注意存在其他有效的构造方式也能达到最大三角形数量：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x975q63y.png)\n\n样例 #2 如下图所示。同样存在其他有效的构造方式能组成 2 个三角形：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ca1oxq2.png)\n\n样例 #3 中，所有给定点共线，因此无法组成有效的三角形。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$\n- $-10^9 \\leq \\mathbf{X}_i \\leq 10^9$（所有 $i$）\n- $-10^9 \\leq \\mathbf{Y}_i \\leq 10^9$（所有 $i$）\n- 所有点的坐标互不相同\n\n**测试集 1（8 分，可见判定）**\n\n- $3 \\leq \\mathbf{N} \\leq 12$\n\n**测试集 2（42 分，隐藏判定）**\n\n- $3 \\leq \\mathbf{N} \\leq 3000$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13006", "type": "P", "difficulty": 1, "samples": [["zxx : zxx is weak.", "Plang."], ["zxx : ou is strong.", "Not plang."], ["zxx : zxx is cute.", "Not plang."]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "O2优化", "梦熊比赛"], "title": "【MX-X13-T1】「KDOI-12」在现实和志向中选择现实，否则会一个都得不到的。", "background": "现实中的你加入了一个群聊，这个群聊总是有人说批话。", "description": "定义一句话为 $A\\underline{\\texttt{ : }}B\\underline{\\texttt{ is }}C\\underline{\\texttt{.}}$，其中 $A,B,C$ 均为字符串，分别表示这个人的名称，句子的主语以及表语。\n\n一句话是批话当且仅当这个人在说自己菜，也就是，$A$ 与 $B$ 相同且 $C=\\underline{\\texttt{weak}}$。\n\n现在，你先判断给出的这句话是否是批话。如果是批话输出 `Plang.`，否则输出 `Not plang.`。", "inputFormat": "仅一行，一个形如 $A\\underline{\\texttt{ : }}B\\underline{\\texttt{ is }}C\\underline{\\texttt{.}}$ 的字符串。**保证 $A,B,C$ 由且仅由小写英文字母组成**。", "outputFormat": "仅一行，如果给出句子是批话则输出 `Plang.`，否则输出 `Not plang.`。", "hint": "**【样例解释 \\#1】**\n\n在第一个样例中，$A=\\text{zxx}$，$B=\\text{zxx}$，$C=\\text{weak}$。这句话中，$\\text{zxx}$ 在说自己菜，这是一句批话。因此，应当输出 `Plang.`。\n\n**【数据范围】**\n\n| 测试点编号 | 特殊性质 |\n|:--:|:--:|\n| $1\\sim7$ | A |\n| $8\\sim20$ | 无特殊性质 |\n\n* 特殊性质 A：$C=\\underline{\\texttt{weak}}$。\n\n对于所有数据：保证 $A,B,C$ 为长度不少于 $1$，不超过 $10$ 的由小写英文字母组成的字符串。", "locale": "zh-CN", "translations": {"en": {"title": "【MX-X13-T1】\"KDOI-12\" Choosing Reality Over Ambition in Reality, Otherwise You'll Get Neither.", "background": "In reality, you joined a group chat where people often talk nonsense.", "description": "A sentence is defined as $A\\underline{\\texttt{ : }}B\\underline{\\texttt{ is }}C\\underline{\\texttt{.}}$, where $A$, $B$, and $C$ are strings representing the speaker's name, the subject of the sentence, and the predicative, respectively.  \n\nA sentence is considered nonsense if and only if the speaker is calling themselves weak—that is, $A$ is the same as $B$ and $C=\\underline{\\texttt{weak}}$.  \n\nNow, you need to determine whether the given sentence is nonsense. If it is, output `Plang.`; otherwise, output `Not plang.`.  \n", "inputFormat": "A single line containing a string in the form of $A\\underline{\\texttt{ : }}B\\underline{\\texttt{ is }}C\\underline{\\texttt{.}}$. **It is guaranteed that $A$, $B$, and $C$ consist solely of lowercase English letters**.  \n", "outputFormat": "A single line. If the given sentence is nonsense, output `Plang.`; otherwise, output `Not plang.`.  \n", "hint": "### **Explanation for Sample #1**\n\nIn the first sample, $A=\\text{zxx}$, $B=\\text{zxx}$, and $C=\\text{weak}$. Here, $\\text{zxx}$ is calling themselves weak, which qualifies as nonsense. Therefore, the output should be `Plang.`.  \n\n### **Data Range**\n\n| Test Case ID | Special Property |\n|:--:|:--:|\n| $1\\sim7$ | A |\n| $8\\sim20$ | No special property |\n\n* **Special Property A**: $C=\\underline{\\texttt{weak}}$.  \n\nFor all test cases: It is guaranteed that $A$, $B$, and $C$ are strings consisting solely of lowercase English letters, with lengths between $1$ and $10$ (inclusive).  \n\n---\n\n*Translated by DeepSeek V3.*", "locale": "en"}, "zh-CN": {"title": "【MX-X13-T1】「KDOI-12」在现实和志向中选择现实，否则会一个都得不到的。", "background": "现实中的你加入了一个群聊，这个群聊总是有人说批话。", "description": "定义一句话为 $A\\underline{\\texttt{ : }}B\\underline{\\texttt{ is }}C\\underline{\\texttt{.}}$，其中 $A,B,C$ 均为字符串，分别表示这个人的名称，句子的主语以及表语。\n\n一句话是批话当且仅当这个人在说自己菜，也就是，$A$ 与 $B$ 相同且 $C=\\underline{\\texttt{weak}}$。\n\n现在，你先判断给出的这句话是否是批话。如果是批话输出 `Plang.`，否则输出 `Not plang.`。", "inputFormat": "仅一行，一个形如 $A\\underline{\\texttt{ : }}B\\underline{\\texttt{ is }}C\\underline{\\texttt{.}}$ 的字符串。**保证 $A,B,C$ 由且仅由小写英文字母组成**。", "outputFormat": "仅一行，如果给出句子是批话则输出 `Plang.`，否则输出 `Not plang.`。", "hint": "**【样例解释 \\#1】**\n\n在第一个样例中，$A=\\text{zxx}$，$B=\\text{zxx}$，$C=\\text{weak}$。这句话中，$\\text{zxx}$ 在说自己菜，这是一句批话。因此，应当输出 `Plang.`。\n\n**【数据范围】**\n\n| 测试点编号 | 特殊性质 |\n|:--:|:--:|\n| $1\\sim7$ | A |\n| $8\\sim20$ | 无特殊性质 |\n\n* 特殊性质 A：$C=\\underline{\\texttt{weak}}$。\n\n对于所有数据：保证 $A,B,C$ 为长度不少于 $1$，不超过 $10$ 的由小写英文字母组成的字符串。", "locale": "zh-CN"}}}
{"pid": "P13007", "type": "P", "difficulty": 3, "samples": [["3\n4 2\n00\n01\n10\n11\n5 4\n1110\n1100\n1000\n0001\n0000\n7 4\n0101\n1101\n1001\n0010\n1110\n0100\n1000", "4\n4\n7"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "O2优化", "枚举", "位运算", "梦熊比赛"], "title": "【MX-X13-T2】「KDOI-12」不要去思考未来，把这留给未来的你。", "background": "未来的你在打一场模拟赛。", "description": "模拟赛中共有 $T$ 道题，每道题有 $n$ 个子任务和 $m$ 个特殊性质。每个子任务均满足 $m$ 个特殊性质的一个子集。\n\n定义一组子任务依赖 $(i,j)$ 表示子任务 $j$ 依赖子任务 $i$，也就是只有通过了子任务 $i$ 才能通过子任务 $j$。\n\n考虑到模拟赛有懒惰的出题人和愚蠢的在线法官，子任务依赖的条数必然是越少越好。现在你想知道最少配置多少组子任务依赖才能保证：\n\n* 不存在一对子任务 $x,y$ 使得满足子任务 $y$ 的数据必然满足子任务 $x$，但是在不通过子任务 $x$ 的情况下**仍然有可能**通过子任务 $y$；\n* 不存在一对子任务 $x,y$ 使得存在满足子任务 $y$ 的数据**不**满足子任务 $x$，但是在不通过子任务 $x$ 的情况下**无法**通过子任务 $y$。\n\n形式化地讲，设第 $i$ 个子任务的特殊性质集合为 $S_i$，那么你要选择尽可能少的 $(u_x,v_x)$ 二元组使得：\n\n* 对于任意 $(i,j)$ 满足 $S_i\\subseteq S_j$，均存在 $j=p_1,p_2,\\dots,p_M=i$ 使得对于任意 $1\\leq k<M$，存在 $x$ 使得 $u_x=p_k,v_x=p_{k+1}$；\n* 对于任意 $(i,j)$ **不**满足 $S_i\\subseteq S_j$，均**不**存在 $j=p_1,p_2,\\dots,p_M=i$ 使得对于任意 $1\\leq k<M$，存在 $x$ 使得 $u_x=p_k,v_x=p_{k+1}$。\n\n并求出选择二元组数量的最小值。", "inputFormat": "第一行，一个正整数 $T$，表示题目数量。对于每道题目：\n\n* 第一行，两个正整数 $n,m$，表示子任务数量和特殊性质数量。\n* 接下来 $n$ 行，每行一个长度为 $m$ 的 `01` 串。第 $i$ 个子任务满足特殊性质 $j$ 当且仅当第 $i$ 行的字符串的第 $j$ 个字符为 `1`。\n\n**保证不存在两个子任务满足的特殊性质相同。**", "outputFormat": "对于每道题目，一行，一个非负整数，表示子任务依赖数量的最小值。", "hint": "**【样例解释】**\n\n对于第二道题目：不妨设四个特殊性质分别为 $\\text{ABCD}$，那么五个子任务分别符合特殊性质 $\\{\\text{ABC}\\}$、$\\{\\text{AB}\\}$、$\\{\\text{A}\\}$、$\\{\\text{D}\\}$、和 $\\varnothing$。可以证明，配置以下子任务依赖符合要求且最优：\n\n* $(1,2)$；\n* $(2,3)$；\n* $(3,5)$；\n* $(4,5)$。\n\n**【数据范围】**\n\n| 测试点编号 | $n,m\\leq$ | 特殊性质 |\n|:--:|:--:|:--:|\n| $1\\sim2$ | $2$ | 无 |\n| $3\\sim9$ | $5$ | 无 |\n| $10\\sim13$ | $10$ | 无 |\n| $14\\sim20$ | $16$ | A |\n| $21\\sim25$ | $16$ | 无 |\n\n* 特殊性质 A：保证每个子任务最多满足两个特殊性质。\n\n对于所有数据：$1\\leq T\\leq 6$，$1\\leq n,m\\leq16$，输入的字符串由 `0` 和 `1` 组成，保证不存在两个子任务满足的特殊性质相同。", "locale": "zh-CN", "translations": {"en": {"title": "T622835 【MX-X13-T2】\"KDOI-12\" Don't Think About the Future, Leave It to Your Future Self  ", "background": "Your future self is participating in a mock contest.  \n", "description": "The mock contest consists of $T$ problems. Each problem has $n$ subtasks and $m$ special properties. Each subtask satisfies a subset of the $m$ special properties.  \n\nA **subtask dependency** $(i,j)$ means that subtask $j$ depends on subtask $i$—that is, subtask $j$ can only be passed after subtask $i$ is passed.  \n\nConsidering that the problem setters are lazy and the online judge is \"not very smart,\" the number of subtask dependencies should be minimized. Now, you need to determine the minimum number of subtask dependencies required to ensure:  \n\n1. There does **not** exist a pair of subtasks $(x, y)$ such that:  \n   - All test cases satisfying subtask $y$ must also satisfy subtask $x$, but  \n   - It is still **possible** to pass subtask $y$ **without** passing subtask $x$.  \n\n2. There does **not** exist a pair of subtasks $(x, y)$ such that:  \n   - There exists a test case satisfying subtask $y$ but **not** satisfying subtask $x$, but  \n   - It is **impossible** to pass subtask $y$ **without** passing subtask $x$.  \n\nFormally, let $S_i$ denote the set of special properties satisfied by subtask $i$. You need to select the smallest possible number of $(u_x, v_x)$ pairs such that:  \n\n- For any $(i,j)$ where $S_i \\subseteq S_j$, there exists a sequence $j = p_1, p_2, \\dots, p_m = i$ such that for all $1 \\leq k < m$, there exists $x$ where $(u_x, v_x) = (p_k, p_{k+1})$.  \n- For any $(i,j)$ where $S_i \\not\\subseteq S_j$, there does **not** exist any sequence $j = p_1, p_2, \\dots, p_m = i$ such that for all $1 \\leq k < m$, there exists $x$ where $(u_x, v_x) = (p_k, p_{k+1})$.  \n\nYour task is to find the minimum number of such pairs.  ", "inputFormat": "- The first line contains a positive integer $T$, the number of problems.  \n- For each problem:  \n  - The first line contains two positive integers $n$ and $m$, the number of subtasks and special properties, respectively.  \n  - The next $n$ lines each contain a binary string of length $m$. The $j$-th character of the $i$-th string is `1` if and only if the $i$-th subtask satisfies the $j$-th special property.  \n  - **It is guaranteed that no two subtasks satisfy the exact same set of special properties.**  \n", "outputFormat": "For each problem, output a single non-negative integer—the minimum number of subtask dependencies required.  \n", "hint": "### **Sample Explanation**  \n\nFor the second problem: Suppose the four special properties are $\\text{ABCD}$. Then, the five subtasks correspond to the following sets:  \n\n- $\\{\\text{A}, \\text{B}, \\text{C}\\}$  \n- $\\{\\text{A}, \\text{B}\\}$  \n- $\\{\\text{A}\\}$  \n- $\\{\\text{D}\\}$  \n- $\\varnothing$ (empty set)  \n\nThe following dependency configuration is optimal:  \n\n- $(1, 2)$  \n- $(2, 3)$  \n- $(3, 5)$  \n- $(4, 5)$  \n\n### **Data Range**  \n\n| Test Case | $n, m \\leq$ | Special Property |  \n|:--:|:--:|:--:|  \n| $1\\sim2$ | $2$ | None |  \n| $3\\sim9$ | $5$ | None |  \n| $10\\sim13$ | $10$ | None |  \n| $14\\sim20$ | $16$ | A |  \n| $21\\sim25$ | $16$ | None |  \n\n- **Special Property A**: Each subtask satisfies at most two special properties.  \n\nFor all test cases:  \n- $1 \\leq T \\leq 6$,  \n- $1 \\leq n, m \\leq 16$,  \n- Input strings consist of `0` and `1`,  \n- No two subtasks share the exact same set of special properties.  \n\n---\n\n*Translated by DeepSeek V3.*  ", "locale": "en"}, "zh-CN": {"title": "【MX-X13-T2】「KDOI-12」不要去思考未来，把这留给未来的你。", "background": "未来的你在打一场模拟赛。", "description": "模拟赛中共有 $T$ 道题，每道题有 $n$ 个子任务和 $m$ 个特殊性质。每个子任务均满足 $m$ 个特殊性质的一个子集。\n\n定义一组子任务依赖 $(i,j)$ 表示子任务 $j$ 依赖子任务 $i$，也就是只有通过了子任务 $i$ 才能通过子任务 $j$。\n\n考虑到模拟赛有懒惰的出题人和愚蠢的在线法官，子任务依赖的条数必然是越少越好。现在你想知道最少配置多少组子任务依赖才能保证：\n\n* 不存在一对子任务 $x,y$ 使得满足子任务 $y$ 的数据必然满足子任务 $x$，但是在不通过子任务 $x$ 的情况下**仍然有可能**通过子任务 $y$；\n* 不存在一对子任务 $x,y$ 使得存在满足子任务 $y$ 的数据**不**满足子任务 $x$，但是在不通过子任务 $x$ 的情况下**无法**通过子任务 $y$。\n\n形式化地讲，设第 $i$ 个子任务的特殊性质集合为 $S_i$，那么你要选择尽可能少的 $(u_x,v_x)$ 二元组使得：\n\n* 对于任意 $(i,j)$ 满足 $S_i\\subseteq S_j$，均存在 $j=p_1,p_2,\\dots,p_M=i$ 使得对于任意 $1\\leq k<M$，存在 $x$ 使得 $u_x=p_k,v_x=p_{k+1}$；\n* 对于任意 $(i,j)$ **不**满足 $S_i\\subseteq S_j$，均**不**存在 $j=p_1,p_2,\\dots,p_M=i$ 使得对于任意 $1\\leq k<M$，存在 $x$ 使得 $u_x=p_k,v_x=p_{k+1}$。\n\n并求出选择二元组数量的最小值。", "inputFormat": "第一行，一个正整数 $T$，表示题目数量。对于每道题目：\n\n* 第一行，两个正整数 $n,m$，表示子任务数量和特殊性质数量。\n* 接下来 $n$ 行，每行一个长度为 $m$ 的 `01` 串。第 $i$ 个子任务满足特殊性质 $j$ 当且仅当第 $i$ 行的字符串的第 $j$ 个字符为 `1`。\n\n**保证不存在两个子任务满足的特殊性质相同。**", "outputFormat": "对于每道题目，一行，一个非负整数，表示子任务依赖数量的最小值。", "hint": "**【样例解释】**\n\n对于第二道题目：不妨设四个特殊性质分别为 $\\text{ABCD}$，那么五个子任务分别符合特殊性质 $\\{\\text{ABC}\\}$、$\\{\\text{AB}\\}$、$\\{\\text{A}\\}$、$\\{\\text{D}\\}$、和 $\\varnothing$。可以证明，配置以下子任务依赖符合要求且最优：\n\n* $(1,2)$；\n* $(2,3)$；\n* $(3,5)$；\n* $(4,5)$。\n\n**【数据范围】**\n\n| 测试点编号 | $n,m\\leq$ | 特殊性质 |\n|:--:|:--:|:--:|\n| $1\\sim2$ | $2$ | 无 |\n| $3\\sim9$ | $5$ | 无 |\n| $10\\sim13$ | $10$ | 无 |\n| $14\\sim20$ | $16$ | A |\n| $21\\sim25$ | $16$ | 无 |\n\n* 特殊性质 A：保证每个子任务最多满足两个特殊性质。\n\n对于所有数据：$1\\leq T\\leq 6$，$1\\leq n,m\\leq16$，输入的字符串由 `0` 和 `1` 组成，保证不存在两个子任务满足的特殊性质相同。", "locale": "zh-CN"}}}
{"pid": "P13008", "type": "P", "difficulty": 4, "samples": [["5\n2 4 1\n2 5\n2 5 2\n2 5 2\n3 9 2\n1 2 3\n4 23 3\n1 5 2 4\n1 114 5\n1 4 1 9 19 8", "4\n4\n5\n11\n29"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "贪心", "O2优化", "位运算", "梦熊比赛"], "title": "【MX-X13-T3】「KDOI-12」只有失去光明，才能逃脱黑暗。", "background": "", "description": "给定一个非负整数 $x$，你要经过若干次以下操作将其变成 $y$，求最小代价：\n\n* 选择一个 $0\\leq i\\leq k$，花费 $a_i$ 代价将 $x$ 加或减 $2^i$。\n\n**注意：你在操作时不需要保证 $x$ 为非负整数。**", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个正整数 $T$，表示测试数据组数。对于每组测试数据：\n\n* 第一行，三个非负整数 $x,y,k$。\n* 第二行，$k+1$ 个正整数 $a_0, \\ldots, a_k$。", "outputFormat": "对于每组测试数据，一行，一个非负整数，表示最小代价。", "hint": "**【样例解释】**\n\n对于样例的第二组测试数据：经过以下两次操作即可让 $x$ 变为 $y$，且代价最小：\n\n* 取 $i=2$，令 $x\\gets x+2^2$，此时 $x=6$，总代价为 $2$；\n* 取 $i=0$，令 $x\\gets x-2^0$，此时 $x=5$，总代价为 $4$。\n\n**【数据范围】**\n\n**本题使用捆绑测试。**\n\n| 子任务编号 | 分值 | $T\\leq$ | $x,y<$ | $k\\leq$ | $a_i$  |\n|:--:|:--:|:--:|:--:|:--:|:--:|\n| $1$ | $6$ | $10^3$ | $2^3$ | $3$ | $\\leq10^9$ |\n| $2$ | $15$ | $10^3$ | $2^{10}$ | $10$ | $\\leq10^9$ |\n| $3$ | $21$ | $2\\times10^5$ | $2^{30}$ | $1$ | $\\leq10^9$ |\n| $4$ | $27$ | $2\\times10^5$ | $2^{30}$ | $30$ | $\\leq2$ |\n| $5$ | $20$ | $10^4$ | $2^{30}$ | $30$ | $\\leq10^9$ |\n| $6$ | $11$ | $2\\times10^5$ | $2^{30}$ | $30$ | $\\leq10^9$ |\n\n对于所有数据：$1\\leq T\\leq2\\times10^5$，$0\\leq x,y<2^{30}$，$1\\leq k\\leq 30$，$1\\leq a_i\\leq10^9$。\n\n**【提示】**\n\n请使用较快的读入方式。", "locale": "zh-CN", "translations": {"en": {"title": "【MX-X13-T3】\"KDOI-12\" Only by Losing Light Can You Escape Darkness", "background": "", "description": "Given a non-negative integer $x$, you need to transform it into $y$ through a series of operations with the minimum cost. Each operation is defined as follows:\n\n* Choose an integer $0 \\leq i \\leq k$, and pay a cost of $a_i$ to either add or subtract $2^i$ from $x$.\n\n**Note: You do not need to ensure that $x$ remains non-negative during the operations.**", "inputFormat": "For each test case, output a single non-negative integer—the minimum cost required to transform $x$ into $y$.\n", "outputFormat": "For each test case, output a single non-negative integer—the minimum cost required to transform $x$ into $y$.\n", "hint": "### **Sample Explanation**\n\nFor the second test case in the sample input, the following two operations transform $x$ into $y$ with the minimum cost:\n\n1. Choose $i=2$, perform $x \\gets x + 2^2$, resulting in $x=6$ with a cost of $2$.\n2. Choose $i=0$, perform $x \\gets x - 2^0$, resulting in $x=5$ with an additional cost of $2$, totaling $4$.\n\n### **Data Range**\n\n**This problem uses bundled testing.**\n\n| Subtask | Points | $T \\leq$ | $x, y <$ | $k \\leq$ | $a_i$ |\n|:--:|:--:|:--:|:--:|:--:|:--:|\n| $1$ | $6$ | $10^3$ | $2^3$ | $3$ | $\\leq 10^9$ |\n| $2$ | $15$ | $10^3$ | $2^{10}$ | $10$ | $\\leq 10^9$ |\n| $3$ | $21$ | $2 \\times 10^5$ | $2^{30}$ | $1$ | $\\leq 10^9$ |\n| $4$ | $27$ | $2 \\times 10^5$ | $2^{30}$ | $30$ | $\\leq 2$ |\n| $5$ | $20$ | $10^4$ | $2^{30}$ | $30$ | $\\leq 10^9$ |\n| $6$ | $11$ | $2 \\times 10^5$ | $2^{30}$ | $30$ | $\\leq 10^9$ |\n\nFor all test cases:  \n- $1 \\leq T \\leq 2 \\times 10^5$,  \n- $0 \\leq x, y < 2^{30}$,  \n- $1 \\leq k \\leq 30$,  \n- $1 \\leq a_i \\leq 10^9$.  \n\n### **Hint**\n\nPlease use fast input methods for reading data.\n\n---\n\n*Translated by DeepSeek V3.*  ", "locale": "en"}, "zh-CN": {"title": "【MX-X13-T3】「KDOI-12」只有失去光明，才能逃脱黑暗。", "background": "", "description": "给定一个非负整数 $x$，你要经过若干次以下操作将其变成 $y$，求最小代价：\n\n* 选择一个 $0\\leq i\\leq k$，花费 $a_i$ 代价将 $x$ 加或减 $2^i$。\n\n**注意：你在操作时不需要保证 $x$ 为非负整数。**", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个正整数 $T$，表示测试数据组数。对于每组测试数据：\n\n* 第一行，三个非负整数 $x,y,k$。\n* 第二行，$k+1$ 个正整数 $a_0, \\ldots, a_k$。", "outputFormat": "对于每组测试数据，一行，一个非负整数，表示最小代价。", "hint": "**【样例解释】**\n\n对于样例的第二组测试数据：经过以下两次操作即可让 $x$ 变为 $y$，且代价最小：\n\n* 取 $i=2$，令 $x\\gets x+2^2$，此时 $x=6$，总代价为 $2$；\n* 取 $i=0$，令 $x\\gets x-2^0$，此时 $x=5$，总代价为 $4$。\n\n**【数据范围】**\n\n**本题使用捆绑测试。**\n\n| 子任务编号 | 分值 | $T\\leq$ | $x,y<$ | $k\\leq$ | $a_i$  |\n|:--:|:--:|:--:|:--:|:--:|:--:|\n| $1$ | $6$ | $10^3$ | $2^3$ | $3$ | $\\leq10^9$ |\n| $2$ | $15$ | $10^3$ | $2^{10}$ | $10$ | $\\leq10^9$ |\n| $3$ | $21$ | $2\\times10^5$ | $2^{30}$ | $1$ | $\\leq10^9$ |\n| $4$ | $27$ | $2\\times10^5$ | $2^{30}$ | $30$ | $\\leq2$ |\n| $5$ | $20$ | $10^4$ | $2^{30}$ | $30$ | $\\leq10^9$ |\n| $6$ | $11$ | $2\\times10^5$ | $2^{30}$ | $30$ | $\\leq10^9$ |\n\n对于所有数据：$1\\leq T\\leq2\\times10^5$，$0\\leq x,y<2^{30}$，$1\\leq k\\leq 30$，$1\\leq a_i\\leq10^9$。\n\n**【提示】**\n\n请使用较快的读入方式。", "locale": "zh-CN"}}}
{"pid": "P13009", "type": "P", "difficulty": 4, "samples": [["3\n2 5\n1 2\n5 10\n1 5 2 4 3\n10 10\n1 4 2 5 1 6 2 7 1 10", "7 1\n28 3\n80 5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "贪心", "O2优化", "整除分块", "梦熊比赛"], "title": "【MX-X13-T4】「KDOI-12」好胜是人的本能，功利是社会的本性。", "background": "", "description": "给定一个长度为 $n$ 的正整数序列 $a_1, \\ldots, a_n$ 以及一个正整数 $m$ 满足 $m \\ge \\max a_i$。\n\n你可以对序列进行任意次操作（也可以不操作）。每次操作你可以选择一个区间 $[l,r]$，然后对于所有 $l\\leq i\\leq r$，令 $a_i\\gets\\bigl\\lfloor\\frac{m}{a_i}\\bigr\\rfloor$。\n\n求可以得到的 $\\sum_{j=1}^na_j$ 的最大值以及对应的最少操作次数。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个正整数 $T$，表示测试数据组数。对于每组测试数据：\n\n* 第一行，两个正整数 $n,m$。\n* 第二行，$n$ 个正整数 $a_1, \\ldots, a_n$。", "outputFormat": "对于每组测试数据，一行，两个非负整数，分别表示 $\\sum_{j=1}^na_j$ 的最大值以及对应的最少操作次数。", "hint": "**【样例解释】**\n\n对于样例的第二组测试数据：选择以下 $3$ 组 $[l,r]$ 即可得到最大值 $28$：\n\n* $[1,2]$；\n* $[2,5]$；\n* $[4,5]$。\n\n可以证明该方案是最优的之一。\n\n**【数据范围】**\n\n**本题使用捆绑测试。**\n\n| 子任务编号 | 分值 | $n\\leq$ | $\\sum n\\leq$ | 特殊性质 |\n|:--:|:--:|:--:|:--:|:--:|\n| $1$ | $9$ | $4$ | $400$ | 无 |\n| $2$ | $27$ | $10^3$ | $10^4$ | 无 |\n| $3$ | $11$ | $10^5$ | $10^6$ | A |\n| $4$ | $16$ | $10^5$ | $10^6$ | B |\n| $5$ | $37$ | $10^5$ | $10^6$ | 无 |\n\n* 特殊性质 A：$a_i\\leq\\sqrt m$；\n* 特殊性质 B：$a_i\\mid m$。\n\n对于所有数据：$1\\leq T\\leq 10^5$，$1\\leq n\\leq 10^5$，$1\\leq\\sum n\\leq10^6$，$1\\leq a_i\\leq m\\leq10^{12}$。", "locale": "zh-CN", "translations": {"en": {"title": "【MX-X13-T4】\"KDOI-12\" Competitiveness is Human Nature, Utility is Society's Nature", "background": "", "description": "Given a sequence of positive integers $a_1, \\ldots, a_n$ of length $n$ and a positive integer $m$ satisfying $m \\geq \\max a_i$, you can perform any number of operations (including zero) on the sequence. In each operation, you may select an interval $[l, r]$ and for all $l \\leq i \\leq r$, set $a_i \\gets \\left\\lfloor \\frac{m}{a_i} \\right\\rfloor$. \n\nYour task is to determine:\n1. The maximum possible value of $\\sum_{j=1}^n a_j$ achievable through these operations.\n2. The minimum number of operations required to achieve this maximum sum.", "inputFormat": "**This problem contains multiple test cases.**\n\n- The first line contains a positive integer $T$, the number of test cases.\n- For each test case:\n  - The first line contains two positive integers $n$ and $m$.\n  - The second line contains $n$ positive integers $a_1, \\ldots, a_n$.", "outputFormat": "For each test case, output two non-negative integers:\n1. The maximum possible sum $\\sum_{j=1}^n a_j$.\n2. The minimum number of operations required to achieve this sum.", "hint": "### **Sample Explanation**\n\nFor the second test case in the sample input, selecting the following 3 intervals achieves the maximum sum of $28$:\n\n1. $[1, 2]$\n2. $[2, 5]$\n3. $[4, 5]$\n\nIt can be proven that this is one of the optimal solutions.\n\n### **Data Range**\n\n**This problem uses bundled testing.**\n\n| Subtask | Points | $n \\leq$ | $\\sum n \\leq$ | Special Properties |\n|:--:|:--:|:--:|:--:|:--:|\n| $1$ | $9$ | $4$ | $400$ | None |\n| $2$ | $27$ | $10^3$ | $10^4$ | None |\n| $3$ | $11$ | $10^5$ | $10^6$ | A |\n| $4$ | $16$ | $10^5$ | $10^6$ | B |\n| $5$ | $37$ | $10^5$ | $10^6$ | None |\n\n- **Special Property A**: $a_i \\leq \\sqrt{m}$.\n- **Special Property B**: $a_i$ divides $m$ (i.e., $a_i \\mid m$).\n\nFor all test cases:\n- $1 \\leq T \\leq 10^5$,\n- $1 \\leq n \\leq 10^5$,\n- $1 \\leq \\sum n \\leq 10^6$,\n- $1 \\leq a_i \\leq m \\leq 10^{12}$.\n\n---\n\n*Translated by DeepSeek V3.*", "locale": "en"}, "zh-CN": {"title": "【MX-X13-T4】「KDOI-12」好胜是人的本能，功利是社会的本性。", "background": "", "description": "给定一个长度为 $n$ 的正整数序列 $a_1, \\ldots, a_n$ 以及一个正整数 $m$ 满足 $m \\ge \\max a_i$。\n\n你可以对序列进行任意次操作（也可以不操作）。每次操作你可以选择一个区间 $[l,r]$，然后对于所有 $l\\leq i\\leq r$，令 $a_i\\gets\\bigl\\lfloor\\frac{m}{a_i}\\bigr\\rfloor$。\n\n求可以得到的 $\\sum_{j=1}^na_j$ 的最大值以及对应的最少操作次数。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个正整数 $T$，表示测试数据组数。对于每组测试数据：\n\n* 第一行，两个正整数 $n,m$。\n* 第二行，$n$ 个正整数 $a_1, \\ldots, a_n$。", "outputFormat": "对于每组测试数据，一行，两个非负整数，分别表示 $\\sum_{j=1}^na_j$ 的最大值以及对应的最少操作次数。", "hint": "**【样例解释】**\n\n对于样例的第二组测试数据：选择以下 $3$ 组 $[l,r]$ 即可得到最大值 $28$：\n\n* $[1,2]$；\n* $[2,5]$；\n* $[4,5]$。\n\n可以证明该方案是最优的之一。\n\n**【数据范围】**\n\n**本题使用捆绑测试。**\n\n| 子任务编号 | 分值 | $n\\leq$ | $\\sum n\\leq$ | 特殊性质 |\n|:--:|:--:|:--:|:--:|:--:|\n| $1$ | $9$ | $4$ | $400$ | 无 |\n| $2$ | $27$ | $10^3$ | $10^4$ | 无 |\n| $3$ | $11$ | $10^5$ | $10^6$ | A |\n| $4$ | $16$ | $10^5$ | $10^6$ | B |\n| $5$ | $37$ | $10^5$ | $10^6$ | 无 |\n\n* 特殊性质 A：$a_i\\leq\\sqrt m$；\n* 特殊性质 B：$a_i\\mid m$。\n\n对于所有数据：$1\\leq T\\leq 10^5$，$1\\leq n\\leq 10^5$，$1\\leq\\sum n\\leq10^6$，$1\\leq a_i\\leq m\\leq10^{12}$。", "locale": "zh-CN"}}}
{"pid": "P13010", "type": "P", "difficulty": 5, "samples": [["4\n1 3 1\n1 1 3\n2 1 1\n1 5 2\n1 2 2 1 3\n3 2 1 2 2\n2 5 1\n2 3 1 3 3\n2 1 3 1 1\n3 6 2\n3 5 2 4 1 6\n2 3 4 5 6 1", "1.5000000000\n2.0000000000\n1.5000000000\n3.0000000000\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "二分", "Special Judge", "O2优化", "梦熊比赛"], "title": "【MX-X13-T5】「KDOI-12」茫茫人海如都市的晚高峰，迎面的车终将相遇，迎面的车终将分别。", "background": "", "description": "一条大道共有从北到南和从南到北两个方向，记作方向 $1$ 和方向 $2$。  \n\n每个方向都各有一条基础车道，除此之外，大道还有 $n$ 条动态车道。\n\n一天共会经过 $m$ 个时刻，编号为 $1 \\sim m$，其中第 $i$ 个时刻 $j$ 方向会有 $c_{i, j}$ 辆车驶过。\n\n在每一个时刻 $i$，每一条动态车道 $j$ 都会有 $3$ 种情况，记为 $t_{i, j}$（$t_{i, j}\\in \\{0, 1, 2\\}$）。  \n其中若 $t_{i, j} = 0$ 则代表这条动态车道无法通行，否则其值就代表这条动态车道允许通过的方向。\n\n动态车道不能随意调转方向，有一个值 $C$ 代表调换动态车道的方向所需要的时间。  \n具体来说，如果在 $x$ 时刻与 $x + 1$ 时刻之间决定调换动态车道 $j$（$t_{x, j} \\ne 0$）的方向。  \n那么对于 $y \\in [x + 1, x + C]$，有 $t_{y, j} = 0$。从 $x + C + 1$ 时刻开始（到下一次调转方向为止），$t_{*, j}$ 才变为 $3 - t_{x, j}$。 \n\n特殊的是，对于 $1$ 时刻，可以直接为每个动态车道分配好其对应的方向。\n\n定义时刻 $i$ 时方向 $j$ 的负载量 $v_{i, j}$ 是该时刻通过这个方向的车辆数量与能够通过的车道数量（包括基础和动态车道）的比值，即 $v_{i, j} = \\frac{c_{i, j}}{1 + \\sum_{k = 1}^n [t_{i, k} = j]}$。  \n\n你需要求出在合理的调配下，最大负载量的最小值是多少。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个正整数 $T$，表示测试数据组数。对于每组测试数据：\n\n* 第一行，三个正整数 $n, m, C$。\n* 第二行，$m$ 个正整数 $c_{1, 1}, \\ldots, c_{m, 1}$，表示在每个时刻通过方向 $1$ 的车辆数量。\n* 第三行，$m$ 个正整数 $c_{1, 2}, \\ldots, c_{m, 2}$，表示在每个时刻通过方向 $2$ 的车辆数量。", "outputFormat": "对于每组测试数据，一行，一个小数，表示最大负载量的最小值。\n\n**本题使用自定义校验器**，你的答案与正确答案的绝对误差或相对误差在 $10^{-6}$ 内即可算做正确。", "hint": "**【样例解释】**\n\n对于样例的第一组测试数据：令 $t_{1, 1} = 2, t_{2, 1} = 0, t_{3, 1} = 1$，这样有 $v_{1, 1} = v_{1, 2} = v_{2, 1} = v_{2, 2} = v_{3, 2} = 1, v_{3, 1} = 1.5$，最大负载量为 $1.5$。可以证明没有比 $1.5$ 更优的分配。\n\n**【数据范围】**\n\n**本题使用捆绑测试。**\n\n| 子任务编号 | 分值 | $n\\leq$ | $C\\leq$ | $\\sum m\\leq$ |\n|:--:|:--:|:--:|:--:|:--:|\n| $1$ | $15$ | $1$ | $m-1$ | $5\\times10^5$ |\n| $2$ | $20$ | $10^5$ | $1$ | $5\\times10^5$ |\n| $3$ | $15$ | $10^5$ | $m-1$ | $100$ |\n| $4$ | $20$ | $10^5$ | $m-1$ | $5\\times10^4$ |\n| $5$ | $30$ | $10^5$ | $m-1$ | $5\\times10^5$ |\n\n对于所有数据：$1\\leq T\\leq10^4$，$1\\le n\\le 10^5$，$1\\le c_{i, 1}, c_{i, 2}\\le 10^5$，$1\\le C < m\\leq5\\times10^5$，$\\sum m\\le 5\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "【MX-X13-T5】\"In the Vast Sea of People Like the Evening Rush Hour in the City\"", "background": "", "description": "A main road has two directions: from north to south and from south to north, denoted as direction $1$ and direction $2$, respectively.  \n\nEach direction has one base lane. Additionally, the road has $n$ dynamic lanes.\n\nA day consists of $m$ moments, numbered from $1$ to $m$, where at the $i$-th moment, $c_{i, j}$ cars pass through direction $j$.\n\nAt each moment $i$, each dynamic lane $j$ can be in one of three states, denoted as $t_{i, j}$ ($t_{i, j} \\in \\{0, 1, 2\\}$).  \nIf $t_{i, j} = 0$, it means the dynamic lane is impassable. Otherwise, its value indicates the direction allowed for passage.  \n\nThe direction of dynamic lanes cannot be freely switched. A parameter $C$ represents the time required to switch the direction of a dynamic lane.  \nSpecifically, if the direction of dynamic lane $j$ is decided to switch between moment $x$ and $x + 1$ (where $t_{x, j} \\ne 0$),  \nthen for $y \\in [x + 1, x + C]$, $t_{y, j} = 0$. Starting from moment $x + C + 1$ (until the next switch), $t_{*, j}$ becomes $3 - t_{x, j}$.  \n\nAs a special case, for the first moment ($1$), the direction of each dynamic lane can be directly assigned.\n\nDefine the **load** $v_{i, j}$ of direction $j$ at moment $i$ as the ratio of the number of cars passing through this direction to the number of available lanes (including the base lane and dynamic lanes), i.e., $v_{i, j} = \\frac{c_{i, j}}{1 + \\sum_{k = 1}^n [t_{i, k} = j]}$.  \n\nYour task is to determine the minimum possible maximum load under a reasonable allocation scheme.", "inputFormat": "**There are multiple test cases in this problem.**\n\nThe first line contains a positive integer $T$, the number of test cases. For each test case:\n\n* The first line contains three positive integers $n, m, C$.  \n* The second line contains $m$ positive integers $c_{1, 1}, \\ldots, c_{m, 1}$, representing the number of cars passing through direction $1$ at each moment.  \n* The third line contains $m$ positive integers $c_{1, 2}, \\ldots, c_{m, 2}$, representing the number of cars passing through direction $2$ at each moment.  \n", "outputFormat": "For each test case, output a single line with a decimal number, representing the minimum possible maximum load.  \n\n**This problem uses a custom checker.** Your answer will be considered correct if its absolute or relative error compared to the correct answer is within $10^{-6}$.\n", "hint": "**【Sample Explanation】**\n\nFor the first test case in the sample: Let $t_{1, 1} = 2$, $t_{2, 1} = 0$, and $t_{3, 1} = 1$. Then, $v_{1, 1} = v_{1, 2} = v_{2, 1} = v_{2, 2} = v_{3, 2} = 1$, and $v_{3, 1} = 1.5$. The maximum load is $1.5$. It can be proven that no allocation yields a better result than $1.5$.\n\n**【Data Range】**\n\n**This problem uses bundled testing.**\n\n| Subtask ID | Points | $n\\leq$ | $C\\leq$ | $\\sum m\\leq$ |\n|:--:|:--:|:--:|:--:|:--:|\n| $1$ | $15$ | $1$ | $m-1$ | $5\\times10^5$ |\n| $2$ | $20$ | $10^5$ | $1$ | $5\\times10^5$ |\n| $3$ | $15$ | $10^5$ | $m-1$ | $100$ |\n| $4$ | $20$ | $10^5$ | $m-1$ | $5\\times10^4$ |\n| $5$ | $30$ | $10^5$ | $m-1$ | $5\\times10^5$ |\n\nFor all data:  \n$1 \\leq T \\leq 10^4$,  \n$1 \\le n \\le 10^5$,  \n$1 \\le c_{i, 1}, c_{i, 2} \\le 10^5$,  \n$1 \\le C < m \\leq 5 \\times 10^5$,  \n$\\sum m \\le 5 \\times 10^5$.\n\n---\n\nTranslated by DeepSeek V3.", "locale": "en"}, "zh-CN": {"title": "【MX-X13-T5】「KDOI-12」茫茫人海如都市的晚高峰，迎面的车终将相遇，迎面的车终将分别。", "background": "", "description": "一条大道共有从北到南和从南到北两个方向，记作方向 $1$ 和方向 $2$。  \n\n每个方向都各有一条基础车道，除此之外，大道还有 $n$ 条动态车道。\n\n一天共会经过 $m$ 个时刻，编号为 $1 \\sim m$，其中第 $i$ 个时刻 $j$ 方向会有 $c_{i, j}$ 辆车驶过。\n\n在每一个时刻 $i$，每一条动态车道 $j$ 都会有 $3$ 种情况，记为 $t_{i, j}$（$t_{i, j}\\in \\{0, 1, 2\\}$）。  \n其中若 $t_{i, j} = 0$ 则代表这条动态车道无法通行，否则其值就代表这条动态车道允许通过的方向。\n\n动态车道不能随意调转方向，有一个值 $C$ 代表调换动态车道的方向所需要的时间。  \n具体来说，如果在 $x$ 时刻与 $x + 1$ 时刻之间决定调换动态车道 $j$（$t_{x, j} \\ne 0$）的方向。  \n那么对于 $y \\in [x + 1, x + C]$，有 $t_{y, j} = 0$。从 $x + C + 1$ 时刻开始（到下一次调转方向为止），$t_{*, j}$ 才变为 $3 - t_{x, j}$。 \n\n特殊的是，对于 $1$ 时刻，可以直接为每个动态车道分配好其对应的方向。\n\n定义时刻 $i$ 时方向 $j$ 的负载量 $v_{i, j}$ 是该时刻通过这个方向的车辆数量与能够通过的车道数量（包括基础和动态车道）的比值，即 $v_{i, j} = \\frac{c_{i, j}}{1 + \\sum_{k = 1}^n [t_{i, k} = j]}$。  \n\n你需要求出在合理的调配下，最大负载量的最小值是多少。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，一个正整数 $T$，表示测试数据组数。对于每组测试数据：\n\n* 第一行，三个正整数 $n, m, C$。\n* 第二行，$m$ 个正整数 $c_{1, 1}, \\ldots, c_{m, 1}$，表示在每个时刻通过方向 $1$ 的车辆数量。\n* 第三行，$m$ 个正整数 $c_{1, 2}, \\ldots, c_{m, 2}$，表示在每个时刻通过方向 $2$ 的车辆数量。", "outputFormat": "对于每组测试数据，一行，一个小数，表示最大负载量的最小值。\n\n**本题使用自定义校验器**，你的答案与正确答案的绝对误差或相对误差在 $10^{-6}$ 内即可算做正确。", "hint": "**【样例解释】**\n\n对于样例的第一组测试数据：令 $t_{1, 1} = 2, t_{2, 1} = 0, t_{3, 1} = 1$，这样有 $v_{1, 1} = v_{1, 2} = v_{2, 1} = v_{2, 2} = v_{3, 2} = 1, v_{3, 1} = 1.5$，最大负载量为 $1.5$。可以证明没有比 $1.5$ 更优的分配。\n\n**【数据范围】**\n\n**本题使用捆绑测试。**\n\n| 子任务编号 | 分值 | $n\\leq$ | $C\\leq$ | $\\sum m\\leq$ |\n|:--:|:--:|:--:|:--:|:--:|\n| $1$ | $15$ | $1$ | $m-1$ | $5\\times10^5$ |\n| $2$ | $20$ | $10^5$ | $1$ | $5\\times10^5$ |\n| $3$ | $15$ | $10^5$ | $m-1$ | $100$ |\n| $4$ | $20$ | $10^5$ | $m-1$ | $5\\times10^4$ |\n| $5$ | $30$ | $10^5$ | $m-1$ | $5\\times10^5$ |\n\n对于所有数据：$1\\leq T\\leq10^4$，$1\\le n\\le 10^5$，$1\\le c_{i, 1}, c_{i, 2}\\le 10^5$，$1\\le C < m\\leq5\\times10^5$，$\\sum m\\le 5\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P13011", "type": "P", "difficulty": 6, "samples": [["10 1000000007\n4 1 4\n4 2 2\n4 3 2\n5 4 2\n7 3 5\n8 2 7\n10 3 8\n100 99 6\n1000 234 789\n5000 1234 4321", "6\n24\n8\n25\n882\n3840\n270000\n220955222\n251832899\n768412458\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "数学", "O2优化", "组合数学", "容斥原理", "梦熊比赛"], "title": "【MX-X13-T6】「KDOI-12」能做到的也只不过是静等缘分耗尽的那一天。", "background": "待到缘分耗尽，关系断裂，我们还会在一起吗？", "description": "对于一个排列 $p_{1\\sim n}$，建出其大根[笛卡尔树](https://www.luogu.com.cn/problem/P5854)，并断开每个点与其右儿子（如果存在）的连边，记最后所成的森林为 $T(p)$。\n\n例如 $p_{1\\sim 5} = [1, 3, 2, 5, 4]$，其大根笛卡尔树与 $T(p)$ 分别如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6mikhar1.png)![](https://cdn.luogu.com.cn/upload/image_hosting/otv9hnhe.png)\n\n在给定 $n, x, y$ 的情况下，你需要回答，在 $n!$ 种 $1\\sim n$ 的排列 $p_{1\\sim n}$ 中，有多少种 $p$ 使得节点 $x$ 与节点 $y$ 在 $T(p)$ 中属于同一棵树。**节点指的是编号而非在 $p$ 中的权值。**\n\n由于答案可能很大，输出的答案需要对一个质数 $P$ 取模。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，两个正整数 $T, P$，表示测试数据组数与模数。**保证 $\\bm P$ 为质数**。对于每组测试数据：\n\n* 仅一行，三个正整数 $n, x, y$。", "outputFormat": "对于每组测试数据，一行，一个非负整数，表示满足题目条件的排列数量，对 $P$ 取模。", "hint": "**【样例解释】**\n\n对于样例的第一组测试数据：有 $[1, 2, 3, 4], [1, 3, 2, 4], [2, 1, 3, 4], [2, 3, 1, 4], [3, 1, 2, 4], [3, 2, 1, 4]$ 共 $6$ 种排列满足条件。\n\n对于样例的第二组测试数据：任意 $1\\sim 4$ 的排列均满足条件。\n\n**【数据范围】**\n\n**本题使用捆绑测试。**\n\n| 子任务编号 | 分值 | $n\\leq$ | $T\\leq$ | 特殊性质 |\n|:--:|:--:|:--:|:--:|:--:|\n| $1$ | $5$ | $8$ | $10^6$ | 无 |\n| $2$ | $15$ | $2000$ | $2000$ | 无 |\n| $3$ | $15$ | $2000$ | $10^6$ | 无 |\n| $4$ | $25$ | $5\\times10^6$ | $20$ | 无 |\n| $5$ | $15$ | $10^5$ | $10^6$ | A |\n| $6$ | $25$ | $5\\times10^6$ | $10^6$ | 无 |\n\n* 特殊性质 A：$P=998244353$。\n\n对于所有数据：$1\\leq T\\leq10^6$，$1\\le x, y\\le n\\le 5\\times 10^6$，$10^8\\le P\\le 10^9 + 7$ 且 $P$ 为质数。\n\n**【提示】**\n\n请使用较快的读入方式。", "locale": "zh-CN", "translations": {"en": {"title": "【MX-X13-T6】\"All I Can Do Is Quietly Wait for the Day When Fate Runs Out\"", "background": "When fate runs out and relationships break, will we still be together?\n", "description": "For a permutation $p_{1\\sim n}$, construct its **max-heap Cartesian tree**, then disconnect the edge between each node and its right child (if it exists). Denote the resulting forest as $T(p)$.  \n\nFor example, consider $p_{1\\sim 5} = [1, 3, 2, 5, 4]$. The max-heap Cartesian tree and $T(p)$ are shown below:  \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6mikhar1.png)![](https://cdn.luogu.com.cn/upload/image_hosting/otv9hnhe.png)  \n\nGiven $n, x, y$, you need to determine how many of the $n!$ permutations of $1\\sim n$ satisfy that nodes $x$ and $y$ belong to the same tree in $T(p)$. **Nodes are identified by their indices, not their values in $p$.**  \n\nSince the answer may be large, output it modulo a prime $P$.  ", "inputFormat": "**This problem contains multiple test cases.**  \n\nThe first line contains two positive integers $T$ and $P$, representing the number of test cases and the modulo. **It is guaranteed that $\\bm{P}$ is a prime.** For each test case:  \n- One line with three positive integers $n, x, y$. ", "outputFormat": "For each test case, output a non-negative integer indicating the number of valid permutations modulo $P$.  \n", "hint": "### Sample Explanation  \nFor the first test case, the following $6$ permutations satisfy the condition:  \n$[1, 2, 3, 4], [1, 3, 2, 4], [2, 1, 3, 4], [2, 3, 1, 4], [3, 1, 2, 4], [3, 2, 1, 4]$.  \n\nFor the second test case, all $1\\sim 4$ permutations are valid.  \n\n### Constraints  \n\n**This problem uses bundling tests.**  \n\n| Subtask | Points | $n\\leq$ | $T\\leq$ | Special Constraints |\n|:------:|:------:|:------:|:------:|:------------------:|\n| $1$    | $5$    | $8$    | $10^6$ | None               |\n| $2$    | $15$   | $2000$ | $2000$ | None               |\n| $3$    | $15$   | $2000$ | $10^6$ | None               |\n| $4$    | $25$   | $5\\times10^6$ | $20$ | None               |\n| $5$    | $15$   | $10^5$ | $10^6$ | A                  |\n| $6$    | $25$   | $5\\times10^6$ | $10^6$ | None               |\n\n- Special Constraint A: $P=998244353$.  \n\nFor all test cases:  \n- $1 \\leq T \\leq 10^6$,  \n- $1 \\le x, y \\le n \\le 5 \\times 10^6$,  \n- $10^8 \\le P \\le 10^9 + 7$ and $P$ is a prime.  \n\n### Hint  \nPlease use a fast input method.  \n\n---\n\n*Translation by DeepSeek V3.*  ", "locale": "en"}, "zh-CN": {"title": "【MX-X13-T6】「KDOI-12」能做到的也只不过是静等缘分耗尽的那一天。", "background": "待到缘分耗尽，关系断裂，我们还会在一起吗？", "description": "对于一个排列 $p_{1\\sim n}$，建出其大根[笛卡尔树](https://www.luogu.com.cn/problem/P5854)，并断开每个点与其右儿子（如果存在）的连边，记最后所成的森林为 $T(p)$。\n\n例如 $p_{1\\sim 5} = [1, 3, 2, 5, 4]$，其大根笛卡尔树与 $T(p)$ 分别如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6mikhar1.png)![](https://cdn.luogu.com.cn/upload/image_hosting/otv9hnhe.png)\n\n在给定 $n, x, y$ 的情况下，你需要回答，在 $n!$ 种 $1\\sim n$ 的排列 $p_{1\\sim n}$ 中，有多少种 $p$ 使得节点 $x$ 与节点 $y$ 在 $T(p)$ 中属于同一棵树。**节点指的是编号而非在 $p$ 中的权值。**\n\n由于答案可能很大，输出的答案需要对一个质数 $P$ 取模。", "inputFormat": "**本题有多组测试数据。**\n\n第一行，两个正整数 $T, P$，表示测试数据组数与模数。**保证 $\\bm P$ 为质数**。对于每组测试数据：\n\n* 仅一行，三个正整数 $n, x, y$。", "outputFormat": "对于每组测试数据，一行，一个非负整数，表示满足题目条件的排列数量，对 $P$ 取模。", "hint": "**【样例解释】**\n\n对于样例的第一组测试数据：有 $[1, 2, 3, 4], [1, 3, 2, 4], [2, 1, 3, 4], [2, 3, 1, 4], [3, 1, 2, 4], [3, 2, 1, 4]$ 共 $6$ 种排列满足条件。\n\n对于样例的第二组测试数据：任意 $1\\sim 4$ 的排列均满足条件。\n\n**【数据范围】**\n\n**本题使用捆绑测试。**\n\n| 子任务编号 | 分值 | $n\\leq$ | $T\\leq$ | 特殊性质 |\n|:--:|:--:|:--:|:--:|:--:|\n| $1$ | $5$ | $8$ | $10^6$ | 无 |\n| $2$ | $15$ | $2000$ | $2000$ | 无 |\n| $3$ | $15$ | $2000$ | $10^6$ | 无 |\n| $4$ | $25$ | $5\\times10^6$ | $20$ | 无 |\n| $5$ | $15$ | $10^5$ | $10^6$ | A |\n| $6$ | $25$ | $5\\times10^6$ | $10^6$ | 无 |\n\n* 特殊性质 A：$P=998244353$。\n\n对于所有数据：$1\\leq T\\leq10^6$，$1\\le x, y\\le n\\le 5\\times 10^6$，$10^8\\le P\\le 10^9 + 7$ 且 $P$ 为质数。\n\n**【提示】**\n\n请使用较快的读入方式。", "locale": "zh-CN"}}}
{"pid": "P13012", "type": "P", "difficulty": 7, "samples": [["3 3\n0 1 2\n3 0 2\n3 1 0", "2"], ["6 5\n0 1 1 2 3 4\n3 3 0 6 6 1\n2 4 1 0 1 1\n3 0 2 6 6 2\n5 3 6 1 0 4", "18"]], "limits": {"time": [12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000, 12000], "memory": [2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152, 2097152]}, "tags": ["O2优化", "深度优先搜索 DFS", "树论", "前缀和", "分块", "梦熊比赛"], "title": "【MX-X13-T7】「KDOI-12」No one can be anything without comparison.", "background": "", "description": "**请注意本题对 $\\bm{n,k}$ 的特殊限制。**\n\n$n$ 名选手参加了 $k$ 场 Tetris Tournament。每一场 Tetris Tournament 包含 $n-1$ 轮，每轮会选出两个目前还未淘汰的选手 $x,y$ 并让他们参加一场比赛，输的人淘汰。最后会有唯一胜者。你现在得知第 $j$ 个人在第 $i$ 场 Tetris Tournament 中被 $a_{i,j}$ 淘汰了。$j$ 是第 $i$ 场 Tetris Tournament 的胜者当且仅当 $a_{i,j}=0$。\n\n选手们喜欢比较。他们都希望自己在某种意义上能够胜过别人，或至少跟别人水平差不多。\n\n定义第 $i$ 场 Tetris Tournament 中 $x$ 严格吊打 $y$ 当且仅当存在 $x=p_1,p_2,\\dots,p_m=y$（$m\\ge 2$，也就是说 $x\\neq y$），使得对于任意 $1\\leq j<m$，$a_{i,p_{j+1}}=p_j$。\n\n定义一个有序的选手 $k$ 元组 $(i_1,i_2,\\dots,i_k)$ 是水平相似的当且仅当对于 $1\\leq j<k$，$i_j$ 在第 $j$ 场比赛中严格吊打 $i_{j+1}$ 且 $i_k$ 在第 $k$ 场比赛中严格吊打 $i_1$。\n\n求水平相似的 $k$ 元组数量，对 $998244353$ 取模。", "inputFormat": "第一行，两个正整数 $n,k$。**保证 $\\bm{3\\leq k\\leq 5}$**。\n\n接下来 $k$ 行，第 $i$ 行 $n$ 个非负整数 $a_{i,1}, \\ldots, a_{i,n}$。", "outputFormat": "仅一行，一个非负整数，表示水平相似的 $k$ 元组数量，对 $998244353$ 取模。", "hint": "**【样例解释 \\#1】**\n\n符合要求的三元组 $(i_1,i_2,i_3)$ 有：$(1,2,3)$，$(2,3,1)$。\n\n**【数据范围】**\n\n**本题使用捆绑测试。**\n\n| 子任务编号 | 分值 | $n\\leq$ | $k=$ | 特殊性质 |\n|:--:|:--:|:--:|:--:|:--:|\n| $1$ | $7$ | $100$ | $3$ | 无 |\n| $2$ | $8$ | $500$ | $3$ | 无 |\n| $3$ | $13$ | $3\\times10^3$ | $3$ | 无 |\n| $4$ | $14$ | $2.5\\times10^5$ | $3$ | A |\n| $5$ | $15$ | $10^5$ | $3$ | B |\n| $6$ | $7$ | $10^5$ | $3$ | 无 |\n| $7$ | $14$ | $2.5\\times10^5$ | $3$ | 无 |\n| $8$ | $7$ | $5\\times10^4$ | $4$ | 无 |\n| $9$ | $6$ | $7.5\\times10^4$ | $4$ | 无 |\n| $10$ | $9$ | $4\\times10^4$ | $5$ | 无 |\n\n* 特殊性质 A：对于 $1\\leq i\\leq n$，$a_{1,i}=a_{2,i}$；\n* 特殊性质 B：对于 $1\\leq i\\leq k$，不存在 $1\\leq j_1<j_2\\leq n$ 使得 $a_{i,j_1}=a_{i,j_2}$。\n\n对于所有数据：$1\\leq n\\leq2.5\\times10^5$，$\\bm{3\\leq k\\leq 5}$，保证 $a$ 数组符合题意，且：\n\n* $k=3$ 时，$n\\leq2.5\\times10^5$；\n* $k=4$ 时：$n\\leq7.5\\times10^4$；\n* $k=5$ 时：$n\\leq4\\times10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "【MX-X13-T7】\"KDOI-12\" No one can be anything without comparison.", "background": "", "description": "**Please note the special constraints on $\\bm{n,k}$ in this problem.**\n\n$n$ players participated in $k$ Tetris Tournaments. Each Tetris Tournament consists of $n-1$ rounds. In each round, two currently uneliminated players $x$ and $y$ are selected to compete, and the loser is eliminated. The last remaining player is the winner. You are given that the $j$-th player was eliminated by $a_{i,j}$ in the $i$-th Tetris Tournament. Here, $j$ is the winner of the $i$-th tournament if and only if $a_{i,j} = 0$.\n\nThe players enjoy comparison. They all hope to surpass others in some way or at least be on a similar level.\n\nDefine that in the $i$-th Tetris Tournament, $x$ **strictly dominates** $y$ if and only if there exists a sequence $x = p_1, p_2, \\dots, p_m = y$ (where $m \\ge 2$, i.e., $x \\neq y$) such that for all $1 \\leq j < m$, $a_{i,p_{j+1}} = p_j$.\n\nAn ordered $k$-tuple of players $(i_1, i_2, \\dots, i_k)$ is called **level-similar** if and only if for all $1 \\leq j < k$, $i_j$ strictly dominates $i_{j+1}$ in the $j$-th tournament, and $i_k$ strictly dominates $i_1$ in the $k$-th tournament.\n\nYour task is to compute the number of level-similar $k$-tuples, modulo $998244353$.", "inputFormat": "The first line contains two positive integers $n$ and $k$. **It is guaranteed that $\\bm{3 \\leq k \\leq 5}$.**\n\nThe next $k$ lines each contain $n$ non-negative integers $a_{i,1}, \\ldots, a_{i,n}$, representing the elimination data for the $i$-th tournament.\n", "outputFormat": "Output a single non-negative integer: the number of level-similar $k$-tuples, modulo $998244353$.\n", "hint": "### Sample Explanation #1  \nThe valid $3$-tuples $(i_1, i_2, i_3)$ are: $(1, 2, 3)$ and $(2, 3, 1)$.  \n\n### Constraints  \n\n**This problem uses bundling tests.**  \n\n| Subtask | Points | $n\\leq$ | $k=$ | Special Constraints |\n|:--:|:--:|:--:|:--:|:--:|\n| $1$ | $7$ | $100$ | $3$ | None |\n| $2$ | $8$ | $500$ | $3$ | None |\n| $3$ | $13$ | $3\\times10^3$ | $3$ | None |\n| $4$ | $14$ | $2.5\\times10^5$ | $3$ | A |\n| $5$ | $15$ | $10^5$ | $3$ | B |\n| $6$ | $7$ | $10^5$ | $3$ | None |\n| $7$ | $14$ | $2.5\\times10^5$ | $3$ | None |\n| $8$ | $7$ | $5\\times10^4$ | $4$ | None |\n| $9$ | $6$ | $7.5\\times10^4$ | $4$ | None |\n| $10$ | $9$ | $4\\times10^4$ | $5$ | None |\n\n- **Special Constraint A**: For $1 \\leq i \\leq n$, $a_{1,i} = a_{2,i}$.  \n- **Special Constraint B**: For $1 \\leq i \\leq k$, there do not exist $1 \\leq j_1 < j_2 \\leq n$ such that $a_{i,j_1} = a_{i,j_2}$.  \n\nFor all test cases:  \n- $1 \\leq n \\leq 2.5 \\times 10^5$,  \n- $\\bm{3 \\leq k \\leq 5}$,  \n- The $a$ array is consistent with the problem description, and:  \n  - If $k=3$, $n \\leq 2.5 \\times 10^5$.  \n  - If $k=4$, $n \\leq 7.5 \\times 10^4$.  \n  - If $k=5$, $n \\leq 4 \\times 10^4$.  \n\n---\n\n*Translation by DeepSeek V3.*  ", "locale": "en"}, "zh-CN": {"title": "【MX-X13-T7】「KDOI-12」No one can be anything without comparison.", "background": "", "description": "**请注意本题对 $\\bm{n,k}$ 的特殊限制。**\n\n$n$ 名选手参加了 $k$ 场 Tetris Tournament。每一场 Tetris Tournament 包含 $n-1$ 轮，每轮会选出两个目前还未淘汰的选手 $x,y$ 并让他们参加一场比赛，输的人淘汰。最后会有唯一胜者。你现在得知第 $j$ 个人在第 $i$ 场 Tetris Tournament 中被 $a_{i,j}$ 淘汰了。$j$ 是第 $i$ 场 Tetris Tournament 的胜者当且仅当 $a_{i,j}=0$。\n\n选手们喜欢比较。他们都希望自己在某种意义上能够胜过别人，或至少跟别人水平差不多。\n\n定义第 $i$ 场 Tetris Tournament 中 $x$ 严格吊打 $y$ 当且仅当存在 $x=p_1,p_2,\\dots,p_m=y$（$m\\ge 2$，也就是说 $x\\neq y$），使得对于任意 $1\\leq j<m$，$a_{i,p_{j+1}}=p_j$。\n\n定义一个有序的选手 $k$ 元组 $(i_1,i_2,\\dots,i_k)$ 是水平相似的当且仅当对于 $1\\leq j<k$，$i_j$ 在第 $j$ 场比赛中严格吊打 $i_{j+1}$ 且 $i_k$ 在第 $k$ 场比赛中严格吊打 $i_1$。\n\n求水平相似的 $k$ 元组数量，对 $998244353$ 取模。", "inputFormat": "第一行，两个正整数 $n,k$。**保证 $\\bm{3\\leq k\\leq 5}$**。\n\n接下来 $k$ 行，第 $i$ 行 $n$ 个非负整数 $a_{i,1}, \\ldots, a_{i,n}$。", "outputFormat": "仅一行，一个非负整数，表示水平相似的 $k$ 元组数量，对 $998244353$ 取模。", "hint": "**【样例解释 \\#1】**\n\n符合要求的三元组 $(i_1,i_2,i_3)$ 有：$(1,2,3)$，$(2,3,1)$。\n\n**【数据范围】**\n\n**本题使用捆绑测试。**\n\n| 子任务编号 | 分值 | $n\\leq$ | $k=$ | 特殊性质 |\n|:--:|:--:|:--:|:--:|:--:|\n| $1$ | $7$ | $100$ | $3$ | 无 |\n| $2$ | $8$ | $500$ | $3$ | 无 |\n| $3$ | $13$ | $3\\times10^3$ | $3$ | 无 |\n| $4$ | $14$ | $2.5\\times10^5$ | $3$ | A |\n| $5$ | $15$ | $10^5$ | $3$ | B |\n| $6$ | $7$ | $10^5$ | $3$ | 无 |\n| $7$ | $14$ | $2.5\\times10^5$ | $3$ | 无 |\n| $8$ | $7$ | $5\\times10^4$ | $4$ | 无 |\n| $9$ | $6$ | $7.5\\times10^4$ | $4$ | 无 |\n| $10$ | $9$ | $4\\times10^4$ | $5$ | 无 |\n\n* 特殊性质 A：对于 $1\\leq i\\leq n$，$a_{1,i}=a_{2,i}$；\n* 特殊性质 B：对于 $1\\leq i\\leq k$，不存在 $1\\leq j_1<j_2\\leq n$ 使得 $a_{i,j_1}=a_{i,j_2}$。\n\n对于所有数据：$1\\leq n\\leq2.5\\times10^5$，$\\bm{3\\leq k\\leq 5}$，保证 $a$ 数组符合题意，且：\n\n* $k=3$ 时，$n\\leq2.5\\times10^5$；\n* $k=4$ 时：$n\\leq7.5\\times10^4$；\n* $k=5$ 时：$n\\leq4\\times10^4$。", "locale": "zh-CN"}}}
{"pid": "P13013", "type": "P", "difficulty": 3, "samples": [["8 8\n2 1", "5"], ["314159 2653589\n27 1828", "1599"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["二分", "2025", "GESP", "整数规划"], "title": "[GESP202506 五级] 奖品兑换", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1185>\n\n为了保证只有时间复杂度正确的代码能够通过本题，时限下降为 400 毫秒。", "description": "班主任给上课专心听讲、认真完成作业的同学们分别发放了若干张课堂优秀券和作业优秀券。同学们可以使用这两种券找班主任兑换奖品。具体来说，可以使用 $a$ 张课堂优秀券和 $b$ 张作业优秀券兑换一份奖品，或者使用 $b$ 张课堂优秀券和 $a$ 张作业优秀券兑换一份奖品。\n\n现在小 A 有 $n$ 张课堂优秀券和 $m$ 张作业优秀券，他最多能兑换多少份奖品呢？", "inputFormat": "第一行，两个正整数 $n,m$，分别表示小 A 持有的课堂优秀券和作业优秀券的数量。\n\n第二行，两个正整数 $a,b$，表示兑换一份奖品所需的两种券的数量。", "outputFormat": "输出共一行，一个整数，表示最多能兑换的奖品份数。\n", "hint": "对于 $60\\%$ 的测试点，保证 $1 \\le a,b \\le 100$，$1 \\le n,m \\le 500$。\n\n对于所有测试点，保证 $1 \\le a,b \\le 10^4$，$1 \\le n,m \\le 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202506 五级] 奖品兑换", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1185>\n\n为了保证只有时间复杂度正确的代码能够通过本题，时限下降为 400 毫秒。", "description": "班主任给上课专心听讲、认真完成作业的同学们分别发放了若干张课堂优秀券和作业优秀券。同学们可以使用这两种券找班主任兑换奖品。具体来说，可以使用 $a$ 张课堂优秀券和 $b$ 张作业优秀券兑换一份奖品，或者使用 $b$ 张课堂优秀券和 $a$ 张作业优秀券兑换一份奖品。\n\n现在小 A 有 $n$ 张课堂优秀券和 $m$ 张作业优秀券，他最多能兑换多少份奖品呢？", "inputFormat": "第一行，两个正整数 $n,m$，分别表示小 A 持有的课堂优秀券和作业优秀券的数量。\n\n第二行，两个正整数 $a,b$，表示兑换一份奖品所需的两种券的数量。", "outputFormat": "输出共一行，一个整数，表示最多能兑换的奖品份数。\n", "hint": "对于 $60\\%$ 的测试点，保证 $1 \\le a,b \\le 100$，$1 \\le n,m \\le 500$。\n\n对于所有测试点，保证 $1 \\le a,b \\le 10^4$，$1 \\le n,m \\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P13014", "type": "P", "difficulty": 2, "samples": [["5 3\n6 9 12 18 30", "1\n1\n3"], ["3 5\n31 47 59", "4\n1\n2\n1\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2025", "GESP"], "title": "[GESP202506 五级] 最大公因数", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1185>", "description": "对于两个正整数 $a,b$，他们的最大公因数记为 $\\gcd(a,b)$。对于 $k > 3$ 个正整数 $c_1,c_2,\\dots,c_k$，他们的最大公因数为：\n\n$$\\gcd(c_1,c_2,\\dots,c_k)=\\gcd(\\gcd(c_1,c_2,\\dots,c_{k-1}),c_k)$$\n\n给定 $n$ 个正整数 $a_1,a_2,\\dots,a_n$ 以及 $q$ 组询问。对于第 $i(1 \\le i \\le q)$ 组询问，请求出 $a_1+i,a_2+i,\\dots,a_n+i$ 的最大公因数，也即 $\\gcd(a_1+i,a_2+i,\\dots,a_n+i)$。", "inputFormat": "第一行，两个正整数 $n,q$，分别表示给定正整数的数量，以及询问组数。\n\n第二行，$n$ 个正整数 $a_1,a_2,\\dots,a_n$。", "outputFormat": "输出共 $q$ 行，第 $i$ 行包含一个正整数，表示 $a_1+i,a_2+i,\\dots,a_n+i$ 的最大公因数。", "hint": "对于 $60\\%$ 的测试点，保证 $1 \\le n \\le 10^3$，$1 \\le q \\le 10$。\n\n对于所有测试点，保证 $1 \\le n \\le 10^5$，$1 \\le q \\le 10^5$，$1 \\le a_i \\le 1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202506 五级] 最大公因数", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1185>", "description": "对于两个正整数 $a,b$，他们的最大公因数记为 $\\gcd(a,b)$。对于 $k > 3$ 个正整数 $c_1,c_2,\\dots,c_k$，他们的最大公因数为：\n\n$$\\gcd(c_1,c_2,\\dots,c_k)=\\gcd(\\gcd(c_1,c_2,\\dots,c_{k-1}),c_k)$$\n\n给定 $n$ 个正整数 $a_1,a_2,\\dots,a_n$ 以及 $q$ 组询问。对于第 $i(1 \\le i \\le q)$ 组询问，请求出 $a_1+i,a_2+i,\\dots,a_n+i$ 的最大公因数，也即 $\\gcd(a_1+i,a_2+i,\\dots,a_n+i)$。", "inputFormat": "第一行，两个正整数 $n,q$，分别表示给定正整数的数量，以及询问组数。\n\n第二行，$n$ 个正整数 $a_1,a_2,\\dots,a_n$。", "outputFormat": "输出共 $q$ 行，第 $i$ 行包含一个正整数，表示 $a_1+i,a_2+i,\\dots,a_n+i$ 的最大公因数。", "hint": "对于 $60\\%$ 的测试点，保证 $1 \\le n \\le 10^3$，$1 \\le q \\le 10$。\n\n对于所有测试点，保证 $1 \\le n \\le 10^5$，$1 \\le q \\le 10^5$，$1 \\le a_i \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P13015", "type": "P", "difficulty": 2, "samples": [["4\n1 5 6 3", "10"], ["8\n0 2 5 6 4 3 3 4", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2025", "背包 DP", "GESP"], "title": "[GESP202506 六级] 学习小组", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1186>", "description": "\n\n班主任计划将班级里的 $ n $ 名同学划分为若干个学习小组，每名同学都需要分入某一个学习小组中。观察发现，如果一个学习小组中恰好包含 $ k $ 名同学，则该学习小组的讨论积极度为 $ a_k $。\n\n给定讨论积极度 $ a_1, a_2, \\ldots, a_n $，请你计算将这 $ n $ 名同学划分为学习小组的所有可能方案中，讨论积极度之和的最大值。\n", "inputFormat": "\n第一行，一个正整数 $ n $，表示班级人数。\n\n第二行，$ n $ 个非负整数 $ a_1, a_2, \\ldots, a_n $，表示不同人数学习小组的讨论积极度。\n", "outputFormat": "\n输出共一行，一个整数，表示所有划分方案中，学习小组讨论积极度之和的最大值。", "hint": "对于 $40\\%$ 的测试点，保证 $1\\le n\\le 10$。\n\n对于所有测试点，保证 $1\\le n\\le 1000$，$0\\le a_i\\le 10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202506 六级] 学习小组", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1186>", "description": "\n\n班主任计划将班级里的 $ n $ 名同学划分为若干个学习小组，每名同学都需要分入某一个学习小组中。观察发现，如果一个学习小组中恰好包含 $ k $ 名同学，则该学习小组的讨论积极度为 $ a_k $。\n\n给定讨论积极度 $ a_1, a_2, \\ldots, a_n $，请你计算将这 $ n $ 名同学划分为学习小组的所有可能方案中，讨论积极度之和的最大值。\n", "inputFormat": "\n第一行，一个正整数 $ n $，表示班级人数。\n\n第二行，$ n $ 个非负整数 $ a_1, a_2, \\ldots, a_n $，表示不同人数学习小组的讨论积极度。\n", "outputFormat": "\n输出共一行，一个整数，表示所有划分方案中，学习小组讨论积极度之和的最大值。", "hint": "对于 $40\\%$ 的测试点，保证 $1\\le n\\le 10$。\n\n对于所有测试点，保证 $1\\le n\\le 1000$，$0\\le a_i\\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P13016", "type": "P", "difficulty": 3, "samples": [["3\n1 3\n2 5\n4 8", "1\n2\n1"], ["1\n120 650", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2025", "数论", "最近公共祖先 LCA", "GESP"], "title": "[GESP202506 六级] 最大因数", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1186>", "description": "\n\n给定一棵有 $10^9$ 个结点的有根树，这些结点依次以 $1, 2, \\dots, 10^9$ 编号，根结点的编号为 $1$。对于编号为 $k$（$2 \\leq k \\leq 10^9$）的结点，其父结点的编号为 $k$ 的因数中除 $k$ 以外最大的因数。\n\n现在有 $q$ 组询问，第 $i$（$1 \\leq i \\leq q$）组询问给定 $x_i, y_i$，请你求出编号分别为 $x_i, y_i$ 的两个结点在这棵树上的距离。两个结点之间的距离是连接这两个结点的简单路径所包含的边数。\n", "inputFormat": "\n第一行，一个正整数 $q$，表示询问组数。\n\n接下来 $q$ 行，每行两个正整数 $x_i, y_i$，表示询问结点的编号。", "outputFormat": "\n输出共 $q$ 行，每行一个整数，表示结点 $x_i, y_i$ 之间的距离。", "hint": "\n对于 $60\\%$ 的测试点，保证 $1 \\leq x_i, y_i \\leq 1000$。\n\n对于所有测试点，保证 $1 \\leq q \\leq 1000$，$1 \\leq x_i, y_i \\leq 10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202506 六级] 最大因数", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1186>", "description": "\n\n给定一棵有 $10^9$ 个结点的有根树，这些结点依次以 $1, 2, \\dots, 10^9$ 编号，根结点的编号为 $1$。对于编号为 $k$（$2 \\leq k \\leq 10^9$）的结点，其父结点的编号为 $k$ 的因数中除 $k$ 以外最大的因数。\n\n现在有 $q$ 组询问，第 $i$（$1 \\leq i \\leq q$）组询问给定 $x_i, y_i$，请你求出编号分别为 $x_i, y_i$ 的两个结点在这棵树上的距离。两个结点之间的距离是连接这两个结点的简单路径所包含的边数。\n", "inputFormat": "\n第一行，一个正整数 $q$，表示询问组数。\n\n接下来 $q$ 行，每行两个正整数 $x_i, y_i$，表示询问结点的编号。", "outputFormat": "\n输出共 $q$ 行，每行一个整数，表示结点 $x_i, y_i$ 之间的距离。", "hint": "\n对于 $60\\%$ 的测试点，保证 $1 \\leq x_i, y_i \\leq 1000$。\n\n对于所有测试点，保证 $1 \\leq q \\leq 1000$，$1 \\leq x_i, y_i \\leq 10^9$。", "locale": "zh-CN"}}}
{"pid": "P13017", "type": "P", "difficulty": 3, "samples": [["5 4\n1 2\n2 3\n3 1\n4 5", "3"], ["5 10\n1 2\n1 3\n1 4\n1 5\n2 3\n2 4\n2 5\n3 4\n3 5\n4 5", "30"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2025", "组合数学", "GESP"], "title": "[GESP202506 七级] 线图", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1187>", "description": "给定由 $n$ 个结点与 $m$ 条边构成的简单无向图 $G$，结点依次以 $1,2,\\dots,n$ 编号。简单无向图意味着 $G$ 中不包含重边与自环。$G$ 的**线图** $L(G)$ 通过以下方式构建：\n\n- 初始时线图 $L(G)$ 为空。\n\n- 对于无向图 $G$ 中的一条边，在线图 $L(G)$ 中加入与之对应的一个结点。\n\n- 对于无向图 $G$ 中两条不同的边 $(u_1,v_1),(u_2,v_2)$，若存在 $G$ 中的结点同时连接这两条边（即 $u_1,v_1$ 之一与 $u_2,v_2$ 之一相同），则在线图 $L(G)$ 中加入一条无向边，连接 $(u_1,v_1),(u_2,v_2)$ 在线图中对应的结点。\n\n请你求出线图 $L(G)$ 中所包含的无向边的数量。", "inputFormat": "第一行，两个正整数 $n,m$，分别表示无向图 $G$ 中的结点数和边数。\n\n接下来 $m$ 行，每行两个正整数 $u_i,v_i$，表示 $G$ 中连接 $u_i,v_i$ 的一条无向边。", "outputFormat": "输出共一行，一个整数，表示线图 $L(G)$ 中所包含的无向边的数量。", "hint": "**【样例解释 #1】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/72ffa0a3.png)\n\n**【数据范围】**\n\n对于 $60\\%$ 的测试点，保证 $1 \\le n \\le 500$，$1 \\le m \\le 500$。\n\n对于所有测试点，保证 $1 \\le n \\le 10^5$，$1 \\le m \\le 10^5$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202506 七级] 线图", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1187>", "description": "给定由 $n$ 个结点与 $m$ 条边构成的简单无向图 $G$，结点依次以 $1,2,\\dots,n$ 编号。简单无向图意味着 $G$ 中不包含重边与自环。$G$ 的**线图** $L(G)$ 通过以下方式构建：\n\n- 初始时线图 $L(G)$ 为空。\n\n- 对于无向图 $G$ 中的一条边，在线图 $L(G)$ 中加入与之对应的一个结点。\n\n- 对于无向图 $G$ 中两条不同的边 $(u_1,v_1),(u_2,v_2)$，若存在 $G$ 中的结点同时连接这两条边（即 $u_1,v_1$ 之一与 $u_2,v_2$ 之一相同），则在线图 $L(G)$ 中加入一条无向边，连接 $(u_1,v_1),(u_2,v_2)$ 在线图中对应的结点。\n\n请你求出线图 $L(G)$ 中所包含的无向边的数量。", "inputFormat": "第一行，两个正整数 $n,m$，分别表示无向图 $G$ 中的结点数和边数。\n\n接下来 $m$ 行，每行两个正整数 $u_i,v_i$，表示 $G$ 中连接 $u_i,v_i$ 的一条无向边。", "outputFormat": "输出共一行，一个整数，表示线图 $L(G)$ 中所包含的无向边的数量。", "hint": "**【样例解释 #1】**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/72ffa0a3.png)\n\n**【数据范围】**\n\n对于 $60\\%$ 的测试点，保证 $1 \\le n \\le 500$，$1 \\le m \\le 500$。\n\n对于所有测试点，保证 $1 \\le n \\le 10^5$，$1 \\le m \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P13018", "type": "P", "difficulty": 3, "samples": [["3\n1 2\n2 4\n3 2", "8"], ["5\n1 1\n2 3\n6 1\n8 2\n5 7\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2025", "背包 DP", "GESP"], "title": "[GESP202506 七级] 调味平衡", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1187>", "description": "小 A 准备了 $n$ 种食材用来制作料理，这些食材依次以 $1,2,\\dots,n$ 编号，第 $i$ 种食材的酸度为 $a_i$，甜度为 $b_i$。对于每种食材，小 A 可以选择将其放入料理，或者不放入料理。料理的酸度 $A$ 为放入食材的酸度之和，甜度 $B$ 为放入食材的甜度之和。如果料理的酸度和甜度相等，那么料理的调味是**平衡的**。\n\n过于清淡的料理并不好吃，因此小 A 想在满足料理调味平衡的前提下，合理选择食材，最大化料理的酸度与甜度之和。你能帮他求出在调味平衡的前提下，料理酸度与甜度之和的最大值吗？\n", "inputFormat": "第一行，一个正整数 $n$，表示食材种类数量。\n\n接下来 $n$ 行，每行两个正整数 $a_i,b_i$，表示食材的酸度和甜度。", "outputFormat": "输出共一行，一个整数，表示在调味平衡的前提下，料理酸度与甜度之和的最大值。", "hint": "对于 $40\\%$ 的测试点，保证 $1 \\le n \\le 10$，$1 \\le a_i,b_i \\le 10$。\n\n对于另外 $20\\%$ 的测试点，保证 $1 \\le n \\le 50$，$1 \\le a_i,b_i \\le 10$。\n\n对于所有测试点，保证 $1 \\le n \\le 100$，$1 \\le a_i,b_i \\le 500$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202506 七级] 调味平衡", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1187>", "description": "小 A 准备了 $n$ 种食材用来制作料理，这些食材依次以 $1,2,\\dots,n$ 编号，第 $i$ 种食材的酸度为 $a_i$，甜度为 $b_i$。对于每种食材，小 A 可以选择将其放入料理，或者不放入料理。料理的酸度 $A$ 为放入食材的酸度之和，甜度 $B$ 为放入食材的甜度之和。如果料理的酸度和甜度相等，那么料理的调味是**平衡的**。\n\n过于清淡的料理并不好吃，因此小 A 想在满足料理调味平衡的前提下，合理选择食材，最大化料理的酸度与甜度之和。你能帮他求出在调味平衡的前提下，料理酸度与甜度之和的最大值吗？\n", "inputFormat": "第一行，一个正整数 $n$，表示食材种类数量。\n\n接下来 $n$ 行，每行两个正整数 $a_i,b_i$，表示食材的酸度和甜度。", "outputFormat": "输出共一行，一个整数，表示在调味平衡的前提下，料理酸度与甜度之和的最大值。", "hint": "对于 $40\\%$ 的测试点，保证 $1 \\le n \\le 10$，$1 \\le a_i,b_i \\le 10$。\n\n对于另外 $20\\%$ 的测试点，保证 $1 \\le n \\le 50$，$1 \\le a_i,b_i \\le 10$。\n\n对于所有测试点，保证 $1 \\le n \\le 100$，$1 \\le a_i,b_i \\le 500$。", "locale": "zh-CN"}}}
{"pid": "P13019", "type": "P", "difficulty": 4, "samples": [["5 4\n1 1 2 2\n3 3\n1 -1 -1\n2 5\n1 -1 1 -1 1\n5 8\n1 1 1 -1 -1 -1 -1 -1\n5 3\n-1 -1 1", "4\n1\n4\n2"], ["8 3\n5 4 2 1 3 6 6\n8 1\n8\n8 2\n8 -8\n8 3\n8 -8 8", "1\n7\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["倍增", "2025", "最近公共祖先 LCA", "GESP"], "title": "[GESP202506 八级] 树上旅行", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1188>", "description": "\n\n给定一棵有 $ n $ 个结点的 **有根树**，结点依次以 $1,2,\\dots,n$ 编号，其中根结点的编号为 $1$。\n\n小 A 计划在这棵有根树上进行 $q$ 次旅行。在第 $i$ 次旅行中，小 A 首先选定结点 $s_i$ 作为起点，并移动若干次。移动分为以下两种：\n\n1. 移动至当前结点的父结点。特殊地，如果当前位于根结点，则不进行移动。\n2. 移动至当前结点的所有子结点中**编号最小**的结点。特殊地，如果当前位于叶子结点，则不进行移动。\n\n由于移动次数可能很大，对于第 $i$ 次旅行，旅行中的移动以 $k_i$ 个不为零的整数构成的序列 $a_{i,1}, a_{i,2}, \\dots, a_{i,k_i}$ 表示。对 $a_{i,j}$，若 $a_{i,j} > 0$ 则代表进行 $a_{i,j}$ 次第一种移动；若 $a_{i,j} < 0$ 则代表进行 $-a_{i,j}$ 次第二种移动。根据给出的序列从左至右完成所有移动后，小 A 所在的结点即是旅行的**终点**。\n\n给定每次旅行的起点与移动序列，请你求出旅行终点的结点编号。\n", "inputFormat": "\n\n第一行，两个正整数 $n, q$，分别表示有根树的结点数量，以及旅行次数。\n\n第二行，$n-1$ 个整数 $p_2, p_3, \\dots, p_n$，其中 $p_i$ 表示结点 $i$ 的父结点编号。\n\n接下来 $2q$ 行中的第 $2i-1$ 行（$1 \\leq i \\leq q$）包含两个正整数 $s_i, k_i$，分别表示第 $i$ 次旅行的起点编号，以及移动序列的长度。第 $2i$ 行包含 $k_i$ 个整数 $a_{i,1}, a_{i,2}, \\dots, a_{i,k_i}$，表示移动序列。", "outputFormat": "\n输出共 $q$ 行，第 $i$ 行包含一个整数，表示第 $i$ 次旅行终点的结点编号。", "hint": "\n\n| 子任务编号 | 测试点占比 | $n$ | $q$ | $\\sum k_i$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| $1$          | $20\\%$         | $\\leq 100$ | $\\leq 100$ | $\\leq 1000$ | 保证 $a_{i,j}$ 为 $1$ 或 $-1$ |\n| $2$          | $20\\%$         | $\\leq 10^4$ | $\\leq 10^4$ | $\\leq 4 \\times 10^4$ | 仅包含第一种移动 |\n| $3$          | $20\\%$         | $\\leq 10^4$ | $\\leq 10^4$ | $\\leq 4 \\times 10^4$ | 仅包含第二种移动 |\n| $4$          | $40\\%$         | $\\leq 10^5$ | $\\leq 2 \\times 10^4$ | $\\leq 10^5$ | - |\n\n对于所有测试点，保证：\n\n- $1 \\leq n \\leq 10^5$\n- $1 \\leq q \\leq 2 \\times 10^4$\n- $1 \\leq p_i \\leq n$\n- $1 \\leq s_i \\leq n$\n- $k_i \\geq 1$ 且 $\\sum k_i \\leq 10^5$\n- $1 \\leq |a_{i,j}| \\leq n$\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202506 八级] 树上旅行", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1188>", "description": "\n\n给定一棵有 $ n $ 个结点的 **有根树**，结点依次以 $1,2,\\dots,n$ 编号，其中根结点的编号为 $1$。\n\n小 A 计划在这棵有根树上进行 $q$ 次旅行。在第 $i$ 次旅行中，小 A 首先选定结点 $s_i$ 作为起点，并移动若干次。移动分为以下两种：\n\n1. 移动至当前结点的父结点。特殊地，如果当前位于根结点，则不进行移动。\n2. 移动至当前结点的所有子结点中**编号最小**的结点。特殊地，如果当前位于叶子结点，则不进行移动。\n\n由于移动次数可能很大，对于第 $i$ 次旅行，旅行中的移动以 $k_i$ 个不为零的整数构成的序列 $a_{i,1}, a_{i,2}, \\dots, a_{i,k_i}$ 表示。对 $a_{i,j}$，若 $a_{i,j} > 0$ 则代表进行 $a_{i,j}$ 次第一种移动；若 $a_{i,j} < 0$ 则代表进行 $-a_{i,j}$ 次第二种移动。根据给出的序列从左至右完成所有移动后，小 A 所在的结点即是旅行的**终点**。\n\n给定每次旅行的起点与移动序列，请你求出旅行终点的结点编号。\n", "inputFormat": "\n\n第一行，两个正整数 $n, q$，分别表示有根树的结点数量，以及旅行次数。\n\n第二行，$n-1$ 个整数 $p_2, p_3, \\dots, p_n$，其中 $p_i$ 表示结点 $i$ 的父结点编号。\n\n接下来 $2q$ 行中的第 $2i-1$ 行（$1 \\leq i \\leq q$）包含两个正整数 $s_i, k_i$，分别表示第 $i$ 次旅行的起点编号，以及移动序列的长度。第 $2i$ 行包含 $k_i$ 个整数 $a_{i,1}, a_{i,2}, \\dots, a_{i,k_i}$，表示移动序列。", "outputFormat": "\n输出共 $q$ 行，第 $i$ 行包含一个整数，表示第 $i$ 次旅行终点的结点编号。", "hint": "\n\n| 子任务编号 | 测试点占比 | $n$ | $q$ | $\\sum k_i$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| $1$          | $20\\%$         | $\\leq 100$ | $\\leq 100$ | $\\leq 1000$ | 保证 $a_{i,j}$ 为 $1$ 或 $-1$ |\n| $2$          | $20\\%$         | $\\leq 10^4$ | $\\leq 10^4$ | $\\leq 4 \\times 10^4$ | 仅包含第一种移动 |\n| $3$          | $20\\%$         | $\\leq 10^4$ | $\\leq 10^4$ | $\\leq 4 \\times 10^4$ | 仅包含第二种移动 |\n| $4$          | $40\\%$         | $\\leq 10^5$ | $\\leq 2 \\times 10^4$ | $\\leq 10^5$ | - |\n\n对于所有测试点，保证：\n\n- $1 \\leq n \\leq 10^5$\n- $1 \\leq q \\leq 2 \\times 10^4$\n- $1 \\leq p_i \\leq n$\n- $1 \\leq s_i \\leq n$\n- $k_i \\geq 1$ 且 $\\sum k_i \\leq 10^5$\n- $1 \\leq |a_{i,j}| \\leq n$\n", "locale": "zh-CN"}}}
{"pid": "P13020", "type": "P", "difficulty": 4, "samples": [["4\n1 2\n2 3\n3 4", "6"], ["8\n1 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8", "112"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "树形 DP", "树论", "组合数学", "GESP"], "title": "[GESP202506 八级] 遍历计数", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1188>", "description": "给定一棵有 $n$ 个结点的树 $T$，结点依次以 $1,2,\\dots,n$ 标号。树 $T$ 的深度优先遍历序可由以下过程得到：\n\n1. 选定深度优先遍历的起点 $s$（$1 \\leq s \\leq n$），当前位置结点即是起点。\n2. 若当前结点存在未被遍历的相邻结点 $u$ 则遍历 $u$，也即令当前位置结点为 $u$ 并重复这一步；否则回溯。\n3. 按照遍历结点的顺序依次写下结点编号，即可得到一组深度优先遍历序。\n\n第一步中起点的选择是任意的，并且第二步中遍历相邻结点的顺序也是任意的，因此对于同一棵树 $T$ 可能有多组不同的深度优先遍历序。请你求出树 $T$ 有多少组不同的深度优先遍历序。由于答案可能很大，你只需要求出答案对 $10^9$ 取模之后的结果。", "inputFormat": "第一行，一个整数 $n$，表示树 $T$ 的结点数。\n\n接下来 $n-1$ 行，每行两个正整数 $u_i, v_i$，表示树 $T$ 中的一条连接结点 $u_i, v_i$ 的边。", "outputFormat": "输出一行，一个整数，表示树 $T$ 的不同的深度优先遍历序数量对 $10^9$ 取模的结果。", "hint": "对于 $40\\%$ 的测试点，保证 $1 \\leq n \\leq 8$。\n\n对于另外 $20\\%$ 的测试点，保证给定的树是一条链。\n\n对于所有测试点，保证 $1 \\leq n \\leq 10^5$。\n\n在洛谷上，只有通过了 Subtask0、Subtask1 和 Subtask2 后，才能获得第三个 Subtask 的分数。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[GESP202506 八级] 遍历计数", "background": "对应的选择、判断题：<https://ti.luogu.com.cn/problemset/1188>", "description": "给定一棵有 $n$ 个结点的树 $T$，结点依次以 $1,2,\\dots,n$ 标号。树 $T$ 的深度优先遍历序可由以下过程得到：\n\n1. 选定深度优先遍历的起点 $s$（$1 \\leq s \\leq n$），当前位置结点即是起点。\n2. 若当前结点存在未被遍历的相邻结点 $u$ 则遍历 $u$，也即令当前位置结点为 $u$ 并重复这一步；否则回溯。\n3. 按照遍历结点的顺序依次写下结点编号，即可得到一组深度优先遍历序。\n\n第一步中起点的选择是任意的，并且第二步中遍历相邻结点的顺序也是任意的，因此对于同一棵树 $T$ 可能有多组不同的深度优先遍历序。请你求出树 $T$ 有多少组不同的深度优先遍历序。由于答案可能很大，你只需要求出答案对 $10^9$ 取模之后的结果。", "inputFormat": "第一行，一个整数 $n$，表示树 $T$ 的结点数。\n\n接下来 $n-1$ 行，每行两个正整数 $u_i, v_i$，表示树 $T$ 中的一条连接结点 $u_i, v_i$ 的边。", "outputFormat": "输出一行，一个整数，表示树 $T$ 的不同的深度优先遍历序数量对 $10^9$ 取模的结果。", "hint": "对于 $40\\%$ 的测试点，保证 $1 \\leq n \\leq 8$。\n\n对于另外 $20\\%$ 的测试点，保证给定的树是一条链。\n\n对于所有测试点，保证 $1 \\leq n \\leq 10^5$。\n\n在洛谷上，只有通过了 Subtask0、Subtask1 和 Subtask2 后，才能获得第三个 Subtask 的分数。", "locale": "zh-CN"}}}
{"pid": "P13021", "type": "P", "difficulty": 2, "samples": [["3\n4\n4 2 1 3\n2\n1 2\n7\n7 6 5 4 3 2 1", "Case #1: 6\nCase #2: 1\nCase #3: 12"]], "limits": {"time": [10000, 10000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2021", "Google Code Jam"], "title": "[GCJ 2021 Qualification] Reversort", "background": "", "description": "**Note: The main parts of the statements of the problems \"Reversort\" and \"Reversort Engineering\" are identical, except for the last paragraph. The problems can otherwise be solved independently.**\n\nReversort is an algorithm to sort a list of distinct integers in increasing order. The algorithm is based on the \"Reverse\" operation. Each application of this operation reverses the order of some contiguous part of the list.\n\nThe pseudocode of the algorithm is the following:\n\n```\nReversort(L):\n  for i := 1 to length(L) - 1\n    j := position with the minimum value in L between i and length(L), inclusive\n    Reverse(L[i..j])\n```\n\nAfter $i-1$ iterations, the positions $1, 2, \\ldots, i-1$ of the list contain the $i-1$ smallest elements of $L$, in increasing order. During the $i$-th iteration, the process reverses the sublist going from the $i$-th position to the current position of the $i$-th minimum element. That makes the $i$-th minimum element end up in the $i$-th position.\n\nFor example, for a list with 4 elements, the algorithm would perform 3 iterations. Here is how it would process $L = [4, 2, 1, 3]$:\n\n1. $i = 1$, $j = 3 \\longrightarrow L = [1, 2, 4, 3]$\n2. $i = 2$, $j = 2 \\longrightarrow L = [1, 2, 4, 3]$\n3. $i = 3$, $j = 4 \\longrightarrow L = [1, 2, 3, 4]$\n\nThe most expensive part of executing the algorithm on our architecture is the Reverse operation. Therefore, our measure for the cost of each iteration is simply the length of the sublist passed to Reverse, that is, the value $j - i + 1$. The cost of the whole algorithm is the sum of the costs of each iteration.\n\nIn the example above, the iterations cost 3, 1, and 2, in that order, for a total of 6.\n\nGiven the initial list, compute the cost of executing Reversort on it.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 2 lines. The first line contains a single integer $\\mathbf{N}$, representing the number of elements in the input list. The second line contains $\\mathbf{N}$ distinct integers $\\mathbf{L}_{1}, \\mathbf{L}_{2}, \\ldots, \\mathbf{L}_{\\mathbf{N}}$, representing the elements of the input list $L$, in order.", "outputFormat": "For each test case, output one line containing Case #$x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is the total cost of executing Reversort on the list given as input.", "hint": "**Sample Explanation**\n\nSample Case #1 is described in the statement above.\n\nIn Sample Case #2, there is a single iteration, in which Reverse is applied to a sublist of size 1. Therefore, the total cost is 1.\n\nIn Sample Case #3, the first iteration reverses the full list, for a cost of 7. After that, the list is already sorted, but there are 5 more iterations, each of which contributes a cost of 1.\n\n**Limits**\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 100$.\n- $1 \\leq \\mathbf{L}_{i} \\leq N$, for all $i$.\n- $\\mathbf{L}_{i} \\neq \\mathbf{L}_{j}$, for all $i \\neq j$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Qualification] Reversort", "background": "", "description": "**Note: The main parts of the statements of the problems \"Reversort\" and \"Reversort Engineering\" are identical, except for the last paragraph. The problems can otherwise be solved independently.**\n\nReversort is an algorithm to sort a list of distinct integers in increasing order. The algorithm is based on the \"Reverse\" operation. Each application of this operation reverses the order of some contiguous part of the list.\n\nThe pseudocode of the algorithm is the following:\n\n```\nReversort(L):\n  for i := 1 to length(L) - 1\n    j := position with the minimum value in L between i and length(L), inclusive\n    Reverse(L[i..j])\n```\n\nAfter $i-1$ iterations, the positions $1, 2, \\ldots, i-1$ of the list contain the $i-1$ smallest elements of $L$, in increasing order. During the $i$-th iteration, the process reverses the sublist going from the $i$-th position to the current position of the $i$-th minimum element. That makes the $i$-th minimum element end up in the $i$-th position.\n\nFor example, for a list with 4 elements, the algorithm would perform 3 iterations. Here is how it would process $L = [4, 2, 1, 3]$:\n\n1. $i = 1$, $j = 3 \\longrightarrow L = [1, 2, 4, 3]$\n2. $i = 2$, $j = 2 \\longrightarrow L = [1, 2, 4, 3]$\n3. $i = 3$, $j = 4 \\longrightarrow L = [1, 2, 3, 4]$\n\nThe most expensive part of executing the algorithm on our architecture is the Reverse operation. Therefore, our measure for the cost of each iteration is simply the length of the sublist passed to Reverse, that is, the value $j - i + 1$. The cost of the whole algorithm is the sum of the costs of each iteration.\n\nIn the example above, the iterations cost 3, 1, and 2, in that order, for a total of 6.\n\nGiven the initial list, compute the cost of executing Reversort on it.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of 2 lines. The first line contains a single integer $\\mathbf{N}$, representing the number of elements in the input list. The second line contains $\\mathbf{N}$ distinct integers $\\mathbf{L}_{1}, \\mathbf{L}_{2}, \\ldots, \\mathbf{L}_{\\mathbf{N}}$, representing the elements of the input list $L$, in order.", "outputFormat": "For each test case, output one line containing Case #$x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is the total cost of executing Reversort on the list given as input.", "hint": "**Sample Explanation**\n\nSample Case #1 is described in the statement above.\n\nIn Sample Case #2, there is a single iteration, in which Reverse is applied to a sublist of size 1. Therefore, the total cost is 1.\n\nIn Sample Case #3, the first iteration reverses the full list, for a cost of 7. After that, the list is already sorted, but there are 5 more iterations, each of which contributes a cost of 1.\n\n**Limits**\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 100$.\n- $1 \\leq \\mathbf{L}_{i} \\leq N$, for all $i$.\n- $\\mathbf{L}_{i} \\neq \\mathbf{L}_{j}$, for all $i \\neq j$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Qualification] Reversort", "background": "", "description": "**注意：问题 \"Reversort\" 和 \"Reversort Engineering\" 的题目描述主体部分相同，仅最后一段不同。这两个问题可以独立解决。**\n\nReversort 是一种用于将**互不相同**的整数列表按升序排序的算法。该算法基于 \"Reverse\" 操作，每次应用该操作会反转列表中某个连续部分的顺序。\n\n算法的伪代码如下：\n\n```\nReversort(L):\n  for i := 1 to length(L) - 1\n    j := position with the minimum value in L between i and length(L), inclusive\n    Reverse(L[i..j])\n```\n\n经过 $i-1$ 次迭代后，列表的第 $1, 2, \\ldots, i-1$ 个位置将包含 $L$ 中前 $i-1$ 小的元素，并按升序排列。在第 $i$ 次迭代中，算法会反转从第 $i$ 个位置到当前第 $i$ 小元素所在位置的子列表。这将使第 $i$ 小的元素最终位于第 $i$ 个位置。\n\n例如，对于一个包含 4 个元素的列表，算法将执行 3 次迭代。以下是处理 $L = [4, 2, 1, 3]$ 的过程：\n\n1. $i = 1$，$j = 3 \\longrightarrow L = [1, 2, 4, 3]$\n2. $i = 2$，$j = 2 \\longrightarrow L = [1, 2, 4, 3]$\n3. $i = 3$，$j = 4 \\longrightarrow L = [1, 2, 3, 4]$\n\n在我们的架构中，执行该算法最耗时的部分是 Reverse 操作。因此，我们衡量每次迭代成本的标准仅仅是传递给 Reverse 的子列表长度，即 $j - i + 1$。整个算法的成本是每次迭代成本的总和。\n\n在上述示例中，迭代成本依次为 3、1 和 2，总成本为 6。\n\n给定初始列表，计算执行 Reversort 的成本。", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 个测试用例。每个测试用例包含 2 行。第一行包含一个整数 $\\mathbf{N}$，表示输入列表的元素数量。第二行包含 $\\mathbf{N}$ 个**互不相同**的整数 $\\mathbf{L}_{1}, \\mathbf{L}_{2}, \\ldots, \\mathbf{L}_{\\mathbf{N}}$，按顺序表示输入列表 $L$ 的元素。\n", "outputFormat": "对于每个测试用例，输出一行 \"Case #$x$: $y$\"，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是对给定列表执行 Reversort 的总成本。\n", "hint": "**样例解释**\n\n样例 #1 已在题目描述中说明。\n\n在样例 #2 中，仅有一次迭代，Reverse 操作应用于长度为 1 的子列表，因此总成本为 1。\n\n在样例 #3 中，第一次迭代反转了整个列表，成本为 7。此后列表已排序，但仍有 5 次迭代，每次成本为 1。\n\n**数据范围**\n\n**测试集 1（7 分，可见判定结果）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{N} \\leq 100$。\n- $1 \\leq \\mathbf{L}_{i} \\leq N$，对所有 $i$ 成立。\n- $\\mathbf{L}_{i} \\neq \\mathbf{L}_{j}$，对所有 $i \\neq j$ 成立。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13022", "type": "P", "difficulty": 3, "samples": [["4\n2 3 CJ?CC?\n4 2 CJCJ\n1 3 C?J\n2 5 ??J???", "Case #1: 5\nCase #2: 10\nCase #3: 1\nCase #4: 0"], ["1\n2 -5 ??JJ??", "Case #1: -8"]], "limits": {"time": [10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2021", "Google Code Jam"], "title": "[GCJ 2021 Qualification] Moons and Umbrellas", "background": "", "description": "Cody-Jamal is working on his latest piece of abstract art: a mural consisting of a row of waning moons and closed umbrellas. Unfortunately, greedy copyright trolls are claiming that waning moons look like an uppercase C and closed umbrellas look like a J, and they have a copyright on CJ and JC. Therefore, for each time CJ appears in the mural, Cody-Jamal must pay $\\mathbf{X}$, and for each time JC appears in the mural, he must pay $\\mathbf{Y}$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sqo2l8si.png)\n\nCody-Jamal is unwilling to let them compromise his art, so he will not change anything already painted. He decided, however, that the empty spaces he still has could be filled strategically, to minimize the copyright expenses.\n\nFor example, if `CJ?CC?` represents the current state of the mural, with `C` representing a waning moon, `J` representing a closed umbrella, and `?` representing a space that still needs to be painted with either a waning moon or a closed umbrella, he could finish the mural as `CJCCCC`, `CJCCCJ`, `CJJCCC`, or `CJJCCJ`. The first and third options would require paying $\\mathbf{X} + \\mathbf{Y}$ in copyrights, while the second and fourth would require paying $2 \\cdot \\mathbf{X} + \\mathbf{Y}$.\n\nGiven the costs $\\mathbf{X}$ and $\\mathbf{Y}$ and a string representing the current state of the mural, how much does Cody-Jamal need to pay in copyrights if he finishes his mural in a way that minimizes that cost?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line contains two integers $\\mathbf{X}$ and $\\mathbf{Y}$ and a string $\\mathbf{S}$ representing the two costs and the current state of the mural, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum cost that Cody-Jamal needs to pay in copyrights for a finished mural.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained in the problem statement. The minimum cost is $\\mathbf{X} + \\mathbf{Y} = 2 + 3 = 5$.\n\nIn Sample Case #2, Cody-Jamal is already finished, so he does not have a choice. There are two `CJ`s and one `JC` in his mural.\n\nIn Sample Case #3, substituting either `C` or `J` results in one `CJ` either from the second and third characters or the first and second characters, respectively.\n\nIn Sample Case #4, Cody-Jamal can finish his mural with all Js. Since that contains no instance of `CJ` nor `JC`, it yields no copyright cost.\n\nThe following additional sample 2 fits the limits of Test Set 3. It will not be run against your submitted solutions.\n\nIn Sample Case #1 for Test Set 3, Cody-Jamal can finish his mural optimally as `JCJJCC` or `JCJJJC`. Either way, there is one `CJ` and two `JC`s in his mural.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{S}$ is either $\\mathbf{c}$, $\\mathbf{J}$, or $\\mathbf{?}$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 10$.\n- $1 \\leq \\mathbf{X} \\leq 100$.\n- $1 \\leq \\mathbf{Y} \\leq 100$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 1000$.\n- $1 \\leq \\mathbf{X} \\leq 100$.\n- $1 \\leq \\mathbf{Y} \\leq 100$.\n\n**Extra credit!**\n\nWhat if some copyright holders could pay Cody-Jamal for the advertisement instead of being paid? Cody-Jamal getting paid is represented by a negative cost.\n\n**Test Set 3 (1 Pts, Hidden Verdict)**\n\n- $1 < $ the length of $\\mathbf{S} < 1000$.\n- $-100 \\leq \\mathbf{X} \\leq 100$.\n- $-100 \\leq \\mathbf{Y} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Qualification] Moons and Umbrellas", "background": "", "description": "Cody-Jamal is working on his latest piece of abstract art: a mural consisting of a row of waning moons and closed umbrellas. Unfortunately, greedy copyright trolls are claiming that waning moons look like an uppercase C and closed umbrellas look like a J, and they have a copyright on CJ and JC. Therefore, for each time CJ appears in the mural, Cody-Jamal must pay $\\mathbf{X}$, and for each time JC appears in the mural, he must pay $\\mathbf{Y}$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sqo2l8si.png)\n\nCody-Jamal is unwilling to let them compromise his art, so he will not change anything already painted. He decided, however, that the empty spaces he still has could be filled strategically, to minimize the copyright expenses.\n\nFor example, if `CJ?CC?` represents the current state of the mural, with `C` representing a waning moon, `J` representing a closed umbrella, and `?` representing a space that still needs to be painted with either a waning moon or a closed umbrella, he could finish the mural as `CJCCCC`, `CJCCCJ`, `CJJCCC`, or `CJJCCJ`. The first and third options would require paying $\\mathbf{X} + \\mathbf{Y}$ in copyrights, while the second and fourth would require paying $2 \\cdot \\mathbf{X} + \\mathbf{Y}$.\n\nGiven the costs $\\mathbf{X}$ and $\\mathbf{Y}$ and a string representing the current state of the mural, how much does Cody-Jamal need to pay in copyrights if he finishes his mural in a way that minimizes that cost?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line contains two integers $\\mathbf{X}$ and $\\mathbf{Y}$ and a string $\\mathbf{S}$ representing the two costs and the current state of the mural, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum cost that Cody-Jamal needs to pay in copyrights for a finished mural.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained in the problem statement. The minimum cost is $\\mathbf{X} + \\mathbf{Y} = 2 + 3 = 5$.\n\nIn Sample Case #2, Cody-Jamal is already finished, so he does not have a choice. There are two `CJ`s and one `JC` in his mural.\n\nIn Sample Case #3, substituting either `C` or `J` results in one `CJ` either from the second and third characters or the first and second characters, respectively.\n\nIn Sample Case #4, Cody-Jamal can finish his mural with all Js. Since that contains no instance of `CJ` nor `JC`, it yields no copyright cost.\n\nThe following additional sample 2 fits the limits of Test Set 3. It will not be run against your submitted solutions.\n\nIn Sample Case #1 for Test Set 3, Cody-Jamal can finish his mural optimally as `JCJJCC` or `JCJJJC`. Either way, there is one `CJ` and two `JC`s in his mural.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{S}$ is either $\\mathbf{c}$, $\\mathbf{J}$, or $\\mathbf{?}$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 10$.\n- $1 \\leq \\mathbf{X} \\leq 100$.\n- $1 \\leq \\mathbf{Y} \\leq 100$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 1000$.\n- $1 \\leq \\mathbf{X} \\leq 100$.\n- $1 \\leq \\mathbf{Y} \\leq 100$.\n\n**Extra credit!**\n\nWhat if some copyright holders could pay Cody-Jamal for the advertisement instead of being paid? Cody-Jamal getting paid is represented by a negative cost.\n\n**Test Set 3 (1 Pts, Hidden Verdict)**\n\n- $1 < $ the length of $\\mathbf{S} < 1000$.\n- $-100 \\leq \\mathbf{X} \\leq 100$.\n- $-100 \\leq \\mathbf{Y} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Qualification] Moons and Umbrellas", "background": null, "description": "Cody-Jamal 正在创作他最新的抽象艺术作品：一幅由一排渐亏的月亮和闭合的雨伞组成的壁画。不幸的是，贪婪的版权流氓声称渐亏的月亮看起来像大写字母 C，而闭合的雨伞看起来像字母 J，并且他们拥有 CJ 和 JC 的版权。因此，每当壁画中出现 CJ 时，Cody-Jamal 必须支付 $\\mathbf{X}$，而出现 JC 时则需支付 $\\mathbf{Y}$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sqo2l8si.png)\n\nCody-Jamal 不愿让他们破坏自己的艺术，因此不会更改已经画好的部分。但他决定，可以通过策略性地填充尚未完成的空白部分来最小化版权费用。\n\n例如，如果 `CJ?CC?` 表示壁画的当前状态，其中 `C` 代表渐亏的月亮，`J` 代表闭合的雨伞，而 `?` 代表需要填充为渐亏月亮或闭合雨伞的空白部分。他可以将壁画完成为 `CJCCCC`、`CJCCCJ`、`CJJCCC` 或 `CJJCCJ`。第一种和第三种选择需要支付 $\\mathbf{X} + \\mathbf{Y}$ 的版权费用，而第二种和第四种则需要支付 $2 \\cdot \\mathbf{X} + \\mathbf{Y}$。\n\n给定费用 $\\mathbf{X}$ 和 $\\mathbf{Y}$ 以及一个表示壁画当前状态的字符串，如果 Cody-Jamal 以最小化成本的方式完成壁画，他需要支付多少版权费用？", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 行。每行包含两个整数 $\\mathbf{X}$ 和 $\\mathbf{Y}$ 以及一个字符串 $\\mathbf{S}$，分别表示两项费用和壁画的当前状态。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 Cody-Jamal 在完成壁画后需要支付的最小版权费用。", "hint": "**样例解释**\n\n样例 #1 是题目描述中解释的情况。最小费用为 $\\mathbf{X} + \\mathbf{Y} = 2 + 3 = 5$。\n\n在样例 #2 中，Cody-Jamal 已经完成了壁画，因此无法选择。壁画中有两个 `CJ` 和一个 `JC`。\n\n在样例 #3 中，无论是将 `?` 替换为 `C` 还是 `J`，都会在第二和第三个字符或第一和第二个字符之间形成一个 `CJ`。\n\n在样例 #4 中，Cody-Jamal 可以将壁画全部填充为 `J`。由于这既不包含 `CJ` 也不包含 `JC`，因此不需要支付版权费用。\n\n以下附加样例 2 符合测试集 3 的限制，但不会在提交的解决方案中运行。\n\n在测试集 3 的样例 #1 中，Cody-Jamal 可以最优地将壁画完成为 `JCJJCC` 或 `JCJJJC`。无论哪种方式，壁画中都有一个 `CJ` 和两个 `JC`。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $\\mathbf{S}$ 中的每个字符为 $\\mathbf{C}$、$\\mathbf{J}$ 或 $\\mathbf{?}$。\n\n**测试集 1（5 分，可见判定结果）**\n\n- $1 \\leq \\mathbf{S}$ 的长度 $\\leq 10$。\n- $1 \\leq \\mathbf{X} \\leq 100$。\n- $1 \\leq \\mathbf{Y} \\leq 100$。\n\n**测试集 2（11 分，可见判定结果）**\n\n- $1 \\leq \\mathbf{S}$ 的长度 $\\leq 1000$。\n- $1 \\leq \\mathbf{X} \\leq 100$。\n- $1 \\leq \\mathbf{Y} \\leq 100$。\n\n**额外奖励！**\n\n如果某些版权持有者反而会支付 Cody-Jamal 广告费而不是向他收费呢？Cody-Jamal 获得报酬的情况用负成本表示。\n\n**测试集 3（1 分，隐藏判定结果）**\n\n- $1 < \\mathbf{S}$ 的长度 $< 1000$。\n- $-100 \\leq \\mathbf{X} \\leq 100$。\n- $-100 \\leq \\mathbf{Y} \\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13023", "type": "P", "difficulty": 3, "samples": [["5\n4 6\n2 1\n7 12\n7 2\n2 1000", "Case #1: 4 2 1 3\nCase #2: 1 2\nCase #3: 7 6 5 4 3 2 1\nCase #4: IMPOSSIBLE\nCase #5: IMPOSSIBLE"]], "limits": {"time": [10000, 10000, 10000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "2021", "Special Judge", "Google Code Jam"], "title": "[GCJ 2021 Qualification] Reversort Engineering", "background": "", "description": "**Note: The main parts of the statements of the problems \"Reversort\" and \"Reversort Engineering\" are identical, except for the last paragraph. The problems can otherwise be solved independently.**\n\nReversort is an algorithm to sort a list of distinct integers in increasing order. The algorithm is based on the \"Reverse\" operation. Each application of this operation reverses the order of some contiguous part of the list.\n\nThe pseudocode of the algorithm is the following:\n\n```\nReversort(L):\n  for i := 1 to length(L) - 1\n    j := position with the minimum value in L between i and length(L), inclusive\n    Reverse(L[i..j])\n```\n\nAfter $i - 1$ iterations, the positions $1$, $2$, $\\ldots$, $i - 1$ of the list contain the $i - 1$ smallest elements of $L$, in increasing order. During the $i$-th iteration, the process reverses the sublist going from the $i$-th position to the current position of the $i$-th minimum element. That makes the $i$-th minimum element end up in the $i$-th position.\n\nFor example, for a list with $4$ elements, the algorithm would perform $3$ iterations. Here is how it would process $L = [4, 2, 1, 3]$:\n\n1. $i = 1$, $j = 3 \\longrightarrow L = [1, 2, 4, 3]$\n2. $i = 2$, $j = 2 \\longrightarrow L = [1, 2, 4, 3]$\n3. $i = 3$, $j = 4 \\longrightarrow L = [1, 2, 3, 4]$\n\nThe most expensive part of executing the algorithm on our architecture is the Reverse operation. Therefore, our measure for the cost of each iteration is simply the length of the sublist passed to Reverse, that is, the value $j - i + 1$. The cost of the whole algorithm is the sum of the costs of each iteration.\n\nIn the example above, the iterations cost $3$, $1$, and $2$, in that order, for a total of $6$.\n\nYou are given a size $N$ and a cost $C$. Find a list of $N$ distinct integers between $1$ and $N$ such that the cost of applying Reversort to it is exactly $C$, or say that there is no such list.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line describes a test case with two integers $\\mathbf{N}$ and $\\mathbf{C}$, the size of the wanted list and the desired cost, respectively.\n", "outputFormat": "For each test case, if there is no list of size $\\mathbf{N}$ such that applying Reversort to it costs exactly $\\mathbf{C}$, output one line containing Case #$x$: IMPOSSIBLE, where $x$ is the test case number (starting from 1). Otherwise, output one line containing Case #$x$: $y_1$ $y_2$ $\\ldots$ $y_{\\mathbf{N}}$, where $x$ is the test case number (starting from 1) and each $y_i$ is a distinct integer between 1 and $\\mathbf{N}$, representing the $i$-th element of one such possible list.\n\nIf there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nSample Case #1 is described in the statement above.\n\nIn Sample Case #2, the algorithm runs for only one iteration on the proposed output. In that iteration, reverse is applied to a sublist of size 1, therefore, its cost is 1.\n\nIn Sample Case #3, the first iteration reverses the full list, for a cost of 7. After that, the list is already sorted, but there are 5 more iterations, each of which contributes a cost of 1. Another valid output would be 7 5 4 3 2 1 6. For that output, the first iteration has a cost of 6, the last one has a cost of 2, and all others have a cost of 1.\n\nIn Sample Case #4, Reversort will necessarily perform 6 iterations, each of which will have a cost of at least 1, so there is no way the total cost can be as low as required.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{C} \\leq 1000$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 7$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Qualification] Reversort Engineering", "background": "", "description": "**Note: The main parts of the statements of the problems \"Reversort\" and \"Reversort Engineering\" are identical, except for the last paragraph. The problems can otherwise be solved independently.**\n\nReversort is an algorithm to sort a list of distinct integers in increasing order. The algorithm is based on the \"Reverse\" operation. Each application of this operation reverses the order of some contiguous part of the list.\n\nThe pseudocode of the algorithm is the following:\n\n```\nReversort(L):\n  for i := 1 to length(L) - 1\n    j := position with the minimum value in L between i and length(L), inclusive\n    Reverse(L[i..j])\n```\n\nAfter $i - 1$ iterations, the positions $1$, $2$, $\\ldots$, $i - 1$ of the list contain the $i - 1$ smallest elements of $L$, in increasing order. During the $i$-th iteration, the process reverses the sublist going from the $i$-th position to the current position of the $i$-th minimum element. That makes the $i$-th minimum element end up in the $i$-th position.\n\nFor example, for a list with $4$ elements, the algorithm would perform $3$ iterations. Here is how it would process $L = [4, 2, 1, 3]$:\n\n1. $i = 1$, $j = 3 \\longrightarrow L = [1, 2, 4, 3]$\n2. $i = 2$, $j = 2 \\longrightarrow L = [1, 2, 4, 3]$\n3. $i = 3$, $j = 4 \\longrightarrow L = [1, 2, 3, 4]$\n\nThe most expensive part of executing the algorithm on our architecture is the Reverse operation. Therefore, our measure for the cost of each iteration is simply the length of the sublist passed to Reverse, that is, the value $j - i + 1$. The cost of the whole algorithm is the sum of the costs of each iteration.\n\nIn the example above, the iterations cost $3$, $1$, and $2$, in that order, for a total of $6$.\n\nYou are given a size $N$ and a cost $C$. Find a list of $N$ distinct integers between $1$ and $N$ such that the cost of applying Reversort to it is exactly $C$, or say that there is no such list.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line describes a test case with two integers $\\mathbf{N}$ and $\\mathbf{C}$, the size of the wanted list and the desired cost, respectively.\n", "outputFormat": "For each test case, if there is no list of size $\\mathbf{N}$ such that applying Reversort to it costs exactly $\\mathbf{C}$, output one line containing Case #$x$: IMPOSSIBLE, where $x$ is the test case number (starting from 1). Otherwise, output one line containing Case #$x$: $y_1$ $y_2$ $\\ldots$ $y_{\\mathbf{N}}$, where $x$ is the test case number (starting from 1) and each $y_i$ is a distinct integer between 1 and $\\mathbf{N}$, representing the $i$-th element of one such possible list.\n\nIf there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nSample Case #1 is described in the statement above.\n\nIn Sample Case #2, the algorithm runs for only one iteration on the proposed output. In that iteration, reverse is applied to a sublist of size 1, therefore, its cost is 1.\n\nIn Sample Case #3, the first iteration reverses the full list, for a cost of 7. After that, the list is already sorted, but there are 5 more iterations, each of which contributes a cost of 1. Another valid output would be 7 5 4 3 2 1 6. For that output, the first iteration has a cost of 6, the last one has a cost of 2, and all others have a cost of 1.\n\nIn Sample Case #4, Reversort will necessarily perform 6 iterations, each of which will have a cost of at least 1, so there is no way the total cost can be as low as required.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{C} \\leq 1000$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 7$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Qualification] Reversort Engineering", "background": "", "description": "**注意：问题 \"Reversort\" 和 \"Reversort Engineering\" 的题目描述主体部分相同，仅最后一段不同。这两个问题可以独立解决。**\n\nReversort 是一种用于将**互不相同**的整数列表按升序排序的算法。该算法基于 \"Reverse\" 操作，每次应用该操作会反转列表中某个连续部分的顺序。\n\n算法的伪代码如下：\n\n```\nReversort(L):\n  for i := 1 to length(L) - 1\n    j := position with the minimum value in L between i and length(L), inclusive\n    Reverse(L[i..j])\n```\n\n经过 $i - 1$ 次迭代后，列表的第 $1$, $2$, $\\ldots$, $i - 1$ 个位置将包含 $L$ 中前 $i - 1$ 小的元素，并按升序排列。在第 $i$ 次迭代中，算法会反转从第 $i$ 个位置到当前第 $i$ 小元素所在位置的子列表。这将使第 $i$ 小的元素最终位于第 $i$ 个位置。\n\n例如，对于一个包含 $4$ 个元素的列表，算法将执行 $3$ 次迭代。以下是处理 $L = [4, 2, 1, 3]$ 的过程：\n\n1. $i = 1$, $j = 3 \\longrightarrow L = [1, 2, 4, 3]$\n2. $i = 2$, $j = 2 \\longrightarrow L = [1, 2, 4, 3]$\n3. $i = 3$, $j = 4 \\longrightarrow L = [1, 2, 3, 4]$\n\n在我们的架构中，执行该算法最耗时的部分是 Reverse 操作。因此，我们衡量每次迭代成本的标准仅仅是传递给 Reverse 的子列表长度，即 $j - i + 1$。整个算法的成本是每次迭代成本的总和。\n\n在上述示例中，迭代成本依次为 $3$、$1$ 和 $2$，总成本为 $6$。\n\n现在给定列表大小 $N$ 和目标成本 $C$。请找出一个由 $1$ 到 $N$ 的 $N$ 个不同整数组成的列表，使得对其应用 Reversort 的成本恰好为 $C$，或者判定这样的列表不存在。\n", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 行。每行描述一个测试用例，包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{C}$，分别表示目标列表的大小和期望成本。\n", "outputFormat": "对于每个测试用例，如果不存在大小为 $\\mathbf{N}$ 且应用 Reversort 后成本恰好为 $\\mathbf{C}$ 的列表，则输出一行 Case #$x$: IMPOSSIBLE，其中 $x$ 是测试用例编号（从 1 开始）。否则，输出一行 Case #$x$: $y_1$ $y_2$ $\\ldots$ $y_{\\mathbf{N}}$，其中 $x$ 是测试用例编号（从 1 开始），每个 $y_i$ 是 $1$ 到 $\\mathbf{N}$ 之间的不同整数，表示一个可能列表的第 $i$ 个元素。\n\n如果存在多个解，可以输出其中任意一个。", "hint": "**样例解释**\n\n样例 #1 已在题目描述中说明。\n\n在样例 #2 中，算法在所提出的输出上仅运行一次迭代。在该次迭代中，reverse 操作应用于长度为 1 的子列表，因此其成本为 1。\n\n在样例 #3 中，第一次迭代反转了整个列表，成本为 7。此后列表已排序，但仍有 5 次迭代，每次成本为 1。另一个有效输出是 7 5 4 3 2 1 6。对于该输出，第一次迭代的成本为 6，最后一次的成本为 2，其余每次的成本为 1。\n\n在样例 #4 中，Reversort 必然执行 6 次迭代，每次迭代的成本至少为 1，因此无法达到要求的低总成本。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{C} \\leq 1000$。\n\n**测试集 1（7 分，可见判定结果）**\n\n- $2 \\leq \\mathbf{N} \\leq 7$。\n\n**测试集 2（11 分，可见判定结果）**\n\n- $2 \\leq \\mathbf{N} \\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13024", "type": "P", "difficulty": 5, "samples": [["2 5 600\n\n2\n\n3\n\n4\n\n1\n\n3\n\n4\n\n5\n\n1", "\n1 2 3\n\n4 2 3\n\n5 4 3\n\n5 4 3 2 1\n\n1 2 3\n\n2 3 4\n\n3 4 5\n\n1 3 5 4 2"]], "limits": {"time": [40000, 40000, 40000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2021", "三分", "交互题", "Special Judge", "Google Code Jam"], "title": "[GCJ 2021 Qualification] Median Sort", "background": "", "description": "You want to sort $\\mathbf{N}$ distinct items, $x_1$, $x_2$, $\\ldots$, $x_{\\mathbf{N}}$. Unfortunately, you do not have a way of comparing two of these items. You only have a way to, given three of them, find out which one is the median, that is, which one is neither the minimum nor the maximum among the three.\n\nFor example, suppose $\\mathbf{N} = 5$ and you know that:\n\n* $x_1$ is the median of $\\{x_1, x_2, x_3\\}$\n* $x_2$ is the median of $\\{x_2, x_3, x_4\\}$\n* $x_3$ is the median of $\\{x_3, x_4, x_5\\}$\n\nThen, it is guaranteed that the sorted order of the elements is either $x_4, x_2, x_1, x_3, x_5$ or its reverse $x_5, x_3, x_1, x_2, x_4$. Notice that by knowing only medians, it is impossible to distinguish the order of any list from its reverse, since the median question has the same result for any three elements in both cases.\n\nYour program will have to find the order of $\\mathbf{T}$ lists of $\\mathbf{N}$ elements using at most $\\mathbf{Q}$ median questions in total (or $\\mathbf{Q}/\\mathbf{T}$ queries per list on average). In each case, finding either the right order or its reverse is considered correct. The order for each case is generated uniformly at random from all possible orders, and independently of any other information.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, the judge will send you a single line containing three integers $\\mathbf{T}$, $\\mathbf{N}$, and $\\mathbf{Q}$: the number of test cases, the number of elements to sort within each test case, and the total number of questions you are allowed across all test cases, respectively. Then, you must process $\\mathbf{T}$ test cases. Each test case consists of a series of question exchanges plus an additional exchange to provide the answer.\n\nFor a question exchange, your program must print a single line containing three distinct integers $i$, $j$, $k$ all between 1 and $\\mathbf{N}$, inclusive, which corresponds to asking the judge \"which element is the median of the set $\\{x_i, x_j, x_k\\}$?\" The judge will respond with a single line containing a single integer $\\mathbf{L}$, meaning that the median of that set is $x_{\\mathbf{L}}$ ($\\mathbf{L}$ is always equal to one of $i$, $j$, or $k$). If you try to perform a $(\\mathbf{Q} + 1)$-th question exchange, the judge will simply output -1.\n\nOnce you are ready to state the result, print a line containing $\\mathbf{N}$ integers representing the indices of the elements in sorted or reverse sorted order. The judge will respond with a single integer 1 if your answer is correct or -1 if it is not. After receiving the judge's answer for the $\\mathbf{T}$-th case, your program must finish in time in order to not receive a Time Limit Exceeded error. In addition, if you print additional information after receiving the result for the $\\mathbf{T}$-th case, you will get a Wrong Answer judgment.\n\nIf the judge receives an invalidly formatted line or invalid values from your program at any moment, the judge will print a single number -1. After the judge prints -1 for any of the reasons explained above, it will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that. For more information, read the instructions in comments in that file, and also check out the Interactive Problems section of the FAQ.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $\\mathbf{T} = 100$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $\\mathbf{N} = 10$.\n- $\\mathbf{Q} = 300 \\cdot \\mathbf{T}$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $\\mathbf{N} = 50$.\n- $\\mathbf{Q} = 300 \\cdot \\mathbf{T}$.\n\n**Test Set 3 (10 Pts, Hidden Verdict)**\n\n- $\\mathbf{N} = 50$.\n- $\\mathbf{Q} = 170 \\cdot \\mathbf{T}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Qualification] Median Sort", "background": "", "description": "You want to sort $\\mathbf{N}$ distinct items, $x_1$, $x_2$, $\\ldots$, $x_{\\mathbf{N}}$. Unfortunately, you do not have a way of comparing two of these items. You only have a way to, given three of them, find out which one is the median, that is, which one is neither the minimum nor the maximum among the three.\n\nFor example, suppose $\\mathbf{N} = 5$ and you know that:\n\n* $x_1$ is the median of $\\{x_1, x_2, x_3\\}$\n* $x_2$ is the median of $\\{x_2, x_3, x_4\\}$\n* $x_3$ is the median of $\\{x_3, x_4, x_5\\}$\n\nThen, it is guaranteed that the sorted order of the elements is either $x_4, x_2, x_1, x_3, x_5$ or its reverse $x_5, x_3, x_1, x_2, x_4$. Notice that by knowing only medians, it is impossible to distinguish the order of any list from its reverse, since the median question has the same result for any three elements in both cases.\n\nYour program will have to find the order of $\\mathbf{T}$ lists of $\\mathbf{N}$ elements using at most $\\mathbf{Q}$ median questions in total (or $\\mathbf{Q}/\\mathbf{T}$ queries per list on average). In each case, finding either the right order or its reverse is considered correct. The order for each case is generated uniformly at random from all possible orders, and independently of any other information.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, the judge will send you a single line containing three integers $\\mathbf{T}$, $\\mathbf{N}$, and $\\mathbf{Q}$: the number of test cases, the number of elements to sort within each test case, and the total number of questions you are allowed across all test cases, respectively. Then, you must process $\\mathbf{T}$ test cases. Each test case consists of a series of question exchanges plus an additional exchange to provide the answer.\n\nFor a question exchange, your program must print a single line containing three distinct integers $i$, $j$, $k$ all between 1 and $\\mathbf{N}$, inclusive, which corresponds to asking the judge \"which element is the median of the set $\\{x_i, x_j, x_k\\}$?\" The judge will respond with a single line containing a single integer $\\mathbf{L}$, meaning that the median of that set is $x_{\\mathbf{L}}$ ($\\mathbf{L}$ is always equal to one of $i$, $j$, or $k$). If you try to perform a $(\\mathbf{Q} + 1)$-th question exchange, the judge will simply output -1.\n\nOnce you are ready to state the result, print a line containing $\\mathbf{N}$ integers representing the indices of the elements in sorted or reverse sorted order. The judge will respond with a single integer 1 if your answer is correct or -1 if it is not. After receiving the judge's answer for the $\\mathbf{T}$-th case, your program must finish in time in order to not receive a Time Limit Exceeded error. In addition, if you print additional information after receiving the result for the $\\mathbf{T}$-th case, you will get a Wrong Answer judgment.\n\nIf the judge receives an invalidly formatted line or invalid values from your program at any moment, the judge will print a single number -1. After the judge prints -1 for any of the reasons explained above, it will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that. For more information, read the instructions in comments in that file, and also check out the Interactive Problems section of the FAQ.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $\\mathbf{T} = 100$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $\\mathbf{N} = 10$.\n- $\\mathbf{Q} = 300 \\cdot \\mathbf{T}$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $\\mathbf{N} = 50$.\n- $\\mathbf{Q} = 300 \\cdot \\mathbf{T}$.\n\n**Test Set 3 (10 Pts, Hidden Verdict)**\n\n- $\\mathbf{N} = 50$.\n- $\\mathbf{Q} = 170 \\cdot \\mathbf{T}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Qualification] Median Sort", "background": "", "description": "你需要对 $\\mathbf{N}$ 个互不相同的元素 $x_1$, $x_2$, $\\ldots$, $x_{\\mathbf{N}}$ 进行排序。但遗憾的是，你无法直接比较任意两个元素。你只能通过一种方式：给定三个元素，找出其中的中位数（即既不是最小值也不是最大值的那个元素）。\n\n例如，假设 $\\mathbf{N} = 5$，并且你知道：\n* $x_1$ 是 $\\{x_1, x_2, x_3\\}$ 的中位数\n* $x_2$ 是 $\\{x_2, x_3, x_4\\}$ 的中位数\n* $x_3$ 是 $\\{x_3, x_4, x_5\\}$ 的中位数\n\n那么可以确定，元素的排序结果要么是 $x_4, x_2, x_1, x_3, x_5$，要么是其逆序 $x_5, x_3, x_1, x_2, x_4$。注意，仅通过中位数信息无法区分一个列表与其逆序，因为对于任意三个元素，中位数的结果在这两种情况下是相同的。\n\n你的程序需要在最多 $\\mathbf{Q}$ 次中位数询问的总次数内（平均每个列表 $\\mathbf{Q}/\\mathbf{T}$ 次询问），找出 $\\mathbf{T}$ 个 $\\mathbf{N}$ 元素列表的顺序。对于每个测试用例，只要给出的顺序是正确的或其逆序，都被认为是正确答案。每个测试用例的顺序是从所有可能顺序中均匀随机生成的，且与其他信息无关。\n\n### 交互协议\n\n这是一个交互式问题。\n\n初始时，评测机将发送一行包含三个整数 $\\mathbf{T}$、$\\mathbf{N}$ 和 $\\mathbf{Q}$：分别表示测试用例的数量、每个测试用例中需要排序的元素数量，以及允许在所有测试用例中进行的总询问次数。然后，你需要处理 $\\mathbf{T}$ 个测试用例。每个测试用例包含一系列询问交互以及一个额外的回答交互。\n\n对于询问交互，你的程序需要输出一行包含三个介于 1 和 $\\mathbf{N}$ 之间的不同整数 $i$、$j$、$k$，表示询问评测机\"集合 $\\{x_i, x_j, x_k\\}$ 的中位数是哪个元素？\"。评测机将回复一个整数 $\\mathbf{L}$，表示该集合的中位数是 $x_{\\mathbf{L}}$（$\\mathbf{L}$ 总是等于 $i$、$j$ 或 $k$ 之一）。如果你尝试进行第 $(\\mathbf{Q} + 1)$ 次询问，评测机将输出 -1。\n\n当你准备好提交结果时，输出一行包含 $\\mathbf{N}$ 个整数，表示元素按升序或降序排列的索引。评测机将回复一个整数 1 表示答案正确，或 -1 表示错误。在接收到第 $\\mathbf{T}$ 个测试用例的评测结果后，你的程序必须及时结束以避免超时错误。此外，如果在接收到第 $\\mathbf{T}$ 个测试用例的结果后继续输出，将被判为错误答案。\n\n如果评测机在任何时候接收到格式错误或无效的值，它将输出 -1。在输出 -1 后，评测机将不再输出任何内容。如果你的程序在接收到 -1 后继续等待评测机输出，将会因超时而收到 Time Limit Exceeded 错误。注意，确保程序及时退出以避免超时错误是你的责任。如果内存超出限制或程序运行时出错，将收到相应的判定结果。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "你可以使用此测试工具在本地或我们的平台上进行测试。要在本地测试，你需要同时运行工具和你的代码；可以使用我们的[交互式运行器](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请参阅该文件注释中的说明，并查看 FAQ 的交互式问题部分。\n\n测试工具的说明包含在工具的注释中。我们建议你添加自己的测试用例。请注意，尽管测试工具旨在模拟评测系统，但它**并非**真实的评测系统，行为可能有所不同。\n\n**数据范围**\n\n- $\\mathbf{T} = 100$。\n\n**测试集 1（7 分，可见判定结果）**\n\n- $\\mathbf{N} = 10$。\n- $\\mathbf{Q} = 300 \\cdot \\mathbf{T}$。\n\n**测试集 2（11 分，可见判定结果）**\n\n- $\\mathbf{N} = 50$。\n- $\\mathbf{Q} = 300 \\cdot \\mathbf{T}$。\n\n**测试集 3（10 分，隐藏判定结果）**\n\n- $\\mathbf{N} = 50$。\n- $\\mathbf{Q} = 170 \\cdot \\mathbf{T}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13025", "type": "P", "difficulty": 5, "samples": [["Use the download button above to view the full sample input.", "Use the download button above to view the full sample input."]], "limits": {"time": [60000, 60000], "memory": [1048576, 1048576]}, "tags": ["2021", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2021 Qualification] Cheating Detection", "background": "", "description": "100 players are competing in a 10000-question trivia tournament; the players are numbered from 1 to 100. Player $i$ has a skill level of $S_i$ and question $j$ has a difficulty level of $Q_j$. Each skill level and each question difficulty are chosen uniformly at random from the range $[-3.00, 3.00]$, and independently of all other choices. For example, a player can have a skill level of 2.47853 and a question can have a difficulty level of -1.4172.\n\nWhen player $i$ tries to answer question $j$, the probability that they answer it correctly is $f(S_i - Q_j)$, where $f$ is the sigmoid function:\n\n$$f(x) = \\frac{1}{1 + e^{-x}}$$\n\nwhere $e$ is Euler's number (approximately 2.718...), the mathematical constant. Notice that $0 < f(x) < 1$ for all $x$, so $f(S_i - Q_j)$ is always a valid probability. Each of these answer attempts is chosen at random independently of all other choices.\n\nThere is one exception: exactly one of the players is a cheater! The cheater is chosen uniformly at random from among all players, and independently of all other choices. The cheater behaves as follows: before answering each question, they flip a fair coin. If it comes up heads, they do not cheat and the rules work as normal. If it comes up tails, they secretly look up the answer on the Internet and answer the question correctly. Formally, they decide whether to cheat at random with 0.5 probability for each question, independently of all other choices.\n\nThe results of a tournament consist of only the per-question results (correct or incorrect) for each player. Apart from the general description above, you do not know anything about the skill levels of the players or the difficulties of the questions.\n\nYou must correctly identify the cheater in at least $\\mathbf{P}$ percent of the test cases. That is, you must succeed in at least $\\mathbf{P} \\cdot \\mathbf{T}/100$ out of $\\mathbf{T}$ cases.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. The second line of the input gives the percentage of test cases, $\\mathbf{P}$, that you must answer correctly for your solution to be considered correct. $\\mathbf{T}$ test cases follow. Each case consists of 100 lines of 10000 characters each. The $j$-th character on the $i$-th line is $1$ if the $i$-th player answered the $j$-th question correctly, or $0$ if they answered it incorrectly.", "outputFormat": "For each test case, output one line containing Case #$x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is the number of the cheater (with player numbers starting from 1).", "hint": "**Sample Explanation**\n\nNotice that the sample input uses $\\mathbf{T} = 1$ and $\\mathbf{P} = 0$ and therefore does not meet the limits of any test set. The sample output for it is the actual cheater.\n\n**Limits**\n\n- $\\mathbf{T} = 50$.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- $\\mathbf{P} = 10$.\n\n**Test Set 2 (20 Pts, Visible Verdict)**\n\n- $\\mathbf{P} = 86$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Qualification] Cheating Detection", "background": "", "description": "100 players are competing in a 10000-question trivia tournament; the players are numbered from 1 to 100. Player $i$ has a skill level of $S_i$ and question $j$ has a difficulty level of $Q_j$. Each skill level and each question difficulty are chosen uniformly at random from the range $[-3.00, 3.00]$, and independently of all other choices. For example, a player can have a skill level of 2.47853 and a question can have a difficulty level of -1.4172.\n\nWhen player $i$ tries to answer question $j$, the probability that they answer it correctly is $f(S_i - Q_j)$, where $f$ is the sigmoid function:\n\n$$f(x) = \\frac{1}{1 + e^{-x}}$$\n\nwhere $e$ is Euler's number (approximately 2.718...), the mathematical constant. Notice that $0 < f(x) < 1$ for all $x$, so $f(S_i - Q_j)$ is always a valid probability. Each of these answer attempts is chosen at random independently of all other choices.\n\nThere is one exception: exactly one of the players is a cheater! The cheater is chosen uniformly at random from among all players, and independently of all other choices. The cheater behaves as follows: before answering each question, they flip a fair coin. If it comes up heads, they do not cheat and the rules work as normal. If it comes up tails, they secretly look up the answer on the Internet and answer the question correctly. Formally, they decide whether to cheat at random with 0.5 probability for each question, independently of all other choices.\n\nThe results of a tournament consist of only the per-question results (correct or incorrect) for each player. Apart from the general description above, you do not know anything about the skill levels of the players or the difficulties of the questions.\n\nYou must correctly identify the cheater in at least $\\mathbf{P}$ percent of the test cases. That is, you must succeed in at least $\\mathbf{P} \\cdot \\mathbf{T}/100$ out of $\\mathbf{T}$ cases.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. The second line of the input gives the percentage of test cases, $\\mathbf{P}$, that you must answer correctly for your solution to be considered correct. $\\mathbf{T}$ test cases follow. Each case consists of 100 lines of 10000 characters each. The $j$-th character on the $i$-th line is $1$ if the $i$-th player answered the $j$-th question correctly, or $0$ if they answered it incorrectly.", "outputFormat": "For each test case, output one line containing Case #$x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is the number of the cheater (with player numbers starting from 1).", "hint": "**Sample Explanation**\n\nNotice that the sample input uses $\\mathbf{T} = 1$ and $\\mathbf{P} = 0$ and therefore does not meet the limits of any test set. The sample output for it is the actual cheater.\n\n**Limits**\n\n- $\\mathbf{T} = 50$.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- $\\mathbf{P} = 10$.\n\n**Test Set 2 (20 Pts, Visible Verdict)**\n\n- $\\mathbf{P} = 86$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Qualification] Cheating Detection", "background": "", "description": "100 名玩家正在参加一场包含 10000 道问题的问答锦标赛，玩家编号为 1 至 100。玩家 $i$ 拥有技能值 $S_i$，问题 $j$ 拥有难度值 $Q_j$。每个技能值和难度值都是从 $[-3.00, 3.00]$ 范围内均匀随机且独立选取的。例如，某个玩家的技能值可能是 2.47853，而某个问题的难度值可能是 -1.4172。\n\n当玩家 $i$ 尝试回答问题 $j$ 时，其答对的概率为 $f(S_i - Q_j)$，其中 $f$ 是 sigmoid 函数：\n$$f(x) = \\frac{1}{1 + e^{-x}}$$\n这里 $e$ 是自然对数的底（约 2.718...）。注意到对所有 $x$ 都有 $0 < f(x) < 1$，因此 $f(S_i - Q_j)$ 始终是有效的概率值。所有答题行为都是随机且独立进行的。\n\n但有一个例外：这些玩家中**恰好有一个是作弊者**！作弊者是从所有玩家中均匀随机选出的，且与其他选择独立。作弊者的行为如下：在回答每个问题前，他们会抛一枚公平硬币。如果结果为正面，则不作弊并正常答题；如果为反面，则会秘密查阅正确答案并确保答对。形式化地说，他们对每个问题以 0.5 的概率独立决定是否作弊。\n\n锦标赛的结果仅包含每位玩家对每道题目的答题结果（正确或错误）。除了上述描述外，你无法获知任何关于玩家技能值或问题难度的具体信息。\n\n你需要在至少 $\\mathbf{P}$% 的测试用例中正确识别作弊者。也就是说，在 $\\mathbf{T}$ 个测试用例中，你至少要正确判断 $\\mathbf{P} \\cdot \\mathbf{T}/100$ 个。\n", "inputFormat": "输入的第一行给出测试用例数量 $\\mathbf{T}$。第二行给出通过测试所需的正确率 $\\mathbf{P}$。随后是 $\\mathbf{T}$ 个测试用例，每个用例包含 100 行，每行 10000 个字符。第 $i$ 行的第 $j$ 个字符为 $1$ 表示第 $i$ 名玩家答对了第 $j$ 题，为 $0$ 表示答错。\n", "outputFormat": "对于每个测试用例，输出一行 Case #$x$: $y$，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是作弊者的编号（玩家编号从 1 开始）。\n", "hint": "**样例说明**\n\n注意样例输入使用 $\\mathbf{T} = 1$ 和 $\\mathbf{P} = 0$，因此不满足任何测试集的限制条件。其样例输出展示了实际的作弊者编号。\n\n**数据范围**\n\n- $\\mathbf{T} = 50$\n\n**测试集 1（11 分，可见判定）**\n\n- $\\mathbf{P} = 10$\n\n**测试集 2（20 分，可见判定）**\n\n- $\\mathbf{P} = 86$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13026", "type": "P", "difficulty": 3, "samples": [["4\n3\n100 7 10\n2\n10 10\n3\n4 19 1\n3\n1 2 3", "Case #1: 4\nCase #2: 1\nCase #3: 2\nCase #4: 0"]], "limits": {"time": [10000, 10000, 10000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "2021", "Google Code Jam"], "title": "[GCJ 2021 #1A] Append Sort\t", "background": "", "description": "We have a list of integers $X_1, X_2, \\ldots, X_N$. We would like them to be in strictly increasing order, but unfortunately, we cannot reorder them. This means that usual sorting algorithms will not work.\n\nOur only option is to change them by appending digits $0$ through $9$ to their right (in base $10$). For example, if one of the integers is $10$, you can turn it into $100$ or $109$ with a single append operation, or into $1034$ with two operations (as seen in the image below).\n\nGiven the current list, what is the minimum number of single digit append operations that are necessary for the list to be in strictly increasing order?\n\nFor example, if the list is $100, 7, 10$, we can use $4$ total operations to make it into a sorted list, as the following image shows.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x5uxrlzd.png)", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in two lines. The first line of a test case contains a single integer $\\mathbf{N}$, the number of integers in the list. The second line contains $\\mathbf{N}$ integers $\\mathbf{X}_1, \\mathbf{X}_2, \\ldots, \\mathbf{X}_\\mathbf{N}$, the members of the list.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of single digit append operations needed for the list to be in strictly increasing order.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the input is the same as in the example given in the problem statement. As the image shows, the list can be turned into a sorted list with 4 operations. Notice that the last two integers need to end up with at least 3 digits (requiring at least 3 append operations in total). If all of the final numbers had exactly three digits, the second would be larger than the third because it starts with a 7 instead of a 1. This means we cannot do it with fewer than 4 operations.\n\nIn Sample Case #2, notice that the list needs to be in strictly increasing order, so we have to do at least one operation. In this case, any valid append operation to the second integer works.\n\nIn Sample Case #3, we can use two append operations to get the list to 4, 19, 193.\n\nIn Sample Case #4, the given list is already in strictly increasing order, so no operations are necessary.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test Set 1 (12 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 3$.\n- $1 \\leq \\mathbf{X}_i \\leq 100$, for all $i$.\n\n**Test Set 2 (14 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.\n- $1 \\leq \\mathbf{X}_i \\leq 10^9$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1A] Append Sort\t", "background": "", "description": "We have a list of integers $X_1, X_2, \\ldots, X_N$. We would like them to be in strictly increasing order, but unfortunately, we cannot reorder them. This means that usual sorting algorithms will not work.\n\nOur only option is to change them by appending digits $0$ through $9$ to their right (in base $10$). For example, if one of the integers is $10$, you can turn it into $100$ or $109$ with a single append operation, or into $1034$ with two operations (as seen in the image below).\n\nGiven the current list, what is the minimum number of single digit append operations that are necessary for the list to be in strictly increasing order?\n\nFor example, if the list is $100, 7, 10$, we can use $4$ total operations to make it into a sorted list, as the following image shows.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x5uxrlzd.png)", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case is described in two lines. The first line of a test case contains a single integer $\\mathbf{N}$, the number of integers in the list. The second line contains $\\mathbf{N}$ integers $\\mathbf{X}_1, \\mathbf{X}_2, \\ldots, \\mathbf{X}_\\mathbf{N}$, the members of the list.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of single digit append operations needed for the list to be in strictly increasing order.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the input is the same as in the example given in the problem statement. As the image shows, the list can be turned into a sorted list with 4 operations. Notice that the last two integers need to end up with at least 3 digits (requiring at least 3 append operations in total). If all of the final numbers had exactly three digits, the second would be larger than the third because it starts with a 7 instead of a 1. This means we cannot do it with fewer than 4 operations.\n\nIn Sample Case #2, notice that the list needs to be in strictly increasing order, so we have to do at least one operation. In this case, any valid append operation to the second integer works.\n\nIn Sample Case #3, we can use two append operations to get the list to 4, 19, 193.\n\nIn Sample Case #4, the given list is already in strictly increasing order, so no operations are necessary.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test Set 1 (12 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 3$.\n- $1 \\leq \\mathbf{X}_i \\leq 100$, for all $i$.\n\n**Test Set 2 (14 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 100$.\n- $1 \\leq \\mathbf{X}_i \\leq 10^9$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1A] Append Sort", "background": "", "description": "我们有一个整数列表 $X_1, X_2, \\ldots, X_N$。我们希望它们能按**严格递增**的顺序排列，但遗憾的是不能直接重新排序。这意味着常规的排序算法无法使用。\n\n我们唯一的操作是在这些数字的右侧（十进制下）追加数字 $0$ 到 $9$。例如，若某数字是 $10$，通过一次追加操作可以变为 $100$ 或 $109$，通过两次操作可变为 $1034$（如下图所示）。\n\n给定当前列表，至少需要进行多少次单数字追加操作才能使列表严格递增？\n\n例如，对于列表 $100, 7, 10$，可通过 $4$ 次操作将其变为有序列表，如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x5uxrlzd.png)", "inputFormat": "输入的第一行给出测试用例数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例由两行描述：第一行包含一个整数 $\\mathbf{N}$，表示列表中的数字数量；第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{X}_1, \\mathbf{X}_2, \\ldots, \\mathbf{X}_\\mathbf{N}$，即列表成员。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为使列表严格递增所需的最少单数字追加操作次数。\n", "hint": "**样例解释**\n\n在样例 #1 中，输入与题目描述中的示例相同。如图所示，需 $4$ 次操作使列表有序。注意最后两个数字最终至少需要 $3$ 位数字（共需至少 $3$ 次追加操作）。若所有数字最终均为 $3$ 位，由于第二个数字以 $7$ 开头而第三个以 $1$ 开头，第二个数字仍会大于第三个，因此无法用少于 $4$ 次操作完成。\n\n在样例 #2 中，由于要求严格递增，必须至少进行 $1$ 次操作。此处对第二个数字追加任意有效数字均可。\n\n在样例 #3 中，可通过 $2$ 次操作将列表变为 $4, 19, 193$。\n\n在样例 #4 中，列表已严格递增，无需操作。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n\n**测试集 1（12 分，可见判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 3$。\n- $1 \\leq \\mathbf{X}_i \\leq 100$（对所有 $i$）。\n\n**测试集 2（14 分，可见判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 100$。\n- $1 \\leq \\mathbf{X}_i \\leq 10^9$（对所有 $i$）。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13027", "type": "P", "difficulty": 4, "samples": [["4\n5\n2 2\n3 1\n5 2\n7 1\n11 1\n1\n17 2\n2\n2 2\n3 1\n1\n2 7", "Case #1: 25\nCase #2: 17\nCase #3: 0\nCase #4: 8"]], "limits": {"time": [45000, 45000, 45000, 45000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2021", "数论", "枚举", "Google Code Jam"], "title": "[GCJ 2021 #1A] Prime Time", "background": "", "description": "You are playing a new solitaire game called Prime Time. You are given a deck of cards, and each card has a prime number written on it. Multiple cards may have the same number.\n\nYour goal is to divide the cards into two groups in such a way that the sum of the numbers in the first group is equal to the product of the numbers in the second group. Each card must belong to exactly one of the two groups, and each group must contain at least one card. The sum or product of a group that consists of a single card is simply the number on that card.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n1zowb5r.png)\n\nFor example, in the image above, the left group has cards whose sum is $25$ and the right group has cards whose product is $25$. Therefore, this is a valid split into groups.\n\nYour score is the sum of the numbers in the first group (which is equal to the product of the numbers in the second group), or $0$ if you cannot split the cards this way at all. What is the maximum score you can achieve?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of each test case contains a single integer $\\mathbf{M}$, representing the number of distinct prime numbers in your deck. Each of the next $\\mathbf{M}$ lines contains two values: $\\mathbf{P}_i$ and $\\mathbf{N}_i$, representing that you have exactly $\\mathbf{N}_i$ cards with the prime $\\mathbf{P}_i$ written on them.\n\nNote that the total number of cards in your deck is the sum of all $\\mathbf{N}_i$s.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum score you can achieve.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the optimal split is: $11 + 2 + 7 + 3 + 2 = 5 \\cdot 5$. Another split is also possible: $5 + 7 + 3 + 2 + 5 = 11 \\cdot 2$, but it gives a lower score.\n\nIn Sample Case #2, note that cards with the same number can be placed in different groups.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{M} \\leq 95$. (Note that there are exactly 95 distinct primes between 2 and 499)\n- $2 \\leq \\mathbf{P}_i \\leq 499$, for all $i$.\n- Each $\\mathbf{P}_i$ is prime.\n- $\\mathbf{P}_i < \\mathbf{P}_{i+1}$, for all $i$. (The primes are given in strictly increasing order)\n- $1 \\leq \\mathbf{N}_i$, for all $i$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N}_1 + \\mathbf{N}_2 + \\cdots + \\mathbf{N}_\\mathbf{M} \\leq 10$.\n\n**Test Set 2 (13 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N}_1 + \\mathbf{N}_2 + \\cdots + \\mathbf{N}_\\mathbf{M} \\leq 100$.\n\n**Test Set 3 (15 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{N}_1 + \\mathbf{N}_2 + \\cdots + \\mathbf{N}_\\mathbf{M} \\leq 10^{15}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1A] Prime Time", "background": "", "description": "You are playing a new solitaire game called Prime Time. You are given a deck of cards, and each card has a prime number written on it. Multiple cards may have the same number.\n\nYour goal is to divide the cards into two groups in such a way that the sum of the numbers in the first group is equal to the product of the numbers in the second group. Each card must belong to exactly one of the two groups, and each group must contain at least one card. The sum or product of a group that consists of a single card is simply the number on that card.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n1zowb5r.png)\n\nFor example, in the image above, the left group has cards whose sum is $25$ and the right group has cards whose product is $25$. Therefore, this is a valid split into groups.\n\nYour score is the sum of the numbers in the first group (which is equal to the product of the numbers in the second group), or $0$ if you cannot split the cards this way at all. What is the maximum score you can achieve?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of each test case contains a single integer $\\mathbf{M}$, representing the number of distinct prime numbers in your deck. Each of the next $\\mathbf{M}$ lines contains two values: $\\mathbf{P}_i$ and $\\mathbf{N}_i$, representing that you have exactly $\\mathbf{N}_i$ cards with the prime $\\mathbf{P}_i$ written on them.\n\nNote that the total number of cards in your deck is the sum of all $\\mathbf{N}_i$s.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum score you can achieve.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the optimal split is: $11 + 2 + 7 + 3 + 2 = 5 \\cdot 5$. Another split is also possible: $5 + 7 + 3 + 2 + 5 = 11 \\cdot 2$, but it gives a lower score.\n\nIn Sample Case #2, note that cards with the same number can be placed in different groups.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{M} \\leq 95$. (Note that there are exactly 95 distinct primes between 2 and 499)\n- $2 \\leq \\mathbf{P}_i \\leq 499$, for all $i$.\n- Each $\\mathbf{P}_i$ is prime.\n- $\\mathbf{P}_i < \\mathbf{P}_{i+1}$, for all $i$. (The primes are given in strictly increasing order)\n- $1 \\leq \\mathbf{N}_i$, for all $i$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N}_1 + \\mathbf{N}_2 + \\cdots + \\mathbf{N}_\\mathbf{M} \\leq 10$.\n\n**Test Set 2 (13 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N}_1 + \\mathbf{N}_2 + \\cdots + \\mathbf{N}_\\mathbf{M} \\leq 100$.\n\n**Test Set 3 (15 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{N}_1 + \\mathbf{N}_2 + \\cdots + \\mathbf{N}_\\mathbf{M} \\leq 10^{15}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1A] Prime Time", "background": "", "description": "你正在玩一款名为**质数时刻**的新单人纸牌游戏。你有一副卡牌，每张牌上写有一个质数，不同牌可能写有相同的数字。\n\n游戏目标是将所有卡牌分成两组：第一组卡牌上的数字之和等于第二组卡牌上的数字之积。每张牌必须属于其中一组，且每组至少包含一张牌。若某组仅有一张牌，则该组的和或积即为该牌上的数字。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n1zowb5r.png)\n\n例如上图中，左侧卡牌数字之和为 $25$，右侧卡牌数字之积也为 $25$，因此这是一个有效的分组方案。\n\n你的得分等于第一组数字之和（即第二组数字之积），若无法完成这样的分组则得分为 $0$。你能获得的最高得分是多少？\n", "inputFormat": "输入第一行包含测试用例数量 $\\mathbf{T}$。随后每个测试用例包含：\n- 第一行：整数 $\\mathbf{M}$，表示牌堆中不同质数的种类数\n- 接下来 $\\mathbf{M}$ 行：每行两个数 $\\mathbf{P}_i$ 和 $\\mathbf{N}_i$，表示有 $\\mathbf{N}_i$ 张数字为 $\\mathbf{P}_i$ 的卡牌\n\n注意牌堆总卡牌数为所有 $\\mathbf{N}_i$ 之和。", "outputFormat": "对每个测试用例，输出 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为可获得的最大得分。\n", "hint": "**样例解释**\n\n在样例 #1 中，最优分组为 $11 + 2 + 7 + 3 + 2 = 5 \\cdot 5$。另一可行分组 $5 + 7 + 3 + 2 + 5 = 11 \\cdot 2$ 得分较低。\n\n在样例 #2 中，注意相同数字的卡牌可以分到不同组。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$\n- $1 \\leq \\mathbf{M} \\leq 95$（在 2 至 499 之间的质数共 95 个）\n- $2 \\leq \\mathbf{P}_i \\leq 499$（均为质数）\n- $\\mathbf{P}_i < \\mathbf{P}_{i+1}$（质数按严格递增顺序给出）\n- $1 \\leq \\mathbf{N}_i$\n\n**测试集 1（7 分，可见判定）**\n- 总卡牌数 $2 \\leq \\sum \\mathbf{N}_i \\leq 10$\n\n**测试集 2（13 分，可见判定）**\n- 总卡牌数 $2 \\leq \\sum \\mathbf{N}_i \\leq 100$\n\n**测试集 3（15 分，隐藏判定）**\n- 总卡牌数 $2 \\leq \\sum \\mathbf{N}_i \\leq 10^{15}$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13028", "type": "P", "difficulty": 5, "samples": [["4\n1 3\nFFT 3\n1 3\nFFT 2\n2 6\nFFTTTF 2\nFTFTFT 4\n2 2\nFF 1\nTT 1", "Case #1: FFT 3/1\nCase #2: FFT 2/1\nCase #3: FTFFFT 4/1\nCase #4: TF 1/1"], ["1\n3 120\nFFTFFFTFFFTTTTTTTFTFFFFFFTTTFTFFFTFTFFTTFTFFTFFTTTFTFTFFTFTFTTFFFFTFTFFFFTTTFTTFTTTTFFFTTFFFFFTTFFTFFTFFTTTFFFFTTFFTFTTF 55\nFFFTFFTTFFFFTFTFFTFFFTTTTTTFFFTTTFTTTTFFTFTTTFTTFFTTTFTFFFFTFFTTFFTTFTTFFTFTFFTFTTFTFTFFTTTFFTFTFTTFFTFTFTFTTFFTFFFTFTFT 62\nFFFTFTTFFFFFTFTFTTTTTTFFTTFTFFFTFFTTTTTTFFFTTTFFFTTFTFFFFFFTFTTFFTFTTTFTTTTFTTFFFFTFFTTFTFFTTTTTTFTFFFFFTTFFTFTFTFFTTTTT 64", "Case #1: FFFTFTTTFFFFTFTFFTFTTTTTTTFFFFTTTFTTTTFFTFTTTTTFFFTFTFTFFFFTFFTTFTFTFTTTTTFFTFFFFFFFFTTFTTTTTTFTTTTFFFFTFTFTTFTFFFFTTTFT 189154508532118369075350624633/2901503505434414233388602018"]], "limits": {"time": [30000, 30000, 30000, 30000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2021", "Special Judge", "组合数学", "期望", "Google Code Jam"], "title": "[GCJ 2021 #1A] Hacked Exam", "background": "", "description": "There is an exam with $\\mathbf{Q}$ true or false questions. The correct answer to each question is either $\\mathsf{T}$ or $\\mathsf{F}$. Each student taking the exam selects either $\\mathsf{T}$ or $\\mathsf{F}$ for each question, and the student's score is the number of questions they answer correctly.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jwf5pdvs.png)\n\nThere are $\\mathbf{N}$ students who have already taken this exam. For each of those students, you know the answers they gave to each question and their final score. Assuming that any sequence of answers that is consistent with all of those students' scores has the same probability of being the correct sequence of answers, you want to maximize your own expected score. Determine what that expected score is and how to answer the questions so that you achieve it.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of each test case contains two integers $\\mathbf{N}$ and $\\mathbf{Q}$: the number of students and the number of questions, respectively. Each of the next $\\mathbf{N}$ lines contains a string $\\mathbf{A}_i$ and an integer $\\mathbf{S}_i$: the $i$-th student's answers and their score, respectively. The $j$-th character of $\\mathbf{A}_i$ is either $\\mathsf{T}$ or $\\mathsf{F}$, representing the answer the $i$-th student gave to the $j$-th question.", "outputFormat": "For each test case, output one line containing `Case #x: y z/w`, where $x$ is the test case number (starting from 1), $y$ is a string representing a sequence of answers that yields the maximum expected score (in the same format as the input), and $\\frac{z}{w}$ is the maximum expected score as an irreducible fraction (that is, $w$ must be positive and of minimum possible value).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, given that the score for $\\mathsf{FFT}$ is 3, the sequence of correct answers must be $\\mathsf{FFT}$.\n\nIn Sample Case #2, given that the score for $\\mathsf{FFT}$ is 2, the sequence of correct answers is $\\mathsf{FFF}$, $\\mathsf{FTT}$, or $\\mathsf{TFT}$, each with probability $\\frac{1}{3}$. Your best strategy is to answer $\\mathsf{FFT}$, to achieve the expected score of $\\frac{1}{3} \\times 2 + \\frac{1}{3} \\times 2 + \\frac{1}{3} \\times 2 = 2$.\n\nIn Sample Case #3, there are other answers that also achieve an expected score of 4, like $\\mathsf{FTFTFT}$.\n\nIn Sample Case #4, one of the questions' answer is $\\mathsf{T}$ and the other one is $\\mathsf{F}$, but you do not know which is which. Answering $\\mathsf{TF}$ or $\\mathsf{FT}$ scores you 2 with probability $\\frac{1}{2}$ and 0 with probability $\\frac{1}{2}$, yielding an expected score of 1. Answering $\\mathsf{FF}$ or $\\mathsf{TT}$ guarantees a score of 1. Since any sequence of answers gives the same expected score, you can output any of them.\n\nSample 2 fits the limits of Test Set 3. It will not be run against your submitted solutions.\n\nIn the Sample Case for Test Set 3, you can get an expected score over 65, which is higher than the actual score of any of the other students. Notice that both the numerator and denominator of the expected score can be significantly larger than $2^{64}$ (the numerator in this case actually exceeds $2^{97}$).\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 2021$.\n- The length of $\\mathbf{A}_{\\mathbf{i}}=\\mathbf{Q}$, for all $i$.\n- Each character of $\\mathbf{A}_{\\mathbf{i}}$ is an uppercase $\\mathsf{T}$ or an uppercase $\\mathsf{F}$, for all $i$.\n- $0 \\leq \\mathbf{S}_{\\mathbf{i}} \\leq \\mathbf{Q}$, for all $i$.\n- There exists at least one sequence of correct answers consistent with the input.\n\n**Test Set 1 (8 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 2$.\n- $1 \\leq \\mathbf{Q} \\leq 10$.\n\n**Test Set 2 (6 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 2$.\n- $1 \\leq \\mathbf{Q} \\leq 40$.\n\n**Test Set 3 (25 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 3$.\n- $1 \\leq \\mathbf{Q} \\leq 120$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1A] Hacked Exam", "background": "", "description": "There is an exam with $\\mathbf{Q}$ true or false questions. The correct answer to each question is either $\\mathsf{T}$ or $\\mathsf{F}$. Each student taking the exam selects either $\\mathsf{T}$ or $\\mathsf{F}$ for each question, and the student's score is the number of questions they answer correctly.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jwf5pdvs.png)\n\nThere are $\\mathbf{N}$ students who have already taken this exam. For each of those students, you know the answers they gave to each question and their final score. Assuming that any sequence of answers that is consistent with all of those students' scores has the same probability of being the correct sequence of answers, you want to maximize your own expected score. Determine what that expected score is and how to answer the questions so that you achieve it.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of each test case contains two integers $\\mathbf{N}$ and $\\mathbf{Q}$: the number of students and the number of questions, respectively. Each of the next $\\mathbf{N}$ lines contains a string $\\mathbf{A}_i$ and an integer $\\mathbf{S}_i$: the $i$-th student's answers and their score, respectively. The $j$-th character of $\\mathbf{A}_i$ is either $\\mathsf{T}$ or $\\mathsf{F}$, representing the answer the $i$-th student gave to the $j$-th question.", "outputFormat": "For each test case, output one line containing `Case #x: y z/w`, where $x$ is the test case number (starting from 1), $y$ is a string representing a sequence of answers that yields the maximum expected score (in the same format as the input), and $\\frac{z}{w}$ is the maximum expected score as an irreducible fraction (that is, $w$ must be positive and of minimum possible value).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, given that the score for $\\mathsf{FFT}$ is 3, the sequence of correct answers must be $\\mathsf{FFT}$.\n\nIn Sample Case #2, given that the score for $\\mathsf{FFT}$ is 2, the sequence of correct answers is $\\mathsf{FFF}$, $\\mathsf{FTT}$, or $\\mathsf{TFT}$, each with probability $\\frac{1}{3}$. Your best strategy is to answer $\\mathsf{FFT}$, to achieve the expected score of $\\frac{1}{3} \\times 2 + \\frac{1}{3} \\times 2 + \\frac{1}{3} \\times 2 = 2$.\n\nIn Sample Case #3, there are other answers that also achieve an expected score of 4, like $\\mathsf{FTFTFT}$.\n\nIn Sample Case #4, one of the questions' answer is $\\mathsf{T}$ and the other one is $\\mathsf{F}$, but you do not know which is which. Answering $\\mathsf{TF}$ or $\\mathsf{FT}$ scores you 2 with probability $\\frac{1}{2}$ and 0 with probability $\\frac{1}{2}$, yielding an expected score of 1. Answering $\\mathsf{FF}$ or $\\mathsf{TT}$ guarantees a score of 1. Since any sequence of answers gives the same expected score, you can output any of them.\n\nSample 2 fits the limits of Test Set 3. It will not be run against your submitted solutions.\n\nIn the Sample Case for Test Set 3, you can get an expected score over 65, which is higher than the actual score of any of the other students. Notice that both the numerator and denominator of the expected score can be significantly larger than $2^{64}$ (the numerator in this case actually exceeds $2^{97}$).\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 2021$.\n- The length of $\\mathbf{A}_{\\mathbf{i}}=\\mathbf{Q}$, for all $i$.\n- Each character of $\\mathbf{A}_{\\mathbf{i}}$ is an uppercase $\\mathsf{T}$ or an uppercase $\\mathsf{F}$, for all $i$.\n- $0 \\leq \\mathbf{S}_{\\mathbf{i}} \\leq \\mathbf{Q}$, for all $i$.\n- There exists at least one sequence of correct answers consistent with the input.\n\n**Test Set 1 (8 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 2$.\n- $1 \\leq \\mathbf{Q} \\leq 10$.\n\n**Test Set 2 (6 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 2$.\n- $1 \\leq \\mathbf{Q} \\leq 40$.\n\n**Test Set 3 (25 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 3$.\n- $1 \\leq \\mathbf{Q} \\leq 120$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1A] Hacked Exam", "background": "", "description": "一场考试包含 $\\mathbf{Q}$ 道判断题，每道题的正确答案是 $\\mathsf{T}$ 或 $\\mathsf{F}$。每位考生为每道题选择 $\\mathsf{T}$ 或 $\\mathsf{F}$，其得分是答对的题数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/jwf5pdvs.png)\n\n已有 $\\mathbf{N}$ 名学生参加了这场考试。对于每名学生，你知道他们的答案和最终得分。假设所有与学生得分一致的正确答案序列出现的概率相同，你需要最大化自己的期望得分。请确定该期望得分，并给出能达到该得分的答题方案。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{Q}$：分别表示学生人数和题目数量。接下来的 $\\mathbf{N}$ 行，每行包含一个字符串 $\\mathbf{A}_i$ 和一个整数 $\\mathbf{S}_i$：分别表示第 $i$ 名学生的答案和得分。$\\mathbf{A}_i$ 的第 $j$ 个字符是 $\\mathsf{T}$ 或 $\\mathsf{F}$，表示第 $i$ 名学生第 $j$ 道题的答案。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y z/w`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是一个字符串，表示能获得最大期望得分的答案序列（格式与输入相同），$\\frac{z}{w}$ 是最大期望得分的最简分数形式（即 $w$ 必须为正且最小）。\n", "hint": "**样例解释**\n\n在样例 #1 中，由于 $\\mathsf{FFT}$ 的得分为 3，正确答案序列必须是 $\\mathsf{FFT}$。\n\n在样例 #2 中，由于 $\\mathsf{FFT}$ 的得分为 2，正确答案序列可能是 $\\mathsf{FFF}$、$\\mathsf{FTT}$ 或 $\\mathsf{TFT}$，每种概率为 $\\frac{1}{3}$。最佳策略是回答 $\\mathsf{FFT}$，期望得分为 $\\frac{1}{3} \\times 2 + \\frac{1}{3} \\times 2 + \\frac{1}{3} \\times 2 = 2$。\n\n在样例 #3 中，其他答案（如 $\\mathsf{FTFTFT}$）也能达到期望得分 4。\n\n在样例 #4 中，一道题的答案是 $\\mathsf{T}$，另一道是 $\\mathsf{F}$，但无法确定顺序。回答 $\\mathsf{TF}$ 或 $\\mathsf{FT}$ 有 $\\frac{1}{2}$ 概率得 2 分，$\\frac{1}{2}$ 概率得 0 分，期望得分为 1。回答 $\\mathsf{FF}$ 或 $\\mathsf{TT}$ 保证得 1 分。由于所有答案序列的期望得分相同，可以输出任意一个。\n\n样例 2 符合测试集 3 的限制。它不会用于测试你的提交。\n\n在测试集 3 的样例中，你可以获得超过 65 的期望得分，高于其他学生的实际得分。注意，期望分数的分子和分母可能远大于 $2^{64}$（此样例的分子实际超过 $2^{97}$）。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 2021$。\n- 对于所有 $i$，$\\mathbf{A}_{\\mathbf{i}}$ 的长度为 $\\mathbf{Q}$。\n- 对于所有 $i$，$\\mathbf{A}_{\\mathbf{i}}$ 的每个字符是大写 $\\mathsf{T}$ 或 $\\mathsf{F}$。\n- 对于所有 $i$，$0 \\leq \\mathbf{S}_{\\mathbf{i}} \\leq \\mathbf{Q}$。\n- 输入至少存在一个一致的正确答案序列。\n\n**测试集 1（8 分，可见评测结果）**\n\n- $1 \\leq \\mathbf{N} \\leq 2$。\n- $1 \\leq \\mathbf{Q} \\leq 10$。\n\n**测试集 2（6 分，隐藏评测结果）**\n\n- $1 \\leq \\mathbf{N} \\leq 2$。\n- $1 \\leq \\mathbf{Q} \\leq 40$。\n\n**测试集 3（25 分，隐藏评测结果）**\n\n- $1 \\leq \\mathbf{N} \\leq 3$。\n- $1 \\leq \\mathbf{Q} \\leq 120$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13029", "type": "P", "difficulty": 4, "samples": [["3\n0 0 0\n0 21600000000000 23400000000000\n1476000000000 2160000000000 3723000000000", "Case #1: 0 0 0 0\nCase #2: 6 30 0 0\nCase #3: 1 2 3 0"], ["3\n5400000000000 5400000000000 5400000000000\n10800000000000 32400000000000 34200000000000\n23076000000000 23760000000000 25323000000000", "Case #1: 0 0 0 0\nCase #2: 0 30 0 0\nCase #3: 1 2 3 0"], ["1\n0 11 719", "Case #1: 0 0 0 1"]], "limits": {"time": [30000, 30000, 30000, 30000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2021", "Special Judge", "Google Code Jam"], "title": "[GCJ 2021 #1B] Broken Clock", "background": "", "description": "Emmett found an old clock in his attic. The clock is a circle with 3 hands that attach to the center and rotate clockwise at constant speeds. They are called the $hours$ $hand$, the $minutes$ $hand$ and the $seconds$ $hand$. At midnight, all hands point up. The hours hand completes a full revolution in 12 hours, the minutes hand completes a full revolution in 1 hour, and the seconds hand completes a full revolution in 1 minute. 1 hour is equal to 60 minutes, 1 minute is equal to 60 seconds, and 1 second is equal to $10^{9}$ nanoseconds.\n\nFor example, the clock depicted below is showing that the time is exactly 6 hours and 30 minutes after midnight. The hours hand (short black) is halfway between 6 and 7 (completed 6.5/12 of a revolution), the minutes hand (long black) is pointing straight down because it has completed exactly 6 and a half full revolutions and the seconds hand (red) is pointing straight up because it has completed an integer number of full revolutions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h3nslzqx.png)\n\nUnfortunately, the hands are broken, so they all look identical and there is no way to know which hand is which. The clock in the picture above, with its hands broken, would look like this.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4m1446he.png)\n\nEmmett does know that the time was strictly before noon, that is, strictly less than 12 hours after midnight. Emmett has taken a picture of the clock. Given that picture (represented by the angles of the hands relative to a single arbitrary axis), figure out what time it could correspond to.\n\nNotice that Emmett has already figured out a viable orientation of the clock in some cases (Test Set 1) and has managed to narrow down the possible times to a whole integer number of seconds (Test Sets 1 and 2) or nanoseconds (Test Set 3). Please see the limits sections for more details.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line describes a test case and contains three integers $\\mathbf{A}$, $\\mathbf{B}$, and $\\mathbf{C}$: the angles of each hand, relative to an arbitrary axis and given in ticks in the clockwise direction. 1 tick is equal to $1 / 12 \\times 10^{-10}$ degrees. This means that the hours hand rotates exactly 1 tick each nanosecond, the minutes hand rotates exactly 12 ticks each nanosecond and the seconds hand rotates exactly 720 ticks each nanosecond.\n", "outputFormat": "For each test case, output one line containing `Case #x: h m s n`, where $x$ is the test case number (starting from 1) and $h, m, s$, and $n$ are integers: $h$ is the number of full hours since midnight (between 0 and 11, inclusive), $m$ is the number of full minutes since the last full hour (between 0 and 59, inclusive), $s$ is the number of full seconds since the last full minute (between 0 and 59, inclusive) and $n$ is the number of full nanoseconds since the last full second (between 0 and $10^{9}-1$, inclusive).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, all hands point up (as in the first picture below) which happens only exactly at midnight (as in the second picture below).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ac9ropk5.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/oc7u48j6.png)\n\nSample Case #2 is the one pictured in the main part of the statement. The angles of the hands in degrees are 0, 180 and 195. These angles can correspond to 6h 30m 0s without rotating the clock, as the pictures in the main part of the statement show. Notice however, that at 0h 30m 0s (pictured below), the clock looks the same but rotated 180 degrees.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j5ktfcq2.png)\n\nEven in Test Set 1, 0h 30m 0s would be a valid answer. The limit only says that there is one valid time that does not require rotating the clock, but times that work with rotation are also valid answers.\n\nIn Sample Case #3, the input represents the clock in the first picture below and the given output happens when interpreting the clock as in the second picture below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x2hzcknb.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/u6758coa.png)\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nSample Cases in this test set are the same as in the previous one, but the clock is rotated by $45$, $90$, and $180$ degrees clockwise respectively, as shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/srt7xazp.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/5b9o5qf6.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/2pz53ap7.png)\n\nSample Test Set 3 fits the limits of Test Set 3. It will not be run against your submitted solutions.\n\nAs explained above, 1 nanosecond after midnight the hands are moved by 1, 12, and 720 ticks, respectively. If the clock is also rotated counter-clockwise by 1 tick, the hand angles are exactly the ones given in the input.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{A} \\leq \\mathbf{B} \\leq \\mathbf{C} < 360 \\times 12 \\times 10^{10}$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- There is a time $t$ that corresponds to the input such that:\n  - $t$ is an integer number of seconds after midnight.\n  - $t$ can be read from the input clock without rotating it.\n\n**Test Set 2 (6 Pts, Visible Verdict)**\n\n- There is a time that corresponds to the input and is an integer number of seconds after midnight.\n\n**Test Set 3 (19 Pts, Visible Verdict)**\n\n- There is a time that corresponds to the input and is an integer number of nanoseconds after midnight.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1B] Broken Clock", "background": "", "description": "Emmett found an old clock in his attic. The clock is a circle with 3 hands that attach to the center and rotate clockwise at constant speeds. They are called the $hours$ $hand$, the $minutes$ $hand$ and the $seconds$ $hand$. At midnight, all hands point up. The hours hand completes a full revolution in 12 hours, the minutes hand completes a full revolution in 1 hour, and the seconds hand completes a full revolution in 1 minute. 1 hour is equal to 60 minutes, 1 minute is equal to 60 seconds, and 1 second is equal to $10^{9}$ nanoseconds.\n\nFor example, the clock depicted below is showing that the time is exactly 6 hours and 30 minutes after midnight. The hours hand (short black) is halfway between 6 and 7 (completed 6.5/12 of a revolution), the minutes hand (long black) is pointing straight down because it has completed exactly 6 and a half full revolutions and the seconds hand (red) is pointing straight up because it has completed an integer number of full revolutions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h3nslzqx.png)\n\nUnfortunately, the hands are broken, so they all look identical and there is no way to know which hand is which. The clock in the picture above, with its hands broken, would look like this.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4m1446he.png)\n\nEmmett does know that the time was strictly before noon, that is, strictly less than 12 hours after midnight. Emmett has taken a picture of the clock. Given that picture (represented by the angles of the hands relative to a single arbitrary axis), figure out what time it could correspond to.\n\nNotice that Emmett has already figured out a viable orientation of the clock in some cases (Test Set 1) and has managed to narrow down the possible times to a whole integer number of seconds (Test Sets 1 and 2) or nanoseconds (Test Set 3). Please see the limits sections for more details.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line describes a test case and contains three integers $\\mathbf{A}$, $\\mathbf{B}$, and $\\mathbf{C}$: the angles of each hand, relative to an arbitrary axis and given in ticks in the clockwise direction. 1 tick is equal to $1 / 12 \\times 10^{-10}$ degrees. This means that the hours hand rotates exactly 1 tick each nanosecond, the minutes hand rotates exactly 12 ticks each nanosecond and the seconds hand rotates exactly 720 ticks each nanosecond.\n", "outputFormat": "For each test case, output one line containing `Case #x: h m s n`, where $x$ is the test case number (starting from 1) and $h, m, s$, and $n$ are integers: $h$ is the number of full hours since midnight (between 0 and 11, inclusive), $m$ is the number of full minutes since the last full hour (between 0 and 59, inclusive), $s$ is the number of full seconds since the last full minute (between 0 and 59, inclusive) and $n$ is the number of full nanoseconds since the last full second (between 0 and $10^{9}-1$, inclusive).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, all hands point up (as in the first picture below) which happens only exactly at midnight (as in the second picture below).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ac9ropk5.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/oc7u48j6.png)\n\nSample Case #2 is the one pictured in the main part of the statement. The angles of the hands in degrees are 0, 180 and 195. These angles can correspond to 6h 30m 0s without rotating the clock, as the pictures in the main part of the statement show. Notice however, that at 0h 30m 0s (pictured below), the clock looks the same but rotated 180 degrees.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j5ktfcq2.png)\n\nEven in Test Set 1, 0h 30m 0s would be a valid answer. The limit only says that there is one valid time that does not require rotating the clock, but times that work with rotation are also valid answers.\n\nIn Sample Case #3, the input represents the clock in the first picture below and the given output happens when interpreting the clock as in the second picture below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x2hzcknb.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/u6758coa.png)\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nSample Cases in this test set are the same as in the previous one, but the clock is rotated by $45$, $90$, and $180$ degrees clockwise respectively, as shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/srt7xazp.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/5b9o5qf6.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/2pz53ap7.png)\n\nSample Test Set 3 fits the limits of Test Set 3. It will not be run against your submitted solutions.\n\nAs explained above, 1 nanosecond after midnight the hands are moved by 1, 12, and 720 ticks, respectively. If the clock is also rotated counter-clockwise by 1 tick, the hand angles are exactly the ones given in the input.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{A} \\leq \\mathbf{B} \\leq \\mathbf{C} < 360 \\times 12 \\times 10^{10}$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- There is a time $t$ that corresponds to the input such that:\n  - $t$ is an integer number of seconds after midnight.\n  - $t$ can be read from the input clock without rotating it.\n\n**Test Set 2 (6 Pts, Visible Verdict)**\n\n- There is a time that corresponds to the input and is an integer number of seconds after midnight.\n\n**Test Set 3 (19 Pts, Visible Verdict)**\n\n- There is a time that corresponds to the input and is an integer number of nanoseconds after midnight.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1B] Broken Clock", "background": "", "description": "Emmett 在他的阁楼里发现了一个旧时钟。这个时钟是一个圆形，带有 3 根指针，它们连接在中心并以恒定速度顺时针旋转。这三根指针分别称为**时针**、**分针**和**秒针**。在午夜时分，所有指针都指向正上方。时针每 12 小时旋转一圈，分针每小时旋转一圈，秒针每分钟旋转一圈。1 小时等于 60 分钟，1 分钟等于 60 秒，1 秒等于 $10^{9}$ 纳秒。\n\n例如，下图所示的时钟表示的时间恰好是午夜后 6 小时 30 分钟。时针（黑色短针）位于 6 和 7 之间（完成了 6.5/12 圈），分针（黑色长针）指向正下方，因为它完成了恰好 6.5 圈，而秒针（红色）指向正上方，因为它完成了整数圈。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/h3nslzqx.png)\n\n不幸的是，这些指针已经损坏，因此它们看起来完全相同，无法区分哪根指针是哪根。上图中的时钟在指针损坏后看起来像这样。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/4m1446he.png)\n\nEmmett 知道时间严格在中午之前，即严格小于午夜后 12 小时。Emmett 拍摄了一张时钟的照片。给定这张照片（用指针相对于某个任意轴的角度表示），请找出它可能对应的时间。\n\n注意，在某些情况下（测试集 1），Emmett 已经找到了时钟的可行方向，并将可能的时间范围缩小到整数秒（测试集 1 和 2）或纳秒（测试集 3）。更多细节请参阅数据范围部分。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 行，每行描述一个测试用例，包含三个整数 $\\mathbf{A}$、$\\mathbf{B}$ 和 $\\mathbf{C}$：分别表示每根指针相对于某个任意轴的角度，以顺时针方向的“滴答”为单位。1 滴答等于 $1 / 12 \\times 10^{-10}$ 度。这意味着时针每纳秒旋转恰好 1 滴答，分针每纳秒旋转恰好 12 滴答，秒针每纳秒旋转恰好 720 滴答。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: h m s n`，其中 $x$ 是测试用例编号（从 1 开始），$h$、$m$、$s$ 和 $n$ 是整数：$h$ 表示午夜后的整小时数（0 到 11 之间，包括 0 和 11），$m$ 表示上一整小时后的整分钟数（0 到 59 之间），$s$ 表示上一整分钟后的整秒数（0 到 59 之间），$n$ 表示上一整秒后的整纳秒数（0 到 $10^{9}-1$ 之间）。\n", "hint": "**样例解释**\n\n在样例 #1 中，所有指针指向正上方（如下第一张图），这仅在午夜时分发生（如下第二张图）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ac9ropk5.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/oc7u48j6.png)\n\n样例 #2 是题目描述中展示的时钟。指针的角度分别为 0、180 和 195 度。这些角度可以对应 6 小时 30 分 0 秒（无需旋转时钟），如题目描述中的图片所示。但请注意，在 0 小时 30 分 0 秒时（如下第三张图），时钟看起来相同，只是旋转了 180 度。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j5ktfcq2.png)\n\n即使在测试集 1 中，0 小时 30 分 0 秒也是一个有效答案。题目限制仅说明存在一个无需旋转时钟的有效时间，但旋转后的时间也是有效答案。\n\n在样例 #3 中，输入表示第一张图中的时钟，而给定的输出对应于第二张图的解释。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x2hzcknb.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/u6758coa.png)\n\n样例测试集 2 符合测试集 2 的限制。它不会用于测试你的提交。\n\n此测试集中的样例与上一个相同，但时钟分别顺时针旋转了 45、90 和 180 度，如下所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/srt7xazp.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/5b9o5qf6.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/2pz53ap7.png)\n\n样例测试集 3 符合测试集 3 的限制。它不会用于测试你的提交。\n\n如上所述，午夜后 1 纳秒，指针分别移动了 1、12 和 720 滴答。如果时钟还逆时针旋转了 1 滴答，指针的角度恰好与输入一致。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $0 \\leq \\mathbf{A} \\leq \\mathbf{B} \\leq \\mathbf{C} < 360 \\times 12 \\times 10^{10}$。\n\n**测试集 1（5 分，可见评测结果）**\n\n- 存在一个时间 $t$ 与输入对应，满足：\n  - $t$ 是午夜后的整数秒。\n  - $t$ 可以从输入时钟直接读取，无需旋转。\n\n**测试集 2（6 分，可见评测结果）**\n\n- 存在一个时间与输入对应，且是午夜后的整数秒。\n\n**测试集 3（19 分，可见评测结果）**\n\n- 存在一个时间与输入对应，且是午夜后的整数纳秒。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13030", "type": "P", "difficulty": 4, "samples": [["3\n2 1 2\n1 2\n5 1 2\n2 0 0 0 1\n3 1 2\n1 1 1", "Case #1: 4\nCase #2: 6\nCase #3: 5"], ["3\n3 2 4\n1 1 1\n3 2 4\n1 0 1\n5 2 5\n1 0 0 0 1", "Case #1: IMPOSSIBLE\nCase #2: 5\nCase #3: 10"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "贪心", "2021", "数论", "Bézout 定理", "Google Code Jam"], "title": "[GCJ 2021 #1B] Subtransmutation", "background": "", "description": "As the most skilled alchemist in your country, you were summoned yet again because powers beyond science were needed to satisfy your country's leader's ever increasing greed for rare metals.\n\nEach metal is represented by a positive integer. You need to create $\\mathbf{U}_{1}$ units of metal 1, $\\mathbf{U}_{2}$ units of metal 2, … and $\\mathbf{U}_{\\mathrm{N}}$ units of metal $\\mathrm{N}$. Metals $\\mathrm{N}+1, \\mathrm{~N}+2, \\ldots$ do exist, but you are not required to create any specific amount of them. You are allowed to create excess amounts of any metal, which can just be discarded.\n\nUnfortunately, budget cuts have left you only the materials for a simple alchemy spell. For some fixed numbers $\\mathbf{A}$ and $\\mathbf{B}$, with $\\mathbf{A}<\\mathbf{B}$, you can take one unit of metal $i$ and destroy it to create one unit of metal $(i-\\mathbf{A})$ and one unit of metal $(i-\\mathbf{B})$. If either of those integers is not positive, that specific unit is not created. In particular, if $i \\leq \\mathbf{A}$, the spell simply destroys the unit and creates nothing. If $\\mathbf{A}<i \\leq \\mathbf{B}$ the spell destroys the unit and creates only a single unit of metal $(i-\\mathbf{A})$.\n\nYou have been assigned an expert miner to assist you. The expert miner can fetch a single unit of any metal you want. From that unit, you can use your spell to create other metals and then use the spell on the resulting metals to create even more units. The picture below shows a single unit of metal 4 being converted into one unit of metal 1 and two units of metal 2 using two spells with $\\mathbf{A}=1$ and $\\mathbf{B}=2$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/imhnu3zr.png)\n\nMetals represented by larger integers are heavier and more difficult to handle, so you want to ask the expert miner for a single unit of metal represented by the smallest possible integer that is sufficient to complete your task, or say that there is no such metal.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains three integers $\\mathbf{N}, \\mathbf{A}$, and $\\mathbf{B}$, representing the largest metal number that you are required to create, and the two values that define the available spell as described above, respectively. The second line of a test case contains $\\mathbf{N}$ integers $\\mathbf{U}_{1}, \\mathbf{U}_{2}, \\ldots, \\mathbf{U}_{\\mathbf{N}}$, representing the required units of metals $1,2, \\ldots, \\mathbf{N}$, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if it is not possible to create all required units starting from a single unit of metal. Otherwise, $y$ is the smallest integer that represents a metal such that one unit of it is sufficient to create all the required units of metal.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we require one unit of metal 1 and two units of metal 2. If we start with a single unit of metal 3, then applying the spell once will give us one unit of metal 1 and one unit of metal 2. There is no way to get an additional unit of metal 2. Similarly, starting with a single unit of metals 1 or 2 is not sufficient. However, a single unit of metal 4 is sufficient as is demonstrated in the picture in the main part of the statement.\n\nIn Sample Case #2, we can start with a single unit of metal 6 and apply the following operations:\n\n* Apply spell on 6: $\\{6\\} \\longrightarrow\\{4,5\\}$.\n* Apply spell on 4: $\\{4,5\\} \\longrightarrow\\{2,3,5\\}$.\n* Apply spell on 2: $\\{2,3,5\\} \\longrightarrow\\{1,3,5\\}$.\n* Apply spell on 3: $\\{1,3,5\\} \\longrightarrow\\{1,1,2,5\\}$.\n\nNote that even though we have an extra unit of metal 2 , this solution is valid.\n\nIn Sample Case #3, we can start with a single unit of metal 5 and apply the following operations:\n\n* Apply spell on 5: $\\{5\\} \\longrightarrow\\{3,4\\}$.\n* Apply spell on 4: $\\{3,4\\} \\longrightarrow\\{2,3,3\\}$.\n* Apply spell on 2: $\\{2,3,3\\} \\longrightarrow\\{1,3,3\\}$.\n* Apply spell on 3: $\\{1,3,3\\} \\longrightarrow\\{1,1,2,3\\}$.\n\nThere are other ways to apply spells which also work but they all require starting with a single unit of metal 5 or higher.\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nIn the first Sample Case for Test Set 2, it is impossible to start with a single unit of any metal and apply the spell with $\\mathbf{A}=2$ and $\\mathbf{B}=4$ several times and be left with one unit of metals $1,2$ and $3$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{N} \\leq 20$.\n- $0 \\leq \\mathbf{U}_{\\mathbf{i}} \\leq 20$, for all $i$.\n- $1 \\leq \\mathbf{U}_{\\mathbf{N}}$.\n- $2 \\leq \\mathbf{U}_{1}+\\mathbf{U}_{2}+\\cdots+\\mathbf{U}_{\\mathbf{N}}$.\n\n**Test Set 1 (13 Pts, Visible Verdict)**\n\n- $\\mathbf{A}=1$.\n- $\\mathbf{B}=2$.\n\n**Test Set 2 (18 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{A}<\\mathbf{B} \\leq 20$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1B] Subtransmutation", "background": "", "description": "As the most skilled alchemist in your country, you were summoned yet again because powers beyond science were needed to satisfy your country's leader's ever increasing greed for rare metals.\n\nEach metal is represented by a positive integer. You need to create $\\mathbf{U}_{1}$ units of metal 1, $\\mathbf{U}_{2}$ units of metal 2, … and $\\mathbf{U}_{\\mathrm{N}}$ units of metal $\\mathrm{N}$. Metals $\\mathrm{N}+1, \\mathrm{~N}+2, \\ldots$ do exist, but you are not required to create any specific amount of them. You are allowed to create excess amounts of any metal, which can just be discarded.\n\nUnfortunately, budget cuts have left you only the materials for a simple alchemy spell. For some fixed numbers $\\mathbf{A}$ and $\\mathbf{B}$, with $\\mathbf{A}<\\mathbf{B}$, you can take one unit of metal $i$ and destroy it to create one unit of metal $(i-\\mathbf{A})$ and one unit of metal $(i-\\mathbf{B})$. If either of those integers is not positive, that specific unit is not created. In particular, if $i \\leq \\mathbf{A}$, the spell simply destroys the unit and creates nothing. If $\\mathbf{A}<i \\leq \\mathbf{B}$ the spell destroys the unit and creates only a single unit of metal $(i-\\mathbf{A})$.\n\nYou have been assigned an expert miner to assist you. The expert miner can fetch a single unit of any metal you want. From that unit, you can use your spell to create other metals and then use the spell on the resulting metals to create even more units. The picture below shows a single unit of metal 4 being converted into one unit of metal 1 and two units of metal 2 using two spells with $\\mathbf{A}=1$ and $\\mathbf{B}=2$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/imhnu3zr.png)\n\nMetals represented by larger integers are heavier and more difficult to handle, so you want to ask the expert miner for a single unit of metal represented by the smallest possible integer that is sufficient to complete your task, or say that there is no such metal.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains three integers $\\mathbf{N}, \\mathbf{A}$, and $\\mathbf{B}$, representing the largest metal number that you are required to create, and the two values that define the available spell as described above, respectively. The second line of a test case contains $\\mathbf{N}$ integers $\\mathbf{U}_{1}, \\mathbf{U}_{2}, \\ldots, \\mathbf{U}_{\\mathbf{N}}$, representing the required units of metals $1,2, \\ldots, \\mathbf{N}$, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if it is not possible to create all required units starting from a single unit of metal. Otherwise, $y$ is the smallest integer that represents a metal such that one unit of it is sufficient to create all the required units of metal.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we require one unit of metal 1 and two units of metal 2. If we start with a single unit of metal 3, then applying the spell once will give us one unit of metal 1 and one unit of metal 2. There is no way to get an additional unit of metal 2. Similarly, starting with a single unit of metals 1 or 2 is not sufficient. However, a single unit of metal 4 is sufficient as is demonstrated in the picture in the main part of the statement.\n\nIn Sample Case #2, we can start with a single unit of metal 6 and apply the following operations:\n\n* Apply spell on 6: $\\{6\\} \\longrightarrow\\{4,5\\}$.\n* Apply spell on 4: $\\{4,5\\} \\longrightarrow\\{2,3,5\\}$.\n* Apply spell on 2: $\\{2,3,5\\} \\longrightarrow\\{1,3,5\\}$.\n* Apply spell on 3: $\\{1,3,5\\} \\longrightarrow\\{1,1,2,5\\}$.\n\nNote that even though we have an extra unit of metal 2 , this solution is valid.\n\nIn Sample Case #3, we can start with a single unit of metal 5 and apply the following operations:\n\n* Apply spell on 5: $\\{5\\} \\longrightarrow\\{3,4\\}$.\n* Apply spell on 4: $\\{3,4\\} \\longrightarrow\\{2,3,3\\}$.\n* Apply spell on 2: $\\{2,3,3\\} \\longrightarrow\\{1,3,3\\}$.\n* Apply spell on 3: $\\{1,3,3\\} \\longrightarrow\\{1,1,2,3\\}$.\n\nThere are other ways to apply spells which also work but they all require starting with a single unit of metal 5 or higher.\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nIn the first Sample Case for Test Set 2, it is impossible to start with a single unit of any metal and apply the spell with $\\mathbf{A}=2$ and $\\mathbf{B}=4$ several times and be left with one unit of metals $1,2$ and $3$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{N} \\leq 20$.\n- $0 \\leq \\mathbf{U}_{\\mathbf{i}} \\leq 20$, for all $i$.\n- $1 \\leq \\mathbf{U}_{\\mathbf{N}}$.\n- $2 \\leq \\mathbf{U}_{1}+\\mathbf{U}_{2}+\\cdots+\\mathbf{U}_{\\mathbf{N}}$.\n\n**Test Set 1 (13 Pts, Visible Verdict)**\n\n- $\\mathbf{A}=1$.\n- $\\mathbf{B}=2$.\n\n**Test Set 2 (18 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{A}<\\mathbf{B} \\leq 20$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1B] Subtransmutation", "background": "", "description": "作为国内最顶尖的炼金术士，你再次被征召，因为需要超越科学的力量来满足国家领袖对稀有金属日益增长的贪婪需求。\n\n每种金属用一个正整数表示。你需要制造 $\\mathbf{U}_{1}$ 个单位的 1 号金属，$\\mathbf{U}_{2}$ 个单位的 2 号金属，……，以及 $\\mathbf{U}_{\\mathrm{N}}$ 个单位的 $\\mathrm{N}$ 号金属。$\\mathrm{N}+1$, $\\mathrm{N}+2$, …… 号金属也存在，但你不需要制造特定数量的它们。你可以制造任何金属的过量单位，这些多余的金属可以直接丢弃。\n\n不幸的是，预算削减让你只剩下施展一个简单炼金法术的材料。对于固定的数字 $\\mathbf{A}$ 和 $\\mathbf{B}$（$\\mathbf{A}<\\mathbf{B}$），你可以消耗 1 个单位的 $i$ 号金属，将其分解为 1 个单位的 $(i-\\mathbf{A})$ 号金属和 1 个单位的 $(i-\\mathbf{B})$ 号金属。如果其中某个整数不是正数，则不会生成对应的单位。特别地，如果 $i \\leq \\mathbf{A}$，这个法术只会销毁该单位而不生成任何金属。如果 $\\mathbf{A}<i \\leq \\mathbf{B}$，法术会销毁该单位并只生成 1 个单位的 $(i-\\mathbf{A})$ 号金属。\n\n你被指派了一位专家矿工协助。专家矿工可以为你开采任意一种金属的 1 个单位。你可以从这个单位出发，使用你的法术制造其他金属，然后再对生成的金属施用该法术来制造更多单位。下图展示了在 $\\mathbf{A}=1$ 和 $\\mathbf{B}=2$ 时，1 个单位的 4 号金属通过两次法术转化为 1 个单位的 1 号金属和 2 个单位的 2 号金属的过程。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/imhnu3zr.png)\n\n数值越大的金属越重且越难处理，因此你希望向专家矿工请求数值尽可能小的金属单位来完成你的任务，或者指出这是不可能实现的。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含两行：\n- 第一行包含三个整数 $\\mathbf{N}$、$\\mathbf{A}$ 和 $\\mathbf{B}$，分别表示你需要制造的金属的最大编号，以及定义可用法术的两个参数。\n- 第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{U}_{1}, \\mathbf{U}_{2}, \\ldots, \\mathbf{U}_{\\mathbf{N}}$，表示对 1 号、2 号、……、$\\mathbf{N}$ 号金属的需求量。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 IMPOSSIBLE（如果无法从 1 个单位的某种金属开始制造所有所需金属），否则 $y$ 是最小的金属编号，使得从它的 1 个单位出发可以制造所有所需金属。\n", "hint": "**样例解释**\n\n在样例 #1 中，我们需要 1 个单位的 1 号金属和 2 个单位的 2 号金属。如果从 1 个单位的 3 号金属开始，施用一次法术会得到 1 个单位的 1 号金属和 1 个单位的 2 号金属，无法再获得额外的 2 号金属。类似地，从 1 号或 2 号金属开始也不够。但如题目描述中的图示所示，从 4 号金属开始可以满足需求。\n\n在样例 #2 中，我们可以从 1 个单位的 6 号金属开始，进行以下操作：\n* 对 6 施法：$\\{6\\} \\to \\{4,5\\}$\n* 对 4 施法：$\\{4,5\\} \\to \\{2,3,5\\}$\n* 对 2 施法：$\\{2,3,5\\} \\to \\{1,3,5\\}$\n* 对 3 施法：$\\{1,3,5\\} \\to \\{1,1,2,5\\}$\n\n虽然会多出 2 号金属，但这个解是有效的。\n\n在样例 #3 中，我们可以从 5 号金属开始：\n* 对 5 施法：$\\{5\\} \\to \\{3,4\\}$\n* 对 4 施法：$\\{3,4\\} \\to \\{2,3,3\\}$\n* 对 2 施法：$\\{2,3,3\\} \\to \\{1,3,3\\}$\n* 对 3 施法：$\\{1,3,3\\} \\to \\{1,1,2,3\\}$\n\n其他操作方式也可以满足需求，但都需要从 5 号或更高编号的金属开始。\n\n样例测试集 2 符合测试集 2 的限制。它不会用于测试你的提交。\n\n在测试集 2 的第一个样例中，无法从任何金属的 1 个单位出发，通过 $\\mathbf{A}=2$、$\\mathbf{B}=4$ 的法术操作得到 1 个单位的 1 号、2 号和 3 号金属。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$\n- $1 \\leq \\mathbf{N} \\leq 20$\n- 对所有 $i$，$0 \\leq \\mathbf{U}_{\\mathbf{i}} \\leq 20$\n- $1 \\leq \\mathbf{U}_{\\mathbf{N}}$\n- $2 \\leq \\mathbf{U}_{1}+\\mathbf{U}_{2}+\\cdots+\\mathbf{U}_{\\mathbf{N}}$\n\n**测试集 1（13 分，可见评测结果）**\n- $\\mathbf{A}=1$\n- $\\mathbf{B}=2$\n\n**测试集 2（18 分，隐藏评测结果）**\n- $1 \\leq \\mathbf{A}<\\mathbf{B} \\leq 20$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13031", "type": "P", "difficulty": 5, "samples": [["2 3 3 1500\n3\n\n2\n\n5\n\n4\n\n1\n\n6\n\n3\n\n9\n\n0", "\n\n1\n\n1\n\n2\n\n2\n\n1\n\n3\n\n2\n\n3\n\n3"]], "limits": {"time": [60000, 60000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2021", "交互题", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2021 #1B] Digit Blocks", "background": "", "description": "You are going to build $N$ towers of $B$ cubic blocks each, one block at a time. Towers are built bottom-up: the $i$-th block to be placed in a tower ends up as the $i$-th from the bottom. You need to decide where to place each block before getting to see any of the upcoming blocks, and once placed, blocks cannot be moved.\n\nEach block has a single decimal digit printed on it, and towers are built such that the faces with digits are all facing the front. The font is such that blocks cannot be rotated to obtain a different digit (for example, a block with a 6 on it cannot be rotated to obtain a block with a 9 on it, nor vice versa).\n\nFor example, suppose $N = 3$ and $B = 3$ and you currently have towers as shown in Picture 1. If a block with a 6 shows up next, you have two options: either place it on top of the tower with only two blocks (as shown in Picture 2) or start the third tower (as shown in Picture 3). Note that you cannot put it on top of the first tower since the first tower already has $B$ blocks.\n\n\nAfter the building is done, we read the $B$ digit integer printed on the front of each tower from the top to the bottom (that is, the digit on the last block placed on a tower is the most significant digit). Notice that these integers may have any number of leading zeroes. Then, we add those $N$ integers together to obtain the score of our building operation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/47a718u8.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/c8lwc9qg.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/wdg8ljcv.png)\n\nFor example, in Picture 4 below, the integers read on each tower, from left to right, are $123$, $345$, and $96$. The score of that building operation would be $123 + 345 + 96 = 564$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6aiwqzwm.png)\n\nThe digit for each block is generated uniformly at random, and independently of any other information. In order for your solution to be judged correct, the sum of its scores over all $\\textbf{T}$ test cases must be at least $\\textbf{P}$.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially the judge will send you a single line containing four integers $\\textbf{T}$, $\\textbf{N}$, $\\textbf{B}$, and $\\textbf{P}$: the number of test cases, the number of towers, the number of blocks in each tower, and the minimum total score you need to reach to pass this test set.\n\nThen, you must process $\\textbf{T}$ test cases. Each test case consists of $\\textbf{N} \\times \\textbf{B}$ exchanges. Each exchange corresponds to placing one block. Within each exchange, the judge will first print a line containing a single integer $\\textbf{D}$ representing the digit printed on the block you need to place. You need to respond with a single line containing a single integer $\\textbf{i}$, the number (between $1$ and $\\textbf{N}$) of the tower you want to place that block on.\n\nAfter the last exchange of each test case except the last one, the judge will immediately start the next test case. After the last exchange of the last test case, the judge will print an additional line containing a single integer: $1$ if your total score is at least $\\textbf{P}$ or $-1$ if it is not.\n\nIf the judge receives an invalidly formatted line, an invalid tower number, or the number of a tower that already contains $\\textbf{B}$ blocks from your program, the judge will print a single number $-1$. After the judge prints $-1$ for any of the reasons explained above, it will not print any further output. If your program continues to wait for the judge after receiving a $-1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n\nYou can assume that the digit for each block is generated uniformly at random, and independently for each digit, for each test case and for each submission. Therefore even if you submit exactly the same code twice, the judge could use different random digits.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nIn the sample, we are now at the state shown in Picture 4 (sum = 564).\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $\\textbf{T} = 50$.\n- $\\textbf{N} = 20$.\n- $\\textbf{B} = 15$.\n- $\\textbf{D}$ is a decimal digit between $0$ and $9$.\n\n**Test Set 1 (16 Pts, Visible Verdict)**\n\n$\\textbf{P} = 860939810732536850$ (approximately $8.6 \\times 10^{17}$).\n\nNote that this boundary is chosen as approximately $90\\%$ of $\\textbf{T} \\times S$, where $S = 19131995794056374.42\\dots$ (approximately $1.9 \\times 10^{16}$) is the highest possible expected score that a solution to this problem can achieve on one test case given unbounded running time.\n\nThe exact value of $S$ as defined above can be found in lines 13 and 14 of the local testing tool.\n\n**Test Set 2 (21 Pts, Visible Verdict)**\n\n$\\textbf{P} = 937467793908762347$ (approximately $9.37 \\times 10^{17}$).\n\nNote that this boundary is chosen as approximately $98\\%$ of $\\textbf{T} \\times S$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1B] Digit Blocks", "background": "", "description": "You are going to build $N$ towers of $B$ cubic blocks each, one block at a time. Towers are built bottom-up: the $i$-th block to be placed in a tower ends up as the $i$-th from the bottom. You need to decide where to place each block before getting to see any of the upcoming blocks, and once placed, blocks cannot be moved.\n\nEach block has a single decimal digit printed on it, and towers are built such that the faces with digits are all facing the front. The font is such that blocks cannot be rotated to obtain a different digit (for example, a block with a 6 on it cannot be rotated to obtain a block with a 9 on it, nor vice versa).\n\nFor example, suppose $N = 3$ and $B = 3$ and you currently have towers as shown in Picture 1. If a block with a 6 shows up next, you have two options: either place it on top of the tower with only two blocks (as shown in Picture 2) or start the third tower (as shown in Picture 3). Note that you cannot put it on top of the first tower since the first tower already has $B$ blocks.\n\n\nAfter the building is done, we read the $B$ digit integer printed on the front of each tower from the top to the bottom (that is, the digit on the last block placed on a tower is the most significant digit). Notice that these integers may have any number of leading zeroes. Then, we add those $N$ integers together to obtain the score of our building operation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/47a718u8.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/c8lwc9qg.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/wdg8ljcv.png)\n\nFor example, in Picture 4 below, the integers read on each tower, from left to right, are $123$, $345$, and $96$. The score of that building operation would be $123 + 345 + 96 = 564$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6aiwqzwm.png)\n\nThe digit for each block is generated uniformly at random, and independently of any other information. In order for your solution to be judged correct, the sum of its scores over all $\\textbf{T}$ test cases must be at least $\\textbf{P}$.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially the judge will send you a single line containing four integers $\\textbf{T}$, $\\textbf{N}$, $\\textbf{B}$, and $\\textbf{P}$: the number of test cases, the number of towers, the number of blocks in each tower, and the minimum total score you need to reach to pass this test set.\n\nThen, you must process $\\textbf{T}$ test cases. Each test case consists of $\\textbf{N} \\times \\textbf{B}$ exchanges. Each exchange corresponds to placing one block. Within each exchange, the judge will first print a line containing a single integer $\\textbf{D}$ representing the digit printed on the block you need to place. You need to respond with a single line containing a single integer $\\textbf{i}$, the number (between $1$ and $\\textbf{N}$) of the tower you want to place that block on.\n\nAfter the last exchange of each test case except the last one, the judge will immediately start the next test case. After the last exchange of the last test case, the judge will print an additional line containing a single integer: $1$ if your total score is at least $\\textbf{P}$ or $-1$ if it is not.\n\nIf the judge receives an invalidly formatted line, an invalid tower number, or the number of a tower that already contains $\\textbf{B}$ blocks from your program, the judge will print a single number $-1$. After the judge prints $-1$ for any of the reasons explained above, it will not print any further output. If your program continues to wait for the judge after receiving a $-1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n\nYou can assume that the digit for each block is generated uniformly at random, and independently for each digit, for each test case and for each submission. Therefore even if you submit exactly the same code twice, the judge could use different random digits.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nIn the sample, we are now at the state shown in Picture 4 (sum = 564).\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $\\textbf{T} = 50$.\n- $\\textbf{N} = 20$.\n- $\\textbf{B} = 15$.\n- $\\textbf{D}$ is a decimal digit between $0$ and $9$.\n\n**Test Set 1 (16 Pts, Visible Verdict)**\n\n$\\textbf{P} = 860939810732536850$ (approximately $8.6 \\times 10^{17}$).\n\nNote that this boundary is chosen as approximately $90\\%$ of $\\textbf{T} \\times S$, where $S = 19131995794056374.42\\dots$ (approximately $1.9 \\times 10^{16}$) is the highest possible expected score that a solution to this problem can achieve on one test case given unbounded running time.\n\nThe exact value of $S$ as defined above can be found in lines 13 and 14 of the local testing tool.\n\n**Test Set 2 (21 Pts, Visible Verdict)**\n\n$\\textbf{P} = 937467793908762347$ (approximately $9.37 \\times 10^{17}$).\n\nNote that this boundary is chosen as approximately $98\\%$ of $\\textbf{T} \\times S$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1B] Digit Blocks", "background": "", "description": "你将建造 $N$ 座塔，每座塔由 $B$ 块立方体积木组成，每次放置一块积木。塔的建造是从下往上进行的：第 $i$ 块被放置到某座塔中的积木最终会成为该塔从下往上数的第 $i$ 块。你需要在看到后续积木之前决定每块积木的放置位置，且一旦放置就不能移动。\n\n每块积木上印有一个十进制数字，塔的建造会确保所有数字面朝前。积木的字体设计使得无法通过旋转获得不同的数字（例如，印有 6 的积木不能通过旋转变成 9，反之亦然）。\n\n例如，假设 $N = 3$ 且 $B = 3$，当前塔的状态如图 1 所示。如果下一块积木的数字是 6，你有两种选择：要么将其放在只有两块积木的塔上（如图 2），要么开始建造第三座塔（如图 3）。注意不能将其放在第一座塔上，因为第一座塔已经有 $B$ 块积木。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/47a718u8.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/c8lwc9qg.png)\n![](https://cdn.luogu.com.cn/upload/image_hosting/wdg8ljcv.png)\n\n建造完成后，我们从每座塔的顶端到底端读取数字（即最后放置的积木数字是最高位），得到一个 $B$ 位整数。注意这些整数可能有任意前导零。然后，将这 $N$ 个整数相加，得到建造操作的分数。\n\n例如，在图 4 中，从左到右的塔分别读作 $123$、$345$ 和 $96$，得分为 $123 + 345 + 96 = 564$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6aiwqzwm.png)\n\n每块积木的数字是独立且均匀随机生成的。为了使你的答案被判为正确，所有 $\\mathbf{T}$ 个测试用例的总分必须至少达到 $\\mathbf{P}$。\n\n### 交互协议\n\n这是一个交互问题。\n\n最初评测机会发送一行包含四个整数 $\\mathbf{T}$、$\\mathbf{N}$、$\\mathbf{B}$ 和 $\\mathbf{P}$：测试用例数量、塔的数量、每座塔的积木数，以及通过测试集所需的最低总分。\n\n然后，你需要处理 $\\mathbf{T}$ 个测试用例。每个测试用例包含 $\\mathbf{N} \\times \\mathbf{B}$ 次交互。每次交互对应放置一块积木。在每次交互中：\n1. 评测机输出一行，包含一个整数 $\\mathbf{D}$，表示当前积木的数字。\n2. 你需要输出一行，包含一个整数 $\\mathbf{i}$（$1 \\leq \\mathbf{i} \\leq \\mathbf{N}$），表示要将积木放置到第几座塔。\n\n在最后一个测试用例的最后一次交互后，评测机会额外输出一行：\n- 如果总分 $\\geq \\mathbf{P}$，输出 $1$；\n- 否则输出 $-1$。\n\n如果评测机收到的交互内容格式错误、塔编号无效，或尝试将积木放到已满的塔上，它会输出 $-1$ 并终止交互。如果程序在收到 $-1$ 后仍继续等待输入，会导致超时错误（TLE）。注意：程序需要及时退出以避免 TLE，否则会被判为错误答案。\n\n可以假设每个积木的数字是独立且均匀随机生成的，因此即使完全相同的代码提交两次，评测机也可能生成不同的随机数字。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "**样例解释**\n\n样例中的状态对应图 4（总分 = 564）。\n\n你可以使用本地测试工具调试代码。测试工具会模拟评测机的行为，但**并非真实评测系统**，可能在某些细节上存在差异。\n\n**数据范围**\n\n- $\\mathbf{T} = 50$\n- $\\mathbf{N} = 20$\n- $\\mathbf{B} = 15$\n- $\\mathbf{D}$ 是 $0$ 到 $9$ 的十进制数字\n\n**测试集 1（16 分，可见评测结果）**\n\n$\\mathbf{P} = 860939810732536850$（约 $8.6 \\times 10^{17}$）。\n\n该边界约为理论最高期望分数（$S \\approx 1.9 \\times 10^{16}$）的 $90\\% \\times \\mathbf{T}$。精确的 $S$ 值可在测试工具代码的第 13-14 行找到。\n\n**测试集 2（21 分，可见评测结果）**\n\n$\\mathbf{P} = 937467793908762347$（约 $9.37 \\times 10^{17}$）。\n\n该边界约为理论最高期望分数的 $98\\% \\times \\mathbf{T}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13032", "type": "P", "difficulty": 3, "samples": [["4\n3 10\n1 3 7\n4 10\n4 1 7 3\n4 3\n1 2 3 2\n4 4\n1 2 4 2", "Case #1: 0.5\nCase #2: 0.4\nCase #3: 0.0\nCase #4: 0.25"]], "limits": {"time": [1000, 1000, 1000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "贪心", "2021", "Special Judge", "排序", "Google Code Jam"], "title": "[GCJ 2021 #1C] Closest Pick", "background": "", "description": "You are entering a raffle for a lifetime supply of pancakes. $\\textbf{N}$ tickets have already been sold. Each ticket contains a single integer between $1$ and $\\textbf{K}$, inclusive. Different tickets are allowed to contain the same integer. You know exactly which numbers are on all of the tickets already sold and would like to maximize your odds of winning by purchasing two tickets (possibly with the same integer on them). You are allowed to choose which integers between $1$ and $\\textbf{K}$, inclusive, are on the two tickets.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dzt1cd5t.png)\n\nYou know you are the last customer, so after you purchase your tickets, no more tickets will be purchased. Then, an integer $c$ between $1$ and $\\textbf{K}$, inclusive, is chosen uniformly at random. If one of your tickets is strictly closer to $c$ than all other tickets or if both of your tickets are the same distance to $c$ and strictly closer than all other tickets, then you win the raffle. Otherwise, you do not win the raffle.\n\nGiven the integers on the $\\textbf{N}$ tickets purchased so far, what is the maximum probability of winning the raffle you can achieve by choosing the integers on your two tickets optimally?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\textbf{T}$. $\\textbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains two integers $\\textbf{N}$ and $\\textbf{K}$: the number of tickets already sold and the limit of the range of integers to pick from, respectively. The second line contains $\\textbf{N}$ integers $\\textbf{P}_1, \\textbf{P}_2, \\ldots, \\textbf{P}_\\textbf{N}$, representing the integers on the tickets that have already been purchased.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from $1$) and $y$ is the maximum win probability you can achieve if you choose your tickets optimally. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you can purchase tickets with the integers $4$ and $8$ on them and then win if $4$, $5$, $8$, $9$, or $10$ are chosen giving you $\\frac{5}{10} = 0.5$ probability of winning. Purchasing tickets with the integers $6$ and $8$ on them also yields a $0.5$ probability of winning, but no combination yields more.\n\nIn Sample Case #2, $6$ and $8$ is a possible optimal pair of tickets, which wins when $c$ is one of $6$, $8$, $9$, or $10$. Note that the integers on the tickets are not necessarily given in sorted order.\n\nIn Sample Case #3, every possible $c$ is at distance $0$ from an already purchased ticket, so you cannot win regardless of your choices.\n\nIn Sample Case #4, if you pick $3$ for at least one of your tickets, you win on $c = 3$, for $\\frac{1}{4} = 0.25$ win probability. There is no way to win when $c$ is any other integer, so that is the best you can do.\n\n**Limits**\n\n- $1 \\leq \\textbf{T} \\leq 100$.\n- $1 \\leq \\textbf{N} \\leq 30$.\n- $1 \\leq \\textbf{P}_i \\leq \\textbf{K}$, for all $i$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $1 \\leq \\textbf{K} \\leq 30$.\n\n**Test Set 2 (16 Pts, Visible Verdict)**\n\n- $1 \\leq \\textbf{K} \\leq 10^9$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1C] Closest Pick", "background": "", "description": "You are entering a raffle for a lifetime supply of pancakes. $\\textbf{N}$ tickets have already been sold. Each ticket contains a single integer between $1$ and $\\textbf{K}$, inclusive. Different tickets are allowed to contain the same integer. You know exactly which numbers are on all of the tickets already sold and would like to maximize your odds of winning by purchasing two tickets (possibly with the same integer on them). You are allowed to choose which integers between $1$ and $\\textbf{K}$, inclusive, are on the two tickets.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dzt1cd5t.png)\n\nYou know you are the last customer, so after you purchase your tickets, no more tickets will be purchased. Then, an integer $c$ between $1$ and $\\textbf{K}$, inclusive, is chosen uniformly at random. If one of your tickets is strictly closer to $c$ than all other tickets or if both of your tickets are the same distance to $c$ and strictly closer than all other tickets, then you win the raffle. Otherwise, you do not win the raffle.\n\nGiven the integers on the $\\textbf{N}$ tickets purchased so far, what is the maximum probability of winning the raffle you can achieve by choosing the integers on your two tickets optimally?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\textbf{T}$. $\\textbf{T}$ test cases follow. Each test case consists of two lines. The first line of a test case contains two integers $\\textbf{N}$ and $\\textbf{K}$: the number of tickets already sold and the limit of the range of integers to pick from, respectively. The second line contains $\\textbf{N}$ integers $\\textbf{P}_1, \\textbf{P}_2, \\ldots, \\textbf{P}_\\textbf{N}$, representing the integers on the tickets that have already been purchased.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from $1$) and $y$ is the maximum win probability you can achieve if you choose your tickets optimally. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you can purchase tickets with the integers $4$ and $8$ on them and then win if $4$, $5$, $8$, $9$, or $10$ are chosen giving you $\\frac{5}{10} = 0.5$ probability of winning. Purchasing tickets with the integers $6$ and $8$ on them also yields a $0.5$ probability of winning, but no combination yields more.\n\nIn Sample Case #2, $6$ and $8$ is a possible optimal pair of tickets, which wins when $c$ is one of $6$, $8$, $9$, or $10$. Note that the integers on the tickets are not necessarily given in sorted order.\n\nIn Sample Case #3, every possible $c$ is at distance $0$ from an already purchased ticket, so you cannot win regardless of your choices.\n\nIn Sample Case #4, if you pick $3$ for at least one of your tickets, you win on $c = 3$, for $\\frac{1}{4} = 0.25$ win probability. There is no way to win when $c$ is any other integer, so that is the best you can do.\n\n**Limits**\n\n- $1 \\leq \\textbf{T} \\leq 100$.\n- $1 \\leq \\textbf{N} \\leq 30$.\n- $1 \\leq \\textbf{P}_i \\leq \\textbf{K}$, for all $i$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $1 \\leq \\textbf{K} \\leq 30$.\n\n**Test Set 2 (16 Pts, Visible Verdict)**\n\n- $1 \\leq \\textbf{K} \\leq 10^9$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1C] Closest Pick", "background": "", "description": "你正在参加一场抽奖活动，奖品是终身免费煎饼。已有 $\\textbf{N}$ 张彩票售出。每张彩票包含一个 $1$ 到 $\\textbf{K}$ 之间的整数（含端点）。不同的彩票可以包含相同的整数。你确切知道所有已售出彩票上的数字，并希望通过购买两张彩票（可以包含相同的整数）来最大化中奖概率。你可以自由选择 $1$ 到 $\\textbf{K}$ 之间的任意整数作为这两张彩票的数字。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/dzt1cd5t.png)\n\n你知道自己是最后一位顾客，因此在你购买彩票后，不会再有任何彩票售出。接着，系统会均匀随机选择一个 $1$ 到 $\\textbf{K}$ 之间的整数 $c$（含端点）。如果满足以下条件之一，你将赢得抽奖：\n- 你的一张彩票到 $c$ 的距离严格小于其他所有彩票；\n- 你的两张彩票到 $c$ 的距离相同，且严格小于其他所有彩票。\n\n否则，你将不会赢得抽奖。\n\n给定已售出的 $\\textbf{N}$ 张彩票上的整数，通过最优选择你的两张彩票上的整数，你能够达到的最大中奖概率是多少？", "inputFormat": "输入的第一行包含测试用例的数量 $\\textbf{T}$。随后是 $\\textbf{T}$ 个测试用例。每个测试用例包含两行：第一行是两个整数 $\\textbf{N}$ 和 $\\textbf{K}$，分别表示已售出的彩票数量和可选整数的上限；第二行包含 $\\textbf{N}$ 个整数 $\\textbf{P}_1, \\textbf{P}_2, \\ldots, \\textbf{P}_\\textbf{N}$，表示已售出彩票上的整数。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是你通过最优选择彩票能够达到的最大中奖概率。$y$ 的答案将被认为是正确的，如果其绝对误差或相对误差不超过 $10^{-6}$。关于误差范围的解释及可接受的实数格式，请参考 FAQ。\n", "hint": "**样例解释**\n\n在样例 #1 中，你可以购买数字为 $4$ 和 $8$ 的彩票。当 $c$ 为 $4$、$5$、$8$、$9$ 或 $10$ 时，你将赢得抽奖，中奖概率为 $\\frac{5}{10} = 0.5$。购买数字为 $6$ 和 $8$ 的彩票也能达到 $0.5$ 的中奖概率，但没有其他组合能超过这一概率。\n\n在样例 #2 中，$6$ 和 $8$ 是一个可能的最优组合，当 $c$ 为 $6$、$8$、$9$ 或 $10$ 时，你将赢得抽奖。注意，已售出彩票上的数字不一定按升序排列。\n\n在样例 #3 中，所有可能的 $c$ 都与至少一张已售出的彩票距离为 $0$，因此无论你如何选择彩票，都无法赢得抽奖。\n\n在样例 #4 中，如果你至少选择一张数字为 $3$ 的彩票，你将在 $c = 3$ 时赢得抽奖，中奖概率为 $\\frac{1}{4} = 0.25$。对于其他整数 $c$，你无法获胜，因此这是你能达到的最佳概率。\n\n**数据范围**\n\n- $1 \\leq \\textbf{T} \\leq 100$。\n- $1 \\leq \\textbf{N} \\leq 30$。\n- 对于所有 $i$，$1 \\leq \\textbf{P}_i \\leq \\textbf{K}$。\n\n**测试集 1（9 分，可见判定）**\n\n- $1 \\leq \\textbf{K} \\leq 30$。\n\n**测试集 2（16 分，可见判定）**\n\n- $1 \\leq \\textbf{K} \\leq 10^9$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13033", "type": "P", "difficulty": 5, "samples": [["4\n2020\n2021\n68000\n101", "Case #1: 2021\nCase #2: 2122\nCase #3: 78910\nCase #4: 123"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "二分", "2021", "Google Code Jam"], "title": "[GCJ 2021 #1C] Roaring Years", "background": "", "description": "Something is happening in 2021 that has not happened in over a century. 2021, like 1920 before it, is a roaring year. A year represented by a positive integer $y$ is roaring if the decimal writing (without leading zeroes) of $y$ is the concatenation of the decimal writing (without leading zeroes) of two or more distinct consecutive positive integers, in increasing order. In this case, 2021 is a roaring year because it is the concatenation of 20 and 21.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k37unt4l.png)\n\nOther examples of roaring years are 12, 789, 910, 1234, and 9899100. 2020 was not roaring because the only list of two or more positive integers that concatenate into 2020 is $[20, 20]$, and it is not made of consecutive integers. Similarly, there are only three lists for 2019: $[20, 1, 9]$, $[201, 9]$, and $[20, 19]$. The first two are not made of consecutive integers, while the third does not have the integers in increasing order. Thus, 2019 was also not roaring. As a final example, 778 was not a roaring year because $[7, 78]$ and $[77, 8]$ are not made up of consecutive integers and $[7, 7, 8]$ is not made up of distinct integers.\n\nGiven the current year (which may or may not be roaring), find what the next roaring year is going to be.", "inputFormat": "The first line of the input gives the number of test cases, $\\textbf{T}$. $\\textbf{T}$ lines follow. Each line represents a test case and contains a single integer $\\textbf{Y}$, the current year.\n", "outputFormat": "For each test case, output one line containing `Case #x: z`, where $x$ is the test case number (starting from 1) and $z$ is the first year strictly after $\\textbf{Y}$ that is roaring.", "hint": "**Sample Explanation**\n\nNotice in the last Sample Case that 102 is not a roaring year because $[10, 2]$ is not a list of consecutive integers and you cannot write 2 with a leading zero to use $[1, 02]$.\n\n**Limits**\n\n- $1 \\leq \\textbf{T} \\leq 100$.\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $1 \\leq \\textbf{Y} \\leq 10^6$.\n\n**Test Set 2 (20 Pts, Hidden Verdict)**\n\n- $1 \\leq \\textbf{Y} \\leq 10^{18}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1C] Roaring Years", "background": "", "description": "Something is happening in 2021 that has not happened in over a century. 2021, like 1920 before it, is a roaring year. A year represented by a positive integer $y$ is roaring if the decimal writing (without leading zeroes) of $y$ is the concatenation of the decimal writing (without leading zeroes) of two or more distinct consecutive positive integers, in increasing order. In this case, 2021 is a roaring year because it is the concatenation of 20 and 21.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k37unt4l.png)\n\nOther examples of roaring years are 12, 789, 910, 1234, and 9899100. 2020 was not roaring because the only list of two or more positive integers that concatenate into 2020 is $[20, 20]$, and it is not made of consecutive integers. Similarly, there are only three lists for 2019: $[20, 1, 9]$, $[201, 9]$, and $[20, 19]$. The first two are not made of consecutive integers, while the third does not have the integers in increasing order. Thus, 2019 was also not roaring. As a final example, 778 was not a roaring year because $[7, 78]$ and $[77, 8]$ are not made up of consecutive integers and $[7, 7, 8]$ is not made up of distinct integers.\n\nGiven the current year (which may or may not be roaring), find what the next roaring year is going to be.", "inputFormat": "The first line of the input gives the number of test cases, $\\textbf{T}$. $\\textbf{T}$ lines follow. Each line represents a test case and contains a single integer $\\textbf{Y}$, the current year.\n", "outputFormat": "For each test case, output one line containing `Case #x: z`, where $x$ is the test case number (starting from 1) and $z$ is the first year strictly after $\\textbf{Y}$ that is roaring.", "hint": "**Sample Explanation**\n\nNotice in the last Sample Case that 102 is not a roaring year because $[10, 2]$ is not a list of consecutive integers and you cannot write 2 with a leading zero to use $[1, 02]$.\n\n**Limits**\n\n- $1 \\leq \\textbf{T} \\leq 100$.\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $1 \\leq \\textbf{Y} \\leq 10^6$.\n\n**Test Set 2 (20 Pts, Hidden Verdict)**\n\n- $1 \\leq \\textbf{Y} \\leq 10^{18}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1C] Roaring Years", "background": "", "description": "2021 年正在发生一件百年未遇的事情。与 1920 年一样，2021 年也是一个**咆哮年份**。一个正整数 $y$ 所代表的年份被称为咆哮年份，当且仅当 $y$ 的十进制表示（不含前导零）是两个或更多个不同的连续正整数的十进制表示（不含前导零）按递增顺序连接而成。在这个定义下，2021 是一个咆哮年份，因为它是 20 和 21 的连接。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/k37unt4l.png)\n\n其他咆哮年份的例子包括 12（1 和 2）、789（7、8、9）、910（9 和 10）、1234（1、2、3、4）以及 9899100（9899 和 100）。2020 不是咆哮年份，因为唯一能连接成 2020 的两个或多个正整数列表是 $[20, 20]$，而它们不是连续的整数。类似地，2019 只有三种可能的分解方式：$[20, 1, 9]$、$[201, 9]$ 和 $[20, 19]$。前两种不是连续整数，而第三种虽然连续但不是严格递增的，因此 2019 也不是咆哮年份。再举个例子，778 不是咆哮年份，因为 $[7, 78]$ 和 $[77, 8]$ 不是连续的整数，而 $[7, 7, 8]$ 中的数字不唯一。\n\n给定当前年份（可能是咆哮年份，也可能不是），找出下一个咆哮年份。", "inputFormat": "输入的第一行包含测试用例的数量 $\\textbf{T}$。随后是 $\\textbf{T}$ 行，每行一个测试用例，包含一个整数 $\\textbf{Y}$，表示当前年份。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: z`，其中 $x$ 是测试用例编号（从 1 开始），$z$ 是严格大于 $\\textbf{Y}$ 的第一个咆哮年份。\n", "hint": "**样例解释**\n\n注意最后一个样例，102 不是咆哮年份，因为 $[10, 2]$ 不是连续整数，且不能将 2 写作 $02$（带前导零）来构造 $[1, 02]$。\n\n**数据范围**\n\n- $1 \\leq \\textbf{T} \\leq 100$。\n\n**测试集 1（15 分，可见判定）**\n\n- $1 \\leq \\textbf{Y} \\leq 10^6$。\n\n**测试集 2（20 分，隐藏判定）**\n\n- $1 \\leq \\textbf{Y} \\leq 10^{18}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13034", "type": "P", "difficulty": 6, "samples": [["6\n10001 111\n1011 111\n1010 1011\n0 1\n0 101\n1101011 1101011", "Case #1: 4\nCase #2: 3\nCase #3: 2\nCase #4: 1\nCase #5: IMPOSSIBLE\nCase #6: 0"]], "limits": {"time": [10000, 10000, 10000], "memory": [1048576, 1048576, 1048576]}, "tags": ["图论", "2021", "KMP 算法", "Google Code Jam"], "title": "[GCJ 2021 #1C] Double or NOTing", "background": "", "description": "You are given a starting non-negative integer $\\textbf{S}$ and an ending non-negative integer $\\textbf{E}$. Both $\\textbf{S}$ and $\\textbf{E}$ are given by their binary representation (that is, they are given written in base 2). Your goal is to transform $\\textbf{S}$ into $\\textbf{E}$. The following two operations are available to you:\n\n- Double your current value.\n- Take the bitwise NOT of your current value. The binary representation of your current value is taken without unnecessary leading zeroes, and any unnecessary leading zeroes produced by the operation are dropped. (The only necessary leading zero is the one in the representation of 0).\n\nFor example, by using the double operation, 6 becomes 12, 0 becomes 0, and 10 becomes 20. By using the NOT operation, 0 becomes 1, 1 becomes 0, $3 = 11_2$ becomes 0, $14 = 1110_2$ becomes 1, $10 = 1010_2$ becomes $5 = 101_2$, and $5 = 101_2$ becomes $2 = 10_2$. ($X_2$ means the integer whose binary representation is $X$).\n\nYou can use these operations as many times as you want in any order. For example, you can transform $\\textbf{S} = 10001_2$ to $\\textbf{E} = 111_2$ using the NOT operation first, then using the double operation twice, and then another NOT operation:\n\n$$10001_2 \\xrightarrow{\\text{NOT}} 1110_2 \\xrightarrow{\\times2} 11100_2 \\xrightarrow{\\times2} 111000_2 \\xrightarrow{\\text{NOT}} 111_2.$$\n\nDetermine the smallest number of operations needed to complete the transformation, or say it is impossible to do so.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\textbf{T}$. $\\textbf{T}$ test cases follow. Each consists of a single line containing two strings $\\textbf{S}$ and $\\textbf{E}$, the binary representations of the starting and ending integers, respectively.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if there is no way to transform $\\textbf{S}$ into $\\textbf{E}$ using the two operations. Otherwise, $y$ is the smallest number of operations needed to transform $\\textbf{S}$ into $\\textbf{E}$.", "hint": "**Sample Explanation**\n\nSample Case #1 is the example shown in the main part of the statement.\n\nThese are possible optimal ways of solving Sample Cases #2, #3, and #4, respectively:\n\n$$1011_2 \\xrightarrow{\\text{NOT}} 100_2 \\xrightarrow{\\times2} 1000_2 \\xrightarrow{\\text{NOT}} 111_2,$$\n\n$$1010_2 \\xrightarrow{\\times2} 10100_2 \\xrightarrow{\\text{NOT}} 1011_2,$$ \n\nand\n\n$$0_2 \\xrightarrow{\\text{NOT}} 1_2.$$\n\nIn Sample Case #5, it is not possible to get from $0_2$ to $101_2$ with any sequence of operations.\n\nIn Sample Case #6, we do not need to perform any operations because $\\textbf{S} = \\textbf{E}$.\n\n**Limits**\n\n- $1 \\leq \\textbf{T} \\leq 100$.\n- Each character of $\\textbf{S}$ is either 0 or 1.\n- The first digit of $\\textbf{S}$ can be 0 only if the length of $\\textbf{S}$ is 1.\n- Each character of $\\textbf{E}$ is either 0 or 1.\n- The first digit of $\\textbf{E}$ can be 0 only if the length of $\\textbf{E}$ is 1.\n\n**Test Set 1 (14 Pts, Visible Verdict)**\n\n- $1 \\leq \\text{the length of } \\textbf{S} \\leq 8$.\n- $1 \\leq \\text{the length of } \\textbf{E} \\leq 8$.\n\n**Test Set 2 (26 Pts, Hidden Verdict)**\n\n- $1 \\leq \\text{the length of } \\textbf{S} \\leq 100$.\n- $1 \\leq \\text{the length of } \\textbf{E} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #1C] Double or NOTing", "background": "", "description": "You are given a starting non-negative integer $\\textbf{S}$ and an ending non-negative integer $\\textbf{E}$. Both $\\textbf{S}$ and $\\textbf{E}$ are given by their binary representation (that is, they are given written in base 2). Your goal is to transform $\\textbf{S}$ into $\\textbf{E}$. The following two operations are available to you:\n\n- Double your current value.\n- Take the bitwise NOT of your current value. The binary representation of your current value is taken without unnecessary leading zeroes, and any unnecessary leading zeroes produced by the operation are dropped. (The only necessary leading zero is the one in the representation of 0).\n\nFor example, by using the double operation, 6 becomes 12, 0 becomes 0, and 10 becomes 20. By using the NOT operation, 0 becomes 1, 1 becomes 0, $3 = 11_2$ becomes 0, $14 = 1110_2$ becomes 1, $10 = 1010_2$ becomes $5 = 101_2$, and $5 = 101_2$ becomes $2 = 10_2$. ($X_2$ means the integer whose binary representation is $X$).\n\nYou can use these operations as many times as you want in any order. For example, you can transform $\\textbf{S} = 10001_2$ to $\\textbf{E} = 111_2$ using the NOT operation first, then using the double operation twice, and then another NOT operation:\n\n$$10001_2 \\xrightarrow{\\text{NOT}} 1110_2 \\xrightarrow{\\times2} 11100_2 \\xrightarrow{\\times2} 111000_2 \\xrightarrow{\\text{NOT}} 111_2.$$\n\nDetermine the smallest number of operations needed to complete the transformation, or say it is impossible to do so.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\textbf{T}$. $\\textbf{T}$ test cases follow. Each consists of a single line containing two strings $\\textbf{S}$ and $\\textbf{E}$, the binary representations of the starting and ending integers, respectively.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if there is no way to transform $\\textbf{S}$ into $\\textbf{E}$ using the two operations. Otherwise, $y$ is the smallest number of operations needed to transform $\\textbf{S}$ into $\\textbf{E}$.", "hint": "**Sample Explanation**\n\nSample Case #1 is the example shown in the main part of the statement.\n\nThese are possible optimal ways of solving Sample Cases #2, #3, and #4, respectively:\n\n$$1011_2 \\xrightarrow{\\text{NOT}} 100_2 \\xrightarrow{\\times2} 1000_2 \\xrightarrow{\\text{NOT}} 111_2,$$\n\n$$1010_2 \\xrightarrow{\\times2} 10100_2 \\xrightarrow{\\text{NOT}} 1011_2,$$ \n\nand\n\n$$0_2 \\xrightarrow{\\text{NOT}} 1_2.$$\n\nIn Sample Case #5, it is not possible to get from $0_2$ to $101_2$ with any sequence of operations.\n\nIn Sample Case #6, we do not need to perform any operations because $\\textbf{S} = \\textbf{E}$.\n\n**Limits**\n\n- $1 \\leq \\textbf{T} \\leq 100$.\n- Each character of $\\textbf{S}$ is either 0 or 1.\n- The first digit of $\\textbf{S}$ can be 0 only if the length of $\\textbf{S}$ is 1.\n- Each character of $\\textbf{E}$ is either 0 or 1.\n- The first digit of $\\textbf{E}$ can be 0 only if the length of $\\textbf{E}$ is 1.\n\n**Test Set 1 (14 Pts, Visible Verdict)**\n\n- $1 \\leq \\text{the length of } \\textbf{S} \\leq 8$.\n- $1 \\leq \\text{the length of } \\textbf{E} \\leq 8$.\n\n**Test Set 2 (26 Pts, Hidden Verdict)**\n\n- $1 \\leq \\text{the length of } \\textbf{S} \\leq 100$.\n- $1 \\leq \\text{the length of } \\textbf{E} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #1C] Double or NOTing", "background": "", "description": "给定一个起始非负整数 $\\textbf{S}$ 和一个目标非负整数 $\\textbf{E}$。$\\textbf{S}$ 和 $\\textbf{E}$ 都以二进制形式给出（即以 2 为基数的表示）。你的目标是通过以下两种操作将 $\\textbf{S}$ 转换为 $\\textbf{E}$：\n\n1. **双倍操作**：将当前值乘以 2。\n2. **取反操作**：对当前值进行按位取反。当前值的二进制表示不包含不必要的前导零，且操作后产生的不必要前导零将被移除。（唯一必要的前导零是表示 0 时的那个零）。\n\n例如：\n- 双倍操作：6 变为 12，0 保持为 0，10 变为 20。\n- 取反操作：0 变为 1，1 变为 0，$3 = 11_2$ 变为 0，$14 = 1110_2$ 变为 1，$10 = 1010_2$ 变为 $5 = 101_2$，$5 = 101_2$ 变为 $2 = 10_2$。（$X_2$ 表示二进制表示为 $X$ 的整数）。\n\n你可以按任意顺序、任意次数使用这两种操作。例如，可以通过先取反，再两次双倍，最后再取反，将 $\\textbf{S} = 10001_2$ 转换为 $\\textbf{E} = 111_2$：\n\n$$10001_2 \\xrightarrow{\\text{取反}} 1110_2 \\xrightarrow{\\times2} 11100_2 \\xrightarrow{\\times2} 111000_2 \\xrightarrow{\\text{取反}} 111_2.$$\n\n你的任务是确定完成转换所需的最少操作次数，或者判定转换**不可能**。", "inputFormat": "输入的第一行是测试用例的数量 $\\textbf{T}$。接下来是 $\\textbf{T}$ 个测试用例，每个测试用例占一行，包含两个字符串 $\\textbf{S}$ 和 $\\textbf{E}$，分别表示起始整数和目标整数的二进制形式。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 `IMPOSSIBLE`（如果无法通过操作将 $\\textbf{S}$ 转换为 $\\textbf{E}$），否则 $y$ 是所需的最少操作次数。\n", "hint": "**样例解释**\n\n样例 #1 是题目描述中给出的示例。\n\n以下是样例 #2、#3 和 #4 的可能最优解法：\n\n$$1011_2 \\xrightarrow{\\text{取反}} 100_2 \\xrightarrow{\\times2} 1000_2 \\xrightarrow{\\text{取反}} 111_2,$$\n\n$$1010_2 \\xrightarrow{\\times2} 10100_2 \\xrightarrow{\\text{取反}} 1011_2,$$\n\n$$0_2 \\xrightarrow{\\text{取反}} 1_2.$$\n\n在样例 #5 中，无法通过任何操作序列将 $0_2$ 转换为 $101_2$。\n\n在样例 #6 中，$\\textbf{S} = \\textbf{E}$，因此无需任何操作。\n\n**数据范围**\n\n- $1 \\leq \\textbf{T} \\leq 100$。\n- $\\textbf{S}$ 的每个字符是 0 或 1。\n- $\\textbf{S}$ 的首字符可以是 0，仅当 $\\textbf{S}$ 的长度为 1 时。\n- $\\textbf{E}$ 的每个字符是 0 或 1。\n- $\\textbf{E}$ 的首字符可以是 0，仅当 $\\textbf{E}$ 的长度为 1 时。\n\n**测试集 1（14 分，可见判定）**\n\n- $1 \\leq \\text{\\textbf{S} 的长度} \\leq 8$。\n- $1 \\leq \\text{\\textbf{E} 的长度} \\leq 8$。\n\n**测试集 2（26 分，隐藏判定）**\n\n- $1 \\leq \\text{\\textbf{S} 的长度} \\leq 100$。\n- $1 \\leq \\text{\\textbf{E} 的长度} \\leq 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13035", "type": "P", "difficulty": 3, "samples": [["2 4\n\n4\n\n2\n\n1\n\n4\n\n1\n\n1\n\n3\n\n1\n\n3\n\n2\n\n1", "\nM 2 4\n\nM 1 3\n\nS 1 4\n\nM 3 4\n\nS 3 4\n\nD\n\nM 1 4\n\nS 1 3\n\nM 3 4\n\nM 2 4\n\nD"]], "limits": {"time": [60000], "memory": [1048576]}, "tags": ["2021", "交互题", "Special Judge", "排序", "Google Code Jam"], "title": "[GCJ 2021 #2] Minimum Sort", "background": "", "description": "In this problem, you need to sort a list of $N = 100$ distinct integers in strictly increasing order. You can rearrange the list by swapping the contents of any two positions (they do not need to be adjacent). Unfortunately, you cannot read those contents directly. You can access information about the list contents by querying the minimum of a range. The minimum query gives you the position of the minimum value over a range of consecutive positions. For example, in the list $[51, 33, 100, 11]$, the minimum over the range between positions 2 and 4, inclusive (1-based), is at position 4 and the minimum between positions 1 and 3 is at position 2.\n\nQueries about the minimum within a range are limited by a coin budget per test case. Larger ranges are cheaper: asking about the position of the minimum between positions $i$ and $j$ (for $i < j$) costs $\\lceil 10^8 / (j - i + 1) \\rceil$ coins, where $\\lceil x \\rceil$ is the smallest integer greater than or equal to $x$ (that is, $x$ rounded up). Swap operations, on the other hand, do not cost any coins.\n\nWrite a program that sorts lists of integers using any number of swaps and at most $6 \\times 10^8$ coins per test case distributed among any number of minimum queries.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, the judge will send you a single line containing two integers $\\mathbf{T}$ and $\\mathbf{N}$: the number of test cases and the number of elements to sort within each test case, respectively. The judge has the initial lists preset before it gets any input from your program, and the only changes done to them during the exchanges with your program are the swaps that you request.\n\nThen, you must process $\\mathbf{T}$ test cases. Each test case consists of a series of exchanges plus an additional line indicating you are done. Each exchange consists of you printing one line and the judge printing one line in response. Your program must print a single line containing one of these options:\n\n- An uppercase $\\mathbf{M}$ and two integers $i$ and $j$ with $i < j$ representing a minimum query. The judge responds with a single integer representing the position of the minimum value in the list within 1-based positions $i$ and $j$, inclusive.\n- An uppercase $\\mathbf{S}$ and two integers $i$ and $j$ with $i < j$ representing a swap operation. The judge swaps the two elements at 1-based positions $i$ and $j$ and responds with 1.\n- An uppercase $\\mathbf{D}$ representing that you are done sorting the list. The judge checks the list. It responds with 1 if the list is sorted in strictly increasing order and -1 if it is not.\n\nAfter the judge responds 1 to a $\\mathbf{D}$, it will finish if it was the last test case or it will immediately start waiting for your first command for the next test case. After receiving the judge's response for the $\\mathbf{T}$-th case, your program must finish in order to not receive a Time Limit Exceeded error.\n\nIf the judge receives an invalidly formatted line or invalid values from your program at any moment, including a minimum operation whose cost would exceed your remaining budget for the test case, the judge will print a single number -1. After the judge prints -1 for any of the reasons explained above, it will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{T} = 100$.\n- $\\mathbf{N} = 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #2] Minimum Sort", "background": "", "description": "In this problem, you need to sort a list of $N = 100$ distinct integers in strictly increasing order. You can rearrange the list by swapping the contents of any two positions (they do not need to be adjacent). Unfortunately, you cannot read those contents directly. You can access information about the list contents by querying the minimum of a range. The minimum query gives you the position of the minimum value over a range of consecutive positions. For example, in the list $[51, 33, 100, 11]$, the minimum over the range between positions 2 and 4, inclusive (1-based), is at position 4 and the minimum between positions 1 and 3 is at position 2.\n\nQueries about the minimum within a range are limited by a coin budget per test case. Larger ranges are cheaper: asking about the position of the minimum between positions $i$ and $j$ (for $i < j$) costs $\\lceil 10^8 / (j - i + 1) \\rceil$ coins, where $\\lceil x \\rceil$ is the smallest integer greater than or equal to $x$ (that is, $x$ rounded up). Swap operations, on the other hand, do not cost any coins.\n\nWrite a program that sorts lists of integers using any number of swaps and at most $6 \\times 10^8$ coins per test case distributed among any number of minimum queries.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, the judge will send you a single line containing two integers $\\mathbf{T}$ and $\\mathbf{N}$: the number of test cases and the number of elements to sort within each test case, respectively. The judge has the initial lists preset before it gets any input from your program, and the only changes done to them during the exchanges with your program are the swaps that you request.\n\nThen, you must process $\\mathbf{T}$ test cases. Each test case consists of a series of exchanges plus an additional line indicating you are done. Each exchange consists of you printing one line and the judge printing one line in response. Your program must print a single line containing one of these options:\n\n- An uppercase $\\mathbf{M}$ and two integers $i$ and $j$ with $i < j$ representing a minimum query. The judge responds with a single integer representing the position of the minimum value in the list within 1-based positions $i$ and $j$, inclusive.\n- An uppercase $\\mathbf{S}$ and two integers $i$ and $j$ with $i < j$ representing a swap operation. The judge swaps the two elements at 1-based positions $i$ and $j$ and responds with 1.\n- An uppercase $\\mathbf{D}$ representing that you are done sorting the list. The judge checks the list. It responds with 1 if the list is sorted in strictly increasing order and -1 if it is not.\n\nAfter the judge responds 1 to a $\\mathbf{D}$, it will finish if it was the last test case or it will immediately start waiting for your first command for the next test case. After receiving the judge's response for the $\\mathbf{T}$-th case, your program must finish in order to not receive a Time Limit Exceeded error.\n\nIf the judge receives an invalidly formatted line or invalid values from your program at any moment, including a minimum operation whose cost would exceed your remaining budget for the test case, the judge will print a single number -1. After the judge prints -1 for any of the reasons explained above, it will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our interactive runner for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{T} = 100$.\n- $\\mathbf{N} = 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #2] Minimum Sort", "background": "", "description": "在这个问题中，你需要将一个包含 $N = 100$ 个不同整数的列表按严格递增的顺序排序。你可以通过交换任意两个位置的内容来重新排列列表（这两个位置不需要相邻）。但遗憾的是，你无法直接读取这些内容。你可以通过查询区间最小值来获取列表内容的信息。最小值查询会给出一个连续位置区间内最小值所在的位置。例如，在列表 $[51, 33, 100, 11]$ 中，位置 2 到 4（基于 1 的索引）的最小值位于位置 4，而位置 1 到 3 的最小值位于位置 2。\n\n关于区间最小值的查询受到每个测试用例的硬币预算限制。更大的区间更便宜：查询位置 $i$ 到 $j$（$i < j$）的最小值位置需要花费 $\\lceil 10^8 / (j - i + 1) \\rceil$ 枚硬币，其中 $\\lceil x \\rceil$ 表示大于或等于 $x$ 的最小整数（即 $x$ 向上取整）。而交换操作不消耗任何硬币。\n\n编写一个程序，使用任意次数的交换操作和最多 $6 \\times 10^8$ 枚硬币（每个测试用例中分配到任意数量的最小值查询）对整数列表进行排序。\n\n### 交互协议\n\n这是一个交互式问题。\n\n最初，评测机会发送一行包含两个整数 $\\mathbf{T}$ 和 $\\mathbf{N}$：分别是测试用例的数量和每个测试用例中需要排序的元素数量。评测机在收到你的程序的任何输入之前已经预设了初始列表，并且在与你程序的交互过程中，列表的唯一变化是你请求的交换操作。\n\n然后，你需要处理 $\\mathbf{T}$ 个测试用例。每个测试用例由一系列交互加上一行表示完成的指令组成。每次交互由你打印一行和评测机打印一行响应组成。你的程序必须打印以下选项之一的一行内容：\n\n- 一个大写字母 $\\mathbf{M}$ 和两个整数 $i$ 和 $j$（$i < j$），表示一个最小值查询。评测机会响应一个整数，表示基于 1 的索引中位置 $i$ 到 $j$（包含）区间内最小值的位置。\n- 一个大写字母 $\\mathbf{S}$ 和两个整数 $i$ 和 $j$（$i < j$），表示一个交换操作。评测机会交换基于 1 的索引中位置 $i$ 和 $j$ 的两个元素，并响应 1。\n- 一个大写字母 $\\mathbf{D}$，表示你已完成列表的排序。评测机会检查列表。如果列表已按严格递增顺序排序，则响应 1；否则响应 -1。\n\n当评测机对 $\\mathbf{D}$ 响应 1 后，如果是最后一个测试用例，评测机会结束；否则会立即开始等待你对下一个测试用例的第一条指令。在收到第 $\\mathbf{T}$ 个测试用例的响应后，你的程序必须结束，否则会收到“超出时间限制”错误。\n\n如果评测机在任何时候收到格式无效的行或无效的值（包括最小值查询的硬币成本超过了当前测试用例的剩余预算），评测机会打印一个数字 -1。在评测机因上述任何原因打印 -1 后，它将不再输出任何内容。如果你的程序在收到 -1 后继续等待评测机的响应，你的程序将因超时而收到“超出时间限制”错误。请注意，你的程序有责任及时退出以避免收到“超出时间限制”错误，而应收到“答案错误”的判定。与往常一样，如果超出内存限制或程序出现运行时错误，你将收到相应的判定。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "你可以使用此测试工具在本地或我们的平台上进行测试。要在本地测试，你需要同时运行该工具和你的代码；你可以使用我们的[交互式运行器](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)来实现。\n\n测试工具的说明包含在工具的注释中。我们鼓励你添加自己的测试用例。请注意，尽管该测试工具旨在模拟评测系统，但它**并非**真实的评测系统，可能会表现出不同的行为。\n\n**限制**\n\n**测试集 1（15 分，可见判定）**\n\n- $\\mathbf{T} = 100$。\n- $\\mathbf{N} = 100$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13036", "type": "P", "difficulty": 4, "samples": [["3\n33\n15\n41", "Case #1: 3\nCase #2: 2\nCase #3: 1"]], "limits": {"time": [20000, 20000, 40000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2021", "Google Code Jam"], "title": "[GCJ 2021 #2] Matrygons", "background": "", "description": "A [matryoshka](https://en.wikipedia.org/wiki/Matryoshka_doll) is a type of doll that originated in Russia over a century ago. Their defining characteristic is that they consist of a set of dolls, all of a different size, with smaller dolls fitting nicely inside larger dolls.\n\nIn this problem, we work with matrygons, which are sets of regular convex polygons that follow a similar nesting pattern. A matrygon consists of a set of regular convex polygons with positive area $p_1, p_2, \\ldots, p_k$ such that, for all $i$, the vertices of $p_{i+1}$ overlap with a proper subset of the vertices of $p_i$ ($p_{i+1}$ has strictly less vertices than $p_i$).\n\nFor example, the following pictures illustrate two matrygons. The first one contains 3 regular convex polygons: a regular icositetragon (24 sides), a regular hexagon (6 sides), and an equilateral triangle (3 sides). The second one contains 2 regular convex polygons: a regular icosidigon (22 sides) and a regular hendecagon (11 sides). Each of these matrygons has 33 total sides among all polygons in it.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3kcm72a3.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/pf69u83n.png)\n\nGiven a fixed total number of sides $\\mathbf{N}$, calculate the largest number of polygons that can be part of a matrygon such that the total number of sides among all polygons in it is exactly $\\mathbf{N}$.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line represents a test case and contains a single integer $\\mathbf{N}$, the target total number of sides.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of polygons in a matrygon such that the total number of sides among all polygons in it is exactly $\\mathbf{N}$.", "hint": "**Sample Explanation**\n\nThe first matrygon pictured in the problem statement is an optimal solution for Sample Case #1.\n\nIn Sample Case #2, we can get to two polygons by fitting a regular pentagon (5 sides) inside a regular decagon (10 sides).\n\nIn Sample Case #3, there is no way to create a matrygon with multiple regular polygons, so our only option is to use a single regular tetracontahenagon (41 sides).\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $3 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 2 (13 Pts, Visible Verdict)**\n\n- Time limit: 40 seconds.\n- $3 \\leq \\mathbf{N} \\leq 10^6$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #2] Matrygons", "background": "", "description": "A [matryoshka](https://en.wikipedia.org/wiki/Matryoshka_doll) is a type of doll that originated in Russia over a century ago. Their defining characteristic is that they consist of a set of dolls, all of a different size, with smaller dolls fitting nicely inside larger dolls.\n\nIn this problem, we work with matrygons, which are sets of regular convex polygons that follow a similar nesting pattern. A matrygon consists of a set of regular convex polygons with positive area $p_1, p_2, \\ldots, p_k$ such that, for all $i$, the vertices of $p_{i+1}$ overlap with a proper subset of the vertices of $p_i$ ($p_{i+1}$ has strictly less vertices than $p_i$).\n\nFor example, the following pictures illustrate two matrygons. The first one contains 3 regular convex polygons: a regular icositetragon (24 sides), a regular hexagon (6 sides), and an equilateral triangle (3 sides). The second one contains 2 regular convex polygons: a regular icosidigon (22 sides) and a regular hendecagon (11 sides). Each of these matrygons has 33 total sides among all polygons in it.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3kcm72a3.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/pf69u83n.png)\n\nGiven a fixed total number of sides $\\mathbf{N}$, calculate the largest number of polygons that can be part of a matrygon such that the total number of sides among all polygons in it is exactly $\\mathbf{N}$.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line represents a test case and contains a single integer $\\mathbf{N}$, the target total number of sides.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of polygons in a matrygon such that the total number of sides among all polygons in it is exactly $\\mathbf{N}$.", "hint": "**Sample Explanation**\n\nThe first matrygon pictured in the problem statement is an optimal solution for Sample Case #1.\n\nIn Sample Case #2, we can get to two polygons by fitting a regular pentagon (5 sides) inside a regular decagon (10 sides).\n\nIn Sample Case #3, there is no way to create a matrygon with multiple regular polygons, so our only option is to use a single regular tetracontahenagon (41 sides).\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $3 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 2 (13 Pts, Visible Verdict)**\n\n- Time limit: 40 seconds.\n- $3 \\leq \\mathbf{N} \\leq 10^6$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #2] Matrygons", "background": "", "description": "[套娃](https://en.wikipedia.org/wiki/Matryoshka_doll)是一种起源于一个多世纪前俄罗斯的玩偶。它们的显著特征是由一组大小各异的玩偶组成，较小的玩偶可以完美地嵌套在较大的玩偶内部。\n\n在本问题中，我们研究**套娃多边形**，这是一组遵循类似嵌套规则的正则凸多边形。一个套娃多边形由一组面积为正的正则凸多边形 $p_1, p_2, \\ldots, p_k$ 组成，且满足对于所有 $i$，$p_{i+1}$ 的顶点是 $p_i$ 顶点的**真子集**（即 $p_{i+1}$ 的边数严格少于 $p_i$）。\n\n例如，下图展示了两个套娃多边形。第一个包含 3 个正则凸多边形：一个正二十四边形（24 条边）、一个正六边形（6 条边）和一个等边三角形（3 条边）。第二个包含 2 个正则凸多边形：一个正二十二边形（22 条边）和一个正十一边形（11 条边）。这两个套娃多边形的总边数均为 33。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3kcm72a3.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/pf69u83n.png)\n\n给定总边数 $\\mathbf{N}$，计算在总边数恰好为 $\\mathbf{N}$ 的套娃多边形中，最多可以包含多少个多边形。", "inputFormat": "输入第一行包含测试用例数量 $\\mathbf{T}$。随后 $\\mathbf{T}$ 行，每行一个整数 $\\mathbf{N}$，表示目标总边数。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为满足条件的套娃多边形中最多包含的多边形数量。\n", "hint": "**样例解释**\n\n问题描述中的第一个套娃多边形是样例 #1 的最优解。\n\n在样例 #2 中，我们可以将一个正五边形（5 条边）嵌套在正十边形（10 条边）内，得到包含 2 个多边形的套娃多边形。\n\n在样例 #3 中，无法创建包含多个正则多边形的套娃多边形，因此唯一选择是使用单个正四十一边形（41 条边）。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n\n**测试集 1（7 分，可见判定）**\n\n- 时间限制：20 秒。\n- $3 \\leq \\mathbf{N} \\leq 1000$。\n\n**测试集 2（13 分，可见判定）**\n\n- 时间限制：40 秒。\n- $3 \\leq \\mathbf{N} \\leq 10^6$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13037", "type": "P", "difficulty": 5, "samples": [["3\n4\n1 2 2 1\n3\n1 1 2\n3\n1 1 3", "Case #1: 1\nCase #2: 2\nCase #3: 0"], ["1\n24\n1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2", "Case #1: 234141013"]], "limits": {"time": [30000, 30000, 40000], "memory": [1048576, 1048576, 1048576]}, "tags": ["线段树", "二分", "2021", "分治", "组合数学", "Google Code Jam"], "title": "[GCJ 2021 #2] Hidden Pancakes", "background": "", "description": "We are cooking $\\mathbf{N}$ pancakes in total. We cook one pancake with a 1 centimeter (cm) radius, one with a $2 \\mathrm{~cm}$ radius, one with a $3 \\mathrm{~cm}$ radius, ..., and one with an $\\mathbf{N} \\mathrm{cm}$ radius, not necessarily in that order. After we cook the first pancake, we just lay it on a plate. After we cook each subsequent pancake, we lay it on top of the previously made pancake, with their centers coinciding. In this way, a pancake is visible from the top of the stack when we first add it. A pancake only becomes hidden if we later cook another pancake with a larger radius.\n\nFor example, say we cook 4 pancakes. We first cook the pancake with radius $3 \\mathrm{~cm}$, and it is visible. Then, we cook the pancake with radius $1 \\mathrm{~cm}$, lay it on top of the first one and both are visible. Third, we cook the pancake with radius $2 \\mathrm{~cm}$, and now that covers the previous pancake, but not the first one, so 2 pancakes remain visible in total. Finally, we cook the pancake with radius $4 \\mathrm{~cm}$ which covers the other pancakes leaving only 1 visible pancake. The picture below illustrates the state of the stack after each pancake is cooked. Within each stack, the fully colored pancakes are visible and the semi-transparent pancakes are not visible.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s69k9evw.png)\n\nLet $\\mathbf{V}_{\\mathbf{i}}$ be the number of visible pancakes when the stack contains exactly $i$ pancakes. In the example above, $\\mathbf{V}_{1}=1, \\mathbf{V}_{2}=2, \\mathbf{V}_{3}=2$, and $\\mathbf{V}_{4}=1$.\n\nGiven the list $\\mathbf{V}_{1}, \\mathbf{V}_{2}, \\ldots, \\mathbf{V}_{\\mathbf{N}}$, how many of the $\\mathbf{N} !$ possible cooking orders yield those values? Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^{9}+7(1000000007)$.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow, each described with two lines. The first line of a test case contains a single integer $\\mathbf{N}$, the number of pancakes we cook. The second line of a test case contains $\\mathbf{N}$ integers $\\mathbf{V}_{1}, \\mathbf{V}_{2}, \\ldots, \\mathbf{V}_{\\mathbf{N}}$, representing the number of visible pancakes after we cook $1,2, \\ldots, \\mathbf{N}$ pancakes, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of cooking orders of $\\mathbf{N}$ pancakes that yield the given numbers of visible pancakes after each step, modulo the prime $10^{9}+7(1000000007)$.", "hint": "Sample Case #1 is explained in the problem statement. The order $3,1,2,4$ is the only one that yields the given $\\mathbf{V}_{\\mathbf{i}} \\mathrm{s}$.\n\nIn Sample Case #2, both the order $1,3,2$ and the order $2,3,1$ yield the intended $\\mathbf{V}_{\\mathbf{i}} \\mathrm{s}$. The pictures below illustrate both options.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o981r60x.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3vhqt53k.png)\n\nIn Sample Case #3, only 1 pancake is visible after the second is made, so there is no way to have more than 2 visible pancakes by only adding a third.\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nIn the Sample Case for Test Set 2, there are $316234143225$ cooking orders that yield the given $\\mathbf{V}_{\\mathbf{i}} \\mathrm{s}$. Modulo $10^{9}+7$, this value is $234141013$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{V}_{\\mathbf{i}} \\leq i$, for all $i$.\n\n**Test Set 1 (Visible Verdict)**\n\n- Time limit: 30 seconds.\n- $2 \\leq \\mathbf{N} \\leq 13$.\n\n**Test Set 2 (Hidden Verdict)**\n\n- Time limit: 40 seconds.\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #2] Hidden Pancakes", "background": "", "description": "We are cooking $\\mathbf{N}$ pancakes in total. We cook one pancake with a 1 centimeter (cm) radius, one with a $2 \\mathrm{~cm}$ radius, one with a $3 \\mathrm{~cm}$ radius, ..., and one with an $\\mathbf{N} \\mathrm{cm}$ radius, not necessarily in that order. After we cook the first pancake, we just lay it on a plate. After we cook each subsequent pancake, we lay it on top of the previously made pancake, with their centers coinciding. In this way, a pancake is visible from the top of the stack when we first add it. A pancake only becomes hidden if we later cook another pancake with a larger radius.\n\nFor example, say we cook 4 pancakes. We first cook the pancake with radius $3 \\mathrm{~cm}$, and it is visible. Then, we cook the pancake with radius $1 \\mathrm{~cm}$, lay it on top of the first one and both are visible. Third, we cook the pancake with radius $2 \\mathrm{~cm}$, and now that covers the previous pancake, but not the first one, so 2 pancakes remain visible in total. Finally, we cook the pancake with radius $4 \\mathrm{~cm}$ which covers the other pancakes leaving only 1 visible pancake. The picture below illustrates the state of the stack after each pancake is cooked. Within each stack, the fully colored pancakes are visible and the semi-transparent pancakes are not visible.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s69k9evw.png)\n\nLet $\\mathbf{V}_{\\mathbf{i}}$ be the number of visible pancakes when the stack contains exactly $i$ pancakes. In the example above, $\\mathbf{V}_{1}=1, \\mathbf{V}_{2}=2, \\mathbf{V}_{3}=2$, and $\\mathbf{V}_{4}=1$.\n\nGiven the list $\\mathbf{V}_{1}, \\mathbf{V}_{2}, \\ldots, \\mathbf{V}_{\\mathbf{N}}$, how many of the $\\mathbf{N} !$ possible cooking orders yield those values? Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^{9}+7(1000000007)$.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow, each described with two lines. The first line of a test case contains a single integer $\\mathbf{N}$, the number of pancakes we cook. The second line of a test case contains $\\mathbf{N}$ integers $\\mathbf{V}_{1}, \\mathbf{V}_{2}, \\ldots, \\mathbf{V}_{\\mathbf{N}}$, representing the number of visible pancakes after we cook $1,2, \\ldots, \\mathbf{N}$ pancakes, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of cooking orders of $\\mathbf{N}$ pancakes that yield the given numbers of visible pancakes after each step, modulo the prime $10^{9}+7(1000000007)$.", "hint": "Sample Case #1 is explained in the problem statement. The order $3,1,2,4$ is the only one that yields the given $\\mathbf{V}_{\\mathbf{i}} \\mathrm{s}$.\n\nIn Sample Case #2, both the order $1,3,2$ and the order $2,3,1$ yield the intended $\\mathbf{V}_{\\mathbf{i}} \\mathrm{s}$. The pictures below illustrate both options.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o981r60x.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3vhqt53k.png)\n\nIn Sample Case #3, only 1 pancake is visible after the second is made, so there is no way to have more than 2 visible pancakes by only adding a third.\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nIn the Sample Case for Test Set 2, there are $316234143225$ cooking orders that yield the given $\\mathbf{V}_{\\mathbf{i}} \\mathrm{s}$. Modulo $10^{9}+7$, this value is $234141013$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{V}_{\\mathbf{i}} \\leq i$, for all $i$.\n\n**Test Set 1 (Visible Verdict)**\n\n- Time limit: 30 seconds.\n- $2 \\leq \\mathbf{N} \\leq 13$.\n\n**Test Set 2 (Hidden Verdict)**\n\n- Time limit: 40 seconds.\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #2] Hidden Pancakes", "background": "", "description": "我们总共要烹饪 $\\mathbf{N}$ 张煎饼。这些煎饼的半径分别为 $1$ 厘米（cm）、$2 \\mathrm{~cm}$、$3 \\mathrm{~cm}$，……，以及 $\\mathbf{N} \\mathrm{cm}$，但烹饪顺序不一定按半径从小到大排列。烹饪完第一张煎饼后，我们直接将其放在盘子上。之后每烹饪完一张煎饼，就将其叠放在之前所有煎饼的最上方，且所有煎饼的中心对齐。这样，每张煎饼在刚被加入时都能从顶部被看到。只有当之后烹饪了比它半径更大的煎饼时，这张煎饼才会被隐藏。\n\n例如，假设我们烹饪 4 张煎饼。首先烹饪半径为 $3 \\mathrm{~cm}$ 的煎饼，此时它可见。接着烹饪半径为 $1 \\mathrm{~cm}$ 的煎饼，叠放在第一张煎饼上，此时两张煎饼都可见。然后烹饪半径为 $2 \\mathrm{~cm}$ 的煎饼，它会覆盖前一张煎饼（半径为 $1 \\mathrm{~cm}$ 的煎饼），但不会覆盖第一张煎饼，因此此时共有 2 张煎饼可见。最后，烹饪半径为 $4 \\mathrm{~cm}$ 的煎饼，它会覆盖所有其他煎饼，此时只有 1 张煎饼可见。下图展示了每张煎饼被烹饪后叠放的状态，其中完全不透明的煎饼表示可见，半透明的煎饼表示不可见。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/s69k9evw.png)\n\n设 $\\mathbf{V}_{\\mathbf{i}}$ 表示叠放了恰好 $i$ 张煎饼时可见的煎饼数量。在上面的例子中，$\\mathbf{V}_{1}=1$、$\\mathbf{V}_{2}=2$、$\\mathbf{V}_{3}=2$、$\\mathbf{V}_{4}=1$。\n\n给定列表 $\\mathbf{V}_{1}, \\mathbf{V}_{2}, \\ldots, \\mathbf{V}_{\\mathbf{N}}$，问在所有 $\\mathbf{N} !$ 种可能的烹饪顺序中，有多少种顺序能恰好得到给定的 $\\mathbf{V}_{\\mathbf{i}}$ 序列？由于结果可能非常大，只需输出结果对质数 $10^{9}+7$（即 $1000000007$）取模后的值。\n", "inputFormat": "输入的第一行包含测试用例数量 $\\mathbf{T}$。每个测试用例包含两行：第一行是一个整数 $\\mathbf{N}$，表示烹饪的煎饼数量；第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{V}_{1}, \\mathbf{V}_{2}, \\ldots, \\mathbf{V}_{\\mathbf{N}}$，分别表示叠放了 $1, 2, \\ldots, \\mathbf{N}$ 张煎饼时的可见煎饼数量。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是满足条件的烹饪顺序数量对 $10^{9}+7$ 取模后的结果。\n", "hint": "**样例解释**\n\n样例 #1 已在题目描述中说明，唯一的满足条件的烹饪顺序是 $3,1,2,4$。\n\n在样例 #2 中，顺序 $1,3,2$ 和 $2,3,1$ 均能满足给定的 $\\mathbf{V}_{\\mathbf{i}}$ 序列。下图展示了这两种情况：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o981r60x.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3vhqt53k.png)\n\n在样例 #3 中，叠加第二张煎饼后只有 1 张煎饼可见，因此无法通过叠加第三张煎饼使可见煎饼数量超过 2。\n\n样例测试集 2 符合测试集 2 的限制条件，但提交的解法不会实际运行该测试集。\n\n在测试集 2 的样例中，共有 $316234143225$ 种烹饪顺序满足给定的 $\\mathbf{V}_{\\mathbf{i}}$ 序列，对 $10^{9}+7$ 取模后的结果是 $234141013$。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i$，$1 \\leq \\mathbf{V}_{\\mathbf{i}} \\leq i$。\n\n**测试集 1（可见判定）**\n\n- 时间限制：30 秒。\n- $2 \\leq \\mathbf{N} \\leq 13$。\n\n**测试集 2（隐藏判定）**\n\n- 时间限制：40 秒。\n- $2 \\leq \\mathbf{N} \\leq 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13038", "type": "P", "difficulty": 6, "samples": [["2\n2 4 1 1\nMGMG\nMMMG\nGMGM\nMMMM\n3 3 1 1\nMGG\nGMG\nMMM\nMMM\nMGM\nMMG", "Case #1: 3\nCase #2: 4"], ["1\n1 5 1000 1\nMGGGG\nGGGMM", "Case #1: 1003"]], "limits": {"time": [40000, 40000, 40000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2021", "二分图", "费用流", "Google Code Jam"], "title": "[GCJ 2021 #2] Retiling", "background": "", "description": "Cody-Jamal's latest artistic installment is a tiled kitchen floor that can be retiled to different patterns. The floor consists of a matrix of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns of square tiles. Each tile is reversible, one side is magenta and the other one is green.\n\nTo retile the kitchen, there are two allowed operations:\n\n* flip a tile, changing its visible color from magenta to green, or vice versa, and\n* swap two adjacent tiles (horizontally or vertically, but not diagonally), without flipping either.\n\nViewing Cody-Jamal's artistic floor is free, but interacting with it is not. Performing a single flip operation costs $\\mathbf{F}$ coins, and performing a single swap operation costs $\\mathbf{S}$ coins.\n\nYou can see the current state of the floor and want to turn it into a particular pattern. What is the minimum amount of coins you need to spend to achieve your goal?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains 4 integers: $\\mathbf{R}$, $\\mathbf{C}$, $\\mathbf{F}$ and $\\mathbf{S}$, the number of rows and columns of the floor, the cost in coins of flipping and the cost in coins of swapping, respectively. Then, $2 \\cdot \\mathbf{R}$ lines follow. The first $\\mathbf{R}$ lines contain $\\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines represents the current state of the tile in the $i$-th row and $j$-th column. The character is $\\mathsf{M}$ if the currently visible side is magenta and $\\mathsf{G}$ otherwise. The last $\\mathbf{R}$ lines also contain $\\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines represents the color you want for the tile in the $i$-th row and $j$-th column, using the same character code as for the current state.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum amount of coins you need to spend to perform operations that allow you to change the tile colors from their current state to your intended one.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 5 tiles that have a different color between the current and the desired states of the floor. Since each operation can change at most 2 tiles, at least 3 operations, costing 3 coins, are needed. One way to do it with exactly 3 coins is:\n\n1. Swap the leftmost two tiles in the top row.\n2. Swap the rightmost two tiles in the top row.\n3. Flip the bottom right corner tile.\n\nThe picture below illustrates the states the floor goes through. The highlighted tile or tiles in each state are the ones being changed by the operation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lnckx68s.png)\n\nIn Sample Case #2, there are 6 tiles that need changing. However, since only swaps can change two tiles at a time, solving it with 3 operations would require all of them to be swaps. There is no way to involve all 6 tiles in a single swap each, so we need at least 4 operations. One way to use exactly 4 operations is:\n\n1. Swap the topmost two tiles in the middle column.\n2. Flip the top right corner tile.\n3. Swap the bottommost two tiles in the rightmost column.\n4. Flip the middle tile of the leftmost column.\n\nThe picture below illustrates the states the floor goes through.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yholjw9b.png)\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nIn the Sample Case for Test Set 2, flips are so expensive that we want to avoid them at all costs. We need at least one since our desired floor state has more magenta tiles than the current one, and swaps do not change that amount. We can do it optimally with just one flip like this:\n\n1. Swap the leftmost two tiles.\n2. Flip the rightmost tile.\n3. Swap the second and third tiles from the left.\n4. Swap the third and fourth tiles from the left.\n\nThe picture below illustrates all the states the floor goes through.\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7c22w7hy.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{R} \\leq 10$.\n- $1 \\leq \\mathbf{C} \\leq 10$.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- $\\mathbf{F}=1$.\n- $\\mathbf{S}=1$.\n\n**Test Set 2 (23 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{F} \\leq 10^{6}$.\n- $1 \\leq \\mathbf{S} \\leq 10^{6}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #2] Retiling", "background": "", "description": "Cody-Jamal's latest artistic installment is a tiled kitchen floor that can be retiled to different patterns. The floor consists of a matrix of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns of square tiles. Each tile is reversible, one side is magenta and the other one is green.\n\nTo retile the kitchen, there are two allowed operations:\n\n* flip a tile, changing its visible color from magenta to green, or vice versa, and\n* swap two adjacent tiles (horizontally or vertically, but not diagonally), without flipping either.\n\nViewing Cody-Jamal's artistic floor is free, but interacting with it is not. Performing a single flip operation costs $\\mathbf{F}$ coins, and performing a single swap operation costs $\\mathbf{S}$ coins.\n\nYou can see the current state of the floor and want to turn it into a particular pattern. What is the minimum amount of coins you need to spend to achieve your goal?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains 4 integers: $\\mathbf{R}$, $\\mathbf{C}$, $\\mathbf{F}$ and $\\mathbf{S}$, the number of rows and columns of the floor, the cost in coins of flipping and the cost in coins of swapping, respectively. Then, $2 \\cdot \\mathbf{R}$ lines follow. The first $\\mathbf{R}$ lines contain $\\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines represents the current state of the tile in the $i$-th row and $j$-th column. The character is $\\mathsf{M}$ if the currently visible side is magenta and $\\mathsf{G}$ otherwise. The last $\\mathbf{R}$ lines also contain $\\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines represents the color you want for the tile in the $i$-th row and $j$-th column, using the same character code as for the current state.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum amount of coins you need to spend to perform operations that allow you to change the tile colors from their current state to your intended one.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 5 tiles that have a different color between the current and the desired states of the floor. Since each operation can change at most 2 tiles, at least 3 operations, costing 3 coins, are needed. One way to do it with exactly 3 coins is:\n\n1. Swap the leftmost two tiles in the top row.\n2. Swap the rightmost two tiles in the top row.\n3. Flip the bottom right corner tile.\n\nThe picture below illustrates the states the floor goes through. The highlighted tile or tiles in each state are the ones being changed by the operation.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lnckx68s.png)\n\nIn Sample Case #2, there are 6 tiles that need changing. However, since only swaps can change two tiles at a time, solving it with 3 operations would require all of them to be swaps. There is no way to involve all 6 tiles in a single swap each, so we need at least 4 operations. One way to use exactly 4 operations is:\n\n1. Swap the topmost two tiles in the middle column.\n2. Flip the top right corner tile.\n3. Swap the bottommost two tiles in the rightmost column.\n4. Flip the middle tile of the leftmost column.\n\nThe picture below illustrates the states the floor goes through.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yholjw9b.png)\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\nIn the Sample Case for Test Set 2, flips are so expensive that we want to avoid them at all costs. We need at least one since our desired floor state has more magenta tiles than the current one, and swaps do not change that amount. We can do it optimally with just one flip like this:\n\n1. Swap the leftmost two tiles.\n2. Flip the rightmost tile.\n3. Swap the second and third tiles from the left.\n4. Swap the third and fourth tiles from the left.\n\nThe picture below illustrates all the states the floor goes through.\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7c22w7hy.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{R} \\leq 10$.\n- $1 \\leq \\mathbf{C} \\leq 10$.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- $\\mathbf{F}=1$.\n- $\\mathbf{S}=1$.\n\n**Test Set 2 (23 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{F} \\leq 10^{6}$.\n- $1 \\leq \\mathbf{S} \\leq 10^{6}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #2] Retiling", "background": "", "description": "Cody-Jamal 最新的艺术装置是一个可以重新铺设不同图案的厨房瓷砖地面。地面由 $\\mathbf{R}$ 行 $\\mathbf{C}$ 列的正方形瓷砖组成。每块瓷砖都是双面的，一面是品红色（M），另一面是绿色（G）。\n\n要重新铺设厨房地面，允许进行以下两种操作：\n* **翻转**一块瓷砖，将其可见面从品红色变为绿色，或反之，每次操作花费 $\\mathbf{F}$ 枚硬币；\n* **交换**两块相邻的瓷砖（水平或垂直相邻，不包括对角线相邻），不翻转任何瓷砖，每次操作花费 $\\mathbf{S}$ 枚硬币。\n\n观看 Cody-Jamal 的艺术地面是免费的，但与之互动需要花费硬币。已知地面的当前状态和目标图案，求最少需要花费多少枚硬币才能将地面从当前状态转变为目标图案。", "inputFormat": "输入第一行包含测试用例数量 $\\mathbf{T}$。每个测试用例包含：\n1. 第一行四个整数 $\\mathbf{R}$、$\\mathbf{C}$、$\\mathbf{F}$、$\\mathbf{S}$，分别表示地面的行数、列数、翻转操作的花费和交换操作的花费；\n2. 接下来 $\\mathbf{R}$ 行，每行 $\\mathbf{C}$ 个字符，表示地面的当前状态（$\\mathsf{M}$ 表示品红色，$\\mathsf{G}$ 表示绿色）；\n3. 最后 $\\mathbf{R}$ 行，每行 $\\mathbf{C}$ 个字符，表示目标图案（字符编码与当前状态相同）。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是将地面转变为目标图案所需的最小硬币花费。\n", "hint": "**样例解释**\n\n在样例 #1 中：\n- 当前状态与目标图案有 5 处颜色不同；\n- 最少需要 3 次操作（每次操作最多改变 2 处颜色）；\n- 一种最优方案：\n  1. 交换第一行最左两块瓷砖；\n  2. 交换第一行最右两块瓷砖；\n  3. 翻转右下角瓷砖。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lnckx68s.png)\n\n在样例 #2 中：\n- 有 6 处颜色需要改变；\n- 由于只能通过交换同时改变两处颜色，最少需要 4 次操作；\n- 一种最优方案：\n  1. 交换中间列最上两块瓷砖；\n  2. 翻转右上角瓷砖；\n  3. 交换最右列最下两块瓷砖；\n  4. 翻转最左列中间瓷砖。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yholjw9b.png)\n\n测试集 2 的样例中：\n- 翻转操作非常昂贵，应尽量避免；\n- 由于目标图案比当前状态多 1 块品红色瓷砖，必须至少进行 1 次翻转；\n- 最优方案（花费 1003 枚硬币）：\n  1. 交换最左两块瓷砖；\n  2. 翻转最右瓷砖；\n  3. 交换左数第二和第三块瓷砖；\n  4. 交换左数第三和第四块瓷砖。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7c22w7hy.png)\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$；\n- $1 \\leq \\mathbf{R} \\leq 10$；\n- $1 \\leq \\mathbf{C} \\leq 10$。\n\n**测试集 1（11 分，可见判定）**\n\n- $\\mathbf{F}=1$；\n- $\\mathbf{S}=1$。\n\n**测试集 2（23 分，隐藏判定）**\n\n- $1 \\leq \\mathbf{F} \\leq 10^{6}$；\n- $1 \\leq \\mathbf{S} \\leq 10^{6}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13039", "type": "P", "difficulty": 4, "samples": [["4\n1234\n0011\n07080\n0899", "Case #1: 7\nCase #2: 0\nCase #3: 620\nCase #4: 1"]], "limits": {"time": [5000, 5000, 5000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "2021", "枚举", "分类讨论", "Google Code Jam"], "title": "[GCJ 2021 #3] Build-A-Pair", "background": "", "description": "You want to build a pair of positive integers. To do that, you are given a list of decimal digits to use. You must use every digit in the list exactly once, but you get to choose which ones to use for the first integer and which ones to use for the second integer. You also get to choose the order of the digits within each integer, except you cannot put a zero as the most significant (leftmost) digit in either integer. Note that you cannot choose just a zero for one integer either, because it would not be positive.\n\nFor example, you could be given the list $[1, 0, 2, 0, 4, 3]$. Two of the valid pairs you can build are $(200, 143)$ and $(3, 12400)$. The following pairs, on the other hand, are not valid:\n\n* $(0102, 34)$: has a leading zero.\n* $(0, 12340)$: has a non-positive integer.\n* $(10, 243)$ and $(12300, 47)$: the list of digits in each of these pairs is not exactly equal to the given list of digits.\n\nGiven the list of digits to use, what is the minimum absolute difference between the two built integers that can be achieved?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line describes a test case with a single string of digits $\\mathbf{D}$. Each character of $\\mathbf{D}$ is a digit you must use.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum possible absolute difference between the two integers built from $\\mathbf{D}$ according to the rules above.", "hint": "**Sample Explanation**\n\nThe optimal pair of integers to build are $31$ and $24$ for Sample Case #1, $10$ and $10$ for Sample Case #2, $700$ and $80$ for Sample Case #3, and $89$ and $90$ for Sample Case #4.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{D}$ is a decimal digit.\n- At least two characters of $\\mathbf{D}$ are not $\\emptyset$.\n\n**Test Set 1 (3 Pts, Visible Verdict)**\n\n- $2 \\leq$ the length of $\\mathbf{D} \\leq 8$.\n\n**Test Set 2 (12 Pts, Visible Verdict)**\n\n- $2 \\leq$ the length of $\\mathbf{D} \\leq 36$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #3] Build-A-Pair", "background": "", "description": "You want to build a pair of positive integers. To do that, you are given a list of decimal digits to use. You must use every digit in the list exactly once, but you get to choose which ones to use for the first integer and which ones to use for the second integer. You also get to choose the order of the digits within each integer, except you cannot put a zero as the most significant (leftmost) digit in either integer. Note that you cannot choose just a zero for one integer either, because it would not be positive.\n\nFor example, you could be given the list $[1, 0, 2, 0, 4, 3]$. Two of the valid pairs you can build are $(200, 143)$ and $(3, 12400)$. The following pairs, on the other hand, are not valid:\n\n* $(0102, 34)$: has a leading zero.\n* $(0, 12340)$: has a non-positive integer.\n* $(10, 243)$ and $(12300, 47)$: the list of digits in each of these pairs is not exactly equal to the given list of digits.\n\nGiven the list of digits to use, what is the minimum absolute difference between the two built integers that can be achieved?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line describes a test case with a single string of digits $\\mathbf{D}$. Each character of $\\mathbf{D}$ is a digit you must use.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum possible absolute difference between the two integers built from $\\mathbf{D}$ according to the rules above.", "hint": "**Sample Explanation**\n\nThe optimal pair of integers to build are $31$ and $24$ for Sample Case #1, $10$ and $10$ for Sample Case #2, $700$ and $80$ for Sample Case #3, and $89$ and $90$ for Sample Case #4.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- Each character of $\\mathbf{D}$ is a decimal digit.\n- At least two characters of $\\mathbf{D}$ are not $\\emptyset$.\n\n**Test Set 1 (3 Pts, Visible Verdict)**\n\n- $2 \\leq$ the length of $\\mathbf{D} \\leq 8$.\n\n**Test Set 2 (12 Pts, Visible Verdict)**\n\n- $2 \\leq$ the length of $\\mathbf{D} \\leq 36$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #3] Build-A-Pair", "background": "", "description": "你需要构造一对正整数。为此，你会获得一个十进制数字列表作为可用数字。你必须**恰好使用列表中的每个数字一次**，但可以自由选择哪些数字用于第一个整数，哪些数字用于第二个整数。同时，你可以自由决定每个整数内部数字的排列顺序，但**不允许在任何整数的最高位（最左侧）放置零**。请注意，你也不能选择仅包含一个零的整数，因为它不是正整数。\n\n例如，给定数字列表 $[1, 0, 2, 0, 4, 3]$。你可以构造的有效数字对包括 $(200, 143)$ 和 $(3, 12400)$。而以下数字对则是**无效的**：\n\n* $(0102, 34)$：存在前导零。\n* $(0, 12340)$：包含非正整数。\n* $(10, 243)$ 和 $(12300, 47)$：这些数字对中使用的数字列表与给定列表不完全一致。\n\n给定数字列表，如何构造一对数字，使得它们的绝对差最小？", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 行，每行描述一个测试用例，包含一个数字字符串 $\\mathbf{D}$。$\\mathbf{D}$ 的每个字符都是你必须使用的数字。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是根据上述规则从 $\\mathbf{D}$ 构造的两个整数的**最小可能绝对差**。\n", "hint": "**样例解释**\n\n最优构造的数字对为：\n- 样例 #1：$31$ 和 $24$；\n- 样例 #2：$10$ 和 $10$；\n- 样例 #3：$700$ 和 $80$；\n- 样例 #4：$89$ 和 $90$。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $\\mathbf{D}$ 的每个字符均为十进制数字。\n- $\\mathbf{D}$ 中至少有两个字符不为 $\\emptyset$。\n\n**测试集 1（3 分，可见判定）**\n\n- $2 \\leq \\mathbf{D}$ 的长度 $\\leq 8$。\n\n**测试集 2（12 分，可见判定）**\n\n- $2 \\leq \\mathbf{D}$ 的长度 $\\leq 36$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13040", "type": "P", "difficulty": 6, "samples": [["4\n4 4\n3 2 3 3\n3 3 2 3\n2 3\n1 1\n1 1 1\n2 3\n1 2\n1 1 1\n3 3\n2 0 2\n2 0 2", "Case #1: POSSIBLE\n//\\/\n\\/\\/\n///\\\n/\\//\nCase #2: IMPOSSIBLE\nCase #3: POSSIBLE\n\\\\/\n//\\\nCase #4: POSSIBLE\n/\\/\n\\\\\\\n/\\/"]], "limits": {"time": [15000, 15000, 15000], "memory": [1048576, 1048576, 1048576]}, "tags": ["图论", "2021", "Special Judge", "费用流", "Google Code Jam"], "title": "[GCJ 2021 #3] Square Free", "background": "", "description": "We have a matrix of square cells with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. We need to draw a diagonal in each cell. Exactly one of two possible diagonals must be drawn in each cell: the forward slash diagonal, which connects the bottom-left and the top-right corners of the cell, or the backslash diagonal, which connects the top-left and the bottom-right corners of the cell.\n\nFor each row and column, we want to draw a specific number of diagonals of each type. Also, after all the diagonals are drawn, the matrix should be square free. That is, there should be no squares formed using the diagonals we added.\n\nFor example, suppose we have a matrix with 4 rows and 4 columns. The number next to each row is the exact number of forward slash diagonals there must be in that row. The number below each column is the exact number of forward slash diagonals there must be in that column.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xc6yu1qy.png)\n\nThere are multiple ways to fill the matrix respecting those per-row and per-column amounts. Below we depict three possibilities:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1gul8pxa.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/xip3jkqs.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/o3qbkh80.png)\n\nThe first two matrices are not square free, while the third matrix is. In the first matrix, there is a square of side-length 2 diagonals with its vertices in the middle of each side of the matrix. In the second matrix, there is a square of side-length 1 diagonal drawn in the bottom-right corner. In the third matrix, there is no square. The third matrix would then be a valid drawing according to all the rules.\n\nGiven the size of the matrix and the exact number of forward slash diagonals that must be drawn in each row and column, produce any square free matrix that satisfies the row and column constraints, or say that one does not exist.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of exactly three lines. The first line of a test case contains $\\mathbf{R}$ and $\\mathbf{C}$, the number of rows and columns of the matrix. The second line of a test case contains $\\mathbf{R}$ integers $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{R}$. $\\mathbf{S}_i$ is the exact number of forward slash diagonals that must be drawn in the $i$-th row from the top. The third line of a test case contains $\\mathbf{C}$ integers $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{C}$. $\\mathbf{D}_i$ is the exact number of forward slash diagonals that must be drawn in the $i$-th column from the left.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `IMPOSSIBLE` if there is no filled matrix that follows all rules and `POSSIBLE` otherwise. If you output `POSSIBLE`, output $\\mathbf{R}$ more lines with $\\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines must be `/` if the diagonal drawn in the $i$-th row from the top and $j$-th column from the left in your proposed matrix is a forward slash diagonal, and `\\` otherwise. Your proposed matrix must be valid according to all rules.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained above.\n\nIn Sample Case #2, there must be a total of 2 forward slash diagonals according to the sum of the row totals, but a total of 3 according to the sum of the column totals. It is therefore impossible to follow all rules.\n\nIn Sample Case #3 the only matrices that follow the row and column totals are the following:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qrbza4hc.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/439fpaug.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/ib6vqil8.png)\n\nSince the first two contain a square, the third one is the only valid output for this case.\n\nIn Sample Case #4 there is only one way to fill the matrix that follows the row and column totals, shown in the picture below. Note that it produces a single rectangle, shown in blue in the picture. But, since that rectangle is not a square, the matrix is square free.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ljxlouhx.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{S}_i \\leq \\mathbf{C}$, for all $i$.\n- $0 \\leq \\mathbf{D}_i \\leq \\mathbf{R}$, for all $i$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{R} \\leq 6$.\n- $2 \\leq \\mathbf{C} \\leq 6$.\n\n**Test Set 2 (13 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{R} \\leq 20$.\n- $2 \\leq \\mathbf{C} \\leq 20$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #3] Square Free", "background": "", "description": "We have a matrix of square cells with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. We need to draw a diagonal in each cell. Exactly one of two possible diagonals must be drawn in each cell: the forward slash diagonal, which connects the bottom-left and the top-right corners of the cell, or the backslash diagonal, which connects the top-left and the bottom-right corners of the cell.\n\nFor each row and column, we want to draw a specific number of diagonals of each type. Also, after all the diagonals are drawn, the matrix should be square free. That is, there should be no squares formed using the diagonals we added.\n\nFor example, suppose we have a matrix with 4 rows and 4 columns. The number next to each row is the exact number of forward slash diagonals there must be in that row. The number below each column is the exact number of forward slash diagonals there must be in that column.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xc6yu1qy.png)\n\nThere are multiple ways to fill the matrix respecting those per-row and per-column amounts. Below we depict three possibilities:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1gul8pxa.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/xip3jkqs.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/o3qbkh80.png)\n\nThe first two matrices are not square free, while the third matrix is. In the first matrix, there is a square of side-length 2 diagonals with its vertices in the middle of each side of the matrix. In the second matrix, there is a square of side-length 1 diagonal drawn in the bottom-right corner. In the third matrix, there is no square. The third matrix would then be a valid drawing according to all the rules.\n\nGiven the size of the matrix and the exact number of forward slash diagonals that must be drawn in each row and column, produce any square free matrix that satisfies the row and column constraints, or say that one does not exist.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of exactly three lines. The first line of a test case contains $\\mathbf{R}$ and $\\mathbf{C}$, the number of rows and columns of the matrix. The second line of a test case contains $\\mathbf{R}$ integers $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{R}$. $\\mathbf{S}_i$ is the exact number of forward slash diagonals that must be drawn in the $i$-th row from the top. The third line of a test case contains $\\mathbf{C}$ integers $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{C}$. $\\mathbf{D}_i$ is the exact number of forward slash diagonals that must be drawn in the $i$-th column from the left.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `IMPOSSIBLE` if there is no filled matrix that follows all rules and `POSSIBLE` otherwise. If you output `POSSIBLE`, output $\\mathbf{R}$ more lines with $\\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines must be `/` if the diagonal drawn in the $i$-th row from the top and $j$-th column from the left in your proposed matrix is a forward slash diagonal, and `\\` otherwise. Your proposed matrix must be valid according to all rules.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained above.\n\nIn Sample Case #2, there must be a total of 2 forward slash diagonals according to the sum of the row totals, but a total of 3 according to the sum of the column totals. It is therefore impossible to follow all rules.\n\nIn Sample Case #3 the only matrices that follow the row and column totals are the following:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qrbza4hc.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/439fpaug.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/ib6vqil8.png)\n\nSince the first two contain a square, the third one is the only valid output for this case.\n\nIn Sample Case #4 there is only one way to fill the matrix that follows the row and column totals, shown in the picture below. Note that it produces a single rectangle, shown in blue in the picture. But, since that rectangle is not a square, the matrix is square free.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ljxlouhx.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{S}_i \\leq \\mathbf{C}$, for all $i$.\n- $0 \\leq \\mathbf{D}_i \\leq \\mathbf{R}$, for all $i$.\n\n**Test Set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{R} \\leq 6$.\n- $2 \\leq \\mathbf{C} \\leq 6$.\n\n**Test Set 2 (13 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{R} \\leq 20$.\n- $2 \\leq \\mathbf{C} \\leq 20$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #3] Square Free", "background": "", "description": "我们有一个由正方形单元格组成的矩阵，包含 $\\mathbf{R}$ 行和 $\\mathbf{C}$ 列。我们需要在每个单元格中绘制一条对角线。每个单元格必须且只能绘制两种对角线之一：**正斜杠对角线（/）**（连接单元格的左下角和右上角）或 **反斜杠对角线（\\）**（连接单元格的左上角和右下角）。\n\n对于每一行和每一列，我们需要绘制特定数量的正斜杠对角线。此外，在所有对角线绘制完成后，矩阵必须满足**无方格**条件。即，不能存在由所绘制的对角线构成的正方形。\n\n例如，假设我们有一个 4 行 4 列的矩阵。每行旁边的数字表示该行必须绘制的正斜杠对角线的确切数量，每列下方的数字表示该列必须绘制的正斜杠对角线的确切数量。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xc6yu1qy.png)\n\n存在多种方式填充该矩阵以满足每行和每列的要求。以下是三种可能的填充方式：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1gul8pxa.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/xip3jkqs.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/o3qbkh80.png)\n\n前两个矩阵**不满足无方格条件**，而第三个矩阵满足。在第一个矩阵中，存在一个边长为 2 的对角线组成的正方形，其顶点位于矩阵各边的中点；在第二个矩阵中，右下角存在一个边长为 1 的对角线组成的正方形；第三个矩阵则不存在任何此类正方形。因此，第三个矩阵是符合所有规则的合法填充方案。\n\n给定矩阵的大小以及每行和每列必须绘制的正斜杠对角线的数量，请构造一个满足行和列约束的无方格矩阵，或者判断这样的矩阵不存在。\n", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 组测试用例。每组测试用例包含三行：\n1. 第一行包含 $\\mathbf{R}$ 和 $\\mathbf{C}$，分别表示矩阵的行数和列数。\n2. 第二行包含 $\\mathbf{R}$ 个整数 $\\mathbf{S}_1, \\mathbf{S}_2, \\ldots, \\mathbf{S}_\\mathbf{R}$，其中 $\\mathbf{S}_i$ 表示第 $i$ 行（从上到下）必须绘制的正斜杠对角线的数量。\n3. 第三行包含 $\\mathbf{C}$ 个整数 $\\mathbf{D}_1, \\mathbf{D}_2, \\ldots, \\mathbf{D}_\\mathbf{C}$，其中 $\\mathbf{D}_i$ 表示第 $i$ 列（从左到右）必须绘制的正斜杠对角线的数量。\n", "outputFormat": "对于每组测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 为 `IMPOSSIBLE`（如果不存在满足所有规则的矩阵）或 `POSSIBLE`（如果存在）。如果输出 `POSSIBLE`，则还需额外输出 $\\mathbf{R}$ 行，每行包含 $\\mathbf{C}$ 个字符。其中第 $i$ 行的第 $j$ 个字符为 `/`（表示该单元格绘制正斜杠对角线）或 `\\`（表示绘制反斜杠对角线）。你的方案必须满足所有规则。\n", "hint": "**样例解释**\n\n样例 #1 是题目描述中提到的示例。\n\n在样例 #2 中，根据行的总和，需要绘制 2 条正斜杠对角线，但根据列的总和，需要绘制 3 条。因此无法满足所有规则。\n\n样例 #3 中唯一满足行和列约束的矩阵如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qrbza4hc.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/439fpaug.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/ib6vqil8.png)\n\n由于前两个矩阵包含正方形，第三个矩阵是唯一合法的输出。\n\n在样例 #4 中，只有一种填充方式满足行和列约束（如下图所示）。注意，它产生了一个矩形（图中蓝色部分），但由于该矩形不是正方形，因此矩阵满足无方格条件。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ljxlouhx.png)\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i$，$0 \\leq \\mathbf{S}_i \\leq \\mathbf{C}$。\n- 对于所有 $i$，$0 \\leq \\mathbf{D}_i \\leq \\mathbf{R}$。\n\n**测试集 1（7 分，可见判定）**\n\n- $2 \\leq \\mathbf{R} \\leq 6$。\n- $2 \\leq \\mathbf{C} \\leq 6$。\n\n**测试集 2（13 分，隐藏判定）**\n\n- $2 \\leq \\mathbf{R} \\leq 20$。\n- $2 \\leq \\mathbf{C} \\leq 20$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13041", "type": "P", "difficulty": 7, "samples": [["2\n4\n0 0\n0 1\n1 1\n1 0\n1 2\n3 4\n5\n0 0\n0 1\n1 1\n1 0\n2 3\n1 2\n3 5", "Case #1: 3\n1 4\n2 3\n4 2\nCase #2: 6\n5 4\n2 4\n5 2\n1 4\n4 3\n3 2"]], "limits": {"time": [60000, 60000, 90000], "memory": [1048576, 1048576, 1048576]}, "tags": ["计算几何", "2021", "Special Judge", "分治", "凸包", "Google Code Jam"], "title": "[GCJ 2021 #3] Fence Design", "background": "", "description": "You are hired as a temporary employee of the Fence Construction Company and have been tasked with finishing the design of the fencing for a field. Each fence must run in a straight line between two poles. Each pole occupies a single point and the location of each pole is fixed. No three poles are collinear. Fences cannot intersect each other, except possibly at their endpoints (the poles).\n\nThe design was started by someone else, but they quit the project after adding exactly two fences. You need to finish their design. To impress your bosses and clients, you want the design to have as many fences as possible, regardless of their lengths.\n\nGiven the positions of the poles and the already-built fences, please find a way to add as many fences as possible such that no pair of fences (new or existing) intersect each other, except possibly at their endpoints (the poles).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a single line containing an integer $\\mathbf{N}$, indicating the number of poles. Then, $\\mathbf{N}$ lines follow. The $i$-th of these lines contains two integers $\\mathbf{X}_i$ and $\\mathbf{Y}_i$, representing the X and Y coordinates of the $i$-th pole's position. The last two lines for each test case represent the two existing fences. These two lines contain two integers each: $\\mathbf{P}_k$ and $\\mathbf{Q}_k$, representing that the $k$-th existing fence runs between the $\\mathbf{P}_k$-th and the $\\mathbf{Q}_k$-th pole (poles are numbered starting from 1).\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of fences that can be added to the design (not including the existing ones). Then, output $y$ more lines. Each line must contain two distinct integers $i$ and $j$ (both between 1 and $\\mathbf{N}$, inclusive), representing a different fence that connects the $i$-th and $j$-th poles. No pair of the $y + 2$ fences (the existing fences as well as the ones you have added) may overlap, except possibly at their endpoints.", "hint": "**Sample Explanation**\n\nThe following pictures show the poles and fences in the given samples. The fences with the wider blue line on them are the existing ones, and the rest show the way of adding a maximum number of fences shown in the sample output.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j0yr6b9n.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/is24xybt.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 50$.\n- $-10^9 \\leq \\mathbf{X}_i \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y}_i \\leq 10^9$, for all $i$.\n- $(\\mathbf{X}_i, \\mathbf{Y}_i) \\neq (\\mathbf{X}_j, \\mathbf{Y}_j)$, for all $i \\neq j$.\n- $1 \\leq \\mathbf{P}_k < \\mathbf{Q}_k \\leq \\mathbf{N}$, for all $k$.\n- The existing fences do not intersect, except possibly at their endpoints.\n- No three poles are collinear.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- Time limit: 60 seconds.\n- $4 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 2 (19 Pts, Hidden Verdict)**\n\n- Time limit: 90 seconds.\n- $4 \\leq \\mathbf{N} \\leq 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #3] Fence Design", "background": "", "description": "You are hired as a temporary employee of the Fence Construction Company and have been tasked with finishing the design of the fencing for a field. Each fence must run in a straight line between two poles. Each pole occupies a single point and the location of each pole is fixed. No three poles are collinear. Fences cannot intersect each other, except possibly at their endpoints (the poles).\n\nThe design was started by someone else, but they quit the project after adding exactly two fences. You need to finish their design. To impress your bosses and clients, you want the design to have as many fences as possible, regardless of their lengths.\n\nGiven the positions of the poles and the already-built fences, please find a way to add as many fences as possible such that no pair of fences (new or existing) intersect each other, except possibly at their endpoints (the poles).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a single line containing an integer $\\mathbf{N}$, indicating the number of poles. Then, $\\mathbf{N}$ lines follow. The $i$-th of these lines contains two integers $\\mathbf{X}_i$ and $\\mathbf{Y}_i$, representing the X and Y coordinates of the $i$-th pole's position. The last two lines for each test case represent the two existing fences. These two lines contain two integers each: $\\mathbf{P}_k$ and $\\mathbf{Q}_k$, representing that the $k$-th existing fence runs between the $\\mathbf{P}_k$-th and the $\\mathbf{Q}_k$-th pole (poles are numbered starting from 1).\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of fences that can be added to the design (not including the existing ones). Then, output $y$ more lines. Each line must contain two distinct integers $i$ and $j$ (both between 1 and $\\mathbf{N}$, inclusive), representing a different fence that connects the $i$-th and $j$-th poles. No pair of the $y + 2$ fences (the existing fences as well as the ones you have added) may overlap, except possibly at their endpoints.", "hint": "**Sample Explanation**\n\nThe following pictures show the poles and fences in the given samples. The fences with the wider blue line on them are the existing ones, and the rest show the way of adding a maximum number of fences shown in the sample output.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j0yr6b9n.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/is24xybt.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 50$.\n- $-10^9 \\leq \\mathbf{X}_i \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y}_i \\leq 10^9$, for all $i$.\n- $(\\mathbf{X}_i, \\mathbf{Y}_i) \\neq (\\mathbf{X}_j, \\mathbf{Y}_j)$, for all $i \\neq j$.\n- $1 \\leq \\mathbf{P}_k < \\mathbf{Q}_k \\leq \\mathbf{N}$, for all $k$.\n- The existing fences do not intersect, except possibly at their endpoints.\n- No three poles are collinear.\n\n**Test Set 1 (11 Pts, Visible Verdict)**\n\n- Time limit: 60 seconds.\n- $4 \\leq \\mathbf{N} \\leq 100$.\n\n**Test Set 2 (19 Pts, Hidden Verdict)**\n\n- Time limit: 90 seconds.\n- $4 \\leq \\mathbf{N} \\leq 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #3] Fence Design", "background": "", "description": "你被临时雇佣为围栏建设公司的员工，负责完成一块场地的围栏设计工作。每条围栏必须沿着直线连接两根立柱。每根立柱占据一个固定点，且**任意三根立柱不共线**。围栏之间**不能相互交叉**，但可以在端点（立柱位置）处相连。\n\n前员工在项目中已经铺设了两条围栏后就离职了。现在需要由你来完成剩余设计。为了让老板和客户满意，你希望在不考虑围栏长度的情况下，尽可能多地添加围栏。\n\n给定所有立柱的位置和已建好的两条围栏，请找出可以添加的**最大数量**的围栏，使得所有围栏（包括已有的和新增的）两两之间不交叉（仅在端点处相连是允许的）。", "inputFormat": "输入的第一行包含测试用例数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 组测试用例：\n1. 每组测试用例的第一行是一个整数 $\\mathbf{N}$，表示立柱数量。\n2. 接下来 $\\mathbf{N}$ 行，每行包含两个整数 $\\mathbf{X}_i$ 和 $\\mathbf{Y}_i$，表示第 $i$ 根立柱的坐标。\n3. 最后两行分别描述已有的两条围栏，每行包含两个整数 $\\mathbf{P}_k$ 和 $\\mathbf{Q}_k$，表示第 $k$ 条围栏连接第 $\\mathbf{P}_k$ 根和第 $\\mathbf{Q}_k$ 根立柱（立柱编号从 1 开始）。\n", "outputFormat": "对于每组测试用例：\n1. 首先输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是能添加的围栏最大数量（不包括已有围栏）。\n2. 接着输出 $y$ 行，每行包含两个不同的整数 $i$ 和 $j$（$1 \\leq i, j \\leq \\mathbf{N}$），表示新增的围栏连接第 $i$ 根和第 $j$ 根立柱。\n3. 所有围栏（包括已有的和新增的）必须满足两两不交叉（仅在端点处允许相连）。", "hint": "**样例解释**\n\n下图展示了样例中的立柱和围栏布局。蓝色加粗线条表示已有围栏，其余线条表示样例输出中添加的围栏方案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j0yr6b9n.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/is24xybt.png)\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 50$。\n- 对所有 $i$，$-10^9 \\leq \\mathbf{X}_i, \\mathbf{Y}_i \\leq 10^9$。\n- 对所有 $i \\neq j$，$(\\mathbf{X}_i, \\mathbf{Y}_i) \\neq (\\mathbf{X}_j, \\mathbf{Y}_j)$。\n- 对所有 $k$，$1 \\leq \\mathbf{P}_k < \\mathbf{Q}_k \\leq \\mathbf{N}$。\n- 已有围栏之间不交叉（仅在端点处允许相连）。\n- 任意三根立柱不共线。\n\n**测试集 1（11 分，可见判定）**\n\n- 时间限制：60 秒。\n- $4 \\leq \\mathbf{N} \\leq 100$。\n\n**测试集 2（19 分，隐藏判定）**\n\n- 时间限制：90 秒。\n- $4 \\leq \\mathbf{N} \\leq 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13042", "type": "P", "difficulty": 7, "samples": [["3\n2 2 2\n2 1 1 1\n4 3 2\n3 1 1 4\n5 100 3\n2 4 1 1 4 5 2 5", "Case #1: 6\nCase #2: 144\nCase #3: 991661422"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2021", "多项式", "组合数学", "拉格朗日插值法", "Google Code Jam"], "title": "[GCJ 2021 #3] Binary Search Game", "background": "", "description": "Alice and Bob are going to play the Binary Search game. The game is played on a board consisting of a single row of $2^{\\mathbf{L}}$ cells. Each cell contains an integer between 1 and $\\mathbf{N}$, inclusive. There are also $\\mathbf{N}$ cards numbered 1 through $\\mathbf{N}$. Before the game starts, the referee writes an integer between 1 and $\\mathbf{M}$, inclusive, on each card, in one of the $\\mathbf{M}^{\\mathbf{N}}$ ways in which that can be done. Alice and Bob know the integers in the cells and on each card before they start playing.\n\nThe game proceeds alternating turns, with Alice having the first turn. There are $\\mathbf{L}$ turns in total, which means Alice plays $\\lceil \\mathbf{L}/2 \\rceil$ turns and Bob plays $\\lfloor \\mathbf{L}/2 \\rfloor$ turns. During a turn, a player can eliminate either the leftmost half or the rightmost half of the remaining cells. For example, let us consider a board that contains the numbers $[2, 4, 1, 1, 4, 5, 2, 5]$. In her first turn, Alice must choose to eliminate one half, leaving either $[2, 4, 1, 1]$ or $[4, 5, 2, 5]$. If she eliminates the leftmost half and leaves $[4, 5, 2, 5]$, then Bob must choose between leaving $[4, 5]$ and $[2, 5]$. If he were to leave $[2, 5]$, the game's final turn would have Alice choosing between $[2]$ and $[5]$.\n\nWhen the game is over, they look at the number $X$ in the only remaining cell. The score of the game is the integer written on card number $X$. In the example above, if Alice were to eliminate $[5]$ and leave $[2]$ in her final turn, the score of the game would be the number the referee wrote on card number 2.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l71ofi6o.png)\n\nAlice plays optimally to maximize the score of the game, while Bob plays optimally to minimize it. They are given a fixed board with integers $\\mathbf{A}_1$, $\\mathbf{A}_2$, …, $\\mathbf{A}_{2^{\\mathbf{L}}}$ in its cells. For maximal fairness, they will play $\\mathbf{M}^{\\mathbf{N}}$ games, and the referee will choose a different way to write integers on the cards for each one. That means that for any given way of writing integers on the cards, Alice and Bob will play exactly one game with it. Given the game parameters and the fixed board contents, please determine the sum of the scores of all those games. Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^9 + 7$ ($1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of exactly two lines. The first line of each test case contains the three integers $\\mathbf{N}$, $\\mathbf{M}$, and $\\mathbf{L}$. The second line contains $2^{\\mathbf{L}}$ integers $\\mathbf{A}_1$, $\\mathbf{A}_2$, …, $\\mathbf{A}_{2^{\\mathbf{L}}}$, where $\\mathbf{A}_i$ is the integer contained in the $i$-th cell from the left of the board.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the sum of scores of all $\\mathbf{M}^{\\mathbf{N}}$ games, modulo the prime $10^9 + 7$ ($1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 4 ways to write the integers on the blank cards: $[1, 1], [1, 2], [2, 1]$, and $[2, 2]$. In the first two ways, no matter what Alice chooses in her first turn, Bob can always make the number in the last remaining cell be a 1, and card 1 contains a 1, which means those two games have a score of 1. In the last two ways, Alice can start by eliminating the leftmost half of the board, leaving $[1, 1]$ for Bob, who then has no choice but to leave $[1]$ at the end. Since card 1 has a 2 on it in these ways, the score of both of these games is 2. The sum of all scores is therefore $1 + 1 + 2 + 2 = 6$.\n\n**Limits**\n\n- $1 \\leq \\text{T} \\leq 12$.\n- $1 \\leq \\text{L} \\leq 5$.\n- $1 \\leq \\text{A}_i \\leq \\text{N}$, for all $i$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $1 \\leq \\text{N} \\leq 8$.\n- $1 \\leq \\text{M} \\leq 100$.\n\n**Test Set 2 (26 Pts, Hidden Verdict)**\n\n- $1 \\leq \\text{N} \\leq 32$.\n- $1 \\leq \\text{M} \\leq 10^9$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 #3] Binary Search Game", "background": "", "description": "Alice and Bob are going to play the Binary Search game. The game is played on a board consisting of a single row of $2^{\\mathbf{L}}$ cells. Each cell contains an integer between 1 and $\\mathbf{N}$, inclusive. There are also $\\mathbf{N}$ cards numbered 1 through $\\mathbf{N}$. Before the game starts, the referee writes an integer between 1 and $\\mathbf{M}$, inclusive, on each card, in one of the $\\mathbf{M}^{\\mathbf{N}}$ ways in which that can be done. Alice and Bob know the integers in the cells and on each card before they start playing.\n\nThe game proceeds alternating turns, with Alice having the first turn. There are $\\mathbf{L}$ turns in total, which means Alice plays $\\lceil \\mathbf{L}/2 \\rceil$ turns and Bob plays $\\lfloor \\mathbf{L}/2 \\rfloor$ turns. During a turn, a player can eliminate either the leftmost half or the rightmost half of the remaining cells. For example, let us consider a board that contains the numbers $[2, 4, 1, 1, 4, 5, 2, 5]$. In her first turn, Alice must choose to eliminate one half, leaving either $[2, 4, 1, 1]$ or $[4, 5, 2, 5]$. If she eliminates the leftmost half and leaves $[4, 5, 2, 5]$, then Bob must choose between leaving $[4, 5]$ and $[2, 5]$. If he were to leave $[2, 5]$, the game's final turn would have Alice choosing between $[2]$ and $[5]$.\n\nWhen the game is over, they look at the number $X$ in the only remaining cell. The score of the game is the integer written on card number $X$. In the example above, if Alice were to eliminate $[5]$ and leave $[2]$ in her final turn, the score of the game would be the number the referee wrote on card number 2.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l71ofi6o.png)\n\nAlice plays optimally to maximize the score of the game, while Bob plays optimally to minimize it. They are given a fixed board with integers $\\mathbf{A}_1$, $\\mathbf{A}_2$, …, $\\mathbf{A}_{2^{\\mathbf{L}}}$ in its cells. For maximal fairness, they will play $\\mathbf{M}^{\\mathbf{N}}$ games, and the referee will choose a different way to write integers on the cards for each one. That means that for any given way of writing integers on the cards, Alice and Bob will play exactly one game with it. Given the game parameters and the fixed board contents, please determine the sum of the scores of all those games. Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^9 + 7$ ($1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of exactly two lines. The first line of each test case contains the three integers $\\mathbf{N}$, $\\mathbf{M}$, and $\\mathbf{L}$. The second line contains $2^{\\mathbf{L}}$ integers $\\mathbf{A}_1$, $\\mathbf{A}_2$, …, $\\mathbf{A}_{2^{\\mathbf{L}}}$, where $\\mathbf{A}_i$ is the integer contained in the $i$-th cell from the left of the board.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the sum of scores of all $\\mathbf{M}^{\\mathbf{N}}$ games, modulo the prime $10^9 + 7$ ($1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are 4 ways to write the integers on the blank cards: $[1, 1], [1, 2], [2, 1]$, and $[2, 2]$. In the first two ways, no matter what Alice chooses in her first turn, Bob can always make the number in the last remaining cell be a 1, and card 1 contains a 1, which means those two games have a score of 1. In the last two ways, Alice can start by eliminating the leftmost half of the board, leaving $[1, 1]$ for Bob, who then has no choice but to leave $[1]$ at the end. Since card 1 has a 2 on it in these ways, the score of both of these games is 2. The sum of all scores is therefore $1 + 1 + 2 + 2 = 6$.\n\n**Limits**\n\n- $1 \\leq \\text{T} \\leq 12$.\n- $1 \\leq \\text{L} \\leq 5$.\n- $1 \\leq \\text{A}_i \\leq \\text{N}$, for all $i$.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $1 \\leq \\text{N} \\leq 8$.\n- $1 \\leq \\text{M} \\leq 100$.\n\n**Test Set 2 (26 Pts, Hidden Verdict)**\n\n- $1 \\leq \\text{N} \\leq 32$.\n- $1 \\leq \\text{M} \\leq 10^9$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 #3] Binary Search Game", "background": "", "description": "**Alice** 和 **Bob** 将要玩一个名为二分搜索的游戏。游戏在一个由 $2^{\\mathbf{L}}$ 个格子组成的单行棋盘上进行。每个格子中包含一个介于 1 到 $\\mathbf{N}$ 之间的整数（包括 1 和 $\\mathbf{N}$）。此外，还有编号为 1 到 $\\mathbf{N}$ 的 $\\mathbf{N}$ 张卡片。在游戏开始前，裁判会以 $\\mathbf{M}^{\\mathbf{N}}$ 种可能的分配方式之一，在每张卡片上写下一个介于 1 到 $\\mathbf{M}$ 之间的整数（包括 1 和 $\\mathbf{M}$）。**Alice** 和 **Bob** 在游戏开始前知道棋盘上每个格子的整数以及每张卡片上的数字。\n\n游戏以轮流进行的方式展开，**Alice** 先手。总共有 $\\mathbf{L}$ 轮，这意味着 **Alice** 会进行 $\\lceil \\mathbf{L}/2 \\rceil$ 轮，而 **Bob** 会进行 $\\lfloor \\mathbf{L}/2 \\rfloor$ 轮。在每一轮中，玩家可以选择消除剩余格子中最左侧的一半或最右侧的一半。例如，假设棋盘上的数字为 $[2, 4, 1, 1, 4, 5, 2, 5]$。在 **Alice** 的第一轮中，她必须选择消除其中一半，留下 $[2, 4, 1, 1]$ 或 $[4, 5, 2, 5]$。如果她选择消除最左侧的一半并留下 $[4, 5, 2, 5]$，那么 **Bob** 必须在下一轮中选择留下 $[4, 5]$ 或 $[2, 5]$。如果他选择留下 $[2, 5]$，那么在最后一轮中，**Alice** 将需要在 $[2]$ 和 $[5]$ 之间做出选择。\n\n游戏结束时，他们查看唯一剩下的格子中的数字 $X$。游戏的分数就是编号为 $X$ 的卡片上所写的整数。在上述例子中，如果 **Alice** 在最后一轮中消除 $[5]$ 并留下 $[2]$，那么游戏的分数就是裁判在编号为 2 的卡片上写的数字。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/l71ofi6o.png)\n\n**Alice** 会采取最优策略以最大化游戏分数，而 **Bob** 则会采取最优策略以最小化分数。他们在一个固定的棋盘上进行游戏，棋盘上的格子中分别写着整数 $\\mathbf{A}_1$, $\\mathbf{A}_2$, …, $\\mathbf{A}_{2^{\\mathbf{L}}}$。为了确保最大限度的公平性，他们会进行 $\\mathbf{M}^{\\mathbf{N}}$ 局游戏，每局游戏中裁判会以不同的方式在卡片上写数字。这意味着对于每一种可能的卡片分配方式，**Alice** 和 **Bob** 都会恰好进行一局游戏。给定游戏参数和固定的棋盘内容，请计算所有游戏的分数之和。由于输出可能是一个非常大的数字，我们只要求你输出结果对质数 $10^9 + 7$（即 $1000000007$）取模后的余数。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含恰好两行。第一行包含三个整数 $\\mathbf{N}$、$\\mathbf{M}$ 和 $\\mathbf{L}$。第二行包含 $2^{\\mathbf{L}}$ 个整数 $\\mathbf{A}_1$, $\\mathbf{A}_2$, …, $\\mathbf{A}_{2^{\\mathbf{L}}}$，其中 $\\mathbf{A}_i$ 表示棋盘上从左数第 $i$ 个格子中的整数。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是所有 $\\mathbf{M}^{\\mathbf{N}}$ 局游戏的分数之和模 $10^9 + 7$（即 $1000000007$）后的结果。\n", "hint": "**样例解释**\n\n在样例 #1 中，有 4 种卡片分配方式：$[1, 1]$、$[1, 2]$、$[2, 1]$ 和 $[2, 2]$。在前两种分配方式中，无论 **Alice** 在首轮如何选择，**Bob** 总能使得最终剩下的格子中的数字为 1，而卡片 1 上的数字为 1，因此这两局游戏的分数均为 1。在后两种分配方式中，**Alice** 可以通过在首轮消除棋盘最左侧的一半，留下 $[1, 1]$，此时 **Bob** 别无选择，只能留下 $[1]$。由于在这两种分配方式中卡片 1 上的数字为 2，因此这两局游戏的分数均为 2。所有分数的总和为 $1 + 1 + 2 + 2 = 6$。\n\n**数据范围**\n\n- $1 \\leq \\text{T} \\leq 12$。\n- $1 \\leq \\text{L} \\leq 5$。\n- 对于所有 $i$，满足 $1 \\leq \\text{A}_i \\leq \\text{N}$。\n\n**测试集 1（9 分，可见判定结果）**\n\n- $1 \\leq \\text{N} \\leq 8$。\n- $1 \\leq \\text{M} \\leq 100$。\n\n**测试集 2（26 分，隐藏判定结果）**\n\n- $1 \\leq \\text{N} \\leq 32$。\n- $1 \\leq \\text{M} \\leq 10^9$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13043", "type": "P", "difficulty": 6, "samples": [["4\n1 5 5\n3 -1 2 2\n1 2 -10 5\n2 100000000 50000000\n80000000 0 40000000 40000000\n5000001 2500000 500 -501\n15000000 5000000 501 -400\n2 10 10\n0 2 4 2\n2 2 -4 5\n4 6 -6 5\n3 622460462 608203753\n486076103 36373156 502082214 284367873\n98895371 126167607 823055173 -740793281\n26430289 116311281 -398612375 -223683435\n46950301 278229490 766767410 -550292032", "Case #1: 5/1\nCase #2: 288309900002019999899/320000000000000000\nCase #3: 37/4\nCase #4: 216757935773010988373334129808263414106891/187470029508637421883991794137967"]], "limits": {"time": [45000, 45000], "memory": [1048576, 1048576]}, "tags": ["数学", "高精度", "2021", "扫描线", "Google Code Jam"], "title": "[GCJ 2021 Finals] Cutting Cake", "background": "", "description": "Today is your and your twin sibling's birthday. To celebrate, you got a rectangular cake to share. The cake is decorated with $\\mathbf{N}$ triangular patches of icing (which may overlap). All the icing patches were created with the same triangular mold, so they have the same shape and orientation. Although you and your twin are very similar, your tastes in icing are much different. This difference is formalized by each of you having a different enjoyment value for each patch of icing. Specifically, your enjoyment value for eating the entire $i$-th patch of icing is $\\mathbf{A}_i$, and your twin's is $\\mathbf{B}_i$. If someone eats part of a patch, they get enjoyment proportional to the eaten area. For example, if you eat $\\frac{2}{3}$ of the area of the $i$-th icing patch, you would get $\\frac{2\\mathbf{A}_i}{3}$ enjoyment from it. Note that there may be some flavors of icing that you or your twin do not enjoy, so the $\\mathbf{A}_i$ and/or $\\mathbf{B}_i$ values can be negative.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bb02prmd.png)\n\nYou will cut the cake into two rectangular pieces by making a single vertical cut (parallel to the Y-axis). After cutting the cake, you will eat the left piece and your twin will eat the right piece. Your total enjoyment is the sum of the enjoyment you get from all icing to the left of the cut. Similarly, your twin's enjoyment is the sum of the enjoyment they get from all icing to the right of the cut.\n\nTo be as fair as possible, you want to cut the cake such that the absolute value of the difference between your total enjoyment and your twin's total enjoyment is as small as possible. Given the $\\mathbf{N}$ triangular icing patches on a rectangular cake, what is the minimum possible absolute value of the difference between your and your twin's total enjoyments you can get?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing three positive integers, $\\mathbf{N}$, $\\mathbf{W}$, and $\\mathbf{H}$, representing the number of icing patches on the cake and the width and height of the top of the cake, respectively. The bottom-left corner of the cake is located at $(0,0)$ and the top-right corner is at $(\\mathbf{W}, \\mathbf{H})$. Then, a line describing the icing patch mold follows. This line contains four integers: $\\mathbf{P}$, $\\mathbf{Q}$, $\\mathbf{R}$, and $\\mathbf{S}$. The icing patch mold is a triangle with vertices at $(0,0)$, $(\\mathbf{P}, \\mathbf{Q})$, and $(\\mathbf{R}, \\mathbf{S})$. Then, $\\mathbf{N}$ lines follow. The $i$-th of these lines contains four integers $\\mathbf{X}_i$, $\\mathbf{Y}_i$, $\\mathbf{A}_i$, and $\\mathbf{B}_i$. The $i$-th patch is a triangle with vertices at $(\\mathbf{X}_i, \\mathbf{Y}_i)$, $(\\mathbf{X}_i + \\mathbf{P}, \\mathbf{Y}_i + \\mathbf{Q})$, and $(\\mathbf{X}_i + \\mathbf{R}, \\mathbf{Y}_i + \\mathbf{S})$. You would get $\\mathbf{A}_i$ enjoyment from eating it and your twin would get $\\mathbf{B}_i$ enjoyment.", "outputFormat": "For each test case, output one line containing `Case #x: y/z`, where $x$ is the test case number (starting from 1) and $\\frac{y}{z}$ is the minimum absolute value of the difference between your and your twin's total enjoyment that can be achieved with a single vertical cut as an irreducible fraction (that is, $z$ must be positive and of minimum possible value).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is a single icing patch. The optimal cut is to the left of the patch. You will eat no icing and receive 0 enjoyment. Your twin will eat all of the icing patch and receive 5 enjoyment from it. The absolute value of the difference between your and your twin's enjoyments is $|0 - 5| = 5$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0l7tbto8.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/nfrgziry.png)\n\nIn Sample Case #2, there are two icing patches. The optimal cut is at $X = 15099999.99$. Notice that the numerator and denominator of the answer can get very large.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wer6hjfq.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/bjelfqv7.png)\n\nIn Sample Case #3, there are two icing patches. The optimal cut is at $X = 4$. You will eat 75% of the first icing patch and receive $-3$ enjoyment from it. Your twin will eat 25% of the first icing patch and all of the second icing patch getting $5 \\cdot 0.25 + 5 = 6.25$ enjoyment. The absolute value of the difference between your and your twin's enjoyments is $|-3 - 6.25| = 9.25 = \\frac{37}{4}$.\n\nNotice that cutting at $X = 1$ would give you $0$ enjoyment and your twin $10$ enjoyment. While both of those values are greater than the corresponding enjoyment when cutting at $X = 4$, the difference between them is $10 > 9.25$, which means cutting at $X = 4$ is preferable anyway.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x0dpaoy4.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/kgtk2lkh.png)\n\nIn Sample Case #4, there are three icing patches. The optimal cut is at $X \\approx 521241077.6027$.\n\n**Test Set 1 (20 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{N} \\leq 100$.\n- $3 \\leq \\mathbf{W} \\leq 10^{9}$.\n- $3 \\leq \\mathbf{H} \\leq 10^{9}$.\n- $-10^{9} \\leq \\mathbf{A}_{i} \\leq 10^{9}$, for all $i$.\n- $-10^{9} \\leq \\mathbf{B}_{i} \\leq 10^{9}$, for all $i$.\n- $0 \\leq \\mathbf{P} \\leq 10^{9}$.\n- $-10^{9} \\leq \\mathbf{Q} \\leq 10^{9}$.\n- $0 \\leq \\mathbf{R} \\leq 10^{9}$.\n- $-10^{9} \\leq \\mathbf{S} \\leq 10^{9}$.\n- The three vertices of the mold $(0, 0)$, $(\\mathbf{P}, \\mathbf{Q})$, and $(\\mathbf{R}, \\mathbf{S})$ are not collinear.\n- The three vertices of each triangular icing patch are strictly inside the cake's borders. Formally:\n  - $1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{W} - \\max(\\mathbf{P}, \\mathbf{R}) - 1$, for all $i$, and\n  - $\\max(0, -\\mathbf{Q}, -\\mathbf{S}) + 1 \\leq \\mathbf{Y}_{i} \\leq \\mathbf{H} - \\max(0, \\mathbf{Q}, \\mathbf{S}) - 1$, for all $i$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Finals] Cutting Cake", "background": "", "description": "Today is your and your twin sibling's birthday. To celebrate, you got a rectangular cake to share. The cake is decorated with $\\mathbf{N}$ triangular patches of icing (which may overlap). All the icing patches were created with the same triangular mold, so they have the same shape and orientation. Although you and your twin are very similar, your tastes in icing are much different. This difference is formalized by each of you having a different enjoyment value for each patch of icing. Specifically, your enjoyment value for eating the entire $i$-th patch of icing is $\\mathbf{A}_i$, and your twin's is $\\mathbf{B}_i$. If someone eats part of a patch, they get enjoyment proportional to the eaten area. For example, if you eat $\\frac{2}{3}$ of the area of the $i$-th icing patch, you would get $\\frac{2\\mathbf{A}_i}{3}$ enjoyment from it. Note that there may be some flavors of icing that you or your twin do not enjoy, so the $\\mathbf{A}_i$ and/or $\\mathbf{B}_i$ values can be negative.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bb02prmd.png)\n\nYou will cut the cake into two rectangular pieces by making a single vertical cut (parallel to the Y-axis). After cutting the cake, you will eat the left piece and your twin will eat the right piece. Your total enjoyment is the sum of the enjoyment you get from all icing to the left of the cut. Similarly, your twin's enjoyment is the sum of the enjoyment they get from all icing to the right of the cut.\n\nTo be as fair as possible, you want to cut the cake such that the absolute value of the difference between your total enjoyment and your twin's total enjoyment is as small as possible. Given the $\\mathbf{N}$ triangular icing patches on a rectangular cake, what is the minimum possible absolute value of the difference between your and your twin's total enjoyments you can get?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing three positive integers, $\\mathbf{N}$, $\\mathbf{W}$, and $\\mathbf{H}$, representing the number of icing patches on the cake and the width and height of the top of the cake, respectively. The bottom-left corner of the cake is located at $(0,0)$ and the top-right corner is at $(\\mathbf{W}, \\mathbf{H})$. Then, a line describing the icing patch mold follows. This line contains four integers: $\\mathbf{P}$, $\\mathbf{Q}$, $\\mathbf{R}$, and $\\mathbf{S}$. The icing patch mold is a triangle with vertices at $(0,0)$, $(\\mathbf{P}, \\mathbf{Q})$, and $(\\mathbf{R}, \\mathbf{S})$. Then, $\\mathbf{N}$ lines follow. The $i$-th of these lines contains four integers $\\mathbf{X}_i$, $\\mathbf{Y}_i$, $\\mathbf{A}_i$, and $\\mathbf{B}_i$. The $i$-th patch is a triangle with vertices at $(\\mathbf{X}_i, \\mathbf{Y}_i)$, $(\\mathbf{X}_i + \\mathbf{P}, \\mathbf{Y}_i + \\mathbf{Q})$, and $(\\mathbf{X}_i + \\mathbf{R}, \\mathbf{Y}_i + \\mathbf{S})$. You would get $\\mathbf{A}_i$ enjoyment from eating it and your twin would get $\\mathbf{B}_i$ enjoyment.", "outputFormat": "For each test case, output one line containing `Case #x: y/z`, where $x$ is the test case number (starting from 1) and $\\frac{y}{z}$ is the minimum absolute value of the difference between your and your twin's total enjoyment that can be achieved with a single vertical cut as an irreducible fraction (that is, $z$ must be positive and of minimum possible value).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is a single icing patch. The optimal cut is to the left of the patch. You will eat no icing and receive 0 enjoyment. Your twin will eat all of the icing patch and receive 5 enjoyment from it. The absolute value of the difference between your and your twin's enjoyments is $|0 - 5| = 5$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0l7tbto8.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/nfrgziry.png)\n\nIn Sample Case #2, there are two icing patches. The optimal cut is at $X = 15099999.99$. Notice that the numerator and denominator of the answer can get very large.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wer6hjfq.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/bjelfqv7.png)\n\nIn Sample Case #3, there are two icing patches. The optimal cut is at $X = 4$. You will eat 75% of the first icing patch and receive $-3$ enjoyment from it. Your twin will eat 25% of the first icing patch and all of the second icing patch getting $5 \\cdot 0.25 + 5 = 6.25$ enjoyment. The absolute value of the difference between your and your twin's enjoyments is $|-3 - 6.25| = 9.25 = \\frac{37}{4}$.\n\nNotice that cutting at $X = 1$ would give you $0$ enjoyment and your twin $10$ enjoyment. While both of those values are greater than the corresponding enjoyment when cutting at $X = 4$, the difference between them is $10 > 9.25$, which means cutting at $X = 4$ is preferable anyway.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x0dpaoy4.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/kgtk2lkh.png)\n\nIn Sample Case #4, there are three icing patches. The optimal cut is at $X \\approx 521241077.6027$.\n\n**Test Set 1 (20 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{N} \\leq 100$.\n- $3 \\leq \\mathbf{W} \\leq 10^{9}$.\n- $3 \\leq \\mathbf{H} \\leq 10^{9}$.\n- $-10^{9} \\leq \\mathbf{A}_{i} \\leq 10^{9}$, for all $i$.\n- $-10^{9} \\leq \\mathbf{B}_{i} \\leq 10^{9}$, for all $i$.\n- $0 \\leq \\mathbf{P} \\leq 10^{9}$.\n- $-10^{9} \\leq \\mathbf{Q} \\leq 10^{9}$.\n- $0 \\leq \\mathbf{R} \\leq 10^{9}$.\n- $-10^{9} \\leq \\mathbf{S} \\leq 10^{9}$.\n- The three vertices of the mold $(0, 0)$, $(\\mathbf{P}, \\mathbf{Q})$, and $(\\mathbf{R}, \\mathbf{S})$ are not collinear.\n- The three vertices of each triangular icing patch are strictly inside the cake's borders. Formally:\n  - $1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{W} - \\max(\\mathbf{P}, \\mathbf{R}) - 1$, for all $i$, and\n  - $\\max(0, -\\mathbf{Q}, -\\mathbf{S}) + 1 \\leq \\mathbf{Y}_{i} \\leq \\mathbf{H} - \\max(0, \\mathbf{Q}, \\mathbf{S}) - 1$, for all $i$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Finals] Cutting Cake", "background": "", "description": "今天是你和你的双胞胎兄弟姐妹的生日。为了庆祝，你们得到了一个长方形的蛋糕来分享。蛋糕上装饰有 $\\mathbf{N}$ 个三角形的糖霜区域（这些区域可能重叠）。所有的糖霜区域都是用同一个三角形模具制作的，因此它们的形状和方向完全相同。尽管你和你的双胞胎非常相似，但你们对糖霜的喜好却大不相同。具体来说，吃掉第 $i$ 个糖霜区域的全部，你会获得 $\\mathbf{A}_i$ 的享受值，而你的双胞胎会获得 $\\mathbf{B}_i$ 的享受值。如果有人吃掉了一部分糖霜区域，他们获得的享受值与吃掉的部分面积成正比。例如，如果你吃掉了第 $i$ 个糖霜区域的 $\\frac{2}{3}$，你会获得 $\\frac{2\\mathbf{A}_i}{3}$ 的享受值。注意，有些糖霜口味可能是你或你的双胞胎不喜欢的，因此 $\\mathbf{A}_i$ 和/或 $\\mathbf{B}_i$ 的值可能是负数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bb02prmd.png)\n\n你将通过一次垂直切割（平行于 Y 轴）将蛋糕分成两个长方形部分。切完蛋糕后，你将吃掉左边的部分，而你的双胞胎将吃掉右边的部分。你的总享受值是你从切割线左侧所有糖霜区域获得的享受值之和。类似地，你的双胞胎的总享受值是他们从切割线右侧所有糖霜区域获得的享受值之和。\n\n为了尽可能公平，你希望切割蛋糕使得你和你的双胞胎的总享受值之差的绝对值尽可能小。给定长方形蛋糕上的 $\\mathbf{N}$ 个三角形糖霜区域，你和你的双胞胎的总享受值之差的最小可能绝对值是多少？", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含三个正整数 $\\mathbf{N}$、$\\mathbf{W}$ 和 $\\mathbf{H}$，分别表示蛋糕上的糖霜区域数量、蛋糕顶部的宽度和高度。蛋糕的左下角位于 $(0,0)$，右上角位于 $(\\mathbf{W}, \\mathbf{H})$。接下来的一行描述糖霜区域模具，包含四个整数 $\\mathbf{P}$、$\\mathbf{Q}$、$\\mathbf{R}$ 和 $\\mathbf{S}$。糖霜区域模具是一个顶点位于 $(0,0)$、$(\\mathbf{P}, \\mathbf{Q})$ 和 $(\\mathbf{R}, \\mathbf{S})$ 的三角形。随后是 $\\mathbf{N}$ 行，每行包含四个整数 $\\mathbf{X}_i$、$\\mathbf{Y}_i$、$\\mathbf{A}_i$ 和 $\\mathbf{B}_i$。第 $i$ 个糖霜区域是一个顶点位于 $(\\mathbf{X}_i, \\mathbf{Y}_i)$、$(\\mathbf{X}_i + \\mathbf{P}, \\mathbf{Y}_i + \\mathbf{Q})$ 和 $(\\mathbf{X}_i + \\mathbf{R}, \\mathbf{Y}_i + \\mathbf{S})$ 的三角形。你会从吃掉它中获得 $\\mathbf{A}_i$ 的享受值，而你的双胞胎会获得 $\\mathbf{B}_i$ 的享受值。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y/z`，其中 $x$ 是测试用例编号（从 1 开始），$\\frac{y}{z}$ 是通过一次垂直切割可以实现你和你的双胞胎总享受值之差的最小绝对值，且必须为不可约分式（即 $z$ 必须为正且尽可能小）。\n", "hint": "**样例解释**\n\n在样例 #1 中，只有一个糖霜区域。最优切割位于该区域的左侧。你将不会吃到任何糖霜，享受值为 0。你的双胞胎会吃掉整个糖霜区域并获得 5 的享受值。你和你的双胞胎享受值之差的绝对值为 $|0 - 5| = 5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0l7tbto8.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/nfrgziry.png)\n\n在样例 #2 中，有两个糖霜区域。最优切割位于 $X = 15099999.99$ 处。注意答案的分子和分母可能非常大。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wer6hjfq.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/bjelfqv7.png)\n\n在样例 #3 中，有两个糖霜区域。最优切割位于 $X = 4$ 处。你将吃掉第一个糖霜区域的 75%，获得 $-3$ 的享受值。你的双胞胎会吃掉第一个糖霜区域的 25% 和整个第二个糖霜区域，获得 $5 \\times 0.25 + 5 = 6.25$ 的享受值。你和你的双胞胎享受值之差的绝对值为 $|-3 - 6.25| = 9.25 = \\frac{37}{4}$。\n\n注意，在 $X = 1$ 处切割会让你获得 $0$ 享受值，而你的双胞胎获得 $10$ 享受值。虽然这两个值都比在 $X = 4$ 处切割时的对应值大，但它们之间的差值为 $10 > 9.25$，因此仍然选择在 $X = 4$ 处切割更优。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x0dpaoy4.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/kgtk2lkh.png)\n\n在样例 #4 中，有三个糖霜区域。最优切割位于 $X \\approx 521241077.6027$ 处。\n\n**测试集 1（20 分，可见判定）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{N} \\leq 100$。\n- $3 \\leq \\mathbf{W} \\leq 10^{9}$。\n- $3 \\leq \\mathbf{H} \\leq 10^{9}$。\n- $-10^{9} \\leq \\mathbf{A}_{i} \\leq 10^{9}$，对所有 $i$ 成立。\n- $-10^{9} \\leq \\mathbf{B}_{i} \\leq 10^{9}$，对所有 $i$ 成立。\n- $0 \\leq \\mathbf{P} \\leq 10^{9}$。\n- $-10^{9} \\leq \\mathbf{Q} \\leq 10^{9}$。\n- $0 \\leq \\mathbf{R} \\leq 10^{9}$。\n- $-10^{9} \\leq \\mathbf{S} \\leq 10^{9}$。\n- 模具的三个顶点 $(0, 0)$、$(\\mathbf{P}, \\mathbf{Q})$ 和 $(\\mathbf{R}, \\mathbf{S})$ 不共线。\n- 每个三角形糖霜区域的三个顶点严格位于蛋糕的边界内。即：\n  - $1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{W} - \\max(\\mathbf{P}, \\mathbf{R}) - 1$，对所有 $i$ 成立；\n  - $\\max(0, -\\mathbf{Q}, -\\mathbf{S}) + 1 \\leq \\mathbf{Y}_{i} \\leq \\mathbf{H} - \\max(0, \\mathbf{Q}, \\mathbf{S}) - 1$，对所有 $i$ 成立。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13044", "type": "P", "difficulty": 6, "samples": [["2\n3 3 5\n1 2\n2 3\n3 1\nE 1 2 1\nE 3 3 1\nD 1 3 2\nD 1 3 3\nE 1 2 2\n5 8 10\n1 5\n5 3\n4 1\n3 2\n2 4\n2 5\n2 1\n1 4\nE 1 8 2\nD 4 8 2\nE 3 5 1\nE 1 1 3\nE 1 1 1\nE 5 8 2\nD 1 8 3\nD 5 8 4\nD 4 5 1\nE 3 4 1", "Case #1: 3 X 2 X 3\nCase #2: 3 X 1 1 X X X 3 X 5"]], "limits": {"time": [10000, 10000, 120000], "memory": [1048576, 1048576, 1048576]}, "tags": ["图论", "2021", "哈希 hashing", "Google Code Jam"], "title": "[GCJ 2021 Finals] Slide Circuits", "background": "", "description": "Gooli is a huge company that owns $\\mathbf{B}$ buildings in a hilly area. Five years ago, Gooli built slides that allowed employees to go from one building to another (they are not bidirectional), starting a tradition of building slides between buildings. Currently, $\\mathbf{S}$ slides exist.\n\nMelek is Gooli's Head of Transportation and a problem-solving enthusiast. She was tasked with keeping the slides enjoyable to use. The idea she came up with was disabling some slides such that only circuits remained. A circuit is a set of two or more buildings $b_{1}, b_{2}, \\ldots, b_{k}$ such that there is exactly one slide enabled from building $b_{i}$ to building $b_{i+1}$, for each $i$, and exactly one slide enabled from building $b_{k}$ to building $b_{1}$. No other slides from or to any of those buildings should be enabled, to prevent misdirection. A state of the slides is then called fun if each building belongs to exactly one circuit.\n\nSlides in Gooli's campus are numbered with integers between 1 and $\\mathbf{S}$, inclusive. Melek created a slide controlling console that supports two operations: enable and disable. Both operations receive three parameters $\\ell, r$, and $m$ and perform the operation on each slide $x$ such that $\\ell \\leq x \\leq r$ and $x$ is a multiple of $m$. An enable operation is valid only if all affected slides are in a disabled state right before the operation is performed. Similarly, a disable operation is valid only if all affected slides are in an enabled state right before the operation is performed.\n\nThe following picture illustrates a possible succession of states and operations. The layout has 3 buildings and 3 slides. Slides are light grey when disabled and dark grey when enabled.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vcfdd3y.png)\n\n1. Initial state. All sides are disabled.\n2. After enable operation with $\\ell=1$, $r=2$, and $m=1$.\n3. After enable operation with $\\ell=3$, $r=3$, and $m=1$.\n4. After disable operation with $\\ell=1, r=3$, and $m=2$.\n5. After disable operation with $\\ell=1, r=3$, and $m=3$.\n6. After enable operation with $\\ell=1, r=2$, and $m=2$.\n\nUnfortunately, Sult, Melek's cat, found the console and started performing several valid enable and disable operations. After every console operation performed by Sult, Melek wants to know if the state of the slides can be made fun by enabling exactly one currently disabled slide. Note that Melek does not actually enable this slide.\n\nIn the picture above, we can see that after the first, third, and last operations, Melek could enable the only disabled slide and get to a fun state. After the second operation, there are two issues. One issue is that there are no currently disabled slides, so Melek cannot enable any. Additionally, the state is already fun, so even if there were additional disabled slides, enabling anything would result in a not fun state. After the fourth operation, there are two disabled slides, but enabling either would not yield a fun state.\n\nAll slides are initially disabled, then Sult performs its operations one at a time. After each of Sult's operations, determine which disabled slide, if any, Melek can enable to put the slides in a fun state.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing three integers $\\mathbf{B}$, $\\mathbf{S}$, and $\\mathbf{N}$: the number of buildings, slides, and operations to process, respectively. Then, $\\mathbf{S}$ lines follow. The $i$-th of these lines contains two integers $\\mathbf{X}_{i}$ and $\\mathbf{Y}_{i}$, indicating that the slide with number $i$ goes from building $\\mathbf{X}_{i}$ to building $\\mathbf{Y}_{i}$. Finally, $\\mathbf{N}$ lines represent the operations. The $j$-th of these lines contains a character $\\mathbf{A}_{j}$ and three integers $\\mathbf{L}_{j}, \\mathbf{R}_{j}$, and $\\mathbf{M}_{j}$, describing the $j$-th operation. $\\mathbf{A}_{j}$ describes the type of operation using an uppercase $\\mathbf{E}$ for enable and an uppercase $\\mathbf{D}$ for disable. The operation is to be performed on slides with numbers that are simultaneously a multiple of $\\mathbf{M}_{j}$ and between $\\mathbf{L}_{j}$ and $\\mathbf{R}_{j}$, inclusive.", "outputFormat": "For each test case, output one line containing `Case #x:` $y_{1}\\ y_{2}\\ \\ldots\\ y_{N}$, where $x$ is the test case number (starting from 1) and $y_{j}$ is an uppercase $\\mathbf{X}$ if there is no way to turn the state of slides created by the first $j$ console operations into a fun state by enabling exactly one disabled slide. Otherwise, $y_{j}$ should be an integer representing that enabling the $y_{j}$-th slide would turn the state created by the first $j$ console operations into a fun state.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one depicted in the problem statement.\n\nThe following picture shows the building and slide layout of Sample Case #2.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gc127wx5.png)\n\nThe sets of enabled slides after each operation are:\n\n- $\\{2,4,6,8\\}$,\n- $\\{2\\}$,\n- $\\{2,3,4,5\\}$,\n- $\\{2,3,4,5\\}$,\n- $\\{1,2,3,4,5\\}$,\n- $\\{1,2,3,4,5,6,8\\}$,\n- $\\{1,2,4,5,8\\}$,\n- $\\{1,2,4,5\\}$,\n- $\\{1,2\\}$, and\n- $\\{1,2,3,4\\}$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{B}$, for all $i$.\n- $1 \\leq \\mathbf{Y}_{i} \\leq \\mathbf{B}$, for all $i$.\n- $\\mathbf{X}_{i} \\neq \\mathbf{Y}_{i}$, for all $i$.\n- $\\left(\\mathbf{X}_{i}, \\mathbf{Y}_{i}\\right) \\neq\\left(\\mathbf{X}_{j}, \\mathbf{Y}_{j}\\right)$, for all $i \\neq j$.\n- $\\mathbf{A}_{j}$ is either uppercase $\\mathbf{E}$ or uppercase $\\mathbf{D}$, for all $j$.\n- $1 \\leq \\mathbf{L}_{j} \\leq \\mathbf{R}_{j} \\leq \\mathbf{S}$, for all $j$.\n- $1 \\leq \\mathbf{M}_{j} \\leq \\mathbf{S}$, for all $j$.\n- Each operation is valid.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{B} \\leq 100$.\n- $2 \\leq \\mathbf{S} \\leq 1000$.\n- $1 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 2 (20 Pts, Hidden Verdict)**\n\n- Time limit: 120 seconds.\n- $1 \\leq \\mathbf{T} \\leq 30$.\n- $2 \\leq \\mathbf{B} \\leq 3 \\times 10^{4}$.\n- $2 \\leq \\mathbf{S} \\leq 3 \\times 10^{5}$.\n- $1 \\leq \\mathbf{N} \\leq 3 \\times 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Finals] Slide Circuits", "background": "", "description": "Gooli is a huge company that owns $\\mathbf{B}$ buildings in a hilly area. Five years ago, Gooli built slides that allowed employees to go from one building to another (they are not bidirectional), starting a tradition of building slides between buildings. Currently, $\\mathbf{S}$ slides exist.\n\nMelek is Gooli's Head of Transportation and a problem-solving enthusiast. She was tasked with keeping the slides enjoyable to use. The idea she came up with was disabling some slides such that only circuits remained. A circuit is a set of two or more buildings $b_{1}, b_{2}, \\ldots, b_{k}$ such that there is exactly one slide enabled from building $b_{i}$ to building $b_{i+1}$, for each $i$, and exactly one slide enabled from building $b_{k}$ to building $b_{1}$. No other slides from or to any of those buildings should be enabled, to prevent misdirection. A state of the slides is then called fun if each building belongs to exactly one circuit.\n\nSlides in Gooli's campus are numbered with integers between 1 and $\\mathbf{S}$, inclusive. Melek created a slide controlling console that supports two operations: enable and disable. Both operations receive three parameters $\\ell, r$, and $m$ and perform the operation on each slide $x$ such that $\\ell \\leq x \\leq r$ and $x$ is a multiple of $m$. An enable operation is valid only if all affected slides are in a disabled state right before the operation is performed. Similarly, a disable operation is valid only if all affected slides are in an enabled state right before the operation is performed.\n\nThe following picture illustrates a possible succession of states and operations. The layout has 3 buildings and 3 slides. Slides are light grey when disabled and dark grey when enabled.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vcfdd3y.png)\n\n1. Initial state. All sides are disabled.\n2. After enable operation with $\\ell=1$, $r=2$, and $m=1$.\n3. After enable operation with $\\ell=3$, $r=3$, and $m=1$.\n4. After disable operation with $\\ell=1, r=3$, and $m=2$.\n5. After disable operation with $\\ell=1, r=3$, and $m=3$.\n6. After enable operation with $\\ell=1, r=2$, and $m=2$.\n\nUnfortunately, Sult, Melek's cat, found the console and started performing several valid enable and disable operations. After every console operation performed by Sult, Melek wants to know if the state of the slides can be made fun by enabling exactly one currently disabled slide. Note that Melek does not actually enable this slide.\n\nIn the picture above, we can see that after the first, third, and last operations, Melek could enable the only disabled slide and get to a fun state. After the second operation, there are two issues. One issue is that there are no currently disabled slides, so Melek cannot enable any. Additionally, the state is already fun, so even if there were additional disabled slides, enabling anything would result in a not fun state. After the fourth operation, there are two disabled slides, but enabling either would not yield a fun state.\n\nAll slides are initially disabled, then Sult performs its operations one at a time. After each of Sult's operations, determine which disabled slide, if any, Melek can enable to put the slides in a fun state.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing three integers $\\mathbf{B}$, $\\mathbf{S}$, and $\\mathbf{N}$: the number of buildings, slides, and operations to process, respectively. Then, $\\mathbf{S}$ lines follow. The $i$-th of these lines contains two integers $\\mathbf{X}_{i}$ and $\\mathbf{Y}_{i}$, indicating that the slide with number $i$ goes from building $\\mathbf{X}_{i}$ to building $\\mathbf{Y}_{i}$. Finally, $\\mathbf{N}$ lines represent the operations. The $j$-th of these lines contains a character $\\mathbf{A}_{j}$ and three integers $\\mathbf{L}_{j}, \\mathbf{R}_{j}$, and $\\mathbf{M}_{j}$, describing the $j$-th operation. $\\mathbf{A}_{j}$ describes the type of operation using an uppercase $\\mathbf{E}$ for enable and an uppercase $\\mathbf{D}$ for disable. The operation is to be performed on slides with numbers that are simultaneously a multiple of $\\mathbf{M}_{j}$ and between $\\mathbf{L}_{j}$ and $\\mathbf{R}_{j}$, inclusive.", "outputFormat": "For each test case, output one line containing `Case #x:` $y_{1}\\ y_{2}\\ \\ldots\\ y_{N}$, where $x$ is the test case number (starting from 1) and $y_{j}$ is an uppercase $\\mathbf{X}$ if there is no way to turn the state of slides created by the first $j$ console operations into a fun state by enabling exactly one disabled slide. Otherwise, $y_{j}$ should be an integer representing that enabling the $y_{j}$-th slide would turn the state created by the first $j$ console operations into a fun state.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one depicted in the problem statement.\n\nThe following picture shows the building and slide layout of Sample Case #2.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gc127wx5.png)\n\nThe sets of enabled slides after each operation are:\n\n- $\\{2,4,6,8\\}$,\n- $\\{2\\}$,\n- $\\{2,3,4,5\\}$,\n- $\\{2,3,4,5\\}$,\n- $\\{1,2,3,4,5\\}$,\n- $\\{1,2,3,4,5,6,8\\}$,\n- $\\{1,2,4,5,8\\}$,\n- $\\{1,2,4,5\\}$,\n- $\\{1,2\\}$, and\n- $\\{1,2,3,4\\}$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{B}$, for all $i$.\n- $1 \\leq \\mathbf{Y}_{i} \\leq \\mathbf{B}$, for all $i$.\n- $\\mathbf{X}_{i} \\neq \\mathbf{Y}_{i}$, for all $i$.\n- $\\left(\\mathbf{X}_{i}, \\mathbf{Y}_{i}\\right) \\neq\\left(\\mathbf{X}_{j}, \\mathbf{Y}_{j}\\right)$, for all $i \\neq j$.\n- $\\mathbf{A}_{j}$ is either uppercase $\\mathbf{E}$ or uppercase $\\mathbf{D}$, for all $j$.\n- $1 \\leq \\mathbf{L}_{j} \\leq \\mathbf{R}_{j} \\leq \\mathbf{S}$, for all $j$.\n- $1 \\leq \\mathbf{M}_{j} \\leq \\mathbf{S}$, for all $j$.\n- Each operation is valid.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- Time limit: 10 seconds.\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{B} \\leq 100$.\n- $2 \\leq \\mathbf{S} \\leq 1000$.\n- $1 \\leq \\mathbf{N} \\leq 1000$.\n\n**Test Set 2 (20 Pts, Hidden Verdict)**\n\n- Time limit: 120 seconds.\n- $1 \\leq \\mathbf{T} \\leq 30$.\n- $2 \\leq \\mathbf{B} \\leq 3 \\times 10^{4}$.\n- $2 \\leq \\mathbf{S} \\leq 3 \\times 10^{5}$.\n- $1 \\leq \\mathbf{N} \\leq 3 \\times 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Finals] Slide Circuits", "background": "", "description": "**Gooli** 是一家大型公司，在一个丘陵地区拥有 $\\mathbf{B}$ 栋建筑。五年前，**Gooli** 建造了允许员工从一栋建筑滑向另一栋建筑的滑道（单向），由此开启了在建筑间建造滑道的传统。目前共有 $\\mathbf{S}$ 条滑道。\n\n**Melek** 是 **Gooli** 的交通主管，也是一位热衷解决问题的爱好者。她接到任务要保持滑道的使用乐趣。她想出的办法是禁用部分滑道，使得仅保留电路。一个电路是指由两栋或更多建筑 $b_{1}, b_{2}, \\ldots, b_{k}$ 组成的集合，其中对于每个 $i$，从建筑 $b_{i}$ 到建筑 $b_{i+1}$ 恰好有一条启用的滑道，且从建筑 $b_{k}$ 到建筑 $b_{1}$ 恰好有一条启用的滑道。这些建筑的其他任何滑道都不应启用，以防止误导。此时滑道的状态被称为 **有趣状态**，当且仅当每栋建筑恰好属于一个电路。\n\n**Gooli** 园区内的滑道用 1 到 $\\mathbf{S}$ 的整数编号。**Melek** 创建了一个滑道控制台，支持两种操作：**启用** 和 **禁用**。两种操作都接收三个参数 $\\ell$、$r$ 和 $m$，并对所有满足 $\\ell \\leq x \\leq r$ 且 $x$ 是 $m$ 的倍数的滑道 $x$ 执行操作。启用操作仅在操作执行前所有受影响的滑道处于禁用状态时才有效。类似地，禁用操作仅在操作执行前所有受影响的滑道处于启用状态时才有效。\n\n下图展示了可能的操作序列和状态变化。布局包含 3 栋建筑和 3 条滑道。禁用状态的滑道显示为浅灰色，启用状态的滑道显示为深灰色。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9vcfdd3y.png)\n\n1. 初始状态。所有滑道禁用。\n2. 执行启用操作 $\\ell=1$，$r=2$，$m=1$ 后。\n3. 执行启用操作 $\\ell=3$，$r=3$，$m=1$ 后。\n4. 执行禁用操作 $\\ell=1$，$r=3$，$m=2$ 后。\n5. 执行禁用操作 $\\ell=1$，$r=3$，$m=3$ 后。\n6. 执行启用操作 $\\ell=1$，$r=2$，$m=2$ 后。\n\n不幸的是，**Melek** 的猫 **Sult** 发现了控制台，并开始执行一系列有效的启用和禁用操作。在 **Sult** 执行每次操作后，**Melek** 想知道是否可以通过 **恰好启用一条当前禁用的滑道** 使滑道达到有趣状态。注意 **Melek** 实际上并不会启用这条滑道。\n\n在上图中可以看到，在第一次、第三次和最后一次操作后，**Melek** 可以启用唯一禁用的滑道，使状态变为有趣状态。第二次操作后存在两个问题：一是当前没有禁用的滑道，因此 **Melek** 无法启用任何滑道；此外，状态已经是有趣状态，即使有其他禁用的滑道，启用任何滑道都会导致状态不再有趣。第四次操作后，有两条禁用的滑道，但启用任意一条都无法得到有趣状态。\n\n所有滑道最初都是禁用的，然后 **Sult** 依次执行操作。在 **Sult** 的每次操作后，确定 **Melek** 可以启用哪条禁用的滑道（如果有的话）使滑道达到有趣状态。\n", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含三个整数 $\\mathbf{B}$、$\\mathbf{S}$ 和 $\\mathbf{N}$，分别表示建筑数量、滑道数量和处理的操作数量。接下来 $\\mathbf{S}$ 行，每行包含两个整数 $\\mathbf{X}_{i}$ 和 $\\mathbf{Y}_{i}$，表示编号为 $i$ 的滑道从建筑 $\\mathbf{X}_{i}$ 通向建筑 $\\mathbf{Y}_{i}$。最后 $\\mathbf{N}$ 行描述操作。第 $j$ 行包含一个字符 $\\mathbf{A}_{j}$ 和三个整数 $\\mathbf{L}_{j}$、$\\mathbf{R}_{j}$ 和 $\\mathbf{M}_{j}$，描述第 $j$ 个操作。$\\mathbf{A}_{j}$ 表示操作类型，大写字母 $\\mathbf{E}$ 表示启用，大写字母 $\\mathbf{D}$ 表示禁用。操作会对所有编号是 $\\mathbf{M}_{j}$ 的倍数且介于 $\\mathbf{L}_{j}$ 和 $\\mathbf{R}_{j}$ 之间的滑道执行。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x:` $y_{1} y_{2} ... y_{N}$，其中 $x$ 是测试用例编号（从 1 开始），$y_{j}$ 是一个大写字母 $\\mathbf{X}$（如果在前 $j$ 次操作后无法通过启用恰好一条禁用滑道使状态变为有趣状态），否则 $y_{j}$ 是一个整数，表示启用编号为 $y_{j}$ 的滑道可以使前 $j$ 次操作后的状态变为有趣状态。\n", "hint": "**样例解释**\n\n样例 #1 对应题目描述中的图示案例。\n\n下图展示了样例 #2 的建筑和滑道布局：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gc127wx5.png)\n\n每次操作后启用的滑道集合依次为：\n\n1. $\\{2,4,6,8\\}$\n2. $\\{2\\}$\n3. $\\{2,3,4,5\\}$\n4. $\\{2,3,4,5\\}$\n5. $\\{1,2,3,4,5\\}$\n6. $\\{1,2,3,4,5,6,8\\}$\n7. $\\{1,2,4,5,8\\}$\n8. $\\{1,2,4,5\\}$\n9. $\\{1,2\\}$\n10. $\\{1,2,3,4\\}$\n\n**数据范围**\n\n- 对所有 $i$，$1 \\leq \\mathbf{X}_{i} \\leq \\mathbf{B}$\n- 对所有 $i$，$1 \\leq \\mathbf{Y}_{i} \\leq \\mathbf{B}$\n- 对所有 $i$，$\\mathbf{X}_{i} \\neq \\mathbf{Y}_{i}$\n- 对所有 $i \\neq j$，$\\left(\\mathbf{X}_{i}, \\mathbf{Y}_{i}\\right) \\neq\\left(\\mathbf{X}_{j}, \\mathbf{Y}_{j}\\right)$\n- 对所有 $j$，$\\mathbf{A}_{j}$ 为大写字母 $\\mathbf{E}$ 或 $\\mathbf{D}$\n- 对所有 $j$，$1 \\leq \\mathbf{L}_{j} \\leq \\mathbf{R}_{j} \\leq \\mathbf{S}$\n- 对所有 $j$，$1 \\leq \\mathbf{M}_{j} \\leq \\mathbf{S}$\n- 每个操作都有效\n\n**测试集 1（10 分，可见判定）**\n\n- 时间限制：10 秒\n- $1 \\leq \\mathbf{T} \\leq 100$\n- $2 \\leq \\mathbf{B} \\leq 100$\n- $2 \\leq \\mathbf{S} \\leq 1000$\n- $1 \\leq \\mathbf{N} \\leq 1000$\n\n**测试集 2（20 分，隐藏判定）**\n\n- 时间限制：120 秒\n- $1 \\leq \\mathbf{T} \\leq 30$\n- $2 \\leq \\mathbf{B} \\leq 3 \\times 10^{4}$\n- $2 \\leq \\mathbf{S} \\leq 3 \\times 10^{5}$\n- $1 \\leq \\mathbf{N} \\leq 3 \\times 10^{5}$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13045", "type": "P", "difficulty": 7, "samples": [["2 2 1\n\n4 1\n\n2 4\n0\n\n2 3\n\n4 4\n1", "\n3 2\n\n1 3\n\n\n1 1\n\n3 2"]], "limits": {"time": [90000, 90000, 90000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "2021", "交互题", "Special Judge", "Ad-hoc", "Google Code Jam"], "title": "[GCJ 2021 Finals] Ropes", "background": "", "description": "Two scout teams are taking part in a scouting competition. It is the finals and each team is well prepared. The game is played along a river that flows west to east. There are $4 \\mathrm{~N}$ trees planted along the river, with exactly $2 \\mathrm{~N}$ of them lined up along the north bank and $2 \\mathrm{~N}$ lined up along the south bank. Both teams alternate turns playing the game. Your team goes first.\n\nOn each turn, the playing team selects one tree on each bank that does not have any ropes tied to it and ties a rope between both trees, making it cross the river. Each rope that is added is placed higher than all previous ropes. The playing team scores 1 point per each previously used rope that passes below the newly added rope.\n\nAfter $2 \\mathrm{~N}$ turns, all trees have exactly one rope tied to them, so there are no more possible plays and the game is over. The score of each team is the sum of the scores they got in all of their turns. If your team's score is strictly greater than the opposing team's score, your team wins. If your team's score is less than or equal to the opposing team's score, your team does not win.\n\nThe following animation shows a possible game with $\\mathrm{N}=2$. Your team is represented by the color red and the other team by the color blue.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/85s69ke7)\n\nThe opposing team felt confident that going second is a large advantage, so they revealed their strategy. On their turn, they choose the play that yields the maximum possible score for this turn. If multiple such plays exist, they choose one at random. This choice is generated uniformly at random, and independently for each play, for each test case and for each submission. Therefore, even if you submit exactly the same code twice, the opposing team can make different random choices.\n\nYou play $\\mathrm{T}$ games in total, and your team must win at least $\\mathrm{W}$ of them.\n\n### Interactive Protocol\n\nThis is an interactive problem. You should make sure you have read the information in the Interactive Problems section of our $F A Q$.\n\nInitially, your program should read a single line containing three integers $\\mathbf{T}, \\mathbf{N}$, and $\\mathbf{W}$ : the number of test cases, the number of turns of your team and the number of wins you need to get for your solution to be considered correct, respectively. Note that the opposing team also gets $\\mathbf{N}$ turns, for a total of $2 \\mathbf{N}$ turns for each test case.\n\nFor each test case, your program must process $\\mathbf{N}$ exchanges. Each exchange represents two consecutive turns, one from your team and one from the opposing team.\n\nFor the $i$-th exchange, you must first print a single line with two integers $\\mathbf{A}_{i}$ and $\\mathbf{B}_{i}$ and then read a single line with two integers $\\mathbf{C}_{i}$ and $\\mathbf{D}_{i}$. This represents that in your $i$-th turn you tied the rope between the $\\mathbf{A}_{i}$-th tree from the west on the north bank and the $\\mathbf{B}_{i}$-th tree from the west on the south bank. Similarly, in the opposing team's $i$-th turn they used the $\\mathbf{C}_{i}$-th tree from the west on the north bank and the $\\mathbf{D}_{i}$-th tree from the west on the south bank. Trees are indexed starting from 1.\n\nAfter the $\\mathbf{N}$ exchanges, you must read one number that represents the result of this game. This number will be 1 if your team won, otherwise it will be 0 .\n\nThe next test case starts immediately if there is one. If this was the last test case, the judge will expect no more output and will send no further input to your program. In addition, all $\\mathbf{T}$ test cases are always processed, regardless of whether it is already guaranteed that the threshold for correctness will or cannot be met. The threshold is only checked after correctly processing all test cases.\n\nIf the judge receives an invalidly formatted line or invalid move (like using a tree that has already been used) from your program at any moment, the judge will print a single number -1 and will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently. \n\n**Limits**\n\n- $\\mathbf{T}=2000$.\n- $\\mathbf{N}=50$.\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{W}=1200(\\mathbf{W}=0.6 \\cdot \\mathbf{T})$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $\\mathbf{W}=1560(\\mathbf{W}=0.78 \\cdot \\mathbf{T})$.\n\n**Test Set 3 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{W}=1720(\\mathbf{W}=0.86 \\cdot \\mathbf{T})$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Finals] Ropes", "background": "", "description": "Two scout teams are taking part in a scouting competition. It is the finals and each team is well prepared. The game is played along a river that flows west to east. There are $4 \\mathrm{~N}$ trees planted along the river, with exactly $2 \\mathrm{~N}$ of them lined up along the north bank and $2 \\mathrm{~N}$ lined up along the south bank. Both teams alternate turns playing the game. Your team goes first.\n\nOn each turn, the playing team selects one tree on each bank that does not have any ropes tied to it and ties a rope between both trees, making it cross the river. Each rope that is added is placed higher than all previous ropes. The playing team scores 1 point per each previously used rope that passes below the newly added rope.\n\nAfter $2 \\mathrm{~N}$ turns, all trees have exactly one rope tied to them, so there are no more possible plays and the game is over. The score of each team is the sum of the scores they got in all of their turns. If your team's score is strictly greater than the opposing team's score, your team wins. If your team's score is less than or equal to the opposing team's score, your team does not win.\n\nThe following animation shows a possible game with $\\mathrm{N}=2$. Your team is represented by the color red and the other team by the color blue.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/85s69ke7)\n\nThe opposing team felt confident that going second is a large advantage, so they revealed their strategy. On their turn, they choose the play that yields the maximum possible score for this turn. If multiple such plays exist, they choose one at random. This choice is generated uniformly at random, and independently for each play, for each test case and for each submission. Therefore, even if you submit exactly the same code twice, the opposing team can make different random choices.\n\nYou play $\\mathrm{T}$ games in total, and your team must win at least $\\mathrm{W}$ of them.\n\n### Interactive Protocol\n\nThis is an interactive problem. You should make sure you have read the information in the Interactive Problems section of our $F A Q$.\n\nInitially, your program should read a single line containing three integers $\\mathbf{T}, \\mathbf{N}$, and $\\mathbf{W}$ : the number of test cases, the number of turns of your team and the number of wins you need to get for your solution to be considered correct, respectively. Note that the opposing team also gets $\\mathbf{N}$ turns, for a total of $2 \\mathbf{N}$ turns for each test case.\n\nFor each test case, your program must process $\\mathbf{N}$ exchanges. Each exchange represents two consecutive turns, one from your team and one from the opposing team.\n\nFor the $i$-th exchange, you must first print a single line with two integers $\\mathbf{A}_{i}$ and $\\mathbf{B}_{i}$ and then read a single line with two integers $\\mathbf{C}_{i}$ and $\\mathbf{D}_{i}$. This represents that in your $i$-th turn you tied the rope between the $\\mathbf{A}_{i}$-th tree from the west on the north bank and the $\\mathbf{B}_{i}$-th tree from the west on the south bank. Similarly, in the opposing team's $i$-th turn they used the $\\mathbf{C}_{i}$-th tree from the west on the north bank and the $\\mathbf{D}_{i}$-th tree from the west on the south bank. Trees are indexed starting from 1.\n\nAfter the $\\mathbf{N}$ exchanges, you must read one number that represents the result of this game. This number will be 1 if your team won, otherwise it will be 0 .\n\nThe next test case starts immediately if there is one. If this was the last test case, the judge will expect no more output and will send no further input to your program. In addition, all $\\mathbf{T}$ test cases are always processed, regardless of whether it is already guaranteed that the threshold for correctness will or cannot be met. The threshold is only checked after correctly processing all test cases.\n\nIf the judge receives an invalidly formatted line or invalid move (like using a tree that has already been used) from your program at any moment, the judge will print a single number -1 and will not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently. \n\n**Limits**\n\n- $\\mathbf{T}=2000$.\n- $\\mathbf{N}=50$.\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{W}=1200(\\mathbf{W}=0.6 \\cdot \\mathbf{T})$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $\\mathbf{W}=1560(\\mathbf{W}=0.78 \\cdot \\mathbf{T})$.\n\n**Test Set 3 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{W}=1720(\\mathbf{W}=0.86 \\cdot \\mathbf{T})$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Finals] Ropes", "background": "", "description": "两支侦察队正在参加一场侦察竞赛。这是决赛环节，每支队伍都做好了充分准备。比赛在一条自西向东流动的河流沿岸进行。河岸两侧共种植了 $4 \\mathrm{~N}$ 棵树，其中北岸和南岸各有恰好 $2 \\mathrm{~N}$ 棵。两支队伍轮流进行游戏，你的队伍先手。\n\n在每个回合中，当前行动队伍需要在两岸各选择一棵尚未绑绳的树，并在两棵树之间系一条跨河的绳索。每条新添加的绳索必须位于所有先前绳索的上方。该队伍每有一条先前使用的绳索从新绳索下方穿过，就能获得 1 分。\n\n经过 $2 \\mathrm{~N}$ 个回合后，所有树都恰好绑有一条绳索，游戏结束。每支队伍的总得分是他们在所有回合中获得分数的总和。若你队伍的得分严格大于对手队伍的得分，则你队获胜；否则不获胜。\n\n以下动画展示了一个 $\\mathrm{N}=2$ 时的可能对局。你队用红色表示，对手队用蓝色表示。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/85s69ke7)\n\n对手队认为后手具有巨大优势，因此公开了他们的策略：在他们的回合中，会选择使当前回合得分最大化的操作。若存在多个这样的操作，则随机选择其一。这个选择在每次操作、每个测试用例和每次提交中都是独立且均匀随机的。因此，即使提交完全相同的代码两次，对手队也可能做出不同的随机选择。\n\n你们共进行 $\\mathrm{T}$ 局游戏，你队需要至少赢得其中的 $\\mathrm{W}$ 局。\n\n### 交互协议\n\n这是一个交互题。请确保你已阅读交互题常见问题部分。\n\n初始时，你的程序需读取包含三个整数 $\\mathbf{T}$、$\\mathbf{N}$ 和 $\\mathbf{W}$ 的单行输入，分别表示测试用例数量、你队的回合数以及需要获胜的局数。注意对手队也有 $\\mathbf{N}$ 个回合，因此每个测试用例共进行 $2 \\mathbf{N}$ 个回合。\n\n对于每个测试用例，你的程序需要处理 $\\mathbf{N}$ 轮交互。每轮交互代表连续的两个回合，分别由你队和对手队进行。\n\n对于第 $i$ 轮交互，你需要先输出两个整数 $\\mathbf{A}_{i}$ 和 $\\mathbf{B}_{i}$，然后读取两个整数 $\\mathbf{C}_{i}$ 和 $\\mathbf{D}_{i}$。这表示在你队的第 $i$ 个回合中，你选择了北岸从西数第 $\\mathbf{A}_{i}$ 棵树和南岸从西数第 $\\mathbf{B}_{i}$ 棵树系绳；对手队则在他们的第 $i$ 个回合中选择了北岸第 $\\mathbf{C}_{i}$ 棵和南岸第 $\\mathbf{D}_{i}$ 棵树。树的编号从 1 开始。\n\n完成 $\\mathbf{N}$ 轮交互后，你需要读取一个表示本局结果数字：1 表示你队获胜，0 表示未获胜。\n\n若还有后续测试用例，则立即开始处理。若是最后一个测试用例，评测系统将不再提供输入。注意所有 $\\mathbf{T}$ 个测试用例都会被处理，不论是否已确定能否达到正确率阈值。该阈值仅在正确处理所有测试用例后才进行检查。\n\n若评测系统在任何时刻接收到非法格式或无效操作（如选择已使用的树），将输出 -1 并终止交互。若你的程序在收到 -1 后仍等待输入，将导致超时错误。请注意确保程序及时退出以避免该情况。\n", "inputFormat": "参见交互协议部分。", "outputFormat": "参见交互协议部分。", "hint": "你可以使用测试工具在本地或平台上进行测试。本地测试时需要并行运行工具和代码，我们提供了[交互运行器](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多说明请参阅该文件中的注释。\n\n测试工具的使用说明包含在工具的注释中。建议你添加自己的测试用例。请注意该工具虽然用于模拟评测系统，但并非真实评测系统，其行为可能有所不同。\n\n**数据范围**\n\n- $\\mathbf{T}=2000$\n- $\\mathbf{N}=50$\n\n**测试集 1（15 分，可见判定）**\n\n- $\\mathbf{W}=1200$（$\\mathbf{W}=0.6 \\cdot \\mathbf{T}$）\n\n**测试集 2（10 分，可见判定）**\n\n- $\\mathbf{W}=1560$（$\\mathbf{W}=0.78 \\cdot \\mathbf{T}$）\n\n**测试集 3（15 分，可见判定）**\n\n- $\\mathbf{W}=1720$（$\\mathbf{W}=0.86 \\cdot \\mathbf{T}$）\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13046", "type": "P", "difficulty": 6, "samples": [["3\n0145217 7\n100100 10\n5555 12", "Case #1: 16\nCase #2: 30\nCase #3: 1"]], "limits": {"time": [60000, 60000, 60000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "数学", "2021", "数论", "中国剩余定理 CRT", "Google Code Jam"], "title": "[GCJ 2021 Finals] Divisible Divisions", "background": "", "description": "We have a string $\\mathbf{S}$ consisting of decimal digits. A division of $\\mathbf{S}$ is created by dividing $\\mathbf{S}$ into contiguous substrings. For example, if $\\mathbf{S}$ is 0145217, two possible divisions are 014 5 21 7 and 0 14 52 17. Each digit must be used in exactly one substring, and each substring must be non-empty. If $\\mathbf{S}$ has $L$ digits, then there are exactly $2^{L-1}$ possible divisions of it.\n\nGiven a positive integer $\\mathbf{D}$, a division of $\\mathbf{S}$ is called divisible by $\\mathbf{D}$ if for every pair of consecutive substrings, at least one of the integers they represent in base 10 is divisible by $\\mathbf{D}$. If $\\mathbf{D}=7$, the first example division above is divisible because 014, 21, and 7 represent integers divisible by 7. The second example division is not divisible because 52 and 17 are consecutive substrings and neither represents an integer divisible by 7. Dividing 0145217 as 0145217 is divisible by any $\\mathbf{D}$ because there are no pairs of consecutive substrings.\n\nGiven $\\mathbf{S}$ and $\\mathbf{D}$, count how many divisions of $\\mathbf{S}$ exist that are divisible by $\\mathbf{D}$. Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^{9}+7$ ($1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line represents a test case with a string of digits $\\mathbf{S}$ and a positive integer $\\mathbf{D}$, as mentioned above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of different divisions of $\\mathbf{S}$ that are divisible by $\\mathbf{D}$, modulo the prime $10^{9}+7$ ($1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, all $16$ divisible divisions of $\\mathbf{S}$ are:\n\n- 0145217,\n- 0 145217,\n- 0 14 5217,\n- 0 14 5 217,\n- 0 14 5 21 7,\n- 0 14 521 7,\n- 0 145 217,\n- 0 145 21 7,\n- 0 14521 7,\n- 014 5217,\n- 014 5 217,\n- 014 5 21 7,\n- 014 521 7,\n- 0145 217,\n- 0145 21 7, and\n- 014521 7.\n\nIn Sample Case #2, there are $2^{5}=32$ ways to divide in total. To get two consecutive substrings to not be divisible by 10, we need both of them to not end in 0. The only 2 ways of doing that are $1 \\ 001 \\ 00$ and $1 \\ 001 \\ 0 \\ 0$, which means the other 30 divisions of $\\mathbf{S}$ are divisible by 10.\n\nIn Sample Case #3, no possible substring represents an even integer, which in turn means it is not divisible by 12. Therefore, the only way to not have two consecutive substrings that are not divisible by 12 is to not have two consecutive substrings at all, which can be done in only 1 way: 5555.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D} \\leq 10^{6}$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 1000$.\n\n**Test Set 2 (35 Pts, Hidden Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Finals] Divisible Divisions", "background": "", "description": "We have a string $\\mathbf{S}$ consisting of decimal digits. A division of $\\mathbf{S}$ is created by dividing $\\mathbf{S}$ into contiguous substrings. For example, if $\\mathbf{S}$ is 0145217, two possible divisions are 014 5 21 7 and 0 14 52 17. Each digit must be used in exactly one substring, and each substring must be non-empty. If $\\mathbf{S}$ has $L$ digits, then there are exactly $2^{L-1}$ possible divisions of it.\n\nGiven a positive integer $\\mathbf{D}$, a division of $\\mathbf{S}$ is called divisible by $\\mathbf{D}$ if for every pair of consecutive substrings, at least one of the integers they represent in base 10 is divisible by $\\mathbf{D}$. If $\\mathbf{D}=7$, the first example division above is divisible because 014, 21, and 7 represent integers divisible by 7. The second example division is not divisible because 52 and 17 are consecutive substrings and neither represents an integer divisible by 7. Dividing 0145217 as 0145217 is divisible by any $\\mathbf{D}$ because there are no pairs of consecutive substrings.\n\nGiven $\\mathbf{S}$ and $\\mathbf{D}$, count how many divisions of $\\mathbf{S}$ exist that are divisible by $\\mathbf{D}$. Since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^{9}+7$ ($1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line represents a test case with a string of digits $\\mathbf{S}$ and a positive integer $\\mathbf{D}$, as mentioned above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of different divisions of $\\mathbf{S}$ that are divisible by $\\mathbf{D}$, modulo the prime $10^{9}+7$ ($1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, all $16$ divisible divisions of $\\mathbf{S}$ are:\n\n- 0145217,\n- 0 145217,\n- 0 14 5217,\n- 0 14 5 217,\n- 0 14 5 21 7,\n- 0 14 521 7,\n- 0 145 217,\n- 0 145 21 7,\n- 0 14521 7,\n- 014 5217,\n- 014 5 217,\n- 014 5 21 7,\n- 014 521 7,\n- 0145 217,\n- 0145 21 7, and\n- 014521 7.\n\nIn Sample Case #2, there are $2^{5}=32$ ways to divide in total. To get two consecutive substrings to not be divisible by 10, we need both of them to not end in 0. The only 2 ways of doing that are $1 \\ 001 \\ 00$ and $1 \\ 001 \\ 0 \\ 0$, which means the other 30 divisions of $\\mathbf{S}$ are divisible by 10.\n\nIn Sample Case #3, no possible substring represents an even integer, which in turn means it is not divisible by 12. Therefore, the only way to not have two consecutive substrings that are not divisible by 12 is to not have two consecutive substrings at all, which can be done in only 1 way: 5555.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D} \\leq 10^{6}$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 1000$.\n\n**Test Set 2 (35 Pts, Hidden Verdict)**\n\n- $1 \\leq$ the length of $\\mathbf{S} \\leq 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Finals] Divisible Divisions", "background": "", "description": "我们有一个由十进制数字组成的字符串 $\\mathbf{S}$。$\\mathbf{S}$ 的一个**分割**是通过将 $\\mathbf{S}$ 划分为连续的若干子串得到的。例如，若 $\\mathbf{S}$ 为 `0145217`，则两种可能的分割为 `014 5 21 7` 和 `0 14 52 17`。每个数字必须恰好出现在一个子串中，且每个子串必须非空。如果 $\\mathbf{S}$ 有 $L$ 个数字，则它共有 $2^{L-1}$ 种可能的分割方式。\n\n给定一个正整数 $\\mathbf{D}$，若 $\\mathbf{S}$ 的某个分割满足：对于任意两个相邻的子串，它们表示的十进制整数中至少有一个能被 $\\mathbf{D}$ 整除，则称该分割是**可被 $\\mathbf{D}$ 整除的**。若 $\\mathbf{D}=7$，上述第一个示例分割是可被整除的，因为 `014`、`21` 和 `7` 表示的整数均能被 7 整除。第二个示例分割不可被整除，因为 `52` 和 `17` 是相邻子串且均不能被 7 整除。将 `0145217` 分割为 `0145217`（即不分割）对任意 $\\mathbf{D}$ 都是可被整除的，因为此时不存在相邻子串对。\n\n给定 $\\mathbf{S}$ 和 $\\mathbf{D}$，统计 $\\mathbf{S}$ 的可被 $\\mathbf{D}$ 整除的分割数量。由于结果可能非常大，只需输出其对质数 $10^{9}+7$（即 $1000000007$）取模后的余数。\n", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后 $\\mathbf{T}$ 行，每行表示一个测试用例，包含一个数字字符串 $\\mathbf{S}$ 和一个正整数 $\\mathbf{D}$，如上所述。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为 $\\mathbf{S}$ 的可被 $\\mathbf{D}$ 整除的分割数量，对 $10^{9}+7$ 取模后的结果。\n", "hint": "**样例解释**\n\n在样例 #1 中，$\\mathbf{S}$ 的所有 16 种可被 7 整除的分割为：\n\n- 0145217,\n- 0 145217,\n- 0 14 5217,\n- 0 14 5 217,\n- 0 14 5 21 7,\n- 0 14 521 7,\n- 0 145 217,\n- 0 145 21 7,\n- 0 14521 7,\n- 014 5217,\n- 014 5 217,\n- 014 5 21 7,\n- 014 521 7,\n- 0145 217,\n- 0145 21 7, 和\n- 014521 7.\n\n在样例 #2 中，共有 $2^{5}=32$ 种分割方式。若要使两个相邻子串均不被 10 整除，则这两个子串的末尾均不能为 0。唯一满足此条件的分割是 `1 001 00` 和 `1 001 0 0`，因此其余 30 种分割均是可被 10 整除的。\n\n在样例 #3 中，没有任何子串表示的整数是偶数（即无法被 12 整除）。因此，唯一避免两个相邻子串均不被 12 整除的方式是不进行任何分割，即仅有一种分割：`5555`。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{D} \\leq 10^{6}$。\n\n**测试集 1（10 分，可见判定）**\n\n- $1 \\leq \\mathbf{S}$ 的长度 $\\leq 1000$。\n\n**测试集 2（35 分，隐藏判定）**\n\n- $1 \\leq \\mathbf{S}$ 的长度 $\\leq 10^{5}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13047", "type": "P", "difficulty": 7, "samples": [["5\n3 1 8\n3 0 0\n2 0 2\n3 1 5\n3 0 0\n2 0 2\n4 1 27\n3 4 2 4\n2 2 4 0\n4 1 28\n3 4 2 4\n2 2 4 0\n3 1 10\n1 3 1\n3 2 1", "Case #1: 3\nCase #2: 2\nCase #3: 4\nCase #4: 5\nCase #5: 3"], ["4\n3 5 7\n3 0 0\n2 0 2\n3 4 9\n3 0 0\n2 0 2\n4 11 18\n3 4 2 4\n2 2 4 0\n4 21 22\n3 4 2 4\n2 2 4 0", "Case #1: 4\nCase #2: 3\nCase #3: 5\nCase #4: 8"]], "limits": {"time": [90000, 90000, 90000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2021", "矩阵加速", "最近公共祖先 LCA", "Google Code Jam"], "title": "[GCJ 2021 Finals] Infinitree", "background": "", "description": "This problem is about finding the distance between two nodes of a strictly binary tree. Oh, is that too easy?! Ok, the tree is potentially infinite now. Keep it up and we will start going up the aleph numbers.\n\nIn this problem, a tree is either a single node $X$, or a node $X$ with two trees attached to it: a left subtree and a right subtree. In both cases, $X$ is the root of the tree. If the tree is not a single node, the roots of both the left and right subtrees are the only children of $X$.\n\nThere is a set of colors numbered from 0 to $\\mathbf{N}$, inclusive. Each node is of exactly one color. There might be zero, one, or multiple nodes of each color. Each node of color 0 (white) is a leaf node (that is, it has no children). Each node of color $i$, for $1 \\leq i \\leq \\mathbf{N}$, has exactly 2 children: the left one is color $\\mathbf{L}_{i}$ and the right one is color $\\mathbf{R}_{i}$. The root of the tree is color 1 (black). Note that the tree may have a finite or countably infinite number of nodes.\n\nFor example, the following picture illustrates a finite tree defined by the lists $\\mathbf{L}=[3,0,0]$ and $\\mathbf{R}=[2,0,2]$. Color 2 is blue and color 3 is yellow.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sj19pjad.png)\n\nThe distance between two nodes in the tree is the minimum number of steps that are needed to get from one node to the other. A step is a move from a node to its direct parent or its direct child.\n\nNodes in the tree are indexed using positive integers. The root has index $1$. Then, other nodes are indexed using consecutive integers, with nodes with smaller distances to the root being indexed first. For nodes that are equidistant to the root, nodes that are further to the left are indexed first. For example, the following picture adds indices to each node in the tree we presented before. Notice that each node's index is independent from its color.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nx04usnw.png)\n\nAs another example, the following picture shows the first $33$ nodes of an infinite tree defined by the lists $\\mathbf{L}=[3,4,2,4]$ and $\\mathbf{R}=[2,2,4,0]$. Color $4$ is green.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zc3569sp.png)\n\nGiven the lists $\\mathbf{L}$ and $\\mathbf{R}$ that define a tree and the indices of two different nodes in the tree, return the distance between those two nodes.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of three lines. The first line contains $\\mathbf{N}$, $\\mathbf{A}$, and $\\mathbf{B}$: the size of the lists that define the tree, and the indices of the two nodes whose distance you need to calculate, respectively. The second line contains $\\mathbf{N}$ integers $\\mathbf{L}_{1}$, $\\mathbf{L}_{2}$, $\\ldots$, $\\mathbf{L}_{\\mathbf{N}}$ and the third line contains $\\mathbf{N}$ integers $\\mathbf{R}_{1}$, $\\mathbf{R}_{2}$, $\\ldots$, $\\mathbf{R}_{\\mathbf{N}}$, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the distance between the nodes with indices $\\mathbf{A}$ and $\\mathbf{B}$ in the tree defined by the lists $\\mathbf{L}$ and $\\mathbf{R}$.", "hint": "**Sample Explanation**\n\nThe tree in Sample Cases #1 and #2 is the first tree shown in the statement. The tree in Sample Cases #3 and #4 is the last tree shown in the statement. The same is true for the additional samples below. In Sample Case #5, notice that some colors may not be present in the tree.\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{N} \\leq 50$.\n- $0 \\leq \\mathbf{L}_{i} \\leq \\mathbf{N}$.\n- $0 \\leq \\mathbf{R}_{i} \\leq \\mathbf{N}$.\n- $\\mathbf{A} < \\mathbf{B} \\leq 10^{18}$.\n- The tree defined by $\\mathbf{L}$ and $\\mathbf{R}$ has at least $\\mathbf{B}$ nodes.\n\n**Test Set 1 (25 Pts, Visible Verdict)**\n\n- $\\mathbf{A} = 1$.\n\n**Test Set 2 (40 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{A} \\leq 10^{18}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2021 Finals] Infinitree", "background": "", "description": "This problem is about finding the distance between two nodes of a strictly binary tree. Oh, is that too easy?! Ok, the tree is potentially infinite now. Keep it up and we will start going up the aleph numbers.\n\nIn this problem, a tree is either a single node $X$, or a node $X$ with two trees attached to it: a left subtree and a right subtree. In both cases, $X$ is the root of the tree. If the tree is not a single node, the roots of both the left and right subtrees are the only children of $X$.\n\nThere is a set of colors numbered from 0 to $\\mathbf{N}$, inclusive. Each node is of exactly one color. There might be zero, one, or multiple nodes of each color. Each node of color 0 (white) is a leaf node (that is, it has no children). Each node of color $i$, for $1 \\leq i \\leq \\mathbf{N}$, has exactly 2 children: the left one is color $\\mathbf{L}_{i}$ and the right one is color $\\mathbf{R}_{i}$. The root of the tree is color 1 (black). Note that the tree may have a finite or countably infinite number of nodes.\n\nFor example, the following picture illustrates a finite tree defined by the lists $\\mathbf{L}=[3,0,0]$ and $\\mathbf{R}=[2,0,2]$. Color 2 is blue and color 3 is yellow.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sj19pjad.png)\n\nThe distance between two nodes in the tree is the minimum number of steps that are needed to get from one node to the other. A step is a move from a node to its direct parent or its direct child.\n\nNodes in the tree are indexed using positive integers. The root has index $1$. Then, other nodes are indexed using consecutive integers, with nodes with smaller distances to the root being indexed first. For nodes that are equidistant to the root, nodes that are further to the left are indexed first. For example, the following picture adds indices to each node in the tree we presented before. Notice that each node's index is independent from its color.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nx04usnw.png)\n\nAs another example, the following picture shows the first $33$ nodes of an infinite tree defined by the lists $\\mathbf{L}=[3,4,2,4]$ and $\\mathbf{R}=[2,2,4,0]$. Color $4$ is green.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zc3569sp.png)\n\nGiven the lists $\\mathbf{L}$ and $\\mathbf{R}$ that define a tree and the indices of two different nodes in the tree, return the distance between those two nodes.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of three lines. The first line contains $\\mathbf{N}$, $\\mathbf{A}$, and $\\mathbf{B}$: the size of the lists that define the tree, and the indices of the two nodes whose distance you need to calculate, respectively. The second line contains $\\mathbf{N}$ integers $\\mathbf{L}_{1}$, $\\mathbf{L}_{2}$, $\\ldots$, $\\mathbf{L}_{\\mathbf{N}}$ and the third line contains $\\mathbf{N}$ integers $\\mathbf{R}_{1}$, $\\mathbf{R}_{2}$, $\\ldots$, $\\mathbf{R}_{\\mathbf{N}}$, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the distance between the nodes with indices $\\mathbf{A}$ and $\\mathbf{B}$ in the tree defined by the lists $\\mathbf{L}$ and $\\mathbf{R}$.", "hint": "**Sample Explanation**\n\nThe tree in Sample Cases #1 and #2 is the first tree shown in the statement. The tree in Sample Cases #3 and #4 is the last tree shown in the statement. The same is true for the additional samples below. In Sample Case #5, notice that some colors may not be present in the tree.\n\nSample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{N} \\leq 50$.\n- $0 \\leq \\mathbf{L}_{i} \\leq \\mathbf{N}$.\n- $0 \\leq \\mathbf{R}_{i} \\leq \\mathbf{N}$.\n- $\\mathbf{A} < \\mathbf{B} \\leq 10^{18}$.\n- The tree defined by $\\mathbf{L}$ and $\\mathbf{R}$ has at least $\\mathbf{B}$ nodes.\n\n**Test Set 1 (25 Pts, Visible Verdict)**\n\n- $\\mathbf{A} = 1$.\n\n**Test Set 2 (40 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{A} \\leq 10^{18}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2021 Finals] Infinitree", "background": "", "description": "本题需要计算一棵严格二叉树上两个节点之间的距离。哦，这太简单了？！好吧，现在这棵树可能是无限的。继续努力的话，我们可能要开始讨论阿列夫数了。\n\n在这道题中，一棵树要么是一个单独的节点 $X$，要么是一个节点 $X$ 附带两棵子树：左子树和右子树。无论是哪种情况，$X$ 都是这棵树的根节点。如果树不是单个节点，那么左子树和右子树的根节点是 $X$ 仅有的两个子节点。\n\n有一组颜色编号从 0 到 $\\mathbf{N}$（包括 $\\mathbf{N}$）。每个节点恰好有一种颜色。每种颜色可能有零个、一个或多个节点。颜色为 0（白色）的节点是叶节点（即没有子节点）。对于颜色为 $i$（$1 \\leq i \\leq \\mathbf{N}$）的节点，它恰好有两个子节点：左子节点的颜色为 $\\mathbf{L}_{i}$，右子节点的颜色为 $\\mathbf{R}_{i}$。树的根节点颜色为 1（黑色）。注意，这棵树的节点数量可能是有限的或可数无限的。\n\n例如，下图展示了一棵由列表 $\\mathbf{L}=[3,0,0]$ 和 $\\mathbf{R}=[2,0,2]$ 定义的有限树。颜色 2 为蓝色，颜色 3 为黄色。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sj19pjad.png)\n\n树中两个节点之间的距离是从一个节点到另一个节点所需的最少步数。每一步可以是从一个节点移动到其直接父节点或直接子节点。\n\n树中的节点用正整数编号。根节点的编号为 $1$。其他节点按以下规则编号：距离根节点较近的节点优先编号；若距离相同，则左侧的节点优先编号。例如，下图展示了之前那棵树中每个节点的编号。注意，每个节点的编号与其颜色无关。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nx04usnw.png)\n\n再举一个例子，下图展示了由列表 $\\mathbf{L}=[3,4,2,4]$ 和 $\\mathbf{R}=[2,2,4,0]$ 定义的无限树的前 $33$ 个节点。颜色 4 为绿色。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zc3569sp.png)\n\n给定定义树的列表 $\\mathbf{L}$ 和 $\\mathbf{R}$，以及树中两个不同节点的编号，返回这两个节点之间的距离。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后 $\\mathbf{T}$ 个测试用例，每个测试用例包含三行。第一行包含 $\\mathbf{N}$、$\\mathbf{A}$ 和 $\\mathbf{B}$：分别表示定义树的列表的大小，以及需要计算距离的两个节点的编号。第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{L}_{1}, \\mathbf{L}_{2}, \\ldots, \\mathbf{L}_{\\mathbf{N}}$，第三行包含 $\\mathbf{N}$ 个整数 $\\mathbf{R}_{1}, \\mathbf{R}_{2}, \\ldots, \\mathbf{R}_{\\mathbf{N}}$，如上所述。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为由 $\\mathbf{L}$ 和 $\\mathbf{R}$ 定义的树中编号为 $\\mathbf{A}$ 和 $\\mathbf{B}$ 的两个节点之间的距离。\n", "hint": "**样例解释**\n\n样例 #1 和 #2 中的树是题目描述中的第一棵树。样例 #3 和 #4 中的树是题目描述中的最后一棵树。样例 #5 中，注意某些颜色可能在树中不存在。\n\n样例测试集 2 符合测试集 2 的限制条件，但不会对提交的解决方案运行。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $1 \\leq \\mathbf{N} \\leq 50$。\n- $0 \\leq \\mathbf{L}_{i} \\leq \\mathbf{N}$。\n- $0 \\leq \\mathbf{R}_{i} \\leq \\mathbf{N}$。\n- $\\mathbf{A} < \\mathbf{B} \\leq 10^{18}$。\n- 由 $\\mathbf{L}$ 和 $\\mathbf{R}$ 定义的树至少有 $\\mathbf{B}$ 个节点。\n\n**测试集 1（25 分，可见判定）**\n\n- $\\mathbf{A} = 1$。\n\n**测试集 2（40 分，隐藏判定）**\n\n- $1 \\leq \\mathbf{A} \\leq 10^{18}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13048", "type": "P", "difficulty": 2, "samples": [["3\n4\n1 2 3 4\n2 1 4 3\n3 4 1 2\n4 3 2 1\n4\n2 2 2 2\n2 3 2 3\n2 2 2 3\n2 2 2 2\n3\n2 1 3\n1 3 2\n1 2 3", "Case #1: 4 0 0\nCase #2: 9 4 4\nCase #3: 8 0 2"]], "limits": {"time": [20000, 20000], "memory": [1048576, 1048576]}, "tags": ["模拟", "2020", "排序", "Google Code Jam"], "title": "[GCJ 2020 Qualification] Vestigium", "background": "", "description": "Vestigium means \"trace\" in Latin. In this problem we work with Latin squares and matrix traces.\n\nThe trace of a square matrix is the sum of the values on the main diagonal (which runs from the upper left to the lower right).\n\nAn $N$-by-$N$ square matrix is a *Latin square* if each cell contains one of $N$ different values, and no value is repeated within a row or a column. In this problem, we will deal only with \"natural Latin squares\" in which the $N$ values are the integers between 1 and $N$.\n\nGiven a matrix that contains only integers between 1 and $N$, we want to compute its trace and check whether it is a natural Latin square. To give some additional information, instead of simply telling us whether the matrix is a natural Latin square or not, please compute the number of rows and the number of columns that contain repeated values.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each starts with a line containing a single integer $N$: the size of the matrix to explore. Then, $N$ lines follow. The $i$-th of these lines contains $N$ integers $M_{i,1}$, $M_{i,2}$, $\\dots$, $M_{i,N}$. $M_{i,j}$ is the integer in the $i$-th row and $j$-th column of the matrix.\n", "outputFormat": "For each test case, output one line containing `Case #x: k r c`, where $x$ is the test case number (starting from 1), $k$ is the trace of the matrix, $r$ is the number of rows of the matrix that contain repeated elements, and $c$ is the number of columns of the matrix that contain repeated elements.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the input is a natural Latin square, which means no row or column has repeated elements. All four values in the main diagonal are 1, and so the trace (their sum) is 4.\n\nIn Sample Case #2, all rows and columns have repeated elements. Notice that each row or column with repeated elements is counted only once regardless of the number of elements that are repeated or how often they are repeated within the row or column. In addition, notice that some integers in the range 1 through $N$ may be absent from the input.\n\nIn Sample Case #3, the leftmost and rightmost columns have repeated elements.\n\n**Limits**\n\n**Test set 1 (7 Pts, Visible Verdict)**\n\n- $1 \\leq T \\leq 100.$\n- $2 \\leq N \\leq 100.$\n- $1 \\leq M_{i,j} \\leq N,$ for all $i, j.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Qualification] Vestigium", "background": "", "description": "Vestigium means \"trace\" in Latin. In this problem we work with Latin squares and matrix traces.\n\nThe trace of a square matrix is the sum of the values on the main diagonal (which runs from the upper left to the lower right).\n\nAn $N$-by-$N$ square matrix is a *Latin square* if each cell contains one of $N$ different values, and no value is repeated within a row or a column. In this problem, we will deal only with \"natural Latin squares\" in which the $N$ values are the integers between 1 and $N$.\n\nGiven a matrix that contains only integers between 1 and $N$, we want to compute its trace and check whether it is a natural Latin square. To give some additional information, instead of simply telling us whether the matrix is a natural Latin square or not, please compute the number of rows and the number of columns that contain repeated values.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each starts with a line containing a single integer $N$: the size of the matrix to explore. Then, $N$ lines follow. The $i$-th of these lines contains $N$ integers $M_{i,1}$, $M_{i,2}$, $\\dots$, $M_{i,N}$. $M_{i,j}$ is the integer in the $i$-th row and $j$-th column of the matrix.\n", "outputFormat": "For each test case, output one line containing `Case #x: k r c`, where $x$ is the test case number (starting from 1), $k$ is the trace of the matrix, $r$ is the number of rows of the matrix that contain repeated elements, and $c$ is the number of columns of the matrix that contain repeated elements.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the input is a natural Latin square, which means no row or column has repeated elements. All four values in the main diagonal are 1, and so the trace (their sum) is 4.\n\nIn Sample Case #2, all rows and columns have repeated elements. Notice that each row or column with repeated elements is counted only once regardless of the number of elements that are repeated or how often they are repeated within the row or column. In addition, notice that some integers in the range 1 through $N$ may be absent from the input.\n\nIn Sample Case #3, the leftmost and rightmost columns have repeated elements.\n\n**Limits**\n\n**Test set 1 (7 Pts, Visible Verdict)**\n\n- $1 \\leq T \\leq 100.$\n- $2 \\leq N \\leq 100.$\n- $1 \\leq M_{i,j} \\leq N,$ for all $i, j.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Qualification] Vestigium", "background": null, "description": "Vestigium 在拉丁语中意为“痕迹”。本题中，我们将研究拉丁方阵与矩阵的迹。\n\n一个方阵的迹是指其主对角线上所有元素的和（主对角线从左上角延伸至右下角）。\n\n一个 $N \\times N$ 的方阵被称为**拉丁方阵**，当且仅当每个单元格包含 $N$ 个不同的值，且每一行和每一列中都没有重复的值。在本题中，我们仅讨论“自然拉丁方阵”，即这些 $N$ 个值为 $1$ 到 $N$ 之间的整数。\n\n给定一个仅包含 $1$ 到 $N$ 之间整数的矩阵，我们需要计算其迹，并检查它是否是一个自然拉丁方阵。为了提供更多信息，除了简单地告诉我们矩阵是否为自然拉丁方阵外，请计算包含重复值的行数和列数。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。随后是 $T$ 个测试用例。每个测试用例的第一行包含一个整数 $N$，表示矩阵的大小。接下来的 $N$ 行中，第 $i$ 行包含 $N$ 个整数 $M_{i,1}, M_{i,2},\\dots,M_{i,N},M_{i,j}$ 表示矩阵第 $i$ 行第 $j$ 列的整数值。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: k r c`，其中 $x$ 是测试用例编号（从 $1$ 开始），$k$ 是矩阵的迹，$r$ 是包含重复元素的行数，$c$ 是包含重复元素的列数。", "hint": "**样例解释**\n\n在样例一中，输入是一个自然拉丁方阵，因此没有任何行或列包含重复元素。主对角线上的四个值均为 $1$，因此迹（它们的和）为 $4$。\n\n在样例二中，所有行和列均包含重复元素。注意，无论重复元素的数量或重复次数如何，每行或每列仅被计数一次。此外，$1$ 到 $N$ 之间的某些整数可能在输入中缺失。\n\n在样例三中，最左和最右的列包含重复元素。\n\n**数据范围**\n\n**测试集 $1$（$7$ 分，可见判定）**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq N \\leq 100$。\n- 对于所有 $i, j$，$1 \\leq M_{i,j} \\leq N$。\n\n翻译由 DeepSeek V3 完成。", "locale": "zh-CN"}}}
{"pid": "P13049", "type": "P", "difficulty": 2, "samples": [["4\n0000\n101\n111000\n1", "Case #1: 0000\nCase #2: (1)0(1)\nCase #3: (111)000\nCase #4: (1)"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["字符串", "贪心", "2020", "Google Code Jam"], "title": "[GCJ 2020 Qualification] Nesting Depth", "background": "", "description": "tl;dr: Given a string of digits $\\mathbf{S}$, insert a minimum number of opening and closing parentheses into it such that the resulting string is balanced and each digit $d$ is inside exactly $d$ pairs of matching parentheses.\n\nLet the *nesting* of two parentheses within a string be the substring that occurs strictly between them. An opening parenthesis and a closing parenthesis that is further to its right are said to *match* if their nesting is empty, or if every parenthesis in their nesting matches with another parenthesis in their nesting. The *nesting depth* of a position $p$ is the number of pairs of matching parentheses $m$ such that $p$ is included in the nesting of $m$.\n\nFor example, in the following strings, all digits match their nesting depth: 0((2)1), (((3))1(2)), ((((4)))), ((2))((2))(1). The first three strings have minimum length among those that have the same digits in the same order, but the last one does not since ((22)1) also has the digits 221 and is shorter.\n\nGiven a string of digits $\\mathbf{S}$, find another string $\\mathbf{S}'$, comprised of parentheses and digits, such that:\n\n* all parentheses in $\\mathbf{S}'$ match some other parenthesis,\n* removing any and all parentheses from $\\mathbf{S}'$ results in $\\mathbf{S}$,\n* each digit in $\\mathbf{S}'$ is equal to its nesting depth, and\n* $\\mathbf{S}'$ is of minimum length.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line represents a test case and contains only the string $\\mathbf{S}$.", "outputFormat": "For each test case, output one line containing case #x: y, where $x$ is the test case number (starting from 1) and $y$ is the string $\\mathbf{S}'$ defined above.", "hint": "**Sample Explanation**\n\nThe strings ()0000(), (1)0(((()))1) and (1)(11)000 are not valid solutions to Sample Cases #1, #2 and #3, respectively, only because they are not of minimum length. In addition, 1)( and )(1 are not valid solutions to Sample Case #4 because they contain unmatched parentheses and the nesting depth is 0 at the position where there is a 1.\n\nYou can create sample inputs that are valid only for Test Set 2 by removing the parentheses from the example strings mentioned in the problem statement.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq$ length of $\\mathbf{S} \\leq 100$.\n\n**Test set 1 (5 Pts, Visible Verdict)**\n\n- Each character in $\\mathbf{S}$ is either 0 or 1 .\n\n**Test set 2 (11 Pts, Visible Verdict)**\n\n- Each character in $\\mathbf{S}$ is a decimal digit between 0 and 9 , inclusive.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Qualification] Nesting Depth", "background": "", "description": "tl;dr: Given a string of digits $\\mathbf{S}$, insert a minimum number of opening and closing parentheses into it such that the resulting string is balanced and each digit $d$ is inside exactly $d$ pairs of matching parentheses.\n\nLet the *nesting* of two parentheses within a string be the substring that occurs strictly between them. An opening parenthesis and a closing parenthesis that is further to its right are said to *match* if their nesting is empty, or if every parenthesis in their nesting matches with another parenthesis in their nesting. The *nesting depth* of a position $p$ is the number of pairs of matching parentheses $m$ such that $p$ is included in the nesting of $m$.\n\nFor example, in the following strings, all digits match their nesting depth: 0((2)1), (((3))1(2)), ((((4)))), ((2))((2))(1). The first three strings have minimum length among those that have the same digits in the same order, but the last one does not since ((22)1) also has the digits 221 and is shorter.\n\nGiven a string of digits $\\mathbf{S}$, find another string $\\mathbf{S}'$, comprised of parentheses and digits, such that:\n\n* all parentheses in $\\mathbf{S}'$ match some other parenthesis,\n* removing any and all parentheses from $\\mathbf{S}'$ results in $\\mathbf{S}$,\n* each digit in $\\mathbf{S}'$ is equal to its nesting depth, and\n* $\\mathbf{S}'$ is of minimum length.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each line represents a test case and contains only the string $\\mathbf{S}$.", "outputFormat": "For each test case, output one line containing case #x: y, where $x$ is the test case number (starting from 1) and $y$ is the string $\\mathbf{S}'$ defined above.", "hint": "**Sample Explanation**\n\nThe strings ()0000(), (1)0(((()))1) and (1)(11)000 are not valid solutions to Sample Cases #1, #2 and #3, respectively, only because they are not of minimum length. In addition, 1)( and )(1 are not valid solutions to Sample Case #4 because they contain unmatched parentheses and the nesting depth is 0 at the position where there is a 1.\n\nYou can create sample inputs that are valid only for Test Set 2 by removing the parentheses from the example strings mentioned in the problem statement.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq$ length of $\\mathbf{S} \\leq 100$.\n\n**Test set 1 (5 Pts, Visible Verdict)**\n\n- Each character in $\\mathbf{S}$ is either 0 or 1 .\n\n**Test set 2 (11 Pts, Visible Verdict)**\n\n- Each character in $\\mathbf{S}$ is a decimal digit between 0 and 9 , inclusive.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Qualification] Nesting Depth", "background": "", "description": "**简要题意**：给定一个数字字符串 $\\mathbf{S}$，在其中插入最少数量的左右括号，使得生成的字符串是平衡的，并且每个数字 $d$ 恰好位于 $d$ 对匹配的括号内。\n\n我们定义字符串中两个括号的**嵌套**为它们之间严格包含的子串。一个左括号和其右侧的一个右括号称为**匹配**，如果它们的嵌套为空，或者它们的嵌套中的每个括号都与另一个括号匹配。位置 $p$ 的**嵌套深度**是包含 $p$ 的匹配括号对的数量 $m$。\n\n例如，在以下字符串中，所有数字都与其嵌套深度匹配：`0((2)1)`、`(((3))1(2))`、`((((4))))`、`((2))((2))(1)`。前三个字符串在保持数字顺序相同的情况下长度最短，但最后一个不是，因为 `((22)1)` 也包含数字 `221` 且更短。\n\n给定一个数字字符串 $\\mathbf{S}$，找到另一个由括号和数字组成的字符串 $\\mathbf{S}'$，满足以下条件：\n\n* $\\mathbf{S}'$ 中的所有括号都与其他括号匹配；\n* 从 $\\mathbf{S}'$ 中移除所有括号后得到 $\\mathbf{S}$；\n* $\\mathbf{S}'$ 中的每个数字等于其嵌套深度；\n* $\\mathbf{S}'$ 的长度最短。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 行，每行表示一个测试用例，仅包含字符串 $\\mathbf{S}$。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是上述定义的字符串 $\\mathbf{S}'$。\n", "hint": "**样例解释**\n\n字符串 `()0000()`、`(1)0(((()))1)` 和 `(1)(11)000` 分别不是样例 #1、#2 和 #3 的有效解，因为它们不是最短的。此外，`1)(` 和 `)(1` 不是样例 #4 的有效解，因为它们包含未匹配的括号，且在数字 `1` 的位置嵌套深度为 0。\n\n你可以通过移除题目描述中提到的示例字符串的括号来创建仅适用于测试集 2 的样例输入。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$；\n- $1 \\leq \\mathbf{S}$ 的长度 $\\leq 100$。\n\n**测试集 1（5 分，可见判定）**\n\n- $\\mathbf{S}$ 中的每个字符为 `0` 或 `1`。\n\n**测试集 2（11 分，可见判定）**\n\n- $\\mathbf{S}$ 中的每个字符为 `0` 到 `9` 的数字（含）。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13050", "type": "P", "difficulty": 3, "samples": [["4\n3\n360 480\n420 540\n600 660\n3\n0 1440\n1 3\n2 4\n5\n99 150\n1 100\n100 301\n2 5\n150 250\n2\n0 720\n720 1440", "Case #1: CJC\nCase #2: IMPOSSIBLE\nCase #3: JCCJJ\nCase #4: CC"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "2020", "Special Judge", "Google Code Jam"], "title": "[GCJ 2020 Qualification] Parenting Partnering Returns", "background": "", "description": "Cameron and Jamie's kid is almost 3 years old! However, even though the child is more independent now, scheduling kid activities and domestic necessities is still a challenge for the couple.\n\nCameron and Jamie have a list of $\\mathbf{N}$ activities to take care of during the day. Each activity happens during a specified interval during the day. They need to assign each activity to one of them, so that neither of them is responsible for two activities that overlap. An activity that ends at time $\\mathbf{t}$ is not considered to overlap with another activity that starts at time $\\mathbf{t}$.\n\nFor example, suppose that Jamie and Cameron need to cover 3 activities: one running from 18:00 to 20:00, another from 19:00 to 21:00 and another from 22:00 to 23:00. One possibility would be for Jamie to cover the activity running from 19:00 to 21:00, with Cameron covering the other two. Another valid schedule would be for Cameron to cover the activity from 18:00 to 20:00 and Jamie to cover the other two. Notice that the first two activities overlap in the time between 19:00 and 20:00, so it is impossible to assign both of those activities to the same partner.\n\nGiven the starting and ending times of each activity, find any schedule that does not require the same person to cover overlapping activities, or say that it is impossible.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing a single integer $\\mathbf{N}$, the number of activities to assign. Then, $\\mathbf{N}$ more lines follow. The $\\mathbf{i}$-th of these lines (counting starting from 1) contains two integers $\\mathbf{S}_{\\mathbf{i}}$ and $\\mathbf{E}_{\\mathbf{i}}$. The $\\mathbf{i}$-th activity starts exactly $\\mathbf{S}_{\\mathbf{i}}$ minutes after midnight and ends exactly $\\mathbf{E}_{\\mathbf{i}}$ minutes after midnight.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathbf{x}$ is the test case number (starting from 1) and $\\mathbf{y}$ is IMPOSSIBLE if there is no valid schedule according to the above rules, or a string of exactly $\\mathbf{N}$ characters otherwise. The $\\mathbf{i}$-th character in $\\mathbf{y}$ must be $\\mathbf{c}$ if the $\\mathbf{i}$-th activity is assigned to Cameron in your proposed schedule, and $\\mathbf{j}$ if it is assigned to Jamie.\n\nIf there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one described in the problem statement. As mentioned above, there are other valid solutions, like `JCJ` and `JCC`.\n\nIn Sample Case #2, all three activities overlap with each other. Assigning them all would mean someone would end up with at least two overlapping activities, so there is no valid schedule.\n\nIn Sample Case #3, notice that Cameron ends an activity and starts another one at minute 100 .\n\nIn Sample Case #4, any schedule would be valid. Specifically, it is OK for one partner to do all activities.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{S}_{\\mathbf{i}}<\\mathbf{E}_{\\mathbf{i}} \\leq 24 \\times 60$.\n\n**Test set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10$.\n\n**Test set 2 (12 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Qualification] Parenting Partnering Returns", "background": "", "description": "Cameron and Jamie's kid is almost 3 years old! However, even though the child is more independent now, scheduling kid activities and domestic necessities is still a challenge for the couple.\n\nCameron and Jamie have a list of $\\mathbf{N}$ activities to take care of during the day. Each activity happens during a specified interval during the day. They need to assign each activity to one of them, so that neither of them is responsible for two activities that overlap. An activity that ends at time $\\mathbf{t}$ is not considered to overlap with another activity that starts at time $\\mathbf{t}$.\n\nFor example, suppose that Jamie and Cameron need to cover 3 activities: one running from 18:00 to 20:00, another from 19:00 to 21:00 and another from 22:00 to 23:00. One possibility would be for Jamie to cover the activity running from 19:00 to 21:00, with Cameron covering the other two. Another valid schedule would be for Cameron to cover the activity from 18:00 to 20:00 and Jamie to cover the other two. Notice that the first two activities overlap in the time between 19:00 and 20:00, so it is impossible to assign both of those activities to the same partner.\n\nGiven the starting and ending times of each activity, find any schedule that does not require the same person to cover overlapping activities, or say that it is impossible.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing a single integer $\\mathbf{N}$, the number of activities to assign. Then, $\\mathbf{N}$ more lines follow. The $\\mathbf{i}$-th of these lines (counting starting from 1) contains two integers $\\mathbf{S}_{\\mathbf{i}}$ and $\\mathbf{E}_{\\mathbf{i}}$. The $\\mathbf{i}$-th activity starts exactly $\\mathbf{S}_{\\mathbf{i}}$ minutes after midnight and ends exactly $\\mathbf{E}_{\\mathbf{i}}$ minutes after midnight.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathbf{x}$ is the test case number (starting from 1) and $\\mathbf{y}$ is IMPOSSIBLE if there is no valid schedule according to the above rules, or a string of exactly $\\mathbf{N}$ characters otherwise. The $\\mathbf{i}$-th character in $\\mathbf{y}$ must be $\\mathbf{c}$ if the $\\mathbf{i}$-th activity is assigned to Cameron in your proposed schedule, and $\\mathbf{j}$ if it is assigned to Jamie.\n\nIf there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one described in the problem statement. As mentioned above, there are other valid solutions, like `JCJ` and `JCC`.\n\nIn Sample Case #2, all three activities overlap with each other. Assigning them all would mean someone would end up with at least two overlapping activities, so there is no valid schedule.\n\nIn Sample Case #3, notice that Cameron ends an activity and starts another one at minute 100 .\n\nIn Sample Case #4, any schedule would be valid. Specifically, it is OK for one partner to do all activities.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $0 \\leq \\mathbf{S}_{\\mathbf{i}}<\\mathbf{E}_{\\mathbf{i}} \\leq 24 \\times 60$.\n\n**Test set 1 (7 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 10$.\n\n**Test set 2 (12 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Qualification] Parenting Partnering Returns", "background": "", "description": "Cameron 和 Jamie 的孩子快 3 岁了！虽然孩子现在更独立了，但安排孩子的活动和家务对这对夫妇来说仍然是个挑战。\n\nCameron 和 Jamie 需要共同完成 $\\mathbf{N}$ 项当天的活动。每项活动都在一天中的特定时间段进行。他们需要将这些活动分配给两人，确保每人不会被分配到时间重叠的两项活动。注意：一项在时间 $\\mathbf{t}$ 结束的活动与另一项在时间 $\\mathbf{t}$ 开始的活动不算重叠。\n\n例如，假设 Jamie 和 Cameron 需要安排 3 项活动：第一项从 18:00 到 20:00，第二项从 19:00 到 21:00，第三项从 22:00 到 23:00。一种可能的分配方式是 Jamie 负责第二项活动（19:00-21:00），Cameron 负责另外两项。另一种有效分配是 Cameron 负责第一项活动（18:00-20:00），Jamie 负责另外两项。注意前两项活动在 19:00 至 20:00 期间重叠，因此不能将它们分配给同一个人。\n\n给定每项活动的开始和结束时间，找出任意一个不要求同一人承担重叠活动的排班方案，或者判定这是不可能的。\n", "inputFormat": "输入的第一行包含测试用例数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含一个整数 $\\mathbf{N}$，表示活动数量。接下来 $\\mathbf{N}$ 行中，第 $\\mathbf{i}$ 行（从 1 开始计数）包含两个整数 $\\mathbf{S}_{\\mathbf{i}}$ 和 $\\mathbf{E}_{\\mathbf{i}}$，表示第 $\\mathbf{i}$ 项活动从午夜后 $\\mathbf{S}_{\\mathbf{i}}$ 分钟开始，到午夜后 $\\mathbf{E}_{\\mathbf{i}}$ 分钟结束。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $\\mathbf{x}$ 是测试用例编号（从 1 开始），$\\mathbf{y}$ 如果不存在有效排班方案则输出 `IMPOSSIBLE`，否则输出一个长度为 $\\mathbf{N}$ 的字符串。字符串的第 $\\mathbf{i}$ 个字符如果是 $\\mathbf{c}$ 表示第 $\\mathbf{i}$ 项活动分配给 Cameron，$\\mathbf{j}$ 表示分配给 Jamie。\n\n若存在多个解，输出任意一个即可。", "hint": "**样例解释**\n\n样例 #1 对应题目描述中的情况。如所述，还存在其他有效解，例如 `JCJ` 和 `JCC`。\n\n样例 #2 中，三项活动互相重叠。无论如何分配都会导致至少一人承担两项重叠活动，因此无解。\n\n样例 #3 中，注意 Cameron 在 100 分钟时结束一项活动并立即开始另一项活动。\n\n样例 #4 中，任意分配方案都有效。特别地，允许一人承担所有活动。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$；\n- $0 \\leq \\mathbf{S}_{\\mathbf{i}} < \\mathbf{E}_{\\mathbf{i}} \\leq 24 \\times 60$。\n\n**测试集 1（7 分，可见判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 10$。\n\n**测试集 2（12 分，可见判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 1000$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13051", "type": "P", "difficulty": 5, "samples": [["", ""]], "limits": {"time": [40000, 40000, 40000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2020", "交互题", "Special Judge", "Google Code Jam"], "title": "[GCJ 2020 Qualification] ESAb ATAd", "background": "", "description": "Last year, a research consortium had some trouble with a distributed database system that sometimes lost pieces of the data. You do not need to read or understand that problem in order to solve this one!\n\nThe consortium has decided that distributed systems are too complicated, so they are storing $\\mathbf{B}$ bits of important information in a single array on one awesome machine. As an additional layer of security, they have made it difficult to obtain the information quickly; the user must query for a bit position between 1 and $\\mathbf{B}$, and then they receive that bit of the stored array as a response.\n\nUnfortunately, this ultra-modern machine is subject to random quantum fluctuations! Specifically, after every 1st, 11th, 21st, 31st... etc. query is sent, but before the response is given, quantum fluctuation causes exactly one of the following four effects, with equal probability:\n\n- 25% of the time, the array is complemented: every 0 becomes a 1, and vice versa.\n- 25% of the time, the array is reversed: the first bit swaps with the last bit, the second bit swaps with the second-to-last bit, and so on.\n- 25% of the time, both of the things above (complementation and reversal) happen to the array. (Notice that the order in which they happen does not matter.)\n- 25% of the time, nothing happens to the array.\n\nMoreover, there is no indication of what effect the quantum fluctuation has had each time. The consortium is now concerned, and it has hired you to get its precious data back, in whatever form it is in! Can you find the entire array, such that your answer is accurate as of the time that you give it? Answering does not count as a query, so if you answer after your 30th query, for example, the array will be the same as it was after your 21st through 30th queries.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing two integers $\\mathbf{T}$ and $\\mathbf{B}$ : the number of test cases and the number of bits in the array, respectively. Note that $\\mathbf{B}$ is the same for every test case.\n\nThen, you need to process $\\mathbf{T}$ test cases. In each case, the judge begins with a predetermined $\\mathbf{B}$-bit array; note that this array can vary from test case to test case, and is not necessarily chosen at random. Then, you may make up to 150 queries of the following form:\n\n* Your program outputs one line containing a single integer $\\mathrm{P}$ between 1 and $\\mathbf{B}$, inclusive, indicating which position in the array you wish to look at.\n* If the number of queries you have made so far ends with a 1 , the judge chooses one of the four possibilities described above (complementation, reversal, complementation + reversal, or nothing), uniformly at random and independently of all other choices, and alters the stored array accordingly. (Notice that this will happen on the very first query you make.)\n* The judge responds with one line containing a single character 0 or 1 , the value it currently has stored at bit position $\\mathrm{P}$, or $\\mathrm{N}$ if you provided a malformed line (e.g., an invalid position).\n\nThen, after you have made as many of the 150 queries above as you want, you must make one more exchange of the following form:\n\n* Your program outputs one line containing a string of $\\mathbf{B}$ characters, each of which is 0 or 1 , representing the bits currently stored in the array (which will not necessarily match the bits that were initially present!)\n* The judge responds with one line containing a single letter: uppercase $\\mathrm{Y}$ if your answer was correct, and uppercase $\\mathrm{N}$ if it was not (or you provided a malformed line). If you receive $\\mathrm{Y}$, you should begin the next test case, or stop sending input if there are no more test cases.\n\nAfter the judge sends $\\mathrm{N}$ to your input stream, it will not send any other output. If your program continues to wait for the judge after receiving $\\mathrm{N}$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "The following interaction corresponds to Test Set 1.\n\n```\n  t, b = readline_int_list()      // reads 100 into t and 10 into b.\n  // The judge starts with the predetermined array for this test case:\n  // 0001101111. (Note: the actual Test Set 1 will not necessarily\n  // use this array.)\n  printline 1 to stdout   // we ask about position 1.\n  flush stdout\n  // Since this is our 1st query, and 1 is 1 mod 10, the judge secretly and\n  // randomly chooses one of the four possible quantum fluctuation effects, as\n  // described above. It happens to choose complementation + reversal, so now\n  // the stored value is 0000100111.\n  r = readline_chr()      // reads 0.\n  printline 6 to stdout   // we ask about position 6.\n  flush stdout\n  // Since this is our 2nd query, and 2 is 2 mod 10, the judge does not choose\n  // a quantum fluctuation effect.\n  r = readline_chr()      // reads 0.\n  ...\n  // We have omitted the third through tenth queries in this example.\n  ...\n  printline 1 to stdout   // we decide to ask about position 1 again.\n  flush stdout\n  // Since this is our 11th query, and 11 is 1 mod 10, the judge secretly and\n  // randomly chooses a quantum fluctuation effect, and happens to get\n  // reversal, so now the stored value is 1110010000.\n  r = readline_chr()      // reads 1.\n  printline 1110110000 to stdout   // we try to answer. why?!?!\n  flush stdout\n  ok = readline_chr()     // reads N -- we have made a mistake!\n  exit                    // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\n**Limits**\n\n$1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test set 1 (1 Pts, Visible Verdict)**\n\n- $\\mathrm{B}=10$.\n\n**Test set 2 (9 Pts, Visible Verdict)**\n\n- $\\mathrm{B}=20$.\n\n**Test set 3 (16 Pts, Hidden Verdict)**\n\n- $\\mathrm{B}=100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Qualification] ESAb ATAd", "background": "", "description": "Last year, a research consortium had some trouble with a distributed database system that sometimes lost pieces of the data. You do not need to read or understand that problem in order to solve this one!\n\nThe consortium has decided that distributed systems are too complicated, so they are storing $\\mathbf{B}$ bits of important information in a single array on one awesome machine. As an additional layer of security, they have made it difficult to obtain the information quickly; the user must query for a bit position between 1 and $\\mathbf{B}$, and then they receive that bit of the stored array as a response.\n\nUnfortunately, this ultra-modern machine is subject to random quantum fluctuations! Specifically, after every 1st, 11th, 21st, 31st... etc. query is sent, but before the response is given, quantum fluctuation causes exactly one of the following four effects, with equal probability:\n\n- 25% of the time, the array is complemented: every 0 becomes a 1, and vice versa.\n- 25% of the time, the array is reversed: the first bit swaps with the last bit, the second bit swaps with the second-to-last bit, and so on.\n- 25% of the time, both of the things above (complementation and reversal) happen to the array. (Notice that the order in which they happen does not matter.)\n- 25% of the time, nothing happens to the array.\n\nMoreover, there is no indication of what effect the quantum fluctuation has had each time. The consortium is now concerned, and it has hired you to get its precious data back, in whatever form it is in! Can you find the entire array, such that your answer is accurate as of the time that you give it? Answering does not count as a query, so if you answer after your 30th query, for example, the array will be the same as it was after your 21st through 30th queries.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing two integers $\\mathbf{T}$ and $\\mathbf{B}$ : the number of test cases and the number of bits in the array, respectively. Note that $\\mathbf{B}$ is the same for every test case.\n\nThen, you need to process $\\mathbf{T}$ test cases. In each case, the judge begins with a predetermined $\\mathbf{B}$-bit array; note that this array can vary from test case to test case, and is not necessarily chosen at random. Then, you may make up to 150 queries of the following form:\n\n* Your program outputs one line containing a single integer $\\mathrm{P}$ between 1 and $\\mathbf{B}$, inclusive, indicating which position in the array you wish to look at.\n* If the number of queries you have made so far ends with a 1 , the judge chooses one of the four possibilities described above (complementation, reversal, complementation + reversal, or nothing), uniformly at random and independently of all other choices, and alters the stored array accordingly. (Notice that this will happen on the very first query you make.)\n* The judge responds with one line containing a single character 0 or 1 , the value it currently has stored at bit position $\\mathrm{P}$, or $\\mathrm{N}$ if you provided a malformed line (e.g., an invalid position).\n\nThen, after you have made as many of the 150 queries above as you want, you must make one more exchange of the following form:\n\n* Your program outputs one line containing a string of $\\mathbf{B}$ characters, each of which is 0 or 1 , representing the bits currently stored in the array (which will not necessarily match the bits that were initially present!)\n* The judge responds with one line containing a single letter: uppercase $\\mathrm{Y}$ if your answer was correct, and uppercase $\\mathrm{N}$ if it was not (or you provided a malformed line). If you receive $\\mathrm{Y}$, you should begin the next test case, or stop sending input if there are no more test cases.\n\nAfter the judge sends $\\mathrm{N}$ to your input stream, it will not send any other output. If your program continues to wait for the judge after receiving $\\mathrm{N}$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "The following interaction corresponds to Test Set 1.\n\n```\n  t, b = readline_int_list()      // reads 100 into t and 10 into b.\n  // The judge starts with the predetermined array for this test case:\n  // 0001101111. (Note: the actual Test Set 1 will not necessarily\n  // use this array.)\n  printline 1 to stdout   // we ask about position 1.\n  flush stdout\n  // Since this is our 1st query, and 1 is 1 mod 10, the judge secretly and\n  // randomly chooses one of the four possible quantum fluctuation effects, as\n  // described above. It happens to choose complementation + reversal, so now\n  // the stored value is 0000100111.\n  r = readline_chr()      // reads 0.\n  printline 6 to stdout   // we ask about position 6.\n  flush stdout\n  // Since this is our 2nd query, and 2 is 2 mod 10, the judge does not choose\n  // a quantum fluctuation effect.\n  r = readline_chr()      // reads 0.\n  ...\n  // We have omitted the third through tenth queries in this example.\n  ...\n  printline 1 to stdout   // we decide to ask about position 1 again.\n  flush stdout\n  // Since this is our 11th query, and 11 is 1 mod 10, the judge secretly and\n  // randomly chooses a quantum fluctuation effect, and happens to get\n  // reversal, so now the stored value is 1110010000.\n  r = readline_chr()      // reads 1.\n  printline 1110110000 to stdout   // we try to answer. why?!?!\n  flush stdout\n  ok = readline_chr()     // reads N -- we have made a mistake!\n  exit                    // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\n**Limits**\n\n$1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test set 1 (1 Pts, Visible Verdict)**\n\n- $\\mathrm{B}=10$.\n\n**Test set 2 (9 Pts, Visible Verdict)**\n\n- $\\mathrm{B}=20$.\n\n**Test set 3 (16 Pts, Hidden Verdict)**\n\n- $\\mathrm{B}=100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Qualification] ESAb ATAd", "background": "", "description": "去年，一个研究联盟在使用分布式数据库系统时遇到了问题，该系统有时会丢失部分数据。不过你不需要理解那个问题就能解决本题！\n\n该联盟认为分布式系统过于复杂，于是决定将 $\\mathbf{B}$ 位重要信息存储在一台超级计算机的单个数组中。为了增加安全性，他们设置了获取信息的障碍：用户必须查询 1 到 $\\mathbf{B}$ 之间的位位置，才能获得该位存储的值。\n\n不幸的是，这台超现代计算机会受到随机量子涨落的影响！具体来说，在发送第 1、11、21、31...次查询后（但在返回响应前），量子涨落会以均等概率（各 25%）引发以下四种效应之一：\n\n* 数组取反：所有 0 变 1，所有 1 变 0；\n* 数组反转：第 1 位与第 $\\mathbf{B}$ 位交换，第 2 位与第 $\\mathbf{B}-1$ 位交换，以此类推；\n* 同时发生取反和反转（顺序无关）；\n* 数组保持不变。\n\n每次量子涨落的影响没有任何提示。联盟现在非常担忧，雇佣你来恢复这些珍贵数据（无论它们当前处于何种状态）！你能否找出整个数组，使得你的答案在提交时是准确的？注意：提交答案不算作查询，例如如果你在第 30 次查询后提交答案，数组状态将与第 21-30 次查询期间的状态一致。\n\n### 交互协议\n\n这是一个交互题。\n\n初始时，你的程序应读取包含两个整数 $\\mathbf{T}$ 和 $\\mathbf{B}$ 的单行输入：分别表示测试用例数量和数组位数。注意所有测试用例的 $\\mathbf{B}$ 相同。\n\n接着处理 $\\mathbf{T}$ 个测试用例。每个用例中，评测系统会预设一个 $\\mathbf{B}$ 位数组（注意该数组可能因用例而异，且不一定是随机生成的）。你可以进行最多 150 次如下形式的查询：\n\n* 你的程序输出 1 到 $\\mathbf{B}$ 之间的整数 $\\mathrm{P}$，表示要查询的位位置；\n* 若当前查询次数是第 1、11、21...次（即模 10 余 1），评测系统会随机选择上述四种效应之一（独立于之前的选择）改变数组；\n* 评测系统返回单字符 0 或 1 表示当前 $\\mathrm{P}$ 位的值，若 $\\mathrm{P}$ 非法则返回 $\\mathrm{N}$。\n\n完成查询后，你必须进行如下最终交互：\n\n* 你的程序输出由 $\\mathbf{B}$ 个 0/1 组成的字符串，表示当前数组状态（可能与初始状态不同）；\n* 评测系统返回 $\\mathrm{Y}$ 表示答案正确，$\\mathrm{N}$ 表示错误（或格式非法）。收到 $\\mathrm{Y}$ 后应处理下一个测试用例，若无更多用例则终止程序。\n\n当评测系统返回 $\\mathrm{N}$ 后，将不再发送任何输出。若你的程序继续等待会导致超时错误。注意：你需要确保程序及时退出以避免超时错误。若内存超限或运行时错误，将得到相应判果。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "以下交互对应测试集 1：\n\n```\nt, b = readline_int_list() // 读取 t=100 和 b=10\n// 评测系统初始数组：0001101111（实际测试集 1 不一定使用此数组）\nprintline 1 // 查询第 1 位\nflush stdout\n// 这是第 1 次查询（1 mod 10），系统随机选择取反+反转，数组变为 0000100111\nr = readline_chr() // 返回 0\nprintline 6 // 查询第 6 位\nflush stdout\n// 第 2 次查询（2 mod 10），无量子涨落\nr = readline_chr() // 返回 0\n...\n// 此处省略第 3-10 次查询\n...\nprintline 1 // 再次查询第 1 位\nflush stdout\n// 第 11 次查询（11 mod 10），系统随机选择反转，数组变为 1110010000\nr = readline_chr() // 返回 1\nprintline 1110110000 // 尝试提交错误答案\nflush stdout\nok = readline_chr() // 返回 N\nexit // 退出以避免超时错误\n```\n\n可使用[交互测试工具](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)进行本地测试。\n\n**数据范围**\n\n$1 \\leq \\mathbf{T} \\leq 100$\n\n**测试集 1（1 分，可见判果）**\n\n- $\\mathrm{B}=10$\n\n**测试集 2（9 分，可见判果）**\n\n- $\\mathrm{B}=20$\n\n**测试集 3（16 分，隐藏判果）**\n\n- $\\mathrm{B}=100$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13052", "type": "P", "difficulty": 6, "samples": [["2\n3 6\n2 3", "Case #1: POSSIBLE\n2 1 3\n3 2 1\n1 3 2\nCase #2: IMPOSSIBLE"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2020", "Special Judge", "构造", "Ad-hoc", "Google Code Jam"], "title": "[GCJ 2020 Qualification] Indicium", "background": "", "description": "Indicium means \"trace\" in Latin. In this problem we work with Latin squares and matrix traces.\n\nA Latin square is an $\\mathbf{N}$-by-$\\mathbf{N}$ square matrix in which each cell contains one of $\\mathbf{N}$ different values, such that no value is repeated within a row or a column. In this problem, we will deal only with \"natural Latin squares\" in which the $\\mathbf{N}$ values are the integers between 1 and $\\mathbf{N}$.\n\nThe trace of a square matrix is the sum of the values on the main diagonal (which runs from the upper left to the lower right).\n\nGiven values $\\mathbf{N}$ and $\\mathbf{K}$, produce any $\\mathbf{N}$-by-$\\mathbf{N}$ \"natural Latin square\" with trace $\\mathbf{K}$, or say it is impossible. For example, here are two possible answers for $\\mathbf{N}=3, \\mathbf{K}=6$. In each case, the values that contribute to the trace are underlined.\n\n$\\begin{array}{llll}\\underline{2} & 1 & 3 & \\underline{3} \\\\3 & \\underline{2} & 1 & 1 \\\\1 & 3 & \\underline{2} & 2\\end{array} \\begin{array}{lll}1 & 2 \\\\ \\underline{2} & 3 \\\\3 & \\underline{1}\\end{array}$\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line containing two integers $\\mathbf{N}$ and $\\mathbf{K}$ : the desired size of the matrix and the desired trace.\n\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if there is no answer for the given parameters or POSSIBLE otherwise. In the latter case, output $\\mathbf{N}$ more lines of $\\mathbf{N}$ integers each, representing a valid \"natural Latin square\" with a trace of $\\mathbf{K}$, as described above.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one described in the problem statement.\n\nSample Case #2 has no answer. The only possible 2-by-2 \"natural Latin squares\" are as follows:\n\n```\n1 2 2 1\n2 1 1 2\n```\n\nThese have traces of 2 and 4, respectively. There is no way to get a trace of 3.\n\n**Limits**\n\n- $\\mathrm{N} \\leqslant \\mathrm{K} \\leqslant \\mathrm{N}^{2}$.\n\n**Test set 1 (7 Pts, Visible Verdict)**\n\n- $\\mathrm{T}=44$.\n- $2 \\leqslant \\mathrm{N} \\leqslant 5$.\n\n**Test set 2 (25 Pts, Hidden Verdict)**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $2 \\leqslant \\mathrm{N} \\leqslant 50$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Qualification] Indicium", "background": "", "description": "Indicium means \"trace\" in Latin. In this problem we work with Latin squares and matrix traces.\n\nA Latin square is an $\\mathbf{N}$-by-$\\mathbf{N}$ square matrix in which each cell contains one of $\\mathbf{N}$ different values, such that no value is repeated within a row or a column. In this problem, we will deal only with \"natural Latin squares\" in which the $\\mathbf{N}$ values are the integers between 1 and $\\mathbf{N}$.\n\nThe trace of a square matrix is the sum of the values on the main diagonal (which runs from the upper left to the lower right).\n\nGiven values $\\mathbf{N}$ and $\\mathbf{K}$, produce any $\\mathbf{N}$-by-$\\mathbf{N}$ \"natural Latin square\" with trace $\\mathbf{K}$, or say it is impossible. For example, here are two possible answers for $\\mathbf{N}=3, \\mathbf{K}=6$. In each case, the values that contribute to the trace are underlined.\n\n$\\begin{array}{llll}\\underline{2} & 1 & 3 & \\underline{3} \\\\3 & \\underline{2} & 1 & 1 \\\\1 & 3 & \\underline{2} & 2\\end{array} \\begin{array}{lll}1 & 2 \\\\ \\underline{2} & 3 \\\\3 & \\underline{1}\\end{array}$\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line containing two integers $\\mathbf{N}$ and $\\mathbf{K}$ : the desired size of the matrix and the desired trace.\n\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if there is no answer for the given parameters or POSSIBLE otherwise. In the latter case, output $\\mathbf{N}$ more lines of $\\mathbf{N}$ integers each, representing a valid \"natural Latin square\" with a trace of $\\mathbf{K}$, as described above.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one described in the problem statement.\n\nSample Case #2 has no answer. The only possible 2-by-2 \"natural Latin squares\" are as follows:\n\n```\n1 2 2 1\n2 1 1 2\n```\n\nThese have traces of 2 and 4, respectively. There is no way to get a trace of 3.\n\n**Limits**\n\n- $\\mathrm{N} \\leqslant \\mathrm{K} \\leqslant \\mathrm{N}^{2}$.\n\n**Test set 1 (7 Pts, Visible Verdict)**\n\n- $\\mathrm{T}=44$.\n- $2 \\leqslant \\mathrm{N} \\leqslant 5$.\n\n**Test set 2 (25 Pts, Hidden Verdict)**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $2 \\leqslant \\mathrm{N} \\leqslant 50$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Qualification] Indicium", "background": null, "description": "Indicium 在拉丁语中意为\"迹\"。本题中我们将研究拉丁方阵及其矩阵迹。\n\n一个拉丁方阵是指 $\\mathbf{N} \\times \\mathbf{N}$ 的方阵，其中每个单元格包含 $\\mathbf{N}$ 个不同值之一，且每行每列都不重复出现相同值。在本题中，我们仅处理\"自然拉丁方阵\"，即这些 $\\mathbf{N}$ 个值为 1 到 $\\mathbf{N}$ 的整数。\n\n方阵的迹是指主对角线（从左上到右下）上所有值的和。\n\n给定 $\\mathbf{N}$ 和 $\\mathbf{K}$，构造任意一个迹为 $\\mathbf{K}$ 的 $\\mathbf{N} \\times \\mathbf{N}$ 自然拉丁方阵，或判定其不存在。例如，以下是 $\\mathbf{N}=3, \\mathbf{K}=6$ 时的两种可能解（贡献迹的值已加下划线）：\n\n$\\begin{array}{lll}\n\\underline{2} & 1 & 3 \\\\ \n3 & \\underline{2} & 1 \\\\ \n1 & 3 & \\underline{2}\n\\end{array}\n\\quad\n\\begin{array}{lll}\n\\underline{3} & 1 & 2 \\\\ \n1 & \\underline{2} &3 \\\\ \n2 & 3 & \\underline{1}\n\\end{array}$", "inputFormat": "输入第一行包含测试用例数 $\\mathbf{T}$。随后 $\\mathbf{T}$ 行，每行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{K}$，分别表示方阵大小和期望的迹。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为 `IMPOSSIBLE`（无解时）或 `POSSIBLE`（有解时）。若有解，还需输出 $\\mathbf{N}$ 行，每行 $\\mathbf{N}$ 个整数表示满足条件的自然拉丁方阵。", "hint": "**样例解释**\n\n样例 #1 对应题目描述中的情况。\n\n样例 #2 无解。所有可能的 2×2 自然拉丁方阵如下：\n\n```\n1 2 2 1\n2 1 1 2\n```\n\n它们的迹分别为 2 和 4，无法得到迹 3。\n\n**数据范围**\n\n- $\\mathrm{N} \\leqslant \\mathrm{K} \\leqslant \\mathrm{N}^{2}$\n\n**测试集 1（7 分，可见判果）**\n\n- $\\mathrm{T}=44$\n- $2 \\leqslant \\mathrm{N} \\leqslant 5$\n\n**测试集 2（25 分，隐藏判果）**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$\n- $2 \\leqslant \\mathrm{N} \\leqslant 50$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13053", "type": "P", "difficulty": 3, "samples": [["2\n5\n*CONUTS\n*COCONUTS\n*OCONUTS\n*CONUTS\n*S\n2\n*XZ\n*XYZ", "Case #1: COCONUTS\nCase #2: *"]], "limits": {"time": [20000, 20000, 20000, 20000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["字符串", "2020", "Special Judge", "Google Code Jam"], "title": "[GCJ 2020 #1A] Pattern Matching", "background": "", "description": "Many terminals use asterisks (`*`) to signify \"any string\", including the empty string. For example, when listing files matching `BASH*`, a terminal may list BASH, BASHER and BASHFUL. For `*FUL`, it may list BEAUTIFUL, AWFUL and BASHFUL. When listing `B*L`, BASHFUL, BEAUTIFUL and BULL may be listed.\n\nIn this problem, formally, a pattern is a string consisting of only uppercase English letters and asterisks (`*`), and a name is a string consisting of only uppercase English letters. A pattern $p$ matches a name $m$ if there is a way of replacing every asterisk in $p$ with a (possibly empty) string to obtain $m$. Notice that each asterisk may be replaced by a different string.\n\nGiven $\\mathrm{N}$ patterns, can you find a single name of at most $10^{4}$ letters that matches all those patterns at once, or report that it cannot be done?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each test case starts with a line with a single integer $\\mathrm{N}$: the number of patterns to simultaneously match. Then, $\\mathrm{N}$ lines follow, each one containing a single string $\\mathrm{P}_{\\mathrm{i}}$ representing the $\\mathrm{i}$-th pattern.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is any name containing at most $10^{4}$ letters such that each $\\mathrm{P}_{\\mathrm{i}}$ matches $\\mathrm{y}$ according to the definition above, or `*` (i.e., just an asterisk) if there is no such name.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are other possible answers, including COCOCONUTS and ILIKECOCONUTS. Neither COCONUTSAREGREAT nor COCOANUTS would be acceptable. Notice that the same pattern may appear more than once within a test case.\n\nIn Sample Case #2, there is no acceptable name, so the answer is `*`.\n\nThe following cases could not appear in Test Set 1, but could appear in Test Set 2 or Test Set 3:\n```\n  4\n  H*O\n  HELLO*\n  *HELLO\n  HE*\n```\nHELLO and HELLOGOODBYEHELLO are examples of acceptable answers. OTHELLO and HELLOO would not be acceptable.\n```\n  2\n  CO*DE\n  J*AM\n```\nThere is no name that matches both patterns, so the answer would be `*`.\n```\n  2\n  CODE*\n  *JAM\n```\nCODEJAM is one example of an acceptable answer.\n\nThe following cases could not appear in Test Set 1 or Test Set 2, but could appear in Test Set 3:\n```\n  2\n  A*C*E\n  *B*D*\n```\nABCDE and ABUNDANCE are among the possible acceptable answers, but BOLDFACE is not.\n```\n  2\n  A*C*E\n  *B*D\n```\nThere is no name that matches both patterns, so the answer would be `*`.\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $2 \\leqslant \\mathrm{N} \\leqslant 50$.\n- $2 \\leqslant$ length of $\\mathrm{P}_{\\mathrm{i}} \\leqslant 100$, for all $\\mathrm{i}$.\n- Each character of $\\mathrm{P}_{\\mathrm{i}}$ is either an uppercase English letter or an asterisk (*), for all $\\mathrm{i}$.\n- At least one character of $\\mathrm{P}_{\\mathrm{i}}$ is an uppercase English letter, for all $\\mathrm{i}$.\n\n**Test set 1 (5 Pts, Visible Verdict)**\n\n- Exactly one character of $\\mathrm{P}_{\\mathrm{i}}$ is an asterisk (*), for all $\\mathrm{i}$.\n\n- The leftmost character of $\\mathrm{P}_{\\mathrm{i}}$ is the only asterisk (*), for all $\\mathrm{i}$.\n\n**Test set 2 (5 Pts, Visible Verdict)**\n\n- Exactly one character of $\\mathrm{P}_{\\mathrm{i}}$ is an asterisk (*), for all $\\mathrm{i}$.\n\n**Test set 3 (18 Pts, Visible Verdict)**\n\n- At least one character of $\\mathrm{P}_{\\mathrm{i}}$ is an asterisk (*), for all $\\mathrm{i}$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1A] Pattern Matching", "background": "", "description": "Many terminals use asterisks (`*`) to signify \"any string\", including the empty string. For example, when listing files matching `BASH*`, a terminal may list BASH, BASHER and BASHFUL. For `*FUL`, it may list BEAUTIFUL, AWFUL and BASHFUL. When listing `B*L`, BASHFUL, BEAUTIFUL and BULL may be listed.\n\nIn this problem, formally, a pattern is a string consisting of only uppercase English letters and asterisks (`*`), and a name is a string consisting of only uppercase English letters. A pattern $p$ matches a name $m$ if there is a way of replacing every asterisk in $p$ with a (possibly empty) string to obtain $m$. Notice that each asterisk may be replaced by a different string.\n\nGiven $\\mathrm{N}$ patterns, can you find a single name of at most $10^{4}$ letters that matches all those patterns at once, or report that it cannot be done?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each test case starts with a line with a single integer $\\mathrm{N}$: the number of patterns to simultaneously match. Then, $\\mathrm{N}$ lines follow, each one containing a single string $\\mathrm{P}_{\\mathrm{i}}$ representing the $\\mathrm{i}$-th pattern.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is any name containing at most $10^{4}$ letters such that each $\\mathrm{P}_{\\mathrm{i}}$ matches $\\mathrm{y}$ according to the definition above, or `*` (i.e., just an asterisk) if there is no such name.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are other possible answers, including COCOCONUTS and ILIKECOCONUTS. Neither COCONUTSAREGREAT nor COCOANUTS would be acceptable. Notice that the same pattern may appear more than once within a test case.\n\nIn Sample Case #2, there is no acceptable name, so the answer is `*`.\n\nThe following cases could not appear in Test Set 1, but could appear in Test Set 2 or Test Set 3:\n```\n  4\n  H*O\n  HELLO*\n  *HELLO\n  HE*\n```\nHELLO and HELLOGOODBYEHELLO are examples of acceptable answers. OTHELLO and HELLOO would not be acceptable.\n```\n  2\n  CO*DE\n  J*AM\n```\nThere is no name that matches both patterns, so the answer would be `*`.\n```\n  2\n  CODE*\n  *JAM\n```\nCODEJAM is one example of an acceptable answer.\n\nThe following cases could not appear in Test Set 1 or Test Set 2, but could appear in Test Set 3:\n```\n  2\n  A*C*E\n  *B*D*\n```\nABCDE and ABUNDANCE are among the possible acceptable answers, but BOLDFACE is not.\n```\n  2\n  A*C*E\n  *B*D\n```\nThere is no name that matches both patterns, so the answer would be `*`.\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $2 \\leqslant \\mathrm{N} \\leqslant 50$.\n- $2 \\leqslant$ length of $\\mathrm{P}_{\\mathrm{i}} \\leqslant 100$, for all $\\mathrm{i}$.\n- Each character of $\\mathrm{P}_{\\mathrm{i}}$ is either an uppercase English letter or an asterisk (*), for all $\\mathrm{i}$.\n- At least one character of $\\mathrm{P}_{\\mathrm{i}}$ is an uppercase English letter, for all $\\mathrm{i}$.\n\n**Test set 1 (5 Pts, Visible Verdict)**\n\n- Exactly one character of $\\mathrm{P}_{\\mathrm{i}}$ is an asterisk (*), for all $\\mathrm{i}$.\n\n- The leftmost character of $\\mathrm{P}_{\\mathrm{i}}$ is the only asterisk (*), for all $\\mathrm{i}$.\n\n**Test set 2 (5 Pts, Visible Verdict)**\n\n- Exactly one character of $\\mathrm{P}_{\\mathrm{i}}$ is an asterisk (*), for all $\\mathrm{i}$.\n\n**Test set 3 (18 Pts, Visible Verdict)**\n\n- At least one character of $\\mathrm{P}_{\\mathrm{i}}$ is an asterisk (*), for all $\\mathrm{i}$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1A] Pattern Matching", "background": "", "description": "许多终端使用星号(`*`)表示\"任意字符串\"，包括空字符串。例如，当列出匹配`BASH*`的文件时，终端可能显示 BASH、BASHER 和 BASHFUL。对于`*FUL`，可能显示 BEAUTIFUL、AWFUL 和 BASHFUL。当列出`B*L`时，可能显示 BASHFUL、BEAUTIFUL 和 BULL。\n\n在本题中，**模式**是仅由大写字母和星号(`*`)组成的字符串，**名称**是仅由大写字母组成的字符串。若模式 $p$ 能通过将每个星号替换为任意字符串（可为空）得到名称 $m$，则称 $p$ 匹配 $m$。注意不同星号可被替换为不同字符串。\n\n给定 $\\mathrm{N}$ 个模式，请构造一个长度不超过 $10^{4}$ 的字符串，使其同时匹配所有给定模式；若不存在这样的字符串，则报告无解。", "inputFormat": "输入第一行包含测试用例数 $\\mathrm{T}$。随后每个测试用例包含：\n- 第一行：整数 $\\mathrm{N}$ 表示模式数量\n- 随后 $\\mathrm{N}$ 行：每行一个字符串 $\\mathrm{P}_{\\mathrm{i}}$ 表示第 $\\mathrm{i}$ 个模式\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中：\n- $x$ 为测试用例编号（从 1 开始）\n- $y$ 为满足条件的长度不超过 $10^{4}$ 的字符串，若无解则输出 `*`\n", "hint": "样例 #1 中，其他可行解包括 COCOCONUTS 和 ILIKECOCONUTS，但 COCONUTSAREGREAT 和 COCOANUTS 不符合要求。注意同一模式可能在测试用例中重复出现。\n\n样例 #2 无解，故输出 `*`。\n\n以下情况不会出现在测试集 1，但可能出现在测试集 2 或 3：\n\n```\n  4\n  H*O\n  HELLO*\n  *HELLO\n  HE*\n```\n\n可行解包括 HELLO 和 HELLOGOODBYEHELLO，但 OTHELLO 和 HELLOO 不符合。\n\n```\n  2\n  CO*DE\n  J*AM\n```\n\n无解，输出 `*`。\n\n```\n  2\n  CODE*\n  *JAM\n```\n\nCODEJAM 是可行解之一。\n\n以下情况仅可能出现在测试集 3：\n\n```\n  2\n  A*C*E\n  *B*D*\n```\n\n可行解包括 ABCDE 和 ABUNDANCE，但 BOLDFACE 不符合。\n\n```\n  2\n  A*C*E\n  *B*D\n```\n\n无解，输出 `*`。\n\n**数据范围**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$\n- $2 \\leqslant \\mathrm{N} \\leqslant 50$\n- $2 \\leqslant \\mathrm{P}_{\\mathrm{i}}$ 长度 $\\leqslant 100$\n- 每个 $\\mathrm{P}_{\\mathrm{i}}$ 仅含大写字母和星号\n- 每个 $\\mathrm{P}_{\\mathrm{i}}$ 至少包含一个大写字母\n\n**测试集 1（5 分，可见判果）**\n- 每个 $\\mathrm{P}_{\\mathrm{i}}$ 仅含一个星号\n- 星号必须位于模式开头\n\n**测试集 2（5 分，可见判果）**\n- 每个 $\\mathrm{P}_{\\mathrm{i}}$ 仅含一个星号\n\n**测试集 3（18 分，可见判果）**\n- 每个 $\\mathrm{P}_{\\mathrm{i}}$ 至少含一个星号\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13054", "type": "P", "difficulty": 4, "samples": [["3\n1\n4\n19", "Case #1:\n1 1\nCase #2:\n1 1\n2 1\n2 2\n3 3\nCase #3:\n1 1\n2 2\n3 2\n4 3\n5 3\n5 2\n4 1\n3 1"]], "limits": {"time": [20000, 20000, 20000, 20000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2020", "Special Judge", "构造", "Google Code Jam"], "title": "[GCJ 2020 #1A] Pascal Walk", "background": "", "description": "Pascal's triangle consists of an infinite number of rows of an increasing number of integers each, arranged in a triangular shape.\n\nLet us define $(r, k)$ as the $k$-th position from the left in the $r$-th row, with both $r$ and $k$ counted starting from 1. Then Pascal's triangle is defined by the following rules:\n\n- The $r$-th row contains $r$ positions $(r, 1),(r, 2), \\ldots,(r, r)$.\n- The numbers at positions $(r, 1)$ and $(r, r)$ are 1 , for all $r$.\n- The number at position $(r, k)$ is the sum of the numbers at positions $(r-1, k-1)$ and $(r-1, k)$, for all $k$ with $2 \\leqslant k \\leqslant r-1$.\n\nThe first 5 rows of Pascal's triangle look like this:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6s8m35j7.png)\n\nIn this problem, a Pascal walk is a sequence of $\\mathrm{s}$ positions $\\left(\\mathrm{r}_{1}, \\mathrm{k}_{1}\\right),\\left(\\mathrm{r}_{2}, \\mathrm{k}_{2}\\right), \\ldots,\\left(\\mathrm{r}_{\\mathrm{s}}, \\mathrm{k}_{\\mathrm{s}}\\right)$ in Pascal's triangle that satisfy the following criteria:\n\n- $\\mathrm{r}_{1}=1$ and $\\mathrm{k}_{1}=1$.\n- Each subsequent position must be within the triangle and adjacent (in one of the six possible directions) to the previous position. That is, for all $\\mathrm{i} \\geqslant 1,\\left(\\mathrm{r}_{\\mathrm{i}+1}, \\mathrm{k}_{\\mathrm{i}+1}\\right)$ must be one of the following that is within the triangle: $\\left(\\mathrm{r}_{\\mathrm{i}}-1, \\mathrm{k}_{\\mathrm{i}}-1\\right),\\left(\\mathrm{r}_{\\mathrm{i}}-1, \\mathrm{k}_{\\mathrm{i}}\\right),\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}-1\\right),\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}+1\\right),\\left(\\mathrm{r}_{\\mathrm{i}}+1, \\mathrm{k}_{\\mathrm{i}}\\right),\\left(\\mathrm{r}_{\\mathrm{i}}+1, \\mathrm{k}_{\\mathrm{i}}+1\\right)$.\n- No position may be repeated within the sequence. That is, for every $\\mathrm{i} \\neq \\mathrm{j}$, either $\\mathrm{r}_{\\mathrm{i}} \\neq \\mathrm{r}_{\\mathrm{j}}$ or $\\mathrm{k}_{\\mathrm{i}} \\neq \\mathrm{k}_{\\mathrm{j}}$, or both.\n\nFind any Pascal walk of $\\mathrm{S} \\leqslant 500$ positions such that the sum of the numbers in all of the positions it visits is equal to $\\mathrm{N}$. It is guaranteed that at least one such walk exists for every $\\mathrm{N}$.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each consists of a single line containing a single integer $\\mathrm{N}$.\n", "outputFormat": "For each test case, first output a line containing case #x:, where $\\mathrm{x}$ is the test case number (starting from 1). Then, output your proposed Pascal walk of length $\\mathrm{S} \\leqslant 500$ using $\\mathrm{S}$ additional lines. The $\\mathrm{i}$-th of these lines must be $\\mathrm{r}_{\\mathrm{i}} \\mathrm{k}_{\\mathrm{i}}$ where $\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}\\right)$ is the $\\mathrm{i}$-th position in the walk. For example, the first line should be $1 \\quad 1$ since the first position for all valid walks is $(1,1)$. The sum of the numbers at the $\\mathrm{S}$ positions of your proposed Pascal walk must be exactly $\\mathrm{N}$.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, only the starting position is needed.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/06jwicgw.png)\n\nIn Sample Case #2, notice that although a shorter path exists, the path does not need to be of minimal length, as long as it uses no more than 500 positions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/scfogipe.png)\n\nThe following image depicts our solution to Sample Case #3:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x6b2j5as.png)\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n\n**Test set 1 (3 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 501$.\n\n**Test set 2 (11 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 1000$.\n\n**Test set 3 (21 Pts, Hidden Verdict)**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 10^{9}$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1A] Pascal Walk", "background": "", "description": "Pascal's triangle consists of an infinite number of rows of an increasing number of integers each, arranged in a triangular shape.\n\nLet us define $(r, k)$ as the $k$-th position from the left in the $r$-th row, with both $r$ and $k$ counted starting from 1. Then Pascal's triangle is defined by the following rules:\n\n- The $r$-th row contains $r$ positions $(r, 1),(r, 2), \\ldots,(r, r)$.\n- The numbers at positions $(r, 1)$ and $(r, r)$ are 1 , for all $r$.\n- The number at position $(r, k)$ is the sum of the numbers at positions $(r-1, k-1)$ and $(r-1, k)$, for all $k$ with $2 \\leqslant k \\leqslant r-1$.\n\nThe first 5 rows of Pascal's triangle look like this:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6s8m35j7.png)\n\nIn this problem, a Pascal walk is a sequence of $\\mathrm{s}$ positions $\\left(\\mathrm{r}_{1}, \\mathrm{k}_{1}\\right),\\left(\\mathrm{r}_{2}, \\mathrm{k}_{2}\\right), \\ldots,\\left(\\mathrm{r}_{\\mathrm{s}}, \\mathrm{k}_{\\mathrm{s}}\\right)$ in Pascal's triangle that satisfy the following criteria:\n\n- $\\mathrm{r}_{1}=1$ and $\\mathrm{k}_{1}=1$.\n- Each subsequent position must be within the triangle and adjacent (in one of the six possible directions) to the previous position. That is, for all $\\mathrm{i} \\geqslant 1,\\left(\\mathrm{r}_{\\mathrm{i}+1}, \\mathrm{k}_{\\mathrm{i}+1}\\right)$ must be one of the following that is within the triangle: $\\left(\\mathrm{r}_{\\mathrm{i}}-1, \\mathrm{k}_{\\mathrm{i}}-1\\right),\\left(\\mathrm{r}_{\\mathrm{i}}-1, \\mathrm{k}_{\\mathrm{i}}\\right),\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}-1\\right),\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}+1\\right),\\left(\\mathrm{r}_{\\mathrm{i}}+1, \\mathrm{k}_{\\mathrm{i}}\\right),\\left(\\mathrm{r}_{\\mathrm{i}}+1, \\mathrm{k}_{\\mathrm{i}}+1\\right)$.\n- No position may be repeated within the sequence. That is, for every $\\mathrm{i} \\neq \\mathrm{j}$, either $\\mathrm{r}_{\\mathrm{i}} \\neq \\mathrm{r}_{\\mathrm{j}}$ or $\\mathrm{k}_{\\mathrm{i}} \\neq \\mathrm{k}_{\\mathrm{j}}$, or both.\n\nFind any Pascal walk of $\\mathrm{S} \\leqslant 500$ positions such that the sum of the numbers in all of the positions it visits is equal to $\\mathrm{N}$. It is guaranteed that at least one such walk exists for every $\\mathrm{N}$.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each consists of a single line containing a single integer $\\mathrm{N}$.\n", "outputFormat": "For each test case, first output a line containing case #x:, where $\\mathrm{x}$ is the test case number (starting from 1). Then, output your proposed Pascal walk of length $\\mathrm{S} \\leqslant 500$ using $\\mathrm{S}$ additional lines. The $\\mathrm{i}$-th of these lines must be $\\mathrm{r}_{\\mathrm{i}} \\mathrm{k}_{\\mathrm{i}}$ where $\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}\\right)$ is the $\\mathrm{i}$-th position in the walk. For example, the first line should be $1 \\quad 1$ since the first position for all valid walks is $(1,1)$. The sum of the numbers at the $\\mathrm{S}$ positions of your proposed Pascal walk must be exactly $\\mathrm{N}$.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, only the starting position is needed.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/06jwicgw.png)\n\nIn Sample Case #2, notice that although a shorter path exists, the path does not need to be of minimal length, as long as it uses no more than 500 positions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/scfogipe.png)\n\nThe following image depicts our solution to Sample Case #3:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x6b2j5as.png)\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n\n**Test set 1 (3 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 501$.\n\n**Test set 2 (11 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 1000$.\n\n**Test set 3 (21 Pts, Hidden Verdict)**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 10^{9}$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1A] Pascal Walk", "background": "", "description": "**帕斯卡三角形** 由无限多行整数构成，每行的整数数量逐行递增，排列成三角形。\n\n定义 $(r, k)$ 为第 $r$ 行从左数第 $k$ 个位置，其中 $r$ 和 $k$ 均从 1 开始计数。帕斯卡三角形的构造遵循以下规则：\n\n- 第 $r$ 行包含 $r$ 个位置 $(r, 1), (r, 2), \\ldots, (r, r)$。\n- 对于所有 $r$，位置 $(r, 1)$ 和 $(r, r)$ 的数字均为 $1$。\n- 对于所有满足 $2 \\leqslant k \\leqslant r-1$ 的 $k$，位置 $(r, k)$ 的数字等于位置 $(r-1, k-1)$ 和 $(r-1, k)$ 的数字之和。\n\n帕斯卡三角形的前 5 行如下所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/6s8m35j7.png)\n\n在本问题中，**帕斯卡游走** 是指帕斯卡三角形中一个长度为 $\\mathrm{s}$ 的位置序列 $\\left(\\mathrm{r}_{1}, \\mathrm{k}_{1}\\right), \\left(\\mathrm{r}_{2}, \\mathrm{k}_{2}\\right), \\ldots, \\left(\\mathrm{r}_{\\mathrm{s}}, \\mathrm{k}_{\\mathrm{s}}\\right)$，满足以下条件：\n\n1. $\\mathrm{r}_{1}=1$ 且 $\\mathrm{k}_{1}=1$。\n2. 每个后续位置必须在三角形内，并且与前一个位置相邻（六个可能方向之一）。即对于所有 $\\mathrm{i} \\geqslant 1$，$\\left(\\mathrm{r}_{\\mathrm{i}+1}, \\mathrm{k}_{\\mathrm{i}+1}\\right)$ 必须是以下之一且位于三角形内：$\\left(\\mathrm{r}_{\\mathrm{i}}-1, \\mathrm{k}_{\\mathrm{i}}-1\\right)$、$\\left(\\mathrm{r}_{\\mathrm{i}}-1, \\mathrm{k}_{\\mathrm{i}}\\right)$、$\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}-1\\right)$、$\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}+1\\right)$、$\\left(\\mathrm{r}_{\\mathrm{i}}+1, \\mathrm{k}_{\\mathrm{i}}\\right)$、$\\left(\\mathrm{r}_{\\mathrm{i}}+1, \\mathrm{k}_{\\mathrm{i}}+1\\right)$。\n3. 序列中不能重复访问同一位置。即对于任意 $\\mathrm{i} \\neq \\mathrm{j}$，必须满足 $\\mathrm{r}_{\\mathrm{i}} \\neq \\mathrm{r}_{\\mathrm{j}}$ 或 $\\mathrm{k}_{\\mathrm{i}} \\neq \\mathrm{k}_{\\mathrm{j}}$，或两者均不相等。\n\n请构造一个长度 $\\mathrm{S} \\leqslant 500$ 的帕斯卡游走，使得所访问位置中所有数字之和恰好等于 $\\mathrm{N}$。题目保证对于所有 $\\mathrm{N}$，至少存在一个这样的游走。", "inputFormat": "输入的第一行包含测试用例数量 $\\mathrm{T}$。随后是 $\\mathrm{T}$ 个测试用例，每个用例占一行，包含一个整数 $\\mathrm{N}$。\n", "outputFormat": "对于每个测试用例，首先输出一行 `Case #x:`，其中 $\\mathrm{x}$ 为测试用例编号（从 1 开始）。接着输出你构造的帕斯卡游走，共 $\\mathrm{S} \\leqslant 500$ 行，每行格式为 $\\mathrm{r}_{\\mathrm{i}} \\ \\mathrm{k}_{\\mathrm{i}}$，表示游走的第 $\\mathrm{i}$ 个位置 $\\left(\\mathrm{r}_{\\mathrm{i}}, \\mathrm{k}_{\\mathrm{i}}\\right)$。例如，第一行必须为 `1 1`，因为所有有效游走的起点均为 $(1,1)$。游走中所有位置的数字之和必须严格等于 $\\mathrm{N}$。\n", "hint": "\n## 说明/提示\n\n**样例解释**\n\n- 样例 #1 仅需起点位置即可满足要求。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/06jwicgw.png)\n\n- 样例 #2 中，虽然存在更短的路径，但路径长度只需不超过 500 即可，无需最短。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/scfogipe.png)\n\n- 下图展示了样例 #3 的解决方案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x6b2j5as.png)\n\n**数据范围**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$。\n\n**测试集 1（3 分，可见评测结果）**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 501$。\n\n**测试集 2（11 分，可见评测结果）**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 1000$。\n\n**测试集 3（21 分，隐藏评测结果）**\n\n- $1 \\leqslant \\mathrm{N} \\leqslant 10^{9}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13055", "type": "P", "difficulty": 5, "samples": [["4\n1 1\n15\n3 3\n1 1 1\n1 2 1\n1 1 1\n1 3\n3 1 2\n1 3\n1 2 3", "Case #1: 15\nCase #2: 16\nCase #3: 14\nCase #4: 14"]], "limits": {"time": [40000, 40000, 40000], "memory": [1048576, 1048576, 1048576]}, "tags": ["模拟", "2020", "广度优先搜索 BFS", "Google Code Jam"], "title": "[GCJ 2020 #1A] Square Dance", "background": "", "description": "You are organizing an international dancing competition. You have already obtained all of the following:\n\n* A dance floor with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns, consisting of unit square cells;\n* $\\mathbf{R} \\times \\mathbf{C}$ competitors;\n* A cutting-edge automated judge for the competition.\n\nBut you are still missing an audience! You are worried that the competition might not be interesting enough, so you have come up with a way to calculate the interest level for the competition.\n\nEach competitor occupies one square unit cell of the floor and stays there until they are eliminated. A compass neighbor of a competitor $\\mathrm{x}$ is another competitor $\\mathrm{y}$ chosen such that $\\mathrm{y}$ shares a row or column with $\\mathrm{x}$, and there are no competitors still standing in cells in between $\\mathrm{x}$ and $\\mathrm{y}$. Each competitor may have between 0 and 4 compass neighbors, inclusive, and the number may decrease if all the other competitors in one orthogonal direction are eliminated.\n\nThe competition runs one round at a time. In between rounds $\\mathrm{i}$ and $\\mathrm{i}+1$, if a competitor $\\mathrm{d}$ had at least one compass neighbor during round $\\mathrm{i}$, and $\\mathrm{d}$ 's skill level is strictly less than the average skill level of all of $\\mathrm{d}$ 's compass neighbors, $\\mathrm{d}$ is eliminated and is not part of the competition for rounds $\\mathrm{i}+1, \\mathrm{i}+2, \\mathrm{i}+3$, etc. Notice that $\\mathrm{d}$ still counts as a neighbor of their other compass neighbors for the purpose of other eliminations that may also happen between rounds $\\mathrm{i}$ and $\\mathrm{i}+1$. Competitors that do not have any compass neighbors are never eliminated. If after a round no competitor is eliminated, then the competition ends.\n\nThe interest level of a round is the sum of skill levels of the competitors dancing in that round (even any competitors that are to be eliminated between that round and the next). The interest level of the competition is the sum of the interest levels of all of the rounds.\n\nGiven the skill levels of the dancers that are on the floor for the first round, what is the interest level of the competition?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each test case begins with a line containing two integers $\\mathbf{R}$ and $\\mathbf{C}$. Then, there are $\\mathbf{R}$ more lines containing $\\mathbf{C}$ integers each. The $\\mathrm{j}$-th value on the $\\mathrm{i}$-th of these lines, $\\mathrm{S}_{\\mathrm{i}, \\mathrm{j}}$, represents the skill level of the dancer in the cell in the $\\mathrm{i}$-th row and $\\mathrm{j}$-th column of the floor.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the interest level of the competition.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, only one competitor is on the floor. Since the competitor does not have any compass neighbors, they dance in one round, and then the competition is over. Thus the answer is equal to the dancer's skill level, 15.\n\nIn Sample Case #2, the interest level of the first round is $1+1+1+1+2+1+1+1+1=10$.\n\nThe competitors that are not in the center nor in a corner have a skill level of 1 , but the average of their compass neighbors is $4 / 3$, which is greater than 1 , so they are eliminated. The floor during the second round looks like this:\n\n```\n1 . 1\n. 2 .\n1 . 1\n```\n\nThis round is the last one. The competitors in the corner have two compass neighbors each, but the average of their skill level is equal to their own. The competitor in the center has no compass neighbor. The interest level of the round is $1+1+2+1+1=6$. This means the interest level of the competition is $10+6=16$.\n\nIn Sample Case #3, the competitor with skill level 1 is eliminated after the first round, while the other two remain. In the second round, the two other competitors become compass neighbors, and this causes the competitor with skill level 2 to be eliminated. There is a single competitor in the third round, which makes it the last one. The interest levels of the rounds are 6, 5 and 3, making the interest level of the competition 14.\n\n**Limits**\n\n- $1 \\leqslant S_{i, j} \\leqslant 10^{6}$, for all $i$ and $j$.\n\n**Test set 1 (9 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $1 \\leqslant \\mathrm{R} \\times \\mathrm{C} \\leqslant 100$.\n\n**Test set 2 (28 Pts, Hidden Verdict)**\n\n- $10 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $1000<\\mathrm{R} \\times \\mathrm{C} \\leqslant 10^{5}$, in exactly 10 cases.\n- $1 \\leqslant \\mathrm{R} \\times \\mathrm{C} \\leqslant 1000$, in exactly $\\mathrm{T}-10$ cases.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1A] Square Dance", "background": "", "description": "You are organizing an international dancing competition. You have already obtained all of the following:\n\n* A dance floor with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns, consisting of unit square cells;\n* $\\mathbf{R} \\times \\mathbf{C}$ competitors;\n* A cutting-edge automated judge for the competition.\n\nBut you are still missing an audience! You are worried that the competition might not be interesting enough, so you have come up with a way to calculate the interest level for the competition.\n\nEach competitor occupies one square unit cell of the floor and stays there until they are eliminated. A compass neighbor of a competitor $\\mathrm{x}$ is another competitor $\\mathrm{y}$ chosen such that $\\mathrm{y}$ shares a row or column with $\\mathrm{x}$, and there are no competitors still standing in cells in between $\\mathrm{x}$ and $\\mathrm{y}$. Each competitor may have between 0 and 4 compass neighbors, inclusive, and the number may decrease if all the other competitors in one orthogonal direction are eliminated.\n\nThe competition runs one round at a time. In between rounds $\\mathrm{i}$ and $\\mathrm{i}+1$, if a competitor $\\mathrm{d}$ had at least one compass neighbor during round $\\mathrm{i}$, and $\\mathrm{d}$ 's skill level is strictly less than the average skill level of all of $\\mathrm{d}$ 's compass neighbors, $\\mathrm{d}$ is eliminated and is not part of the competition for rounds $\\mathrm{i}+1, \\mathrm{i}+2, \\mathrm{i}+3$, etc. Notice that $\\mathrm{d}$ still counts as a neighbor of their other compass neighbors for the purpose of other eliminations that may also happen between rounds $\\mathrm{i}$ and $\\mathrm{i}+1$. Competitors that do not have any compass neighbors are never eliminated. If after a round no competitor is eliminated, then the competition ends.\n\nThe interest level of a round is the sum of skill levels of the competitors dancing in that round (even any competitors that are to be eliminated between that round and the next). The interest level of the competition is the sum of the interest levels of all of the rounds.\n\nGiven the skill levels of the dancers that are on the floor for the first round, what is the interest level of the competition?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each test case begins with a line containing two integers $\\mathbf{R}$ and $\\mathbf{C}$. Then, there are $\\mathbf{R}$ more lines containing $\\mathbf{C}$ integers each. The $\\mathrm{j}$-th value on the $\\mathrm{i}$-th of these lines, $\\mathrm{S}_{\\mathrm{i}, \\mathrm{j}}$, represents the skill level of the dancer in the cell in the $\\mathrm{i}$-th row and $\\mathrm{j}$-th column of the floor.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the interest level of the competition.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, only one competitor is on the floor. Since the competitor does not have any compass neighbors, they dance in one round, and then the competition is over. Thus the answer is equal to the dancer's skill level, 15.\n\nIn Sample Case #2, the interest level of the first round is $1+1+1+1+2+1+1+1+1=10$.\n\nThe competitors that are not in the center nor in a corner have a skill level of 1 , but the average of their compass neighbors is $4 / 3$, which is greater than 1 , so they are eliminated. The floor during the second round looks like this:\n\n```\n1 . 1\n. 2 .\n1 . 1\n```\n\nThis round is the last one. The competitors in the corner have two compass neighbors each, but the average of their skill level is equal to their own. The competitor in the center has no compass neighbor. The interest level of the round is $1+1+2+1+1=6$. This means the interest level of the competition is $10+6=16$.\n\nIn Sample Case #3, the competitor with skill level 1 is eliminated after the first round, while the other two remain. In the second round, the two other competitors become compass neighbors, and this causes the competitor with skill level 2 to be eliminated. There is a single competitor in the third round, which makes it the last one. The interest levels of the rounds are 6, 5 and 3, making the interest level of the competition 14.\n\n**Limits**\n\n- $1 \\leqslant S_{i, j} \\leqslant 10^{6}$, for all $i$ and $j$.\n\n**Test set 1 (9 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $1 \\leqslant \\mathrm{R} \\times \\mathrm{C} \\leqslant 100$.\n\n**Test set 2 (28 Pts, Hidden Verdict)**\n\n- $10 \\leqslant \\mathrm{T} \\leqslant 100$.\n- $1000<\\mathrm{R} \\times \\mathrm{C} \\leqslant 10^{5}$, in exactly 10 cases.\n- $1 \\leqslant \\mathrm{R} \\times \\mathrm{C} \\leqslant 1000$, in exactly $\\mathrm{T}-10$ cases.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1A] Square Dance", "background": "", "description": "你正在组织一场国际舞蹈比赛。目前已经准备好以下内容：\n\n* 一个由 $\\mathbf{R}$ 行 $\\mathbf{C}$ 列单位方格组成的舞池；\n* $\\mathbf{R} \\times \\mathbf{C}$ 名参赛选手；\n* 一套先进的自动评分系统。\n\n但你还缺少观众！担心比赛可能不够精彩，你设计了一种计算比赛**精彩度**的方法。\n\n每名选手占据舞池的一个单位方格，直到被淘汰为止。选手 $\\mathrm{x}$ 的**罗盘邻居**是指满足以下条件的另一选手 $\\mathrm{y}$：$\\mathrm{y}$ 与 $\\mathrm{x}$ 同行或同列，且 $\\mathrm{x}$ 与 $\\mathrm{y}$ 之间没有其他未被淘汰的选手。每名选手可能有 0 到 4 个罗盘邻居（包含边界），且数量会因某一方向上选手被淘汰而减少。\n\n比赛按轮次进行。在第 $\\mathrm{i}$ 轮和第 $\\mathrm{i}+1$ 轮之间，若选手 $\\mathrm{d}$ 在第 $\\mathrm{i}$ 轮时有至少一个罗盘邻居，且 $\\mathrm{d}$ 的技能值**严格小于**其所有罗盘邻居技能值的平均值，则 $\\mathrm{d}$ 被淘汰，不再参与后续轮次。注意：$\\mathrm{d}$ 在被淘汰前仍会作为其他选手的罗盘邻居参与淘汰判定。没有罗盘邻居的选手永远不会被淘汰。若某一轮后无人被淘汰，则比赛结束。\n\n每一轮的精彩度是该轮所有参赛选手（包括即将被淘汰者）技能值之和。比赛的**总精彩度**是所有轮次精彩度的总和。\n\n给定第一轮所有选手的技能值，求比赛的总精彩度。", "inputFormat": "输入第一行包含测试用例数量 $\\mathrm{T}$。随后是 $\\mathrm{T}$ 个测试用例，每个用例格式如下：\n- 第一行：两个整数 $\\mathbf{R}$ 和 $\\mathbf{C}$；\n- 接下来 $\\mathbf{R}$ 行：每行 $\\mathbf{C}$ 个整数，其中第 $\\mathrm{i}$ 行第 $\\mathrm{j}$ 列的 $\\mathrm{S}_{\\mathrm{i}, \\mathrm{j}}$ 表示初始位于第 $\\mathrm{i}$ 行第 $\\mathrm{j}$ 列选手的技能值。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $\\mathrm{x}$ 为测试用例编号（从 1 开始），$\\mathrm{y}$ 为比赛的总精彩度。\n", "hint": "**样例解释**\n\n- **样例 #1**：仅有一名选手。因其无罗盘邻居，比赛仅进行一轮，总精彩度为该选手技能值 15。\n  \n- **样例 #2**：\n  - 第一轮精彩度：$1+1+1+1+2+1+1+1+1=10$。\n  - 非中心且非角落的选手（技能值 1）因邻居平均值 $4/3 > 1$ 被淘汰。第二轮舞池如下：\n    ```\n    1 . 1\n    . 2 .\n    1 . 1\n    ```\n  - 角落选手的邻居平均值等于自身技能值，中心选手无邻居，比赛结束。第二轮精彩度 $1+1+2+1+1=6$，总精彩度 $10+6=16$。\n\n- **样例 #3**：\n  - 第一轮后技能值 1 的选手被淘汰，剩余两人。\n  - 第二轮中，技能值 2 的选手因邻居平均值 $3/1 > 2$ 被淘汰。\n  - 第三轮仅剩一人，比赛结束。各轮精彩度分别为 6、5、3，总精彩度 14。\n\n**数据范围**\n\n- $\\forall i,j$，$1 \\leqslant S_{i, j} \\leqslant 10^{6}$。\n\n**测试集 1（9 分，可见评测结果）**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$；\n- $1 \\leqslant \\mathrm{R} \\times \\mathrm{C} \\leqslant 100$。\n\n**测试集 2（28 分，隐藏评测结果）**\n\n- $10 \\leqslant \\mathrm{T} \\leqslant 100$；\n- 恰好 10 个用例满足 $1000 < \\mathrm{R} \\times \\mathrm{C} \\leqslant 10^{5}$；\n- 其余 $\\mathrm{T}-10$ 个用例满足 $1 \\leqslant \\mathrm{R} \\times \\mathrm{C} \\leqslant 1000$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13056", "type": "P", "difficulty": 4, "samples": [["4\n2 3\n-2 -3\n3 0\n-1 1", "Case #1: SEN\nCase #2: NWS\nCase #3: EE\nCase #4: IMPOSSIBLE"]], "limits": {"time": [20000, 20000, 20000, 20000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["贪心", "2020", "位运算", "Google Code Jam"], "title": "[GCJ 2020 #1B] Expogo", "background": "", "description": "You have just received the best gift ever: an Expogo stick. You can stand on it and use it to make increasingly large jumps.\n\nYou are currently standing on point $(0,0)$ in your infinite two-dimensional backyard, and you are trying to reach a goal point $(\\mathrm{X}, \\mathrm{Y})$, with integer coordinates, in as few jumps as possible. You must land exactly on the goal point; it is not sufficient to pass over it on a jump.\n\nEach time you use your Expogo stick to jump, you pick a cardinal direction: north, south, east, or west. The $i$-th jump with your Expogo stick moves you $2^{(i-1)}$ units in the chosen direction, so your first jump takes you 1 unit, your second jump takes you 2 units, your third jump takes you 4 units, and so on.\n\nGiven a goal point $(\\mathrm{X}, \\mathrm{Y})$, determine whether it is possible to get there, and if so, demonstrate how to do it using as few jumps as possible.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each consists of a single line with two integers $\\mathrm{X}$ and $\\mathrm{Y}$ : the coordinates of the goal point.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if the goal point cannot be reached. Otherwise, $y$ must be a string of one or more characters, each of which is either $\\mathrm{N}$ (north), $\\mathrm{S}$ (south), $\\mathrm{E}$ (east), or $\\mathrm{W}$ (west), representing the directions of the jumps that you will make, in order. This sequence of jumps must reach the goal point at the end of the final jump, and it must be as short as possible.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you can jump south from $(0, 0)$ to $(0, -1)$, then jump east to $(2, -1)$, then jump north to $(2, 3)$.\n\nWe can be sure there is not a more efficient solution (two moves or fewer) because at least $2 + 3 = 5$ units of distance are needed to reach the goal point, but the first two jumps combined only give us $3$ units of distance.\n\nNotice that Sample Case #2 is like Sample Case #1 but reflected across both axes, and so the answer comes from reflecting all directions in Sample Case #1's answer.\n\nIn Sample Case #3, notice that EWE would not be a valid answer, even though it reaches the target, because there is a way to get there using fewer jumps.\n\nWe leave it to you to determine why it is impossible to reach the target in Sample Case #4.\n\n**Limits**\n\n- $(\\text{X}, \\text{Y}) \\neq (0, 0)$.\n\n**Test set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\text{T} \\leqslant 80$.\n- $-4 \\leqslant \\text{X} \\leqslant 4$.\n- $-4 \\leqslant \\text{Y} \\leqslant 4$.\n\n**Test set 2 (8 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\text{T} \\leqslant 100$.\n- $-100 \\leqslant \\text{X} \\leqslant 100$.\n- $-100 \\leqslant \\text{Y} \\leqslant 100$.\n\n**Test set 3 (16 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\text{T} \\leqslant 100$.\n- $-10^{9} \\leqslant \\text{X} \\leqslant 10^{9}$.\n- $-10^{9} \\leqslant \\text{Y} \\leqslant 10^{9}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1B] Expogo", "background": "", "description": "You have just received the best gift ever: an Expogo stick. You can stand on it and use it to make increasingly large jumps.\n\nYou are currently standing on point $(0,0)$ in your infinite two-dimensional backyard, and you are trying to reach a goal point $(\\mathrm{X}, \\mathrm{Y})$, with integer coordinates, in as few jumps as possible. You must land exactly on the goal point; it is not sufficient to pass over it on a jump.\n\nEach time you use your Expogo stick to jump, you pick a cardinal direction: north, south, east, or west. The $i$-th jump with your Expogo stick moves you $2^{(i-1)}$ units in the chosen direction, so your first jump takes you 1 unit, your second jump takes you 2 units, your third jump takes you 4 units, and so on.\n\nGiven a goal point $(\\mathrm{X}, \\mathrm{Y})$, determine whether it is possible to get there, and if so, demonstrate how to do it using as few jumps as possible.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathrm{T}$. $\\mathrm{T}$ test cases follow. Each consists of a single line with two integers $\\mathrm{X}$ and $\\mathrm{Y}$ : the coordinates of the goal point.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if the goal point cannot be reached. Otherwise, $y$ must be a string of one or more characters, each of which is either $\\mathrm{N}$ (north), $\\mathrm{S}$ (south), $\\mathrm{E}$ (east), or $\\mathrm{W}$ (west), representing the directions of the jumps that you will make, in order. This sequence of jumps must reach the goal point at the end of the final jump, and it must be as short as possible.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you can jump south from $(0, 0)$ to $(0, -1)$, then jump east to $(2, -1)$, then jump north to $(2, 3)$.\n\nWe can be sure there is not a more efficient solution (two moves or fewer) because at least $2 + 3 = 5$ units of distance are needed to reach the goal point, but the first two jumps combined only give us $3$ units of distance.\n\nNotice that Sample Case #2 is like Sample Case #1 but reflected across both axes, and so the answer comes from reflecting all directions in Sample Case #1's answer.\n\nIn Sample Case #3, notice that EWE would not be a valid answer, even though it reaches the target, because there is a way to get there using fewer jumps.\n\nWe leave it to you to determine why it is impossible to reach the target in Sample Case #4.\n\n**Limits**\n\n- $(\\text{X}, \\text{Y}) \\neq (0, 0)$.\n\n**Test set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\text{T} \\leqslant 80$.\n- $-4 \\leqslant \\text{X} \\leqslant 4$.\n- $-4 \\leqslant \\text{Y} \\leqslant 4$.\n\n**Test set 2 (8 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\text{T} \\leqslant 100$.\n- $-100 \\leqslant \\text{X} \\leqslant 100$.\n- $-100 \\leqslant \\text{Y} \\leqslant 100$.\n\n**Test set 3 (16 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\text{T} \\leqslant 100$.\n- $-10^{9} \\leqslant \\text{X} \\leqslant 10^{9}$.\n- $-10^{9} \\leqslant \\text{Y} \\leqslant 10^{9}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1B] Expogo", "background": "", "description": "你刚刚收到了有史以来最棒的礼物：一根 **Expogo** 跳跃棒。你可以站在上面，用它进行越来越大的跳跃。\n\n你目前站在无限大的二维后院中的点 $(0, 0)$ 处，并试图以尽可能少的跳跃次数到达目标点 $(\\mathrm{X}, \\mathrm{Y})$（坐标为整数）。你必须恰好落在目标点上，仅从上方经过是不够的。\n\n每次使用 **Expogo** 跳跃棒跳跃时，你需要选择一个基本方向：北（north）、南（south）、东（east）或西（west）。第 $i$ 次跳跃会将你移动 $2^{(i-1)}$ 个单位，因此第一次跳跃移动 1 个单位，第二次跳跃移动 2 个单位，第三次跳跃移动 4 个单位，以此类推。\n\n给定目标点 $(\\mathrm{X}, \\mathrm{Y})$，判断是否可以到达该点。如果可以，请展示如何以最少的跳跃次数实现。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathrm{T}$。接下来是 $\\mathrm{T}$ 个测试用例，每个测试用例占一行，包含两个整数 $\\mathrm{X}$ 和 $\\mathrm{Y}$，表示目标点的坐标。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 **IMPOSSIBLE**（如果无法到达目标点）。否则，$y$ 应为一个由若干字符组成的字符串，每个字符为 $\\mathrm{N}$（北）、$\\mathrm{S}$（南）、$\\mathrm{E}$（东）或 $\\mathrm{W}$（西），表示按顺序跳跃的方向。此跳跃序列必须在最后一次跳跃结束时到达目标点，且必须是最短的可能序列。\n", "hint": "**样例解释**\n\n在样例 #1 中，你可以从 $(0, 0)$ 向南跳到 $(0, -1)$，然后向东跳到 $(2, -1)$，最后向北跳到 $(2, 3)$。\n\n我们可以确定没有更高效的解决方案（两次或更少跳跃），因为到达目标点至少需要 $2 + 3 = 5$ 个单位的距离，而前两次跳跃总共只能提供 $3$ 个单位的距离。\n\n注意，样例 #2 是样例 #1 关于两个坐标轴的镜像，因此答案也是样例 #1 答案中所有方向的镜像。\n\n在样例 #3 中，注意 **EWE** 不是一个有效答案，尽管它能到达目标点，因为存在使用更少跳跃次数的方案。\n\n我们留给你思考为什么在样例 #4 中无法到达目标点。\n\n**数据范围**\n\n- $(\\text{X}, \\text{Y}) \\neq (0, 0)$。\n\n**测试集 1（5 分，可见判定）**\n\n- $1 \\leqslant \\text{T} \\leqslant 80$。\n- $-4 \\leqslant \\text{X} \\leqslant 4$。\n- $-4 \\leqslant \\text{Y} \\leqslant 4$。\n\n**测试集 2（8 分，可见判定）**\n\n- $1 \\leqslant \\text{T} \\leqslant 100$。\n- $-100 \\leqslant \\text{X} \\leqslant 100$。\n- $-100 \\leqslant \\text{Y} \\leqslant 100$。\n\n**测试集 3（16 分，可见判定）**\n\n- $1 \\leqslant \\text{T} \\leqslant 100$。\n- $-10^{9} \\leqslant \\text{X} \\leqslant 10^{9}$。\n- $-10^{9} \\leqslant \\text{Y} \\leqslant 10^{9}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13057", "type": "P", "difficulty": 5, "samples": [["", ""]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["计算几何", "2020", "二分", "交互题", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2020 #1B] Blindfolded Bullseye", "background": "", "description": "Gary has a large square wall that is exactly $2 \\times 10^{9}$ nanometers tall and $2 \\times 10^{9}$ nanometers wide. Gary has a dartboard placed on the wall. The dartboard is circular and its radius is between A and B nanometers, inclusive. The dartboard is fully contained within the wall, but it may touch its edges. The center of the dartboard is an integer number of nanometers from each edge of the wall.\n\nGary invited his friend Mika over to play an interesting game. Gary blindfolds Mika and challenges her to throw a dart at the center of the dartboard. To help her, whenever Mika throws a dart at the wall, Gary will tell her whether the dart hit the dartboard.\n\nMika does not know where on the wall the dartboard is, but since Mika is very skilled at darts, she can throw darts with nanometer precision. That is, she can aim and hit exactly any point that is an integer number of nanometers away from each edge of the wall. Immediately after throwing each dart, Gary tells her whether she hit the center of the dartboard, some other part of it, or missed it completely and hit the bare wall.\n\nCan you help Mika hit the center of the dartboard, without throwing more than 300 darts?\n\n### Interactive Protocol\n\nInitially, your program should read a single line containing three integers $\\mathbf{T}$, $\\mathbf{A}$ and $\\mathbf{B}$, indicating the number of test cases and the inclusive minimum and maximum values for the dartboard's radius, in nanometers, respectively. (Notice that $\\mathbf{A}$ and $\\mathbf{B}$ are the same for every test case within a test set.) Then, you need to process $\\mathbf{T}$ test cases.\n\nWe represent the points that darts can be aimed at as pairs $(x, y)$, where $x$ and $y$ are integers between $-10^{9}$ and $10^{9}$, inclusive. The pair $(x, y)$ is the point that is $x + 10^{9}$ nanometers away from the left edge of the wall and $y + 10^{9}$ nanometers away from the bottom edge of the wall. Point $(0, 0)$ is therefore at the exact center of the wall.\n\nFor each test case, there is a secretly chosen radius $R$ for the dartboard, and a secretly chosen center of the dartboard $(X, Y)$. $R$, $X$, and $Y$ are integers chosen for each test case by the judges in a designed (not random) way, within the limits. For each test case you need to process up to 300 exchanges with the judge. Your program represents Mika and the judge program represents Gary. Each exchange consists of Mika (your program) choosing where to throw a dart and Gary (the judging program) giving information about that position.\n\nThe $i$-th exchange consists of your program first outputting a single line containing two integers $X_{i}$ and $Y_{i}$, both between $-10^{9}$ and $10^{9}$, inclusive, and the judge responding with a single line containing either:\n\n* `CENTER` if $X_{i} = X$ and $Y_{i} = Y$\n* `HIT` if $0 < (X - X_{i})^{2} + (Y - Y_{i})^{2} \\leq R^{2}$\n* `MISS` in all other cases.\n\nAfter sending CENTER, the judge will start waiting for the first exchange of the next test case, if there is any.\n\nIf you output a line that is incorrectly formatted or with an out of bounds value, the judge will respond with a single line containing WRONG. If 300 exchanges occur (including 300 responses from the judge) without you receiving CENTER, or if you ever receive WRONG, the judge will finish all communication, wait for your own program to also finish, and give a Wrong Answer verdict. After sending the $T$-th CENTER, on the other hand, the judge will finish all communication, wait for your own program to finish, and give a Correct verdict. If, while waiting for your program to finish, time or memory limits are exceeded, the corresponding verdict will be assigned instead. (Note that verdicts are not messages sent to your program.)", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nThe following sample interaction uses the limits of Test Set 1.\n\n```\n  // The following reads 20 into t and 999999995 into a and b.\n  t, a, b = readline_int_list()\n  // The judge secretly picks R = 999999995 (it had no choice) and X = -1,\n  // Y = 3 (it did have a choice here). (Note: the actual Test Set 1 will\n  // not necessarily use the values in this example.)\n  // We try to throw at the upper left corner of the wall, and the dartboard\n  // does not overlap with that point.\n  printline -1000000000 1000000000 to stdout\n  flush stdout\n  r = readline_string()  // reads MISS.\n  // We try to throw at the center of the wall. That does hit the dartboard,\n  // but not the center.\n  printline 0 0 to stdout\n  flush stdout\n  r = readline_string()  // reads HIT.\n  // We make a super lucky choice and throw at the center of the dartboard.\n  printline -1 3 to stdout\n  flush stdout\n  r = readline_string()  // reads CENTER.\n  // The judge begins the next test case. It secretly picks R = 999999995\n  // and X = 5, Y = 5.\n  // We accidentally throw a dart out of the allowed range.\n  printline -1234567890 1234567890 to stdout\n  flush stdout\n  r = readline_string()  // reads WRONG.\n  exit  // exits to avoid an ambiguous TLE error.\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 20$.\n- $\\mathbf{A} \\leqslant \\mathbf{R} \\leqslant \\mathbf{B}$.\n- $-10^{9} + \\mathbf{R} \\leqslant \\mathbf{X} \\leqslant 10^{9} - \\mathbf{R}$.\n- $-10^{9} + \\mathbf{R} \\leqslant \\mathbf{Y} \\leqslant 10^{9} - \\mathbf{R}$.\n\n**Test set 1 (3 Pts, Visible Verdict)**\n\n- $\\mathbf{A} = \\mathbf{B} = 10^{9} - 5$.\n\n**Test set 2 (12 Pts, Visible Verdict)**\n\n- $\\mathbf{A} = \\mathbf{B} = 10^{9} - 50$.\n\n**Test set 3 (19 Pts, Hidden Verdict)**\n\n- $\\mathbf{A} = 10^{9} / 2$.\n- $\\mathbf{B} = 10^{9}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1B] Blindfolded Bullseye", "background": "", "description": "Gary has a large square wall that is exactly $2 \\times 10^{9}$ nanometers tall and $2 \\times 10^{9}$ nanometers wide. Gary has a dartboard placed on the wall. The dartboard is circular and its radius is between A and B nanometers, inclusive. The dartboard is fully contained within the wall, but it may touch its edges. The center of the dartboard is an integer number of nanometers from each edge of the wall.\n\nGary invited his friend Mika over to play an interesting game. Gary blindfolds Mika and challenges her to throw a dart at the center of the dartboard. To help her, whenever Mika throws a dart at the wall, Gary will tell her whether the dart hit the dartboard.\n\nMika does not know where on the wall the dartboard is, but since Mika is very skilled at darts, she can throw darts with nanometer precision. That is, she can aim and hit exactly any point that is an integer number of nanometers away from each edge of the wall. Immediately after throwing each dart, Gary tells her whether she hit the center of the dartboard, some other part of it, or missed it completely and hit the bare wall.\n\nCan you help Mika hit the center of the dartboard, without throwing more than 300 darts?\n\n### Interactive Protocol\n\nInitially, your program should read a single line containing three integers $\\mathbf{T}$, $\\mathbf{A}$ and $\\mathbf{B}$, indicating the number of test cases and the inclusive minimum and maximum values for the dartboard's radius, in nanometers, respectively. (Notice that $\\mathbf{A}$ and $\\mathbf{B}$ are the same for every test case within a test set.) Then, you need to process $\\mathbf{T}$ test cases.\n\nWe represent the points that darts can be aimed at as pairs $(x, y)$, where $x$ and $y$ are integers between $-10^{9}$ and $10^{9}$, inclusive. The pair $(x, y)$ is the point that is $x + 10^{9}$ nanometers away from the left edge of the wall and $y + 10^{9}$ nanometers away from the bottom edge of the wall. Point $(0, 0)$ is therefore at the exact center of the wall.\n\nFor each test case, there is a secretly chosen radius $R$ for the dartboard, and a secretly chosen center of the dartboard $(X, Y)$. $R$, $X$, and $Y$ are integers chosen for each test case by the judges in a designed (not random) way, within the limits. For each test case you need to process up to 300 exchanges with the judge. Your program represents Mika and the judge program represents Gary. Each exchange consists of Mika (your program) choosing where to throw a dart and Gary (the judging program) giving information about that position.\n\nThe $i$-th exchange consists of your program first outputting a single line containing two integers $X_{i}$ and $Y_{i}$, both between $-10^{9}$ and $10^{9}$, inclusive, and the judge responding with a single line containing either:\n\n* `CENTER` if $X_{i} = X$ and $Y_{i} = Y$\n* `HIT` if $0 < (X - X_{i})^{2} + (Y - Y_{i})^{2} \\leq R^{2}$\n* `MISS` in all other cases.\n\nAfter sending CENTER, the judge will start waiting for the first exchange of the next test case, if there is any.\n\nIf you output a line that is incorrectly formatted or with an out of bounds value, the judge will respond with a single line containing WRONG. If 300 exchanges occur (including 300 responses from the judge) without you receiving CENTER, or if you ever receive WRONG, the judge will finish all communication, wait for your own program to also finish, and give a Wrong Answer verdict. After sending the $T$-th CENTER, on the other hand, the judge will finish all communication, wait for your own program to finish, and give a Correct verdict. If, while waiting for your program to finish, time or memory limits are exceeded, the corresponding verdict will be assigned instead. (Note that verdicts are not messages sent to your program.)", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nThe following sample interaction uses the limits of Test Set 1.\n\n```\n  // The following reads 20 into t and 999999995 into a and b.\n  t, a, b = readline_int_list()\n  // The judge secretly picks R = 999999995 (it had no choice) and X = -1,\n  // Y = 3 (it did have a choice here). (Note: the actual Test Set 1 will\n  // not necessarily use the values in this example.)\n  // We try to throw at the upper left corner of the wall, and the dartboard\n  // does not overlap with that point.\n  printline -1000000000 1000000000 to stdout\n  flush stdout\n  r = readline_string()  // reads MISS.\n  // We try to throw at the center of the wall. That does hit the dartboard,\n  // but not the center.\n  printline 0 0 to stdout\n  flush stdout\n  r = readline_string()  // reads HIT.\n  // We make a super lucky choice and throw at the center of the dartboard.\n  printline -1 3 to stdout\n  flush stdout\n  r = readline_string()  // reads CENTER.\n  // The judge begins the next test case. It secretly picks R = 999999995\n  // and X = 5, Y = 5.\n  // We accidentally throw a dart out of the allowed range.\n  printline -1234567890 1234567890 to stdout\n  flush stdout\n  r = readline_string()  // reads WRONG.\n  exit  // exits to avoid an ambiguous TLE error.\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 20$.\n- $\\mathbf{A} \\leqslant \\mathbf{R} \\leqslant \\mathbf{B}$.\n- $-10^{9} + \\mathbf{R} \\leqslant \\mathbf{X} \\leqslant 10^{9} - \\mathbf{R}$.\n- $-10^{9} + \\mathbf{R} \\leqslant \\mathbf{Y} \\leqslant 10^{9} - \\mathbf{R}$.\n\n**Test set 1 (3 Pts, Visible Verdict)**\n\n- $\\mathbf{A} = \\mathbf{B} = 10^{9} - 5$.\n\n**Test set 2 (12 Pts, Visible Verdict)**\n\n- $\\mathbf{A} = \\mathbf{B} = 10^{9} - 50$.\n\n**Test set 3 (19 Pts, Hidden Verdict)**\n\n- $\\mathbf{A} = 10^{9} / 2$.\n- $\\mathbf{B} = 10^{9}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1B] Blindfolded Bullseye", "background": "", "description": "Gary 有一面巨大的正方形墙，高度和宽度均为 $2 \\times 10^{9}$ 纳米。Gary 在墙上放置了一个圆形飞镖靶。飞镖靶的半径 $R$ 介于 $\\mathbf{A}$ 和 $\\mathbf{B}$ 纳米之间（含端点），且完全位于墙内（允许接触边缘）。飞镖靶的中心与墙的每条边的距离均为整数纳米。\n\nGary 邀请了他的朋友 Mika 来玩一个有趣的游戏。Gary 蒙住 Mika 的眼睛，并挑战她向飞镖靶的中心投掷飞镖。为了帮助她，每当 Mika 向墙上投掷飞镖时，Gary 会告诉她飞镖是否击中了飞镖靶。\n\nMika 不知道飞镖靶在墙上的具体位置，但由于她投掷飞镖的技术非常高超，可以精确到纳米级别。也就是说，她可以瞄准并击中墙上任意一个与边缘距离为整数纳米的点。每次投掷后，Gary 会立即告诉她是否击中了飞镖靶的中心、飞镖靶的其他部分，或者完全未击中飞镖靶（即击中墙面）。\n\n你能帮助 Mika 在不超过 300 次投掷的情况下击中飞镖靶的中心吗？\n\n### 交互协议\n\n初始时，你的程序应读取一行，包含三个整数 $\\mathbf{T}$、$\\mathbf{A}$ 和 $\\mathbf{B}$，分别表示测试用例的数量以及飞镖靶半径的最小值和最大值（单位为纳米）。（注意，$\\mathbf{A}$ 和 $\\mathbf{B}$ 在同一测试集中对所有测试用例相同。）然后，你需要处理 $\\mathbf{T}$ 个测试用例。\n\n我们将可投掷的点表示为 $(x, y)$，其中 $x$ 和 $y$ 是介于 $-10^{9}$ 和 $10^{9}$ 之间的整数。点 $(x, y)$ 表示该点距离墙的左边缘 $x + 10^{9}$ 纳米，距离墙的底边缘 $y + 10^{9}$ 纳米。因此，点 $(0, 0)$ 位于墙的正中心。\n\n对于每个测试用例，裁判会秘密选择一个飞镖靶的半径 $R$ 和中心 $(X, Y)$。$R$、$X$ 和 $Y$ 是裁判为每个测试用例设计的整数（非随机），且满足题目限制。对于每个测试用例，你最多可以与裁判进行 300 次交互。你的程序代表 Mika，裁判程序代表 Gary。每次交互包含以下步骤：\n\n1. 你的程序输出一行，包含两个整数 $X_{i}$ 和 $Y_{i}$（均在 $-10^{9}$ 到 $10^{9}$ 之间），表示投掷的坐标。\n2. 裁判会响应一行，内容为以下之一：\n   - `CENTER`：如果 $X_{i} = X$ 且 $Y_{i} = Y$（即击中中心）。\n   - `HIT`：如果 $0 < (X - X_{i})^{2} + (Y - Y_{i})^{2} \\leq R^{2}$（即击中飞镖靶但未击中中心）。\n   - `MISS`：其他情况（未击中飞镖靶）。\n\n当裁判返回 `CENTER` 后，它会开始等待下一个测试用例的交互（如果有）。\n\n如果你的输出格式错误或超出范围，裁判会返回 `WRONG`。如果在 300 次交互内未收到 `CENTER`，或者收到 `WRONG`，裁判会终止通信并判定为错误答案。如果成功在第 $T$ 个测试用例返回 `CENTER`，裁判会终止通信并判定为正确。如果程序超时或内存超限，会相应判定。\n", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "**样例解释**\n\n以下是一个使用测试集 1 限制的样例交互：\n\n```\n// 读取 t = 20, a = 999999995, b = 999999995\nt, a, b = readline_int_list()\n// 裁判秘密选择 R = 999999995 和 X = -1, Y = 3\n// 尝试投掷到墙的左上角，未击中飞镖靶\nprintline -1000000000 1000000000 to stdout\nflush stdout\nr = readline_string() // 返回 MISS\n// 尝试投掷到墙的中心，击中飞镖靶但未击中中心\nprintline 0 0 to stdout\nflush stdout\nr = readline_string() // 返回 HIT\n// 幸运地直接投掷到飞镖靶中心\nprintline -1 3 to stdout\nflush stdout\nr = readline_string() // 返回 CENTER\n// 裁判开始下一个测试用例，选择 R = 999999995, X = 5, Y = 5\n// 尝试投掷超出允许范围\nprintline -1234567890 1234567890 to stdout\nflush stdout\nr = readline_string() // 返回 WRONG\nexit // 退出以避免超时错误\n```\n\n你可以使用[交互测试工具](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)在本地或平台上测试。工具的使用说明包含在注释中。请注意，该工具并非真实裁判系统，行为可能有所不同。\n\n**数据范围**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 20$。\n- $\\mathbf{A} \\leqslant \\mathbf{R} \\leqslant \\mathbf{B}$。\n- $-10^{9} + \\mathbf{R} \\leqslant \\mathbf{X} \\leqslant 10^{9} - \\mathbf{R}$。\n- $-10^{9} + \\mathbf{R} \\leqslant \\mathbf{Y} \\leqslant 10^{9} - \\mathbf{R}$。\n\n**测试集 1（3 分，可见判定）**\n\n- $\\mathbf{A} = \\mathbf{B} = 10^{9} - 5$。\n\n**测试集 2（12 分，可见判定）**\n\n- $\\mathbf{A} = \\mathbf{B} = 10^{9} - 50$。\n\n**测试集 3（19 分，隐藏判定）**\n\n- $\\mathbf{A} = 10^{9} / 2$。\n- $\\mathbf{B} = 10^{9}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13058", "type": "P", "difficulty": 5, "samples": [["3\n2 2\n3 2\n2 3", "Case #1: 1\n2 1\nCase #2: 2\n3 2\n2 1\nCase #3: 2\n2 3\n2 2"]], "limits": {"time": [30000, 30000, 60000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2020", "Special Judge", "Ad-hoc", "Google Code Jam"], "title": "[GCJ 2020 #1B] Join the Ranks\t", "background": "", "description": "You recently acquired a new deck of cards. Each card displays a rank, which is an integer between 1 and $\\mathbf{R}$, and a suit, which is an integer between 1 and $\\mathbf{S}$. For each combination of a rank and a suit, there is exactly one card that displays it, meaning that the deck has $\\mathbf{R} \\times \\mathbf{S}$ cards in total. We will denote a card with rank $r$ and suit $s$ as $(r, s)$.\n\nBeing brand new, the deck is sorted from top to bottom by suit in increasing order, with ties being broken by ranks in increasing order. That is, $(1, 1)$ comes first, then $(2, 1)$, ..., $(\\mathbf{R}, 1)$, then $(1, 2)$, $(2, 2)$, ..., $(\\mathbf{R}, 2)$, and so on up to $(\\mathbf{R}, \\mathbf{S})$. For example, with $\\mathbf{R} = 4$ ranks and $\\mathbf{S} = 2$ suits, the initial ordering would be: $(1, 1)$, $(2, 1)$, $(3, 1)$, $(4, 1)$, $(1, 2)$, $(2, 2)$, $(3, 2)$, $(4, 2)$.\n\nYou want to reorder the deck to be sorted by rank. That is, you want to put all the cards of the same rank together, and have the ranks be in increasing order. You do not care, however, about the order of the suits within each rank. For example, with $\\mathbf{R} = 4$ and $\\mathbf{S} = 2$, one of the various possible valid new orderings would be: $(1, 2)$, $(1, 1)$, $(2, 1)$, $(2, 2)$, $(3, 1)$, $(3, 2)$, $(4, 2)$, $(4, 1)$.\n\nYou have been learning how to cook, so you want to reorder the deck without putting your spatulas down. You decided to sort the deck using only the following multi-part operation:\n\n* First, take one or more cards from the top of the deck, and set that selection aside as pile A.\n* Next, take one or more cards from the new top of the deck, and set that selection aside as pile B.\n* Finally, put pile A on top of the deck, and then put pile B on top of the new deck.\n\nNotice that the operation exchanges the pile A part of the deck and the pile B part of the deck, without affecting any other cards deeper in the deck (if there are any).\n\nContinuing with our $\\mathbf{R} = 4$, $\\mathbf{S} = 2$ example, if your first move is to choose 3 cards from the top for pile A and 2 cards for pile B, then these are the cards you get:\n\n- A: $(1, 1)$, $(2, 1)$, $(3, 1)$,\n- B: $(4, 1)$, $(1, 2)$, and\n- Remainder of deck: $(2, 2)$, $(3, 2)$, $(4, 2)$.\n\nAfter putting A on the deck and then B on top of that, the new deck is ordered like this:\n\n$(4, 1)$, $(1, 2)$, $(1, 1)$, $(2, 1)$, $(3, 1)$, $(2, 2)$, $(3, 2)$, $(4, 2)$.\n\nGiven $\\mathbf{R}$ and $\\mathbf{S}$, find a sequence of operations that reorders the deck to be sorted by rank, as described above, and uses the minimum possible number of operations to do so.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each of these lines describes a single test case with two integers $\\mathbf{R}$ and $\\mathbf{S}$, the number of ranks and suits in the deck, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of operations needed to reorder the deck as explained above. Then, print $y$ more lines containing $a_{i}$ $b_{i}$, meaning that in the $i$-th operation in a sequence of moves that reorders the deck, you take $a_{i}$ cards first to form pile A and then $b_{i}$ cards after that to form pile B.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the initial order is $(1, 1)$, $(2, 1)$, $(1, 2)$, $(2, 2)$. After swapping $A = (1, 1)$, $(2, 1)$ and $B = (1, 2)$ the deck is left as $(1, 2)$, $(1, 1)$, $(2, 1)$, $(2, 2)$, which is sorted by rank as needed. Notice that the suits are in different orders within each rank, which is allowed.\n\nIn Sample Case #2, the initial order is $(1, 1)$, $(2, 1)$, $(3, 1)$, $(1, 2)$, $(2, 2)$, $(3, 2)$. After swapping $A = (1, 1)$, $(2, 1)$, $(3, 1)$ and $B = (1, 2)$, $(2, 2)$ the deck is left as $(1, 2)$, $(2, 2)$, $(1, 1)$, $(2, 1)$, $(3, 1)$, $(3, 2)$. In a second move, we can do $A = (1, 2)$, $(2, 2)$ and $B = (1, 1)$ to get $(1, 1)$, $(1, 2)$, $(2, 2)$, $(2, 1)$, $(3, 1)$, $(3, 2)$.\n\nIn Sample Case #3, another valid solution is $a_{1} = 4$, $b_{1} = 1$ first, and then $a_{2} = 3$ and $b_{2} = 1$.\n\n**Limits**\n\n**Test set 1 (14 Pts, Visible Verdict)**\n\n- Time limit: 30 seconds.\n- $\\mathbf{T} = 12$.\n- $2 \\leq \\mathbf{R} \\leq 5$.\n- $2 \\leq \\mathbf{S} \\leq 7$.\n- $\\mathbf{R} \\times \\mathbf{S} \\leq 14$.\n\n**Test set 2 (23 Pts, Hidden Verdict)**\n\n- Time limit: 60 seconds.\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{R} \\leq 40$.\n- $2 \\leq \\mathbf{S} \\leq 40$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1B] Join the Ranks\t", "background": "", "description": "You recently acquired a new deck of cards. Each card displays a rank, which is an integer between 1 and $\\mathbf{R}$, and a suit, which is an integer between 1 and $\\mathbf{S}$. For each combination of a rank and a suit, there is exactly one card that displays it, meaning that the deck has $\\mathbf{R} \\times \\mathbf{S}$ cards in total. We will denote a card with rank $r$ and suit $s$ as $(r, s)$.\n\nBeing brand new, the deck is sorted from top to bottom by suit in increasing order, with ties being broken by ranks in increasing order. That is, $(1, 1)$ comes first, then $(2, 1)$, ..., $(\\mathbf{R}, 1)$, then $(1, 2)$, $(2, 2)$, ..., $(\\mathbf{R}, 2)$, and so on up to $(\\mathbf{R}, \\mathbf{S})$. For example, with $\\mathbf{R} = 4$ ranks and $\\mathbf{S} = 2$ suits, the initial ordering would be: $(1, 1)$, $(2, 1)$, $(3, 1)$, $(4, 1)$, $(1, 2)$, $(2, 2)$, $(3, 2)$, $(4, 2)$.\n\nYou want to reorder the deck to be sorted by rank. That is, you want to put all the cards of the same rank together, and have the ranks be in increasing order. You do not care, however, about the order of the suits within each rank. For example, with $\\mathbf{R} = 4$ and $\\mathbf{S} = 2$, one of the various possible valid new orderings would be: $(1, 2)$, $(1, 1)$, $(2, 1)$, $(2, 2)$, $(3, 1)$, $(3, 2)$, $(4, 2)$, $(4, 1)$.\n\nYou have been learning how to cook, so you want to reorder the deck without putting your spatulas down. You decided to sort the deck using only the following multi-part operation:\n\n* First, take one or more cards from the top of the deck, and set that selection aside as pile A.\n* Next, take one or more cards from the new top of the deck, and set that selection aside as pile B.\n* Finally, put pile A on top of the deck, and then put pile B on top of the new deck.\n\nNotice that the operation exchanges the pile A part of the deck and the pile B part of the deck, without affecting any other cards deeper in the deck (if there are any).\n\nContinuing with our $\\mathbf{R} = 4$, $\\mathbf{S} = 2$ example, if your first move is to choose 3 cards from the top for pile A and 2 cards for pile B, then these are the cards you get:\n\n- A: $(1, 1)$, $(2, 1)$, $(3, 1)$,\n- B: $(4, 1)$, $(1, 2)$, and\n- Remainder of deck: $(2, 2)$, $(3, 2)$, $(4, 2)$.\n\nAfter putting A on the deck and then B on top of that, the new deck is ordered like this:\n\n$(4, 1)$, $(1, 2)$, $(1, 1)$, $(2, 1)$, $(3, 1)$, $(2, 2)$, $(3, 2)$, $(4, 2)$.\n\nGiven $\\mathbf{R}$ and $\\mathbf{S}$, find a sequence of operations that reorders the deck to be sorted by rank, as described above, and uses the minimum possible number of operations to do so.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow. Each of these lines describes a single test case with two integers $\\mathbf{R}$ and $\\mathbf{S}$, the number of ranks and suits in the deck, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of operations needed to reorder the deck as explained above. Then, print $y$ more lines containing $a_{i}$ $b_{i}$, meaning that in the $i$-th operation in a sequence of moves that reorders the deck, you take $a_{i}$ cards first to form pile A and then $b_{i}$ cards after that to form pile B.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the initial order is $(1, 1)$, $(2, 1)$, $(1, 2)$, $(2, 2)$. After swapping $A = (1, 1)$, $(2, 1)$ and $B = (1, 2)$ the deck is left as $(1, 2)$, $(1, 1)$, $(2, 1)$, $(2, 2)$, which is sorted by rank as needed. Notice that the suits are in different orders within each rank, which is allowed.\n\nIn Sample Case #2, the initial order is $(1, 1)$, $(2, 1)$, $(3, 1)$, $(1, 2)$, $(2, 2)$, $(3, 2)$. After swapping $A = (1, 1)$, $(2, 1)$, $(3, 1)$ and $B = (1, 2)$, $(2, 2)$ the deck is left as $(1, 2)$, $(2, 2)$, $(1, 1)$, $(2, 1)$, $(3, 1)$, $(3, 2)$. In a second move, we can do $A = (1, 2)$, $(2, 2)$ and $B = (1, 1)$ to get $(1, 1)$, $(1, 2)$, $(2, 2)$, $(2, 1)$, $(3, 1)$, $(3, 2)$.\n\nIn Sample Case #3, another valid solution is $a_{1} = 4$, $b_{1} = 1$ first, and then $a_{2} = 3$ and $b_{2} = 1$.\n\n**Limits**\n\n**Test set 1 (14 Pts, Visible Verdict)**\n\n- Time limit: 30 seconds.\n- $\\mathbf{T} = 12$.\n- $2 \\leq \\mathbf{R} \\leq 5$.\n- $2 \\leq \\mathbf{S} \\leq 7$.\n- $\\mathbf{R} \\times \\mathbf{S} \\leq 14$.\n\n**Test set 2 (23 Pts, Hidden Verdict)**\n\n- Time limit: 60 seconds.\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{R} \\leq 40$.\n- $2 \\leq \\mathbf{S} \\leq 40$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1B] Join the Ranks", "background": "", "description": "你最近获得了一副新卡牌。每张卡牌显示一个**点数**（介于 1 和 $\\mathbf{R}$ 之间的整数）和一个**花色**（介于 1 和 $\\mathbf{S}$ 之间的整数）。对于每个点数和花色的组合，恰好有一张对应的卡牌，这意味着这副牌共有 $\\mathbf{R} \\times \\mathbf{S}$ 张。我们将点数为 $r$、花色为 $s$ 的卡牌记为 $(r, s)$。\n\n由于是全新的牌组，初始时卡牌按花色从小到大排序，相同花色时按点数从小到大排序。也就是说，$(1, 1)$ 在最上面，接着是 $(2, 1)$，……，$(\\mathbf{R}, 1)$，然后是 $(1, 2)$，$(2, 2)$，……，$(\\mathbf{R}, 2)$，依此类推直到 $(\\mathbf{R}, \\mathbf{S})$。例如，$\\mathbf{R} = 4$ 点、$\\mathbf{S} = 2$ 花色时，初始顺序为：$(1, 1)$，$(2, 1)$，$(3, 1)$，$(4, 1)$，$(1, 2)$，$(2, 2)$，$(3, 2)$，$(4, 2)$。\n\n你希望重新排列牌组，使其按点数排序。也就是说，你想将所有相同点数的卡牌放在一起，并按点数升序排列。但你不在乎每个点数内部花色的顺序。例如，$\\mathbf{R} = 4$ 和 $\\mathbf{S} = 2$ 时，一种可能的有效新顺序是：$(1, 2)$，$(1, 1)$，$(2, 1)$，$(2, 2)$，$(3, 1)$，$(3, 2)$，$(4, 2)$，$(4, 1)$。\n\n你最近在学习烹饪，因此希望在不放下锅铲的情况下完成牌组排序。你决定仅使用以下多步操作来排序牌组：\n\n1. 首先，从牌组顶部取一张或多张卡牌，作为堆叠 A。\n2. 接着，从新的牌组顶部再取一张或多张卡牌，作为堆叠 B。\n3. 最后，将堆叠 A 放回牌组顶部，再将堆叠 B 放在新的牌组顶部。\n\n注意，该操作交换了牌组的堆叠 A 部分和堆叠 B 部分，而不会影响更深层的卡牌（如果有的话）。\n\n继续以 $\\mathbf{R} = 4$、$\\mathbf{S} = 2$ 为例，如果第一次操作选择 3 张卡牌作为堆叠 A，2 张作为堆叠 B，则得到：\n\n- A：$(1, 1)$，$(2, 1)$，$(3, 1)$，\n- B：$(4, 1)$，$(1, 2)$，\n- 剩余牌组：$(2, 2)$，$(3, 2)$，$(4, 2)$。\n\n将 A 放回牌组后再放上 B，新的牌组顺序为：\n\n$(4, 1)$，$(1, 2)$，$(1, 1)$，$(2, 1)$，$(3, 1)$，$(2, 2)$，$(3, 2)$，$(4, 2)$。\n\n给定 $\\mathbf{R}$ 和 $\\mathbf{S}$，找到一系列操作，将牌组重新排序为按点数排序（如上所述），并使用尽可能少的操作次数完成。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。接下来的 $\\mathbf{T}$ 行每行描述一个测试用例，包含两个整数 $\\mathbf{R}$ 和 $\\mathbf{S}$，分别表示牌组的点数和花色数量。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是重新排序牌组所需的最少操作次数。然后，输出 $y$ 行，每行包含 $a_{i}$ $b_{i}$，表示在第 $i$ 次操作中，先取 $a_{i}$ 张卡牌作为堆叠 A，再取 $b_{i}$ 张卡牌作为堆叠 B。\n", "hint": "**样例解释**\n\n在样例 #1 中，初始顺序为 $(1, 1)$，$(2, 1)$，$(1, 2)$，$(2, 2)$。交换 $A = (1, 1)$，$(2, 1)$ 和 $B = (1, 2)$ 后，牌组变为 $(1, 2)$，$(1, 1)$，$(2, 1)$，$(2, 2)$，满足按点数排序的要求。注意，每个点数内部的花色顺序可以不同，这是允许的。\n\n在样例 #2 中，初始顺序为 $(1, 1)$，$(2, 1)$，$(3, 1)$，$(1, 2)$，$(2, 2)$，$(3, 2)$。第一次操作交换 $A = (1, 1)$，$(2, 1)$，$(3, 1)$ 和 $B = (1, 2)$，$(2, 2)$ 后，牌组变为 $(1, 2)$，$(2, 2)$，$(1, 1)$，$(2, 1)$，$(3, 1)$，$(3, 2)$。第二次操作交换 $A = (1, 2)$，$(2, 2)$ 和 $B = (1, 1)$ 后，牌组变为 $(1, 1)$，$(1, 2)$，$(2, 2)$，$(2, 1)$，$(3, 1)$，$(3, 2)$。\n\n在样例 #3 中，另一种有效解法是第一次操作 $a_{1} = 4$，$b_{1} = 1$，第二次操作 $a_{2} = 3$，$b_{2} = 1$。\n\n**数据范围**\n\n**测试集 1（14 分，可见判定）**\n\n- 时间限制：30 秒。\n- $\\mathbf{T} = 12$。\n- $2 \\leq \\mathbf{R} \\leq 5$。\n- $2 \\leq \\mathbf{S} \\leq 7$。\n- $\\mathbf{R} \\times \\mathbf{S} \\leq 14$。\n\n**测试集 2（23 分，隐藏判定）**\n\n- 时间限制：60 秒。\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{R} \\leq 40$。\n- $2 \\leq \\mathbf{S} \\leq 40$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13059", "type": "P", "difficulty": 2, "samples": [["5\n4 4 SSSS\n3 0 SNSS\n2 10 NSNNSN\n0 1 S\n2 7 SSSSSSSS", "Case #1: 4\nCase #2: IMPOSSIBLE\nCase #3: IMPOSSIBLE\nCase #4: 1\nCase #5: 5"]], "limits": {"time": [20000, 20000, 20000, 20000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["字符串", "2020", "Google Code Jam"], "title": "[GCJ 2020 #1C] Overexcited Fan", "background": "", "description": "Today will be the day—today will be the day that you finally get a picture with Peppurr the cat!\n\nIt has just been announced that Peppurr will be touring your city. The city has infinitely many infinitely-long streets running north-south and infinitely many infinitely-long streets running east-west. An intersection is any point at which a north-south street and an east-west street meet. From any given intersection, the closest intersection in each of the four directions (north, east, south and west) is exactly one block away.\n\nYou know the exact path that Peppurr's tour will take along those streets. Your goal is to be at one of the intersections on Peppurr's tour at the same time that Peppurr is there, and you want to do so as fast as possible. This is how you will get your picture with Peppurr!\n\nPeppurr's tour starts at an intersection that is $\\mathbf{X}$ blocks east and $\\mathbf{Y}$ blocks north of the intersection where you are currently located. Both you and Peppurr take exactly one minute to walk one full block, and must finish each minute at an intersection; neither of you can walk partial blocks.\n\nPeppurr moves along a predefined path. Every minute, you can choose to stand still for the minute, or use it to walk a single block in any of the 4 directions (north, east, south or west). Both you and Peppurr only walk along the streets.\n\nIf you and Peppurr are at the same intersection at the same time, you can take a picture, even at the last intersection of the tour. However, Peppurr is unavailable for pictures after the tour ends, so arriving at the tour's final intersection even a single minute after the tour finishes means you will not get a picture.\n\nIs it possible to get a picture with Peppurr? If so, how soon can you do it?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case consists of one line containing two integers, $\\mathbf{X}$ and $\\mathbf{Y}$, and a string of characters $\\mathbf{M}$. This represents that Peppurr's tour starts exactly $\\mathbf{X}$ blocks east and $\\mathbf{Y}$ blocks north of you. The string $\\mathbf{M}$ is the sequence of moves that Peppurr will make. The $i$-th character in $\\mathbf{M}$ is one of $\\mathbf{N}$, $\\mathbf{E}$, $\\mathbf{S}$ or $\\mathbf{W}$, and corresponds to the direction (north, east, south, or west, respectively) in which Peppurr will walk one block during the tour's $i$-th minute.", "outputFormat": "For each test case, output one line with `Case #x: y`, where $x$ is the test case number (starting from 1). If there is no way to get a picture with Peppurr, $y$ is $\\text{IMPOSSIBLE}$. Otherwise, $y$ is the smallest number of minutes from the start of the tour needed to get a picture with Peppurr.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you can walk east four blocks and you will be able to take a picture with Peppurr on the tour's last intersection.\n\nIn Sample Case #2, the tour starts off exactly three blocks to the east of you. No matter how you move, you cannot get a picture with Peppurr.\n\nIn Sample Case #3, the tour is too far north for you to get the picture before the tour ends.\n\nIn Sample Case #4, the tour will come to you after one minute, so you don't even have to move! Enjoy the picture with Peppurr! Remember that you can only take pictures in intersections, so if you moved north while the tour moved south, which would cause you to cross paths with Peppurr outside of an intersection, you could not get your picture in 0.5 minutes.\n\nIn Sample Case #5, you can move north twice, then east twice. Then, you can stay still and you will be able to take a picture with Peppurr in the next minute. There are other paths you can take which can get you a picture with Peppurr in 5 minutes, but none which can do it sooner than that.\n\nThe following two cases could not appear in Test Set 1 or Test Set 2, but could appear in Test Set 3:\n\n```\n2\n3 2 SSSW\n4 0 NESW\n```\n\nThe correct output for these two cases would be:\n\n```\nCase #1: 4\nCase #2: 4\n```\n\nNote that in Case #1, you can take a picture with Peppurr one block to the south and two blocks to the east of your original starting point.\n\nIn Case #2, Peppurr travels in a small square. You can take a picture when Peppurr returns to the starting point of that square.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $(\\mathbf{X}, \\mathbf{Y}) \\neq (0, 0)$. (The tour does not start in the same intersection as you.)\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 10$.\n- $0 \\leqslant \\mathbf{Y} \\leqslant 10$.\n- $1 \\leqslant \\text{length of } \\mathbf{M} \\leqslant 8$.\n- Each character in $\\mathbf{M}$ is an uppercase letter — either $\\mathbf{N}$ or $\\mathbf{s}$.\n\n**Test Set 2 (6 Pts, Visible Verdict)**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 1000$.\n- $0 \\leqslant \\mathbf{Y} \\leqslant 1000$.\n- $1 \\leqslant \\text{length of } \\mathbf{M} \\leqslant 1000$.\n- Each character in $\\mathbf{M}$ is an uppercase letter — either $\\mathbf{N}$ or $\\mathbf{s}$.\n\n**Test Set 3 (12 Pts, Visible Verdict)**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 1000$.\n- $0 \\leqslant \\mathbf{Y} \\leqslant 1000$.\n- $1 \\leqslant \\text{length of } \\mathbf{M} \\leqslant 1000$.\n- Each character in $\\mathbf{M}$ is an uppercase letter — either $\\mathbf{N}$, $\\mathbf{E}$, $\\mathbf{s}$ or $\\mathbf{w}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1C] Overexcited Fan", "background": "", "description": "Today will be the day—today will be the day that you finally get a picture with Peppurr the cat!\n\nIt has just been announced that Peppurr will be touring your city. The city has infinitely many infinitely-long streets running north-south and infinitely many infinitely-long streets running east-west. An intersection is any point at which a north-south street and an east-west street meet. From any given intersection, the closest intersection in each of the four directions (north, east, south and west) is exactly one block away.\n\nYou know the exact path that Peppurr's tour will take along those streets. Your goal is to be at one of the intersections on Peppurr's tour at the same time that Peppurr is there, and you want to do so as fast as possible. This is how you will get your picture with Peppurr!\n\nPeppurr's tour starts at an intersection that is $\\mathbf{X}$ blocks east and $\\mathbf{Y}$ blocks north of the intersection where you are currently located. Both you and Peppurr take exactly one minute to walk one full block, and must finish each minute at an intersection; neither of you can walk partial blocks.\n\nPeppurr moves along a predefined path. Every minute, you can choose to stand still for the minute, or use it to walk a single block in any of the 4 directions (north, east, south or west). Both you and Peppurr only walk along the streets.\n\nIf you and Peppurr are at the same intersection at the same time, you can take a picture, even at the last intersection of the tour. However, Peppurr is unavailable for pictures after the tour ends, so arriving at the tour's final intersection even a single minute after the tour finishes means you will not get a picture.\n\nIs it possible to get a picture with Peppurr? If so, how soon can you do it?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case consists of one line containing two integers, $\\mathbf{X}$ and $\\mathbf{Y}$, and a string of characters $\\mathbf{M}$. This represents that Peppurr's tour starts exactly $\\mathbf{X}$ blocks east and $\\mathbf{Y}$ blocks north of you. The string $\\mathbf{M}$ is the sequence of moves that Peppurr will make. The $i$-th character in $\\mathbf{M}$ is one of $\\mathbf{N}$, $\\mathbf{E}$, $\\mathbf{S}$ or $\\mathbf{W}$, and corresponds to the direction (north, east, south, or west, respectively) in which Peppurr will walk one block during the tour's $i$-th minute.", "outputFormat": "For each test case, output one line with `Case #x: y`, where $x$ is the test case number (starting from 1). If there is no way to get a picture with Peppurr, $y$ is $\\text{IMPOSSIBLE}$. Otherwise, $y$ is the smallest number of minutes from the start of the tour needed to get a picture with Peppurr.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you can walk east four blocks and you will be able to take a picture with Peppurr on the tour's last intersection.\n\nIn Sample Case #2, the tour starts off exactly three blocks to the east of you. No matter how you move, you cannot get a picture with Peppurr.\n\nIn Sample Case #3, the tour is too far north for you to get the picture before the tour ends.\n\nIn Sample Case #4, the tour will come to you after one minute, so you don't even have to move! Enjoy the picture with Peppurr! Remember that you can only take pictures in intersections, so if you moved north while the tour moved south, which would cause you to cross paths with Peppurr outside of an intersection, you could not get your picture in 0.5 minutes.\n\nIn Sample Case #5, you can move north twice, then east twice. Then, you can stay still and you will be able to take a picture with Peppurr in the next minute. There are other paths you can take which can get you a picture with Peppurr in 5 minutes, but none which can do it sooner than that.\n\nThe following two cases could not appear in Test Set 1 or Test Set 2, but could appear in Test Set 3:\n\n```\n2\n3 2 SSSW\n4 0 NESW\n```\n\nThe correct output for these two cases would be:\n\n```\nCase #1: 4\nCase #2: 4\n```\n\nNote that in Case #1, you can take a picture with Peppurr one block to the south and two blocks to the east of your original starting point.\n\nIn Case #2, Peppurr travels in a small square. You can take a picture when Peppurr returns to the starting point of that square.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $(\\mathbf{X}, \\mathbf{Y}) \\neq (0, 0)$. (The tour does not start in the same intersection as you.)\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 10$.\n- $0 \\leqslant \\mathbf{Y} \\leqslant 10$.\n- $1 \\leqslant \\text{length of } \\mathbf{M} \\leqslant 8$.\n- Each character in $\\mathbf{M}$ is an uppercase letter — either $\\mathbf{N}$ or $\\mathbf{s}$.\n\n**Test Set 2 (6 Pts, Visible Verdict)**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 1000$.\n- $0 \\leqslant \\mathbf{Y} \\leqslant 1000$.\n- $1 \\leqslant \\text{length of } \\mathbf{M} \\leqslant 1000$.\n- Each character in $\\mathbf{M}$ is an uppercase letter — either $\\mathbf{N}$ or $\\mathbf{s}$.\n\n**Test Set 3 (12 Pts, Visible Verdict)**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 1000$.\n- $0 \\leqslant \\mathbf{Y} \\leqslant 1000$.\n- $1 \\leqslant \\text{length of } \\mathbf{M} \\leqslant 1000$.\n- Each character in $\\mathbf{M}$ is an uppercase letter — either $\\mathbf{N}$, $\\mathbf{E}$, $\\mathbf{s}$ or $\\mathbf{w}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1C] Overexcited Fan", "background": "", "description": "今天将是你终于能和猫咪 Peppurr 合影的日子！\n\nPeppurr 即将在你的城市巡游。这座城市有无限多条南北走向和东西走向的无限长街道。任意两条垂直街道的交点称为**十字路口**。从任意一个十字路口出发，往四个方向（北、东、南、西）最近的十字路口都恰好相隔一个街区。\n\n你已知 Peppurr 巡游的完整路径。你的目标是**在 Peppurr 到达某个巡游路线的十字路口的同时**，你也到达该路口，并且希望尽可能快地完成这件事。这就是你与 Peppurr 合影的方式！\n\nPeppurr 的巡游起点位于你当前位置以东 $\\mathbf{X}$ 个街区、以北 $\\mathbf{Y}$ 个街区的十字路口。你和 Peppurr 每走完一个完整街区都需要恰好一分钟，且每分钟结束时必须到达一个十字路口；你们都不能走部分街区。\n\nPeppurr 沿着预定路径移动。每分钟，你可以选择**静止不动**，或者选择向四个方向之一（北、东、南、西）移动一个街区。你和 Peppurr 都只沿街道行走。\n\n如果你和 Peppurr **同时到达同一个十字路口**，你就能成功合影（包括巡游的最后一个路口）。但 Peppurr 在巡游结束后不再接受合影，因此即使只晚一分钟到达巡游终点，也无法合影。\n\n你有可能和 Peppurr 合影吗？如果可能，最快需要多少分钟？", "inputFormat": "输入的第一行包含测试用例数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例，每个用例占一行，包含两个整数 $\\mathbf{X}$、$\\mathbf{Y}$ 和一个字符串 $\\mathbf{M}$。表示 Peppurr 的巡游起点位于你当前位置以东 $\\mathbf{X}$ 个街区、以北 $\\mathbf{Y}$ 个街区的十字路口。字符串 $\\mathbf{M}$ 是 Peppurr 的移动序列，其中第 $i$ 个字符为 $\\mathbf{N}$（北）、$\\mathbf{E}$（东）、$\\mathbf{S}$（南）或 $\\mathbf{W}$（西），对应巡游第 $i$ 分钟 Peppurr 移动的方向。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始）。如果无法与 Peppurr 合影，$y$ 为 `IMPOSSIBLE`；否则 $y$ 为从巡游开始到成功合影所需的最少分钟数。", "hint": "**样例解释**\n\n在样例 #1 中，你可以向东走 4 个街区，在巡游的最后一个十字路口与 Peppurr 合影。\n\n在样例 #2 中，巡游起点位于你以东 3 个街区。无论如何移动，你都无法与 Peppurr 合影。\n\n在样例 #3 中，巡游路线距离你太远，无法在巡游结束前合影。\n\n在样例 #4 中，Peppurr 会在 1 分钟后到达你的位置，因此你甚至不需要移动！注意只能在十字路口合影，如果你向北移动而 Peppurr 向南移动，虽然会在非路口处相遇，但无法在 0.5 分钟时合影。\n\n在样例 #5 中，你可以先向北走 2 次，再向东走 2 次，然后静止不动，下一分钟即可合影。其他路径也可能在 5 分钟时合影，但无法更快。\n\n以下两个样例不会出现在测试集 1 或 2 中，但可能出现在测试集 3：\n\n```\n2\n3 2 SSSW\n4 0 NESW\n```\n\n正确输出应为：\n\n```\nCase #1: 4\nCase #2: 4\n```\n\n注意在样例 #1 中，你可以在起点以南 1 个街区、以东 2 个街区的十字路口与 Peppurr 合影。在样例 #2 中，Peppurr 沿小正方形移动，当其返回起点时即可合影。\n\n**数据范围**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $(\\mathbf{X}, \\mathbf{Y}) \\neq (0, 0)$（巡游起点与你不在同一路口）。\n\n**测试集 1（4 分，可见判定）**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 10$。\n- $0 \\leqslant \\mathbf{Y} \\leqslant 10$。\n- $1 \\leqslant \\mathbf{M} \\text{ 的长度} \\leqslant 8$。\n- $\\mathbf{M}$ 仅包含 $\\mathbf{N}$ 或 $\\mathbf{S}$。\n\n**测试集 2（6 分，可见判定）**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 1000$。\n- $0 \\leqslant \\mathbf{Y} \\leqslant 1000$。\n- $1 \\leqslant \\mathbf{M} \\text{ 的长度} \\leqslant 1000$。\n- $\\mathbf{M}$ 仅包含 $\\mathbf{N}$ 或 $\\mathbf{S}$。\n\n**测试集 3（12 分，可见判定）**\n\n- $0 \\leqslant \\mathbf{X} \\leqslant 1000$。\n- $0 \\leqslant \\mathbf{Y} \\leqslant 1000$。\n- $1 \\leqslant \\mathbf{M} \\text{ 的长度} \\leqslant 1000$。\n- $\\mathbf{M}$ 可包含 $\\mathbf{N}$、$\\mathbf{E}$、$\\mathbf{S}$ 或 $\\mathbf{W}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13060", "type": "P", "difficulty": 4, "samples": [["", ""]], "limits": {"time": [20000, 20000, 20000, 20000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2020", "概率论", "Google Code Jam"], "title": "[GCJ 2020 #1C] Overrandomized", "background": "", "description": "Note: Every time this statement says something is randomly chosen, it means \"chosen uniformly at random across all valid possibilities, and independently from all other choices\".\n\nThe company Banana Rocks Inc. just wrote a premium cloud-based random number generation service that is destined to be the new gold standard of randomness.\n\nThe original design was that a group of servers would receive a request in the form of a single positive integer M of up to $\\mathbf{U}$ decimal digits and then respond with an integer from the range 1 through M, inclusive, chosen at random. However, instead of simply having the output written with digits 0 through 9 as usual, the servers were \"overrandomized\". Each server has a random subset of 10 distinct uppercase English letters to use as digits, and a random mapping from those letters to unique values between 0 and 9.\n\nThe formal description of the current situation is as follows: each server has a digit string D composed of exactly 10 different uppercase English letters. The digit string defines the mapping between letters and the base 10 digits: D's j-th character from the left (counting from 0) is the base 10 digit of value j. For example, if D were CODEJAMFUN then c would represent digit 0, o would represent digit 1 and n would represent digit 9. The number 379009 would be encoded as EFNCCN when using that digit string.\n\nWhen receiving the i-th query with an integer parameter $M_i$, the server:\n\n* chooses an integer $N_i$ at random from the inclusive range 1 through $M_i$,\n* writes it as a base 10 string with no leading zeroes using the j-th character of D (counting starting from 0) as the digit of value j, and\n* returns the resulting string as the response $R_i$.\n\nWe collected some data that we believe we can use to recover the secret digit string D from each server. We sent $10^4$ queries to each server. For each query, we chose a value $M_i$ at random from the range 1 through $10^{\\mathbf{U}} - 1$, inclusive, and received the response $R_i$, a string of up to $\\mathbf{U}$ uppercase English letters. We recorded the pairs $(M_i, R_i)$. As we were moving these records to a new data storage device, the values of all the integers $M_i$ within the records of some servers became corrupted and unreadable.\n\nCan you help us find each server's digit string D?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case contains the records for one server and starts with a line containing a single integer $\\mathbf{U}$, representing that $10^{\\mathbf{U}} - 1$ is the inclusive upper bound for the range in which we chose the integers $M_i$ to query that server. Then, exactly $10^4$ lines follow. Each of these lines contains an integer $\\mathbf{Q}_i$ (in base 10 using digits 0 through 9, as usual) and a string $\\mathbf{R}_i$, representing the i-th query and response, respectively. If $\\mathbf{Q}_i = -1$, then the integer $M_i$ used for the i-th query is unknown. Otherwise, $\\mathbf{Q}_i = M_i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where x is the test case number (starting from 1) and y is the digit string D for the server examined in test case x.", "hint": "**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 10$.\n- $\\mathbf{D}$ is a string of exactly 10 different uppercase English letters, chosen independently and uniformly at random from the set of all such strings.\n- $\\mathbf{M}_i$ is chosen independently and uniformly at random from the range 1 through $10^{\\mathbf{U}} - 1$, inclusive, for all i.\n- $\\mathbf{N}_i$ is chosen independently and uniformly at random from the range 1 through $\\mathbf{M}_i$, inclusive, for all i.\n- $\\mathbf{R}_i$ is the base 10 representation of $\\mathbf{N}_i$, using the j-th digit from the left of $\\mathbf{D}$ (counting starting from 0) as the digit of value j, for all i.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $\\mathbf{Q}_i = \\mathbf{M}_i$, for all i.\n- $\\mathbf{U} = 2$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $\\mathbf{Q}_i = \\mathbf{M}_i$, for all i.\n- $\\mathbf{U} = 16$.\n\n**Test Set 3 (17 Pts, Visible Verdict)**\n\n- $\\mathbf{Q}_i = -1$, for all i.\n- $\\mathbf{U} = 16$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1C] Overrandomized", "background": "", "description": "Note: Every time this statement says something is randomly chosen, it means \"chosen uniformly at random across all valid possibilities, and independently from all other choices\".\n\nThe company Banana Rocks Inc. just wrote a premium cloud-based random number generation service that is destined to be the new gold standard of randomness.\n\nThe original design was that a group of servers would receive a request in the form of a single positive integer M of up to $\\mathbf{U}$ decimal digits and then respond with an integer from the range 1 through M, inclusive, chosen at random. However, instead of simply having the output written with digits 0 through 9 as usual, the servers were \"overrandomized\". Each server has a random subset of 10 distinct uppercase English letters to use as digits, and a random mapping from those letters to unique values between 0 and 9.\n\nThe formal description of the current situation is as follows: each server has a digit string D composed of exactly 10 different uppercase English letters. The digit string defines the mapping between letters and the base 10 digits: D's j-th character from the left (counting from 0) is the base 10 digit of value j. For example, if D were CODEJAMFUN then c would represent digit 0, o would represent digit 1 and n would represent digit 9. The number 379009 would be encoded as EFNCCN when using that digit string.\n\nWhen receiving the i-th query with an integer parameter $M_i$, the server:\n\n* chooses an integer $N_i$ at random from the inclusive range 1 through $M_i$,\n* writes it as a base 10 string with no leading zeroes using the j-th character of D (counting starting from 0) as the digit of value j, and\n* returns the resulting string as the response $R_i$.\n\nWe collected some data that we believe we can use to recover the secret digit string D from each server. We sent $10^4$ queries to each server. For each query, we chose a value $M_i$ at random from the range 1 through $10^{\\mathbf{U}} - 1$, inclusive, and received the response $R_i$, a string of up to $\\mathbf{U}$ uppercase English letters. We recorded the pairs $(M_i, R_i)$. As we were moving these records to a new data storage device, the values of all the integers $M_i$ within the records of some servers became corrupted and unreadable.\n\nCan you help us find each server's digit string D?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case contains the records for one server and starts with a line containing a single integer $\\mathbf{U}$, representing that $10^{\\mathbf{U}} - 1$ is the inclusive upper bound for the range in which we chose the integers $M_i$ to query that server. Then, exactly $10^4$ lines follow. Each of these lines contains an integer $\\mathbf{Q}_i$ (in base 10 using digits 0 through 9, as usual) and a string $\\mathbf{R}_i$, representing the i-th query and response, respectively. If $\\mathbf{Q}_i = -1$, then the integer $M_i$ used for the i-th query is unknown. Otherwise, $\\mathbf{Q}_i = M_i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where x is the test case number (starting from 1) and y is the digit string D for the server examined in test case x.", "hint": "**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 10$.\n- $\\mathbf{D}$ is a string of exactly 10 different uppercase English letters, chosen independently and uniformly at random from the set of all such strings.\n- $\\mathbf{M}_i$ is chosen independently and uniformly at random from the range 1 through $10^{\\mathbf{U}} - 1$, inclusive, for all i.\n- $\\mathbf{N}_i$ is chosen independently and uniformly at random from the range 1 through $\\mathbf{M}_i$, inclusive, for all i.\n- $\\mathbf{R}_i$ is the base 10 representation of $\\mathbf{N}_i$, using the j-th digit from the left of $\\mathbf{D}$ (counting starting from 0) as the digit of value j, for all i.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $\\mathbf{Q}_i = \\mathbf{M}_i$, for all i.\n- $\\mathbf{U} = 2$.\n\n**Test Set 2 (10 Pts, Visible Verdict)**\n\n- $\\mathbf{Q}_i = \\mathbf{M}_i$, for all i.\n- $\\mathbf{U} = 16$.\n\n**Test Set 3 (17 Pts, Visible Verdict)**\n\n- $\\mathbf{Q}_i = -1$, for all i.\n- $\\mathbf{U} = 16$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1C] Overrandomized", "background": "", "description": "**注意**：每当题目描述中提到\"随机选择\"时，均表示\"在所有有效可能性中均匀随机且独立地选择\"。\n\nBanana Rocks 公司开发了一款基于云计算的优质随机数生成服务，旨在成为随机性领域的新黄金标准。\n\n最初的设计是：一组服务器接收一个最多包含 $\\mathbf{U}$ 位十进制数字的正整数 $\\mathbf{M}$ 作为请求，然后返回一个在 1 到 $\\mathbf{M}$ 之间（含端点）随机选择的整数。然而，这些服务器被\"过度随机化\"了——它们没有使用常规的 0-9 数字输出结果，而是每个服务器都随机选取了 10 个不同的大写英文字母作为数字，并随机将这些字母映射到 0-9 的唯一值。\n\n当前情况的正式描述如下：\n- 每个服务器有一个由恰好 10 个不同大写字母组成的**数字字符串 $\\mathbf{D}$**\n- 该字符串定义了字母与十进制数字的映射关系：$\\mathbf{D}$ 中从左数第 $j$ 个字符（从 0 开始计数）代表数值为 $j$ 的数字\n- 例如，若 $\\mathbf{D}$ 为 `CODEJAMFUN`，则 `C` 代表数字 0，`O` 代表数字 1，`N` 代表数字 9。数字 379009 将被编码为 `EFNCCN`\n\n当服务器收到第 $i$ 个参数为 $M_i$ 的查询时，会：\n1. 从 1 到 $M_i$ 的范围内随机选择一个整数 $N_i$\n2. 使用 $\\mathbf{D}$ 中的字母数字表示法将其转换为无前导零的十进制字符串\n3. 返回结果字符串 $R_i$ 作为响应\n\n我们收集了一些数据，认为可以用来恢复每个服务器的秘密数字字符串 $\\mathbf{D}$。我们向每个服务器发送了 $10^4$ 次查询：\n- 每次查询的 $M_i$ 是从 1 到 $10^{\\mathbf{U}}-1$ 范围内随机选择的\n- 收到的响应 $R_i$ 是一个最多包含 $\\mathbf{U}$ 个大写字母的字符串\n- 我们记录了这些 $(M_i, R_i)$ 对\n\n但在将这些记录转移到新存储设备时，部分服务器记录中的所有 $M_i$ 整数值都损坏无法读取了。你能帮我们找出每个服务器的数字字符串 $\\mathbf{D}$ 吗？", "inputFormat": "输入第一行包含测试用例数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例，每个用例包含一个服务器的记录：\n- 第一行是整数 $\\mathbf{U}$，表示查询参数 $M_i$ 的选择范围上限为 $10^{\\mathbf{U}}-1$\n- 接下来是恰好 $10^4$ 行，每行包含一个十进制整数 $\\mathbf{Q}_i$ 和字符串 $\\mathbf{R}_i$\n  - 若 $\\mathbf{Q}_i = -1$，表示该次查询的 $M_i$ 未知\n  - 否则 $\\mathbf{Q}_i = M_i$", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是该服务器对应的数字字符串 $\\mathbf{D}$。\n", "hint": "**数据范围**\n- $1 \\leqslant \\mathbf{T} \\leqslant 10$\n- $\\mathbf{D}$ 是恰好 10 个不同大写字母组成的字符串，从所有可能组合中独立均匀随机选取\n- 对所有 $i$，$M_i$ 从 1 到 $10^{\\mathbf{U}}-1$ 范围内独立均匀随机选取\n- 对所有 $i$，$N_i$ 从 1 到 $M_i$ 范围内独立均匀随机选取\n- 对所有 $i$，$R_i$ 是 $N_i$ 的十进制表示，使用 $\\mathbf{D}$ 中第 $j$ 个字母代表数字 $j$\n\n**测试集 1（9 分，可见判定）**\n- 对所有 $i$，$\\mathbf{Q}_i = M_i$\n- $\\mathbf{U} = 2$\n\n**测试集 2（10 分，可见判定）**\n- 对所有 $i$，$\\mathbf{Q}_i = M_i$\n- $\\mathbf{U} = 16$\n\n**测试集 3（17 分，可见判定）**\n- 对所有 $i$，$\\mathbf{Q}_i = -1$\n- $\\mathbf{U} = 16$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13061", "type": "P", "difficulty": 6, "samples": [["4\n1 3\n1\n5 2\n10 5 359999999999 123456789 10\n2 3\n8 4\n3 2\n1 2 3", "Case #1: 2\nCase #2: 0\nCase #3: 1\nCase #4: 1"]], "limits": {"time": [20000, 20000, 20000, 60000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "贪心", "2020", "Google Code Jam"], "title": "[GCJ 2020 #1C] Oversized Pancake Choppers", "background": "", "description": "You just showed up to your job as the head chef of the Infinite House of Pancakes, and as usual, you found a disaster in progress! The other chefs accidentally created some enormous circular pancakes, all of the same size. These pancakes are too large to serve whole, so they have already started to chop them up into slices (which, in this problem, are circular sectors). You currently have $\\mathbf{N}$ slices, the i-th of which is a sector with an internal (central) angle of $\\mathbf{A}_i$ nanodegrees (a nanodegree is $10^{-9}$ degrees).\n\nYou have $\\mathbf{D}$ diners waiting for their food. Each diner wants a single slice that is the same size as every other diner's slice, although they do not care what that size is. But it may not be possible to do this using the current slices, so you may need to make one or more radial cuts.\n\nA cut changes an existing slice with internal angle $X$ into two new slices with internal angles $Y$ and $X - Y$. You can do this for any $0 < Y < X$, and these values do not need to be integers. You may apply further cuts to either or both of these new slices, and so on.\n\nIt is OK to have one or more leftover slices (of any size) that are not given to the diners; you can eat those later, since this disaster is making you miss your own breakfast!\n\nDetermine the smallest total number of cuts you need to make to satisfy the diners.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line containing two integers $\\mathbf{N}$ and $\\mathbf{D}$: the number of slices you currently have and the number of diners. Then, there is one more line containing $\\mathbf{N}$ integers $\\mathbf{A}_1, \\mathbf{A}_2, ..., \\mathbf{A}_\\mathbf{N}$; the i-th of these represents the internal angle (in nanodegrees) of the i-th slice.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the smallest number of cuts you need, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you only have one tiny slice to start with. The optimal solution is to use one cut to change it into two slices with angles of $1/3$ nanodegree and $2/3$ nanodegrees, and then further cut the latter slice into two more slices with angles of $1/3$ nanodegree.\n\nIn Sample Case #2, you already have two slices of the same size, so you can give those to the two diners, and you do not need to make any cuts.\n\nIn Sample Case #3, the optimal solution is to cut the slice with internal angle 8 nanodegrees in half. After that operation, you have exactly 3 slices of internal angle 4 nanodegrees, with no leftovers.\n\nIn Sample Case #4, remember that every diner must receive a single slice. You cannot give one diner the \"3\" slice and the other diner the \"1\" and \"2\" slices, even though the total areas are the same. You must make at least one cut in this case to satisfy the requirements.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq A_i < 360 \\times 10^9$, for all $i$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $1 \\leq N \\leq 300$.\n- $2 \\leq D \\leq 3$.\n\n**Test Set 2 (16 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $1 \\leq N \\leq 300$.\n- $2 \\leq D \\leq 50$.\n\n**Test Set 3 (16 Pts, Hidden Verdict)**\n\n- Time limit: 60 seconds.\n- For exactly 21 cases, $9000 \\leq N \\leq 10000$.\n- For exactly $T-21$ cases, $1 \\leq N \\leq 1000$.\n- $2 \\leq D \\leq 50$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #1C] Oversized Pancake Choppers", "background": "", "description": "You just showed up to your job as the head chef of the Infinite House of Pancakes, and as usual, you found a disaster in progress! The other chefs accidentally created some enormous circular pancakes, all of the same size. These pancakes are too large to serve whole, so they have already started to chop them up into slices (which, in this problem, are circular sectors). You currently have $\\mathbf{N}$ slices, the i-th of which is a sector with an internal (central) angle of $\\mathbf{A}_i$ nanodegrees (a nanodegree is $10^{-9}$ degrees).\n\nYou have $\\mathbf{D}$ diners waiting for their food. Each diner wants a single slice that is the same size as every other diner's slice, although they do not care what that size is. But it may not be possible to do this using the current slices, so you may need to make one or more radial cuts.\n\nA cut changes an existing slice with internal angle $X$ into two new slices with internal angles $Y$ and $X - Y$. You can do this for any $0 < Y < X$, and these values do not need to be integers. You may apply further cuts to either or both of these new slices, and so on.\n\nIt is OK to have one or more leftover slices (of any size) that are not given to the diners; you can eat those later, since this disaster is making you miss your own breakfast!\n\nDetermine the smallest total number of cuts you need to make to satisfy the diners.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line containing two integers $\\mathbf{N}$ and $\\mathbf{D}$: the number of slices you currently have and the number of diners. Then, there is one more line containing $\\mathbf{N}$ integers $\\mathbf{A}_1, \\mathbf{A}_2, ..., \\mathbf{A}_\\mathbf{N}$; the i-th of these represents the internal angle (in nanodegrees) of the i-th slice.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the smallest number of cuts you need, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you only have one tiny slice to start with. The optimal solution is to use one cut to change it into two slices with angles of $1/3$ nanodegree and $2/3$ nanodegrees, and then further cut the latter slice into two more slices with angles of $1/3$ nanodegree.\n\nIn Sample Case #2, you already have two slices of the same size, so you can give those to the two diners, and you do not need to make any cuts.\n\nIn Sample Case #3, the optimal solution is to cut the slice with internal angle 8 nanodegrees in half. After that operation, you have exactly 3 slices of internal angle 4 nanodegrees, with no leftovers.\n\nIn Sample Case #4, remember that every diner must receive a single slice. You cannot give one diner the \"3\" slice and the other diner the \"1\" and \"2\" slices, even though the total areas are the same. You must make at least one cut in this case to satisfy the requirements.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq A_i < 360 \\times 10^9$, for all $i$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $1 \\leq N \\leq 300$.\n- $2 \\leq D \\leq 3$.\n\n**Test Set 2 (16 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $1 \\leq N \\leq 300$.\n- $2 \\leq D \\leq 50$.\n\n**Test Set 3 (16 Pts, Hidden Verdict)**\n\n- Time limit: 60 seconds.\n- For exactly 21 cases, $9000 \\leq N \\leq 10000$.\n- For exactly $T-21$ cases, $1 \\leq N \\leq 1000$.\n- $2 \\leq D \\leq 50$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #1C] Oversized Pancake Choppers", "background": "", "description": "当你作为\"无限煎饼屋\"的主厨刚上班时，又一次发现灾难现场！其他厨师不小心做出了一些巨大的圆形煎饼，且所有煎饼大小相同。这些煎饼太大无法整块供应，于是他们已经开始将煎饼切成扇形切片（在本问题中即为圆形扇形）。你现在有 $\\mathbf{N}$ 块切片，其中第 $i$ 块是中心角为 $\\mathbf{A}_i$ 纳度（1 纳度 = $10^{-9}$ 度）的扇形。\n\n现在有 $\\mathbf{D}$ 位顾客等待用餐。每位顾客需要**一块**与其他顾客**大小完全相同**的切片（具体大小不限）。但现有切片可能无法满足需求，因此你可能需要进行若干次径向切割。\n\n一次切割操作可以将一个中心角为 $X$ 的切片分成两个新切片，其中心角分别为 $Y$ 和 $X - Y$。其中 $0 < Y < X$ 且不需要为整数。你可以对这两个新切片继续切割，以此类推。\n\n允许存在任意大小的剩余切片（不供应给顾客）——毕竟这场灾难让你错过了早餐！\n\n请计算满足顾客需求所需的最少切割次数。", "inputFormat": "输入第一行包含测试用例数量 $\\mathbf{T}$。随后每个测试用例包含：\n- 第一行：两个整数 $\\mathbf{N}$（现有切片数）和 $\\mathbf{D}$（顾客数）\n- 第二行：$\\mathbf{N}$ 个整数 $\\mathbf{A}_1, \\mathbf{A}_2, ..., \\mathbf{A}_\\mathbf{N}$，表示每块切片的中心角（纳度）\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为所需的最少切割次数。\n", "hint": "**样例解释**\n\n样例 #1：初始只有 1 块极小切片。最优方案是：\n1. 第一次切割得到 $1/3$ 纳度和 $2/3$ 纳度的切片\n2. 将后者再次切割为两块 $1/3$ 纳度的切片\n最终得到 3 块相同切片，共需 2 次切割。\n\n样例 #2：已有两块相同大小的切片可直接供应，无需切割。\n\n样例 #3：最优方案是将 8 纳度的切片对半切割，得到 3 块 4 纳度的切片且无剩余。\n\n样例 #4：注意每位顾客必须获得**单块**切片。即使 \"1+2\" 和 \"3\" 的总面积相同，也不符合要求。此时至少需要进行 1 次切割。\n\n**数据范围**\n- $1 \\leq T \\leq 100$\n- $1 \\leq A_i < 360 \\times 10^9$（所有 $i$）\n\n**测试集 1（10 分，可见判定）**\n- 时间限制：20 秒\n- $1 \\leq N \\leq 300$\n- $2 \\leq D \\leq 3$\n\n**测试集 2（16 分，可见判定）**\n- 时间限制：20 秒\n- $1 \\leq N \\leq 300$\n- $2 \\leq D \\leq 50$\n\n**测试集 3（16 分，隐藏判定）**\n- 时间限制：60 秒\n- 其中 21 个用例满足 $9000 \\leq N \\leq 10000$\n- 其余 $T-21$ 个用例满足 $1 \\leq N \\leq 1000$\n- $2 \\leq D \\leq 50$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13062", "type": "P", "difficulty": 4, "samples": [["3\n1 2\n2 2\n8 11", "Case #1: 1 1 1\nCase #2: 2 1 0\nCase #3: 5 0 4"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2020", "二分", "Google Code Jam"], "title": "[GCJ 2020 #2] Incremental House of Pancakes", "background": "", "description": "Every morning at The Incremental House of Pancakes, the kitchen staff prepares all of its pancakes for the day and arranges them into two stacks. Initially, the stack on the left has $L$ pancakes, and the stack on the right has $R$ pancakes.\n\nThis restaurant's customers behave very consistently: the i-th customer to arrive (counting starting from 1) always orders $i$ pancakes. When the i-th customer places their order of $i$ pancakes, you take $i$ pancakes from the stack that has the most pancakes remaining (or from the left stack if both have the same amount). If neither stack has at least $i$ pancakes, the restaurant closes and the $i$-th customer does not get served any pancakes. You never complete an order using pancakes from both stacks.\n\nGiven the initial numbers of pancakes in each stack, you want to know how many customers will be served, and how many pancakes will remain in each stack when the restaurant closes.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of a single line containing two integers $L$ and $R$: the initial numbers of pancakes in the left and right stacks, respectively, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: n l r`, where $x$ is the test case number (starting from 1), $n$ is the number of customers who will be served, and $l$ and $r$ are the numbers of pancakes that will remain in the left and right stacks, respectively, when the restaurant closes.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the first customer gets 1 pancake from the right stack, leaving 1 pancake in each stack. The second customer wants 2 pancakes, but neither stack has enough for them, even though there are 2 pancakes in total.\n\nIn Sample Case #2, the first customer gets 1 pancake from the left stack, because both stacks have the same amount. This leaves 1 pancake in the left stack and 2 in the right stack. The second customer wants 2 pancakes, which you serve to them from the right stack, emptying it. When the third customer arrives, neither stack has 3 pancakes, so no more orders are fulfilled.\n\nIn Sample Case #3, the first customer is served from the right stack, leaving 8 pancakes in the left stack and 10 in the right stack. The second customer is also served from the right stack, leaving 8 pancakes in each stack. The third customer is served from the left stack, leaving 5 pancakes there and 8 in the right stack. The fourth customer is then served from the right stack, leaving 4 pancakes there. Serving the fifth customer empties the left stack, and then there are not enough pancakes remaining in either stack to serve a sixth customer.\n\n**Limits**\n\n- $1 \\leq T \\leq 1000$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq L \\leq 1000$.\n- $1 \\leq R \\leq 1000$.\n\n**Test Set 2 (14 Pts, Hidden Verdict)**\n\n- $1 \\leq L \\leq 10^{18}$.\n- $1 \\leq R \\leq 10^{18}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #2] Incremental House of Pancakes", "background": "", "description": "Every morning at The Incremental House of Pancakes, the kitchen staff prepares all of its pancakes for the day and arranges them into two stacks. Initially, the stack on the left has $L$ pancakes, and the stack on the right has $R$ pancakes.\n\nThis restaurant's customers behave very consistently: the i-th customer to arrive (counting starting from 1) always orders $i$ pancakes. When the i-th customer places their order of $i$ pancakes, you take $i$ pancakes from the stack that has the most pancakes remaining (or from the left stack if both have the same amount). If neither stack has at least $i$ pancakes, the restaurant closes and the $i$-th customer does not get served any pancakes. You never complete an order using pancakes from both stacks.\n\nGiven the initial numbers of pancakes in each stack, you want to know how many customers will be served, and how many pancakes will remain in each stack when the restaurant closes.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of a single line containing two integers $L$ and $R$: the initial numbers of pancakes in the left and right stacks, respectively, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: n l r`, where $x$ is the test case number (starting from 1), $n$ is the number of customers who will be served, and $l$ and $r$ are the numbers of pancakes that will remain in the left and right stacks, respectively, when the restaurant closes.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the first customer gets 1 pancake from the right stack, leaving 1 pancake in each stack. The second customer wants 2 pancakes, but neither stack has enough for them, even though there are 2 pancakes in total.\n\nIn Sample Case #2, the first customer gets 1 pancake from the left stack, because both stacks have the same amount. This leaves 1 pancake in the left stack and 2 in the right stack. The second customer wants 2 pancakes, which you serve to them from the right stack, emptying it. When the third customer arrives, neither stack has 3 pancakes, so no more orders are fulfilled.\n\nIn Sample Case #3, the first customer is served from the right stack, leaving 8 pancakes in the left stack and 10 in the right stack. The second customer is also served from the right stack, leaving 8 pancakes in each stack. The third customer is served from the left stack, leaving 5 pancakes there and 8 in the right stack. The fourth customer is then served from the right stack, leaving 4 pancakes there. Serving the fifth customer empties the left stack, and then there are not enough pancakes remaining in either stack to serve a sixth customer.\n\n**Limits**\n\n- $1 \\leq T \\leq 1000$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq L \\leq 1000$.\n- $1 \\leq R \\leq 1000$.\n\n**Test Set 2 (14 Pts, Hidden Verdict)**\n\n- $1 \\leq L \\leq 10^{18}$.\n- $1 \\leq R \\leq 10^{18}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #2] Incremental House of Pancakes", "background": "", "description": "每天早晨，增量煎饼屋的厨房员工会准备好当天所有的煎饼，并将它们分成两堆。初始时，左边的煎饼堆有 $L$ 个煎饼，右边的煎饼堆有 $R$ 个煎饼。\n\n这家餐厅的顾客行为非常一致：第 $i$ 个到达的顾客（从 $1$ 开始计数）总是会点 $i$ 个煎饼。当第 $i$ 个顾客下单 $i$ 个煎饼时，你会从当前煎饼数量较多的那一堆中取出 $i$ 个煎饼（如果两堆煎饼数量相同，则从左边的那一堆中取）。如果两堆煎饼的数量都不足 $i$ 个，餐厅将关闭，且第 $i$ 个顾客不会得到任何煎饼。你**不会**从两堆煎饼中各取一部分来完成一个订单。\n\n给定两堆煎饼的初始数量，你需要计算有多少顾客会被服务，以及餐厅关闭时两堆煎饼的剩余数量。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来是 $T$ 个测试用例。每个测试用例占一行，包含两个整数 $L$ 和 $R$，分别表示左边和右边煎饼堆的初始数量，如上所述。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: n l r`，其中 $x$ 是测试用例编号（从 $1$ 开始），$n$ 是被服务的顾客数量，$l$ 和 $r$ 分别是餐厅关闭时左边和右边煎饼堆的剩余数量。\n", "hint": "**样例解释**\n\n在样例 #1 中，第一个顾客从右边的煎饼堆中取走 $1$ 个煎饼，剩下每堆各有 $1$ 个煎饼。第二个顾客想要 $2$ 个煎饼，但两堆煎饼都不够，尽管总共有 $2$ 个煎饼。\n\n在样例 #2 中，第一个顾客从左边的煎饼堆中取走 $1$ 个煎饼，因为两堆煎饼数量相同。这样左边剩下 $1$ 个煎饼，右边剩下 $2$ 个煎饼。第二个顾客想要 $2$ 个煎饼，你从右边的煎饼堆中取给他，清空了右边的堆。当第三个顾客到来时，两堆煎饼都不足 $3$ 个，因此不再完成订单。\n\n在样例 #3 中，第一个顾客从右边的煎饼堆中取走 $1$ 个煎饼，左边剩下 $8$ 个煎饼，右边剩下 $10$ 个煎饼。第二个顾客也从右边的煎饼堆中取走 $2$ 个煎饼，此时两堆各有 $8$ 个煎饼。第三个顾客从左边的煎饼堆中取走 $3$ 个煎饼，左边剩下 $5$ 个煎饼，右边剩下 $8$ 个煎饼。第四个顾客从右边的煎饼堆中取走 $4$ 个煎饼，右边剩下 $4$ 个煎饼。第五个顾客取走 $5$ 个煎饼后清空了左边的堆，此时两堆煎饼都不足以满足第六个顾客的需求。\n\n**数据范围**\n\n- $1 \\leq T \\leq 1000$。\n\n**测试集 1（5 分，可见评测结果）**\n\n- $1 \\leq L \\leq 1000$。\n- $1 \\leq R \\leq 1000$。\n\n**测试集 2（14 分，隐藏评测结果）**\n\n- $1 \\leq L \\leq 10^{18}$。\n- $1 \\leq R \\leq 10^{18}$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13063", "type": "P", "difficulty": 4, "samples": [["3\n4 4\n-1 -3 -2\n1 2\n1 3\n2 4\n3 4\n4 4\n-1 -1 -1\n1 4\n1 2\n1 3\n2 3\n3 2\n-2 -1\n2 3\n1 3", "Case #1: 5 10 1 5\nCase #2: 2020 2020 2020 2020\nCase #3: 1000000 1000000"], ["1\n6 9\n10 -2 -5 15 20\n1 2\n1 3\n2 3\n2 4\n2 5\n3 5\n3 6\n4 5\n5 6", "Case #1: 10 12 4 15 8 3 9 7 5"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2020", "Special Judge", "Google Code Jam"], "title": "[GCJ 2020 #2] Security Update", "background": "", "description": "The Apricot Rules company just installed a critical security update on its network. The network has one source computer, and all other computers in the network are connected to the source computer via a sequence of one or more direct bidirectional connections.\n\nThis kind of update propagates itself: once a computer receives the update for the first time, that computer immediately begins to transmit the update to all of the computers that are directly connected to it. Each of the direct connections has a latency value: the number of seconds needed for that connection to transmit the update (which is the same in either direction). Therefore, the update does not spread to all computers instantly.\n\nThe Apricot Rules engineers do not know any of these latency values, but they know that they are all positive integers. They would like your help in figuring out what these latency values could be, based on how they saw the update spread in a recent experiment.\n\nThe Apricot Rules engineers installed the update only on the source computer and then waited for it to propagate throughout the system until every computer was updated. They recorded some information about how the update spread. Specifically, for every computer $K$ other than the source computer, you know exactly one of two things.\n\n- The exact time in seconds between the time when the source computer received the update and the time when $K$ first received the update.\n- The number of other computers (including the source computer) that first got the update strictly before $K$.\n\nNotice that multiple computers may have received the update at the exact same time.\n\nYou are required to compute a latency in seconds for each of the direct connections between two computers. Each latency value must be a positive integer no greater than $10^6$. The set of latencies that you provide must be consistent with all of the known information. It is guaranteed that there is at least one consistent way to assign latencies.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line containing two integers $C$ and $D$: the number of computers and the number of direct connections, respectively. The computers are numbered from 1 to $C$, with computer 1 being the source computer.\n\nThe next line contains $C-1$ integers $X_2$, $X_3$, $\\dots$, $X_C$. A positive $X_i$ value indicates that computer $i$ received the update $X_i$ seconds after computer 1. A negative $X_i$ value indicates that $-X_i$ other computers received the update strictly before computer $i$; this value includes the source computer.\n\nAfter that, there are $D$ more lines that represent the $D$ direct connections in the network. The $i$-th of these lines contains two integers $U_i$ and $V_i$, indicating that computers $U_i$ and $V_i$ are directly connected to each other.\n", "outputFormat": "For each test case, output one line containing `Case #x: y_1 y_2 ... y_D`, where $x$ is the test case number (starting from 1) and $y_i$ is a positive integer not more than $10^6$ representing the latency, in seconds, assigned to the $i$-th direct connection.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the following picture represents the computer network that is illustrated by the sample output. The $i$-th computer is represented by the circle with the label $i$. A line linking two circles represents a direct connection. The number on each line represents the latency of the direct connection.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uvr9sjli.png)\n\nIn Sample Case #2, the first three connections need to have the same latency, while the fourth can have any valid latency. Note that $-2, 0, 1000001$, and $3.14$ are examples of invalid latencies.\n\nIn Sample Case #3, remember that the connections are bidirectional, and so the update can travel from computer $3$ to computer $2$. Any two valid latency values work here.\n\nSample Test Set 2 could not appear in Test Set 1, but could appear in Test Set 2.\n\nOne of the correct outputs is $10\\ 12\\ 4\\ 15\\ 8\\ 3\\ 9\\ 7\\ 5$, as illustrated by the picture below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x60u5h9g.png)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq C \\leq 100$.\n- $C - 1 \\leq D \\leq 1000$.\n- $1 \\leq U_i < V_i \\leq C$, for all $i$.\n- $(U_i, V_i) \\neq (U_j, V_j)$, for all $i \\neq j$.\n- All computers (except the source computer) are connected to the source computer through a sequence of one or more direct connections.\n- There exists at least one way of assigning latency values that is consistent with the input.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $-C < X_i < 0$, for all $i$. (You get the second type of information for all computers.)\n\n**Test Set 2 (11 Pts, Hidden Verdict)**\n\n- $-C < X_i \\leq 1000$, for all $i$.\n- $X_i \\neq 0$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #2] Security Update", "background": "", "description": "The Apricot Rules company just installed a critical security update on its network. The network has one source computer, and all other computers in the network are connected to the source computer via a sequence of one or more direct bidirectional connections.\n\nThis kind of update propagates itself: once a computer receives the update for the first time, that computer immediately begins to transmit the update to all of the computers that are directly connected to it. Each of the direct connections has a latency value: the number of seconds needed for that connection to transmit the update (which is the same in either direction). Therefore, the update does not spread to all computers instantly.\n\nThe Apricot Rules engineers do not know any of these latency values, but they know that they are all positive integers. They would like your help in figuring out what these latency values could be, based on how they saw the update spread in a recent experiment.\n\nThe Apricot Rules engineers installed the update only on the source computer and then waited for it to propagate throughout the system until every computer was updated. They recorded some information about how the update spread. Specifically, for every computer $K$ other than the source computer, you know exactly one of two things.\n\n- The exact time in seconds between the time when the source computer received the update and the time when $K$ first received the update.\n- The number of other computers (including the source computer) that first got the update strictly before $K$.\n\nNotice that multiple computers may have received the update at the exact same time.\n\nYou are required to compute a latency in seconds for each of the direct connections between two computers. Each latency value must be a positive integer no greater than $10^6$. The set of latencies that you provide must be consistent with all of the known information. It is guaranteed that there is at least one consistent way to assign latencies.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line containing two integers $C$ and $D$: the number of computers and the number of direct connections, respectively. The computers are numbered from 1 to $C$, with computer 1 being the source computer.\n\nThe next line contains $C-1$ integers $X_2$, $X_3$, $\\dots$, $X_C$. A positive $X_i$ value indicates that computer $i$ received the update $X_i$ seconds after computer 1. A negative $X_i$ value indicates that $-X_i$ other computers received the update strictly before computer $i$; this value includes the source computer.\n\nAfter that, there are $D$ more lines that represent the $D$ direct connections in the network. The $i$-th of these lines contains two integers $U_i$ and $V_i$, indicating that computers $U_i$ and $V_i$ are directly connected to each other.\n", "outputFormat": "For each test case, output one line containing `Case #x: y_1 y_2 ... y_D`, where $x$ is the test case number (starting from 1) and $y_i$ is a positive integer not more than $10^6$ representing the latency, in seconds, assigned to the $i$-th direct connection.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the following picture represents the computer network that is illustrated by the sample output. The $i$-th computer is represented by the circle with the label $i$. A line linking two circles represents a direct connection. The number on each line represents the latency of the direct connection.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uvr9sjli.png)\n\nIn Sample Case #2, the first three connections need to have the same latency, while the fourth can have any valid latency. Note that $-2, 0, 1000001$, and $3.14$ are examples of invalid latencies.\n\nIn Sample Case #3, remember that the connections are bidirectional, and so the update can travel from computer $3$ to computer $2$. Any two valid latency values work here.\n\nSample Test Set 2 could not appear in Test Set 1, but could appear in Test Set 2.\n\nOne of the correct outputs is $10\\ 12\\ 4\\ 15\\ 8\\ 3\\ 9\\ 7\\ 5$, as illustrated by the picture below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x60u5h9g.png)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq C \\leq 100$.\n- $C - 1 \\leq D \\leq 1000$.\n- $1 \\leq U_i < V_i \\leq C$, for all $i$.\n- $(U_i, V_i) \\neq (U_j, V_j)$, for all $i \\neq j$.\n- All computers (except the source computer) are connected to the source computer through a sequence of one or more direct connections.\n- There exists at least one way of assigning latency values that is consistent with the input.\n\n**Test Set 1 (9 Pts, Visible Verdict)**\n\n- $-C < X_i < 0$, for all $i$. (You get the second type of information for all computers.)\n\n**Test Set 2 (11 Pts, Hidden Verdict)**\n\n- $-C < X_i \\leq 1000$, for all $i$.\n- $X_i \\neq 0$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #2] Security Update", "background": "", "description": "**Apricot Rules** 公司刚刚在其网络上安装了一个关键的安全更新。该网络有一台源计算机，其他所有计算机都通过一条或多条直接双向连接与源计算机相连。\n\n这种更新会自行传播：一旦某台计算机首次接收到更新，它会立即开始向所有直接连接的计算机传输更新。每条直接连接都有一个延迟值：表示该连接传输更新所需的秒数（双向传输的延迟相同）。因此，更新不会瞬间传播到所有计算机。\n\n**Apricot Rules** 的工程师不知道这些延迟的具体值，但他们知道这些值都是正整数。他们希望你能根据最近一次实验中观察到的更新传播情况，推断出这些延迟的可能取值。\n\n工程师仅在源计算机上安装了更新，然后等待更新传播到整个系统，直到所有计算机都完成更新。他们记录了更新传播的一些信息。具体来说，对于除源计算机外的每台计算机 $K$，你确切知道以下两种情况之一：\n\n- 源计算机接收到更新的时间与 $K$ 首次接收到更新的时间之间的精确秒数。\n- 在 $K$ 首次接收到更新之前，严格比 $K$ 更早接收到更新的其他计算机（包括源计算机）的数量。\n\n注意，多台计算机可能在同一时间接收到更新。\n\n你需要为每对直接连接的计算机计算一个延迟值（单位为秒）。每个延迟值必须是一个不超过 $10^6$ 的正整数。你提供的延迟值集合必须与所有已知信息一致。题目保证至少存在一种一致的延迟分配方式。\n", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来是 $T$ 个测试用例。每个测试用例的第一行包含两个整数 $C$ 和 $D$，分别表示计算机的数量和直接连接的数量。计算机编号为 $1$ 到 $C$，其中计算机 $1$ 是源计算机。\n\n第二行包含 $C-1$ 个整数 $X_2$, $X_3$, $\\dots$, $X_C$。如果 $X_i$ 为正，表示计算机 $i$ 在计算机 $1$ 接收到更新后的 $X_i$ 秒接收到更新；如果 $X_i$ 为负，表示 $-X_i$ 台其他计算机（包括源计算机）在计算机 $i$ 之前严格更早接收到更新。\n\n接下来的 $D$ 行表示网络中的 $D$ 条直接连接。第 $i$ 行包含两个整数 $U_i$ 和 $V_i$，表示计算机 $U_i$ 和 $V_i$ 直接相连。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y_1 y_2 ... y_D`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y_i$ 是一个不超过 $10^6$ 的正整数，表示分配给第 $i$ 条直接连接的延迟值（单位为秒）。\n", "hint": "**样例解释**\n\n在样例 #1 中，下图展示了样例输出对应的计算机网络。标有 $i$ 的圆圈表示第 $i$ 台计算机，连接两个圆圈的线表示直接连接，线上的数字表示该连接的延迟值。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uvr9sjli.png)\n\n在样例 #2 中，前三条连接的延迟必须相同，而第四条连接的延迟可以是任意有效值。注意，$-2$、$0$、$1000001$ 和 $3.14$ 都是无效的延迟值。\n\n在样例 #3 中，由于连接是双向的，更新可以从计算机 $3$ 传输到计算机 $2$。任意两个有效的延迟值均可满足条件。\n\n样例测试集 #2 不会出现在测试集 #1 中，但可能出现在测试集 #2 中。\n\n其中一个正确的输出是 $10\\ 12\\ 4\\ 15\\ 8\\ 3\\ 9\\ 7\\ 5$，如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/x60u5h9g.png)\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq C \\leq 100$。\n- $C - 1 \\leq D \\leq 1000$。\n- 对于所有 $i$，$1 \\leq U_i < V_i \\leq C$。\n- 对于所有 $i \\neq j$，$(U_i, V_i) \\neq (U_j, V_j)$。\n- 所有计算机（除源计算机外）都通过一条或多条直接连接与源计算机相连。\n- 至少存在一种与输入一致的延迟分配方式。\n\n**测试集 1（9 分，可见评测结果）**\n\n- 对于所有 $i$，$-C < X_i < 0$（即所有计算机的信息均为第二种类型）。\n\n**测试集 2（11 分，隐藏评测结果）**\n\n- 对于所有 $i$，$-C < X_i \\leq 1000$。\n- 对于所有 $i$，$X_i \\neq 0$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13064", "type": "P", "difficulty": 5, "samples": [["5\n2\n0 0\n5 5\n3\n0 0\n5 5\n5 0\n5\n0 0\n5 5\n5 0\n3 2\n2 4\n7\n0 0\n1 1\n2 1\n3 1\n8 2\n11 2\n14 2\n1\n-1000000000 1000000000", "Case #1: 2\nCase #2: 3\nCase #3: 4\nCase #4: 7\nCase #5: 1"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "2020", "组合数学", "Google Code Jam"], "title": "[GCJ 2020 #2] Wormhole in One", "background": "", "description": "You are participating in an inter-galactic hyperspace golf competition, and you have advanced to the final round! You are really determined to triumph, and so you want to prepare a winning strategy.\n\nIn hyperspace golf, just as in conventional golf, you hit a ball with a club, which sends the ball in a direction chosen by you. The playing field in hyperspace golf is a 2-dimensional plane with points representing the different holes. The ball is also represented by a point, and you get to choose where the ball starts, as long as it is not in the same place as a hole.\n\nSince this is hyperspace golf, the players are allowed to turn some pairs of holes into wormholes by linking them together. Each hole can be either left as a normal hole, or linked to at most one other hole (never to itself). Wormholes are undirected links, and can be traversed in either direction.\n\nBecause the environment is frictionless, when you hit the ball, it moves in a straight direction that it maintains forever unless it reaches a hole; call that hole $h$. Upon touching hole $h$, the ball stops if $h$ is not connected to another hole. If $h$ is connected to another hole $h'$, then the ball immediately comes out of $h'$ and continues moving in the same direction as before.\n\nYou know the location of each hole. You want to maximize the number of distinct holes you can touch with a single hit. With that goal in mind, you want to pick the ball's starting location, the direction in which to send the ball, and which pairs of holes, if any, to link together as wormholes. The ball cannot start in the same place as a wormhole. When the ball goes through a wormhole, both the hole it goes into and the hole it comes out of are counted towards your total. Each hole is only counted once, even if the ball goes into it or comes out of it (or both) multiple times. If the ball stops in a hole, that hole also counts toward your total.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line containing a single integer $N$: the total number of holes. The following $N$ lines contain two integers each: $X_i$ and $Y_i$, representing the $X$ and $Y$ coordinates, respectively, of the $i$-th hole.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of distinct holes you can touch if you make optimal decisions as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we can connect the two holes with a wormhole so that we could touch both of them by sending the ball into either one. Notice that without the wormhole, the ball would just stay in the first hole it touches, so it would be impossible to touch more than one hole.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/ts9ilei7)\n\nIn Sample Case #2, we can connect the holes at $(0, 0)$ and at $(5, 5)$. We can then hit the ball from position $(4.9, 5)$, for example, in the positive horizontal direction so that it first touches the hole at $(5, 5)$. It goes into that hole and comes out of the hole at $(0, 0)$, retaining its positive horizontal direction of movement. Finally, it touches the hole at $(5, 0)$, and stops (since there is no wormhole linked to that hole).\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/28bszlac)\n\nIn Sample Case #3, we can connect the pair of holes at positions $(0, 0)$ and $(5, 0)$, and also the pair of holes at positions $(3, 2)$ and $(5, 5)$. Hitting the ball from $(4, -1)$ towards the hole at $(5, 0)$ makes it touch the holes at positions $(5, 0), (0, 0), (5, 5)$ and $(3, 2)$, in that order.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/1peglhnt)\n\nIn Sample Case #4, we can connect the pairs of holes at positions $(0, 0)$ and $(1, 1)$, the pair of holes at positions $(2, 1)$ and $(11, 2)$, and also the pair of holes at positions $(8, 2)$ and $(14, 2)$. Hitting the ball from $(-1, 0)$ towards the hole at $(0, 0)$ makes it touch the holes at the following positions, in this order: $(0, 0), (1, 1), (2, 1), (11, 2), (14, 2), (8, 2), (11, 2), (2, 1)$, and $(3, 1)$. Note that although the holes at positions $(11, 2)$ and $(2, 1)$ are touched twice, they are only counted once each for the answer, since the problem asks for a count of distinct holes.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/qrzd1ajh)\n\nIn Sample Case #5, there is only one hole, and we can hit the ball into it without needing to consider wormholes at all. (For what it's worth, we can choose any starting location we want, even outside of the allowable range of coordinates for holes.)\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/1sb96cjz)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $-10^9 \\leq X_i \\leq 10^9$, for all $i$.\n- $-10^9 \\leq Y_i \\leq 10^9$, for all $i$.\n- $(X_i, Y_i) \\neq (X_j, Y_j)$, for all $i \\neq j$. (No two holes are at the same coordinates.)\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq N \\leq 7$.\n\n**Test Set 2 (16 Pts, Hidden Verdict)**\n\n- $1 \\leq N \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #2] Wormhole in One", "background": "", "description": "You are participating in an inter-galactic hyperspace golf competition, and you have advanced to the final round! You are really determined to triumph, and so you want to prepare a winning strategy.\n\nIn hyperspace golf, just as in conventional golf, you hit a ball with a club, which sends the ball in a direction chosen by you. The playing field in hyperspace golf is a 2-dimensional plane with points representing the different holes. The ball is also represented by a point, and you get to choose where the ball starts, as long as it is not in the same place as a hole.\n\nSince this is hyperspace golf, the players are allowed to turn some pairs of holes into wormholes by linking them together. Each hole can be either left as a normal hole, or linked to at most one other hole (never to itself). Wormholes are undirected links, and can be traversed in either direction.\n\nBecause the environment is frictionless, when you hit the ball, it moves in a straight direction that it maintains forever unless it reaches a hole; call that hole $h$. Upon touching hole $h$, the ball stops if $h$ is not connected to another hole. If $h$ is connected to another hole $h'$, then the ball immediately comes out of $h'$ and continues moving in the same direction as before.\n\nYou know the location of each hole. You want to maximize the number of distinct holes you can touch with a single hit. With that goal in mind, you want to pick the ball's starting location, the direction in which to send the ball, and which pairs of holes, if any, to link together as wormholes. The ball cannot start in the same place as a wormhole. When the ball goes through a wormhole, both the hole it goes into and the hole it comes out of are counted towards your total. Each hole is only counted once, even if the ball goes into it or comes out of it (or both) multiple times. If the ball stops in a hole, that hole also counts toward your total.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line containing a single integer $N$: the total number of holes. The following $N$ lines contain two integers each: $X_i$ and $Y_i$, representing the $X$ and $Y$ coordinates, respectively, of the $i$-th hole.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of distinct holes you can touch if you make optimal decisions as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we can connect the two holes with a wormhole so that we could touch both of them by sending the ball into either one. Notice that without the wormhole, the ball would just stay in the first hole it touches, so it would be impossible to touch more than one hole.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/ts9ilei7)\n\nIn Sample Case #2, we can connect the holes at $(0, 0)$ and at $(5, 5)$. We can then hit the ball from position $(4.9, 5)$, for example, in the positive horizontal direction so that it first touches the hole at $(5, 5)$. It goes into that hole and comes out of the hole at $(0, 0)$, retaining its positive horizontal direction of movement. Finally, it touches the hole at $(5, 0)$, and stops (since there is no wormhole linked to that hole).\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/28bszlac)\n\nIn Sample Case #3, we can connect the pair of holes at positions $(0, 0)$ and $(5, 0)$, and also the pair of holes at positions $(3, 2)$ and $(5, 5)$. Hitting the ball from $(4, -1)$ towards the hole at $(5, 0)$ makes it touch the holes at positions $(5, 0), (0, 0), (5, 5)$ and $(3, 2)$, in that order.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/1peglhnt)\n\nIn Sample Case #4, we can connect the pairs of holes at positions $(0, 0)$ and $(1, 1)$, the pair of holes at positions $(2, 1)$ and $(11, 2)$, and also the pair of holes at positions $(8, 2)$ and $(14, 2)$. Hitting the ball from $(-1, 0)$ towards the hole at $(0, 0)$ makes it touch the holes at the following positions, in this order: $(0, 0), (1, 1), (2, 1), (11, 2), (14, 2), (8, 2), (11, 2), (2, 1)$, and $(3, 1)$. Note that although the holes at positions $(11, 2)$ and $(2, 1)$ are touched twice, they are only counted once each for the answer, since the problem asks for a count of distinct holes.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/qrzd1ajh)\n\nIn Sample Case #5, there is only one hole, and we can hit the ball into it without needing to consider wormholes at all. (For what it's worth, we can choose any starting location we want, even outside of the allowable range of coordinates for holes.)\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/1sb96cjz)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $-10^9 \\leq X_i \\leq 10^9$, for all $i$.\n- $-10^9 \\leq Y_i \\leq 10^9$, for all $i$.\n- $(X_i, Y_i) \\neq (X_j, Y_j)$, for all $i \\neq j$. (No two holes are at the same coordinates.)\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq N \\leq 7$.\n\n**Test Set 2 (16 Pts, Hidden Verdict)**\n\n- $1 \\leq N \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #2] Wormhole in One", "background": "", "description": "你正在参加一场星际超空间高尔夫比赛，并成功晋级决赛！为了确保胜利，你决定制定一个完美的策略。\n\n在超空间高尔夫中，和传统高尔夫一样，你需要用球杆击球，使球朝你选择的方向飞行。比赛场地是一个二维平面，平面上的点代表不同的球洞。球本身也用一个点表示，你可以自由选择球的起始位置，只要不和任何球洞重合即可。\n\n由于这是超空间高尔夫，选手可以将某些球洞对连接起来形成虫洞。每个球洞可以选择保持普通状态，或者最多与另一个球洞相连（不能自连）。虫洞是无向连接，可以双向穿越。\n\n由于环境无摩擦，当你击球后，球会沿直线永远飞行，除非碰到球洞 $h$。当球碰到球洞 $h$ 时：\n- 如果 $h$ 没有连接其他球洞，球会停止；\n- 如果 $h$ 连接了另一个球洞 $h'$，球会立即从 $h'$ 飞出，并保持原来的飞行方向继续移动。\n\n你已知所有球洞的位置。你的目标是通过一次击球，最大化触碰到的不同球洞数量。为此，你需要选择：\n1. 球的起始位置\n2. 球的飞行方向\n3. 要连接成虫洞的球洞对（可选）\n\n注意：\n- 球不能从虫洞位置开始\n- 当球穿过虫洞时，进入和穿出的两个球洞都计入总数\n- 每个球洞只计一次，即使多次进入或穿出\n- 如果球停在某个球洞，该球洞也会被计入", "inputFormat": "输入第一行是测试用例数量 $T$。每个测试用例包含：\n- 第一行：整数 $N$ 表示球洞数量\n- 接下来 $N$ 行：每行两个整数 $X_i$ 和 $Y_i$，表示第 $i$ 个球洞的坐标", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中：\n- $x$ 是测试用例编号（从 1 开始）\n- $y$ 是在最优策略下能触碰到的最大不同球洞数量", "hint": "**样例解释**\n\n样例 #1：连接两个球洞形成虫洞，可以让球穿过两个球洞。如果不连接虫洞，球碰到第一个球洞就会停止，无法触碰多个球洞。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/ts9ilei7)\n\n样例 #2：连接 $(0, 0)$ 和 $(5, 5)$ 的球洞。从 $(4.9, 5)$ 水平向右击球，依次经过 $(5, 5)$ → $(0, 0)$ → $(5, 0)$ 后停止。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/28bszlac)\n\n样例 #3：连接 $(0, 0)-(5, 0)$ 和 $(3, 2)-(5, 5)$ 两对球洞。从 $(4, -1)$ 向 $(5, 0)$ 击球，依次经过 $(5, 0)$ → $(0, 0)$ → $(5, 5)$ → $(3, 2)$。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/1peglhnt)\n\n样例 #4：连接 $(0, 0)-(1, 1)$、$(2, 1)-(11, 2)$ 和 $(8, 2)-(14, 2)$ 三对球洞。从 $(-1, 0)$ 向 $(0, 0)$ 击球，可以经过所有 7 个球洞（某些球洞会被多次经过但只计一次）。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/qrzd1ajh)\n\n样例 #5：只有一个球洞时，直接击球入洞即可。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/1sb96cjz)\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$\n- 球洞坐标范围：$-10^9 \\leq X_i, Y_i \\leq 10^9$\n- 所有球洞坐标互不相同\n\n**测试集 1（10 分，可见评测结果）**\n\n- $1 \\leq N \\leq 7$\n\n**测试集 2（16 分，隐藏评测结果）**\n\n- $1 \\leq N \\leq 100$\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13065", "type": "P", "difficulty": 7, "samples": [["1\n12 5\n(()(((()))))\n1 1 1 1 1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1 1 1 1 1\n7 4 4 12 5\n12 11 10 1 6", "Case #1: 10"]], "limits": {"time": [60000, 60000, 60000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2020", "倍增", "最短路", "最近公共祖先 LCA", "Google Code Jam"], "title": "[GCJ 2020 #2] Emacs++", "background": "", "description": "In 2016's Distributed Code Jam, we introduced the Lisp++ language for Lisp fans who prefer a higher density of parentheses. Here is a reminder of how the language's syntax works:\n\nA Lisp++ program is a string of balanced parentheses. More formally, a Lisp++ program consists of one of the following. (In this specification, C stands for some program code — not necessarily the same code each time.)\n\n- `()` Literally, just an opening parenthesis and a closing parenthesis. We say that this `(` matches this `)`, and vice versa.\n- `(C)` A program within a pair of enclosing parentheses. We say that this `(` matches this `)`, and vice versa.\n- `CC` Two programs (not necessarily the same), back to back.\n\nThis year, we are pleased to announce Emacs++, a text viewer for Lisp++. Emacs++ displays a Lisp++ program of length K as a single long line with a cursor that you can move around. The cursor is a \"block cursor\" that is always located on one of the K characters in the program, rather than between characters.\n\nAt any point, you can perform one of the following three actions to move the cursor. (i represents the current position of the cursor, counting starting from 1 for the leftmost position.)\n\n- Move the cursor one character to the left (or, if the cursor is already on the leftmost character, does nothing). This takes $L_i$ seconds.\n- Move the cursor one character to the right (or, if the cursor is already on the rightmost character, does nothing). This takes $R_i$ seconds.\n- Teleport the cursor to the parenthesis matching (as described above) the parenthesis that is the i-th character. This takes $P_i$ seconds.\n\nWe think Emacs++ will be simple for power users, but we still need to understand how efficient it is. We have a single Lisp++ program and list of Q queries about that program; each query consists of a start position $S_j$ and an end position $E_j$. To answer the j-th query, you must determine the smallest possible amount of time $N_j$ (in seconds) that it will take to take the cursor from position $S_j$ to position $E_j$, if you make optimal decisions.\n\nPlease output the sum of all of those $N_j$ values.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. The first line of a test case contains two integers $K$, which is the length of the Lisp++ program, and $Q$, which is the number of queries.\n\nThe second line of a test case contains a string $P$ of $K$ characters, each of which is either ( or ), representing a Lisp++ program (string of balanced parentheses), as described above.\n\nThe third, fourth, and fifth lines of a test case each contain $K$ integers. The $i$-th integers in these lines are the values $L_i$, $R_i$, and $P_i$, respectively, that are described above.\n\nThe sixth and seventh lines of a test case each contain $Q$ integers. The $j$-th integers in these lines are $S_j$ and $E_j$, respectively, that are described above.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the sum of the $N_j$ values that are described above.", "hint": "**Sample Explanation**\n\nIn the sample case, which obeys the limits for Test Set 1, all of the time costs are the same ($1$ second per move). The shortest times for the queries are as follows:\n\n1. Move right from $7$ five times to $12$ taking $5$ seconds.\n2. Teleport from $4$ to $11$ taking $1$ second.\n3. Teleport from $4$ to $11$, then move left to $10$ taking $2$ seconds.\n4. Teleport from $12$ to $1$, taking $1$ second.\n5. Move right from $5$ to $6$ taking $1$ second.\n\nThus, the sum of query times is $5+1+2+1+1 = 10$ seconds.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $K = 10^5$ and $Q = 10^5$, for at most 9 test cases.\n- $2 \\leq K \\leq 1000$ and $1 \\leq Q \\leq 1000$, in all other cases.\n- length of $P = K$ $P$ is a string of balanced parentheses, as described above.\n- $1 \\leq S_j \\leq K$, for all $j$.\n- $1 \\leq E_j \\leq K$, for all $j$.\n\n**Test Set 1 (12 Pts, Visible Verdict)**\n\n- $L_i = 1$, for all $i$.\n- $R_i = 1$, for all $i$.\n- $P_i = 1$, for all $i$.\n\n**Test Set 2 (23 Pts, Hidden Verdict)**\n\n- $1 \\leq L_i \\leq 10^6$, for all $i$.\n- $1 \\leq R_i \\leq 10^6$, for all $i$.\n- $1 \\leq P_i \\leq 10^6$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #2] Emacs++", "background": "", "description": "In 2016's Distributed Code Jam, we introduced the Lisp++ language for Lisp fans who prefer a higher density of parentheses. Here is a reminder of how the language's syntax works:\n\nA Lisp++ program is a string of balanced parentheses. More formally, a Lisp++ program consists of one of the following. (In this specification, C stands for some program code — not necessarily the same code each time.)\n\n- `()` Literally, just an opening parenthesis and a closing parenthesis. We say that this `(` matches this `)`, and vice versa.\n- `(C)` A program within a pair of enclosing parentheses. We say that this `(` matches this `)`, and vice versa.\n- `CC` Two programs (not necessarily the same), back to back.\n\nThis year, we are pleased to announce Emacs++, a text viewer for Lisp++. Emacs++ displays a Lisp++ program of length K as a single long line with a cursor that you can move around. The cursor is a \"block cursor\" that is always located on one of the K characters in the program, rather than between characters.\n\nAt any point, you can perform one of the following three actions to move the cursor. (i represents the current position of the cursor, counting starting from 1 for the leftmost position.)\n\n- Move the cursor one character to the left (or, if the cursor is already on the leftmost character, does nothing). This takes $L_i$ seconds.\n- Move the cursor one character to the right (or, if the cursor is already on the rightmost character, does nothing). This takes $R_i$ seconds.\n- Teleport the cursor to the parenthesis matching (as described above) the parenthesis that is the i-th character. This takes $P_i$ seconds.\n\nWe think Emacs++ will be simple for power users, but we still need to understand how efficient it is. We have a single Lisp++ program and list of Q queries about that program; each query consists of a start position $S_j$ and an end position $E_j$. To answer the j-th query, you must determine the smallest possible amount of time $N_j$ (in seconds) that it will take to take the cursor from position $S_j$ to position $E_j$, if you make optimal decisions.\n\nPlease output the sum of all of those $N_j$ values.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. The first line of a test case contains two integers $K$, which is the length of the Lisp++ program, and $Q$, which is the number of queries.\n\nThe second line of a test case contains a string $P$ of $K$ characters, each of which is either ( or ), representing a Lisp++ program (string of balanced parentheses), as described above.\n\nThe third, fourth, and fifth lines of a test case each contain $K$ integers. The $i$-th integers in these lines are the values $L_i$, $R_i$, and $P_i$, respectively, that are described above.\n\nThe sixth and seventh lines of a test case each contain $Q$ integers. The $j$-th integers in these lines are $S_j$ and $E_j$, respectively, that are described above.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the sum of the $N_j$ values that are described above.", "hint": "**Sample Explanation**\n\nIn the sample case, which obeys the limits for Test Set 1, all of the time costs are the same ($1$ second per move). The shortest times for the queries are as follows:\n\n1. Move right from $7$ five times to $12$ taking $5$ seconds.\n2. Teleport from $4$ to $11$ taking $1$ second.\n3. Teleport from $4$ to $11$, then move left to $10$ taking $2$ seconds.\n4. Teleport from $12$ to $1$, taking $1$ second.\n5. Move right from $5$ to $6$ taking $1$ second.\n\nThus, the sum of query times is $5+1+2+1+1 = 10$ seconds.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $K = 10^5$ and $Q = 10^5$, for at most 9 test cases.\n- $2 \\leq K \\leq 1000$ and $1 \\leq Q \\leq 1000$, in all other cases.\n- length of $P = K$ $P$ is a string of balanced parentheses, as described above.\n- $1 \\leq S_j \\leq K$, for all $j$.\n- $1 \\leq E_j \\leq K$, for all $j$.\n\n**Test Set 1 (12 Pts, Visible Verdict)**\n\n- $L_i = 1$, for all $i$.\n- $R_i = 1$, for all $i$.\n- $P_i = 1$, for all $i$.\n\n**Test Set 2 (23 Pts, Hidden Verdict)**\n\n- $1 \\leq L_i \\leq 10^6$, for all $i$.\n- $1 \\leq R_i \\leq 10^6$, for all $i$.\n- $1 \\leq P_i \\leq 10^6$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #2] Emacs++", "background": "", "description": "在 2016 年的 **Distributed Code Jam** 中，我们为偏爱更高密度括号的 Lisp 爱好者推出了 **Lisp++** 语言。以下是该语言语法规则的回顾：\n\n一个 Lisp++ 程序是一个由平衡括号组成的字符串。更正式地说，Lisp++ 程序由以下任意一种形式构成（在此规范中，$C$ 代表某段程序代码——每次出现时不一定相同）：\n\n- `()`：字面上仅包含一个左括号和一个右括号。我们说这个 `(` 匹配这个 `)`，反之亦然。\n- `(C)`：被一对括号包裹的程序。我们说这个 `(` 匹配这个 `)`，反之亦然。\n- $CC$：两个程序（不一定相同）连续拼接。\n\n今年，我们很高兴推出 **Emacs++**，一款专为 Lisp++ 设计的文本查看器。Emacs++ 将长度为 $K$ 的 Lisp++ 程序显示为一行长文本，并带有一个可移动的光标。光标是一个“块光标”，始终位于程序的 $K$ 个字符之一上，而非字符之间。\n\n在任何时刻，你可以执行以下三种操作之一来移动光标（$i$ 表示光标的当前位置，从最左侧位置开始计数为 1）：\n\n- 将光标向左移动一个字符（若光标已在最左侧字符则不做任何操作）。此操作耗时 $L_i$ 秒。\n- 将光标向右移动一个字符（若光标已在最右侧字符则不做任何操作）。此操作耗时 $R_i$ 秒。\n- 将光标传送到与第 $i$ 个字符的括号（如上所述）匹配的括号处。此操作耗时 $P_i$ 秒。\n\n我们认为 Emacs++ 对高级用户来说很简单，但仍需了解其效率。我们有一个 Lisp++ 程序和关于该程序的 $Q$ 个查询；每个查询包含一个起始位置 $S_j$ 和一个目标位置 $E_j$。为了回答第 $j$ 个查询，你需要确定在最优决策下，将光标从位置 $S_j$ 移动到位置 $E_j$ 所需的最小时间 $N_j$（以秒为单位）。\n\n请输出所有 $N_j$ 值的总和。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。随后是 $T$ 个测试用例。每个测试用例的第一行包含两个整数 $K$（表示 Lisp++ 程序的长度）和 $Q$（表示查询的数量）。\n\n每个测试用例的第二行包含一个长度为 $K$ 的字符串 $P$，每个字符为 `(` 或 `)`，表示一个 Lisp++ 程序（平衡括号字符串），如上所述。\n\n每个测试用例的第三、第四和第五行各包含 $K$ 个整数。这些行的第 $i$ 个整数分别为上述的 $L_i$、$R_i$ 和 $P_i$。\n\n每个测试用例的第六和第七行各包含 $Q$ 个整数。这些行的第 $j$ 个整数分别为上述的 $S_j$ 和 $E_j$。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是上述所有 $N_j$ 值的总和。\n", "hint": "**样例解释**\n\n在样例中（符合测试集 1 的限制），所有移动的时间成本相同（每次移动 1 秒）。各查询的最短时间如下：\n\n1. 从 $7$ 向右移动五次到 $12$，耗时 $5$ 秒。\n2. 从 $4$ 传送到 $11$，耗时 $1$ 秒。\n3. 从 $4$ 传送到 $11$，再向左移动到 $10$，耗时 $2$ 秒。\n4. 从 $12$ 传送到 $1$，耗时 $1$ 秒。\n5. 从 $5$ 向右移动到 $6$，耗时 $1$ 秒。\n\n因此，查询时间的总和为 $5 + 1 + 2 + 1 + 1 = 10$ 秒。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- 对于最多 9 个测试用例，$K = 10^5$ 且 $Q = 10^5$。\n- 其他所有情况下，$2 \\leq K \\leq 1000$ 且 $1 \\leq Q \\leq 1000$。\n- 字符串 $P$ 的长度为 $K$，且 $P$ 是一个平衡括号字符串，如上所述。\n- 对于所有 $j$，$1 \\leq S_j \\leq K$。\n- 对于所有 $j$，$1 \\leq E_j \\leq K$。\n\n**测试集 1（12 分，可见判定）**\n\n- 对于所有 $i$，$L_i = 1$。\n- 对于所有 $i$，$R_i = 1$。\n- 对于所有 $i$，$P_i = 1$。\n\n**测试集 2（23 分，隐藏判定）**\n\n- 对于所有 $i$，$1 \\leq L_i \\leq 10^6$。\n- 对于所有 $i$，$1 \\leq R_i \\leq 10^6$。\n- 对于所有 $i$，$1 \\leq P_i \\leq 10^6$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13066", "type": "P", "difficulty": 4, "samples": [["4\nXYZZY ZZYZX\nY Z\nYYXXYZ ZYYXXY\nXZXZXZ YZ", "Case #1: ZZY\nCase #2: Z\nCase #3: ZYYXXYZ\nCase #4: ZYZX"], ["1\nGCJ ABC", "Case #1: GC"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2020", "Special Judge", "Google Code Jam"], "title": "[GCJ 2020 #3] Naming Compromise", "background": "", "description": "Cameron and Jamie are about to welcome a second baby into their lives. They are already good at working together as parents, but right now they are disagreeing about one crucial thing! Cameron wants to name the baby one name (the string $\\mathbf{C}$), whereas Jamie wants to name the baby something else (the string $\\mathbf{J}$).\n\nYou want to help them find a compromise name that is as close as possible to what each of them wants. You think you can do this using the notion of edit distance. The edit distance between two strings $S_1$ and $S_2$ is the minimum number of operations required to transform $S_1$ into $S_2$, where the allowed operations are as follows:\n\n* Insert one character anywhere in the string.\n* Delete one character from anywhere in the string.\n* Change one character in the string to any other character.\n\nFor example, the edit distance between CAMERON and JAMIE is 5. One way to accomplish the transformation in 5 steps is the following: CAMERON to JAMERON (change) to JAMIERON (insert) to JAMIEON (delete) to JAMIEN (delete) to JAMIE (delete). Any transformation from CAMERON into JAMIE requires at least this many operations.\n\nTo make the compromise name $N$ as close as possible to the original desires of the parents, you want $N$ to be a non-empty string such that the sum of the edit distances between $\\mathbf{C}$ and $N$ and between $\\mathbf{J}$ and $N$ is as small as possible. Out of all those choices for $N$, to make sure the compromise is fair, you must choose an $N$ such that the difference between those two edit distances is also as small as possible. Please find a compromise name for Cameron and Jamie.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case consists of a single line with two strings $\\mathbf{C}$ and $\\mathbf{J}$: the names that Cameron and Jamie have proposed for the baby, respectively. Each of these names is made up of uppercase English alphabet letters.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a name that meets the requirements mentioned in the statement. Note that $y$ must contain only uppercase English letters.", "hint": "**Sample Explanation**\n\nSample Test Set 1 meets the limits for Test Set 1. Another sample case that does not meet those limits but could appear in Test Set 2.\n\nThe above cases meet the limits for Test Set 1. Another sample case that does not meet those limits appears at the end of this section.\n\nIn Sample Case #1, the edit distance from `XYZZY` to `ZZY` is 2 (delete the first two letters), and the edit distance from `ZZYZX` to `ZZY` is 2 (delete the last two letters). `XZZX` and `ZYYZY` would also work. No possible name has a sum of edit distances that is less than 4.\n\n`ZY`, for example, has the same edit distance to `C` as to `J` (3, in each case). However the sum of those distances would be 6, which is not minimal, so it would not be an acceptable answer.\n\n`XZZY` is also unacceptable. Its edit distances to `C` and `J`, respectively, are 1 and 3. The sum of those edit distances is minimal, but the difference between the two ($|1-3| = 2$) is not minimal, since we have shown that it is possible to achieve a difference of 0.\n\nIn Sample Case #2, `Y` and `Z` are the only acceptable answers.\n\nIn Sample Case #3, notice that input length restrictions do not apply to the output, so the shown answer is acceptable in either test set. Another possible answer is `YYXXY`.\n\nIn Sample Case #4, the edit distance between `XZXZXZ` and `ZYZX` is 3, and the edit distance between `YZ` and `ZYZX` is 2. The sum of those edit distances is 5, and their difference is 1; these values are optimal for this case.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $\\mathbf{C} \\neq \\mathbf{J}$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $1 \\leq \\text{length of } \\mathbf{C} \\leq 6$.\n- $1 \\leq \\text{length of } \\mathbf{J} \\leq 6$.\n- The i-th letter of $\\mathbf{C}$ is an uppercase x, y, or z, for all i.\n- The i-th letter of $\\mathbf{J}$ is an uppercase x, y, or z, for all i.\n\n**Test Set 2 (8 Pts, Hidden Verdict)**\n\n- $1 \\leq \\text{length of } \\mathbf{C} \\leq 60$.\n- $1 \\leq \\text{length of } \\mathbf{J} \\leq 60$.\n- The $i$-th letter of $\\mathbf{C}$ is an uppercase English alphabet letter, for all i.\n- The $i$-th letter of $\\mathbf{J}$ is an uppercase English alphabet letter, for all i.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #3] Naming Compromise", "background": "", "description": "Cameron and Jamie are about to welcome a second baby into their lives. They are already good at working together as parents, but right now they are disagreeing about one crucial thing! Cameron wants to name the baby one name (the string $\\mathbf{C}$), whereas Jamie wants to name the baby something else (the string $\\mathbf{J}$).\n\nYou want to help them find a compromise name that is as close as possible to what each of them wants. You think you can do this using the notion of edit distance. The edit distance between two strings $S_1$ and $S_2$ is the minimum number of operations required to transform $S_1$ into $S_2$, where the allowed operations are as follows:\n\n* Insert one character anywhere in the string.\n* Delete one character from anywhere in the string.\n* Change one character in the string to any other character.\n\nFor example, the edit distance between CAMERON and JAMIE is 5. One way to accomplish the transformation in 5 steps is the following: CAMERON to JAMERON (change) to JAMIERON (insert) to JAMIEON (delete) to JAMIEN (delete) to JAMIE (delete). Any transformation from CAMERON into JAMIE requires at least this many operations.\n\nTo make the compromise name $N$ as close as possible to the original desires of the parents, you want $N$ to be a non-empty string such that the sum of the edit distances between $\\mathbf{C}$ and $N$ and between $\\mathbf{J}$ and $N$ is as small as possible. Out of all those choices for $N$, to make sure the compromise is fair, you must choose an $N$ such that the difference between those two edit distances is also as small as possible. Please find a compromise name for Cameron and Jamie.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case consists of a single line with two strings $\\mathbf{C}$ and $\\mathbf{J}$: the names that Cameron and Jamie have proposed for the baby, respectively. Each of these names is made up of uppercase English alphabet letters.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a name that meets the requirements mentioned in the statement. Note that $y$ must contain only uppercase English letters.", "hint": "**Sample Explanation**\n\nSample Test Set 1 meets the limits for Test Set 1. Another sample case that does not meet those limits but could appear in Test Set 2.\n\nThe above cases meet the limits for Test Set 1. Another sample case that does not meet those limits appears at the end of this section.\n\nIn Sample Case #1, the edit distance from `XYZZY` to `ZZY` is 2 (delete the first two letters), and the edit distance from `ZZYZX` to `ZZY` is 2 (delete the last two letters). `XZZX` and `ZYYZY` would also work. No possible name has a sum of edit distances that is less than 4.\n\n`ZY`, for example, has the same edit distance to `C` as to `J` (3, in each case). However the sum of those distances would be 6, which is not minimal, so it would not be an acceptable answer.\n\n`XZZY` is also unacceptable. Its edit distances to `C` and `J`, respectively, are 1 and 3. The sum of those edit distances is minimal, but the difference between the two ($|1-3| = 2$) is not minimal, since we have shown that it is possible to achieve a difference of 0.\n\nIn Sample Case #2, `Y` and `Z` are the only acceptable answers.\n\nIn Sample Case #3, notice that input length restrictions do not apply to the output, so the shown answer is acceptable in either test set. Another possible answer is `YYXXY`.\n\nIn Sample Case #4, the edit distance between `XZXZXZ` and `ZYZX` is 3, and the edit distance between `YZ` and `ZYZX` is 2. The sum of those edit distances is 5, and their difference is 1; these values are optimal for this case.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $\\mathbf{C} \\neq \\mathbf{J}$.\n\n**Test Set 1 (4 Pts, Visible Verdict)**\n\n- $1 \\leq \\text{length of } \\mathbf{C} \\leq 6$.\n- $1 \\leq \\text{length of } \\mathbf{J} \\leq 6$.\n- The i-th letter of $\\mathbf{C}$ is an uppercase x, y, or z, for all i.\n- The i-th letter of $\\mathbf{J}$ is an uppercase x, y, or z, for all i.\n\n**Test Set 2 (8 Pts, Hidden Verdict)**\n\n- $1 \\leq \\text{length of } \\mathbf{C} \\leq 60$.\n- $1 \\leq \\text{length of } \\mathbf{J} \\leq 60$.\n- The $i$-th letter of $\\mathbf{C}$ is an uppercase English alphabet letter, for all i.\n- The $i$-th letter of $\\mathbf{J}$ is an uppercase English alphabet letter, for all i.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #3] Naming Compromise", "background": "", "description": "Cameron 和 Jamie 即将迎来他们的第二个孩子。他们在育儿方面已经配合得很好了，但此刻却在一个关键问题上产生了分歧！Cameron 想给孩子取名为 $\\mathbf{C}$，而 Jamie 则想取名为 $\\mathbf{J}$。\n\n你希望帮助他们找到一个折中的名字，使其尽可能接近双方的想法。你认为可以通过**编辑距离**的概念来实现这一点。两个字符串 $S_1$ 和 $S_2$ 之间的编辑距离是指将 $S_1$ 转换为 $S_2$ 所需的最少操作次数，允许的操作包括：\n\n* 在字符串任意位置插入一个字符。\n* 删除字符串中的任意一个字符。\n* 将字符串中的一个字符替换为其他任意字符。\n\n例如，CAMERON 和 JAMIE 之间的编辑距离为 5。一种用 5 步完成转换的方式如下：CAMERON → JAMERON（替换）→ JAMIERON（插入）→ JAMIEON（删除）→ JAMIEN（删除）→ JAMIE（删除）。从 CAMERON 转换到 JAMIE 至少需要这么多操作。\n\n为了使折中名字 $N$ 尽可能接近父母的原始意愿，你需要选择一个非空字符串 $N$，使得 $\\mathbf{C}$ 与 $N$ 的编辑距离和 $\\mathbf{J}$ 与 $N$ 的编辑距离之和最小。在所有满足这一条件的 $N$ 中，为了确保公平性，你还必须选择一个使得这两个编辑距离之差也尽可能小的 $N$。请为 Cameron 和 Jamie 找到一个折中名字。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含一行，其中有两个字符串 $\\mathbf{C}$ 和 $\\mathbf{J}$，分别表示 Cameron 和 Jamie 提议的婴儿名字。这些名字均由大写英文字母组成。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是满足题目要求的名字。注意，$y$ 必须仅包含大写英文字母。\n", "hint": "**样例解释**\n\n样例测试集 1 符合测试集 1 的限制。另一个不符合这些限制但可能出现在测试集 2 中的样例见下文。\n\n在样例 #1 中，从 `XYZZY` 到 `ZZY` 的编辑距离为 2（删除前两个字母），从 `ZZYZX` 到 `ZZY` 的编辑距离为 2（删除最后两个字母）。`XZZX` 和 `ZYYZY` 也是可行的解。没有其他名字能使编辑距离之和小于 4。\n\n例如，`ZY` 到 `C` 和 `J` 的编辑距离相同（均为 3），但编辑距离之和为 6，并非最小值，因此不是可接受的答案。\n\n`XZZY` 也不符合要求。它到 `C` 和 `J` 的编辑距离分别为 1 和 3。虽然编辑距离之和是最小的，但两者之差（$|1-3| = 2$）并非最小，因为我们已经证明可以找到差值为 0 的解。\n\n在样例 #2 中，`Y` 和 `Z` 是唯一可接受的答案。\n\n在样例 #3 中，注意输入的长度限制不适用于输出，因此所示答案在任一测试集中均可接受。另一个可能的答案是 `YYXXY`。\n\n在样例 #4 中，`XZXZXZ` 到 `ZYZX` 的编辑距离为 3，`YZ` 到 `ZYZX` 的编辑距离为 2。编辑距离之和为 5，差值为 1；这些值是该情况下的最优解。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $\\mathbf{C} \\neq \\mathbf{J}$。\n\n**测试集 1（4 分，可见判定）**\n\n- $1 \\leq \\text{C 的长度} \\leq 6$。\n- $1 \\leq \\text{J 的长度} \\leq 6$。\n- $\\mathbf{C}$ 的第 $i$ 个字母是大写 X、Y 或 Z。\n- $\\mathbf{J}$ 的第 $i$ 个字母是大写 X、Y 或 Z。\n\n**测试集 2（8 分，隐藏判定）**\n\n- $1 \\leq \\text{C 的长度} \\leq 60$。\n- $1 \\leq \\text{J 的长度} \\leq 60$。\n- $\\mathbf{C}$ 的第 $i$ 个字母是大写英文字母。\n- $\\mathbf{J}$ 的第 $i$ 个字母是大写英文字母。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13067", "type": "P", "difficulty": 6, "samples": [["3\n2 2\n0 1\n184 330\n3 2\n0 1\n184 330\n10 3\n1 5 9\n184 200 330\n", "Case #1: 2\nCase #2: 3\nCase #3: 3"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2020", "Google Code Jam"], "title": "[GCJ 2020 #3] Thermometers", "background": "", "description": "You are part of a team of researchers investigating the climate along the coast of an island. The island's coast is modeled as a circle with a circumference of $K$ kilometers. There is a lighthouse on the coast which occupies a single point on the circle's circumference. Each point on the coast is mapped to a real number in the range $[0, K)$; formally, point $x$ is the point on the coast that is $x$ kilometers away from the lighthouse when walking clockwise along the coast. For example, if $K = 5$, point $0$ is the point where the lighthouse is, point $1.5$ is the point that is $1.5$ kilometers away from the lighthouse in the clockwise direction, and point $2.5$ is the point that is located at the diametrical opposite of the lighthouse.\n\nYou are in charge of studying coastal temperatures. Another team installed a coastal temperature measuring system that works as follows: a number of thermometers were deployed at specific points to measure the temperature at those points. No two thermometers were placed at the same point. In that team's model, points without thermometers are assumed to have the same temperature as the one measured by the closest thermometer. For points that are equidistant from two thermometers, the thermometer in the clockwise direction is used (the first one you would encounter if walking clockwise from the point).\n\nUnfortunately, you do not know how many thermometers the system used or where they were placed, but you do have access to the system's temperature data. It is given as two lists of $N$ values each $X_1$, $X_2$, $\\dots$, $X_N$ and $T_1$, $T_2$, $\\dots$, $T_N$, representing that each point $x$ where $X_i \\leq x < X_{i+1}$ is assigned temperature $T_i$, for each $1 \\leq i < N$, and each point $x$ where $0 \\leq x < X_1$ or $X_N \\leq x < K$ is assigned temperature $T_N$. The points are enumerated in the clockwise direction, so $X_i < X_{i+1}$, for all $i$.\n\nYou want to determine the smallest number of thermometers that, when placed in some set of locations, could have produced the observed data.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of three lines. The first line of a test case contains two integers $K$ and $N$: the circumference of the island and the size of the lists representing the temperature data. The second line contains $N$ integers $X_1$, $X_2$, $\\dots$, $X_N$. The third line contains $N$ integers $T_1$, $T_2$, $\\dots$, $T_N$. The way in which the integers in the second and third line represent the temperatures is explained above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of thermometers that could have produced the observed input data, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, at least 2 thermometers are needed because there are two different temperatures measured. It is possible to produce the data using exactly 2 thermometers, with one thermometer (measuring 184) at point 0.5 and another (measuring 330) at point 1.5. Note that point 0 and point 1 are equidistant from both thermometers, so the thermometer in the clockwise direction is used. The temperature measured at point 0 comes from the thermometer at point 0.5 and the temperature measured at point 1 comes from the thermometer at point 1.5.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/dk7alwgf)\n\nThe data from Sample Case #2 could not be produced with just 2 thermometers. It could be produced with 3 thermometers if they were placed at point 0.2, point 1.8, and point 2.8, measuring 184, 330 and 330, respectively. There are other ways to place 3 thermometers that would also yield the input data.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/i379fxtz)\n\nIn Sample Case #3, one way to produce the data with 3 thermometers is to place them at point 0, point 2 and point 8, measuring 330, 184 and 200, respectively.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/mrnq6cjj)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq \\min(100, K)$.\n- $0 \\leq X_1$.\n- $X_i < X_{i+1}$, for all $i$.\n- $X_N < K$.\n- $184 \\leq T_i \\leq 330$, for all $i$.\n- $T_i \\neq T_{i+1}$, for all $i$.\n- $T_1 \\neq T_N$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $2 \\leq K \\leq 10$.\n\n**Test Set 2 (19 Pts, Hidden Verdict)**\n\n- $2 \\leq K \\leq 10^9$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #3] Thermometers", "background": "", "description": "You are part of a team of researchers investigating the climate along the coast of an island. The island's coast is modeled as a circle with a circumference of $K$ kilometers. There is a lighthouse on the coast which occupies a single point on the circle's circumference. Each point on the coast is mapped to a real number in the range $[0, K)$; formally, point $x$ is the point on the coast that is $x$ kilometers away from the lighthouse when walking clockwise along the coast. For example, if $K = 5$, point $0$ is the point where the lighthouse is, point $1.5$ is the point that is $1.5$ kilometers away from the lighthouse in the clockwise direction, and point $2.5$ is the point that is located at the diametrical opposite of the lighthouse.\n\nYou are in charge of studying coastal temperatures. Another team installed a coastal temperature measuring system that works as follows: a number of thermometers were deployed at specific points to measure the temperature at those points. No two thermometers were placed at the same point. In that team's model, points without thermometers are assumed to have the same temperature as the one measured by the closest thermometer. For points that are equidistant from two thermometers, the thermometer in the clockwise direction is used (the first one you would encounter if walking clockwise from the point).\n\nUnfortunately, you do not know how many thermometers the system used or where they were placed, but you do have access to the system's temperature data. It is given as two lists of $N$ values each $X_1$, $X_2$, $\\dots$, $X_N$ and $T_1$, $T_2$, $\\dots$, $T_N$, representing that each point $x$ where $X_i \\leq x < X_{i+1}$ is assigned temperature $T_i$, for each $1 \\leq i < N$, and each point $x$ where $0 \\leq x < X_1$ or $X_N \\leq x < K$ is assigned temperature $T_N$. The points are enumerated in the clockwise direction, so $X_i < X_{i+1}$, for all $i$.\n\nYou want to determine the smallest number of thermometers that, when placed in some set of locations, could have produced the observed data.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of three lines. The first line of a test case contains two integers $K$ and $N$: the circumference of the island and the size of the lists representing the temperature data. The second line contains $N$ integers $X_1$, $X_2$, $\\dots$, $X_N$. The third line contains $N$ integers $T_1$, $T_2$, $\\dots$, $T_N$. The way in which the integers in the second and third line represent the temperatures is explained above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of thermometers that could have produced the observed input data, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, at least 2 thermometers are needed because there are two different temperatures measured. It is possible to produce the data using exactly 2 thermometers, with one thermometer (measuring 184) at point 0.5 and another (measuring 330) at point 1.5. Note that point 0 and point 1 are equidistant from both thermometers, so the thermometer in the clockwise direction is used. The temperature measured at point 0 comes from the thermometer at point 0.5 and the temperature measured at point 1 comes from the thermometer at point 1.5.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/dk7alwgf)\n\nThe data from Sample Case #2 could not be produced with just 2 thermometers. It could be produced with 3 thermometers if they were placed at point 0.2, point 1.8, and point 2.8, measuring 184, 330 and 330, respectively. There are other ways to place 3 thermometers that would also yield the input data.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/i379fxtz)\n\nIn Sample Case #3, one way to produce the data with 3 thermometers is to place them at point 0, point 2 and point 8, measuring 330, 184 and 200, respectively.\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/mrnq6cjj)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq \\min(100, K)$.\n- $0 \\leq X_1$.\n- $X_i < X_{i+1}$, for all $i$.\n- $X_N < K$.\n- $184 \\leq T_i \\leq 330$, for all $i$.\n- $T_i \\neq T_{i+1}$, for all $i$.\n- $T_1 \\neq T_N$.\n\n**Test Set 1 (5 Pts, Visible Verdict)**\n\n- $2 \\leq K \\leq 10$.\n\n**Test Set 2 (19 Pts, Hidden Verdict)**\n\n- $2 \\leq K \\leq 10^9$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #3] Thermometers", "background": "", "description": "你是一个研究岛屿海岸气候的团队成员。该岛屿的海岸被建模为一个周长为 $K$ 公里的圆。海岸上有一座灯塔，占据圆周上的一个点。海岸上的每个点都被映射到 $[0, K)$ 范围内的一个实数；形式上，点 $x$ 表示从灯塔出发沿顺时针方向行走 $x$ 公里后到达的海岸点。例如，若 $K = 5$，点 $0$ 是灯塔所在位置，点 $1.5$ 是从灯塔出发顺时针方向 $1.5$ 公里的点，而点 $2.5$ 是灯塔的直径对称点。\n\n你负责研究海岸温度。另一个团队安装了一套海岸温度测量系统，其工作原理如下：在特定位置部署了若干温度计以测量这些点的温度。没有两个温度计被放置在同一个点。在该团队的模型中，没有温度计的点被认为与最近温度计测量的温度相同。对于与两个温度计等距的点，使用顺时针方向的温度计（即从该点出发顺时针行走时最先遇到的温度计）。\n\n遗憾的是，你不知道系统使用了多少个温度计或它们的具体位置，但你可以访问系统的温度数据。数据以两个长度为 $N$ 的列表给出：$X_1, X_2, \\dots, X_N$ 和 $T_1, T_2, \\dots, T_N$，表示对于每个 $1 \\leq i < N$，满足 $X_i \\leq x < X_{i+1}$ 的点 $x$ 被分配温度 $T_i$，而满足 $0 \\leq x < X_1$ 或 $X_N \\leq x < K$ 的点 $x$ 被分配温度 $T_N$。这些点按顺时针方向排列，因此对所有 $i$ 有 $X_i < X_{i+1}$。\n\n你需要确定能够产生观测数据的最小温度计数量。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。随后是 $T$ 个测试用例；每个测试用例包含三行。第一行包含两个整数 $K$ 和 $N$：岛屿的周长和表示温度数据的列表大小。第二行包含 $N$ 个整数 $X_1, X_2, \\dots, X_N$。第三行包含 $N$ 个整数 $T_1, T_2, \\dots, T_N$。第二行和第三行的整数表示温度的方式如上所述。\n", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是能够产生输入数据的最小温度计数量。\n", "hint": "**样例解释**\n\n在样例 #1 中，至少需要 2 个温度计，因为测量到了两种不同的温度。可以通过在点 0.5 放置一个温度计（测量值为 184）和在点 1.5 放置另一个温度计（测量值为 330）来生成数据。注意，点 0 和点 1 与两个温度计的距离相等，因此使用顺时针方向的温度计。点 0 的温度来自点 0.5 的温度计，点 1 的温度来自点 1.5 的温度计。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/dk7alwgf)\n\n样例 #2 的数据无法仅用 2 个温度计生成。可以通过在点 0.2、点 1.8 和点 2.8 分别放置测量值为 184、330 和 330 的 3 个温度计来生成数据。还有其他放置 3 个温度计的方式也能生成输入数据。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/i379fxtz)\n\n在样例 #3 中，一种生成数据的方式是在点 0、点 2 和点 8 分别放置测量值为 330、184 和 200 的 3 个温度计。\n\n![](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/mrnq6cjj)\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq N \\leq \\min(100, K)$。\n- $0 \\leq X_1$。\n- 对所有 $i$，$X_i < X_{i+1}$。\n- $X_N < K$。\n- 对所有 $i$，$184 \\leq T_i \\leq 330$。\n- 对所有 $i$，$T_i \\neq T_{i+1}$。\n- $T_1 \\neq T_N$。\n\n**测试集 1（5 分，可见判定）**\n\n- $2 \\leq K \\leq 10$。\n\n**测试集 2（19 分，隐藏判定）**\n\n- $2 \\leq K \\leq 10^9$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13068", "type": "P", "difficulty": 6, "samples": [["2 5 1\n\n1 0\n\n0 1\n\n0 1", "\n4 5\n\n4 3\n\n0 2\n\n0 0\n3 4 3 4"]], "limits": {"time": [90000, 90000, 90000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2020", "交互题", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2020 #3] Pen Testing", "background": "", "description": "You have $N$ ballpoint pens. You know that each has a distinct integer number of units of ink between $0$ and $N-1$, but the pens are given to you in random order, and therefore you do not know which pen is which.\n\nYou are about to go on a trip to the South Pole (where there are no pens), and your luggage only has room for two pens, but you know you will need to do a lot of important postcard writing. Specifically, the two pens you choose must have a total of at least $N$ ink units.\n\nYour only way to get information about the pens is to choose one and try writing something with it. You will either succeed, in which case the pen will now have one unit of ink less (and is now possibly empty), or fail, which means that the pen already had no ink left. You can repeat this multiple times, with the same pen or different pens.\n\nEventually, you must select the two pens to take on your trip, and you succeed if the total amount of ink remaining in those two pens is at least $N$ units.\n\nYou will be given $T$ test cases, and you must succeed in at least $C$ of them. Note that all test sets in this problem are Visible.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing three integers $\\mathbf{T}$, $\\mathbf{N}$, and $\\mathbf{C}$: the number of test cases, the number of pens, and the minimum number of test cases you must succeed in. (Note that the value of $\\mathbf{N}$ is the same for all test sets, and is provided as input only for convenience; see the Limits section for more details.)\n\nThen, your program needs to process all $\\mathbf{T}$ test cases at the same time (this is done to reduce the number of roundtrips between your solution and the judging program). The interaction is organized into rounds.\n\nAt the beginning of each round, your program must print one line containing $\\mathbf{T}$ integers: the i-th integer is the number of the pen you want to try writing with in the i-th test case, or 0 if you do not want to write with any pen in this test case in this round. The pens are numbered from 1 to $\\mathbf{N}$.\n\nBe aware that flushing the output buffer after each one of these integers, instead of only once after printing all $\\mathbf{T}$, could cause a Time Limit Exceeded error because of the time consumed by the flushing itself.\n\nThe judge responds with one line containing $\\mathbf{T}$ integers: the i-th integer is the amount of ink spent in the i-th test case in this round. It will be equal to 1 if the writing in the i-th test case was successful. Otherwise, it will be equal to 0, which could mean that you tried to write in the i-th test case but the pen you chose had no ink left, or that you did not try to write in the i-th test case at all.\n\nYou may participate in at most $\\mathbf{N} \\times (\\mathbf{N}+1)/2$ rounds. Note that this is enough to be confident that all pens are empty.\n\nWhen your program is ready to submit an answer for all test cases, it must print a line containing the number 0 $\\mathbf{T}$ times. This line is not counted towards the limit on the number of rounds, and the judge will not send a response.\n\nThen, your program must print another line with $2 \\times \\mathbf{T}$ integers: the $(2 \\times \\mathbf{i}-1)$-th and the $(2 \\times \\mathbf{i})$-th integers in this line are the distinct numbers of the pens that you take to the South Pole in the i-th test case. The judge will not send a response, and your program must then terminate with no error.\n\nIf the judge receives unexpected output from your program at any moment, the judge will print a single number -1 and not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n\nYou can assume that the pens are given to you in random order. These orders are chosen uniformly at random and independently for each test case and for each submission. Therefore even if you submit exactly the same code twice the judge will use different random orders.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nHere is the same interaction, explained:\n\n```\n  // The following reads 2 into t, 5 into n and 1 into c.\n  t, n, c = readline_int_list()\n  // The judge secretly picks the number of units for each pen:\n  // in test case 1: 2 0 4 1 3\n  // in test case 2: 1 3 2 4 0\n  // We write with the 4-th pen in test case 1, and with the 5-th pen in test case 2.\n  printline 4 5 to stdout\n  flush stdout\n  // Reads 1 0, as the 4-th pen in test case 1 still had ink left,\n  // but the 5-th pen in test case 2 did not.\n  a1, a2 = readline_int_list()\n  // We write with the 4-th pen in test case 1 again, and with the 3-rd pen in test case 2.\n  printline 4 3 to stdout\n  flush stdout\n  // Reads 0 1.\n  a1, a2 = readline_int_list()\n  // We only write in test case 2 this time, with the 2-nd pen.\n  printline 0 2 to stdout\n  flush stdout\n  // Reads 0 1.\n  a1, a2 = readline_int_list()\n  // We decide we are ready to answer.\n  printline 0 0 to stdout\n  flush stdout\n  // We take the 3-rd and the 4-th pens to the South Pole in both test cases.\n  printline 3 4 3 4 to stdout\n  flush stdout\n  // In test case 1, the remaining amounts in the 3-rd and the 4-th pens are 4 and 0, and 4+0<5,\n  // so we did not succeed.\n  // In test case 2, the remaining amounts in the 3-rd and the 4-th pens are 1 and 4, and 1+4≥5,\n  // so we succeeded.\n  // We have succeeded in 1 out of 2 test cases, which is good enough since c=1.\n  exit\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $\\mathbf{N} = 15$.\n\n**Test Set 1 (6 Pts, Visible Verdict)**\n\n- $\\mathbf{T} = 20000$.\n- $\\mathbf{C} = 10900$ ($\\mathbf{C} = 0.545 \\times \\mathbf{T}$).\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $\\mathbf{T} = 20000$.\n- $\\mathbf{C} = 12000$ ($\\mathbf{C} = 0.6 \\times \\mathbf{T}$).\n\n**Test Set 3 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{T} = 100000$.\n- $\\mathbf{C} = 63600$ ($\\mathbf{C} = 0.636 \\times \\mathbf{T}$).", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #3] Pen Testing", "background": "", "description": "You have $N$ ballpoint pens. You know that each has a distinct integer number of units of ink between $0$ and $N-1$, but the pens are given to you in random order, and therefore you do not know which pen is which.\n\nYou are about to go on a trip to the South Pole (where there are no pens), and your luggage only has room for two pens, but you know you will need to do a lot of important postcard writing. Specifically, the two pens you choose must have a total of at least $N$ ink units.\n\nYour only way to get information about the pens is to choose one and try writing something with it. You will either succeed, in which case the pen will now have one unit of ink less (and is now possibly empty), or fail, which means that the pen already had no ink left. You can repeat this multiple times, with the same pen or different pens.\n\nEventually, you must select the two pens to take on your trip, and you succeed if the total amount of ink remaining in those two pens is at least $N$ units.\n\nYou will be given $T$ test cases, and you must succeed in at least $C$ of them. Note that all test sets in this problem are Visible.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing three integers $\\mathbf{T}$, $\\mathbf{N}$, and $\\mathbf{C}$: the number of test cases, the number of pens, and the minimum number of test cases you must succeed in. (Note that the value of $\\mathbf{N}$ is the same for all test sets, and is provided as input only for convenience; see the Limits section for more details.)\n\nThen, your program needs to process all $\\mathbf{T}$ test cases at the same time (this is done to reduce the number of roundtrips between your solution and the judging program). The interaction is organized into rounds.\n\nAt the beginning of each round, your program must print one line containing $\\mathbf{T}$ integers: the i-th integer is the number of the pen you want to try writing with in the i-th test case, or 0 if you do not want to write with any pen in this test case in this round. The pens are numbered from 1 to $\\mathbf{N}$.\n\nBe aware that flushing the output buffer after each one of these integers, instead of only once after printing all $\\mathbf{T}$, could cause a Time Limit Exceeded error because of the time consumed by the flushing itself.\n\nThe judge responds with one line containing $\\mathbf{T}$ integers: the i-th integer is the amount of ink spent in the i-th test case in this round. It will be equal to 1 if the writing in the i-th test case was successful. Otherwise, it will be equal to 0, which could mean that you tried to write in the i-th test case but the pen you chose had no ink left, or that you did not try to write in the i-th test case at all.\n\nYou may participate in at most $\\mathbf{N} \\times (\\mathbf{N}+1)/2$ rounds. Note that this is enough to be confident that all pens are empty.\n\nWhen your program is ready to submit an answer for all test cases, it must print a line containing the number 0 $\\mathbf{T}$ times. This line is not counted towards the limit on the number of rounds, and the judge will not send a response.\n\nThen, your program must print another line with $2 \\times \\mathbf{T}$ integers: the $(2 \\times \\mathbf{i}-1)$-th and the $(2 \\times \\mathbf{i})$-th integers in this line are the distinct numbers of the pens that you take to the South Pole in the i-th test case. The judge will not send a response, and your program must then terminate with no error.\n\nIf the judge receives unexpected output from your program at any moment, the judge will print a single number -1 and not print any further output. If your program continues to wait for the judge after receiving a -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n\nYou can assume that the pens are given to you in random order. These orders are chosen uniformly at random and independently for each test case and for each submission. Therefore even if you submit exactly the same code twice the judge will use different random orders.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Explanation**\n\nHere is the same interaction, explained:\n\n```\n  // The following reads 2 into t, 5 into n and 1 into c.\n  t, n, c = readline_int_list()\n  // The judge secretly picks the number of units for each pen:\n  // in test case 1: 2 0 4 1 3\n  // in test case 2: 1 3 2 4 0\n  // We write with the 4-th pen in test case 1, and with the 5-th pen in test case 2.\n  printline 4 5 to stdout\n  flush stdout\n  // Reads 1 0, as the 4-th pen in test case 1 still had ink left,\n  // but the 5-th pen in test case 2 did not.\n  a1, a2 = readline_int_list()\n  // We write with the 4-th pen in test case 1 again, and with the 3-rd pen in test case 2.\n  printline 4 3 to stdout\n  flush stdout\n  // Reads 0 1.\n  a1, a2 = readline_int_list()\n  // We only write in test case 2 this time, with the 2-nd pen.\n  printline 0 2 to stdout\n  flush stdout\n  // Reads 0 1.\n  a1, a2 = readline_int_list()\n  // We decide we are ready to answer.\n  printline 0 0 to stdout\n  flush stdout\n  // We take the 3-rd and the 4-th pens to the South Pole in both test cases.\n  printline 3 4 3 4 to stdout\n  flush stdout\n  // In test case 1, the remaining amounts in the 3-rd and the 4-th pens are 4 and 0, and 4+0<5,\n  // so we did not succeed.\n  // In test case 2, the remaining amounts in the 3-rd and the 4-th pens are 1 and 4, and 1+4≥5,\n  // so we succeeded.\n  // We have succeeded in 1 out of 2 test cases, which is good enough since c=1.\n  exit\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $\\mathbf{N} = 15$.\n\n**Test Set 1 (6 Pts, Visible Verdict)**\n\n- $\\mathbf{T} = 20000$.\n- $\\mathbf{C} = 10900$ ($\\mathbf{C} = 0.545 \\times \\mathbf{T}$).\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- $\\mathbf{T} = 20000$.\n- $\\mathbf{C} = 12000$ ($\\mathbf{C} = 0.6 \\times \\mathbf{T}$).\n\n**Test Set 3 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{T} = 100000$.\n- $\\mathbf{C} = 63600$ ($\\mathbf{C} = 0.636 \\times \\mathbf{T}$).", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #3] Pen Testing", "background": "", "description": "你有 $N$ 支圆珠笔。已知每支笔的墨水单位数都是 $0$ 到 $N-1$ 之间互不相同的整数，但这些笔是随机顺序给你的，因此你不知道哪支笔对应多少墨水。\n\n你即将前往南极（那里没有笔），而你的行李只能装两支笔。你知道需要写很多重要的明信片，因此选择的两支笔的墨水总量必须至少为 $N$ 单位。\n\n获取笔信息的唯一方法是选择一支笔尝试写字。尝试结果有两种：成功（该笔墨水减少 1 单位，可能用完）或失败（该笔已无墨水）。你可以重复测试同一支笔或不同笔。\n\n最终，你必须选择两支笔带去南极。若这两支笔剩余墨水的总量不少于 $N$ 单位，则视为成功。\n\n本题包含 $T$ 个测试用例，你需要在至少 $C$ 个用例中成功。注意本题所有测试集都是可见的。\n\n### 交互协议\n\n这是一个交互题。\n\n初始时，你的程序应读取一行包含三个整数 $\\mathbf{T}$、$\\mathbf{N}$ 和 $\\mathbf{C}$：测试用例数量、笔的数量和需要成功的最少用例数。（注意 $\\mathbf{N}$ 在所有测试集中相同，详见数据范围部分。）\n\n然后，你的程序需要同时处理所有 $\\mathbf{T}$ 个测试用例（这是为了减少交互次数）。交互以轮次进行。\n\n每轮开始时，你的程序需输出一行 $\\mathbf{T}$ 个整数：第 $i$ 个整数表示在第 $i$ 个测试用例中要测试的笔编号（1 到 $\\mathbf{N}$），若该轮不测试则输出 0。\n\n注意：如果在每个整数后立即刷新输出缓冲区（而非整行输出后刷新），可能导致超时错误。\n\n评测机将返回一行 $\\mathbf{T}$ 个整数：第 $i$ 个整数表示该轮第 $i$ 个测试用例的耗墨量。1 表示测试成功（耗墨 1 单位），0 表示测试失败（笔已无墨）或未测试。\n\n最多可进行 $\\mathbf{N} \\times (\\mathbf{N}+1)/2$ 轮交互（足以耗尽所有墨水）。\n\n当准备提交答案时，输出一行包含 $\\mathbf{T}$ 个 0。此行不计入交互轮次限制，评测机不会回复。\n\n接着输出一行 $2 \\times \\mathbf{T}$ 个整数：第 $(2i-1)$ 和第 $2i$ 个整数表示第 $i$ 个测试用例选择的两支笔编号。输出后程序应立即终止。\n\n若评测机收到意外输出，将返回 -1 并终止交互。程序需及时退出以避免超时错误。\n\n注意：每次提交时，笔的初始顺序都是独立随机生成的。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "**样例解释**\n\n交互过程解析：\n\n```\n// 读取 T=2, N=5, C=1\nt, n, c = readline_int_list()\n// 评测机秘密生成墨水分布：\n// 测试用例1: [2,0,4,1,3]\n// 测试用例2: [1,3,2,4,0]\n// 第一轮：测试用例1用笔4，测试用例2用笔5\nprintline 4 5\n// 返回1 0（笔4有墨，笔5无墨）\na1, a2 = readline_int_list()\n// 第二轮：测试用例1用笔4，测试用例2用笔3\nprintline 4 3\n// 返回0 1（笔4已无墨，笔3有墨）\na1, a2 = readline_int_list()\n// 第三轮：仅测试用例2用笔2\nprintline 0 2\n// 返回0 1\na1, a2 = readline_int_list()\n// 准备提交答案\nprintline 0 0\n// 选择笔3和笔4\nprintline 3 4 3 4\n// 测试用例1：4+0<5（失败）\n// 测试用例2：1+4≥5（成功）\n// 成功数1≥C，通过\nexit\n```\n\n可使用本地测试工具进行调试。建议配合[交互运行器](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)使用。注意测试工具与真实评测系统可能存在差异。\n\n**数据范围**\n\n- $\\mathbf{N} = 15$\n\n**测试集 1（6 分，可见判定）**\n\n- $\\mathbf{T} = 20000$\n- $\\mathbf{C} = 10900$（$\\mathbf{C} = 0.545 \\times \\mathbf{T}$）\n\n**测试集 2（11 分，可见判定）**\n\n- $\\mathbf{T} = 20000$\n- $\\mathbf{C} = 12000$（$\\mathbf{C} = 0.6 \\times \\mathbf{T}$）\n\n**测试集 3（15 分，可见判定）**\n\n- $\\mathbf{T} = 100000$\n- $\\mathbf{C} = 63600$（$\\mathbf{C} = 0.636 \\times \\mathbf{T}$）\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13069", "type": "P", "difficulty": 6, "samples": [["4\n2 4\n0 0\n5 0\n2 1\n0 0\n5 0\n2 4\n0 0\n4 4\n2 4\n0 0\n5 1", "Case #1: 27 119\nCase #2: 0 1\nCase #3: 0 1\nCase #4: 1 5"], ["1\n3 4\n0 0\n1 1\n2 3", "Case #1: 101 109"]], "limits": {"time": [20000, 20000, 60000, 120000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["2020", "线段树", "扫描线", "Google Code Jam"], "title": "[GCJ 2020 #3] Recalculating", "background": "", "description": "You are working for the Driverless Direct Delivery Drone Directions Design Division of Apricot Rules LLC. The company is about to take its first drone \"Principia\" to market. You are tasked with designing backup systems for Principia, in case it loses access to its primary geolocation systems (like GPS), but it still needs a way to get directions. Principia is designed for use on a flat region; formally, the region is a Cartesian plane in which the coordinates are in meters. One or more points on this plane are drone repair centers. No two drone repair centers are at the same location.\n\nPrincipia has a system that can retrieve the relative locations of drone repair centers that are within an $L_1$ distance (which is also known as Manhattan distance) of at most $\\mathbf{D}$ meters of its location. The information retrieved is a set of repair center locations relative to Principia's current location. For example: \"there is a repair center 4 meters north and 3.5 meters west, and another one 2.5 meters east\". Notice that the information does not identify repair centers; it gives their locations relative to Principia.\n\nYou quickly realized that there may be points on the map where this information may not be enough for Principia to uniquely determine its current location. This is because there might be two (or more) different points from which the information looks the same. Points with this property are called non-distinguishable, while all other points are called distinguishable.\n\nFormally, the information retrieved by Principia when located at point $(x, y)$ is $\\text{Info}(x, y) :=$ the set of all points $(z - x, w - y)$, where $(z, w)$ is the location of a repair center and $|z - x| + |w - y| \\leq \\mathbf{D}$. Here $|z - x|$ and $|w - y|$ denote the absolute values of $z - x$ and $w - y$, respectively. A point $(x_1, y_1)$ is non-distinguishable if and only if there exists another point $(x_2, y_2)$ such that $\\text{Info}(x_1, y_1) = \\text{Info}(x_2, y_2)$.\n\nFor example, suppose $\\mathbf{D} = 4$ and there are repair centers at points $(0, 0)$ and $(5, 0)$. The point $(0, 0)$ is non-distinguishable because $\\text{Info}(0, 0) = \\{(0, 0)\\} = \\text{Info}(5, 0)$. This means that point $(5, 0)$ is also non-distinguishable. On the other hand, $\\text{Info}(3.5, 0.1) = \\{(-3.5, -0.1), (1.5, -0.1)\\}$ is not equal to the information from any other point, which means that point $(3.5, 0.1)$ is distinguishable. The following picture illustrates the regions of distinguishable points (in red) and non-distinguishable points (in blue):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lejki1zk.png)\n\nPrincipia is deployed to a point that is chosen uniformly at random from the set of all points that are within $\\mathbf{D}$ meters (using $L_1$ distance) of at least one repair center — that is, the set of all points $(x, y)$ such that $\\text{Info}(x, y)$ is non-empty. The probability of that choice belonging to a given continuous set of points $S$ is proportional to the number of square meters of $S$'s area. In the example above, each red square has an area of 4.5 square meters, while each blue section has an area of 23 square meters. Therefore, the probability of Principia being deployed within each red square is $4.5 / (3 \\times 4.5 + 2 \\times 23)$ and the probability of it being deployed within each blue section is $23 / (3 \\times 4.5 + 2 \\times 23)$. Since the border between adjacent differently-colored sections has area equal to 0, the probability of Principia being deployed exactly on the border is exactly 0.\n\nGiven the locations of all repair centers, what is the probability that the point to which Principia is deployed is distinguishable?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{N}$ and $\\mathbf{D}$ representing (respectively) the number of repair centers and the maximum $L_1$ distance from which Principia can retrieve information from a repair center, as described above. Then, $\\mathbf{N}$ lines follow. The $i$-th of these contains two integers $\\mathbf{X_i}$ and $\\mathbf{Y_i}$ representing the coordinates of the $i$-th repair center. The unit of measurement for all coordinates and $\\mathbf{D}$ is meters.\n", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1) and $y$ and $z$ are non-negative integers. The fraction $y/z$ must represent the probability of Principia being at a distinguishable location, if one is chosen uniformly at random from all locations that are within $\\mathbf{D}$ meters of at least one repair center (using $L_1$ distance). If there are multiple acceptable values for $y$ and $z$, choose the one such that $z$ is minimized.", "hint": "**Sample Explanation**\n\nSample Test Set 1 meets the limits for Test Set 1. Another sample case that does not meet those limits could appear in any of the other test sets.\n\nSample Case #1 is described and depicted in the statement.\n\nThe points in the middle red region are all distinguishable points because they are the only points that retrieve information from both repair centers, and each point in that region retrieves a distinct set of information.\n\nThe points in the left and right red region each receive information from only one repair center, but that information is always unique, so these are all distinguishable points. For example, if Principia knows it is $3$ meters east of a repair center, it can be sure it is not $3$ meters east of the repair center at $(0, 0)$, because then it would have retrieved information from both repair centers. So it must be $3$ meters east of the repair center at $(5, 0)$.\n\nThe points in the blue regions are all non-distinguishable points. Choose any point in one of those regions, and consider the information that Principia would get from that point. It contains only the one repair center in range. But, there is a corresponding point in the other blue region from which Principia would get exactly the same information.\n\nAs explained above, the probability of Principia being deployed to one of the red sections is $4.5/59.5$, so the total probability of it being deployed to any of them is $3\\times 4.5/59.5 = 27/119$.\n\nThe following picture illustrates Sample Case #2. There is no way to retrieve information from more than one repair center, so every point close enough to one of them is non-distinguishable; the same information is retrieved from an equivalent point near the other one. Remember that $z$ (the denominator) must be minimal, so $0\\ 1$ is the only acceptable answer.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uxwv3yho.png)\n\nThe following picture illustrates Sample Case #3. Notice that the border between the two blue squares consists of distinguishable points. However, since its area is $0$, the probability of Principia being deployed there is $0$. All other points where Principia can be deployed are non-distinguishable.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sh8ma8rw.png)\n\nThe following picture illustrates Sample Case #4.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ibxhmn7j.png)\n\nThe following picture illustrates the additional case.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0hdmx3av.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D} \\leq 10^7$.\n- $-10^9 \\leq \\mathbf{X_i} \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y_i} \\leq 10^9$, for all $i$.\n- $(\\mathbf{X_i}, \\mathbf{Y_i}) \\neq (\\mathbf{X_j}, \\mathbf{Y_j})$ for all $i \\neq j$. (No two repair centers share the same location.)\n\n**Test Set 1 (6 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $\\mathbf{N} = 2$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- Time limit: 60 seconds.\n- $2 \\leq \\mathbf{N} \\leq 10$.\n\n**Test Set 3 (15 Pts, Visible Verdict)**\n\n- Time limit: 120 seconds.\n- For 6 cases, $\\mathbf{N} = 1687$.\n- For $\\mathbf{T}-6$ cases, $2 \\leq \\mathbf{N} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 #3] Recalculating", "background": "", "description": "You are working for the Driverless Direct Delivery Drone Directions Design Division of Apricot Rules LLC. The company is about to take its first drone \"Principia\" to market. You are tasked with designing backup systems for Principia, in case it loses access to its primary geolocation systems (like GPS), but it still needs a way to get directions. Principia is designed for use on a flat region; formally, the region is a Cartesian plane in which the coordinates are in meters. One or more points on this plane are drone repair centers. No two drone repair centers are at the same location.\n\nPrincipia has a system that can retrieve the relative locations of drone repair centers that are within an $L_1$ distance (which is also known as Manhattan distance) of at most $\\mathbf{D}$ meters of its location. The information retrieved is a set of repair center locations relative to Principia's current location. For example: \"there is a repair center 4 meters north and 3.5 meters west, and another one 2.5 meters east\". Notice that the information does not identify repair centers; it gives their locations relative to Principia.\n\nYou quickly realized that there may be points on the map where this information may not be enough for Principia to uniquely determine its current location. This is because there might be two (or more) different points from which the information looks the same. Points with this property are called non-distinguishable, while all other points are called distinguishable.\n\nFormally, the information retrieved by Principia when located at point $(x, y)$ is $\\text{Info}(x, y) :=$ the set of all points $(z - x, w - y)$, where $(z, w)$ is the location of a repair center and $|z - x| + |w - y| \\leq \\mathbf{D}$. Here $|z - x|$ and $|w - y|$ denote the absolute values of $z - x$ and $w - y$, respectively. A point $(x_1, y_1)$ is non-distinguishable if and only if there exists another point $(x_2, y_2)$ such that $\\text{Info}(x_1, y_1) = \\text{Info}(x_2, y_2)$.\n\nFor example, suppose $\\mathbf{D} = 4$ and there are repair centers at points $(0, 0)$ and $(5, 0)$. The point $(0, 0)$ is non-distinguishable because $\\text{Info}(0, 0) = \\{(0, 0)\\} = \\text{Info}(5, 0)$. This means that point $(5, 0)$ is also non-distinguishable. On the other hand, $\\text{Info}(3.5, 0.1) = \\{(-3.5, -0.1), (1.5, -0.1)\\}$ is not equal to the information from any other point, which means that point $(3.5, 0.1)$ is distinguishable. The following picture illustrates the regions of distinguishable points (in red) and non-distinguishable points (in blue):\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lejki1zk.png)\n\nPrincipia is deployed to a point that is chosen uniformly at random from the set of all points that are within $\\mathbf{D}$ meters (using $L_1$ distance) of at least one repair center — that is, the set of all points $(x, y)$ such that $\\text{Info}(x, y)$ is non-empty. The probability of that choice belonging to a given continuous set of points $S$ is proportional to the number of square meters of $S$'s area. In the example above, each red square has an area of 4.5 square meters, while each blue section has an area of 23 square meters. Therefore, the probability of Principia being deployed within each red square is $4.5 / (3 \\times 4.5 + 2 \\times 23)$ and the probability of it being deployed within each blue section is $23 / (3 \\times 4.5 + 2 \\times 23)$. Since the border between adjacent differently-colored sections has area equal to 0, the probability of Principia being deployed exactly on the border is exactly 0.\n\nGiven the locations of all repair centers, what is the probability that the point to which Principia is deployed is distinguishable?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{N}$ and $\\mathbf{D}$ representing (respectively) the number of repair centers and the maximum $L_1$ distance from which Principia can retrieve information from a repair center, as described above. Then, $\\mathbf{N}$ lines follow. The $i$-th of these contains two integers $\\mathbf{X_i}$ and $\\mathbf{Y_i}$ representing the coordinates of the $i$-th repair center. The unit of measurement for all coordinates and $\\mathbf{D}$ is meters.\n", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1) and $y$ and $z$ are non-negative integers. The fraction $y/z$ must represent the probability of Principia being at a distinguishable location, if one is chosen uniformly at random from all locations that are within $\\mathbf{D}$ meters of at least one repair center (using $L_1$ distance). If there are multiple acceptable values for $y$ and $z$, choose the one such that $z$ is minimized.", "hint": "**Sample Explanation**\n\nSample Test Set 1 meets the limits for Test Set 1. Another sample case that does not meet those limits could appear in any of the other test sets.\n\nSample Case #1 is described and depicted in the statement.\n\nThe points in the middle red region are all distinguishable points because they are the only points that retrieve information from both repair centers, and each point in that region retrieves a distinct set of information.\n\nThe points in the left and right red region each receive information from only one repair center, but that information is always unique, so these are all distinguishable points. For example, if Principia knows it is $3$ meters east of a repair center, it can be sure it is not $3$ meters east of the repair center at $(0, 0)$, because then it would have retrieved information from both repair centers. So it must be $3$ meters east of the repair center at $(5, 0)$.\n\nThe points in the blue regions are all non-distinguishable points. Choose any point in one of those regions, and consider the information that Principia would get from that point. It contains only the one repair center in range. But, there is a corresponding point in the other blue region from which Principia would get exactly the same information.\n\nAs explained above, the probability of Principia being deployed to one of the red sections is $4.5/59.5$, so the total probability of it being deployed to any of them is $3\\times 4.5/59.5 = 27/119$.\n\nThe following picture illustrates Sample Case #2. There is no way to retrieve information from more than one repair center, so every point close enough to one of them is non-distinguishable; the same information is retrieved from an equivalent point near the other one. Remember that $z$ (the denominator) must be minimal, so $0\\ 1$ is the only acceptable answer.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uxwv3yho.png)\n\nThe following picture illustrates Sample Case #3. Notice that the border between the two blue squares consists of distinguishable points. However, since its area is $0$, the probability of Principia being deployed there is $0$. All other points where Principia can be deployed are non-distinguishable.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sh8ma8rw.png)\n\nThe following picture illustrates Sample Case #4.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ibxhmn7j.png)\n\nThe following picture illustrates the additional case.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0hdmx3av.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{D} \\leq 10^7$.\n- $-10^9 \\leq \\mathbf{X_i} \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y_i} \\leq 10^9$, for all $i$.\n- $(\\mathbf{X_i}, \\mathbf{Y_i}) \\neq (\\mathbf{X_j}, \\mathbf{Y_j})$ for all $i \\neq j$. (No two repair centers share the same location.)\n\n**Test Set 1 (6 Pts, Visible Verdict)**\n\n- Time limit: 20 seconds.\n- $\\mathbf{N} = 2$.\n\n**Test Set 2 (11 Pts, Visible Verdict)**\n\n- Time limit: 60 seconds.\n- $2 \\leq \\mathbf{N} \\leq 10$.\n\n**Test Set 3 (15 Pts, Visible Verdict)**\n\n- Time limit: 120 seconds.\n- For 6 cases, $\\mathbf{N} = 1687$.\n- For $\\mathbf{T}-6$ cases, $2 \\leq \\mathbf{N} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 #3] Recalculating", "background": "", "description": "你为 Apricot Rules LLC 公司的**无人驾驶直送无人机导航设计部**工作。公司即将推出首款无人机\"Principia\"，你需要为其设计备用导航系统，以防其失去主要定位系统（如 GPS）后仍能获取方向指引。Principia 设计用于平面区域，该区域被建模为笛卡尔坐标系（单位为米），坐标系中分布着一个或多个无人机维修中心，且任意两个维修中心位置不同。\n\nPrincipia 配备的系统可获取其当前位置 $L_1$ 距离（曼哈顿距离）不超过 $\\mathbf{D}$ 米范围内的维修中心相对位置信息。例如：\"有一个维修中心在正北 4 米、正西 3.5 米处，另一个在正东 2.5 米处\"。注意这些信息不标识具体维修中心，仅提供相对于 Principia 的位置。\n\n你很快意识到，地图上可能存在某些点无法通过这些信息唯一确定当前位置，因为不同位置可能产生相同的相对信息集。这类点称为**不可区分点**，其余点称为**可区分点**。\n\n形式化定义：当 Principia 位于 $(x, y)$ 时，获取的信息 $\\text{Info}(x, y)$ 是所有满足 $|z - x| + |w - y| \\leq \\mathbf{D}$ 的维修中心坐标 $(z, w)$ 对应的相对位置 $(z - x, w - y)$ 的集合。若存在另一个点 $(x_2, y_2)$ 使得 $\\text{Info}(x_1, y_1) = \\text{Info}(x_2, y_2)$，则 $(x_1, y_1)$ 是不可区分点。\n\n例如：设 $\\mathbf{D} = 4$，维修中心位于 $(0, 0)$ 和 $(5, 0)$。点 $(0, 0)$ 不可区分，因为 $\\text{Info}(0, 0) = \\{(0, 0)\\} = \\text{Info}(5, 0)$。而 $(3.5, 0.1)$ 是可区分点，因其信息集 $\\{(-3.5, -0.1), (1.5, -0.1)\\}$ 唯一。下图展示了可区分点（红色）与不可区分点（蓝色）的分布：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lejki1zk.png)\n\nPrincipia 的部署位置从所有满足 $\\text{Info}(x, y)$ 非空的点中均匀随机选择。连续点集 $S$ 的被选概率与其面积（平方米）成正比。上例中每个红色区域面积为 4.5 平方米，蓝色区域为 23 平方米，因此部署到红色区域的概率为 $4.5 / (3 \\times 4.5 + 2 \\times 23)$，蓝色区域为 $23 / (3 \\times 4.5 + 2 \\times 23)$。边界区域面积为 0，被选概率严格为 0。\n\n给定所有维修中心坐标，求 Principia 被部署到可区分点的概率。", "inputFormat": "第一行输入测试用例数 $\\mathbf{T}$。每个测试用例包含：\n- 两个整数 $\\mathbf{N}$（维修中心数量）和 $\\mathbf{D}$（最大 $L_1$ 距离）\n- $\\mathbf{N}$ 行，每行两个整数 $\\mathbf{X_i}, \\mathbf{Y_i}$ 表示维修中心坐标（单位：米）", "outputFormat": "对每个测试用例，输出 `Case #x: y z`，其中 $y/z$ 为最简分数形式的概率（$z$ 取最小可能值）。\n", "hint": "**样例解释**\n\n样例测试集 1 符合测试集 1 的限制条件。其他不符合该限制的样例可能出现在任意其他测试集中。\n\n样例 #1 已在题目描述中详细说明并配有图示。\n\n中间红色区域的所有点都是可区分点，因为它们是唯一能同时获取两个维修中心信息的点，且该区域内每个点获取的信息集都是唯一的。\n\n左右两侧红色区域的点各自只能获取一个维修中心的信息，但这些信息始终是唯一的，因此也都是可区分点。例如，若 Principia 知道自己在某个维修中心东侧 $3$ 米处，可以确定这不是 $(0, 0)$ 维修中心的东侧 $3$ 米（否则会同时获取两个维修中心的信息），因此必定是 $(5, 0)$ 维修中心的东侧 $3$ 米。\n\n蓝色区域的所有点都是不可区分点。任选其中一个区域内的点，Principia 获取的信息仅包含范围内单个维修中心的数据，但在另一个蓝色区域存在对应点会生成完全相同的信息集。\n\n如前所述，Principia 部署到单个红色区域的概率为 $4.5/59.5$，因此部署到任意红色区域的总概率为 $3\\times 4.5/59.5 = 27/119$。\n\n下图展示样例 #2。由于无法获取超过一个维修中心的信息，所有靠近维修中心的点都是不可区分的——从另一个维修中心附近的对应点会获取完全相同的信息。注意分母 $z$ 必须取最小值，因此 $0\\ 1$ 是唯一可接受的答案。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uxwv3yho.png)\n\n下图展示样例 #3。注意两个蓝色方形交界处的边界点属于可区分点，但由于其面积为 $0$，被部署到该处的概率为 $0$。其余所有可部署点都是不可区分的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sh8ma8rw.png)\n\n下图展示样例 #4。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ibxhmn7j.png)\n\n下图展示附加测试用例。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0hdmx3av.png)\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$\n- $1 \\leq \\mathbf{D} \\leq 10^7$\n- 对所有 $i$，$-10^9 \\leq \\mathbf{X_i} \\leq 10^9$\n- 对所有 $i$，$-10^9 \\leq \\mathbf{Y_i} \\leq 10^9$\n- 对所有 $i \\neq j$，$(\\mathbf{X_i}, \\mathbf{Y_i}) \\neq (\\mathbf{X_j}, \\mathbf{Y_j})$（任意两个维修中心位置不同）\n\n**测试集 1（6 分，可见判定）**\n\n- 时间限制：20 秒\n- $\\mathbf{N} = 2$\n\n**测试集 2（11 分，可见判定）**\n\n- 时间限制：60 秒\n- $2 \\leq \\mathbf{N} \\leq 10$\n\n**测试集 3（15 分，可见判定）**\n\n- 时间限制：120 秒\n- 其中 6 个用例 $\\mathbf{N} = 1687$\n- 其余 $\\mathbf{T}-6$ 个用例 $2 \\leq \\mathbf{N} \\leq 100$\n\n翻译由 DeepSeek V3 完成\n", "locale": "zh-CN"}}}
{"pid": "P13070", "type": "P", "difficulty": 5, "samples": [["2\n4\n1 2 2 5\n1 3 2 5\n3 4 1 -2\n7\n4 7 2 2\n1 3 5 5\n1 4 2 -1\n3 2 3 -2\n3 5 2 -1\n3 6 2 2", "Case #1: 4 18\nCase #2: 7 15"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "2020", "线段树", "树链剖分", "启发式合并", "Google Code Jam"], "title": "[GCJ 2020 Finals] Pack the Slopes", "background": "", "description": "You are trying to organize a group of skiers. The skiers are taking a trip to a large mountain, which has been rented for the day.\n\nThere are $\\mathbf{N}$ rest points numbered from 1 to $\\mathbf{N}$ on the mountain, and they are connected by $\\mathbf{N}-1$ slopes. Each slope starts at some rest point and goes directly to another rest point, with no intermediate slopes or rest points. A slope can be traversed in only one direction.\n\nEach skier starts at the summit rest point and traverses a slope to reach another rest point. From there, the skier can traverse another slope to reach another rest point, and so on. Once a skier reaches their destination rest point, they stop skiing for the day and head to the ski lodge for hot cocoa. The destination rest point cannot be the summit rest point. However, notice that a skier's destination rest point can be the start of zero or more slopes; that is, a skier does not necessarily have to keep using available slopes until there are none available: they can always walk carefully down the rest of the mountain! For all rest points, there is exactly one sequence of slopes that a skier can use to reach it from the summit rest point.\n\nEach slope can accommodate only a certain total number of skiers in a day, after which the snow gets too choppy to ski. In addition, the ski resort can charge or reward each skier for each slope that they ski on. Each slope may have a different price, and each skier must pay the price for each slope they ski on. A slope's price can be positive, zero, or even negative; a negative price represents a bounty awarded for testing that slope. As the organizer, you pay all the slope prices and collect all the bounties on behalf of your group of skiers. Notice that if multiple skiers use the same slope, you pay that slope's price or collect the slope's bounty multiple times. The sum of all costs you pay minus the sum of all bounties you collect is the total expense for the trip. The expense can be positive, zero, or negative. A negative expense means that you actually made money on the trip!\n\nAs the organizer, you want to figure out the maximum number of skiers that you can put on the mountain. Also, you would like to figure out the minimum possible expense for a trip with that maximum number of skiers.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains a single integer $\\mathbf{N}$: the number of rest points on the mountain.\n\nEach of the final $\\mathbf{N}-1$ lines of a test case describes a slope via four integers $\\mathbf{U_i}$, $\\mathbf{V_i}$, $\\mathbf{S_i}$, and $\\mathbf{C_i}$. These are the slope's starting rest point, the slope's ending rest point, the maximum number of skiers the slope can accommodate, and the slope's price per skier, respectively.\n\nThe summit rest point where the skiers start from is always numbered 1.", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), $y$ is the maximum number of skiers, and $z$ is the minimum expense for having $y$ skiers ski at least one slope each.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we can send one skier to rest point 4, one skier to rest point 3, and two skiers to rest point 2.\n\nIn Sample Case #2, we can send three skiers to rest point 2, two skiers to rest point 5, and two skiers to rest point 4.\n\nNotice that the first slope listed in a test case does not need to start at the summit rest point, and that slopes can have $\\mathbf{U_i} > \\mathbf{V_i}$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{U_i} \\leqslant \\mathbf{N}$, for all $i$.\n- $2 \\leqslant \\mathbf{V_i} \\leqslant \\mathbf{N}$, for all $i$. (No slope can end at the summit rest point.)\n- $\\mathbf{U_i} \\neq \\mathbf{V_i}$, for all $i$.\n- $1 \\leqslant \\mathbf{S_i} \\leqslant 10^5$, for all $i$.\n- $-10^5 \\leqslant \\mathbf{C_i} \\leqslant 10^5$, for all $i$.\n- There is exactly one sequence of slopes that a skier can use to reach rest point $r$ from the summit rest point, for all $r$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $2 \\leqslant \\mathbf{N} \\leqslant 1000$.\n\n**Test Set 2 (22 Pts, Hidden Verdict)**\n\n- $\\mathbf{T} = 17$.\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Finals] Pack the Slopes", "background": "", "description": "You are trying to organize a group of skiers. The skiers are taking a trip to a large mountain, which has been rented for the day.\n\nThere are $\\mathbf{N}$ rest points numbered from 1 to $\\mathbf{N}$ on the mountain, and they are connected by $\\mathbf{N}-1$ slopes. Each slope starts at some rest point and goes directly to another rest point, with no intermediate slopes or rest points. A slope can be traversed in only one direction.\n\nEach skier starts at the summit rest point and traverses a slope to reach another rest point. From there, the skier can traverse another slope to reach another rest point, and so on. Once a skier reaches their destination rest point, they stop skiing for the day and head to the ski lodge for hot cocoa. The destination rest point cannot be the summit rest point. However, notice that a skier's destination rest point can be the start of zero or more slopes; that is, a skier does not necessarily have to keep using available slopes until there are none available: they can always walk carefully down the rest of the mountain! For all rest points, there is exactly one sequence of slopes that a skier can use to reach it from the summit rest point.\n\nEach slope can accommodate only a certain total number of skiers in a day, after which the snow gets too choppy to ski. In addition, the ski resort can charge or reward each skier for each slope that they ski on. Each slope may have a different price, and each skier must pay the price for each slope they ski on. A slope's price can be positive, zero, or even negative; a negative price represents a bounty awarded for testing that slope. As the organizer, you pay all the slope prices and collect all the bounties on behalf of your group of skiers. Notice that if multiple skiers use the same slope, you pay that slope's price or collect the slope's bounty multiple times. The sum of all costs you pay minus the sum of all bounties you collect is the total expense for the trip. The expense can be positive, zero, or negative. A negative expense means that you actually made money on the trip!\n\nAs the organizer, you want to figure out the maximum number of skiers that you can put on the mountain. Also, you would like to figure out the minimum possible expense for a trip with that maximum number of skiers.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains a single integer $\\mathbf{N}$: the number of rest points on the mountain.\n\nEach of the final $\\mathbf{N}-1$ lines of a test case describes a slope via four integers $\\mathbf{U_i}$, $\\mathbf{V_i}$, $\\mathbf{S_i}$, and $\\mathbf{C_i}$. These are the slope's starting rest point, the slope's ending rest point, the maximum number of skiers the slope can accommodate, and the slope's price per skier, respectively.\n\nThe summit rest point where the skiers start from is always numbered 1.", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), $y$ is the maximum number of skiers, and $z$ is the minimum expense for having $y$ skiers ski at least one slope each.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we can send one skier to rest point 4, one skier to rest point 3, and two skiers to rest point 2.\n\nIn Sample Case #2, we can send three skiers to rest point 2, two skiers to rest point 5, and two skiers to rest point 4.\n\nNotice that the first slope listed in a test case does not need to start at the summit rest point, and that slopes can have $\\mathbf{U_i} > \\mathbf{V_i}$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{U_i} \\leqslant \\mathbf{N}$, for all $i$.\n- $2 \\leqslant \\mathbf{V_i} \\leqslant \\mathbf{N}$, for all $i$. (No slope can end at the summit rest point.)\n- $\\mathbf{U_i} \\neq \\mathbf{V_i}$, for all $i$.\n- $1 \\leqslant \\mathbf{S_i} \\leqslant 10^5$, for all $i$.\n- $-10^5 \\leqslant \\mathbf{C_i} \\leqslant 10^5$, for all $i$.\n- There is exactly one sequence of slopes that a skier can use to reach rest point $r$ from the summit rest point, for all $r$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $2 \\leqslant \\mathbf{N} \\leqslant 1000$.\n\n**Test Set 2 (22 Pts, Hidden Verdict)**\n\n- $\\mathbf{T} = 17$.\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Finals] Pack the Slopes", "background": "", "description": "你正在组织一群滑雪者。滑雪者们将前往一座被全天租用的大型雪山。\n\n雪山上有编号为 $1$ 到 $\\mathbf{N}$ 的 $\\mathbf{N}$ 个休息点，它们通过 $\\mathbf{N}-1$ 条滑雪道相连。每条滑雪道从一个休息点出发，直接通向另一个休息点，中途没有其他滑雪道或休息点。滑雪道只能单向通行。\n\n每位滑雪者从山顶休息点（编号 $1$）出发，沿一条滑雪道到达另一个休息点。之后，滑雪者可以继续沿另一条滑雪道前往下一个休息点，以此类推。当滑雪者到达目标休息点时，他们会结束当天的滑雪并前往滑雪小屋享用热可可。目标休息点不能是山顶休息点。但注意，滑雪者的目标休息点可以是零条或多条滑雪道的起点——即滑雪者不一定要用完所有可用滑雪道：他们可以小心地步行下山！对于所有休息点，从山顶休息点出发到达它的滑雪道序列是唯一的。\n\n每条滑雪道每天仅能容纳一定数量的滑雪者，超过后雪道会因积雪过乱而无法使用。此外，滑雪场会根据滑雪者使用的每条滑雪道收取费用或发放奖励。每条滑雪道的价格可能不同，每位滑雪者需支付其使用的每条滑雪道的价格。价格可以是正数、零甚至负数（负数代表测试该滑雪道的奖励）。作为组织者，你需要代表滑雪者支付所有费用并收取所有奖励。注意，若多名滑雪者使用同一条滑雪道，该滑雪道的费用或奖励会被多次计算。你$ $支付的总费用减去收取的总奖励即为本次旅行的总支出。支出可能为正、零或负（负支出表示你实际上赚了钱）。\n\n作为组织者，你需要计算能安排到雪山上的最大滑雪者数量，并求出在该最大数量下的最小可能支出。", "inputFormat": "输入第一行给出测试用例数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含一个整数 $\\mathbf{N}$，表示雪山上的休息点数量。\n\n接下来的 $\\mathbf{N}-1$ 行每行描述一条滑雪道，包含四个整数 $\\mathbf{U_i}$、$\\mathbf{V_i}$、$\\mathbf{S_i}$ 和 $\\mathbf{C_i}$，分别表示滑雪道的起点休息点、终点休息点、最大承载滑雪者数量以及每位滑雪者的使用价格。\n\n山顶休息点（滑雪者起点）始终编号为 $1$。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y z`，其中 $x$ 为测试用例编号（从 $1$ 开始），$y$ 为最大滑雪者数量，$z$ 为安排 $y$ 名滑雪者（每人至少使用一条滑雪道）的最小支出。\n", "hint": "**样例解释**\n\n在样例 #1 中，可以安排 $1$ 名滑雪者前往休息点 $4$，$1$ 名前往休息点 $3$，$2$ 名前往休息点 $2$。\n\n在样例 #2 中，可以安排 $3$ 名滑雪者前往休息点 $2$，$2$ 名前往休息点 $5$，$2$ 名前往休息点 $4$。\n\n注意：测试用例中第一条滑雪道的起点不一定是山顶休息点，且可能存在 $\\mathbf{U_i} > \\mathbf{V_i}$ 的情况。\n\n**数据范围**\n\n- 对所有 $i$，满足 $1 \\leqslant \\mathbf{U_i} \\leqslant \\mathbf{N}$。\n- 对所有 $i$，满足 $2 \\leqslant \\mathbf{V_i} \\leqslant \\mathbf{N}$（没有滑雪道以山顶休息点为终点）。\n- 对所有 $i$，满足 $\\mathbf{U_i} \\neq \\mathbf{V_i}$。\n- 对所有 $i$，满足 $1 \\leqslant \\mathbf{S_i} \\leqslant 10^5$。\n- 对所有 $i$，满足 $-10^5 \\leqslant \\mathbf{C_i} \\leqslant 10^5$。\n- 对所有休息点 $r$，从山顶休息点到 $r$ 的滑雪道序列唯一。\n\n**测试集 1（10 分，可见判定）**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $2 \\leqslant \\mathbf{N} \\leqslant 1000$。\n\n**测试集 2（22 分，隐藏判定）**\n\n- $\\mathbf{T} = 17$。\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13071", "type": "P", "difficulty": 6, "samples": [["3\n6\n2 2\n3 5\n4 3\n6 6\n1 4\n5 1\n4\n4 1\n1 3\n3 4\n2 2\n4\n3 1\n2 2\n4 3\n1 4", "Case #1: 2 1\nCase #2: 0 0\nCase #3: 0 0"]], "limits": {"time": [40000, 40000, 40000], "memory": [1048576, 1048576, 1048576]}, "tags": ["博弈论", "2020", "记忆化搜索", "Google Code Jam"], "title": "[GCJ 2020 Finals] Adjacent and Consecutive", "background": "", "description": "Two players, A and B, are playing a game. The game uses $\\mathbf{N}$ tiles numbered 1 through $\\mathbf{N}$, and a board consisting of a single horizontal row of $\\mathbf{N}$ empty cells.\n\nPlayers alternate turns, with Player A going first. On a turn, a player picks an unused tile and an empty cell and places the tile in the cell. At the end of the game, Player A wins if there are two tiles with consecutive numbers in adjacent cells (regardless of who put them there). Otherwise, Player B wins. For example, final boards of 1 2 3 4 and 4 1 3 2 are examples of wins for Player A, and a final board of 3 1 4 2 is an example of a win for Player B. (Notice that consecutive numbers may appear in either order.)\n\nYou just watched two players play a game, but you could not understand their strategy. They may not have played rationally! You decide to compare their moves against an optimal strategy.\n\nA winning state is a state of the game from which the player whose turn it is can guarantee a win if they play optimally, regardless of what the opponent does. A mistake is a move made while in a winning state that results in the opponent having a winning state on their next turn. (Notice that it is not possible to make a mistake on the last turn of the game, since if the last turn begins with a winning state for that player, it must be because that player's only move results in a win.)\n\nGiven the $\\mathbf{N}$ moves, count the number of mistakes made by each player.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line containing an integer $\\mathbf{N}$: the number of tiles in the game (which is also the number of turns, and the number of cells on the board).\n\nThen, $\\mathbf{N}$ more lines follow. The $i$-th of these (counting starting from 1) has two integers $\\mathbf{M_i}$ and $\\mathbf{C_i}$. Respectively, these represent the tile chosen on the $i$-th turn, and the index of the cell (counting from 1 at the left end to $\\mathbf{N}$ at the right end) where that tile is placed.\n\nNote that it is Player A's turn whenever $i$ is odd, and Player B's turn whenever $i$ is even.", "outputFormat": "For each test case, output one line containing `Case #x: a b`, where $x$ is the test case number (starting from 1), $a$ is the total number of mistakes made by Player A, and $b$ is the total number of mistakes made by Player B.", "hint": "**Sample Explanation**\n\nNotice that any game always begins in a winning state for Player A. For example, Player A can play tile 2 in cell 2 (i.e. the second cell from the left). No matter what Player B does on their turn, at least one of tiles 1 and 3 will be unused, and at least one of cells 1 and 3 will be empty. Then Player A can play one of those tiles in one of those cells, and this secures a win for Player A regardless of what happens in the rest of the game.\n\nIn Sample Case #1, the game plays out as follows:\n\n* _ _ _ _ _ _. This is a winning state for Player A, as explained above.\n* Turn 1: Player A plays tile 2 in cell 2.\n* _ 2 _ _ _ _. This is not a winning state for Player B, as explained above; Player B cannot guarantee a win, regardless of their remaining choices in the game.\n* Turn 2: Player B plays tile 3 in cell 5.\n* _ 2 _ _ 3 _. This is a winning state for Player A; for example, they could play tile 1 in cell 3.\n* Turn 3: Player A plays tile 4 in cell 3.\n* _ 2 4 _ 3 _. This is a winning state for Player B; for example, they could play tile 5 in cell 1, and then they would be guaranteed to win no matter what Player A did. So Player A's last move was a mistake!\n* Turn 4: Player B plays tile 6 in cell 6.\n* _ 2 4 _ 3 6. This is a winning state for Player A, since Player A could play tile 1 in cell 1. So Player B's last move was a mistake!\n* Turn 5: Player A plays tile 1 in cell 4.\n* _ 2 4 1 3 6. This is a winning state for Player B, so Player A's last move was a mistake!\n* Turn 6: Player B plays tile 5 in cell 1.\n* 5 2 4 1 3 6. The game is over, and Player B has won.\n\nIn total, Player A made 2 mistakes and Player B made 1 mistake.\n\nIn Sample Case #2, although some of the moves may look risky, neither player made a mistake as defined in this problem. Player A never gave up a winning state to Player B, and Player B had no opportunity to make a mistake because they were never in a winning state.\n\nIn Sample Case #3, notice that even though the outcome of the game is determined after the second move (since that move creates a pair of adjacent and consecutive tiles), all tiles must be placed in each game. Moreover, although the second move assures Player A's victory, it is not a mistake for Player B because Player B was not in a winning state at the time.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $1 \\leq M_i \\leq N,$ for all $i.$\n- $M_i \\neq M_j,$ for all $i \\neq j.$\n- $1 \\leq C_i \\leq N,$ for all $i.$\n- $C_i \\neq C_j,$ for all $i \\neq j.$\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $4 \\leq N \\leq 10.$\n\n**Test Set 2 (32 Pts, Hidden Verdict)**\n\n- $4 \\leq N \\leq 50.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Finals] Adjacent and Consecutive", "background": "", "description": "Two players, A and B, are playing a game. The game uses $\\mathbf{N}$ tiles numbered 1 through $\\mathbf{N}$, and a board consisting of a single horizontal row of $\\mathbf{N}$ empty cells.\n\nPlayers alternate turns, with Player A going first. On a turn, a player picks an unused tile and an empty cell and places the tile in the cell. At the end of the game, Player A wins if there are two tiles with consecutive numbers in adjacent cells (regardless of who put them there). Otherwise, Player B wins. For example, final boards of 1 2 3 4 and 4 1 3 2 are examples of wins for Player A, and a final board of 3 1 4 2 is an example of a win for Player B. (Notice that consecutive numbers may appear in either order.)\n\nYou just watched two players play a game, but you could not understand their strategy. They may not have played rationally! You decide to compare their moves against an optimal strategy.\n\nA winning state is a state of the game from which the player whose turn it is can guarantee a win if they play optimally, regardless of what the opponent does. A mistake is a move made while in a winning state that results in the opponent having a winning state on their next turn. (Notice that it is not possible to make a mistake on the last turn of the game, since if the last turn begins with a winning state for that player, it must be because that player's only move results in a win.)\n\nGiven the $\\mathbf{N}$ moves, count the number of mistakes made by each player.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line containing an integer $\\mathbf{N}$: the number of tiles in the game (which is also the number of turns, and the number of cells on the board).\n\nThen, $\\mathbf{N}$ more lines follow. The $i$-th of these (counting starting from 1) has two integers $\\mathbf{M_i}$ and $\\mathbf{C_i}$. Respectively, these represent the tile chosen on the $i$-th turn, and the index of the cell (counting from 1 at the left end to $\\mathbf{N}$ at the right end) where that tile is placed.\n\nNote that it is Player A's turn whenever $i$ is odd, and Player B's turn whenever $i$ is even.", "outputFormat": "For each test case, output one line containing `Case #x: a b`, where $x$ is the test case number (starting from 1), $a$ is the total number of mistakes made by Player A, and $b$ is the total number of mistakes made by Player B.", "hint": "**Sample Explanation**\n\nNotice that any game always begins in a winning state for Player A. For example, Player A can play tile 2 in cell 2 (i.e. the second cell from the left). No matter what Player B does on their turn, at least one of tiles 1 and 3 will be unused, and at least one of cells 1 and 3 will be empty. Then Player A can play one of those tiles in one of those cells, and this secures a win for Player A regardless of what happens in the rest of the game.\n\nIn Sample Case #1, the game plays out as follows:\n\n* _ _ _ _ _ _. This is a winning state for Player A, as explained above.\n* Turn 1: Player A plays tile 2 in cell 2.\n* _ 2 _ _ _ _. This is not a winning state for Player B, as explained above; Player B cannot guarantee a win, regardless of their remaining choices in the game.\n* Turn 2: Player B plays tile 3 in cell 5.\n* _ 2 _ _ 3 _. This is a winning state for Player A; for example, they could play tile 1 in cell 3.\n* Turn 3: Player A plays tile 4 in cell 3.\n* _ 2 4 _ 3 _. This is a winning state for Player B; for example, they could play tile 5 in cell 1, and then they would be guaranteed to win no matter what Player A did. So Player A's last move was a mistake!\n* Turn 4: Player B plays tile 6 in cell 6.\n* _ 2 4 _ 3 6. This is a winning state for Player A, since Player A could play tile 1 in cell 1. So Player B's last move was a mistake!\n* Turn 5: Player A plays tile 1 in cell 4.\n* _ 2 4 1 3 6. This is a winning state for Player B, so Player A's last move was a mistake!\n* Turn 6: Player B plays tile 5 in cell 1.\n* 5 2 4 1 3 6. The game is over, and Player B has won.\n\nIn total, Player A made 2 mistakes and Player B made 1 mistake.\n\nIn Sample Case #2, although some of the moves may look risky, neither player made a mistake as defined in this problem. Player A never gave up a winning state to Player B, and Player B had no opportunity to make a mistake because they were never in a winning state.\n\nIn Sample Case #3, notice that even though the outcome of the game is determined after the second move (since that move creates a pair of adjacent and consecutive tiles), all tiles must be placed in each game. Moreover, although the second move assures Player A's victory, it is not a mistake for Player B because Player B was not in a winning state at the time.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $1 \\leq M_i \\leq N,$ for all $i.$\n- $M_i \\neq M_j,$ for all $i \\neq j.$\n- $1 \\leq C_i \\leq N,$ for all $i.$\n- $C_i \\neq C_j,$ for all $i \\neq j.$\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $4 \\leq N \\leq 10.$\n\n**Test Set 2 (32 Pts, Hidden Verdict)**\n\n- $4 \\leq N \\leq 50.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Finals] Adjacent and Consecutive", "background": "", "description": "两名玩家 A 和 B 正在玩一个游戏。游戏使用编号为 $1$ 到 $\\mathbf{N}$ 的 $\\mathbf{N}$ 个方块，以及一个由 $\\mathbf{N}$ 个空格组成的水平排列的游戏板。\n\n玩家轮流行动，玩家 A 先手。每回合，玩家选择一个未被使用的方块和一个空格，并将该方块放入空格中。游戏结束时，如果存在两个**相邻**的格子中的方块编号是**连续**的（无论顺序如何，例如 $1$ 和 $2$ 或 $2$ 和 $1$），则玩家 A 获胜；否则玩家 B 获胜。例如，最终游戏板为 $1\\ 2\\ 3\\ 4$ 或 $4\\ 1\\ 3\\ 2$ 时玩家 A 获胜，而 $3\\ 1\\ 4\\ 2$ 时玩家 B 获胜。\n\n你刚刚观看了一局游戏，但无法理解他们的策略（他们可能没有采用最优策略）。现在，你需要将他们的操作与最优策略进行对比。\n\n**必胜状态** 是指当前回合的玩家在采取最优策略后，无论对手如何应对，都能确保自己最终获胜的游戏状态。**失误** 是指玩家在处于必胜状态时，做出了一个导致对手在下一回合进入必胜状态的操作（注意：游戏的最后一回合不可能出现失误，因为如果最后一回合开始时玩家处于必胜状态，那么他的唯一操作必然直接获胜）。\n\n给定 $\\mathbf{N}$ 个操作，计算每名玩家的失误次数。", "inputFormat": "输入第一行给出测试用例数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含一个整数 $\\mathbf{N}$，表示游戏中的方块数量（也是回合数和游戏板的格子数）。\n\n接下来的 $\\mathbf{N}$ 行，第 $i$ 行（从 $1$ 开始计数）包含两个整数 $\\mathbf{M_i}$ 和 $\\mathbf{C_i}$，分别表示第 $i$ 回合选择的方块编号和放置的格子索引（$1$ 表示最左端，$\\mathbf{N}$ 表示最右端）。\n\n注意：当 $i$ 为奇数时是玩家 A 的回合，偶数时是玩家 B 的回合。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: a b`，其中 $x$ 为测试用例编号（从 $1$ 开始），$a$ 是玩家 A 的失误总数，$b$ 是玩家 B 的失误总数。\n", "hint": "**样例解释**\n\n任何游戏的初始状态都是玩家 A 的必胜状态。例如，玩家 A 可以将方块 $2$ 放在格子 $2$（从左数第二个格子）。无论玩家 B 如何应对，至少方块 $1$ 或 $3$ 未被使用，且格子 $1$ 或 $3$ 为空。之后，玩家 A 可以将其中一个方块放入其中一个格子，从而确保自己最终获胜。\n\n在样例 #1 中，游戏过程如下：\n\n* _ _ _ _ _ _（初始状态，玩家 A 必胜）。\n* 回合 1：玩家 A 将方块 $2$ 放入格子 $2$。\n* _ 2 _ _ _ _（玩家 B 无法确保必胜）。\n* 回合 2：玩家 B 将方块 $3$ 放入格子 $5$。\n* _ 2 _ _ 3 _（玩家 A 仍可必胜，例如将方块 $1$ 放入格子 $3$）。\n* 回合 3：玩家 A 将方块 $4$ 放入格子 $3$。\n* _ 2 4 _ 3 _（此时玩家 B 进入必胜状态，例如下一步可将方块 $5$ 放入格子 $1$，确保最终获胜。因此玩家 A 的这一步是失误！）。\n* 回合 4：玩家 B 将方块 $6$ 放入格子 $6$。\n* _ 2 4 _ 3 6（玩家 A 可必胜，例如将方块 $1$ 放入格子 $1$。因此玩家 B 的这一步是失误！）。\n* 回合 5：玩家 A 将方块 $1$ 放入格子 $4$。\n* _ 2 4 1 3 6（玩家 B 进入必胜状态，因此玩家 A 的这一步是失误！）。\n* 回合 6：玩家 B 将方块 $5$ 放入格子 $1$。\n* 5 2 4 1 3 6（游戏结束，玩家 B 获胜）。\n\n总计：玩家 A 失误 $2$ 次，玩家 B 失误 $1$ 次。\n\n在样例 #2 中，尽管某些操作看起来有风险，但根据题目定义，双方均未失误。玩家 A 从未让玩家 B 进入必胜状态，而玩家 B 也从未有机会失误（因为他们从未处于必胜状态）。\n\n在样例 #3 中，尽管第二回合后游戏结果已确定（因为该操作创造了相邻连续的方块对），但游戏仍需放置所有方块。此外，虽然第二步确保了玩家 A 的胜利，但玩家 B 并未失误，因为当时玩家 B 并不处于必胜状态。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- 对所有 $i$，$1 \\leq M_i \\leq N$。\n- 对所有 $i \\neq j$，$M_i \\neq M_j$。\n- 对所有 $i$，$1 \\leq C_i \\leq N$。\n- 对所有 $i \\neq j$，$C_i \\neq C_j$。\n\n**测试集 1（10 分，可见判定）**\n\n- $4 \\leq N \\leq 10$。\n\n**测试集 2（32 分，隐藏判定）**\n\n- $4 \\leq N \\leq 50$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13072", "type": "P", "difficulty": 7, "samples": [["4\n2 2\n10 10\n00 FF\n2 2\n10 11\n00 FF\n4 3\nFFF FFF\n230 A10 010 F70\n4 3\nAFF FFF\n230 A10 010 F70", "Case #1: 7 120\nCase #2: 1 15\nCase #3: 0 1\nCase #4: 2731 8736"]], "limits": {"time": [90000, 90000, 90000, 90000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2020", "组合数学", "Google Code Jam"], "title": "[GCJ 2020 Finals] Hexacoin Jam", "background": "", "description": "The Code Jam team's first cryptocurrency, jamcoins, never caught on. This year, we are trying again with $hexacoins$, which are named for their use of base 16. To \"mine\" a $\\mathbf{D}$-digit hexacoin, one has to work with integers using exactly $\\mathbf{D}$ base 16 digits, including leading zeroes if needed. Each value represents an integer between 0 and $16^{\\mathbf{D}} - 1$, inclusive. Base 16 digits are represented by the numbers 0 through 9 and the uppercase letters A through F, as usual. For example, F2B, 0C8 and 000 are valid values when $\\mathbf{D}=3$, corresponding to the base 10 values 3883, 200 and 0. On the other hand, 1234, DF, C0DE and JAM are not valid values when $\\mathbf{D}=3$.\n\nWhen performing addition of $\\mathbf{D}$-digit base 16 values, any overflow digits are dropped. That is, the addition is performed modulo $16^{\\mathbf{D}}$. For example, F2B + 0C8 = FF3 (4083 in base 10) and F2B + F2B = E56 (3670 in base 10, because the sum's result is 7766, and taking modulo $16^3$ yields 3670).\n\nTo \"mine\" a $\\mathbf{D}$-digit hexacoin, a computer must perform the following steps:\n\n1. Choose a list $\\mathbf{L}$ of $\\mathbf{N}$ $\\mathbf{D}$-digit base 16 values $\\mathbf{L}_1, \\mathbf{L}_2, ..., \\mathbf{L}_\\mathbf{N}$.\n2. Choose a target range of $\\mathbf{D}$-digit base 16 values: the numbers from $\\mathbf{S}$ to $\\mathbf{E}$, inclusive.\n3. Choose a permutation $\\mathbf{P}$ of the base 16 digits 0 through F, uniformly at random from among all 16! such permutations.\n4. Apply $\\mathbf{P}$ to all digits of all numbers in the list, creating a new list $\\mathbf{L}'$ consisting of $\\mathbf{N}$ $\\mathbf{D}$-digit base 16 values. Formally, the $j$-th digit of the $i$-th element of $\\mathbf{L}'$ is the result of applying $\\mathbf{P}$ to the $j$-th digit of the $i$-th element of $\\mathbf{L}$.\n5. Choose a pair of elements from $\\mathbf{L}'$ without replacement, uniformly at random from among all such possible choices, and independently of the choice of permutation.\n6. Calculate the sum (dropping overflow digits) of the two chosen elements.\n\nIf the sum calculated in the last step is between $\\mathbf{S}$ and $\\mathbf{E}$, inclusive, then a hexacoin has been found! For example, suppose that:\n\n* $\\mathbf{L} = [134, 000, FFB, 000, AA9]$.\n* $\\mathbf{S} = 85C$ and $\\mathbf{E} = EDF$.\n* The computer happens to choose $\\mathbf{P} = (0 \\rightarrow 4, 1 \\rightarrow A, 2 \\rightarrow 2, 3 \\rightarrow 8, 4 \\rightarrow 9, 5 \\rightarrow B, 6 \\rightarrow C, 7 \\rightarrow 7, 8 \\rightarrow F, 9 \\rightarrow 1, A \\rightarrow 0, B \\rightarrow 3, C \\rightarrow 5, D \\rightarrow 6, E \\rightarrow E, F \\rightarrow D)$.\n\nThen, when $\\mathbf{P}$ is applied to $\\mathbf{L}$, the resulting $\\mathbf{L}'$ is [A89, 444, DD3, 444, 001]. Notice that $\\mathbf{P}$ is not applied to $\\mathbf{S}$ and $\\mathbf{E}$.\n\nThere are $(5 \\times 4) / 2 = 10$ pairs of values to choose, and each pair has a probability of $1/10$ of being chosen. The only sums that fall within the range are A89 + DD3 = 85C, 444 + 444 = 888, A89 + 001 = A8A, DD3 + 001 = DD4, and A89 + 444 = ECD (twice).\n\nThe first two steps are already computed and you know the list $\\mathbf{L}$ and the range $[\\mathbf{S}, \\mathbf{E}]$ that were chosen. What is the probability that a hexacoin is found after the rest of the process is performed?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of three lines. The first line contains two integers $\\mathbf{N}$ and $\\mathbf{D}$: the size of the given list and the number of digits to work with, respectively. The second line contains two $\\mathbf{D}$-digit base 16 numbers $\\mathbf{S}$ and $\\mathbf{E}$: the inclusive lower and upper bounds of the target range, respectively. Then there is one more line containing $\\mathbf{N}$ $\\mathbf{D}$-digit base 16 numbers $\\mathbf{L}_1, \\mathbf{L}_2, \\dots, \\mathbf{L}_\\mathbf{N}$, representing the values in the list.", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1) and $y$ and $z$ are non-negative integers, such that the fraction $y/z$ represents the probability of finding a hexacoin, under the conditions described above. All of $x$, $y$, and $z$ must be in base 10. If there are multiple acceptable values for $y$ and $z$, choose the ones such that $z$ is minimized.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the target range is just a single value $10$. Since the result ends with $0$, the sum of the values assigned to both last digits $0$ and $F$ must end in $0$ as well. Since $\\mathbf{P}[0]$ and $\\mathbf{P}[F]$ are different values, their sum cannot be exactly $0$. Therefore, $\\mathbf{P}[0] + \\mathbf{P}[F]$ must be $10$ (in base 16). There are $7$ pairs of different digits that accomplish that. $\\mathbf{P}[0]$ and $\\mathbf{P}[F]$ cannot both be $8$. All $7$ pairs lead to an overall sum of $10$ (after dropping an overflow $1$). Therefore, there are $14$ assignments of different digits to $0$ and $F$ that lead to a hexacoin. There are $16 \\times 15$ possible assignments to those digits, so the result is $14/240 = 7/120$.\n\nIn Sample Case #2, we need to add the probability of the result being exactly $11$ to the result of Sample Case #1. The only way that happens is if $0$ and $F$ are assigned to $0$ and $1$, in either order. That has a probability of $2/240 = 1/120$, leading to a total of $7/120 + 1/120 = 8/120 = 1/15$.\n\nIn Sample Case #3, notice that regardless of which permutation and pair of numbers the computer chooses from the list, we will add two numbers that end in the same digit. That produces an even result, even after taking it modulo $16^3$. Since the only value in range is odd, we have no hope of mining a hexacoin in this case. Notice that $0/2$ is an invalid representation of the answer because $z$ would not be minimum.\n\n**Limits**\n\n- $2 \\leq \\mathbf{N} \\leq 450$.\n- $\\mathbf{S}$ contains exactly $\\mathbf{D}$ characters.\n- Each character of $\\mathbf{S}$ is a base 16 digit.\n- $\\mathbf{E}$ contains exactly $\\mathbf{D}$ characters.\n- Each character of $\\mathbf{E}$ is a base 16 digit.\n- $\\mathbf{S} \\leq \\mathbf{E}$.\n- $\\mathbf{L}_i$ contains exactly $\\mathbf{D}$ characters, for all $i$.\n- Each character of $\\mathbf{L}_i$ is a base 16 digit, for all $i$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{D} \\leq 3$.\n\n**Test Set 2 (10 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{D} \\leq 4$.\n\n**Test Set 3 (22 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 10$.\n- $2 \\leq \\mathbf{D} \\leq 5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Finals] Hexacoin Jam", "background": "", "description": "The Code Jam team's first cryptocurrency, jamcoins, never caught on. This year, we are trying again with $hexacoins$, which are named for their use of base 16. To \"mine\" a $\\mathbf{D}$-digit hexacoin, one has to work with integers using exactly $\\mathbf{D}$ base 16 digits, including leading zeroes if needed. Each value represents an integer between 0 and $16^{\\mathbf{D}} - 1$, inclusive. Base 16 digits are represented by the numbers 0 through 9 and the uppercase letters A through F, as usual. For example, F2B, 0C8 and 000 are valid values when $\\mathbf{D}=3$, corresponding to the base 10 values 3883, 200 and 0. On the other hand, 1234, DF, C0DE and JAM are not valid values when $\\mathbf{D}=3$.\n\nWhen performing addition of $\\mathbf{D}$-digit base 16 values, any overflow digits are dropped. That is, the addition is performed modulo $16^{\\mathbf{D}}$. For example, F2B + 0C8 = FF3 (4083 in base 10) and F2B + F2B = E56 (3670 in base 10, because the sum's result is 7766, and taking modulo $16^3$ yields 3670).\n\nTo \"mine\" a $\\mathbf{D}$-digit hexacoin, a computer must perform the following steps:\n\n1. Choose a list $\\mathbf{L}$ of $\\mathbf{N}$ $\\mathbf{D}$-digit base 16 values $\\mathbf{L}_1, \\mathbf{L}_2, ..., \\mathbf{L}_\\mathbf{N}$.\n2. Choose a target range of $\\mathbf{D}$-digit base 16 values: the numbers from $\\mathbf{S}$ to $\\mathbf{E}$, inclusive.\n3. Choose a permutation $\\mathbf{P}$ of the base 16 digits 0 through F, uniformly at random from among all 16! such permutations.\n4. Apply $\\mathbf{P}$ to all digits of all numbers in the list, creating a new list $\\mathbf{L}'$ consisting of $\\mathbf{N}$ $\\mathbf{D}$-digit base 16 values. Formally, the $j$-th digit of the $i$-th element of $\\mathbf{L}'$ is the result of applying $\\mathbf{P}$ to the $j$-th digit of the $i$-th element of $\\mathbf{L}$.\n5. Choose a pair of elements from $\\mathbf{L}'$ without replacement, uniformly at random from among all such possible choices, and independently of the choice of permutation.\n6. Calculate the sum (dropping overflow digits) of the two chosen elements.\n\nIf the sum calculated in the last step is between $\\mathbf{S}$ and $\\mathbf{E}$, inclusive, then a hexacoin has been found! For example, suppose that:\n\n* $\\mathbf{L} = [134, 000, FFB, 000, AA9]$.\n* $\\mathbf{S} = 85C$ and $\\mathbf{E} = EDF$.\n* The computer happens to choose $\\mathbf{P} = (0 \\rightarrow 4, 1 \\rightarrow A, 2 \\rightarrow 2, 3 \\rightarrow 8, 4 \\rightarrow 9, 5 \\rightarrow B, 6 \\rightarrow C, 7 \\rightarrow 7, 8 \\rightarrow F, 9 \\rightarrow 1, A \\rightarrow 0, B \\rightarrow 3, C \\rightarrow 5, D \\rightarrow 6, E \\rightarrow E, F \\rightarrow D)$.\n\nThen, when $\\mathbf{P}$ is applied to $\\mathbf{L}$, the resulting $\\mathbf{L}'$ is [A89, 444, DD3, 444, 001]. Notice that $\\mathbf{P}$ is not applied to $\\mathbf{S}$ and $\\mathbf{E}$.\n\nThere are $(5 \\times 4) / 2 = 10$ pairs of values to choose, and each pair has a probability of $1/10$ of being chosen. The only sums that fall within the range are A89 + DD3 = 85C, 444 + 444 = 888, A89 + 001 = A8A, DD3 + 001 = DD4, and A89 + 444 = ECD (twice).\n\nThe first two steps are already computed and you know the list $\\mathbf{L}$ and the range $[\\mathbf{S}, \\mathbf{E}]$ that were chosen. What is the probability that a hexacoin is found after the rest of the process is performed?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of three lines. The first line contains two integers $\\mathbf{N}$ and $\\mathbf{D}$: the size of the given list and the number of digits to work with, respectively. The second line contains two $\\mathbf{D}$-digit base 16 numbers $\\mathbf{S}$ and $\\mathbf{E}$: the inclusive lower and upper bounds of the target range, respectively. Then there is one more line containing $\\mathbf{N}$ $\\mathbf{D}$-digit base 16 numbers $\\mathbf{L}_1, \\mathbf{L}_2, \\dots, \\mathbf{L}_\\mathbf{N}$, representing the values in the list.", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1) and $y$ and $z$ are non-negative integers, such that the fraction $y/z$ represents the probability of finding a hexacoin, under the conditions described above. All of $x$, $y$, and $z$ must be in base 10. If there are multiple acceptable values for $y$ and $z$, choose the ones such that $z$ is minimized.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the target range is just a single value $10$. Since the result ends with $0$, the sum of the values assigned to both last digits $0$ and $F$ must end in $0$ as well. Since $\\mathbf{P}[0]$ and $\\mathbf{P}[F]$ are different values, their sum cannot be exactly $0$. Therefore, $\\mathbf{P}[0] + \\mathbf{P}[F]$ must be $10$ (in base 16). There are $7$ pairs of different digits that accomplish that. $\\mathbf{P}[0]$ and $\\mathbf{P}[F]$ cannot both be $8$. All $7$ pairs lead to an overall sum of $10$ (after dropping an overflow $1$). Therefore, there are $14$ assignments of different digits to $0$ and $F$ that lead to a hexacoin. There are $16 \\times 15$ possible assignments to those digits, so the result is $14/240 = 7/120$.\n\nIn Sample Case #2, we need to add the probability of the result being exactly $11$ to the result of Sample Case #1. The only way that happens is if $0$ and $F$ are assigned to $0$ and $1$, in either order. That has a probability of $2/240 = 1/120$, leading to a total of $7/120 + 1/120 = 8/120 = 1/15$.\n\nIn Sample Case #3, notice that regardless of which permutation and pair of numbers the computer chooses from the list, we will add two numbers that end in the same digit. That produces an even result, even after taking it modulo $16^3$. Since the only value in range is odd, we have no hope of mining a hexacoin in this case. Notice that $0/2$ is an invalid representation of the answer because $z$ would not be minimum.\n\n**Limits**\n\n- $2 \\leq \\mathbf{N} \\leq 450$.\n- $\\mathbf{S}$ contains exactly $\\mathbf{D}$ characters.\n- Each character of $\\mathbf{S}$ is a base 16 digit.\n- $\\mathbf{E}$ contains exactly $\\mathbf{D}$ characters.\n- Each character of $\\mathbf{E}$ is a base 16 digit.\n- $\\mathbf{S} \\leq \\mathbf{E}$.\n- $\\mathbf{L}_i$ contains exactly $\\mathbf{D}$ characters, for all $i$.\n- Each character of $\\mathbf{L}_i$ is a base 16 digit, for all $i$.\n\n**Test Set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{D} \\leq 3$.\n\n**Test Set 2 (10 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{D} \\leq 4$.\n\n**Test Set 3 (22 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{T} \\leq 10$.\n- $2 \\leq \\mathbf{D} \\leq 5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Finals] Hexacoin Jam", "background": "", "description": "Code Jam 团队的第一种加密货币 **jamcoins** 从未流行起来。今年，我们尝试推出基于 16 进制的 **十六进制币**（$hexacoins$）。要“挖矿”一个 $\\mathbf{D}$ 位十六进制币，需要处理恰好 $\\mathbf{D}$ 位的 16 进制数（必要时包含前导零）。每个数值代表 $0$ 到 $16^{\\mathbf{D}} - 1$（含）之间的整数。16 进制数字由数字 0 到 9 和大写字母 A 到 F 表示。例如，当 $\\mathbf{D}=3$ 时，F2B、0C8 和 000 是有效值，对应十进制值 3883、200 和 0。而 1234、DF、C0DE 和 JAM 不是 $\\mathbf{D}=3$ 时的有效值。\n\n执行 $\\mathbf{D}$ 位 16 进制数加法时，溢出的位数会被丢弃（即模 $16^{\\mathbf{D}}$ 加法）。例如，F2B + 0C8 = FF3（十进制 4083），F2B + F2B = E56（十进制 3670，因为和为 7766，模 $16^3$ 得 3670）。\n\n要“挖矿”一个 $\\mathbf{D}$ 位十六进制币，计算机需执行以下步骤：\n\n1. 选择一个包含 $\\mathbf{N}$ 个 $\\mathbf{D}$ 位 16 进制数的列表 $\\mathbf{L}$：$\\mathbf{L}_1, \\mathbf{L}_2, ..., \\mathbf{L}_\\mathbf{N}$。\n2. 选择一个目标范围 $\\mathbf{S}$ 到 $\\mathbf{E}$（含）的 $\\mathbf{D}$ 位 16 进制数。\n3. 从所有 16! 种排列中均匀随机选择一个 16 进制数字 0 到 F 的排列 $\\mathbf{P}$。\n4. 将 $\\mathbf{P}$ 应用于 $\\mathbf{L}$ 中所有数字的每一位，生成新列表 $\\mathbf{L}'$。形式化地，$\\mathbf{L}'$ 的第 $i$ 个元素的第 $j$ 位是 $\\mathbf{P}$ 作用于 $\\mathbf{L}$ 的第 $i$ 个元素的第 $j$ 位的结果。\n5. 从 $\\mathbf{L}'$ 中均匀随机且独立地选择一对元素（无放回）。\n6. 计算所选两个元素的和（丢弃溢出位）。\n\n如果最后一步的和在 $\\mathbf{S}$ 到 $\\mathbf{E}$（含）之间，则成功挖到一枚十六进制币！例如：\n\n- $\\mathbf{L} = [134, 000, FFB, 000, AA9]$。\n- $\\mathbf{S} = 85C$，$\\mathbf{E} = EDF$。\n- 计算机选择排列 $\\mathbf{P} = (0 \\rightarrow 4, 1 \\rightarrow A, 2 \\rightarrow 2, 3 \\rightarrow 8, 4 \\rightarrow 9, 5 \\rightarrow B, 6 \\rightarrow C, 7 \\rightarrow 7, 8 \\rightarrow F, 9 \\rightarrow 1, A \\rightarrow 0, B \\rightarrow 3, C \\rightarrow 5, D \\rightarrow 6, E \\rightarrow E, F \\rightarrow D)$。\n\n应用 $\\mathbf{P}$ 后，$\\mathbf{L}' = [A89, 444, DD3, 444, 001]$。注意 $\\mathbf{S}$ 和 $\\mathbf{E}$ 不受 $\\mathbf{P}$ 影响。\n\n共有 $(5 \\times 4) / 2 = 10$ 对可选，每对概率为 $1/10$。满足范围的求和结果为：A89 + DD3 = 85C、444 + 444 = 888、A89 + 001 = A8A、DD3 + 001 = DD4 和 A89 + 444 = ECD（两次）。\n\n已知前两步的 $\\mathbf{L}$ 和范围 $[\\mathbf{S}, \\mathbf{E}]$，求后续步骤成功挖矿的概率。", "inputFormat": "第一行输入测试用例数 $\\mathbf{T}$。随后每个测试用例包含三行：  \n第一行两个整数 $\\mathbf{N}$ 和 $\\mathbf{D}$：列表大小和数字位数。  \n第二行两个 $\\mathbf{D}$ 位 16 进制数 $\\mathbf{S}$ 和 $\\mathbf{E}$：目标范围的上下界。  \n第三行 $\\mathbf{N}$ 个 $\\mathbf{D}$ 位 16 进制数 $\\mathbf{L}_1, \\mathbf{L}_2, \\dots, \\mathbf{L}_\\mathbf{N}$。\n", "outputFormat": "对每个测试用例，输出一行 `Case #x: y z`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 和 $z$ 为非负整数，表示概率的最简分数 $y/z$。若存在多解，取 $z$ 最小者。\n", "hint": "**样例解释**\n\n样例 #1 中，目标范围仅为 $10$。由于结果末位需为 $0$，且 $\\mathbf{P}[0]$ 和 $\\mathbf{P}[F]$ 不同，它们的和必须为 $10$（16 进制）。共有 7 对不同的数字满足此条件（不能同为 8），对应 14 种赋值方式。总可能赋值数为 $16 \\times 15 = 240$，故概率为 $14/240 = 7/120$。\n\n样例 #2 需额外考虑和为 $11$ 的情况，仅当 $0$ 和 $F$ 被赋值为 $0$ 和 $1$（顺序不限）时成立，概率为 $2/240$。总概率为 $7/120 + 1/120 = 1/15$。\n\n样例 #3 中，无论选择哪对数字，和的末位均为偶数，而目标范围 $FFF$ 为奇数，故概率为 $0$。注意 $0/2$ 不是合法输出，因为 $z$ 未取最小。\n\n**数据范围**\n\n- $2 \\leq \\mathbf{N} \\leq 450$。\n- $\\mathbf{S}$ 和 $\\mathbf{E}$ 均为 $\\mathbf{D}$ 位 16 进制数，且 $\\mathbf{S} \\leq \\mathbf{E}$。\n- 每个 $\\mathbf{L}_i$ 为 $\\mathbf{D}$ 位 16 进制数。\n\n**测试集 1（10 分，可见判定）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{D} \\leq 3$。\n\n**测试集 2（10 分，隐藏判定）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{D} \\leq 4$。\n\n**测试集 3（22 分，隐藏判定）**\n\n- $1 \\leq \\mathbf{T} \\leq 10$。\n- $2 \\leq \\mathbf{D} \\leq 5$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13073", "type": "P", "difficulty": 7, "samples": [["2\n5 2 1\n0 3\n1234567890 3\n3154510113 3\n180000000000 3\n359999999999 3\n5 10 1\n90000000000 8\n180000000000 7\n260000000000 9\n260000000001 1\n260000000002 1", "Case #1: 10.0000000000\nCase #2: 36.9238939618"], ["1\n6 1 10\n0 10\n15000000000 1\n30000000000 1\n45000000000 1\n60000000000 1\n75000000000 1", "Case #1: 12.2175228580 12.0000000000 11.7653668647 11.5176380902 11.2610523844 3.0000000000 2.7653668647 2.7653668647 2.5176380902 2.5176380902"]], "limits": {"time": [120000, 120000, 120000], "memory": [1048576, 1048576, 1048576]}, "tags": ["计算几何", "2020", "Special Judge", "Google Code Jam"], "title": "[GCJ 2020 Finals] Musical Cords", "background": "", "description": "Lauren is trying to play the most beautiful notes possible using a harp. The harp is a circle with a radius of $\\mathbf{R}$ centimeters. To play a note, a cord must be attached to the harp in a way that connects two different attachment points on the perimeter of the circle. Lauren then plucks this cord to play a note.\n\nThere are $\\mathbf{N}$ attachment points on the perimeter of the circular harp at which a cord can be attached. The $i$-th such attachment point is at a location that is $\\mathbf{D}_i$ nanodegrees (a nanodegree is $10^{-9}$ degrees) clockwise around the perimeter of the circular harp, starting from the rightmost point on the perimeter.\n\nNot all attachment points use the same technology to properly fix the cords onto them. The $i$-th attachment point requires $\\mathbf{L}_i$ centimeters of cord to be used for attaching. A cord fixed between two different attachment points $i$ and $j$ needs to be exactly $\\mathbf{L}_i + \\mathbf{L}_j + \\text{distance}(i, j)$ centimeters long. By $\\text{distance}(i, j)$ we mean the length of the geometric chord connecting the $i$-th and $j$-th attachment points, that is, the Euclidean distance between the two points.\n\nLauren thinks that notes sound better when they come from longer cords. What are the $\\mathbf{K}$ longest cords that can be used with Lauren's harp?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains three integers: $\\mathbf{N}$, $\\mathbf{R}$ and $\\mathbf{K}$: the number of attachment points, the radius of the circular harp in centimeters, and the number of lengths of cords that Lauren is interested in knowing.\n\nThe next $\\mathbf{N}$ lines describe the attachment points. The $i$-th of these lines contains two integers, $\\mathbf{D}_i$ and $\\mathbf{L}_i$, which describe the position (in number of nanodegrees clockwise from the rightmost point of the harp) and length of cord in centimeters needed at the $i$-th attachment point.\n", "outputFormat": "For each test case, output one line containing Case #x: $y_1$ $y_2$ ... $y_{\\mathbf{K}}$, where $x$ is the test case number (starting from 1), and $y_n$ is the $n$-th value in the list of lengths of all $\\mathbf{N} \\times (\\mathbf{N}-1)/2$ cords that can be used in Lauren's harp, sorted in non-increasing order.\n\nEach $y_n$ will be considered correct if it is within an absolute or relative error of $10^{-9}$ of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explanation**\n\nSample Test Set 1 meet the limits for Test Set 1. Another sample case that does not meet those limits could appear in Test Set 2.\n\nNote: the $\\mathbf{L}_i$ values in these sample cases for Test Set 1 were chosen for ease of understanding and were not randomly generated. Your solution will be run against these sample cases and must pass them.\n\nIn Sample Case #1, all of the attachment points have the same value, so we should pick the pair connected by the longest chord, which in this case is a horizontal diameter of the circle that has a length of 4 centimeters. So the total length needed is $4 + 3 + 3 = 10$ centimeters.\n\nIn Sample Case #2, the fourth and fifth points are extremely close to the third point, but have much smaller $\\mathbf{L}$ values. We can effectively rule them out and focus on the possible connections among the first three points, as follows:\n\n- first and second points: length $10\\sqrt{2} + 8 + 7 \\approx 29.142136$.\n- first and third points: length $\\approx 19.923894 + 8 + 9 \\approx 36.923894$.\n- second and third points: length $\\approx 12.855726 + 7 + 9 \\approx 28.855726$.\n\nUsing the first and third points gives us the greatest total length.\n\nSample Test Set 2: Notice that there are three possible pairs of points tied for producing the 9th longest cord. Also, it is fine if lines connecting different pairs of points intersect, since Lauren will only be playing one note at a time.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{N} = 150000$ in at most 10 cases.\n- $5 \\leq \\mathbf{N} \\leq 10^4$ in all cases with $\\mathbf{N} \\neq 150000$.\n- $1 \\leq \\mathbf{R} \\leq 10^9$.\n- $0 \\leq \\mathbf{D}_1$.\n- $\\mathbf{D}_i < \\mathbf{D}_{i+1}$, for all $i$.\n- $\\mathbf{D}_N < 360 \\times 10^9$.\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{L}_i$ is chosen independently and uniformly at random between 1 and $10^9$, inclusive, for each $i$.\n- $\\mathbf{K} = 1$.\n\n**Test Set 2 (27 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{L}_i \\leq 10^9$, for all $i$.\n- (There is no guarantee as to how each $\\mathbf{L}_i$ is generated.)\n- $\\mathbf{K} = 10$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Finals] Musical Cords", "background": "", "description": "Lauren is trying to play the most beautiful notes possible using a harp. The harp is a circle with a radius of $\\mathbf{R}$ centimeters. To play a note, a cord must be attached to the harp in a way that connects two different attachment points on the perimeter of the circle. Lauren then plucks this cord to play a note.\n\nThere are $\\mathbf{N}$ attachment points on the perimeter of the circular harp at which a cord can be attached. The $i$-th such attachment point is at a location that is $\\mathbf{D}_i$ nanodegrees (a nanodegree is $10^{-9}$ degrees) clockwise around the perimeter of the circular harp, starting from the rightmost point on the perimeter.\n\nNot all attachment points use the same technology to properly fix the cords onto them. The $i$-th attachment point requires $\\mathbf{L}_i$ centimeters of cord to be used for attaching. A cord fixed between two different attachment points $i$ and $j$ needs to be exactly $\\mathbf{L}_i + \\mathbf{L}_j + \\text{distance}(i, j)$ centimeters long. By $\\text{distance}(i, j)$ we mean the length of the geometric chord connecting the $i$-th and $j$-th attachment points, that is, the Euclidean distance between the two points.\n\nLauren thinks that notes sound better when they come from longer cords. What are the $\\mathbf{K}$ longest cords that can be used with Lauren's harp?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains three integers: $\\mathbf{N}$, $\\mathbf{R}$ and $\\mathbf{K}$: the number of attachment points, the radius of the circular harp in centimeters, and the number of lengths of cords that Lauren is interested in knowing.\n\nThe next $\\mathbf{N}$ lines describe the attachment points. The $i$-th of these lines contains two integers, $\\mathbf{D}_i$ and $\\mathbf{L}_i$, which describe the position (in number of nanodegrees clockwise from the rightmost point of the harp) and length of cord in centimeters needed at the $i$-th attachment point.\n", "outputFormat": "For each test case, output one line containing Case #x: $y_1$ $y_2$ ... $y_{\\mathbf{K}}$, where $x$ is the test case number (starting from 1), and $y_n$ is the $n$-th value in the list of lengths of all $\\mathbf{N} \\times (\\mathbf{N}-1)/2$ cords that can be used in Lauren's harp, sorted in non-increasing order.\n\nEach $y_n$ will be considered correct if it is within an absolute or relative error of $10^{-9}$ of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explanation**\n\nSample Test Set 1 meet the limits for Test Set 1. Another sample case that does not meet those limits could appear in Test Set 2.\n\nNote: the $\\mathbf{L}_i$ values in these sample cases for Test Set 1 were chosen for ease of understanding and were not randomly generated. Your solution will be run against these sample cases and must pass them.\n\nIn Sample Case #1, all of the attachment points have the same value, so we should pick the pair connected by the longest chord, which in this case is a horizontal diameter of the circle that has a length of 4 centimeters. So the total length needed is $4 + 3 + 3 = 10$ centimeters.\n\nIn Sample Case #2, the fourth and fifth points are extremely close to the third point, but have much smaller $\\mathbf{L}$ values. We can effectively rule them out and focus on the possible connections among the first three points, as follows:\n\n- first and second points: length $10\\sqrt{2} + 8 + 7 \\approx 29.142136$.\n- first and third points: length $\\approx 19.923894 + 8 + 9 \\approx 36.923894$.\n- second and third points: length $\\approx 12.855726 + 7 + 9 \\approx 28.855726$.\n\nUsing the first and third points gives us the greatest total length.\n\nSample Test Set 2: Notice that there are three possible pairs of points tied for producing the 9th longest cord. Also, it is fine if lines connecting different pairs of points intersect, since Lauren will only be playing one note at a time.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{N} = 150000$ in at most 10 cases.\n- $5 \\leq \\mathbf{N} \\leq 10^4$ in all cases with $\\mathbf{N} \\neq 150000$.\n- $1 \\leq \\mathbf{R} \\leq 10^9$.\n- $0 \\leq \\mathbf{D}_1$.\n- $\\mathbf{D}_i < \\mathbf{D}_{i+1}$, for all $i$.\n- $\\mathbf{D}_N < 360 \\times 10^9$.\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $\\mathbf{L}_i$ is chosen independently and uniformly at random between 1 and $10^9$, inclusive, for each $i$.\n- $\\mathbf{K} = 1$.\n\n**Test Set 2 (27 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{L}_i \\leq 10^9$, for all $i$.\n- (There is no guarantee as to how each $\\mathbf{L}_i$ is generated.)\n- $\\mathbf{K} = 10$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Finals] Musical Cords", "background": "", "description": "Lauren 正尝试用竖琴演奏最美妙的音符。竖琴是一个半径为 $\\mathbf{R}$ 厘米的圆形乐器。要演奏一个音符，必须在圆周上两个不同的固定点之间连接一根琴弦，并通过拨动琴弦发声。\n\n圆周上共有 $\\mathbf{N}$ 个固定点可用于连接琴弦。第 $i$ 个固定点的位置为从圆周最右侧点顺时针方向 $\\mathbf{D}_i$ 纳度（1 纳度 = $10^{-9}$ 度）处。\n\n不同固定点使用的固定技术不同。第 $i$ 个固定点需要消耗 $\\mathbf{L}_i$ 厘米的琴弦用于固定。连接两个不同固定点 $i$ 和 $j$ 的琴弦总长度必须恰好为 $\\mathbf{L}_i + \\mathbf{L}_j + \\text{distance}(i, j)$ 厘米。其中 $\\text{distance}(i, j)$ 表示第 $i$ 个和第 $j$ 个固定点之间的几何弦长（即两点间的欧几里得距离）。\n\nLauren 认为琴弦越长，音符听起来越美妙。请问 Lauren 的竖琴可以使用的琴弦中，最长的 $\\mathbf{K}$ 个长度分别是多少？\n", "inputFormat": "第一行输入测试用例数 $\\mathbf{T}$。每个测试用例包含：  \n第一行三个整数 $\\mathbf{N}$、$\\mathbf{R}$ 和 $\\mathbf{K}$：固定点数量、竖琴半径（厘米）和 Lauren 需要查询的琴弦长度数量。  \n接下来 $\\mathbf{N}$ 行描述固定点，每行两个整数 $\\mathbf{D}_i$ 和 $\\mathbf{L}_i$，分别表示第 $i$ 个固定点的位置（纳度）和固定所需琴弦长度（厘米）。\n", "outputFormat": "对每个测试用例，输出一行 `Case #x: y1 y2 ... yK`，其中 $x$ 为测试用例编号（从 1 开始），$y_n$ 为所有 $\\mathbf{N} \\times (\\mathbf{N}-1)/2$ 根可能琴弦的长度按非递增排序后的第 $n$ 个值。\n\n每个 $y_n$ 允许存在绝对或相对误差不超过 $10^{-9}$。", "hint": "**样例解释**\n\n样例测试集 1 符合测试集 1 的限制条件。其他不符合该限制的样例可能出现在测试集 2 中。\n\n注意：测试集 1 的样例中 $\\mathbf{L}_i$ 值是为便于理解而设定的非随机值。您的解法必须通过这些样例。\n\n在样例 #1 中，所有固定点的 $\\mathbf{L}_i$ 值相同，因此应选择弦长最长的点对（即圆的水平直径，长度 4 厘米）。总长度为 $4 + 3 + 3 = 10$ 厘米。\n\n在样例 #2 中，第四和第五个点非常接近第三个点，但 $\\mathbf{L}$ 值较小。最优解来自前三个点的连接：  \n- 第一和第二个点：长度 $10\\sqrt{2} + 8 + 7 \\approx 29.142136$  \n- 第一和第三个点：长度 $\\approx 19.923894 + 8 + 9 \\approx 36.923894$  \n- 第二和第三个点：长度 $\\approx 12.855726 + 7 + 9 \\approx 28.855726$  \n因此选择第一和第三个点获得最大长度。\n\n样例测试集 2：注意存在三组点对并列产生第 9 长的琴弦。不同琴弦可以交叉，因为 Lauren 每次只演奏一个音符。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$  \n- $\\mathbf{N} = 150000$ 的用例不超过 10 个  \n- $5 \\leq \\mathbf{N} \\leq 10^4$（当 $\\mathbf{N} \\neq 150000$ 时）  \n- $1 \\leq \\mathbf{R} \\leq 10^9$  \n- $0 \\leq \\mathbf{D}_1$  \n- $\\mathbf{D}_i < \\mathbf{D}_{i+1}$（对所有 $i$）  \n- $\\mathbf{D}_N < 360 \\times 10^9$  \n\n**测试集 1（15 分，可见判定）**\n\n- $\\mathbf{L}_i$ 在 1 到 $10^9$ 之间独立均匀随机生成  \n- $\\mathbf{K} = 1$  \n\n**测试集 2（27 分，隐藏判定）**\n\n- $1 \\leq \\mathbf{L}_i \\leq 10^9$（生成方式无限制）  \n- $\\mathbf{K} = 10$  \n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13074", "type": "P", "difficulty": 6, "samples": [["4\nCODEJAMWORLDFINALS 2\nAO OY\nxyz 3\nxy zx yz\nCJ 4\n20 2O HC KS\nAB 2\nAb bA", "Case #1: 14\nCase #2: 2\nCase #3: 2\nCase #4: 2"], ["1\n1234 5\n12 2X X3 31 X2", "Case #1: 4"]], "limits": {"time": [60000, 60000, 60000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2020", "网络流", "二分图", "Google Code Jam"], "title": "[GCJ 2020 Finals] Replace All", "background": "", "description": "Banana Rocks Inc is coming up with a revolutionary technology to perform the common edit operation \"replace all\". Their implementation replaces every occurrence of a character within a given text with another character. (If the character does not appear in the text, then the operation occurs but has no effect.)\n\nFor example, if the starting text is `CODEJAMWORLDFINALS` and an operation is performed to replace A with o, the new text would be `CODEJOMWORLDFINOLS`. If another operation is performed on that result to replace o with y, the final text would be `CYDEJYMWYRLDFINYLS`.\n\nUnfortunately, the implementation is incomplete, so it can only perform replacements from a specific list of $\\mathbf{N}$ pairs of characters. Also, even if a replacement of a specific character $c_1$ with another character $c_2$ is implemented, the reverse replacement of $c_2$ with $c_1$ may or may not be implemented.\n\nYou want to try all the implemented replacements. You are given some initial string $\\mathbf{S}$ to use as the initial text. You can perform any number of replacements in sequential order: the first replacement is performed on $\\mathbf{S}$, and the (i+1)-th replacement is performed on the result of performing the i-th replacement. The only requirement is that each implemented replacement is performed at least once during this process. There is no upper limit on how many times you may perform each replacement.\n\nThe allowed characters are decimal digits and uppercase and lowercase English alphabet letters. In this problem, uppercase and lowercase versions of the same letter are treated as distinct characters.\n\nWhat is the maximum number of unique characters that can appear in a text that is the result of the last replacement performed?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line contains a string $\\mathbf{S}$ and an integer $\\mathbf{N}$: the initial text and the number of implemented replacements. The second line contains $\\mathbf{N}$ two-character strings $\\mathbf{R}_1$, $\\mathbf{R}_2$, ..., $\\mathbf{R}_\\mathbf{N}$, representing the implemented replacements. $\\mathbf{A}_i$ and $\\mathbf{B}_i$ are the first and second characters of $\\mathbf{R}_i$, respectively. The i-th implemented replacement corresponds to replacing all occurrences of $\\mathbf{A}_i$ with $\\mathbf{B}_i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where x is the test case number (starting from 1) and y is the maximum number of unique characters that can appear in a text that is the result of performing all implemented replacements to $\\mathbf{S}$ one or more times each, in some order.", "hint": "**Sample Explanation**\n\nSample Test Set 1 meets the limits for Test Set 1. Another sample case that does not meet those limits could appear in Test Set 2.\n\nSample Case #1 is the one in the statement. Notice that if we perform the replacements in the order mentioned in the statement, we get 13 different characters in the final text. If we perform them both once in the other order, however, we can get `CYDEJOMWYRLDFINOLS`, which has 14 different characters.\n\nIn Sample Case #2, one way to get 2 different characters in the final text is to perform the replacements in the order given from left to right, once each.\n\nIn Sample Case #3, none of the replacements affect the text at all, so it does not matter how we apply them. We will always be left with the original two letters. Notice that replacements can contain characters not appearing in the initial text, and the initial text can contain characters not appearing in the implemented replacements.\n\nIn Sample Case #4, remember that uppercase $\\mathbf{B}$ is not the same character as lowercase $\\mathbf{b}$.\n\nIn this additional sample case, one possibility is to perform the replacements in the following order: `X3 2X X2 2X 12 31`. This process goes through the following strings, starting with S: `1234 1234 1X34 1234 1X34 2X34 2X14`.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\text{length of } \\mathbf{S} \\leq 1000$, for all i.\n- Each character of $\\mathbf{S}$ is an uppercase or lowercase English alphabet letter or a decimal digit.\n- $\\mathbf{A}_i$ is an uppercase or lowercase English alphabet letter or a decimal digit, for all i.\n- $\\mathbf{B}_i$ is an uppercase or lowercase English alphabet letter or a decimal digit, for all i.\n- $\\mathbf{A}_i \\neq \\mathbf{B}_i$, for all i.\n- $(\\mathbf{A}_i, \\mathbf{B}_i) \\neq (\\mathbf{A}_j, \\mathbf{B}_j)$, for all $i \\neq j$. (Each replacement is unique.)\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 62$.\n- $\\mathbf{B}_i \\neq \\mathbf{B}_j$, for all $i \\neq j$.\n\n**Test Set 2 (27 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 62 \\times 61$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2020 Finals] Replace All", "background": "", "description": "Banana Rocks Inc is coming up with a revolutionary technology to perform the common edit operation \"replace all\". Their implementation replaces every occurrence of a character within a given text with another character. (If the character does not appear in the text, then the operation occurs but has no effect.)\n\nFor example, if the starting text is `CODEJAMWORLDFINALS` and an operation is performed to replace A with o, the new text would be `CODEJOMWORLDFINOLS`. If another operation is performed on that result to replace o with y, the final text would be `CYDEJYMWYRLDFINYLS`.\n\nUnfortunately, the implementation is incomplete, so it can only perform replacements from a specific list of $\\mathbf{N}$ pairs of characters. Also, even if a replacement of a specific character $c_1$ with another character $c_2$ is implemented, the reverse replacement of $c_2$ with $c_1$ may or may not be implemented.\n\nYou want to try all the implemented replacements. You are given some initial string $\\mathbf{S}$ to use as the initial text. You can perform any number of replacements in sequential order: the first replacement is performed on $\\mathbf{S}$, and the (i+1)-th replacement is performed on the result of performing the i-th replacement. The only requirement is that each implemented replacement is performed at least once during this process. There is no upper limit on how many times you may perform each replacement.\n\nThe allowed characters are decimal digits and uppercase and lowercase English alphabet letters. In this problem, uppercase and lowercase versions of the same letter are treated as distinct characters.\n\nWhat is the maximum number of unique characters that can appear in a text that is the result of the last replacement performed?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line contains a string $\\mathbf{S}$ and an integer $\\mathbf{N}$: the initial text and the number of implemented replacements. The second line contains $\\mathbf{N}$ two-character strings $\\mathbf{R}_1$, $\\mathbf{R}_2$, ..., $\\mathbf{R}_\\mathbf{N}$, representing the implemented replacements. $\\mathbf{A}_i$ and $\\mathbf{B}_i$ are the first and second characters of $\\mathbf{R}_i$, respectively. The i-th implemented replacement corresponds to replacing all occurrences of $\\mathbf{A}_i$ with $\\mathbf{B}_i$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where x is the test case number (starting from 1) and y is the maximum number of unique characters that can appear in a text that is the result of performing all implemented replacements to $\\mathbf{S}$ one or more times each, in some order.", "hint": "**Sample Explanation**\n\nSample Test Set 1 meets the limits for Test Set 1. Another sample case that does not meet those limits could appear in Test Set 2.\n\nSample Case #1 is the one in the statement. Notice that if we perform the replacements in the order mentioned in the statement, we get 13 different characters in the final text. If we perform them both once in the other order, however, we can get `CYDEJOMWYRLDFINOLS`, which has 14 different characters.\n\nIn Sample Case #2, one way to get 2 different characters in the final text is to perform the replacements in the order given from left to right, once each.\n\nIn Sample Case #3, none of the replacements affect the text at all, so it does not matter how we apply them. We will always be left with the original two letters. Notice that replacements can contain characters not appearing in the initial text, and the initial text can contain characters not appearing in the implemented replacements.\n\nIn Sample Case #4, remember that uppercase $\\mathbf{B}$ is not the same character as lowercase $\\mathbf{b}$.\n\nIn this additional sample case, one possibility is to perform the replacements in the following order: `X3 2X X2 2X 12 31`. This process goes through the following strings, starting with S: `1234 1234 1X34 1234 1X34 2X34 2X14`.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\text{length of } \\mathbf{S} \\leq 1000$, for all i.\n- Each character of $\\mathbf{S}$ is an uppercase or lowercase English alphabet letter or a decimal digit.\n- $\\mathbf{A}_i$ is an uppercase or lowercase English alphabet letter or a decimal digit, for all i.\n- $\\mathbf{B}_i$ is an uppercase or lowercase English alphabet letter or a decimal digit, for all i.\n- $\\mathbf{A}_i \\neq \\mathbf{B}_i$, for all i.\n- $(\\mathbf{A}_i, \\mathbf{B}_i) \\neq (\\mathbf{A}_j, \\mathbf{B}_j)$, for all $i \\neq j$. (Each replacement is unique.)\n\n**Test Set 1 (15 Pts, Visible Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 62$.\n- $\\mathbf{B}_i \\neq \\mathbf{B}_j$, for all $i \\neq j$.\n\n**Test Set 2 (27 Pts, Hidden Verdict)**\n\n- $2 \\leq \\mathbf{N} \\leq 62 \\times 61$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2020 Finals] Replace All", "background": null, "description": "**Banana Rocks Inc** 正在研发一项革命性技术，用于执行常见的编辑操作“替换所有字符”。他们的实现会将给定文本中某个字符的所有出现替换为另一个字符。（如果该字符未出现在文本中，则操作会执行但无实际效果。）\n\n例如，如果初始文本为 `CODEJAMWORLDFINALS`，执行将 A 替换为 o 的操作后，新文本为 `CODEJOMWORLDFINOLS`。若在该结果上再执行将 o 替换为 y 的操作，最终文本为 `CYDEJYMWYRLDFINYLS`。\n\n遗憾的是，该实现尚未完成，因此只能执行特定列表中的 $\\mathbf{N}$ 对字符的替换。此外，即使实现了将某个字符 $c_1$ 替换为另一个字符 $c_2$ 的操作，反向将 $c_2$ 替换为 $c_1$ 的操作可能实现也可能未实现。\n\n你需要尝试所有已实现的替换操作。给定一个初始字符串 $\\mathbf{S}$ 作为初始文本，你可以按任意顺序执行任意次数的替换操作：第一次替换作用于 $\\mathbf{S}$，第 $(i+1)$ 次替换作用于第 $i$ 次替换后的结果。唯一的要求是在此过程中每个已实现的替换操作至少执行一次。每个替换操作的执行次数无上限。\n\n允许的字符包括十进制数字、大小写英文字母。在此问题中，同一字母的大小写被视为不同字符。\n\n在执行完最后一次替换操作后，最终文本中可能出现的**最大不同字符数**是多少？", "inputFormat": "输入的第一行给出测试用例的数量 $\\mathbf{T}$。随后是 $\\mathbf{T}$ 个测试用例。每个测试用例包含两行：第一行是一个字符串 $\\mathbf{S}$ 和一个整数 $\\mathbf{N}$，分别表示初始文本和已实现的替换操作数量。第二行包含 $\\mathbf{N}$ 个两字符的字符串 $\\mathbf{R}_1, \\mathbf{R}_2, \\ldots, \\mathbf{R}_\\mathbf{N}$，表示已实现的替换操作。$\\mathbf{A}_i$ 和 $\\mathbf{B}_i$ 分别是 $\\mathbf{R}_i$ 的第一个和第二个字符。第 $i$ 个替换操作表示将所有 $\\mathbf{A}_i$ 替换为 $\\mathbf{B}_i$。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是在以某种顺序对 $\\mathbf{S}$ 执行所有已实现替换操作（每个至少一次）后，最终文本中可能出现的最大不同字符数。", "hint": "**样例解释**\n\n样例测试集 1 符合测试集 1 的限制。另一个不符合这些限制的样例可能出现在测试集 2 中。\n\n样例 #1 对应题目描述中的例子。注意，若按描述中的顺序执行替换操作，最终文本中有 13 个不同字符；但若以相反顺序各执行一次，则可得到 `CYDEJOMWYRLDFINOLS`，其中包含 14 个不同字符。\n\n在样例 #2 中，按从左到右的顺序各执行一次替换操作，最终文本中可得到 2 个不同字符。\n\n在样例 #3 中，所有替换操作均不影响文本，因此执行顺序无关紧要。最终文本始终为原始的两个字母。注意，替换操作可能包含初始文本中未出现的字符，且初始文本也可能包含替换操作中未出现的字符。\n\n在样例 #4 中，请记住大写 $\\mathbf{B}$ 与小写 $\\mathbf{b}$ 是不同的字符。\n\n在此附加样例中，一种可能的替换顺序为 `X3 2X X2 2X 12 31`。该过程从 $\\mathbf{S}$ 开始依次生成以下字符串：`1234 1234 1X34 1234 1X34 2X34 2X14`。\n\n**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对于所有 $i$，$2 \\leq \\text{初始文本 } \\mathbf{S} \\text{ 的长度} \\leq 1000$。\n- $\\mathbf{S}$ 的每个字符为大写或小写英文字母或十进制数字。\n- 对于所有 $i$，$\\mathbf{A}_i$ 为大写或小写英文字母或十进制数字。\n- 对于所有 $i$，$\\mathbf{B}_i$ 为大写或小写英文字母或十进制数字。\n- 对于所有 $i$，$\\mathbf{A}_i \\neq \\mathbf{B}_i$。\n- 对于所有 $i \\neq j$，$(\\mathbf{A}_i, \\mathbf{B}_i) \\neq (\\mathbf{A}_j, \\mathbf{B}_j)$（每个替换操作唯一）。\n\n**测试集 1（15 分，可见判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 62$。\n- 对于所有 $i \\neq j$，$\\mathbf{B}_i \\neq \\mathbf{B}_j$。\n\n**测试集 2（27 分，隐藏判定）**\n\n- $2 \\leq \\mathbf{N} \\leq 62 \\times 61$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P13075", "type": "P", "difficulty": 0, "samples": [["6 3\n1 3 2 4 1 2\n2 3 4", "5\n9\n21"], ["6 3\n2 2 5 2 2 2\n1 2 10", "0\n9\n21"], ["2 1\n1 2\n1000000", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "NOISG（新加坡）"], "title": "[NOISG 2019] Pilot", "background": "小猫 Rar 终于实现了自己童年的梦想，成为了一名飞行员，想带他的朋友 Dinosaur 进行几次观光飞行。Rar 生活在一个线性的世界中，这个世界可以描述为一列 $N$ 个整数，第 $i$ 个整数 $H_i$ 表示从世界最左端起第 $i$ 座山的高度。", "description": "Rar 有 $Q$ 架飞机，第 $i$ 架飞机的最大巡航高度为 $Y_i$ 米。每次飞行从第 $s$ 座山起飞，到第 $e$ 座山降落，保证 $s \\leq e$，即 Rar 总是朝右飞行。\n\n由于飞机有最大巡航高度，Rar 无法飞越、起飞或降落在高度大于巡航高度的山上。也就是说，若使用第 $j$ 架飞机，Rar 只能在满足 $H_i \\leq Y_j$ 的山上飞行。\n\n对于第 $i$ 架飞机，请你帮助 Rar 计算，他一共可以进行多少次不同的飞行。也就是说，求有多少对 $s,e$ 满足：\n\n- $1 \\leq s \\leq e \\leq N$；\n- $s$ 到 $e$ 之间所有山的高度均不超过该飞机的最大巡航高度。", "inputFormat": "第一行包含两个整数 $N$ 和 $Q$。\n\n第二行包含 $N$ 个整数 $H_1, H_2, \\dots, H_N$。\n\n第三行包含 $Q$ 个整数 $Y_1, Y_2, \\dots, Y_Q$。\n", "outputFormat": "输出 $Q$ 行，第 $i$ 行输出一个整数，表示使用第 $i$ 架飞机时，Rar 可以进行的不同飞行次数。\n", "hint": "【样例解释】\n\n对于样例 1：\n\n对于第一架飞机，$5$ 次飞行分别是：$(1,1)$、$(3,3)$、$(5,5)$、$(5,6)$、$(6,6)$。\n\n对于第二架飞机，$9$ 次飞行分别是：$(1,1)$、$(1,2)$、$(1,3)$、$(2,2)$、$(2,3)$、$(3,3)$、$(5,5)$、$(5,6)$、$(6,6)$。\n\n对于第三架飞机，所有 $21$ 种飞行均可进行。\n\n【数据范围】\n\n- $1 \\leq N, Q, H_i, Y_i \\leq 10^6$\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $3$ | $N = 2,\\ Q = 1$ |\n| $2$ | $10$ | $1 \\leq N, Q \\leq 30$ |\n| $3$ | $12$ | $1 \\leq N, Q \\leq 200$ |\n| $4$ | $15$ | $1 \\leq N, Q \\leq 10^3$ |\n| $5$ | $5$ | $1 \\leq N \\leq 10^5,\\ Q = 1,\\ Y_i = 10^6$ |\n| $6$ | $9$ | $1 \\leq N, Q \\leq 10^5,\\ H_i = i$ |\n| $7$ | $14$ | $1 \\leq N, Q \\leq 10^5,\\ H$ 严格递增 |\n| $8$ | $10$ | $1 \\leq N \\leq 10^5,\\ Q = 1$ |\n| $9$ | $11$ | $1 \\leq N, Q \\leq 10^5$ |\n| $10$ | $11$ | 无额外限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2019] Pilot", "background": "小猫 Rar 终于实现了自己童年的梦想，成为了一名飞行员，想带他的朋友 Dinosaur 进行几次观光飞行。Rar 生活在一个线性的世界中，这个世界可以描述为一列 $N$ 个整数，第 $i$ 个整数 $H_i$ 表示从世界最左端起第 $i$ 座山的高度。", "description": "Rar 有 $Q$ 架飞机，第 $i$ 架飞机的最大巡航高度为 $Y_i$ 米。每次飞行从第 $s$ 座山起飞，到第 $e$ 座山降落，保证 $s \\leq e$，即 Rar 总是朝右飞行。\n\n由于飞机有最大巡航高度，Rar 无法飞越、起飞或降落在高度大于巡航高度的山上。也就是说，若使用第 $j$ 架飞机，Rar 只能在满足 $H_i \\leq Y_j$ 的山上飞行。\n\n对于第 $i$ 架飞机，请你帮助 Rar 计算，他一共可以进行多少次不同的飞行。也就是说，求有多少对 $s,e$ 满足：\n\n- $1 \\leq s \\leq e \\leq N$；\n- $s$ 到 $e$ 之间所有山的高度均不超过该飞机的最大巡航高度。", "inputFormat": "第一行包含两个整数 $N$ 和 $Q$。\n\n第二行包含 $N$ 个整数 $H_1, H_2, \\dots, H_N$。\n\n第三行包含 $Q$ 个整数 $Y_1, Y_2, \\dots, Y_Q$。\n", "outputFormat": "输出 $Q$ 行，第 $i$ 行输出一个整数，表示使用第 $i$ 架飞机时，Rar 可以进行的不同飞行次数。\n", "hint": "【样例解释】\n\n对于样例 1：\n\n对于第一架飞机，$5$ 次飞行分别是：$(1,1)$、$(3,3)$、$(5,5)$、$(5,6)$、$(6,6)$。\n\n对于第二架飞机，$9$ 次飞行分别是：$(1,1)$、$(1,2)$、$(1,3)$、$(2,2)$、$(2,3)$、$(3,3)$、$(5,5)$、$(5,6)$、$(6,6)$。\n\n对于第三架飞机，所有 $21$ 种飞行均可进行。\n\n【数据范围】\n\n- $1 \\leq N, Q, H_i, Y_i \\leq 10^6$\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $3$ | $N = 2,\\ Q = 1$ |\n| $2$ | $10$ | $1 \\leq N, Q \\leq 30$ |\n| $3$ | $12$ | $1 \\leq N, Q \\leq 200$ |\n| $4$ | $15$ | $1 \\leq N, Q \\leq 10^3$ |\n| $5$ | $5$ | $1 \\leq N \\leq 10^5,\\ Q = 1,\\ Y_i = 10^6$ |\n| $6$ | $9$ | $1 \\leq N, Q \\leq 10^5,\\ H_i = i$ |\n| $7$ | $14$ | $1 \\leq N, Q \\leq 10^5,\\ H$ 严格递增 |\n| $8$ | $10$ | $1 \\leq N \\leq 10^5,\\ Q = 1$ |\n| $9$ | $11$ | $1 \\leq N, Q \\leq 10^5$ |\n| $10$ | $11$ | 无额外限制 |", "locale": "zh-CN"}}}
{"pid": "P13076", "type": "P", "difficulty": 0, "samples": [["11 3\n2 2 3\n1 7\n2 4 1", "3"], ["10 3\n3 1 5 1\n4 2 2 3 1\n3 1 6 2", "6"], ["10 1\n1 4", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "NOISG（新加坡）"], "title": "[NOISG 2019] Lasers", "background": "熊猫先生知道小猫非常喜欢激光玩具，于是他决定给 Rar the Cat 买一个激光玩具。", "description": "这个激光玩具的顶部有 $L$ 个间距均匀的激光，全部朝下。第 $1$ 个激光距离左边缘 $0.5$ 个单位，第 $L$ 个激光距离右边缘 $0.5$ 个单位，相邻激光之间距离为 $1$ 个单位。\n\n该玩具共有 $R$ 排滑动的挡板，每排有若干不重叠的挡板。具体来说：\n\n- 每排有若干长度为正整数的挡板，总长度不超过 $L$。\n- 同一排内，所有挡板可以整体平移，但挡板之间相对位置不变，且不会重叠。\n- 一个宽度为 $x$ 的挡板可以完全阻挡连续 $x$ 个激光。\n\n请你计算，在所有挡板可能的配置中，有多少个激光会始终被至少一个挡板阻挡。", "inputFormat": "第一行包含两个整数 $L$ 和 $R$。\n\n接下来 $R$ 行描述每排的挡板情况，每行格式如下：\n\n- 一个整数 $X$，表示该排有 $X$ 个挡板。\n- 接下来 $X$ 个整数，依次表示每个挡板的宽度，第一个整数是最左边挡板的宽度。\n\n保证每排所有挡板的总宽度不超过 $L$。", "outputFormat": "输出一个整数，表示始终被至少一个挡板阻挡的激光数量。", "hint": "【样例解释】\n\n对于样例 1：\n\n第 $2$ 排有一个宽度为 $7$ 的挡板，它无论怎么移动，第 $5$、$6$、$7$ 号激光总会被阻挡。\n\n对于样例 2：\n\n第 $3$、$4$、$5$、$6$、$7$、$9$ 号激光始终被至少一个挡板阻挡。\n\n对于样例 3：\n\n所有激光在至少一种挡板配置下都可以通过。\n\n【数据范围】\n\n- $1 \\leq R \\leq 5 \\times 10^5$\n- $1 \\leq L \\leq 10^9$\n- $1 \\leq \\sum X \\leq 5 \\times 10^5$\n- 每排所有挡板宽度和不超过 $L$\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $10$ | $R = 1,\\ X = 1$ |\n| $2$ | $14$ | $X = 1$ |\n| $3$ | $20$ | $R = 2,\\ 1 \\leq L \\leq 10^6$ |\n| $4$ | $21$ | $1 \\leq L \\leq 10^3,\\ 1 \\leq \\sum X \\leq 10^3$ |\n| $5$ | $22$ | $1 \\leq L \\leq 10^6$ |\n| $6$ | $13$ | 无额外限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2019] Lasers", "background": "熊猫先生知道小猫非常喜欢激光玩具，于是他决定给 Rar the Cat 买一个激光玩具。", "description": "这个激光玩具的顶部有 $L$ 个间距均匀的激光，全部朝下。第 $1$ 个激光距离左边缘 $0.5$ 个单位，第 $L$ 个激光距离右边缘 $0.5$ 个单位，相邻激光之间距离为 $1$ 个单位。\n\n该玩具共有 $R$ 排滑动的挡板，每排有若干不重叠的挡板。具体来说：\n\n- 每排有若干长度为正整数的挡板，总长度不超过 $L$。\n- 同一排内，所有挡板可以整体平移，但挡板之间相对位置不变，且不会重叠。\n- 一个宽度为 $x$ 的挡板可以完全阻挡连续 $x$ 个激光。\n\n请你计算，在所有挡板可能的配置中，有多少个激光会始终被至少一个挡板阻挡。", "inputFormat": "第一行包含两个整数 $L$ 和 $R$。\n\n接下来 $R$ 行描述每排的挡板情况，每行格式如下：\n\n- 一个整数 $X$，表示该排有 $X$ 个挡板。\n- 接下来 $X$ 个整数，依次表示每个挡板的宽度，第一个整数是最左边挡板的宽度。\n\n保证每排所有挡板的总宽度不超过 $L$。", "outputFormat": "输出一个整数，表示始终被至少一个挡板阻挡的激光数量。", "hint": "【样例解释】\n\n对于样例 1：\n\n第 $2$ 排有一个宽度为 $7$ 的挡板，它无论怎么移动，第 $5$、$6$、$7$ 号激光总会被阻挡。\n\n对于样例 2：\n\n第 $3$、$4$、$5$、$6$、$7$、$9$ 号激光始终被至少一个挡板阻挡。\n\n对于样例 3：\n\n所有激光在至少一种挡板配置下都可以通过。\n\n【数据范围】\n\n- $1 \\leq R \\leq 5 \\times 10^5$\n- $1 \\leq L \\leq 10^9$\n- $1 \\leq \\sum X \\leq 5 \\times 10^5$\n- 每排所有挡板宽度和不超过 $L$\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $10$ | $R = 1,\\ X = 1$ |\n| $2$ | $14$ | $X = 1$ |\n| $3$ | $20$ | $R = 2,\\ 1 \\leq L \\leq 10^6$ |\n| $4$ | $21$ | $1 \\leq L \\leq 10^3,\\ 1 \\leq \\sum X \\leq 10^3$ |\n| $5$ | $22$ | $1 \\leq L \\leq 10^6$ |\n| $6$ | $13$ | 无额外限制 |", "locale": "zh-CN"}}}
{"pid": "P13077", "type": "P", "difficulty": 5, "samples": [["6 1\n1 -2 3 -1 5 -6", "7"], ["6 2\n1 2 3 -10 5 6", "17"], ["6 4\n-1 -2 -1 0 -5 -1", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2019", "线段树", "NOISG（新加坡）"], "title": "[NOISG 2019] Feast", "background": "", "description": "Gug 正在为他的朋友们准备一场盛宴。盛宴由 $N$ 盘食物组成，按顺序排列，第 $i$ 盘食物若被食用，可带来 $A_i$ 点满足感。部分食物可能已经腐烂，因此 $A_i$ 可能为负数。\n\n共有 $K$ 个人参加盛宴，每人将被分配一段连续的食物区间食用。该区间可以为空，且不同人的区间不得重叠，每盘食物最多只能被食用一次。\n\nGug 希望合理分配食物，使得所有被食用的食物带来的满足感总和最大。\n\n请你计算，最大满足感总和是多少。", "inputFormat": "第一行包含两个整数 $N$ 和 $K$。\n\n第二行包含 $N$ 个整数 $A_1, A_2, \\dots, A_N$。\n", "outputFormat": "输出一个整数，表示最大满足感总和。", "hint": "【样例解释】\n\n对于样例 1：\n\n将唯一一人分配到区间 $[3,-1,5]$，满足感总和为 $7$。\n\n对于样例 2：\n\n选择连续区间 $[1,2,3]$ 和 $[5,6]$，总和最大。\n\n对于样例 3：\n\n所有满足感均不为正，最优选择是所有人都选择空区间，总和为 $0$。\n\n【数据范围】\n\n- $1 \\leq K \\leq N \\leq 3 \\times 10^5$\n- $0 \\leq |A_i| \\leq 10^9$\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $4$ | $A_i \\geq 0$ |\n| $2$ | $8$ | 至多有一个位置 $A_i < 0$ |\n| $3$ | $18$ | $K = 1$ |\n| $4$ | $10$ | $1 \\leq K \\leq N \\leq 80$ |\n| $5$ | $11$ | $1 \\leq K \\leq N \\leq 300$ |\n| $6$ | $20$ | $1 \\leq K \\leq N \\leq 2000$ |\n| $7$ | $29$ | 无额外限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2019] Feast", "background": "", "description": "Gug 正在为他的朋友们准备一场盛宴。盛宴由 $N$ 盘食物组成，按顺序排列，第 $i$ 盘食物若被食用，可带来 $A_i$ 点满足感。部分食物可能已经腐烂，因此 $A_i$ 可能为负数。\n\n共有 $K$ 个人参加盛宴，每人将被分配一段连续的食物区间食用。该区间可以为空，且不同人的区间不得重叠，每盘食物最多只能被食用一次。\n\nGug 希望合理分配食物，使得所有被食用的食物带来的满足感总和最大。\n\n请你计算，最大满足感总和是多少。", "inputFormat": "第一行包含两个整数 $N$ 和 $K$。\n\n第二行包含 $N$ 个整数 $A_1, A_2, \\dots, A_N$。\n", "outputFormat": "输出一个整数，表示最大满足感总和。", "hint": "【样例解释】\n\n对于样例 1：\n\n将唯一一人分配到区间 $[3,-1,5]$，满足感总和为 $7$。\n\n对于样例 2：\n\n选择连续区间 $[1,2,3]$ 和 $[5,6]$，总和最大。\n\n对于样例 3：\n\n所有满足感均不为正，最优选择是所有人都选择空区间，总和为 $0$。\n\n【数据范围】\n\n- $1 \\leq K \\leq N \\leq 3 \\times 10^5$\n- $0 \\leq |A_i| \\leq 10^9$\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $4$ | $A_i \\geq 0$ |\n| $2$ | $8$ | 至多有一个位置 $A_i < 0$ |\n| $3$ | $18$ | $K = 1$ |\n| $4$ | $10$ | $1 \\leq K \\leq N \\leq 80$ |\n| $5$ | $11$ | $1 \\leq K \\leq N \\leq 300$ |\n| $6$ | $20$ | $1 \\leq K \\leq N \\leq 2000$ |\n| $7$ | $29$ | 无额外限制 |", "locale": "zh-CN"}}}
{"pid": "P13078", "type": "P", "difficulty": 6, "samples": [["4 5\n3 4\n1 2\n2 3\n1 3\n1 4\n2 4 5", "3 4 5 1 2"], ["4 4\n1 2\n1 4\n2 3\n3 4\n1 3 4", "1 4 2 3"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "并查集", "NOISG（新加坡）"], "title": "[NOISG 2019] Rigged Roads", "background": "Silvermill 最近财政紧张，市长 Peanut 打算拆除部分道路以节省养护成本。", "description": "Silvermill 可以看作一个城市，包含 $N$ 个道路交汇点和 $E$ 条道路，第 $i$ 条道路连接交汇点 $A_i$ 和 $B_i$。交汇点编号为 $1$ 到 $N$，道路编号为 $1$ 到 $E$。保证任意两个交汇点之间总可以直接或间接到达，且没有两条道路连接同一对交汇点。\n\n为了方便决策，Peanut 请你帮忙评估各条道路的养护成本。你的任务是：\n\n你需要给出一个长度为 $E$ 的排列 $W = (W_1, W_2, \\dots, W_E)$，表示第 $i$ 条道路的养护成本为 $W_i$，其中 $W$ 是 $1$ 到 $E$ 的一个排列。\n\nPeanut 会根据你提供的养护成本，保留一组道路，满足：\n\n- 所有交汇点仍然连通；\n- 保留道路的养护成本之和最小。\n\n即，Peanut 实际上会选择最小生成树，且由于所有成本互不相同，最小生成树唯一。\n\n但你另有所图。你想让最终被保留的道路集合恰好是你指定的一组道路 $R$，且 $R$ 恰好构成一棵生成树。通过合理选择 $W$，你可以让 $R$ 恰好成为最小生成树。\n\n请你计算，满足上述条件的字典序最小的排列 $W$。\n\n给定城市结构和你想保留的道路集合 $R$，请输出字典序最小的养护成本分配方案 $W$，使得 $R$ 成为唯一的最小生成树。\n\n注：若存在第 $1 \\leq p \\leq E$ 使得 $W_p < W'_p$，且 $W_1 = W'_1, \\dots, W_{p-1} = W'_{p-1}$，则 $W$ 的字典序小于 $W'$。", "inputFormat": "第一行包含两个整数 $N$ 和 $E$。\n\n接下来 $E$ 行，每行两个整数 $A_i$ 和 $B_i$，表示第 $i$ 条道路连接的两个交汇点。\n\n最后一行包含 $N - 1$ 个整数，表示你想保留的道路编号，构成的集合 $R$。", "outputFormat": "输出 $E$ 个整数，表示字典序最小的排列 $W$，第 $i$ 个数是第 $i$ 条道路的养护成本。", "hint": "【数据范围】\n\n- $1 \\leq N, E \\leq 3 \\times 10^5$\n- $1 \\leq A_i \\neq B_i \\leq N$\n- $1 \\leq R_i \\leq E$\n- 仅使用 $R$ 中的道路也能保证所有交汇点连通。\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $8$ | $1 \\leq N, E \\leq 9$ |\n| $2$ | $19$ | $1 \\leq N, E \\leq 10^3$ |\n| $3$ | $9$ | $A_{R_i} = 1,\\ B_{R_i} = i + 1$，即 $R$ 构成一棵星形树 |\n| $4$ | $10$ | $A_{R_i} = i,\\ B_{R_i} = i + 1$，即 $R$ 构成一条链 |\n| $5$ | $10$ | $E = N,\\ A_i = i,\\ B_i = i \\bmod N + 1$ |\n| $6$ | $12$ | $E = N$ |\n| $7$ | $32$ | 无额外限制 |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2019] Rigged Roads", "background": "Silvermill 最近财政紧张，市长 Peanut 打算拆除部分道路以节省养护成本。", "description": "Silvermill 可以看作一个城市，包含 $N$ 个道路交汇点和 $E$ 条道路，第 $i$ 条道路连接交汇点 $A_i$ 和 $B_i$。交汇点编号为 $1$ 到 $N$，道路编号为 $1$ 到 $E$。保证任意两个交汇点之间总可以直接或间接到达，且没有两条道路连接同一对交汇点。\n\n为了方便决策，Peanut 请你帮忙评估各条道路的养护成本。你的任务是：\n\n你需要给出一个长度为 $E$ 的排列 $W = (W_1, W_2, \\dots, W_E)$，表示第 $i$ 条道路的养护成本为 $W_i$，其中 $W$ 是 $1$ 到 $E$ 的一个排列。\n\nPeanut 会根据你提供的养护成本，保留一组道路，满足：\n\n- 所有交汇点仍然连通；\n- 保留道路的养护成本之和最小。\n\n即，Peanut 实际上会选择最小生成树，且由于所有成本互不相同，最小生成树唯一。\n\n但你另有所图。你想让最终被保留的道路集合恰好是你指定的一组道路 $R$，且 $R$ 恰好构成一棵生成树。通过合理选择 $W$，你可以让 $R$ 恰好成为最小生成树。\n\n请你计算，满足上述条件的字典序最小的排列 $W$。\n\n给定城市结构和你想保留的道路集合 $R$，请输出字典序最小的养护成本分配方案 $W$，使得 $R$ 成为唯一的最小生成树。\n\n注：若存在第 $1 \\leq p \\leq E$ 使得 $W_p < W'_p$，且 $W_1 = W'_1, \\dots, W_{p-1} = W'_{p-1}$，则 $W$ 的字典序小于 $W'$。", "inputFormat": "第一行包含两个整数 $N$ 和 $E$。\n\n接下来 $E$ 行，每行两个整数 $A_i$ 和 $B_i$，表示第 $i$ 条道路连接的两个交汇点。\n\n最后一行包含 $N - 1$ 个整数，表示你想保留的道路编号，构成的集合 $R$。", "outputFormat": "输出 $E$ 个整数，表示字典序最小的排列 $W$，第 $i$ 个数是第 $i$ 条道路的养护成本。", "hint": "【数据范围】\n\n- $1 \\leq N, E \\leq 3 \\times 10^5$\n- $1 \\leq A_i \\neq B_i \\leq N$\n- $1 \\leq R_i \\leq E$\n- 仅使用 $R$ 中的道路也能保证所有交汇点连通。\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $8$ | $1 \\leq N, E \\leq 9$ |\n| $2$ | $19$ | $1 \\leq N, E \\leq 10^3$ |\n| $3$ | $9$ | $A_{R_i} = 1,\\ B_{R_i} = i + 1$，即 $R$ 构成一棵星形树 |\n| $4$ | $10$ | $A_{R_i} = i,\\ B_{R_i} = i + 1$，即 $R$ 构成一条链 |\n| $5$ | $10$ | $E = N,\\ A_i = i,\\ B_i = i \\bmod N + 1$ |\n| $6$ | $12$ | $E = N$ |\n| $7$ | $32$ | 无额外限制 |", "locale": "zh-CN"}}}
{"pid": "P13079", "type": "P", "difficulty": 0, "samples": [["6 3 2 100 2", "3 4 1 5 2 6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "交互题", "NOISG（新加坡）"], "title": "[NOISG 2019] Shuffle【交互题待配置】", "background": "", "description": "Lim Li 非常喜欢动漫，最近她在 Amazon 购买了一整季的《干物妹小埋》。这季共有 $N$ 集，每集刻录在一张光盘上，光盘编号为 $1$ 到 $N$，每集的集数也是 $1$ 到 $N$。\n\n然而，Lim Li 发现由于生产问题，光盘编号与剧集集数不对应！Amazon 告诉她，剧集只是被打乱顺序，所有剧集都在，没有缺失。\n\n为了避免剧透，Lim Li 不愿自己播放光盘来确认剧集顺序。于是她决定请朋友 Rar the Cat 帮忙。具体流程如下：\n\n- Lim Li 将 $N$ 张光盘分为 $B$ 个盒子，每个盒子装 $K$ 张光盘（$N = B \\times K$）。\n- 这些盒子寄给 Rar。在运输过程中，盒子之间的顺序和每个盒子内部光盘的顺序可能会被打乱。\n- Rar 接收到盒子后，会播放每张光盘，并记录下盒子内各张光盘对应的剧集集数，然后将每个盒子的结果分别写在 $B$ 张纸上寄回给 Lim Li。\n- 所有光盘最终被寄回给 Lim Li。\n\n整个过程最多允许进行 $Q$ 次。Rar 如果不耐烦就不再帮忙。\n\n你的任务是，帮助 Lim Li 在尽量少的查询次数内，确定每张光盘上的剧集集数。\n\n本题为交互题，请实现以下函数：\n\n- C++: `vector<int> solve(int N, int B, int K, int Q, int ST)`\n- ~~Java: `public int[] solve(int N, int B, int K, int Q, int ST)`~~\n\n你可以调用如下交互函数：\n\n- C++: `vector<vector<int>> shuffle(vector<vector<int>> boxes)`\n- ~~Java: `public static int[][] shuffle(int[][] boxes)`~~\n\n参数 `boxes` 是 $B$ 个数组，每个数组包含 $K$ 个整数，表示 Lim Li 寄出的光盘编号分组。\n\n返回值为 $B$ 个数组，每个数组 $K$ 个整数，表示收到盒子后，每张光盘的剧集集数。\n\n注意：\n\n- `boxes` 传入参数不会被修改。\n- 超过 $Q$ 次调用或参数非法，判定为 Wrong Answer。", "inputFormat": "所有必要信息通过函数参数提供。", "outputFormat": "程序通过返回值完成答案，无需额外输出。", "hint": "【样例解释】\n\n假设 $N = 6$，$B = 3$，$K = 2$，$Q = 100$，剧集顺序为 $[3, 1, 4, 5, 2, 6]$。\n\n调用 `solve(6, 3, 2, 100, 2)`。\n\n一次可能的交互：\n\n- 调用 `shuffle([[1, 2], [3, 4], [5, 6]])`，返回 `[[6, 2], [5, 4], [3, 1]]`。\n- 调用 `shuffle([[2, 6], [3, 1], [5, 4]])`，返回 `[[6, 1], [2, 5], [4, 3]]`。\n- 调用 `shuffle([[6, 5], [4, 2], [3, 1]])`，返回 `[[5, 1], [3, 4], [2, 6]]`。\n\n最终确定顺序为 $[3, 4, 1, 5, 2, 6]$，输出该数组即为正确答案。\n\n【数据范围】\n\n- $B, K \\geq 2$\n- $N \\geq 6$\n- $N = B \\times K$\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $2$ | $N = 6,\\ B = 2,\\ K = 3,\\ Q = 100$ |\n| $2$ | $3$ | $N = 6,\\ B = 3,\\ K = 2,\\ Q = 100$ |\n| $3$ | $12$ | $N \\leq 1000,\\ Q = 12$，盒子顺序保持不变 |\n| $4$ | $16$ | $N \\leq 1000,\\ K = 2,\\ Q = 4$ |\n| $5$ | $15$ | $N \\leq 1000,\\ B = 2,\\ Q = 12$ |\n| $6$ | $52$ | $N \\leq 1000,\\ Q = 2000,\\ B,K > 2$，具体见评分规则 |\n\n【评分规则】\n\n对于子任务 6，根据查询次数 $q$ 计分：\n\n- $q > 2000$，得 $0$ 分；\n- $500 < q \\leq 2000$，得 $8$ 分；\n- $50 < q \\leq 500$，得 $17$ 分；\n- $9 < q \\leq 50$，得 $22 + 30 \\times \\left(\\dfrac{50 - q}{41}\\right)^2$ 分；\n- $q \\leq 9$，得 $52$ 分。\n\n【测试说明】\n\n官方提供裁判程序、头文件、模板与样例测试数据。请严格使用官方提供的测试脚本。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2019] Shuffle【交互题待配置】", "background": "", "description": "Lim Li 非常喜欢动漫，最近她在 Amazon 购买了一整季的《干物妹小埋》。这季共有 $N$ 集，每集刻录在一张光盘上，光盘编号为 $1$ 到 $N$，每集的集数也是 $1$ 到 $N$。\n\n然而，Lim Li 发现由于生产问题，光盘编号与剧集集数不对应！Amazon 告诉她，剧集只是被打乱顺序，所有剧集都在，没有缺失。\n\n为了避免剧透，Lim Li 不愿自己播放光盘来确认剧集顺序。于是她决定请朋友 Rar the Cat 帮忙。具体流程如下：\n\n- Lim Li 将 $N$ 张光盘分为 $B$ 个盒子，每个盒子装 $K$ 张光盘（$N = B \\times K$）。\n- 这些盒子寄给 Rar。在运输过程中，盒子之间的顺序和每个盒子内部光盘的顺序可能会被打乱。\n- Rar 接收到盒子后，会播放每张光盘，并记录下盒子内各张光盘对应的剧集集数，然后将每个盒子的结果分别写在 $B$ 张纸上寄回给 Lim Li。\n- 所有光盘最终被寄回给 Lim Li。\n\n整个过程最多允许进行 $Q$ 次。Rar 如果不耐烦就不再帮忙。\n\n你的任务是，帮助 Lim Li 在尽量少的查询次数内，确定每张光盘上的剧集集数。\n\n本题为交互题，请实现以下函数：\n\n- C++: `vector<int> solve(int N, int B, int K, int Q, int ST)`\n- ~~Java: `public int[] solve(int N, int B, int K, int Q, int ST)`~~\n\n你可以调用如下交互函数：\n\n- C++: `vector<vector<int>> shuffle(vector<vector<int>> boxes)`\n- ~~Java: `public static int[][] shuffle(int[][] boxes)`~~\n\n参数 `boxes` 是 $B$ 个数组，每个数组包含 $K$ 个整数，表示 Lim Li 寄出的光盘编号分组。\n\n返回值为 $B$ 个数组，每个数组 $K$ 个整数，表示收到盒子后，每张光盘的剧集集数。\n\n注意：\n\n- `boxes` 传入参数不会被修改。\n- 超过 $Q$ 次调用或参数非法，判定为 Wrong Answer。", "inputFormat": "所有必要信息通过函数参数提供。", "outputFormat": "程序通过返回值完成答案，无需额外输出。", "hint": "【样例解释】\n\n假设 $N = 6$，$B = 3$，$K = 2$，$Q = 100$，剧集顺序为 $[3, 1, 4, 5, 2, 6]$。\n\n调用 `solve(6, 3, 2, 100, 2)`。\n\n一次可能的交互：\n\n- 调用 `shuffle([[1, 2], [3, 4], [5, 6]])`，返回 `[[6, 2], [5, 4], [3, 1]]`。\n- 调用 `shuffle([[2, 6], [3, 1], [5, 4]])`，返回 `[[6, 1], [2, 5], [4, 3]]`。\n- 调用 `shuffle([[6, 5], [4, 2], [3, 1]])`，返回 `[[5, 1], [3, 4], [2, 6]]`。\n\n最终确定顺序为 $[3, 4, 1, 5, 2, 6]$，输出该数组即为正确答案。\n\n【数据范围】\n\n- $B, K \\geq 2$\n- $N \\geq 6$\n- $N = B \\times K$\n\n| 子任务编号 | 分值 | 额外限制 |\n| :---: | :---: | :---: |\n| $1$ | $2$ | $N = 6,\\ B = 2,\\ K = 3,\\ Q = 100$ |\n| $2$ | $3$ | $N = 6,\\ B = 3,\\ K = 2,\\ Q = 100$ |\n| $3$ | $12$ | $N \\leq 1000,\\ Q = 12$，盒子顺序保持不变 |\n| $4$ | $16$ | $N \\leq 1000,\\ K = 2,\\ Q = 4$ |\n| $5$ | $15$ | $N \\leq 1000,\\ B = 2,\\ Q = 12$ |\n| $6$ | $52$ | $N \\leq 1000,\\ Q = 2000,\\ B,K > 2$，具体见评分规则 |\n\n【评分规则】\n\n对于子任务 6，根据查询次数 $q$ 计分：\n\n- $q > 2000$，得 $0$ 分；\n- $500 < q \\leq 2000$，得 $8$ 分；\n- $50 < q \\leq 500$，得 $17$ 分；\n- $9 < q \\leq 50$，得 $22 + 30 \\times \\left(\\dfrac{50 - q}{41}\\right)^2$ 分；\n- $q \\leq 9$，得 $52$ 分。\n\n【测试说明】\n\n官方提供裁判程序、头文件、模板与样例测试数据。请严格使用官方提供的测试脚本。", "locale": "zh-CN"}}}
{"pid": "P13080", "type": "P", "difficulty": 2, "samples": [["2\n1 0\n4 0", "3 0"], ["6\n1 0\n3 0\n5 0\n7 0\n9 0\n11 0\n", "7 0"], ["9\n1 16\n3 12\n5 6\n7 10\n9 8\n11 4\n13 14\n15 2\n17 18\n", "9 10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2017", "Special Judge", "排序", "NOISG（新加坡）"], "title": "[NOISG 2017] Best Places / 最佳选址", "background": "译自 [NOISG 2017 A.Best Places](https://github.com/noisg/sg_noi_archive/tree/master/2017/bestplace)。", "description": "IOI 2020 将在新加坡举行！举办这样的国际赛事，选择举办地自然成了十分重要的事。\n\n现在，组委会拿到了一份选手住址名单，共有 $N$ 位选手，他们所在的城市可以看作一个坐标系，第 $i$ 位选手住在 $(X_i,Y_i)$。\n\n为了选手们方便参加比赛，组委会想要选择一个点 $(X,Y)$，使得所有 $|X-X_i|+|Y-Y_i|$ 之和最小。\n\n请你输出这个 $(X,Y)$。如果有多种可能的答案，输出任意一个即可。\n\n**注意：最终答案 $(X,Y)$ 可能与某个 $(X_i,Y_i)$ 相同。一个 $(X_i,Y_i)$ 点上也可能不止一位选手。你应该认为住在同一个点的选手分别单独去赛场，而不是将他们视为同一个人。**", "inputFormat": "第一行一个正整数 $N$。\n\n接下来 $N$ 行，每行两个整数 $X_i,Y_i$。", "outputFormat": "一行两个整数 $X,Y$。", "hint": "### 【样例解释】\n\n对于样例一，不难发现 $(1,0),(2,0),(4,0)$ 也是正确的输出。无论选择 $(1,0),(2,0),(3,0)$ 还是 $(4,0)$，都有 $\\sum\\limits_{i=1}^N(|X-X_i|+|Y-Y_i|)=3$。可以证明没有 $(X,Y)$ 可以使 $|X-X_i|+|Y-Y_i|$ 之和更小。\n\n对于样例二，$(5,0),(6,0)$ 也是正确的输出。\n\n对于样例三，可以证明这是唯一正确的输出。\n\n### 【数据范围】\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|$N$|$X_i,Y_i$|\n|:-:|:-:|:-:|:-:|\n|$1$|$3$|$N=2$|$0\\le X_i,Y_i\\le10^9$|\n|$2$|$20$|$2\\le N\\le1000$|$0\\le X_i\\le1000,Y_i=0$\n|$3$|$28$|$2\\le N\\le10^6$|$0 \\le X_i\\le10^9,Y_i=0$|\n|$4$|$13$|$2\\le N\\le100$|$0\\le X_i,Y_i\\le100$|\n|$5$|$17$|$2\\le N\\le1000$|$0\\le X_i,Y_i\\le10^9$|\n|$6$|$19$|$2\\le N\\le10^6$|$0\\le X_i,Y_i\\le10^9$|\n\n对于 $100\\%$ 的数据，$2\\le N\\le10^6$，$0\\le X_i,Y_i\\le10^9$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2017] Best Places / 最佳选址", "background": "译自 [NOISG 2017 A.Best Places](https://github.com/noisg/sg_noi_archive/tree/master/2017/bestplace)。", "description": "IOI 2020 将在新加坡举行！举办这样的国际赛事，选择举办地自然成了十分重要的事。\n\n现在，组委会拿到了一份选手住址名单，共有 $N$ 位选手，他们所在的城市可以看作一个坐标系，第 $i$ 位选手住在 $(X_i,Y_i)$。\n\n为了选手们方便参加比赛，组委会想要选择一个点 $(X,Y)$，使得所有 $|X-X_i|+|Y-Y_i|$ 之和最小。\n\n请你输出这个 $(X,Y)$。如果有多种可能的答案，输出任意一个即可。\n\n**注意：最终答案 $(X,Y)$ 可能与某个 $(X_i,Y_i)$ 相同。一个 $(X_i,Y_i)$ 点上也可能不止一位选手。你应该认为住在同一个点的选手分别单独去赛场，而不是将他们视为同一个人。**", "inputFormat": "第一行一个正整数 $N$。\n\n接下来 $N$ 行，每行两个整数 $X_i,Y_i$。", "outputFormat": "一行两个整数 $X,Y$。", "hint": "### 【样例解释】\n\n对于样例一，不难发现 $(1,0),(2,0),(4,0)$ 也是正确的输出。无论选择 $(1,0),(2,0),(3,0)$ 还是 $(4,0)$，都有 $\\sum\\limits_{i=1}^N(|X-X_i|+|Y-Y_i|)=3$。可以证明没有 $(X,Y)$ 可以使 $|X-X_i|+|Y-Y_i|$ 之和更小。\n\n对于样例二，$(5,0),(6,0)$ 也是正确的输出。\n\n对于样例三，可以证明这是唯一正确的输出。\n\n### 【数据范围】\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|$N$|$X_i,Y_i$|\n|:-:|:-:|:-:|:-:|\n|$1$|$3$|$N=2$|$0\\le X_i,Y_i\\le10^9$|\n|$2$|$20$|$2\\le N\\le1000$|$0\\le X_i\\le1000,Y_i=0$\n|$3$|$28$|$2\\le N\\le10^6$|$0 \\le X_i\\le10^9,Y_i=0$|\n|$4$|$13$|$2\\le N\\le100$|$0\\le X_i,Y_i\\le100$|\n|$5$|$17$|$2\\le N\\le1000$|$0\\le X_i,Y_i\\le10^9$|\n|$6$|$19$|$2\\le N\\le10^6$|$0\\le X_i,Y_i\\le10^9$|\n\n对于 $100\\%$ 的数据，$2\\le N\\le10^6$，$0\\le X_i,Y_i\\le10^9$。", "locale": "zh-CN"}}}
{"pid": "P13081", "type": "P", "difficulty": 4, "samples": [["5\n0 1 1\n1 2 2\n2 3 3\n3 4 4\n1\n4 0 3 1 2", "10"], ["6\n4 0 4\n0 1 2\n1 3 9\n3 5 1\n3 2 5\n2\n4 0 3 5 2\n0 4 1 3 5", "21\n16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "倍增", "最近公共祖先 LCA", "NOISG（新加坡）"], "title": "[NOISG 2017] Roadside Advertisements / 广告投放", "background": "译自 [NOISG 2017 B.Roadside Advertisements](https://github.com/noisg/sg_noi_archive/tree/master/2017/roadsideadverts)。\n\n------------\n\nNOISG2017 拥有 $5$ 个赞助商。", "description": "新加坡的地图可以视为一张 $V$ 个点 $V-1$ 条边的图，其中点的编号为 $0,1,\\cdots V-1$。保证任意两点间有且仅有唯一路径。\n\n已知 $5$ 个赞助商分别位于 $a,b,c,d,e$ 号点，NOISG 主席 TAN Sun-Teck 想要在一些边上投放广告，使得 $5$ 个赞助商两两间最短路径上的每一条边都投放了广告。\n\n对于每条边，在该边上投放广告的成本是已知的。投放广告的总成本是每条需投放广告的道路成本的总和。$Q$ 次询问，每次给定 $a,b,c,d,e$，求满足要求的最低总成本。", "inputFormat": "第一行一个正整数 $V$。\n\n接下来 $V−1$ 行，每行三个整数 $u,v,w$，表示 $u$ 号点和 $v$ 号点间有一条道路相连，并且在这条道路上投放广告需要 $w$ 新加坡元。\n\n接下来一行包含一个正整数 $Q$，表示询问次数。\n\n接下来 $Q$ 行，每行五个整数 $a,b,c,d,e$，表示 $5$ 个赞助商的位置。保证 $a,b,c,d,e$ 两两不同。", "outputFormat": "对于每次询问，一行一个整数表示投放广告的最低总成本。", "hint": "### 【样例 2 解释】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bflmat2l.png)\n\n对于第一次询问，$5$ 个赞助商分别位于 $4,0,3,5,2$ 号点（请注意编号不一定按升序排列）。易知我们需要在每一条路边投放广告，最低成本是所有道路的成本之和，即 $4+2+9+1+5=21$。\n\n对于第二次询问，$5$ 个赞助商位于 $0,4,1,3,5$ 号点。这一次我们不需要在 $(3,2)$ 这条道路上投放广告。因此总成本为 $21−5=16$。\n\n### 【数据范围】\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|$V,Q$ 的范围|特殊性质|\n|:-:|:-:|:-:|:-:|\n|$1$|$7$|$V=5,Q=1$|无|\n|$2$|$23$|$5\\le V\\le5\\times10^4,1\\le Q\\le 10^4$|有|\n|$3$|$40$|$5\\le V\\le5\\times10^4,1\\le Q\\le 100$|无|\n|$4$|$30$|$5\\le V\\le5\\times10^4,1\\le Q\\le 10^4$|无|\n\n特殊性质：保证每个点最多与 $2$ 个点间有道路相连。\n\n对于所有数据，保证 $5\\le V\\le5\\times10^4$，$1\\le Q\\le 10^4$，$0\\le u,v<V$ 且 $1\\le w\\le1000$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2017] Roadside Advertisements / 广告投放", "background": "译自 [NOISG 2017 B.Roadside Advertisements](https://github.com/noisg/sg_noi_archive/tree/master/2017/roadsideadverts)。\n\n------------\n\nNOISG2017 拥有 $5$ 个赞助商。", "description": "新加坡的地图可以视为一张 $V$ 个点 $V-1$ 条边的图，其中点的编号为 $0,1,\\cdots V-1$。保证任意两点间有且仅有唯一路径。\n\n已知 $5$ 个赞助商分别位于 $a,b,c,d,e$ 号点，NOISG 主席 TAN Sun-Teck 想要在一些边上投放广告，使得 $5$ 个赞助商两两间最短路径上的每一条边都投放了广告。\n\n对于每条边，在该边上投放广告的成本是已知的。投放广告的总成本是每条需投放广告的道路成本的总和。$Q$ 次询问，每次给定 $a,b,c,d,e$，求满足要求的最低总成本。", "inputFormat": "第一行一个正整数 $V$。\n\n接下来 $V−1$ 行，每行三个整数 $u,v,w$，表示 $u$ 号点和 $v$ 号点间有一条道路相连，并且在这条道路上投放广告需要 $w$ 新加坡元。\n\n接下来一行包含一个正整数 $Q$，表示询问次数。\n\n接下来 $Q$ 行，每行五个整数 $a,b,c,d,e$，表示 $5$ 个赞助商的位置。保证 $a,b,c,d,e$ 两两不同。", "outputFormat": "对于每次询问，一行一个整数表示投放广告的最低总成本。", "hint": "### 【样例 2 解释】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bflmat2l.png)\n\n对于第一次询问，$5$ 个赞助商分别位于 $4,0,3,5,2$ 号点（请注意编号不一定按升序排列）。易知我们需要在每一条路边投放广告，最低成本是所有道路的成本之和，即 $4+2+9+1+5=21$。\n\n对于第二次询问，$5$ 个赞助商位于 $0,4,1,3,5$ 号点。这一次我们不需要在 $(3,2)$ 这条道路上投放广告。因此总成本为 $21−5=16$。\n\n### 【数据范围】\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|$V,Q$ 的范围|特殊性质|\n|:-:|:-:|:-:|:-:|\n|$1$|$7$|$V=5,Q=1$|无|\n|$2$|$23$|$5\\le V\\le5\\times10^4,1\\le Q\\le 10^4$|有|\n|$3$|$40$|$5\\le V\\le5\\times10^4,1\\le Q\\le 100$|无|\n|$4$|$30$|$5\\le V\\le5\\times10^4,1\\le Q\\le 10^4$|无|\n\n特殊性质：保证每个点最多与 $2$ 个点间有道路相连。\n\n对于所有数据，保证 $5\\le V\\le5\\times10^4$，$1\\le Q\\le 10^4$，$0\\le u,v<V$ 且 $1\\le w\\le1000$。", "locale": "zh-CN"}}}
{"pid": "P13082", "type": "P", "difficulty": 0, "samples": [["5 5\n0 1\n1 2\n2 3\n3 4\n4 0\n2\n1 3\n2 4", "2"], ["5 4\n0 1\n1 2\n2 3\n3 4\n3\n0 2\n1 3\n2 4", "2"], ["6 5\n0 2\n1 2\n2 3\n3 4\n3 5\n2\n0 5\n1 4", "2"], ["15 19\n0 3\n1 3\n1 4\n1 5\n2 5\n3 6\n3 7\n4 7\n5 7\n6 10\n7 9\n7 10\n7 11\n8 11\n9 12\n9 13\n10 13\n11 13\n11 14\n2\n4 10\n3 8", "7"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "Special Judge", "NOISG（新加坡）"], "title": "[NOISG 2017] Hotspot / 热门地点", "background": "译自 [NOISG 2017 C.Hotspot](https://github.com/noisg/sg_noi_archive/tree/master/2017/hotspot)。", "description": "一个国家有 $n$ 个城镇，这些城镇由 $m$ 条长度相同的道路连接。\n\n这个国家有 $k$ 个公民。有趣的是，第 $i$ 位公民的家和办公室位于两个不同的城镇 $A_i$ 和 $B_i$。因此，第 $i$ 个公民每天都会在 $A_i$ 和 $B_i$ 两个固定的城镇间往返。\n\n为了节省时间，第 $i$ 个公民将选择长度最短的路径。如果 $A_i$ 和 $B_i$ 间有多条最短路径，他 / 她将随机选择一条最短路径。第 $i$ 个公民通过城镇 $w$ 的期望为：\n\n$$E_i(w)=\\dfrac{S_w(A_i,B_i)}{S(A_i,B_i)}$$\n\n其中 $S(u,v)$ 表示 $u$ 和 $v$ 间的最短路数量，$S_w(u,v)$ 表示 $u$ 和 $v$ 间经过 $w$ 的的最短路数量。\n\n小 D 是这个国家的总统。他想了解公民的需求，于是想在国家的某一个城镇上设立一个会议办公室，因为这样他就可以会见尽可能多的公民。确切地说，他想将会议办公室设立在使 $\\sum\\limits_{i=0}^{k-1}E_i(w)$ 最大的城镇 $w$。\n\n你的任务是帮助小 D 找到符合要求的 $w$。当有多个符合要求的城镇 $w$ 时，你可以输出其中的任何一个。\n\n注意本题需要使用**双精度浮点数**。", "inputFormat": "第一行两个正整数 $n,m$，分别表示城镇和道路的数量。\n\n接下来 $m$ 行，每行两个整数 $u,v$，表示城镇 $u$ 和城镇 $v$ 间有一条道路相连。\n\n接下来一行包含一个正整数 $k$，表示公民的个数。\n\n接下来 $k$ 行，第 $i$ 行两个整数 $A_i,B_i$，表示第 $i$ 个公民的家和办公室的位置。", "outputFormat": "一行一个整数表示使 $\\sum\\limits_{i=0}^{k-1}E_i(w)$ 最大的城镇 $w$。如果有多个符合要求的解，输出其中的任何一个即可。", "hint": "### 样例解释\n\n对于样例 1 和 3，显然选择城镇 $3$ 也是正确的。\n\n对于样例 4（如下图），在城镇 $4$ 和城镇 $10$ 之间只有一条长度为 $2$ 的最短路径，即 $4\\to7\\to10$。此外，城镇 $3$ 和城镇 $8$ 之间只有一条长度为 $3$ 的最短路径，即 $3\\to7\\to11\\to8$。\n如果小 D 在城镇 $7$ 建造会议办公室，那么 $\\sum\\limits_{i=0}^{k-1}E_i(w)=2$ 最大。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z7tp37kw.png)\n\n### 数据范围\n\n请注意本题时限为 $2.5$ 秒。\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|性质|\n|:-:|:-:|:-:|\n|$1$|$4$|图是一条链，且 $n\\le1000$，$m=n-1$，$k=1$|\n|$2$|$5$|图是一棵树，且 $n\\le1000$，$m=n-1$，$k=1$|\n|$3$|$11$|图是一条链，且 $n\\le1000$，$m=n-1$，$k\\le200$|\n|$4$|$18$|图是一棵树，且 $n\\le1000$，$m=n-1$，$k\\le200$|\n|$5$|$26$|$n\\le1000$，$m\\le8000$，$k\\le20$|\n|$6$|$36$|$1\\le n\\le5000$，$1\\le m\\le 4\\times 10^4$，$1\\le k \\le2000$|\n\n对于所有数据，保证 $1\\le n\\le5000$，$1\\le m\\le 4\\times 10^4$，$1\\le k \\le2000$，$1\\le u,v,A_i,B_i\\le n$，任何两个城镇之间的最短路不会超过 $2^{15}$ 条。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2017] Hotspot / 热门地点", "background": "译自 [NOISG 2017 C.Hotspot](https://github.com/noisg/sg_noi_archive/tree/master/2017/hotspot)。", "description": "一个国家有 $n$ 个城镇，这些城镇由 $m$ 条长度相同的道路连接。\n\n这个国家有 $k$ 个公民。有趣的是，第 $i$ 位公民的家和办公室位于两个不同的城镇 $A_i$ 和 $B_i$。因此，第 $i$ 个公民每天都会在 $A_i$ 和 $B_i$ 两个固定的城镇间往返。\n\n为了节省时间，第 $i$ 个公民将选择长度最短的路径。如果 $A_i$ 和 $B_i$ 间有多条最短路径，他 / 她将随机选择一条最短路径。第 $i$ 个公民通过城镇 $w$ 的期望为：\n\n$$E_i(w)=\\dfrac{S_w(A_i,B_i)}{S(A_i,B_i)}$$\n\n其中 $S(u,v)$ 表示 $u$ 和 $v$ 间的最短路数量，$S_w(u,v)$ 表示 $u$ 和 $v$ 间经过 $w$ 的的最短路数量。\n\n小 D 是这个国家的总统。他想了解公民的需求，于是想在国家的某一个城镇上设立一个会议办公室，因为这样他就可以会见尽可能多的公民。确切地说，他想将会议办公室设立在使 $\\sum\\limits_{i=0}^{k-1}E_i(w)$ 最大的城镇 $w$。\n\n你的任务是帮助小 D 找到符合要求的 $w$。当有多个符合要求的城镇 $w$ 时，你可以输出其中的任何一个。\n\n注意本题需要使用**双精度浮点数**。", "inputFormat": "第一行两个正整数 $n,m$，分别表示城镇和道路的数量。\n\n接下来 $m$ 行，每行两个整数 $u,v$，表示城镇 $u$ 和城镇 $v$ 间有一条道路相连。\n\n接下来一行包含一个正整数 $k$，表示公民的个数。\n\n接下来 $k$ 行，第 $i$ 行两个整数 $A_i,B_i$，表示第 $i$ 个公民的家和办公室的位置。", "outputFormat": "一行一个整数表示使 $\\sum\\limits_{i=0}^{k-1}E_i(w)$ 最大的城镇 $w$。如果有多个符合要求的解，输出其中的任何一个即可。", "hint": "### 样例解释\n\n对于样例 1 和 3，显然选择城镇 $3$ 也是正确的。\n\n对于样例 4（如下图），在城镇 $4$ 和城镇 $10$ 之间只有一条长度为 $2$ 的最短路径，即 $4\\to7\\to10$。此外，城镇 $3$ 和城镇 $8$ 之间只有一条长度为 $3$ 的最短路径，即 $3\\to7\\to11\\to8$。\n如果小 D 在城镇 $7$ 建造会议办公室，那么 $\\sum\\limits_{i=0}^{k-1}E_i(w)=2$ 最大。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z7tp37kw.png)\n\n### 数据范围\n\n请注意本题时限为 $2.5$ 秒。\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|性质|\n|:-:|:-:|:-:|\n|$1$|$4$|图是一条链，且 $n\\le1000$，$m=n-1$，$k=1$|\n|$2$|$5$|图是一棵树，且 $n\\le1000$，$m=n-1$，$k=1$|\n|$3$|$11$|图是一条链，且 $n\\le1000$，$m=n-1$，$k\\le200$|\n|$4$|$18$|图是一棵树，且 $n\\le1000$，$m=n-1$，$k\\le200$|\n|$5$|$26$|$n\\le1000$，$m\\le8000$，$k\\le20$|\n|$6$|$36$|$1\\le n\\le5000$，$1\\le m\\le 4\\times 10^4$，$1\\le k \\le2000$|\n\n对于所有数据，保证 $1\\le n\\le5000$，$1\\le m\\le 4\\times 10^4$，$1\\le k \\le2000$，$1\\le u,v,A_i,B_i\\le n$，任何两个城镇之间的最短路不会超过 $2^{15}$ 条。", "locale": "zh-CN"}}}
{"pid": "P13083", "type": "P", "difficulty": 5, "samples": [["5 3\n0 2 1\n1 3 0\n1 4 0", "1 4 3 0 2"], ["3 2\n0 1 1\n1 2 1", "-1 -1 -1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2017", "Special Judge", "NOISG（新加坡）"], "title": "[NOISG 2017] RMQ", "background": "译自 [NOISG 2017 D.RMQ](https://github.com/noisg/sg_noi_archive/tree/master/2017/rmq)。", "description": "小 K 有 $N$ 头奶牛，编号分别为 $0$ 至 $N-1$。这些奶牛以某种未知的顺序排成了一排。\n\n现在给出 $Q$ 条信息，每条信息包含三个整数 $L_i,R_i,A_i$，表示区间 $[L_i,R_i]$ 内编号最小的奶牛的编号为 $A_i$。请你构造一组奶牛的顺序使得其可以满足所有信息。", "inputFormat": "第一行两个正整数 $N,Q$，分别表示奶牛数和信息数。\n\n接下来 $Q$ 行，每行三个整数 $L_i,R_i,A_i$，代表一条信息。", "outputFormat": "一行 $N$ 个整数表示你构造的奶牛的顺序。如果有多个解，输出任意一个即可。如果无解，输出 $N$ 个 $-1$。", "hint": "### 样例解释\n\n对于样例 1，请注意这不是唯一满足要求的顺序。\n\n对于样例 2，如果 $0$ 号奶牛在 $0$ 号位置或者 $1$ 号位置，那么区间 $[0,1]$ 的最小值应为 $0$ 而非 $1$；如果 $0$ 号奶牛在 $2$ 号位置，那么区间 $[1,1]$ 的最小值应为 $0$ 而非 $1$。因此，不存在符合要求的顺序。\n\n### 评分标准\n\n对于一个测试点：\n- 如果你的输出满足以下要求，你将获得该测试点所有的分数：\n\t- 输出 $N$ 个数。\n\t- 该测试点无解，并且你也判断无解。\n\t- 该测试点有解，并且你构造的顺序满足所有信息而且没有奶牛编号相同。\n- 如果你的输出满足以下要求，你将获得该测试点 $30\\%$ 的分数：\n\t- 输出 $N$ 个数。\n\t- 你构造的顺序满足所有信息但是有奶牛编号相同。\n- 否则你将获得该测试点 $0\\%$ 的分数。\n\n例如，对于样例 2，如果你输出 `1 1 1`，那么你将获得该点 $30\\%$ 的分数。\n\n### 数据范围\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|$N,Q$|\n|:-:|:-:|:-:|\n|$1$|$23$|$\\le10$|\n|$2$|$44$|$\\le1000$|\n|$3$|$33$|$\\le10^5$|\n\n对于所有数据，保证 $1\\le N,Q\\le10^5$，$0\\le L_i,R_i< N$，$0\\le A_i< N$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2017] RMQ", "background": "译自 [NOISG 2017 D.RMQ](https://github.com/noisg/sg_noi_archive/tree/master/2017/rmq)。", "description": "小 K 有 $N$ 头奶牛，编号分别为 $0$ 至 $N-1$。这些奶牛以某种未知的顺序排成了一排。\n\n现在给出 $Q$ 条信息，每条信息包含三个整数 $L_i,R_i,A_i$，表示区间 $[L_i,R_i]$ 内编号最小的奶牛的编号为 $A_i$。请你构造一组奶牛的顺序使得其可以满足所有信息。", "inputFormat": "第一行两个正整数 $N,Q$，分别表示奶牛数和信息数。\n\n接下来 $Q$ 行，每行三个整数 $L_i,R_i,A_i$，代表一条信息。", "outputFormat": "一行 $N$ 个整数表示你构造的奶牛的顺序。如果有多个解，输出任意一个即可。如果无解，输出 $N$ 个 $-1$。", "hint": "### 样例解释\n\n对于样例 1，请注意这不是唯一满足要求的顺序。\n\n对于样例 2，如果 $0$ 号奶牛在 $0$ 号位置或者 $1$ 号位置，那么区间 $[0,1]$ 的最小值应为 $0$ 而非 $1$；如果 $0$ 号奶牛在 $2$ 号位置，那么区间 $[1,1]$ 的最小值应为 $0$ 而非 $1$。因此，不存在符合要求的顺序。\n\n### 评分标准\n\n对于一个测试点：\n- 如果你的输出满足以下要求，你将获得该测试点所有的分数：\n\t- 输出 $N$ 个数。\n\t- 该测试点无解，并且你也判断无解。\n\t- 该测试点有解，并且你构造的顺序满足所有信息而且没有奶牛编号相同。\n- 如果你的输出满足以下要求，你将获得该测试点 $30\\%$ 的分数：\n\t- 输出 $N$ 个数。\n\t- 你构造的顺序满足所有信息但是有奶牛编号相同。\n- 否则你将获得该测试点 $0\\%$ 的分数。\n\n例如，对于样例 2，如果你输出 `1 1 1`，那么你将获得该点 $30\\%$ 的分数。\n\n### 数据范围\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|$N,Q$|\n|:-:|:-:|:-:|\n|$1$|$23$|$\\le10$|\n|$2$|$44$|$\\le1000$|\n|$3$|$33$|$\\le10^5$|\n\n对于所有数据，保证 $1\\le N,Q\\le10^5$，$0\\le L_i,R_i< N$，$0\\le A_i< N$。", "locale": "zh-CN"}}}
{"pid": "P13084", "type": "P", "difficulty": 0, "samples": [["1 5 5\n1 2 3 4 5\n1 1 2 1 2\n2 2 1 2\n2 1 1 4\n2 4 1 3\n1 3 1 1\n2 3 1 4", "1\n2\n0\n1"], ["1 5 5\n1 2 3 4 5\n3 4 3 2 5\n2 3 1 3\n2 1 1 5\n2 4 1 2\n1 4 1 4\n2 3 1 5", "2\n4\n0\n3"], ["3 3 5\n1 4 3\n11 2 7\n5 10 6\n1 1 1\n2 1 2\n1 2 1\n2 2 1 6\n2 2 3 10\n2 3 2 3\n1 2 2 2\n2 2 1 4", "1\n2\n0\n2"], ["3 3 5\n1 4 3\n11 2 7\n5 10 6\n6 3 3\n4 6 4\n9 4 9\n2 2 1 6\n2 2 3 10\n2 3 2 3\n1 2 2 7\n2 2 1 4", "2\n4\n0\n3"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2017", "NOISG（新加坡）"], "title": "[NOISG 2017] I want to be the very best too! / 宝可梦大师", "background": "译自 [NOISG 2017 E.I want to be the very best too! (Pokémon Master)](https://github.com/noisg/sg_noi_archive/tree/master/2017/pokemonmaster)。\n\n------------\n\n看到小智成功成为最优秀的人后，小 P 也想追随他的脚步，成为最出色的人！\n\n为了做到这一点，他想抓住种类尽可能多的宝可梦，以填满他的宝可梦图鉴并成为最出色的人。\n\n然而，还有许多其他的宝可梦训练家挡在他面前，他必须打败他们，才能实现他的目标。", "description": "小 P 和宝可梦生活在一个可以用 $R$ 行 $C$ 列的网格表示的世界里。其中左上角的网格为 $(1,1)$，右下角的网格为 $(C,R)$。小 P 每次只能从一个网格移动到与其相邻的另一个网格。\n\n每一个网格中都有一个宝可梦训练家。小 P 必须与之战斗才能通过这一个网格并获得该宝可梦训练家的宝可梦。\n\n每个宝可梦训练家都有自己的等级。我们不妨认为所有宝可梦训练家的等级都是不同的（这样方便知道每一场战斗的获胜者）。其中，网格 $(j,i)$ 中的训练家的等级为 $L_{i,j}$，并用种类为 $P_{i,j}$ 的宝可梦进行战斗。\n\n让事情变得更加困难的是，宝可梦训练家们有时会改变他们的宝可梦的种类。于是，小 P 想提前规划好他的出发时间。因此，小 P 会随时询问你，如果他现在从 $(X_q,Y_q)$ 出发，并且只能击败等级小于或等于 $L_q$ 的宝可梦训练家，那么他最终能拥有多少种宝可梦。\n\n注意，如果他不能打败一个网格中的宝可梦训练家，他就不能穿过该网格。", "inputFormat": "第一行三个整数 $R,C,Q$，分别表示世界的行数。\n\n接下来 $R$ 行，每行 $C$ 个整数，第 $i$ 行第 $j$ 列的整数 $L_{i,j}$ 表示网格 $(j,i)$ 中的训练家的等级。\n\n接下来 $R$ 行，每行 $C$ 个整数，第 $i$ 行第 $j$ 列的整数 $P_{i,j}$ 表示网格 $(j,i)$ 中的训练家的宝可梦的种类。\n\n最后 $Q$ 行，每行四个整数。第一个整数为 $op$，如果 $op=1$，则其后三个整数 $X_q,Y_q,P_q$，代表 $(X_q,Y_q)$ 处的训练师将宝可梦的种类更换为了 $P_q$；如果 $op=2$，则其后三个整数 $X_q,Y_q,L_q$，代表小 P 询问你，如果他现在从 $(X_q,Y_q)$ 出发，并且只能击败等级小于或等于 $L_q$ 的宝可梦训练家，那么他最终能拥有多少种宝可梦。", "outputFormat": "对于小 P 的每次询问，输出一行一个整数，即他最终能拥有的宝可梦种类数。", "hint": "### 样例 4 解释\n\n对于第一次询问，小 P 只能通过击败等级分别为 $1,2,3,4$ 的宝可梦训练家来捕捉种类为 $3$ 和 $6$ 的宝可梦。\n\n对于第二次询问，小 P 可以捕捉到所有种类的宝可梦，因为他可以击败除 $11$ 级之外的所有宝可梦训练家。\n\n对于第三次询问，小 P 无法打败出发的位置处的宝可梦训练家，因此他无法去任何地方，也无法抓住任何种类的宝可梦。\n\n对于第四次询问，小 P 可以捕捉到 $3$ 种类型的宝可梦，因为 $(2,2)$ 处的训练师现在使用的是种类为 $7$ 的宝可梦。\n\n### 数据范围\n\n请注意本题时限为 $5$ 秒。\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|$R$|$Q$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$11$|$=1$|$\\le1000$|$(X,1)$ 处的训练家的等级为 $X$|\n|$2$|$16$|$\\le5\\times10^4$|$\\le10$|无|\n|$3$|$20$|$\\le5\\times10^4$|$\\le10^5$|$1\\le P_{i,j},P_q\\le2$|\n|$4$|$24$|$=1$|$\\le10^5$|$(X,1)$ 处的训练家的等级为 $X$|\n|$5$|$29$|$\\le5\\times10^4$|$\\le10^5$|无|\n\n对于所有数据，保证 $1\\le R\\times C\\le5\\times10^4$，$1\\le Q\\le 10^5$，$1\\le L_{i,j},L_q \\le10^9$，$1\\le P_{i,j},P_q\\le 5\\times10^4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[NOISG 2017] I want to be the very best too! / 宝可梦大师", "background": "译自 [NOISG 2017 E.I want to be the very best too! (Pokémon Master)](https://github.com/noisg/sg_noi_archive/tree/master/2017/pokemonmaster)。\n\n------------\n\n看到小智成功成为最优秀的人后，小 P 也想追随他的脚步，成为最出色的人！\n\n为了做到这一点，他想抓住种类尽可能多的宝可梦，以填满他的宝可梦图鉴并成为最出色的人。\n\n然而，还有许多其他的宝可梦训练家挡在他面前，他必须打败他们，才能实现他的目标。", "description": "小 P 和宝可梦生活在一个可以用 $R$ 行 $C$ 列的网格表示的世界里。其中左上角的网格为 $(1,1)$，右下角的网格为 $(C,R)$。小 P 每次只能从一个网格移动到与其相邻的另一个网格。\n\n每一个网格中都有一个宝可梦训练家。小 P 必须与之战斗才能通过这一个网格并获得该宝可梦训练家的宝可梦。\n\n每个宝可梦训练家都有自己的等级。我们不妨认为所有宝可梦训练家的等级都是不同的（这样方便知道每一场战斗的获胜者）。其中，网格 $(j,i)$ 中的训练家的等级为 $L_{i,j}$，并用种类为 $P_{i,j}$ 的宝可梦进行战斗。\n\n让事情变得更加困难的是，宝可梦训练家们有时会改变他们的宝可梦的种类。于是，小 P 想提前规划好他的出发时间。因此，小 P 会随时询问你，如果他现在从 $(X_q,Y_q)$ 出发，并且只能击败等级小于或等于 $L_q$ 的宝可梦训练家，那么他最终能拥有多少种宝可梦。\n\n注意，如果他不能打败一个网格中的宝可梦训练家，他就不能穿过该网格。", "inputFormat": "第一行三个整数 $R,C,Q$，分别表示世界的行数。\n\n接下来 $R$ 行，每行 $C$ 个整数，第 $i$ 行第 $j$ 列的整数 $L_{i,j}$ 表示网格 $(j,i)$ 中的训练家的等级。\n\n接下来 $R$ 行，每行 $C$ 个整数，第 $i$ 行第 $j$ 列的整数 $P_{i,j}$ 表示网格 $(j,i)$ 中的训练家的宝可梦的种类。\n\n最后 $Q$ 行，每行四个整数。第一个整数为 $op$，如果 $op=1$，则其后三个整数 $X_q,Y_q,P_q$，代表 $(X_q,Y_q)$ 处的训练师将宝可梦的种类更换为了 $P_q$；如果 $op=2$，则其后三个整数 $X_q,Y_q,L_q$，代表小 P 询问你，如果他现在从 $(X_q,Y_q)$ 出发，并且只能击败等级小于或等于 $L_q$ 的宝可梦训练家，那么他最终能拥有多少种宝可梦。", "outputFormat": "对于小 P 的每次询问，输出一行一个整数，即他最终能拥有的宝可梦种类数。", "hint": "### 样例 4 解释\n\n对于第一次询问，小 P 只能通过击败等级分别为 $1,2,3,4$ 的宝可梦训练家来捕捉种类为 $3$ 和 $6$ 的宝可梦。\n\n对于第二次询问，小 P 可以捕捉到所有种类的宝可梦，因为他可以击败除 $11$ 级之外的所有宝可梦训练家。\n\n对于第三次询问，小 P 无法打败出发的位置处的宝可梦训练家，因此他无法去任何地方，也无法抓住任何种类的宝可梦。\n\n对于第四次询问，小 P 可以捕捉到 $3$ 种类型的宝可梦，因为 $(2,2)$ 处的训练师现在使用的是种类为 $7$ 的宝可梦。\n\n### 数据范围\n\n请注意本题时限为 $5$ 秒。\n\n**本题采用 $\\text{Subtask}$ 捆绑测试。**\n\n|$\\text{Subtask}$|分值|$R$|$Q$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$1$|$11$|$=1$|$\\le1000$|$(X,1)$ 处的训练家的等级为 $X$|\n|$2$|$16$|$\\le5\\times10^4$|$\\le10$|无|\n|$3$|$20$|$\\le5\\times10^4$|$\\le10^5$|$1\\le P_{i,j},P_q\\le2$|\n|$4$|$24$|$=1$|$\\le10^5$|$(X,1)$ 处的训练家的等级为 $X$|\n|$5$|$29$|$\\le5\\times10^4$|$\\le10^5$|无|\n\n对于所有数据，保证 $1\\le R\\times C\\le5\\times10^4$，$1\\le Q\\le 10^5$，$1\\le L_{i,j},L_q \\le10^9$，$1\\le P_{i,j},P_q\\le 5\\times10^4$。", "locale": "zh-CN"}}}
{"pid": "P13085", "type": "P", "difficulty": 5, "samples": [["1 10", "9"], ["25 50\n", "20\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2009", "四川", "各省省选", "数位 DP"], "title": "[SCOI2009] windy 数（加强版）", "background": "**本题与 [P2657 [SCOI2009] windy 数](https://www.luogu.com.cn/problem/P2657) 的区别在于 $\\bm{a}$ 与 $\\bm{b}$ 的范围。**\n\nwindy 定义了一种 windy 数。", "description": "不含前导零且相邻两个数字之差至少为 $2$ 的正整数被称为 windy 数。windy 想知道，在 $a$ 和 $b$ 之间，包括 $a$ 和 $b$，总共有多少个 windy 数？", "inputFormat": "输入只有一行两个整数，分别表示 $a$ 和 $b$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq a \\leq b \\leq 10^{18}$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[SCOI2009] windy 数（加强版）", "background": "**本题与 [P2657 [SCOI2009] windy 数](https://www.luogu.com.cn/problem/P2657) 的区别在于 $\\bm{a}$ 与 $\\bm{b}$ 的范围。**\n\nwindy 定义了一种 windy 数。", "description": "不含前导零且相邻两个数字之差至少为 $2$ 的正整数被称为 windy 数。windy 想知道，在 $a$ 和 $b$ 之间，包括 $a$ 和 $b$，总共有多少个 windy 数？", "inputFormat": "输入只有一行两个整数，分别表示 $a$ 和 $b$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq a \\leq b \\leq 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P13086", "type": "P", "difficulty": 7, "samples": [["", "1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n1024\n2048\n1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n1024\n2048\n3\n3 XOR 1 2\n3 OR 3 N 7\n3 POPCNT 3"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["提交答案", "Special Judge", "O2优化"], "title": "『STA - H1』Code Golf (16bit[v])", "background": "这是问题的 16bit[v] 版本。本题与 [24bit 版本](https://www.luogu.com.cn/problem/P13087)和 [68bit 版本](https://www.luogu.com.cn/problem/P13088)的区别在于此版本中电路的位长 $w=16$。此外，另外两个版本和本题的另一个区别是本题的电路中 `LSH` 与 `RSH` 的右操作数**不**必须是字面量。", "description": "**本题为提交答案题。**\n\n以下是简要题面，关于其中名词的详细定义见后文（有些名词可能和你所见过的定义并不完全相符）。\n\n定义所有**长度为 $\\bm4$** 的排列组成的集合为 $\\mathcal P$，$w=\\color{blue}16$ 是位长，$B$ 是 $[0,2^w)$ 内的整数组成的集合。\n\n你需要设计一个**函数** $f:\\mathcal P\\to B$ 和一个**电路** $C:(B, B)\\to B$，使得对于任意 $p,q\\in\\mathcal P$ 都有：\n$$\\operatorname{cyc}(p\\circ q)=C(f(p),f(q))$$\n其中 $\\circ$ 是排列的复合，$\\operatorname{cyc}(\\cdot)$ 表示排列的置换环个数。\n\n电路 $C$ 中涉及到的运算门个数不能超过 $10^4$，得分将根据电路 $C$ 中的运算门个数评定，得分计算方式见说明 / 提示部分。\n***\n\n以下是可能涉及到的定义：\n\n> **关于排列**\n>\n> 一个长度为 $n$ 的排列是元素为 $1$ 到 $n$ 中互不重复的整数的长度为 $n$ 的序列。两个排列 $p,q$ 的复合 $(p\\circ q)_i=p_{q_i}$。对于一个排列 $p$，集合 $S$ 是其置换环当且仅当 $S$ 是极小的满足 $S=\\{p_x\\mid x\\in S\\}$ 的集合。$\\operatorname{cyc}(p)$ 是排列 $p$ 的置换环个数。\n>\n> 一个排列 $p$ 的排名是字典序不大于它的排列个数，关于字典序的定义选手可以自行搜索。\n>\n> **关于电路**\n>\n> 在一个电路 $C$ 中，你有 $100$ 个变量 $x_{1\\dots 100}$ 可供使用，其中 $x_1,x_2$ 是输入信号接收 $C$ 的两个参数，$x_3$ 是输出信号在电路运行完毕后作为 $C$ 的返回值传出。初始除了 $x_1,x_2$ 每个变量的值都是 $0$。每个变量都是 $B$ 内的整数，并且运算时随时保持对 $2^w$ 取模。你可以认为电路中的变量都是 $w$ 位的自然溢出的无符号整数。\n>\n> 一个数值有以下两种表达（后将值为 $p$ 的数值记作 `#p`，不带 `#` 的字母表示普通变量）：\n> - `i`，表示变量 $x_i$。\n> - `N n`，表示十进制字面量 $n$，其中 $0\\le n<2^w$。\n>\n> 电路由若干计算门组成，所有计算门按顺序依次进行。计算门分以下七种：\n> - `i AND #p #q`，令 $x_i\\gets p\\land q$，其中 $\\land$ 是按位与运算。\n> - `i OR #p #q`，令 $x_i\\gets p\\lor q$，其中 $\\lor$ 是按位或运算。\n> - `i XOR #p #q`，令 $x_i\\gets p\\oplus q$，其中 $\\oplus$ 是按位异或运算。\n> - `i NOT #p`，令 $x_i\\gets \\lnot p$，其中 $\\lnot$ 是按位取反运算。\n> - `i LSH #p #q`，令 $x_i\\gets p\\cdot 2^q$，**其中要求 $\\bm{q<w}$**。\n> - `i RSH #p #q`，令 $x_i\\gets \\lfloor\\frac p{2^q}\\rfloor$，**其中要求 $\\bm{q<w}$**。\n> - `i POPCNT #p`，令 $x_i\\gets\\operatorname{popcount}(p)$，其中 $\\operatorname{popcount}(\\cdot)$ 表示二进制中一的个数。\n>\n> 关于各类位运算的详细定义，选手可以自行搜索。", "inputFormat": "没有任何输入。", "outputFormat": "你可以选择提交答案的生成器代码，或者直接提交答案。如果想要直接提交答案的话需要把答案文件压缩到一个 zip 文件内并使用提交文件方式提交。\n\n首先 $24$ 行，第 $i$ 行一个 $[0,2^w)$ 内的整数 $x$ 表示排名为 $i$ 的排列 $p$ 的 $f$ 值 $f(p)=x$。\n\n接下来一行一个非负整数 $L$，表示电路涉及到的计算门个数。\n\n接下来 $L$ 行，每行描述一个计算门。", "hint": "**样例解释**\n\n样例仅供演示输出格式，并没有实际意义，也不能在本题得到任何分数。\n\n样例输出中的电路 $C$ 描述了 $C(x,y)=\\operatorname{popcount}((x\\oplus y)\\lor7)$。\n\n**电路模拟**\n\n我们在下发文件中提供了一个可以计算电路的运行结果的 C++ 代码 `compiler.cpp`（需要以至少 C++ 11 标准运行），选手可以使用 `compiler.cpp` 辅助理解电路的运行模式。\n\n注意：`compiler.cpp` 仅对合法的输入有效，对不合法的输入的运行结果不做任何保证。\n\n**评分标准**\n\n若你的输出出现下列情况，那么该测试点不得分：\n\n- $\\operatorname{cyc}(p\\circ q)\\neq C(f(p),f(q))$。\n- 电路 $C$ 不合法（使用标号不在 $[1,100]$ 内的变量 / 字面量的值 $\\ge2^w$ / 出现无法识别或不合法的语句 / 使用超过 $10^4$ 个运算门 / 运算门参数不合法）。\n\n否则若你使用了 $c$ 个运算门，那么你的得分为：\n$$\\mathit{score}=\\min\\left(100,\\left\\lfloor\\frac{1315.15}{8.73+e^{0.03c}}\\right\\rfloor\\right)$$\n\n下表为在一些特殊的 $c$ 中选手在该测试点得到的分数：  \n\n| $c$ | $\\mathit{score}$ | $c$ | $\\mathit{score}$ |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $240$ | $0$ | $90$ | $55$ |\n| $200$ | $3$ | $80$ | $66$ |\n| $160$ | $10$ | $70$ | $77$ |\n| $140$ | $17$ | $60$ | $88$ |\n| $120$ | $29$ | $50$ | $99$ |\n| $100$ | $45$ | $49$ | $100$ |\n\n这里给出得分函数的函数图像，以供参考（由 desmos 提供）。  \n\n![image](https://cdn.luogu.com.cn/upload/image_hosting/10zy6f0i.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『STA - H1』Code Golf (16bit[v])", "background": "这是问题的 16bit[v] 版本。本题与 [24bit 版本](https://www.luogu.com.cn/problem/P13087)和 [68bit 版本](https://www.luogu.com.cn/problem/P13088)的区别在于此版本中电路的位长 $w=16$。此外，另外两个版本和本题的另一个区别是本题的电路中 `LSH` 与 `RSH` 的右操作数**不**必须是字面量。", "description": "**本题为提交答案题。**\n\n以下是简要题面，关于其中名词的详细定义见后文（有些名词可能和你所见过的定义并不完全相符）。\n\n定义所有**长度为 $\\bm4$** 的排列组成的集合为 $\\mathcal P$，$w=\\color{blue}16$ 是位长，$B$ 是 $[0,2^w)$ 内的整数组成的集合。\n\n你需要设计一个**函数** $f:\\mathcal P\\to B$ 和一个**电路** $C:(B, B)\\to B$，使得对于任意 $p,q\\in\\mathcal P$ 都有：\n$$\\operatorname{cyc}(p\\circ q)=C(f(p),f(q))$$\n其中 $\\circ$ 是排列的复合，$\\operatorname{cyc}(\\cdot)$ 表示排列的置换环个数。\n\n电路 $C$ 中涉及到的运算门个数不能超过 $10^4$，得分将根据电路 $C$ 中的运算门个数评定，得分计算方式见说明 / 提示部分。\n***\n\n以下是可能涉及到的定义：\n\n> **关于排列**\n>\n> 一个长度为 $n$ 的排列是元素为 $1$ 到 $n$ 中互不重复的整数的长度为 $n$ 的序列。两个排列 $p,q$ 的复合 $(p\\circ q)_i=p_{q_i}$。对于一个排列 $p$，集合 $S$ 是其置换环当且仅当 $S$ 是极小的满足 $S=\\{p_x\\mid x\\in S\\}$ 的集合。$\\operatorname{cyc}(p)$ 是排列 $p$ 的置换环个数。\n>\n> 一个排列 $p$ 的排名是字典序不大于它的排列个数，关于字典序的定义选手可以自行搜索。\n>\n> **关于电路**\n>\n> 在一个电路 $C$ 中，你有 $100$ 个变量 $x_{1\\dots 100}$ 可供使用，其中 $x_1,x_2$ 是输入信号接收 $C$ 的两个参数，$x_3$ 是输出信号在电路运行完毕后作为 $C$ 的返回值传出。初始除了 $x_1,x_2$ 每个变量的值都是 $0$。每个变量都是 $B$ 内的整数，并且运算时随时保持对 $2^w$ 取模。你可以认为电路中的变量都是 $w$ 位的自然溢出的无符号整数。\n>\n> 一个数值有以下两种表达（后将值为 $p$ 的数值记作 `#p`，不带 `#` 的字母表示普通变量）：\n> - `i`，表示变量 $x_i$。\n> - `N n`，表示十进制字面量 $n$，其中 $0\\le n<2^w$。\n>\n> 电路由若干计算门组成，所有计算门按顺序依次进行。计算门分以下七种：\n> - `i AND #p #q`，令 $x_i\\gets p\\land q$，其中 $\\land$ 是按位与运算。\n> - `i OR #p #q`，令 $x_i\\gets p\\lor q$，其中 $\\lor$ 是按位或运算。\n> - `i XOR #p #q`，令 $x_i\\gets p\\oplus q$，其中 $\\oplus$ 是按位异或运算。\n> - `i NOT #p`，令 $x_i\\gets \\lnot p$，其中 $\\lnot$ 是按位取反运算。\n> - `i LSH #p #q`，令 $x_i\\gets p\\cdot 2^q$，**其中要求 $\\bm{q<w}$**。\n> - `i RSH #p #q`，令 $x_i\\gets \\lfloor\\frac p{2^q}\\rfloor$，**其中要求 $\\bm{q<w}$**。\n> - `i POPCNT #p`，令 $x_i\\gets\\operatorname{popcount}(p)$，其中 $\\operatorname{popcount}(\\cdot)$ 表示二进制中一的个数。\n>\n> 关于各类位运算的详细定义，选手可以自行搜索。", "inputFormat": "没有任何输入。", "outputFormat": "你可以选择提交答案的生成器代码，或者直接提交答案。如果想要直接提交答案的话需要把答案文件压缩到一个 zip 文件内并使用提交文件方式提交。\n\n首先 $24$ 行，第 $i$ 行一个 $[0,2^w)$ 内的整数 $x$ 表示排名为 $i$ 的排列 $p$ 的 $f$ 值 $f(p)=x$。\n\n接下来一行一个非负整数 $L$，表示电路涉及到的计算门个数。\n\n接下来 $L$ 行，每行描述一个计算门。", "hint": "**样例解释**\n\n样例仅供演示输出格式，并没有实际意义，也不能在本题得到任何分数。\n\n样例输出中的电路 $C$ 描述了 $C(x,y)=\\operatorname{popcount}((x\\oplus y)\\lor7)$。\n\n**电路模拟**\n\n我们在下发文件中提供了一个可以计算电路的运行结果的 C++ 代码 `compiler.cpp`（需要以至少 C++ 11 标准运行），选手可以使用 `compiler.cpp` 辅助理解电路的运行模式。\n\n注意：`compiler.cpp` 仅对合法的输入有效，对不合法的输入的运行结果不做任何保证。\n\n**评分标准**\n\n若你的输出出现下列情况，那么该测试点不得分：\n\n- $\\operatorname{cyc}(p\\circ q)\\neq C(f(p),f(q))$。\n- 电路 $C$ 不合法（使用标号不在 $[1,100]$ 内的变量 / 字面量的值 $\\ge2^w$ / 出现无法识别或不合法的语句 / 使用超过 $10^4$ 个运算门 / 运算门参数不合法）。\n\n否则若你使用了 $c$ 个运算门，那么你的得分为：\n$$\\mathit{score}=\\min\\left(100,\\left\\lfloor\\frac{1315.15}{8.73+e^{0.03c}}\\right\\rfloor\\right)$$\n\n下表为在一些特殊的 $c$ 中选手在该测试点得到的分数：  \n\n| $c$ | $\\mathit{score}$ | $c$ | $\\mathit{score}$ |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $240$ | $0$ | $90$ | $55$ |\n| $200$ | $3$ | $80$ | $66$ |\n| $160$ | $10$ | $70$ | $77$ |\n| $140$ | $17$ | $60$ | $88$ |\n| $120$ | $29$ | $50$ | $99$ |\n| $100$ | $45$ | $49$ | $100$ |\n\n这里给出得分函数的函数图像，以供参考（由 desmos 提供）。  \n\n![image](https://cdn.luogu.com.cn/upload/image_hosting/10zy6f0i.png)", "locale": "zh-CN"}}}
{"pid": "P13087", "type": "P", "difficulty": 7, "samples": [["", "1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n1024\n2048\n4096\n8192\n16384\n32768\n65536\n131072\n262144\n524288\n1048576\n2097152\n4194304\n8388608\n3\n3 XOR 1 2\n3 OR 3 N 7\n3 POPCNT 3"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["提交答案", "Special Judge", "O2优化"], "title": "『STA - H1』Code Golf (24bit)", "background": "这是问题的 24bit 版本。本题与 [68bit 版本](https://www.luogu.com.cn/problem/P13088)和 [16bit[v] 版本](https://www.luogu.com.cn/problem/P13086)的区别在于此版本中电路的位长 $w=24$。此外，[16bit[v] 版本](https://www.luogu.com.cn/problem/P13086)和本题的另一个区别是本题的电路中 `LSH` 与 `RSH` 的右操作数必须是字面量。", "description": "**本题为提交答案题。**\n\n以下是简要题面，关于其中名词的详细定义见后文（有些名词可能和你所见过的定义并不完全相符）。\n\n定义所有**长度为 $\\bm4$** 的排列组成的集合为 $\\mathcal P$，$w=\\color{blue}24$ 是位长，$B$ 是 $[0,2^w)$ 内的整数组成的集合。\n\n你需要设计一个**函数** $f:\\mathcal P\\to B$ 和一个**电路** $C:(B, B)\\to B$，使得对于任意 $p,q\\in\\mathcal P$ 都有：\n$$\\operatorname{cyc}(p\\circ q)=C(f(p),f(q))$$\n其中 $\\circ$ 是排列的复合，$\\operatorname{cyc}(\\cdot)$ 表示排列的置换环个数。\n\n电路 $C$ 中涉及到的运算门个数不能超过 $10^4$，得分将根据电路 $C$ 中的运算门个数评定，得分计算方式见说明 / 提示部分。\n***\n\n以下是可能涉及到的定义：\n\n> **关于排列**\n>\n> 一个长度为 $n$ 的排列是元素为 $1$ 到 $n$ 中互不重复的整数的长度为 $n$ 的序列。两个排列 $p,q$ 的复合 $(p\\circ q)_i=p_{q_i}$。对于一个排列 $p$，集合 $S$ 是其置换环当且仅当 $S$ 是极小的满足 $S=\\{p_x\\mid x\\in S\\}$ 的集合。$\\operatorname{cyc}(p)$ 是排列 $p$ 的置换环个数。\n>\n> 一个排列 $p$ 的排名是字典序不大于它的排列个数，关于字典序的定义选手可以自行搜索。\n>\n> **关于电路**\n>\n> 在一个电路 $C$ 中，你有 $100$ 个变量 $x_{1\\dots 100}$ 可供使用，其中 $x_1,x_2$ 是输入信号接收 $C$ 的两个参数，$x_3$ 是输出信号在电路运行完毕后作为 $C$ 的返回值传出。初始除了 $x_1,x_2$ 每个变量的值都是 $0$。每个变量都是 $B$ 内的整数，并且运算时随时保持对 $2^w$ 取模。你可以认为电路中的变量都是 $w$ 位的自然溢出的无符号整数。\n>\n> 一个数值有以下两种表达（后将值为 $p$ 的数值记作 `#p`，不带 `#` 的字母表示普通变量）：\n> - `i`，表示变量 $x_i$。\n> - `N n`，表示十进制字面量 $n$，其中 $0\\le n<2^w$。\n>\n> 电路由若干计算门组成，所有计算门按顺序依次进行。计算门分以下七种：\n> - `i AND #p #q`，令 $x_i\\gets p\\land q$，其中 $\\land$ 是按位与运算。\n> - `i OR #p #q`，令 $x_i\\gets p\\lor q$，其中 $\\lor$ 是按位或运算。\n> - `i XOR #p #q`，令 $x_i\\gets p\\oplus q$，其中 $\\oplus$ 是按位异或运算。\n> - `i NOT #p`，令 $x_i\\gets \\lnot p$，其中 $\\lnot$ 是按位取反运算。\n> - `i LSH #p #q`，令 $x_i\\gets p\\cdot 2^q$，**其中要求 $\\bm{q<w}$ 且 $\\bm q$ 必须是字面量**。\n> - `i RSH #p #q`，令 $x_i\\gets \\lfloor\\frac p{2^q}\\rfloor$，**其中要求 $\\bm{q<w}$ 且 $\\bm q$ 必须是字面量**。\n> - `i POPCNT #p`，令 $x_i\\gets\\operatorname{popcount}(p)$，其中 $\\operatorname{popcount}(\\cdot)$ 表示二进制中一的个数。\n>\n> 关于各类位运算的详细定义，选手可以自行搜索。", "inputFormat": "没有任何输入。", "outputFormat": "你可以选择提交答案的生成器代码，或者直接提交答案。如果想要直接提交答案的话需要把答案文件压缩到一个 zip 文件内并使用提交文件方式提交。\n\n首先 $24$ 行，第 $i$ 行一个 $[0,2^w)$ 内的整数 $x$ 表示排名为 $i$ 的排列 $p$ 的 $f$ 值 $f(p)=x$。\n\n接下来一行一个非负整数 $L$，表示电路涉及到的计算门个数。\n\n接下来 $L$ 行，每行描述一个计算门。", "hint": "**样例解释**\n\n样例仅供演示输出格式，并没有实际意义，也不能在本题得到任何分数。\n\n样例输出中的电路 $C$ 描述了 $C(x,y)=\\operatorname{popcount}((x\\oplus y)\\lor7)$。\n\n**电路模拟**\n\n我们在下发文件中提供了一个可以计算电路的运行结果的 C++ 代码 `compiler.cpp`（需要以至少 C++ 11 标准运行），选手可以使用 `compiler.cpp` 辅助理解电路的运行模式。\n\n注意：`compiler.cpp` 仅对合法的输入有效，对不合法的输入的运行结果不做任何保证。\n\n**评分标准**\n\n若你的输出出现下列情况，那么该测试点不得分：\n\n- $\\operatorname{cyc}(p\\circ q)\\neq C(f(p),f(q))$。\n- 电路 $C$ 不合法（使用标号不在 $[1,100]$ 内的变量 / 字面量的值 $\\ge2^w$ / 出现无法识别或不合法的语句 / 使用超过 $10^4$ 个运算门 / 运算门参数不合法）。\n\n否则若你使用了 $c$ 个运算门，那么你的得分为：\n\n$$\\mathrm{score}=\\begin{cases}100&c\\le 24\\\\\\left\\lfloor15.25\\log_{30}\\left(\\frac{0.09}{c-23}\\right)+111\\right\\rfloor&24<c\\le30\\\\\\left\\lceil-0.16c+95\\right\\rceil&30<c\\le350\\\\\\left\\lceil49\\cdot0.9994^{c}\\right\\rceil&350<c\\le10^4\\\\0&c>10^4\\end{cases}$$\n\n下表为在一些特殊的 $c$ 中选手在该测试点得到的分数：\n\n| $c$ | $\\mathrm{score}$ | $c$ | $\\mathrm{score}$ |\n| :---: | :---: | :---: | :---: |\n| $10^4$ | $1$ | $300$ | $47$ |\n| $6000$ | $2$ | $200$ | $63$ |\n| $5000$ | $3$ | $100$ | $79$ |\n| $3000$ | $9$ | $80$ | $83$ |\n| $2000$ | $15$ | $50$ | $87$ |\n| $1000$ | $27$ | $30$ | $91$ |\n| $700$ | $33$ | $25$ | $97$ |\n| $500$ | $37$ | $24$ | $100$ |\n\n这里给出 $c>24$ 时两张得分函数缩放不同的图像，以供参考（由 desmos 提供）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n9l07rb3.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nxrlgckv.png)", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『STA - H1』Code Golf (24bit)", "background": "这是问题的 24bit 版本。本题与 [68bit 版本](https://www.luogu.com.cn/problem/P13088)和 [16bit[v] 版本](https://www.luogu.com.cn/problem/P13086)的区别在于此版本中电路的位长 $w=24$。此外，[16bit[v] 版本](https://www.luogu.com.cn/problem/P13086)和本题的另一个区别是本题的电路中 `LSH` 与 `RSH` 的右操作数必须是字面量。", "description": "**本题为提交答案题。**\n\n以下是简要题面，关于其中名词的详细定义见后文（有些名词可能和你所见过的定义并不完全相符）。\n\n定义所有**长度为 $\\bm4$** 的排列组成的集合为 $\\mathcal P$，$w=\\color{blue}24$ 是位长，$B$ 是 $[0,2^w)$ 内的整数组成的集合。\n\n你需要设计一个**函数** $f:\\mathcal P\\to B$ 和一个**电路** $C:(B, B)\\to B$，使得对于任意 $p,q\\in\\mathcal P$ 都有：\n$$\\operatorname{cyc}(p\\circ q)=C(f(p),f(q))$$\n其中 $\\circ$ 是排列的复合，$\\operatorname{cyc}(\\cdot)$ 表示排列的置换环个数。\n\n电路 $C$ 中涉及到的运算门个数不能超过 $10^4$，得分将根据电路 $C$ 中的运算门个数评定，得分计算方式见说明 / 提示部分。\n***\n\n以下是可能涉及到的定义：\n\n> **关于排列**\n>\n> 一个长度为 $n$ 的排列是元素为 $1$ 到 $n$ 中互不重复的整数的长度为 $n$ 的序列。两个排列 $p,q$ 的复合 $(p\\circ q)_i=p_{q_i}$。对于一个排列 $p$，集合 $S$ 是其置换环当且仅当 $S$ 是极小的满足 $S=\\{p_x\\mid x\\in S\\}$ 的集合。$\\operatorname{cyc}(p)$ 是排列 $p$ 的置换环个数。\n>\n> 一个排列 $p$ 的排名是字典序不大于它的排列个数，关于字典序的定义选手可以自行搜索。\n>\n> **关于电路**\n>\n> 在一个电路 $C$ 中，你有 $100$ 个变量 $x_{1\\dots 100}$ 可供使用，其中 $x_1,x_2$ 是输入信号接收 $C$ 的两个参数，$x_3$ 是输出信号在电路运行完毕后作为 $C$ 的返回值传出。初始除了 $x_1,x_2$ 每个变量的值都是 $0$。每个变量都是 $B$ 内的整数，并且运算时随时保持对 $2^w$ 取模。你可以认为电路中的变量都是 $w$ 位的自然溢出的无符号整数。\n>\n> 一个数值有以下两种表达（后将值为 $p$ 的数值记作 `#p`，不带 `#` 的字母表示普通变量）：\n> - `i`，表示变量 $x_i$。\n> - `N n`，表示十进制字面量 $n$，其中 $0\\le n<2^w$。\n>\n> 电路由若干计算门组成，所有计算门按顺序依次进行。计算门分以下七种：\n> - `i AND #p #q`，令 $x_i\\gets p\\land q$，其中 $\\land$ 是按位与运算。\n> - `i OR #p #q`，令 $x_i\\gets p\\lor q$，其中 $\\lor$ 是按位或运算。\n> - `i XOR #p #q`，令 $x_i\\gets p\\oplus q$，其中 $\\oplus$ 是按位异或运算。\n> - `i NOT #p`，令 $x_i\\gets \\lnot p$，其中 $\\lnot$ 是按位取反运算。\n> - `i LSH #p #q`，令 $x_i\\gets p\\cdot 2^q$，**其中要求 $\\bm{q<w}$ 且 $\\bm q$ 必须是字面量**。\n> - `i RSH #p #q`，令 $x_i\\gets \\lfloor\\frac p{2^q}\\rfloor$，**其中要求 $\\bm{q<w}$ 且 $\\bm q$ 必须是字面量**。\n> - `i POPCNT #p`，令 $x_i\\gets\\operatorname{popcount}(p)$，其中 $\\operatorname{popcount}(\\cdot)$ 表示二进制中一的个数。\n>\n> 关于各类位运算的详细定义，选手可以自行搜索。", "inputFormat": "没有任何输入。", "outputFormat": "你可以选择提交答案的生成器代码，或者直接提交答案。如果想要直接提交答案的话需要把答案文件压缩到一个 zip 文件内并使用提交文件方式提交。\n\n首先 $24$ 行，第 $i$ 行一个 $[0,2^w)$ 内的整数 $x$ 表示排名为 $i$ 的排列 $p$ 的 $f$ 值 $f(p)=x$。\n\n接下来一行一个非负整数 $L$，表示电路涉及到的计算门个数。\n\n接下来 $L$ 行，每行描述一个计算门。", "hint": "**样例解释**\n\n样例仅供演示输出格式，并没有实际意义，也不能在本题得到任何分数。\n\n样例输出中的电路 $C$ 描述了 $C(x,y)=\\operatorname{popcount}((x\\oplus y)\\lor7)$。\n\n**电路模拟**\n\n我们在下发文件中提供了一个可以计算电路的运行结果的 C++ 代码 `compiler.cpp`（需要以至少 C++ 11 标准运行），选手可以使用 `compiler.cpp` 辅助理解电路的运行模式。\n\n注意：`compiler.cpp` 仅对合法的输入有效，对不合法的输入的运行结果不做任何保证。\n\n**评分标准**\n\n若你的输出出现下列情况，那么该测试点不得分：\n\n- $\\operatorname{cyc}(p\\circ q)\\neq C(f(p),f(q))$。\n- 电路 $C$ 不合法（使用标号不在 $[1,100]$ 内的变量 / 字面量的值 $\\ge2^w$ / 出现无法识别或不合法的语句 / 使用超过 $10^4$ 个运算门 / 运算门参数不合法）。\n\n否则若你使用了 $c$ 个运算门，那么你的得分为：\n\n$$\\mathrm{score}=\\begin{cases}100&c\\le 24\\\\\\left\\lfloor15.25\\log_{30}\\left(\\frac{0.09}{c-23}\\right)+111\\right\\rfloor&24<c\\le30\\\\\\left\\lceil-0.16c+95\\right\\rceil&30<c\\le350\\\\\\left\\lceil49\\cdot0.9994^{c}\\right\\rceil&350<c\\le10^4\\\\0&c>10^4\\end{cases}$$\n\n下表为在一些特殊的 $c$ 中选手在该测试点得到的分数：\n\n| $c$ | $\\mathrm{score}$ | $c$ | $\\mathrm{score}$ |\n| :---: | :---: | :---: | :---: |\n| $10^4$ | $1$ | $300$ | $47$ |\n| $6000$ | $2$ | $200$ | $63$ |\n| $5000$ | $3$ | $100$ | $79$ |\n| $3000$ | $9$ | $80$ | $83$ |\n| $2000$ | $15$ | $50$ | $87$ |\n| $1000$ | $27$ | $30$ | $91$ |\n| $700$ | $33$ | $25$ | $97$ |\n| $500$ | $37$ | $24$ | $100$ |\n\n这里给出 $c>24$ 时两张得分函数缩放不同的图像，以供参考（由 desmos 提供）。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n9l07rb3.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nxrlgckv.png)", "locale": "zh-CN"}}}
{"pid": "P13088", "type": "P", "difficulty": 7, "samples": [["", "1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n1024\n2048\n4096\n8192\n16384\n32768\n65536\n131072\n262144\n524288\n1048576\n2097152\n4194304\n8388608\n3\n3 XOR 1 2\n3 OR 3 N 7\n3 POPCNT 3"]], "limits": {"time": [1000], "memory": [524288]}, "tags": ["提交答案", "Special Judge", "O2优化"], "title": "『STA - H1』Code Golf (68bit)", "background": "这是问题的 68bit 版本。本题与 [24bit 版本](https://www.luogu.com.cn/problem/P13087)和 [16bit[v] 版本](https://www.luogu.com.cn/problem/P13086)的区别在于此版本中电路的位长 $w=68$。此外，[16bit[v] 版本](https://www.luogu.com.cn/problem/P13086)和本题的另一个区别是本题的电路中 `LSH` 与 `RSH` 的右操作数必须是字面量。", "description": "**本题为提交答案题。**\n\n以下是简要题面，关于其中名词的详细定义见后文（有些名词可能和你所见过的定义并不完全相符）。\n\n定义所有**长度为 $\\bm4$** 的排列组成的集合为 $\\mathcal P$，$w=\\color{blue}68$ 是位长，$B$ 是 $[0,2^w)$ 内的整数组成的集合。\n\n你需要设计一个**函数** $f:\\mathcal P\\to B$ 和一个**电路** $C:(B, B)\\to B$，使得对于任意 $p,q\\in\\mathcal P$ 都有：\n$$\\operatorname{cyc}(p\\circ q)=C(f(p),f(q))$$\n其中 $\\circ$ 是排列的复合，$\\operatorname{cyc}(\\cdot)$ 表示排列的置换环个数。\n\n电路 $C$ 中涉及到的运算门个数不能超过 $10^4$，得分将根据电路 $C$ 中的运算门个数评定，得分计算方式见说明 / 提示部分。\n***\n\n以下是可能涉及到的定义：\n\n> **关于排列**\n>\n> 一个长度为 $n$ 的排列是元素为 $1$ 到 $n$ 中互不重复的整数的长度为 $n$ 的序列。两个排列 $p,q$ 的复合 $(p\\circ q)_i=p_{q_i}$。对于一个排列 $p$，集合 $S$ 是其置换环当且仅当 $S$ 是极小的满足 $S=\\{p_x\\mid x\\in S\\}$ 的集合。$\\operatorname{cyc}(p)$ 是排列 $p$ 的置换环个数。\n>\n> 一个排列 $p$ 的排名是字典序不大于它的排列个数，关于字典序的定义选手可以自行搜索。\n>\n> **关于电路**\n>\n> 在一个电路 $C$ 中，你有 $100$ 个变量 $x_{1\\dots 100}$ 可供使用，其中 $x_1,x_2$ 是输入信号接收 $C$ 的两个参数，$x_3$ 是输出信号在电路运行完毕后作为 $C$ 的返回值传出。初始除了 $x_1,x_2$ 每个变量的值都是 $0$。每个变量都是 $B$ 内的整数，并且运算时随时保持对 $2^w$ 取模。你可以认为电路中的变量都是 $w$ 位的自然溢出的无符号整数。\n>\n> 一个数值有以下两种表达（后将值为 $p$ 的数值记作 `#p`，不带 `#` 的字母表示普通变量）：\n> - `i`，表示变量 $x_i$。\n> - `N n`，表示十进制字面量 $n$，其中 $0\\le n<2^w$。\n>\n> 电路由若干计算门组成，所有计算门按顺序依次进行。计算门分以下七种：\n> - `i AND #p #q`，令 $x_i\\gets p\\land q$，其中 $\\land$ 是按位与运算。\n> - `i OR #p #q`，令 $x_i\\gets p\\lor q$，其中 $\\lor$ 是按位或运算。\n> - `i XOR #p #q`，令 $x_i\\gets p\\oplus q$，其中 $\\oplus$ 是按位异或运算。\n> - `i NOT #p`，令 $x_i\\gets \\lnot p$，其中 $\\lnot$ 是按位取反运算。\n> - `i LSH #p #q`，令 $x_i\\gets p\\cdot 2^q$，**其中要求 $\\bm{q<w}$ 且 $\\bm q$ 必须是字面量**。\n> - `i RSH #p #q`，令 $x_i\\gets \\lfloor\\frac p{2^q}\\rfloor$，**其中要求 $\\bm{q<w}$ 且 $\\bm q$ 必须是字面量**。\n> - `i POPCNT #p`，令 $x_i\\gets\\operatorname{popcount}(p)$，其中 $\\operatorname{popcount}(\\cdot)$ 表示二进制中一的个数。\n>\n> 关于各类位运算的详细定义，选手可以自行搜索。", "inputFormat": "没有任何输入。", "outputFormat": "你可以选择提交答案的生成器代码，或者直接提交答案。如果想要直接提交答案的话需要把答案文件压缩到一个 zip 文件内并使用提交文件方式提交。\n\n首先 $24$ 行，第 $i$ 行一个 $[0,2^w)$ 内的整数 $x$ 表示排名为 $i$ 的排列 $p$ 的 $f$ 值 $f(p)=x$。\n\n接下来一行一个非负整数 $L$，表示电路涉及到的计算门个数。\n\n接下来 $L$ 行，每行描述一个计算门。", "hint": "**样例解释**\n\n样例仅供演示输出格式，并没有实际意义，也不能在本题得到任何分数。\n\n样例输出中的电路 $C$ 描述了 $C(x,y)=\\operatorname{popcount}((x\\oplus y)\\lor7)$。\n\n**电路模拟**\n\n我们在下发文件中提供了一个可以计算电路的运行结果的 C++ 代码 `compiler.cpp`（需要以 GCC、至少 C++ 11 标准运行），选手可以使用 `compiler.cpp` 辅助理解电路的运行模式。\n\n注意：`compiler.cpp` 仅对合法的输入有效，对不合法的输入的运行结果不做任何保证。\n\n**评分标准**\n\n若你的输出出现下列情况，那么该测试点不得分：\n\n- $\\operatorname{cyc}(p\\circ q)\\neq C(f(p),f(q))$。\n- 电路 $C$ 不合法（使用标号不在 $[1,100]$ 内的变量 / 字面量的值 $\\ge2^w$ / 出现无法识别或不合法的语句 / 使用超过 $10^4$ 个运算门 / 运算门参数不合法）。\n\n否则若你使用了 $c$ 个运算门，那么你的得分为：\n\n$$\\mathrm{score}=\\left\\lfloor\\frac{500}{\\max\\{5,\\min\\{500,x\\}\\}}\\right\\rfloor$$\n\n提示：如果 $c\\le5$，你的得分 $\\mathrm{score}=100$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "『STA - H1』Code Golf (68bit)", "background": "这是问题的 68bit 版本。本题与 [24bit 版本](https://www.luogu.com.cn/problem/P13087)和 [16bit[v] 版本](https://www.luogu.com.cn/problem/P13086)的区别在于此版本中电路的位长 $w=68$。此外，[16bit[v] 版本](https://www.luogu.com.cn/problem/P13086)和本题的另一个区别是本题的电路中 `LSH` 与 `RSH` 的右操作数必须是字面量。", "description": "**本题为提交答案题。**\n\n以下是简要题面，关于其中名词的详细定义见后文（有些名词可能和你所见过的定义并不完全相符）。\n\n定义所有**长度为 $\\bm4$** 的排列组成的集合为 $\\mathcal P$，$w=\\color{blue}68$ 是位长，$B$ 是 $[0,2^w)$ 内的整数组成的集合。\n\n你需要设计一个**函数** $f:\\mathcal P\\to B$ 和一个**电路** $C:(B, B)\\to B$，使得对于任意 $p,q\\in\\mathcal P$ 都有：\n$$\\operatorname{cyc}(p\\circ q)=C(f(p),f(q))$$\n其中 $\\circ$ 是排列的复合，$\\operatorname{cyc}(\\cdot)$ 表示排列的置换环个数。\n\n电路 $C$ 中涉及到的运算门个数不能超过 $10^4$，得分将根据电路 $C$ 中的运算门个数评定，得分计算方式见说明 / 提示部分。\n***\n\n以下是可能涉及到的定义：\n\n> **关于排列**\n>\n> 一个长度为 $n$ 的排列是元素为 $1$ 到 $n$ 中互不重复的整数的长度为 $n$ 的序列。两个排列 $p,q$ 的复合 $(p\\circ q)_i=p_{q_i}$。对于一个排列 $p$，集合 $S$ 是其置换环当且仅当 $S$ 是极小的满足 $S=\\{p_x\\mid x\\in S\\}$ 的集合。$\\operatorname{cyc}(p)$ 是排列 $p$ 的置换环个数。\n>\n> 一个排列 $p$ 的排名是字典序不大于它的排列个数，关于字典序的定义选手可以自行搜索。\n>\n> **关于电路**\n>\n> 在一个电路 $C$ 中，你有 $100$ 个变量 $x_{1\\dots 100}$ 可供使用，其中 $x_1,x_2$ 是输入信号接收 $C$ 的两个参数，$x_3$ 是输出信号在电路运行完毕后作为 $C$ 的返回值传出。初始除了 $x_1,x_2$ 每个变量的值都是 $0$。每个变量都是 $B$ 内的整数，并且运算时随时保持对 $2^w$ 取模。你可以认为电路中的变量都是 $w$ 位的自然溢出的无符号整数。\n>\n> 一个数值有以下两种表达（后将值为 $p$ 的数值记作 `#p`，不带 `#` 的字母表示普通变量）：\n> - `i`，表示变量 $x_i$。\n> - `N n`，表示十进制字面量 $n$，其中 $0\\le n<2^w$。\n>\n> 电路由若干计算门组成，所有计算门按顺序依次进行。计算门分以下七种：\n> - `i AND #p #q`，令 $x_i\\gets p\\land q$，其中 $\\land$ 是按位与运算。\n> - `i OR #p #q`，令 $x_i\\gets p\\lor q$，其中 $\\lor$ 是按位或运算。\n> - `i XOR #p #q`，令 $x_i\\gets p\\oplus q$，其中 $\\oplus$ 是按位异或运算。\n> - `i NOT #p`，令 $x_i\\gets \\lnot p$，其中 $\\lnot$ 是按位取反运算。\n> - `i LSH #p #q`，令 $x_i\\gets p\\cdot 2^q$，**其中要求 $\\bm{q<w}$ 且 $\\bm q$ 必须是字面量**。\n> - `i RSH #p #q`，令 $x_i\\gets \\lfloor\\frac p{2^q}\\rfloor$，**其中要求 $\\bm{q<w}$ 且 $\\bm q$ 必须是字面量**。\n> - `i POPCNT #p`，令 $x_i\\gets\\operatorname{popcount}(p)$，其中 $\\operatorname{popcount}(\\cdot)$ 表示二进制中一的个数。\n>\n> 关于各类位运算的详细定义，选手可以自行搜索。", "inputFormat": "没有任何输入。", "outputFormat": "你可以选择提交答案的生成器代码，或者直接提交答案。如果想要直接提交答案的话需要把答案文件压缩到一个 zip 文件内并使用提交文件方式提交。\n\n首先 $24$ 行，第 $i$ 行一个 $[0,2^w)$ 内的整数 $x$ 表示排名为 $i$ 的排列 $p$ 的 $f$ 值 $f(p)=x$。\n\n接下来一行一个非负整数 $L$，表示电路涉及到的计算门个数。\n\n接下来 $L$ 行，每行描述一个计算门。", "hint": "**样例解释**\n\n样例仅供演示输出格式，并没有实际意义，也不能在本题得到任何分数。\n\n样例输出中的电路 $C$ 描述了 $C(x,y)=\\operatorname{popcount}((x\\oplus y)\\lor7)$。\n\n**电路模拟**\n\n我们在下发文件中提供了一个可以计算电路的运行结果的 C++ 代码 `compiler.cpp`（需要以 GCC、至少 C++ 11 标准运行），选手可以使用 `compiler.cpp` 辅助理解电路的运行模式。\n\n注意：`compiler.cpp` 仅对合法的输入有效，对不合法的输入的运行结果不做任何保证。\n\n**评分标准**\n\n若你的输出出现下列情况，那么该测试点不得分：\n\n- $\\operatorname{cyc}(p\\circ q)\\neq C(f(p),f(q))$。\n- 电路 $C$ 不合法（使用标号不在 $[1,100]$ 内的变量 / 字面量的值 $\\ge2^w$ / 出现无法识别或不合法的语句 / 使用超过 $10^4$ 个运算门 / 运算门参数不合法）。\n\n否则若你使用了 $c$ 个运算门，那么你的得分为：\n\n$$\\mathrm{score}=\\left\\lfloor\\frac{500}{\\max\\{5,\\min\\{500,x\\}\\}}\\right\\rfloor$$\n\n提示：如果 $c\\le5$，你的得分 $\\mathrm{score}=100$。", "locale": "zh-CN"}}}
{"pid": "P13089", "type": "P", "difficulty": 7, "samples": [["5\nabb\n1 1 3 1 2\noixcpc\n1 1 4 5 1 4 1 9\ntarjen\n1 1 1 1 1 1 1\nnanani\n1 1 1 1 1 1 1\nwildfire\n1 1 1 1 1 1 1 1 1 1\n", "13\n109\n21\n21\n36"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "福建", "省赛/邀请赛"], "title": "[FJCPC 2025] We are watching you!", "background": "作弊哥是一个资深代打高手，他经常在 OCASU、oaiqnal、CPCX 等各种编程比赛中替别人代写代码，赚取了丰厚的收入。在比赛过程中，作弊哥会将题目的正确代码 $s_1$ 发送给作弊的参赛选手；这个参赛选手会在代码的 开头 随便加点没用的东西，构造出完整代码 $s$，就能提交。\n\n作弊哥靠着这招屡试不爽。然而，这一次他不幸被官方盯上了。\n\n作为官方的技术审查专家，小 A 需要对于选手提交的代码 $s$，分析 $s$ 的任意一个后缀的代码风格有多大概率出自于作弊哥。为了方便检验代码的同时，尽量不影响评测机速度，小 A 构造了一个能接受所有 $s$ 后缀的最小化确定型有限状态自动机（Deterministic Finite Automaton，DFA）。\n\n接下来，小 A 按深度优先搜索的方法，遍历这个 DFA，并分析出状态 $i$ 和作弊哥的代码风格有 $c_i$ 点相似度。小 A 认为子串 $s'$ 的相似度为 DFA 在输出 $s'$ 的过程中，经过状态的最大相似度；而完整代码的相似度为其所有非空子串相似度的平均值。\n\n现在，小 A 拿到了一些选手的完整代码 $s$，依此构建了最小化 DFA，并按深度优先搜索的遍历方法给出了 DFA 各状态的相似度。请你帮忙评估这些代码和作弊哥代码的相似度。\n\n如果你不了解 DFA 以及 DFA 的深度优先遍历，请阅读补充提示。\n\n", "description": "形式化的，以下代码描述了上述过程以及需求，但由于过大的时间复杂度，需要你优化并使其可以通过本题。\n\n```cpp\n#include <bits/stdc++.h>\nusing i64 = long long;\nstruct SAM {\n    struct Node {\n        int fa, len;\n        std::array<int, 26> trans; \n        Node() : fa{}, len{}, trans{} {}\n    };\n    std::vector<Node> t;\n    SAM() : t(2) {}\n    int New() {\n        t.push_back(Node());\n        return t.size() - 1;\n    }\n    int extend(int lst, int c) {\n        int u = lst, v;\n        if (trans(u, c)) {\n            if (len(u) + 1 == len(v = trans(u, c))) {\n                return v;\n            }\n            int x = New();\n            len(x) = len(u) + 1, fa(x) = fa(v);\n            t[x].trans = t[v].trans;\n            for (fa(v) = x; u && trans(u, c) == v; trans(u, c) = x, u = fa(u));\n            return x;\n        }\n        int x = New();\n        len(x) = len(u) + 1;\n        for(; u && !trans(u, c); trans(u, c) = x, u = fa(u));\n        if (!u) {\n            fa(x) = 1;\n        } else if (len(u) + 1 == len(v = trans(u, c))) {\n            fa(x) = v;\n        } else {\n            int w = New();\n            len(w) = len(u) + 1, fa(w) = fa(v);\n            t[w].trans = t[v].trans;\n            for (fa(v) = fa(x) = w; u && trans(u, c) == v; trans(u, c) = w, u = fa(u));\n        }\n        return x;\n    }\n    int& fa(int x) { return t[x].fa; }\n    int& len(int x) { return t[x].len; }\n    int& trans(int x, int c) { return t[x].trans[c]; }\n};\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n    SAM sam;\n    int lst = 1;\n    for (auto c : s) {  // 请注意这里是建立后缀自动机\n        lst = sam.extend(lst, c - 'a');\n    }\n    std::vector<int> c(sam.t.size());\n    for (int i = 1; i < c.size(); i++) {\n        std::cin >> c[i];\n    }\n    i64 ans = 0;\n    for (int i = 0; i < s.size(); i++) {\n        int now = c[1], x = 1;\n        for (int j = i; j >= 0; j--) {\n            x = sam.trans(x, s[j] - 'a');\n            now = std::max(now, c[x]);\n            ans += now;\n        }\n    }\n    std::cout << ans << std::endl;\n}\nint main() {\n    int T;\n    std::cin >> T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```", "inputFormat": "本题包含多组测试数据。\n\n第一行是一个正整数 $T$（$1\\leq T\\leq 2\\times 10^5$），表示有 $T$ 份完整代码。\n\n接下来 $T$ 组数据。第一行是一个由小写字母组成的字符串 $S$，表示选手提交的代码。保证字符串长度 $|S|$ 满足（$1\\leq |S|\\leq 2\\times 10^5$）。\n\n第二行由 $m$ 个整数 $c_1, c_2, \\cdots, c_m$（$1\\leq c_i\\leq 2\\times 10^5$）构成。其中 $m$ 表示小 A 构造的最小化 DFA 的状态数，$c_i$ 表示这个 DFA 按深度优先搜索，访问到的第 $i$ 个状态的相似度。\n\n数据保证 $\\sum|S|\\leq 2\\times 10^5$；数据保证对于每组的字符串 $S$，其所有后缀构成的最小化 DFA 状态数恰好为 $m$。", "outputFormat": "输出包含 $T$ 行，其中第 $i$ 行表示第 $i$ 份代码的相似度。\n\n为了避免除法运算，对于每个提问 $S$，你只需要输出答案乘上 $\\frac{|S|\\cdot (|S|+1)}{2}$，答案可以保证这是个整数。", "hint": "1. 确定型有限状态自动机（DFA）\n\n确定型有限状态自动机（DFA）是一个状态机。它从固定的起始状态 $q_0$ 出发，不断读入字符 $c$，并不断依此跳到后续状态；读入不同的字符将会跳转到不同的后续状态。如果读入完整个字符串后停在\"接受状态\"，我们认为 DFA 接受这个字符串；否则，认为 DFA 不接受这个字符串。特别的，如果 DFA 在某个状态 $q$ 时读入字符 $c$ 无后续状态，我们同样认为 DFA 不接受这个字符串。\n\n如下图所示，带两个圆的状态为接受状态。左侧的 DFA 从初始状态 $q_0$ 开始，读入 abab、bab、ab、b 后会分别停止于 $q_4, q_7, q_2, q_5$，均是接受状态；且读入其他字符串均不能进入接受状态。因此左侧的 DFA 可以接受 abab 的所有后缀；右侧的同理。\n\n对于能识别相同字符串的所有 DFA，我们认为状态最少的 DFA 就是最小化 DFA。可以证明，不同的最小化 DFA 可以通过给状态重新编号，而变成相同的 DFA。\n\n如该图所示，左右两侧的 DFA 均只能接受 abab、bab、ab、b 这四个字符串，因此两者等价。此外，可以证明，右侧的 DFA 是能识别这类字符串的最小化 DFA。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zpo9dm5b.png)\n\n2. DFA 的深度优先遍历\n\nDFA 的深度优先遍历将从起始状态 $q_0$ 开始，每次选择当前状态未访问的、按字母表从小到大的下一个字符对应的边，直到遍历完所有状态。各状态的编号即为其被访问到的顺序。\n\n如左侧的 DFA 的深度优先遍历顺序为 $q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7$；\n\n右侧 DFA 的深度优先遍历顺序为 $q_0, q_1, q_2, q_3, q_4$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] We are watching you!", "background": "作弊哥是一个资深代打高手，他经常在 OCASU、oaiqnal、CPCX 等各种编程比赛中替别人代写代码，赚取了丰厚的收入。在比赛过程中，作弊哥会将题目的正确代码 $s_1$ 发送给作弊的参赛选手；这个参赛选手会在代码的 开头 随便加点没用的东西，构造出完整代码 $s$，就能提交。\n\n作弊哥靠着这招屡试不爽。然而，这一次他不幸被官方盯上了。\n\n作为官方的技术审查专家，小 A 需要对于选手提交的代码 $s$，分析 $s$ 的任意一个后缀的代码风格有多大概率出自于作弊哥。为了方便检验代码的同时，尽量不影响评测机速度，小 A 构造了一个能接受所有 $s$ 后缀的最小化确定型有限状态自动机（Deterministic Finite Automaton，DFA）。\n\n接下来，小 A 按深度优先搜索的方法，遍历这个 DFA，并分析出状态 $i$ 和作弊哥的代码风格有 $c_i$ 点相似度。小 A 认为子串 $s'$ 的相似度为 DFA 在输出 $s'$ 的过程中，经过状态的最大相似度；而完整代码的相似度为其所有非空子串相似度的平均值。\n\n现在，小 A 拿到了一些选手的完整代码 $s$，依此构建了最小化 DFA，并按深度优先搜索的遍历方法给出了 DFA 各状态的相似度。请你帮忙评估这些代码和作弊哥代码的相似度。\n\n如果你不了解 DFA 以及 DFA 的深度优先遍历，请阅读补充提示。\n\n", "description": "形式化的，以下代码描述了上述过程以及需求，但由于过大的时间复杂度，需要你优化并使其可以通过本题。\n\n```cpp\n#include <bits/stdc++.h>\nusing i64 = long long;\nstruct SAM {\n    struct Node {\n        int fa, len;\n        std::array<int, 26> trans; \n        Node() : fa{}, len{}, trans{} {}\n    };\n    std::vector<Node> t;\n    SAM() : t(2) {}\n    int New() {\n        t.push_back(Node());\n        return t.size() - 1;\n    }\n    int extend(int lst, int c) {\n        int u = lst, v;\n        if (trans(u, c)) {\n            if (len(u) + 1 == len(v = trans(u, c))) {\n                return v;\n            }\n            int x = New();\n            len(x) = len(u) + 1, fa(x) = fa(v);\n            t[x].trans = t[v].trans;\n            for (fa(v) = x; u && trans(u, c) == v; trans(u, c) = x, u = fa(u));\n            return x;\n        }\n        int x = New();\n        len(x) = len(u) + 1;\n        for(; u && !trans(u, c); trans(u, c) = x, u = fa(u));\n        if (!u) {\n            fa(x) = 1;\n        } else if (len(u) + 1 == len(v = trans(u, c))) {\n            fa(x) = v;\n        } else {\n            int w = New();\n            len(w) = len(u) + 1, fa(w) = fa(v);\n            t[w].trans = t[v].trans;\n            for (fa(v) = fa(x) = w; u && trans(u, c) == v; trans(u, c) = w, u = fa(u));\n        }\n        return x;\n    }\n    int& fa(int x) { return t[x].fa; }\n    int& len(int x) { return t[x].len; }\n    int& trans(int x, int c) { return t[x].trans[c]; }\n};\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n    SAM sam;\n    int lst = 1;\n    for (auto c : s) {  // 请注意这里是建立后缀自动机\n        lst = sam.extend(lst, c - 'a');\n    }\n    std::vector<int> c(sam.t.size());\n    for (int i = 1; i < c.size(); i++) {\n        std::cin >> c[i];\n    }\n    i64 ans = 0;\n    for (int i = 0; i < s.size(); i++) {\n        int now = c[1], x = 1;\n        for (int j = i; j >= 0; j--) {\n            x = sam.trans(x, s[j] - 'a');\n            now = std::max(now, c[x]);\n            ans += now;\n        }\n    }\n    std::cout << ans << std::endl;\n}\nint main() {\n    int T;\n    std::cin >> T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}\n```", "inputFormat": "本题包含多组测试数据。\n\n第一行是一个正整数 $T$（$1\\leq T\\leq 2\\times 10^5$），表示有 $T$ 份完整代码。\n\n接下来 $T$ 组数据。第一行是一个由小写字母组成的字符串 $S$，表示选手提交的代码。保证字符串长度 $|S|$ 满足（$1\\leq |S|\\leq 2\\times 10^5$）。\n\n第二行由 $m$ 个整数 $c_1, c_2, \\cdots, c_m$（$1\\leq c_i\\leq 2\\times 10^5$）构成。其中 $m$ 表示小 A 构造的最小化 DFA 的状态数，$c_i$ 表示这个 DFA 按深度优先搜索，访问到的第 $i$ 个状态的相似度。\n\n数据保证 $\\sum|S|\\leq 2\\times 10^5$；数据保证对于每组的字符串 $S$，其所有后缀构成的最小化 DFA 状态数恰好为 $m$。", "outputFormat": "输出包含 $T$ 行，其中第 $i$ 行表示第 $i$ 份代码的相似度。\n\n为了避免除法运算，对于每个提问 $S$，你只需要输出答案乘上 $\\frac{|S|\\cdot (|S|+1)}{2}$，答案可以保证这是个整数。", "hint": "1. 确定型有限状态自动机（DFA）\n\n确定型有限状态自动机（DFA）是一个状态机。它从固定的起始状态 $q_0$ 出发，不断读入字符 $c$，并不断依此跳到后续状态；读入不同的字符将会跳转到不同的后续状态。如果读入完整个字符串后停在\"接受状态\"，我们认为 DFA 接受这个字符串；否则，认为 DFA 不接受这个字符串。特别的，如果 DFA 在某个状态 $q$ 时读入字符 $c$ 无后续状态，我们同样认为 DFA 不接受这个字符串。\n\n如下图所示，带两个圆的状态为接受状态。左侧的 DFA 从初始状态 $q_0$ 开始，读入 abab、bab、ab、b 后会分别停止于 $q_4, q_7, q_2, q_5$，均是接受状态；且读入其他字符串均不能进入接受状态。因此左侧的 DFA 可以接受 abab 的所有后缀；右侧的同理。\n\n对于能识别相同字符串的所有 DFA，我们认为状态最少的 DFA 就是最小化 DFA。可以证明，不同的最小化 DFA 可以通过给状态重新编号，而变成相同的 DFA。\n\n如该图所示，左右两侧的 DFA 均只能接受 abab、bab、ab、b 这四个字符串，因此两者等价。此外，可以证明，右侧的 DFA 是能识别这类字符串的最小化 DFA。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/zpo9dm5b.png)\n\n2. DFA 的深度优先遍历\n\nDFA 的深度优先遍历将从起始状态 $q_0$ 开始，每次选择当前状态未访问的、按字母表从小到大的下一个字符对应的边，直到遍历完所有状态。各状态的编号即为其被访问到的顺序。\n\n如左侧的 DFA 的深度优先遍历顺序为 $q_0, q_1, q_2, q_3, q_4, q_5, q_6, q_7$；\n\n右侧 DFA 的深度优先遍历顺序为 $q_0, q_1, q_2, q_3, q_4$。", "locale": "zh-CN"}}}
{"pid": "P13090", "type": "P", "difficulty": 5, "samples": [["8 7\n", "0 0 1 2 2 1 1 1\n"], ["10 8\n", "0 0 1 2 2 2 2 1 1 1"], ["12 1\n", "0 1 2 2 3 3 2 2 2 1 1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "福建", "前缀和", "省赛/邀请赛"], "title": "[FJCPC 2025] XCPC", "background": "", "description": "XCPC 赛事拥有金、银、铜、铁四种奖牌。作为一名参与该赛事的魔法师，小 A 可通过金、银、铜、铁四种奖牌作为媒介，施展“红日初升”法阵，召唤太阳，祈求保佑。\n\n在施展“红日初升”法阵的过程中，每一个奖牌都可以提供光亮值。其中金、银、铜、铁奖牌分别具有 $4$，$3$，$2$，$1$ 的光亮值。而施展“红日初升”法阵要求所有奖牌的光亮值之和大于等于 $p$ 。\n\n初始时小 A 有 $n$ 块铁牌，他可以通过炼金术进行奖牌转换：将 $2$ 个铁牌合成 $1$ 个铜牌、将 $2$ 个铜牌合成 $1$ 个银牌、将 $2$ 个银牌合成 $1$ 个金牌。\n\n假设用四元组 $(a_1,a_2,a_3,a_4)$ 分别表示金、银、铜、铁奖牌的数量。请回答以下 $n$ 个问题，其中第 $i~(1\\le i\\le n)$ 个问题是：\n\n* 初始有 $n$ 块铁牌，最终有多少种不同的四元组 $(a_1,a_2,a_3,a_4)$，同时满足：\n\n（1）一共有 $i$ 个牌子，即 $a_1+a_2+a_3+a_4=i$；\n\n（2）可以施展“红日初升”法阵，即 $4a_1+3a_2+2a_3+a_4\\ge p$。\n\n其中 $p$ 通过输入给定。\n\n两个四元组不同当且仅当它们存在某一位对应的数字不同。\n", "inputFormat": "第一行输入两个整数 $n,p~(1\\le p\\le n\\le 10^6)$，用空格相隔，分别表示初始有 $n$ 个奖牌，以及问题要求的奖牌价值之和大于等于 $p$。\n", "outputFormat": "输出一行 $n$ 个整数，用空格相隔，第 $i~(1\\le i\\le n)$ 个数字表示第 $i$ 个问题的答案。\n", "hint": "**样例解释**：对于样例一，初始的 $8$ 个铁牌最终可以得到多个四元组，以下列出光亮值之和大于等于 $7$ 的：\n\n* 第 $1,2$ 个问题：（无）；\n\n* 第 $3$ 个问题：$(0,1,2,0)$；\n\n* 第 $4$ 个问题：$(0,0,4,0),(0,1,1,2)$；\n\n* 第 $5$ 个问题：$(0,1,0,4),(0,0,3,2)$；\n\n* 第 $6$ 个问题：$(0,0,2,4)$；\n\n* 第 $7$ 个问题：$(0,0,1,6)$；\n\n* 第 $8$ 个问题：$(0,0,0,8)$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] XCPC", "background": "", "description": "XCPC 赛事拥有金、银、铜、铁四种奖牌。作为一名参与该赛事的魔法师，小 A 可通过金、银、铜、铁四种奖牌作为媒介，施展“红日初升”法阵，召唤太阳，祈求保佑。\n\n在施展“红日初升”法阵的过程中，每一个奖牌都可以提供光亮值。其中金、银、铜、铁奖牌分别具有 $4$，$3$，$2$，$1$ 的光亮值。而施展“红日初升”法阵要求所有奖牌的光亮值之和大于等于 $p$ 。\n\n初始时小 A 有 $n$ 块铁牌，他可以通过炼金术进行奖牌转换：将 $2$ 个铁牌合成 $1$ 个铜牌、将 $2$ 个铜牌合成 $1$ 个银牌、将 $2$ 个银牌合成 $1$ 个金牌。\n\n假设用四元组 $(a_1,a_2,a_3,a_4)$ 分别表示金、银、铜、铁奖牌的数量。请回答以下 $n$ 个问题，其中第 $i~(1\\le i\\le n)$ 个问题是：\n\n* 初始有 $n$ 块铁牌，最终有多少种不同的四元组 $(a_1,a_2,a_3,a_4)$，同时满足：\n\n（1）一共有 $i$ 个牌子，即 $a_1+a_2+a_3+a_4=i$；\n\n（2）可以施展“红日初升”法阵，即 $4a_1+3a_2+2a_3+a_4\\ge p$。\n\n其中 $p$ 通过输入给定。\n\n两个四元组不同当且仅当它们存在某一位对应的数字不同。\n", "inputFormat": "第一行输入两个整数 $n,p~(1\\le p\\le n\\le 10^6)$，用空格相隔，分别表示初始有 $n$ 个奖牌，以及问题要求的奖牌价值之和大于等于 $p$。\n", "outputFormat": "输出一行 $n$ 个整数，用空格相隔，第 $i~(1\\le i\\le n)$ 个数字表示第 $i$ 个问题的答案。\n", "hint": "**样例解释**：对于样例一，初始的 $8$ 个铁牌最终可以得到多个四元组，以下列出光亮值之和大于等于 $7$ 的：\n\n* 第 $1,2$ 个问题：（无）；\n\n* 第 $3$ 个问题：$(0,1,2,0)$；\n\n* 第 $4$ 个问题：$(0,0,4,0),(0,1,1,2)$；\n\n* 第 $5$ 个问题：$(0,1,0,4),(0,0,3,2)$；\n\n* 第 $6$ 个问题：$(0,0,2,4)$；\n\n* 第 $7$ 个问题：$(0,0,1,6)$；\n\n* 第 $8$ 个问题：$(0,0,0,8)$。", "locale": "zh-CN"}}}
{"pid": "P13091", "type": "P", "difficulty": 5, "samples": [["6\n1\n1\n3\n1 2 2\n5\n1 3 4 5 2\n7\n1 2 3 5 6 7 4\n9\n9 9 8 2 4 4 3 5 3\n9\n4 4 9 2 9 5 8 3 3", "1 \n2 \n3 \n5 \n9 \n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["二分", "2025", "福建", "省赛/邀请赛"], "title": "[FJCPC 2025] 中位数", "background": "", "description": " CFJ 拥有一个长度为 $n$ 的数组 $a$，且 $n$ 必定为奇数。\n\n由于 CFJ 十分喜爱中位数，他将进行以下操作：每次选择数组中连续的三个数字，并将它们合并为其中位数，替换这三个数字。具体而言，每次选择任意一个位置 $i$（满足 $1 < i < n$），删除 $a_{i-1}$、$a_i$ 和 $a_{i+1}$，并在该位置插入这三个数字的中位数。\n\n CFJ 将持续进行上述操作，直到数组中仅剩一个数字为止。整个过程共需进行 $\\frac{n-1}{2}$ 次合并。他期望这个最终剩余的数字尽可能大。你的任务是帮助 CFJ 确定这个数字的最大可能值。\n\n**中位数的定义为：将一组长度为 $n$ 的数组从小到大排序后，排名第$\\lfloor \\frac{n+1}{2} \\rfloor$小的数字。**", "inputFormat": "**本题包含多组测试数据。**\n\n第一行，包含一个整数 $T$（$1\\le T \\le 10^6$），表示测试数据的组数。\n\n对于每组数据：\n\n第一行，包含一个整数 $n$（$1\\le n< 10^5$），且 $n$ 必定为奇数。\n\n第二行，包含 $n$ 个整数 $a_1,a_2,\\cdots, a_n$（$1\\le a_i\\le 10^9$）。\n\n数据保证 $\\sum n \\leq 10^6$。", "outputFormat": "对于每个测试用例，输出 $\\frac{n-1}{2}$ 次合并以后剩下数字的最大值。\n\n", "hint": "对于第四个样例而言，数组 $ A = [ \\ 1 \\ 2 \\ 3 \\ 5 \\ 6 \\ 7 \\ 4 \\ ] $ 一种可行的方案是：$ [ \\  \\underline{1 \\ 2 \\ 3} \\ 5 \\ 6 \\ 7 \\ 4 \\ ] \\rightarrow [ \\ \\underline{2 \\ 5 \\ 6}  \\ 7  \\ 4 \\ ] \\rightarrow [ \\ \\underline{5 \\ 7 \\ 4} \\  ] \\rightarrow [ \\ 5 \\ ]$。\n\n其中 $  \\underline{a_{i-1} \\ a_i \\ a_{i+1}}  $ 下划线选择的连续三个数字表示每次操作合并的对象。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 中位数", "background": "", "description": " CFJ 拥有一个长度为 $n$ 的数组 $a$，且 $n$ 必定为奇数。\n\n由于 CFJ 十分喜爱中位数，他将进行以下操作：每次选择数组中连续的三个数字，并将它们合并为其中位数，替换这三个数字。具体而言，每次选择任意一个位置 $i$（满足 $1 < i < n$），删除 $a_{i-1}$、$a_i$ 和 $a_{i+1}$，并在该位置插入这三个数字的中位数。\n\n CFJ 将持续进行上述操作，直到数组中仅剩一个数字为止。整个过程共需进行 $\\frac{n-1}{2}$ 次合并。他期望这个最终剩余的数字尽可能大。你的任务是帮助 CFJ 确定这个数字的最大可能值。\n\n**中位数的定义为：将一组长度为 $n$ 的数组从小到大排序后，排名第$\\lfloor \\frac{n+1}{2} \\rfloor$小的数字。**", "inputFormat": "**本题包含多组测试数据。**\n\n第一行，包含一个整数 $T$（$1\\le T \\le 10^6$），表示测试数据的组数。\n\n对于每组数据：\n\n第一行，包含一个整数 $n$（$1\\le n< 10^5$），且 $n$ 必定为奇数。\n\n第二行，包含 $n$ 个整数 $a_1,a_2,\\cdots, a_n$（$1\\le a_i\\le 10^9$）。\n\n数据保证 $\\sum n \\leq 10^6$。", "outputFormat": "对于每个测试用例，输出 $\\frac{n-1}{2}$ 次合并以后剩下数字的最大值。\n\n", "hint": "对于第四个样例而言，数组 $ A = [ \\ 1 \\ 2 \\ 3 \\ 5 \\ 6 \\ 7 \\ 4 \\ ] $ 一种可行的方案是：$ [ \\  \\underline{1 \\ 2 \\ 3} \\ 5 \\ 6 \\ 7 \\ 4 \\ ] \\rightarrow [ \\ \\underline{2 \\ 5 \\ 6}  \\ 7  \\ 4 \\ ] \\rightarrow [ \\ \\underline{5 \\ 7 \\ 4} \\  ] \\rightarrow [ \\ 5 \\ ]$。\n\n其中 $  \\underline{a_{i-1} \\ a_i \\ a_{i+1}}  $ 下划线选择的连续三个数字表示每次操作合并的对象。", "locale": "zh-CN"}}}
{"pid": "P13092", "type": "P", "difficulty": 5, "samples": [["3\n2\n1 2\n14\n8 14\n5 10\n9 14\n2 4\n12 13\n7 14\n1 5\n2 6\n2 1\n7 12\n3 5\n12 4\n11 2\n10\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n1 8\n8 9\n8 10", "1\n4\n7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "福建", "Special Judge", "省赛/邀请赛"], "title": "[FJCPC 2025] 二叉树", "background": "", "description": "墨菲特非常喜欢完美的树。在某一天，他决定用茂凯给的神秘种子自己种一棵树。\n\n这颗种子拥有非常旺盛的生命力。将这颗种子种下后，如果我们把第一天种下的种子记为初始的叶子节点，那么从第二天开始，每个前一天长出来的叶子节点，都会长出两个新的叶子节点。换句话说，如果这颗树生长了 $k$ 天，那么它就是一棵拥有 $2^k - 1$ 个节点的满二叉树。\n\n由于其迅速的生长速度，墨菲特很快就能得到一棵拥有很多节点的满二叉树，他认为满二叉树是十分完美的。\n\n茂凯也知道墨菲特非常喜欢树，因此他带来了一份礼物：由同样的神秘种子种出来的一棵树（大小不一定相同）。然而墨菲特已经有一颗这样的树了，两棵树的存放不太方便，于是他在两棵树之间连接了一条新的边，这样就是一棵树了。\n\n显然，这样的树已经不是完美的二叉树了，因此墨菲特很快就把他丢在了角落。\n\n过了很久很久之后，墨菲特又想起来了这棵由两棵满二叉树连接形成的新树，他想要重新把这棵树拆成两棵满二叉树，但是他已经忘记哪条边是他额外添加上去的了。\n\n希望聪明的你可以帮助墨菲特解决这个问题。\n\n形式化地，给定一棵树，你需要删除其中的一条边，使得分成的两棵树都是满二叉树，保证至少存在一个解。\n\n*所有叶结点的深度均相同，且所有非叶节点的子节点数量均为 $2$ 的二叉树称为满二叉树。", "inputFormat": "**输入包含多组测试数据。**\n\n第一行包含一个正整数 $T$ ( $1 \\le T \\le 10^5$ ) ，表示测试数据的数量。接下来是测试数据的描述。\n\n每组测试数据的第一行包含一个正整数 $n\\ (2 \\le n \\le 2^{17} - 2)$ ，表示墨菲特手上的树的节点个数。\n\n接下来 $n - 1$ 行，每行两个由空格分开的正整数 $u_i, v_i\\ (1 \\le u_i, v_i \\le n)$ ，表示树上的一条边 $(u_i, v_i)$ 。输入保证给定的边集构成一棵树。\n\n另外，保证 $\\sum n \\le 10^6$ 。", "outputFormat": "对于每一组测试数据，输出一行一个正整数 $i$ ，表示如果删除了给定边集中的第 $i$ 条边 $(u_i, v_i)$ ，分成的两棵树都是满二叉树。保证这样的解一定存在。如果有多个可行的解，输出任意一个即可。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/u2r7vj65.png)\n\n第二组样例的树如上图所示，可以发现，只有删除边 $(2, 4)$ 是合法的。\n\n第三组样例的树如下图所示，可以发现，删除边 $(1, 2), (1, 3), (1, 8)$ 都是合法的，你可以输出任意一种。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 二叉树", "background": "", "description": "墨菲特非常喜欢完美的树。在某一天，他决定用茂凯给的神秘种子自己种一棵树。\n\n这颗种子拥有非常旺盛的生命力。将这颗种子种下后，如果我们把第一天种下的种子记为初始的叶子节点，那么从第二天开始，每个前一天长出来的叶子节点，都会长出两个新的叶子节点。换句话说，如果这颗树生长了 $k$ 天，那么它就是一棵拥有 $2^k - 1$ 个节点的满二叉树。\n\n由于其迅速的生长速度，墨菲特很快就能得到一棵拥有很多节点的满二叉树，他认为满二叉树是十分完美的。\n\n茂凯也知道墨菲特非常喜欢树，因此他带来了一份礼物：由同样的神秘种子种出来的一棵树（大小不一定相同）。然而墨菲特已经有一颗这样的树了，两棵树的存放不太方便，于是他在两棵树之间连接了一条新的边，这样就是一棵树了。\n\n显然，这样的树已经不是完美的二叉树了，因此墨菲特很快就把他丢在了角落。\n\n过了很久很久之后，墨菲特又想起来了这棵由两棵满二叉树连接形成的新树，他想要重新把这棵树拆成两棵满二叉树，但是他已经忘记哪条边是他额外添加上去的了。\n\n希望聪明的你可以帮助墨菲特解决这个问题。\n\n形式化地，给定一棵树，你需要删除其中的一条边，使得分成的两棵树都是满二叉树，保证至少存在一个解。\n\n*所有叶结点的深度均相同，且所有非叶节点的子节点数量均为 $2$ 的二叉树称为满二叉树。", "inputFormat": "**输入包含多组测试数据。**\n\n第一行包含一个正整数 $T$ ( $1 \\le T \\le 10^5$ ) ，表示测试数据的数量。接下来是测试数据的描述。\n\n每组测试数据的第一行包含一个正整数 $n\\ (2 \\le n \\le 2^{17} - 2)$ ，表示墨菲特手上的树的节点个数。\n\n接下来 $n - 1$ 行，每行两个由空格分开的正整数 $u_i, v_i\\ (1 \\le u_i, v_i \\le n)$ ，表示树上的一条边 $(u_i, v_i)$ 。输入保证给定的边集构成一棵树。\n\n另外，保证 $\\sum n \\le 10^6$ 。", "outputFormat": "对于每一组测试数据，输出一行一个正整数 $i$ ，表示如果删除了给定边集中的第 $i$ 条边 $(u_i, v_i)$ ，分成的两棵树都是满二叉树。保证这样的解一定存在。如果有多个可行的解，输出任意一个即可。", "hint": "![](https://cdn.luogu.com.cn/upload/image_hosting/u2r7vj65.png)\n\n第二组样例的树如上图所示，可以发现，只有删除边 $(2, 4)$ 是合法的。\n\n第三组样例的树如下图所示，可以发现，删除边 $(1, 2), (1, 3), (1, 8)$ 都是合法的，你可以输出任意一种。", "locale": "zh-CN"}}}
{"pid": "P13093", "type": "P", "difficulty": 5, "samples": [["4\n2\n1 3 2 4\n1\n1000000000 1\n3\n1 1 2 3 5 8\n4\n1 2 4 8 16 32 64 128", "5\n1\n9\n106"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "福建", "前缀和", "省赛/邀请赛"], "title": "[FJCPC 2025] 卡牌游戏", "background": "", "description": "小 A 和小 B 正在玩卡牌游戏。\n\n有 $2n$ 张卡牌垒成一摞牌堆，自上而下的第 $i$（$1\\leq i\\leq 2n$）张牌上标注了数字 $a_i$。发牌时，牌堆中的卡牌自上而下以 $1, 2, \\dots, 2n$ 编号，编号为奇数的卡牌将分给一位玩家，编号为偶数的卡牌将分给另一位玩家。这意味着，小 A 将会获得编号同为奇数或同为偶数的 $n$ 张卡牌。\n\n对于玩家而言，所得到的卡牌上的数字之和越大，游戏局面对他越有利。因此小 A 想最大化最坏情况下他所得到的卡牌数字之和。为了达到这个目的，小 A 可以对当前牌堆执行恰好一次以下操作：\n\n-   从当前牌堆中抽出一张卡牌，并插回牌堆中的任意位置。注意发牌时的编号可能会发生变化。\n\n例如，初始时牌堆中卡牌标注的数字自上而下依次是 $1, 2, 3, 4$，发牌时一位玩家将得到 $1, 3$，另一位玩家将得到 $2, 4$。小 A 可以选择抽出第二张卡牌，并将其插回最后一张卡牌后面，此时牌堆为 $1, 3, 4, 2$，发牌时一位玩家将得到 $1, 4$，另一位玩家将得到 $3, 2$。\n\n你需要求出小 A 在执行恰好一次操作后，最坏情况下所得到的卡牌数字之和的最大值。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行，一个正整数 $t$（$1\\leq t\\leq 10^4$），表示测试数据组数。\n\n对于每组数据：\n\n第一行，一个正整数 $n$（$1\\leq n\\leq 10^5$），表示每位玩家将得到的卡牌数量。\n\n第二行，$2n$ 个正整数 $a_1, a_2, \\dots, a_{2n}$（$1\\leq a_i\\leq 10^9$），表示当前牌堆中卡牌标注的数字。\n\n对于每个测试点，保证 $\\sum n$ 不超过 $10^5$。", "outputFormat": "对于每组数据，输出一行，一个整数，表示在执行恰好一次操作后，最坏情况下小 A 所得到的卡牌数字之和的最大值。", "hint": "第一组样例即是题目描述中所给出的例子。发牌时，一位玩家的卡牌数字之和为 $1 + 4 = 5$，另一位玩家的卡牌数字之和为 $3 + 2 = 5$，可以证明这即是所能取得的最大值。\n\n第二组样例中，无论如何操作，发牌情况都将是一位玩家得到 $1$，而另一位玩家得到 $10^9$。因此最坏情况下小 A 只能得到 $1$，即为答案。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 卡牌游戏", "background": "", "description": "小 A 和小 B 正在玩卡牌游戏。\n\n有 $2n$ 张卡牌垒成一摞牌堆，自上而下的第 $i$（$1\\leq i\\leq 2n$）张牌上标注了数字 $a_i$。发牌时，牌堆中的卡牌自上而下以 $1, 2, \\dots, 2n$ 编号，编号为奇数的卡牌将分给一位玩家，编号为偶数的卡牌将分给另一位玩家。这意味着，小 A 将会获得编号同为奇数或同为偶数的 $n$ 张卡牌。\n\n对于玩家而言，所得到的卡牌上的数字之和越大，游戏局面对他越有利。因此小 A 想最大化最坏情况下他所得到的卡牌数字之和。为了达到这个目的，小 A 可以对当前牌堆执行恰好一次以下操作：\n\n-   从当前牌堆中抽出一张卡牌，并插回牌堆中的任意位置。注意发牌时的编号可能会发生变化。\n\n例如，初始时牌堆中卡牌标注的数字自上而下依次是 $1, 2, 3, 4$，发牌时一位玩家将得到 $1, 3$，另一位玩家将得到 $2, 4$。小 A 可以选择抽出第二张卡牌，并将其插回最后一张卡牌后面，此时牌堆为 $1, 3, 4, 2$，发牌时一位玩家将得到 $1, 4$，另一位玩家将得到 $3, 2$。\n\n你需要求出小 A 在执行恰好一次操作后，最坏情况下所得到的卡牌数字之和的最大值。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行，一个正整数 $t$（$1\\leq t\\leq 10^4$），表示测试数据组数。\n\n对于每组数据：\n\n第一行，一个正整数 $n$（$1\\leq n\\leq 10^5$），表示每位玩家将得到的卡牌数量。\n\n第二行，$2n$ 个正整数 $a_1, a_2, \\dots, a_{2n}$（$1\\leq a_i\\leq 10^9$），表示当前牌堆中卡牌标注的数字。\n\n对于每个测试点，保证 $\\sum n$ 不超过 $10^5$。", "outputFormat": "对于每组数据，输出一行，一个整数，表示在执行恰好一次操作后，最坏情况下小 A 所得到的卡牌数字之和的最大值。", "hint": "第一组样例即是题目描述中所给出的例子。发牌时，一位玩家的卡牌数字之和为 $1 + 4 = 5$，另一位玩家的卡牌数字之和为 $3 + 2 = 5$，可以证明这即是所能取得的最大值。\n\n第二组样例中，无论如何操作，发牌情况都将是一位玩家得到 $1$，而另一位玩家得到 $10^9$。因此最坏情况下小 A 只能得到 $1$，即为答案。", "locale": "zh-CN"}}}
{"pid": "P13094", "type": "P", "difficulty": 6, "samples": [["8 7\n1 9 7 8 0 7 2 3\n19 20 5 6 1 14 9 5\n1 8\n3 7\n2 6\n4 4\n5 7\n3 8\n6 7", "1\n2\n1\n1\n1\n2\n1"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["2025", "福建", "cdq 分治", "扫描线", "省赛/邀请赛"], "title": "[FJCPC 2025] 帕累托前沿", "background": "", "description": "给出 $n$ 个二元组 $(x_i,y_i)$，你需要回答 $q$ 个询问，每个询问给出闭区间 $[l,r]$，请回答满足以下条件的整数 $j$ 数量：\n\n- $l\\leq j\\leq r$；\n\n- 不存在 $l\\leq k\\leq r, k\\neq j$，使得 $x_k\\geq x_j$ 且 $y_k\\geq y_j$。", "inputFormat": "第一行两个正整数 $n,q$（$1\\leq n,q\\leq 10^6$），分别表示二元组数量和询问数量。\n\n第二行 $n$ 个非负整数 $x_1,x_2,\\dots,x_n$（$0\\le x_i\\le 10^6$）。\n\n第三行 $n$ 个非负整数 $y_1,y_2,\\dots,y_n$（$0\\le y_i\\le 10^6$）。\n\n接下来 $q$ 行，每行两个正整数 $l,r$（$1\\leq l\\leq r\\leq n$），表示询问的区间。", "outputFormat": "对于每个询问，输出一行一个整数表示答案。", "hint": "对于询问 $1$，满足条件的整数为 $2$。\n\n对于询问 $2$，满足条件的整数为 $4$、$6$。\n\n对于询问 $3$，满足条件的整数为 $2$。\n\n对于询问 $4$，满足条件的整数为 $4$。\n\n对于询问 $5$，满足条件的整数为 $6$。\n\n对于询问 $6$，满足条件的整数为 $4$、$6$。\n\n对于询问 $7$，满足条件的整数为 $6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 帕累托前沿", "background": "", "description": "给出 $n$ 个二元组 $(x_i,y_i)$，你需要回答 $q$ 个询问，每个询问给出闭区间 $[l,r]$，请回答满足以下条件的整数 $j$ 数量：\n\n- $l\\leq j\\leq r$；\n\n- 不存在 $l\\leq k\\leq r, k\\neq j$，使得 $x_k\\geq x_j$ 且 $y_k\\geq y_j$。", "inputFormat": "第一行两个正整数 $n,q$（$1\\leq n,q\\leq 10^6$），分别表示二元组数量和询问数量。\n\n第二行 $n$ 个非负整数 $x_1,x_2,\\dots,x_n$（$0\\le x_i\\le 10^6$）。\n\n第三行 $n$ 个非负整数 $y_1,y_2,\\dots,y_n$（$0\\le y_i\\le 10^6$）。\n\n接下来 $q$ 行，每行两个正整数 $l,r$（$1\\leq l\\leq r\\leq n$），表示询问的区间。", "outputFormat": "对于每个询问，输出一行一个整数表示答案。", "hint": "对于询问 $1$，满足条件的整数为 $2$。\n\n对于询问 $2$，满足条件的整数为 $4$、$6$。\n\n对于询问 $3$，满足条件的整数为 $2$。\n\n对于询问 $4$，满足条件的整数为 $4$。\n\n对于询问 $5$，满足条件的整数为 $6$。\n\n对于询问 $6$，满足条件的整数为 $4$、$6$。\n\n对于询问 $7$，满足条件的整数为 $6$。", "locale": "zh-CN"}}}
{"pid": "P13095", "type": "P", "difficulty": 2, "samples": [["6 2\n3 2 4 5 3 6\n2\n2 4\n3 6", "5\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "福建", "省赛/邀请赛"], "title": "[FJCPC 2025] 炒股高手", "background": "", "description": "小 A 立志成为一名炒股高手。经过长时间的学习，他自信已掌握了丰富的理论知识，并精心挑选出了一支股票，决定在接下来的 $n$ 个交易日内进行实战操作。\n\n股票之神向小 A 投来了注视，他帮你预知了接下来 $n$ 个交易日中这只股票的股价。由于股票之神擅长数学，所有价格均以自然对数的形式给出。也就是说，在第 $i$ 天（$1 \\leq i \\leq n$），会得到一个正整数 $a_i$，表示当天该股票的价格为 $e^{a_i}$ 元。需要注意的是，在本题中，小 A 可以购买非整数份的股票。\n\n由于手头资金有限，小 A 决定公开向他人借款，称为\"鸡债\"。为了方便管理和收益核算，他规定每位出借人均提供固定的 $e^k$ 元借款。\n\n在这 $n$ 天内，共有 $m$ 位出借人愿意向小 A 提供鸡债。\n\n对于第 $i$ 位出借人，他会在第 $s_i$ 天开盘前向小 A 提供 $e^k$ 元，在第 $t_i$ 天收盘后要求结算收益。在这段时间内，小 A 可自由使用这笔资金进行任意次数的买入与卖出操作。\n\n你的任务是：对于每一笔鸡债，计算小 A 在最优操作下所能获得的最终总资产（即本金加收益）的自然对数值 $k$，并输出该整数。\n换句话说，若小 A 最终通过操作将手中 $e^k$ 元变为 $e^w$ 元，则你应输出该整数 $w$。", "inputFormat": "第一行包含两个正整数 $n$（$1 \\leq n \\leq 10^5$） 和 $m$（$1 \\leq m \\leq 10^5$），分别表示交易日的数量以及鸡债的数量。\n\n第二行包含 $n$ 个正整数 $a_1, a_2, \\dots, a_n$（$1 \\leq a_i \\leq 10^4$），其中第 $i$ 天的股票价格为$e^{a_i}$。\n\n第三行包含一个正整数 $k$（$1 \\leq k \\leq 10^9$），表示每份鸡债提供的借款金额为$e^k$。\n\n接下来 $m$ 行，每行包含两个整数 $s_i$ 和 $t_i$（$1 \\leq s_i \\leq t_i \\leq n$），表示第 $i$ 份鸡债的借款开始日和收益结算日。", "outputFormat": "输出共 $m$ 行，每行一个正整数 $w_i$，表示第 $i$ 份鸡债的本金加收益总额为 $e^{w_i}$ 元。", "hint": "在样例中，一共有 $6$ 个交易日，$2$ 份鸡债。\n\n每天的股价为 $e^3, e^2, e^4, e^5, e^3, e^6$ 。\n\n鸡债的本金均为 $e^2$ 。\n\n第 $1$ 份鸡债：第 $2$ 天借出，在第 $4$ 天归还。\n\n第 $2$ 份鸡债：第 $3$ 天借出，在第 $6$ 天归还。\n\n对于第 $1$ 份鸡债：三天的股价为 $[e^2, e^4, e^5]$ ，最优方案为第 $2$ 天买入，第 $4$ 天卖出。最终资产为 $e^2 \\div e^2 \\times e^5 = e^5$ 。\n\n输出答案为 $5$ 。\n\n对于第 $2$ 份鸡债：四天的股价为 $[e^4, e^5, e^3, e^6]$ ，最优方案为第 $3$ 天买入，第 $4$ 天卖出，第 $5$ 天再买入，第 $6$ 天再卖出。最终资产为 $e^2 \\div e^4 \\times e^5 \\div e^3 \\times e ^6 = e^6$ 。\n\n输出答案为 $6$ 。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 炒股高手", "background": "", "description": "小 A 立志成为一名炒股高手。经过长时间的学习，他自信已掌握了丰富的理论知识，并精心挑选出了一支股票，决定在接下来的 $n$ 个交易日内进行实战操作。\n\n股票之神向小 A 投来了注视，他帮你预知了接下来 $n$ 个交易日中这只股票的股价。由于股票之神擅长数学，所有价格均以自然对数的形式给出。也就是说，在第 $i$ 天（$1 \\leq i \\leq n$），会得到一个正整数 $a_i$，表示当天该股票的价格为 $e^{a_i}$ 元。需要注意的是，在本题中，小 A 可以购买非整数份的股票。\n\n由于手头资金有限，小 A 决定公开向他人借款，称为\"鸡债\"。为了方便管理和收益核算，他规定每位出借人均提供固定的 $e^k$ 元借款。\n\n在这 $n$ 天内，共有 $m$ 位出借人愿意向小 A 提供鸡债。\n\n对于第 $i$ 位出借人，他会在第 $s_i$ 天开盘前向小 A 提供 $e^k$ 元，在第 $t_i$ 天收盘后要求结算收益。在这段时间内，小 A 可自由使用这笔资金进行任意次数的买入与卖出操作。\n\n你的任务是：对于每一笔鸡债，计算小 A 在最优操作下所能获得的最终总资产（即本金加收益）的自然对数值 $k$，并输出该整数。\n换句话说，若小 A 最终通过操作将手中 $e^k$ 元变为 $e^w$ 元，则你应输出该整数 $w$。", "inputFormat": "第一行包含两个正整数 $n$（$1 \\leq n \\leq 10^5$） 和 $m$（$1 \\leq m \\leq 10^5$），分别表示交易日的数量以及鸡债的数量。\n\n第二行包含 $n$ 个正整数 $a_1, a_2, \\dots, a_n$（$1 \\leq a_i \\leq 10^4$），其中第 $i$ 天的股票价格为$e^{a_i}$。\n\n第三行包含一个正整数 $k$（$1 \\leq k \\leq 10^9$），表示每份鸡债提供的借款金额为$e^k$。\n\n接下来 $m$ 行，每行包含两个整数 $s_i$ 和 $t_i$（$1 \\leq s_i \\leq t_i \\leq n$），表示第 $i$ 份鸡债的借款开始日和收益结算日。", "outputFormat": "输出共 $m$ 行，每行一个正整数 $w_i$，表示第 $i$ 份鸡债的本金加收益总额为 $e^{w_i}$ 元。", "hint": "在样例中，一共有 $6$ 个交易日，$2$ 份鸡债。\n\n每天的股价为 $e^3, e^2, e^4, e^5, e^3, e^6$ 。\n\n鸡债的本金均为 $e^2$ 。\n\n第 $1$ 份鸡债：第 $2$ 天借出，在第 $4$ 天归还。\n\n第 $2$ 份鸡债：第 $3$ 天借出，在第 $6$ 天归还。\n\n对于第 $1$ 份鸡债：三天的股价为 $[e^2, e^4, e^5]$ ，最优方案为第 $2$ 天买入，第 $4$ 天卖出。最终资产为 $e^2 \\div e^2 \\times e^5 = e^5$ 。\n\n输出答案为 $5$ 。\n\n对于第 $2$ 份鸡债：四天的股价为 $[e^4, e^5, e^3, e^6]$ ，最优方案为第 $3$ 天买入，第 $4$ 天卖出，第 $5$ 天再买入，第 $6$ 天再卖出。最终资产为 $e^2 \\div e^4 \\times e^5 \\div e^3 \\times e ^6 = e^6$ 。\n\n输出答案为 $6$ 。\n", "locale": "zh-CN"}}}
{"pid": "P13096", "type": "P", "difficulty": 4, "samples": [["3\n5 5\n2 3\n10000\n01000\n00110\n11001\n11111\n7 8\n3 3\n10101000\n01010100\n10000100\n01000010\n00100100\n00011010\n00000001\n7 8\n4 4\n10101000\n01010100\n10000100\n01000010\n00100100\n00011010\n00000001", "2\n3\n3\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "福建", "广度优先搜索 BFS", "省赛/邀请赛"], "title": "[FJCPC 2025] 难以控制的滑板火箭", "background": "", "description": "在一个 $n\\times m$ 的 `01` 网格中，其中第 $i$ 行第 $j$ 列的元素为 $a_{i,j}$，若 $a_{i,j}=1$ 则表示这个位置为空地，反之若 $a_{i,j}=0$ 则表示这个位置上有障碍物。\n\n现在小猫从 $(1,1)$ 出发，想要去 $(n,m)$。\n\n若小猫当前在 $(x,y)$ 则**一次移动**后可以到 $(x-1,y)$、$(x+1,y)$、$(x,y-1)$、$(x,y+1)$、$(x-1,y-1)$、$(x+1,y-1)$、$(x-1,y+1)$、$(x+1,y+1)$ 的位置上，注意不能移动到地图外，也不能走到障碍物上。即任意时候 $1\\leq x\\leq n,1\\leq y\\leq m,a_{x,y}=1$。\n\n因为小猫使用了难以控制的滑板火箭，每一分钟都会移动 $[l,r]$ 次。\n\n现在需要你求出小猫最少需要几分钟才能成功抵达终点（**必须要某一分钟的移动全部结束后小猫的位置在 $(n,m)$ 才算成功抵达**），如果无论经过多久都不能成功抵达请输出 `-1`。", "inputFormat": "第一行一个整数 $t$（$1\\leq t\\leq 1000$），表示测试数据组数。\n\n接下来对于每一组测试数据，第一行两个整数 $n,m$（$2\\leq n,m\\leq 1000$），表示 `01` 网格的大小。\n\n接下来一行包含两个整数 $l,r$（$1\\leq l\\leq r\\leq 10^9$），表示在一分钟内移动次数的限制范围。\n\n接下来 $n$ 行，每行 $m$ 个字符，表示网格的元素 $a_{i,j}$，字符仅会出现 `0` 或 `1`，且 $a_{1,1}$ 与 $a_{n,m}$ 一定为 $1$。\n\n保证所有测试数据的 $n\\times m$ 的和不超过 $10^6$。", "outputFormat": "对于每一组测试数据输出一行，如果小猫能在有限时间内抵达 $(n,m)$，那么输出最少需要的分钟数，否则输出 `-1`。", "hint": "对于第一组样例：\n\n在第一分钟 $(1,1)\\rightarrow (2,2)\\rightarrow (3,3)\\rightarrow (3,4)$；\n\n在第二分钟 $(3,4)\\rightarrow (4,5)\\rightarrow (5,5)$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 难以控制的滑板火箭", "background": "", "description": "在一个 $n\\times m$ 的 `01` 网格中，其中第 $i$ 行第 $j$ 列的元素为 $a_{i,j}$，若 $a_{i,j}=1$ 则表示这个位置为空地，反之若 $a_{i,j}=0$ 则表示这个位置上有障碍物。\n\n现在小猫从 $(1,1)$ 出发，想要去 $(n,m)$。\n\n若小猫当前在 $(x,y)$ 则**一次移动**后可以到 $(x-1,y)$、$(x+1,y)$、$(x,y-1)$、$(x,y+1)$、$(x-1,y-1)$、$(x+1,y-1)$、$(x-1,y+1)$、$(x+1,y+1)$ 的位置上，注意不能移动到地图外，也不能走到障碍物上。即任意时候 $1\\leq x\\leq n,1\\leq y\\leq m,a_{x,y}=1$。\n\n因为小猫使用了难以控制的滑板火箭，每一分钟都会移动 $[l,r]$ 次。\n\n现在需要你求出小猫最少需要几分钟才能成功抵达终点（**必须要某一分钟的移动全部结束后小猫的位置在 $(n,m)$ 才算成功抵达**），如果无论经过多久都不能成功抵达请输出 `-1`。", "inputFormat": "第一行一个整数 $t$（$1\\leq t\\leq 1000$），表示测试数据组数。\n\n接下来对于每一组测试数据，第一行两个整数 $n,m$（$2\\leq n,m\\leq 1000$），表示 `01` 网格的大小。\n\n接下来一行包含两个整数 $l,r$（$1\\leq l\\leq r\\leq 10^9$），表示在一分钟内移动次数的限制范围。\n\n接下来 $n$ 行，每行 $m$ 个字符，表示网格的元素 $a_{i,j}$，字符仅会出现 `0` 或 `1`，且 $a_{1,1}$ 与 $a_{n,m}$ 一定为 $1$。\n\n保证所有测试数据的 $n\\times m$ 的和不超过 $10^6$。", "outputFormat": "对于每一组测试数据输出一行，如果小猫能在有限时间内抵达 $(n,m)$，那么输出最少需要的分钟数，否则输出 `-1`。", "hint": "对于第一组样例：\n\n在第一分钟 $(1,1)\\rightarrow (2,2)\\rightarrow (3,3)\\rightarrow (3,4)$；\n\n在第二分钟 $(3,4)\\rightarrow (4,5)\\rightarrow (5,5)$。", "locale": "zh-CN"}}}
{"pid": "P13097", "type": "P", "difficulty": 4, "samples": [["2\n4\n11\n7\n11000", "-1\n6\n1 2\n1 3\n1 4\n2 5\n2 6\n3 7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "2025", "福建", "Special Judge", "构造", "省赛/邀请赛"], "title": "[FJCPC 2025] 割点", "background": null, "description": "给定一个正整数 $n$ 和一个长度为 $n-2$ 的 01 序列 $a_{2}, a_{3}, \\dots, a_{n-1}$，要求你构造一个 $n$ 个点的**无向简单连通图** $G$，使得：\n\n- 点 $1$ 是割点，点 $n$ 不是割点。\n\n- 对于每个 $1 < i < n$：\n\n若 $a_{i} = 1$，则点 $i$ 在图 $G$ 中是割点；\n\n若 $a_{i} = 0$，则点 $i$ 在图 $G$ 中不是割点。\n\n- 图 $G$ 中各顶点的度数满足：$\\rm{deg}_1\\geq \\rm{deg}_2\\geq\\dots\\geq \\rm{deg}_n$。\n\n如果存在多种可行的图，输出任意一种；如果不存在满足条件的图，则输出 $-1$。\n\n简单图的定义为：无重边（即任意一对点之间至多只有一条边）且无自环（即不存在一条边两端点相同）的图。\n\n割点的定义为：删掉该点以及它连的边后，使得图连通块个数增加的点。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行一个正整数 $T$（$1\\leq T\\leq 500$），表示测试数据的组数。\n\n对于每组数据：\n\n第一行一个正整数 $n$（$4\\le n \\leq 1000$），表示图中点的个数。\n\n接下来一个长度为 $n - 2$ 的 01 串，表示序列 $a_{2}, a_{3}, \\dots, a_{n-1}$。\n\n保证所有数据的 $\\sum n\\leq 2000$。", "outputFormat": "对于每组数据：\n\n若无解，输出 $-1$；\n\n若有解，第一行输出 $m$ （$0<m\\leq \\frac{n(n-1)}{2}$），表示图的边数。接下来 $m$ 行，每行输出两个正整数，第 $i$ 行的两个正整数表示第 $i$ 条边两个点的编号。若有多种满足题意的图，你可以输出任意一种。", "hint": "对于样例一，可以证明不存在满足题意的图。\n\n对于样例二，图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/49d4fgs7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)\n\n其中点 $1,2,3$ 是割点，$\\rm{deg}_1\\sim\\rm{deg}_7$ 分别为：$3,3,2,1,1,1,1$，符合题意。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 割点", "background": null, "description": "给定一个正整数 $n$ 和一个长度为 $n-2$ 的 01 序列 $a_{2}, a_{3}, \\dots, a_{n-1}$，要求你构造一个 $n$ 个点的**无向简单连通图** $G$，使得：\n\n- 点 $1$ 是割点，点 $n$ 不是割点。\n\n- 对于每个 $1 < i < n$：\n\n若 $a_{i} = 1$，则点 $i$ 在图 $G$ 中是割点；\n\n若 $a_{i} = 0$，则点 $i$ 在图 $G$ 中不是割点。\n\n- 图 $G$ 中各顶点的度数满足：$\\rm{deg}_1\\geq \\rm{deg}_2\\geq\\dots\\geq \\rm{deg}_n$。\n\n如果存在多种可行的图，输出任意一种；如果不存在满足条件的图，则输出 $-1$。\n\n简单图的定义为：无重边（即任意一对点之间至多只有一条边）且无自环（即不存在一条边两端点相同）的图。\n\n割点的定义为：删掉该点以及它连的边后，使得图连通块个数增加的点。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行一个正整数 $T$（$1\\leq T\\leq 500$），表示测试数据的组数。\n\n对于每组数据：\n\n第一行一个正整数 $n$（$4\\le n \\leq 1000$），表示图中点的个数。\n\n接下来一个长度为 $n - 2$ 的 01 串，表示序列 $a_{2}, a_{3}, \\dots, a_{n-1}$。\n\n保证所有数据的 $\\sum n\\leq 2000$。", "outputFormat": "对于每组数据：\n\n若无解，输出 $-1$；\n\n若有解，第一行输出 $m$ （$0<m\\leq \\frac{n(n-1)}{2}$），表示图的边数。接下来 $m$ 行，每行输出两个正整数，第 $i$ 行的两个正整数表示第 $i$ 条边两个点的编号。若有多种满足题意的图，你可以输出任意一种。", "hint": "对于样例一，可以证明不存在满足题意的图。\n\n对于样例二，图如下：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/49d4fgs7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)\n\n其中点 $1,2,3$ 是割点，$\\rm{deg}_1\\sim\\rm{deg}_7$ 分别为：$3,3,2,1,1,1,1$，符合题意。", "locale": "zh-CN"}}}
{"pid": "P13098", "type": "P", "difficulty": 3, "samples": [["2\n2025\n182", "0 \n3\n7 3 4"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "2025", "福建", "Special Judge", "构造", "省赛/邀请赛"], "title": "[FJCPC 2025] 构造大师贝贝", "background": "", "description": "贝贝励志成为 FJ-ACM 中最强的构造选手，于是他每日苦练构造题。\n\n为了检验贝贝的训练成果，宁宁同学提出了一道十分甚至九分困难的构造题来检验他的学习成果：\n\n给定一个正整数 $n$，请在 $100$ 次操作以内，将其变为一个完全平方数。每次操作的内容为如下：\n\n* 选择一个当前数字 $n$ 的约数 $x$，即 $n \\bmod x = 0$；\n\n* 每次选择的 $x$ 需跟之前**任何一次**选择的都不同；\n\n* 随后让 $n$ 加上 $x$。\n\n在整个操作过程中，$n$ 不允许超过 $10^{18}$。\n\n这可难坏了贝贝，于是他找到了无比聪明的你来解决这个问题。\n\n其中，$n \\bmod x$ 表示 $n$ 除以 $x$ 的余数。", "inputFormat": "本题包含多组评测用例。\n\n第一行，包含一个整数 $T( 1\\le T \\le 1000 )$，表示评测用例组数。\n\n接下来的 $T$ 行，一行一个正整数 $n(1\\le n\\le 10^{12})$。\n\n", "outputFormat": "对于每组评测用例：\n\n第一行，输出一个整数 $m(0\\le m\\le 100)$，表示操作次数。\n\n第二行，包含 $m$ 个由空格分隔的不同的数字，表示每次操作所加上的数字 $x$。\n\n在整个操作过程中，你需要保证 $n$ 不超过 $10^{18}$。", "hint": "对于第 $1$ 个评测用例的说明如下：\n\n- 因为 $2025=45\\times 45$ 原本就是平方数，故无需操作。\n\n对于第 $2$ 个评测用例的说明如下：\n\n- 第一次操作：\n\n  - 选择 $x=7$，数字 $7$ 是 $182$ 的因子；\n\n  - 令 $n:=182+7=189$。\n\n- 第二次操作：\n\n  - 选择 $x=3$，数字 $3$ 是 $189$ 的因子且 $3$ 不在之前选择的数字集合 $\\{7\\}$ 中；\n\n  - 令 $n:=189+3=192$；\n\n- 第三次操作：\n\n  - 选择 $x=4$，数字 $4$ 是 $192$ 的因子且 $4$ 不在之前选择的数字集合 $\\{7,3\\}$ 中；  \n\n  - 令 $n:=192+4=196$；\n\n  - $196=14\\times 14$ 是完全平方数，结束。\n\n其中 $:=$ 表示赋值符号。\n\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 构造大师贝贝", "background": "", "description": "贝贝励志成为 FJ-ACM 中最强的构造选手，于是他每日苦练构造题。\n\n为了检验贝贝的训练成果，宁宁同学提出了一道十分甚至九分困难的构造题来检验他的学习成果：\n\n给定一个正整数 $n$，请在 $100$ 次操作以内，将其变为一个完全平方数。每次操作的内容为如下：\n\n* 选择一个当前数字 $n$ 的约数 $x$，即 $n \\bmod x = 0$；\n\n* 每次选择的 $x$ 需跟之前**任何一次**选择的都不同；\n\n* 随后让 $n$ 加上 $x$。\n\n在整个操作过程中，$n$ 不允许超过 $10^{18}$。\n\n这可难坏了贝贝，于是他找到了无比聪明的你来解决这个问题。\n\n其中，$n \\bmod x$ 表示 $n$ 除以 $x$ 的余数。", "inputFormat": "本题包含多组评测用例。\n\n第一行，包含一个整数 $T( 1\\le T \\le 1000 )$，表示评测用例组数。\n\n接下来的 $T$ 行，一行一个正整数 $n(1\\le n\\le 10^{12})$。\n\n", "outputFormat": "对于每组评测用例：\n\n第一行，输出一个整数 $m(0\\le m\\le 100)$，表示操作次数。\n\n第二行，包含 $m$ 个由空格分隔的不同的数字，表示每次操作所加上的数字 $x$。\n\n在整个操作过程中，你需要保证 $n$ 不超过 $10^{18}$。", "hint": "对于第 $1$ 个评测用例的说明如下：\n\n- 因为 $2025=45\\times 45$ 原本就是平方数，故无需操作。\n\n对于第 $2$ 个评测用例的说明如下：\n\n- 第一次操作：\n\n  - 选择 $x=7$，数字 $7$ 是 $182$ 的因子；\n\n  - 令 $n:=182+7=189$。\n\n- 第二次操作：\n\n  - 选择 $x=3$，数字 $3$ 是 $189$ 的因子且 $3$ 不在之前选择的数字集合 $\\{7\\}$ 中；\n\n  - 令 $n:=189+3=192$；\n\n- 第三次操作：\n\n  - 选择 $x=4$，数字 $4$ 是 $192$ 的因子且 $4$ 不在之前选择的数字集合 $\\{7,3\\}$ 中；  \n\n  - 令 $n:=192+4=196$；\n\n  - $196=14\\times 14$ 是完全平方数，结束。\n\n其中 $:=$ 表示赋值符号。\n\n", "locale": "zh-CN"}}}
{"pid": "P13099", "type": "P", "difficulty": 3, "samples": [["5\n1 2 5\n1 3 4\n2 5 7\n3 4 2", "YES\n3 2 1 1 5"], ["4\n1 2 5\n2 3 9\n3 4 4", "NO"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "福建", "Special Judge", "树论", "省赛/邀请赛"], "title": "[FJCPC 2025] VERTeX", "background": "", "description": "给定一棵有 $n$ 个结点的树，结点依次以 $1, 2, \\dots, n$ 标号。第 $i$（$1\\leq i\\leq n$）个结点有**正整数**权值 $b_i > 0$。对于连接结点 $u$ 与 $v$ 的树边，其边权为 $w_{uv} = b_u + b_v$。\n\n现在给定树的形态与每条树边的边权，你需要判断是否存在满足条件的一组结点权值。若存在，则求出任意一组结点权值。", "inputFormat": "第一行，一个正整数 $n$（$1\\leq n\\leq 2\\times 10^5$），表示结点数量。\n\n接下来 $n - 1$ 行，每行三个整数 $u, v, w_{uv}$（$1\\leq u,v\\leq n$，$1\\leq w_{uv}\\leq 10^9$），表示一条连接结点 $u$ 与 $v$ 的边权为 $w_{uv}$ 的树边。", "outputFormat": "若满足条件的一组结点权值不存在，则输出一行一个字符串 `NO`。\n\n否则，第一行输出一个字符串 `YES`，第二行输出 $n$ 个正整数 $b_1, \\dots, b_n$，表示你求出的一组结点权值。你需要保证对于任意 $1\\leq i\\leq n$ 有 $b_i \\leq 10^9$。\n\n若存在多组满足条件的答案，输出任意一组均可。", "hint": "对于第一组样例，可以验证给出的权值满足条件。注意到 $w_{34} = b_3 + b_4 = 2$，因此 $b_3$ 与 $b_4$ 只能取 $1$，继而可以确定其他结点的权值。\n\n对于第二组样例，注意到 $b_2 + b_3 = w_{23} = 9 = w_{12} + w_{34} = b_1 + b_2 + b_3 + b_4$，从而 $b_1 + b_4 = 0$，而这与 $b_1 > 0$ 且 $b_4 > 0$ 矛盾，因此不存在满足条件的结点权值。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] VERTeX", "background": "", "description": "给定一棵有 $n$ 个结点的树，结点依次以 $1, 2, \\dots, n$ 标号。第 $i$（$1\\leq i\\leq n$）个结点有**正整数**权值 $b_i > 0$。对于连接结点 $u$ 与 $v$ 的树边，其边权为 $w_{uv} = b_u + b_v$。\n\n现在给定树的形态与每条树边的边权，你需要判断是否存在满足条件的一组结点权值。若存在，则求出任意一组结点权值。", "inputFormat": "第一行，一个正整数 $n$（$1\\leq n\\leq 2\\times 10^5$），表示结点数量。\n\n接下来 $n - 1$ 行，每行三个整数 $u, v, w_{uv}$（$1\\leq u,v\\leq n$，$1\\leq w_{uv}\\leq 10^9$），表示一条连接结点 $u$ 与 $v$ 的边权为 $w_{uv}$ 的树边。", "outputFormat": "若满足条件的一组结点权值不存在，则输出一行一个字符串 `NO`。\n\n否则，第一行输出一个字符串 `YES`，第二行输出 $n$ 个正整数 $b_1, \\dots, b_n$，表示你求出的一组结点权值。你需要保证对于任意 $1\\leq i\\leq n$ 有 $b_i \\leq 10^9$。\n\n若存在多组满足条件的答案，输出任意一组均可。", "hint": "对于第一组样例，可以验证给出的权值满足条件。注意到 $w_{34} = b_3 + b_4 = 2$，因此 $b_3$ 与 $b_4$ 只能取 $1$，继而可以确定其他结点的权值。\n\n对于第二组样例，注意到 $b_2 + b_3 = w_{23} = 9 = w_{12} + w_{34} = b_1 + b_2 + b_3 + b_4$，从而 $b_1 + b_4 = 0$，而这与 $b_1 > 0$ 且 $b_4 > 0$ 矛盾，因此不存在满足条件的结点权值。", "locale": "zh-CN"}}}
{"pid": "P13100", "type": "P", "difficulty": 3, "samples": [["3\n6\n1 1 4 5 1 4\n5\n1 2 3 4 5\n5\n1 2 2 1 2", "2 2 5 6 6 6\n2 4 4 5 6\n2 4 4 3 3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "福建", "省赛/邀请赛"], "title": "[FJCPC 2025] 众数", "background": "", "description": "有 $n$ 个整数构成的序列 $a_i$（下标 $1\\sim n$），对于序列的每个前缀 $a_1,a_2,\\cdots,a_k$（$1\\leq k\\leq n$），考虑选择其中一个非空下标集合 $S$，定义 $f(S)=\\min\\{a_i\\mid i\\in S\\}+\\max\\{a_i\\mid i\\in S\\}$。\n\n求对于序列 $a$ 的每个前缀，在其对应的 $2^k-1$ 种情况下，$f(S)$ 的值的众数（出现最多的数），如果有多种数出现次数一样均为最多，则输出其中最大的数。", "inputFormat": "第一行一个整数 $t$（$1\\leq t\\leq 1000$），表示接下来有 $t$ 组测试数据。\n\n接下来对于每一组测试数据，第一行包含一个整数 $n$（$1\\leq n\\leq 10^6$），表示整数的个数。\n\n接下来一行包含 $n$ 个整数表示 $a_i$（$1\\leq a_i\\leq 10^9$）。\n\n保证所有测试数据的 $n$ 的总和不超过 $10^6$。", "outputFormat": "对于每一组数据输出一行，包含 $n$ 个由空格隔开的整数，依次表示每一个前缀的 $f(S)$ 的值的最大众数。", "hint": "前 $1$ 个数中，$2$ 出现了 $1$ 次，最大众数为 $2$；\n\n前 $2$ 个数中，$2$ 出现了 $3$ 次，最大众数为 $2$；\n\n前 $3$ 个数中，$2$ 出现了 $3$ 次，$5$ 出现了 $3$ 次，$8$ 出现了 $1$ 次，最大众数为 $5$；\n\n前 $4$ 个数中，$2$ 出现了 $3$ 次，$5$ 出现了 $3$ 次，$6$ 出现了 $6$ 次，$8$ 出现了 $1$ 次，$9$ 出现了 $1$ 次，$10$ 出现了 $1$ 次，最大众数为 $6$；\n\n前 $5$ 个数中，$2$ 出现了 $7$ 次，$5$ 出现了 $7$ 次，$6$ 出现了 $14$ 次，$8$ 出现了 $1$ 次，$9$ 出现了 $1$ 次，$10$ 出现了 $1$ 次，最大众数为 $6$；\n\n前 $6$ 个数中，$2$ 出现了 $7$ 次，$5$ 出现了 $21$ 次，$6$ 出现了 $28$ 次，$8$ 出现了 $3$ 次，$9$ 出现了 $3$ 次，$10$ 出现了 $1$ 次，最大众数为 $6$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 众数", "background": "", "description": "有 $n$ 个整数构成的序列 $a_i$（下标 $1\\sim n$），对于序列的每个前缀 $a_1,a_2,\\cdots,a_k$（$1\\leq k\\leq n$），考虑选择其中一个非空下标集合 $S$，定义 $f(S)=\\min\\{a_i\\mid i\\in S\\}+\\max\\{a_i\\mid i\\in S\\}$。\n\n求对于序列 $a$ 的每个前缀，在其对应的 $2^k-1$ 种情况下，$f(S)$ 的值的众数（出现最多的数），如果有多种数出现次数一样均为最多，则输出其中最大的数。", "inputFormat": "第一行一个整数 $t$（$1\\leq t\\leq 1000$），表示接下来有 $t$ 组测试数据。\n\n接下来对于每一组测试数据，第一行包含一个整数 $n$（$1\\leq n\\leq 10^6$），表示整数的个数。\n\n接下来一行包含 $n$ 个整数表示 $a_i$（$1\\leq a_i\\leq 10^9$）。\n\n保证所有测试数据的 $n$ 的总和不超过 $10^6$。", "outputFormat": "对于每一组数据输出一行，包含 $n$ 个由空格隔开的整数，依次表示每一个前缀的 $f(S)$ 的值的最大众数。", "hint": "前 $1$ 个数中，$2$ 出现了 $1$ 次，最大众数为 $2$；\n\n前 $2$ 个数中，$2$ 出现了 $3$ 次，最大众数为 $2$；\n\n前 $3$ 个数中，$2$ 出现了 $3$ 次，$5$ 出现了 $3$ 次，$8$ 出现了 $1$ 次，最大众数为 $5$；\n\n前 $4$ 个数中，$2$ 出现了 $3$ 次，$5$ 出现了 $3$ 次，$6$ 出现了 $6$ 次，$8$ 出现了 $1$ 次，$9$ 出现了 $1$ 次，$10$ 出现了 $1$ 次，最大众数为 $6$；\n\n前 $5$ 个数中，$2$ 出现了 $7$ 次，$5$ 出现了 $7$ 次，$6$ 出现了 $14$ 次，$8$ 出现了 $1$ 次，$9$ 出现了 $1$ 次，$10$ 出现了 $1$ 次，最大众数为 $6$；\n\n前 $6$ 个数中，$2$ 出现了 $7$ 次，$5$ 出现了 $21$ 次，$6$ 出现了 $28$ 次，$8$ 出现了 $3$ 次，$9$ 出现了 $3$ 次，$10$ 出现了 $1$ 次，最大众数为 $6$。", "locale": "zh-CN"}}}
{"pid": "P13101", "type": "P", "difficulty": 1, "samples": [["1", "FZU"], ["2", "FNU"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2025", "福建", "省赛/邀请赛"], "title": "[FJCPC 2025] 致谢 | FJCPC2025全体参赛选手&赛事staff", "background": "", "description": "亲爱的参赛者：\n\n衷心感谢你参与第十二届福建省大学生程序设计竞赛暨福建邀请赛。\n\n同时，向在比赛幕后默默付出的教练老师和赛事组织人员致以诚挚的谢意，正是因为你们的辛勤付出，比赛才能顺利进行。\n\n此外，也要感谢历届福建省赛(FJCPC)的承办院校为该系列赛事所做出的巨大贡献。\n\n接下来是历届福建省赛(FJCPC)的承办院校及其比赛时间的具体信息：\n\n| 届数 | 比赛时间     | 承办院校               | 英文名                          | 缩写 |\n|------|----------------|--------------|-----------------|----------|\n| 1    | 2010-5-23    | 福州大学               | Fuzhou University               | FZU      |\n| 2    | 2011-5-15    | 福建师范大学           | Fujian Normal University        | FNU      |\n| 3    | 2012-12-02   | 福州大学               | Fuzhou University               | FZU      |\n| 4    | 2013-12-15   | 福州大学               | Fuzhou University               | FZU      |\n| 5    | 2014-11-30   | 福建农林大学           | Fujian Agriculture and Forestry University | FAFU     |\n| 6    | 2015-12-20   | 华侨大学               | Huaqiao University              | HQU      |\n| 7    | 2016-5-22    | 闽江学院               | Minjiang University             | MJU      |\n| 8    | 2017-5-17    | 厦门理工学院           | Xiamen University of Technology | XMUT     |\n| 9    | 2018-6-10    | 泉州师范学院           | Quanzhou Normal University      | QNU      |\n| 10   | 2019-5-19    | 集美大学               | Jimei University                | JMU      |\n| 11   | 2024-5-26    | 福州大学               | Fuzhou University               | FZU      |\n\n CFJ 希望你能输出第 $n$ 届FJCPC的承办院校英文缩写。\n\n再次向所有为第十二届福建省大学生程序设计竞赛暨福建邀请赛奉献力量的每一个人表示最衷心的感谢！\n\n也祝愿你能比赛中取得理想的成绩！", "inputFormat": "输入一个正整数 $n(1\\leq n \\leq 11)$。\n\n", "outputFormat": "输出第 $n$ 届 FJCPC 的承办院校英文缩写。", "hint": "由表可知，第一届 FJCPC 承办校是福州大学，第二届 FJCPC 承办校是福建师范大学。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[FJCPC 2025] 致谢 | FJCPC2025全体参赛选手&赛事staff", "background": "", "description": "亲爱的参赛者：\n\n衷心感谢你参与第十二届福建省大学生程序设计竞赛暨福建邀请赛。\n\n同时，向在比赛幕后默默付出的教练老师和赛事组织人员致以诚挚的谢意，正是因为你们的辛勤付出，比赛才能顺利进行。\n\n此外，也要感谢历届福建省赛(FJCPC)的承办院校为该系列赛事所做出的巨大贡献。\n\n接下来是历届福建省赛(FJCPC)的承办院校及其比赛时间的具体信息：\n\n| 届数 | 比赛时间     | 承办院校               | 英文名                          | 缩写 |\n|------|----------------|--------------|-----------------|----------|\n| 1    | 2010-5-23    | 福州大学               | Fuzhou University               | FZU      |\n| 2    | 2011-5-15    | 福建师范大学           | Fujian Normal University        | FNU      |\n| 3    | 2012-12-02   | 福州大学               | Fuzhou University               | FZU      |\n| 4    | 2013-12-15   | 福州大学               | Fuzhou University               | FZU      |\n| 5    | 2014-11-30   | 福建农林大学           | Fujian Agriculture and Forestry University | FAFU     |\n| 6    | 2015-12-20   | 华侨大学               | Huaqiao University              | HQU      |\n| 7    | 2016-5-22    | 闽江学院               | Minjiang University             | MJU      |\n| 8    | 2017-5-17    | 厦门理工学院           | Xiamen University of Technology | XMUT     |\n| 9    | 2018-6-10    | 泉州师范学院           | Quanzhou Normal University      | QNU      |\n| 10   | 2019-5-19    | 集美大学               | Jimei University                | JMU      |\n| 11   | 2024-5-26    | 福州大学               | Fuzhou University               | FZU      |\n\n CFJ 希望你能输出第 $n$ 届FJCPC的承办院校英文缩写。\n\n再次向所有为第十二届福建省大学生程序设计竞赛暨福建邀请赛奉献力量的每一个人表示最衷心的感谢！\n\n也祝愿你能比赛中取得理想的成绩！", "inputFormat": "输入一个正整数 $n(1\\leq n \\leq 11)$。\n\n", "outputFormat": "输出第 $n$ 届 FJCPC 的承办院校英文缩写。", "hint": "由表可知，第一届 FJCPC 承办校是福州大学，第二届 FJCPC 承办校是福建师范大学。", "locale": "zh-CN"}}}
{"pid": "P13102", "type": "P", "difficulty": 3, "samples": [["3\n4\n940\n4444", "Case #1: 2 2\nCase #2: 852 88\nCase #3: 667 3777"]], "limits": {"time": [10000, 10000, 10000, 10000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["数学", "2019", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 Qualification] Foregone Solution", "background": "", "description": "Someone just won the Code Jam lottery, and we owe them $N$ jamcoins! However, when we tried to print out an oversized check, we encountered a problem. The value of $N$, which is an integer, includes at least one digit that is a `4...` and the 4 key on the keyboard of our oversized check printer is broken.\n\nFortunately, we have a workaround: we will send our winner two checks for positive integer amounts $A$ and $B$, such that neither $A$ nor $B$ contains any digit that is a 4, and $A + B = N$. Please help us find any pair of values $A$ and $B$ that satisfy these conditions.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of one line with an integer $N$.\n", "outputFormat": "For each test case, output one line containing `Case #x: A B`, where $x$ is the test case number (starting from 1), and $A$ and $B$ are positive integers as described above.\n\nIt is guaranteed that at least one solution exists. If there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, notice that A and B can be the same. The only other possible answers are 1 3 and 3 1.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- At least one of the digits of $N$ is a 4.\n\n**Test set 1 (6 Pts, Visible)**\n\n- $1 < N < 10^5$.\n\n**Test set 2 (10 Pts, Visible)**\n\n- $1 < N < 10^9$.\n\nSolving the first two test sets for this problem should get you a long way toward advancing. The third test set is worth only 1 extra point, for extra fun and bragging rights!\n\n**Test set 3 (1 Pts, Hidden)**\n\n- $1 < N < 10^{100}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Qualification] Foregone Solution", "background": "", "description": "Someone just won the Code Jam lottery, and we owe them $N$ jamcoins! However, when we tried to print out an oversized check, we encountered a problem. The value of $N$, which is an integer, includes at least one digit that is a `4...` and the 4 key on the keyboard of our oversized check printer is broken.\n\nFortunately, we have a workaround: we will send our winner two checks for positive integer amounts $A$ and $B$, such that neither $A$ nor $B$ contains any digit that is a 4, and $A + B = N$. Please help us find any pair of values $A$ and $B$ that satisfy these conditions.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of one line with an integer $N$.\n", "outputFormat": "For each test case, output one line containing `Case #x: A B`, where $x$ is the test case number (starting from 1), and $A$ and $B$ are positive integers as described above.\n\nIt is guaranteed that at least one solution exists. If there are multiple solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, notice that A and B can be the same. The only other possible answers are 1 3 and 3 1.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- At least one of the digits of $N$ is a 4.\n\n**Test set 1 (6 Pts, Visible)**\n\n- $1 < N < 10^5$.\n\n**Test set 2 (10 Pts, Visible)**\n\n- $1 < N < 10^9$.\n\nSolving the first two test sets for this problem should get you a long way toward advancing. The third test set is worth only 1 extra point, for extra fun and bragging rights!\n\n**Test set 3 (1 Pts, Hidden)**\n\n- $1 < N < 10^{100}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Qualification] Foregone Solution", "background": null, "description": "有人刚刚赢得了 Code Jam 彩票，我们需要支付给他们 $N$ 个 jamcoin！然而，当我们尝试打印一张超大支票时遇到了问题。$N$ 是一个整数，其中至少包含一个数字 $4$，而我们的超大支票打印机上的 $4$ 键坏了。\n\n幸运的是，我们有一个解决办法：我们将给获奖者发送两张金额为正整数 $A$ 和 $B$ 的支票，使得 $A$ 和 $B$ 都不包含数字 $4$，并且 $A + B = N$。请帮助我们找到任意一组满足条件的 $A$ 和 $B$。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来的 $T$ 行，每行包含一个整数 $N$。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: A B`，其中 $x$ 是测试用例编号（从 1 开始），$A$ 和 $B$ 是满足上述条件的正整数。\n\n保证至少存在一个解。如果有多个解，你可以输出其中任意一个。", "hint": "**样例解释**\n\n在样例第 1 个测试用例中，注意 $A$ 和 $B$ 可以相同。唯一其他可能的答案是 1 3 和 3 1。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $N$ 的数字中至少有一个是 $4$。\n\n**测试点 1（6 分，可见）**\n\n- $1 < N < 10^5$。\n\n**测试点 2（10 分，可见）**\n\n- $1 < N < 10^9$。\n\n解决前两个测试点即可获得大部分分数。第三个测试点仅额外给 1 分，适合挑战和炫耀！\n\n**测试点 3（1 分，隐藏）**\n\n- $1 < N < 10^{100}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13103", "type": "P", "difficulty": 2, "samples": [["2\n2\nSE\n5\nEESSSESE", "Case #1: ES\nCase #2: SEEESSES"]], "limits": {"time": [15000, 15000, 15000, 15000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["字符串", "2019", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 Qualification] You Can Go Your Own Way", "background": "", "description": "You have just entered the world's easiest maze. You start in the northwest cell of an $N$ by $N$ grid of unit cells, and you must reach the southeast cell. You have only two types of moves available: a unit move to the east, and a unit move to the south. You can move into any cell, but you may not make a move that would cause you to leave the grid.\n\nYou are excited to be the first in the world to solve the maze, but then you see footprints. Your rival, Labyrinth Lydia, has already solved the maze before you, using the same rules described above!\n\nAs an original thinker, you do not want to reuse any of Lydia's moves. Specifically, if her path includes a unit move from some cell A to some adjacent cell B, your path cannot also include a move from A to B. (However, in that case, it is OK for your path to visit A or visit B, as long as you do not go from A to B.) Please find such a path.\n\nIn the following picture, Lydia's path is indicated in blue, and one possible valid path for you is indicated in orange:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n9xdyxsk.png)", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each case consists of two lines. The first line contains one integer $N$, giving the dimensions of the maze, as described above. The second line contains a string $P$ of $2N - 2$ characters, each of which is either uppercase E (for east) or uppercase S (for south), representing Lydia's valid path through the maze.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a string of $2N - 2$ characters each of which is either uppercase E (for east) or uppercase S (for south), representing your valid path through the maze that does not conflict with Lydia's path, as described above. It is guaranteed that at least one answer exists.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the maze is so small that there is only one valid solution left for us.\n\nSample Case #2 corresponds to the picture above. Notice that it is acceptable for the paths to cross.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $P$ contains exactly $N - 1$ E characters and exactly $N - 1$ S characters.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $2 \\leq N \\leq 10$.\n\n**Test set 2 (9 Pts, Visible)**\n\n- $2 \\leq N \\leq 1000$.\n\n**Test set 3 (10 Pts, Hidden)**\n\n- For at most 10 cases, $2 \\leq N \\leq 50000$.\n- For all other cases, $2 \\leq N \\leq 10000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Qualification] You Can Go Your Own Way", "background": "", "description": "You have just entered the world's easiest maze. You start in the northwest cell of an $N$ by $N$ grid of unit cells, and you must reach the southeast cell. You have only two types of moves available: a unit move to the east, and a unit move to the south. You can move into any cell, but you may not make a move that would cause you to leave the grid.\n\nYou are excited to be the first in the world to solve the maze, but then you see footprints. Your rival, Labyrinth Lydia, has already solved the maze before you, using the same rules described above!\n\nAs an original thinker, you do not want to reuse any of Lydia's moves. Specifically, if her path includes a unit move from some cell A to some adjacent cell B, your path cannot also include a move from A to B. (However, in that case, it is OK for your path to visit A or visit B, as long as you do not go from A to B.) Please find such a path.\n\nIn the following picture, Lydia's path is indicated in blue, and one possible valid path for you is indicated in orange:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n9xdyxsk.png)", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each case consists of two lines. The first line contains one integer $N$, giving the dimensions of the maze, as described above. The second line contains a string $P$ of $2N - 2$ characters, each of which is either uppercase E (for east) or uppercase S (for south), representing Lydia's valid path through the maze.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a string of $2N - 2$ characters each of which is either uppercase E (for east) or uppercase S (for south), representing your valid path through the maze that does not conflict with Lydia's path, as described above. It is guaranteed that at least one answer exists.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the maze is so small that there is only one valid solution left for us.\n\nSample Case #2 corresponds to the picture above. Notice that it is acceptable for the paths to cross.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $P$ contains exactly $N - 1$ E characters and exactly $N - 1$ S characters.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $2 \\leq N \\leq 10$.\n\n**Test set 2 (9 Pts, Visible)**\n\n- $2 \\leq N \\leq 1000$.\n\n**Test set 3 (10 Pts, Hidden)**\n\n- For at most 10 cases, $2 \\leq N \\leq 50000$.\n- For all other cases, $2 \\leq N \\leq 10000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Qualification] You Can Go Your Own Way", "background": null, "description": "你刚刚进入了世界上最简单的迷宫。你从一个 $N \\times N$ 的单位方格的西北角单元格出发，目标是到达东南角单元格。你只能进行两种类型的移动：向东移动一格，或向南移动一格。你可以进入任意单元格，但不能移动出格子外。\n\n你本以为自己是第一个解开这个迷宫的人，但你发现了脚印。你的对手 Labyrinth Lydia 已经按照上述规则走完了迷宫！\n\n作为一个有创意的人，你不想重复 Lydia 的任何一步。具体来说，如果她的路径包含了从某个单元格 A 移动到相邻单元格 B 的一步，你的路径中不能包含从 A 到 B 的移动（但你可以访问 A 或 B，只要不是从 A 到 B）。请你找出一条满足条件的路径。\n\n下图中，Lydia 的路径用蓝色表示，你的一种可行路径用橙色表示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/n9xdyxsk.png)", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据，每组包含两行。第一行包含一个整数 $N$，表示迷宫的尺寸。第二行包含一个长度为 $2N-2$ 的字符串 $P$，每个字符为大写字母 E（表示向东）或 S（表示向南），表示 Lydia 的一条合法路径。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是一个长度为 $2N-2$ 的字符串，每个字符为大写字母 E 或 S，表示你的一条合法路径，且不与 Lydia 的路径冲突。保证至少存在一个解。", "hint": "**样例解释**\n\n样例 1 中，迷宫太小，你只剩下唯一一种合法解法。\n\n样例 2 对应上图。注意，路径可以交叉。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $P$ 恰好包含 $N-1$ 个 E 和 $N-1$ 个 S。\n\n**测试点 1（5 分，可见）**\n\n- $2 \\leq N \\leq 10$。\n\n**测试点 2（9 分，可见）**\n\n- $2 \\leq N \\leq 1000$。\n\n**测试点 3（10 分，隐藏）**\n\n- 最多 10 个用例满足 $2 \\leq N \\leq 50000$。\n- 其余用例满足 $2 \\leq N \\leq 10000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13104", "type": "P", "difficulty": 4, "samples": [["2\n103 31\n217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053\n10000 25\n3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543", "Case #1: CJQUIZKNOWBEVYOFDPFLUXALGORITHMS\nCase #2: SUBDERMATOGLYPHICFJKNQVWXZ"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "2019", "数论", "Google Code Jam"], "title": "[GCJ 2019 Qualification] Cryptopangrams", "background": "", "description": "On the Code Jam team, we enjoy sending each other pangrams, which are phrases that use each letter of the English alphabet at least once. One common example of a pangram is \"the quick brown fox jumps over the lazy dog\". Sometimes our pangrams contain confidential information — for example, `CJ QUIZ: KNOW BEVY OF DP FLUX ALGORITHMS` — so we need to keep them secure.\n\nWe looked through a cryptography textbook for a few minutes, and we learned that it is very hard to factor products of two large prime numbers, so we devised an encryption scheme based on that fact. First, we made some preparations:\n\n* We chose 26 different prime numbers, none of which is larger than some integer $N$.\n* We sorted those primes in increasing order. Then, we assigned the smallest prime to the letter A, the second smallest prime to the letter B, and so on.\n* Everyone on the team memorized this list.\n\nNow, whenever we want to send a pangram as a message, we first remove all spacing to form a plaintext message. Then we write down the product of the prime for the first letter of the plaintext and the prime for the second letter of the plaintext. Then we write down the product of the primes for the second and third plaintext letters, and so on, ending with the product of the primes for the next-to-last and last plaintext letters. This new list of values is our ciphertext. The number of values is one smaller than the number of characters in the plaintext message.\n\nFor example, suppose that $N = 103$ and we chose to use the first 26 odd prime numbers, because we worry that it is too easy to factor even numbers. Then $A = 3$, $B = 5$, $C = 7$, $D = 11$, and so on, up to $Z = 103$. Also suppose that we want to encrypt the `CJ QUIZ KNOW BEVY OF DP FLUX ALGORITHMS` pangram above, so our plaintext is `CJQUIZKNOWBEVYOFDPFLUXALGORITHMS`. Then the first value in our ciphertext is $7$ (the prime for `C`) times $31$ (the prime for `J`) $= 217$; the next value is $1891$, and so on, ending with $3053$.\n\nWe will give you a ciphertext message and the value of $N$ that we used. We will not tell you which primes we used, or how to decrypt the ciphertext. Do you think you can recover the plaintext anyway?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each test case consists of two lines. The first line contains two integers: $N$, as described above, and $L$, the length of the list of values in the ciphertext. The second line contains $L$ integers: the list of values in the ciphertext.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a string of $L + 1$ uppercase English alphabet letters: the plaintext.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $25 \\leq L \\leq 100$.\n- The plaintext contains each English alphabet letter at least once.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $101 \\leq N \\leq 10000$.\n\n**Test set 2 (15 Pts, Hidden)**\n\n- $101 \\leq N \\leq 10^{100}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Qualification] Cryptopangrams", "background": "", "description": "On the Code Jam team, we enjoy sending each other pangrams, which are phrases that use each letter of the English alphabet at least once. One common example of a pangram is \"the quick brown fox jumps over the lazy dog\". Sometimes our pangrams contain confidential information — for example, `CJ QUIZ: KNOW BEVY OF DP FLUX ALGORITHMS` — so we need to keep them secure.\n\nWe looked through a cryptography textbook for a few minutes, and we learned that it is very hard to factor products of two large prime numbers, so we devised an encryption scheme based on that fact. First, we made some preparations:\n\n* We chose 26 different prime numbers, none of which is larger than some integer $N$.\n* We sorted those primes in increasing order. Then, we assigned the smallest prime to the letter A, the second smallest prime to the letter B, and so on.\n* Everyone on the team memorized this list.\n\nNow, whenever we want to send a pangram as a message, we first remove all spacing to form a plaintext message. Then we write down the product of the prime for the first letter of the plaintext and the prime for the second letter of the plaintext. Then we write down the product of the primes for the second and third plaintext letters, and so on, ending with the product of the primes for the next-to-last and last plaintext letters. This new list of values is our ciphertext. The number of values is one smaller than the number of characters in the plaintext message.\n\nFor example, suppose that $N = 103$ and we chose to use the first 26 odd prime numbers, because we worry that it is too easy to factor even numbers. Then $A = 3$, $B = 5$, $C = 7$, $D = 11$, and so on, up to $Z = 103$. Also suppose that we want to encrypt the `CJ QUIZ KNOW BEVY OF DP FLUX ALGORITHMS` pangram above, so our plaintext is `CJQUIZKNOWBEVYOFDPFLUXALGORITHMS`. Then the first value in our ciphertext is $7$ (the prime for `C`) times $31$ (the prime for `J`) $= 217$; the next value is $1891$, and so on, ending with $3053$.\n\nWe will give you a ciphertext message and the value of $N$ that we used. We will not tell you which primes we used, or how to decrypt the ciphertext. Do you think you can recover the plaintext anyway?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each test case consists of two lines. The first line contains two integers: $N$, as described above, and $L$, the length of the list of values in the ciphertext. The second line contains $L$ integers: the list of values in the ciphertext.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a string of $L + 1$ uppercase English alphabet letters: the plaintext.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $25 \\leq L \\leq 100$.\n- The plaintext contains each English alphabet letter at least once.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $101 \\leq N \\leq 10000$.\n\n**Test set 2 (15 Pts, Hidden)**\n\n- $101 \\leq N \\leq 10^{100}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Qualification] Cryptopangrams", "background": null, "description": "在 Code Jam 团队中，我们喜欢互相发送全字母短语（pangram），即包含英语字母表中每个字母至少一次的短语。一个常见的例子是 “the quick brown fox jumps over the lazy dog”。有时我们的全字母短语中包含机密信息，例如 `CJ QUIZ: KNOW BEVY OF DP FLUX ALGORITHMS`，因此我们需要保证它们的安全。\n\n我们翻看了一本密码学教材几分钟，了解到分解两个大质数的乘积非常困难，于是我们基于这个事实设计了一种加密方案。首先，我们做了一些准备：\n\n- 我们选择了 $26$ 个不同的质数，且每个质数都不大于某个整数 $N$。\n- 我们将这些质数按升序排列。然后，将最小的质数分配给字母 $A$，第二小的分配给 $B$，以此类推。\n- 团队中的每个人都记住了这份列表。\n\n现在，每当我们想要发送一个全字母短语作为消息时，我们首先去除所有空格，形成明文消息。然后，我们记录下明文第一个字母对应的质数与第二个字母对应的质数的乘积。接着，记录第二个和第三个字母对应质数的乘积，依此类推，直到倒数第二个和最后一个字母对应质数的乘积。这个新的数值列表就是我们的密文。密文中的数值个数比明文字符数少 $1$。\n\n例如，假设 $N = 103$，我们选择了前 $26$ 个奇质数，因为我们担心偶数太容易分解。那么 $A = 3$，$B = 5$，$C = 7$，$D = 11$，以此类推，直到 $Z = 103$。又假设我们想加密上面的全字母短语 `CJ QUIZ KNOW BEVY OF DP FLUX ALGORITHMS`，那么明文为 `CJQUIZKNOWBEVYOFDPFLUXALGORITHMS`。此时密文的第一个数值是 $7$（`C` 对应的质数）乘以 $31$（`J` 对应的质数）$= 217$；下一个数值是 $1891$，以此类推，最后一个数值是 $3053$。\n\n我们会给你一个密文消息和我们使用的 $N$ 的值。我们不会告诉你用的是哪些质数，也不会告诉你如何解密密文。你能否恢复出明文呢？", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来有 $T$ 组测试用例，每组测试用例包含两行。第一行包含两个整数：$N$（如上所述）和 $L$，即密文数值列表的长度。第二行包含 $L$ 个整数，表示密文数值列表。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是由 $L+1$ 个大写英文字母组成的明文字符串。", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 100$。\n- $25 \\leq L \\leq 100$。\n- 明文包含每个英文字母至少一次。\n\n**测试点 1（10 分，可见）**\n\n- $101 \\leq N \\leq 10000$。\n\n**测试点 2（15 分，隐藏）**\n\n- $101 \\leq N \\leq 10^{100}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13105", "type": "P", "difficulty": 5, "samples": [["", ""]], "limits": {"time": [20000, 20000], "memory": [1048576, 1048576]}, "tags": ["2019", "交互题", "Special Judge", "位运算", "Google Code Jam"], "title": "[GCJ 2019 Qualification] Dat Bae", "background": "", "description": "A research consortium has built a new database system for their new data center. The database is made up of one master computer and $N$ worker computers, which are given IDs from 0 to $N-1$. Each worker stores exactly one bit of information... which seems rather wasteful, but this is very important data!\n\nYou have been hired to evaluate the following instruction for the database:\n\n* TEST\\_STORE <bits>: The master reads in <bits>, which is a string of $N$ bits, and sends the $i$-th bit to the $i$-th worker for storage. The master will then read the bits back from the workers and return them to the user, in the same order in which they were read in.\n\nDuring normal operation, TEST\\_STORE should return the same string of bits that it read in, but unfortunately, $B$ of the workers are broken!\n\nThe broken workers are correctly able to store the bits given to them, but whenever the master tries to read from a broken worker, no bit is returned. This causes the TEST\\_STORE operation to return only $N-B$ bits, which are the bits stored on the non-broken workers (in ascending order of their IDs). For example, suppose $N = 5$ and the 0th and 3rd workers are broken (so $B = 2$). Then:\n\n* TEST\\_STORE 01101 returns 111.\n* TEST\\_STORE 00110 returns 010.\n* TEST\\_STORE 01010 returns 100.\n* TEST\\_STORE 11010 also returns 100.\n\nFor security reasons, the database is hidden in an underground mountain vault, so calls to TEST\\_STORE take a very long time. You have been tasked with working out which workers are broken using at most $F$ calls to TEST\\_STORE.\n\n### Interactive Protocol\n\nThis is an interactive problem. \n\nInitially, your program should read a single line containing a single integer $T$ indicating the number of test cases. Then, you need to process $T$ test cases.\n\nFor each test case, your program will first read a single line containing three integers $N$, $B$, and $F$, indicating the number of workers, the number of broken workers, and the number of lines you may send (as described below).\n\nThen you may send the judge up to $F$ lines, each containing a string of exactly $N$ characters, each either 0 or 1. Each time you send a line, the judge will check that you have not made more than $F$ calls. If you have, the judge will send you a single line containing a single -1, and then finish all communication and wait for your program to finish. Otherwise, the judge will send a string of length $N-B$: the string returned by TEST\\_STORE, as described above.\n\nOnce your program knows the index of the $B$ broken workers, it can finish the test case by sending $B$ space-separated integers: the IDs of the broken workers, in sorted order. This does not count as one of your $F$ calls.\n\nIf the $B$ integers are not exactly the IDs of the $B$ broken workers, you will receive a Wrong Answer verdict, and the judge will send a single line containing -1, and then no additional communication. If your answer was correct, the judge will send a single line with 1, followed by the line that begins the next test case (or exit, if that was the last test case).", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nThe following interaction meets the limits for Test set 1.\n\n```\n  t = readline_int()           // Reads 2 into t\n  n, b, f = readline_int_list()  // Reads 5, 2, 10 into n, b, f\n  printline 01101 to stdout    // The next four outputs match the example in\n                               // the problem statement.\n  flush stdout\n  response = readline_str()    // Reads 111 into response. (At this point, we\n                               // could determine the answer; the remaining\n                               // queries are just examples!)\n  printline 00110 to stdout\n  flush stdout\n  response = readline_str()    // Reads 010 into response\n  printline 01010 to stdout\n  flush stdout\n  response = readline_str()    // Reads 100 into response\n  printline 11010 to stdout\n  flush stdout\n  response = readline_str()    // Reads 100 into response\n  printline 0 3 to stdout      // Guesses the answer. Notice that we were\n                               // not required to use all 10 of our allowed\n                               // queries.\n  flush stdout\n  verdict = readline_int()     // Reads 1 into verdict. We got that test case\n                               // right!\n  n, b, f = readline_int_list()  // Reads 2, 1, 10 into n, b, f.\n  printline 01 to stdout       // 01 is a query, not a guess at the final\n                               // answer (if we wanted to guess that just\n                               // worker 1 were broken, we would have to\n                               // send 1 as we do below)\n  flush stdout\n  response = readline_str()    // Reads 1 into response.\n  printline 1 to stdout        // Makes a (bad) wild guess.\n  verdict = readline_str()     // Reads -1 into verdict.\n  exit                         // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq 1024$.\n- $1 \\leq B \\leq \\min(15, N-1)$.\n\n**Test set 1 (14 Pts, Visible)**\n\n- $F = 10$.\n\n**Test set 2 (20 Pts, Hidden)**\n\n- $F = 5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Qualification] Dat Bae", "background": "", "description": "A research consortium has built a new database system for their new data center. The database is made up of one master computer and $N$ worker computers, which are given IDs from 0 to $N-1$. Each worker stores exactly one bit of information... which seems rather wasteful, but this is very important data!\n\nYou have been hired to evaluate the following instruction for the database:\n\n* TEST\\_STORE <bits>: The master reads in <bits>, which is a string of $N$ bits, and sends the $i$-th bit to the $i$-th worker for storage. The master will then read the bits back from the workers and return them to the user, in the same order in which they were read in.\n\nDuring normal operation, TEST\\_STORE should return the same string of bits that it read in, but unfortunately, $B$ of the workers are broken!\n\nThe broken workers are correctly able to store the bits given to them, but whenever the master tries to read from a broken worker, no bit is returned. This causes the TEST\\_STORE operation to return only $N-B$ bits, which are the bits stored on the non-broken workers (in ascending order of their IDs). For example, suppose $N = 5$ and the 0th and 3rd workers are broken (so $B = 2$). Then:\n\n* TEST\\_STORE 01101 returns 111.\n* TEST\\_STORE 00110 returns 010.\n* TEST\\_STORE 01010 returns 100.\n* TEST\\_STORE 11010 also returns 100.\n\nFor security reasons, the database is hidden in an underground mountain vault, so calls to TEST\\_STORE take a very long time. You have been tasked with working out which workers are broken using at most $F$ calls to TEST\\_STORE.\n\n### Interactive Protocol\n\nThis is an interactive problem. \n\nInitially, your program should read a single line containing a single integer $T$ indicating the number of test cases. Then, you need to process $T$ test cases.\n\nFor each test case, your program will first read a single line containing three integers $N$, $B$, and $F$, indicating the number of workers, the number of broken workers, and the number of lines you may send (as described below).\n\nThen you may send the judge up to $F$ lines, each containing a string of exactly $N$ characters, each either 0 or 1. Each time you send a line, the judge will check that you have not made more than $F$ calls. If you have, the judge will send you a single line containing a single -1, and then finish all communication and wait for your program to finish. Otherwise, the judge will send a string of length $N-B$: the string returned by TEST\\_STORE, as described above.\n\nOnce your program knows the index of the $B$ broken workers, it can finish the test case by sending $B$ space-separated integers: the IDs of the broken workers, in sorted order. This does not count as one of your $F$ calls.\n\nIf the $B$ integers are not exactly the IDs of the $B$ broken workers, you will receive a Wrong Answer verdict, and the judge will send a single line containing -1, and then no additional communication. If your answer was correct, the judge will send a single line with 1, followed by the line that begins the next test case (or exit, if that was the last test case).", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nThe following interaction meets the limits for Test set 1.\n\n```\n  t = readline_int()           // Reads 2 into t\n  n, b, f = readline_int_list()  // Reads 5, 2, 10 into n, b, f\n  printline 01101 to stdout    // The next four outputs match the example in\n                               // the problem statement.\n  flush stdout\n  response = readline_str()    // Reads 111 into response. (At this point, we\n                               // could determine the answer; the remaining\n                               // queries are just examples!)\n  printline 00110 to stdout\n  flush stdout\n  response = readline_str()    // Reads 010 into response\n  printline 01010 to stdout\n  flush stdout\n  response = readline_str()    // Reads 100 into response\n  printline 11010 to stdout\n  flush stdout\n  response = readline_str()    // Reads 100 into response\n  printline 0 3 to stdout      // Guesses the answer. Notice that we were\n                               // not required to use all 10 of our allowed\n                               // queries.\n  flush stdout\n  verdict = readline_int()     // Reads 1 into verdict. We got that test case\n                               // right!\n  n, b, f = readline_int_list()  // Reads 2, 1, 10 into n, b, f.\n  printline 01 to stdout       // 01 is a query, not a guess at the final\n                               // answer (if we wanted to guess that just\n                               // worker 1 were broken, we would have to\n                               // send 1 as we do below)\n  flush stdout\n  response = readline_str()    // Reads 1 into response.\n  printline 1 to stdout        // Makes a (bad) wild guess.\n  verdict = readline_str()     // Reads -1 into verdict.\n  exit                         // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq 1024$.\n- $1 \\leq B \\leq \\min(15, N-1)$.\n\n**Test set 1 (14 Pts, Visible)**\n\n- $F = 10$.\n\n**Test set 2 (20 Pts, Hidden)**\n\n- $F = 5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Qualification] Dat Bae", "background": null, "description": "一个研究联盟为他们的新数据中心建立了一个新的数据库系统。该数据库由一台主控计算机和 $N$ 台工作计算机组成，工作计算机的编号从 $0$ 到 $N-1$。每台工作计算机只存储一位信息……这看起来似乎很浪费，但这些数据非常重要！\n\n你被雇佣来评估数据库的以下指令：\n\n- TEST\\_STORE <bits>：主控计算机读取 <bits>，这是一个长度为 $N$ 的二进制字符串，并将第 $i$ 位发送给第 $i$ 个工作计算机进行存储。随后，主控计算机会从工作计算机中读取这些位，并按照输入时的顺序返回给用户。\n\n在正常情况下，TEST\\_STORE 应该返回与输入相同的二进制字符串，但不幸的是，有 $B$ 台工作计算机损坏了！\n\n损坏的工作计算机能够正确存储分配给它们的位，但当主控计算机尝试从损坏的工作计算机读取数据时，将无法返回任何位。这导致 TEST\\_STORE 操作只返回 $N-B$ 位，这些位是存储在未损坏工作计算机上的（按照它们的编号升序排列）。例如，假设 $N = 5$，第 0 和第 3 号工作计算机损坏（即 $B = 2$）。那么：\n\n- TEST\\_STORE 01101 返回 111。\n- TEST\\_STORE 00110 返回 010。\n- TEST\\_STORE 01010 返回 100。\n- TEST\\_STORE 11010 也返回 100。\n\n出于安全原因，数据库被隐藏在地下山体仓库中，因此每次调用 TEST\\_STORE 都需要很长时间。你的任务是在最多 $F$ 次 TEST\\_STORE 调用内，找出哪些工作计算机损坏了。\n\n### 交互协议\n\n这是一个交互题。\n\n程序开始时，应读取一行，包含一个整数 $T$，表示测试用例的数量。然后，你需要处理 $T$ 个测试用例。\n\n对于每个测试用例，程序首先会读取一行，包含三个整数 $N$、$B$ 和 $F$，分别表示工作计算机的数量、损坏的工作计算机数量以及你可以发送的最多查询次数（如下所述）。\n\n接下来，你可以向评测机最多发送 $F$ 行，每行包含一个长度为 $N$ 的字符串，每个字符为 0 或 1。每当你发送一行时，评测机会检查你是否已超过 $F$ 次调用。如果超过，评测机会返回一行，内容为 -1，然后结束所有通信并等待你的程序结束。否则，评测机会返回一个长度为 $N-B$ 的字符串，即 TEST\\_STORE 操作的返回值，如上所述。\n\n一旦你确定了 $B$ 个损坏的工作计算机的编号，可以通过发送一行 $B$ 个用空格分隔的整数（按升序排列）来提交答案。这一步不计入 $F$ 次调用之内。\n\n如果你提交的 $B$ 个整数不是准确的损坏工作计算机编号，你将收到 Wrong Answer 判定，评测机会返回一行 -1，之后不再进行任何通信。如果你的答案正确，评测机会返回一行 1，随后进入下一个测试用例（或结束，如果这是最后一个测试用例）。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**交互样例**\n\n以下交互过程符合测试集 1 的限制。\n\n```\n  t = readline_int()           // 读取 t=2\n  n, b, f = readline_int_list()  // 读取 n=5, b=2, f=10\n  printline 01101 to stdout    // 以下四次输出与题目描述中的例子一致\n  flush stdout\n  response = readline_str()    // 读取 response=111（此时我们已可确定答案，后续查询仅为示例）\n  printline 00110 to stdout\n  flush stdout\n  response = readline_str()    // 读取 response=010\n  printline 01010 to stdout\n  response = readline_str()    // 读取 response=100\n  printline 11010 to stdout\n  flush stdout\n  response = readline_str()    // 读取 response=100\n  printline 0 3 to stdout      // 猜测答案。注意不要求用完所有 10 次查询。\n  flush stdout\n  verdict = readline_int()     // 读取 verdict=1，说明本测试用例正确！\n  n, b, f = readline_int_list()  // 读取 n=2, b=1, f=10\n  printline 01 to stdout       // 01 是一次查询，不是最终答案（如果想猜测只有 1 号损坏，应像下方一样输出）\n  flush stdout\n  response = readline_str()    // 读取 response=1\n  printline 1 to stdout        // 随意猜测\n  verdict = readline_str()     // 读取 verdict=-1\n  exit                         // 退出以避免歧义性 TLE 错误\n```\n\n你可以使用本地测试工具在本地或平台上进行测试。要在本地测试，你需要让测试工具与你的代码并行运行；你可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释说明。\n\n测试工具的使用说明已包含在工具的注释中。我们鼓励你添加自己的测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真实的评测系统，可能会有不同的表现。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq N \\leq 1024$。\n- $1 \\leq B \\leq \\min(15, N-1)$。\n\n**测试集 1（14 分，公开）**\n\n- $F = 10$。\n\n**测试集 2（20 分，隐藏）**\n\n- $F = 5$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13106", "type": "P", "difficulty": 5, "samples": [["2\n2 2\n2 5", "Case #1: IMPOSSIBLE\nCase #2: POSSIBLE\n2 3\n1 1\n2 4\n1 2\n2 5\n1 3\n2 1\n1 5\n2 2\n1 4"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2019", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 #1A] Pylons", "background": "", "description": "Our Battlestarcraft Algorithmica ship is being chased through space by persistent robots called Pylons! We have just teleported to a new galaxy to try to shake them off of our tail, and we want to stay here for as long as possible so we can buy time to plan our next move... but we do not want to get caught!\n\nThis galaxy is a flat grid of $R$ rows and $C$ columns; the rows are numbered from 1 to $R$ from top to bottom, and the columns are numbered from 1 to $C$ from left to right. We can choose which cell to start in, and we must continue to jump between cells until we have visited each cell in the galaxy exactly once. That is, we can never revisit a cell, including our starting cell.\n\nWe do not want to make it too easy for the Pylons to guess where we will go next. Each time we jump from our current cell, we must choose a destination cell that does not share a row, column, or diagonal with that current cell. Let $(i, j)$ denote the cell in the $i$-th row and $j$-th column; then a jump from a current cell $(r, c)$ to a destination cell $(r', c')$ is invalid if and only if any of these is true:\n\n* $r = r'$\n* $c = c'$\n* $r - c = r' - c'$\n* $r + c = r' + c'$\n\nCan you help us find an order in which to visit each of the $R \\times C$ cells, such that the move between any pair of consecutive cells in the sequence is valid? Or is it impossible for us to escape from the Pylons?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line containing two integers $R$ and $C$: the numbers of rows and columns in this galaxy.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $y$ is a string of uppercase letters: either `POSSIBLE` or `IMPOSSIBLE`, according to whether it is possible to fulfill the conditions in the problem statement. Then, if it is possible, output $R \\times C$ more lines. The $i$-th of these lines represents the $i$-th cell you will visit (counting starting from 1), and should contain two integers $r_i$ and $c_i$: the row and column of that cell. Note that the first of these lines represents your chosen starting cell.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, no matter which starting cell we choose, we have nowhere to jump, since all of the remaining cells share a row, column, or diagonal with our starting cell.\n\nIn Sample Case #2, we have chosen the cell in row 2, column 3 as our starting cell. Notice that it is fine for our final cell to share a row, column, or diagonal with our starting cell. The following diagram shows the order in which the cells are visited:\n\n```\n2 4 6 10 8\n7 9 1 3  5\n```\n\n**Limits**\n\n**Test set 1 (8 Pts, Visible)**\n\n- $\\text{T} = 16.$\n- $2 \\leqslant \\text{R} \\leqslant 5.$\n- $2 \\leqslant \\text{C} \\leqslant 5.$\n\n**Test set 2 (23 Pts, Hidden)**\n\n- $1 \\leqslant \\text{T} \\leqslant 100.$\n- $2 \\leqslant \\text{R} \\leqslant 20.$\n- $2 \\leqslant \\text{C} \\leqslant 20.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1A] Pylons", "background": "", "description": "Our Battlestarcraft Algorithmica ship is being chased through space by persistent robots called Pylons! We have just teleported to a new galaxy to try to shake them off of our tail, and we want to stay here for as long as possible so we can buy time to plan our next move... but we do not want to get caught!\n\nThis galaxy is a flat grid of $R$ rows and $C$ columns; the rows are numbered from 1 to $R$ from top to bottom, and the columns are numbered from 1 to $C$ from left to right. We can choose which cell to start in, and we must continue to jump between cells until we have visited each cell in the galaxy exactly once. That is, we can never revisit a cell, including our starting cell.\n\nWe do not want to make it too easy for the Pylons to guess where we will go next. Each time we jump from our current cell, we must choose a destination cell that does not share a row, column, or diagonal with that current cell. Let $(i, j)$ denote the cell in the $i$-th row and $j$-th column; then a jump from a current cell $(r, c)$ to a destination cell $(r', c')$ is invalid if and only if any of these is true:\n\n* $r = r'$\n* $c = c'$\n* $r - c = r' - c'$\n* $r + c = r' + c'$\n\nCan you help us find an order in which to visit each of the $R \\times C$ cells, such that the move between any pair of consecutive cells in the sequence is valid? Or is it impossible for us to escape from the Pylons?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line containing two integers $R$ and $C$: the numbers of rows and columns in this galaxy.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $y$ is a string of uppercase letters: either `POSSIBLE` or `IMPOSSIBLE`, according to whether it is possible to fulfill the conditions in the problem statement. Then, if it is possible, output $R \\times C$ more lines. The $i$-th of these lines represents the $i$-th cell you will visit (counting starting from 1), and should contain two integers $r_i$ and $c_i$: the row and column of that cell. Note that the first of these lines represents your chosen starting cell.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, no matter which starting cell we choose, we have nowhere to jump, since all of the remaining cells share a row, column, or diagonal with our starting cell.\n\nIn Sample Case #2, we have chosen the cell in row 2, column 3 as our starting cell. Notice that it is fine for our final cell to share a row, column, or diagonal with our starting cell. The following diagram shows the order in which the cells are visited:\n\n```\n2 4 6 10 8\n7 9 1 3  5\n```\n\n**Limits**\n\n**Test set 1 (8 Pts, Visible)**\n\n- $\\text{T} = 16.$\n- $2 \\leqslant \\text{R} \\leqslant 5.$\n- $2 \\leqslant \\text{C} \\leqslant 5.$\n\n**Test set 2 (23 Pts, Hidden)**\n\n- $1 \\leqslant \\text{T} \\leqslant 100.$\n- $2 \\leqslant \\text{R} \\leqslant 20.$\n- $2 \\leqslant \\text{C} \\leqslant 20.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1A] Pylons", "background": null, "description": "我们的 Battlestarcraft Algorithmica 飞船正在太空中被名为 Pylons 的顽固机器人追赶！我们刚刚传送到一个新的星系，试图甩掉它们，并希望能在这里停留尽可能长的时间，以便为下一步行动争取时间……但我们绝不能被抓住！\n\n这个星系是一个 $R$ 行 $C$ 列的平面网格；行从上到下编号为 $1$ 到 $R$，列从左到右编号为 $1$ 到 $C$。我们可以选择从任意一个格子开始，并且必须不断地跳跃到其他格子，直到每个格子都恰好访问一次。也就是说，我们不能重复访问任何格子，包括起始格子。\n\n我们不希望让 Pylons 太容易猜到我们下一步会去哪里。每次从当前格子跳跃时，必须选择一个不与当前格子在同一行、同一列或同一对角线上的目标格子。设 $(i, j)$ 表示第 $i$ 行第 $j$ 列的格子；那么从当前格子 $(r, c)$ 跳到目标格子 $(r', c')$ 是无效的，当且仅当以下任一条件成立：\n\n- $r = r'$\n- $c = c'$\n- $r - c = r' - c'$\n- $r + c = r' + c'$\n\n你能帮我们找到一种访问 $R \\times C$ 个格子的顺序，使得任意一对相邻格子的移动都是有效的吗？或者说，我们根本无法逃脱 Pylons 的追捕？", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 个测试用例。每个测试用例包含一行，包含两个整数 $R$ 和 $C$，分别表示这个星系的行数和列数。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $y$ 是一个大写字母字符串：如果可以满足题目要求则为 `POSSIBLE`，否则为 `IMPOSSIBLE`。如果可能，请接着输出 $R \\times C$ 行，第 $i$ 行表示你访问的第 $i$ 个格子（从 $1$ 开始计数），包含两个整数 $r_i$ 和 $c_i$，分别表示该格子的行号和列号。注意，第一行表示你选择的起始格子。", "hint": "**样例解释**\n\n在样例第 1 组中，无论选择哪个起始格子，都无法跳到其他格子，因为剩下的所有格子都与起始格子在同一行、同一列或同一对角线上。\n\n在样例第 2 组中，我们选择了第 2 行第 3 列的格子作为起始格子。注意，最后一个格子可以与起始格子在同一行、同一列或同一对角线上。下图展示了访问格子的顺序：\n\n```\n2 4 6 10 8\n7 9 1 3  5\n```\n\n**数据范围**\n\n**测试点 1（8 分，可见）**\n\n- $\\text{T} = 16$\n- $2 \\leqslant \\text{R} \\leqslant 5$\n- $2 \\leqslant \\text{C} \\leqslant 5$\n\n**测试点 2（23 分，隐藏）**\n\n- $1 \\leqslant \\text{T} \\leqslant 100$\n- $2 \\leqslant \\text{R} \\leqslant 20$\n- $2 \\leqslant \\text{C} \\leqslant 20$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13107", "type": "P", "difficulty": 5, "samples": [["", ""]], "limits": {"time": [20000, 20000], "memory": [1048576, 1048576]}, "tags": ["2019", "交互题", "Special Judge", "中国剩余定理 CRT", "Google Code Jam"], "title": "[GCJ 2019 #1A] Golf Gophers", "background": "", "description": "Last year, a bunch of pesky gophers took up residence in our orchard. We tried to change our line of work by opening up a miniature golf course, but it looks like the gophers have followed us here! Once again, we need to figure out how many gophers there are, but we cannot observe them directly because they are secretive and nocturnal, whereas we like to sleep at night. We do know there are between 1 and M gophers, inclusive.\n\nOur mini golf course is famous for having a small electronic windmill on each of its 18 holes. The i-th windmill has $2 \\leqslant \\mathbf{B}_{\\mathrm{i}} \\leqslant 18$ blades, which are numbered from 0 to $\\mathbf{B}_{\\mathrm{i}}-1$, clockwise. Each night, before going to sleep, we turn off the windmills and set each one such that blade 0 is pointing downward, which is important so that the windmills can charge up properly for the next day. However, we have noticed that when we wake up, the windmills have been disturbed. Since our mini golf course is in a windless area, we think the mischievous gophers must be responsible!\n\nWe know that every night, all of the gophers emerge, one by one; each of them chooses one of the windmills independently and uniformly at random and rotates it counterclockwise by one blade. So, for example, for a windmill with 3 blades for which 0 is pointing downward, the first gopher to interact with it turns it so that 1 is pointing downward, and then the next gophers to interact with that windmill make the downward-pointing blade have number 2, then 0, then 1, and so on.\n\nWe have devised a plan. We designed our windmills so that we can easily change the number of blades (to modulate the difficulty of our course), and we will now take advantage of this! Each night, before going to sleep, we can choose the number of blades on each of the 18 windmills, within the given limits; we do not have to use the same number of blades on each windmill, or make the same choices every night. In the morning, we will observe the number on each windmill's downward-pointing blade.\n\nWe have $\\mathbf{N}$ nights in which to figure out $\\mathbf{G}$, the number of gophers. Can you help us?\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing three integers $\\mathbf{T}$, $\\mathbf{N}$ and $\\mathbf{M}$, the number of test cases, the number of nights allowed per test case and the maximum number of gophers, respectively. Then, you need to process $\\mathbf{T}$ test cases.\n\nIn each test case, your program processes up to $\\mathbf{N}+1$ exchanges with our judge. You may make up to $\\mathbf{N}$ exchanges of the following form:\n\n* Your program outputs one line with eighteen integers between 2 and 18, inclusive; the i-th of these represents the number of blades you want the i-th windmill to have on that night.\n* The judge responds with one line with eighteen integers; the i-th of these represents the number on the downward-pointing blade of the i-th windmill in the morning, after the gophers have worked their mischief. If you sent invalid data (e.g., a number out of range, or a malformed line), the judge instead responds with -1.\n\nOn each night, for each gopher, the choice of which windmill the gopher turns is uniform at (pseudo)-random, and independent of any other choice by any gopher (including itself) on any night.\n\nAfter making between 0 and $\\mathbf{N}$ exchanges as explained above, you must make one more exchange of the following form:\n\n* Your program outputs one integer: your guess for $\\mathbf{G}$, the number of gophers.\n* The judge responds with one line with a single integer: 1 if your answer is correct, and -1 if it is not (or you have provided a malformed line).\n\nAfter the judge sends -1 to your input stream (because of either invalid data or an incorrect answer), it will not send any other output. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nThis interaction corresponds to Test set 1. Suppose that, unbeknownst to us, the judge has decided that there are 10 gophers.\n\n```\n  t, n, m = readline_int_list()   // Reads 20 into t, 365 into n and 100 into m.\n  // Choose numbers of blades for day 1.\n  printline 2 2 2 2 18 3 3 3 3 3 3 4 4 4 4 5 2 2 to stdout\n  flush stdout\n  // Reads 0 0 0 0 0 0 1 2 1 0 1 2 0 0 0 0 1 0 into res.\n  res = readline_int_list()\n  // Choose numbers of blades for day 2.\n  printline 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2 to stdout\n  flush stdout\n  // Reads 0 1 1 2 0 0 1 0 0 0 0 0 0 1 0 0 0 0 into res.\n  res = readline_int_list()\n  printline 8 to stdout        // We make a wrong guess even though we could\n  flush stdout                 // have investigated for up to 363 more nights.\n  verdict = readline_int()     // Reads -1 into verdict (judge has decided our\n                               //   solution is incorrect)\n  exit                         // Exits to avoid an ambiguous TLE error\n```\n\nNotice that even though the guess was consistent with the information we received from the judge, we were still wrong because we did not find the correct value.\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 20 .$\n\n**Test set 1 (11 Pts, Visible)**\n\n- $\\mathrm{N}=365$.\n- $\\mathrm{M}=100$.\n\n**Test set 2 (21 Pts, Hidden)**\n\n- $\\mathrm{N}=7$.\n- $\\mathrm{M}=10^{6}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1A] Golf Gophers", "background": "", "description": "Last year, a bunch of pesky gophers took up residence in our orchard. We tried to change our line of work by opening up a miniature golf course, but it looks like the gophers have followed us here! Once again, we need to figure out how many gophers there are, but we cannot observe them directly because they are secretive and nocturnal, whereas we like to sleep at night. We do know there are between 1 and M gophers, inclusive.\n\nOur mini golf course is famous for having a small electronic windmill on each of its 18 holes. The i-th windmill has $2 \\leqslant \\mathbf{B}_{\\mathrm{i}} \\leqslant 18$ blades, which are numbered from 0 to $\\mathbf{B}_{\\mathrm{i}}-1$, clockwise. Each night, before going to sleep, we turn off the windmills and set each one such that blade 0 is pointing downward, which is important so that the windmills can charge up properly for the next day. However, we have noticed that when we wake up, the windmills have been disturbed. Since our mini golf course is in a windless area, we think the mischievous gophers must be responsible!\n\nWe know that every night, all of the gophers emerge, one by one; each of them chooses one of the windmills independently and uniformly at random and rotates it counterclockwise by one blade. So, for example, for a windmill with 3 blades for which 0 is pointing downward, the first gopher to interact with it turns it so that 1 is pointing downward, and then the next gophers to interact with that windmill make the downward-pointing blade have number 2, then 0, then 1, and so on.\n\nWe have devised a plan. We designed our windmills so that we can easily change the number of blades (to modulate the difficulty of our course), and we will now take advantage of this! Each night, before going to sleep, we can choose the number of blades on each of the 18 windmills, within the given limits; we do not have to use the same number of blades on each windmill, or make the same choices every night. In the morning, we will observe the number on each windmill's downward-pointing blade.\n\nWe have $\\mathbf{N}$ nights in which to figure out $\\mathbf{G}$, the number of gophers. Can you help us?\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing three integers $\\mathbf{T}$, $\\mathbf{N}$ and $\\mathbf{M}$, the number of test cases, the number of nights allowed per test case and the maximum number of gophers, respectively. Then, you need to process $\\mathbf{T}$ test cases.\n\nIn each test case, your program processes up to $\\mathbf{N}+1$ exchanges with our judge. You may make up to $\\mathbf{N}$ exchanges of the following form:\n\n* Your program outputs one line with eighteen integers between 2 and 18, inclusive; the i-th of these represents the number of blades you want the i-th windmill to have on that night.\n* The judge responds with one line with eighteen integers; the i-th of these represents the number on the downward-pointing blade of the i-th windmill in the morning, after the gophers have worked their mischief. If you sent invalid data (e.g., a number out of range, or a malformed line), the judge instead responds with -1.\n\nOn each night, for each gopher, the choice of which windmill the gopher turns is uniform at (pseudo)-random, and independent of any other choice by any gopher (including itself) on any night.\n\nAfter making between 0 and $\\mathbf{N}$ exchanges as explained above, you must make one more exchange of the following form:\n\n* Your program outputs one integer: your guess for $\\mathbf{G}$, the number of gophers.\n* The judge responds with one line with a single integer: 1 if your answer is correct, and -1 if it is not (or you have provided a malformed line).\n\nAfter the judge sends -1 to your input stream (because of either invalid data or an incorrect answer), it will not send any other output. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nThis interaction corresponds to Test set 1. Suppose that, unbeknownst to us, the judge has decided that there are 10 gophers.\n\n```\n  t, n, m = readline_int_list()   // Reads 20 into t, 365 into n and 100 into m.\n  // Choose numbers of blades for day 1.\n  printline 2 2 2 2 18 3 3 3 3 3 3 4 4 4 4 5 2 2 to stdout\n  flush stdout\n  // Reads 0 0 0 0 0 0 1 2 1 0 1 2 0 0 0 0 1 0 into res.\n  res = readline_int_list()\n  // Choose numbers of blades for day 2.\n  printline 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2 to stdout\n  flush stdout\n  // Reads 0 1 1 2 0 0 1 0 0 0 0 0 0 1 0 0 0 0 into res.\n  res = readline_int_list()\n  printline 8 to stdout        // We make a wrong guess even though we could\n  flush stdout                 // have investigated for up to 363 more nights.\n  verdict = readline_int()     // Reads -1 into verdict (judge has decided our\n                               //   solution is incorrect)\n  exit                         // Exits to avoid an ambiguous TLE error\n```\n\nNotice that even though the guess was consistent with the information we received from the judge, we were still wrong because we did not find the correct value.\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 20 .$\n\n**Test set 1 (11 Pts, Visible)**\n\n- $\\mathrm{N}=365$.\n- $\\mathrm{M}=100$.\n\n**Test set 2 (21 Pts, Hidden)**\n\n- $\\mathrm{N}=7$.\n- $\\mathrm{M}=10^{6}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1A] Golf Gophers", "background": null, "description": "去年，一群讨厌的地鼠在我们的果园里安了家。我们试图转行，开了一家迷你高尔夫球场，但看起来地鼠们又跟着我们来了！我们再次需要弄清楚有多少只地鼠，但我们无法直接观察它们，因为它们很隐秘且是夜行性动物，而我们喜欢晚上睡觉。我们只知道地鼠的数量在 $1$ 到 $M$ 之间（包含两端）。\n\n我们的迷你高尔夫球场以每个球洞上都有一个小型电子风车而闻名，一共 18 个球洞。第 $i$ 个风车有 $2 \\leqslant \\mathbf{B}_{\\mathrm{i}} \\leqslant 18$ 片叶片，编号从 $0$ 到 $\\mathbf{B}_{\\mathrm{i}}-1$，顺时针排列。每天晚上，睡觉前我们会关闭所有风车，并将每个风车设置为 0 号叶片朝下，这样风车才能为第二天正常充电。然而，我们注意到，早上醒来时风车的位置已经被扰乱。由于我们的球场没有风，所以我们认为一定是这些调皮的地鼠搞的鬼！\n\n我们知道，每天晚上，所有地鼠都会依次出现；每只地鼠会独立且等概率地选择一个风车，并将其逆时针旋转一片叶片。例如，对于一个有 3 片叶片、0 号叶片朝下的风车，第一只地鼠会让 1 号叶片朝下，之后每有一只地鼠操作该风车，朝下的叶片编号依次变为 2、0、1，依此类推。\n\n我们已经想好了一个计划。我们的风车设计允许我们轻松更改叶片数量（以调整球场难度），现在我们要利用这一点！每天晚上睡觉前，我们可以为每个风车选择叶片数量，范围在给定的限制内；我们不需要每晚为每个风车选择相同的叶片数，也不需要每晚都做相同的选择。第二天早上，我们会观察每个风车朝下的叶片编号。\n\n我们有 $\\mathbf{N}$ 个夜晚来推断出 $\\mathbf{G}$，即地鼠的数量。你能帮我们吗？\n\n### 交互协议\n\n这是一个交互题。\n\n最开始，你的程序应读取一行，包含三个整数 $\\mathbf{T}$、$\\mathbf{N}$ 和 $\\mathbf{M}$，分别表示测试用例数量、每个用例允许的夜晚数和地鼠数量的最大值。然后，你需要处理 $\\mathbf{T}$ 个测试用例。\n\n在每个测试用例中，你的程序最多与评测器进行 $\\mathbf{N}+1$ 次交互。你可以进行最多 $\\mathbf{N}$ 次如下形式的交互：\n\n- 你的程序输出一行 18 个整数，每个整数在 2 到 18 之间（包含），第 $i$ 个数表示你希望第 $i$ 个风车当晚拥有的叶片数。\n- 评测器返回一行 18 个整数，第 $i$ 个数表示早上第 $i$ 个风车朝下的叶片编号（经过地鼠捣乱后）。如果你输出了非法数据（如超出范围的数字或格式错误），评测器会返回 -1。\n\n每个夜晚，对于每只地鼠，选择哪个风车是独立且等概率的（伪）随机选择，与其他地鼠（包括自己）在任何夜晚的选择都无关。\n\n在进行 0 到 $\\mathbf{N}$ 次上述交互后，你必须再进行一次如下形式的交互：\n\n- 你的程序输出一个整数，表示你猜测的地鼠数量 $\\mathbf{G}$。\n- 评测器返回一行一个整数：如果你的答案正确则为 1，否则为 -1（或你输出了格式错误的行）。\n\n当评测器向你的输入流发送 -1（因为数据非法或答案错误）后，不会再发送其他输出。如果你的程序在收到 -1 后仍然等待评测器输出，将会超时（TLE）。请注意，你有责任在收到 -1 后及时退出，以获得 Wrong Answer 判决而不是 Time Limit Exceeded。如果超出内存限制或发生运行时错误，将获得相应的判决。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**交互样例**\n\n本交互对应于测试集 1。假设评测器实际设定的地鼠数量为 10。\n\n```\n  t, n, m = readline_int_list()   // 读取 t=20, n=365, m=100。\n  // 第一天选择风车叶片数。\n  printline 2 2 2 2 18 3 3 3 3 3 3 4 4 4 4 5 2 2 到标准输出\n  flush stdout\n  // 读取 0 0 0 0 0 0 1 2 1 0 1 2 0 0 0 0 1 0 到 res。\n  res = readline_int_list()\n  // 第二天选择风车叶片数。\n  printline 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2 到标准输出\n  flush stdout\n  // 读取 0 1 1 2 0 0 1 0 0 0 0 0 0 1 0 0 0 0 到 res。\n  res = readline_int_list()\n  printline 8 到标准输出        // 我们做了一个错误的猜测，尽管还可以调查 363 个夜晚。\n  flush stdout\n  // 读取 -1 到 verdict（评测器判定我们的解答错误）\n  exit                         // 退出以避免 TLE 错误\n```\n\n注意，即使猜测与已知信息一致，如果不是正确答案，依然会判错。\n\n你可以使用本题的测试工具在本地或平台上测试。若要在本地测试，你需要让测试工具与代码并行运行；你可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件注释中的说明。\n\n测试工具的使用说明已包含在工具注释中。我们鼓励你添加自己的测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真实的评测系统，可能会有不同表现。\n\n**数据范围**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 20$。\n\n**测试集 1（11 分，可见）**\n\n- $\\mathrm{N}=365$。\n- $\\mathrm{M}=100$。\n\n**测试集 2（21 分，隐藏）**\n\n- $\\mathrm{N}=7$。\n- $\\mathrm{M}=10^{6}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13108", "type": "P", "difficulty": 4, "samples": [["4\n2\nTARPOL\nPROL\n3\nTARPOR\nPROL\nTARPRO\n6\nCODEJAM\nJAM\nHAM\nNALAM\nHUM\nNOLOM\n4\nPI\nHI\nWI\nFI", "Case #1: 2\nCase #2: 0\nCase #3: 6\nCase #4: 2"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2019", "字典树 Trie", "Google Code Jam"], "title": "[GCJ 2019 #1A] Alien Rhyme", "background": "", "description": "During some extraterrestrial exploration, you found evidence of alien poetry! Your team of linguists has determined that each word in the alien language has an accent on exactly one position (letter) in the word; the part of the word starting from the accented letter is called the accent-suffix. Two words are said to rhyme if both of their accent-suffixes are equal. For example, the words $\\text{PROL}$ and $\\text{TARPOL}$ rhyme if the accented letter in both is the $\\text{o}$ or the $\\text{L}$, but they do not rhyme if the accented letters are the $\\text{RS}$, or the $\\text{R}$ in $\\text{PROL}$ and the $\\text{P}$ in $\\text{TARPOL}$, or the $\\text{O}$ in $\\text{PROL}$ and the $\\text{L}$ in $\\text{TARPOL}$.\n\nYou have recovered a list of $N$ words that may be part of an alien poem. Unfortunately, you do not know which is the accented letter for each word. You believe that you can discard zero or more of these words, assign accented letters to the remaining words, and then arrange those words into pairs such that each word rhymes only with the other word in its pair, and with none of the words in other pairs.\n\nYou want to know the largest number of words that can be arranged into pairs in this way.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line with a single integer $N$. Then, $N$ lines follow, each of which contains a string $W_i$ of uppercase English letters, representing a distinct word. Notice that the same word can have different accentuations in different test cases.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the size of the largest subset of words meeting the criteria described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the two words can rhyme with an appropriate accent assignment, as described above, so the largest subset is the entire input.\n\nIn Sample Case #2, no two words can rhyme regardless of how we assign accents, because any two suffixes will differ at least in the last letter. Therefore, the largest subset is the empty one, of size 0.\n\nIn Sample Case #3, we can use the entire set of words if we accentuate `CODEJAM` and `JAM` at the `J`s, `HAM` and `NALAM` at their last `A`s and `HUM` and `NOLOM` at the Ms.\n\nIn Sample Case #4, any two words can be made to rhyme, but always by making the accented letter the `I`. Therefore, if we add two pairs to the subset, words from different pairs will rhyme. We can, thus, only form a subset of size 2, by choosing any 2 of the input words.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $1 \\leq \\text{length of } W_i \\leq 50,$ for all $i.$\n- $W_i$ consists of uppercase English letters, for all $i.$\n- $W_i \\neq W_j,$ for all $i \\neq j.$ (Words are not repeated within a test case.)\n\n**Test set 1 (10 Pts, Visible)**\n\n- $2 \\leq N \\leq 6.$\n\n**Test set 2 (27 Pts, Hidden)**\n\n- $2 \\leq N \\leq 1000.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1A] Alien Rhyme", "background": "", "description": "During some extraterrestrial exploration, you found evidence of alien poetry! Your team of linguists has determined that each word in the alien language has an accent on exactly one position (letter) in the word; the part of the word starting from the accented letter is called the accent-suffix. Two words are said to rhyme if both of their accent-suffixes are equal. For example, the words $\\text{PROL}$ and $\\text{TARPOL}$ rhyme if the accented letter in both is the $\\text{o}$ or the $\\text{L}$, but they do not rhyme if the accented letters are the $\\text{RS}$, or the $\\text{R}$ in $\\text{PROL}$ and the $\\text{P}$ in $\\text{TARPOL}$, or the $\\text{O}$ in $\\text{PROL}$ and the $\\text{L}$ in $\\text{TARPOL}$.\n\nYou have recovered a list of $N$ words that may be part of an alien poem. Unfortunately, you do not know which is the accented letter for each word. You believe that you can discard zero or more of these words, assign accented letters to the remaining words, and then arrange those words into pairs such that each word rhymes only with the other word in its pair, and with none of the words in other pairs.\n\nYou want to know the largest number of words that can be arranged into pairs in this way.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line with a single integer $N$. Then, $N$ lines follow, each of which contains a string $W_i$ of uppercase English letters, representing a distinct word. Notice that the same word can have different accentuations in different test cases.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the size of the largest subset of words meeting the criteria described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the two words can rhyme with an appropriate accent assignment, as described above, so the largest subset is the entire input.\n\nIn Sample Case #2, no two words can rhyme regardless of how we assign accents, because any two suffixes will differ at least in the last letter. Therefore, the largest subset is the empty one, of size 0.\n\nIn Sample Case #3, we can use the entire set of words if we accentuate `CODEJAM` and `JAM` at the `J`s, `HAM` and `NALAM` at their last `A`s and `HUM` and `NOLOM` at the Ms.\n\nIn Sample Case #4, any two words can be made to rhyme, but always by making the accented letter the `I`. Therefore, if we add two pairs to the subset, words from different pairs will rhyme. We can, thus, only form a subset of size 2, by choosing any 2 of the input words.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $1 \\leq \\text{length of } W_i \\leq 50,$ for all $i.$\n- $W_i$ consists of uppercase English letters, for all $i.$\n- $W_i \\neq W_j,$ for all $i \\neq j.$ (Words are not repeated within a test case.)\n\n**Test set 1 (10 Pts, Visible)**\n\n- $2 \\leq N \\leq 6.$\n\n**Test set 2 (27 Pts, Hidden)**\n\n- $2 \\leq N \\leq 1000.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1A] Alien Rhyme", "background": null, "description": "在一次外星探索中，你发现了外星诗歌的证据！你的语言学家团队确定，外星语言中的每个单词都有且只有一个字母带有重音；从重音字母开始到单词结尾的部分称为“重音后缀”。如果两个单词的重音后缀相同，则称这两个单词押韵。例如，单词 $\\text{PROL}$ 和 $\\text{TARPOL}$，如果它们的重音字母都是 $\\text{o}$ 或 $\\text{L}$，则它们押韵；但如果重音字母分别是 $\\text{RS}$，或者 $\\text{PROL}$ 的重音字母是 $\\text{R}$ 而 $\\text{TARPOL}$ 的重音字母是 $\\text{P}$，又或者 $\\text{PROL}$ 的重音字母是 $\\text{O}$ 而 $\\text{TARPOL}$ 的重音字母是 $\\text{L}$，则它们不押韵。\n\n你找回了一份包含 $N$ 个单词的列表，这些单词可能是外星诗歌的一部分。不幸的是，你并不知道每个单词的重音字母是哪一个。你可以选择丢弃零个或多个单词，对剩下的单词分配重音字母，然后将这些单词两两配对，使得每个单词只与它的配对单词押韵，并且不与其他配对中的单词押韵。\n\n你想知道，最多能有多少个单词可以这样被配对。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为一个整数 $N$。接下来的 $N$ 行，每行包含一个由大写英文字母组成的字符串 $W_i$，表示一个不同的单词。注意，在不同的测试用例中，相同的单词可以有不同的重音分配方式。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是满足上述条件的最大单词数量。", "hint": "**样例解释**\n\n在样例 1 中，这两个单词可以通过合适的重音分配使其押韵，因此最大子集就是全部单词。\n\n在样例 2 中，无论如何分配重音，都没有两个单词能押韵，因为任何两个后缀的最后一个字母都不同。因此最大子集为空，大小为 0。\n\n在样例 3 中，如果将 `CODEJAM` 和 `JAM` 的重音都放在 `J` 上，将 `HAM` 和 `NALAM` 的重音都放在最后一个 `A` 上，将 `HUM` 和 `NOLOM` 的重音都放在 `M` 上，则可以使用全部单词。\n\n在样例 4 中，任意两个单词都可以押韵，但总是通过把重音放在 `I` 上实现。因此，如果选取两个配对，来自不同配对的单词也会押韵。因此最多只能选取 2 个单词组成一个配对。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq W_i$ 的长度 $\\leq 50$。\n- $W_i$ 仅包含大写英文字母。\n- 对于同一测试用例，$W_i \\neq W_j$，即单词不重复。\n\n**测试点 1（10 分，可见）**\n\n- $2 \\leq N \\leq 6$。\n\n**测试点 2（27 分，隐藏）**\n\n- $2 \\leq N \\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13109", "type": "P", "difficulty": 3, "samples": [["3\n1 10\n5 5 N\n4 10\n2 4 N\n2 6 S\n1 5 E\n3 5 W\n8 10\n0 2 S\n0 3 N\n0 3 N\n0 4 N\n0 5 S\n0 5 S\n0 8 S\n1 5 W", "Case #1: 0 6\nCase #2: 2 5\nCase #3: 0 4"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2019", "差分", "Google Code Jam"], "title": "[GCJ 2019 #1B] Manhattan Crepe Cart", "background": "", "description": "There are a lot of great streetside food vendors in Manhattan, but without a doubt, the one with the tastiest food is the Code Jam Crepe Cart!\n\nYou want to find the cart, but you do not know where it is, except that it is at some street intersection. You believe that people from across Manhattan are currently walking toward that intersection, so you will try to identify the intersection toward which the most people are traveling.\n\nFor the purposes of this problem, Manhattan is a regular grid with its axes aligned to compass lines and bounded between 0 and $\\mathbf{Q}$, inclusive, on each axis. There are west-east streets corresponding to gridlines $y = 0$, $y = 1$, $y = 2$, $\\cdots$, $y = \\mathbf{Q}$ and south-north streets corresponding to gridlines $x = 0$, $x = 1$, $x = 2$, $\\cdots$, $x = \\mathbf{Q}$, and people move only along these streets. The points where the lines meet — e.g., $(0, 0)$ and $(1, 2)$ — are intersections. The shortest distance between two intersections is measured via the Manhattan distance — that is, by the sum of the absolute horizontal difference and the absolute vertical difference between the two sets of coordinates.\n\nYou know the locations of $\\mathbf{P}$ people, all of whom are standing at intersections, and the compass direction each person is headed: north (increasing $y$ direction), south (decreasing $y$ direction), east (increasing $x$ direction), or west (decreasing $x$ direction). A person is moving toward a street intersection if their current movement is on a shortest path to that street intersection within the Manhattan grid. For example, if a person located at $(x_0, y_0)$ is moving north, then they are moving toward all street intersections that have coordinates $(x, y)$ with $y > y_0$.\n\nYou think the crepe cart is at the intersection toward which the most people are traveling. Moreover, you believe that more southern and western parts of the island are most likely to have a crepe cart, so if there are multiple such intersections, you will choose the one with the smallest non-negative $x$ coordinate, and if there are multiple such intersections with that same $x$ coordinate, the one among those with the smallest non-negative $y$ coordinate. Which intersection will you choose?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with one line containing two integers $\\mathbf{P}$ and $\\mathbf{Q}$: the number of people, and the maximum possible value of an $x$ or $y$ coordinate in Manhattan, as described above. Then, there are $\\mathbf{P}$ more lines. The $i$-th of those lines contains two integers $\\mathbf{X}_i$ and $\\mathbf{Y}_i$, the current location (street corner) of a person, and a character $\\mathbf{D}_i$, the direction that person is headed. $\\mathbf{D}_i$ is one of the uppercase letters N, S, E, or W, which stand for north, south, east, and west, respectively.", "outputFormat": "For each test case, output one line containing `Case #t: x y`, where $t$ is the test case number (starting from 1) and $x$ and $y$ are the horizontal and vertical coordinates of the intersection where you believe the crepe cart is located.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is only one person, and they are moving north from $(5, 5)$. This means that all street corners with $y \\geqslant 6$ are possible locations for the crepe cart. Of those possibilities, we choose the one with lowest $x \\geqslant 0$ and then lowest $y \\geqslant 6$.\n\nIn Sample Case #2, there are four people, all moving toward location $(2, 5)$. There is no other location that has as many people moving toward it.\n\nIn Sample Case #3, six of the eight people are moving toward location $(0, 4)$. There is no other location that has as many people moving toward it.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{P} \\leqslant 500$.\n- $0 \\leqslant \\mathbf{X}_i \\leqslant \\mathbf{Q}$, for all $i$.\n- $0 \\leqslant \\mathbf{Y}_i \\leqslant \\mathbf{Q}$, for all $i$.\n- For all $i$, if $\\mathbf{X}_i = 0$, $\\mathbf{D}_i \\neq \\text{w}$.\n- For all $i$, if $\\mathbf{Y}_i = 0$, $\\mathbf{D}_i \\neq \\text{s}$.\n- For all $i$, if $\\mathbf{X}_i = \\mathbf{Q}$, $\\mathbf{D}_i \\neq \\text{E}$.\n- For all $i$, if $\\mathbf{Y}_i = \\mathbf{Q}$, $\\mathbf{D}_i \\neq \\text{N}$.\n\n**Test set 1 (9 Pts, Visible)**\n\n- $\\mathbf{Q} = 10$.\n\n**Test set 2 (18 Pts, Hidden)**\n\n- $\\mathbf{Q} = 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1B] Manhattan Crepe Cart", "background": "", "description": "There are a lot of great streetside food vendors in Manhattan, but without a doubt, the one with the tastiest food is the Code Jam Crepe Cart!\n\nYou want to find the cart, but you do not know where it is, except that it is at some street intersection. You believe that people from across Manhattan are currently walking toward that intersection, so you will try to identify the intersection toward which the most people are traveling.\n\nFor the purposes of this problem, Manhattan is a regular grid with its axes aligned to compass lines and bounded between 0 and $\\mathbf{Q}$, inclusive, on each axis. There are west-east streets corresponding to gridlines $y = 0$, $y = 1$, $y = 2$, $\\cdots$, $y = \\mathbf{Q}$ and south-north streets corresponding to gridlines $x = 0$, $x = 1$, $x = 2$, $\\cdots$, $x = \\mathbf{Q}$, and people move only along these streets. The points where the lines meet — e.g., $(0, 0)$ and $(1, 2)$ — are intersections. The shortest distance between two intersections is measured via the Manhattan distance — that is, by the sum of the absolute horizontal difference and the absolute vertical difference between the two sets of coordinates.\n\nYou know the locations of $\\mathbf{P}$ people, all of whom are standing at intersections, and the compass direction each person is headed: north (increasing $y$ direction), south (decreasing $y$ direction), east (increasing $x$ direction), or west (decreasing $x$ direction). A person is moving toward a street intersection if their current movement is on a shortest path to that street intersection within the Manhattan grid. For example, if a person located at $(x_0, y_0)$ is moving north, then they are moving toward all street intersections that have coordinates $(x, y)$ with $y > y_0$.\n\nYou think the crepe cart is at the intersection toward which the most people are traveling. Moreover, you believe that more southern and western parts of the island are most likely to have a crepe cart, so if there are multiple such intersections, you will choose the one with the smallest non-negative $x$ coordinate, and if there are multiple such intersections with that same $x$ coordinate, the one among those with the smallest non-negative $y$ coordinate. Which intersection will you choose?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with one line containing two integers $\\mathbf{P}$ and $\\mathbf{Q}$: the number of people, and the maximum possible value of an $x$ or $y$ coordinate in Manhattan, as described above. Then, there are $\\mathbf{P}$ more lines. The $i$-th of those lines contains two integers $\\mathbf{X}_i$ and $\\mathbf{Y}_i$, the current location (street corner) of a person, and a character $\\mathbf{D}_i$, the direction that person is headed. $\\mathbf{D}_i$ is one of the uppercase letters N, S, E, or W, which stand for north, south, east, and west, respectively.", "outputFormat": "For each test case, output one line containing `Case #t: x y`, where $t$ is the test case number (starting from 1) and $x$ and $y$ are the horizontal and vertical coordinates of the intersection where you believe the crepe cart is located.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is only one person, and they are moving north from $(5, 5)$. This means that all street corners with $y \\geqslant 6$ are possible locations for the crepe cart. Of those possibilities, we choose the one with lowest $x \\geqslant 0$ and then lowest $y \\geqslant 6$.\n\nIn Sample Case #2, there are four people, all moving toward location $(2, 5)$. There is no other location that has as many people moving toward it.\n\nIn Sample Case #3, six of the eight people are moving toward location $(0, 4)$. There is no other location that has as many people moving toward it.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{P} \\leqslant 500$.\n- $0 \\leqslant \\mathbf{X}_i \\leqslant \\mathbf{Q}$, for all $i$.\n- $0 \\leqslant \\mathbf{Y}_i \\leqslant \\mathbf{Q}$, for all $i$.\n- For all $i$, if $\\mathbf{X}_i = 0$, $\\mathbf{D}_i \\neq \\text{w}$.\n- For all $i$, if $\\mathbf{Y}_i = 0$, $\\mathbf{D}_i \\neq \\text{s}$.\n- For all $i$, if $\\mathbf{X}_i = \\mathbf{Q}$, $\\mathbf{D}_i \\neq \\text{E}$.\n- For all $i$, if $\\mathbf{Y}_i = \\mathbf{Q}$, $\\mathbf{D}_i \\neq \\text{N}$.\n\n**Test set 1 (9 Pts, Visible)**\n\n- $\\mathbf{Q} = 10$.\n\n**Test set 2 (18 Pts, Hidden)**\n\n- $\\mathbf{Q} = 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1B] Manhattan Crepe Cart", "background": null, "description": "曼哈顿有许多很棒的街头小吃摊，但毫无疑问，味道最棒的是 Code Jam 可丽饼车！\n\n你想找到这辆小吃车，但你只知道它在某个街道交叉口。你认为来自曼哈顿各地的人们正朝着这个交叉口走去，因此你会尝试找出最多人正前往的那个交叉口。\n\n在本题中，曼哈顿是一张规则的网格，坐标轴与罗盘方向对齐，每个坐标轴的取值范围为 $0$ 到 $\\mathbf{Q}$（包含 $0$ 和 $\\mathbf{Q}$）。东西向的街道对应于 $y = 0, y = 1, y = 2, \\cdots, y = \\mathbf{Q}$ 的网格线，南北向的街道对应于 $x = 0, x = 1, x = 2, \\cdots, x = \\mathbf{Q}$ 的网格线，人们只能沿着这些街道行走。网格线的交点（如 $(0, 0)$ 和 $(1, 2)$）即为街道交叉口。两个交叉口之间的最短距离是曼哈顿距离，即横向距离与纵向距离的绝对值之和。\n\n你知道有 $\\mathbf{P}$ 个人的位置，他们都站在交叉口上，并且你知道每个人当前前进的方向：北（$y$ 增大方向）、南（$y$ 减小方向）、东（$x$ 增大方向）或西（$x$ 减小方向）。如果某个人当前的移动方向在曼哈顿网格中是通往某个交叉口的最短路径之一，则认为此人正朝该交叉口前进。例如，如果某人位于 $(x_0, y_0)$ 并向北移动，则他们正朝所有 $y > y_0$ 的交叉口前进。\n\n你认为可丽饼车就在最多人正前往的交叉口处。此外，你认为岛屿的更南部和更西部更有可能有可丽饼车，因此如果有多个这样的交叉口，你会选择 $x$ 坐标最小的那个，如果仍有多个，则选择 $y$ 坐标最小的那个。你会选择哪个交叉口？", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 组测试用例。每组测试用例的第一行包含两个整数 $\\mathbf{P}$ 和 $\\mathbf{Q}$，分别表示人数和曼哈顿坐标的最大值。接下来的 $\\mathbf{P}$ 行，每行包含两个整数 $\\mathbf{X}_i$ 和 $\\mathbf{Y}_i$，表示第 $i$ 个人当前所在的交叉口，以及一个字符 $\\mathbf{D}_i$，表示该人前进的方向。$\\mathbf{D}_i$ 是大写字母 N、S、E 或 W，分别代表北、南、东和西。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #t: x y`，其中 $t$ 是测试用例编号（从 1 开始），$x$ 和 $y$ 分别为你认为可丽饼车所在交叉口的横纵坐标。", "hint": "**样例解释**\n\n在样例 1 中，只有一个人，他从 $(5, 5)$ 向北移动。这意味着所有 $y \\geqslant 6$ 的交叉口都是可丽饼车可能的位置。在这些位置中，选择 $x \\geqslant 0$ 最小的，再选择 $y \\geqslant 6$ 最小的。\n\n在样例 2 中，有四个人都朝着 $(2, 5)$ 这个位置移动，没有其他位置有这么多人朝向。\n\n在样例 3 中，八个人中有六个人都朝着 $(0, 4)$ 这个位置移动，没有其他位置有这么多人朝向。\n\n**数据范围**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $1 \\leqslant \\mathbf{P} \\leqslant 500$。\n- $0 \\leqslant \\mathbf{X}_i \\leqslant \\mathbf{Q}$，对所有 $i$。\n- $0 \\leqslant \\mathbf{Y}_i \\leqslant \\mathbf{Q}$，对所有 $i$。\n- 对所有 $i$，如果 $\\mathbf{X}_i = 0$，则 $\\mathbf{D}_i \\neq \\text{W}$。\n- 对所有 $i$，如果 $\\mathbf{Y}_i = 0$，则 $\\mathbf{D}_i \\neq \\text{S}$。\n- 对所有 $i$，如果 $\\mathbf{X}_i = \\mathbf{Q}$，则 $\\mathbf{D}_i \\neq \\text{E}$。\n- 对所有 $i$，如果 $\\mathbf{Y}_i = \\mathbf{Q}$，则 $\\mathbf{D}_i \\neq \\text{N}$。\n\n**测试点 1（9 分，可见）**\n\n- $\\mathbf{Q} = 10$。\n\n**测试点 2（18 分，隐藏）**\n\n- $\\mathbf{Q} = 10^5$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13110", "type": "P", "difficulty": 4, "samples": [["", ""]], "limits": {"time": [20000, 20000], "memory": [1048576, 1048576]}, "tags": ["2019", "交互题", "Special Judge", "进制", "位运算", "Google Code Jam"], "title": "[GCJ 2019 #1B] Draupnir", "background": "", "description": "Odin has some magical rings which produce copies of themselves. Each \"X-day ring\" produces one more X-day ring every X days after the day it came into existence. These rings come in six possible varieties: 1-day, 2-day, ..., all the way up to 6-day.\n\nFor example, a 3-day ring that came into existence on day 0 would do nothing until day 3, when it would produce another 3-day ring. Then, on day 6, each of those two rings would produce another 3-day ring, and so on.\n\nYou know that Odin had no rings before day 0. On day 0, some rings came into existence. At the end of day 0, Odin had $R_i$ i-day rings, for each $1 \\leqslant i \\leqslant 6$. You know that $0 \\leqslant R_i \\leqslant 100$, for all $i$, and at least one of the $R_i$ values is positive.\n\nFortunately, you also have access to the secret well of knowledge. Each time you use it, you can find out the total number of rings that Odin had at the end of a particular day between day 1 and day 500, inclusive. The well will give you the answer modulo $2^{63}$, because even it can only hold so much information! Moreover, you can only use the well up to W times.\n\nYour goal is to determine how many rings of each type Odin had at the end of day 0 — that is, you must find each of the $R_i$ values.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing two integers $\\mathbf{T}$, the number of test cases, and $\\mathbf{W}$, the number of times you are allowed to use the well of knowledge per test case. Then, you need to process $\\mathbf{T}$ test cases.\n\nIn each test case, your program processes up to $\\mathbf{W} + 1$ exchanges with our judge. You may make up to $\\mathbf{W}$ exchanges of the following form:\n\n* Your program outputs one line with a single integer $\\mathbf{D}$ between 1 and 500, inclusive.\n* The judge responds with one line with a single integer: the total number of rings that Odin had at the end of day $\\mathbf{D}$, modulo $2^{63}$. If you send invalid data (e.g., a number out of range, or a malformed line), the judge instead responds with -1.\n\nAfter between 0 and $\\mathbf{W}$ exchanges as explained above, you must perform one more exchange of the following form:\n\n* Your program outputs one line with six integers $\\mathbf{R}_1$, $\\mathbf{R}_2$, $\\mathbf{R}_3$, $\\mathbf{R}_4$, $\\mathbf{R}_5$, $\\mathbf{R}_6$, where $\\mathbf{R}_i$ represents the number of i-day rings that Odin had at the end of day 0.\n* The judge responds with one line with a single integer: 1 if your answer is correct, and -1 if it is not (or you have provided a malformed line).\n\nAfter the judge sends -1 to your input stream (because of either invalid data or an incorrect answer), it will not send any other output. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nThis interaction corresponds to Test set 1. Suppose that, unbeknownst to us, the judge has decided that Odin had one ring of each of the six types at the end of day 0.\n\n```\n  t, w = readline_int_list()   // Reads 50 into t and 6 into w\n  printline 3 to stdout        // Asks about day 3.\n  flush stdout\n  n = readline_int()           // Reads 15 into n.\n  printline 1 to stdout        // Asks about day 1.\n  flush stdout\n  n = readline_int()           // Reads 7 into n.\n  printline 1 1 1 3 0 0 to stdout\n  flush stdout                 // We make a guess even though we could have\n                               // queried the well up to four more times.\n  verdict = readline_int()     // Reads -1 into verdict (judge has decided our\n                               //   solution is incorrect)\n  exit                         // Exits to avoid an ambiguous TLE error\n```\n\nNotice that even though the guess was consistent with the information we received from the judge, we were still wrong because we did not find the correct values.\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leq T \\leq 50$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $W = 6$.\n\n**Test set 2 (21 Pts, Hidden)**\n\n- $W = 2$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1B] Draupnir", "background": "", "description": "Odin has some magical rings which produce copies of themselves. Each \"X-day ring\" produces one more X-day ring every X days after the day it came into existence. These rings come in six possible varieties: 1-day, 2-day, ..., all the way up to 6-day.\n\nFor example, a 3-day ring that came into existence on day 0 would do nothing until day 3, when it would produce another 3-day ring. Then, on day 6, each of those two rings would produce another 3-day ring, and so on.\n\nYou know that Odin had no rings before day 0. On day 0, some rings came into existence. At the end of day 0, Odin had $R_i$ i-day rings, for each $1 \\leqslant i \\leqslant 6$. You know that $0 \\leqslant R_i \\leqslant 100$, for all $i$, and at least one of the $R_i$ values is positive.\n\nFortunately, you also have access to the secret well of knowledge. Each time you use it, you can find out the total number of rings that Odin had at the end of a particular day between day 1 and day 500, inclusive. The well will give you the answer modulo $2^{63}$, because even it can only hold so much information! Moreover, you can only use the well up to W times.\n\nYour goal is to determine how many rings of each type Odin had at the end of day 0 — that is, you must find each of the $R_i$ values.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing two integers $\\mathbf{T}$, the number of test cases, and $\\mathbf{W}$, the number of times you are allowed to use the well of knowledge per test case. Then, you need to process $\\mathbf{T}$ test cases.\n\nIn each test case, your program processes up to $\\mathbf{W} + 1$ exchanges with our judge. You may make up to $\\mathbf{W}$ exchanges of the following form:\n\n* Your program outputs one line with a single integer $\\mathbf{D}$ between 1 and 500, inclusive.\n* The judge responds with one line with a single integer: the total number of rings that Odin had at the end of day $\\mathbf{D}$, modulo $2^{63}$. If you send invalid data (e.g., a number out of range, or a malformed line), the judge instead responds with -1.\n\nAfter between 0 and $\\mathbf{W}$ exchanges as explained above, you must perform one more exchange of the following form:\n\n* Your program outputs one line with six integers $\\mathbf{R}_1$, $\\mathbf{R}_2$, $\\mathbf{R}_3$, $\\mathbf{R}_4$, $\\mathbf{R}_5$, $\\mathbf{R}_6$, where $\\mathbf{R}_i$ represents the number of i-day rings that Odin had at the end of day 0.\n* The judge responds with one line with a single integer: 1 if your answer is correct, and -1 if it is not (or you have provided a malformed line).\n\nAfter the judge sends -1 to your input stream (because of either invalid data or an incorrect answer), it will not send any other output. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nThis interaction corresponds to Test set 1. Suppose that, unbeknownst to us, the judge has decided that Odin had one ring of each of the six types at the end of day 0.\n\n```\n  t, w = readline_int_list()   // Reads 50 into t and 6 into w\n  printline 3 to stdout        // Asks about day 3.\n  flush stdout\n  n = readline_int()           // Reads 15 into n.\n  printline 1 to stdout        // Asks about day 1.\n  flush stdout\n  n = readline_int()           // Reads 7 into n.\n  printline 1 1 1 3 0 0 to stdout\n  flush stdout                 // We make a guess even though we could have\n                               // queried the well up to four more times.\n  verdict = readline_int()     // Reads -1 into verdict (judge has decided our\n                               //   solution is incorrect)\n  exit                         // Exits to avoid an ambiguous TLE error\n```\n\nNotice that even though the guess was consistent with the information we received from the judge, we were still wrong because we did not find the correct values.\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leq T \\leq 50$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $W = 6$.\n\n**Test set 2 (21 Pts, Hidden)**\n\n- $W = 2$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1B] Draupnir", "background": null, "description": "奥丁拥有一些能够自我复制的魔法戒指。每个“X 天戒指”会在其诞生后的每隔 $X$ 天生产一个同样的 X 天戒指。这些戒指共有六种类型：1 天、2 天、……，一直到 6 天。\n\n例如，一个在第 0 天诞生的 3 天戒指，在第 3 天才会产生另一个 3 天戒指。然后在第 6 天，这两个戒指都会各自再产生一个 3 天戒指，以此类推。\n\n你知道奥丁在第 0 天之前没有任何戒指。在第 0 天，有一些戒指诞生了。在第 0 天结束时，奥丁拥有 $R_i$ 个 $i$ 天戒指，其中 $1 \\leqslant i \\leqslant 6$。你知道 $0 \\leqslant R_i \\leqslant 100$，且至少有一个 $R_i$ 是正数。\n\n幸运的是，你还可以使用知识之井。每次使用时，你可以得知奥丁在某一天（第 1 天到第 500 天之间，包含端点）结束时拥有的戒指总数。由于知识之井的信息容量有限，答案会对 $2^{63}$ 取模。此外，每个测试用例你最多只能使用知识之井 $W$ 次。\n\n你的目标是确定奥丁在第 0 天结束时每种类型的戒指数量——也就是找出每个 $R_i$ 的值。\n\n### 交互协议\n\n这是一个交互题。\n\n最开始，你的程序应读取一行，包含两个整数 $\\mathbf{T}$（测试用例数量）和 $\\mathbf{W}$（每个测试用例允许使用知识之井的次数）。然后，你需要处理 $\\mathbf{T}$ 个测试用例。\n\n在每个测试用例中，你的程序最多可以与评测机进行 $\\mathbf{W} + 1$ 次交互。你可以进行最多 $\\mathbf{W}$ 次如下形式的交互：\n\n- 你的程序输出一行，包含一个整数 $\\mathbf{D}$，表示询问第 $\\mathbf{D}$ 天（$1 \\leqslant D \\leqslant 500$）。\n- 评测机回复一行，包含一个整数：奥丁在第 $\\mathbf{D}$ 天结束时拥有的戒指总数，对 $2^{63}$ 取模。如果你发送了无效数据（如超出范围的数字或格式错误），评测机会回复 $-1$。\n\n在上述 0 到 $\\mathbf{W}$ 次交互后，你必须再进行一次如下形式的交互：\n\n- 你的程序输出一行，包含六个整数 $\\mathbf{R}_1, \\mathbf{R}_2, \\mathbf{R}_3, \\mathbf{R}_4, \\mathbf{R}_5, \\mathbf{R}_6$，分别表示奥丁在第 0 天结束时拥有的 1 天至 6 天戒指数量。\n- 评测机回复一行，包含一个整数：如果你的答案正确，则为 $1$，否则为 $-1$（或格式错误）。\n\n当评测机向你的输入流发送 $-1$（无效数据或答案错误时），它不会再发送其他输出。如果你的程序在收到 $-1$ 后仍然等待评测机回复，将会超时（TLE）。请确保你的程序在收到 $-1$ 后及时退出，以获得 Wrong Answer 判定而不是 Time Limit Exceeded。如果超出内存限制或运行时错误，将获得相应的判定。\n\n#", "inputFormat": "见交互协议。\n\n#", "outputFormat": "见交互协议。\n\n#", "hint": "**交互样例**\n\n该交互对应于测试集 1。假设我们不知道，评测机设定奥丁在第 0 天拥有每种类型各一个戒指。\n\n```\n  t, w = readline_int_list()   // 读取 t=50, w=6\n  printline 3 to stdout        // 询问第 3 天\n  flush stdout\n  n = readline_int()           // 读取 n=15\n  printline 1 to stdout        // 询问第 1 天\n  flush stdout\n  n = readline_int()           // 读取 n=7\n  printline 1 1 1 3 0 0 to stdout\n  flush stdout                 // 我们做出猜测，尽管还可以再询问四次\n  verdict = readline_int()     // 读取 verdict=-1（评测机判定答案错误）\n  exit                         // 及时退出，避免超时\n```\n\n注意，即使我们的猜测与评测机返回的信息一致，但如果答案不正确，依然会被判错。\n\n你可以使用测试工具在本地或平台上测试。若在本地测试，需要并行运行测试工具和你的代码；你可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释。\n\n测试工具的使用说明已包含在工具的注释中。建议你添加自己的测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真实的评测系统，行为可能有所不同。\n\n**数据范围**\n\n- $1 \\leq T \\leq 50$。\n\n**测试集 1（10 分，可见）**\n\n- $W = 6$。\n\n**测试集 2（21 分，隐藏）**\n\n- $W = 2$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13111", "type": "P", "difficulty": 5, "samples": [["6\n4 0\n1 1 1 8\n8 8 8 8\n3 0\n0 1 1\n1 1 0\n1 0\n3\n3\n5 0\n0 8 0 8 0\n4 0 4 0 4\n3 0\n1 0 0\n0 1 2\n5 2\n1 2 3 4 5\n5 5 5 5 10", "Case #1: 4\nCase #2: 4\nCase #3: 1\nCase #4: 0\nCase #5: 1\nCase #6: 7"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2019", "单调栈", "Google Code Jam"], "title": "[GCJ 2019 #1B] Fair Fight", "background": "", "description": "En garde! Charles and Delila are about to face off against each other in the final fight of the Swordmaster fencing tournament.\n\nAlong one wall of the fencing arena, there is a rack with $\\mathbf{N}$ different types of swords; the swords are numbered by type, from 1 to $\\mathbf{N}$. As the head judge, you will pick a pair of integers $(L, R)$ (with $1 \\leqslant \\mathbf{L} \\leqslant \\mathbf{R} \\leqslant \\mathbf{N}$), and only the L-th through R-th types of swords (inclusive) will be available for the fight.\n\nDifferent types of sword are used in different ways, and being good with one type of sword does not necessarily mean you are good with another! Charles and Delila have skill levels of $\\mathbf{C}_i$ and $\\mathbf{D}_i$, respectively, with the i-th type of sword. Each of them will look at the types of sword you have made available for this fight, and then each will choose a type with which they are most skilled. If there are multiple available types with which a fighter is equally skilled, and that skill level exceeds the fighter's skill level in all other available types, then the fighter will make one of those equally good choices at random. Notice that it is possible for Charles and Delila to choose the same type of sword, which is fine — there are multiple copies of each type of sword available.\n\nThe fight is *fair* if the absolute difference between Charles's skill level with his chosen sword type and Delila's skill level with her chosen sword type is at most $\\mathbf{K}$. To keep the fight exciting, you'd like to know how many different pairs $(L, R)$ you can choose that will result in a fair fight.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with a line containing the two integers $\\mathbf{N}$ and $\\mathbf{K}$, as described above. Then, two more lines follow. The first of these lines contains $\\mathbf{N}$ integers $\\mathbf{C}_i$, giving Charles's skill levels for each type of sword, as described above. Similarly, the second line contains $\\mathbf{N}$ integers $\\mathbf{D}_i$, giving Delila's skill levels.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of choices you can make that result in a fair fight, as described above.", "hint": "**Sample Explanation**\n\n- In Sample Case #1, the fight is fair if and only if Charles can use the last type of sword, so the answer is $4$.\n- In Sample Case #2, there are $4$ fair fights: $(1, 2)$, $(1, 3)$, $(2, 2)$, and $(2, 3)$. Notice that for pairs like $(1, 3)$, Charles and Delila both have multiple swords they could choose that they are most skilled with; however, each pair only counts as one fair fight.\n- In Sample Case #3, there is $1$ fair fight: $(1, 1)$.\n- In Sample Case #4, there are no fair fights, so the answer is $0$.\n- In Sample Case #5, remember that the *duelists* are not trying to make the fights fair; they choose the type of sword that they are most skilled with. For example, $(1, 3)$ is not a fair fight, because Charles will choose the first type of sword, and Delila will choose the third type of sword. Delila will not go easy on Charles by choosing a weaker sword!\n- In Sample Case #6, there are $7$ fair fights: $(1, 3)$, $(1, 4)$, $(2, 3)$, $(2, 4)$, $(3, 3)$, $(3, 4)$, and $(4, 4)$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $0 \\leqslant \\mathbf{K} \\leqslant 10^5$.\n- $0 \\leqslant \\mathbf{C}_i \\leqslant 10^5$, for all $i$.\n- $0 \\leqslant \\mathbf{D}_i \\leqslant 10^5$, for all $i$.\n\n**Test set 1 (14 Pts, Visible)**\n\n- $1 \\leqslant \\mathbf{N} \\leqslant 100$.\n\n**Test set 2 (28 Pts, Hidden)**\n\n- $\\mathbf{N} = 10^5$, for exactly 8 test cases.\n- $1 \\leqslant \\mathbf{N} \\leqslant 1000$, for all but 8 test cases.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1B] Fair Fight", "background": "", "description": "En garde! Charles and Delila are about to face off against each other in the final fight of the Swordmaster fencing tournament.\n\nAlong one wall of the fencing arena, there is a rack with $\\mathbf{N}$ different types of swords; the swords are numbered by type, from 1 to $\\mathbf{N}$. As the head judge, you will pick a pair of integers $(L, R)$ (with $1 \\leqslant \\mathbf{L} \\leqslant \\mathbf{R} \\leqslant \\mathbf{N}$), and only the L-th through R-th types of swords (inclusive) will be available for the fight.\n\nDifferent types of sword are used in different ways, and being good with one type of sword does not necessarily mean you are good with another! Charles and Delila have skill levels of $\\mathbf{C}_i$ and $\\mathbf{D}_i$, respectively, with the i-th type of sword. Each of them will look at the types of sword you have made available for this fight, and then each will choose a type with which they are most skilled. If there are multiple available types with which a fighter is equally skilled, and that skill level exceeds the fighter's skill level in all other available types, then the fighter will make one of those equally good choices at random. Notice that it is possible for Charles and Delila to choose the same type of sword, which is fine — there are multiple copies of each type of sword available.\n\nThe fight is *fair* if the absolute difference between Charles's skill level with his chosen sword type and Delila's skill level with her chosen sword type is at most $\\mathbf{K}$. To keep the fight exciting, you'd like to know how many different pairs $(L, R)$ you can choose that will result in a fair fight.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with a line containing the two integers $\\mathbf{N}$ and $\\mathbf{K}$, as described above. Then, two more lines follow. The first of these lines contains $\\mathbf{N}$ integers $\\mathbf{C}_i$, giving Charles's skill levels for each type of sword, as described above. Similarly, the second line contains $\\mathbf{N}$ integers $\\mathbf{D}_i$, giving Delila's skill levels.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of choices you can make that result in a fair fight, as described above.", "hint": "**Sample Explanation**\n\n- In Sample Case #1, the fight is fair if and only if Charles can use the last type of sword, so the answer is $4$.\n- In Sample Case #2, there are $4$ fair fights: $(1, 2)$, $(1, 3)$, $(2, 2)$, and $(2, 3)$. Notice that for pairs like $(1, 3)$, Charles and Delila both have multiple swords they could choose that they are most skilled with; however, each pair only counts as one fair fight.\n- In Sample Case #3, there is $1$ fair fight: $(1, 1)$.\n- In Sample Case #4, there are no fair fights, so the answer is $0$.\n- In Sample Case #5, remember that the *duelists* are not trying to make the fights fair; they choose the type of sword that they are most skilled with. For example, $(1, 3)$ is not a fair fight, because Charles will choose the first type of sword, and Delila will choose the third type of sword. Delila will not go easy on Charles by choosing a weaker sword!\n- In Sample Case #6, there are $7$ fair fights: $(1, 3)$, $(1, 4)$, $(2, 3)$, $(2, 4)$, $(3, 3)$, $(3, 4)$, and $(4, 4)$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $0 \\leqslant \\mathbf{K} \\leqslant 10^5$.\n- $0 \\leqslant \\mathbf{C}_i \\leqslant 10^5$, for all $i$.\n- $0 \\leqslant \\mathbf{D}_i \\leqslant 10^5$, for all $i$.\n\n**Test set 1 (14 Pts, Visible)**\n\n- $1 \\leqslant \\mathbf{N} \\leqslant 100$.\n\n**Test set 2 (28 Pts, Hidden)**\n\n- $\\mathbf{N} = 10^5$, for exactly 8 test cases.\n- $1 \\leqslant \\mathbf{N} \\leqslant 1000$, for all but 8 test cases.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1B] Fair Fight", "background": null, "description": "准备好！Charles 和 Delila 即将在剑术大师击剑锦标赛的决赛中一决高下。\n\n在击剑场的一面墙上，有一个剑架，上面放着 $N$ 种不同类型的剑；这些剑按照类型编号，从 $1$ 到 $N$。作为主裁判，你将选择一对整数 $(L, R)$（满足 $1 \\leqslant L \\leqslant R \\leqslant N$），只有第 $L$ 种到第 $R$ 种（包含两端）的剑可以用于本场比赛。\n\n不同类型的剑使用方式各异，擅长一种剑并不意味着擅长另一种！Charles 和 Delila 分别对第 $i$ 种剑的熟练度为 $C_i$ 和 $D_i$。他们会查看你为本场比赛指定的可用剑的类型，然后各自选择自己最擅长的一种剑。如果有多种可用类型的剑熟练度相同，且该熟练度高于其他所有可用类型，则选手会在这些同样擅长的类型中随机选择一种。注意，Charles 和 Delila 可能会选择同一种剑，这没有问题——每种剑有多把可用。\n\n如果 Charles 选择的剑类型的熟练度与 Delila 选择的剑类型的熟练度之差的绝对值不超过 $K$，则这场比赛是“公平”的。为了让比赛更精彩，你想知道有多少种不同的 $(L, R)$ 选择会导致一场公平的比赛。", "inputFormat": "第一行输入测试用例的数量 $T$。接下来有 $T$ 组测试用例。每组测试用例的第一行包含两个整数 $N$ 和 $K$，含义如上所述。接下来两行，每行包含 $N$ 个整数。第一行为 $C_i$，表示 Charles 对每种剑的熟练度。第二行为 $D_i$，表示 Delila 对每种剑的熟练度。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是能导致公平比赛的 $(L, R)$ 选择的数量。", "hint": "**样例解释**\n\n- 样例 1 中，只有当 Charles 能使用最后一种剑时，比赛才是公平的，所以答案是 $4$。\n- 样例 2 中，有 $4$ 种公平的比赛区间：$(1, 2)$、$(1, 3)$、$(2, 2)$ 和 $(2, 3)$。注意，对于像 $(1, 3)$ 这样的区间，Charles 和 Delila 都有多种最擅长的剑可以选择；但每个区间只计为一次公平比赛。\n- 样例 3 中，只有 $1$ 种公平比赛：$(1, 1)$。\n- 样例 4 中，没有公平比赛，所以答案是 $0$。\n- 样例 5 中，要注意选手不会为了让比赛公平而选择较弱的剑。例如 $(1, 3)$ 不是公平比赛，因为 Charles 会选择第一种剑，Delila 会选择第三种剑。Delila 不会为了照顾 Charles 而选择较弱的剑！\n- 样例 6 中，有 $7$ 种公平比赛区间：$(1, 3)$、$(1, 4)$、$(2, 3)$、$(2, 4)$、$(3, 3)$、$(3, 4)$ 和 $(4, 4)$。\n\n**数据范围**\n\n- $1 \\leqslant T \\leqslant 100$。\n- $0 \\leqslant K \\leqslant 10^5$。\n- $0 \\leqslant C_i \\leqslant 10^5$，对于所有 $i$。\n- $0 \\leqslant D_i \\leqslant 10^5$，对于所有 $i$。\n\n**测试点 1（14 分，公开）**\n\n- $1 \\leqslant N \\leqslant 100$。\n\n**测试点 2（28 分，隐藏）**\n\n- 有 8 个测试用例满足 $N = 10^5$。\n- 除这 8 个测试用例外，其余均满足 $1 \\leqslant N \\leqslant 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13112", "type": "P", "difficulty": 4, "samples": [["3\n1\nRS\n3\nR\nP\nS\n7\nRS\nRS\nRS\nRS\nRS\nRS\nRS", "Case #1: RSRSRSP\nCase #2: IMPOSSIBLE\nCase #3: P"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "2019", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 #1C] Robot Programming Strategy", "background": "", "description": "After many sleepless nights, you have finally finished teaching a robotic arm to make the hand gestures required for the Rock-Paper-Scissors game. Now you just need to program it to compete in the upcoming robot tournament!\n\nIn this tournament, each robot uses a program that is a series of moves, each of which must be one of the following: R (for \"Rock\"), P (for \"Paper\"), or S (for \"Scissors\"). Paper beats Rock and loses to Scissors; Rock beats Scissors and loses to Paper; Scissors beats Paper and loses to Rock.\n\nWhen two robots face off in a match, the first robot to play a winning move wins. To start, each robot plays the first move of its program. If the two moves are different, one of the moves beats the other and thus one of the robots wins the match. If the moves are the same, each robot plays the next move in its program, and so on.\n\nWhenever a robot has reached the end of its program and needs its next move, it returns to the start of its program. So, for example, the fifth move of a robot with the program RSSP would be R. If a match goes on for over a googol ($10^{100}$) of moves, the judges flip a fair coin to determine the winner.\n\nOnce a match is over, the winning robot resets, so it has no memory of that match. In its next match, it starts by playing the first move of its program, and so on.\n\nThe tournament is played in K rounds and has a single-elimination \"bracket\" structure. There are N = $2^K$ robots in total, numbered 0 through N - 1. In the first round, robot 0 plays a match against robot 1, robot 2 plays a match against robot 3, and so on, up to robots N - 2 and N - 1. The losers of those matches are eliminated from the tournament. In the second round, the winner of the 0-1 match faces off against the winner of the 2-3 match, and so on. Once we get to the K-th round, there is only one match, and it determines the overall winner of the tournament.\n\nAll of the other contestants are so confident that they have already publicly posted their robots' programs online. However, the robots have not yet been assigned numbers, so nobody knows in advance who their opponents will be. Knowing all of the other programs, is it possible for you to write a program that is guaranteed to win the tournament, no matter how the robot numbers are assigned?", "inputFormat": "The first line of the input gives the number of test cases, $T$; $T$ test cases follow. Each test case begins with one line containing an integer $A$: the number of adversaries (other robots) in the tournament. Then, there are $A$ more lines; the i-th of these contains a string $C_i$ of uppercase letters that represent the program of the i-th opponent's robot.", "outputFormat": "For each test case, output one line containing `Case #x: y`. If there is a string of between 1 and 500 characters that is guaranteed to win the tournament, as described above, then $y$ should be the string of uppercase letters representing that program. Otherwise, $y$ should be IMPOSSIBLE, in uppercase letters.", "hint": "**Sample Explanation**\n\nNote: Although all the opponents in each of these sample cases have programs of the same length, this is not necessarily the case. Opponents within a test case might have programs of different lengths.\n\nIn Sample Case #1, there is only one opponent, with the program RS. Our answer matches the opponent's moves for a while, and the opponent loops through its program several times. As is starts its fourth pass through its program, we beat it with P. Other valid solutions exist, like P, RR, and R.\n\nIn Sample Case #2, there are three opponents, with the programs R, P, and S. It is up to you to figure out why this case is IMPOSSIBLE!\n\nIn Sample Case #3, all seven opponents use the same program. Using the program P, for example, guarantees that you will win. Remember that each robot begins at the start of its program at the start of each match against a new opponent.\n\n**Limits**\n\n- $1 \\leqslant T \\leqslant 100 .$\n- Each character in $\\mathbf{C}_{\\mathbf{i}}$ is uppercase $\\mathbf{R}, \\mathbf{P}$, or $\\mathbf{s}$, for all $\\mathbf{i}$.\n- $\\mathbf{A}=2^{\\mathbf{K}}-1$ for some integer $\\mathbf{K} \\geqslant 1$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $1 \\leqslant \\mathbf{A} \\leqslant 7$.\n- $\\mathbf{C}_{\\mathbf{i}}$ is between 1 and 5 characters long, for all $\\mathbf{i}$.\n\n**Test set 2 (18 Pts, Hidden)**\n\n- $1 \\leqslant \\mathbf{A} \\leqslant 255$.\n- $\\mathbf{C}_{\\mathbf{i}}$ is between 1 and 500 characters long, for all $\\mathbf{i}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1C] Robot Programming Strategy", "background": "", "description": "After many sleepless nights, you have finally finished teaching a robotic arm to make the hand gestures required for the Rock-Paper-Scissors game. Now you just need to program it to compete in the upcoming robot tournament!\n\nIn this tournament, each robot uses a program that is a series of moves, each of which must be one of the following: R (for \"Rock\"), P (for \"Paper\"), or S (for \"Scissors\"). Paper beats Rock and loses to Scissors; Rock beats Scissors and loses to Paper; Scissors beats Paper and loses to Rock.\n\nWhen two robots face off in a match, the first robot to play a winning move wins. To start, each robot plays the first move of its program. If the two moves are different, one of the moves beats the other and thus one of the robots wins the match. If the moves are the same, each robot plays the next move in its program, and so on.\n\nWhenever a robot has reached the end of its program and needs its next move, it returns to the start of its program. So, for example, the fifth move of a robot with the program RSSP would be R. If a match goes on for over a googol ($10^{100}$) of moves, the judges flip a fair coin to determine the winner.\n\nOnce a match is over, the winning robot resets, so it has no memory of that match. In its next match, it starts by playing the first move of its program, and so on.\n\nThe tournament is played in K rounds and has a single-elimination \"bracket\" structure. There are N = $2^K$ robots in total, numbered 0 through N - 1. In the first round, robot 0 plays a match against robot 1, robot 2 plays a match against robot 3, and so on, up to robots N - 2 and N - 1. The losers of those matches are eliminated from the tournament. In the second round, the winner of the 0-1 match faces off against the winner of the 2-3 match, and so on. Once we get to the K-th round, there is only one match, and it determines the overall winner of the tournament.\n\nAll of the other contestants are so confident that they have already publicly posted their robots' programs online. However, the robots have not yet been assigned numbers, so nobody knows in advance who their opponents will be. Knowing all of the other programs, is it possible for you to write a program that is guaranteed to win the tournament, no matter how the robot numbers are assigned?", "inputFormat": "The first line of the input gives the number of test cases, $T$; $T$ test cases follow. Each test case begins with one line containing an integer $A$: the number of adversaries (other robots) in the tournament. Then, there are $A$ more lines; the i-th of these contains a string $C_i$ of uppercase letters that represent the program of the i-th opponent's robot.", "outputFormat": "For each test case, output one line containing `Case #x: y`. If there is a string of between 1 and 500 characters that is guaranteed to win the tournament, as described above, then $y$ should be the string of uppercase letters representing that program. Otherwise, $y$ should be IMPOSSIBLE, in uppercase letters.", "hint": "**Sample Explanation**\n\nNote: Although all the opponents in each of these sample cases have programs of the same length, this is not necessarily the case. Opponents within a test case might have programs of different lengths.\n\nIn Sample Case #1, there is only one opponent, with the program RS. Our answer matches the opponent's moves for a while, and the opponent loops through its program several times. As is starts its fourth pass through its program, we beat it with P. Other valid solutions exist, like P, RR, and R.\n\nIn Sample Case #2, there are three opponents, with the programs R, P, and S. It is up to you to figure out why this case is IMPOSSIBLE!\n\nIn Sample Case #3, all seven opponents use the same program. Using the program P, for example, guarantees that you will win. Remember that each robot begins at the start of its program at the start of each match against a new opponent.\n\n**Limits**\n\n- $1 \\leqslant T \\leqslant 100 .$\n- Each character in $\\mathbf{C}_{\\mathbf{i}}$ is uppercase $\\mathbf{R}, \\mathbf{P}$, or $\\mathbf{s}$, for all $\\mathbf{i}$.\n- $\\mathbf{A}=2^{\\mathbf{K}}-1$ for some integer $\\mathbf{K} \\geqslant 1$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $1 \\leqslant \\mathbf{A} \\leqslant 7$.\n- $\\mathbf{C}_{\\mathbf{i}}$ is between 1 and 5 characters long, for all $\\mathbf{i}$.\n\n**Test set 2 (18 Pts, Hidden)**\n\n- $1 \\leqslant \\mathbf{A} \\leqslant 255$.\n- $\\mathbf{C}_{\\mathbf{i}}$ is between 1 and 500 characters long, for all $\\mathbf{i}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1C] Robot Programming Strategy", "background": null, "description": "经过无数个不眠之夜，你终于教会了机械臂做出石头剪刀布游戏所需的手势。现在你只需要编写程序，让它在即将到来的机器人锦标赛中参赛！\n\n在本次锦标赛中，每个机器人都使用一个程序，该程序是一系列动作，每个动作必须是以下三者之一：R（代表“石头”）、P（代表“布”）或 S（代表“剪刀”）。布胜石头，输给剪刀；石头胜剪刀，输给布；剪刀胜布，输给石头。\n\n当两个机器人进行对决时，先出制胜动作的机器人获胜。比赛开始时，每个机器人出程序中的第一个动作。如果两个动作不同，其中一个动作会击败另一个动作，从而有一个机器人获胜。如果两个动作相同，则每个机器人出程序中的下一个动作，依此类推。\n\n每当一个机器人走到程序末尾需要下一个动作时，它会回到程序的开头。例如，程序为 RSSP 的机器人，第五步将是 R。如果一场比赛持续超过一个 googol（$10^{100}$）步，裁判会抛硬币决定胜者。\n\n一场比赛结束后，获胜的机器人会重置，因此它不会记得这场比赛。在下一场比赛中，它会从程序的第一个动作开始，依此类推。\n\n锦标赛共进行 $K$ 轮，采用单败淘汰“对阵表”结构。共有 $N=2^K$ 个机器人，编号为 $0$ 到 $N-1$。第一轮中，机器人 $0$ 对阵机器人 $1$，机器人 $2$ 对阵机器人 $3$，以此类推，直到机器人 $N-2$ 和 $N-1$。这些比赛的失败者被淘汰。第二轮中，$0-1$ 比赛的胜者对阵 $2-3$ 比赛的胜者，依此类推。到第 $K$ 轮时，只剩下一场比赛，决定锦标赛的总冠军。\n\n其他参赛者都非常自信，已经在网上公开了他们机器人的程序。然而，机器人编号尚未分配，因此没人提前知道对手是谁。已知所有其他机器人的程序，你能否编写一个程序，无论机器人编号如何分配，都能保证你赢得锦标赛？", "inputFormat": "输入的第一行给出测试用例数 $T$；接下来是 $T$ 组测试数据。每组测试数据的第一行包含一个整数 $A$，表示锦标赛中对手（其他机器人）的数量。接下来有 $A$ 行，第 $i$ 行包含一个字符串 $C_i$，表示第 $i$ 个对手机器人的程序，由大写字母组成。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`。如果存在一个长度在 $1$ 到 $500$ 之间的字符串，能保证你赢得锦标赛，则 $y$ 应为表示该程序的大写字母字符串。否则，$y$ 应为大写字母 `IMPOSSIBLE`。", "hint": "**样例说明**\n\n注意：虽然每个样例中所有对手的程序长度相同，但实际情况并非如此。一个测试用例中的对手程序长度可能不同。\n\n在样例 1 中，只有一个对手，程序为 RS。我们的答案在一段时间内与对手的动作相同，对手的程序循环多次。当对手开始第四次循环时，我们用 P 击败了它。其他有效答案还包括 P、RR 和 R。\n\n在样例 2 中，有三个对手，程序分别为 R、P 和 S。你需要自己思考为什么这个用例的答案是 IMPOSSIBLE！\n\n在样例 3 中，所有七个对手都使用相同的程序。例如，使用程序 P 可以保证你获胜。记住，每次对阵新对手时，每个机器人都会从程序的第一个动作开始。\n\n**数据范围**\n\n- $1 \\leqslant T \\leqslant 100$。\n- 每个 $\\mathbf{C}_i$ 的每个字符均为大写字母 $\\mathbf{R}$、$\\mathbf{P}$ 或 $\\mathbf{S}$。\n- $\\mathbf{A}=2^{\\mathbf{K}}-1$，其中整数 $\\mathbf{K} \\geqslant 1$。\n\n**测试点 1（10 分，可见）**\n\n- $1 \\leqslant \\mathbf{A} \\leqslant 7$。\n- 每个 $\\mathbf{C}_i$ 的长度为 $1$ 到 $5$。\n\n**测试点 2（18 分，隐藏）**\n\n- $1 \\leqslant \\mathbf{A} \\leqslant 255$。\n- 每个 $\\mathbf{C}_i$ 的长度为 $1$ 到 $500$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13113", "type": "P", "difficulty": 4, "samples": [["", ""]], "limits": {"time": [40000, 40000], "memory": [1048576, 1048576]}, "tags": ["2019", "交互题", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 #1C] Power Arrangers", "background": "", "description": "Go, go, Power Arrangers! Everyone loves this team of five superhero high school students who wear the letters A, B, C, D, and E. When they stand side by side to confront evil monsters, they arrange their team in one of 120 possible different left-to-right orders, giving them various different tactical superpowers. They are even more popular than the Teenage Permutant Ninja Turtles!\n\nSome critics of the show claim that the team only has its arrangement gimmick so that the owners of the show can sell 120 separate sets of 5 action figures, each of which features the team in a different left-to-right order, glued to a base so that the set cannot be rearranged. As an avid Power Arrangers fan, you have collected 119 of these sets, but you do not remember which set you are missing. Your 119 sets are lined up horizontally along a shelf, such that there are a total of $119 \\times 5 = 595$ action figures in left-to-right order. You do not remember how the sets are arranged, but you know that the permutation of the sets is selected uniformly at random from all possible permutations, and independently for each case.\n\nYou do not want to waste any time figuring out which set you are missing, so you plan to look at the letters on at most $\\mathbf{F}$ figures on the shelf. For instance, you might choose to look at the letter on the eighth figure from the left, which would be the third figure from the left in the second set from the left. When looking at a figure, you only get the letter from that one figure; the letters are hard to see, and the different team members look very similar otherwise!\n\nAfter checking at most $\\mathbf{F}$ figures, you must figure out which of the sets is missing, so you can complete your collection and be ready to face any possible evil threat!\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing two integers $\\mathbf{T}$, the number of test cases, and $\\mathbf{F}$, the number of figures you are allowed to inspect per test case. Then, you need to process $\\mathbf{T}$ test cases.\n\nWithin each test case, the missing set of figures is chosen uniformly at random from all possible sets, and the order of the remaining sets is chosen uniformly at random from all possible orders as well. Every choice is made independently of all other choices and of your inputs.\n\nIn each test case, your program will process up to $\\mathbf{F} + 1$ exchanges with our judge. You may make up to $\\mathbf{F}$ exchanges of the following form:\n\n* Your program outputs one line containing a single integer between 1 and 595, inclusive, indicating which figure (in left-to-right order along the shelf) you wish to look at. As a further example, 589 would represent the fourth figure from the left in the second set from the right.\n* The judge responds with one line containing a single uppercase letter A, B, C, D, or E, indicating the letter on that figure. If you sent invalid data (e.g., a number out of range, or a malformed line), the judge will instead respond with one line containing the single uppercase letter N.\n\nThen, after you have made as many of the $\\mathbf{F}$ exchanges above as you want, you must make one more exchange of the following form:\n\n* Your program outputs one line containing a single string of five uppercase letters: the permutation corresponding to the missing set (e.g., CADBE).\n* The judge responds with one line containing a single uppercase letter: Y if your answer was correct, and N if it was not (or you provided a malformed line). If you receive Y, you should begin the next test case, or stop sending input if there are no more test cases.\n\nAfter the judge sends N to your input stream (because of either invalid data or an incorrect answer), it will not send any other output. If your program continues to wait for the judge after receiving N, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "This interaction corresponds to Test set 1.\n\n```\n  t, f = readline_int_list()   // Reads 50 into t and 475 into f\n  printline 10 to stdout       // Looks at the last figure in the second set\n                               // from the left\n  flush stdout\n  n = readline_string()        // Reads B into n. Ooh, team member B! They may\n                               // not have the leadership ability of A, or the\n                               // technical skill of C, but they entertain the\n                               // team with clever quips!\n  printline 11 to stdout       // Looks at the first figure in the third set\n                               // from the left\n  flush stdout\n  n = readline_string()        // Reads B into n. Notice that B is at the start\n                               // of the third set, whereas they were at the\n                               // end of the second set.\n  printline 14 to stdout       // Looks at the fourth figure in the third set\n                               // from the left\n  flush stdout\n  n = readline_string()        // Reads D into n. Silent and brooding, team\n                               // member D nonetheless fights fiercely to\n                               // protect their friends... and the world!\n  printline ABCDE to stdout    // We foolishly make a wild guess even though we\n                               // could have looked at up to 472 more figures.\n  flush stdout\n  verdict = readline_string()  // Reads N into verdict (judge has decided our\n                               //   solution is incorrect)\n  exit                         // Exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 50$.\n- The missing set, and the order of the remaining sets, are chosen uniformly and independently at random.\n\n**Test set 1 (11 Pts, Visible)**\n\n- $\\mathbf{F} = 475$.\n\n**Test set 2 (21 Pts, Hidden)**\n\n- $\\mathbf{F} = 150$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1C] Power Arrangers", "background": "", "description": "Go, go, Power Arrangers! Everyone loves this team of five superhero high school students who wear the letters A, B, C, D, and E. When they stand side by side to confront evil monsters, they arrange their team in one of 120 possible different left-to-right orders, giving them various different tactical superpowers. They are even more popular than the Teenage Permutant Ninja Turtles!\n\nSome critics of the show claim that the team only has its arrangement gimmick so that the owners of the show can sell 120 separate sets of 5 action figures, each of which features the team in a different left-to-right order, glued to a base so that the set cannot be rearranged. As an avid Power Arrangers fan, you have collected 119 of these sets, but you do not remember which set you are missing. Your 119 sets are lined up horizontally along a shelf, such that there are a total of $119 \\times 5 = 595$ action figures in left-to-right order. You do not remember how the sets are arranged, but you know that the permutation of the sets is selected uniformly at random from all possible permutations, and independently for each case.\n\nYou do not want to waste any time figuring out which set you are missing, so you plan to look at the letters on at most $\\mathbf{F}$ figures on the shelf. For instance, you might choose to look at the letter on the eighth figure from the left, which would be the third figure from the left in the second set from the left. When looking at a figure, you only get the letter from that one figure; the letters are hard to see, and the different team members look very similar otherwise!\n\nAfter checking at most $\\mathbf{F}$ figures, you must figure out which of the sets is missing, so you can complete your collection and be ready to face any possible evil threat!\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing two integers $\\mathbf{T}$, the number of test cases, and $\\mathbf{F}$, the number of figures you are allowed to inspect per test case. Then, you need to process $\\mathbf{T}$ test cases.\n\nWithin each test case, the missing set of figures is chosen uniformly at random from all possible sets, and the order of the remaining sets is chosen uniformly at random from all possible orders as well. Every choice is made independently of all other choices and of your inputs.\n\nIn each test case, your program will process up to $\\mathbf{F} + 1$ exchanges with our judge. You may make up to $\\mathbf{F}$ exchanges of the following form:\n\n* Your program outputs one line containing a single integer between 1 and 595, inclusive, indicating which figure (in left-to-right order along the shelf) you wish to look at. As a further example, 589 would represent the fourth figure from the left in the second set from the right.\n* The judge responds with one line containing a single uppercase letter A, B, C, D, or E, indicating the letter on that figure. If you sent invalid data (e.g., a number out of range, or a malformed line), the judge will instead respond with one line containing the single uppercase letter N.\n\nThen, after you have made as many of the $\\mathbf{F}$ exchanges above as you want, you must make one more exchange of the following form:\n\n* Your program outputs one line containing a single string of five uppercase letters: the permutation corresponding to the missing set (e.g., CADBE).\n* The judge responds with one line containing a single uppercase letter: Y if your answer was correct, and N if it was not (or you provided a malformed line). If you receive Y, you should begin the next test case, or stop sending input if there are no more test cases.\n\nAfter the judge sends N to your input stream (because of either invalid data or an incorrect answer), it will not send any other output. If your program continues to wait for the judge after receiving N, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "This interaction corresponds to Test set 1.\n\n```\n  t, f = readline_int_list()   // Reads 50 into t and 475 into f\n  printline 10 to stdout       // Looks at the last figure in the second set\n                               // from the left\n  flush stdout\n  n = readline_string()        // Reads B into n. Ooh, team member B! They may\n                               // not have the leadership ability of A, or the\n                               // technical skill of C, but they entertain the\n                               // team with clever quips!\n  printline 11 to stdout       // Looks at the first figure in the third set\n                               // from the left\n  flush stdout\n  n = readline_string()        // Reads B into n. Notice that B is at the start\n                               // of the third set, whereas they were at the\n                               // end of the second set.\n  printline 14 to stdout       // Looks at the fourth figure in the third set\n                               // from the left\n  flush stdout\n  n = readline_string()        // Reads D into n. Silent and brooding, team\n                               // member D nonetheless fights fiercely to\n                               // protect their friends... and the world!\n  printline ABCDE to stdout    // We foolishly make a wild guess even though we\n                               // could have looked at up to 472 more figures.\n  flush stdout\n  verdict = readline_string()  // Reads N into verdict (judge has decided our\n                               //   solution is incorrect)\n  exit                         // Exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 50$.\n- The missing set, and the order of the remaining sets, are chosen uniformly and independently at random.\n\n**Test set 1 (11 Pts, Visible)**\n\n- $\\mathbf{F} = 475$.\n\n**Test set 2 (21 Pts, Hidden)**\n\n- $\\mathbf{F} = 150$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1C] Power Arrangers", "background": null, "description": "Go, go, Power Arrangers！每个人都喜欢这支由五名高中生超级英雄组成的团队，他们分别佩戴字母 A、B、C、D 和 E。当他们并肩站立对抗邪恶怪兽时，会以 120 种不同的从左到右的排列方式排列队伍，从而获得各种不同的战术超能力。他们甚至比“忍者神龟”还要受欢迎！\n\n一些评论家认为，这个团队之所以有排列的噱头，只是为了让节目拥有者能够售卖 120 套不同的 5 人手办，每一套都以不同的从左到右顺序固定在底座上，无法重新排列。作为一名狂热的 Power Arrangers 粉丝，你已经收集了其中的 119 套，但你不记得自己缺少哪一套。你的 119 套手办水平排列在书架上，总共有 $119 \\times 5 = 595$ 个手办，按从左到右的顺序排列。你不记得这些套装的排列顺序，但你知道这些套装的排列是从所有可能的排列中等概率随机选择的，并且每种情况都是独立的。\n\n你不想浪费时间去找出自己缺少哪一套，因此你计划最多查看 $\\mathbf{F}$ 个手办上的字母。例如，你可以选择查看从左数第八个手办上的字母，这就是从左数第二套中的第三个手办。当你查看一个手办时，你只能获得该手办上的字母；这些字母很难看清，而且不同的队员外观非常相似！\n\n在最多检查 $\\mathbf{F}$ 个手办后，你必须判断出缺少的是哪一套，这样你才能完成你的收藏，随时准备对抗任何邪恶威胁！\n\n### 交互协议\n\n这是一个交互题。\n\n最开始，你的程序应读取一行，包含两个整数 $\\mathbf{T}$（测试用例数量）和 $\\mathbf{F}$（每个测试用例允许检查的手办数量）。然后，你需要处理 $\\mathbf{T}$ 个测试用例。\n\n在每个测试用例中，缺失的那套手办会从所有可能的套装中等概率随机选择，剩下套装的排列顺序也会从所有可能的顺序中等概率随机选择。每一次选择都是独立的。\n\n在每个测试用例中，你最多可以与评测器进行 $\\mathbf{F} + 1$ 次交互。你可以进行最多 $\\mathbf{F}$ 次如下形式的交互：\n\n- 你的程序输出一行，包含一个介于 1 到 595 之间的整数，表示你想查看的手办（从左到右编号）。例如，589 表示从右数第二套中的第四个手办。\n- 评测器会回复一行，包含一个大写字母 A、B、C、D 或 E，表示该手办上的字母。如果你发送了无效数据（例如，超出范围的数字或格式错误的行），评测器会回复一行，内容为大写字母 N。\n\n在你完成最多 $\\mathbf{F}$ 次上述交互后，你还必须进行一次如下形式的交互：\n\n- 你的程序输出一行，包含一个由五个大写字母组成的字符串，表示缺失套装的排列（例如，CADBE）。\n- 评测器会回复一行，内容为一个大写字母：如果你的答案正确，则为 Y，否则为 N（或格式错误时也为 N）。如果你收到 Y，应开始下一个测试用例；如果没有更多测试用例，则停止输入。\n\n如果评测器向你的输入流发送了 N（因为无效数据或答案错误），它将不会再发送任何输出。如果你的程序在收到 N 后继续等待评测器回复，将会超时，导致 Time Limit Exceeded 错误。请注意，你有责任让程序及时退出，以获得 Wrong Answer 判定，而不是 Time Limit Exceeded。如果超出内存限制或程序运行时出错，将会收到相应的判定。\n\n如常规，若超出内存限制或程序运行时出错，将会收到相应的判定。\n\n你可以使用本地测试工具进行测试。要在本地测试，你需要让测试工具与你的代码并行运行；你可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释说明。\n\n测试工具的使用说明已包含在工具的注释中。我们鼓励你添加自己的测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真实的评测系统，可能会有不同的表现。\n\n**限制条件**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 50$。\n- 缺失的套装和剩余套装的顺序均为等概率独立随机选择。\n\n**测试点 1（11 分，可见）**\n\n- $\\mathbf{F} = 475$。\n\n**测试点 2（21 分，隐藏）**\n\n- $\\mathbf{F} = 150$。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "本交互对应测试点 1。\n\n```\n  t, f = readline_int_list()   // 读取 t=50, f=475\n  printline 10 to stdout       // 查看从左数第二套中的最后一个手办\n  flush stdout\n  n = readline_string()        // 读取 n=B。哦，队员 B！虽然他没有 A 的领导力，也没有 C 的技术能力，但他用机智的俏皮话娱乐着团队！\n  printline 11 to stdout       // 查看从左数第三套中的第一个手办\n  flush stdout\n  n = readline_string()        // 读取 n=B。注意，B 在第三套的开头，而在第二套的结尾。\n  printline 14 to stdout       // 查看从左数第三套中的第四个手办\n  flush stdout\n  n = readline_string()        // 读取 n=D。沉默寡言的 D，虽然性格内敛，但为了保护朋友和世界而英勇战斗！\n  printline ABCDE to stdout    // 我们鲁莽地猜测，尽管还可以再查看 472 个手办。\n  flush stdout\n  verdict = readline_string()  // 读取 verdict=N（评测器判定我们的答案错误）\n  exit                         // 退出，避免出现超时错误\n```\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13114", "type": "P", "difficulty": 6, "samples": [["5\n2 2\n..\n.#\n4 4\n.#..\n..#.\n#...\n...#\n3 4\n#.##\n....\n#.##\n1 1\n.\n1 2\n##", "Case #1: 0\nCase #2: 0\nCase #3: 7\nCase #4: 2\nCase #5: 0"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["博弈论", "2019", "SG 函数", "Google Code Jam"], "title": "[GCJ 2019 #1C] Bacterial Tactics", "background": "", "description": "Becca and Terry are microbiologists who have a friendly rivalry. When they need a break from their research, they like to play a game together. The game is played on a matrix of unit cells with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. Initially, each cell is either empty, or contains radioactive material.\n\nOn each player's turn, if there are no empty cells in the matrix, that player loses the game. Otherwise, they choose an empty cell and place a colony of bacteria there. Bacteria colonies come in two types: H (for \"horizontal\") and V (for \"vertical\").\n\n* When a type H colony is placed into an empty cell, it occupies that cell (making it non-empty), and also tries to spread into the cell immediately to the west (if there is one) and the cell immediately to the east (if there is one).\n* When a type V colony is placed into an empty cell, it occupies that cell (making it non-empty), and also tries to spread into the cell immediately to the south (if there is one) and the cell immediately to the north (if there is one).\n\nWhenever a colony (of either type) tries to spread into a cell:\n\n* If the cell contains radioactive material, the colony mutates and the player who placed the colony loses the game.\n* If that cell is empty, the colony occupies that cell (making it non-empty), and then the rule above is triggered again (i.e. the colony will try to spread further).\n* If the cell already contains bacteria (of any type), the colony does not spread into that cell.\n\nNotice that it may be possible that all of a player's available moves would cause them to lose the game, and so they are doomed. See the sample case explanations below for examples of how the game works.\n\nBecca makes the first move, and then the two players alternate moves until one of them loses the game. If both players play optimally, who will win? And, if Becca will win, how many distinct winning opening moves does she have? (Two opening moves are distinct if and only if they either use different cells, or different kinds of colony, or both.)\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line containing two integers $\\mathbf{R}$ and $\\mathbf{C}$: the number of rows and columns, respectively, in the matrix. Then, there are $\\mathbf{R}$ more rows of $\\mathbf{C}$ characters each. The j-th character on the i-th of these lines represents the j-th column of the i-th row of the matrix. Each character is either . (an empty cell) or # (a cell with radioactive material).\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1), and $y$ is an integer: either 0 if Becca will not win, or, if Becca will win, the number of distinct winning opening moves she can make, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, Becca cannot place an H colony in the southwest empty cell or a V colony in the northeast empty cell, because those would spread onto a radioactive cell and Becca would lose. She has only two possible strategies that do not cause her to lose immediately:\n\n1. Place an H colony in the northwest or northeast empty cells. The colony will also spread to the other of those two cells.\n2. Place a V colony in the northwest or southwest empty cell. The colony will also spread to the other of those two cells.\n\nIf Becca chooses strategy 1, Terry can place a V colony in the southwest empty cell. If Becca chooses strategy 2, Terry can place an H colony in the northeast empty cell. Either way, Becca has no empty cells to choose from on her next turn, so she loses and Terry wins.\n\nIn Sample Case #2, any of Becca's opening moves would cause a mutation.\n\nIn Sample Case #3, five of Becca's possible opening moves would cause a mutation, but the other seven are winning. She can place an H colony in any of the cells of the second row, or she can place a V colony in any of the cells of the second column. In either case, she leaves two disconnected sets of 1 or 2 cells each. In each of those sets, only one type of colony can be played, and playing it consumes all of the empty cells in that set. So, whichever of those sets Terry chooses to consume, Becca can consume the other, leaving Terry with no moves.\n\nIn Sample Case #4, both of Becca's two distinct possible opening moves are winning.\n\nIn Sample Case #5, Becca has no possible opening moves.\n\n**Limits**\n\n$1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test set 1 (Visible)**\n\n- $1 \\leq \\mathbf{R} \\leq 4$.\n- $1 \\leq \\mathbf{C} \\leq 4$.\n\n**Test set 2 (Hidden)**\n\n- $1 \\leq \\mathbf{R} \\leq 15$.\n- $1 \\leq \\mathbf{C} \\leq 15$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #1C] Bacterial Tactics", "background": "", "description": "Becca and Terry are microbiologists who have a friendly rivalry. When they need a break from their research, they like to play a game together. The game is played on a matrix of unit cells with $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. Initially, each cell is either empty, or contains radioactive material.\n\nOn each player's turn, if there are no empty cells in the matrix, that player loses the game. Otherwise, they choose an empty cell and place a colony of bacteria there. Bacteria colonies come in two types: H (for \"horizontal\") and V (for \"vertical\").\n\n* When a type H colony is placed into an empty cell, it occupies that cell (making it non-empty), and also tries to spread into the cell immediately to the west (if there is one) and the cell immediately to the east (if there is one).\n* When a type V colony is placed into an empty cell, it occupies that cell (making it non-empty), and also tries to spread into the cell immediately to the south (if there is one) and the cell immediately to the north (if there is one).\n\nWhenever a colony (of either type) tries to spread into a cell:\n\n* If the cell contains radioactive material, the colony mutates and the player who placed the colony loses the game.\n* If that cell is empty, the colony occupies that cell (making it non-empty), and then the rule above is triggered again (i.e. the colony will try to spread further).\n* If the cell already contains bacteria (of any type), the colony does not spread into that cell.\n\nNotice that it may be possible that all of a player's available moves would cause them to lose the game, and so they are doomed. See the sample case explanations below for examples of how the game works.\n\nBecca makes the first move, and then the two players alternate moves until one of them loses the game. If both players play optimally, who will win? And, if Becca will win, how many distinct winning opening moves does she have? (Two opening moves are distinct if and only if they either use different cells, or different kinds of colony, or both.)\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each case begins with one line containing two integers $\\mathbf{R}$ and $\\mathbf{C}$: the number of rows and columns, respectively, in the matrix. Then, there are $\\mathbf{R}$ more rows of $\\mathbf{C}$ characters each. The j-th character on the i-th of these lines represents the j-th column of the i-th row of the matrix. Each character is either . (an empty cell) or # (a cell with radioactive material).\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1), and $y$ is an integer: either 0 if Becca will not win, or, if Becca will win, the number of distinct winning opening moves she can make, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, Becca cannot place an H colony in the southwest empty cell or a V colony in the northeast empty cell, because those would spread onto a radioactive cell and Becca would lose. She has only two possible strategies that do not cause her to lose immediately:\n\n1. Place an H colony in the northwest or northeast empty cells. The colony will also spread to the other of those two cells.\n2. Place a V colony in the northwest or southwest empty cell. The colony will also spread to the other of those two cells.\n\nIf Becca chooses strategy 1, Terry can place a V colony in the southwest empty cell. If Becca chooses strategy 2, Terry can place an H colony in the northeast empty cell. Either way, Becca has no empty cells to choose from on her next turn, so she loses and Terry wins.\n\nIn Sample Case #2, any of Becca's opening moves would cause a mutation.\n\nIn Sample Case #3, five of Becca's possible opening moves would cause a mutation, but the other seven are winning. She can place an H colony in any of the cells of the second row, or she can place a V colony in any of the cells of the second column. In either case, she leaves two disconnected sets of 1 or 2 cells each. In each of those sets, only one type of colony can be played, and playing it consumes all of the empty cells in that set. So, whichever of those sets Terry chooses to consume, Becca can consume the other, leaving Terry with no moves.\n\nIn Sample Case #4, both of Becca's two distinct possible opening moves are winning.\n\nIn Sample Case #5, Becca has no possible opening moves.\n\n**Limits**\n\n$1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test set 1 (Visible)**\n\n- $1 \\leq \\mathbf{R} \\leq 4$.\n- $1 \\leq \\mathbf{C} \\leq 4$.\n\n**Test set 2 (Hidden)**\n\n- $1 \\leq \\mathbf{R} \\leq 15$.\n- $1 \\leq \\mathbf{C} \\leq 15$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #1C] Bacterial Tactics", "background": null, "description": "Becca 和 Terry 是微生物学家，他们之间有着友好的竞争。当他们需要从研究中休息时，会一起玩一个游戏。该游戏在一个由 $\\mathbf{R}$ 行 $\\mathbf{C}$ 列组成的单元格矩阵上进行。最初，每个格子要么是空的，要么含有放射性物质。\n\n每位玩家轮流行动，如果矩阵中没有空格子，则该玩家输掉游戏。否则，玩家选择一个空格子并在其中放置一个细菌菌落。细菌菌落有两种类型：H（代表“水平”）和 V（代表“垂直”）。\n\n- 当在一个空格子中放置 H 型菌落时，它会占据该格子（使其变为非空），并尝试向西边（如果有）和东边（如果有）的相邻格子扩散。\n- 当在一个空格子中放置 V 型菌落时，它会占据该格子（使其变为非空），并尝试向南边（如果有）和北边（如果有）的相邻格子扩散。\n\n每当菌落（无论哪种类型）尝试扩散到某个格子时：\n\n- 如果该格子含有放射性物质，菌落发生变异，放置该菌落的玩家输掉游戏。\n- 如果该格子为空，菌落占据该格子（使其变为非空），然后再次触发上述规则（即菌落会继续尝试扩散）。\n- 如果该格子已经含有细菌（任意类型），菌落不会扩散到该格子。\n\n注意，可能存在玩家所有可选的行动都会导致自己输掉游戏的情况，因此该玩家注定失败。下面的样例解释中有关于游戏玩法的示例。\n\nBecca 先手，然后两位玩家轮流行动，直到其中一方输掉游戏。如果双方都采取最优策略，谁会获胜？如果 Becca 会获胜，她有多少种不同的必胜开局？（只有当使用的格子不同，或菌落类型不同，或两者都不同，两个开局才算作不同。）", "inputFormat": "输入的第一行为测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组数据的第一行为两个整数 $\\mathbf{R}$ 和 $\\mathbf{C}$，分别表示矩阵的行数和列数。接下来有 $\\mathbf{R}$ 行，每行有 $\\mathbf{C}$ 个字符。第 $i$ 行第 $j$ 个字符表示矩阵第 $i$ 行第 $j$ 列的格子。每个字符要么是 .（空格子），要么是 #（含有放射性物质的格子）。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是一个整数：如果 Becca 无法获胜，则为 0；如果 Becca 能获胜，则为她拥有的不同必胜开局数量，如上所述。", "hint": "**样例解释**\n\n在样例 1 中，Becca 不能在西南角的空格子放置 H 型菌落，也不能在东北角的空格子放置 V 型菌落，因为那样会扩散到放射性格子，Becca 会输。她只有两种不会立即输掉的策略：\n\n1. 在西北角或东北角的空格子放置 H 型菌落。该菌落还会扩散到另一个角的空格子。\n2. 在西北角或西南角的空格子放置 V 型菌落。该菌落还会扩散到另一个角的空格子。\n\n如果 Becca 选择策略 1，Terry 可以在西南角的空格子放置 V 型菌落。如果 Becca 选择策略 2，Terry 可以在东北角的空格子放置 H 型菌落。无论哪种情况，Becca 下一轮都没有空格可选，因此她会输，Terry 获胜。\n\n在样例 2 中，Becca 的任何开局都会导致变异。\n\n在样例 3 中，Becca 有 5 种可能的开局会导致变异，但另外 7 种是必胜的。她可以在第二行的任意格子放置 H 型菌落，或者在第二列的任意格子放置 V 型菌落。无论哪种情况，她都会留下两个不相连的 1 或 2 个格子的集合。在每个集合中，只能放置一种类型的菌落，且放置后会消耗掉该集合内所有空格。因此，无论 Terry 选择消耗哪一个集合，Becca 都可以消耗另一个集合，使 Terry 无法行动。\n\n在样例 4 中，Becca 的两种不同开局都是必胜的。\n\n在样例 5 中，Becca 没有可行的开局。\n\n**数据范围**\n\n$1 \\leq \\mathbf{T} \\leq 100$。\n\n**测试点 1（可见）**\n\n- $1 \\leq \\mathbf{R} \\leq 4$。\n- $1 \\leq \\mathbf{C} \\leq 4$。\n\n**测试点 2（隐藏）**\n\n- $1 \\leq \\mathbf{R} \\leq 15$。\n- $1 \\leq \\mathbf{C} \\leq 15$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13115", "type": "P", "difficulty": 3, "samples": [["3\n3\n1 1\n1 2\n2 1\n4\n1 2\n2 4\n2 1\n4 2\n3\n1 2\n1 3\n2 3", "Case #1: 2\nCase #2: 2\nCase #3: 1"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "2019", "Google Code Jam"], "title": "[GCJ 2019 #2] New Elements: Part 1", "background": "", "description": "**The first two paragraphs (not counting this one) of this problem and \"New Elements: Part 2\" are identical. The problems can otherwise be solved independently; you do not need to read or solve one in order to read or solve the other.**\n\nMuriel is on the path to discovering two new elements that she has named Codium and Jamarium. She has not been able to isolate them yet, but she wants to start investigating some important properties, like their atomic weights, by indirect means. Since Muriel is working with a single isotope of Codium and a single isotope of Jamarium, their atomic weights are strictly positive integers.\n\nMuriel managed to create $\\mathbf{N}$ different molecules, each of which contains one or more atoms of Codium and one or more atoms of Jamarium, and no other elements. For each molecule, she knows how many atoms of each element are present in it. The molecular weight of a molecule is the sum of the atomic weights of all the atoms it contains.\n\nAs a first step towards figuring out exact molecular weights for the molecules and atomic weights for the two elements, Muriel wants to sort the molecules by strictly increasing molecular weight. To assess the difficulty of that task, she wants to know how many orders are valid considering only the information she has right now. An ordering of the molecules is considered valid if there exist values for the atomic weights of Codium and Jamarium such that the ordering is strictly increasing in molecular weight.\n\nTo give an example, we represent each molecule by the ordered pair of the number of atoms of Codium and Jamarium it contains. If Muriel has 3 molecules represented by $(1, 1)$, $(2, 1)$ and $(1, 2)$, there are two possible orderings that can be strictly increasing in molecular weight: $(1, 1)$, $(1, 2)$, $(2, 1)$ and $(1, 1)$, $(2, 1)$, $(1, 2)$. The first ordering is valid for any assignment of atomic weights in which Codium is the heaviest of the two elements, and the second is valid for any assignment in which Jamarium is the heaviest. The only case remaining is when both Codium and Jamarium have the same atomic weight, in which case $(1, 2)$ and $(2, 1)$ have the same molecular weight, so no strictly increasing ordering can be produced for that scenario.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains a single integer $\\mathbf{N}$, the number of molecules. Each of the next $\\mathbf{N}$ lines describes a different molecule with two integers $\\mathbf{C_i}$ and $\\mathbf{J_i}$ that represent the number of Codium and Jamarium atoms in the i-th molecule, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the total number of valid orderings as defined above.", "hint": "**Sample Explanation**\n\nSample Case #1 is explained in the statement.\n\nIn Sample Case #2, the two valid orderings are $(1, 2)$, $(2, 1)$, $(2, 4)$, $(4, 2)$ and $(2, 1)$, $(1, 2)$, $(4, 2)$, $(2, 4)$. Notice that the ordering $(1, 2)$, $(2, 1)$, $(2, 4)$, $(4, 2)$, $(2, 4)$ is invalid because if $(1, 2)$ is strictly less heavy than $(2, 1)$, then $(2, 4)$, which is exactly twice as heavy as $(1, 2)$, must be strictly less heavy than $(4, 2)$, which is exactly twice as heavy as $(2, 1)$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{C_i} \\leqslant 10^9$, for all i.\n- $1 \\leqslant \\mathbf{J_i} \\leqslant 10^9$, for all i.\n- $(\\mathbf{C_i}, \\mathbf{J_i}) \\neq (\\mathbf{C_j}, \\mathbf{J_j})$ for all $i \\neq j$. (All molecules are different.)\n\n**Test set 1 (8 Pts, Visible)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 6$.\n\n**Test set 2 (14 Pts, Hidden)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 300$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #2] New Elements: Part 1", "background": "", "description": "**The first two paragraphs (not counting this one) of this problem and \"New Elements: Part 2\" are identical. The problems can otherwise be solved independently; you do not need to read or solve one in order to read or solve the other.**\n\nMuriel is on the path to discovering two new elements that she has named Codium and Jamarium. She has not been able to isolate them yet, but she wants to start investigating some important properties, like their atomic weights, by indirect means. Since Muriel is working with a single isotope of Codium and a single isotope of Jamarium, their atomic weights are strictly positive integers.\n\nMuriel managed to create $\\mathbf{N}$ different molecules, each of which contains one or more atoms of Codium and one or more atoms of Jamarium, and no other elements. For each molecule, she knows how many atoms of each element are present in it. The molecular weight of a molecule is the sum of the atomic weights of all the atoms it contains.\n\nAs a first step towards figuring out exact molecular weights for the molecules and atomic weights for the two elements, Muriel wants to sort the molecules by strictly increasing molecular weight. To assess the difficulty of that task, she wants to know how many orders are valid considering only the information she has right now. An ordering of the molecules is considered valid if there exist values for the atomic weights of Codium and Jamarium such that the ordering is strictly increasing in molecular weight.\n\nTo give an example, we represent each molecule by the ordered pair of the number of atoms of Codium and Jamarium it contains. If Muriel has 3 molecules represented by $(1, 1)$, $(2, 1)$ and $(1, 2)$, there are two possible orderings that can be strictly increasing in molecular weight: $(1, 1)$, $(1, 2)$, $(2, 1)$ and $(1, 1)$, $(2, 1)$, $(1, 2)$. The first ordering is valid for any assignment of atomic weights in which Codium is the heaviest of the two elements, and the second is valid for any assignment in which Jamarium is the heaviest. The only case remaining is when both Codium and Jamarium have the same atomic weight, in which case $(1, 2)$ and $(2, 1)$ have the same molecular weight, so no strictly increasing ordering can be produced for that scenario.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains a single integer $\\mathbf{N}$, the number of molecules. Each of the next $\\mathbf{N}$ lines describes a different molecule with two integers $\\mathbf{C_i}$ and $\\mathbf{J_i}$ that represent the number of Codium and Jamarium atoms in the i-th molecule, respectively.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the total number of valid orderings as defined above.", "hint": "**Sample Explanation**\n\nSample Case #1 is explained in the statement.\n\nIn Sample Case #2, the two valid orderings are $(1, 2)$, $(2, 1)$, $(2, 4)$, $(4, 2)$ and $(2, 1)$, $(1, 2)$, $(4, 2)$, $(2, 4)$. Notice that the ordering $(1, 2)$, $(2, 1)$, $(2, 4)$, $(4, 2)$, $(2, 4)$ is invalid because if $(1, 2)$ is strictly less heavy than $(2, 1)$, then $(2, 4)$, which is exactly twice as heavy as $(1, 2)$, must be strictly less heavy than $(4, 2)$, which is exactly twice as heavy as $(2, 1)$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{C_i} \\leqslant 10^9$, for all i.\n- $1 \\leqslant \\mathbf{J_i} \\leqslant 10^9$, for all i.\n- $(\\mathbf{C_i}, \\mathbf{J_i}) \\neq (\\mathbf{C_j}, \\mathbf{J_j})$ for all $i \\neq j$. (All molecules are different.)\n\n**Test set 1 (8 Pts, Visible)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 6$.\n\n**Test set 2 (14 Pts, Hidden)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 300$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #2] New Elements: Part 1", "background": null, "description": "**本题的前两段（不包括本段）与“New Elements: Part 2”完全相同。除此之外，这两道题可以独立解决；你无需阅读或解决其中一道即可理解或解决另一道。**\n\nMuriel 正在探索两种新元素，并将它们命名为 Codium 和 Jamarium。她尚未能够分离出这两种元素，但她希望通过间接方法研究它们的一些重要性质，比如它们的原子量。由于 Muriel 只研究 Codium 和 Jamarium 的单一同位素，因此它们的原子量都是严格正整数。\n\nMuriel 成功合成了 $\\mathbf{N}$ 种不同的分子，每种分子都只包含一种或多种 Codium 原子和一种或多种 Jamarium 原子，不含其他元素。对于每种分子，她都知道其中包含的每种元素的原子数。分子的分子量等于其所含所有原子的原子量之和。\n\n为了进一步确定分子的精确分子量以及两种元素的原子量，Muriel 首先希望将这些分子按分子量严格递增的顺序排序。为了评估这个任务的难度，她想知道在当前信息下，有多少种排序方式是有效的。一个分子的排序被认为是有效的，当且仅当存在 Codium 和 Jamarium 的原子量的取值，使得该排序下分子的分子量严格递增。\n\n举个例子，我们用每个分子中 Codium 和 Jamarium 原子的数量对其进行表示。如果 Muriel 有 3 个分子，分别为 $(1, 1)$、$(2, 1)$ 和 $(1, 2)$，则有两种可能的排序可以使分子量严格递增：$(1, 1)$、$(1, 2)$、$(2, 1)$ 和 $(1, 1)$、$(2, 1)$、$(1, 2)$。第一种排序在 Codium 比 Jamarium 重时成立，第二种排序在 Jamarium 比 Codium 重时成立。剩下的唯一情况是 Codium 和 Jamarium 的原子量相等，此时 $(1, 2)$ 和 $(2, 1)$ 的分子量相等，因此无法得到严格递增的排序。", "inputFormat": "输入的第一行为测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组测试数据的第一行为一个整数 $\\mathbf{N}$，表示分子的数量。接下来的 $\\mathbf{N}$ 行，每行包含两个整数 $\\mathbf{C_i}$ 和 $\\mathbf{J_i}$，分别表示第 $i$ 个分子中 Codium 和 Jamarium 的原子数。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是满足条件的有效排序总数。", "hint": "**样例解释**\n\n样例 1 已在题目描述中解释。\n\n在样例 2 中，两种有效的排序分别为 $(1, 2)$、$(2, 1)$、$(2, 4)$、$(4, 2)$ 和 $(2, 1)$、$(1, 2)$、$(4, 2)$、$(2, 4)$。注意，排序 $(1, 2)$、$(2, 1)$、$(2, 4)$、$(4, 2)$、$(2, 4)$ 是无效的，因为如果 $(1, 2)$ 的分子量严格小于 $(2, 1)$，那么 $(2, 4)$（正好是 $(1, 2)$ 的两倍）也必须严格小于 $(4, 2)$（正好是 $(2, 1)$ 的两倍）。\n\n**数据范围**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $1 \\leqslant \\mathbf{C_i} \\leqslant 10^9$，对所有 $i$。\n- $1 \\leqslant \\mathbf{J_i} \\leqslant 10^9$，对所有 $i$。\n- 对于所有 $i \\neq j$，$(\\mathbf{C_i}, \\mathbf{J_i}) \\neq (\\mathbf{C_j}, \\mathbf{J_j})$（所有分子都不同）。\n\n**测试点 1（8 分，可见）**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 6$。\n\n**测试点 2（14 分，隐藏）**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 300$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13116", "type": "P", "difficulty": 5, "samples": [["", ""]], "limits": {"time": [40000], "memory": [1048576]}, "tags": ["数学", "贪心", "2019", "交互题", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 #2] Pottery Lottery", "background": "", "description": "The Pottery Palace is going to run a lottery featuring some valuable vases by the artist Cody-Jamal. The lottery works as follows:\n\n* 100 people get to play in the lottery. Each player has a unique number between 1 and 100, and is given a single token with that number.\n* There are 20 empty clay vases on a table, numbered 1 through 20. The vases have narrow openings that are large enough to accept a token, but small enough that players cannot look inside to see the contents.\n* On the i-th day of the lottery, the player with token number i chooses a vase and puts their token in that vase. Since the vases are all identical (apart from their labels), every player will choose one uniformly at random and independently of all other players' choices.\n* On day 100, after player number 100 has inserted their token, the organizers shake the vases to determine how many tokens are inside each one. If there is exactly one vase that has fewer tokens than any other vase, then that one is the \"winning vase\". The organizers then pour out all of the tokens in that vase, and every player whose number is written on one of those poured-out tokens wins a vase! If multiple vases have the same minimal amount of tokens, nobody wins anything.\n\nYou have been hired to test the security of the lottery, and you will participate in some trial runs. The company will always assign you the number 100 — that is, you replace player 100.\n\nYou have found some ways to tamper with the lottery at night, but security is tight, so you can only do so much! Specifically, after each of the first 99 days of the lottery, you may do exactly one of the following:\n\n* forge a token with the player number of your choice (between 1 and 100, inclusive), and add it to a vase of your choice. You are a very good forger: if there is a winning vase, any forged tokens in that vase will cause the players with those numbers to win (with one exception; see below).\n* use a special camera to see the numbers on all of the tokens in one vase of your choice\n\nYou may perform different actions on different nights, and you may choose dynamically: you do not need to decide on all of your actions in advance.\n\nOn the 100th day, it is your turn to insert your token into a vase of your choice (you do not need to choose uniformly at random). You cannot perform any other actions on that day.\n\nYou know that if there is a winning vase with more than one token for the same player, it will be obvious that cheating has occurred and nobody will win. However, it does not matter if other vases contain more than one token for the same player because the organizers never see those tokens.\n\nYour goal is to be a winner in at least 90% of the test cases.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing a single integer $\\mathbf{T}$ indicating the number of test cases. Then, you need to process $\\mathbf{T}$ test cases.\n\nAt the start of a test case, the judge outputs one line with one integer: the number of the current day. (The judge starts on day 1, and on the i-th day, it prints i.) After your program reads the integer, it should write a line containing two integers $\\mathbf{V}$ and $\\mathbf{P}$, with $1 \\leq \\mathbf{V} \\leq 20$, and $0 \\leq \\mathbf{P} \\leq 100$. The judge will interpret these as follows:\n\n* If $1 \\leq \\mathbf{P} \\leq 100$, you put a token for player $\\mathbf{P}$ in vase $\\mathbf{V}$. The judge does not write anything back as a response.\n* If $\\mathbf{P} = 0$, you inspect the contents of vase $\\mathbf{V}$. The judge writes one line containing integers. The first integer is $\\mathbf{N}$, the number of tokens in vase $\\mathbf{V}$, and then there are $\\mathbf{N}$ more integers: the player numbers on each of the tokens, in non-decreasing order.\n\nNotice that on turn 100, you must put your own token in, so $\\mathbf{P}$ must be 100.\n\nRemember that on the i-th day, for $1 \\leq i \\leq 99$, the judge simulates the action of the i-th player, as described in the statement. This happens before your own action on that day.\n\nAfter you send your move for turn 100, your program should terminate if it was the last test case; otherwise, it should start reading data for the next test case. (Notice that the judge does not tell you whether you got each case correct or incorrect.) The judge will only check whether you have enough correct answers after you have attempted all $\\mathbf{T}$ test cases, so you should not stop early! For example, if you answer the first 225 out of 250 cases correctly and then exit, or provide malformed input, your solution will not be considered correct.\n\nIf your program outputs something illegal (e.g., gives an invalid value for $\\mathbf{P}$ or $\\mathbf{V}$, or tries to inspect a vase on turn 100), the judge will send one line containing -1 to your input stream, and it will not send any other output after that. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the total memory is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\n```\n  t = readline_int()           // reads 250 into t\n  curr_day = readline_int()    // reads 1 (day 1)\n  printline 8 100 to stdout    // puts a token for player 100 into vase 8\n  flush stdout\n  curr_day = readline_int()    // reads 2 (day 2)\n  printline 8 99 to stdout     // puts a token for player 99 into vase 8\n  flush stdout\n  curr_day = readline_int()    // reads 3 (day 3)\n  printline 8 100 to stdout    // puts a token for player 100 into vase 8\n  flush stdout\n  curr_day = readline_int()    // reads 4 (day 4)\n  printline 20 7 to stdout     // puts a token for player 7 into vase 20\n  flush stdout\n  curr_day = readline_int()    // reads 5 (day 5)\n  printline 8 0 to stdout      // inspects vase 8\n  flush stdout\n  tokens = readline_int_list() // reads 5 2 5 99 100 100 (players 2 and 5\n                               //   happen to have chosen vase 8)\n  curr_day = readline_int()    // reads 6 (day 6)\n  printline 8 101 to stdout    // tries to add a token with a bad player number\n  flush stdout\n  curr_day = readline_int()    // reads -1 (judge has decided our solution is\n                               //   incorrect)\n  exit                         // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n**Test set 1 (23 Pts, Visible)**\n\n- $\\mathbf{T} = 250$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #2] Pottery Lottery", "background": "", "description": "The Pottery Palace is going to run a lottery featuring some valuable vases by the artist Cody-Jamal. The lottery works as follows:\n\n* 100 people get to play in the lottery. Each player has a unique number between 1 and 100, and is given a single token with that number.\n* There are 20 empty clay vases on a table, numbered 1 through 20. The vases have narrow openings that are large enough to accept a token, but small enough that players cannot look inside to see the contents.\n* On the i-th day of the lottery, the player with token number i chooses a vase and puts their token in that vase. Since the vases are all identical (apart from their labels), every player will choose one uniformly at random and independently of all other players' choices.\n* On day 100, after player number 100 has inserted their token, the organizers shake the vases to determine how many tokens are inside each one. If there is exactly one vase that has fewer tokens than any other vase, then that one is the \"winning vase\". The organizers then pour out all of the tokens in that vase, and every player whose number is written on one of those poured-out tokens wins a vase! If multiple vases have the same minimal amount of tokens, nobody wins anything.\n\nYou have been hired to test the security of the lottery, and you will participate in some trial runs. The company will always assign you the number 100 — that is, you replace player 100.\n\nYou have found some ways to tamper with the lottery at night, but security is tight, so you can only do so much! Specifically, after each of the first 99 days of the lottery, you may do exactly one of the following:\n\n* forge a token with the player number of your choice (between 1 and 100, inclusive), and add it to a vase of your choice. You are a very good forger: if there is a winning vase, any forged tokens in that vase will cause the players with those numbers to win (with one exception; see below).\n* use a special camera to see the numbers on all of the tokens in one vase of your choice\n\nYou may perform different actions on different nights, and you may choose dynamically: you do not need to decide on all of your actions in advance.\n\nOn the 100th day, it is your turn to insert your token into a vase of your choice (you do not need to choose uniformly at random). You cannot perform any other actions on that day.\n\nYou know that if there is a winning vase with more than one token for the same player, it will be obvious that cheating has occurred and nobody will win. However, it does not matter if other vases contain more than one token for the same player because the organizers never see those tokens.\n\nYour goal is to be a winner in at least 90% of the test cases.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing a single integer $\\mathbf{T}$ indicating the number of test cases. Then, you need to process $\\mathbf{T}$ test cases.\n\nAt the start of a test case, the judge outputs one line with one integer: the number of the current day. (The judge starts on day 1, and on the i-th day, it prints i.) After your program reads the integer, it should write a line containing two integers $\\mathbf{V}$ and $\\mathbf{P}$, with $1 \\leq \\mathbf{V} \\leq 20$, and $0 \\leq \\mathbf{P} \\leq 100$. The judge will interpret these as follows:\n\n* If $1 \\leq \\mathbf{P} \\leq 100$, you put a token for player $\\mathbf{P}$ in vase $\\mathbf{V}$. The judge does not write anything back as a response.\n* If $\\mathbf{P} = 0$, you inspect the contents of vase $\\mathbf{V}$. The judge writes one line containing integers. The first integer is $\\mathbf{N}$, the number of tokens in vase $\\mathbf{V}$, and then there are $\\mathbf{N}$ more integers: the player numbers on each of the tokens, in non-decreasing order.\n\nNotice that on turn 100, you must put your own token in, so $\\mathbf{P}$ must be 100.\n\nRemember that on the i-th day, for $1 \\leq i \\leq 99$, the judge simulates the action of the i-th player, as described in the statement. This happens before your own action on that day.\n\nAfter you send your move for turn 100, your program should terminate if it was the last test case; otherwise, it should start reading data for the next test case. (Notice that the judge does not tell you whether you got each case correct or incorrect.) The judge will only check whether you have enough correct answers after you have attempted all $\\mathbf{T}$ test cases, so you should not stop early! For example, if you answer the first 225 out of 250 cases correctly and then exit, or provide malformed input, your solution will not be considered correct.\n\nIf your program outputs something illegal (e.g., gives an invalid value for $\\mathbf{P}$ or $\\mathbf{V}$, or tries to inspect a vase on turn 100), the judge will send one line containing -1 to your input stream, and it will not send any other output after that. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the total memory is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\n```\n  t = readline_int()           // reads 250 into t\n  curr_day = readline_int()    // reads 1 (day 1)\n  printline 8 100 to stdout    // puts a token for player 100 into vase 8\n  flush stdout\n  curr_day = readline_int()    // reads 2 (day 2)\n  printline 8 99 to stdout     // puts a token for player 99 into vase 8\n  flush stdout\n  curr_day = readline_int()    // reads 3 (day 3)\n  printline 8 100 to stdout    // puts a token for player 100 into vase 8\n  flush stdout\n  curr_day = readline_int()    // reads 4 (day 4)\n  printline 20 7 to stdout     // puts a token for player 7 into vase 20\n  flush stdout\n  curr_day = readline_int()    // reads 5 (day 5)\n  printline 8 0 to stdout      // inspects vase 8\n  flush stdout\n  tokens = readline_int_list() // reads 5 2 5 99 100 100 (players 2 and 5\n                               //   happen to have chosen vase 8)\n  curr_day = readline_int()    // reads 6 (day 6)\n  printline 8 101 to stdout    // tries to add a token with a bad player number\n  flush stdout\n  curr_day = readline_int()    // reads -1 (judge has decided our solution is\n                               //   incorrect)\n  exit                         // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n**Test set 1 (23 Pts, Visible)**\n\n- $\\mathbf{T} = 250$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #2] Pottery Lottery", "background": null, "description": "陶艺宫将举办一次抽奖活动，奖品是艺术家 Cody-Jamal 的一些珍贵花瓶。抽奖规则如下：\n\n- 有 100 人参与抽奖。每位玩家拥有一个唯一编号（1 到 100 之间），并获得一个带有该编号的代币。\n- 桌上有 20 个空陶瓷花瓶，编号为 1 到 20。花瓶的开口足够大，可以放入代币，但开口很窄，玩家无法看到里面的内容。\n- 在第 $i$ 天，编号为 $i$ 的玩家选择一个花瓶，并将自己的代币放入该花瓶。由于花瓶除了标签外完全相同，每位玩家都会独立且等概率地随机选择一个花瓶。\n- 第 100 天，在编号为 100 的玩家放入代币后，组织者会摇晃花瓶，统计每个花瓶中的代币数量。如果恰好有一个花瓶中的代币数量比其他所有花瓶都少，那么这个花瓶就是“中奖花瓶”。组织者会倒出中奖花瓶中的所有代币，代币编号对应的玩家都将获得一个花瓶！如果有多个花瓶的代币数量同为最少，则无人获奖。\n\n你被雇佣来测试抽奖的安全性，并将参与若干次试运行。公司总是会分配给你编号 100 —— 也就是说，你替代了编号为 100 的玩家。\n\n你发现了一些夜间篡改抽奖的方法，但安保很严，你能做的有限！具体来说，在前 99 天的每一天结束后，你可以执行以下两种操作之一：\n\n- 伪造一个任意玩家编号（1 到 100 之间）的代币，并将其放入任意一个花瓶。你的伪造技术非常高超：如果某个花瓶成为中奖花瓶，中奖花瓶中的伪造代币也会使对应编号的玩家获奖（有一个例外，见下文）。\n- 使用特殊相机查看某个花瓶内所有代币上的编号。\n\n你可以在不同的夜晚选择不同的操作，并且可以动态决定：不需要提前规划所有操作。\n\n第 100 天轮到你放入自己的代币，你可以选择任意一个花瓶（不需要随机选择）。当天你不能进行其他操作。\n\n你知道，如果中奖花瓶中存在同一玩家编号的多个代币，作弊行为会被发现，无人获奖。但其他花瓶中是否有重复编号的代币无关紧要，因为组织者不会查看那些花瓶。\n\n你的目标是在至少 90% 的测试用例中成为获奖者。\n\n### 交互协议\n\n这是一个交互题。\n\n最开始，你的程序应读取一行，包含一个整数 $\\mathbf{T}$，表示测试用例数量。然后，你需要处理 $\\mathbf{T}$ 个测试用例。\n\n每个测试用例开始时，评测器会输出一行，包含一个整数：当前天数（评测器从第 1 天开始，在第 $i$ 天输出 $i$）。你的程序读取该整数后，应输出一行，包含两个整数 $\\mathbf{V}$ 和 $\\mathbf{P}$，其中 $1 \\leq \\mathbf{V} \\leq 20$，$0 \\leq \\mathbf{P} \\leq 100$。评测器的解释如下：\n\n- 如果 $1 \\leq \\mathbf{P} \\leq 100$，你会将编号为 $\\mathbf{P}$ 的代币放入编号为 $\\mathbf{V}$ 的花瓶。评测器不会对此做出回应。\n- 如果 $\\mathbf{P} = 0$，你会查看编号为 $\\mathbf{V}$ 的花瓶内的内容。评测器会输出一行整数。第一个整数是 $\\mathbf{N}$，表示该花瓶内的代币数量，接下来有 $\\mathbf{N}$ 个整数，按非递减顺序给出每个代币上的玩家编号。\n\n注意，第 100 天你必须放入自己的代币，因此 $\\mathbf{P}$ 必须为 100。\n\n请记住，在第 $i$ 天（$1 \\leq i \\leq 99$），评测器会按照题目描述模拟第 $i$ 位玩家的操作，这发生在你当天的操作之前。\n\n在你第 100 天提交操作后，如果这是最后一个测试用例，你的程序应终止；否则，继续读取下一个测试用例的数据。（注意，评测器不会告知你每个用例是否正确。只有在你完成所有 $\\mathbf{T}$ 个测试用例后，评测器才会检查你是否答对足够多的用例，因此不要提前退出！例如，如果你答对了前 225 个用例中的 225 个然后退出，或者输出格式错误，你的解答将不被判为正确。）\n\n如果你的程序输出了非法内容（如 $\\mathbf{P}$ 或 $\\mathbf{V}$ 不合法，或在第 100 天尝试查看花瓶），评测器会向你的输入流发送一行 -1，之后不会再有任何输出。如果你的程序在收到 -1 后仍继续等待评测器，则会超时，导致 Time Limit Exceeded 错误。请确保你的程序能及时退出，以获得 Wrong Answer 判罚，而不是 TLE。若总内存超限或程序运行时出错，也会得到相应的判罚。", "inputFormat": "参见交互协议。", "outputFormat": "参见交互协议。", "hint": "**交互样例**\n\n```\n  t = readline_int()           // 读取 250 到 t\n  curr_day = readline_int()    // 读取 1（第 1 天）\n  printline 8 100 to stdout    // 将编号 100 的代币放入 8 号花瓶\n  flush stdout\n  curr_day = readline_int()    // 读取 2（第 2 天）\n  printline 8 99 to stdout     // 将编号 99 的代币放入 8 号花瓶\n  flush stdout\n  curr_day = readline_int()    // 读取 3（第 3 天）\n  printline 8 100 to stdout    // 将编号 100 的代币放入 8 号花瓶\n  flush stdout\n  curr_day = readline_int()    // 读取 4（第 4 天）\n  printline 20 7 to stdout     // 将编号 7 的代币放入 20 号花瓶\n  flush stdout\n  curr_day = readline_int()    // 读取 5（第 5 天）\n  printline 8 0 to stdout      // 查看 8 号花瓶\n  flush stdout\n  tokens = readline_int_list() // 读取 5 2 5 99 100 100（玩家 2 和 5\n                               //   恰好选择了 8 号花瓶）\n  curr_day = readline_int()    // 读取 6（第 6 天）\n  printline 8 101 to stdout    // 尝试放入非法编号的代币\n  flush stdout\n  curr_day = readline_int()    // 读取 -1（评测器判定解答错误）\n  exit                         // 退出，避免 TLE 错误\n```\n\n你可以使用本地测试工具在本地或平台上测试。若要在本地测试，需要让测试工具与你的代码并行运行；你可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释。\n\n测试工具的使用说明已包含在工具的注释中。我们鼓励你自行添加测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真实的评测系统，行为可能有所不同。\n\n**数据范围**\n\n**测试点 1（23 分，可见）**\n\n- $\\mathbf{T} = 250$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13117", "type": "P", "difficulty": 6, "samples": [["3\n3\n1 1\n1 2\n2 1\n4\n1 2\n2 1\n4 2\n2 4\n3\n1 2\n1 3\n2 3", "Case #1: 2 1\nCase #2: IMPOSSIBLE\nCase #3: 1 1"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "2019", "二分", "Stern-Brocot 树", "Google Code Jam"], "title": "[GCJ 2019 #2] New Elements: Part 2", "background": "", "description": "**The first two paragraphs (not counting this one) of this problem and \"New Elements: Part 1\" are identical. The problems can otherwise be solved independently; you do not need to read or solve one in order to read or solve the other.**\n\nMuriel is on the path to discovering two new elements that she has named Codium and Jamarium. She has not been able to isolate them yet, but she wants to start investigating some important properties, like their atomic weights, by indirect means. Since Muriel is working with a single isotope of Codium and a single isotope of Jamarium, their atomic weights are strictly positive integers.\n\nMuriel managed to create $\\mathbf{N}$ different molecules, each of which contains one or more atoms of Codium and one or more atoms of Jamarium, and no other elements. For each molecule, she knows how many atoms of each element are present in it. The molecular weight of a molecule is the sum of the atomic weights of all the atoms it contains.\n\nAs a first step, Muriel sorted the molecules by strictly increasing molecular weight. Now she wants to find out possible integer values for the atomic weights of both Codium and Jamarium that are consistent with the ordering. Since she is aware there could be many consistent pairs of values, she wants one that minimizes the atomic weight of Codium. If there are multiple pairs in which Codium's atomic weight is minimum, she wants the one in which Jamarium's atomic weight is minimum.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains a single integer $\\mathbf{N}$, the number of molecules. Each of the next $\\mathbf{N}$ lines describes a different molecule with two integers $\\mathbf{C_i}$ and $\\mathbf{J_i}$ that represent the number of Codium and Jamarium atoms in the i-th molecule, respectively. The molecules are given in strictly increasing order of molecular weight.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1), and $y$ is IMPOSSIBLE (in uppercase) if there is no pair of integer atomic weights that would make the order of the molecules strictly increasing in molecular weight. Otherwise, $y$ should be two integers $c\\ j$ where $c$ is the atomic weight of Codium and $j$ is the atomic weight of Jamarium, chosen according to the rules above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the difference between the last two molecules is having an extra atom of one element or the other. Given that the one having the extra Codium is heavier overall, we conclude that Codium must be heavier than Jamarium. The values 2 and 1 for the atomic weights of Codium and Jamarium make the molecular weights $1 \\times 2 + 1 \\times 1 = 3$, $1 \\times 2 + 2 \\times 1 = 4$, and $2 \\times 2 + 1 \\times 1 = 5$, respecting the strict ordering. Since Codium is heavier than Jamarium in this case, 2 is Codium's minimum atomic weight, and 1 is of course Jamarium's minimum atomic weight.\n\nLet $a$, $b$, $c$ and $d$ be the molecular weights of the molecules in Sample Case #2, in increasing order of molecular weight. By their atom contents, $d = 2 \\times a$ and $c = 2 \\times b$. It follows from $a < b$ that $d = 2 \\times a < 2 \\times b = c$, which means there is no pair of values for the atomic weights that would make the ordering strictly increasing.\n\nIn Sample Case #3, notice that the molecules happen to be sorted in strictly increasing order of total number of atoms. Therefore, assigning both elements an atomic weight of 1 makes the atomic weights be sorted in strictly increasing order.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 10$.\n- $(\\mathbf{C_i}, \\mathbf{J_i}) \\neq (\\mathbf{C_j}, \\mathbf{J_j})$ for all $i \\neq j$. (All molecules are different.)\n\n**Test set 1 (10 Pts, Visible)**\n\n- $1 \\leq \\mathbf{C_i} \\leq 100$, for all $i$.\n- $1 \\leq \\mathbf{J_i} \\leq 100$, for all $i$.\n\n**Test set 2 (16 Pts, Hidden)**\n\n- $1 \\leq \\mathbf{C_i} \\leq 10^9$, for all $i$.\n- $1 \\leq \\mathbf{J_i} \\leq 10^9$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #2] New Elements: Part 2", "background": "", "description": "**The first two paragraphs (not counting this one) of this problem and \"New Elements: Part 1\" are identical. The problems can otherwise be solved independently; you do not need to read or solve one in order to read or solve the other.**\n\nMuriel is on the path to discovering two new elements that she has named Codium and Jamarium. She has not been able to isolate them yet, but she wants to start investigating some important properties, like their atomic weights, by indirect means. Since Muriel is working with a single isotope of Codium and a single isotope of Jamarium, their atomic weights are strictly positive integers.\n\nMuriel managed to create $\\mathbf{N}$ different molecules, each of which contains one or more atoms of Codium and one or more atoms of Jamarium, and no other elements. For each molecule, she knows how many atoms of each element are present in it. The molecular weight of a molecule is the sum of the atomic weights of all the atoms it contains.\n\nAs a first step, Muriel sorted the molecules by strictly increasing molecular weight. Now she wants to find out possible integer values for the atomic weights of both Codium and Jamarium that are consistent with the ordering. Since she is aware there could be many consistent pairs of values, she wants one that minimizes the atomic weight of Codium. If there are multiple pairs in which Codium's atomic weight is minimum, she wants the one in which Jamarium's atomic weight is minimum.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. The first line of a test case contains a single integer $\\mathbf{N}$, the number of molecules. Each of the next $\\mathbf{N}$ lines describes a different molecule with two integers $\\mathbf{C_i}$ and $\\mathbf{J_i}$ that represent the number of Codium and Jamarium atoms in the i-th molecule, respectively. The molecules are given in strictly increasing order of molecular weight.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1), and $y$ is IMPOSSIBLE (in uppercase) if there is no pair of integer atomic weights that would make the order of the molecules strictly increasing in molecular weight. Otherwise, $y$ should be two integers $c\\ j$ where $c$ is the atomic weight of Codium and $j$ is the atomic weight of Jamarium, chosen according to the rules above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the difference between the last two molecules is having an extra atom of one element or the other. Given that the one having the extra Codium is heavier overall, we conclude that Codium must be heavier than Jamarium. The values 2 and 1 for the atomic weights of Codium and Jamarium make the molecular weights $1 \\times 2 + 1 \\times 1 = 3$, $1 \\times 2 + 2 \\times 1 = 4$, and $2 \\times 2 + 1 \\times 1 = 5$, respecting the strict ordering. Since Codium is heavier than Jamarium in this case, 2 is Codium's minimum atomic weight, and 1 is of course Jamarium's minimum atomic weight.\n\nLet $a$, $b$, $c$ and $d$ be the molecular weights of the molecules in Sample Case #2, in increasing order of molecular weight. By their atom contents, $d = 2 \\times a$ and $c = 2 \\times b$. It follows from $a < b$ that $d = 2 \\times a < 2 \\times b = c$, which means there is no pair of values for the atomic weights that would make the ordering strictly increasing.\n\nIn Sample Case #3, notice that the molecules happen to be sorted in strictly increasing order of total number of atoms. Therefore, assigning both elements an atomic weight of 1 makes the atomic weights be sorted in strictly increasing order.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 10$.\n- $(\\mathbf{C_i}, \\mathbf{J_i}) \\neq (\\mathbf{C_j}, \\mathbf{J_j})$ for all $i \\neq j$. (All molecules are different.)\n\n**Test set 1 (10 Pts, Visible)**\n\n- $1 \\leq \\mathbf{C_i} \\leq 100$, for all $i$.\n- $1 \\leq \\mathbf{J_i} \\leq 100$, for all $i$.\n\n**Test set 2 (16 Pts, Hidden)**\n\n- $1 \\leq \\mathbf{C_i} \\leq 10^9$, for all $i$.\n- $1 \\leq \\mathbf{J_i} \\leq 10^9$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #2] New Elements: Part 2", "background": null, "description": "**本题的前两段（不包括本段）与“New Elements: Part 1”完全相同。除此之外，两题可以独立解决；你无需阅读或解决其中一题才能理解或解决另一题。**\n\nMuriel 正在探索两种她命名为 Codium 和 Jamarium 的新元素。她尚未能将它们分离出来，但她希望通过间接方法研究它们的一些重要性质，比如它们的原子量。由于 Muriel 只研究 Codium 的单一同位素和 Jamarium 的单一同位素，它们的原子量都是严格正整数。\n\nMuriel 成功合成了 $\\mathbf{N}$ 种不同的分子，每种分子都包含至少一个 Codium 原子和至少一个 Jamarium 原子，且不含其他元素。对于每种分子，她都知道其中每种元素的原子数。分子的分子量等于其所含所有原子的原子量之和。\n\n作为第一步，Muriel 按照分子量严格递增的顺序对这些分子进行了排序。现在她想找出 Codium 和 Jamarium 的原子量的所有可能整数取值对，使其与分子的排序一致。由于她知道可能存在多个满足条件的取值对，她希望找到 Codium 原子量最小的那一组。如果有多组 Codium 原子量相同，则选择 Jamarium 原子量最小的那一组。", "inputFormat": "输入的第一行是测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组测试数据的第一行为一个整数 $\\mathbf{N}$，表示分子的数量。接下来的 $\\mathbf{N}$ 行，每行包含两个整数 $\\mathbf{C_i}$ 和 $\\mathbf{J_i}$，分别表示第 $i$ 个分子中 Codium 和 Jamarium 的原子数。分子按分子量严格递增的顺序给出。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 若不存在满足条件的原子量整数对，则输出大写的 IMPOSSIBLE；否则输出两个整数 $c\\ j$，分别为 Codium 和 Jamarium 的原子量，且需满足上述最小化规则。", "hint": "**样例解释**\n\n在样例 1 中，最后两个分子的区别在于多了一个元素的原子。由于多一个 Codium 的分子整体更重，可以推断 Codium 的原子量大于 Jamarium。取 Codium 和 Jamarium 的原子量分别为 2 和 1 时，分子的分子量分别为 $1 \\times 2 + 1 \\times 1 = 3$，$1 \\times 2 + 2 \\times 1 = 4$，$2 \\times 2 + 1 \\times 1 = 5$，满足严格递增的顺序。由于 Codium 更重，2 是 Codium 的最小原子量，1 是 Jamarium 的最小原子量。\n\n设样例 2 中分子的分子量依次为 $a$、$b$、$c$ 和 $d$。根据原子数，有 $d = 2 \\times a$ 且 $c = 2 \\times b$。由 $a < b$ 可得 $d = 2 \\times a < 2 \\times b = c$，这意味着不存在一组原子量能使分子的分子量严格递增。\n\n在样例 3 中，分子的原子总数恰好严格递增。因此，令两种元素的原子量都为 1，可以使分子的分子量严格递增。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{N} \\leq 10$。\n- 对所有 $i \\neq j$，$(\\mathbf{C_i}, \\mathbf{J_i}) \\neq (\\mathbf{C_j}, \\mathbf{J_j})$（所有分子都不同）。\n\n**测试点 1（10 分，可见）**\n\n- 对所有 $i$，$1 \\leq \\mathbf{C_i} \\leq 100$。\n- 对所有 $i$，$1 \\leq \\mathbf{J_i} \\leq 100$。\n\n**测试点 2（16 分，隐藏）**\n\n- 对所有 $i$，$1 \\leq \\mathbf{C_i} \\leq 10^9$。\n- 对所有 $i$，$1 \\leq \\mathbf{J_i} \\leq 10^9$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13118", "type": "P", "difficulty": 6, "samples": [["3\n2\n1 2\n1 2\n1 0\n2\n1 2\n1 2\n0 0\n4\n2 4\n3 4\n2 4\n2 3\n10 10 10 10", "Case #1: UNBOUNDED\nCase #2: 0\nCase #3: 10"]], "limits": {"time": [20000, 20000, 20000, 20000], "memory": [1048576, 1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "图论", "2019", "拓扑排序", "强连通分量", "Google Code Jam"], "title": "[GCJ 2019 #2] Contransmutation", "background": "", "description": "Last year, we asked you to help us convert expensive metals into lead. (You do not need to know anything about the previous problem to solve this one.) But your country's leader is still greedy for more lead!\n\nThere are $\\mathbf{M}$ metals known in the world; lead is metal number 1 on your periodic table. Your country's leader has asked you to use the metals in the treasury to make as much lead as possible.\n\nFor each metal (including lead), you know exactly one formula that lets you destroy one gram of that metal and create one gram each of two metals. (It is best not to think too much about the principle of mass conservation!) Note that it is possible that the formula for the i-th metal might produce the i-th metal as one of the products. The formulas do not work with partial grams. However, you can use each formula as often as you would like (or not at all), as long as you have a gram of the required ingredient.\n\nIf you make optimal choices, what is the largest number of grams of lead you can end up with, or is it unbounded? If it is not unbounded: since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^9+7$ (that is, $1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with an integer $\\mathbf{M}$: the number of metals known in the world. Then there are $\\mathbf{M}$ more lines with two integers $\\mathbf{R_{i1}}$ and $\\mathbf{R_{i2}}$ each; the i-th of these lines, counting starting from 1, indicates that you can destroy one gram of metal i to create one gram of metal $\\mathbf{R_{i1}}$ and one gram of metal $\\mathbf{R_{i2}}$. Finally, there is one line with $\\mathbf{M}$ integers $\\mathbf{G_1}$, $\\mathbf{G_2}$, ..., $\\mathbf{G_M}$; $\\mathbf{G_i}$ is the number of grams of metal i in the treasury. Lead is metal 1.\n", "outputFormat": "For each test case, output one line containing `Case #x: y` where $x$ is the test case number (starting from 1). If there is no bound on the maximum amount of lead that can be produced, $y$ must be UNBOUNDED. Otherwise, $y$ must be the largest amount of lead, in grams, that you can end up with, modulo the prime $10^9+7$ (that is, $1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you have one formula that turns 1 gram of lead into 1 gram of lead and 1 gram of the second metal, and another formula that turns 1 gram of the second metal into 1 gram of lead and 1 gram of the second metal. You can alternate between these formulas to produce as much of both metals as you want.\n\nSample Case #2 has the same formulas as Sample Case #1, but you have no metals to start with!\n\nIn Sample Case #3, none of the formulas help you produce more lead, so you cannot end up with more lead than you started with.\n\n**Limits**\n\n- $1 \\leq \\mathbf{R_{i1}} < \\mathbf{R_{i2}} \\leq \\mathbf{M}$, for all $i$.\n\n**Test set 1 (7 Pts, Visible)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{M} \\leq 10$.\n- $0 \\leq \\mathbf{G_i} \\leq 10$, for all $i$.\n\n**Test set 2 (16 Pts, Hidden)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{M} \\leq 100$.\n- $0 \\leq \\mathbf{G_i} \\leq 10^9$, for all $i$.\n\n**Test set 3 (6 Pts, Hidden)**\n\n- $1 \\leq \\mathbf{T} \\leq 5$.\n- $2 \\leq \\mathbf{M} \\leq 10^5$.\n- $0 \\leq \\mathbf{G_i} \\leq 10^9$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #2] Contransmutation", "background": "", "description": "Last year, we asked you to help us convert expensive metals into lead. (You do not need to know anything about the previous problem to solve this one.) But your country's leader is still greedy for more lead!\n\nThere are $\\mathbf{M}$ metals known in the world; lead is metal number 1 on your periodic table. Your country's leader has asked you to use the metals in the treasury to make as much lead as possible.\n\nFor each metal (including lead), you know exactly one formula that lets you destroy one gram of that metal and create one gram each of two metals. (It is best not to think too much about the principle of mass conservation!) Note that it is possible that the formula for the i-th metal might produce the i-th metal as one of the products. The formulas do not work with partial grams. However, you can use each formula as often as you would like (or not at all), as long as you have a gram of the required ingredient.\n\nIf you make optimal choices, what is the largest number of grams of lead you can end up with, or is it unbounded? If it is not unbounded: since the output can be a really big number, we only ask you to output the remainder of dividing the result by the prime $10^9+7$ (that is, $1000000007$).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with an integer $\\mathbf{M}$: the number of metals known in the world. Then there are $\\mathbf{M}$ more lines with two integers $\\mathbf{R_{i1}}$ and $\\mathbf{R_{i2}}$ each; the i-th of these lines, counting starting from 1, indicates that you can destroy one gram of metal i to create one gram of metal $\\mathbf{R_{i1}}$ and one gram of metal $\\mathbf{R_{i2}}$. Finally, there is one line with $\\mathbf{M}$ integers $\\mathbf{G_1}$, $\\mathbf{G_2}$, ..., $\\mathbf{G_M}$; $\\mathbf{G_i}$ is the number of grams of metal i in the treasury. Lead is metal 1.\n", "outputFormat": "For each test case, output one line containing `Case #x: y` where $x$ is the test case number (starting from 1). If there is no bound on the maximum amount of lead that can be produced, $y$ must be UNBOUNDED. Otherwise, $y$ must be the largest amount of lead, in grams, that you can end up with, modulo the prime $10^9+7$ (that is, $1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, you have one formula that turns 1 gram of lead into 1 gram of lead and 1 gram of the second metal, and another formula that turns 1 gram of the second metal into 1 gram of lead and 1 gram of the second metal. You can alternate between these formulas to produce as much of both metals as you want.\n\nSample Case #2 has the same formulas as Sample Case #1, but you have no metals to start with!\n\nIn Sample Case #3, none of the formulas help you produce more lead, so you cannot end up with more lead than you started with.\n\n**Limits**\n\n- $1 \\leq \\mathbf{R_{i1}} < \\mathbf{R_{i2}} \\leq \\mathbf{M}$, for all $i$.\n\n**Test set 1 (7 Pts, Visible)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{M} \\leq 10$.\n- $0 \\leq \\mathbf{G_i} \\leq 10$, for all $i$.\n\n**Test set 2 (16 Pts, Hidden)**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{M} \\leq 100$.\n- $0 \\leq \\mathbf{G_i} \\leq 10^9$, for all $i$.\n\n**Test set 3 (6 Pts, Hidden)**\n\n- $1 \\leq \\mathbf{T} \\leq 5$.\n- $2 \\leq \\mathbf{M} \\leq 10^5$.\n- $0 \\leq \\mathbf{G_i} \\leq 10^9$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #2] Contransmutation", "background": null, "description": "去年，我们曾请你帮忙将昂贵的金属转化为铅。（你无需了解前一道题即可解答本题。）但你们国家的领导人依然贪婪地渴望获得更多的铅！\n\n世界上已知有 $\\mathbf{M}$ 种金属；在你的元素周期表上，铅是第 1 号金属。你们国家的领导人要求你利用国库中的金属，尽可能多地制造铅。\n\n对于每种金属（包括铅），你都知道恰好有一种配方，可以消耗 1 克该金属，并各生成 1 克另外两种金属。（关于质量守恒原理，最好不要深究！）注意，第 $i$ 种金属的配方可能会生成第 $i$ 种金属本身作为产物之一。配方不能对部分克数的金属起作用。然而，只要你拥有所需金属的 1 克，你可以任意多次（或不使用）使用每种配方。\n\n如果你做出最优选择，最终最多能获得多少克铅，或者说这个数量是否有限？如果答案有限，我们只要求你输出结果除以质数 $10^9+7$（即 $1000000007$）的余数。", "inputFormat": "输入的第一行是测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例首先有一行整数 $\\mathbf{M}$，表示已知的金属种类数。接下来有 $\\mathbf{M}$ 行，每行包含两个整数 $\\mathbf{R_{i1}}$ 和 $\\mathbf{R_{i2}}$；第 $i$ 行（从 1 开始计数）表示你可以消耗 1 克第 $i$ 种金属，生成 1 克第 $\\mathbf{R_{i1}}$ 种金属和 1 克第 $\\mathbf{R_{i2}}$ 种金属。最后一行包含 $\\mathbf{M}$ 个整数 $\\mathbf{G_1}, \\mathbf{G_2}, \\ldots, \\mathbf{G_M}$，其中 $\\mathbf{G_i}$ 表示国库中第 $i$ 种金属的克数。铅为第 1 号金属。", "outputFormat": "对于每组测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是你最终能获得的最大铅克数。如果最大铅克数没有上限，则 $y$ 必须为 UNBOUNDED。否则，$y$ 必须是你最终能获得的最大铅克数对质数 $10^9+7$（即 $1000000007$）取余的结果。", "hint": "**样例解释**\n\n在样例 1 中，你有一个配方可以将 1 克铅变为 1 克铅和 1 克第二种金属，另一个配方可以将 1 克第二种金属变为 1 克铅和 1 克第二种金属。你可以交替使用这两个配方，制造出任意多的两种金属。\n\n样例 2 的配方与样例 1 相同，但你一开始没有任何金属！\n\n样例 3 中，所有配方都无法帮助你制造更多的铅，因此你最终获得的铅不会超过初始拥有的数量。\n\n**数据范围**\n\n- 对所有 $i$，$1 \\leq \\mathbf{R_{i1}} < \\mathbf{R_{i2}} \\leq \\mathbf{M}$。\n\n**测试点 1（7 分，公开）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{M} \\leq 10$。\n- $0 \\leq \\mathbf{G_i} \\leq 10$。\n\n**测试点 2（16 分，隐藏）**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{M} \\leq 100$。\n- $0 \\leq \\mathbf{G_i} \\leq 10^9$。\n\n**测试点 3（6 分，隐藏）**\n\n- $1 \\leq \\mathbf{T} \\leq 5$。\n- $2 \\leq \\mathbf{M} \\leq 10^5$。\n- $0 \\leq \\mathbf{G_i} \\leq 10^9$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13119", "type": "P", "difficulty": 5, "samples": [["", ""]], "limits": {"time": [50000, 50000, 50000], "memory": [1048576, 1048576, 1048576]}, "tags": ["博弈论", "2019", "交互题", "Special Judge", "SG 函数", "Google Code Jam"], "title": "[GCJ 2019 #3] Zillionim", "background": "", "description": "Zillionim is a turn-based game for two players. Initially, $10^{12}$ coins are arranged end-to-end in a single line, numbered from 1 to $10^{12}$ from left to right. During a turn, a player must select $10^{10}$ consecutive coins and remove them. Two coins that were not originally consecutive do not become consecutive even if all of the coins in between them are removed.\n\nOn their turn, a player makes a valid move if possible, and then it is their opponent's turn. If a player cannot make a valid move on their turn, they lose the game (and the opponent wins the game).\n\nBecause our engineers are still hard at work training our machine learning model to play Zillionim, we have created a simple AI that plays Zillionim by making random moves. The AI always gets the first turn. On each of the AI's turns, the AI determines all valid moves and chooses one of them uniformly at random.\n\nCan you beat this AI... at least most of the time?\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing two integers $\\mathbf{T}$, the number of test cases, and $\\mathbf{W}$, the minimum number of games you need to win for your solution to be considered correct. Then, you need to process $\\mathbf{T}$ test cases, each of which is a single game of Zillionim.\n\nEach test case is processed by making exchanges with the judge until one player wins the game. For each exchange, the judge first outputs a single line with a single integer $\\mathbf{P}$, to be interpreted as follows:\n\n* If $1 \\leq \\mathbf{P} \\leq 10^{12} - 10^{10} + 1$, then the AI has removed coins numbered $\\mathbf{P}$, $\\mathbf{P} + 1$, ..., $\\mathbf{P} + 10^{10} - 1$ and it is your turn. Note that this means there is at least one valid move remaining for you to play. The AI always plays a valid move.\n* If $\\mathbf{P} = -2$, your last move caused you to win the current game.\n* If $\\mathbf{P} = -3$, the AI has made a move that caused it to win the current game. Notice that in this case, the judge does not send you the AI's last move.\n* If $\\mathbf{P} = -1$, the last information you sent to the judge was malformed data or an invalid move (out of range or attempting to remove coins that were not there), meaning that you will get a Wrong Answer verdict for not playing correctly (more below).\n\nAfter receiving a positive integer $\\mathbf{P}$, you should send back a single line with a positive integer $\\mathbf{Q}$ ($1 \\leq \\mathbf{Q} \\leq 10^{12} - 10^{10} + 1$) representing that you are removing coins numbered $\\mathbf{Q}$, $\\mathbf{Q} + 1$, ..., $\\mathbf{Q} + 10^{10} - 1$. Each of these coins must not have been previously removed during the current game.\n\nAfter the judge sends a -2 or -3, if it was the last game, the judge will terminate and so should your program. Otherwise, the judge will proceed to send data corresponding to the first exchange of the next game. The judge will not check how many games you have won or lost until all games have been processed correctly. For example, if you win $\\mathbf{T} - 1$ games and then send malformed data during the last game, you will receive a Wrong Answer verdict, regardless of the value of $\\mathbf{W}$.\n\nAfter receiving a -1, your program should terminate to receive a Wrong Answer verdict. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit normally and within the time limit to receive a Wrong Answer verdict instead of a Runtime Error or Time Limit Exceeded.\n\nThe seed for the random generator is predetermined (and is different) for each game. This means that two submissions that make the exact same sequence of moves in a given game will receive the exact same sequence of moves from the AI for that game. It also means the play of the AI in a game does not depend, even in the pseudo-random generation sense, on the plays made in previous games within the same test set.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nFor simplicity, the following interaction uses 50 coins in total instead of $10^{12}$, and each move removes 10 consecutive coins instead of $10^{10}$. The rules are otherwise the same.\n\n```\n  t, w = readline_int_list()   // reads 500 into t and 300 into w\n  p = readline_int()           // reads 23 into p; this is the beginning of the first game. The\n                               //   AI has taken coins 23 through 32, inclusive.\n  printline 38 to stdout       // we decide to take coins 38 through 47, inclusive\n  flush stdout\n  p = readline_int()           // reads 3 into p. The AI has taken coins 3 through 12, inclusive.\n  printline 13 to stdout       // we decide to take coins 13 through 22, inclusive\n                               //  (and this is our only remaining move!)\n  flush stdout\n  p = readline_int()           // reads -2 into p. We won the first game since the AI had no move.\n  p = readline_int()           // reads 32 into p; this is the beginning of the second game. The\n                               //   AI has taken coins 32 through 41, inclusive.\n  printline 13 to stdout       // we decide to take coins 13 through 22, inclusive\n  flush stdout\n  p = readline_int()           // reads -3 into p. We don't know the AI's move, but it left us\n                               //   with no valid move, so we lost the second game.\n  p = readline_int()           // reads 10 into p; this is the beginning of the third game. The\n                               //   AI has taken coins 10 through 19, inclusive.\n  printline 0 to stdout        // we select an invalid index (coin numbering starts at 1!)\n  flush stdout\n  p = readline_int()           // reads -1 into p -- we have made a mistake!\n  exit                         // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $\\mathbf{T} = 500$.\n- $-3 \\leq \\mathbf{P} \\leq 10^{12} - 10^{10} + 1$.\n- $\\mathbf{P} \\neq 0$.\n- $\\mathbf{P}$ represents a valid play or valid information about the game's status, as explained above.\n\n**Test set 1 (1 Pt, Visible)**\n\n- $\\mathbf{W} = 300$.\n\n**Test set 2 (5 Pts, Visible)**\n\n- $\\mathbf{W} = 475$.\n\n**Test set 3 (6 Pts, Visible)**\n\n- $\\mathbf{W} = 499$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #3] Zillionim", "background": "", "description": "Zillionim is a turn-based game for two players. Initially, $10^{12}$ coins are arranged end-to-end in a single line, numbered from 1 to $10^{12}$ from left to right. During a turn, a player must select $10^{10}$ consecutive coins and remove them. Two coins that were not originally consecutive do not become consecutive even if all of the coins in between them are removed.\n\nOn their turn, a player makes a valid move if possible, and then it is their opponent's turn. If a player cannot make a valid move on their turn, they lose the game (and the opponent wins the game).\n\nBecause our engineers are still hard at work training our machine learning model to play Zillionim, we have created a simple AI that plays Zillionim by making random moves. The AI always gets the first turn. On each of the AI's turns, the AI determines all valid moves and chooses one of them uniformly at random.\n\nCan you beat this AI... at least most of the time?\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing two integers $\\mathbf{T}$, the number of test cases, and $\\mathbf{W}$, the minimum number of games you need to win for your solution to be considered correct. Then, you need to process $\\mathbf{T}$ test cases, each of which is a single game of Zillionim.\n\nEach test case is processed by making exchanges with the judge until one player wins the game. For each exchange, the judge first outputs a single line with a single integer $\\mathbf{P}$, to be interpreted as follows:\n\n* If $1 \\leq \\mathbf{P} \\leq 10^{12} - 10^{10} + 1$, then the AI has removed coins numbered $\\mathbf{P}$, $\\mathbf{P} + 1$, ..., $\\mathbf{P} + 10^{10} - 1$ and it is your turn. Note that this means there is at least one valid move remaining for you to play. The AI always plays a valid move.\n* If $\\mathbf{P} = -2$, your last move caused you to win the current game.\n* If $\\mathbf{P} = -3$, the AI has made a move that caused it to win the current game. Notice that in this case, the judge does not send you the AI's last move.\n* If $\\mathbf{P} = -1$, the last information you sent to the judge was malformed data or an invalid move (out of range or attempting to remove coins that were not there), meaning that you will get a Wrong Answer verdict for not playing correctly (more below).\n\nAfter receiving a positive integer $\\mathbf{P}$, you should send back a single line with a positive integer $\\mathbf{Q}$ ($1 \\leq \\mathbf{Q} \\leq 10^{12} - 10^{10} + 1$) representing that you are removing coins numbered $\\mathbf{Q}$, $\\mathbf{Q} + 1$, ..., $\\mathbf{Q} + 10^{10} - 1$. Each of these coins must not have been previously removed during the current game.\n\nAfter the judge sends a -2 or -3, if it was the last game, the judge will terminate and so should your program. Otherwise, the judge will proceed to send data corresponding to the first exchange of the next game. The judge will not check how many games you have won or lost until all games have been processed correctly. For example, if you win $\\mathbf{T} - 1$ games and then send malformed data during the last game, you will receive a Wrong Answer verdict, regardless of the value of $\\mathbf{W}$.\n\nAfter receiving a -1, your program should terminate to receive a Wrong Answer verdict. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit normally and within the time limit to receive a Wrong Answer verdict instead of a Runtime Error or Time Limit Exceeded.\n\nThe seed for the random generator is predetermined (and is different) for each game. This means that two submissions that make the exact same sequence of moves in a given game will receive the exact same sequence of moves from the AI for that game. It also means the play of the AI in a game does not depend, even in the pseudo-random generation sense, on the plays made in previous games within the same test set.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nFor simplicity, the following interaction uses 50 coins in total instead of $10^{12}$, and each move removes 10 consecutive coins instead of $10^{10}$. The rules are otherwise the same.\n\n```\n  t, w = readline_int_list()   // reads 500 into t and 300 into w\n  p = readline_int()           // reads 23 into p; this is the beginning of the first game. The\n                               //   AI has taken coins 23 through 32, inclusive.\n  printline 38 to stdout       // we decide to take coins 38 through 47, inclusive\n  flush stdout\n  p = readline_int()           // reads 3 into p. The AI has taken coins 3 through 12, inclusive.\n  printline 13 to stdout       // we decide to take coins 13 through 22, inclusive\n                               //  (and this is our only remaining move!)\n  flush stdout\n  p = readline_int()           // reads -2 into p. We won the first game since the AI had no move.\n  p = readline_int()           // reads 32 into p; this is the beginning of the second game. The\n                               //   AI has taken coins 32 through 41, inclusive.\n  printline 13 to stdout       // we decide to take coins 13 through 22, inclusive\n  flush stdout\n  p = readline_int()           // reads -3 into p. We don't know the AI's move, but it left us\n                               //   with no valid move, so we lost the second game.\n  p = readline_int()           // reads 10 into p; this is the beginning of the third game. The\n                               //   AI has taken coins 10 through 19, inclusive.\n  printline 0 to stdout        // we select an invalid index (coin numbering starts at 1!)\n  flush stdout\n  p = readline_int()           // reads -1 into p -- we have made a mistake!\n  exit                         // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $\\mathbf{T} = 500$.\n- $-3 \\leq \\mathbf{P} \\leq 10^{12} - 10^{10} + 1$.\n- $\\mathbf{P} \\neq 0$.\n- $\\mathbf{P}$ represents a valid play or valid information about the game's status, as explained above.\n\n**Test set 1 (1 Pt, Visible)**\n\n- $\\mathbf{W} = 300$.\n\n**Test set 2 (5 Pts, Visible)**\n\n- $\\mathbf{W} = 475$.\n\n**Test set 3 (6 Pts, Visible)**\n\n- $\\mathbf{W} = 499$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #3] Zillionim", "background": null, "description": "Zillionim 是一个由两名玩家轮流进行的回合制游戏。最初，$10^{12}$ 枚硬币首尾相连排成一行，从左到右编号为 $1$ 到 $10^{12}$。每一回合，玩家必须选择 $10^{10}$ 枚连续的硬币并将其移除。即使中间的硬币被移除，原本不相邻的两枚硬币也不会变得相邻。\n\n在自己的回合，玩家如果可以，则必须进行一次合法操作，然后轮到对手。如果某位玩家在自己的回合无法进行合法操作，则该玩家输掉本局游戏（对手获胜）。\n\n由于我们的工程师仍在努力训练我们的机器学习模型来玩 Zillionim，我们为 Zillionim 创建了一个简单的 AI，它会随机进行操作。AI 总是先手。在每次 AI 的回合，AI 会确定所有合法操作，并从中均匀随机选择一个。\n\n你能击败这个 AI 吗……至少大多数时候？\n\n### 交互协议\n\n本题为交互题。\n\n最开始，你的程序应读取一行包含两个整数 $\\mathbf{T}$（测试用例数量）和 $\\mathbf{W}$（你的解答被判为正确所需赢下的最少局数）。然后，你需要处理 $\\mathbf{T}$ 个测试用例，每个用例即为一局 Zillionim 游戏。\n\n每个测试用例通过与评测器的多轮交互进行，直到某一方获胜。每轮交互中，评测器首先输出一行，内容为一个整数 $\\mathbf{P}$，含义如下：\n\n- 如果 $1 \\leq \\mathbf{P} \\leq 10^{12} - 10^{10} + 1$，则表示 AI 移除了编号为 $\\mathbf{P}$ 到 $\\mathbf{P} + 10^{10} - 1$ 的硬币，现在轮到你。注意，这意味着你至少还有一个合法操作可以进行。AI 总是会进行合法操作。\n- 如果 $\\mathbf{P} = -2$，表示你上一次操作后赢得了本局游戏。\n- 如果 $\\mathbf{P} = -3$，表示 AI 上一次操作后赢得了本局游戏。注意此时评测器不会告知你 AI 的最后一步操作。\n- 如果 $\\mathbf{P} = -1$，表示你上一次发送给评测器的信息有误（数据格式错误、操作越界或试图移除已被移除的硬币），你将因未正确操作而被判为 Wrong Answer（见下文）。\n\n在收到正整数 $\\mathbf{P}$ 后，你应输出一行，内容为正整数 $\\mathbf{Q}$（$1 \\leq \\mathbf{Q} \\leq 10^{12} - 10^{10} + 1$），表示你要移除编号为 $\\mathbf{Q}$ 到 $\\mathbf{Q} + 10^{10} - 1$ 的硬币。你移除的这些硬币必须在当前局中尚未被移除。\n\n当评测器发送 $-2$ 或 $-3$ 后，如果这是最后一局，评测器会终止，你的程序也应随之终止。否则，评测器会继续发送下一局的首轮数据。在所有局都正确处理完毕前，评测器不会检查你赢了多少局。例如，如果你赢了 $\\mathbf{T} - 1$ 局，但在最后一局发送了错误数据，你将被判为 Wrong Answer，无论 $\\mathbf{W}$ 的值是多少。\n\n收到 $-1$ 后，你的程序应立即终止以获得 Wrong Answer 判定。如果收到 $-1$ 后仍继续等待评测器数据，你的程序将因超时被判为 Time Limit Exceeded。请注意，程序应自行正常退出，以获得 Wrong Answer 而不是 Runtime Error 或 Time Limit Exceeded。\n\n每一局的随机数种子是预先设定且互不相同的。这意味着，如果两份提交在同一局中做出完全相同的操作序列，将收到 AI 完全相同的操作序列。AI 在一局中的操作不会受到同一测试集内前几局操作的影响（即伪随机生成器的状态是独立的）。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**交互样例**\n\n为简化说明，以下交互样例假设总共有 $50$ 枚硬币，每次移除 $10$ 枚连续硬币，其余规则与原题一致。\n\n```\n  t, w = readline_int_list()   // 读取 t=500, w=300\n  p = readline_int()           // 读取 p=23，表示第一局 AI 移除了 23~32 号硬币\n  printline 38 to stdout       // 我们选择移除 38~47 号硬币\n  flush stdout\n  p = readline_int()           // 读取 p=3，AI 移除了 3~12 号硬币\n  printline 13 to stdout       // 我们选择移除 13~22 号硬币（这是我们唯一剩下的合法操作）\n  flush stdout\n  p = readline_int()           // 读取 p=-2，表示我们赢了第一局\n  p = readline_int()           // 读取 p=32，第二局开始，AI 移除了 32~41 号硬币\n  printline 13 to stdout       // 我们选择移除 13~22 号硬币\n  flush stdout\n  p = readline_int()           // 读取 p=-3，AI 获胜，我们无法操作\n  p = readline_int()           // 读取 p=10，第三局开始，AI 移除了 10~19 号硬币\n  printline 0 to stdout        // 我们选择了非法下标（硬币编号从 1 开始！）\n  flush stdout\n  p = readline_int()           // 读取 p=-1，表示我们操作有误\n  exit                         // 立即退出，避免超时\n```\n\n你可以使用本题的测试工具在本地或平台上进行测试。若在本地测试，你需要让测试工具与自己的代码并行运行；可使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释。\n\n测试工具的使用说明已包含在工具文件的注释中。我们鼓励你自行添加测试用例。请注意，测试工具旨在模拟评测系统，但**并非**真实评测系统，可能存在行为差异。\n\n**数据范围**\n\n- $\\mathbf{T} = 500$。\n- $-3 \\leq \\mathbf{P} \\leq 10^{12} - 10^{10} + 1$。\n- $\\mathbf{P} \\neq 0$。\n- $\\mathbf{P}$ 表示一次合法操作或游戏状态信息，详见上文。\n\n**测试点 1（1 分，公开）**\n\n- $\\mathbf{W} = 300$。\n\n**测试点 2（5 分，公开）**\n\n- $\\mathbf{W} = 475$。\n\n**测试点 3（6 分，公开）**\n\n- $\\mathbf{W} = 499$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13120", "type": "P", "difficulty": 5, "samples": [["3\n3\n2 1 2\n5\n1 6 2 5 7\n4\n1000000000 1 1 1000000000", "Case #1: 1\nCase #2: 16\nCase #3: 999999991"]], "limits": {"time": [30000, 30000, 30000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2019", "单调栈", "Google Code Jam"], "title": "[GCJ 2019 #3] Pancake Pyramid", "background": "", "description": "You have just finished cooking for some diners at the Infinite House of Pancakes. There are $\\mathbf{S}$ stacks of pancakes in all, and you have arranged them in a line, such that the i-th stack from the left (counting starting from 1) has $\\mathbf{P}_\\mathbf{i}$ pancakes.\n\nYour supervisor was about to bring out the stacks to the customers, but then it occurred to her that a picture of the stacks might make for a good advertisement. However, she is worried that there might be too many stacks, so she intends to remove the $\\mathbf{L}$ leftmost stacks and the $\\mathbf{R}$ rightmost stacks, where $\\mathbf{L}$ and $\\mathbf{R}$ are nonnegative integers such that $\\mathbf{L} + \\mathbf{R} \\leq \\mathbf{S} - 3$. (Notice that at least 3 stacks of pancakes will remain after the removal.)\n\nYour supervisor also thinks the remaining stacks will look aesthetically pleasing if they have the pyramid property. A sequence of $\\mathbf{N}$ stacks of heights $\\mathbf{H}_1, \\mathbf{H}_2, \\ldots, \\mathbf{H}_\\mathbf{N}$ has the pyramid property if there exists an integer $\\mathbf{j}$ ($1 \\leq \\mathbf{j} \\leq \\mathbf{N}$) such that $\\mathbf{H}_1 \\leq \\mathbf{H}_2 \\leq \\ldots \\leq \\mathbf{H}_{\\mathbf{j}-1} \\leq \\mathbf{H}_\\mathbf{j}$ and $\\mathbf{H}_\\mathbf{j} \\geq \\mathbf{H}_{\\mathbf{j}+1} \\geq \\ldots \\geq \\mathbf{H}_{\\mathbf{N}-1} \\geq \\mathbf{H}_\\mathbf{N}$. (It is possible that this sequence might not look much like a typical \"pyramid\" — a group of stacks of the same size has the pyramid property, and so does a group in which the stack heights are nondecreasing from left to right, among other examples.)\n\nNote that the sequence of stacks remaining after your supervisor removes the $\\mathbf{L}$ leftmost and $\\mathbf{R}$ rightmost stacks might not yet have the pyramid property... but you can fix that by adding pancakes to one or more of the stacks! The pyramidification cost of a sequence of stacks is the minimum total number of pancakes that must be added to stacks to give the sequence the pyramid property.\n\nWhile your manager is carefully deciding which values of $\\mathbf{L}$ and $\\mathbf{R}$ to choose, you have started to wonder what the sum of the pyramidification costs over all valid choices of $\\mathbf{L}$ and $\\mathbf{R}$ is. Compute this sum, modulo the prime $10^9+7$ ($1000000007$).\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line containing one integer $\\mathbf{S}$: the number of stacks of pancakes. Then, there is one more line containing $\\mathbf{S}$ integers $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots, \\mathbf{P}_\\mathbf{S}$. The i-th of these is the number of pancakes in the i-th stack from the left.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the sum of the pyramidification costs over all valid choices of $\\mathbf{L}$ and $\\mathbf{R}$, modulo the prime $10^9+7$ ($1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, your supervisor must choose $\\mathbf{L} = 0$ and $\\mathbf{R} = 0$, so that is the only scenario you need to consider. The optimal strategy for that scenario is to add a single pancake to the middle stack. Although the resulting sequence of stacks looks flat, notice that it has the pyramid property; in fact, any index will work as the $\\mathbf{j}$ value.\n\nIn Sample Case #2, here are all possible choices of $\\mathbf{L}$ and $\\mathbf{R}$, the corresponding remaining stacks, and what you should do in each scenario.\n\n* $\\mathbf{L} = 0$, $\\mathbf{R} = 0$: $\\mathbf{H} = [1 \\ 6 \\ 2 \\ 5 \\ 7]$. The optimal solution is to add four pancakes to the third stack and one pancake to the fourth stack. Then we have $[1 \\ 6 \\ 6 \\ 6 \\ 7]$, which has the pyramid property with $\\mathbf{j} = 5$.\n* $\\mathbf{L} = 0$, $\\mathbf{R} = 1$: $\\mathbf{H} = [1 \\ 6 \\ 2 \\ 5]$. The optimal solution is to add three pancakes to the third stack. Then we have $[1 \\ 6 \\ 5 \\ 5]$, which has the pyramid property with $\\mathbf{j} = 2$.\n* $\\mathbf{L} = 0$, $\\mathbf{R} = 2$: $\\mathbf{H} = [1 \\ 6 \\ 2]$. This already has the pyramid property with $\\mathbf{j} = 2$.\n* $\\mathbf{L} = 1$, $\\mathbf{R} = 0$: $\\mathbf{H} = [6 \\ 2 \\ 5 \\ 7]$. The optimal solution is to add four pancakes to the second stack and one pancake to the third stack. Then we have $[6 \\ 6 \\ 6 \\ 7]$, which has the pyramid property with $\\mathbf{j} = 4$.\n* $\\mathbf{L} = 1$, $\\mathbf{R} = 1$: $\\mathbf{H} = [6 \\ 2 \\ 5]$. The optimal solution is to add three pancakes to the second stack. Then we have $[6 \\ 5 \\ 5]$, which has the pyramid property with $\\mathbf{j} = 1$.\n* $\\mathbf{L} = 2$, $\\mathbf{R} = 0$: $\\mathbf{H} = [2 \\ 5 \\ 7]$. This already has the pyramid property with $\\mathbf{j} = 3$.\n\nSo the answer is $(5 + 3 + 0 + 5 + 3 + 0)$ modulo $(10^9 + 7)$, which is $16$.\n\nIn Sample Case #3, we only need to add extra pancakes to create the pyramid property when $\\mathbf{L} = 0$ and $\\mathbf{R} = 0$. In that case, it is optimal to add $999999999$ pancakes to each of the second and third stacks. (We hope the diners are hungry!) So the answer is $(999999999 + 999999999)$ modulo $(10^9 + 7) = 999999991$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{P}_\\mathbf{i} \\leq 10^9$, for all $\\mathbf{i}$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $\\mathbf{S} = 3000$, for up to 20 test cases.\n- $3 \\leq \\mathbf{S} \\leq 500$, for all remaining cases.\n\n**Test set 2 (17 Pts, Hidden)**\n\n- $\\mathbf{S} = 10^6$, for up to 1 test case.\n- $\\mathbf{S} = 10^5$, for up to 3 test cases.\n- $3 \\leq \\mathbf{S} \\leq 10000$, for all remaining cases.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #3] Pancake Pyramid", "background": "", "description": "You have just finished cooking for some diners at the Infinite House of Pancakes. There are $\\mathbf{S}$ stacks of pancakes in all, and you have arranged them in a line, such that the i-th stack from the left (counting starting from 1) has $\\mathbf{P}_\\mathbf{i}$ pancakes.\n\nYour supervisor was about to bring out the stacks to the customers, but then it occurred to her that a picture of the stacks might make for a good advertisement. However, she is worried that there might be too many stacks, so she intends to remove the $\\mathbf{L}$ leftmost stacks and the $\\mathbf{R}$ rightmost stacks, where $\\mathbf{L}$ and $\\mathbf{R}$ are nonnegative integers such that $\\mathbf{L} + \\mathbf{R} \\leq \\mathbf{S} - 3$. (Notice that at least 3 stacks of pancakes will remain after the removal.)\n\nYour supervisor also thinks the remaining stacks will look aesthetically pleasing if they have the pyramid property. A sequence of $\\mathbf{N}$ stacks of heights $\\mathbf{H}_1, \\mathbf{H}_2, \\ldots, \\mathbf{H}_\\mathbf{N}$ has the pyramid property if there exists an integer $\\mathbf{j}$ ($1 \\leq \\mathbf{j} \\leq \\mathbf{N}$) such that $\\mathbf{H}_1 \\leq \\mathbf{H}_2 \\leq \\ldots \\leq \\mathbf{H}_{\\mathbf{j}-1} \\leq \\mathbf{H}_\\mathbf{j}$ and $\\mathbf{H}_\\mathbf{j} \\geq \\mathbf{H}_{\\mathbf{j}+1} \\geq \\ldots \\geq \\mathbf{H}_{\\mathbf{N}-1} \\geq \\mathbf{H}_\\mathbf{N}$. (It is possible that this sequence might not look much like a typical \"pyramid\" — a group of stacks of the same size has the pyramid property, and so does a group in which the stack heights are nondecreasing from left to right, among other examples.)\n\nNote that the sequence of stacks remaining after your supervisor removes the $\\mathbf{L}$ leftmost and $\\mathbf{R}$ rightmost stacks might not yet have the pyramid property... but you can fix that by adding pancakes to one or more of the stacks! The pyramidification cost of a sequence of stacks is the minimum total number of pancakes that must be added to stacks to give the sequence the pyramid property.\n\nWhile your manager is carefully deciding which values of $\\mathbf{L}$ and $\\mathbf{R}$ to choose, you have started to wonder what the sum of the pyramidification costs over all valid choices of $\\mathbf{L}$ and $\\mathbf{R}$ is. Compute this sum, modulo the prime $10^9+7$ ($1000000007$).\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line containing one integer $\\mathbf{S}$: the number of stacks of pancakes. Then, there is one more line containing $\\mathbf{S}$ integers $\\mathbf{P}_1, \\mathbf{P}_2, \\ldots, \\mathbf{P}_\\mathbf{S}$. The i-th of these is the number of pancakes in the i-th stack from the left.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the sum of the pyramidification costs over all valid choices of $\\mathbf{L}$ and $\\mathbf{R}$, modulo the prime $10^9+7$ ($1000000007$).", "hint": "**Sample Explanation**\n\nIn Sample Case #1, your supervisor must choose $\\mathbf{L} = 0$ and $\\mathbf{R} = 0$, so that is the only scenario you need to consider. The optimal strategy for that scenario is to add a single pancake to the middle stack. Although the resulting sequence of stacks looks flat, notice that it has the pyramid property; in fact, any index will work as the $\\mathbf{j}$ value.\n\nIn Sample Case #2, here are all possible choices of $\\mathbf{L}$ and $\\mathbf{R}$, the corresponding remaining stacks, and what you should do in each scenario.\n\n* $\\mathbf{L} = 0$, $\\mathbf{R} = 0$: $\\mathbf{H} = [1 \\ 6 \\ 2 \\ 5 \\ 7]$. The optimal solution is to add four pancakes to the third stack and one pancake to the fourth stack. Then we have $[1 \\ 6 \\ 6 \\ 6 \\ 7]$, which has the pyramid property with $\\mathbf{j} = 5$.\n* $\\mathbf{L} = 0$, $\\mathbf{R} = 1$: $\\mathbf{H} = [1 \\ 6 \\ 2 \\ 5]$. The optimal solution is to add three pancakes to the third stack. Then we have $[1 \\ 6 \\ 5 \\ 5]$, which has the pyramid property with $\\mathbf{j} = 2$.\n* $\\mathbf{L} = 0$, $\\mathbf{R} = 2$: $\\mathbf{H} = [1 \\ 6 \\ 2]$. This already has the pyramid property with $\\mathbf{j} = 2$.\n* $\\mathbf{L} = 1$, $\\mathbf{R} = 0$: $\\mathbf{H} = [6 \\ 2 \\ 5 \\ 7]$. The optimal solution is to add four pancakes to the second stack and one pancake to the third stack. Then we have $[6 \\ 6 \\ 6 \\ 7]$, which has the pyramid property with $\\mathbf{j} = 4$.\n* $\\mathbf{L} = 1$, $\\mathbf{R} = 1$: $\\mathbf{H} = [6 \\ 2 \\ 5]$. The optimal solution is to add three pancakes to the second stack. Then we have $[6 \\ 5 \\ 5]$, which has the pyramid property with $\\mathbf{j} = 1$.\n* $\\mathbf{L} = 2$, $\\mathbf{R} = 0$: $\\mathbf{H} = [2 \\ 5 \\ 7]$. This already has the pyramid property with $\\mathbf{j} = 3$.\n\nSo the answer is $(5 + 3 + 0 + 5 + 3 + 0)$ modulo $(10^9 + 7)$, which is $16$.\n\nIn Sample Case #3, we only need to add extra pancakes to create the pyramid property when $\\mathbf{L} = 0$ and $\\mathbf{R} = 0$. In that case, it is optimal to add $999999999$ pancakes to each of the second and third stacks. (We hope the diners are hungry!) So the answer is $(999999999 + 999999999)$ modulo $(10^9 + 7) = 999999991$.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $1 \\leq \\mathbf{P}_\\mathbf{i} \\leq 10^9$, for all $\\mathbf{i}$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $\\mathbf{S} = 3000$, for up to 20 test cases.\n- $3 \\leq \\mathbf{S} \\leq 500$, for all remaining cases.\n\n**Test set 2 (17 Pts, Hidden)**\n\n- $\\mathbf{S} = 10^6$, for up to 1 test case.\n- $\\mathbf{S} = 10^5$, for up to 3 test cases.\n- $3 \\leq \\mathbf{S} \\leq 10000$, for all remaining cases.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #3] Pancake Pyramid", "background": null, "description": "你刚刚在“无限煎饼屋”为一些食客完成了烹饪。总共有 $S$ 堆煎饼，你将它们排成一行，第 $i$ 堆（从左到右，从 1 开始计数）有 $P_i$ 张煎饼。\n\n你的主管正准备把这些煎饼端给顾客，但她突然想到，给这些煎饼堆拍一张照片可能会成为很好的广告。不过，她担心煎饼堆太多，于是打算移除最左边的 $L$ 堆和最右边的 $R$ 堆，其中 $L$ 和 $R$ 是非负整数，满足 $L + R \\leq S - 3$。也就是说，移除后至少还会剩下 3 堆煎饼。\n\n你的主管还认为，剩下的煎饼堆如果满足“金字塔属性”会更美观。对于一组高度为 $H_1, H_2, \\ldots, H_N$ 的 $N$ 堆煎饼，如果存在一个整数 $j$（$1 \\leq j \\leq N$），使得 $H_1 \\leq H_2 \\leq \\ldots \\leq H_{j-1} \\leq H_j$ 且 $H_j \\geq H_{j+1} \\geq \\ldots \\geq H_{N-1} \\geq H_N$，那么这组煎饼堆就具有金字塔属性。（注意，这样的序列不一定看起来像传统的“金字塔”——比如所有堆高度相同的序列也满足金字塔属性，或者高度从左到右单调不减的序列也满足。）\n\n注意，经过移除 $L$ 个最左和 $R$ 个最右的煎饼堆后，剩下的序列可能还不满足金字塔属性……但你可以通过给某些堆添加煎饼来修正！一组煎饼堆的“金字塔化代价”定义为：使该序列满足金字塔属性所需添加的煎饼总数的最小值。\n\n当你的主管还在仔细考虑 $L$ 和 $R$ 的取值时，你开始思考：所有合法的 $L$ 和 $R$ 取值下，金字塔化代价之和是多少？请计算这个和，并对质数 $10^9+7$（$1000000007$）取模。", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试用例。每组测试用例的第一行为一个整数 $S$，表示煎饼堆的数量。接下来一行有 $S$ 个整数 $P_1, P_2, \\ldots, P_S$，第 $i$ 个数表示从左到右第 $i$ 堆煎饼的数量。", "outputFormat": "对于每组测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是所有合法 $L$ 和 $R$ 取值下金字塔化代价之和，对 $10^9+7$ 取模后的结果。", "hint": "**样例解释**\n\n在样例 1 中，你的主管只能选择 $L=0$ 且 $R=0$，所以只需考虑这一种情况。最优策略是给中间那一堆加一张煎饼。虽然最终序列看起来是平的，但它满足金字塔属性；实际上，任何一个位置都可以作为 $j$。\n\n在样例 2 中，所有可能的 $L$ 和 $R$ 取值、剩余的煎饼堆序列及最优操作如下：\n\n- $L=0$，$R=0$：$H=[1\\ 6\\ 2\\ 5\\ 7]$。最优解是给第三堆加 4 张煎饼，第四堆加 1 张煎饼，得到 $[1\\ 6\\ 6\\ 6\\ 7]$，此时 $j=5$。\n- $L=0$，$R=1$：$H=[1\\ 6\\ 2\\ 5]$。最优解是给第三堆加 3 张煎饼，得到 $[1\\ 6\\ 5\\ 5]$，此时 $j=2$。\n- $L=0$，$R=2$：$H=[1\\ 6\\ 2]$。本身就满足金字塔属性，$j=2$。\n- $L=1$，$R=0$：$H=[6\\ 2\\ 5\\ 7]$。最优解是给第二堆加 4 张煎饼，第三堆加 1 张煎饼，得到 $[6\\ 6\\ 6\\ 7]$，此时 $j=4$。\n- $L=1$，$R=1$：$H=[6\\ 2\\ 5]$。最优解是给第二堆加 3 张煎饼，得到 $[6\\ 5\\ 5]$，此时 $j=1$。\n- $L=2$，$R=0$：$H=[2\\ 5\\ 7]$。本身就满足金字塔属性，$j=3$。\n\n因此答案为 $(5 + 3 + 0 + 5 + 3 + 0)$ 对 $(10^9 + 7)$ 取模，即 $16$。\n\n在样例 3 中，只有 $L=0$ 且 $R=0$ 时需要额外加煎饼使其满足金字塔属性。在这种情况下，最优解是给第二堆和第三堆各加 $999999999$ 张煎饼。（希望食客们胃口够大！）所以答案为 $(999999999 + 999999999)$ 对 $(10^9 + 7)$ 取模，结果为 $999999991$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- 对所有 $i$，$1 \\leq P_i \\leq 10^9$。\n\n**测试点 1（5 分，公开）**\n\n- $S = 3000$，最多 20 组测试用例。\n- 其余测试用例满足 $3 \\leq S \\leq 500$。\n\n**测试点 2（17 分，隐藏）**\n\n- $S = 10^6$，最多 1 组测试用例。\n- $S = 10^5$，最多 3 组测试用例。\n- 其余测试用例满足 $3 \\leq S \\leq 10000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13121", "type": "P", "difficulty": 6, "samples": [["3\n2 2\nAB\nBA\n2 3\nAAB\nABB\n3 4\nBBAA\nBABA\nBBAA", "Case #1: IMPOSSIBLE\nCase #2: POSSIBLE\n..\nCase #3: POSSIBLE\n//\\\n.//"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2019", "并查集", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 #3] Datacenter Duplex", "background": "", "description": "Two companies, Apricot Rules LLC and Banana Rocks Inc., are sharing the same datacenter. The datacenter is a matrix of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns, with each cell containing a single server tower. Each tower contains intellectual property belonging to exactly one of the two companies.\n\nAt first, they built walls on the edges between cells assigned to different companies. This allowed orthogonally adjacent cells belonging to the same company to remain connected. Also, two cells $\\mathbf{x}$ and $\\mathbf{y}$ are considered connected if $\\mathbf{x}$ is connected to a cell that is, directly or indirectly, connected to $\\mathbf{y}$. With this definition, it was possible that two cells assigned to the same company were not connected, which was unacceptable.\n\nBoth companies agreed to build narrow hallways running through cell corners that allow two diagonally adjacent cells to be connected directly. Let us write $(\\mathbf{i}, \\mathbf{j})$ to represent the cell at row $\\mathbf{i}$ and column $\\mathbf{j}$. At most one narrow hallway can be built through any given vertex, which means either $(\\mathbf{i}, \\mathbf{j})$ and $(\\mathbf{i} + 1, \\mathbf{j} + 1)$ can be connected, or $(\\mathbf{i} + 1, \\mathbf{j})$ and $(\\mathbf{i}, \\mathbf{j} + 1)$ can be connected, or neither pair, but not both. Of course, only hallways between cells assigned to the same company can be built.\n\nGiven a matrix where each cell is labeled $\\mathbf{A}$ or $\\mathbf{B}$ depending on which company it is assigned to, find a way to add connections through diagonal adjacencies such that all $\\mathbf{A}$s are connected and all $\\mathbf{B}$s are connected.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case begins with one line containing two integers $\\mathbf{R}$ and $\\mathbf{C}$, the number of rows and columns of the matrix representing the datacenter. Then, there are $\\mathbf{R}$ more lines containing $\\mathbf{C}$ characters each. The $\\mathbf{j}$-th character on the $\\mathbf{i}$-th of these lines $\\mathbf{M}", "outputFormat": "For each test case, first output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `IMPOSSIBLE` if there is no way to assign the diagonal connections such that the $\\mathbf{A}$ cells are connected and the $\\mathbf{B}$ cells are connected, or `POSSIBLE` otherwise. Then, if you output `POSSIBLE`, output $\\mathbf{R} - 1$ more lines of $\\mathbf{C} - 1$ characters each. These characters must correspond to a valid arrangement as described in the statement above. The $\\mathbf{j}$-th character of the $\\mathbf{i}$-th of those lines must be $\\backslash$ if cells $(\\mathbf{i}, \\mathbf{j})$ and $(\\mathbf{i} + 1, \\mathbf{j} + 1)$ are to be connected, / if cells $(\\mathbf{i} + 1, \\mathbf{j})$ and $(\\mathbf{i}, \\mathbf{j} + 1)$ are to be connected, or . if neither pair is to be connected.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the pair of A cells and the pair of B cells need to be connected, but since both connections would have to cross the same vertex, at most one of the connections can exist.\n\nIn Sample Case #2, the cells are already connected in the required way in the input, so no additional connections are necessary. Note that you can add unnecessary valid connections, so another valid answer would be `//`, but `\\.` would be wrong.\n\nIn Sample Case #3, there are also multiple solutions, one of which is displayed.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{C} \\leq 100$.\n- $\\mathbf{M}_{\\mathbf{i}, \\mathbf{j}}$ = uppercase A or uppercase B, for all $\\mathbf{i}$ and $\\mathbf{j}$.\n- $\\mathbf{M}_{\\mathbf{i}, \\mathbf{j}}$ = uppercase A for at least one pair of $\\mathbf{i}$ and $\\mathbf{j}$.\n- $\\mathbf{M}_{\\mathbf{i}, \\mathbf{j}}$ = uppercase B for at least one pair of $\\mathbf{i}$ and $\\mathbf{j}$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $2 \\leq \\mathbf{R} \\leq 4$.\n\n**Test set 2 (13 Pts, Hidden)**\n\n- $2 \\leq \\mathbf{R} \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #3] Datacenter Duplex", "background": "", "description": "Two companies, Apricot Rules LLC and Banana Rocks Inc., are sharing the same datacenter. The datacenter is a matrix of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns, with each cell containing a single server tower. Each tower contains intellectual property belonging to exactly one of the two companies.\n\nAt first, they built walls on the edges between cells assigned to different companies. This allowed orthogonally adjacent cells belonging to the same company to remain connected. Also, two cells $\\mathbf{x}$ and $\\mathbf{y}$ are considered connected if $\\mathbf{x}$ is connected to a cell that is, directly or indirectly, connected to $\\mathbf{y}$. With this definition, it was possible that two cells assigned to the same company were not connected, which was unacceptable.\n\nBoth companies agreed to build narrow hallways running through cell corners that allow two diagonally adjacent cells to be connected directly. Let us write $(\\mathbf{i}, \\mathbf{j})$ to represent the cell at row $\\mathbf{i}$ and column $\\mathbf{j}$. At most one narrow hallway can be built through any given vertex, which means either $(\\mathbf{i}, \\mathbf{j})$ and $(\\mathbf{i} + 1, \\mathbf{j} + 1)$ can be connected, or $(\\mathbf{i} + 1, \\mathbf{j})$ and $(\\mathbf{i}, \\mathbf{j} + 1)$ can be connected, or neither pair, but not both. Of course, only hallways between cells assigned to the same company can be built.\n\nGiven a matrix where each cell is labeled $\\mathbf{A}$ or $\\mathbf{B}$ depending on which company it is assigned to, find a way to add connections through diagonal adjacencies such that all $\\mathbf{A}$s are connected and all $\\mathbf{B}$s are connected.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case begins with one line containing two integers $\\mathbf{R}$ and $\\mathbf{C}$, the number of rows and columns of the matrix representing the datacenter. Then, there are $\\mathbf{R}$ more lines containing $\\mathbf{C}$ characters each. The $\\mathbf{j}$-th character on the $\\mathbf{i}$-th of these lines $\\mathbf{M}", "outputFormat": "For each test case, first output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `IMPOSSIBLE` if there is no way to assign the diagonal connections such that the $\\mathbf{A}$ cells are connected and the $\\mathbf{B}$ cells are connected, or `POSSIBLE` otherwise. Then, if you output `POSSIBLE`, output $\\mathbf{R} - 1$ more lines of $\\mathbf{C} - 1$ characters each. These characters must correspond to a valid arrangement as described in the statement above. The $\\mathbf{j}$-th character of the $\\mathbf{i}$-th of those lines must be $\\backslash$ if cells $(\\mathbf{i}, \\mathbf{j})$ and $(\\mathbf{i} + 1, \\mathbf{j} + 1)$ are to be connected, / if cells $(\\mathbf{i} + 1, \\mathbf{j})$ and $(\\mathbf{i}, \\mathbf{j} + 1)$ are to be connected, or . if neither pair is to be connected.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the pair of A cells and the pair of B cells need to be connected, but since both connections would have to cross the same vertex, at most one of the connections can exist.\n\nIn Sample Case #2, the cells are already connected in the required way in the input, so no additional connections are necessary. Note that you can add unnecessary valid connections, so another valid answer would be `//`, but `\\.` would be wrong.\n\nIn Sample Case #3, there are also multiple solutions, one of which is displayed.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{C} \\leq 100$.\n- $\\mathbf{M}_{\\mathbf{i}, \\mathbf{j}}$ = uppercase A or uppercase B, for all $\\mathbf{i}$ and $\\mathbf{j}$.\n- $\\mathbf{M}_{\\mathbf{i}, \\mathbf{j}}$ = uppercase A for at least one pair of $\\mathbf{i}$ and $\\mathbf{j}$.\n- $\\mathbf{M}_{\\mathbf{i}, \\mathbf{j}}$ = uppercase B for at least one pair of $\\mathbf{i}$ and $\\mathbf{j}$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $2 \\leq \\mathbf{R} \\leq 4$.\n\n**Test set 2 (13 Pts, Hidden)**\n\n- $2 \\leq \\mathbf{R} \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #3] Datacenter Duplex", "background": null, "description": "两家公司，Apricot Rules LLC 和 Banana Rocks Inc.，共用同一个数据中心。数据中心是一个 $\\mathbf{R}$ 行 $\\mathbf{C}$ 列的矩阵，每个格子里有一台服务器塔。每台服务器塔只属于其中一家公司。\n\n最初，他们在分配给不同公司的格子之间的边上建造了墙。这样，属于同一公司的正交相邻格子依然是连通的。同时，如果格子 $\\mathbf{x}$ 与格子 $\\mathbf{y}$ 之间存在直接或间接的连通路径，则认为 $\\mathbf{x}$ 和 $\\mathbf{y}$ 是连通的。根据这个定义，可能会出现同一公司分配的两个格子不连通的情况，这是不可接受的。\n\n两家公司同意在格子的顶点处修建狭窄的走廊，使得两个对角相邻的格子可以直接连通。我们用 $(\\mathbf{i}, \\mathbf{j})$ 表示第 $\\mathbf{i}$ 行第 $\\mathbf{j}$ 列的格子。每个顶点最多只能建一条狭窄的走廊，这意味着要么连接 $(\\mathbf{i}, \\mathbf{j})$ 和 $(\\mathbf{i} + 1, \\mathbf{j} + 1)$，要么连接 $(\\mathbf{i} + 1, \\mathbf{j})$ 和 $(\\mathbf{i}, \\mathbf{j} + 1)$，要么两者都不连，但不能同时连。当然，只有分配给同一公司的格子之间才能建走廊。\n\n给定一个矩阵，每个格子用 $\\mathbf{A}$ 或 $\\mathbf{B}$ 标记，表示分配给哪家公司。请你为每个测试用例设计一种对角连通方案，使得所有 $\\mathbf{A}$ 格子连通，所有 $\\mathbf{B}$ 格子连通。", "inputFormat": "第一行输入测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组测试数据第一行包含两个整数 $\\mathbf{R}$ 和 $\\mathbf{C}$，表示数据中心的行数和列数。接下来有 $\\mathbf{R}$ 行，每行包含 $\\mathbf{C}$ 个字符，表示矩阵 $\\mathbf{M}$。", "outputFormat": "对于每个测试用例，首先输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 若无法通过对角连通方案使所有 $\\mathbf{A}$ 格子连通且所有 $\\mathbf{B}$ 格子连通，则输出 `IMPOSSIBLE`，否则输出 `POSSIBLE`。如果输出 `POSSIBLE`，则接下来输出 $\\mathbf{R} - 1$ 行，每行 $\\mathbf{C} - 1$ 个字符，表示一种合法的对角连通方案。第 $\\mathbf{i}$ 行第 $\\mathbf{j}$ 个字符为 `\\` 表示连接 $(\\mathbf{i}, \\mathbf{j})$ 和 $(\\mathbf{i} + 1, \\mathbf{j} + 1)$，为 `/` 表示连接 $(\\mathbf{i} + 1, \\mathbf{j})$ 和 $(\\mathbf{i}, \\mathbf{j} + 1)$，为 `.` 表示两对都不连。", "hint": "**样例解释**\n\n在样例 1 中，A 格子和 B 格子都需要连通，但由于两条连通路径会交叉在同一个顶点，最多只能连通一对。\n\n在样例 2 中，输入中的格子已经满足连通要求，无需额外连通。注意你可以添加多余但合法的连通方案，因此 `//` 也是合法答案，但 `\\.` 就不合法。\n\n在样例 3 中，也有多种合法方案，样例给出其中一种。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{C} \\leq 100$。\n- 对所有 $\\mathbf{i}, \\mathbf{j}$，$\\mathbf{M}_{\\mathbf{i}, \\mathbf{j}}$ 仅为大写字母 A 或 B。\n- 至少有一个格子为 A，至少有一个格子为 B。\n\n**测试点 1（10 分，公开）**\n\n- $2 \\leq \\mathbf{R} \\leq 4$。\n\n**测试点 2（13 分，隐藏）**\n\n- $2 \\leq \\mathbf{R} \\leq 100$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13122", "type": "P", "difficulty": 7, "samples": [["4\n4 2\n1 1\n1 2\n2 2\n2 1\n3 2\n1 1\n1 2\n2 1\n8 2\n1 3\n3 5\n5 5\n4 4\n7 3\n5 1\n4 2\n3 1\n8 2\n1 3\n3 5\n4 4\n5 5\n7 3\n5 1\n4 2\n3 1", "Case #1: POSSIBLE\n1/1 2/1 2/1 1/1\nCase #2: POSSIBLE\n1/1 1/1 3/2 3/2\nCase #3: IMPOSSIBLE\nCase #4: POSSIBLE\n1/1 3/1 7/1 3/1"], ["1\n10 8\n4 1\n3 1\n2 2\n2 3\n1 3\n1 4\n2 4\n3 3\n3 2\n4 2", "Case #1: POSSIBLE\n3/1 1/1 4/1 2/1\n3/1 1/1 3/1 2/1\n2/1 2/1 3/1 2/1\n2/1 2/1 3/1 3/1\n2/1 3/1 3/1 3/1\n2/1 3/1 2/1 4/1\n1/1 3/1 2/1 4/1"]], "limits": {"time": [60000, 60000, 60000], "memory": [1048576, 1048576, 1048576]}, "tags": ["计算几何", "2019", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 #3] Napkin Folding", "background": "", "description": "Chalk has been actively traveling the world with his friends taking pictures in all the coolest places. Most recently, he made his way to Europe, where he studied the history of [napkin folding](https://en.wikipedia.org/wiki/Napkin_folding). Ever since, Chalk has been collecting a wide variety of napkins to practice the art of napkin folding.\n\nChalk's napkins can be defined as [simple polygons](https://en.wikipedia.org/wiki/Simple_polygon). A simple polygon is a polygon in which no edges intersect except for adjacent edges which meet at their shared vertex. Each vertex of the polygon is on exactly two edges.\n\nChalk folds his napkins by first drawing a *folding pattern* on them. A folding pattern is a set of $\\mathbf{K}-1$ line segments which are drawn on the napkin. Each line segment connects two points with rational coordinates on the border of the polygon defining the napkin and is fully contained in the polygon. No two line segments in a folding pattern may touch or overlap, except possibly at common endpoints. A folding pattern of $\\mathbf{K}-1$ line segments splits the napkin into $\\mathbf{K}$ polygonal regions. Two points are in the same region if there exists some continuous line (not necessarily straight) between them which does not intersect any edge of the polygon or any line segment in the folding pattern — even at endpoints.\n\nChalk is only interested in *neat folding patterns*. A folding pattern is *neat* if any two regions that are adjacent to the same folding line segment $F$ are [symmetric](https://en.wikipedia.org/wiki/Symmetry) with respect to $F$. This means that folding the napkin along that line segment would result in the two regions lining up perfectly.\n\nThe following picture illustrates a neat folding pattern with $\\mathbf{K}=8$ regions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ta6vzkcp.png)\n\nChalk has been successfully folding his collection of napkins using neat folding patterns. But he has some napkins in his collection that he has not been able to find a neat folding pattern for. For each of those napkins, Chalk needs your help to find a neat folding pattern with $\\mathbf{K}$ regions or determine that no such neat folding pattern exists.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{N}$ and $\\mathbf{K}$: the number of points in the polygon defining Chalk's napkin and the number of regions to split the napkin into with a neat folding pattern containing $\\mathbf{K}-1$ line segments.\n\nThe polygon defining the napkin is represented as a list of the $\\mathbf{N}$ vertices, as encountered when traveling along the perimeter of the polygon in the clockwise direction, with the first vertex being chosen arbitrarily. The next $\\mathbf{N}$ lines represent that list. The $\\mathbf{i}$-th of these contains two integers $\\mathbf{X}_{\\mathbf{i}}$ and $\\mathbf{Y}_{\\mathbf{i}}$, indicating that the $\\mathbf{i}$-th point is located at $(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}})$ in two-dimensional space.\n", "outputFormat": "For each test case, output one line containing Case #$x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is `POSSIBLE` if it is possible to make a neat folding pattern with $\\mathbf{K}$ regions and `IMPOSSIBLE` otherwise.\n\nIf it is possible to make a neat folding pattern with $\\mathbf{K}$ regions, output $\\mathbf{K}-1$ more lines listing the segments of a neat folding pattern with $\\mathbf{K}$ regions, in any order. Each line should represent a different segment as $\\mathbf{A}_{\\mathbf{x}}$ $\\mathbf{A}_{\\mathbf{y}}$ $\\mathbf{B}_{\\mathbf{x}}$ $\\mathbf{B}_{\\mathbf{y}}$, where $(\\mathbf{A}_{\\mathbf{x}}, \\mathbf{A}_{\\mathbf{y}})$ and $(\\mathbf{B}_{\\mathbf{x}}, \\mathbf{B}_{\\mathbf{y}})$ are the two endpoints of the segment, in any order. Each of $\\mathbf{A}_{\\mathbf{x}}$, $\\mathbf{A}_{\\mathbf{y}}$, $\\mathbf{B}_{\\mathbf{x}}$, and $\\mathbf{B}_{\\mathbf{y}}$ should be in the form $\\mathbf{N}/\\mathbf{D}$ where $\\mathbf{N}$ and $\\mathbf{D}$ are positive integers (written with no leading zeroes) sharing no common prime factors, and representing the rational number $\\mathbf{N}/\\mathbf{D}$. There must be no whitespace between $\\mathbf{N}$ and /, or between / and $\\mathbf{D}$.", "hint": "**Sample Explanation**\n\nNote: Sample 2 is not valid for Test set 1. Only Sample 1 will be tested prior to running Test set 1 (the same way samples normally are). Moreover, Sample 2 will not be tested prior to running Test set 2.\n\nFor Sample Case #1, a neat folding pattern with $\\mathbf{K}=2$ can be drawn using any of the 4 dashed lines:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bm3282e7.png)\n\nFor Sample Case #2, a neat folding pattern with $\\mathbf{K}=2$ can be drawn as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hvx1riz3.png)\n\nFor Sample Case #3, there are no neat folding patterns:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/adkogxsq.png)\n\nFor Sample Case #4, there are two possible neat folding patterns with $\\mathbf{K}=2$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j4v71qhu.png)\n\nFor the test set 2 sample case, a neat folding pattern with $\\mathbf{K}=8$ can be drawn as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vqrcukau.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $3 \\leq \\mathbf{N} \\leq 200$.\n- $1 \\leq \\mathbf{X}_{\\mathbf{i}} \\leq 1000$, for all $\\mathbf{i}$.\n- $1 \\leq \\mathbf{Y}_{\\mathbf{i}} \\leq 1000$, for all $\\mathbf{i}$.\n- The $\\mathbf{N}$ points are given in clockwise order.\n- No two adjacent edges of the polygon are collinear.\n- The polygon is a simple polygon with strictly positive area.\n- No two edges intersect except for adjacent edges at their shared endpoint.\n\n**Test set 1 (4 Pts, Visible)**\n\n- $\\mathbf{K}=2$.\n\n**Test set 2 (39 Pts, Hidden)**\n\n- $2 \\leq \\mathbf{K} \\leq 10$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 #3] Napkin Folding", "background": "", "description": "Chalk has been actively traveling the world with his friends taking pictures in all the coolest places. Most recently, he made his way to Europe, where he studied the history of [napkin folding](https://en.wikipedia.org/wiki/Napkin_folding). Ever since, Chalk has been collecting a wide variety of napkins to practice the art of napkin folding.\n\nChalk's napkins can be defined as [simple polygons](https://en.wikipedia.org/wiki/Simple_polygon). A simple polygon is a polygon in which no edges intersect except for adjacent edges which meet at their shared vertex. Each vertex of the polygon is on exactly two edges.\n\nChalk folds his napkins by first drawing a *folding pattern* on them. A folding pattern is a set of $\\mathbf{K}-1$ line segments which are drawn on the napkin. Each line segment connects two points with rational coordinates on the border of the polygon defining the napkin and is fully contained in the polygon. No two line segments in a folding pattern may touch or overlap, except possibly at common endpoints. A folding pattern of $\\mathbf{K}-1$ line segments splits the napkin into $\\mathbf{K}$ polygonal regions. Two points are in the same region if there exists some continuous line (not necessarily straight) between them which does not intersect any edge of the polygon or any line segment in the folding pattern — even at endpoints.\n\nChalk is only interested in *neat folding patterns*. A folding pattern is *neat* if any two regions that are adjacent to the same folding line segment $F$ are [symmetric](https://en.wikipedia.org/wiki/Symmetry) with respect to $F$. This means that folding the napkin along that line segment would result in the two regions lining up perfectly.\n\nThe following picture illustrates a neat folding pattern with $\\mathbf{K}=8$ regions.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ta6vzkcp.png)\n\nChalk has been successfully folding his collection of napkins using neat folding patterns. But he has some napkins in his collection that he has not been able to find a neat folding pattern for. For each of those napkins, Chalk needs your help to find a neat folding pattern with $\\mathbf{K}$ regions or determine that no such neat folding pattern exists.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\\mathbf{N}$ and $\\mathbf{K}$: the number of points in the polygon defining Chalk's napkin and the number of regions to split the napkin into with a neat folding pattern containing $\\mathbf{K}-1$ line segments.\n\nThe polygon defining the napkin is represented as a list of the $\\mathbf{N}$ vertices, as encountered when traveling along the perimeter of the polygon in the clockwise direction, with the first vertex being chosen arbitrarily. The next $\\mathbf{N}$ lines represent that list. The $\\mathbf{i}$-th of these contains two integers $\\mathbf{X}_{\\mathbf{i}}$ and $\\mathbf{Y}_{\\mathbf{i}}$, indicating that the $\\mathbf{i}$-th point is located at $(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}})$ in two-dimensional space.\n", "outputFormat": "For each test case, output one line containing Case #$x$: $y$, where $x$ is the test case number (starting from 1) and $y$ is `POSSIBLE` if it is possible to make a neat folding pattern with $\\mathbf{K}$ regions and `IMPOSSIBLE` otherwise.\n\nIf it is possible to make a neat folding pattern with $\\mathbf{K}$ regions, output $\\mathbf{K}-1$ more lines listing the segments of a neat folding pattern with $\\mathbf{K}$ regions, in any order. Each line should represent a different segment as $\\mathbf{A}_{\\mathbf{x}}$ $\\mathbf{A}_{\\mathbf{y}}$ $\\mathbf{B}_{\\mathbf{x}}$ $\\mathbf{B}_{\\mathbf{y}}$, where $(\\mathbf{A}_{\\mathbf{x}}, \\mathbf{A}_{\\mathbf{y}})$ and $(\\mathbf{B}_{\\mathbf{x}}, \\mathbf{B}_{\\mathbf{y}})$ are the two endpoints of the segment, in any order. Each of $\\mathbf{A}_{\\mathbf{x}}$, $\\mathbf{A}_{\\mathbf{y}}$, $\\mathbf{B}_{\\mathbf{x}}$, and $\\mathbf{B}_{\\mathbf{y}}$ should be in the form $\\mathbf{N}/\\mathbf{D}$ where $\\mathbf{N}$ and $\\mathbf{D}$ are positive integers (written with no leading zeroes) sharing no common prime factors, and representing the rational number $\\mathbf{N}/\\mathbf{D}$. There must be no whitespace between $\\mathbf{N}$ and /, or between / and $\\mathbf{D}$.", "hint": "**Sample Explanation**\n\nNote: Sample 2 is not valid for Test set 1. Only Sample 1 will be tested prior to running Test set 1 (the same way samples normally are). Moreover, Sample 2 will not be tested prior to running Test set 2.\n\nFor Sample Case #1, a neat folding pattern with $\\mathbf{K}=2$ can be drawn using any of the 4 dashed lines:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bm3282e7.png)\n\nFor Sample Case #2, a neat folding pattern with $\\mathbf{K}=2$ can be drawn as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hvx1riz3.png)\n\nFor Sample Case #3, there are no neat folding patterns:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/adkogxsq.png)\n\nFor Sample Case #4, there are two possible neat folding patterns with $\\mathbf{K}=2$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j4v71qhu.png)\n\nFor the test set 2 sample case, a neat folding pattern with $\\mathbf{K}=8$ can be drawn as follows:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vqrcukau.png)\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $3 \\leq \\mathbf{N} \\leq 200$.\n- $1 \\leq \\mathbf{X}_{\\mathbf{i}} \\leq 1000$, for all $\\mathbf{i}$.\n- $1 \\leq \\mathbf{Y}_{\\mathbf{i}} \\leq 1000$, for all $\\mathbf{i}$.\n- The $\\mathbf{N}$ points are given in clockwise order.\n- No two adjacent edges of the polygon are collinear.\n- The polygon is a simple polygon with strictly positive area.\n- No two edges intersect except for adjacent edges at their shared endpoint.\n\n**Test set 1 (4 Pts, Visible)**\n\n- $\\mathbf{K}=2$.\n\n**Test set 2 (39 Pts, Hidden)**\n\n- $2 \\leq \\mathbf{K} \\leq 10$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 #3] Napkin Folding", "background": null, "description": "Chalk 一直在和朋友们积极地环游世界，在最酷的地方拍照。最近，他来到了欧洲，研究了[餐巾折叠](https://en.wikipedia.org/wiki/Napkin_folding)的历史。从那以后，Chalk 就开始收集各种各样的餐巾来练习餐巾折叠艺术。\n\nChalk 的餐巾可以被定义为[简单多边形](https://en.wikipedia.org/wiki/Simple_polygon)。简单多边形是指没有边相交（除了相邻边在公共顶点处相交）的多边形。多边形的每个顶点都恰好属于两条边。\n\nChalk 折叠餐巾时，首先会在餐巾上画出*折叠图案*。折叠图案是一组 $\\mathbf{K}-1$ 条线段，这些线段画在定义餐巾的多边形上。每条线段连接多边形边界上的两个有理数坐标点，并且完全位于多边形内部。折叠图案中的任意两条线段不能相交或重叠，除了可能在公共端点处。包含 $\\mathbf{K}-1$ 条线段的折叠图案会将餐巾分成 $\\mathbf{K}$ 个多边形区域。如果存在一条连续的路径（不一定是直线），连接两个点且不与多边形的任何边或折叠图案中的任何线段（即使是端点）相交，则这两个点属于同一区域。\n\nChalk 只对*整齐的折叠图案*感兴趣。折叠图案是*整齐*的，当且仅当与同一折叠线段 $F$ 相邻的任意两个区域关于 $F$ 对称。这意味着，如果沿着该线段折叠餐巾，这两个区域会完全重合。\n\n下图展示了一个包含 $\\mathbf{K}=8$ 个区域的整齐折叠图案。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ta6vzkcp.png)\n\nChalk 已经用整齐的折叠图案成功折叠了他的大部分餐巾。但他收藏中还有一些餐巾，始终找不到整齐的折叠图案。对于这些餐巾中的每一块，Chalk 需要你的帮助，找出一个包含 $\\mathbf{K}$ 个区域的整齐折叠图案，或者判断不存在这样的整齐折叠图案。", "inputFormat": "输入的第一行包含测试用例数 $\\mathbf{T}$。接下来是 $\\mathbf{T}$ 组测试数据。每组测试数据的第一行包含两个整数 $\\mathbf{N}$ 和 $\\mathbf{K}$，分别表示定义 Chalk 餐巾的多边形的顶点数和需要用整齐折叠图案分割出的区域数（即折叠图案包含 $\\mathbf{K}-1$ 条线段）。\n\n定义餐巾的多边形用一组 $\\mathbf{N}$ 个顶点表示，按顺时针方向沿多边形边界依次给出，起点任意。接下来的 $\\mathbf{N}$ 行表示该顶点列表。第 $\\mathbf{i}$ 行包含两个整数 $\\mathbf{X}_{\\mathbf{i}}$ 和 $\\mathbf{Y}_{\\mathbf{i}}$，表示第 $\\mathbf{i}$ 个点在二维平面上的坐标为 $(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}})$。", "outputFormat": "对于每组测试数据，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 为 `POSSIBLE` 表示存在包含 $\\mathbf{K}$ 个区域的整齐折叠图案，`IMPOSSIBLE` 表示不存在。\n\n如果存在整齐折叠图案，将接着输出 $\\mathbf{K}-1$ 行，每行表示一条折叠线段，顺序任意。每行格式为 $\\mathbf{A}_{\\mathbf{x}}$ $\\mathbf{A}_{\\mathbf{y}}$ $\\mathbf{B}_{\\mathbf{x}}$ $\\mathbf{B}_{\\mathbf{y}}$，其中 $(\\mathbf{A}_{\\mathbf{x}}, \\mathbf{A}_{\\mathbf{y}})$ 和 $(\\mathbf{B}_{\\mathbf{x}}, \\mathbf{B}_{\\mathbf{y}})$ 是线段的两个端点，顺序任意。$\\mathbf{A}_{\\mathbf{x}}$、$\\mathbf{A}_{\\mathbf{y}}$、$\\mathbf{B}_{\\mathbf{x}}$、$\\mathbf{B}_{\\mathbf{y}}$ 都应为 $\\mathbf{N}/\\mathbf{D}$ 的形式，其中 $\\mathbf{N}$ 和 $\\mathbf{D}$ 是正整数（无前导零），且互质，表示有理数 $\\mathbf{N}/\\mathbf{D}$。$\\mathbf{N}$ 与 `/`、`/` 与 $\\mathbf{D}$ 之间不得有空格。", "hint": "**样例解释**\n\n注意：样例 2 不适用于测试集 1。只有样例 1 会在运行测试集 1 前被测试（与通常的样例测试方式一致）。此外，样例 2 不会在运行测试集 2 前被测试。\n\n对于样例 1，$\\mathbf{K}=2$ 时，可以用任意一条虚线画出整齐的折叠图案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bm3282e7.png)\n\n对于样例 2，$\\mathbf{K}=2$ 时，可以如下画出整齐的折叠图案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hvx1riz3.png)\n\n对于样例 3，没有整齐的折叠图案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/adkogxsq.png)\n\n对于样例 4，存在两种可能的整齐折叠图案，$\\mathbf{K}=2$：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/j4v71qhu.png)\n\n对于测试集 2 的样例，$\\mathbf{K}=8$ 时，可以如下画出整齐的折叠图案：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/vqrcukau.png)\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $3 \\leq \\mathbf{N} \\leq 200$。\n- $1 \\leq \\mathbf{X}_{\\mathbf{i}} \\leq 1000$，对所有 $\\mathbf{i}$。\n- $1 \\leq \\mathbf{Y}_{\\mathbf{i}} \\leq 1000$，对所有 $\\mathbf{i}$。\n- 所有 $\\mathbf{N}$ 个点按顺时针顺序给出。\n- 多边形任意两条相邻边不共线。\n- 多边形为简单多边形，面积严格大于零。\n- 除了相邻边在公共端点处外，多边形任意两条边不相交。\n\n**测试集 1（4 分，公开）**\n\n- $\\mathbf{K}=2$。\n\n**测试集 2（39 分，隐藏）**\n\n- $2 \\leq \\mathbf{K} \\leq 10$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13123", "type": "P", "difficulty": 6, "samples": [["", ""]], "limits": {"time": [60000, 60000], "memory": [1048576, 1048576]}, "tags": ["数学", "2019", "二分", "交互题", "Special Judge", "Google Code Jam"], "title": "[GCJ 2019 Finals] Board Meeting [Can't Judge yet]", "background": "", "description": "Note that it is not necessary to know anything about the rules of chess to solve this problem.\n\nThere are $\\mathbf{N}$ kings on an infinite chessboard (two-dimensional grid), located in cells with coordinates $(\\mathbf{X}_{1}, \\mathbf{Y}_{1})$, $(\\mathbf{X}_{2}, \\mathbf{Y}_{2})$, ..., $(\\mathbf{X}_{\\mathbf{N}}, \\mathbf{Y}_{\\mathbf{N}})$. Both $\\mathbf{N}$ and the kings' coordinates are unknown to you. However, you do know the following things:\n\n- $\\mathbf{N}$ is at least 1 and at most $\\mathbf{N}_{\\text{max}}$.\n- No king's coordinates (X or Y) have an absolute value exceeding $\\mathbf{M}$.\n- The $\\mathbf{N}$ kings are located in $\\mathbf{N}$ different cells.\n\nThe kings want to meet in a single cell of the board. If some cell $(\\mathbf{X}, \\mathbf{Y})$ were to be chosen as the meeting cell, then in order to get there, the i-th king would use a number of moves equal to the maximum of the absolute values of the differences of coordinates between its cell and the meeting cell: $\\max(|\\mathbf{X}-\\mathbf{X}_{\\mathbf{i}}|, |\\mathbf{Y}-\\mathbf{Y}_{\\mathbf{i}}|)$. The total number of moves used by all kings is thus equal to the sum of those maximums over all values of $\\mathbf{i}$. Note that it is not relevant to this problem exactly how the kings move on the board — only the source and destination cells matter, and the number of moves can always be computed using the above formula.\n\nThis problem has two phases. In the first phase, you may repeatedly do the following: propose a meeting location $(\\mathbf{A}, \\mathbf{B})$ (with each of $\\mathbf{A}$ and $\\mathbf{B}$ between $-10 \\times \\mathbf{M}$ and $10 \\times \\mathbf{M}$, inclusive), and have the judge tell you the total number of moves the kings would use to get there — the sum (over all $\\mathbf{i}$) of $\\max(|\\mathbf{X}_{\\mathbf{i}}-\\mathbf{A}|, |\\mathbf{Y}_{\\mathbf{i}}-\\mathbf{B}|)$. You can have at most $\\mathbf{R}$ such exchanges with the judge, choosing your values of $\\mathbf{A}$ and $\\mathbf{B}$ each time. Note that the kings do not actually move, so their locations $(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}})$ stay the same for all requests within one test case.\n\nIn the second phase, the roles are swapped: the judge gives you a meeting cell location $(\\mathbf{C}, \\mathbf{D})$ (with each of $\\mathbf{C}$ and $\\mathbf{D}$ between $-10 \\times \\mathbf{M}$ and $10 \\times \\mathbf{M}$, inclusive), and you must respond with the total number of moves the kings would use to get there, assuming that the kings are in the same locations as in the first phase. There are at most $\\mathbf{R}$ such exchanges, and you must correctly respond to all of the judge's requests.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing four integers $\\mathbf{T}$, $\\mathbf{N}_{\\text{max}}$, $\\mathbf{M}$ and $\\mathbf{R}$: the number of test cases, the maximum number of kings, the maximum absolute value for any coordinate for any king, and the maximum number of requests per phase, respectively. (Note that the values of $\\mathbf{M}$ and $\\mathbf{R}$ are fixed, and are provided as input only for convenience; see the Limits section for more details.) Then, you need to process $\\mathbf{T}$ test cases.\n\nIn each test case, there are two phases. In the first phase, the i-th exchange is as follows:\n\n- Your program sends one line containing two integers $\\mathbf{A}_{\\mathbf{i}}$ and $\\mathbf{B}_{\\mathbf{i}}$, representing the x and y coordinates of a cell.\n    - Both $\\mathbf{A}_{\\mathbf{i}}$ and $\\mathbf{B}_{\\mathbf{i}}$ must be between $-10 \\times \\mathbf{M}$ and $10 \\times \\mathbf{M}$, inclusive.\n- The judge responds with one line containing a single integer: the total number of moves the kings need to use to get from their unknown locations to your cell.\n\nYou may initiate at most $\\mathbf{R}$ such exchanges in this phase. If you make more than $\\mathbf{R}$ exchanges, or send a request that the judge can not parse or is out of bounds, the judge responds with one line with a single string $\\text{ERROR}$.\n\nTo end the first phase and switch to the second phase, you must send one line with the string $\\text{READY}$ (the case does not matter), to which the judge responds with the first request of the second phase.\n\nIn the second phase, the i-th exchange is as follows:\n\n- The judge sends one line containing two integers $\\mathbf{C}_{\\mathbf{i}}$ and $\\mathbf{D}_{\\mathbf{i}}$, representing the x and y coordinates of a cell.\n    - Each of $\\mathbf{C}_{\\mathbf{i}}$ and $\\mathbf{D}_{\\mathbf{i}}$ will be between $-10 \\times \\mathbf{M}$ and $10 \\times \\mathbf{M}$, inclusive.\n- Your program must respond with one line containing a single integer: the total number of moves the kings would need to use to get to the given cell.\n\nThe judge is guaranteed to send at least 1 and at most $\\mathbf{R}$ such requests. If you send an answer that is incorrect or unparseable, the judge responds with $\\text{ERROR}$ as described above. If you answer all of the requests correctly, the judge sends one line with a single string $\\text{DONE}$, at which point your program should initiate the next test case, or terminate with no error if all $\\mathbf{T}$ test cases have been handled.\n\nAfter the judge sends a line with $\\text{ERROR}$, it does not send any other output. If your program continues to wait for the judge after receiving $\\text{ERROR}$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n\nThe number and location of the kings, as well as the number and positions of the requests that the judge sends during the second phases, are chosen before any exchanges occur.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nNote that the following sample interaction is for test set 1, in which there is always exactly one king.\n\n```\n  // Suppose that the judge has decided that in the first test case, the king\n  // is at the coordinates (1, -2), and the requests will be (5, -1) and\n  // (7, 7).\n  t, nmax, m, r = readline_int_list()   // Reads 10 1 1000000 1000\n  // Our solution decides (for whatever reason) to check (3, 3) first.\n  printline 3 3 to stdout\n  flush stdout\n  result = readline_int()               // Reads 5\n  // Our solution now decides (for whatever reason) to check (2, 0).\n  printline 2 0 to stdout\n  flush stdout\n  result = readline_int()               // Reads 2\n  // Our solution concludes that the king is at (3, -2), which is consistent\n  // with the observed information so far, but unfortunately not correct.\n  // Our solution moves on to the request phase.\n  printline READY to stdout\n  request_line = readline()             // Reads 5 -1\n  printline 2 to stdout                 // Wrong answer!\n  request_line = readline()             // Reads ERROR\n  exit                                  // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n~~Note that a program that just makes valid exchanges with the judge (and does no other processing) takes the following time in our environment: ~13 seconds for C++, ~24 seconds for Java, ~19 seconds for Python and Go.~~\n\n- $1 \\leq \\mathbf{T} \\leq 15$.\n- $\\mathbf{M} = 10^{6}$.\n- $-\\mathbf{M} \\leq \\mathbf{X}_{\\mathbf{i}} \\leq \\mathbf{M}$, for all $\\mathbf{i}$.\n- $-\\mathbf{M} \\leq \\mathbf{Y}_{\\mathbf{i}} \\leq \\mathbf{M}$, for all $\\mathbf{i}$.\n- The pairs $(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}})$ are distinct.\n- $-10 \\times \\mathbf{M} \\leq \\mathbf{C}_{\\mathbf{i}} \\leq 10 \\times \\mathbf{M}$, for all $\\mathbf{i}$.\n- $-10 \\times \\mathbf{M} \\leq \\mathbf{D}_{\\mathbf{i}} \\leq 10 \\times \\mathbf{M}$, for all $\\mathbf{i}$.\n- $\\mathbf{R} = 1000$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $\\mathbf{N}_{\\text{max}} = 1$.\n\n**Test set 2 (22 Pts, Hidden)**\n\n- $\\mathbf{N}_{\\text{max}} = 10$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Finals] Board Meeting [Can't Judge yet]", "background": "", "description": "Note that it is not necessary to know anything about the rules of chess to solve this problem.\n\nThere are $\\mathbf{N}$ kings on an infinite chessboard (two-dimensional grid), located in cells with coordinates $(\\mathbf{X}_{1}, \\mathbf{Y}_{1})$, $(\\mathbf{X}_{2}, \\mathbf{Y}_{2})$, ..., $(\\mathbf{X}_{\\mathbf{N}}, \\mathbf{Y}_{\\mathbf{N}})$. Both $\\mathbf{N}$ and the kings' coordinates are unknown to you. However, you do know the following things:\n\n- $\\mathbf{N}$ is at least 1 and at most $\\mathbf{N}_{\\text{max}}$.\n- No king's coordinates (X or Y) have an absolute value exceeding $\\mathbf{M}$.\n- The $\\mathbf{N}$ kings are located in $\\mathbf{N}$ different cells.\n\nThe kings want to meet in a single cell of the board. If some cell $(\\mathbf{X}, \\mathbf{Y})$ were to be chosen as the meeting cell, then in order to get there, the i-th king would use a number of moves equal to the maximum of the absolute values of the differences of coordinates between its cell and the meeting cell: $\\max(|\\mathbf{X}-\\mathbf{X}_{\\mathbf{i}}|, |\\mathbf{Y}-\\mathbf{Y}_{\\mathbf{i}}|)$. The total number of moves used by all kings is thus equal to the sum of those maximums over all values of $\\mathbf{i}$. Note that it is not relevant to this problem exactly how the kings move on the board — only the source and destination cells matter, and the number of moves can always be computed using the above formula.\n\nThis problem has two phases. In the first phase, you may repeatedly do the following: propose a meeting location $(\\mathbf{A}, \\mathbf{B})$ (with each of $\\mathbf{A}$ and $\\mathbf{B}$ between $-10 \\times \\mathbf{M}$ and $10 \\times \\mathbf{M}$, inclusive), and have the judge tell you the total number of moves the kings would use to get there — the sum (over all $\\mathbf{i}$) of $\\max(|\\mathbf{X}_{\\mathbf{i}}-\\mathbf{A}|, |\\mathbf{Y}_{\\mathbf{i}}-\\mathbf{B}|)$. You can have at most $\\mathbf{R}$ such exchanges with the judge, choosing your values of $\\mathbf{A}$ and $\\mathbf{B}$ each time. Note that the kings do not actually move, so their locations $(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}})$ stay the same for all requests within one test case.\n\nIn the second phase, the roles are swapped: the judge gives you a meeting cell location $(\\mathbf{C}, \\mathbf{D})$ (with each of $\\mathbf{C}$ and $\\mathbf{D}$ between $-10 \\times \\mathbf{M}$ and $10 \\times \\mathbf{M}$, inclusive), and you must respond with the total number of moves the kings would use to get there, assuming that the kings are in the same locations as in the first phase. There are at most $\\mathbf{R}$ such exchanges, and you must correctly respond to all of the judge's requests.\n\n### Interactive Protocol\n\nThis is an interactive problem.\n\nInitially, your program should read a single line containing four integers $\\mathbf{T}$, $\\mathbf{N}_{\\text{max}}$, $\\mathbf{M}$ and $\\mathbf{R}$: the number of test cases, the maximum number of kings, the maximum absolute value for any coordinate for any king, and the maximum number of requests per phase, respectively. (Note that the values of $\\mathbf{M}$ and $\\mathbf{R}$ are fixed, and are provided as input only for convenience; see the Limits section for more details.) Then, you need to process $\\mathbf{T}$ test cases.\n\nIn each test case, there are two phases. In the first phase, the i-th exchange is as follows:\n\n- Your program sends one line containing two integers $\\mathbf{A}_{\\mathbf{i}}$ and $\\mathbf{B}_{\\mathbf{i}}$, representing the x and y coordinates of a cell.\n    - Both $\\mathbf{A}_{\\mathbf{i}}$ and $\\mathbf{B}_{\\mathbf{i}}$ must be between $-10 \\times \\mathbf{M}$ and $10 \\times \\mathbf{M}$, inclusive.\n- The judge responds with one line containing a single integer: the total number of moves the kings need to use to get from their unknown locations to your cell.\n\nYou may initiate at most $\\mathbf{R}$ such exchanges in this phase. If you make more than $\\mathbf{R}$ exchanges, or send a request that the judge can not parse or is out of bounds, the judge responds with one line with a single string $\\text{ERROR}$.\n\nTo end the first phase and switch to the second phase, you must send one line with the string $\\text{READY}$ (the case does not matter), to which the judge responds with the first request of the second phase.\n\nIn the second phase, the i-th exchange is as follows:\n\n- The judge sends one line containing two integers $\\mathbf{C}_{\\mathbf{i}}$ and $\\mathbf{D}_{\\mathbf{i}}$, representing the x and y coordinates of a cell.\n    - Each of $\\mathbf{C}_{\\mathbf{i}}$ and $\\mathbf{D}_{\\mathbf{i}}$ will be between $-10 \\times \\mathbf{M}$ and $10 \\times \\mathbf{M}$, inclusive.\n- Your program must respond with one line containing a single integer: the total number of moves the kings would need to use to get to the given cell.\n\nThe judge is guaranteed to send at least 1 and at most $\\mathbf{R}$ such requests. If you send an answer that is incorrect or unparseable, the judge responds with $\\text{ERROR}$ as described above. If you answer all of the requests correctly, the judge sends one line with a single string $\\text{DONE}$, at which point your program should initiate the next test case, or terminate with no error if all $\\mathbf{T}$ test cases have been handled.\n\nAfter the judge sends a line with $\\text{ERROR}$, it does not send any other output. If your program continues to wait for the judge after receiving $\\text{ERROR}$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.\n\nThe number and location of the kings, as well as the number and positions of the requests that the judge sends during the second phases, are chosen before any exchanges occur.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nNote that the following sample interaction is for test set 1, in which there is always exactly one king.\n\n```\n  // Suppose that the judge has decided that in the first test case, the king\n  // is at the coordinates (1, -2), and the requests will be (5, -1) and\n  // (7, 7).\n  t, nmax, m, r = readline_int_list()   // Reads 10 1 1000000 1000\n  // Our solution decides (for whatever reason) to check (3, 3) first.\n  printline 3 3 to stdout\n  flush stdout\n  result = readline_int()               // Reads 5\n  // Our solution now decides (for whatever reason) to check (2, 0).\n  printline 2 0 to stdout\n  flush stdout\n  result = readline_int()               // Reads 2\n  // Our solution concludes that the king is at (3, -2), which is consistent\n  // with the observed information so far, but unfortunately not correct.\n  // Our solution moves on to the request phase.\n  printline READY to stdout\n  request_line = readline()             // Reads 5 -1\n  printline 2 to stdout                 // Wrong answer!\n  request_line = readline()             // Reads ERROR\n  exit                                  // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n~~Note that a program that just makes valid exchanges with the judge (and does no other processing) takes the following time in our environment: ~13 seconds for C++, ~24 seconds for Java, ~19 seconds for Python and Go.~~\n\n- $1 \\leq \\mathbf{T} \\leq 15$.\n- $\\mathbf{M} = 10^{6}$.\n- $-\\mathbf{M} \\leq \\mathbf{X}_{\\mathbf{i}} \\leq \\mathbf{M}$, for all $\\mathbf{i}$.\n- $-\\mathbf{M} \\leq \\mathbf{Y}_{\\mathbf{i}} \\leq \\mathbf{M}$, for all $\\mathbf{i}$.\n- The pairs $(\\mathbf{X}_{\\mathbf{i}}, \\mathbf{Y}_{\\mathbf{i}})$ are distinct.\n- $-10 \\times \\mathbf{M} \\leq \\mathbf{C}_{\\mathbf{i}} \\leq 10 \\times \\mathbf{M}$, for all $\\mathbf{i}$.\n- $-10 \\times \\mathbf{M} \\leq \\mathbf{D}_{\\mathbf{i}} \\leq 10 \\times \\mathbf{M}$, for all $\\mathbf{i}$.\n- $\\mathbf{R} = 1000$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $\\mathbf{N}_{\\text{max}} = 1$.\n\n**Test set 2 (22 Pts, Hidden)**\n\n- $\\mathbf{N}_{\\text{max}} = 10$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Finals] Board Meeting [Can't Judge yet]", "background": null, "description": "注意，解决本题并不需要了解国际象棋的规则。\n\n在一个无限大的国际象棋棋盘（二维网格）上，有 $N$ 个国王，分别位于坐标 $(X_{1}, Y_{1})$，$(X_{2}, Y_{2})$，...，$(X_{N}, Y_{N})$。你并不知道 $N$ 以及这些国王的具体坐标，但你知道以下信息：\n\n- $N$ 至少为 $1$，至多为 $N_{\\text{max}}$。\n- 没有任何一个国王的坐标（$X$ 或 $Y$）的绝对值超过 $M$。\n- $N$ 个国王分别位于 $N$ 个不同的格子中。\n\n这些国王想要在棋盘上的某一个格子会合。如果选择某个格子 $(X, Y)$ 作为会合点，则第 $i$ 个国王到达该点所需的步数为其当前位置与会合点坐标差的绝对值的最大值：$\\max(|X-X_{i}|, |Y-Y_{i}|)$。所有国王到达会合点所需的总步数就是对所有 $i$ 的上述最大值之和。注意，本题并不关心国王具体如何移动——只关心起点和终点，以及步数的计算方式。\n\n本题分为两个阶段。在第一阶段，你可以多次进行如下操作：提出一个会合点 $(A, B)$（其中 $A$ 和 $B$ 均在 $-10 \\times M$ 到 $10 \\times M$ 之间，包括端点），裁判会告诉你所有国王到达该点所需的总步数——即对所有 $i$ 计算 $\\max(|X_{i}-A|, |Y_{i}-B|)$ 的和。你最多可以进行 $R$ 次这样的交互，每次可以自由选择 $A$ 和 $B$ 的值。注意，国王并不会真的移动，所以在同一测试用例的所有请求中，国王的位置 $(X_{i}, Y_{i})$ 都保持不变。\n\n在第二阶段，角色互换：裁判会给你一个会合点 $(C, D)$（其中 $C$ 和 $D$ 均在 $-10 \\times M$ 到 $10 \\times M$ 之间，包括端点），你需要回答所有国王到达该点所需的总步数，假设国王们的位置与第一阶段相同。裁判最多会发出 $R$ 个这样的请求，你需要全部正确回答。\n\n### 交互协议\n\n这是一个交互题。\n\n程序开始时，你需要读取一行，包含四个整数 $T$、$N_{\\text{max}}$、$M$ 和 $R$，分别表示测试用例数、国王数量的最大值、任意国王坐标的最大绝对值、每个阶段最多请求次数。（注意 $M$ 和 $R$ 的值是固定的，仅为方便输入，具体见限制部分。）然后，你需要依次处理 $T$ 个测试用例。\n\n每个测试用例包含两个阶段。在第一阶段，第 $i$ 次交互如下：\n\n- 你的程序输出一行，包含两个整数 $A_{i}$ 和 $B_{i}$，表示一个格子的 $x$ 和 $y$ 坐标。\n    - $A_{i}$ 和 $B_{i}$ 必须都在 $-10 \\times M$ 到 $10 \\times M$ 之间，包括端点。\n- 裁判回复一行，包含一个整数：所有国王从未知位置到你指定的格子所需的总步数。\n\n你在本阶段最多可以进行 $R$ 次这样的交互。如果你超过 $R$ 次，或者请求格式错误或越界，裁判会回复一行字符串 $\\text{ERROR}$。\n\n当你想结束第一阶段并进入第二阶段时，输出一行字符串 $\\text{READY}$（大小写不敏感），裁判会回复第二阶段的第一个请求。\n\n在第二阶段，第 $i$ 次交互如下：\n\n- 裁判输出一行，包含两个整数 $C_{i}$ 和 $D_{i}$，表示一个格子的 $x$ 和 $y$ 坐标。\n    - $C_{i}$ 和 $D_{i}$ 都在 $-10 \\times M$ 到 $10 \\times M$ 之间，包括端点。\n- 你的程序需要输出一行，包含一个整数：所有国王到达该点所需的总步数。\n\n裁判保证会发出至少 $1$ 次、至多 $R$ 次这样的请求。如果你的回答错误或格式不正确，裁判会回复 $\\text{ERROR}$。如果你全部回答正确，裁判会回复一行字符串 $\\text{DONE}$，此时你应开始下一个测试用例，或在所有 $T$ 个测试用例处理完毕后正常结束程序。\n\n如果裁判回复 $\\text{ERROR}$，则不会再有其他输出。如果你的程序在收到 $\\text{ERROR}$ 后继续等待裁判输出，将会超时（Time Limit Exceeded）。请确保你的程序在收到 $\\text{ERROR}$ 后及时退出，以便获得 Wrong Answer 而不是 TLE。如果超出内存限制或运行时错误，将会收到相应的判定。\n\n国王的数量和位置，以及第二阶段裁判发出的请求数量和位置，在所有交互开始前就已确定。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**交互样例**\n\n注意，以下交互样例对应于测试集 1，其中总是只有一个国王。\n\n```\n  // 假设裁判决定第一个测试用例中，国王在坐标 (1, -2)，请求为 (5, -1) 和 (7, 7)。\n  t, nmax, m, r = readline_int_list()   // 读取 10 1 1000000 1000\n  // 我们的解法（无论出于什么原因）首先查询 (3, 3)。\n  printline 3 3 to stdout\n  flush stdout\n  result = readline_int()               // 读取 5\n  // 现在查询 (2, 0)。\n  printline 2 0 to stdout\n  flush stdout\n  result = readline_int()               // 读取 2\n  // 我们推断国王在 (3, -2)，这与已知信息一致，但实际上不正确。\n  // 进入请求阶段。\n  printline READY to stdout\n  request_line = readline()             // 读取 5 -1\n  printline 2 to stdout                 // 错误答案！\n  request_line = readline()             // 读取 ERROR\n  exit                                  // 退出，避免 TLE\n```\n\n你可以使用本地或平台提供的测试工具进行测试。若要在本地测试，需要让测试工具与你的代码并行运行；你可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释。\n\n测试工具的使用说明见工具内注释。建议你自行添加测试用例。请注意，测试工具仅用于模拟评测系统，**并非**真实评测系统，可能存在差异。\n\n**限制条件**\n\n~~仅进行合法交互的程序，在我们的环境下运行时间约为：C++ 13 秒，Java 24 秒，Python 和 Go 19 秒。~~\n\n- $1 \\leq T \\leq 15$。\n- $M = 10^{6}$。\n- $-\\mathbf{M} \\leq X_{i} \\leq \\mathbf{M}$，对所有 $i$。\n- $-\\mathbf{M} \\leq Y_{i} \\leq \\mathbf{M}$，对所有 $i$。\n- 所有 $(X_{i}, Y_{i})$ 均互不相同。\n- $-10 \\times M \\leq C_{i} \\leq 10 \\times M$，对所有 $i$。\n- $-10 \\times M \\leq D_{i} \\leq 10 \\times M$，对所有 $i$。\n- $R = 1000$。\n\n**测试集 1（5 分，可见）**\n\n- $N_{\\text{max}} = 1$。\n\n**测试集 2（22 分，隐藏）**\n\n- $N_{\\text{max}} = 10$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13124", "type": "P", "difficulty": 6, "samples": [["2\n20 450 4 3\n10 10 11\n17 4 1000\n999 998 997\n10 10 11\n20 450 5 5\n1 2 3 4 5\n2 3 4 5 1\n3 4 5 1 2\n4 5 1 2 3\n5 1 2 3 4", "Case #1:\n2\n3 1 2\n2 1 3\n0\n1 2\n2 2 1\n1 2\nCase #2:\n1\n5 1 2 3 4\n0\n1 1\n2 1 1\n3 1 1 1\n4 1 1 1 1"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["2019", "Special Judge", "排序", "Ad-hoc", "Google Code Jam"], "title": "[GCJ 2019 Finals] Sorting Permutation Unit", "background": "", "description": "You may have heard of Google's Tensor Processing Units, which are used to build neural networks. However, there is one research area that is even deeper and more important than machine learning: sorting!\n\nWe are working on a special new chip called the Sorting Permutation Unit, which is very fast at applying permutations to arrays of integers. Formally, a permutation is an ordering of the first $\\mathbf{n}$ positive integers\n\n$$\\mathbf{p}_{1}, \\mathbf{p}_{2}, \\ldots, \\mathbf{p}_{\\mathbf{n}}$$\n\nand applying it to an array of $\\mathbf{n}$ integers\n\n$$\\mathbf{a}_{1}, \\mathbf{a}_{2}, \\ldots, \\mathbf{a}_{\\mathbf{n}}$$\n\nyields the new array\n\n$$\\mathbf{a}_{\\mathbf{p}_{1}}, \\mathbf{a}_{\\mathbf{p}_{2}}, \\ldots, \\mathbf{a}_{\\mathbf{p}_{\\mathbf{n}}}$$\n\nFor example, applying the permutation 3, 1, 2, 4 to the array 99, 234, 45, 800 would yield the new array 45, 99, 234, 800.\n\nHowever, permutations are expensive to represent in the hardware, so the unit can only have access to at most $\\mathbf{P}$ distinct permutations. We need your help figuring out what those permutations should be!\n\nGiven $\\mathbf{K}$ arrays of $\\mathbf{N}$ integers each, you must first specify up to $\\mathbf{P}$ permutations (of size $\\mathbf{N}$) of your choice. Then, for each of those $\\mathbf{K}$ input arrays, you must provide one sequence of up to $\\mathbf{S}$ instructions (each of which is a permutation from your specified set). When the instructions in this sequence are applied, in the given order, to the array, they must yield an array sorted in nondecreasing order. In each of your $\\mathbf{K}$ sequences of instructions, you may use each of your $\\mathbf{P}$ permutations zero or more times (not necessarily consecutively).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with four integers $\\mathbf{P}$, $\\mathbf{S}$, $\\mathbf{K}$, and $\\mathbf{N}$: the maximum number of permutations allowed, the maximum number of instructions you are allowed to use to sort each array, the number of arrays, and the number of integers in each array. Then, there are $\\mathbf{K}$ more lines of $\\mathbf{N}$ integers $\\mathbf{A}_{\\mathbf{i}1}$, $\\mathbf{A}_{\\mathbf{i}2}$, ..., $\\mathbf{A}_{\\mathbf{iN}}$ each, where the j-th integer on the i-th line, $\\mathbf{A}_{\\mathbf{ij}}$, represents the j-th value of the i-th array.", "outputFormat": "For each test case, first output the following, in this order:\n\n* One line containing Case #x:, where $\\mathbf{x}$ is the test case number (starting from 1).\n* One line containing one integer $\\mathbf{P}'$, where $1 \\leq \\mathbf{P}' \\leq \\mathbf{P}$: the number of permutations you have chosen to use.\n* $\\mathbf{P}'$ lines, the i-th of which contains $\\mathbf{N}$ integers $\\mathbf{p}_{\\mathbf{i}1}$ $\\mathbf{p}_{\\mathbf{i}2}$ ... $\\mathbf{p}_{\\mathbf{iN}}$, where $\\mathbf{p}_{\\mathbf{ij}}$ is the j-th element of the i-th permutation.\n\nThen, output $\\mathbf{K}$ more lines. The i-th of these gives the instructions that you will apply to the i-th array given in the input. Each such line must begin with one integer $\\mathbf{S}'$, where $0 \\leq \\mathbf{S}' \\leq \\mathbf{S}$, and must continue with $\\mathbf{S}'$ integers $\\mathbf{X}_{1}$, $\\mathbf{X}_{2}$, ..., $\\mathbf{X}_{\\mathbf{S}'}$, where $1 \\leq \\mathbf{X}_{\\mathbf{k}} \\leq \\mathbf{P}'$ for all $\\mathbf{k}$. Here, $\\mathbf{X}_{\\mathbf{k}}$ represents that the k-th instruction you apply to the i-th array is the $\\mathbf{X}_{\\mathbf{k}}$-th permutation (counting starting from 1) in your list of permutations. These instructions must yield an array with the elements of the i-th input array, sorted in nondecreasing order.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we can define up to $\\mathbf{P} = 20$ permutations. One viable strategy uses only these two:\n\n1. 3 1 2\n2. 2 1 3\n\nWe can handle the four arrays as follows:\n\n* 10 10 11: This is already sorted in nondecreasing order, so we do not need to do anything.\n* 17 4 1000: We can apply permutation #2 to yield 4 17 1000.\n* 999 998 997: One option is to first apply permutation #2 to turn the array into 998 999 997, then apply permutation #1 to turn the array into 997 998 999.\n* 10 10 11: This is the same as the first array. Applying permutation #2 also yields array sorted in nondecreasing order. (But we could have used the line 0 as we did before.)\n\nIn Sample Case #2, notice that we can use the same permutation instruction more than once on the same array, if desired.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 10$.\n- $\\mathbf{S} = 450$.\n- $1 \\leq \\mathbf{K} \\leq 30$.\n- $2 \\leq \\mathbf{N} \\leq 50$.\n- $1 \\leq \\mathbf{A}_{\\mathbf{ij}} \\leq 1000$, for all $\\mathbf{i}$ and $\\mathbf{j}$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $\\mathbf{P} = 20$.\n\n**Test set 2 (22 Pts, Hidden)**\n\n- $\\mathbf{P} = 5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Finals] Sorting Permutation Unit", "background": "", "description": "You may have heard of Google's Tensor Processing Units, which are used to build neural networks. However, there is one research area that is even deeper and more important than machine learning: sorting!\n\nWe are working on a special new chip called the Sorting Permutation Unit, which is very fast at applying permutations to arrays of integers. Formally, a permutation is an ordering of the first $\\mathbf{n}$ positive integers\n\n$$\\mathbf{p}_{1}, \\mathbf{p}_{2}, \\ldots, \\mathbf{p}_{\\mathbf{n}}$$\n\nand applying it to an array of $\\mathbf{n}$ integers\n\n$$\\mathbf{a}_{1}, \\mathbf{a}_{2}, \\ldots, \\mathbf{a}_{\\mathbf{n}}$$\n\nyields the new array\n\n$$\\mathbf{a}_{\\mathbf{p}_{1}}, \\mathbf{a}_{\\mathbf{p}_{2}}, \\ldots, \\mathbf{a}_{\\mathbf{p}_{\\mathbf{n}}}$$\n\nFor example, applying the permutation 3, 1, 2, 4 to the array 99, 234, 45, 800 would yield the new array 45, 99, 234, 800.\n\nHowever, permutations are expensive to represent in the hardware, so the unit can only have access to at most $\\mathbf{P}$ distinct permutations. We need your help figuring out what those permutations should be!\n\nGiven $\\mathbf{K}$ arrays of $\\mathbf{N}$ integers each, you must first specify up to $\\mathbf{P}$ permutations (of size $\\mathbf{N}$) of your choice. Then, for each of those $\\mathbf{K}$ input arrays, you must provide one sequence of up to $\\mathbf{S}$ instructions (each of which is a permutation from your specified set). When the instructions in this sequence are applied, in the given order, to the array, they must yield an array sorted in nondecreasing order. In each of your $\\mathbf{K}$ sequences of instructions, you may use each of your $\\mathbf{P}$ permutations zero or more times (not necessarily consecutively).", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with four integers $\\mathbf{P}$, $\\mathbf{S}$, $\\mathbf{K}$, and $\\mathbf{N}$: the maximum number of permutations allowed, the maximum number of instructions you are allowed to use to sort each array, the number of arrays, and the number of integers in each array. Then, there are $\\mathbf{K}$ more lines of $\\mathbf{N}$ integers $\\mathbf{A}_{\\mathbf{i}1}$, $\\mathbf{A}_{\\mathbf{i}2}$, ..., $\\mathbf{A}_{\\mathbf{iN}}$ each, where the j-th integer on the i-th line, $\\mathbf{A}_{\\mathbf{ij}}$, represents the j-th value of the i-th array.", "outputFormat": "For each test case, first output the following, in this order:\n\n* One line containing Case #x:, where $\\mathbf{x}$ is the test case number (starting from 1).\n* One line containing one integer $\\mathbf{P}'$, where $1 \\leq \\mathbf{P}' \\leq \\mathbf{P}$: the number of permutations you have chosen to use.\n* $\\mathbf{P}'$ lines, the i-th of which contains $\\mathbf{N}$ integers $\\mathbf{p}_{\\mathbf{i}1}$ $\\mathbf{p}_{\\mathbf{i}2}$ ... $\\mathbf{p}_{\\mathbf{iN}}$, where $\\mathbf{p}_{\\mathbf{ij}}$ is the j-th element of the i-th permutation.\n\nThen, output $\\mathbf{K}$ more lines. The i-th of these gives the instructions that you will apply to the i-th array given in the input. Each such line must begin with one integer $\\mathbf{S}'$, where $0 \\leq \\mathbf{S}' \\leq \\mathbf{S}$, and must continue with $\\mathbf{S}'$ integers $\\mathbf{X}_{1}$, $\\mathbf{X}_{2}$, ..., $\\mathbf{X}_{\\mathbf{S}'}$, where $1 \\leq \\mathbf{X}_{\\mathbf{k}} \\leq \\mathbf{P}'$ for all $\\mathbf{k}$. Here, $\\mathbf{X}_{\\mathbf{k}}$ represents that the k-th instruction you apply to the i-th array is the $\\mathbf{X}_{\\mathbf{k}}$-th permutation (counting starting from 1) in your list of permutations. These instructions must yield an array with the elements of the i-th input array, sorted in nondecreasing order.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, we can define up to $\\mathbf{P} = 20$ permutations. One viable strategy uses only these two:\n\n1. 3 1 2\n2. 2 1 3\n\nWe can handle the four arrays as follows:\n\n* 10 10 11: This is already sorted in nondecreasing order, so we do not need to do anything.\n* 17 4 1000: We can apply permutation #2 to yield 4 17 1000.\n* 999 998 997: One option is to first apply permutation #2 to turn the array into 998 999 997, then apply permutation #1 to turn the array into 997 998 999.\n* 10 10 11: This is the same as the first array. Applying permutation #2 also yields array sorted in nondecreasing order. (But we could have used the line 0 as we did before.)\n\nIn Sample Case #2, notice that we can use the same permutation instruction more than once on the same array, if desired.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 10$.\n- $\\mathbf{S} = 450$.\n- $1 \\leq \\mathbf{K} \\leq 30$.\n- $2 \\leq \\mathbf{N} \\leq 50$.\n- $1 \\leq \\mathbf{A}_{\\mathbf{ij}} \\leq 1000$, for all $\\mathbf{i}$ and $\\mathbf{j}$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $\\mathbf{P} = 20$.\n\n**Test set 2 (22 Pts, Hidden)**\n\n- $\\mathbf{P} = 5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Finals] Sorting Permutation Unit", "background": null, "description": "你可能听说过 Google 的张量处理单元（Tensor Processing Units），它们被用于构建神经网络。然而，有一个比机器学习更深奥、更重要的研究领域：排序！\n\n我们正在研发一种名为“排序置换单元”（Sorting Permutation Unit）的特殊芯片，它能非常快速地对整数数组应用置换。形式化地说，置换是对前 $n$ 个正整数的一种排列：\n\n$$\\mathbf{p}_{1}, \\mathbf{p}_{2}, \\ldots, \\mathbf{p}_{\\mathbf{n}}$$\n\n将其应用于一个包含 $n$ 个整数的数组\n\n$$\\mathbf{a}_{1}, \\mathbf{a}_{2}, \\ldots, \\mathbf{a}_{\\mathbf{n}}$$\n\n会得到新的数组\n\n$$\\mathbf{a}_{\\mathbf{p}_{1}}, \\mathbf{a}_{\\mathbf{p}_{2}}, \\ldots, \\mathbf{a}_{\\mathbf{p}_{\\mathbf{n}}}$$\n\n例如，将置换 3, 1, 2, 4 应用于数组 99, 234, 45, 800，会得到新数组 45, 99, 234, 800。\n\n然而，硬件中表示置换的代价很高，因此该单元最多只能使用 $\\mathbf{P}$ 个不同的置换。我们需要你的帮助，来确定这些置换应该是什么！\n\n给定 $\\mathbf{K}$ 个长度为 $\\mathbf{N}$ 的整数数组，你首先需要指定至多 $\\mathbf{P}$ 个你选择的置换（每个置换长度为 $\\mathbf{N}$）。然后，对于每一个输入数组，你需要给出一组最多包含 $\\mathbf{S}$ 条指令的序列（每条指令是你指定的置换之一）。当按顺序对该数组应用这些指令后，最终得到的数组必须是非递减有序的。在每个数组的指令序列中，你可以对每个置换使用零次或多次（不要求连续）。", "inputFormat": "输入的第一行是测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例的第一行为四个整数 $\\mathbf{P}$、$\\mathbf{S}$、$\\mathbf{K}$ 和 $\\mathbf{N}$，分别表示最多允许的置换数、对每个数组最多允许的指令数、数组的数量以及每个数组中的整数个数。接下来有 $\\mathbf{K}$ 行，每行包含 $\\mathbf{N}$ 个整数 $\\mathbf{A}_{\\mathbf{i}1}$、$\\mathbf{A}_{\\mathbf{i}2}$、...、$\\mathbf{A}_{\\mathbf{iN}}$，其中第 $i$ 行的第 $j$ 个整数 $\\mathbf{A}_{\\mathbf{ij}}$ 表示第 $i$ 个数组的第 $j$ 个值。", "outputFormat": "对于每个测试用例，按以下顺序输出：\n\n- 首先输出一行 `Case #x:`，其中 $x$ 是测试用例编号（从 1 开始）。\n- 输出一行一个整数 $\\mathbf{P}'$，表示你选择使用的置换数量，$1 \\leq \\mathbf{P}' \\leq \\mathbf{P}$。\n- 接下来输出 $\\mathbf{P}'$ 行，每行包含 $\\mathbf{N}$ 个整数 $\\mathbf{p}_{\\mathbf{i}1}$ $\\mathbf{p}_{\\mathbf{i}2}$ ... $\\mathbf{p}_{\\mathbf{iN}}$，表示第 $i$ 个置换的内容。\n\n然后，再输出 $\\mathbf{K}$ 行。第 $i$ 行表示你将应用于输入中第 $i$ 个数组的指令序列。每行首先是一个整数 $\\mathbf{S}'$，$0 \\leq \\mathbf{S}' \\leq \\mathbf{S}$，接着是 $\\mathbf{S}'$ 个整数 $\\mathbf{X}_{1}$、$\\mathbf{X}_{2}$、...、$\\mathbf{X}_{\\mathbf{S}'}$，其中 $1 \\leq \\mathbf{X}_{\\mathbf{k}} \\leq \\mathbf{P}'$。这里，$\\mathbf{X}_{\\mathbf{k}}$ 表示对第 $i$ 个数组应用的第 $k$ 条指令是你置换列表中第 $\\mathbf{X}_{\\mathbf{k}}$ 个置换（从 1 开始编号）。这些指令应用后，得到的数组必须是输入数组元素的非递减排列。", "hint": "**样例解释**\n\n在样例 1 中，我们最多可以定义 $\\mathbf{P} = 20$ 个置换。一种可行的策略只用到了以下两个：\n\n1. 3 1 2\n2. 2 1 3\n\n我们可以这样处理四个数组：\n\n- 10 10 11：已经是非递减有序，无需操作。\n- 17 4 1000：可以应用第 2 个置换，得到 4 17 1000。\n- 999 998 997：可以先应用第 2 个置换，得到 998 999 997，再应用第 1 个置换，得到 997 998 999。\n- 10 10 11：与第一个数组相同，也可以应用第 2 个置换得到有序数组（当然也可以直接输出 0）。\n\n在样例 2 中，注意同一个置换指令可以在同一个数组上多次使用。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 10$。\n- $\\mathbf{S} = 450$。\n- $1 \\leq \\mathbf{K} \\leq 30$。\n- $2 \\leq \\mathbf{N} \\leq 50$。\n- $1 \\leq \\mathbf{A}_{\\mathbf{ij}} \\leq 1000$，对于所有 $i$ 和 $j$。\n\n**测试点 1（5 分，可见）**\n\n- $\\mathbf{P} = 20$。\n\n**测试点 2（22 分，隐藏）**\n\n- $\\mathbf{P} = 5$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13125", "type": "P", "difficulty": 7, "samples": [["3\n1\n198\n1234567890", "Case #1: 1\nCase #2: 191 7\nCase #3: 672787276 94449 561686165"]], "limits": {"time": [20000, 20000, 20000], "memory": [1048576, 1048576, 1048576]}, "tags": ["搜索", "数学", "2019", "Special Judge", "剪枝", "数位 DP", "Google Code Jam"], "title": "[GCJ 2019 Finals] Won't sum? Must now", "background": "", "description": "In 2016, it was shown that every positive integer can be written as the sum of three or fewer palindromic terms. For the purposes of this problem, a palindromic term is a string of digits (with no leading zeroes) that represents a positive integer and reads the same forward and backward.\n\nGiven a positive integer $\\mathbf{S}$, find $\\mathbf{K}$ palindromic terms that sum to $\\mathbf{S}$, such that $\\mathbf{K}$ is minimized.", "inputFormat": "The first line of input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow, each containing a positive integer $\\mathbf{S}$.\n", "outputFormat": "For each test case, output one line of the form Case #x: $A_1$ (if only one term is needed), Case #x: $A_1$ $A_2$ (if only two terms are needed), or Case #x: $A_1$ $A_2$ $A_3$ (if three terms are needed), where $x$ is the case number (counting starting from 1), each $A_i$ is a palindromic term (as described above), and the sum of the $A_i$s equals $\\mathbf{S}$.\n", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the input is already a palindrome.\n\nIn Sample Case #2, note that `99 99`, for example, would also be an acceptable answer. Even though there are multiple instances of 99, they count as separate terms, so this solution uses the same number of terms as 191 7.\n\nAlso note that `191 07`, `181 8 9`, `0110 88`, `101 97`, `7.0 191.0`, and `-202 4`, for example, would not be acceptable answers.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $1 \\leq \\mathbf{S} \\leq 10^{10}$.\n\n**Test set 2 (22 Pts, Hidden)**\n\n- $1 \\leq \\mathbf{S} \\leq 10^{40}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Finals] Won't sum? Must now", "background": "", "description": "In 2016, it was shown that every positive integer can be written as the sum of three or fewer palindromic terms. For the purposes of this problem, a palindromic term is a string of digits (with no leading zeroes) that represents a positive integer and reads the same forward and backward.\n\nGiven a positive integer $\\mathbf{S}$, find $\\mathbf{K}$ palindromic terms that sum to $\\mathbf{S}$, such that $\\mathbf{K}$ is minimized.", "inputFormat": "The first line of input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ lines follow, each containing a positive integer $\\mathbf{S}$.\n", "outputFormat": "For each test case, output one line of the form Case #x: $A_1$ (if only one term is needed), Case #x: $A_1$ $A_2$ (if only two terms are needed), or Case #x: $A_1$ $A_2$ $A_3$ (if three terms are needed), where $x$ is the case number (counting starting from 1), each $A_i$ is a palindromic term (as described above), and the sum of the $A_i$s equals $\\mathbf{S}$.\n", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the input is already a palindrome.\n\nIn Sample Case #2, note that `99 99`, for example, would also be an acceptable answer. Even though there are multiple instances of 99, they count as separate terms, so this solution uses the same number of terms as 191 7.\n\nAlso note that `191 07`, `181 8 9`, `0110 88`, `101 97`, `7.0 191.0`, and `-202 4`, for example, would not be acceptable answers.\n\n**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $1 \\leq \\mathbf{S} \\leq 10^{10}$.\n\n**Test set 2 (22 Pts, Hidden)**\n\n- $1 \\leq \\mathbf{S} \\leq 10^{40}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Finals] Won't sum? Must now", "background": null, "description": "2016 年，有研究表明每个正整数都可以表示为不超过三个回文数之和。在本题中，回文数指的是没有前导零、正读和反读都相同的正整数。\n\n给定一个正整数 $\\mathbf{S}$，请找出 $\\mathbf{K}$ 个回文数，使它们的和等于 $\\mathbf{S}$，并且 $\\mathbf{K}$ 最小。", "inputFormat": "输入的第一行为测试用例数 $\\mathbf{T}$。接下来的 $\\mathbf{T}$ 行，每行包含一个正整数 $\\mathbf{S}$。", "outputFormat": "对于每个测试用例，输出一行，格式为 Case #x: $A_1$（如果只需要一个回文数）、Case #x: $A_1$ $A_2$（如果需要两个回文数），或 Case #x: $A_1$ $A_2$ $A_3$（如果需要三个回文数），其中 $x$ 为测试用例编号（从 1 开始），每个 $A_i$ 为一个回文数，且 $A_1 + A_2 + \\cdots + A_K = \\mathbf{S}$。", "hint": "**样例解释**\n\n在样例第 1 个用例中，输入本身就是回文数。\n\n在样例第 2 个用例中，`99 99` 也是一个可行答案。即使有多个 99，它们也算作不同的项，因此这个解法和 `191 7` 使用的项数相同。\n\n注意，`191 07`、`181 8 9`、`0110 88`、`101 97`、`7.0 191.0`、`-202 4` 等都不是可接受的答案。\n\n**数据范围**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n\n**测试点 1（5 分，可见）**\n\n- $1 \\leq \\mathbf{S} \\leq 10^{10}$。\n\n**测试点 2（22 分，隐藏）**\n\n- $1 \\leq \\mathbf{S} \\leq 10^{40}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13126", "type": "P", "difficulty": 6, "samples": [["3\n2\n-1 -1\n-1 1\n1 1\n1 -1\n3\n1 2\n2 1\n2 3\n3 1\n3 3\n4 2\n3\n7 1\n1 1\n7 2\n5 5\n3 5\n1 2", "Case #1: 3 4 1 2\nCase #2: 6 5 4 3 2 1\nCase #3: 5 4 6 2 1 3"]], "limits": {"time": [20000, 20000, 60000], "memory": [1048576, 1048576, 1048576]}, "tags": ["计算几何", "2019", "分治", "Google Code Jam"], "title": "[GCJ 2019 Finals] Juggle Struggle: Part 1", "background": "", "description": "The first two paragraphs (not counting this one) of this problem and \"Juggle Struggle: Part 2\" are identical. The problems can otherwise be solved independently; you do not need to read or solve one in order to read or solve the other.\n\nAs manager of the Graceful Chainsaw Jugglers group, you have decided to spice the show up a bit. Instead of having each juggler individually juggle their own chainsaws, you want them to form pairs, with each pair throwing the chainsaws back and forth to each other. In this new performance, $2 \\times \\mathbf{N}$ jugglers will be on stage at the same time, arranged into $\\mathbf{N}$ pairs, with each juggler belonging to exactly one pair.\n\nYou think the show will be more impressive if the chainsaws being juggled by different pairs of jugglers are at risk of collision. Let the stage be a two-dimensional plane, and let the straight line segment in that plane that connects the positions of two jugglers in a pair be called the pair's juggling path. When two juggling paths intersect, we say the chainsaws juggled by those pairs are at risk of collision. We call the spatial positions and the pairings of the jugglers an arrangement. An arrangement is magnificent if every two pairs of jugglers' chainsaws are at risk of collision.\n\nAfter a lot of thinking and designing, you came up with a magnificent arrangement. You wrote down the positions of the jugglers on the stage and the pairings of the jugglers on a piece of paper. Unfortunately, a bad chainsaw throw cut the paper in half, and you have lost the half with the pairings. Since the stage decorations have already been designed based on the positions of the jugglers, those positions cannot be changed. The show's highly anticipated debut is a mere few hours away, so you need to find a magnificent arrangement that works! Given every juggler's position on a two-dimensional stage, find a pairing of them that yields a magnificent arrangement.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with one line containing a single integer $\\mathbf{N}$, the number of pairs of jugglers. Then, $2 \\times \\mathbf{N}$ lines follow. The i-th of these lines contains two integers $\\mathbf{X}_\\mathbf{i}$ and $\\mathbf{Y}_\\mathbf{i}$, representing the coordinates of the position of the i-th juggler.\n", "outputFormat": "For each test case, output one line containing Case #x: $j_1$ $j_2$ $\\dots$ $j_{2 \\times \\mathbf{N}}$, representing that jugglers $i$ and $j_i$ are to be paired together, for every $i$. Notice that $j_{j_i} = i$ for every $i$.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the jugglers' positions form a square. The only valid solution is to pair up jugglers 1 and 3, and pair up jugglers 2 and 4.\n\n**Limits**\n\n- $-10^9 \\leq \\mathbf{X}_\\mathbf{i} \\leq 10^9$, for all i.\n- $-10^9 \\leq \\mathbf{Y}_\\mathbf{i} \\leq 10^9$, for all i.\n- No three juggler positions are collinear. (Note that this also implies that no two jugglers are in the same position.)\n- There exists at least one way to pair the jugglers such that the resulting arrangement is magnificent.\n\n**Test set 1 (5 Pts, Visible)**\n\n- Time limit: 20 seconds.\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 100$.\n\n**Test set 2 (30 Pts, Hidden)**\n\n- Time limit: 60 seconds.\n- $1 \\leq \\mathbf{T} \\leq 10$.\n- $2 \\leq \\mathbf{N} \\leq 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Finals] Juggle Struggle: Part 1", "background": "", "description": "The first two paragraphs (not counting this one) of this problem and \"Juggle Struggle: Part 2\" are identical. The problems can otherwise be solved independently; you do not need to read or solve one in order to read or solve the other.\n\nAs manager of the Graceful Chainsaw Jugglers group, you have decided to spice the show up a bit. Instead of having each juggler individually juggle their own chainsaws, you want them to form pairs, with each pair throwing the chainsaws back and forth to each other. In this new performance, $2 \\times \\mathbf{N}$ jugglers will be on stage at the same time, arranged into $\\mathbf{N}$ pairs, with each juggler belonging to exactly one pair.\n\nYou think the show will be more impressive if the chainsaws being juggled by different pairs of jugglers are at risk of collision. Let the stage be a two-dimensional plane, and let the straight line segment in that plane that connects the positions of two jugglers in a pair be called the pair's juggling path. When two juggling paths intersect, we say the chainsaws juggled by those pairs are at risk of collision. We call the spatial positions and the pairings of the jugglers an arrangement. An arrangement is magnificent if every two pairs of jugglers' chainsaws are at risk of collision.\n\nAfter a lot of thinking and designing, you came up with a magnificent arrangement. You wrote down the positions of the jugglers on the stage and the pairings of the jugglers on a piece of paper. Unfortunately, a bad chainsaw throw cut the paper in half, and you have lost the half with the pairings. Since the stage decorations have already been designed based on the positions of the jugglers, those positions cannot be changed. The show's highly anticipated debut is a mere few hours away, so you need to find a magnificent arrangement that works! Given every juggler's position on a two-dimensional stage, find a pairing of them that yields a magnificent arrangement.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with one line containing a single integer $\\mathbf{N}$, the number of pairs of jugglers. Then, $2 \\times \\mathbf{N}$ lines follow. The i-th of these lines contains two integers $\\mathbf{X}_\\mathbf{i}$ and $\\mathbf{Y}_\\mathbf{i}$, representing the coordinates of the position of the i-th juggler.\n", "outputFormat": "For each test case, output one line containing Case #x: $j_1$ $j_2$ $\\dots$ $j_{2 \\times \\mathbf{N}}$, representing that jugglers $i$ and $j_i$ are to be paired together, for every $i$. Notice that $j_{j_i} = i$ for every $i$.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the jugglers' positions form a square. The only valid solution is to pair up jugglers 1 and 3, and pair up jugglers 2 and 4.\n\n**Limits**\n\n- $-10^9 \\leq \\mathbf{X}_\\mathbf{i} \\leq 10^9$, for all i.\n- $-10^9 \\leq \\mathbf{Y}_\\mathbf{i} \\leq 10^9$, for all i.\n- No three juggler positions are collinear. (Note that this also implies that no two jugglers are in the same position.)\n- There exists at least one way to pair the jugglers such that the resulting arrangement is magnificent.\n\n**Test set 1 (5 Pts, Visible)**\n\n- Time limit: 20 seconds.\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 100$.\n\n**Test set 2 (30 Pts, Hidden)**\n\n- Time limit: 60 seconds.\n- $1 \\leq \\mathbf{T} \\leq 10$.\n- $2 \\leq \\mathbf{N} \\leq 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Finals] Juggle Struggle: Part 1", "background": null, "description": "本题的前两段（不包括本段）与“Juggle Struggle: Part 2”完全相同。除此之外，这两道题可以独立解决；你无需阅读或解决其中一道题即可理解或解决另一道题。\n\n作为 Graceful Chainsaw Jugglers 团队的经理，你决定让表演更加精彩。你不再让每位杂技演员单独抛接自己的电锯，而是让他们两两组队，每对互相抛接电锯。在这种新表演中，将有 $2 \\times \\mathbf{N}$ 名杂技演员同时登台，被分为 $\\mathbf{N}$ 对，每位杂技演员恰好属于一对。\n\n你认为，如果不同对的杂技演员所抛接的电锯有相互碰撞的风险，表演会更加惊险。设舞台为一个二维平面，连接一对杂技演员位置的直线段称为该对的抛接路径。当两条抛接路径相交时，称这两对杂技演员的电锯存在碰撞风险。我们称杂技演员的空间位置及其配对方式为一种“安排”。如果每两对杂技演员的电锯都存在碰撞风险，则称该安排为“壮观的安排”。\n\n经过长时间的思考和设计，你想出了一个壮观的安排，并把杂技演员在舞台上的位置和配对方式记录在纸上。不幸的是，一次失误的电锯抛掷把纸张切成了两半，你丢失了记载配对方式的那一半。由于舞台布景已经根据杂技演员的位置设计好，这些位置无法更改。距离备受期待的首演只剩下几个小时，你需要重新找到一个壮观的安排！给定每位杂技演员在二维舞台上的位置，请找出一种配对方式，使得该安排是壮观的。", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例的数量。接下来有 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含一个整数 $\\mathbf{N}$，表示杂技演员对数。接下来的 $2 \\times \\mathbf{N}$ 行，每行包含两个整数 $\\mathbf{X}_\\mathbf{i}$ 和 $\\mathbf{Y}_\\mathbf{i}$，表示第 $i$ 位杂技演员的位置坐标。", "outputFormat": "对于每个测试用例，输出一行，格式为 Case #x: $j_1$ $j_2$ $\\dots$ $j_{2 \\times \\mathbf{N}}$，表示第 $i$ 位杂技演员应与第 $j_i$ 位杂技演员配对，对于每个 $i$ 都满足 $j_{j_i} = i$。", "hint": "**样例解释**\n\n在样例第 1 个测试用例中，杂技演员的位置构成一个正方形。唯一的有效方案是将第 1 位与第 3 位配对，第 2 位与第 4 位配对。\n\n**数据范围**\n\n- $-10^9 \\leq \\mathbf{X}_\\mathbf{i} \\leq 10^9$，对所有 $i$ 成立。\n- $-10^9 \\leq \\mathbf{Y}_\\mathbf{i} \\leq 10^9$，对所有 $i$ 成立。\n- 任意三位杂技演员的位置不共线。（这也意味着没有两位杂技演员处于同一位置。）\n- 至少存在一种配对方式，使得最终安排是壮观的。\n\n**测试点 1（5 分，公开）**\n\n- 时间限制：20 秒。\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{N} \\leq 100$。\n\n**测试点 2（30 分，隐藏）**\n\n- 时间限制：60 秒。\n- $1 \\leq \\mathbf{T} \\leq 10$。\n- $2 \\leq \\mathbf{N} \\leq 10^5$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13127", "type": "P", "difficulty": 7, "samples": [["4\n2\n-1 -1 -1 1\n1 1 1 -1\n2\n-1 -1 1 1\n-1 1 1 -1\n4\n1 2 4 2\n2 1 3 1\n2 4 3 0\n3 3 2 3\n3\n1 1 2 2\n3 7 4 8\n8 3 9 3", "Case #1: 1 2\nCase #2: MAGNIFICENT\nCase #3: 1 2 4\nCase #4: 1 2 3"]], "limits": {"time": [20000, 20000, 45000], "memory": [1048576, 1048576, 1048576]}, "tags": ["计算几何", "2019", "凸包", "Google Code Jam"], "title": "[GCJ 2019 Finals] Juggle Struggle: Part 2", "background": "", "description": "The first two paragraphs (not counting this one) of this problem and \"Juggle Struggle: Part 1\" are identical. The problems can otherwise be solved independently; you do not need to read or solve one in order to read or solve the other.\n\nAs manager of the Graceful Chainsaw Jugglers group, you have decided to spice the show up a bit. Instead of having each juggler individually juggle their own chainsaws, you want them to form pairs, with each pair throwing the chainsaws back and forth to each other. In this new performance, $2 \\times \\mathbf{N}$ jugglers will be on stage at the same time, arranged into $\\mathbf{N}$ pairs, with each juggler belonging to exactly one pair.\n\nYou think the show will be more impressive if the chainsaws being juggled by different pairs of jugglers are at risk of collision. Let the stage be a two-dimensional plane, and let the straight line segment in that plane that connects the positions of two jugglers in a pair be called the pair's juggling path. When two juggling paths intersect, we say the chainsaws juggled by those pairs are at risk of collision. We call the spatial positions and the pairings of the jugglers an arrangement. An arrangement is magnificent if every two pairs of jugglers' chainsaws are at risk of collision. That is, for the arrangement to be magnificent, each of the $\\mathbf{N}$ juggling path segments must intersect each of the other $\\mathbf{N}-1$ juggling path segments (but these intersections do not necessarily all have to be in the same place).\n\nAfter some last minute fixes, you have what you think is a magnificent arrangement. Given the rush to put it together, you want to write a checker that can determine whether it is indeed magnificent. If it is not, then at most 25 juggler pairs fail to intersect every other pair. You want your checker to report a list of all those juggler pairs for inspection.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with one line containing a single integer $\\mathbf{N}$, the number of pairs of jugglers. Then, $\\mathbf{N}$ lines follow. The i-th of these lines contains four integers $\\mathbf{X}_\\mathbf{i}$, $\\mathbf{Y}_\\mathbf{i}$, $\\mathbf{X'}_\\mathbf{i}$, $\\mathbf{Y'}_\\mathbf{i}$. ($\\mathbf{X}_\\mathbf{i}$, $\\mathbf{Y}_\\mathbf{i}$) and ($\\mathbf{X'}_\\mathbf{i}$, $\\mathbf{Y'}_\\mathbf{i}$) are the coordinates of the positions of the two jugglers comprising the i-th juggler pair.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $y$ is uppercase MAGNIFICENT if the input represents a magnificent arrangement. Otherwise, $y$ should be a strictly increasing list of integers. Integer $i$ should be on that list if and only if the juggling path of the $i$-th juggler pair fails to intersect at least one other juggling path.", "hint": "**Sample Explanation**\n\n- In Sample Case #1, there are only two pairs, and their paths do not cross.\n- In Sample Case #2, the arrangement is magnificent: every pair's path crosses every other pair's path.\n- In Sample Case #3, only pair 3's path crosses every other pair's path.\n\n**Limits**\n\n- $-10^9 \\leq \\mathbf{X}_\\mathbf{i} \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y}_\\mathbf{i} \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{X'}_\\mathbf{i} \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y'}_\\mathbf{i} \\leq 10^9$, for all $i$.\n- No three juggler positions are collinear. (Note that this also implies that no two jugglers are in the same position.)\n- For all but up to 25 pairs of jugglers, their juggling paths intersect all $\\mathbf{N} - 1$ other juggling paths.\n- Note: There may or may not exist a way to pair the jugglers such that the resulting arrangement is magnificent.\n\n**Test set 1 (5 Pts, Visible)**\n\n- Time limit: 20 seconds.\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 100$.\n\n**Test set 2 (30 Pts, Hidden)**\n\n- Time limit: 45 seconds.\n- $1 \\leq \\mathbf{T} \\leq 13$.\n- $2 \\leq \\mathbf{N} \\leq 10^5$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Finals] Juggle Struggle: Part 2", "background": "", "description": "The first two paragraphs (not counting this one) of this problem and \"Juggle Struggle: Part 1\" are identical. The problems can otherwise be solved independently; you do not need to read or solve one in order to read or solve the other.\n\nAs manager of the Graceful Chainsaw Jugglers group, you have decided to spice the show up a bit. Instead of having each juggler individually juggle their own chainsaws, you want them to form pairs, with each pair throwing the chainsaws back and forth to each other. In this new performance, $2 \\times \\mathbf{N}$ jugglers will be on stage at the same time, arranged into $\\mathbf{N}$ pairs, with each juggler belonging to exactly one pair.\n\nYou think the show will be more impressive if the chainsaws being juggled by different pairs of jugglers are at risk of collision. Let the stage be a two-dimensional plane, and let the straight line segment in that plane that connects the positions of two jugglers in a pair be called the pair's juggling path. When two juggling paths intersect, we say the chainsaws juggled by those pairs are at risk of collision. We call the spatial positions and the pairings of the jugglers an arrangement. An arrangement is magnificent if every two pairs of jugglers' chainsaws are at risk of collision. That is, for the arrangement to be magnificent, each of the $\\mathbf{N}$ juggling path segments must intersect each of the other $\\mathbf{N}-1$ juggling path segments (but these intersections do not necessarily all have to be in the same place).\n\nAfter some last minute fixes, you have what you think is a magnificent arrangement. Given the rush to put it together, you want to write a checker that can determine whether it is indeed magnificent. If it is not, then at most 25 juggler pairs fail to intersect every other pair. You want your checker to report a list of all those juggler pairs for inspection.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with one line containing a single integer $\\mathbf{N}$, the number of pairs of jugglers. Then, $\\mathbf{N}$ lines follow. The i-th of these lines contains four integers $\\mathbf{X}_\\mathbf{i}$, $\\mathbf{Y}_\\mathbf{i}$, $\\mathbf{X'}_\\mathbf{i}$, $\\mathbf{Y'}_\\mathbf{i}$. ($\\mathbf{X}_\\mathbf{i}$, $\\mathbf{Y}_\\mathbf{i}$) and ($\\mathbf{X'}_\\mathbf{i}$, $\\mathbf{Y'}_\\mathbf{i}$) are the coordinates of the positions of the two jugglers comprising the i-th juggler pair.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $y$ is uppercase MAGNIFICENT if the input represents a magnificent arrangement. Otherwise, $y$ should be a strictly increasing list of integers. Integer $i$ should be on that list if and only if the juggling path of the $i$-th juggler pair fails to intersect at least one other juggling path.", "hint": "**Sample Explanation**\n\n- In Sample Case #1, there are only two pairs, and their paths do not cross.\n- In Sample Case #2, the arrangement is magnificent: every pair's path crosses every other pair's path.\n- In Sample Case #3, only pair 3's path crosses every other pair's path.\n\n**Limits**\n\n- $-10^9 \\leq \\mathbf{X}_\\mathbf{i} \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y}_\\mathbf{i} \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{X'}_\\mathbf{i} \\leq 10^9$, for all $i$.\n- $-10^9 \\leq \\mathbf{Y'}_\\mathbf{i} \\leq 10^9$, for all $i$.\n- No three juggler positions are collinear. (Note that this also implies that no two jugglers are in the same position.)\n- For all but up to 25 pairs of jugglers, their juggling paths intersect all $\\mathbf{N} - 1$ other juggling paths.\n- Note: There may or may not exist a way to pair the jugglers such that the resulting arrangement is magnificent.\n\n**Test set 1 (5 Pts, Visible)**\n\n- Time limit: 20 seconds.\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $2 \\leq \\mathbf{N} \\leq 100$.\n\n**Test set 2 (30 Pts, Hidden)**\n\n- Time limit: 45 seconds.\n- $1 \\leq \\mathbf{T} \\leq 13$.\n- $2 \\leq \\mathbf{N} \\leq 10^5$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Finals] Juggle Struggle: Part 2", "background": null, "description": "本题的前两段（不包括本段）与“Juggle Struggle: Part 1”完全相同。除此之外，这两道题可以独立解决，你无需阅读或解决其中一道才能理解或解决另一道。\n\n作为 Graceful Chainsaw Jugglers 团队的经理，你决定让表演更加精彩。你不再让每个杂技演员单独抛接自己的电锯，而是让他们两两组队，每对互相抛接电锯。在新的表演中，$2 \\times \\mathbf{N}$ 名杂技演员将同时登台，分成 $\\mathbf{N}$ 对，每个杂技演员恰好属于一对。\n\n你认为，如果不同杂技演员对抛接的电锯有相互碰撞的风险，表演会更加惊险。设舞台为一个二维平面，将一对杂技演员的位置用一条直线段连接，称为该对的“抛接路径”。当两对杂技演员的抛接路径相交时，说明他们抛接的电锯存在碰撞风险。我们将杂技演员的空间位置和分组方式称为一种“安排”。如果每一对杂技演员的抛接路径都与其他每一对的抛接路径相交，则称该安排为“壮观的”。也就是说，要使安排壮观，$\\mathbf{N}$ 条抛接路径中的每一条都必须与其他 $\\mathbf{N}-1$ 条路径相交（这些交点不必都在同一位置）。\n\n经过最后的调整后，你认为你已经得到了一个壮观的安排。由于准备仓促，你希望编写一个检查程序，判断该安排是否真的壮观。如果不是，则最多有 25 对杂技演员的抛接路径未能与所有其他对的路径相交。你希望你的检查程序能列出所有这些未达标的杂技演员对，供进一步检查。", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例的数量。接下来有 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含一个整数 $\\mathbf{N}$，表示杂技演员对的数量。接下来的 $\\mathbf{N}$ 行，每行包含四个整数 $\\mathbf{X}_\\mathbf{i}$、$\\mathbf{Y}_\\mathbf{i}$、$\\mathbf{X'}_\\mathbf{i}$、$\\mathbf{Y'}_\\mathbf{i}$。其中 $(\\mathbf{X}_\\mathbf{i}, \\mathbf{Y}_\\mathbf{i})$ 和 $(\\mathbf{X'}_\\mathbf{i}, \\mathbf{Y'}_\\mathbf{i})$ 分别表示第 $i$ 对杂技演员两人的坐标。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $y$ 为大写单词 MAGNIFICENT，如果输入表示的是一个壮观的安排；否则，$y$ 应为一个严格递增的整数列表。整数 $i$ 应出现在该列表中，当且仅当第 $i$ 对杂技演员的抛接路径未能与至少一条其他抛接路径相交。", "hint": "**样例解释**\n\n- 样例 1 中只有两对杂技演员，他们的抛接路径没有相交。\n- 样例 2 中，所有对的抛接路径都两两相交，安排是壮观的。\n- 样例 3 中，只有第 3 对的抛接路径与所有其他对的路径都相交。\n\n**数据范围**\n\n- $-10^9 \\leq \\mathbf{X}_\\mathbf{i} \\leq 10^9$，对所有 $i$。\n- $-10^9 \\leq \\mathbf{Y}_\\mathbf{i} \\leq 10^9$，对所有 $i$。\n- $-10^9 \\leq \\mathbf{X'}_\\mathbf{i} \\leq 10^9$，对所有 $i$。\n- $-10^9 \\leq \\mathbf{Y'}_\\mathbf{i} \\leq 10^9$，对所有 $i$。\n- 不存在三点共线的情况。（这也意味着没有两名杂技演员处于同一位置。）\n- 除至多 25 对杂技演员外，其余所有对的抛接路径都与其他 $\\mathbf{N} - 1$ 条路径相交。\n- 注意：不一定存在一种分组方式能使安排壮观。\n\n**测试点 1（5 分，公开）**\n\n- 时间限制：20 秒。\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- $2 \\leq \\mathbf{N} \\leq 100$。\n\n**测试点 2（30 分，隐藏）**\n\n- 时间限制：45 秒。\n- $1 \\leq \\mathbf{T} \\leq 13$。\n- $2 \\leq \\mathbf{N} \\leq 10^5$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13128", "type": "P", "difficulty": 6, "samples": [["5\n2 5\nN...#\n....M\n2 5\nN#...\n...#M\n5 5\nN..##\n#.###\n#...#\n##.##\n##..M\n5 5\n..N##\n#.###\n#...#\n##.##\n##..M\n3 3\n#M#\n###\n#N#", "Case #1: 4\nCase #2: 7\nCase #3: 5\nCase #4: 6\nCase #5: IMPOSSIBLE"]], "limits": {"time": [30000, 30000, 120000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "2019", "广度优先搜索 BFS", "Google Code Jam"], "title": "[GCJ 2019 Finals] Go To Considered Helpful", "background": "", "description": "Marlin is a fish who lost his son and is trying to find him. Fortunately, he ran into Cynthia, a turtle, as she swam around with her brothers, Wally and Seymour. Cynthia knows exactly where Marlin needs to go, and she can be very precise in giving directions. While Marlin is smart and can follow them perfectly, keeping track of a long list of directions can be problematic. Cynthia needs to find a way to make the list of directions short.\n\nMarlin lives in a matrix of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. Some cells of the matrix are dangerous and cannot be entered. Marlin and his son are currently in different non-dangerous cells. Marlin's son never moves to a different cell. Cynthia decided to give Marlin directions in the form of a program consisting of a list of instructions, each on a single line. Each instruction is of one of 5 types:\n\n* $\\mathbf{N}$: move one cell North (up),\n* $\\mathbf{S}$: move one cell South (down),\n* $\\mathbf{W}$: move one cell West (left),\n* $\\mathbf{E}$: move one cell East (right), and\n* $\\mathbf{G}(\\mathbf{i})$: jump to the i-th line of the instruction list (counting starting from 1).\n\nAfter executing a line with any of the first 4 instructions, Marlin jumps to the next line on the list if there is one. If there is no next line, Marlin just stands still forever.\n\nFor example, if Marlin were following the program\n\n1. $\\mathbf{N}$\n2. $\\mathbf{E}$\n3. $\\mathbf{G}(6)$\n4. $\\mathbf{S}$\n5. $\\mathbf{G}(1)$\n6. $\\mathbf{W}$\n7. $\\mathbf{G}(4)$\n\nhe would move North (line 1), then East (2), then jump to line 6 without physically moving (3), then move West (6), then jump to line 4 (7), then move South (4), then jump to line 1 (5), then move North (1), etc.\n\nIf at any point Marlin and his son are at the same cell, they will be reunited and Marlin will no longer follow any instructions. Cynthia the turtle wants to find out the smallest number of lines in a program that would get Marlin to the same cell as his son, without him ever going into a dangerous cell or moving outside of the matrix boundaries. All $\\mathbf{G}$ instructions must jump to existing lines in the program.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing $\\mathbf{R}$ and $\\mathbf{C}$, the number of rows and columns in the matrix. Then, $\\mathbf{R}$ lines follow containing a string of $\\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines $\\mathbf{A}_{ij}$ represents the cell in the $i$-th row and $j$-th column of the matrix. The character is $\\#$ if the cell is dangerous, an uppercase $\\mathbf{M}$ if the cell is the one Marlin is currently at, an uppercase $\\mathbf{N}$ if the cell is the one Marlin's son is currently at and $\\mathbf{.}$ if the cell is an unoccupied non-dangerous cell.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is $\\text{IMPOSSIBLE}$ if there is no program that would get Marlin to his son under the conditions explained above, or the smallest number of instructions in such a program.", "hint": "**Sample Explanation**\n\nBelow are some shortest programs for each of the possible sample case.\n\n- Sample Case #1:\n```\n1: W\n2: N\n3: S\n4: G(1)\n```\nor\n```\n1: W\n2: N\n3: W\n4: G(3)\n```\n\n- Sample Case #2:\n```\n1: N\n2: W\n3: W\n4: S\n5: W\n6: W\n7: N\n```\n- Sample Case #3:\n```\n1: W\n2: W\n3: N\n4: N\n5: G(2)\n```\n- Sample Case #4:\n```\n1: W\n2: W\n3: N\n4: N\n5: E\n6: G(1)\n```\n\n**Sample Explanation**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{A}_{ij}$ is either $\\#$, $\\mathbf{.}$, uppercase $\\mathbf{M}$ or uppercase $\\mathbf{N}$, for all $i$ and $j$.\n- $\\mathbf{A}_{ij} = \\mathbf{M}$ for exactly one pair of $i$ and $j$.\n- $\\mathbf{A}_{ij} = \\mathbf{N}$ for exactly one pair of $i$ and $j$.\n\n**Test set 1 (19 Pts, Visible)**\n\n- Time limit: 30 seconds.\n- $1 \\leq \\mathbf{R} \\leq 10$.\n- $1 \\leq \\mathbf{C} \\leq 10$.\n\n**Test set 2 (30 Pts, Hidden)**\n\n- Time limit: 120 seconds.\n- For at most 10 test cases:\n  - $1 \\leq \\mathbf{R} \\leq 100$.\n  - $1 \\leq \\mathbf{C} \\leq 100$.\n- For the remaining test cases:\n  - $1 \\leq \\mathbf{R} \\leq 50$.\n  - $1 \\leq \\mathbf{C} \\leq 50$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2019 Finals] Go To Considered Helpful", "background": "", "description": "Marlin is a fish who lost his son and is trying to find him. Fortunately, he ran into Cynthia, a turtle, as she swam around with her brothers, Wally and Seymour. Cynthia knows exactly where Marlin needs to go, and she can be very precise in giving directions. While Marlin is smart and can follow them perfectly, keeping track of a long list of directions can be problematic. Cynthia needs to find a way to make the list of directions short.\n\nMarlin lives in a matrix of $\\mathbf{R}$ rows and $\\mathbf{C}$ columns. Some cells of the matrix are dangerous and cannot be entered. Marlin and his son are currently in different non-dangerous cells. Marlin's son never moves to a different cell. Cynthia decided to give Marlin directions in the form of a program consisting of a list of instructions, each on a single line. Each instruction is of one of 5 types:\n\n* $\\mathbf{N}$: move one cell North (up),\n* $\\mathbf{S}$: move one cell South (down),\n* $\\mathbf{W}$: move one cell West (left),\n* $\\mathbf{E}$: move one cell East (right), and\n* $\\mathbf{G}(\\mathbf{i})$: jump to the i-th line of the instruction list (counting starting from 1).\n\nAfter executing a line with any of the first 4 instructions, Marlin jumps to the next line on the list if there is one. If there is no next line, Marlin just stands still forever.\n\nFor example, if Marlin were following the program\n\n1. $\\mathbf{N}$\n2. $\\mathbf{E}$\n3. $\\mathbf{G}(6)$\n4. $\\mathbf{S}$\n5. $\\mathbf{G}(1)$\n6. $\\mathbf{W}$\n7. $\\mathbf{G}(4)$\n\nhe would move North (line 1), then East (2), then jump to line 6 without physically moving (3), then move West (6), then jump to line 4 (7), then move South (4), then jump to line 1 (5), then move North (1), etc.\n\nIf at any point Marlin and his son are at the same cell, they will be reunited and Marlin will no longer follow any instructions. Cynthia the turtle wants to find out the smallest number of lines in a program that would get Marlin to the same cell as his son, without him ever going into a dangerous cell or moving outside of the matrix boundaries. All $\\mathbf{G}$ instructions must jump to existing lines in the program.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case starts with a line containing $\\mathbf{R}$ and $\\mathbf{C}$, the number of rows and columns in the matrix. Then, $\\mathbf{R}$ lines follow containing a string of $\\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines $\\mathbf{A}_{ij}$ represents the cell in the $i$-th row and $j$-th column of the matrix. The character is $\\#$ if the cell is dangerous, an uppercase $\\mathbf{M}$ if the cell is the one Marlin is currently at, an uppercase $\\mathbf{N}$ if the cell is the one Marlin's son is currently at and $\\mathbf{.}$ if the cell is an unoccupied non-dangerous cell.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is $\\text{IMPOSSIBLE}$ if there is no program that would get Marlin to his son under the conditions explained above, or the smallest number of instructions in such a program.", "hint": "**Sample Explanation**\n\nBelow are some shortest programs for each of the possible sample case.\n\n- Sample Case #1:\n```\n1: W\n2: N\n3: S\n4: G(1)\n```\nor\n```\n1: W\n2: N\n3: W\n4: G(3)\n```\n\n- Sample Case #2:\n```\n1: N\n2: W\n3: W\n4: S\n5: W\n6: W\n7: N\n```\n- Sample Case #3:\n```\n1: W\n2: W\n3: N\n4: N\n5: G(2)\n```\n- Sample Case #4:\n```\n1: W\n2: W\n3: N\n4: N\n5: E\n6: G(1)\n```\n\n**Sample Explanation**\n\n- $1 \\leq \\mathbf{T} \\leq 100$.\n- $\\mathbf{A}_{ij}$ is either $\\#$, $\\mathbf{.}$, uppercase $\\mathbf{M}$ or uppercase $\\mathbf{N}$, for all $i$ and $j$.\n- $\\mathbf{A}_{ij} = \\mathbf{M}$ for exactly one pair of $i$ and $j$.\n- $\\mathbf{A}_{ij} = \\mathbf{N}$ for exactly one pair of $i$ and $j$.\n\n**Test set 1 (19 Pts, Visible)**\n\n- Time limit: 30 seconds.\n- $1 \\leq \\mathbf{R} \\leq 10$.\n- $1 \\leq \\mathbf{C} \\leq 10$.\n\n**Test set 2 (30 Pts, Hidden)**\n\n- Time limit: 120 seconds.\n- For at most 10 test cases:\n  - $1 \\leq \\mathbf{R} \\leq 100$.\n  - $1 \\leq \\mathbf{C} \\leq 100$.\n- For the remaining test cases:\n  - $1 \\leq \\mathbf{R} \\leq 50$.\n  - $1 \\leq \\mathbf{C} \\leq 50$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2019 Finals] Go To Considered Helpful", "background": null, "description": "Marlin 是一条丢失了儿子的鱼，正在努力寻找他的儿子。幸运的是，他遇到了正在和兄弟 Wally 与 Seymour 一起游泳的海龟 Cynthia。Cynthia 知道 Marlin 需要去哪里，并且她可以非常精确地给出指引。虽然 Marlin 很聪明，能够完美地按照指令行动，但要记住一长串指令还是很困难的。Cynthia 需要想办法让指令列表尽可能简短。\n\nMarlin 生活在一个有 $\\mathbf{R}$ 行 $\\mathbf{C}$ 列的矩阵中。矩阵中的某些格子是危险的，不能进入。Marlin 和他的儿子目前分别位于两个不同的非危险格子中。Marlin 的儿子不会移动。Cynthia 决定以程序的形式给 Marlin 指路，这个程序由若干条指令组成，每条指令占一行。每条指令有以下 5 种类型之一：\n\n- $\\mathbf{N}$：向北（上）移动一格，\n- $\\mathbf{S}$：向南（下）移动一格，\n- $\\mathbf{W}$：向西（左）移动一格，\n- $\\mathbf{E}$：向东（右）移动一格，\n- $\\mathbf{G}(\\mathbf{i})$：跳转到指令列表的第 $i$ 行（从 1 开始计数）。\n\n每当执行前 4 种指令中的任意一种后，如果还有下一行指令，Marlin 会跳到下一行继续执行。如果没有下一行指令，Marlin 就会原地停留，永远不再移动。\n\n例如，假如 Marlin 执行如下程序：\n\n1. $\\mathbf{N}$\n2. $\\mathbf{E}$\n3. $\\mathbf{G}(6)$\n4. $\\mathbf{S}$\n5. $\\mathbf{G}(1)$\n6. $\\mathbf{W}$\n7. $\\mathbf{G}(4)$\n\n他会先向北移动（第 1 行），然后向东移动（第 2 行），接着跳转到第 6 行（第 3 行），然后向西移动（第 6 行），再跳转到第 4 行（第 7 行），然后向南移动（第 4 行），再跳转到第 1 行（第 5 行），然后向北移动（第 1 行），如此循环往复。\n\n如果某一时刻 Marlin 和他的儿子处于同一个格子，他们就会团聚，Marlin 也会停止执行任何指令。海龟 Cynthia 想知道，能够让 Marlin 安全到达他儿子所在格子的最短程序需要多少行指令，且在此过程中 Marlin 不能进入危险格子，也不能走出矩阵边界。所有 $\\mathbf{G}$ 指令必须跳转到程序中已存在的行。", "inputFormat": "输入的第一行为测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组测试数据的第一行为两个整数 $\\mathbf{R}$ 和 $\\mathbf{C}$，表示矩阵的行数和列数。接下来有 $\\mathbf{R}$ 行，每行包含一个长度为 $\\mathbf{C}$ 的字符串。第 $i$ 行第 $j$ 列的字符 $\\mathbf{A}_{ij}$ 表示矩阵中第 $i$ 行第 $j$ 列的格子。若该格子为危险格子，则为字符 $\\#$；若为 Marlin 当前所在格子，则为大写字母 $\\mathbf{M}$；若为 Marlin 儿子当前所在格子，则为大写字母 $\\mathbf{N}$；若为未被占用的非危险格子，则为 $\\mathbf{.}$。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为在上述条件下能让 Marlin 到达他儿子所在格子的最短程序所需的指令行数。如果不存在这样的程序，则输出 $\\text{IMPOSSIBLE}$。", "hint": "**样例说明**\n\n下面是每个样例的最短程序示例。\n\n- 样例 1：\n```\n1: W\n2: N\n3: S\n4: G(1)\n```\n或\n```\n1: W\n2: N\n3: W\n4: G(3)\n```\n\n- 样例 2：\n```\n1: N\n2: W\n3: W\n4: S\n5: W\n6: W\n7: N\n```\n- 样例 3：\n```\n1: W\n2: W\n3: N\n4: N\n5: G(2)\n```\n- 样例 4：\n```\n1: W\n2: W\n3: N\n4: N\n5: E\n6: G(1)\n```\n\n**样例解释**\n\n- $1 \\leq \\mathbf{T} \\leq 100$。\n- 对所有 $i$ 和 $j$，$\\mathbf{A}_{ij}$ 只可能为 $\\#$、$\\mathbf{.}$、大写字母 $\\mathbf{M}$ 或大写字母 $\\mathbf{N}$。\n- 恰好有一对 $i$ 和 $j$ 使得 $\\mathbf{A}_{ij} = \\mathbf{M}$。\n- 恰好有一对 $i$ 和 $j$ 使得 $\\mathbf{A}_{ij} = \\mathbf{N}$。\n\n**测试点 1（19 分，公开）**\n\n- 时间限制：30 秒。\n- $1 \\leq \\mathbf{R} \\leq 10$。\n- $1 \\leq \\mathbf{C} \\leq 10$。\n\n**测试点 2（30 分，隐藏）**\n\n- 时间限制：120 秒。\n- 最多 10 个测试用例满足：\n  - $1 \\leq \\mathbf{R} \\leq 100$。\n  - $1 \\leq \\mathbf{C} \\leq 100$。\n- 其余测试用例满足：\n  - $1 \\leq \\mathbf{R} \\leq 50$。\n  - $1 \\leq \\mathbf{C} \\leq 50$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13129", "type": "P", "difficulty": 6, "samples": [["5 5\n1 2 2 3\n2 3\n1 4 3\n2 3\n2 4\n2 1", "0 0\n0 0\n3 2\n3 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2019] 有马加奈", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/0xyttjqf.png)", "description": "对于一个节点 $i$ 存在二元组信息 $(a_i,b_i)$。\n\n给定大小为 $n$ 的树。初始化所有节点全为 $(0,0)$。根为 $1$。\n\n给定 $m$ 个操作。\n\n- $1 \\ x \\ c$ 设当前操作编号为 $z$，对于 $x$ 到根路径，路径上的所有节点 $i$ 的二元组信息，若 $a_i = c$ 那么令 $(a_i,b_i) \\leftarrow (c,b_i)$ 否则令 $(a_i,b_i) \\leftarrow (c,z)$。\n\n- $2 \\ x$ 查询 $(a_x,b_x)$。", "inputFormat": "第一行两个整数 $n,m$ 代表树的大小和操作个数。\n\n接下来一行 $n - 1$ 个数，第 $i$ 个数 $p_i$ 表示点 $i + 1$ 的父亲 $p_i$。\n\n接下来 $m$ 行，每行三个数或两个数代表操作。", "outputFormat": "对于每个询问，输出一行两个数表示答案。", "hint": "Idea：\nFutaRimeWoawaSete，Solution：\nFutaRimeWoawaSete，Code：\nFutaRimeWoawaSete，Data：\nFutaRimeWoawaSete\n\n#### 【数据范围】\n\n|    测试点    |         $n$          |         $m$         | 特殊性质 |\n| :----------: | :------------------: | :-----------------: | :------: |\n|  $1 \\sim 5$  | $\\leq \\times 10 ^ 5$ |    $\\leq 10 ^ 5$    |   $A$    |\n| $6 \\sim 10$  |    $\\leq 10 ^ 5$     |    $\\leq 10 ^ 5$    |   $B$    |\n| $11 \\sim 15$ |     $\\le 10 ^ 5$     | $\\le \\times 10 ^ 5$ |   $C$    |\n| $16 \\sim 20$ |      $\\le 10^6$      |    $\\leq 10 ^ 6$    |   $/$    |\n\n特殊性质 $A$：满足 $p_i$ 从 $[1,i - 1]$ 里随机选择。\n\n特殊性质 $B$：保证所有 $1$ 操作中 $c = 1$。\n\n特殊性质 $C$：保证 $p_i = i - 1$。\n\n所有数据保证 $n,q \\leq 10 ^ 6,x,c \\in [1,n]$。\n\n保证样例 $2,3,4,5$ 相应性质对应测试点 $1 \\sim 5,6 \\sim 10,11 \\sim 15,16 \\sim 20$ 且使用同一构造方式生成。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2019] 有马加奈", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/0xyttjqf.png)", "description": "对于一个节点 $i$ 存在二元组信息 $(a_i,b_i)$。\n\n给定大小为 $n$ 的树。初始化所有节点全为 $(0,0)$。根为 $1$。\n\n给定 $m$ 个操作。\n\n- $1 \\ x \\ c$ 设当前操作编号为 $z$，对于 $x$ 到根路径，路径上的所有节点 $i$ 的二元组信息，若 $a_i = c$ 那么令 $(a_i,b_i) \\leftarrow (c,b_i)$ 否则令 $(a_i,b_i) \\leftarrow (c,z)$。\n\n- $2 \\ x$ 查询 $(a_x,b_x)$。", "inputFormat": "第一行两个整数 $n,m$ 代表树的大小和操作个数。\n\n接下来一行 $n - 1$ 个数，第 $i$ 个数 $p_i$ 表示点 $i + 1$ 的父亲 $p_i$。\n\n接下来 $m$ 行，每行三个数或两个数代表操作。", "outputFormat": "对于每个询问，输出一行两个数表示答案。", "hint": "Idea：\nFutaRimeWoawaSete，Solution：\nFutaRimeWoawaSete，Code：\nFutaRimeWoawaSete，Data：\nFutaRimeWoawaSete\n\n#### 【数据范围】\n\n|    测试点    |         $n$          |         $m$         | 特殊性质 |\n| :----------: | :------------------: | :-----------------: | :------: |\n|  $1 \\sim 5$  | $\\leq \\times 10 ^ 5$ |    $\\leq 10 ^ 5$    |   $A$    |\n| $6 \\sim 10$  |    $\\leq 10 ^ 5$     |    $\\leq 10 ^ 5$    |   $B$    |\n| $11 \\sim 15$ |     $\\le 10 ^ 5$     | $\\le \\times 10 ^ 5$ |   $C$    |\n| $16 \\sim 20$ |      $\\le 10^6$      |    $\\leq 10 ^ 6$    |   $/$    |\n\n特殊性质 $A$：满足 $p_i$ 从 $[1,i - 1]$ 里随机选择。\n\n特殊性质 $B$：保证所有 $1$ 操作中 $c = 1$。\n\n特殊性质 $C$：保证 $p_i = i - 1$。\n\n所有数据保证 $n,q \\leq 10 ^ 6,x,c \\in [1,n]$。\n\n保证样例 $2,3,4,5$ 相应性质对应测试点 $1 \\sim 5,6 \\sim 10,11 \\sim 15,16 \\sim 20$ 且使用同一构造方式生成。", "locale": "zh-CN"}}}
{"pid": "P13130", "type": "P", "difficulty": 7, "samples": [["10 30\n5 4 1 2 3 2 1 4 2 2\n2 1 1 5 3\n2 3 1 7 1\n2 9 1 7 1\n2 1 1 1 2\n2 1 1 10 1\n2 9 9 9 3\n1 3 10\n2 3 1 1 2\n1 1 8\n2 5 5 5 2\n2 1 1 1 2\n1 9 1\n2 6 5 5 2\n2 2 4 6 3\n2 7 1 5 1\n2 2 6 8 3\n2 2 1 9 3\n2 9 9 9 1\n1 2 4\n2 2 3 7 2\n1 6 3\n2 7 3 5 1\n1 2 5\n2 9 1 9 2\n2 2 3 7 2\n1 6 7\n1 2 6\n1 2 9\n2 2 1 7 1\n2 2 1 3 1", "1\n0\n0\n1\n0\n1\n0\n1\n1\n0\n0\n0\n0\n1\n0\n1\n0\n9\n4\n0\n0"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2019", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2019] 黑川赤音", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/9fvafeiq.png)", "description": "给定一个数组 $a$ 和 $n$ 个集合，初始第 $i$ 个集合里面只有一个元素 $i$，集合里面的每个元素对应了数组的一个下标。\n\n定义一个元素 $i$ 在集合 $S$ 中的相同数个数 $F(S,i)$ 为集合 $S$ 中元素 $j$ 的个数，满足 $a[i] = a[j]$。\n\n定义一个集合 $S$ 的 $k$-权值为：$\\forall i \\in S,\\forall j \\in S$，有多少方案 $(i,j)$ 满足 $F(S,i)+F(S,j) \\le k$，这里可以 $i=j$，并且 $(i,j)$ 与 $(j,i)$ 视为不同的方案。\n\n要进行 $m$ 次操作，操作有两种：\n\n``1 x y`` : 将 $y$ 集合里面所有元素都放入 $x$ 集合，之后将 $y$ 集合清空，操作保证 $x$ 集合和 $y$ 集合操作前非空。\n\n``2 x l r k`` : 查询 $x$ 集合保留在 $[l,r]$ 内的所有元素时的 $k$-权值，查询是独立的，不对集合进行改变。", "inputFormat": "第一行用空格隔开的两个数，表示 $n,m$。\n\n第二行包含 $n$ 个数，表示这个数组。\n\n之后 $m$ 行，每行格式如题目描述，表示一次操作。", "outputFormat": "对于每个 $2$ 操作，输出一行一个数，表示查询的答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477\n\n对于 $10\\%$ 的数据，满足 $n,m \\le 100$\n\n对于另外 $20\\%$ 的数据，满足 $n,m \\le 10000$\n\n对于另外 $20\\%$ 的数据，查询的 $k$ 不变。\n\n对于 $100\\%$ 的数据，满足 $n \\le 10^5， m \\le 2 \\times 10^5$， $0 \\le a_i,k \\le m$，$1 \\le l \\le r \\le n$，$1 \\le x,y \\le n$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2019] 黑川赤音", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/9fvafeiq.png)", "description": "给定一个数组 $a$ 和 $n$ 个集合，初始第 $i$ 个集合里面只有一个元素 $i$，集合里面的每个元素对应了数组的一个下标。\n\n定义一个元素 $i$ 在集合 $S$ 中的相同数个数 $F(S,i)$ 为集合 $S$ 中元素 $j$ 的个数，满足 $a[i] = a[j]$。\n\n定义一个集合 $S$ 的 $k$-权值为：$\\forall i \\in S,\\forall j \\in S$，有多少方案 $(i,j)$ 满足 $F(S,i)+F(S,j) \\le k$，这里可以 $i=j$，并且 $(i,j)$ 与 $(j,i)$ 视为不同的方案。\n\n要进行 $m$ 次操作，操作有两种：\n\n``1 x y`` : 将 $y$ 集合里面所有元素都放入 $x$ 集合，之后将 $y$ 集合清空，操作保证 $x$ 集合和 $y$ 集合操作前非空。\n\n``2 x l r k`` : 查询 $x$ 集合保留在 $[l,r]$ 内的所有元素时的 $k$-权值，查询是独立的，不对集合进行改变。", "inputFormat": "第一行用空格隔开的两个数，表示 $n,m$。\n\n第二行包含 $n$ 个数，表示这个数组。\n\n之后 $m$ 行，每行格式如题目描述，表示一次操作。", "outputFormat": "对于每个 $2$ 操作，输出一行一个数，表示查询的答案。", "hint": "Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477\n\n对于 $10\\%$ 的数据，满足 $n,m \\le 100$\n\n对于另外 $20\\%$ 的数据，满足 $n,m \\le 10000$\n\n对于另外 $20\\%$ 的数据，查询的 $k$ 不变。\n\n对于 $100\\%$ 的数据，满足 $n \\le 10^5， m \\le 2 \\times 10^5$， $0 \\le a_i,k \\le m$，$1 \\le l \\le r \\le n$，$1 \\le x,y \\le n$。", "locale": "zh-CN"}}}
{"pid": "P13131", "type": "P", "difficulty": 7, "samples": [["5 4 3\n1 1 3 3\n5 2 2 3\n3 4 5\n2 0 7\n3 0 3", "3\n2\n1"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "O2优化", "Ynoi"], "title": "[Ynoi Easy Round 2019] 神木辉", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/9w5w003j.png)", "description": "给定 $n$ 个顶点的树，顶点编号为 $1,\\dots,n$，给定长度 $n_0$ 的序列 $a_1,\\dots,a_{n_0}$，共 $m$ 次查询，每次查询给定 $l,r,x$，问树的顶点 $x$，依次向 $a_l,\\dots,a_r$ 移动一步，到达的顶点。\n\n若 $x=y$，则从顶点 $x$ 向 $y$ 移动一步到达 $x$，否则到达与 $x$ 在树上相邻且距离 $y$ 最近的位置。", "inputFormat": "第一行三个整数 $n,n_0,m$；\n\n接下来一行 $n-1$ 个整数依次表示 $f_2,\\dots,f_n$，其中 $f_i$ 是顶点 $i$ 的父亲，$1$ 为根；\n\n接下来一行 $n_0$ 个整数，依次表示 $a_1,\\dots,a_{n_0}$；\n\n接下来 $m$ 行，每行三个整数 $l\\oplus v,r\\oplus v,x\\oplus v$ 表示一次查询，其中 $v$ 是上次查询的答案（特别地，第一次查询时 $v=0$），$\\oplus$ 是按位异或。", "outputFormat": "共 $m$ 行，依次为每次查询的答案。", "hint": "Idea：Ynoi，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n对 $100\\%$ 的数据，满足 $1\\le n,n_0,m\\le 10^5$；\n\n对于 $25%$ 的数据，满足 $n,n_0,m\\le 10^3$。\n\n对于 $25%$ 的数据，满足 $f_i=i-1$\n\n对于 $25%$ 的数据，满足 $f_i$ 在 $1,2,\\dots,i-1$ 中均匀随机选取。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[Ynoi Easy Round 2019] 神木辉", "background": "![](https://cdn.luogu.com.cn/upload/image_hosting/9w5w003j.png)", "description": "给定 $n$ 个顶点的树，顶点编号为 $1,\\dots,n$，给定长度 $n_0$ 的序列 $a_1,\\dots,a_{n_0}$，共 $m$ 次查询，每次查询给定 $l,r,x$，问树的顶点 $x$，依次向 $a_l,\\dots,a_r$ 移动一步，到达的顶点。\n\n若 $x=y$，则从顶点 $x$ 向 $y$ 移动一步到达 $x$，否则到达与 $x$ 在树上相邻且距离 $y$ 最近的位置。", "inputFormat": "第一行三个整数 $n,n_0,m$；\n\n接下来一行 $n-1$ 个整数依次表示 $f_2,\\dots,f_n$，其中 $f_i$ 是顶点 $i$ 的父亲，$1$ 为根；\n\n接下来一行 $n_0$ 个整数，依次表示 $a_1,\\dots,a_{n_0}$；\n\n接下来 $m$ 行，每行三个整数 $l\\oplus v,r\\oplus v,x\\oplus v$ 表示一次查询，其中 $v$ 是上次查询的答案（特别地，第一次查询时 $v=0$），$\\oplus$ 是按位异或。", "outputFormat": "共 $m$ 行，依次为每次查询的答案。", "hint": "Idea：Ynoi，Solution：ccz181078，Code：ccz181078，Data：ccz181078\n\n对 $100\\%$ 的数据，满足 $1\\le n,n_0,m\\le 10^5$；\n\n对于 $25%$ 的数据，满足 $n,n_0,m\\le 10^3$。\n\n对于 $25%$ 的数据，满足 $f_i=i-1$\n\n对于 $25%$ 的数据，满足 $f_i$ 在 $1,2,\\dots,i-1$ 中均匀随机选取。", "locale": "zh-CN"}}}
{"pid": "P13132", "type": "P", "difficulty": 2, "samples": [["6\n1 CS\n2 CS\n1 SS\n6 SCCSSC\n2 CC\n3 CSCSS", "Case #1: 1\nCase #2: 0\nCase #3: IMPOSSIBLE\nCase #4: 2\nCase #5: 0\nCase #6: 5"]], "limits": {"time": [20000, 20000], "memory": [1048576, 1048576]}, "tags": ["字符串", "贪心", "2018", "Google Code Jam"], "title": "[GCJ 2018 Qualification] Saving The Universe Again", "background": "", "description": "An alien robot is threatening the universe, using a beam that will destroy all algorithms knowledge. We have to stop it!\n\nFortunately, we understand how the robot works. It starts off with a beam with a strength of 1, and it will run a program that is a series of instructions, which will be executed one at a time, in left to right order. Each instruction is of one of the following two types:\n\n- c (for \"charge\"): Double the beam's strength.\n- s (for \"shoot\"): Shoot the beam, doing damage equal to the beam's current strength.\n\nFor example, if the robot's program is sccssc, the robot will do the following when the program runs:\n\n- Shoot the beam, doing 1 damage.\n- Charge the beam, doubling the beam's strength to 2.\n- Charge the beam, doubling the beam's strength to 4.\n- Shoot the beam, doing 4 damage.\n- Shoot the beam, doing 4 damage.\n- Charge the beam, increasing the beam's strength to 8.\n\nIn that case, the program would do a total of $9$ damage.\n\nThe universe's top algorithmists have developed a shield that can withstand a maximum total of $\\mathbf D$ damage. But the robot's current program might do more damage than that when it runs.\n\nThe President of the Universe has volunteered to fly into space to hack the robot's program before the robot runs it. The only way the President can hack (without the robot noticing) is by swapping two adjacent instructions. For example, the President could hack the above program once by swapping the third and fourth instructions to make it scscsc. This would reduce the total damage to 7. Then, for example, the president could hack the program again to make it scsscc, reducing the damage to 5, and so on.\n\nTo prevent the robot from getting too suspicious, the President does not want to hack too many times. What is this smallest possible number of hacks which will ensure that the program does no more than $\\mathbf D$ total damage, if it is possible to do so?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line containing an integer $\\mathbf{D}$ and a string $\\mathbf{P}$: the maximum total damage our shield can withstand, and the robot's program.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either the minimum number of hacks needed to accomplish the goal, or IMPOSSIBLE if it is not possible.", "hint": "**Sample Explanation**\n\nNote that the last three sample cases would not appear in test set 1.\n\nIn Sample Case #1, the President can swap the two instructions to reduce the total damage to 1, which the shield can withstand.\n\nIn Sample Case #2, the President does not need to hack the program at all, since the shield can already withstand the 2 total damage it will cause.\n\nIn Sample Case #3, the program will do more damage than the shield can withstand, and hacking will do nothing to change this. The universe is doomed.\n\nSample Case #4 uses the program described in the problem statement. The statement demonstrates one way to reduce the total damage to 5 using two hacks. It is not possible to reduce the damage to 6 or less by using only one hack; remember that the President can only swap adjacent instructions.\n\nIn Sample Case #5, the robot will never shoot, and so it will never do any damage. No hacking is required.\n\nIn Sample Case #6, five hacks are required. Notice that even if two hacks swap the instructions at the same two positions, they still count as separate hacks.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $1 \\leq D \\leq 10^9.$\n- $2 \\leq \\text{length of } P \\leq 30.$\n- Every character in $P$ is either $c$ or $s$.\n\n**Test set 1 (5 Pts,Visible)**\n\nThe robot's program contains either zero or one $c$ characters.\n\n**Test set 2 (10 Pts, Hidden)**\n\nNo additional restrictions to the Limits section.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 Qualification] Saving The Universe Again", "background": "", "description": "An alien robot is threatening the universe, using a beam that will destroy all algorithms knowledge. We have to stop it!\n\nFortunately, we understand how the robot works. It starts off with a beam with a strength of 1, and it will run a program that is a series of instructions, which will be executed one at a time, in left to right order. Each instruction is of one of the following two types:\n\n- c (for \"charge\"): Double the beam's strength.\n- s (for \"shoot\"): Shoot the beam, doing damage equal to the beam's current strength.\n\nFor example, if the robot's program is sccssc, the robot will do the following when the program runs:\n\n- Shoot the beam, doing 1 damage.\n- Charge the beam, doubling the beam's strength to 2.\n- Charge the beam, doubling the beam's strength to 4.\n- Shoot the beam, doing 4 damage.\n- Shoot the beam, doing 4 damage.\n- Charge the beam, increasing the beam's strength to 8.\n\nIn that case, the program would do a total of $9$ damage.\n\nThe universe's top algorithmists have developed a shield that can withstand a maximum total of $\\mathbf D$ damage. But the robot's current program might do more damage than that when it runs.\n\nThe President of the Universe has volunteered to fly into space to hack the robot's program before the robot runs it. The only way the President can hack (without the robot noticing) is by swapping two adjacent instructions. For example, the President could hack the above program once by swapping the third and fourth instructions to make it scscsc. This would reduce the total damage to 7. Then, for example, the president could hack the program again to make it scsscc, reducing the damage to 5, and so on.\n\nTo prevent the robot from getting too suspicious, the President does not want to hack too many times. What is this smallest possible number of hacks which will ensure that the program does no more than $\\mathbf D$ total damage, if it is possible to do so?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each consists of one line containing an integer $\\mathbf{D}$ and a string $\\mathbf{P}$: the maximum total damage our shield can withstand, and the robot's program.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either the minimum number of hacks needed to accomplish the goal, or IMPOSSIBLE if it is not possible.", "hint": "**Sample Explanation**\n\nNote that the last three sample cases would not appear in test set 1.\n\nIn Sample Case #1, the President can swap the two instructions to reduce the total damage to 1, which the shield can withstand.\n\nIn Sample Case #2, the President does not need to hack the program at all, since the shield can already withstand the 2 total damage it will cause.\n\nIn Sample Case #3, the program will do more damage than the shield can withstand, and hacking will do nothing to change this. The universe is doomed.\n\nSample Case #4 uses the program described in the problem statement. The statement demonstrates one way to reduce the total damage to 5 using two hacks. It is not possible to reduce the damage to 6 or less by using only one hack; remember that the President can only swap adjacent instructions.\n\nIn Sample Case #5, the robot will never shoot, and so it will never do any damage. No hacking is required.\n\nIn Sample Case #6, five hacks are required. Notice that even if two hacks swap the instructions at the same two positions, they still count as separate hacks.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $1 \\leq D \\leq 10^9.$\n- $2 \\leq \\text{length of } P \\leq 30.$\n- Every character in $P$ is either $c$ or $s$.\n\n**Test set 1 (5 Pts,Visible)**\n\nThe robot's program contains either zero or one $c$ characters.\n\n**Test set 2 (10 Pts, Hidden)**\n\nNo additional restrictions to the Limits section.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 Qualification] Saving The Universe Again", "background": null, "description": "一个外星机器人正在威胁宇宙，它使用一束光束，能够摧毁所有的算法知识。我们必须阻止它！\n\n幸运的是，我们已经了解了机器人的工作方式。它一开始拥有强度为 $1$ 的光束，并将运行一个由一系列指令组成的程序，这些指令会按从左到右的顺序依次执行。每条指令有以下两种类型之一：\n\n- c（代表“充能”）：将光束的强度加倍。\n- s（代表“发射”）：发射光束，造成等于当前光束强度的伤害。\n\n例如，如果机器人的程序是 sccssc，当程序运行时，机器人会按如下方式执行：\n\n- 发射光束，造成 $1$ 点伤害。\n- 充能，将光束强度加倍至 $2$。\n- 充能，将光束强度加倍至 $4$。\n- 发射光束，造成 $4$ 点伤害。\n- 发射光束，造成 $4$ 点伤害。\n- 充能，将光束强度加倍至 $8$。\n\n在这种情况下，程序总共会造成 $9$ 点伤害。\n\n宇宙顶尖的算法专家们开发了一种护盾，最多可以承受 $\\mathbf D$ 点总伤害。但机器人的当前程序在运行时可能会造成超过这个数值的伤害。\n\n宇宙总统自愿飞入太空，在机器人运行程序之前对其进行黑客攻击。总统唯一能在不被机器人察觉的情况下进行的黑客手段，是交换两条相邻的指令。例如，总统可以通过交换上述程序的第三和第四条指令，将其变为 scscsc，这样总伤害就会降为 $7$。然后，总统还可以再次进行黑客操作，将程序变为 scsscc，总伤害降为 $5$，以此类推。\n\n为了避免引起机器人的怀疑，总统不希望进行太多次黑客操作。请问，最少需要多少次黑客操作，才能确保程序造成的总伤害不超过 $\\mathbf D$，如果无法做到，则输出 IMPOSSIBLE。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例包含一行，包括一个整数 $\\mathbf{D}$ 和一个字符串 $\\mathbf{P}$，分别表示护盾能承受的最大总伤害，以及机器人的程序。", "outputFormat": "对于每组测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 $1$ 开始），$y$ 是完成目标所需的最小黑客次数，或者如果无法实现则输出 IMPOSSIBLE。", "hint": "**样例解释**\n\n注意，最后三个样例不会出现在测试集 1 中。\n\n在样例 1 中，总统可以交换两条指令，将总伤害降为 $1$，护盾可以承受。\n\n在样例 2 中，总统无需进行任何黑客操作，因为程序造成的总伤害为 $2$，护盾可以承受。\n\n在样例 3 中，程序造成的伤害超过了护盾的承受能力，并且无论如何黑客都无法改变这一点。宇宙注定要毁灭。\n\n样例 4 使用了题目描述中的程序。题目中演示了一种通过两次黑客操作将总伤害降为 $5$ 的方法。仅用一次黑客操作无法将伤害降至 $6$ 或以下；请记住，总统只能交换相邻的指令。\n\n在样例 5 中，机器人永远不会发射，因此不会造成任何伤害，无需黑客操作。\n\n在样例 6 中，需要进行五次黑客操作。注意，即使两次黑客操作交换的是同一对位置的指令，也算作两次操作。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq D \\leq 10^9$。\n- $2 \\leq P$ 的长度 $\\leq 30$。\n- $P$ 中的每个字符都是 $c$ 或 $s$。\n\n**测试集 1（5 分，可见）**\n\n机器人的程序中最多只包含 $0$ 个或 $1$ 个 $c$ 字符。\n\n**测试集 2（10 分，隐藏）**\n\n无额外限制。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13133", "type": "P", "difficulty": 3, "samples": [["2\n5\n5 6 8 4 3\n3\n8 9 7", "Case #1: OK\nCase #2: 1"]], "limits": {"time": [10000, 20000], "memory": [1048576, 1048576]}, "tags": ["2018", "排序", "Google Code Jam"], "title": "[GCJ 2018 Qualification] Trouble Sort", "background": "", "description": "Deep in Code Jam's secret algorithm labs, we devote countless hours to wrestling with one of the most complex problems of our time: efficiently sorting a list of integers into non-decreasing order. We have taken a careful look at the classic bubble sort algorithm, and we are pleased to announce a new variant.\n\nThe basic operation of the standard bubble sort algorithm is to examine a pair of adjacent numbers, and reverse that pair if the left number is larger than the right number. But our algorithm examines a group of three adjacent numbers, and if the leftmost number is larger than the rightmost number, it reverses that entire group. Because our algorithm is a \"triplet bubble sort\", we have named it Trouble Sort for short.\n\n```\n  TroubleSort(L): // L is a 0-indexed list of integers\n    let done := false\n    while not done:\n      done = true\n      for i := 0; i < len(L)-2; i++:\n        if L[i] > L[i+2]:\n          done = false\n          reverse the sublist from L[i] to L[i+2], inclusive\n```\n\nFor example, for $L = 5 \\ 6 \\ 6 \\ 4 \\ 3$, Trouble Sort would proceed as follows:\n\n- First pass:\n    - inspect $5 \\ 6 \\ 6$, do nothing: $5 \\ 6 \\ 6 \\ 4 \\ 3$\n    - inspect $6 \\ 6 \\ 4$, see that $6 > 4$, reverse the triplet: $5 \\ 4 \\ 6 \\ 6 \\ 3$\n    - inspect $6 \\ 6 \\ 3$, see that $6 > 3$, reverse the triplet: $5 \\ 4 \\ 3 \\ 6 \\ 6$\n- Second pass:\n    - inspect $5 \\ 4 \\ 3$, see that $5 > 3$, reverse the triplet: $3 \\ 4 \\ 5 \\ 6 \\ 6$\n    - inspect $4 \\ 5 \\ 6$, do nothing: $3 \\ 4 \\ 5 \\ 6 \\ 6$\n    - inspect $5 \\ 6 \\ 6$, do nothing: $3 \\ 4 \\ 5 \\ 6 \\ 6$\n- Then the third pass inspects the three triplets and does nothing, so the algorithm terminates.\n\nWe were looking forward to presenting Trouble Sort at the Special Interest Group in Sorting conference in Hawaii, but one of our interns has just pointed out a problem: it is possible that Trouble Sort does not correctly sort the list! Consider the list $8 \\ 9 \\ 7$, for example.\n\nWe need your help with some further research. Given a list of $\\mathbf N$ integers, determine whether Trouble Sort will successfully sort the list into non-decreasing order. If it will not, find the index (counting starting from 0) of the first sorting error after the algorithm has finished: that is, the first value that is larger than the value that comes directly after it when the algorithm is done.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines: one line with an integer $\\mathbf{N}$, the number of values in the list, and then another line with $\\mathbf{N}$ integers $\\mathbf{V}_\\mathbf{i}$, the list of values.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is ok if Trouble Sort correctly sorts the list, or the index (counting starting from 0) of the first sorting error, as described above.", "hint": "**Sample Explanation**\n\nSample Case #1 is similar to the first one described in the problem statement. Trouble Sort correctly sorts this list, so the answer is OK.\n\nSample Case #2 is the second one described in the problem statement. Trouble Sort does not correctly sort this list, since it terminates with the list $7\\ 9\\ 8$. The $9$ is the first value in the list that is larger than the next value, so the index of the first sorting error is $1$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $0 \\leq V_i \\leq 10^9,$ for all $i$.\n\n**Test set 1 (8 Pts, Visible)**\n\n- $3 \\leq N \\leq 100.$\n- Time limit (for the entire test set): 10 seconds.\n\n**Test set 2 (15 Pts, Hidden)**\n\n- $3 \\leq N \\leq 10^5.$\n- Time limit (for the entire test set): 20 seconds.\n\n**Special Note**\n\nNotice that test set 2 for this problem has a large amount of input, so using a non-buffered reader might lead to slower input reading. In addition, keep in mind that certain languages have a small input buffer size by default.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 Qualification] Trouble Sort", "background": "", "description": "Deep in Code Jam's secret algorithm labs, we devote countless hours to wrestling with one of the most complex problems of our time: efficiently sorting a list of integers into non-decreasing order. We have taken a careful look at the classic bubble sort algorithm, and we are pleased to announce a new variant.\n\nThe basic operation of the standard bubble sort algorithm is to examine a pair of adjacent numbers, and reverse that pair if the left number is larger than the right number. But our algorithm examines a group of three adjacent numbers, and if the leftmost number is larger than the rightmost number, it reverses that entire group. Because our algorithm is a \"triplet bubble sort\", we have named it Trouble Sort for short.\n\n```\n  TroubleSort(L): // L is a 0-indexed list of integers\n    let done := false\n    while not done:\n      done = true\n      for i := 0; i < len(L)-2; i++:\n        if L[i] > L[i+2]:\n          done = false\n          reverse the sublist from L[i] to L[i+2], inclusive\n```\n\nFor example, for $L = 5 \\ 6 \\ 6 \\ 4 \\ 3$, Trouble Sort would proceed as follows:\n\n- First pass:\n    - inspect $5 \\ 6 \\ 6$, do nothing: $5 \\ 6 \\ 6 \\ 4 \\ 3$\n    - inspect $6 \\ 6 \\ 4$, see that $6 > 4$, reverse the triplet: $5 \\ 4 \\ 6 \\ 6 \\ 3$\n    - inspect $6 \\ 6 \\ 3$, see that $6 > 3$, reverse the triplet: $5 \\ 4 \\ 3 \\ 6 \\ 6$\n- Second pass:\n    - inspect $5 \\ 4 \\ 3$, see that $5 > 3$, reverse the triplet: $3 \\ 4 \\ 5 \\ 6 \\ 6$\n    - inspect $4 \\ 5 \\ 6$, do nothing: $3 \\ 4 \\ 5 \\ 6 \\ 6$\n    - inspect $5 \\ 6 \\ 6$, do nothing: $3 \\ 4 \\ 5 \\ 6 \\ 6$\n- Then the third pass inspects the three triplets and does nothing, so the algorithm terminates.\n\nWe were looking forward to presenting Trouble Sort at the Special Interest Group in Sorting conference in Hawaii, but one of our interns has just pointed out a problem: it is possible that Trouble Sort does not correctly sort the list! Consider the list $8 \\ 9 \\ 7$, for example.\n\nWe need your help with some further research. Given a list of $\\mathbf N$ integers, determine whether Trouble Sort will successfully sort the list into non-decreasing order. If it will not, find the index (counting starting from 0) of the first sorting error after the algorithm has finished: that is, the first value that is larger than the value that comes directly after it when the algorithm is done.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines: one line with an integer $\\mathbf{N}$, the number of values in the list, and then another line with $\\mathbf{N}$ integers $\\mathbf{V}_\\mathbf{i}$, the list of values.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is ok if Trouble Sort correctly sorts the list, or the index (counting starting from 0) of the first sorting error, as described above.", "hint": "**Sample Explanation**\n\nSample Case #1 is similar to the first one described in the problem statement. Trouble Sort correctly sorts this list, so the answer is OK.\n\nSample Case #2 is the second one described in the problem statement. Trouble Sort does not correctly sort this list, since it terminates with the list $7\\ 9\\ 8$. The $9$ is the first value in the list that is larger than the next value, so the index of the first sorting error is $1$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $0 \\leq V_i \\leq 10^9,$ for all $i$.\n\n**Test set 1 (8 Pts, Visible)**\n\n- $3 \\leq N \\leq 100.$\n- Time limit (for the entire test set): 10 seconds.\n\n**Test set 2 (15 Pts, Hidden)**\n\n- $3 \\leq N \\leq 10^5.$\n- Time limit (for the entire test set): 20 seconds.\n\n**Special Note**\n\nNotice that test set 2 for this problem has a large amount of input, so using a non-buffered reader might lead to slower input reading. In addition, keep in mind that certain languages have a small input buffer size by default.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 Qualification] Trouble Sort", "background": null, "description": "在 Code Jam 的秘密算法实验室里，我们花费了无数小时，致力于解决当今最复杂的问题之一：高效地将一个整数序列按非递减顺序排序。我们仔细研究了经典的冒泡排序算法，并很高兴地宣布一种新变体。\n\n标准冒泡排序算法的基本操作是检查一对相邻的数字，如果左边的数字大于右边的数字，则交换这对数字。而我们的算法会检查一组三个相邻的数字，如果最左边的数字大于最右边的数字，就将整个三元组反转。由于我们的算法是“三元组冒泡排序”，我们将其简称为 Trouble Sort。\n\n```\n  TroubleSort(L): // L 是一个从 0 开始编号的整数列表\n    let done := false\n    while not done:\n      done = true\n      for i := 0; i < len(L)-2; i++:\n        if L[i] > L[i+2]:\n          done = false\n          reverse the sublist from L[i] to L[i+2], inclusive\n```\n\n例如，对于 $L = 5\\ 6\\ 6\\ 4\\ 3$，Trouble Sort 的执行过程如下：\n\n- 第一轮：\n    - 检查 $5\\ 6\\ 6$，无需操作：$5\\ 6\\ 6\\ 4\\ 3$\n    - 检查 $6\\ 6\\ 4$，发现 $6 > 4$，反转三元组：$5\\ 4\\ 6\\ 6\\ 3$\n    - 检查 $6\\ 6\\ 3$，发现 $6 > 3$，反转三元组：$5\\ 4\\ 3\\ 6\\ 6$\n- 第二轮：\n    - 检查 $5\\ 4\\ 3$，发现 $5 > 3$，反转三元组：$3\\ 4\\ 5\\ 6\\ 6$\n    - 检查 $4\\ 5\\ 6$，无需操作：$3\\ 4\\ 5\\ 6\\ 6$\n    - 检查 $5\\ 6\\ 6$，无需操作：$3\\ 4\\ 5\\ 6\\ 6$\n- 第三轮检查所有三元组均无需操作，算法终止。\n\n我们原本期待在夏威夷举办的排序特别兴趣小组会议上展示 Trouble Sort，但我们的一个实习生刚刚指出了一个问题：Trouble Sort 可能无法正确地对序列进行排序！例如，考虑序列 $8\\ 9\\ 7$。\n\n我们需要你的帮助来进一步研究。给定一个长度为 $\\mathbf N$ 的整数序列，判断 Trouble Sort 是否能将该序列正确地按非递减顺序排序。如果不能，请在算法结束后找出第一个排序错误的位置（从 0 开始计数）：即第一个比其后一个数大的数的下标。", "inputFormat": "输入的第一行包含测试用例的数量 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组测试数据包含两行：第一行为一个整数 $\\mathbf{N}$，表示序列的长度，第二行为 $\\mathbf{N}$ 个整数 $\\mathbf{V}_\\mathbf{i}$，表示序列中的元素。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为 ok（如果 Trouble Sort 能正确排序），或者为第一个排序错误的下标（从 0 开始计数），如上所述。", "hint": "**样例解释**\n\n样例 Case #1 与题目描述中的第一个例子类似。Trouble Sort 能正确排序该序列，因此输出 ok。\n\n样例 Case #2 是题目描述中的第二个例子。Trouble Sort 无法正确排序该序列，最终结果为 $7\\ 9\\ 8$。$9$ 是第一个比下一个数大的数，因此第一个排序错误的下标为 $1$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- 对所有 $i$，$0 \\leq V_i \\leq 10^9$。\n\n**测试点 1（8 分，可见）**\n\n- $3 \\leq N \\leq 100$。\n- 整个测试点的时间限制：10 秒。\n\n**测试点 2（15 分，隐藏）**\n\n- $3 \\leq N \\leq 10^5$。\n- 整个测试点的时间限制：20 秒。\n\n**特别说明**\n\n注意，本题的测试点 2 输入量很大，因此使用非缓冲输入可能导致读取速度较慢。此外，请注意某些编程语言默认的输入缓冲区较小。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13134", "type": "P", "difficulty": 2, "samples": [["", ""]], "limits": {"time": [20000, 60000], "memory": [1048576, 1048576]}, "tags": ["2018", "交互题", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2018 Qualification] Go, Gopher!", "background": "", "description": "The Code Jam team has just purchased an orchard that is a two-dimensional matrix of cells of unprepared soil, with $1000$ rows and $1000$ columns. We plan to use this orchard to grow a variety of trees — AVL, binary, red-black, splay, and so on — so we need to prepare some of the cells by digging holes:\n\n- In order to have enough trees to use for each year's tree problems, we need there to be at least $A$ prepared cells.\n- In order to care for our trees properly, the set of all prepared cells must form a single grid-aligned rectangle in which every cell within the rectangle is prepared.\n\nNote that the above also implies that none of the cells outside of that rectangle can be prepared. We want the orchard to look tidy!\n\nFor example, when $\\mathbf A=11$, although the eleven prepared cells in the left figure below form a $3 \\times 4$ rectangle (that is, with $3$ rows and $4$ columns), the cell in the center of the rectangle is not prepared. As a result, we have not yet completed preparing our orchard, since not every cell of the $3 \\times 4$ rectangle is prepared. However, after just preparing the center cell, the rectangle of size at least $11$ is fully filled, and the orchard is ready.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qetth289.png)\n\nSee below for another example. In this case, $\\mathbf{A}=6$. Note that the middle figure prepares a cell outside the $3\\times 2$ rectangle, so although the rightmost figure prepares a rectangle of size $6$, the entire set of the prepared cells does not form a rectangle (due to the extra cell on the left). As a result, the orchard is not ready.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/twco3tpd.png)\n\nDigging is hard work for humans, so we have borrowed the [Go gopher](https://blog.golang.org/gopher) from the [Google Go](https://golang.org/) team and trained it to help us out by preparing cells. We can deploy the gopher by giving it the coordinates of a target cell in the matrix that is not along any of the borders of the matrix. However, we have not yet perfected the gopher's training, so it will choose a cell uniformly at [(pseudo-)random](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) from the $3\\times 3$ block of nine cells centered on the target cell, and then prepare the cell it has chosen. (If it chooses a cell that was already prepared, it will uselessly prepare it again.)\n\nWe can only deploy the gopher up to $1000$ times before it gets too tired to keep digging, so we need your help in figuring out how to deploy it strategically. When you deploy the gopher, you will be told which cell the gopher actually prepared, and you can take this information into account before deploying it again, if needed. Note that you do not have to declare the dimensions or location of a rectangle in advance.\n\n### Interactive Protocol\n\nThis problem is interactive, which means that the concepts of input and output are different than in standard Code Jam problems. You will interact with a separate process that both provides you with information and evaluates your responses. All information comes into your program via standard input; anything that you need to communicate should be sent via standard output. Remember that many programming languages buffer the output by default, so make sure your output actually goes out (for instance, by flushing the buffer) before blocking to wait for a response. See the FAQ for an explanation of what it means to flush the buffer. Anything your program sends through standard error is ignored, but it might consume some memory and be counted against your memory limit, so do not overflow it. To help you debug, a local testing tool script (in Python) is provided at the very end of the problem statement. In addition, sample solutions to a previous Code Jam interactive problem (in all of our supported languages) are provided in the analysis for Number Guessing.\n\nInitially, your program should read a single line containing a single integer $\\mathbf T$ indicating the number of test cases. Then, you need to process $\\mathbf T$ test cases.\n\nFor each test case, your program will read a single line containing a single integer $\\mathbf A$ indicating the minimum required prepared rectangular area. Then, your program will process up to $1000$ exchanges with our judge.\n\nFor each exchange, your program needs to use standard output to send a single line containing two integers $I$ and $J$: the row and column number you want to deploy the gopher to. The two integers must be between $2$ and $999$, and written in base-10 without leading zeroes. If your output format is wrong (e.g., out of bounds values), your program will fail, and the judge will send you a single line with $-1 -1$ which signals that your test has failed, and it will not send anything to your input stream after that. Otherwise, in response to your deployment, the judge will print a single line containing two integers $I'$ and $J'$ to your input stream, which your program must read through standard input.\n\nIf the last deployment caused the set of prepared cells to be a rectangle of area at least $\\mathbf A$, you will get $I' = J' = 0$, signaling the end of the test case. Otherwise, $I'$ and $J'$ are the row and column numbers of the cell that was actually prepared by the gopher, with $\\text{abs}(I'-I) \\leq 1$ and $\\text{abs}(J'-J) \\leq 1$. Then, you can start another exchange.\n\nIf your program gets something wrong (e.g. wrong output format, or out-of-bounds values), as mentioned above, the judge will send $I' = J' = -1$, and stop sending output to your input stream afterwards. If your program continues to wait for the judge after reading in $I' = J' = -1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive the appropriate verdict (Wrong Answer, Runtime Error, etc.) instead of a Time Limit Exceeded error. As usual, if the total time or memory is exceeded, or your program gets a runtime error, you will receive the appropriate verdict.\n\nIf the test case is solved within $1000$ deployments, you will receive the $I' = J' = 0$ message from the judge, as mentioned above, and then continue to solve the next test case. After $1000$ exchanges, if the test case is not solved, the judge will send the $I' = J' = -1$ message, and stop sending output to your input stream after.\n\nYou should not send additional information to the judge after solving all test cases. In other words, if your program keeps printing to standard output after receiving $I' = J' = 0$ message from the judge for the last test case, you will receive a Wrong Answer judgment.\n\nPlease be advised that for a given test case, the cells that the gopher will pick from each $3 \\times 3$ block are (pseudo-)random and independent of each other, but they are determined using the same seed each time for the same test case, so a solution that gives an incorrect result for a test case will do so consistently across all attempts for the same test case. We have also set different seeds for different test cases.\n", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\n```\n  t = readline_int()         // reads 2 into t\n  a = readline_int()         // reads 3 into a\n  printline 10 10 to stdout  // sends out cell 10 10 to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 10 11, since cell 10 11 is prepared\n  printline 10 10 to stdout  // sends out cell 10 10 again to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 10 10, since cell 10 10 is prepared\n  printline 10 12 to stdout  // sends out cell 10 12 to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 10 11, since cell 10 11 is prepared again\n  printline 10 10 to stdout  // sends out cell 10 10 to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 11 10, since cell 11 10 is prepared\n  printline 11 10 to stdout  // sends out cell 11 10 to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 0 0; since cell 11 11 is prepared, a rectangle of size 4\n```\n\nThe pseudocode above is the first half of a sample interaction for one test set. Suppose there are only two test cases in this test set. The pseudocode first reads the number of test cases into an integer $t$. Then the first test case begins. For the first test case, suppose $\\mathbf A$ is $3$ (although, in the real test sets, $\\mathbf A$ is always either $20$ or $200$). The pseudocode first reads the value of $\\mathbf A$ into an integer $a$, and outputs $10 \\ 10$ the location of the cell to prepare. By (pseudo-)random choice, the cell at location $10 \\ 11$ is prepared, so the code reads $10 \\ 11$ in response. Next, the code outputs cell $10 \\ 10$ again for preparation, and the gopher prepares $10 \\ 10$ this time. The code subsequently sends $10 \\ 12$ with the goal of finishing preparing a rectangle of size $3$, but only gets cell $10 \\ 11$ prepared again. $10 \\ 10$ is then sent out, and this time $11 \\ 10$ is prepared. Notice that although the prepared area is of size $3$, a rectangle has not been formed, so the preparation goes on. In the end, the pseudocode decides to try out cell $11 \\ 10$, and $0 \\ 0$ is sent back, which implies that cell $11 \\ 11$ has been prepared, completing a rectangle (or square, rather) or size $4$. As a result, the first test case is successfully solved.\n\n```\n  a = readline_int()         // reads 3 into a\n  printline 10 10 to stdout  // sends out cell 10 10 to prepare\n  x, y = readline_two_int()  // does not flush stdout; hangs on the judge\n```\n\nNow the pseudocode is ready for the second test case. It again first reads an integer $a = 3$ and decides to send cell $10\\ 10$ to prepare. However, this time, the code forgets to flush the stdout buffer! As a result, $10\\ 10$ is buffered and not sent to the judge. Both the judge and the code wait on each other, leading to a deadlock and eventually a Time Limit Exceeded error.\n\n```\n  a = readline_int()         // reads 3 into a\n  printline 1 1 to stdout    // sends out cell 1 1 to prepare\n  x, y = readline_two_int()  // reads -1 -1, since 1 is outside the range [2, 999]\n  printline 10 10 to stdout  // sends a cell location anyway\n  x, y = readline_two_int()  // hangs since the judge stops sending info to stdin\n```\n\nThe code above is another example. Suppose for the second test case, the code remembers to flush the output buffer, but sends out cell $1 \\ 1$ to prepare. Remember that the row and column of the chosen cell must both be in the range $[2, 999]$, so $1 \\ 1$ is illegal! As a result, the judge sends back $-1 \\ -1$. However, after reading $-1 \\ -1$ into $x$ and $y$, the code proceeds to send another cell location to the judge, and wait. Since there is nothing in the input stream (the judge has stopped sending info), the code hangs and will eventually receive a Time Limit Exceeded error.\n\nNote that if the code in the example above exits immediately after reading $-1 \\ -1$, it will receive a Wrong Answer instead:\n\n```\n  a = readline_int()         // reads 3 into a\n  printline 1 1 to stdout    // sends out cell 1 1 to prepare\n  x, y = readline_two_int()  // reads -1 -1, since 1 is outside the range [2, 999]\n  exit                       // receives a Wrong Answer judgment\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n$1 \\leqslant T \\leqslant 20$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $A=20$.\n- Time limit (for the entire test set): 20 seconds.\n\n**Test set 2 (20 Pts, Hidden)**\n\n- $A=200$.\n- Time limit (for the entire test set): 60 seconds.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 Qualification] Go, Gopher!", "background": "", "description": "The Code Jam team has just purchased an orchard that is a two-dimensional matrix of cells of unprepared soil, with $1000$ rows and $1000$ columns. We plan to use this orchard to grow a variety of trees — AVL, binary, red-black, splay, and so on — so we need to prepare some of the cells by digging holes:\n\n- In order to have enough trees to use for each year's tree problems, we need there to be at least $A$ prepared cells.\n- In order to care for our trees properly, the set of all prepared cells must form a single grid-aligned rectangle in which every cell within the rectangle is prepared.\n\nNote that the above also implies that none of the cells outside of that rectangle can be prepared. We want the orchard to look tidy!\n\nFor example, when $\\mathbf A=11$, although the eleven prepared cells in the left figure below form a $3 \\times 4$ rectangle (that is, with $3$ rows and $4$ columns), the cell in the center of the rectangle is not prepared. As a result, we have not yet completed preparing our orchard, since not every cell of the $3 \\times 4$ rectangle is prepared. However, after just preparing the center cell, the rectangle of size at least $11$ is fully filled, and the orchard is ready.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qetth289.png)\n\nSee below for another example. In this case, $\\mathbf{A}=6$. Note that the middle figure prepares a cell outside the $3\\times 2$ rectangle, so although the rightmost figure prepares a rectangle of size $6$, the entire set of the prepared cells does not form a rectangle (due to the extra cell on the left). As a result, the orchard is not ready.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/twco3tpd.png)\n\nDigging is hard work for humans, so we have borrowed the [Go gopher](https://blog.golang.org/gopher) from the [Google Go](https://golang.org/) team and trained it to help us out by preparing cells. We can deploy the gopher by giving it the coordinates of a target cell in the matrix that is not along any of the borders of the matrix. However, we have not yet perfected the gopher's training, so it will choose a cell uniformly at [(pseudo-)random](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) from the $3\\times 3$ block of nine cells centered on the target cell, and then prepare the cell it has chosen. (If it chooses a cell that was already prepared, it will uselessly prepare it again.)\n\nWe can only deploy the gopher up to $1000$ times before it gets too tired to keep digging, so we need your help in figuring out how to deploy it strategically. When you deploy the gopher, you will be told which cell the gopher actually prepared, and you can take this information into account before deploying it again, if needed. Note that you do not have to declare the dimensions or location of a rectangle in advance.\n\n### Interactive Protocol\n\nThis problem is interactive, which means that the concepts of input and output are different than in standard Code Jam problems. You will interact with a separate process that both provides you with information and evaluates your responses. All information comes into your program via standard input; anything that you need to communicate should be sent via standard output. Remember that many programming languages buffer the output by default, so make sure your output actually goes out (for instance, by flushing the buffer) before blocking to wait for a response. See the FAQ for an explanation of what it means to flush the buffer. Anything your program sends through standard error is ignored, but it might consume some memory and be counted against your memory limit, so do not overflow it. To help you debug, a local testing tool script (in Python) is provided at the very end of the problem statement. In addition, sample solutions to a previous Code Jam interactive problem (in all of our supported languages) are provided in the analysis for Number Guessing.\n\nInitially, your program should read a single line containing a single integer $\\mathbf T$ indicating the number of test cases. Then, you need to process $\\mathbf T$ test cases.\n\nFor each test case, your program will read a single line containing a single integer $\\mathbf A$ indicating the minimum required prepared rectangular area. Then, your program will process up to $1000$ exchanges with our judge.\n\nFor each exchange, your program needs to use standard output to send a single line containing two integers $I$ and $J$: the row and column number you want to deploy the gopher to. The two integers must be between $2$ and $999$, and written in base-10 without leading zeroes. If your output format is wrong (e.g., out of bounds values), your program will fail, and the judge will send you a single line with $-1 -1$ which signals that your test has failed, and it will not send anything to your input stream after that. Otherwise, in response to your deployment, the judge will print a single line containing two integers $I'$ and $J'$ to your input stream, which your program must read through standard input.\n\nIf the last deployment caused the set of prepared cells to be a rectangle of area at least $\\mathbf A$, you will get $I' = J' = 0$, signaling the end of the test case. Otherwise, $I'$ and $J'$ are the row and column numbers of the cell that was actually prepared by the gopher, with $\\text{abs}(I'-I) \\leq 1$ and $\\text{abs}(J'-J) \\leq 1$. Then, you can start another exchange.\n\nIf your program gets something wrong (e.g. wrong output format, or out-of-bounds values), as mentioned above, the judge will send $I' = J' = -1$, and stop sending output to your input stream afterwards. If your program continues to wait for the judge after reading in $I' = J' = -1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive the appropriate verdict (Wrong Answer, Runtime Error, etc.) instead of a Time Limit Exceeded error. As usual, if the total time or memory is exceeded, or your program gets a runtime error, you will receive the appropriate verdict.\n\nIf the test case is solved within $1000$ deployments, you will receive the $I' = J' = 0$ message from the judge, as mentioned above, and then continue to solve the next test case. After $1000$ exchanges, if the test case is not solved, the judge will send the $I' = J' = -1$ message, and stop sending output to your input stream after.\n\nYou should not send additional information to the judge after solving all test cases. In other words, if your program keeps printing to standard output after receiving $I' = J' = 0$ message from the judge for the last test case, you will receive a Wrong Answer judgment.\n\nPlease be advised that for a given test case, the cells that the gopher will pick from each $3 \\times 3$ block are (pseudo-)random and independent of each other, but they are determined using the same seed each time for the same test case, so a solution that gives an incorrect result for a test case will do so consistently across all attempts for the same test case. We have also set different seeds for different test cases.\n", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\n```\n  t = readline_int()         // reads 2 into t\n  a = readline_int()         // reads 3 into a\n  printline 10 10 to stdout  // sends out cell 10 10 to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 10 11, since cell 10 11 is prepared\n  printline 10 10 to stdout  // sends out cell 10 10 again to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 10 10, since cell 10 10 is prepared\n  printline 10 12 to stdout  // sends out cell 10 12 to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 10 11, since cell 10 11 is prepared again\n  printline 10 10 to stdout  // sends out cell 10 10 to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 11 10, since cell 11 10 is prepared\n  printline 11 10 to stdout  // sends out cell 11 10 to prepare\n  flush stdout\n  x, y = readline_two_int()  // reads 0 0; since cell 11 11 is prepared, a rectangle of size 4\n```\n\nThe pseudocode above is the first half of a sample interaction for one test set. Suppose there are only two test cases in this test set. The pseudocode first reads the number of test cases into an integer $t$. Then the first test case begins. For the first test case, suppose $\\mathbf A$ is $3$ (although, in the real test sets, $\\mathbf A$ is always either $20$ or $200$). The pseudocode first reads the value of $\\mathbf A$ into an integer $a$, and outputs $10 \\ 10$ the location of the cell to prepare. By (pseudo-)random choice, the cell at location $10 \\ 11$ is prepared, so the code reads $10 \\ 11$ in response. Next, the code outputs cell $10 \\ 10$ again for preparation, and the gopher prepares $10 \\ 10$ this time. The code subsequently sends $10 \\ 12$ with the goal of finishing preparing a rectangle of size $3$, but only gets cell $10 \\ 11$ prepared again. $10 \\ 10$ is then sent out, and this time $11 \\ 10$ is prepared. Notice that although the prepared area is of size $3$, a rectangle has not been formed, so the preparation goes on. In the end, the pseudocode decides to try out cell $11 \\ 10$, and $0 \\ 0$ is sent back, which implies that cell $11 \\ 11$ has been prepared, completing a rectangle (or square, rather) or size $4$. As a result, the first test case is successfully solved.\n\n```\n  a = readline_int()         // reads 3 into a\n  printline 10 10 to stdout  // sends out cell 10 10 to prepare\n  x, y = readline_two_int()  // does not flush stdout; hangs on the judge\n```\n\nNow the pseudocode is ready for the second test case. It again first reads an integer $a = 3$ and decides to send cell $10\\ 10$ to prepare. However, this time, the code forgets to flush the stdout buffer! As a result, $10\\ 10$ is buffered and not sent to the judge. Both the judge and the code wait on each other, leading to a deadlock and eventually a Time Limit Exceeded error.\n\n```\n  a = readline_int()         // reads 3 into a\n  printline 1 1 to stdout    // sends out cell 1 1 to prepare\n  x, y = readline_two_int()  // reads -1 -1, since 1 is outside the range [2, 999]\n  printline 10 10 to stdout  // sends a cell location anyway\n  x, y = readline_two_int()  // hangs since the judge stops sending info to stdin\n```\n\nThe code above is another example. Suppose for the second test case, the code remembers to flush the output buffer, but sends out cell $1 \\ 1$ to prepare. Remember that the row and column of the chosen cell must both be in the range $[2, 999]$, so $1 \\ 1$ is illegal! As a result, the judge sends back $-1 \\ -1$. However, after reading $-1 \\ -1$ into $x$ and $y$, the code proceeds to send another cell location to the judge, and wait. Since there is nothing in the input stream (the judge has stopped sending info), the code hangs and will eventually receive a Time Limit Exceeded error.\n\nNote that if the code in the example above exits immediately after reading $-1 \\ -1$, it will receive a Wrong Answer instead:\n\n```\n  a = readline_int()         // reads 3 into a\n  printline 1 1 to stdout    // sends out cell 1 1 to prepare\n  x, y = readline_two_int()  // reads -1 -1, since 1 is outside the range [2, 999]\n  exit                       // receives a Wrong Answer judgment\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n$1 \\leqslant T \\leqslant 20$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $A=20$.\n- Time limit (for the entire test set): 20 seconds.\n\n**Test set 2 (20 Pts, Hidden)**\n\n- $A=200$.\n- Time limit (for the entire test set): 60 seconds.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 Qualification] Go, Gopher!", "background": null, "description": "Code Jam 团队刚刚购买了一片果园，这片果园是一个 $1000$ 行 $1000$ 列的二维矩阵，每个格子都是未经准备的土壤。我们计划在这片果园里种植各种树木——AVL 树、二叉树、红黑树、伸展树等等——因此我们需要通过挖坑来准备一些格子：\n\n- 为了保证每年有足够的树用于树类题目，我们需要至少有 $A$ 个准备好的格子。\n- 为了便于照料树木，所有准备好的格子必须组成一个网格对齐的矩形，并且该矩形内的每一个格子都必须被准备好。\n\n注意，上述要求还意味着，矩形外的格子都不能被准备。我们希望果园看起来整洁！\n\n例如，当 $\\mathbf A=11$ 时，虽然下图左侧的 11 个准备好的格子组成了一个 $3 \\times 4$ 的矩形（即有 3 行 4 列），但该矩形中心的格子尚未准备好。因此，我们还没有完成果园的准备，因为 $3 \\times 4$ 矩形内并非每个格子都已准备好。然而，只需再准备中心的那个格子，面积至少为 11 的矩形就被完全填满，果园也就准备好了。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qetth289.png)\n\n下面是另一个例子。在这种情况下，$\\mathbf{A}=6$。注意，中间的图在 $3\\times 2$ 矩形之外准备了一个格子，因此虽然最右侧的图准备了一个面积为 6 的矩形，但所有准备好的格子并未组成一个矩形（因为左侧多了一个格子）。因此，果园还没有准备好。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/twco3tpd.png)\n\n挖坑对人类来说很辛苦，所以我们从 [Google Go](https://golang.org/) 团队借来了 [Go gopher](https://blog.golang.org/gopher)，并训练它来帮我们准备格子。我们可以通过给它一个目标格子的坐标来部署 gopher，但目标格子不能在矩阵的任意边界上。然而，我们的训练还不够完善，所以它会从以目标格子为中心的 $3\\times 3$ 区块的九个格子中，均匀地（伪）随机选择一个格子，然后准备它。（如果它选择了一个已经准备好的格子，它会无用地再准备一次。）\n\n我们最多只能部署 gopher $1000$ 次，否则它会太累而无法继续挖坑，所以我们需要你帮忙，制定一个策略来部署它。每次部署 gopher 后，你会被告知它实际准备了哪个格子，你可以据此决定下一步的部署。注意，你不需要提前声明矩形的尺寸或位置。\n\n### 交互协议\n\n本题为交互题，这意味着输入输出方式与标准 Code Jam 题目不同。你需要与一个独立的进程进行交互，该进程既向你提供信息，也会评判你的回答。所有信息都通过标准输入进入你的程序；你需要传达的信息应通过标准输出发送。请注意，许多编程语言默认会缓冲输出，因此在等待回应前，请确保你的输出已真正发送出去（例如，通过刷新缓冲区）。详见 FAQ 关于刷新缓冲区的说明。你通过标准错误输出的内容会被忽略，但可能会占用内存并计入内存限制，所以不要输出过多调试信息。为帮助你调试，题目末尾提供了本地测试工具脚本（Python 版）。此外，在 Number Guessing 的题解中还提供了所有支持语言的交互题样例代码。\n\n最开始，你的程序应读取一行，包含一个整数 $\\mathbf T$，表示测试用例的数量。然后，你需要处理 $\\mathbf T$ 个测试用例。\n\n对于每个测试用例，你的程序会读取一行，包含一个整数 $\\mathbf A$，表示所需准备的最小矩形面积。然后，你的程序最多可以与评测机进行 $1000$ 次交互。\n\n每次交互时，你需要通过标准输出发送一行，包含两个整数 $I$ 和 $J$，表示你希望部署 gopher 的行号和列号。两个整数都必须在 $2$ 到 $999$ 之间，且为十进制、无前导零。如果你的输出格式错误（如超出范围），你的程序会失败，评测机会返回一行 $-1 -1$，表示测试失败，之后不会再向你的输入流发送任何内容。否则，作为回应，评测机会向你的输入流输出一行，包含两个整数 $I'$ 和 $J'$，表示 gopher 实际准备的格子的行号和列号。\n\n如果上一次部署后，所有准备好的格子组成了一个面积至少为 $\\mathbf A$ 的矩形，你会收到 $I' = J' = 0$，表示该测试用例结束。否则，$I'$ 和 $J'$ 是 gopher 实际准备的格子的行号和列号，且满足 $\\text{abs}(I'-I) \\leq 1$ 且 $\\text{abs}(J'-J) \\leq 1$。然后，你可以开始下一次交互。\n\n如果你的程序出现错误（如输出格式错误或超出范围），如上所述，评测机会返回 $I' = J' = -1$，之后不会再向你的输入流发送任何内容。如果你的程序在读取到 $I' = J' = -1$ 后仍然等待评测机，则会超时，导致 Time Limit Exceeded 错误。请注意，你有责任让程序及时退出，以获得正确的评判结果（Wrong Answer、Runtime Error 等），而不是 Time Limit Exceeded。和往常一样，如果总时间或内存超限，或程序运行时出错，你会收到相应的评判结果。\n\n如果在 $1000$ 次部署内解决了测试用例，你会收到 $I' = J' = 0$ 的消息，然后继续解决下一个测试用例。如果 $1000$ 次交互后仍未解决该测试用例，评测机会返回 $I' = J' = -1$，之后不会再向你的输入流发送任何内容。\n\n在解决所有测试用例后，你不应再向评测机发送任何信息。换句话说，如果你在收到最后一个测试用例的 $I' = J' = 0$ 消息后仍继续向标准输出打印内容，你会收到 Wrong Answer 的评判。\n\n请注意，对于每个测试用例，gopher 从每个 $3 \\times 3$ 区块中选择格子的方式是（伪）随机且彼此独立的，但对于同一个测试用例，每次的随机种子是相同的，因此对于同一个测试用例，错误的解法会始终错误。不同测试用例的随机种子不同。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**交互样例**\n\n```\n  t = readline_int()         // 读取 t=2\n  a = readline_int()         // 读取 a=3\n  printline 10 10 to stdout  // 输出 10 10，表示准备该格子\n  flush stdout\n  x, y = readline_two_int()  // 读取 10 11，表示实际准备了 10 11\n  printline 10 10 to stdout  // 再次输出 10 10\n  flush stdout\n  x, y = readline_two_int()  // 读取 10 10，实际准备了 10 10\n  printline 10 12 to stdout  // 输出 10 12\n  flush stdout\n  x, y = readline_two_int()  // 读取 10 11，再次准备了 10 11\n  printline 10 10 to stdout  // 输出 10 10\n  flush stdout\n  x, y = readline_two_int()  // 读取 11 10，实际准备了 11 10\n  printline 11 10 to stdout  // 输出 11 10\n  flush stdout\n  x, y = readline_two_int()  // 读取 0 0，表示 11 11 被准备好，形成了面积为 4 的矩形\n```\n\n上面的伪代码是某一测试组的前半部分交互样例。假设该测试组只有两个测试用例。伪代码首先读取测试用例数 $t$。然后开始第一个测试用例，假设 $\\mathbf A = 3$（实际测试组中 $\\mathbf A$ 只会是 $20$ 或 $200$）。伪代码首先读取 $a$，然后输出 $10\\ 10$，请求准备该格子。由于（伪）随机选择，$10\\ 11$ 被准备，于是读取 $10\\ 11$。接着再次请求 $10\\ 10$，这次 $10\\ 10$ 被准备。随后输出 $10\\ 12$，希望完成面积为 $3$ 的矩形，但只得到了 $10\\ 11$。再次请求 $10\\ 10$，这次 $11\\ 10$ 被准备。注意，虽然准备好的面积已达 $3$，但还未形成矩形，因此继续准备。最后尝试 $11\\ 10$，收到 $0\\ 0$，表示 $11\\ 11$ 被准备，完成了面积为 $4$ 的矩形（实际上是正方形）。因此，第一个测试用例成功解决。\n\n```\n  a = readline_int()         // 读取 a=3\n  printline 10 10 to stdout  // 输出 10 10\n  x, y = readline_two_int()  // 未刷新输出缓冲区，导致评测机阻塞\n```\n\n现在准备第二个测试用例。再次读取 $a=3$，并请求准备 $10\\ 10$。但这次忘记刷新输出缓冲区！结果 $10\\ 10$ 被缓冲，未发送给评测机。评测机和代码都在等待对方，最终导致超时。\n\n```\n  a = readline_int()         // 读取 a=3\n  printline 1 1 to stdout    // 输出 1 1\n  x, y = readline_two_int()  // 读取 -1 -1，因为 1 不在 [2, 999] 范围内\n  printline 10 10 to stdout  // 仍然输出\n  x, y = readline_two_int()  // 阻塞，因为评测机已停止发送信息\n```\n\n上面是另一个例子。假设第二个测试用例，代码记得刷新输出缓冲区，但输出了 $1\\ 1$。注意，行列号必须都在 $[2, 999]$ 范围内，所以 $1\\ 1$ 非法！评测机返回 $-1\\ -1$。但代码在读取到 $-1\\ -1$ 后仍然向评测机发送请求并等待，评测机已停止发送信息，最终导致超时。\n\n注意，如果上述代码在读取到 $-1\\ -1$ 后立即退出，则会收到 Wrong Answer：\n\n```\n  a = readline_int()         // 读取 a=3\n  printline 1 1 to stdout    // 输出 1 1\n  x, y = readline_two_int()  // 读取 -1 -1，因为 1 不在 [2, 999] 范围内\n  exit                       // 收到 Wrong Answer 评判\n```\n\n你可以使用本地测试工具在本地或平台上测试。要在本地测试，你需要让测试工具与你的代码并行运行；你可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释说明。\n\n测试工具的使用说明已包含在脚本注释中。建议你添加自己的测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真正的评测系统，可能会有不同的表现。\n\n**数据范围**\n\n$1 \\leqslant T \\leqslant 20$。\n\n**测试点 1（10 分，可见）**\n\n- $A=20$。\n- 整个测试点的时间限制：20 秒。\n\n**测试点 2（20 分，隐藏）**\n\n- $A=200$。\n- 整个测试点的时间限制：60 秒。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13135", "type": "P", "difficulty": 5, "samples": [["2\n1.000000\n1.414213", "Case #1:\n0.5 0 0\n0 0.5 0\n0 0 0.5\nCase #2:\n0.3535533905932738 0.3535533905932738 0\n-0.3535533905932738 0.3535533905932738 0\n0 0 0.5"]], "limits": {"time": [30000, 30000], "memory": [1048576, 1048576]}, "tags": ["数学", "计算几何", "2018", "Special Judge", "凸包", "Google Code Jam"], "title": "[GCJ 2018 Qualification] Cubic UFO", "background": "", "description": "A mysterious cubic alien ship has appeared in the sky over Toronto! In this problem, Toronto is a plane in three-dimensional space that is parallel to the xz plane at $y = -3$ km. The alien ship is a solid cube with side length 1 km, centered at $(0 \\text{ km}, 0 \\text{ km}, 0 \\text{ km})$, with its eight corners at $(\\pm 0.5 \\text{ km}, \\pm 0.5 \\text{ km}, \\pm 0.5 \\text{ km})$. The ship is casting an ominous shadow onto the plane; formally, the shadow is the orthogonal projection of the cube onto the plane. (We consider the sun to be a point infinitely far above the Toronto plane along the y-axis.)\n\nThe military is willing to tolerate the ship as long as the aliens meet their bureaucratic demand: the shadow must cover an area of the plane that is acceptably close to $\\mathbf A \\text{ km}^2$ (see the Output section for a precise definition). They have hired you, a geometric linguistics expert, to convey this demand to the aliens. In your communications so far, you have learned that the ship cannot change size, and the center of the ship cannot move, but the ship is able to rotate arbitrarily in place.\n\nPlease find a way that the aliens can rotate the ship so that the shadow's area is close to $\\mathbf A$. Express your rotation using three points: the centers of any three non-pairwise-opposing faces.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow; each consists of one line with a rational $\\mathbf{A}$, the desired area of the shadow, in $\\mathrm{km}^{2}$, with exactly six digits after the decimal point.\n\nIt is guaranteed that there is always a way to rotate the ship in the desired manner for the values of $\\mathbf{A}$ allowed in this problem.", "outputFormat": "For each test case, first output one line containing `Case #x:`, where $x$ is the test case number (starting from 1). Then, output three more lines with three rational values each: the $x, y$, and $z$ coordinates of one of your three provided face-centers, as described above. You are welcome to use decimal (e.g., 0.000123456) or scientific notation (e.g., 1.23456e-4).\n\nYour answer will be considered correct if and only if all of the following are true:\n\n1. The distance (in $\\mathrm{km}$ ) from each point to the origin must be between $0.5-10^{-6}$ and $0.5+10^{-6}$, inclusive.\n2. The angles (in radians) between segments connecting the origin to each point must be between $\\pi / 2-10^{-6}$ and $\\pi / 2+10^{-6}$, inclusive.\n3. The area of the shadow (in $\\mathrm{km}^{2}$ ), computed by projecting all 8 vertices onto the $y=-3$ plane and finding the area of the convex hull of those projected points, must be between $\\mathbf{A}-10^{-6}$ and $\\mathbf{A}+$ $10^{-6}$, inclusive. We will compute the vertices as $+/-\\mathbf{p}_{1}+/-\\mathbf{p}_{2}+/-\\mathbf{p}_{3}$ (that is, for each $\\mathbf{p}_{i}$ we add either $\\mathbf{p}_{i}$ or $-\\mathbf{p}_{i}$ to the total using vector addition), where $\\mathbf{p}_{1}, \\mathbf{p}_{2}$, and $\\mathbf{p}_{3}$ are the face-centers that you provide.\n\nPlease note that you might need to output more than 6 digits after the decimal point to safely pass the checks mentioned above. If there are multiple acceptable answers, you may output any one of them.", "hint": "In Sample Case #1, there is no need to rotate the cube at all; with two of its faces already parallel to the plane, the cube is already casting a shadow that is a square with side length $1$.\n\nIn Sample Case #2, one possible solution is to tell the aliens to give the cube a $45$ degree turn around the $x = y = 0$ line, creating a shadow that is a rectangle with dimensions of $1$ and $\\sqrt 2$.\n\nThe following rough image shows the cubes and shadows for Sample Cases #1 and #2. The sun is shown for clarity, but remember that it is actually a point infinitely far away along the y-axis.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ylvi5a65.png)\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n\n**Test set 1 (Visible)**\n\n- $1.000000 \\leqslant \\mathrm{A} \\leqslant 1.414213$\n\n**Test set 2 (Hidden)**\n\n- $1.000000 \\leqslant \\mathrm{A} \\leqslant 1.732050$", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 Qualification] Cubic UFO", "background": "", "description": "A mysterious cubic alien ship has appeared in the sky over Toronto! In this problem, Toronto is a plane in three-dimensional space that is parallel to the xz plane at $y = -3$ km. The alien ship is a solid cube with side length 1 km, centered at $(0 \\text{ km}, 0 \\text{ km}, 0 \\text{ km})$, with its eight corners at $(\\pm 0.5 \\text{ km}, \\pm 0.5 \\text{ km}, \\pm 0.5 \\text{ km})$. The ship is casting an ominous shadow onto the plane; formally, the shadow is the orthogonal projection of the cube onto the plane. (We consider the sun to be a point infinitely far above the Toronto plane along the y-axis.)\n\nThe military is willing to tolerate the ship as long as the aliens meet their bureaucratic demand: the shadow must cover an area of the plane that is acceptably close to $\\mathbf A \\text{ km}^2$ (see the Output section for a precise definition). They have hired you, a geometric linguistics expert, to convey this demand to the aliens. In your communications so far, you have learned that the ship cannot change size, and the center of the ship cannot move, but the ship is able to rotate arbitrarily in place.\n\nPlease find a way that the aliens can rotate the ship so that the shadow's area is close to $\\mathbf A$. Express your rotation using three points: the centers of any three non-pairwise-opposing faces.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow; each consists of one line with a rational $\\mathbf{A}$, the desired area of the shadow, in $\\mathrm{km}^{2}$, with exactly six digits after the decimal point.\n\nIt is guaranteed that there is always a way to rotate the ship in the desired manner for the values of $\\mathbf{A}$ allowed in this problem.", "outputFormat": "For each test case, first output one line containing `Case #x:`, where $x$ is the test case number (starting from 1). Then, output three more lines with three rational values each: the $x, y$, and $z$ coordinates of one of your three provided face-centers, as described above. You are welcome to use decimal (e.g., 0.000123456) or scientific notation (e.g., 1.23456e-4).\n\nYour answer will be considered correct if and only if all of the following are true:\n\n1. The distance (in $\\mathrm{km}$ ) from each point to the origin must be between $0.5-10^{-6}$ and $0.5+10^{-6}$, inclusive.\n2. The angles (in radians) between segments connecting the origin to each point must be between $\\pi / 2-10^{-6}$ and $\\pi / 2+10^{-6}$, inclusive.\n3. The area of the shadow (in $\\mathrm{km}^{2}$ ), computed by projecting all 8 vertices onto the $y=-3$ plane and finding the area of the convex hull of those projected points, must be between $\\mathbf{A}-10^{-6}$ and $\\mathbf{A}+$ $10^{-6}$, inclusive. We will compute the vertices as $+/-\\mathbf{p}_{1}+/-\\mathbf{p}_{2}+/-\\mathbf{p}_{3}$ (that is, for each $\\mathbf{p}_{i}$ we add either $\\mathbf{p}_{i}$ or $-\\mathbf{p}_{i}$ to the total using vector addition), where $\\mathbf{p}_{1}, \\mathbf{p}_{2}$, and $\\mathbf{p}_{3}$ are the face-centers that you provide.\n\nPlease note that you might need to output more than 6 digits after the decimal point to safely pass the checks mentioned above. If there are multiple acceptable answers, you may output any one of them.", "hint": "In Sample Case #1, there is no need to rotate the cube at all; with two of its faces already parallel to the plane, the cube is already casting a shadow that is a square with side length $1$.\n\nIn Sample Case #2, one possible solution is to tell the aliens to give the cube a $45$ degree turn around the $x = y = 0$ line, creating a shadow that is a rectangle with dimensions of $1$ and $\\sqrt 2$.\n\nThe following rough image shows the cubes and shadows for Sample Cases #1 and #2. The sun is shown for clarity, but remember that it is actually a point infinitely far away along the y-axis.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ylvi5a65.png)\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n\n**Test set 1 (Visible)**\n\n- $1.000000 \\leqslant \\mathrm{A} \\leqslant 1.414213$\n\n**Test set 2 (Hidden)**\n\n- $1.000000 \\leqslant \\mathrm{A} \\leqslant 1.732050$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 Qualification] Cubic UFO", "background": null, "description": "一艘神秘的立方体外星飞船出现在多伦多上空！在本题中，多伦多被视为三维空间中一条平行于 $xz$ 平面的平面，位于 $y = -3$ 千米处。外星飞船是一个边长为 $1$ 千米的实心立方体，中心在 $(0\\,\\text{km}, 0\\,\\text{km}, 0\\,\\text{km})$，其八个顶点分别为 $(\\pm 0.5\\,\\text{km}, \\pm 0.5\\,\\text{km}, \\pm 0.5\\,\\text{km})$。飞船在该平面上投下了一个不祥的影子；形式上，这个影子是立方体在该平面上的正交投影（我们认为太阳是一个位于 $y$ 轴正方向无限远处的点光源）。\n\n军方表示，只要外星人满足他们的官僚要求：影子在平面上覆盖的面积必须与 $\\mathbf{A}\\,\\text{km}^2$ 足够接近（具体定义见输出部分），他们就可以容忍飞船的存在。他们雇佣了你——一位几何语言学专家——来向外星人传达这一要求。你已经了解到，飞船不能改变大小，中心也不能移动，但可以在原地任意旋转。\n\n请你找出一种旋转方式，使得飞船的影子面积接近 $\\mathbf{A}$。你需要用三个点来表达旋转方式：任选三个互不相对的面心。", "inputFormat": "第一行输入一个整数 $\\mathbf{T}$，表示测试用例的数量。接下来有 $\\mathbf{T}$ 组测试数据，每组一行，包含一个有理数 $\\mathbf{A}$，表示期望的影子面积（单位为 $\\mathrm{km}^2$），精确到小数点后六位。\n\n保证对于本题允许的 $\\mathbf{A}$ 取值，总存在一种旋转方式使得飞船满足要求。", "outputFormat": "对于每个测试用例，首先输出一行 `Case #x:`，其中 $x$ 是测试用例编号（从 1 开始）。然后输出三行，每行三个有理数，分别为你选择的三个面心的 $x, y, z$ 坐标。你可以使用十进制（如 0.000123456）或科学计数法（如 1.23456e-4）输出。\n\n你的答案仅当同时满足以下所有条件时才被认为是正确的：\n\n1. 每个点到原点的距离必须在 $0.5-10^{-6}$ 到 $0.5+10^{-6}$ 千米之间（含端点）。\n2. 连接原点到每个点的线段，两两夹角（弧度）必须在 $\\pi/2-10^{-6}$ 到 $\\pi/2+10^{-6}$ 之间（含端点）。\n3. 影子的面积（单位为 $\\mathrm{km}^2$），通过将所有 8 个顶点投影到 $y=-3$ 平面并计算这些投影点的凸包面积得到，必须在 $\\mathbf{A}-10^{-6}$ 到 $\\mathbf{A}+10^{-6}$ 之间（含端点）。我们将顶点计算为 $+/-\\mathbf{p}_1+/-\\mathbf{p}_2+/-\\mathbf{p}_3$（即对于每个 $\\mathbf{p}_i$，取 $+\\mathbf{p}_i$ 或 $-\\mathbf{p}_i$，向量相加），其中 $\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3$ 是你提供的三个面心。\n\n请注意，你可能需要输出超过 6 位小数以通过上述判定。如果存在多个可行解，你可以输出任意一个。", "hint": "在样例 1 中，立方体无需旋转；此时有两个面已经与平面平行，影子是边长为 $1$ 的正方形。\n\n在样例 2 中，一种可行解是让立方体绕 $x=y=0$ 这条线旋转 $45$ 度，此时影子是 $1$ 和 $\\sqrt{2}$ 的矩形。\n\n下图为样例 1 和样例 2 的立方体及其影子示意图。太阳仅为说明而画出，实际应视为位于 $y$ 轴正方向无限远处的点。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ylvi5a65.png)\n\n**数据范围**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$。\n\n**测试点 1（可见）**\n\n- $1.000000 \\leqslant \\mathrm{A} \\leqslant 1.414213$\n\n**测试点 2（隐藏）**\n\n- $1.000000 \\leqslant \\mathrm{A} \\leqslant 1.732050$\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13136", "type": "P", "difficulty": 3, "samples": [["6\n3 6 1 1\n.@@..@\n.....@\n@.@.@@\n4 3 1 1\n@@@\n@.@\n@.@\n@@@\n4 5 1 1\n.....\n.....\n.....\n.....\n4 4 1 1\n..@@\n..@@\n@@..\n@@..\n3 4 2 2\n@.@@\n@@.@\n@.@@\n3 4 1 2\n.@.@\n@.@.\n.@.@", "Case #1: POSSIBLE\nCase #2: IMPOSSIBLE\nCase #3: POSSIBLE\nCase #4: IMPOSSIBLE\nCase #5: POSSIBLE\nCase #6: IMPOSSIBLE"]], "limits": {"time": [6000, 6000], "memory": [1048576, 1048576]}, "tags": ["2018", "前缀和", "Google Code Jam"], "title": "[GCJ 2018 #1A] Waffle Choppers", "background": "", "description": "The diners at the Infinite House of Pancakes have gotten tired of circular pancakes, so the chefs are about to offer a new menu option: waffles! As a publicity stunt, they have made one large waffle that is a grid of square cells with $\\mathrm{R}$ rows and $\\mathrm{C}$ columns. Each cell of the waffle is either empty, or contains a single chocolate chip.\n\nNow it is time for the chefs to divide up the waffle among their hungry diners. A horizontal cut runs along the entire gridline between two of the rows; a vertical cut runs along the entire gridline between two of the columns. For efficiency's sake, one chef will make exactly $\\mathbf{H}$ different horizontal cuts and another chef will make exactly $\\mathbf{V}$ different vertical cuts. This will conveniently create one piece for each of the $(\\mathbf{H}+1) \\times(\\mathbf{V}+1)$ diners. The pieces will not necessarily all be of equal sizes, but that is fine; market research has shown that the diners do not care about that.\n\nWhat the diners do care about is the number of chocolate chips they get, so each piece must have exactly the same number of chocolate chips. Can you determine whether the chefs can accomplish this goal using the given numbers of horizontal and vertical cuts?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$; $\\mathbf{T}$ test cases follow. Each begins with one line containing four integers $\\mathbf{R}, \\mathbf{C}, \\mathbf{H}$, and $\\mathbf{V}$ : the number of rows and columns in the waffle, and the exact numbers of horizontal and vertical cuts that the chefs must make. Then, there are $\\mathbf{R}$ more lines of $\\mathbf{C}$ characters each; the $j$-th character in the $i$-th of these lines represents the cell in the $i$-th row and the $j$-th column of the waffle. Each character is either `@`, which means the cell has a chocolate chip, or `.`, which means the cell is empty.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is possible if the chefs can accomplish the goal as described above, or IMPOSSIBLE if they cannot.", "hint": "**Sample Explanation**\n\nNote that the last two sample cases would not appear in test set 1.\n\nIn Sample Case #1, one possible strategy is to make the horizontal cut between the second and third rows from the top, and make the vertical cut between the fourth and fifth columns from the left. That creates the following pieces, each of which has exactly two chocolate chips:\n\n```\n.@@. .@\n.... .@\n\n@.@. @@\n```\n\nIn Sample Case #2, no matter where you make the horizontal cut and the vertical cut, you will create pieces with unequal numbers of chocolate chips, so the case is impossible.\n\nIn Sample Case #3, there are no chocolate chips in the waffle. Any cutting strategy creates pieces which have the same number of chocolate chips (zero), so the diners are happy... but maybe not as happy as they would have been if they had gotten chocolate chips!\n\nIn Sample Case #4, just as in Sample Case #2, you cannot succeed regardless of where you make your horizontal cut and your vertical cut.\n\nIn Sample Case #5, the chefs can make the only two possible horizontal cuts, and make the two vertical cuts to the right of the first and third columns.\n\nAlthough Sample Case #6 would be possible for other numbers of horizontal and vertical cuts, remember that you must use exactly H horizontal cuts and exactly V vertical cuts. No matter where you make your one horizontal cut and two vertical cuts, you cannot succeed.\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n\n**Test set 1 (9 Pts, Visible)**\n\n- $2 \\leqslant \\mathbf{R} \\leqslant 10$.\n- $2 \\leqslant \\mathbf{C} \\leqslant 10$.\n- $\\mathbf{H}=1$.\n- $\\mathbf{V}=1$.\n\n**Test set 2 (16 Pts, Hidden)**\n\n- $2 \\leqslant \\mathbf{R} \\leqslant 100$.\n- $2 \\leqslant \\mathbf{C} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{H}<\\mathbf{R}$.\n- $1 \\leqslant \\mathbf{V}<\\mathbf{C}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #1A] Waffle Choppers", "background": "", "description": "The diners at the Infinite House of Pancakes have gotten tired of circular pancakes, so the chefs are about to offer a new menu option: waffles! As a publicity stunt, they have made one large waffle that is a grid of square cells with $\\mathrm{R}$ rows and $\\mathrm{C}$ columns. Each cell of the waffle is either empty, or contains a single chocolate chip.\n\nNow it is time for the chefs to divide up the waffle among their hungry diners. A horizontal cut runs along the entire gridline between two of the rows; a vertical cut runs along the entire gridline between two of the columns. For efficiency's sake, one chef will make exactly $\\mathbf{H}$ different horizontal cuts and another chef will make exactly $\\mathbf{V}$ different vertical cuts. This will conveniently create one piece for each of the $(\\mathbf{H}+1) \\times(\\mathbf{V}+1)$ diners. The pieces will not necessarily all be of equal sizes, but that is fine; market research has shown that the diners do not care about that.\n\nWhat the diners do care about is the number of chocolate chips they get, so each piece must have exactly the same number of chocolate chips. Can you determine whether the chefs can accomplish this goal using the given numbers of horizontal and vertical cuts?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$; $\\mathbf{T}$ test cases follow. Each begins with one line containing four integers $\\mathbf{R}, \\mathbf{C}, \\mathbf{H}$, and $\\mathbf{V}$ : the number of rows and columns in the waffle, and the exact numbers of horizontal and vertical cuts that the chefs must make. Then, there are $\\mathbf{R}$ more lines of $\\mathbf{C}$ characters each; the $j$-th character in the $i$-th of these lines represents the cell in the $i$-th row and the $j$-th column of the waffle. Each character is either `@`, which means the cell has a chocolate chip, or `.`, which means the cell is empty.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is possible if the chefs can accomplish the goal as described above, or IMPOSSIBLE if they cannot.", "hint": "**Sample Explanation**\n\nNote that the last two sample cases would not appear in test set 1.\n\nIn Sample Case #1, one possible strategy is to make the horizontal cut between the second and third rows from the top, and make the vertical cut between the fourth and fifth columns from the left. That creates the following pieces, each of which has exactly two chocolate chips:\n\n```\n.@@. .@\n.... .@\n\n@.@. @@\n```\n\nIn Sample Case #2, no matter where you make the horizontal cut and the vertical cut, you will create pieces with unequal numbers of chocolate chips, so the case is impossible.\n\nIn Sample Case #3, there are no chocolate chips in the waffle. Any cutting strategy creates pieces which have the same number of chocolate chips (zero), so the diners are happy... but maybe not as happy as they would have been if they had gotten chocolate chips!\n\nIn Sample Case #4, just as in Sample Case #2, you cannot succeed regardless of where you make your horizontal cut and your vertical cut.\n\nIn Sample Case #5, the chefs can make the only two possible horizontal cuts, and make the two vertical cuts to the right of the first and third columns.\n\nAlthough Sample Case #6 would be possible for other numbers of horizontal and vertical cuts, remember that you must use exactly H horizontal cuts and exactly V vertical cuts. No matter where you make your one horizontal cut and two vertical cuts, you cannot succeed.\n\n**Limits**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$.\n\n**Test set 1 (9 Pts, Visible)**\n\n- $2 \\leqslant \\mathbf{R} \\leqslant 10$.\n- $2 \\leqslant \\mathbf{C} \\leqslant 10$.\n- $\\mathbf{H}=1$.\n- $\\mathbf{V}=1$.\n\n**Test set 2 (16 Pts, Hidden)**\n\n- $2 \\leqslant \\mathbf{R} \\leqslant 100$.\n- $2 \\leqslant \\mathbf{C} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{H}<\\mathbf{R}$.\n- $1 \\leqslant \\mathbf{V}<\\mathbf{C}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #1A] Waffle Choppers", "background": null, "description": "无限煎饼屋的食客们已经厌倦了圆形煎饼，因此厨师们即将推出新的菜单选项：华夫饼！作为宣传噱头，他们制作了一个巨大的华夫饼，这个华夫饼是一个由 $\\mathrm{R}$ 行 $\\mathrm{C}$ 列方格组成的网格。每个格子要么是空的，要么包含一颗巧克力豆。\n\n现在，厨师们要把华夫饼分给饥饿的食客们。一条水平切割沿着两行之间的整条网格线切开；一条垂直切割沿着两列之间的整条网格线切开。为了效率，一位厨师会恰好进行 $\\mathbf{H}$ 次不同的水平切割，另一位厨师会恰好进行 $\\mathbf{V}$ 次不同的垂直切割。这样就会方便地为每位食客分出 $(\\mathbf{H}+1) \\times (\\mathbf{V}+1)$ 块华夫饼。每块的大小不一定相等，但这没关系；市场调研显示食客们并不在意这一点。\n\n食客们真正关心的是他们能分到多少巧克力豆，因此每一块中必须恰好有相同数量的巧克力豆。你能判断厨师们能否用给定数量的水平和垂直切割实现这个目标吗？", "inputFormat": "输入的第一行包含测试用例数 $\\mathbf{T}$；接下来有 $\\mathbf{T}$ 组测试数据。每组测试数据的第一行包含四个整数 $\\mathbf{R}, \\mathbf{C}, \\mathbf{H}, \\mathbf{V}$，分别表示华夫饼的行数、列数，以及厨师们必须进行的水平和垂直切割次数。接下来有 $\\mathbf{R}$ 行，每行有 $\\mathbf{C}$ 个字符；第 $i$ 行第 $j$ 个字符表示华夫饼第 $i$ 行第 $j$ 列的格子。每个字符要么是 `@`（表示该格子有一颗巧克力豆），要么是 `.`（表示该格子为空）。", "outputFormat": "对于每组测试数据，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 为 `POSSIBLE`（如果厨师们能实现目标）或 `IMPOSSIBLE`（如果不能）。", "hint": "**样例解释**\n\n注意，最后两个样例不会出现在测试集 1 中。\n\n在样例 1 中，一种可行的切割方式是在从上往下数的第二行和第三行之间进行水平切割，在从左往右数的第四列和第五列之间进行垂直切割。这样会得到如下的分块，每块恰好有两颗巧克力豆：\n\n```\n.@@. .@\n.... .@\n\n@.@. @@\n```\n\n在样例 2 中，无论如何切割，都会得到包含不同数量巧克力豆的分块，因此该情况不可能实现。\n\n在样例 3 中，华夫饼中没有巧克力豆。任何切割方式都会得到每块都含有相同数量巧克力豆（零颗），因此食客们会满意……不过也许没有巧克力豆他们就没那么开心了！\n\n在样例 4 中，和样例 2 一样，无论如何切割都无法实现目标。\n\n在样例 5 中，厨师们可以进行仅有的两次水平切割，并在第一列和第三列右侧进行两次垂直切割。\n\n虽然样例 6 在其他水平和垂直切割次数下可能可行，但请记住你必须恰好使用 $H$ 次水平切割和 $V$ 次垂直切割。无论如何进行一次水平切割和两次垂直切割，都无法实现目标。\n\n**数据范围**\n\n- $1 \\leqslant \\mathrm{T} \\leqslant 100$。\n\n**测试集 1（9 分，公开）**\n\n- $2 \\leqslant \\mathbf{R} \\leqslant 10$。\n- $2 \\leqslant \\mathbf{C} \\leqslant 10$。\n- $\\mathbf{H}=1$。\n- $\\mathbf{V}=1$。\n\n**测试集 2（16 分，隐藏）**\n\n- $2 \\leqslant \\mathbf{R} \\leqslant 100$。\n- $2 \\leqslant \\mathbf{C} \\leqslant 100$。\n- $1 \\leqslant \\mathbf{H}<\\mathbf{R}$。\n- $1 \\leqslant \\mathbf{V}<\\mathbf{C}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13137", "type": "P", "difficulty": 4, "samples": [["3\n2 2 2\n1 2 3\n1 1 2\n2 2 2\n1 2 3\n2 1 2\n3 4 5\n2 3 3\n2 1 5\n2 4 2\n2 2 4\n2 5 1", "Case #1: 5\nCase #2: 4\nCase #3: 7"]], "limits": {"time": [15000, 15000], "memory": [1048576, 1048576]}, "tags": ["2018", "二分", "Google Code Jam"], "title": "[GCJ 2018 #1A] Bit Party", "background": "", "description": "These days, robots can drive cars, but can they throw a good party? The Code Jam team's research into this topic is still at an early stage. We just deployed $\\mathbf{R}$ robot shoppers to our local supermarket to buy party supplies for our World Finals in Toronto, but their first-order model of a Canadian party was very simple: they just bought $\\mathbf{B}$ \"bits\" (a bit being a small donut-like treat found in the area). We will work on improving their AI later, but for now, we want to help them purchase all of those bits as quickly as possible.\n\nThe supermarket has $\\mathbf{C}$ cashiers who can scan customers' purchases. The $i$-th cashier will:\n- accept a maximum of $\\mathbf{M}_{\\mathbf{i}}$ items per customer\n- take $\\mathbf{S}_{\\mathbf{i}}$ seconds to scan each item\n- spend a further $\\mathbf{P}_{\\mathbf{i}}$ seconds handling payment and packaging up the bits.\n\nThat is, a customer who brings $\\mathrm{N}$ bits to the $i$-th cashier (where $\\mathrm{N}$ must be less than or equal to $\\mathbf{M}_{\\mathbf{i}}$ ) will spend a total of $\\mathbf{S}_{\\mathbf{i}} \\times \\mathrm{N}+\\mathbf{P}_{\\mathbf{i}}$ seconds interacting with that cashier.\n\nBefore the robots interact with any cashiers, you will distribute the bits among the robots however you want. (Bits must remain intact; you cannot break them up into fractional pieces!) Any robot that gets no bits will not get to interact with a cashier, and will go away disappointed.\n\nThen, for each robot with at least one bit, you will choose a different single cashier. (Two robots cannot use the same cashier, and a robot cannot use more than one cashier.) The robots all start interacting with their cashiers at time 0 . Note that once a robot finishes interacting with its cashier, it cannot be given more bits and cannot interact with other cashiers.\n\nIf you help the robots make optimal choices, what is the earliest time at which all of the robots can finish interacting with their cashiers?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with three integers $\\mathbf{R}, \\mathbf{B}$, and $\\mathbf{C}$ : the numbers of robot shoppers, bits, and cashiers. Then, there are $\\mathbf{C}$ more lines. The $i$-th of these represents the $i$-th cashier, and it has three integers $\\mathbf{M}_{\\mathbf{i}}, \\mathbf{S}_{\\mathbf{i}}$, and $\\mathbf{P}_{\\mathbf{i}}$ : the maximum number of bits, scan time per bit (in seconds), and payment/packaging time (in seconds) for that cashier, as described above.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the earliest time (in seconds) at which all robots can finish interacting with their cashiers.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are two robots, two bits, and two cashiers, and each cashier can only handle one item. So, you must give one bit to each robot. Cashier 1 takes 5 seconds, and Cashier 2 takes 3 seconds, so the time required is 5 seconds.\n\nSample Case #2 is similar to the previous case, except that now Cashier 2 can handle up to 2 items. So, it is best to give all the bits to one robot and have that robot use Cashier 2. This takes 1 second per item plus 2 seconds $=4$ seconds.\n\nIn Sample Case #3, the optimal strategy is to send one robot with 2 bits to cashier 2, and two robots with 1 bit each to any of the other cashiers.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{M}_{\\mathbf{i}} \\leqslant 10^{9}$, for all $i$.\n- $1 \\leqslant \\mathbf{S}_{\\mathbf{i}} \\leqslant 10^{9}$, for all $i$.\n- $1 \\leqslant \\mathbf{P}_{\\mathbf{i}} \\leqslant 10^{9}$, for all $i$.\n- The sum of the $\\mathbf{R}$ largest values of $\\mathbf{M}_{\\mathbf{i}} \\geqslant \\mathbf{B}$. (It is possible for at least one subset of $\\mathbf{R}$ cashiers to handle all of the bits.)\n\n**Test set 1 (11 Pts, Visible)**\n\n- $1 \\leqslant \\mathbf{R} \\leqslant \\mathbf{C} \\leqslant 5$.\n- $1 \\leqslant \\mathbf{B} \\leqslant 20$.\n\n**Test set 2 (21 Pts, Hidden)**\n\n- $1 \\leqslant \\mathbf{R} \\leqslant \\mathbf{C} \\leqslant 1000$.\n- $1 \\leqslant \\mathbf{B} \\leqslant 10^{9}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #1A] Bit Party", "background": "", "description": "These days, robots can drive cars, but can they throw a good party? The Code Jam team's research into this topic is still at an early stage. We just deployed $\\mathbf{R}$ robot shoppers to our local supermarket to buy party supplies for our World Finals in Toronto, but their first-order model of a Canadian party was very simple: they just bought $\\mathbf{B}$ \"bits\" (a bit being a small donut-like treat found in the area). We will work on improving their AI later, but for now, we want to help them purchase all of those bits as quickly as possible.\n\nThe supermarket has $\\mathbf{C}$ cashiers who can scan customers' purchases. The $i$-th cashier will:\n- accept a maximum of $\\mathbf{M}_{\\mathbf{i}}$ items per customer\n- take $\\mathbf{S}_{\\mathbf{i}}$ seconds to scan each item\n- spend a further $\\mathbf{P}_{\\mathbf{i}}$ seconds handling payment and packaging up the bits.\n\nThat is, a customer who brings $\\mathrm{N}$ bits to the $i$-th cashier (where $\\mathrm{N}$ must be less than or equal to $\\mathbf{M}_{\\mathbf{i}}$ ) will spend a total of $\\mathbf{S}_{\\mathbf{i}} \\times \\mathrm{N}+\\mathbf{P}_{\\mathbf{i}}$ seconds interacting with that cashier.\n\nBefore the robots interact with any cashiers, you will distribute the bits among the robots however you want. (Bits must remain intact; you cannot break them up into fractional pieces!) Any robot that gets no bits will not get to interact with a cashier, and will go away disappointed.\n\nThen, for each robot with at least one bit, you will choose a different single cashier. (Two robots cannot use the same cashier, and a robot cannot use more than one cashier.) The robots all start interacting with their cashiers at time 0 . Note that once a robot finishes interacting with its cashier, it cannot be given more bits and cannot interact with other cashiers.\n\nIf you help the robots make optimal choices, what is the earliest time at which all of the robots can finish interacting with their cashiers?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with three integers $\\mathbf{R}, \\mathbf{B}$, and $\\mathbf{C}$ : the numbers of robot shoppers, bits, and cashiers. Then, there are $\\mathbf{C}$ more lines. The $i$-th of these represents the $i$-th cashier, and it has three integers $\\mathbf{M}_{\\mathbf{i}}, \\mathbf{S}_{\\mathbf{i}}$, and $\\mathbf{P}_{\\mathbf{i}}$ : the maximum number of bits, scan time per bit (in seconds), and payment/packaging time (in seconds) for that cashier, as described above.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the earliest time (in seconds) at which all robots can finish interacting with their cashiers.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are two robots, two bits, and two cashiers, and each cashier can only handle one item. So, you must give one bit to each robot. Cashier 1 takes 5 seconds, and Cashier 2 takes 3 seconds, so the time required is 5 seconds.\n\nSample Case #2 is similar to the previous case, except that now Cashier 2 can handle up to 2 items. So, it is best to give all the bits to one robot and have that robot use Cashier 2. This takes 1 second per item plus 2 seconds $=4$ seconds.\n\nIn Sample Case #3, the optimal strategy is to send one robot with 2 bits to cashier 2, and two robots with 1 bit each to any of the other cashiers.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{M}_{\\mathbf{i}} \\leqslant 10^{9}$, for all $i$.\n- $1 \\leqslant \\mathbf{S}_{\\mathbf{i}} \\leqslant 10^{9}$, for all $i$.\n- $1 \\leqslant \\mathbf{P}_{\\mathbf{i}} \\leqslant 10^{9}$, for all $i$.\n- The sum of the $\\mathbf{R}$ largest values of $\\mathbf{M}_{\\mathbf{i}} \\geqslant \\mathbf{B}$. (It is possible for at least one subset of $\\mathbf{R}$ cashiers to handle all of the bits.)\n\n**Test set 1 (11 Pts, Visible)**\n\n- $1 \\leqslant \\mathbf{R} \\leqslant \\mathbf{C} \\leqslant 5$.\n- $1 \\leqslant \\mathbf{B} \\leqslant 20$.\n\n**Test set 2 (21 Pts, Hidden)**\n\n- $1 \\leqslant \\mathbf{R} \\leqslant \\mathbf{C} \\leqslant 1000$.\n- $1 \\leqslant \\mathbf{B} \\leqslant 10^{9}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #1A] Bit Party", "background": null, "description": "如今，机器人已经能够驾驶汽车，但它们能举办一场精彩的派对吗？Code Jam 团队对此的研究还处于初级阶段。我们刚刚派遣了 $\\mathbf{R}$ 个机器人购物者到本地超市，为我们在多伦多举办的世界总决赛采购派对用品，但它们对加拿大派对的第一印象非常简单：它们只买了 $\\mathbf{B}$ 个“bit”（bit 是当地一种小型甜甜圈状点心）。我们以后会继续改进它们的人工智能，但现在，我们希望帮助它们尽快购买完所有的 bit。\n\n超市有 $\\mathbf{C}$ 个收银员可以为顾客结账。第 $i$ 个收银员有如下特点：\n- 每位顾客最多接受 $\\mathbf{M}_{\\mathbf{i}}$ 个商品\n- 扫描每个商品需要 $\\mathbf{S}_{\\mathbf{i}}$ 秒\n- 还需要额外花费 $\\mathbf{P}_{\\mathbf{i}}$ 秒用于收款和打包 bit\n\n也就是说，一个顾客如果带着 $\\mathrm{N}$ 个 bit 找到第 $i$ 个收银员（其中 $\\mathrm{N}$ 必须不超过 $\\mathbf{M}_{\\mathbf{i}}$），则与该收银员的总交互时间为 $\\mathbf{S}_{\\mathbf{i}} \\times \\mathrm{N}+\\mathbf{P}_{\\mathbf{i}}$ 秒。\n\n在机器人和收银员交互之前，你可以任意分配 bit 给机器人（bit 必须保持完整，不能拆分成小数部分！）。任何没有分到 bit 的机器人将无法与收银员交互，并会失望地离开。\n\n接下来，对于每个至少分到一个 bit 的机器人，你需要为其选择一个不同的收银员。（两个机器人不能使用同一个收银员，一个机器人也不能使用多个收银员。）所有机器人会在时间 0 同时开始与各自的收银员交互。注意，一旦某个机器人完成了与收银员的交互，它不能再获得更多 bit，也不能与其他收银员交互。\n\n如果你帮助机器人做出最优选择，所有机器人最早能在什么时候全部完成与收银员的交互？", "inputFormat": "输入的第一行包含一个整数 $\\mathbf{T}$，表示测试用例的数量。接下来有 $\\mathbf{T}$ 个测试用例。每个测试用例的第一行包含三个整数 $\\mathbf{R}, \\mathbf{B}, \\mathbf{C}$，分别表示机器人数量、bit 数量和收银员数量。接下来的 $\\mathbf{C}$ 行，每行包含三个整数 $\\mathbf{M}_{\\mathbf{i}}, \\mathbf{S}_{\\mathbf{i}}, \\mathbf{P}_{\\mathbf{i}}$，分别表示第 $i$ 个收银员能处理的最大 bit 数、每个 bit 的扫描时间（秒）以及收款和打包时间（秒），如上所述。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是所有机器人最早能完成与收银员交互的时间（单位为秒）。", "hint": "**样例解释**\n\n在样例 1 中，有两个机器人、两个 bit 和两个收银员，每个收银员最多只能处理一个商品。因此，必须给每个机器人分配一个 bit。收银员 1 需要 5 秒，收银员 2 需要 3 秒，所以所需时间为 5 秒。\n\n样例 2 与前一个类似，但现在收银员 2 最多可以处理 2 个商品。因此，最优做法是将所有 bit 都分配给一个机器人，并让该机器人使用收银员 2。这样总共需要 $1$ 秒每个商品加上 $2$ 秒，共 $4$ 秒。\n\n在样例 3 中，最优策略是让一个机器人带着 2 个 bit 去找收银员 2，另外两个机器人各带 1 个 bit 去找其他任意收银员。\n\n**数据范围**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- 对所有 $i$，$1 \\leqslant \\mathbf{M}_{\\mathbf{i}} \\leqslant 10^{9}$。\n- 对所有 $i$，$1 \\leqslant \\mathbf{S}_{\\mathbf{i}} \\leqslant 10^{9}$。\n- 对所有 $i$，$1 \\leqslant \\mathbf{P}_{\\mathbf{i}} \\leqslant 10^{9}$。\n- $\\mathbf{M}_{\\mathbf{i}}$ 中最大的 $\\mathbf{R}$ 个数之和 $\\geqslant \\mathbf{B}$。（即至少存在一组 $\\mathbf{R}$ 个收银员可以处理所有 bit。）\n\n**测试点 1（11 分，公开）**\n\n- $1 \\leqslant \\mathbf{R} \\leqslant \\mathbf{C} \\leqslant 5$。\n- $1 \\leqslant \\mathbf{B} \\leqslant 20$。\n\n**测试点 2（21 分，隐藏）**\n\n- $1 \\leqslant \\mathbf{R} \\leqslant \\mathbf{C} \\leqslant 1000$。\n- $1 \\leqslant \\mathbf{B} \\leqslant 10^{9}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13138", "type": "P", "difficulty": 4, "samples": [["4\n1 7\n1 1\n2 920\n50 120\n50 120\n1 32\n7 4\n3 240\n10 20\n20 30\n30 10", "Case #1: 6.828427\nCase #2: 920.000000\nCase #3: 32.000000\nCase #4: 240.000000"]], "limits": {"time": [15000, 15000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2018", "Special Judge", "Google Code Jam"], "title": "[GCJ 2018 #1A] Edgy Baking", "background": "", "description": "The baker Mr. Maillard has rolled out some cookie dough and cut it up to create $\\mathbf{N}$ cookies, each of which is a rectangle. He was just about to put them in the oven when he remembered that the crispy, caramelized edges of cookies taste particularly delicious. Specifically, he thinks he would be happiest if the sum of the perimeters of all the cookies were as close as possible to $\\mathbf{P}$ millimeters (mm), without going over. (If the batch of cookies is too edgy, it might burn!)\n\nFor each cookie, Mr. Maillard can decide whether to leave it as is, or make a single straight cut to separate it into two (not necessarily rectangular) halves with equal area. (Note that such a cut must necessarily go through the center of the cookie.) The two new cookies created in this way cannot themselves be cut again.\n\nIf Mr. Maillard makes optimal decisions, what is the closest he can come to $\\mathbf{P}$ without exceeding it?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with two integers $\\mathbf{N}$ and $\\mathbf{P}$ : the number of cookies, and the desired perimeter sum (in mm), respectively. Then, $\\mathbf{N}$ lines follow. The $i$-th of these has two integers $\\mathbf{W}_{\\mathbf{i}}$ and $\\mathbf{H}_{\\mathbf{i}}$ : the width and height (both in mm) of the $i$-th cookie.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a real number: the largest possible sum (in mm) of the perimeters of all cookies (after Mr. Maillard is done cutting) that does not exceed $\\mathbf{P}$. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in test set 1.\n\nIn Sample Case #1, there is only one cookie, and it is a square with side length 1. Mr. Maillard can cut from one corner to a diagonally opposite corner, which creates two right triangles, each of which has side lengths 1, 1, and $\\sqrt 2$. Then the perimeter sum is $4+2 \\times \\sqrt 2$; this is smaller than $\\mathbf{P}=7$, but it is not possible to get any closer.\n\nIn Sample Case #2, Mr. Maillard can cut the first cookie along its longer axis to create two new $25 \\times 120$ rectangles, and leave the second cookie alone. The total perimeter is then $580+340=920$, which is exactly $\\mathbf{P}$.\n\nIn Sample Case #3, Mr. Maillard can cut the cookie to make two trapezoids, each of which has side lengths of $2, 4, 5$, and $5$. Then the new perimeter sum is $32$, which is exactly $\\mathbf{P}$.\n\nIn Sample Case #4, the initial perimeter sum is exactly $\\mathbf{P}$, so Mr. Maillard should not make any cuts.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{N} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{W}_{\\mathbf{i}} \\leqslant 250$, for all $i$.\n- $1 \\leqslant \\mathbf{H}_{\\mathbf{i}} \\leqslant 250$, for all $i$.\n- $\\mathbf{P} \\geqslant 2 \\times$ the sum of $\\left(\\mathbf{W}_{\\mathbf{i}}+\\mathbf{H}_{\\mathbf{i}}\\right)$ over all $i$. ( $\\mathbf{P}$ is at least as large as the sum of the perimeters of all cookies before any cuts are made.)\n- $\\mathbf{P} \\leqslant 10^{8}$.\n\n**Test set 1 (14 Pts, Visible)**\n\n- $\\mathbf{W}_{\\mathbf{i}}=\\mathbf{W}_{\\mathbf{j}}$, for all $i$ and $j$.\n- $\\mathbf{H}_{\\mathbf{i}}=\\mathbf{H}_{\\mathbf{j}}$, for all $i$ and $j$.\n- (All of the provided cookies have the same dimensions.)\n\n**Test set 2 (29 Pts, Hidden)**\n\n- No additional limits beyond the general ones. (In particular, the provided cookies do not all necessarily have the same dimensions.)", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #1A] Edgy Baking", "background": "", "description": "The baker Mr. Maillard has rolled out some cookie dough and cut it up to create $\\mathbf{N}$ cookies, each of which is a rectangle. He was just about to put them in the oven when he remembered that the crispy, caramelized edges of cookies taste particularly delicious. Specifically, he thinks he would be happiest if the sum of the perimeters of all the cookies were as close as possible to $\\mathbf{P}$ millimeters (mm), without going over. (If the batch of cookies is too edgy, it might burn!)\n\nFor each cookie, Mr. Maillard can decide whether to leave it as is, or make a single straight cut to separate it into two (not necessarily rectangular) halves with equal area. (Note that such a cut must necessarily go through the center of the cookie.) The two new cookies created in this way cannot themselves be cut again.\n\nIf Mr. Maillard makes optimal decisions, what is the closest he can come to $\\mathbf{P}$ without exceeding it?\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with two integers $\\mathbf{N}$ and $\\mathbf{P}$ : the number of cookies, and the desired perimeter sum (in mm), respectively. Then, $\\mathbf{N}$ lines follow. The $i$-th of these has two integers $\\mathbf{W}_{\\mathbf{i}}$ and $\\mathbf{H}_{\\mathbf{i}}$ : the width and height (both in mm) of the $i$-th cookie.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a real number: the largest possible sum (in mm) of the perimeters of all cookies (after Mr. Maillard is done cutting) that does not exceed $\\mathbf{P}$. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in test set 1.\n\nIn Sample Case #1, there is only one cookie, and it is a square with side length 1. Mr. Maillard can cut from one corner to a diagonally opposite corner, which creates two right triangles, each of which has side lengths 1, 1, and $\\sqrt 2$. Then the perimeter sum is $4+2 \\times \\sqrt 2$; this is smaller than $\\mathbf{P}=7$, but it is not possible to get any closer.\n\nIn Sample Case #2, Mr. Maillard can cut the first cookie along its longer axis to create two new $25 \\times 120$ rectangles, and leave the second cookie alone. The total perimeter is then $580+340=920$, which is exactly $\\mathbf{P}$.\n\nIn Sample Case #3, Mr. Maillard can cut the cookie to make two trapezoids, each of which has side lengths of $2, 4, 5$, and $5$. Then the new perimeter sum is $32$, which is exactly $\\mathbf{P}$.\n\nIn Sample Case #4, the initial perimeter sum is exactly $\\mathbf{P}$, so Mr. Maillard should not make any cuts.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{N} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{W}_{\\mathbf{i}} \\leqslant 250$, for all $i$.\n- $1 \\leqslant \\mathbf{H}_{\\mathbf{i}} \\leqslant 250$, for all $i$.\n- $\\mathbf{P} \\geqslant 2 \\times$ the sum of $\\left(\\mathbf{W}_{\\mathbf{i}}+\\mathbf{H}_{\\mathbf{i}}\\right)$ over all $i$. ( $\\mathbf{P}$ is at least as large as the sum of the perimeters of all cookies before any cuts are made.)\n- $\\mathbf{P} \\leqslant 10^{8}$.\n\n**Test set 1 (14 Pts, Visible)**\n\n- $\\mathbf{W}_{\\mathbf{i}}=\\mathbf{W}_{\\mathbf{j}}$, for all $i$ and $j$.\n- $\\mathbf{H}_{\\mathbf{i}}=\\mathbf{H}_{\\mathbf{j}}$, for all $i$ and $j$.\n- (All of the provided cookies have the same dimensions.)\n\n**Test set 2 (29 Pts, Hidden)**\n\n- No additional limits beyond the general ones. (In particular, the provided cookies do not all necessarily have the same dimensions.)", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #1A] Edgy Baking", "background": null, "description": "面包师 Mr. Maillard 已经将一些饼干面团擀平并切割，制作出了 $\\mathbf{N}$ 块饼干，每块都是一个矩形。他正准备把它们放进烤箱时，突然想起饼干酥脆、焦糖化的边缘特别美味。具体来说，他认为如果所有饼干的周长之和尽可能接近 $\\mathbf{P}$ 毫米（mm），且不超过 $\\mathbf{P}$，他会最开心。（如果饼干的边太多，可能会烤焦！）\n\n对于每块饼干，Mr. Maillard 可以选择保持原样，或者沿着一条直线将其一分为二（不一定是矩形），使得两部分面积相等。（注意，这样的切割必然经过饼干的中心。）通过这种方式切割后产生的两块新饼干不能再次切割。\n\n如果 Mr. Maillard 做出最优决策，他能得到不超过 $\\mathbf{P}$ 的最大周长和是多少？", "inputFormat": "输入的第一行包含测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组测试数据第一行为两个整数 $\\mathbf{N}$ 和 $\\mathbf{P}$，分别表示饼干的数量和期望的周长总和（单位：毫米）。接下来的 $\\mathbf{N}$ 行，每行包含两个整数 $\\mathbf{W}_{\\mathbf{i}}$ 和 $\\mathbf{H}_{\\mathbf{i}}$，分别表示第 $i$ 块饼干的宽和高（单位：毫米）。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是所有饼干（切割后）的最大可能周长和（单位：毫米），且不超过 $\\mathbf{P}$。如果你的答案与正确答案的绝对误差或相对误差不超过 $10^{-6}$，则视为正确。关于误差的解释及可接受的实数格式，请参见 FAQ。", "hint": "**样例解释**\n\n注意，最后一个样例不会出现在测试集 1 中。\n\n样例 1 中，只有一块边长为 1 的正方形饼干。Mr. Maillard 可以从一个角到对角线上的另一个角切割，得到两个直角三角形，每个三角形的边长为 1、1 和 $\\sqrt 2$。此时周长和为 $4+2 \\times \\sqrt 2$，小于 $\\mathbf{P}=7$，但无法更接近。\n\n样例 2 中，Mr. Maillard 可以沿着第一块饼干的长边切割，得到两个 $25 \\times 120$ 的矩形，第二块保持不变。总周长为 $580+340=920$，正好等于 $\\mathbf{P}$。\n\n样例 3 中，Mr. Maillard 可以将饼干切割成两个梯形，每个梯形的边长为 $2, 4, 5, 5$。此时新的周长和为 $32$，正好等于 $\\mathbf{P}$。\n\n样例 4 中，初始周长和正好等于 $\\mathbf{P}$，因此不需要切割。\n\n**数据范围**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$。\n- $1 \\leqslant \\mathbf{N} \\leqslant 100$。\n- $1 \\leqslant \\mathbf{W}_{\\mathbf{i}} \\leqslant 250$，对于所有 $i$。\n- $1 \\leqslant \\mathbf{H}_{\\mathbf{i}} \\leqslant 250$，对于所有 $i$。\n- $\\mathbf{P} \\geqslant 2 \\times$ 所有 $\\left(\\mathbf{W}_{\\mathbf{i}}+\\mathbf{H}_{\\mathbf{i}}\\right)$ 的和。（$\\mathbf{P}$ 至少等于所有饼干未切割时的周长和。）\n- $\\mathbf{P} \\leqslant 10^{8}$。\n\n**测试集 1（14 分，可见）**\n\n- $\\mathbf{W}_{\\mathbf{i}}=\\mathbf{W}_{\\mathbf{j}}$，对于所有 $i$ 和 $j$。\n- $\\mathbf{H}_{\\mathbf{i}}=\\mathbf{H}_{\\mathbf{j}}$，对于所有 $i$ 和 $j$。\n- （所有给定的饼干尺寸都相同。）\n\n**测试集 2（29 分，隐藏）**\n\n- 除一般限制外无其他限制。（特别地，给定的饼干尺寸不一定都相同。）\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13139", "type": "P", "difficulty": 4, "samples": [["4\n3 2\n1 1\n10 3\n1 3 2\n6 2\n3 1\n9 8\n1 1 1 1 1 1 1 1", "Case #1: 100\nCase #2: 100\nCase #3: 101\nCase #4: 99"]], "limits": {"time": [10000, 10000, 10000], "memory": [1048576, 1048576, 1048576]}, "tags": ["贪心", "2018", "Google Code Jam"], "title": "[GCJ 2018 #1B] Rounding Error", "background": "", "description": "To finally settle the age-old question of which programming language is the best, you are asking a total of $\\mathbf{N}$ people to tell you their favorite language. This is an open-ended question: each person is free to name any language, and there are infinitely many languages in the world.\n\nSome people have already responded, and you have gathered this information as a list of counts. For example, 1 2 means that you have asked 3 people so far, and one picked a particular language, and the other two picked some other language.\n\nYou plan to publish the results in a table listing each language and the percentage of people who picked it. You will round each percentage to the nearest integer, rounding up any percentage with a decimal part equal to or greater than 0.5. So, for example, $12.5 \\%$ would round up to $13 \\%, 99.5 \\%$ would round up to $100 \\%$, and $12.4999 \\%$ would round down to $12 \\%$.\n\nIn surveys like this, sometimes the rounded percentages do not add up to exactly 100. After you are done surveying the remaining people, what is the largest value that the rounded percentages could possibly add up to?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow; each consists of two lines. The first line consists of two integers $\\mathbf{N}$ and $\\mathbf{L}$ : the total number of people in the survey, and the total number of different languages represented among the people who have already responded. The second line consists of $\\mathbf{L}$ integers $\\mathbf{C}_{\\mathbf{i}}$; the $i$-th of these is the number of people who said that the $i$-th of the represented languages was their favorite.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the largest value that the percentages could possibly add up to, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, two people have already responded, and they have chosen different languages. One person has not yet responded. If that person chooses a third language, then the rounded percentages will add up to $33+33+33=99$. However, if that person chooses one of the already-chosen languages, then the rounded percentages will add up to $67+33=100$. So 100 is the maximum possible sum.\n\nIn Sample Case #2, regardless of what the other four people choose, the percentages for the various languages will always be exact multiples of 10 that do not need to be rounded, and they will add up to exactly 100 .\n\nIn Sample Case #3, one optimal scenario is as follows: each of the remaining two people chooses an unchosen language, so the rounded percentages add up to $50+17+17+17=101$.\n\nIn Sample Case #4, whether or not the remaining person chooses an already-chosen language, the rounded percentages will add up to $99$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{L}<\\mathbf{N}$.\n- $1 \\leqslant \\mathbf{C}_{\\mathbf{i}}$, for all $i$.\n- The sum of all $\\mathbf{C}_{\\mathbf{i}}$ values $<\\mathbf{N}$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 25$.\n\n**Test set 2 (9 Pts, Visible)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 250$.\n\n**Test set 3 (11 Pts, Hidden)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^{5}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #1B] Rounding Error", "background": "", "description": "To finally settle the age-old question of which programming language is the best, you are asking a total of $\\mathbf{N}$ people to tell you their favorite language. This is an open-ended question: each person is free to name any language, and there are infinitely many languages in the world.\n\nSome people have already responded, and you have gathered this information as a list of counts. For example, 1 2 means that you have asked 3 people so far, and one picked a particular language, and the other two picked some other language.\n\nYou plan to publish the results in a table listing each language and the percentage of people who picked it. You will round each percentage to the nearest integer, rounding up any percentage with a decimal part equal to or greater than 0.5. So, for example, $12.5 \\%$ would round up to $13 \\%, 99.5 \\%$ would round up to $100 \\%$, and $12.4999 \\%$ would round down to $12 \\%$.\n\nIn surveys like this, sometimes the rounded percentages do not add up to exactly 100. After you are done surveying the remaining people, what is the largest value that the rounded percentages could possibly add up to?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow; each consists of two lines. The first line consists of two integers $\\mathbf{N}$ and $\\mathbf{L}$ : the total number of people in the survey, and the total number of different languages represented among the people who have already responded. The second line consists of $\\mathbf{L}$ integers $\\mathbf{C}_{\\mathbf{i}}$; the $i$-th of these is the number of people who said that the $i$-th of the represented languages was their favorite.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the largest value that the percentages could possibly add up to, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, two people have already responded, and they have chosen different languages. One person has not yet responded. If that person chooses a third language, then the rounded percentages will add up to $33+33+33=99$. However, if that person chooses one of the already-chosen languages, then the rounded percentages will add up to $67+33=100$. So 100 is the maximum possible sum.\n\nIn Sample Case #2, regardless of what the other four people choose, the percentages for the various languages will always be exact multiples of 10 that do not need to be rounded, and they will add up to exactly 100 .\n\nIn Sample Case #3, one optimal scenario is as follows: each of the remaining two people chooses an unchosen language, so the rounded percentages add up to $50+17+17+17=101$.\n\nIn Sample Case #4, whether or not the remaining person chooses an already-chosen language, the rounded percentages will add up to $99$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 100$.\n- $1 \\leqslant \\mathbf{L}<\\mathbf{N}$.\n- $1 \\leqslant \\mathbf{C}_{\\mathbf{i}}$, for all $i$.\n- The sum of all $\\mathbf{C}_{\\mathbf{i}}$ values $<\\mathbf{N}$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 25$.\n\n**Test set 2 (9 Pts, Visible)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 250$.\n\n**Test set 3 (11 Pts, Hidden)**\n\n- $2 \\leqslant \\mathbf{N} \\leqslant 10^{5}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #1B] Rounding Error", "background": null, "description": "为了最终解决“哪种编程语言最好”这一由来已久的问题，你打算询问总共 $N$ 个人，让他们告诉你自己最喜欢的语言。这是一个开放式问题：每个人都可以自由选择任何一种语言，世界上的语言数量是无限的。\n\n有些人已经作出了回应，你已经将这些信息整理成了一个计数列表。例如，1 2 表示你目前已经询问了 3 个人，其中一人选择了一种特定的语言，另外两人选择了另一种语言。\n\n你打算将结果以表格的形式公布，列出每种语言以及选择它的人所占的百分比。你会将每个百分比四舍五入到最接近的整数，如果小数部分大于等于 0.5，则向上取整。例如，$12.5\\%$ 会四舍五入为 $13\\%$，$99.5\\%$ 会四舍五入为 $100\\%$，$12.4999\\%$ 会四舍五入为 $12\\%$。\n\n在这种调查中，有时四舍五入后的百分比之和并不一定正好等于 100。请问，在你完成对剩余人员的调查后，四舍五入后的百分比之和最大可能是多少？", "inputFormat": "输入的第一行是测试用例的数量 $T$。接下来有 $T$ 组测试数据，每组包含两行。第一行包含两个整数 $N$ 和 $L$，分别表示调查的总人数，以及已经有回应的不同语言的数量。第二行包含 $L$ 个整数 $C_i$，第 $i$ 个数表示有 $C_i$ 个人选择了第 $i$ 种已出现的语言。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是四舍五入后的百分比之和的最大可能值。", "hint": "**样例解释**\n\n在样例 1 中，已有两人作答，且选择了不同的语言。还有一人未作答。如果这人选择第三种语言，则四舍五入后的百分比之和为 $33+33+33=99$。但如果这人选择了已出现的某种语言，则四舍五入后的百分比之和为 $67+33=100$。因此最大可能为 100。\n\n在样例 2 中，无论剩下的四人如何选择，各语言的百分比总是 10 的整数倍，无需四舍五入，总和始终为 100。\n\n在样例 3 中，一种最优情况是：剩下的两人各自选择一种未出现的语言，则四舍五入后的百分比之和为 $50+17+17+17=101$。\n\n在样例 4 中，无论剩下的一人选择已出现的语言与否，四舍五入后的百分比之和都为 99。\n\n**数据范围**\n\n- $1 \\leqslant T \\leqslant 100$。\n- $1 \\leqslant L < N$。\n- 对所有 $i$，$1 \\leqslant C_i$。\n- 所有 $C_i$ 之和 $< N$。\n\n**测试点 1（5 分，可见）**\n\n- $2 \\leqslant N \\leqslant 25$。\n\n**测试点 2（9 分，可见）**\n\n- $2 \\leqslant N \\leqslant 250$。\n\n**测试点 3（11 分，隐藏）**\n\n- $2 \\leqslant N \\leqslant 10^{5}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13140", "type": "P", "difficulty": 5, "samples": [["3\n1\n1 1 1\n5\n2 7 12\n6 3 11\n8 10 1\n11 11 12\n13 9 14\n5\n1 3 3\n2 2 2\n3 1 1\n4 2 2\n5 3 3", "Case #1: 1 1\nCase #2: 3 2\nCase #3: 5 1"]], "limits": {"time": [10000, 10000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2018", "双指针 two-pointer", "Google Code Jam"], "title": "[GCJ 2018 #1B] Mysterious Road Signs", "background": "", "description": "The town of Signfield is on a perfectly straight and infinitely long road running from west to east. Along that road, there is a sequence of $\\mathbf{S}$ mysterious road signs with numbers on both sides. The $i$-th sign (numbered in order from west to east) is at a point $\\mathbf{D}_{\\mathbf{i}}$ kilometers east of Signfield, and has a number $\\mathbf{A}_{\\mathbf{i}}$ on the west-facing side and a number $\\mathbf{B}_{\\mathbf{i}}$ on the east-facing side.\n\nNobody in Signfield knows what these signs are trying to say. You think that the numbers on the west sides of the signs are intended for drivers traveling east, and that they represent distances to some particular destination. Similarly, you think that the numbers on the east sides of the signs are for drivers traveling west, and that they represent distances to some particular destination. You suspect that not all of the signs may be consistent with this theory, though.\n\nTo start testing your theory, you are interested in finding valid sets of signs that obey the following rules:\n\n* The set is a contiguous subsequence of the sequence of all road signs. (The entire sequence also counts as a contiguous subsequence.)\n* There exist locations $\\mathrm{M}$ and $\\mathrm{N}$ kilometers east of Signfield, where $\\mathrm{M}$ and $\\mathrm{N}$ are (not necessarily positive and not necessarily distinct) numbers, such that for every sign in that set, at least one of the following is true:\n    * $\\mathbf{D}_{\\mathbf{i}}+\\mathbf{A}_{\\mathbf{i}}=\\mathbf{M}$.\n    * $\\mathbf{D}_{\\mathbf{i}}-\\mathbf{B}_{\\mathbf{i}}=\\mathbf{N}$.\n\nWhat is the largest possible number of signs in a valid set as described above, and how many different valid sets of that size are there?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line containing one integer $\\mathbf{S}$ : the number of road signs. Then, $\\mathbf{S}$ more lines follow. The $i$-th of these lines represents the $i$-th sign (in west-to-east order), and contains three integers $\\mathbf{D}_{\\mathbf{i}}, \\mathbf{A}_{\\mathbf{i}}$, and $\\mathbf{B}_{\\mathbf{i}}$ : the sign's distance (in kilometers) east of Signfield, the number on its west side, and the number on its east side.\n", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), and $y$ and $z$ are the largest possible number of signs in a valid set and the number of valid sets of that size, as described in the problem statement.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is only one sign. If we choose just that sign as our set, there are many possible values of $\\mathrm{M}$ and $\\mathrm{N}$ that work - for example:\n\n* $\\mathrm{M}=2$ and $\\mathrm{N}=0$\n* $\\mathrm{M}=1$ and $\\mathrm{N}=0$ (remember that each sign only needs to be correct for one of its values; also, $\\mathrm{M}$ and $\\mathrm{N}$ might be in the same place as one or more signs, or Signfield itself)\n* $\\mathrm{M}=2$ and $\\mathrm{N}=-12345$ ( $\\mathrm{N}$ might be west of Signfield)\n* $\\mathrm{M}=0$ and $\\mathrm{N}=0$ ( $\\mathrm{M}$ and $\\mathrm{N}$ are not necessarily distinct)\n* $\\mathrm{M}=2$ and $\\mathrm{N}=3$ ( $\\mathrm{N}$ might be east of $\\mathrm{M}$)\n\nSo, the set consisting of just that one sign is valid. That is the only set of that length, so the answer is 11 .\n\nIn Sample Case #2, note that the first, second, fourth, and fifth signs would be consistent with $\\mathrm{M}=9$ and $\\mathrm{N}=-1$, but they do not form a contiguous subsequence. (The 1 on the back of the third sign cannot be used as if it were on the front.) As it turns out, there is no valid set of four signs. There are two different valid sets of three signs. Note that although there are two different $\\mathrm{M} / \\mathrm{N}$ pairs that make the second set of three signs valid, that set counts only once:\n\n* the first, second, and third signs, with $\\mathrm{M}=9$ and $\\mathrm{N}=7$\n* the third, fourth, and fifth signs, with $\\mathrm{M}=18$ and $\\mathrm{N}=-1$ or with $\\mathrm{M}=22$ and $\\mathrm{N}=7$\n\nIn Sample Case #3, the entire sequence is a valid set, with $\\mathrm{M}=4$ and $\\mathrm{N}=2$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 60$.\n- $1 \\leqslant \\mathbf{D}_{\\mathbf{i}} \\leqslant 10^{6}$, for all $i$.\n- $\\mathbf{D}_{\\mathbf{i}}<\\mathbf{D}_{\\mathbf{j}}$, for all $i<j$.\n- $1 \\leqslant \\mathbf{A}_{\\mathbf{i}} \\leqslant 10^{6}$, for all $i$.\n- $1 \\leqslant \\mathbf{B}_{\\mathbf{i}} \\leqslant 10^{6}$, for all $i$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $1 \\leqslant \\mathbf{S} \\leqslant 100$ for all test cases.\n\n**Test set 2 (20 Pts, Hidden)**\n\n- $1 \\leqslant \\mathbf{S} \\leqslant 100$ for all but 3 test cases.\n- $\\mathbf{S}=10^{5}$ for 3 test cases.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #1B] Mysterious Road Signs", "background": "", "description": "The town of Signfield is on a perfectly straight and infinitely long road running from west to east. Along that road, there is a sequence of $\\mathbf{S}$ mysterious road signs with numbers on both sides. The $i$-th sign (numbered in order from west to east) is at a point $\\mathbf{D}_{\\mathbf{i}}$ kilometers east of Signfield, and has a number $\\mathbf{A}_{\\mathbf{i}}$ on the west-facing side and a number $\\mathbf{B}_{\\mathbf{i}}$ on the east-facing side.\n\nNobody in Signfield knows what these signs are trying to say. You think that the numbers on the west sides of the signs are intended for drivers traveling east, and that they represent distances to some particular destination. Similarly, you think that the numbers on the east sides of the signs are for drivers traveling west, and that they represent distances to some particular destination. You suspect that not all of the signs may be consistent with this theory, though.\n\nTo start testing your theory, you are interested in finding valid sets of signs that obey the following rules:\n\n* The set is a contiguous subsequence of the sequence of all road signs. (The entire sequence also counts as a contiguous subsequence.)\n* There exist locations $\\mathrm{M}$ and $\\mathrm{N}$ kilometers east of Signfield, where $\\mathrm{M}$ and $\\mathrm{N}$ are (not necessarily positive and not necessarily distinct) numbers, such that for every sign in that set, at least one of the following is true:\n    * $\\mathbf{D}_{\\mathbf{i}}+\\mathbf{A}_{\\mathbf{i}}=\\mathbf{M}$.\n    * $\\mathbf{D}_{\\mathbf{i}}-\\mathbf{B}_{\\mathbf{i}}=\\mathbf{N}$.\n\nWhat is the largest possible number of signs in a valid set as described above, and how many different valid sets of that size are there?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line containing one integer $\\mathbf{S}$ : the number of road signs. Then, $\\mathbf{S}$ more lines follow. The $i$-th of these lines represents the $i$-th sign (in west-to-east order), and contains three integers $\\mathbf{D}_{\\mathbf{i}}, \\mathbf{A}_{\\mathbf{i}}$, and $\\mathbf{B}_{\\mathbf{i}}$ : the sign's distance (in kilometers) east of Signfield, the number on its west side, and the number on its east side.\n", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), and $y$ and $z$ are the largest possible number of signs in a valid set and the number of valid sets of that size, as described in the problem statement.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is only one sign. If we choose just that sign as our set, there are many possible values of $\\mathrm{M}$ and $\\mathrm{N}$ that work - for example:\n\n* $\\mathrm{M}=2$ and $\\mathrm{N}=0$\n* $\\mathrm{M}=1$ and $\\mathrm{N}=0$ (remember that each sign only needs to be correct for one of its values; also, $\\mathrm{M}$ and $\\mathrm{N}$ might be in the same place as one or more signs, or Signfield itself)\n* $\\mathrm{M}=2$ and $\\mathrm{N}=-12345$ ( $\\mathrm{N}$ might be west of Signfield)\n* $\\mathrm{M}=0$ and $\\mathrm{N}=0$ ( $\\mathrm{M}$ and $\\mathrm{N}$ are not necessarily distinct)\n* $\\mathrm{M}=2$ and $\\mathrm{N}=3$ ( $\\mathrm{N}$ might be east of $\\mathrm{M}$)\n\nSo, the set consisting of just that one sign is valid. That is the only set of that length, so the answer is 11 .\n\nIn Sample Case #2, note that the first, second, fourth, and fifth signs would be consistent with $\\mathrm{M}=9$ and $\\mathrm{N}=-1$, but they do not form a contiguous subsequence. (The 1 on the back of the third sign cannot be used as if it were on the front.) As it turns out, there is no valid set of four signs. There are two different valid sets of three signs. Note that although there are two different $\\mathrm{M} / \\mathrm{N}$ pairs that make the second set of three signs valid, that set counts only once:\n\n* the first, second, and third signs, with $\\mathrm{M}=9$ and $\\mathrm{N}=7$\n* the third, fourth, and fifth signs, with $\\mathrm{M}=18$ and $\\mathrm{N}=-1$ or with $\\mathrm{M}=22$ and $\\mathrm{N}=7$\n\nIn Sample Case #3, the entire sequence is a valid set, with $\\mathrm{M}=4$ and $\\mathrm{N}=2$.\n\n**Limits**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 60$.\n- $1 \\leqslant \\mathbf{D}_{\\mathbf{i}} \\leqslant 10^{6}$, for all $i$.\n- $\\mathbf{D}_{\\mathbf{i}}<\\mathbf{D}_{\\mathbf{j}}$, for all $i<j$.\n- $1 \\leqslant \\mathbf{A}_{\\mathbf{i}} \\leqslant 10^{6}$, for all $i$.\n- $1 \\leqslant \\mathbf{B}_{\\mathbf{i}} \\leqslant 10^{6}$, for all $i$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $1 \\leqslant \\mathbf{S} \\leqslant 100$ for all test cases.\n\n**Test set 2 (20 Pts, Hidden)**\n\n- $1 \\leqslant \\mathbf{S} \\leqslant 100$ for all but 3 test cases.\n- $\\mathbf{S}=10^{5}$ for 3 test cases.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #1B] Mysterious Road Signs", "background": null, "description": "Signfield 镇位于一条完全笔直且无限延伸的东西向公路上。在这条公路上，依次排列着 $\\mathbf{S}$ 个神秘的路标，每个路标的两面都写有数字。第 $i$ 个路标（从西到东编号）位于 Signfield 东侧 $\\mathbf{D}_{\\mathbf{i}}$ 公里处，其西侧写有数字 $\\mathbf{A}_{\\mathbf{i}}$，东侧写有数字 $\\mathbf{B}_{\\mathbf{i}}$。\n\nSignfield 的居民都不知道这些路标想表达什么。你认为，路标西侧的数字是给向东行驶的司机看的，代表到某个特定目的地的距离。同理，你认为路标东侧的数字是给向西行驶的司机看的，也代表到某个特定目的地的距离。不过，你怀疑并不是所有路标都与这个理论一致。\n\n为了验证你的理论，你希望找到满足以下规则的有效路标集合：\n\n- 该集合是所有路标序列的一个连续子序列（整个序列也算作连续子序列）。\n- 存在两个位置 $\\mathrm{M}$ 和 $\\mathrm{N}$（均为 Signfield 东侧的公里数，$\\mathrm{M}$ 和 $\\mathrm{N}$ 不一定为正数，也不一定不同），使得对于该集合中的每一个路标，至少满足下列条件之一：\n    - $\\mathbf{D}_{\\mathbf{i}}+\\mathbf{A}_{\\mathbf{i}}=\\mathrm{M}$。\n    - $\\mathbf{D}_{\\mathbf{i}}-\\mathbf{B}_{\\mathbf{i}}=\\mathrm{N}$。\n\n请你求出满足上述条件的有效集合中，包含路标数量的最大值，以及有多少个不同的有效集合达到该最大值。", "inputFormat": "输入的第一行是测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组测试数据的第一行为一个整数 $\\mathbf{S}$，表示路标的数量。接下来的 $\\mathbf{S}$ 行，每行包含三个整数 $\\mathbf{D}_{\\mathbf{i}}, \\mathbf{A}_{\\mathbf{i}}, \\mathbf{B}_{\\mathbf{i}}$，分别表示第 $i$ 个路标距离 Signfield 的距离（公里）、西侧数字和东侧数字。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y z`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为有效集合中最大路标数量，$z$ 为达到该最大数量的不同有效集合个数。", "hint": "**样例解释**\n\n在样例 1 中，只有一个路标。如果我们只选择这个路标作为集合，有很多可能的 $\\mathrm{M}$ 和 $\\mathrm{N}$ 组合都是可行的，例如：\n\n- $\\mathrm{M}=2$，$\\mathrm{N}=0$\n- $\\mathrm{M}=1$，$\\mathrm{N}=0$（注意每个路标只需满足其中一个条件；$\\mathrm{M}$ 和 $\\mathrm{N}$ 可以与某些路标或 Signfield 重合）\n- $\\mathrm{M}=2$，$\\mathrm{N}=-12345$（$\\mathrm{N}$ 可以在 Signfield 西侧）\n- $\\mathrm{M}=0$，$\\mathrm{N}=0$（$\\mathrm{M}$ 和 $\\mathrm{N}$ 不一定不同）\n- $\\mathrm{M}=2$，$\\mathrm{N}=3$（$\\mathrm{N}$ 可以在 $\\mathrm{M}$ 东侧）\n\n因此，只包含该路标的集合是有效的。该长度的集合只有一个，所以答案是 1 1。\n\n在样例 2 中，注意第 1、2、4、5 个路标在 $\\mathrm{M}=9$ 和 $\\mathrm{N}=-1$ 时是成立的，但它们不是连续子序列（第 3 个路标的背面数字不能当作正面用）。实际上，没有包含 4 个路标的有效集合。有两个不同的包含 3 个路标的有效集合。注意，虽然第二个集合有两组不同的 $\\mathrm{M}/\\mathrm{N}$ 组合可以使其成立，但该集合只计数一次：\n\n- 第 1、2、3 个路标，$\\mathrm{M}=9$，$\\mathrm{N}=7$\n- 第 3、4、5 个路标，$\\mathrm{M}=18$，$\\mathrm{N}=-1$ 或 $\\mathrm{M}=22$，$\\mathrm{N}=7$\n\n在样例 3 中，整个序列是一个有效集合，$\\mathrm{M}=4$，$\\mathrm{N}=2$。\n\n**数据范围**\n\n- $1 \\leqslant \\mathbf{T} \\leqslant 60$。\n- $1 \\leqslant \\mathbf{D}_{\\mathbf{i}} \\leqslant 10^{6}$，对所有 $i$。\n- $\\mathbf{D}_{\\mathbf{i}}<\\mathbf{D}_{\\mathbf{j}}$，对所有 $i<j$。\n- $1 \\leqslant \\mathbf{A}_{\\mathbf{i}} \\leqslant 10^{6}$，对所有 $i$。\n- $1 \\leqslant \\mathbf{B}_{\\mathbf{i}} \\leqslant 10^{6}$，对所有 $i$。\n\n**测试点 1（10 分，公开）**\n\n- 所有测试用例 $1 \\leqslant \\mathbf{S} \\leqslant 100$。\n\n**测试点 2（20 分，隐藏）**\n\n- 除 3 个测试用例外，所有测试用例 $1 \\leqslant \\mathbf{S} \\leqslant 100$。\n- 有 3 个测试用例 $\\mathbf{S}=10^{5}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13141", "type": "P", "difficulty": 5, "samples": [["3\n3\n2 3\n1 3\n1 2\n5 2 3\n5\n3 4\n3 4\n4 5\n3 5\n1 3\n0 8 6 2 4\n4\n3 4\n2 3\n2 3\n2 3\n0 1 1 0", "Case #1: 7\nCase #2: 4\nCase #3: 0"]], "limits": {"time": [5000, 5000, 5000], "memory": [1048576, 1048576, 1048576]}, "tags": ["动态规划 DP", "图论", "贪心", "2018", "二分", "递归", "Google Code Jam"], "title": "[GCJ 2018 #1B] Transmutation", "background": "", "description": "You are the most skilled alchemist of a country that considers metals such as gold, platinum, and silver to be uninteresting, but highly values lead. There are $\\mathrm{M}$ metals known in the world; lead is metal number 1 on your periodic table. Your country's leader has asked you to use the metal in the treasury to make as much lead as possible.\n\nFor each metal (including lead), you know exactly one formula that lets you create one gram of that metal by destroying one gram each of two ingredient metals. (If you are wondering about the principle of mass conservation, the other gram is lost in useless waste products.) The formulas do not work with partial grams. However, you can use each formula as often as you would like (or not at all), as long as you have the required ingredients each time.\n\nIf you make optimal choices, what is the largest total amount of lead you can end up with? Note that it is possible that you may have some metals other than lead left over after you are done.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with an integer $\\mathrm{M}$ : the number of metals known in the world. Then there are $\\mathrm{M}$ more lines with two integers $\\mathbf{R}_{\\mathbf{i} 1}$ and $\\mathbf{R}_{\\mathbf{i} 2}$ each; the $\\mathrm{i}$-th of these lines indicates that you can create one gram of metal $\\mathrm{i}$ by destroying one gram of metal $\\mathbf{R}_{\\mathbf{i} 1}$ and one gram of metal $\\mathbf{R}_{\\mathbf{i} 2}$. Finally, there is one line with $\\mathrm{M}$ integers $\\mathbf{G}_{1}, \\mathbf{G}_{2}, \\ldots, \\mathbf{G}_{\\mathbf{M}} ; \\mathbf{G}_{\\mathbf{i}}$ is the number of grams of metal $\\mathrm{i}$ in the treasury. Lead is metal 1 .", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the largest amount of lead, in grams, that you can end up with.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the optimal strategy is to use $2$ grams of metals $2$ and $3$ to produce $2$ more grams of lead, for a total of $7$ grams of lead.\n\nIn Sample Case #2, the optimal strategy is to first use $2$ grams of metal $3$ and $2$ grams of metal $5$ to produce $2$ grams of metal $4$, and then use $4$ grams of metal $3$ and $4$ grams of metal $4$ to produce $4$ grams of lead. Note that it is possible for two formulas to have the same two ingredients (you just use different alchemical techniques). Also note that not every metal is necessarily an ingredient in some other formula; in this case, metal $2$ is never an ingredient.\n\nIn Sample Case #3, note that it is possible for a metal to be used to produce itself. (Sometimes the laws of alchemy may be silly!) Unfortunately, it is not possible to produce any lead in this case. Note that since formulas only work on single-gram quantities, you cannot, for example, use $0.5$ grams of each of metals $2$ and $3$ to create $0.5$ grams of metal $4$, and then use $0.5$ grams of each of metals $3$ and $4$ to create $0.5$ grams of lead.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq \\mathbf{R_{i1}} < \\mathbf{R_{i2}} \\leq M$, for all $i$.\n\n**Test set 1 (15 Pts,Visible)**\n\n- $2 \\leq M \\leq 8$.\n- $0 \\leq \\mathbf{G_i} \\leq 8$, for all $i$.\n\n**Test set 2 (18 Pts, Hidden)**\n\n- $2 \\leq M \\leq 100$.\n- $0 \\leq \\mathbf{G_i} \\leq 100$, for all $i$.\n\n**Test set 3 (12 Pts, Hidden)**\n\n- $2 \\leq M \\leq 100$.\n- $0 \\leq \\mathbf{G_i} \\leq 10^9$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #1B] Transmutation", "background": "", "description": "You are the most skilled alchemist of a country that considers metals such as gold, platinum, and silver to be uninteresting, but highly values lead. There are $\\mathrm{M}$ metals known in the world; lead is metal number 1 on your periodic table. Your country's leader has asked you to use the metal in the treasury to make as much lead as possible.\n\nFor each metal (including lead), you know exactly one formula that lets you create one gram of that metal by destroying one gram each of two ingredient metals. (If you are wondering about the principle of mass conservation, the other gram is lost in useless waste products.) The formulas do not work with partial grams. However, you can use each formula as often as you would like (or not at all), as long as you have the required ingredients each time.\n\nIf you make optimal choices, what is the largest total amount of lead you can end up with? Note that it is possible that you may have some metals other than lead left over after you are done.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with an integer $\\mathrm{M}$ : the number of metals known in the world. Then there are $\\mathrm{M}$ more lines with two integers $\\mathbf{R}_{\\mathbf{i} 1}$ and $\\mathbf{R}_{\\mathbf{i} 2}$ each; the $\\mathrm{i}$-th of these lines indicates that you can create one gram of metal $\\mathrm{i}$ by destroying one gram of metal $\\mathbf{R}_{\\mathbf{i} 1}$ and one gram of metal $\\mathbf{R}_{\\mathbf{i} 2}$. Finally, there is one line with $\\mathrm{M}$ integers $\\mathbf{G}_{1}, \\mathbf{G}_{2}, \\ldots, \\mathbf{G}_{\\mathbf{M}} ; \\mathbf{G}_{\\mathbf{i}}$ is the number of grams of metal $\\mathrm{i}$ in the treasury. Lead is metal 1 .", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $\\mathrm{x}$ is the test case number (starting from 1) and $\\mathrm{y}$ is the largest amount of lead, in grams, that you can end up with.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the optimal strategy is to use $2$ grams of metals $2$ and $3$ to produce $2$ more grams of lead, for a total of $7$ grams of lead.\n\nIn Sample Case #2, the optimal strategy is to first use $2$ grams of metal $3$ and $2$ grams of metal $5$ to produce $2$ grams of metal $4$, and then use $4$ grams of metal $3$ and $4$ grams of metal $4$ to produce $4$ grams of lead. Note that it is possible for two formulas to have the same two ingredients (you just use different alchemical techniques). Also note that not every metal is necessarily an ingredient in some other formula; in this case, metal $2$ is never an ingredient.\n\nIn Sample Case #3, note that it is possible for a metal to be used to produce itself. (Sometimes the laws of alchemy may be silly!) Unfortunately, it is not possible to produce any lead in this case. Note that since formulas only work on single-gram quantities, you cannot, for example, use $0.5$ grams of each of metals $2$ and $3$ to create $0.5$ grams of metal $4$, and then use $0.5$ grams of each of metals $3$ and $4$ to create $0.5$ grams of lead.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq \\mathbf{R_{i1}} < \\mathbf{R_{i2}} \\leq M$, for all $i$.\n\n**Test set 1 (15 Pts,Visible)**\n\n- $2 \\leq M \\leq 8$.\n- $0 \\leq \\mathbf{G_i} \\leq 8$, for all $i$.\n\n**Test set 2 (18 Pts, Hidden)**\n\n- $2 \\leq M \\leq 100$.\n- $0 \\leq \\mathbf{G_i} \\leq 100$, for all $i$.\n\n**Test set 3 (12 Pts, Hidden)**\n\n- $2 \\leq M \\leq 100$.\n- $0 \\leq \\mathbf{G_i} \\leq 10^9$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #1B] Transmutation", "background": null, "description": "你是一个国家中最技艺高超的炼金术士，这个国家认为黄金、铂金和白银等金属毫无趣味，却极为珍视铅。在已知的 $\\mathrm{M}$ 种金属中，铅在你的元素周期表上编号为 1。国家的领袖要求你利用国库中的金属，尽可能多地制造铅。\n\n对于每种金属（包括铅），你都知道恰好有一种配方，可以通过消耗两种原料金属各一克来制造该金属一克。（如果你在思考质量守恒定律，另一克会变成无用的废弃物。）配方不能用部分克数操作。然而，只要你有足够的原料，每种配方你都可以使用任意多次（也可以不用）。\n\n如果你做出最优选择，最终你最多能得到多少克铅？注意，操作结束后，可能还会剩下一些非铅金属。", "inputFormat": "输入的第一行为测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试用例。每组测试用例的第一行为一个整数 $\\mathrm{M}$，表示已知的金属种类数。接下来有 $\\mathrm{M}$ 行，每行包含两个整数 $\\mathbf{R}_{\\mathbf{i} 1}$ 和 $\\mathbf{R}_{\\mathbf{i} 2}$，表示可以通过消耗 $\\mathbf{R}_{\\mathbf{i} 1}$ 号金属一克和 $\\mathbf{R}_{\\mathbf{i} 2}$ 号金属一克，制造出 $\\mathrm{i}$ 号金属一克。最后一行包含 $\\mathrm{M}$ 个整数 $\\mathbf{G}_{1}, \\mathbf{G}_{2}, \\ldots, \\mathbf{G}_{\\mathbf{M}}$，其中 $\\mathbf{G}_{\\mathbf{i}}$ 表示国库中 $\\mathrm{i}$ 号金属的克数。铅为 1 号金属。", "outputFormat": "对于每组测试用例，输出一行，格式为 `Case #x: y`，其中 $\\mathrm{x}$ 为测试用例编号（从 1 开始），$\\mathrm{y}$ 为你最终能获得的最大铅的克数。", "hint": "**样例解释**\n\n样例 1 中，最优策略是用 2 克 2 号金属和 2 克 3 号金属制造 2 克铅，最终共得到 7 克铅。\n\n样例 2 中，最优策略是先用 2 克 3 号金属和 2 克 5 号金属制造 2 克 4 号金属，然后用 4 克 3 号金属和 4 克 4 号金属制造 4 克铅。注意，可能有两种配方使用相同的两种原料金属（只是炼金术手法不同）。也要注意，并不是每种金属都一定会作为其他配方的原料；在本例中，2 号金属从未作为原料。\n\n样例 3 中，注意某种金属可能可以用来制造自身。（有时候炼金术的规律也很奇怪！）但在本例中无法制造出任何铅。注意，由于配方只能以整数克操作，不能用 0.5 克 2 号金属和 0.5 克 3 号金属制造 0.5 克 4 号金属，再用 0.5 克 3 号金属和 0.5 克 4 号金属制造 0.5 克铅。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- 对所有 $i$，$1 \\leq \\mathbf{R_{i1}} < \\mathbf{R_{i2}} \\leq M$。\n\n**测试点 1（15 分，可见）**\n\n- $2 \\leq M \\leq 8$。\n- 对所有 $i$，$0 \\leq \\mathbf{G_i} \\leq 8$。\n\n**测试点 2（18 分，隐藏）**\n\n- $2 \\leq M \\leq 100$。\n- 对所有 $i$，$0 \\leq \\mathbf{G_i} \\leq 100$。\n\n**测试点 3（12 分，隐藏）**\n\n- $2 \\leq M \\leq 100$。\n- 对所有 $i$，$0 \\leq \\mathbf{G_i} \\leq 10^9$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13142", "type": "P", "difficulty": 3, "samples": [["5\n4 1\nA\nB\nC\nD\n4 2\nWW\nAA\nSS\nDD\n4 2\nAA\nAB\nBA\nBB\n3 4\nCAKE\nTORN\nSHOW\n5 7\nHELPIAM\nTRAPPED\nINSIDEA\nCODEJAM\nFACTORY", "Case #1: -\nCase #2: WA\nCase #3: -\nCase #4: CORN\nCase #5: HOLIDAY"]], "limits": {"time": [15000, 15000], "memory": [1048576, 1048576]}, "tags": ["2018", "Special Judge", "字典树 Trie", "Google Code Jam"], "title": "[GCJ 2018 #1C] A Whole New Word", "background": "", "description": "Vincent and Desta are childhood friends. Today, Vincent is showing $N$ distinct $L$-letter words to Desta by using some letter tiles. Each tile contains one uppercase English alphabet letter, and one number between $1$ and $L$. A word consists of the letters spelled out by $L$ tiles with numbers from $1$ through $L$, in order. (Vincent's words are not necessarily real English words.)\n\nFor example, if Vincent has $N = 3$ words with $L = 4$, and the words are $\\{\\text{CAKE}, \\text{TORN}, \\text{SHOW}\\}$, then Vincent must show the following to Desta:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ve1i8p4m.png)\n\nDesta feels that creating words must be easy, and he wants to create a new word that obeys the rules above and is not one of Vincent's existing words. However, Desta does not have any tiles of his own, so he must use some of Vincent's tiles.\n\nFor instance, if Vincent has the words from the previous example, then Desta can make a new word such as $\\text{CORN}$ or $\\text{SAKE}$ or $\\text{CHRE}$ (Desta's words are also not necessarily real English words). Each of the example is illustrated in the following image:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0rhou6na.png)\n\nNote that the three rows in the image above are independent. Desta only needs to make one new word.\n\nHowever, in the above example, Desta cannot make WAKE, for example, because there is no $\\text W$ tile with a number $1$. Nor can he make coo, since it is not the right length.\n\nNotice that it may be impossible for Desta to make a new word. For example, if Vincent has only one word, then Desta cannot make anything new. Or, if Vincent has the words $\\{\\text{AA}, \\text{AB}, \\text{BA}, \\text{BB}\\}$, then any word that Desta can form is already present.\n\nHelp Desta to choose a word that he can show to Vincent using only the tiles used by Vincent, or indicate that it is impossible to do so.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with two integers $N$ and $L$: the number of Vincent's words, and the length of each word. Then, $N$ more lines follow. The $i$-th of these lines contains a string of $L$ uppercase English letters representing the $i$-th of Vincent's words.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a valid word to be chosen by Desta, or - (a single dash character of ASCII value 45) if there is no valid word to be chosen by Desta. If there is more than one valid word that Desta can make, you can output any of them.", "hint": "**Sample Explanation**\n\nNote that the last two sample cases would not appear in test set 1.\n\nIn Sample Case #1, the only words that can be constructed using the tiles used by Vincent are A, B, C, D. However, all of those words already appear in Vincent's list of words, so Desta is not allowed to choose them.\n\nIn Sample Case #2, there are $12$ possible new words that Desta can make, one of which is $\\text{WA}$.\n\nSample Case #3 was explained in the problem description above; there is no new word that Desta can make.\n\nSample Case #4 was explained in the problem description above; other answers such as $\\text{SAKF}$ are possible.\n\nIn Sample Case #5, other answers such as $\\text{TRAPJAM}$ are possible.\n\n**Limits**\n\n- $1 \\leqslant T \\leqslant 100$.\n- No two of Vincent's words are the same.\n\n**Test set 1 (11 Pts, Visible)**\n\n- $1 \\leqslant N \\leqslant 26^{2}$.\n- $1 \\leqslant L \\leqslant 2$.\n\n**Test set 2 (17 Pts, Hidden)**\n\n- $1 \\leqslant N \\leqslant 2000$.\n- $1 \\leqslant L \\leqslant 10$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #1C] A Whole New Word", "background": "", "description": "Vincent and Desta are childhood friends. Today, Vincent is showing $N$ distinct $L$-letter words to Desta by using some letter tiles. Each tile contains one uppercase English alphabet letter, and one number between $1$ and $L$. A word consists of the letters spelled out by $L$ tiles with numbers from $1$ through $L$, in order. (Vincent's words are not necessarily real English words.)\n\nFor example, if Vincent has $N = 3$ words with $L = 4$, and the words are $\\{\\text{CAKE}, \\text{TORN}, \\text{SHOW}\\}$, then Vincent must show the following to Desta:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ve1i8p4m.png)\n\nDesta feels that creating words must be easy, and he wants to create a new word that obeys the rules above and is not one of Vincent's existing words. However, Desta does not have any tiles of his own, so he must use some of Vincent's tiles.\n\nFor instance, if Vincent has the words from the previous example, then Desta can make a new word such as $\\text{CORN}$ or $\\text{SAKE}$ or $\\text{CHRE}$ (Desta's words are also not necessarily real English words). Each of the example is illustrated in the following image:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0rhou6na.png)\n\nNote that the three rows in the image above are independent. Desta only needs to make one new word.\n\nHowever, in the above example, Desta cannot make WAKE, for example, because there is no $\\text W$ tile with a number $1$. Nor can he make coo, since it is not the right length.\n\nNotice that it may be impossible for Desta to make a new word. For example, if Vincent has only one word, then Desta cannot make anything new. Or, if Vincent has the words $\\{\\text{AA}, \\text{AB}, \\text{BA}, \\text{BB}\\}$, then any word that Desta can form is already present.\n\nHelp Desta to choose a word that he can show to Vincent using only the tiles used by Vincent, or indicate that it is impossible to do so.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with two integers $N$ and $L$: the number of Vincent's words, and the length of each word. Then, $N$ more lines follow. The $i$-th of these lines contains a string of $L$ uppercase English letters representing the $i$-th of Vincent's words.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is a valid word to be chosen by Desta, or - (a single dash character of ASCII value 45) if there is no valid word to be chosen by Desta. If there is more than one valid word that Desta can make, you can output any of them.", "hint": "**Sample Explanation**\n\nNote that the last two sample cases would not appear in test set 1.\n\nIn Sample Case #1, the only words that can be constructed using the tiles used by Vincent are A, B, C, D. However, all of those words already appear in Vincent's list of words, so Desta is not allowed to choose them.\n\nIn Sample Case #2, there are $12$ possible new words that Desta can make, one of which is $\\text{WA}$.\n\nSample Case #3 was explained in the problem description above; there is no new word that Desta can make.\n\nSample Case #4 was explained in the problem description above; other answers such as $\\text{SAKF}$ are possible.\n\nIn Sample Case #5, other answers such as $\\text{TRAPJAM}$ are possible.\n\n**Limits**\n\n- $1 \\leqslant T \\leqslant 100$.\n- No two of Vincent's words are the same.\n\n**Test set 1 (11 Pts, Visible)**\n\n- $1 \\leqslant N \\leqslant 26^{2}$.\n- $1 \\leqslant L \\leqslant 2$.\n\n**Test set 2 (17 Pts, Hidden)**\n\n- $1 \\leqslant N \\leqslant 2000$.\n- $1 \\leqslant L \\leqslant 10$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #1C] A Whole New Word", "background": null, "description": "Vincent 和 Desta 是从小一起长大的朋友。今天，Vincent 用一些字母牌向 Desta 展示了 $N$ 个不同的 $L$ 字母单词。每个字母牌上有一个大写英文字母和一个 $1$ 到 $L$ 之间的数字。一个单词由 $L$ 个数字分别为 $1$ 到 $L$ 的字母牌按顺序拼成。（Vincent 的单词不一定是真正的英文单词。）\n\n例如，如果 Vincent 有 $N = 3$ 个长度为 $L = 4$ 的单词，分别是 $\\{\\text{CAKE}, \\text{TORN}, \\text{SHOW}\\}$，那么 Vincent 必须向 Desta 展示如下内容：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ve1i8p4m.png)\n\nDesta 觉得造单词一定很简单，他想用上述规则造出一个新的单词，并且不能和 Vincent 已有的单词重复。然而，Desta 没有自己的字母牌，他只能使用 Vincent 的字母牌。\n\n例如，如果 Vincent 的单词如上例所示，Desta 可以拼出新的单词，如 $\\text{CORN}$、$\\text{SAKE}$ 或 $\\text{CHRE}$（Desta 造的单词也不一定是真正的英文单词）。每个例子如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/0rhou6na.png)\n\n注意，上图的三行是独立的。Desta 只需要造出一个新单词即可。\n\n但是，在上述例子中，Desta 不能拼出 WAKE，因为没有数字为 $1$ 的 $\\text W$ 字母牌。也不能拼出 coo，因为长度不对。\n\n注意，有时 Desta 可能无法造出新单词。例如，如果 Vincent 只有一个单词，那么 Desta 无法造出任何新单词。又如，如果 Vincent 的单词为 $\\{\\text{AA}, \\text{AB}, \\text{BA}, \\text{BB}\\}$，那么 Desta 能拼出的所有单词都已在 Vincent 的单词列表中。\n\n请帮助 Desta 选择一个他能用 Vincent 的字母牌拼出的新单词，或者指出无法拼出新单词。", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行包含两个整数 $N$ 和 $L$，分别表示 Vincent 的单词数和每个单词的长度。接下来的 $N$ 行，每行是一个长度为 $L$ 的大写英文字母字符串，表示 Vincent 的第 $i$ 个单词。", "outputFormat": "对于每组测试数据，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 Desta 能拼出的一个合法新单词，或者如果无法拼出则输出一个单独的短横线 `-`（ASCII 码 45）。如果有多个合法答案，可以输出任意一个。", "hint": "**样例解释**\n\n注意，最后两个样例不会出现在测试集 1 中。\n\n样例 1 中，只能用 Vincent 的字母牌拼出 A、B、C、D 这四个单词，但这些单词都已在 Vincent 的单词列表中，所以 Desta 不能选择它们。\n\n样例 2 中，有 $12$ 个可能的新单词可以拼出，其中之一是 $\\text{WA}$。\n\n样例 3 已在题目描述中解释，Desta 无法拼出新单词。\n\n样例 4 已在题目描述中解释，也可以输出如 $\\text{SAKF}$ 等其它答案。\n\n样例 5 也可以输出如 $\\text{TRAPJAM}$ 等其它答案。\n\n**数据范围**\n\n- $1 \\leqslant T \\leqslant 100$。\n- Vincent 的单词互不相同。\n\n**测试集 1（11 分，可见）**\n\n- $1 \\leqslant N \\leqslant 26^{2}$。\n- $1 \\leqslant L \\leqslant 2$。\n\n**测试集 2（17 分，隐藏）**\n\n- $1 \\leqslant N \\leqslant 2000$。\n- $1 \\leqslant L \\leqslant 10$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13143", "type": "P", "difficulty": 4, "samples": [["", ""]], "limits": {"time": [25000], "memory": [1048576]}, "tags": ["数学", "2018", "交互题", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2018 #1C] Lollipop Shop", "background": "", "description": "You own a lollipop shop. At the start of the day, you make $N$ lollipops, each of a single unique flavor, like huckleberry, cherry or lime. $N$ customers come into the shop during the day, one at a time. Each customer gives you a list of which of your lollipop flavors they like. You can sell them one lollipop of any of those flavors, as long as you have not already sold someone else the same flavor earlier in the day (since there is only one lollipop of each flavor). If none of the flavors they like are still available, you cannot sell them a lollipop, and they leave your shop disappointed.\n\nYou do not know what each customer's flavor preferences are going to be until they arrive. Each customer decides if they like or dislike each flavor randomly, independently of whether they like any other flavor, or what flavors anyone else likes. However, your market studies have shown that some flavors may have a higher probability of being liked in general! For example, the lime flavor might have a $10\\%$ chance of being liked by any particular customer, whereas that chance might be $1\\%$ for the cherry flavor. These values are always chosen independently and uniformly at random from the interval $[0.005, 0.1]$.\n\nObviously, you want to sell lollipops to as many of the $N$ customers as possible! But, since you do not know what flavors your customers will ask for ahead of time, you cannot always make an optimal decision — sometimes you might sell a customer one flavor, and then later wish you had sold them another.\n\nSuppose that you somehow knew all the customers' preferences in advance and could plan ahead; then there is some maximum number $M$ of lollipops that you could possibly sell. You do not know the customers' preferences in advance, but we require you to sell a number of lollipops that is at least $90\\%$ of $M$ for each input case.\n\n### Interactive Protocol\n\nThis problem is interactive, which means that the concepts of input and output are different than in standard Code Jam problems. You will interact with a separate process that both provides you with information and evaluates your responses. All information comes into your program via standard input; anything that you need to communicate should be sent via standard output. Remember that many programming languages buffer the output by default, so make sure your output actually goes out (for instance, by flushing the buffer) before blocking to wait for a response. See the FAQ for an explanation of what it means to flush the buffer. Anything your program sends through standard error is ignored, but it might consume some memory and be counted against your memory limit, so do not overflow it.\n\nInitially, your program should read a single line containing a single integer $\\mathbf{T}$ indicating the number of test cases. Then, you need to process $\\mathbf{T}$ test cases.\n\nFor each test case, your program should read a single line with one integer $\\mathbf{N}$, the number of lollipops (which is the same as the number of customers).\n\nThen, for each of the customers, your program should read a single line, which will contain space-separated integers. The first integer is $\\mathbf{D}$, the number of flavors that customer likes. Then, $\\mathbf{D}$ integers follow, the ID numbers of those flavors, in strictly increasing order. Flavors have unique ID numbers in the range $[0, \\mathbf{N} - 1]$. Note that $\\mathbf{D}$ might be zero for some or all customers.\n\nAfter each of these lines, your program must write a single line to standard output, containing the ID number of one of the $\\mathbf{D}$ flavors to sell to the customer, or -1 if no lollipop is to be sold to the customer. After you have written the $\\mathbf{N}$th line for the test case, your program should terminate if it was the last test case; otherwise, it should start reading data for the next test case.\n\nIf your program gets something wrong (e.g., tries to sell a customer a flavor that was already sold, or tries to sell a customer a flavor they don't like, or uses the wrong output format, or outputs an out-of-bounds value), the judge will send -1 to your input stream and it will not send any other output after that. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive the appropriate verdict (Wrong Answer, Runtime Error, etc.) instead of a Time Limit Exceeded error. As usual, if the total time or memory is exceeded, or your program gets a runtime error, you will receive the appropriate verdict. Not selling enough lollipops for a test case will not cause you to get the -1 message.\n\nYou should not send additional information to the judge after processing all test cases. In other words, if your program keeps printing to standard output after the last test case, you will get a Wrong Answer judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "Note that this sample interaction has smaller values of $\\mathbf T$ and $\\mathbf N$ than the real data. The local testing tool also uses smaller cases.\n\n```\n  t = readline_int()           // reads 10 into t\n  n = readline_int()           // reads 4 into n (four customers & flavors)\n  prefs = readline_int_list()  // reads 1 2 (customer only likes flavor 2)\n  printline 2 to stdout        // sells this customer flavor 2\n  flush stdout\n  prefs = readline_int_list()  // reads 0 (customer likes nothing)\n  printline -1 to stdout       // no flavor to sell to the customer!\n  flush stdout\n  prefs = readline_int_list()  // reads 1 2 (customer only likes flavor 2)\n  printline -1 to stdout       // already used flavor 2, so no flavor to sell\n  flush stdout\n  prefs = readline_int_list()  // reads 2 1 3 (customer likes 1 and 3)\n  printline 3 to stdout        // note: we could have also sold flavor 1\n  flush stdout\n  n = readline_int()           // (start of case 2) reads 1\n  prefs = readline_int_list()  // reads 1 0\n  printline -1 to stdout       // non-optimal but legal choice\n  flush stdout\n  n = readline_int()           // (start of case 3) reads 5\n  prefs = readline_int_list()  // reads 2 1 3\n  printline 1 to stdout\n  flush stdout\n  prefs = readline_int_list()  // reads 2 1 2\n  printline 1 to stdout        // error -- tried to give same flavor twice!\n  flush stdout\n  prefs = readline_int_list()  // reads -1 (judge has given up on us)\n  exit                         // exits to avoid an ambiguous TLE error\n```\n\nThe pseudocode above demonstrates the following scenario.\n\n- In the first test case, the program sells a total of two lollipops. It would not have been possible to sell more than two, so the actual number sold is definitely at least 90% of the maximum possible number sold.\n- In the second test case, the program chooses (for the sake of demonstration here) not to sell the customer a lollipop, although it could have. It sells a total of 0 when it could have sold a total of 1. So, the program will not pass this test set, but note that this does not cause the judge to stop sending input.\n- In the third case, the program makes an error (again for the sake of demonstration) that causes the judge to stop sending input. The program recognizes this and terminates. The user will see a Wrong Answer judgment.\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**A note on judge behavior**\n\nAt the start of each test case, the judge will determine all customers' preferences. That is, it will use a (hidden) list of probabilities $P_i$ between 0.005 and 0.1, one for each flavor; each customer has a probability $P_i$ of liking the i-th flavor. That is, the random variables indicating whether customer j likes flavor i are independent and identically distributed. These preferences are constant throughout the test and will not be modified e.g. in response to your choices.\n\n**Test set 1 (29 Pts, Visible)**\n\n- $\\mathbf{T} = 50.$\n- $\\mathbf{N} = 200.$\n- $0 \\leqslant \\mathbf{D} \\leqslant \\mathbf{N}.$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #1C] Lollipop Shop", "background": "", "description": "You own a lollipop shop. At the start of the day, you make $N$ lollipops, each of a single unique flavor, like huckleberry, cherry or lime. $N$ customers come into the shop during the day, one at a time. Each customer gives you a list of which of your lollipop flavors they like. You can sell them one lollipop of any of those flavors, as long as you have not already sold someone else the same flavor earlier in the day (since there is only one lollipop of each flavor). If none of the flavors they like are still available, you cannot sell them a lollipop, and they leave your shop disappointed.\n\nYou do not know what each customer's flavor preferences are going to be until they arrive. Each customer decides if they like or dislike each flavor randomly, independently of whether they like any other flavor, or what flavors anyone else likes. However, your market studies have shown that some flavors may have a higher probability of being liked in general! For example, the lime flavor might have a $10\\%$ chance of being liked by any particular customer, whereas that chance might be $1\\%$ for the cherry flavor. These values are always chosen independently and uniformly at random from the interval $[0.005, 0.1]$.\n\nObviously, you want to sell lollipops to as many of the $N$ customers as possible! But, since you do not know what flavors your customers will ask for ahead of time, you cannot always make an optimal decision — sometimes you might sell a customer one flavor, and then later wish you had sold them another.\n\nSuppose that you somehow knew all the customers' preferences in advance and could plan ahead; then there is some maximum number $M$ of lollipops that you could possibly sell. You do not know the customers' preferences in advance, but we require you to sell a number of lollipops that is at least $90\\%$ of $M$ for each input case.\n\n### Interactive Protocol\n\nThis problem is interactive, which means that the concepts of input and output are different than in standard Code Jam problems. You will interact with a separate process that both provides you with information and evaluates your responses. All information comes into your program via standard input; anything that you need to communicate should be sent via standard output. Remember that many programming languages buffer the output by default, so make sure your output actually goes out (for instance, by flushing the buffer) before blocking to wait for a response. See the FAQ for an explanation of what it means to flush the buffer. Anything your program sends through standard error is ignored, but it might consume some memory and be counted against your memory limit, so do not overflow it.\n\nInitially, your program should read a single line containing a single integer $\\mathbf{T}$ indicating the number of test cases. Then, you need to process $\\mathbf{T}$ test cases.\n\nFor each test case, your program should read a single line with one integer $\\mathbf{N}$, the number of lollipops (which is the same as the number of customers).\n\nThen, for each of the customers, your program should read a single line, which will contain space-separated integers. The first integer is $\\mathbf{D}$, the number of flavors that customer likes. Then, $\\mathbf{D}$ integers follow, the ID numbers of those flavors, in strictly increasing order. Flavors have unique ID numbers in the range $[0, \\mathbf{N} - 1]$. Note that $\\mathbf{D}$ might be zero for some or all customers.\n\nAfter each of these lines, your program must write a single line to standard output, containing the ID number of one of the $\\mathbf{D}$ flavors to sell to the customer, or -1 if no lollipop is to be sold to the customer. After you have written the $\\mathbf{N}$th line for the test case, your program should terminate if it was the last test case; otherwise, it should start reading data for the next test case.\n\nIf your program gets something wrong (e.g., tries to sell a customer a flavor that was already sold, or tries to sell a customer a flavor they don't like, or uses the wrong output format, or outputs an out-of-bounds value), the judge will send -1 to your input stream and it will not send any other output after that. If your program continues to wait for the judge after receiving -1, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive the appropriate verdict (Wrong Answer, Runtime Error, etc.) instead of a Time Limit Exceeded error. As usual, if the total time or memory is exceeded, or your program gets a runtime error, you will receive the appropriate verdict. Not selling enough lollipops for a test case will not cause you to get the -1 message.\n\nYou should not send additional information to the judge after processing all test cases. In other words, if your program keeps printing to standard output after the last test case, you will get a Wrong Answer judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "Note that this sample interaction has smaller values of $\\mathbf T$ and $\\mathbf N$ than the real data. The local testing tool also uses smaller cases.\n\n```\n  t = readline_int()           // reads 10 into t\n  n = readline_int()           // reads 4 into n (four customers & flavors)\n  prefs = readline_int_list()  // reads 1 2 (customer only likes flavor 2)\n  printline 2 to stdout        // sells this customer flavor 2\n  flush stdout\n  prefs = readline_int_list()  // reads 0 (customer likes nothing)\n  printline -1 to stdout       // no flavor to sell to the customer!\n  flush stdout\n  prefs = readline_int_list()  // reads 1 2 (customer only likes flavor 2)\n  printline -1 to stdout       // already used flavor 2, so no flavor to sell\n  flush stdout\n  prefs = readline_int_list()  // reads 2 1 3 (customer likes 1 and 3)\n  printline 3 to stdout        // note: we could have also sold flavor 1\n  flush stdout\n  n = readline_int()           // (start of case 2) reads 1\n  prefs = readline_int_list()  // reads 1 0\n  printline -1 to stdout       // non-optimal but legal choice\n  flush stdout\n  n = readline_int()           // (start of case 3) reads 5\n  prefs = readline_int_list()  // reads 2 1 3\n  printline 1 to stdout\n  flush stdout\n  prefs = readline_int_list()  // reads 2 1 2\n  printline 1 to stdout        // error -- tried to give same flavor twice!\n  flush stdout\n  prefs = readline_int_list()  // reads -1 (judge has given up on us)\n  exit                         // exits to avoid an ambiguous TLE error\n```\n\nThe pseudocode above demonstrates the following scenario.\n\n- In the first test case, the program sells a total of two lollipops. It would not have been possible to sell more than two, so the actual number sold is definitely at least 90% of the maximum possible number sold.\n- In the second test case, the program chooses (for the sake of demonstration here) not to sell the customer a lollipop, although it could have. It sells a total of 0 when it could have sold a total of 1. So, the program will not pass this test set, but note that this does not cause the judge to stop sending input.\n- In the third case, the program makes an error (again for the sake of demonstration) that causes the judge to stop sending input. The program recognizes this and terminates. The user will see a Wrong Answer judgment.\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**A note on judge behavior**\n\nAt the start of each test case, the judge will determine all customers' preferences. That is, it will use a (hidden) list of probabilities $P_i$ between 0.005 and 0.1, one for each flavor; each customer has a probability $P_i$ of liking the i-th flavor. That is, the random variables indicating whether customer j likes flavor i are independent and identically distributed. These preferences are constant throughout the test and will not be modified e.g. in response to your choices.\n\n**Test set 1 (29 Pts, Visible)**\n\n- $\\mathbf{T} = 50.$\n- $\\mathbf{N} = 200.$\n- $0 \\leqslant \\mathbf{D} \\leqslant \\mathbf{N}.$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #1C] Lollipop Shop", "background": null, "description": "你拥有一家棒棒糖店。在一天开始时，你制作了 $N$ 根棒棒糖，每根棒棒糖都有唯一的口味，比如越橘、樱桃或青柠。当天会有 $N$ 位顾客依次进入你的店铺。每位顾客会给你一份他们喜欢的棒棒糖口味列表。你可以卖给他们其中任意一种他们喜欢的口味的棒棒糖，只要这种口味的棒棒糖还没有在当天卖给其他人（因为每种口味只有一根棒棒糖）。如果他们喜欢的所有口味都已经卖完了，你就不能卖棒棒糖给他们，他们会失望地离开你的店。\n\n你在顾客到来之前并不知道他们的口味偏好。每位顾客会随机决定是否喜欢每种口味，这一决定与他们是否喜欢其他口味、以及其他人喜欢什么口味都无关。然而，你的市场调研显示，有些口味被喜欢的概率更高！例如，青柠口味被某位顾客喜欢的概率可能是 $10\\%$，而樱桃口味可能只有 $1\\%$。这些概率值总是独立且均匀地从区间 $[0.005, 0.1]$ 中随机选取。\n\n显然，你希望能卖出尽可能多的棒棒糖！但由于你事先不知道顾客的口味偏好，因此你无法总是做出最优决策——有时你可能会把某种口味卖给一位顾客，之后又希望当时卖给他们另一种口味。\n\n假设你能提前知道所有顾客的偏好并做好规划，那么你最多能卖出 $M$ 根棒棒糖。虽然你无法提前知道顾客的偏好，但本题要求你在每组输入中，卖出的棒棒糖数量至少达到 $M$ 的 $90\\%$。\n\n### 交互协议\n\n本题为交互题，这意味着输入输出方式与标准题目不同。你需要与一个独立的进程进行交互，该进程既向你提供信息，也会评判你的回答。所有信息都通过标准输入进入你的程序；你需要传递的信息应通过标准输出输出。请注意，许多编程语言默认会缓冲输出，因此请确保你的输出实际被发送出去（例如，通过刷新缓冲区），再等待下一步输入。详见 FAQ 关于刷新缓冲区的说明。你通过标准错误输出的内容会被忽略，但可能会占用内存并计入内存限制，因此请勿输出过多内容。\n\n最初，你的程序应读取一行，包含一个整数 $\\mathbf{T}$，表示测试用例的数量。然后，你需要处理 $\\mathbf{T}$ 组测试数据。\n\n对于每组测试数据，你的程序应读取一行，包含一个整数 $\\mathbf{N}$，表示棒棒糖的数量（也等于顾客数量）。\n\n接下来，对于每位顾客，你的程序应读取一行，包含若干用空格分隔的整数。第一个整数为 $\\mathbf{D}$，表示该顾客喜欢的口味数量。接下来有 $\\mathbf{D}$ 个整数，表示这些口味的编号，严格递增。口味编号唯一，范围为 $[0, \\mathbf{N} - 1]$。注意，有些顾客的 $\\mathbf{D}$ 可能为零。\n\n在每一行顾客信息后，你的程序必须输出一行，包含一个整数，表示你卖给该顾客的口味编号（必须是他们喜欢且尚未卖出的口味），或者输出 $-1$ 表示不卖棒棒糖给该顾客。在每组测试数据的第 $\\mathbf{N}$ 行输出后，如果这是最后一组测试数据，程序应终止；否则，继续读取下一组测试数据。\n\n如果你的程序出现错误（例如，尝试卖出已经卖掉的口味，或者卖给顾客他们不喜欢的口味，或者输出格式错误，或者输出超出范围的值），评测机会向你的输入流发送 $-1$，并且不会再发送其他输出。如果你的程序在收到 $-1$ 后仍然等待评测机输入，则会超时，导致超时错误。请注意，程序应自行及时退出，以获得正确的判题结果（如 Wrong Answer、Runtime Error 等），而不是超时。如果总时间或内存超限，或程序运行时出错，也会得到相应的判题结果。如果某组测试数据卖出的棒棒糖数量不足，不会导致收到 $-1$。\n\n在处理完所有测试数据后，不要再向评测机输出任何内容。换句话说，如果你的程序在最后一组测试数据后仍然输出内容，将会被判为 Wrong Answer。\n\n你可以使用本地测试工具进行测试。要在本地测试，你需要让测试工具与你的代码并行运行；可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释说明。\n\n测试工具的使用说明已包含在工具的注释中。我们鼓励你添加自己的测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真实的评测系统，行为可能有所不同。\n\n**关于评测机行为的说明**\n\n在每组测试数据开始时，评测机会确定所有顾客的偏好。即，对于每种口味，评测机会生成一个（隐藏的）概率列表 $P_i$，每个 $P_i$ 取值在 $[0.005, 0.1]$ 之间；每位顾客喜欢第 $i$ 种口味的概率为 $P_i$。也就是说，顾客 $j$ 是否喜欢口味 $i$ 的随机变量是独立同分布的。这些偏好在整个测试过程中保持不变，不会因你的选择而改变。\n\n**测试点 1（29 分，公开）**\n\n- $\\mathbf{T} = 50$。\n- $\\mathbf{N} = 200$。\n- $0 \\leqslant \\mathbf{D} \\leqslant \\mathbf{N}$。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "请注意，以下样例交互中的 $\\mathbf T$ 和 $\\mathbf N$ 都比真实数据要小。用于本地测试的工具也使用更小的样例。\n\n```\n  t = readline_int()           // 读取 t，值为 10\n  n = readline_int()           // 读取 n，值为 4（4 位顾客和 4 种口味）\n  prefs = readline_int_list()  // 读取 1 2（顾客只喜欢口味 2）\n  printline 2 to stdout        // 卖给该顾客口味 2\n  flush stdout\n  prefs = readline_int_list()  // 读取 0（顾客什么都不喜欢）\n  printline -1 to stdout       // 没有可卖的口味！\n  flush stdout\n  prefs = readline_int_list()  // 读取 1 2（顾客只喜欢口味 2）\n  printline -1 to stdout       // 口味 2 已经卖出，无法再卖\n  flush stdout\n  prefs = readline_int_list()  // 读取 2 1 3（顾客喜欢 1 和 3）\n  printline 3 to stdout        // 注意：也可以卖 1\n  flush stdout\n  n = readline_int()           // （第二组数据开始）读取 1\n  prefs = readline_int_list()  // 读取 1 0\n  printline -1 to stdout       // 非最优但合法的选择\n  flush stdout\n  n = readline_int()           // （第三组数据开始）读取 5\n  prefs = readline_int_list()  // 读取 2 1 3\n  printline 1 to stdout\n  flush stdout\n  prefs = readline_int_list()  // 读取 2 1 2\n  printline 1 to stdout        // 错误——尝试重复卖出同一口味！\n  flush stdout\n  prefs = readline_int_list()  // 读取 -1（评测机放弃评测）\n  exit                         // 退出，避免超时\n```\n\n上述伪代码演示了如下场景：\n\n- 第一组数据，程序共卖出两根棒棒糖。无法卖出更多，因此实际卖出数量肯定至少为最大可能数量的 $90\\%$。\n- 第二组数据，程序（仅为演示）选择不卖棒棒糖，虽然本可以卖。实际卖出 0 根，最大可卖 1 根。因此该组数据无法通过测试，但不会导致评测机停止输入。\n- 第三组数据，程序出现错误（同样仅为演示），导致评测机停止输入。程序识别到这一点并终止。用户会看到 Wrong Answer 判定。\n\n# 输入格式\n\n见交互协议。\n\n# 输出格式\n\n见交互协议。\n\n# 提示\n\n请注意，以下样例交互中的 $\\mathbf T$ 和 $\\mathbf N$ 都比真实数据要小。用于本地测试的工具也使用更小的样例。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13144", "type": "P", "difficulty": 5, "samples": [["3\n2\n9 1\n3\n8 4 100\n9\n10 10 10 10 10 10 10 10 100", "Case #1: 1\nCase #2: 3\nCase #3: 8"]], "limits": {"time": [15000, 15000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2018", "Google Code Jam"], "title": "[GCJ 2018 #1C] Ant Stack", "background": "", "description": "Scott has an ant farm containing $\\mathbf{N}$ ants. Each ant has a certain length and weight.\n\nToday, as a challenge for the ants, Scott has placed some food at the top of the ant farm. The ants will try to reach it by arranging themselves into a vertical stack, with each ant in the stack directly holding the next on its back. In this way, each ant bears the weight of all ants above it. Scott's ants are very strong for their size and are able to carry up to 6 times their own weight. For example, an ant that weighs 8 milligrams can carry two other ants weighing 24 milligrams each! Each ant also has a body length; the exact lengths are not important, except that they are all different.\n\n* The stack must be linear. Each ant except for the top ant must be directly below exactly one ant, and each ant except for the bottom ant must be directly above exactly one ant.\n* The lengths of the ants in the stack must be strictly decreasing from the bottom to the top of the stack; this ensures that each new ant that joins the stack will be able to climb up to the top.\n* For each ant, the sum of the weights of all the ants above it in the stack must be no more than 6 times the weight of that ant.\n\nWhat is the maximum number of these ants that can form such a stack?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with an integer $\\mathbf{N}$: the number of ants in the colony. Then, a second line follows containing $\\mathbf{N}$ integers $\\mathbf{W}_1, \\mathbf{W}_2, ..., \\mathbf{W}_\\mathbf{N}$, where $\\mathbf{W}_\\mathbf{i}$ is the weight in milligrams of the i-th ant. The ants are listed in strictly increasing order of length. Notice that no actual length values are given; only the order is important.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of the given ants that can form a stack that obeys the rules above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are two ants. The first weighs 9 mg; the second weighs 1 mg, and is longer than the first ant. The first ant is strong enough to hold the second ant (since it can hold up to $9 \\times 6$ mg), but it cannot, because the second ant is longer. The second ant is not strong enough to hold the first ant (since it can only hold up to $1 \\times 6$ mg, which is less than 9 mg). So it is only possible to make a \"stack\" of one of the two ants.\n\nIn Sample Case #2, it is possible for all three ants to form a stack, with the third holding up the second, which holds up the first.\n\nIn Sample Case #3, the optimal solution has the ninth ant on the bottom, and then seven of the other ants above it.\n\n**Limits**\n\n- $7 \\leqslant \\mathbf{T} \\leqslant 100.$\n\n**Test set 1 (16 Pts, Visible)**\n\n- For exactly 6 cases, $\\mathbf{N} = 100$; for the other $\\mathbf{T} - 6$ cases, $2 \\leqslant \\mathbf{N} \\leqslant 50.$\n- $1 \\leqslant \\mathbf{W}_\\mathbf{i} \\leqslant 1000,$ for all $i$.\n\n**Test set 2 (27 Pts, Hidden)**\n\n- For exactly 6 cases, $\\mathbf{N} = 10^5$; for the other $\\mathbf{T} - 6$ cases, $2 \\leqslant \\mathbf{N} \\leqslant 500.$\n- $1 \\leqslant \\mathbf{W}_\\mathbf{i} \\leqslant 10^9,$ for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #1C] Ant Stack", "background": "", "description": "Scott has an ant farm containing $\\mathbf{N}$ ants. Each ant has a certain length and weight.\n\nToday, as a challenge for the ants, Scott has placed some food at the top of the ant farm. The ants will try to reach it by arranging themselves into a vertical stack, with each ant in the stack directly holding the next on its back. In this way, each ant bears the weight of all ants above it. Scott's ants are very strong for their size and are able to carry up to 6 times their own weight. For example, an ant that weighs 8 milligrams can carry two other ants weighing 24 milligrams each! Each ant also has a body length; the exact lengths are not important, except that they are all different.\n\n* The stack must be linear. Each ant except for the top ant must be directly below exactly one ant, and each ant except for the bottom ant must be directly above exactly one ant.\n* The lengths of the ants in the stack must be strictly decreasing from the bottom to the top of the stack; this ensures that each new ant that joins the stack will be able to climb up to the top.\n* For each ant, the sum of the weights of all the ants above it in the stack must be no more than 6 times the weight of that ant.\n\nWhat is the maximum number of these ants that can form such a stack?", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each begins with one line with an integer $\\mathbf{N}$: the number of ants in the colony. Then, a second line follows containing $\\mathbf{N}$ integers $\\mathbf{W}_1, \\mathbf{W}_2, ..., \\mathbf{W}_\\mathbf{N}$, where $\\mathbf{W}_\\mathbf{i}$ is the weight in milligrams of the i-th ant. The ants are listed in strictly increasing order of length. Notice that no actual length values are given; only the order is important.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of the given ants that can form a stack that obeys the rules above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there are two ants. The first weighs 9 mg; the second weighs 1 mg, and is longer than the first ant. The first ant is strong enough to hold the second ant (since it can hold up to $9 \\times 6$ mg), but it cannot, because the second ant is longer. The second ant is not strong enough to hold the first ant (since it can only hold up to $1 \\times 6$ mg, which is less than 9 mg). So it is only possible to make a \"stack\" of one of the two ants.\n\nIn Sample Case #2, it is possible for all three ants to form a stack, with the third holding up the second, which holds up the first.\n\nIn Sample Case #3, the optimal solution has the ninth ant on the bottom, and then seven of the other ants above it.\n\n**Limits**\n\n- $7 \\leqslant \\mathbf{T} \\leqslant 100.$\n\n**Test set 1 (16 Pts, Visible)**\n\n- For exactly 6 cases, $\\mathbf{N} = 100$; for the other $\\mathbf{T} - 6$ cases, $2 \\leqslant \\mathbf{N} \\leqslant 50.$\n- $1 \\leqslant \\mathbf{W}_\\mathbf{i} \\leqslant 1000,$ for all $i$.\n\n**Test set 2 (27 Pts, Hidden)**\n\n- For exactly 6 cases, $\\mathbf{N} = 10^5$; for the other $\\mathbf{T} - 6$ cases, $2 \\leqslant \\mathbf{N} \\leqslant 500.$\n- $1 \\leqslant \\mathbf{W}_\\mathbf{i} \\leqslant 10^9,$ for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #1C] Ant Stack", "background": null, "description": "Scott 有一个蚂蚁农场，里面有 $N$ 只蚂蚁。每只蚂蚁都有一定的体长和体重。\n\n今天，Scott 给蚂蚁们设置了一个挑战：他把一些食物放在蚂蚁农场的顶部。蚂蚁们会尝试通过把自己叠成一根竖直的“蚂蚁塔”来够到食物，每只蚂蚁都直接背着下一只蚂蚁。这样，每只蚂蚁都要承受其上方所有蚂蚁的重量。Scott 的蚂蚁们非常强壮，每只蚂蚁最多可以承受自身重量的 6 倍。例如，一只重 8 毫克的蚂蚁可以承受两只各重 24 毫克的蚂蚁！每只蚂蚁也有一个体长；具体长度不重要，只要它们的长度都不相同即可。\n\n- 蚂蚁塔必须是线性的。除了最顶上的蚂蚁外，每只蚂蚁正上方必须有且只有一只蚂蚁；除了最底下的蚂蚁外，每只蚂蚁正下方必须有且只有一只蚂蚁。\n- 蚂蚁塔中蚂蚁的体长必须从下到上严格递减；这保证了每只新加入蚂蚁都能顺利爬到顶部。\n- 对于塔中的每只蚂蚁，其上方所有蚂蚁的总重量不得超过该蚂蚁自身重量的 6 倍。\n\n请问最多能有多少只蚂蚁组成这样一根蚂蚁塔？", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据。每组数据的第一行为一个整数 $N$，表示蚂蚁的数量。第二行为 $N$ 个整数 $W_1, W_2, ..., W_N$，其中 $W_i$ 表示第 $i$ 只蚂蚁的重量（单位：毫克）。蚂蚁按照体长严格递增的顺序给出。注意，实际长度值未给出，只需关心顺序。", "outputFormat": "对于每组测试数据，输出一行 `Case #x: y`，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 表示最多能组成的蚂蚁塔的蚂蚁数量。", "hint": "**样例解释**\n\n在样例 1 中，有两只蚂蚁。第一只重 9 毫克，第二只重 1 毫克，且第二只比第一只体长更长。第一只蚂蚁足够强壮，可以承受第二只蚂蚁（因为它能承受 $9 \\times 6$ 毫克），但由于第二只蚂蚁体长更长，不能叠在第一只上。第二只蚂蚁无法承受第一只蚂蚁（因为它只能承受 $1 \\times 6$ 毫克，小于 9 毫克）。所以只能单独选其中一只蚂蚁组成“蚂蚁塔”。\n\n在样例 2 中，三只蚂蚁可以全部组成一根蚂蚁塔，第三只承受第二只，第二只承受第一只。\n\n在样例 3 中，最优解是第九只蚂蚁在最底下，其上方再叠七只其它蚂蚁。\n\n**数据范围**\n\n- $7 \\leqslant T \\leqslant 100$。\n\n**测试点 1（16 分，可见）**\n\n- 恰有 6 组数据 $N = 100$；其余 $T-6$ 组 $2 \\leqslant N \\leqslant 50$。\n- $1 \\leqslant W_i \\leqslant 1000$，对所有 $i$。\n\n**测试点 2（27 分，隐藏）**\n\n- 恰有 6 组数据 $N = 10^5$；其余 $T-6$ 组 $2 \\leqslant N \\leqslant 500$。\n- $1 \\leqslant W_i \\leqslant 10^9$，对所有 $i$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13145", "type": "P", "difficulty": 3, "samples": [["3\n4\n1 1 1 1\n3\n0 2 1\n6\n3 0 0 2 0 1", "Case #1: 1\n....\nCase #2: IMPOSSIBLE\nCase #3: 3\n.//\\..\n./\\./.\n......"]], "limits": {"time": [10000, 10000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2018", "Special Judge", "Google Code Jam"], "title": "[GCJ 2018 #2] Falling Balls", "background": "", "description": "A certain toy consists of a grid of 2 or more columns and 1 or more rows, where each cell of the grid contains either a $\\backslash$ ramp or a $/$ ramp, or is empty. The leftmost and rightmost columns are empty and the bottom row is also empty. Balls are dropped into the top row and fall vertically, sliding on ramps. To prevent balls from getting stuck, a cell with a $\\backslash$ ramp is never immediately to the left of a cell with a $/$ ramp.\n\nWhen a ball is dropped into the top row, it moves deterministically as follows:\n\n* A ball in an empty cell moves to the cell immediately below its current cell, unless it is in the bottom row, in which case it does not move any more.\n* A ball in a cell containing a $\\backslash$ ramp moves to the cell immediately below and to the right of its current cell.\n* A ball in a cell containing a $/$ ramp moves to the cell immediately below and to the left of its current cell.\n\nTo see the mechanism to its full extent, the user drops exactly one ball into each column. Balls do not interfere with each other, and it is possible for a cell to contain multiple balls.\n\nYour friend has a toy with $C$ columns and an unknown number of rows. They just dropped one ball into the top row of each column, and waited for all balls to stop moving. Then, they counted how many balls ended up in each of the cells of the bottom row, and gave you those results... but you think it is possible that they made a mistake. Can you create a layout that is consistent with the results and uses as few rows as possible, or determine that no such layout exists?\n\nFor example, if your friend reported the values $3 \\ 0 \\ 0 \\ 2 \\ 0 \\ 1$, one possible solution would be the following. (Note that it is not necessary to use a minimal number of ramps, or for every ramp to affect the balls.)\n\n```\n./\\\\...\n./\\.\\/.\n.......\n```\n\nHere are the paths that the balls would take when falling through that grid:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ia5vs05s.png)", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line containing an integer $C$: the number of columns in your friend's falling ball toy. Then, there is one more line containing $C$ integers $B_i$. The i-th of these integers represents the number of balls that ended up in the i-th cell from the left of the bottom row of your friend's falling ball toy, according to the data they gave you.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either IMPOSSIBLE, or the number of rows in your layout, as described above. If $y$ is not IMPOSSIBLE, output $y$ more rows, representing the rows of your proposed falling ball toy layout, in order from top to bottom. Use . to represent a cell with no ramp, and $\\backslash$ or $/$ to represent the ramps. The layout must obey all of the rules in the problem statement.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in Test set 1.\n\nThe following layout is the only valid solution for Sample Case #1. (There must be at least one row, and including any more rows would make the solution use more rows than needed. It is not legal to include any ramps in the bottom row.)\n\n```\n....\n```\nIn Sample Case #2, there is no way to prevent the leftmost ball from falling to the bottom of its column without adding a ramp, but ramps cannot be added to that column.\n\nSample Case #3 is the one described at the end of the problem statement. Note that the following invalid layout for Sample Case #3 breaks several rules: it has more rows than needed, it has ramps in the three illegal zones (left column, right column, bottom row), and it contains a $\\backslash$ ramp immediately to the left of a $/$ ramp.\n\n```\n\\\\..\\/\n../.\\/\n./../.\n..../.\n```\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $0 \\leq B_i \\leq C$, for all $i$.\n- The sum (over all $i$ from 1 to $C$, inclusive) of all $B_i$ values = $C$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $2 \\leq C \\leq 5$.\n\n**Test set 2 (12 Pts, Hidden)**\n\n- $2 \\leq C \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #2] Falling Balls", "background": "", "description": "A certain toy consists of a grid of 2 or more columns and 1 or more rows, where each cell of the grid contains either a $\\backslash$ ramp or a $/$ ramp, or is empty. The leftmost and rightmost columns are empty and the bottom row is also empty. Balls are dropped into the top row and fall vertically, sliding on ramps. To prevent balls from getting stuck, a cell with a $\\backslash$ ramp is never immediately to the left of a cell with a $/$ ramp.\n\nWhen a ball is dropped into the top row, it moves deterministically as follows:\n\n* A ball in an empty cell moves to the cell immediately below its current cell, unless it is in the bottom row, in which case it does not move any more.\n* A ball in a cell containing a $\\backslash$ ramp moves to the cell immediately below and to the right of its current cell.\n* A ball in a cell containing a $/$ ramp moves to the cell immediately below and to the left of its current cell.\n\nTo see the mechanism to its full extent, the user drops exactly one ball into each column. Balls do not interfere with each other, and it is possible for a cell to contain multiple balls.\n\nYour friend has a toy with $C$ columns and an unknown number of rows. They just dropped one ball into the top row of each column, and waited for all balls to stop moving. Then, they counted how many balls ended up in each of the cells of the bottom row, and gave you those results... but you think it is possible that they made a mistake. Can you create a layout that is consistent with the results and uses as few rows as possible, or determine that no such layout exists?\n\nFor example, if your friend reported the values $3 \\ 0 \\ 0 \\ 2 \\ 0 \\ 1$, one possible solution would be the following. (Note that it is not necessary to use a minimal number of ramps, or for every ramp to affect the balls.)\n\n```\n./\\\\...\n./\\.\\/.\n.......\n```\n\nHere are the paths that the balls would take when falling through that grid:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ia5vs05s.png)", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line containing an integer $C$: the number of columns in your friend's falling ball toy. Then, there is one more line containing $C$ integers $B_i$. The i-th of these integers represents the number of balls that ended up in the i-th cell from the left of the bottom row of your friend's falling ball toy, according to the data they gave you.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either IMPOSSIBLE, or the number of rows in your layout, as described above. If $y$ is not IMPOSSIBLE, output $y$ more rows, representing the rows of your proposed falling ball toy layout, in order from top to bottom. Use . to represent a cell with no ramp, and $\\backslash$ or $/$ to represent the ramps. The layout must obey all of the rules in the problem statement.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in Test set 1.\n\nThe following layout is the only valid solution for Sample Case #1. (There must be at least one row, and including any more rows would make the solution use more rows than needed. It is not legal to include any ramps in the bottom row.)\n\n```\n....\n```\nIn Sample Case #2, there is no way to prevent the leftmost ball from falling to the bottom of its column without adding a ramp, but ramps cannot be added to that column.\n\nSample Case #3 is the one described at the end of the problem statement. Note that the following invalid layout for Sample Case #3 breaks several rules: it has more rows than needed, it has ramps in the three illegal zones (left column, right column, bottom row), and it contains a $\\backslash$ ramp immediately to the left of a $/$ ramp.\n\n```\n\\\\..\\/\n../.\\/\n./../.\n..../.\n```\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $0 \\leq B_i \\leq C$, for all $i$.\n- The sum (over all $i$ from 1 to $C$, inclusive) of all $B_i$ values = $C$.\n\n**Test set 1 (5 Pts, Visible)**\n\n- $2 \\leq C \\leq 5$.\n\n**Test set 2 (12 Pts, Hidden)**\n\n- $2 \\leq C \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #2] Falling Balls", "background": null, "description": "某种玩具由一个有 $2$ 列或更多列、$1$ 行或更多行的网格组成，网格的每个格子中要么放有一个 $\\backslash$ 斜坡，要么放有一个 $/$ 斜坡，要么为空。最左边和最右边的两列始终为空，最底下一行也始终为空。小球会从最顶上一行的每一列各投放一个，并垂直下落，遇到斜坡会滑动。为了防止小球卡住，任意一个放有 $\\backslash$ 斜坡的格子左侧，绝不会紧挨着一个放有 $/$ 斜坡的格子。\n\n当一个小球从顶行落下时，它的移动规则如下：\n\n- 如果小球当前在一个空格子中，则会直接落到正下方的格子，除非已经在最底行，此时小球不再移动。\n- 如果小球当前在一个放有 $\\backslash$ 斜坡的格子中，则会落到右下方的格子。\n- 如果小球当前在一个放有 $/$ 斜坡的格子中，则会落到左下方的格子。\n\n为了完整展示这个机制，用户会在每一列的顶行各投放一个小球。小球之间互不影响，一个格子中可以有多个小球。\n\n你的朋友有这样一个玩具，列数为 $C$，行数未知。他在每一列的顶行各投放了一个小球，等所有小球都停止移动后，统计了每个底行格子里最终有多少个小球，并把这个结果告诉了你……但你怀疑他可能记错了。你能否构造出一个满足这些结果的布局，并且使用尽可能少的行数？或者判断根本不存在这样的布局？\n\n例如，如果你朋友报告的底行结果是 $3\\ 0\\ 0\\ 2\\ 0\\ 1$，一种可能的解法如下（注意不要求斜坡数量最少，也不要求每个斜坡都必须影响小球的路径）：\n\n```\n./\\\\...\n./\\.\\/.\n.......\n```\n\n下图展示了小球在该网格中的下落路径：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ia5vs05s.png)", "inputFormat": "第一行输入测试用例数 $T$。接下来有 $T$ 组测试数据。每组数据第一行为一个整数 $C$，表示朋友的玩具有多少列。接下来一行有 $C$ 个整数 $B_i$，第 $i$ 个整数表示朋友统计的底行从左到右第 $i$ 个格子里最终有多少个小球。", "outputFormat": "对于每组测试数据，输出一行 `Case #x: y`，其中 $x$ 是测试编号（从 $1$ 开始），$y$ 是你构造的布局所需的最少行数，或者如果不存在这样的布局则输出 `IMPOSSIBLE`。如果 $y$ 不是 `IMPOSSIBLE`，则接下来输出 $y$ 行，依次表示你构造的玩具布局的每一行，从上到下。用 `.` 表示空格子，`\\` 或 `/` 分别表示对应的斜坡。布局必须满足题目中的所有规则。", "hint": "**样例解释**\n\n注意，最后一个样例不会出现在测试集 1 中。\n\n对于样例 1，唯一的有效解法如下（必须至少有一行，增加更多行会导致行数不最少。底行不能有任何斜坡）：\n\n```\n....\n```\n对于样例 2，没有办法阻止最左边的小球直接落到底部，因为那一列不能放斜坡。\n\n样例 3 就是题目描述最后给出的例子。注意，下面这个布局是非法的，因为它有多余的行数，左、右边界和底行都放了斜坡，而且出现了 $/$ 斜坡左侧紧挨着 $\\backslash$ 斜坡的情况：\n\n```\n\\\\..\\/\n../.\\/\n./../.\n..../.\n```\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $0 \\leq B_i \\leq C$，对所有 $i$ 均成立。\n- 所有 $B_i$ 之和等于 $C$。\n\n**测试集 1（5 分，公开）**\n\n- $2 \\leq C \\leq 5$。\n\n**测试集 2（12 分，隐藏）**\n\n- $2 \\leq C \\leq 100$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13146", "type": "P", "difficulty": 4, "samples": [["2\n2 0\n4 5", "Case #1: 1\nCase #2: 5"]], "limits": {"time": [25000, 25000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2018", "记忆化搜索", "Google Code Jam"], "title": "[GCJ 2018 #2] Graceful Chainsaw Jugglers", "background": "", "description": "You are the manager of the Graceful Chainsaw Jugglers performance group, and you are trying to succeed in the very competitive chainsaw juggling business. You have an unlimited number of identical talented jugglers, and each of them knows how to juggle any number of chainsaws. To run a show, you will choose some number of jugglers, and then distribute your red chainsaws and blue chainsaws among them, so that each juggler gets at least one chainsaw. For example, one juggler might juggle two red chainsaws and three blue chainsaws, and another juggler might juggle just one red chainsaw. During the show, each chainsaw is used by only one juggler; the jugglers do not pass chainsaws around, because it is already hard enough just to juggle them!\n\nAccording to your market research, your audience is happiest when the show uses as many jugglers and chainsaws as possible, but the audience also demands variety: no two jugglers in the show can use both the same number of red chainsaws and the same number of blue chainsaws.\n\nYou have $R$ red chainsaws and $B$ blue chainsaws, and you must use all of them in the show. What is the largest number of jugglers that you can use in the show while satisfying the audience's demands?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$; $T$ test cases follow. Each test case consists of one line with two integers $R$ and $B$: the numbers of red and blue chainsaws that you must use in the show.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the largest number of jugglers that you can use in the show while satisfying the audience's demands, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the only possible strategy is to give both red chainsaws to one juggler.\n\nIn Sample Case #2, one optimal strategy is to have:\n\n- one juggler with one red chainsaw\n- one juggler with two red chainsaws\n- one juggler with one blue chainsaw\n- one juggler with three blue chainsaws\n- one juggler with one red chainsaw and one blue chainsaw\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $R + B > 0$.\n\n**Test set 1 (7 Pts, Visible)**\n\n- $0 \\leq R \\leq 50$.\n- $0 \\leq B \\leq 50$.\n\n**Test set 2 (17 Pts, Hidden)**\n\n- $0 \\leq R \\leq 500$.\n- $0 \\leq B \\leq 500$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #2] Graceful Chainsaw Jugglers", "background": "", "description": "You are the manager of the Graceful Chainsaw Jugglers performance group, and you are trying to succeed in the very competitive chainsaw juggling business. You have an unlimited number of identical talented jugglers, and each of them knows how to juggle any number of chainsaws. To run a show, you will choose some number of jugglers, and then distribute your red chainsaws and blue chainsaws among them, so that each juggler gets at least one chainsaw. For example, one juggler might juggle two red chainsaws and three blue chainsaws, and another juggler might juggle just one red chainsaw. During the show, each chainsaw is used by only one juggler; the jugglers do not pass chainsaws around, because it is already hard enough just to juggle them!\n\nAccording to your market research, your audience is happiest when the show uses as many jugglers and chainsaws as possible, but the audience also demands variety: no two jugglers in the show can use both the same number of red chainsaws and the same number of blue chainsaws.\n\nYou have $R$ red chainsaws and $B$ blue chainsaws, and you must use all of them in the show. What is the largest number of jugglers that you can use in the show while satisfying the audience's demands?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$; $T$ test cases follow. Each test case consists of one line with two integers $R$ and $B$: the numbers of red and blue chainsaws that you must use in the show.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the largest number of jugglers that you can use in the show while satisfying the audience's demands, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the only possible strategy is to give both red chainsaws to one juggler.\n\nIn Sample Case #2, one optimal strategy is to have:\n\n- one juggler with one red chainsaw\n- one juggler with two red chainsaws\n- one juggler with one blue chainsaw\n- one juggler with three blue chainsaws\n- one juggler with one red chainsaw and one blue chainsaw\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $R + B > 0$.\n\n**Test set 1 (7 Pts, Visible)**\n\n- $0 \\leq R \\leq 50$.\n- $0 \\leq B \\leq 50$.\n\n**Test set 2 (17 Pts, Hidden)**\n\n- $0 \\leq R \\leq 500$.\n- $0 \\leq B \\leq 500$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #2] Graceful Chainsaw Jugglers", "background": "", "description": "你是 Graceful Chainsaw Jugglers 表演团的经理，正在努力在竞争激烈的链锯杂耍行业中取得成功。你拥有无限数量的相同且才华横溢的杂耍演员，每位演员都能杂耍任意数量的链锯。为了举办一场表演，你需要选择若干名杂耍演员，然后将你所有的红色链锯和蓝色链锯分配给他们，使得每位演员至少获得一把链锯。例如，一位演员可以杂耍两把红色链锯和三把蓝色链锯，另一位演员则只杂耍一把红色链锯。在表演过程中，每把链锯只能由一名演员使用；演员之间不会传递链锯，因为仅仅杂耍链锯就已经够难了！\n\n根据市场调研，观众在演员和链锯数量尽可能多的情况下最为满意，但观众也要求多样性：表演中的任意两位演员，不能同时拥有相同数量的红色链锯和相同数量的蓝色链锯。\n\n你有 $R$ 把红色链锯和 $B$ 把蓝色链锯，必须全部用于表演。请问，在满足观众要求的前提下，最多可以安排多少名杂耍演员参与表演？", "inputFormat": "输入的第一行为测试用例数 $T$，接下来有 $T$ 组测试用例。每组测试用例包含一行两个整数 $R$ 和 $B$，分别表示你必须用于表演的红色链锯和蓝色链锯的数量。", "outputFormat": "对于每组测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为在满足观众要求的前提下，最多可以安排的杂耍演员数量。", "hint": "**样例解释**\n\n在样例 1 中，唯一可行的方案是将两把红色链锯都分给一名演员。\n\n在样例 2 中，一种最优方案如下：\n\n- 一名演员有一把红色链锯\n- 一名演员有两把红色链锯\n- 一名演员有一把蓝色链锯\n- 一名演员有三把蓝色链锯\n- 一名演员有一把红色链锯和一把蓝色链锯\n\n**限制**\n\n- $1 \\leq T \\leq 100$。\n- $R + B > 0$。\n\n**测试点 1（7 分，可见）**\n\n- $0 \\leq R \\leq 50$。\n- $0 \\leq B \\leq 50$。\n\n**测试点 2（17 分，隐藏）**\n\n- $0 \\leq R \\leq 500$。\n- $0 \\leq B \\leq 500$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13147", "type": "P", "difficulty": 5, "samples": [["4\n2\n1 2\n2 1\n2\n1 1\n2 1\n2\n1 2\n1 2\n2\n2 2\n-2 2", "Case #1: 0\nCase #2: 1\nCase #3: 2\nCase #4: 1"]], "limits": {"time": [15000, 15000], "memory": [1048576, 1048576]}, "tags": ["2018", "二分图", "Google Code Jam"], "title": "[GCJ 2018 #2] Costume Change", "background": "", "description": "Supervin is a well-known choreographer. Today is the $N$-th anniversary of his choreography career. To celebrate it, he is planning a dance on a stage that is a square grid of size $N$ by $N$. Exactly one dancer will stand in each grid cell.\n\nEach dancer will wear a costume; each costume has a single color, and is made out of either wool or cotton as its material. Supervin has $N$ colors to choose from when designing the costumes for his dancers, indexed from 1 to $N$.\n\nEach dancer wants to feel special. If two or more dancers share a row or column and also have costumes of the same color and material, they will no longer feel special.\n\nSupervin wants all of his dancers to feel special. Therefore, Supervin is prepared to change the color and/or material of dancers' costumes so that no dancer shares a row or column with another dancer with the same costume (same color and same material). What is the minimum number of dancers whose costumes must be changed in order to make this happen? (Note that a change to both the color and material of a costume still counts as only one change.)", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line containing an integer $N$: the side length (in unit cells) of the square grid of dancers. Then, $N$ lines follow; each contains $N$ non-zero integers $A_{i,j}$. The $j$-th value on the $i$-th line represents the costume of the dancer in the $i$-th row and $j$-th column of the grid. The magnitude of the value gives the color and the sign of the value gives the material (- for wool, + for cotton).\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of dancers whose costumes must be changed, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, no costumes need to be changed, since no dancer shares a row or column with another dancer with the same costume.\n\nIn Sample Case #2, one optimal solution is to change the value of $\\mathbf A$ into the following (bold indicates changed values):\n\n```\n  1 -2\n  2 1\n```\n\nOther optimal solutions are possible. Note that changing both the color and the material of a dancer's costume only counts as one change.\n\nIn Sample Case #3, one optimal solution is to change the value of $\\mathbf A$ into the following (bold indicates changed values):\n\n```\n  1 2\n  2 1\n```\n\nOther optimal solutions are possible.\n\nIn Sample Case #4, one optimal solution is to change the value of $\\mathbf A$ into the following (bold indicates changed values):\n\n```\n  2 -2\n  -2 2\n```\n\nOther optimal solutions are possible.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $-N \\leq A_{i,j} \\leq N$, for all $i, j$.\n- $A_{i,j} \\neq 0$, for all $i, j$.\n\n**Test set 1 (7 Pts, Visible)**\n\n- $2 \\leq N \\leq 4$.\n\n**Test set 2 (17 Pts, Hidden)**\n\n- $2 \\leq N \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #2] Costume Change", "background": "", "description": "Supervin is a well-known choreographer. Today is the $N$-th anniversary of his choreography career. To celebrate it, he is planning a dance on a stage that is a square grid of size $N$ by $N$. Exactly one dancer will stand in each grid cell.\n\nEach dancer will wear a costume; each costume has a single color, and is made out of either wool or cotton as its material. Supervin has $N$ colors to choose from when designing the costumes for his dancers, indexed from 1 to $N$.\n\nEach dancer wants to feel special. If two or more dancers share a row or column and also have costumes of the same color and material, they will no longer feel special.\n\nSupervin wants all of his dancers to feel special. Therefore, Supervin is prepared to change the color and/or material of dancers' costumes so that no dancer shares a row or column with another dancer with the same costume (same color and same material). What is the minimum number of dancers whose costumes must be changed in order to make this happen? (Note that a change to both the color and material of a costume still counts as only one change.)", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line containing an integer $N$: the side length (in unit cells) of the square grid of dancers. Then, $N$ lines follow; each contains $N$ non-zero integers $A_{i,j}$. The $j$-th value on the $i$-th line represents the costume of the dancer in the $i$-th row and $j$-th column of the grid. The magnitude of the value gives the color and the sign of the value gives the material (- for wool, + for cotton).\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum number of dancers whose costumes must be changed, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, no costumes need to be changed, since no dancer shares a row or column with another dancer with the same costume.\n\nIn Sample Case #2, one optimal solution is to change the value of $\\mathbf A$ into the following (bold indicates changed values):\n\n```\n  1 -2\n  2 1\n```\n\nOther optimal solutions are possible. Note that changing both the color and the material of a dancer's costume only counts as one change.\n\nIn Sample Case #3, one optimal solution is to change the value of $\\mathbf A$ into the following (bold indicates changed values):\n\n```\n  1 2\n  2 1\n```\n\nOther optimal solutions are possible.\n\nIn Sample Case #4, one optimal solution is to change the value of $\\mathbf A$ into the following (bold indicates changed values):\n\n```\n  2 -2\n  -2 2\n```\n\nOther optimal solutions are possible.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $-N \\leq A_{i,j} \\leq N$, for all $i, j$.\n- $A_{i,j} \\neq 0$, for all $i, j$.\n\n**Test set 1 (7 Pts, Visible)**\n\n- $2 \\leq N \\leq 4$.\n\n**Test set 2 (17 Pts, Hidden)**\n\n- $2 \\leq N \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #2] Costume Change", "background": null, "description": "Supervin 是一位著名的编舞家。今天是他编舞生涯的第 $N$ 周年。为此，他计划在一个 $N \\times N$ 的正方形舞台上编排一场舞蹈。每个格子上恰好站着一名舞者。\n\n每位舞者都将穿着一套服装；每套服装只有一种颜色，并且材质为羊毛或棉布。Supervin 在为舞者设计服装时有 $N$ 种颜色可选，编号为 $1$ 到 $N$。\n\n每位舞者都希望自己与众不同。如果同一行或同一列中有两位或更多舞者穿着颜色和材质都相同的服装，他们就不会感到特别。\n\nSupervin 希望所有舞者都能感到特别。因此，他准备更改一些舞者服装的颜色和/或材质，使得没有任何两位舞者在同一行或同一列中穿着完全相同的服装（即颜色和材质都相同）。请问，最少需要更改多少位舞者的服装，才能满足上述要求？（注意，更改服装的颜色和材质都只算作一次更改。）", "inputFormat": "输入的第一行是测试用例的数量 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为一个整数 $N$，表示舞台的边长。接下来的 $N$ 行，每行包含 $N$ 个非零整数 $A_{i,j}$。第 $i$ 行第 $j$ 列的值表示第 $i$ 行第 $j$ 列舞者的服装。数值的绝对值表示颜色，符号表示材质（负号表示羊毛，正号表示棉布）。", "outputFormat": "对于每组测试数据，输出一行 `Case #x: y`，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 表示最少需要更改服装的舞者人数。", "hint": "**样例解释**\n\n在样例 1 中，不需要更改任何服装，因为没有舞者在同一行或同一列中穿着完全相同的服装。\n\n在样例 2 中，一种最优方案是将 $\\mathbf A$ 更改为如下（加粗表示更改过的值）：\n\n```\n  1 -2\n  2 1\n```\n\n也存在其他最优方案。注意，更改服装的颜色和材质都只算作一次更改。\n\n在样例 3 中，一种最优方案是将 $\\mathbf A$ 更改为如下（加粗表示更改过的值）：\n\n```\n  1 2\n  2 1\n```\n\n也存在其他最优方案。\n\n在样例 4 中，一种最优方案是将 $\\mathbf A$ 更改为如下（加粗表示更改过的值）：\n\n```\n  2 -2\n  -2 2\n```\n\n也存在其他最优方案。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- 对所有 $i, j$，$-N \\leq A_{i,j} \\leq N$。\n- 对所有 $i, j$，$A_{i,j} \\neq 0$。\n\n**测试点 1（7 分，公开）**\n\n- $2 \\leq N \\leq 4$。\n\n**测试点 2（17 分，隐藏）**\n\n- $2 \\leq N \\leq 100$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13148", "type": "P", "difficulty": 5, "samples": [["5\n3 3\nBBB\nBWB\nBBB\n2 3\nBBB\nWBW\n1 1\nW\n3 3\nWBW\nBWB\nWBW\n2 4\nBBWW\nBBWW", "Case #1: 8\nCase #2: 5\nCase #3: 1\nCase #4: 4\nCase #5: 8"]], "limits": {"time": [30000, 30000], "memory": [1048576, 1048576]}, "tags": ["搜索", "2018", "Google Code Jam"], "title": "[GCJ 2018 #2] Gridception", "background": "", "description": "The master thief Jom Codd is able to infiltrate the dreams of others. Since dream-viewing technology is not very good yet, Codd sees a dream as a dream grid of unit cells, each of which is white or black.\n\nGiven a starting dream grid, Codd can go deeper by replacing each white cell with a $2\\times 2$ grid of white cells, and each black cell with a $2\\times 2$ grid of black cells; this creates a new dream grid that is four times larger. He can go deeper again from that grid, and so on. For example, given this starting dream grid:\n\n```\nBBB\nBWB\nBBB\n```\n\nthen going deeper once produces this new dream grid:\n\n```\nBBBBBB\nBBBBBB\nBBWWBB\nBBWWBB\nBBBBBB\nBBBBBB\n```\n\nand going deeper again produces this new dream grid:\n\n```\nBBBBBBBBBBBB\nBBBBBBBBBBBB\nBBBBBBBBBBBB\nBBBBBBBBBBBB\nBBBBWWWWBBBB\nBBBBWWWWBBBB\nBBBBWWWWBBBB\nBBBBWWWWBBBB\nBBBBBBBBBBBB\nBBBBBBBBBBBB\nBBBBBBBBBBBB\nBBBBBBBBBBBB\n```\n\nand so on.\n\nCodd has just infiltrated a dream and viewed its starting dream grid. He is on a very difficult mission, and he knows that he will need to go deeper many times. To help him navigate, he is looking at various patterns in the starting dream grid. A pattern consists of a single group of cells connected by shared edges (shared corners do not count as connections), plus their colors. A pattern might contain internal gaps (as long as the pattern's cells are a single connected group); such gaps are not considered part of the pattern. Two patterns are the same if and only if they have the same number and arrangement of cells (not reflected or rotated), with the same colors.\n\nFor example, in the grids above, the following $8$-cell pattern is present in the starting grid:\n\n```\nBBB\nB B\nBBB\n```\n\nIt is not present after going deeper once, but it is present after going deeper twice, and three times, and so on for every deeper dream grid.\n\nCodd wants to find the largest pattern from the starting dream grid that will be present in at least a googol ($10^{100}$) of deeper dream grids. For the given example, the pattern above is the largest such pattern. Even though it is not present after going deeper once, it is present in at least a googol of deeper levels. Other such patterns of smaller sizes also meet this condition, but there is no $9$-cell pattern that does; the only such pattern would have to be identical to the entire starting dream grid, and that pattern will never show up in any deeper dream grid, let alone in a googol of them.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with two integers $R$ and $C$: the numbers of rows and columns, respectively, in the dream grid. Each case continues with $R$ more lines of $C$ characters each; every such character is either `B` or `W`. These lines directly represent the dream grid.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the largest possible size of at least one pattern that meets Codd's requirements, as described above.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one described in the problem statement.\n\nIn Sample Case #2, one possible largest pattern is:\n\n```\nBBB\nWB\n```\n\nAnother equally large one is:\n\n```\nBBB\nW W\n```\n\nIn Sample Case #3, the entire starting dream grid is a largest pattern.\n\nIn Sample Case #4, note that the five Ws would not form a valid pattern, because they are not connected. However, this is a largest pattern:\n\n```\nWB\nBW\n```\n\nIn Sample Case #5, the entire starting dream grid is a largest pattern. Note that even though this grid happens to be what Codd would get by going deeper starting from BW, that is irrelevant; Codd will never \"go shallower\".\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $1 \\leq R \\leq 3$.\n- $1 \\leq C \\leq 4$.\n\n**Test set 2 (22 Pts, Hidden)**\n\n- $1 \\leq R \\leq 20$.\n- $1 \\leq C \\leq 20$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #2] Gridception", "background": "", "description": "The master thief Jom Codd is able to infiltrate the dreams of others. Since dream-viewing technology is not very good yet, Codd sees a dream as a dream grid of unit cells, each of which is white or black.\n\nGiven a starting dream grid, Codd can go deeper by replacing each white cell with a $2\\times 2$ grid of white cells, and each black cell with a $2\\times 2$ grid of black cells; this creates a new dream grid that is four times larger. He can go deeper again from that grid, and so on. For example, given this starting dream grid:\n\n```\nBBB\nBWB\nBBB\n```\n\nthen going deeper once produces this new dream grid:\n\n```\nBBBBBB\nBBBBBB\nBBWWBB\nBBWWBB\nBBBBBB\nBBBBBB\n```\n\nand going deeper again produces this new dream grid:\n\n```\nBBBBBBBBBBBB\nBBBBBBBBBBBB\nBBBBBBBBBBBB\nBBBBBBBBBBBB\nBBBBWWWWBBBB\nBBBBWWWWBBBB\nBBBBWWWWBBBB\nBBBBWWWWBBBB\nBBBBBBBBBBBB\nBBBBBBBBBBBB\nBBBBBBBBBBBB\nBBBBBBBBBBBB\n```\n\nand so on.\n\nCodd has just infiltrated a dream and viewed its starting dream grid. He is on a very difficult mission, and he knows that he will need to go deeper many times. To help him navigate, he is looking at various patterns in the starting dream grid. A pattern consists of a single group of cells connected by shared edges (shared corners do not count as connections), plus their colors. A pattern might contain internal gaps (as long as the pattern's cells are a single connected group); such gaps are not considered part of the pattern. Two patterns are the same if and only if they have the same number and arrangement of cells (not reflected or rotated), with the same colors.\n\nFor example, in the grids above, the following $8$-cell pattern is present in the starting grid:\n\n```\nBBB\nB B\nBBB\n```\n\nIt is not present after going deeper once, but it is present after going deeper twice, and three times, and so on for every deeper dream grid.\n\nCodd wants to find the largest pattern from the starting dream grid that will be present in at least a googol ($10^{100}$) of deeper dream grids. For the given example, the pattern above is the largest such pattern. Even though it is not present after going deeper once, it is present in at least a googol of deeper levels. Other such patterns of smaller sizes also meet this condition, but there is no $9$-cell pattern that does; the only such pattern would have to be identical to the entire starting dream grid, and that pattern will never show up in any deeper dream grid, let alone in a googol of them.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with two integers $R$ and $C$: the numbers of rows and columns, respectively, in the dream grid. Each case continues with $R$ more lines of $C$ characters each; every such character is either `B` or `W`. These lines directly represent the dream grid.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the largest possible size of at least one pattern that meets Codd's requirements, as described above.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one described in the problem statement.\n\nIn Sample Case #2, one possible largest pattern is:\n\n```\nBBB\nWB\n```\n\nAnother equally large one is:\n\n```\nBBB\nW W\n```\n\nIn Sample Case #3, the entire starting dream grid is a largest pattern.\n\nIn Sample Case #4, note that the five Ws would not form a valid pattern, because they are not connected. However, this is a largest pattern:\n\n```\nWB\nBW\n```\n\nIn Sample Case #5, the entire starting dream grid is a largest pattern. Note that even though this grid happens to be what Codd would get by going deeper starting from BW, that is irrelevant; Codd will never \"go shallower\".\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $1 \\leq R \\leq 3$.\n- $1 \\leq C \\leq 4$.\n\n**Test set 2 (22 Pts, Hidden)**\n\n- $1 \\leq R \\leq 20$.\n- $1 \\leq C \\leq 20$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #2] Gridception", "background": null, "description": "盗贼大师 Jom Codd 能够潜入他人的梦境。由于梦境观察技术还不够先进，Codd 看到的梦境是一个由单元格组成的梦境网格，每个单元格要么是白色，要么是黑色。\n\n给定一个初始的梦境网格，Codd 可以通过“深入”操作，将每个白色单元格替换为一个 $2\\times 2$ 的白色单元格网格，每个黑色单元格替换为一个 $2\\times 2$ 的黑色单元格网格；这样会生成一个面积扩大四倍的新梦境网格。他可以在此基础上继续深入，如此反复。例如，给定如下初始梦境网格：\n\n```\nBBB\nBWB\nBBB\n```\n\n深入一次后，得到的新梦境网格为：\n\n```\nBBBBBB\nBBBBBB\nBBWWBB\nBBWWBB\nBBBBBB\nBBBBBB\n```\n\n再深入一次，得到的新梦境网格为：\n\n```\nBBBBBBBBBBBB\nBBBBBBBBBBBB\nBBBBBBBBBBBB\nBBBBBBBBBBBB\nBBBBWWWWBBBB\nBBBBWWWWBBBB\nBBBBWWWWBBBB\nBBBBWWWWBBBB\nBBBBBBBBBBBB\nBBBBBBBBBBBB\nBBBBBBBBBBBB\nBBBBBBBBBBBB\n```\n\n以此类推。\n\nCodd 刚刚潜入了一个梦境，并看到了它的初始梦境网格。他正执行一项极其艰难的任务，他知道自己需要多次深入。为了帮助自己导航，他正在观察初始梦境网格中的各种“模式”。一个模式由一组通过边相连（仅共享角不算相连）的单元格及其颜色组成。一个模式可以包含内部空洞（只要模式的单元格是一个连通块）；这些空洞不算作模式的一部分。如果两个模式的单元格数量和排列方式完全相同（不允许翻转或旋转），且颜色一致，则认为它们是相同的模式。\n\n例如，在上述网格中，以下 $8$ 个单元格的模式出现在初始网格中：\n\n```\nBBB\nB B\nBBB\n```\n\n在深入一次后，这个模式不再出现，但在深入两次、三次及之后的每一次深入的梦境网格中，这个模式都会出现。\n\nCodd 想要找到初始梦境网格中，能够在至少 $10^{100}$ 个更深层梦境网格中出现的最大模式。对于给定的例子，上述模式就是最大的满足条件的模式。尽管它在深入一次后没有出现，但在至少 $10^{100}$ 个更深层网格中都会出现。其他更小的模式也满足条件，但不存在 $9$ 个单元格的模式满足条件；唯一可能的 $9$ 个单元格模式只能是整个初始梦境网格，但这个模式在任何更深层网格中都不会出现，更不用说出现 $10^{100}$ 次了。", "inputFormat": "第一行输入一个整数 $T$，表示测试用例的数量。接下来有 $T$ 组测试数据。每组数据第一行包含两个整数 $R$ 和 $C$，分别表示梦境网格的行数和列数。接下来的 $R$ 行，每行包含 $C$ 个字符，每个字符为 `B` 或 `W`，直接表示梦境网格。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是满足 Codd 要求的最大模式的大小。", "hint": "**样例解释**\n\n样例 1 即为题目描述中的例子。\n\n样例 2 中，一个可能的最大模式为：\n\n```\nBBB\nWB\n```\n\n另一个同样大小的模式为：\n\n```\nBBB\nW W\n```\n\n样例 3 中，整个初始梦境网格就是最大的模式。\n\n样例 4 中，注意五个 W 不能构成一个合法模式，因为它们不是连通的。然而，以下模式是一个最大模式：\n\n```\nWB\nBW\n```\n\n样例 5 中，整个初始梦境网格就是最大的模式。需要注意的是，尽管这个网格恰好是从 BW 深入得到的，但这与本题无关；Codd 永远不会“向上回溯”。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n\n**测试点 1（10 分，公开）**\n\n- $1 \\leq R \\leq 3$。\n- $1 \\leq C \\leq 4$。\n\n**测试点 2（22 分，隐藏）**\n\n- $1 \\leq R \\leq 20$。\n- $1 \\leq C \\leq 20$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13149", "type": "P", "difficulty": 3, "samples": [["5\n3\n3 2\n0 2\n0 0\n3\n2 2\n2 2\n2 2\n9\n1 1\n0 0\n0 1\n0 2\n1 0\n1 2\n2 0\n2 1\n2 2\n2\n8 0\n0 8\n4\n1 0\n1 3\n2 2\n0 2", "Case #1: 2\nCase #2: 0\nCase #3: 1\nCase #4: 4\nCase #5: 2"]], "limits": {"time": [20000, 20000], "memory": [1048576, 1048576]}, "tags": ["2018", "Google Code Jam"], "title": "[GCJ 2018 #3] Field Trip", "background": "", "description": "$N$ people from an elementary school — one teacher and $N-1$ kids — are on a field trip. They are exploring a grassy field that is an infinite two-dimensional grid of unit cells. Each person is currently occupying one of the cells; there may be multiple people in the same cell.\n\nWhen it is time to go home, the teacher and kids must all gather in one cell; it does not matter which one, since their bus can pick them up anywhere. The kids have been taught an algorithm that makes it easier to gather:\n\n- The teacher is person number 1, and the kids are numbered 2 through $N$.\n- An action taken by a person consists of either moving to one of the 8 cells sharing at least one edge or corner with that person's current cell, or choosing to remain in their current cell.\n- When the signal for the end of the field trip sounds, the teacher checks to see if all $N$ people are in the same cell. If they are, no further action is necessary. Otherwise, the teacher begins a turn:\n  1. First, the teacher takes an action, as described above. It is up to the teacher to decide where, if anywhere, to move.\n  2. Then, each kid takes an action, starting with kid 2, and so on up to kid $N$; the $i$-th kid does not take their action until the $(i-1)$th person has taken their action. The kids' actions are deterministic: the $i$-th kid must choose the option that minimizes the center-to-center distance from their cell to the cell of the $(i-1)$th person. This is never ambiguous; one of the 9 options will uniquely minimize that distance.\n- Once the turn is complete, the teacher checks again to see if all people are in the same cell. If they are not, another turn begins, and so on, until everyone is in one cell.\n\nIf the teacher makes choices that minimize the number of turns, what is that number of turns?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with an integer $N$: the number of people on the field trip. Then, there are $N$ more lines. The $i$-th of these represents the $i$-th person, and has two integers $R_i$ and $C_i$: the row and column numbers (on the grid) of the cell that the $i$-th person initially occupies.\n", "outputFormat": "For each test case, output one line containing Case #x: y, where $x$ is the test case number (starting from 1) and $y$ is the smallest possible number of turns required, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the teacher is at $(3, 2)$ — that is, row 3 and column 2. Kid 2 is at $(0, 2)$, and Kid 3 is at $(0, 0)$. One optimal strategy for the teacher is as follows:\n\n- Turn 1:\n    - Move to $(2, 2)$.\n    - Kid 2 moves to $(1, 2)$.\n    - Kid 3 moves to $(1, 1)$.\n- Turn 2:\n    - Move to $(1, 2)$.\n    - Kid 2 remains in place in $(1, 2)$.\n    - Kid 3 moves to $(1, 2)$. Now everyone is in the same cell.\n\nIn Sample Case #2, the teacher and the two kids start off in the same cell, so no turns are required.\n\nIn Sample Case #3, the teacher can remain in place, and all of the kids will move to the teacher's cell by the end of the first turn.\n\nIn Sample Case #4, the teacher should move diagonally four times to reach $(4, 4)$.\n\nIn Sample Case #5, the teacher should begin by moving to $(1, 1)$; then kids $2, 3$, and $4$ will all move to $(1, 2)$. Note that even though all the kids are now in the same cell, the teacher is not, and must start another turn. On the second turn, the teacher can move to $(1, 2)$ to join the kids, and the kids will not move.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Test set 1 (4 Pts, Visible)**\n\n- $2 \\leq N \\leq 10$.\n- $0 \\leq R_i \\leq 8$, for all $i$.\n- $0 \\leq C_i \\leq 8$, for all $i$.\n\n**Test set 2 (10 Pts, Hidden)**\n\n- $2 \\leq N \\leq 10^4$.\n- $0 \\leq R_i \\leq 10^9$, for all $i$.\n- $0 \\leq C_i \\leq 10^9$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #3] Field Trip", "background": "", "description": "$N$ people from an elementary school — one teacher and $N-1$ kids — are on a field trip. They are exploring a grassy field that is an infinite two-dimensional grid of unit cells. Each person is currently occupying one of the cells; there may be multiple people in the same cell.\n\nWhen it is time to go home, the teacher and kids must all gather in one cell; it does not matter which one, since their bus can pick them up anywhere. The kids have been taught an algorithm that makes it easier to gather:\n\n- The teacher is person number 1, and the kids are numbered 2 through $N$.\n- An action taken by a person consists of either moving to one of the 8 cells sharing at least one edge or corner with that person's current cell, or choosing to remain in their current cell.\n- When the signal for the end of the field trip sounds, the teacher checks to see if all $N$ people are in the same cell. If they are, no further action is necessary. Otherwise, the teacher begins a turn:\n  1. First, the teacher takes an action, as described above. It is up to the teacher to decide where, if anywhere, to move.\n  2. Then, each kid takes an action, starting with kid 2, and so on up to kid $N$; the $i$-th kid does not take their action until the $(i-1)$th person has taken their action. The kids' actions are deterministic: the $i$-th kid must choose the option that minimizes the center-to-center distance from their cell to the cell of the $(i-1)$th person. This is never ambiguous; one of the 9 options will uniquely minimize that distance.\n- Once the turn is complete, the teacher checks again to see if all people are in the same cell. If they are not, another turn begins, and so on, until everyone is in one cell.\n\nIf the teacher makes choices that minimize the number of turns, what is that number of turns?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with an integer $N$: the number of people on the field trip. Then, there are $N$ more lines. The $i$-th of these represents the $i$-th person, and has two integers $R_i$ and $C_i$: the row and column numbers (on the grid) of the cell that the $i$-th person initially occupies.\n", "outputFormat": "For each test case, output one line containing Case #x: y, where $x$ is the test case number (starting from 1) and $y$ is the smallest possible number of turns required, as described above.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the teacher is at $(3, 2)$ — that is, row 3 and column 2. Kid 2 is at $(0, 2)$, and Kid 3 is at $(0, 0)$. One optimal strategy for the teacher is as follows:\n\n- Turn 1:\n    - Move to $(2, 2)$.\n    - Kid 2 moves to $(1, 2)$.\n    - Kid 3 moves to $(1, 1)$.\n- Turn 2:\n    - Move to $(1, 2)$.\n    - Kid 2 remains in place in $(1, 2)$.\n    - Kid 3 moves to $(1, 2)$. Now everyone is in the same cell.\n\nIn Sample Case #2, the teacher and the two kids start off in the same cell, so no turns are required.\n\nIn Sample Case #3, the teacher can remain in place, and all of the kids will move to the teacher's cell by the end of the first turn.\n\nIn Sample Case #4, the teacher should move diagonally four times to reach $(4, 4)$.\n\nIn Sample Case #5, the teacher should begin by moving to $(1, 1)$; then kids $2, 3$, and $4$ will all move to $(1, 2)$. Note that even though all the kids are now in the same cell, the teacher is not, and must start another turn. On the second turn, the teacher can move to $(1, 2)$ to join the kids, and the kids will not move.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Test set 1 (4 Pts, Visible)**\n\n- $2 \\leq N \\leq 10$.\n- $0 \\leq R_i \\leq 8$, for all $i$.\n- $0 \\leq C_i \\leq 8$, for all $i$.\n\n**Test set 2 (10 Pts, Hidden)**\n\n- $2 \\leq N \\leq 10^4$.\n- $0 \\leq R_i \\leq 10^9$, for all $i$.\n- $0 \\leq C_i \\leq 10^9$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #3] Field Trip", "background": null, "description": "一所小学的 $N$ 个人——一名老师和 $N-1$ 名学生——正在进行一次郊游。他们正在探索一片无限大的二维网格草地，每个格子为单位格。每个人当前都占据着某一个格子；同一个格子上可能有多个人。\n\n当要回家时，老师和学生们必须全部聚集到同一个格子里；具体是哪个格子无所谓，因为他们的校车可以在任何地方接他们。学生们已经学会了一种便于集合的算法：\n\n- 老师编号为 1，学生编号为 2 到 $N$。\n- 每个人的一个动作可以是移动到与当前格子至少共享一个边或一个角的 8 个格子中的任意一个，或者选择留在原地不动。\n- 当郊游结束的信号响起时，老师会检查所有 $N$ 个人是否都在同一个格子里。如果是，则不需要再做任何操作。否则，老师开始一轮操作：\n  1. 首先，老师进行一次动作，如上所述。老师可以自行决定是否移动以及移动到哪里。\n  2. 然后，每个学生依次进行动作，从 2 号学生开始，依次到第 $N$ 号学生；第 $i$ 个学生要等到第 $i-1$ 个人完成动作后才能行动。学生的动作是确定的：第 $i$ 个学生必须选择能使自己与第 $i-1$ 个人的格子中心距离最小的选项。这种选择不会有歧义，9 个选项中必有唯一一个能最小化该距离。\n- 一轮操作结束后，老师再次检查所有人是否都在同一个格子里。如果还没有，则开始新的一轮操作，如此反复，直到所有人都在同一个格子里为止。\n\n如果老师每次都做出能最小化轮数的选择，最少需要多少轮才能集合所有人？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为一个整数 $N$，表示郊游的人数。接下来的 $N$ 行中，第 $i$ 行包含两个整数 $R_i$ 和 $C_i$，表示第 $i$ 个人（老师为第 1 个人）初始所在的格子的行号和列号。", "outputFormat": "对于每个测试用例，输出一行，格式为 Case #x: y，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为最少需要的轮数。", "hint": "**样例解释**\n\n在样例 1 中，老师在 $(3, 2)$，即第 3 行第 2 列。2 号学生在 $(0, 2)$，3 号学生在 $(0, 0)$。老师的一种最优策略如下：\n\n- 第 1 轮：\n    - 老师移动到 $(2, 2)$。\n    - 2 号学生移动到 $(1, 2)$。\n    - 3 号学生移动到 $(1, 1)$。\n- 第 2 轮：\n    - 老师移动到 $(1, 2)$。\n    - 2 号学生留在 $(1, 2)$。\n    - 3 号学生移动到 $(1, 2)$。此时所有人都在同一个格子。\n\n在样例 2 中，老师和两名学生一开始就在同一个格子里，因此不需要任何轮数。\n\n在样例 3 中，老师可以原地不动，所有学生在第一轮结束时都会移动到老师所在的格子。\n\n在样例 4 中，老师应当沿对角线移动 4 次到达 $(4, 4)$。\n\n在样例 5 中，老师应当先移动到 $(1, 1)$；然后 2、3、4 号学生都会移动到 $(1, 2)$。注意，虽然所有学生都在同一个格子，但老师还不在，因此需要再进行一轮。在第二轮中，老师可以移动到 $(1, 2)$ 与学生们会合，学生们则不动。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n\n**测试点 1（4 分，公开）**\n\n- $2 \\leq N \\leq 10$。\n- $0 \\leq R_i \\leq 8$，对所有 $i$。\n- $0 \\leq C_i \\leq 8$，对所有 $i$。\n\n**测试点 2（10 分，隐藏）**\n\n- $2 \\leq N \\leq 10^4$。\n- $0 \\leq R_i \\leq 10^9$，对所有 $i$。\n- $0 \\leq C_i \\leq 10^9$，对所有 $i$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13150", "type": "P", "difficulty": 6, "samples": [["", ""]], "limits": {"time": [10000, 10000], "memory": [1048576, 1048576]}, "tags": ["图论", "2018", "交互题", "Special Judge", "Google Code Jam"], "title": "[GCJ 2018 #3] Name-Preserving Network", "background": "", "description": "A research consortium is building a new datacenter. In the datacenter, a set of computers is set up to work together and communicate via a network. The network works only with direct bidirectional links between computers. A pair of computers $c_1$ and $c_2$ that are not connected by a direct link can still communicate with each other, as long as there is at least one path of links $l_1, l_2, ..., l_k$ such that links $l_i$ and $l_{i+1}$ share an endpoint, $c_1$ is an endpoint of $l_1$, and $c_2$ is an endpoint of $l_k$. Any two computers can have at most one direct link between them.\n\nThe consortium has asked you to submit a design that illustrates how many computers will be in the network and how they will be connected to each other. Each network design you submit must comply with a specific set of restrictions:\n\n1. There must be between $L$ and $U$ computers, inclusive, in the network.\n2. Each computer must be an endpoint of exactly 4 links, linking it to 4 other distinct computers.\n3. Every pair of computers must be able to communicate with each other, as described above.\n4. The computers must be able to uniquely identify themselves even if their IDs are randomly changed while the system is off.\n\nTo elaborate on the last point: each of the $N$ computers in a network design is initially assigned a unique integer between 1 and $N$ that identifies it. However, it is possible that after some downtime, the system will boot up and the identifiers will be permuted — that is, each computer will still have a unique integer between 1 and $N$, but not necessarily the original one. The network must be able to recover the original identifying integers without having access to any information other than the existing direct links.\n\nTo evaluate your network designs, the research consortium has set up an automated program. The program will receive one of your network designs, validate conditions 1-3 above, and then send back a copy of the network design with the following changes:\n\n- the unique IDs have been permuted at random (that is, each ID is now equally likely to be on any of the computers),\n- every link is listed with the smallest ID first (using the new IDs), and\n- the set of links is listed in increasing order of the first endpoint (using the new IDs), breaking ties by smallest second endpoint (i.e., lexicographical order).\n\nYou need to be able to determine exactly how the IDs were changed. Formally, the automated program will create a secret random permutation $f$ of the integers 1 through $N$, and it will assign those numbers to computers in a \"blank copy\" of the network with all of the previous links removed. Then, for each link between computers $i$ and $j$ in your network design, it will add a link between $f(i)$ and $f(j)$ to the copy. You then must recreate exactly the $f$ that the automated program created. If there exists a different $f'$ that yields the same result and you return $f'$, the consortium will not accept your network design, as in such a case, you cannot ensure that the recovered IDs are the original ones.\n\nFor every $N$ between $10$ and $100$, inclusive, there exists at least one network of $N$ computers that complies with all restrictions above and has the property that applying two different permutations $f$ and $f'$ to it produces two different sets of links.\n\n### Interactive Protocol\n\nThis problem is interactive, which means that the concepts of input and output are different than in standard Code Jam problems. You will interact with a separate process that both provides you with information and evaluates your responses. All information comes into your program via standard input; anything that you need to communicate should be sent via standard output. Remember that many programming languages buffer the output by default, so make sure your output actually goes out (for instance, by flushing the buffer) before blocking to wait for a response. See the FAQ for an explanation of what it means to flush the buffer. Anything your program sends through standard error is ignored, but it might consume some memory and be counted against your memory limit, so do not overflow it. To help you debug, a local testing tool script (in Python) is provided at the very end of the problem statement. In addition, sample solutions to a previous Code Jam interactive problem (in all of our supported languages) are provided in the analysis for Number Guessing.\n\nInitially, your program should read a single line containing a single integer $T$ indicating the number of test cases. Then, you need to process $T$ test cases.\n\nFor each test case, your program will first read a single line containing two integers $L$ and $U$ indicating the inclusive range of values for the number of computers in your network design.\n\nThen, you need to create a network design with $N$ computers and print $2N+1$ lines representing that design. The first line must contain a single integer $N$. The remaining $2N$ lines must contain two integers $A$ and $B$ each, each representing a different link between computers $A$ and $B$, where $A \\neq B$. Notice that if you list link $A$ $B$, you may not list $A$ $B$ nor $B$ $A$ again.\n\nUpon reading your network design, the judge will first check the first three conditions listed in the statement above. If any of those is not met, the judge will send you a single line containing a single -1, and then finish all communication and wait for your program to finish. If your program does finish correctly and without violating other limits, it will receive a Wrong Answer verdict.\n\nIf all of the conditions are met, the judge will send you $2N+1$ lines. The first line will contain a single integer $N$ (the same $N$ you sent). Then, the next $2N$ lines will contain two integers each, describing the links of the copy of the network design, in the same format as you used. The copy is generated as described above, with the permutation $f$ chosen uniformly at random from all possible permutations, independently of your network design.\n\nTo finish a test case, you need to send the judge a single line with $N$ integers $X_1$, $X_2$, ..., $X_N$, representing that the computer to which you assigned number $i$ was assigned number $X_i$ in the judge's copy, for all $i$.\n\nIf the list is not the list the judge generated, you will receive a Wrong Answer verdict. If it was in the last test case, the judge will send no additional communication. Otherwise, the judge will send a single line containing a single -1, and then no additional communication. In both cases, the judge will wait for your program to end, and assign the Wrong Answer verdict only if it ended normally and without violating any resource limits.\n\nYou should not send additional information to the judge after solving all test cases. In other words, if your program keeps printing to standard output after printing the list of $X$s for the last test case, you will receive a Wrong Answer judgment.\n\nNotice that you are allowed to submit the same network design for different test cases, as long as that design complies with all restrictions for both cases. Additionally, the seed from random generation in the judge is fixed, so sending the same set of original network designs in the same order will get back the same set of copies.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nNote that this sample interaction uses a smaller value of $L$ than the real data, for ease of illustration. Also note that there is no network of exactly $6$ computers with the property that applying two different permutations $f$ and $f'$ to it produces two different sets of links, so it would be a bad idea to design a network of exactly $6$ computers, even if the problem's limits allowed it!\n\n```\n  t = readline_int()           // reads 2 into t\n  limits = readline_int_list() // reads 6 50 into limits\n  printline 6 to stdout        // using 6 computers. Contestant designs an\n                               //   octahedral network\n  printline 2 4 to stdout\n  printline 1 2 to stdout      // you do not need to list edges in any\n                               //   particular order\n  printline 3 1 to stdout      // you do not need to give the endpoints of a\n                               //   link in order\n  printline 1 4 to stdout\n  printline 1 5 to stdout\n  printline 2 3 to stdout\n  printline 2 6 to stdout\n  printline 3 5 to stdout\n  printline 3 6 to stdout\n  printline 4 5 to stdout\n  printline 4 6 to stdout\n  printline 5 6 to stdout\n  flush stdout                 // judge verifies that the network meets\n                               //   conditions 1-3 above, and secretly picks\n                               //   2 6 3 1 5 4 as the new permutation\n  n = readline_int()           // reads 6 into n\n  repeat 12 times:\n    add readline_int_list() to edges  // reads 1 2, 1 4, 1 5, 1 6, 2 3, 2 5,\n                                      //   2 6, 3 4, 3 5, 3 6, 4 5, 4 6, in\n                                      //   that order\n  printline 2 5 6 1 3 4        // note that this is consistent with what the\n                               //   judge sent, but is not the permutation the\n                               //   judge used\n  flush stdout                 // judge decides that this is wrong\n  limits = readline_int_list() // expects to read the next case but gets -1,\n                               //   indicating a wrong answer\n  exit                         // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leq T \\leq 30$.\n\n**Test set 1 (9 Pts, Visible)**\n\n- $L = 10$.\n- $U = 50$.\n\n**Test set 2 (16 Pts, Hidden)**\n\n- $10 \\leq L \\leq 50$.\n- $L = U$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #3] Name-Preserving Network", "background": "", "description": "A research consortium is building a new datacenter. In the datacenter, a set of computers is set up to work together and communicate via a network. The network works only with direct bidirectional links between computers. A pair of computers $c_1$ and $c_2$ that are not connected by a direct link can still communicate with each other, as long as there is at least one path of links $l_1, l_2, ..., l_k$ such that links $l_i$ and $l_{i+1}$ share an endpoint, $c_1$ is an endpoint of $l_1$, and $c_2$ is an endpoint of $l_k$. Any two computers can have at most one direct link between them.\n\nThe consortium has asked you to submit a design that illustrates how many computers will be in the network and how they will be connected to each other. Each network design you submit must comply with a specific set of restrictions:\n\n1. There must be between $L$ and $U$ computers, inclusive, in the network.\n2. Each computer must be an endpoint of exactly 4 links, linking it to 4 other distinct computers.\n3. Every pair of computers must be able to communicate with each other, as described above.\n4. The computers must be able to uniquely identify themselves even if their IDs are randomly changed while the system is off.\n\nTo elaborate on the last point: each of the $N$ computers in a network design is initially assigned a unique integer between 1 and $N$ that identifies it. However, it is possible that after some downtime, the system will boot up and the identifiers will be permuted — that is, each computer will still have a unique integer between 1 and $N$, but not necessarily the original one. The network must be able to recover the original identifying integers without having access to any information other than the existing direct links.\n\nTo evaluate your network designs, the research consortium has set up an automated program. The program will receive one of your network designs, validate conditions 1-3 above, and then send back a copy of the network design with the following changes:\n\n- the unique IDs have been permuted at random (that is, each ID is now equally likely to be on any of the computers),\n- every link is listed with the smallest ID first (using the new IDs), and\n- the set of links is listed in increasing order of the first endpoint (using the new IDs), breaking ties by smallest second endpoint (i.e., lexicographical order).\n\nYou need to be able to determine exactly how the IDs were changed. Formally, the automated program will create a secret random permutation $f$ of the integers 1 through $N$, and it will assign those numbers to computers in a \"blank copy\" of the network with all of the previous links removed. Then, for each link between computers $i$ and $j$ in your network design, it will add a link between $f(i)$ and $f(j)$ to the copy. You then must recreate exactly the $f$ that the automated program created. If there exists a different $f'$ that yields the same result and you return $f'$, the consortium will not accept your network design, as in such a case, you cannot ensure that the recovered IDs are the original ones.\n\nFor every $N$ between $10$ and $100$, inclusive, there exists at least one network of $N$ computers that complies with all restrictions above and has the property that applying two different permutations $f$ and $f'$ to it produces two different sets of links.\n\n### Interactive Protocol\n\nThis problem is interactive, which means that the concepts of input and output are different than in standard Code Jam problems. You will interact with a separate process that both provides you with information and evaluates your responses. All information comes into your program via standard input; anything that you need to communicate should be sent via standard output. Remember that many programming languages buffer the output by default, so make sure your output actually goes out (for instance, by flushing the buffer) before blocking to wait for a response. See the FAQ for an explanation of what it means to flush the buffer. Anything your program sends through standard error is ignored, but it might consume some memory and be counted against your memory limit, so do not overflow it. To help you debug, a local testing tool script (in Python) is provided at the very end of the problem statement. In addition, sample solutions to a previous Code Jam interactive problem (in all of our supported languages) are provided in the analysis for Number Guessing.\n\nInitially, your program should read a single line containing a single integer $T$ indicating the number of test cases. Then, you need to process $T$ test cases.\n\nFor each test case, your program will first read a single line containing two integers $L$ and $U$ indicating the inclusive range of values for the number of computers in your network design.\n\nThen, you need to create a network design with $N$ computers and print $2N+1$ lines representing that design. The first line must contain a single integer $N$. The remaining $2N$ lines must contain two integers $A$ and $B$ each, each representing a different link between computers $A$ and $B$, where $A \\neq B$. Notice that if you list link $A$ $B$, you may not list $A$ $B$ nor $B$ $A$ again.\n\nUpon reading your network design, the judge will first check the first three conditions listed in the statement above. If any of those is not met, the judge will send you a single line containing a single -1, and then finish all communication and wait for your program to finish. If your program does finish correctly and without violating other limits, it will receive a Wrong Answer verdict.\n\nIf all of the conditions are met, the judge will send you $2N+1$ lines. The first line will contain a single integer $N$ (the same $N$ you sent). Then, the next $2N$ lines will contain two integers each, describing the links of the copy of the network design, in the same format as you used. The copy is generated as described above, with the permutation $f$ chosen uniformly at random from all possible permutations, independently of your network design.\n\nTo finish a test case, you need to send the judge a single line with $N$ integers $X_1$, $X_2$, ..., $X_N$, representing that the computer to which you assigned number $i$ was assigned number $X_i$ in the judge's copy, for all $i$.\n\nIf the list is not the list the judge generated, you will receive a Wrong Answer verdict. If it was in the last test case, the judge will send no additional communication. Otherwise, the judge will send a single line containing a single -1, and then no additional communication. In both cases, the judge will wait for your program to end, and assign the Wrong Answer verdict only if it ended normally and without violating any resource limits.\n\nYou should not send additional information to the judge after solving all test cases. In other words, if your program keeps printing to standard output after printing the list of $X$s for the last test case, you will receive a Wrong Answer judgment.\n\nNotice that you are allowed to submit the same network design for different test cases, as long as that design complies with all restrictions for both cases. Additionally, the seed from random generation in the judge is fixed, so sending the same set of original network designs in the same order will get back the same set of copies.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interaction**\n\nNote that this sample interaction uses a smaller value of $L$ than the real data, for ease of illustration. Also note that there is no network of exactly $6$ computers with the property that applying two different permutations $f$ and $f'$ to it produces two different sets of links, so it would be a bad idea to design a network of exactly $6$ computers, even if the problem's limits allowed it!\n\n```\n  t = readline_int()           // reads 2 into t\n  limits = readline_int_list() // reads 6 50 into limits\n  printline 6 to stdout        // using 6 computers. Contestant designs an\n                               //   octahedral network\n  printline 2 4 to stdout\n  printline 1 2 to stdout      // you do not need to list edges in any\n                               //   particular order\n  printline 3 1 to stdout      // you do not need to give the endpoints of a\n                               //   link in order\n  printline 1 4 to stdout\n  printline 1 5 to stdout\n  printline 2 3 to stdout\n  printline 2 6 to stdout\n  printline 3 5 to stdout\n  printline 3 6 to stdout\n  printline 4 5 to stdout\n  printline 4 6 to stdout\n  printline 5 6 to stdout\n  flush stdout                 // judge verifies that the network meets\n                               //   conditions 1-3 above, and secretly picks\n                               //   2 6 3 1 5 4 as the new permutation\n  n = readline_int()           // reads 6 into n\n  repeat 12 times:\n    add readline_int_list() to edges  // reads 1 2, 1 4, 1 5, 1 6, 2 3, 2 5,\n                                      //   2 6, 3 4, 3 5, 3 6, 4 5, 4 6, in\n                                      //   that order\n  printline 2 5 6 1 3 4        // note that this is consistent with what the\n                               //   judge sent, but is not the permutation the\n                               //   judge used\n  flush stdout                 // judge decides that this is wrong\n  limits = readline_int_list() // expects to read the next case but gets -1,\n                               //   indicating a wrong answer\n  exit                         // exits to avoid an ambiguous TLE error\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Limits**\n\n- $1 \\leq T \\leq 30$.\n\n**Test set 1 (9 Pts, Visible)**\n\n- $L = 10$.\n- $U = 50$.\n\n**Test set 2 (16 Pts, Hidden)**\n\n- $10 \\leq L \\leq 50$.\n- $L = U$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #3] Name-Preserving Network", "background": "", "description": "一个研究联盟正在建设一个新的数据中心。在数据中心中，一组计算机被设置为协同工作，并通过网络进行通信。该网络仅通过计算机之间的直接双向连接工作。对于没有直接连接的两台计算机 $c_1$ 和 $c_2$，只要存在一条由连接 $l_1, l_2, ..., l_k$ 组成的路径，使得每对相邻连接 $l_i$ 和 $l_{i+1}$ 共享一个端点，且 $c_1$ 是 $l_1$ 的一个端点，$c_2$ 是 $l_k$ 的一个端点，那么 $c_1$ 和 $c_2$ 依然可以通信。任意两台计算机之间最多只能有一条直接连接。\n\n联盟要求你提交一个网络设计，说明网络中有多少台计算机，以及它们之间如何连接。你提交的每个网络设计都必须满足以下特定限制：\n\n1. 网络中的计算机数量必须在 $L$ 到 $U$ 之间（包含两端）。\n2. 每台计算机必须正好作为 4 条连接的端点，即与 4 台不同的计算机直接相连。\n3. 任意两台计算机都必须能够互相通信，如上所述。\n4. 即使系统关闭时计算机的编号被随机更改，计算机也必须能够唯一地识别自己。\n\n对于最后一点，具体说明如下：在你的网络设计中，每台计算机最初被分配一个唯一的整数编号，范围为 $1$ 到 $N$。然而，系统在某次关闭后，重新启动时这些编号可能会被重新排列——也就是说，每台计算机仍然拥有 $1$ 到 $N$ 之间的唯一编号，但不一定是原来的编号。网络必须能够仅凭现有的直接连接关系，恢复出原始的编号分配。\n\n为了评估你的网络设计，研究联盟设置了一个自动化程序。该程序会接收你的网络设计，验证上述第 1-3 条限制，然后返回一个经过如下更改的网络设计副本：\n\n- 唯一编号被随机重新排列（即每个编号现在在任意计算机上都是等可能的）；\n- 每条连接按照较小编号在前的顺序输出（使用新的编号）；\n- 所有连接按照第一个端点编号递增排序，若相同则按第二个端点递增排序（即字典序）。\n\n你需要能够准确判断编号是如何被更改的。形式化地说，自动化程序会生成一个 $1$ 到 $N$ 的随机排列 $f$，并将这些编号分配给一个“空白副本”网络（所有原有连接已移除）。然后，对于你设计中的每一条连接 $i$ 和 $j$，在副本中添加一条 $f(i)$ 和 $f(j)$ 之间的连接。你必须准确还原出 $f$。如果存在另一个不同的排列 $f'$ 也能得到相同的连接集合，而你返回了 $f'$，联盟将不接受你的设计，因为此时无法确保恢复的编号就是原始编号。\n\n对于每个 $N$，其中 $10 \\leq N \\leq 100$，都至少存在一个满足所有上述限制且具有如下性质的网络：对其应用任意两个不同的排列 $f$ 和 $f'$，会得到不同的连接集合。\n\n### 交互协议\n\n本题为交互题，这意味着输入输出方式与标准题目不同。你需要与一个独立的进程进行交互，该进程既为你提供信息，也评估你的回答。所有信息通过标准输入传入你的程序；你需要输出的内容通过标准输出发送。请注意，许多编程语言默认会缓冲输出，因此在等待输入前请确保输出已刷新（例如，使用 flush）。详见 FAQ 关于 flush 的说明。你通过标准错误输出的内容会被忽略，但可能会占用内存并计入内存限制，因此请勿输出过多内容。为方便调试，题目末尾提供了本地测试工具脚本（Python）。此外，分析部分还提供了以往 Code Jam 交互题的参考实现。\n\n最初，你的程序应读取一行，包含一个整数 $T$，表示测试用例数量。然后，你需要处理 $T$ 个测试用例。\n\n对于每个测试用例，你的程序首先读取一行，包含两个整数 $L$ 和 $U$，表示网络中计算机数量的取值范围（包含两端）。\n\n接下来，你需要设计一个包含 $N$ 台计算机的网络，并输出 $2N+1$ 行，描述该网络设计。第一行包含一个整数 $N$。接下来的 $2N$ 行，每行包含两个整数 $A$ 和 $B$，表示一条连接 $A$ 和 $B$ 的不同计算机，且 $A \\neq B$。注意，如果你输出了 $A$ $B$，则不能再输出 $A$ $B$ 或 $B$ $A$。\n\n评测程序收到你的网络设计后，会首先检查前 3 条限制。如果有任何一条不满足，评测程序会返回一行 $-1$，然后结束所有通信并等待你的程序结束。如果你的程序正常结束且未违反其他限制，将收到 Wrong Answer 判定。\n\n如果所有限制均满足，评测程序会返回 $2N+1$ 行。第一行包含整数 $N$（与你输出的 $N$ 相同）。接下来的 $2N$ 行，每行包含两个整数，描述副本网络的连接，格式同上。副本的生成方式如前所述，排列 $f$ 是从所有可能的排列中等概率随机选取的，且与网络设计无关。\n\n完成一个测试用例后，你需要输出一行，包含 $N$ 个整数 $X_1, X_2, ..., X_N$，表示你设计中编号为 $i$ 的计算机在副本中被分配到的编号 $X_i$。\n\n如果该列表不是评测程序生成的排列，将收到 Wrong Answer 判定。如果这是最后一个测试用例，评测程序不会再发送任何信息。否则，评测程序会发送一行 $-1$，然后不再通信。在这两种情况下，评测程序都会等待你的程序结束，只有在程序正常结束且未违反资源限制时才会判定为 Wrong Answer。\n\n请勿在所有测试用例结束后继续向评测程序输出内容。也就是说，在输出最后一个测试用例的 $X$ 列表后，不要再输出任何内容，否则会收到 Wrong Answer 判定。\n\n注意，你可以为不同测试用例提交相同的网络设计，只要该设计同时满足所有相关限制。此外，评测程序的随机种子是固定的，因此以相同顺序提交相同的原始网络设计，会得到相同的副本。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**样例交互**\n\n注意，此样例交互使用的 $L$ 值比实际数据小，仅为说明方便。此外，正如题目所述，$N=6$ 时不存在满足“对任意不同排列 $f$ 和 $f'$，应用后得到的连接集合不同”这一性质的网络，因此即使题目限制允许，设计 $N=6$ 的网络也是不明智的！\n\n```\n  t = readline_int()           // 读取 t=2\n  limits = readline_int_list() // 读取 6 50\n  printline 6 to stdout        // 使用 6 台计算机。选手设计了一个八面体网络\n  printline 2 4 to stdout\n  printline 1 2 to stdout      // 连接的输出顺序不限\n  printline 3 1 to stdout      // 端点顺序也不限\n  printline 1 4 to stdout\n  printline 1 5 to stdout\n  printline 2 3 to stdout\n  printline 2 6 to stdout\n  printline 3 5 to stdout\n  printline 3 6 to stdout\n  printline 4 5 to stdout\n  printline 4 6 to stdout\n  printline 5 6 to stdout\n  flush stdout                 // 评测程序验证网络是否满足前 3 条限制，并随机选择 2 6 3 1 5 4 作为新排列\n  n = readline_int()           // 读取 n=6\n  repeat 12 times:\n    add readline_int_list() to edges  // 读取 1 2, 1 4, 1 5, 1 6, 2 3, 2 5,\n                                      //   2 6, 3 4, 3 5, 3 6, 4 5, 4 6, 按顺序\n  printline 2 5 6 1 3 4        // 这与评测程序返回的内容一致，但不是评测程序实际用的排列\n  flush stdout                 // 评测程序判定错误\n  limits = readline_int_list() // 期望读取下一个用例，但收到 -1，表示答案错误\n  exit                         // 退出，避免歧义性 TLE\n```\n\n你可以使用本地测试工具进行本地或平台测试。要在本地测试，需要并行运行该工具和你的代码；可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释说明。\n\n测试工具的使用说明已包含在工具注释中。建议你自行添加测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真实的评测系统，可能存在差异。\n\n**限制条件**\n\n- $1 \\leq T \\leq 30$。\n\n**测试点 1（9 分，可见）**\n\n- $L = 10$。\n- $U = 50$。\n\n**测试点 2（16 分，隐藏）**\n\n- $10 \\leq L \\leq 50$。\n- $L = U$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13151", "type": "P", "difficulty": 6, "samples": [["3\n5\n-1 0 3\n1 2 4\n1 -2 4\n3 1 3\n3 -1 2\n4\n1 1 1\n2 2 3\n2 3 4\n10 11 120\n4\n1 1 1\n2 2 3\n2 3 4\n10 11 12", "Case #1: 5 4 3 1 2\nCase #2: 3 2 1 4\nCase #3: 1 2 4 3"]], "limits": {"time": [12000, 12000], "memory": [1048576, 1048576]}, "tags": ["计算几何", "2018", "Special Judge", "Google Code Jam"], "title": "[GCJ 2018 #3] Raise the Roof", "background": "", "description": "Anthropologists have learned something surprising about a certain ancient Greek society of geometers: they loved partying as much as they loved mathematics! In fact, they kept hosting larger and larger parties over the years, so they needed to raise the roof of their ballroom to keep the noise level tolerable.\n\nWe know that the roof of their ballroom was always supported by the tips of exactly three columns; these columns were infinitely thin line segments that originated on the floor and rose up perpendicular to the floor. Whenever the society wanted to raise the roof, they would begin by removing the existing roof. Then, they would build a new column in a location where there was not already a column. Finally, they would rest a new roof on the tips of the new column and the two most recently built of the previously existing columns. For mystical reasons, no three column bases were ever collinear, and no four column tips were ever coplanar.\n\nEach roof was a convex polygon that was part of the plane defined by the three tips that supported it. For each column $c$ built before the supporting ones, the roof did not intersect $c$ at any point and was large enough to cover the space above $c$. The roof did not touch the floor. The different roofs did not necessarily all have the same shape.\n\nOn an archeological dig, you found all $N$ columns that the society ever built, but no roof. You want to determine a possible order in which the columns could have been built that is consistent with the rules above. A possible order is an ordering of the $N$ columns such that, for each prefix of length at least 4 of the ordering, there is a roof (convex polygon) that contains the tips of the last three columns in the prefix, and for each other column in the prefix with a tip at $(x, y, h)$ the roof contains a point $(x, y, z)$ with $z > h$.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with one line containing an integer $N$: the number of columns. Then, $N$ more lines follow; the $i$-th of these lines contains three integers $X_i$, $Y_i$, and $H_i$, representing the $X$ and $Y$ coordinates and height above the ground of the tip of the $i$-th column.\n", "outputFormat": "For each test case, output one line containing `Case #x: y1 y2 ... yN`, where $x$ is the test case number (starting from 1), and each $y_i$ is a different integer between 1 through $N$. These represent a possible ordering of the columns, with $y_i$ being the index in the input of the $i$-th built column.\n\nIt is guaranteed that at least one valid answer always exists. If there are multiple possible answers, you may output any of them.", "hint": "**Sample Explanation**\n\nThe following pictures illustrate Sample Case #1.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cefuy1j7.png)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $-10^6 \\leq X_i \\leq 10^6$, for all $i$.\n- $-10^6 \\leq Y_i \\leq 10^6$, for all $i$.\n- $1 \\leq H_i \\leq 10^6$, for all $i$.\n- $(X_i, Y_i)$, $(X_j, Y_j)$, and $(X_k, Y_k)$ are not collinear, for all distinct $i, j, k$.\n- $(X_i, Y_i, H_i)$, $(X_j, Y_j, H_j)$, $(X_k, Y_k, H_k)$, and $(X_l, Y_l, H_l)$ are not coplanar, for all distinct $i, j, k, l$.\n\n**Test set 1 (7 Pts, Visible)**\n\n- $4 \\leq N \\leq 10$.\n\n**Test set 2 (19 Pts, Hidden)**\n\n- $4 \\leq N \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #3] Raise the Roof", "background": "", "description": "Anthropologists have learned something surprising about a certain ancient Greek society of geometers: they loved partying as much as they loved mathematics! In fact, they kept hosting larger and larger parties over the years, so they needed to raise the roof of their ballroom to keep the noise level tolerable.\n\nWe know that the roof of their ballroom was always supported by the tips of exactly three columns; these columns were infinitely thin line segments that originated on the floor and rose up perpendicular to the floor. Whenever the society wanted to raise the roof, they would begin by removing the existing roof. Then, they would build a new column in a location where there was not already a column. Finally, they would rest a new roof on the tips of the new column and the two most recently built of the previously existing columns. For mystical reasons, no three column bases were ever collinear, and no four column tips were ever coplanar.\n\nEach roof was a convex polygon that was part of the plane defined by the three tips that supported it. For each column $c$ built before the supporting ones, the roof did not intersect $c$ at any point and was large enough to cover the space above $c$. The roof did not touch the floor. The different roofs did not necessarily all have the same shape.\n\nOn an archeological dig, you found all $N$ columns that the society ever built, but no roof. You want to determine a possible order in which the columns could have been built that is consistent with the rules above. A possible order is an ordering of the $N$ columns such that, for each prefix of length at least 4 of the ordering, there is a roof (convex polygon) that contains the tips of the last three columns in the prefix, and for each other column in the prefix with a tip at $(x, y, h)$ the roof contains a point $(x, y, z)$ with $z > h$.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with one line containing an integer $N$: the number of columns. Then, $N$ more lines follow; the $i$-th of these lines contains three integers $X_i$, $Y_i$, and $H_i$, representing the $X$ and $Y$ coordinates and height above the ground of the tip of the $i$-th column.\n", "outputFormat": "For each test case, output one line containing `Case #x: y1 y2 ... yN`, where $x$ is the test case number (starting from 1), and each $y_i$ is a different integer between 1 through $N$. These represent a possible ordering of the columns, with $y_i$ being the index in the input of the $i$-th built column.\n\nIt is guaranteed that at least one valid answer always exists. If there are multiple possible answers, you may output any of them.", "hint": "**Sample Explanation**\n\nThe following pictures illustrate Sample Case #1.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cefuy1j7.png)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $-10^6 \\leq X_i \\leq 10^6$, for all $i$.\n- $-10^6 \\leq Y_i \\leq 10^6$, for all $i$.\n- $1 \\leq H_i \\leq 10^6$, for all $i$.\n- $(X_i, Y_i)$, $(X_j, Y_j)$, and $(X_k, Y_k)$ are not collinear, for all distinct $i, j, k$.\n- $(X_i, Y_i, H_i)$, $(X_j, Y_j, H_j)$, $(X_k, Y_k, H_k)$, and $(X_l, Y_l, H_l)$ are not coplanar, for all distinct $i, j, k, l$.\n\n**Test set 1 (7 Pts, Visible)**\n\n- $4 \\leq N \\leq 10$.\n\n**Test set 2 (19 Pts, Hidden)**\n\n- $4 \\leq N \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #3] Raise the Roof", "background": null, "description": "人类学家们对某个古希腊几何学家社团有了令人惊讶的发现：他们对聚会的热爱丝毫不亚于对数学的热爱！事实上，随着年复一年的聚会规模不断扩大，他们不得不不断抬高舞厅的屋顶，以保持噪音在可接受的水平。\n\n我们知道，他们舞厅的屋顶始终由恰好三根柱子的顶端支撑；这些柱子是从地板上垂直升起的无限细线段。每当社团想要抬高屋顶时，他们会先拆除现有的屋顶。然后，在一个还没有柱子的地方建造一根新柱子。最后，用新柱子和之前建造的柱子中最近的两根柱子的顶端作为支点，搭建新的屋顶。出于神秘的原因，任意三根柱子的底座都不会共线，任意四根柱子的顶端也不会共面。\n\n每一块屋顶都是一个凸多边形，属于由三根支撑柱顶端确定的平面。对于每一根在支撑柱之前建造的柱子，屋顶不会与该柱子有任何交点，并且屋顶足够大，可以覆盖该柱子顶端的上方空间。屋顶不会接触地板。不同的屋顶形状不一定完全相同。\n\n在一次考古发掘中，你找到了社团曾经建造过的所有 $N$ 根柱子，但没有发现任何屋顶。你想要确定一种可能的柱子建造顺序，使其符合上述规则。一个可能的顺序是对 $N$ 根柱子的一个排列，使得对于该排列的每一个长度不少于 4 的前缀，存在一块屋顶（凸多边形），它包含该前缀最后三根柱子的顶端，并且对于前缀中的其它每一根柱子，若其顶端为 $(x, y, h)$，则屋顶上存在一个点 $(x, y, z)$ 满足 $z > h$。", "inputFormat": "输入的第一行包含测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行包含一个整数 $N$，表示柱子的数量。接下来的 $N$ 行，每行包含三个整数 $X_i$、$Y_i$ 和 $H_i$，分别表示第 $i$ 根柱子顶端的 $X$ 坐标、$Y$ 坐标和离地高度。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y1 y2 ... yN`，其中 $x$ 是测试用例编号（从 1 开始），$y_i$ 是 $1$ 到 $N$ 之间的不同整数，表示第 $i$ 根被建造的柱子在输入中的编号。\n\n保证至少存在一种合法答案。如果有多种可能的答案，你可以输出其中任意一种。", "hint": "**样例解释**\n\n下图展示了样例第 1 组数据的情况。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cefuy1j7.png)\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $-10^6 \\leq X_i \\leq 10^6$，对所有 $i$。\n- $-10^6 \\leq Y_i \\leq 10^6$，对所有 $i$。\n- $1 \\leq H_i \\leq 10^6$，对所有 $i$。\n- 任意不同的 $i, j, k$，$(X_i, Y_i)$、$(X_j, Y_j)$ 和 $(X_k, Y_k)$ 不共线。\n- 任意不同的 $i, j, k, l$，$(X_i, Y_i, H_i)$、$(X_j, Y_j, H_j)$、$(X_k, Y_k, H_k)$ 和 $(X_l, Y_l, H_l)$ 不共面。\n\n**测试点 1（7 分，公开）**\n\n- $4 \\leq N \\leq 10$。\n\n**测试点 2（19 分，隐藏）**\n\n- $4 \\leq N \\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13152", "type": "P", "difficulty": 6, "samples": [["3\n6 2\n0 0 7 7\n15 -2 10 0\n0 0 0 10\n0 0 10 0\n0 10 10 10\n10 0 10 10\n6 1\n0 0 0 10\n0 0 10 0\n0 10 10 10\n10 0 10 10\n0 0 7 7\n15 -2 10 0\n11 4\n-10 0 10 0\n-10 0 0 10\n10 0 0 10\n0 2 0 5\n0 2 10 0\n10 0 0 5\n15 3 18 3\n15 3 15 9\n18 3 15 9\n15 3 16 5\n0 10 15 3", "Case #1: 1 2 3 4 5 6\nCase #2: 5 6 1 2 3 4\nCase #3: 11 10 7 8 9 1 2 3 6 5 4"]], "limits": {"time": [10000, 10000], "memory": [1048576, 1048576]}, "tags": ["2018", "Special Judge", "Google Code Jam"], "title": "[GCJ 2018 #3] Fence Construction", "background": "", "description": "You are an employee of the Fence Construction Company and have been tasked with the construction of $F$ fences. Each fence runs in a straight line from one point to another. Formally, each fence is a segment connecting two different points in two-dimensional space. Fences do not intersect each other, except possibly at their endpoints. The fences are all connected, that is, for any pair of fences $f$ and $g$ there exists a path $f = f_1, f_2, \\dots, f_k = g$ such that $f_i$ shares an endpoint with $f_{i+1}$.\n\nAt the time you begin your work, no fences have been built. Construction is done using a special fence-shooting 3D printer. There is only one such device, so fences are built one at a time. The printer is small enough that you can consider it a single point on the plane.\n\nTo build a fence $f$, you must first position the printer at a point $p$ in the plane such that the printer can see all of $f$ without being obstructed by previously constructed fences. Formally, $p$ has to be such that:\n\n* $p$ is not on $f$ (not even at an endpoint).\n* for any point $q$ on $f$ that is not an endpoint of $f$, the segment connecting $p$ and $q$ does not intersect any previously built fence.\n\nTo position the printer, you can move it from its current position in a contiguous and not necessarily straight line through the plane, as long as the line does not intersect any previously built fences (not even at an endpoint). You can choose any position for the printer to be at before the first fence is built and after the last fence is built.\n\nHaving to follow this procedure means that you cannot necessarily build the fences in any order. For example, you might choose an order that blocks off the printer and prevents you from moving it to where it needs to be.\n\nThe director of the organization has drafted a relative ordering involving $K$ of the fences (but none of these have been built yet) without giving much thought to it. To avoid angering them, you need to use this ordering, inserting the remaining $F-K$ fences anywhere you like to complete the ordering.\n\nGiven these restrictions, find an order in which to build the fences. It is guaranteed that at least one valid order exists.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line containing two integers $F$ and $K$: the total number of fences and the number of fences in the director's incomplete ordering. Then, $F$ more lines follow; the $i$-th of these lines (counting starting from 1) contains four integers $A_i$, $B_i$, $C_i$ and $D_i$, indicating that the $i$-th fence is a line segment from $(A_i, B_i)$ to $(C_i, D_i)$. The first $K$ fences given in the input are the $K$ fences in the director's ordering.", "outputFormat": "For each test case, output one line beginning `Case #x: y`, where $x$ is the test case number (starting from 1), and $y$ is a space-separated ordering of the integers between 1 and $F$, inclusive, giving a valid order in which to build the fences.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in test set $1$.\n\nIn Sample Case #1, it is possible to build the fences in the order they are given: $1, 2, 3, 4, 5, 6$. Note that fence $1$ must come earlier in the order than fence $2$, per the director's list.\n\nIn Sample Case #2, it is not possible to build the fences in the given order! One possible order is: $5, 6, 1, 2, 3, 4$. Note that when the director's list includes only one fence, the relative order condition is always trivially satisfied.\n\nIn Sample Case #3, it is possible to build the fences in the order: $11, 10, 7, 8, 9, 1, 2, 3, 6, 5, 4$. Note that fences $1, 2, 3$ and $4$ must be built in that relative order.\n\nThe following pictures illustrate one valid way of building the fences for Sample Case #1.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g7k0wawc.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/db8ugko8.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/djg1s3jk.png)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $4 \\leq F \\leq 300$.\n- $-10^5 \\leq A_i \\leq 10^5$, for all $i$.\n- $-10^5 \\leq B_i \\leq 10^5$, for all $i$.\n- $-10^5 \\leq C_i \\leq 10^5$, for all $i$.\n- $-10^5 \\leq D_i \\leq 10^5$, for all $i$.\n- $(A_i, B_i) \\neq (C_i, D_i)$, for all $i$.\n- If $p$ is a non-endpoint point on a fence, then $p$ is not a point of any other fence.\n- The given fences are connected, as defined in the statement.\n- There is at least one ordering of the fences that satisfies all the construction restrictions in the statement.\n\n**Test set 1 (12 Pts, Visible)**\n\n- $1 \\leq K \\leq 2$.\n\n**Test set 2 (23 Pts, Hidden)**\n\n- $1 \\leq K < F$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 #3] Fence Construction", "background": "", "description": "You are an employee of the Fence Construction Company and have been tasked with the construction of $F$ fences. Each fence runs in a straight line from one point to another. Formally, each fence is a segment connecting two different points in two-dimensional space. Fences do not intersect each other, except possibly at their endpoints. The fences are all connected, that is, for any pair of fences $f$ and $g$ there exists a path $f = f_1, f_2, \\dots, f_k = g$ such that $f_i$ shares an endpoint with $f_{i+1}$.\n\nAt the time you begin your work, no fences have been built. Construction is done using a special fence-shooting 3D printer. There is only one such device, so fences are built one at a time. The printer is small enough that you can consider it a single point on the plane.\n\nTo build a fence $f$, you must first position the printer at a point $p$ in the plane such that the printer can see all of $f$ without being obstructed by previously constructed fences. Formally, $p$ has to be such that:\n\n* $p$ is not on $f$ (not even at an endpoint).\n* for any point $q$ on $f$ that is not an endpoint of $f$, the segment connecting $p$ and $q$ does not intersect any previously built fence.\n\nTo position the printer, you can move it from its current position in a contiguous and not necessarily straight line through the plane, as long as the line does not intersect any previously built fences (not even at an endpoint). You can choose any position for the printer to be at before the first fence is built and after the last fence is built.\n\nHaving to follow this procedure means that you cannot necessarily build the fences in any order. For example, you might choose an order that blocks off the printer and prevents you from moving it to where it needs to be.\n\nThe director of the organization has drafted a relative ordering involving $K$ of the fences (but none of these have been built yet) without giving much thought to it. To avoid angering them, you need to use this ordering, inserting the remaining $F-K$ fences anywhere you like to complete the ordering.\n\nGiven these restrictions, find an order in which to build the fences. It is guaranteed that at least one valid order exists.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line containing two integers $F$ and $K$: the total number of fences and the number of fences in the director's incomplete ordering. Then, $F$ more lines follow; the $i$-th of these lines (counting starting from 1) contains four integers $A_i$, $B_i$, $C_i$ and $D_i$, indicating that the $i$-th fence is a line segment from $(A_i, B_i)$ to $(C_i, D_i)$. The first $K$ fences given in the input are the $K$ fences in the director's ordering.", "outputFormat": "For each test case, output one line beginning `Case #x: y`, where $x$ is the test case number (starting from 1), and $y$ is a space-separated ordering of the integers between 1 and $F$, inclusive, giving a valid order in which to build the fences.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in test set $1$.\n\nIn Sample Case #1, it is possible to build the fences in the order they are given: $1, 2, 3, 4, 5, 6$. Note that fence $1$ must come earlier in the order than fence $2$, per the director's list.\n\nIn Sample Case #2, it is not possible to build the fences in the given order! One possible order is: $5, 6, 1, 2, 3, 4$. Note that when the director's list includes only one fence, the relative order condition is always trivially satisfied.\n\nIn Sample Case #3, it is possible to build the fences in the order: $11, 10, 7, 8, 9, 1, 2, 3, 6, 5, 4$. Note that fences $1, 2, 3$ and $4$ must be built in that relative order.\n\nThe following pictures illustrate one valid way of building the fences for Sample Case #1.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g7k0wawc.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/db8ugko8.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/djg1s3jk.png)\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $4 \\leq F \\leq 300$.\n- $-10^5 \\leq A_i \\leq 10^5$, for all $i$.\n- $-10^5 \\leq B_i \\leq 10^5$, for all $i$.\n- $-10^5 \\leq C_i \\leq 10^5$, for all $i$.\n- $-10^5 \\leq D_i \\leq 10^5$, for all $i$.\n- $(A_i, B_i) \\neq (C_i, D_i)$, for all $i$.\n- If $p$ is a non-endpoint point on a fence, then $p$ is not a point of any other fence.\n- The given fences are connected, as defined in the statement.\n- There is at least one ordering of the fences that satisfies all the construction restrictions in the statement.\n\n**Test set 1 (12 Pts, Visible)**\n\n- $1 \\leq K \\leq 2$.\n\n**Test set 2 (23 Pts, Hidden)**\n\n- $1 \\leq K < F$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 #3] Fence Construction", "background": null, "description": "你是一名“Fence Construction Company”（围栏建造公司）的员工，被分配去建造 $F$ 段围栏。每段围栏都是一条从一个点到另一个点的直线段。形式化地说，每段围栏是连接二维平面上两个不同点的线段。围栏之间不会相互相交，除了可能在端点处。所有围栏是连通的，即对于任意两段围栏 $f$ 和 $g$，都存在一条路径 $f = f_1, f_2, \\dots, f_k = g$，使得 $f_i$ 与 $f_{i+1}$ 共享一个端点。\n\n在你开始工作时，尚未建造任何围栏。建造工作通过一种特殊的“围栏发射”3D 打印机完成。只有一台这样的设备，因此围栏需要一段一段地建造。打印机足够小，可以视为平面上的一个点。\n\n要建造某段围栏 $f$，你必须首先将打印机放置在平面上的某个点 $p$，使得打印机能够“看到”整个 $f$，且视线不会被之前建造的围栏阻挡。形式化地说，$p$ 必须满足：\n\n- $p$ 不能在 $f$ 上（包括端点）。\n- 对于 $f$ 上的任意非端点 $q$，连接 $p$ 和 $q$ 的线段不能与任何已建造的围栏相交。\n\n移动打印机时，你可以从当前位置沿着一条连续但不一定直的路径移动，只要这条路径不与任何已建造的围栏相交（包括端点）。在建造第一段围栏之前和最后一段围栏之后，你可以选择打印机的任意位置。\n\n由于需要遵循上述流程，你并不总能以任意顺序建造围栏。例如，你可能选择了一个顺序，结果把打印机困在某处，无法移动到需要的位置。\n\n公司主管已经为 $K$ 段围栏指定了一个相对顺序（但这些围栏都还未建造），但他并未深思熟虑。为了避免惹怒主管，你需要遵循这个顺序，并将剩下的 $F-K$ 段围栏插入到任意位置以完成整个顺序。\n\n在这些限制下，请找出一种建造围栏的顺序。保证至少存在一种合法的顺序。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为两个整数 $F$ 和 $K$，分别表示围栏总数和主管指定顺序中的围栏数。接下来 $F$ 行，第 $i$ 行（从 1 开始计数）包含四个整数 $A_i$、$B_i$、$C_i$ 和 $D_i$，表示第 $i$ 段围栏是从点 $(A_i, B_i)$ 到 $(C_i, D_i)$ 的线段。输入中的前 $K$ 段围栏即为主管指定顺序中的围栏。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为一个用空格分隔的 $1$ 到 $F$ 的整数排列，表示一种合法的建造围栏顺序。", "hint": "**样例解释**\n\n注意，最后一个样例不会出现在测试集 1 中。\n\n在样例 1 中，可以按给定顺序建造围栏：$1, 2, 3, 4, 5, 6$。注意，围栏 $1$ 必须在围栏 $2$ 之前建造，这是主管的要求。\n\n在样例 2 中，无法按给定顺序建造围栏！一种可行的顺序是：$5, 6, 1, 2, 3, 4$。注意，当主管指定的顺序只包含一段围栏时，相对顺序条件总是自动满足。\n\n在样例 3 中，可以按顺序建造：$11, 10, 7, 8, 9, 1, 2, 3, 6, 5, 4$。注意，围栏 $1, 2, 3, 4$ 必须按这个相对顺序建造。\n\n下图展示了样例 1 的一种合法建造方式。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g7k0wawc.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/db8ugko8.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/djg1s3jk.png)\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $4 \\leq F \\leq 300$。\n- $-10^5 \\leq A_i \\leq 10^5$，对所有 $i$。\n- $-10^5 \\leq B_i \\leq 10^5$，对所有 $i$。\n- $-10^5 \\leq C_i \\leq 10^5$，对所有 $i$。\n- $-10^5 \\leq D_i \\leq 10^5$，对所有 $i$。\n- $(A_i, B_i) \\neq (C_i, D_i)$，对所有 $i$。\n- 如果 $p$ 是某段围栏上的非端点，则 $p$ 不是任何其他围栏上的点。\n- 给定的围栏是连通的，如题目描述所定义。\n- 至少存在一种满足所有建造限制的围栏顺序。\n\n**测试集 1（12 分，公开）**\n\n- $1 \\leq K \\leq 2$。\n\n**测试集 2（23 分，隐藏）**\n\n- $1 \\leq K < F$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13153", "type": "P", "difficulty": 6, "samples": [["2\n3 4 2\n1 1 1\n3 3 2\n5 5 2\n4 1 2\n3 2 2", "Case #1: 4\nCase #2: 0"]], "limits": {"time": [30000, 30000], "memory": [1048576, 1048576]}, "tags": ["2018", "二分", "网络流", "最大流最小割定理", "Google Code Jam"], "title": "[GCJ 2018 Finals] Jurisdiction Restrictions", "background": "", "description": "The city of Gridtopia is a matrix of square cells (\"blocks\") with $R$ rows and $C$ columns; rows are numbered (starting from 1) from top to bottom, and columns are numbered (starting from 1) from left to right. The city is served by $S$ different police stations; the i-th station is in the block located in the $R_i$th row and the $C_i$th column, and no block contains more than one station.\n\nEach station is only able to patrol blocks that are no more than $D_i$ blocks away from that station, either horizontally or vertically. That is, the i-th station can only patrol the block in row $R'$ and column $C'$ if $\\max(|R' - R_i|, |C' - C_i|) \\leq D_i$. Put another way, the i-th station can patrol only blocks within the square of side length $2D_i + 1$ centered on that station.\n\nAs the new police commissioner, you need to assign some blocks within the city to exactly one station that is able to patrol it. Blocks that contain stations and blocks that no station is able to patrol should not be assigned. All other blocks have to be assigned. Moreover, you must distribute this assignment load as evenly as possible among stations. Let $A_i$ denote the number of blocks assigned to the i-th station; then your goal is to minimize the difference between the maximum of all the $A_i$ values and the minimum of all of the $A_i$ values. If you make optimal assignments, what is the smallest possible difference?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line with three integers $R$, $C$, and $S$: respectively, the numbers of rows and columns in the grid of cells, and the number of stations. Then, there are $S$ more lines. The i-th of these has three integers $R_i$, $C_i$, and $D_i$: respectively, the row and column in which the i-th station is located, and the parameter that determines which blocks that station is able to patrol, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the difference described above.", "hint": "In Sample Case #1, the city consists of a grid with 3 rows and 4 columns, with one station in the upper left block and one station in the block to the left of the lower right block. The first station can only patrol the three blocks that touch the edge or corner of its block; every other block is at a horizontal or vertical distance of more than 1 away. The second station can patrol any block in the grid (except for the blocks containing the stations). The difference in number of blocks assigned is minimized if you assign station 1 all three of the blocks it can patrol, and then assign the remaining seven blocks to station 2.\n\nIn Sample Case #2, one optimal strategy is to assign the blocks as follows. In this picture, $1$ represents station 1, $2$ represents station 2, $!$ represents a block assigned to station 1, $@$ represents a block assigned to station 2, and $.$ represents a block assigned to neither station (because neither station can patrol it). Notice that a station's assigned blocks do not need to form a single continuous area.\n\n```\n@@@@.\n!!!@.\n!2!@.\n1!!@.\n!@!@.\n```\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $2 \\leq S \\leq 15.$\n- $1 \\leq R_i \\leq R,$ for all $i.$\n- $1 \\leq C_i \\leq C,$ for all $i.$\n- For all $i \\neq j,$ $R_i \\neq R_j$ and/or $C_i \\neq C_j.$ (No two stations are in the same block.)\n- $1 \\leq D_i < \\max(R, C),$ for all $i.$\n\n**Test set 1 (5 Pts, Visible)**\n\n- $1 \\leq R \\leq 20.$\n- $1 \\leq C \\leq 20.$\n\n**Test set 2 (23 Pts, Hidden)**\n\n- $1 \\leq R \\leq 10^9.$\n- $1 \\leq C \\leq 10^9.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 Finals] Jurisdiction Restrictions", "background": "", "description": "The city of Gridtopia is a matrix of square cells (\"blocks\") with $R$ rows and $C$ columns; rows are numbered (starting from 1) from top to bottom, and columns are numbered (starting from 1) from left to right. The city is served by $S$ different police stations; the i-th station is in the block located in the $R_i$th row and the $C_i$th column, and no block contains more than one station.\n\nEach station is only able to patrol blocks that are no more than $D_i$ blocks away from that station, either horizontally or vertically. That is, the i-th station can only patrol the block in row $R'$ and column $C'$ if $\\max(|R' - R_i|, |C' - C_i|) \\leq D_i$. Put another way, the i-th station can patrol only blocks within the square of side length $2D_i + 1$ centered on that station.\n\nAs the new police commissioner, you need to assign some blocks within the city to exactly one station that is able to patrol it. Blocks that contain stations and blocks that no station is able to patrol should not be assigned. All other blocks have to be assigned. Moreover, you must distribute this assignment load as evenly as possible among stations. Let $A_i$ denote the number of blocks assigned to the i-th station; then your goal is to minimize the difference between the maximum of all the $A_i$ values and the minimum of all of the $A_i$ values. If you make optimal assignments, what is the smallest possible difference?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line with three integers $R$, $C$, and $S$: respectively, the numbers of rows and columns in the grid of cells, and the number of stations. Then, there are $S$ more lines. The i-th of these has three integers $R_i$, $C_i$, and $D_i$: respectively, the row and column in which the i-th station is located, and the parameter that determines which blocks that station is able to patrol, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the difference described above.", "hint": "In Sample Case #1, the city consists of a grid with 3 rows and 4 columns, with one station in the upper left block and one station in the block to the left of the lower right block. The first station can only patrol the three blocks that touch the edge or corner of its block; every other block is at a horizontal or vertical distance of more than 1 away. The second station can patrol any block in the grid (except for the blocks containing the stations). The difference in number of blocks assigned is minimized if you assign station 1 all three of the blocks it can patrol, and then assign the remaining seven blocks to station 2.\n\nIn Sample Case #2, one optimal strategy is to assign the blocks as follows. In this picture, $1$ represents station 1, $2$ represents station 2, $!$ represents a block assigned to station 1, $@$ represents a block assigned to station 2, and $.$ represents a block assigned to neither station (because neither station can patrol it). Notice that a station's assigned blocks do not need to form a single continuous area.\n\n```\n@@@@.\n!!!@.\n!2!@.\n1!!@.\n!@!@.\n```\n\n**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $2 \\leq S \\leq 15.$\n- $1 \\leq R_i \\leq R,$ for all $i.$\n- $1 \\leq C_i \\leq C,$ for all $i.$\n- For all $i \\neq j,$ $R_i \\neq R_j$ and/or $C_i \\neq C_j.$ (No two stations are in the same block.)\n- $1 \\leq D_i < \\max(R, C),$ for all $i.$\n\n**Test set 1 (5 Pts, Visible)**\n\n- $1 \\leq R \\leq 20.$\n- $1 \\leq C \\leq 20.$\n\n**Test set 2 (23 Pts, Hidden)**\n\n- $1 \\leq R \\leq 10^9.$\n- $1 \\leq C \\leq 10^9.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 Finals] Jurisdiction Restrictions", "background": null, "description": "Gridtopia 城市是一个由 $R$ 行 $C$ 列方格（“街区”）组成的矩阵。行号从上到下编号（从 1 开始），列号从左到右编号（从 1 开始）。城市中有 $S$ 个不同的警察局，第 $i$ 个警察局位于第 $R_i$ 行第 $C_i$ 列的街区，并且每个街区最多只包含一个警察局。\n\n每个警察局只能巡逻距离其自身不超过 $D_i$ 个街区的区域（横向或纵向）。也就是说，第 $i$ 个警察局只能巡逻第 $R'$ 行第 $C'$ 列的街区，当且仅当 $\\max(|R' - R_i|, |C' - C_i|) \\leq D_i$。换句话说，第 $i$ 个警察局只能巡逻以其为中心、边长为 $2D_i + 1$ 的正方形范围内的街区。\n\n作为新任警察局长，你需要将城市中的部分街区分配给能够巡逻它们的某一个警察局，并且每个街区只能分配给一个警察局。包含警察局的街区以及没有任何警察局能够巡逻到的街区不需要分配。其他所有街区都必须被分配。此外，你还需要尽可能均匀地分配这些任务。设 $A_i$ 表示分配给第 $i$ 个警察局的街区数，你的目标是最小化所有 $A_i$ 的最大值与最小值之差。如果你采用最优分配方案，这个最小可能的差值是多少？", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据。每组数据的第一行为三个整数 $R$、$C$ 和 $S$，分别表示城市的行数、列数和警察局数量。接下来的 $S$ 行，每行三个整数 $R_i$、$C_i$ 和 $D_i$，分别表示第 $i$ 个警察局所在的行、列，以及该警察局能够巡逻的最大距离参数，如上所述。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是上述最小差值。", "hint": "在样例 1 中，城市为 $3$ 行 $4$ 列的网格，一个警察局在左上角，一个警察局在右下角左侧的街区。第一个警察局只能巡逻与其相邻的三个街区，其他街区距离它的横向或纵向距离都超过 1。第二个警察局可以巡逻除警察局所在街区外的所有街区。如果将第一个警察局能巡逻的三个街区都分配给它，剩下的七个街区分配给第二个警察局，则分配的最大最小差值最小。\n\n在样例 2 中，一种最优分配方式如下图所示。图中 $1$ 表示第 1 个警察局，$2$ 表示第 2 个警察局，$!$ 表示分配给第 1 个警察局的街区，$@$ 表示分配给第 2 个警察局的街区，$.$ 表示没有分配给任何警察局（因为没有警察局能巡逻到）。注意，一个警察局分配到的街区不需要连成一片。\n\n```\n@@@@.\n!!!@.\n!2!@.\n1!!@.\n!@!@.\n```\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq S \\leq 15$。\n- $1 \\leq R_i \\leq R$，对所有 $i$。\n- $1 \\leq C_i \\leq C$，对所有 $i$。\n- 对所有 $i \\neq j$，$R_i \\neq R_j$ 或 $C_i \\neq C_j$（即没有两个警察局在同一个街区）。\n- $1 \\leq D_i < \\max(R, C)$，对所有 $i$。\n\n**测试点 1（5 分，可见）**\n\n- $1 \\leq R \\leq 20$。\n- $1 \\leq C \\leq 20$。\n\n**测试点 2（23 分，隐藏）**\n\n- $1 \\leq R \\leq 10^9$。\n- $1 \\leq C \\leq 10^9$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13154", "type": "P", "difficulty": 7, "samples": [["4\n.@@ .@.\n.@. .@.\n.@@ @@.\n\n@@@ @@@\n@.@ @@@\n@@@ @@@\n\n.@. ...\n@@. .@@\n@.. ...\n\n... ..@\n... ..@\n@.. ...", "Case #1: POSSIBLE\n....11.. ....11..\n...221.. ...221..\n...211.. ...321..\n...22... ...32...\n.333.... .433....\n4343.... 5444....\n444..... 555.....\n........ ........\nCase #2: IMPOSSIBLE\nCase #3: POSSIBLE\n........ ........\n..T..I.. ..T..I..\n.TT..II. .tT..Ii.\n.T....I. .t....i.\n........ ........\n.LL..EE. .LL..EE.\n..LLEE.. ..llee..\n........ ........\nCase #4: POSSIBLE\nthe.CODE AAB.CDDE\nJam.2018 FFB.CGGE\n........ ........\nWorld... HHIIJ...\n.FiNALS. .KLLJMM.\n.cup.... .KNN....\n........ ........\nTRIUMPH! OOPPQQRR"]], "limits": {"time": [30000], "memory": [1048576]}, "tags": ["2018", "Special Judge", "Google Code Jam"], "title": "[GCJ 2018 Finals] Two-Tiling", "background": "", "description": "Your game company just ordered a lot of square game boards with $64$ blank unit cells, intending to turn them into chessboards, but your boss has suddenly declared that chess is out of fashion. To make the best use of all of these boards, you have designed a new puzzle that uses tiles.\n\nA tile is a contiguous set of unit cells, connected edge-to-edge, that can fit inside a $3\\times 3$ square of unit cells. For example, the following are examples of valid tiles (with each @ denoting a piece of the tile, and extra . characters for padding):\n\n```\n... @@@ @@@ .@@\n... @@@ @.@ @.@\n.@. @@@ @.. @@@\n```\n\nThe following would NOT be valid tiles:\n\n```\n@@. @.@ .@@.\n... .@. @@@@\n.@@ @.@ .@@.\n```\n\nWhen the solver of your new puzzle places a tile on the board, its unit cells must exactly overlap some unit cells on the board that have not already been covered by other tiles. A tile is still considered the same type of tile even after being arbitrarily translated, rotated (by multiples of 90 degrees), and/or reflected, and the solver is allowed to do any of those things to a tile while placing it. For example, all of these are considered to be the same tile (and other variants of that tile are possible):\n\n```\n.@. ..@ @.. ... @@.\n@@. .@@ @@. .@@ .@@\n@.. .@. .@. @@. ...\n```\n\nTo make your puzzle, you will color one or more of the cells on the board red. The solver will solve the puzzle by placing tiles on the board such that all red cells are covered up, but no other cell is covered up. To save on manufacturing costs, the solver receives only one type of tile, but they are given exactly enough copies of it to be able to cover all of the red cells.\n\nYour job is to decide which of the board's cells to color red. Unfortunately, your boss is still deciding which of two particular tiles to use for the game. You are tired of waiting, so you have decided to try to color a set of cells such that the puzzle can be solved regardless of which of the tiles ends up being used.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of four lines. Each of the first three lines has three characters, then a single space, then three more characters. The fourth line is a blank line.\n\nWhen looking at an entire case, the space characters separate a $3\\times 3$ grid on the left and a $3\\times 3$ grid on the right. Each grid represents a frame in which one of the two tiles is displayed. In each grid, each character is either @, representing a cell that is part of the tile, or ., representing a cell that is not part of the tile. Note that these . cells have nothing to do with the puzzle or the board, and are just padding to make the shape of the tile clear. It is guaranteed that the two tiles are not the same, as described in the statement above.\n", "outputFormat": "For each test case, output one line with `Case #x: y`, where $x$ is the test case number (starting from 1), and $y$ is POSSIBLE if there is a solution to the problem, and IMPOSSIBLE if there is not. Then, if there is a solution, output eight more lines of seventeen characters each, forming two 8x8 grids with one column of space characters in between. Each grid must use dot (.) characters to denote any blank cells, or characters from the following set of 64:\n\n```\n!?0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n```\n\nto denote the individual tiles used in a solution to the puzzle. Within each $8\\times 8$ grid, each non-dot character must denote a part of the same single tile, and different characters must denote different tiles. Each tile in the grid on the left must be the same as the tile on the left in input, up to rotations, translations and reflections. Each tile in the grid on the right must be the same as the tile on the right in input, up to rotations, translations and reflections. The set of cells that are not dots in both 8x8 grids must be the same, and must be nonempty.\n\nIf there are multiple valid solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible.\n\nIn Sample Case #2, there is no possible set of red cells that would make the puzzle solvable regardless of which of the two tiles is chosen.\n\nIn Sample Cases #3 and #4, note that the chosen set of red cells is not required to be contiguous. Also note that the dots in the input for a tile are not considered part of the tile, and have no significance in creating the puzzle. For example, the given answer would also be acceptable for the following input:\n\n```\n... ...\n.@. .@.\n... .@.\n```\n\nMoreover, that input is isomorphic with Sample Case #4, and would not appear in the same test set along with Sample Case #4.\n\n**Limits for Test set 1 (Visible; the only test set)**\n\n- $T = 595$. (Every possible test case, up to isomorphism, is included.)\n- The cells in each tile in the input form a single contiguous group via their edge-to-edge connections.\n- The two tiles in the input are not the same, as described in the statement.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 Finals] Two-Tiling", "background": "", "description": "Your game company just ordered a lot of square game boards with $64$ blank unit cells, intending to turn them into chessboards, but your boss has suddenly declared that chess is out of fashion. To make the best use of all of these boards, you have designed a new puzzle that uses tiles.\n\nA tile is a contiguous set of unit cells, connected edge-to-edge, that can fit inside a $3\\times 3$ square of unit cells. For example, the following are examples of valid tiles (with each @ denoting a piece of the tile, and extra . characters for padding):\n\n```\n... @@@ @@@ .@@\n... @@@ @.@ @.@\n.@. @@@ @.. @@@\n```\n\nThe following would NOT be valid tiles:\n\n```\n@@. @.@ .@@.\n... .@. @@@@\n.@@ @.@ .@@.\n```\n\nWhen the solver of your new puzzle places a tile on the board, its unit cells must exactly overlap some unit cells on the board that have not already been covered by other tiles. A tile is still considered the same type of tile even after being arbitrarily translated, rotated (by multiples of 90 degrees), and/or reflected, and the solver is allowed to do any of those things to a tile while placing it. For example, all of these are considered to be the same tile (and other variants of that tile are possible):\n\n```\n.@. ..@ @.. ... @@.\n@@. .@@ @@. .@@ .@@\n@.. .@. .@. @@. ...\n```\n\nTo make your puzzle, you will color one or more of the cells on the board red. The solver will solve the puzzle by placing tiles on the board such that all red cells are covered up, but no other cell is covered up. To save on manufacturing costs, the solver receives only one type of tile, but they are given exactly enough copies of it to be able to cover all of the red cells.\n\nYour job is to decide which of the board's cells to color red. Unfortunately, your boss is still deciding which of two particular tiles to use for the game. You are tired of waiting, so you have decided to try to color a set of cells such that the puzzle can be solved regardless of which of the tiles ends up being used.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of four lines. Each of the first three lines has three characters, then a single space, then three more characters. The fourth line is a blank line.\n\nWhen looking at an entire case, the space characters separate a $3\\times 3$ grid on the left and a $3\\times 3$ grid on the right. Each grid represents a frame in which one of the two tiles is displayed. In each grid, each character is either @, representing a cell that is part of the tile, or ., representing a cell that is not part of the tile. Note that these . cells have nothing to do with the puzzle or the board, and are just padding to make the shape of the tile clear. It is guaranteed that the two tiles are not the same, as described in the statement above.\n", "outputFormat": "For each test case, output one line with `Case #x: y`, where $x$ is the test case number (starting from 1), and $y$ is POSSIBLE if there is a solution to the problem, and IMPOSSIBLE if there is not. Then, if there is a solution, output eight more lines of seventeen characters each, forming two 8x8 grids with one column of space characters in between. Each grid must use dot (.) characters to denote any blank cells, or characters from the following set of 64:\n\n```\n!?0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n```\n\nto denote the individual tiles used in a solution to the puzzle. Within each $8\\times 8$ grid, each non-dot character must denote a part of the same single tile, and different characters must denote different tiles. Each tile in the grid on the left must be the same as the tile on the left in input, up to rotations, translations and reflections. Each tile in the grid on the right must be the same as the tile on the right in input, up to rotations, translations and reflections. The set of cells that are not dots in both 8x8 grids must be the same, and must be nonempty.\n\nIf there are multiple valid solutions, you may output any one of them.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible.\n\nIn Sample Case #2, there is no possible set of red cells that would make the puzzle solvable regardless of which of the two tiles is chosen.\n\nIn Sample Cases #3 and #4, note that the chosen set of red cells is not required to be contiguous. Also note that the dots in the input for a tile are not considered part of the tile, and have no significance in creating the puzzle. For example, the given answer would also be acceptable for the following input:\n\n```\n... ...\n.@. .@.\n... .@.\n```\n\nMoreover, that input is isomorphic with Sample Case #4, and would not appear in the same test set along with Sample Case #4.\n\n**Limits for Test set 1 (Visible; the only test set)**\n\n- $T = 595$. (Every possible test case, up to isomorphism, is included.)\n- The cells in each tile in the input form a single contiguous group via their edge-to-edge connections.\n- The two tiles in the input are not the same, as described in the statement.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 Finals] Two-Tiling", "background": null, "description": "你的游戏公司刚刚订购了许多有 $64$ 个空白单元格的正方形游戏棋盘，原本打算将它们制作为国际象棋棋盘，但你的老板突然宣布国际象棋已经过时。为了充分利用这些棋盘，你设计了一种新的拼图游戏，使用“瓷砖”。\n\n一个“瓷砖”是由若干个单元格通过边相连组成的连续区域，且可以放入一个 $3\\times 3$ 的单元格正方形内。例如，以下是一些合法的瓷砖示例（每个 @ 表示瓷砖的一部分，额外的 . 字符用于填充）：\n\n```\n... @@@ @@@ .@@\n... @@@ @.@ @.@\n.@. @@@ @.. @@@\n```\n\n以下则不是合法的瓷砖：\n\n```\n@@. @.@ .@@.\n... .@. @@@@\n.@@ @.@ .@@.\n```\n\n当玩家在棋盘上放置瓷砖时，瓷砖的单元格必须完全覆盖棋盘上未被其他瓷砖覆盖的某些单元格。即使经过任意平移、90 度倍数的旋转和/或翻转后，仍然视为同一种瓷砖，玩家在放置时可以进行这些操作。例如，以下所有都是同一种瓷砖（还可能有其它变体）：\n\n```\n.@. ..@ @.. ... @@.\n@@. .@@ @@. .@@ .@@\n@.. .@. .@. @@. ...\n```\n\n为了制作拼图，你会将棋盘上的一个或多个单元格涂成红色。玩家需要通过放置瓷砖，使所有红色单元格都被覆盖，且没有其他单元格被覆盖。为节省制造成本，玩家只会获得一种瓷砖，但会获得恰好足够多的该瓷砖以覆盖所有红色单元格。\n\n你的任务是决定哪些棋盘单元格需要涂成红色。不幸的是，你的老板还在犹豫究竟用哪两种瓷砖。你厌倦了等待，于是决定尝试涂色，使得无论最终选择哪种瓷砖，拼图都能被解出。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试用例；每组包含四行。前三行每行有三个字符，然后一个空格，再三个字符。第四行为空行。\n\n每组测试用例中，空格将左侧和右侧的两个 $3\\times 3$ 网格分开。每个网格表示一种瓷砖的形状。网格中的每个字符要么是 @（表示瓷砖的一部分），要么是 .（表示不是瓷砖的一部分，仅用于填充以便形状清晰）。注意，这些 . 与拼图或棋盘无关，仅用于展示瓷砖形状。保证输入的两种瓷砖不是同一种瓷砖（如上文所述）。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 为 POSSIBLE（存在解）或 IMPOSSIBLE（不存在解）。如果存在解，则再输出八行，每行十七个字符，形成两个 $8\\times 8$ 的网格，中间用一个空格分隔。每个网格用点（.）表示空白单元格，或用如下 64 个字符之一：\n\n```\n!?0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n```\n\n表示每个瓷砖的不同部分。在每个 $8\\times 8$ 网格中，相同的非点字符表示同一个瓷砖的不同部分，不同字符表示不同的瓷砖。左侧网格中的每个瓷砖必须与输入左侧的瓷砖一致（允许旋转、平移和翻转），右侧网格同理。两个 $8\\times 8$ 网格中非点字符所在的单元格集合必须完全相同，且非空。\n\n如果有多组合法解，可以输出任意一组。", "hint": "**样例解释**\n\n样例输出展示了样例的某一组答案，其他答案也可能合法。\n\n在样例第 2 组中，不存在一组红色单元格能使得无论选择哪种瓷砖都能解出拼图。\n\n在样例第 3、4 组中，所选的红色单元格不要求连通。注意，输入中瓷砖的点（.）不参与拼图，仅用于展示。例如，以下输入也可以接受：\n\n```\n... ...\n.@. .@.\n... .@.\n```\n\n此外，该输入与样例第 4 组同构，因此不会同时出现在同一测试集中。\n\n**第 1 组数据范围（可见，且为唯一测试集）**\n\n- $T = 595$。（包含所有可能的测试用例，按同构分类）\n- 输入中每个瓷砖的单元格通过边相连，形成一个连通块。\n- 输入的两种瓷砖不是同一种瓷砖（如上文所述）。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13155", "type": "P", "difficulty": 6, "samples": [["", ""]], "limits": {"time": [90000, 90000], "memory": [1048576, 1048576]}, "tags": ["2018", "二分", "交互题", "Special Judge", "Google Code Jam"], "title": "[GCJ 2018 Finals] Go, Gophers!", "background": "", "description": "Earlier this year, the Code Jam team planted an orchard with the help of an industrious gopher. It must have told other gophers, because we now have somewhere between 2 and 25 gophers living in the orchard. But it is hard to be sure exactly how many there are, because these gophers only emerge from their underground tunnels to eat at night, and we are too tired after a hard day of tree-pruning to stay up and watch for them. However, we do know how to make one \"gopher snack\" per day, which we can leave out each night to see whether it gets eaten. We think we can use this information to determine the number of gophers.\n\nHere is what we know about the way that gophers eat. The $N$ gophers meet during one day in a council to determine an order in which they will emerge over the following $N$ nights, one at a time. Then, during each of the $i$-th of the next $N$ nights, the $i$-th gopher in the order emerges and looks for a gopher snack. Each gopher has its own particular taste level (which never changes), and it will eat a snack if and only if the snack's quality level is at least as high as that gopher's taste level. During the day after the $N$-th gopher in the order has emerged, the gophers choose a new order and the process continues. Notice that even if a gopher chooses not to eat the snack that it finds, it still does not emerge again until it comes up in the next order chosen by the council.\n\nWe must make exactly one new gopher snack each day; even if a snack is not eaten, it spoils and cannot be reused the next night. Each morning, we learn whether or not the previous night's snack was taken.\n\nToday, we know that the gophers are meeting in their council to determine their next order, so tonight will mark the start of that order. We are willing to devote some serious time to this investigation — as many as $10^5$ nights. Using $S$ or fewer snacks, can you help us figure out how many gophers there are?\n\n**Interactive Protocol**\n\nThis problem is interactive, which means that the concepts of input and output are different than in standard Code Jam problems. You will interact with a separate process that both provides you with information and evaluates your responses. All information comes into your program via standard input; anything that you need to communicate should be sent via standard output. Remember that many programming languages buffer the output by default, so make sure your output actually goes out (for instance, by flushing the buffer) before blocking to wait for a response. See the [FAQ](http://faq) for an explanation of what it means to flush the buffer. Anything your program sends through standard error is ignored, but it might consume some memory and be counted against your memory limit, so do not overflow it. To help you debug, a local testing tool script (in Python) is provided at the very end of the problem statement. In addition, sample solutions to a previous Code Jam interactive problem (in all of our supported languages) are provided in the analysis for [Number Guessing](http://number_guessing).\n\nInitially, your program should read a single line containing a single integer $T$ indicating the number of test cases. Then, you need to process $T$ test cases. For each test case, your program will first read one line containing one integer $S$: the maximum number of snacks you can use. Then, your program will process up to $S + 1$ exchanges with our judge, in which the last exchange must be a guess at the answer.\n\nFor the $i$-th exchange, your program needs to use standard output to send a single line containing an integer $Q_i$.\n\n* If $Q_i$ is in the inclusive range $[1, 10^6]$, it represents that you will leave out a gopher snack with quality level $Q_i$. In response, the judge will print a single line with a single integer: 1 if the gopher ate the snack, or 0 if it did not. This line will be printed to your input stream, as described above, and your program must read it through standard input. Then, you can start another exchange.\n* If $Q_i$ is in the inclusive range $[-25, -2]$, it represents that your answer to the test case is that there are $-Q_i$ gophers. If your answer is correct, the judge will proceed to the next test case, if there is one.\n\nThe judge will print a single line with the integer $-1$, and then stop sending output to your input stream, if any of the following happen:\n\n1. Your program sends a malformed or out-of-bounds value (e.g., $1000001$, $-1$, or GO_IS_THE_BEST_LANGUAGE), or too many values (e.g., 1 2).\n2. Your program sends a value not in the inclusive range $[-25, -2]$ after having already sent $S$ values for the current test case.\n3. Your program sends a value in the inclusive range $[-25, -2]$ that is not a correct answer. Note that this means that you only get one chance to answer a test case correctly.\n\nIf your program continues to wait for the judge after receiving $-1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive the appropriate verdict (Wrong Answer, Runtime Error, etc.) instead of a Time Limit Exceeded error. As usual, if the total time or memory is exceeded, or your program gets a runtime error, you will receive the appropriate verdict.\n\nYou should not send additional information to the judge after solving all test cases. In other words, if your program keeps printing to standard output after sending the answer to the last test case, you will get a Wrong Answer judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interactions**\n\nThe following interaction is for Test set 1.\n\n```\n  // In this example, the problem setters have already determined that the first\n  // test case has two gophers with taste levels 1 and 2 (we will call them A\n  // and B, respectively), and that the second test case has four gophers with\n  // taste levels 1, 999, 123, and 4567 (we will call them C, D, E, and F,\n  // respectively).\n  // The judge randomly generates the first order: A, B.\n  t = readline_int()           // Code reads 2 into t.\n  s = readline_int()           // Code reads 100000 into s.\n  printline 1 to stdout        // Code sends a snack with quality level 1.\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate the\n                               //   snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_srt()        // Code reads 0 into resp (gopher B did not eat\n                               //   the snack).\n                               // Judge randomly generates B, A as the next\n                               //   order.\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher B ate the\n                               //   snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate the\n                               //   snack).\n                               // Judge randomly generates B, A as the next\n                               //   order.\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher B ate the\n                               //   snack).\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate the\n                               //   snack).\n  printline -2 to stdout       // Code correctly determines that the only\n  flush stdout                 //   scenario consistent with the information\n                               //   given so far is two gophers with taste\n                               //   levels 1 and 2.\n                               // Judge rules that the answer is correct, and\n                               //   prepares the next test case...\n                               // Judge randomly generates C, E, F, D as the\n                               //   first order.\n  s = readline_int()           // Code reads 100000 into s. (This also shows\n                               //   that the answer to the first test case was\n                               //   correct.)\n  printline 0 to stdout        // Code sends an invalid value.\n  flush stdout\n  resp = readline_str()        // Code reads -1 into resp.\n  exit                         // Code exits to avoid an ambiguous TLE error.\n```\n\nThe following interaction is for Test set 2. Notice that the interactions in the first test case are the same as in the previous example, but the outcome is different.\n\n```\n\n  // In this example, the problem setters have already determined that the first\n  // test case has three gophers with taste levels 1, 2, and 1; we will call\n  // them A, B, and C, respectively, and they will be ordered ABCCBAABCCBA...\n  t = readline_int()           // Code reads 1 into t.\n  s = readline_int()           // Code reads 100000 into s.\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate\n                               //   the snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_srt()        // Code reads 0 into resp (gopher B did not eat\n                               //   the snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher C ate the\n                               //   snack).\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher C ate the\n                               //   snack).\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher B ate the\n                               //   snack).\n  printline -2 to stdout       // Code erroneously decides that there\n                               //   are two gophers A and B with taste levels\n                               //   1 and 2; this is consistent with the\n                               //   information given so far for the order\n                               //   A,B,A,B,A, but the true number of gophers\n  flush stdout                 //   is different, so judge rules it is wrong.\n  s = readline_str()           // Code tries to read s but gets -1, meaning\n                               //   that the answer to the last test case was\n                               //   wrong.\n  exit                         // Code exits to avoid an ambiguous TLE error.\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Important warning**\n\nContext switching between your program and the judge is expensive, and more so in our judging system. As opposed to other interactive problems, we found it necessary in all our reference solutions for this problem to bundle the exchanges to the server. That is, instead of \"print taste level, read response, print taste level, read response\" we can do \"print taste level, print taste level, read response, read response\" which requires less context switching.\n\n**Benchmarks**\n\nTo give you some idea of how a given bundling of queries will perform in our system, we are providing some benchmarks. We wrote a program that performs $S = 10^5$ exchanges bundled into groups of specific sizes $B$ — that is, it prints $B$ taste levels, then reads $B$ responses, then prints $B$ more, then reads $B$ more, and so on, $S / B$ times. We implemented this in both Python and C++, always printing the $B$ taste levels to a string variable and printing that string later, ensuring the buffer is not flushed within a bundle. Here are the results for each bundle size $B$, in seconds (rounded up to the next half-second, and taking the worst case over multiple runs):\n\n| $B$ | 1 | 10 | 50 | 100 | 200 | 500 | $10^5$ |\n|:---:|:---:|:----:|:----:|:-----:|:-----:|:-----:|:--------:|\n| Python | 167 | 21 | 6.5 | 5.5 | 5 | 5 | >250 |\n| C++ | 130 | 18 | 5.5 | 5.5 | 4.5 | 2.5 | >250 |\n\nNotice that with somewhat small bundle sizes, the context switching time gets below 5s per test, which is under a minute per test set.\n\n**Limits**\n\n- $1 \\leq T \\leq 10$.\n- The number of gophers is between 2 and 25, inclusive. The taste level of each gopher is between 1 and $10^6$, inclusive. $S = 10^5$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- No two gophers have the same taste level.\n- The order in which the gophers emerge each night is chosen uniformly at random from all possible orders, and independently of all other orders.\n\n**Test set 2 (38 Pts, Hidden)**\n\n- The GCD of the set $\\{x : \\text{there exist exactly } x \\geq 1 \\text{ gophers in the input that share a taste level}\\} = 1$.\n- The order in which the gophers emerge is chosen independently of the provided snacks.\n\nFor each test case, the multiset of taste levels and the seed for the random number generation are generated by the problem setters in advance of the contest, and will be the same for any contestant, for any submission. That means two submissions that offer the same number $s_i$ of snacks for test case $i$ will see the gophers emerge in the same order.\n  - For example, the following scenario would be possible in either of the test sets:\n    * two gophers, one with taste level 1, and one with taste level 2\n  - The following scenario would be possible in test set 2, but not in test set 1:\n    * three gophers, two with taste level 1, and one with taste level 2\n  - The following scenarios would not be possible in either of the test sets:\n    * six gophers, four with taste level 1, and two with taste level 2\n    * two gophers, both with taste level 7", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 Finals] Go, Gophers!", "background": "", "description": "Earlier this year, the Code Jam team planted an orchard with the help of an industrious gopher. It must have told other gophers, because we now have somewhere between 2 and 25 gophers living in the orchard. But it is hard to be sure exactly how many there are, because these gophers only emerge from their underground tunnels to eat at night, and we are too tired after a hard day of tree-pruning to stay up and watch for them. However, we do know how to make one \"gopher snack\" per day, which we can leave out each night to see whether it gets eaten. We think we can use this information to determine the number of gophers.\n\nHere is what we know about the way that gophers eat. The $N$ gophers meet during one day in a council to determine an order in which they will emerge over the following $N$ nights, one at a time. Then, during each of the $i$-th of the next $N$ nights, the $i$-th gopher in the order emerges and looks for a gopher snack. Each gopher has its own particular taste level (which never changes), and it will eat a snack if and only if the snack's quality level is at least as high as that gopher's taste level. During the day after the $N$-th gopher in the order has emerged, the gophers choose a new order and the process continues. Notice that even if a gopher chooses not to eat the snack that it finds, it still does not emerge again until it comes up in the next order chosen by the council.\n\nWe must make exactly one new gopher snack each day; even if a snack is not eaten, it spoils and cannot be reused the next night. Each morning, we learn whether or not the previous night's snack was taken.\n\nToday, we know that the gophers are meeting in their council to determine their next order, so tonight will mark the start of that order. We are willing to devote some serious time to this investigation — as many as $10^5$ nights. Using $S$ or fewer snacks, can you help us figure out how many gophers there are?\n\n**Interactive Protocol**\n\nThis problem is interactive, which means that the concepts of input and output are different than in standard Code Jam problems. You will interact with a separate process that both provides you with information and evaluates your responses. All information comes into your program via standard input; anything that you need to communicate should be sent via standard output. Remember that many programming languages buffer the output by default, so make sure your output actually goes out (for instance, by flushing the buffer) before blocking to wait for a response. See the [FAQ](http://faq) for an explanation of what it means to flush the buffer. Anything your program sends through standard error is ignored, but it might consume some memory and be counted against your memory limit, so do not overflow it. To help you debug, a local testing tool script (in Python) is provided at the very end of the problem statement. In addition, sample solutions to a previous Code Jam interactive problem (in all of our supported languages) are provided in the analysis for [Number Guessing](http://number_guessing).\n\nInitially, your program should read a single line containing a single integer $T$ indicating the number of test cases. Then, you need to process $T$ test cases. For each test case, your program will first read one line containing one integer $S$: the maximum number of snacks you can use. Then, your program will process up to $S + 1$ exchanges with our judge, in which the last exchange must be a guess at the answer.\n\nFor the $i$-th exchange, your program needs to use standard output to send a single line containing an integer $Q_i$.\n\n* If $Q_i$ is in the inclusive range $[1, 10^6]$, it represents that you will leave out a gopher snack with quality level $Q_i$. In response, the judge will print a single line with a single integer: 1 if the gopher ate the snack, or 0 if it did not. This line will be printed to your input stream, as described above, and your program must read it through standard input. Then, you can start another exchange.\n* If $Q_i$ is in the inclusive range $[-25, -2]$, it represents that your answer to the test case is that there are $-Q_i$ gophers. If your answer is correct, the judge will proceed to the next test case, if there is one.\n\nThe judge will print a single line with the integer $-1$, and then stop sending output to your input stream, if any of the following happen:\n\n1. Your program sends a malformed or out-of-bounds value (e.g., $1000001$, $-1$, or GO_IS_THE_BEST_LANGUAGE), or too many values (e.g., 1 2).\n2. Your program sends a value not in the inclusive range $[-25, -2]$ after having already sent $S$ values for the current test case.\n3. Your program sends a value in the inclusive range $[-25, -2]$ that is not a correct answer. Note that this means that you only get one chance to answer a test case correctly.\n\nIf your program continues to wait for the judge after receiving $-1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive the appropriate verdict (Wrong Answer, Runtime Error, etc.) instead of a Time Limit Exceeded error. As usual, if the total time or memory is exceeded, or your program gets a runtime error, you will receive the appropriate verdict.\n\nYou should not send additional information to the judge after solving all test cases. In other words, if your program keeps printing to standard output after sending the answer to the last test case, you will get a Wrong Answer judgment.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "**Sample Interactions**\n\nThe following interaction is for Test set 1.\n\n```\n  // In this example, the problem setters have already determined that the first\n  // test case has two gophers with taste levels 1 and 2 (we will call them A\n  // and B, respectively), and that the second test case has four gophers with\n  // taste levels 1, 999, 123, and 4567 (we will call them C, D, E, and F,\n  // respectively).\n  // The judge randomly generates the first order: A, B.\n  t = readline_int()           // Code reads 2 into t.\n  s = readline_int()           // Code reads 100000 into s.\n  printline 1 to stdout        // Code sends a snack with quality level 1.\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate the\n                               //   snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_srt()        // Code reads 0 into resp (gopher B did not eat\n                               //   the snack).\n                               // Judge randomly generates B, A as the next\n                               //   order.\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher B ate the\n                               //   snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate the\n                               //   snack).\n                               // Judge randomly generates B, A as the next\n                               //   order.\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher B ate the\n                               //   snack).\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate the\n                               //   snack).\n  printline -2 to stdout       // Code correctly determines that the only\n  flush stdout                 //   scenario consistent with the information\n                               //   given so far is two gophers with taste\n                               //   levels 1 and 2.\n                               // Judge rules that the answer is correct, and\n                               //   prepares the next test case...\n                               // Judge randomly generates C, E, F, D as the\n                               //   first order.\n  s = readline_int()           // Code reads 100000 into s. (This also shows\n                               //   that the answer to the first test case was\n                               //   correct.)\n  printline 0 to stdout        // Code sends an invalid value.\n  flush stdout\n  resp = readline_str()        // Code reads -1 into resp.\n  exit                         // Code exits to avoid an ambiguous TLE error.\n```\n\nThe following interaction is for Test set 2. Notice that the interactions in the first test case are the same as in the previous example, but the outcome is different.\n\n```\n\n  // In this example, the problem setters have already determined that the first\n  // test case has three gophers with taste levels 1, 2, and 1; we will call\n  // them A, B, and C, respectively, and they will be ordered ABCCBAABCCBA...\n  t = readline_int()           // Code reads 1 into t.\n  s = readline_int()           // Code reads 100000 into s.\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate\n                               //   the snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_srt()        // Code reads 0 into resp (gopher B did not eat\n                               //   the snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher C ate the\n                               //   snack).\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher C ate the\n                               //   snack).\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher B ate the\n                               //   snack).\n  printline -2 to stdout       // Code erroneously decides that there\n                               //   are two gophers A and B with taste levels\n                               //   1 and 2; this is consistent with the\n                               //   information given so far for the order\n                               //   A,B,A,B,A, but the true number of gophers\n  flush stdout                 //   is different, so judge rules it is wrong.\n  s = readline_str()           // Code tries to read s but gets -1, meaning\n                               //   that the answer to the last test case was\n                               //   wrong.\n  exit                         // Code exits to avoid an ambiguous TLE error.\n```\n\nYou can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.\n\nInstructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.\n\n**Important warning**\n\nContext switching between your program and the judge is expensive, and more so in our judging system. As opposed to other interactive problems, we found it necessary in all our reference solutions for this problem to bundle the exchanges to the server. That is, instead of \"print taste level, read response, print taste level, read response\" we can do \"print taste level, print taste level, read response, read response\" which requires less context switching.\n\n**Benchmarks**\n\nTo give you some idea of how a given bundling of queries will perform in our system, we are providing some benchmarks. We wrote a program that performs $S = 10^5$ exchanges bundled into groups of specific sizes $B$ — that is, it prints $B$ taste levels, then reads $B$ responses, then prints $B$ more, then reads $B$ more, and so on, $S / B$ times. We implemented this in both Python and C++, always printing the $B$ taste levels to a string variable and printing that string later, ensuring the buffer is not flushed within a bundle. Here are the results for each bundle size $B$, in seconds (rounded up to the next half-second, and taking the worst case over multiple runs):\n\n| $B$ | 1 | 10 | 50 | 100 | 200 | 500 | $10^5$ |\n|:---:|:---:|:----:|:----:|:-----:|:-----:|:-----:|:--------:|\n| Python | 167 | 21 | 6.5 | 5.5 | 5 | 5 | >250 |\n| C++ | 130 | 18 | 5.5 | 5.5 | 4.5 | 2.5 | >250 |\n\nNotice that with somewhat small bundle sizes, the context switching time gets below 5s per test, which is under a minute per test set.\n\n**Limits**\n\n- $1 \\leq T \\leq 10$.\n- The number of gophers is between 2 and 25, inclusive. The taste level of each gopher is between 1 and $10^6$, inclusive. $S = 10^5$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- No two gophers have the same taste level.\n- The order in which the gophers emerge each night is chosen uniformly at random from all possible orders, and independently of all other orders.\n\n**Test set 2 (38 Pts, Hidden)**\n\n- The GCD of the set $\\{x : \\text{there exist exactly } x \\geq 1 \\text{ gophers in the input that share a taste level}\\} = 1$.\n- The order in which the gophers emerge is chosen independently of the provided snacks.\n\nFor each test case, the multiset of taste levels and the seed for the random number generation are generated by the problem setters in advance of the contest, and will be the same for any contestant, for any submission. That means two submissions that offer the same number $s_i$ of snacks for test case $i$ will see the gophers emerge in the same order.\n  - For example, the following scenario would be possible in either of the test sets:\n    * two gophers, one with taste level 1, and one with taste level 2\n  - The following scenario would be possible in test set 2, but not in test set 1:\n    * three gophers, two with taste level 1, and one with taste level 2\n  - The following scenarios would not be possible in either of the test sets:\n    * six gophers, four with taste level 1, and two with taste level 2\n    * two gophers, both with taste level 7", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 Finals] Go, Gophers!", "background": null, "description": "今年早些时候，Code Jam 团队在一只勤劳的地鼠的帮助下种植了一片果园。可能是它把消息告诉了其他地鼠，现在果园里住着 2 到 25 只地鼠。但我们很难确定具体有多少只，因为这些地鼠只在夜间从地下洞穴出来觅食，而我们经过一天的修剪树木后太累，无法熬夜观察。不过，我们知道每天可以制作一个“地鼠零食”，晚上放出去看看是否被吃掉。我们认为可以利用这些信息来确定地鼠的数量。\n\n以下是我们已知的地鼠觅食方式。$N$ 只地鼠会在白天开会，决定接下来 $N$ 个夜晚它们出洞的顺序，每晚一只。然后，在接下来的第 $i$ 个夜晚，顺序中的第 $i$ 只地鼠会出来寻找地鼠零食。每只地鼠都有自己独特的口味等级（且永远不会改变），只有当零食的质量等级不低于该地鼠的口味等级时，它才会吃掉零食。在顺序中的第 $N$ 只地鼠出来后的第二天，地鼠们会重新决定顺序，流程再次循环。注意，即使某只地鼠选择不吃它发现的零食，它也不会再次出现，直到下次会议决定的新顺序轮到它。\n\n我们每天必须制作一个新的地鼠零食；即使零食没有被吃掉，也会变质，不能留到第二天。每天早上，我们会得知前一晚的零食是否被吃掉。\n\n今天，我们知道地鼠们正在开会决定新的顺序，所以今晚将是新顺序的开始。我们愿意为这项调查投入大量时间——最多 $10^5$ 个夜晚。请你帮我们用不超过 $S$ 个零食，确定地鼠的数量。\n\n**交互协议**\n\n本题为交互题，这意味着输入输出方式与标准 Code Jam 题目不同。你需要与一个独立进程进行交互，该进程既向你提供信息，也会评判你的回答。所有信息通过标准输入进入你的程序；你需要传达的信息应通过标准输出发送。请注意，许多编程语言默认会缓冲输出，因此在等待响应前请确保你的输出已真正发送（例如，刷新缓冲区）。详见 [FAQ](http://faq) 关于刷新缓冲区的说明。你通过标准错误发送的任何内容都会被忽略，但可能会占用内存并计入内存限制，因此请勿溢出。为帮助调试，题目末尾提供了本地测试工具脚本（Python）。此外，[Number Guessing](http://number_guessing) 的分析中提供了以所有支持语言编写的交互题样例代码。\n\n最开始，你的程序应读取一行，包含一个整数 $T$，表示测试用例数量。然后，你需要处理 $T$ 个测试用例。对于每个测试用例，你的程序首先读取一行，包含一个整数 $S$，表示你最多可以使用的零食数量。接下来，你的程序将与评测机进行最多 $S+1$ 次交互，其中最后一次必须是对答案的猜测。\n\n在第 $i$ 次交互中，你的程序需要通过标准输出发送一行，包含一个整数 $Q_i$。\n\n- 如果 $Q_i$ 在区间 $[1, 10^6]$ 内，表示你放置了一个质量等级为 $Q_i$ 的地鼠零食。作为回应，评测机会向你的输入流输出一行，包含一个整数：若地鼠吃了零食则为 1，否则为 0。你的程序必须通过标准输入读取该值。然后可以开始下一次交互。\n- 如果 $Q_i$ 在区间 $[-25, -2]$ 内，表示你认为本测试用例中有 $-Q_i$ 只地鼠。如果你的答案正确，评测机会进入下一个测试用例（如果还有的话）。\n\n如果发生以下任一情况，评测机会输出一行 $-1$，然后停止向你的输入流发送输出：\n\n1. 你的程序发送了格式错误或越界的值（如 $1000001$、$-1$ 或 GO_IS_THE_BEST_LANGUAGE），或发送了过多的值（如 1 2）。\n2. 在当前测试用例中，已经发送了 $S$ 个值后，又发送了区间 $[-25, -2]$ 内的值。\n3. 你的程序发送了区间 $[-25, -2]$ 内的值，但答案不正确。注意，每个测试用例你只有一次答题机会。\n\n如果你的程序在收到 $-1$ 后仍继续等待评测机，将会超时，导致 Time Limit Exceeded 错误。请注意，你有责任让程序及时退出，以获得正确的评判结果（Wrong Answer、Runtime Error 等），而不是超时。和往常一样，如果总时间或内存超限，或程序运行时出错，你将收到相应的评判结果。\n\n在解决所有测试用例后，不应再向评测机发送任何信息。换句话说，如果你在发送最后一个测试用例的答案后仍继续向标准输出打印内容，将会被判为 Wrong Answer。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "**样例交互**\n\n以下交互为测试集 1 的示例。\n\n```\n  // 在本例中，出题人已确定第一个测试用例有两只地鼠，口味等级分别为 1 和 2（我们称它们为 A 和 B），第二个测试用例有四只地鼠，口味等级分别为 1、999、123 和 4567（我们称它们为 C、D、E 和 F）。\n  // 评测机随机生成第一个顺序：A, B。\n  t = readline_int()           // 代码读取到 t=2。\n  s = readline_int()           // 代码读取到 s=100000。\n  printline 1 to stdout        // 代码发送一个质量等级为 1 的零食。\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 A 吃了零食）。\n  printline 1 to stdout\n  flush stdout\n  resp = readline_srt()        // 代码读取到 resp=0（地鼠 B 没有吃零食）。\n                               // 评测机随机生成下一个顺序 B, A。\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 B 吃了零食）。\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 A 吃了零食）。\n                               // 评测机随机生成下一个顺序 B, A。\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 B 吃了零食）。\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 A 吃了零食）。\n  printline -2 to stdout       // 代码正确判断唯一符合条件的情况是两只地鼠，口味等级为 1 和 2。\n  flush stdout                 // 评测机判定答案正确，准备下一个测试用例……\n                               // 评测机随机生成 C, E, F, D 作为第一个顺序。\n  s = readline_int()           // 代码读取到 s=100000。（这也说明第一个测试用例答案正确。）\n  printline 0 to stdout        // 代码发送了一个非法值。\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=-1。\n  exit                         // 代码退出以避免出现不明确的 TLE 错误。\n```\n\n以下交互为测试集 2 的示例。注意第一个测试用例的交互与前例相同，但结果不同。\n\n```\n  // 在本例中，出题人已确定第一个测试用例有三只地鼠，口味等级分别为 1、2 和 1；我们称它们为 A、B 和 C，顺序为 ABCCBAABCCBA……\n  t = readline_int()           // 代码读取到 t=1。\n  s = readline_int()           // 代码读取到 s=100000。\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 A 吃了零食）。\n  printline 1 to stdout\n  flush stdout\n  resp = readline_srt()        // 代码读取到 resp=0（地鼠 B 没有吃零食）。\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 C 吃了零食）。\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 C 吃了零食）。\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // 代码读取到 resp=1（地鼠 B 吃了零食）。\n  printline -2 to stdout       // 代码错误地判断只有两只地鼠 A 和 B，口味等级为 1 和 2；这与当前顺序 A,B,A,B,A 一致，但实际地鼠数量不同，因此评测机判定错误。\n  flush stdout\n  s = readline_str()           // 代码尝试读取 s，但得到 -1，表示上一个测试用例答案错误。\n  exit                         // 代码退出以避免出现不明确的 TLE 错误。\n```\n\n你可以使用本地测试工具在本地或平台上测试。若要在本地测试，需要并行运行该工具和你的代码；可使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件注释中的说明。\n\n测试工具的使用说明已包含在工具注释中。我们鼓励你自行添加测试用例。请注意，尽管测试工具旨在模拟评测系统，但它**不是**真实的评测系统，可能会有不同的行为。\n\n**重要警告**\n\n你与评测机之间的上下文切换开销很大，在我们的评测系统中更甚。与其他交互题不同，我们发现本题所有参考解法都需要将多次交互打包发送。即，不是“打印口味等级，读取响应，打印口味等级，读取响应”，而是“打印多个口味等级，再读取多个响应”，这样可以减少上下文切换。\n\n**性能基准**\n\n为帮助你了解不同批量交互的性能，我们提供了如下基准。我们写了一个程序，进行 $S=10^5$ 次交互，每 $B$ 次为一组——即先打印 $B$ 个口味等级，再读取 $B$ 个响应，如此 $S/B$ 组。我们用 Python 和 C++ 实现，始终将 $B$ 个口味等级打印到字符串变量，最后再输出，确保批量内不刷新缓冲区。以下为每个批量大小 $B$ 的耗时（秒，向上取整，多次运行取最大值）：\n\n| $B$ | 1 | 10 | 50 | 100 | 200 | 500 | $10^5$ |\n|:---:|:---:|:----:|:----:|:-----:|:-----:|:-----:|:--------:|\n| Python | 167 | 21 | 6.5 | 5.5 | 5 | 5 | >250 |\n| C++ | 130 | 18 | 5.5 | 5.5 | 4.5 | 2.5 | >250 |\n\n注意，批量较小时，上下文切换时间可降至每组 5 秒以内，整个测试集不到一分钟。\n\n**数据范围**\n\n- $1 \\leq T \\leq 10$。\n- 地鼠数量在 2 到 25 之间，口味等级在 1 到 $10^6$ 之间。$S=10^5$。\n\n**测试集 1（10 分，可见）**\n\n- 没有两只地鼠的口味等级相同。\n- 每晚地鼠出洞顺序均匀随机，从所有可能顺序中独立选择。\n\n**测试集 2（38 分，隐藏）**\n\n- 集合 $\\{x : \\text{存在恰好 } x \\geq 1 \\text{ 只地鼠口味等级相同}\\}$ 的最大公约数为 1。\n- 地鼠出洞顺序与所提供零食无关，且每次独立选择。\n\n对于每个测试用例，口味等级的多重集和随机数生成种子由出题人在赛前预先生成，对于任何选手、任何提交都是相同的。这意味着对于同一个测试用例，提交相同数量 $s_i$ 的零食，地鼠出现的顺序也完全相同。\n  - 例如，以下情况在任意测试集都可能出现：\n    * 两只地鼠，口味等级分别为 1 和 2\n  - 以下情况只可能出现在测试集 2，不会出现在测试集 1：\n    * 三只地鼠，两只口味等级为 1，一只口味等级为 2\n  - 以下情况在任意测试集都不会出现：\n    * 六只地鼠，四只口味等级为 1，两只口味等级为 2\n    * 两只地鼠，口味等级均为 7\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13156", "type": "P", "difficulty": 7, "samples": [["3\n5\n0 1001 -1 1001\n0 1001 -1 1001\n0 1001 -2 1001\n0 1001 0 500\n0 1002 1234 5678\n4\n500 500 1000 1000\n500 500 0 1000\n500 500 0 0\n500 500 1000 0\n4\n500 500 1000 1001\n500 500 0 1000\n500 500 0 0\n500 500 1000 0", "Case #1: 1.000000\nCase #2: 0.750000\nCase #3: 1.000000"]], "limits": {"time": [40000, 40000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2018", "Special Judge", "Google Code Jam"], "title": "[GCJ 2018 Finals] The Cartesian Job", "background": "", "description": "You may have heard of the platinum-iridium cylinder that serves as the standard for the kilogram, but did you know that there is a special line segment used as the standard for the kilometer? It runs from $(0, 0)$ to $(0, 1000)$ in a 2D plane in a confidential and very flat location.\n\nNaturally, this segment is extremely valuable, so it is protected by $N$ rotating surveillance lasers, which are rays in the 2D plane. Each laser has a fixed endpoint, and it rotates around that endpoint at a constant speed of 1 revolution per second. Whether each laser rotates clockwise or counterclockwise is chosen uniformly and independently at random by the security system.\n\nLasers are not blocked by other lasers or their endpoints, or the segment itself. No laser has an endpoint on the segment.\n\nYou have been hired to audit the security system, but all you have to work with is a single snapshot from an instant in time, which shows the endpoint and orientation (at that instant) of each laser. Since the image is just a snapshot, you have no way of inferring the rotation directions of the lasers.\n\nYou have determined that the segment could be stolen in a heist if there is ever a non-empty open interval of time during which no laser is touching the segment. What is the probability of this happening?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line containing one integer $N$: the number of lasers. Then, $N$ more lines follow. The $i$-th of these lines represents the ray that is the $i$-th laser, and contains four integers $X_i$, $Y_i$, $X_i'$, and $Y_i'$, representing the 2D coordinates of the endpoint of the ray, followed by the 2D coordinates of some other point on the ray.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the probability described above. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, note that multiple lasers might share the same endpoint and initial orientation, but this does not necessarily imply that they rotate in the same direction. (Also note that the second and third lasers have the same initial orientation even though it is specified differently.) Regardless of their rotation directions, though, each of these lasers only touches the segment at the instant that it is pointing in the negative y direction, so there is clearly some other open interval during which no laser is touching the segment, and the answer is 1.\n\nIn Sample Case #2, each of the lasers touches the segment during exactly 1/4 of its rotation, and the segment will be touched by a laser at all times if and only if lasers 1 and 4 rotate in the same direction, and lasers 2 and 3 rotate in the same direction. The probability of that is 1/4, so the answer is 3/4.\n\nSample Case #3 is like Sample Case #2, but with a slight difference that guarantees that there will be an instant at which no laser is touching the segment, even if the lasers are all rotating the same way. So the answer is 1.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $-10^6 \\leq X_i \\leq 10^6$, for all $i$.\n- $-10^6 \\leq Y_i \\leq 10^6$, for all $i$.\n- $-10^6 \\leq X_i' \\leq 10^6$, for all $i$.\n- $-10^6 \\leq Y_i' \\leq 10^6$, for all $i$.\n- $(X_i, Y_i) \\neq (X_i', Y_i')$, for all $i$.\n- If $X_i = 0$, then either $Y_i < 0$ or $Y_i > 1000$, for all $i$. (No laser's endpoint is on the segment.)\n\n**Test set 1 (10 Pts, Visible)**\n\n- $1 \\leq N \\leq 10$.\n\n**Test set 2 (38 Pts, Hidden)**\n\n- $1 \\leq N \\leq 10000$.\n- There are at most 8 cases with $N > 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 Finals] The Cartesian Job", "background": "", "description": "You may have heard of the platinum-iridium cylinder that serves as the standard for the kilogram, but did you know that there is a special line segment used as the standard for the kilometer? It runs from $(0, 0)$ to $(0, 1000)$ in a 2D plane in a confidential and very flat location.\n\nNaturally, this segment is extremely valuable, so it is protected by $N$ rotating surveillance lasers, which are rays in the 2D plane. Each laser has a fixed endpoint, and it rotates around that endpoint at a constant speed of 1 revolution per second. Whether each laser rotates clockwise or counterclockwise is chosen uniformly and independently at random by the security system.\n\nLasers are not blocked by other lasers or their endpoints, or the segment itself. No laser has an endpoint on the segment.\n\nYou have been hired to audit the security system, but all you have to work with is a single snapshot from an instant in time, which shows the endpoint and orientation (at that instant) of each laser. Since the image is just a snapshot, you have no way of inferring the rotation directions of the lasers.\n\nYou have determined that the segment could be stolen in a heist if there is ever a non-empty open interval of time during which no laser is touching the segment. What is the probability of this happening?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line containing one integer $N$: the number of lasers. Then, $N$ more lines follow. The $i$-th of these lines represents the ray that is the $i$-th laser, and contains four integers $X_i$, $Y_i$, $X_i'$, and $Y_i'$, representing the 2D coordinates of the endpoint of the ray, followed by the 2D coordinates of some other point on the ray.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the probability described above. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, note that multiple lasers might share the same endpoint and initial orientation, but this does not necessarily imply that they rotate in the same direction. (Also note that the second and third lasers have the same initial orientation even though it is specified differently.) Regardless of their rotation directions, though, each of these lasers only touches the segment at the instant that it is pointing in the negative y direction, so there is clearly some other open interval during which no laser is touching the segment, and the answer is 1.\n\nIn Sample Case #2, each of the lasers touches the segment during exactly 1/4 of its rotation, and the segment will be touched by a laser at all times if and only if lasers 1 and 4 rotate in the same direction, and lasers 2 and 3 rotate in the same direction. The probability of that is 1/4, so the answer is 3/4.\n\nSample Case #3 is like Sample Case #2, but with a slight difference that guarantees that there will be an instant at which no laser is touching the segment, even if the lasers are all rotating the same way. So the answer is 1.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $-10^6 \\leq X_i \\leq 10^6$, for all $i$.\n- $-10^6 \\leq Y_i \\leq 10^6$, for all $i$.\n- $-10^6 \\leq X_i' \\leq 10^6$, for all $i$.\n- $-10^6 \\leq Y_i' \\leq 10^6$, for all $i$.\n- $(X_i, Y_i) \\neq (X_i', Y_i')$, for all $i$.\n- If $X_i = 0$, then either $Y_i < 0$ or $Y_i > 1000$, for all $i$. (No laser's endpoint is on the segment.)\n\n**Test set 1 (10 Pts, Visible)**\n\n- $1 \\leq N \\leq 10$.\n\n**Test set 2 (38 Pts, Hidden)**\n\n- $1 \\leq N \\leq 10000$.\n- There are at most 8 cases with $N > 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 Finals] The Cartesian Job", "background": null, "description": "你可能听说过作为千克标准的铂铱圆柱体，但你知道有一条特殊的线段被用作千米的标准吗？它位于二维平面中的 $(0, 0)$ 到 $(0, 1000)$，地点保密且非常平坦。\n\n自然，这条线段极其珍贵，因此由 $N$ 台旋转监控激光器保护。每台激光器在二维平面中是一条射线，拥有一个固定端点，并以每秒 1 圈的速度围绕该端点旋转。每台激光器是顺时针还是逆时针旋转，由安保系统独立且等概率地随机选择。\n\n激光不会被其他激光、端点或线段本身阻挡。没有任何激光的端点在该线段上。\n\n你被雇佣来审计安保系统，但你只能获得某一时刻的快照，快照显示了每台激光器的端点和当时的朝向。由于这只是一个快照，你无法推断激光器的旋转方向。\n\n你已经确定，如果存在某个非空的时间开区间，在此期间没有任何激光器照射到该线段，则该线段有可能被盗。请问这种情况发生的概率是多少？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为一个整数 $N$，表示激光器的数量。接下来的 $N$ 行，每行包含四个整数 $X_i$、$Y_i$、$X_i'$、$Y_i'$，表示第 $i$ 台激光器的端点坐标和射线上另一点的坐标。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是所求概率。$y$ 的绝对误差或相对误差在 $10^{-6}$ 以内均视为正确。", "hint": "**样例解释**\n\n在样例 1 中，注意多台激光器可能有相同的端点和初始朝向，但这并不意味着它们的旋转方向相同。（还要注意，第二台和第三台激光器虽然输入不同，但初始朝向相同。）无论旋转方向如何，每台激光器仅在指向负 $y$ 方向时才能照射到线段，因此显然总有一段时间没有激光器照射到线段，答案为 1。\n\n在样例 2 中，每台激光器在旋转周期的 $1/4$ 时间内照射到线段。只有当第 1 和第 4 台激光器旋转方向相同，且第 2 和第 3 台激光器旋转方向相同时，线段才会始终被激光照射。该概率为 $1/4$，所以答案为 $3/4$。\n\n样例 3 与样例 2 类似，但有细微差别，保证即使所有激光器旋转方向相同，也会有某一时刻没有激光器照射到线段，因此答案为 1。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $-10^6 \\leq X_i \\leq 10^6$，对所有 $i$。\n- $-10^6 \\leq Y_i \\leq 10^6$，对所有 $i$。\n- $-10^6 \\leq X_i' \\leq 10^6$，对所有 $i$。\n- $-10^6 \\leq Y_i' \\leq 10^6$，对所有 $i$。\n- $(X_i, Y_i) \\neq (X_i', Y_i')$，对所有 $i$。\n- 如果 $X_i = 0$，则 $Y_i < 0$ 或 $Y_i > 1000$，对所有 $i$。（没有激光器的端点在该线段上。）\n\n**测试点 1（10 分，公开）**\n\n- $1 \\leq N \\leq 10$。\n\n**测试点 2（38 分，隐藏）**\n\n- $1 \\leq N \\leq 10000$。\n- 其中 $N > 100$ 的测试用例不超过 8 个。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13157", "type": "P", "difficulty": 7, "samples": [["5\n2 2\n1 2\n1\n1 2\n2 1\n1 2\n1\n2 2\n1 1\n1\n2\n1 1\n2\n1\n2 5\n1 1\n2\n3\n2 1\n2 4\n2\n3 5\n3 2\n1 2 3\n3 4\n2 4\n3 4\n2 3 4 5\n2 5\n4 5\n1 2 3 4 5\n4 4\n1 1\n1\n4\n2 3\n2 3\n2 3 4\n1 3\n4\n1 2 4\n1 3\n4\n1 3 4", "Case #1: NO\nCase #2: YES\nCase #3: NO\nCase #4: NO\nCase #5: YES"]], "limits": {"time": [10000, 10000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2018", "Google Code Jam"], "title": "[GCJ 2018 Finals] Swordmaster", "background": "", "description": "You are a duelist aspiring to become the next Swordmaster. You will work toward this title by dueling with opponents until you win against every opponent. Every opponent is always available for dueling, and opponents do not duel each other.\n\nEach duelist (including you) knows at least one attack, and at least one defense. There are at most $P$ pairs of attacks and defenses in the world; the $i$-th defense only counters the $i$-th attack, and the $i$-th attack is only countered by the $i$-th defense. It is possible that there are attacks and/or defenses that no duelist knows. You can use any attack or defense that you know as many times as you like; they do not get \"used up\".\n\nHere are the rules for each individual duel with an opponent:\n\n* As the aspiring Swordmaster, you always get to attack first. You select an attack that you know. If the opponent knows the corresponding defense, they may choose to use it. If they do not know that defense, or they choose not to use it, then they do not defend.\n* Then, the opponent selects an attack that they know. If you know the corresponding defense, you may choose to use it. If you do not know that defense, or you choose not to use it, then you do not defend.\n* If you successfully defended and the opponent did not, you win the duel! Otherwise, you do not win, but your quest to become the Swordmaster can continue.\n\nYou can fight as many duels as you want, including multiple duels with the same opponent, regardless of the outcomes of any previous duels. You do not need to determine a complete schedule of duels in advance; you can base your next decision on what has already happened. Once you have won at least once against every opponent, you become the Swordmaster!\n\nYou are an especially quick learner. After each duel, regardless of the outcome of the duel, you can add the attack and the defense (if any) used by the opponent to your own set of known attacks/defenses. (Note that if an opponent uses an unfamiliar defense against you, you do not learn it during the duel itself, so you cannot use it against the opponent's attack in the same duel.) Only you have this advantage; the attacks and defenses known by your opponents never change.\n\nMoreover, after you win against an opponent, and before your next duel, that opponent will teach you all of the attacks and defenses that they know and that you do not already know. (Once they have lost to you, it looks better for them if you eventually do become the Swordmaster!)\n\nYou know which attacks and defenses each opponent knows. If you make optimal choices, is it possible to guarantee that you will become the Swordmaster, regardless of what choices your opponents make?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow.\n\n* Each case begins with one line with two integers $N$ and $P$: the number of duelists (including you), and the maximum number of attack/defense pairs in the world.\n* Then, there are $N$ groups of three lines each. The $i$-th of these groups represents one of the duelists; in particular, the first of them represents you. Each group has the following structure:\n    1. One line with two integers $Attacks_i$ and $Defenses_i$: the numbers of different attacks and defenses, respectively, known by the $i$-th duelist.\n    2. One line with $Attacks_i$ different integers $A_{ij}$, sorted in increasing order: the identities of the attacks known by the $i$-th duelist.\n    3. One line with $Defenses_i$ different integers $D_{ij}$, sorted in increasing order: the identities of the defenses known by the $i$-th duelist.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `YES` if you can guarantee that you will become the Swordmaster (as described in the problem statement), or `NO` otherwise.", "hint": "**Sample Explanation**\n\nNote that the last four sample cases would not appear in Test set 1.\n\nIn Sample Case #1, as long as your opponent keeps choosing defense 1 and attack 1, you cannot win the duel. There is no guarantee that your opponent will ever choose attack 2 or choose not to use defense 1, so it is not possible to guarantee that you will become the Swordmaster.\n\nIn Sample Case #2, you know attack 1 and defense 2, and your (only) opponent knows attack 2 and defense 1. The following strategy is guaranteed to make you the Swordmaster:\n\n* In your first duel, you must choose attack 1; the opponent may defend with defense 1. Then, the opponent must choose attack 2; you should choose defense 2.\n    * If the opponent did not defend, then you won and you are now the Swordmaster.\n    * Otherwise, you do not win, but you learn attack 2 and defense 1 afterward. Then, start a second duel with that opponent. This time, choose attack 2; the opponent cannot defend against it. Once again, the opponent must choose attack 2; you should choose defense 2. You have won and you are now the Swordmaster.\n\nIn Sample Case #3, in your first duel, if your opponent always chooses attack 4, you will never be able to defend, since nobody knows the defense to that attack. So, there is no way for you to ever become the swordmaster. Note that there can be attacks and/or defenses that exist in the world, but are not known by any of the duelists in this problem.\n\nIn Sample Case #4, there is an opponent that knows every defense, so you cannot guarantee that you will ever win against them (they would have to be nice and not defend!)\n\nHere is one guaranteed winning strategy for Sample Case #5:\n\n1. Duel the first opponent. You must choose attack 1, and they cannot defend. We will proceed assuming that they choose attack 2. (If they choose attack 3, an isomorphic strategy will work.) You cannot defend, and you do not win the duel, but you learn attack 2.\n2. Duel the third opponent, and use attack 2 and defense 4 for a guaranteed win. You learn attack 4 (which you will never use) and defenses 1 and 3.\n3. Duel the second opponent, and use attack 2. You are guaranteed to learn defense 2: either the opponent will use it against you, or they will not use it and you will win (and learn all of their attacks and defenses).\n4. Duel the first opponent again, and choose attack 1. Now, whichever attack they use, you can defend, and you win. You learn attack 3.\n5. Duel the second opponent again, using attack 3, if you did not already win against them before.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq 1000$.\n- $1 \\leq P \\leq 1000$.\n- $1 \\leq Attacks_i \\leq P$, for all $i$.\n- $1 \\leq Defenses_i \\leq P$, for all $i$.\n- $1 \\leq A_{ij} < A_{i(j+1)} \\leq P$, for all $i$ and $j$.\n- $1 \\leq D_{ij} < D_{i(j+1)} \\leq P$, for all $i$ and $j$.\n- The sum of all $Attacks_i$ + the sum of all $Defenses_i$, over all $i$, does not exceed $50000$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $A_{i1} = 1$, for all $i$. (Attack 1 is known by all the duelists, including you.)\n- $D_{i1} = 1$, for all $i$. (Defense 1 is known by all the duelists, including you.)\n\n**Test set 2 (38 Pts, Hidden)**\n\n- No extra restrictions.", "locale": "en", "translations": {"en": {"title": "[GCJ 2018 Finals] Swordmaster", "background": "", "description": "You are a duelist aspiring to become the next Swordmaster. You will work toward this title by dueling with opponents until you win against every opponent. Every opponent is always available for dueling, and opponents do not duel each other.\n\nEach duelist (including you) knows at least one attack, and at least one defense. There are at most $P$ pairs of attacks and defenses in the world; the $i$-th defense only counters the $i$-th attack, and the $i$-th attack is only countered by the $i$-th defense. It is possible that there are attacks and/or defenses that no duelist knows. You can use any attack or defense that you know as many times as you like; they do not get \"used up\".\n\nHere are the rules for each individual duel with an opponent:\n\n* As the aspiring Swordmaster, you always get to attack first. You select an attack that you know. If the opponent knows the corresponding defense, they may choose to use it. If they do not know that defense, or they choose not to use it, then they do not defend.\n* Then, the opponent selects an attack that they know. If you know the corresponding defense, you may choose to use it. If you do not know that defense, or you choose not to use it, then you do not defend.\n* If you successfully defended and the opponent did not, you win the duel! Otherwise, you do not win, but your quest to become the Swordmaster can continue.\n\nYou can fight as many duels as you want, including multiple duels with the same opponent, regardless of the outcomes of any previous duels. You do not need to determine a complete schedule of duels in advance; you can base your next decision on what has already happened. Once you have won at least once against every opponent, you become the Swordmaster!\n\nYou are an especially quick learner. After each duel, regardless of the outcome of the duel, you can add the attack and the defense (if any) used by the opponent to your own set of known attacks/defenses. (Note that if an opponent uses an unfamiliar defense against you, you do not learn it during the duel itself, so you cannot use it against the opponent's attack in the same duel.) Only you have this advantage; the attacks and defenses known by your opponents never change.\n\nMoreover, after you win against an opponent, and before your next duel, that opponent will teach you all of the attacks and defenses that they know and that you do not already know. (Once they have lost to you, it looks better for them if you eventually do become the Swordmaster!)\n\nYou know which attacks and defenses each opponent knows. If you make optimal choices, is it possible to guarantee that you will become the Swordmaster, regardless of what choices your opponents make?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow.\n\n* Each case begins with one line with two integers $N$ and $P$: the number of duelists (including you), and the maximum number of attack/defense pairs in the world.\n* Then, there are $N$ groups of three lines each. The $i$-th of these groups represents one of the duelists; in particular, the first of them represents you. Each group has the following structure:\n    1. One line with two integers $Attacks_i$ and $Defenses_i$: the numbers of different attacks and defenses, respectively, known by the $i$-th duelist.\n    2. One line with $Attacks_i$ different integers $A_{ij}$, sorted in increasing order: the identities of the attacks known by the $i$-th duelist.\n    3. One line with $Defenses_i$ different integers $D_{ij}$, sorted in increasing order: the identities of the defenses known by the $i$-th duelist.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `YES` if you can guarantee that you will become the Swordmaster (as described in the problem statement), or `NO` otherwise.", "hint": "**Sample Explanation**\n\nNote that the last four sample cases would not appear in Test set 1.\n\nIn Sample Case #1, as long as your opponent keeps choosing defense 1 and attack 1, you cannot win the duel. There is no guarantee that your opponent will ever choose attack 2 or choose not to use defense 1, so it is not possible to guarantee that you will become the Swordmaster.\n\nIn Sample Case #2, you know attack 1 and defense 2, and your (only) opponent knows attack 2 and defense 1. The following strategy is guaranteed to make you the Swordmaster:\n\n* In your first duel, you must choose attack 1; the opponent may defend with defense 1. Then, the opponent must choose attack 2; you should choose defense 2.\n    * If the opponent did not defend, then you won and you are now the Swordmaster.\n    * Otherwise, you do not win, but you learn attack 2 and defense 1 afterward. Then, start a second duel with that opponent. This time, choose attack 2; the opponent cannot defend against it. Once again, the opponent must choose attack 2; you should choose defense 2. You have won and you are now the Swordmaster.\n\nIn Sample Case #3, in your first duel, if your opponent always chooses attack 4, you will never be able to defend, since nobody knows the defense to that attack. So, there is no way for you to ever become the swordmaster. Note that there can be attacks and/or defenses that exist in the world, but are not known by any of the duelists in this problem.\n\nIn Sample Case #4, there is an opponent that knows every defense, so you cannot guarantee that you will ever win against them (they would have to be nice and not defend!)\n\nHere is one guaranteed winning strategy for Sample Case #5:\n\n1. Duel the first opponent. You must choose attack 1, and they cannot defend. We will proceed assuming that they choose attack 2. (If they choose attack 3, an isomorphic strategy will work.) You cannot defend, and you do not win the duel, but you learn attack 2.\n2. Duel the third opponent, and use attack 2 and defense 4 for a guaranteed win. You learn attack 4 (which you will never use) and defenses 1 and 3.\n3. Duel the second opponent, and use attack 2. You are guaranteed to learn defense 2: either the opponent will use it against you, or they will not use it and you will win (and learn all of their attacks and defenses).\n4. Duel the first opponent again, and choose attack 1. Now, whichever attack they use, you can defend, and you win. You learn attack 3.\n5. Duel the second opponent again, using attack 3, if you did not already win against them before.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq 1000$.\n- $1 \\leq P \\leq 1000$.\n- $1 \\leq Attacks_i \\leq P$, for all $i$.\n- $1 \\leq Defenses_i \\leq P$, for all $i$.\n- $1 \\leq A_{ij} < A_{i(j+1)} \\leq P$, for all $i$ and $j$.\n- $1 \\leq D_{ij} < D_{i(j+1)} \\leq P$, for all $i$ and $j$.\n- The sum of all $Attacks_i$ + the sum of all $Defenses_i$, over all $i$, does not exceed $50000$.\n\n**Test set 1 (10 Pts, Visible)**\n\n- $A_{i1} = 1$, for all $i$. (Attack 1 is known by all the duelists, including you.)\n- $D_{i1} = 1$, for all $i$. (Defense 1 is known by all the duelists, including you.)\n\n**Test set 2 (38 Pts, Hidden)**\n\n- No extra restrictions.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2018 Finals] Swordmaster", "background": null, "description": "你是一名决斗者，渴望成为下一任剑术大师。你需要通过与对手决斗，直到你战胜了每一位对手。每个对手始终可以与你决斗，且对手之间不会互相决斗。\n\n每位决斗者（包括你自己）至少掌握一种攻击和一种防御。世界上最多存在 $P$ 对攻击与防御，每一对中的第 $i$ 种防御只能克制第 $i$ 种攻击，第 $i$ 种攻击也只会被第 $i$ 种防御克制。可能存在某些攻击或防御没有任何决斗者掌握。你可以无限次使用自己掌握的任意攻击或防御，它们不会“用完”。\n\n每场与对手的单独决斗规则如下：\n\n- 作为剑术大师的候选人，你总是先攻击。你选择自己会的一种攻击。如果对手会相应的防御，则可以选择使用该防御。如果对手不会该防御，或者选择不使用，则无法防御。\n- 然后，对手选择自己会的一种攻击。如果你会相应的防御，则可以选择使用该防御。如果你不会该防御，或者选择不使用，则无法防御。\n- 如果你成功防御了对手的攻击，而对手没有防御你的攻击，则你赢得这场决斗！否则，你未能获胜，但你追求剑术大师之路可以继续。\n\n你可以进行任意多场决斗，包括与同一对手多次决斗，无论之前的结果如何。你不需要提前安排所有决斗的顺序，可以根据之前的结果决定下一步。只要你至少战胜过每一位对手一次，你就成为了剑术大师！\n\n你有极强的学习能力。每场决斗结束后，无论胜负，你都可以将对手在该场决斗中使用的攻击和防御（如果有）加入到你自己的已知攻击/防御集合中。（注意，如果对手在对你攻击时使用了你不熟悉的防御，你在本场决斗中无法学会，因此不能在本场对对手的攻击使用该防御。）只有你拥有这个优势；对手们掌握的攻击和防御永远不会变化。\n\n此外，在你战胜某位对手后，在下一场决斗之前，该对手会将他们所掌握而你尚未掌握的所有攻击和防御全部教给你。（他们输给你后，希望你最终能成为剑术大师，这样对他们更有面子！）\n\n你知道每位对手掌握哪些攻击和防御。如果你做出最优选择，是否可以保证最终成为剑术大师，无论对手如何选择？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。\n\n每组数据开头一行包含两个整数 $N$ 和 $P$，分别表示决斗者（包括你自己）的数量，以及世界上最多存在的攻击/防御对数。\n\n接下来有 $N$ 组，每组包含三行，描述每位决斗者（第一个为你自己）：\n\n1. 一行包含两个整数 $Attacks_i$ 和 $Defenses_i$，分别表示第 $i$ 位决斗者已知的攻击数和防御数。\n2. 一行包含 $Attacks_i$ 个不同的递增整数 $A_{ij}$，表示第 $i$ 位决斗者已知的攻击编号。\n3. 一行包含 $Defenses_i$ 个不同的递增整数 $D_{ij}$，表示第 $i$ 位决斗者已知的防御编号。", "outputFormat": "对于每个测试用例，输出一行 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为 `YES` 或 `NO`，表示你是否可以保证最终成为剑术大师。", "hint": "**样例解释**\n\n注意，最后四个样例不会出现在测试集 1 中。\n\n样例 1 中，只要你的对手一直选择防御 1 并使用攻击 1，你就无法获胜。无法保证对手会选择攻击 2 或不使用防御 1，因此无法保证你能成为剑术大师。\n\n样例 2 中，你会攻击 1 和防御 2，唯一的对手会攻击 2 和防御 1。你可以采用如下策略保证获胜：\n\n- 首先，你必须选择攻击 1；对手可能用防御 1 防御。然后，对手只能选择攻击 2，你应选择防御 2。\n    - 如果对手没有防御，你获胜，成为剑术大师。\n    - 否则，你未能获胜，但你学会了攻击 2 和防御 1。然后再次与该对手决斗，这次你选择攻击 2，对手无法防御。对手仍然只能选择攻击 2，你用防御 2。你获胜，成为剑术大师。\n\n样例 3 中，若对手始终选择攻击 4，你永远无法防御，因为没人会防御 4。因此你无法成为剑术大师。注意，可能存在世界上有攻击或防御，但无人掌握。\n\n样例 4 中，有一位对手掌握所有防御，因此你无法保证战胜他（除非他“好心”不防御）。\n\n样例 5 的一种必胜策略如下：\n\n1. 与第一个对手决斗。你只能选择攻击 1，对方无法防御。假设对方选择攻击 2（如果选择攻击 3，也有类似策略）。你无法防御，未能获胜，但你学会了攻击 2。\n2. 与第三个对手决斗，使用攻击 2 和防御 4，必胜。你学会攻击 4（虽然不会用到）和防御 1、3。\n3. 与第二个对手决斗，使用攻击 2。你一定能学会防御 2：要么对手用它防御你，要么不用你直接获胜（并学会他所有攻击和防御）。\n4. 再次与第一个对手决斗，选择攻击 1。此时无论对方用哪种攻击，你都能防御，获胜。你学会攻击 3。\n5. 如之前未战胜第二个对手，再次与其决斗，使用攻击 3。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq N \\leq 1000$。\n- $1 \\leq P \\leq 1000$。\n- $1 \\leq Attacks_i \\leq P$，对所有 $i$。\n- $1 \\leq Defenses_i \\leq P$，对所有 $i$。\n- $1 \\leq A_{ij} < A_{i(j+1)} \\leq P$，对所有 $i$ 和 $j$。\n- $1 \\leq D_{ij} < D_{i(j+1)} \\leq P$，对所有 $i$ 和 $j$。\n- 所有 $Attacks_i$ 与 $Defenses_i$ 之和不超过 $50000$。\n\n**测试集 1（10 分，可见）**\n\n- 对所有 $i$，$A_{i1} = 1$。（所有决斗者都知道攻击 1，包括你。）\n- 对所有 $i$，$D_{i1} = 1$。（所有决斗者都知道防御 1，包括你。）\n\n**测试集 2（38 分，隐藏）**\n\n- 无额外限制。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13158", "type": "P", "difficulty": 3, "samples": [["3\n---+-++- 3\n+++++ 4\n-+-+- 4", "Case #1: 3\nCase #2: 0\nCase #3: IMPOSSIBLE"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2017", "Google Code Jam"], "title": "[GCJ 2017 Qualification] Oversized Pancake Flipper", "background": "", "description": "Last year, the Infinite House of Pancakes introduced a new kind of pancake. It has a happy face made of chocolate chips on one side (the \"happy side\"), and nothing on the other side (the \"blank side\").\n\nYou are the head cook on duty. The pancakes are cooked in a single row over a hot surface. As part of its infinite efforts to maximize efficiency, the House has recently given you an oversized pancake flipper that flips exactly $K$ consecutive pancakes. That is, in that range of $K$ pancakes, it changes every happy-side pancake to a blank-side pancake, and vice versa; it does not change the left-to-right order of those pancakes.\n\nYou cannot flip fewer than $K$ pancakes at a time with the flipper, even at the ends of the row (since there are raised borders on both sides of the cooking surface). For example, you can flip the first $K$ pancakes, but not the first $K - 1$ pancakes.\n\nYour apprentice cook, who is still learning the job, just used the old-fashioned single-pancake flipper to flip some individual pancakes and then ran to the restroom with it, right before the time when customers come to visit the kitchen. You only have the oversized pancake flipper left, and you need to use it quickly to leave all the cooking pancakes happy side up, so that the customers leave feeling happy with their visit.\n\nGiven the current state of the pancakes, calculate the minimum number of uses of the oversized pancake flipper needed to leave all pancakes happy side up, or state that there is no way to do it.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line with a string $S$ and an integer $K$. $S$ represents the row of pancakes: each of its characters is either + (which represents a pancake that is initially happy side up) or - (which represents a pancake that is initially blank side up).\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either `IMPOSSIBLE` if there is no way to get all the pancakes happy side up, or an integer representing the the minimum number of times you will need to use the oversized pancake flipper to do it.", "hint": "**Sample Explanation**\n\n- In Case #1, you can get all the pancakes happy side up by first flipping the leftmost 3 pancakes, getting to ++++-++-, then the rightmost 3, getting to ++++---+, and finally the 3 pancakes that remain blank side up. There are other ways to do it with 3 flips or more, but none with fewer than 3 flips.\n\n- In Case #2, all of the pancakes are already happy side up, so there is no need to flip any of them.\n\n- In Case #3, there is no way to make the second and third pancakes from the left have the same side up, because any flip flips them both. Therefore, there is no way to make all of the pancakes happy side up.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- Every character in $S$ is either + or -.\n- $2 \\leq K \\leq$ length of $S$.\n\n**Small dataset (5 Pts, Test Set 1 - Visible)**\n\n- $2 \\leq$ length of $S \\leq 10$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leq$ length of $S \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 Qualification] Oversized Pancake Flipper", "background": "", "description": "Last year, the Infinite House of Pancakes introduced a new kind of pancake. It has a happy face made of chocolate chips on one side (the \"happy side\"), and nothing on the other side (the \"blank side\").\n\nYou are the head cook on duty. The pancakes are cooked in a single row over a hot surface. As part of its infinite efforts to maximize efficiency, the House has recently given you an oversized pancake flipper that flips exactly $K$ consecutive pancakes. That is, in that range of $K$ pancakes, it changes every happy-side pancake to a blank-side pancake, and vice versa; it does not change the left-to-right order of those pancakes.\n\nYou cannot flip fewer than $K$ pancakes at a time with the flipper, even at the ends of the row (since there are raised borders on both sides of the cooking surface). For example, you can flip the first $K$ pancakes, but not the first $K - 1$ pancakes.\n\nYour apprentice cook, who is still learning the job, just used the old-fashioned single-pancake flipper to flip some individual pancakes and then ran to the restroom with it, right before the time when customers come to visit the kitchen. You only have the oversized pancake flipper left, and you need to use it quickly to leave all the cooking pancakes happy side up, so that the customers leave feeling happy with their visit.\n\nGiven the current state of the pancakes, calculate the minimum number of uses of the oversized pancake flipper needed to leave all pancakes happy side up, or state that there is no way to do it.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line with a string $S$ and an integer $K$. $S$ represents the row of pancakes: each of its characters is either + (which represents a pancake that is initially happy side up) or - (which represents a pancake that is initially blank side up).\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either `IMPOSSIBLE` if there is no way to get all the pancakes happy side up, or an integer representing the the minimum number of times you will need to use the oversized pancake flipper to do it.", "hint": "**Sample Explanation**\n\n- In Case #1, you can get all the pancakes happy side up by first flipping the leftmost 3 pancakes, getting to ++++-++-, then the rightmost 3, getting to ++++---+, and finally the 3 pancakes that remain blank side up. There are other ways to do it with 3 flips or more, but none with fewer than 3 flips.\n\n- In Case #2, all of the pancakes are already happy side up, so there is no need to flip any of them.\n\n- In Case #3, there is no way to make the second and third pancakes from the left have the same side up, because any flip flips them both. Therefore, there is no way to make all of the pancakes happy side up.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- Every character in $S$ is either + or -.\n- $2 \\leq K \\leq$ length of $S$.\n\n**Small dataset (5 Pts, Test Set 1 - Visible)**\n\n- $2 \\leq$ length of $S \\leq 10$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leq$ length of $S \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 Qualification] Oversized Pancake Flipper", "background": null, "description": "去年，Infinite House of Pancakes 推出了一种新型煎饼。这种煎饼的一面（“开心面”）上有用巧克力豆做成的笑脸，另一面（“空白面”）则什么都没有。\n\n你是当班的主厨。煎饼被排成一排在加热面上烹饪。为了进一步提升效率，餐厅最近给你配备了一个超大号煎饼翻转器，每次可以同时翻转恰好 $K$ 个连续的煎饼。也就是说，在这 $K$ 个煎饼的范围内，每个开心面朝上的煎饼会变为空白面朝上，反之亦然；煎饼的左右顺序不会改变。\n\n你不能用翻转器翻转少于 $K$ 个煎饼，即使是在煎饼排的两端（因为加热面两侧有凸起的边界）。例如，你可以翻转最左边的 $K$ 个煎饼，但不能只翻转最左边的 $K-1$ 个煎饼。\n\n你的学徒厨师还在学习工作，他刚刚用老式的单煎饼翻转器翻转了一些单独的煎饼，然后带着翻转器跑去洗手间了，正好在顾客即将参观厨房之前。现在你只剩下超大号煎饼翻转器，你需要尽快使用它，使所有正在烹饪的煎饼都开心面朝上，这样顾客才能满意地离开。\n\n给定当前煎饼的状态，计算至少需要使用多少次超大号煎饼翻转器，才能让所有煎饼都开心面朝上；或者说明无法做到这一点。", "inputFormat": "输入的第一行包含测试用例的数量 $T$。接下来有 $T$ 组测试用例。每组测试用例包含一行，包括一个字符串 $S$ 和一个整数 $K$。$S$ 表示煎饼的排列：每个字符为 +（表示该煎饼初始为开心面朝上）或 -（表示该煎饼初始为空白面朝上）。", "outputFormat": "对于每组测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是所需使用超大号煎饼翻转器的最小次数，或者如果无法做到则输出 `IMPOSSIBLE`。", "hint": "**样例解释**\n\n- 对于第 1 组测试用例，你可以先翻转最左边的 3 个煎饼，变为 ++++-++-，然后翻转最右边的 3 个，变为 ++++---+，最后再翻转剩下的 3 个空白面朝上的煎饼。还有其他方法可以用 3 次或更多次翻转完成，但没有比 3 次更少的方案。\n\n- 对于第 2 组测试用例，所有煎饼已经全部开心面朝上，因此不需要翻转。\n\n- 对于第 3 组测试用例，无法让从左数第 2 和第 3 个煎饼都朝同一面，因为任何一次翻转都会同时翻转它们。因此无法让所有煎饼都开心面朝上。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $S$ 中每个字符均为 + 或 -。\n- $2 \\leq K \\leq S$ 的长度。\n\n**小数据集（5 分，测试集 1 - 可见）**\n\n- $2 \\leq S$ 的长度 $\\leq 10$。\n\n**大数据集（10 分，测试集 2 - 隐藏）**\n\n- $2 \\leq S$ 的长度 $\\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13159", "type": "P", "difficulty": 3, "samples": [["4\n132\n1000\n7\n111111111111111110", "Case #1: 129\nCase #2: 999\nCase #3: 7\nCase #4: 99999999999999999"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "贪心", "2017", "二分", "Google Code Jam"], "title": "[GCJ 2017 Qualification] Tidy Numbers", "background": "", "description": "Tatiana likes to keep things tidy. Her toys are sorted from smallest to largest, her pencils are sorted from shortest to longest and her computers from oldest to newest. One day, when practicing her counting skills, she noticed that some integers, when written in base 10 with no leading zeroes, have their digits sorted in non-decreasing order. Some examples of this are 8, 123, 555, and 224488. She decided to call these numbers $tidy$. Numbers that do not have this property, like 20, 321, 495 and 999990, are not tidy.\n\nShe just finished counting all positive integers in ascending order from 1 to $N$. What was the last tidy number she counted?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each line describes a test case with a single integer $N$, the last number counted by Tatiana.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the last tidy number counted by Tatiana.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in the Small dataset.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Small dataset (5 Pts, Test Set 1 - Visible)**\n\n- $1 \\leq N \\leq 1000$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq N \\leq 10^{18}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 Qualification] Tidy Numbers", "background": "", "description": "Tatiana likes to keep things tidy. Her toys are sorted from smallest to largest, her pencils are sorted from shortest to longest and her computers from oldest to newest. One day, when practicing her counting skills, she noticed that some integers, when written in base 10 with no leading zeroes, have their digits sorted in non-decreasing order. Some examples of this are 8, 123, 555, and 224488. She decided to call these numbers $tidy$. Numbers that do not have this property, like 20, 321, 495 and 999990, are not tidy.\n\nShe just finished counting all positive integers in ascending order from 1 to $N$. What was the last tidy number she counted?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each line describes a test case with a single integer $N$, the last number counted by Tatiana.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the last tidy number counted by Tatiana.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in the Small dataset.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n\n**Small dataset (5 Pts, Test Set 1 - Visible)**\n\n- $1 \\leq N \\leq 1000$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq N \\leq 10^{18}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 Qualification] Tidy Numbers", "background": null, "description": "Tatiana 喜欢保持整洁。她的玩具按照从小到大的顺序排列，她的铅笔按照从短到长的顺序排列，她的电脑按照从旧到新的顺序排列。一天，在练习数数的时候，她注意到有些整数在十进制下书写且没有前导零时，其各位数字是非递减排列的。例如 8、123、555 和 224488 就是这样的数。她决定把这些数称为“tidy”数。不满足这个性质的数，比如 20、321、495 和 999990，就不是 tidy 数。\n\n她刚刚从 1 开始按升序数到了 $N$。她数到的最后一个 tidy 数是多少？", "inputFormat": "输入的第一行包含一个整数 $T$，表示测试用例的数量。接下来的 $T$ 行，每行包含一个整数 $N$，表示 Tatiana 数到的最后一个数。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 Tatiana 数到的最后一个 tidy 数。", "hint": "**样例解释**\n\n注意，最后一个样例不会出现在 Small 数据集里。\n\n**限制条件**\n\n- $1 \\leq T \\leq 100$。\n\n**Small 数据集（5 分，测试集 1 - 可见）**\n\n- $1 \\leq N \\leq 1000$。\n\n**Large 数据集（10 分，测试集 2 - 隐藏）**\n\n- $1 \\leq N \\leq 10^{18}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13160", "type": "P", "difficulty": 4, "samples": [["5\n4 2\n5 2\n6 2\n1000 1000\n1000 1", "Case #1: 1 0\nCase #2: 1 0\nCase #3: 1 1\nCase #4: 0 0\nCase #5: 500 499"]], "limits": {"time": [15000, 15000, 15000], "memory": [1048576, 1048576, 1048576]}, "tags": ["数学", "2017", "Google Code Jam"], "title": "[GCJ 2017 Qualification] Bathroom Stalls", "background": "", "description": "A certain bathroom has $N + 2$ stalls in a single row; the stalls on the left and right ends are permanently occupied by the bathroom guards. The other $N$ stalls are for users.\n\nWhenever someone enters the bathroom, they try to choose a stall that is as far from other people as possible. To avoid confusion, they follow deterministic rules: For each empty stall $S$, they compute two values $L_S$ and $R_S$, each of which is the number of empty stalls between $S$ and the closest occupied stall to the left or right, respectively. Then they consider the set of stalls with the farthest closest neighbor, that is, those $S$ for which $\\min(L_S, R_S)$ is maximal. If there is only one such stall, they choose it; otherwise, they choose the one among those where $\\max(L_S, R_S)$ is maximal. If there are still multiple tied stalls, they choose the leftmost stall among those.\n\n$K$ people are about to enter the bathroom; each one will choose their stall before the next arrives. Nobody will ever leave.\n\nWhen the last person chooses their stall $S$, what will the values of $\\max(L_S, R_S)$ and $\\min(L_S, R_S)$ be?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each line describes a test case with two integers $N$ and $K$, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), $y$ is $\\max(L_S, R_S)$, and $z$ is $\\min(L_S, R_S)$ as calculated by the last person to enter the bathroom for their chosen stall $S$.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the first person occupies the leftmost of the middle two stalls, leaving the following configuration (O stands for an occupied stall and . for an empty one): `O.O..O`. Then, the second and last person occupies the stall immediately to the right, leaving 1 empty stall on one side and none on the other.\n\nIn Sample Case #2, the first person occupies the middle stall, getting to `O..O..O`. Then, the second and last person occupies the leftmost stall.\n\nIn Sample Case #3, the first person occupies the leftmost of the two middle stalls, leaving `O..O...O`. The second person then occupies the middle of the three consecutive empty stalls.\n\nIn Sample Case #4, every stall is occupied at the end, no matter what the stall choices are.\n\nIn Sample Case #5, the first and only person chooses the leftmost middle stall.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq K \\leq N$.\n\n**Small Dataset 1 (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 1000$.\n\n**Small Dataset 2 (10 Pts, Test set 2 - Visible)**\n\n- $1 \\leq N \\leq 10^{6}$.\n\n**Large Dataset (15 Pts, Test set 3 - Hidden)**\n\n- $1 \\leq N \\leq 10^{18}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 Qualification] Bathroom Stalls", "background": "", "description": "A certain bathroom has $N + 2$ stalls in a single row; the stalls on the left and right ends are permanently occupied by the bathroom guards. The other $N$ stalls are for users.\n\nWhenever someone enters the bathroom, they try to choose a stall that is as far from other people as possible. To avoid confusion, they follow deterministic rules: For each empty stall $S$, they compute two values $L_S$ and $R_S$, each of which is the number of empty stalls between $S$ and the closest occupied stall to the left or right, respectively. Then they consider the set of stalls with the farthest closest neighbor, that is, those $S$ for which $\\min(L_S, R_S)$ is maximal. If there is only one such stall, they choose it; otherwise, they choose the one among those where $\\max(L_S, R_S)$ is maximal. If there are still multiple tied stalls, they choose the leftmost stall among those.\n\n$K$ people are about to enter the bathroom; each one will choose their stall before the next arrives. Nobody will ever leave.\n\nWhen the last person chooses their stall $S$, what will the values of $\\max(L_S, R_S)$ and $\\min(L_S, R_S)$ be?\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ lines follow. Each line describes a test case with two integers $N$ and $K$, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), $y$ is $\\max(L_S, R_S)$, and $z$ is $\\min(L_S, R_S)$ as calculated by the last person to enter the bathroom for their chosen stall $S$.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, the first person occupies the leftmost of the middle two stalls, leaving the following configuration (O stands for an occupied stall and . for an empty one): `O.O..O`. Then, the second and last person occupies the stall immediately to the right, leaving 1 empty stall on one side and none on the other.\n\nIn Sample Case #2, the first person occupies the middle stall, getting to `O..O..O`. Then, the second and last person occupies the leftmost stall.\n\nIn Sample Case #3, the first person occupies the leftmost of the two middle stalls, leaving `O..O...O`. The second person then occupies the middle of the three consecutive empty stalls.\n\nIn Sample Case #4, every stall is occupied at the end, no matter what the stall choices are.\n\nIn Sample Case #5, the first and only person chooses the leftmost middle stall.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq K \\leq N$.\n\n**Small Dataset 1 (5 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 1000$.\n\n**Small Dataset 2 (10 Pts, Test set 2 - Visible)**\n\n- $1 \\leq N \\leq 10^{6}$.\n\n**Large Dataset (15 Pts, Test set 3 - Hidden)**\n\n- $1 \\leq N \\leq 10^{18}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 Qualification] Bathroom Stalls", "background": null, "description": "某间洗手间有 $N + 2$ 个隔间排成一排，最左端和最右端的隔间被洗手间管理员永久占用。其余 $N$ 个隔间供用户使用。\n\n每当有人进入洗手间时，他们会尽量选择距离其他人最远的隔间。为避免混淆，他们遵循如下确定性规则：对于每一个空隔间 $S$，计算两个值 $L_S$ 和 $R_S$，分别表示 $S$ 到其左侧最近被占用隔间之间的空隔间数，以及到其右侧最近被占用隔间之间的空隔间数。然后，他们会考虑那些最近邻距离最远的隔间，即使得 $\\min(L_S, R_S)$ 最大的所有 $S$。如果只有一个这样的隔间，则选择它；否则，在这些隔间中选择 $\\max(L_S, R_S)$ 最大的那个。如果仍有多个隔间并列，则选择这些隔间中最靠左的一个。\n\n有 $K$ 个人即将依次进入洗手间；每个人都会在下一个人到来前选择好自己的隔间。没有人会离开。\n\n当最后一个人选择隔间 $S$ 时，对于他所选隔间，$\\max(L_S, R_S)$ 和 $\\min(L_S, R_S)$ 的值分别是多少？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来的 $T$ 行，每行描述一个测试用例，包含两个整数 $N$ 和 $K$，含义如上所述。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y z`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为最后一个人选择的隔间 $S$ 的 $\\max(L_S, R_S)$，$z$ 为 $\\min(L_S, R_S)$。", "hint": "**样例解释**\n\n在样例 1 中，第一个人占据了中间两个隔间中最左边的一个，剩下的状态为（O 表示已占用，. 表示空）：`O.O..O`。然后，第二个人（也是最后一个人）占据了紧挨着右侧的隔间，此时一侧有 1 个空隔间，另一侧没有空隔间。\n\n在样例 2 中，第一个人占据了中间的隔间，状态变为 `O..O..O`。然后，第二个人占据了最左边的隔间。\n\n在样例 3 中，第一个人占据了两个中间隔间中最左边的一个，状态为 `O..O...O`。第二个人随后占据了连续三个空隔间中间的那个。\n\n在样例 4 中，最后所有隔间都被占满，无论选择顺序如何。\n\n在样例 5 中，唯一一个人选择了最左边的中间隔间。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq K \\leq N$。\n\n**小数据集 1（5 分，测试点 1 - 可见）**\n\n- $1 \\leq N \\leq 1000$。\n\n**小数据集 2（10 分，测试点 2 - 可见）**\n\n- $1 \\leq N \\leq 10^{6}$。\n\n**大数据集（15 分，测试点 3 - 隐藏）**\n\n- $1 \\leq N \\leq 10^{18}$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13161", "type": "P", "difficulty": 6, "samples": [["3\n2 0\n1 1\no 1 1\n3 4\n+ 2 3\n+ 2 1\nx 3 1\n+ 2 2", "Case #1: 4 3\no 2 2\n+ 2 1\nx 1 1\nCase #2: 2 0\nCase #3: 6 2\no 2 3\nx 1 2"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2017", "Special Judge", "Google Code Jam"], "title": "[GCJ 2017 Qualification] Fashion Show", "background": "", "description": "You are about to host a fashion show to show off three new styles of clothing. The show will be held on a stage which is in the most fashionable of all shapes: an $N$-by-$N$ grid of cells.\n\nEach cell in the grid can be empty (which we represent with a `.` character) or can contain one fashion model. The models come in three types, depending on the clothing style they are wearing: `+`, `x`, and the super-trendy `o`. A cell with a `+` or `x` model in it adds 1 style point to the show. A cell with an `o` model in it adds 2 style points. Empty cells add no style points.\n\nTo achieve the maximum artistic effect, there are rules on how models can be placed relative to each other.\n\n* Whenever any two models share a row or column, at least one of the two must be a `+`.\n* Whenever any two models share a diagonal of the grid, at least one of the two must be an `x`.\n\nFormally, a model located in row $i_0$ and column $j_0$ and a model located in row $i_1$ and column $j_1$ share a row if and only if $i_0 = i_1$, they share a column if and only if $j_0 = j_1$, and they share a diagonal if and only if $i_0 + j_0 = i_1 + j_1$ or $i_0 - j_0 = i_1 - j_1$.\n\nFor example, the following grid is not legal:\n\n```\n...\nx+o\n.+.\n```\n\nThe middle row has a pair of models (`x` and `o`) that does not include a `+`. The diagonal starting at the `+` in the bottom row and running up to the `o` in the middle row has two models, and neither of them is an `x`.\n\nHowever, the following grid is legal. No row, column, or diagonal violates the rules.\n\n```\n+.x\n+x+\no..\n```\n\nYour artistic advisor has already placed $M$ models in certain cells, following these rules. You are free to place any number (including zero) of additional models of whichever types you like. You may not remove existing models, but you may upgrade as many existing `+` and `x` models into o models as you wish, as long as the above rules are not violated.\n\nYour task is to find a legal way of placing and/or upgrading models that earns the maximum possible number of style points.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with one line with two integers $N$ and $M$, as described above. Then, $M$ more lines follow; the $i$-th of these lines has a `+`, `x`, or `o` character (the type of the model) and two integers $R_i$ and $C_i$ (the position of the model). The rows of the grid are numbered 1 through $N$, from top to bottom. The columns of the grid are numbered 1 through $N$, from left to right.\n", "outputFormat": "For each test case, first output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), $y$ is the number of style points earned in your arrangement, and $z$ is the total number of models you have added and/or substituted in. Then, for each model that you have added or substituted in, output exactly one line in exactly the same format described in the Input section, where the character is the type of the model that you have added or substituted in. These $z$ lines can be in any order.\n\nIf there are multiple valid answers, you may output any one of them.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible. Note that the last sample case would not appear in the Small dataset.\n\nIn sample case #1, the grid is 2-by-2 and is initially blank. The output corresponds to the following grid. (In these explanations, we will use . to denote a blank cell.)\n```\nx.\n+o\n```\nIn sample case #2, the only cell is already occupied by an o model, and it is impossible to add a new model or replace the o model.\n\nIn sample case #3, the grid looks like this before you place any models:\n```\n...\n+++\nx..\n```\nThe output corresponds to this grid:\n```\n.x.\n++o\nx..\n```\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 100$.\n- $1 \\leq C_i \\leq N$, for all $i$.\n- $0 \\leq M \\leq N^2$.\n- No two pre-placed models appear in the same cell.\n- It is guaranteed that the set of pre-placed models follows the rules.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- $R_i = 1$, for all $i$. (Any models that are pre-placed are in the top row. Note that you may add/replace models in that row and/or add models in other rows.)\n\n**Large dataset (25 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq R_i \\leq N$, for all $i$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 Qualification] Fashion Show", "background": "", "description": "You are about to host a fashion show to show off three new styles of clothing. The show will be held on a stage which is in the most fashionable of all shapes: an $N$-by-$N$ grid of cells.\n\nEach cell in the grid can be empty (which we represent with a `.` character) or can contain one fashion model. The models come in three types, depending on the clothing style they are wearing: `+`, `x`, and the super-trendy `o`. A cell with a `+` or `x` model in it adds 1 style point to the show. A cell with an `o` model in it adds 2 style points. Empty cells add no style points.\n\nTo achieve the maximum artistic effect, there are rules on how models can be placed relative to each other.\n\n* Whenever any two models share a row or column, at least one of the two must be a `+`.\n* Whenever any two models share a diagonal of the grid, at least one of the two must be an `x`.\n\nFormally, a model located in row $i_0$ and column $j_0$ and a model located in row $i_1$ and column $j_1$ share a row if and only if $i_0 = i_1$, they share a column if and only if $j_0 = j_1$, and they share a diagonal if and only if $i_0 + j_0 = i_1 + j_1$ or $i_0 - j_0 = i_1 - j_1$.\n\nFor example, the following grid is not legal:\n\n```\n...\nx+o\n.+.\n```\n\nThe middle row has a pair of models (`x` and `o`) that does not include a `+`. The diagonal starting at the `+` in the bottom row and running up to the `o` in the middle row has two models, and neither of them is an `x`.\n\nHowever, the following grid is legal. No row, column, or diagonal violates the rules.\n\n```\n+.x\n+x+\no..\n```\n\nYour artistic advisor has already placed $M$ models in certain cells, following these rules. You are free to place any number (including zero) of additional models of whichever types you like. You may not remove existing models, but you may upgrade as many existing `+` and `x` models into o models as you wish, as long as the above rules are not violated.\n\nYour task is to find a legal way of placing and/or upgrading models that earns the maximum possible number of style points.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with one line with two integers $N$ and $M$, as described above. Then, $M$ more lines follow; the $i$-th of these lines has a `+`, `x`, or `o` character (the type of the model) and two integers $R_i$ and $C_i$ (the position of the model). The rows of the grid are numbered 1 through $N$, from top to bottom. The columns of the grid are numbered 1 through $N$, from left to right.\n", "outputFormat": "For each test case, first output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), $y$ is the number of style points earned in your arrangement, and $z$ is the total number of models you have added and/or substituted in. Then, for each model that you have added or substituted in, output exactly one line in exactly the same format described in the Input section, where the character is the type of the model that you have added or substituted in. These $z$ lines can be in any order.\n\nIf there are multiple valid answers, you may output any one of them.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible. Note that the last sample case would not appear in the Small dataset.\n\nIn sample case #1, the grid is 2-by-2 and is initially blank. The output corresponds to the following grid. (In these explanations, we will use . to denote a blank cell.)\n```\nx.\n+o\n```\nIn sample case #2, the only cell is already occupied by an o model, and it is impossible to add a new model or replace the o model.\n\nIn sample case #3, the grid looks like this before you place any models:\n```\n...\n+++\nx..\n```\nThe output corresponds to this grid:\n```\n.x.\n++o\nx..\n```\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 100$.\n- $1 \\leq C_i \\leq N$, for all $i$.\n- $0 \\leq M \\leq N^2$.\n- No two pre-placed models appear in the same cell.\n- It is guaranteed that the set of pre-placed models follows the rules.\n\n**Small dataset (10 Pts, Test Set 1 - Visible)**\n\n- $R_i = 1$, for all $i$. (Any models that are pre-placed are in the top row. Note that you may add/replace models in that row and/or add models in other rows.)\n\n**Large dataset (25 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq R_i \\leq N$, for all $i$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 Qualification] Fashion Show", "background": null, "description": "你即将举办一场时装秀，展示三种新款服装。秀场的舞台是最时尚的形状：一个 $N \\times N$ 的网格。\n\n网格中的每个格子可以是空的（用 `.` 表示），也可以有一位时装模特。模特分为三种类型，取决于他们所穿的服装风格：`+`、`x`，以及超级时尚的 `o`。一个格子中如果有 `+` 或 `x` 型模特，将为秀场增加 1 分风格分；如果有 `o` 型模特，则增加 2 分风格分。空格子不加分。\n\n为了达到最佳艺术效果，模特的摆放有如下规则：\n\n- 只要有两个模特处于同一行或同一列，这两个模特中至少有一个必须是 `+`。\n- 只要有两个模特处于同一对角线，这两个模特中至少有一个必须是 `x`。\n\n形式化地说，若一个模特位于第 $i_0$ 行第 $j_0$ 列，另一个模特位于第 $i_1$ 行第 $j_1$ 列，则当 $i_0 = i_1$ 时他们同一行，当 $j_0 = j_1$ 时同一列，当 $i_0 + j_0 = i_1 + j_1$ 或 $i_0 - j_0 = i_1 - j_1$ 时同一对角线。\n\n例如，下面这个网格是不合法的：\n\n```\n...\nx+o\n.+.\n```\n\n中间一行有一对模特（`x` 和 `o`），但其中没有 `+`。从底行的 `+` 到中间行的 `o` 的对角线上有两个模特，但都不是 `x`。\n\n而下面这个网格是合法的，没有任何行、列或对角线违反规则：\n\n```\n+.x\n+x+\no..\n```\n\n你的艺术顾问已经按照规则在某些格子中预先放置了 $M$ 个模特。你可以在任意数量（包括零个）格子中自由添加任意类型的模特。你不能移除已有的模特，但可以将已有的 `+` 或 `x` 型模特升级为 `o` 型，只要不违反上述规则。\n\n你的任务是找到一种合法的放置和/或升级方式，使得获得的风格分最大。", "inputFormat": "第一行输入一个整数 $T$，表示测试用例的数量。接下来有 $T$ 组测试数据。每组测试数据的第一行包含两个整数 $N$ 和 $M$。接下来 $M$ 行，每行包含一个字符（`+`、`x` 或 `o`）和两个整数 $R_i$、$C_i$，表示该模特的类型和位置。网格的行从上到下编号为 $1$ 到 $N$，列从左到右编号为 $1$ 到 $N$。", "outputFormat": "对于每个测试用例，首先输出一行 `Case #x: y z`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是你安排下获得的风格分，$z$ 是你添加和/或替换的模特总数。然后，对于每一个你添加或替换的模特，输出一行，格式与输入部分相同，字符为你添加或替换的模特类型。这 $z$ 行顺序不限。\n\n如果有多种合法方案，你可以输出其中任意一种。", "hint": "**样例说明**\n\n样例输出展示了样例数据的一组解。其他解也是可能的。注意最后一个样例不会出现在 Small 数据集中。\n\n在样例 1 中，网格为 $2 \\times 2$，初始为空。输出对应如下网格（用 `.` 表示空格）：\n```\nx.\n+o\n```\n在样例 2 中，唯一的格子已经被 `o` 型模特占据，无法再添加或替换模特。\n\n在样例 3 中，初始网格如下：\n```\n...\n+++\nx..\n```\n输出对应如下网格：\n```\n.x.\n++o\nx..\n```\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq N \\leq 100$。\n- $1 \\leq C_i \\leq N$，对所有 $i$。\n- $0 \\leq M \\leq N^2$。\n- 不会有两个预放置的模特在同一格子。\n- 保证所有预放置的模特均符合规则。\n\n**小数据（10 分，测试集 1 - 可见）**\n\n- $R_i = 1$，对所有 $i$。（所有预放置的模特都在第一行。你可以在该行添加/替换模特，也可以在其他行添加模特。）\n\n**大数据（25 分，测试集 2 - 隐藏）**\n\n- $1 \\leq R_i \\leq N$，对所有 $i$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13162", "type": "P", "difficulty": 3, "samples": [["3\n3 3\nG??\n?C?\n??J\n3 4\nCODE\n????\n?JAM\n2 2\nCA\nKE", "Case #1:\nGGJ\nCCJ\nCCJ\nCase #2:\nCODE\nCOAE\nJJAM\nCase #3:\nCA\nKE"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "贪心", "2017", "递归", "Special Judge", "Google Code Jam"], "title": "[GCJ 2017 #1A] Alphabet Cake", "background": "", "description": "You are catering a party for some children, and you are serving them a cake in the shape of a grid with $R$ rows and $C$ columns. Your assistant has started to decorate the cake by writing every child's initial in icing on exactly one cell of the cake. Each cell contains at most one initial, and since no two children share the same initial, no initial appears more than once on the cake.\n\nEach child wants a single rectangular (grid-aligned) piece of cake that has their initial and no other child's initial(s). Can you find a way to assign every blank cell of the cake to one child, such that this goal is accomplished? It is guaranteed that this is always possible. There is no need to split the cake evenly among the children, and one or more of them may even get a 1-by-1 piece; this will be a valuable life lesson about unfairness.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with two integers $R$ and $C$. Then, there are $R$ more lines of $C$ characters each, representing the cake. Each character is either an uppercase English letter (which means that your assistant has already added that letter to that cell) or ? (which means that that cell is blank).\n", "outputFormat": "For each test case, output one line containing `Case #x:` and nothing else. Then output $R$ more lines of $C$ characters each. Your output grid must be identical to the input grid, but with every `?` replaced with an uppercase English letter, representing that that cell appears in the slice for the child who has that initial. You may not add letters that did not originally appear in the input. In your grid, for each letter, the region formed by all the cells containing that letter must be a single grid-aligned rectangle.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- There is at least one letter in the input grid.\n- No letter appears in more than one cell in the input grid.\n- It is guaranteed that at least one answer exists for each test case.\n\n**Small dataset (8 Pts, Test Set 1 - Visible)**\n\n- $1 \\leq R \\leq 12$.\n- $1 \\leq C \\leq 12$.\n- $R \\times C \\leq 12$.\n\n**Large dataset (13 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq R \\leq 25$.\n- $1 \\leq C \\leq 25$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1A] Alphabet Cake", "background": "", "description": "You are catering a party for some children, and you are serving them a cake in the shape of a grid with $R$ rows and $C$ columns. Your assistant has started to decorate the cake by writing every child's initial in icing on exactly one cell of the cake. Each cell contains at most one initial, and since no two children share the same initial, no initial appears more than once on the cake.\n\nEach child wants a single rectangular (grid-aligned) piece of cake that has their initial and no other child's initial(s). Can you find a way to assign every blank cell of the cake to one child, such that this goal is accomplished? It is guaranteed that this is always possible. There is no need to split the cake evenly among the children, and one or more of them may even get a 1-by-1 piece; this will be a valuable life lesson about unfairness.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with two integers $R$ and $C$. Then, there are $R$ more lines of $C$ characters each, representing the cake. Each character is either an uppercase English letter (which means that your assistant has already added that letter to that cell) or ? (which means that that cell is blank).\n", "outputFormat": "For each test case, output one line containing `Case #x:` and nothing else. Then output $R$ more lines of $C$ characters each. Your output grid must be identical to the input grid, but with every `?` replaced with an uppercase English letter, representing that that cell appears in the slice for the child who has that initial. You may not add letters that did not originally appear in the input. In your grid, for each letter, the region formed by all the cells containing that letter must be a single grid-aligned rectangle.", "hint": "**Sample Explanation**\n\nThe sample output displays one set of answers to the sample cases. Other answers may be possible.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- There is at least one letter in the input grid.\n- No letter appears in more than one cell in the input grid.\n- It is guaranteed that at least one answer exists for each test case.\n\n**Small dataset (8 Pts, Test Set 1 - Visible)**\n\n- $1 \\leq R \\leq 12$.\n- $1 \\leq C \\leq 12$.\n- $R \\times C \\leq 12$.\n\n**Large dataset (13 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq R \\leq 25$.\n- $1 \\leq C \\leq 25$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1A] Alphabet Cake", "background": null, "description": "你正在为一些孩子举办一个聚会，并为他们准备了一个蛋糕，蛋糕的形状是一个 $R$ 行 $C$ 列的网格。你的助手已经开始装饰蛋糕，在每个孩子的首字母上用糖霜写在蛋糕的某一个格子里。每个格子最多只包含一个首字母，并且没有两个孩子的首字母相同，因此每个首字母在蛋糕上只出现一次。\n\n每个孩子都希望得到一块包含自己首字母且不包含其他孩子首字母的矩形（与网格对齐）蛋糕。你能否为蛋糕上的每一个空白格子分配归属，使得每个孩子都能得到满足要求的蛋糕块？保证一定存在可行解。蛋糕不需要平均分配，甚至有的孩子可能只得到 $1 \\times 1$ 的小块；这将是关于不公平的宝贵人生课程。", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据。每组数据的第一行为两个整数 $R$ 和 $C$。接下来 $R$ 行，每行 $C$ 个字符，表示蛋糕的网格。每个字符要么是一个大写英文字母（表示你的助手已经在该格子写上了这个字母），要么是 `?`（表示该格子为空）。", "outputFormat": "对于每组测试数据，输出一行 `Case #x:`，其中 $x$ 是当前测试数据的编号（从 1 开始）。然后输出 $R$ 行，每行 $C$ 个字符，表示你分配后的蛋糕网格。你的输出网格必须与输入网格相同，只不过将所有的 `?` 替换为大写英文字母，表示该格子属于哪个孩子的蛋糕块。你不能添加输入中没有出现过的字母。在你的输出网格中，对于每个字母，所有包含该字母的格子必须组成一个与网格对齐的矩形区域。", "hint": "**样例解释**\n\n样例输出展示了样例数据的一组可行解。其他解也是可能的。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- 输入网格中至少有一个字母。\n- 每个字母最多只在一个格子中出现一次。\n- 保证每组测试数据都至少有一个解。\n\n**小数据范围（8 分，测试点 1 - 可见）**\n\n- $1 \\leq R \\leq 12$。\n- $1 \\leq C \\leq 12$。\n- $R \\times C \\leq 12$。\n\n**大数据范围（13 分，测试点 2 - 隐藏）**\n\n- $1 \\leq R \\leq 25$。\n- $1 \\leq C \\leq 25$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13163", "type": "P", "difficulty": 4, "samples": [["6\n2 1\n500 300\n900\n660\n2 1\n500 300\n1500\n809\n2 2\n50 100\n450 449\n1100 1101\n2 1\n500 300\n300\n500\n1 8\n10\n11 13 17 11 16 14 12 18\n3 3\n70 80 90\n1260 1500 700\n800 1440 1600\n1700 1620 900", "Case #1: 1\nCase #2: 0\nCase #3: 1\nCase #4: 0\nCase #5: 3\nCase #6: 3"]], "limits": {"time": [15000, 30000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2017", "Google Code Jam"], "title": "[GCJ 2017 #1A] Ratatouille", "background": "", "description": "You've discovered it: the ultimate recipe for ratatouille, the famous French dish! You know which ingredients to use, and how many grams of each one to use, in order to make one serving of ratatouille. But you believe that anyone can cook, and so you want to share the recipe with the world... and make some money in the process!\n\nYou have ordered some ingredient packages that are easy to ship. Each package contains some amount of one ingredient; different packages may have different amounts even if they contain the same ingredient. For convenience, you ordered the same number of packages of each ingredient.\n\nYou would like to use these packages to form as many ratatouille kits as possible to send to customers. A kit consists of exactly one package of each ingredient, and a label with the integer number of servings of ratatouille that the kit makes. Since you do not want to shortchange customers or waste food, each package must contain between $90$ and $110$ percent (inclusive) of the amount of that ingredient that is actually needed to make the number of servings of ratatouille on the kit's label.\n\nFor example, suppose that one serving of ratatouille takes $500$ g of tomato and $300$ g of onion. Suppose that you have a $900$ g package of tomato and a $660$ g package of onion. You could form these into a kit that makes two servings of ratatouille. To make two servings, $1000$ g of tomato and $600$ g of onion are required. Since the $900$ g of tomato you have is within $[90, 110]\\%$ of the $1000$ g of tomato required, and the $660$ g of onion you have is within $[90, 110]\\%$ of the $600$ g of onion required, this is acceptable. However, you could not say that the kit makes one or three servings of ratatouille, nor could you say that it makes $1.999$ servings (the number of servings must be an integer).\n\nNote that there are some sets of packages that could never form a kit. Continuing with our recipe above, if you have a $1500$ g package of tomato and an $809$ g package of onion, for example, there is no amount of servings that you can make. Three servings would take $1500$ g of tomato and $900$ g of onion, and the amount of onion is not within the $[90, 110]\\%$ range. No other integer amount of servings works, either.\n\nYou want to share your recipe with as many customers as possible, so you want to produce the maximum number of valid kits. (Of course, each package can be used in at most one kit.) What is the largest number of kits that you can form? Note that you are not required to maximize the total number of servings of ratatouille formed.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case consists of the following:\n\n* One line with two integers $N$: the number of ingredients, and $P$, the number of packages of each ingredient.\n* One line with $N$ integers $R_i$. The i-th of these represents the number of grams of the i-th ingredient needed to make one serving of ratatouille.\n* $N$ more lines of $P$ integers each. The j-th value on the i-th of these lines, $Q_{ij}$, represents the quantity, in grams, in the j-th package of the i-th ingredient.", "outputFormat": "For each test case, output one line containing Case #x: y, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of kits you can produce, as described above.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in the Small dataset.\n\nSample cases #1 and #2 are the ones described in the problem statement.\n\nIn sample case #3, you can form a kit out of the $450$ g package of the first ingredient and the $1100$ g package of the second ingredient, and say that the kit makes $10$ servings of ratatouille. That number of servings requires $500$ g of the first ingredient; you have $450$ g, which is $90\\%$ of $500$ and within the allowed limit. It requires $1000$ g of the second ingredient; you have $1100$ g, which is $110\\%$ of $1000$ and within the allowed limit.\n\nOnce you form this kit, however, you cannot form the remaining packages into a kit. $449$ g of the first ingredient and $1101$ g of the second ingredient would not be able to form $10$ (or any other number of) servings. In fact, the ($450$ g, $1100$ g) kit is the only kit that can be formed from these packages.\n\nIn sample case #4, no kits can be formed. Note that the recipe requires particular amounts of particular ingredients in the given order, the ingredients are not interchangeable. This is fine French cuisine, after all!\n\nIn sample case #5, the recipe has only one ingredient — how elegantly simple! A single serving cannot use more than $11$ g, and two servings cannot use fewer than $18$ g. It is possible to form three kits: two with an $11$ g package, and one with an $18$ g package.\n\nIn sample case #6, you can form three valid kits: ($700$ g, $800$ g, $900$ g), which makes $10$ servings, and ($1500$ g, $1600$ g, $1700$ g) and ($1260$ g, $1440$ g, $1620$ g), each of which makes $20$ servings. Note that you could also say that the ($1260$ g, $1440$ g, $1620$ g) kit makes $17$, $18$, or $19$ servings, but it does not matter how many servings a kit makes as long as the kit is valid.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq R_i \\leq 10^6$, for all $i$.\n- $1 \\leq Q_{ij} \\leq 10^6$, for all $i$ and $j$.\n\n**Small dataset (12 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq N \\leq 2$.\n- $1 \\leq P \\leq 8$.\n\n**Large dataset (23 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $1 \\leq N \\leq 50$.\n- $1 \\leq P \\leq 50$.\n- $N \\times P \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1A] Ratatouille", "background": "", "description": "You've discovered it: the ultimate recipe for ratatouille, the famous French dish! You know which ingredients to use, and how many grams of each one to use, in order to make one serving of ratatouille. But you believe that anyone can cook, and so you want to share the recipe with the world... and make some money in the process!\n\nYou have ordered some ingredient packages that are easy to ship. Each package contains some amount of one ingredient; different packages may have different amounts even if they contain the same ingredient. For convenience, you ordered the same number of packages of each ingredient.\n\nYou would like to use these packages to form as many ratatouille kits as possible to send to customers. A kit consists of exactly one package of each ingredient, and a label with the integer number of servings of ratatouille that the kit makes. Since you do not want to shortchange customers or waste food, each package must contain between $90$ and $110$ percent (inclusive) of the amount of that ingredient that is actually needed to make the number of servings of ratatouille on the kit's label.\n\nFor example, suppose that one serving of ratatouille takes $500$ g of tomato and $300$ g of onion. Suppose that you have a $900$ g package of tomato and a $660$ g package of onion. You could form these into a kit that makes two servings of ratatouille. To make two servings, $1000$ g of tomato and $600$ g of onion are required. Since the $900$ g of tomato you have is within $[90, 110]\\%$ of the $1000$ g of tomato required, and the $660$ g of onion you have is within $[90, 110]\\%$ of the $600$ g of onion required, this is acceptable. However, you could not say that the kit makes one or three servings of ratatouille, nor could you say that it makes $1.999$ servings (the number of servings must be an integer).\n\nNote that there are some sets of packages that could never form a kit. Continuing with our recipe above, if you have a $1500$ g package of tomato and an $809$ g package of onion, for example, there is no amount of servings that you can make. Three servings would take $1500$ g of tomato and $900$ g of onion, and the amount of onion is not within the $[90, 110]\\%$ range. No other integer amount of servings works, either.\n\nYou want to share your recipe with as many customers as possible, so you want to produce the maximum number of valid kits. (Of course, each package can be used in at most one kit.) What is the largest number of kits that you can form? Note that you are not required to maximize the total number of servings of ratatouille formed.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case consists of the following:\n\n* One line with two integers $N$: the number of ingredients, and $P$, the number of packages of each ingredient.\n* One line with $N$ integers $R_i$. The i-th of these represents the number of grams of the i-th ingredient needed to make one serving of ratatouille.\n* $N$ more lines of $P$ integers each. The j-th value on the i-th of these lines, $Q_{ij}$, represents the quantity, in grams, in the j-th package of the i-th ingredient.", "outputFormat": "For each test case, output one line containing Case #x: y, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of kits you can produce, as described above.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in the Small dataset.\n\nSample cases #1 and #2 are the ones described in the problem statement.\n\nIn sample case #3, you can form a kit out of the $450$ g package of the first ingredient and the $1100$ g package of the second ingredient, and say that the kit makes $10$ servings of ratatouille. That number of servings requires $500$ g of the first ingredient; you have $450$ g, which is $90\\%$ of $500$ and within the allowed limit. It requires $1000$ g of the second ingredient; you have $1100$ g, which is $110\\%$ of $1000$ and within the allowed limit.\n\nOnce you form this kit, however, you cannot form the remaining packages into a kit. $449$ g of the first ingredient and $1101$ g of the second ingredient would not be able to form $10$ (or any other number of) servings. In fact, the ($450$ g, $1100$ g) kit is the only kit that can be formed from these packages.\n\nIn sample case #4, no kits can be formed. Note that the recipe requires particular amounts of particular ingredients in the given order, the ingredients are not interchangeable. This is fine French cuisine, after all!\n\nIn sample case #5, the recipe has only one ingredient — how elegantly simple! A single serving cannot use more than $11$ g, and two servings cannot use fewer than $18$ g. It is possible to form three kits: two with an $11$ g package, and one with an $18$ g package.\n\nIn sample case #6, you can form three valid kits: ($700$ g, $800$ g, $900$ g), which makes $10$ servings, and ($1500$ g, $1600$ g, $1700$ g) and ($1260$ g, $1440$ g, $1620$ g), each of which makes $20$ servings. Note that you could also say that the ($1260$ g, $1440$ g, $1620$ g) kit makes $17$, $18$, or $19$ servings, but it does not matter how many servings a kit makes as long as the kit is valid.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq R_i \\leq 10^6$, for all $i$.\n- $1 \\leq Q_{ij} \\leq 10^6$, for all $i$ and $j$.\n\n**Small dataset (12 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq N \\leq 2$.\n- $1 \\leq P \\leq 8$.\n\n**Large dataset (23 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $1 \\leq N \\leq 50$.\n- $1 \\leq P \\leq 50$.\n- $N \\times P \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1A] Ratatouille", "background": null, "description": "你发现了终极的“ratatouille”（法国蔬菜杂烩）配方！你已经知道制作一份 ratatouille 需要哪些原料，以及每种原料需要多少克。你相信“人人都能做菜”，所以你想把这个配方分享给全世界……顺便赚点钱！\n\n你订购了一些便于运输的原料包装。每个包装只包含一种原料；即使是同一种原料，不同包装中的数量也可能不同。为了方便，你为每种原料都订购了相同数量的包装。\n\n你希望用这些包装尽可能多地组装出 ratatouille 套装，发给顾客。每个套装由每种原料各一个包装组成，并贴有一个标签，标明该套装可以制作多少份 ratatouille（份数为整数）。为了保证不亏待顾客且不浪费食材，每个包装中的原料含量必须在制作标签上标明的份数所需原料的 $90\\%$ 到 $110\\%$（含端点）之间。\n\n例如，假设制作一份 ratatouille 需要 $500$ 克番茄和 $300$ 克洋葱。假如你有一个 $900$ 克的番茄包装和一个 $660$ 克的洋葱包装。你可以将它们组合成一个可以制作两份 ratatouille 的套装。制作两份需要 $1000$ 克番茄和 $600$ 克洋葱。你拥有的 $900$ 克番茄在 $1000$ 克的 $[90\\%, 110\\%]$ 区间内，$660$ 克洋葱也在 $600$ 克的 $[90\\%, 110\\%]$ 区间内，因此这是可行的。然而，你不能说这个套装可以制作一份或三份 ratatouille，也不能说可以制作 $1.999$ 份（份数必须为整数）。\n\n注意，有些包装组合永远无法组成一个套装。继续上面的例子，如果你有一个 $1500$ 克的番茄包装和一个 $809$ 克的洋葱包装，无论制作多少份都不行。三份需要 $1500$ 克番茄和 $900$ 克洋葱，但 $809$ 克洋葱不在 $[90\\%, 110\\%]$ 区间内。没有其他整数份数可行。\n\n你希望让尽可能多的顾客享受到你的配方，所以你想制作最多数量的有效套装。（当然，每个包装最多只能用在一个套装中。）你最多能组装出多少个套装？注意，你不需要最大化 ratatouille 的总份数。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据包括：\n\n- 一行包含两个整数 $N$ 和 $P$，分别表示原料种类数和每种原料的包装数量。\n- 一行包含 $N$ 个整数 $R_i$，第 $i$ 个数表示制作一份 ratatouille 需要的第 $i$ 种原料的克数。\n- 接下来 $N$ 行，每行包含 $P$ 个整数。第 $i$ 行的第 $j$ 个数 $Q_{ij}$ 表示第 $i$ 种原料的第 $j$ 个包装的克数。", "outputFormat": "对于每组测试数据，输出一行 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是你最多能组装出的套装数量。", "hint": "**样例解释**\n\n注意，最后一个样例不会出现在 Small 数据集中。\n\n样例 1 和 2 就是题目描述中的例子。\n\n在样例 3 中，你可以用第一种原料的 $450$ 克包装和第二种原料的 $1100$ 克包装，组装成一个制作 $10$ 份 ratatouille 的套装。制作 $10$ 份需要第一种原料 $500$ 克，你有 $450$ 克，正好是 $500$ 克的 $90\\%$，在允许范围内。第二种原料需要 $1000$ 克，你有 $1100$ 克，正好是 $110\\%$，也在允许范围内。\n\n但组装完这个套装后，剩下的包装无法再组成套装。$449$ 克的第一种原料和 $1101$ 克的第二种原料无法组成 $10$ 份（或其他份数）的套装。实际上，($450$ 克, $1100$ 克) 是唯一能组成的套装。\n\n在样例 4 中，无法组成任何套装。注意，配方要求每种原料的顺序和用量都不能变，原料不可互换。这可是正宗法式料理！\n\n在样例 5 中，配方只有一种原料——多么优雅！一份不能超过 $11$ 克，两份不能少于 $18$ 克。可以组装出三个套装：两个 $11$ 克包装，一个 $18$ 克包装。\n\n在样例 6 中，可以组装出三个有效套装：($700$ 克, $800$ 克, $900$ 克)，可制作 $10$ 份；($1500$ 克, $1600$ 克, $1700$ 克) 和 ($1260$ 克, $1440$ 克, $1620$ 克)，每个都可制作 $20$ 份。注意，($1260$ 克, $1440$ 克, $1620$ 克) 也可以标为 $17$、$18$ 或 $19$ 份，但只要套装有效，份数具体是多少并不重要。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq R_i \\leq 10^6$，对所有 $i$。\n- $1 \\leq Q_{ij} \\leq 10^6$，对所有 $i, j$。\n\n**小数据集（12 分，测试点 1 - 可见）**\n\n- 时间限制：15 秒。\n- $1 \\leq N \\leq 2$。\n- $1 \\leq P \\leq 8$。\n\n**大数据集（23 分，测试点 2 - 隐藏）**\n\n- 时间限制：30 秒。\n- $1 \\leq N \\leq 50$。\n- $1 \\leq P \\leq 50$。\n- $N \\times P \\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13164", "type": "P", "difficulty": 7, "samples": [["4\n11 5 16 5 0 0\n3 1 3 2 2 0\n3 1 3 2 1 0\n2 1 5 1 1 1", "Case #1: 5\nCase #2: 2\nCase #3: IMPOSSIBLE\nCase #4: 5"]], "limits": {"time": [15000, 60000], "memory": [1048576, 1048576]}, "tags": ["数学", "2017", "Google Code Jam"], "title": "[GCJ 2017 #1A] Play the Dragon", "background": "", "description": "You are a friendly dragon fighting to protect your lair from a greedy knight! You have $H_d$ health points and an attack power of $A_d$, and the knight has $H_k$ health points and an attack power of $A_k$. If your health drops to 0 or below at any point; you are knocked out and you instantly lose; if the knight's health drops to 0 or below at any point, the knight is knocked out and you win!\n\nYou will battle the knight in a series of turns. On each turn, you go first, and you can choose and execute any one of the following actions.\n\n* Attack: Reduce the opponent's health by your own attack power.\n* Buff: Increase your attack power by $B$ for the rest of the battle.\n* Cure: Your health becomes $H_d$.\n* Debuff: Decrease the opponent's attack power by $D$ for the rest of the battle. If a Debuff would cause the opponent's attack power to become less than 0, it instead sets it to 0.\n\nThen, if the knight's health is greater than 0 following your action, the knight will execute an Attack action. After that, the turn ends. (Note that a turn in which you defeat the knight still counts as a turn even though the knight does not get to act.)\n\nNote that buffs stack with each other; every buff adds an additional $B$ to your attack power. Similarly, debuffs stack with each other.\n\nYou would like to defeat the knight as fast as possible (if it is possible) so that you will not be late to help the villagers roast marshmallows at tonight's festival. Can you determine the minimum number of turns in which you can defeat the knight, or that it is IMPOSSIBLE to do so?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line with six integers $H_d$, $A_d$, $H_k$, $A_k$, $B$, and $D$, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either IMPOSSIBLE if it is not possible to defeat the knight, or the minimum number of turns needed to defeat the knight.", "hint": "**Sample Explanation**\n\nIn Case #1, you have 11 health and 5 attack, and the knight has 16 health and 5 attack. One possible optimal sequence of actions is:\n\n* Turn 1: Attack, reducing the knight's health to 11. Then the knight attacks and reduces your health to 6.\n* Turn 2: Attack, reducing the knight's health to 6. Then the knight attacks and reduces your health to 1.\n* Turn 3: Cure, restoring your health to 11. Then the knight attacks and reduces your health to 6. (If you had attacked instead this turn, the knight's next attack would have caused you to lose.)\n* Turn 4: Attack, reducing the knight's health to 1. Then the knight attacks and reduces your health to 1.\n* Turn 5: Attack, reducing the knight's health to -4. You instantly win and the knight does not get another attack.\n\nIn Case #2, one possible optimal sequence of actions is:\n\n* Turn 1: Buff, increasing your attack power to 3. Then the knight attacks and reduces your health to 1.\n* Turn 2: Attack, reducing the knight's health to 0. You instantly win and the knight does not get another attack.\n\nIn Case #3, the knight only needs two attacks to defeat you, and you cannot do enough damage fast enough to defeat the knight. You can indefinitely extend the combat by executing the Cure action after every attack, but it is impossible to actually defeat the knight.\n\nIn Case #4, one possible optimal sequence of actions is: Attack, Debuff, Buff, Attack, Attack.\n\n**Limits**\n\n$1 \\leq T \\leq 100$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq H_d \\leq 100$.\n- $1 \\leq A_d \\leq 100$.\n- $1 \\leq H_k \\leq 100$.\n- $1 \\leq A_k \\leq 100$.\n- $0 \\leq B \\leq 100$.\n- $0 \\leq D \\leq 100$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~240~~ 60 seconds.\n- $1 \\leq H_d \\leq 10^9$.\n- $1 \\leq A_d \\leq 10^9$.\n- $1 \\leq H_k \\leq 10^9$.\n- $1 \\leq A_k \\leq 10^9$.\n- $0 \\leq B \\leq 10^9$.\n- $0 \\leq D \\leq 10^9$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1A] Play the Dragon", "background": "", "description": "You are a friendly dragon fighting to protect your lair from a greedy knight! You have $H_d$ health points and an attack power of $A_d$, and the knight has $H_k$ health points and an attack power of $A_k$. If your health drops to 0 or below at any point; you are knocked out and you instantly lose; if the knight's health drops to 0 or below at any point, the knight is knocked out and you win!\n\nYou will battle the knight in a series of turns. On each turn, you go first, and you can choose and execute any one of the following actions.\n\n* Attack: Reduce the opponent's health by your own attack power.\n* Buff: Increase your attack power by $B$ for the rest of the battle.\n* Cure: Your health becomes $H_d$.\n* Debuff: Decrease the opponent's attack power by $D$ for the rest of the battle. If a Debuff would cause the opponent's attack power to become less than 0, it instead sets it to 0.\n\nThen, if the knight's health is greater than 0 following your action, the knight will execute an Attack action. After that, the turn ends. (Note that a turn in which you defeat the knight still counts as a turn even though the knight does not get to act.)\n\nNote that buffs stack with each other; every buff adds an additional $B$ to your attack power. Similarly, debuffs stack with each other.\n\nYou would like to defeat the knight as fast as possible (if it is possible) so that you will not be late to help the villagers roast marshmallows at tonight's festival. Can you determine the minimum number of turns in which you can defeat the knight, or that it is IMPOSSIBLE to do so?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line with six integers $H_d$, $A_d$, $H_k$, $A_k$, $B$, and $D$, as described above.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is either IMPOSSIBLE if it is not possible to defeat the knight, or the minimum number of turns needed to defeat the knight.", "hint": "**Sample Explanation**\n\nIn Case #1, you have 11 health and 5 attack, and the knight has 16 health and 5 attack. One possible optimal sequence of actions is:\n\n* Turn 1: Attack, reducing the knight's health to 11. Then the knight attacks and reduces your health to 6.\n* Turn 2: Attack, reducing the knight's health to 6. Then the knight attacks and reduces your health to 1.\n* Turn 3: Cure, restoring your health to 11. Then the knight attacks and reduces your health to 6. (If you had attacked instead this turn, the knight's next attack would have caused you to lose.)\n* Turn 4: Attack, reducing the knight's health to 1. Then the knight attacks and reduces your health to 1.\n* Turn 5: Attack, reducing the knight's health to -4. You instantly win and the knight does not get another attack.\n\nIn Case #2, one possible optimal sequence of actions is:\n\n* Turn 1: Buff, increasing your attack power to 3. Then the knight attacks and reduces your health to 1.\n* Turn 2: Attack, reducing the knight's health to 0. You instantly win and the knight does not get another attack.\n\nIn Case #3, the knight only needs two attacks to defeat you, and you cannot do enough damage fast enough to defeat the knight. You can indefinitely extend the combat by executing the Cure action after every attack, but it is impossible to actually defeat the knight.\n\nIn Case #4, one possible optimal sequence of actions is: Attack, Debuff, Buff, Attack, Attack.\n\n**Limits**\n\n$1 \\leq T \\leq 100$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq H_d \\leq 100$.\n- $1 \\leq A_d \\leq 100$.\n- $1 \\leq H_k \\leq 100$.\n- $1 \\leq A_k \\leq 100$.\n- $0 \\leq B \\leq 100$.\n- $0 \\leq D \\leq 100$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~240~~ 60 seconds.\n- $1 \\leq H_d \\leq 10^9$.\n- $1 \\leq A_d \\leq 10^9$.\n- $1 \\leq H_k \\leq 10^9$.\n- $1 \\leq A_k \\leq 10^9$.\n- $0 \\leq B \\leq 10^9$.\n- $0 \\leq D \\leq 10^9$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1A] Play the Dragon", "background": null, "description": "你是一条友善的龙，正在与一名贪婪的骑士战斗，以保护你的巢穴！你拥有 $H_d$ 点生命值和 $A_d$ 点攻击力，骑士拥有 $H_k$ 点生命值和 $A_k$ 点攻击力。如果你的生命值在任何时刻降至 $0$ 或以下，你会被击倒并立即失败；如果骑士的生命值在任何时刻降至 $0$ 或以下，骑士会被击倒，你获得胜利！\n\n你将与骑士进行一系列回合的战斗。在每个回合中，你先行动，可以选择并执行以下任意一个动作：\n\n- 攻击（Attack）：使对方的生命值减少你当前的攻击力。\n- 增益（Buff）：你的攻击力永久增加 $B$。\n- 治疗（Cure）：你的生命值恢复为 $H_d$。\n- 减益（Debuff）：对方的攻击力永久减少 $D$。如果减益会使对方攻击力降至 $0$ 以下，则将其设为 $0$。\n\n然后，如果你的动作后骑士的生命值仍大于 $0$，骑士会执行一次攻击动作。之后本回合结束。（注意，如果你在本回合击败了骑士，虽然骑士不会再行动，但该回合仍然计入总回合数。）\n\n注意，增益和减益效果可以叠加；每次增益会额外增加 $B$ 攻击力，每次减益会额外减少 $D$ 攻击力。\n\n你希望尽快击败骑士（如果可能的话），这样你就不会错过今晚村民们烤棉花糖的节日了。你能否判断出击败骑士所需的最少回合数，或者判断是否不可能击败骑士？", "inputFormat": "输入的第一行包含一个整数 $T$，表示测试用例的数量。接下来有 $T$ 组测试用例。每组测试用例占一行，包含六个整数 $H_d$、$A_d$、$H_k$、$A_k$、$B$ 和 $D$，含义如上所述。", "outputFormat": "对于每组测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是击败骑士所需的最少回合数，或者如果无法击败骑士则输出 `IMPOSSIBLE`。", "hint": "**样例解释**\n\n在第 1 组样例中，你有 11 点生命值和 5 点攻击力，骑士有 16 点生命值和 5 点攻击力。一种可能的最优行动顺序如下：\n\n- 第 1 回合：攻击，将骑士生命值降至 11。骑士攻击你，你的生命值降至 6。\n- 第 2 回合：攻击，将骑士生命值降至 6。骑士攻击你，你的生命值降至 1。\n- 第 3 回合：治疗，生命值恢复到 11。骑士攻击你，你的生命值降至 6。（如果你本回合选择攻击，下回合骑士的攻击会让你失败。）\n- 第 4 回合：攻击，将骑士生命值降至 1。骑士攻击你，你的生命值降至 1。\n- 第 5 回合：攻击，将骑士生命值降至 -4。你立即获胜，骑士不会再攻击。\n\n在第 2 组样例中，一种可能的最优行动顺序如下：\n\n- 第 1 回合：增益，攻击力提升至 3。骑士攻击你，你的生命值降至 1。\n- 第 2 回合：攻击，将骑士生命值降至 0。你立即获胜，骑士不会再攻击。\n\n在第 3 组样例中，骑士只需两次攻击就能击败你，而你无法在足够快的时间内击败骑士。你可以通过每次攻击后都治疗来无限延长战斗，但实际上无法击败骑士。\n\n在第 4 组样例中，一种可能的最优行动顺序为：攻击、减益、增益、攻击、攻击。\n\n**数据范围**\n\n$1 \\leq T \\leq 100$。\n\n**小数据集（测试集 1 - 可见）**\n\n- 时间限制：~~60~~ 15 秒。\n- $1 \\leq H_d \\leq 100$。\n- $1 \\leq A_d \\leq 100$。\n- $1 \\leq H_k \\leq 100$。\n- $1 \\leq A_k \\leq 100$。\n- $0 \\leq B \\leq 100$。\n- $0 \\leq D \\leq 100$。\n\n**大数据集（测试集 2 - 隐藏）**\n\n- 时间限制：~~240~~ 60 秒。\n- $1 \\leq H_d \\leq 10^9$。\n- $1 \\leq A_d \\leq 10^9$。\n- $1 \\leq H_k \\leq 10^9$。\n- $1 \\leq A_k \\leq 10^9$。\n- $0 \\leq B \\leq 10^9$。\n- $0 \\leq D \\leq 10^9$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13165", "type": "P", "difficulty": 2, "samples": [["3\n2525 1\n2400 5\n300 2\n120 60\n60 90\n100 2\n80 100\n70 10", "Case #1: 101.000000\nCase #2: 100.000000\nCase #3: 33.333333"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "2017", "Special Judge", "Google Code Jam"], "title": "[GCJ 2017 #1B] Steed 2: Cruise Control", "background": "", "description": "Annie is a bus driver with a high-stress job. She tried to unwind by going on a Caribbean cruise, but that also turned out to be stressful, so she has recently taken up horseback riding.\n\nToday, Annie is riding her horse to the east along a long and narrow one-way road that runs west to east. She is currently at kilometer 0 of the road, and her destination is at kilometer $D$; kilometers along the road are numbered from west to east.\n\nThere are $N$ other horses traveling east on the same road; all of them will go on traveling forever, and all of them are currently between Annie's horse and her destination. The $i$-th of these horses is initially at kilometer $K_i$ and is traveling at its maximum speed of $S_i$ kilometers per hour.\n\nHorses are very polite, and a horse $H_1$ will not pass (move ahead of) another horse $H_2$ that started off ahead of $H_1$. (Two or more horses can share the same position for any amount of time; you may consider the horses to be single points.) Horses (other than Annie's) travel at their maximum speeds, except that whenever a horse $H_1$ catches up to another slower horse $H_2$, $H_1$ reduces its speed to match the speed of $H_2$.\n\nAnnie's horse, on the other hand, does not have a maximum speed and can travel at any speed that Annie chooses, as long as it does not pass another horse. To ensure a smooth ride for her and her horse, Annie wants to choose a single constant \"cruise control\" speed for her horse for the entire trip, from her current position to the destination, such that her horse will not pass any other horses. What is the maximum such speed that she can choose?", "inputFormat": "The first line of the input gives the number of test cases, $T$; $T$ test cases follow. Each test case begins with two integers $D$ and $N$: the destination position of all of the horses (in kilometers) and the number of other horses on the road. Then, $N$ lines follow. The $i$-th of those lines has two integers $K_i$ and $S_i$: the initial position (in kilometers) and maximum speed (in kilometers per hour) of the $i$-th of the other horses on the road.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum constant speed (in kilometers per hour) that Annie can use without colliding with other horses. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is one other (very slow!) horse on the road; it will reach Annie's destination after $25$ hours. Anything faster than $101$ kilometers per hour would cause Annie to pass the horse before reaching the destination.\n\nIn Sample Case #2, there are two other horses on the road. The faster horse will catch up to the slower horse at kilometer $240$ after $2$ hours. Both horses will then go at the slower horse's speed for $1$ more hour, until the horses reach Annie's destination at kilometer 300. The maximum speed that Annie can choose without passing another horse is $100$ kilometers per hour.\n\n**Sample Explanation**\n\n- $1 \\leq T \\leq 100$.\n- $0 < K_i < D \\leq 10^9$, for all $i$.\n- $K_i \\neq K_j$, for all $i \\neq j$. (No two horses start in the same position.)\n- $1 \\leq S_i \\leq 10000$.\n\n**Small Dataset (11 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 2$.\n\n**Large Dataset (14 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1B] Steed 2: Cruise Control", "background": "", "description": "Annie is a bus driver with a high-stress job. She tried to unwind by going on a Caribbean cruise, but that also turned out to be stressful, so she has recently taken up horseback riding.\n\nToday, Annie is riding her horse to the east along a long and narrow one-way road that runs west to east. She is currently at kilometer 0 of the road, and her destination is at kilometer $D$; kilometers along the road are numbered from west to east.\n\nThere are $N$ other horses traveling east on the same road; all of them will go on traveling forever, and all of them are currently between Annie's horse and her destination. The $i$-th of these horses is initially at kilometer $K_i$ and is traveling at its maximum speed of $S_i$ kilometers per hour.\n\nHorses are very polite, and a horse $H_1$ will not pass (move ahead of) another horse $H_2$ that started off ahead of $H_1$. (Two or more horses can share the same position for any amount of time; you may consider the horses to be single points.) Horses (other than Annie's) travel at their maximum speeds, except that whenever a horse $H_1$ catches up to another slower horse $H_2$, $H_1$ reduces its speed to match the speed of $H_2$.\n\nAnnie's horse, on the other hand, does not have a maximum speed and can travel at any speed that Annie chooses, as long as it does not pass another horse. To ensure a smooth ride for her and her horse, Annie wants to choose a single constant \"cruise control\" speed for her horse for the entire trip, from her current position to the destination, such that her horse will not pass any other horses. What is the maximum such speed that she can choose?", "inputFormat": "The first line of the input gives the number of test cases, $T$; $T$ test cases follow. Each test case begins with two integers $D$ and $N$: the destination position of all of the horses (in kilometers) and the number of other horses on the road. Then, $N$ lines follow. The $i$-th of those lines has two integers $K_i$ and $S_i$: the initial position (in kilometers) and maximum speed (in kilometers per hour) of the $i$-th of the other horses on the road.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum constant speed (in kilometers per hour) that Annie can use without colliding with other horses. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn Sample Case #1, there is one other (very slow!) horse on the road; it will reach Annie's destination after $25$ hours. Anything faster than $101$ kilometers per hour would cause Annie to pass the horse before reaching the destination.\n\nIn Sample Case #2, there are two other horses on the road. The faster horse will catch up to the slower horse at kilometer $240$ after $2$ hours. Both horses will then go at the slower horse's speed for $1$ more hour, until the horses reach Annie's destination at kilometer 300. The maximum speed that Annie can choose without passing another horse is $100$ kilometers per hour.\n\n**Sample Explanation**\n\n- $1 \\leq T \\leq 100$.\n- $0 < K_i < D \\leq 10^9$, for all $i$.\n- $K_i \\neq K_j$, for all $i \\neq j$. (No two horses start in the same position.)\n- $1 \\leq S_i \\leq 10000$.\n\n**Small Dataset (11 Pts, Test set 1 - Visible)**\n\n- $1 \\leq N \\leq 2$.\n\n**Large Dataset (14 Pts, Test set 2 - Hidden)**\n\n- $1 \\leq N \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1B] Steed 2: Cruise Control", "background": null, "description": "Annie 是一名公交车司机，工作压力很大。她曾尝试通过加勒比海邮轮来放松自己，但那次旅行同样让她感到压力重重，于是她最近开始学习骑马。\n\n今天，Annie 正骑着她的马沿着一条狭长的单向公路向东行进。她现在位于公路的 $0$ 公里处，目的地在 $D$ 公里处；公路上的公里数从西到东依次编号。\n\n在这条路上，还有 $N$ 匹其他马同样向东行进；它们都会一直前进下去，并且目前都位于 Annie 的马和她的目的地之间。第 $i$ 匹马当前位于 $K_i$ 公里处，并以其最大速度 $S_i$ 公里每小时行进。\n\n马非常有礼貌，一匹马 $H_1$ 不会超过（即不会跑到前面去）另一匹起始位置在 $H_1$ 前面的马 $H_2$。（多匹马可以在任意时刻处于同一位置；你可以将马视为一个点。）除 Annie 的马以外，其他马都以最大速度行进，除非某匹马 $H_1$ 追上了另一匹更慢的马 $H_2$，此时 $H_1$ 会减速至 $H_2$ 的速度。\n\n而 Annie 的马没有最大速度限制，她可以选择任意速度，只要不超过其他马。为了让自己和马都能顺利前行，Annie 想为她的马选择一个全程恒定的“巡航速度”，使得她的马在从当前位置到目的地的整个过程中都不会超过其他马。请问她能选择的最大速度是多少？", "inputFormat": "输入的第一行为测试用例数 $T$；接下来有 $T$ 组测试数据。每组测试数据的第一行为两个整数 $D$ 和 $N$，分别表示所有马的目的地位置（单位：公里）和道路上的其他马的数量。接下来的 $N$ 行，每行包含两个整数 $K_i$ 和 $S_i$，分别表示第 $i$ 匹其他马的初始位置（单位：公里）和最大速度（单位：公里每小时）。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是 Annie 能选择的不超过其他马的最大恒定速度（单位：公里每小时）。如果 $y$ 的绝对误差或相对误差在 $10^{-6}$ 以内，则视为正确。", "hint": "**样例解释**\n\n在样例 1 中，只有一匹（非常慢的）马在路上；它到达 Annie 目的地需要 $25$ 小时。Annie 选择的速度只要不超过 $101$ 公里每小时，就不会在到达目的地前超过这匹马。\n\n在样例 2 中，有两匹马在路上。较快的马会在 $2$ 小时后于 $240$ 公里处追上较慢的马。此后，两匹马会以较慢马的速度再行进 $1$ 小时，直到到达 $300$ 公里处的目的地。Annie 能选择的最大速度是 $100$ 公里每小时。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $0 < K_i < D \\leq 10^9$，对所有 $i$。\n- $K_i \\neq K_j$，对所有 $i \\neq j$。（没有两匹马起始位置相同。）\n- $1 \\leq S_i \\leq 10000$。\n\n**小数据范围（11 分，测试点 1 - 可见）**\n\n- $1 \\leq N \\leq 2$。\n\n**大数据范围（14 分，测试点 2 - 隐藏）**\n\n- $1 \\leq N \\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13166", "type": "P", "difficulty": 5, "samples": [["4\n6 2 0 2 0 2 0\n3 1 0 2 0 0 0\n6 2 0 1 1 2 0\n4 0 0 2 0 0 2", "Case #1: RYBRBY\nCase #2: IMPOSSIBLE\nCase #3: YBRGRB\nCase #4: YVYV"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "2017", "Special Judge", "Google Code Jam"], "title": "[GCJ 2017 #1B] Stable Neigh-bors", "background": "", "description": "You are lucky enough to own $N$ pet unicorns. Each of your unicorns has either one or two of the following kinds of hairs in its mane: red hairs, yellow hairs, and blue hairs. The color of a mane depends on exactly which sorts of colored hairs it contains:\n\n- A mane with only one color of hair appears to be that color. For example, a mane with only blue hairs is blue.\n- A mane with red and yellow hairs appears orange.\n- A mane with yellow and blue hairs appears green.\n- A mane with red and blue hairs appears violet.\n\nYou have $R$, $O$, $Y$, $G$, $B$, and $V$ unicorns with red, orange, yellow, green, blue, and violet manes, respectively.\n\nYou have just built a circular stable with $N$ stalls, arranged in a ring such that each stall borders two other stalls. You would like to put exactly one of your unicorns in each of these stalls. However, unicorns need to feel rare and special, so no unicorn can be next to another unicorn that shares at least one of the hair colors in its mane. For example, a unicorn with an orange mane cannot be next to a unicorn with a violet mane, since both of those manes have red hairs. Similarly, a unicorn with a green mane cannot be next to a unicorn with a yellow mane, since both of those have yellow hairs.\n\nIs it possible to place all of your unicorns? If so, provide any one arrangement.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line with seven integers: $N$, $R$, $O$, $Y$, $G$, $B$, and $V$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `IMPOSSIBLE` if it is not possible to place all the unicorns, or a string of $N$ characters representing the placements of unicorns in stalls, starting at a point of your choice and reading clockwise around the circle. Use `R` to represent each unicorn with a red mane, `O` to represent each unicorn with an orange mane, and so on with `Y`, `G`, `B`, and `V`. This arrangement must obey the rules described in the statement above.\n\nIf multiple arrangements are possible, you may print any of them.", "hint": "**Sample Explanation**\n\nNote that the last two sample cases would not appear in the Small dataset.\n\nFor sample case #1, there are many possible answers; for example, another is BYBRYR. Note that BYRYRB would not be a valid answer; remember that the stalls form a ring, and the first touches the last!\n\nIn sample case #2, there are only three stalls, and each stall is a neighbor of the other two, so the two unicorns with yellow manes would have to be neighbors, which is not allowed.\n\nFor sample case #3, note that arranging the unicorns in the same color pattern as the Google logo (BRYBGR) would not be valid, since a unicorn with a blue mane would be a neighbor of a unicorn with a green mane, and both of those manes share blue hairs.\n\nIn sample case #4, no two unicorns with yellow manes can be neighbors, and no two unicorns with violet manes can be neighbors.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $3 \\leq N \\leq 1000$.\n- $R + O + Y + G + B + V = N$.\n- $0 \\leq Z$ for each $Z$ in $\\{R, O, Y, G, B, V\\}$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- $O = G = V = 0$. (Each unicorn has only one hair color in its mane.)\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- No restrictions beyond the general limits. (Each unicorn may have either one or two hair colors in its mane.)", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1B] Stable Neigh-bors", "background": "", "description": "You are lucky enough to own $N$ pet unicorns. Each of your unicorns has either one or two of the following kinds of hairs in its mane: red hairs, yellow hairs, and blue hairs. The color of a mane depends on exactly which sorts of colored hairs it contains:\n\n- A mane with only one color of hair appears to be that color. For example, a mane with only blue hairs is blue.\n- A mane with red and yellow hairs appears orange.\n- A mane with yellow and blue hairs appears green.\n- A mane with red and blue hairs appears violet.\n\nYou have $R$, $O$, $Y$, $G$, $B$, and $V$ unicorns with red, orange, yellow, green, blue, and violet manes, respectively.\n\nYou have just built a circular stable with $N$ stalls, arranged in a ring such that each stall borders two other stalls. You would like to put exactly one of your unicorns in each of these stalls. However, unicorns need to feel rare and special, so no unicorn can be next to another unicorn that shares at least one of the hair colors in its mane. For example, a unicorn with an orange mane cannot be next to a unicorn with a violet mane, since both of those manes have red hairs. Similarly, a unicorn with a green mane cannot be next to a unicorn with a yellow mane, since both of those have yellow hairs.\n\nIs it possible to place all of your unicorns? If so, provide any one arrangement.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each consists of one line with seven integers: $N$, $R$, $O$, $Y$, $G$, $B$, and $V$.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is `IMPOSSIBLE` if it is not possible to place all the unicorns, or a string of $N$ characters representing the placements of unicorns in stalls, starting at a point of your choice and reading clockwise around the circle. Use `R` to represent each unicorn with a red mane, `O` to represent each unicorn with an orange mane, and so on with `Y`, `G`, `B`, and `V`. This arrangement must obey the rules described in the statement above.\n\nIf multiple arrangements are possible, you may print any of them.", "hint": "**Sample Explanation**\n\nNote that the last two sample cases would not appear in the Small dataset.\n\nFor sample case #1, there are many possible answers; for example, another is BYBRYR. Note that BYRYRB would not be a valid answer; remember that the stalls form a ring, and the first touches the last!\n\nIn sample case #2, there are only three stalls, and each stall is a neighbor of the other two, so the two unicorns with yellow manes would have to be neighbors, which is not allowed.\n\nFor sample case #3, note that arranging the unicorns in the same color pattern as the Google logo (BRYBGR) would not be valid, since a unicorn with a blue mane would be a neighbor of a unicorn with a green mane, and both of those manes share blue hairs.\n\nIn sample case #4, no two unicorns with yellow manes can be neighbors, and no two unicorns with violet manes can be neighbors.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $3 \\leq N \\leq 1000$.\n- $R + O + Y + G + B + V = N$.\n- $0 \\leq Z$ for each $Z$ in $\\{R, O, Y, G, B, V\\}$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- $O = G = V = 0$. (Each unicorn has only one hair color in its mane.)\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- No restrictions beyond the general limits. (Each unicorn may have either one or two hair colors in its mane.)", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1B] Stable Neigh-bors", "background": null, "description": "你非常幸运地拥有 $N$ 只独角兽。每只独角兽的鬃毛中只包含以下三种颜色中的一种或两种：红色、黄色和蓝色。鬃毛的颜色取决于它包含的具体颜色种类：\n\n- 只有一种颜色的鬃毛，看起来就是那种颜色。例如，只有蓝色鬃毛的鬃毛就是蓝色。\n- 同时有红色和黄色鬃毛的鬃毛看起来是橙色。\n- 同时有黄色和蓝色鬃毛的鬃毛看起来是绿色。\n- 同时有红色和蓝色鬃毛的鬃毛看起来是紫色。\n\n你拥有 $R$、$O$、$Y$、$G$、$B$ 和 $V$ 只鬃毛分别为红色、橙色、黄色、绿色、蓝色和紫色的独角兽。\n\n你刚刚建造了一个有 $N$ 个马厩的圆形马圈，这些马厩首尾相连，每个马厩都与两个其他马厩相邻。你希望将每只独角兽恰好放入一个马厩中。然而，独角兽需要感到稀有和特别，因此，任何两只鬃毛中包含至少一种相同颜色的独角兽都不能相邻。例如，鬃毛为橙色的独角兽不能与鬃毛为紫色的独角兽相邻，因为它们的鬃毛都含有红色。同理，鬃毛为绿色的独角兽不能与鬃毛为黄色的独角兽相邻，因为它们的鬃毛都含有黄色。\n\n你能否将所有独角兽都安置好？如果可以，请给出任意一种可行的安排。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据，每组数据为一行，包含七个整数：$N$、$R$、$O$、$Y$、$G$、$B$ 和 $V$。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为 `IMPOSSIBLE`（如果无法安排所有独角兽），或者为一个长度为 $N$ 的字符串，表示独角兽在马厩中的排列顺序，从任意一个马厩开始，顺时针排列。用 `R` 表示红色鬃毛的独角兽，`O` 表示橙色，`Y` 表示黄色，`G` 表示绿色，`B` 表示蓝色，`V` 表示紫色。该排列必须满足题目描述中的所有规则。\n\n如果存在多种可行的排列方式，你可以输出任意一种。", "hint": "**样例解释**\n\n注意，最后两个样例不会出现在 Small 数据集中。\n\n对于样例 1，有多种可行答案；例如，BYBRYR 也是一种可行解。注意，BYRYRB 并不是有效答案，因为马厩是环形的，第一个和最后一个马厩也是相邻的！\n\n对于样例 2，只有三个马厩，每个马厩都与其他两个相邻，因此两只黄色鬃毛的独角兽必须相邻，这是不允许的。\n\n对于样例 3，注意如果按照 Google logo 的颜色顺序（BRYBGR）排列独角兽，并不是有效答案，因为蓝色鬃毛的独角兽会与绿色鬃毛的独角兽相邻，而它们的鬃毛都含有蓝色。\n\n对于样例 4，不能有两只黄色鬃毛的独角兽相邻，也不能有两只紫色鬃毛的独角兽相邻。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $3 \\leq N \\leq 1000$。\n- $R + O + Y + G + B + V = N$。\n- 对于每个 $Z \\in \\{R, O, Y, G, B, V\\}$，$0 \\leq Z$。\n\n**Small 数据集（测试集 1 - 可见）**\n\n- $O = G = V = 0$。（每只独角兽的鬃毛只包含一种颜色。）\n\n**Large 数据集（测试集 2 - 隐藏）**\n\n- 除一般限制外无其他限制。（每只独角兽的鬃毛可能包含一种或两种颜色。）\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13167", "type": "P", "difficulty": 4, "samples": [["3\n3 1\n2 3\n2 4\n4 4\n-1 1 -1\n-1 -1 1\n-1 -1 -1\n1 3\n4 1\n13 10\n1 1000\n10 8\n5 5\n-1 1 -1 -1\n-1 -1 1 -1\n-1 -1 -1 10\n-1 -1 -1 -1\n1 4\n4 3\n30 60\n10 1000\n12 5\n20 1\n-1 10 -1 31\n10 -1 10 -1\n-1 -1 -1 10\n15 6 -1 -1\n2 4\n3 1\n3 2", "Case #1: 0.583333333\nCase #2: 1.2\nCase #3: 0.51 8.01 8.0"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["2017", "Special Judge", "最短路", "Google Code Jam"], "title": "[GCJ 2017 #1B] Pony Express", "background": "", "description": "It's the year 1860, and the Pony Express is the fastest mail delivery system joining the East and West coasts of the United States. This system serves $N$ different cities. In each city, there is one horse (as in the expression \"one-horse town\"); each horse travels at a certain constant speed and has a maximum total distance it can travel before it becomes too tired to continue.\n\nThe Pony Express rider starts off on the starting city's horse. Every time the rider reaches a city, they may continue to use their current horse or switch to that city's horse; switching is instantaneous. Horses never get a chance to rest, so whenever part of a horse's maximum total distance is \"used up\", it is used up forever! When the rider reaches the destination city, the mail is delivered.\n\nThe routes between cities were established via complicated negotiations between company owners, lawmakers, union delegates, and cousin Pete. That means that the distances between cities do not necessarily follow common sense: for instance, they do not necessarily comply with the triangle inequality, and the distance from city A to city B might be different from the distance from city B to city A!\n\nYou are a time traveling entrepreneur, and you have brought a fast computer from the future. A single computer is not enough for you to set up an e-mail service and make the Pony Express obsolete, but you can use it to make optimal routing plans for the Pony Express. Given all data about routes between cities and the horses in each city, and a list of pairs of starting and ending cities, can you quickly calculate the minimum time necessary for each delivery? (You should treat all of these deliveries as independent; using cities/horses on one route does not make them unavailable on other routes.)\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case is described as follows:\n\n- One line with two integers: $N$, the number of cities with horses, and $Q$, the number of pairs of stops we are interested in. Cities are numbered from 1 to $N$.\n- $N$ lines, each containing two integers $E_i$, the maximum total distance, in kilometers, the horse in the i-th city can go and $S_i$, the constant speed, in kilometers per hour, at which the horse travels.\n- $N$ lines, each containing $N$ integers. The j-th integer on the i-th of these lines, $D_{ij}$, is -1 if there is no direct route from the i-th to the j-th city, and the length of that route in kilometers otherwise.\n- $Q$ lines containing two integers $U_k$ and $V_k$, the starting and destination point, respectively, of the k-th pair of cities we want to investigate.", "outputFormat": "For each test case, output one line containing `Case #x: y_1 y_2 ... y_Q`, where $x$ is the test case number (starting from 1) and $y_k$ is the minimum time, in hours, to deliver a letter from city $U_k$ to city $V_k$.\n\nEach $y_k$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in the Small dataset.\n\nIn Case #1 there are two options: use the horse in city 1 for the entire trip, or change horses in city 2. Both horses have enough endurance, so both options are viable. Since the horse in city 2 is faster, it is better to change, for a total time of $1/3 + 1/4$.\n\nIn Case #2 there are two intermediate cities in which you can change horses. If you change horses in city 2, however, your new horse, while blazingly fast, will not have enough endurance, so you will be forced to change again in city 3. If you keep your horse, you will have the option to change horses (or not) in city 3. So, the three options, with their total times, are:\n\n1. Change horses in both city 2 and 3 ($1/10 + 1/1000 + 10/8 = 1.351$).\n2. Change horses just in city 3 ($2/10 + 10/8 = 1.45$).\n3. Never change horses ($12/10 = 1.2$).\n\nIn Case #3, there are lots of alternatives for each delivery. The optimal one for the first delivery (city 2 to city 4) is to go to city 1 in time $10/1000$, change horses, and then go to cities 2, 3 and 4, in that order, using the horse from city 1, which takes time $(10 + 10 + 10) / 60$.\n\nFor the second delivery (city 3 to city 2) you have no choice but to first go to city 4 which takes time $10/5$. Your relatively fast horse does not have enough endurance to get anywhere else, so you need to grab the horse in city 4. You could use it to get directly to city 1 in time 15, but that would be slower than riding it to city 2 in time 6 and then using the blazingly fast horse in city 2 to get to city 1 in just $10/1000$ extra time.\n\nIn the third delivery (city 3 to city 1) of Case #3 it is optimal to use the first two steps of the previous one, for a total time of $10/5 + 6 = 8$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq 100$.\n- $1 \\leq E_i \\leq 10^9$, for all $i$.\n- $1 \\leq S_i \\leq 1000$, for all $i$.\n- $-1 \\leq D_{ij} \\leq 10^9$, for all $i, j$.\n- $D_{ii} = -1$, for all $i$. (There are no direct routes from a city to itself.)\n- $D_{ij} \\neq 0$, for all $i, j$.\n- $U_k \\neq V_k$, for all $k$.\n- It is guaranteed that the delivery from $U_k$ to $V_k$ can be accomplished with the given horses, for all $k$.\n- $U_l \\neq U_m$ and/or $V_l \\neq V_m$, for all different $l, m$. (No ordered pair of cities to investigate is repeated within a test case.)\n\n**Small dataset (16 Pts, Test Set 1 - Visible)**\n\n- $D_{ij} = -1$, for all $i, j$ where $i + 1 \\neq j$. (The cities are in a single line; each route goes from one city to the next city in line.)\n- $Q = 1$.\n- $U_1 = 1$.\n- $V_1 = N$. (The only delivery to calculate is between the first and last cities in the line).\n\n**Large dataset (24 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq Q \\leq 100$.\n- $1 \\leq U_k \\leq N$, for all $k$.\n- $1 \\leq V_k \\leq N$, for all $k$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1B] Pony Express", "background": "", "description": "It's the year 1860, and the Pony Express is the fastest mail delivery system joining the East and West coasts of the United States. This system serves $N$ different cities. In each city, there is one horse (as in the expression \"one-horse town\"); each horse travels at a certain constant speed and has a maximum total distance it can travel before it becomes too tired to continue.\n\nThe Pony Express rider starts off on the starting city's horse. Every time the rider reaches a city, they may continue to use their current horse or switch to that city's horse; switching is instantaneous. Horses never get a chance to rest, so whenever part of a horse's maximum total distance is \"used up\", it is used up forever! When the rider reaches the destination city, the mail is delivered.\n\nThe routes between cities were established via complicated negotiations between company owners, lawmakers, union delegates, and cousin Pete. That means that the distances between cities do not necessarily follow common sense: for instance, they do not necessarily comply with the triangle inequality, and the distance from city A to city B might be different from the distance from city B to city A!\n\nYou are a time traveling entrepreneur, and you have brought a fast computer from the future. A single computer is not enough for you to set up an e-mail service and make the Pony Express obsolete, but you can use it to make optimal routing plans for the Pony Express. Given all data about routes between cities and the horses in each city, and a list of pairs of starting and ending cities, can you quickly calculate the minimum time necessary for each delivery? (You should treat all of these deliveries as independent; using cities/horses on one route does not make them unavailable on other routes.)\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case is described as follows:\n\n- One line with two integers: $N$, the number of cities with horses, and $Q$, the number of pairs of stops we are interested in. Cities are numbered from 1 to $N$.\n- $N$ lines, each containing two integers $E_i$, the maximum total distance, in kilometers, the horse in the i-th city can go and $S_i$, the constant speed, in kilometers per hour, at which the horse travels.\n- $N$ lines, each containing $N$ integers. The j-th integer on the i-th of these lines, $D_{ij}$, is -1 if there is no direct route from the i-th to the j-th city, and the length of that route in kilometers otherwise.\n- $Q$ lines containing two integers $U_k$ and $V_k$, the starting and destination point, respectively, of the k-th pair of cities we want to investigate.", "outputFormat": "For each test case, output one line containing `Case #x: y_1 y_2 ... y_Q`, where $x$ is the test case number (starting from 1) and $y_k$ is the minimum time, in hours, to deliver a letter from city $U_k$ to city $V_k$.\n\nEach $y_k$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nNote that the last sample case would not appear in the Small dataset.\n\nIn Case #1 there are two options: use the horse in city 1 for the entire trip, or change horses in city 2. Both horses have enough endurance, so both options are viable. Since the horse in city 2 is faster, it is better to change, for a total time of $1/3 + 1/4$.\n\nIn Case #2 there are two intermediate cities in which you can change horses. If you change horses in city 2, however, your new horse, while blazingly fast, will not have enough endurance, so you will be forced to change again in city 3. If you keep your horse, you will have the option to change horses (or not) in city 3. So, the three options, with their total times, are:\n\n1. Change horses in both city 2 and 3 ($1/10 + 1/1000 + 10/8 = 1.351$).\n2. Change horses just in city 3 ($2/10 + 10/8 = 1.45$).\n3. Never change horses ($12/10 = 1.2$).\n\nIn Case #3, there are lots of alternatives for each delivery. The optimal one for the first delivery (city 2 to city 4) is to go to city 1 in time $10/1000$, change horses, and then go to cities 2, 3 and 4, in that order, using the horse from city 1, which takes time $(10 + 10 + 10) / 60$.\n\nFor the second delivery (city 3 to city 2) you have no choice but to first go to city 4 which takes time $10/5$. Your relatively fast horse does not have enough endurance to get anywhere else, so you need to grab the horse in city 4. You could use it to get directly to city 1 in time 15, but that would be slower than riding it to city 2 in time 6 and then using the blazingly fast horse in city 2 to get to city 1 in just $10/1000$ extra time.\n\nIn the third delivery (city 3 to city 1) of Case #3 it is optimal to use the first two steps of the previous one, for a total time of $10/5 + 6 = 8$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq 100$.\n- $1 \\leq E_i \\leq 10^9$, for all $i$.\n- $1 \\leq S_i \\leq 1000$, for all $i$.\n- $-1 \\leq D_{ij} \\leq 10^9$, for all $i, j$.\n- $D_{ii} = -1$, for all $i$. (There are no direct routes from a city to itself.)\n- $D_{ij} \\neq 0$, for all $i, j$.\n- $U_k \\neq V_k$, for all $k$.\n- It is guaranteed that the delivery from $U_k$ to $V_k$ can be accomplished with the given horses, for all $k$.\n- $U_l \\neq U_m$ and/or $V_l \\neq V_m$, for all different $l, m$. (No ordered pair of cities to investigate is repeated within a test case.)\n\n**Small dataset (16 Pts, Test Set 1 - Visible)**\n\n- $D_{ij} = -1$, for all $i, j$ where $i + 1 \\neq j$. (The cities are in a single line; each route goes from one city to the next city in line.)\n- $Q = 1$.\n- $U_1 = 1$.\n- $V_1 = N$. (The only delivery to calculate is between the first and last cities in the line).\n\n**Large dataset (24 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq Q \\leq 100$.\n- $1 \\leq U_k \\leq N$, for all $k$.\n- $1 \\leq V_k \\leq N$, for all $k$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1B] Pony Express", "background": null, "description": "现在是 1860 年，Pony Express 是连接美国东西海岸最快的邮件递送系统。该系统服务于 $N$ 个不同的城市。每个城市都有一匹马（正如“一马小镇”这个说法）；每匹马都有一个恒定的速度，并且有一个最大总行驶距离，超过这个距离马就会太累无法继续前进。\n\nPony Express 的骑手会骑上起始城市的马出发。每当骑手到达一个城市时，可以选择继续使用当前的马，或者换乘该城市的马；换马是瞬间完成的。马匹永远没有休息的机会，因此一旦马的最大总距离被“消耗”了一部分，这部分就永远无法恢复！当骑手到达目的地城市时，邮件就被送达。\n\n城市之间的路线是通过公司老板、立法者、工会代表和表哥 Pete 的复杂协商建立的。这意味着城市之间的距离不一定符合常理：例如，它们不一定满足三角不等式，从城市 A 到城市 B 的距离可能与从城市 B 到城市 A 的距离不同！\n\n你是一位穿越时空的企业家，带来了一台来自未来的高速计算机。虽然一台计算机还不足以让你建立电子邮件服务从而让 Pony Express 过时，但你可以用它为 Pony Express 制定最优的路线规划。给定所有城市间路线和每个城市马匹的信息，以及一系列起点和终点城市对，你能否快速计算出每次递送所需的最短时间？（你应将所有递送视为独立事件；在一条路线中使用的城市/马匹不会影响其他路线的可用性。）", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据描述如下：\n\n- 一行包含两个整数：$N$，表示有马的城市数量，$Q$，表示需要查询的起止城市对数量。城市编号为 $1$ 到 $N$。\n- 接下来 $N$ 行，每行包含两个整数 $E_i$ 和 $S_i$，分别表示第 $i$ 个城市的马的最大总行驶距离（单位：千米）和恒定速度（单位：千米/小时）。\n- 接下来 $N$ 行，每行包含 $N$ 个整数。第 $i$ 行第 $j$ 个整数 $D_{ij}$，若 $D_{ij} = -1$，表示没有从第 $i$ 个城市到第 $j$ 个城市的直达路线，否则表示该路线的长度（单位：千米）。\n- 接下来 $Q$ 行，每行包含两个整数 $U_k$ 和 $V_k$，分别表示第 $k$ 个需要查询的起点和终点城市。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y_1 y_2 ... y_Q`，其中 $x$ 表示测试用例编号（从 1 开始），$y_k$ 表示从城市 $U_k$ 到城市 $V_k$ 递送邮件所需的最短时间（单位：小时）。\n\n每个 $y_k$ 的答案只要在绝对误差或相对误差 $10^{-6}$ 以内都视为正确。", "hint": "**样例说明**\n\n注意，最后一个样例不会出现在 Small 数据集中。\n\n在 Case #1 中有两种选择：全程使用城市 1 的马，或者在城市 2 换马。两匹马的耐力都足够，因此两种方案都可行。由于城市 2 的马更快，所以换马更优，总时间为 $1/3 + 1/4$。\n\n在 Case #2 中，有两个中间城市可以换马。如果你在城市 2 换马，虽然新马速度极快，但耐力不足，因此你必须在城市 3 再次换马。如果你不换马，则可以选择在城市 3 换马（或不换）。三种方案及其总时间如下：\n\n1. 在城市 2 和 3 都换马（$1/10 + 1/1000 + 10/8 = 1.351$）。\n2. 只在城市 3 换马（$2/10 + 10/8 = 1.45$）。\n3. 全程不换马（$12/10 = 1.2$）。\n\n在 Case #3 中，每次递送都有许多选择。对于第一次递送（城市 2 到城市 4），最优方案是先到城市 1，耗时 $10/1000$，换马后再依次到城市 2、3、4，使用城市 1 的马，总耗时为 $(10 + 10 + 10) / 60$。\n\n对于 Case #3 的第二次递送（城市 3 到城市 2），你只能先到城市 4，耗时 $10/5$。你的马虽然速度快，但耐力不足以到其他地方，因此你需要换乘城市 4 的马。你可以直接骑它到城市 1，耗时 15，但骑到城市 2 只需 6，然后再用城市 2 的极速马到城市 1，仅需额外 $10/1000$ 时间。\n\n对于 Case #3 的第三次递送（城市 3 到城市 1），最优方案是复用上一次的前两步，总耗时 $10/5 + 6 = 8$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq N \\leq 100$。\n- $1 \\leq E_i \\leq 10^9$，对于所有 $i$。\n- $1 \\leq S_i \\leq 1000$，对于所有 $i$。\n- $-1 \\leq D_{ij} \\leq 10^9$，对于所有 $i, j$。\n- $D_{ii} = -1$，对于所有 $i$。（不存在城市到自身的直达路线。）\n- $D_{ij} \\neq 0$，对于所有 $i, j$。\n- $U_k \\neq V_k$，对于所有 $k$。\n- 保证对于所有 $k$，从 $U_k$ 到 $V_k$ 的递送一定可以完成。\n- 对于任意不同的 $l, m$，有 $U_l \\neq U_m$ 和/或 $V_l \\neq V_m$。（每组测试数据中不会有重复的城市对。）\n\n**Small 数据集（16 分，测试集 1 - 可见）**\n\n- 对于所有 $i, j$，若 $i + 1 \\neq j$，则 $D_{ij} = -1$。（城市排成一条直线，每条路线只连接相邻城市。）\n- $Q = 1$。\n- $U_1 = 1$。\n- $V_1 = N$。（唯一需要计算的递送是从第一座城市到最后一座城市。）\n\n**Large 数据集（24 分，测试集 2 - 隐藏）**\n\n- $1 \\leq Q \\leq 100$。\n- $1 \\leq U_k \\leq N$，对于所有 $k$。\n- $1 \\leq V_k \\leq N$，对于所有 $k$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13168", "type": "P", "difficulty": 3, "samples": [["4\n2 1\n100 20\n200 10\n2 2\n100 20\n200 10\n3 2\n100 10\n100 10\n100 10\n4 2\n9 3\n7 1\n10 1\n8 4", "Case #1: 138230.076757951\nCase #2: 150796.447372310\nCase #3: 43982.297150257\nCase #4: 625.176938064"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["2017", "堆", "Special Judge", "排序", "Google Code Jam"], "title": "[GCJ 2017 #1C] Ample Syrup", "background": "", "description": "The kitchen at the Infinite House of Pancakes has just received an order for a stack of $K$ pancakes! The chef currently has $N$ pancakes available, where $N \\geq K$. Each pancake is a cylinder, and different pancakes may have different radii and heights.\n\nAs the sous-chef, you must choose $K$ out of the $N$ available pancakes, discard the others, and arrange those $K$ pancakes in a stack on a plate as follows. First, take the pancake that has the largest radius, and lay it on the plate on one of its circular faces. (If multiple pancakes have the same radius, you can use any of them.) Then, take the remaining pancake with the next largest radius and lay it on top of that pancake, and so on, until all $K$ pancakes are in the stack and the centers of the circular faces are aligned in a line perpendicular to the plate, as illustrated by this example:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/57lkgshp.png)\n\nYou know that there is only one thing your diners love as much as they love pancakes: syrup! It is best to maximize the total amount of exposed pancake surface area in the stack, since more exposed pancake surface area means more places to pour on delicious syrup. Any part of a pancake that is not touching part of another pancake or the plate is considered to be exposed.\n\nIf you choose the $K$ pancakes optimally, what is the largest total exposed pancake surface area you can achieve?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with two integers $N$ and $K$: the total number of available pancakes, and the size of the stack that the diner has ordered. Then, $N$ more lines follow. Each contains two integers $R_i$ and $H_i$: the radius and height of the $i$-th pancake, in millimeters.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum possible total exposed pancake surface area, in millimeters squared. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn sample case #1, the \"stack\" consists only of one pancake. A stack of just the first pancake would have an exposed area of $\\pi \\times R_0^2 + 2 \\times \\pi \\times R_0 \\times H_0 = 14000\\pi \\text{ mm}^2$. A stack of just the second pancake would have an exposed area of $44000\\pi \\text{ mm}^2$. So it is better to use the second pancake.\n\nIn sample case #2, we can use both of the same pancakes from case #1. The first pancake contributes its top area and its side, for a total of $14000\\pi \\text{ mm}^2$. The second pancake contributes some of its top area (the part not covered by the first pancake) and its side, for a total of $34000\\pi \\text{ mm}^2$. The combined exposed surface area is $48000\\pi \\text{ mm}^2$.\n\nIn sample case #3, all of the pancakes have radius 100 and height 10. If we stack two of these together, we effectively have a single new cylinder of radius 100 and height 20. The exposed surface area is $14000\\pi \\text{ mm}^2$.\n\nIn sample case #4, the optimal stack uses the pancakes with radii of 8 and 9.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq K \\leq N$.\n- $1 \\leq R_i \\leq 10^6$, for all $i$.\n- $1 \\leq H_i \\leq 10^6$, for all $i$.\n\n**Small dataset (9 Pts, Test Set 1 - Visible)**\n\n- $1 \\leq N \\leq 10$.\n\n**Large dataset (16 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq N \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1C] Ample Syrup", "background": "", "description": "The kitchen at the Infinite House of Pancakes has just received an order for a stack of $K$ pancakes! The chef currently has $N$ pancakes available, where $N \\geq K$. Each pancake is a cylinder, and different pancakes may have different radii and heights.\n\nAs the sous-chef, you must choose $K$ out of the $N$ available pancakes, discard the others, and arrange those $K$ pancakes in a stack on a plate as follows. First, take the pancake that has the largest radius, and lay it on the plate on one of its circular faces. (If multiple pancakes have the same radius, you can use any of them.) Then, take the remaining pancake with the next largest radius and lay it on top of that pancake, and so on, until all $K$ pancakes are in the stack and the centers of the circular faces are aligned in a line perpendicular to the plate, as illustrated by this example:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/57lkgshp.png)\n\nYou know that there is only one thing your diners love as much as they love pancakes: syrup! It is best to maximize the total amount of exposed pancake surface area in the stack, since more exposed pancake surface area means more places to pour on delicious syrup. Any part of a pancake that is not touching part of another pancake or the plate is considered to be exposed.\n\nIf you choose the $K$ pancakes optimally, what is the largest total exposed pancake surface area you can achieve?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each begins with one line with two integers $N$ and $K$: the total number of available pancakes, and the size of the stack that the diner has ordered. Then, $N$ more lines follow. Each contains two integers $R_i$ and $H_i$: the radius and height of the $i$-th pancake, in millimeters.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum possible total exposed pancake surface area, in millimeters squared. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nIn sample case #1, the \"stack\" consists only of one pancake. A stack of just the first pancake would have an exposed area of $\\pi \\times R_0^2 + 2 \\times \\pi \\times R_0 \\times H_0 = 14000\\pi \\text{ mm}^2$. A stack of just the second pancake would have an exposed area of $44000\\pi \\text{ mm}^2$. So it is better to use the second pancake.\n\nIn sample case #2, we can use both of the same pancakes from case #1. The first pancake contributes its top area and its side, for a total of $14000\\pi \\text{ mm}^2$. The second pancake contributes some of its top area (the part not covered by the first pancake) and its side, for a total of $34000\\pi \\text{ mm}^2$. The combined exposed surface area is $48000\\pi \\text{ mm}^2$.\n\nIn sample case #3, all of the pancakes have radius 100 and height 10. If we stack two of these together, we effectively have a single new cylinder of radius 100 and height 20. The exposed surface area is $14000\\pi \\text{ mm}^2$.\n\nIn sample case #4, the optimal stack uses the pancakes with radii of 8 and 9.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq K \\leq N$.\n- $1 \\leq R_i \\leq 10^6$, for all $i$.\n- $1 \\leq H_i \\leq 10^6$, for all $i$.\n\n**Small dataset (9 Pts, Test Set 1 - Visible)**\n\n- $1 \\leq N \\leq 10$.\n\n**Large dataset (16 Pts, Test Set 2 - Hidden)**\n\n- $1 \\leq N \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1C] Ample Syrup", "background": null, "description": "无限煎饼屋的厨房刚刚收到了一份包含 $K$ 张煎饼的订单！厨师目前有 $N$ 张煎饼可用，其中 $N \\geq K$。每张煎饼都是一个圆柱体，不同的煎饼可能有不同的半径和高度。\n\n作为副厨师，你需要从这 $N$ 张煎饼中选择 $K$ 张，丢弃其余的煎饼，并将这 $K$ 张煎饼按如下方式叠放在盘子上。首先，取出半径最大的煎饼，将其一面圆形朝下放在盘子上。（如果有多张煎饼半径相同，可以任选其中一张。）然后，取剩下的半径次大的煎饼，叠放在第一张煎饼上，以此类推，直到所有 $K$ 张煎饼都叠好，并且所有圆形面的中心都在一条垂直于盘子的直线上，如下图所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/57lkgshp.png)\n\n你知道，食客们除了喜欢煎饼外，还同样喜欢糖浆！最大化煎饼堆中所有暴露在外的煎饼表面积是最好的，因为暴露的表面积越多，能倒上美味糖浆的地方就越多。任何没有与其他煎饼或盘子接触的煎饼部分都被视为暴露在外。\n\n如果你最优地选择这 $K$ 张煎饼，能获得的最大总暴露煎饼表面积是多少？", "inputFormat": "输入的第一行包含测试用例数 $T$。接下来有 $T$ 组测试用例。每组测试用例的第一行为两个整数 $N$ 和 $K$，分别表示可用煎饼总数和订单所需的煎饼数量。接下来的 $N$ 行，每行包含两个整数 $R_i$ 和 $H_i$，分别表示第 $i$ 张煎饼的半径和高度，单位为毫米。", "outputFormat": "对于每组测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是最大可能的总暴露煎饼表面积，单位为平方毫米。只要 $y$ 的绝对误差或相对误差在 $10^{-6}$ 以内，都视为正确。", "hint": "**样例解释**\n\n在样例 1 中，\"堆叠\" 只包含一张煎饼。只用第一张煎饼时，暴露表面积为 $\\pi \\times R_0^2 + 2 \\times \\pi \\times R_0 \\times H_0 = 14000\\pi \\text{ mm}^2$。只用第二张煎饼时，暴露表面积为 $44000\\pi \\text{ mm}^2$。因此，使用第二张煎饼更优。\n\n在样例 2 中，我们可以使用样例 1 中的两张煎饼。第一张煎饼贡献了顶部面积和侧面积，总共 $14000\\pi \\text{ mm}^2$。第二张煎饼贡献了部分顶部面积（未被第一张煎饼覆盖的部分）和侧面积，总共 $34000\\pi \\text{ mm}^2$。合计暴露表面积为 $48000\\pi \\text{ mm}^2$。\n\n在样例 3 中，所有煎饼的半径均为 100，高度均为 10。如果叠放两张这样的煎饼，实际上就相当于一个半径为 100、高度为 20 的新圆柱体。暴露表面积为 $14000\\pi \\text{ mm}^2$。\n\n在样例 4 中，最优的堆叠方式是选择半径为 8 和 9 的煎饼。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq K \\leq N$。\n- $1 \\leq R_i \\leq 10^6$，对于所有 $i$。\n- $1 \\leq H_i \\leq 10^6$，对于所有 $i$。\n\n**小数据范围（9 分，测试点 1 - 可见）**\n\n- $1 \\leq N \\leq 10$。\n\n**大数据范围（16 分，测试点 2 - 隐藏）**\n\n- $1 \\leq N \\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13169", "type": "P", "difficulty": 4, "samples": [["5\n1 1\n540 600\n840 900\n2 0\n900 1260\n180 540\n1 1\n1439 1440\n0 1\n2 2\n0 1\n1439 1440\n1438 1439\n1 2\n3 4\n0 10\n1420 1440\n90 100\n550 600\n900 950\n100 150\n1050 1400", "Case #1: 2\nCase #2: 4\nCase #3: 2\nCase #4: 4\nCase #5: 6"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2017", "Google Code Jam"], "title": "[GCJ 2017 #1C] Parenting Partnering", "background": "", "description": "Cameron and Jamie are longtime life partners and have recently become parents! Being in charge of a baby, exciting as it is, is not without challenges. Given that both parents have a scientific mind, they have decided to take a scientific approach to baby care.\n\nCameron and Jamie are establishing a daily routine and need to decide who will be the main person in charge of the baby at each given time. They have been equal partners their whole relationship, and they do not want to stop now, so they decided that each of them will be in charge for exactly 12 hours (720 minutes) per day.\n\nCameron and Jamie have other activities that they either need or want to do on their own. Cameron has $A_C$ of these and Jamie has $A_J$. These activities always take place at the same times each day. None of Cameron's activities overlap with Jamie's activities, so at least one of the parents will always be free to take care of the baby.\n\nCameron and Jamie want to come up with a daily baby care schedule such that:\n\n* Scheduled baby time must not interfere with a scheduled activity. That is, during Cameron's activities, Jamie has to be in charge of the baby, and vice versa.\n* Each of Cameron and Jamie must have exactly 720 minutes assigned to them.\n* The number of exchanges — that is, the number of times the person in charge of the baby changes from one partner to the other — must be as small as possible.\n\nFor example, suppose that Jamie and Cameron have a single activity each: Jamie has a morning activity from 9 am to 10 am, and Cameron has an afternoon activity from 2 pm to 3 pm. One possible but suboptimal schedule would be for Jamie to take care of the baby from midnight to 6 am and from noon to 6 pm, and for Cameron to take care of the baby from 6 am to noon and 6 pm to midnight. That fulfills the first two conditions, and requires a total of 4 exchanges, which happen at midnight, 6 am, noon and 6 pm. If there is an exchange happening at midnight, it is counted exactly once, not zero or two times.\n\nA better option would be for Cameron to take care of the baby from midnight to noon, and Jamie to take care of the baby from noon to midnight. This schedule also fulfills the first two conditions, but it uses only 2 exchanges, which is the minimum possible.\n\nGiven Cameron's and Jamie's lists of activities, and the restrictions above, what is the minimum possible number of exchanges in a daily schedule?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line containing two integers $A_C$ and $A_J$, the number of activities that Cameron and Jamie have, respectively. Then, $A_C + A_J$ lines follow. The first $A_C$ of these lines contain two integers $C_i$ and $D_i$ each. The $i$-th of Cameron's activities starts exactly $C_i$ minutes after the start of the day at midnight and ends exactly $D_i$ minutes after the start of the day at midnight (taking exactly $D_i - C_i$ minutes). The last $A_J$ of these lines contain two integers $J_i$ and $K_i$ each, representing the starting and ending time of one of Jamie's activities, in minutes counting from the start of the day at midnight (same format as Cameron's). No activity spans two days, and no two activities overlap (except that one might end exactly as another starts, but an exchange can still occur at that time).", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ the minimum possible number of exchanges, as described in the statement.", "hint": "**Sample Explanation**\n\nNote that Cases #4 and #5 would not appear in the Small dataset.\n\nCase #1 is the one described in the problem statement.\n\nIn Case #2, Jamie must cover for all of Cameron's activity time, and then Cameron must cover all the remaining time. This schedule entails four exchanges.\n\nIn Case #3, there is an exchange at midnight, from Cameron to Jamie. No matter how the parents divide up the remaining $1438$ non-activity minutes of the day, there must be at least one exchange from Jamie to Cameron, and there is no reason to add more exchanges than that.\n\nIn Case #4, note that back-to-back activities can exist for the same partner or different partners. There is no exchange at midnight because Cameron has activities both right before and right after that time. However, the schedule needs to add some time for Cameron in between Jamie's activities, requiring a total of $4$ exchanges. Notice that it is optimal to add a single interval for Cameron of length $718$ somewhere between minutes $2$ and $1438$, but the exact position of that added interval does not impact the number of exchanges, so there are multiple optimal schedules.\n\nIn Case #5, a possible optimal schedule is to assign Cameron to the intervals (in minutes) $100-200$, $500-620$, and $900-1400$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $0 \\leq C_i < D_i \\leq 24 \\times 60$, for all $i$.\n- $0 \\leq J_i < K_i \\leq 24 \\times 60$, for all $i$.\n- Any two of the intervals of $\\{[C_i, D_i)\\}$ for all $i$ union $\\{[J_i, K_i)\\}$ for all $i$ have an empty intersection. (The intervals are closed on the left and open on the right, which ensures that two exactly consecutive intervals have nothing in between but do not overlap.)\n- $\\sum (D_i - C_i)$ for all $i \\leq 720$.\n- $\\sum (K_i - J_i)$ for all $i \\leq 720$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- $0 \\leq A_C \\leq 2$.\n- $0 \\leq A_J \\leq 2$.\n- $1 \\leq A_C + A_J \\leq 2$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- $0 \\leq A_C \\leq 100$.\n- $0 \\leq A_J \\leq 100$.\n- $1 \\leq A_C + A_J \\leq 200$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1C] Parenting Partnering", "background": "", "description": "Cameron and Jamie are longtime life partners and have recently become parents! Being in charge of a baby, exciting as it is, is not without challenges. Given that both parents have a scientific mind, they have decided to take a scientific approach to baby care.\n\nCameron and Jamie are establishing a daily routine and need to decide who will be the main person in charge of the baby at each given time. They have been equal partners their whole relationship, and they do not want to stop now, so they decided that each of them will be in charge for exactly 12 hours (720 minutes) per day.\n\nCameron and Jamie have other activities that they either need or want to do on their own. Cameron has $A_C$ of these and Jamie has $A_J$. These activities always take place at the same times each day. None of Cameron's activities overlap with Jamie's activities, so at least one of the parents will always be free to take care of the baby.\n\nCameron and Jamie want to come up with a daily baby care schedule such that:\n\n* Scheduled baby time must not interfere with a scheduled activity. That is, during Cameron's activities, Jamie has to be in charge of the baby, and vice versa.\n* Each of Cameron and Jamie must have exactly 720 minutes assigned to them.\n* The number of exchanges — that is, the number of times the person in charge of the baby changes from one partner to the other — must be as small as possible.\n\nFor example, suppose that Jamie and Cameron have a single activity each: Jamie has a morning activity from 9 am to 10 am, and Cameron has an afternoon activity from 2 pm to 3 pm. One possible but suboptimal schedule would be for Jamie to take care of the baby from midnight to 6 am and from noon to 6 pm, and for Cameron to take care of the baby from 6 am to noon and 6 pm to midnight. That fulfills the first two conditions, and requires a total of 4 exchanges, which happen at midnight, 6 am, noon and 6 pm. If there is an exchange happening at midnight, it is counted exactly once, not zero or two times.\n\nA better option would be for Cameron to take care of the baby from midnight to noon, and Jamie to take care of the baby from noon to midnight. This schedule also fulfills the first two conditions, but it uses only 2 exchanges, which is the minimum possible.\n\nGiven Cameron's and Jamie's lists of activities, and the restrictions above, what is the minimum possible number of exchanges in a daily schedule?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line containing two integers $A_C$ and $A_J$, the number of activities that Cameron and Jamie have, respectively. Then, $A_C + A_J$ lines follow. The first $A_C$ of these lines contain two integers $C_i$ and $D_i$ each. The $i$-th of Cameron's activities starts exactly $C_i$ minutes after the start of the day at midnight and ends exactly $D_i$ minutes after the start of the day at midnight (taking exactly $D_i - C_i$ minutes). The last $A_J$ of these lines contain two integers $J_i$ and $K_i$ each, representing the starting and ending time of one of Jamie's activities, in minutes counting from the start of the day at midnight (same format as Cameron's). No activity spans two days, and no two activities overlap (except that one might end exactly as another starts, but an exchange can still occur at that time).", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ the minimum possible number of exchanges, as described in the statement.", "hint": "**Sample Explanation**\n\nNote that Cases #4 and #5 would not appear in the Small dataset.\n\nCase #1 is the one described in the problem statement.\n\nIn Case #2, Jamie must cover for all of Cameron's activity time, and then Cameron must cover all the remaining time. This schedule entails four exchanges.\n\nIn Case #3, there is an exchange at midnight, from Cameron to Jamie. No matter how the parents divide up the remaining $1438$ non-activity minutes of the day, there must be at least one exchange from Jamie to Cameron, and there is no reason to add more exchanges than that.\n\nIn Case #4, note that back-to-back activities can exist for the same partner or different partners. There is no exchange at midnight because Cameron has activities both right before and right after that time. However, the schedule needs to add some time for Cameron in between Jamie's activities, requiring a total of $4$ exchanges. Notice that it is optimal to add a single interval for Cameron of length $718$ somewhere between minutes $2$ and $1438$, but the exact position of that added interval does not impact the number of exchanges, so there are multiple optimal schedules.\n\nIn Case #5, a possible optimal schedule is to assign Cameron to the intervals (in minutes) $100-200$, $500-620$, and $900-1400$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $0 \\leq C_i < D_i \\leq 24 \\times 60$, for all $i$.\n- $0 \\leq J_i < K_i \\leq 24 \\times 60$, for all $i$.\n- Any two of the intervals of $\\{[C_i, D_i)\\}$ for all $i$ union $\\{[J_i, K_i)\\}$ for all $i$ have an empty intersection. (The intervals are closed on the left and open on the right, which ensures that two exactly consecutive intervals have nothing in between but do not overlap.)\n- $\\sum (D_i - C_i)$ for all $i \\leq 720$.\n- $\\sum (K_i - J_i)$ for all $i \\leq 720$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- $0 \\leq A_C \\leq 2$.\n- $0 \\leq A_J \\leq 2$.\n- $1 \\leq A_C + A_J \\leq 2$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- $0 \\leq A_C \\leq 100$.\n- $0 \\leq A_J \\leq 100$.\n- $1 \\leq A_C + A_J \\leq 200$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1C] Parenting Partnering", "background": null, "description": "Cameron 和 Jamie 是多年的生活伴侣，最近刚刚成为了父母！照顾婴儿虽然令人兴奋，但也充满挑战。由于两位父母都具有科学思维，他们决定以科学的方法来照顾孩子。\n\nCameron 和 Jamie 正在制定每日作息时间表，需要决定在每天的每个时刻由谁主要负责照看婴儿。他们一直以来都是平等的伴侣，现在也不想改变这一点，因此他们决定每天各自负责照看婴儿恰好 12 小时（720 分钟）。\n\nCameron 和 Jamie 各自还有一些必须或想要独自完成的活动。Cameron 有 $A_C$ 个这样的活动，Jamie 有 $A_J$ 个。这些活动每天都在相同的时间进行。Cameron 的活动与 Jamie 的活动不会重叠，因此至少有一位父母始终可以照看婴儿。\n\nCameron 和 Jamie 想要制定一个每日照看婴儿的时间表，使得：\n\n- 安排的照看时间不能与已安排的活动冲突。也就是说，在 Cameron 有活动时，Jamie 必须负责照看婴儿，反之亦然。\n- Cameron 和 Jamie 每人分配的照看时间必须恰好为 720 分钟。\n- 交接次数——即负责照看婴儿的人从一方变为另一方的次数——要尽可能少。\n\n例如，假设 Jamie 和 Cameron 各有一项活动：Jamie 有一项早上 9 点到 10 点的活动，Cameron 有一项下午 2 点到 3 点的活动。一种可能但非最优的安排是，Jamie 从午夜到早上 6 点以及中午到下午 6 点照看婴儿，Cameron 从早上 6 点到中午以及下午 6 点到午夜照看婴儿。这样满足前两个条件，总共需要 4 次交接，分别发生在午夜、早上 6 点、中午和下午 6 点。如果交接发生在午夜，只计作一次，不计作零次或两次。\n\n更优的方案是 Cameron 从午夜到中午照看婴儿，Jamie 从中午到午夜照看婴儿。这个安排同样满足前两个条件，但只需要 2 次交接，这是最少可能的次数。\n\n给定 Cameron 和 Jamie 的活动列表，以及上述限制，问每日时间表中最少需要多少次交接？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试用例。每组测试用例的第一行为两个整数 $A_C$ 和 $A_J$，分别表示 Cameron 和 Jamie 的活动数。接下来的 $A_C + A_J$ 行，每行包含两个整数。前 $A_C$ 行，每行包含两个整数 $C_i$ 和 $D_i$，表示 Cameron 的第 $i$ 个活动从午夜起第 $C_i$ 分钟开始，到第 $D_i$ 分钟结束（持续 $D_i - C_i$ 分钟）。接下来的 $A_J$ 行，每行包含两个整数 $J_i$ 和 $K_i$，表示 Jamie 的一项活动的开始和结束时间（同样以午夜起的分钟数计）。没有活动跨越两天，且任意两项活动不会重叠（但可能一个活动结束时另一个活动正好开始，此时可以发生交接）。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为最少的交接次数。", "hint": "**样例解释**\n\n注意，样例 #4 和 #5 不会出现在 Small 数据集。\n\n样例 #1 即题目描述中的例子。\n\n在样例 #2 中，Jamie 必须覆盖 Cameron 所有活动的时间，然后 Cameron 覆盖剩余的时间。这个安排需要 4 次交接。\n\n在样例 #3 中，午夜时有一次从 Cameron 到 Jamie 的交接。无论父母如何分配剩余的 $1438$ 分钟非活动时间，至少还需要一次从 Jamie 到 Cameron 的交接，没有理由增加更多交接。\n\n在样例 #4 中，注意同一方或不同方的活动可能连续出现。由于 Cameron 在午夜前后都有活动，因此午夜没有交接。但在 Jamie 的活动之间需要为 Cameron 安排一段时间，总共需要 4 次交接。最优做法是在第 2 分钟到第 1438 分钟之间为 Cameron 安排一段长度为 718 分钟的区间，具体位置不影响交接次数，因此存在多种最优方案。\n\n在样例 #5 中，一种最优方案是将 Cameron 分配到区间（以分钟计）$100-200$、$500-620$ 和 $900-1400$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- 对所有 $i$，$0 \\leq C_i < D_i \\leq 24 \\times 60$。\n- 对所有 $i$，$0 \\leq J_i < K_i \\leq 24 \\times 60$。\n- 所有 $\\{[C_i, D_i)\\}$ 与 $\\{[J_i, K_i)\\}$ 区间两两不重叠（区间左闭右开，确保两个完全连续的区间之间没有重叠，但也没有间隙）。\n- $\\sum (D_i - C_i)$ 对所有 $i$ 不超过 720。\n- $\\sum (K_i - J_i)$ 对所有 $i$ 不超过 720。\n\n**Small 数据集（测试集 1 - 可见）**\n\n- $0 \\leq A_C \\leq 2$。\n- $0 \\leq A_J \\leq 2$。\n- $1 \\leq A_C + A_J \\leq 2$。\n\n**Large 数据集（测试集 2 - 隐藏）**\n\n- $0 \\leq A_C \\leq 100$。\n- $0 \\leq A_J \\leq 100$。\n- $1 \\leq A_C + A_J \\leq 200$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13170", "type": "P", "difficulty": 7, "samples": [["4\n4 4\n1.4000\n0.5000 0.7000 0.8000 0.6000\n2 2\n1.0000\n0.0000 0.0000\n2 1\n0.0000\n0.9000 0.8000\n2 1\n0.1000\n0.4000 0.5000", "Case #1: 1.000000\nCase #2: 0.250000\nCase #3: 0.980000\nCase #4: 0.760000"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2017", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2017 #1C] Core Training", "background": "", "description": "Writing Code Jam problems is hard, so we have built an AI to come up with new ideas. To make the AI as creative as possible, we have given it $N$ different \"cores\", each of which has its own \"personality\". However, just like people, these cores may become distracted or corrupt or may refuse to work; the i-th core has a success probability $P_i$ of functioning properly. As long as at least $K$ of the cores function properly, the AI will function properly. Otherwise, it will probably become evil and trap us in a maze of fiendish puzzles of its own design. And who knows what it might do to Code Jam — it might just write a bunch of tough probability problems!\n\nTo prevent this from happening, we plan to train one or more of the cores to become more reliable. We have a total of $U$ \"training units\" that we can use to improve the cores. Spending $X$ units on the i-th core will add $X$ to its success probability. We can divide up the units among the cores however we like, and it is possible that one or more cores may not receive any units. Of course, a core's success probability cannot be increased above 1.\n\nIf we assign the training units to maximize the probability that the AI will function properly, what is that probability?\n\n~~**Solving this problem**~~\n\n~~This problem has 2 Small datasets and no Large dataset. You must solve the first Small dataset before you can attempt the second Small dataset. You will be able to retry either of the datasets (with a time penalty).~~", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of three lines. The first line contains two integers $N$ and $K$: the total number of cores, and the minimum number of cores that must succeed for the AI to function properly. The second line contains one rational $U$: the number of training units. The third line contains $N$ rational numbers $P_i$; the i-th of these gives the probability that the i-th core will function properly. All of these probabilities are specified to exactly four decimal places of precision.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the probability that the AI will function properly if the training units are assigned optimally. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nNote that the last two sample cases would not appear in Small dataset 1.\n\nIn Sample Case #1, we have enough training units to spend to give all cores a success probability of 1, so the AI will certainly function properly.\n\nIn Sample Case #2, both of the cores must function properly for the AI to function properly, so we must give each core at least some training units. The best option turns out to be to train each one up to $0.5$. Then the probability that the AI functions properly is $0.5 \\times 0.5 = 0.25$. Any other assignment is inferior; for instance, if we train one core to $0.9$ and the other core to $0.1$, the probability of success is only $0.9 \\times 0.1 = 0.09$.\n\nIn Sample Case #3, we have no training units to spend, and at least one of the two cores must function properly for the AI to function properly. We can approach this by first calculating the probability that the AI does not function properly, which happens only if both cores fail to function properly. The probability that both cores fail is $(1 - 0.9) \\times (1 - 0.8) = 0.02$. So the probability that at least one core functions properly, and thus that the AI functions properly, is $1 - 0.02 = 0.98$.\n\nIn Sample Case #4, the optimal strategy is to give all the training units to the second core. That makes the probability of at least one core functioning properly $1 - (0.4 \\times 0.6) = 0.76$. All other options are inferior; for example, giving all the training units to the first core only yields $0.75$, and dividing them equally among the cores gives $0.7525$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 50$.\n- For all $i$, $0.0000 \\leq P_i \\leq 1.0000$.\n- $0.0000 \\leq U \\leq N - \\sum P_i$. (There will not be more training units than can be used.)\n\n**Small dataset 1 (15 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~20~~ 5 seconds.\n- $K = N$. (All of the cores must function properly for the AI to function properly.)\n\n**Small dataset 2 (28 Pts, Test Set 2 - Visible)**\n\n- Time limit: ~~40~~ 10 seconds.\n- $1 \\leq K \\leq N$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #1C] Core Training", "background": "", "description": "Writing Code Jam problems is hard, so we have built an AI to come up with new ideas. To make the AI as creative as possible, we have given it $N$ different \"cores\", each of which has its own \"personality\". However, just like people, these cores may become distracted or corrupt or may refuse to work; the i-th core has a success probability $P_i$ of functioning properly. As long as at least $K$ of the cores function properly, the AI will function properly. Otherwise, it will probably become evil and trap us in a maze of fiendish puzzles of its own design. And who knows what it might do to Code Jam — it might just write a bunch of tough probability problems!\n\nTo prevent this from happening, we plan to train one or more of the cores to become more reliable. We have a total of $U$ \"training units\" that we can use to improve the cores. Spending $X$ units on the i-th core will add $X$ to its success probability. We can divide up the units among the cores however we like, and it is possible that one or more cores may not receive any units. Of course, a core's success probability cannot be increased above 1.\n\nIf we assign the training units to maximize the probability that the AI will function properly, what is that probability?\n\n~~**Solving this problem**~~\n\n~~This problem has 2 Small datasets and no Large dataset. You must solve the first Small dataset before you can attempt the second Small dataset. You will be able to retry either of the datasets (with a time penalty).~~", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of three lines. The first line contains two integers $N$ and $K$: the total number of cores, and the minimum number of cores that must succeed for the AI to function properly. The second line contains one rational $U$: the number of training units. The third line contains $N$ rational numbers $P_i$; the i-th of these gives the probability that the i-th core will function properly. All of these probabilities are specified to exactly four decimal places of precision.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the probability that the AI will function properly if the training units are assigned optimally. $y$ will be considered correct if it is within an absolute or relative error of $10^{-6}$ of the correct answer.", "hint": "**Sample Explanation**\n\nNote that the last two sample cases would not appear in Small dataset 1.\n\nIn Sample Case #1, we have enough training units to spend to give all cores a success probability of 1, so the AI will certainly function properly.\n\nIn Sample Case #2, both of the cores must function properly for the AI to function properly, so we must give each core at least some training units. The best option turns out to be to train each one up to $0.5$. Then the probability that the AI functions properly is $0.5 \\times 0.5 = 0.25$. Any other assignment is inferior; for instance, if we train one core to $0.9$ and the other core to $0.1$, the probability of success is only $0.9 \\times 0.1 = 0.09$.\n\nIn Sample Case #3, we have no training units to spend, and at least one of the two cores must function properly for the AI to function properly. We can approach this by first calculating the probability that the AI does not function properly, which happens only if both cores fail to function properly. The probability that both cores fail is $(1 - 0.9) \\times (1 - 0.8) = 0.02$. So the probability that at least one core functions properly, and thus that the AI functions properly, is $1 - 0.02 = 0.98$.\n\nIn Sample Case #4, the optimal strategy is to give all the training units to the second core. That makes the probability of at least one core functioning properly $1 - (0.4 \\times 0.6) = 0.76$. All other options are inferior; for example, giving all the training units to the first core only yields $0.75$, and dividing them equally among the cores gives $0.7525$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 50$.\n- For all $i$, $0.0000 \\leq P_i \\leq 1.0000$.\n- $0.0000 \\leq U \\leq N - \\sum P_i$. (There will not be more training units than can be used.)\n\n**Small dataset 1 (15 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~20~~ 5 seconds.\n- $K = N$. (All of the cores must function properly for the AI to function properly.)\n\n**Small dataset 2 (28 Pts, Test Set 2 - Visible)**\n\n- Time limit: ~~40~~ 10 seconds.\n- $1 \\leq K \\leq N$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #1C] Core Training", "background": null, "description": "编写 Code Jam 题目很难，因此我们开发了一个 AI 来提出新点子。为了让 AI 尽可能有创造力，我们为它配备了 $N$ 个不同的“核心”，每个核心都有自己的“个性”。然而，就像人一样，这些核心可能会分心、损坏或拒绝工作；第 $i$ 个核心正常工作的概率为 $P_i$。只要至少有 $K$ 个核心正常工作，AI 就能正常运行。否则，它很可能会变得邪恶，把我们困在自己设计的恶魔谜题迷宫里。谁知道它会对 Code Jam 做些什么——也许会写出一堆难到爆炸的概率题！\n\n为了防止这种情况发生，我们计划训练一个或多个核心，使其更可靠。我们总共有 $U$ 个“训练单元”可以用来提升核心的可靠性。将 $X$ 个训练单元分配给第 $i$ 个核心，会使其成功概率增加 $X$。我们可以随意分配这些训练单元，也可以让一个或多个核心不分配任何训练单元。当然，核心的成功概率不能超过 $1$。\n\n如果我们以最大化 AI 正常运行概率的方式分配训练单元，这个概率是多少？", "inputFormat": "输入的第一行包含测试用例数 $T$。接下来有 $T$ 组测试数据，每组包含三行。第一行包含两个整数 $N$ 和 $K$，分别表示核心总数和 AI 正常运行所需的最少正常核心数。第二行包含一个有理数 $U$，表示训练单元的数量。第三行包含 $N$ 个有理数 $P_i$，第 $i$ 个数表示第 $i$ 个核心正常工作的概率。所有概率均精确到小数点后四位。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是在最优分配训练单元后 AI 正常运行的概率。如果 $y$ 与正确答案的绝对误差或相对误差不超过 $10^{-6}$，则视为正确。", "hint": "**样例解释**\n\n注意，最后两个样例不会出现在小数据集 1 中。\n\n在样例 1 中，我们有足够的训练单元，可以让所有核心的成功概率都变为 1，因此 AI 一定能正常运行。\n\n在样例 2 中，两个核心都必须正常工作，AI 才能正常运行，因此必须给每个核心分配一些训练单元。最优方案是将每个核心都训练到 $0.5$。此时 AI 正常运行的概率为 $0.5 \\times 0.5 = 0.25$。其他分配方式都不如这个好；比如把一个核心训练到 $0.9$，另一个训练到 $0.1$，成功概率只有 $0.9 \\times 0.1 = 0.09$。\n\n在样例 3 中，我们没有训练单元可用，且至少需要一个核心正常工作。可以先计算 AI 无法正常工作的概率，即所有核心都失效。两个核心都失效的概率为 $(1 - 0.9) \\times (1 - 0.8) = 0.02$。因此至少有一个核心正常工作的概率，即 AI 正常运行的概率为 $1 - 0.02 = 0.98$。\n\n在样例 4 中，最优策略是将所有训练单元都分配给第二个核心。这样至少有一个核心正常工作的概率为 $1 - (0.4 \\times 0.6) = 0.76$。其他分配方式都不如这个好；比如全部分配给第一个核心只得到 $0.75$，平均分配给两个核心得到 $0.7525$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq N \\leq 50$。\n- 对所有 $i$，$0.0000 \\leq P_i \\leq 1.0000$。\n- $0.0000 \\leq U \\leq N - \\sum P_i$。（不会有多于可用的训练单元。）\n\n**小数据集 1（15 分，测试集 1 - 可见）**\n\n- 时间限制：5 秒。\n- $K = N$。（所有核心都必须正常工作，AI 才能正常运行。）\n\n**小数据集 2（28 分，测试集 2 - 可见）**\n\n- 时间限制：10 秒。\n- $1 \\leq K \\leq N$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13171", "type": "P", "difficulty": 3, "samples": [["3\n4 3\n4 5 6 4\n4 2\n4 5 6 4\n3 3\n1 1 1", "Case #1: 3\nCase #2: 4\nCase #3: 1"]], "limits": {"time": [5000, 10000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2017", "Google Code Jam"], "title": "[GCJ 2017 #2] Fresh Chocolate", "background": "", "description": "You are the public relations manager for a chocolate manufacturer. Unfortunately, the company's image has suffered because customers think the owner is cheap and miserly. You hope to undo that impression by offering a free factory tour and chocolate tasting.\n\nSoon after starting the new project, you realized that the company owner's reputation is well-deserved: he only agreed to give away free chocolate if you would minimize the cost. The chocolate to be given away comes in packs of $P$ pieces. You would like to open new packs for each tour group, but the owner insists that if there are leftover pieces from one group, they must be used with the next tour group before opening up any new packs.\n\nFor instance, suppose that each pack contains $P=3$ pieces, and that a tour group with $5$ people comes. You will open two packs to give one piece to each person, and you will have one piece left over. Suppose that after that, another tour group with $6$ people comes. They will receive the leftover piece, and then you will open two more packs to finish giving them their samples, and so you will have one piece left over again. If two groups with $4$ people each come right after, the first of those will get the leftover piece plus a full pack, and the last $4$ person group will get their pieces from two newly opened packs. Notice that you cannot open new packs until all leftovers have been used up, even if you plan on using all of the newly opened pack immediately.\n\nIn the example above, $2$ out of the $4$ groups (the first and last groups) got all of their chocolate from freshly opened packs. The other $2$ groups got some fresh chocolate and some leftovers. You know that giving out leftovers is not the best way to undo the owner's miserly image, but you had to accept this system in order to get your cheap boss to agree to the project. Despite the unfavorable context, you are committed to doing a good job.\n\nYou have requests from $N$ groups, and each group has specified the number of people that will come into the factory. Groups will come in one at a time. You want to bring them in in an order that maximizes the number of groups that get only fresh chocolate and no leftovers. You cannot reject groups, nor have a group get chocolate more than once, and you need to give exactly one piece to each person in each group.\n\nIn the example above, if instead of $5, 6, 4, 4$, the order were $4, 5, 6, 4$, a total of $3$ groups (all but the $5$ person group) would get only fresh chocolate. For that set of groups, it is not possible to do better, as no arrangement would cause all groups to get only fresh chocolate.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of two lines. The first line contains two integers $N$, the number of groups coming for a tour, and $P$, the number of pieces of chocolate per pack. The second line contains $N$ integers $G_1, G_2, \\dots, G_N$, the number of people in each of the groups.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of groups that will receive only fresh chocolate if you bring them in in an order that maximizes that number.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained in the statement. Besides the possible optimal order given above, other orders like $6, 5, 4, 4$ also maximize the number of groups with only fresh chocolate, although the groups that get the fresh chocolate are not necessarily the same. Notice that we only care about the number of groups that get the best experience, not the total number of people in them.\n\nIn Sample Case #2, the groups are the same as in Case #1, but the packs contain two pieces each. In this case, several ways of ordering them — for instance, $4, 4, 6, 5$ — make all groups get only fresh chocolate.\n\nIn Sample Case #3, all groups are single individuals, and they will all eat from the same pack. Of course, only the first one to come in is going to get a freshly opened pack.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 100$.\n- $1 \\leq G_i \\leq 100$, for all $i$.\n\n**Small dataset (6 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~20~~ 5 seconds.\n- $2 \\leq P \\leq 3$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~40~~ 10 seconds.\n- $2 \\leq P \\leq 4$.\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #2] Fresh Chocolate", "background": "", "description": "You are the public relations manager for a chocolate manufacturer. Unfortunately, the company's image has suffered because customers think the owner is cheap and miserly. You hope to undo that impression by offering a free factory tour and chocolate tasting.\n\nSoon after starting the new project, you realized that the company owner's reputation is well-deserved: he only agreed to give away free chocolate if you would minimize the cost. The chocolate to be given away comes in packs of $P$ pieces. You would like to open new packs for each tour group, but the owner insists that if there are leftover pieces from one group, they must be used with the next tour group before opening up any new packs.\n\nFor instance, suppose that each pack contains $P=3$ pieces, and that a tour group with $5$ people comes. You will open two packs to give one piece to each person, and you will have one piece left over. Suppose that after that, another tour group with $6$ people comes. They will receive the leftover piece, and then you will open two more packs to finish giving them their samples, and so you will have one piece left over again. If two groups with $4$ people each come right after, the first of those will get the leftover piece plus a full pack, and the last $4$ person group will get their pieces from two newly opened packs. Notice that you cannot open new packs until all leftovers have been used up, even if you plan on using all of the newly opened pack immediately.\n\nIn the example above, $2$ out of the $4$ groups (the first and last groups) got all of their chocolate from freshly opened packs. The other $2$ groups got some fresh chocolate and some leftovers. You know that giving out leftovers is not the best way to undo the owner's miserly image, but you had to accept this system in order to get your cheap boss to agree to the project. Despite the unfavorable context, you are committed to doing a good job.\n\nYou have requests from $N$ groups, and each group has specified the number of people that will come into the factory. Groups will come in one at a time. You want to bring them in in an order that maximizes the number of groups that get only fresh chocolate and no leftovers. You cannot reject groups, nor have a group get chocolate more than once, and you need to give exactly one piece to each person in each group.\n\nIn the example above, if instead of $5, 6, 4, 4$, the order were $4, 5, 6, 4$, a total of $3$ groups (all but the $5$ person group) would get only fresh chocolate. For that set of groups, it is not possible to do better, as no arrangement would cause all groups to get only fresh chocolate.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of two lines. The first line contains two integers $N$, the number of groups coming for a tour, and $P$, the number of pieces of chocolate per pack. The second line contains $N$ integers $G_1, G_2, \\dots, G_N$, the number of people in each of the groups.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the number of groups that will receive only fresh chocolate if you bring them in in an order that maximizes that number.", "hint": "**Sample Explanation**\n\nSample Case #1 is the one explained in the statement. Besides the possible optimal order given above, other orders like $6, 5, 4, 4$ also maximize the number of groups with only fresh chocolate, although the groups that get the fresh chocolate are not necessarily the same. Notice that we only care about the number of groups that get the best experience, not the total number of people in them.\n\nIn Sample Case #2, the groups are the same as in Case #1, but the packs contain two pieces each. In this case, several ways of ordering them — for instance, $4, 4, 6, 5$ — make all groups get only fresh chocolate.\n\nIn Sample Case #3, all groups are single individuals, and they will all eat from the same pack. Of course, only the first one to come in is going to get a freshly opened pack.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq N \\leq 100$.\n- $1 \\leq G_i \\leq 100$, for all $i$.\n\n**Small dataset (6 Pts, Test Set 1 - Visible)**\n\n- Time limit: ~~20~~ 5 seconds.\n- $2 \\leq P \\leq 3$.\n\n**Large dataset (10 Pts, Test Set 2 - Hidden)**\n\n- Time limit: ~~40~~ 10 seconds.\n- $2 \\leq P \\leq 4$.\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #2] Fresh Chocolate", "background": null, "description": "你是一家巧克力制造商的公关经理。不幸的是，由于顾客认为老板吝啬小气，公司的形象受到了影响。你希望通过提供免费的工厂参观和巧克力品尝来扭转这种印象。\n\n然而，在新项目刚开始后，你就意识到老板的名声并非空穴来风：他只同意免费赠送巧克力，前提是你能将成本降到最低。要赠送的巧克力以每包 $P$ 块的形式提供。你本希望每个参观团都能打开新的一包，但老板坚持要求，如果上一组有剩余的巧克力，必须在为下一组服务前先用完这些剩余，之后才能打开新的一包。\n\n例如，假设每包有 $P=3$ 块巧克力，某一参观团有 $5$ 人。你需要打开两包巧克力，每人分到一块，还会剩下一块。假设接下来又有一组 $6$ 人的参观团到来，他们会先拿到那块剩余的巧克力，然后你再打开两包新巧克力，分给剩下的人，这样又会剩下一块。如果之后有两个 $4$ 人的参观团，第一个团会拿到剩余的一块加上一包新开的巧克力，最后一个 $4$ 人团则需要打开两包新巧克力。注意，即使你打算立刻用完新开的巧克力，也不能在用完所有剩余之前打开新的一包。\n\n在上述例子中，$4$ 个团中有 $2$ 个团（第一个和最后一个）拿到的都是新开的巧克力。其余 $2$ 个团则拿到了一部分新巧克力和一部分剩余巧克力。你知道发放剩余巧克力并不能改善老板吝啬的形象，但为了让老板同意这个项目，你不得不接受这个制度。尽管条件不利，你仍然致力于把工作做好。\n\n现在有 $N$ 个参观团提出了申请，每个团都说明了将有多少人来参观工厂。参观团会一个接一个到来。你希望安排他们的到场顺序，使得拿到全新巧克力（没有剩余巧克力）的团数最多。你不能拒绝任何团，也不能让同一个团多次领取巧克力，并且必须保证每个人都正好拿到一块巧克力。\n\n在上述例子中，如果顺序不是 $5, 6, 4, 4$，而是 $4, 5, 6, 4$，那么总共有 $3$ 个团（除了 $5$ 人团外）能拿到全新巧克力。对于这组团体来说，没有任何顺序能让所有团都只拿到新巧克力。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据包含两行。第一行包含两个整数 $N$（参观团数量）和 $P$（每包巧克力的块数）。第二行包含 $N$ 个整数 $G_1, G_2, \\dots, G_N$，分别表示每个团的人数。", "outputFormat": "对于每组测试数据，输出一行，格式为 `Case #x: y`，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 表示在最优安排下，能拿到全新巧克力的团数。", "hint": "**样例解释**\n\n样例 1 即题目描述中的例子。除了上文给出的最优顺序外，像 $6, 5, 4, 4$ 这样的顺序也能使拿到全新巧克力的团数最大，尽管具体哪些团拿到新巧克力可能不同。注意，我们只关心拿到全新巧克力的团数，而不是这些团的人数总和。\n\n样例 2 中，团体和样例 1 相同，但每包有两块巧克力。在这种情况下，有多种顺序（如 $4, 4, 6, 5$）可以让所有团都拿到全新巧克力。\n\n样例 3 中，所有团都是单人团，他们都会从同一包巧克力中领取。当然，只有第一个人能拿到刚开封的巧克力。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq N \\leq 100$。\n- $1 \\leq G_i \\leq 100$，对所有 $i$。\n\n**小数据范围（6 分，测试点 1 - 可见）**\n\n- 时间限制：5 秒。\n- $2 \\leq P \\leq 3$。\n\n**大数据范围（10 分，测试点 2 - 隐藏）**\n\n- 时间限制：10 秒。\n- $2 \\leq P \\leq 4$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13172", "type": "P", "difficulty": 4, "samples": [["5\n2 2 2\n2 1\n2 2\n2 2 2\n1 1\n1 2\n2 2 2\n1 1\n2 1\n1000 1000 4\n3 2\n2 1\n3 3\n3 1\n3 3 5\n3 1\n2 2\n3 3\n2 2\n3 1", "Case #1: 1 1\nCase #2: 2 0\nCase #3: 2 0\nCase #4: 2 1\nCase #5: 2 1"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["数学", "贪心", "2017", "Google Code Jam"], "title": "[GCJ 2017 #2] Roller Coaster Scheduling", "background": "", "description": "You created a new roller coaster that is about to open. Its train consists of a single row of $N$ seats numbered $1$ through $N$ from front to back. Of course, seats closer to the front are more valuable. Customers have already purchased opening-day tickets. Each ticket allows a specific customer to take one ride on the coaster in a particular seat. Some customers may have bought more than one ticket, and they expect to go on one ride for each ticket.\n\nYou need to decide how many roller coaster rides there will be on opening day. On each ride, one customer can sit in each seat; some seats on a ride might be left empty. You cannot assign a customer to more than one seat in the same ride, nor can you put two customers on the same seat in any given ride.\n\nYou wish to minimize the number of rides required to honor all tickets, to reduce operational costs. To reduce the required number of rides, you can promote any number of tickets. Promoting a ticket means taking a customer's ticket and giving that customer a new ticket for a seat closer to the front of the train (that is, a seat with a lower number). You would prefer to promote as few tickets as possible, since too many promotions might cause customers to get greedy and ask for more promotions in the future.\n\nGiven the positions and buyers of all the tickets that have been sold, what is the minimum number of rides needed to honor all tickets, using as many promotions as needed and scheduling the rides optimally? And what is the minimum number of ticket promotions necessary to attain that number of rides? Note that promoting a given customer on a given ride from seat $4$ to seat $2$, for example, counts as only one promotion, not two separate ones.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a single line with three integers $N$, the number of seats in the roller coaster, $C$, the number of potential customers, and $M$, the number of tickets sold. The customers are identified with numbers between 1 and $C$. Then, $M$ lines follow, each containing two integers: $P_i$, the position in the roller coaster assigned to the $i$-th ticket, and $B_i$, the identifier of the buyer of that ticket.\n", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), $y$ is the minimum number of rides you need to honor all tickets if you use the promotions and schedule the rides optimally, and $z$ is the minimum number of promotions you need to make be able to honor all tickets with $y$ rides.", "hint": "**Sample Explanation**\n\nNote that the last two sample cases would not appear in the Small dataset.\n\nIn Case #1, both customers purchased a ticket for position 2. It is impossible to honor both tickets with a single ride, but promoting either ticket to position 1 allows you to accommodate both tickets on the same round.\n\nCase #2 is a similar story, except both tickets are for position 1. Since you cannot promote those tickets or exchange them for inferior tickets, you are forced to run 2 separate rides, one per customer.\n\nCase #3 features the same customer purchasing both positions. Since you are forced to have 2 rides for that customer, there is no reason to give out any promotions.\n\nIn Case #4, notice that there may be both customers and positions with no tickets assigned. In this case, there are three tickets sold for position three. If you promote customer 2 to position 2, for instance, you can have one ride with customer 1 sitting in position 2 and customer 3 sitting in position 3, and a second ride with customer 2 in position 2 and customer 1 in position 3. Additional promotions will not allow you to decrease the number of rides, because customer 1 has two tickets and you need to honor those in different rides, regardless of position.\n\nIn Case #5, one optimal solution is to promote one of the $3\\ 1$ tickets to $1\\ 1$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq 1000$.\n- $1 \\leq M \\leq 1000$.\n- $1 \\leq P_i \\leq N$.\n- $1 \\leq B_i \\leq C$.\n\n**Small dataset (7 Pts, Test Set 1 - Visible)**\n\n- $C = 2$.\n\n**Large dataset (14 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leq C \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #2] Roller Coaster Scheduling", "background": "", "description": "You created a new roller coaster that is about to open. Its train consists of a single row of $N$ seats numbered $1$ through $N$ from front to back. Of course, seats closer to the front are more valuable. Customers have already purchased opening-day tickets. Each ticket allows a specific customer to take one ride on the coaster in a particular seat. Some customers may have bought more than one ticket, and they expect to go on one ride for each ticket.\n\nYou need to decide how many roller coaster rides there will be on opening day. On each ride, one customer can sit in each seat; some seats on a ride might be left empty. You cannot assign a customer to more than one seat in the same ride, nor can you put two customers on the same seat in any given ride.\n\nYou wish to minimize the number of rides required to honor all tickets, to reduce operational costs. To reduce the required number of rides, you can promote any number of tickets. Promoting a ticket means taking a customer's ticket and giving that customer a new ticket for a seat closer to the front of the train (that is, a seat with a lower number). You would prefer to promote as few tickets as possible, since too many promotions might cause customers to get greedy and ask for more promotions in the future.\n\nGiven the positions and buyers of all the tickets that have been sold, what is the minimum number of rides needed to honor all tickets, using as many promotions as needed and scheduling the rides optimally? And what is the minimum number of ticket promotions necessary to attain that number of rides? Note that promoting a given customer on a given ride from seat $4$ to seat $2$, for example, counts as only one promotion, not two separate ones.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a single line with three integers $N$, the number of seats in the roller coaster, $C$, the number of potential customers, and $M$, the number of tickets sold. The customers are identified with numbers between 1 and $C$. Then, $M$ lines follow, each containing two integers: $P_i$, the position in the roller coaster assigned to the $i$-th ticket, and $B_i$, the identifier of the buyer of that ticket.\n", "outputFormat": "For each test case, output one line containing `Case #x: y z`, where $x$ is the test case number (starting from 1), $y$ is the minimum number of rides you need to honor all tickets if you use the promotions and schedule the rides optimally, and $z$ is the minimum number of promotions you need to make be able to honor all tickets with $y$ rides.", "hint": "**Sample Explanation**\n\nNote that the last two sample cases would not appear in the Small dataset.\n\nIn Case #1, both customers purchased a ticket for position 2. It is impossible to honor both tickets with a single ride, but promoting either ticket to position 1 allows you to accommodate both tickets on the same round.\n\nCase #2 is a similar story, except both tickets are for position 1. Since you cannot promote those tickets or exchange them for inferior tickets, you are forced to run 2 separate rides, one per customer.\n\nCase #3 features the same customer purchasing both positions. Since you are forced to have 2 rides for that customer, there is no reason to give out any promotions.\n\nIn Case #4, notice that there may be both customers and positions with no tickets assigned. In this case, there are three tickets sold for position three. If you promote customer 2 to position 2, for instance, you can have one ride with customer 1 sitting in position 2 and customer 3 sitting in position 3, and a second ride with customer 2 in position 2 and customer 1 in position 3. Additional promotions will not allow you to decrease the number of rides, because customer 1 has two tickets and you need to honor those in different rides, regardless of position.\n\nIn Case #5, one optimal solution is to promote one of the $3\\ 1$ tickets to $1\\ 1$.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $2 \\leq N \\leq 1000$.\n- $1 \\leq M \\leq 1000$.\n- $1 \\leq P_i \\leq N$.\n- $1 \\leq B_i \\leq C$.\n\n**Small dataset (7 Pts, Test Set 1 - Visible)**\n\n- $C = 2$.\n\n**Large dataset (14 Pts, Test Set 2 - Hidden)**\n\n- $2 \\leq C \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #2] Roller Coaster Scheduling", "background": null, "description": "你设计了一款即将开放的新过山车。它的列车由一排 $N$ 个座位组成，座位从前到后编号为 $1$ 到 $N$。显然，越靠前的座位越有价值。顾客们已经购买了开业当天的门票。每张门票允许特定顾客在特定座位上乘坐一次过山车。有些顾客可能购买了多张门票，他们期望每张门票都能乘坐一次。\n\n你需要决定开业当天需要安排多少次过山车运行。每次运行时，每个座位只能坐一位顾客；某些座位可以空着。你不能让同一位顾客在同一次运行中占据多个座位，也不能让两位顾客在同一次运行中坐在同一个座位上。\n\n你希望通过合理安排，最小化所需的运行次数以满足所有门票。为了减少所需的运行次数，你可以对任意数量的门票进行“晋升”。晋升一张门票意味着将某位顾客的门票换成编号更小（即更靠前）的座位。你希望晋升的门票数量尽可能少，因为晋升太多可能会让顾客变得贪心，今后要求更多晋升。\n\n给定所有已售门票的座位和购买者信息，请你计算：在可以任意晋升门票并最优安排运行的情况下，满足所有门票所需的最少运行次数是多少？以及达到该最少运行次数所需的最少晋升次数是多少？注意，对于同一位顾客在同一次运行中将座位从 $4$ 晋升到 $2$，只算作一次晋升，而不是两次。", "inputFormat": "输入的第一行包含一个整数 $T$，表示测试用例的数量。接下来有 $T$ 组测试数据。每组测试数据的第一行包含三个整数：$N$（过山车的座位数）、$C$（潜在顾客数）和 $M$（已售门票数）。顾客编号为 $1$ 到 $C$。接下来的 $M$ 行，每行包含两个整数：$P_i$ 表示第 $i$ 张门票对应的座位编号，$B_i$ 表示购买该门票的顾客编号。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y z`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 是在允许晋升并最优安排运行的情况下满足所有门票所需的最少运行次数，$z$ 是达到该最少运行次数所需的最少晋升次数。", "hint": "**样例解释**\n\n注意，最后两个样例不会出现在 Small 数据集。\n\n在第 1 个样例中，两位顾客都购买了第 2 号座位的门票。无法在一次运行中满足两张门票，但如果将其中一张晋升到第 1 号座位，就可以在同一轮中安排两位顾客。\n\n第 2 个样例类似，只不过两张门票都是第 1 号座位。由于无法再晋升，也无法交换到更差的座位，因此只能安排两次运行，每位顾客各一次。\n\n第 3 个样例中，同一位顾客购买了两个座位。由于必须为该顾客安排两次运行，因此无需进行任何晋升。\n\n第 4 个样例中，注意可能存在没有门票的顾客和座位。本例中，第 3 号座位卖出了三张门票。如果将顾客 2 晋升到第 2 号座位，例如，可以安排一次运行：顾客 1 坐第 2 号座位，顾客 3 坐第 3 号座位；再安排一次运行：顾客 2 坐第 2 号座位，顾客 1 坐第 3 号座位。即使再晋升，也无法减少运行次数，因为顾客 1 有两张门票，必须分两次运行，无论座位如何。\n\n第 5 个样例中，一种最优方案是将其中一张 $3\\ 1$ 门票晋升到 $1\\ 1$。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $2 \\leq N \\leq 1000$。\n- $1 \\leq M \\leq 1000$。\n- $1 \\leq P_i \\leq N$。\n- $1 \\leq B_i \\leq C$。\n\n**Small 数据集（7 分，测试点 1 - 可见）**\n\n- $C = 2$。\n\n**Large 数据集（14 分，测试点 2 - 隐藏）**\n\n- $2 \\leq C \\leq 1000$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13173", "type": "P", "difficulty": 6, "samples": [["5\n1 3\n-.-\n3 4\n#.##\n#--#\n####\n2 2\n-.\n#|\n4 3\n.|.\n-//\n.-.\n#\\/\n3 3\n/|\\\n\\\\/\n./#", "Case #1: IMPOSSIBLE\nCase #2: POSSIBLE\n#.##\n#||#\n####\nCase #3: POSSIBLE\n|.\n#|\nCase #4: POSSIBLE\n.-.\n|//\n.|.\n#\\/\nCase #5: IMPOSSIBLE"]], "limits": {"time": [5000, 5000], "memory": [1048576, 1048576]}, "tags": ["2017", "Special Judge", "2-SAT", "Google Code Jam"], "title": "[GCJ 2017 #2] Beaming With Joy", "background": "", "description": "Joy is about to go on a long vacation, so she has hired technicians to install a security system based on infrared laser beams. The technicians have given her a diagram that represents her house as a grid of unit cells with $R$ rows and $C$ columns. Each cell in this grid contains one of the following:\n\n* `/`: A two-sided mirror that runs from the cell's lower left corner to its upper right corner.\n* `\\`: A two-sided mirror that runs from the cell's upper left corner to its lower right corner.\n* `-`: A beam shooter that shoots horizontal beams out into the cells (if any) to the immediate left and right of this cell.\n* `|`: A beam shooter that shoots vertical beams out into the cells (if any) immediately above and below this cell.\n* `#`: A wall. (Note that the house is not necessarily surrounded by a border of walls; this is one reason why Joy needs a security system!)\n* `.`: Nothing; the cell is empty.\n\nBeams travel in straight lines and continue on through empty cells. When a beam hits a mirror, it bounces 90 degrees off the mirror's surface and continues. When a beam traveling to the right hits a `/` mirror, it bounces off the mirror and starts traveling up; beams traveling up, left, or down that hit a `/` mirror bounce off and travel right, down, or left, respectively. The `\\` mirror behaves similarly: when a beam traveling right, up, left or down hits it, it bounces off and starts traveling down, left, up or right, respectively. When a beam hits a wall or goes out of the bounds of the grid, it stops. It is fine for beams to cross other beams, but if a beam hits any beam shooter (including, perhaps, the beam shooter that originated the beam), that beam shooter will be destroyed!\n\nJoy wants to make sure that every empty cell in the house has at least one beam passing through it, and that no beam shooters are destroyed, since that would just be wasting money! Unfortunately, the technicians have already installed the system, so the most Joy can do is rotate some of the existing beam shooters 90 degrees. That is, for any number (including zero) of beam shooters, she can turn `-` into `|` or vice versa.\n\nCan you find any way for Joy to achieve her goal, or determine that it is impossible? Note that it is not required to minimize the number of rotations of beam shooters.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line with two integers $R$ and $C$: the number of rows and columns in the grid representing the house. Then, $R$ lines of $C$ characters each follow; each character is `/, \\, -, |, #`, or `.`, as described in the statement.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if Joy cannot accomplish her goal, or POSSIBLE if she can. Then, if the case is possible, output the same $R$ lines of $C$ characters each from the input grid, with zero or more instances of - replaced by | or vice versa.\n\nIf there are multiple possible answers, you may output any of them.", "hint": "**Sample Explanation**\n\nNote that the last 2 sample cases would not appear in the Small dataset.\n\nIn Sample Case #1, if a beam shooter is positioned to shoot its beam into the empty cell, it will necessarily destroy the other beam shooter. So the case is IMPOSSIBLE.\n\nIn Sample Case #2, the leftmost beam shooter must be rotated to cover the empty cell. The rightmost beam shooter must also be rotated to avoid destroying the leftmost beam shooter.\n\nIn Sample Case #3, the existing beam shooters already cover all empty cells with their beams and do not destroy each other, so outputting the grid from the input would be acceptable. However, notice that the output that we have given is also correct.\n\nIn Sample Case #4, one acceptable solution is to rotate all three of the beam shooters. However, note that the following would also be acceptable:\n```\n.-.\n|//\n.-.\n#\\/\n```\nsince it is not necessary for cells with mirrors to have a beam pass through them. (Who would steal giant diagonal mirrors, anyway?)\n\nIn Sample Case #5, the beam shooter would destroy itself no matter which orientation Joy chooses for it, so the case is IMPOSSIBLE.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq C \\leq 50$.\n- Each character in the grid is one of `/, \\, -, |, #`, or `.`.\n- The number of `-` characters plus the number of `|` characters (that is, the number of beam shooters) in the grid is between $1$ and $100$, inclusive.\n- There is at least $1$ `.` character (that is, empty space) in the grid.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- $1 \\leq R \\leq 5$.\n- There are no `/` or `\\` characters (that is, no mirrors) in the grid.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- $1 \\leq R \\leq 50$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #2] Beaming With Joy", "background": "", "description": "Joy is about to go on a long vacation, so she has hired technicians to install a security system based on infrared laser beams. The technicians have given her a diagram that represents her house as a grid of unit cells with $R$ rows and $C$ columns. Each cell in this grid contains one of the following:\n\n* `/`: A two-sided mirror that runs from the cell's lower left corner to its upper right corner.\n* `\\`: A two-sided mirror that runs from the cell's upper left corner to its lower right corner.\n* `-`: A beam shooter that shoots horizontal beams out into the cells (if any) to the immediate left and right of this cell.\n* `|`: A beam shooter that shoots vertical beams out into the cells (if any) immediately above and below this cell.\n* `#`: A wall. (Note that the house is not necessarily surrounded by a border of walls; this is one reason why Joy needs a security system!)\n* `.`: Nothing; the cell is empty.\n\nBeams travel in straight lines and continue on through empty cells. When a beam hits a mirror, it bounces 90 degrees off the mirror's surface and continues. When a beam traveling to the right hits a `/` mirror, it bounces off the mirror and starts traveling up; beams traveling up, left, or down that hit a `/` mirror bounce off and travel right, down, or left, respectively. The `\\` mirror behaves similarly: when a beam traveling right, up, left or down hits it, it bounces off and starts traveling down, left, up or right, respectively. When a beam hits a wall or goes out of the bounds of the grid, it stops. It is fine for beams to cross other beams, but if a beam hits any beam shooter (including, perhaps, the beam shooter that originated the beam), that beam shooter will be destroyed!\n\nJoy wants to make sure that every empty cell in the house has at least one beam passing through it, and that no beam shooters are destroyed, since that would just be wasting money! Unfortunately, the technicians have already installed the system, so the most Joy can do is rotate some of the existing beam shooters 90 degrees. That is, for any number (including zero) of beam shooters, she can turn `-` into `|` or vice versa.\n\nCan you find any way for Joy to achieve her goal, or determine that it is impossible? Note that it is not required to minimize the number of rotations of beam shooters.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line with two integers $R$ and $C$: the number of rows and columns in the grid representing the house. Then, $R$ lines of $C$ characters each follow; each character is `/, \\, -, |, #`, or `.`, as described in the statement.", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if Joy cannot accomplish her goal, or POSSIBLE if she can. Then, if the case is possible, output the same $R$ lines of $C$ characters each from the input grid, with zero or more instances of - replaced by | or vice versa.\n\nIf there are multiple possible answers, you may output any of them.", "hint": "**Sample Explanation**\n\nNote that the last 2 sample cases would not appear in the Small dataset.\n\nIn Sample Case #1, if a beam shooter is positioned to shoot its beam into the empty cell, it will necessarily destroy the other beam shooter. So the case is IMPOSSIBLE.\n\nIn Sample Case #2, the leftmost beam shooter must be rotated to cover the empty cell. The rightmost beam shooter must also be rotated to avoid destroying the leftmost beam shooter.\n\nIn Sample Case #3, the existing beam shooters already cover all empty cells with their beams and do not destroy each other, so outputting the grid from the input would be acceptable. However, notice that the output that we have given is also correct.\n\nIn Sample Case #4, one acceptable solution is to rotate all three of the beam shooters. However, note that the following would also be acceptable:\n```\n.-.\n|//\n.-.\n#\\/\n```\nsince it is not necessary for cells with mirrors to have a beam pass through them. (Who would steal giant diagonal mirrors, anyway?)\n\nIn Sample Case #5, the beam shooter would destroy itself no matter which orientation Joy chooses for it, so the case is IMPOSSIBLE.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $1 \\leq C \\leq 50$.\n- Each character in the grid is one of `/, \\, -, |, #`, or `.`.\n- The number of `-` characters plus the number of `|` characters (that is, the number of beam shooters) in the grid is between $1$ and $100$, inclusive.\n- There is at least $1$ `.` character (that is, empty space) in the grid.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- $1 \\leq R \\leq 5$.\n- There are no `/` or `\\` characters (that is, no mirrors) in the grid.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- $1 \\leq R \\leq 50$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #2] Beaming With Joy", "background": null, "description": "Joy 即将去度长假，因此她雇佣了技术人员为她安装一个基于红外激光束的安防系统。技术人员给了她一张图纸，将她的房子表示为一个 $R$ 行 $C$ 列的单元格网格。每个单元格包含以下之一：\n\n- `/`：一面双面镜，从单元格的左下角延伸到右上角。\n- `\\`：一面双面镜，从单元格的左上角延伸到右下角。\n- `-`：一个水平激光发射器，会向该单元格左右相邻的单元格（如果有）发射水平激光束。\n- `|`：一个垂直激光发射器，会向该单元格上下相邻的单元格（如果有）发射垂直激光束。\n- `#`：一面墙。（注意，房子不一定被墙包围，这也是 Joy 需要安防系统的原因之一！）\n- `.`：空单元格，什么都没有。\n\n激光束会沿直线传播，并穿过空单元格。当激光束遇到镜子时，会以 90 度角反射并继续传播。当向右传播的激光束遇到 `/` 镜子时，会反射并向上传播；而向上、向左或向下传播的激光束遇到 `/` 镜子时，会分别反射并向右、向下或向左传播。`\\` 镜子的反射方式类似：当激光束向右、上、左或下传播时遇到它，会分别反射并向下、向左、向上或向右传播。当激光束遇到墙壁或超出网格边界时，会停止传播。激光束可以与其他激光束交叉，但如果激光束击中任何激光发射器（包括可能是发射该激光束的发射器本身），该激光发射器会被摧毁！\n\nJoy 希望确保房子里的每个空单元格都至少有一束激光通过，并且没有任何激光发射器被摧毁，否则就浪费钱了！不幸的是，技术人员已经安装好了系统，所以 Joy 现在最多只能将一些现有的激光发射器旋转 90 度，也就是说，可以将任意数量（包括 0 个）的 `-` 改为 `|`，或将 `|` 改为 `-`。\n\n你能帮 Joy 判断是否有办法达成她的目标，或者判断是否不可能实现吗？注意，不要求最小化旋转激光发射器的数量。", "inputFormat": "输入的第一行是测试用例数 $T$。接下来有 $T$ 组测试数据。每组数据的第一行为两个整数 $R$ 和 $C$，表示房子的网格有 $R$ 行 $C$ 列。接下来 $R$ 行，每行 $C$ 个字符，字符为 `/`、`\\`、`-`、`|`、`#` 或 `.`，含义如题目描述所述。", "outputFormat": "对于每个测试用例，输出一行，格式为 `Case #x: y`，其中 $x$ 是测试用例编号（从 1 开始），$y$ 为 IMPOSSIBLE（如果 Joy 无法达成目标）或 POSSIBLE（如果可以达成目标）。如果可能，请在接下来的 $R$ 行输出修改后的网格（与输入格式相同），其中可以有若干 `-` 被替换为 `|` 或反之。\n\n如果有多种可行解，输出任意一种即可。", "hint": "**样例解释**\n\n注意，最后两个样例不会出现在 Small 数据集中。\n\n在样例 1 中，如果一个激光发射器被设置为发射激光覆盖空单元格，则必然会摧毁另一个激光发射器。因此该情况为 IMPOSSIBLE。\n\n在样例 2 中，最左侧的激光发射器必须旋转以覆盖空单元格。最右侧的激光发射器也必须旋转，以避免摧毁最左侧的激光发射器。\n\n在样例 3 中，现有的激光发射器已经覆盖了所有空单元格且不会互相摧毁，因此直接输出输入网格即可。当然，给出的输出也是正确的。\n\n在样例 4 中，一种可行解是将三个激光发射器全部旋转。不过，以下解也是可行的：\n```\n.-.\n|//\n.-.\n#\\/\n```\n因为镜子所在的单元格不需要有激光通过。（毕竟没人会偷巨大的斜面镜子，对吧？）\n\n在样例 5 中，无论激光发射器如何旋转，都会自我摧毁，因此该情况为 IMPOSSIBLE。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $1 \\leq C \\leq 50$。\n- 网格中的每个字符为 `/`、`\\`、`-`、`|`、`#` 或 `.`。\n- 网格中 `-` 和 `|`（即激光发射器）的总数在 $1$ 到 $100$ 之间。\n- 至少有 $1$ 个 `.`（即空单元格）。\n\n**小数据集（测试集 1 - 可见）**\n\n- $1 \\leq R \\leq 5$。\n- 网格中没有 `/` 或 `\\`（即没有镜子）。\n\n**大数据集（测试集 2 - 隐藏）**\n\n- $1 \\leq R \\leq 50$。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
{"pid": "P13174", "type": "P", "difficulty": 6, "samples": [["4\n2 2 1\n#S\nT.\n2 6 4\n.T\n.T\n.T\nS#\nS#\nS#\n5 5 4\n.....\nSS#.T\nSS#TT\nSS#.T\n.....\n3 3 8\nS.#\n.#.\n#.T", "Case #1: 1\n1 1\nCase #2: 3\n3 3\n1 1\n2 2\nCase #3: 3\n1 2\n2 1\n6 3\nCase #4: 0"]], "limits": {"time": [7500, 15000], "memory": [524288, 524288]}, "tags": ["2017", "Special Judge", "广度优先搜索 BFS", "二分图", "Google Code Jam"], "title": "[GCJ 2017 #2] Shoot the Turrets", "background": "", "description": "The fight to free the city from extraterrestrial invaders is over! People are happy that love and peace have returned.\n\nThe city is represented as a grid with $R$ rows and $C$ columns. Some cells on the grid are buildings (through which nobody can see, nobody can shoot, and nobody can walk), and some are streets (through which everybody can see, shoot and walk). Unfortunately, during the war, the now-defeated invaders set up automatic security turrets in the city. These turrets are only in streets (not in buildings). They pose a threat to the citizens, but fortunately, there are also some soldiers on the streets (not in buildings). Initially, no soldier is in the same place as a turret.\n\nThe invader turrets do not move. They are small, so they don't block sight and shooting. A soldier cannot walk through an active turret's cell, but can walk through it once it is destroyed. A turret can only see soldiers in the cells for which it has a horizontal or vertical line of sight. If a soldier enters such a cell, the turret does not fire. If a soldier attempts to exit such a cell (after entering it, or after starting in that cell), the turret fires. Luckily, a soldier can still shoot from that cell, and the turret will not detect that as movement. It means that none of your soldiers will actually die, because in the worst case they can always wait, motionless, for help (perhaps for a long time). Maybe you will have a chance to rescue them later.\n\nEach soldier can make a total of $M$ unit moves. Each of these moves must be one cell in a horizontal or vertical direction. Soldiers can walk through each other and do not block the lines of sight of other soldiers or turrets. Each soldier also has one bullet. If a soldier has a turret in her horizontal or vertical line of sight, the soldier can shoot and destroy it. Each shot can only destroy one turret, but the soldiers are such excellent shooters that they can even shoot past one or several turrets or soldiers in their line of sight and hit another turret farther away!\n\nYou are given a map (with the soldier and turret positions marked). What is the largest number of turrets that the soldiers can destroy?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing the integer $C$ (the width of the map), $R$ (the height of the map) and $M$ (the number of unit moves each soldier can make). The next $R$ lines contain $C$ characters each, with . representing a street, # representing a building, S representing a soldier and T representing a turret.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of turrets that it is possible to destroy. Then $y$ lines should follow: each should contain two integers $s_i$ and $t_i$ denoting that the $i$th thing that happens should be soldier $s_i$ destroying turret $t_i$ (you don't need to specify exactly how the soldier has to move). If multiple valid strategies exist, you may output any one of them.\n\nSoldiers are numbered from 1, reading from left to right along the top row, then left to right along the next row down from the top, and so on, from top to bottom.", "hint": "**Sample Explanation**\n\nIn Case #2, one of the possible solutions is to move soldier $3$ up three cells and shoot turret $3$. Then soldier $1$ can move up one cell and right one cell (to where turret $3$ was) and shoot past turret $2$ to destroy turret $1$. Finally, soldier $2$ can move up three cells and shoot turret $2$.\n\nIn Case #3, soldier $1$ can move up one cell, then right three cells and shoot turret $2$. Then soldier $2$ can move up one cell, then right three cells and shoot turret $1$. Finally, soldier $6$ can move down one cell, then right three cells and shoot turret $3$. Other soldiers have insufficient move range to shoot any other turrets.\n\nIn Case #4, the soldier cannot move to within the same row or column as the turret, so the turret cannot be destroyed.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $0 \\leq M < C \\times R$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- Time limit: ~~30~~ 7.5 seconds.\n- $1 \\leq C \\leq 30$.\n- $1 \\leq R \\leq 30$.\n- The number of S symbols is between $1$ and $10$.\n- The number of T symbols is between $1$ and $10$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq C \\leq 100$.\n- $1 \\leq R \\leq 100$.\n- The number of S symbols is between $1$ and $100$.\n- The number of T symbols is between $1$ and $100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2017 #2] Shoot the Turrets", "background": "", "description": "The fight to free the city from extraterrestrial invaders is over! People are happy that love and peace have returned.\n\nThe city is represented as a grid with $R$ rows and $C$ columns. Some cells on the grid are buildings (through which nobody can see, nobody can shoot, and nobody can walk), and some are streets (through which everybody can see, shoot and walk). Unfortunately, during the war, the now-defeated invaders set up automatic security turrets in the city. These turrets are only in streets (not in buildings). They pose a threat to the citizens, but fortunately, there are also some soldiers on the streets (not in buildings). Initially, no soldier is in the same place as a turret.\n\nThe invader turrets do not move. They are small, so they don't block sight and shooting. A soldier cannot walk through an active turret's cell, but can walk through it once it is destroyed. A turret can only see soldiers in the cells for which it has a horizontal or vertical line of sight. If a soldier enters such a cell, the turret does not fire. If a soldier attempts to exit such a cell (after entering it, or after starting in that cell), the turret fires. Luckily, a soldier can still shoot from that cell, and the turret will not detect that as movement. It means that none of your soldiers will actually die, because in the worst case they can always wait, motionless, for help (perhaps for a long time). Maybe you will have a chance to rescue them later.\n\nEach soldier can make a total of $M$ unit moves. Each of these moves must be one cell in a horizontal or vertical direction. Soldiers can walk through each other and do not block the lines of sight of other soldiers or turrets. Each soldier also has one bullet. If a soldier has a turret in her horizontal or vertical line of sight, the soldier can shoot and destroy it. Each shot can only destroy one turret, but the soldiers are such excellent shooters that they can even shoot past one or several turrets or soldiers in their line of sight and hit another turret farther away!\n\nYou are given a map (with the soldier and turret positions marked). What is the largest number of turrets that the soldiers can destroy?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing the integer $C$ (the width of the map), $R$ (the height of the map) and $M$ (the number of unit moves each soldier can make). The next $R$ lines contain $C$ characters each, with . representing a street, # representing a building, S representing a soldier and T representing a turret.\n", "outputFormat": "For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of turrets that it is possible to destroy. Then $y$ lines should follow: each should contain two integers $s_i$ and $t_i$ denoting that the $i$th thing that happens should be soldier $s_i$ destroying turret $t_i$ (you don't need to specify exactly how the soldier has to move). If multiple valid strategies exist, you may output any one of them.\n\nSoldiers are numbered from 1, reading from left to right along the top row, then left to right along the next row down from the top, and so on, from top to bottom.", "hint": "**Sample Explanation**\n\nIn Case #2, one of the possible solutions is to move soldier $3$ up three cells and shoot turret $3$. Then soldier $1$ can move up one cell and right one cell (to where turret $3$ was) and shoot past turret $2$ to destroy turret $1$. Finally, soldier $2$ can move up three cells and shoot turret $2$.\n\nIn Case #3, soldier $1$ can move up one cell, then right three cells and shoot turret $2$. Then soldier $2$ can move up one cell, then right three cells and shoot turret $1$. Finally, soldier $6$ can move down one cell, then right three cells and shoot turret $3$. Other soldiers have insufficient move range to shoot any other turrets.\n\nIn Case #4, the soldier cannot move to within the same row or column as the turret, so the turret cannot be destroyed.\n\n**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $0 \\leq M < C \\times R$.\n\n**Small dataset (Test Set 1 - Visible)**\n\n- Time limit: ~~30~~ 7.5 seconds.\n- $1 \\leq C \\leq 30$.\n- $1 \\leq R \\leq 30$.\n- The number of S symbols is between $1$ and $10$.\n- The number of T symbols is between $1$ and $10$.\n\n**Large dataset (Test Set 2 - Hidden)**\n\n- Time limit: ~~60~~ 15 seconds.\n- $1 \\leq C \\leq 100$.\n- $1 \\leq R \\leq 100$.\n- The number of S symbols is between $1$ and $100$.\n- The number of T symbols is between $1$ and $100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2017 #2] Shoot the Turrets", "background": null, "description": "解放城市摆脱外星入侵者的战斗已经结束！人们为爱与和平的回归而欢欣鼓舞。\n\n城市被表示为一个有 $R$ 行 $C$ 列的网格。网格上的某些格子是建筑物（无法看见、无法射击、无法行走），其余格子是街道（可以看见、可以射击、可以行走）。不幸的是，在战争期间，已经被击败的入侵者在城市中设置了自动安保炮台。这些炮台只会出现在街道上（不会在建筑物中）。它们对市民构成威胁，但幸运的是，街道上也有一些士兵（同样不会在建筑物中）。最初，没有任何士兵与炮台处于同一格子。\n\n入侵者的炮台不会移动。它们体积很小，不会阻挡视线和射击。士兵无法穿过一个激活状态的炮台所在的格子，但炮台被摧毁后可以通过。炮台只能看到与自己处于同一行或同一列的士兵。如果士兵进入这样的格子，炮台不会开火；但如果士兵试图离开这样的格子（无论是进入后还是一开始就在该格子），炮台就会开火。幸运的是，士兵仍然可以在该格子射击，炮台不会因为射击而发现士兵的移动。这意味着你的士兵实际上不会阵亡，因为在最坏的情况下，他们总可以静止等待救援（也许会等很久）。或许你以后还有机会去救他们。\n\n每个士兵最多可以进行 $M$ 次单位移动。每次移动只能向上下左右四个方向之一移动一个格子。士兵可以相互穿越，并且不会阻挡其他士兵或炮台的视线。每个士兵还有一颗子弹。如果士兵与某个炮台处于同一行或同一列，并且中间没有建筑物阻挡，则可以射击并摧毁该炮台。每次射击只能摧毁一个炮台，但士兵射击技术高超，即使有一个或多个炮台或士兵在射击路径上，也能击中更远处的炮台！\n\n你将获得一张标记了士兵和炮台位置的地图。请问士兵们最多能摧毁多少个炮台？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为三个整数 $C$（地图宽度）、$R$（地图高度）和 $M$（每个士兵可移动的单位步数）。接下来的 $R$ 行每行包含 $C$ 个字符，`.` 表示街道，`#` 表示建筑物，`S` 表示士兵，`T` 表示炮台。", "outputFormat": "对于每组测试数据，输出一行 `Case #x: y`，其中 $x$ 表示测试用例编号（从 1 开始），$y$ 表示最多可以被摧毁的炮台数量。接下来输出 $y$ 行，每行两个整数 $s_i$ 和 $t_i$，表示第 $i$ 个事件是编号为 $s_i$ 的士兵摧毁编号为 $t_i$ 的炮台（不需要具体说明士兵如何移动）。\n\n士兵的编号从 1 开始，按照从上到下、每行从左到右的顺序编号。炮台的编号同理。", "hint": "**样例解释**\n\n在第 2 组样例中，一种可行的方案是让第 3 号士兵向上移动三格并射击第 3 号炮台。然后第 1 号士兵向上移动一格再向右移动一格（到达第 3 号炮台原本的位置），并穿过第 2 号炮台射击摧毁第 1 号炮台。最后第 2 号士兵向上移动三格并射击第 2 号炮台。\n\n在第 3 组样例中，第 1 号士兵可以向上移动一格，然后向右移动三格并射击第 2 号炮台。第 2 号士兵可以向上移动一格，然后向右移动三格并射击第 1 号炮台。最后第 6 号士兵可以向下移动一格，然后向右移动三格并射击第 3 号炮台。其他士兵的移动步数不足以射击其他炮台。\n\n在第 4 组样例中，士兵无法移动到与炮台同一行或同一列，因此无法摧毁炮台。\n\n**数据范围**\n\n- $1 \\leq T \\leq 100$。\n- $0 \\leq M < C \\times R$。\n\n**小数据集（测试集 1 - 可见）**\n\n- 时间限制：7.5 秒。\n- $1 \\leq C \\leq 30$。\n- $1 \\leq R \\leq 30$。\n- $S$ 的数量在 $1$ 到 $10$ 之间。\n- $T$ 的数量在 $1$ 到 $10$ 之间。\n\n**大数据集（测试集 2 - 隐藏）**\n\n- 时间限制：15 秒。\n- $1 \\leq C \\leq 100$。\n- $1 \\leq R \\leq 100$。\n- $S$ 的数量在 $1$ 到 $100$ 之间。\n- $T$ 的数量在 $1$ 到 $100$ 之间。\n\n由 ChatGPT 4.1 翻译", "locale": "zh-CN"}}}
