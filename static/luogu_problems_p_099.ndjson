{"pid": "P3008", "type": "P", "difficulty": 5, "samples": [["6 3 3 4 \n1 2 5 \n3 4 5 \n5 6 10 \n3 5 -100 \n4 6 -100 \n1 3 -10 \n", "NO PATH \nNO PATH \n5 \n0 \n-95 \n-100 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO", "拓扑排序", "最短路"], "title": "[USACO11JAN] Roads and Planes G", "background": "", "description": "Farmer John is conducting research for a new milk contract in a new territory. He intends to distribute milk to T (1 <= T <= 25,000) towns conveniently numbered 1..T which are connected by up to R (1 <= R <= 50,000) roads conveniently numbered 1..R and/or P (1 <= P <= 50,000) airplane flights conveniently numbered 1..P.\n\nEither road i or plane i connects town A\\_i (1 <= A\\_i <= T) to town B\\_i (1 <= B\\_i <= T) with traversal cost C\\_i. For roads, 0 <= C\\_i <= 10,000; however, due to the strange finances of the airlines, the cost for planes can be quite negative (-10,000 <= C\\_i <= 10,000).\n\nRoads are bidirectional and can be traversed from A\\_i to B\\_i or B\\_i to A\\_i for the same cost; the cost of a road must be non-negative.\n\nPlanes, however, can only be used in the direction from A\\_i to B\\_i specified in the input. In fact, if there is a plane from A\\_i to B\\_i it is guaranteed that there is no way to return from B\\_i to A\\_i with any sequence of roads and planes due to recent antiterror regulation.\n\nFarmer John is known around the world as the source of the world's finest dairy cows. He has in fact received orders for his cows from every single town. He therefore wants to find the cheapest price for delivery to each town from his distribution center in town S (1 <= S <= T) or to know that it is not possible if this is the case.\n\nMEMORY LIMIT: 64MB", "inputFormat": "\\* Line 1: Four space separated integers: T, R, P, and S\n\n\\* Lines 2..R+1: Three space separated integers describing a road: A\\_i, B\\_i and C\\_i\n\n\\* Lines R+2..R+P+1: Three space separated integers describing a plane: A\\_i, B\\_i and C\\_i\n", "outputFormat": "\\* Lines 1..T: The minimum cost to get from town S to town i, or 'NO PATH' if this is not possible\n", "hint": "6 towns.  There are roads between town 1 and town 2, town 3 and town 4, and town 5 and town 6 with costs 5, 5 and 10; there are planes from town 3 to town 5, from town 4 to town 6, and from town 1 to town 3 with costs -100, - 100 and -10.  FJ is based in town 4.\n\n\nFJ's cows begin at town 4, and can get to town 3 on the road.  They can get to towns 5 and 6 using planes from towns 3 and 4.  However, there is no way to get to towns 1 and 2, since they cannot go\n\nbackwards on the plane from 1 to 3.\n", "locale": "en", "translations": {"en": {"title": "[USACO11JAN] Roads and Planes G", "background": "", "description": "Farmer John is conducting research for a new milk contract in a new territory. He intends to distribute milk to T (1 <= T <= 25,000) towns conveniently numbered 1..T which are connected by up to R (1 <= R <= 50,000) roads conveniently numbered 1..R and/or P (1 <= P <= 50,000) airplane flights conveniently numbered 1..P.\n\nEither road i or plane i connects town A\\_i (1 <= A\\_i <= T) to town B\\_i (1 <= B\\_i <= T) with traversal cost C\\_i. For roads, 0 <= C\\_i <= 10,000; however, due to the strange finances of the airlines, the cost for planes can be quite negative (-10,000 <= C\\_i <= 10,000).\n\nRoads are bidirectional and can be traversed from A\\_i to B\\_i or B\\_i to A\\_i for the same cost; the cost of a road must be non-negative.\n\nPlanes, however, can only be used in the direction from A\\_i to B\\_i specified in the input. In fact, if there is a plane from A\\_i to B\\_i it is guaranteed that there is no way to return from B\\_i to A\\_i with any sequence of roads and planes due to recent antiterror regulation.\n\nFarmer John is known around the world as the source of the world's finest dairy cows. He has in fact received orders for his cows from every single town. He therefore wants to find the cheapest price for delivery to each town from his distribution center in town S (1 <= S <= T) or to know that it is not possible if this is the case.\n\nMEMORY LIMIT: 64MB", "inputFormat": "\\* Line 1: Four space separated integers: T, R, P, and S\n\n\\* Lines 2..R+1: Three space separated integers describing a road: A\\_i, B\\_i and C\\_i\n\n\\* Lines R+2..R+P+1: Three space separated integers describing a plane: A\\_i, B\\_i and C\\_i\n", "outputFormat": "\\* Lines 1..T: The minimum cost to get from town S to town i, or 'NO PATH' if this is not possible\n", "hint": "6 towns.  There are roads between town 1 and town 2, town 3 and town 4, and town 5 and town 6 with costs 5, 5 and 10; there are planes from town 3 to town 5, from town 4 to town 6, and from town 1 to town 3 with costs -100, - 100 and -10.  FJ is based in town 4.\n\n\nFJ's cows begin at town 4, and can get to town 3 on the road.  They can get to towns 5 and 6 using planes from towns 3 and 4.  However, there is no way to get to towns 1 and 2, since they cannot go\n\nbackwards on the plane from 1 to 3.\n", "locale": "en"}, "zh-CN": {"title": "[USACO11JAN] Roads and Planes G", "background": null, "description": "Farmer John 正在一个新的销售区域对他的牛奶销售方案进行调查。他想把牛奶送到 $T$ 个城镇（$1 \\le T \\le 25,000$），编号为 $1$ 到 $T$。这些城镇之间通过 $R$ 条道路（$1 \\le R \\le 50,000$，编号为 $1$ 到 $R$）和 $P$ 条航线（$1 \\le P \\le 50,000$，编号为 $1$ 到 $P$）连接。每条道路 $i$ 或者航线 $i$ 连接城镇 $A_i$（$1 \\le A_i \\le T$）到 $B_i$（$1 \\le B_i \\le T$），花费为 $C_i$。\n\n对于道路 $0 \\le C_i \\le 10,000$；然而航线的花费很神奇，花费 $C_i$ 可能是负数（$-10,000 \\le C_i \\le 10,000$）。道路是双向的，可以从 $A_i$ 到 $B_i$，也可以从 $B_i$ 到 $A_i$，花费都是 $C_i$。然而航线与之不同，只可以从 $A_i$ 到 $B_i$。\n\n事实上，由于最近恐怖主义太嚣张，为了社会和谐，出台了一些政策保证：如果有一条航线可以从 $A_i$ 到 $B_i$，那么保证不可能通过一些道路和航线从 $B_i$ 回到 $A_i$。由于 FJ 的奶牛世界公认十分给力，他需要运送奶牛到每一个城镇。他想找到从发送中心城镇 $S$（$1 \\le S \\le T$）把奶牛送到每个城镇的最便宜的方案，或者知道这是不可能的。", "inputFormat": "共 $R+P+1$ 行。\n\n第 $1$ 行：四个整数 $T,R,P$ 和 $S$，分别表示城镇的数量，道路的数量，航线的数量和中心城镇。\n\n第 $2$ 到 $R+1$ 行：每行三个整数 $A_i,B_i$ 和 $C_i$，描述一条道路。\n\n第 $R+2$ 到 $R+P+1$ 行：每行三个整数 $A_i,B_i$ 和 $C_i$，描述一条航线。", "outputFormat": "共 $T$ 行，第 $i$ 行输出城市 $S$ 到城市 $i$ 的最小花费。如果不能到达，输出 `NO PATH`。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3009", "type": "P", "difficulty": 2, "samples": [["7 \n-3 \n4 \n9 \n-2 \n-5 \n8 \n-3 \n", "14 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2011", "USACO"], "title": "[USACO11JAN] Profits S", "background": null, "description": "奶牛们开始了新的生意，它们的主人约翰想知道它们到底能做得多好。这笔生意已经做了 $N(1\\le N\\le 10^5)$ 天，每天奶牛们都会记录下这一天的利润 $P\n_i(\\vert Pi\\vert ≤1,000)$。\n\n约翰想要找到奶牛们在连续的时间期间所获得的最大的总利润。（注：连续时间的周期长度范围从第一天到第 $N$ 天）。\n\n请你写一个计算最大利润的程序来帮助他。", "inputFormat": "第一行，一个单独的整数 $N$。\n\n接下来 $N$ 行，第 $i+1$ 行包括一个单独的整数 $P_i$。", "outputFormat": "一行，一个整数，表示任意连续时间段利润最大和的数值。", "hint": "**【样例解释】**\n\n取区间 $[2,6]$ 的和可以得到最大值 $14$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO11JAN] Profits S", "background": null, "description": "The cows have opened a new business, and Farmer John wants to see how well they are doing. The business has been running for $N (1 \\leq N \\leq 10^5)$ days, and every day i the cows recorded their net profit $P_i (-1,000\\leq P_i \\leq 1,000)$.\n\nFarmer John wants to find the largest total profit that the cows have made during any consecutive time period. (Note that a consecutive time period can range in length from one day through $N$ days.) Help him by writing a program to calculate the largest sum of consecutive profits.", "inputFormat": "- Line $1$: A single integer: $N$.\n\n- Lines $2\\dots N+1$: Line $i+1$ contains a single integer: $P_i$.", "outputFormat": "- Line $1$: A single integer representing the value of the maximum sum of profits for any consecutive time period.", "hint": "The maximum sum is obtained by taking the sum from the second through the sixth number $(4, 9, -2, -5, 8) \\geq 14$.", "locale": "en"}, "zh-CN": {"title": "[USACO11JAN] Profits S", "background": null, "description": "奶牛们开始了新的生意，它们的主人约翰想知道它们到底能做得多好。这笔生意已经做了 $N(1\\le N\\le 10^5)$ 天，每天奶牛们都会记录下这一天的利润 $P\n_i(\\vert Pi\\vert ≤1,000)$。\n\n约翰想要找到奶牛们在连续的时间期间所获得的最大的总利润。（注：连续时间的周期长度范围从第一天到第 $N$ 天）。\n\n请你写一个计算最大利润的程序来帮助他。", "inputFormat": "第一行，一个单独的整数 $N$。\n\n接下来 $N$ 行，第 $i+1$ 行包括一个单独的整数 $P_i$。", "outputFormat": "一行，一个整数，表示任意连续时间段利润最大和的数值。", "hint": "**【样例解释】**\n\n取区间 $[2,6]$ 的和可以得到最大值 $14$。", "locale": "zh-CN"}}}
{"pid": "P3010", "type": "P", "difficulty": 4, "samples": [["5 \n2 \n1 \n8 \n4 \n16 \n", "1 \n1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11JAN] Dividing the Gold S", "background": "", "description": "Bessie and Canmuu found a sack of N (1 <= N <= 250) gold coins that they wish to divide as evenly as possible. Coin i has value v\\_i (1 <= V\\_i <= 2,000). The cows would like to split the pile as evenly as they can, but that is not always possible. What is the smallest difference between the values of the two piles?\n\nIn addition, the Bessie and Canmuu have found that there might be multiple ways to split the piles with that minimum difference. They would also like to know the number of ways to split the coins as fairly as possible. If it isn't possible to split the piles evenly, Bessie will get the higher-valued pile.\n\nBy way of example, consider a sack of five coins of values: 2, 1, 8, 4, and 16. Bessie and Canmuu split the coins into two piles, one pile with one coin worth 16, and the other pile with the remaining coins worth 1+2+4+8=15. Therefore the difference is 16-15 = 1.  This is the only way for them to split the coins this way, so the number of ways to split it evenly is just 1.\n\nNote that same-valued coins can be switched among the piles to increase the number of ways to perform an optimal split. Thus, the set of coins {1, 1, 1, 1} has six different ways to split into two optimal partitions, each with two coins.", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: V\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the smallest difference of two partitions.\n\n\\* Line 2: A single integer that is the number of ways to split the coins with the minimum difference printed in line 1. Since this number can get quite large, print the remainder when divided by 1,000,000.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11JAN] Dividing the Gold S", "background": "", "description": "Bessie and Canmuu found a sack of N (1 <= N <= 250) gold coins that they wish to divide as evenly as possible. Coin i has value v\\_i (1 <= V\\_i <= 2,000). The cows would like to split the pile as evenly as they can, but that is not always possible. What is the smallest difference between the values of the two piles?\n\nIn addition, the Bessie and Canmuu have found that there might be multiple ways to split the piles with that minimum difference. They would also like to know the number of ways to split the coins as fairly as possible. If it isn't possible to split the piles evenly, Bessie will get the higher-valued pile.\n\nBy way of example, consider a sack of five coins of values: 2, 1, 8, 4, and 16. Bessie and Canmuu split the coins into two piles, one pile with one coin worth 16, and the other pile with the remaining coins worth 1+2+4+8=15. Therefore the difference is 16-15 = 1.  This is the only way for them to split the coins this way, so the number of ways to split it evenly is just 1.\n\nNote that same-valued coins can be switched among the piles to increase the number of ways to perform an optimal split. Thus, the set of coins {1, 1, 1, 1} has six different ways to split into two optimal partitions, each with two coins.", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains a single integer: V\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the smallest difference of two partitions.\n\n\\* Line 2: A single integer that is the number of ways to split the coins with the minimum difference printed in line 1. Since this number can get quite large, print the remainder when divided by 1,000,000.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11JAN] Dividing the Gold S", "background": null, "description": "Bessie 和 Canmuu 找到了一袋 $N (1 \\leq N \\leq 250)$ 枚金币，他们希望尽可能均匀地分配这些金币。第 $i$ 枚金币的价值为 $v_i (1 \\leq v_i \\leq 2,000)$。奶牛们希望尽可能均匀地分割这堆金币，但这并不总是可能的。两个堆之间的最小价值差是多少？\n\n此外，Bessie 和 Canmuu 发现可能有多种方法以该最小差异分割金币。他们还想知道以最公平方式分割金币的方法数。如果无法均匀分割，Bessie 将得到价值较高的一堆。\n\n例如，考虑一袋五枚金币，价值分别为：$2、1、8、4$ 和 $16$。Bessie 和 Canmuu 将金币分成两堆，一堆有一枚价值为 16 的金币，另一堆有剩下的金币，价值为 $1+2+4+8=15$。因此，差异为 $16-15 = 1$。这是他们以这种方式分割金币的唯一方法，所以均匀分割的方法数只有 $1$。\n\n注意，相同价值的金币可以在堆之间交换，以增加执行最佳分割的方法数。因此，硬币集合 $\\{1, 1, 1, 1\\}$ 有六种不同的方法分割成两个最佳分区，每个分区有两枚硬币。", "inputFormat": "第 1 行：一个整数：$N$。\n\n第 2 行到第 $N+1$ 行：第 $i+1$ 行包含一个整数：$V_i$。", "outputFormat": "第 1 行：一个整数，表示两个分区的最小差异。\n\n第 2 行：一个整数，表示以第 1 行打印的最小差异分割金币的方法数。由于这个数可能会非常大，输出时请对 $1,000,000$ 取余。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3011", "type": "P", "difficulty": 6, "samples": [["1 4 \n4 5 \nB 2 16 99 \nP 6 32 13 \nP 2 87 4 \nP 38 96 49 \n1 2 4 \n1 3 40 \n2 3 75 \n2 4 76 \n3 4 77 \n", "127 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11JAN] Traffic Lights S", "background": "征求翻译。如果你能提供翻译或者题意简述，请直接发讨论，感谢你的贡献。\n", "description": "Kenosha, the city nearest Farmer John, has M (1 <= M <= 14,000) roads conveniently numbered 1..M that connect N (2 <= N <= 300) junctions which are conveniently numbered 1..N. No two roads connect the same pair of junctions. No road connects a junction to itself. The integer travel time T\\_ij (1 <= T\\_ij <= 100) between junctions i and j is the same for both directions (i.e., T\\_ij = T\\_ji).\n\nEach junction has a single traffic light with two colors: blue or purple. The color of each light alternates periodically: blue for certain duration and then purple for another duration.  Traffic is permitted to commence travel down the road between any two junctions, if and only if the lights at both junctions are the same color at the moment of departing from one junction for the other.  The lights do not necessarily have to be the same on the whole trip down the road.\n\nIf a vehicle arrives at a junction just at the moment the lights switch it must consider the new colors of lights. Vehicles are allowed to wait at the junctions. You are given the city map which shows:\n\n```cpp\n                                    Init  Remg  Blue   Purple\n       4       76         Junction  Color Time  Cycle  Cycle\n>>[1B]===[2P]======          1        B    2     16      99\n    |   /          \\         2        P    6     32      13\n  40|  /75          \\        3        P    2     87       4\n    | /              \\       4        P   38     96      49\n  [3P]===============[4P]>>\n           77\n```\n```cpp\n* The travel times T_ij for all roads \n* The durations of the two colors at junction i. (DB_i (1 <= DB_i <= 100) for the blue light and DP_i (1 <= DP_i <= 100) for the purple light) \n* The initial color C_i of the light at junction i (a letter 'B' or 'P' with the obvious meaning) and the remaining time R_i (1 <= R_i <= 100) for this color to change \nFind the minimum time one needs to get from a given source S (1 <= S <= N) to a given destination D (1 <= D <= N; D != S). \nConsider the map below with four junctions and five roads. FJ wants to travel from junction 1 to junction 4. The first light is blue; the rest are purple. \n```\nThe minimum time is 127 utilizing the path 1-2-4.\nInitially, the light at junction 1 is blue. Since the light at junction 2 is purple, vehicle waits at junction 1 for 2 seconds then travels 4 seconds to junction 2.\n\nAt time 6, the light at junction 2 switches to blue whereas the light at junction 4 has 32 more seconds to switch to blue. However, after 32 seconds, the light at junction 2 switches to purple and the light at junction 4 switches to blue at the same time. So the vehicle needs to wait 13 seconds more for junction 2 to switch to blue then the lights have the same color and vehicle travels 76 seconds to the destination junction 4.\n\nThe total time is 2+4+32+13+76=127 seconds. \n\nBelow is a more graphical presentation of this travel plan:\n\n```cpp\n                                                                                                      1    1    1    1    1    1\n             1    1    2    2    3    3    4    4    5    5    6    6    7    7    8    8    9    9    0    0    1    1    2    2\n   0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5..\n   --------------------------------------------------------------------------------------------------------------------------------\nJ1 BBBPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPBBBBBBBBBBBBBBBBPPPPPPPPPP\nJ2 PPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBPPPPPPPPPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBPPPPPPPPPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nJ3 PPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nJ4 PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nFJ 1..>>>2............................................>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>4\n```", "inputFormat": "\\* Line 1: Two space-separated integers: S and D\n\n\\* Line 2: Two space-separated integers: N and M\n\n\\* Lines 3..N+2: Line i+2 line describes junction i with a character and three integers (all separated by a single space): C\\_i, R\\_i, DB\\_i, and DP\\_i\n\n\\* Lines N+3..N+M+2: Line N+2+k describes road k with three integers: i, j, and T\\_ij\n", "outputFormat": "\\* Line 1: One integer: the time taken by a minimum-time path from the source junction to the destination junction. If there is no path, output 0.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11JAN] Traffic Lights S", "background": "征求翻译。如果你能提供翻译或者题意简述，请直接发讨论，感谢你的贡献。\n", "description": "Kenosha, the city nearest Farmer John, has M (1 <= M <= 14,000) roads conveniently numbered 1..M that connect N (2 <= N <= 300) junctions which are conveniently numbered 1..N. No two roads connect the same pair of junctions. No road connects a junction to itself. The integer travel time T\\_ij (1 <= T\\_ij <= 100) between junctions i and j is the same for both directions (i.e., T\\_ij = T\\_ji).\n\nEach junction has a single traffic light with two colors: blue or purple. The color of each light alternates periodically: blue for certain duration and then purple for another duration.  Traffic is permitted to commence travel down the road between any two junctions, if and only if the lights at both junctions are the same color at the moment of departing from one junction for the other.  The lights do not necessarily have to be the same on the whole trip down the road.\n\nIf a vehicle arrives at a junction just at the moment the lights switch it must consider the new colors of lights. Vehicles are allowed to wait at the junctions. You are given the city map which shows:\n\n```cpp\n                                    Init  Remg  Blue   Purple\n       4       76         Junction  Color Time  Cycle  Cycle\n>>[1B]===[2P]======          1        B    2     16      99\n    |   /          \\         2        P    6     32      13\n  40|  /75          \\        3        P    2     87       4\n    | /              \\       4        P   38     96      49\n  [3P]===============[4P]>>\n           77\n```\n```cpp\n* The travel times T_ij for all roads \n* The durations of the two colors at junction i. (DB_i (1 <= DB_i <= 100) for the blue light and DP_i (1 <= DP_i <= 100) for the purple light) \n* The initial color C_i of the light at junction i (a letter 'B' or 'P' with the obvious meaning) and the remaining time R_i (1 <= R_i <= 100) for this color to change \nFind the minimum time one needs to get from a given source S (1 <= S <= N) to a given destination D (1 <= D <= N; D != S). \nConsider the map below with four junctions and five roads. FJ wants to travel from junction 1 to junction 4. The first light is blue; the rest are purple. \n```\nThe minimum time is 127 utilizing the path 1-2-4.\nInitially, the light at junction 1 is blue. Since the light at junction 2 is purple, vehicle waits at junction 1 for 2 seconds then travels 4 seconds to junction 2.\n\nAt time 6, the light at junction 2 switches to blue whereas the light at junction 4 has 32 more seconds to switch to blue. However, after 32 seconds, the light at junction 2 switches to purple and the light at junction 4 switches to blue at the same time. So the vehicle needs to wait 13 seconds more for junction 2 to switch to blue then the lights have the same color and vehicle travels 76 seconds to the destination junction 4.\n\nThe total time is 2+4+32+13+76=127 seconds. \n\nBelow is a more graphical presentation of this travel plan:\n\n```cpp\n                                                                                                      1    1    1    1    1    1\n             1    1    2    2    3    3    4    4    5    5    6    6    7    7    8    8    9    9    0    0    1    1    2    2\n   0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5..\n   --------------------------------------------------------------------------------------------------------------------------------\nJ1 BBBPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPBBBBBBBBBBBBBBBBPPPPPPPPPP\nJ2 PPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBPPPPPPPPPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBPPPPPPPPPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nJ3 PPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nJ4 PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nFJ 1..>>>2............................................>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>4\n```", "inputFormat": "\\* Line 1: Two space-separated integers: S and D\n\n\\* Line 2: Two space-separated integers: N and M\n\n\\* Lines 3..N+2: Line i+2 line describes junction i with a character and three integers (all separated by a single space): C\\_i, R\\_i, DB\\_i, and DP\\_i\n\n\\* Lines N+3..N+M+2: Line N+2+k describes road k with three integers: i, j, and T\\_ij\n", "outputFormat": "\\* Line 1: One integer: the time taken by a minimum-time path from the source junction to the destination junction. If there is no path, output 0.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11JAN] Traffic Lights S", "background": null, "description": "和FJ靠的最近的城市Kenosha市有 $M$ 条道路。(编号为 $1-M$) 连接着 $N$ 个路口 (编号为 $1-N$) 。保证没有重边和自环。 \n\n从点 $i$ 到点 $j$ 需要的时间是 $T_{i,j}$， 且保证 $T_{i,j}$ = $T_{j,i}$\n\n每个路口有一个交通灯，有两种颜色：蓝色和紫色。两个颜色周期性的交替。蓝色持续一定时间，然后紫色持续一定时间。\n\n想要从 $i$ 到 $j$ 只有在 $i$ 和 $j$ 的信号灯颜色相同的时候才可以走(从 T1 时刻离开 $i$ 走向 $j$，只需 T1 时刻 $i$ 与 $j$ 的颜色相同即可，无其他任何约束。)\n\n如果在变幻灯的那一秒到 $j$，考虑的是变幻后的颜色。\n给你所有第 $i$ 个路口的蓝色灯持续时间 $DB_i$ 和紫色灯持续时间 $DP_i$ 和每个路口刚开始灯的颜色 $C_i$,剩余持续时间 $R_i$。\n\n求一个给定的原点 $S$ 到给定目标点 $D$ 的最小时间。", "inputFormat": "* 第 1 行两个整数 $S$ 和 $D$。\n * 第 2 行两个整数 $N$ 和 $M$。\n * 第 3 至 $N+2$ 行。第 $i+2$ 行描述点 $i$ 的信号灯情况 $C_i$，$R_i$，$DB_i$，$DP_i$。\n * 第 $N+3$ 至 $N+M+2$ 行：第 $N+2+k$ 行描述第 $k$ 条道路 : $i$，$j$，$T_{i,j}$。", "outputFormat": "* 一个整数代表从 $S$ 到 $D$ 最少消耗的时间， 如果 $S$、$D$ 不连通，输出 0。\n\n感谢@ToBiChi 提供翻译", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3012", "type": "P", "difficulty": 4, "samples": [["2 2 7 \nAB \nab \nBA \nba \nAa \nBb \nbB \n", "7 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11FEB] Cowlphabet G", "background": null, "description": "Like all bovines, Farmer John's cows speak the peculiar 'Cow'\n\nlanguage. Like so many languages, each word in this language comprises a sequence of upper and lowercase letters (A-Z and a-z).  A word is valid if and only if each ordered pair of adjacent letters in the word is a valid pair.\n\nFarmer John, ever worried that his cows are plotting against him, recently tried to eavesdrop on their conversation. He overheard one word before the cows noticed his presence. The Cow language is spoken so quickly, and its sounds are so strange, that all that Farmer John was able to perceive was the total number of uppercase letters, $U$ ($1 \\leq U \\leq 250$) and the total number of lowercase letters, $L$ ($1 \\leq L \\leq 250$) in the word. \n\nFarmer John knows all $P$ ($1 \\leq P \\leq 200$) valid ordered pairs of adjacent letters.  He wishes to know how many different valid words are consistent with his limited data.  However, since this number may be very large, he only needs the value modulo $97654321$.\n\n约翰家的奶牛用别人听不懂的“牛语”联络。牛语采用英文字母，而且区分大小写。牛语中的语法中，前后字母的衔接非常重要，存在 $P$ 个基本组合，每个字母之后只能接固定的几个字母。约翰担心奶牛正在密谋反对他，于是最近一直在偷听她们的对话。可是牛语太复杂了，他只模模糊糊地听到了一个单词，并确定了这个单词中有 $U$（$1 \\leq U \\leq 250$）个大写字母，$L$（$1 \\leq L \\leq 250$）个小写字母。约翰对这个单词很在意，他想知道，有多少牛语词汇拥有 $U$ 个大写字母，$L$ 个小写字母。由于这个数字太大了，你只要输出答案取 $97654321$ 的余数就可以了。", "inputFormat": "- Line 1: Three space-separated integers: U, L and P.\n\n - 第一行：三个用空格分开的整数 $U$，$L$ 和 $P$。\n\n - Lines 2..P+1: Two letters (each of which may be uppercase or lowercase), representing one valid ordered pair of adjacent letters in Cow.\n\n - 第二至 $P+1$ 行：两个字母 $A_i$ 和 $B_i$，表示字母 $A_i$ 后面可以接 $B_i$，没有一对 $A_i$ 和 $B_i$ 是完全相同的。", "outputFormat": "- Line 1: A single integer, the number of valid words consistent with Farmer John's data mod $97654321$.\n\n - 第一行：单独一个整数，与 FJ 的数据吻合的单词数模 $97654321$ 的值。", "hint": "The word Farmer John overheard had 2 uppercase and 2 lowercase letters.  The valid pairs of adjacent letters are AB, ab, BA, ba, Aa, Bb and bB.\n\n\nThe possible words are:\n\nAabB\nABba\nabBA\nBAab\nBbBb\nbBAa\nbBbB", "locale": "zh-CN", "translations": {"en": {"title": "[USACO11FEB] Cowlphabet G", "background": "", "description": "Like all bovines, Farmer John's cows speak the peculiar \"Cow\" language. As in many languages, each word in this language is a sequence of uppercase and lowercase letters (A-Z and a-z). A word is valid if and only if each ordered pair of adjacent letters in the word is a valid pair.\n\nFarmer John, ever worried that his cows are plotting against him, recently tried to eavesdrop on their conversation. He overheard one word before the cows noticed his presence. The Cow language is spoken so quickly, and its sounds are so strange, that all Farmer John was able to perceive was the total number of uppercase letters, $U$ ($1 \\leq U \\leq 250$), and the total number of lowercase letters, $L$ ($1 \\leq L \\leq 250$), in the word.\n\nFarmer John knows all $P$ ($1 \\leq P \\leq 200$) valid ordered pairs of adjacent letters. He wishes to know how many different valid words are consistent with his limited data. However, since this number may be very large, he only needs the value modulo $97654321$.", "inputFormat": "- Line 1: Three space-separated integers: $U$, $L$, and $P$.\n- Lines 2 to $P+1$: Two letters $A_i$ and $B_i$ (each of which may be uppercase or lowercase), representing one valid ordered pair of adjacent letters in Cow, meaning $A_i$ can be followed by $B_i$. No ordered pair appears more than once.", "outputFormat": "- Line 1: A single integer, the number of valid words consistent with Farmer John's data, modulo $97654321$.", "hint": "The word Farmer John overheard had 2 uppercase and 2 lowercase letters. The valid pairs of adjacent letters are AB, ab, BA, ba, Aa, Bb and bB.\n\nThe possible words are:\nAabB\nABba\nabBA\nBAab\nBbBb\nbBAa\nbBbB\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO11FEB] Cowlphabet G", "background": null, "description": "Like all bovines, Farmer John's cows speak the peculiar 'Cow'\n\nlanguage. Like so many languages, each word in this language comprises a sequence of upper and lowercase letters (A-Z and a-z).  A word is valid if and only if each ordered pair of adjacent letters in the word is a valid pair.\n\nFarmer John, ever worried that his cows are plotting against him, recently tried to eavesdrop on their conversation. He overheard one word before the cows noticed his presence. The Cow language is spoken so quickly, and its sounds are so strange, that all that Farmer John was able to perceive was the total number of uppercase letters, $U$ ($1 \\leq U \\leq 250$) and the total number of lowercase letters, $L$ ($1 \\leq L \\leq 250$) in the word. \n\nFarmer John knows all $P$ ($1 \\leq P \\leq 200$) valid ordered pairs of adjacent letters.  He wishes to know how many different valid words are consistent with his limited data.  However, since this number may be very large, he only needs the value modulo $97654321$.\n\n约翰家的奶牛用别人听不懂的“牛语”联络。牛语采用英文字母，而且区分大小写。牛语中的语法中，前后字母的衔接非常重要，存在 $P$ 个基本组合，每个字母之后只能接固定的几个字母。约翰担心奶牛正在密谋反对他，于是最近一直在偷听她们的对话。可是牛语太复杂了，他只模模糊糊地听到了一个单词，并确定了这个单词中有 $U$（$1 \\leq U \\leq 250$）个大写字母，$L$（$1 \\leq L \\leq 250$）个小写字母。约翰对这个单词很在意，他想知道，有多少牛语词汇拥有 $U$ 个大写字母，$L$ 个小写字母。由于这个数字太大了，你只要输出答案取 $97654321$ 的余数就可以了。", "inputFormat": "- Line 1: Three space-separated integers: U, L and P.\n\n - 第一行：三个用空格分开的整数 $U$，$L$ 和 $P$。\n\n - Lines 2..P+1: Two letters (each of which may be uppercase or lowercase), representing one valid ordered pair of adjacent letters in Cow.\n\n - 第二至 $P+1$ 行：两个字母 $A_i$ 和 $B_i$，表示字母 $A_i$ 后面可以接 $B_i$，没有一对 $A_i$ 和 $B_i$ 是完全相同的。", "outputFormat": "- Line 1: A single integer, the number of valid words consistent with Farmer John's data mod $97654321$.\n\n - 第一行：单独一个整数，与 FJ 的数据吻合的单词数模 $97654321$ 的值。", "hint": "The word Farmer John overheard had 2 uppercase and 2 lowercase letters.  The valid pairs of adjacent letters are AB, ab, BA, ba, Aa, Bb and bB.\n\n\nThe possible words are:\n\nAabB\nABba\nabBA\nBAab\nBbBb\nbBAa\nbBbB", "locale": "zh-CN"}}}
{"pid": "P3013", "type": "P", "difficulty": 5, "samples": [["4 3 \n4 4 1 3 \n1 3 2 4 \n4 2 3 1 \n", "1 \n2 \n1 \n2 \n3 \n1 \n3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2011", "USACO", "Special Judge", "广度优先搜索 BFS", "深度优先搜索 DFS"], "title": "[USACO11FEB] The Lost Cows G", "background": "", "description": "One sunny day farmer John was kidnapped by evil farmer Marcus's cows. FJ wasn't too concerned about his forced holiday but wanted to make sure that his cows got home safely together.\n\nThe cows are spread out in every one of FJ's N (3 <= N <= 200) pastures conveniently numbered 1..N. The barn is located at pasture 1. The farm has an interesting navigation system: at every pasture i there are M (1 <= M <= 200) signs S\\_ij (1 <= S\\_ij <= N) which one could reference as S\\_i1..S\\_iM; each sign points the way to a pasture. Sometimes a sign points to a path that leads back to the same\n\npasture.\n\nFarmer Marcus's cows allow FJ to write a single message to all of his cows. FJ's plan is to write a list of sign numbers such that any cow who follows those instructions will all arrive at the barn when each cow has completed all the instructions.\n\nWhen a cow starts at a given pasture then she will first follow the path indicated by the first sign number on FJ's list. When she arrives at the second pasture, she looks at the second sign of FJ's list and follows the path marked by that sign. She continues until she exhausts the instruction list, at which point she should be at the barn.\n\nFind a list of instructions containing no more than 5,000,000 sign numbers that will guide every cow, from every pasture, to the barn after all instructions are followed.  It is guaranteed that such a list exists.\n\nConsider a set of three signs in four pastures that direct the cows like these do:\n\n```cpp\n** Pasture# ** \n1    2    3    4 \nSign 1   4    4    1    3 \nSign 2   1    3    2    4 \nSign 3   4    2    3    1 \n```\nThe set of instructions below will direct cows to the barn from any of the four pastures:\n\n```cpp\nInstruction#   Sign#            Instruction#   Sign# \n1           1                   5           3 \n2           2                   6           1 \n3           1                   7           3 \n4           2 \n```\nThe cow in pasture 1 will read sign #1 at time 1 and be directed to pasture 4.  At time 2, she is in pasture 4 and (per FJ's\n\ninstructions) read sign #2 and then be directed to pasture 4. Below is a table that shows the cow's travels:\n\n```cpp\n* * * *  Cow in pasture  1  * * * * \nTime    CurrentPasture#    WhichSign     Sign->Nextpasture \n1            1               1                4 \n2            4               2                4 (same pasture!) \n3            4               1                3 \n4            3               2                2 \n5            2               3                2 (same pasture)\n6            2               1                4 \n7            4               3                1 Barn! \n```\nSimilarly: Pasture 2's cow visits pastures [2]-4-4-3-2-2-4-1. Pasture 3's cow visits pastures [3]-1-1-4-4-1-4-1.\n\nPasture 4's cow visits pastures [4]-3-2-4-4-1-4-1.\n\n\nGiven a set of signs, create a set of instructions. \n", "inputFormat": "\\* Line 1: Two space separated integers: N and M\n\n\\* Lines 2..M+1: Line i+1 describes the contents of each pasture's N signs with N integers: S\\_1i..S\\_Ni\n", "outputFormat": "\\* Lines 1..?: The sign numbers the cows should follow, one per line.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11FEB] The Lost Cows G", "background": "", "description": "One sunny day farmer John was kidnapped by evil farmer Marcus's cows. FJ wasn't too concerned about his forced holiday but wanted to make sure that his cows got home safely together.\n\nThe cows are spread out in every one of FJ's N (3 <= N <= 200) pastures conveniently numbered 1..N. The barn is located at pasture 1. The farm has an interesting navigation system: at every pasture i there are M (1 <= M <= 200) signs S\\_ij (1 <= S\\_ij <= N) which one could reference as S\\_i1..S\\_iM; each sign points the way to a pasture. Sometimes a sign points to a path that leads back to the same\n\npasture.\n\nFarmer Marcus's cows allow FJ to write a single message to all of his cows. FJ's plan is to write a list of sign numbers such that any cow who follows those instructions will all arrive at the barn when each cow has completed all the instructions.\n\nWhen a cow starts at a given pasture then she will first follow the path indicated by the first sign number on FJ's list. When she arrives at the second pasture, she looks at the second sign of FJ's list and follows the path marked by that sign. She continues until she exhausts the instruction list, at which point she should be at the barn.\n\nFind a list of instructions containing no more than 5,000,000 sign numbers that will guide every cow, from every pasture, to the barn after all instructions are followed.  It is guaranteed that such a list exists.\n\nConsider a set of three signs in four pastures that direct the cows like these do:\n\n```cpp\n** Pasture# ** \n1    2    3    4 \nSign 1   4    4    1    3 \nSign 2   1    3    2    4 \nSign 3   4    2    3    1 \n```\nThe set of instructions below will direct cows to the barn from any of the four pastures:\n\n```cpp\nInstruction#   Sign#            Instruction#   Sign# \n1           1                   5           3 \n2           2                   6           1 \n3           1                   7           3 \n4           2 \n```\nThe cow in pasture 1 will read sign #1 at time 1 and be directed to pasture 4.  At time 2, she is in pasture 4 and (per FJ's\n\ninstructions) read sign #2 and then be directed to pasture 4. Below is a table that shows the cow's travels:\n\n```cpp\n* * * *  Cow in pasture  1  * * * * \nTime    CurrentPasture#    WhichSign     Sign->Nextpasture \n1            1               1                4 \n2            4               2                4 (same pasture!) \n3            4               1                3 \n4            3               2                2 \n5            2               3                2 (same pasture)\n6            2               1                4 \n7            4               3                1 Barn! \n```\nSimilarly: Pasture 2's cow visits pastures [2]-4-4-3-2-2-4-1. Pasture 3's cow visits pastures [3]-1-1-4-4-1-4-1.\n\nPasture 4's cow visits pastures [4]-3-2-4-4-1-4-1.\n\n\nGiven a set of signs, create a set of instructions. \n", "inputFormat": "\\* Line 1: Two space separated integers: N and M\n\n\\* Lines 2..M+1: Line i+1 describes the contents of each pasture's N signs with N integers: S\\_1i..S\\_Ni\n", "outputFormat": "\\* Lines 1..?: The sign numbers the cows should follow, one per line.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11FEB] The Lost Cows G", "background": "", "description": "给定一张 $n(3\\leq n\\leq 200)$ 个点的图，每个点都恰好有 $m(1\\leq m\\leq 200)$ 条出边，第 $i$ 个点的第 $j$ 条出边指向 $a_{i,j}$。\n\n现在这张图上每个点都有一头牛。每次你可以报出一个数 $x(1\\leq x\\leq m)$，这会使得每一头牛沿着当前所在的点的第 $x$ 条边走一步（即当前在点 $u$ 的牛移动到点 $a_{u,x}$）。\n\n你需要发出不超过 $5\\times 10^6$ 条指令，使得在所有的指令执行完后，所有的牛都在编号为 $1$ 的点上。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $m$ 行每行 $n$ 个整数，第 $i$ 行的第 $j$ 个整数是 $a_{j,i}$。", "outputFormat": "在第 $i$ 行输出你发出的第 $i$ 条指令。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3014", "type": "P", "difficulty": 4, "samples": [["5 2 \nP \n3 \nQ \n1 2 5 3 4 \n", "1 2 4 3 5 \n5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2011", "USACO", "枚举", "康托展开"], "title": "[USACO11FEB] Cow Line S", "background": "", "description": "The N (1 <= N <= 20) cows conveniently numbered 1...N are playing yet another one of their crazy games with Farmer John. The cows will arrange themselves in a line and ask Farmer John what their line number is. In return, Farmer John can give them a line number and the cows must rearrange themselves into that line.\n\nA line number is assigned by numbering all the permutations of the line in lexicographic order.\n\nConsider this example:\n\nFarmer John has 5 cows and gives them the line number of 3.\n\nThe permutations of the line in ascending lexicographic order: 1st: 1 2 3 4 5\n\n2nd: 1 2 3 5 4\n\n3rd: 1 2 4 3 5\n\nTherefore, the cows will line themselves in the cow line 1 2 4 3 5.\n\nThe cows, in return, line themselves in the configuration '1 2 5 3 4' and ask Farmer John what their line number is.\n\nContinuing with the list:\n\n4th : 1 2 4 5 3\n\n5th : 1 2 5 3 4\n\nFarmer John can see the answer here is 5\n\nFarmer John and the cows would like your help to play their game. They have K (1 <= K <= 10,000) queries that they need help with. Query i has two parts: C\\_i will be the command, which is either 'P' or 'Q'.\n\nIf C\\_i is 'P', then the second part of the query will be one integer A\\_i (1 <= A\\_i <= N!), which is a line number. This is Farmer John challenging the cows to line up in the correct cow line.\n\nIf C\\_i is 'Q', then the second part of the query will be N distinct integers B\\_ij (1 <= B\\_ij <= N). This will denote a cow line. These are the cows challenging Farmer John to find their line number.\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..2\\*K+1: Line 2\\*i and 2\\*i+1 will contain a single query.\n\nLine 2\\*i will contain just one character: 'Q' if the cows are lining up and asking Farmer John for their line number or 'P' if Farmer John gives the cows a line number.\n\nIf the line 2\\*i is 'Q', then line 2\\*i+1 will contain N space-separated integers B\\_ij which represent the cow line. If the line 2\\*i is 'P', then line 2\\*i+1 will contain a single integer A\\_i which is the line number to solve for.\n", "outputFormat": "\\* Lines 1..K: Line i will contain the answer to query i.\n\nIf line 2\\*i of the input was 'Q', then this line will contain a single integer, which is the line number of the cow line in line 2\\*i+1.\n\nIf line 2\\*i of the input was 'P', then this line will contain N space separated integers giving the cow line of the number in line 2\\*i+1.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11FEB] Cow Line S", "background": "", "description": "The N (1 <= N <= 20) cows conveniently numbered 1...N are playing yet another one of their crazy games with Farmer John. The cows will arrange themselves in a line and ask Farmer John what their line number is. In return, Farmer John can give them a line number and the cows must rearrange themselves into that line.\n\nA line number is assigned by numbering all the permutations of the line in lexicographic order.\n\nConsider this example:\n\nFarmer John has 5 cows and gives them the line number of 3.\n\nThe permutations of the line in ascending lexicographic order: 1st: 1 2 3 4 5\n\n2nd: 1 2 3 5 4\n\n3rd: 1 2 4 3 5\n\nTherefore, the cows will line themselves in the cow line 1 2 4 3 5.\n\nThe cows, in return, line themselves in the configuration '1 2 5 3 4' and ask Farmer John what their line number is.\n\nContinuing with the list:\n\n4th : 1 2 4 5 3\n\n5th : 1 2 5 3 4\n\nFarmer John can see the answer here is 5\n\nFarmer John and the cows would like your help to play their game. They have K (1 <= K <= 10,000) queries that they need help with. Query i has two parts: C\\_i will be the command, which is either 'P' or 'Q'.\n\nIf C\\_i is 'P', then the second part of the query will be one integer A\\_i (1 <= A\\_i <= N!), which is a line number. This is Farmer John challenging the cows to line up in the correct cow line.\n\nIf C\\_i is 'Q', then the second part of the query will be N distinct integers B\\_ij (1 <= B\\_ij <= N). This will denote a cow line. These are the cows challenging Farmer John to find their line number.\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..2\\*K+1: Line 2\\*i and 2\\*i+1 will contain a single query.\n\nLine 2\\*i will contain just one character: 'Q' if the cows are lining up and asking Farmer John for their line number or 'P' if Farmer John gives the cows a line number.\n\nIf the line 2\\*i is 'Q', then line 2\\*i+1 will contain N space-separated integers B\\_ij which represent the cow line. If the line 2\\*i is 'P', then line 2\\*i+1 will contain a single integer A\\_i which is the line number to solve for.\n", "outputFormat": "\\* Lines 1..K: Line i will contain the answer to query i.\n\nIf line 2\\*i of the input was 'Q', then this line will contain a single integer, which is the line number of the cow line in line 2\\*i+1.\n\nIf line 2\\*i of the input was 'P', then this line will contain N space separated integers giving the cow line of the number in line 2\\*i+1.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11FEB] Cow Line S", "background": null, "description": "编号为 $1$ 到 $N (1 \\leq N \\leq 20)$ 的 $N$ 头奶牛正在和农夫约翰玩他们的又一个疯狂游戏。奶牛们将自己排列成一行，并询问农夫约翰它们的排列编号是多少。作为回应，农夫约翰可以给它们一个排列编号，奶牛们必须重新排列成那个排列。\n\n排列编号是通过按字典序给所有排列编号来分配的。\n\n考虑这个例子：\n\n农夫约翰有 $5$ 头奶牛，并给它们排列编号 $3$ 。\n\n按升序字典序排列的排列：第 $1$ 个：$1,2,3,4,5$\n\n第 $2$ 个：$1,2,3,5,4$\n\n第 $3$ 个：$1,2,4,3,5$\n\n因此，奶牛们将自己排列成奶牛排列 $1,2,4,3,5$。\n\n奶牛们反过来排列成配置「$1,2,5,3,4$」，并询问农夫约翰它们的排列编号是多少。\n\n继续列表：\n\n第 $4$ 个：$1,2,4,5,3$\n\n第 $5$ 个：$1,2,5,3,4$\n\n农夫约翰可以看到答案是 $5$ 。\n\n农夫约翰和奶牛们希望你能帮助他们玩这个游戏。他们有 $K (1 \\leq K \\leq 10,000)$ 个查询需要帮助。查询 $i$ 有两个部分：$C_i$ 是命令，可以是 `P` 或 `Q` 。\n\n如果 $C_i$ 是 `P` ，那么查询的第二部分将是一个整数 $A_i (1 \\leq A_i \\leq N!)$，这是一个排列编号。这是农夫约翰挑战奶牛们排成正确的奶牛排列。\n\n如果 $C_i$ 是 `Q`，那么查询的第二部分将是 $N$ 个不同的整数 $B_{ij} (1 \\leq B_{ij} \\leq N)$。这将表示一个奶牛排列。这是奶牛们挑战农夫约翰找出它们的排列编号。", "inputFormat": "\\* 第 $1$ 行：两个用空格分隔的整数：$N$ 和 $K$\n\n\\* 第 $2$ 行到第 $2 \\times K + 1$ 行：第 $2 \\times i$ 行和第 $2 \\times i + 1$ 行将包含一个查询。\n\n第 $2 \\times i$ 行将只包含一个字符：如果奶牛们排列并询问农夫约翰它们的排列编号，则为 `Q`；如果农夫约翰给奶牛们一个排列编号，则为 `P`。\n\n如果第 $2 \\times i$ 行是 `Q`，那么第 $2 \\times i + 1$ 行将包含 $N$ 个用空格分隔的整数 $B_ij$，表示奶牛排列。如果第 $2 \\times i$ 行是 `P`，那么第 $2 \\times i + 1$ 行将包含一个整数 $A_i$，这是要解决的排列编号。", "outputFormat": "\\* 第 $1$ 行到第 $K$ 行：第 $i$ 行将包含查询 $i$ 的答案。\n\n如果输入的第 $2 \\times i$ 行是 `Q`，那么这一行将包含一个整数，即第 $2 \\times i + 1$ 行中奶牛排列的排列编号。\n\n如果输入的第 $2 \\times i$ 行是 `P`，那么这一行将包含 $N$ 个用空格分隔的整数，给出第 $2 \\times i + 1$ 行中编号的奶牛排列。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3015", "type": "P", "difficulty": 3, "samples": [["6 \n0 \n0 \n1 \n1 \n0 \n1 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "字符串", "2011", "USACO", "栈"], "title": "[USACO11FEB] Best Parenthesis S", "background": null, "description": "给定一个只包含左右括号的字符串，得分规则如下：\n\n如果一对括号内没有括号，那么这对括号的得分为1；如果两对括号互不包含（即并列存在），那这两对括号的得分相加；如果括号内包含一对括号，那么这个括号的得分记为内部括号序列的得分 $\\times 2$。\n\n例如：对于这样一个字符串：`() ()`，两对括号并列存在，则得分为 $1+1=2$;\n\n而对于这样一个字符串：`(())`，最外层的括号内层包含一对括号，则得分为 $2 \\times 1 = 2$。\n\n\nBessie 想击败所有同事的牛，所以她需要计算某个字符串的评分。给定一个长度为 $n$ 、只包含括号的字符串（$2 \\le N \\le 100000$），计算其得分帮助 Bessie。", "inputFormat": "第一行，输入一个整数 $n$。  \n接下来 $n$ 行，每行一个数字，如果是 $0$，表示这个字符是 `(`；如果是 $1$，表示这个字符是 `)`。", "outputFormat": "字符串的分数，由于数字可能会变得很大，所以对 $12345678910$ 取模。", "hint": "样例的字符串是 `(())()`。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO11FEB] Best Parenthesis S", "background": null, "description": "Recently, the cows have been competing with strings of balanced parentheses and comparing them with each other to see who has the best one.\n\nSuch strings are scored as follows (all strings are balanced): the string '()' has score 1; if 'A' has score s(A) then '(A)' has score 2\\*s(A); and if 'A' and 'B' have scores s(A) and s(B), respectively, then 'AB' has score s(A)+s(B). For example, s('(())()') = s('(())')+s('()') = 2\\*s('()')+1 = 2\\*1+1 = 3.\n\nBessie wants to beat all of her fellow cows, so she needs to calculate the score of some strings. Given a string of balanced parentheses of length N (2 <= N <= 100,000), help Bessie compute its score.", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N + 1: Line i+1 will contain 1 integer: 0 if the ith character of the string is '(',  and 1 if the ith character of the string is ')'", "outputFormat": "\\* Line 1: The score of the string. Since this number can get quite large, output the  score modulo 12345678910.", "hint": "This corresponds to the string \"(())()\". \n\nAs discussed above.", "locale": "en"}, "zh-CN": {"title": "[USACO11FEB] Best Parenthesis S", "background": null, "description": "给定一个只包含左右括号的字符串，得分规则如下：\n\n如果一对括号内没有括号，那么这对括号的得分为1；如果两对括号互不包含（即并列存在），那这两对括号的得分相加；如果括号内包含一对括号，那么这个括号的得分记为内部括号序列的得分 $\\times 2$。\n\n例如：对于这样一个字符串：`() ()`，两对括号并列存在，则得分为 $1+1=2$;\n\n而对于这样一个字符串：`(())`，最外层的括号内层包含一对括号，则得分为 $2 \\times 1 = 2$。\n\n\nBessie 想击败所有同事的牛，所以她需要计算某个字符串的评分。给定一个长度为 $n$ 、只包含括号的字符串（$2 \\le N \\le 100000$），计算其得分帮助 Bessie。", "inputFormat": "第一行，输入一个整数 $n$。  \n接下来 $n$ 行，每行一个数字，如果是 $0$，表示这个字符是 `(`；如果是 $1$，表示这个字符是 `)`。", "outputFormat": "字符串的分数，由于数字可能会变得很大，所以对 $12345678910$ 取模。", "hint": "样例的字符串是 `(())()`。", "locale": "zh-CN"}}}
{"pid": "P3016", "type": "P", "difficulty": 3, "samples": [["3 2 \n5 \n-8 4 \n2 -3 6 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11FEB] The Triangle S", "background": "", "description": "\nFor her spectacular milk output for the previous month, Farmer John has awarded Bessie a prize -- with a twist.  He has given her a triangular grid with N (1 <= N <= 700) rows (whose lengths vary from 1 through N, of course). Row i of the the grid has i values labeled v\\_ij (-1,000,000,000 <= v\\_ij <= 1,000,000,000) where j is in the range 1..i.\n\nBessie chooses a sub-triangle whose side length is at least K (1 <= K <= 20; 1 <= K <= N) within the triangular grid. The sub-triangle is another triangular grid which might be oriented the same as the original triangle or might be 'upside down' with its shorter rows on the bottom instead of the top.\n\nAfter she chooses her sub-triangle, Farmer John will take the average of all the numbers in the sub-triangle, discarding the digits to the right of the decimal point, and give her that many gold coins (or take that many gold coins from her if the number is negative). Naturally, Bessie would like to maximize her prize (or minimize her loss). Help her solve this problem.\n\nBy way of example, Bessie is given this triangular grid with N = 3 rows and must choose a sub-triangle with a side length of at least K = 2. A graphical representation of the triangle is shown below:\n\n```cpp\n    / \\\n   / 5 \\\n  /-8  4\\\n /2 -3  6\\\n ---------\n```\nShe could choose any of five valid sub-triangles (one of which is the entire original triangle):\n\n```cpp\n                                                   /\\\n    / \\         / \\        / \\         / \\        /5 \\       \n   / 5 \\       / \\5\\      / 5 \\       / 5/\\      /----\\    \n  /-8  4\\     /-8 \\4\\    /-8  4\\     /-8/ 4\\    /\\-8 4/\\ \n /2 -3  6\\   / 2 -3\\6\\  /-------\\   / 2/-3 6\\  / 2\\-3/6 \\ \n ---------   ---------  -2  -3  6   ---------  ----------  \n  entire      lower        top          lower     upside\n triangle     left                      right      down\n```\nThe one that is lined below is the one with the highest average:\n\n```cpp\n    / \\\n   / 5/\\\n  /-8/ 4\\\n / 2/-3 6\\\n ---------\n```\nThe average of this sub-triangle is (4+6-3)/3, which is about\n\n2.3333...; without the fraction, the answer is 2. \n\nHelp Bessie calculate the maximum amount of coins which she could receive.", "inputFormat": "\n\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..N+1: Line i+1 will contain i space-separated integers: v\\_ij", "outputFormat": "\n\\* Line 1: The maximum number of coins that Bessie can receive (or, if negative, the best she can do for her loss).\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11FEB] The Triangle S", "background": "", "description": "\nFor her spectacular milk output for the previous month, Farmer John has awarded Bessie a prize -- with a twist.  He has given her a triangular grid with N (1 <= N <= 700) rows (whose lengths vary from 1 through N, of course). Row i of the the grid has i values labeled v\\_ij (-1,000,000,000 <= v\\_ij <= 1,000,000,000) where j is in the range 1..i.\n\nBessie chooses a sub-triangle whose side length is at least K (1 <= K <= 20; 1 <= K <= N) within the triangular grid. The sub-triangle is another triangular grid which might be oriented the same as the original triangle or might be 'upside down' with its shorter rows on the bottom instead of the top.\n\nAfter she chooses her sub-triangle, Farmer John will take the average of all the numbers in the sub-triangle, discarding the digits to the right of the decimal point, and give her that many gold coins (or take that many gold coins from her if the number is negative). Naturally, Bessie would like to maximize her prize (or minimize her loss). Help her solve this problem.\n\nBy way of example, Bessie is given this triangular grid with N = 3 rows and must choose a sub-triangle with a side length of at least K = 2. A graphical representation of the triangle is shown below:\n\n```cpp\n    / \\\n   / 5 \\\n  /-8  4\\\n /2 -3  6\\\n ---------\n```\nShe could choose any of five valid sub-triangles (one of which is the entire original triangle):\n\n```cpp\n                                                   /\\\n    / \\         / \\        / \\         / \\        /5 \\       \n   / 5 \\       / \\5\\      / 5 \\       / 5/\\      /----\\    \n  /-8  4\\     /-8 \\4\\    /-8  4\\     /-8/ 4\\    /\\-8 4/\\ \n /2 -3  6\\   / 2 -3\\6\\  /-------\\   / 2/-3 6\\  / 2\\-3/6 \\ \n ---------   ---------  -2  -3  6   ---------  ----------  \n  entire      lower        top          lower     upside\n triangle     left                      right      down\n```\nThe one that is lined below is the one with the highest average:\n\n```cpp\n    / \\\n   / 5/\\\n  /-8/ 4\\\n / 2/-3 6\\\n ---------\n```\nThe average of this sub-triangle is (4+6-3)/3, which is about\n\n2.3333...; without the fraction, the answer is 2. \n\nHelp Bessie calculate the maximum amount of coins which she could receive.", "inputFormat": "\n\\* Line 1: Two space-separated integers: N and K\n\n\\* Lines 2..N+1: Line i+1 will contain i space-separated integers: v\\_ij", "outputFormat": "\n\\* Line 1: The maximum number of coins that Bessie can receive (or, if negative, the best she can do for her loss).\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11FEB] The Triangle S", "background": null, "description": "农夫 FJ 颁给 Bessie 一个奇怪的奖项，以奖励她前几个月壮观的牛奶产量。他给她一个 $N$ 行的三角形网格（当然，三角形网格每行是 $1$ 到 $N$ 之间递增）。网格中第 $i$ 行有 $i$ 个数，数值为 $v_{i,j}$（$-10^9\\le v_{i,j}\\le 10^9$），其中 $j$ 为 $1\\sim i$ 的数列。\n\nBessie 在这个三角形网格中选择了一个行数至少为 $K$ 的子三角形网格（$1 \\le K \\le N \\le 700$，$1\\le K\\le 20$）。子三角形网格有可能和原来的三角形朝向相反，即子三角形网格朝向的较短行对应原来三角形的较长行。\n\nBessie 选择完子三角形网格后，FJ 会将子三角形中的所有数值求平均数，并抹除小数，然后给 Bessie 相对应的金币（若平均值为负，则从 Bessie 处拿相应的金币），Bessie 想要取得最大的利益（或最小的代价），请你帮她解决问题\n\n例如，Bessie 被给了一个 $N=5,K=3$ 的三角形网格。这个问题的图像为:\n\n```cpp\n    / \\\n   / 5 \\\n  /-8  4\\\n /2 -3  6\\\n ---------\n```\n她可以选择 $5$ 个子三角形的任意一个\n\n```cpp\n                                                   /\\\n    / \\         / \\        / \\         / \\        /5 \\       \n   / 5 \\       / \\5\\      / 5 \\       / 5/\\      /----\\    \n  /-8  4\\     /-8 \\4\\    /-8  4\\     /-8/ 4\\    /\\-8 4/\\ \n /2 -3  6\\   / 2 -3\\6\\  /-------\\   / 2/-3 6\\  / 2\\-3/6 \\ \n ---------   ---------  -2  -3  6   ---------  ----------  \n  三角形      左下          顶部         右下      中间\n   整体                          \n```\n这是平均值最大的一组:\n\n```cpp\n    / \\\n   / 5/\\\n  /-8/ 4\\\n / 2/-3 6\\\n ---------\n```\n这个子三角形的平均值为 $(4-3+6)\\div3$，等于 $2.\\dot3$（即 $2.333\\dots$），所以答案为 $2$。\n\n帮助 Bessie 求出她可获得金币的最大值。\n\n**时简限制**: 2 秒。\n\n**空间限制**: 32 MB。", "inputFormat": "* 第一行两个用空格隔开的正整数 $N,K$。\n* 第 $2\\sim N$ 行，$i+1$ 行输入 $i$ 个用空格隔开的整数 $v_{i,j}$。", "outputFormat": "* 一行，输出 Bessie 得到的金币最大值（可能为负）。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P3017", "type": "P", "difficulty": 5, "samples": [["5 4 4 2 \n1 2 2 1 \n3 1 1 1 \n2 0 1 3 \n1 1 1 1 \n1 1 1 1 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "二分", "USACO", "枚举", "前缀和"], "title": "[USACO11MAR] Brownie Slicing G", "background": "", "description": "Bessie has baked a rectangular brownie that can be thought of as an RxC grid (1 <= R <= 500; 1 <= C <= 500) of little brownie squares. The square at row i, column j contains N\\_ij (0 <= N\\_ij <= 4,000) chocolate chips.\n\nBessie wants to partition the brownie up into A\\*B chunks (1 <= A <= R; 1 <= B <= C): one for each of the A\\*B cows. The brownie is cut by first making A-1 horizontal cuts (always along integer\n\ncoordinates) to divide the brownie into A strips.  Then cut each strip \\*independently\\* with B-1 vertical cuts, also on integer\n\nboundaries. The other A\\*B-1 cows then each choose a brownie piece, leaving the last chunk for Bessie. Being greedy, they leave Bessie the brownie that has the least number of chocolate chips on it.\n\nDetermine the maximum number of chocolate chips Bessie can receive, assuming she cuts the brownies optimally.\n\nAs an example, consider a 5 row x 4 column brownie with chips\n\ndistributed like this:\n```\n1 2 2 1\n3 1 1 1\n2 0 1 3\n1 1 1 1\n1 1 1 1\n```\n\nBessie must partition the brownie into 4 horizontal strips, each with two pieces. Bessie can cut the brownie like this:\n\n```\n1 2 | 2 1\n---------\n3 | 1 1 1\n---------\n2 0 1 | 3\n---------\n1 1 | 1 1\n1 1 | 1 1\n```\n\nThus, when the other greedy cows take their brownie piece, Bessie still gets 3 chocolate chips.", "inputFormat": "\\* Line 1: Four space-separated integers: R, C, A, and B\n\n\\* Lines 2..R+1: Line i+1 contains C space-separated integers: N\\_i1, ..., N\\_iC\n", "outputFormat": "\\* Line 1: A single integer: the maximum number of chocolate chips that Bessie guarantee on her brownie\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11MAR] Brownie Slicing G", "background": "", "description": "Bessie has baked a rectangular brownie that can be thought of as an RxC grid (1 <= R <= 500; 1 <= C <= 500) of little brownie squares. The square at row i, column j contains N\\_ij (0 <= N\\_ij <= 4,000) chocolate chips.\n\nBessie wants to partition the brownie up into A\\*B chunks (1 <= A <= R; 1 <= B <= C): one for each of the A\\*B cows. The brownie is cut by first making A-1 horizontal cuts (always along integer\n\ncoordinates) to divide the brownie into A strips.  Then cut each strip \\*independently\\* with B-1 vertical cuts, also on integer\n\nboundaries. The other A\\*B-1 cows then each choose a brownie piece, leaving the last chunk for Bessie. Being greedy, they leave Bessie the brownie that has the least number of chocolate chips on it.\n\nDetermine the maximum number of chocolate chips Bessie can receive, assuming she cuts the brownies optimally.\n\nAs an example, consider a 5 row x 4 column brownie with chips\n\ndistributed like this:\n```\n1 2 2 1\n3 1 1 1\n2 0 1 3\n1 1 1 1\n1 1 1 1\n```\n\nBessie must partition the brownie into 4 horizontal strips, each with two pieces. Bessie can cut the brownie like this:\n\n```\n1 2 | 2 1\n---------\n3 | 1 1 1\n---------\n2 0 1 | 3\n---------\n1 1 | 1 1\n1 1 | 1 1\n```\n\nThus, when the other greedy cows take their brownie piece, Bessie still gets 3 chocolate chips.", "inputFormat": "\\* Line 1: Four space-separated integers: R, C, A, and B\n\n\\* Lines 2..R+1: Line i+1 contains C space-separated integers: N\\_i1, ..., N\\_iC\n", "outputFormat": "\\* Line 1: A single integer: the maximum number of chocolate chips that Bessie guarantee on her brownie\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11MAR] Brownie Slicing G", "background": "", "description": "Bessie 烤了一个长方形的布朗尼，可以看作是一个 $R \\times C$ 的网格（$1 \\le R \\le 500$；$1 \\le C \\le 500$），由小方块组成。在第 $i$ 行，第 $j$ 列的方块中有 $N_{ij}$（$0 \\le N_{ij} \\le 4,000$）颗巧克力豆。\n\nBessie 想把布朗尼分成 $A \\times B$ 块（$1 \\le A \\le R$；$1 \\le B \\le C$）：每头牛一块。布朗尼的切割方式是先进行 $A-1$ 次水平切割（总是在整数坐标上），将布朗尼分成 $A$ 条带。然后每条带独立地进行 $B-1$ 次垂直切割，也是在整数边界上。其他 $A \\times B - 1$ 头牛各自选择一块布朗尼，剩下最后一块给 Bessie。由于它们很贪心，它们会把巧克力豆最少的一块留给 Bessie。\n\n假设 Bessie 以最优方式切割布朗尼，求 Bessie 能获得的最多巧克力豆数。\n\n例如，考虑一个 5 行 4 列的布朗尼，巧克力豆分布如下：\n```\n1 2 2 1\n3 1 1 1\n2 0 1 3\n1 1 1 1\n1 1 1 1\n```\n\nBessie 必须将布朗尼分成 4 条水平带，每条带有两块。Bessie 可以这样切割布朗尼：\n\n```\n1 2 | 2 1\n---------\n3 | 1 1 1\n---------\n2 0 1 | 3\n---------\n1 1 | 1 1\n1 1 | 1 1\n```\n\n因此，当其他贪心的牛选择它们的布朗尼块时，Bessie 仍然可以得到 3 颗巧克力豆。", "inputFormat": "\\* 第 1 行：四个用空格分隔的整数：$R$，$C$，$A$ 和 $B$\n\n\\* 第 2 行到第 $R+1$ 行：第 $i+1$ 行包含 $C$ 个用空格分隔的整数：$N_{i1}, ..., N_{iC}$", "outputFormat": "\\* 第 1 行：一个整数：Bessie 在她的布朗尼上能保证获得的最多巧克力豆数", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3018", "type": "P", "difficulty": 4, "samples": [["5 \n-1 9 3 \n1 2 2 \n5 3 2 \n5 1 4 \n2 3 3 \n", "20 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11MAR] Tree Decoration G", "background": "", "description": "Farmer John is decorating his Spring Equinox Tree (like a Christmas tree but popular about three months later). It can be modeled as a rooted mathematical tree with N (1 <= N <= 100,000) elements, labeled 1...N, with element 1 as the root of the tree. Each tree element e > 1 has a parent, P\\_e (1 <= P\\_e <= N). Element 1 has no parent (denoted '-1' in the input), of course, because it is the root of the tree.\n\nEach element i has a corresponding subtree (potentially of size 1) rooted there. FJ would like to make sure that the subtree corresponding to element i has a total of at least C\\_i (0 <= C\\_i <= 10,000,000) ornaments scattered among its members. He would also like to minimize the total amount of time it takes him to place all the ornaments (it takes time K\\*T\\_i to place K ornaments at element i (1 <= T\\_i <= 100)).\n\nHelp FJ determine the minimum amount of time it takes to place ornaments that satisfy the constraints.  Note that this answer might not fit into a 32-bit integer, but it will fit into a signed 64-bit integer.\n\nFor example, consider the tree below where nodes located higher on the display are parents of connected lower nodes (1 is the root):\n\n```cpp\nFor example, consider the tree below where nodes located higher on\nthe display are parents of connected lower nodes (1 is the root):\n\n               1 \n               |\n               2\n               |\n               5\n              / \\\n             4   3\n\nSuppose that FJ has the following subtree constraints:\n\n                  Minimum ornaments the subtree requires\n                    |     Time to install an ornament\n       Subtree      |       |\n        root   |   C_i  |  T_i\n       --------+--------+-------\n          1    |    9   |   3\n          2    |    2   |   2\n          3    |    3   |   2\n          4    |    1   |   4\n          5    |    3   |   3\n\nThen FJ can place all the ornaments as shown below, for a total\ncost of 20:\n\n            1 [0/9(0)]     legend: element# [ornaments here/\n            |                      total ornaments in subtree(node install time)]\n            2 [3/9(6)]\n            |\n            5 [0/6(0)]\n           / \\\n [1/1(4)] 4   3 [5/5(10)]\n```", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains three space-separated integers: P\\_i, C\\_i, and T\\_i\n", "outputFormat": "\\* Line 1: A single integer: The minimum time to place all the\n\nornaments\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11MAR] Tree Decoration G", "background": "", "description": "Farmer John is decorating his Spring Equinox Tree (like a Christmas tree but popular about three months later). It can be modeled as a rooted mathematical tree with N (1 <= N <= 100,000) elements, labeled 1...N, with element 1 as the root of the tree. Each tree element e > 1 has a parent, P\\_e (1 <= P\\_e <= N). Element 1 has no parent (denoted '-1' in the input), of course, because it is the root of the tree.\n\nEach element i has a corresponding subtree (potentially of size 1) rooted there. FJ would like to make sure that the subtree corresponding to element i has a total of at least C\\_i (0 <= C\\_i <= 10,000,000) ornaments scattered among its members. He would also like to minimize the total amount of time it takes him to place all the ornaments (it takes time K\\*T\\_i to place K ornaments at element i (1 <= T\\_i <= 100)).\n\nHelp FJ determine the minimum amount of time it takes to place ornaments that satisfy the constraints.  Note that this answer might not fit into a 32-bit integer, but it will fit into a signed 64-bit integer.\n\nFor example, consider the tree below where nodes located higher on the display are parents of connected lower nodes (1 is the root):\n\n```cpp\nFor example, consider the tree below where nodes located higher on\nthe display are parents of connected lower nodes (1 is the root):\n\n               1 \n               |\n               2\n               |\n               5\n              / \\\n             4   3\n\nSuppose that FJ has the following subtree constraints:\n\n                  Minimum ornaments the subtree requires\n                    |     Time to install an ornament\n       Subtree      |       |\n        root   |   C_i  |  T_i\n       --------+--------+-------\n          1    |    9   |   3\n          2    |    2   |   2\n          3    |    3   |   2\n          4    |    1   |   4\n          5    |    3   |   3\n\nThen FJ can place all the ornaments as shown below, for a total\ncost of 20:\n\n            1 [0/9(0)]     legend: element# [ornaments here/\n            |                      total ornaments in subtree(node install time)]\n            2 [3/9(6)]\n            |\n            5 [0/6(0)]\n           / \\\n [1/1(4)] 4   3 [5/5(10)]\n```", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains three space-separated integers: P\\_i, C\\_i, and T\\_i\n", "outputFormat": "\\* Line 1: A single integer: The minimum time to place all the\n\nornaments\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11MAR] Tree Decoration G", "background": "", "description": "给定一颗以 $1$ 为根的有根树，第 $i$ 个结点的父结点为 $P_i$（$P_1=-1$），在第 $i$ 个结点上挂一个装饰物的代价为 $T_i$，每个结点可以挂任意个。现在给定每棵树子树中至少挂的装饰物个数 $C_i$，求满足要求的最少花费。\n\n$1 \\leq n \\leq 10^5$，$1 \\leq T_i \\leq 100$，$1 \\leq C_i \\leq 10^7$，请注意要开 long long。", "inputFormat": "第一行一个整数 $n$。\n\n第 $1$ 行至第 $n$ 行，在第 $i+1$ 行有三个整数，分别表示 $P_i$，$C_i$ 和 $T_i$。", "outputFormat": "一行一个整数表示最小花费。\n\n### 样例解释\n```\n样例中给出的树如下：\n               1 \n               |\n               2\n               |\n               5\n              / \\\n             4   3\n\n给定如下数据：\n\n                  该子树中所需的装饰物个数\n                    |     在该节点挂一个装饰物的花费\n                    |       |\n       结点编号 |   C_i  |  T_i\n       --------+--------+-------\n          1    |    9   |   3\n          2    |    2   |   2\n          3    |    3   |   2\n          4    |    1   |   4\n          5    |    3   |   3\n\n最佳方案如下：\n\n            1 [0/9(0)]\n            |\n            2 [3/9(6)]\n            |\n            5 [0/6(0)]\n           / \\\n [1/1(4)] 4   3 [5/5(10)]\n\n（格式：[在此处挂的装饰物个数/子树中装饰物总数(在此结点花费代价)]）\n```", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3019", "type": "P", "difficulty": 3, "samples": [["9 6 \n1 \n1 \n2 \n8 \n1 \n8 \n6 \n6 \n2 7 \n4 2 \n3 3 \n4 1 \n7 5 \n9 5 \n", "1 \n2 \n3 \n1 \n8 \n6 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11MAR] Meeting Place S", "background": "", "description": "Bessie and Jonell are great friends. Since Farmer John scrambles where the cows graze every day, they are sometimes quite far from each other and can't talk.\n\nThe pastures and paths on FJ's farm form a 'tree' structure.  Each pasture has exactly one distinct path to any other pasture, and each pasture (except pasture #1, the 'root') also has a single parent node.\n\nBessie and Jonell have decided that they will always meet at the closest pasture that that is both an ancestor of Jonell's pasture and of Bessie's pasture.\n\nFJ created a map of his N (1 <= N <= 1,000) pastures (conveniently numbered 1..N) that tells the parent P\\_i (1 <= P\\_i <= N) of each pasture except pasture 1, which has no parent.\n\nFJ has released his daily grazing schedule for the next M (1 <= M <= 1,000) days, so Bessie and Jonell are deciding where they should meet each day for gossip. On day k, Bessie is in pasture B\\_k (1 <= B\\_k <= N) and Jonell is in pasture J\\_k (1 <= J\\_k <= N).\n\nGiven a map and schedule, help Bessie and Jonell find their meeting places.\n\n```cpp\nConsider, for example, the following farm layout:\n\n                            Pasture      Parent Pasture\n             [1]           ---------    ----------------\n            / | \\              1              ---\n           /  |  \\             2               1 \n         [2] [3] [6]           3               1\n         /        | \\          4               2\n        /         |  \\         5               8\n      [4]        [8]  [9]      6               1\n                /   \\          7               8\n               /     \\         8               6\n             [5]     [7]       9               6\n\nHere are the meeting places that Bessie and Jonell would choose\ngiven a six day schedule of their initial grazing locations:\n\n              Bessie      Jonell       Meeting Place\n             --------    --------     ---------------\n                 2           7               1\n                 4           2               2\n                 1           1               1\n                 4           1               1\n                 7           5               8\n                 9           5               6\n```\n\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N: Line i contains a single integer that describes the parent of pasture i:  P\\_i\n\n\\* Lines N+1..N+M: Line k+N describes Bessie and Jonell's respective pastures with two space-separated integers: B\\_k and J\\_k\n\n\n", "outputFormat": "\\* Lines 1..M: Line j contains the meeting place Bessie and Jonell would use for line j+N of the input\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11MAR] Meeting Place S", "background": "", "description": "Bessie and Jonell are great friends. Since Farmer John scrambles where the cows graze every day, they are sometimes quite far from each other and can't talk.\n\nThe pastures and paths on FJ's farm form a 'tree' structure.  Each pasture has exactly one distinct path to any other pasture, and each pasture (except pasture #1, the 'root') also has a single parent node.\n\nBessie and Jonell have decided that they will always meet at the closest pasture that that is both an ancestor of Jonell's pasture and of Bessie's pasture.\n\nFJ created a map of his N (1 <= N <= 1,000) pastures (conveniently numbered 1..N) that tells the parent P\\_i (1 <= P\\_i <= N) of each pasture except pasture 1, which has no parent.\n\nFJ has released his daily grazing schedule for the next M (1 <= M <= 1,000) days, so Bessie and Jonell are deciding where they should meet each day for gossip. On day k, Bessie is in pasture B\\_k (1 <= B\\_k <= N) and Jonell is in pasture J\\_k (1 <= J\\_k <= N).\n\nGiven a map and schedule, help Bessie and Jonell find their meeting places.\n\n```cpp\nConsider, for example, the following farm layout:\n\n                            Pasture      Parent Pasture\n             [1]           ---------    ----------------\n            / | \\              1              ---\n           /  |  \\             2               1 \n         [2] [3] [6]           3               1\n         /        | \\          4               2\n        /         |  \\         5               8\n      [4]        [8]  [9]      6               1\n                /   \\          7               8\n               /     \\         8               6\n             [5]     [7]       9               6\n\nHere are the meeting places that Bessie and Jonell would choose\ngiven a six day schedule of their initial grazing locations:\n\n              Bessie      Jonell       Meeting Place\n             --------    --------     ---------------\n                 2           7               1\n                 4           2               2\n                 1           1               1\n                 4           1               1\n                 7           5               8\n                 9           5               6\n```\n\n\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N: Line i contains a single integer that describes the parent of pasture i:  P\\_i\n\n\\* Lines N+1..N+M: Line k+N describes Bessie and Jonell's respective pastures with two space-separated integers: B\\_k and J\\_k\n\n\n", "outputFormat": "\\* Lines 1..M: Line j contains the meeting place Bessie and Jonell would use for line j+N of the input\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11MAR] Meeting Place S", "background": null, "description": "贝西和乔内尔是好朋友。由于农夫约翰每天都会重新安排奶牛的放牧地点，有时他们相距甚远，无法交谈。\n\n农夫约翰的农场上的牧场和路径形成了一种「树」结构。每个牧场到其他任何牧场都有且仅有一条独特的路径，并且每个牧场（除了牧场 #1，即「根」）都有一个父节点。\n\n贝西和乔内尔决定，他们总是会在一个既是乔内尔牧场的祖先又是贝西牧场的祖先的最近的牧场见面。\n\n农夫约翰创建了一张他的 $N (1 \\le N \\le 1,000)$ 个牧场（编号为 $1$ 到 $N$）的地图，地图上标明了每个牧场的父节点 $P_i (1 \\le P_i \\le N)$，除了牧场 $1$，它没有父节点。\n\n农夫约翰发布了他未来 $M (1 \\le M \\le 1,000)$ 天的放牧计划，因此贝西和乔内尔正在决定他们每天应该在哪里见面进行闲聊。在第 $k$ 天，贝西在牧场 $B_k (1 \\le B_k \\le N)$，乔内尔在牧场 $J_k (1 \\le J_k \\le N)$。\n\n给定地图和计划，帮助贝西和乔内尔找到他们的会面地点。\n\n例如，考虑以下农场布局：\n\n```plain\n                            牧场      父牧场\n             [1]           ---------    ----------------\n            / | \\              1              ---\n           /  |  \\             2               1 \n         [2] [3] [6]           3               1\n         /        | \\          4               2\n        /         |  \\         5               8\n      [4]        [8]  [9]      6               1\n                /   \\          7               8\n               /     \\         8               6\n             [5]     [7]       9               6\n```\n\n以下是贝西和乔内尔在给定六天的初始放牧地点计划时选择的会面地点：\n\n```plain\n              贝西      乔内尔       会面地点\n             --------    --------     ---------------\n                 2           7               1\n                 4           2               2\n                 1           1               1\n                 4           1               1\n                 7           5               8\n                 9           5               6\n```", "inputFormat": "* 第 $1$ 行：两个用空格分隔的整数：$N$ 和 $M$\n* 第 $2$ 行到第 $N$ 行：第 $i$ 行包含一个整数，描述牧场 $i$ 的父牧场：$P_i$\n* 第 $N+1$ 行到第 $N+M$ 行：第 $k+N$ 行描述贝西和乔内尔各自所在的牧场，用两个空格分隔的整数：$B_k$ 和 $J_k$", "outputFormat": "* 第 $1$ 行到第 $M$ 行：第 $j$ 行包含贝西和乔内尔在输入的第 $j+N$ 行使用的会面地点", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3020", "type": "P", "difficulty": 3, "samples": [["6 8 \n4 5 3 \n2 4 0 \n4 1 4 \n2 1 1 \n5 6 1 \n3 6 2 \n3 2 6 \n3 4 4 \n", "5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO", "最短路"], "title": "[USACO11MAR] Package Delivery S", "background": "", "description": "Farmer John must deliver a package to Farmer Dan, and is preparing to make his journey. To keep the peace, he gives a tasty treat to every cow that he meets along his way and, of course, FJ is so frugal that he would like to encounter as few cows as possible.\n\n农夫约翰必须送一个包裹给农夫丹，并准备去旅行。为了保持和平，他必须给每一头遇到的奶牛一些吃的，当然，FJ很节俭，他想可能遇到尽可能少的奶牛。\n\nFJ has plotted a map of N (1 <= N <= 50,000) barns, connected by M (1 <= M <= 50,000) bi-directional cow paths, each with C\\_i (0 <= C\\_i <= 1,000) cows ambling along it. A cow path connects two distinct barns, A\\_i and B\\_i (1 <= A\\_i <= N; 1 <= B\\_i <= N; A\\_i != B\\_i). Two barns may be directly connected by more than one path. He is currently located at barn 1, and Farmer Dan is located at barn N.\n\nFJ 已经绘制了 $N(1 \\le N \\le 50000)$ 个谷仓的地图，通过 $M(1 \\le M \\le 50000)$ 条双向牛道，每条双向牛道上有 $c[i](0 \\le c[i] \\le 1000)$ 奶牛漫步。双向牛道连接两个不同的谷仓，$a[i]$ 和 $b[i](1 \\le a[i] \\le N,1 \\le b[i] \\le N, a[i] \\neq b[i])$。两个谷仓可以由一条以上的小路直接连接。他目前在 $1$ 号谷仓，农夫丹位于 $N$ 号谷仓。\n\nConsider the following map:\n\n```cpp\n           [2]---\n          / |    \\\n         /1 |     \\ 6\n        /   |      \\\n     [1]   0|    --[3]\n        \\   |   /     \\2\n        4\\  |  /4      [6]\n          \\ | /       /1\n           [4]-----[5] \n                3  \n```\nThe best path for Farmer John to take is to go from 1 -> 2 -> 4 -> 5 -> 6, because it will cost him 1 + 0 + 3 + 1 = 5 treats.\n\nGiven FJ's map, what is the minimal number of treats that he should bring with him, given that he will feed each distinct cow he meets exactly one treat? He does not care about the length of his journey.\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Three space-separated integers: A\\_i, B\\_i, and C\\_i\n", "outputFormat": "\\* Line 1: The minimum number of treats that FJ must bring\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO11MAR] Package Delivery S", "background": "", "description": "Farmer John must deliver a package to Farmer Dan and is preparing to set out. To keep the peace, he gives a tasty treat to every cow he meets along the way, and since FJ is frugal, he wants to encounter as few cows as possible.\n\nFJ has a map of $N(1 \\le N \\le 50000)$ barns connected by $M(1 \\le M \\le 50000)$ bidirectional cow paths. Each path $i$ has $c[i](0 \\le c[i] \\le 1000)$ cows ambling along it. A cow path connects two distinct barns $a[i]$ and $b[i]$ with $1 \\le a[i] \\le N$, $1 \\le b[i] \\le N$, and $a[i] \\ne b[i]$. Two barns may be directly connected by more than one path. He is currently at barn $1$, and Farmer Dan is at barn $N$.\n\nConsider the following map:\n\n```cpp\n           [2]---\n          / |    \\\n         /1 |     \\ 6\n        /   |      \\\n     [1]   0|    --[3]\n        \\   |   /     \\2\n        4\\  |  /4      [6]\n          \\ | /       /1\n           [4]-----[5] \n                3  \n```\n\nThe best path for Farmer John is 1 -> 2 -> 4 -> 5 -> 6, because it will cost him 1 + 0 + 3 + 1 = 5 treats.\n\nGiven FJ’s map, what is the minimal number of treats he should bring, assuming he feeds each distinct cow he meets exactly one treat? He does not care about the length of his journey.", "inputFormat": "- Line 1: Two space-separated integers: N and M.\n- Lines 2 to M+1: Three space-separated integers: A_i, B_i, and C_i.", "outputFormat": "- Line 1: The minimum number of treats that FJ must bring.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO11MAR] Package Delivery S", "background": "", "description": "Farmer John must deliver a package to Farmer Dan, and is preparing to make his journey. To keep the peace, he gives a tasty treat to every cow that he meets along his way and, of course, FJ is so frugal that he would like to encounter as few cows as possible.\n\n农夫约翰必须送一个包裹给农夫丹，并准备去旅行。为了保持和平，他必须给每一头遇到的奶牛一些吃的，当然，FJ很节俭，他想可能遇到尽可能少的奶牛。\n\nFJ has plotted a map of N (1 <= N <= 50,000) barns, connected by M (1 <= M <= 50,000) bi-directional cow paths, each with C\\_i (0 <= C\\_i <= 1,000) cows ambling along it. A cow path connects two distinct barns, A\\_i and B\\_i (1 <= A\\_i <= N; 1 <= B\\_i <= N; A\\_i != B\\_i). Two barns may be directly connected by more than one path. He is currently located at barn 1, and Farmer Dan is located at barn N.\n\nFJ 已经绘制了 $N(1 \\le N \\le 50000)$ 个谷仓的地图，通过 $M(1 \\le M \\le 50000)$ 条双向牛道，每条双向牛道上有 $c[i](0 \\le c[i] \\le 1000)$ 奶牛漫步。双向牛道连接两个不同的谷仓，$a[i]$ 和 $b[i](1 \\le a[i] \\le N,1 \\le b[i] \\le N, a[i] \\neq b[i])$。两个谷仓可以由一条以上的小路直接连接。他目前在 $1$ 号谷仓，农夫丹位于 $N$ 号谷仓。\n\nConsider the following map:\n\n```cpp\n           [2]---\n          / |    \\\n         /1 |     \\ 6\n        /   |      \\\n     [1]   0|    --[3]\n        \\   |   /     \\2\n        4\\  |  /4      [6]\n          \\ | /       /1\n           [4]-----[5] \n                3  \n```\nThe best path for Farmer John to take is to go from 1 -> 2 -> 4 -> 5 -> 6, because it will cost him 1 + 0 + 3 + 1 = 5 treats.\n\nGiven FJ's map, what is the minimal number of treats that he should bring with him, given that he will feed each distinct cow he meets exactly one treat? He does not care about the length of his journey.\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Three space-separated integers: A\\_i, B\\_i, and C\\_i\n", "outputFormat": "\\* Line 1: The minimum number of treats that FJ must bring\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3021", "type": "P", "difficulty": 3, "samples": [["8 \n-3 0 \n-2 0 \n-1 1 \n0 3 \n2 0 \n-3 1 \n3 0 \n-2 2 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11MAR] Bovine Bridge Battle S", "background": "给定N（4 <= N <= 1,000）个整点的坐标 (-1,000,000,000 <= X\\_i <= 1,000,000,000; -1,000,000,000 <= Y\\_i <= 1,000,000,000，X\\_i，Y\\_i∈Z)，求card{{(X\\_a,Y\\_a),(X\\_b,Y\\_b),(X\\_c,Y\\_c),(X\\_d,Y\\_d)}|四点呈中心对称}\n", "description": "Each of Farmer John's N (4 <= N <= 1,000) cows is patiently waiting in the main pasture with cow i at point with integer coordinates (X\\_i, Y\\_i) (-1,000,000,000 <= X\\_i <= 1,000,000,000; -1,000,000,000 <= Y\\_i <= 1,000,000,000).\n\nThe cows wish to form into groups of four in order to play Bridge, their new favorite card game. Each group must satisfy an important constraint: four cows are allowed to team up if and only if there exists some point X somewhere in the plane (and not coincident with any of the four points of the potential group of four) such that rotating any of the group's cows 180 degrees about that point X gives the position of some other cow in the group.\n\nPlease help the cows determine the number of sets of four cows that can form a Bridge group.\n\nBy way of example, suppose eight cows are standing at eight points:\n\n|\nf\\*\n```cpp\n|             a = (-3, 1)    e = (-1, 1) \nb*     |             b = (-2, 2)    f = ( 0, 3) \na      e  |             c = (-3, 0)    g = ( 2, 0) \n*     *  |             d = (-2, 0)    h = ( 3, 0) \n```\nc  d     |     g  h\n---------\\*--\\*-----+-----\\*--\\*---------\n\n|\nThen the three legal sets of four cows are {a, b, e, d} (they rotate around point (-2, 1)), {b, c, e, f} (around the point (-1.5, 1.5)), and {c, d, g, h} (around (0,0)).\n\nThe supplied locations of the cows given are all distinct, although they are supplied in no particular order. Furthermore, the answer will fit into a signed 32-bit integer.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: X\\_i and Y\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the number of sets of 4 cows that form valid groups for bridge.\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO11MAR] Bovine Bridge Battle S", "background": "给定N（4 <= N <= 1,000）个整点的坐标 (-1,000,000,000 <= X\\_i <= 1,000,000,000; -1,000,000,000 <= Y\\_i <= 1,000,000,000，X\\_i，Y\\_i∈Z)，求card{{(X\\_a,Y\\_a),(X\\_b,Y\\_b),(X\\_c,Y\\_c),(X\\_d,Y\\_d)}|四点呈中心对称}\n", "description": "Each of Farmer John's N (4 <= N <= 1,000) cows is patiently waiting in the main pasture with cow i at point with integer coordinates (X\\_i, Y\\_i) (-1,000,000,000 <= X\\_i <= 1,000,000,000; -1,000,000,000 <= Y\\_i <= 1,000,000,000).\n\nThe cows wish to form into groups of four in order to play Bridge, their new favorite card game. Each group must satisfy an important constraint: four cows are allowed to team up if and only if there exists some point X somewhere in the plane (and not coincident with any of the four points of the potential group of four) such that rotating any of the group's cows 180 degrees about that point X gives the position of some other cow in the group.\n\nPlease help the cows determine the number of sets of four cows that can form a Bridge group.\n\nBy way of example, suppose eight cows are standing at eight points:\n\n|\nf\\*\n```cpp\n|             a = (-3, 1)    e = (-1, 1) \nb*     |             b = (-2, 2)    f = ( 0, 3) \na      e  |             c = (-3, 0)    g = ( 2, 0) \n*     *  |             d = (-2, 0)    h = ( 3, 0) \n```\nc  d     |     g  h\n---------\\*--\\*-----+-----\\*--\\*---------\n\n|\nThen the three legal sets of four cows are {a, b, e, d} (they rotate around point (-2, 1)), {b, c, e, f} (around the point (-1.5, 1.5)), and {c, d, g, h} (around (0,0)).\n\nThe supplied locations of the cows given are all distinct, although they are supplied in no particular order. Furthermore, the answer will fit into a signed 32-bit integer.\n", "inputFormat": "\\* Line 1: A single integer: N\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: X\\_i and Y\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the number of sets of 4 cows that form valid groups for bridge.\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO11MAR] Bovine Bridge Battle S", "background": "", "description": "Farmer John 的每头牛（共 $N$ 头，$4 \\le N \\le 1,000$）都耐心地在主牧场等待，其中第 $i$ 头牛位于整数坐标 $(X_i, Y_i)$ 上（$-1,000,000,000 \\le X_i \\le 1,000,000,000$，$-1,000,000,000 \\le Y_i \\le 1,000,000,000$）。\n\n这些牛希望组成四个一组，以便玩他们的新宠卡牌游戏「桥牌」。每组必须满足一个重要的约束条件：如果且仅如果在平面上存在某个点 $X$（并且不与潜在四牛组的任何四个点重合），使得围绕该点 $X$ 将组内任意一头牛旋转 $180$ 度后得到组内的另一头牛的位置，四头牛才可以组队。\n\n请帮助这些牛确定可以组成桥牌组的四牛组合的数量。\n\n例如，假设有八头牛分别站在八个点上：\n\n|\nf\\*\n```cpp\n|             a = (-3, 1)    e = (-1, 1) \nb*     |             b = (-2, 2)    f = ( 0, 3) \na      e  |             c = (-3, 0)    g = ( 2, 0) \n*     *  |             d = (-2, 0)    h = ( 3, 0) \n```\nc  d     |     g  h\n---------\\*--\\*-----+-----\\*--\\*---------\n\n|\n那么，三个合法的四牛组合是 {a, b, e, d}（它们围绕点 $(-2, 1)$ 旋转），{b, c, e, f}（围绕点 $(-1.5, 1.5)$），以及 {c, d, g, h}（围绕点 $(0,0)$）。\n\n提供的牛的位置都是不同的，尽管它们的顺序没有特定的规则。此外，答案将适合一个有符号的 32 位整数。\n", "inputFormat": "\\* 第 1 行：一个整数：$N$\n\n\\* 第 2 行到第 $N+1$ 行：第 $i+1$ 行包含两个用空格分隔的整数：$X_i$ 和 $Y_i$\n", "outputFormat": "\\* 第 1 行：一个整数，表示可以组成桥牌有效组的四牛组合的数量。\n", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3022", "type": "P", "difficulty": 5, "samples": [["4 4 \n1 2 \n2 3 \n3 1 \n3 4 \n", "3 \n2 \n3 \n4 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2011", "USACO", "Special Judge", "深度优先搜索 DFS", "树形 DP"], "title": "[USACO11OPEN] Odd degrees G", "background": "", "description": "The cows are being invaded! Their republic comprises N (1 <= N <= 50,000) towns that are connected by M (1 <= M <= 100,000) undirected paths between two towns A\\_i and B\\_i (1 <= A\\_i <= N; 1 <= B\\_i <= N; A\\_i != B\\_i; no duplicate paths will occur). However the republic is not necessarily connected--there may be pairs of towns that are unable to reach each other through the paths.\n\nThe cows know their invaders plan to conduct an inventory of every path within their republic, so they are willing to shut down various paths to make it as difficult as possible for their invaders to do so.\n\nPlease help the cows find a way to shut down a subset of the paths such that each town has an odd number of remaining paths connected to it, or determine if no such subset exists.\n\nFor example, consider the following cow republic: \n\n1---2\n\\ /\n3---4\nIf we keep the paths 1-3, 2-3, and 3-4, and remove the path 1-2, then towns 1, 2, and 4 will be an endpoint of exactly one path, whereas town 3 will be an endpoint of three paths:\n\n1   2\n\\ /\n3---4", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Line i+1 contains two space-separated integers: A\\_i and B\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the number of paths to keep. If no subset exists output only a single line with the integer -1.\n\n\\* Lines 2..K+1: Each line contains an index of an path to keep, in the range 1..M. These indices must be pairwise distinct.\n", "hint": "感谢@cn：苏卿念 提供的Special Judge", "locale": "en", "translations": {"en": {"title": "[USACO11OPEN] Odd degrees G", "background": "", "description": "The cows are being invaded! Their republic comprises N (1 <= N <= 50,000) towns that are connected by M (1 <= M <= 100,000) undirected paths between two towns A\\_i and B\\_i (1 <= A\\_i <= N; 1 <= B\\_i <= N; A\\_i != B\\_i; no duplicate paths will occur). However the republic is not necessarily connected--there may be pairs of towns that are unable to reach each other through the paths.\n\nThe cows know their invaders plan to conduct an inventory of every path within their republic, so they are willing to shut down various paths to make it as difficult as possible for their invaders to do so.\n\nPlease help the cows find a way to shut down a subset of the paths such that each town has an odd number of remaining paths connected to it, or determine if no such subset exists.\n\nFor example, consider the following cow republic: \n\n1---2\n\\ /\n3---4\nIf we keep the paths 1-3, 2-3, and 3-4, and remove the path 1-2, then towns 1, 2, and 4 will be an endpoint of exactly one path, whereas town 3 will be an endpoint of three paths:\n\n1   2\n\\ /\n3---4", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..M+1: Line i+1 contains two space-separated integers: A\\_i and B\\_i\n", "outputFormat": "\\* Line 1: A single integer that is the number of paths to keep. If no subset exists output only a single line with the integer -1.\n\n\\* Lines 2..K+1: Each line contains an index of an path to keep, in the range 1..M. These indices must be pairwise distinct.\n", "hint": "感谢@cn：苏卿念 提供的Special Judge", "locale": "en"}, "zh-CN": {"title": "[USACO11OPEN] Odd degrees G", "background": "", "description": "奶牛们正在遭受入侵！它们的共和国由 $N$ 个城镇组成（$1 \\leq N \\leq 50,000$），这些城镇通过 $M$ 条无向路径连接（$1 \\leq M \\leq 100,000$），每条路径连接两个城镇 $A_i$ 和 $B_i$（$1 \\leq A_i \\leq N$；$1 \\leq B_i \\leq N$；$A_i \neq B_i$；不会出现重复路径）。然而，共和国不一定是连通的——可能存在无法通过路径到达彼此的城镇对。\n\n奶牛们知道入侵者计划对它们共和国内的每一条路径进行清点，所以它们愿意关闭各种路径，以使入侵者的工作尽可能困难。\n\n请帮助奶牛们找到一种关闭路径子集的方法，使得每个城镇连接的剩余路径数为奇数，或者确定不存在这样的子集。\n\n例如，考虑以下的奶牛共和国：\n\n1---2\n\\ /\n3---4\n如果我们保留路径 1-3、2-3 和 3-4，并移除路径 1-2，那么城镇 1、2 和 4 将成为正好一条路径的端点，而城镇 3 将成为三条路径的端点：\n\n1   2\n\\ /\n3---4", "inputFormat": "\\* 第 1 行：两个用空格分隔的整数：$N$ 和 $M$\n\n\\* 第 2 行到第 $M+1$ 行：第 $i+1$ 行包含两个用空格分隔的整数：$A_i$ 和 $B_i$\n", "outputFormat": "\\* 第 1 行：一个整数，表示要保留的路径数量。如果不存在这样的子集，则仅输出一行，包含整数 -1。\n\n\\* 第 2 行到第 $K+1$ 行：每行包含一个要保留的路径的索引，范围为 1 到 $M$。这些索引必须两两不同。\n", "hint": "感谢 @cn：苏侨念 提供的 Special Judge（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
{"pid": "P3023", "type": "P", "difficulty": 6, "samples": [["6 \n1 2 \n1 3 \n1 4 \n1 5 \n1 6 \n", "7 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2011", "USACO", "斜率优化", "树形 DP"], "title": "[USACO11OPEN] Soldering G", "background": "", "description": "The cows are playing with wires! They have learned a technique called soldering, in which they connect two pieces of wire together by attaching the endpoint of one wire to a location along the length of the other. (Soldering endpoint to endpoint is not allowed.) There can be multiple solder junctions at the same point.\n\nThe cows have a plan for an Amazing Structure they would like to build. It is in the form of a graph with $N$($1 \\leq N \\leq 50,000$) nodes and $N - 1$ edges of unit length so that each pair of nodes is connected. Each edge is described by a pair of integers, $A$ and $B$($1 \\leq A \\leq N; 1 \\leq B \\leq N; A \\neq B$).\n\nThe cows are able to buy wire from a local store; however longer wire is more expensive. In particular the cows can buy a wire of length L with cost $L * L$, but they cannot cut wires or join wires together.\n\nGiven the plan, the cows would like solder wires together to build their Amazing Structure. Please help them find the minimum possible cost!", "inputFormat": "Line $1$: A single integer: $N$\n\nLines $2 \\sim N$: Two space-separated integers describing an edge: $A$ and $B$", "outputFormat": "Line $1$: A single integer, the cost of soldering the tree together. \n\n**Note that this number may not always fit in a 32-bit integer.**", "hint": "Since all nodes in the structure are connected to node $1$, we only need to buy one wire of length $2$ and three of length $1$, for a total cost of $2 * 2 + 1 * 1 + 1 * 1 + 1 * 1 = 7$.\n\nTest data worth at least $50\\%$ of the points will have $N \\leq 2,000$.", "locale": "en", "translations": {"en": {"title": "[USACO11OPEN] Soldering G", "background": "", "description": "The cows are playing with wires! They have learned a technique called soldering, in which they connect two pieces of wire together by attaching the endpoint of one wire to a location along the length of the other. (Soldering endpoint to endpoint is not allowed.) There can be multiple solder junctions at the same point.\n\nThe cows have a plan for an Amazing Structure they would like to build. It is in the form of a graph with $N$($1 \\leq N \\leq 50,000$) nodes and $N - 1$ edges of unit length so that each pair of nodes is connected. Each edge is described by a pair of integers, $A$ and $B$($1 \\leq A \\leq N; 1 \\leq B \\leq N; A \\neq B$).\n\nThe cows are able to buy wire from a local store; however longer wire is more expensive. In particular the cows can buy a wire of length L with cost $L * L$, but they cannot cut wires or join wires together.\n\nGiven the plan, the cows would like solder wires together to build their Amazing Structure. Please help them find the minimum possible cost!", "inputFormat": "Line $1$: A single integer: $N$\n\nLines $2 \\sim N$: Two space-separated integers describing an edge: $A$ and $B$", "outputFormat": "Line $1$: A single integer, the cost of soldering the tree together. \n\n**Note that this number may not always fit in a 32-bit integer.**", "hint": "Since all nodes in the structure are connected to node $1$, we only need to buy one wire of length $2$ and three of length $1$, for a total cost of $2 * 2 + 1 * 1 + 1 * 1 + 1 * 1 = 7$.\n\nTest data worth at least $50\\%$ of the points will have $N \\leq 2,000$.", "locale": "en"}, "zh-CN": {"title": "[USACO11OPEN] Soldering G", "background": null, "description": "奶牛决定用电线焊接出一张图，这张图是连通的，由 $N$ 个点，$N-1$ 条边组成，每条边的长度都是 $1$。焊接所用的电线要从当地的商店里买。越长的电线越贵，一条长度为 $L$ 的电线售价为 $L^2$。奶牛们已经学会了基本的焊接方法，她们会把某条电线的一个端点焊接到另一条电线的中间某个位置，但她们没有学会如何把两条电线的端点直接焊接起来，也没有学会怎么把电线剪断。给定奶牛准备焊接的图，请告诉奶牛怎么焊接才能最节约材料费用。", "inputFormat": "第 $1$ 行：一个整数 $N$。\n\n第 $2 \\sim N$ 行：描述边的两个以空格分隔的整数：$A$ 和 $B$。", "outputFormat": "第 $1$ 行：一个整数，将树焊接在一起的成本。\n\n**请注意，此数字可能并不总是适合32位整数。**", "hint": "由于结构中的所有节点都连接到节点 $1$，我们只需要购买一根长度为 $2$ 的电线和三根长度为 $1$ 的电线，总成本为 $2 * 2 + 1 * 1 + 1 * 1 + 1 * 1 = 7$。\n\n对于至少 $50\\%$ 的测试数据，有 $N \\leq 2,000$。", "locale": "zh-CN"}}}
{"pid": "P3024", "type": "P", "difficulty": 5, "samples": [["3 3 \n1 \n1 1 \n", "Bessie \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "博弈论", "2011", "USACO", "排序"], "title": "[USACO11OPEN] Cow Checkers S", "background": null, "description": "有一天，Bessie 准备玩一个叫做奶牛跳棋的游戏，来挑战 Farmer John。这个游戏的棋盘大小为 $M\\times N$。\n\n最初棋盘上只有一个棋子在 $(X,Y)$，棋盘的左下角坐标是 $(0,0)$，右上角的坐标是 $(M-1,N-1)$。每次游戏 Bessie 都是先手，之后两个人轮流进行操作。每次操作可以在以下三种移动中选择一种：\n\n1. 向左走任意步。\n\n2. 向下走任意步。\n\n3. 向左走 $k$ 步然后向下走 $k$ 步（$k$ 为任意能保证不走出棋盘的正整数）。\n\n首个无法操作的人为败者。\n\n游戏共有 $T$ 次，每次都会给出一个新的坐标 $(X,Y)$，请输出每一轮胜者的名字。", "inputFormat": "第 $1$ 行，两个用空格隔开的正整数，代表 $M$ 和 $N$。\n\n第 $2$ 行，一个正整数代表 $T$。\n\n第 $3$ 行到第 $(T+2)$ 行，分别有两个空格隔开的非负整数，代表 $X,Y$。", "outputFormat": "共 $T$ 行，每一行输出那一轮的胜者。", "hint": "**【数据范围】**\n\n保证 $1\\le M,N\\le 10^6$，$0 \\le X < M$，$0 \\le Y < N$，$1\\le T\\le10^3$。\n\n**【样例解释 #1】**\n\n起点在 $(1,1)$，一开始有三种选择 $(1,0)$、$(0,1)$、$(0,0)$。只要 Bessie 在开始时将棋子移到 $(0,0)$，就必胜无疑。\n\n感谢 @[\\_Trangle\\_](/user/768144) 提供的翻译。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO11OPEN] Cow Checkers S", "background": null, "description": "One day, Bessie decides to challenge Farmer John to a game of 'Cow Checkers'. The game is played on an M\\*N (1 <= M <= 1,000,000; 1 <= N <= 1,000,000) checkerboard that initially contains a single checker piece on the checkboard square coordinates (X, Y) (0 <= X < M; 0 <= Y < N). The bottom leftmost square of the checkerboard has\n\ncoordinates (0, 0), and the top rightmost square has coordinates (M-1, N-1). Bessie always moves first, and then the two players alternate turns.  Each turn comprises one of three types of moves:\n\n1) Move the checker piece to any square on the same row to the left of its current position.\n\n2) Move the checker piece to any square on the same column below its current position.\n\n3) Move the checker piece to any spot k squares below and k squares to the left of the current square (where k is any positive integer such that this new spot is still on the checkerboard).\n\nThe first player unable to make a move (i.e., because the checker is at (0, 0)) loses. Given that Bessie always goes first, determine who will win the game if both play optimally.\n\nPlay and report the winner for T games (1 <= T <= 1,000) reading in a new X,Y starting value for each new game.", "inputFormat": "\\* Line 1: Two space-separated integers: M and N\n\n\\* Line 2: A single integer: T\n\n\\* Lines 3..T+2: Two space-separated integers: X and Y", "outputFormat": "\\* Lines 1..T: Should contain either 'Farmer John' or 'Bessie' depending on who wins each  game.", "hint": "Farmer John and Bessie are playing one game on a 3\\*3 checkerboard with the checker piece initially at (1, 1) (i.e. at the center of the board).\n\n\nBessie initially can only move the checker piece to either (1, 0) or (0, 1), or (0, 0). Bessie can immediately win by moving the piece to (0, 0).", "locale": "en"}, "zh-CN": {"title": "[USACO11OPEN] Cow Checkers S", "background": null, "description": "有一天，Bessie 准备玩一个叫做奶牛跳棋的游戏，来挑战 Farmer John。这个游戏的棋盘大小为 $M\\times N$。\n\n最初棋盘上只有一个棋子在 $(X,Y)$，棋盘的左下角坐标是 $(0,0)$，右上角的坐标是 $(M-1,N-1)$。每次游戏 Bessie 都是先手，之后两个人轮流进行操作。每次操作可以在以下三种移动中选择一种：\n\n1. 向左走任意步。\n\n2. 向下走任意步。\n\n3. 向左走 $k$ 步然后向下走 $k$ 步（$k$ 为任意能保证不走出棋盘的正整数）。\n\n首个无法操作的人为败者。\n\n游戏共有 $T$ 次，每次都会给出一个新的坐标 $(X,Y)$，请输出每一轮胜者的名字。", "inputFormat": "第 $1$ 行，两个用空格隔开的正整数，代表 $M$ 和 $N$。\n\n第 $2$ 行，一个正整数代表 $T$。\n\n第 $3$ 行到第 $(T+2)$ 行，分别有两个空格隔开的非负整数，代表 $X,Y$。", "outputFormat": "共 $T$ 行，每一行输出那一轮的胜者。", "hint": "**【数据范围】**\n\n保证 $1\\le M,N\\le 10^6$，$0 \\le X < M$，$0 \\le Y < N$，$1\\le T\\le10^3$。\n\n**【样例解释 #1】**\n\n起点在 $(1,1)$，一开始有三种选择 $(1,0)$、$(0,1)$、$(0,0)$。只要 Bessie 在开始时将棋子移到 $(0,0)$，就必胜无疑。\n\n感谢 @[\\_Trangle\\_](/user/768144) 提供的翻译。", "locale": "zh-CN"}}}
{"pid": "P3025", "type": "P", "difficulty": 5, "samples": [["15 6 \na??l?ban??????? \napple \ncow \nfarmer \nbanana \nbananas \npies \n", "applebananapies \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11OPEN] Forgotten Password S", "background": "", "description": "就像在我们身上经常发生的那样，Bessie 又一次忘记了她的牛场管理员密码，她只能记得密码的一部分。\n\n首先，她记得密码 $P$ 是长度为 $L$（$1 \\le L \\le 1000$）的字符串，并且她的密码中出现过的所有单词都记录在她的共有 $NW$（$1 \\le NW \\le 1000$）个单词的字典中，每个字典中的单词 $W_i$ 都是由 $1$ 至 $20$ 个小写拉丁字母组成的。\n\n她只记得密码中的一部分字母和它的位置。例如，Bessie 记得她的密码为 `a??l?ban???????`，其中，`?` 是她忘记的字母。她的字典中有这些单词：`apple cow farmer banana bananas pies`。所以，Bessie 的密码的两种可能是`applebananapies` 和 `applebananascow`.\n\n现在，给你 Bessie 还记得的字母和她的字典，求可能的密码。如果有多个答案，则输出字典序最小的那一个。", "inputFormat": "第一行输入她密码的长度 $L$ 和字典中的单词数量 $NW$，用一个空格隔开。\n\n第二行输入长为 $L$ 的字符串 $P$。\n\n此后 $NW$ 行，每行输入一个字符串 $W_i$。", "outputFormat": "只输出一行：Bessie 的密码。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO11OPEN] Forgotten Password S", "background": "", "description": "As often happens to us, Bessie has once again forgotten her barn manager password. She can only remember part of it.\n\nFirst, she remembers that the password $P$ is a string of length $L$ ($1 \\le L \\le 1000$), and that the password is formed by concatenating one or more words, each of which is recorded in her dictionary of $NW$ ($1 \\le NW \\le 1000$) words. Every dictionary word $W_i$ consists of $1$ to $20$ lowercase Latin letters.\n\nShe only remembers some letters in the password and their positions. For example, Bessie remembers her password as `a??l?ban???????`, where `?` stands for a letter she forgot. Her dictionary contains these words: `apple cow farmer banana bananas pies`. Therefore, two possible passwords for Bessie are `applebananapies` and `applebananascow`.\n\nNow, given the letters Bessie still remembers and her dictionary, find a possible password. If there are multiple answers, output the lexicographically smallest one.", "inputFormat": "The first line contains the length $L$ of her password and the number of words $NW$ in the dictionary, separated by a space.\n\nThe second line contains the string $P$ of length $L$.\n\nThen follow $NW$ lines, each containing a string $W_i$.", "outputFormat": "Output exactly one line: Bessie’s password.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO11OPEN] Forgotten Password S", "background": "", "description": "就像在我们身上经常发生的那样，Bessie 又一次忘记了她的牛场管理员密码，她只能记得密码的一部分。\n\n首先，她记得密码 $P$ 是长度为 $L$（$1 \\le L \\le 1000$）的字符串，并且她的密码中出现过的所有单词都记录在她的共有 $NW$（$1 \\le NW \\le 1000$）个单词的字典中，每个字典中的单词 $W_i$ 都是由 $1$ 至 $20$ 个小写拉丁字母组成的。\n\n她只记得密码中的一部分字母和它的位置。例如，Bessie 记得她的密码为 `a??l?ban???????`，其中，`?` 是她忘记的字母。她的字典中有这些单词：`apple cow farmer banana bananas pies`。所以，Bessie 的密码的两种可能是`applebananapies` 和 `applebananascow`.\n\n现在，给你 Bessie 还记得的字母和她的字典，求可能的密码。如果有多个答案，则输出字典序最小的那一个。", "inputFormat": "第一行输入她密码的长度 $L$ 和字典中的单词数量 $NW$，用一个空格隔开。\n\n第二行输入长为 $L$ 的字符串 $P$。\n\n此后 $NW$ 行，每行输入一个字符串 $W_i$。", "outputFormat": "只输出一行：Bessie 的密码。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3026", "type": "P", "difficulty": 5, "samples": [["3 3 \n2 3 2 \n1 2 \n1 1 \n", "1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2011", "USACO"], "title": "[USACO11OPEN] Learning Languages S", "background": "", "description": "Farmer John's N (2 <= N <= 10,000) cows, conveniently numbered 1..N, are fluent in some M (1 <= M <= 30,000) languages, also conveniently numbered from 1..M. Cow i can speak in K\\_i (1 <= K\\_i <= M) languages, namely L\\_i1, L\\_i2,..., L\\_{iK\\_i} (1 <= L\\_ij <= M). FJ's cows aren't THAT smart, so the sum of K\\_i over all cows i is at most 100,000.\n\nTwo cows can't directly talk to each other unless both speak a common language. However, cows can pass messages along, translating if necessary. In other words, cows A and B can have a conversation if and only if there exists a sequence of cows T\\_1, T\\_2, ..., T\\_k such that A and T\\_1 share a language, T\\_1 and T\\_2 share a language, etc., and T\\_k and B share a language.\n\nFarmer John wishes that his cows could be even more social, so he wants all his cows to be able to socialize with any other cow. He can buy books to teach any one of his cows any language he pleases. Being a fairly frugal farmer, FJ wants to purchase the minimum number of books necessary to enable all of his cows to speak to each other. Help him determine:\n\n\\* The minimum number of books he must purchase\n\n\\* Any set of books assigned to cows in any order which will help him meet this goal; a program will grade your output.\n\nBy way of example, suppose there are three cows named Alberta, Bessie, and Contessa along with three languages denoted as #1, #2, and #3. Alberta can speak languages #2 and #3, Bessie can speak language #2, and Contessa can speak language #1. Currently, Alberta and Bessie can talk to each other, but Contessa is left alone.\n\n```\n#1   #2   #3\nAlberta           x    x\nBessie            x\nContessa     x\n```\nFJ wants to fix this situation, so he can buy Contessa a book to teach her language #2. This will ensure all cows speak the same language, so they can all communicate with one another.\n\nNote that an alternate solution exists: instead, FJ could buy\n\nContessa a book to teach her language #3. Not all cows would speak the same language, but this would still be a valid solution because Contessa could communicate through Alberta (who also speaks language #3) if she wants to talk to Bessie. Other alternatives exist, and any valid alternate solution will also be accepted.\n\n农夫约翰的$N(2<=N<=10,000)$只奶牛标号为$1..N$，同样的有$M(1<=M<=30,000)$种牛语标号为$1..M$，第i只奶牛会说$K_i(1<=K_i<=M)$种牛语，分别为$L_i1,L_i2,…,L_{iK_i}(1<=L_ij<=M)$，农夫的奶牛不是特别聪明，所以$K_i$的累加和不大于$100,000$。\n\n两只奶牛只有当他们至少有一门语言一样的时候才可以沟通。否则这两只奶牛就需要别人来帮他们翻译才能交流。换句话说，A和B要进行沟通，他们可以通过$T_1,T_2,…,T_k$来传递，比如A和$T_1,T_1$和$T_2,…,T_k$和B进行交流。\n\n农夫希望他的奶牛可以多多沟通，所以他买了很多课本去教她的奶牛语言。当然农夫非常的吝啬，他希望买最少的书就可以让所有的奶牛可以交流。你的任务就是帮他算出最少需要买几本书。\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 describes the languages that cow i can speak with $(K_i)+1$ space-separated integers: $K_i$, $L_i1$,\n\nL\\_i2,...,L\\_i{K\\_i}. \n\n", "outputFormat": "\\* Line 1: A single integer that is the minimum number of books that FJ must purchase.\n\n\\* Lines 2..B+1: Line i+1 contains two space-separated integers: the language id # and the id # of the cow to receive book i. If multiple solutions exist, print any one.\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO11OPEN] Learning Languages S", "background": "", "description": "Farmer John's $N$ ($2 \\le N \\le 10{,}000$) cows, conveniently numbered $1..N$, are fluent in some $M$ ($1 \\le M \\le 30{,}000$) languages, also conveniently numbered $1..M$. Cow $i$ can speak $K_i$ ($1 \\le K_i \\le M$) languages, namely $L_{i1}, L_{i2}, ..., L_{i K_i}$ ($1 \\le L_{ij} \\le M$). FJ's cows are not that smart, so the sum of $K_i$ over all cows $i$ is at most $100{,}000$.\n\nTwo cows cannot directly talk to each other unless they both speak a common language. However, cows can pass messages along, translating if necessary. In other words, cows $A$ and $B$ can have a conversation if and only if there exists a sequence of cows $T_1, T_2, ..., T_k$ such that $A$ and $T_1$ share a language, $T_1$ and $T_2$ share a language, ..., and $T_k$ and $B$ share a language.\n\nFarmer John wants all his cows to be able to socialize with any other cow. He can buy books to teach any one of his cows any language he pleases. Being frugal, FJ wants to purchase the minimum number of books necessary to enable all of his cows to speak to each other. Help him determine:\n- The minimum number of books he must purchase.\n- Any set of books assigned to cows, in any order, that will achieve this goal; a program will grade your output.\n\nBy way of example, suppose there are three cows named Alberta, Bessie, and Contessa along with three languages denoted as #1, #2, and #3. Alberta can speak languages #2 and #3, Bessie can speak language #2, and Contessa can speak language #1. Currently, Alberta and Bessie can talk to each other, but Contessa is left alone.\n\n```\n#1   #2   #3\nAlberta           x    x\nBessie            x\nContessa     x\n```\nFJ wants to fix this situation, so he can buy Contessa a book to teach her language #2. This will ensure all cows speak the same language, so they can all communicate with one another.\n\nNote that an alternate solution exists: instead, FJ could buy Contessa a book to teach her language #3. Not all cows would speak the same language, but this would still be a valid solution because Contessa could communicate through Alberta (who also speaks language #3) if she wants to talk to Bessie. Other alternatives exist, and any valid alternate solution will also be accepted.", "inputFormat": "* Line 1: Two space-separated integers: $N$ and $M$.\n* Lines $2..N+1$: Line $i+1$ describes the languages that cow $i$ can speak with $K_i + 1$ space-separated integers: $K_i$, $L_{i1}$, $L_{i2}$, ..., $L_{i K_i}$.", "outputFormat": "* Line 1: A single integer that is the minimum number of books that FJ must purchase.\n* Lines $2..B+1$: Line $i+1$ contains two space-separated integers: the language id and the id of the cow to receive book $i$, where $B$ is the number printed on line 1. If multiple solutions exist, print any one.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO11OPEN] Learning Languages S", "background": "", "description": "Farmer John's N (2 <= N <= 10,000) cows, conveniently numbered 1..N, are fluent in some M (1 <= M <= 30,000) languages, also conveniently numbered from 1..M. Cow i can speak in K\\_i (1 <= K\\_i <= M) languages, namely L\\_i1, L\\_i2,..., L\\_{iK\\_i} (1 <= L\\_ij <= M). FJ's cows aren't THAT smart, so the sum of K\\_i over all cows i is at most 100,000.\n\nTwo cows can't directly talk to each other unless both speak a common language. However, cows can pass messages along, translating if necessary. In other words, cows A and B can have a conversation if and only if there exists a sequence of cows T\\_1, T\\_2, ..., T\\_k such that A and T\\_1 share a language, T\\_1 and T\\_2 share a language, etc., and T\\_k and B share a language.\n\nFarmer John wishes that his cows could be even more social, so he wants all his cows to be able to socialize with any other cow. He can buy books to teach any one of his cows any language he pleases. Being a fairly frugal farmer, FJ wants to purchase the minimum number of books necessary to enable all of his cows to speak to each other. Help him determine:\n\n\\* The minimum number of books he must purchase\n\n\\* Any set of books assigned to cows in any order which will help him meet this goal; a program will grade your output.\n\nBy way of example, suppose there are three cows named Alberta, Bessie, and Contessa along with three languages denoted as #1, #2, and #3. Alberta can speak languages #2 and #3, Bessie can speak language #2, and Contessa can speak language #1. Currently, Alberta and Bessie can talk to each other, but Contessa is left alone.\n\n```\n#1   #2   #3\nAlberta           x    x\nBessie            x\nContessa     x\n```\nFJ wants to fix this situation, so he can buy Contessa a book to teach her language #2. This will ensure all cows speak the same language, so they can all communicate with one another.\n\nNote that an alternate solution exists: instead, FJ could buy\n\nContessa a book to teach her language #3. Not all cows would speak the same language, but this would still be a valid solution because Contessa could communicate through Alberta (who also speaks language #3) if she wants to talk to Bessie. Other alternatives exist, and any valid alternate solution will also be accepted.\n\n农夫约翰的$N(2<=N<=10,000)$只奶牛标号为$1..N$，同样的有$M(1<=M<=30,000)$种牛语标号为$1..M$，第i只奶牛会说$K_i(1<=K_i<=M)$种牛语，分别为$L_i1,L_i2,…,L_{iK_i}(1<=L_ij<=M)$，农夫的奶牛不是特别聪明，所以$K_i$的累加和不大于$100,000$。\n\n两只奶牛只有当他们至少有一门语言一样的时候才可以沟通。否则这两只奶牛就需要别人来帮他们翻译才能交流。换句话说，A和B要进行沟通，他们可以通过$T_1,T_2,…,T_k$来传递，比如A和$T_1,T_1$和$T_2,…,T_k$和B进行交流。\n\n农夫希望他的奶牛可以多多沟通，所以他买了很多课本去教她的奶牛语言。当然农夫非常的吝啬，他希望买最少的书就可以让所有的奶牛可以交流。你的任务就是帮他算出最少需要买几本书。\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 describes the languages that cow i can speak with $(K_i)+1$ space-separated integers: $K_i$, $L_i1$,\n\nL\\_i2,...,L\\_i{K\\_i}. \n\n", "outputFormat": "\\* Line 1: A single integer that is the minimum number of books that FJ must purchase.\n\n\\* Lines 2..B+1: Line i+1 contains two space-separated integers: the language id # and the id # of the cow to receive book i. If multiple solutions exist, print any one.\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P3027", "type": "P", "difficulty": 3, "samples": [["3 17 \n2 4 \n5 6 \n3 7 \n", "22 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "USACO", "背包 DP"], "title": "[USACO10OCT] Making Money G", "background": "", "description": "FJ has gone into the curio business, buying and selling knickknacks like cow Christmas tree ornaments. He knows he will sell every single curio he can stock from a catalog of N (1 <= N <= 100)\n\ndifferent cow curios, and he can buy as many of each kind of curio as his heart desires. He has only M (1 <= M <= 100,000) money to invest but wants to maximize his profit (which has a slightly unusual definition) at the end of his first year in business.\n\nCurio type i costs C\\_i (1 <= C\\_i <= 100,000) money to purchase and yields R\\_i (1 <= R\\_i <= 100,000) revenue for each curio sold (a profit of R\\_i-C\\_i). FJ can mix and match the curios he sells in any way he wishes. He need not spend all his money when purchasing curios.\n\nWhat is the greatest amount of total profit (profit = initial\\_cash - all\\_costs + all\\_sales) FJ can have at the end of his first year? This number is guaranteed to be less than 1,000,000,000.\n\nConsider the situation when FJ has just 3 kinds of curios and starts with M=17. Below are the cost and revenue numbers for each curio:\n\nCurio     Cost     Revenue\n\n#        C\\_i       R\\_i\n\n1         2         4\n\n2         5         6\n\n3         3         7\n\nIn this case, FJ should purchase 5 curios of type 3 for 15 money and 1 more curio of type 1 for 2 money, a total of 17 money. His profit will be 5 \\* (7-3) + 1 \\* (4-2) = 5\\*4 + 1\\*2 = 22 money. He can do no better than this given the cost and revenue structure.\n\nNOTE: The second test case is challenging -- but our answer is correct.\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: C\\_i and R\\_i\n", "outputFormat": "\\* Line 1: The maximum profit FJ can generate given the costs and revenues\n", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO10OCT] Making Money G", "background": "", "description": "FJ has gone into the curio business, buying and selling knickknacks like cow Christmas tree ornaments. He knows he will sell every single curio he can stock from a catalog of N (1 <= N <= 100)\n\ndifferent cow curios, and he can buy as many of each kind of curio as his heart desires. He has only M (1 <= M <= 100,000) money to invest but wants to maximize his profit (which has a slightly unusual definition) at the end of his first year in business.\n\nCurio type i costs C\\_i (1 <= C\\_i <= 100,000) money to purchase and yields R\\_i (1 <= R\\_i <= 100,000) revenue for each curio sold (a profit of R\\_i-C\\_i). FJ can mix and match the curios he sells in any way he wishes. He need not spend all his money when purchasing curios.\n\nWhat is the greatest amount of total profit (profit = initial\\_cash - all\\_costs + all\\_sales) FJ can have at the end of his first year? This number is guaranteed to be less than 1,000,000,000.\n\nConsider the situation when FJ has just 3 kinds of curios and starts with M=17. Below are the cost and revenue numbers for each curio:\n\nCurio     Cost     Revenue\n\n#        C\\_i       R\\_i\n\n1         2         4\n\n2         5         6\n\n3         3         7\n\nIn this case, FJ should purchase 5 curios of type 3 for 15 money and 1 more curio of type 1 for 2 money, a total of 17 money. His profit will be 5 \\* (7-3) + 1 \\* (4-2) = 5\\*4 + 1\\*2 = 22 money. He can do no better than this given the cost and revenue structure.\n\nNOTE: The second test case is challenging -- but our answer is correct.\n", "inputFormat": "\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: C\\_i and R\\_i\n", "outputFormat": "\\* Line 1: The maximum profit FJ can generate given the costs and revenues\n", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO10OCT] Making Money G", "background": null, "description": "FJ 又经营起了古董生意，买卖一些像奶牛圣诞树上的装饰之类的小玩意。他知道他会将他能存储的 $N(1 \\le N \\le 100)$ 件不同的奶牛古董每件都卖出。\n\n\n而且如果他的钱足够多他可以买他想要的任意数量的古董（即他可以购买的古董数量没有限制）。他只有 $M(1\\le M\\le 10^5)$ 元钱来买古董，但他想要在他经商的第一年年末最大化他的利润（这有点难以解释）。\n\n\n第 $i$ 种古董采购需要花费 $C_i(1\\le C_i \\le 10^5)$ 元钱，每卖掉一件可以获得 $R_i(1\\le R_i \\le 10^5)$ 元钱（每卖一件的利润为 $R_i-C_i$）。FJ 可以以任意顺序卖出他的货物。他并不需要花光他所有的钱来购买古董。\n\n\nFJ 在他经商的第一年年末能得到的最大总利润（利润 = 初始钱数 - 总花费 + 总收入）是多少呢？输入数据保证这个数字不会超过 $10^9$。\n\n\n假设 FJ 只有 $3$ 种古董而且开始时有 $M=17$ 元钱。下面是三种古董的花费和收入。\n\n\n| 古董 | 花费 | 收入 |\n|:---:|:---:|:---:|\n| 1 | 2 | 4 |\n| 2 | 5 | 6 |\n| 3 | 3 | 7 |\n\n在这种情况下，FJ 应该花 $15$ 元购买 $5$ 个 $3$ 号古董，再花 $2$ 元购买 $1$ 个 $1$ 号古董，总共 $17$ 元。他的利润是 $5\\times(7-3)+1\\times(4-2)=5\\times4+1\\times2=22$ 元。他不能获得比这更多的利润了。\n\n\n提示：第二个样例很有挑战性，但我们的答案是正确的。", "inputFormat": "* 第 $1$ 行：两个用空格分隔的整数：$N$ 和 $M$。\n* 第 $2$ 行到第 $N+1$ 行：第 $i+1$ 行包含两个用空格分隔的整数：$C_i$ 和 $R_i$。", "outputFormat": "* 第 $1$ 行：FJ 在给定成本和收入的情况下可以产生的最大利润。", "hint": "（由 ChatGPT 4o 翻译）", "locale": "zh-CN"}}}
