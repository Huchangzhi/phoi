{"pid": "P13315", "type": "P", "difficulty": 4, "samples": [["3\n2 5\n0.6 0.6\n1 20\n1\n3 4\n1 0.9 0.1", "Case #1: 7.000000\nCase #2: 20.000000\nCase #3: 4.500000"]], "limits": {"time": [4000, 4000], "memory": [1048576, 1048576]}, "tags": ["2012", "Special Judge", "期望", "Google Code Jam"], "title": "[GCJ 2012 #1A] Password Problem", "background": "", "description": "I have a really long password, and sometimes I make a mistake when I type it. Right now I've typed part of my password, but I might have made some mistakes. In particular, I might have pressed the wrong key while typing one or more of the previous characters. Given how likely I was to get each character right, what should I do?\n\nI have three options:\n\n1. Finish typing the password, then press \"enter\". I know I'll type the rest of the characters perfectly. If it turns out that one of the earlier characters was wrong, I'll have to retype the whole thing and hit \"enter\" again -- but I know I'll get it right the second time.\n2. Hit \"backspace\" some number of times, deleting the last character(s) I typed, and then complete the password and press \"enter\" as in option 1. If one of the characters I didn't delete was wrong, I'll have to retype the whole thing and press \"enter\", knowing I'll get it right the second time.\n3. Give up by pressing \"enter\", retyping the password from the start, and pressing \"enter\" again. I know I'll get it right this time.\n\nI want to minimize the expected number of keystrokes needed. Each character in the password costs 1 keystroke; each \"backspace\" costs 1 keystroke; pressing \"enter\" to complete an attempt or to give up costs 1 keystroke.\n\nNote: The \"expected\" number of keystrokes is the average number of keystrokes that would be needed if the same situation occurred a very large number of times. See the example below.\n\n**Example**\n\nSuppose my password is \"guest\" and I have already typed the first two characters, but I had a $40\\%$ chance of making a mistake when typing each of them. Then there are four cases:\n\n* I typed \"gu\" without error. This occurs with probability $0.6 \\times 0.6 = 0.36$.\n* I typed the 'g' correctly but I made a mistake typing the 'u'. Then I have two letters typed still, but the second one is wrong: \"gx\". (Here, the 'X' character represents a mistyped letter.) This occurs with probability $0.6 \\times 0.4 = 0.24$.\n* I typed the 'u' correctly but I made a mistake typing the 'g': \"xu\". This occurs with probability $0.4 \\times 0.6 = 0.24$.\n* I made a mistake typing both letters, so I have two incorrect letters: \"xx\". This occurs with probability $0.4 \\times 0.4 = 0.16$.\n\nI don't know how many mistakes I actually made, but for any strategy, I can calculate the expected number of keys required to use it. This is shown in the table below:\n\n| Probability | \"gu\" | \"gx\" | \"xu\" | \"xx\" | Expected |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| Keystrokes if I keep typing | $4$ | $10$ | $10$ | $10$ | $7.84$ |\n| Keystrokes if I press backspace once | $6$ | $6$ | $12$ | $12$ | $8.4$ |\n| Keystrokes if I press backspace twice | $8$ | $8$ | $8$ | $8$ | $8$ |\n| Keystrokes if I press enter right away | $7$ | $7$ | $7$ | $7$ | $7$ |\n\nIf I keep typing, then there is an $0.36$ probability that I will need $4$ keystrokes, and an $0.64$ probability that I will need $10$ keystrokes. If I repeated the trial many times, then I would use $4$ keystrokes $36\\%$ of the time, and $10$ keystrokes the remaining $64\\%$ of the time, so the average number of keystrokes needed would be $0.36 \\times 4 + 0.64 \\times 10 = 7.84$. In this case however, it is better to just press enter right away, which requires $7$ keystrokes.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing two integers, $A$ and $B$. $A$ is the number of characters that I have already typed, and $B$ is the total number of characters in my password.\n\nThis is followed by a line containing $A$ real numbers: $p_1$, $p_2$, $\\dots$, $p_A$. $p_i$ represents the probability that I correctly typed the $i^{th}$ letter in my password. These real numbers will consist of decimal digits and at most one decimal point. The decimal point will never be the first or the last character in a number.", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1) and $y$ is the expected number of additional keystrokes I need, not counting the letters I have typed so far, and assuming I choose the optimal strategy. $y$ must be correct to within an absolute or relative error of $10^{-6}$.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 20$.\n- $0 \\leq p_i \\leq 1$ for all $i$.\n\n**Test set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq A \\leq 3$.\n- $A < B \\leq 100$.\n\n**Test set 2 (10 Pts, Hidden Verdict)**\n\n- $1 \\leq A \\leq 99999$.\n- $A < B \\leq 100000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #1A] Password Problem", "background": "", "description": "I have a really long password, and sometimes I make a mistake when I type it. Right now I've typed part of my password, but I might have made some mistakes. In particular, I might have pressed the wrong key while typing one or more of the previous characters. Given how likely I was to get each character right, what should I do?\n\nI have three options:\n\n1. Finish typing the password, then press \"enter\". I know I'll type the rest of the characters perfectly. If it turns out that one of the earlier characters was wrong, I'll have to retype the whole thing and hit \"enter\" again -- but I know I'll get it right the second time.\n2. Hit \"backspace\" some number of times, deleting the last character(s) I typed, and then complete the password and press \"enter\" as in option 1. If one of the characters I didn't delete was wrong, I'll have to retype the whole thing and press \"enter\", knowing I'll get it right the second time.\n3. Give up by pressing \"enter\", retyping the password from the start, and pressing \"enter\" again. I know I'll get it right this time.\n\nI want to minimize the expected number of keystrokes needed. Each character in the password costs 1 keystroke; each \"backspace\" costs 1 keystroke; pressing \"enter\" to complete an attempt or to give up costs 1 keystroke.\n\nNote: The \"expected\" number of keystrokes is the average number of keystrokes that would be needed if the same situation occurred a very large number of times. See the example below.\n\n**Example**\n\nSuppose my password is \"guest\" and I have already typed the first two characters, but I had a $40\\%$ chance of making a mistake when typing each of them. Then there are four cases:\n\n* I typed \"gu\" without error. This occurs with probability $0.6 \\times 0.6 = 0.36$.\n* I typed the 'g' correctly but I made a mistake typing the 'u'. Then I have two letters typed still, but the second one is wrong: \"gx\". (Here, the 'X' character represents a mistyped letter.) This occurs with probability $0.6 \\times 0.4 = 0.24$.\n* I typed the 'u' correctly but I made a mistake typing the 'g': \"xu\". This occurs with probability $0.4 \\times 0.6 = 0.24$.\n* I made a mistake typing both letters, so I have two incorrect letters: \"xx\". This occurs with probability $0.4 \\times 0.4 = 0.16$.\n\nI don't know how many mistakes I actually made, but for any strategy, I can calculate the expected number of keys required to use it. This is shown in the table below:\n\n| Probability | \"gu\" | \"gx\" | \"xu\" | \"xx\" | Expected |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| Keystrokes if I keep typing | $4$ | $10$ | $10$ | $10$ | $7.84$ |\n| Keystrokes if I press backspace once | $6$ | $6$ | $12$ | $12$ | $8.4$ |\n| Keystrokes if I press backspace twice | $8$ | $8$ | $8$ | $8$ | $8$ |\n| Keystrokes if I press enter right away | $7$ | $7$ | $7$ | $7$ | $7$ |\n\nIf I keep typing, then there is an $0.36$ probability that I will need $4$ keystrokes, and an $0.64$ probability that I will need $10$ keystrokes. If I repeated the trial many times, then I would use $4$ keystrokes $36\\%$ of the time, and $10$ keystrokes the remaining $64\\%$ of the time, so the average number of keystrokes needed would be $0.36 \\times 4 + 0.64 \\times 10 = 7.84$. In this case however, it is better to just press enter right away, which requires $7$ keystrokes.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing two integers, $A$ and $B$. $A$ is the number of characters that I have already typed, and $B$ is the total number of characters in my password.\n\nThis is followed by a line containing $A$ real numbers: $p_1$, $p_2$, $\\dots$, $p_A$. $p_i$ represents the probability that I correctly typed the $i^{th}$ letter in my password. These real numbers will consist of decimal digits and at most one decimal point. The decimal point will never be the first or the last character in a number.", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1) and $y$ is the expected number of additional keystrokes I need, not counting the letters I have typed so far, and assuming I choose the optimal strategy. $y$ must be correct to within an absolute or relative error of $10^{-6}$.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 20$.\n- $0 \\leq p_i \\leq 1$ for all $i$.\n\n**Test set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq A \\leq 3$.\n- $A < B \\leq 100$.\n\n**Test set 2 (10 Pts, Hidden Verdict)**\n\n- $1 \\leq A \\leq 99999$.\n- $A < B \\leq 100000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #1A] Password Problem", "background": "", "description": "我有一个非常长的密码，有时候在输入时会出错。现在我已经输入了部分密码，但可能在输入前面的某些字符时按错了键。已知我每个字符输入正确的概率，你觉得我该怎么做？\n\n我有三种选择：\n\n1. 继续输入剩下的密码，然后按下“回车”。我知道剩下的字符我一定能全部正确输入。如果之前输入的某个字符错了，我就需要重新输入整个密码并再次按“回车”——而这次我一定能全部输入正确。\n2. 按下“退格键”若干次，删除我已经输入的最后若干字符，然后像选项 1 那样输入剩下的密码并按“回车”。如果没有删除的字符中有错的，我仍需重新输入整个密码并再次按“回车”，这次我一定能全部输入正确。\n3. 直接放弃，按“回车”重新输入整个密码，再按一次“回车”。我知道这次我一定能全部输入正确。\n\n我希望让期望按键次数最小。每输入一个字符算一次按键，每按一次“退格键”也算一次按键，每按一次“回车”完成一次尝试或直接放弃也算一次按键。\n\n注意：“期望”按键次数是指如果这种情况发生很多次，平均每次需要的按键数。见下例。\n\n**例子**\n\n假设我的密码是“guest”，我已经输入了前两个字符，但每个字符输入时出错的概率都是 $40\\%$。那么共有四种情况：\n\n* 我输入了“gu”，全对。这种情况概率为 $0.6 \\times 0.6 = 0.36$。\n* 我输入了 'g' 正确，'u' 错了，此时输入的是“gx”。（这里 'X' 表示输错的字符。）概率为 $0.6 \\times 0.4 = 0.24$。\n* 我输入了 'u' 正确，'g' 错了，输入的是“xu”。概率为 $0.4 \\times 0.6 = 0.24$。\n* 两个都错了，输入的是“xx”。概率为 $0.4 \\times 0.4 = 0.16$。\n\n我并不知道自己实际错了几个，但对于任何策略，都可以算出期望按键次数。如下表：\n\n| 概率 | \"gu\" | \"gx\" | \"xu\" | \"xx\" | 期望值 |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| 如果继续输入 | $4$ | $10$ | $10$ | $10$ | $7.84$ |\n| 如果退格一次 | $6$ | $6$ | $12$ | $12$ | $8.4$ |\n| 如果退格两次 | $8$ | $8$ | $8$ | $8$ | $8$ |\n| 如果直接放弃 | $7$ | $7$ | $7$ | $7$ | $7$ |\n\n如果我继续输入，有 $0.36$ 的概率只需 $4$ 次按键，有 $0.64$ 的概率需要 $10$ 次按键。大量重复这种情况，平均每次需要 $0.36 \\times 4 + 0.64 \\times 10 = 7.84$ 次按键。但在这个例子中，直接放弃（重输）只需要 $7$ 次按键，是更优选择。\n", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组数据第一行为两个整数 $A$ 和 $B$，表示我已经输入的字符数 $A$，以及密码总长度 $B$。\n\n接下来一行给出 $A$ 个实数：$p_1, p_2, \\dots, p_A$，其中 $p_i$ 表示第 $i$ 个字符输入正确的概率。这些实数为小数，最多有一个小数点，小数点不会出现在数字开头或结尾。\n", "outputFormat": "对于每个测试用例，输出一行 \"Case #x: y\"，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为在最优策略下，除去已经输入的字符后，期望还需按下的按键数。$y$ 的绝对或相对误差需不超过 $10^{-6}$。\n", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 20$\n- 对所有 $i$，$0 \\leq p_i \\leq 1$\n\n**测试集 1（10 分，可见结果）**\n\n- $1 \\leq A \\leq 3$\n- $A < B \\leq 100$\n\n**测试集 2（10 分，隐藏结果）**\n\n- $1 \\leq A \\leq 99999$\n- $A < B \\leq 100000$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13316", "type": "P", "difficulty": 4, "samples": [["4\n2\n0 1\n0 2\n3\n2 2\n0 0\n4 4\n1\n1 1\n5\n0 5\n0 1\n1 1\n4 7\n5 6", "Case #1: 3\nCase #2: 3\nCase #3: Too Bad\nCase #4: 6"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2012", "Google Code Jam"], "title": "[GCJ 2012 #1A] Kingdom Rush", "background": "Kingdom Rush was created by Ironhide Game Studio. Ironhide Game Studio does not endorse and has no involvement with Google Code Jam.", "description": "Ryan is playing Kingdom Rush, a single-player tower defense game developed by Ironhide Game Studio. In Kingdom Rush, players earn stars by completing levels, in a way described below. Having more stars makes the player more powerful; so while Ryan might not be able to complete level 2 right away, he might be able to complete it after earning stars from level 1.\n\nThe real game Kingdom Rush doesn't work in quite the same way as this problem. It isn't important to have played the game in order to solve the problem.\n\nIn this problem's version of Kingdom Rush, when a player completes a level, he or she is given a 1-star rating or a 2-star rating. That rating might allow the player to earn stars as follows:\n\n* If the player has never completed the level before and completes it with a 1-star rating, that player earns 1 star.\n* If the player has never completed the level before and completes it with a 2-star rating, that player earns 2 stars.\n* If the player has only completed the level before with a 1-star rating and completes it this time with a 2-star rating, the player earns 1 more star.\n\nOtherwise there is no way for a player to earn stars.\n\nRyan might not be able to complete every level right away. For each level, before he can complete it with a 1-star rating, he needs to have earned a certain number of stars; and he will need a larger or equal number of stars to complete that level with a 2-star rating.\n\nFor example, suppose there are two levels:\n\n* Level 1 requires 0 stars to complete with a 1-star rating, and 1 star to complete with a 2-star rating.\n* Level 2 requires 0 stars to complete with a 1-star rating, and 2 stars to complete with a 2-star rating.\n\nHere's a possible series of events for Ryan:\n\n1. Ryan starts with 0 stars. He can choose to complete either level 1 or level 2 with a 1-star rating. He chooses to complete level 1 with a 1-star rating. Now he has 1 star.\n2. Now Ryan can either complete level 2 with a 1-star rating, or level 1 with a 2-star rating. He chooses to complete level 1 with a 2-star rating. Now he has 2 stars.\n3. Now Ryan can complete level 2 with a 2-star rating. He does that, and now he has 4 stars.\n4. Now he is done, having completed all levels with 2-star ratings and earned 4 stars (2 per level). He has completed levels 3 times: level 1 twice, and level 2 once.\n\nRyan is great at tower defense games, but he needs some help to beat Kingdom Rush as quickly as possible. Your job is to figure out how many times he needs to complete levels in order to earn a 2-star rating on every level.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line containing a single integer $N$, indicating how many levels are in the game. $N$ lines follow. The $i$th line contains two integers $a_i$ and $b_i$: the number of stars it takes to earn a one-star rating or a two-star rating, respectively, on level $i$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1) and $y$ is the minimum number of times Ryan must complete levels in order to have earned a 2-star rating on every level. If it is impossible for Ryan to earn a 2-star rating on every level, $y$ should instead be the string \"Too Bad\" (without the \" characters, but with that exact capitalization). This indicates that Ryan is too bad at Kingdom Rush to finish the whole game.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $0 \\leq a_i \\leq b_i \\leq 2001$.\n\n**Test set 1 (15 Pts, Visible Verdict)**\n\n- $1 \\leq N \\leq 10$.\n\n**Test set 2 (18 Pts, Hidden Verdict)**\n\n- $1 \\leq N \\leq 1000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #1A] Kingdom Rush", "background": "Kingdom Rush was created by Ironhide Game Studio. Ironhide Game Studio does not endorse and has no involvement with Google Code Jam.", "description": "Ryan is playing Kingdom Rush, a single-player tower defense game developed by Ironhide Game Studio. In Kingdom Rush, players earn stars by completing levels, in a way described below. Having more stars makes the player more powerful; so while Ryan might not be able to complete level 2 right away, he might be able to complete it after earning stars from level 1.\n\nThe real game Kingdom Rush doesn't work in quite the same way as this problem. It isn't important to have played the game in order to solve the problem.\n\nIn this problem's version of Kingdom Rush, when a player completes a level, he or she is given a 1-star rating or a 2-star rating. That rating might allow the player to earn stars as follows:\n\n* If the player has never completed the level before and completes it with a 1-star rating, that player earns 1 star.\n* If the player has never completed the level before and completes it with a 2-star rating, that player earns 2 stars.\n* If the player has only completed the level before with a 1-star rating and completes it this time with a 2-star rating, the player earns 1 more star.\n\nOtherwise there is no way for a player to earn stars.\n\nRyan might not be able to complete every level right away. For each level, before he can complete it with a 1-star rating, he needs to have earned a certain number of stars; and he will need a larger or equal number of stars to complete that level with a 2-star rating.\n\nFor example, suppose there are two levels:\n\n* Level 1 requires 0 stars to complete with a 1-star rating, and 1 star to complete with a 2-star rating.\n* Level 2 requires 0 stars to complete with a 1-star rating, and 2 stars to complete with a 2-star rating.\n\nHere's a possible series of events for Ryan:\n\n1. Ryan starts with 0 stars. He can choose to complete either level 1 or level 2 with a 1-star rating. He chooses to complete level 1 with a 1-star rating. Now he has 1 star.\n2. Now Ryan can either complete level 2 with a 1-star rating, or level 1 with a 2-star rating. He chooses to complete level 1 with a 2-star rating. Now he has 2 stars.\n3. Now Ryan can complete level 2 with a 2-star rating. He does that, and now he has 4 stars.\n4. Now he is done, having completed all levels with 2-star ratings and earned 4 stars (2 per level). He has completed levels 3 times: level 1 twice, and level 2 once.\n\nRyan is great at tower defense games, but he needs some help to beat Kingdom Rush as quickly as possible. Your job is to figure out how many times he needs to complete levels in order to earn a 2-star rating on every level.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line containing a single integer $N$, indicating how many levels are in the game. $N$ lines follow. The $i$th line contains two integers $a_i$ and $b_i$: the number of stars it takes to earn a one-star rating or a two-star rating, respectively, on level $i$.\n", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1) and $y$ is the minimum number of times Ryan must complete levels in order to have earned a 2-star rating on every level. If it is impossible for Ryan to earn a 2-star rating on every level, $y$ should instead be the string \"Too Bad\" (without the \" characters, but with that exact capitalization). This indicates that Ryan is too bad at Kingdom Rush to finish the whole game.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100$.\n- $0 \\leq a_i \\leq b_i \\leq 2001$.\n\n**Test set 1 (15 Pts, Visible Verdict)**\n\n- $1 \\leq N \\leq 10$.\n\n**Test set 2 (18 Pts, Hidden Verdict)**\n\n- $1 \\leq N \\leq 1000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #1A] Kingdom Rush", "background": "Kingdom Rush 由 Ironhide Game Studio 开发。Ironhide Game Studio 未参与本题，也未对 Google Code Jam 进行任何背书。\n", "description": "Ryan 正在玩 Kingdom Rush，这是一款由 Ironhide Game Studio 开发的单人塔防游戏。在 Kingdom Rush 中，玩家通过完成关卡获得星星，具体规则如下。星星越多，玩家就越强大；因此，Ryan 也许暂时无法完成第 2 关，但他可以先通过第 1 关获得星星后再挑战第 2 关。\n\n真实的 Kingdom Rush 游戏机制与本题略有不同。你不需要玩过这款游戏也能解题。\n\n在本题描述的 Kingdom Rush 里，当玩家完成某一关时，可以获得 1 星或 2 星的评价。获得星星的具体规则如下：\n\n* 如果玩家从未通关该关卡，并以 1 星评价通关，则获得 1 颗星。\n* 如果玩家从未通关该关卡，并以 2 星评价通关，则获得 2 颗星。\n* 如果玩家之前以 1 星评价通关过该关卡，现在以 2 星评价再次通关，则再获得 1 颗星。\n\n除此之外，玩家无法再通过该关卡获得星星。\n\nRyan 可能并不能立刻完成所有关卡。对于每一关，在以 1 星评价完成前，需要至少获得 $a_i$ 颗星；而以 2 星评价完成前，需要至少获得 $b_i$ 颗星，且 $b_i \\geq a_i$。\n\n例如，假设有两关：\n\n* 第 1 关：以 1 星评价完成需要 0 颗星，以 2 星评价完成需要 1 颗星。\n* 第 2 关：以 1 星评价完成需要 0 颗星，以 2 星评价完成需要 2 颗星。\n\nRyan 可能的通关流程如下：\n\n1. Ryan 初始有 0 颗星。他可以选择以 1 星评价完成第 1 关或第 2 关。他选择以 1 星评价通关第 1 关，此时有 1 颗星。\n2. 现在，Ryan 可以选择以 1 星评价通关第 2 关，或以 2 星评价再次通关第 1 关。他选择以 2 星评价通关第 1 关，此时有 2 颗星。\n3. 现在，Ryan 可以以 2 星评价通关第 2 关。他完成后共有 4 颗星。\n4. 此时他已完成所有关卡的 2 星评价，累计获得 4 颗星（每关 2 颗）。他一共通关了 3 次：第 1 关两次，第 2 关一次。\n\nRyan 很擅长塔防游戏，但他需要你的帮助来尽快通关。你的任务是计算，为了让每一关都获得 2 星评价，Ryan 至少需要通关多少次。\n", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组数据第一行为整数 $N$，表示该游戏包含的关卡数。接下来 $N$ 行，每行两个整数 $a_i$ 和 $b_i$，分别表示第 $i$ 关以 1 星和 2 星评价完成所需的星星数。\n", "outputFormat": "对于每个测试用例，输出一行 \"Case #x: y\"，其中 $x$ 为测试用例编号（从 1 开始），$y$ 表示 Ryan 至少需要通关的次数，以使每一关都获得 2 星评价。如果无法让每一关都获得 2 星评价，则输出 \"Too Bad\"（不带引号，大小写严格一致）。这表示 Ryan 没有能力完成整个游戏。\n", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 100$\n- $0 \\leq a_i \\leq b_i \\leq 2001$\n\n**测试集 1（15 分，结果可见）**\n\n- $1 \\leq N \\leq 10$\n\n**测试集 2（18 分，结果隐藏）**\n\n- $1 \\leq N \\leq 1000$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13317", "type": "P", "difficulty": 6, "samples": [["4\n2\nL 5 10\nL 100 0\n3\nL 100 0\nR 100 0\nL 50 505\n6\nL 30 0\nR 30 2\nL 10 39\nR 10 42\nL 25 13\nL 15 29\n4\nL 4 0\nL 2 29\nL 1 35\nL 1 44", "Case #1: Possible\nCase #2: 10.0\nCase #3: 1.4\nCase #4: 12.0"]], "limits": {"time": [1000, 1000], "memory": [524288, 524288]}, "tags": ["2012", "Special Judge", "Google Code Jam"], "title": "[GCJ 2012 #1A] Cruise Control", "background": "", "description": "Cruise control is a system that allows a car to go at a constant speed, while the driver controls only the steering wheel. The driver can, of course, turn off the cruise control to avoid collisions.\n\nIn this problem, we will consider a one-way road with two lanes, and $N$ cars using cruise control on the road. Each car is 5 meters long and goes at some constant speed. A car can change lanes at any time if it would not cause the car to collide with some other car (touching does not count as collision). Assume that changing lanes is instantaneous and simply causes the car to switch to the other lane. We are interested in whether any driver will have to turn off cruise control eventually to avoid a collision, or is it possible for all of them to drive (possibly switching lanes, but at constant speed) without collisions indefinitely. Note that even though changing lanes is instantaneous, two cars driving side by side cannot exchange places by changing lanes at the same time.\n", "inputFormat": "The first line of the input file gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with the number $N$. $N$ lines follow, each describing a single car. Each line contains a character $C_i$ (denoting whether the car is initially in the left or the right lane), two integers describing the speed $S_i$ of the car (in meters per second), and the initial position $P_i$ of the car (in meters), denoting the distance between the rear end of the car and some fixed line across the road. All the cars are moving away from this line, and no car is behind the line.\n", "outputFormat": "For each test case output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1) and $y$ is either the word \"Possible\" (quotes for clarity only), if the cars can drive at the given constant speeds indefinitely, or the maximum number of seconds they can drive before somebody has to change speed to avoid a collision. Answers accurate to within $10^{-5}$ absolute or relative error will be accepted.", "hint": "**Sample Explanation**\n\nIn the first case, the faster car can shift over to the right lane and easily overtake the slower one. In the second case, the two cars driving side-by-side at 100 m/s will reach the car going 50 m/s in 10 seconds, and somebody will have to change speed, as both lanes will be blocked.\n\n**Limits**\n\n- $1 \\leq T \\leq 30$.\n- $1 \\leq S_i \\leq 1000$.\n- $0 \\leq P_i \\leq 10000$.\n- Each of the $C_i$ characters will be either $L$, denoting the left lane, or $R$, denoting the right lane.\n- Initially the cars' positions are such that they do not collide, that is, if two cars $i$ and $j$ have the same initial starting lane (that is, $C_i = C_j$), then $|P_i - P_j| \\geq 5$.\n\n**Test set 1 (17 Pts, Visible Verdict)**\n\n- $1 \\leq N \\leq 6$.\n\n**Test set 2 (30 Pts, Hidden Verdict)**\n\n- $1 \\leq N \\leq 50$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #1A] Cruise Control", "background": "", "description": "Cruise control is a system that allows a car to go at a constant speed, while the driver controls only the steering wheel. The driver can, of course, turn off the cruise control to avoid collisions.\n\nIn this problem, we will consider a one-way road with two lanes, and $N$ cars using cruise control on the road. Each car is 5 meters long and goes at some constant speed. A car can change lanes at any time if it would not cause the car to collide with some other car (touching does not count as collision). Assume that changing lanes is instantaneous and simply causes the car to switch to the other lane. We are interested in whether any driver will have to turn off cruise control eventually to avoid a collision, or is it possible for all of them to drive (possibly switching lanes, but at constant speed) without collisions indefinitely. Note that even though changing lanes is instantaneous, two cars driving side by side cannot exchange places by changing lanes at the same time.\n", "inputFormat": "The first line of the input file gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with the number $N$. $N$ lines follow, each describing a single car. Each line contains a character $C_i$ (denoting whether the car is initially in the left or the right lane), two integers describing the speed $S_i$ of the car (in meters per second), and the initial position $P_i$ of the car (in meters), denoting the distance between the rear end of the car and some fixed line across the road. All the cars are moving away from this line, and no car is behind the line.\n", "outputFormat": "For each test case output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1) and $y$ is either the word \"Possible\" (quotes for clarity only), if the cars can drive at the given constant speeds indefinitely, or the maximum number of seconds they can drive before somebody has to change speed to avoid a collision. Answers accurate to within $10^{-5}$ absolute or relative error will be accepted.", "hint": "**Sample Explanation**\n\nIn the first case, the faster car can shift over to the right lane and easily overtake the slower one. In the second case, the two cars driving side-by-side at 100 m/s will reach the car going 50 m/s in 10 seconds, and somebody will have to change speed, as both lanes will be blocked.\n\n**Limits**\n\n- $1 \\leq T \\leq 30$.\n- $1 \\leq S_i \\leq 1000$.\n- $0 \\leq P_i \\leq 10000$.\n- Each of the $C_i$ characters will be either $L$, denoting the left lane, or $R$, denoting the right lane.\n- Initially the cars' positions are such that they do not collide, that is, if two cars $i$ and $j$ have the same initial starting lane (that is, $C_i = C_j$), then $|P_i - P_j| \\geq 5$.\n\n**Test set 1 (17 Pts, Visible Verdict)**\n\n- $1 \\leq N \\leq 6$.\n\n**Test set 2 (30 Pts, Hidden Verdict)**\n\n- $1 \\leq N \\leq 50$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #1A] Cruise Control", "background": "", "description": "巡航控制是一种让汽车以恒定速度行驶的系统，驾驶员只需控制方向盘。当然，司机可以随时关闭巡航控制以避免碰撞。\n\n在本题中，我们考虑一条单向双车道公路，路上有 $N$ 辆车正在以巡航控制模式行驶。每辆车长 $5$ 米，并以某个恒定速度行驶。只要不会与其他车辆发生碰撞（“接触”不算碰撞），车辆可以随时变道。假设变道是瞬时完成的，只需将车辆切换到另一车道即可。我们关心的是，是否所有司机都可以一直保持恒定速度（可以变道），而永远无需关闭巡航控制来避免碰撞，或者说，是否最终有人必须减速或加速以避免碰撞。请注意，虽然变道是瞬时的，但两辆并排行驶的车辆不能同时通过变道交换位置。\n", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组数据的第一行为整数 $N$，表示车辆数。接下来 $N$ 行，每行描述一辆车，包含一个字符 $C_i$（表示该车初始在左车道还是右车道），两个整数分别表示该车的速度 $S_i$（单位：米/秒）和初始位置 $P_i$（单位：米），即该车车尾距离公路某条参考线的距离。所有车辆都在远离该参考线的方向行驶，且没有车辆在参考线后方。\n", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #x: y\"，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为 \"Possible\"（仅为说明加引号，输出时不要带引号），如果所有车辆都能一直以给定速度行驶（可以变道）而无需改变速度；否则，$y$ 为最大能保持恒定速度行驶的秒数（即在某人必须改变速度以避免碰撞之前的最长时间）。答案的绝对或相对误差在 $10^{-5}$ 以内均视为正确。\n", "hint": "**样例说明**\n\n在第一个样例中，较快的车辆可以变道到右侧，轻松超越较慢的车辆。在第二个样例中，两辆以 $100$ m/s 行驶的车会在 $10$ 秒后追上以 $50$ m/s 行驶的车，届时两条车道都被堵住了，某辆车必须改变速度。\n\n**限制条件**\n\n- $1 \\leq T \\leq 30$\n- $1 \\leq S_i \\leq 1000$\n- $0 \\leq P_i \\leq 10000$\n- 每个 $C_i$ 字符为 $L$（左车道）或 $R$（右车道）\n- 初始时各车位置不会发生碰撞，即若两辆车 $i$ 和 $j$ 在同一车道（$C_i = C_j$），则 $|P_i - P_j| \\geq 5$\n\n**测试集 1（17 分，结果可见）**\n\n- $1 \\leq N \\leq 6$\n\n**测试集 2（30 分，结果隐藏）**\n\n- $1 \\leq N \\leq 50$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13318", "type": "P", "difficulty": 4, "samples": [["4\n2 20 10\n2 10 0\n4 25 25 25 25\n3 24 30 21", "Case #1: 33.333333 66.666667\nCase #2: 0.000000 100.000000\nCase #3: 25.0 25.0 25.0 25.0\nCase #4: 34.666667 26.666667 38.666667"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["数学", "2012", "二分", "Special Judge", "Google Code Jam"], "title": "[GCJ 2012 #1B] Safety in Numbers", "background": "", "description": "There are $N$ contestants in a reality TV show. Each contestant is assigned a point value by the judges and receives votes from the audience. The point value given by the judges and the audience's votes are combined to form a final score for the contestant, in the following way:\n\nLet $x$ be the sum of the judge-assigned point values of all contestants. Now suppose a contestant got $j$ points from the judges, and that she received a fraction $y$ (between 0 and 1, inclusive) of the audience's votes ($y$ might be, for example, 0.3). Then that contestant's final score is $j + x \\cdot y$. Note that the sum of all contestants' audience vote fractions must be 1.\n\nThe contestant with the lowest score is eliminated.\n\nGiven the points contestants got from judges, your job is to find out, for each contestant, the minimum percentage of audience votes he/she must receive in order for him/her to be guaranteed not to be eliminated, no matter how the rest of the audience's votes are distributed.\n\nIf the lowest score is shared by multiple contestants, no contestants will be eliminated.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, one per line. Each line starts with an integer $N$, the number of contestants, followed by a space, followed by $N$ integers $s_0, s_1, ..., s_{N-1}$, separated by single spaces. The integer $s_i$ is the point value assigned to contestant $i$ by the judges.\n", "outputFormat": "For each test case, output one line containing \"Case #x: \" followed by $N$ real numbers: $m_i$s. The value $x$ is the case number (starting from 1). The value $m_i$ is the smallest percentage of audience votes required for contestant $i$ to definitely avoid elimination.\n\nAnswers within an absolute or relative error of $10^{-5}$ of the correct answer will be accepted.", "hint": "**Limits**\n\n- $0 \\leq s_i \\leq 100$.\n- $s_i > 0$ for some $i$. This means at least one contestant will have a point value greater than $0$.\n\n**Test set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq T \\leq 20$.\n- $2 \\leq N \\leq 10$.\n\n**Test set 2 (11 Pts, Hidden Verdict)**\n\n- $1 \\leq T \\leq 50$.\n- $2 \\leq N \\leq 200$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #1B] Safety in Numbers", "background": "", "description": "There are $N$ contestants in a reality TV show. Each contestant is assigned a point value by the judges and receives votes from the audience. The point value given by the judges and the audience's votes are combined to form a final score for the contestant, in the following way:\n\nLet $x$ be the sum of the judge-assigned point values of all contestants. Now suppose a contestant got $j$ points from the judges, and that she received a fraction $y$ (between 0 and 1, inclusive) of the audience's votes ($y$ might be, for example, 0.3). Then that contestant's final score is $j + x \\cdot y$. Note that the sum of all contestants' audience vote fractions must be 1.\n\nThe contestant with the lowest score is eliminated.\n\nGiven the points contestants got from judges, your job is to find out, for each contestant, the minimum percentage of audience votes he/she must receive in order for him/her to be guaranteed not to be eliminated, no matter how the rest of the audience's votes are distributed.\n\nIf the lowest score is shared by multiple contestants, no contestants will be eliminated.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, one per line. Each line starts with an integer $N$, the number of contestants, followed by a space, followed by $N$ integers $s_0, s_1, ..., s_{N-1}$, separated by single spaces. The integer $s_i$ is the point value assigned to contestant $i$ by the judges.\n", "outputFormat": "For each test case, output one line containing \"Case #x: \" followed by $N$ real numbers: $m_i$s. The value $x$ is the case number (starting from 1). The value $m_i$ is the smallest percentage of audience votes required for contestant $i$ to definitely avoid elimination.\n\nAnswers within an absolute or relative error of $10^{-5}$ of the correct answer will be accepted.", "hint": "**Limits**\n\n- $0 \\leq s_i \\leq 100$.\n- $s_i > 0$ for some $i$. This means at least one contestant will have a point value greater than $0$.\n\n**Test set 1 (10 Pts, Visible Verdict)**\n\n- $1 \\leq T \\leq 20$.\n- $2 \\leq N \\leq 10$.\n\n**Test set 2 (11 Pts, Hidden Verdict)**\n\n- $1 \\leq T \\leq 50$.\n- $2 \\leq N \\leq 200$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #1B] Safety in Numbers", "background": "", "description": "有 $N$ 名选手参加一档真人秀节目。每位选手会被评委打分，并获得观众投票。评委分数与观众投票将按照如下方式合成为选手的最终得分：\n\n设 $x$ 为所有选手评委分数的总和。假设某位选手获得了 $j$ 分评委分数，并且她获得了观众投票的 $y$ 部分（$y$ 在 $0$ 到 $1$ 之间，包括 $0$ 和 $1$，例如 $y$ 可能为 $0.3$）。那么这位选手的最终得分为 $j + x \\cdot y$。注意，所有选手获得的观众投票比例之和必须为 $1$。\n\n得分最低的选手将被淘汰。\n\n现在给定每位选手从评委那里获得的分数，你的任务是，对于每一位选手，计算她为了**确保自己不会被淘汰**，无论其他观众票如何分配，至少需要获得多少百分比的观众投票。\n\n如果有多名选手并列最低分，则没有任何选手会被淘汰。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 行，每行一个测试用例。每个测试用例以一个整数 $N$ 开头，表示选手人数，后面跟着 $N$ 个整数 $s_0, s_1, ..., s_{N-1}$，分别表示每位选手从评委那里获得的分数。各数之间用一个空格分隔。\n", "outputFormat": "对于每个测试用例，输出一行，格式为 \"Case #x: \"，后接 $N$ 个实数 $m_i$。$x$ 为测试用例编号（从 $1$ 开始），$m_i$ 表示第 $i$ 位选手为确保不会被淘汰，至少需要获得的观众投票百分比。\n\n只要答案的绝对或相对误差不超过 $10^{-5}$，即视为正确。", "hint": "**限制条件**\n\n- $0 \\leq s_i \\leq 100$\n- 至少存在一个 $i$ 使得 $s_i > 0$。也就是说，至少有一名选手的评委分数大于 $0$。\n\n**测试集 1（10 分，结果可见）**\n\n- $1 \\leq T \\leq 20$\n- $2 \\leq N \\leq 10$\n\n**测试集 2（11 分，结果隐藏）**\n\n- $1 \\leq T \\leq 50$\n- $2 \\leq N \\leq 200$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13319", "type": "P", "difficulty": 4, "samples": [["4\n200 1 2\n250 233\n180 100\n100 3 3\n500 500 500\n500 500 600\n500 140 1000\n10 10 10\n10 10 490\n10 10 10\n100 3 3\n500 100 500\n100 100 500\n500 500 500\n10 10 10\n10 10 10\n10 10 10\n100 2 2\n1000 1000\n1000 1000\n100 900\n900 100", "Case #1: 11.7\nCase #2: 3.0\nCase #3: 18.0\nCase #4: 0.0"]], "limits": {"time": [4000, 4000], "memory": [1048576, 1048576]}, "tags": ["图论", "2012", "Special Judge", "最短路", "Google Code Jam"], "title": "[GCJ 2012 #1B] Tide Goes In, Tide Goes Out", "background": "", "description": "You are kayaking through a system of underground caves and suddenly realize that the tide is coming in and you are trapped! Luckily, you have a map of the cave system. You are stuck until the tide starts going out, so you will be here for a while. In the meantime, you want to determine the fastest way to the exit once the tide starts going out.\n\nThe cave system is an $N$ by $M$ grid. Your map consists of two $N$ by $M$ grids of numbers: one that specifies the height of the ceiling in each grid square, and one that specifies the height of the floor in each grid square. The floor of the cave system is porous, which means that as the water level falls, no water will remain above the water level.\n\nYou are trapped at the north-west corner of the map. The current water level is $H$ centimeters, and once it starts going down, it will drop at a constant rate of 10 centimeters per second, down to zero. The exit is at the south-east corner of the map. It is now covered by water, but it will become passable as soon as the water starts going down.\n\nAt any time, you can move north, south, east or west to an adjacent square with the following constraints:\n\n* The water level, the floor height of your current square, and the floor height of the adjacent square must all be at least 50 centimeters lower than the ceiling height of the adjacent square. Note: this means that you will never be able to enter a square with less than 50 centimeters between the floor and the ceiling.\n* The floor height of the adjacent square must be at least 50 centimeters below the ceiling height of your current square as well.\n* You can never move off the edge of the map.\n\nNote that you can go up or down as much as you want with your kayak. (You're very athletic from all this kayaking!) For example, you can go from a square with floor at height 10 centimeters to an adjacent square with floor at height 9000 centimeters (assuming the constraints given above are met).\n\nThese constraints are illustrated below: \n\n* In the first image, you can't move to the right because the water level is less than 50 centimeters below the ceiling height of the adjacent square.\n* In the second image, you can't move to the right because the floor height of your current square is less than 50 centimeters below the ceiling height of the adjacent square.\n* In the third image, you can't move to the right because the floor height of the adjacent square is less than 50 centimeters below the ceiling height of the adjacent square. You'll never be able to enter that square from any direction.\n* In the fourth image, you can't move to the right because the floor height of the adjacent square is less than 50 centimeters below the ceiling height of the current square.\n\nWhen moving from one square to another, if there are at least 20 centimeters of water remaining on the current square when you start moving from it, it takes 1 second to complete the move (you can use your kayak). Otherwise, it takes 10 seconds (you have to drag your kayak). Note that the time depends only on the water level in the square you are leaving, not in the square you are entering.\n\nIt will be a while before the tide starts going out, and so you can spend as much time moving as you want before the water starts going down. What matters is how much time you will need from the moment the water starts going down until the moment you reach the exit. Can you calculate this time?\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1sc1nj3u.png)\n\n", "inputFormat": "* The first line will contain a single integer, $T$: the number of test cases\n* It is followed by $T$ test cases, each starting with a line containing integers $H$, $N$ and $M$, representing the initial water level height, in centimeters, and the map dimensions. The following $2N$ lines contain the ceiling and floor heights as follows:\n    * The next $N$ lines contain $M$ space-separated integers each. The $j$th integer in the $i$th row represents $C_{ij}$, the height of the ceiling in centimeters at grid location $(j, i)$, where increasing $i$ coordinates go South, and increasing $j$ coordinates go East.\n    * The next $N$ lines contain $M$ space-separated integers representing the heights of the floor, in the same format.\n* At the starting location, there will always be at least 50 cm of air between the ceiling and the starting water level, and at least 50 cm between the ceiling and the floor.\n* The exit location will always have at least 50 cm of air between the ceiling and the floor.\n* There will always be a way out (you got in, after all!).", "outputFormat": "For each test case, output one line containing \"Case #x: t\", where $x$ is the case number (starting from 1), and $t$ is the time, in seconds, starting from when the tide begins going out, that it takes you to make your way out of the cave system. Answers within an absolute or relative error of $10^{-6}$ of the correct answer will be accepted.\n\nIt is possible that you can go through the whole cave system before the tide starts dropping. In this case you will be able to wait at the exit for the tide to start dropping, so the answer in this case should be zero (this is the case in the fourth of the sample test cases).", "hint": "**Sample Explanation**\n\nIn the first sample test case, there are initially only 33 centimeters between the water level and the ceiling of the eastern square, so after the tide starts going down, you have to wait for at 1.7 seconds to enter it. Once it is accessible, you can start going in - but the water level in the western square is now so low (only 3 centimeters above the floor) that you have to drag your kayak for the next 10 seconds to get to the exit point.\n\nThe initial situation in the second case is better - you have a lot of headroom in adjacent squares, so you can move, for example, to $(1, 1)$ before the tide starts dropping. Once there, you have to wait for the tide to start going down, and the water level to go down to 90cm (that takes one second). Then you can kayak south and then east and get out (in a total of three seconds). Note that you cannot go through the cave at $(2, 1)$, even though the ceiling there is high enough, because there is too little space between the floor of this cave and the ceiling of any caves you could try to enter from ($(1, 1)$ and $(2, 0)$) - only 10 centimeters in each case.\n\nThe third case is somewhat similar to the first - you have to wait at the starting position until the tide goes down to 50cm. After that you can kayak for the exit - but after three moves (taking three seconds) the water is at 20cm, which is only 10cm above the floor, which means the fourth move will be dragging instead of kayaking.\n\nIn the fourth case you are really lucky! You can immediately go the exit, even before the tide starts leaving, and wait there.\n\n**Test set 1 (18 Pts, Visible Verdict)**\n\n- $1 \\leq T \\leq 50$.\n- $1 \\leq N, M \\leq 10$.\n- $1 \\leq H \\leq 1000$.\n- $1 \\leq F_{xy} \\leq C_{xy} \\leq 1000$.\n\n**Test set 2 (18 Pts, Hidden Verdict)**\n\n- $1 \\leq T \\leq 50$.\n- $1 \\leq N, M \\leq 100$.\n- $1 \\leq H \\leq 10000$.\n- $1 \\leq F_{xy} \\leq C_{xy} \\leq 10000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #1B] Tide Goes In, Tide Goes Out", "background": "", "description": "You are kayaking through a system of underground caves and suddenly realize that the tide is coming in and you are trapped! Luckily, you have a map of the cave system. You are stuck until the tide starts going out, so you will be here for a while. In the meantime, you want to determine the fastest way to the exit once the tide starts going out.\n\nThe cave system is an $N$ by $M$ grid. Your map consists of two $N$ by $M$ grids of numbers: one that specifies the height of the ceiling in each grid square, and one that specifies the height of the floor in each grid square. The floor of the cave system is porous, which means that as the water level falls, no water will remain above the water level.\n\nYou are trapped at the north-west corner of the map. The current water level is $H$ centimeters, and once it starts going down, it will drop at a constant rate of 10 centimeters per second, down to zero. The exit is at the south-east corner of the map. It is now covered by water, but it will become passable as soon as the water starts going down.\n\nAt any time, you can move north, south, east or west to an adjacent square with the following constraints:\n\n* The water level, the floor height of your current square, and the floor height of the adjacent square must all be at least 50 centimeters lower than the ceiling height of the adjacent square. Note: this means that you will never be able to enter a square with less than 50 centimeters between the floor and the ceiling.\n* The floor height of the adjacent square must be at least 50 centimeters below the ceiling height of your current square as well.\n* You can never move off the edge of the map.\n\nNote that you can go up or down as much as you want with your kayak. (You're very athletic from all this kayaking!) For example, you can go from a square with floor at height 10 centimeters to an adjacent square with floor at height 9000 centimeters (assuming the constraints given above are met).\n\nThese constraints are illustrated below: \n\n* In the first image, you can't move to the right because the water level is less than 50 centimeters below the ceiling height of the adjacent square.\n* In the second image, you can't move to the right because the floor height of your current square is less than 50 centimeters below the ceiling height of the adjacent square.\n* In the third image, you can't move to the right because the floor height of the adjacent square is less than 50 centimeters below the ceiling height of the adjacent square. You'll never be able to enter that square from any direction.\n* In the fourth image, you can't move to the right because the floor height of the adjacent square is less than 50 centimeters below the ceiling height of the current square.\n\nWhen moving from one square to another, if there are at least 20 centimeters of water remaining on the current square when you start moving from it, it takes 1 second to complete the move (you can use your kayak). Otherwise, it takes 10 seconds (you have to drag your kayak). Note that the time depends only on the water level in the square you are leaving, not in the square you are entering.\n\nIt will be a while before the tide starts going out, and so you can spend as much time moving as you want before the water starts going down. What matters is how much time you will need from the moment the water starts going down until the moment you reach the exit. Can you calculate this time?\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1sc1nj3u.png)\n\n", "inputFormat": "* The first line will contain a single integer, $T$: the number of test cases\n* It is followed by $T$ test cases, each starting with a line containing integers $H$, $N$ and $M$, representing the initial water level height, in centimeters, and the map dimensions. The following $2N$ lines contain the ceiling and floor heights as follows:\n    * The next $N$ lines contain $M$ space-separated integers each. The $j$th integer in the $i$th row represents $C_{ij}$, the height of the ceiling in centimeters at grid location $(j, i)$, where increasing $i$ coordinates go South, and increasing $j$ coordinates go East.\n    * The next $N$ lines contain $M$ space-separated integers representing the heights of the floor, in the same format.\n* At the starting location, there will always be at least 50 cm of air between the ceiling and the starting water level, and at least 50 cm between the ceiling and the floor.\n* The exit location will always have at least 50 cm of air between the ceiling and the floor.\n* There will always be a way out (you got in, after all!).", "outputFormat": "For each test case, output one line containing \"Case #x: t\", where $x$ is the case number (starting from 1), and $t$ is the time, in seconds, starting from when the tide begins going out, that it takes you to make your way out of the cave system. Answers within an absolute or relative error of $10^{-6}$ of the correct answer will be accepted.\n\nIt is possible that you can go through the whole cave system before the tide starts dropping. In this case you will be able to wait at the exit for the tide to start dropping, so the answer in this case should be zero (this is the case in the fourth of the sample test cases).", "hint": "**Sample Explanation**\n\nIn the first sample test case, there are initially only 33 centimeters between the water level and the ceiling of the eastern square, so after the tide starts going down, you have to wait for at 1.7 seconds to enter it. Once it is accessible, you can start going in - but the water level in the western square is now so low (only 3 centimeters above the floor) that you have to drag your kayak for the next 10 seconds to get to the exit point.\n\nThe initial situation in the second case is better - you have a lot of headroom in adjacent squares, so you can move, for example, to $(1, 1)$ before the tide starts dropping. Once there, you have to wait for the tide to start going down, and the water level to go down to 90cm (that takes one second). Then you can kayak south and then east and get out (in a total of three seconds). Note that you cannot go through the cave at $(2, 1)$, even though the ceiling there is high enough, because there is too little space between the floor of this cave and the ceiling of any caves you could try to enter from ($(1, 1)$ and $(2, 0)$) - only 10 centimeters in each case.\n\nThe third case is somewhat similar to the first - you have to wait at the starting position until the tide goes down to 50cm. After that you can kayak for the exit - but after three moves (taking three seconds) the water is at 20cm, which is only 10cm above the floor, which means the fourth move will be dragging instead of kayaking.\n\nIn the fourth case you are really lucky! You can immediately go the exit, even before the tide starts leaving, and wait there.\n\n**Test set 1 (18 Pts, Visible Verdict)**\n\n- $1 \\leq T \\leq 50$.\n- $1 \\leq N, M \\leq 10$.\n- $1 \\leq H \\leq 1000$.\n- $1 \\leq F_{xy} \\leq C_{xy} \\leq 1000$.\n\n**Test set 2 (18 Pts, Hidden Verdict)**\n\n- $1 \\leq T \\leq 50$.\n- $1 \\leq N, M \\leq 100$.\n- $1 \\leq H \\leq 10000$.\n- $1 \\leq F_{xy} \\leq C_{xy} \\leq 10000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #1B] Tide Goes In, Tide Goes Out", "background": "", "description": "你正划着皮艇穿越一个地下洞穴系统，突然发现潮水正在上涨，你被困住了！幸运的是，你有这片洞穴系统的地图。在潮水开始退去之前，你都无法离开，所以你要在这里待上一段时间。在此期间，你希望能找出潮水开始退去时最快离开洞穴的路线。\n\n洞穴系统是一个 $N \\times M$ 的网格。你的地图包含两个 $N \\times M$ 的数字网格：一个指定每个格子的天花板高度，另一个指定每个格子的地板高度。洞穴的地板是多孔的，这意味着随着水位下降，水不会停留在水位线以上。\n\n你被困在地图的西北角。当前水位为 $H$ 厘米，一旦开始下降，将以每秒 $10$ 厘米的速度下降，直到降至 $0$。出口位于地图的东南角。现在出口处也被水覆盖，但只要潮水开始下降，它就能被通过。\n\n在任何时刻，你都可以向北、南、东或西移动到相邻的格子，前提是满足以下约束：\n\n* 当前水位、当前格子的地板高度、以及相邻格子的地板高度，三者都必须至少比相邻格子的天花板高度低 $50$ 厘米。注意：这意味着你永远无法进入一个地板与天花板间隙小于 $50$ 厘米的格子。\n* 相邻格子的地板高度也必须至少比当前格子的天花板高度低 $50$ 厘米。\n* 你永远不能移出地图边界。\n\n需要注意的是，你可以随意上下移动（你划皮艇很有运动天赋！）。例如，你可以从地板高度为 $10$ 厘米的格子移动到相邻的地板高度为 $9000$ 厘米的格子（只要满足上述约束）。\n\n这些约束如下图所示：\n\n* 第一幅图中，你无法向右移动，因为当前水位距离右侧格子的天花板不足 $50$ 厘米。\n* 第二幅图中，你无法向右移动，因为当前格子的地板距离右侧格子的天花板不足 $50$ 厘米。\n* 第三幅图中，你无法向右移动，因为右侧格子的地板距离其天花板不足 $50$ 厘米。你永远无法从任何方向进入该格子。\n* 第四幅图中，你无法向右移动，因为右侧格子的地板距离当前格子的天花板不足 $50$ 厘米。\n\n从一个格子移动到另一个格子时，如果你离开该格子时水面距离地板还有至少 $20$ 厘米，那么移动需要 $1$ 秒（你可以划皮艇）；否则需要 $10$ 秒（你得拖着皮艇走）。注意，所需时间只取决于你离开的格子的水位，而不是你要进入的格子的水位。\n\n在潮水开始退去之前，你可以在洞中随意移动时间，不计入答案。你需要计算的是，从潮水开始下降那一刻起，到你到达出口所需的最短时间。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1sc1nj3u.png)", "inputFormat": "* 第一行包含一个整数 $T$，表示测试用例数。\n* 接下来有 $T$ 个测试用例，每个测试用例以一行 $H$、$N$、$M$ 开头，分别表示初始水位（厘米）和地图的行列数。接下来的 $2N$ 行给出天花板和地板高度，具体如下：\n   * 接下来 $N$ 行，每行 $M$ 个空格分隔的整数，第 $i$ 行第 $j$ 个数为 $C_{ij}$，表示 $(j, i)$ 位置的天花板高度（厘米），$i$ 坐标向南递增，$j$ 坐标向东递增。\n   * 再接下来 $N$ 行，每行 $M$ 个空格分隔的整数，表示地板高度，格式同上。\n* 起点处天花板与初始水位之间至少有 $50$ 厘米空气，且天花板与地板之间至少有 $50$ 厘米空间。\n* 出口处天花板与地板之间至少有 $50$ 厘米空间。\n* 总是存在一条可通向出口的路径（毕竟你能进来！）。", "outputFormat": "对于每个测试用例，输出一行 \"Case #x: t\"，其中 $x$ 为测试用例编号（从 $1$ 开始），$t$ 为从潮水开始下降到你离开洞穴所需的时间（秒）。只要答案的绝对或相对误差不超过 $10^{-6}$，即视为正确。\n\n有可能你能在潮水下降前就到达出口。在这种情况下，你可以在出口处等潮水开始下降，因此答案应为 $0$（这正是样例的第四组数据）。\n", "hint": "**样例说明**\n\n在第一个样例中，最初东侧格子的天花板与水面仅有 $33$ 厘米距离，所以你必须等水位下降 $1.7$ 秒后才能进入。一旦可以进入，你就可以前进——但此时西侧格子的水面距离地板仅 $3$ 厘米，你必须拖着皮艇走 $10$ 秒才能到达出口。\n\n第二个样例起点条件更好——相邻格子有很大空间，因此你可以在潮水退去前移动到 $(1, 1)$。一旦在那里，你只需等潮水下降到 $90$ 厘米（需 $1$ 秒），然后向南再向东即可离开（共需 $3$ 秒）。注意你无法通过 $(2, 1)$，即使那里的天花板足够高，因为该格子的地板与任何相邻格子的天花板间隙都只有 $10$ 厘米。\n\n第三个样例与第一个类似——你必须在起点等到水位降到 $50$ 厘米，然后才能出发；但三步后水位降到 $20$ 厘米，只高出地板 $10$ 厘米，因此第四步需要拖皮艇走 $10$ 秒。\n\n第四个样例你非常幸运！你可以在潮水下降前就到达出口，在那里等待潮水下降。\n\n**测试集 1（18 分，结果可见）**\n\n- $1 \\leq T \\leq 50$\n- $1 \\leq N, M \\leq 10$\n- $1 \\leq H \\leq 1000$\n- $1 \\leq F_{xy} \\leq C_{xy} \\leq 1000$\n\n**测试集 2（18 分，结果隐藏）**\n\n- $1 \\leq T \\leq 50$\n- $1 \\leq N, M \\leq 100$\n- $1 \\leq H \\leq 10000$\n- $1 \\leq F_{xy} \\leq C_{xy} \\leq 10000$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13320", "type": "P", "difficulty": 6, "samples": [["2\n20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n20 120 266 858 1243 1657 1771 2328 2490 2665 2894 3117 4210 4454 4943 5690 6170 7048 7125 9512 9600", "Case #1: Possible\nCase #2: Possible"]], "limits": {"time": [12000, 30000], "memory": [1048576, 1048576]}, "tags": ["2012", "Special Judge", "鸽笼原理", "概率论", "Google Code Jam"], "title": "[GCJ 2012 #1B] Equal Sums", "background": "", "description": "I have a set of positive integers $\\mathbf{S}$. Can you find two non-empty, distinct subsets with the same sum?\n\nNote: A subset is a set that contains only elements from $\\mathbf{S}$, and two subsets are distinct if they do not have exactly the same elements.\n", "inputFormat": "he first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow, one per line. Each test case begins with $\\mathbf{N}$, the number of positive integers in $\\mathbf{S}$. It is followed by $\\mathbf{N}$ distinct positive integers, all on the same line.\n", "outputFormat": "For each test case, first output one line containing \"Case #x:\", where $\\mathbf{x}$ is the case number (starting from 1).\n\n* If there are two different subsets of $\\mathbf{S}$ that have the same sum, then output these subsets, one per line. Each line should contain the numbers in one subset, separated by spaces.\n* If it is impossible, then you should output the string \"Impossible\" on a single line.\n\nIf there are multiple ways of choosing two subsets with the same sum, any choice is acceptable.", "hint": "**Limits**\n\n- No two numbers in $\\mathbf{S}$ will be equal.\n- $1 \\leq \\mathbf{T} \\leq 10$.\n\n**Test set 1 (6 Pts, Visible Verdict)**\n\n- Time limit: ~~60~~ 12 seconds.\n- $\\mathbf{N}$ is exactly equal to $20$.\n- Each number in $\\mathbf{S}$ will be a positive integer less than $10^5$.\n\n**Test set 2 (37 Pts, Hidden Verdict)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $\\mathbf{N}$ is exactly equal to $500$.\n- Each number in $\\mathbf{S}$ will be a positive integer less than $10^{12}$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #1B] Equal Sums", "background": "", "description": "I have a set of positive integers $\\mathbf{S}$. Can you find two non-empty, distinct subsets with the same sum?\n\nNote: A subset is a set that contains only elements from $\\mathbf{S}$, and two subsets are distinct if they do not have exactly the same elements.\n", "inputFormat": "he first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow, one per line. Each test case begins with $\\mathbf{N}$, the number of positive integers in $\\mathbf{S}$. It is followed by $\\mathbf{N}$ distinct positive integers, all on the same line.\n", "outputFormat": "For each test case, first output one line containing \"Case #x:\", where $\\mathbf{x}$ is the case number (starting from 1).\n\n* If there are two different subsets of $\\mathbf{S}$ that have the same sum, then output these subsets, one per line. Each line should contain the numbers in one subset, separated by spaces.\n* If it is impossible, then you should output the string \"Impossible\" on a single line.\n\nIf there are multiple ways of choosing two subsets with the same sum, any choice is acceptable.", "hint": "**Limits**\n\n- No two numbers in $\\mathbf{S}$ will be equal.\n- $1 \\leq \\mathbf{T} \\leq 10$.\n\n**Test set 1 (6 Pts, Visible Verdict)**\n\n- Time limit: ~~60~~ 12 seconds.\n- $\\mathbf{N}$ is exactly equal to $20$.\n- Each number in $\\mathbf{S}$ will be a positive integer less than $10^5$.\n\n**Test set 2 (37 Pts, Hidden Verdict)**\n\n- Time limit: ~~120~~ 30 seconds.\n- $\\mathbf{N}$ is exactly equal to $500$.\n- Each number in $\\mathbf{S}$ will be a positive integer less than $10^{12}$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #1B] Equal Sums", "background": "", "description": "我有一个正整数集合 $\\mathbf{S}$。你能否找到两个非空且不同的子集，使它们的元素和相等？\n\n**注意**：子集是仅包含自 $\\mathbf{S}$ 的元素的集合；若两个子集包含的元素完全相同，则认为它们是相同的，否则为不同子集。\n", "inputFormat": "输入的第一行为测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据，每组一行。每组数据首先给出一个整数 $\\mathbf{N}$，表示集合 $\\mathbf{S}$ 中正整数的个数，随后是 $\\mathbf{N}$ 个互不相同的正整数，全部在同一行。\n", "outputFormat": "对于每个测试用例，首先输出一行 \"Case #x:\"，其中 $\\mathbf{x}$ 为测试用例编号（从 1 开始）。\n\n* 如果存在 $\\mathbf{S}$ 的两个不同子集，其元素和相等，则输出这两个子集，每行一个子集，子集内元素以空格分隔。\n* 如果不存在这样的子集，则输出一行 \"Impossible\"。\n\n如果存在多组答案，输出任意一组均可。注意原题样例没有输出方案。", "hint": "**限制条件**\n\n- $\\mathbf{S}$ 中不会有相同的数。\n- $1 \\leq \\mathbf{T} \\leq 10$。\n\n**测试集 1（6 分，结果可见）**\n\n- 时间限制：~~60~~ 12 秒。\n- $\\mathbf{N}$ 恰好等于 $20$。\n- $\\mathbf{S}$ 中每个数均为小于 $10^5$ 的正整数。\n\n**测试集 2（37 分，结果隐藏）**\n\n- 时间限制：~~120~~ 30 秒。\n- $\\mathbf{N}$ 恰好等于 $500$。\n- $\\mathbf{S}$ 中每个数均为小于 $10^{12}$ 的正整数。\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13321", "type": "P", "difficulty": 3, "samples": [["3\n3\n1 2\n1 3\n0\n5\n2 2 3\n1 4\n1 5\n1 5\n0\n3\n2 2 3\n1 3\n0", "Case #1: No\nCase #2: Yes\nCase #3: Yes"]], "limits": {"time": [4000, 4000], "memory": [1048576, 1048576]}, "tags": ["搜索", "2012", "深度优先搜索 DFS", "Google Code Jam"], "title": "[GCJ 2012 #1C] Diamond Inheritance", "background": "", "description": "You are asked to help diagnose class diagrams to identify instances of diamond inheritance. The following example class diagram illustrates the property of diamond inheritance. There are four classes: $A, B, C$ and $D$. An arrow pointing from $X$ to $Y$ indicates that class $X$ inherits from class $Y$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g3yse0or.png)\n\nIn this class diagram, $D$ inherits from both $B$ and $C$, $B$ inherits from $A$, and $C$ also inherits from $A$. An inheritance path from $X$ to $Y$ is defined as a sequence of classes $X$, $C_1$, $C_2$, $C_3$, $\\dots$, $C_n$, $Y$ where $X$ inherits from $C_1$, $C_i$ inherits from $C_{i+1}$ for $1 \\leq i \\leq n - 1$, and $C_n$ inherits from $Y$. There are two inheritance paths from $D$ to $A$ in the example above. The first path is $D$, $B$, $A$ and the second path is $D$, $C$, $A$.\n\nA class diagram is said to contain a diamond inheritance if there exists a pair of classes $X$ and $Y$ such that there are at least two different inheritance paths from $X$ to $Y$. The above class diagram is a classic example of diamond inheritance. Your task is to determine whether or not a given class diagram contains a diamond inheritance.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, each specifies a class diagram. The first line of each test case gives the number of classes in this diagram, $N$. The classes are numbered from $1$ to $N$. $N$ lines follow. The $i^{th}$ line starts with a non-negative integer $M_i$ indicating the number of classes that class $i$ inherits from. This is followed by $M_i$ distinct positive integers each from $1$ to $N$ representing those classes. You may assume that:\n\n* If there is an inheritance path from $X$ to $Y$ then there is no inheritance path from $Y$ to $X$.\n* A class will never inherit from itself.", "outputFormat": "For each diagram, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is \"Yes\" if the class diagram contains a diamond inheritance, \"No\" otherwise.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50$.\n- $0 \\leq M_i \\leq 10$.\n\n**Test set 1 (14 Pts, Visible Verdict)**\n\n- $1 \\leq N \\leq 50$.\n\n**Test set 2 (14 Pts, Hidden Verdict)**\n\n- $1 \\leq N \\leq 1,000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #1C] Diamond Inheritance", "background": "", "description": "You are asked to help diagnose class diagrams to identify instances of diamond inheritance. The following example class diagram illustrates the property of diamond inheritance. There are four classes: $A, B, C$ and $D$. An arrow pointing from $X$ to $Y$ indicates that class $X$ inherits from class $Y$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g3yse0or.png)\n\nIn this class diagram, $D$ inherits from both $B$ and $C$, $B$ inherits from $A$, and $C$ also inherits from $A$. An inheritance path from $X$ to $Y$ is defined as a sequence of classes $X$, $C_1$, $C_2$, $C_3$, $\\dots$, $C_n$, $Y$ where $X$ inherits from $C_1$, $C_i$ inherits from $C_{i+1}$ for $1 \\leq i \\leq n - 1$, and $C_n$ inherits from $Y$. There are two inheritance paths from $D$ to $A$ in the example above. The first path is $D$, $B$, $A$ and the second path is $D$, $C$, $A$.\n\nA class diagram is said to contain a diamond inheritance if there exists a pair of classes $X$ and $Y$ such that there are at least two different inheritance paths from $X$ to $Y$. The above class diagram is a classic example of diamond inheritance. Your task is to determine whether or not a given class diagram contains a diamond inheritance.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, each specifies a class diagram. The first line of each test case gives the number of classes in this diagram, $N$. The classes are numbered from $1$ to $N$. $N$ lines follow. The $i^{th}$ line starts with a non-negative integer $M_i$ indicating the number of classes that class $i$ inherits from. This is followed by $M_i$ distinct positive integers each from $1$ to $N$ representing those classes. You may assume that:\n\n* If there is an inheritance path from $X$ to $Y$ then there is no inheritance path from $Y$ to $X$.\n* A class will never inherit from itself.", "outputFormat": "For each diagram, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from $1$) and $y$ is \"Yes\" if the class diagram contains a diamond inheritance, \"No\" otherwise.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50$.\n- $0 \\leq M_i \\leq 10$.\n\n**Test set 1 (14 Pts, Visible Verdict)**\n\n- $1 \\leq N \\leq 50$.\n\n**Test set 2 (14 Pts, Hidden Verdict)**\n\n- $1 \\leq N \\leq 1,000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #1C] Diamond Inheritance", "background": "", "description": "你需要帮助诊断类图，以识别菱形继承的实例。下面的类图示例说明了菱形继承的特性。共有四个类：$A, B, C$ 和 $D$。箭头从 $X$ 指向 $Y$ 表示类 $X$ 继承自类 $Y$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g3yse0or.png)\n\n在这个类图中，$D$ 同时继承自 $B$ 和 $C$，$B$ 继承自 $A$，而 $C$ 也继承自 $A$。从 $X$ 到 $Y$ 的继承路径被定义为一个类序列 $X, C_1, C_2, C_3, \\dots, C_n, Y$，其中 $X$ 继承自 $C_1$，对于 $1 \\leq i \\leq n-1$，$C_i$ 继承自 $C_{i+1}$，$C_n$ 继承自 $Y$。在上面的例子中，从 $D$ 到 $A$ 存在两条继承路径。第一条路径为 $D, B, A$，第二条路径为 $D, C, A$。\n\n如果存在一对类 $X$ 和 $Y$，使得从 $X$ 到 $Y$ 存在至少两条不同的继承路径，则称该类图包含菱形继承。上面的类图就是菱形继承的经典示例。你的任务是判断给定的类图是否包含菱形继承。\n", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据，每组描述一个类图。每组数据的第一行为该类图的类数 $N$。类的编号为 $1$ 到 $N$。接下来有 $N$ 行。第 $i$ 行以一个非负整数 $M_i$ 开头，表示第 $i$ 个类继承的类的数量。随后是 $M_i$ 个不同的正整数，范围均为 $1$ 到 $N$，表示这些被继承的类。你可以假设：\n\n* 如果存在从 $X$ 到 $Y$ 的继承路径，则不存在从 $Y$ 到 $X$ 的继承路径。\n* 不会有类继承自身。", "outputFormat": "对于每个类图，输出一行 \"Case #$x$: $y$\"，其中 $x$ 为测试用例编号（从 $1$ 开始），$y$ 若该类图包含菱形继承则为 \"Yes\"，否则为 \"No\"。\n", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 50$\n- $0 \\leq M_i \\leq 10$\n\n**测试集 1（14 分，结果可见）**\n\n- $1 \\leq N \\leq 50$\n\n**测试集 2（14 分，结果隐藏）**\n\n- $1 \\leq N \\leq 1,000$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13322", "type": "P", "difficulty": 5, "samples": [["3\n1000.000000 2 3\n0.000000 20.500000\n25.000000 1000.000000\n1.00 5.00 9.81\n50.000000 2 2\n0.000000 0.000000\n100000.000000 100.000000\n1.00 1.01\n10000.000000 3 1\n0.000000 0.000000\n10000.000000 0.100000\n10000.100000 100000.000000\n1.00", "Case #1:\n44.7213595\n25.000000\n25.0\nCase #2:\n50000.0\n50000.0\nCase #3:\n10140.974143"]], "limits": {"time": [12000, 24000], "memory": [1048576, 1048576]}, "tags": ["数学", "2012", "二分", "Special Judge", "Google Code Jam"], "title": "[GCJ 2012 #1C] Out of Gas", "background": "", "description": "Your car is out of gas, and you want to get home as quickly as possible! Fortunately, your home is at the bottom of a hill and you (in your car) are at the top of it. Unfortunately, there is a car in front of you, and you can't move past it. Fortunately, your brakes are working and they are very powerful.\n\nYou start at the top of the hill with speed $0 \\, \\text{m/s}$ at time $0$ seconds. Gravity is pulling your car down the hill with a constant acceleration. At any time, you can use your brakes to reduce your speed, or temporarily reduce your acceleration, by any amount.\n\nHow quickly can you reach your home if you use your brakes in the best possible way?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. The first line of each test case contains three space-separated numbers: a real-valued number $D$, the distance in meters to your home down the hill; and two integers, $N$ and $A$. The distance $D$ will be given in exactly 6 decimal places.\n\n$N$ lines follow, each of which contains two space-separated, real-valued numbers: a time $t_i$ in seconds, and a position $x_i$ in meters. The $t_i$ and $x_i$ values will be given in exactly 6 decimal places.\n\nOne line follows, with $A$ space-separated, real-valued numbers $a_i$, which are accelerations in $\\text{m/s}^2$. The accelerations will be given in exactly 2 decimal places.\n\nThe other car's position is specified by the $(t_i, x_i)$ pairs. The car's position at time $t_i$ seconds is $x_i$ meters measured from the top of the hill (i.e. your initial position). The car travels at constant speed between time $t_i$ and $t_{i+1}$. The positions and times will both be given in increasing order, with $t_0=0$.\n\nFor example, if $t_5=10$, $x_5=20$, $t_6=20$, $x_6=40$, then 10 seconds after the start, the other car is 20 meters down the hill; 15 seconds after the start, the other car is 30 meters down the hill; and 20 seconds after the start, the other car is 40 meters down the hill.\n", "outputFormat": "For each test case, output one line containing \"Case #$c$:\", where $c$ is the case number (starting from 1). Then output $A$ lines, the $i^{\\text{th}}$ of which contains the minimum number of seconds it takes you to reach your home if your acceleration down the hill due to gravity is $a_i$, and you use your brakes in the best possible way. Answers within an absolute or relative error of $10^{-6}$ of the correct answer will be accepted. There should be no blank lines in the output.", "hint": "**Notes**\n\n**Position and Acceleration:** An object with a constant acceleration $a \\, \\text{m/s}^2$ and starting speed of $v_0 \\, \\text{m/s}$ will move a distance of $v_0 \\cdot t + 0.5 \\cdot a \\cdot t^2$ after $t$ seconds.\n\n**Distance on the slope:** All the distances and accelerations are given with respect to the straight line down the hill. They are not, for example, horizontal distances; so if your car is accelerating at $2 \\, \\text{m/s}^2$ with an initial speed of $0 \\, \\text{m/s}$, and the other car is stopped at $x=1$, it will take exactly 1 second to reach the other car.\n\n**The other car:** You may never pass the other car, which means that at no time shall your distance down the hill be greater than that of the other car. It may be equal. The cars should be considered as point masses.\n\n**Output values:** You can print as many decimal places as you like in the output. We will read and compare your answers with ours, and at that time we will be using $10^{-6}$ as a threshold for inaccuracy. So 25, 25.0 and 25.000000 are the same from our perspective. Trailing zeros after the decimal point does not matter.\n\n**Limits**\n\n- $1 \\leq T \\leq 20.$\n- $1.0 \\leq D \\leq 10^4.$\n- $1.0 \\leq a_i \\leq 9.81.$\n- $0.0 \\leq t_i \\leq 10^5.$\n- $0.0 \\leq x_i \\leq 10^5.$\n- $t_i < t_{i+1}.$\n- $x_i < x_{i+1}.$\n- $t_0 = 0$\n- $x_{N-1} \\geq D.$\n\n**Test set 1 (10 Pts, Visible Verdict)**\n\n- Time limit: ~~60~~ 12 seconds.\n- $1 \\leq N \\leq 2.$\n- $1 \\leq A \\leq 10.$\n\n**Test set 2 (27 Pts, Hidden Verdict)**\n\n- Time limit: ~~120~~ 24 seconds.\n- $1 \\leq N \\leq 2000.$\n- $1 \\leq A \\leq 250.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #1C] Out of Gas", "background": "", "description": "Your car is out of gas, and you want to get home as quickly as possible! Fortunately, your home is at the bottom of a hill and you (in your car) are at the top of it. Unfortunately, there is a car in front of you, and you can't move past it. Fortunately, your brakes are working and they are very powerful.\n\nYou start at the top of the hill with speed $0 \\, \\text{m/s}$ at time $0$ seconds. Gravity is pulling your car down the hill with a constant acceleration. At any time, you can use your brakes to reduce your speed, or temporarily reduce your acceleration, by any amount.\n\nHow quickly can you reach your home if you use your brakes in the best possible way?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. The first line of each test case contains three space-separated numbers: a real-valued number $D$, the distance in meters to your home down the hill; and two integers, $N$ and $A$. The distance $D$ will be given in exactly 6 decimal places.\n\n$N$ lines follow, each of which contains two space-separated, real-valued numbers: a time $t_i$ in seconds, and a position $x_i$ in meters. The $t_i$ and $x_i$ values will be given in exactly 6 decimal places.\n\nOne line follows, with $A$ space-separated, real-valued numbers $a_i$, which are accelerations in $\\text{m/s}^2$. The accelerations will be given in exactly 2 decimal places.\n\nThe other car's position is specified by the $(t_i, x_i)$ pairs. The car's position at time $t_i$ seconds is $x_i$ meters measured from the top of the hill (i.e. your initial position). The car travels at constant speed between time $t_i$ and $t_{i+1}$. The positions and times will both be given in increasing order, with $t_0=0$.\n\nFor example, if $t_5=10$, $x_5=20$, $t_6=20$, $x_6=40$, then 10 seconds after the start, the other car is 20 meters down the hill; 15 seconds after the start, the other car is 30 meters down the hill; and 20 seconds after the start, the other car is 40 meters down the hill.\n", "outputFormat": "For each test case, output one line containing \"Case #$c$:\", where $c$ is the case number (starting from 1). Then output $A$ lines, the $i^{\\text{th}}$ of which contains the minimum number of seconds it takes you to reach your home if your acceleration down the hill due to gravity is $a_i$, and you use your brakes in the best possible way. Answers within an absolute or relative error of $10^{-6}$ of the correct answer will be accepted. There should be no blank lines in the output.", "hint": "**Notes**\n\n**Position and Acceleration:** An object with a constant acceleration $a \\, \\text{m/s}^2$ and starting speed of $v_0 \\, \\text{m/s}$ will move a distance of $v_0 \\cdot t + 0.5 \\cdot a \\cdot t^2$ after $t$ seconds.\n\n**Distance on the slope:** All the distances and accelerations are given with respect to the straight line down the hill. They are not, for example, horizontal distances; so if your car is accelerating at $2 \\, \\text{m/s}^2$ with an initial speed of $0 \\, \\text{m/s}$, and the other car is stopped at $x=1$, it will take exactly 1 second to reach the other car.\n\n**The other car:** You may never pass the other car, which means that at no time shall your distance down the hill be greater than that of the other car. It may be equal. The cars should be considered as point masses.\n\n**Output values:** You can print as many decimal places as you like in the output. We will read and compare your answers with ours, and at that time we will be using $10^{-6}$ as a threshold for inaccuracy. So 25, 25.0 and 25.000000 are the same from our perspective. Trailing zeros after the decimal point does not matter.\n\n**Limits**\n\n- $1 \\leq T \\leq 20.$\n- $1.0 \\leq D \\leq 10^4.$\n- $1.0 \\leq a_i \\leq 9.81.$\n- $0.0 \\leq t_i \\leq 10^5.$\n- $0.0 \\leq x_i \\leq 10^5.$\n- $t_i < t_{i+1}.$\n- $x_i < x_{i+1}.$\n- $t_0 = 0$\n- $x_{N-1} \\geq D.$\n\n**Test set 1 (10 Pts, Visible Verdict)**\n\n- Time limit: ~~60~~ 12 seconds.\n- $1 \\leq N \\leq 2.$\n- $1 \\leq A \\leq 10.$\n\n**Test set 2 (27 Pts, Hidden Verdict)**\n\n- Time limit: ~~120~~ 24 seconds.\n- $1 \\leq N \\leq 2000.$\n- $1 \\leq A \\leq 250.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #1C] Out of Gas", "background": "", "description": "你的汽车没油了，你想尽快回家！幸运的是，你的家在山脚下，而你（和你的车）在山顶。不幸的是，你前面还有一辆车，你无法超过它。幸运的是，你的刹车很好用，而且非常强大。\n\n你从山顶以 $0\\,\\text{m/s}$ 的速度、在 $0$ 秒时刻出发。重力会以恒定加速度将你的车向山下拉。你可以随时使用刹车来减慢速度，或者临时减小加速度，幅度不限。\n\n如果你以最优方式使用刹车，你最快多久能到家？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行包含三个用空格分隔的数：一个实数 $D$，表示你到家的距离（米）；两个整数 $N$ 和 $A$。$D$ 保证有且仅有 $6$ 位小数。\n\n接下来 $N$ 行，每行包含两个用空格分隔的实数：第 $i$ 个为时间 $t_i$（秒），第 $i$ 个为位置 $x_i$（米）。$t_i$ 和 $x_i$ 都保证有且仅有 $6$ 位小数。\n\n再接下来一行，包含 $A$ 个用空格分隔的实数 $a_i$，表示加速度（$\\text{m/s}^2$），每个加速度保证有且仅有 $2$ 位小数。\n\n前车的位置由 $(t_i, x_i)$ 对给出。前车在 $t_i$ 秒时位于山顶下方 $x_i$ 米处（即你的起点）。前车在 $t_i$ 到 $t_{i+1}$ 之间以恒定速度行驶。所有 $t_i$ 和 $x_i$ 均严格递增，$t_0 = 0$。\n\n例如，如果 $t_5=10$，$x_5=20$，$t_6=20$，$x_6=40$，那么开始后 $10$ 秒前车在 $20$ 米处，$15$ 秒时在 $30$ 米处，$20$ 秒时在 $40$ 米处。\n", "outputFormat": "对于每个测试用例，输出一行 \"Case #$c$:\"，其中 $c$ 为测试用例编号（从 $1$ 开始）。然后输出 $A$ 行，第 $i$ 行为你在重力加速度为 $a_i$ 时，且以最优方式使用刹车，最快到家的秒数。答案的绝对或相对误差不超过 $10^{-6}$ 即视为正确。输出中不应有空行。\n", "hint": "**说明**\n\n**位置与加速度**：一个以恒定加速度 $a\\,\\text{m/s}^2$、初速度 $v_0\\,\\text{m/s}$ 的物体，在 $t$ 秒后将移动 $v_0 \\cdot t + 0.5 \\cdot a \\cdot t^2$ 米。\n\n**坡面距离**：所有距离和加速度均以山坡直线方向为准，不是水平距离。例如，你以 $2\\,\\text{m/s}^2$ 的加速度、初速度 $0\\,\\text{m/s}$，前车静止在 $x=1$，那么你正好 $1$ 秒能追到前车。\n\n**前车**：你永远不能超过前车，也就是说，任何时刻你的下坡距离都不能大于前车，可以相等。两车都视为质点。\n\n**输出数值**：你可以输出任意多的小数位。我们会用 $10^{-6}$ 作为误差阈值进行比较。因此 $25$、$25.0$、$25.000000$ 都被视为相同。小数点后的尾随 $0$ 不影响判分。\n\n**限制条件**\n\n- $1 \\leq T \\leq 20$\n- $1.0 \\leq D \\leq 10^4$\n- $1.0 \\leq a_i \\leq 9.81$\n- $0.0 \\leq t_i \\leq 10^5$\n- $0.0 \\leq x_i \\leq 10^5$\n- $t_i < t_{i+1}$\n- $x_i < x_{i+1}$\n- $t_0 = 0$\n- $x_{N-1} \\geq D$\n\n**测试集 1（10 分，结果可见）**\n\n- 时间限制：~~60~~ 12 秒\n- $1 \\leq N \\leq 2$\n- $1 \\leq A \\leq 10$\n\n**测试集 2（27 分，结果隐藏）**\n\n- 时间限制：~~120~~ 24 秒\n- $1 \\leq N \\leq 2000$\n- $1 \\leq A \\leq 250$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13323", "type": "P", "difficulty": 5, "samples": [["4\n3 3\n10 1 20 2 25 3\n10 2 30 3 20 1\n3 5\n10 1 6 2 10 1\n5 1 3 2 10 1 3 2 5 1\n3 5\n10 1 6 2 10 1\n5 1 6 2 10 1 6 2 5 1\n1 1\n5000000 10\n5000000 100", "Case #1: 35\nCase #2: 20\nCase #3: 21\nCase #4: 0"]], "limits": {"time": [3000, 3000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2012", "Google Code Jam"], "title": "[GCJ 2012 #1C] Box Factory", "background": "", "description": "You own a factory with two assembly lines. The first assembly line makes boxes, and the second assembly line makes toys to put in those boxes. Each type of box goes with one type of toy and vice-versa.\n\nAt the beginning, you pick up a box from the first assembly line and a toy from the second assembly line. You then have a few options.\n\n* You can always throw out the box and pick up the next one.\n* You can always throw out the toy and pick up the next one.\n* If the box and toy are the same type, you can put the toy in the box, and send it out to customers.\n\nYou always pick boxes up in the order in which they are made, and similarly for toys. You know the order in which boxes and toys are made, and you want to plan out a strategy that will allow you to send as many boxed toys as possible to customers.\n\nWarning: The two assembly lines make a lot of boxes and toys. However, they tend to make one kind of thing for a long period of time before switching.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow.\n\nEach test case begins with a line containing two integers $N$ and $M$. It is followed by a line containing $2 \\times N$ integers $a_1, A_1, a_2, A_2, ..., a_N, A_N$, and another line containing $2 \\times M$ integers $b_1, B_1, b_2, B_2, ..., b_M, B_M$.\n\nThis means that the first assembly line will make $a_1$ boxes of type $A_1$, then $a_2$ boxes of type $A_2$, etc., until it finishes with $a_N$ boxes of type $A_N$. Similarly, the second assembly will make $b_1$ toys of type $B_1$, followed by $b_2$ toys of type $B_2$, etc., until it finishes with $b_M$ toys of type $B_M$.\n\nA toy can be matched with a box if and only if they have the same type number.", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1), and $y$ is the largest number of boxed toys that you can send out to customers.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $1 \\leq a_i, b_i \\leq 10^{16}.$\n- $1 \\leq A_i, B_i \\leq 100.$\n\n**Test set 1 (12 Pts, Visible Verdict)**\n\n- $1 \\leq N \\leq 3.$\n- $1 \\leq M \\leq 100.$\n\n**Test set 2 (23 Pts, Hidden Verdict)**\n\n- $1 \\leq N, M \\leq 100.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #1C] Box Factory", "background": "", "description": "You own a factory with two assembly lines. The first assembly line makes boxes, and the second assembly line makes toys to put in those boxes. Each type of box goes with one type of toy and vice-versa.\n\nAt the beginning, you pick up a box from the first assembly line and a toy from the second assembly line. You then have a few options.\n\n* You can always throw out the box and pick up the next one.\n* You can always throw out the toy and pick up the next one.\n* If the box and toy are the same type, you can put the toy in the box, and send it out to customers.\n\nYou always pick boxes up in the order in which they are made, and similarly for toys. You know the order in which boxes and toys are made, and you want to plan out a strategy that will allow you to send as many boxed toys as possible to customers.\n\nWarning: The two assembly lines make a lot of boxes and toys. However, they tend to make one kind of thing for a long period of time before switching.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow.\n\nEach test case begins with a line containing two integers $N$ and $M$. It is followed by a line containing $2 \\times N$ integers $a_1, A_1, a_2, A_2, ..., a_N, A_N$, and another line containing $2 \\times M$ integers $b_1, B_1, b_2, B_2, ..., b_M, B_M$.\n\nThis means that the first assembly line will make $a_1$ boxes of type $A_1$, then $a_2$ boxes of type $A_2$, etc., until it finishes with $a_N$ boxes of type $A_N$. Similarly, the second assembly will make $b_1$ toys of type $B_1$, followed by $b_2$ toys of type $B_2$, etc., until it finishes with $b_M$ toys of type $B_M$.\n\nA toy can be matched with a box if and only if they have the same type number.", "outputFormat": "For each test case, output one line containing \"Case #x: y\", where $x$ is the case number (starting from 1), and $y$ is the largest number of boxed toys that you can send out to customers.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $1 \\leq a_i, b_i \\leq 10^{16}.$\n- $1 \\leq A_i, B_i \\leq 100.$\n\n**Test set 1 (12 Pts, Visible Verdict)**\n\n- $1 \\leq N \\leq 3.$\n- $1 \\leq M \\leq 100.$\n\n**Test set 2 (23 Pts, Hidden Verdict)**\n\n- $1 \\leq N, M \\leq 100.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #1C] Box Factory", "background": "", "description": "你拥有一家拥有两条装配线的工厂。第一条装配线生产盒子，第二条装配线生产可以放入这些盒子的玩具。每种类型的盒子只对应一种类型的玩具，反之亦然。\n\n一开始，你会从第一条装配线上取一个盒子，从第二条装配线上取一个玩具。此时你有如下几种选择：\n\n* 你可以随时丢弃盒子，取下一个盒子。\n* 你可以随时丢弃玩具，取下一个玩具。\n* 如果盒子和玩具是同一种类型，你可以将玩具放入盒子，并将其发给客户。\n\n你总是按照生产顺序依次取盒子和玩具。你已知盒子和玩具的生产顺序，并希望制定一种策略，使得你发出的装盒玩具数量尽可能多。\n\n**注意**：两条装配线会生产大量盒子和玩具，但它们通常会长时间连续生产同一种类型后才切换。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。\n\n每组测试数据第一行为两个整数 $N$ 和 $M$。接下来一行为 $2 \\times N$ 个整数 $a_1, A_1, a_2, A_2, \\dots, a_N, A_N$，再接下来一行为 $2 \\times M$ 个整数 $b_1, B_1, b_2, B_2, \\dots, b_M, B_M$。\n\n这表示第一条装配线会先生产 $a_1$ 个类型为 $A_1$ 的盒子，然后生产 $a_2$ 个类型为 $A_2$ 的盒子，依此类推，直到最后生产 $a_N$ 个类型为 $A_N$ 的盒子。第二条装配线同理，先生产 $b_1$ 个类型为 $B_1$ 的玩具，接着 $b_2$ 个类型为 $B_2$ 的玩具，依此类推，直到最后生产 $b_M$ 个类型为 $B_M$ 的玩具。\n\n只有当盒子和玩具类型编号相同时，二者才能配对。", "outputFormat": "对于每个测试用例，输出一行 \"Case #x: y\"，其中 $x$ 为测试用例编号（从 $1$ 开始），$y$ 为你最多能发出的装盒玩具数量。\n", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 100$\n- $1 \\leq a_i, b_i \\leq 10^{16}$\n- $1 \\leq A_i, B_i \\leq 100$\n\n**测试集 1（12 分，结果可见）**\n\n- $1 \\leq N \\leq 3$\n- $1 \\leq M \\leq 100$\n\n**测试集 2（23 分，结果隐藏）**\n\n- $1 \\leq N, M \\leq 100$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13324", "type": "P", "difficulty": 4, "samples": [["4\n3\n3 4\n4 10\n6 10\n9\n3\n3 4\n4 10\n7 10\n9\n2\n6 6\n10 3\n13\n2\n6 6\n10 3\n14", "Case #1: YES\nCase #2: NO\nCase #3: YES\nCase #4: NO"]], "limits": {"time": [4000, 4000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2012", "Google Code Jam"], "title": "[GCJ 2012 #2] Swinging Wild", "background": "", "description": "You are standing on a ledge in the jungle, and your one true love is standing on a similar ledge at the other side of a swamp infested with snakes, crocodiles and a variety of other unpleasant denizens. Fortunately, there is a number of vines hanging from the canopy of the jungle over the swamp, even more fortunately, you somehow managed to get hold of the first of these vines (see figures below). The canopy of the jungle is at a constant height, and both the ledges are at the same height as the canopy. The vines are simply lines hanging from the canopy at certain points, with differing lengths.\n\nIf you happened to be a fictional hero, you would just go swinging wildly and yelling, at some point let go of the vine you hold, fly in the air for some time, catch another vine, swing again, and after a few repetitions you would be holding your one true love in your arms. Unfortunately, you are not a fictional hero, and if you tried that, probably yelling would be the only part you would manage well.\n\nYour plan is a bit more cautious. You will swing on the vine you hold, but instead of letting go, you will catch hold of another vine. Then you will slowly and carefully climb up your original vine, so that the new vine you are holding will become horizontal - either to its full length, or up to the distance between the two vines, whichever is smaller. Then you will rest for a bit, and swing again, to repeat the process. Note that you do not have to catch the first vine you come up against while swinging, you might prefer to swing a bit further and catch some further-off vine instead. You can also climb up the vine you're currently swinging back and forth on to reduce the distance between you and the root of the vine. In effect, this means that you can catch any vine that your vine crosses while swinging. Note that you will not climb down a vine while swinging.\n\nOne other thing that sets you apart from any fictional hero is that before you start the whole rather risky procedure you would like to know whether it is actually possible to reach the other side of the jungle this way. And this is the question you have to answer in this problem.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. The first line of each test case contains the number $N$ of vines. $N$ lines describing the vines follow, each with a pair of integers $d_i$ and $l_i$ - the distance of the vine from your ledge, and the length of the vine, respectively. The last line of the test case contains the distance $D$ to the ledge with your one true love. You start by holding the first vine in hand.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is a YES or a NO. Indicating whether it is possible for you to reach your one true love, given the rules above.", "hint": "**Sample Explantion**\n\nIn the first case, you hold the first vine 3 units away from where it is attached. You swing wildly, bypass the second vine and just barely catch the third. The picture below depicts the starting situation, and you are able to reach any vine that is rooted anywhere within the red interval:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2v8e9qcl.png)\n\nAfter resting, you climb down the third one and up the first, to find yourself three units from the start, touching the canopy and holding the first and third vines. Now you let go of the first vine, swing again and again just barely reach the ledge, where your one true love awaits. The picture below depicts the situation after you caught the third vine and climbed over to the root of the first one. Again, you could reach any vine rooted within the red interval:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rk4gi3a8.png)\n\nIn the second case, you will not reach the third vine in the first swing, so your only choice is to catch the second. However, as it is attached four units from the start, you can (by going up the first vine) give yourself only one unit of swing - clearly too little to reach the third vine. Thus, you can't even reach the third vine, not to mention the other side of the swamp. Better go looking for some way around (or for a new true love).\n\nIn the third case, note that if you just swing on the first vine you hold, your path will not intersect the second vine - you have to climb up a bit while swinging (fortunately, you can) to reach the second vine. Remember, you can only climb up while swinging, you cannot climb down (because the vine going up is taut and you can put your weight on it, while the vine going down is swinging freely). In the fourth case, even though you can reach the second vine, it is too short to reach the final ledge.\n\n**Limits**\n\n- $0 < \\mathbf{d}_i, \\mathbf{l}_i, \\mathbf{D} \\leq 10^9$.\n- $\\mathbf{T} \\leq 30$.\n- $\\mathbf{d}_i < \\mathbf{d}_{i+1}$.\n- As you hold the first vine, $\\mathbf{d}_0 \\leq \\mathbf{l}_0$.\n- $\\mathbf{d}_{\\mathbf{N}-1} < \\mathbf{D}$.\n\n**Test set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 100$.\n\n**Test set 2 (9 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10000$.\n- There will be at most 60000 vines in all the test cases in total.", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #2] Swinging Wild", "background": "", "description": "You are standing on a ledge in the jungle, and your one true love is standing on a similar ledge at the other side of a swamp infested with snakes, crocodiles and a variety of other unpleasant denizens. Fortunately, there is a number of vines hanging from the canopy of the jungle over the swamp, even more fortunately, you somehow managed to get hold of the first of these vines (see figures below). The canopy of the jungle is at a constant height, and both the ledges are at the same height as the canopy. The vines are simply lines hanging from the canopy at certain points, with differing lengths.\n\nIf you happened to be a fictional hero, you would just go swinging wildly and yelling, at some point let go of the vine you hold, fly in the air for some time, catch another vine, swing again, and after a few repetitions you would be holding your one true love in your arms. Unfortunately, you are not a fictional hero, and if you tried that, probably yelling would be the only part you would manage well.\n\nYour plan is a bit more cautious. You will swing on the vine you hold, but instead of letting go, you will catch hold of another vine. Then you will slowly and carefully climb up your original vine, so that the new vine you are holding will become horizontal - either to its full length, or up to the distance between the two vines, whichever is smaller. Then you will rest for a bit, and swing again, to repeat the process. Note that you do not have to catch the first vine you come up against while swinging, you might prefer to swing a bit further and catch some further-off vine instead. You can also climb up the vine you're currently swinging back and forth on to reduce the distance between you and the root of the vine. In effect, this means that you can catch any vine that your vine crosses while swinging. Note that you will not climb down a vine while swinging.\n\nOne other thing that sets you apart from any fictional hero is that before you start the whole rather risky procedure you would like to know whether it is actually possible to reach the other side of the jungle this way. And this is the question you have to answer in this problem.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. The first line of each test case contains the number $N$ of vines. $N$ lines describing the vines follow, each with a pair of integers $d_i$ and $l_i$ - the distance of the vine from your ledge, and the length of the vine, respectively. The last line of the test case contains the distance $D$ to the ledge with your one true love. You start by holding the first vine in hand.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is a YES or a NO. Indicating whether it is possible for you to reach your one true love, given the rules above.", "hint": "**Sample Explantion**\n\nIn the first case, you hold the first vine 3 units away from where it is attached. You swing wildly, bypass the second vine and just barely catch the third. The picture below depicts the starting situation, and you are able to reach any vine that is rooted anywhere within the red interval:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2v8e9qcl.png)\n\nAfter resting, you climb down the third one and up the first, to find yourself three units from the start, touching the canopy and holding the first and third vines. Now you let go of the first vine, swing again and again just barely reach the ledge, where your one true love awaits. The picture below depicts the situation after you caught the third vine and climbed over to the root of the first one. Again, you could reach any vine rooted within the red interval:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rk4gi3a8.png)\n\nIn the second case, you will not reach the third vine in the first swing, so your only choice is to catch the second. However, as it is attached four units from the start, you can (by going up the first vine) give yourself only one unit of swing - clearly too little to reach the third vine. Thus, you can't even reach the third vine, not to mention the other side of the swamp. Better go looking for some way around (or for a new true love).\n\nIn the third case, note that if you just swing on the first vine you hold, your path will not intersect the second vine - you have to climb up a bit while swinging (fortunately, you can) to reach the second vine. Remember, you can only climb up while swinging, you cannot climb down (because the vine going up is taut and you can put your weight on it, while the vine going down is swinging freely). In the fourth case, even though you can reach the second vine, it is too short to reach the final ledge.\n\n**Limits**\n\n- $0 < \\mathbf{d}_i, \\mathbf{l}_i, \\mathbf{D} \\leq 10^9$.\n- $\\mathbf{T} \\leq 30$.\n- $\\mathbf{d}_i < \\mathbf{d}_{i+1}$.\n- As you hold the first vine, $\\mathbf{d}_0 \\leq \\mathbf{l}_0$.\n- $\\mathbf{d}_{\\mathbf{N}-1} < \\mathbf{D}$.\n\n**Test set 1 (5 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 100$.\n\n**Test set 2 (9 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10000$.\n- There will be at most 60000 vines in all the test cases in total.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #2] Swinging Wild", "background": "", "description": "你正站在丛林中的一个岩架上，你的真爱正站在沼泽对岸的另一个相似的岩架上。沼泽中满是蛇、鳄鱼和各种令人不快的生物。幸运的是，丛林树冠上方悬挂着许多藤蔓，更幸运的是，你设法抓住了这些藤蔓中的第一根（见下图）。树冠高度恒定，两个岩架的高度也与树冠一致。藤蔓仅仅是从树冠某些点垂下来的线段，长度各不相同。\n\n如果你是小说中的英雄，你会疯狂地荡着藤蔓大喊大叫，在某个时刻松手飞跃空中，抓住另一根藤蔓，再次荡起，如此反复，最终你会把你的真爱拥入怀中。不幸的是，你并不是小说英雄，如果你尝试这么做，可能唯一能做好的只有大喊大叫。\n\n你的计划要谨慎得多。你会先在手中的藤蔓上荡起来，但不是松手，而是去抓住另一根藤蔓。然后你会慢慢小心地爬上原来的藤蔓，使你手中抓住的新藤蔓变成水平状态——要么拉到它的全部长度，要么拉到两根藤蔓之间的距离，以较小者为准。然后你会休息片刻，再次荡起来，如此反复。注意，你并不一定要抓住荡到的第一根藤蔓，你可以选择荡得更远，抓住更远的藤蔓。同样，你可以在荡动时爬上当前的藤蔓，以缩短你与藤蔓根部的距离。实际上，这意味着你可以抓住任何在你荡动时经过的藤蔓。注意，荡动时你不会向下爬藤蔓。\n\n还有一点你与小说英雄不同，那就是在开始这场相当冒险的行动前，你想知道按照上述规则，你是否真的有可能到达对岸。这正是本题要你回答的问题。\n", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据的第一行为藤蔓数量 $N$。接下来 $N$ 行，每行两个整数 $d_i$ 和 $l_i$，分别表示第 $i$ 根藤蔓距离你所在岩架的距离，以及该藤蔓的长度。每组测试数据最后一行为你到真爱所在岩架的距离 $D$。你一开始手里抓着第一根藤蔓。\n", "outputFormat": "对于每个测试用例，输出一行 \"Case #$x$: $y$\"，其中 $x$ 为测试用例编号（从 $1$ 开始），$y$ 为 \"YES\" 或 \"NO\"，表示你是否有可能按照上述规则到达你的真爱身边。\n", "hint": "**样例说明**\n\n在第一个样例中，你手中的第一根藤蔓距离其挂点有 3 个单位长度。你可以大幅荡动，越过第二根藤蔓，刚好抓住第三根。下图展示了初始状态，你能够到达任何根部在红色区间内的藤蔓：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2v8e9qcl.png)\n\n休息后，你顺着第三根往下爬，顺着第一根往上爬，发现自己距离起点 3 个单位长度，正好碰到树冠并抓住第一和第三根藤蔓。现在你松开第一根，再次荡动，又刚好到达终点岩架，你的真爱在那等你。下图展示了你抓住第三根并爬到第一根根部后的状态。你同样可以到达任何红色区间内的藤蔓：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rk4gi3a8.png)\n\n在第二个样例中，你第一次荡动无法到达第三根藤蔓，所以只能抓住第二根。然而，第二根距起点 4 个单位长度，即使你顺着第一根往上爬，也只能荡 1 个单位长度——显然不足以到达第三根藤蔓。因此你连第三根都到不了，更别说对岸了。你还是去找别的路（或新的真爱）吧。\n\n在第三个样例中，注意如果你只在第一根藤蔓上荡动，是无法碰到第二根的——你必须在荡动时爬上一些（幸运的是，你可以这么做）才能抓住第二根。记住，你只能在荡动时向上爬，不能向下（因为向上藤蔓是拉紧的可以承重，向下则是自由荡动的）。第四个样例中，即使你能到第二根藤蔓，但它太短，无法到达终点岩架。\n\n**限制条件**\n\n- $0 < d_i, l_i, D \\leq 10^9$\n- $T \\leq 30$\n- $d_i < d_{i+1}$\n- 起始时你抓住第一根藤蔓，$d_0 \\leq l_0$\n- $d_{N-1} < D$\n\n**测试集 1（5 分，结果可见）**\n\n- $1 \\leq N \\leq 100$\n\n**测试集 2（9 分，结果隐藏）**\n\n- $1 \\leq N \\leq 10000$\n- 所有测试用例的藤蔓总数不超过 60000\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13325", "type": "P", "difficulty": 4, "samples": [["2\n2 6 6\n1 1\n3 320 2\n4 3 2", "Case #1: 0.0 0.0 6.0 6.0\nCase #2: 0.0 0.0 7.0 0.0 12.0 0.0"]], "limits": {"time": [4000, 4000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2012", "Special Judge", "随机化", "Google Code Jam"], "title": "[GCJ 2012 #2] Aerobics", "background": "", "description": "The aerobics class begins. The trainer says, \"Please position yourselves on the training mat so that each one of you has enough space to move your arms around freely, and not hit anybody else.\" People start milling around on the mat, trying to position themselves properly. Minutes pass, and finally the trainer is so annoyed that he asks you to write a program that will position all the people correctly, hoping it will be quicker than letting them figure it out for themselves!\n\nYou are given the dimensions (width and length) of the mat on which the class takes place. For every student, there is a circular area she has to have for herself, with radius equal to the reach of her arms. These circles can not intersect, though they can touch; and the center of each circle (where the student stands) has to be on the mat. Note that the arms **can** reach outside the mat. You know that there's plenty of space on the mat — the area of the mat is at least five times larger than the total area of the circles required by all the people in the class. It will always be possible for all the people to position themselves as required.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line contains three integers: $\\mathbf{N}$, $\\mathbf{W}$ and $\\mathbf{L}$, denoting the number of students, the width of the mat, and the length of the mat, respectively. The second line contains $\\mathbf{N}$ integers $\\mathbf{r}_i$, denoting the reach of the arms of the $i^{th}$ student.\n", "outputFormat": "For each test case, output one line containing \"Case #$n$: $y$\", where $n$ is the case number (starting from 1) and $y$ is a string containing $2\\mathbf{N}$ numbers, each of which can be an integer or a real number: $\\mathbf{x}_1$, $\\mathbf{y}_1$, $\\mathbf{x}_2$, $\\mathbf{y}_2$, etc., where the pair $(\\mathbf{x}_i, \\mathbf{y}_i)$ is the position where the $i^{th}$ student should stand (with $0 \\leq \\mathbf{x}_i \\leq \\mathbf{W}$ and $0 \\leq \\mathbf{y}_i \\leq \\mathbf{L}$).\n\nAs there will likely be multiple ways to position the students on the mat, you may output any correct positioning; but remember that you may not submit an output file more than 200kB in size.", "hint": "**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 50$.\n- $1 \\leq \\mathbf{W}, \\mathbf{L} \\leq 10^9$.\n- $1 \\leq \\mathbf{r}_i \\leq 10^5$.\n- The area of the mat is at least 5 times larger than the total area of the circles:\n- $5 \\times \\pi \\times (\\mathbf{r}_1^2 + \\ldots + \\mathbf{r}_\\mathbf{N}^2) \\leq \\mathbf{W} \\times \\mathbf{L}$.\n\n**Test set 1 (6 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10$.\n\n**Test set 2 (15 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10^3$.\n- The total number of circles in all test cases will be $\\leq 6000$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #2] Aerobics", "background": "", "description": "The aerobics class begins. The trainer says, \"Please position yourselves on the training mat so that each one of you has enough space to move your arms around freely, and not hit anybody else.\" People start milling around on the mat, trying to position themselves properly. Minutes pass, and finally the trainer is so annoyed that he asks you to write a program that will position all the people correctly, hoping it will be quicker than letting them figure it out for themselves!\n\nYou are given the dimensions (width and length) of the mat on which the class takes place. For every student, there is a circular area she has to have for herself, with radius equal to the reach of her arms. These circles can not intersect, though they can touch; and the center of each circle (where the student stands) has to be on the mat. Note that the arms **can** reach outside the mat. You know that there's plenty of space on the mat — the area of the mat is at least five times larger than the total area of the circles required by all the people in the class. It will always be possible for all the people to position themselves as required.", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line contains three integers: $\\mathbf{N}$, $\\mathbf{W}$ and $\\mathbf{L}$, denoting the number of students, the width of the mat, and the length of the mat, respectively. The second line contains $\\mathbf{N}$ integers $\\mathbf{r}_i$, denoting the reach of the arms of the $i^{th}$ student.\n", "outputFormat": "For each test case, output one line containing \"Case #$n$: $y$\", where $n$ is the case number (starting from 1) and $y$ is a string containing $2\\mathbf{N}$ numbers, each of which can be an integer or a real number: $\\mathbf{x}_1$, $\\mathbf{y}_1$, $\\mathbf{x}_2$, $\\mathbf{y}_2$, etc., where the pair $(\\mathbf{x}_i, \\mathbf{y}_i)$ is the position where the $i^{th}$ student should stand (with $0 \\leq \\mathbf{x}_i \\leq \\mathbf{W}$ and $0 \\leq \\mathbf{y}_i \\leq \\mathbf{L}$).\n\nAs there will likely be multiple ways to position the students on the mat, you may output any correct positioning; but remember that you may not submit an output file more than 200kB in size.", "hint": "**Limits**\n\n- $1 \\leq \\mathbf{T} \\leq 50$.\n- $1 \\leq \\mathbf{W}, \\mathbf{L} \\leq 10^9$.\n- $1 \\leq \\mathbf{r}_i \\leq 10^5$.\n- The area of the mat is at least 5 times larger than the total area of the circles:\n- $5 \\times \\pi \\times (\\mathbf{r}_1^2 + \\ldots + \\mathbf{r}_\\mathbf{N}^2) \\leq \\mathbf{W} \\times \\mathbf{L}$.\n\n**Test set 1 (6 Pts, Visible Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10$.\n\n**Test set 2 (15 Pts, Hidden Verdict)**\n\n- $1 \\leq \\mathbf{N} \\leq 10^3$.\n- The total number of circles in all test cases will be $\\leq 6000$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #2] Aerobics", "background": "", "description": "有氧操课程开始了。教练说：“请大家在训练垫上站好，保证每个人都有足够的空间能自由挥动手臂，而且不会碰到其他人。”大家开始在垫子上走动，试图找到合适的位置。时间一分一秒过去，最终教练非常恼火，要求你写一个程序来给所有人安排正确的位置，希望这样比让他们自己慢慢挪要快！\n\n你会得到课程所用垫子的尺寸（宽度和长度）。对于每位学员，都有一个属于她自己的圆形区域，半径等于她手臂的可达范围。这些圆不能相交，但可以相切；每个圆的圆心（即学员所站的位置）必须在垫子上。注意，手臂可以伸出垫子之外。你知道垫子的空间非常充足——垫子的面积至少是所有圆面积总和的五倍。所有学员都能按要求站下这一点始终成立。", "inputFormat": "输入的第一行为测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据。每组测试数据包含两行。第一行三个整数：$\\mathbf{N}$、$\\mathbf{W}$ 和 $\\mathbf{L}$，分别表示学员人数、垫子的宽度和长度。第二行包含 $\\mathbf{N}$ 个整数 $\\mathbf{r}_i$，表示第 $i$ 位学员的手臂可达半径。\n", "outputFormat": "对于每个测试用例，输出一行 \"Case #$n$: $y$\"，其中 $n$ 为测试用例编号（从 1 开始），$y$ 是一个包含 $2\\mathbf{N}$ 个数字的字符串，每个数字可以是整数或实数：$\\mathbf{x}_1$、$\\mathbf{y}_1$、$\\mathbf{x}_2$、$\\mathbf{y}_2$，依此类推，其中 $(\\mathbf{x}_i, \\mathbf{y}_i)$ 表示第 $i$ 位学员应站的位置（$0 \\leq \\mathbf{x}_i \\leq \\mathbf{W}$ 且 $0 \\leq \\mathbf{y}_i \\leq \\mathbf{L}$）。\n\n由于学员在垫子上的站位方案可能有多种，你可以输出任意一个合法方案；但请注意，提交的输出文件不得超过 200kB。\n", "hint": "**限制条件**\n\n- $1 \\leq \\mathbf{T} \\leq 50$\n- $1 \\leq \\mathbf{W}, \\mathbf{L} \\leq 10^9$\n- $1 \\leq \\mathbf{r}_i \\leq 10^5$\n- 垫子的面积至少是所有圆面积总和的 5 倍：\n- $5 \\times \\pi \\times (\\mathbf{r}_1^2 + \\ldots + \\mathbf{r}_\\mathbf{N}^2) \\leq \\mathbf{W} \\times \\mathbf{L}$\n\n**测试集 1（6 分，结果可见）**\n\n- $1 \\leq \\mathbf{N} \\leq 10$\n\n**测试集 2（15 分，结果隐藏）**\n\n- $1 \\leq \\mathbf{N} \\leq 10^3$\n- 所有测试用例的圆总数不超过 6000\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13326", "type": "P", "difficulty": 5, "samples": [["4\n6\n2 3 4 5 6\n4\n4 4 4\n4\n3 4 4\n4\n4 3 4", "Case #1: 10 10 10 10 10 2\nCase #2: 10 20 40 80\nCase #3: Impossible\nCase #4: 5 3 6 8"]], "limits": {"time": [4000, 4000], "memory": [1048576, 1048576]}, "tags": ["贪心", "2012", "Special Judge", "构造", "Google Code Jam"], "title": "[GCJ 2012 #2] Mountain View", "background": "", "description": "You are walking through the mountains. It turns out that in this mountain range there is a peak every kilometer, and there are no intermediate peaks. On every peak, you lie down for a rest, look forward, and perceive one of the peaks in front of you to be the highest one. The peak that looks like it's the highest might not really be the highest, for two reasons: there could be a higher peak that is obscured by another peak that's closer to you, and not as high; or you could be looking down, and a faraway peak could look higher than a nearby one.\n\nTo be precise, when we say that peak $B$ looks like it's the highest from peak $A$ we mean that $B$ is further down the road than $A$; all peaks between $A$ and $B$ are below the line connecting the peaks $A$ and $B$; and all the peaks that are further than $B$ are below or on this line.\n\nYou don't know how high each peak is, but you have a very good memory; you've been on all the peaks; and you remember which peak looks like it's the highest from each of them. You would like to invent a set of heights for the peaks that is consistent with that information. Note that you were lying down when looking, so we assume you always looked from the ground level on each peak.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/umylxqho.png)\n\nIn this example, the fourth peak looks like it's the highest from the first and third peaks. When you're lying on the second peak, you can't see the fourth peak; the third one obscures it, and looks like it's the highest.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of two lines. The first contains one number, $N$, the number of peaks in the range. You began your trip on peak $1$ and went forward to peak $N$. The next line contains $N-1$ numbers $x_i$. The $i$-th number denotes the index of the peak that appeared to be the highest from peak $i$ (note that peak $N$ is the last peak, so there are no other peaks to see from there).\n", "outputFormat": "For each test case, output one line containing \"Case #$n$: $y_1$ $y_2$ ... $y_N$\", where $n$ is the case number (starting from $1$) and $y_i$ is the height of the $i$-th peak. You can output any solution agreeing with the input data, except that all the heights you output have to be integers between $0$ and $10^9$, inclusive.\n\nIf no solution is possible, output \"Case #$n$: Impossible\" instead.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 30.$\n- $i < x_i \\leq N.$\n\n**Test set 1 (13 Pts, Visible Verdict)**\n\n- $2 \\leq N \\leq 10.$\n\n**Test set 2 (14 Pts, Hidden Verdict)**\n\n- $2 \\leq N \\leq 2000.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #2] Mountain View", "background": "", "description": "You are walking through the mountains. It turns out that in this mountain range there is a peak every kilometer, and there are no intermediate peaks. On every peak, you lie down for a rest, look forward, and perceive one of the peaks in front of you to be the highest one. The peak that looks like it's the highest might not really be the highest, for two reasons: there could be a higher peak that is obscured by another peak that's closer to you, and not as high; or you could be looking down, and a faraway peak could look higher than a nearby one.\n\nTo be precise, when we say that peak $B$ looks like it's the highest from peak $A$ we mean that $B$ is further down the road than $A$; all peaks between $A$ and $B$ are below the line connecting the peaks $A$ and $B$; and all the peaks that are further than $B$ are below or on this line.\n\nYou don't know how high each peak is, but you have a very good memory; you've been on all the peaks; and you remember which peak looks like it's the highest from each of them. You would like to invent a set of heights for the peaks that is consistent with that information. Note that you were lying down when looking, so we assume you always looked from the ground level on each peak.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/umylxqho.png)\n\nIn this example, the fourth peak looks like it's the highest from the first and third peaks. When you're lying on the second peak, you can't see the fourth peak; the third one obscures it, and looks like it's the highest.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of two lines. The first contains one number, $N$, the number of peaks in the range. You began your trip on peak $1$ and went forward to peak $N$. The next line contains $N-1$ numbers $x_i$. The $i$-th number denotes the index of the peak that appeared to be the highest from peak $i$ (note that peak $N$ is the last peak, so there are no other peaks to see from there).\n", "outputFormat": "For each test case, output one line containing \"Case #$n$: $y_1$ $y_2$ ... $y_N$\", where $n$ is the case number (starting from $1$) and $y_i$ is the height of the $i$-th peak. You can output any solution agreeing with the input data, except that all the heights you output have to be integers between $0$ and $10^9$, inclusive.\n\nIf no solution is possible, output \"Case #$n$: Impossible\" instead.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 30.$\n- $i < x_i \\leq N.$\n\n**Test set 1 (13 Pts, Visible Verdict)**\n\n- $2 \\leq N \\leq 10.$\n\n**Test set 2 (14 Pts, Hidden Verdict)**\n\n- $2 \\leq N \\leq 2000.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #2] Mountain View", "background": null, "description": "你正在山脉中行走。在这片山脉中，每隔一公里就有一座山峰，且中间没有其他山峰。在每一座山峰上，你都会躺下来休息，向前眺望，并会觉得前方某一座山峰是最高的。实际上，看起来最高的山峰未必真的最高，原因有两个：可能有一座更高的山峰被离你更近但较矮的山峰挡住了；或者你是在俯视，远处的山峰看起来比附近的更高。\n\n更准确地说，当我们说从山峰 $A$ 看过去，山峰 $B$ 看起来最高，意思是：$B$ 比 $A$ 更靠前；$A$ 和 $B$ 之间的所有山峰都在连接 $A$ 和 $B$ 的直线下方；$B$ 之后的所有山峰都在该直线下方或正好在直线上。\n\n你并不知道每座山峰的具体高度，但你记忆力极佳——你去过所有山峰，并且记得每座山峰上看起来最高的是哪一座。你希望构造一组山峰的高度，使其与这些观测信息一致。注意你是躺着看的，所以我们假设你总是从每座山峰的地面水平观测。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/umylxqho.png)\n\n在这个例子中，从第一座和第三座山峰看，第四座山峰看起来最高。当你躺在第二座山峰时，看不到第四座，因为第三座挡住了视线，所以第三座看起来最高。", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据，每组两行。第一行为一个整数 $N$，表示山峰数量。你从第 $1$ 座山峰出发，依次前进到第 $N$ 座。下一行有 $N-1$ 个整数 $x_i$，第 $i$ 个数表示从第 $i$ 座山峰看起来最高的是第 $x_i$ 座山峰（注意第 $N$ 座山峰是最后一座，从那里看不到别的山峰）。", "outputFormat": "对于每个测试用例，输出一行 \"Case #$n$: $y_1$ $y_2$ $\\dots$ $y_N$\"，其中 $n$ 为测试用例编号（从 $1$ 开始），$y_i$ 表示第 $i$ 座山峰的高度。你可以输出任意一组与输入观测信息一致的解，但所有高度必须是 $0$ 到 $10^9$ 之间的整数。\n\n如果不存在满足条件的解，则输出 \"Case #$n$: Impossible\"。", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 30$\n- $i < x_i \\leq N$\n\n**测试集 1（13 分，结果可见）**\n\n- $2 \\leq N \\leq 10$\n\n**测试集 2（14 分，结果隐藏）**\n\n- $2 \\leq N \\leq 2000$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13327", "type": "P", "difficulty": 7, "samples": [["2\n7 5\n#####\n##0##\n##1.#\n##2##\n#3..#\n#.#.#\n#####\n7 6\n######\n##...#\n#..#.#\n#...##\n#0#..#\n####1#\n######", "Case #1:\n0: 1 Lucky\n1: 3 Lucky\n2: 4 Unlucky\n3: 7 Lucky\nCase #2:\n0: 9 Lucky\n1: 11 Unlucky"]], "limits": {"time": [4000, 4000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "2012", "状压 DP", "Google Code Jam"], "title": "[GCJ 2012 #2] Descending in the Dark", "background": "", "description": "You are on the face of Mount Everest. You need to find shelter before you freeze, and it's dark! What do you do?\n\nThe good news is you have already memorized the layout of the mountain. It is a grid with certain squares impassable and other squares containing caves where you can rest for the night. The bad news is you don't know where you are, and it's too steep to climb up. All you can do is move left, right, or down.\n\nHere is an example layout, with '.' representing a passable square, '#' representing an impassable square, and numbers representing caves.\n\n```\n######\n##...#\n#..#.#\n#...##\n#0#..#\n####1#\n######\n```\n\nSince it is so dark, you will move around by following a *plan*, which is a series of instructions, each telling you to move one square left, right, or down. If an instruction would take you to a passable square or to a cave, you will follow it. If it would take you to an impassable square, you will have to ignore it. Either way, you will continue on to the next step, and so on, until you have gone through the whole plan.\n\nTo help with your descent, you want to find out two things for each cave $\\mathbf{C}$:\n\n* What squares is it possible to reach $\\mathbf{C}$ from? We will label the set of these squares by $\\mathbf{S}_{\\mathbf{C}}$, and the number of them by $\\mathbf{n}_{\\mathbf{C}}$.\n* Is there a single plan that, if followed from any square in $\\mathbf{S}_{\\mathbf{C}}$, will finish with you at cave $\\mathbf{C}$? If so, we say the cave is *lucky*.\n\nNote that you might pass by several caves while following a plan. All that matters is what square you *finish* on after executing all the steps, not what caves you visit along the way.\n\nFor example, in the layout above, cave 0 is lucky. There are 9 squares that it can be reached from (including itself), and the plan \"left-left-down-down-down-left-down\" will finish with you at the cave from any of those squares.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow, beginning with a line containing integers $\\mathbf{R}$ and $\\mathbf{C}$, representing the number of rows and columns in the mountain layout.\n\nThis is followed by $\\mathbf{R}$ lines, each containing $\\mathbf{C}$ characters, describing a mountain layout. As in the example above, a '#' character represents an impassable square, a '.' character represents a passable square, and the digits '0'-'9' represent caves (which are also passable squares).\n", "outputFormat": "For each test case, first output one line containing \"Case #$x$:\", where $x$ is the case number (starting from 1). For each cave $\\mathbf{C}$, starting with 0 and counting up from there, write a line \"$\\mathbf{C}$: $\\mathbf{n}_{\\mathbf{C}}$ $\\mathbf{L}_{\\mathbf{C}}$\". Here, $\\mathbf{C}$ is the cave number, $\\mathbf{n}_{\\mathbf{C}}$ is the number of squares you can reach the cave from, and $\\mathbf{L}_{\\mathbf{C}}$ is either the string \"Lucky\" or the string \"Unlucky\", as defined above.", "hint": "**Sample Explanation**\n\nIn the first case, here are some valid plans you could use for the lucky caves:\n- For cave 0, you can use the empty plan. If you can reach the cave at all, you are already in the right place!\n- For cave 1, you can use the plan right-down-left.\n- For cave 3, you can use the plan right-right-left-down-down-down-left.\n\n**Limits**\n\n- There will be between 1 and 10 caves inclusive.\n- If there are $d$ caves, they will be labeled with the digits $\\{0, 1, \\ldots, d - 1\\}$, and no two caves will have the same label.\n- All squares on the boundary of the mountain layout will be impassable.\n- $1 \\leq T \\leq 20.$\n\n**Test set 1 (8 Pts, Visible Verdict)**\n\n- $3 \\leq R, C \\leq 10.$\n\n**Test set 2 (30 Pts, Hidden Verdict)**\n\n- $3 \\leq R, C \\leq 60.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #2] Descending in the Dark", "background": "", "description": "You are on the face of Mount Everest. You need to find shelter before you freeze, and it's dark! What do you do?\n\nThe good news is you have already memorized the layout of the mountain. It is a grid with certain squares impassable and other squares containing caves where you can rest for the night. The bad news is you don't know where you are, and it's too steep to climb up. All you can do is move left, right, or down.\n\nHere is an example layout, with '.' representing a passable square, '#' representing an impassable square, and numbers representing caves.\n\n```\n######\n##...#\n#..#.#\n#...##\n#0#..#\n####1#\n######\n```\n\nSince it is so dark, you will move around by following a *plan*, which is a series of instructions, each telling you to move one square left, right, or down. If an instruction would take you to a passable square or to a cave, you will follow it. If it would take you to an impassable square, you will have to ignore it. Either way, you will continue on to the next step, and so on, until you have gone through the whole plan.\n\nTo help with your descent, you want to find out two things for each cave $\\mathbf{C}$:\n\n* What squares is it possible to reach $\\mathbf{C}$ from? We will label the set of these squares by $\\mathbf{S}_{\\mathbf{C}}$, and the number of them by $\\mathbf{n}_{\\mathbf{C}}$.\n* Is there a single plan that, if followed from any square in $\\mathbf{S}_{\\mathbf{C}}$, will finish with you at cave $\\mathbf{C}$? If so, we say the cave is *lucky*.\n\nNote that you might pass by several caves while following a plan. All that matters is what square you *finish* on after executing all the steps, not what caves you visit along the way.\n\nFor example, in the layout above, cave 0 is lucky. There are 9 squares that it can be reached from (including itself), and the plan \"left-left-down-down-down-left-down\" will finish with you at the cave from any of those squares.\n", "inputFormat": "The first line of the input gives the number of test cases, $\\mathbf{T}$. $\\mathbf{T}$ test cases follow, beginning with a line containing integers $\\mathbf{R}$ and $\\mathbf{C}$, representing the number of rows and columns in the mountain layout.\n\nThis is followed by $\\mathbf{R}$ lines, each containing $\\mathbf{C}$ characters, describing a mountain layout. As in the example above, a '#' character represents an impassable square, a '.' character represents a passable square, and the digits '0'-'9' represent caves (which are also passable squares).\n", "outputFormat": "For each test case, first output one line containing \"Case #$x$:\", where $x$ is the case number (starting from 1). For each cave $\\mathbf{C}$, starting with 0 and counting up from there, write a line \"$\\mathbf{C}$: $\\mathbf{n}_{\\mathbf{C}}$ $\\mathbf{L}_{\\mathbf{C}}$\". Here, $\\mathbf{C}$ is the cave number, $\\mathbf{n}_{\\mathbf{C}}$ is the number of squares you can reach the cave from, and $\\mathbf{L}_{\\mathbf{C}}$ is either the string \"Lucky\" or the string \"Unlucky\", as defined above.", "hint": "**Sample Explanation**\n\nIn the first case, here are some valid plans you could use for the lucky caves:\n- For cave 0, you can use the empty plan. If you can reach the cave at all, you are already in the right place!\n- For cave 1, you can use the plan right-down-left.\n- For cave 3, you can use the plan right-right-left-down-down-down-left.\n\n**Limits**\n\n- There will be between 1 and 10 caves inclusive.\n- If there are $d$ caves, they will be labeled with the digits $\\{0, 1, \\ldots, d - 1\\}$, and no two caves will have the same label.\n- All squares on the boundary of the mountain layout will be impassable.\n- $1 \\leq T \\leq 20.$\n\n**Test set 1 (8 Pts, Visible Verdict)**\n\n- $3 \\leq R, C \\leq 10.$\n\n**Test set 2 (30 Pts, Hidden Verdict)**\n\n- $3 \\leq R, C \\leq 60.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #2] Descending in the Dark", "background": "", "description": "你正站在珠穆朗玛峰的山坡上。你需要在冻僵之前找到一个避难所，而现在天已经黑了！你该怎么办？\n\n好消息是，你已经记住了整座山的布局。这是一张网格图，其中有些格子无法通过，另一些格子包含可以过夜的山洞。坏消息是，你并不知道自己所在的位置，并且由于坡度太陡，你无法往上爬。你只能向左、右或向下移动。\n\n下面是一个布局示例，'.' 表示可通行的格子，'#' 表示不可通行的格子，数字表示山洞：\n\n```\n######\n##...#\n#..#.#\n#...##\n#0#..#\n####1#\n######\n```\n\n由于天太黑了，你只能按照一个*计划*行动，这是一串指令，每条指令都让你向左、右或下移动一格。如果某条指令会让你走到一个可通行的格子或山洞，你就执行它。如果会走到一个不可通行的格子，你就必须忽略这条指令。不论是否执行，你都会继续下一步，直到计划全部执行完毕。\n\n为了帮助你下山，你希望对每个山洞 $\\mathbf{C}$ 得到两个信息：\n\n* 可以从哪些格子到达山洞 $\\mathbf{C}$？我们用 $\\mathbf{S}_{\\mathbf{C}}$ 表示这些格子的集合，$\\mathbf{n}_{\\mathbf{C}}$ 表示这些格子的数量。\n* 是否存在一个计划，使得从 $\\mathbf{S}_{\\mathbf{C}}$ 的任意一个格子出发，最终都能到达山洞 $\\mathbf{C}$？如果存在，我们称该山洞是**Lucky** 的。\n\n注意，在按计划行动的过程中，你可能会经过多个山洞。唯一重要的是你最终**停留**在哪个格子，而不是途中经过了哪些山洞。\n\n例如，在上面的布局中，山洞 0 是 Lucky 的。有 9 个格子可以到达它（包括它本身），计划 \"left-left-down-down-down-left-down\" 能保证从这些格子的任意一个出发，最终都停在该山洞。\n", "inputFormat": "输入的第一行为测试用例数 $\\mathbf{T}$。接下来有 $\\mathbf{T}$ 组测试数据，每组首先一行两个整数 $\\mathbf{R}$ 和 $\\mathbf{C}$，表示山的行数和列数。\n\n接下来有 $\\mathbf{R}$ 行，每行 $\\mathbf{C}$ 个字符，描述山的布局。与上例一样，'#' 表示不可通行的格子，'.' 表示可通行的格子，'0'-'9' 表示山洞（也是可通行的格子）。", "outputFormat": "对于每个测试用例，首先输出一行 \"Case #$x$:\"，其中 $x$ 为测试用例编号（从 1 开始）。对于每个山洞 $\\mathbf{C}$（从 0 开始递增），输出一行 \"$\\mathbf{C}$: $\\mathbf{n}_{\\mathbf{C}}$ $\\mathbf{L}_{\\mathbf{C}}$\"。其中 $\\mathbf{C}$ 是山洞编号，$\\mathbf{n}_{\\mathbf{C}}$ 是能到达该山洞的格子数，$\\mathbf{L}_{\\mathbf{C}}$ 为 \"Lucky\" 或 \"Unlucky\"，如上所述。\n", "hint": "**样例说明**\n\n在第一个样例中，下面是一些对 Lucky 山洞可用的计划：\n- 对于山洞 0，可以使用空计划。如果你能到达该山洞，说明你已经在正确的位置！\n- 对于山洞 1，可以使用计划 right-down-left。\n- 对于山洞 3，可以使用计划 right-right-left-down-down-down-left。\n\n**限制条件**\n\n- 山洞数量在 1 到 10 之间。\n- 若有 $d$ 个山洞，则编号为 $\\{0, 1, \\ldots, d-1\\}$，且不会有重复编号。\n- 山的布局边界上的所有格子都是不可通行的。\n- $1 \\leq T \\leq 20$\n\n**测试集 1（8 分，结果可见）**\n\n- $3 \\leq R, C \\leq 10$\n\n**测试集 2（30 分，结果隐藏）**\n\n- $3 \\leq R, C \\leq 60$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13328", "type": "P", "difficulty": 5, "samples": [["3\n4\n1 1 1 1\n50 0 20 20\n3\n100 10 1\n0 50 0\n3\n100 80 50\n40 20 80", "Case #1: 0 2 3 1\nCase #2: 1 0 2\nCase #3: 2 0 1"]], "limits": {"time": [2000, 2000], "memory": [1048576, 1048576]}, "tags": ["数学", "贪心", "2012", "期望", "Google Code Jam"], "title": "[GCJ 2012 #3] Perfect Game", "background": "", "description": "You're playing a video game, in which you will get an achievement if you complete all of the levels consecutively without dying. You can play the levels in any order, and each time you play a level you'll either complete it or die. Each level has some probability that you'll complete it, and takes some amount of time. In what order should you play the levels so that the expected time it takes you to get the achievement is minimized? Assume that it takes equally long to beat a level or to die in it, and that you will start again from the first level in your ordering as soon as you die.\n\nNote: If you fail to complete a level, you do not personally die—only your character in the game dies. If that were not the case, only a few people would try to earn this achievement.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, each of which consists of three lines. The first line of each test case contains a single integer $N$, the number of levels. The second line contains $N$ space-separated integers $L_i$. $L_i$ is the number of seconds level $i$ lasts, which is independent of whether you complete the level or die. The third line contains $N$ space-separated integers $P_i$. $P_i$ is the percent chance that you will die in any given attempt to complete level $i$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: \", where $x$ is the case number (starting from 1), followed by $N$ space-separated integers. The $j^{th}$ integer in the list should be the index of the $j^{th}$ level you should attempt to beat in order to minimize the amount of time you expect to spend earning the achievement.\n\nIndices go from 0 to $N-1$. If there are multiple orderings that would give the same expected time, output the lexicographically least ordering. Out of two orderings, the lexicographically smaller one is the one with the smaller index at the first location where they differ; out of many orderings, the lexicographically least one is the one that is lexicographically smaller than every other ordering.", "hint": "**Sample Explanation**\n\nNote that the second and third samples do not satisfy the constraints for the small input.\n\n**Limits**\n\n$1 \\leq T \\leq 100$.\n\n$0 \\leq P_i < 100$.\n\n**Test set 1 (3 Pts, Visible Verdict)**\n\n- $1 \\leq N \\leq 20$.\n- $L_i = 1$.\n\n**Test set 2 (7 Pts, Hidden Verdict)**\n\n- $1 \\leq N \\leq 1000$.\n- $1 \\leq L_i \\leq 100$.", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #3] Perfect Game", "background": "", "description": "You're playing a video game, in which you will get an achievement if you complete all of the levels consecutively without dying. You can play the levels in any order, and each time you play a level you'll either complete it or die. Each level has some probability that you'll complete it, and takes some amount of time. In what order should you play the levels so that the expected time it takes you to get the achievement is minimized? Assume that it takes equally long to beat a level or to die in it, and that you will start again from the first level in your ordering as soon as you die.\n\nNote: If you fail to complete a level, you do not personally die—only your character in the game dies. If that were not the case, only a few people would try to earn this achievement.\n", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow, each of which consists of three lines. The first line of each test case contains a single integer $N$, the number of levels. The second line contains $N$ space-separated integers $L_i$. $L_i$ is the number of seconds level $i$ lasts, which is independent of whether you complete the level or die. The third line contains $N$ space-separated integers $P_i$. $P_i$ is the percent chance that you will die in any given attempt to complete level $i$.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: \", where $x$ is the case number (starting from 1), followed by $N$ space-separated integers. The $j^{th}$ integer in the list should be the index of the $j^{th}$ level you should attempt to beat in order to minimize the amount of time you expect to spend earning the achievement.\n\nIndices go from 0 to $N-1$. If there are multiple orderings that would give the same expected time, output the lexicographically least ordering. Out of two orderings, the lexicographically smaller one is the one with the smaller index at the first location where they differ; out of many orderings, the lexicographically least one is the one that is lexicographically smaller than every other ordering.", "hint": "**Sample Explanation**\n\nNote that the second and third samples do not satisfy the constraints for the small input.\n\n**Limits**\n\n$1 \\leq T \\leq 100$.\n\n$0 \\leq P_i < 100$.\n\n**Test set 1 (3 Pts, Visible Verdict)**\n\n- $1 \\leq N \\leq 20$.\n- $L_i = 1$.\n\n**Test set 2 (7 Pts, Hidden Verdict)**\n\n- $1 \\leq N \\leq 1000$.\n- $1 \\leq L_i \\leq 100$.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #3] Perfect Game", "background": "", "description": "你正在玩一款电子游戏，如果能够连续通关所有关卡且中途没有死亡，你将获得一个成就。你可以以任意顺序游玩各个关卡，每次游玩某一关时，你要么通关，要么死亡。每一关都有一定的通关概率，并且每一关都需要一定的时间。不论你通关还是死亡，所用时间都相同。你应该以怎样的顺序游玩关卡，才能使获得成就所需的期望时间最小？假设每当你死亡后，会立刻从你设定的顺序的第一关重新开始。\n\n**注意**：如果你未能通关某一关，你本人并不会真的死亡——只是游戏角色死亡而已。如果不是这样，恐怕只有极少数人会尝试获得这个成就。\n", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据，每组测试数据包含三行。第一行为一个整数 $N$，表示关卡数量。第二行为 $N$ 个以空格分隔的整数 $L_i$，表示第 $i$ 关所需的秒数，无论通关还是死亡用时相同。第三行为 $N$ 个以空格分隔的整数 $P_i$，表示你每次尝试第 $i$ 关时死亡的概率（百分数）。\n", "outputFormat": "对于每个测试用例，输出一行 \"Case #$x$: \"，其中 $x$ 是测试用例编号（从 1 开始），后接 $N$ 个以空格分隔的整数。第 $j$ 个整数表示你应该第 $j$ 个挑战的关卡编号，以最小化获得成就所需的期望时间。\n\n编号从 $0$ 到 $N-1$。若有多种顺序能获得相同的期望时间，请输出字典序最小的那一个。对于两个顺序，字典序较小的是在第一个不同位置上编号较小的那个；对于多个顺序，字典序最小的是在所有顺序中字典序最小的那个。\n", "hint": "**样例说明**\n\n请注意，第二组和第三组样例并不满足小数据的约束条件。\n\n**限制条件**\n\n$1 \\leq T \\leq 100$。\n\n$0 \\leq P_i < 100$。\n\n**测试集 1（3 分，结果可见）**\n\n- $1 \\leq N \\leq 20$。\n- $L_i = 1$。\n\n**测试集 2（7 分，结果隐藏）**\n\n- $1 \\leq N \\leq 1000$。\n- $1 \\leq L_i \\leq 100$。\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13329", "type": "P", "difficulty": 6, "samples": [["7\n2 4\n1 1\n1 2\n2 3\n3 3\n3 6\n2 1\n2 2\n2 3\n2 4\n1 2\n4 4\n3 7\n3 3\n2 2\n2 3\n3 4\n4 4\n4 3\n3 2\n3 6\n2 2\n2 3\n3 4\n4 4\n4 3\n3 2\n3 8\n1 1\n2 1\n1 3\n2 4\n1 2\n3 2\n3 3\n3 4\n3 7\n1 1\n2 2\n3 5\n3 4\n5 3\n4 3\n3 3\n3 3\n1 1\n1 3\n3 5", "Case #1: bridge in move 2\nCase #2: fork in move 5\nCase #3: none\nCase #4: ring in move 6\nCase #5: bridge-fork in move 5\nCase #6: bridge in move 7\nCase #7: none"]], "limits": {"time": [3000, 6000], "memory": [1048576, 1048576]}, "tags": ["2012", "二分", "并查集", "Google Code Jam"], "title": "[GCJ 2012 #3] Havannah", "background": "Havannah was created by Christian Freeling and MindSports. MindSports and Christian Freeling do not endorse and have no involvement with Google Code Jam.", "description": "Havannah is an abstract strategy board game created by Christian Freeling. Havannah is a game played on a hexagonal board with $S$ hexagons to each side. Each hexagon has two horizontal and four slanted edges. The hexagons are identified by pairs of integer values. The hexagon in the bottom corner of the board is $(1, 1)$. The hexagon adjacent to $(x, y)$ in the direction of a two-o'clock hand is $(x, y+1)$. The hexagon adjacent to $(x, y)$ in the direction of a ten-o'clock hand is $(x + 1, y)$. Here is an example board with $S = 5$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oegdj7r3.png)\n\nIn the game of Havannah, each hexagon can be occupied by at most one stone. Stones once put on the board are never removed or moved. The goal of the game is to build from stones a connected set of stones of one of three kinds. The winning structures are:\n\n- A **ring** that encircles one or more empty hexagons. That is, at least one of the inner hexagons must be empty. More specifically, there is an empty hexagon that is separated from the outermost boundary of the board by hexagons with stones. Note that this rule is different from the official game Havannah.\n- A **bridge** that connects any two corners of the board.\n- A fork that connects any three of the board's six edges. Corners do not count as part of either adjacent edge.\n\nThis picture shows examples of winning structures:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iar2seqk.png)\n\nYour program should determine whether a sequence of moves of a single player builds a winning structure. If so, it should output the name of the structure and the number of the move that completed it. If a move completes multiple rings, connects more than two corners, or connects more than three edges, the structure is still considered a ring, a bridge, or a fork, respectively. But if a move completes structures of different kinds at once, your program should output the names of all of them. We are only interested in the first winning move: ignore all moves following the winning one. If there is no winning structure on the board after playing all the moves from the sequence, your program should output none.", "inputFormat": "The first line of input gives the number of test cases, $T$. $T$ test cases follow. The first line of each test case contains two integers $S$ and $M$, the number of hexagons on each side of the board and the number of moves in the sequence, respectively. The next $M$ lines provide the sequence of moves, in order, where each line contains a space-separated pair $(x, y)$ of hexagon identifiers. All the moves in the sequence lie on the board of size $S$. In each test case, the board is initially empty and the moves do not repeat.", "outputFormat": "For each test case, output one line containing \"Case #$n$: \" followed by one of:\n\n* none\n* bridge in move $k$\n* fork in move $k$\n* ring in move $k$\n* bridge-fork in move $k$\n* bridge-ring in move $k$\n* fork-ring in move $k$\n* bridge-fork-ring in move $k$\n\nThe cases are numbered starting from 1. The moves are numbered starting from 1.", "hint": "**Limits**\n\n**Test set 1 (8 Pts, Visible Verdict)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq T \\leq 200$\n- $2 \\leq S \\leq 50$\n- $0 \\leq M \\leq 100$\n\n**Test set 2 (12 Pts, Hidden Verdict)**\n\n- Time limit: ~~60~~ 6 seconds.\n- $1 \\leq T \\leq 20$\n- $2 \\leq S \\leq 3000$\n- $0 \\leq M \\leq 10000$", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #3] Havannah", "background": "Havannah was created by Christian Freeling and MindSports. MindSports and Christian Freeling do not endorse and have no involvement with Google Code Jam.", "description": "Havannah is an abstract strategy board game created by Christian Freeling. Havannah is a game played on a hexagonal board with $S$ hexagons to each side. Each hexagon has two horizontal and four slanted edges. The hexagons are identified by pairs of integer values. The hexagon in the bottom corner of the board is $(1, 1)$. The hexagon adjacent to $(x, y)$ in the direction of a two-o'clock hand is $(x, y+1)$. The hexagon adjacent to $(x, y)$ in the direction of a ten-o'clock hand is $(x + 1, y)$. Here is an example board with $S = 5$:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oegdj7r3.png)\n\nIn the game of Havannah, each hexagon can be occupied by at most one stone. Stones once put on the board are never removed or moved. The goal of the game is to build from stones a connected set of stones of one of three kinds. The winning structures are:\n\n- A **ring** that encircles one or more empty hexagons. That is, at least one of the inner hexagons must be empty. More specifically, there is an empty hexagon that is separated from the outermost boundary of the board by hexagons with stones. Note that this rule is different from the official game Havannah.\n- A **bridge** that connects any two corners of the board.\n- A fork that connects any three of the board's six edges. Corners do not count as part of either adjacent edge.\n\nThis picture shows examples of winning structures:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iar2seqk.png)\n\nYour program should determine whether a sequence of moves of a single player builds a winning structure. If so, it should output the name of the structure and the number of the move that completed it. If a move completes multiple rings, connects more than two corners, or connects more than three edges, the structure is still considered a ring, a bridge, or a fork, respectively. But if a move completes structures of different kinds at once, your program should output the names of all of them. We are only interested in the first winning move: ignore all moves following the winning one. If there is no winning structure on the board after playing all the moves from the sequence, your program should output none.", "inputFormat": "The first line of input gives the number of test cases, $T$. $T$ test cases follow. The first line of each test case contains two integers $S$ and $M$, the number of hexagons on each side of the board and the number of moves in the sequence, respectively. The next $M$ lines provide the sequence of moves, in order, where each line contains a space-separated pair $(x, y)$ of hexagon identifiers. All the moves in the sequence lie on the board of size $S$. In each test case, the board is initially empty and the moves do not repeat.", "outputFormat": "For each test case, output one line containing \"Case #$n$: \" followed by one of:\n\n* none\n* bridge in move $k$\n* fork in move $k$\n* ring in move $k$\n* bridge-fork in move $k$\n* bridge-ring in move $k$\n* fork-ring in move $k$\n* bridge-fork-ring in move $k$\n\nThe cases are numbered starting from 1. The moves are numbered starting from 1.", "hint": "**Limits**\n\n**Test set 1 (8 Pts, Visible Verdict)**\n\n- Time limit: ~~30~~ 3 seconds.\n- $1 \\leq T \\leq 200$\n- $2 \\leq S \\leq 50$\n- $0 \\leq M \\leq 100$\n\n**Test set 2 (12 Pts, Hidden Verdict)**\n\n- Time limit: ~~60~~ 6 seconds.\n- $1 \\leq T \\leq 20$\n- $2 \\leq S \\leq 3000$\n- $0 \\leq M \\leq 10000$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #3] Havannah", "background": "Havannah 由 Christian Freeling 和 MindSports 创作。MindSports 和 Christian Freeling 并未参与，也未给 Google Code Jam 背书。\n", "description": "Havannah 是一款由 Christian Freeling 创作的抽象策略棋类游戏。Havannah 在一个六边形棋盘上进行，棋盘每边有 $S$ 个六边形格子。每个六边形格子有两条水平边和四条斜边。每个六边形用一对整数标识。棋盘左下角的格子为 $(1, 1)$。与 $(x, y)$ 相邻、指向两点钟方向的格子是 $(x, y+1)$，指向十点钟方向的相邻格子是 $(x+1, y)$。下图是 $S=5$ 时的棋盘示例：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oegdj7r3.png)\n\n在 Havannah 游戏中，每个格子最多只能被一个棋子占据。棋子一旦落下，不会被移走或移动。游戏目标是用棋子构成以下三种连通结构之一。获胜结构包括：\n\n- **环（ring）**：形成一个包围了一个或多个空格的环。即，至少有一个内部格子是空的。更具体地说，存在一个空格，它被棋子包围，与棋盘的外边界隔开。注意，这条规则与官方 Havannah 游戏不同。\n- **桥（bridge）**：连接棋盘上任意两个角的结构。\n- **叉（fork）**：连接棋盘六条边中任意三条的结构。角不算作任何一条边的一部分。\n\n下图展示了获胜结构的例子：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/iar2seqk.png)\n\n你的程序需要判断，单一玩家的一系列落子是否形成了获胜结构。如果形成，则输出结构名称及完成该结构的步数。如果某一步同时完成了多个环、连接了多于两个角，或连接了多于三条边，依然只算作“环”、“桥”或“叉”。但如果某一步同时完成了不同类型的结构，你需要输出所有结构的名称。我们只关心首次形成获胜结构的那一步：之后的落子全部忽略。如果全部落子后棋盘上没有任何获胜结构，则输出 none。\n", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组第一行为两个整数 $S$ 和 $M$，分别表示棋盘每边六边形的数量和落子数。接下来 $M$ 行，每行一个用空格分隔的二元组 $(x, y)$，表示落子的位置。所有落子都在 $S$ 阶棋盘范围内，且无重复。本组测试数据的棋盘初始为空。\n", "outputFormat": "对于每个测试用例，输出一行 \"Case #$n$: \"，后接如下之一：\n\n* none\n* bridge in move $k$\n* fork in move $k$\n* ring in move $k$\n* bridge-fork in move $k$\n* bridge-ring in move $k$\n* fork-ring in move $k$\n* bridge-fork-ring in move $k$\n\n测试用例编号从 1 开始，落子编号也从 1 开始。", "hint": "**限制条件**\n\n**测试集 1（8 分，结果可见）**\n\n- 时间限制：~~30~~ 3 秒\n- $1 \\leq T \\leq 200$\n- $2 \\leq S \\leq 50$\n- $0 \\leq M \\leq 100$\n\n**测试集 2（12 分，结果隐藏）**\n\n- 时间限制：~~60~~ 6 秒\n- $1 \\leq T \\leq 20$\n- $2 \\leq S \\leq 3000$\n- $0 \\leq M \\leq 10000$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13330", "type": "P", "difficulty": 6, "samples": [["3\n32 5 2\n5 0\n10 2\n10 10 1\n10 10\n10 1 1\n1 5", "Case #1: 3\nCase #2: 0\nCase #3: 8"]], "limits": {"time": [4000, 4000], "memory": [1048576, 1048576]}, "tags": ["数学", "2012", "二分", "三分", "Google Code Jam"], "title": "[GCJ 2012 #3] Quality Food", "background": "", "description": "You just moved from your hometown to a big metropolitan city! You love everything about your new environment, except for the food. Your hometown provides the best food in the region (called \"quality food\") and you sure will miss it.\n\nFortunately, the largest restaurant in your hometown provides a food delivery service. You can purchase any amount of food in one delivery. There is a constant delivery fee for every delivery, regardless of the amount of food purchased in the delivery.\n\nThis restaurant serves different types of food. Each type of food has two properties: a price-per-meal, and a time-to-stale. One \"meal\" of food will feed you for one day; once a meal has been eaten, it cannot be eaten again. The time-to-stale of a type of food is the maximum number of days for which that food can still be eaten, counting from when you received it. A time-to-stale of zero means you must eat that type of food on the day of delivery.\n\nIn a single delivery you can purchase as many different types of food, and as many meals of each of those types, as you have money for. Note that if a particular type of food has a time-to-stale of $t$, it doesn't make any sense to order more than $t+1$ meals of that food in one delivery: at least one meal would go stale before you could eat it.\n\nThis restaurant has a very fast delivery service, so you will receive all the food in a delivery on the same day that you purchased it, and you may eat some of the food on the same day. Food delivery is the only way for you to receive quality food.\n\nGiven an amount of money, which you can spend on meal prices and delivery fees, what is the maximum number of days for which you can eat quality food every day?", "inputFormat": "The first line of input gives the number of test cases, $T$. $T$ test cases follow. Each test case will begin with three integers, $M$, $F$ and $N$, denoting the amount of money you have, the delivery fee, and the number of types of food provided by the restaurant, respectively. $N$ lines follow, each will consist of two integers, $P_i$ and $S_i$, denoting respectively the price-per-meal and time-to-stale of one type of food.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the maximum number of days that you can keep eating at least one meal of quality food everyday.", "hint": "**Sample Explanation**\n\nAn example scenario for the first case is by purchasing one meal of the first type and one meal of the second type during your first day in the city (costing a total of 20). Eat the first type of food that day, and eat the second type the next day. During your third day, purchase one meal of the first type and eat it on the same day. This accounts for three days.\n\n**Limits**\n\n- $1 \\leq T \\leq 50.$\n- $1 \\leq F \\leq M.$\n- $1 \\leq N \\leq 200.$\n- $1 \\leq P_i \\leq M.$\n\n**Test set 1 (9 Pts, Visible Verdict)**\n\n- $0 \\leq S_i \\leq 2,000,000.$\n- $1 \\leq M \\leq 2,000,000.$\n\n**Test set 2 (18 Pts, Hidden Verdict)**\n\n- $0 \\leq S_i \\leq 10^{18}.$\n- $1 \\leq M \\leq 10^{18}.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #3] Quality Food", "background": "", "description": "You just moved from your hometown to a big metropolitan city! You love everything about your new environment, except for the food. Your hometown provides the best food in the region (called \"quality food\") and you sure will miss it.\n\nFortunately, the largest restaurant in your hometown provides a food delivery service. You can purchase any amount of food in one delivery. There is a constant delivery fee for every delivery, regardless of the amount of food purchased in the delivery.\n\nThis restaurant serves different types of food. Each type of food has two properties: a price-per-meal, and a time-to-stale. One \"meal\" of food will feed you for one day; once a meal has been eaten, it cannot be eaten again. The time-to-stale of a type of food is the maximum number of days for which that food can still be eaten, counting from when you received it. A time-to-stale of zero means you must eat that type of food on the day of delivery.\n\nIn a single delivery you can purchase as many different types of food, and as many meals of each of those types, as you have money for. Note that if a particular type of food has a time-to-stale of $t$, it doesn't make any sense to order more than $t+1$ meals of that food in one delivery: at least one meal would go stale before you could eat it.\n\nThis restaurant has a very fast delivery service, so you will receive all the food in a delivery on the same day that you purchased it, and you may eat some of the food on the same day. Food delivery is the only way for you to receive quality food.\n\nGiven an amount of money, which you can spend on meal prices and delivery fees, what is the maximum number of days for which you can eat quality food every day?", "inputFormat": "The first line of input gives the number of test cases, $T$. $T$ test cases follow. Each test case will begin with three integers, $M$, $F$ and $N$, denoting the amount of money you have, the delivery fee, and the number of types of food provided by the restaurant, respectively. $N$ lines follow, each will consist of two integers, $P_i$ and $S_i$, denoting respectively the price-per-meal and time-to-stale of one type of food.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the maximum number of days that you can keep eating at least one meal of quality food everyday.", "hint": "**Sample Explanation**\n\nAn example scenario for the first case is by purchasing one meal of the first type and one meal of the second type during your first day in the city (costing a total of 20). Eat the first type of food that day, and eat the second type the next day. During your third day, purchase one meal of the first type and eat it on the same day. This accounts for three days.\n\n**Limits**\n\n- $1 \\leq T \\leq 50.$\n- $1 \\leq F \\leq M.$\n- $1 \\leq N \\leq 200.$\n- $1 \\leq P_i \\leq M.$\n\n**Test set 1 (9 Pts, Visible Verdict)**\n\n- $0 \\leq S_i \\leq 2,000,000.$\n- $1 \\leq M \\leq 2,000,000.$\n\n**Test set 2 (18 Pts, Hidden Verdict)**\n\n- $0 \\leq S_i \\leq 10^{18}.$\n- $1 \\leq M \\leq 10^{18}.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #3] Quality Food", "background": null, "description": "你刚刚从家乡搬到了一座大都市！你喜欢新环境的一切，除了食物。你的家乡是该地区美食的圣地（被称为“优质美食”），你一定会非常怀念。\n\n幸运的是，你家乡最大的一家餐厅提供送餐服务。每次送餐你可以购买任意数量的食物。不论你购买多少食物，每次送餐都需要支付一笔固定的送餐费。\n\n这家餐厅供应多种不同类型的食物。每种食物都有两个属性：每份价格（price-per-meal）和变质时间（time-to-stale）。一份食物可以供你吃一天；吃掉后不能再吃。某种食物的变质时间 $t$ 表示，从你收到食物起，这种食物最多可以保存 $t$ 天。变质时间为 $0$ 意味着你必须在送到当天吃掉。\n\n每次送餐你可以购买任意多种食物，以及每种食物的任意份数，只要你有足够的钱。注意，如果某种食物的变质时间为 $t$，那么在一次送餐中最多只能购买 $t+1$ 份该食物：否则至少有一份会在你吃到之前变质。\n\n这家餐厅送餐速度非常快，所以你当天下单就能收到所有食物，并且可以在当天吃掉部分食物。送餐是你获得优质美食的唯一方式。\n\n给定你拥有的金钱数（可用于购买食物和支付送餐费），你最多能连续多少天每天都吃到至少一份优质美食？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组数据首先有三个整数 $M$、$F$ 和 $N$，分别表示你拥有的金钱数、每次送餐的费用、以及餐厅提供的食物种类数。接下来 $N$ 行，每行两个整数 $P_i$ 和 $S_i$，分别表示某种食物的每份价格和变质时间。", "outputFormat": "对于每个测试用例，输出一行 \"Case #$x$: $y$\"，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为你最多能连续多少天每天吃到至少一份优质美食。", "hint": "**样例说明**\n\n以第一个样例为例，你可以在第一天购买第一种食物一份和第二种食物一份（共花费 20 元），第一天吃第一种，第二天吃第二种。第三天再买一份第一种食物当天吃掉。这样共能吃三天。\n\n**限制条件**\n\n- $1 \\leq T \\leq 50$\n- $1 \\leq F \\leq M$\n- $1 \\leq N \\leq 200$\n- $1 \\leq P_i \\leq M$\n\n**测试集 1（9 分，结果可见）**\n\n- $0 \\leq S_i \\leq 2,\\!000,\\!000$\n- $1 \\leq M \\leq 2,\\!000,\\!000$\n\n**测试集 2（18 分，结果隐藏）**\n\n- $0 \\leq S_i \\leq 10^{18}$\n- $1 \\leq M \\leq 10^{18}$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13331", "type": "P", "difficulty": 7, "samples": [["4\n2\npoppop\n2\ngoogle\n2\ntbilcwhafiparmdmotcaaloth\n10\ntbilcwhafiparmdmotcaaloth", "Case #1: 6\nCase #2: 18\nCase #3: 53\nCase #4: 1136"]], "limits": {"time": [4000, 4000], "memory": [1048576, 1048576]}, "tags": ["2012", "模拟费用流", "Google Code Jam"], "title": "[GCJ 2012 #3] Lost Password", "background": "", "description": "Ashish has forgotten his password. He remembers that he used the following algorithm to create his password: Ashish took up to $k$ consecutive words from a passage of text, and took the first letter from each word. Then, he might have changed some of the letters to their \"l33tspeak\" equivalents. Specifically, he might have changed \"o\" to \"0\", \"i\" to \"1\", \"e\" to \"3\", \"a\" to \"4\", \"s\" to \"5\", \"t\" to \"7\", \"b\" to \"8\" and/or \"g\" to \"9\".\n\nFor example, if Ashish took his password from the first sentence of The Fellowship of the Ring -- \"This book is largely concerned with Hobbits, and from its pages a reader may discover much of their character and a little of their history\" -- Ashish would have reduced that to \"tbilcwhafiparmdmotcaaloth\". Then the password might be \"tbilcwh\", \"7b1lcwh4f\", \"a\", \"4\", or \"4al07h\", etc.\n\nAshish has a special extension installed in his browser that will prevent his computer from uploading any string that contains his password. In order to figure out which passage of text he took his password from, Ashish has created a webpage to take advantage of this extension. Every second, the webpage will tell the browser to post a \"password string\" for a new passage of text: a string that contains all of the possible passwords that Ashish could have chosen from that passage of text. As soon as his browser fails to post such a string, Ashish will know where he took his password from.\n\nFor example, if $k = 2$ and the passage of text contains words starting with the letters \"google\", then one password string for that passage is \"goo0og00gle9o909l3\". All substrings of length $\\leq 2$ from the original string, and all of their l33tspeak equivalents, are contained in the new string.\n\nGiven the first letters of the words in a passage of text, what is the minimum number of characters in the \"password string\" of that passage?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of two lines. The first line contains the integer $k$. The second line contains a string $S$, representing the first letters of the words in a passage of text. $S$ contains only the characters 'a' - 'z', with no spaces.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the minimum number of characters in the password string for $S$.", "hint": "**Sample Explanation**\n\n- In the first sample input, one possible password string is \"0ppop0\".\n- In the second sample input, one possible password string is \"goo0og00gle9o909l3\".\n\n**Limits**\n\n- $1 \\leq T \\leq 20.$\n- $S$ will contain at least $2 \\times k$ characters.\n- There will exist a password string with at most $10^{18}$ characters.\n\n**Test set 1 (7 Pts, Visible Verdict)**\n\n- $S$ will contain at most 1000 characters.\n- $k = 2.$\n\n**Test set 2 (36 Pts, Hidden Verdict)**\n\n- $S$ will contain at most 5000 characters.\n- $2 \\leq k \\leq 500.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 #3] Lost Password", "background": "", "description": "Ashish has forgotten his password. He remembers that he used the following algorithm to create his password: Ashish took up to $k$ consecutive words from a passage of text, and took the first letter from each word. Then, he might have changed some of the letters to their \"l33tspeak\" equivalents. Specifically, he might have changed \"o\" to \"0\", \"i\" to \"1\", \"e\" to \"3\", \"a\" to \"4\", \"s\" to \"5\", \"t\" to \"7\", \"b\" to \"8\" and/or \"g\" to \"9\".\n\nFor example, if Ashish took his password from the first sentence of The Fellowship of the Ring -- \"This book is largely concerned with Hobbits, and from its pages a reader may discover much of their character and a little of their history\" -- Ashish would have reduced that to \"tbilcwhafiparmdmotcaaloth\". Then the password might be \"tbilcwh\", \"7b1lcwh4f\", \"a\", \"4\", or \"4al07h\", etc.\n\nAshish has a special extension installed in his browser that will prevent his computer from uploading any string that contains his password. In order to figure out which passage of text he took his password from, Ashish has created a webpage to take advantage of this extension. Every second, the webpage will tell the browser to post a \"password string\" for a new passage of text: a string that contains all of the possible passwords that Ashish could have chosen from that passage of text. As soon as his browser fails to post such a string, Ashish will know where he took his password from.\n\nFor example, if $k = 2$ and the passage of text contains words starting with the letters \"google\", then one password string for that passage is \"goo0og00gle9o909l3\". All substrings of length $\\leq 2$ from the original string, and all of their l33tspeak equivalents, are contained in the new string.\n\nGiven the first letters of the words in a passage of text, what is the minimum number of characters in the \"password string\" of that passage?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case consists of two lines. The first line contains the integer $k$. The second line contains a string $S$, representing the first letters of the words in a passage of text. $S$ contains only the characters 'a' - 'z', with no spaces.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $y$\", where $x$ is the case number (starting from 1) and $y$ is the minimum number of characters in the password string for $S$.", "hint": "**Sample Explanation**\n\n- In the first sample input, one possible password string is \"0ppop0\".\n- In the second sample input, one possible password string is \"goo0og00gle9o909l3\".\n\n**Limits**\n\n- $1 \\leq T \\leq 20.$\n- $S$ will contain at least $2 \\times k$ characters.\n- There will exist a password string with at most $10^{18}$ characters.\n\n**Test set 1 (7 Pts, Visible Verdict)**\n\n- $S$ will contain at most 1000 characters.\n- $k = 2.$\n\n**Test set 2 (36 Pts, Hidden Verdict)**\n\n- $S$ will contain at most 5000 characters.\n- $2 \\leq k \\leq 500.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 #3] Lost Password", "background": "", "description": "Ashish 忘记了自己的密码。他记得自己是用如下算法创建密码的：Ashish 从一段文本中取出最多 $k$ 个连续的单词，然后取每个单词的首字母。接着，他可能将其中一些字母替换为它们的“l33tspeak”变体。具体来说，他可能将 \"o\" 替换为 \"0\"，\"i\" 替换为 \"1\"，\"e\" 替换为 \"3\"，\"a\" 替换为 \"4\"，\"s\" 替换为 \"5\"，\"t\" 替换为 \"7\"，\"b\" 替换为 \"8\"，\"g\" 替换为 \"9\"。\n\n例如，如果 Ashish 从《魔戒首部曲》（The Fellowship of the Ring）的第一句——\"This book is largely concerned with Hobbits, and from its pages a reader may discover much of their character and a little of their history\"——中取密码，则他会将其简化为 \"tbilcwhafiparmdmotcaaloth\"。那么密码可能是 \"tbilcwh\"、\"7b1lcwh4f\"、\"a\"、\"4\" 或 \"4al07h\" 等等。\n\nAshish 的浏览器安装了一个特殊扩展，这个扩展会阻止他的电脑上传任何包含其密码的字符串。为了找出自己密码所取的文本段落，Ashish 创建了一个网页来利用这个扩展。每秒钟，这个网页会让浏览器尝试上传一个该段落的“密码字符串”：这个字符串包含了从该段落可能生成的所有密码。一旦浏览器无法上传这样的字符串，Ashish 就知道密码取自哪里了。\n\n例如，若 $k = 2$，而文本首字母为 \"google\"，那么该段落的一个密码字符串为 \"goo0og00gle9o909l3\"。原始字符串的所有长度不超过 $2$ 的子串，以及它们的 l33tspeak 变体，都包含在这个新字符串中。\n\n给定某段文本所有单词的首字母，问该段落的“密码字符串”最少需要多少个字符？", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据包含两行。第一行为整数 $k$。第二行为字符串 $S$，表示该段落所有单词的首字母。$S$ 仅包含 'a'-'z'，且不含空格。\n", "outputFormat": "对于每个测试用例，输出一行 \"Case #$x$: $y$\"，其中 $x$ 为测试用例编号（从 1 开始），$y$ 为 $S$ 的最小密码字符串长度。\n", "hint": "**样例说明**\n\n- 在第一个样例中，一个可能的密码字符串是 \"0ppop0\"。\n- 在第二个样例中，一个可能的密码字符串是 \"goo0og00gle9o909l3\"。\n\n**限制条件**\n\n- $1 \\leq T \\leq 20$\n- $S$ 至少包含 $2 \\times k$ 个字符。\n- 一定存在长度不超过 $10^{18}$ 的密码字符串。\n\n**测试集 1（7 分，结果可见）**\n\n- $S$ 最多包含 1000 个字符。\n- $k = 2$。\n\n**测试集 2（36 分，结果隐藏）**\n\n- $S$ 最多包含 5000 个字符。\n- $2 \\leq k \\leq 500$。\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13332", "type": "P", "difficulty": 5, "samples": [["3\n4\n1 0 0\n-1 0 0\n10 10 1000\n10 -10 1000\n3\n1 1 0\n2 2 0\n3 3 0\n5\n10 10 1000\n-10 10 1000\n10 -10 1000\n-10 -10 1000\n20 20 2000", "Case #1: 3\nCase #2: 2\nCase #3: 2"]], "limits": {"time": [6000, 6000], "memory": [1048576, 1048576]}, "tags": ["图论", "2012", "最短路", "Google Code Jam"], "title": "[GCJ 2012 Finals] Zombie Smash", "background": "", "description": "You are playing Zombie Smash: a game where the objective is to smash zombies with your trusty Zombie Smasher as they pop out of graves at the graveyard. The graveyard is represented by a flat 2D grid. Each zombie will pop out of a grave at some $(X, Y)$ cell on the grid, stand in place for 1000 milliseconds (ms), and then disappear back into the grave. At most one zombie can stand around a grave at a time.\n\nYou can move to any one of the 8 cells adjacent to your location in 100ms; i.e., you can move North, East, South, West, NW, NE, SW, and SE of your current location. You may move through or stand on a cell even if it is currently occupied by a zombie. You can smash a zombie instantly once you reach the cell that the zombie is standing on, but once you smash a zombie it takes 750ms for your Zombie Smasher to recharge before you can smash another zombie. You may move around while Zombie Smasher is recharging. For example, immediately after smashing a zombie at $(0, 0)$:\n\n* It will take 750ms to reach and smash a zombie at $(1, 1)$ or\n* 2000ms to reach and smash a zombie at $(20, 20)$.\n\nYou start at cell $(0, 0)$ at the beginning of the game (time=0). After you play a level you would like to know how many zombies you could have smashed, if you had played optimally.\n", "inputFormat": "The first line will contain a single integer $T$, the number of test cases. It is followed by $T$ test cases, each starting with a line containing a single integer $Z$, the number of zombies in the level.\n\nThe next $Z$ lines contain 3 space-separated integers each, representing the location and time at which a given zombie will appear and disappear. The $i^{th}$ line will contain the integers $X_i$, $Y_i$ and $M_i$, where:\n\n* $X_i$ is the X coordinate of the cell at which zombie $i$ appears,\n* $Y_i$ is the Y coordinate of the cell at which zombie $i$ appears,\n* $M_i$ is the time at which zombie $i$ appears, in milliseconds after the beginning of the game. The time interval during which the zombie can smashed is inclusive: if you reach the cell at any time in the range $[M_i, M_i + 1000]$ with a charged Zombie Smasher, you can smash the zombie in that cell.\n", "outputFormat": "For each test case, output one line containing \"Case #$c$: $d$\", where $c$ is the case number (starting from 1), and $d$ is the maximum number of zombies you could have smashed in this level.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $-1000 \\leq X_i, Y_i \\leq 1000.$\n- $0 \\leq M_i \\leq 100000000 = 10^8.$\n- Two zombies will never be in the same location at the same time. In other words, if one zombie appears at $(x, y)$ at time $t$, then any other zombie that appears at $(x, y)$ must appear at or before $(t - 1001)$, or at or after $(t + 1001)$.\n\n**Test set 1 (7 Pts, Visible Verdict)**\n\n- $1 \\leq Z \\leq 8.$\n\n**Test set 2 (18 Pts, Hidden Verdict)**\n\n- $1 \\leq Z \\leq 100.$\n", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 Finals] Zombie Smash", "background": "", "description": "You are playing Zombie Smash: a game where the objective is to smash zombies with your trusty Zombie Smasher as they pop out of graves at the graveyard. The graveyard is represented by a flat 2D grid. Each zombie will pop out of a grave at some $(X, Y)$ cell on the grid, stand in place for 1000 milliseconds (ms), and then disappear back into the grave. At most one zombie can stand around a grave at a time.\n\nYou can move to any one of the 8 cells adjacent to your location in 100ms; i.e., you can move North, East, South, West, NW, NE, SW, and SE of your current location. You may move through or stand on a cell even if it is currently occupied by a zombie. You can smash a zombie instantly once you reach the cell that the zombie is standing on, but once you smash a zombie it takes 750ms for your Zombie Smasher to recharge before you can smash another zombie. You may move around while Zombie Smasher is recharging. For example, immediately after smashing a zombie at $(0, 0)$:\n\n* It will take 750ms to reach and smash a zombie at $(1, 1)$ or\n* 2000ms to reach and smash a zombie at $(20, 20)$.\n\nYou start at cell $(0, 0)$ at the beginning of the game (time=0). After you play a level you would like to know how many zombies you could have smashed, if you had played optimally.\n", "inputFormat": "The first line will contain a single integer $T$, the number of test cases. It is followed by $T$ test cases, each starting with a line containing a single integer $Z$, the number of zombies in the level.\n\nThe next $Z$ lines contain 3 space-separated integers each, representing the location and time at which a given zombie will appear and disappear. The $i^{th}$ line will contain the integers $X_i$, $Y_i$ and $M_i$, where:\n\n* $X_i$ is the X coordinate of the cell at which zombie $i$ appears,\n* $Y_i$ is the Y coordinate of the cell at which zombie $i$ appears,\n* $M_i$ is the time at which zombie $i$ appears, in milliseconds after the beginning of the game. The time interval during which the zombie can smashed is inclusive: if you reach the cell at any time in the range $[M_i, M_i + 1000]$ with a charged Zombie Smasher, you can smash the zombie in that cell.\n", "outputFormat": "For each test case, output one line containing \"Case #$c$: $d$\", where $c$ is the case number (starting from 1), and $d$ is the maximum number of zombies you could have smashed in this level.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $-1000 \\leq X_i, Y_i \\leq 1000.$\n- $0 \\leq M_i \\leq 100000000 = 10^8.$\n- Two zombies will never be in the same location at the same time. In other words, if one zombie appears at $(x, y)$ at time $t$, then any other zombie that appears at $(x, y)$ must appear at or before $(t - 1001)$, or at or after $(t + 1001)$.\n\n**Test set 1 (7 Pts, Visible Verdict)**\n\n- $1 \\leq Z \\leq 8.$\n\n**Test set 2 (18 Pts, Hidden Verdict)**\n\n- $1 \\leq Z \\leq 100.$\n", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 Finals] Zombie Smash", "background": "", "description": "你正在玩丧尸粉碎（Zombie Smash）这款游戏：你的目标是在墓地中用你可靠的丧尸粉碎器击碎不断从坟墓中冒出的丧尸。墓地被表示为一个平坦的二维网格。每只丧尸会在网格的某个 $(X, Y)$ 单元格中冒出，停留 1000 毫秒（ms），然后又消失回坟墓。任意时刻每个坟墓旁最多只会有一只丧尸。\n\n你可以在 100ms 内移动到当前位置周围 8 个相邻格中的任意一个：也就是说，你可以向正北、正东、正南、正西、东北、东南、西北、西南移动。即使某个格子当前有丧尸占据，你依然可以经过或停在该格子。只要你到达丧尸所在的格子，就可以立即击碎该丧尸，但每次击碎后，你的丧尸粉碎器需要 750ms 冷却，冷却期间你不能再次击碎丧尸，但你可以自由移动。例如，刚刚在 $(0, 0)$ 击碎一只丧尸后：\n\n* 你需要 750ms 才能到达并击碎 $(1, 1)$ 处的丧尸；\n* 你需要 2000ms 才能到达并击碎 $(20, 20)$ 处的丧尸。\n\n你在游戏开始时（时间 $=0$）站在 $(0, 0)$。每一关结束后，你想知道如果你玩得最优，这一关你最多能击碎多少只丧尸。", "inputFormat": "第一行为一个整数 $T$，表示测试用例数量。接下来有 $T$ 组测试数据，每组首先一行一个整数 $Z$，表示本关丧尸数量。\n\n接下来 $Z$ 行，每行包含 3 个用空格分隔的整数，描述一只丧尸出现和消失的时间及位置。第 $i$ 行为 $X_i$、$Y_i$、$M_i$，其中：\n\n* $X_i$ 为第 $i$ 只丧尸出现的横坐标，\n* $Y_i$ 为第 $i$ 只丧尸出现的纵坐标，\n* $M_i$ 为第 $i$ 只丧尸出现的时间（自游戏开始后的毫秒数）。你可以在 $[M_i, M_i+1000]$ 区间内任意时刻到达该格子并且丧尸粉碎器已充能时，立即击碎该丧尸。\n", "outputFormat": "对于每个测试用例，输出一行 \"Case #$c$: $d$\"，其中 $c$ 为测试用例编号（从 1 开始），$d$ 为本关你最多能击碎的丧尸数量。\n", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 100$\n- $-1000 \\leq X_i, Y_i \\leq 1000$\n- $0 \\leq M_i \\leq 100000000 = 10^8$\n- 任意时刻同一格子不会有两只丧尸。换言之，如果某只丧尸在 $(x, y)$ 的 $t$ 时刻出现，则其他在 $(x, y)$ 出现的丧尸要么出现在 $t-1001$ 及更早，要么出现在 $t+1001$ 及更晚。\n\n**测试集 1（7 分，结果可见）**\n\n- $1 \\leq Z \\leq 8$\n\n**测试集 2（18 分，结果隐藏）**\n\n- $1 \\leq Z \\leq 100$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13333", "type": "P", "difficulty": 5, "samples": [["3\n4 1\n1/2 3\n1/5 2\n2/5 1\n2/2 2\n3 2\n1/2 2\n1/3 2\n3/4 2\n3 3\n99/100 1\n1/2 2\n1/50 3", "Case #1: 0.000000000\nCase #2: 0.083333333\nCase #3: 0.015000000"]], "limits": {"time": [6000, 12000], "memory": [1048576, 1048576]}, "tags": ["动态规划 DP", "贪心", "2012", "Special Judge", "概率论", "Google Code Jam"], "title": "[GCJ 2012 Finals] Upstairs/Downstairs", "background": "", "description": "Konstantin and Ilia live in the same house. Konstantin lives upstairs, and enjoys activities that involve jumping, moving furniture around, and - in general - making noise. Ilia lives downstairs, and enjoys sleep.\n\nIn order to have a good evening, Konstantin wants to do at least $K$ activities. Last night, Ilia asked Konstantin to try not to wake him up; and because Konstantin is a very nice neighbor, he agreed. Unfortunately, he took Ilia's request a bit too literally, and he will choose his activities in such a way as to minimize the probability that Ilia is woken up after falling asleep.\n\nEach possible activity for Konstantin has an associated probability $a_i / b_i$. If Konstantin performs this activity, then at the end of it, Ilia will be awake with probability $a_i / b_i$, and asleep otherwise, regardless of whether he was asleep at the start. Moreover, for each possible activity Konstantin can perform it at most $c_i$ times (more than that would be boring, and Konstantin won't have a good evening if he's bored).\n\nKonstantin wants to choose a number of activities to do, in order, so that:\n\n* The total number of activities done is at least $K$.\n* The $i$th activity is performed no more than $c_i$ times.\n* The probability $Q$ that Ilia is woken up one or more times during the course of the activities is as small as possible.\n\nIlia starts awake, so in order for him to be woken up, he must be asleep at the end of some activity, and then awake at the end of the next activity.\n\nWhat is the smallest $Q$ Konstantin can achieve while having a good evening? Note that Konstantin cannot tell whether Ilia is awake or asleep, and so he cannot adapt his activities using that information.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a pair of integers, $N$, $K$, on a line by themselves. $N$ lines follow, each of which represents an activity that Konstantin can choose. Each of those lines is formatted as \"$a_i/b_i$ $c_i$\", indicating that there is an activity which would leave Ilia awake with probability $a_i/b_i$ and which Konstantin can perform at most $c_i$ times without being bored.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $Q$\", where $x$ is the case number (starting from 1) and $Q$ is the smallest probability of Ilia waking up during the course of the activities that Konstantin performs. Answers with absolute or relative error no larger than $10^{-6}$ will be accepted.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $0 \\leq a_i \\leq b_i \\leq 1000000$ for all $i$.\n- $1 \\leq b_i$ and $1 \\leq c_i$ for all $i$.\n- $1 \\leq K \\leq$ the sum of all $c_i$ in that test case.\n\n**Test set 1 (13 Pts, Visible Verdict)**\n\n- Time limit: ~~30~~ 6 seconds.\n- $1 \\leq N \\leq 100.$\n- The sum of all $c_i$ is no larger than $100$ in each test case.\n\n**Test set 2 (17 Pts, Hidden Verdict)**\n\n- Time limit: ~~60~~ 12 seconds.\n- $1 \\leq N \\leq 10000.$\n- The sum of all $c_i$ is no larger than $10^6$ in each test case.", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 Finals] Upstairs/Downstairs", "background": "", "description": "Konstantin and Ilia live in the same house. Konstantin lives upstairs, and enjoys activities that involve jumping, moving furniture around, and - in general - making noise. Ilia lives downstairs, and enjoys sleep.\n\nIn order to have a good evening, Konstantin wants to do at least $K$ activities. Last night, Ilia asked Konstantin to try not to wake him up; and because Konstantin is a very nice neighbor, he agreed. Unfortunately, he took Ilia's request a bit too literally, and he will choose his activities in such a way as to minimize the probability that Ilia is woken up after falling asleep.\n\nEach possible activity for Konstantin has an associated probability $a_i / b_i$. If Konstantin performs this activity, then at the end of it, Ilia will be awake with probability $a_i / b_i$, and asleep otherwise, regardless of whether he was asleep at the start. Moreover, for each possible activity Konstantin can perform it at most $c_i$ times (more than that would be boring, and Konstantin won't have a good evening if he's bored).\n\nKonstantin wants to choose a number of activities to do, in order, so that:\n\n* The total number of activities done is at least $K$.\n* The $i$th activity is performed no more than $c_i$ times.\n* The probability $Q$ that Ilia is woken up one or more times during the course of the activities is as small as possible.\n\nIlia starts awake, so in order for him to be woken up, he must be asleep at the end of some activity, and then awake at the end of the next activity.\n\nWhat is the smallest $Q$ Konstantin can achieve while having a good evening? Note that Konstantin cannot tell whether Ilia is awake or asleep, and so he cannot adapt his activities using that information.", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a pair of integers, $N$, $K$, on a line by themselves. $N$ lines follow, each of which represents an activity that Konstantin can choose. Each of those lines is formatted as \"$a_i/b_i$ $c_i$\", indicating that there is an activity which would leave Ilia awake with probability $a_i/b_i$ and which Konstantin can perform at most $c_i$ times without being bored.\n", "outputFormat": "For each test case, output one line containing \"Case #$x$: $Q$\", where $x$ is the case number (starting from 1) and $Q$ is the smallest probability of Ilia waking up during the course of the activities that Konstantin performs. Answers with absolute or relative error no larger than $10^{-6}$ will be accepted.", "hint": "**Limits**\n\n- $1 \\leq T \\leq 100.$\n- $0 \\leq a_i \\leq b_i \\leq 1000000$ for all $i$.\n- $1 \\leq b_i$ and $1 \\leq c_i$ for all $i$.\n- $1 \\leq K \\leq$ the sum of all $c_i$ in that test case.\n\n**Test set 1 (13 Pts, Visible Verdict)**\n\n- Time limit: ~~30~~ 6 seconds.\n- $1 \\leq N \\leq 100.$\n- The sum of all $c_i$ is no larger than $100$ in each test case.\n\n**Test set 2 (17 Pts, Hidden Verdict)**\n\n- Time limit: ~~60~~ 12 seconds.\n- $1 \\leq N \\leq 10000.$\n- The sum of all $c_i$ is no larger than $10^6$ in each test case.", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 Finals] Upstairs/Downstairs", "background": "", "description": "Konstantin 和 Ilia 住在同一栋房子里。Konstantin 住在楼上，喜欢跳跃、搬动家具等一切会制造噪音的活动。Ilia 住在楼下，喜欢睡觉。\n\n为了度过一个愉快的夜晚，Konstantin 希望至少做 $K$ 项活动。昨晚，Ilia 请 Konstantin 尽量不要吵醒他；而 Konstantin 是个非常友善的邻居，他答应了。可惜，他把 Ilia 的请求理解得太过字面，于是他会以最小化 Ilia 被吵醒概率的方式来选择自己的活动顺序。\n\nKonstantin 可以选择的每项活动都有一个相关概率 $a_i / b_i$。如果 Konstantin 执行了这项活动，那么在活动结束时，Ilia 会以 $a_i / b_i$ 的概率是清醒的，否则是睡着的——无论活动前 Ilia 是什么状态。此外，每项活动至多可以执行 $c_i$ 次（超过这个次数会觉得无聊，而无聊的夜晚可不是好夜晚）。\n\nKonstantin 希望选择一系列活动，按顺序进行，使得：\n\n* 总共进行的活动数不少于 $K$；\n* 第 $i$ 项活动最多执行 $c_i$ 次；\n* Ilia 在活动过程中被吵醒一次或多次的概率 $Q$ 尽可能小。\n\nIlia 初始是清醒的，因此，只有在某项活动结束时 Ilia 处于睡着状态，且紧接着下一项活动结束时 Ilia 变为清醒，才算作 Ilia 被吵醒了一次。\n\nKonstantin 无法判断 Ilia 当前是清醒还是睡着，因此他不能根据 Ilia 的状态调整自己的活动选择。\n\n问 Konstantin 在度过一个愉快夜晚的前提下，最小能做到的 $Q$ 是多少？注意：Konstantin 无法得知 Ilia 的状态，因此不能根据状态自适应选择活动。\n", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组测试数据首先一行两个整数 $N$、$K$。接下来 $N$ 行，每行描述一种活动，格式为 \"$a_i/b_i$ $c_i$\"，表示该活动结束时 Ilia 以 $a_i/b_i$ 的概率清醒，且该活动最多可执行 $c_i$ 次。\n", "outputFormat": "对于每个测试用例，输出一行 \"Case #$x$: $Q$\"，其中 $x$ 为测试用例编号（从 1 开始），$Q$ 为 Konstantin 执行这些活动过程中 Ilia 被吵醒的最小概率。答案的绝对或相对误差不超过 $10^{-6}$ 即视为正确。\n", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 100$\n- 对所有 $i$，$0 \\leq a_i \\leq b_i \\leq 1000000$\n- 对所有 $i$，$1 \\leq b_i$ 且 $1 \\leq c_i$\n- $1 \\leq K \\leq$ 本组测试数据所有 $c_i$ 之和\n\n**测试集 1（13 分，结果可见）**\n\n- 时间限制：~~30~~ 6 秒\n- $1 \\leq N \\leq 100$\n- 本组测试数据所有 $c_i$ 之和不超过 $100$\n\n**测试集 2（17 分，结果隐藏）**\n\n- 时间限制：~~60~~ 12 秒\n- $1 \\leq N \\leq 10000$\n- 本组测试数据所有 $c_i$ 之和不超过 $10^6$\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
{"pid": "P13334", "type": "P", "difficulty": 6, "samples": [["6\n1\n0 0 .\n1\n0 0 #\n3\n0 0 #\n0 1 #\n1 0 #\n5\n50 30 #\n49 30 #\n49 31 #\n49 32 #\n50 32 #\n2\n-98 0 #\n99 50 .\n4\n88 88 .\n88 89 .\n89 88 .\n89 89 .", "Case #1: 0 0\nCase #2: 1 0\nCase #3: 1 1\nCase #4: 50 31\nCase #5: 1 0\nCase #6: Too damaged"]], "limits": {"time": [6000, 6000], "memory": [1048576, 1048576]}, "tags": ["数学", "2012", "扫描线", "分类讨论", "Google Code Jam"], "title": "[GCJ 2012 Finals] Xeno-archaeology", "background": "", "description": "Long ago, an alien civilization built a giant monument. The floor of the monument looked like this:\n\n```\n###############\n#.............#\n#.###########.#\n#.#.........#.#\n#.#.#######.#.#\n#.#.#.....#.#.#\n#.#.#.###.#.#.#\n#.#.#.#.#.#.#.#\n#.#.#.###.#.#.#\n#.#.#.....#.#.#\n#.#.#######.#.#\n#.#.........#.#\n#.###########.#\n#.............#\n###############\n```\n\nEach '#' represents a red tile, and each '.' represents a blue tile. The pattern went on for miles and miles (you may, for the purposes of the problem, assume it was infinite). Today, only a few of the tiles remain. The rest have been damaged by methane rain and dust storms. Given the locations and colours of the remaining tiles, can you find the center of the pattern?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each one starts with a line containing $N$, the number of remaining tiles. The next $N$ lines each contain $X_i$, $Y_i$, and the tile colour (either '#' or '.').\n", "outputFormat": "For each test case, output one line containing \"Case #$c$: $X$ $Y$\", where $c$ is the case number (starting from 1) and ($X$, $Y$) is the location of the center of the pattern. If there is more than one possible answer, output the ($X$, $Y$) closest to (0, 0) in Manhattan distance (the distance in $x$, plus the distance in $y$). If there are still ties, output the one with the largest $X$. If there are still ties after that, output the one with the largest $Y$. If there is no possible answer, output \"Case #$c$: Too damaged\".", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50.$\n- The list of coordinates in each test case will not contain duplicates.\n\n**Test set 1 (12 Pts, Visible Verdict)**\n\n- $1 \\leq N \\leq 100.$\n- $-100 \\leq X_i \\leq 100.$\n- $-100 \\leq Y_i \\leq 100.$\n\n**Test set 2 (33 Pts, Hidden Verdict)**\n\n- $1 \\leq N \\leq 1000.$\n- $-10^{15} \\leq X_i \\leq 10^{15}.$\n- $-10^{15} \\leq Y_i \\leq 10^{15}.$", "locale": "en", "translations": {"en": {"title": "[GCJ 2012 Finals] Xeno-archaeology", "background": "", "description": "Long ago, an alien civilization built a giant monument. The floor of the monument looked like this:\n\n```\n###############\n#.............#\n#.###########.#\n#.#.........#.#\n#.#.#######.#.#\n#.#.#.....#.#.#\n#.#.#.###.#.#.#\n#.#.#.#.#.#.#.#\n#.#.#.###.#.#.#\n#.#.#.....#.#.#\n#.#.#######.#.#\n#.#.........#.#\n#.###########.#\n#.............#\n###############\n```\n\nEach '#' represents a red tile, and each '.' represents a blue tile. The pattern went on for miles and miles (you may, for the purposes of the problem, assume it was infinite). Today, only a few of the tiles remain. The rest have been damaged by methane rain and dust storms. Given the locations and colours of the remaining tiles, can you find the center of the pattern?", "inputFormat": "The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each one starts with a line containing $N$, the number of remaining tiles. The next $N$ lines each contain $X_i$, $Y_i$, and the tile colour (either '#' or '.').\n", "outputFormat": "For each test case, output one line containing \"Case #$c$: $X$ $Y$\", where $c$ is the case number (starting from 1) and ($X$, $Y$) is the location of the center of the pattern. If there is more than one possible answer, output the ($X$, $Y$) closest to (0, 0) in Manhattan distance (the distance in $x$, plus the distance in $y$). If there are still ties, output the one with the largest $X$. If there are still ties after that, output the one with the largest $Y$. If there is no possible answer, output \"Case #$c$: Too damaged\".", "hint": "**Limits**\n\n- $1 \\leq T \\leq 50.$\n- The list of coordinates in each test case will not contain duplicates.\n\n**Test set 1 (12 Pts, Visible Verdict)**\n\n- $1 \\leq N \\leq 100.$\n- $-100 \\leq X_i \\leq 100.$\n- $-100 \\leq Y_i \\leq 100.$\n\n**Test set 2 (33 Pts, Hidden Verdict)**\n\n- $1 \\leq N \\leq 1000.$\n- $-10^{15} \\leq X_i \\leq 10^{15}.$\n- $-10^{15} \\leq Y_i \\leq 10^{15}.$", "locale": "en"}, "zh-CN": {"title": "[GCJ 2012 Finals] Xeno-archaeology", "background": "", "description": "很久以前，一个外星文明建造了一座巨大的纪念碑。纪念碑的地板图案如下：\n\n```\n###############\n#.............#\n#.###########.#\n#.#.........#.#\n#.#.#######.#.#\n#.#.#.....#.#.#\n#.#.#.###.#.#.#\n#.#.#.#.#.#.#.#\n#.#.#.###.#.#.#\n#.#.#.....#.#.#\n#.#.#######.#.#\n#.#.........#.#\n#.###########.#\n#.............#\n###############\n```\n\n每个 `#` 代表一块红色瓷砖，每个 `.` 代表一块蓝色瓷砖。这个图案曾经向四面八方无限延展（在本题中，你可以假设它是无限的）。而今天，只剩下少量瓷砖还留存，其他的都被甲烷雨和尘暴损坏了。现给出所有还剩下的瓷砖的位置和颜色，你能否找出这个图案的中心位置？\n", "inputFormat": "输入的第一行为测试用例数 $T$。接下来有 $T$ 组测试数据。每组数据第一行为整数 $N$，表示剩余瓷砖的数量。接下来的 $N$ 行，每行包含 $X_i$、$Y_i$ 以及瓷砖颜色（`#` 或 `.`）。\n", "outputFormat": "对于每个测试用例，输出一行 \"Case #$c$: $X$ $Y$\"，其中 $c$ 为测试用例编号（从 1 开始），($X$, $Y$) 为图案中心的位置。如果有多个可能的答案，输出与 $(0, 0)$ 曼哈顿距离（$|X| + |Y|$）最小的那个。如果仍有多解，输出 $X$ 最大的那个；如果仍有多解，输出 $Y$ 最大的那个。如果无解，输出 \"Case #$c$: Too damaged\"。\n", "hint": "**限制条件**\n\n- $1 \\leq T \\leq 50$。\n- 每组测试数据中的坐标不会重复。\n\n**测试集 1（12 分，结果可见）**\n\n- $1 \\leq N \\leq 100$。\n- $-100 \\leq X_i \\leq 100$。\n- $-100 \\leq Y_i \\leq 100$。\n\n**测试集 2（33 分，结果隐藏）**\n\n- $1 \\leq N \\leq 1000$。\n- $-10^{15} \\leq X_i \\leq 10^{15}$。\n- $-10^{15} \\leq Y_i \\leq 10^{15}$。\n\n翻译由 ChatGPT-4.1 完成。", "locale": "zh-CN"}}}
