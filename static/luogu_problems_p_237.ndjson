{"pid": "P5792", "type": "P", "difficulty": 7, "samples": [["5 0 100 135\n20 200\n200 100\n300 125\n40 10\n100 100", "469.86"], ["8 1 25 15\n0 0\n0 20\n30 20\n30 0\n20 0\n20 10\n10 10\n10 0", "106.67"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2005", "Special Judge", "CTSC/CTS"], "title": "[CTSC2005] 孤独的牧羊女", "background": "", "description": "在瑞典的达拉纳洲有一座高山。山上有一个小屋，里面住着一位牧羊女。每天清晨，隔壁的山头会传来一阵悠扬的长笛声，而牧羊女则会站在屋里用自己的歌声回应。\n\n小屋的俯视图是一个有 $n$ 个顶点的简单多边形，每一面墙可以反射声音，但是由于不可避免的能量损失，最多只能反射 $k$ 次（$k=0$ 表示不能反射声音）。墙面非常光滑，因此声音的反射遵循反射角等于入射角，如图 $1$。墙角不能反射声音，而每面墙的其他部分——即使离墙角很近——都可以反射声音。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wcjsrg80.png)\n\n突然有一天，牧羊女问自己：在小屋的哪些地方能听到她的歌声？假设所有听众都在屋里靠墙而坐，那么歌声能到达的墙一共有多长？\n图 $2$ 的四幅示意图分别画出了初始情况和声音经过 $0$、$1$、$2$ 次反射后到达的区域。灰色部分表示能听到歌声的部分，黑点表示牧羊女的位置。本题所求即灰色部分在多边形边界上的**总长度**。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yuwzz7vj.png)", "inputFormat": "第一行包含 $4$ 个整数 $n，k，x，y$ 分别表示小屋的墙角数、最多反射的次数以及牧羊女的坐标（牧羊女所在位置保证在屋内且至少离墙 $1$ 个单位）。以下 $n$ 行每行两个整数 $x, y$，表示第 $i$ 个墙角的坐标。墙角按照**顺时针或逆时针**排列。", "outputFormat": "输出文件仅包含一个实数 $L$，表示能听到歌声的墙的总长度。保留两位小数。", "hint": "#### 评分方法\n\n选手输出和参考输出差的绝对值不大于 $0.02$ 时该测试点满分，相差超过 $0.02$ 但不超过 $1$ 时该测试点得 $50\\%$ 的分数。在样例$1$中，答案为 $469.84$ 和 $469.88$ 都能拿满分，$468.86$ 和 $470.86$ 都能拿 $50\\%$ 的分数。\n\n#### 约定\n\n$3\\leq n\\leq 50$，$0\\leq k\\leq 5$，所有坐标为绝对值不超过 $1000$ 的整数。\n\n$50\\%$ 的数据满足 $k≤1$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2005] The Lonely Shepherd Girl", "background": "", "description": "In Dalarna, Sweden, there is a high mountain. On the mountain there is a small cabin, where a shepherd girl lives. Every morning, a melodious flute sound comes from the neighboring mountain, and the shepherd girl responds from inside the cabin with her singing.\n\nThe top view of the cabin is a simple polygon with $n$ vertices. Each wall can reflect sound, but due to unavoidable energy loss, the sound can be reflected at most $k$ times ($k=0$ means sound cannot be reflected). The walls are very smooth, so the reflection follows the law that the angle of reflection equals the angle of incidence, as shown in Figure $1$. Corners cannot reflect sound, but every other part of a wall—even very close to a corner—can reflect sound.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wcjsrg80.png)\n\nOne day, the shepherd girl asked herself: at which places in the cabin can her singing be heard? Assume all listeners sit inside the cabin with their backs against the walls. Then what is the total length of the walls that her singing can reach?\n\nThe four diagrams in Figure $2$ show the initial situation and the regions reached after $0$, $1$, and $2$ reflections. The gray part indicates the area where the singing can be heard, and the black dot indicates the shepherd girl’s position. What you need to compute is the **total length** of the gray part on the polygon boundary.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yuwzz7vj.png)", "inputFormat": "The first line contains $4$ integers $n, k, x, y$, representing the number of corners of the cabin, the maximum number of reflections, and the shepherd girl’s coordinates (her position is guaranteed to be inside the cabin and at least $1$ unit away from the walls). The next $n$ lines each contain two integers $x, y$, giving the coordinates of the $i$-th corner. The corners are listed in **clockwise or counterclockwise** order.", "outputFormat": "The output contains only one real number $L$, representing the total length of walls that can hear the singing. Print it with two decimal places.", "hint": "#### Scoring\n\nA test point gets full score if the absolute difference between your output and the reference output is not greater than $0.02$. If the difference is greater than $0.02$ but not greater than $1$, then the test point gets $50\\%$ of the score. In Sample $1$, answers $469.84$ and $469.88$ both get full score, while $468.86$ and $470.86$ both get $50\\%$ of the score.\n\n#### Notes\n\n$3\\leq n\\leq 50$, $0\\leq k\\leq 5$, and all coordinates are integers with absolute value not exceeding $1000$.\n\n$50\\%$ of the testdata satisfies $k\\leq 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2005] 孤独的牧羊女", "background": "", "description": "在瑞典的达拉纳洲有一座高山。山上有一个小屋，里面住着一位牧羊女。每天清晨，隔壁的山头会传来一阵悠扬的长笛声，而牧羊女则会站在屋里用自己的歌声回应。\n\n小屋的俯视图是一个有 $n$ 个顶点的简单多边形，每一面墙可以反射声音，但是由于不可避免的能量损失，最多只能反射 $k$ 次（$k=0$ 表示不能反射声音）。墙面非常光滑，因此声音的反射遵循反射角等于入射角，如图 $1$。墙角不能反射声音，而每面墙的其他部分——即使离墙角很近——都可以反射声音。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/wcjsrg80.png)\n\n突然有一天，牧羊女问自己：在小屋的哪些地方能听到她的歌声？假设所有听众都在屋里靠墙而坐，那么歌声能到达的墙一共有多长？\n图 $2$ 的四幅示意图分别画出了初始情况和声音经过 $0$、$1$、$2$ 次反射后到达的区域。灰色部分表示能听到歌声的部分，黑点表示牧羊女的位置。本题所求即灰色部分在多边形边界上的**总长度**。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/yuwzz7vj.png)", "inputFormat": "第一行包含 $4$ 个整数 $n，k，x，y$ 分别表示小屋的墙角数、最多反射的次数以及牧羊女的坐标（牧羊女所在位置保证在屋内且至少离墙 $1$ 个单位）。以下 $n$ 行每行两个整数 $x, y$，表示第 $i$ 个墙角的坐标。墙角按照**顺时针或逆时针**排列。", "outputFormat": "输出文件仅包含一个实数 $L$，表示能听到歌声的墙的总长度。保留两位小数。", "hint": "#### 评分方法\n\n选手输出和参考输出差的绝对值不大于 $0.02$ 时该测试点满分，相差超过 $0.02$ 但不超过 $1$ 时该测试点得 $50\\%$ 的分数。在样例$1$中，答案为 $469.84$ 和 $469.88$ 都能拿满分，$468.86$ 和 $470.86$ 都能拿 $50\\%$ 的分数。\n\n#### 约定\n\n$3\\leq n\\leq 50$，$0\\leq k\\leq 5$，所有坐标为绝对值不超过 $1000$ 的整数。\n\n$50\\%$ 的数据满足 $k≤1$。", "locale": "zh-CN"}}}
{"pid": "P5793", "type": "P", "difficulty": 0, "samples": [["7 2\n7\n1\n7\n7\n7\n1\n2\n2 1 2\n3 2 4\n6 5 2\n7 5 9\n5 1 3\n4 1 7", "30\n2"]], "limits": {"time": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2004", "CTSC/CTS"], "title": "[CTSC2004] 网络改造", "background": "HURRICANE 小组原来构建的网络由网络上的交换机及其间的网路构成。交换机分级连接，最高级的为顶级的网关交换机，其他交换机分级相连到该网关交换机上。但值得注意的是，任一台非网关交换机与一台高一级的交换机直接相连。而任一台交换机均可以与几台低一级的交换机直接相连。\n\n但最近，由于原来架设的网络服务有限，需要把网络中的一些交换机（包括网关交换机）升级为核心交换机。由于改造的时间所限，只来得及把不超过 $p$ 台（含 $p$ 台）交换机升级为核心交换机，而所有剩下的交换机则需要通过改造网路的方法和这几台核心交换机直接连接。\n\n但是无论是升级交换机还是改造网络都需要花费一定的资金。现在请你给出一个改造网络的方案。使得按照该方案升级后每一个交换机要么是核心交换机，要么直接和核心交换机相连。并且要求提供的方案使改造所用的总费用最小。", "description": "你的程序必须根据给定的输入，给出符合题意的输出：\n\n+ 输入包括网络的拓扑结构，升级网络中每台交换机的费用，以及改造网络的费用，还有可以升级的交换机的最大数目 $p$；\n+ 你必须根据输入，找出一个升级的方案，满足升级后的核心交换机的数目不超过给定的可升级交换机最大值 $p$，且使得总费用最少；\n+ 其中总费用的计算包括两个部分:\n    - 一部分是升级交换机为核心交换机所需要的费用，该部分的费用按照所有的需要升级的交换机所需的费用之和来计算；\n    - 另一部分是改造网络所需要的费用，该部分的费用按照所有未升级的交换机到最近的核心交换机的网络路径距离之和来计算；\n    - **注意:** 当网络中没有任何交换机升级到核心交换机的时候，由于也没有交换机可以连接到核心交换机，所以我们定义此时的总费用为无穷大。", "inputFormat": "第一行为两个正整数 $n(n \\leq 400)$ 和 $p$，分别表示网络中交换机的数目（交换机按照 $1$ 到 $n$ 标号）和可升级交换机的最大值。接下来的 $n$ 行每行一个正整数 $c_i$，表示把标号为 $i$ 的交换机升级为核心交换机所需要的费用。\n\n接下来的 $n-1$ 行每行三个正整数 $i$、$j$、$d_{i,j}(d_{i,j}<20000)$，表示编号为 $j$ 的交换机为编号为 $i$ 的交换机的上层交换机，而 $d_{i,j}$ 表示两台交换机之间的网路距离。", "outputFormat": "你的输出第一行为一个整数 $M$，表示你的方案的最小总费用。接下来一行包括一个整数 $p_0$，表示你的方案所需要升级为核心交换机的交换机数目。", "hint": "#### 样例说明\n![](https://cdn.luogu.com.cn/upload/image_hosting/74nd663j.png)\n\n#### 评分方法\n本题目一共有十个测试点，每个测试点的分数为总分数的 $10\\%$。对于每个测试点来说，如果你的答案正确，那么你将得到该测试点全部的分数，否则得 $0$ 分。\n\n注意，本题目的测试数据中有 $8$ 个数据的 $n$ 不超过 $180$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC2004] Network Reconstruction.", "background": "The network originally built by the HURRICANE group consists of switches and the links between them. The switches are connected in levels. The highest one is the top gateway switch, and all other switches are connected to this gateway switch level by level. Note that any non-gateway switch is directly connected to exactly one switch at the next higher level, while any switch may be directly connected to several switches at the next lower level.\n\nRecently, because the original network services are limited, some switches in the network (including the gateway switch) need to be upgraded to core switches. Due to limited time, at most $p$ switches (including $p$) can be upgraded to core switches, and all remaining switches must be directly connected to these core switches by reconstructing the network links.\n\nHowever, both upgrading switches and reconstructing links cost money. Please provide a reconstruction plan such that after the upgrade, every switch is either a core switch or is directly connected to a core switch, and the total cost of reconstruction is minimized.", "description": "Your program must produce output that satisfies the requirements based on the given input:\n\n- The input includes the network topology, the cost to upgrade each switch in the network, the cost to reconstruct links, and the maximum number $p$ of switches that can be upgraded.\n- Based on the input, you must find an upgrade plan such that the number of core switches after upgrading does not exceed the given maximum $p$, and the total cost is minimized.\n- The total cost consists of two parts:\n  - One part is the cost required to upgrade switches to core switches, which is the sum of the upgrade costs of all switches that are upgraded.\n  - The other part is the cost required to reconstruct the network, which is the sum of the network path distances from every non-upgraded switch to its nearest core switch.\n  - **Note:** If no switch in the network is upgraded to a core switch, since no switch can be connected to a core switch, we define the total cost in this case to be infinity.", "inputFormat": "The first line contains two positive integers $n(n \\leq 400)$ and $p$, representing the number of switches in the network (switches are numbered from $1$ to $n$) and the maximum number of switches that can be upgraded.\n\nThe next $n$ lines each contain a positive integer $c_i$, representing the cost to upgrade switch $i$ to a core switch.\n\nThe next $n-1$ lines each contain three positive integers $i$, $j$, and $d_{i,j}(d_{i,j}<20000)$, indicating that switch $j$ is an upper-level switch of switch $i$, and $d_{i,j}$ is the network distance between the two switches.", "outputFormat": "The first line of output contains an integer $M$, representing the minimum total cost of your plan.\n\nThe next line contains an integer $p_0$, representing the number of switches that need to be upgraded to core switches in your plan.", "hint": "#### Sample Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/74nd663j.png)\n\n#### Scoring Method\n\nThere are ten test points in this problem, and each test point is worth $10\\%$ of the total score. For each test point, if your answer is correct, you will get the full score for that test point; otherwise, you will get $0$ points.\n\nNote that in the testdata of this problem, there are $8$ cases where $n$ does not exceed $180$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC2004] 网络改造", "background": "HURRICANE 小组原来构建的网络由网络上的交换机及其间的网路构成。交换机分级连接，最高级的为顶级的网关交换机，其他交换机分级相连到该网关交换机上。但值得注意的是，任一台非网关交换机与一台高一级的交换机直接相连。而任一台交换机均可以与几台低一级的交换机直接相连。\n\n但最近，由于原来架设的网络服务有限，需要把网络中的一些交换机（包括网关交换机）升级为核心交换机。由于改造的时间所限，只来得及把不超过 $p$ 台（含 $p$ 台）交换机升级为核心交换机，而所有剩下的交换机则需要通过改造网路的方法和这几台核心交换机直接连接。\n\n但是无论是升级交换机还是改造网络都需要花费一定的资金。现在请你给出一个改造网络的方案。使得按照该方案升级后每一个交换机要么是核心交换机，要么直接和核心交换机相连。并且要求提供的方案使改造所用的总费用最小。", "description": "你的程序必须根据给定的输入，给出符合题意的输出：\n\n+ 输入包括网络的拓扑结构，升级网络中每台交换机的费用，以及改造网络的费用，还有可以升级的交换机的最大数目 $p$；\n+ 你必须根据输入，找出一个升级的方案，满足升级后的核心交换机的数目不超过给定的可升级交换机最大值 $p$，且使得总费用最少；\n+ 其中总费用的计算包括两个部分:\n    - 一部分是升级交换机为核心交换机所需要的费用，该部分的费用按照所有的需要升级的交换机所需的费用之和来计算；\n    - 另一部分是改造网络所需要的费用，该部分的费用按照所有未升级的交换机到最近的核心交换机的网络路径距离之和来计算；\n    - **注意:** 当网络中没有任何交换机升级到核心交换机的时候，由于也没有交换机可以连接到核心交换机，所以我们定义此时的总费用为无穷大。", "inputFormat": "第一行为两个正整数 $n(n \\leq 400)$ 和 $p$，分别表示网络中交换机的数目（交换机按照 $1$ 到 $n$ 标号）和可升级交换机的最大值。接下来的 $n$ 行每行一个正整数 $c_i$，表示把标号为 $i$ 的交换机升级为核心交换机所需要的费用。\n\n接下来的 $n-1$ 行每行三个正整数 $i$、$j$、$d_{i,j}(d_{i,j}<20000)$，表示编号为 $j$ 的交换机为编号为 $i$ 的交换机的上层交换机，而 $d_{i,j}$ 表示两台交换机之间的网路距离。", "outputFormat": "你的输出第一行为一个整数 $M$，表示你的方案的最小总费用。接下来一行包括一个整数 $p_0$，表示你的方案所需要升级为核心交换机的交换机数目。", "hint": "#### 样例说明\n![](https://cdn.luogu.com.cn/upload/image_hosting/74nd663j.png)\n\n#### 评分方法\n本题目一共有十个测试点，每个测试点的分数为总分数的 $10\\%$。对于每个测试点来说，如果你的答案正确，那么你将得到该测试点全部的分数，否则得 $0$ 分。\n\n注意，本题目的测试数据中有 $8$ 个数据的 $n$ 不超过 $180$。", "locale": "zh-CN"}}}
{"pid": "P5794", "type": "P", "difficulty": 5, "samples": [["6 3\n1 1 1 3 0 1 2", "1 2 3 1 1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "THUSC"], "title": "[THUSC 2015] 解密运算", "background": "", "description": "对于一个长度为 $N$ 的字符串，我们在字符串的末尾添加一个特殊的字符 `.`。之后将字符串视为一个环，从位置 $1,2,3,...,N+1$ 为起点读出 $N+1$ 个字符，就能得到 $N+1$ 个字符串。\n\n比如对于字符串 `ABCAAA`，我们可以得到这 $N+1$ 个串：\n```plain\nABCAAA.\nBCAAA.A\nCAAA.AB\nAAA.ABC\nAA.ABCA\nA.ABCAA\n.ABCAAA\n```\n接着我们对得到的这 $N+1$ 个串按字典序从小到大进行排序（注意特殊字符 `.` 的字典序小于任何其他的字符）结果如下：\n```plain\n.ABCAAA\nA.ABCAA\nAA.ABCA\nAAA.ABC\nABCAAA.\nBCAAA.A\nCAAA.AB\n```\n最后，将排序好的 $N+1$ 个串的最后一个字符取出，按照顺序排成一个新的字符串，也就是上面这个表的最后一列，就是加密后的密文 `AAAC.AB`。\n\n请通过加密后的密文求出加密前的字符串。", "inputFormat": "第一行有两个整数 $N,M$，分别表示加密前的字符串长度和字符集大小，其中字符用整数 $1,2,3,...,M$ 编号，添加的特殊字符 `.` 用 $0$ 编号。\n\n第二行为 $N+1$ 个整数，表示加密后的字符串。", "outputFormat": "输出仅一行，包含 $N$ 个整数，用空格隔开，依次表示加密前字符串中每个字符的编号。", "hint": "对于第 $i$ 个测试点 ($i=1 \\sim 4$)，$N=5\\times (i+1),M\\leq 3$。\n\n对于第 $5\\sim 6$ 个测试点，$N,M\\leq 50$，字符串中字符互不相同。\n\n对于第 $7\\sim 8$ 个测试点，$N,M\\leq 1000$，字符串中字符互不相同。\n\n对于第 $9\\sim 12$ 个测试点，$N,M\\leq 1000$。\n\n对于第 $13\\sim 20$ 个测试点，$N,M\\leq 200000$。", "locale": "zh-CN", "translations": {"en": {"title": "[THUSC 2015] Decryption Operation", "background": "", "description": "For a string of length $N$, we append a special character `.` to the end of the string. Then we treat the string as a cycle. Starting from positions $1,2,3,\\ldots,N+1$, read $N+1$ characters each time, and we can obtain $N+1$ strings.\n\nFor example, for the string `ABCAAA`, we can get these $N+1$ strings:\n```plain\nABCAAA.\nBCAAA.A\nCAAA.AB\nAAA.ABC\nAA.ABCA\nA.ABCAA\n.ABCAAA\n```\nNext, we sort these $N+1$ strings in lexicographical order from small to large (note that the special character `.` is lexicographically smaller than any other character). The result is:\n```plain\n.ABCAAA\nA.ABCAA\nAA.ABCA\nAAA.ABC\nABCAAA.\nBCAAA.A\nCAAA.AB\n```\nFinally, take the last character of each of the sorted $N+1$ strings, and concatenate them in order into a new string. That is, the last column of the table above, which is the encrypted ciphertext `AAAC.AB`.\n\nPlease recover the string before encryption from the encrypted ciphertext.", "inputFormat": "The first line contains two integers $N,M$, representing the length of the string before encryption and the size of the character set. The characters are numbered by integers $1,2,3,\\ldots,M$, and the appended special character `.` is numbered by $0$.\n\nThe second line contains $N+1$ integers, representing the encrypted string.", "outputFormat": "Output a single line containing $N$ integers separated by spaces, representing the number of each character in the original string before encryption in order.", "hint": "For the $i$-th test point ($i=1 \\sim 4$), $N=5\\times (i+1),M\\leq 3$.\n\nFor test points $5\\sim 6$, $N,M\\leq 50$, and all characters in the string are distinct.\n\nFor test points $7\\sim 8$, $N,M\\leq 1000$, and all characters in the string are distinct.\n\nFor test points $9\\sim 12$, $N,M\\leq 1000$.\n\nFor test points $13\\sim 20$, $N,M\\leq 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[THUSC 2015] 解密运算", "background": "", "description": "对于一个长度为 $N$ 的字符串，我们在字符串的末尾添加一个特殊的字符 `.`。之后将字符串视为一个环，从位置 $1,2,3,...,N+1$ 为起点读出 $N+1$ 个字符，就能得到 $N+1$ 个字符串。\n\n比如对于字符串 `ABCAAA`，我们可以得到这 $N+1$ 个串：\n```plain\nABCAAA.\nBCAAA.A\nCAAA.AB\nAAA.ABC\nAA.ABCA\nA.ABCAA\n.ABCAAA\n```\n接着我们对得到的这 $N+1$ 个串按字典序从小到大进行排序（注意特殊字符 `.` 的字典序小于任何其他的字符）结果如下：\n```plain\n.ABCAAA\nA.ABCAA\nAA.ABCA\nAAA.ABC\nABCAAA.\nBCAAA.A\nCAAA.AB\n```\n最后，将排序好的 $N+1$ 个串的最后一个字符取出，按照顺序排成一个新的字符串，也就是上面这个表的最后一列，就是加密后的密文 `AAAC.AB`。\n\n请通过加密后的密文求出加密前的字符串。", "inputFormat": "第一行有两个整数 $N,M$，分别表示加密前的字符串长度和字符集大小，其中字符用整数 $1,2,3,...,M$ 编号，添加的特殊字符 `.` 用 $0$ 编号。\n\n第二行为 $N+1$ 个整数，表示加密后的字符串。", "outputFormat": "输出仅一行，包含 $N$ 个整数，用空格隔开，依次表示加密前字符串中每个字符的编号。", "hint": "对于第 $i$ 个测试点 ($i=1 \\sim 4$)，$N=5\\times (i+1),M\\leq 3$。\n\n对于第 $5\\sim 6$ 个测试点，$N,M\\leq 50$，字符串中字符互不相同。\n\n对于第 $7\\sim 8$ 个测试点，$N,M\\leq 1000$，字符串中字符互不相同。\n\n对于第 $9\\sim 12$ 个测试点，$N,M\\leq 1000$。\n\n对于第 $13\\sim 20$ 个测试点，$N,M\\leq 200000$。", "locale": "zh-CN"}}}
{"pid": "P5795", "type": "P", "difficulty": 6, "samples": [["3 3\n1 2 4\n7 6 5\n3\n1 2 1 2 2\n1 2 1 3 4\n2 3 2 3 4", "6\n5\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "THUSC"], "title": "[THUSC 2015] 异或运算", "background": "", "description": "给定长度为 $n$ 的数列 $X={x_1,x_2,...,x_n}$ 和长度为 $m$ 的数列 $Y={y_1,y_2,...,y_m}$，令矩阵 $A$ 中第 $i$ 行第 $j$ 列的值 $A_{i,j}=x_i\\ \\operatorname{xor}\\ y_j$，每次询问给定矩形区域 $i∈[u,d],j∈[l,r]$，找出第 $k$ 大的 $A_{i,j}$。", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示两个数列的长度。\n\n第二行包含 $n$ 个非负整数 $x_i$。\n\n第三行包含 $m$ 个非负整数 $y_j$。\n\n第四行包含一个正整数 $p$，表示询问次数。\n\n随后 $p$ 行，每行均包含 $5$ 个正整数，用来描述一次询问，每行包含五个正整数 $u,d,l,r,k$，含义如题意所述。", "outputFormat": "共 $p$ 行，每行包含一个非负整数，表示此次询问的答案。", "hint": "对于 $100\\%$ 的数据\n\n- $0\\leq X_i,Y_j<2^{31}$,\n- $1\\leq u\\leq d\\leq n\\leq 1000$,\n- $1\\leq l\\leq r\\leq m\\leq 300000$,\n- $1\\leq k\\leq (d-u+1)\\times (r-l+1)$, $1\\leq p\\leq 500$。", "locale": "zh-CN", "translations": {"en": {"title": "[THUSC 2015] XOR Operation", "background": "", "description": "Given a sequence $X=\\{x_1,x_2,\\ldots,x_n\\}$ of length $n$ and a sequence $Y=\\{y_1,y_2,\\ldots,y_m\\}$ of length $m$, define a matrix $A$ where the value in row $i$ and column $j$ is $A_{i,j}=x_i\\ \\operatorname{xor}\\ y_j$.  \n\nFor each query, you are given a rectangular region $i\\in[u,d],\\, j\\in[l,r]$. Find the $k$-th largest value among all $A_{i,j}$ in this region.", "inputFormat": "The first line contains two positive integers $n,m$, representing the lengths of the two sequences.\n\nThe second line contains $n$ non-negative integers $x_i$.\n\nThe third line contains $m$ non-negative integers $y_j$.\n\nThe fourth line contains a positive integer $p$, representing the number of queries.\n\nThe next $p$ lines each contain five positive integers $u,d,l,r,k$, describing one query. The meanings are as stated above.", "outputFormat": "Output $p$ lines. Each line contains one non-negative integer, the answer to the corresponding query.", "hint": "For $100\\%$ of the data:\n\n- $0\\leq X_i,Y_j<2^{31}$.\n- $1\\leq u\\leq d\\leq n\\leq 1000$.\n- $1\\leq l\\leq r\\leq m\\leq 300000$.\n- $1\\leq k\\leq (d-u+1)\\times (r-l+1)$, $1\\leq p\\leq 500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[THUSC 2015] 异或运算", "background": "", "description": "给定长度为 $n$ 的数列 $X={x_1,x_2,...,x_n}$ 和长度为 $m$ 的数列 $Y={y_1,y_2,...,y_m}$，令矩阵 $A$ 中第 $i$ 行第 $j$ 列的值 $A_{i,j}=x_i\\ \\operatorname{xor}\\ y_j$，每次询问给定矩形区域 $i∈[u,d],j∈[l,r]$，找出第 $k$ 大的 $A_{i,j}$。", "inputFormat": "第一行包含两个正整数 $n,m$，分别表示两个数列的长度。\n\n第二行包含 $n$ 个非负整数 $x_i$。\n\n第三行包含 $m$ 个非负整数 $y_j$。\n\n第四行包含一个正整数 $p$，表示询问次数。\n\n随后 $p$ 行，每行均包含 $5$ 个正整数，用来描述一次询问，每行包含五个正整数 $u,d,l,r,k$，含义如题意所述。", "outputFormat": "共 $p$ 行，每行包含一个非负整数，表示此次询问的答案。", "hint": "对于 $100\\%$ 的数据\n\n- $0\\leq X_i,Y_j<2^{31}$,\n- $1\\leq u\\leq d\\leq n\\leq 1000$,\n- $1\\leq l\\leq r\\leq m\\leq 300000$,\n- $1\\leq k\\leq (d-u+1)\\times (r-l+1)$, $1\\leq p\\leq 500$。", "locale": "zh-CN"}}}
{"pid": "P5796", "type": "P", "difficulty": 6, "samples": [["5 1\n1 2\n2 4\n3 4\n5 1\n5 3\n1 1", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2006", "重庆", "各省省选"], "title": "[CQOI2006] 移动棋子", "background": "", "description": "在一个 $n\\times n$ 的棋盘上有 $n$ 枚棋子。每次可以把一枚棋子往上、下、左、右方向之一移动一格，最后排成一行、一列或者主、副对角线上（因此一共有 $2n+2$ 条可能的目标状态），要求移动次数最小。\n\n棋盘上有一些位置是障碍，棋子在任何时候都不能经过。棋子的初始位置保证不在障碍物上。任两枚棋子不能在同时到达同一个格子。\n　　　　　　", "inputFormat": "第一行包含两个整数 $n$，$m$，表示棋子的个数（它也是棋盘的边长）和障碍的个数。\n\n以下 $n$ 行，每行两个整数 $x$ 和 $y$，表示第 $i$ 个棋子的坐标。（$1\\le x,y\\le n$）\n\n以下 $m$ 行，每行给出一个障碍物的坐标。保证这 $n+m$ 个坐标两两不重合。", "outputFormat": "输出仅包含一个整数，表示最小移动步数。如果无解，输出`-1`。", "hint": "【样例解释】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qs93n3f7.png)\n\n【数据范围】\n\n对于 $50\\%$ 的数据，$n\\le 15$，$m=0$；\n\n对于 $100\\%$ 的数据，$2\\le n\\le 50$，$0\\le m\\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[CQOI2006] Moving Pieces", "background": "", "description": "On an $n \\times n$ chessboard there are $n$ pieces. Each time, you may move one piece one step in one of the four directions: up, down, left, or right. In the end, the pieces must form a single row, a single column, or lie on the main diagonal or the anti-diagonal (so there are $2n + 2$ possible target states in total). Find the minimum number of moves.\n\nSome cells on the board are obstacles, and a piece can never pass through them at any time. The initial positions of the pieces are guaranteed not to be on obstacles. No two pieces may end up on the same cell at the same time.", "inputFormat": "The first line contains two integers $n$ and $m$, representing the number of pieces (which is also the side length of the board) and the number of obstacles.\n\nThe next $n$ lines each contain two integers $x$ and $y$, representing the coordinates of the $i$-th piece ($1 \\le x, y \\le n$).\n\nThe next $m$ lines each contain the coordinates of an obstacle. It is guaranteed that these $n + m$ coordinates are all distinct.", "outputFormat": "Output a single integer, the minimum number of moves. If there is no solution, output `-1`.", "hint": "[Sample Explanation]\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qs93n3f7.png)\n\n[Constraints]\n\nFor $50\\%$ of the testdata, $n \\le 15$ and $m = 0$.\n\nFor $100\\%$ of the testdata, $2 \\le n \\le 50$ and $0 \\le m \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CQOI2006] 移动棋子", "background": "", "description": "在一个 $n\\times n$ 的棋盘上有 $n$ 枚棋子。每次可以把一枚棋子往上、下、左、右方向之一移动一格，最后排成一行、一列或者主、副对角线上（因此一共有 $2n+2$ 条可能的目标状态），要求移动次数最小。\n\n棋盘上有一些位置是障碍，棋子在任何时候都不能经过。棋子的初始位置保证不在障碍物上。任两枚棋子不能在同时到达同一个格子。\n　　　　　　", "inputFormat": "第一行包含两个整数 $n$，$m$，表示棋子的个数（它也是棋盘的边长）和障碍的个数。\n\n以下 $n$ 行，每行两个整数 $x$ 和 $y$，表示第 $i$ 个棋子的坐标。（$1\\le x,y\\le n$）\n\n以下 $m$ 行，每行给出一个障碍物的坐标。保证这 $n+m$ 个坐标两两不重合。", "outputFormat": "输出仅包含一个整数，表示最小移动步数。如果无解，输出`-1`。", "hint": "【样例解释】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qs93n3f7.png)\n\n【数据范围】\n\n对于 $50\\%$ 的数据，$n\\le 15$，$m=0$；\n\n对于 $100\\%$ 的数据，$2\\le n\\le 50$，$0\\le m\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P5797", "type": "P", "difficulty": 6, "samples": [["7 5\n2 5 1 1 2 3 2", "5 5 7 -1 6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "线段树", "ICPC", "SEERC"], "title": "[SEERC 2019] Max or Min", "background": "", "description": "Kevin 有 $n$ 个整数 $a_1, a_2, \\dots, a_n$ ，它们按**环形**排列。对于环上的数字，数字 $a_i$ 和 $a_{i+1} \\ (1 \\leq i < n)$ 是相邻的，且数字 $a_1$ 和 $a_n$ 是相邻的。因此，每个数字有恰好两个相邻的数字。\n\n在 $1$ 分钟内，Kevin 可以将 $a_i$ 修改为这 $3$ 个数字中的最小值或最大值：$a_i$ 以及它的两个相邻数字。例如，如果 $a_i=5$ 且 $a_i$ 的两个相邻数字为 $3$ 和 $2$，Kevin 修改 $a_i$ 为最小值后，$a_i$ 会变为 $2$；如果 Kevin 修改 $a_i$ 为最大值，$a_i$ 仍是 $5$。\n\n对于从 $1$ 到 $m$ 的每个整数 $x$，计算出让上述环上的数字都变为 $x$ 的最短时间。", "inputFormat": "第一行包含两个整数 $n$ 和 $m \\ (3 \\leq n \\leq 2 \\cdot 10^5, 1 \\leq m \\leq 2 \\cdot 10^5)$，代表环上的数字个数和需要计算答案的 $x$ 的范围。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n \\ (1 \\leq a_i \\leq m)$，代表环上的数字。", "outputFormat": "输出 $m$ 个整数。第 $i$ 个整数为将环上的所有数字变为 $i$ 的最短时间的分钟数，如果无论如何都无法将环上的所有整数变为 $i$，则第 $i$ 个整数应输出 $-1$。", "hint": "要让环上的所有整数都变为 $2$，Kevin 需要至少 $5$ 分钟。一种可行的修改方案为：\n\n1. 将 $a_6$ 修改为它与相邻数字中的最小值，即修改为 $2$；\n2. 将 $a_4$ 修改为它与相邻数字中的最大值，即修改为 $2$；\n3. 将 $a_3$ 修改为它与相邻数字中的最大值，即修改为 $5$；\n4. 将 $a_2$ 修改为它与相邻数字中的最小值，即修改为 $2$；\n5. 将 $a_3$ 修改为它与相邻数字中的最小值，即修改为 $2$。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2019] Max or Min", "background": "", "description": "Kevin has $n$ integers $a_1, a_2, \\dots, a_n$, arranged in a **circular** order. On the circle, the numbers $a_i$ and $a_{i+1}$ $(1 \\leq i < n)$ are adjacent, and $a_1$ and $a_n$ are adjacent. Therefore, each number has exactly two adjacent numbers.\n\nIn 1 minute, Kevin can change $a_i$ to the minimum or the maximum among these three numbers: $a_i$ and its two adjacent numbers. For example, if $a_i = 5$ and its two adjacent numbers are $3$ and $2$, then after changing $a_i$ to the minimum, $a_i$ becomes $2$; if Kevin changes $a_i$ to the maximum, then $a_i$ is still $5$.\n\nFor each integer $x$ from $1$ to $m$, compute the shortest time to make all numbers on the circle become $x$.", "inputFormat": "The first line contains two integers $n$ and $m$ $(3 \\leq n \\leq 2 \\cdot 10^5, 1 \\leq m \\leq 2 \\cdot 10^5)$, representing the number of integers on the circle and the range of $x$ for which answers are required.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$ $(1 \\leq a_i \\leq m)$, representing the numbers on the circle.", "outputFormat": "Output $m$ integers. The $i$-th integer is the minimum number of minutes needed to make all numbers on the circle equal to $i$. If it is impossible to make all integers become $i$, output $-1$ for the $i$-th integer.", "hint": "To make all integers on the circle become $2$, Kevin needs at least $5$ minutes. One feasible sequence of operations is:\n\n1. Change $a_6$ to the minimum among it and its adjacent numbers, i.e., change it to $2$.\n2. Change $a_4$ to the maximum among it and its adjacent numbers, i.e., change it to $2$.\n3. Change $a_3$ to the maximum among it and its adjacent numbers, i.e., change it to $5$.\n4. Change $a_2$ to the minimum among it and its adjacent numbers, i.e., change it to $2$.\n5. Change $a_3$ to the minimum among it and its adjacent numbers, i.e., change it to $2$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2019] Max or Min", "background": "", "description": "Kevin 有 $n$ 个整数 $a_1, a_2, \\dots, a_n$ ，它们按**环形**排列。对于环上的数字，数字 $a_i$ 和 $a_{i+1} \\ (1 \\leq i < n)$ 是相邻的，且数字 $a_1$ 和 $a_n$ 是相邻的。因此，每个数字有恰好两个相邻的数字。\n\n在 $1$ 分钟内，Kevin 可以将 $a_i$ 修改为这 $3$ 个数字中的最小值或最大值：$a_i$ 以及它的两个相邻数字。例如，如果 $a_i=5$ 且 $a_i$ 的两个相邻数字为 $3$ 和 $2$，Kevin 修改 $a_i$ 为最小值后，$a_i$ 会变为 $2$；如果 Kevin 修改 $a_i$ 为最大值，$a_i$ 仍是 $5$。\n\n对于从 $1$ 到 $m$ 的每个整数 $x$，计算出让上述环上的数字都变为 $x$ 的最短时间。", "inputFormat": "第一行包含两个整数 $n$ 和 $m \\ (3 \\leq n \\leq 2 \\cdot 10^5, 1 \\leq m \\leq 2 \\cdot 10^5)$，代表环上的数字个数和需要计算答案的 $x$ 的范围。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n \\ (1 \\leq a_i \\leq m)$，代表环上的数字。", "outputFormat": "输出 $m$ 个整数。第 $i$ 个整数为将环上的所有数字变为 $i$ 的最短时间的分钟数，如果无论如何都无法将环上的所有整数变为 $i$，则第 $i$ 个整数应输出 $-1$。", "hint": "要让环上的所有整数都变为 $2$，Kevin 需要至少 $5$ 分钟。一种可行的修改方案为：\n\n1. 将 $a_6$ 修改为它与相邻数字中的最小值，即修改为 $2$；\n2. 将 $a_4$ 修改为它与相邻数字中的最大值，即修改为 $2$；\n3. 将 $a_3$ 修改为它与相邻数字中的最大值，即修改为 $5$；\n4. 将 $a_2$ 修改为它与相邻数字中的最小值，即修改为 $2$；\n5. 将 $a_3$ 修改为它与相邻数字中的最小值，即修改为 $2$。", "locale": "zh-CN"}}}
{"pid": "P5798", "type": "P", "difficulty": 5, "samples": [["2 100 100\n100 100 10 10\n101 11 100 10", "110"], ["4 20 20\n40 1000 20 20\n6 6 5 5\n10 10 1 1\n10 10 1 1", "40"], ["2 20 5\n10 10 5 5\n10 10 5 5", "-1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["动态规划 DP", "2019", "ICPC", "SEERC"], "title": "[SEERC 2019] Level Up", "background": "", "description": "作为一个 MMORPG 粉，得知《魔兽世界：经典旧世》发布的 Steve 非常兴奋。他从发布的第一天就开始玩，现在离满级只差 $2$ 级了。当然，他现在没有刚开始玩那时那么有空，因此他想尽快升到满级。\n\n升第一个等级需要 $s_1$ 经验值。只有当他获得了这么多经验后，才能升到下一级，而第二个等级又需要 $s_2$ 经验值来升级。\n\nSteve 有一个有 $n$ 个任务的任务列表。他希望通过完成一些任务来升到满级。Steve 需要花 $t_i$ 分钟才能完成第 $i$ 个任务，这个任务会让他获得 $x_i$ 经验值。\n\n当 Steve 完成了一个任务后可以升级了，超过升级所需的那部分经验值将会计入下一等级。当他升了一级之后，第 $i$ 个任务可获得的经验值会减少为 $y_i$，而完成任务的时间也会减为 $r_i$。\n\n需要注意的是，Steve 完成了的任务**不能**重复接取，无论是否升级。\n\n已知任务列表中的任务信息，帮助 Steve 找出一个完成任务的顺序，使得他升到满级所需的时间最短。", "inputFormat": "第一行包含三个整数 $n, s_1, s_2 \\ (1 \\leq n, s_1, s_2 \\leq 500)$，代表任务的数量、升第一级所需的经验值和升第二级所需的经验值。 \n\n接下来的 $n$ 行每行包含四个整数 $x_i, t_i, y_i, r_i \\ (1 \\leq y_i < x_i \\leq 500, 1 \\leq r_i < t_i \\leq 10^9)$，代表第 $i$ 个任务获得的经验值、完成所需的时间、升一级之后获得的经验值和完成所需的时间。", "outputFormat": "输出一个整数，代表 Steve 升到满级所需的最短时间的分钟数，如果无论如何都无法升到满级，输出 $-1$。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2019] Level Up", "background": "", "description": "As an MMORPG fan, Steve was very excited to hear that *World of Warcraft: Classic* was released. He started playing on the first day of release, and now he is only $2$ levels away from reaching the maximum level. Of course, he does not have as much free time as when he first started, so he wants to reach the maximum level as quickly as possible.\n\nTo gain the first level, he needs $s_1$ experience points. Only after he has obtained that much experience can he level up, and the second level then requires another $s_2$ experience points to level up.\n\nSteve has a quest list with $n$ quests. He wants to reach the maximum level by completing some of these quests. Steve needs $t_i$ minutes to complete quest $i$, and this quest gives him $x_i$ experience points.\n\nWhen Steve completes a quest and can level up, any experience beyond what is required to level up will carry over to the next level. After he levels up once, the experience gained from quest $i$ decreases to $y_i$, and the time needed to complete it also decreases to $r_i$.\n\nNote that quests Steve has completed **cannot** be taken again, regardless of whether he has leveled up.\n\nGiven the information of the quests in the list, help Steve find an order of completing quests such that the total time needed to reach the maximum level is minimized.", "inputFormat": "The first line contains three integers $n, s_1, s_2 \\ (1 \\leq n, s_1, s_2 \\leq 500)$, representing the number of quests, the experience required to gain the first level, and the experience required to gain the second level.\n\nThe next $n$ lines each contain four integers $x_i, t_i, y_i, r_i \\ (1 \\leq y_i < x_i \\leq 500, 1 \\leq r_i < t_i \\leq 10^9)$, representing the experience gained from quest $i$, the time needed to complete it, the experience gained after leveling up once, and the time needed after leveling up once.", "outputFormat": "Output one integer, the minimum number of minutes Steve needs to reach the maximum level. If it is impossible to reach the maximum level no matter what, output $-1$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2019] Level Up", "background": "", "description": "作为一个 MMORPG 粉，得知《魔兽世界：经典旧世》发布的 Steve 非常兴奋。他从发布的第一天就开始玩，现在离满级只差 $2$ 级了。当然，他现在没有刚开始玩那时那么有空，因此他想尽快升到满级。\n\n升第一个等级需要 $s_1$ 经验值。只有当他获得了这么多经验后，才能升到下一级，而第二个等级又需要 $s_2$ 经验值来升级。\n\nSteve 有一个有 $n$ 个任务的任务列表。他希望通过完成一些任务来升到满级。Steve 需要花 $t_i$ 分钟才能完成第 $i$ 个任务，这个任务会让他获得 $x_i$ 经验值。\n\n当 Steve 完成了一个任务后可以升级了，超过升级所需的那部分经验值将会计入下一等级。当他升了一级之后，第 $i$ 个任务可获得的经验值会减少为 $y_i$，而完成任务的时间也会减为 $r_i$。\n\n需要注意的是，Steve 完成了的任务**不能**重复接取，无论是否升级。\n\n已知任务列表中的任务信息，帮助 Steve 找出一个完成任务的顺序，使得他升到满级所需的时间最短。", "inputFormat": "第一行包含三个整数 $n, s_1, s_2 \\ (1 \\leq n, s_1, s_2 \\leq 500)$，代表任务的数量、升第一级所需的经验值和升第二级所需的经验值。 \n\n接下来的 $n$ 行每行包含四个整数 $x_i, t_i, y_i, r_i \\ (1 \\leq y_i < x_i \\leq 500, 1 \\leq r_i < t_i \\leq 10^9)$，代表第 $i$ 个任务获得的经验值、完成所需的时间、升一级之后获得的经验值和完成所需的时间。", "outputFormat": "输出一个整数，代表 Steve 升到满级所需的最短时间的分钟数，如果无论如何都无法升到满级，输出 $-1$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5799", "type": "P", "difficulty": 4, "samples": [["cbbabcacbb", "YES\nabbabcbccb"], ["aa", "NO"], ["afedbc", "YES\nafedbc"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["字符串", "2019", "Special Judge", "构造", "ICPC", "SEERC"], "title": "[SEERC 2019] Cycle String?", "background": "", "description": "大法师给了 Alice 和 Bob 一个长度为 $2 \\cdot n$ 的环形字符串，这个环形字符串中没有重复的长为 $n$ 的子串。在一个环形字符串中，字符 $s_{i+1}$ 在 $s_i$之后，而 $s_1$ 在 $s_{2n}$ 之后。\n\n不幸的是，恶魔打乱了字符串中字符的顺序。帮助 Alice 和 Bob 将字符串还原成满足上述要求的原始字符串。", "inputFormat": "第一行包含一个长度为 $2 \\cdot n \\ (2 \\leq 2\\cdot n \\leq 1 \\ 000 \\ 000)$ 的字符串 $s$，字符串中只包含小写字母。", "outputFormat": "如果能够将字符串还原成满足要求的字符串，则在第一行输出 `NO`；如果无法还原，则在第一行输出 `YES`。\n\n如果有解，在第二行输出还原后的字符串。如果存在多解，输出任意一个即可。", "hint": "第一个样例中，还原后的字符串中的子串分别为：`abbab`、`bbabc`、`babcb`、`abcbc`、`bcbcc`、`cbccb`、`bccba`、`ccbab`、`babba`。\n\n注意到第一个样例的答案中并不含有重复的子串，但存在其他的答案也满足题目要求。因此答案不唯一，样例只提供了一种满足要求的输出。\n\n第二个样例中，无法将字符串还原为满足要求的原始字符串。\n\n第三个样例中，不需要做任何操作即满足要求。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2019] Cycle String?", "background": "", "description": "The Archmage gave Alice and Bob a cyclic string of length $2 \\cdot n$. In this cyclic string, there are no repeated substrings of length $n$. In a cyclic string, the character $s_{i+1}$ comes after $s_i$, and $s_1$ comes after $s_{2n}$.\n\nUnfortunately, the devil scrambled the order of the characters in the string. Help Alice and Bob restore the string to an original string that satisfies the requirement above.", "inputFormat": "The first line contains a string $s$ of length $2 \\cdot n \\ (2 \\leq 2 \\cdot n \\leq 1 \\ 000 \\ 000)$. The string contains only lowercase letters.", "outputFormat": "If the string can be restored to a string that satisfies the requirement, output `NO` in the first line. If it cannot be restored, output `YES` in the first line.\n\nIf a solution exists, output the restored string in the second line. If there are multiple solutions, output any one.", "hint": "In the first sample, the substrings in the restored string are: `abbab`, `bbabc`, `babcb`, `abcbc`, `bcbcc`, `cbccb`, `bccba`, `ccbab`, `babba`.\n\nNote that in the first sample output, there are no repeated substrings, but there are other outputs that also satisfy the requirement. Therefore, the answer is not unique, and the sample only provides one valid output.\n\nIn the second sample, it is impossible to restore the string to an original string that satisfies the requirement.\n\nIn the third sample, no operation is needed because the requirement is already satisfied.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2019] Cycle String?", "background": "", "description": "大法师给了 Alice 和 Bob 一个长度为 $2 \\cdot n$ 的环形字符串，这个环形字符串中没有重复的长为 $n$ 的子串。在一个环形字符串中，字符 $s_{i+1}$ 在 $s_i$之后，而 $s_1$ 在 $s_{2n}$ 之后。\n\n不幸的是，恶魔打乱了字符串中字符的顺序。帮助 Alice 和 Bob 将字符串还原成满足上述要求的原始字符串。", "inputFormat": "第一行包含一个长度为 $2 \\cdot n \\ (2 \\leq 2\\cdot n \\leq 1 \\ 000 \\ 000)$ 的字符串 $s$，字符串中只包含小写字母。", "outputFormat": "如果能够将字符串还原成满足要求的字符串，则在第一行输出 `NO`；如果无法还原，则在第一行输出 `YES`。\n\n如果有解，在第二行输出还原后的字符串。如果存在多解，输出任意一个即可。", "hint": "第一个样例中，还原后的字符串中的子串分别为：`abbab`、`bbabc`、`babcb`、`abcbc`、`bcbcc`、`cbccb`、`bccba`、`ccbab`、`babba`。\n\n注意到第一个样例的答案中并不含有重复的子串，但存在其他的答案也满足题目要求。因此答案不唯一，样例只提供了一种满足要求的输出。\n\n第二个样例中，无法将字符串还原为满足要求的原始字符串。\n\n第三个样例中，不需要做任何操作即满足要求。", "locale": "zh-CN"}}}
{"pid": "P5800", "type": "P", "difficulty": 4, "samples": [["2 2\n18 1000 16 1\n5 3\n16 15", "1010"], ["2 2\n23 10 15 5\n2 2\n9 20", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "双指针 two-pointer", "SEERC"], "title": "[SEERC 2019] Life Transfer", "background": "*注：「feli」是当地货币单位。*", "description": "在大都市 Nekoresti 中，有 $n$ 个人已知年龄，第 $i$ 个人年龄为 $a_i$。现在他们享受着假期，所以他们决定去 Pisiev 游览一个著名的博物馆 Koshkseum。他们可以通过开车或骑摩托车去：\n\n- 一辆**车**可以载最多 $k$ 个人（包括一个年龄不低于 $l_c$ 岁的司机和至多 $k-1$ 个乘客）。一辆车的租金为 $p_c$ feli。\n- 一辆**摩托车**只能载 $1$ 个人（年龄不低于 $l_m$ 岁）。一辆摩托车的租金为 $p_m$ feli。\n\n不幸的是，这些人不是很富裕，所以他们请求一名当地的大魔法师 Mewlin 来帮助他们。通过使用一种强大的魔法 Mucadabra，Mewlin 可以转移人们的年龄。形式化地说，他可以减少一个年龄为 $x$ 的人的年龄，同时增加一个年龄为 $y$ 的人的年龄同一数值（这两个人的年龄之和不变）。完成 $1$ 岁的年龄的转移的花费是 $t$ feli。由于魔法的限制，魔法不能将一个人的年龄改变超过 $d$（如果一个人的年龄为 $x$，改变后的年龄只能在 $[x-d, x+d]$ 区间内）。并且，年龄也不能低于 $1$ 岁。\n\n帮助这些人花费最少的钱从 Nekoresti 到 Pisiev 去旅游吧。", "inputFormat": "第一行包含两个整数 $n$ 和 $k \\ (1 \\leq n, k \\leq 10^5)$，代表旅游的人数和一辆车的最大载客数。\n\n第二行包含四个整数 $l_c, p_c, l_m$ 和 $p_m \\ (1 \\leq l_m < l_c \\leq 10^5, 1 \\leq p_m < p_c \\leq 10^5)$，代表开车的最低年龄、一辆车的租金、骑摩托车的最低年龄、一辆摩托车的租金。\n\n第三行包含两个整数 $t$ 和 $d \\ (0 \\leq t, d \\leq 10^5)$，代表转移 $1$ 岁的年龄的花费和魔法的转移改变量限制。\n\n第四行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n \\ (1 \\leq a_i \\leq 10^5)$，$a_i$ 代表第 $i$ 个人的年龄。", "outputFormat": "输出一个数字，即让所有人到达目的地的最小花费。如果无解，输出 $-1$。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2019] Life Transfer", "background": "*Note: “feli” is the local currency unit.*", "description": "In the metropolis Nekoresti, there are $n$ people with known ages. The age of the $i$-th person is $a_i$. They are enjoying their vacation, so they decide to visit Pisiev to tour a famous museum called Koshkseum. They can travel either by car or by motorcycle:\n\n- A **car** can carry up to $k$ people (including one driver whose age is at least $l_c$, and up to $k-1$ passengers). The rental cost of one car is $p_c$ feli.\n- A **motorcycle** can carry only $1$ person (whose age is at least $l_m$). The rental cost of one motorcycle is $p_m$ feli.\n\nUnfortunately, these people are not very wealthy, so they ask a local archmage, Mewlin, to help them. By using a powerful spell, Mucadabra, Mewlin can transfer people’s ages. Formally, he can decrease the age of a person with age $x$, while increasing the age of a person with age $y$ by the same amount (so the sum of the two ages stays unchanged). The cost to transfer $1$ year of age is $t$ feli. Due to the limits of the spell, the spell cannot change a person’s age by more than $d$ (if a person’s age is $x$, then the changed age can only be within $[x-d, x+d]$). Also, an age cannot be less than $1$.\n\nHelp them spend the least amount of money to travel from Nekoresti to Pisiev.", "inputFormat": "The first line contains two integers $n$ and $k$ $(1 \\leq n, k \\leq 10^5)$, representing the number of people traveling and the maximum capacity of one car.\n\nThe second line contains four integers $l_c, p_c, l_m$ and $p_m$ $(1 \\leq l_m < l_c \\leq 10^5, 1 \\leq p_m < p_c \\leq 10^5)$, representing the minimum age to drive, the rental cost of one car, the minimum age to ride a motorcycle, and the rental cost of one motorcycle.\n\nThe third line contains two integers $t$ and $d$ $(0 \\leq t, d \\leq 10^5)$, representing the cost to transfer $1$ year of age and the limit $d$ on how much the spell can change an age.\n\nThe fourth line contains $n$ integers $a_1, a_2, \\dots, a_n$ $(1 \\leq a_i \\leq 10^5)$, where $a_i$ is the age of the $i$-th person.", "outputFormat": "Output one number, the minimum total cost to get everyone to the destination. If there is no solution, output $-1$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2019] Life Transfer", "background": "*注：「feli」是当地货币单位。*", "description": "在大都市 Nekoresti 中，有 $n$ 个人已知年龄，第 $i$ 个人年龄为 $a_i$。现在他们享受着假期，所以他们决定去 Pisiev 游览一个著名的博物馆 Koshkseum。他们可以通过开车或骑摩托车去：\n\n- 一辆**车**可以载最多 $k$ 个人（包括一个年龄不低于 $l_c$ 岁的司机和至多 $k-1$ 个乘客）。一辆车的租金为 $p_c$ feli。\n- 一辆**摩托车**只能载 $1$ 个人（年龄不低于 $l_m$ 岁）。一辆摩托车的租金为 $p_m$ feli。\n\n不幸的是，这些人不是很富裕，所以他们请求一名当地的大魔法师 Mewlin 来帮助他们。通过使用一种强大的魔法 Mucadabra，Mewlin 可以转移人们的年龄。形式化地说，他可以减少一个年龄为 $x$ 的人的年龄，同时增加一个年龄为 $y$ 的人的年龄同一数值（这两个人的年龄之和不变）。完成 $1$ 岁的年龄的转移的花费是 $t$ feli。由于魔法的限制，魔法不能将一个人的年龄改变超过 $d$（如果一个人的年龄为 $x$，改变后的年龄只能在 $[x-d, x+d]$ 区间内）。并且，年龄也不能低于 $1$ 岁。\n\n帮助这些人花费最少的钱从 Nekoresti 到 Pisiev 去旅游吧。", "inputFormat": "第一行包含两个整数 $n$ 和 $k \\ (1 \\leq n, k \\leq 10^5)$，代表旅游的人数和一辆车的最大载客数。\n\n第二行包含四个整数 $l_c, p_c, l_m$ 和 $p_m \\ (1 \\leq l_m < l_c \\leq 10^5, 1 \\leq p_m < p_c \\leq 10^5)$，代表开车的最低年龄、一辆车的租金、骑摩托车的最低年龄、一辆摩托车的租金。\n\n第三行包含两个整数 $t$ 和 $d \\ (0 \\leq t, d \\leq 10^5)$，代表转移 $1$ 岁的年龄的花费和魔法的转移改变量限制。\n\n第四行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n \\ (1 \\leq a_i \\leq 10^5)$，$a_i$ 代表第 $i$ 个人的年龄。", "outputFormat": "输出一个数字，即让所有人到达目的地的最小花费。如果无解，输出 $-1$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5801", "type": "P", "difficulty": 5, "samples": [["4\n1 2\n2 3\n3 4", "Bob"], ["7\n2 1\n2 6\n1 3\n2 5\n7 2\n2 4", "Alice"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "SEERC"], "title": "[SEERC 2019] Game on a Tree", "background": "", "description": "Alice 和 Bob 在树上玩游戏。最初的时候，树上的所有节点都是白色的。\n\nAlice 先手，她可以任选一个节点并在该点上放置一个标记，该点变为黑色。在这之后，玩家轮流进行游戏，每一回合中玩家可以将标记从所在点移动到该点的白色祖先节点或儿子节点中，并将移动到的点变为黑色。无法进行移动的玩家即输。\n\n谁会赢得游戏呢？\n\n在有根树上，节点 $v$ 的*祖先节点*是指从树根到节点 $v$ 的路径上的任意点。\n\n在有根树上，节点 $v$ 的*儿子节点*是指满足节点 $v$ 在从树根到节点 $w$ 路径上的任意点 $w$。\n\n规定树的树根为点 $1$。", "inputFormat": "第一行包含一个整数 $n \\ (1 \\leq n \\leq 100 \\ 000)$，代表树的节点数。\n\n接下来的 $n-1$ 行中，每一行包含两个整数 $u$ 和 $v \\ (1 \\leq u, v \\leq n)$，代表树上的一条边 $(u, v)$。数据保证这些边会构成一棵树。", "outputFormat": "输出一行，如果 Alice 赢得了游戏，则输出 `Alice`，否则输出 `Bob`。", "hint": "第一组样例中，树的形态是 $4$ 个点的一条链，所以 Bob 总是可以把标记移到最后的白点上。\n\n第二组样例中，Alice 的最佳策略是先把标记放在点 $3$ 上，然后 $3$ 会变为黑色。Bob 只能移动标记到点 $1$ 上。Alice 可以选择点 $4, 5, 6$ 或 $7$ 来移动。Bob 只能选择 $2$。Alice 选择 $2$ 的任一白色子节点，Bob 就无法移动了。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2019] Game on a Tree", "background": "", "description": "Alice and Bob play a game on a tree. At the beginning, all nodes on the tree are white.\n\nAlice moves first. She may choose any node and place a token on it, and that node becomes black. After that, the players take turns. In each turn, the current player may move the token from its current node to a white ancestor of that node or to a white child of that node, and the node moved to becomes black. The player who cannot make a move loses.\n\nIn a rooted tree, an *ancestor* of a node $v$ is any node on the path from the root to node $v$.\n\nIn a rooted tree, a *child* of a node $v$ is a node $w$ such that $v$ is on the path from the root to $w$ and $v$ is the parent of $w$.\n\nThe root of the tree is node $1$.", "inputFormat": "The first line contains an integer $n \\ (1 \\leq n \\leq 100 \\ 000)$, the number of nodes in the tree.\n\nEach of the next $n-1$ lines contains two integers $u$ and $v \\ (1 \\leq u, v \\leq n)$, denoting an edge $(u, v)$ of the tree. The testdata guarantees that these edges form a tree.", "outputFormat": "Output one line. If Alice wins the game, output `Alice`; otherwise, output `Bob`.", "hint": "In the first sample, the tree is a chain of $4$ nodes, so Bob can always move the token to the last remaining white node.\n\nIn the second sample, Alice’s best strategy is to place the token on node $3$ first, and then node $3$ becomes black. Bob can only move the token to node $1$. Alice can choose node $4, 5, 6$ or $7$ to move to. Bob can then only choose node $2$. After Alice chooses any white child of node $2$, Bob will have no move.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2019] Game on a Tree", "background": "", "description": "Alice 和 Bob 在树上玩游戏。最初的时候，树上的所有节点都是白色的。\n\nAlice 先手，她可以任选一个节点并在该点上放置一个标记，该点变为黑色。在这之后，玩家轮流进行游戏，每一回合中玩家可以将标记从所在点移动到该点的白色祖先节点或儿子节点中，并将移动到的点变为黑色。无法进行移动的玩家即输。\n\n谁会赢得游戏呢？\n\n在有根树上，节点 $v$ 的*祖先节点*是指从树根到节点 $v$ 的路径上的任意点。\n\n在有根树上，节点 $v$ 的*儿子节点*是指满足节点 $v$ 在从树根到节点 $w$ 路径上的任意点 $w$。\n\n规定树的树根为点 $1$。", "inputFormat": "第一行包含一个整数 $n \\ (1 \\leq n \\leq 100 \\ 000)$，代表树的节点数。\n\n接下来的 $n-1$ 行中，每一行包含两个整数 $u$ 和 $v \\ (1 \\leq u, v \\leq n)$，代表树上的一条边 $(u, v)$。数据保证这些边会构成一棵树。", "outputFormat": "输出一行，如果 Alice 赢得了游戏，则输出 `Alice`，否则输出 `Bob`。", "hint": "第一组样例中，树的形态是 $4$ 个点的一条链，所以 Bob 总是可以把标记移到最后的白点上。\n\n第二组样例中，Alice 的最佳策略是先把标记放在点 $3$ 上，然后 $3$ 会变为黑色。Bob 只能移动标记到点 $1$ 上。Alice 可以选择点 $4, 5, 6$ 或 $7$ 来移动。Bob 只能选择 $2$。Alice 选择 $2$ 的任一白色子节点，Bob 就无法移动了。", "locale": "zh-CN"}}}
{"pid": "P5802", "type": "P", "difficulty": 4, "samples": [["5 3 3\n111\n010\n010\n010\n010\n111\n100\n110\n100\n100", "14\n0 0 0\n0 0 1\n0 0 2\n0 1 0\n0 1 1\n0 1 2\n0 2 0\n0 2 1\n0 2 2\n1 1 0\n2 1 0\n2 1 1\n3 1 0\n4 1 0\n8\n0 0 0\n0 1 1\n0 2 2\n1 1 0\n2 1 0\n2 1 1\n3 1 0\n4 1 0"], ["2 2 2\n00\n00\n11\n11", "-1"], ["2 3 2\n101\n011\n10\n11", "6\n0 0 0\n0 2 0\n1 1 0\n1 1 1\n1 2 0\n1 2 1\n4\n0 0 0\n0 2 0\n1 1 0\n1 2 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2019", "ICPC", "SEERC"], "title": "[SEERC 2019] Projection", "background": "", "description": "![TensorFlow](https://cdn.luogu.com.cn/upload/image_hosting/gdl3vztm.png)\n\n你是一个 TensorFlow 的死忠粉，因此，你想要从两个投影图形来还原出 TensorFlow 的图标。\n\n假定你有一个 3D 空间，尺寸为 $n \\times m \\times h$，以及两个投影图形（一个 $n \\times m$ 的矩阵和一个 $n \\times h$ 的矩阵，矩阵里的元素都为 $0$ 或 $1$）。你需要计算出一些 $1 \\times 1 \\times 1$ 的小正方体的集合，使得这些正方体放入 3D 空间后构成的立体的正投影（光照立体正面在立体后侧形成的投影）和右投影（光照立体左面在立体右侧形成的投影）与题目给定的投影图形一致。如果无解，输出 $-1$。如果有解，你需要计算出两个满足条件的集合，一个包含的小正方体数量最少，另一个最多。假定正方体的摆放不受重力影响（即小正方体在 3D 空间中可以随意放置，悬空也不需要支撑）。规定矩阵中的 $1$ 代表有阴影遮住，$0$ 代表无阴影遮住。\n\n如果有多解，你需要输出字典序最小的解。一个解 $a$ 字典序比解 $b$ 小，当且仅当对于两个解中第一对不相同的数字，$a$ 中的数字小于 $b$ 中的。\n\n例如，解 $[(0, 0, 0), (1, 1, 1)]$ 比解 $[(1, 1, 1), (0, 0, 0)]$ 字典序更小。", "inputFormat": "第一行包含三个整数 $n, m, h \\ (1 \\leq n,m,h \\leq 100)$，代表 3D 空间的尺寸。\n\n接下来的 $n$ 行中，每一行包含 $m$ 个字符 $0$ 或 $1$，其中 $1$ 代表有阴影遮住，$0$ 代表无阴影遮住。这 $n \\times m$ 个字符描述了一个正投影。\n\n接下来的 $n$ 行中，每一行包含 $h$ 个字符，格式同上。这 $n \\times h$ 个字符描述了一个右投影。", "outputFormat": "如果无解，仅在第一行输出 $-1$ 即可。\n\n如果有解，第一行输出一个整数 $k_{max}$，代表满足题目要求的解中小正方体个数的最大值。\n\n接下来 $k_{max}$ 行中每行输出三个整数 $x, y, z \\ (0 \\leq x < n, 0 \\leq y < m, 0 \\leq z < h)$，代表小正方体最多的解中字典序最小的解的 $k_{max}$ 个小正方体的放置位置。\n\n接下来一行输出一个整数 $k_{min}$，代表满足题目要求的解中小正方体个数的最小值。\n\n接下来 $k_{min}$ 行中每行输出三个整数 $x, y, z \\ (0 \\leq x < n, 0 \\leq y < m, 0 \\leq z < h)$，代表小正方体最少的解中字典序最小的解的 $k_{min}$ 个小正方体的放置位置。", "hint": "一个放置在 $(x, y, z)$ 的小正方体会在正投影的 $(x, y)$ 位置产生一个有阴影遮住的区域，并在右投影的 $(x, z)$ 位置产生一个有阴影遮住的区域。\n\n坐标从 $0$ 开始编号。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2019] Projection", "background": "", "description": "![TensorFlow](https://cdn.luogu.com.cn/upload/image_hosting/gdl3vztm.png)\n\nYou are a hardcore fan of TensorFlow, so you want to reconstruct the TensorFlow logo from two projection images.\n\nSuppose you have a 3D space of size $n \\times m \\times h$, and two projection images (an $n \\times m$ matrix and an $n \\times h$ matrix, with each entry being $0$ or $1$). You need to find a set of $1 \\times 1 \\times 1$ unit cubes such that, after placing these cubes into the 3D space, the front orthographic projection (the projection formed on the back side of the solid when light shines on the front face) and the right projection (the projection formed on the right side of the solid when light shines on the left face) are consistent with the given projection images. If there is no solution, output $-1$. If there is a solution, you need to compute two valid sets: one with the minimum number of unit cubes, and one with the maximum number. Assume gravity does not matter (i.e., unit cubes can be placed anywhere in the 3D space; they can float without support). In the matrices, $1$ means the position is covered by shadow, and $0$ means it is not covered by shadow.\n\nIf there are multiple solutions, you need to output the lexicographically smallest one. A solution $a$ is lexicographically smaller than a solution $b$ if and only if, at the first position where they differ, the number in $a$ is smaller than the corresponding number in $b$.\n\nFor example, the solution $[(0, 0, 0), (1, 1, 1)]$ is lexicographically smaller than $[(1, 1, 1), (0, 0, 0)]$.", "inputFormat": "The first line contains three integers $n, m, h \\ (1 \\leq n,m,h \\leq 100)$, representing the size of the 3D space.\n\nIn the next $n$ lines, each line contains $m$ characters $0$ or $1$. Here, $1$ means covered by shadow, and $0$ means not covered. These $n \\times m$ characters describe the front projection.\n\nIn the next $n$ lines, each line contains $h$ characters in the same format. These $n \\times h$ characters describe the right projection.", "outputFormat": "If there is no solution, output $-1$ on the first line only.\n\nIf there is a solution, output an integer $k_{max}$ on the first line, representing the maximum number of unit cubes among all valid solutions.\n\nIn the next $k_{max}$ lines, output three integers $x, y, z \\ (0 \\leq x < n, 0 \\leq y < m, 0 \\leq z < h)$ per line, representing the positions of the $k_{max}$ unit cubes in the lexicographically smallest solution among those with the maximum number of cubes.\n\nThen output an integer $k_{min}$ on the next line, representing the minimum number of unit cubes among all valid solutions.\n\nIn the next $k_{min}$ lines, output three integers $x, y, z \\ (0 \\leq x < n, 0 \\leq y < m, 0 \\leq z < h)$ per line, representing the positions of the $k_{min}$ unit cubes in the lexicographically smallest solution among those with the minimum number of cubes.", "hint": "A unit cube placed at $(x, y, z)$ will create a shadowed area at position $(x, y)$ in the front projection, and at position $(x, z)$ in the right projection.\n\nCoordinates are numbered starting from $0$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2019] Projection", "background": "", "description": "![TensorFlow](https://cdn.luogu.com.cn/upload/image_hosting/gdl3vztm.png)\n\n你是一个 TensorFlow 的死忠粉，因此，你想要从两个投影图形来还原出 TensorFlow 的图标。\n\n假定你有一个 3D 空间，尺寸为 $n \\times m \\times h$，以及两个投影图形（一个 $n \\times m$ 的矩阵和一个 $n \\times h$ 的矩阵，矩阵里的元素都为 $0$ 或 $1$）。你需要计算出一些 $1 \\times 1 \\times 1$ 的小正方体的集合，使得这些正方体放入 3D 空间后构成的立体的正投影（光照立体正面在立体后侧形成的投影）和右投影（光照立体左面在立体右侧形成的投影）与题目给定的投影图形一致。如果无解，输出 $-1$。如果有解，你需要计算出两个满足条件的集合，一个包含的小正方体数量最少，另一个最多。假定正方体的摆放不受重力影响（即小正方体在 3D 空间中可以随意放置，悬空也不需要支撑）。规定矩阵中的 $1$ 代表有阴影遮住，$0$ 代表无阴影遮住。\n\n如果有多解，你需要输出字典序最小的解。一个解 $a$ 字典序比解 $b$ 小，当且仅当对于两个解中第一对不相同的数字，$a$ 中的数字小于 $b$ 中的。\n\n例如，解 $[(0, 0, 0), (1, 1, 1)]$ 比解 $[(1, 1, 1), (0, 0, 0)]$ 字典序更小。", "inputFormat": "第一行包含三个整数 $n, m, h \\ (1 \\leq n,m,h \\leq 100)$，代表 3D 空间的尺寸。\n\n接下来的 $n$ 行中，每一行包含 $m$ 个字符 $0$ 或 $1$，其中 $1$ 代表有阴影遮住，$0$ 代表无阴影遮住。这 $n \\times m$ 个字符描述了一个正投影。\n\n接下来的 $n$ 行中，每一行包含 $h$ 个字符，格式同上。这 $n \\times h$ 个字符描述了一个右投影。", "outputFormat": "如果无解，仅在第一行输出 $-1$ 即可。\n\n如果有解，第一行输出一个整数 $k_{max}$，代表满足题目要求的解中小正方体个数的最大值。\n\n接下来 $k_{max}$ 行中每行输出三个整数 $x, y, z \\ (0 \\leq x < n, 0 \\leq y < m, 0 \\leq z < h)$，代表小正方体最多的解中字典序最小的解的 $k_{max}$ 个小正方体的放置位置。\n\n接下来一行输出一个整数 $k_{min}$，代表满足题目要求的解中小正方体个数的最小值。\n\n接下来 $k_{min}$ 行中每行输出三个整数 $x, y, z \\ (0 \\leq x < n, 0 \\leq y < m, 0 \\leq z < h)$，代表小正方体最少的解中字典序最小的解的 $k_{min}$ 个小正方体的放置位置。", "hint": "一个放置在 $(x, y, z)$ 的小正方体会在正投影的 $(x, y)$ 位置产生一个有阴影遮住的区域，并在右投影的 $(x, z)$ 位置产生一个有阴影遮住的区域。\n\n坐标从 $0$ 开始编号。", "locale": "zh-CN"}}}
{"pid": "P5803", "type": "P", "difficulty": 6, "samples": [["3\n1 1 2 2", "2 3"], ["3\n2 2 2 2", "-1 -1"], ["6\n1 4 5 4 4 4 3 4 4 2", "-1 -1 -1 17 20"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "SEERC"], "title": "[SEERC 2019] Tree Permutations", "background": "", "description": "有一天，Cool 先生建了一棵 $n$ 个点的树（没有环的无向连通图），他给任一编号 $i > 1$ 的点规定了两个值：$p_i < i$ 代表点 $i$ 的父节点，与 $w_i$ 代表 $i$ 与 $p_i$ 之间的边的边权。点 $1$ 是树根，所以它没有父节点。\n\n你想知道 Cool 先生建的树长啥样，但是 Cool 先生拒绝告诉你，但他给了你一些提示：\n\n他把所有的 $p_i$ 和 $w_i$ 值写成一列，得到了长为 $2 \\cdot n - 2$ 的数列 $b$。\n\n$$ b=[p_2, w_2, p_3, w_3, \\dots, p_{n-1}, w_{n-1}, p_n, w_n] $$\n\n然后他将其随机打乱，得到了数列 $a$，并将 $a$ 告诉你。\n\n然而只知道数列 $a$ 是无法还原那棵树的，你决定解决一个更难的问题。\n\n定义一个树是 *$k$ 长*的，当且仅当点 $1$ 到点 $n$ 的路径上有恰好 $k$ 条边。\n\n定义一个树是 *$k$ 完美*的，当且仅当这棵树是 *$k$ 长*的且点 $1$ 到点 $n$ 的路径上的边的边权之和是所有 *$k$ 长*的树中最大的。\n\n你的任务是计算出每个 $k$ 值对应的 *$k$ 完美*的树中，点 $1$ 到点 $n$ 的路径上的边的边权之和。如果某个 $k$ 值不存在 *$k$ 完美*的树，则在该位置输出 $-1$。", "inputFormat": "第一行包含一个整数 $n \\ (2 \\leq n \\leq 10^5)$，代表树上的节点数。\n\n第二行包含 $2 \\cdot n -2$ 个整数 $a_1, a_2, \\dots, a_{2n-2} \\ (1 \\leq a_i \\leq n-1)$，代表数列 $a$ 中的数字。", "outputFormat": "输出一行，共 $n-1$ 个空格隔开的整数 $w_1, w_2, w_3, \\dots, w_{n-1}$，其中 $w_k$ 代表 *$k$ 完美*的树中点 $1$ 到点 $n$ 的路径上的边的边权之和。如果不存在 *$i$ 长*的树，则 $w_i=-1$。", "hint": "第一个样例中，*$1$ 完美*的树由数列 $[1, 2, 1, 2]$ 构成（即，$p_2=1, w_2=2, p_3=1, w_3=2$），*$2$ 完美*的树由数列 $[1, 2, 2, 1]$ 构成（即，$p_2=1, w_2=2, p_3=2, w_3=1$）。以下是这两棵树的图形（点 $1$ 到点 $n$ 的路径上的边都为粗线）。\n\n![样例1](https://cdn.luogu.com.cn/upload/image_hosting/lgpg0jne.png)\n\n第二个样例中，不存在能通过重排 $a$ 构造出的 *$k$ 完美*的树。\n\n第三个样例中，只有 *$4$ 完美*的和 *$5$ 完美*的树可以被构造出。它们分别由数列 $[1, 4, 2, 4, 3, 4, 4, 4, 4, 5]$ 和 $[1, 4,2, 4, 3, 4, 4, 4, 5, 4]$ 构成。以下是这两棵树的图形。\n\n![样例3](https://cdn.luogu.com.cn/upload/image_hosting/rz04b4ro.png)", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2019] Tree Permutations", "background": "", "description": "One day, Mr. Cool built a tree with $n$ vertices (a connected undirected graph with no cycles). For each vertex $i > 1$, he specified two values: $p_i < i$, which represents the parent of vertex $i$, and $w_i$, which represents the weight of the edge between $i$ and $p_i$. Vertex $1$ is the root of the tree, so it has no parent.\n\nYou want to know what the tree Mr. Cool built looks like, but Mr. Cool refuses to tell you. However, he gave you some hints:\n\nHe wrote all the values $p_i$ and $w_i$ into a single list, obtaining an array $b$ of length $2 \\cdot n - 2$.\n\n$$ b=[p_2, w_2, p_3, w_3, \\dots, p_{n-1}, w_{n-1}, p_n, w_n] $$\n\nThen he randomly shuffled it, obtaining an array $a$, and told you $a$.\n\nHowever, knowing only the array $a$ is not enough to restore the tree, so you decide to solve a harder problem.\n\nA tree is called *$k$-long* if and only if the path from vertex $1$ to vertex $n$ contains exactly $k$ edges.\n\nA tree is called *$k$-perfect* if and only if it is *$k$-long*, and among all *$k$-long* trees, the sum of edge weights on the path from vertex $1$ to vertex $n$ is the maximum possible.\n\nYour task is to compute, for each $k$, the sum of edge weights on the path from vertex $1$ to vertex $n$ in a *$k$-perfect* tree. If no *$k$-perfect* tree exists for some $k$, output $-1$ at that position.", "inputFormat": "The first line contains an integer $n \\ (2 \\leq n \\leq 10^5)$, representing the number of vertices in the tree.\n\nThe second line contains $2 \\cdot n -2$ integers $a_1, a_2, \\dots, a_{2n-2} \\ (1 \\leq a_i \\leq n-1)$, representing the elements of array $a$.", "outputFormat": "Output one line with $n-1$ space-separated integers $w_1, w_2, w_3, \\dots, w_{n-1}$, where $w_k$ is the sum of edge weights on the path from vertex $1$ to vertex $n$ in a *$k$-perfect* tree. If no *$i$-long* tree exists, then $w_i=-1$.", "hint": "In the first sample, the *$1$-perfect* tree is formed by the list $[1, 2, 1, 2]$ (i.e., $p_2=1, w_2=2, p_3=1, w_3=2$), and the *$2$-perfect* tree is formed by the list $[1, 2, 2, 1]$ (i.e., $p_2=1, w_2=2, p_3=2, w_3=1$). The figures of these two trees are shown below (the edges on the path from vertex $1$ to vertex $n$ are drawn in bold).\n\n![Sample 1](https://cdn.luogu.com.cn/upload/image_hosting/lgpg0jne.png)\n\nIn the second sample, there is no *$k$-perfect* tree that can be constructed by rearranging $a$.\n\nIn the third sample, only the *$4$-perfect* and *$5$-perfect* trees can be constructed. They are formed by the lists $[1, 4, 2, 4, 3, 4, 4, 4, 4, 5]$ and $[1, 4,2, 4, 3, 4, 4, 4, 5, 4]$, respectively. The figures of these two trees are shown below.\n\n![Sample 3](https://cdn.luogu.com.cn/upload/image_hosting/rz04b4ro.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2019] Tree Permutations", "background": "", "description": "有一天，Cool 先生建了一棵 $n$ 个点的树（没有环的无向连通图），他给任一编号 $i > 1$ 的点规定了两个值：$p_i < i$ 代表点 $i$ 的父节点，与 $w_i$ 代表 $i$ 与 $p_i$ 之间的边的边权。点 $1$ 是树根，所以它没有父节点。\n\n你想知道 Cool 先生建的树长啥样，但是 Cool 先生拒绝告诉你，但他给了你一些提示：\n\n他把所有的 $p_i$ 和 $w_i$ 值写成一列，得到了长为 $2 \\cdot n - 2$ 的数列 $b$。\n\n$$ b=[p_2, w_2, p_3, w_3, \\dots, p_{n-1}, w_{n-1}, p_n, w_n] $$\n\n然后他将其随机打乱，得到了数列 $a$，并将 $a$ 告诉你。\n\n然而只知道数列 $a$ 是无法还原那棵树的，你决定解决一个更难的问题。\n\n定义一个树是 *$k$ 长*的，当且仅当点 $1$ 到点 $n$ 的路径上有恰好 $k$ 条边。\n\n定义一个树是 *$k$ 完美*的，当且仅当这棵树是 *$k$ 长*的且点 $1$ 到点 $n$ 的路径上的边的边权之和是所有 *$k$ 长*的树中最大的。\n\n你的任务是计算出每个 $k$ 值对应的 *$k$ 完美*的树中，点 $1$ 到点 $n$ 的路径上的边的边权之和。如果某个 $k$ 值不存在 *$k$ 完美*的树，则在该位置输出 $-1$。", "inputFormat": "第一行包含一个整数 $n \\ (2 \\leq n \\leq 10^5)$，代表树上的节点数。\n\n第二行包含 $2 \\cdot n -2$ 个整数 $a_1, a_2, \\dots, a_{2n-2} \\ (1 \\leq a_i \\leq n-1)$，代表数列 $a$ 中的数字。", "outputFormat": "输出一行，共 $n-1$ 个空格隔开的整数 $w_1, w_2, w_3, \\dots, w_{n-1}$，其中 $w_k$ 代表 *$k$ 完美*的树中点 $1$ 到点 $n$ 的路径上的边的边权之和。如果不存在 *$i$ 长*的树，则 $w_i=-1$。", "hint": "第一个样例中，*$1$ 完美*的树由数列 $[1, 2, 1, 2]$ 构成（即，$p_2=1, w_2=2, p_3=1, w_3=2$），*$2$ 完美*的树由数列 $[1, 2, 2, 1]$ 构成（即，$p_2=1, w_2=2, p_3=2, w_3=1$）。以下是这两棵树的图形（点 $1$ 到点 $n$ 的路径上的边都为粗线）。\n\n![样例1](https://cdn.luogu.com.cn/upload/image_hosting/lgpg0jne.png)\n\n第二个样例中，不存在能通过重排 $a$ 构造出的 *$k$ 完美*的树。\n\n第三个样例中，只有 *$4$ 完美*的和 *$5$ 完美*的树可以被构造出。它们分别由数列 $[1, 4, 2, 4, 3, 4, 4, 4, 4, 5]$ 和 $[1, 4,2, 4, 3, 4, 4, 4, 5, 4]$ 构成。以下是这两棵树的图形。\n\n![样例3](https://cdn.luogu.com.cn/upload/image_hosting/rz04b4ro.png)", "locale": "zh-CN"}}}
{"pid": "P5804", "type": "P", "difficulty": 3, "samples": [["4\n2 14 7 14\n5 10 9 22", "4"], ["1\n14\n42", "28"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "SEERC"], "title": "[SEERC 2019] Absolute Game", "background": "", "description": "Alice 和 Bob 在玩一个游戏。Alice 有一个包含 $n$ 个整数的数列 $a$，Bob 有一个包含 $n$ 个整数的数列 $b$。每一回合中，玩家需要从他的数列中删去一个数字。玩家轮流进行回合，Alice 先手。\n\n当两个数列中都只剩下一个数字的时候，游戏结束。令 Alice 的数列剩下的数字为 $x$，Bob 的数列剩下的数字为 $y$。Alice 想要最大化 $x$ 与 $y$ 之差的绝对值，而 Bob 想最小化这个值。两个玩家都以最优策略游戏。\n\n请算出游戏结束时的结果。", "inputFormat": "第一行包含一个整数 $n \\ (1 \\leq n \\leq 1 \\ 000)$，代表每个数列中的数字个数。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n \\ (1 \\leq a_i \\leq 10^9)$，代表 Alice 的数列中的数字。\n\n第三行包含 $n$ 个整数 $b_1, b_2, \\dots, b_n \\ (1 \\leq b_i \\leq 10^9)$，代表 Bob 的数列中的数字。", "outputFormat": "输出当两个玩家都以最优策略游戏时，$x$ 与 $y$ 之差的绝对值。", "hint": "第一个样例中，$x=14, y=10$，因此两个数之差为 $4$。\n\n第二个样例中，两个数列都只剩下一个数字了，因此 $x=14, y=42$。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2019] Absolute Game", "background": "", "description": "Alice and Bob are playing a game. Alice has a sequence $a$ containing $n$ integers, and Bob has a sequence $b$ containing $n$ integers. In each round, the player must delete one number from their own sequence. The players take turns, and Alice moves first.\n\nWhen both sequences have only one number left, the game ends. Let the remaining number in Alice’s sequence be $x$, and the remaining number in Bob’s sequence be $y$. Alice wants to maximize the absolute value of the difference between $x$ and $y$, while Bob wants to minimize this value. Both players play optimally.\n\nCompute the result when the game ends.", "inputFormat": "The first line contains an integer $n \\ (1 \\leq n \\leq 1 \\ 000)$, representing the number of integers in each sequence.\n\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n \\ (1 \\leq a_i \\leq 10^9)$, representing the numbers in Alice’s sequence.\n\nThe third line contains $n$ integers $b_1, b_2, \\dots, b_n \\ (1 \\leq b_i \\leq 10^9)$, representing the numbers in Bob’s sequence.", "outputFormat": "Output the absolute value of the difference between $x$ and $y$ when both players play optimally.", "hint": "In the first sample, $x=14$ and $y=10$, so the difference between the two numbers is $4$.\n\nIn the second sample, both sequences already have only one number left, so $x=14$ and $y=42$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2019] Absolute Game", "background": "", "description": "Alice 和 Bob 在玩一个游戏。Alice 有一个包含 $n$ 个整数的数列 $a$，Bob 有一个包含 $n$ 个整数的数列 $b$。每一回合中，玩家需要从他的数列中删去一个数字。玩家轮流进行回合，Alice 先手。\n\n当两个数列中都只剩下一个数字的时候，游戏结束。令 Alice 的数列剩下的数字为 $x$，Bob 的数列剩下的数字为 $y$。Alice 想要最大化 $x$ 与 $y$ 之差的绝对值，而 Bob 想最小化这个值。两个玩家都以最优策略游戏。\n\n请算出游戏结束时的结果。", "inputFormat": "第一行包含一个整数 $n \\ (1 \\leq n \\leq 1 \\ 000)$，代表每个数列中的数字个数。\n\n第二行包含 $n$ 个整数 $a_1, a_2, \\dots, a_n \\ (1 \\leq a_i \\leq 10^9)$，代表 Alice 的数列中的数字。\n\n第三行包含 $n$ 个整数 $b_1, b_2, \\dots, b_n \\ (1 \\leq b_i \\leq 10^9)$，代表 Bob 的数列中的数字。", "outputFormat": "输出当两个玩家都以最优策略游戏时，$x$ 与 $y$ 之差的绝对值。", "hint": "第一个样例中，$x=14, y=10$，因此两个数之差为 $4$。\n\n第二个样例中，两个数列都只剩下一个数字了，因此 $x=14, y=42$。", "locale": "zh-CN"}}}
{"pid": "P5805", "type": "P", "difficulty": 3, "samples": [["3\n1 2 1\n2 3 1\n3 1 1", "3"], ["5\n4 5 4\n1 3 4\n1 2 4\n3 2 3\n3 5 2\n1 4 3\n4 2 2\n1 5 4\n5 2 4\n3 4 2", "35"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "ICPC", "SEERC"], "title": "[SEERC 2019] Graph and Cycles", "background": "", "description": "有一个 $n$ 个点的无向有边权的完全图，其中 $n$ 是奇数。\n\n定义一个大小为 $k$ 的*环边组*为一个边构成的数组 $[e_1, e_2, \\dots, e_k]$，且具有以下性质：\n\n- $k$ 大于 $1$。\n- 对于任意 $[1, k]$ 中的整数 $i$，边 $e_i$ 与 $e_{i-1}$ 和 $e_{i+1}$ 都恰好有一个相同的端点（规定 $e_0=e_k, e_{k+1}=e_1$）。\n\n显然一个环边组中的边构成了图上的一个环。\n\n定义一个参数为两条边 $e_1, e_2$ 的函数 $f(e_1, e_2)$，其函数值为两条边中边权的较大值。\n\n定义一个环边组 $C=[e_1, e_2, \\dots, e_k]$ 的*价值*为对于任意 $[1, k]$ 中的整数 $i$，$f(e_i, e_{i+1})$ 的值之和（规定 $e_{k+1}=e_1$）。\n\n定义一个图的*环分割*为一组无交集的环边组，且这些环边组的并包含了图上所有的边。定义一个图的环分割的*价值*为其中所有环边组的价值之和。\n\n一个图可能存在多组环分割。给定一个图，你的任务是找到价值最小的环分割并输出该最小价值。", "inputFormat": "第一行包含一个整数 $n \\ (3 \\leq n \\leq 999, n \\bmod 2 = 1)$，代表图的点数。\n\n接下来的 $\\frac{n\\cdot (n-1)}{2}$ 行每行包含三个整数 $u, v$ 和 $w \\ (1 \\leq u, v \\leq n, u \\neq v, 1 \\leq w \\leq 10^9)$，代表点 $u$ 和点 $v$ 间有一条边权为 $w$ 的边。", "outputFormat": "输出一个整数，代表给定图的最小价值环分割的价值。", "hint": "以下样例解释中，边以输入顺序编号，$e_i$ 代表输入顺序中的第 $i$ 条边。\n\n第一个样例中，唯一的环分割为 $S=\\{ [e_1, e_2, e_3] \\}$。$f(e_1, e_2)+f(e_2,e_3)+f(e_3,e_1)=1+1+1=3$。\n\n第二个样例中，最优的环分割为 $S=\\{ [e_3, e_8, e_9], [e_2,e_4,e_7,e_{10},e_5,e_1,e_6] \\}$。环边组 $[e_3,e_8,e_9]$ 的价值为 $12$，$[e_2,e_4,e_7,e_{10},e_5,e_1,e_6]$ 的价值为 $23$，因此环分割的价值为 $35$。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2019] Graph and Cycles", "background": "", "description": "There is an undirected complete graph with $n$ vertices and edge weights, where $n$ is odd.\n\nA *cycle edge group* of size $k$ is an array of edges $[e_1, e_2, \\dots, e_k]$ that satisfies:\n\n- $k$ is greater than $1$.\n- For any integer $i$ in $[1, k]$, the edge $e_i$ shares exactly one common endpoint with each of $e_{i-1}$ and $e_{i+1}$ (where $e_0 = e_k$ and $e_{k+1} = e_1$).\n\nObviously, the edges in a cycle edge group form a cycle in the graph.\n\nDefine a function $f(e_1, e_2)$ for two edges $e_1, e_2$ as the larger of their edge weights.\n\nDefine the *value* of a cycle edge group $C = [e_1, e_2, \\dots, e_k]$ as the sum of $f(e_i, e_{i+1})$ over all integers $i$ in $[1, k]$ (where $e_{k+1} = e_1$).\n\nDefine a *cycle decomposition* of a graph as a set of pairwise disjoint cycle edge groups whose union contains all edges of the graph. Define the *value* of a cycle decomposition as the sum of the values of all cycle edge groups in it.\n\nA graph may have multiple cycle decompositions. Given a graph, your task is to find the cycle decomposition with the minimum value and output this minimum value.", "inputFormat": "The first line contains an integer $n \\ (3 \\leq n \\leq 999, n \\bmod 2 = 1)$, representing the number of vertices in the graph.\n\nThe next $\\frac{n\\cdot (n-1)}{2}$ lines each contain three integers $u, v$ and $w \\ (1 \\leq u, v \\leq n, u \\neq v, 1 \\leq w \\leq 10^9)$, indicating that there is an edge of weight $w$ between vertex $u$ and vertex $v$.", "outputFormat": "Output one integer, representing the value of the minimum-value cycle decomposition of the given graph.", "hint": "In the following sample explanations, edges are numbered in input order, and $e_i$ denotes the $i$-th edge in the input order.\n\nIn the first sample, the only cycle decomposition is $S = \\{ [e_1, e_2, e_3] \\}$. $f(e_1, e_2) + f(e_2, e_3) + f(e_3, e_1) = 1 + 1 + 1 = 3$.\n\nIn the second sample, an optimal cycle decomposition is $S = \\{ [e_3, e_8, e_9], [e_2, e_4, e_7, e_{10}, e_5, e_1, e_6] \\}$. The value of the cycle edge group $[e_3, e_8, e_9]$ is $12$, and the value of $[e_2, e_4, e_7, e_{10}, e_5, e_1, e_6]$ is $23$, so the value of the cycle decomposition is $35$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2019] Graph and Cycles", "background": "", "description": "有一个 $n$ 个点的无向有边权的完全图，其中 $n$ 是奇数。\n\n定义一个大小为 $k$ 的*环边组*为一个边构成的数组 $[e_1, e_2, \\dots, e_k]$，且具有以下性质：\n\n- $k$ 大于 $1$。\n- 对于任意 $[1, k]$ 中的整数 $i$，边 $e_i$ 与 $e_{i-1}$ 和 $e_{i+1}$ 都恰好有一个相同的端点（规定 $e_0=e_k, e_{k+1}=e_1$）。\n\n显然一个环边组中的边构成了图上的一个环。\n\n定义一个参数为两条边 $e_1, e_2$ 的函数 $f(e_1, e_2)$，其函数值为两条边中边权的较大值。\n\n定义一个环边组 $C=[e_1, e_2, \\dots, e_k]$ 的*价值*为对于任意 $[1, k]$ 中的整数 $i$，$f(e_i, e_{i+1})$ 的值之和（规定 $e_{k+1}=e_1$）。\n\n定义一个图的*环分割*为一组无交集的环边组，且这些环边组的并包含了图上所有的边。定义一个图的环分割的*价值*为其中所有环边组的价值之和。\n\n一个图可能存在多组环分割。给定一个图，你的任务是找到价值最小的环分割并输出该最小价值。", "inputFormat": "第一行包含一个整数 $n \\ (3 \\leq n \\leq 999, n \\bmod 2 = 1)$，代表图的点数。\n\n接下来的 $\\frac{n\\cdot (n-1)}{2}$ 行每行包含三个整数 $u, v$ 和 $w \\ (1 \\leq u, v \\leq n, u \\neq v, 1 \\leq w \\leq 10^9)$，代表点 $u$ 和点 $v$ 间有一条边权为 $w$ 的边。", "outputFormat": "输出一个整数，代表给定图的最小价值环分割的价值。", "hint": "以下样例解释中，边以输入顺序编号，$e_i$ 代表输入顺序中的第 $i$ 条边。\n\n第一个样例中，唯一的环分割为 $S=\\{ [e_1, e_2, e_3] \\}$。$f(e_1, e_2)+f(e_2,e_3)+f(e_3,e_1)=1+1+1=3$。\n\n第二个样例中，最优的环分割为 $S=\\{ [e_3, e_8, e_9], [e_2,e_4,e_7,e_{10},e_5,e_1,e_6] \\}$。环边组 $[e_3,e_8,e_9]$ 的价值为 $12$，$[e_2,e_4,e_7,e_{10},e_5,e_1,e_6]$ 的价值为 $23$，因此环分割的价值为 $35$。", "locale": "zh-CN"}}}
{"pid": "P5806", "type": "P", "difficulty": 6, "samples": [["2 5 1\nR-\n*-\n*-\n*T\n**", "1"], ["3 2 1\nR-T\n***", "2"], ["3 3 1\n-R-\n-*-\n-T-", "-1"], ["5 4 2\n-R---\n-****\n-****\n-****\n-----\n-----\n*T---\n----*", "5"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 10000, 10000, 10000, 10000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2019", "O2优化", "广度优先搜索 BFS", "ICPC", "SEERC"], "title": "[SEERC 2019] Stranded Robot", "background": "", "description": "在废弃宇宙飞船的残骸中，有一个机器人。残骸的某处有一个传送机，可以将这个可怜的机器人送至安全的地方。\n\n宇宙飞船不受控制地在各个方向上翻滚。一个邻近的恒星发出的光可以照到残骸上。飞船配备了人工重力发生器。人工重力总是向远离恒星的方向拉机器人，无论飞船的方向如何。\n\n机器人配备了太阳能电池板，必须依赖太阳能才能在残骸上移动。当残骸的一部分挡住了光照，机器人就无法移动了。然而，机器人总是会在移动后将自己固定住，以免被晃走或者掉入宇宙中。\n\n残骸和残骸周围的区域可以用一个大小为 $m \\times n \\times p$ 的三维坐标空间表示。每个空间中的小方格都可能是残骸的一部分或真空。飞船残骸可能不是连在一起的。\n\n机器人最开始固定在飞船的某一块上。机器人可以决定什么时候移动或什么时候等光照从合适的方向照过来。\n\n形式化地说，重力可以在六个方向上作用于机器人，包括三个坐标轴上各两个方向。当一个格子在重力的反方向上没有残骸遮挡时，这个格子就有光照。当进行移动时，起点和终点都必须同时有光照。\n\n以下是可用的移动方式：（光照从图片所示空间的上方照下；蓝色格子代表机器人；橙色格子代表可能的移动终点）\n\n1. **在平地移动**\n   假如机器人固定在某一块上，它可以移动到相邻的块上，这些块必须与起点同高。\n   机器人无法斜向移动。终点必须也有光照。\n   ![移动1](https://cdn.luogu.com.cn/upload/image_hosting/sf5pxkhr.png)\n2. **从高处跳下**\n   机器人可以从高处走出一步，然后落下。落下的高度没有限制。\n   机器人不能落入宇宙中，也不能落到没有光照的地方。\n   ![移动2](https://cdn.luogu.com.cn/upload/image_hosting/8jwv3v8y.png)\n3. **掉落**\n   假如机器人有光照且悬在空中，它可以掉落下来。这种情况可能会在重力的方向改变后产生。\n   机器人不能掉入宇宙中。\n   ![移动3](https://cdn.luogu.com.cn/upload/image_hosting/8ei3yfks.png)\n\n机器人的目标是到达传送机的所在地，如果有多种走法，则使用移动次数最少的走法。传送机工作要求机器人必须固定在飞船上。换句话说，机器人必须在某一次移动之后到达传送机的位置上，但掉落时经过它是无法工作的。传送机不会遮住光照或阻挡机器人的移动。", "inputFormat": "第一行包含三个整数 $m, n, p \\ (1 \\leq m, n, p \\leq 500)$。\n\n飞船和飞船周围的空间被描述为 $p$ 块。\n\n第 $k$ 块描述了高度为 $k$ 的格子。每块都包含 $n$ 行。\n\n第 $k$ 块的第 $i$ 行包含 $m$ 个字符，描述该格子的情况。令 $a_{ijk}$ 代表第 $j$ 个字符。\n\n- 如果 $a_{ijk}$ 是 `*`，则这个格子是残骸。\n- 如果 $a_{ijk}$ 是 `-`，则这个格子是真空。\n- 如果 $a_{ijk}$ 是 `R`，则这个格子是机器人。数据保证只有一个格子是机器人，且机器人被固定在一个残骸格子上。\n- 如果 $a_{ijk}$ 是 `T`，则这个格子是传送机。数据保证只有一个格子是传送机。", "outputFormat": "输出到达传送机处所需的最少移动数。如果无解，输出 $-1$。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2019] Stranded Robot", "background": "", "description": "In the wreckage of an abandoned spaceship, there is a robot. Somewhere in the wreckage there is a teleporter that can send this poor robot to a safe place.\n\nThe spaceship is uncontrollably tumbling in all directions. Light from a nearby star can shine onto the wreckage. The spaceship is equipped with an artificial gravity generator. Artificial gravity always pulls the robot in the direction away from the star, no matter how the ship is oriented.\n\nThe robot is equipped with solar panels and must rely on sunlight to move on the wreckage. When some part of the wreckage blocks the light, the robot cannot move. However, after moving, the robot always anchors itself so that it will not be shaken away or fall into space.\n\nThe wreckage and the area around it can be represented as a three-dimensional coordinate space of size $m \\times n \\times p$. Each small cell in the space may be part of the wreckage or vacuum. The spaceship wreckage may be disconnected.\n\nThe robot starts anchored on some piece of the ship. The robot can decide when to move or when to wait for light to shine from a suitable direction.\n\nFormally, gravity can act on the robot in six directions: two directions along each of the three coordinate axes. A cell is lit if there is no wreckage blocking it in the direction opposite to gravity. When making a move, both the starting cell and the destination cell must be lit at the same time.\n\nThe following moves are available (the light in the figures shines from above; the blue cell is the robot; orange cells are possible destinations):\n\n1. **Moving on flat ground**  \n   If the robot is anchored on a block, it can move to a neighboring block at the same height as the starting cell.  \n   The robot cannot move diagonally. The destination must also be lit.  \n   ![Move 1](https://cdn.luogu.com.cn/upload/image_hosting/sf5pxkhr.png)\n\n2. **Stepping off from a height**  \n   The robot can step out by one cell from a higher place and then fall down. There is no limit on the falling height.  \n   The robot must not fall into space, and it must not land on an unlit cell.  \n   ![Move 2](https://cdn.luogu.com.cn/upload/image_hosting/8jwv3v8y.png)\n\n3. **Falling**  \n   If the robot is lit and hanging in the air, it can fall down. This may happen after the direction of gravity changes.  \n   The robot must not fall into space.  \n   ![Move 3](https://cdn.luogu.com.cn/upload/image_hosting/8ei3yfks.png)\n\nThe robot’s goal is to reach the teleporter. If there are multiple ways, it should use the one with the fewest moves. The teleporter requires the robot to be anchored on the ship in order to work. In other words, the robot must arrive at the teleporter’s cell as the result of some move; merely passing through it while falling does not activate it. The teleporter does not block light and does not obstruct the robot’s movement.", "inputFormat": "The first line contains three integers $m, n, p \\ (1 \\leq m, n, p \\leq 500)$.\n\nThe spaceship and the surrounding space are described by $p$ layers.\n\nLayer $k$ describes the cells at height $k$. Each layer contains $n$ rows.\n\nIn layer $k$, row $i$ contains $m$ characters describing the cells. Let $a_{ijk}$ denote the $j$-th character.\n\n- If $a_{ijk}$ is `*`, the cell is wreckage.\n- If $a_{ijk}$ is `-`, the cell is vacuum.\n- If $a_{ijk}$ is `R`, the cell contains the robot. The testdata guarantees there is exactly one robot cell, and the robot is anchored on a wreckage cell.\n- If $a_{ijk}$ is `T`, the cell contains the teleporter. The testdata guarantees there is exactly one teleporter cell.", "outputFormat": "Output the minimum number of moves required to reach the teleporter. If it is impossible, output $-1$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2019] Stranded Robot", "background": "", "description": "在废弃宇宙飞船的残骸中，有一个机器人。残骸的某处有一个传送机，可以将这个可怜的机器人送至安全的地方。\n\n宇宙飞船不受控制地在各个方向上翻滚。一个邻近的恒星发出的光可以照到残骸上。飞船配备了人工重力发生器。人工重力总是向远离恒星的方向拉机器人，无论飞船的方向如何。\n\n机器人配备了太阳能电池板，必须依赖太阳能才能在残骸上移动。当残骸的一部分挡住了光照，机器人就无法移动了。然而，机器人总是会在移动后将自己固定住，以免被晃走或者掉入宇宙中。\n\n残骸和残骸周围的区域可以用一个大小为 $m \\times n \\times p$ 的三维坐标空间表示。每个空间中的小方格都可能是残骸的一部分或真空。飞船残骸可能不是连在一起的。\n\n机器人最开始固定在飞船的某一块上。机器人可以决定什么时候移动或什么时候等光照从合适的方向照过来。\n\n形式化地说，重力可以在六个方向上作用于机器人，包括三个坐标轴上各两个方向。当一个格子在重力的反方向上没有残骸遮挡时，这个格子就有光照。当进行移动时，起点和终点都必须同时有光照。\n\n以下是可用的移动方式：（光照从图片所示空间的上方照下；蓝色格子代表机器人；橙色格子代表可能的移动终点）\n\n1. **在平地移动**\n   假如机器人固定在某一块上，它可以移动到相邻的块上，这些块必须与起点同高。\n   机器人无法斜向移动。终点必须也有光照。\n   ![移动1](https://cdn.luogu.com.cn/upload/image_hosting/sf5pxkhr.png)\n2. **从高处跳下**\n   机器人可以从高处走出一步，然后落下。落下的高度没有限制。\n   机器人不能落入宇宙中，也不能落到没有光照的地方。\n   ![移动2](https://cdn.luogu.com.cn/upload/image_hosting/8jwv3v8y.png)\n3. **掉落**\n   假如机器人有光照且悬在空中，它可以掉落下来。这种情况可能会在重力的方向改变后产生。\n   机器人不能掉入宇宙中。\n   ![移动3](https://cdn.luogu.com.cn/upload/image_hosting/8ei3yfks.png)\n\n机器人的目标是到达传送机的所在地，如果有多种走法，则使用移动次数最少的走法。传送机工作要求机器人必须固定在飞船上。换句话说，机器人必须在某一次移动之后到达传送机的位置上，但掉落时经过它是无法工作的。传送机不会遮住光照或阻挡机器人的移动。", "inputFormat": "第一行包含三个整数 $m, n, p \\ (1 \\leq m, n, p \\leq 500)$。\n\n飞船和飞船周围的空间被描述为 $p$ 块。\n\n第 $k$ 块描述了高度为 $k$ 的格子。每块都包含 $n$ 行。\n\n第 $k$ 块的第 $i$ 行包含 $m$ 个字符，描述该格子的情况。令 $a_{ijk}$ 代表第 $j$ 个字符。\n\n- 如果 $a_{ijk}$ 是 `*`，则这个格子是残骸。\n- 如果 $a_{ijk}$ 是 `-`，则这个格子是真空。\n- 如果 $a_{ijk}$ 是 `R`，则这个格子是机器人。数据保证只有一个格子是机器人，且机器人被固定在一个残骸格子上。\n- 如果 $a_{ijk}$ 是 `T`，则这个格子是传送机。数据保证只有一个格子是传送机。", "outputFormat": "输出到达传送机处所需的最少移动数。如果无解，输出 $-1$。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5807", "type": "P", "difficulty": 6, "samples": [["2\n1\n0\n2\n1 1\n1 2\n", "1\n0\n"], ["5\n3\n1 2\n1 3\n1 2\n3\n1 2\n1 1\n0\n3\n1 2\n1 1\n1 3\n3\n1 2\n1 3\n1 1\n3\n0\n0\n0", "0\n1\n0\n1\n1\n"], ["4\n6\n1 4 \n1 4 \n1 2 \n2 5 5 \n2 3 1 \n0 \n7\n2 6 5 \n3 3 6 1 \n4 4 2 4 5 \n3 3 7 2 \n4 6 3 1 6 \n4 4 2 5 5 \n1 3 \n10\n7 8 9 2 6 7 9 6 \n5 6 10 5 1 3 \n5 5 7 7 9 6 \n4 5 7 9 7 \n4 1 2 7 9 \n6 4 10 8 1 10 3 \n8 2 3 4 10 5 1 3 8 \n7 7 10 6 1 2 3 7 \n8 8 8 10 2 4 4 6 1 \n6 9 8 1 8 9 9 \n15\n11 10 10 10 11 2 13 10 8 14 9 14 \n9 5 3 10 1 15 11 8 13 11 \n7 1 15 13 7 15 8 5 \n7 8 14 7 1 2 3 8 \n3 11 4 10 \n7 7 12 7 4 12 11 12 \n10 10 12 3 13 15 1 2 8 11 12 \n12 9 4 13 10 2 6 13 10 7 6 7 11 \n6 4 1 2 8 12 1 \n15 1 11 9 9 7 7 6 6 2 8 12 2 8 12 2 \n10 12 10 6 10 3 1 6 3 9 4 \n12 15 14 10 14 14 9 8 7 7 11 13 4 \n7 12 3 10 6 1 1 4 \n6 12 5 8 3 8 12 \n5 10 10 1 11 2 \n", "2\n190080\n120594\n887148\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模板题"], "title": "【模板】BEST 定理 / Which Dreamed It", "background": "请注意本题与真正的 BEST 定理略有出入：BEST 定理没有从 $1$ 出发的限制，且回路的边序列是循环同构的。", "description": "有 $n$ 个房间，每个房间有若干把钥匙能够打开特定房间的门。\n\n最初你在房间 $1$。每当你到达一个房间，你可以选择该房间的一把钥匙，前往该钥匙对应的房间，并将该钥匙丢到垃圾桶中。\n\n你希望最终回到房间 $1$，且垃圾桶中有所有的钥匙。\n\n你需要求出方案数，答案对 $10^6 + 3$ 取模。两组方案不同，当且仅当使用钥匙的顺序不同。\n\n注意，每把钥匙都是不同的。\n\n原 BZOJ3659。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行一个整数 $n$。\n\n接下来 $n$ 行，第 $i$ 行描述房间 $i$：\n\n首先一个数 $s$，表示这个房间的钥匙数目，接下来 $s$ 个数，分别描述每把钥匙能够打开的房间的门。", "outputFormat": "对于每组数据，一行一个整数，表示答案对 $10^6+3$ 取模后的值。", "hint": "### 样例解释\n\n* 样例 $1$ 说明\n\n在第一组样例中，没有钥匙，则方案数为 $1$。\n\n在第二组样例中，你不可能使用第二个房间的钥匙，所以方案数为 $0$。\n\n* 样例 $2$ 说明\n\n只要使用完所有的钥匙即可，不一定要经过所有的房间。\n\n* 样例 $3$ 说明\n\n前三组数据在取模前的答案分别是 $2,190080,49476320425715737559040000000$。\n\n### 数据范围\n\n对于 $50\\%$ 的数据，$n \\le 4$，$\\sum s \\le 30$。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 15$，$1 \\le n \\le 100$，$0 \\le \\sum s \\le 3141592$。\n\n2021/5/14 加强 by [SSerxhs](https://www.luogu.com.cn/user/29826)&[滑大稽](https://www.luogu.com.cn/user/203743)", "locale": "zh-CN", "translations": {"en": {"title": "[Template] BEST Theorem / Which Dreamed It", "background": "Please note that this problem is slightly different from the real BEST Theorem: the BEST Theorem does not require starting from $1$, and the edge sequence of the circuit is considered up to cyclic isomorphism.", "description": "There are $n$ rooms, and each room has several keys that can open the door to a specific room.\n\nAt the beginning, you are in room $1$. Each time you arrive at a room, you may choose one key in that room, go to the room corresponding to that key, and throw that key into the trash bin.\n\nYou want to finally return to room $1$, and have all the keys in the trash bin.\n\nYou need to count the number of valid plans, modulo $10^6 + 3$. Two plans are different if and only if the order of using keys is different.\n\nNote that every key is distinct.\n\nOriginally BZOJ3659.", "inputFormat": "**This problem contains multiple test cases.**\n\nThe first line contains an integer $T$, the number of test cases.\n\nFor each test case:\n\nThe first line contains an integer $n$.\n\nThe next $n$ lines describe the rooms. Line $i$ describes room $i$:\n\nFirst a number $s$, the number of keys in this room, followed by $s$ numbers, each describing which room’s door that key can open.", "outputFormat": "For each test case, output one integer per line, the answer modulo $10^6 + 3$.", "hint": "### Sample Explanation\n\n* Sample $1$\n\nIn the first test case, there are no keys, so the number of plans is $1$.\n\nIn the second test case, you cannot use the key in the second room, so the number of plans is $0$.\n\n* Sample $2$\n\nIt is enough to use up all the keys; you do not necessarily need to visit all rooms.\n\n* Sample $3$\n\nBefore taking modulo, the answers for the first three test cases are $2,190080,49476320425715737559040000000$, respectively.\n\n### Constraints\n\nFor $50\\%$ of the testdata, $n \\le 4$, $\\sum s \\le 30$.\n\nFor $100\\%$ of the testdata, $1 \\le T \\le 15$, $1 \\le n \\le 100$, $0 \\le \\sum s \\le 3141592$.\n\nStrengthened on 2021/5/14 by [SSerxhs](https://www.luogu.com.cn/user/29826) & [滑大稽](https://www.luogu.com.cn/user/203743).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】BEST 定理 / Which Dreamed It", "background": "请注意本题与真正的 BEST 定理略有出入：BEST 定理没有从 $1$ 出发的限制，且回路的边序列是循环同构的。", "description": "有 $n$ 个房间，每个房间有若干把钥匙能够打开特定房间的门。\n\n最初你在房间 $1$。每当你到达一个房间，你可以选择该房间的一把钥匙，前往该钥匙对应的房间，并将该钥匙丢到垃圾桶中。\n\n你希望最终回到房间 $1$，且垃圾桶中有所有的钥匙。\n\n你需要求出方案数，答案对 $10^6 + 3$ 取模。两组方案不同，当且仅当使用钥匙的顺序不同。\n\n注意，每把钥匙都是不同的。\n\n原 BZOJ3659。", "inputFormat": "**本题有多组数据。**\n\n第一行一个整数 $T$，表示数据组数。\n\n对于每组数据：\n\n第一行一个整数 $n$。\n\n接下来 $n$ 行，第 $i$ 行描述房间 $i$：\n\n首先一个数 $s$，表示这个房间的钥匙数目，接下来 $s$ 个数，分别描述每把钥匙能够打开的房间的门。", "outputFormat": "对于每组数据，一行一个整数，表示答案对 $10^6+3$ 取模后的值。", "hint": "### 样例解释\n\n* 样例 $1$ 说明\n\n在第一组样例中，没有钥匙，则方案数为 $1$。\n\n在第二组样例中，你不可能使用第二个房间的钥匙，所以方案数为 $0$。\n\n* 样例 $2$ 说明\n\n只要使用完所有的钥匙即可，不一定要经过所有的房间。\n\n* 样例 $3$ 说明\n\n前三组数据在取模前的答案分别是 $2,190080,49476320425715737559040000000$。\n\n### 数据范围\n\n对于 $50\\%$ 的数据，$n \\le 4$，$\\sum s \\le 30$。\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 15$，$1 \\le n \\le 100$，$0 \\le \\sum s \\le 3141592$。\n\n2021/5/14 加强 by [SSerxhs](https://www.luogu.com.cn/user/29826)&[滑大稽](https://www.luogu.com.cn/user/203743)", "locale": "zh-CN"}}}
{"pid": "P5808", "type": "P", "difficulty": 7, "samples": [["40 5 6\n1 2 3 5 8 13\n1 3 4 9 6 7\n1 1 4 5 1 4", "349344375"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "递推", "O2优化", "快速傅里叶变换 FFT", "快速数论变换 NTT", "模板题"], "title": "【模板】常系数非齐次线性递推", "background": "NaCly\\_Fish 一到机房，所有做题的人便都看着她笑。有的叫道，“鱼鱼，你怎么又爆零了！”她不回答，对教练说：“要两道数学题，一道数据结构。”便打开电脑。他们又故意的高声嚷道，“你怎么连 exgcd 都写不对了！”......\n\nNaCly\\_Fish 自己知道不能和同机房的神仙们谈天，便只好向隔壁初一的说话。有一回对我说道，“你学过 OI 么？”我略略点一点头。他说，“学过 OI，...... 我便考你一考。常系数线性齐次递推，怎样算的？”我想，机房垫底 AFO 的人，也配考我么？便回过脸去，不再理会。NaCly\\_Fish 等了许久，很恳切的说道，“不会算罢？…… 我教给你，记着！这算法应该好好记着，将来比赛的时候，做题要用。”我懒懒的答她道，“谁要你教，不是把递推系数写在矩阵第一列，剩下斜着放 $1$，再快速幂么？”NaCly\\_Fish 显出极高兴的样子，将两个指头的长指甲敲着课桌，点头说，“对呀对呀！...... 这还有四样求法，你知道么？”......\n****  \nNaCly\\_Fish 看见了这题，她根本不会做。  \n看在她那么菜的份上，请您做了这题，帮帮她吧。", "description": "已知递推式：  \n\n$$a_n = P(n) + \\sum\\limits_{i=1}^k f_i \\times a_{n-i}$$  \n\n其中 $P(x)$ 是一个 $m$ 次多项式。\n\n给定 $f_1,f_2,\\dots,f_k$，$a_0,a_1,\\dots,a_{k-1}$，和 $P(x)$ 的各项系数，求 $a_n$。  \n答案对 $998244353$ 取模。", "inputFormat": "第一行三个正整数 $n,m,k$。  \n第二行 $k$ 个整数，表示 $a_0,a_1,\\dots,a_{k-1}$。  \n第三行 $k$ 个整数，表示 $f_1,f_2,\\dots,f_k$。  \n第四行 $m+1$ 个整数，由低到高的表示 $P(x)$ 的系数。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 10^9$，$1\\le m,k \\le 30000$。    \n除第一行外，输入的所有数在 $[0,998244353)$ 范围内。  \n\n数据有一定梯度。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Non-homogeneous Linear Recurrence with Constant Coefficients", "background": "As soon as NaCly_Fish arrived in the computer lab, everyone who was solving problems looked at her and laughed. Some shouted, “Fishy, why did you get zero points again!” She did not answer, and said to the coach: “Two math problems, and one data structure problem.” Then she turned on the computer. They deliberately shouted louder, “How can you even write exgcd wrong!”......\n\nNaCly_Fish knew she could not chat with the geniuses in the same lab, so she had to talk to the first-year middle school students next door. Once she asked me, “Have you learned OI?” I nodded slightly. She said, “If you have learned OI, ...... then I will test you. For a homogeneous linear recurrence with constant coefficients, how do you compute it?” I thought, someone who is AFO and last in the lab, how dare she test me? So I turned my head away and ignored her. NaCly_Fish waited for a long time and said sincerely, “You can’t do it, right? ... I will teach you, remember this! You should memorize this algorithm well. You will need it when solving problems in future contests.” I lazily replied, “Who needs you to teach me? Isn’t it just writing the recurrence coefficients in the first column of a matrix, putting the remaining $1$’s along the diagonal, and then doing fast exponentiation?” NaCly_Fish looked very happy, tapped the desk with her two long fingernails, nodded, and said, “Yes, yes! ...... There are four more methods as well, do you know them?”......\n****  \nAfter NaCly_Fish saw this problem, she could not solve it at all.  \nSince she is so bad at it, please solve this problem and help her.", "description": "Given the recurrence:\n\n$$a_n = P(n) + \\sum\\limits_{i=1}^k f_i \\times a_{n-i}$$\n\nwhere $P(x)$ is a polynomial of degree $m$.\n\nGiven $f_1,f_2,\\dots,f_k$, $a_0,a_1,\\dots,a_{k-1}$, and the coefficients of $P(x)$, find $a_n$.  \nOutput the answer modulo $998244353$.", "inputFormat": "The first line contains three positive integers $n,m,k$.  \nThe second line contains $k$ integers, representing $a_0,a_1,\\dots,a_{k-1}$.  \nThe third line contains $k$ integers, representing $f_1,f_2,\\dots,f_k$.  \nThe fourth line contains $m+1$ integers, from low degree to high degree, representing the coefficients of $P(x)$.", "outputFormat": "Output one line with one integer, representing the answer.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1\\le n \\le 10^9$, $1\\le m,k \\le 30000$.  \nExcept for the first line, all input numbers are in the range $[0,998244353)$.  \n\nThe testdata has multiple difficulty levels.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】常系数非齐次线性递推", "background": "NaCly\\_Fish 一到机房，所有做题的人便都看着她笑。有的叫道，“鱼鱼，你怎么又爆零了！”她不回答，对教练说：“要两道数学题，一道数据结构。”便打开电脑。他们又故意的高声嚷道，“你怎么连 exgcd 都写不对了！”......\n\nNaCly\\_Fish 自己知道不能和同机房的神仙们谈天，便只好向隔壁初一的说话。有一回对我说道，“你学过 OI 么？”我略略点一点头。他说，“学过 OI，...... 我便考你一考。常系数线性齐次递推，怎样算的？”我想，机房垫底 AFO 的人，也配考我么？便回过脸去，不再理会。NaCly\\_Fish 等了许久，很恳切的说道，“不会算罢？…… 我教给你，记着！这算法应该好好记着，将来比赛的时候，做题要用。”我懒懒的答她道，“谁要你教，不是把递推系数写在矩阵第一列，剩下斜着放 $1$，再快速幂么？”NaCly\\_Fish 显出极高兴的样子，将两个指头的长指甲敲着课桌，点头说，“对呀对呀！...... 这还有四样求法，你知道么？”......\n****  \nNaCly\\_Fish 看见了这题，她根本不会做。  \n看在她那么菜的份上，请您做了这题，帮帮她吧。", "description": "已知递推式：  \n\n$$a_n = P(n) + \\sum\\limits_{i=1}^k f_i \\times a_{n-i}$$  \n\n其中 $P(x)$ 是一个 $m$ 次多项式。\n\n给定 $f_1,f_2,\\dots,f_k$，$a_0,a_1,\\dots,a_{k-1}$，和 $P(x)$ 的各项系数，求 $a_n$。  \n答案对 $998244353$ 取模。", "inputFormat": "第一行三个正整数 $n,m,k$。  \n第二行 $k$ 个整数，表示 $a_0,a_1,\\dots,a_{k-1}$。  \n第三行 $k$ 个整数，表示 $f_1,f_2,\\dots,f_k$。  \n第四行 $m+1$ 个整数，由低到高的表示 $P(x)$ 的系数。", "outputFormat": "输出一行一个整数表示答案。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 10^9$，$1\\le m,k \\le 30000$。    \n除第一行外，输入的所有数在 $[0,998244353)$ 范围内。  \n\n数据有一定梯度。", "locale": "zh-CN"}}}
{"pid": "P5809", "type": "P", "difficulty": 7, "samples": [["6\n0 1 2 2 4 3\n", "0 1 998244351 6 998244329 113\n"], ["7\n0 1 1 4 5 1 4\n", "0 1 998244352 998244351 10 7 998244202\n"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "O2优化", "快速傅里叶变换 FFT", "快速数论变换 NTT", "模板题"], "title": "【模板】多项式复合逆", "background": "神鱼姐姐太鸽了 qwq", "description": "令 $n-1$ 次多项式 $F(x)=\\sum\\limits _{i=0}^{n-1} a_ix^i$。\n\n给定 $n$ 和 $F(x)$ 的各项系数，要求一个 $n-1$ 次多项式 $G(x)$ 满足：\n\n$$\nG(F(x))\\equiv x\\pmod{x^n}\n$$\n\n求 $G(x)$ 的各项系数对 $998244353$ 取模的结果。\n\n保证 $a_0=0$，$a_1\\neq 0$。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个非负整数 $a_0,a_1,a_2,\\ldots,a_{n-1}$，其中 $a_i$ 表示 $F(x)$ 的第 $i$ 项系数。保证 $a_0=0$，$a_1\\neq 0$。", "outputFormat": "一行 $n$ 个非负整数，第 $i$ 个非负整数表示 $G(x)$ 的第 $i-1$ 项系数。", "hint": "对于 $100\\%$ 的数据，$2\\leq n\\leq 2^{14}$，$0\\leq a_i < 998,244,353$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Polynomial Composition Inverse", "background": "Shen Yu (姐姐) is procrastinating too much qwq.", "description": "Let $F(x)=\\sum\\limits _{i=0}^{n-1} a_ix^i$ be a degree $n-1$ polynomial.\n\nGiven $n$ and the coefficients of $F(x)$, find a degree $n-1$ polynomial $G(x)$ such that:\n\n$$\nG(F(x))\\equiv x\\pmod{x^n}\n$$\n\nOutput the coefficients of $G(x)$ modulo $998244353$.\n\nIt is guaranteed that $a_0=0$ and $a_1\\neq 0$.", "inputFormat": "The first line contains a positive integer $n$.\n\nThe second line contains $n$ non-negative integers $a_0,a_1,a_2,\\ldots,a_{n-1}$, where $a_i$ is the coefficient of the $i$-th term of $F(x)$. It is guaranteed that $a_0=0$ and $a_1\\neq 0$.", "outputFormat": "Output one line with $n$ non-negative integers. The $i$-th non-negative integer is the coefficient of the $(i-1)$-th term of $G(x)$.", "hint": "For $100\\%$ of the testdata, $2\\leq n\\leq 2^{14}$ and $0\\leq a_i < 998,244,353$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】多项式复合逆", "background": "神鱼姐姐太鸽了 qwq", "description": "令 $n-1$ 次多项式 $F(x)=\\sum\\limits _{i=0}^{n-1} a_ix^i$。\n\n给定 $n$ 和 $F(x)$ 的各项系数，要求一个 $n-1$ 次多项式 $G(x)$ 满足：\n\n$$\nG(F(x))\\equiv x\\pmod{x^n}\n$$\n\n求 $G(x)$ 的各项系数对 $998244353$ 取模的结果。\n\n保证 $a_0=0$，$a_1\\neq 0$。", "inputFormat": "第一行一个正整数 $n$。\n\n第二行 $n$ 个非负整数 $a_0,a_1,a_2,\\ldots,a_{n-1}$，其中 $a_i$ 表示 $F(x)$ 的第 $i$ 项系数。保证 $a_0=0$，$a_1\\neq 0$。", "outputFormat": "一行 $n$ 个非负整数，第 $i$ 个非负整数表示 $G(x)$ 的第 $i-1$ 项系数。", "hint": "对于 $100\\%$ 的数据，$2\\leq n\\leq 2^{14}$，$0\\leq a_i < 998,244,353$。", "locale": "zh-CN"}}}
{"pid": "P5810", "type": "P", "difficulty": 4, "samples": [["20", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2004", "四川", "各省省选", "O2优化"], "title": "[SCOI2004] 文本的输入", "background": "", "description": "人们在输入文本时，除了逐个输入这种方式外，还可以利用剪贴板进行复制，如果打入一个字母需要 $1$ 的时间，将已输入的部分复制进剪贴板需要 $5$ 的时间（`Ctrl`+`A`，`Ctrl`+`C`，再取消全选状态），将剪贴板的内容粘贴出来需要 $2$ 的时间（`Ctrl`+`V`）。\n\n如果我们不关心输入文本的内容，而只关心输入文本的长度，要输入一个长度**不低于** $n$ 的文本最少需要多少时间？\n\n**请注意，数据范围与原题略有不同。**\n　　", "inputFormat": "一个正整数 $n$，表示文本的长度。", "outputFormat": "一个正整数 $t$，表示需要的最短的时间。", "hint": "样例解释：先用 $7$ 时间打出 $7$ 个字符，再复制（用去 $5$ 时间），粘贴两次（用去 $4$ 时间），即可用 $16$ 时间打出 $21$ 个字符。\n\n对于 $20\\%$ 的数据，$n\\le 10$；\n\n对于 $60\\%$ 的数据，$n\\le 10^4$；\n\n对于 $100\\%$ 的数据，$n\\le 4\\times 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2004] Text Input", "background": "", "description": "When people input text, besides typing character by character, they can also use the clipboard to copy. Typing one letter takes $1$ unit of time. Copying the part that has already been typed into the clipboard takes $5$ units of time (`Ctrl`+`A`, `Ctrl`+`C`, then cancel the select-all state). Pasting the clipboard content takes $2$ units of time (`Ctrl`+`V`).\n\nIf we do not care about the actual content of the text and only care about its length, what is the minimum time needed to input a text whose length is **at least** $n$?\n\n**Note: The Constraints are slightly different from the original problem.**", "inputFormat": "A positive integer $n$, representing the length of the text.", "outputFormat": "A positive integer $t$, representing the minimum time needed.", "hint": "Sample explanation: First spend $7$ units of time to type $7$ characters, then copy (costs $5$ units of time), paste twice (costs $4$ units of time), and you can type $21$ characters in $16$ units of time.\n\nFor $20\\%$ of the testdata, $n\\le 10$.\n\nFor $60\\%$ of the testdata, $n\\le 10^4$.\n\nFor $100\\%$ of the testdata, $n\\le 4\\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2004] 文本的输入", "background": "", "description": "人们在输入文本时，除了逐个输入这种方式外，还可以利用剪贴板进行复制，如果打入一个字母需要 $1$ 的时间，将已输入的部分复制进剪贴板需要 $5$ 的时间（`Ctrl`+`A`，`Ctrl`+`C`，再取消全选状态），将剪贴板的内容粘贴出来需要 $2$ 的时间（`Ctrl`+`V`）。\n\n如果我们不关心输入文本的内容，而只关心输入文本的长度，要输入一个长度**不低于** $n$ 的文本最少需要多少时间？\n\n**请注意，数据范围与原题略有不同。**\n　　", "inputFormat": "一个正整数 $n$，表示文本的长度。", "outputFormat": "一个正整数 $t$，表示需要的最短的时间。", "hint": "样例解释：先用 $7$ 时间打出 $7$ 个字符，再复制（用去 $5$ 时间），粘贴两次（用去 $4$ 时间），即可用 $16$ 时间打出 $21$ 个字符。\n\n对于 $20\\%$ 的数据，$n\\le 10$；\n\n对于 $60\\%$ 的数据，$n\\le 10^4$；\n\n对于 $100\\%$ 的数据，$n\\le 4\\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P5811", "type": "P", "difficulty": 7, "samples": [["9 10\n4 2 3\n0 1\n0 2\n0 3\n0 4\n0 6\n0 8\n1 7\n3 7\n4 5\n5 6\n", "1 1 3 1 2 2 3 1 3\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["2019", "IOI", "Special Judge"], "title": "[IOI 2019] 景点划分", "background": "### 滥用本题评测将封号\n\n注：本题按照传统题方式进行评测，即，你的程序**需要包含 `main` 函数**。", "description": "巴库有 $n$ 处景点，从 $0$ 到 $n-1$ 编号。另外还有 $m$ 条双向道路，从 $0$ 到 $m-1$ 编号。每条道路连接两个不同的景点。经由这些道路，可以在任意两处景点之间往来。\n\nFatima 打算在三天之内参观完所有这些景点。她已经决定要在第一天参观 $a$ 处景点，第二天参观 $b$ 处景点，第三天参观 $c$ 处景点。因此，她要将 $n$ 处景点划分为三个集合 $A$、$B$ 和 $C$，其规模分别为 $a$、$b$ 和 $c$。每处景点恰好属于其中一个集合，因此有 $a+b+c=n$。\n\nFatima 想要找到这样的景点划分 $A$、$B$ 和 $C$，使得这三个集合中的至少两个是联通的。一个景点集合 $S$ 被称为是联通的，如果能够经由这些道路在 $S$ 中的任意两处景点之间往来，且不需要经过不在 $S$ 中的景点。如果满足上述要求，则景点的一个划分 $A$、$B$ 和 $C$ 被称为是合法的。\n\n请帮助 Fatima 找到一个合法的景点划分 （给定 $a$、$b$ 和 $c$），或者判断合法的划分不存在。如果存在多个合法的划分，你可以给出其中的任何一个。\n\n**实现细节**\n\n你需要实现下述函数：\n`int [] find_split（int n,int a,int b,int c,int [] p,int [] q）`\n- $n$：景点的数量。\n- $a$、$b$ 和 $c$：集合$A$、$B$ 和 $C$ 的期望规模。\n- $p$ 和 $q$：长度为 $m$ 的数组，包含道路的端点。对每个 $i$ （$ 0 \\le i \\le m-1 $），$p[i]$ 和 $q[i]$ 是由道路 $i$ 连接的两处景点。\n- 该函数需要返回一个长度为 $n$ 的数组。记该数组为 $s$。如果不存在合法的划分，$s$ 应当包含 $n$ 个零。否则，对于 $0 \\le i \\le n-1$，$s[i]$ 应为 $1$、$2$ 或 $3$ 中的一个。以分别表示景点 $i$ 被归到集合 $A$、$B$ 或 $C$\n", "inputFormat": "第一行，两个正整数 $n$、$m$。\n\n第二行，三个正整数 $a$、$b$ 和 $c$。\n\n第 $3+i$ 行 （对于 $ 0 \\le i \\le m-1 $） 两个正整数 $p[i]$、$q[i]$。\n\n意义见题目描述", "outputFormat": "共一行，内容为 `find_split` 所返回的数组。", "hint": "**样例说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sltz4zao.png)\n\n一个可能解为 $[1,1,3,1,2,2,3,1,3]$。这个解刻画了这样的划分：$A=\\{0,1,3,7\\}$，$B=\\{4,5\\}$，$C=\\{2,6,8\\}$。集合 $A$ 和 $B$ 是联通的。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，\n- $3 \\le n \\le 10^5$。\n- $2 \\le m \\le 2 \\times 10^5$。\n- $1 \\le a,b,c \\le n$。\n- $a+b+c=n$。\n- 每一对景点之间至多有一条道路。\n- 经由这些道路，可以在任何两处景点之间往来。\n- 对于 $0 \\le i \\le m-1$，有 $0 \\le p[i],q[i] \\le n-1$ 和 $p[i] ≠ q[i] $。\n\n**子任务**\n1. （$7$ 分） 每处景点至多可做两条道路的端点。\n2. （$11$ 分） $a=1$\n3. （$22$ 分） $m=n-1$\n4. （$24$ 分） $n \\le 2500$，$m \\le 5000$。\n5. （$36$ 分） 没有任何附加限制。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2019] Sightseeing Splitting", "background": "### Account bans for abusing this problem's judging.\n\nNote: This problem is judged in the traditional way, i.e., your program **must contain the `main` function**.", "description": "Baku has $n$ sightseeing spots, numbered from $0$ to $n-1$. There are also $m$ bidirectional roads, numbered from $0$ to $m-1$. Each road connects two different spots. Using these roads, it is possible to travel between any two spots.\n\nFatima plans to visit all the spots within three days. She has decided to visit $a$ spots on the first day, $b$ spots on the second day, and $c$ spots on the third day. Therefore, she wants to split the $n$ spots into three sets $A$, $B$, and $C$, with sizes $a$, $b$, and $c$ respectively. Each spot belongs to exactly one set, so $a+b+c=n$.\n\nFatima wants to find a split into $A$, $B$, and $C$ such that at least two of these three sets are connected. A set of spots $S$ is called connected if it is possible to travel between any two spots in $S$ using the roads, without having to pass through any spot not in $S$. If the above requirement is satisfied, then the split into $A$, $B$, and $C$ is called valid.\n\nPlease help Fatima find a valid split (given $a$, $b$, and $c$), or determine that no valid split exists. If multiple valid splits exist, you may output any one of them.\n\n**Implementation details**\n\nYou need to implement the following function:  \n`int [] find_split（int n,int a,int b,int c,int [] p,int [] q）`\n- $n$: the number of sightseeing spots.\n- $a$, $b$, and $c$: the desired sizes of sets $A$, $B$, and $C$.\n- $p$ and $q$: arrays of length $m$ containing the endpoints of the roads. For each $i$ ($ 0 \\le i \\le m-1 $), $p[i]$ and $q[i]$ are the two spots connected by road $i$.\n- The function should return an array of length $n$. Call this array $s$. If no valid split exists, $s$ should contain $n$ zeros. Otherwise, for $0 \\le i \\le n-1$, $s[i]$ should be one of $1$, $2$, or $3$, indicating that spot $i$ is assigned to set $A$, $B$, or $C$, respectively.", "inputFormat": "The first line contains two positive integers $n$ and $m$.\n\nThe second line contains three positive integers $a$, $b$, and $c$.\n\nLine $3+i$ (for $ 0 \\le i \\le m-1 $) contains two positive integers $p[i]$ and $q[i]$.\n\nTheir meanings are the same as in the statement.", "outputFormat": "One line, containing the array returned by `find_split`.", "hint": "**Sample explanation**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sltz4zao.png)\n\nOne possible solution is $[1,1,3,1,2,2,3,1,3]$. This solution describes the following split: $A=\\{0,1,3,7\\}$, $B=\\{4,5\\}$, $C=\\{2,6,8\\}$. Sets $A$ and $B$ are connected.\n\n**Constraints**\n\nFor $100\\%$ of the testdata:\n- $3 \\le n \\le 10^5$.\n- $2 \\le m \\le 2 \\times 10^5$.\n- $1 \\le a,b,c \\le n$.\n- $a+b+c=n$.\n- There is at most one road between each pair of spots.\n- Using these roads, it is possible to travel between any two spots.\n- For $0 \\le i \\le m-1$, $0 \\le p[i],q[i] \\le n-1$ and $p[i] ≠ q[i]$.\n\n**Subtasks**\n1. ($7$ points) Each spot can be an endpoint of at most two roads.\n2. ($11$ points) $a=1$.\n3. ($22$ points) $m=n-1$.\n4. ($24$ points) $n \\le 2500$, $m \\le 5000$.\n5. ($36$ points) No additional constraints.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2019] 景点划分", "background": "### 滥用本题评测将封号\n\n注：本题按照传统题方式进行评测，即，你的程序**需要包含 `main` 函数**。", "description": "巴库有 $n$ 处景点，从 $0$ 到 $n-1$ 编号。另外还有 $m$ 条双向道路，从 $0$ 到 $m-1$ 编号。每条道路连接两个不同的景点。经由这些道路，可以在任意两处景点之间往来。\n\nFatima 打算在三天之内参观完所有这些景点。她已经决定要在第一天参观 $a$ 处景点，第二天参观 $b$ 处景点，第三天参观 $c$ 处景点。因此，她要将 $n$ 处景点划分为三个集合 $A$、$B$ 和 $C$，其规模分别为 $a$、$b$ 和 $c$。每处景点恰好属于其中一个集合，因此有 $a+b+c=n$。\n\nFatima 想要找到这样的景点划分 $A$、$B$ 和 $C$，使得这三个集合中的至少两个是联通的。一个景点集合 $S$ 被称为是联通的，如果能够经由这些道路在 $S$ 中的任意两处景点之间往来，且不需要经过不在 $S$ 中的景点。如果满足上述要求，则景点的一个划分 $A$、$B$ 和 $C$ 被称为是合法的。\n\n请帮助 Fatima 找到一个合法的景点划分 （给定 $a$、$b$ 和 $c$），或者判断合法的划分不存在。如果存在多个合法的划分，你可以给出其中的任何一个。\n\n**实现细节**\n\n你需要实现下述函数：\n`int [] find_split（int n,int a,int b,int c,int [] p,int [] q）`\n- $n$：景点的数量。\n- $a$、$b$ 和 $c$：集合$A$、$B$ 和 $C$ 的期望规模。\n- $p$ 和 $q$：长度为 $m$ 的数组，包含道路的端点。对每个 $i$ （$ 0 \\le i \\le m-1 $），$p[i]$ 和 $q[i]$ 是由道路 $i$ 连接的两处景点。\n- 该函数需要返回一个长度为 $n$ 的数组。记该数组为 $s$。如果不存在合法的划分，$s$ 应当包含 $n$ 个零。否则，对于 $0 \\le i \\le n-1$，$s[i]$ 应为 $1$、$2$ 或 $3$ 中的一个。以分别表示景点 $i$ 被归到集合 $A$、$B$ 或 $C$\n", "inputFormat": "第一行，两个正整数 $n$、$m$。\n\n第二行，三个正整数 $a$、$b$ 和 $c$。\n\n第 $3+i$ 行 （对于 $ 0 \\le i \\le m-1 $） 两个正整数 $p[i]$、$q[i]$。\n\n意义见题目描述", "outputFormat": "共一行，内容为 `find_split` 所返回的数组。", "hint": "**样例说明**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sltz4zao.png)\n\n一个可能解为 $[1,1,3,1,2,2,3,1,3]$。这个解刻画了这样的划分：$A=\\{0,1,3,7\\}$，$B=\\{4,5\\}$，$C=\\{2,6,8\\}$。集合 $A$ 和 $B$ 是联通的。\n\n**数据范围**\n\n对于 $100\\%$ 的数据，\n- $3 \\le n \\le 10^5$。\n- $2 \\le m \\le 2 \\times 10^5$。\n- $1 \\le a,b,c \\le n$。\n- $a+b+c=n$。\n- 每一对景点之间至多有一条道路。\n- 经由这些道路，可以在任何两处景点之间往来。\n- 对于 $0 \\le i \\le m-1$，有 $0 \\le p[i],q[i] \\le n-1$ 和 $p[i] ≠ q[i] $。\n\n**子任务**\n1. （$7$ 分） 每处景点至多可做两条道路的端点。\n2. （$11$ 分） $a=1$\n3. （$22$ 分） $m=n-1$\n4. （$24$ 分） $n \\le 2500$，$m \\le 5000$。\n5. （$36$ 分） 没有任何附加限制。", "locale": "zh-CN"}}}
