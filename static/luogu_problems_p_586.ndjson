{"pid": "P12892", "type": "P", "difficulty": 2, "samples": [["4", "3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "2025", "蓝桥杯国赛"], "title": "[蓝桥杯 2025 国 Java B] 弹跳鞋", "background": "", "description": "小 A 穿上了一双神奇的弹跳鞋，他可以给弹跳鞋充能 $x$ 点能量并启动，然后弹跳鞋会连续弹跳 $x$ 次，过程中无法停止。\n\n其中，第 $i$ 次弹跳时小 A 可以跳跃的距离恰好为 $x - i + 1$。\n\n小 A 正站在一条路上，他希望跳到距离自己 $L$ 的位置，你可以认为小 A 只能向正反两个方向跳跃，不需要考虑路的宽度。\n\n小 A 想知道，如果他只给鞋子充能一次，他在所有弹跳完成后能否停在目标位置。如果能，输出最低需要多少能量；如果不能，输出 $-1$。", "inputFormat": "输入包含一行一个整数，$L$。\n", "outputFormat": "输出一行一个整数表示答案。", "hint": "**【评测用例规模与约定】**\n\n对于 $40\\%$ 的评测用例，$L \\leq 100$。\n\n对于 $60\\%$ 的评测用例，$L \\leq 5000$。\n\n对于 $100\\%$ 的评测用例，$1 \\leq L \\leq 10^{18}$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 国 Java B] 弹跳鞋", "background": "", "description": "小 A 穿上了一双神奇的弹跳鞋，他可以给弹跳鞋充能 $x$ 点能量并启动，然后弹跳鞋会连续弹跳 $x$ 次，过程中无法停止。\n\n其中，第 $i$ 次弹跳时小 A 可以跳跃的距离恰好为 $x - i + 1$。\n\n小 A 正站在一条路上，他希望跳到距离自己 $L$ 的位置，你可以认为小 A 只能向正反两个方向跳跃，不需要考虑路的宽度。\n\n小 A 想知道，如果他只给鞋子充能一次，他在所有弹跳完成后能否停在目标位置。如果能，输出最低需要多少能量；如果不能，输出 $-1$。", "inputFormat": "输入包含一行一个整数，$L$。\n", "outputFormat": "输出一行一个整数表示答案。", "hint": "**【评测用例规模与约定】**\n\n对于 $40\\%$ 的评测用例，$L \\leq 100$。\n\n对于 $60\\%$ 的评测用例，$L \\leq 5000$。\n\n对于 $100\\%$ 的评测用例，$1 \\leq L \\leq 10^{18}$。\n", "locale": "zh-CN"}}}
{"pid": "P12893", "type": "P", "difficulty": 4, "samples": [["5 3\n1 2\n2 3\n4 5", "2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["并查集", "2025", "蓝桥杯国赛"], "title": "[蓝桥杯 2025 国 Java B] 隔离网络", "background": "", "description": "小蓝负责一家科技公司的数据中心安全。该数据中心包含 $N$ 台服务器，编号为 $1$ 到 $N$，以及 $M$ 条数据链路，编号为 $1$ 到 $M$。每条数据链路都连接着两台服务器。\n\n最近，数据中心遭到了网络攻击，病毒正在通过这些链路快速蔓延。为了阻止病毒扩散，小蓝需要采取紧急措施，对网络进行隔离。他计划进行一系列操作，每次操作都包含以下两个步骤：\n\n1. 确定当前网络中所有连通的服务器集群——即通过链路直接或间接相连的服务器集合。\n2. 对于每个连通的服务器集群，禁用该集群内编号最小的那条数据链路，以切断病毒传播的途径。\n\n小蓝会重复执行上述操作，直到数据中心的所有数据链路都被禁用、整个数据中心的网络都被隔离。对此，请你帮助小蓝计算出，他总共需要进行多少次操作？", "inputFormat": "输入数据第一行包含两个正整数 $N$ 和 $M$，分别表示服务器的数量和数据链路的数量。\n\n接下来 $M$ 行，每行包含两个正整数 $u_i$ 和 $v_i$，表示第 $i$ 条数据链路连接的服务器编号。数据链路的编号按照输入顺序从上到下依次为 $1$ 到 $M$。\n", "outputFormat": "输出一个整数，表示小蓝需要进行的操作次数。", "hint": "**【样例说明】**\n\n第一次操作：\n\n1. 识别两个连通的服务器集群：\n   - 集群 1：服务器 $(1,2,3)$\n   - 集群 2：服务器 $(4,5)$\n\n2. 对于集群 1，禁用编号最小的链路 $1-2$；对于集群 2，禁用编号最小的链路 $4-5$。\n\n第一次操作结束后，仅剩余一个连通的服务器集群：服务器 $(2,3)$。\n\n第二次操作：\n\n1. 识别剩余的连通服务器集群: 服务器 $(2,3)$。\n2. 禁用编号最小的链路 $2-3$。\n\n第二次操作结束后，网络中不再有连通的服务器集群，隔离完成。总共需要 2 次操作。\n\n**【评测用例规模与约定】**\n\n对于 $40\\%$ 的评测用例，$2 \\leq N \\leq 10^3$，$1 \\leq M \\leq \\min(\\frac{N \\times (N-1)}{2}, 2 \\times 10^3)$。\n\n对于 $100\\%$ 的评测用例，$2 \\leq N \\leq 10^5$，$1 \\leq M \\leq \\min(\\frac{N \\times (N-1)}{2}, 2 \\times 10^5)$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 国 Java B] 隔离网络", "background": "", "description": "小蓝负责一家科技公司的数据中心安全。该数据中心包含 $N$ 台服务器，编号为 $1$ 到 $N$，以及 $M$ 条数据链路，编号为 $1$ 到 $M$。每条数据链路都连接着两台服务器。\n\n最近，数据中心遭到了网络攻击，病毒正在通过这些链路快速蔓延。为了阻止病毒扩散，小蓝需要采取紧急措施，对网络进行隔离。他计划进行一系列操作，每次操作都包含以下两个步骤：\n\n1. 确定当前网络中所有连通的服务器集群——即通过链路直接或间接相连的服务器集合。\n2. 对于每个连通的服务器集群，禁用该集群内编号最小的那条数据链路，以切断病毒传播的途径。\n\n小蓝会重复执行上述操作，直到数据中心的所有数据链路都被禁用、整个数据中心的网络都被隔离。对此，请你帮助小蓝计算出，他总共需要进行多少次操作？", "inputFormat": "输入数据第一行包含两个正整数 $N$ 和 $M$，分别表示服务器的数量和数据链路的数量。\n\n接下来 $M$ 行，每行包含两个正整数 $u_i$ 和 $v_i$，表示第 $i$ 条数据链路连接的服务器编号。数据链路的编号按照输入顺序从上到下依次为 $1$ 到 $M$。\n", "outputFormat": "输出一个整数，表示小蓝需要进行的操作次数。", "hint": "**【样例说明】**\n\n第一次操作：\n\n1. 识别两个连通的服务器集群：\n   - 集群 1：服务器 $(1,2,3)$\n   - 集群 2：服务器 $(4,5)$\n\n2. 对于集群 1，禁用编号最小的链路 $1-2$；对于集群 2，禁用编号最小的链路 $4-5$。\n\n第一次操作结束后，仅剩余一个连通的服务器集群：服务器 $(2,3)$。\n\n第二次操作：\n\n1. 识别剩余的连通服务器集群: 服务器 $(2,3)$。\n2. 禁用编号最小的链路 $2-3$。\n\n第二次操作结束后，网络中不再有连通的服务器集群，隔离完成。总共需要 2 次操作。\n\n**【评测用例规模与约定】**\n\n对于 $40\\%$ 的评测用例，$2 \\leq N \\leq 10^3$，$1 \\leq M \\leq \\min(\\frac{N \\times (N-1)}{2}, 2 \\times 10^3)$。\n\n对于 $100\\%$ 的评测用例，$2 \\leq N \\leq 10^5$，$1 \\leq M \\leq \\min(\\frac{N \\times (N-1)}{2}, 2 \\times 10^5)$。\n", "locale": "zh-CN"}}}
{"pid": "P12894", "type": "P", "difficulty": 4, "samples": [["5 3\n1 2 3 4 5\n1 1 5\n2 1 2\n1 1 5", "15\n10"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["树状数组", "2025", "蓝桥杯国赛"], "title": "[蓝桥杯 2025 国 Java B] 智能交通信号灯", "background": "", "description": "蓝桥智慧城市在一条主干道上沿路安装了 $N$ 个智能交通信号灯，这些信号灯按位置从 $1$ 到 $N$ 编号。每个信号灯都有着一种控制模式，对于第 $i$ 个信号灯，其控制模式用 $A_i$ 表示，$A_i$ 是一个大于等于 $1$ 的整数。\n\n为了评估信号灯配置的 “多样性”，交通管理专家提出了一种度量方式：对于任意两个不同位置 $x$ 和 $y$，它们的多样性分数被定义为大于等于 $1$ 的整数中，第一个既不是 $A_x$ 也不是 $A_y$ 的数值，记作 $\\text{mex}(A_x, A_y)$。例如，当 $A_x = 1$ 且 $A_y = 2$ 时，$\\text{mex}(1, 2) = 3$；当 $A_x = 1$ 且 $A_y = 3$ 时，$\\text{mex}(1, 3) = 2$；当 $A_x = 2$ 且 $A_y = 2$ 时，$\\text{mex}(2, 2) = 1$。\n\n政府希望通过分析和调整信号灯配置，提升道路通行效率。为此，他们计划执行 $M$ 条操作指令，每条指令为以下两类之一：\n\n- $1\\ l\\ r$：查询操作。计算所有满足 $l \\leq i < j \\leq r$ 的信号灯对 $(A_i, A_j)$，其多样性分数 $\\text{mex}(A_i, A_j)$ 的总和。\n- $2\\ k\\ x$：调整操作。将第 $k$ 个信号灯的控制模式 $A_k$ 修改为新的值 $x$。\n\n现在，请你协助政府依次处理这 $M$ 次操作，并输出每个查询操作的结果。", "inputFormat": "第一行包含两个整数 $N$ 和 $M$，分别表示信号灯的数量和操作指令的数量。\n\n第二行包含 $N$ 个整数 $A_1, A_2, \\ldots, A_N$，表示初始的信号灯控制模式。\n\n接下来 $M$ 行，每行描述一条操作指令，格式如上所述。\n", "outputFormat": "对于每个查询操作，输出一行包含一个整数，表示多样性分数的总和。", "hint": "**【样例说明】**\n\n初始时信号灯的控制模式依次为：$1, 2, 3, 4, 5$。第一次查询区间 $[1, 5]$，$\\text{mex}$ 值分别为 $3, 2, 2, 2, 1, 1, 1, 1, 1, 1$，总和为 $15$。\n\n第二次操作后，信号灯的控制模式依次为：$2, 2, 3, 4, 5$。第二次查询区间 $[1, 5]$，$\\text{mex}$ 值均为 $1$，总和为 $10$。\n\n**【评测用例规模与约定】**\n\n对于 $10\\%$ 的评测用例，$2 \\leq N, M \\leq 100$，$1 \\leq l < r \\leq N$，$1 \\leq k \\leq N$，$1 \\leq A_i, x \\leq 10^3$。\n\n对于 $40\\%$ 的评测用例，$2 \\leq N, M \\leq 10^3$，$1 \\leq l < r \\leq N$，$1 \\leq k \\leq N$，$1 \\leq A_i, x \\leq 10^5$。\n\n对于 $100\\%$ 的评测用例，$2 \\leq N, M \\leq 10^5$，$1 \\leq l < r \\leq N$，$1 \\leq k \\leq N$，$1 \\leq A_i, x \\leq 10^9$。\n", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[蓝桥杯 2025 国 Java B] 智能交通信号灯", "background": "", "description": "蓝桥智慧城市在一条主干道上沿路安装了 $N$ 个智能交通信号灯，这些信号灯按位置从 $1$ 到 $N$ 编号。每个信号灯都有着一种控制模式，对于第 $i$ 个信号灯，其控制模式用 $A_i$ 表示，$A_i$ 是一个大于等于 $1$ 的整数。\n\n为了评估信号灯配置的 “多样性”，交通管理专家提出了一种度量方式：对于任意两个不同位置 $x$ 和 $y$，它们的多样性分数被定义为大于等于 $1$ 的整数中，第一个既不是 $A_x$ 也不是 $A_y$ 的数值，记作 $\\text{mex}(A_x, A_y)$。例如，当 $A_x = 1$ 且 $A_y = 2$ 时，$\\text{mex}(1, 2) = 3$；当 $A_x = 1$ 且 $A_y = 3$ 时，$\\text{mex}(1, 3) = 2$；当 $A_x = 2$ 且 $A_y = 2$ 时，$\\text{mex}(2, 2) = 1$。\n\n政府希望通过分析和调整信号灯配置，提升道路通行效率。为此，他们计划执行 $M$ 条操作指令，每条指令为以下两类之一：\n\n- $1\\ l\\ r$：查询操作。计算所有满足 $l \\leq i < j \\leq r$ 的信号灯对 $(A_i, A_j)$，其多样性分数 $\\text{mex}(A_i, A_j)$ 的总和。\n- $2\\ k\\ x$：调整操作。将第 $k$ 个信号灯的控制模式 $A_k$ 修改为新的值 $x$。\n\n现在，请你协助政府依次处理这 $M$ 次操作，并输出每个查询操作的结果。", "inputFormat": "第一行包含两个整数 $N$ 和 $M$，分别表示信号灯的数量和操作指令的数量。\n\n第二行包含 $N$ 个整数 $A_1, A_2, \\ldots, A_N$，表示初始的信号灯控制模式。\n\n接下来 $M$ 行，每行描述一条操作指令，格式如上所述。\n", "outputFormat": "对于每个查询操作，输出一行包含一个整数，表示多样性分数的总和。", "hint": "**【样例说明】**\n\n初始时信号灯的控制模式依次为：$1, 2, 3, 4, 5$。第一次查询区间 $[1, 5]$，$\\text{mex}$ 值分别为 $3, 2, 2, 2, 1, 1, 1, 1, 1, 1$，总和为 $15$。\n\n第二次操作后，信号灯的控制模式依次为：$2, 2, 3, 4, 5$。第二次查询区间 $[1, 5]$，$\\text{mex}$ 值均为 $1$，总和为 $10$。\n\n**【评测用例规模与约定】**\n\n对于 $10\\%$ 的评测用例，$2 \\leq N, M \\leq 100$，$1 \\leq l < r \\leq N$，$1 \\leq k \\leq N$，$1 \\leq A_i, x \\leq 10^3$。\n\n对于 $40\\%$ 的评测用例，$2 \\leq N, M \\leq 10^3$，$1 \\leq l < r \\leq N$，$1 \\leq k \\leq N$，$1 \\leq A_i, x \\leq 10^5$。\n\n对于 $100\\%$ 的评测用例，$2 \\leq N, M \\leq 10^5$，$1 \\leq l < r \\leq N$，$1 \\leq k \\leq N$，$1 \\leq A_i, x \\leq 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P12895", "type": "P", "difficulty": 4, "samples": [["8\n3 8 5 4 1 2 1 1\n1 2\n2 3\n2 4\n5 4\n4 6\n7 6\n8 7\n", "13\n4\n3 2 1 2 4 6 7"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2020", "POI（波兰）", "Special Judge", "树的直径"], "title": "[POI 2019/2020 R2] 假期 Wakacje Bajtazara", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4844)。", "description": "**题目译自 [XXVII Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi27-2/dashboard/) [Wakacje Bajtazara](https://szkopul.edu.pl/problemset/problem/pXcijJbDyC_jRAjkoxBH9sCO/statement/)**\n\n众所周知，Bajtazar 是一个非常忙碌的人，他从不畏惧字节王国中的任何生活挑战。不过，他终于决定给自己放个假，于是前往比特王国度假。比特王国中有 $n$ 座城市，通过 $n-1$ 条双向道路连接，确保任意两座城市之间都可以通行。Bajtazar 不想连续两天待在同一座城市，但他也不喜欢长途跋涉，所以每天晚上他计划只通过一条道路前往邻近城市。他为每座城市设定了吸引力系数，用来衡量游览这座城市的愉悦程度。当然，他希望度过一个尽可能愉快的假期。\n\n然而，Bajtazar 就是 Bajtazar，他总是喜欢将愉快与实用相结合。这次假期也不例外，他打算利用假期时间开始撰写回忆录。具体来说，他计划在假期中每隔一天游览城市，其余日子用来写作。\n\n他希望规划一个长度为 $2k-1$ 天的假期，其中在 $k$ 个奇数日游览城市，在 $k-1$ 个偶数日写作回忆录。游览过的城市的吸引力系数总和必须尽可能大，同时他不想重复游览同一座城市。不过，在写作的日子，他并不介意待在之前已经去过的城市。请你帮助他规划一个最愉快的假期。", "inputFormat": "输入的第一行包含一个整数 $n$ $(1 \\leq n \\leq 1000000)$，表示比特王国中的城市数量。城市编号从 $1$ 到 $n$。\n\n第二行包含 $n$ 个整数 $w_{1}, w_{2}, \\ldots, w_{n}$ $(1 \\leq w_{i} \\leq 1000000)$，用单个空格分隔，$w_{i}$ 表示编号为 $i$ 的城市的吸引力系数。\n\n接下来的 $n-1$ 行描述比特王国的道路，每行包含两个整数 $a_{i}$ 和 $b_{i}$ $(1 \\leq a_{i}, b_{i} \\leq n)$，用单个空格分隔，表示编号为 $a_{i}$ 和 $b_{i}$ 的城市之间有一条双向道路。", "outputFormat": "你的程序应输出三行内容：\n\n第一行包含一个整数 $W$，表示 Bajtazar 假期中能获得的最大吸引力系数总和。\n\n第二行包含一个整数 $k$，表示 Bajtazar 在假期中游览的城市数量。\n\n第三行包含 $2k-1$ 个整数，用单个空格分隔，表示 Bajtazar 在假期各天所在的城市编号。如果存在多种最大 $W$ 的方案，你的程序可以输出任意一种。", "hint": "**样例 1 解释**\n\n下图展示了比特王国的道路网络示意图。Bajtazar 将游览城市 $3$、$1$、$4$ 和 $7$，这些城市的吸引力系数总和为 $5+3+4+1=13$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hb2mrr0b.png)\n\n**附加样例**\n\n1. 该样例满足四座城市连成一条路径，每座城市的吸引力系数均为 $1$。\n2. 该样例满足七座城市构成一棵满二叉树，每座城市的吸引力系数等于其所在深度（根节点深度为 $1$）。\n3. 该样例满足一千座城市，每座城市（除了城市 $1$）都与城市 $1$ 直接相连，每座城市的吸引力系数均为 $1$。\n4. 该样例满足一百万座城市连成一条路径，每座城市的吸引力系数为 $1$、$2$ 或 $3$。\n\n详细子任务附加限制及分值如下表所示。\n\n如果你的程序正确输出了第一行（即 $W$），但其他行不正确，可以获得该测试点 $40\\%$ 的分数。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $n \\leq 1000$，所有 $w_{i}=1$ | $20$   |\n| $2$      | $n \\leq 1000$         | $10$   |\n| $3$      | 所有 $w_{i}=1$        | $40$   |\n| $4$      | 无附加限制            | $30$   |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2019/2020 R2] 假期 Wakacje Bajtazara", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4844)。", "description": "**题目译自 [XXVII Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi27-2/dashboard/) [Wakacje Bajtazara](https://szkopul.edu.pl/problemset/problem/pXcijJbDyC_jRAjkoxBH9sCO/statement/)**\n\n众所周知，Bajtazar 是一个非常忙碌的人，他从不畏惧字节王国中的任何生活挑战。不过，他终于决定给自己放个假，于是前往比特王国度假。比特王国中有 $n$ 座城市，通过 $n-1$ 条双向道路连接，确保任意两座城市之间都可以通行。Bajtazar 不想连续两天待在同一座城市，但他也不喜欢长途跋涉，所以每天晚上他计划只通过一条道路前往邻近城市。他为每座城市设定了吸引力系数，用来衡量游览这座城市的愉悦程度。当然，他希望度过一个尽可能愉快的假期。\n\n然而，Bajtazar 就是 Bajtazar，他总是喜欢将愉快与实用相结合。这次假期也不例外，他打算利用假期时间开始撰写回忆录。具体来说，他计划在假期中每隔一天游览城市，其余日子用来写作。\n\n他希望规划一个长度为 $2k-1$ 天的假期，其中在 $k$ 个奇数日游览城市，在 $k-1$ 个偶数日写作回忆录。游览过的城市的吸引力系数总和必须尽可能大，同时他不想重复游览同一座城市。不过，在写作的日子，他并不介意待在之前已经去过的城市。请你帮助他规划一个最愉快的假期。", "inputFormat": "输入的第一行包含一个整数 $n$ $(1 \\leq n \\leq 1000000)$，表示比特王国中的城市数量。城市编号从 $1$ 到 $n$。\n\n第二行包含 $n$ 个整数 $w_{1}, w_{2}, \\ldots, w_{n}$ $(1 \\leq w_{i} \\leq 1000000)$，用单个空格分隔，$w_{i}$ 表示编号为 $i$ 的城市的吸引力系数。\n\n接下来的 $n-1$ 行描述比特王国的道路，每行包含两个整数 $a_{i}$ 和 $b_{i}$ $(1 \\leq a_{i}, b_{i} \\leq n)$，用单个空格分隔，表示编号为 $a_{i}$ 和 $b_{i}$ 的城市之间有一条双向道路。", "outputFormat": "你的程序应输出三行内容：\n\n第一行包含一个整数 $W$，表示 Bajtazar 假期中能获得的最大吸引力系数总和。\n\n第二行包含一个整数 $k$，表示 Bajtazar 在假期中游览的城市数量。\n\n第三行包含 $2k-1$ 个整数，用单个空格分隔，表示 Bajtazar 在假期各天所在的城市编号。如果存在多种最大 $W$ 的方案，你的程序可以输出任意一种。", "hint": "**样例 1 解释**\n\n下图展示了比特王国的道路网络示意图。Bajtazar 将游览城市 $3$、$1$、$4$ 和 $7$，这些城市的吸引力系数总和为 $5+3+4+1=13$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/hb2mrr0b.png)\n\n**附加样例**\n\n1. 该样例满足四座城市连成一条路径，每座城市的吸引力系数均为 $1$。\n2. 该样例满足七座城市构成一棵满二叉树，每座城市的吸引力系数等于其所在深度（根节点深度为 $1$）。\n3. 该样例满足一千座城市，每座城市（除了城市 $1$）都与城市 $1$ 直接相连，每座城市的吸引力系数均为 $1$。\n4. 该样例满足一百万座城市连成一条路径，每座城市的吸引力系数为 $1$、$2$ 或 $3$。\n\n详细子任务附加限制及分值如下表所示。\n\n如果你的程序正确输出了第一行（即 $W$），但其他行不正确，可以获得该测试点 $40\\%$ 的分数。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $n \\leq 1000$，所有 $w_{i}=1$ | $20$   |\n| $2$      | $n \\leq 1000$         | $10$   |\n| $3$      | 所有 $w_{i}=1$        | $40$   |\n| $4$      | 无附加限制            | $30$   |", "locale": "zh-CN"}}}
{"pid": "P12896", "type": "P", "difficulty": 0, "samples": [["3\n404004111014001410011", "2\n24"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "POI（波兰）", "Special Judge"], "title": "[POI 2019/2020 R2] 四叉树 Drzewo czwórkowe", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4845)。", "description": "**题目译自 [XXVII Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi27-2/dashboard/) [Drzewo czwórkowe](https://szkopul.edu.pl/problemset/problem/GcP-wwgKv1HiCzuFRKE6n7-U/statement/)**\n\n给定一个尺寸为 $2^{m} \\times 2^{m}$ 的方形位图，每个像素要么是白色，要么是黑色。这样的位图可以用四叉树进行压缩表示。如果位图中的所有像素都是白色，四叉树只有一个节点，标记为 $0$；如果所有像素都是黑色，四叉树也只有一个节点，标记为 $1$；否则，四叉树的根节点标记为 $4$，并拥有四个子树，分别对应位图的四个象限（大小为 $2^{m-1} \\times 2^{m-1}$），顺序为左上、右上、左下和右下。四叉树可以用一个由字符 `0`、`1` 和 `4` 组成的字符串来描述：树的描述从根节点的标记开始，后面依次是各个子树的描述。下图展示了一个 $m=3$ 的示例位图及其对应的四叉树，其描述字符串为 `404004111014001410011`。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bzvpzqvq.png)\n\n我们将**黑色联通块**定义为相互邻接的最大黑色像素集合（像素之间如果共享边则视为邻接）。对于给定的描述位图的字符串，计算位图中的黑色联通块数量以及最大黑色联通块的大小。在上述示例中，有两个黑色联通块，面积分别为 $24$ 和 $5$。\n\n正式来说，黑色联通块是指黑色像素的集合，其中任意两个像素可以通过一系列黑色像素连接起来，每两个连续的像素共享边。黑色联通块被称为最大黑色联通块，当且仅当无法通过添加任何其他黑色像素来扩大它，同时仍保持为黑色联通块。在本题中，我们只考虑最大黑色联通块。", "inputFormat": "输入的第一行包含一个整数 $m$ $(m \\geq 0)$，表示位图的大小。第二行包含一个非空的字符串，由字符 `0`、`1` 和 `4` 组成，用于编码位图。输入保证是合法的，特别是四叉树的高度（即从根节点到最深处节点的路径上的边数）不超过 $m$。位图中至少包含一个黑色像素。", "outputFormat": "你的程序应输出两行内容：\n\n第一行包含一个整数，表示位图中的黑色联通块数量。\n\n第二行包含一个整数，表示最大黑色联通块的大小。由于这个数字可能非常大，需输出其对 $10^{9}+7$ 取模的结果。", "hint": "**附加样例**\n\n1. 该样例满足 $m=3$，位图的四个角各有一个 $2 \\times 2$ 的黑色方块，因此包含 $4$ 个大小为 $4$ 的黑色联通块；\n2. 该样例满足 $m=9$，位图被涂成棋盘格样式，因此包含 $\\left(2^{9}\\right)^{2} / 2 = 2^{17}$ 个大小为 $1$ 的黑色联通块；\n3. 该样例满足 $m=16$，位图全为黑色，因此包含 $1$ 个大小为 $\\left(2^{16}\\right)^{2} = 2^{32}$ 的黑色联通块。\n\n\n详细子任务附加限制及分值如下表所示。\n\n如果你的程序只正确输出了两行中的一行，可以获得该测试点 $50\\%$ 的分数。但在这种情况下，仍然需要输出两行，每行包含一个 $0$ 到 $10^{9}+6$ 之间的整数。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $m \\leq 10$           | $24$   |\n| $2$      | $m, n \\leq 1000$      | $36$   |\n| $3$      | $m, n \\leq 10^{6}$    | $32$   |\n| $4$      | $m \\leq 10^{9}, n \\leq 10^{6}$ | $8$    |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2019/2020 R2] 四叉树 Drzewo czwórkowe", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4845)。", "description": "**题目译自 [XXVII Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi27-2/dashboard/) [Drzewo czwórkowe](https://szkopul.edu.pl/problemset/problem/GcP-wwgKv1HiCzuFRKE6n7-U/statement/)**\n\n给定一个尺寸为 $2^{m} \\times 2^{m}$ 的方形位图，每个像素要么是白色，要么是黑色。这样的位图可以用四叉树进行压缩表示。如果位图中的所有像素都是白色，四叉树只有一个节点，标记为 $0$；如果所有像素都是黑色，四叉树也只有一个节点，标记为 $1$；否则，四叉树的根节点标记为 $4$，并拥有四个子树，分别对应位图的四个象限（大小为 $2^{m-1} \\times 2^{m-1}$），顺序为左上、右上、左下和右下。四叉树可以用一个由字符 `0`、`1` 和 `4` 组成的字符串来描述：树的描述从根节点的标记开始，后面依次是各个子树的描述。下图展示了一个 $m=3$ 的示例位图及其对应的四叉树，其描述字符串为 `404004111014001410011`。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bzvpzqvq.png)\n\n我们将**黑色联通块**定义为相互邻接的最大黑色像素集合（像素之间如果共享边则视为邻接）。对于给定的描述位图的字符串，计算位图中的黑色联通块数量以及最大黑色联通块的大小。在上述示例中，有两个黑色联通块，面积分别为 $24$ 和 $5$。\n\n正式来说，黑色联通块是指黑色像素的集合，其中任意两个像素可以通过一系列黑色像素连接起来，每两个连续的像素共享边。黑色联通块被称为最大黑色联通块，当且仅当无法通过添加任何其他黑色像素来扩大它，同时仍保持为黑色联通块。在本题中，我们只考虑最大黑色联通块。", "inputFormat": "输入的第一行包含一个整数 $m$ $(m \\geq 0)$，表示位图的大小。第二行包含一个非空的字符串，由字符 `0`、`1` 和 `4` 组成，用于编码位图。输入保证是合法的，特别是四叉树的高度（即从根节点到最深处节点的路径上的边数）不超过 $m$。位图中至少包含一个黑色像素。", "outputFormat": "你的程序应输出两行内容：\n\n第一行包含一个整数，表示位图中的黑色联通块数量。\n\n第二行包含一个整数，表示最大黑色联通块的大小。由于这个数字可能非常大，需输出其对 $10^{9}+7$ 取模的结果。", "hint": "**附加样例**\n\n1. 该样例满足 $m=3$，位图的四个角各有一个 $2 \\times 2$ 的黑色方块，因此包含 $4$ 个大小为 $4$ 的黑色联通块；\n2. 该样例满足 $m=9$，位图被涂成棋盘格样式，因此包含 $\\left(2^{9}\\right)^{2} / 2 = 2^{17}$ 个大小为 $1$ 的黑色联通块；\n3. 该样例满足 $m=16$，位图全为黑色，因此包含 $1$ 个大小为 $\\left(2^{16}\\right)^{2} = 2^{32}$ 的黑色联通块。\n\n\n详细子任务附加限制及分值如下表所示。\n\n如果你的程序只正确输出了两行中的一行，可以获得该测试点 $50\\%$ 的分数。但在这种情况下，仍然需要输出两行，每行包含一个 $0$ 到 $10^{9}+6$ 之间的整数。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $m \\leq 10$           | $24$   |\n| $2$      | $m, n \\leq 1000$      | $36$   |\n| $3$      | $m, n \\leq 10^{6}$    | $32$   |\n| $4$      | $m \\leq 10^{9}, n \\leq 10^{6}$ | $8$    |", "locale": "zh-CN"}}}
{"pid": "P12897", "type": "P", "difficulty": 0, "samples": [["3\n1 5\n10 6\n20 7\n1 4 2 1", "5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2020", "POI（波兰）"], "title": "[POI 2019/2020 R2] 伟大倒塌 Wielki Upadek", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4846)。", "description": "**题目译自 [XXVII Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi27-2/dashboard/) [Wielki Upadek](https://szkopul.edu.pl/problemset/problem/1asri4nHTSmINAOKJ-iUZf6f/statement/)**\n\nBajtek 拥有一套相当可观的 $n$ 张多米诺骨牌收藏，这些骨牌高度各不相同，他喜欢将它们排成一列，观看它们一个接一个倒下的壮观景象。为了他最新的创意项目（暂命名为「伟大倒塌」），他决定利用手中所有的多米诺骨牌，将它们依次排列在数轴上的某些整数位置。\n\n当 Bajtek 终于按照计划摆好所有骨牌时，妈妈送来了生日礼物——两盒装满较小多米诺骨牌的新礼盒。每盒中的骨牌高度相同，且都比已摆放的骨牌矮。而且，按照 Bajtek 的要求，其中一盒骨牌的高度是另一盒骨牌高度的倍数。由于 Bajtek 不想改变已摆放骨牌的位置，他决定将新骨牌放置在空闲的位置上。\n\n根据「伟大倒塌」项目的设想，当所有骨牌摆放完毕后，Bajtek 会选择其中一块，向某个方向（向左或向右）推动，以尽可能多地推倒骨牌。根据经验，他知道每块倒下的骨牌会推倒后续所有骨牌，前提是这些骨牌与它的距离不超过它的高度。\n\nBajtek 对如何处理这些新骨牌感到困惑。请你帮助他，计算如果他在合适的位置放置新骨牌，最多能推倒多少块多米诺骨牌。", "inputFormat": "输入的第一行包含一个整数 $n$ $(1 \\leq n \\leq 200000)$，表示 Bajtek 原本拥有的并已在「伟大倒塌」项目中摆放的骨牌数量。\n\n接下来的 $n$ 行描述 Bajtek 摆放的骨牌，第 $i$ 行包含两个整数 $x_{i}, h_{i}$ $(0 \\leq x_{i} \\leq 10^{18}, x_{i-1} < x_{i}, 1 \\leq h_{i} \\leq 2000000)$，用单个空格分隔，分别表示第 $i$ 块骨牌的位置和高度。\n\n最后一行包含四个整数 $N_{1}, H_{1}, N_{2}, H_{2}$ $(0 \\leq N_{1}, N_{2} \\leq 10^{18}, 1 \\leq H_{1}, H_{2} \\leq 10^{6})$，用单个空格分隔，分别表示第一盒骨牌的数量和高度，以及第二盒骨牌的数量和高度。新骨牌比旧骨牌矮，因此 $H_{1}, H_{2} < h_{i}$ 对每个 $i$ 都成立。按照 Bajtek 的要求，$H_{2}$ 能整除 $H_{1}$ 或 $H_{1}$ 能整除 $H_{2}$。", "outputFormat": "输出一行，包含一个整数，表示在「伟大倒塌」项目中最多能倒下的骨牌数量。", "hint": "**样例 1 解释**\n\n一种可行的摆放方式是：在位置 $6$ 放置一块高度为 $4$ 的骨牌，在位置 $4$ 和 $5$ 各放置一块高度为 $1$ 的骨牌，然后向右推动位置 $1$ 上的骨牌。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/owsl2ogj.png)\n\n**附加样例**\n\n1. 该样例满足 $n=1, N_{1}=N_{2}=10, H_{1}=2, H_{2}=4$；\n2. 该样例满足 $n=6$，骨牌摆放在位置 $0,3,5,10,12,15$，$N_{1}+N_{2}=3, H_{1}=H_{2}=1$，最多能推倒 $7$ 块骨牌；\n3. 该样例满足 $n=200000$，摆放的骨牌高度为 $91$，位置为 $190$ 的连续倍数，$N_{1}=N_{2}=n, H_{1}=90, H_{2}=9$，新骨牌数量恰好能推倒所有骨牌。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $n \\leq 2000$     | $25$   |\n| $2$      | $H_{1}=H_{2}$    | $25$   |\n| $3$      | 无附加限制           | $50$   |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2019/2020 R2] 伟大倒塌 Wielki Upadek", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4846)。", "description": "**题目译自 [XXVII Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi27-2/dashboard/) [Wielki Upadek](https://szkopul.edu.pl/problemset/problem/1asri4nHTSmINAOKJ-iUZf6f/statement/)**\n\nBajtek 拥有一套相当可观的 $n$ 张多米诺骨牌收藏，这些骨牌高度各不相同，他喜欢将它们排成一列，观看它们一个接一个倒下的壮观景象。为了他最新的创意项目（暂命名为「伟大倒塌」），他决定利用手中所有的多米诺骨牌，将它们依次排列在数轴上的某些整数位置。\n\n当 Bajtek 终于按照计划摆好所有骨牌时，妈妈送来了生日礼物——两盒装满较小多米诺骨牌的新礼盒。每盒中的骨牌高度相同，且都比已摆放的骨牌矮。而且，按照 Bajtek 的要求，其中一盒骨牌的高度是另一盒骨牌高度的倍数。由于 Bajtek 不想改变已摆放骨牌的位置，他决定将新骨牌放置在空闲的位置上。\n\n根据「伟大倒塌」项目的设想，当所有骨牌摆放完毕后，Bajtek 会选择其中一块，向某个方向（向左或向右）推动，以尽可能多地推倒骨牌。根据经验，他知道每块倒下的骨牌会推倒后续所有骨牌，前提是这些骨牌与它的距离不超过它的高度。\n\nBajtek 对如何处理这些新骨牌感到困惑。请你帮助他，计算如果他在合适的位置放置新骨牌，最多能推倒多少块多米诺骨牌。", "inputFormat": "输入的第一行包含一个整数 $n$ $(1 \\leq n \\leq 200000)$，表示 Bajtek 原本拥有的并已在「伟大倒塌」项目中摆放的骨牌数量。\n\n接下来的 $n$ 行描述 Bajtek 摆放的骨牌，第 $i$ 行包含两个整数 $x_{i}, h_{i}$ $(0 \\leq x_{i} \\leq 10^{18}, x_{i-1} < x_{i}, 1 \\leq h_{i} \\leq 2000000)$，用单个空格分隔，分别表示第 $i$ 块骨牌的位置和高度。\n\n最后一行包含四个整数 $N_{1}, H_{1}, N_{2}, H_{2}$ $(0 \\leq N_{1}, N_{2} \\leq 10^{18}, 1 \\leq H_{1}, H_{2} \\leq 10^{6})$，用单个空格分隔，分别表示第一盒骨牌的数量和高度，以及第二盒骨牌的数量和高度。新骨牌比旧骨牌矮，因此 $H_{1}, H_{2} < h_{i}$ 对每个 $i$ 都成立。按照 Bajtek 的要求，$H_{2}$ 能整除 $H_{1}$ 或 $H_{1}$ 能整除 $H_{2}$。", "outputFormat": "输出一行，包含一个整数，表示在「伟大倒塌」项目中最多能倒下的骨牌数量。", "hint": "**样例 1 解释**\n\n一种可行的摆放方式是：在位置 $6$ 放置一块高度为 $4$ 的骨牌，在位置 $4$ 和 $5$ 各放置一块高度为 $1$ 的骨牌，然后向右推动位置 $1$ 上的骨牌。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/owsl2ogj.png)\n\n**附加样例**\n\n1. 该样例满足 $n=1, N_{1}=N_{2}=10, H_{1}=2, H_{2}=4$；\n2. 该样例满足 $n=6$，骨牌摆放在位置 $0,3,5,10,12,15$，$N_{1}+N_{2}=3, H_{1}=H_{2}=1$，最多能推倒 $7$ 块骨牌；\n3. 该样例满足 $n=200000$，摆放的骨牌高度为 $91$，位置为 $190$ 的连续倍数，$N_{1}=N_{2}=n, H_{1}=90, H_{2}=9$，新骨牌数量恰好能推倒所有骨牌。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $n \\leq 2000$     | $25$   |\n| $2$      | $H_{1}=H_{2}$    | $25$   |\n| $3$      | 无附加限制           | $50$   |", "locale": "zh-CN"}}}
{"pid": "P12898", "type": "P", "difficulty": 0, "samples": [["6 2\n001010\n6\n2", "2\n3\n2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2020", "POI（波兰）"], "title": "[POI 2019/2020 R2] 牢骚 Marudny Bajtazar", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4847)。", "description": "**题目译自 [XXVII Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi27-2/dashboard/) [Marudny Bajtazar](https://szkopul.edu.pl/problemset/problem/kvwWom2nxVBqipEfeiMtidn5/statement/)**\n\n圣诞节即将来临，Bajtazar 决定购买新的装饰品来装点自己的家。今年，他想尝试极简风格，计划买一条只有绿色和红色两种颜色的灯链。于是，他前往附近的灯饰店，请店主展示双色灯链。\n\n然而，多年在字节王国从事各种工作的经历，让 Bajtazar 养成了对任何事物（哪怕是最琐碎的）都有自己看法的习惯，而且他从不吝于表达意见（即便没人愿意听）。特别是在时尚和美学方面，他的观念尤为固执，这对那些接待过他的店主来说尤为头疼，因为他们总是要听他抱怨商品哪里不尽如人意。\n\n这次也不例外：Bajtazar 盯着店主展示的灯链看了半天，终于开口说：「总体来说，这条灯链还不错，但整体美感被一个问题破坏了——链条里没有一段连续四个灯泡的片段，颜色依次是红-绿-绿-红。」由于店主没有其他灯链可供选择，他决定更换其中一个灯泡的颜色，以满足这个要求。\n\nBajtazar 满意地点了点头，但没过多久又说：「现在还差一段颜色为绿-红-绿-绿-红的片段。」店主又换了一个灯泡的颜色。Bajtazar 接着说：「现在看起来很美，但还缺少另一个对颜色搭配很重要的片段。」\n\n虽然 Bajtazar 非常耐心地解释为什么灯链还不完美，但他担心店主更换灯泡颜色的方式过于随意，可能无法快速达到目标。为了更高效地解决问题，他请你帮忙编写一个程序，帮助他快速找到灯链中缺失的、影响他美感的片段。作为第一步，请你为他编写一个程序，计算给定灯链中未出现的最短颜色片段的长度。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $m$ $(1 \\leq n \\leq 100000, 0 \\leq m \\leq 10000)$，用单个空格分隔，分别表示灯链中灯泡的数量和店主更换颜色的次数。第二行包含一个长度为 $n$ 的字符串，由字符 `0` 和 `1` 组成，表示灯链中各灯泡的颜色（例如 `0` 表示红色，`1` 表示绿色）。\n\n接下来的 $m$ 行描述颜色更换操作，每行包含一个整数 $a_{i}$ $(1 \\leq a_{i} \\leq n)$，表示店主更换了第 $a_{i}$ 个灯泡的颜色。", "outputFormat": "输出应包含正好 $m+1$ 行，每行包含一个整数。第 $i$ 行表示在店主完成前 $i-1$ 次更换后，灯链颜色编码字符串中未出现的最短子字符串（由 `0` 和 `1` 组成）的长度。", "hint": "**样例 1 解释**\n\n在字符串 `001010` 中，未出现的最短子字符串是 `11`，长度为 $2$。更换第六个字符后得到 `001011`，此时长度为 $1$ 和 $2$ 的所有子字符串都已出现，但长度为 $3$ 的子字符串 `110` 未出现。更换第二个字符后得到 `011011`，此时未出现的最短子字符串是 `00`，长度为 $2$。\n\n**附加样例**\n\n1. 该样例满足 $n=5, m=0$，灯链为 `10000`；\n2. 该样例满足 $n=500, m=2$，初始灯链为 `000...0`（全为 `0`），更换第一个和最后一个灯泡；\n3. 该样例满足 $n=m=10000$，初始灯链为 `1000...0`（开头为 `1`，后面全为 `0`），依次更换所有灯泡。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $n, m \\leq 1000$  | $46$   |\n| $2$      | 无附加限制        | $54$   |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2019/2020 R2] 牢骚 Marudny Bajtazar", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4847)。", "description": "**题目译自 [XXVII Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi27-2/dashboard/) [Marudny Bajtazar](https://szkopul.edu.pl/problemset/problem/kvwWom2nxVBqipEfeiMtidn5/statement/)**\n\n圣诞节即将来临，Bajtazar 决定购买新的装饰品来装点自己的家。今年，他想尝试极简风格，计划买一条只有绿色和红色两种颜色的灯链。于是，他前往附近的灯饰店，请店主展示双色灯链。\n\n然而，多年在字节王国从事各种工作的经历，让 Bajtazar 养成了对任何事物（哪怕是最琐碎的）都有自己看法的习惯，而且他从不吝于表达意见（即便没人愿意听）。特别是在时尚和美学方面，他的观念尤为固执，这对那些接待过他的店主来说尤为头疼，因为他们总是要听他抱怨商品哪里不尽如人意。\n\n这次也不例外：Bajtazar 盯着店主展示的灯链看了半天，终于开口说：「总体来说，这条灯链还不错，但整体美感被一个问题破坏了——链条里没有一段连续四个灯泡的片段，颜色依次是红-绿-绿-红。」由于店主没有其他灯链可供选择，他决定更换其中一个灯泡的颜色，以满足这个要求。\n\nBajtazar 满意地点了点头，但没过多久又说：「现在还差一段颜色为绿-红-绿-绿-红的片段。」店主又换了一个灯泡的颜色。Bajtazar 接着说：「现在看起来很美，但还缺少另一个对颜色搭配很重要的片段。」\n\n虽然 Bajtazar 非常耐心地解释为什么灯链还不完美，但他担心店主更换灯泡颜色的方式过于随意，可能无法快速达到目标。为了更高效地解决问题，他请你帮忙编写一个程序，帮助他快速找到灯链中缺失的、影响他美感的片段。作为第一步，请你为他编写一个程序，计算给定灯链中未出现的最短颜色片段的长度。", "inputFormat": "输入的第一行包含两个整数 $n$ 和 $m$ $(1 \\leq n \\leq 100000, 0 \\leq m \\leq 10000)$，用单个空格分隔，分别表示灯链中灯泡的数量和店主更换颜色的次数。第二行包含一个长度为 $n$ 的字符串，由字符 `0` 和 `1` 组成，表示灯链中各灯泡的颜色（例如 `0` 表示红色，`1` 表示绿色）。\n\n接下来的 $m$ 行描述颜色更换操作，每行包含一个整数 $a_{i}$ $(1 \\leq a_{i} \\leq n)$，表示店主更换了第 $a_{i}$ 个灯泡的颜色。", "outputFormat": "输出应包含正好 $m+1$ 行，每行包含一个整数。第 $i$ 行表示在店主完成前 $i-1$ 次更换后，灯链颜色编码字符串中未出现的最短子字符串（由 `0` 和 `1` 组成）的长度。", "hint": "**样例 1 解释**\n\n在字符串 `001010` 中，未出现的最短子字符串是 `11`，长度为 $2$。更换第六个字符后得到 `001011`，此时长度为 $1$ 和 $2$ 的所有子字符串都已出现，但长度为 $3$ 的子字符串 `110` 未出现。更换第二个字符后得到 `011011`，此时未出现的最短子字符串是 `00`，长度为 $2$。\n\n**附加样例**\n\n1. 该样例满足 $n=5, m=0$，灯链为 `10000`；\n2. 该样例满足 $n=500, m=2$，初始灯链为 `000...0`（全为 `0`），更换第一个和最后一个灯泡；\n3. 该样例满足 $n=m=10000$，初始灯链为 `1000...0`（开头为 `1`，后面全为 `0`），依次更换所有灯泡。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $n, m \\leq 1000$  | $46$   |\n| $2$      | 无附加限制        | $54$   |", "locale": "zh-CN"}}}
{"pid": "P12899", "type": "P", "difficulty": 5, "samples": [["15", "8\n12 10"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["搜索", "数学", "2020", "POI（波兰）", "Special Judge"], "title": "[POI 2019/2020 R2] 幼儿园难题 Trudny dylemat przedszkolanina", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4848)。", "description": "**题目译自 [XXVII Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi27-2/dashboard/) [Trudny dylemat przedszkolanina](https://szkopul.edu.pl/problemset/problem/iJJmCcYiYpjxJP682ai0jToE/statement/)**\n\nBajtazar 刚刚从字节教育学院（Bajtocka Szkoła Pedagogiczna）毕业，假期结束后，他将开始在幼儿园担任保育员。由于在字节王国，男性保育员对许多孩子来说可能是个新鲜事物，他决定用一个小魔法赢得孩子们的心。当他第一次与孩子们见面时，他会将其中一个口袋翻出来，让糖果洒落在地板上。孩子们当然不会让任何一颗糖果被浪费，但对 Bajtazar 来说，确保每个孩子分到的糖果数量相等非常重要（否则，有些孩子可能会不喜欢他）。因此，洒出的糖果总数必须能被孩子的数量整除。\n\n这听起来似乎很简单，但问题在于，Bajtazar 并不知道他的班级会有多少个孩子。已知他的裤子有两个口袋，且每个口袋的容量（即能装下的糖果数量）是已知的，请你帮助他选择两个口袋中的糖果数量，使他能应对尽可能多的不同孩子人数。", "inputFormat": "输入只有一行，包含一个整数 $n$ $(n \\geq 1)$，表示 Bajtazar 裤子每个口袋的容量。", "outputFormat": "输出包含两行：\n\n第一行包含一个自然数，表示 Bajtazar 能应对的不同孩子人数的数量。\n\n第二行包含两个不超过 $n$ 的正整数 $x$ 和 $y$，表示 Bajtazar 在两个口袋中应放置的糖果数量，以应对这么多可能性。如果存在多种满足条件的答案，你的程序可以输出任意一种。", "hint": "**样例 1 解释**\n\n口袋中装 $10$ 颗糖果时，Bajtazar 能应对 $1, 2, 5, 10$ 个孩子；口袋中装 $12$ 颗糖果时，他能应对 $1, 2, 3, 4, 6, 12$ 个孩子。综合来看，Bajtazar 总共能应对 $8$ 种不同的孩子人数（即 $1, 2, 3, 4, 5, 6, 10, 12$）。\n\n**附加样例**\n\n1. 该样例满足 $n=10$；\n2. 该样例满足 $n=100$；\n3. 该样例满足 $n=1000$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $n \\leq 200$      | $8$    |\n| $2$      | $n \\leq 3000$     | $7$    |\n| $3$      | $n \\leq 1000000$  | $34$   |\n| $4$      | $n \\leq 10^{12}$  | $23$   |\n| $5$      | $n \\leq 10^{16}$  | $28$   |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2019/2020 R2] 幼儿园难题 Trudny dylemat przedszkolanina", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4848)。", "description": "**题目译自 [XXVII Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi27-2/dashboard/) [Trudny dylemat przedszkolanina](https://szkopul.edu.pl/problemset/problem/iJJmCcYiYpjxJP682ai0jToE/statement/)**\n\nBajtazar 刚刚从字节教育学院（Bajtocka Szkoła Pedagogiczna）毕业，假期结束后，他将开始在幼儿园担任保育员。由于在字节王国，男性保育员对许多孩子来说可能是个新鲜事物，他决定用一个小魔法赢得孩子们的心。当他第一次与孩子们见面时，他会将其中一个口袋翻出来，让糖果洒落在地板上。孩子们当然不会让任何一颗糖果被浪费，但对 Bajtazar 来说，确保每个孩子分到的糖果数量相等非常重要（否则，有些孩子可能会不喜欢他）。因此，洒出的糖果总数必须能被孩子的数量整除。\n\n这听起来似乎很简单，但问题在于，Bajtazar 并不知道他的班级会有多少个孩子。已知他的裤子有两个口袋，且每个口袋的容量（即能装下的糖果数量）是已知的，请你帮助他选择两个口袋中的糖果数量，使他能应对尽可能多的不同孩子人数。", "inputFormat": "输入只有一行，包含一个整数 $n$ $(n \\geq 1)$，表示 Bajtazar 裤子每个口袋的容量。", "outputFormat": "输出包含两行：\n\n第一行包含一个自然数，表示 Bajtazar 能应对的不同孩子人数的数量。\n\n第二行包含两个不超过 $n$ 的正整数 $x$ 和 $y$，表示 Bajtazar 在两个口袋中应放置的糖果数量，以应对这么多可能性。如果存在多种满足条件的答案，你的程序可以输出任意一种。", "hint": "**样例 1 解释**\n\n口袋中装 $10$ 颗糖果时，Bajtazar 能应对 $1, 2, 5, 10$ 个孩子；口袋中装 $12$ 颗糖果时，他能应对 $1, 2, 3, 4, 6, 12$ 个孩子。综合来看，Bajtazar 总共能应对 $8$ 种不同的孩子人数（即 $1, 2, 3, 4, 5, 6, 10, 12$）。\n\n**附加样例**\n\n1. 该样例满足 $n=10$；\n2. 该样例满足 $n=100$；\n3. 该样例满足 $n=1000$。\n\n详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$      | $n \\leq 200$      | $8$    |\n| $2$      | $n \\leq 3000$     | $7$    |\n| $3$      | $n \\leq 1000000$  | $34$   |\n| $4$      | $n \\leq 10^{12}$  | $23$   |\n| $5$      | $n \\leq 10^{16}$  | $28$   |", "locale": "zh-CN"}}}
{"pid": "P12900", "type": "P", "difficulty": 6, "samples": [["NE?(ER)C++|(IS)*?|(CHA((LL))ENGING)", "23 57\n      +---+               +----+        +---+            \nS->+->+ N +->+-------->+->+ ER +->+->+->+ C +->+->+->+->F\n   |  +---+  |         |  +----+  |  |  +---+  |  |  |   \n   |         |  +---+  |          |  |         |  |  |   \n   |         +->+ E +->+          |  +<--------+  |  |   \n   |            +---+             |               |  |   \n   |                              +<--------------+  |   \n   |                                                 |   \n   |                                                 |   \n   +->+--------------->+---------------------------->+   \n   |  |                |                             |   \n   |  |                |                             |   \n   |  +->+--------->+->+                             |   \n   |     |          |                                |   \n   |     |  +----+  |                                |   \n   |     +->+ IS +->+                                |   \n   |     |  +----+  |                                |   \n   |     |          |                                |   \n   |     +<---------+                                |   \n   |                                                 |   \n   |  +-----+  +----+  +--------+                    |   \n   +->+ CHA +->+ LL +->+ ENGING +------------------->+   \n      +-----+  +----+  +--------+                        "]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "ICPC", "NERC/NEERC"], "title": "[NERC 2020] ASCII Automata Art", "background": "", "description": "This problem statement is quite wordy by itself and does not need a legend. You are given a regular expression and your task is to render its corresponding automaton as an ASCII art text drawing following the specification in the problem statement. Please, see examples.\n\nA regular expression in this problem consists of uppercase letters from `A` to `Z`, special characters `+`, `?`, `*`, and parenthesis that are used for grouping. An input to the problem is given by an `<input>` non-terminal of the following BNF grammar:\n\n```\n<input> ::= <expr>\n\n<expr> ::= <term> | <term> `|' <expr>\n\n<term> ::= <atom> | <atom><term> | <term><atom>\n\n<atom> ::= <letter> | `(' <expr> `)' | <atom> `+' | <atom> `?' | <atom> `*'\n\n<letter> ::= `A' | `B' | ... | `Z'\n```\n\nA regular expression is rendered as an ASCII art picture using the precise rules that are given below. They recursively define a unique representation for each regular expression as a rectangular *box* of characters with the specified number of rows and columns. Empty characters of the representation, including trailing ones, must be filled with spaces.\n\nA `<term>` that consists of a sequence of $n$ uppercase letters is rendered as a box of 3 rows and $4 + n$ columns using `+` and `-` characters to render a border on the first and the last rows and columns as shown in the example. The production rule for the `<term>` non-terminal in the grammar is intentionally ambiguous. The longest possible sequence of adjacent `<letter>` non-terminals in the regular expression must be grouped into a `<term>` and rendered as a single box. \nFor example, a `<term>` of `NERC` \nis rendered as the following $3 \\times 8$ box:\n\n```\n+------+\n+ NERC +\n+------+\n```\n\nA `<term>` that consists of a sequence of `<atom>` non-terminals and `<term>` non-terminals with letters (as described above) is rendered by laying out the constituent boxes left-to-right, aligned vertically to the top, with 2 columns separating adjacent boxes. The height of the resulting box is equal to the maximum height of the constituent boxes.\nEach pair of adjacent boxes is joined by rendering `->` characters on the 2nd row in the columns between them. \nFor example, a `<term>` of `N(E)RC` (consisting of a sequence: `<atom>` of `A`, `<atom>` of `(E)`, and a letters-only `<term>` of `RC`)\nis rendered as the following $3 \\times 20$ box:\n\n```\n+---+  +---+  +----+\n+ N +->+ E +->+ RC +\n+---+  +---+  +----+\n```\n\nAn `<expr>` that consists of a single `<term>` is rendered as its `<term>`.\n\nAn `<expr>` that consists of a `|`-separated sequence of `<term>` non-literals is rendered by laying out the corresponding `<term>` boxes top-to-bottom, aligned to the left, with a single row separating adjacent `<term>` boxes. The width of the resulting box is equal to the maximum width of the `<term>` boxes plus 6. There are 3 additional columns on the left, and 3 on the right. The first column and the last column use `+` and `|` characters to join the 2nd rows of all the `<term>` boxes from the top to the bottom one, with `+` placed on the 2nd row of each `<term>` box. The 2nd and the 3rd columns on the left and the 3rd-to-last and the 2nd-to-last columns on the right have `->` characters on the 2nd rows of the corresponding `<term>` boxes. Additionally, shorter `<term>` boxes are connected on the right with extra `-` characters on their 2nd rows. \nFor example, an `<expr>` of `C|ON|TEST`\nis rendered as the following $11 \\times 14$ box:\n\n```\n   +---+         \n+->+ C +---->+\n|  +---+     |   \n|            |   \n|  +----+    |   \n+->+ ON +--->+   \n|  +----+    |   \n|            |   \n|  +------+  |   \n+->+ TEST +->+   \n   +------+      \n```\n\nAn `<atom>` of `(` `<expr>` `)` is rendered as its `<expr>`.\n\nAn `<atom>` of `<atom>` `+` is rendered as a box of its source `<atom>` with 2 additional rows at the bottom and 6 additional columns (3 on the left and 3 on the right). The first and the last columns, starting with the 2nd row, and the last row are filled with the connecting characters as shown in the example. \n\n- The 2nd row starts with `+->` and ends with `->+` to connect to the 2nd row of the source `<atom>` box. \n- The last row starts with `+<-` to represent a backwards edge in the automaton. \n\nFor example, an `<atom>` of `A+`\nis rendered as the following $5 \\times 11$ box. \n\n```\n   +---+      \n+->+ A +->+\n|  +---+  |   \n|         |   \n+<--------+   \n```\n\nAn `<atom>` of `<atom>` `?` is rendered as a box of its source `<atom>` with 3 additional rows at the top and 6 additional columns (3 on the left and 3 on the right). The first and the last columns (from the 2nd to the 5th row) and the 2nd row are filled with the connecting characters as shown in the example. \n\n- The first row of `<atom>` `?` is always empty (filled with spaces).\n- The 2nd row ends with `->+` to represent an epsilon-edge in the corresponding automaton.\n- The 5th row starts with `+->` and ends with `->+` to connect to the 2nd row of the source `<atom>` box.\n\nFor example, an `<atom>` of `B?`\nis rendered as the following $6 \\times 11$ box. \n\n```\n                 \n+-------->+\n|         |   \n|  +---+  |   \n+->+ B +->+   \n   +---+       \n```\n\nAn `<atom>` of `<atom>` `*` is rendered as a box of its source `<atom>` with 5 additional rows (3 at the top and 2 at the bottom) and 6 additional columns (3 on the left and 3 on the right). The first and the last columns, with the 2nd and the last row, are filled with the connecting characters as shown in the example. \n\n- The first row of `<atom>` `*` is always empty (filled with spaces).\n- The 2nd row ends with `->+` to represent an epsilon-edge in the corresponding automaton.\n- The 5th row starts with `+->` and ends with `->+` to connect to the 2nd row of the source `<atom>` box.\n- The last row starts with `+<-` to represent a backwards edge in the automata. \n\nFor example, an `<atom>` of `C*`\nis rendered as the following $8 \\times 11$ box. \n\n```\n                 \n+-------->+\n|         |   \n|  +---+  |   \n+->+ C +->+   \n|  +---+  |   \n|         |   \n+<--------+   \n```\n\nAn `<input>` is rendered as a box that has 6 more columns than the corresponding box of the `<expr>`, with 3 additional columns on the left, and 3 on the right. The 2nd row starts with `S->` to represent the starting state of the automaton and ends with `->F` to represent the final state of the automaton. See the example output.", "inputFormat": "The input consists of a single line that corresponds to the $\\langle input \\rangle$ non-terminal of the grammar given the problem statement and has at most 100 characters in length.", "outputFormat": "On the first line of the output, write two integers $h$ and $w$ --- the height and the width, correspondingly, of the $h \\times w$ box that corresponds to the given $\\langle input \\rangle$. On each of the next $h$ lines, write $w$ characters of the corresponding ASCII art rendering.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2020] ASCII Automata Art", "background": "", "description": "This problem statement is quite wordy by itself and does not need a legend. You are given a regular expression and your task is to render its corresponding automaton as an ASCII art text drawing following the specification in the problem statement. Please, see examples.\n\nA regular expression in this problem consists of uppercase letters from `A` to `Z`, special characters `+`, `?`, `*`, and parenthesis that are used for grouping. An input to the problem is given by an `<input>` non-terminal of the following BNF grammar:\n\n```\n<input> ::= <expr>\n\n<expr> ::= <term> | <term> `|' <expr>\n\n<term> ::= <atom> | <atom><term> | <term><atom>\n\n<atom> ::= <letter> | `(' <expr> `)' | <atom> `+' | <atom> `?' | <atom> `*'\n\n<letter> ::= `A' | `B' | ... | `Z'\n```\n\nA regular expression is rendered as an ASCII art picture using the precise rules that are given below. They recursively define a unique representation for each regular expression as a rectangular *box* of characters with the specified number of rows and columns. Empty characters of the representation, including trailing ones, must be filled with spaces.\n\nA `<term>` that consists of a sequence of $n$ uppercase letters is rendered as a box of 3 rows and $4 + n$ columns using `+` and `-` characters to render a border on the first and the last rows and columns as shown in the example. The production rule for the `<term>` non-terminal in the grammar is intentionally ambiguous. The longest possible sequence of adjacent `<letter>` non-terminals in the regular expression must be grouped into a `<term>` and rendered as a single box. \nFor example, a `<term>` of `NERC` \nis rendered as the following $3 \\times 8$ box:\n\n```\n+------+\n+ NERC +\n+------+\n```\n\nA `<term>` that consists of a sequence of `<atom>` non-terminals and `<term>` non-terminals with letters (as described above) is rendered by laying out the constituent boxes left-to-right, aligned vertically to the top, with 2 columns separating adjacent boxes. The height of the resulting box is equal to the maximum height of the constituent boxes.\nEach pair of adjacent boxes is joined by rendering `->` characters on the 2nd row in the columns between them. \nFor example, a `<term>` of `N(E)RC` (consisting of a sequence: `<atom>` of `A`, `<atom>` of `(E)`, and a letters-only `<term>` of `RC`)\nis rendered as the following $3 \\times 20$ box:\n\n```\n+---+  +---+  +----+\n+ N +->+ E +->+ RC +\n+---+  +---+  +----+\n```\n\nAn `<expr>` that consists of a single `<term>` is rendered as its `<term>`.\n\nAn `<expr>` that consists of a `|`-separated sequence of `<term>` non-literals is rendered by laying out the corresponding `<term>` boxes top-to-bottom, aligned to the left, with a single row separating adjacent `<term>` boxes. The width of the resulting box is equal to the maximum width of the `<term>` boxes plus 6. There are 3 additional columns on the left, and 3 on the right. The first column and the last column use `+` and `|` characters to join the 2nd rows of all the `<term>` boxes from the top to the bottom one, with `+` placed on the 2nd row of each `<term>` box. The 2nd and the 3rd columns on the left and the 3rd-to-last and the 2nd-to-last columns on the right have `->` characters on the 2nd rows of the corresponding `<term>` boxes. Additionally, shorter `<term>` boxes are connected on the right with extra `-` characters on their 2nd rows. \nFor example, an `<expr>` of `C|ON|TEST`\nis rendered as the following $11 \\times 14$ box:\n\n```\n   +---+         \n+->+ C +---->+\n|  +---+     |   \n|            |   \n|  +----+    |   \n+->+ ON +--->+   \n|  +----+    |   \n|            |   \n|  +------+  |   \n+->+ TEST +->+   \n   +------+      \n```\n\nAn `<atom>` of `(` `<expr>` `)` is rendered as its `<expr>`.\n\nAn `<atom>` of `<atom>` `+` is rendered as a box of its source `<atom>` with 2 additional rows at the bottom and 6 additional columns (3 on the left and 3 on the right). The first and the last columns, starting with the 2nd row, and the last row are filled with the connecting characters as shown in the example. \n\n- The 2nd row starts with `+->` and ends with `->+` to connect to the 2nd row of the source `<atom>` box. \n- The last row starts with `+<-` to represent a backwards edge in the automaton. \n\nFor example, an `<atom>` of `A+`\nis rendered as the following $5 \\times 11$ box. \n\n```\n   +---+      \n+->+ A +->+\n|  +---+  |   \n|         |   \n+<--------+   \n```\n\nAn `<atom>` of `<atom>` `?` is rendered as a box of its source `<atom>` with 3 additional rows at the top and 6 additional columns (3 on the left and 3 on the right). The first and the last columns (from the 2nd to the 5th row) and the 2nd row are filled with the connecting characters as shown in the example. \n\n- The first row of `<atom>` `?` is always empty (filled with spaces).\n- The 2nd row ends with `->+` to represent an epsilon-edge in the corresponding automaton.\n- The 5th row starts with `+->` and ends with `->+` to connect to the 2nd row of the source `<atom>` box.\n\nFor example, an `<atom>` of `B?`\nis rendered as the following $6 \\times 11$ box. \n\n```\n                 \n+-------->+\n|         |   \n|  +---+  |   \n+->+ B +->+   \n   +---+       \n```\n\nAn `<atom>` of `<atom>` `*` is rendered as a box of its source `<atom>` with 5 additional rows (3 at the top and 2 at the bottom) and 6 additional columns (3 on the left and 3 on the right). The first and the last columns, with the 2nd and the last row, are filled with the connecting characters as shown in the example. \n\n- The first row of `<atom>` `*` is always empty (filled with spaces).\n- The 2nd row ends with `->+` to represent an epsilon-edge in the corresponding automaton.\n- The 5th row starts with `+->` and ends with `->+` to connect to the 2nd row of the source `<atom>` box.\n- The last row starts with `+<-` to represent a backwards edge in the automata. \n\nFor example, an `<atom>` of `C*`\nis rendered as the following $8 \\times 11$ box. \n\n```\n                 \n+-------->+\n|         |   \n|  +---+  |   \n+->+ C +->+   \n|  +---+  |   \n|         |   \n+<--------+   \n```\n\nAn `<input>` is rendered as a box that has 6 more columns than the corresponding box of the `<expr>`, with 3 additional columns on the left, and 3 on the right. The 2nd row starts with `S->` to represent the starting state of the automaton and ends with `->F` to represent the final state of the automaton. See the example output.", "inputFormat": "The input consists of a single line that corresponds to the $\\langle input \\rangle$ non-terminal of the grammar given the problem statement and has at most 100 characters in length.", "outputFormat": "On the first line of the output, write two integers $h$ and $w$ --- the height and the width, correspondingly, of the $h \\times w$ box that corresponds to the given $\\langle input \\rangle$. On each of the next $h$ lines, write $w$ characters of the corresponding ASCII art rendering.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2020] ASCII Automata Art", "background": "", "description": "本题的题目描述本身已经足够详细，不需要额外的背景说明。给定一个正则表达式，你的任务是根据题目描述中的规范，将其对应的自动机以 ASCII 艺术的形式绘制出来。请参考示例。\n\n本题中的正则表达式由大写字母 `A` 到 `Z`、特殊字符 `+`、`?`、`*` 以及用于分组的括号组成。问题的输入由以下 BNF 文法中的 `<input>` 非终结符给出：\n\n```\n<input> ::= <expr>\n\n<expr> ::= <term> | <term> `|' <expr>\n\n<term> ::= <atom> | <atom><term> | <term><atom>\n\n<atom> ::= <letter> | `(' <expr> `)' | <atom> `+' | <atom> `?' | <atom> `*'\n\n<letter> ::= `A' | `B' | ... | `Z'\n```\n\n正则表达式的 ASCII 艺术绘制遵循以下精确规则。这些规则递归地定义了每个正则表达式的唯一表示形式，即一个由字符组成的矩形*框*，具有指定的行数和列数。表示中的空白字符（包括尾随空格）必须用空格填充。\n\n一个由 $n$ 个大写字母组成的 `<term>` 被绘制为一个 $3 \\times (4 + n)$ 的框，使用 `+` 和 `-` 字符在第一行和最后一行以及第一列和最后一列绘制边框，如示例所示。文法中 `<term>` 非终结符的产生规则故意设计为歧义。正则表达式中相邻的 `<letter>` 非终结符的最长连续序列必须被分组为一个 `<term>`，并绘制为一个单独的框。例如，`NERC` 的 `<term>` 被绘制为以下 $3 \\times 8$ 的框：\n\n```\n+------+\n+ NERC +\n+------+\n```\n\n一个由 `<atom>` 非终结符和字母组成的 `<term>` 非终结符（如上所述）组成的 `<term>`，通过将组成框从左到右排列，垂直对齐到顶部，相邻框之间用 2 列分隔。结果框的高度等于组成框的最大高度。每对相邻框通过在它们之间的列中在第二行绘制 `->` 字符来连接。例如，`N(E)RC` 的 `<term>`（由序列 `<atom>` 的 `N`、`<atom>` 的 `(E)` 和仅由字母组成的 `<term>` 的 `RC` 组成）被绘制为以下 $3 \\times 20$ 的框：\n\n```\n+---+  +---+  +----+\n+ N +->+ E +->+ RC +\n+---+  +---+  +----+\n```\n\n一个由单个 `<term>` 组成的 `<expr>` 被绘制为其 `<term>`。\n\n一个由 `|` 分隔的 `<term>` 非终结符序列组成的 `<expr>`，通过将对应的 `<term>` 框从上到下排列，左对齐，相邻 `<term>` 框之间用一行分隔。结果框的宽度等于 `<term>` 框的最大宽度加 6。左侧有 3 列额外列，右侧有 3 列额外列。第一列和最后一列使用 `+` 和 `|` 字符将所有 `<term>` 框的第二行从顶部到底部连接起来，`+` 放置在每个 `<term>` 框的第二行。左侧的第二列和第三列以及右侧的倒数第三列和倒数第二列在对应的 `<term>` 框的第二行有 `->` 字符。此外，较短的 `<term>` 框在右侧用额外的 `-` 字符在其第二行连接。例如，`C|ON|TEST` 的 `<expr>` 被绘制为以下 $11 \\times 14$ 的框：\n\n```\n   +---+         \n+->+ C +---->+\n|  +---+     |   \n|            |   \n|  +----+    |   \n+->+ ON +--->+   \n|  +----+    |   \n|            |   \n|  +------+  |   \n+->+ TEST +->+   \n   +------+\n```\n\n一个 `(` `<expr>` `)` 的 `<atom>` 被绘制为其 `<expr>`。\n\n一个 `<atom>` `+` 的 `<atom>` 被绘制为其源 `<atom>` 的框，底部增加 2 行，左右各增加 3 列。从第二行开始的第一列和最后一列以及最后一行填充连接字符，如示例所示。\n\n- 第二行以 `+->` 开头，以 `->+` 结尾，连接到源 `<atom>` 框的第二行。\n- 最后一行以 `+<-` 开头，表示自动机中的反向边。\n\n例如，`A+` 的 `<atom>` 被绘制为以下 $5 \\times 11$ 的框：\n\n```\n   +---+      \n+->+ A +->+\n|  +---+  |   \n|         |   \n+<--------+\n```\n\n一个 `<atom>` `?` 的 `<atom>` 被绘制为其源 `<atom>` 的框，顶部增加 3 行，左右各增加 3 列。从第二行到第五行的第一列和最后一列以及第二行填充连接字符，如示例所示。\n\n- `<atom>` `?` 的第一行始终为空（填充空格）。\n- 第二行以 `->+` 结尾，表示对应自动机中的 epsilon 边。\n- 第五行以 `+->` 开头，以 `->+` 结尾，连接到源 `<atom>` 框的第二行。\n\n例如，`B?` 的 `<atom>` 被绘制为以下 $6 \\times 11$ 的框：\n\n```\n\n+-------->+\n|         |   \n|  +---+  |   \n+->+ B +->+   \n   +---+\n```\n\n一个 `<atom>` `*` 的 `<atom>` 被绘制为其源 `<atom>` 的框，顶部增加 3 行，底部增加 2 行，左右各增加 3 列。第一列和最后一列以及第二行和最后一行填充连接字符，如示例所示。\n\n- `<atom>` `*` 的第一行始终为空（填充空格）。\n- 第二行以 `->+` 结尾，表示对应自动机中的 epsilon 边。\n- 第五行以 `+->` 开头，以 `->+` 结尾，连接到源 `<atom>` 框的第二行。\n- 最后一行以 `+<-` 开头，表示自动机中的反向边。\n\n例如，`C*` 的 `<atom>` 被绘制为以下 $8 \\times 11$ 的框：\n\n```\n                 \n+-------->+\n|         |   \n|  +---+  |   \n+->+ C +->+   \n|  +---+  |   \n|         |   \n+<--------+\n```\n\n一个 `<input>` 被绘制为一个比对应 `<expr>` 框多 6 列的框，左侧和右侧各增加 3 列。第二行以 `S->` 开头，表示自动机的起始状态，以 `->F` 结尾，表示自动机的终止状态。参见示例输出。", "inputFormat": "输入由一行组成，对应于题目描述中给出的文法中的 `<input>` 非终结符，长度不超过 100 个字符。\n", "outputFormat": "输出的第一行写入两个整数 $h$ 和 $w$，分别对应于给定 `<input>` 的 $h \\times w$ 框的高度和宽度。接下来的 $h$ 行每行写入 $w$ 个字符，表示对应的 ASCII 艺术绘制。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P12901", "type": "P", "difficulty": 6, "samples": [["2 2\n10\n11", "2\n0 1"], ["3 4\n001\n111\n101\n011", "6\n2 0 R 1 2 0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "网络流", "Special Judge", "费用流", "ICPC", "NERC/NEERC"], "title": "[NERC 2020] Button Lock", "background": "", "description": "You are standing in front of the room with great treasures. The only thing stopping you is the door with a push-button combination lock. This lock has $d$ buttons with digits from $0$ to $d - 1$. Whenever you press a button, it stays pushed down. You can not pop back up just one button, but there is a \"RESET\" button --- pressing it pops up all other buttons. Initially, no buttons are pushed down.\n\nThe door instantly opens when some specific set of digits is pushed down. Sadly, you don't know the password for it. Having read the documentation for this specific lock, you found out that there are $n$ possible passwords for this particular lock.  \n\nFind the shortest sequence of button presses, such that all possible passwords appear at least once during its execution. Any shortest correct sequence of button presses will be accepted.", "inputFormat": "The first line contains two integers $d$ and $n$ ($1 \\le d \\le 10$; $1 \\le n \\le 2^d - 1$).\nNext $n$ lines describe possible passwords. Each line contains a string $s_i$ of $d$ zeros and ones: for all $j$ from $1$ to $d$ the $j$-th character is $\\tt{1}$ iff the button with the digit $j - 1$ must be pushed down.\n\nAll strings $s_i$ are different, and each string contains at least one $\\tt{1}$.", "outputFormat": "On the first line, print the number $k$ --- the minimum number of button presses.\nOn the second line, print $k$ tokens, describing the sequence. Whenever you press a button with a digit, print that digit. Whenever you press \"RESET\", print $\\tt{R}$.", "hint": "In the second example, the sequence $\\tt{1 2 R 2 0 1}$ is also possible.", "locale": "en", "translations": {"en": {"title": "[NERC 2020] Button Lock", "background": "", "description": "You are standing in front of the room with great treasures. The only thing stopping you is the door with a push-button combination lock. This lock has $d$ buttons with digits from $0$ to $d - 1$. Whenever you press a button, it stays pushed down. You can not pop back up just one button, but there is a \"RESET\" button --- pressing it pops up all other buttons. Initially, no buttons are pushed down.\n\nThe door instantly opens when some specific set of digits is pushed down. Sadly, you don't know the password for it. Having read the documentation for this specific lock, you found out that there are $n$ possible passwords for this particular lock.  \n\nFind the shortest sequence of button presses, such that all possible passwords appear at least once during its execution. Any shortest correct sequence of button presses will be accepted.", "inputFormat": "The first line contains two integers $d$ and $n$ ($1 \\le d \\le 10$; $1 \\le n \\le 2^d - 1$).\nNext $n$ lines describe possible passwords. Each line contains a string $s_i$ of $d$ zeros and ones: for all $j$ from $1$ to $d$ the $j$-th character is $\\tt{1}$ iff the button with the digit $j - 1$ must be pushed down.\n\nAll strings $s_i$ are different, and each string contains at least one $\\tt{1}$.", "outputFormat": "On the first line, print the number $k$ --- the minimum number of button presses.\nOn the second line, print $k$ tokens, describing the sequence. Whenever you press a button with a digit, print that digit. Whenever you press \"RESET\", print $\\tt{R}$.", "hint": "In the second example, the sequence $\\tt{1 2 R 2 0 1}$ is also possible.", "locale": "en"}, "zh-CN": {"title": "[NERC 2020] Button Lock", "background": "", "description": "你站在一个藏有巨大宝藏的房间门前。唯一的阻碍是一个带有按钮组合锁的门。这把锁有 $d$ 个按钮，分别标有数字 $0$ 到 $d - 1$。每次按下按钮时，它会保持按下状态。你不能单独弹起一个按钮，但有一个 \"RESET\" 按钮——按下它会弹起所有其他按钮。初始状态下，所有按钮均未按下。\n\n当某些特定的数字组合被按下时，门会立即打开。遗憾的是，你并不知道密码。通过阅读该锁的文档，你发现这把锁有 $n$ 种可能的密码。  \n\n请找出最短的按钮操作序列，使得在执行过程中所有可能的密码至少出现一次。任何最短的正确操作序列都将被接受。", "inputFormat": "第一行包含两个整数 $d$ 和 $n$（$1 \\le d \\le 10$；$1 \\le n \\le 2^d - 1$）。  \n接下来的 $n$ 行描述了可能的密码。每行包含一个由 $d$ 个 0 和 1 组成的字符串 $s_i$：对于所有 $j$ 从 $1$ 到 $d$，第 $j$ 个字符为 $\\tt{1}$ 当且仅当数字为 $j - 1$ 的按钮必须被按下。  \n\n所有字符串 $s_i$ 均不相同，且每个字符串至少包含一个 $\\tt{1}$。", "outputFormat": "第一行输出一个整数 $k$，表示最小的按钮操作次数。  \n第二行输出 $k$ 个标记，描述操作序列。按下数字按钮时，输出对应的数字；按下 \"RESET\" 按钮时，输出 $\\tt{R}$。\n", "hint": "在第二个示例中，序列 $\\tt{1 2 R 2 0 1}$ 也是可行的。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12902", "type": "P", "difficulty": 6, "samples": [["6 1\n7 1 2 5 6 2 3 4\n3 1\n4 1 2 3 1\n5 2\n3 1 3 5\n3 1 2 4\n7 2\n6 1 2 3 4 5 3\n3 6 5 7\n0 0", "1\n1 4\n0\n1\n5 4\n2\n1 3\n6 7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "Special Judge", "树形 DP", "仙人掌", "ICPC", "圆方树", "NERC/NEERC"], "title": "[NERC 2020] Cactus Not Enough", "background": "", "description": "There was no problem about a cactus at the NERC 2020 online round. That's a bad mistake, \nso judges decided to fix it. You shall not pass to the World Finals 2021 without solving\na problem about a cactus!\n\nA $\\emph{cactus}$ is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively, a cactus is a generalization of a tree where some cycles are allowed. Multiedges (multiple edges between a pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus. \n\nCher has got a cactus. She calls cactus $\\emph{strong}$ if it is impossible to add an edge to it in such a way that it still remains a cactus. But Cher thinks her cactus is not strong enough. She wants to add the smallest possible number of edges to it to make it strong, i.e. to create a new cactus with the same vertices, so that the original cactus is a subgraph of the new one, and it is impossible to add another edge to it so that the graph remains a cactus. Cher hired you to do this job for her. So $\\ldots$ it's on you!", "inputFormat": "The input consists of one or more independent test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ \n($1 \\le n \\le 10^5$, $0 \\le m \\le 10^5$), where $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$. Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths. \n\nEach of the following $m$ lines contains a path in the graph. A path starts\nwith an integer number $s_i$ ($2 \\le s_i \\le 1000$) followed by $s_i$ integers\nfrom $1$ to $n$. These $s_i$ integers represent vertices of a path. Adjacent vertices in a path are distinct. The path can go through the same vertex multiple times, but every edge is traversed exactly once in the whole test case. There are no multiedges in the graph (there is at most one edge between any two vertices).\n\nThe last line of the input after all test cases always contains two zeros. It does $\\textbf{not}$ define a test case. It just marks the end of the input and does not require any output.\n\nAll graphs in the input are cacti. The total sum of all values of $n$ and\nthe total sum of all values of $m$ throughout the input both do not exceed $10^5$.", "outputFormat": "For each test case, first output the line with the minimal possible number of additional edges $A$. \nThen output $A$ lines, each describing one edge as $u_i$ $v_i$, where $u_i$ and $v_i$\nare the numbers of vertices to connect. After adding these edges, the resulting graph must be a strong cactus.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2020] Cactus Not Enough", "background": "", "description": "There was no problem about a cactus at the NERC 2020 online round. That's a bad mistake, \nso judges decided to fix it. You shall not pass to the World Finals 2021 without solving\na problem about a cactus!\n\nA $\\emph{cactus}$ is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively, a cactus is a generalization of a tree where some cycles are allowed. Multiedges (multiple edges between a pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus. \n\nCher has got a cactus. She calls cactus $\\emph{strong}$ if it is impossible to add an edge to it in such a way that it still remains a cactus. But Cher thinks her cactus is not strong enough. She wants to add the smallest possible number of edges to it to make it strong, i.e. to create a new cactus with the same vertices, so that the original cactus is a subgraph of the new one, and it is impossible to add another edge to it so that the graph remains a cactus. Cher hired you to do this job for her. So $\\ldots$ it's on you!", "inputFormat": "The input consists of one or more independent test cases.\n\nThe first line of each test case contains two integers $n$ and $m$ \n($1 \\le n \\le 10^5$, $0 \\le m \\le 10^5$), where $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$. Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths. \n\nEach of the following $m$ lines contains a path in the graph. A path starts\nwith an integer number $s_i$ ($2 \\le s_i \\le 1000$) followed by $s_i$ integers\nfrom $1$ to $n$. These $s_i$ integers represent vertices of a path. Adjacent vertices in a path are distinct. The path can go through the same vertex multiple times, but every edge is traversed exactly once in the whole test case. There are no multiedges in the graph (there is at most one edge between any two vertices).\n\nThe last line of the input after all test cases always contains two zeros. It does $\\textbf{not}$ define a test case. It just marks the end of the input and does not require any output.\n\nAll graphs in the input are cacti. The total sum of all values of $n$ and\nthe total sum of all values of $m$ throughout the input both do not exceed $10^5$.", "outputFormat": "For each test case, first output the line with the minimal possible number of additional edges $A$. \nThen output $A$ lines, each describing one edge as $u_i$ $v_i$, where $u_i$ and $v_i$\nare the numbers of vertices to connect. After adding these edges, the resulting graph must be a strong cactus.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2020] Cactus Not Enough", "background": "", "description": "在 NERC 2020 线上赛中竟然没有关于仙人掌的题目。这是个重大失误，因此裁判决定弥补这个遗憾。不解决一道关于仙人掌的问题，你就别想晋级 2021 年世界总决赛！\n\n**仙人掌**是一种连通无向图，其中每条边最多属于一个简单环。直观地说，仙人掌是树的推广，允许存在某些环。仙人图中不允许出现多重边（一对顶点之间有多条边）或自环（顶点连接到自身的边）。\n\nCher 得到了一个仙人掌图。她称一个仙人掌图是**强**的，如果无法再添加任何一条边使其仍然保持仙人掌的性质。但 Cher 觉得她的仙人掌还不够强。她希望添加尽可能少的边使其变强，即创建一个具有相同顶点的新仙人掌图，使得原图是新图的子图，并且无法再添加任何一条边使其仍然保持仙人掌的性质。Cher 雇佣你来完成这个任务。所以…现在就看你的了！", "inputFormat": "输入包含一个或多个独立的测试用例。\n\n每个测试用例的第一行包含两个整数 $n$ 和 $m$（$1 \\le n \\le 10^5$，$0 \\le m \\le 10^5$），其中 $n$ 是图中的顶点数。顶点编号从 $1$ 到 $n$。图的边由一组边不重复的路径表示，$m$ 是这些路径的数量。\n\n接下来的 $m$ 行每行包含图中的一条路径。路径以一个整数 $s_i$（$2 \\le s_i \\le 1000$）开头，后跟 $s_i$ 个 $1$ 到 $n$ 的整数。这些整数表示路径的顶点。路径中相邻的顶点是不同的。路径可以多次经过同一个顶点，但在整个测试用例中每条边恰好被遍历一次。图中没有多重边（任意两个顶点之间最多有一条边）。\n\n输入的最后一行在所有测试用例之后总是包含两个零。它**不**定义任何测试用例，仅标记输入结束，不需要任何输出。\n\n输入中的所有图都是仙人掌图。整个输入中所有 $n$ 的总和和所有 $m$ 的总和均不超过 $10^5$。", "outputFormat": "对于每个测试用例，首先输出一行，包含需要添加的最小边数 $A$。然后输出 $A$ 行，每行描述一条边为 $u_i$ $v_i$，其中 $u_i$ 和 $v_i$ 是要连接的顶点编号。添加这些边后，得到的图必须是一个强仙人掌图。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12903", "type": "P", "difficulty": 5, "samples": [["6 4\n4 11 8 2 1 13", "5\n1 2 4 11 13"], ["3 1\n2 4 6", "-1"], ["5 7\n1 3 1 5 3", "-1"], ["6 3\n8 9 4 17 11 5", "3\n9 11 17"], ["5 6\n2 2 2 2 2", "4\n2 2 2 2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "数学", "2020", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2020] Digits", "background": "", "description": "Diana loves playing with numbers. She's got $n$ cards with positive integer numbers $a_i$ written on them. She spends her free time multiplying the numbers on the cards. She picks a \nnon-empty subset of the cards and multiplies all the numbers $a_i$ written on them.\n\nDiana is happy when the product of the numbers ends with her favorite digit $d$. Now she is curious what cards she should pick so that the product of the numbers on them is the largest possible and the last decimal digit of the product is $d$. Please, help her.", "inputFormat": "The first line contains the integers $n$ and $d$ ($1\\le n\\le 10^5$, $0\\le d\\le 9$). The second line contains $n$ integers $a_i$ ($1\\le a_i\\le 1000$). ", "outputFormat": "On the first line, print the number of chosen cards $k$ ($1\\le k\\le n$). On the next line, print the numbers written on the chosen cards in any order. \n\nIf it is impossible to choose a subset of cards with the product that ends with the digit $d$, print the single line with $-1$.", "hint": "In the first example, $1 \\times 2 \\times 4 \\times 11 \\times 13 = 1144$, which is the largest product that ends with the digit 4. The same set of cards without the number 1 is also a valid answer, as well as a set of 8, 11, and 13 with or without 1 that also has the product of 1144.\n\nIn the second example, all the numbers on the cards are even and their product cannot end with an odd digit 1.\n\nIn the third example, the only possible products are 1, 3, 5, 9, 15, and 45, none of which end with the digit 7.\n\nIn the fourth example, $9 \\times 11 \\times 17 = 1683$, which ends with the digit 3. \n\nIn the fifth example, $2 \\times 2 \\times 2 \\times 2 = 16$, which ends with the digit 6.", "locale": "en", "translations": {"en": {"title": "[NERC 2020] Digits", "background": "", "description": "Diana loves playing with numbers. She's got $n$ cards with positive integer numbers $a_i$ written on them. She spends her free time multiplying the numbers on the cards. She picks a \nnon-empty subset of the cards and multiplies all the numbers $a_i$ written on them.\n\nDiana is happy when the product of the numbers ends with her favorite digit $d$. Now she is curious what cards she should pick so that the product of the numbers on them is the largest possible and the last decimal digit of the product is $d$. Please, help her.", "inputFormat": "The first line contains the integers $n$ and $d$ ($1\\le n\\le 10^5$, $0\\le d\\le 9$). The second line contains $n$ integers $a_i$ ($1\\le a_i\\le 1000$). ", "outputFormat": "On the first line, print the number of chosen cards $k$ ($1\\le k\\le n$). On the next line, print the numbers written on the chosen cards in any order. \n\nIf it is impossible to choose a subset of cards with the product that ends with the digit $d$, print the single line with $-1$.", "hint": "In the first example, $1 \\times 2 \\times 4 \\times 11 \\times 13 = 1144$, which is the largest product that ends with the digit 4. The same set of cards without the number 1 is also a valid answer, as well as a set of 8, 11, and 13 with or without 1 that also has the product of 1144.\n\nIn the second example, all the numbers on the cards are even and their product cannot end with an odd digit 1.\n\nIn the third example, the only possible products are 1, 3, 5, 9, 15, and 45, none of which end with the digit 7.\n\nIn the fourth example, $9 \\times 11 \\times 17 = 1683$, which ends with the digit 3. \n\nIn the fifth example, $2 \\times 2 \\times 2 \\times 2 = 16$, which ends with the digit 6.", "locale": "en"}, "zh-CN": {"title": "[NERC 2020] Digits", "background": "", "description": "Diana 喜欢玩数字游戏。她有 $n$ 张卡片，每张卡片上写着一个正整数 $a_i$。她闲暇时会挑选一些卡片，将这些卡片上的数字相乘。\n\n当这些数字的乘积以她最喜欢的数字 $d$ 结尾时，Diana 就会很开心。现在她想知道，应该如何选择卡片才能使得这些数字的乘积尽可能大，并且乘积的十进制表示最后一位是 $d$。请你帮帮她。\n", "inputFormat": "第一行包含两个整数 $n$ 和 $d$（$1 \\le n \\le 10^5$，$0 \\le d \\le 9$）。第二行包含 $n$ 个整数 $a_i$（$1 \\le a_i \\le 1000$）。\n", "outputFormat": "第一行输出选择的卡片数量 $k$（$1 \\le k \\le n$）。第二行以任意顺序输出被选中卡片上的数字。\n\n如果无法选出满足条件的卡片子集（即乘积最后一位是 $d$），则输出一行 $-1$。\n", "hint": "在第一个样例中，$1 \\times 2 \\times 4 \\times 11 \\times 13 = 1144$，这是以数字 4 结尾的最大乘积。不包含数字 1 的相同卡片组合也是有效答案，包含 8、11 和 13 的组合（无论是否包含 1）同样可以得到乘积 1144。\n\n在第二个样例中，所有卡片上的数字都是偶数，它们的乘积不可能以奇数 1 结尾。\n\n在第三个样例中，所有可能的乘积为 1、3、5、9、15 和 45，它们均不以数字 7 结尾。\n\n在第四个样例中，$9 \\times 11 \\times 17 = 1683$，其最后一位是 3。\n\n在第五个样例中，$2 \\times 2 \\times 2 \\times 2 = 16$，其最后一位是 6。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12904", "type": "P", "difficulty": 6, "samples": [["6 3.4 0.6", "()(())"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "2020", "Special Judge", "ICPC", "折半搜索 meet in the middle", "NERC/NEERC"], "title": "[NERC 2020] Equilibrium Point /\\/\\", "background": "", "description": "Consider a balanced bracket sequence $s$ with one type of brackets: $\\tt{(}$ and $\\tt{)}$.\n\nThere is a common geometrical representation of such a sequence. Starting at the point $(0, 0)$, you draw a polyline, for each bracket moving along a vector $(1, 1)$ if it is an opening bracket, and along $(1, -1)$ if it is a closing bracket.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5vg5dzar.png)\n\nConsider an area between this curve and the line $y=0$. It is a set of polygons. This area has its center of mass at some point $(x, y)$. Note that the center of mass might be outside of the area.\n\nYou are to solve the reverse problem. Given the length $n$ and a point $(x, y)$, find any balanced bracket sequence of length $n$ such that the center of mass of its geometrical representation is located at $(x, y)$.", "inputFormat": "The first line contains three numbers $n$, $x$, and $y$ ($n$ is an even integer, $2 \\le n \\le 36$; $0 < x, y < n$) --- the length of the desired sequence and the coordinates of the desired center of mass.\n\nIt is guaranteed that $(x, y)$ is the center of mass of some balanced bracket sequence of length $n$, with Euclidean-distance error of no more than $10^{-9}$.", "outputFormat": "Output a balanced bracket sequence with brackets $\\tt{(}$ and $\\tt{)}$ of length $n$ such that the center of mass of its geometrical representation is located at the point $(x, y)$, with Euclidean-distance error of no more than $10^{-7}$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2020] Equilibrium Point /\\/\\", "background": "", "description": "Consider a balanced bracket sequence $s$ with one type of brackets: $\\tt{(}$ and $\\tt{)}$.\n\nThere is a common geometrical representation of such a sequence. Starting at the point $(0, 0)$, you draw a polyline, for each bracket moving along a vector $(1, 1)$ if it is an opening bracket, and along $(1, -1)$ if it is a closing bracket.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5vg5dzar.png)\n\nConsider an area between this curve and the line $y=0$. It is a set of polygons. This area has its center of mass at some point $(x, y)$. Note that the center of mass might be outside of the area.\n\nYou are to solve the reverse problem. Given the length $n$ and a point $(x, y)$, find any balanced bracket sequence of length $n$ such that the center of mass of its geometrical representation is located at $(x, y)$.", "inputFormat": "The first line contains three numbers $n$, $x$, and $y$ ($n$ is an even integer, $2 \\le n \\le 36$; $0 < x, y < n$) --- the length of the desired sequence and the coordinates of the desired center of mass.\n\nIt is guaranteed that $(x, y)$ is the center of mass of some balanced bracket sequence of length $n$, with Euclidean-distance error of no more than $10^{-9}$.", "outputFormat": "Output a balanced bracket sequence with brackets $\\tt{(}$ and $\\tt{)}$ of length $n$ such that the center of mass of its geometrical representation is located at the point $(x, y)$, with Euclidean-distance error of no more than $10^{-7}$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2020] Equilibrium Point /\\/\\", "background": "", "description": "考虑一个由单种括号$\\tt{(}$ 和 $\\tt{)}$ 组成的平衡括号序列 $s$。\n\n这种序列有一种常见的几何表示方法。从点 $(0, 0)$ 出发，根据每个括号类型绘制折线：遇到开括号 $\\tt{(}$ 时沿向量 $(1, 1)$ 移动，遇到闭括号 $\\tt{)}$ 时沿向量 $(1, -1)$ 移动。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/5vg5dzar.png)\n\n考虑这条曲线与直线 $y=0$ 之间的区域。这个区域由若干多边形组成，其质心位于某个点 $(x, y)$。注意质心可能位于该区域之外。\n\n现在你需要解决一个逆向问题：给定长度 $n$ 和一个点 $(x, y)$，找出任意一个长度为 $n$ 的平衡括号序列，使得其几何表示的质心位于 $(x, y)$。", "inputFormat": "第一行包含三个数字 $n$、$x$ 和 $y$（$n$ 为偶数，$2 \\le n \\le 36$；$0 < x, y < n$）—— 目标序列的长度和期望质心的坐标。\n\n题目保证存在某个长度为 $n$ 的平衡括号序列，其几何表示的质心与 $(x, y)$ 的欧几里得距离误差不超过 $10^{-9}$。\n", "outputFormat": "输出一个由 $\\tt{(}$ 和 $\\tt{)}$ 组成的长度为 $n$ 的平衡括号序列，其几何表示的质心与点 $(x, y)$ 的欧几里得距离误差不超过 $10^{-7}$。\n", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12905", "type": "P", "difficulty": 7, "samples": [["3 4\n0 0\n1 0\n0 1", "3.012712585980357"], ["4 5\n0 0\n1 0\n1 1\n0 1", "5.682061989789656"], ["5 17\n0 0\n2 -1\n3 0\n4 3\n-1 4", "37.719371276930820"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "2020", "Special Judge", "微积分", "ICPC", "NERC/NEERC"], "title": "[NERC 2020] Fiber Shape", "background": "", "description": "Imagine a board with $n$ pins put into it, the $i$-th pin is located at $(x_i, y_i)$. \nFor simplicity, we will restrict the problem to the case where the pins are placed in vertices of a convex polygon.\n\nThen, take a non-stretchable string of length $l$, and put it around all the pins. Place a pencil inside the string and draw a curve around the pins, trying to pull the string in every possible direction. The picture below shows an example of a string tied around the pins and pulled by a pencil (a point $P$).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ej1gx8wa.png)\n\nYour task is to find an area inside this curve. Formally, for a given convex polygon $S$ and a length $l$ let's define a $\\emph{fiber shape}$ $F(S, l)$ as a set of points $t$ such that the perimeter of the convex hull of $S \\cup \\{t\\}$ does not exceed $l$. Find an area of $F(S, l)$.", "inputFormat": "The first line contains two integers $n$ and $l$ ($3 \\le n \\le 10^4$; $1 \\le l \\le 8 \\cdot 10^5$) --- the number of vertices of the polygon $S$ and the length of the string. Next $n$ lines contain integers $x_i$ and $y_i$ ($-10^5 \\le x_i, y_i \\le 10^5$) --- coordinates of polygon's vertices in counterclockwise order. All internal angles of the polygon are strictly less than $\\pi$. The length $l$ exceeds the perimeter of the polygon by at least $10^{-3}$.", "outputFormat": "Output a single floating-point number --- the area of the fiber shape $F(S, l)$. Your answer will be considered correct if its absolute or relative error doesn't exceed $10^{-6}$. ", "hint": "The following pictures illustrate the example tests.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lcmvxklh.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nyr1k7a8.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2020] Fiber Shape", "background": "", "description": "Imagine a board with $n$ pins put into it, the $i$-th pin is located at $(x_i, y_i)$. \nFor simplicity, we will restrict the problem to the case where the pins are placed in vertices of a convex polygon.\n\nThen, take a non-stretchable string of length $l$, and put it around all the pins. Place a pencil inside the string and draw a curve around the pins, trying to pull the string in every possible direction. The picture below shows an example of a string tied around the pins and pulled by a pencil (a point $P$).\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ej1gx8wa.png)\n\nYour task is to find an area inside this curve. Formally, for a given convex polygon $S$ and a length $l$ let's define a $\\emph{fiber shape}$ $F(S, l)$ as a set of points $t$ such that the perimeter of the convex hull of $S \\cup \\{t\\}$ does not exceed $l$. Find an area of $F(S, l)$.", "inputFormat": "The first line contains two integers $n$ and $l$ ($3 \\le n \\le 10^4$; $1 \\le l \\le 8 \\cdot 10^5$) --- the number of vertices of the polygon $S$ and the length of the string. Next $n$ lines contain integers $x_i$ and $y_i$ ($-10^5 \\le x_i, y_i \\le 10^5$) --- coordinates of polygon's vertices in counterclockwise order. All internal angles of the polygon are strictly less than $\\pi$. The length $l$ exceeds the perimeter of the polygon by at least $10^{-3}$.", "outputFormat": "Output a single floating-point number --- the area of the fiber shape $F(S, l)$. Your answer will be considered correct if its absolute or relative error doesn't exceed $10^{-6}$. ", "hint": "The following pictures illustrate the example tests.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lcmvxklh.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nyr1k7a8.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2020] Fiber Shape", "background": "", "description": "想象一块钉有 $n$ 个钉子的木板，第 $i$ 个钉子的位置为 $(x_i, y_i)$。为简化问题，我们限定这些钉子位于一个凸多边形的顶点上。\n\n然后取一根长度为 $l$ 的不可伸缩细绳，将其绕过所有钉子。将铅笔置于细绳内侧，尝试向各个方向拉紧细绳并绘制出围绕钉子的曲线。下图展示了细绳绕钉并被铅笔（点 $P$）拉紧的示例。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ej1gx8wa.png)\n\n你的任务是计算该曲线所围成的区域面积。正式地，对于给定凸多边形 $S$ 和长度 $l$，我们定义 **纤维形状** $F(S, l)$ 为满足以下条件的点 $t$ 的集合：$S \\cup \\{t\\}$ 的凸包周长不超过 $l$。请计算 $F(S, l)$ 的面积。", "inputFormat": "第一行包含两个整数 $n$ 和 $l$（$3 \\le n \\le 10^4$；$1 \\le l \\le 8 \\cdot 10^5$）—— 多边形 $S$ 的顶点数和细绳长度。接下来 $n$ 行每行包含两个整数 $x_i$ 和 $y_i$（$-10^5 \\le x_i, y_i \\le 10^5$）—— 按逆时针顺序给出的多边形顶点坐标。多边形的所有内角严格小于 $\\pi$。长度 $l$ 至少比多边形周长大 $10^{-3}$。\n", "outputFormat": "输出一个浮点数——纤维形状 $F(S, l)$ 的面积。若答案的绝对或相对误差不超过 $10^{-6}$ 即视为正确。\n", "hint": "下图展示了样例测试的示意图。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/lcmvxklh.png)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/nyr1k7a8.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12906", "type": "P", "difficulty": 3, "samples": [["3\n6 2\n1 1 2 2 3\n6 6\n1 1 2 2 3\n6 4\n1 2 3 4 5", "1\n1 2\n8\n1 3 6 3 1 2 5 2 4\n3\n1 2 3 4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2020", "Special Judge", "树的遍历", "构造", "ICPC", "NERC/NEERC"], "title": "[NERC 2020] Guide", "background": "", "description": "Mister Gooti is the world-famous guide of The Freezing Isles. The topology of the Isles can be represented as a tree with cities at the vertices and two-way roads between them. \nGooti prepares a new sightseeing tour over the Isles. He wants to find the shortest path that starts in the capital and visits $k$ different cities, including the capital. Please, help him.", "inputFormat": "The first line of the input contains the number of tests $T$ ($1 \\leq T \\leq 100$). Each test consists of two lines. The first line contains the overall number of cities $n$ in the Isles and the requested number of cities $k$ for the tour ($1 \\leq k \\leq n \\leq 100$). The second line contains the description of the tree in a rooted manner: $n - 1$ integers where the $i$-th integer, $p_i$, is the parent of the city $i + 1$ ($1 \\leq p_i \\leq i$). The capital is the city with the number $1$ --- the root of the tree.", "outputFormat": "For each test, the first line of the output shall contain the length of the path $l$. The second line shall contain $l + 1$ integers --- the cities that lie on the path in the order of the traversal.", "hint": "The following pictures illustrate all the three tests from the example.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/93kgqe0s.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2020] Guide", "background": "", "description": "Mister Gooti is the world-famous guide of The Freezing Isles. The topology of the Isles can be represented as a tree with cities at the vertices and two-way roads between them. \nGooti prepares a new sightseeing tour over the Isles. He wants to find the shortest path that starts in the capital and visits $k$ different cities, including the capital. Please, help him.", "inputFormat": "The first line of the input contains the number of tests $T$ ($1 \\leq T \\leq 100$). Each test consists of two lines. The first line contains the overall number of cities $n$ in the Isles and the requested number of cities $k$ for the tour ($1 \\leq k \\leq n \\leq 100$). The second line contains the description of the tree in a rooted manner: $n - 1$ integers where the $i$-th integer, $p_i$, is the parent of the city $i + 1$ ($1 \\leq p_i \\leq i$). The capital is the city with the number $1$ --- the root of the tree.", "outputFormat": "For each test, the first line of the output shall contain the length of the path $l$. The second line shall contain $l + 1$ integers --- the cities that lie on the path in the order of the traversal.", "hint": "The following pictures illustrate all the three tests from the example.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/93kgqe0s.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2020] Guide", "background": "", "description": "Gooti 先生是著名的\"冰封群岛\"导游。群岛的地形可以用一棵树来表示，其中城市位于顶点，双向道路连接这些城市。\n\nGooti 正在准备一条新的群岛观光路线。他想要找到一条从首都出发的最短路径，该路径需要访问 $k$ 个不同的城市（包括首都）。请你帮助他完成这个任务。", "inputFormat": "输入的第一行包含测试用例的数量 $T$（$1 \\leq T \\leq 100$）。每个测试用例由两行组成：第一行包含群岛的城市总数 $n$ 和观光路线需要访问的城市数量 $k$（$1 \\leq k \\leq n \\leq 100$）；第二行以树的有根表示法描述城市间的连接关系：包含 $n - 1$ 个整数，其中第 $i$ 个整数 $p_i$ 表示城市 $i + 1$ 的父节点（$1 \\leq p_i \\leq i$）。编号为 $1$ 的城市是首都，也是树的根节点。\n", "outputFormat": "对于每个测试用例，输出的第一行应包含路径长度 $l$。第二行应包含 $l + 1$ 个整数，按访问顺序列出路径上经过的城市。\n", "hint": "下图展示了示例中的三个测试用例对应的树结构。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/93kgqe0s.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12907", "type": "P", "difficulty": 7, "samples": [["4\n1 10\n2 3\n5 9\n6 7", "7\n3 6\n2 3\n7 9\n6 7"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "各省省选", "2022", "福建", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2020] Hard Optimization", "background": "", "description": "You are given a set of $n$ segments on a line $[L_i; R_i]$. All $2n$ segment endpoints are pairwise distinct integers.\n\nThe set is $\\emph{laminar}$ --- any two segments are either disjoint or one of them contains the other.\n\nChoose a non-empty subsegment $[l_i, r_i]$ with integer endpoints in each segment ($L_i \\le l_i < r_i \\le R_i$) in such a way that no two subsegments intersect (they are allowed to have common endpoints though) and the sum of their lengths ($\\sum_{i=1}^n r_i - l_i$) is maximized.", "inputFormat": "The first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^3$) --- the number of segments.\n\nThe $i$-th of the next $n$ lines contains two integers $L_i$ and $R_i$ ($0 \\le L_i < R_i \\le 10^9$) --- the endpoints of the $i$-th segment.\n\nAll the given $2n$ segment endpoints are distinct. The set of segments is laminar.", "outputFormat": "On the first line, output the maximum possible sum of subsegment lengths.\n\nOn the $i$-th of the next $n$ lines, output two integers $l_i$ and $r_i$ ($L_i \\le l_i < r_i \\le R_i$), denoting the chosen subsegment of the $i$-th segment.", "hint": "The example input and the example output are illustrated below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b5xwqrzp.png)", "locale": "en", "translations": {"en": {"title": "[NERC 2020] Hard Optimization", "background": "", "description": "You are given a set of $n$ segments on a line $[L_i; R_i]$. All $2n$ segment endpoints are pairwise distinct integers.\n\nThe set is $\\emph{laminar}$ --- any two segments are either disjoint or one of them contains the other.\n\nChoose a non-empty subsegment $[l_i, r_i]$ with integer endpoints in each segment ($L_i \\le l_i < r_i \\le R_i$) in such a way that no two subsegments intersect (they are allowed to have common endpoints though) and the sum of their lengths ($\\sum_{i=1}^n r_i - l_i$) is maximized.", "inputFormat": "The first line contains a single integer $n$ ($1 \\le n \\le 2 \\cdot 10^3$) --- the number of segments.\n\nThe $i$-th of the next $n$ lines contains two integers $L_i$ and $R_i$ ($0 \\le L_i < R_i \\le 10^9$) --- the endpoints of the $i$-th segment.\n\nAll the given $2n$ segment endpoints are distinct. The set of segments is laminar.", "outputFormat": "On the first line, output the maximum possible sum of subsegment lengths.\n\nOn the $i$-th of the next $n$ lines, output two integers $l_i$ and $r_i$ ($L_i \\le l_i < r_i \\le R_i$), denoting the chosen subsegment of the $i$-th segment.", "hint": "The example input and the example output are illustrated below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b5xwqrzp.png)", "locale": "en"}, "zh-CN": {"title": "[NERC 2020] Hard Optimization", "background": "NERC 2020 原题要求给出一种方案，而 FJOI 2022 不要求。", "description": "给定数轴上的 $n$ 个线段 $[L_i; R_i]$。所有 $2n$ 个线段端点为两两不同的整数。\n\n这些线段构成一个 **层叠集**——任意两条线段要么不相交，要么其中一条完全包含另一条。\n\n请为每个线段选择一个非空子线段 $[l_i, r_i]$（要求 $L_i \\le l_i < r_i \\le R_i$ 且端点为整数），使得这些子线段互不相交（允许端点重合），并且它们的长度之和（$\\sum_{i=1}^n r_i - l_i$）达到最大。\n", "inputFormat": "第一行包含一个整数 $n$（$1 \\le n \\le 2 \\cdot 10^3$）——线段数量。\n\n接下来 $n$ 行，每行包含两个整数 $L_i$ 和 $R_i$（$0 \\le L_i < R_i \\le 10^9$）——第 $i$ 条线段的端点。\n\n所有 $2n$ 个线段端点互不相同。给定的线段集合是层叠的。", "outputFormat": "第一行输出子线段长度的最大可能和。\n\n接下来的 $n$ 行，每行输出两个整数 $l_i$ 和 $r_i$（$L_i \\le l_i < r_i \\le R_i$），表示第 $i$ 条线段选择的子线段。\n", "hint": "下图展示了示例输入和示例输出的对应关系。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/b5xwqrzp.png)\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12908", "type": "P", "difficulty": 6, "samples": [["3 4\n000\n\n1\n100\n\n1\n001\n\n0\n111\n\n1", "\n\n0\n\n\n0\n\n\n1\n\n\n1\n\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "交互题", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2020] Is It Rated?", "background": "", "description": "The popular improv website $\\emph{Interpretation Impetus}$ hosts regular improv\ncontests and maintains a rating of the best performers. However, since improv can often go horribly wrong, the website is notorious for declaring improv contests $\\emph{unrated}$. It now holds a wager before each improv contest where the participants try to predict whether it will be rated or unrated, and they are now more popular than the improv itself.\n\nIzzy and $n$ other participants take part in each wager. First, they each make\ntheir prediction, expressed as $\\texttt{1}$ (\"rated\") or $\\texttt{0}$ (\"unrated\"). Izzy\nalways goes last, so she knows the predictions of the other participants when making\nher own. Then, the actual competition takes place and it is declared either rated\nor unrated.\n\nYou need to write a program that will interactively play as Izzy. There will be $m$ wagers held in 2021, and Izzy's goal is to have at most\n$1.3\\cdot b + 100$ wrong predictions after all those wagers, where $b$ is the $\\emph{smallest}$\nnumber of wrong predictions that any other wager participant will have after all those wagers. \n\nThe number $b$ is not known in advance. Izzy also knows nothing about\nthe other participants --- they might somehow always guess correctly, or their predictions might be correlated. Izzy's predictions, though, do not affect the predictions of the other participants and the decision on the contest being rated or not --- in other words, in each test case, your program always receives the same inputs, no matter what it outputs.\n\n### Interactive Protocol\n\nFirst, a solution must read two integers $n$ ($1 \\le n \\le 1000$) and $m$ ($1 \\le m \\le 10\\,000$). Then, the solution must process $m$ wagers. For each of them, the solution must first read a string consisting of $n$ $\\texttt{0}$s and $\\texttt{1}$s, in which the $i$-th character denotes the guess of the $i$-th participant. Then, the solution must print Izzy's guess as $\\texttt{0}$ or $\\texttt{1}$.\nDon't forget to flush the output after printing it! Then, the solution must read the actual outcome, also as $\\texttt{0}$ or $\\texttt{1}$, and then proceed to the next wager, if this wasn't the last one. \n\nYour solution will be considered correct if it makes at most $1.3\\cdot b + 100$ mistakes, where $b$ is the smallest number of mistakes made by any other participant. Note that if a solution outputs anything except $\\texttt{0}$ or $\\texttt{1}$ for a wager, it will be considered incorrect even if it made no other mistakes. \n\nThere are 200 test cases in this problem.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "In the example, the participants made 1, 2, and 3 mistakes respectively, therefore $b=1$ (the smallest of these numbers). Izzy made 3 mistakes, which were not more than $1.3\\cdot b + 100=101.3$, so these outputs are good enough to pass this test case (as are any other valid outputs).", "locale": "en", "translations": {"en": {"title": "[NERC 2020] Is It Rated?", "background": "", "description": "The popular improv website $\\emph{Interpretation Impetus}$ hosts regular improv\ncontests and maintains a rating of the best performers. However, since improv can often go horribly wrong, the website is notorious for declaring improv contests $\\emph{unrated}$. It now holds a wager before each improv contest where the participants try to predict whether it will be rated or unrated, and they are now more popular than the improv itself.\n\nIzzy and $n$ other participants take part in each wager. First, they each make\ntheir prediction, expressed as $\\texttt{1}$ (\"rated\") or $\\texttt{0}$ (\"unrated\"). Izzy\nalways goes last, so she knows the predictions of the other participants when making\nher own. Then, the actual competition takes place and it is declared either rated\nor unrated.\n\nYou need to write a program that will interactively play as Izzy. There will be $m$ wagers held in 2021, and Izzy's goal is to have at most\n$1.3\\cdot b + 100$ wrong predictions after all those wagers, where $b$ is the $\\emph{smallest}$\nnumber of wrong predictions that any other wager participant will have after all those wagers. \n\nThe number $b$ is not known in advance. Izzy also knows nothing about\nthe other participants --- they might somehow always guess correctly, or their predictions might be correlated. Izzy's predictions, though, do not affect the predictions of the other participants and the decision on the contest being rated or not --- in other words, in each test case, your program always receives the same inputs, no matter what it outputs.\n\n### Interactive Protocol\n\nFirst, a solution must read two integers $n$ ($1 \\le n \\le 1000$) and $m$ ($1 \\le m \\le 10\\,000$). Then, the solution must process $m$ wagers. For each of them, the solution must first read a string consisting of $n$ $\\texttt{0}$s and $\\texttt{1}$s, in which the $i$-th character denotes the guess of the $i$-th participant. Then, the solution must print Izzy's guess as $\\texttt{0}$ or $\\texttt{1}$.\nDon't forget to flush the output after printing it! Then, the solution must read the actual outcome, also as $\\texttt{0}$ or $\\texttt{1}$, and then proceed to the next wager, if this wasn't the last one. \n\nYour solution will be considered correct if it makes at most $1.3\\cdot b + 100$ mistakes, where $b$ is the smallest number of mistakes made by any other participant. Note that if a solution outputs anything except $\\texttt{0}$ or $\\texttt{1}$ for a wager, it will be considered incorrect even if it made no other mistakes. \n\nThere are 200 test cases in this problem.", "inputFormat": "See Interactive Protocol.", "outputFormat": "See Interactive Protocol.", "hint": "In the example, the participants made 1, 2, and 3 mistakes respectively, therefore $b=1$ (the smallest of these numbers). Izzy made 3 mistakes, which were not more than $1.3\\cdot b + 100=101.3$, so these outputs are good enough to pass this test case (as are any other valid outputs).", "locale": "en"}, "zh-CN": {"title": "[NERC 2020] Is It Rated?", "background": "", "description": "受欢迎的即兴表演网站 **Interpretation Impetus** 定期举办即兴表演竞赛，并维护最佳表演者的评分。然而，由于即兴表演常常可能出错，该网站以宣布即兴竞赛 **unrated** 而闻名。现在，每次即兴竞赛前会举行一场赌局，参与者试图预测竞赛是 rated 还是 unrated，这些赌局甚至比即兴表演本身更受欢迎。\n\nIzzy 和其他 $n$ 名参与者参加每场赌局。首先，他们各自做出预测，用 $\\texttt{1}$（\"rated\"）或 $\\texttt{0}$（\"unrated\"）表示。Izzy 总是最后一个预测，因此她在做出自己的预测时知道其他参与者的预测。接着，实际的竞赛举行，并宣布为 rated 或 unrated。\n\n你需要编写一个程序，以交互方式扮演 Izzy。2021 年将举行 $m$ 场赌局，Izzy 的目标是在所有赌局结束后，其错误预测的数量不超过 $1.3\\cdot b + 100$，其中 $b$ 是其他所有赌局参与者在所有赌局结束后错误预测的**最小**数量。\n\n数值 $b$ 事先未知。Izzy 对其他参与者一无所知——他们可能总是猜对，或者他们的预测可能相互关联。然而，Izzy 的预测不会影响其他参与者的预测或竞赛是否 rated 的决定——换句话说，在每个测试用例中，你的程序始终会接收到相同的输入，无论它输出什么。\n\n### 交互协议\n\n首先，解决方案必须读取两个整数 $n$（$1 \\le n \\le 1000$）和 $m$（$1 \\le m \\le 10\\,000$）。接着，解决方案必须处理 $m$ 场赌局。对于每场赌局，解决方案首先读取一个由 $n$ 个 $\\texttt{0}$ 和 $\\texttt{1}$ 组成的字符串，其中第 $i$ 个字符表示第 $i$ 名参与者的预测。然后，解决方案必须输出 Izzy 的预测 $\\texttt{0}$ 或 $\\texttt{1}$。  \n**注意：输出后必须刷新缓冲区！** 接着，解决方案必须读取实际结果（同样是 $\\texttt{0}$ 或 $\\texttt{1}$），然后继续处理下一场赌局（如果这不是最后一场）。\n\n如果解决方案的错误预测数量不超过 $1.3\\cdot b + 100$，则视为正确，其中 $b$ 是其他参与者中错误预测的最小数量。注意，如果解决方案在某场赌局中输出的不是 $\\texttt{0}$ 或 $\\texttt{1}$，即使没有其他错误，也会被视为不正确。  \n\n本题共有 200 个测试用例。", "inputFormat": "见交互协议。", "outputFormat": "见交互协议。", "hint": "在样例中，其他参与者分别犯了 1、2 和 3 次错误，因此 $b=1$（这些数字中的最小值）。Izzy 犯了 3 次错误，未超过 $1.3\\cdot b + 100=101.3$，因此这些输出足以通过该测试用例（其他任何有效输出同样可以通过）。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12909", "type": "P", "difficulty": 6, "samples": [["__#_____ ", "2\n3 2"], ["_#", "-1"], ["___ ", "0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["贪心", "2020", "Special Judge", "ICPC", "NERC/NEERC"], "title": "[NERC 2020] Japanese Game", "background": "", "description": "Joseph really likes the culture of Japan. Last year he learned Japanese traditional clothes and visual arts and now he is trying to find out the secret of the Japanese game called Nonogram.\n\nIn the one-dimensional version of the game, there is a row of $n$ empty cells, some of which are to be filled with a pen. There is a description of a solution called a $\\emph{profile}$ --- a sequence of positive integers denoting the lengths of consecutive sets of filled cells. For example, the profile of $[4, 3, 1]$ means that there are sets of four, three, and one filled cell, in that order, with at least one empty cell between successive sets.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7vyfivv3.png)\n\nA suitable solution for $n = 12$ and $p = [4, 3, 1]$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8lednxrh.png)\n\nA wrong solution: the first four filled cells should be consecutive.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r2jcjjbb.png)\n\nA wrong solution: there should be at least one empty cell before the last filled cell.\n\nJoseph found out that for some numbers $n$ and profiles $p$ there are lots of ways to fill the cells to satisfy the profile. Now he is in the process of solving a nonogram consisting of $n$ cells and a profile $p$. He has already created a $\\emph{mask}$ of $p$ --- he has filled all the cells that must be filled in every solution of the nonogram.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/io9ajtcp.png)\n\nThe mask for $n = 12$ and $p = [4, 3, 1]$: all the filled cells above are filled in every solution.\n\nAfter a break, he lost the source profile $p$. He only has $n$ and the mask $m$. Help Joseph find any profile $p'$ with the mask $m$ or say that there is no such profile and Joseph has made a mistake.", "inputFormat": "The only line contains a string $m$ --- the mask of the source profile $p$.\nThe length of $m$ is $n$ ($1 \\le n \\le 100\\,000$).\nThe string $m$ consists of symbols $\\texttt{\\#}$ and $\\texttt{\\_}$ --- denoting filled and empty cells respectively.", "outputFormat": "If there is no profile with the mask $m$, output the number $-1$.\nOtherwise, on the first line, output an integer $k$--- the number of integers in the profile $p'$. \nOn the second line, output $k$ integers of the profile $p'$.", "hint": "", "locale": "en", "translations": {"en": {"title": "[NERC 2020] Japanese Game", "background": "", "description": "Joseph really likes the culture of Japan. Last year he learned Japanese traditional clothes and visual arts and now he is trying to find out the secret of the Japanese game called Nonogram.\n\nIn the one-dimensional version of the game, there is a row of $n$ empty cells, some of which are to be filled with a pen. There is a description of a solution called a $\\emph{profile}$ --- a sequence of positive integers denoting the lengths of consecutive sets of filled cells. For example, the profile of $[4, 3, 1]$ means that there are sets of four, three, and one filled cell, in that order, with at least one empty cell between successive sets.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7vyfivv3.png)\n\nA suitable solution for $n = 12$ and $p = [4, 3, 1]$.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8lednxrh.png)\n\nA wrong solution: the first four filled cells should be consecutive.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r2jcjjbb.png)\n\nA wrong solution: there should be at least one empty cell before the last filled cell.\n\nJoseph found out that for some numbers $n$ and profiles $p$ there are lots of ways to fill the cells to satisfy the profile. Now he is in the process of solving a nonogram consisting of $n$ cells and a profile $p$. He has already created a $\\emph{mask}$ of $p$ --- he has filled all the cells that must be filled in every solution of the nonogram.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/io9ajtcp.png)\n\nThe mask for $n = 12$ and $p = [4, 3, 1]$: all the filled cells above are filled in every solution.\n\nAfter a break, he lost the source profile $p$. He only has $n$ and the mask $m$. Help Joseph find any profile $p'$ with the mask $m$ or say that there is no such profile and Joseph has made a mistake.", "inputFormat": "The only line contains a string $m$ --- the mask of the source profile $p$.\nThe length of $m$ is $n$ ($1 \\le n \\le 100\\,000$).\nThe string $m$ consists of symbols $\\texttt{\\#}$ and $\\texttt{\\_}$ --- denoting filled and empty cells respectively.", "outputFormat": "If there is no profile with the mask $m$, output the number $-1$.\nOtherwise, on the first line, output an integer $k$--- the number of integers in the profile $p'$. \nOn the second line, output $k$ integers of the profile $p'$.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[NERC 2020] Japanese Game", "background": "", "description": "Joseph 非常喜欢日本文化。去年他学习了日本传统服饰和视觉艺术，现在他正试图揭开名为 **Nonogram** 的日本游戏的秘密。\n\n在该游戏的一维版本中，有一排 $n$ 个空单元格，其中一些需要用笔填充。游戏的解由一个称为 **profile** 的描述定义——这是一个由正整数构成的序列，表示连续填充单元格块的长度。例如，profile $[4, 3, 1]$ 表示填充的单元格块依次为 4 个、3 个和 1 个，且这些块之间至少有一个空单元格分隔。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7vyfivv3.png)\n\n一个适合 $n = 12$ 且 $p = [4, 3, 1]$ 的解。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8lednxrh.png)\n\n一个错误的解：前四个填充的单元格应该是连续的。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/r2jcjjbb.png)\n\n一个错误的解：最后一个填充的单元格之前应该至少有一个空单元格。\n\nJoseph 发现，对于某些数字 $n$ 和 profile $p$，存在多种填充单元格的方式以满足该 profile。现在，他正在尝试解决一个由 $n$ 个单元格和 profile $p$ 构成的 nonogram 问题。他已经为 $p$ 创建了一个 **mask**——即填充了所有在 nonogram 的每个解中都必须填充的单元格。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/io9ajtcp.png)\n\n$n = 12$ 且 $p = [4, 3, 1]$ 的 mask：上图中所有填充的单元格在每个解中都必须填充。\n\n休息一段时间后，他丢失了原始的 profile $p$。现在他只有 $n$ 和 mask $m$。请你帮助 Joseph 找到任意一个与 mask $m$ 匹配的 profile $p'$，或者说明不存在这样的 profile（即 Joseph 可能犯了错误）。", "inputFormat": "唯一一行包含一个字符串 $m$——表示原始 profile $p$ 的 mask。  \n字符串 $m$ 的长度为 $n$（$1 \\le n \\le 100\\,000$）。  \n字符串 $m$ 由符号 $\\texttt{\\#}$ 和 $\\texttt{\\_}$ 组成，分别表示填充和空的单元格。\n", "outputFormat": "如果不存在与 mask $m$ 匹配的 profile，则输出 $-1$。  \n否则，在第一行输出一个整数 $k$——表示 profile $p'$ 中整数的数量。  \n在第二行，输出 $k$ 个整数，即 profile $p'$。", "hint": "翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12910", "type": "P", "difficulty": 3, "samples": [["3\n6 3 2 5 4 1", "3"], ["2\n3 4 2 1", "-1"], ["4\n1 2 3 4 5 6 7 8", "0"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2020", "广度优先搜索 BFS", "ICPC", "NERC/NEERC"], "title": "[NERC 2020] King's Task", "background": "", "description": "The brave Knight came to the King and asked permission to marry the princess.\nThe King knew that the Knight was brave, but he also wanted to know if he was smart enough. So he asked him to solve the following task.\n\nThere is a permutation $p_i$ of numbers from $1$ to $2n$. You can make two types of operations.\n\n- Swap $p_1$ and $p_2$, $p_3$ and $p_4$, ..., $p_{2n-1}$ and $p_{2n}$. \n- Swap $p_1$ and $p_{n+1}$, $p_2$ and $p_{n+2}$, ..., $p_{n}$ and $p_{2n}$.\n\nThe task is to find the minimal number of operations required to sort the given permutation.\n\nThe Knight was not that smart actually, but quite charming, so the princess asks you to help him to solve the King's task.", "inputFormat": "The first line contains the integer $n$ ($1\\le n\\le 1000$). The second line contains $2n$ integers $p_i$ --- the permutation of numbers from 1 to $2n$.", "outputFormat": "Print one integer --- the minimal number of operations required to sort the permutation. If it is impossible to sort the permutation using these operations, print $-1$.", "hint": "In the first example, you can sort the permutation in three operations:\n- Make operation 1: $3, 6, 5, 2, 1, 4$.\n- Make operation 2: $2, 1, 4, 3, 6, 5$.\n- Make operation 1: $1, 2, 3, 4, 5, 6$.", "locale": "en", "translations": {"en": {"title": "[NERC 2020] King's Task", "background": "", "description": "The brave Knight came to the King and asked permission to marry the princess.\nThe King knew that the Knight was brave, but he also wanted to know if he was smart enough. So he asked him to solve the following task.\n\nThere is a permutation $p_i$ of numbers from $1$ to $2n$. You can make two types of operations.\n\n- Swap $p_1$ and $p_2$, $p_3$ and $p_4$, ..., $p_{2n-1}$ and $p_{2n}$. \n- Swap $p_1$ and $p_{n+1}$, $p_2$ and $p_{n+2}$, ..., $p_{n}$ and $p_{2n}$.\n\nThe task is to find the minimal number of operations required to sort the given permutation.\n\nThe Knight was not that smart actually, but quite charming, so the princess asks you to help him to solve the King's task.", "inputFormat": "The first line contains the integer $n$ ($1\\le n\\le 1000$). The second line contains $2n$ integers $p_i$ --- the permutation of numbers from 1 to $2n$.", "outputFormat": "Print one integer --- the minimal number of operations required to sort the permutation. If it is impossible to sort the permutation using these operations, print $-1$.", "hint": "In the first example, you can sort the permutation in three operations:\n- Make operation 1: $3, 6, 5, 2, 1, 4$.\n- Make operation 2: $2, 1, 4, 3, 6, 5$.\n- Make operation 1: $1, 2, 3, 4, 5, 6$.", "locale": "en"}, "zh-CN": {"title": "[NERC 2020] King's Task", "background": "", "description": "勇敢的骑士来到国王面前，请求迎娶公主。国王知道骑士很勇敢，但他还想确认骑士是否足够聪明。于是国王给骑士布置了以下任务：\n\n有一个从 $1$ 到 $2n$ 的数字排列 $p_i$。你可以进行两种操作：\n\n1. 交换 $p_1$ 和 $p_2$、$p_3$ 和 $p_4$、...、$p_{2n-1}$ 和 $p_{2n}$（即相邻两两交换）。\n2. 交换 $p_1$ 和 $p_{n+1}$、$p_2$ 和 $p_{n+2}$、...、$p_n$ 和 $p_{2n}$（即前半部分与后半部分对应位置交换）。\n\n任务要求找到将给定排列排序所需的最少操作次数。\n\n实际上骑士并没有那么聪明，但他很有魅力，所以公主请你帮助他完成国王的任务。", "inputFormat": "第一行包含整数 $n$（$1 \\le n \\le 1000$）。  \n第二行包含 $2n$ 个整数 $p_i$ —— 表示从 1 到 $2n$ 的一个排列。\n", "outputFormat": "输出一个整数 —— 将排列排序所需的最少操作次数。如果无法通过这些操作将排列排序，则输出 $-1$。\n", "hint": "在第一个样例中，可以通过三次操作将排列排序：\n1. 执行操作 1：$3, 6, 5, 2, 1, 4$。\n2. 执行操作 2：$2, 1, 4, 3, 6, 5$。\n3. 执行操作 1：$1, 2, 3, 4, 5, 6$。\n\n翻译由 DeepSeek V3 完成", "locale": "zh-CN"}}}
{"pid": "P12911", "type": "P", "difficulty": 6, "samples": [["6", "4\n...#\n....\n##..\n###."]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["POI（波兰）", "2021", "Special Judge", "进制", "构造", "Ad-hoc"], "title": "[POI 2020/2021 R2] 棋盘 / Projekt planszy", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4828)。", "description": "**题目译自 [XXVIII Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi28-2/dashboard/) [Projekt planszy](https://szkopul.edu.pl/problemset/problem/tFYVKjavLmyczkxMH7WFewXe/statement/)**\n\n棋盘由 $n \\cdot n$ 个格子组成，分为 $n$ 行和 $n$ 列，格子编号从 $1$ 到 $n$。第 $i$ 行第 $j$ 列的格子坐标为 $(i, j)$。你需要从左上角的格子 $(1,1)$ 走到右下角的格子 $(n, n)$。棋盘上有些格子是被封锁的，你只能在未被封锁的格子上向右或向下移动，也就是说，从格子 $(i, j)$ 可以走到 $(i, j+1)$ 或 $(i+1, j)$，前提是目标格子没有被封锁。\n\n有的棋盘只有一种走法，有的则有多种走法。给定一个数字 $K$，请你设计一个尺寸不超过 $100$ 的棋盘，使从起点到终点的不同走法数量恰好为 $K$。", "inputFormat": "输入的第一行包含一个整数 $K$ $(0 \\leq K)$。", "outputFormat": "输出的第一行是一个整数 $n$ $(1 \\leq n \\leq 100)$，表示棋盘的大小。接下来 $n$ 行，每行输出一个长度为 $n$ 的字符串，由字符 `.`（表示未封锁的格子）和 `#`（表示被封锁的格子）组成。第 $i$ 行的第 $j$ 个字符描述了格子 $(i, j)$ 的状态。\n\n在题目给定的限制条件下，答案总是存在的。如果有多种可能的答案，你的程序可以输出其中任意一种。", "hint": "详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$ | $K \\leq 50$ | $15$ |\n| $2$ | $K \\leq 2000$ | $15$ |\n| $3$ | $K \\leq 10^{9}$ | $40$ |\n| $4$ | $K \\leq 10^{18}$ | $30$ |", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[POI 2020/2021 R2] 棋盘 / Projekt planszy", "background": "翻译来自于 [LibreOJ](https://loj.ac/p/4828)。", "description": "**题目译自 [XXVIII Olimpiada Informatyczna – II etap](https://sio2.mimuw.edu.pl/c/oi28-2/dashboard/) [Projekt planszy](https://szkopul.edu.pl/problemset/problem/tFYVKjavLmyczkxMH7WFewXe/statement/)**\n\n棋盘由 $n \\cdot n$ 个格子组成，分为 $n$ 行和 $n$ 列，格子编号从 $1$ 到 $n$。第 $i$ 行第 $j$ 列的格子坐标为 $(i, j)$。你需要从左上角的格子 $(1,1)$ 走到右下角的格子 $(n, n)$。棋盘上有些格子是被封锁的，你只能在未被封锁的格子上向右或向下移动，也就是说，从格子 $(i, j)$ 可以走到 $(i, j+1)$ 或 $(i+1, j)$，前提是目标格子没有被封锁。\n\n有的棋盘只有一种走法，有的则有多种走法。给定一个数字 $K$，请你设计一个尺寸不超过 $100$ 的棋盘，使从起点到终点的不同走法数量恰好为 $K$。", "inputFormat": "输入的第一行包含一个整数 $K$ $(0 \\leq K)$。", "outputFormat": "输出的第一行是一个整数 $n$ $(1 \\leq n \\leq 100)$，表示棋盘的大小。接下来 $n$ 行，每行输出一个长度为 $n$ 的字符串，由字符 `.`（表示未封锁的格子）和 `#`（表示被封锁的格子）组成。第 $i$ 行的第 $j$ 个字符描述了格子 $(i, j)$ 的状态。\n\n在题目给定的限制条件下，答案总是存在的。如果有多种可能的答案，你的程序可以输出其中任意一种。", "hint": "详细子任务附加限制及分值如下表所示。\n\n| 子任务 | 附加限制 | 分值 |\n| :---: | :--: | :---: |\n| $1$ | $K \\leq 50$ | $15$ |\n| $2$ | $K \\leq 2000$ | $15$ |\n| $3$ | $K \\leq 10^{9}$ | $40$ |\n| $4$ | $K \\leq 10^{18}$ | $30$ |", "locale": "zh-CN"}}}
