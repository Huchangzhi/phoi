{"pid": "P1120", "type": "P", "difficulty": 5, "samples": [["9\n5 2 1 5 2 1 5 2 1\n", "6"]], "limits": {"time": [260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260, 260], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "O2优化", "枚举", "剪枝", "ICPC", "CERC"], "title": "[CERC 1995] 小木棍", "background": "本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）\n\n本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)", "description": "乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。\n\n现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。\n\n给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。", "inputFormat": "第一行是一个整数 $n$，表示小木棍的个数。  \n第二行有 $n$ 个整数，表示各个木棍的长度 $a_i$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "对于全部测试点，$1 \\leq n \\leq 65$，$1 \\leq a_i \\leq 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[CERC 1995] Sticks", "background": null, "description": "George has some small wooden sticks of equal length. He randomly cut these sticks into several pieces until each piece had length no more than $50$. \n\nNow he wants to reassemble the sticks to their original form, but he has forgotten how many sticks he started with and what their lengths were.\n\nGiven the lengths of all the pieces, write a program to find the minimal possible length of the original sticks.", "inputFormat": "The first line contains an integer $n$, the number of stick pieces.  \nThe second line contains $n$ integers, the lengths $a_i$ of the pieces.", "outputFormat": "Output a single integer on one line, representing the answer.", "hint": "For all testdata, $1 \\leq n \\leq 65$, $1 \\leq a_i \\leq 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CERC 1995] 小木棍", "background": "本题**不保证**存在**可以通过满足本题数据范围的任意数据**做法。可以通过此题的程序不一定完全正确（算法时间复杂度错误、或不保证正确性）\n\n本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)", "description": "乔治有一些同样长的小木棍，他把这些木棍随意砍成几段，直到每段的长都不超过 $50$。\n\n现在，他想把小木棍拼接成原来的样子，但是却忘记了自己开始时有多少根木棍和它们的长度。\n\n给出每段小木棍的长度，编程帮他找出原始木棍的最小可能长度。", "inputFormat": "第一行是一个整数 $n$，表示小木棍的个数。  \n第二行有 $n$ 个整数，表示各个木棍的长度 $a_i$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "对于全部测试点，$1 \\leq n \\leq 65$，$1 \\leq a_i \\leq 50$。", "locale": "zh-CN"}}}
{"pid": "P1121", "type": "P", "difficulty": 4, "samples": [["7\n2 -4 3 -1 2 -4 3\n", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "线性数据结构", "枚举"], "title": "环状最大两段子段和", "background": "", "description": "给出一段长度为 $n$ 的环状序列 $a$，即认为 $a_1$ 和 $a_n$ 是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。\n", "inputFormat": "第一行是一个整数 $n$，表示序列的长度。\n\n第二行有 $n$ 个整数，描述序列 $a$，第 $i$ 个数字表示  $a_i$。", "outputFormat": "一行一个整数，为最大的两段子段和是多少。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $2 \\leq n \\leq 2 \\times 10^5$，$-10^4 \\leq a_i \\leq 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "Maximum Sum of Two Non-overlapping Subarrays on a Circle", "background": null, "description": "Given a circular sequence $a$ of length $n$ (that is, $a_1$ and $a_n$ are adjacent), choose two contiguous, non-overlapping, and non-empty subarrays whose total sum is maximized.", "inputFormat": "The first line contains an integer $n$, the length of the sequence.\nThe second line contains $n$ integers describing the sequence $a$; the $i$-th number is $a_i$.", "outputFormat": "Output a single integer on one line: the maximum possible sum of two subarrays.", "hint": "Constraints\n\nFor all test points, it is guaranteed that $2 \\leq n \\leq 2 \\times 10^5$ and $-10^4 \\leq a_i \\leq 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "环状最大两段子段和", "background": "", "description": "给出一段长度为 $n$ 的环状序列 $a$，即认为 $a_1$ 和 $a_n$ 是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。\n", "inputFormat": "第一行是一个整数 $n$，表示序列的长度。\n\n第二行有 $n$ 个整数，描述序列 $a$，第 $i$ 个数字表示  $a_i$。", "outputFormat": "一行一个整数，为最大的两段子段和是多少。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $2 \\leq n \\leq 2 \\times 10^5$，$-10^4 \\leq a_i \\leq 10^4$。", "locale": "zh-CN"}}}
{"pid": "P1122", "type": "P", "difficulty": 3, "samples": [["7\n-1 -1 -1 1 1 1 0\n1 4\n2 5\n3 6\n4 7\n5 7\n6 7\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "树形 DP"], "title": "最大子树和", "background": null, "description": "小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：\n\n一株奇怪的花卉，上面共连有 $n$ 朵花，共有 $n-1$ 条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。\n\n老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。", "inputFormat": "第一行一个整数 $n\\ (1\\le n\\le 16000)$。表示原始的那株花卉上共 $n$ 朵花。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 朵花的美丽指数。\n\n接下来 $n-1$ 行每行两个整数 $a,b$，表示存在一条连接第 $a$ 朵花和第 $b$ 朵花的枝条。", "outputFormat": "一个数，表示一系列“修剪”之后所能得到的“美丽指数”之和的最大值。保证绝对值不超过 $2147483647$。", "hint": "### 数据范围及约定\n\n- 对于 $60\\%$ 的数据，有 $1\\le n\\le 1000$；\n- 对于 $100\\%$ 的数据，有 $1\\le n\\le 16000$。", "locale": "zh-CN", "translations": {"en": {"title": "Maximum Subtree Sum", "background": null, "description": "Xiao Ming is very interested in mathematics and is a diligent student who always stays after class to ask the teacher questions. One morning on his way to school by bike, he saw an old man trimming plants and suddenly thought of a problem about pruning flowers. After class that day, Xiao Ming presented the following problem to his teacher:\n\nThere is a strange plant with $n$ flowers in total, connected by $n - 1$ branches so that before pruning, no flower is isolated. Each flower has a “beauty index,” where a larger value means the flower is more beautiful; some beauty indices can be negative, meaning the flower looks unpleasant. “Pruning” means removing one of the branches, which splits the plant into two, and then discarding one of them. After a sequence of prunings, only one plant remains (which could be a single flower). The task is to perform a sequence of prunings (or none at all) to maximize the sum of the beauty indices of all flowers on the remaining plant.\n\nThe teacher quickly gave the correct solution. Seeing the problem solved so easily, Xiao Ming felt unsatisfied and brought it to you.", "inputFormat": "- The first line contains an integer $n$ ($1 \\le n \\le 16000$), the number of flowers on the original plant.\n- The second line contains $n$ integers. The $i$-th integer is the beauty index of the $i$-th flower.\n- The next $n - 1$ lines each contain two integers $a, b$, indicating there is a branch connecting the $a$-th flower and the $b$-th flower.", "outputFormat": "Output a single integer, the maximum possible sum of beauty indices after a sequence of prunings. The absolute value is guaranteed not to exceed $2147483647$.", "hint": "### Constraints\n\n- For $60\\%$ of the testdata, $1 \\le n \\le 1000$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 16000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最大子树和", "background": null, "description": "小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：\n\n一株奇怪的花卉，上面共连有 $n$ 朵花，共有 $n-1$ 条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。\n\n老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。", "inputFormat": "第一行一个整数 $n\\ (1\\le n\\le 16000)$。表示原始的那株花卉上共 $n$ 朵花。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 朵花的美丽指数。\n\n接下来 $n-1$ 行每行两个整数 $a,b$，表示存在一条连接第 $a$ 朵花和第 $b$ 朵花的枝条。", "outputFormat": "一个数，表示一系列“修剪”之后所能得到的“美丽指数”之和的最大值。保证绝对值不超过 $2147483647$。", "hint": "### 数据范围及约定\n\n- 对于 $60\\%$ 的数据，有 $1\\le n\\le 1000$；\n- 对于 $100\\%$ 的数据，有 $1\\le n\\le 16000$。", "locale": "zh-CN"}}}
{"pid": "P1123", "type": "P", "difficulty": 3, "samples": [["3\n4 4\n67 75 63 10\n29 29 92 14\n21 68 71 56\n8 67 91 25\n2 3\n87 70 85\n10 3 17\n3 3\n1 1 1\n1 99 1\n1 1 1\n\n", "271\n172\n99\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "枚举", "深度优先搜索 DFS", "状压 DP"], "title": "取数游戏", "background": null, "description": "一个 $N\\times M$ 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 $8$ 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。", "inputFormat": "第一行有一个正整数 $T$，表示了有 $T$ 组数据。\n\n对于每一组数据，第一行有两个正整数 $N$ 和 $M$，表示了数字矩阵为 $N$ 行 $M$ 列。\n\n接下来 $N$ 行，每行 $M$ 个非负整数，描述了这个数字矩阵。", "outputFormat": "共 $T$ 行，每行一个非负整数，输出所求得的答案。", "hint": "### 样例解释\n\n对于第一组数据，取数方式如下：\n\n$$\\begin{matrix}\n[67] & 75 & 63 & 10 \\\\\n29 & 29 & [92] & 14 \\\\\n[21] & 68 & 71 & 56 \\\\\n8 & 67 & [91] & 25 \\\\\n\\end{matrix}$$\n\n\n### 数据范围及约定\n\n- 对于$20\\%$的数据，$1\\le N, M \\le 3$；\n- 对于$40\\%$的数据，$1\\le N, M\\le 4$；\n- 对于$60\\%$的数据，$1\\le N, M\\le 5$；\n- 对于$100\\%$的数据，$1\\le N, M\\le 6$，$1\\le T\\le 20$，$a_{i,j}\\le10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Number Picking Game", "background": null, "description": "Given an $N\\times M$ matrix of non-negative integers, you need to select some numbers such that no two selected numbers are adjacent. Two numbers are considered adjacent if one is in any of the 8 neighboring cells of the other (including diagonals). Find the maximum possible sum of the selected numbers.", "inputFormat": "The first line contains a positive integer $T$, indicating there are $T$ test cases.\n\nFor each test case, the first line contains two positive integers $N$ and $M$, indicating the matrix has $N$ rows and $M$ columns.\n\nThe next $N$ lines each contain $M$ non-negative integers, describing the matrix.", "outputFormat": "Output $T$ lines, each containing a single non-negative integer: the required answer.", "hint": "### Sample Explanation\n\nFor the first test case, a valid selection is as follows:\n\n$$\\begin{matrix}\n[67] & 75 & 63 & 10 \\\\\n29 & 29 & [92] & 14 \\\\\n[21] & 68 & 71 & 56 \\\\\n8 & 67 & [91] & 25 \\\\\n\\end{matrix}$$\n\n### Constraints\n\n- For 20% of the testdata, $1\\le N, M \\le 3$.\n- For 40% of the testdata, $1\\le N, M \\le 4$.\n- For 60% of the testdata, $1\\le N, M \\le 5$.\n- For 100% of the testdata, $1\\le N, M \\le 6$, $1\\le T \\le 20$, $a_{i,j}\\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "取数游戏", "background": null, "description": "一个 $N\\times M$ 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 $8$ 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。", "inputFormat": "第一行有一个正整数 $T$，表示了有 $T$ 组数据。\n\n对于每一组数据，第一行有两个正整数 $N$ 和 $M$，表示了数字矩阵为 $N$ 行 $M$ 列。\n\n接下来 $N$ 行，每行 $M$ 个非负整数，描述了这个数字矩阵。", "outputFormat": "共 $T$ 行，每行一个非负整数，输出所求得的答案。", "hint": "### 样例解释\n\n对于第一组数据，取数方式如下：\n\n$$\\begin{matrix}\n[67] & 75 & 63 & 10 \\\\\n29 & 29 & [92] & 14 \\\\\n[21] & 68 & 71 & 56 \\\\\n8 & 67 & [91] & 25 \\\\\n\\end{matrix}$$\n\n\n### 数据范围及约定\n\n- 对于$20\\%$的数据，$1\\le N, M \\le 3$；\n- 对于$40\\%$的数据，$1\\le N, M\\le 4$；\n- 对于$60\\%$的数据，$1\\le N, M\\le 5$；\n- 对于$100\\%$的数据，$1\\le N, M\\le 6$，$1\\le T\\le 20$，$a_{i,j}\\le10^5$。", "locale": "zh-CN"}}}
{"pid": "P1124", "type": "P", "difficulty": 4, "samples": [["7\nxelpame\n7\n", "example\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串"], "title": "文件压缩", "background": "提高文件的压缩率一直是人们追求的目标。近几年有人提出了这样一种算法，它虽然只是单纯地对文件进行重排，本身并不压缩文件，但是经这种算法调整后的文件在大多数情况下都能获得比原来更大的压缩率。\n", "description": "该算法具体如下：对一个长度为 $n$ 的字符串 $S$，首先根据它构造 $n$ 个字符串，其中第 $i$ 个字符串由将 $S$ 的前 $i-1$ 个字符置于末尾得到。然后把这 $n$ 个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们**在 $S$ 中的位置**从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串 $S'$ ，它的长度也是 $n$，并且包含了 $S$ 中的每一个字符。最后输出 $S'$ 以及 $S$ 的首字符在 $S'$ 中的位置 $p$。\n\n举例：$S$ 是 `example`\n\n1. 构造 $n$ 个字符串。\n\n```plain\nexample\nxamplee\nampleex\nmpleexa\npleexam\nleexamp\neexampl\n```\n\n2. 将字符串排序。\n\n```plain\nampleex\nexample\neexampl\nleexamp\nmpleexa\npleexam\nxamplee\n```\n3. 压缩结果。\n\n$S' = \\texttt{xelpame}$，$p = 7$\n\n由于英语单词构造的特殊性，某些字母对出现的频率很高，因此在 $S'$ 中相同的字母有很大几率排在一起，从而提高 $S'$ 的压缩率。虽然这种算法利用了英语单词的特性，然而在实践的过程中，人们发现它几乎适用于所有的文件压缩。\n\n请你编一个程序，读入 $S'$ 和 $p$，输出字符串 $S$。\n\n保证 $S$ 仅含小写字母（所以输入的 $S'$ 也仅含小写字母）。", "inputFormat": "共三行。\n\n第一行是一个整数 $n$（$1 \\le n \\le 10000$），代表 $S'$ 的长度。\n\n第二行是字符串 $S'$。\n\n第三行是整数 $p$。", "outputFormat": "一行，$S$。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "File Compression", "background": null, "description": "The algorithm is as follows: For a string $S$ of length $n$, first construct $n$ strings, where the $i$-th string is obtained by moving the first $i-1$ characters of $S$ to the end. Then sort these $n$ strings by their first character in ascending order; if two strings have the same first character, sort them by their positions in $S$ in ascending order. The last characters of the sorted strings form a new string $S'$, whose length is also $n$ and which contains every character of $S$. Finally, output $S'$ and the position $p$ of the first character of $S$ in $S'$.\n\nExample: $S$ is `example`.\n\n1. Construct $n$ strings.\n\n```plain\nexample\nxamplee\nampleex\nmpleexa\npleexam\nleexamp\neexampl\n```\n\n2. Sort the strings.\n\n```plain\nampleex\nexample\neexampl\nleexamp\nmpleexa\npleexam\nxamplee\n```\n\n3. Compression result.\n\n$S' = \\texttt{xelpame}$，$p = 7$。\n\nBecause of the characteristics of English words, certain letters occur very frequently, so identical letters are very likely to be grouped together in $S'$, which improves the compression ratio of $S'$. Although this algorithm leverages properties of English words, in practice it is found to work for almost all file compression.\n\nWrite a program that reads $S'$ and $p$, and outputs the string $S$.\n\nIt is guaranteed that $S$ contains only lowercase letters (so the input $S'$ also contains only lowercase letters).", "inputFormat": "Three lines in total.\n\nThe first line contains an integer $n$ ($1 \\le n \\le 10000$), the length of $S'$.\n\nThe second line contains the string $S'$.\n\nThe third line contains an integer $p$.", "outputFormat": "One line, the string $S$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "文件压缩", "background": "提高文件的压缩率一直是人们追求的目标。近几年有人提出了这样一种算法，它虽然只是单纯地对文件进行重排，本身并不压缩文件，但是经这种算法调整后的文件在大多数情况下都能获得比原来更大的压缩率。\n", "description": "该算法具体如下：对一个长度为 $n$ 的字符串 $S$，首先根据它构造 $n$ 个字符串，其中第 $i$ 个字符串由将 $S$ 的前 $i-1$ 个字符置于末尾得到。然后把这 $n$ 个字符串按照首字符从小到大排序，如果两个字符串的首字符相等，则按照它们**在 $S$ 中的位置**从小到大排序。排序后的字符串的尾字符可以组成一个新的字符串 $S'$ ，它的长度也是 $n$，并且包含了 $S$ 中的每一个字符。最后输出 $S'$ 以及 $S$ 的首字符在 $S'$ 中的位置 $p$。\n\n举例：$S$ 是 `example`\n\n1. 构造 $n$ 个字符串。\n\n```plain\nexample\nxamplee\nampleex\nmpleexa\npleexam\nleexamp\neexampl\n```\n\n2. 将字符串排序。\n\n```plain\nampleex\nexample\neexampl\nleexamp\nmpleexa\npleexam\nxamplee\n```\n3. 压缩结果。\n\n$S' = \\texttt{xelpame}$，$p = 7$\n\n由于英语单词构造的特殊性，某些字母对出现的频率很高，因此在 $S'$ 中相同的字母有很大几率排在一起，从而提高 $S'$ 的压缩率。虽然这种算法利用了英语单词的特性，然而在实践的过程中，人们发现它几乎适用于所有的文件压缩。\n\n请你编一个程序，读入 $S'$ 和 $p$，输出字符串 $S$。\n\n保证 $S$ 仅含小写字母（所以输入的 $S'$ 也仅含小写字母）。", "inputFormat": "共三行。\n\n第一行是一个整数 $n$（$1 \\le n \\le 10000$），代表 $S'$ 的长度。\n\n第二行是字符串 $S'$。\n\n第三行是整数 $p$。", "outputFormat": "一行，$S$。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1125", "type": "P", "difficulty": 2, "samples": [["error", "Lucky Word\n2"], ["olympic", "No Answer\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "NOIP 提高组", "素数判断,质数,筛法"], "title": "[NOIP 2008 提高组] 笨小猴", "background": null, "description": "笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！\n\n这种方法的具体描述如下：假设 $\\text{maxn}$ 是单词中出现次数最多的字母的出现次数，$\\text{minn}$ 是单词中出现次数最少的字母的出现次数，如果 $\\text{maxn}-\\text{minn}$ 是一个质数，那么笨小猴就认为这是个 Lucky Word，这样的单词很可能就是正确的答案。", "inputFormat": "一个单词，其中只可能出现小写字母，并且长度小于 $100$。", "outputFormat": "共两行，第一行是一个字符串，假设输入的单词是 Lucky Word，那么输出 `Lucky Word`，否则输出 `No Answer`；\n\n第二行是一个整数，如果输入的单词是 Lucky Word，输出 $\\text{maxn}-\\text{minn}$ 的值，否则输出 $0$。", "hint": "【输入输出样例 1 解释】\n\n单词 `error` 中出现最多的字母 $\\texttt r$ 出现了 $3$ 次，出现次数最少的字母出现了 $1$ 次，$3-1=2$，$2$ 是质数。\n\n【输入输出样例 2 解释】\n\n单词 `olympic` 中出现最多的字母 $\\texttt i$ 出现了 $1$ 次，出现次数最少的字母出现了 $1$ 次，$1-1=0$，$0$ 不是质数。\n\n（本处原题面错误已经修正）\n\nnoip2008 提高第一题", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2008 Senior] Silly Little Monkey", "background": null, "description": "The silly little monkey has a very small vocabulary, so he always struggles with English multiple-choice questions. But he found a method, and experiments show that using this method greatly increases the chance of choosing the correct option.\n\nThe method is described as follows: suppose $ \\text{maxn} $ is the number of occurrences of the most frequent letter in a word, and $ \\text{minn} $ is the number of occurrences of the least frequent letter in the word. If $ \\text{maxn}-\\text{minn} $ is a prime number, then the silly little monkey considers this a Lucky Word. Such a word is very likely to be the correct answer.", "inputFormat": "A single word containing only lowercase letters, with length less than $100$.", "outputFormat": "Two lines in total. The first line is a string: if the input word is a Lucky Word, output `Lucky Word`; otherwise, output `No Answer`.\n\nThe second line is an integer: if the input word is a Lucky Word, output the value of $ \\text{maxn}-\\text{minn} $; otherwise, output $0$.", "hint": "[Explanation for Sample Input/Output 1]\n\nIn the word `error`, the most frequent letter $ \\texttt{r} $ appears $3$ times, and the least frequent letter appears $1$ time. $3-1=2$, and $2$ is a prime number.\n\n[Explanation for Sample Input/Output 2]\n\nIn the word `olympic`, the most frequent letter $ \\texttt{i} $ appears $1$ time, and the least frequent letter appears $1$ time. $1-1=0$, and $0$ is not a prime number.\n\n(The original error in this part has been corrected.)\n\nNOIP 2008 Senior, Problem 1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2008 提高组] 笨小猴", "background": null, "description": "笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！\n\n这种方法的具体描述如下：假设 $\\text{maxn}$ 是单词中出现次数最多的字母的出现次数，$\\text{minn}$ 是单词中出现次数最少的字母的出现次数，如果 $\\text{maxn}-\\text{minn}$ 是一个质数，那么笨小猴就认为这是个 Lucky Word，这样的单词很可能就是正确的答案。", "inputFormat": "一个单词，其中只可能出现小写字母，并且长度小于 $100$。", "outputFormat": "共两行，第一行是一个字符串，假设输入的单词是 Lucky Word，那么输出 `Lucky Word`，否则输出 `No Answer`；\n\n第二行是一个整数，如果输入的单词是 Lucky Word，输出 $\\text{maxn}-\\text{minn}$ 的值，否则输出 $0$。", "hint": "【输入输出样例 1 解释】\n\n单词 `error` 中出现最多的字母 $\\texttt r$ 出现了 $3$ 次，出现次数最少的字母出现了 $1$ 次，$3-1=2$，$2$ 是质数。\n\n【输入输出样例 2 解释】\n\n单词 `olympic` 中出现最多的字母 $\\texttt i$ 出现了 $1$ 次，出现次数最少的字母出现了 $1$ 次，$1-1=0$，$0$ 不是质数。\n\n（本处原题面错误已经修正）\n\nnoip2008 提高第一题", "locale": "zh-CN"}}}
{"pid": "P1126", "type": "P", "difficulty": 4, "samples": [["9 10\n0 0 0 0 0 0 1 0 0 0\n0 0 0 0 0 0 0 0 1 0\n0 0 0 1 0 0 0 0 0 0\n0 0 1 0 0 0 0 0 0 0\n0 0 0 0 0 0 1 0 0 0\n0 0 0 0 0 1 0 0 0 0\n0 0 0 1 1 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 0 0 1 0\n7 2 2 7 S", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "广度优先搜索 BFS", "队列"], "title": "机器人搬重物", "background": "", "description": "机器人移动学会（RMI）现在正尝试用机器人搬运物品。机器人的形状是一个直径 $1.6$ 米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个 $N\\times M$ 的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：\n\n- 向前移动 $1$ 步（`Creep`）；\n- 向前移动 $2$ 步（`Walk`）；\n- 向前移动 $3$ 步（`Run`）；\n- 向左转（`Left`）；\n- 向右转（`Right`）。\n\n每个指令所需要的时间为 $1$ 秒。请你计算一下机器人完成任务所需的最少时间。", "inputFormat": "第一行为两个正整数 $N,M\\ (1\\le N,M\\le50)$，下面 $N$ 行是储藏室的构造，$0$ 表示无障碍，$1$ 表示有障碍，数字之间用一个空格隔开。接着一行有 $4$ 个整数和 $1$ 个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向（东 $\\tt  E$，南 $\\tt  S$，西 $\\tt W$，北 $\\tt N$），数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。", "outputFormat": "一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出 $-1$。\n\n \n![](https://cdn.luogu.com.cn/upload/image_hosting/mma661em.png)\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Robot Moving Heavy Objects", "background": null, "description": "The Robot Mobility Institute (RMI) is now trying to use robots to transport items. The robot is a sphere with a diameter of $1.6$ meters. During the trial phase, the robot is used to move cargo in a storeroom. The storeroom is an $N\\times M$ grid, and some cells are immovable obstacles. The robot’s center is always on grid points. Of course, the robot must deliver the item to the designated location in the shortest time. The robot accepts the following commands:\n- Move forward $1$ step (`Creep`);\n- Move forward $2$ steps (`Walk`);\n- Move forward $3$ steps (`Run`);\n- Turn left (`Left`);\n- Turn right (`Right`).\n\nEach command takes $1$ second. Please compute the minimum time required for the robot to complete the task.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mma661em.png)", "inputFormat": "The first line contains two positive integers $N,M\\ (1\\le N,M\\le50)$. The next $N$ lines describe the storeroom layout: $0$ means no obstacle, and $1$ means an obstacle. Numbers are separated by a single space. Then one line contains $4$ integers and $1$ uppercase letter, which are the row and column of the top-left cell of the starting point and the target point, and the initial facing direction (east $\\tt  E$, south $\\tt  S$, west $\\tt W$, north $\\tt N$). There is a single space between numbers, and between numbers and the letter. The facing direction at the destination is arbitrary.", "outputFormat": "Output one integer, the minimum time required for the robot to complete the task. If it is impossible to reach the destination, output $-1$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "机器人搬重物", "background": "", "description": "机器人移动学会（RMI）现在正尝试用机器人搬运物品。机器人的形状是一个直径 $1.6$ 米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个 $N\\times M$ 的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：\n\n- 向前移动 $1$ 步（`Creep`）；\n- 向前移动 $2$ 步（`Walk`）；\n- 向前移动 $3$ 步（`Run`）；\n- 向左转（`Left`）；\n- 向右转（`Right`）。\n\n每个指令所需要的时间为 $1$ 秒。请你计算一下机器人完成任务所需的最少时间。", "inputFormat": "第一行为两个正整数 $N,M\\ (1\\le N,M\\le50)$，下面 $N$ 行是储藏室的构造，$0$ 表示无障碍，$1$ 表示有障碍，数字之间用一个空格隔开。接着一行有 $4$ 个整数和 $1$ 个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向（东 $\\tt  E$，南 $\\tt  S$，西 $\\tt W$，北 $\\tt N$），数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。", "outputFormat": "一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出 $-1$。\n\n \n![](https://cdn.luogu.com.cn/upload/image_hosting/mma661em.png)\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P1127", "type": "P", "difficulty": 5, "samples": [["6\naloha\narachnid\ndog\ngopher\nrat\ntiger", "aloha.arachnid.dog.gopher.rat.tiger"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "图论", "欧拉回路"], "title": "词链", "background": "", "description": "如果单词 $X$ 的末字母与单词 $Y$ 的首字母相同，则 $X$ 与 $Y$ 可以相连成 $X.Y$。（注意：$X$、$Y$ 之间是英文的句号 `.`）。例如，单词 `dog` 与单词 `gopher`，则 `dog` 与 `gopher` 可以相连成 `dog.gopher`。\n\n另外还有一些例子：\n- `dog.gopher`\n- `gopher.rat`\n- `rat.tiger`\n- `aloha.aloha`\n- `arachnid.dog`\n\n连接成的词可以与其他单词相连，组成更长的词链，例如：\n\n`aloha.arachnid.dog.gopher.rat.tiger`\n\n注意到，`.` 两边的字母一定是相同的。\n\n现在给你一些单词，请你找到字典序最小的词链，使得每个单词在词链中出现且仅出现一次。注意，相同的单词若出现了 $k$ 次就需要输出 $k$ 次。", "inputFormat": "第一行是一个正整数 $n$（$1 \\le n \\le 1000$），代表单词数量。\n\n接下来共有 $n$ 行，每行是一个由 $1$ 到 $20$ 个小写字母组成的单词。", "outputFormat": "只有一行，表示组成字典序最小的词链，若不存在则只输出三个星号 `***`。\n", "hint": "- 对于 $40\\%$ 的数据，有 $n \\leq 10$；\n- 对于 $100\\%$ 的数据，有 $n \\leq 1000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Word Chain", "background": null, "description": "If the last letter of word $X$ is the same as the first letter of word $Y$, then $X$ and $Y$ can be concatenated as $X.Y$. Note: there is an English period `.` between $X$ and $Y$. For example, for the words `dog` and `gopher`, `dog` and `gopher` can be concatenated as `dog.gopher`.\n\nMore examples:\n- `dog.gopher`\n- `gopher.rat`\n- `rat.tiger`\n- `aloha.aloha`\n- `arachnid.dog`\n\nA concatenated word can be connected with other words to form a longer word chain, for example:\n\n`aloha.arachnid.dog.gopher.rat.tiger`\n\nNote that the letters on both sides of `.` must be the same.\n\nNow you are given some words. Please find the lexicographically smallest word chain such that each word appears in the chain exactly once. Note that if the same word appears $k$ times, you must output it $k$ times.", "inputFormat": "The first line contains a positive integer $n$ ($1 \\le n \\le 1000$), representing the number of words.\n\nThe next $n$ lines each contain a word consisting of $1$ to $20$ lowercase letters.", "outputFormat": "Output a single line: the lexicographically smallest word chain that uses every given word exactly once. If such a chain does not exist, output exactly three asterisks `***`.", "hint": "- For $40\\%$ of the testdata, $n \\le 10$.\n- For $100\\%$ of the testdata, $n \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "词链", "background": "", "description": "如果单词 $X$ 的末字母与单词 $Y$ 的首字母相同，则 $X$ 与 $Y$ 可以相连成 $X.Y$。（注意：$X$、$Y$ 之间是英文的句号 `.`）。例如，单词 `dog` 与单词 `gopher`，则 `dog` 与 `gopher` 可以相连成 `dog.gopher`。\n\n另外还有一些例子：\n- `dog.gopher`\n- `gopher.rat`\n- `rat.tiger`\n- `aloha.aloha`\n- `arachnid.dog`\n\n连接成的词可以与其他单词相连，组成更长的词链，例如：\n\n`aloha.arachnid.dog.gopher.rat.tiger`\n\n注意到，`.` 两边的字母一定是相同的。\n\n现在给你一些单词，请你找到字典序最小的词链，使得每个单词在词链中出现且仅出现一次。注意，相同的单词若出现了 $k$ 次就需要输出 $k$ 次。", "inputFormat": "第一行是一个正整数 $n$（$1 \\le n \\le 1000$），代表单词数量。\n\n接下来共有 $n$ 行，每行是一个由 $1$ 到 $20$ 个小写字母组成的单词。", "outputFormat": "只有一行，表示组成字典序最小的词链，若不存在则只输出三个星号 `***`。\n", "hint": "- 对于 $40\\%$ 的数据，有 $n \\leq 10$；\n- 对于 $100\\%$ 的数据，有 $n \\leq 1000$。\n", "locale": "zh-CN"}}}
{"pid": "P1128", "type": "P", "difficulty": 5, "samples": [[" 4\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "高精度", "2001", "各省省选", "湖南"], "title": "[HNOI2001] 求正整数", "background": "", "description": "对于任意输入的正整数 $n$，请求出具有 $n$ 个不同因子的最小正整数 $m$。\n\n例如：$n=4$，则 $m=6$，因为 $6$ 有 $4$ 个不同整数因子 $1,2,3,6$；而且是最小的有 $4$ 个因子的整数。", "inputFormat": "输入有且仅有一行一个整数，代表 $n$。\n", "outputFormat": "输出一行一个整数，代表符合条件的最小正整数 $m$。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 5 \\times 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2001] Find the Positive Integer", "background": null, "description": "Given a positive integer $n$, find the smallest positive integer $m$ that has $n$ distinct divisors.\n\nFor example: when $n=4$, $m=6$, because $6$ has $4$ distinct positive divisors $1, 2, 3, 6$, and it is the smallest integer that has $4$ divisors.", "inputFormat": "The input contains exactly one line with a single integer representing $n$.", "outputFormat": "Output a single line with one integer: the smallest positive integer $m$ that satisfies the condition.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 5 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2001] 求正整数", "background": "", "description": "对于任意输入的正整数 $n$，请求出具有 $n$ 个不同因子的最小正整数 $m$。\n\n例如：$n=4$，则 $m=6$，因为 $6$ 有 $4$ 个不同整数因子 $1,2,3,6$；而且是最小的有 $4$ 个因子的整数。", "inputFormat": "输入有且仅有一行一个整数，代表 $n$。\n", "outputFormat": "输出一行一个整数，代表符合条件的最小正整数 $m$。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 5 \\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P1129", "type": "P", "difficulty": 5, "samples": [["2\n2\n0 0\n0 1\n3\n0 0 1\n0 1 0\n1 0 0\n", "No\nYes\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2007", "各省省选", "递归", "网络流", "浙江", "二分图"], "title": "[ZJOI2007] 矩阵游戏", "background": null, "description": "小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \\times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：\n\n- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。\n- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。\n\n游戏的目标，即通过若干次操作，使得方阵的主对角线（左上角到右下角的连线）上的格子均为黑色。\n\n对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。", "inputFormat": "**本题有多组测试数据**。\n\n第一行包含一个整数 $T$，表示数据的组数，对于每组数据，输入格式如下：\n\n第一行为一个整数，代表方阵的大小 $n$。\n接下来 $n$ 行，每行 $n$ 个非零即一的整数，代表该方阵。其中 $0$ 表示白色，$1$ 表示黑色。", "outputFormat": "对于每组数据，输出一行一个字符串，若关卡有解则输出 `Yes`，否则输出 `No`。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $n \\leq 7$。\n- 对于 $50\\%$ 的数据，保证 $n \\leq 50$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 200$，$1 \\leq T \\leq 20$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2007] Matrix Game", "background": null, "description": "Little Q is a very smart kid. Besides chess, he also likes a computer puzzle game called the Matrix Game. The game is played on an $n \\times n$ black-and-white grid (similar to a chessboard, but colors are arbitrary). Each move allows one of the following operations:\n\n- Row swap: choose any two rows of the matrix and swap them (i.e., swap the colors of the corresponding cells).\n- Column swap: choose any two columns of the matrix and swap them (i.e., swap the colors of the corresponding cells).\n\nThe goal is to make all cells on the main diagonal (from the top-left corner to the bottom-right corner) black after some number of operations.\n\nFor some levels, Little Q cannot figure out the solution and starts to suspect that they may be unsolvable. So he decides to write a program to determine whether a given level is solvable.", "inputFormat": "This problem has multiple test cases.\n\nThe first line contains an integer $T$, the number of test cases. For each test case:\n- The first line contains an integer $n$, the size of the grid.\n- The next $n$ lines each contain $n$ integers, each being 0 or 1, representing the grid. Here, 0 means white and 1 means black.", "outputFormat": "For each test case, output one line with a single string: output Yes if the level is solvable, otherwise output No.", "hint": "Constraints\n- For 20% of the testdata, $n \\leq 7$.\n- For 50% of the testdata, $n \\leq 50$.\n- For 100% of the testdata, $1 \\leq n \\leq 200$, $1 \\leq T \\leq 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2007] 矩阵游戏", "background": null, "description": "小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \\times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：\n\n- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。\n- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。\n\n游戏的目标，即通过若干次操作，使得方阵的主对角线（左上角到右下角的连线）上的格子均为黑色。\n\n对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。", "inputFormat": "**本题有多组测试数据**。\n\n第一行包含一个整数 $T$，表示数据的组数，对于每组数据，输入格式如下：\n\n第一行为一个整数，代表方阵的大小 $n$。\n接下来 $n$ 行，每行 $n$ 个非零即一的整数，代表该方阵。其中 $0$ 表示白色，$1$ 表示黑色。", "outputFormat": "对于每组数据，输出一行一个字符串，若关卡有解则输出 `Yes`，否则输出 `No`。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $n \\leq 7$。\n- 对于 $50\\%$ 的数据，保证 $n \\leq 50$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 200$，$1 \\leq T \\leq 20$。", "locale": "zh-CN"}}}
{"pid": "P1130", "type": "P", "difficulty": 2, "samples": [["4 3 \n2 6 1 8\n3 6 2 6\n4 2 3 6\n", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "红牌", "background": "", "description": "\n某地临时居民想获得长期居住权就必须申请拿到红牌。获得红牌的过程是相当复杂 ，一共包括 $N$ 个步骤。每一步骤都由政府的某个工作人员负责检查你所提交的材料是否符合条件。为了加快进程，每一步政府都派了 $M$ 个工作人员来检查材料。不幸的是，并不是每一个工作人员效率都很高。尽管如此，为了体现“公开政府”的政策，政府部门把每一个工作人员的处理一个申请所花天数都对外界公开。\n\n为了防止所有申请人都到效率高的工作人员去申请。这 $M \\times N$ 个工作人员被分成 $M$ 个小组。每一组在每一步都有一个工作人员。申请人可以选择任意一个小组也可以更换小组。但是更换小组是很严格的，一定要相邻两个步骤之间来更换，而不能在某一步骤已经开始但还没结束的时候提出更换，并且也只能从原来的小组 $I$ 更换到小组 $I+1$，当然从小组 $M$ 可以更换到小组 $1$。对更换小组的次数没有限制。\n\n例如：下面是 $3$ 个小组，每个小组 $4$ 个步骤工作天数：\n\n- 小组 $1$： $2, 6 ,1 ,8$；\n- 小组 $2$：$3,6, 2, 6$；\n- 小组 $3$：$ 4, 2 ,3 ,6$。\n\n例子中，可以选择小组 $1$ 来完成整个过程一共花了$2+6+1+8=17$ 天，也可以从小组 $2$ 开始第一步，然后第二步更换到小组 $3$，第三步到小组 $1$，第四步再到小组 $2$，这样一共花了 $3+2+1+6=12$ 天。你可以发现没有比这样效率更高的选择。\n\n你的任务是求出完成申请所花最少天数。", "inputFormat": "第一行是两个正整数 $N$ 和 $M$，表示步数和小组数。\n\n接下来有 $M$ 行，每行有 $N$ 个非负整数，第 $i+1(1 \\le i  \\le M)$ 行的第 $j$ 个数表示小组 $i$ 完成第 $j$ 步所花的天数，天数都不超过 $1000000$。", "outputFormat": "一个正整数，为完成所有步所需最少天数。", "hint": "对于 $100\\%$ 的数据，$1\\le N,M \\le 2000$。", "locale": "zh-CN", "translations": {"en": {"title": "Red Card", "background": null, "description": "To obtain long-term residency, temporary residents must apply for a red card. The process consists of $N$ steps. Each step is handled by a government staff member who checks whether your submitted materials meet the requirements. To accelerate the process, at each step the government assigns $M$ staff members to check materials. Unfortunately, not every staff member is efficient. Nevertheless, to embody the policy of “open government,” the department publicly releases the number of days each staff member takes to handle one application.\n\nTo prevent all applicants from flocking to the most efficient staff, these $M \\times N$ staff members are divided into $M$ groups. Each group has exactly one staff member at each step. An applicant may choose any one group and may also switch groups. However, switching is strictly limited: it must occur between two adjacent steps, not during a step that has already started but not yet finished; moreover, you can only switch from your current group $I$ to group $I+1$, and from group $M$ you may switch to group $1$. There is no limit on the number of switches.\n\nFor example, here are $3$ groups, with working days for $4$ steps per group:\n- Group $1$: $2, 6 ,1 ,8$;\n- Group $2$: $3,6, 2, 6$;\n- Group $3$: $ 4, 2 ,3 ,6$.\n\nIn this example, you can choose group $1$ for the entire process, which takes $2+6+1+8=17$ days. Alternatively, you may start with group $2$ for step one, then switch to group $3$ for step two, to group $1$ for step three, and to group $2$ for step four, for a total of $3+2+1+6=12$ days. You can see that no choice is more efficient than this.\n\nYour task is to find the minimum number of days needed to complete the application.", "inputFormat": "The first line contains two positive integers $N$ and $M$, the number of steps and the number of groups.\n\nThen there are $M$ lines, each containing $N$ non-negative integers. On the $i$-th of these lines $(1 \\le i \\le M)$, the $j$-th number denotes the number of days group $i$ needs to complete step $j$. All day counts do not exceed $1000000$.", "outputFormat": "Output a single positive integer, the minimum number of days required to complete all steps.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\le N,M \\le 2000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "红牌", "background": "", "description": "\n某地临时居民想获得长期居住权就必须申请拿到红牌。获得红牌的过程是相当复杂 ，一共包括 $N$ 个步骤。每一步骤都由政府的某个工作人员负责检查你所提交的材料是否符合条件。为了加快进程，每一步政府都派了 $M$ 个工作人员来检查材料。不幸的是，并不是每一个工作人员效率都很高。尽管如此，为了体现“公开政府”的政策，政府部门把每一个工作人员的处理一个申请所花天数都对外界公开。\n\n为了防止所有申请人都到效率高的工作人员去申请。这 $M \\times N$ 个工作人员被分成 $M$ 个小组。每一组在每一步都有一个工作人员。申请人可以选择任意一个小组也可以更换小组。但是更换小组是很严格的，一定要相邻两个步骤之间来更换，而不能在某一步骤已经开始但还没结束的时候提出更换，并且也只能从原来的小组 $I$ 更换到小组 $I+1$，当然从小组 $M$ 可以更换到小组 $1$。对更换小组的次数没有限制。\n\n例如：下面是 $3$ 个小组，每个小组 $4$ 个步骤工作天数：\n\n- 小组 $1$： $2, 6 ,1 ,8$；\n- 小组 $2$：$3,6, 2, 6$；\n- 小组 $3$：$ 4, 2 ,3 ,6$。\n\n例子中，可以选择小组 $1$ 来完成整个过程一共花了$2+6+1+8=17$ 天，也可以从小组 $2$ 开始第一步，然后第二步更换到小组 $3$，第三步到小组 $1$，第四步再到小组 $2$，这样一共花了 $3+2+1+6=12$ 天。你可以发现没有比这样效率更高的选择。\n\n你的任务是求出完成申请所花最少天数。", "inputFormat": "第一行是两个正整数 $N$ 和 $M$，表示步数和小组数。\n\n接下来有 $M$ 行，每行有 $N$ 个非负整数，第 $i+1(1 \\le i  \\le M)$ 行的第 $j$ 个数表示小组 $i$ 完成第 $j$ 步所花的天数，天数都不超过 $1000000$。", "outputFormat": "一个正整数，为完成所有步所需最少天数。", "hint": "对于 $100\\%$ 的数据，$1\\le N,M \\le 2000$。", "locale": "zh-CN"}}}
{"pid": "P1131", "type": "P", "difficulty": 4, "samples": [["3\n1\n1 2 1\n1 3 3\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "树形数据结构", "2007", "各省省选", "浙江", "树形 DP", "构造"], "title": "[ZJOI2007] 时态同步", "background": "", "description": "小 Q 在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字 $1,2,3\\cdots$ 进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。\n\n在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激励电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。\n\n激励电流在导线上的传播是需要花费时间的，对于每条边 $e$，激励电流通过它需要的时间为 $t_e$，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小 Q 有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小 Q 最少使用多少次道具才可使得所有的“终止节点”时态同步？", "inputFormat": "第一行包含一个正整数 $N$，表示电路板中节点的个数。\n\n第二行包含一个整数 $S$，为该电路板的激发器的编号。\n\n接下来 $N-1$ 行，每行三个整数 $a,b,t$。表示该条导线连接节点 $a$ 与节点 $b$，且激励电流通过这条导线需要 $t$ 个单位时间。", "outputFormat": "仅包含一个整数 $V$，为小 Q 最少使用的道具次数。", "hint": "- 对于 $40\\%$ 的数据，$1\\le N\\le 1000$。\n- 对于 $100\\%$ 的数据，$1\\le N\\le 5\\times 10^5$。\n\n对于所有的数据，$1\\le t_e\\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2007] Temporal Synchronization", "background": null, "description": "Xiao Q is learning to solder circuit boards in an electronics workshop. A circuit board consists of several components, which we will call nodes, labeled by numbers $1, 2, 3, \\cdots$. The nodes on the circuit board are connected by several non-overlapping wires, and for any two nodes on the board, there exists exactly one path (a path is a sequence of wires connecting two components).\n\nThere is a special component on the board called the “exciter.” When the exciter operates, it generates an excitation current that is sent through wires to each node it is connected to. When an intermediate node receives the excitation current, it gets the information and immediately forwards the current to its connected nodes that have not yet received it. Eventually, the excitation current reaches some “terminal nodes”—nodes that, after receiving the current, no longer forward it.\n\nIt takes time for the excitation current to travel along a wire. For each edge $e$, the time required for the current to pass through it is $t_e$, while forwarding at nodes is considered instantaneous. The board requires that every terminal node receive the excitation current at the same time—that is, to maintain temporal synchronization. Since the current construction does not meet the synchronization requirement, we need to modify the wiring. Xiao Q has a tool that, when used once, can increase the transmission time of some wire by $1$. What is the minimum number of times the tool must be used to make all terminal nodes temporally synchronized?", "inputFormat": "- The first line contains an integer $N$, the number of nodes on the circuit board.\n- The second line contains an integer $S$, the index of the exciter.\n- The next $N - 1$ lines each contain three integers $a, b, t$, indicating that there is a wire connecting nodes $a$ and $b$, and the excitation current takes $t$ units of time to pass through this wire.", "outputFormat": "Output a single integer $V$, the minimum number of times the tool must be used.", "hint": "Constraints:\n- For $40\\%$ of the testdata, $1 \\le N \\le 1000$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 5 \\times 10^5$.\n- For all testdata, $1 \\le t_e \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2007] 时态同步", "background": "", "description": "小 Q 在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字 $1,2,3\\cdots$ 进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。\n\n在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激励电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。\n\n激励电流在导线上的传播是需要花费时间的，对于每条边 $e$，激励电流通过它需要的时间为 $t_e$，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小 Q 有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小 Q 最少使用多少次道具才可使得所有的“终止节点”时态同步？", "inputFormat": "第一行包含一个正整数 $N$，表示电路板中节点的个数。\n\n第二行包含一个整数 $S$，为该电路板的激发器的编号。\n\n接下来 $N-1$ 行，每行三个整数 $a,b,t$。表示该条导线连接节点 $a$ 与节点 $b$，且激励电流通过这条导线需要 $t$ 个单位时间。", "outputFormat": "仅包含一个整数 $V$，为小 Q 最少使用的道具次数。", "hint": "- 对于 $40\\%$ 的数据，$1\\le N\\le 1000$。\n- 对于 $100\\%$ 的数据，$1\\le N\\le 5\\times 10^5$。\n\n对于所有的数据，$1\\le t_e\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P1132", "type": "P", "difficulty": 4, "samples": [["143\n3\n134\n133\n32\n", "1\n-1\n4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索"], "title": "数字生成游戏", "background": null, "description": "小明完成了这样一个数字生成游戏，对于一个不包含 $0$ 的数字 $s$ 来说，有以下 $3$ 种生成新的数的规则：\n\n1.    将 $s$ 的任意两位对换生成新的数字，例如 $143$ 可以生成 $341,413,134$；\n\n2.    将 $s$ 的任意一位删除生成新的数字，例如 $143$ 可以生成 $14,13,43$；\n\n3.    在 $s$ 的相邻两位之间 $s_i,s_{i + 1}$ 之间插入一个数字 $x$，$x$ 需要满足 $s_i<x<s_{i + 1}$。例如 $143$ 可以生成 $1243,1343$，但是不能生成 $1143,1543$ 等。\n\n现在小明想知道，在这个生成法则下，从 $s$ 开始，每次生成一个数，可以用然后用新生成的数生成另外一个数，不断生成直到生成 $t$ 至少需要多少次生成操作。\n\n另外，小明给规则 $3$ 又加了一个限制，即生成数的位数不能超过初始数 $s$ 的位数。若 $s$ 是 $143$，那么 $1243$ 与 $1343$ 都是无法生成的；若 $s$ 为 $1443$，那么可以将 $s$ 删除变为 $143$，再生成 $1243$ 或 $1343$。", "inputFormat": "第一行包含 $1$ 个正整数，为初始数字 $s$。\n\n第二行包含一个正整数 $m$，为询问个数。  \n\n接下来 $m$ 行，每行一个整数 $t$（$t$ 不包含 $0$），表示询问从 $s$ 开始不断生成数字到 $t$ 最少要进行多少次操作。任两个询问独立，即上一个询问生成过的数到下一个询问都不存在，只剩下初始数字 $s$。", "outputFormat": "共 $m$ 行，每行一个正整数，对每个询问输出最少操作数，如果无论如果无论也变换不成，则输出 $-1$。", "hint": "**样例解释**\n\n$143\\to 134$\n\n$133$ 无法得到\n\n$143\\to13\\to123\\to23\\to32$\n\n**数据范围**\n\n对于 $20\\%$ 的数据，$s < 100$；  \n对于 $40\\%$ 的数据，$s < 1000$；  \n对于 $40\\%$ 的数据，$m < 10$；  \n对于 $60\\%$ 的数据，$s < 10000$；  \n对于 $100\\%$ 的数据，$s < 100000,m \\leq 50000$。", "locale": "zh-CN", "translations": {"en": {"title": "Number Generation Game", "background": null, "description": "Xiaoming has completed a number generation game. For a number $s$ that does not contain the digit $0$, there are the following $3$ rules to generate new numbers:\n\n1. Swap any two digits of $s$ to form a new number. For example, $143$ can generate $341, 413, 134$.\n\n2. Delete any single digit of $s$ to form a new number. For example, $143$ can generate $14, 13, 43$.\n\n3. Insert a digit $x$ between two adjacent digits $s_i, s_{i + 1}$ of $s$, where $x$ must satisfy $s_i < x < s_{i + 1}$. For example, $143$ can generate $1243, 1343$, but cannot generate $1143, 1543$, etc.\n\nNow Xiaoming wants to know, under these rules, starting from $s$, each step generating a new number (and then using the newly generated number to generate the next one), what is the minimum number of operations required to obtain $t$.\n\nAdditionally, Xiaoming imposes a further restriction on rule $3$: the number of digits of any generated number cannot exceed the number of digits of the initial number $s$. If $s$ is $143$, then $1243$ and $1343$ are impossible to generate. If $s$ is $1443$, then you can first delete a digit to obtain $143$, and then generate $1243$ or $1343$.", "inputFormat": "The first line contains $1$ positive integer, the initial number $s$.\n\nThe second line contains a positive integer $m$, the number of queries.\n\nThe next $m$ lines each contain an integer $t$ ($t$ does not contain the digit $0$), asking for the minimum number of operations needed to generate $t$ starting from $s$. Any two queries are independent; numbers generated in one query do not carry over to the next, and only the initial number $s$ remains.", "outputFormat": "Output $m$ lines. For each query, output one positive integer: the minimum number of operations. If it is impossible to transform under the rules, output $-1$.", "hint": "Sample explanation:\n\n$143 \\to 134$\n\n$133$ cannot be obtained.\n\n$143 \\to 13 \\to 123 \\to 23 \\to 32$\n\n# Constraints\n\nFor $20\\%$ of the testdata, $s < 100$.\nFor $40\\%$ of the testdata, $s < 1000$.\nFor $40\\%$ of the testdata, $m < 10$.\nFor $60\\%$ of the testdata, $s < 10000$.\nFor $100\\%$ of the testdata, $s < 100000, m \\leq 50000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数字生成游戏", "background": null, "description": "小明完成了这样一个数字生成游戏，对于一个不包含 $0$ 的数字 $s$ 来说，有以下 $3$ 种生成新的数的规则：\n\n1.    将 $s$ 的任意两位对换生成新的数字，例如 $143$ 可以生成 $341,413,134$；\n\n2.    将 $s$ 的任意一位删除生成新的数字，例如 $143$ 可以生成 $14,13,43$；\n\n3.    在 $s$ 的相邻两位之间 $s_i,s_{i + 1}$ 之间插入一个数字 $x$，$x$ 需要满足 $s_i<x<s_{i + 1}$。例如 $143$ 可以生成 $1243,1343$，但是不能生成 $1143,1543$ 等。\n\n现在小明想知道，在这个生成法则下，从 $s$ 开始，每次生成一个数，可以用然后用新生成的数生成另外一个数，不断生成直到生成 $t$ 至少需要多少次生成操作。\n\n另外，小明给规则 $3$ 又加了一个限制，即生成数的位数不能超过初始数 $s$ 的位数。若 $s$ 是 $143$，那么 $1243$ 与 $1343$ 都是无法生成的；若 $s$ 为 $1443$，那么可以将 $s$ 删除变为 $143$，再生成 $1243$ 或 $1343$。", "inputFormat": "第一行包含 $1$ 个正整数，为初始数字 $s$。\n\n第二行包含一个正整数 $m$，为询问个数。  \n\n接下来 $m$ 行，每行一个整数 $t$（$t$ 不包含 $0$），表示询问从 $s$ 开始不断生成数字到 $t$ 最少要进行多少次操作。任两个询问独立，即上一个询问生成过的数到下一个询问都不存在，只剩下初始数字 $s$。", "outputFormat": "共 $m$ 行，每行一个正整数，对每个询问输出最少操作数，如果无论如果无论也变换不成，则输出 $-1$。", "hint": "**样例解释**\n\n$143\\to 134$\n\n$133$ 无法得到\n\n$143\\to13\\to123\\to23\\to32$\n\n**数据范围**\n\n对于 $20\\%$ 的数据，$s < 100$；  \n对于 $40\\%$ 的数据，$s < 1000$；  \n对于 $40\\%$ 的数据，$m < 10$；  \n对于 $60\\%$ 的数据，$s < 10000$；  \n对于 $100\\%$ 的数据，$s < 100000,m \\leq 50000$。", "locale": "zh-CN"}}}
{"pid": "P1133", "type": "P", "difficulty": 4, "samples": [["4 \n1 3 2 \n3 1 2 \n3 1 2 \n3 1 2\n", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "教主的花园", "background": null, "description": "教主有着一个环形的花园，他想在花园周围均匀地种上 $n$ 棵树，但是教主花园的土壤很特别，每个位置适合种的树都不一样，一些树可能会因为不适合这个位置的土壤而损失观赏价值。\n\n教主最喜欢 $3$ 种树，这 $3$ 种树的高度分别为 $10,20,30$。教主希望这一圈树种得有层次感，所以任何一个位置的树要比它相邻的两棵树的高度都高或者都低，并且在此条件下，教主想要你设计出一套方案，使得观赏价值之和最高。", "inputFormat": "第一行为一个正整数 $n$，表示需要种的树的棵数。\n\n接下来 $n$ 行，每行 $3$ 个不超过 $10000$ 的正整数 $a_i,b_i,c_i$，按顺时针顺序表示了第 $i$ 个位置种高度为 $10,20,30$ 的树能获得的观赏价值。\n\n第 $i$ 个位置的树与第 $i+1$ 个位置的树相邻，特别地，第 $1$ 个位置的树与第 $n$ 个位置的树相邻。", "outputFormat": "一个正整数，为最大的观赏价值和。", "hint": "【样例说明】。\n\n第 $1$ 至 $n$ 个位置分别种上高度为 $20,10,30,10$ 的树，价值最高。\n\n【数据规模与约定】。\n\n- 对于 $20\\%$ 的数据，有 $n\\le 10$；\n- 对于 $40\\%$ 的数据，有 $n\\le 100$； \n- 对于 $60\\%$ 的数据，有 $n\\le 1000$；\n- 对于 $100\\%$ 的数据，有 $4\\le n\\le 10^5$，并保证 $n$ 一定为偶数。", "locale": "zh-CN", "translations": {"en": {"title": "The Leader's Garden", "background": "", "description": "The leader has a circular garden and wants to plant $n$ trees evenly around it. However, the soil is special; each position suits different kinds of trees, and some trees may lose aesthetic value if placed in unsuitable soil.\n\nThe leader's three favorite kinds of trees have heights $10,20,30$. He wants the ring of trees to have a sense of layering: at every position, the tree must be strictly higher than both of its adjacent trees or strictly lower than both. Under this condition, design a plan that maximizes the sum of aesthetic values.", "inputFormat": "The first line contains a positive integer $n$, the number of trees to plant.\n\nThe next $n$ lines each contain three positive integers $a_i,b_i,c_i$ not exceeding $10000$, giving, in clockwise order, the aesthetic value obtained by planting at position $i$ a tree of height $10,20,30$, respectively.\n\nThe tree at position $i$ is adjacent to the tree at position $i+1$; in particular, the tree at position $1$ is adjacent to the tree at position $n$.", "outputFormat": "Output a single positive integer, the maximum total aesthetic value.", "hint": "[Sample Explanation].\n\nPlant trees of heights $20,10,30,10$ at positions $1$ through $n$, respectively, to achieve the highest value.\n\n[Constraints].\n\n- For $20\\%$ of the testdata, $n \\le 10$.\n- For $40\\%$ of the testdata, $n \\le 100$.\n- For $60\\%$ of the testdata, $n \\le 1000$.\n- For $100\\%$ of the testdata, $4 \\le n \\le 10^5$, and $n$ is guaranteed to be even.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "教主的花园", "background": null, "description": "教主有着一个环形的花园，他想在花园周围均匀地种上 $n$ 棵树，但是教主花园的土壤很特别，每个位置适合种的树都不一样，一些树可能会因为不适合这个位置的土壤而损失观赏价值。\n\n教主最喜欢 $3$ 种树，这 $3$ 种树的高度分别为 $10,20,30$。教主希望这一圈树种得有层次感，所以任何一个位置的树要比它相邻的两棵树的高度都高或者都低，并且在此条件下，教主想要你设计出一套方案，使得观赏价值之和最高。", "inputFormat": "第一行为一个正整数 $n$，表示需要种的树的棵数。\n\n接下来 $n$ 行，每行 $3$ 个不超过 $10000$ 的正整数 $a_i,b_i,c_i$，按顺时针顺序表示了第 $i$ 个位置种高度为 $10,20,30$ 的树能获得的观赏价值。\n\n第 $i$ 个位置的树与第 $i+1$ 个位置的树相邻，特别地，第 $1$ 个位置的树与第 $n$ 个位置的树相邻。", "outputFormat": "一个正整数，为最大的观赏价值和。", "hint": "【样例说明】。\n\n第 $1$ 至 $n$ 个位置分别种上高度为 $20,10,30,10$ 的树，价值最高。\n\n【数据规模与约定】。\n\n- 对于 $20\\%$ 的数据，有 $n\\le 10$；\n- 对于 $40\\%$ 的数据，有 $n\\le 100$； \n- 对于 $60\\%$ 的数据，有 $n\\le 1000$；\n- 对于 $100\\%$ 的数据，有 $4\\le n\\le 10^5$，并保证 $n$ 一定为偶数。", "locale": "zh-CN"}}}
{"pid": "P1134", "type": "P", "difficulty": 3, "samples": [["12", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["数学", "USACO"], "title": "[USACO3.2] 阶乘问题", "background": "", "description": "也许你早就知道阶乘的含义，$N$ 阶乘是由 $1$ 到 $N$ 相乘而产生，如：\n\n$$12!=1\\times 2\\times 3\\times 4\\times 5\\times 6\\times 7\\times 8\\times 9\\times 10\\times 11\\times  12=479{,}001{,}600$$\n\n$12$ 的阶乘最右边的非零位为 $6$。\n\n写一个程序，计算 $N\\ (1\\le N\\le5\\times 10^7)$ 阶乘的最右边的非零位的值。\n\n**注意**：$10{,}000{,}000!$ 的末尾有 $2499999$ 个零。", "inputFormat": "仅一行包含一个正整数 $N$。\n", "outputFormat": "一个整数，表示最右边的非零位的值。\n", "hint": "USACO Training Section 3.2\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO3.2] Factorial Problem", "background": "", "description": "Perhaps you already know what a factorial is; the factorial of $N$ is the product from $1$ to $N$, for example:\n\n$$12!=1\\times 2\\times 3\\times 4\\times 5\\times 6\\times 7\\times 8\\times 9\\times 10\\times 11\\times  12=479{,}001{,}600$$\n\nThe rightmost non-zero digit of the factorial of $12$ is $6$.\n\nWrite a program to compute the value of the rightmost non-zero digit of the factorial of $N\\ (1\\le N\\le5\\times 10^7)$.\n\n**Note**: There are $2499999$ trailing zeros in $10{,}000{,}000!$.", "inputFormat": "A single line containing a positive integer $N$.", "outputFormat": "A single integer, the value of the rightmost non-zero digit.", "hint": "USACO Training Section 3.2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO3.2] 阶乘问题", "background": "", "description": "也许你早就知道阶乘的含义，$N$ 阶乘是由 $1$ 到 $N$ 相乘而产生，如：\n\n$$12!=1\\times 2\\times 3\\times 4\\times 5\\times 6\\times 7\\times 8\\times 9\\times 10\\times 11\\times  12=479{,}001{,}600$$\n\n$12$ 的阶乘最右边的非零位为 $6$。\n\n写一个程序，计算 $N\\ (1\\le N\\le5\\times 10^7)$ 阶乘的最右边的非零位的值。\n\n**注意**：$10{,}000{,}000!$ 的末尾有 $2499999$ 个零。", "inputFormat": "仅一行包含一个正整数 $N$。\n", "outputFormat": "一个整数，表示最右边的非零位的值。\n", "hint": "USACO Training Section 3.2\n", "locale": "zh-CN"}}}
{"pid": "P1135", "type": "P", "difficulty": 3, "samples": [["5 1 5\n3 3 1 2 5\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "广度优先搜索 BFS", "深度优先搜索 DFS", "最短路"], "title": "奇怪的电梯", "background": "感谢 @[yummy](https://www.luogu.com.cn/user/101694) 提供的一些数据。", "description": "呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \\le i \\le N$）上有一个数字 $K_i$（$0 \\le K_i \\le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如：$3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？", "inputFormat": "共二行。  \n\n第一行为三个用空格隔开的正整数，表示 $N, A, B$（$1 \\le N \\le 200$，$1 \\le A, B \\le N$）。\n\n第二行为 $N$ 个用空格隔开的非负整数，表示 $K_i$。", "outputFormat": "一行，即最少按键次数，若无法到达，则输出 `-1`。", "hint": "对于 $100 \\%$ 的数据，$1 \\le N \\le 200$，$1 \\le A, B \\le N$，$0 \\le K_i \\le N$。\n\n本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。", "locale": "zh-CN", "translations": {"en": {"title": "Strange Elevator", "background": "Thanks to @[yummy](https://www.luogu.com.cn/user/101694) for providing some testdata.", "description": "Hehe, one day I had a dream about a very strange elevator. The elevator can stop at every floor of the building, and on floor $i$ ( $1 \\le i \\le N$ ) there is a number $K_i$ ( $0 \\le K_i \\le N$ ). The elevator has only four buttons: Open, Close, Up, and Down. The number of floors moved up or down equals the number on the current floor. Of course, if the move would be invalid, the corresponding button will not work. For example: $3, 3, 1, 2, 5$ represents $K_i$ ( $K_1 = 3$, $K_2 = 3$, ... ), starting from floor $1$. On floor $1$, pressing \"Up\" takes you to floor $4$, and pressing \"Down\" does nothing because there is no floor $-2$. Then, what is the minimum number of button presses to get from floor $A$ to floor $B$?", "inputFormat": "Two lines in total.\n\nThe first line contains three positive integers separated by spaces, denoting $N, A, B$ ( $1 \\le N \\le 200$, $1 \\le A, B \\le N$ ).\n\nThe second line contains $N$ non-negative integers separated by spaces, denoting $K_i$.", "outputFormat": "One line: the minimum number of button presses. If it is impossible to reach, output `-1`.", "hint": "For 100% of the testdata, $1 \\le N \\le 200$, $1 \\le A, B \\le N$, $0 \\le K_i \\le N$.\n\nThere are $16$ test points in total. The first $15$ test points are worth $6$ points each, and the last test point is worth $10$ points.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "奇怪的电梯", "background": "感谢 @[yummy](https://www.luogu.com.cn/user/101694) 提供的一些数据。", "description": "呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \\le i \\le N$）上有一个数字 $K_i$（$0 \\le K_i \\le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如：$3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？", "inputFormat": "共二行。  \n\n第一行为三个用空格隔开的正整数，表示 $N, A, B$（$1 \\le N \\le 200$，$1 \\le A, B \\le N$）。\n\n第二行为 $N$ 个用空格隔开的非负整数，表示 $K_i$。", "outputFormat": "一行，即最少按键次数，若无法到达，则输出 `-1`。", "hint": "对于 $100 \\%$ 的数据，$1 \\le N \\le 200$，$1 \\le A, B \\le N$，$0 \\le K_i \\le N$。\n\n本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。", "locale": "zh-CN"}}}
{"pid": "P1136", "type": "P", "difficulty": 5, "samples": [["5 2 \nzzzjj\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP"], "title": "迎接仪式", "background": "", "description": "LHX 教主要来 X 市指导 OI 学习工作了。为了迎接教主，在一条道路旁，一群“Orz 教主 er”穿着文化衫站在道路两旁迎接教主，每件文化衫上都印着大字。一旁的 Orzer 依次摆出“欢迎欢迎欢迎欢迎……”的大字，但是领队突然发现，另一旁穿着“教”和“主”字文化衫的 Orzer 却不太和谐。\n\n为了简单描述这个不和谐的队列，我们用 `j` 替代“教”，`z` 替代“主”。而一个 `j` 与 `z` 组成的序列则可以描述当前的队列。为了让教主看得尽量舒服，你必须调整队列，使得 `jz` 子串尽量多。每次调整你可以交换任意位置上的两个人，也就是序列中任意位置上的两个字母。而因为教主马上就来了，时间仅够最多做 $K$ 次调整（当然可以调整不满 $K$ 次），所以这个问题交给了你。", "inputFormat": "第一行，两个正整数 $N, K$，分别表示序列长度与最多交换次数。\n\n第二行，一个长度为 $N$ 的字符串，字符串仅由字母 `j` 与字母 `z` 组成，描述了这个序列。", "outputFormat": "一个非负整数，为调整最多 $K$ 次后最后最多能出现多少个 `jz` 子串。", "hint": "**【样例说明】**\n\n第 $1$ 次交换位置 $1$ 上的 `z` 和位置 $4$ 上的 `j`，变为 `jzzzj`；\n\n第 $2$ 次交换位置 $4$ 上的 `z` 和位置 $5$ 上的 `j`，变为 `jzzjz`。\n\n最后的串有 $2$ 个 `jz` 子串。\n\n**【数据规模与约定】**\n\n对于 $10 \\%$ 的数据，有 $N \\le 10$；  \n对于 $30 \\%$ 的数据，有 $K \\le 10$；  \n对于 $40 \\%$ 的数据，有 $N \\le 50$；  \n对于 $100 \\%$ 的数据，有 $1 \\le N \\le 500$，$1 \\le K \\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "Welcoming Ceremony", "background": "", "description": "Leader LHX is coming to City X to guide OI studies. To welcome the Leader (jiaozhu), along a road, a group of Orzer wearing T-shirts stand on both sides of the road, with big characters printed on each shirt. On one side, the Orzer spell out “欢迎欢迎欢迎欢迎……” in order, but the leader of the group suddenly notices that the Orzer on the other side, who wear the characters “教” and “主,” look less harmonious.\n\nTo describe this disharmony simply, we use `j` to replace “教” and `z` to replace “主.” A sequence composed of `j` and `z` then describes the current lineup. To make it as pleasing as possible for the Leader, you must adjust the lineup to maximize the number of `jz` substrings. In each adjustment, you can swap any two people at any positions, that is, swap the two letters at any positions in the sequence. Since the Leader is arriving soon, there is time for at most $K$ adjustments (you may also perform fewer than $K$), so this problem is assigned to you.", "inputFormat": "The first line contains two positive integers $N, K$, denoting the length of the sequence and the maximum number of swaps.\n\nThe second line contains a string of length $N$, consisting only of the letters `j` and `z`, describing the sequence.", "outputFormat": "Output a non-negative integer: after at most $K$ swaps, the maximum possible number of `jz` substrings.", "hint": "【Sample Explanation】\n\nFirst, swap the `z` at position 1 with the `j` at position 4 to get `jzzzj`.\nSecond, swap the `z` at position 4 with the `j` at position 5 to get `jzzjz`.\n\nThe final string has $2$ `jz` substrings.\n\n【Constraints】\n\nFor $10 \\%$ of the testdata, $N \\le 10$.  \nFor $30 \\%$ of the testdata, $K \\le 10$.  \nFor $40 \\%$ of the testdata, $N \\le 50$.  \nFor $100 \\%$ of the testdata, $1 \\le N \\le 500$, $1 \\le K \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "迎接仪式", "background": "", "description": "LHX 教主要来 X 市指导 OI 学习工作了。为了迎接教主，在一条道路旁，一群“Orz 教主 er”穿着文化衫站在道路两旁迎接教主，每件文化衫上都印着大字。一旁的 Orzer 依次摆出“欢迎欢迎欢迎欢迎……”的大字，但是领队突然发现，另一旁穿着“教”和“主”字文化衫的 Orzer 却不太和谐。\n\n为了简单描述这个不和谐的队列，我们用 `j` 替代“教”，`z` 替代“主”。而一个 `j` 与 `z` 组成的序列则可以描述当前的队列。为了让教主看得尽量舒服，你必须调整队列，使得 `jz` 子串尽量多。每次调整你可以交换任意位置上的两个人，也就是序列中任意位置上的两个字母。而因为教主马上就来了，时间仅够最多做 $K$ 次调整（当然可以调整不满 $K$ 次），所以这个问题交给了你。", "inputFormat": "第一行，两个正整数 $N, K$，分别表示序列长度与最多交换次数。\n\n第二行，一个长度为 $N$ 的字符串，字符串仅由字母 `j` 与字母 `z` 组成，描述了这个序列。", "outputFormat": "一个非负整数，为调整最多 $K$ 次后最后最多能出现多少个 `jz` 子串。", "hint": "**【样例说明】**\n\n第 $1$ 次交换位置 $1$ 上的 `z` 和位置 $4$ 上的 `j`，变为 `jzzzj`；\n\n第 $2$ 次交换位置 $4$ 上的 `z` 和位置 $5$ 上的 `j`，变为 `jzzjz`。\n\n最后的串有 $2$ 个 `jz` 子串。\n\n**【数据规模与约定】**\n\n对于 $10 \\%$ 的数据，有 $N \\le 10$；  \n对于 $30 \\%$ 的数据，有 $K \\le 10$；  \n对于 $40 \\%$ 的数据，有 $N \\le 50$；  \n对于 $100 \\%$ 的数据，有 $1 \\le N \\le 500$，$1 \\le K \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P1137", "type": "P", "difficulty": 3, "samples": [["5 6\n1 2\n1 3\n2 3\n2 4\n3 4\n2 5\n", "1\n2\n3\n4\n3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "图论", "递推", "排序", "拓扑排序"], "title": "旅行计划", "background": "", "description": "小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。\n\n所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。\n\n现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。", "inputFormat": "第一行为两个正整数 $N, M$。\n\n接下来 $M$ 行，每行两个正整数 $x, y$，表示了有一条连接城市 $x$ 与城市 $y$ 的道路，保证了城市 $x$ 在城市 $y$ 西面。\n", "outputFormat": "$N$ 行，第 $i$ 行包含一个正整数，表示以第 $i$ 个城市为终点最多能游览多少个城市。\n", "hint": "均选择从城市 $1$ 出发可以得到以上答案。\n\n- 对于 $20\\%$ 的数据，$1\\le N ≤ 100$；\n- 对于 $60\\%$ 的数据，$1\\le N ≤ 1000$；\n- 对于 $100\\%$ 的数据，$1\\le N ≤ 100000$，$1\\le M ≤ 200000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Travel Plan", "background": "", "description": "Xiao Ming is going to travel to a country. This country has $N$ cities, numbered $1$ to $N$, and there are $M$ roads connecting them. Xiao Ming plans to start from some city and only move east until he stops at city $i$.\n\nTherefore, for each city $i$, he needs to choose a starting city and plan a route ending at city $i$, such that along the route, except for the first city, every city lies to the east of the previous city. Under this condition, he also wants to visit as many cities as possible.\n\nYou only know the relative east–west positions of the two cities connected by each road, but you do not know the exact positions of all cities. Now, for every $i$, you need to plan a route for Xiao Ming and compute the maximum number of cities that can be visited on a route ending at city $i$.", "inputFormat": "The first line contains two positive integers $N, M$.\n\nThe next $M$ lines each contain two positive integers $x, y$, indicating there is a road connecting city $x$ and city $y$, and it is guaranteed that city $x$ is to the west of city $y$.", "outputFormat": "Output $N$ lines. The $i$-th line contains a positive integer, the maximum number of cities that can be visited on a route ending at city $i$.", "hint": "Choosing to always start from city $1$ yields the answers.\n\nConstraints:\n- For $20\\%$ of the testdata, $1 \\le N \\le 100$.\n- For $60\\%$ of the testdata, $1 \\le N \\le 1000$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 100000$, $1 \\le M \\le 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "旅行计划", "background": "", "description": "小明要去一个国家旅游。这个国家有 $N$ 个城市，编号为 $1$ 至 $N$，并且有 $M$ 条道路连接着，小明准备从其中一个城市出发，并只往东走到城市 $i$ 停止。\n\n所以他就需要选择最先到达的城市，并制定一条路线以城市 $i$ 为终点，使得线路上除了第一个城市，每个城市都在路线前一个城市东面，并且满足这个前提下还希望游览的城市尽量多。\n\n现在，你只知道每一条道路所连接的两个城市的相对位置关系，但并不知道所有城市具体的位置。现在对于所有的 $i$，都需要你为小明制定一条路线，并求出以城市 $i$ 为终点最多能够游览多少个城市。", "inputFormat": "第一行为两个正整数 $N, M$。\n\n接下来 $M$ 行，每行两个正整数 $x, y$，表示了有一条连接城市 $x$ 与城市 $y$ 的道路，保证了城市 $x$ 在城市 $y$ 西面。\n", "outputFormat": "$N$ 行，第 $i$ 行包含一个正整数，表示以第 $i$ 个城市为终点最多能游览多少个城市。\n", "hint": "均选择从城市 $1$ 出发可以得到以上答案。\n\n- 对于 $20\\%$ 的数据，$1\\le N ≤ 100$；\n- 对于 $60\\%$ 的数据，$1\\le N ≤ 1000$；\n- 对于 $100\\%$ 的数据，$1\\le N ≤ 100000$，$1\\le M ≤ 200000$。\n", "locale": "zh-CN"}}}
{"pid": "P1138", "type": "P", "difficulty": 2, "samples": [["10 3\n1 3 3 7 2 5 1 2 4 6\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "排序"], "title": "第 k 小整数", "background": null, "description": "现有 $n$ 个正整数，要求出这 $n$ 个正整数中的第 $k$ 个最小整数（相同大小的整数只计算一次）。", "inputFormat": "第一行为 $n$ 和 $k$; 第二行开始为 $n$ 个正整数的值，整数间用空格隔开。", "outputFormat": "第$k$个最小整数的值；若无解，则输出 `NO RESULT`。", "hint": "$n \\leq 10000$，$k \\leq 4000$，正整数均小于 $30000$。", "locale": "zh-CN", "translations": {"en": {"title": "The k-th Smallest Integer", "background": "", "description": "You are given $n$ positive integers. Find the $k$-th smallest integer among the distinct values (count equal integers only once).", "inputFormat": "The first line contains $n$ and $k$; starting from the second line are the $n$ positive integers, separated by spaces.", "outputFormat": "Output the value of the $k$-th smallest integer; if there is no solution, output `NO RESULT`.", "hint": "Constraints: $n \\leq 10000$, $k \\leq 4000$, and all positive integers are less than $30000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "第 k 小整数", "background": null, "description": "现有 $n$ 个正整数，要求出这 $n$ 个正整数中的第 $k$ 个最小整数（相同大小的整数只计算一次）。", "inputFormat": "第一行为 $n$ 和 $k$; 第二行开始为 $n$ 个正整数的值，整数间用空格隔开。", "outputFormat": "第$k$个最小整数的值；若无解，则输出 `NO RESULT`。", "hint": "$n \\leq 10000$，$k \\leq 4000$，正整数均小于 $30000$。", "locale": "zh-CN"}}}
{"pid": "P1139", "type": "P", "difficulty": 5, "samples": [["3\ncba\n", "c A B\nb A B\na A D\nb B D\nc B D\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索"], "title": "单向双轨道", "background": "", "description": "如图所示，某火车站有 B、C 两个调度站，左边入口 A 处有$n$ 辆火车等待进站(从左到右以 $a,b,c,d$ 编号)，右边是出口 D，规定在这一段，火车从 A 进入经过 B、C 只能从左向右单向开，并且 B、C 调度站不限定所能停放的车辆数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/m1n53d63.png)\n\n从文件输入 $n$ 及 $n$ 个小写字母的一个排列，该排列表示火车在出口 D 处形成的从左到右的火车编号序列。输出为一系列操作过程，每一行形如 $h, L, R$ 的字母序列，其中 $h$ 为火车编号，$L$ 为 $h$ 车原先所在位置（位置都以$\\verb!A,B,C,D!$ 表示），$R$ 为新位置。或者输出 `NO` 表示不能完成这样的调度。\n", "inputFormat": "一个数 $n\\ (1<n\\le 15)$ 及由 $n$ 个小写字母组成的字符串。\n", "outputFormat": "可以调度则输出最短的调度序列，当有多种方案时输出按操作 $(L,R)$ 字典序最小的方案，不可以调度时则输出 `NO`。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "One-way Double Tracks", "background": "", "description": "As shown in the figure, a rail yard has two shunting stations B and C. At the left entrance A, there are $n$ trains waiting to enter (from left to right labeled $a, b, c, d$), and on the right side is the exit D. On this segment, trains entering from A and passing through B and C can only move one-way from left to right, and shunting stations B and C have no limit on the number of cars they can hold.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/m1n53d63.png)\n\nYou are given $n$ and a permutation of $n$ lowercase letters, which represents the sequence of train IDs from left to right formed at exit D. Output a sequence of operations, one per line, each being a letter sequence of the form $h, L, R$, where $h$ is a train ID, $L$ is the original position of $h$ (positions are denoted by $\\verb!A,B,C,D!$), and $R$ is the new position. Otherwise, output `NO` to indicate that such a dispatch cannot be completed.", "inputFormat": "An integer $n$ ($1 < n \\le 15$) and a string consisting of $n$ lowercase letters.", "outputFormat": "If it is feasible, output the shortest dispatch sequence. When there are multiple solutions, output the lexicographically smallest scheme with respect to the operation $(L, R)$. If it is not feasible, output `NO`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "单向双轨道", "background": "", "description": "如图所示，某火车站有 B、C 两个调度站，左边入口 A 处有$n$ 辆火车等待进站(从左到右以 $a,b,c,d$ 编号)，右边是出口 D，规定在这一段，火车从 A 进入经过 B、C 只能从左向右单向开，并且 B、C 调度站不限定所能停放的车辆数。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/m1n53d63.png)\n\n从文件输入 $n$ 及 $n$ 个小写字母的一个排列，该排列表示火车在出口 D 处形成的从左到右的火车编号序列。输出为一系列操作过程，每一行形如 $h, L, R$ 的字母序列，其中 $h$ 为火车编号，$L$ 为 $h$ 车原先所在位置（位置都以$\\verb!A,B,C,D!$ 表示），$R$ 为新位置。或者输出 `NO` 表示不能完成这样的调度。\n", "inputFormat": "一个数 $n\\ (1<n\\le 15)$ 及由 $n$ 个小写字母组成的字符串。\n", "outputFormat": "可以调度则输出最短的调度序列，当有多种方案时输出按操作 $(L,R)$ 字典序最小的方案，不可以调度时则输出 `NO`。\n", "hint": "", "locale": "zh-CN"}}}
