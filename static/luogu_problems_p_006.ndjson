{"pid": "P2517", "type": "P", "difficulty": 6, "samples": [["3 1 1000\r\n2 4 8\r\n1 2 4 ", "34"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "河南", "各省省选", "费用流"], "title": "[HAOI2010] 订货", "background": "", "description": "某公司估计市场在第 $i$ 个月对某产品的需求量为 $U_i$，已知在第 $i$ 月该产品的订货单价为 $d_i$，上个月月底未销完的单位产品要付存贮费用 $m$，假定第一月月初的库存量为 $0$，第 $n$ 月月底的库存量也为 $0$，问如何安排这 $n$ 个月订购计划，才能使成本最低？每月月初订购，订购后产品立即到货，进库并供应市场，于当月被售掉则不必付存贮费。假设仓库容量为 $S$。", "inputFormat": "第 $1$ 行：$n, m, S \\ (0\\le n\\le50, 0\\le m\\le10, 0\\le S\\le10000)$。\n\n第 $2$ 行：$U_1 , U_2 , \\cdots , U_n \\ (0\\le U_i\\le10000)$。\n\n第 $3$ 行：$d_1, d_2, \\cdots ,d_n \\ (0\\le d_i\\le100)$。", "outputFormat": "只有 $1$ 行，一个整数，代表最低成本。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2010] Ordering", "background": "", "description": "A company estimates that in month $i$ the market demand for a certain product is $U_i$. It is known that the unit purchase price in month $i$ is $d_i$. For each unit of product that remains unsold at the end of a month and is carried over to the next month, a storage fee of $m$ must be paid. Assume the initial inventory at the beginning of month $1$ is $0$, and the inventory at the end of month $n$ is also $0$. How should the ordering plan for these $n$ months be arranged to minimize the total cost?\n\nOrders are placed at the beginning of each month. After ordering, products arrive immediately, enter the warehouse, and supply the market. If a unit is sold within the same month, no storage fee is charged for it. Assume the warehouse capacity is $S$.", "inputFormat": "Line $1$: $n, m, S \\ (0\\le n\\le50, 0\\le m\\le10, 0\\le S\\le10000)$.\n\nLine $2$: $U_1 , U_2 , \\cdots , U_n \\ (0\\le U_i\\le10000)$.\n\nLine $3$: $d_1, d_2, \\cdots ,d_n \\ (0\\le d_i\\le100)$.", "outputFormat": "Only $1$ line, an integer representing the minimum cost.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2010] 订货", "background": "", "description": "某公司估计市场在第 $i$ 个月对某产品的需求量为 $U_i$，已知在第 $i$ 月该产品的订货单价为 $d_i$，上个月月底未销完的单位产品要付存贮费用 $m$，假定第一月月初的库存量为 $0$，第 $n$ 月月底的库存量也为 $0$，问如何安排这 $n$ 个月订购计划，才能使成本最低？每月月初订购，订购后产品立即到货，进库并供应市场，于当月被售掉则不必付存贮费。假设仓库容量为 $S$。", "inputFormat": "第 $1$ 行：$n, m, S \\ (0\\le n\\le50, 0\\le m\\le10, 0\\le S\\le10000)$。\n\n第 $2$ 行：$U_1 , U_2 , \\cdots , U_n \\ (0\\le U_i\\le10000)$。\n\n第 $3$ 行：$d_1, d_2, \\cdots ,d_n \\ (0\\le d_i\\le100)$。", "outputFormat": "只有 $1$ 行，一个整数，代表最低成本。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2518", "type": "P", "difficulty": 5, "samples": [["1020", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "数学", "2010", "河南", "各省省选", "数位 DP"], "title": "[HAOI2010] 计数", "background": null, "description": "现在给定一个数，你可以删掉这个数中的任意多个数位 $0$（或不删）并将其他的数位任意重新排序。请求出能产生出多少个不同的比这个数小的数（注意这个数不会有前导 0）。", "inputFormat": "只有一行，为一个整数 $n$。", "outputFormat": "一行一个整数，表示答案。", "hint": "$n$ 的长度不超过 $50$，答案不超过 $2^{63}-1$。\n\n样例解释：$12,21,102,120,201,210,1002$。", "locale": "zh-CN", "translations": {"en": {"title": "{{[HAOI2010] Counting}}", "background": "{{}}", "description": "{{You are given a number. You may delete any number of digit 0s (or none) from this number, and arbitrarily reorder the remaining digits. Count how many distinct numbers smaller than the original number can be produced in this way. Note that such a number must not have a leading zero.}}", "inputFormat": "{{Only one line, an integer $n$.}}", "outputFormat": "{{Output a single integer, the answer.}}", "hint": "{{$n$ has length at most 50, and the answer does not exceed $2^{63}-1$.\n\nSample explanation: $12,21,102,120,201,210,1002$.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2010] 计数", "background": null, "description": "现在给定一个数，你可以删掉这个数中的任意多个数位 $0$（或不删）并将其他的数位任意重新排序。请求出能产生出多少个不同的比这个数小的数（注意这个数不会有前导 0）。", "inputFormat": "只有一行，为一个整数 $n$。", "outputFormat": "一行一个整数，表示答案。", "hint": "$n$ 的长度不超过 $50$，答案不超过 $2^{63}-1$。\n\n样例解释：$12,21,102,120,201,210,1002$。", "locale": "zh-CN"}}}
{"pid": "P2519", "type": "P", "difficulty": 5, "samples": [["3\n2 0\n0 2\n2 2", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "递推", "2011", "河南", "各省省选"], "title": "[HAOI2011] problem a", "background": "", "description": "一次考试共有 $n$ 个人参加，可能出现多个人成绩相同的情况。第 $i$ 个人说：“有 $a_i$ 个人成绩比我高，$b_i$ 个人成绩比我低。”\n\n请求出最少有几个人没有说真话。", "inputFormat": "输入的第一行是一个整数，代表参加考试的人数 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行两个用空格隔开的整数，第 $(i + 1)$ 行的两个整数分别代表比第 $i$ 个人成绩高的人数 $a_i$ 和比第 $i$ 个人成绩低的人数 $b_i$。", "outputFormat": "输出一行一个整数，代表最少有几个人没有说真话。", "hint": "对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^5$，$0 \\leq a_i, b_i \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2011] problem a", "background": "", "description": "An exam has $n$ participants, and multiple people may have the same score. The $i$-th person says: \"There are $a_i$ people who scored higher than me, and $b_i$ people who scored lower than me.\"\n\nFind the minimum number of people who did not tell the truth.", "inputFormat": "The first line contains an integer $n$, the number of participants.\n\nLines $2$ to $(n + 1)$ each contain two space-separated integers. On the $(i + 1)$-th line, the two integers represent the number of people scoring higher than the $i$-th person $a_i$ and the number of people scoring lower than the $i$-th person $b_i$.", "outputFormat": "Output a single integer, the minimum number of people who did not tell the truth.", "hint": "For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 10^5$, $0 \\leq a_i, b_i \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2011] problem a", "background": "", "description": "一次考试共有 $n$ 个人参加，可能出现多个人成绩相同的情况。第 $i$ 个人说：“有 $a_i$ 个人成绩比我高，$b_i$ 个人成绩比我低。”\n\n请求出最少有几个人没有说真话。", "inputFormat": "输入的第一行是一个整数，代表参加考试的人数 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行两个用空格隔开的整数，第 $(i + 1)$ 行的两个整数分别代表比第 $i$ 个人成绩高的人数 $a_i$ 和比第 $i$ 个人成绩低的人数 $b_i$。", "outputFormat": "输出一行一个整数，代表最少有几个人没有说真话。", "hint": "对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^5$，$0 \\leq a_i, b_i \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P2520", "type": "P", "difficulty": 5, "samples": [["3\r\n2 1 3 3\r\n1 1 0 1\r\n1 0 -2 3", "Y\r\nN\r\nY"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2011", "河南", "各省省选", "最大公约数 gcd", "向量"], "title": "[HAOI2011] 向量", "background": "", "description": "给你一对数 $(a,b)$，你可以任意使用 $(a,b), (a,-b), (-a,b), (-a,-b), (b,a), (b,-a), (-b,a), (-b,-a)$ 这些向量，问你能不能拼出另一个向量 $(x,y)$。\n\n说明：这里的拼就是使得你选出的向量之和为 $(x,y)$。", "inputFormat": "第一行数组组数 $t(t\\leq50000)$。\n\n接下来 $t$ 行，每行四个整数 $a,b,x,y(-2\\times10^9\\leq a,b,x,y\\leq2\\times10^9)$。", "outputFormat": "$t$ 行，每行为 `Y` 或者为 `N`，分别表示可以拼出来，不能拼出来。", "hint": "### 样例解释\n\n第一组：$(2,1)+(1,2)=(3,3)$。\n\n第三组：$(-1,0)+(-1,0)+(0,1)+(0,1)+(0,1)=(-2,3)$。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2011] Vectors", "background": "", "description": "Given a pair of numbers $(a,b)$, you may use any of the vectors $(a,b)$, $(a,-b)$, $(-a,b)$, $(-a,-b)$, $(b,a)$, $(b,-a)$, $(-b,a)$, $(-b,-a)$ in arbitrary quantities. Determine whether you can form another vector $(x,y)$.\n\nNote: Here, “form” means that the sum of the vectors you choose equals $(x,y)$.", "inputFormat": "The first line contains the number of test cases $t$ ($t \\le 50000$).\n\nThe next $t$ lines each contain four integers $a, b, x, y$ ($-2\\times 10^9 \\le a, b, x, y \\le 2\\times 10^9$).", "outputFormat": "Output $t$ lines. Each line is `Y` if it is possible, or `N` if it is not.", "hint": "### Sample Explanation\n\nGroup 1: $(2,1) + (1,2) = (3,3)$.\n\nGroup 3: $(-1,0) + (-1,0) + (0,1) + (0,1) + (0,1) = (-2,3)$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2011] 向量", "background": "", "description": "给你一对数 $(a,b)$，你可以任意使用 $(a,b), (a,-b), (-a,b), (-a,-b), (b,a), (b,-a), (-b,a), (-b,-a)$ 这些向量，问你能不能拼出另一个向量 $(x,y)$。\n\n说明：这里的拼就是使得你选出的向量之和为 $(x,y)$。", "inputFormat": "第一行数组组数 $t(t\\leq50000)$。\n\n接下来 $t$ 行，每行四个整数 $a,b,x,y(-2\\times10^9\\leq a,b,x,y\\leq2\\times10^9)$。", "outputFormat": "$t$ 行，每行为 `Y` 或者为 `N`，分别表示可以拼出来，不能拼出来。", "hint": "### 样例解释\n\n第一组：$(2,1)+(1,2)=(3,3)$。\n\n第三组：$(-1,0)+(-1,0)+(0,1)+(0,1)+(0,1)=(-2,3)$。", "locale": "zh-CN"}}}
{"pid": "P2521", "type": "P", "difficulty": 6, "samples": [["4 2 1                                \n2                                 \n1 2                               \n3 2                               \n5                                 \n2\n1 1\n2\n1 2\n2", "6.47\n5.84\n4.47"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2011", "河南", "各省省选", "平衡树", "凸包"], "title": "[HAOI2011] 防线修建", "background": "", "description": "近来A国和B国的矛盾激化，为了预防不测，A 国准备修建一条长长的防线，当然修建防线的话，肯定要把需要保护的城市修在防线内部了。  \n\n可是A国上层现在还犹豫不决，到底该把哪些城市作为保护对象呢？又由于 A 国的经费有限，所以希望你能帮忙完成如下的一个任务：\n\n1、给出你所有的 A 国城市坐标\n\n2、A国上层经过讨论，考虑到经济问题，决定取消对 $u$ 城市的保护，也就是说 $u$ 城市不需要在防线内了\n\n3、A国上层询问对于剩下要保护的城市，修建防线的总经费最少是多少\n\n你需要对每次询问作出回答。注意单位长度的防线花费为 $1$。\n\nA 国的地形是这样的，形如下图，$x$ 轴是一条河流，相当于一条天然防线，不需要你再修建。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rkaw5kay.png)\n\nA 国总是有两个城市在河边，一个点是 $(0,0)$，一个点是 $(n,0)$，其余所有点的横坐标均在 $(0,n)$ 范围内，纵坐标均大于0。  \nA国有一个不在 $(0,0)$ 和 $(n,0)$ 的首都。$(0,0),(n,0)$ 和首都这三个城市是一定需要保护的。\n\n上图中，A,B,C,D,E 点为 A 国城市，且目前都要保护，那么修建的防线就会是 A-B-C-D，花费也就是线段 AB 的长度+线段 BC 的长度+线段 CD 的长度,如果，这个时候撤销 B 点的保护，那么防线变成下图\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cd7dpmcj.png)\n", "inputFormat": "第一行三个整数 $n,x,y$ 分别表示河边城市和首都是 $(0,0),(n,0),(x,y)$。\n\n第二行一个整数 $m$。\n\n接下来 $m$ 行，每行两个整数 $a,b$ 表示 A 国的一个非首都非河边城市的坐标为 $(a,b)$。\n\n再接下来一个整数 $q$，表示修改和询问总数。\n\n\n接下来 $q$ 行每行要么形如 `1 u`，要么形如 `2`，分别表示撤销第 $u$ 个城市的保护和询问。\n", "outputFormat": "对于每个询问输出一行一个实数 $v$，表示修建防线的花费，保留两位小数。\n", "hint": "【数据范围】   \n对于 $30\\%$ 的数据，$1\\le m,q \\le 1000$；   \n对于 $100\\%$ 的数据，$1\\le m \\le 10^5$，$1\\le q \\le 2 \\times 10^5$，$1 < n \\le 10^4$。\n\n所有点的坐标范围均在 $10^4$ 以内, 数据保证没有重点。\n\n---\n\n~~$\\text{upd 2022.7.21}$：新增加一组 Hack 数据。~~ 该数据有误，已经被移除。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2011] Building the Defense Line", "background": "", "description": "Recently, tensions between Country A and Country B have escalated. To guard against the unexpected, Country A plans to build a long defense line. Of course, if a defense line is built, the cities that need protection must lie inside the line.\n\nHowever, the leadership of Country A is still hesitant about which cities should be protected. Because the budget is limited, they want you to help with the following task:\n\n1. You are given the coordinates of all cities in Country A.\n2. After discussion, considering economic issues, the leadership decides to cancel protection for city $u$, meaning city $u$ no longer needs to be inside the defense line.\n3. The leadership asks: for the remaining cities that still need protection, what is the minimal total cost to build the defense line?\n\nYou need to answer each query. Note that the cost per unit length of the defense line is $1$.\n\nThe terrain of Country A is as follows. As shown in the figure, the $x$-axis is a river, which serves as a natural defense line and does not need to be built.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rkaw5kay.png)\n\nCountry A always has two cities on the riverbank: one at $(0, 0)$ and one at $(n, 0)$. The $x$-coordinates of all other points lie in $(0, n)$, and the $y$-coordinates are greater than $0$.  \nCountry A has a capital that is not at $(0, 0)$ or $(n, 0)$. The three cities $(0, 0)$, $(n, 0)$, and the capital must always be protected.\n\nIn the figure above, points A, B, C, D, E are cities of Country A, and all currently need protection. Then the defense line will be A-B-C-D, and the cost is the length of segment AB plus the length of segment BC plus the length of segment CD. If, at this moment, the protection of point B is canceled, then the defense line becomes the one shown below.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cd7dpmcj.png)", "inputFormat": "The first line contains three integers $n, x, y$, indicating that the riverbank cities and the capital are $(0, 0)$, $(n, 0)$, and $(x, y)$.\n\nThe second line contains an integer $m$.\n\nThe next $m$ lines each contain two integers $a, b$, indicating that the coordinates of a non-capital, non-river city are $(a, b)$.\n\nThen an integer $q$ follows, representing the total number of updates and queries.\n\nEach of the next $q$ lines is either of the form `1 u` or `2`, representing canceling the protection of the $u$-th city and an inquiry, respectively.", "outputFormat": "For each inquiry, output a real number $v$ on one line, representing the cost to build the defense line, with two decimal places.", "hint": "Constraints  \nFor $30\\%$ of the testdata, $1 \\le m, q \\le 1000$.  \nFor $100\\%$ of the testdata, $1 \\le m \\le 10^5$, $1 \\le q \\le 2 \\times 10^5$, $1 < n \\le 10^4$.\n\nAll coordinates are within $10^4$. The testdata guarantees there are no coincident points.\n\n---\n\n~~$\\text{upd 2022.7.21}$: A new hack testdata was added.~~ This testdata was invalid and has been removed.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2011] 防线修建", "background": "", "description": "近来A国和B国的矛盾激化，为了预防不测，A 国准备修建一条长长的防线，当然修建防线的话，肯定要把需要保护的城市修在防线内部了。  \n\n可是A国上层现在还犹豫不决，到底该把哪些城市作为保护对象呢？又由于 A 国的经费有限，所以希望你能帮忙完成如下的一个任务：\n\n1、给出你所有的 A 国城市坐标\n\n2、A国上层经过讨论，考虑到经济问题，决定取消对 $u$ 城市的保护，也就是说 $u$ 城市不需要在防线内了\n\n3、A国上层询问对于剩下要保护的城市，修建防线的总经费最少是多少\n\n你需要对每次询问作出回答。注意单位长度的防线花费为 $1$。\n\nA 国的地形是这样的，形如下图，$x$ 轴是一条河流，相当于一条天然防线，不需要你再修建。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rkaw5kay.png)\n\nA 国总是有两个城市在河边，一个点是 $(0,0)$，一个点是 $(n,0)$，其余所有点的横坐标均在 $(0,n)$ 范围内，纵坐标均大于0。  \nA国有一个不在 $(0,0)$ 和 $(n,0)$ 的首都。$(0,0),(n,0)$ 和首都这三个城市是一定需要保护的。\n\n上图中，A,B,C,D,E 点为 A 国城市，且目前都要保护，那么修建的防线就会是 A-B-C-D，花费也就是线段 AB 的长度+线段 BC 的长度+线段 CD 的长度,如果，这个时候撤销 B 点的保护，那么防线变成下图\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/cd7dpmcj.png)\n", "inputFormat": "第一行三个整数 $n,x,y$ 分别表示河边城市和首都是 $(0,0),(n,0),(x,y)$。\n\n第二行一个整数 $m$。\n\n接下来 $m$ 行，每行两个整数 $a,b$ 表示 A 国的一个非首都非河边城市的坐标为 $(a,b)$。\n\n再接下来一个整数 $q$，表示修改和询问总数。\n\n\n接下来 $q$ 行每行要么形如 `1 u`，要么形如 `2`，分别表示撤销第 $u$ 个城市的保护和询问。\n", "outputFormat": "对于每个询问输出一行一个实数 $v$，表示修建防线的花费，保留两位小数。\n", "hint": "【数据范围】   \n对于 $30\\%$ 的数据，$1\\le m,q \\le 1000$；   \n对于 $100\\%$ 的数据，$1\\le m \\le 10^5$，$1\\le q \\le 2 \\times 10^5$，$1 < n \\le 10^4$。\n\n所有点的坐标范围均在 $10^4$ 以内, 数据保证没有重点。\n\n---\n\n~~$\\text{upd 2022.7.21}$：新增加一组 Hack 数据。~~ 该数据有误，已经被移除。", "locale": "zh-CN"}}}
{"pid": "P2522", "type": "P", "difficulty": 5, "samples": [["2\n2 5 1 5 1\n1 5 1 5 2", "14\n3"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2011", "河南", "各省省选", "最大公约数 gcd", "莫比乌斯反演", "容斥原理", "整除分块"], "title": "[HAOI2011] Problem b", "background": "", "description": "对于给出的 $n$ 个询问，每次求有多少个数对 $(x,y)$，满足 $a \\le x \\le b$，$c \\le y \\le d$，且 $\\gcd(x,y) = k$，$\\gcd(x,y)$ 函数为 $x$ 和 $y$ 的最大公约数。", "inputFormat": "第一行一个整数 $n$，接下来 $n$ 行每行五个整数，分别表示 $a,b,c,d,k$。", "outputFormat": "共 $n$ 行，每行一个整数表示满足要求的数对 $(x,y)$ 的个数。", "hint": "对于 $100\\%$ 的数据满足：$1 \\le n,k \\le 5 \\times 10^4$，$1 \\le a \\le b \\le 5 \\times 10^4$，$1 \\le c \\le d \\le 5 \\times 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2011] Problem b", "background": "", "description": "For each of the given $n$ queries, count the number of pairs $(x,y)$ such that $a \\le x \\le b$, $c \\le y \\le d$, and $\\gcd(x,y) = k$. The function $\\gcd(x,y)$ denotes the greatest common divisor of $x$ and $y$.", "inputFormat": "The first line contains an integer $n$. Each of the next $n$ lines contains five integers, denoting $a, b, c, d, k$.", "outputFormat": "Output $n$ lines, each containing one integer representing the number of pairs $(x,y)$ that satisfy the conditions.", "hint": "Constraints: For $100\\%$ of the testdata, the following holds: $1 \\le n,k \\le 5 \\times 10^4$, $1 \\le a \\le b \\le 5 \\times 10^4$, $1 \\le c \\le d \\le 5 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2011] Problem b", "background": "", "description": "对于给出的 $n$ 个询问，每次求有多少个数对 $(x,y)$，满足 $a \\le x \\le b$，$c \\le y \\le d$，且 $\\gcd(x,y) = k$，$\\gcd(x,y)$ 函数为 $x$ 和 $y$ 的最大公约数。", "inputFormat": "第一行一个整数 $n$，接下来 $n$ 行每行五个整数，分别表示 $a,b,c,d,k$。", "outputFormat": "共 $n$ 行，每行一个整数表示满足要求的数对 $(x,y)$ 的个数。", "hint": "对于 $100\\%$ 的数据满足：$1 \\le n,k \\le 5 \\times 10^4$，$1 \\le a \\le b \\le 5 \\times 10^4$，$1 \\le c \\le d \\le 5 \\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2523", "type": "P", "difficulty": 5, "samples": [["2\n4 3 10\n1 2 2 1 3 1\n10 3 8882\n7 9 2 9 5 10", "YES 4\nNO"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2011", "河南", "各省省选", "组合数学"], "title": "[HAOI2011] Problem c", "background": "", "description": "给 $n$ 个人安排座位，先给每个人一个 $1\\thicksim n$ 的编号，设第 $i$ 个人的编号为 $a_i$（不同人的编号可以相同）。\n\n接着从第一个人开始，大家依次入座，第 $i$ 个人来了以后尝试坐到 $a_i$，如果 $a_i$ 被占据了，就尝试 $a_i+1$，$a_i+1$ 也被占据了的话就尝试 $a_i+2$……，如果一直尝试到第 $n$ 个都不行，该安排方案就不合法。\n\n然而有 $m$ 个人的编号已经确定（他们或许贿赂了你的上司...），你只能安排剩下的人的编号，求有多少种合法的安排方案。\n\n由于答案可能很大，只需输出其除以 $M$ 后的余数即可。", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n对于每组数据，第一行有三个整数，分别表示 $n$、$m$、$M$。\n\n若 $m$ 不为 $0$，则接下来一行有 $m$ 对整数，$p_1$、$q_1$，$p_2$、$q_2$，...， $p_m$、$q_m$，其中第 $i$ 对整数 $p_i$、$q_i$ 表示第 $p_i$ 个人的编号必须为 $q_i$。", "outputFormat": "对于每组数据输出一行，若是有解则输出 `YES`，后跟一个整数表示方案数 $\\bmod M$，注意，`YES` 和数之间只有一个空格，否则输出 `NO`。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证\n- $1 \\leq T \\leq 10$。\n- $1 \\leq n \\leq 300$， $0 \\leq m \\leq n$， $2 \\leq M \\leq 10^9$。\n- $1 \\leq p_i$、$q_i \\leq n$。\n- $p_i$ 互不相同。 ", "locale": "zh-CN", "translations": {"en": {"title": "[HAOI2011] Problem c", "background": "", "description": "Arrange seats for $n$ people. First, assign each person a label in $1\\thicksim n$. Let the label of the $i$-th person be $a_i$ (different people may share the same label).\n\nThen, starting from the first person, they take seats in order. When the $i$-th person arrives, they try to sit at $a_i$. If $a_i$ is occupied, they try $a_i+1$. If $a_i+1$ is also occupied, they try $a_i+2$, and so on. If all attempts up to seat $n$ fail, the arrangement is invalid.\n\nHowever, the labels of $m$ people have already been fixed (they may have bribed your boss...), and you can only assign labels to the remaining people. Find the number of valid assignment schemes.\n\nSince the answer may be large, output its remainder modulo $M$.", "inputFormat": "The first line contains an integer $T$, denoting the number of test cases.\n\nFor each test case, the first line contains three integers, $n$, $m$, and $M$.\n\nIf $m \\neq 0$, then the next line contains $m$ pairs of integers, $p_1$, $q_1$, $p_2$, $q_2$, ..., $p_m$, $q_m$, where the $i$-th pair $p_i$, $q_i$ means that the label of the $p_i$-th person must be $q_i$.", "outputFormat": "For each test case, output one line. If there is a solution, output `YES` followed by an integer representing the number of schemes $\\bmod M`. Note that there is exactly one space between `YES` and the number. Otherwise, output `NO`.", "hint": "#### Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that\n- $1 \\leq T \\leq 10$.\n- $1 \\leq n \\leq 300$, $0 \\leq m \\leq n$, $2 \\leq M \\leq 10^9$.\n- $1 \\leq p_i, q_i \\leq n$.\n- All $p_i$ are distinct.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HAOI2011] Problem c", "background": "", "description": "给 $n$ 个人安排座位，先给每个人一个 $1\\thicksim n$ 的编号，设第 $i$ 个人的编号为 $a_i$（不同人的编号可以相同）。\n\n接着从第一个人开始，大家依次入座，第 $i$ 个人来了以后尝试坐到 $a_i$，如果 $a_i$ 被占据了，就尝试 $a_i+1$，$a_i+1$ 也被占据了的话就尝试 $a_i+2$……，如果一直尝试到第 $n$ 个都不行，该安排方案就不合法。\n\n然而有 $m$ 个人的编号已经确定（他们或许贿赂了你的上司...），你只能安排剩下的人的编号，求有多少种合法的安排方案。\n\n由于答案可能很大，只需输出其除以 $M$ 后的余数即可。", "inputFormat": "第一行一个整数 $T$，表示数据组数。\n\n对于每组数据，第一行有三个整数，分别表示 $n$、$m$、$M$。\n\n若 $m$ 不为 $0$，则接下来一行有 $m$ 对整数，$p_1$、$q_1$，$p_2$、$q_2$，...， $p_m$、$q_m$，其中第 $i$ 对整数 $p_i$、$q_i$ 表示第 $p_i$ 个人的编号必须为 $q_i$。", "outputFormat": "对于每组数据输出一行，若是有解则输出 `YES`，后跟一个整数表示方案数 $\\bmod M$，注意，`YES` 和数之间只有一个空格，否则输出 `NO`。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证\n- $1 \\leq T \\leq 10$。\n- $1 \\leq n \\leq 300$， $0 \\leq m \\leq n$， $2 \\leq M \\leq 10^9$。\n- $1 \\leq p_i$、$q_i \\leq n$。\n- $p_i$ 互不相同。 ", "locale": "zh-CN"}}}
{"pid": "P2524", "type": "P", "difficulty": 1, "samples": [["3\n231", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "2015", "洛谷原创", "康托展开", "洛谷月赛"], "title": "Uim的情人节礼物·其之弐", "background": null, "description": "前传：详见洛谷 P2525\n\nUim 成功地按照顺序将礼物送到了 $N$ 个妹子的手里并维持她们的和谐。\n\n现在 Uim 想知道，他最终选择的顺序是所有给 $N$ 个妹子送礼顺序中，字典序第几小的。送礼顺序可以看作 $1,2,\\cdots,N$ 的一个排列。", "inputFormat": "第一行一个整数 $N$，表示有 $N$ 个数。\n\n第二行一个整数 $X$，表示给出的排列。", "outputFormat": "一个整数，表示是第几小的字典序。", "hint": "$1\\le N \\le 9$。\n\n请注意输入的排列没有空格。", "locale": "zh-CN", "translations": {"en": {"title": "Uim's Valentine's Gift · Part II", "background": "", "description": "Prequel: see Luogu P2525.\n\nUim successfully delivered gifts to $N$ girls in some order and maintained their harmony.\n\nNow Uim wants to know the lexicographic rank of the final order he chose among all gift-giving orders for $N$ girls. The order can be viewed as a permutation of $1,2,\\cdots,N$.", "inputFormat": "The first line contains an integer $N$.\n\nThe second line contains an integer $X$, representing the given permutation.", "outputFormat": "Output a single integer, indicating its position in lexicographic order.", "hint": "$1\\le N \\le 9$.\n\nPlease note that the permutation in the input has no spaces.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Uim的情人节礼物·其之弐", "background": null, "description": "前传：详见洛谷 P2525\n\nUim 成功地按照顺序将礼物送到了 $N$ 个妹子的手里并维持她们的和谐。\n\n现在 Uim 想知道，他最终选择的顺序是所有给 $N$ 个妹子送礼顺序中，字典序第几小的。送礼顺序可以看作 $1,2,\\cdots,N$ 的一个排列。", "inputFormat": "第一行一个整数 $N$，表示有 $N$ 个数。\n\n第二行一个整数 $X$，表示给出的排列。", "outputFormat": "一个整数，表示是第几小的字典序。", "hint": "$1\\le N \\le 9$。\n\n请注意输入的排列没有空格。", "locale": "zh-CN"}}}
{"pid": "P2525", "type": "P", "difficulty": 2, "samples": [["3\n1 3 2", "1 2 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "2015", "洛谷原创", "康托展开", "洛谷月赛"], "title": "Uim的情人节礼物·其之壱", "background": "", "description": "情人节到了，Uim打算给他的后宫们准备情人节礼物。UIm 一共有$N$（$1\\le N\\le 9$）个后宫妹子（现充去死挫骨扬灰!）。\n\n为了维护他的后宫的稳定。他通过编程，得出了一个送礼物的最佳顺序。这个我们管不着。\n\n然而他认为，如果什么事情做得太圆满不是什么好事。于是他希望得到原定顺序的前一个字典序的序列。\n", "inputFormat": "第一行一个整数 $N$。\n\n第二行 $N$ 个整数，表示原定排列。\n", "outputFormat": "输出 $N$ 个数，表示给定排列的前一个排列。特别地，若当前排列已经是第一个，则输出 `ERROR`。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Uim's Valentine's Day Gift · Part I", "background": "", "description": "Valentine's Day has arrived, and Uim plans to prepare Valentine's Day gifts for the members of his harem. Uim has a total of $N$ ($1\\le N\\le 9$) girls in his harem (normies go die and be ground to ashes!).\n\nTo maintain the stability of his harem, he wrote a program and obtained an optimal order for giving the gifts. That's not our concern.\n\nHowever, he believes that making things too perfect is not necessarily a good thing. Therefore, he wants to obtain the sequence that is immediately previous to the original order in lexicographic order.", "inputFormat": "The first line contains an integer $N$.\n\nThe second line contains $N$ integers, representing the original permutation.", "outputFormat": "Output $N$ numbers, representing the previous permutation of the given permutation. Specifically, if the current permutation is already the first in lexicographic order, output `ERROR`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Uim的情人节礼物·其之壱", "background": "", "description": "情人节到了，Uim打算给他的后宫们准备情人节礼物。UIm 一共有$N$（$1\\le N\\le 9$）个后宫妹子（现充去死挫骨扬灰!）。\n\n为了维护他的后宫的稳定。他通过编程，得出了一个送礼物的最佳顺序。这个我们管不着。\n\n然而他认为，如果什么事情做得太圆满不是什么好事。于是他希望得到原定顺序的前一个字典序的序列。\n", "inputFormat": "第一行一个整数 $N$。\n\n第二行 $N$ 个整数，表示原定排列。\n", "outputFormat": "输出 $N$ 个数，表示给定排列的前一个排列。特别地，若当前排列已经是第一个，则输出 `ERROR`。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2526", "type": "P", "difficulty": 4, "samples": [["4 5\n1 4 5 7 5 2 -2 4\n-4 -2 3 9 1 2 -1 3 8 -3\n", "6\n1 4 3 9 5 7 5 2 1 2 -2 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2001", "各省省选", "上海", "Special Judge", "二分图"], "title": "[SHOI2001] 小狗散步", "background": null, "description": "Grant 喜欢带着他的小狗 Pandog 散步。Grant 以一定的速度沿着固定路线走，该路线可能自交。Pandog 喜欢游览沿途的景点，不过会在给定的  $N$ 个点和主人相遇。小狗和主人同时从  $(X_1,Y_1)$ 点出发，并同时在  $(X_n,Y_n)$ 点汇合。小狗的速度最快是 Grant 的两倍。当主人从一个点以直线走向另一个点时，Pandog 跑向一个它感兴趣的景点。Pandog 每次与主人相遇之前最多只去一个景点。\n\n你现在的任务是：为 Pandog 寻找一条路线（有可能与主人的路线部分相同），使它能够游览最多的景点，并能够准时与主人在给定地点相遇或者汇合。", "inputFormat": "第一行是两个整数  $N$ 和  $M$。\n\n第二行的  $N$ 个整数坐标给出了 Grant 的散步路线，即 Pandog 和主人相遇地点。\n\n第三行的  $M$ 个整数坐标给出了所有 Pandog 感兴趣的景点。", "outputFormat": "输出小狗的移动路线。\n\n第一行是经过的点数，第二行依次为经过的点的二维坐标。", "hint": "对于所有数据，有  $1\\le N,M\\le 100$，所有输入的坐标均不相同，且绝对值不超过  $10^3$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2001] Puppy Walk", "background": "", "description": "Grant likes to take his puppy, Pandog, for walks. Grant moves at a constant speed along a fixed route, which may self‑intersect. Pandog enjoys visiting points of interest along the way, but will meet the owner at the given $N$ points. The puppy and the owner start simultaneously from $(X_1, Y_1)$ and finish together at $(X_N, Y_N)$. The puppy’s maximum speed is twice Grant’s speed. While the owner walks in a straight line from one meeting point to the next, Pandog may run to a point of interest. Before each meeting with the owner, Pandog visits at most one point of interest.\n\nYour task is to find a route for Pandog (which may partially coincide with the owner’s route) so that it can visit as many points of interest as possible, while still meeting the owner on time at each specified meeting point and at the final rendezvous.", "inputFormat": "The first line contains two integers $N$ and $M$.\n\nThe second line contains $N$ 2D integer coordinates, giving Grant’s walking route in order, i.e., the meeting points with Pandog.\n\nThe third line contains $M$ 2D integer coordinates, giving all points of interest that Pandog is interested in.", "outputFormat": "Output the puppy’s movement route.\n\nThe first line contains the number of points visited. The second line contains the 2D coordinates of the visited points in order.", "hint": "For all testdata, $1 \\le N, M \\le 100$, all input coordinates are distinct, and their absolute values do not exceed $10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2001] 小狗散步", "background": null, "description": "Grant 喜欢带着他的小狗 Pandog 散步。Grant 以一定的速度沿着固定路线走，该路线可能自交。Pandog 喜欢游览沿途的景点，不过会在给定的  $N$ 个点和主人相遇。小狗和主人同时从  $(X_1,Y_1)$ 点出发，并同时在  $(X_n,Y_n)$ 点汇合。小狗的速度最快是 Grant 的两倍。当主人从一个点以直线走向另一个点时，Pandog 跑向一个它感兴趣的景点。Pandog 每次与主人相遇之前最多只去一个景点。\n\n你现在的任务是：为 Pandog 寻找一条路线（有可能与主人的路线部分相同），使它能够游览最多的景点，并能够准时与主人在给定地点相遇或者汇合。", "inputFormat": "第一行是两个整数  $N$ 和  $M$。\n\n第二行的  $N$ 个整数坐标给出了 Grant 的散步路线，即 Pandog 和主人相遇地点。\n\n第三行的  $M$ 个整数坐标给出了所有 Pandog 感兴趣的景点。", "outputFormat": "输出小狗的移动路线。\n\n第一行是经过的点数，第二行依次为经过的点的二维坐标。", "hint": "对于所有数据，有  $1\\le N,M\\le 100$，所有输入的坐标均不相同，且绝对值不超过  $10^3$。", "locale": "zh-CN"}}}
{"pid": "P2527", "type": "P", "difficulty": 4, "samples": [["2 7\n3 5", "45\n\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2001", "各省省选", "离散化", "上海"], "title": "[SHOI2001] Panda的烦恼", "background": null, "description": "panda 是个数学怪人，他非常喜欢研究跟别人相反的事情。最近他正在研究筛法，众所周知，对一个范围内的整数，经过筛法处理以后，剩下的全部都是质数，不过 panda 对这些不感兴趣，他只对被筛掉的数感兴趣，他觉得在这些被筛掉的数中一定隐藏着重要的宇宙秘密，只是人们还没有发现罢了。\n\npanda 还觉得如果只是单纯地从小到大筛的话，还不足够发现其中的奥秘，于是他决定对至多只包含某些质因数的数进行研究（比如说至多只包含质因数  $2,3$ 的数有  $2,3,4,6,8,9,\\ldots$），他需要得到这些数中第 $k$ 小的数（$k$ 是 panda 认为的宇宙系数），请你编个程序，帮助他找到这个数。", "inputFormat": "第一行有两个整数 $n,k$，$n$ 代表质因数的个数，$k$ 代表那个宇宙系数。\n\n第二行有 $n$ 个整数，代表这 $n$ 个质因数，设这些质因数组成的序列为 $p$。", "outputFormat": "仅一行，即至多只包含这 $n$ 个质因数的数中第 $k$ 小的正整数，设这个答案为 $ans$。", "hint": "#### 样例解释\n\n前六个数分别是  $3,5,9,15,25,27$。\n\n#### 数据范围及限制\n\n对于所有数据，有:\n- $1\\le n\\le 100$\n- $1\\le k\\le 10^5$\n- $\\forall 1 \\le i < j \\le n,p_i \\ne p_j \\ \\text{且} \\ p_i \\in \\mathbb{P}$\n- $1\\le ans\\le 2\\times 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2001] Panda's Trouble", "background": "", "description": "panda is a math geek who loves studying things that go against the grain. Recently, he has been looking into sieve methods. As is well known, after applying a sieve to integers in a range, the remaining numbers are all primes. But panda is not interested in those; he is only interested in the numbers that get crossed out. He believes that important cosmic secrets are hidden among these eliminated numbers, which people just have not discovered yet.\n\npanda also thinks that simply sieving in ascending order is not enough to reveal the mystery, so he decides to study numbers that contain at most certain prime factors (for example, the numbers that contain at most the prime factors $2,3$ are $2,3,4,6,8,9,\\ldots$). He needs to obtain the $k$-th smallest among such numbers ($k$ is what panda calls the cosmic coefficient). Please write a program to help him find this number.", "inputFormat": "The first line contains two integers $n,k$, where $n$ is the number of prime factors, and $k$ is that cosmic coefficient.\n\nThe second line contains $n$ integers, representing these $n$ prime factors. Let the sequence formed by these primes be $p$.", "outputFormat": "Output a single line: the $k$-th smallest positive integer that contains at most these $n$ prime factors. Denote this answer by $ans$.", "hint": "#### Sample explanation\n\nThe first six numbers are $3,5,9,15,25,27$.\n\n#### Constraints\n\nFor all testdata, $1\\le n\\le 100$, $1\\le k\\le 10^5$, $p_i\\in\\text{prime}$, $p_i\\le 10^3$, $p_i\\not=p_j(i\\not=j)$, $1\\le ans\\le 2\\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2001] Panda的烦恼", "background": null, "description": "panda 是个数学怪人，他非常喜欢研究跟别人相反的事情。最近他正在研究筛法，众所周知，对一个范围内的整数，经过筛法处理以后，剩下的全部都是质数，不过 panda 对这些不感兴趣，他只对被筛掉的数感兴趣，他觉得在这些被筛掉的数中一定隐藏着重要的宇宙秘密，只是人们还没有发现罢了。\n\npanda 还觉得如果只是单纯地从小到大筛的话，还不足够发现其中的奥秘，于是他决定对至多只包含某些质因数的数进行研究（比如说至多只包含质因数  $2,3$ 的数有  $2,3,4,6,8,9,\\ldots$），他需要得到这些数中第 $k$ 小的数（$k$ 是 panda 认为的宇宙系数），请你编个程序，帮助他找到这个数。", "inputFormat": "第一行有两个整数 $n,k$，$n$ 代表质因数的个数，$k$ 代表那个宇宙系数。\n\n第二行有 $n$ 个整数，代表这 $n$ 个质因数，设这些质因数组成的序列为 $p$。", "outputFormat": "仅一行，即至多只包含这 $n$ 个质因数的数中第 $k$ 小的正整数，设这个答案为 $ans$。", "hint": "#### 样例解释\n\n前六个数分别是  $3,5,9,15,25,27$。\n\n#### 数据范围及限制\n\n对于所有数据，有:\n- $1\\le n\\le 100$\n- $1\\le k\\le 10^5$\n- $\\forall 1 \\le i < j \\le n,p_i \\ne p_j \\ \\text{且} \\ p_i \\in \\mathbb{P}$\n- $1\\le ans\\le 2\\times 10^9$。", "locale": "zh-CN"}}}
{"pid": "P2528", "type": "P", "difficulty": 4, "samples": [["4 3", "6\n1 4 3 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2001", "各省省选", "上海"], "title": "[SHOI2001] 排序工作量之新任务", "background": "", "description": "假设我们将序列中第 $i$ 件物品的参数定义为 $A_i$，那么排序就是指将 $A_1, \\cdots ,A_n$ 从小到大排序。若 $i<j$ 且 $A_i>A_j$ ，则 $(i,j)$ 就为一个“逆序对”。SORT 公司是一个专门为用户提供排序服务的公司，他们的收费标准就是被要求排序物品的“逆序对”的个数，简称“逆序数”。\n\nGrant 是这家公司的排序员，他想知道对于 $n$ 个参数都不同的物品组成的序列集合中，逆序对数为 $t$ 的物品有多少个，并试给出其中一个最小的物品序列。所谓最小，即若有两个物品序列 $(A_1,A_2,\\cdots ,A_n)$，$(B_1,B_2,\\cdots ,B_n)$，存在 $1 \\le i \\le n$，使得 $(A_1,A_2,\\cdots ,A_{i-1})=(B_1,B_2,\\cdots,B_{i-1})$ 且$A_i<B_i$。\n", "inputFormat": "即两个整数 $n$和 $t(1 \\le n \\le 20,0 \\le t \\le \\dfrac{n\\cdot (n-1)}{2})$。\n", "outputFormat": "第一行表示 $n$ 个参数都不通的物品组成的序列集合中，逆序数为 $t$ 的序列个数；\n\n第二行是所求物品参数序列。假设 $n$ 个物品分别为 $1$ 到 $n$。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2001] New Task on Sorting Workload", "background": "", "description": "Suppose we define the parameter of the $i$-th item as $A_i$. Sorting means arranging $A_1, \\cdots ,A_n$ in ascending order. If $i < j$ and $A_i > A_j$, then $(i, j)$ is an “inversion pair.” The SORT company specializes in providing sorting services. Their pricing is based on the number of inversion pairs among the items to be sorted, called the “inversion count.”\n\nGrant is a sorter at this company. He wants to know, among all sequences of $n$ items with distinct parameters, how many have inversion count $t$, and to also provide one lexicographically smallest such sequence. “Smallest” means: for two sequences $(A_1,A_2,\\cdots ,A_n)$ and $(B_1,B_2,\\cdots ,B_n)$, if there exists $1 \\le i \\le n$ such that $(A_1,A_2,\\cdots ,A_{i-1})=(B_1,B_2,\\cdots ,B_{i-1})$ and $A_i < B_i$.", "inputFormat": "Two integers $n$ and $t$ ($1 \\le n \\le 20$, $0 \\le t \\le \\dfrac{n\\cdot (n-1)}{2}$).", "outputFormat": "- The first line contains the number of sequences of $n$ distinct items whose inversion count is $t$.\n- The second line is the requested sequence of item parameters. Assume the $n$ items are labeled $1$ to $n$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2001] 排序工作量之新任务", "background": "", "description": "假设我们将序列中第 $i$ 件物品的参数定义为 $A_i$，那么排序就是指将 $A_1, \\cdots ,A_n$ 从小到大排序。若 $i<j$ 且 $A_i>A_j$ ，则 $(i,j)$ 就为一个“逆序对”。SORT 公司是一个专门为用户提供排序服务的公司，他们的收费标准就是被要求排序物品的“逆序对”的个数，简称“逆序数”。\n\nGrant 是这家公司的排序员，他想知道对于 $n$ 个参数都不同的物品组成的序列集合中，逆序对数为 $t$ 的物品有多少个，并试给出其中一个最小的物品序列。所谓最小，即若有两个物品序列 $(A_1,A_2,\\cdots ,A_n)$，$(B_1,B_2,\\cdots ,B_n)$，存在 $1 \\le i \\le n$，使得 $(A_1,A_2,\\cdots ,A_{i-1})=(B_1,B_2,\\cdots,B_{i-1})$ 且$A_i<B_i$。\n", "inputFormat": "即两个整数 $n$和 $t(1 \\le n \\le 20,0 \\le t \\le \\dfrac{n\\cdot (n-1)}{2})$。\n", "outputFormat": "第一行表示 $n$ 个参数都不通的物品组成的序列集合中，逆序数为 $t$ 的序列个数；\n\n第二行是所求物品参数序列。假设 $n$ 个物品分别为 $1$ 到 $n$。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2529", "type": "P", "difficulty": 4, "samples": [["11\n12\n13\n14\n15\n", "8\n6\n8\n2\n8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["高精度", "2001", "各省省选", "递归", "上海"], "title": "[SHOI2001] 击鼓传花", "background": "", "description": "HC(Happy Child)小朋友最近经常在教室里跟同学一起玩击鼓传花的游戏，规则是第 $n$ 个拿到花的小朋友必须说出 $n!$ 最后一位非 0 的数字，如此循环游戏，如果谁讲错了就得罚唱一支歌曲。\n\n经过几次游戏，HC 小朋友认为只要把前一个小朋友说得数字去乘以 $n$，说出得到的数的最后一位非 $0$ 的数字就可以了，可惜 HC 小朋友这次轮到了第 $15$ 个，结果被罚了唱歌(应该是 $8$，但是HC小朋友却说了$3$)。\n\nHC 小朋友不希望这样的事情再次发生，所以希望你能编写一个程序，能够计算出 $n!$ 的最后一位非 $0$ 的数字。\n", "inputFormat": "输入有 $5$ 行，第 $i$ ($1\\le i\\le 5$) 行是一个 $n$ ($1\\le n\\le10^{100}$)。\n", "outputFormat": "输出有 $5$ 行。\n\n第 $i$ 行对应输入中第 $i$ 行的 $n$ 的阶乘的最后一位非 $0$ 的数字。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2001] Passing the Flower", "background": "", "description": "HC (Happy Child) and classmates often play a game called \"passing the flower\" in the classroom. The rule is that the child who gets the flower for the $n$-th time must say the last non-zero digit of $n!$. The game proceeds in cycles, and anyone who answers incorrectly has to sing a song as a penalty.\n\nAfter a few rounds, HC believed that one could simply multiply the previous child's number by $n$ and then say the last non-zero digit of the resulting number. Unfortunately, when it was HC's turn at $n = 15$, HC answered $3$ and was penalized, while the correct answer should have been $8$.\n\nHC does not want this to happen again, so you are asked to write a program that computes the last non-zero digit of $n!$.", "inputFormat": "There are $5$ lines of input. The $i$-th ($1 \\le i \\le 5$) line contains an $n$ ($1 \\le n \\le 10^{100}$).", "outputFormat": "Output $5$ lines.\n\nThe $i$-th line should be the last non-zero digit of the factorial of the $n$ on the $i$-th input line.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2001] 击鼓传花", "background": "", "description": "HC(Happy Child)小朋友最近经常在教室里跟同学一起玩击鼓传花的游戏，规则是第 $n$ 个拿到花的小朋友必须说出 $n!$ 最后一位非 0 的数字，如此循环游戏，如果谁讲错了就得罚唱一支歌曲。\n\n经过几次游戏，HC 小朋友认为只要把前一个小朋友说得数字去乘以 $n$，说出得到的数的最后一位非 $0$ 的数字就可以了，可惜 HC 小朋友这次轮到了第 $15$ 个，结果被罚了唱歌(应该是 $8$，但是HC小朋友却说了$3$)。\n\nHC 小朋友不希望这样的事情再次发生，所以希望你能编写一个程序，能够计算出 $n!$ 的最后一位非 $0$ 的数字。\n", "inputFormat": "输入有 $5$ 行，第 $i$ ($1\\le i\\le 5$) 行是一个 $n$ ($1\\le n\\le10^{100}$)。\n", "outputFormat": "输出有 $5$ 行。\n\n第 $i$ 行对应输入中第 $i$ 行的 $n$ 的阶乘的最后一位非 $0$ 的数字。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2530", "type": "P", "difficulty": 4, "samples": [["11\nA\nB\nC\nA\nB\nC\nA\nB\nC\nA\nB\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2001", "各省省选", "上海", "枚举"], "title": "[SHOI2001] 化工厂装箱员", "background": "", "description": "118 号工厂是世界唯一秘密提炼锎的化工厂，由于提炼锎的难度非常高，技术不是十分完善，所以工厂生产的锎成品可能会有 $3$ 种不同的纯度，$A$：$100\\%$，$B$：$1\\%$，$C$：$0.01\\%$，为了出售方便，必须把不同纯度的成品分开装箱，装箱员 grant 第 $1$ 次顺序从流水线上取 $10$ 个成品（如果一共不足 $10$ 个，则全部取出），以后每一次把手中某种纯度的成品放进相应的箱子，然后再从流水线上顺序取一些成品，使手中保持 $10$ 个成品（如果把剩下的全部取出不足 $10$ 个，则全部取出），如果所有的成品都装进了箱子，那么 grant 的任务就完成了。\n\n由于装箱是件非常累的事情，grant 希望他能够以最少的装箱次数来完成他的任务，现在他请你编个程序帮助他。\n", "inputFormat": "第 $1$ 行为 $n$（$1\\le n\\le 100$），为成品的数量。\n\n以后 $n$ 行，每行为一个大写字母 $\\texttt A$，$\\texttt B$ 或 $\\texttt C$，表示成品的纯度。\n", "outputFormat": "仅一行，为 grant 需要的最少的装箱次数。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2001] Chemical Plant Packer", "background": "", "description": "Factory No. 118 is the world’s only secret chemical plant that refines californium. Because refining californium is very difficult and the technology is not very mature, the finished products may have $3$ different purities: $A$: $100\\%$, $B$: $1\\%$, $C$: $0.01\\%$. For convenient sale, products of different purities must be boxed separately. The packer Grant first takes $10$ products from the assembly line in order (if there are fewer than $10$ in total, he takes all of them). After that, each time he puts all products of one purity in his hand into the corresponding box, and then takes products from the assembly line in order so that he again holds $10$ products (if taking all the remaining ones still makes fewer than $10$, he takes all of them). If all the products have been boxed, then Grant’s task is finished.\n\nSince boxing is very tiring, Grant hopes he can finish his task with the fewest number of boxing operations. Now he asks you to write a program to help him.", "inputFormat": "The first line is $n$ ( $1\\le n\\le 100$ ), the number of products.\n\nThen $n$ lines follow, each containing one uppercase letter $\\texttt A$, $\\texttt B$ or $\\texttt C$, indicating the product’s purity.", "outputFormat": "A single line containing the minimum number of boxing operations Grant needs.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2001] 化工厂装箱员", "background": "", "description": "118 号工厂是世界唯一秘密提炼锎的化工厂，由于提炼锎的难度非常高，技术不是十分完善，所以工厂生产的锎成品可能会有 $3$ 种不同的纯度，$A$：$100\\%$，$B$：$1\\%$，$C$：$0.01\\%$，为了出售方便，必须把不同纯度的成品分开装箱，装箱员 grant 第 $1$ 次顺序从流水线上取 $10$ 个成品（如果一共不足 $10$ 个，则全部取出），以后每一次把手中某种纯度的成品放进相应的箱子，然后再从流水线上顺序取一些成品，使手中保持 $10$ 个成品（如果把剩下的全部取出不足 $10$ 个，则全部取出），如果所有的成品都装进了箱子，那么 grant 的任务就完成了。\n\n由于装箱是件非常累的事情，grant 希望他能够以最少的装箱次数来完成他的任务，现在他请你编个程序帮助他。\n", "inputFormat": "第 $1$ 行为 $n$（$1\\le n\\le 100$），为成品的数量。\n\n以后 $n$ 行，每行为一个大写字母 $\\texttt A$，$\\texttt B$ 或 $\\texttt C$，表示成品的纯度。\n", "outputFormat": "仅一行，为 grant 需要的最少的装箱次数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2531", "type": "P", "difficulty": 5, "samples": [["5\n0.902 0.540 0.862 0.283 0.498 0.597 0.900 0.076 0.750 0.539 \n0.342 0.574 0.743 0.442 0.579 0.502 0.755 0.649 0.835 0.278 \n0.105 0.704 0.274 0.733 0.725 0.861 0.007 0.314 0.099 0.542 \n0.785 0.754 0.541 0.331 0.430 0.426 0.928 0.385 0.314 0.892 \n0.349 0.354 0.408 0.353 0.333 0.180 0.715 0.013 0.563 0.386 \n0.131 0.564 0.265 0.700 0.033 \n0.293 0.688 0.140 0.130 0.550 \n0.346 0.915 0.385 0.536 0.946 \n0.739 0.051 0.682 0.166 0.436 \n0.122 0.065 0.724 0.934 0.736\n", "0.529237"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2001", "各省省选", "上海"], "title": "[SHOI2001] 三国围棋对抗赛", "background": "中国邀请韩国，日本围棋队来参加三国围棋对抗赛，韩国，日本应邀各派了 $5$ 位超一流高手来参赛，中国围棋队希望能赢得这场比赛，但是这 $10$ 位高手实力不俗。不过中国队作为东道主，可以在对方选手安排好出场顺序后再决定队员的组成以及出场顺序，以得到最大的获胜概率。", "description": "比赛规则如下：先抽签决定第 $1$ 轮轮空的队，由不轮空的 $2$ 支队的 $1$ 号队员进行比赛，失利的队员被淘汰，以后每次由前一轮获胜的队员与前一轮轮空的队剩下的队员中序号最小的队员进行比赛，直到只剩下一个国家的队员为止，这个国家就获得了比赛的胜利。\n\n>注：当场上只有两支队伍有队员没被淘汰时忽略轮空，即每次都是这两支队伍中序号分别最小的两个队员进行比赛，输的淘汰。", "inputFormat": "第 $1$ 行为一个数 $n~(5\\le n\\le15)$，中国队的候选人数。\n\n接下来是 $n$ 行，每行有 $10$ 个数。\n\n第 $i+1~(1\\le i\\le n)$ 行的 $10$ 个数依次表示第 $i$ 位中国选手对韩国 $1\\sim5$ 号，日本 $1\\sim5$ 号的胜率，胜率 $k~(0\\le k\\le1)$。\n\n再接下来是 $5$ 行，每行有 $5$ 个数。\n\n第 $i+n+1~(1\\le i\\le n)$ 行的第 $j$ 个数表示韩国 $i$ 号选手对日本 $j$ 号选手的胜率。", "outputFormat": "仅 $1$ 行，为中国队的最大的获胜概率，保留 $6$ 位小数。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2001] Three-Nation Go Team Competition", "background": "China invited the Korean and Japanese Go teams to a three-nation team competition. Korea and Japan each sent 5 top-tier players. Team China hopes to win the match, but those 10 players are very strong. However, as the host, after the other two teams have fixed their rosters and playing orders, Team China may decide its own roster and playing order to maximize its winning probability.", "description": "The rules are as follows: first, a draw determines the team that has a bye in round $1$. Then the No. $1$ players of the two non-bye teams play; the loser is eliminated. Thereafter, in each round, the previous winner plays against the smallest-index remaining player from the team that had the bye in the previous round. This continues until only one country still has players remaining; that country wins.\n\n> Note: When only two teams still have players not eliminated, ignore byes. In each round, the two smallest-index players from those two teams play, and the loser is eliminated.", "inputFormat": "The first line contains a number $n$ $(5 \\le n \\le 15)$, the number of candidates for Team China.\n\nThen follow $n$ lines, each containing $10$ numbers.\n\nIn line $i+1$ $(1 \\le i \\le n)$, the $10$ numbers are the win probabilities of Chinese candidate $i$ against Korea No. $1 \\sim 5$ and Japan No. $1 \\sim 5$, respectively; each probability is $k$ $(0 \\le k \\le 1)$.\n\nNext are $5$ lines, each containing $5$ numbers.\n\nIn line $n+i+1$ $(1 \\le i \\le 5)$, the $j$-th number is the win probability that Korea player $i$ defeats Japan player $j$.", "outputFormat": "Output a single line: the maximum winning probability for Team China, to $6$ decimal places.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2001] 三国围棋对抗赛", "background": "中国邀请韩国，日本围棋队来参加三国围棋对抗赛，韩国，日本应邀各派了 $5$ 位超一流高手来参赛，中国围棋队希望能赢得这场比赛，但是这 $10$ 位高手实力不俗。不过中国队作为东道主，可以在对方选手安排好出场顺序后再决定队员的组成以及出场顺序，以得到最大的获胜概率。", "description": "比赛规则如下：先抽签决定第 $1$ 轮轮空的队，由不轮空的 $2$ 支队的 $1$ 号队员进行比赛，失利的队员被淘汰，以后每次由前一轮获胜的队员与前一轮轮空的队剩下的队员中序号最小的队员进行比赛，直到只剩下一个国家的队员为止，这个国家就获得了比赛的胜利。\n\n>注：当场上只有两支队伍有队员没被淘汰时忽略轮空，即每次都是这两支队伍中序号分别最小的两个队员进行比赛，输的淘汰。", "inputFormat": "第 $1$ 行为一个数 $n~(5\\le n\\le15)$，中国队的候选人数。\n\n接下来是 $n$ 行，每行有 $10$ 个数。\n\n第 $i+1~(1\\le i\\le n)$ 行的 $10$ 个数依次表示第 $i$ 位中国选手对韩国 $1\\sim5$ 号，日本 $1\\sim5$ 号的胜率，胜率 $k~(0\\le k\\le1)$。\n\n再接下来是 $5$ 行，每行有 $5$ 个数。\n\n第 $i+n+1~(1\\le i\\le n)$ 行的第 $j$ 个数表示韩国 $i$ 号选手对日本 $j$ 号选手的胜率。", "outputFormat": "仅 $1$ 行，为中国队的最大的获胜概率，保留 $6$ 位小数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2532", "type": "P", "difficulty": 4, "samples": [["3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "高精度", "2012", "各省省选", "安徽", "Catalan 数"], "title": "[AHOI2012] 树屋阶梯", "background": "", "description": " ![](https://cdn.luogu.com.cn/upload/pic/1630.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/1631.png) \n\n", "inputFormat": "一个正整数 $N$，表示阶梯的高度。\n", "outputFormat": "一个正整数，表示搭建方法的个数。**注**：搭建方法的个数可能很大。\n", "hint": "- 对于 $40\\%$ 的数据，满足 $1\\le N\\le 20$。\n- 对于 $80\\%$ 的数据，满足 $1\\le N\\le 300$。\n- 对于 $100\\%$ 的数据，满足 $1\\le N\\le 500$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2012] Treehouse Staircase", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1630.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/1631.png)", "inputFormat": "A positive integer $N$, representing the height of the staircase.", "outputFormat": "A positive integer, representing the number of ways to build it. **Note**: The number of ways may be very large.", "hint": "- For $40\\%$ of the testdata, $1 \\le N \\le 20$.\n- For $80\\%$ of the testdata, $1 \\le N \\le 300$.\n- For $100\\%$ of the testdata, $1 \\le N \\le 500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2012] 树屋阶梯", "background": "", "description": " ![](https://cdn.luogu.com.cn/upload/pic/1630.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/1631.png) \n\n", "inputFormat": "一个正整数 $N$，表示阶梯的高度。\n", "outputFormat": "一个正整数，表示搭建方法的个数。**注**：搭建方法的个数可能很大。\n", "hint": "- 对于 $40\\%$ 的数据，满足 $1\\le N\\le 20$。\n- 对于 $80\\%$ 的数据，满足 $1\\le N\\le 300$。\n- 对于 $100\\%$ 的数据，满足 $1\\le N\\le 500$。\n", "locale": "zh-CN"}}}
{"pid": "P2533", "type": "P", "difficulty": 6, "samples": [["5\n1.200 1.200\n2.400 2.400\n3.800 4.500\n2.500 3.100\n3.900 1.300", "2.50 2.85 2.10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["计算几何", "2012", "各省省选", "安徽", "随机化"], "title": "[AHOI2012] 信号塔", "background": "", "description": "在野外训练中，为了确保每位参加集训的成员安全，实时的掌握和收集周边环境和队员信息非常重要，集训队采用的方式是在训练所在地散布 $N$ 个小型传感器来收集并传递信息，这些传感器只与设在集训地中的信号塔进行通信，信号塔接收信号的覆盖范围是圆形，可以接收到所有分布在该集训区域内所有 $N$ 个小型传感器（包括在该圆形的边上）发出的信号。信号塔的功率与信号塔接收范围半径的大小成正比，因为是野外训练，只能使用事先储备好的蓄电设备，因此在可以收集所有传感器信息的基础上，还应使得信号塔的功率最小。小龙帮助教官确定了一种信号塔设置的方案，既可以收集到所有 $N$ 个传感器的信号，又可以保证这个信号塔的功率是最小的。同学们，你们知道，这个信号塔的信号收集半径有多大，它应该设置在何处吗?", "inputFormat": "共 $N+1$ 行，第一行为正整数 $N$，表示队员个数。接下来 $N$ 行，每行两个实数用空格分开，分别是第 $i$ 个队员的坐标 $x_i$ 和 $y_i$ （$x_i,y_i$ 不超过双精度范围）。", "outputFormat": "一行，共三个实数（中间用空格隔开），分别是信号塔的坐标，和信号塔覆盖的半径。", "hint": "队员是否在边界上的判断应该符合他到圆心的距离与信号塔接受半径的差的绝对值小于 $10^{-6}$，最终结果保留 $2$ 位小数。\n\n对于 $30\\%$ 的数据，满足 $1\\le N \\le 10^4$  \n对于 $70\\%$ 的数据，满足 $1\\le N \\le 2\\times10^4$  \n对于 $100\\%$ 的数据，满足 $1\\le N \\le 10^6$\n\n本题存在 hack 数据，计 0 分。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2012] Signal Tower", "background": "", "description": "During field training, to ensure the safety of every participant, it is very important to monitor and collect information about the surrounding environment and team members in real time. The training team deploys $N$ small sensors around the training site to collect and transmit information. These sensors communicate only with a signal tower set up within the training area. The signal tower’s reception coverage is circular; it can receive signals from all $N$ sensors distributed in the area, including those on the circle’s boundary. The tower’s power is proportional to the radius of its reception range. Because this is field training and only pre-stored battery equipment can be used, under the condition that all sensor information can be collected, the tower’s power should be minimized. Xiaolong has helped the instructor determine a placement scheme that both collects all $N$ sensors’ signals and minimizes the tower’s power. Students, can you determine how large the tower’s signal collection radius should be, and where it should be placed?", "inputFormat": "There are $N + 1$ lines. The first line contains a positive integer $N$, the number of sensors. The next $N$ lines each contain two real numbers separated by a space, which are the coordinates $x_i$ and $y_i$ of the $i$-th sensor ($x_i, y_i$ are within the range of double precision).", "outputFormat": "One line containing three real numbers separated by spaces: the coordinates of the signal tower and the tower’s coverage radius.", "hint": "- Determine that a sensor lies on the boundary if the absolute value of the difference between its distance to the circle center and the tower’s reception radius is less than $10^{-6}$. Keep the final result to $2$ decimal places.\n- Constraints:\n  - For $30\\%$ of the testdata, $1 \\le N \\le 10^4$.\n  - For $70\\%$ of the testdata, $1 \\le N \\le 2 \\times 10^4$.\n  - For $100\\%$ of the testdata, $1 \\le N \\le 10^6$.\n- This problem contains hack testdata and is scored as $0$ points.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2012] 信号塔", "background": "", "description": "在野外训练中，为了确保每位参加集训的成员安全，实时的掌握和收集周边环境和队员信息非常重要，集训队采用的方式是在训练所在地散布 $N$ 个小型传感器来收集并传递信息，这些传感器只与设在集训地中的信号塔进行通信，信号塔接收信号的覆盖范围是圆形，可以接收到所有分布在该集训区域内所有 $N$ 个小型传感器（包括在该圆形的边上）发出的信号。信号塔的功率与信号塔接收范围半径的大小成正比，因为是野外训练，只能使用事先储备好的蓄电设备，因此在可以收集所有传感器信息的基础上，还应使得信号塔的功率最小。小龙帮助教官确定了一种信号塔设置的方案，既可以收集到所有 $N$ 个传感器的信号，又可以保证这个信号塔的功率是最小的。同学们，你们知道，这个信号塔的信号收集半径有多大，它应该设置在何处吗?", "inputFormat": "共 $N+1$ 行，第一行为正整数 $N$，表示队员个数。接下来 $N$ 行，每行两个实数用空格分开，分别是第 $i$ 个队员的坐标 $x_i$ 和 $y_i$ （$x_i,y_i$ 不超过双精度范围）。", "outputFormat": "一行，共三个实数（中间用空格隔开），分别是信号塔的坐标，和信号塔覆盖的半径。", "hint": "队员是否在边界上的判断应该符合他到圆心的距离与信号塔接受半径的差的绝对值小于 $10^{-6}$，最终结果保留 $2$ 位小数。\n\n对于 $30\\%$ 的数据，满足 $1\\le N \\le 10^4$  \n对于 $70\\%$ 的数据，满足 $1\\le N \\le 2\\times10^4$  \n对于 $100\\%$ 的数据，满足 $1\\le N \\le 10^6$\n\n本题存在 hack 数据，计 0 分。", "locale": "zh-CN"}}}
{"pid": "P2534", "type": "P", "difficulty": 5, "samples": [["5\n2 4 3 5 1", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2012", "各省省选", "安徽", "排序", "剪枝", "启发式迭代加深搜索 IDA*", "A*  算法"], "title": "[AHOI2012] 铁盘整理", "background": "", "description": "在训练中，一些臂力训练器材是少不了的，小龙在练习的时候发现举重器械上的铁盘放置的非常混乱，并没有按照从轻到重的顺序摆放，这样非常不利于循序渐进的锻炼。他打算利用一个非常省力气的办法来整理这些铁盘，即每次都拿起最上面的若干个圆盘并利用器械的力量上下翻转，这样翻转若干次以后，铁盘将会按照从小到大的顺序排列好。那么你能不能帮小龙确定，最少翻转几次就可以使铁盘按从小到大排序呢？\n\n例如：下面的铁盘经过如图所示的以下几个步骤的翻转后变为从小到大排列。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xtpst1lw.png)", "inputFormat": "共两行。第一行为铁盘个数 $N$（$1 \\leq N \\leq 16$），第二行为 $N$ 个不同的正整数，分别为从上到下的铁盘的半径 $R$（$1 \\leq R \\leq 100$）。\n", "outputFormat": "一个正整数，表示使铁盘从小到大有序需要的最少翻转次数。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2012] Iron Plate Sorting", "background": "", "description": "During training, some arm-strength equipment is indispensable. When Xiaolong was practicing, he found that the iron plates on the weightlifting machine were placed in a very chaotic order, not arranged from light to heavy, which is not conducive to gradual training. He plans to use a very effortless method to organize these plates: each time, he picks up the top several plates and uses the machine’s force to flip them as a block. After flipping several times, the plates will be arranged from small to large. Can you help Xiaolong determine the minimum number of flips needed to sort the plates from smallest to largest?\n\nFor example: the plates below become sorted from small to large after the flips shown in the figure.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xtpst1lw.png)", "inputFormat": "There are two lines.  \nThe first line contains the number of plates $N$ ($1 \\leq N \\leq 16$).  \nThe second line contains $N$ distinct positive integers, which are the radii $R$ of the plates from top to bottom ($1 \\leq R \\leq 100$).", "outputFormat": "Output a single positive integer, the minimum number of flips required to make the plates ordered from small to large.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2012] 铁盘整理", "background": "", "description": "在训练中，一些臂力训练器材是少不了的，小龙在练习的时候发现举重器械上的铁盘放置的非常混乱，并没有按照从轻到重的顺序摆放，这样非常不利于循序渐进的锻炼。他打算利用一个非常省力气的办法来整理这些铁盘，即每次都拿起最上面的若干个圆盘并利用器械的力量上下翻转，这样翻转若干次以后，铁盘将会按照从小到大的顺序排列好。那么你能不能帮小龙确定，最少翻转几次就可以使铁盘按从小到大排序呢？\n\n例如：下面的铁盘经过如图所示的以下几个步骤的翻转后变为从小到大排列。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xtpst1lw.png)", "inputFormat": "共两行。第一行为铁盘个数 $N$（$1 \\leq N \\leq 16$），第二行为 $N$ 个不同的正整数，分别为从上到下的铁盘的半径 $R$（$1 \\leq R \\leq 100$）。\n", "outputFormat": "一个正整数，表示使铁盘从小到大有序需要的最少翻转次数。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2535", "type": "P", "difficulty": 6, "samples": [["8 8 10\n1 1 3\n2 2 4\n3 3 5\n3 4 3\n4 3 2\n4 4 6\n5 5 7\n6 6 8", "28"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "各省省选", "安徽"], "title": "[AHOI2012] 收集资源", "background": "", "description": " ![](https://cdn.luogu.com.cn/upload/pic/1637.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/1638.png) \n\n", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1639.png)\n", "outputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1640.png)\n", "hint": "数据：\n\n50%: 1<=N,M,T<=100\n\n100%: 1<=N,M,T<=200\n", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2012] Collect Resources", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1637.png)\n![](https://cdn.luogu.com.cn/upload/pic/1638.png)", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1639.png)", "outputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1640.png)", "hint": "Constraints:\n- 50%: $1 \\le N, M, T \\le 100$.\n- 100%: $1 \\le N, M, T \\le 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2012] 收集资源", "background": "", "description": " ![](https://cdn.luogu.com.cn/upload/pic/1637.png) \n\n ![](https://cdn.luogu.com.cn/upload/pic/1638.png) \n\n", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1639.png)\n", "outputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1640.png)\n", "hint": "数据：\n\n50%: 1<=N,M,T<=100\n\n100%: 1<=N,M,T<=200\n", "locale": "zh-CN"}}}
{"pid": "P2536", "type": "P", "difficulty": 4, "samples": [["A*G?C\n3\nAGTC\nAGTGTC\nAGTGC", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "搜索", "2005", "各省省选", "安徽", "字典树 Trie", "AC 自动机"], "title": "[AHOI2005] 病毒检测", "background": null, "description": "科学家们在 Samuel 星球上的探险仍在继续。非常幸运的，在 Samuel 星球的南极附近，探险机器人发现了一个巨大的冰湖！机器人在这个冰湖中搜集到了许多 DNA 片段运回了实验基地。\n\n科学家们经过几个昼夜的研究，发现这些 DNA 片段中有许多是未知的病毒！\n\n每个 DNA 片段都是由 `A`、`C`、`T`、`G` 组成的序列。科学家们也总结出了 Samuel 星球上的“病毒模版片段”。一个模版片段是由 `A`、`C`、`T`、`G` 的序列加上通配符 `*` 和 `?` 来表示。其中 `*` 的意思是可以匹配上 $0$ 个或任意多个字符，而 `?` 的意思是匹配上任意一个字母。\n\n如果一个 DNA 片段能够和“病毒模版片段”相匹配，那么这个 DNA 片段就是未知的病毒。\n\n例如，假设 “病毒模版片段”为 `A*G?C`。DNA 片段：`AGTC`，`AGTGTC` 都是未知的病毒，而 DNA 片段 `AGTGC` 则不是病毒。\n\n由于，机器人搜集的这些 DNA 片段中除去病毒的其他部分都具有非常高的研究价值。所以科学家们希望能够分辨出其中哪些 DNA 片段不是病毒，并将不是病毒的 DNA 片段运回宇宙空间站继续进行研究。\n\n科学家将这项任务交给了小联。现在请你为小联编写程序统计哪些 DNA 片段不是病毒。", "inputFormat": "共 $N+2$ 行输入。\n\n第一行有一个字符串，由 `A`、`C`、`T`、`G`、`*`、`?` 组成，表示“病毒模版片段”。“病毒模版片段”的长度不超过 $1000$。\n\n第二行有一个整数 $N$，表示机器人搜集到的 DNA 片段的数目。\n\n随后的 $N$ 行，每一行有一个字符串，由 `A`、`C`、`T`、`G` 组成，表示一个 DNA 片段。", "outputFormat": "只有一行输出，为整数 $M$，即不是病毒的 DNA 片段的数目。", "hint": "输入中的 DNA 片段 `AGTGC` 不是病毒。\n\n对于所有数据，$0 < N < 500$。\n\n特别的：\n\n- 每个 DNA 片段的长度不超过 $500$；\n- “病毒模版片段”和 DNA 片段的长度都至少为 $1$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2005] Virus Detection", "background": "", "description": "The exploration on Planet Samuel continues. Very fortunately, near the south pole of Planet Samuel, the exploration robot discovered a huge ice lake! The robot collected many DNA fragments from this ice lake and sent them back to the research base.\n\nAfter several days and nights of research, scientists found that many of these DNA fragments belong to unknown viruses!\n\nEach DNA fragment is a sequence composed of `A`, `C`, `T`, and `G`. Scientists also summarized the \"virus template fragment\" on Planet Samuel. A template fragment is represented by a sequence of `A`, `C`, `T`, `G` plus wildcards `*` and `?`. Here, `*` means it can match $0$ or any number of characters, and `?` means it can match any single letter.\n\nIf a DNA fragment can match the \"virus template fragment\", then that DNA fragment is an unknown virus.\n\nFor example, suppose the \"virus template fragment\" is `A*G?C`. The DNA fragments `AGTC` and `AGTGTC` are viruses, while the DNA fragment `AGTGC` is not a virus.\n\nSince the non-virus parts among the DNA fragments collected by the robot are of very high research value, scientists want to identify which DNA fragments are not viruses and send those non-virus DNA fragments back to the space station for further research.\n\nThis task is assigned to Xiaolian (pinyin: Xiaolian). Please write a program to count which DNA fragments are not viruses.", "inputFormat": "There are $N+2$ lines of input.\n\nThe first line contains a string composed of `A`, `C`, `T`, `G`, `*`, and `?`, representing the \"virus template fragment\". The length of the \"virus template fragment\" does not exceed $1000$.\n\nThe second line contains an integer $N$, representing the number of DNA fragments collected by the robot.\n\nEach of the following $N$ lines contains a string composed of `A`, `C`, `T`, and `G`, representing a DNA fragment.", "outputFormat": "Output a single line with an integer $M$, which is the number of DNA fragments that are not viruses.", "hint": "The DNA fragment `AGTGC` in the input is not a virus.\n\nFor all testdata, $0 < N < 500$.\n\nIn particular:\n- The length of each DNA fragment does not exceed $500$.\n- The lengths of the \"virus template fragment\" and each DNA fragment are at least $1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2005] 病毒检测", "background": null, "description": "科学家们在 Samuel 星球上的探险仍在继续。非常幸运的，在 Samuel 星球的南极附近，探险机器人发现了一个巨大的冰湖！机器人在这个冰湖中搜集到了许多 DNA 片段运回了实验基地。\n\n科学家们经过几个昼夜的研究，发现这些 DNA 片段中有许多是未知的病毒！\n\n每个 DNA 片段都是由 `A`、`C`、`T`、`G` 组成的序列。科学家们也总结出了 Samuel 星球上的“病毒模版片段”。一个模版片段是由 `A`、`C`、`T`、`G` 的序列加上通配符 `*` 和 `?` 来表示。其中 `*` 的意思是可以匹配上 $0$ 个或任意多个字符，而 `?` 的意思是匹配上任意一个字母。\n\n如果一个 DNA 片段能够和“病毒模版片段”相匹配，那么这个 DNA 片段就是未知的病毒。\n\n例如，假设 “病毒模版片段”为 `A*G?C`。DNA 片段：`AGTC`，`AGTGTC` 都是未知的病毒，而 DNA 片段 `AGTGC` 则不是病毒。\n\n由于，机器人搜集的这些 DNA 片段中除去病毒的其他部分都具有非常高的研究价值。所以科学家们希望能够分辨出其中哪些 DNA 片段不是病毒，并将不是病毒的 DNA 片段运回宇宙空间站继续进行研究。\n\n科学家将这项任务交给了小联。现在请你为小联编写程序统计哪些 DNA 片段不是病毒。", "inputFormat": "共 $N+2$ 行输入。\n\n第一行有一个字符串，由 `A`、`C`、`T`、`G`、`*`、`?` 组成，表示“病毒模版片段”。“病毒模版片段”的长度不超过 $1000$。\n\n第二行有一个整数 $N$，表示机器人搜集到的 DNA 片段的数目。\n\n随后的 $N$ 行，每一行有一个字符串，由 `A`、`C`、`T`、`G` 组成，表示一个 DNA 片段。", "outputFormat": "只有一行输出，为整数 $M$，即不是病毒的 DNA 片段的数目。", "hint": "输入中的 DNA 片段 `AGTGC` 不是病毒。\n\n对于所有数据，$0 < N < 500$。\n\n特别的：\n\n- 每个 DNA 片段的长度不超过 $500$；\n- “病毒模版片段”和 DNA 片段的长度都至少为 $1$。", "locale": "zh-CN"}}}
{"pid": "P2537", "type": "P", "difficulty": 6, "samples": [["2\n1 3 3 \n2 1 4\n0 0 3 4", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "各省省选", "离散化", "安徽", "广度优先搜索 BFS", "最短路"], "title": "[AHOI2005] 穿越磁场", "background": null, "description": "探险机器人在 Samuel 星球上寻找一块奇特的矿石，然而此时它陷入了一片神秘的磁场区域，动弹不得。\n\n探险空间站立刻扫描了这片区域，绘制出该区域的磁场分布平面图。这片区域中分布了 $N$ 个磁场，每个磁场呈正方形，且边与坐标轴平行。\n\n例如下图中，存在 $3$ 个磁场，白点表示机器人的位置，黑点表示矿石的位置：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1642.png) \n\n科学家们分析平面图，进一步发现：这些磁场为大小不一的正方形，可能相交，甚至覆盖，但是它们的边缘不会重合，顶点也不会重合。\n\n例如下面的两种情形是不会出现的：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1643.png) \n\n科学家们给探险机器人启动了磁力罩，这样它就可以在磁场中自由穿越了。\n\n初始时，探险机器人和所有矿石都不在任何磁场的边缘。由于技术限制，在穿越过程中机器人只能够水平或垂直移动，且不能够沿着磁场的边缘行动。\n\n由于磁力罩的能量有限，科学家们希望探险机器人穿越尽量少的磁场边缘采集到这块矿石。例如上图中，探险机器人最少需要穿越两次磁场边缘。\n\n现在小联请你编写程序，帮助科学家们设计探险机器人的路线，统计探险机器人最少需要穿越多少次磁场边缘。", "inputFormat": "第一行有一个整数 $N$，表示有 $N$ 个磁场（$1 < N < 100$）。随后有 $N$ 行，每行有三个整数 $X,Y,C$（$0 < X ,Y ,C < 10000$），表示一个磁场左下角坐标为 $(X,Y)$，边长为 $C$。接下来有一行，共有四个整数 $SX, SY, TX, TY$，表示机器人初始坐标为 $(SX,SY)$，矿石坐标为 $(TX,TY)$（其中 $1 < SX, SY, TX, TY < 10000$）。", "outputFormat": "单行输出一个整数，表示机器人最少需要穿越多少次磁场边缘。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2005] Crossing Magnetic Fields", "background": "", "description": "An exploration robot is searching for a peculiar ore on planet Samuel, but it has become trapped in a mysterious magnetic field region and cannot move.\n\nThe exploration station immediately scanned the area and drew a planar map of the magnetic field distribution. There are $N$ magnetic fields in this region. Each magnetic field is a square whose sides are parallel to the coordinate axes.\n\nFor example, in the figure below, there are $3$ magnetic fields. The white dot is the robot’s position, and the black dot is the ore’s position:\n\n ![](https://cdn.luogu.com.cn/upload/pic/1642.png) \n\nAfter analyzing the map, scientists further found that these magnetic fields are squares of various sizes. They may intersect or even overlap, but their edges never coincide, and their vertices never coincide.\n\nFor example, the following two cases will not occur:\n\n ![](https://cdn.luogu.com.cn/upload/pic/1643.png) \n\nScientists activated a magnetic shield for the exploration robot so that it can move freely through the magnetic fields.\n\nInitially, neither the robot nor any ore lies on any magnetic field edge. Due to technical limitations, during traversal the robot can only move horizontally or vertically, and it cannot move along the edges of magnetic fields.\n\nBecause the magnetic shield’s energy is limited, the scientists hope the robot will cross as few magnetic field edges as possible to collect the ore. In the example above, the robot needs to cross edges at least twice.\n\nNow, please write a program to help the scientists design the robot’s route and compute the minimum number of magnetic field edges the robot must cross.", "inputFormat": "The first line contains an integer $N$, meaning there are $N$ magnetic fields ($1 < N < 100$). Then follow $N$ lines, each containing three integers $X, Y, C$ ($0 < X, Y, C < 10000$), indicating a magnetic field whose lower-left corner is $(X, Y)$ and whose side length is $C$. The next line contains four integers $SX, SY, TX, TY$, indicating that the robot’s initial coordinate is $(SX, SY)$ and the ore’s coordinate is $(TX, TY)$ (where $1 < SX, SY, TX, TY < 10000$).", "outputFormat": "Output a single integer on one line, the minimum number of magnetic field edges the robot needs to cross.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2005] 穿越磁场", "background": null, "description": "探险机器人在 Samuel 星球上寻找一块奇特的矿石，然而此时它陷入了一片神秘的磁场区域，动弹不得。\n\n探险空间站立刻扫描了这片区域，绘制出该区域的磁场分布平面图。这片区域中分布了 $N$ 个磁场，每个磁场呈正方形，且边与坐标轴平行。\n\n例如下图中，存在 $3$ 个磁场，白点表示机器人的位置，黑点表示矿石的位置：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1642.png) \n\n科学家们分析平面图，进一步发现：这些磁场为大小不一的正方形，可能相交，甚至覆盖，但是它们的边缘不会重合，顶点也不会重合。\n\n例如下面的两种情形是不会出现的：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1643.png) \n\n科学家们给探险机器人启动了磁力罩，这样它就可以在磁场中自由穿越了。\n\n初始时，探险机器人和所有矿石都不在任何磁场的边缘。由于技术限制，在穿越过程中机器人只能够水平或垂直移动，且不能够沿着磁场的边缘行动。\n\n由于磁力罩的能量有限，科学家们希望探险机器人穿越尽量少的磁场边缘采集到这块矿石。例如上图中，探险机器人最少需要穿越两次磁场边缘。\n\n现在小联请你编写程序，帮助科学家们设计探险机器人的路线，统计探险机器人最少需要穿越多少次磁场边缘。", "inputFormat": "第一行有一个整数 $N$，表示有 $N$ 个磁场（$1 < N < 100$）。随后有 $N$ 行，每行有三个整数 $X,Y,C$（$0 < X ,Y ,C < 10000$），表示一个磁场左下角坐标为 $(X,Y)$，边长为 $C$。接下来有一行，共有四个整数 $SX, SY, TX, TY$，表示机器人初始坐标为 $(SX,SY)$，矿石坐标为 $(TX,TY)$（其中 $1 < SX, SY, TX, TY < 10000$）。", "outputFormat": "单行输出一个整数，表示机器人最少需要穿越多少次磁场边缘。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2538", "type": "P", "difficulty": 6, "samples": [["5 0 1\n1 2 3 4 0\n1 1 1 1 1", "2"], ["3 1 1\n1 2 0\n1 2 3\n2", "1"], ["2 1 1  \n0 1  \n1 1  \n1 ", "0"], ["10 3 3\n0 2 0 0 2 2 8 3 8 7\n10 9 1 8 1 3 7 2 8 1\n3 4 6", "3"], ["2 0 1\n1 0\n5 10", "5"]], "limits": {"time": [800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "搜索", "2008", "四川", "各省省选", "基环树"], "title": "[SCOI2008] 城堡", "background": "2008NOI四川省选\n", "description": "在一个国家里，有 $n$ 个城市（编号为 $0$ 到 $n-1$）。这些城市之间有 $n$ 条双向道路相连（编号为 $0$ 到 $n-1$），其中编号为 $i$ 的道路连接了城市 $i$ 和城市 $r_i$（一条道路可以连接一个城市和它自身），长度为 $d_i$。$n$ 个城市中有 $m$ 个拥有自己城堡，可以抵御敌人侵略。如果没有城堡的城市遭受攻击，则离它最近的城堡将派兵前往救援。\n\n你的任务是在不超过 $k$ 个没有城堡的城市中建立城堡，使得所有城市中“离最近城堡的距离”的最大值尽量小。换句话说，若令 $dist(c)$ 表示城市 $c$ 的最近城堡离它的距离，则你的任务是让 $\\max\\{dist(c)\\}$ 尽量小。\n\n输入数据保证存在方案使得对于每个城市，至少有一个城堡能够到达。", "inputFormat": "输入第一行为三个正整数 $n, m, k$。第二行包含 $n$ 个整数 $r_0,r_1,\\ldots,r_{n-1}$。第三行包含 $n$ 个整数 $d_0,d_1,\\ldots,d_{n-1}$。第四行包含 $m$ 个各不相同的 $0$ 到 $n-1$ 之间的整数，分别为 $m$ 个城堡所在的城市编号。", "outputFormat": "输出仅一行，包含一个整数，即 $\\max\\{dist(c)\\}$ 的最小值。", "hint": "$100\\%$ 的数据满足: $2\\leq n\\leq 50$，$1\\leq d_i\\leq 10^6$，$0\\leq m\\leq n-k$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2008] Castle", "background": "2008 Sichuan NOI Qualifier.", "description": "In a country, there are $n$ cities (numbered $0$ to $n-1$). They are connected by $n$ bidirectional roads (numbered $0$ to $n-1$), where road $i$ connects city $i$ and city $r_i$ (a road may connect a city to itself) and has length $d_i$. Among the $n$ cities, $m$ of them have their own castles and can resist enemy invasions. If a city without a castle is attacked, the nearest castle will send troops to rescue it.\n\nYour task is to build castles in at most $k$ cities that currently do not have castles, so that the maximum among all cities of the distance to the nearest castle is as small as possible. In other words, let $dist(c)$ be the distance from city $c$ to its nearest castle; your task is to minimize $\\max\\{dist(c)\\}$.\n\nThe input guarantees that there exists a solution such that for every city, at least one castle can reach it.", "inputFormat": "The first line contains three positive integers $n, m, k$. The second line contains $n$ integers $r_0, r_1, \\ldots, r_{n-1}$. The third line contains $n$ integers $d_0, d_1, \\ldots, d_{n-1}$. The fourth line contains $m$ distinct integers between $0$ and $n-1$, which are the indices of the cities that have castles.", "outputFormat": "Output a single line containing one integer, the minimum value of $\\max\\{dist(c)\\}$.", "hint": "$100\\%$ of the testdata satisfies: $2 \\leq n \\leq 50$, $1 \\leq d_i \\leq 10^6$, $0 \\leq m \\leq n - k$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2008] 城堡", "background": "2008NOI四川省选\n", "description": "在一个国家里，有 $n$ 个城市（编号为 $0$ 到 $n-1$）。这些城市之间有 $n$ 条双向道路相连（编号为 $0$ 到 $n-1$），其中编号为 $i$ 的道路连接了城市 $i$ 和城市 $r_i$（一条道路可以连接一个城市和它自身），长度为 $d_i$。$n$ 个城市中有 $m$ 个拥有自己城堡，可以抵御敌人侵略。如果没有城堡的城市遭受攻击，则离它最近的城堡将派兵前往救援。\n\n你的任务是在不超过 $k$ 个没有城堡的城市中建立城堡，使得所有城市中“离最近城堡的距离”的最大值尽量小。换句话说，若令 $dist(c)$ 表示城市 $c$ 的最近城堡离它的距离，则你的任务是让 $\\max\\{dist(c)\\}$ 尽量小。\n\n输入数据保证存在方案使得对于每个城市，至少有一个城堡能够到达。", "inputFormat": "输入第一行为三个正整数 $n, m, k$。第二行包含 $n$ 个整数 $r_0,r_1,\\ldots,r_{n-1}$。第三行包含 $n$ 个整数 $d_0,d_1,\\ldots,d_{n-1}$。第四行包含 $m$ 个各不相同的 $0$ 到 $n-1$ 之间的整数，分别为 $m$ 个城堡所在的城市编号。", "outputFormat": "输出仅一行，包含一个整数，即 $\\max\\{dist(c)\\}$ 的最小值。", "hint": "$100\\%$ 的数据满足: $2\\leq n\\leq 50$，$1\\leq d_i\\leq 10^6$，$0\\leq m\\leq n-k$。", "locale": "zh-CN"}}}
{"pid": "P2539", "type": "P", "difficulty": 3, "samples": [["2\n2021010210001", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "各省省选", "安徽"], "title": "[AHOI2005] 矿藏编码", "background": "", "description": "探险机器人在 Samuel 星球发现了一片广阔的矿藏区。在这个矿藏区中，有高耸的山峰，也有平坦的平地。为了方便考察，整个矿藏区被划分 个格子区域。\n\n例如下图，就是一个 $K=2$ 即 $4 \\times 4$ 的矿藏区：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1646.png) \n\n其中黑色表示山峰，白色表示平地。\n\n探险空间站已经将这片矿藏区的详细信息扫描并记录下来。由于矿藏区的面积实在太大，所以科学家们采用了一种特殊的编码方式记录。\n\n- 如果这片矿藏区全部是平地，则编码为 `0`。\n- 如果这片矿藏区全部是山峰，则编码为 `1`。\n- 否则，将矿藏区均匀划分成 $4$ 份，如下 所示：\n     ![](https://cdn.luogu.com.cn/upload/pic/1647.png) \n\n依次对每份进行编码，得 $S_1,S_2,S_3,S_4$。该矿藏区的编码 $S$ 为 $2S_1S_2S_3S_4$。\n例如上图中，矿藏区的编码为：`2021010210001`。\n\n小联希望你能根据给定的编码统计出这片矿藏区一共有多少格子区域是平地。\n", "inputFormat": "第一行有一个整数K，表示有矿藏区的规模为 $K$（$1 < K < 50$）。\n\n第二行有一串编码，由  `0`、`1` 组成，长度不超过 $200$，表示该矿藏区的编码。", "outputFormat": "单行输出一个整数，表示矿藏区中一共有多少格子是平地。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2005] Mine Encoding", "background": "", "description": "An exploration robot discovered an extensive mining area on planet Samuel. In this mining area, there are towering mountains and flat plains. To facilitate survey, the entire mining area is divided into $2^K \\times 2^K$ grid cells.\n\nFor example, as shown below, when $K=2$, the mining area is a $4 \\times 4$ grid:\n\n ![](https://cdn.luogu.com.cn/upload/pic/1646.png) \n\nBlack denotes mountains, and white denotes plains.\n\nThe exploration space station has scanned and recorded detailed information about this mining area. Because the area is extremely large, the scientists use a special encoding method to record it.\n\n- If the entire mining area is plains, the code is `0`.\n- If the entire mining area is mountains, the code is `1`.\n- Otherwise, divide the mining area evenly into 4 parts, as shown below:\n     ![](https://cdn.luogu.com.cn/upload/pic/1647.png) \n\nEncode each part in order to obtain $S_1,S_2,S_3,S_4$. The code $S$ of the mining area is $2S_1S_2S_3S_4$.\nFor example, in the figure above, the code of the mining area is: `2021010210001`.\n\nXiaolian hopes you can, based on the given code, count how many grid cells in this mining area are plains.", "inputFormat": "The first line contains an integer $K$, indicating the size parameter $K$ of the mining area ($1 < K < 50$).\n\nThe second line contains a code string composed of `0`, `1`, `2`, with length at most $200$, representing the code of the mining area.", "outputFormat": "Output a single integer, representing how many grid cells in the mining area are plains.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2005] 矿藏编码", "background": "", "description": "探险机器人在 Samuel 星球发现了一片广阔的矿藏区。在这个矿藏区中，有高耸的山峰，也有平坦的平地。为了方便考察，整个矿藏区被划分 个格子区域。\n\n例如下图，就是一个 $K=2$ 即 $4 \\times 4$ 的矿藏区：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1646.png) \n\n其中黑色表示山峰，白色表示平地。\n\n探险空间站已经将这片矿藏区的详细信息扫描并记录下来。由于矿藏区的面积实在太大，所以科学家们采用了一种特殊的编码方式记录。\n\n- 如果这片矿藏区全部是平地，则编码为 `0`。\n- 如果这片矿藏区全部是山峰，则编码为 `1`。\n- 否则，将矿藏区均匀划分成 $4$ 份，如下 所示：\n     ![](https://cdn.luogu.com.cn/upload/pic/1647.png) \n\n依次对每份进行编码，得 $S_1,S_2,S_3,S_4$。该矿藏区的编码 $S$ 为 $2S_1S_2S_3S_4$。\n例如上图中，矿藏区的编码为：`2021010210001`。\n\n小联希望你能根据给定的编码统计出这片矿藏区一共有多少格子区域是平地。\n", "inputFormat": "第一行有一个整数K，表示有矿藏区的规模为 $K$（$1 < K < 50$）。\n\n第二行有一串编码，由  `0`、`1` 组成，长度不超过 $200$，表示该矿藏区的编码。", "outputFormat": "单行输出一个整数，表示矿藏区中一共有多少格子是平地。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2540", "type": "P", "difficulty": 6, "samples": [["1 8\n7 4\n8 4\n9 1\n10 4\n11 1\n5 1\n1 4\n1 1", "3"], ["1 17\n12 3\n4 3\n2 3\n5 4\n10 2\n3 3\n12 2\n0 1\n1 3\n10 1\n6 2\n12 1\n11 3\n5 2\n12 4\n2 2\n7 2", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "2015", "NOIP 提高组", "广度优先搜索 BFS", "深度优先搜索 DFS", "剪枝", "启发式迭代加深搜索 IDA*"], "title": "[NOIP 2015 提高组] 斗地主 加强版", "background": "", "description": "牛牛最近迷上了一种叫斗地主的扑克游戏。斗地主是一种使用黑桃、红心、梅花、方片的 $A$ 到 $K$ 加上大小王的共 $54$ 张牌来进行的扑克牌游戏。在斗地主中，牌的大小关系根据牌的数码表示如下：$3<4<5<6<7<8<9<10<J<Q<K<A<2<\\text{小王}<\\text{大王}$，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由 $n$ 张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。\n\n现在，牛牛只想知道，对于自己的若干组手牌，分别最少需要多少次出牌可以将它们打光。请你帮他解决这个问题。\n\n需要注意的是，本题中游戏者每次可以出手的牌型与一般的斗地主相似而略有不同。具体规则如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1827.png) \n\n**在此题中认为两个王不能组成对子牌**。\n", "inputFormat": "第一行包含用空格隔开的 $2$ 个正整数 $T,n$，表示手牌的组数以及每组手牌的张数。\n\n接下来 $T$ 组数据，每组数据 $n$ 行，每行一个非负整数对 $a_i,b_i$，表示一张牌，其中 $a_i$ 表示牌的数码，$b_i$ 表示牌的花色，中间用空格隔开。特别的，我们用 $1$ 来表示数码 $A$，$11$ 表示数码 $J$，$12$ 表示数码 $Q$，$13$ 表示数码 $K$；黑桃、红心、梅花、方片分别用 $1-4$ 来表示；小王的表示方法为 `0 1`，大王的表示方法为 `0 2`。", "outputFormat": "共 $T$ 行，每行一个整数，表示打光第 $i$ 手牌的最少次数。\n", "hint": "#### 样例 1 说明\n\n共有 $1$ 组手牌，包含 $8$ 张牌：方片 $7$，方片 $8$，黑桃 $9$，方片 $10$，黑桃 $J$，黑桃 $5$，方片 $A$ 以及黑桃 $A$。可以通过打单顺子（方片 $7$，方片 $8$，黑桃 $9$，方片 $10$，黑桃 $J$），单张牌（黑桃 $5$）以及对子牌（黑桃 $A$ 以及方片 $A$）在 $3$ 次内打光。\n\n#### 数据范围与提示\n\n对于前 $20$ 个测试点， 我们约定手牌组数 $T$ 与张数 $n$ 的规模如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1828.png) \n\n数据不保证所有的手牌都是随机生成的。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2015 Senior] Dou Dizhu Enhanced Version", "background": "", "description": "Niuniu has recently become obsessed with a card game called Dou Dizhu. Dou Dizhu is a poker game played with a deck of $54$ cards: $A$ through $K$ in Spades, Hearts, Clubs, and Diamonds, plus the two Jokers. In Dou Dizhu, the card ranks are ordered by their numbers as follows: $3<4<5<6<7<8<9<10<J<Q<K<A<2<\\text{小王}<\\text{大王}$, and suits do not affect card strength. In each game, a hand consists of $n$ cards. Each turn, a player may play cards according to certain allowed patterns. The side that first plays out all cards wins.\n\nNow, Niuniu only wants to know, for several of his hands, the minimum number of plays needed to play out all the cards in each hand. Please help him solve this problem.\n\nNote that in this problem, the set of playable patterns per move is similar to standard Dou Dizhu but slightly different. The specific rules are as follows:\n\n ![](https://cdn.luogu.com.cn/upload/pic/1827.png) \n\n**In this problem, the two Jokers cannot form a pair.**", "inputFormat": "The first line contains $2$ positive integers $T, n$ separated by a space, representing the number of hands and the number of cards in each hand.\n\nThen follow $T$ groups of data. For each group, there are $n$ lines, each containing a pair of non-negative integers $a_i, b_i$, representing one card, where $a_i$ is the card rank and $b_i$ is the suit, separated by a space. Specifically, we use $1$ to represent rank $A$, $11$ for $J$, $12$ for $Q$, and $13$ for $K$; Spades, Hearts, Clubs, and Diamonds are represented by $1$–$4$ respectively; the small Joker is represented as `0 1`, and the big Joker as `0 2`.", "outputFormat": "Output $T$ lines. Each line contains one integer, the minimum number of plays needed to play out the $i$-th hand.", "hint": "#### Sample 1 Explanation\n\nThere is $1$ hand containing $8$ cards: Diamonds $7$, Diamonds $8$, Spades $9$, Diamonds $10$, Spades $J$, Spades $5$, Diamonds $A$, and Spades $A$. You can play them out in $3$ moves by playing a single straight (Diamonds $7$, Diamonds $8$, Spades $9$, Diamonds $10$, Spades $J$), a single card (Spades $5$), and a pair (Spades $A$ and Diamonds $A$).\n\n#### Constraints and Notes\n\nFor the first $20$ test points, the scales of the number of hands $T$ and the number of cards $n$ are as follows:\n\n ![](https://cdn.luogu.com.cn/upload/pic/1828.png) \n\nThe testdata does not guarantee that all hands are randomly generated.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2015 提高组] 斗地主 加强版", "background": "", "description": "牛牛最近迷上了一种叫斗地主的扑克游戏。斗地主是一种使用黑桃、红心、梅花、方片的 $A$ 到 $K$ 加上大小王的共 $54$ 张牌来进行的扑克牌游戏。在斗地主中，牌的大小关系根据牌的数码表示如下：$3<4<5<6<7<8<9<10<J<Q<K<A<2<\\text{小王}<\\text{大王}$，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由 $n$ 张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。\n\n现在，牛牛只想知道，对于自己的若干组手牌，分别最少需要多少次出牌可以将它们打光。请你帮他解决这个问题。\n\n需要注意的是，本题中游戏者每次可以出手的牌型与一般的斗地主相似而略有不同。具体规则如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1827.png) \n\n**在此题中认为两个王不能组成对子牌**。\n", "inputFormat": "第一行包含用空格隔开的 $2$ 个正整数 $T,n$，表示手牌的组数以及每组手牌的张数。\n\n接下来 $T$ 组数据，每组数据 $n$ 行，每行一个非负整数对 $a_i,b_i$，表示一张牌，其中 $a_i$ 表示牌的数码，$b_i$ 表示牌的花色，中间用空格隔开。特别的，我们用 $1$ 来表示数码 $A$，$11$ 表示数码 $J$，$12$ 表示数码 $Q$，$13$ 表示数码 $K$；黑桃、红心、梅花、方片分别用 $1-4$ 来表示；小王的表示方法为 `0 1`，大王的表示方法为 `0 2`。", "outputFormat": "共 $T$ 行，每行一个整数，表示打光第 $i$ 手牌的最少次数。\n", "hint": "#### 样例 1 说明\n\n共有 $1$ 组手牌，包含 $8$ 张牌：方片 $7$，方片 $8$，黑桃 $9$，方片 $10$，黑桃 $J$，黑桃 $5$，方片 $A$ 以及黑桃 $A$。可以通过打单顺子（方片 $7$，方片 $8$，黑桃 $9$，方片 $10$，黑桃 $J$），单张牌（黑桃 $5$）以及对子牌（黑桃 $A$ 以及方片 $A$）在 $3$ 次内打光。\n\n#### 数据范围与提示\n\n对于前 $20$ 个测试点， 我们约定手牌组数 $T$ 与张数 $n$ 的规模如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1828.png) \n\n数据不保证所有的手牌都是随机生成的。\n", "locale": "zh-CN"}}}
{"pid": "P2541", "type": "P", "difficulty": 6, "samples": [["3 10\n4 1 5 3 10\n3 2 3 3\n5 1 3 4 6 6", "61"]], "limits": {"time": [3000, 1000, 1000, 1000, 1000, 1000, 2000, 1000, 1000, 1000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2016", "USACO", "Ad-hoc"], "title": "[USACO16DEC] Robotic Cow Herd P", "background": "", "description": "Bessie is hoping to fool Farmer John by building a herd of $K$ realistic robotic cows ($1 \\leq K \\leq 100,000$).\n\nIt turns out that building a robotic cow is somewhat complicated. There are $N$ ($1 \\leq n \\leq 100,000$) individual locations on the robot into which microcontrollers must be connected (so a single microcontroller must be connected at each location). For each of these locations, Bessie can select from a number of different models of microcontroller, each varying in cost.\n\nFor the herd of robotic cows to look convincing to Farmer John, no two robots should behave identically. Therefore, no two robots should have exactly the same set of microcontrollers. For any pair of robots, there should be at least one location at which the two robots use a different microcontroller model. It is guaranteed that there will always be enough different microcontroller models to satisfy this constraint.\n\nBessie wants to make her robotic herd as cheaply as possible. Help her determine the minimum possible cost to do this!", "inputFormat": "The first line of input contains $N$ and $K$ separated by a space.\n\nThe following $N$ lines contain a description of the different microcontroller models available for each location. The $i$th such line starts with $M_i$ ($1 \\leq M_i \\leq 10$), giving the number of models available for location $i$. This is followed by $M_i$ space separated integers $P_{i,j}$ giving the costs of these different models ($1 \\le P_{i,j} \\le 100,000,000$).", "outputFormat": "Output a single line, giving the minimum cost to construct $K$ robots.", "hint": "", "locale": "en", "translations": {"en": {"title": "[USACO16DEC] Robotic Cow Herd P", "background": "", "description": "Bessie is hoping to fool Farmer John by building a herd of $K$ realistic robotic cows ($1 \\leq K \\leq 100,000$).\n\nIt turns out that building a robotic cow is somewhat complicated. There are $N$ ($1 \\leq n \\leq 100,000$) individual locations on the robot into which microcontrollers must be connected (so a single microcontroller must be connected at each location). For each of these locations, Bessie can select from a number of different models of microcontroller, each varying in cost.\n\nFor the herd of robotic cows to look convincing to Farmer John, no two robots should behave identically. Therefore, no two robots should have exactly the same set of microcontrollers. For any pair of robots, there should be at least one location at which the two robots use a different microcontroller model. It is guaranteed that there will always be enough different microcontroller models to satisfy this constraint.\n\nBessie wants to make her robotic herd as cheaply as possible. Help her determine the minimum possible cost to do this!", "inputFormat": "The first line of input contains $N$ and $K$ separated by a space.\n\nThe following $N$ lines contain a description of the different microcontroller models available for each location. The $i$th such line starts with $M_i$ ($1 \\leq M_i \\leq 10$), giving the number of models available for location $i$. This is followed by $M_i$ space separated integers $P_{i,j}$ giving the costs of these different models ($1 \\le P_{i,j} \\le 100,000,000$).", "outputFormat": "Output a single line, giving the minimum cost to construct $K$ robots.", "hint": "", "locale": "en"}, "zh-CN": {"title": "[USACO16DEC] Robotic Cow Herd P", "background": "", "description": "Bessie 希望通过建造 $K$ 头逼真的机器人奶牛（$1 \\leq K \\leq 100,000$）来愚弄 Farmer John。\n\n事实证明，建造一头机器人奶牛有些复杂。机器人上有 $N$ 个（$1 \\leq N \\leq 100,000$）独立的位置需要连接微控制器（因此每个位置必须连接一个微控制器）。对于每个位置，Bessie 可以从多个不同的微控制器模型中选择，每个模型的成本各不相同。\n\n为了让机器人牛群对 Farmer John 看起来逼真，任何两头机器人的行为都不应完全相同。因此，任何两头机器人都不应使用完全相同的微控制器集合。对于任意一对机器人，至少应有一个位置上的微控制器模型不同。保证始终有足够的不同微控制器模型来满足此约束。\n\nBessie 希望以尽可能低的成本建造她的机器人牛群。请帮助她确定实现这一目标的最小可能成本！", "inputFormat": "输入的第一行包含用空格分隔的 $N$ 和 $K$。\n\n接下来的 $N$ 行描述了每个位置可用的不同微控制器模型。第 $i$ 行以 $M_i$（$1 \\leq M_i \\leq 10$）开头，表示位置 $i$ 可用的模型数量。随后是 $M_i$ 个用空格分隔的整数 $P_{i,j}$，表示这些不同模型的成本（$1 \\le P_{i,j} \\le 100,000,000$）。", "outputFormat": "输出一行，表示建造 $K$ 头机器人的最小成本。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2542", "type": "P", "difficulty": 6, "samples": [["5 5\n1 2\n1 3\n3 4\n4 5\n4 2\n1 1 5\n0 4 2\n1 5 1\n-1", "1\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "线段树", "各省省选", "安徽", "O2优化", "最近公共祖先 LCA", "树链剖分"], "title": "[AHOI2005] 航线规划", "background": "", "description": "对 Samuel 星球的探险已经取得了非常巨大的成就，于是科学家们将目光投向了 Samuel 星球所在的星系——一个巨大的由千百万星球构成的 Samuel 星系。\n\n星际空间站的 Samuel II 巨型计算机经过长期探测，已经锁定了 Samuel 星系中 $n$ 个星球的空间坐标，并对这些星球以 $1$ 至 $n$ 依次编号。\n\n一些先遣飞船已经出发，在星球之间开辟探险航线。\n\n探险航线是双向的，例如从 $1$ 号星球到 $3$ 号星球开辟探险航线，那么从 $3$ 号星球到 $1$ 号星球也可以使用这条航线。\n\n例如下图所示：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1644.png) \n\n在 $5$ 个星球之间，有 $5$ 条探险航线。\n\n$A,B$ 两星球之间，如果某条航线不存在，就无法从 $A$ 星球抵达 $B$ 星球，我们则称这条航线为关键航线。\n\n显然上图中，$1$ 号与 $5$ 号星球之间的关键航线有 $1$ 条：即为 $4\\leftrightarrow5$ 航线。\n\n然而，在宇宙中一些未知的磁暴和行星的冲撞，使得已有的某些航线被破坏，随着越来越多的航线被破坏，探险飞船又不能及时恢复这些航线，可见两个星球之间的关键航线会越来越多。\n\n假设在上图中，航线 $4\\leftrightarrow2$（从 $4$ 号星球到 $2$ 号星球）被破坏。此时，$1$ 号与 $5$ 号星球之间的关键航线就有 $3$ 条：$1 \\leftrightarrow 3$，$3 \\leftrightarrow 4$，$4 \\leftrightarrow 5$。\n\n小联的任务是，不断关注航线被破坏的情况，并随时给出两个星球之间的关键航线数目。现在请你帮助完成。\n", "inputFormat": "第一行有两个整数，分别表示星球个数 $n$ 和初始时的航线条数 $m$。\n\n接下来 $m$ 行，每行有两个不相同的整数 $u, v$，表示星球 $u$ 和星球 $v$ 之间存在一条航线。\n\n接下来有若干行，每行首先给出一个整数 $op$，表示一次操作的类型。\n\n- 若 $op = 1$，则后接两个整数 $u, v$，表示询问当前 $u, v$ 两星球之间有多少关键航线。\n- 若 $op = 0$，则后接两个整数 $u, v$，表示 $u, v$ 之间的航线被破坏。\n- 若 $op = -1$，则表示输入结束，后面不再存在操作。\n", "outputFormat": "对每个 $op = 1$ 的询问，输出一行一个整数表示关键航线数目。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq n \\leq 3 \\times 10^4$，$1 \\leq m \\leq 10^5$。\n- $-1 \\leq op \\leq 1$，$1 \\leq u, v \\leq n$。\n- 无论航线如何被破坏，任意时刻任意两个星球都能够相互到达。在整个数据中，任意两个星球之间最多只可能存在一条直接的航线。\n- 对于 $op = 0$ 的操作，保证操作前航线 $u \\leftrightarrow v$ 存在。\n- 询问与破坏航线的总次数不超过 $4 \\times 10^4$。\n\nUpdate :2025.6.27 添加一组数据。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2005] Route Planning", "background": "", "description": "Exploration of planet Samuel has achieved great success, so scientists turned their attention to the galaxy where planet Samuel resides—a vast Samuel Galaxy composed of hundreds of millions of planets.\n\nAfter long-term probing, the Samuel II supercomputer of the interstellar space station has located the spatial coordinates of $n$ planets in the Samuel Galaxy and numbered these planets from $1$ to $n$.\n\nSome advance spacecraft have set out and opened exploration routes between planets.\n\nExploration routes are bidirectional. For example, if an exploration route is opened from planet $1$ to planet $3$, then the route can also be used from planet $3$ to planet $1$.\n\nFor example, see the figure below:\n\n ![](https://cdn.luogu.com.cn/upload/pic/1644.png) \n\nAmong $5$ planets, there are $5$ exploration routes.\n\nFor two planets $A$ and $B$, if removing a certain route makes it impossible to travel from planet $A$ to planet $B$, we call that route a critical route.\n\nObviously, in the figure above, there is $1$ critical route between planets $1$ and $5$: that is, the $4 \\leftrightarrow 5$ route.\n\nHowever, due to unknown magnetic storms and planetary collisions in the universe, some existing routes are damaged. As more and more routes are destroyed and exploration ships cannot repair them in time, the number of critical routes between two planets will increase.\n\nSuppose in the figure above, the route $4 \\leftrightarrow 2$ (from planet $4$ to planet $2$) is destroyed. At this time, there are $3$ critical routes between planets $1$ and $5$: $1 \\leftrightarrow 3$, $3 \\leftrightarrow 4$, and $4 \\leftrightarrow 5$.\n\nXiao Lian’s task is to continuously monitor route destructions and report, at any time, the number of critical routes between two planets. Please help complete this task.", "inputFormat": "The first line contains two integers, representing the number of planets $n$ and the initial number of routes $m$.\n\nThe next $m$ lines each contain two distinct integers $u, v$, indicating that there is a route between planet $u$ and planet $v$.\n\nThen follow several lines. Each line first gives an integer $op$, indicating the type of an operation.\n\n- If $op = 1$, then two integers $u, v$ follow, asking how many critical routes currently exist between planets $u$ and $v$.\n- If $op = 0$, then two integers $u, v$ follow, indicating that the route between $u$ and $v$ is destroyed.\n- If $op = -1$, the input ends and no further operations follow.", "outputFormat": "For each query with $op = 1$, output one integer on a separate line indicating the number of critical routes.", "hint": "Constraints and Conventions\n\n- $1 \\leq n \\leq 3 \\times 10^4$, $1 \\leq m \\leq 10^5$.\n- $-1 \\leq op \\leq 1$, $1 \\leq u, v \\leq n$.\n- Regardless of how routes are destroyed, at any time any two planets can reach each other. In the entire testdata, between any two planets there is at most one direct route.\n- For operations with $op = 0$, it is guaranteed that the route $u \\leftrightarrow v$ exists before the operation.\n- The total number of queries and route destructions does not exceed $4 \\times 10^4$.\n\nUpdate: 2025.6.27 Added one set of testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2005] 航线规划", "background": "", "description": "对 Samuel 星球的探险已经取得了非常巨大的成就，于是科学家们将目光投向了 Samuel 星球所在的星系——一个巨大的由千百万星球构成的 Samuel 星系。\n\n星际空间站的 Samuel II 巨型计算机经过长期探测，已经锁定了 Samuel 星系中 $n$ 个星球的空间坐标，并对这些星球以 $1$ 至 $n$ 依次编号。\n\n一些先遣飞船已经出发，在星球之间开辟探险航线。\n\n探险航线是双向的，例如从 $1$ 号星球到 $3$ 号星球开辟探险航线，那么从 $3$ 号星球到 $1$ 号星球也可以使用这条航线。\n\n例如下图所示：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1644.png) \n\n在 $5$ 个星球之间，有 $5$ 条探险航线。\n\n$A,B$ 两星球之间，如果某条航线不存在，就无法从 $A$ 星球抵达 $B$ 星球，我们则称这条航线为关键航线。\n\n显然上图中，$1$ 号与 $5$ 号星球之间的关键航线有 $1$ 条：即为 $4\\leftrightarrow5$ 航线。\n\n然而，在宇宙中一些未知的磁暴和行星的冲撞，使得已有的某些航线被破坏，随着越来越多的航线被破坏，探险飞船又不能及时恢复这些航线，可见两个星球之间的关键航线会越来越多。\n\n假设在上图中，航线 $4\\leftrightarrow2$（从 $4$ 号星球到 $2$ 号星球）被破坏。此时，$1$ 号与 $5$ 号星球之间的关键航线就有 $3$ 条：$1 \\leftrightarrow 3$，$3 \\leftrightarrow 4$，$4 \\leftrightarrow 5$。\n\n小联的任务是，不断关注航线被破坏的情况，并随时给出两个星球之间的关键航线数目。现在请你帮助完成。\n", "inputFormat": "第一行有两个整数，分别表示星球个数 $n$ 和初始时的航线条数 $m$。\n\n接下来 $m$ 行，每行有两个不相同的整数 $u, v$，表示星球 $u$ 和星球 $v$ 之间存在一条航线。\n\n接下来有若干行，每行首先给出一个整数 $op$，表示一次操作的类型。\n\n- 若 $op = 1$，则后接两个整数 $u, v$，表示询问当前 $u, v$ 两星球之间有多少关键航线。\n- 若 $op = 0$，则后接两个整数 $u, v$，表示 $u, v$ 之间的航线被破坏。\n- 若 $op = -1$，则表示输入结束，后面不再存在操作。\n", "outputFormat": "对每个 $op = 1$ 的询问，输出一行一个整数表示关键航线数目。\n", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq n \\leq 3 \\times 10^4$，$1 \\leq m \\leq 10^5$。\n- $-1 \\leq op \\leq 1$，$1 \\leq u, v \\leq n$。\n- 无论航线如何被破坏，任意时刻任意两个星球都能够相互到达。在整个数据中，任意两个星球之间最多只可能存在一条直接的航线。\n- 对于 $op = 0$ 的操作，保证操作前航线 $u \\leftrightarrow v$ 存在。\n- 询问与破坏航线的总次数不超过 $4 \\times 10^4$。\n\nUpdate :2025.6.27 添加一组数据。", "locale": "zh-CN"}}}
{"pid": "P2543", "type": "P", "difficulty": 3, "samples": [["01010101010 00000011111", "6"], ["01011 010010101111111111", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2004", "各省省选", "安徽"], "title": "[AHOI2004] 奇怪的字符串", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1654.png)\n", "inputFormat": "输入文件中包含两个字符串X和Y。当中两字符串非0即1。序列长度均小于9999。\n", "outputFormat": "X和Y的最长公共子序列长度。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2004] Strange String", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1654.png)", "inputFormat": "The input file contains two strings X and Y. Both strings consist only of 0 and 1. The length of each string is less than 9999.", "outputFormat": "Output the length of the longest common subsequence of X and Y.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2004] 奇怪的字符串", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1654.png)\n", "inputFormat": "输入文件中包含两个字符串X和Y。当中两字符串非0即1。序列长度均小于9999。\n", "outputFormat": "X和Y的最长公共子序列长度。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2544", "type": "P", "difficulty": 6, "samples": [["1 2 99", "2"], ["9 1 999", "22"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2004", "各省省选", "递归", "安徽", "Fibonacci 数列"], "title": "[AHOI2004] 数字迷阵", "background": null, "description": "小可可参观科学博物馆时，看到一件藏品，上面有密密麻麻的数字，如下所示：\n\n```text\n\n1   2   3   5   8    13   21   34   55   89   144  …\n4   7   11  18  29   47   76   123  199  322  521  …\n6   10  16  26  42   68   110  178  288  466  754  …\n9   15  24  39  63   102  165  267  432  699  1131 …\n12  20  32  52  84   136  220  356  576  932  1508 …\n14  23  37  60  97   157  254  411  665  1076 1741 …\n17  28  45  73  118  191  309  500  809  1309 2118 …\n19  31  50  81  131  212  343  555  898  1453 2351 …\n22  36  58  94  152  246  398  644  1042 1686 2728 …\n25  41  66  107 173  280  453  733  1186 1919 3105 …\n27  44  71  115 186  301  487  788  1275 2063 3338 …\n…\n\n```\n\n仔细一分析，发现还挺有规律。\n\n原来，**第一行是 Fibonacci 数列**。即，该行中除了第一个和第二个数分别为 1 和 2 之外，其他数都是其左侧相邻的两个数之和。\n\n其后各行也类似于 Fibonacci 数列。只是第 $i$ 行的第一个数是前 $i-1$ 行中未出现的最小正整数，而其第二个数与该行第一个数以及所在行的编号 $i$ 相关，即\n\n$$\nA[i,2] = 2A[i,1] - (i - 1).\n$$\n\n如在第一行中未出现的最小正整数为 4，前三行中未出现的最小正整数为 9。故第二行以 4 和 7 开头，而第四行以 9 和 15 开头。\n\n小可可高兴地把这个发现告诉了爷爷。爷爷问道：**你能否一口报出第 $i$ 行、第 $j$ 列的那个数对 $m$ 取模的结果是多少呢？**  \n聪明的小可可通过心算就能知道答案。你是否能编写程序求解呢？", "inputFormat": "输入一行三个正整数 $i,j,m$。", "outputFormat": "输出一行一个正整数，表示对应的第 $i$ 行，第 $j$ 列的那个正整数对 $m$ 取模的结果。", "hint": "对于所有数据，$i,j\\le10^9,2\\le m\\le10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2004] Number Maze", "background": "", "description": "When Xiao Keke visited the science museum, she saw an exhibit covered with dense numbers, as shown below:\n\n```text\n\n1   2   3   5   8    13   21   34   55   89   144  …\n4   7   11  18  29   47   76   123  199  322  521  …\n6   10  16  26  42   68   110  178  288  466  754  …\n9   15  24  39  63   102  165  267  432  699  1131 …\n12  20  32  52  84   136  220  356  576  932  1508 …\n14  23  37  60  97   157  254  411  665  1076 1741 …\n17  28  45  73  118  191  309  500  809  1309 2118 …\n19  31  50  81  131  212  343  555  898  1453 2351 …\n22  36  58  94  152  246  398  644  1042 1686 2728 …\n25  41  66  107 173  280  453  733  1186 1919 3105 …\n27  44  71  115 186  301  487  788  1275 2063 3338 …\n…\n\n```\n\nAfter some analysis, she found a clear pattern.\n\nIt turns out that the first row is the Fibonacci sequence. That is, in this row, except for the first and second numbers which are 1 and 2 respectively, every other number is the sum of the two numbers immediately to its left.\n\nThe subsequent rows are also similar to the Fibonacci sequence. The first number of row $i$ is the smallest positive integer that has not appeared in the previous $i - 1$ rows, and the second number of that row is related to the first number and the row index $i$, namely\n$$\nA[i,2] = 2A[i,1] - (i - 1).\n$$\n\nFor example, the smallest positive integer not appearing in the first row is 4, and the smallest positive integer not appearing in the first three rows is 9. Therefore, the second row begins with 4 and 7, and the fourth row begins with 9 and 15.\n\nXiao Keke happily told her grandfather about this discovery. Grandpa asked: Can you immediately tell, for the number at row $i$ and column $j$, what its value modulo $m$ is?  \nClever Xiao Keke can figure it out mentally. Can you write a program to compute it?", "inputFormat": "A single line containing three positive integers $i, j, m$.", "outputFormat": "Output a single line with one positive integer: the value of the number at row $i$ and column $j$ modulo $m$.", "hint": "Constraints: For all testdata, $i, j \\le 10^9$, $2 \\le m \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2004] 数字迷阵", "background": null, "description": "小可可参观科学博物馆时，看到一件藏品，上面有密密麻麻的数字，如下所示：\n\n```text\n\n1   2   3   5   8    13   21   34   55   89   144  …\n4   7   11  18  29   47   76   123  199  322  521  …\n6   10  16  26  42   68   110  178  288  466  754  …\n9   15  24  39  63   102  165  267  432  699  1131 …\n12  20  32  52  84   136  220  356  576  932  1508 …\n14  23  37  60  97   157  254  411  665  1076 1741 …\n17  28  45  73  118  191  309  500  809  1309 2118 …\n19  31  50  81  131  212  343  555  898  1453 2351 …\n22  36  58  94  152  246  398  644  1042 1686 2728 …\n25  41  66  107 173  280  453  733  1186 1919 3105 …\n27  44  71  115 186  301  487  788  1275 2063 3338 …\n…\n\n```\n\n仔细一分析，发现还挺有规律。\n\n原来，**第一行是 Fibonacci 数列**。即，该行中除了第一个和第二个数分别为 1 和 2 之外，其他数都是其左侧相邻的两个数之和。\n\n其后各行也类似于 Fibonacci 数列。只是第 $i$ 行的第一个数是前 $i-1$ 行中未出现的最小正整数，而其第二个数与该行第一个数以及所在行的编号 $i$ 相关，即\n\n$$\nA[i,2] = 2A[i,1] - (i - 1).\n$$\n\n如在第一行中未出现的最小正整数为 4，前三行中未出现的最小正整数为 9。故第二行以 4 和 7 开头，而第四行以 9 和 15 开头。\n\n小可可高兴地把这个发现告诉了爷爷。爷爷问道：**你能否一口报出第 $i$ 行、第 $j$ 列的那个数对 $m$ 取模的结果是多少呢？**  \n聪明的小可可通过心算就能知道答案。你是否能编写程序求解呢？", "inputFormat": "输入一行三个正整数 $i,j,m$。", "outputFormat": "输出一行一个正整数，表示对应的第 $i$ 行，第 $j$ 列的那个正整数对 $m$ 取模的结果。", "hint": "对于所有数据，$i,j\\le10^9,2\\le m\\le10^4$。", "locale": "zh-CN"}}}
{"pid": "P2545", "type": "P", "difficulty": 3, "samples": [["4\n-1 2 -3 4\n5 6 7 8", "31"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2004", "各省省选", "安徽"], "title": "[AHOI2004] 实验基地", "background": null, "description": "经过不懈努力，我国科学家将正式启动 Samuel 星球研究计划。目前阶段的任务是采用飞船将智能机器人运送到该星球以建立临时实验基地进行深入的科学探索实验。为了激发广大学生的科学兴趣，科学家们还在全球范围内设立学生研究组（简称 SRT）。经过层层选拔，小可可终于入选该研究组。\n\n科学家前辈们交给小可可一项简单的运筹任务：\n\n在前期的绕 Samuel 星球探测计划中，发现该星球有若干处狭长的平坦地带可以用于登陆（亦称为“登陆地带”）。科学家们计划在登陆地带上建立实验基地。但是，并不是任何登陆地带都适宜建立实验基地。\n\n为此，科学家们已将每一个登陆地带都划分成 $2 \\times N$ 个矩形。不同的登陆地带其 $N$ 值不同。在绕 Samuel 星球探测计划中，已经对各个矩形土地的适用度做了评估。例如，某 $2 \\times 9$ 登陆地带的适用度评估值如下表所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3231y0gl.png)\n\n在这些矩形土地中，适用度为正数的，其土地比较结实平坦，适合建立实验基地，正值越高，就越安全，越适合建立基地。有些矩形土地适用度为负数，这表明该片土地有危险性，负得越多，就越不适合建立实验基地。\n\n科学家希望从登陆地带中自行选取一段 $2 \\times Q$ 的区域建立实验基地。不过为了研究方便，规定在 $2 \\times Q$ 区域中的第一行选一段长度为 $P$ 的区域空出来，作为采集样品的场所——此场所将不算作实验基地。这样一来，实验基地的形状看上去就是一个“凹”字型。\n\n例如，下图就是一个选取方案。粗线条框内的区域就是实验基地，它开辟出了一个 $2\\times5$ 的区域，并且在第一行中选出了长度为 $2$ 的样品采集区，样品采集区的适用度分别为 $-4$ 和 $-5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z0rv0vja.png)\n\n注意：$Q$ 和 $P$ 在 $N$ 的范围内可以自行任意选取，但是必须要设置样品采集区，而且样品采集区的左右两侧必须存在实验基地。故以下形状的实验基地是不允许出现的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d55jtlyn.png)\n\n科学家们将实验基地所占据的各个矩形土地其适用度之和称为该实验基地区，而且样品采集区的左右两侧必须存在实验基地。故以下形状的实验基地是不允许出现的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d55jtlyn.png)\n\n科学家们将实验基地所占据的各个矩形土地其适用度之和称为该实验基地的适用度。科学家们希望所建立的实验基地适用度能够尽可能大，并把这个实验基地的选址任务交给了小可可。现在请你为小可可编写程序进行选址。", "inputFormat": "第一行有一个整数 $N(3 < N < 2000)$，表示登陆地带的大小是 $2 \\times N$。随后的两行每一行有 $N$ 个整数（其绝对值不超过 $10^6$），表示对应的矩形土地的适用度评估值，各个整数之间用一个空格隔开。", "outputFormat": "只有一行输出，为整数 $M$，即所确定的实验基地的适用度。", "hint": "数据范围见输入格式。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2004] Experimental Base", "background": "", "description": "After unremitting efforts, scientists in our country are officially launching the research program for planet Samuel. The current task is to transport intelligent robots to the planet by spacecraft to establish a temporary experimental base for in-depth scientific exploration. To inspire students’ interest in science, scientists have also set up Student Research Teams (SRT) worldwide. After multiple rounds of selection, Xiao Keke has finally been admitted to the team.\n\nSenior scientists assigned Xiao Keke a simple operations task:\n\nIn the preliminary orbital survey of planet Samuel, it was found that the planet has several narrow flat regions suitable for landing (also called “landing zones”). Scientists plan to build an experimental base in a landing zone. However, not every landing zone is suitable for construction.\n\nTo this end, each landing zone has been divided into $2 \\times N$ rectangles. Different landing zones have different values of $N$. During the survey, the suitability of each rectangular plot was assessed. For example, the suitability values for a $2 \\times 9$ landing zone are shown below:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3231y0gl.png)\n\nAmong these rectangular plots, those with positive suitability are firm and flat, suitable for building the base; the higher the positive value, the safer and more suitable it is. Some plots have negative suitability, indicating danger; the more negative it is, the less suitable it is for construction.\n\nScientists wish to choose a $2 \\times Q$ segment within a landing zone to build the experimental base. For convenience in research, it is required that within the $2 \\times Q$ segment, a contiguous segment of length $P$ in the first row is left empty as a sample collection area—this area is not counted as part of the experimental base. As a result, the base forms a “concave” shape.\n\nFor example, the figure below shows a selection scheme. The region within the bold border is the experimental base. It covers a $2 \\times 5$ area, and in the first row, a sample collection area of length $2$ is selected; its suitability values are $-4$ and $-5$ respectively.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z0rv0vja.png)\n\nNote: $Q$ and $P$ can be chosen arbitrarily within the range of $N$, but a sample collection area must be set, and there must be base cells on both the left and right sides of the sample collection area within the first row. Therefore, the following base shapes are not allowed:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d55jtlyn.png)\n\nThe sum of the suitability values of all rectangular plots occupied by the experimental base is called the suitability of the base. Scientists hope to maximize this suitability and have assigned the site selection task to Xiao Keke. Please write a program to determine the optimal base location.", "inputFormat": "The first line contains an integer $N$ ($3 < N < 2000$), indicating the size of the landing zone is $2 \\times N$. The next two lines each contain $N$ integers (each with absolute value at most $10^6$), representing the suitability values of the corresponding rectangular plots, separated by single spaces.", "outputFormat": "Output a single line with an integer $M$, the suitability of the determined experimental base.", "hint": "Constraints are given in the input format.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2004] 实验基地", "background": null, "description": "经过不懈努力，我国科学家将正式启动 Samuel 星球研究计划。目前阶段的任务是采用飞船将智能机器人运送到该星球以建立临时实验基地进行深入的科学探索实验。为了激发广大学生的科学兴趣，科学家们还在全球范围内设立学生研究组（简称 SRT）。经过层层选拔，小可可终于入选该研究组。\n\n科学家前辈们交给小可可一项简单的运筹任务：\n\n在前期的绕 Samuel 星球探测计划中，发现该星球有若干处狭长的平坦地带可以用于登陆（亦称为“登陆地带”）。科学家们计划在登陆地带上建立实验基地。但是，并不是任何登陆地带都适宜建立实验基地。\n\n为此，科学家们已将每一个登陆地带都划分成 $2 \\times N$ 个矩形。不同的登陆地带其 $N$ 值不同。在绕 Samuel 星球探测计划中，已经对各个矩形土地的适用度做了评估。例如，某 $2 \\times 9$ 登陆地带的适用度评估值如下表所示：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3231y0gl.png)\n\n在这些矩形土地中，适用度为正数的，其土地比较结实平坦，适合建立实验基地，正值越高，就越安全，越适合建立基地。有些矩形土地适用度为负数，这表明该片土地有危险性，负得越多，就越不适合建立实验基地。\n\n科学家希望从登陆地带中自行选取一段 $2 \\times Q$ 的区域建立实验基地。不过为了研究方便，规定在 $2 \\times Q$ 区域中的第一行选一段长度为 $P$ 的区域空出来，作为采集样品的场所——此场所将不算作实验基地。这样一来，实验基地的形状看上去就是一个“凹”字型。\n\n例如，下图就是一个选取方案。粗线条框内的区域就是实验基地，它开辟出了一个 $2\\times5$ 的区域，并且在第一行中选出了长度为 $2$ 的样品采集区，样品采集区的适用度分别为 $-4$ 和 $-5$。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/z0rv0vja.png)\n\n注意：$Q$ 和 $P$ 在 $N$ 的范围内可以自行任意选取，但是必须要设置样品采集区，而且样品采集区的左右两侧必须存在实验基地。故以下形状的实验基地是不允许出现的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d55jtlyn.png)\n\n科学家们将实验基地所占据的各个矩形土地其适用度之和称为该实验基地区，而且样品采集区的左右两侧必须存在实验基地。故以下形状的实验基地是不允许出现的：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d55jtlyn.png)\n\n科学家们将实验基地所占据的各个矩形土地其适用度之和称为该实验基地的适用度。科学家们希望所建立的实验基地适用度能够尽可能大，并把这个实验基地的选址任务交给了小可可。现在请你为小可可编写程序进行选址。", "inputFormat": "第一行有一个整数 $N(3 < N < 2000)$，表示登陆地带的大小是 $2 \\times N$。随后的两行每一行有 $N$ 个整数（其绝对值不超过 $10^6$），表示对应的矩形土地的适用度评估值，各个整数之间用一个空格隔开。", "outputFormat": "只有一行输出，为整数 $M$，即所确定的实验基地的适用度。", "hint": "数据范围见输入格式。", "locale": "zh-CN"}}}
{"pid": "P2546", "type": "P", "difficulty": 5, "samples": [["10\n1 1\n3 1\n3 -2\n-3 -2\n-3 0\n-1 0\n-1 -1\n2 -1\n2 0\n1 0", "5\n10 5\n1 7\n2 9\n3 8\n4 6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "POI（波兰）", "Special Judge"], "title": "[POI 2008] SZK - Mirror trap", "background": "", "description": "King Byteasar's palace is haunted by a ghost. The spiteful claim it is the ghost of the late Byteasar's wife (who died recently in suspicious circumstances), for it takes great pleasure in looking at itself in the mirror, just as she did. No wonder that Byteasar would gladly get rid of this ghost!\n\nByteasar has decided to plant a special mirror trap in one of the palace's chambers. It is a closed, well lit room whose every interior wall is covered with mirror. Furthermore, in its every corner a laser gun or a laser detector can be set up. As soon as the ghost crosses one of the laser beams an alarm will go off, summoning Byteasar's ghost vanquishers team (as a royal team, they prefer not to be colloquially called 'ghost busters'), who will surely dispose of the ghost in no time.\n\nThe chamber, in which the mirror trap is being installed, is in the shape of a polygon whose consecutive sides are perpendicular. Moreover, the length of every side (measured in metres) is integral. Should a laser gun be installed in some corner, its beam has to be pointed along the bisector of the angle formed by the walls meeting in this corner (in a plane parallel to the floor surface). Obviously, if the laser beam encounters a mirror, it is reflected, obeying the regular reflection law: the angle which the incident ray makes with the normal is equal to the angle which the reflected ray makes to the same normal. This angle, as you may notice, is always 45 degrees due to the chamber's architecture. A beam cast along the bisector into a corner where a detector is placed, is completely absorbed by it. On the other hand, a beam cast along the bisector into corner without a detector (though possibly with a laser gun) is reflected back (by 180 degrees). In all the remaining cases the beam does not change its direction at all.\n\nA maximum number of laser guns complemented with laser detectors should be placed in the room in such a way that each laser beam is eventually absorbed by some detector, no two laser beams are absorbed by the same detector and each detector absorbs some laser beam. Also, a laser gun and a detector may not be placed in the same corner.\n\n\nAn example of a mirror trap with the laser beam going from corner 1 to corner 7:\n\nWrite a programme that:\n\nreads from the standard input the the mirror trap's shape description,\ndetermines the way of setting up the maximum possible number of laser guns and detectors satisfying the aforementioned conditions,\nwrites out the result to the standard output.\n\n\n![](https://cdn.luogu.com.cn/upload/pic/15471.png)", "inputFormat": "", "outputFormat": "", "hint": "", "locale": "en", "translations": {"en": {"title": "[POI 2008] SZK - Mirror trap", "background": "", "description": "King Byteasar's palace is haunted by a ghost. The spiteful claim it is the ghost of the late Byteasar's wife (who died recently in suspicious circumstances), for it takes great pleasure in looking at itself in the mirror, just as she did. No wonder that Byteasar would gladly get rid of this ghost!\n\nByteasar has decided to plant a special mirror trap in one of the palace's chambers. It is a closed, well lit room whose every interior wall is covered with mirror. Furthermore, in its every corner a laser gun or a laser detector can be set up. As soon as the ghost crosses one of the laser beams an alarm will go off, summoning Byteasar's ghost vanquishers team (as a royal team, they prefer not to be colloquially called 'ghost busters'), who will surely dispose of the ghost in no time.\n\nThe chamber, in which the mirror trap is being installed, is in the shape of a polygon whose consecutive sides are perpendicular. Moreover, the length of every side (measured in metres) is integral. Should a laser gun be installed in some corner, its beam has to be pointed along the bisector of the angle formed by the walls meeting in this corner (in a plane parallel to the floor surface). Obviously, if the laser beam encounters a mirror, it is reflected, obeying the regular reflection law: the angle which the incident ray makes with the normal is equal to the angle which the reflected ray makes to the same normal. This angle, as you may notice, is always 45 degrees due to the chamber's architecture. A beam cast along the bisector into a corner where a detector is placed, is completely absorbed by it. On the other hand, a beam cast along the bisector into corner without a detector (though possibly with a laser gun) is reflected back (by 180 degrees). In all the remaining cases the beam does not change its direction at all.\n\nA maximum number of laser guns complemented with laser detectors should be placed in the room in such a way that each laser beam is eventually absorbed by some detector, no two laser beams are absorbed by the same detector and each detector absorbs some laser beam. Also, a laser gun and a detector may not be placed in the same corner.\n\n\nAn example of a mirror trap with the laser beam going from corner 1 to corner 7:\n\nWrite a programme that:\n\nreads from the standard input the the mirror trap's shape description,\ndetermines the way of setting up the maximum possible number of laser guns and detectors satisfying the aforementioned conditions,\nwrites out the result to the standard output.\n\n\n![](https://cdn.luogu.com.cn/upload/pic/15471.png)", "inputFormat": "", "outputFormat": "", "hint": "", "locale": "en"}, "zh-CN": {"title": "[POI 2008] SZK - Mirror trap", "background": "", "description": "$N$ 个点的多边形相邻边垂直，边长为整数，边平行坐标轴。要在多边形的点上放一些激光发射器和接收器。满足下列要求：\n\n - 发射器和接收器不能放置在同一点；\n - 发射器发出激光可以沿壁反射，最终到达一个接收器；\n - 发射器只能沿角平分线发射激光。\n\n求：最多可放置多少对发射器和接收器？$4\\leq N\\leq 10^5$，**多边形周长不超过 $3\\times 10^5$**。", "inputFormat": "第一行给出一个数字 $N$，代表有多少个点。下面 $N$ 行,用来描述点的坐标.其值在 $[-1000000,1000000]$。", "outputFormat": "第一行一个数，最多可放置多少对发射器和接收器。接下来若干行，每行两个数，描述一对发射器和接收器。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2547", "type": "P", "difficulty": 5, "samples": [["3\nATCTACTG\nCTATACTG\nCTATGATC", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2004", "各省省选", "安徽"], "title": "[AHOI2004] DNA变异", "background": null, "description": "![](https://cdn.luogu.com.cn/upload/pic/1660.png)", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1661.png)", "outputFormat": "只有一行数字，表示 DNA 序列中的血缘序列对的总数。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2004] DNA Mutation", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1660.png)", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1661.png)", "outputFormat": "Only one line containing a number, representing the total number of \"血缘序列对\" in the DNA sequence.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2004] DNA变异", "background": null, "description": "![](https://cdn.luogu.com.cn/upload/pic/1660.png)", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1661.png)", "outputFormat": "只有一行数字，表示 DNA 序列中的血缘序列对的总数。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2548", "type": "P", "difficulty": 2, "samples": [["4 3\nsunny plain full many\nsunny mountain full many\nsunny mountain full few", "sunny * full *"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2004", "各省省选", "安徽"], "title": "[AHOI2004] 智能探险车", "background": "", "description": "在 ***Sanuel*** 星球上的科学探险活动是由名为 ***Smart*** 的智能探险车完成的。因为 ***Sanuel*** 星球远离地球，信号往返传送一次要耗费数小时，而且存在很高的误码率。因此科学家们无法在地球上对 ***Smart*** 探险车进行实时控制，绝大部分探险活动都是由该探险车通过分析环境要素、自主决策、自主完成的。\n\n科学家们的探险车设计方案相对简单：\n\n首先，总结出影响探险车决策的各种**决策因素**，譬如：天气（weather）、地形（landform）、探险车供电情况（energy）和已采集矿石数目（mine）等。\n\n随后，将每一种**决策因素**分成两种主要**情况**。譬如，将天气分成晴朗（sunny）和大风（windy）；将探险车供电情况分成饱满（full）和匮乏（lack），等等。\n\n再后，科学家们针对各种**决策因素**，分别列出每一种行为的决策条件。譬如，若影响采集矿石的决策因素有 $N=4$ 种，而采集矿石的决策条件如下：\n\n| 决策条件 | Weather | Landform | Energy | Mine |\n| :------: | :-----: | :------: | :----: | :--: |\n|    1     |  sunny  |  Plain   |  full  | Few  |\n|    2     |  sunny  | mountain |  full  | Many |\n|    3     |  sunny  | mountain |  full  | Many |\n\n探险车的行为及其决策条件都很多，为了提高探险车的决策速度，最后需要探险车上的智能归纳模块将每一种行为的各种决策条件总结成一条“决策模板”。\n\n如上述采集矿石的各条决策条件可以总结为：\n\n| 决策模板 | sunny |  *   | full |  *   |\n| :------: | :---: | :--: | :--: | :--: |\n\n其中，“*”表示该因素不影响探险车的行为决策。\n\n显然，决策模板要能够涵盖科学家们列出的该行为的所有决策条件。同时，决策模板中也含有一些科学家们未列出的决策条件，因而探险车能够在科学家们没有给出的决策条件下也能够自动进行某种行为，因而具有一定的“智能性”。如，上述决策模板会导致探险车在以下决策条件下也会进行矿石的采集。\n\n|            | Weather | Landform | Energy | Mine |\n| :--------: | :-----: | :------: | :----: | :--: |\n| 新决策条件 |  sunny  |  Plain   |  full  | Many |\n\n但是，任何事物都存在着两个方面。如果给出的决策模板过于笼统就失去了决策意义，相当于决策不精确。如，以下决策模板虽然涵盖了科学家们列出的各种采集矿石决策条件，但是因为决策过于笼统而意义不大。\n\n| 过于笼统的决策模板 |  *   |  *   | full |  *   |\n| :----------------: | :--: | :--: | :--: | :--: |\n\n因此，要求探险车的决策模板所使用的”*“尽可能少。\n\n小可可负责领导开发探险车的智能归纳模块。请你编写程序帮助小可可完成任务。", "inputFormat": "第一行有两个用一个空格隔开的正整数 $N$ 和 $M$ ，分别表示决策因素（$N \\leq 100$）和某种行为的决策条件数目（$M \\leq 1000$）。\n\n接下来的 $M$ 行每行是由 $N$ 个单词构成的字符串，每个单词依次对应一种决策因素的情况，每行就表示一种决策条件。每行内的单词之间用一个空格隔开。\n\n注意：每行的行首与行末都不存在多余的空白字符，单词仅仅由小写英文字母构成，长度不超过 10。\n", "outputFormat": "只有一行，表示决策模板，由 $N$ 个单词或“*”构成，彼此间用一个空格隔开。要求行首与行末都不存在多余的空白字符。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2004] Intelligent Rover", "background": "", "description": "On the planet ***Sanuel***, scientific exploration is carried out by an intelligent rover named ***Smart***. Because ***Sanuel*** is far from Earth, a round-trip signal transmission takes several hours and has a high error rate. Therefore, scientists cannot control the ***Smart*** rover in real time from Earth. Most exploration tasks are autonomously completed by the rover through analyzing environmental factors and making independent decisions.\n\nThe rover’s design is relatively simple:\n\nFirst, list the various decision factors that affect the rover’s actions, such as weather, landform, energy (power supply), and mine (number of collected ores).\n\nNext, divide each decision factor into two primary situations. For example, divide weather into sunny and windy; divide the rover’s energy into full and lack, etc.\n\nThen, for each action, scientists list all decision conditions according to the decision factors. For example, suppose the decision factors that affect ore collection have $N=4$ types, and the decision conditions for collecting ore are as follows:\n\n| Decision condition | Weather | Landform | Energy | Mine |\n| :----------------: | :-----: | :------: | :----: | :--: |\n|         1          |  sunny  |  Plain   |  full  | Few  |\n|         2          |  sunny  | mountain |  full  | Many |\n|         3          |  sunny  | mountain |  full  | Many |\n\nThere are many actions and many corresponding decision conditions. To improve decision speed, the intelligent induction module on the rover needs to summarize all decision conditions of each action into a single “decision template.”\n\nFor example, the above decision conditions for ore collection can be summarized as:\n\n| Decision template | sunny |  *   | full |  *   |\n| :---------------: | :---: | :--: | :--: | :--: |\n\nHere, “*” means that the factor does not affect the action decision of the rover.\n\nObviously, the decision template must cover all listed decision conditions for that action. Meanwhile, the decision template will also include some decision conditions that scientists did not list, so the rover can act automatically under unlisted decision conditions, showing some degree of “intelligence.” For example, the above decision template will cause the rover to collect ore under the following decision condition as well.\n\n|                    | Weather | Landform | Energy | Mine |\n| :----------------: | :-----: | :------: | :----: | :--: |\n| New decision condition |  sunny  |  Plain   |  full  | Many |\n\nHowever, everything has two sides. If the decision template is too general, it loses its decision value and becomes imprecise. For example, the following decision template, although it covers all the listed ore collection decision conditions, is too general to be meaningful.\n\n| Overly general decision template |  *   |  *   | full |  *   |\n| :------------------------------: | :--: | :--: | :--: | :--: |\n\nTherefore, the number of “*” used in the decision template should be as few as possible.\n\nXiao Keke (pinyin) is in charge of developing the rover’s intelligent induction module. Please write a program to help Xiao Keke complete this task.", "inputFormat": "The first line contains two positive integers $N$ and $M$ separated by a space, representing the number of decision factors ($N \\leq 100$) and the number of decision conditions for a certain action ($M \\leq 1000$).\n\nEach of the next $M$ lines is a string consisting of $N$ words. Each word corresponds, in order, to the situation of one decision factor, and each line represents one decision condition. Words on each line are separated by a single space.\n\nNote: There are no extra whitespace characters at the beginning or end of any line. Words consist only of lowercase English letters and have a length of at most 10.", "outputFormat": "Output a single line representing the decision template, consisting of $N$ words or “*”, separated by single spaces. There should be no extra whitespace at the beginning or end of the line.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2004] 智能探险车", "background": "", "description": "在 ***Sanuel*** 星球上的科学探险活动是由名为 ***Smart*** 的智能探险车完成的。因为 ***Sanuel*** 星球远离地球，信号往返传送一次要耗费数小时，而且存在很高的误码率。因此科学家们无法在地球上对 ***Smart*** 探险车进行实时控制，绝大部分探险活动都是由该探险车通过分析环境要素、自主决策、自主完成的。\n\n科学家们的探险车设计方案相对简单：\n\n首先，总结出影响探险车决策的各种**决策因素**，譬如：天气（weather）、地形（landform）、探险车供电情况（energy）和已采集矿石数目（mine）等。\n\n随后，将每一种**决策因素**分成两种主要**情况**。譬如，将天气分成晴朗（sunny）和大风（windy）；将探险车供电情况分成饱满（full）和匮乏（lack），等等。\n\n再后，科学家们针对各种**决策因素**，分别列出每一种行为的决策条件。譬如，若影响采集矿石的决策因素有 $N=4$ 种，而采集矿石的决策条件如下：\n\n| 决策条件 | Weather | Landform | Energy | Mine |\n| :------: | :-----: | :------: | :----: | :--: |\n|    1     |  sunny  |  Plain   |  full  | Few  |\n|    2     |  sunny  | mountain |  full  | Many |\n|    3     |  sunny  | mountain |  full  | Many |\n\n探险车的行为及其决策条件都很多，为了提高探险车的决策速度，最后需要探险车上的智能归纳模块将每一种行为的各种决策条件总结成一条“决策模板”。\n\n如上述采集矿石的各条决策条件可以总结为：\n\n| 决策模板 | sunny |  *   | full |  *   |\n| :------: | :---: | :--: | :--: | :--: |\n\n其中，“*”表示该因素不影响探险车的行为决策。\n\n显然，决策模板要能够涵盖科学家们列出的该行为的所有决策条件。同时，决策模板中也含有一些科学家们未列出的决策条件，因而探险车能够在科学家们没有给出的决策条件下也能够自动进行某种行为，因而具有一定的“智能性”。如，上述决策模板会导致探险车在以下决策条件下也会进行矿石的采集。\n\n|            | Weather | Landform | Energy | Mine |\n| :--------: | :-----: | :------: | :----: | :--: |\n| 新决策条件 |  sunny  |  Plain   |  full  | Many |\n\n但是，任何事物都存在着两个方面。如果给出的决策模板过于笼统就失去了决策意义，相当于决策不精确。如，以下决策模板虽然涵盖了科学家们列出的各种采集矿石决策条件，但是因为决策过于笼统而意义不大。\n\n| 过于笼统的决策模板 |  *   |  *   | full |  *   |\n| :----------------: | :--: | :--: | :--: | :--: |\n\n因此，要求探险车的决策模板所使用的”*“尽可能少。\n\n小可可负责领导开发探险车的智能归纳模块。请你编写程序帮助小可可完成任务。", "inputFormat": "第一行有两个用一个空格隔开的正整数 $N$ 和 $M$ ，分别表示决策因素（$N \\leq 100$）和某种行为的决策条件数目（$M \\leq 1000$）。\n\n接下来的 $M$ 行每行是由 $N$ 个单词构成的字符串，每个单词依次对应一种决策因素的情况，每行就表示一种决策条件。每行内的单词之间用一个空格隔开。\n\n注意：每行的行首与行末都不存在多余的空白字符，单词仅仅由小写英文字母构成，长度不超过 10。\n", "outputFormat": "只有一行，表示决策模板，由 $N$ 个单词或“*”构成，彼此间用一个空格隔开。要求行首与行末都不存在多余的空白字符。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2549", "type": "P", "difficulty": 5, "samples": [["7\r\n4\r\nEGG\r\nODD\r\nLOBE\r\nLIBE", "9933817"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "贪心", "2015", "背包 DP", "洛谷月赛"], "title": "计算器写作文", "background": "", "description": "众所周知，计算器可以拿来干很多它本不应该干的事情，比如弹琴。\n\n小A发现了一个计算器的隐藏功能——写英语作文。\n\n他在计算器上按一些数字，这些然后旋转 $180$ 度就是作文。\n\n每个数字对应一两个字母\n\n ![](https://cdn.luogu.com.cn/upload/pic/1738.png) \n\n\n\n小 A 准备了一个单词表，选择其中的一些单词，按照一个顺序组成作文。这个作文是可以用计算器按出来的。比如单词表给 `ODD`、`EGG`，作文写成 `ODDEGG` 的话，那么要在计算器上按出 `993000`，这篇作文的得分就是 $993000$。\n\n单词表的单词不能重复使用。如果单词表出现了多个一样的单词，每个单词最多都可以各使用一次。单词不可以被截断。\n\n小 A 希望自己写出的作文得分最高。当然这个计算器是有位数限制，作文长度不能超过显示位数。\n\n计算器不能显示前导零，但是你可以添加小数点。比如作文写成 `EGGODD` 的话，就得按出 $0.00993$，这个就是作文的得分，当然这得分太小了。\n", "inputFormat": "第一行 $D$ 表示计算器位数。\n\n第二行 $N$ 表示单词数。\n\n接下来 $N$ 行，一行一个单词，保证可以转换为数字。", "outputFormat": "一行，表示最大的分值。\n", "hint": "\n\n对于 $40\\%$ 的数据，$D \\leq 20,N \\leq 10$。\n\n对于 $100\\%$ 的数据，$D \\leq 200,N \\leq 10000$，单词长度 $\\leq 32$。", "locale": "zh-CN", "translations": {"en": {"title": "Calculator Writes an Essay", "background": "", "description": "As we all know, a calculator can be used for many things it was not meant to do, like playing music.\n\nXiao A discovered a hidden feature of a calculator — writing English essays.\n\nHe presses some digits on the calculator, and after rotating the display by $180$ degrees, it becomes the essay.\n\nEach digit corresponds to one or two letters.\n\n ![](https://cdn.luogu.com.cn/upload/pic/1738.png) \n\nXiao A prepared a word list, chooses some words from it, and arranges them in an order to form an essay. This essay can be typed on the calculator. For example, if the word list contains `ODD` and `EGG`, and the essay is `ODDEGG`, then you need to press `993000` on the calculator, and the score of this essay is $993000$.\n\nWords in the list cannot be reused. If the list contains multiple identical words, each occurrence can be used at most once. Words cannot be split.\n\nXiao A wants the essay to have the highest possible score. Of course, the calculator has a digit limit, so the essay length cannot exceed the number of display digits.\n\nThe calculator cannot display leading zeros, but you may insert a decimal point. For example, if the essay is `EGGODD`, you have to type $0.00993$, which is the score of the essay, though that score is too small.", "inputFormat": "The first line contains $D$, the number of display digits of the calculator.\n\nThe second line contains $N$, the number of words.\n\nThe next $N$ lines each contain one word, guaranteed to be convertible to digits.", "outputFormat": "Output one line containing the maximum score.", "hint": "For $40\\%$ of the testdata, $D \\leq 20, N \\leq 10$.\n\nFor $100\\%$ of the testdata, $D \\leq 200, N \\leq 10000$, and the word length $\\leq 32$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "计算器写作文", "background": "", "description": "众所周知，计算器可以拿来干很多它本不应该干的事情，比如弹琴。\n\n小A发现了一个计算器的隐藏功能——写英语作文。\n\n他在计算器上按一些数字，这些然后旋转 $180$ 度就是作文。\n\n每个数字对应一两个字母\n\n ![](https://cdn.luogu.com.cn/upload/pic/1738.png) \n\n\n\n小 A 准备了一个单词表，选择其中的一些单词，按照一个顺序组成作文。这个作文是可以用计算器按出来的。比如单词表给 `ODD`、`EGG`，作文写成 `ODDEGG` 的话，那么要在计算器上按出 `993000`，这篇作文的得分就是 $993000$。\n\n单词表的单词不能重复使用。如果单词表出现了多个一样的单词，每个单词最多都可以各使用一次。单词不可以被截断。\n\n小 A 希望自己写出的作文得分最高。当然这个计算器是有位数限制，作文长度不能超过显示位数。\n\n计算器不能显示前导零，但是你可以添加小数点。比如作文写成 `EGGODD` 的话，就得按出 $0.00993$，这个就是作文的得分，当然这得分太小了。\n", "inputFormat": "第一行 $D$ 表示计算器位数。\n\n第二行 $N$ 表示单词数。\n\n接下来 $N$ 行，一行一个单词，保证可以转换为数字。", "outputFormat": "一行，表示最大的分值。\n", "hint": "\n\n对于 $40\\%$ 的数据，$D \\leq 20,N \\leq 10$。\n\n对于 $100\\%$ 的数据，$D \\leq 200,N \\leq 10000$，单词长度 $\\leq 32$。", "locale": "zh-CN"}}}
{"pid": "P2550", "type": "P", "difficulty": 1, "samples": [["2\n23 31 1 14 19 17 18\n12 8 9 23 1 16 7\n11 7 10 21 2 9 31", "0 0 0 0 0 1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2001", "各省省选", "安徽"], "title": "[AHOI2001] 彩票摇奖", "background": "", "description": "为了丰富人民群众的生活、支持某些社会公益事业，北塔市设置了一项彩票。该彩票的规则是：\n\n1. 每张彩票上印有 $7$ 个各不相同的号码，且这些号码的取值范围为 $1\\sim33$。\n2. 每次在兑奖前都会公布一个由七个各不相同的号码构成的中奖号码。\n3. 共设置 $7$ 个奖项，特等奖和一等奖至六等奖。\n\n兑奖规则如下：\n- 特等奖：要求彩票上 $7$ 个号码都出现在中奖号码中。\n- 一等奖：要求彩票上有 $6$ 个号码出现在中奖号码中。\n- 二等奖：要求彩票上有 $5$ 个号码出现在中奖号码中。\n- 三等奖：要求彩票上有 $4$ 个号码出现在中奖号码中。\n- 四等奖：要求彩票上有 $3$ 个号码出现在中奖号码中。\n- 五等奖：要求彩票上有 $2$ 个号码出现在中奖号码中。\n- 六等奖：要求彩票上有 $1$ 个号码出现在中奖号码中。\n\n注：兑奖时并不考虑彩票上的号码和中奖号码中的各个号码出现的位置。例如，中奖号码为 $23\\ 31\\ 1\\ 14\\ 19\\ 17\\ 18$，则彩票 $12\\ 8\\ 9\\ 23\\ 1\\ 16\\ 7$ 由于其中有两个号码（$23$ 和 $1$）出现在中奖号码中，所以该彩票中了五等奖。\n\n现已知中奖号码和小明买的若干张彩票的号码，请你写一个程序帮助小明判断他买的彩票的中奖情况。", "inputFormat": "输入的第一行只有一个自然数 $n$，表示小明买的彩票张数；\n\n第二行存放了 $7$ 个介于 $1$ 和 $33$ 之间的自然数，表示中奖号码；\n\n在随后的 $n$ 行中每行都有 $7$ 个介于 $1$ 和 $33$ 之间的自然数，分别表示小明所买的 $n$ 张彩票。", "outputFormat": "依次输出小明所买的彩票的中奖情况（中奖的张数），首先输出特等奖的中奖张数，然后依次输出一等奖至六等奖的中奖张数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n\\lt1000$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2001] Lottery Drawing", "background": "", "description": "To enrich people's lives and support certain public welfare causes, Beita City has set up a lottery. The lottery rules are:\n\n1. Each ticket has $7$ distinct numbers, each in the range $1\\sim33$.\n2. Before claiming prizes, a winning set consisting of seven distinct numbers is announced each time.\n3. There are $7$ prize levels: Special Prize, and First Prize through Sixth Prize.\n\nThe prize-claiming rules are as follows:\n- Special Prize: All $7$ numbers on the ticket appear in the winning set.\n- First Prize: $6$ numbers on the ticket appear in the winning set.\n- Second Prize: $5$ numbers on the ticket appear in the winning set.\n- Third Prize: $4$ numbers on the ticket appear in the winning set.\n- Fourth Prize: $3$ numbers on the ticket appear in the winning set.\n- Fifth Prize: $2$ numbers on the ticket appear in the winning set.\n- Sixth Prize: $1$ number on the ticket appears in the winning set.\n\nNote: The positions of numbers on the ticket and in the winning set are not considered. For example, if the winning set is $23\\ 31\\ 1\\ 14\\ 19\\ 17\\ 18$, then the ticket $12\\ 8\\ 9\\ 23\\ 1\\ 16\\ 7$ wins the Fifth Prize because two numbers ($23$ and $1$) appear in the winning set.\n\nGiven the winning set and the numbers on several tickets bought by Xiao Ming, write a program to determine the prize results of Xiao Ming's tickets.", "inputFormat": "The first line contains a single natural number $n$, the number of tickets Xiao Ming bought.\n\nThe second line contains $7$ natural numbers between $1$ and $33$, which are the winning numbers.\n\nEach of the following $n$ lines contains $7$ natural numbers between $1$ and $33$, representing each of Xiao Ming's $n$ tickets.", "outputFormat": "Output the counts of Xiao Ming's winning tickets for each prize level, in order: first the number of Special Prize winners, then the counts for First Prize through Sixth Prize.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\lt 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2001] 彩票摇奖", "background": "", "description": "为了丰富人民群众的生活、支持某些社会公益事业，北塔市设置了一项彩票。该彩票的规则是：\n\n1. 每张彩票上印有 $7$ 个各不相同的号码，且这些号码的取值范围为 $1\\sim33$。\n2. 每次在兑奖前都会公布一个由七个各不相同的号码构成的中奖号码。\n3. 共设置 $7$ 个奖项，特等奖和一等奖至六等奖。\n\n兑奖规则如下：\n- 特等奖：要求彩票上 $7$ 个号码都出现在中奖号码中。\n- 一等奖：要求彩票上有 $6$ 个号码出现在中奖号码中。\n- 二等奖：要求彩票上有 $5$ 个号码出现在中奖号码中。\n- 三等奖：要求彩票上有 $4$ 个号码出现在中奖号码中。\n- 四等奖：要求彩票上有 $3$ 个号码出现在中奖号码中。\n- 五等奖：要求彩票上有 $2$ 个号码出现在中奖号码中。\n- 六等奖：要求彩票上有 $1$ 个号码出现在中奖号码中。\n\n注：兑奖时并不考虑彩票上的号码和中奖号码中的各个号码出现的位置。例如，中奖号码为 $23\\ 31\\ 1\\ 14\\ 19\\ 17\\ 18$，则彩票 $12\\ 8\\ 9\\ 23\\ 1\\ 16\\ 7$ 由于其中有两个号码（$23$ 和 $1$）出现在中奖号码中，所以该彩票中了五等奖。\n\n现已知中奖号码和小明买的若干张彩票的号码，请你写一个程序帮助小明判断他买的彩票的中奖情况。", "inputFormat": "输入的第一行只有一个自然数 $n$，表示小明买的彩票张数；\n\n第二行存放了 $7$ 个介于 $1$ 和 $33$ 之间的自然数，表示中奖号码；\n\n在随后的 $n$ 行中每行都有 $7$ 个介于 $1$ 和 $33$ 之间的自然数，分别表示小明所买的 $n$ 张彩票。", "outputFormat": "依次输出小明所买的彩票的中奖情况（中奖的张数），首先输出特等奖的中奖张数，然后依次输出一等奖至六等奖的中奖张数。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n\\lt1000$。", "locale": "zh-CN"}}}
{"pid": "P2551", "type": "P", "difficulty": 5, "samples": [["0 1 75000 6 15000 75000\n12 12 12 11 12 14\n11 10 8 9 10 11\n9 8 6 7 8 8\n8 7 6 6 6 5\n8 6 6 6 6 5\n11 11 11 13 15\n10 10 9 9 10\n10 9 9 10 10\n9 8 9 9 10\n7 8 8 9 9\n7 7 7 8 8\n5 4 3 3 2\n4 3 3 2 2\n3 3 2 2 2\n3 3 2 2 2", "79\nRAARRRRADDRR"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2001", "各省省选", "安徽"], "title": "[AHOI2001] 华夏60战斗机", "background": "", "description": "华夏 60 超音速战斗机是当今世界上机动性能最先进的战斗机。战斗过程中的一个关键问题是如何在最短的时间内使飞机从当前的飞行高度和速度爬升/俯冲到指定的高度并达到指定速度，以便占据有利的战斗位置。\n\n现假定只允许华夏 60 执行以下三种基本飞行动作，并且只能在完成了一个基本动作的情况下再去执行另一个基本飞行动作。这样华夏 60 的飞行可以表示成由这三种基本飞行动作组成的动作序列。\n\n(1) 维持原速做恒速爬升飞行，直至飞行高度提高 ∆h 英尺；\n\n(2) 水平加速飞直至速度提高 1 马赫(1 马赫≈1200 公里/小时)；\n\n(3) 垂直俯冲飞行 ∆h 英尺，飞行速度会提高 1 马赫。\n\n同时假定飞机的初始飞行速度和执行每个基本飞行动作初始时刻的飞行速度都是 1 马赫的整数倍，且不超过 6 马赫；初始飞行高度和执行每个基本飞行动作初始时刻的飞行高度都为 ∆h 英尺( ∆h 是整数)的整数倍。\n\n实验研究表明：在不同高度 H 和不同的初始速度V 完成上述的三种基本飞行动作所需的时间也是各不相同的。表 1~表 3 给出了 ∆ h = 15000英尺和最大飞行高度 = 75000\n\nH m 英尺时完成这三种基本飞行动作所需的时间。\n\n根据表 1~表 3 的数据，欲使华夏 60 战斗机从 H = 0 英尺、V = 1马赫的飞行状态达到 H = 75000 英尺、V = 6 马赫的飞行状态的最短飞行时间是79 秒，相应的飞行动作序列是：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1669.png) \n\n(1) 恒速爬升飞行至 H = 15000英尺，V = 1马赫状态；\n\n(2) 连续做两次水平加速飞行至 H = 15000英尺，V = 3马赫状态；\n\n(3) 连续做四次恒速爬升飞行至 H = 75000 英尺，V = 3马赫状态；\n\n\n(4) 水平加速飞行至 H = 75000 英尺，V = 4马赫状态；\n\n(5) 连续做两次垂直俯冲飞行至 H = 45000 英尺，V = 6 马赫状态；\n\n(6) 连续做两次恒速爬升飞行至 H = 75000 英尺，V = 6 马赫状态。\n\n现在小明驾驶华夏 60 战斗机以V1马赫的速度飞行于 H1英尺高度，中队长发出了让他以V2 马赫的速度飞行于 H 2 英尺高度的指令。请你编写程序帮小明决策一下如何飞行才能花费最少的时间执行完中队长下达的命令。\n", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1670.png)\n", "outputFormat": "输出信息用两行来存放。第一行存放你求出的最优方案所需的时间。\n\n第二行存放该最优方案的动作序列(以 R 表示恒速爬升飞行，A 表示\n\n水平加速飞行，D 表示垂直俯冲飞行)。第二行中不允许出现多余的\n\n字符(包括空白字符)。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2001] Huaxia 60 Fighter Jet", "background": "", "description": "The Huaxia 60 supersonic fighter jet is one of the most maneuverable fighters in the world today. A key issue in combat is how to climb/dive from the current flight altitude and speed to a designated altitude and achieve a designated speed in the shortest time to gain a superior combat position.\n\nAssume that the Huaxia 60 is allowed to perform only the following three basic maneuvers, and a new basic maneuver can only start after the previous one is completed. Thus, a flight can be represented as a sequence composed of these three basic maneuvers.\n\n(1) Maintain the current speed and perform a constant-speed climb until the flight altitude increases by $\\Delta h$ feet.\n\n(2) Perform horizontal acceleration until the speed increases by 1 Mach (1 Mach $\\approx 1200$ km/h).\n\n(3) Perform a vertical dive by $\\Delta h$ feet, during which the flight speed increases by 1 Mach.\n\nAlso assume that the initial flight speed and the speed at the beginning of each basic maneuver are integer multiples of 1 Mach and do not exceed 6 Mach; the initial flight altitude and the altitude at the beginning of each basic maneuver are integer multiples of $\\Delta h$ feet (where $\\Delta h$ is an integer).\n\nExperimental studies show that the time required to complete the above three basic maneuvers varies with different altitudes $H$ and initial speeds $V$. Tables 1–3 give the required times when $\\Delta h = 15000$ feet and the maximum flight altitude is $75000$ feet.\n\nBased on the data in Tables 1–3, the shortest time for the Huaxia 60 to reach the flight state $H=75000$ feet, $V=6$ Mach starting from $H=0$ feet, $V=1$ Mach is 79 seconds, and the corresponding sequence of maneuvers is:\n\n ![](https://cdn.luogu.com.cn/upload/pic/1669.png) \n\n(1) Constant-speed climb to $H=15000$ feet, $V=1$ Mach.\n\n(2) Perform two consecutive horizontal accelerations to $H=15000$ feet, $V=3$ Mach.\n\n(3) Perform four consecutive constant-speed climbs to $H=75000$ feet, $V=3$ Mach.\n\n(4) Horizontal acceleration to $H=75000$ feet, $V=4$ Mach.\n\n(5) Perform two consecutive vertical dives to $H=45000$ feet, $V=6$ Mach.\n\n(6) Perform two consecutive constant-speed climbs to $H=75000$ feet, $V=6$ Mach.\n\nNow Xiao Ming is flying the Huaxia 60 at $V_1$ Mach at altitude $H_1$ feet. The squadron commander orders him to fly at $V_2$ Mach at altitude $H_2$ feet. Please write a program to decide how to fly so that the order is completed in the least time.", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1670.png)", "outputFormat": "The output contains two lines.\n- The first line contains the time required by your optimal plan.\n- The second line contains the action sequence of the optimal plan (use R for constant-speed climb, A for horizontal acceleration, and D for vertical dive). No extra characters (including whitespace) are allowed on the second line.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2001] 华夏60战斗机", "background": "", "description": "华夏 60 超音速战斗机是当今世界上机动性能最先进的战斗机。战斗过程中的一个关键问题是如何在最短的时间内使飞机从当前的飞行高度和速度爬升/俯冲到指定的高度并达到指定速度，以便占据有利的战斗位置。\n\n现假定只允许华夏 60 执行以下三种基本飞行动作，并且只能在完成了一个基本动作的情况下再去执行另一个基本飞行动作。这样华夏 60 的飞行可以表示成由这三种基本飞行动作组成的动作序列。\n\n(1) 维持原速做恒速爬升飞行，直至飞行高度提高 ∆h 英尺；\n\n(2) 水平加速飞直至速度提高 1 马赫(1 马赫≈1200 公里/小时)；\n\n(3) 垂直俯冲飞行 ∆h 英尺，飞行速度会提高 1 马赫。\n\n同时假定飞机的初始飞行速度和执行每个基本飞行动作初始时刻的飞行速度都是 1 马赫的整数倍，且不超过 6 马赫；初始飞行高度和执行每个基本飞行动作初始时刻的飞行高度都为 ∆h 英尺( ∆h 是整数)的整数倍。\n\n实验研究表明：在不同高度 H 和不同的初始速度V 完成上述的三种基本飞行动作所需的时间也是各不相同的。表 1~表 3 给出了 ∆ h = 15000英尺和最大飞行高度 = 75000\n\nH m 英尺时完成这三种基本飞行动作所需的时间。\n\n根据表 1~表 3 的数据，欲使华夏 60 战斗机从 H = 0 英尺、V = 1马赫的飞行状态达到 H = 75000 英尺、V = 6 马赫的飞行状态的最短飞行时间是79 秒，相应的飞行动作序列是：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1669.png) \n\n(1) 恒速爬升飞行至 H = 15000英尺，V = 1马赫状态；\n\n(2) 连续做两次水平加速飞行至 H = 15000英尺，V = 3马赫状态；\n\n(3) 连续做四次恒速爬升飞行至 H = 75000 英尺，V = 3马赫状态；\n\n\n(4) 水平加速飞行至 H = 75000 英尺，V = 4马赫状态；\n\n(5) 连续做两次垂直俯冲飞行至 H = 45000 英尺，V = 6 马赫状态；\n\n(6) 连续做两次恒速爬升飞行至 H = 75000 英尺，V = 6 马赫状态。\n\n现在小明驾驶华夏 60 战斗机以V1马赫的速度飞行于 H1英尺高度，中队长发出了让他以V2 马赫的速度飞行于 H 2 英尺高度的指令。请你编写程序帮小明决策一下如何飞行才能花费最少的时间执行完中队长下达的命令。\n", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1670.png)\n", "outputFormat": "输出信息用两行来存放。第一行存放你求出的最优方案所需的时间。\n\n第二行存放该最优方案的动作序列(以 R 表示恒速爬升飞行，A 表示\n\n水平加速飞行，D 表示垂直俯冲飞行)。第二行中不允许出现多余的\n\n字符(包括空白字符)。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2552", "type": "P", "difficulty": 3, "samples": [["2\n16 1 1 6 11\n16 2 2 5 11", "2 5 1 5"]], "limits": {"time": [1000], "memory": [128000]}, "tags": ["模拟", "数学", "2001", "各省省选", "安徽"], "title": "[AHOI2001] 团体操队形", "background": null, "description": "有 $n$ 个团体操队员编号分别为 $1\\sim n$。其队形（分连续队形和梅花桩队形）可以按行排列或者按列排列，按行（列）排列时每行（列）有 $r$ 个位置。 \n\n例 1：$n=16$，$r=6$，连续队形按行排列。\n|1|2|3|4|5|6|\n|:-:|:-:|:-:|-|-|-|\n|**7**|**8**|**9**|**10**|**11**|**12**|\n|**13**|**14**|**15**|**16**|\n\n例 2：$n=16$，$r=3$，连续队形按列排列。\n|  1  |  4  |  7  |  10  |  13  |16|\n| :-: | :-: | :-: |  :-: |  :-: |- |\n|**2**|**5**|**8**|**11**|**14**|\n|**3**|**6**|**9**|**12**|**15**|\n\n例 3：$n=16$，$r=7$，梅花桩队形按行排列。\n|  1   |      |  2   |      |  3   |      |  4   |\n| :-:  | :-:  | :-:  | :-:  | :-:  | :-:  | :-:  |\n|      |**5** |      |**6** |      |**7** |      |\n|**8** |      | **9**|      |**10**|      |**11**|\n|      |**12**|      |**13**|      |**14**|      |\n|**15**|      |**16**|      |      |      |      |\n\n例 4：$n=16$，$r=5$，梅花桩队形按列排列。\n|  1  |     |  6  |      |  11  |      |16 |\n| :-: | :-: | :-: | :-:  | :-:  | :-:  |:-:|\n|     |**4**|     |**9** |      |**14**|   |\n|**2**|     |**7**|      |**12**|      |   |\n|     |**5**|     |**10**|      |**15**|   |\n|**3**|     |**8**|      |**13**|      |   |\n\n现请你编写程序指出编号为 $m$ 的团体操队员所处位置的行号和列号。", "inputFormat": "**本题有多组数据。**  \n第一行只有一个自然数 $k$ ，表明随后的 $k$ 行每行都是一组数据。  \n接下来 $k$ 行，每行都有五个整数，分别表示队伍里的人数、队形代号（$1$ 表示连续队形，而 $2$ 表示梅花桩队形）、排列方式（$1$ 表示按**行**排列，而 $2$ 表示按**列**排列）、每行（列）的位置数和询问位置的队员的编号。", "outputFormat": "输出 $2k$ 个整数，第 $i$ 对整数表示第 $i$ 组询问的行编号和列编号（不用换行）。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2001] Group Gymnastics Formation", "background": "", "description": "There are $n$ group gymnastics members labeled $1 \\sim n$. Their formation (either continuous formation or \"Meihuazhuang\" formation) can be arranged by rows or by columns. When arranged by rows (or columns), each row (or column) has $r$ positions.\n\nExample 1: $n=16$, $r=6$, continuous formation arranged by rows.\n|1|2|3|4|5|6|\n|:-:|:-:|:-:|-|-|-|\n|**7**|**8**|**9**|**10**|**11**|**12**|\n|**13**|**14**|**15**|**16**|\n\nExample 2: $n=16$, $r=3$, continuous formation arranged by columns.\n|  1  |  4  |  7  |  10  |  13  |16|\n| :-: | :-: | :-: |  :-: |  :-: |- |\n|**2**|**5**|**8**|**11**|**14**|\n|**3**|**6**|**9**|**12**|**15**|\n\nExample 3: $n=16$, $r=7$, \"Meihuazhuang\" formation arranged by rows.\n|  1   |      |  2   |      |  3   |      |  4   |\n| :-:  | :-:  | :-:  | :-:  | :-:  | :-:  | :-:  |\n|      |**5** |      |**6** |      |**7** |      |\n|**8** |      | **9**|      |**10**|      |**11**|\n|      |**12**|      |**13**|      |**14**|      |\n|**15**|      |**16**|      |      |      |      |\n\nExample 4: $n=16$, $r=5$, \"Meihuazhuang\" formation arranged by columns.\n|  1  |     |  6  |      |  11  |      |16 |\n| :-: | :-: | :-: | :-:  | :-:  | :-:  |:-:|\n|     |**4**|     |**9** |      |**14**|   |\n|**2**|     |**7**|      |**12**|      |   |\n|     |**5**|     |**10**|      |**15**|   |\n|**3**|     |**8**|      |**13**|      |   |\n\nPlease write a program to output the row index and column index of the gymnast labeled $m$.", "inputFormat": "This problem contains multiple testcases.\nThe first line has a single natural number $k$, indicating that the following $k$ lines each describe one testcase.\nEach of the next $k$ lines contains five integers, denoting respectively: the number of people in the team, the formation code ($1$ means continuous formation, and $2$ means \"Meihuazhuang\" formation), the arrangement method ($1$ means arranged by rows, and $2$ means arranged by columns), the number of positions per row (or column), and the label of the gymnast being queried.", "outputFormat": "Output $2k$ integers. The $i$-th pair of integers denotes the row index and column index for the $i$-th query (no newline).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2001] 团体操队形", "background": null, "description": "有 $n$ 个团体操队员编号分别为 $1\\sim n$。其队形（分连续队形和梅花桩队形）可以按行排列或者按列排列，按行（列）排列时每行（列）有 $r$ 个位置。 \n\n例 1：$n=16$，$r=6$，连续队形按行排列。\n|1|2|3|4|5|6|\n|:-:|:-:|:-:|-|-|-|\n|**7**|**8**|**9**|**10**|**11**|**12**|\n|**13**|**14**|**15**|**16**|\n\n例 2：$n=16$，$r=3$，连续队形按列排列。\n|  1  |  4  |  7  |  10  |  13  |16|\n| :-: | :-: | :-: |  :-: |  :-: |- |\n|**2**|**5**|**8**|**11**|**14**|\n|**3**|**6**|**9**|**12**|**15**|\n\n例 3：$n=16$，$r=7$，梅花桩队形按行排列。\n|  1   |      |  2   |      |  3   |      |  4   |\n| :-:  | :-:  | :-:  | :-:  | :-:  | :-:  | :-:  |\n|      |**5** |      |**6** |      |**7** |      |\n|**8** |      | **9**|      |**10**|      |**11**|\n|      |**12**|      |**13**|      |**14**|      |\n|**15**|      |**16**|      |      |      |      |\n\n例 4：$n=16$，$r=5$，梅花桩队形按列排列。\n|  1  |     |  6  |      |  11  |      |16 |\n| :-: | :-: | :-: | :-:  | :-:  | :-:  |:-:|\n|     |**4**|     |**9** |      |**14**|   |\n|**2**|     |**7**|      |**12**|      |   |\n|     |**5**|     |**10**|      |**15**|   |\n|**3**|     |**8**|      |**13**|      |   |\n\n现请你编写程序指出编号为 $m$ 的团体操队员所处位置的行号和列号。", "inputFormat": "**本题有多组数据。**  \n第一行只有一个自然数 $k$ ，表明随后的 $k$ 行每行都是一组数据。  \n接下来 $k$ 行，每行都有五个整数，分别表示队伍里的人数、队形代号（$1$ 表示连续队形，而 $2$ 表示梅花桩队形）、排列方式（$1$ 表示按**行**排列，而 $2$ 表示按**列**排列）、每行（列）的位置数和询问位置的队员的编号。", "outputFormat": "输出 $2k$ 个整数，第 $i$ 对整数表示第 $i$ 组询问的行编号和列编号（不用换行）。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2553", "type": "P", "difficulty": 4, "samples": [["(5a^2+3a^1+2)*(4a^1+1)\n(5a^1+1)*(5a^1+1)", "20a^3+17a^2+11a^1+2\n25a^2+10a^1+1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["模拟", "数学", "2001", "各省省选", "安徽"], "title": "[AHOI2001] 多项式乘法", "background": "", "description": "请编程序把含有乘法运算的代数多项式表达式改写成不含乘法的代数多项式。为简化计算，特做以下约定：\n\n1. 代数多项式表达式中只涉及一个代数符号 `a`；\n2. 保证输入的「含乘法运算的代数多项式」有且仅有一个「代数多项式」与「代数多项式」的乘法。形式化地讲，每一个测试点的输入数据中，一定有且仅有一行 `(...)*(...)`，其中 `...` 为不含乘法运算的代数多项式。\n3. 一个「不含乘法运算的代数多项式」会被写作 `XXXa^YYY+XXXa^YYY+XXXa^YYY+...+XXX`（代表 $\\text{XXX}a ^ \\text{YYY} + \\text{XXX}a ^ \\text{YYY} + \\text{XXX}a ^ \\text{YYY} + \\cdots + \\text{XXX}$），其中 `XXX`、`YYY` 均为正整数，且保证除第一项外每一项的 `YYY` 比上一项的 `YYY` 少 $1$。例如，一个合法的「不含乘法运算的代数多项式」为 `142a^4+9a^3+4a^2+1a^1+3`。\n\n> 对于约定 3，原题目给予了这样一个表述：常数项以外的各项都是 $xa^y$ 的形式，写作 `xa^y`，其中 $x$ 为该项的系数，而 $y$ 是该项的指数。$x = 1$ 时，不得简写成 `a^y`，应写成 `1a^y`。而 $y = 1$ 时，不得简写成 `xa`，应写成 `xa^1`。", "inputFormat": "输入仅有一行字符串，代表给定的「含乘法运算的代数多项式」。\n\n其格式为：`(...)*(...)`，其中 `...` 为不含乘法运算的代数多项式。对于「不含乘法运算的代数多项式」的约束，请参考题目描述。\n", "outputFormat": "输出一行一个字符串，代表答案。\n\n答案要求指数大的项不能出现在指数小的项之后，指数相同的项必须合并同类项。**不允许出现不必要的空白字符**。输出中不允许有括号。", "hint": "关于数据范围以及数据若干格式的说明：\n\n* 系数范围和指数范围均为 $[0,30]$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2001] Polynomial Multiplication", "background": "", "description": "Write a program to rewrite an algebraic polynomial expression that contains a multiplication operation into an algebraic polynomial without multiplication. To simplify the task, we make the following conventions:\n\n1. The algebraic polynomial expression involves only one algebraic symbol `a`.\n2. It is guaranteed that the input “algebraic polynomial with multiplication” contains exactly one multiplication between an “algebraic polynomial” and an “algebraic polynomial”. Formally, in each test, the input has exactly one line `(...)*(...)`, where `...` is an algebraic polynomial without multiplication.\n3. An “algebraic polynomial without multiplication” is written as `XXXa^YYY+XXXa^YYY+XXXa^YYY+...+XXX` (representing $\\text{XXX}a ^ \\text{YYY} + \\text{XXX}a ^ \\text{YYY} + \\text{XXX}a ^ \\text{YYY} + \\cdots + \\text{XXX}$), where `XXX` and `YYY` are positive integers. Moreover, except for the first term, in each subsequent term the `YYY` is exactly $1$ less than that of the previous term. For example, a valid “algebraic polynomial without multiplication” is `142a^4+9a^3+4a^2+1a^1+3`.\n\n> For Convention 3, the original statement is: All non-constant terms are of the form $xa^y$, written as `xa^y`, where $x$ is the coefficient and $y$ is the exponent. When $x = 1$, it must not be abbreviated to `a^y`, and should be written as `1a^y`. When $y = 1$, it must not be abbreviated to `xa`, and should be written as `xa^1`.", "inputFormat": "The input consists of a single line string representing the given “algebraic polynomial with multiplication”.\n\nIts format is: `(...)*(...)`, where `...` is an algebraic polynomial without multiplication. For the constraints on “algebraic polynomial without multiplication,” refer to the Description.", "outputFormat": "Output a single string on one line representing the answer.\n\nTerms with larger exponents must not appear after terms with smaller exponents, and terms with the same exponent must be combined. No unnecessary whitespace characters are allowed. No parentheses are allowed in the output.", "hint": "Notes on Constraints and some format details:\n\n- The ranges of coefficients and exponents are both $[0,30]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2001] 多项式乘法", "background": "", "description": "请编程序把含有乘法运算的代数多项式表达式改写成不含乘法的代数多项式。为简化计算，特做以下约定：\n\n1. 代数多项式表达式中只涉及一个代数符号 `a`；\n2. 保证输入的「含乘法运算的代数多项式」有且仅有一个「代数多项式」与「代数多项式」的乘法。形式化地讲，每一个测试点的输入数据中，一定有且仅有一行 `(...)*(...)`，其中 `...` 为不含乘法运算的代数多项式。\n3. 一个「不含乘法运算的代数多项式」会被写作 `XXXa^YYY+XXXa^YYY+XXXa^YYY+...+XXX`（代表 $\\text{XXX}a ^ \\text{YYY} + \\text{XXX}a ^ \\text{YYY} + \\text{XXX}a ^ \\text{YYY} + \\cdots + \\text{XXX}$），其中 `XXX`、`YYY` 均为正整数，且保证除第一项外每一项的 `YYY` 比上一项的 `YYY` 少 $1$。例如，一个合法的「不含乘法运算的代数多项式」为 `142a^4+9a^3+4a^2+1a^1+3`。\n\n> 对于约定 3，原题目给予了这样一个表述：常数项以外的各项都是 $xa^y$ 的形式，写作 `xa^y`，其中 $x$ 为该项的系数，而 $y$ 是该项的指数。$x = 1$ 时，不得简写成 `a^y`，应写成 `1a^y`。而 $y = 1$ 时，不得简写成 `xa`，应写成 `xa^1`。", "inputFormat": "输入仅有一行字符串，代表给定的「含乘法运算的代数多项式」。\n\n其格式为：`(...)*(...)`，其中 `...` 为不含乘法运算的代数多项式。对于「不含乘法运算的代数多项式」的约束，请参考题目描述。\n", "outputFormat": "输出一行一个字符串，代表答案。\n\n答案要求指数大的项不能出现在指数小的项之后，指数相同的项必须合并同类项。**不允许出现不必要的空白字符**。输出中不允许有括号。", "hint": "关于数据范围以及数据若干格式的说明：\n\n* 系数范围和指数范围均为 $[0,30]$。", "locale": "zh-CN"}}}
{"pid": "P2555", "type": "P", "difficulty": 4, "samples": [["000.89", "0D89"], ["-0020030004.567", "F2Q03W04D567"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2002", "各省省选", "安徽"], "title": "[AHOI2002] 数的朗读", "background": null, "description": "春游时小可可结识了刚回国定居的 Sealock。但是 Sealock 在海外出生，回国后才开始学习汉语。数的朗读成为 Sealock 的一个难题，小可可下决心教会 Sealock 如何朗读绝对值小于 10 亿的数。\n\n小可可知道汉语中有如下的读数规则：\n\n⑴ 首先读符号位， 然后读整数部分， 整数部分之后可能出现小数点， 如果有小数部分则小数点一定出现、并且读出小数点之后读小数部分；\n\n⑵ 符号位的读法是：\n\n(2.1) 正数，不论正号“+”是否出现，都不必读出符号位；\n\n(2.2) 负数的最左边的符号是“-”， 读成“ 负” (以“ F” 来表示“负” )；\n\n⑶ 整数部分的读法是：\n\n(3.1) 如果整数部分不存在或者整数部分全是零则直接读成“零” (以“ 0”来表示“零” )；\n\n(3.2) 否则从整数部分中最左边的非零数字开始读起， 然后以十、 百、 千、 万、亿(分别以“ S”、“ B”、“ Q”、“ W”、“ Y”来表示)等数量单位来拼读整数部分；\n\n⑷ 整数部分中：\n\n(4.1) 每一个非零数字都必须结合各个相应的数量单位读出来；\n\n(4.2) 每一段连续的“零” 只能读成一个“零”， 但是某一段连续的“零”的左侧或者右侧不存在非零数字(这里只考虑整数部分)则这一段“零” 不应该读出来；\n\n⑸ 如果有小数部分，则首先读“点”(以“ D”来表示“点”)，然后从左至右顺序地读出各个小数位。 在读小数部分的时候不可以使用十、 百、 千、 万、亿等数量单位； 但是小数部分的每一个数字都需要读出来， 连续的零不可以读成一个“零”，而应该分别读出；\n\n(6) 如果数中有小数点而没有小数部分，则不应该把小数点读出来。\n\n例如， -0020030004.567 应该读成 `F2Q03W04D567`， 000.89 应该读成 `0D89`。\n\n请你编写程序帮助小可可把给定的数正确地读出来。", "inputFormat": "文件中以一行的形式存放了一个数(不超过 50 个字符)，其绝对值小于 10 亿。", "outputFormat": "以一行的形式输出这个数的正确读法。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2002] Reading Numbers", "background": "", "description": "On a spring outing, Xiao Keke met Sealock, who had just returned to settle down. But Sealock was born overseas and only started learning Chinese after coming back. Reading numbers became a challenge for Sealock, so Xiao Keke decided to teach Sealock how to read numbers whose absolute value is less than 1 billion.\n\nXiao Keke knows the following rules for reading numbers in Chinese:\n\n1) First read the sign, then read the integer part. A decimal point may appear after the integer part. If there is a fractional part, the decimal point must appear and be read out; after that, read the fractional part.\n\n2) How to read the sign:\n   (2.1) For a positive number, regardless of whether the plus sign \"+\" appears, the sign does not need to be read out.\n   (2.2) For a negative number, the leftmost sign is \"-\", read as \"Fu\" (denoted by \"F\").\n\n3) How to read the integer part:\n   (3.1) If the integer part does not exist or the integer part is all zeros, read it directly as \"ling\" (denoted by \"0\").\n   (3.2) Otherwise, start reading from the leftmost nonzero digit of the integer part, and combine digits with the quantity units shi, bai, qian, wan, yi (denoted by \"S\", \"B\", \"Q\", \"W\", \"Y\" respectively) to spell out the integer part.\n\n4) In the integer part:\n   (4.1) Every nonzero digit must be read together with its corresponding quantity unit.\n   (4.2) Each consecutive run of zeros may only be read as a single \"ling\" (\"0\"). However, if there is no nonzero digit on the left or on the right of this run of zeros (only considering the integer part), then this run of zeros should not be read.\n\n5) If there is a fractional part, first read \"dian\" (denoted by \"D\"), then read each digit of the fractional part from left to right in order. Do not use shi, bai, qian, wan, yi or other quantity units in the fractional part. Every digit in the fractional part must be read out, and consecutive zeros must not be merged; they should be read separately.\n\n6) If the number has a decimal point but no fractional part, the decimal point should not be read.\n\nFor example, -0020030004.567 should be read as `F2Q03W04D567`, and 000.89 should be read as `0D89`.\n\nPlease write a program to help Xiao Keke read the given number correctly.", "inputFormat": "A single line containing one number (no more than 50 characters), whose absolute value is less than 1 billion.", "outputFormat": "Output a single line with the correct reading of the number.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2002] 数的朗读", "background": null, "description": "春游时小可可结识了刚回国定居的 Sealock。但是 Sealock 在海外出生，回国后才开始学习汉语。数的朗读成为 Sealock 的一个难题，小可可下决心教会 Sealock 如何朗读绝对值小于 10 亿的数。\n\n小可可知道汉语中有如下的读数规则：\n\n⑴ 首先读符号位， 然后读整数部分， 整数部分之后可能出现小数点， 如果有小数部分则小数点一定出现、并且读出小数点之后读小数部分；\n\n⑵ 符号位的读法是：\n\n(2.1) 正数，不论正号“+”是否出现，都不必读出符号位；\n\n(2.2) 负数的最左边的符号是“-”， 读成“ 负” (以“ F” 来表示“负” )；\n\n⑶ 整数部分的读法是：\n\n(3.1) 如果整数部分不存在或者整数部分全是零则直接读成“零” (以“ 0”来表示“零” )；\n\n(3.2) 否则从整数部分中最左边的非零数字开始读起， 然后以十、 百、 千、 万、亿(分别以“ S”、“ B”、“ Q”、“ W”、“ Y”来表示)等数量单位来拼读整数部分；\n\n⑷ 整数部分中：\n\n(4.1) 每一个非零数字都必须结合各个相应的数量单位读出来；\n\n(4.2) 每一段连续的“零” 只能读成一个“零”， 但是某一段连续的“零”的左侧或者右侧不存在非零数字(这里只考虑整数部分)则这一段“零” 不应该读出来；\n\n⑸ 如果有小数部分，则首先读“点”(以“ D”来表示“点”)，然后从左至右顺序地读出各个小数位。 在读小数部分的时候不可以使用十、 百、 千、 万、亿等数量单位； 但是小数部分的每一个数字都需要读出来， 连续的零不可以读成一个“零”，而应该分别读出；\n\n(6) 如果数中有小数点而没有小数部分，则不应该把小数点读出来。\n\n例如， -0020030004.567 应该读成 `F2Q03W04D567`， 000.89 应该读成 `0D89`。\n\n请你编写程序帮助小可可把给定的数正确地读出来。", "inputFormat": "文件中以一行的形式存放了一个数(不超过 50 个字符)，其绝对值小于 10 亿。", "outputFormat": "以一行的形式输出这个数的正确读法。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2556", "type": "P", "difficulty": 2, "samples": [["8 0", "8"], ["24 210 0 255", "130 1 129 2 129 9 136"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2002", "各省省选", "安徽"], "title": "[AHOI2002] 黑白图像压缩", "background": "", "description": "选修基础生物基因学的时候， 小可可在家里做了一次图像学试验。 她知道：整个图像其实就是若干个图像点(称作像素)的序列，假定序列中像素的个数总是 8 的倍数， 于是每八个像素可以转换成一个叫做字节的数， 从而这个表示图像的像素序列就被转换成了字节的序列。\n\n所谓的字节就是一个八位的二进制数(当然，为了便于书写，人们经常用它的十进制形式来表示)。这八个像素从前向后依次对应于字节从高位到低位的八个位， 用 0 来表示白色像素、 1 来表示黑色像素。 这种表示方法叫做位图法。 例如字节序列 210、 0、255 表示了 8\\*3=24 个像素， 由于对应的二进制形式是 11010010、 00000000、11111111， 所以这 24 个像素的颜色依次是黑、 黑、 白、 黑、 白、 白、 黑、 白、白、白、白、白、白、白、白、白、黑、黑、黑、黑、黑、黑、黑、黑。\n\n小可可想： 其实图像中存在着很多连续的同色像素段， 也许换一种方式表达图像能够减少图像的数据量。 她的思路是： 把像素按照颜色分成若干个片段， 同一个片段中各像素颜色相同， 且连续的同色像素都在同一个片段中。同时已知每个片段的最大长度小于 128。\n\n每一个像素片段都是用一个二进制字节量来表示， 最高位表示片段中像素的颜色， 而低七位表示片段中像素的数目。注意：不存在长度为 0 的像素片段。这种表示法叫做像素片段法。\n\n例如位图表示法的字节序列 210、 0、 255 对应的像素序列可以分成七个片段，分别是： 11、 0、 1、 00、 1、 000000000、 11111111。如果用像素片段法来表示的话，二进制字节序列应该写成 10000010、 00000001、 10000001、00000010、 10000001、 00001001、 10001000， 而其对应于十进制字节序列就是 130、 1、 129、 2、 129、 9、 136。\n\n像素片段法是否能有效地减少图像的数据存储量呢？小可可不知道如何用数学的方法加以证明， 于是决心对手头上的图像做些试验， 看看该方法是否真的有效。 请你编写程序完成图像信息的转换， 以协助小可可完成这项试验。\n", "inputFormat": "文件中以一行的形式存放了一个图像的信息。第一个数是正整数 $n$ ，表明该图像有 $n$ 个像素。随后有 $\\frac{n}{8}$ 个十进制形式的字节量，表示该图像的位图信息。相邻数之间用一个空白字符隔开。", "outputFormat": "以一行的形式输出以像素片段表示法表示的图像信息，各个数都以\n\n十进制的形式出现，相邻数之间用一个空白字符隔开。\n", "hint": "$1\\leq n\\leq 8\\times 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2002] Black-and-White Image Compression", "background": "", "description": "While taking an elective in basic genetics, Xiao Keke did a home experiment related to image processing. She knows that an entire image is actually a sequence of image points (called pixels). Assume the number of pixels in the sequence is always a multiple of 8, so every eight pixels can be converted into a number called a byte, thereby converting the pixel sequence representing the image into a sequence of bytes.\n\nA byte is an 8-bit binary number (of course, for convenience, people often write it in decimal). The eight pixels, from earlier to later, correspond to the eight bits of the byte from the most significant bit to the least significant bit. Use 0 for a white pixel and 1 for a black pixel. This representation is called the bitmap method. For example, the byte sequence 210, 0, 255 represents $8 \\times 3 = 24$ pixels. Since their binary forms are 11010010, 00000000, 11111111, the colors of these 24 pixels in order are: black, black, white, black, white, white, black, white, white, white, white, white, white, white, white, white, black, black, black, black, black, black, black, black.\n\nXiao Keke thought: there are many runs of consecutive pixels with the same color in an image; maybe using another way to express the image could reduce the data size. Her idea is to divide the pixels into several segments by color, where all pixels in the same segment have the same color, and every consecutive run of same-color pixels belongs to a single segment. It is also known that the maximum length of each segment is less than 128.\n\nEach pixel segment is represented by one binary byte. The most significant bit indicates the color of the pixels in the segment, and the lower seven bits indicate the number of pixels in the segment. Note: segments of length 0 do not exist. This representation is called the pixel segment method.\n\nFor example, the pixel sequence corresponding to the bitmap byte sequence 210, 0, 255 can be divided into seven segments: 11, 0, 1, 00, 1, 000000000, 11111111. If represented by the pixel segment method, the binary byte sequence should be 10000010, 00000001, 10000001, 00000010, 10000001, 00001001, 10001000, and the corresponding decimal byte sequence is 130, 1, 129, 2, 129, 9, 136.\n\nCan the pixel segment method effectively reduce the amount of image data? Xiao Keke does not know how to prove it mathematically, so she decides to experiment on the images at hand to see whether this method really works. Please write a program to perform the conversion of image information to assist Xiao Keke in this experiment.", "inputFormat": "The file contains one line describing an image. The first number is a positive integer $n$, indicating that the image has $n$ pixels. It is followed by $\\frac{n}{8}$ bytes in decimal form, representing the bitmap information of the image. Adjacent numbers are separated by a single whitespace character.", "outputFormat": "Output on a single line the image information encoded by the pixel segment method. All numbers should be in decimal, and adjacent numbers should be separated by a single whitespace character.", "hint": "$1 \\le n \\le 8 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2002] 黑白图像压缩", "background": "", "description": "选修基础生物基因学的时候， 小可可在家里做了一次图像学试验。 她知道：整个图像其实就是若干个图像点(称作像素)的序列，假定序列中像素的个数总是 8 的倍数， 于是每八个像素可以转换成一个叫做字节的数， 从而这个表示图像的像素序列就被转换成了字节的序列。\n\n所谓的字节就是一个八位的二进制数(当然，为了便于书写，人们经常用它的十进制形式来表示)。这八个像素从前向后依次对应于字节从高位到低位的八个位， 用 0 来表示白色像素、 1 来表示黑色像素。 这种表示方法叫做位图法。 例如字节序列 210、 0、255 表示了 8\\*3=24 个像素， 由于对应的二进制形式是 11010010、 00000000、11111111， 所以这 24 个像素的颜色依次是黑、 黑、 白、 黑、 白、 白、 黑、 白、白、白、白、白、白、白、白、白、黑、黑、黑、黑、黑、黑、黑、黑。\n\n小可可想： 其实图像中存在着很多连续的同色像素段， 也许换一种方式表达图像能够减少图像的数据量。 她的思路是： 把像素按照颜色分成若干个片段， 同一个片段中各像素颜色相同， 且连续的同色像素都在同一个片段中。同时已知每个片段的最大长度小于 128。\n\n每一个像素片段都是用一个二进制字节量来表示， 最高位表示片段中像素的颜色， 而低七位表示片段中像素的数目。注意：不存在长度为 0 的像素片段。这种表示法叫做像素片段法。\n\n例如位图表示法的字节序列 210、 0、 255 对应的像素序列可以分成七个片段，分别是： 11、 0、 1、 00、 1、 000000000、 11111111。如果用像素片段法来表示的话，二进制字节序列应该写成 10000010、 00000001、 10000001、00000010、 10000001、 00001001、 10001000， 而其对应于十进制字节序列就是 130、 1、 129、 2、 129、 9、 136。\n\n像素片段法是否能有效地减少图像的数据存储量呢？小可可不知道如何用数学的方法加以证明， 于是决心对手头上的图像做些试验， 看看该方法是否真的有效。 请你编写程序完成图像信息的转换， 以协助小可可完成这项试验。\n", "inputFormat": "文件中以一行的形式存放了一个图像的信息。第一个数是正整数 $n$ ，表明该图像有 $n$ 个像素。随后有 $\\frac{n}{8}$ 个十进制形式的字节量，表示该图像的位图信息。相邻数之间用一个空白字符隔开。", "outputFormat": "以一行的形式输出以像素片段表示法表示的图像信息，各个数都以\n\n十进制的形式出现，相邻数之间用一个空白字符隔开。\n", "hint": "$1\\leq n\\leq 8\\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2557", "type": "P", "difficulty": 4, "samples": [["1 1", "1"], ["2 2", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2002", "各省省选", "安徽"], "title": "[AHOI2002] 芝麻开门", "background": "", "description": "周末小可可参加智力大冲浪活动，经过努力终于来到最后一关“芝麻开门”。门上的电子显示屏写着这么一段话：如果你能把 $n^k$ 的所有正整数因子的和正确地写在门上，并念一声“芝麻开门”，门就能够自由打开。\n\n例如：$n=2$，$k=3$，则 $n^k=8$，它的正因子有 $1,2,4,8$，如果小可可把它们的和 $15$ 写在门上，然后念一声“芝麻开门”，门就能够自动打开。\n\n已知门上的 $n,k$ 都是每过一段时间就会变化一次，请你编写程序协助小可可在规定的时间内求出答案，从而获得智力大冲浪的最终大奖。\n", "inputFormat": "一行两个正整数 $n,k$。\n", "outputFormat": "一行一个整数表示答案。\n", "hint": "$1\\le  n  \\le 2^{16}$，$1\\le k \\lt 20$。\n\n解的位数不超过 $100$ 位。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2002] Open Sesame", "background": "", "description": "On the weekend, little Keke takes part in a brain-power surfing challenge and finally reaches the last level, \"Open Sesame.\" The electronic display on the door says: If you can correctly write on the door the sum of all positive integer divisors of $n^k$, and say \"Open Sesame,\" the door will open freely.\n\nFor example: $n=2$, $k=3$, then $n^k=8$. Its positive divisors are $1, 2, 4, 8$. If Keke writes their sum $15$ on the door and then says \"Open Sesame,\" the door will open automatically.\n\nIt is known that the values $n$ and $k$ on the door change from time to time. Please write a program to help Keke compute the answer within the allotted time, so as to win the final prize of the challenge.", "inputFormat": "One line with two positive integers $n$ and $k$.", "outputFormat": "One line with one integer representing the answer.", "hint": "$1\\le  n  \\le 2^{16}$, $1\\le k \\lt 20$.\n\nThe answer has at most $100$ digits.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2002] 芝麻开门", "background": "", "description": "周末小可可参加智力大冲浪活动，经过努力终于来到最后一关“芝麻开门”。门上的电子显示屏写着这么一段话：如果你能把 $n^k$ 的所有正整数因子的和正确地写在门上，并念一声“芝麻开门”，门就能够自由打开。\n\n例如：$n=2$，$k=3$，则 $n^k=8$，它的正因子有 $1,2,4,8$，如果小可可把它们的和 $15$ 写在门上，然后念一声“芝麻开门”，门就能够自动打开。\n\n已知门上的 $n,k$ 都是每过一段时间就会变化一次，请你编写程序协助小可可在规定的时间内求出答案，从而获得智力大冲浪的最终大奖。\n", "inputFormat": "一行两个正整数 $n,k$。\n", "outputFormat": "一行一个整数表示答案。\n", "hint": "$1\\le  n  \\le 2^{16}$，$1\\le k \\lt 20$。\n\n解的位数不超过 $100$ 位。", "locale": "zh-CN"}}}
{"pid": "P2558", "type": "P", "difficulty": 4, "samples": [["3 2", "3"], ["3 7", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "2002", "各省省选", "安徽", "栈"], "title": "[AHOI2002] 网络传输", "background": "", "description": "在计算机网络中所有数据都是以二进制形式来传输的。但是在进行较大数据的传输时，直接使用该数的二进制形式加以传输则往往传输的位数过多。譬如要传输 $1024$ 就需要 $11$ 位二进制数。于是小可可提出了一种数据优化传输的设想，并打算对这一设想进行试验。\n\n该设想是：正整数的所有方幂以及任意多个互不相等的 $k$ 的方幂之和排成一个递增数列 $\\{a(k)n\\}$，例如当 $k=3$ 时，$\\{a(k)n\\}$ 的前 $7$ 项为 $1(=3^0)$ 、 $3(=3^1)$ 、 $4(=3^0+3^1)$ 、 $9(=3^2)$ 、 $10(=3^0+3^2)$ 、 $12(=3^1+3^2)$ 、 $13(=3^0+3^1+3^2)$。\n\n如果数 $d$ 是数列 $\\{a(k)n\\}$ 中的第 $p$ 项，则可以通过传送 $k$ 和 $p$ 这两个数来表示数 $d$。由于 $k$ 和 $p$ 这两个相对很小的数就可以表达出很大的数，因而理论上可以减少网络传输的位数。\n\n小可可现在请你编写程序把接收到的数 $k$ 和 $p$ 所代表的数 $d$ 计算出来。", "inputFormat": "文件中以一行的形式存放了两个正整数 $k$ 和 $p$，$1<k \\le 1024$，\n$1 \\le p \\le 1024$。", "outputFormat": "以一行的形式输出问题的解（解的位数不超过 $50$ 位）。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2002] Network Transmission", "background": "", "description": "In computer networks, all data are transmitted in binary form. However, when transmitting large data, directly sending its binary representation often requires too many bits. For example, transmitting $1024$ needs an $11$-bit binary number. Therefore, Xiao Keke proposed an idea for optimizing data transmission and plans to test it.\n\nThe idea is: arrange in increasing order the sequence $\\{a(k)_n\\}$ consisting of all positive integer powers of $k$, as well as sums of any number of pairwise distinct powers of $k$. For example, when $k = 3$, the first $7$ terms of $\\{a(k)_n\\}$ are $1(=3^0)$, $3(=3^1)$, $4(=3^0+3^1)$, $9(=3^2)$, $10(=3^0+3^2)$, $12(=3^1+3^2)$, $13(=3^0+3^1+3^2)$.\n\nIf a number $d$ is the $p$-th term of the sequence $\\{a(k)_n\\}$, then one can represent $d$ by transmitting the two numbers $k$ and $p$. Since the relatively small numbers $k$ and $p$ can represent a very large number, this can theoretically reduce the number of bits transmitted.\n\nNow Xiao Keke asks you to write a program to compute the number $d$ represented by the received $k$ and $p$.", "inputFormat": "A single line contains two positive integers $k$ and $p$, with $1 < k \\le 1024$, $1 \\le p \\le 1024$.", "outputFormat": "Output the answer in one line (the number of digits does not exceed $50$).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2002] 网络传输", "background": "", "description": "在计算机网络中所有数据都是以二进制形式来传输的。但是在进行较大数据的传输时，直接使用该数的二进制形式加以传输则往往传输的位数过多。譬如要传输 $1024$ 就需要 $11$ 位二进制数。于是小可可提出了一种数据优化传输的设想，并打算对这一设想进行试验。\n\n该设想是：正整数的所有方幂以及任意多个互不相等的 $k$ 的方幂之和排成一个递增数列 $\\{a(k)n\\}$，例如当 $k=3$ 时，$\\{a(k)n\\}$ 的前 $7$ 项为 $1(=3^0)$ 、 $3(=3^1)$ 、 $4(=3^0+3^1)$ 、 $9(=3^2)$ 、 $10(=3^0+3^2)$ 、 $12(=3^1+3^2)$ 、 $13(=3^0+3^1+3^2)$。\n\n如果数 $d$ 是数列 $\\{a(k)n\\}$ 中的第 $p$ 项，则可以通过传送 $k$ 和 $p$ 这两个数来表示数 $d$。由于 $k$ 和 $p$ 这两个相对很小的数就可以表达出很大的数，因而理论上可以减少网络传输的位数。\n\n小可可现在请你编写程序把接收到的数 $k$ 和 $p$ 所代表的数 $d$ 计算出来。", "inputFormat": "文件中以一行的形式存放了两个正整数 $k$ 和 $p$，$1<k \\le 1024$，\n$1 \\le p \\le 1024$。", "outputFormat": "以一行的形式输出问题的解（解的位数不超过 $50$ 位）。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2559", "type": "P", "difficulty": 3, "samples": [["0 1 0 0 0 0 0\n1 4\n4\n1 2 1\n1 3 1\n2 4 2\n3 4 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2002", "各省省选", "安徽"], "title": "[AHOI2002] 哈利·波特与魔法石", "background": null, "description": "大年初三的那个晚上，小可可去电影院看了《哈利·波特与魔法石》，回到家坐在椅子上不一会儿就睡着了，并且梦见自己成了哈利·波特在充满了正义与邪恶的宇宙中执着地为了正义而战。  \n\n那天哈利·波特去拯救 Super Samuel 星球上的生灵。该星球上有七种不同的地形，依次分别是石子路、森林、草地、山地、雪地、沼泽和沙漠，用数字 $1\\sim7$ 来表示。任意两个城市之间都有至少一条道路，而且任意两个能够不经过别的城市而直接通达的城市 $i$ 和 $j$ 之间都只有一种地形 $t_{i,j}$。奇怪的是，在 Super Samuel 星球上哈利·波特穿越地形 $u$ 所需要的时间与该地形的区域大小无关，却与地形 $u$ 的区域中是否有魔法石有关。如果地形 $u$ 的区域中没有魔法石，哈利·波特要花费 $h_u$ 的时间才能穿越该区域，否则他只要花一半的时间就能穿越了。已知 $h_1=2, h_2=6, h_3=4, h_4=8, h_5=6, h_6=10, h_7=14$。\n\n- $s_u=1$ 表示地形 $u$ 的区域中有魔法石；\n- $s_u=0$ 表示地形 $u$ 的区域中没有魔法石。\n\n例如，如下图所示，有 $4$ 对可以直接通达的城市(城市 $1$ 与 $2$、$1$ 与 $3$、$2$ 与 $4$ 以及 $3$ 与 $4$)；$s_1=0, s_2=1, s_3=4, s_5=6, s_6=7$，即只有森林中有魔法石，因此穿越森林所花的时间是 $\\frac{6}{2}=3$，穿越石子路和草地的时间仍然是 $2$ 和 $4$。如果哈利·波特想从城市 $1$ 到达城市 $4$，则最快的路线是经过城市 $2$，这条路线需要的时间是 $2+3=5$。\n\n![graph](https://cdn.luogu.com.cn/upload/image_hosting/jepqly4c.png)\n\n哈利·波特总是忙于铲除邪恶、伸张正义，没有时间去寻找从起点城市到终点城市的路径。现在请你作为哈利·波特的助手编写程序来找到最快路线为哈利·波特腾出更多的时间来将正义事业进行到底。", "inputFormat": "第一行输入七个数，分别是 $S_1, S_2 ,\\dots, S_7$。\n\n第二行输入两个数，依次分别是起点城市 $i$ 和终点城市 $j$。\n\n第三行输入一个正整数 $c$（$c\\le10000$），随后的 $c$ 行中每行存放了一对能直接通达的城市的信息。能直接通达的城市的信息由三个数组成，依次分别是两个城市的编号和这两个城市之间的地形。城市的编号都是不超过 $100$ 的正整数，但是各个城市的编号未必连续。\n\n输入文件里同一行中相邻的两个数用一个空白字符隔开。", "outputFormat": "输出一行一个整数，表示起点城市 $i$ 与终点城市 $j$ 之间的最快路线所需要的时间。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2002] Harry Potter and the Sorcerer's Stone", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1681.png)", "inputFormat": "The first line of the input file contains seven numbers, namely $S_1, S_2, \\dots, S_7$. The second line contains two numbers: the starting city $i$ and the destination city $j$. The third line contains a positive integer $c$, with $c \\le 10000$, indicating that each of the following $c$ lines stores a pair of cities that are directly reachable from each other.\n\nThe information for a pair of directly reachable cities consists of three numbers: the indices of the two cities and the terrain type between these two cities. City indices are positive integers not exceeding $100$, but the indices are not necessarily continuous.\n\nOn the same line in the file, any two adjacent numbers are separated by a single whitespace character.", "outputFormat": "Output a single line with the time required by the fastest route between the starting city $i$ and the destination city $j$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2002] 哈利·波特与魔法石", "background": null, "description": "大年初三的那个晚上，小可可去电影院看了《哈利·波特与魔法石》，回到家坐在椅子上不一会儿就睡着了，并且梦见自己成了哈利·波特在充满了正义与邪恶的宇宙中执着地为了正义而战。  \n\n那天哈利·波特去拯救 Super Samuel 星球上的生灵。该星球上有七种不同的地形，依次分别是石子路、森林、草地、山地、雪地、沼泽和沙漠，用数字 $1\\sim7$ 来表示。任意两个城市之间都有至少一条道路，而且任意两个能够不经过别的城市而直接通达的城市 $i$ 和 $j$ 之间都只有一种地形 $t_{i,j}$。奇怪的是，在 Super Samuel 星球上哈利·波特穿越地形 $u$ 所需要的时间与该地形的区域大小无关，却与地形 $u$ 的区域中是否有魔法石有关。如果地形 $u$ 的区域中没有魔法石，哈利·波特要花费 $h_u$ 的时间才能穿越该区域，否则他只要花一半的时间就能穿越了。已知 $h_1=2, h_2=6, h_3=4, h_4=8, h_5=6, h_6=10, h_7=14$。\n\n- $s_u=1$ 表示地形 $u$ 的区域中有魔法石；\n- $s_u=0$ 表示地形 $u$ 的区域中没有魔法石。\n\n例如，如下图所示，有 $4$ 对可以直接通达的城市(城市 $1$ 与 $2$、$1$ 与 $3$、$2$ 与 $4$ 以及 $3$ 与 $4$)；$s_1=0, s_2=1, s_3=4, s_5=6, s_6=7$，即只有森林中有魔法石，因此穿越森林所花的时间是 $\\frac{6}{2}=3$，穿越石子路和草地的时间仍然是 $2$ 和 $4$。如果哈利·波特想从城市 $1$ 到达城市 $4$，则最快的路线是经过城市 $2$，这条路线需要的时间是 $2+3=5$。\n\n![graph](https://cdn.luogu.com.cn/upload/image_hosting/jepqly4c.png)\n\n哈利·波特总是忙于铲除邪恶、伸张正义，没有时间去寻找从起点城市到终点城市的路径。现在请你作为哈利·波特的助手编写程序来找到最快路线为哈利·波特腾出更多的时间来将正义事业进行到底。", "inputFormat": "第一行输入七个数，分别是 $S_1, S_2 ,\\dots, S_7$。\n\n第二行输入两个数，依次分别是起点城市 $i$ 和终点城市 $j$。\n\n第三行输入一个正整数 $c$（$c\\le10000$），随后的 $c$ 行中每行存放了一对能直接通达的城市的信息。能直接通达的城市的信息由三个数组成，依次分别是两个城市的编号和这两个城市之间的地形。城市的编号都是不超过 $100$ 的正整数，但是各个城市的编号未必连续。\n\n输入文件里同一行中相邻的两个数用一个空白字符隔开。", "outputFormat": "输出一行一个整数，表示起点城市 $i$ 与终点城市 $j$ 之间的最快路线所需要的时间。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2560", "type": "P", "difficulty": 4, "samples": [["3 2\n11000101\n10 10 5 6 3 2 1 2", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2002", "各省省选", "安徽"], "title": "[AHOI2002] Kitty猫基因突变", "background": "", "description": " ![](https://cdn.luogu.com.cn/upload/pic/1682.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/1683.png)\n", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1684.png)\n", "outputFormat": "以一行的形式输出评价效果最好的突变方案的评价指标。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2002] Kitty Cat Gene Mutation", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1682.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/1683.png)", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1684.png)", "outputFormat": "Output, in a single line, the evaluation metric of the mutation scheme with the best performance.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2002] Kitty猫基因突变", "background": "", "description": " ![](https://cdn.luogu.com.cn/upload/pic/1682.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/1683.png)\n", "inputFormat": "![](https://cdn.luogu.com.cn/upload/pic/1684.png)\n", "outputFormat": "以一行的形式输出评价效果最好的突变方案的评价指标。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2561", "type": "P", "difficulty": 6, "samples": [["1", "2"], ["2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "数学", "2002", "各省省选", "安徽", "置换"], "title": "[AHOI2002] 黑白瓷砖", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1685.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/1686.png)\n", "inputFormat": "一行，一个正整数 $n$，$n \\leq 20$ 。\n", "outputFormat": "以一行的形式输出问题的解 $s$ (解的位数不超过 $200$ 位)。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2002] Black and White Tiles", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1685.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/1686.png)", "inputFormat": "One line containing a positive integer $n$, where $n \\leq 20$.", "outputFormat": "Output, in one line, the solution $s$ (the number of digits of the answer does not exceed 200).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2002] 黑白瓷砖", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1685.png) \n\n![](https://cdn.luogu.com.cn/upload/pic/1686.png)\n", "inputFormat": "一行，一个正整数 $n$，$n \\leq 20$ 。\n", "outputFormat": "以一行的形式输出问题的解 $s$ (解的位数不超过 $200$ 位)。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2562", "type": "P", "difficulty": 2, "samples": [["00", "A"], ["01001011", "CCCABACCBAB"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "2002", "各省省选", "递归", "安徽"], "title": "[AHOI2002] Kitty猫基因编码", "background": null, "description": "小可可选修了基础生物基因学。教授告诉大家 Super Samuel 星球上 Kitty猫的基因的长度都是 $2$ 的正整数次幂，全是由两种不同的基因单元组成的。 这两种不同的基因单元分别记成 $0$ 和 $1$，于是 Kitty 猫基因可以写成一个 $01$ 串表达式 。\n\n为了便于分析和降低数据存储量，教授发明了 ABC 编码规则。该编码规则是不断地按照\n\n ![](https://cdn.luogu.com.cn/upload/pic/1679.png) \n\n对 Kitty 猫基因 $01$ 串表达式 进行改写， 直至最终被改写成只含有字符 “ A”、“ B”、“ C”的符号串。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1680.png) \n\n请你编写程序帮助小可可求出 Kitty 猫基因的 ABC 编码以协助教授开展科研工作。", "inputFormat": "文件中以一行的形式存放了一个 Kitty 猫基因的 $01$ 串表达式。", "outputFormat": "以一行的形式输出这个 Kitty 猫基因的 ABC 编码。", "hint": "给出的 $01$ 字符串长度 $Len\\leq 256$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2002] Kitty Cat Gene Encoding", "background": "", "description": "Xiao Keke took an elective course in basic genetics. The professor told the class that on the planet Super Samuel, the lengths of Kitty cats’ genes are all positive integer powers of $2$, and they consist of two different gene units. These two different gene units are denoted as 0 and 1, so a Kitty cat’s gene can be written as a 01 string.\n\nTo facilitate analysis and reduce storage, the professor invented the ABC encoding rule. This encoding repeatedly rewrites the Kitty cat gene’s 01 string according to\n\n ![](https://cdn.luogu.com.cn/upload/pic/1679.png) \n\nuntil it is finally rewritten into a string containing only the characters \"A\", \"B\", and \"C\".\n\n ![](https://cdn.luogu.com.cn/upload/pic/1680.png) \n\nPlease write a program to help Xiao Keke compute the ABC encoding of a Kitty cat gene to assist the professor’s research.", "inputFormat": "The file contains one line, which is a 01 string representing a Kitty cat gene.", "outputFormat": "Output one line containing the ABC encoding of this Kitty cat gene.", "hint": "The given 01 string length satisfies $Len \\leq 256$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2002] Kitty猫基因编码", "background": null, "description": "小可可选修了基础生物基因学。教授告诉大家 Super Samuel 星球上 Kitty猫的基因的长度都是 $2$ 的正整数次幂，全是由两种不同的基因单元组成的。 这两种不同的基因单元分别记成 $0$ 和 $1$，于是 Kitty 猫基因可以写成一个 $01$ 串表达式 。\n\n为了便于分析和降低数据存储量，教授发明了 ABC 编码规则。该编码规则是不断地按照\n\n ![](https://cdn.luogu.com.cn/upload/pic/1679.png) \n\n对 Kitty 猫基因 $01$ 串表达式 进行改写， 直至最终被改写成只含有字符 “ A”、“ B”、“ C”的符号串。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1680.png) \n\n请你编写程序帮助小可可求出 Kitty 猫基因的 ABC 编码以协助教授开展科研工作。", "inputFormat": "文件中以一行的形式存放了一个 Kitty 猫基因的 $01$ 串表达式。", "outputFormat": "以一行的形式输出这个 Kitty 猫基因的 ABC 编码。", "hint": "给出的 $01$ 字符串长度 $Len\\leq 256$。", "locale": "zh-CN"}}}
{"pid": "P2563", "type": "P", "difficulty": 2, "samples": [["2\n200", "1\n9845164"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["2001", "各省省选", "安徽", "背包 DP", "素数判断,质数,筛法"], "title": "[AHOI2001] 质数和分解", "background": "", "description": "任何大于 $1$ 的自然数 $n$ 都可以写成若干个大于等于 $2$ 且小于等于 $n$ 的质数之和表达式(包括只有一个数构成的和表达式的情况)，并且可能有不止一种质数和的形式。例如，$9$ 的质数和表达式就有四种本质不同的形式：\n\n$9 = 2 + 5 + 2 = 2 + 3 + 2 + 2 = 3 + 3 + 3 = 2 + 7$ 。\n\n这里所谓两个本质相同的表达式是指可以通过交换其中一个表达式中参加和运算的各个数的位置而直接得到另一个表达式。\n\n试编程求解自然数 $n$ 可以写成多少种本质不同的质数和表达式。\n", "inputFormat": "文件中的每一行存放一个自然数 $n(2 \\leq n \\leq 200)$ 。\n", "outputFormat": "依次输出每一个自然数 $n$ 的本质不同的质数和表达式的数目。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2001] Prime Sum Decomposition", "background": "", "description": "Any natural number $n$ greater than $1$ can be written as a sum of primes each greater than or equal to $2$ and less than or equal to $n$ (including the case where the sum consists of only one number), and there may be more than one such prime-sum form. For example, the prime-sum expressions of $9$ have four essentially different forms:\n\n$9 = 2 + 5 + 2 = 2 + 3 + 2 + 2 = 3 + 3 + 3 = 2 + 7$。\n\nTwo expressions are considered essentially the same if one can be obtained from the other by permuting the addends.\n\nWrite a program to compute how many essentially different prime-sum expressions a natural number $n$ can have.", "inputFormat": "Each line of the file contains a natural number $n$ ($2 \\leq n \\leq 200$).", "outputFormat": "For each natural number $n$, output the number of essentially different prime-sum expressions.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2001] 质数和分解", "background": "", "description": "任何大于 $1$ 的自然数 $n$ 都可以写成若干个大于等于 $2$ 且小于等于 $n$ 的质数之和表达式(包括只有一个数构成的和表达式的情况)，并且可能有不止一种质数和的形式。例如，$9$ 的质数和表达式就有四种本质不同的形式：\n\n$9 = 2 + 5 + 2 = 2 + 3 + 2 + 2 = 3 + 3 + 3 = 2 + 7$ 。\n\n这里所谓两个本质相同的表达式是指可以通过交换其中一个表达式中参加和运算的各个数的位置而直接得到另一个表达式。\n\n试编程求解自然数 $n$ 可以写成多少种本质不同的质数和表达式。\n", "inputFormat": "文件中的每一行存放一个自然数 $n(2 \\leq n \\leq 200)$ 。\n", "outputFormat": "依次输出每一个自然数 $n$ 的本质不同的质数和表达式的数目。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2564", "type": "P", "difficulty": 4, "samples": [["6 3\n1 5\n2 1 7\n3 1 3 8\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "四川", "各省省选", "单调队列", "队列"], "title": "[SCOI2009] 生日礼物", "background": "四川2009NOI省选\n", "description": "\n小西有一条很长的彩带，彩带上挂着各式各样的彩珠。已知彩珠有 $N$ 个，分为 $K$ 种。简单的说，可以将彩带抽象为一个 x 轴，每一个彩珠有一个对应的坐标（即位置）。某些坐标上可以没有彩珠，但多个彩珠也可以出现在同一个位置上。\n\n小布的生日快到了，于是小西打算剪一段彩带送给小布。为了让礼物彩带足够漂亮，小西希望这一段彩带中能包含所有种类的彩珠。同时，为了方便，小西希望这段彩带尽可能短，你能帮助小西计算这个最短的长度么？\n\n彩带的长度即为彩带开始位置到结束位置的位置差。\n", "inputFormat": "第一行包含两个整数 $N, K$，分别表示彩珠的总数以及种类数。\n\n接下来 $K$ 行，每行第一个数为 $T_i$，表示第 $i$ 种彩珠的数目。\n\n接下来按升序给出 $T_i$ 个非负整数，为这 $T_i$ 个彩珠分别出现的位置。", "outputFormat": "输出应包含一行，为最短彩带长度。\n", "hint": "\n### 样例说明\n\n有多种方案可选，其中比较短的是 $1 \\sim 5$ 和 $5 \\sim 8$。后者长度为 $3$，更短，故答案为 $3$。\n\n### 数据范围\n\n对于 $50\\%$ 的数据，$N \\le 10^4$；\n\n对于 $80\\%$ 的数据，$N \\le 8 \\times 10^5$；\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^6, 1 \\le K \\le 60$，$0 \\le$ 珠子位置 $< 2^{31}$，且 $\\sum T_i = N$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2009] Birthday Gift", "background": "Sichuan 2009 NOI Qualifier.", "description": "Xiaoxi has a very long ribbon with various colored beads hanging on it. There are $N$ beads in total, divided into $K$ types. Simply put, we can model the ribbon as the x-axis, and each bead corresponds to a coordinate (i.e., a position). Some coordinates may have no bead, and multiple beads may appear at the same position.\n\nXiaobu’s birthday is coming, so Xiaoxi plans to cut a segment of the ribbon as a gift. To make the gift look nice, she wants this segment to contain all types of beads. For convenience, she also wants the segment to be as short as possible. Can you help Xiaoxi find this minimum length?\n\nThe length of a ribbon segment is the difference between the end position and the start position.", "inputFormat": "The first line contains two integers $N, K$, the total number of beads and the number of types.\n\nFor each of the next $K$ lines, the first number is $T_i$, the count of beads of type $i$.\n\nOn the same line, $T_i$ non-negative integers are then given in ascending order, representing the positions where these $T_i$ beads appear.", "outputFormat": "Output a single line: the minimum possible ribbon length.", "hint": "Sample explanation:\nThere are multiple valid choices. Among the shorter ones are 1 ~ 5 and 5 ~ 8. The latter has length 3, which is shorter, so the answer is 3.\n\nConstraints:\n- For 50% of the testdata, $N \\le 10^4$.\n- For 80% of the testdata, $N \\le 8 \\times 10^5$.\n- For 100% of the testdata, $1 \\le N \\le 10^6, 1 \\le K \\le 60$, $0 \\le$ bead position $< 2^{31}$, and $\\sum T_i = N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2009] 生日礼物", "background": "四川2009NOI省选\n", "description": "\n小西有一条很长的彩带，彩带上挂着各式各样的彩珠。已知彩珠有 $N$ 个，分为 $K$ 种。简单的说，可以将彩带抽象为一个 x 轴，每一个彩珠有一个对应的坐标（即位置）。某些坐标上可以没有彩珠，但多个彩珠也可以出现在同一个位置上。\n\n小布的生日快到了，于是小西打算剪一段彩带送给小布。为了让礼物彩带足够漂亮，小西希望这一段彩带中能包含所有种类的彩珠。同时，为了方便，小西希望这段彩带尽可能短，你能帮助小西计算这个最短的长度么？\n\n彩带的长度即为彩带开始位置到结束位置的位置差。\n", "inputFormat": "第一行包含两个整数 $N, K$，分别表示彩珠的总数以及种类数。\n\n接下来 $K$ 行，每行第一个数为 $T_i$，表示第 $i$ 种彩珠的数目。\n\n接下来按升序给出 $T_i$ 个非负整数，为这 $T_i$ 个彩珠分别出现的位置。", "outputFormat": "输出应包含一行，为最短彩带长度。\n", "hint": "\n### 样例说明\n\n有多种方案可选，其中比较短的是 $1 \\sim 5$ 和 $5 \\sim 8$。后者长度为 $3$，更短，故答案为 $3$。\n\n### 数据范围\n\n对于 $50\\%$ 的数据，$N \\le 10^4$；\n\n对于 $80\\%$ 的数据，$N \\le 8 \\times 10^5$；\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 10^6, 1 \\le K \\le 60$，$0 \\le$ 珠子位置 $< 2^{31}$，且 $\\sum T_i = N$。", "locale": "zh-CN"}}}
{"pid": "P2565", "type": "P", "difficulty": 6, "samples": [["3 3\n2 3 1\n", "1 6 8\n3 5 7\n2 4 9\n"], ["3 4\n2 1 2\n", "0\n"], ["3 4\n2 3 1\n", "1 3 10 11\n2 7 8 9\n4 5 6 12\n"], ["4 4\n4 1 2 3\n", "1 11 8 14\n12 15 2 5\n3 6 16 9\n4 10 13 7\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "贪心", "2009", "四川", "各省省选", "Special Judge", "置换"], "title": "[SCOI2009] 骰子的学问", "background": "", "description": "小鱼儿是个数学天才。一天晚上他研究一个和字符串有关的 penney-ante 游戏。游戏的规则如下：\n\n1. 有两个玩家，开始时每人选择一个长度相同的字符串；\n\n2. 一个字符生成器不断的随机生成字母添加到字符串 $S$ 的末尾，$S$ 初始为空串；\n\n3. 如果 $S$ 包含了某个玩家选择的字符串则游戏结束，该玩家获胜。\n\n假设玩家 1 和玩家 2 分别选择了两个字符串 $A$ 和 $B$，如果玩家 1 可以以较大概率战胜玩家 2，我们记作 $A>B$。咋一看来，小鱼儿觉得如果 $A>B$ 且 $B>C$ 则 $A>C$。可事实恰好相反，存在字符串 $A, B, C$ 使得 $A>B, B>C, C>A$。\n\n\n小鱼儿被这种戏的一个反常现象所吸引，通过查阅资料，他了解到这种现象被称为“非传递性悖论”，在许多非完全信息游戏（比如军棋）中，经常会有这样的例子。可是它到底是如何产生的呢？小鱼儿决定设计一种游戏，从中可以容易的找到非传递的例子，以便更清楚的认识“非传递性”。当然，这样的游戏越简单道理越深刻，于是小鱼儿想起了最简单的掷骰子游戏……\n\n\n这个游戏是这样的，假设有 $n$ 个骰子 $D_1,\\dots,D_n$，每个骰子有 $m$ 个面。每个面上标有一个 $1,2,\\dots,n\\times m$ 的正整数，并且所有骰子的所有 $n\\times m$ 个面上的数字各不相同。满足这条编号要求，并且每个面被随到的概率相等的，这样的 $n$ 个骰子称为一组“好骰子”。游戏开始时，两个玩家分别选两个骰子 $D_i$ 和 $D_j$，各掷一次来比较掷出来那一面的数值，数大的获胜。\n\n\n小鱼儿请你帮忙设计一组“好骰子”，使得对任意一个骰子 $D_i$，它总能战胜 $D_{a_i}$。此处战胜是指选择前者的玩家获胜的概率超过 $1/2$；$a_1,a_2,\\dots,a_n$ 为输入的 $1\\sim n$ 的正整数。", "inputFormat": "第一行为两个整数 $n, m$。第二行有 $n$ 个整数，为 $a_1,a_2,\\dots,a_n$。", "outputFormat": "包含 $n$ 行，每行 $m$ 个 $1\\sim n\\times m$ 的正整数，各不相同，以空格分开。\n\n如果有多解，输出任意一组解；如果无解，输出一个整数 $0$。", "hint": "$30\\%$ 的数据满足 $n, m\\le 10$。\n\n$100\\%$的数据满足 $3\\le n, m\\le200$。\n\n感谢 @cn：苏卿念 提供 spj。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2009] The Knowledge of Dice", "background": "", "description": "Xiao Yu'er is a math genius. One night he studied a Penney-ante game related to strings. The rules are as follows:\n\n1. There are two players. At the beginning, each chooses a string of the same length.\n2. A character generator keeps randomly generating letters and appending them to the end of string $S$, which is initially empty.\n3. If $S$ contains the string chosen by a player, the game ends and that player wins.\n\nSuppose players 1 and 2 choose strings $A$ and $B$ respectively. If player 1 can defeat player 2 with higher probability, we write $A > B$. At first glance, Xiao Yu'er thought that if $A > B$ and $B > C$ then $A > C$. However, the opposite is true: there exist strings $A, B, C$ such that $A > B$, $B > C$, and $C > A$.\n\nXiao Yu'er was fascinated by this counterintuitive phenomenon. From the literature, he learned that this is called the \"non-transitivity paradox\", which often appears in many imperfect-information games (such as military chess). But how does it arise? Xiao Yu'er decided to design a game in which it is easy to find non-transitive examples, to better understand \"non-transitivity\". Of course, the simpler the game, the deeper the idea; thus Xiao Yu'er thought of the simplest dice-rolling game.\n\nThe game is as follows. Assume there are $n$ dice $D_1, \\dots, D_n$, each with $m$ faces. Each face is labeled with a positive integer from $1$ to $n \\times m$, and across all dice, the $n \\times m$ faces have pairwise distinct labels. If the above labeling requirement is satisfied and each face is equally likely to be rolled, such $n$ dice are called a set of \"good dice\". At the start of the game, the two players choose two dice $D_i$ and $D_j$; they each roll once and compare the numbers on the rolled faces, and the larger number wins.\n\nXiao Yu'er asks you to design a set of \"good dice\" such that for every die $D_i$, it always beats $D_{a_i}$. Here, \"beat\" means the probability that the player choosing the former wins exceeds $1/2$; $a_1, a_2, \\dots, a_n$ are the input integers in $1 \\sim n$.", "inputFormat": "The first line contains two integers $n, m$. The second line contains $n$ integers, namely $a_1, a_2, \\dots, a_n$.", "outputFormat": "Output $n$ lines, each containing $m$ distinct integers in $1 \\sim n \\times m$, separated by spaces.\n\nIf there are multiple solutions, output any one of them. If there is no solution, output a single integer $0$.", "hint": "- 30% of the testdata satisfies $n, m \\le 10$.\n- 100% of the testdata satisfies $3 \\le n, m \\le 200$.\n\nThanks to @cn: 苏卿念 for providing the SPJ.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2009] 骰子的学问", "background": "", "description": "小鱼儿是个数学天才。一天晚上他研究一个和字符串有关的 penney-ante 游戏。游戏的规则如下：\n\n1. 有两个玩家，开始时每人选择一个长度相同的字符串；\n\n2. 一个字符生成器不断的随机生成字母添加到字符串 $S$ 的末尾，$S$ 初始为空串；\n\n3. 如果 $S$ 包含了某个玩家选择的字符串则游戏结束，该玩家获胜。\n\n假设玩家 1 和玩家 2 分别选择了两个字符串 $A$ 和 $B$，如果玩家 1 可以以较大概率战胜玩家 2，我们记作 $A>B$。咋一看来，小鱼儿觉得如果 $A>B$ 且 $B>C$ 则 $A>C$。可事实恰好相反，存在字符串 $A, B, C$ 使得 $A>B, B>C, C>A$。\n\n\n小鱼儿被这种戏的一个反常现象所吸引，通过查阅资料，他了解到这种现象被称为“非传递性悖论”，在许多非完全信息游戏（比如军棋）中，经常会有这样的例子。可是它到底是如何产生的呢？小鱼儿决定设计一种游戏，从中可以容易的找到非传递的例子，以便更清楚的认识“非传递性”。当然，这样的游戏越简单道理越深刻，于是小鱼儿想起了最简单的掷骰子游戏……\n\n\n这个游戏是这样的，假设有 $n$ 个骰子 $D_1,\\dots,D_n$，每个骰子有 $m$ 个面。每个面上标有一个 $1,2,\\dots,n\\times m$ 的正整数，并且所有骰子的所有 $n\\times m$ 个面上的数字各不相同。满足这条编号要求，并且每个面被随到的概率相等的，这样的 $n$ 个骰子称为一组“好骰子”。游戏开始时，两个玩家分别选两个骰子 $D_i$ 和 $D_j$，各掷一次来比较掷出来那一面的数值，数大的获胜。\n\n\n小鱼儿请你帮忙设计一组“好骰子”，使得对任意一个骰子 $D_i$，它总能战胜 $D_{a_i}$。此处战胜是指选择前者的玩家获胜的概率超过 $1/2$；$a_1,a_2,\\dots,a_n$ 为输入的 $1\\sim n$ 的正整数。", "inputFormat": "第一行为两个整数 $n, m$。第二行有 $n$ 个整数，为 $a_1,a_2,\\dots,a_n$。", "outputFormat": "包含 $n$ 行，每行 $m$ 个 $1\\sim n\\times m$ 的正整数，各不相同，以空格分开。\n\n如果有多解，输出任意一组解；如果无解，输出一个整数 $0$。", "hint": "$30\\%$ 的数据满足 $n, m\\le 10$。\n\n$100\\%$的数据满足 $3\\le n, m\\le200$。\n\n感谢 @cn：苏卿念 提供 spj。", "locale": "zh-CN"}}}
{"pid": "P2566", "type": "P", "difficulty": 6, "samples": [["3 8\r\n3\r\n30 -100 30\r\n00000000\r\n010203#0\r\n00000000\r\n", "38"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "四川", "各省省选", "状压 DP"], "title": "[SCOI2009] 围豆豆", "background": "四川 NOI2009 省选", "description": "是不是平时在手机里玩吃豆豆游戏玩腻了呢？最近 MOKIA 手机上推出了一种新的围豆豆游戏，大家一起来试一试吧。\n\n\n游戏的规则非常简单，在一个 $N\\times M$ 的矩阵方格内分布着 $D$ 颗豆子，每颗豆有不同的分值 $V_i$。游戏者可以选择任意一个方格作为起始格，每次移动可以随意的走到相邻的四个格子，直到最终又回到起始格。最终游戏者的得分为所有被路径围住的豆豆的分值总和减去游戏者移动的步数。矩阵中某些格子内设有障碍物，任何时刻游戏者不能进入包含障碍物或豆子的格子。游戏者可能的最低得分为 $0$，即什么都不做。\n\n\n注意路径包围的概念，即某一颗豆在路径所形成的多边形（可能是含自交的复杂多边形）的内部。下面有两个例子：\n\n \n ![](https://cdn.luogu.com.cn/upload/pic/1690.png) \n\n第一个例子中，豆在路径围成的矩形内部，所以豆被围住了。第二个例子中，虽然路径经过了豆的周围的 $8$ 个格子，但是路径形成的多边形内部并不包含豆，所以没有围住豆子。\n\n布布最近迷上了这款游戏，但是怎么玩都拿不了高分。聪明的你决定写一个程序来帮助他顺利通关。", "inputFormat": "第一行两个整数 $N$ 和 $M$，为矩阵的边长。\n\n第二行一个整数 $D$，为豆子的总个数。\n\n第三行包含 $D$ 个整数 $V_1$ 到 $V_D$，分别为每颗豆子的分值。\n\n接着 $N$ 行有一个 $N\\times M$ 的字符矩阵来描述游戏矩阵状态，`0` 表示空格，`#` 表示障碍物。而数字 `1` 到 `9` 分别表示对应编号的豆子。", "outputFormat": "仅包含一个整数，为最高可能获得的分值。", "hint": "$50\\%$ 的数据满足 $1\\le D\\le 3$。\n\n$100\\%$ 的数据满足 $1\\le D\\le 9$，$1\\le N,M\\le 10$，$-10^4\\le V_i\\le 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2009] Enclosing Beans", "background": "Sichuan NOI2009 NOI Qualifier.", "description": "Are you tired of playing Pac-Man on your phone? Recently, the MOKIA phone launched a new game called “Enclosing Beans.” Give it a try.\n\nThe rules are simple. In an $N\\times M$ grid there are $D$ beans, and each bean has a value $V_i$. The player may choose any cell as the starting cell. Each move, the player may go to one of the four orthogonally adjacent cells, and eventually must return to the starting cell. The final score is the total value of all beans enclosed by the path minus the number of steps taken. Some cells contain obstacles; at no time may the player enter a cell that contains an obstacle or a bean. The player’s minimum possible score is $0$, i.e., they may choose to do nothing.\n\nNote the notion of being enclosed: a bean is considered enclosed if it lies inside the polygon formed by the path (which may be a complex polygon with self-intersections). See the two examples below:\n\n![](https://cdn.luogu.com.cn/upload/pic/1690.png)\n\nIn the first example, the bean lies inside the rectangle formed by the path, so it is enclosed. In the second example, even though the path visits the $8$ neighboring cells around the bean, the interior of the polygon formed by the path does not contain the bean, so it is not enclosed.\n\nBubu has become obsessed with this game but cannot get a high score. You decide to write a program to help him pass the game.", "inputFormat": "The first line contains two integers $N$ and $M$, the dimensions of the grid.\n\nThe second line contains an integer $D$, the total number of beans.\n\nThe third line contains $D$ integers $V_1$ to $V_D$, the values of the beans.\n\nThen follow $N$ lines, each with $M$ characters, forming an $N\\times M$ character matrix describing the game grid. Character `0` denotes an empty cell, `#` denotes an obstacle, and digits `1` to `9` denote beans with the corresponding indices.", "outputFormat": "Output a single integer, the maximum possible score.", "hint": "$50\\%$ of the testdata satisfies $1\\le D\\le 3$.\n\n$100\\%$ of the testdata satisfies $1\\le D\\le 9$, $1\\le N,M\\le 10$, $-10^4\\le V_i\\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2009] 围豆豆", "background": "四川 NOI2009 省选", "description": "是不是平时在手机里玩吃豆豆游戏玩腻了呢？最近 MOKIA 手机上推出了一种新的围豆豆游戏，大家一起来试一试吧。\n\n\n游戏的规则非常简单，在一个 $N\\times M$ 的矩阵方格内分布着 $D$ 颗豆子，每颗豆有不同的分值 $V_i$。游戏者可以选择任意一个方格作为起始格，每次移动可以随意的走到相邻的四个格子，直到最终又回到起始格。最终游戏者的得分为所有被路径围住的豆豆的分值总和减去游戏者移动的步数。矩阵中某些格子内设有障碍物，任何时刻游戏者不能进入包含障碍物或豆子的格子。游戏者可能的最低得分为 $0$，即什么都不做。\n\n\n注意路径包围的概念，即某一颗豆在路径所形成的多边形（可能是含自交的复杂多边形）的内部。下面有两个例子：\n\n \n ![](https://cdn.luogu.com.cn/upload/pic/1690.png) \n\n第一个例子中，豆在路径围成的矩形内部，所以豆被围住了。第二个例子中，虽然路径经过了豆的周围的 $8$ 个格子，但是路径形成的多边形内部并不包含豆，所以没有围住豆子。\n\n布布最近迷上了这款游戏，但是怎么玩都拿不了高分。聪明的你决定写一个程序来帮助他顺利通关。", "inputFormat": "第一行两个整数 $N$ 和 $M$，为矩阵的边长。\n\n第二行一个整数 $D$，为豆子的总个数。\n\n第三行包含 $D$ 个整数 $V_1$ 到 $V_D$，分别为每颗豆子的分值。\n\n接着 $N$ 行有一个 $N\\times M$ 的字符矩阵来描述游戏矩阵状态，`0` 表示空格，`#` 表示障碍物。而数字 `1` 到 `9` 分别表示对应编号的豆子。", "outputFormat": "仅包含一个整数，为最高可能获得的分值。", "hint": "$50\\%$ 的数据满足 $1\\le D\\le 3$。\n\n$100\\%$ 的数据满足 $1\\le D\\le 9$，$1\\le N,M\\le 10$，$-10^4\\le V_i\\le 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2567", "type": "P", "difficulty": 5, "samples": [["1 10", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2010", "四川", "各省省选", "深度优先搜索 DFS", "剪枝", "容斥原理"], "title": "[SCOI2010] 幸运数字", "background": "四川 NOI 省选 2010。\n", "description": "在中国，很多人都把 $6$ 和 $8$ 视为是幸运数字！lxhgww 也这样认为，于是他定义自己的“幸运号码”是十进制表示中只包含数字 $6$ 和 $8$ 的那些号码，比如 $68$，$666$，$888$ 都是“幸运号码”！但是这种“幸运号码”总是太少了，比如在 $[1,100]$ 的区间内就只有 $6$ 个（$6$，$8$，$66$，$68$，$86$，$88$），于是他又定义了一种“近似幸运号码”。lxhgww 规定，凡是“幸运号码”的倍数都是“近似幸运号码”，当然，任何的“幸运号码”也都是“近似幸运号码”，比如 $12$，$16$，$666$ 都是“近似幸运号码”。\n\n现在 lxhgww 想知道在一段闭区间 $[a, b]$ 内，“近似幸运号码”的个数。", "inputFormat": "输入数据是一行，包括 $2$ 个数字 $a$ 和 $b$。", "outputFormat": "输出数据是一行，包括 $1$ 个数字，表示在闭区间 $[a, b]$ 内“近似幸运号码”的个数。", "hint": "对于 $30\\%$ 的数据，保证 $1\\le a\\le b\\le10^6$。\n\n对于 $100\\%$ 的数据，保证 $1\\le a\\le b\\le10^{10}$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2010] Lucky Numbers", "background": "Sichuan NOI Qualifier 2010.", "description": "In China, many people consider $6$ and $8$ to be lucky numbers. lxhgww thinks so too, so he defines his own \"lucky numbers\" as those whose decimal representation contains only the digits $6$ and $8$. For example, $68$, $666$, and $888$ are all \"lucky numbers\". However, there are too few such \"lucky numbers\"; for instance, in the interval $[1,100]$ there are only $6$ of them ($6$, $8$, $66$, $68$, $86$, $88$). Therefore, he further defines \"almost lucky numbers\": any multiple of a \"lucky number\" is an \"almost lucky number\". Of course, any \"lucky number\" is also an \"almost lucky number\". For example, $12$, $16$, and $666$ are all \"almost lucky numbers\".\n\nNow lxhgww wants to know how many \"almost lucky numbers\" there are in a closed interval $[a, b]$.", "inputFormat": "The input is a single line containing $2$ numbers $a$ and $b$.", "outputFormat": "Output a single line containing $1$ number, the count of \"almost lucky numbers\" in the closed interval $[a, b]$.", "hint": "For $30\\%$ of the testdata, it is guaranteed that $1 \\le a \\le b \\le 10^6$.\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\le a \\le b \\le 10^{10}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2010] 幸运数字", "background": "四川 NOI 省选 2010。\n", "description": "在中国，很多人都把 $6$ 和 $8$ 视为是幸运数字！lxhgww 也这样认为，于是他定义自己的“幸运号码”是十进制表示中只包含数字 $6$ 和 $8$ 的那些号码，比如 $68$，$666$，$888$ 都是“幸运号码”！但是这种“幸运号码”总是太少了，比如在 $[1,100]$ 的区间内就只有 $6$ 个（$6$，$8$，$66$，$68$，$86$，$88$），于是他又定义了一种“近似幸运号码”。lxhgww 规定，凡是“幸运号码”的倍数都是“近似幸运号码”，当然，任何的“幸运号码”也都是“近似幸运号码”，比如 $12$，$16$，$666$ 都是“近似幸运号码”。\n\n现在 lxhgww 想知道在一段闭区间 $[a, b]$ 内，“近似幸运号码”的个数。", "inputFormat": "输入数据是一行，包括 $2$ 个数字 $a$ 和 $b$。", "outputFormat": "输出数据是一行，包括 $1$ 个数字，表示在闭区间 $[a, b]$ 内“近似幸运号码”的个数。", "hint": "对于 $30\\%$ 的数据，保证 $1\\le a\\le b\\le10^6$。\n\n对于 $100\\%$ 的数据，保证 $1\\le a\\le b\\le10^{10}$。\n", "locale": "zh-CN"}}}
{"pid": "P2568", "type": "P", "difficulty": 5, "samples": [["4", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["素数判断,质数,筛法", "前缀和", "欧拉函数"], "title": "GCD", "background": null, "description": "给定正整数 $n$，求 $1\\le x,y\\le n$ 且 $\\gcd(x,y)$ 为素数的数对 $(x,y)$ 有多少对。", "inputFormat": "只有一行一个整数，代表 $n$。", "outputFormat": "一行一个整数表示答案。", "hint": "#### 样例输入输出 1 解释\n\n对于样例，满足条件的 $(x,y)$ 为 $(2,2)$，$(2,4)$，$(3,3)$，$(4,2)$。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $1\\le n\\le10^7$。\n\n---\n\n来源：bzoj2818。\n\n本题数据为洛谷自造数据，使用 [CYaRon](https://github.com/luogu-dev/cyaron) 耗时 $5$ 分钟完成数据制作。", "locale": "zh-CN", "translations": {"en": {"title": "GCD", "background": "", "description": "Given a positive integer $n$, count the number of pairs $(x, y)$ such that $1\\le x, y\\le n$ and $\\gcd(x,y)$ is a prime number.", "inputFormat": "A single line containing one integer representing $n$.", "outputFormat": "Output a single integer in one line, representing the answer.", "hint": "#### Sample Input/Output 1 Explanation\n\nFor the sample, the pairs $(x, y)$ that satisfy the condition are $(2, 2)$, $(2, 4)$, $(3, 3)$, $(4, 2)$.\n\n---\n\n#### Constraints\n\n- For $100\\%$ of the testdata, it is guaranteed that $1\\le n\\le 10^7$.\n\n---\n\nSource: bzoj2818.\n\nThe testdata for this problem are self-made by Luogu, generated using [CYaRon](https://github.com/luogu-dev/cyaron), taking 5 minutes.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "GCD", "background": null, "description": "给定正整数 $n$，求 $1\\le x,y\\le n$ 且 $\\gcd(x,y)$ 为素数的数对 $(x,y)$ 有多少对。", "inputFormat": "只有一行一个整数，代表 $n$。", "outputFormat": "一行一个整数表示答案。", "hint": "#### 样例输入输出 1 解释\n\n对于样例，满足条件的 $(x,y)$ 为 $(2,2)$，$(2,4)$，$(3,3)$，$(4,2)$。\n\n---\n\n#### 数据规模与约定\n\n- 对于 $100\\%$ 的数据，保证 $1\\le n\\le10^7$。\n\n---\n\n来源：bzoj2818。\n\n本题数据为洛谷自造数据，使用 [CYaRon](https://github.com/luogu-dev/cyaron) 耗时 $5$ 分钟完成数据制作。", "locale": "zh-CN"}}}
{"pid": "P2569", "type": "P", "difficulty": 5, "samples": [["5 2 0\n2 1 1 1\n2 1 1 1\n3 2 1 1\n4 3 1 1\n5 4 1 1\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "四川", "各省省选", "单调队列", "队列"], "title": "[SCOI2010] 股票交易", "background": "", "description": "最近 $\\text{lxhgww}$ 又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。\n\n通过一段时间的观察，$\\text{lxhgww}$ 预测到了未来 $T$ 天内某只股票的走势，第 $i$ 天的股票买入价为每股 $AP_i$，第 $i$ 天的股票卖出价为每股 $BP_i$（数据保证对于每个 $i$，都有 $AP_i \\geq BP_i$），但是每天不能无限制地交易，于是股票交易所规定第 $i$ 天的一次买入至多只能购买 $AS_i$ 股，一次卖出至多只能卖出 $BS_i$ 股。\n\n另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔 $W$ 天，也就是说如果在第 $i$ 天发生了交易，那么从第 $i+1$ 天到第 $i+W$ 天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过 $\\text{MaxP}$。\n\n在第 $1$ 天之前，$\\text{lxhgww}$ 手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，$T$ 天以后，$\\text{lxhgww}$ 想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？\n\n", "inputFormat": "输入数据第一行包括 $3$ 个整数，分别是 $T$，$\\text{MaxP}$，$W$。\n\n接下来 $T$ 行，第 $i$ 行代表第 $i-1$ 天的股票走势，每行 $4$ 个整数，分别表示 $AP_i,\\ BP_i,\\ AS_i,\\ BS_i$。", "outputFormat": "输出数据为一行，包括 $1$ 个数字，表示 $\\text{lxhgww}$ 能赚到的最多的钱数。", "hint": "- 对于 $30\\%$ 的数据，$0\\leq W<T\\leq 50,1\\leq\\text{MaxP}\\leq50$；\n- 对于 $50\\%$ 的数据，$0\\leq W<T\\leq 2000,1\\leq\\text{MaxP}\\leq50$；\n- 对于 $100\\%$ 的数据，$0\\leq W<T\\leq 2000,1\\leq\\text{MaxP}\\leq2000$；\n- 对于所有的数据，$1\\leq BP_i\\leq AP_i\\leq 1000,1\\leq AS_i,BS_i\\leq\\text{MaxP}$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2010] Stock Trading", "background": "", "description": "Recently, $\\text{lxhgww}$ has gotten into stock investing again. After a period of observation and learning, he summarized some patterns in stock prices.\n\nOver time, $\\text{lxhgww}$ predicted the movement of a certain stock for the next $T$ days. On day $i$, the buy price per share is $AP_i$, and the sell price per share is $BP_i$ (the data guarantees that for every $i$, $AP_i \\geq BP_i$). However, trading cannot be unrestricted each day, so the exchange stipulates that in a single buy on day $i$, you can purchase at most $AS_i$ shares, and in a single sell on day $i$, you can sell at most $BS_i$ shares.\n\nIn addition, the exchange has two more rules. To avoid excessive trading, the exchange requires that between any two transactions (a buy or a sell on any day counts as one transaction), there must be at least $W$ days in between. That is, if a transaction occurs on day $i$, then from day $i+1$ to day $i+W$ (inclusive), no transactions are allowed. Also, to prevent monopolies, the exchange mandates that at any time, the number of shares a person holds cannot exceed $\\text{MaxP}$.\n\nBefore day $1$, $\\text{lxhgww}$ has a large amount of cash (consider it as unlimited cash), but no stock. Of course, after $T$ days, $\\text{lxhgww}$ wants to earn as much money as possible. Smart programmers, can you help him?", "inputFormat": "The first line of input contains $3$ integers: $T$, $\\text{MaxP}$, and $W$.\n\nThe next $T$ lines describe the stock data. The $i$-th line corresponds to day $i$ and contains $4$ integers, namely $AP_i,\\ BP_i,\\ AS_i,\\ BS_i$.", "outputFormat": "Output a single number: the maximum amount of money $\\text{lxhgww}$ can earn.", "hint": "- For 30% of the testdata, $0 \\leq W < T \\leq 50$, $1 \\leq \\text{MaxP} \\leq 50$.\n- For 50% of the testdata, $0 \\leq W < T \\leq 2000$, $1 \\leq \\text{MaxP} \\leq 50$.\n- For 100% of the testdata, $0 \\leq W < T \\leq 2000$, $1 \\leq \\text{MaxP} \\leq 2000$.\n- For all testdata, $1 \\leq BP_i \\leq AP_i \\leq 1000$, $1 \\leq AS_i,BS_i \\leq \\text{MaxP}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2010] 股票交易", "background": "", "description": "最近 $\\text{lxhgww}$ 又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。\n\n通过一段时间的观察，$\\text{lxhgww}$ 预测到了未来 $T$ 天内某只股票的走势，第 $i$ 天的股票买入价为每股 $AP_i$，第 $i$ 天的股票卖出价为每股 $BP_i$（数据保证对于每个 $i$，都有 $AP_i \\geq BP_i$），但是每天不能无限制地交易，于是股票交易所规定第 $i$ 天的一次买入至多只能购买 $AS_i$ 股，一次卖出至多只能卖出 $BS_i$ 股。\n\n另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔 $W$ 天，也就是说如果在第 $i$ 天发生了交易，那么从第 $i+1$ 天到第 $i+W$ 天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过 $\\text{MaxP}$。\n\n在第 $1$ 天之前，$\\text{lxhgww}$ 手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，$T$ 天以后，$\\text{lxhgww}$ 想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？\n\n", "inputFormat": "输入数据第一行包括 $3$ 个整数，分别是 $T$，$\\text{MaxP}$，$W$。\n\n接下来 $T$ 行，第 $i$ 行代表第 $i-1$ 天的股票走势，每行 $4$ 个整数，分别表示 $AP_i,\\ BP_i,\\ AS_i,\\ BS_i$。", "outputFormat": "输出数据为一行，包括 $1$ 个数字，表示 $\\text{lxhgww}$ 能赚到的最多的钱数。", "hint": "- 对于 $30\\%$ 的数据，$0\\leq W<T\\leq 50,1\\leq\\text{MaxP}\\leq50$；\n- 对于 $50\\%$ 的数据，$0\\leq W<T\\leq 2000,1\\leq\\text{MaxP}\\leq50$；\n- 对于 $100\\%$ 的数据，$0\\leq W<T\\leq 2000,1\\leq\\text{MaxP}\\leq2000$；\n- 对于所有的数据，$1\\leq BP_i\\leq AP_i\\leq 1000,1\\leq AS_i,BS_i\\leq\\text{MaxP}$。", "locale": "zh-CN"}}}
{"pid": "P2570", "type": "P", "difficulty": 6, "samples": [["2\n2 2\n13 0 4\n10 1 3\n4\n2\n1 1\n1 0 2\n1\n", "0.5\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "二分", "各省省选", "网络流", "浙江", "Special Judge"], "title": "[ZJOI2010] 贪吃的老鼠", "background": "", "description": "奶酪店里最近出现了 $m$ 只老鼠！它们的目标就是把生产出来的所有奶酪都吃掉。奶酪店中一天会生产 $n$ 块奶酪，其中第 $i$ 块的大小为 $p_i$，会在第 $r_i$ 秒被生产出来，并且必须在第 $d_i$ 秒之前将它吃掉。第 $j$ 只老鼠吃奶酪的速度为 $s_j$，因此如果它单独吃完第 $i$ 块奶酪所需的时间为 $p_i/s_j$。老鼠们吃奶酪的习惯很独特，具体来说：\n\n1. 在任一时刻，一只老鼠最多可以吃一块奶酪；\n2. 在任一时刻，一块奶酪最多被一只老鼠吃。\n\n由于奶酪的保质期常常很短，为了将它们全部吃掉，老鼠们需要使用一种神奇的魔法来延长奶酪的保质期。将奶酪的保质期延长 $T$ 秒是指所有的奶酪的 $d_i$ 变成 $d_i+T$。同时，使用魔法的代价很高，因此老鼠们希望找到最小的 $T$ 使得可以吃掉所有的奶酪。", "inputFormat": "输入文件的第一行包含一个整数 $K$，表示输入文件中数据的组数。\n\n每组数据的第一行包含两个整数 $n$ 和 $m$，分别表示奶酪和老鼠的数量。接下来的 $n$ 行每行包含三个整数 $p_i,r_i,d_i$。最后 $m$ 行每行包含一个整数，表示 $s_j$。$p_i,r_i,d_i,s_j$ 的含义如上文所述。", "outputFormat": "包含 $K$ 行，每行包含一个实数，表示你找到的最小的 $T$。你的答案和标准答案的绝对误差不应超过 $10^{-4}$。", "hint": "### 样例说明\n\n第一组数据中：\n\n第 $0$ 到第 $1$ 秒：\n\n第一只老鼠吃第一块奶酪；\n\n第 $1$ 到第 $3.5$ 秒：\n\n- 第一只老鼠吃第二块奶酪；\n- 第二只老鼠吃第一块奶酪；\n\n第 $3.5$ 到第 $4.5$ 秒：第一只老鼠吃第一块奶酪。\n\n### 数据规模\n\n$30\\%$ 的数据中，$1 \\le n,m \\le 5$；\n\n$100\\%$ 的数据中，$1 \\le K \\le 5$，$1 \\le n,m \\le 30$，$1 \\le p_i \\le 10^5$，$0 \\le r_i<d_i \\le 10^7$，$1 \\le s_j \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2010] The Gluttonous Mice", "background": "", "description": "Recently, $m$ mice have appeared in the cheese shop. Their goal is to eat all the cheese produced. The shop produces $n$ pieces of cheese per day. The $i$-th piece has size $p_i$, is produced at second $r_i$, and must be eaten before second $d_i$. Mouse $j$ eats at speed $s_j$, so if it eats the $i$-th piece alone, it takes time $p_i / s_j$. The mice have special eating rules:\n\n1. At any moment, a mouse can eat at most one piece of cheese.\n2. At any moment, a piece of cheese can be eaten by at most one mouse.\n\nBecause the shelf life of cheese is often short, to eat all pieces, the mice can use a magical spell to extend the shelf life. Extending the shelf life by $T$ seconds means every $d_i$ becomes $d_i + T$. Since the spell is costly, the mice want the minimum $T$ such that all cheese can be eaten.", "inputFormat": "The first line contains an integer $K$, the number of test cases.\n\nFor each test case, the first line contains two integers $n$ and $m$, the numbers of cheese pieces and mice, respectively. The next $n$ lines each contain three integers $p_i, r_i, d_i$. The final $m$ lines each contain one integer $s_j$. The meanings of $p_i, r_i, d_i, s_j$ are as described above.", "outputFormat": "Output $K$ lines. Each line contains a real number, the minimum $T$ you found. The absolute error between your answer and the standard answer must not exceed $10^{-4}$.", "hint": "Sample Explanation:\n\nFor the first test case:\n\nFrom second $0$ to second $1$:\nThe first mouse eats the first piece of cheese.\n\nFrom second $1$ to second $3.5$:\n- The first mouse eats the second piece of cheese.\n- The second mouse eats the first piece of cheese.\n\nFrom second $3.5$ to second $4.5$: the first mouse eats the first piece of cheese.\n\nConstraints:\n\n- For $30\\%$ of the testdata, $1 \\le n, m \\le 5$.\n- For $100\\%$ of the testdata, $1 \\le K \\le 5$, $1 \\le n, m \\le 30$, $1 \\le p_i \\le 10^5$, $0 \\le r_i < d_i \\le 10^7$, $1 \\le s_j \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2010] 贪吃的老鼠", "background": "", "description": "奶酪店里最近出现了 $m$ 只老鼠！它们的目标就是把生产出来的所有奶酪都吃掉。奶酪店中一天会生产 $n$ 块奶酪，其中第 $i$ 块的大小为 $p_i$，会在第 $r_i$ 秒被生产出来，并且必须在第 $d_i$ 秒之前将它吃掉。第 $j$ 只老鼠吃奶酪的速度为 $s_j$，因此如果它单独吃完第 $i$ 块奶酪所需的时间为 $p_i/s_j$。老鼠们吃奶酪的习惯很独特，具体来说：\n\n1. 在任一时刻，一只老鼠最多可以吃一块奶酪；\n2. 在任一时刻，一块奶酪最多被一只老鼠吃。\n\n由于奶酪的保质期常常很短，为了将它们全部吃掉，老鼠们需要使用一种神奇的魔法来延长奶酪的保质期。将奶酪的保质期延长 $T$ 秒是指所有的奶酪的 $d_i$ 变成 $d_i+T$。同时，使用魔法的代价很高，因此老鼠们希望找到最小的 $T$ 使得可以吃掉所有的奶酪。", "inputFormat": "输入文件的第一行包含一个整数 $K$，表示输入文件中数据的组数。\n\n每组数据的第一行包含两个整数 $n$ 和 $m$，分别表示奶酪和老鼠的数量。接下来的 $n$ 行每行包含三个整数 $p_i,r_i,d_i$。最后 $m$ 行每行包含一个整数，表示 $s_j$。$p_i,r_i,d_i,s_j$ 的含义如上文所述。", "outputFormat": "包含 $K$ 行，每行包含一个实数，表示你找到的最小的 $T$。你的答案和标准答案的绝对误差不应超过 $10^{-4}$。", "hint": "### 样例说明\n\n第一组数据中：\n\n第 $0$ 到第 $1$ 秒：\n\n第一只老鼠吃第一块奶酪；\n\n第 $1$ 到第 $3.5$ 秒：\n\n- 第一只老鼠吃第二块奶酪；\n- 第二只老鼠吃第一块奶酪；\n\n第 $3.5$ 到第 $4.5$ 秒：第一只老鼠吃第一块奶酪。\n\n### 数据规模\n\n$30\\%$ 的数据中，$1 \\le n,m \\le 5$；\n\n$100\\%$ 的数据中，$1 \\le K \\le 5$，$1 \\le n,m \\le 30$，$1 \\le p_i \\le 10^5$，$0 \\le r_i<d_i \\le 10^7$，$1 \\le s_j \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P2571", "type": "P", "difficulty": 5, "samples": [["0 0 0 100\r\n100 0 100 100\r\n2 2 1\r\n", "136.60"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "四川", "各省省选"], "title": "[SCOI2010] 传送带", "background": "", "description": "在一个 $2$ 维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段 $\\text{AB}$ 和线段 $\\text{CD}$。lxhgww 在 $\\text{AB}$ 上的移动速度为 $P$，在 $\\text{CD}$ 上的移动速度为 $Q$，在平面上的移动速度 $R$。现在 lxhgww 想从 $\\text A$ 点走到 $\\text D$ 点，他想知道最少需要走多长时间。\n", "inputFormat": "第一行 $4$ 个整数，表示 $\\text A$ 和 $\\text B$ 的坐标，分别为 $A_x$，$A_y$，$B_x$，$B_y$。\n\n第二行 $4$ 个整数，表示 $\\text C$ 和 $\\text D$ 的坐标，分别为 $C_x$，$C_y$，$D_x$，$D_y$。\n\n第三行 $3$ 个整数，分别是 $P$，$Q$，$R$。", "outputFormat": "输出数据为一行，表示 lxhgww 从 $\\text A$ 点走到 $\\text D$ 点的最短时间，保留到小数点后 $2$ 位。", "hint": "对于 $100\\%$ 的数据，$1\\le A_x,A_y,B_x,B_y,C_x,C_y,D_x,D_y\\le10^3$，$1\\le P,Q,R\\le10$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2010] Conveyor Belt", "background": "", "description": "In a $2$-dimensional plane, there are two conveyor belts, each of which can be regarded as a line segment. The two conveyor belts are line segment $\\text{AB}$ and line segment $\\text{CD}$. lxhgww moves at speed $P$ on $\\text{AB}$, at speed $Q$ on $\\text{CD}$, and at speed $R$ on the plane. Now lxhgww wants to go from point $\\text{A}$ to point $\\text{D}$, and he wants to know the minimum time required.", "inputFormat": "The first line contains $4$ integers, giving the coordinates of $\\text{A}$ and $\\text{B}$, namely $A_x$, $A_y$, $B_x$, $B_y$.\n\nThe second line contains $4$ integers, giving the coordinates of $\\text{C}$ and $\\text{D}$, namely $C_x$, $C_y$, $D_x$, $D_y$.\n\nThe third line contains $3$ integers, which are $P$, $Q$, and $R$.", "outputFormat": "Output one line, the minimum time for lxhgww to go from point $\\text{A}$ to point $\\text{D}$, rounded to $2$ decimal places.", "hint": "For $100\\%$ of the testdata, $1 \\le A_x, A_y, B_x, B_y, C_x, C_y, D_x, D_y \\le 10^3$, $1 \\le P, Q, R \\le 10$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2010] 传送带", "background": "", "description": "在一个 $2$ 维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段 $\\text{AB}$ 和线段 $\\text{CD}$。lxhgww 在 $\\text{AB}$ 上的移动速度为 $P$，在 $\\text{CD}$ 上的移动速度为 $Q$，在平面上的移动速度 $R$。现在 lxhgww 想从 $\\text A$ 点走到 $\\text D$ 点，他想知道最少需要走多长时间。\n", "inputFormat": "第一行 $4$ 个整数，表示 $\\text A$ 和 $\\text B$ 的坐标，分别为 $A_x$，$A_y$，$B_x$，$B_y$。\n\n第二行 $4$ 个整数，表示 $\\text C$ 和 $\\text D$ 的坐标，分别为 $C_x$，$C_y$，$D_x$，$D_y$。\n\n第三行 $3$ 个整数，分别是 $P$，$Q$，$R$。", "outputFormat": "输出数据为一行，表示 lxhgww 从 $\\text A$ 点走到 $\\text D$ 点的最短时间，保留到小数点后 $2$ 位。", "hint": "对于 $100\\%$ 的数据，$1\\le A_x,A_y,B_x,B_y,C_x,C_y,D_x,D_y\\le10^3$，$1\\le P,Q,R\\le10$。", "locale": "zh-CN"}}}
{"pid": "P2572", "type": "P", "difficulty": 5, "samples": [["10 10\n0 0 0 1 1 0 1 0 1 1\n1 0 2\n3 0 5\n2 2 2\n4 0 4\n0 3 6\n2 3 7\n4 2 8\n1 0 5\n0 5 6\n3 3 9\n", "5\n2\n6\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2010", "四川", "线段树", "各省省选"], "title": "[SCOI2010] 序列操作", "background": "", "description": "lxhgww 最近收到了一个 $01$ 序列，序列里面包含了 $n$ 个数，下标从 $0$ 开始。这些数要么是 $0$，要么是 $1$，现在对于这个序列有五种变换操作和询问操作：\n\n- `0 l r` 把 $[l, r]$ 区间内的所有数全变成 $0$；\n- `1 l r` 把 $[l, r]$ 区间内的所有数全变成 $1$；\n- `2 l r` 把 $[l,r]$ 区间内的所有数全部取反，也就是说把所有的 $0$ 变成 $1$，把所有的 $1$ 变成 $0$；\n- `3 l r` 询问 $[l, r]$ 区间内总共有多少个 $1$；\n- `4 l r` 询问 $[l, r]$ 区间内最多有多少个连续的 $1$。\n\n对于每一种询问操作，lxhgww 都需要给出回答，聪明的程序员们，你们能帮助他吗？\n", "inputFormat": "第一行两个正整数 $n,m$，表示序列长度与操作个数。  \n第二行包括 $n$ 个数，表示序列的初始状态。  \n接下来 $m$ 行，每行三个整数，表示一次操作。\n", "outputFormat": "对于每一个询问操作，输出一行一个数，表示其对应的答案。\n", "hint": "【数据范围】  \n对于 $30\\%$ 的数据，$1\\le n,m \\le 1000$；  \n对于$100\\%$ 的数据，$1\\le n,m \\le 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2010] Sequence Operations", "background": "", "description": "lxhgww recently received a $01$ sequence containing $n$ numbers, indexed from $0$. Each number is either $0$ or $1$. There are five types of update and query operations on this sequence:\n\n- `0 l r` Set all numbers in the interval $[l, r]$ to $0$.\n- `1 l r` Set all numbers in the interval $[l, r]$ to $1$.\n- `2 l r` Flip all numbers in the interval $[l, r]$, that is, change every $0$ to $1$ and every $1$ to $0$.\n- `3 l r` Query how many $1$s are in the interval $[l, r]$.\n- `4 l r` Query the maximum number of consecutive $1$s in the interval $[l, r]$.\n\nFor each query operation, lxhgww needs to provide an answer. Clever programmers, can you help him?", "inputFormat": "The first line contains two positive integers $n, m$, representing the length of the sequence and the number of operations.  \nThe second line contains $n$ numbers, representing the initial state of the sequence.  \nThen follow $m$ lines, each containing three integers, representing one operation.", "outputFormat": "For each query operation, output one line with a single integer representing the corresponding answer.", "hint": "Constraints  \nFor $30\\%$ of the testdata, $1 \\le n, m \\le 1000$.  \nFor $100\\%$ of the testdata, $1 \\le n, m \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2010] 序列操作", "background": "", "description": "lxhgww 最近收到了一个 $01$ 序列，序列里面包含了 $n$ 个数，下标从 $0$ 开始。这些数要么是 $0$，要么是 $1$，现在对于这个序列有五种变换操作和询问操作：\n\n- `0 l r` 把 $[l, r]$ 区间内的所有数全变成 $0$；\n- `1 l r` 把 $[l, r]$ 区间内的所有数全变成 $1$；\n- `2 l r` 把 $[l,r]$ 区间内的所有数全部取反，也就是说把所有的 $0$ 变成 $1$，把所有的 $1$ 变成 $0$；\n- `3 l r` 询问 $[l, r]$ 区间内总共有多少个 $1$；\n- `4 l r` 询问 $[l, r]$ 区间内最多有多少个连续的 $1$。\n\n对于每一种询问操作，lxhgww 都需要给出回答，聪明的程序员们，你们能帮助他吗？\n", "inputFormat": "第一行两个正整数 $n,m$，表示序列长度与操作个数。  \n第二行包括 $n$ 个数，表示序列的初始状态。  \n接下来 $m$ 行，每行三个整数，表示一次操作。\n", "outputFormat": "对于每一个询问操作，输出一行一个数，表示其对应的答案。\n", "hint": "【数据范围】  \n对于 $30\\%$ 的数据，$1\\le n,m \\le 1000$；  \n对于$100\\%$ 的数据，$1\\le n,m \\le 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P2573", "type": "P", "difficulty": 5, "samples": [["3 3 \n3 2 1 \n1 2 1 \n2 3 1 \n1 3 10 ", "3 2"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2012", "四川", "各省省选", "排序", "生成树"], "title": "[SCOI2012] 滑雪", "background": null, "description": "a180285 非常喜欢滑雪。他来到一座雪山，这里分布着 $m$ 条供滑行的轨道和 $n$ 个轨道之间的交点（同时也是景点），而且每个景点都有一编号 $i\\space (1 \\le i \\le n)$ 和一高度 $h_i$。  \n\na180285 能从景点 $i$ 滑到景点 $j$ 当且仅当存在一条 $i$ 和 $j$ 之间的边，且 $i$ 的高度**不小于** $j$。与其他滑雪爱好者不同，a180285 喜欢用最短的滑行路径去访问尽量多的景点。如果仅仅访问一条路径上的景点，他会觉得数量太少。\n\n于是 a180285 拿出了他随身携带的时间胶囊。这是一种很神奇的药物，吃下之后可以立即回到上个经过的景点（不用移动也不被认为是 a180285 滑行的距离）。  \n\n请注意，这种神奇的药物是可以连续食用的，即能够回到较长时间之前到过的景点（比如上上个经过的景点和上上上个经过的景点）。 现在，a180285 站在 $1$ 号景点望着山下的目标，心潮澎湃。他十分想知道在不考虑时间胶囊消耗的情况下，以最短滑行距离滑到尽量多的景点的方案（即满足经过景点数最大的前提下使得滑行总距离最小）。你能帮他求出最短距离和景点数吗？", "inputFormat": "输入的第一行是两个整数 $n,m$。接下来一行有 $n$ 个整数 $h_i$，分别表示每个景点的高度。\n\n接下来 $m$ 行，表示各个景点之间轨道分布的情况。每行三个整数 $u,v,k$，表示编号为 $u$ 的景点和编号为 $v$ 的景点之间有一条长度为 $k$ 的轨道。", "outputFormat": "输出一行，表示 a180285 最多能到达多少个景点，以及此时最短的滑行距离总和。", "hint": "对于 $ 30\\% $ 的数据，$ 1 \\le n \\le 2000 $；\n\n对于 $ 100\\% $ 的数据，$ 1 \\le n \\le 10^5 , 1 \\le m \\le 10^6 , 1 \\le h_i \\le 10^9 , 1 \\le k_i \\le 10^9 $。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2012] Skiing", "background": "", "description": "a180285 is very fond of skiing. He comes to a snowy mountain with $m$ ski tracks and $n$ intersections between tracks (which are also scenic spots). Each scenic spot has an index $i\\space (1 \\le i \\le n)$ and a height $h_i$.\n\na180285 can ski from spot $i$ to spot $j$ if and only if there is an edge between $i$ and $j$, and the height at $i$ is **not less than** that at $j$. Unlike other ski enthusiasts, a180285 prefers to visit as many spots as possible using the shortest skiing route. If he only visits the spots along a single path, he feels the number is too small.\n\nSo a180285 takes out his portable time capsule. It is a magical medicine that, after being taken, can immediately return him to the last visited spot (this does not require movement and is not counted in a180285’s skiing distance).\n\nNote that this magical medicine can be taken consecutively, allowing him to return to spots visited a longer time ago (for example, the previous, the one before that, or the one even earlier). Now, a180285 stands at spot $1$, gazing at the goals downhill, full of excitement. He wants to know, ignoring the consumption of time capsules, the plan that uses the shortest skiing distance to reach as many scenic spots as possible (i.e., among all plans that maximize the number of visited spots, minimize the total skiing distance). Can you help him find the minimum distance and the number of spots?", "inputFormat": "The first line contains two integers $n, m$.  \nThe next line contains $n$ integers $h_i$, representing the height of each scenic spot.\n\nThen there are $m$ lines, each with three integers $u, v, k$, indicating there is a track of length $k$ between spots $u$ and $v$.", "outputFormat": "Output one line with two integers: the maximum number of scenic spots a180285 can reach, and the minimum total skiing distance in that case.", "hint": "For $30\\%$ of the testdata, $1 \\le n \\le 2000$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^5$, $1 \\le m \\le 10^6$, $1 \\le h_i \\le 10^9$, $1 \\le k_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2012] 滑雪", "background": null, "description": "a180285 非常喜欢滑雪。他来到一座雪山，这里分布着 $m$ 条供滑行的轨道和 $n$ 个轨道之间的交点（同时也是景点），而且每个景点都有一编号 $i\\space (1 \\le i \\le n)$ 和一高度 $h_i$。  \n\na180285 能从景点 $i$ 滑到景点 $j$ 当且仅当存在一条 $i$ 和 $j$ 之间的边，且 $i$ 的高度**不小于** $j$。与其他滑雪爱好者不同，a180285 喜欢用最短的滑行路径去访问尽量多的景点。如果仅仅访问一条路径上的景点，他会觉得数量太少。\n\n于是 a180285 拿出了他随身携带的时间胶囊。这是一种很神奇的药物，吃下之后可以立即回到上个经过的景点（不用移动也不被认为是 a180285 滑行的距离）。  \n\n请注意，这种神奇的药物是可以连续食用的，即能够回到较长时间之前到过的景点（比如上上个经过的景点和上上上个经过的景点）。 现在，a180285 站在 $1$ 号景点望着山下的目标，心潮澎湃。他十分想知道在不考虑时间胶囊消耗的情况下，以最短滑行距离滑到尽量多的景点的方案（即满足经过景点数最大的前提下使得滑行总距离最小）。你能帮他求出最短距离和景点数吗？", "inputFormat": "输入的第一行是两个整数 $n,m$。接下来一行有 $n$ 个整数 $h_i$，分别表示每个景点的高度。\n\n接下来 $m$ 行，表示各个景点之间轨道分布的情况。每行三个整数 $u,v,k$，表示编号为 $u$ 的景点和编号为 $v$ 的景点之间有一条长度为 $k$ 的轨道。", "outputFormat": "输出一行，表示 a180285 最多能到达多少个景点，以及此时最短的滑行距离总和。", "hint": "对于 $ 30\\% $ 的数据，$ 1 \\le n \\le 2000 $；\n\n对于 $ 100\\% $ 的数据，$ 1 \\le n \\le 10^5 , 1 \\le m \\le 10^6 , 1 \\le h_i \\le 10^9 , 1 \\le k_i \\le 10^9 $。", "locale": "zh-CN"}}}
{"pid": "P2574", "type": "P", "difficulty": 4, "samples": [["10 6\n1011101001\n0 2 4\n1 1 5\n0 3 7\n1 1 10\n0 1 4\n1 2 6\n", "3\n6\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "洛谷原创"], "title": "XOR的艺术", "background": "", "description": "AKN 觉得第一题太水了，不屑于写第一题，所以他又玩起了新的游戏。在游戏中，他发现，这个游戏的伤害计算有一个规律，规律如下：\n\n1. 拥有一个伤害串，是一个长度为 $n$ 的只含字符 ``0`` 和字符 ``1`` 的字符串。规定这个字符串的首字符是第一个字符，即下标从 $1$ 开始。\n2. 给定一个范围 $[l,~r]$，伤害为伤害串的这个范围内中字符 ``1`` 的个数。\n3. 会修改伤害串中的数值，修改的方法是把 $[l,~r]$ 中所有原来的字符 ``0`` 变成 ``1``，将 ``1`` 变成 ``0``。\n\nAKN 想知道一些时刻的伤害，请你帮助他求出这个伤害。", "inputFormat": "输入的第一行有两个用空格隔开的整数，分别表示伤害串的长度 $n$，和操作的个数 $m$。\n\n输入第二行是一个长度为 $n$ 的字符串 $S$，代表伤害串。\n\n第 $3$ 到第 $(m + 2)$ 行，每行有三个用空格隔开的整数 $op, l, r$。代表第 $i$ 次操作的方式和区间，规则是：\n\n- 若 $op = 0$，则表示将伤害串的 $[l,~r]$ 区间内的 ``0`` 变成 ``1``，``1`` 变成 ``0``。\n- 若 $op = 1$，则表示询问伤害串的 $[l,~r]$ 区间内有多少个字符 ``1``。", "outputFormat": "对于每次询问，输出一行一个整数，代表区间内 ``1`` 的个数。\n", "hint": "#### 样例输入输出 $1$ 解释\n\n原伤害串为 ``1011101001``。\n\n对于第一次操作，改变 $[2,~4]$ 的字符，伤害串变为 ``1100101001``。\n\n对于第二次操作，查询 $[1,~5]$ 内 ``1`` 的个数，共有 $3$ 个。\n\n对于第三次操作，改变 $[3,~7]$ 的字符，伤害串变为 ``1111010001``。\n\n对于第四次操作，查询 $[1,~10]$ 内 ``1`` 的个数，共有 $6$ 个。\n\n对于第五次操作，改变 $[1,~4]$ 的字符，伤害串变为 ``0000010001``。\n\n对于第六次操作，查询 $[2,~6]$ 内 ``1`` 的个数，共有 $1$ 个。\n\n#### 数据范围与约定\n\n对于 $10\\%$ 的数据，保证 $n, m \\leq 10$。\n\n另有 $30\\%$ 的数据，保证 $n, m \\leq 2 \\times 10^3$。\n\n对于 $100\\%$ 的数据，保证 $2 \\leq n, m \\leq 2 \\times 10^5$，$0 \\leq op \\leq 1$，$1 \\leq l \\leq r \\leq n$，$S$ 中只含字符 ``0`` 和字符 ``1``。", "locale": "zh-CN", "translations": {"en": {"title": "The Art of XOR", "background": "", "description": "AKN thought the first problem was too easy and refused to write it, so he started a new game. In the game, he found a pattern in the damage calculation, as follows:\n\n1. There is a damage string, which is a string of length $n$ consisting only of the characters ``0`` and ``1``. The first character is considered the first position, i.e., indices start from $1$.\n2. Given a range $[l,~r]$, the damage is the number of characters ``1`` within that range of the damage string.\n3. The damage string can be modified by toggling all characters in $[l,~r]$: change every ``0`` to ``1`` and every ``1`` to ``0``.\n\nAKN wants to know the damage at certain times. Please help him compute it.", "inputFormat": "The first line contains two integers separated by a space, representing the length $n$ of the damage string and the number of operations $m$.\n\nThe second line is a string $S$ of length $n$, representing the damage string.\n\nFrom the $3$-rd to the $(m + 2)$-nd line, each line contains three integers $op, l, r$, representing the type and interval of the $i$-th operation. The rules are:\n\n- If $op = 0$, toggle the characters in the interval $[l,~r]$ of the damage string: change ``0`` to ``1`` and ``1`` to ``0``.\n- If $op = 1$, query how many characters ``1`` are in the interval $[l,~r]$ of the damage string.", "outputFormat": "For each query, output a single line with one integer, representing the number of ``1`` in the interval.", "hint": "Explanation for Sample Input/Output 1:\n\nThe original damage string is ``1011101001``.\n\nFor the first operation, toggle the characters in $[2,~4]$, and the damage string becomes ``1100101001``.\n\nFor the second operation, query the number of ``1`` in $[1,~5]$, which is $3$.\n\nFor the third operation, toggle the characters in $[3,~7]$, and the damage string becomes ``1111010001``.\n\nFor the fourth operation, query the number of ``1`` in $[1,~10]$, which is $6$.\n\nFor the fifth operation, toggle the characters in $[1,~4]$, and the damage string becomes ``0000010001``.\n\nFor the sixth operation, query the number of ``1`` in $[2,~6]$, which is $1$.\n\nConstraints:\n\n- For $10\\%$ of the testdata, it is guaranteed that $n, m \\leq 10$.\n- For an additional $30\\%$ of the testdata, it is guaranteed that $n, m \\leq 2 \\times 10^3$.\n- For $100\\%$ of the testdata, it is guaranteed that $2 \\leq n, m \\leq 2 \\times 10^5$, $0 \\leq op \\leq 1$, $1 \\leq l \\leq r \\leq n$, and $S$ contains only the characters ``0`` and ``1``.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "XOR的艺术", "background": "", "description": "AKN 觉得第一题太水了，不屑于写第一题，所以他又玩起了新的游戏。在游戏中，他发现，这个游戏的伤害计算有一个规律，规律如下：\n\n1. 拥有一个伤害串，是一个长度为 $n$ 的只含字符 ``0`` 和字符 ``1`` 的字符串。规定这个字符串的首字符是第一个字符，即下标从 $1$ 开始。\n2. 给定一个范围 $[l,~r]$，伤害为伤害串的这个范围内中字符 ``1`` 的个数。\n3. 会修改伤害串中的数值，修改的方法是把 $[l,~r]$ 中所有原来的字符 ``0`` 变成 ``1``，将 ``1`` 变成 ``0``。\n\nAKN 想知道一些时刻的伤害，请你帮助他求出这个伤害。", "inputFormat": "输入的第一行有两个用空格隔开的整数，分别表示伤害串的长度 $n$，和操作的个数 $m$。\n\n输入第二行是一个长度为 $n$ 的字符串 $S$，代表伤害串。\n\n第 $3$ 到第 $(m + 2)$ 行，每行有三个用空格隔开的整数 $op, l, r$。代表第 $i$ 次操作的方式和区间，规则是：\n\n- 若 $op = 0$，则表示将伤害串的 $[l,~r]$ 区间内的 ``0`` 变成 ``1``，``1`` 变成 ``0``。\n- 若 $op = 1$，则表示询问伤害串的 $[l,~r]$ 区间内有多少个字符 ``1``。", "outputFormat": "对于每次询问，输出一行一个整数，代表区间内 ``1`` 的个数。\n", "hint": "#### 样例输入输出 $1$ 解释\n\n原伤害串为 ``1011101001``。\n\n对于第一次操作，改变 $[2,~4]$ 的字符，伤害串变为 ``1100101001``。\n\n对于第二次操作，查询 $[1,~5]$ 内 ``1`` 的个数，共有 $3$ 个。\n\n对于第三次操作，改变 $[3,~7]$ 的字符，伤害串变为 ``1111010001``。\n\n对于第四次操作，查询 $[1,~10]$ 内 ``1`` 的个数，共有 $6$ 个。\n\n对于第五次操作，改变 $[1,~4]$ 的字符，伤害串变为 ``0000010001``。\n\n对于第六次操作，查询 $[2,~6]$ 内 ``1`` 的个数，共有 $1$ 个。\n\n#### 数据范围与约定\n\n对于 $10\\%$ 的数据，保证 $n, m \\leq 10$。\n\n另有 $30\\%$ 的数据，保证 $n, m \\leq 2 \\times 10^3$。\n\n对于 $100\\%$ 的数据，保证 $2 \\leq n, m \\leq 2 \\times 10^5$，$0 \\leq op \\leq 1$，$1 \\leq l \\leq r \\leq n$，$S$ 中只含字符 ``0`` 和字符 ``1``。", "locale": "zh-CN"}}}
{"pid": "P2575", "type": "P", "difficulty": 5, "samples": [["2\n1\n2 19 20\n2\n1 19\n1 18\n", "NO\nYES\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["博弈论", "SG 函数"], "title": "高手过招", "background": null, "description": "AKN 玩游戏玩累了，于是他开始和同伴下棋了，玩的是跳棋！对手是 wwx！这两位上古神遇在一起下棋，使得棋局变得玄幻莫测，高手过招，必有一赢，他们都将用最佳策略下棋，现在给你一个 $n \\times 20$ 的棋盘，以及棋盘上有若干个棋子，问谁赢？akn 先手！\n\n游戏规则是这样的：\n\n对于一个棋子，能将它向右移动一格，如果右边有空格，则向右跳到第一个空格，如果右边没有空格，则不能移动这个棋子，如果所有棋子都不能移动，那么将输掉这场比赛。", "inputFormat": "第一行一个 $T$，表示 $T$ 组数据。\n\n每组数据第一行 $n$，表示 $n \\times 20$ 的棋盘。\n\n接下来 $n$ 行每行第一个数 $m$ 表示第 $i$ 行有 $m$ 个棋子。\n\n随后跟着 $m$ 个数 $p_j$ 表示第 $i$ 行的棋子布局。", "outputFormat": "如果 AKN 能赢，则输出 `YES`，否则输出 `NO`。", "hint": "$10\\%$ 的数据 $T \\leq 1,n \\leq 1$。\n\n另外 $10\\%$ 的数据 $m \\leq 1$。\n\n$100\\%$ 的数据 $T \\leq 100$，$n \\leq  1000$，$m \\leq 20$，$1 \\leq p_j \\leq 20$。", "locale": "zh-CN", "translations": {"en": {"title": "Clash of Masters", "background": "", "description": "AKN got tired of playing video games, so he started a game of checkers with his teammate. The opponent is wwx. When these two ancient masters meet over the board, the game becomes unpredictable. When masters clash, there will be a winner. They both play optimally. You are given an $n \\times 20$ board with some pieces on it. Who wins? AKN moves first.\n\nThe rules of the game are as follows:\n- For any piece, you may move it one cell to the right. If there is a piece immediately to its right, then jump to the first empty cell to the right. If there is no empty cell to the right, you cannot move this piece. If none of the pieces can move, you lose the game.", "inputFormat": "The first line contains $T$, the number of test cases.\n\nFor each test case, the first line contains $n$, indicating an $n \\times 20$ board.\n\nThen follow $n$ lines; on each line, the first number $m$ indicates that row $i$ has $m$ pieces.\n\nIt is then followed by $m$ numbers $p_j$ describing the piece positions in row $i$.", "outputFormat": "If AKN can win, print `YES`; otherwise, print `NO`.", "hint": "$10\\%$ of the testdata has $T \\leq 1, n \\leq 1$.\n\nAdditionally, $10\\%$ of the testdata has $m \\leq 1$.\n\nFor $100\\%$ of the testdata, $T \\leq 100$, $n \\leq 1000$, $m \\leq 20$, $1 \\leq p_j \\leq 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "高手过招", "background": null, "description": "AKN 玩游戏玩累了，于是他开始和同伴下棋了，玩的是跳棋！对手是 wwx！这两位上古神遇在一起下棋，使得棋局变得玄幻莫测，高手过招，必有一赢，他们都将用最佳策略下棋，现在给你一个 $n \\times 20$ 的棋盘，以及棋盘上有若干个棋子，问谁赢？akn 先手！\n\n游戏规则是这样的：\n\n对于一个棋子，能将它向右移动一格，如果右边有空格，则向右跳到第一个空格，如果右边没有空格，则不能移动这个棋子，如果所有棋子都不能移动，那么将输掉这场比赛。", "inputFormat": "第一行一个 $T$，表示 $T$ 组数据。\n\n每组数据第一行 $n$，表示 $n \\times 20$ 的棋盘。\n\n接下来 $n$ 行每行第一个数 $m$ 表示第 $i$ 行有 $m$ 个棋子。\n\n随后跟着 $m$ 个数 $p_j$ 表示第 $i$ 行的棋子布局。", "outputFormat": "如果 AKN 能赢，则输出 `YES`，否则输出 `NO`。", "hint": "$10\\%$ 的数据 $T \\leq 1,n \\leq 1$。\n\n另外 $10\\%$ 的数据 $m \\leq 1$。\n\n$100\\%$ 的数据 $T \\leq 100$，$n \\leq  1000$，$m \\leq 20$，$1 \\leq p_j \\leq 20$。", "locale": "zh-CN"}}}
{"pid": "P2576", "type": "P", "difficulty": 6, "samples": [["4\r\n\r\n1 7\r\n3 1 7 6 5 4 2\r\n\r\n2 2\r\n1 2\r\n3 4\r\n\r\n2 3\r\n2 1 6\r\n3 4 5\r\n\r\n4 4\r\n11 12 15 14\r\n10 9 16 13\r\n5 8 1 2\r\n6 7 4 3\r\n", "AllRight\r\nCheat\r\nAllRight\r\nAllRight\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "各省省选", "浙江"], "title": "[ZJOI2005] 梦幻折纸", "background": "你是一个喜欢幻想的小女孩，特别喜欢追求一些完美的理想的东西——“理想的圆”，“理想的均等”，“理想的材料”，“理想的最优解”……\n\n最近，偶然的机会，你迷恋上了折纸。你把自己的作业本扯下来折成了各种各样的小把戏——小花，小草，小鸟，小兔子，小老鼠……一张又一张，直到作业本的封面都被你折成了纸鹤。但是你还是觉得不过瘾。\n\n终于……你克制不住自己心中压抑的想法，从可怜的同桌那儿拿了一张用过的草稿纸。正当你打算用同样的方法折掉它的时候，你十分惊奇的发现：这不是一张普通的草稿纸，而是一张非常特殊的草稿纸：它薄得厚度可以忽略不计，柔韧得怎么撕也撕不破，而且无论怎么折都行。\n\n你如获至宝，这不就是你梦寐以求的“理想的材料”吗？真所谓“踏破铁鞋无觅处，得来全不费功夫。梦里寻它千百度，蓦然回首，它却在灯火阑珊处 ！”你决心要把它折成一个有难度一点的东西，才对得住一张这么好的纸。", "description": "你仔细观察了一下纸的特点：\n\n纸的大小为 $n \\times m$，上面等距离的印好了格线，$n-1$ 条横线和 $m-1$ 条竖线（线的宽度忽略不计）。这些格线将纸分成了 $n \\times m$ 个大小完全相同的正方形小格。你的同桌已经在每一块小格 $(i,j)$ 上写下了一个互不相同的正整数 $P_{i,j}$，$1 \\le P_{i,j} \\le n \\times m$。\n\n“他干嘛在纸上写下这么些数字呢？”你看着这些数字，疑惑不解。\n\n这时，你的同桌突然出现了，他发现你正拿着他的纸，看着上面的数字发呆。于是傻乎乎地对你说：\n\n“我刚刚也想学你折纸，可是我很笨，只折出一个 $1 \\times 1$ 的正方形，也就是一个 $n \\times m$ 层纸的纸垛，每一层恰好是一个小格，所有的格线都恰好在正方形的边界上。”\n\n“哦，折得不错，挺好的。”你口里说不错，心里却暗笑：没见过你这么笨的。居然把这么好的纸折成一个如此简单的正方形，简直是暴殄天物，罪过啊，罪过！\n\n“是吗？你也觉得不错啊？我刚刚就在想，如果给这些小格编上号，最上面一层编为 $1$，从上往下数的第 $i$ 层编为 $i$，那么能不能从这些编号复原出刚刚我折的那个图形呢？于是我就在这些格子上写下了它们的编号”\n\n“这……”你一时语塞，确切的说，惊讶得说不出话来，原来一向傻乎乎的同桌脑子里也有这么深奥的想法。\n\n“这样吧，如果你能根据我把我刚刚折的正方形折出来，那我就把这张纸送给你！” 同桌接着说，“不管你折法是否和我一样，只要折出来也是个 $1 \\times 1$ 的正方形，从上往下数的第 $i$ 层的编号恰好也是 $i$，并且纸不能破，就算你折对了。”\n\n“好啊，不过我先要检查检查你有没有骗我，要是你故意骗我或者自己粗心在编号的时候写错了数字而害得我折不出来，我可饶不了你！”", "inputFormat": "第一行为整数 $t$，代表输入数据的总数。\n\n以下有 $t$ 组数据，每组数据的结构如下：\n\n第一行两个正整数 $n,m$。\n\n以下 $n$ 行，每行 $m$ 个正整数，相邻两个整数之间用一个空格隔开，描述矩阵 $P_{i,j}$。", "outputFormat": "输出 $t$ 行，对应 $t$ 个输入数据。\n\n对于第 $i$ 组数据，输出 `AllRight`——如果可以折出来；输出 `Cheat`——如果折不出来。", "hint": "- $1 \\le t \\le 10$\n\n- $1 \\le n, m \\le 100$", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2005] Fantasy Origami", "background": "You are a girl who loves to daydream, especially about perfect ideals—“ideal circles,” “ideal equality,” “ideal materials,” “ideal optimal solutions”…\n\nRecently, by chance, you fell in love with origami. You tore pages from your notebook and folded all kinds of little tricks—little flowers, little grasses, little birds, little rabbits, little mice… page after page, until even the cover was folded into a paper crane. But you still didn’t feel satisfied.\n\nFinally… you couldn’t hold back your urge. You took a used scratch paper from your poor deskmate. Just as you were about to fold it the same way, you were amazed to find: this was not an ordinary scratch paper, but a very special one. It was so thin that its thickness could be ignored, so tough that it wouldn’t tear no matter how you pulled, and it could be folded in any way you wanted.\n\nYou were thrilled—wasn’t this the “ideal material” you had dreamed of? As the saying goes, “after searching everywhere in iron shoes and finding nothing, it all comes without effort; seeking it a thousand times in dreams, suddenly turning back, there it is where the lights are dim!” You decided to fold something a bit more challenging to be worthy of such a good piece of paper.", "description": "You carefully observe the features of the paper:\n\nThe paper has size $n \\times m$, with equally spaced grid lines printed on it: $n - 1$ horizontal lines and $m - 1$ vertical lines (line width ignored). These grid lines divide the paper into $n \\times m$ small squares of exactly the same size. Your deskmate has already written on each small square $(i, j)$ a distinct positive integer $P_{i, j}$ with $1 \\le P_{i, j} \\le n \\times m$.\n\n“Why did he write so many numbers on the paper?” You look at these numbers, puzzled.\n\nAt this moment, your deskmate suddenly shows up. He finds you holding his paper, staring at the numbers in a daze. So he says, a bit silly:\n\n“I just tried to learn origami from you, but I’m clumsy. I only folded a $1 \\times 1$ square, that is, a stack of $n \\times m$ layers of paper, with each layer exactly one small square, and all grid lines exactly on the boundary of the square.”\n\n“Oh, that’s nice, pretty good.” You say it’s good, but secretly laugh: never seen anyone as clumsy as you. Folding such a great paper into such a simple square—what a waste!\n\n“Really? You also think it’s good? I was just thinking, if we number these small squares, label the top layer as $1$, and label the $i$-th layer counted from top to bottom as $i$, can we reconstruct the exact figure I folded from these numbers? So I wrote their labels on the squares.”\n\n“This…” You are at a loss for words—more precisely, so surprised you cannot speak. Turns out your usually silly deskmate has such a deep thought.\n\n“How about this: if you can fold the square I folded just now based on my labels, I’ll give you this paper!” he continues. “No matter whether your sequence of folds is the same as mine or not, as long as you also get a $1 \\times 1$ square, the $i$-th layer from top to bottom is exactly labeled $i$, and the paper is not torn, then you did it right.”\n\n“Alright, but I’ll first check whether you’re trying to fool me. If you deliberately cheat or made careless mistakes when writing the labels so that I cannot fold it, I won’t let you off!”", "inputFormat": "The first line contains an integer $t$, the total number of testcases.\n\nThen there are $t$ testcases, each with the following structure:\n\n- The first line contains two positive integers $n, m$.\n- The next $n$ lines each contain $m$ positive integers, separated by a single space, describing the matrix $P_{i, j}$.", "outputFormat": "Output $t$ lines, one for each testcase.\n\nFor the $i$-th testcase, output `AllRight` if it can be folded as required; otherwise output `Cheat` if it cannot.", "hint": "- $1 \\le t \\le 10$.\n- $1 \\le n, m \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2005] 梦幻折纸", "background": "你是一个喜欢幻想的小女孩，特别喜欢追求一些完美的理想的东西——“理想的圆”，“理想的均等”，“理想的材料”，“理想的最优解”……\n\n最近，偶然的机会，你迷恋上了折纸。你把自己的作业本扯下来折成了各种各样的小把戏——小花，小草，小鸟，小兔子，小老鼠……一张又一张，直到作业本的封面都被你折成了纸鹤。但是你还是觉得不过瘾。\n\n终于……你克制不住自己心中压抑的想法，从可怜的同桌那儿拿了一张用过的草稿纸。正当你打算用同样的方法折掉它的时候，你十分惊奇的发现：这不是一张普通的草稿纸，而是一张非常特殊的草稿纸：它薄得厚度可以忽略不计，柔韧得怎么撕也撕不破，而且无论怎么折都行。\n\n你如获至宝，这不就是你梦寐以求的“理想的材料”吗？真所谓“踏破铁鞋无觅处，得来全不费功夫。梦里寻它千百度，蓦然回首，它却在灯火阑珊处 ！”你决心要把它折成一个有难度一点的东西，才对得住一张这么好的纸。", "description": "你仔细观察了一下纸的特点：\n\n纸的大小为 $n \\times m$，上面等距离的印好了格线，$n-1$ 条横线和 $m-1$ 条竖线（线的宽度忽略不计）。这些格线将纸分成了 $n \\times m$ 个大小完全相同的正方形小格。你的同桌已经在每一块小格 $(i,j)$ 上写下了一个互不相同的正整数 $P_{i,j}$，$1 \\le P_{i,j} \\le n \\times m$。\n\n“他干嘛在纸上写下这么些数字呢？”你看着这些数字，疑惑不解。\n\n这时，你的同桌突然出现了，他发现你正拿着他的纸，看着上面的数字发呆。于是傻乎乎地对你说：\n\n“我刚刚也想学你折纸，可是我很笨，只折出一个 $1 \\times 1$ 的正方形，也就是一个 $n \\times m$ 层纸的纸垛，每一层恰好是一个小格，所有的格线都恰好在正方形的边界上。”\n\n“哦，折得不错，挺好的。”你口里说不错，心里却暗笑：没见过你这么笨的。居然把这么好的纸折成一个如此简单的正方形，简直是暴殄天物，罪过啊，罪过！\n\n“是吗？你也觉得不错啊？我刚刚就在想，如果给这些小格编上号，最上面一层编为 $1$，从上往下数的第 $i$ 层编为 $i$，那么能不能从这些编号复原出刚刚我折的那个图形呢？于是我就在这些格子上写下了它们的编号”\n\n“这……”你一时语塞，确切的说，惊讶得说不出话来，原来一向傻乎乎的同桌脑子里也有这么深奥的想法。\n\n“这样吧，如果你能根据我把我刚刚折的正方形折出来，那我就把这张纸送给你！” 同桌接着说，“不管你折法是否和我一样，只要折出来也是个 $1 \\times 1$ 的正方形，从上往下数的第 $i$ 层的编号恰好也是 $i$，并且纸不能破，就算你折对了。”\n\n“好啊，不过我先要检查检查你有没有骗我，要是你故意骗我或者自己粗心在编号的时候写错了数字而害得我折不出来，我可饶不了你！”", "inputFormat": "第一行为整数 $t$，代表输入数据的总数。\n\n以下有 $t$ 组数据，每组数据的结构如下：\n\n第一行两个正整数 $n,m$。\n\n以下 $n$ 行，每行 $m$ 个正整数，相邻两个整数之间用一个空格隔开，描述矩阵 $P_{i,j}$。", "outputFormat": "输出 $t$ 行，对应 $t$ 个输入数据。\n\n对于第 $i$ 组数据，输出 `AllRight`——如果可以折出来；输出 `Cheat`——如果折不出来。", "hint": "- $1 \\le t \\le 10$\n\n- $1 \\le n, m \\le 100$", "locale": "zh-CN"}}}
{"pid": "P2577", "type": "P", "difficulty": 4, "samples": [["5\r\n2 2\r\n7 7\r\n1 3\r\n6 4\r\n8 5\r\n", "17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2004", "各省省选", "浙江", "排序"], "title": "[ZJOI2004] 午餐", "background": null, "description": "上午的训练结束了，THU ACM 小组集体去吃午餐，他们一行 $N$ 人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。\n\nTHU ACM 小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。\n\n现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。\n\n假设 THU ACM 小组在时刻 $0$ 到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。\n\n现在给定 $N$ 个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。", "inputFormat": "第一行一个整数 $N$，代表总共有 $N$ 个人。\n\n以下 $N$ 行，每行两个整数 $A_i,B_i$，依次代表第 $i$ 个人的打饭时间和吃饭时间。", "outputFormat": "一个整数 $T$，代表所有人吃完饭的最早时刻。", "hint": "所有输入数据均为不超过 $200$ 的正整数。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2004] Lunch", "background": "", "description": "After the morning training, the THU ACM team goes to have lunch. A group of $N$ people arrive at the famous Canteen No. 10. There are two serving windows, and each window can serve at most one person at a time. Because everyone has different tastes (and appetites), the time needed to be served varies by person. Everyone also eats at a different speed, so the eating time may also differ.\n\nTheir plan is: first split all people into two queues and decide the order within each queue. Then queue 1 lines up at window 1, and queue 2 at window 2. Each person starts eating immediately after being served. As soon as everyone finishes eating, they gather to go to the basement of Teaching Building No. 6 for the afternoon training.\n\nGiven the serving time and eating time of each person, arrange the teams and the order to make the time when everyone finishes eating as early as possible.\n\nAssume the THU ACM team arrives at time $0$, and there are no other diners in the canteen (only the servers). Each person must be assigned to exactly one queue. The two windows operate in parallel and do not affect each other, and a person’s serving time is independent of the window. After being served, each person starts eating immediately with no delay.\n\nGiven the serving and eating times of $N$ people, output the time when everyone finishes eating under the optimal plan.", "inputFormat": "The first line contains an integer $N$, the total number of people.\n\nEach of the next $N$ lines contains two integers $A_i, B_i$, representing the $i$-th person’s serving time and eating time.", "outputFormat": "A single integer $T$, the earliest time when everyone has finished eating.", "hint": "Constraints: All input numbers are positive integers not exceeding $200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2004] 午餐", "background": null, "description": "上午的训练结束了，THU ACM 小组集体去吃午餐，他们一行 $N$ 人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。\n\nTHU ACM 小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。\n\n现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。\n\n假设 THU ACM 小组在时刻 $0$ 到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。\n\n现在给定 $N$ 个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。", "inputFormat": "第一行一个整数 $N$，代表总共有 $N$ 个人。\n\n以下 $N$ 行，每行两个整数 $A_i,B_i$，依次代表第 $i$ 个人的打饭时间和吃饭时间。", "outputFormat": "一个整数 $T$，代表所有人吃完饭的最早时刻。", "hint": "所有输入数据均为不超过 $200$ 的正整数。", "locale": "zh-CN"}}}
{"pid": "P2578", "type": "P", "difficulty": 5, "samples": [["2 3 0\n1 8 7\n5 4 6\n", "4\n2 3 0\n1 8 7\n5 4 6\n\n1 2 3\n5 8 0\n4 6 7\n\n1 2 3\n0 5 8\n4 6 7\n\n0 1 2\n4 5 3\n6 7 8\n\n0 1 2\n3 4 5\n6 7 8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "各省省选", "浙江", "Special Judge", "广度优先搜索 BFS", "哈希 hashing"], "title": "[ZJOI2005] 九数码游戏", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1701.png)\n", "inputFormat": "输入文件中包含三行三列九个数，同行的相邻两数用空格隔开，表示初始状态每个方格上的数字。初始状态不会是目标状态。\n", "outputFormat": "如果目标状态无法达到，则输出“UNSOLVABLE”（引号不输出）。\n\n否则，第一行是一个整数S，表示最少的操作次数。接下来4 × (S + 1)行，每四行表示一个状态：前三行每行三个整数，相邻两数用空格隔开，表示每个方格上的数字，第四行是一个空行，作为分隔。第一个状态必须是初始状态，最后一个状态必须是目标状态。\n\n\n\n", "hint": "由@FlierKing提供SPJ\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2005] Nine-Digit Puzzle Game", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1701.png)", "inputFormat": "The input consists of nine integers arranged in three rows and three columns. In each row, adjacent integers are separated by a space, representing the number on each square in the initial state. The initial state will not be the goal state.", "outputFormat": "If the goal state is unreachable, output UNSOLVABLE (without quotes).\n\nOtherwise, the first line contains an integer $S$, the minimal number of moves. Then output $4 \\times (S + 1)$ lines. Every four lines represent one state: the first three lines each contain three integers separated by a space, representing the numbers on the squares; the fourth line is a blank line used as a separator. The first state must be the initial state, and the last state must be the goal state.", "hint": "SPJ provided by @FlierKing.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2005] 九数码游戏", "background": "", "description": "![](https://cdn.luogu.com.cn/upload/pic/1701.png)\n", "inputFormat": "输入文件中包含三行三列九个数，同行的相邻两数用空格隔开，表示初始状态每个方格上的数字。初始状态不会是目标状态。\n", "outputFormat": "如果目标状态无法达到，则输出“UNSOLVABLE”（引号不输出）。\n\n否则，第一行是一个整数S，表示最少的操作次数。接下来4 × (S + 1)行，每四行表示一个状态：前三行每行三个整数，相邻两数用空格隔开，表示每个方格上的数字，第四行是一个空行，作为分隔。第一个状态必须是初始状态，最后一个状态必须是目标状态。\n\n\n\n", "hint": "由@FlierKing提供SPJ\n", "locale": "zh-CN"}}}
{"pid": "P2579", "type": "P", "difficulty": 5, "samples": [["6 8 1 5 3\r\n0 2\r\n2 1\r\n1 0\r\n0 5\r\n5 1\r\n1 4\r\n4 3\r\n3 5\r\n1\r\n3 0 5 1\r\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "各省省选", "浙江", "矩阵乘法", "构造"], "title": "[ZJOI2005] 沼泽鳄鱼", "background": "", "description": "潘塔纳尔沼泽地号称世界上最大的一块湿地，它地位于巴西中部马托格罗索州的南部地区。每当雨季来临，这里碧波荡漾、生机盎然，引来不少游客。\n\n为了让游玩更有情趣，人们在池塘的中央建设了几座石墩和石桥，每座石桥连接着两座石墩，且每两座石墩之间至多只有一座石桥。这个景点造好之后一直没敢对外开放，原因是池塘里有不少危险的食人鱼。\n\n豆豆先生酷爱冒险，他一听说这个消息，立马赶到了池塘，想做第一个在桥上旅游的人。虽说豆豆爱冒险，但也不敢拿自己的性命开玩笑，于是他开始了仔细的实地勘察，并得到了一些惊人的结论：食人鱼的行进路线有周期性，这个周期只可能是 $2$、$3$ 或者 $4$ 个单位时间。每个单位时间里，食人鱼可以从一个石墩游到另一个石墩。每到一个石墩，如果上面有人它就会实施攻击，否则继续它的周期运动。如果没有到石墩，它是不会攻击人的。\n\n借助先进的仪器，豆豆很快就摸清了所有食人鱼的运动规律，他要开始设计自己的行动路线了。每个单位时间里，他只可以沿着石桥从一个石墩走到另一个石墩，而不可以停在某座石墩上不动，因为站着不动还会有其它危险。如果豆豆和某条食人鱼在同一时刻到达了某座石墩，就会遭到食人鱼的袭击，他当然不希望发生这样的事情。\n\n现在豆豆已经选好了两座石墩 $\\mathrm{Start}$ 和 $\\mathrm{End}$，他想从 $\\mathrm{Start}$ 出发，经过 $K$ 个单位时间后恰好站在石墩 $\\mathrm{End}$ 上。假设石墩可以重复经过（包括 $\\mathrm{Start}$ 和 $\\mathrm{End}$），他想请你帮忙算算，这样的路线共有多少种（当然不能遭到食人鱼的攻击）。", "inputFormat": "输入文件共 $M + 2 + \\mathrm{NFish}$ 行。\n\n第一行包含五个正整数 $N,M,\\mathrm{Start},\\mathrm{End},K$，分别表示石墩数目、石桥数目、$\\mathrm{Start}$ 石墩和 $\\mathrm{End}$ 石墩的编号和一条路线所需的单位时间。石墩用 $0$ 到 $N-1$ 的整数编号。\n\n第 $2$ 到 $M + 1$ 行，给出石桥的相关信息。每行两个整数 $x$ 和 $y$，$0 \\leq x, y \\leq N-1$，表示这座石桥连接着编号为 $x$ 和 $y$ 的两座石墩。\n\n第 $M + 2$ 行是一个整数 $\\mathrm{NFish}$，表示食人鱼的数目。\n\n第 $M + 3$ 到 $M + 2 + \\mathrm{NFish}$ 行，每行给出一条食人鱼的相关信息。每行的第一个整数是 $T$，$T = 2,3$ 或 $4$，表示食人鱼的运动周期。接下来有 $T$ 个数，表示一个周期内食人鱼的行进路线。\n\n- 如果 $T=2$，接下来有 $2$ 个数 $P_0$ 和 $P_1$，食人鱼从 $P_0$ 到 $P_1$，从 $P_1$ 到 $P_0,\\ldots$；\n\n- 如果 $T=3$，接下来有 $3$ 个数 $P_0,P_1$ 和 $P_2$，食人鱼从 $P_0$ 到 $P_1$，从 $P_1$ 到 $P_2$，从 $P_2$ 到 $P_0,\\ldots$；\n\n- 如果 $T=4$，接下来有 $4$ 个数 $P_0,P_1,P_2$ 和 $P_3$，食人鱼从 $P_0$ 到 $P_1$，从 $P_1$ 到 $P_2$，从 $P_2$ 到 $P_3$，从 $P_3$ 到 $P_0,\\ldots$。\n\n豆豆出发的时候所有食人鱼都在自己路线上的 $P_0$ 位置，请放心，这个位置不会是 $\\mathrm{Start}$ 石墩。", "outputFormat": "输出路线的种数，因为这个数可能很大，你只要输出该数除以 $10000$ 的余数就行了。", "hint": "对于 $100 \\%$ 的数据，$1 \\leq N \\leq 50$，$1 \\leq K \\leq 2 \\times 10^9$，$1 \\leq \\mathrm{NFish} \\leq 20$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2005] Swamp Crocodiles", "background": "", "description": "The Pantanal wetland is known as the largest wetland in the world. It is located in the southern part of Mato Grosso do Sul in central Brazil. Every rainy season, waves sparkle and life flourishes here, attracting many tourists.\n\nTo make the visit more interesting, several stone piers and stone bridges were built in the middle of a pond. Each stone bridge connects two stone piers, and between any two stone piers there is at most one bridge. This attraction has never been opened to the public because there are many dangerous piranhas in the pond.\n\nMr. Doudou loves adventure. As soon as he heard the news, he hurried to the pond, wanting to be the first person to walk on the bridges. Although he is adventurous, he does not want to risk his life, so he conducted careful field research and reached some startling conclusions: the routes of the piranhas are periodic, and the period can only be $2$, $3$, or $4$ units of time. In each unit of time, a piranha can swim from one stone pier to another. Upon arriving at a stone pier, if there is someone on it, it will attack; otherwise, it continues its periodic movement. If it is not at a stone pier, it will not attack.\n\nWith advanced instruments, Doudou quickly figured out all the movement patterns of the piranhas, and he started planning his own route. In each unit of time, he can only walk along a bridge from one stone pier to another, and he is not allowed to stay on any pier without moving, because standing still also involves other dangers. If Doudou and a piranha arrive at the same stone pier at the same time, he will be attacked by the piranha, which he certainly wants to avoid.\n\nDoudou has selected two stone piers $\\mathrm{Start}$ and $\\mathrm{End}$. He wants to start from $\\mathrm{Start}$ and be standing on $\\mathrm{End}$ after exactly $K$ units of time. Assume that stone piers may be revisited (including $\\mathrm{Start}$ and $\\mathrm{End}$). He asks you to compute how many such routes exist (of course without being attacked by any piranha).", "inputFormat": "The input consists of $M + 2 + \\mathrm{NFish}$ lines.\n\nThe first line contains five positive integers $N, M, \\mathrm{Start}, \\mathrm{End}, K$, representing the number of stone piers, the number of stone bridges, the indices of $\\mathrm{Start}$ and $\\mathrm{End}$, and the required units of time for a route, respectively. Stone piers are numbered from $0$ to $N - 1$.\n\nLines $2$ to $M + 1$ give the information about the stone bridges. Each of these lines contains two integers $x$ and $y$, $0 \\leq x, y \\leq N - 1$, indicating that the bridge connects the piers numbered $x$ and $y$.\n\nLine $M + 2$ contains an integer $\\mathrm{NFish}$, the number of piranhas.\n\nLines $M + 3$ to $M + 2 + \\mathrm{NFish}$ each describe one piranha. The first integer is $T$, with $T = 2, 3$ or $4$, indicating the period of the piranha’s movement. Then follow $T$ numbers describing the route within one period.\n\n- If $T = 2$, the next $2$ numbers are $P_0$ and $P_1$: the piranha moves from $P_0$ to $P_1$, from $P_1$ to $P_0$, $\\ldots$.\n- If $T = 3$, the next $3$ numbers are $P_0, P_1$ and $P_2$: the piranha moves from $P_0$ to $P_1$, from $P_1$ to $P_2$, from $P_2$ to $P_0$, $\\ldots$.\n- If $T = 4$, the next $4$ numbers are $P_0, P_1, P_2$ and $P_3$: the piranha moves from $P_0$ to $P_1$, from $P_1$ to $P_2$, from $P_2$ to $P_3$, from $P_3$ to $P_0$, $\\ldots$.\n\nAt the time Doudou starts, all piranhas are at position $P_0$ on their routes. Rest assured, this position will not be the $\\mathrm{Start}$ pier.", "outputFormat": "Output the number of routes. Since this number may be large, output the remainder when it is divided by $10000$.", "hint": "For $100\\%$ of the testdata, $1 \\leq N \\leq 50$, $1 \\leq K \\leq 2 \\times 10^9$, $1 \\leq \\mathrm{NFish} \\leq 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2005] 沼泽鳄鱼", "background": "", "description": "潘塔纳尔沼泽地号称世界上最大的一块湿地，它地位于巴西中部马托格罗索州的南部地区。每当雨季来临，这里碧波荡漾、生机盎然，引来不少游客。\n\n为了让游玩更有情趣，人们在池塘的中央建设了几座石墩和石桥，每座石桥连接着两座石墩，且每两座石墩之间至多只有一座石桥。这个景点造好之后一直没敢对外开放，原因是池塘里有不少危险的食人鱼。\n\n豆豆先生酷爱冒险，他一听说这个消息，立马赶到了池塘，想做第一个在桥上旅游的人。虽说豆豆爱冒险，但也不敢拿自己的性命开玩笑，于是他开始了仔细的实地勘察，并得到了一些惊人的结论：食人鱼的行进路线有周期性，这个周期只可能是 $2$、$3$ 或者 $4$ 个单位时间。每个单位时间里，食人鱼可以从一个石墩游到另一个石墩。每到一个石墩，如果上面有人它就会实施攻击，否则继续它的周期运动。如果没有到石墩，它是不会攻击人的。\n\n借助先进的仪器，豆豆很快就摸清了所有食人鱼的运动规律，他要开始设计自己的行动路线了。每个单位时间里，他只可以沿着石桥从一个石墩走到另一个石墩，而不可以停在某座石墩上不动，因为站着不动还会有其它危险。如果豆豆和某条食人鱼在同一时刻到达了某座石墩，就会遭到食人鱼的袭击，他当然不希望发生这样的事情。\n\n现在豆豆已经选好了两座石墩 $\\mathrm{Start}$ 和 $\\mathrm{End}$，他想从 $\\mathrm{Start}$ 出发，经过 $K$ 个单位时间后恰好站在石墩 $\\mathrm{End}$ 上。假设石墩可以重复经过（包括 $\\mathrm{Start}$ 和 $\\mathrm{End}$），他想请你帮忙算算，这样的路线共有多少种（当然不能遭到食人鱼的攻击）。", "inputFormat": "输入文件共 $M + 2 + \\mathrm{NFish}$ 行。\n\n第一行包含五个正整数 $N,M,\\mathrm{Start},\\mathrm{End},K$，分别表示石墩数目、石桥数目、$\\mathrm{Start}$ 石墩和 $\\mathrm{End}$ 石墩的编号和一条路线所需的单位时间。石墩用 $0$ 到 $N-1$ 的整数编号。\n\n第 $2$ 到 $M + 1$ 行，给出石桥的相关信息。每行两个整数 $x$ 和 $y$，$0 \\leq x, y \\leq N-1$，表示这座石桥连接着编号为 $x$ 和 $y$ 的两座石墩。\n\n第 $M + 2$ 行是一个整数 $\\mathrm{NFish}$，表示食人鱼的数目。\n\n第 $M + 3$ 到 $M + 2 + \\mathrm{NFish}$ 行，每行给出一条食人鱼的相关信息。每行的第一个整数是 $T$，$T = 2,3$ 或 $4$，表示食人鱼的运动周期。接下来有 $T$ 个数，表示一个周期内食人鱼的行进路线。\n\n- 如果 $T=2$，接下来有 $2$ 个数 $P_0$ 和 $P_1$，食人鱼从 $P_0$ 到 $P_1$，从 $P_1$ 到 $P_0,\\ldots$；\n\n- 如果 $T=3$，接下来有 $3$ 个数 $P_0,P_1$ 和 $P_2$，食人鱼从 $P_0$ 到 $P_1$，从 $P_1$ 到 $P_2$，从 $P_2$ 到 $P_0,\\ldots$；\n\n- 如果 $T=4$，接下来有 $4$ 个数 $P_0,P_1,P_2$ 和 $P_3$，食人鱼从 $P_0$ 到 $P_1$，从 $P_1$ 到 $P_2$，从 $P_2$ 到 $P_3$，从 $P_3$ 到 $P_0,\\ldots$。\n\n豆豆出发的时候所有食人鱼都在自己路线上的 $P_0$ 位置，请放心，这个位置不会是 $\\mathrm{Start}$ 石墩。", "outputFormat": "输出路线的种数，因为这个数可能很大，你只要输出该数除以 $10000$ 的余数就行了。", "hint": "对于 $100 \\%$ 的数据，$1 \\leq N \\leq 50$，$1 \\leq K \\leq 2 \\times 10^9$，$1 \\leq \\mathrm{NFish} \\leq 20$。", "locale": "zh-CN"}}}
{"pid": "P2580", "type": "P", "difficulty": 3, "samples": [["5  \na\nb\nc\nad\nacd\n3\na\na\ne\n", "OK\nREPEAT\nWRONG\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["字符串", "哈希 hashing", "字典树 Trie", "STL"], "title": "于是他错误的点名开始了", "background": "XS 中学化学竞赛组教练是一个酷爱炉石的人。\n\n他会一边搓炉石一边点名以至于有一天他连续点到了某个同学两次，然后正好被路过的校长发现了然后就是一顿欧拉欧拉欧拉（详情请见已结束比赛 CON900）。", "description": "这之后校长任命你为特派探员，每天记录他的点名。校长会提供化学竞赛学生的人数和名单，而你需要告诉校长他有没有点错名。（为什么不直接不让他玩炉石。）", "inputFormat": "第一行一个整数 $n$，表示班上人数。\n\n接下来 $n$ 行，每行一个字符串表示其名字（互不相同，且只含小写字母，长度不超过 $50$）。\n\n第 $n+2$ 行一个整数 $m$，表示教练报的名字个数。\n\n接下来 $m$ 行，每行一个字符串表示教练报的名字（只含小写字母，且长度不超过 $50$）。", "outputFormat": "对于每个教练报的名字，输出一行。\n\n如果该名字正确且是第一次出现，输出 `OK`，如果该名字错误，输出 `WRONG`，如果该名字正确但不是第一次出现，输出 `REPEAT`。", "hint": "- 对于 $40\\%$ 的数据，$n\\le 1000$，$m\\le 2000$。\n- 对于 $70\\%$ 的数据，$n\\le 10^4$，$m\\le 2\\times 10^4$。\n- 对于 $100\\%$ 的数据，$n\\le 10^4$，$m≤10^5$。\n\n---\n\n$\\text{upd 2022.7.30}$：新增加一组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "And Thus His Mistaken Roll Call Began", "background": "The coach of the XS Middle School chemistry competition team is a big fan of Hearthstone. He plays Hearthstone while taking attendance, and one day he called the same student twice in a row. The principal happened to pass by, and then it was a round of \"ora ora ora\" (for details, see the ended contest CON900).", "description": "After that, the principal appointed you as a special agent to record his roll calls every day. The principal will provide the number of chemistry competition students and the roster, and you need to tell the principal whether he called the names correctly. (Why not just stop him from playing Hearthstone.)", "inputFormat": "The first line contains an integer $n$, the number of students in the class.  \nThe next $n$ lines each contain a string representing a name (all distinct, lowercase letters only, length no more than $50$).  \nThe $(n+2)$-th line contains an integer $m$, the number of names the coach called.  \nThe next $m$ lines each contain a string representing a name called by the coach (lowercase letters only, length no more than $50$).", "outputFormat": "For each name called by the coach, output one line.  \nIf the name is correct and appears for the first time, output `OK`. If the name is incorrect, output `WRONG`. If the name is correct but not the first time, output `REPEAT`.", "hint": "- For $40\\%$ of the testdata, $n \\le 1000$, $m \\le 2000$.\n- For $70\\%$ of the testdata, $n \\le 10^4$, $m \\le 2 \\times 10^4$.\n- For $100\\%$ of the testdata, $n \\le 10^4$, $m \\le 10^5$.\n\n---\n\n$\\text{upd 2022.7.30}$: A new set of Hack testdata was added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "于是他错误的点名开始了", "background": "XS 中学化学竞赛组教练是一个酷爱炉石的人。\n\n他会一边搓炉石一边点名以至于有一天他连续点到了某个同学两次，然后正好被路过的校长发现了然后就是一顿欧拉欧拉欧拉（详情请见已结束比赛 CON900）。", "description": "这之后校长任命你为特派探员，每天记录他的点名。校长会提供化学竞赛学生的人数和名单，而你需要告诉校长他有没有点错名。（为什么不直接不让他玩炉石。）", "inputFormat": "第一行一个整数 $n$，表示班上人数。\n\n接下来 $n$ 行，每行一个字符串表示其名字（互不相同，且只含小写字母，长度不超过 $50$）。\n\n第 $n+2$ 行一个整数 $m$，表示教练报的名字个数。\n\n接下来 $m$ 行，每行一个字符串表示教练报的名字（只含小写字母，且长度不超过 $50$）。", "outputFormat": "对于每个教练报的名字，输出一行。\n\n如果该名字正确且是第一次出现，输出 `OK`，如果该名字错误，输出 `WRONG`，如果该名字正确但不是第一次出现，输出 `REPEAT`。", "hint": "- 对于 $40\\%$ 的数据，$n\\le 1000$，$m\\le 2000$。\n- 对于 $70\\%$ 的数据，$n\\le 10^4$，$m\\le 2\\times 10^4$。\n- 对于 $100\\%$ 的数据，$n\\le 10^4$，$m≤10^5$。\n\n---\n\n$\\text{upd 2022.7.30}$：新增加一组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P2581", "type": "P", "difficulty": 5, "samples": [["6\nSAB\nSBC\nSAA\nACA\nBCC\nCBC\n3\nABBCAAABCA\nCCC\nBA", "3\n1\nNIE"]], "limits": {"time": [1000], "memory": [128000]}, "tags": ["2005", "各省省选", "浙江"], "title": "[ZJOI2005] Genotype", "background": "Genotype 是一个独特的基因串。", "description": "我们可以用大写英文字母 $A-Z$ 来描述 Genotype，每个字母就代表一个基因。\n\n规定一种「分裂」规则，由三个大写字母 $A_1A_2A_3$ 组成，代表 $A_1$ 可以「分裂」为 $A_2A_3$。\n\n现在给定 $n$ 个「分裂」规则和 $k$ 个 Genotype，判断这些 Genotype 是否能从一个特定的 **只包含大写字母 $S$ 的** 串通过「分裂」规则得到，如果可以的话输出特定的串的长度的最小值，如果不可以的话输出 `NIE`。", "inputFormat": "第一行一个整数 $n$ 代表「分裂」规则数。     \n接下来 $n$ 行每行三个大写字母 $A_1,A_2,A_3$ 代表一个「分裂」规则。         \n接下来一行一个整数 $k$ 代表给定的 Genotype 数。     \n接下来 $k$ 行每行若干个大写字母表示一个 Genotype。", "outputFormat": "$k$ 行：\n\n- 如果没有特定的串通过「分裂」规则得到这个 Genotype，输出 `NIE`。\n- 如果有特定的串通过「分裂」规则得到这个 Genotype，输出这个特定的串的最小长度。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n,k \\le 2000$，Genotype 的长度最大为 $100$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2005] Genotype", "background": "Genotype is a unique gene string.", "description": "We can use uppercase English letters $A-Z$ to describe a Genotype, where each letter represents a gene.\n\nDefine a \"split\" rule as a triple of uppercase letters $A_1A_2A_3$, meaning $A_1$ can \"split\" into $A_2A_3$.\n\nGiven $n$ \"split\" rules and $k$ Genotypes, determine whether each Genotype can be obtained from a specific string that consists only of the uppercase letter $S$ by applying the \"split\" rules. If it is possible, output the minimal length of that specific string; otherwise, output `NIE`.", "inputFormat": "The first line contains an integer $n$, the number of \"split\" rules.  \nEach of the next $n$ lines contains three uppercase letters $A_1,A_2,A_3$ representing one \"split\" rule.  \nThe next line contains an integer $k$, the number of given Genotypes.  \nEach of the next $k$ lines contains a string of uppercase letters representing a Genotype.", "outputFormat": "$k$ lines:\n- If no such specific string can produce the Genotype via the \"split\" rules, output `NIE`.\n- If there is such a specific string, output the minimal length of that specific string.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, $1 \\le n,k \\le 2000$, and the maximum length of a Genotype is $100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2005] Genotype", "background": "Genotype 是一个独特的基因串。", "description": "我们可以用大写英文字母 $A-Z$ 来描述 Genotype，每个字母就代表一个基因。\n\n规定一种「分裂」规则，由三个大写字母 $A_1A_2A_3$ 组成，代表 $A_1$ 可以「分裂」为 $A_2A_3$。\n\n现在给定 $n$ 个「分裂」规则和 $k$ 个 Genotype，判断这些 Genotype 是否能从一个特定的 **只包含大写字母 $S$ 的** 串通过「分裂」规则得到，如果可以的话输出特定的串的长度的最小值，如果不可以的话输出 `NIE`。", "inputFormat": "第一行一个整数 $n$ 代表「分裂」规则数。     \n接下来 $n$ 行每行三个大写字母 $A_1,A_2,A_3$ 代表一个「分裂」规则。         \n接下来一行一个整数 $k$ 代表给定的 Genotype 数。     \n接下来 $k$ 行每行若干个大写字母表示一个 Genotype。", "outputFormat": "$k$ 行：\n\n- 如果没有特定的串通过「分裂」规则得到这个 Genotype，输出 `NIE`。\n- 如果有特定的串通过「分裂」规则得到这个 Genotype，输出这个特定的串的最小长度。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，$1 \\le n,k \\le 2000$，Genotype 的长度最大为 $100$。", "locale": "zh-CN"}}}
{"pid": "P2582", "type": "P", "difficulty": 5, "samples": [["5\n1 2 3 4 5", "1 1 1 1 1"], ["5\n2 3 4 5 1", "1 2 3 4 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2016", "洛谷原创", "洛谷月赛"], "title": "函数", "background": "Alice 和 Bob 玩游戏。", "description": "Alice 给出一个 $1$~$n$ 的排列表示一个函数 $y=f(x)$，即给出的第 $i$ 个数字即为 $f(i)$。  \n\n现在 Bob 需要给出一个字典序尽可能小的函数 $y=g(x)$，使得对于任意 $i$，$f(g(i))=g(f(i))$。", "inputFormat": "第一行一个整数 $n$。  \n\n第二行 $n$ 个整数，依次表示 $f(1),f(2) \\cdots f(n)$。", "outputFormat": "共一行，$n$ 个整数，依次表示 $g(1),g(2) \\cdots g(n)$。", "hint": "#### 【样例解释】\n#### 样例 1 说明\n- $g(f(1))=f(g(1))=1$。\n- $g(f(2))=f(g(2))=1$。\n- $g(f(3))=f(g(3))=1$。\n- $g(f(4))=f(g(4))=1$。\n- $g(f(5))=f(g(5))=1$。\n\n#### 样例 2 说明\n- $g(f(1))=f(g(1))=2$。\n- $g(f(2))=f(g(2))=3$。\n- $g(f(3))=f(g(3))=4$。\n- $g(f(4))=f(g(4))=5$。\n- $g(f(5))=f(g(5))=1$。\n\n---\n\n#### 【数据规模与约定】\n对于 $30\\%$ 的数据，$n \\le 5$。\n对于 $60\\%$ 的数据，$n \\le 10^3$。\n对于 $100\\%$ 的数据，$1 \\le n \\le 8 \\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Function", "background": "Alice and Bob play a game.", "description": "Alice gives a permutation of $1$ to $n$ representing a function $y=f(x)$, i.e., the $i$-th number given is $f(i)$.\n\nNow Bob needs to give a function $y=g(x)$ that is lexicographically as small as possible, such that for any $i$, $f(g(i))=g(f(i))$.", "inputFormat": "The first line contains an integer $n$.\nThe second line contains $n$ integers, representing $f(1), f(2) \\cdots f(n)$ in order.", "outputFormat": "Output one line containing $n$ integers, representing $g(1), g(2) \\cdots g(n)$ in order.", "hint": "Sample Explanation\nSample 1\n- $g(f(1))=f(g(1))=1$.\n- $g(f(2))=f(g(2))=1$.\n- $g(f(3))=f(g(3))=1$.\n- $g(f(4))=f(g(4))=1$.\n- $g(f(5))=f(g(5))=1$.\n\nSample 2\n- $g(f(1))=f(g(1))=2$.\n- $g(f(2))=f(g(2))=3$.\n- $g(f(3))=f(g(3))=4$.\n- $g(f(4))=f(g(4))=5$.\n- $g(f(5))=f(g(5))=1$.\n\nConstraints\n- For $30\\%$ of the testdata, $n \\le 5$.\n- For $60\\%$ of the testdata, $n \\le 10^3$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 8 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "函数", "background": "Alice 和 Bob 玩游戏。", "description": "Alice 给出一个 $1$~$n$ 的排列表示一个函数 $y=f(x)$，即给出的第 $i$ 个数字即为 $f(i)$。  \n\n现在 Bob 需要给出一个字典序尽可能小的函数 $y=g(x)$，使得对于任意 $i$，$f(g(i))=g(f(i))$。", "inputFormat": "第一行一个整数 $n$。  \n\n第二行 $n$ 个整数，依次表示 $f(1),f(2) \\cdots f(n)$。", "outputFormat": "共一行，$n$ 个整数，依次表示 $g(1),g(2) \\cdots g(n)$。", "hint": "#### 【样例解释】\n#### 样例 1 说明\n- $g(f(1))=f(g(1))=1$。\n- $g(f(2))=f(g(2))=1$。\n- $g(f(3))=f(g(3))=1$。\n- $g(f(4))=f(g(4))=1$。\n- $g(f(5))=f(g(5))=1$。\n\n#### 样例 2 说明\n- $g(f(1))=f(g(1))=2$。\n- $g(f(2))=f(g(2))=3$。\n- $g(f(3))=f(g(3))=4$。\n- $g(f(4))=f(g(4))=5$。\n- $g(f(5))=f(g(5))=1$。\n\n---\n\n#### 【数据规模与约定】\n对于 $30\\%$ 的数据，$n \\le 5$。\n对于 $60\\%$ 的数据，$n \\le 10^3$。\n对于 $100\\%$ 的数据，$1 \\le n \\le 8 \\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P2583", "type": "P", "difficulty": 5, "samples": [["4\n55\n5 10 15\n4\n0 5 10 20\n4\n0 5 10 15\n4\n18\n1 2 3\n5\n0 3 6 10 12\n6\n0 3 5 7 12 15\n2\n30\n20\n1\n20\n7\n1 3 5 7 11 13 17\n0\n", "Case Number 1: 5\nCase Number 2: 0\nCase Number 3: impossible\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2003", "枚举", "前缀和", "ICPC", "洛谷月赛", "WF"], "title": "[ICPC 2003 WF] 地铁间谍", "background": null, "description": "特工玛利亚被送到 S 市执行一个特别危险的任务。她需要利用地铁完成他的任务，S 市的地铁只有一条线路运行，所以并不复杂。\n\n玛利亚有一个任务，现在的时间为 $0$，她要从第一个站出发，并在最后一站的间谍碰头。玛利亚知道有一个强大的组织正在追踪她，她知道如果一直呆在一个车站，她会有很大的被抓的风险，躲在运行的列车中是比较安全的。所以，她决定尽可能地呆在运行的列车中，她只能往前或往后坐车。\n\n玛利亚为了能准时且安全的到达最后一个车站与对方碰头，需要知道在在车站最小等待时间总和的计划。你必须写一个程序，得到玛丽亚最短的等待时间。当然，到了终点站之后如果时间还没有到规定的时刻，她可以在车站里等着对方，只不过这个等待的时刻也是要算进去的。\n\n这个城市有 $n$ 个车站，编号是 $1\\sim n$，火车是这么移动的：从第一个车站开到最后一个车站。或者从最后一站发车然后开会来。火车在每特定两站之间行驶的时间是固定的，我们也可以忽略停车的时间，玛利亚的速度极快，所以他可以迅速上下车即使两辆车同时到站。", "inputFormat": "输入文件包含多组数据，每组数据都由 $7$ 行组成。\n\n- 第 $1$ 行一个正整数 $N\\ (2 \\le N \\le 50)$ 表示站的数量。\n- 第 $2$ 行一个正整数 $T\\ (0 \\le T \\le 2000)$ 表示需要的碰头时间。\n- 第 $3$ 行 $1\\sim n-1$ 个正整数 $t_i\\ (0<t_i<70)$ 表示两站之间列车的通过时间。\n- 第 $4$ 行一个整数 $M_1\\ (1 \\le M_1 \\le 50)$ 表示离开第一个车站的火车的数量。\n- 第 $5$ 行 $M_1$ 个正整数 $d_1,d_2,\\cdots,d_n\\ (0 \\le d \\le 250$，$d_i<d_i+1)$ 表示每一列火车离开第一站的时间。\n- 第 $6$ 行一个正整数 $M_2\\ (1 \\le M_2 \\le 50)$ 表示离开第 $N$ 站的火车的数量。\n- 第 $7$ 行 $M_2$ 个正整数：$e_1,e_2\\cdots e_{M_2}\\ (0 \\le e \\le 250$，$e_i<e_i+1)$ 表示每一列火车离开第 $N$ 站的时间。\n\n最后一行有一个整数 $0$。", "outputFormat": "对于每组数据，打印一行 $\\text{\\texttt{Case Number }\\textit{N}\\texttt{:}}$（$N$ 从 $1$ 开始）和一个整数表示总等待的最短时间或者一个单词 $\\verb!impossible!$ 如果玛丽亚不可能做到。\n\n可参考样例输出。", "hint": "### 样例 1 解释\n\n她 $0$ 分钟时上车，在 $3$ 号站下车，立刻坐上（$0$ 分始发）$15$ 分开的车回去，到 $2$ 号车站，立刻坐上（$20$ 分始发）$25$ 开的车到终点，$50$ 分到，还需要等待 $5$ 分钟。", "locale": "zh-CN", "translations": {"en": {"title": "[ICPC 2003 WF] Subway Spy", "background": "# Description\n\nAgent Maria has been sent to city S to carry out a particularly dangerous mission. She must use the subway to complete her task; city S has only one subway line in operation, so it is not complicated.\n\nThe current time is $0$. Maria starts from station $1$ and must meet the spy at the last station exactly at time $T$. She knows a powerful organization is tracking her. If she stays at a station, she faces a high risk of being caught; hiding in a moving train is safer. Therefore, she decides to stay on moving trains as much as possible, and she can ride only along the line in either direction (forward or backward).\n\nTo arrive at the last station on time and safely, Maria needs a plan that minimizes the total time she waits at stations. You must write a program to find Maria’s minimal total waiting time. Of course, if she arrives at the terminal earlier than the required time, she can wait at the station for the contact; this waiting time must also be counted.\n\nThere are $n$ stations, numbered $1 \\sim n$. Trains shuttle along the line: either from station $1$ to station $n$, or from station $n$ back to station $1$. The travel time between any two consecutive stations is fixed, dwell times can be ignored, and Maria is extremely fast, so she can board or alight instantly, even if two trains arrive simultaneously.", "description": "", "inputFormat": "", "outputFormat": "For each dataset, print one line $\\text{\\texttt{Case Number }\\textit{N}\\texttt{:}}$ (where $N$ starts from $1$) followed by an integer denoting the minimal total waiting time, or the word $\\verb!impossible!$ if Maria cannot accomplish the task.\n\nSee the sample output.", "hint": "Explanation for Sample 1:\n\nShe boards at minute $0$, gets off at station $3$, immediately takes the train that left at minute $0$ and departs at minute $15$ to go back, gets to station $2$, immediately takes the train that started at minute $20$ and departs at minute $25$ to the terminal, arrives at minute $50$, and then needs to wait $5$ minutes.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ICPC 2003 WF] 地铁间谍", "background": null, "description": "特工玛利亚被送到 S 市执行一个特别危险的任务。她需要利用地铁完成他的任务，S 市的地铁只有一条线路运行，所以并不复杂。\n\n玛利亚有一个任务，现在的时间为 $0$，她要从第一个站出发，并在最后一站的间谍碰头。玛利亚知道有一个强大的组织正在追踪她，她知道如果一直呆在一个车站，她会有很大的被抓的风险，躲在运行的列车中是比较安全的。所以，她决定尽可能地呆在运行的列车中，她只能往前或往后坐车。\n\n玛利亚为了能准时且安全的到达最后一个车站与对方碰头，需要知道在在车站最小等待时间总和的计划。你必须写一个程序，得到玛丽亚最短的等待时间。当然，到了终点站之后如果时间还没有到规定的时刻，她可以在车站里等着对方，只不过这个等待的时刻也是要算进去的。\n\n这个城市有 $n$ 个车站，编号是 $1\\sim n$，火车是这么移动的：从第一个车站开到最后一个车站。或者从最后一站发车然后开会来。火车在每特定两站之间行驶的时间是固定的，我们也可以忽略停车的时间，玛利亚的速度极快，所以他可以迅速上下车即使两辆车同时到站。", "inputFormat": "输入文件包含多组数据，每组数据都由 $7$ 行组成。\n\n- 第 $1$ 行一个正整数 $N\\ (2 \\le N \\le 50)$ 表示站的数量。\n- 第 $2$ 行一个正整数 $T\\ (0 \\le T \\le 2000)$ 表示需要的碰头时间。\n- 第 $3$ 行 $1\\sim n-1$ 个正整数 $t_i\\ (0<t_i<70)$ 表示两站之间列车的通过时间。\n- 第 $4$ 行一个整数 $M_1\\ (1 \\le M_1 \\le 50)$ 表示离开第一个车站的火车的数量。\n- 第 $5$ 行 $M_1$ 个正整数 $d_1,d_2,\\cdots,d_n\\ (0 \\le d \\le 250$，$d_i<d_i+1)$ 表示每一列火车离开第一站的时间。\n- 第 $6$ 行一个正整数 $M_2\\ (1 \\le M_2 \\le 50)$ 表示离开第 $N$ 站的火车的数量。\n- 第 $7$ 行 $M_2$ 个正整数：$e_1,e_2\\cdots e_{M_2}\\ (0 \\le e \\le 250$，$e_i<e_i+1)$ 表示每一列火车离开第 $N$ 站的时间。\n\n最后一行有一个整数 $0$。", "outputFormat": "对于每组数据，打印一行 $\\text{\\texttt{Case Number }\\textit{N}\\texttt{:}}$（$N$ 从 $1$ 开始）和一个整数表示总等待的最短时间或者一个单词 $\\verb!impossible!$ 如果玛丽亚不可能做到。\n\n可参考样例输出。", "hint": "### 样例 1 解释\n\n她 $0$ 分钟时上车，在 $3$ 号站下车，立刻坐上（$0$ 分始发）$15$ 分开的车回去，到 $2$ 号车站，立刻坐上（$20$ 分始发）$25$ 开的车到终点，$50$ 分到，还需要等待 $5$ 分钟。", "locale": "zh-CN"}}}
{"pid": "P2584", "type": "P", "difficulty": 5, "samples": [["20\n+ADAM 1000000\n+BOB 1000000 \n+TOM 2000000\n+CATHY 10000000\n?TOM \n?1\n+DAM 100000 \n+BOB 1200000\n+ADAM 900000 \n+FRANK 12340000 \n+LEO 9000000\n+KAINE 9000000 \n+GRACE 8000000 \n+WALT 9000000 \n+SANDY 8000000 \n+MICK 9000000 \n+JACK 7320000 \n?2 \n?5  \n?KAINE", "2\nCATHY TOM ADAM BOB\nCATHY LEO KAINE WALT MICK GRACE SANDY JACK TOM BOB\nWALT MICK GRACE SANDY JACK TOM BOB ADAM DAM\n4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "各省省选", "平衡树", "浙江", "O2优化", "哈希 hashing"], "title": "[ZJOI2006] GameZ游戏排名系统", "background": "", "description": "GameZ为他们最新推出的游戏开通了一个网站。世界各地的玩家都可以将自己的游戏得分上传到网站上。这样就可以看到自己在世界上的排名。得分越高，排名就越靠前。当两个玩家的名次相同时，先上传记录者优先。由于新游戏的火爆，网站服务器已经难堪重负。为此GameZ雇用了你来帮他们重新开发一套新的核心。\n\n排名系统通常要应付三种请求：上传一条新的得分记录、查询某个玩家的当前排名以及返回某个区段内的排名记录。当某个玩家上传自己最新的得分记录时，他原有的得分记录会被删除。为了减轻服务器负担，在返回某个区段内的排名记录时，最多返回 $10$ 条记录。\n", "inputFormat": "输入文件的第一行是一个整数 $n$ $( n \\ge 10 )$ 表示请求总数目。接下来n行每行包含了一个请求。请求的具体格式如下：\n\n``+Name Score`` 上传最新得分记录。``Name`` 表示玩家名字，由大写英文字母组成，不超过 $10$ 个字符。``Score`` 为最多 $10$ 位的正整数。\n\n``?Name`` 查询玩家排名。该玩家的得分记录必定已经在前面上传。\n\n``?Index`` 返回自第 ``Index`` 名开始的最多 $10$ 名玩家名字。``Index`` 必定合法，即不小于 $1$，也不大于当前有记录的玩家总数。\n\n\n", "outputFormat": "对于每条查询请求，在文件中输出相应结果。\n\n对于 ``?Name`` 格式的请求，应输出一个整数表示该玩家当前的排名。\n\n对于 ``?Index`` 格式的请求，应在一行中依次输出从第 ``Index`` 名开始的最多 $10$ 名玩家姓名，用一个空格分隔。\n", "hint": "20\n+ADAM 1000000     加入ADAM的得分记录\n\n+BOB 1000000       加入BOB的得分记录\n\n+TOM 2000000       加入TOM的得分记录\n\n+CATHY 10000000    加入CATHY的得分记录\n\n?TOM               输出TOM目前排名\n\n?1                  目前有记录的玩家总数为4，因此应输出第1名到第4名。\n\n+DAM 100000        加入DAM的得分记录\n\n+BOB 1200000       更新BOB的得分记录\n\n+ADAM 900000      更新ADAM的得分记录（即使比原来的差）\n\n+FRANK 12340000   加入FRANK的得分记录\n\n+LEO 9000000       加入LEO的得分记录\n\n+KAINE 9000000     加入KAINE的得分记录\n\n+GRACE 8000000    加入GRACE的得分记录\n\n+WALT 9000000      加入WALT的得分记录\n\n+SANDY 8000000    加入SANDY的得分记录\n\n+MICK 9000000      加入MICK的得分记录\n\n+JACK 7320000      加入JACK的得分记录\n\n?2                  目前有记录的玩家总数为12，因此应输出第2名到第11名。\n\n?5                  输出第5名到第13名。\n\n?KAINE             输出KAINE的排名\n\n输入文件总大小不超过 2M。\n\nNOTE：用 C++ 的 fstream 读大规模数据的效率较低", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2006] GameZ Game Ranking System", "background": "", "description": "GameZ launched a website for their latest game, where players around the world can upload their game scores to see their global rankings. Higher scores rank higher. If two players tie, the one who uploaded earlier ranks higher. Due to the game's popularity, the website servers are under heavy load. GameZ has hired you to redevelop a new core system.\n\nThe ranking system needs to handle three types of requests: upload a new score record, query a player's current rank, and return the ranking records within a certain range. When a player uploads their latest score, their previous record will be removed. To reduce server load, when returning ranking records within a range, return at most $10$ records.", "inputFormat": "The first line contains an integer $n$ ($n \\ge 10$), the total number of requests. Each of the next $n$ lines contains one request, in one of the following formats:\n\n``+Name Score`` Upload the latest score record. ``Name`` is the player's name, consisting of uppercase English letters, with length at most $10$ characters. ``Score`` is a positive integer with at most $10$ digits.\n\n``?Name`` Query the player's rank. This player's score record is guaranteed to have been uploaded before.\n\n``?Index`` Return at most $10$ player names starting from rank ``Index``. ``Index`` is guaranteed to be valid, i.e., it is at least $1$ and at most the current number of players with records.", "outputFormat": "For each query request, output the corresponding result.\n\nFor a ``?Name`` request, output a single integer representing the player's current rank.\n\nFor a ``?Index`` request, output in one line the names of at most $10$ players starting from rank ``Index``, separated by single spaces.", "hint": "20\n+ADAM 1000000     Add ADAM's score record.\n+BOB 1000000      Add BOB's score record.\n+TOM 2000000      Add TOM's score record.\n+CATHY 10000000   Add CATHY's score record.\n?TOM              Output TOM's current rank.\n?1                There are currently 4 players with records, so output ranks 1 to 4.\n+DAM 100000       Add DAM's score record.\n+BOB 1200000      Update BOB's score record.\n+ADAM 900000      Update ADAM's score record (even if it is worse than before).\n+FRANK 12340000   Add FRANK's score record.\n+LEO 9000000      Add LEO's score record.\n+KAINE 9000000    Add KAINE's score record.\n+GRACE 8000000    Add GRACE's score record.\n+WALT 9000000     Add WALT's score record.\n+SANDY 8000000    Add SANDY's score record.\n+MICK 9000000     Add MICK's score record.\n+JACK 7320000     Add JACK's score record.\n?2                There are currently 12 players with records, so output ranks 2 to 11.\n?5                Output ranks 5 to 13.\n?KAINE            Output KAINE's rank.\n\nThe total size of the input file does not exceed 2 MB.\n\nNOTE: Using C++ fstream to read large input is inefficient.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2006] GameZ游戏排名系统", "background": "", "description": "GameZ为他们最新推出的游戏开通了一个网站。世界各地的玩家都可以将自己的游戏得分上传到网站上。这样就可以看到自己在世界上的排名。得分越高，排名就越靠前。当两个玩家的名次相同时，先上传记录者优先。由于新游戏的火爆，网站服务器已经难堪重负。为此GameZ雇用了你来帮他们重新开发一套新的核心。\n\n排名系统通常要应付三种请求：上传一条新的得分记录、查询某个玩家的当前排名以及返回某个区段内的排名记录。当某个玩家上传自己最新的得分记录时，他原有的得分记录会被删除。为了减轻服务器负担，在返回某个区段内的排名记录时，最多返回 $10$ 条记录。\n", "inputFormat": "输入文件的第一行是一个整数 $n$ $( n \\ge 10 )$ 表示请求总数目。接下来n行每行包含了一个请求。请求的具体格式如下：\n\n``+Name Score`` 上传最新得分记录。``Name`` 表示玩家名字，由大写英文字母组成，不超过 $10$ 个字符。``Score`` 为最多 $10$ 位的正整数。\n\n``?Name`` 查询玩家排名。该玩家的得分记录必定已经在前面上传。\n\n``?Index`` 返回自第 ``Index`` 名开始的最多 $10$ 名玩家名字。``Index`` 必定合法，即不小于 $1$，也不大于当前有记录的玩家总数。\n\n\n", "outputFormat": "对于每条查询请求，在文件中输出相应结果。\n\n对于 ``?Name`` 格式的请求，应输出一个整数表示该玩家当前的排名。\n\n对于 ``?Index`` 格式的请求，应在一行中依次输出从第 ``Index`` 名开始的最多 $10$ 名玩家姓名，用一个空格分隔。\n", "hint": "20\n+ADAM 1000000     加入ADAM的得分记录\n\n+BOB 1000000       加入BOB的得分记录\n\n+TOM 2000000       加入TOM的得分记录\n\n+CATHY 10000000    加入CATHY的得分记录\n\n?TOM               输出TOM目前排名\n\n?1                  目前有记录的玩家总数为4，因此应输出第1名到第4名。\n\n+DAM 100000        加入DAM的得分记录\n\n+BOB 1200000       更新BOB的得分记录\n\n+ADAM 900000      更新ADAM的得分记录（即使比原来的差）\n\n+FRANK 12340000   加入FRANK的得分记录\n\n+LEO 9000000       加入LEO的得分记录\n\n+KAINE 9000000     加入KAINE的得分记录\n\n+GRACE 8000000    加入GRACE的得分记录\n\n+WALT 9000000      加入WALT的得分记录\n\n+SANDY 8000000    加入SANDY的得分记录\n\n+MICK 9000000      加入MICK的得分记录\n\n+JACK 7320000      加入JACK的得分记录\n\n?2                  目前有记录的玩家总数为12，因此应输出第2名到第11名。\n\n?5                  输出第5名到第13名。\n\n?KAINE             输出KAINE的排名\n\n输入文件总大小不超过 2M。\n\nNOTE：用 C++ 的 fstream 读大规模数据的效率较低", "locale": "zh-CN"}}}
{"pid": "P2585", "type": "P", "difficulty": 4, "samples": [["1122002010", "5 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "2006", "各省省选", "浙江", "深度优先搜索 DFS", "树形 DP"], "title": "[ZJOI2006] 三色二叉树", "background": null, "description": "一棵二叉树可以按照如下规则表示成一个由 $0$、$1$、$2$ 组成的字符序列，我们称之为“二叉树序列 $S$”：\n\n$$S=\n\\begin{cases}\n0& \\text表示该树没有子节点\\\\\n1S_1& 表示该树有一个节点，S_1 为其子树的二叉树序列\\\\\n2S_1S_2& 表示该树有两个子节点，S_1 和 S_2 分别表示其两个子树的二叉树序列\n\\end{cases}$$\n\n例如，下图所表示的二叉树可以用二叉树序列 $S=\\texttt{21200110}$ 来表示。\n\n![haha.png](https://i.loli.net/2020/04/27/Ijw8ZEWCKH2rtJG.png)\n\n你的任务是要对一棵二叉树的节点进行染色。每个节点可以被染成红色、绿色或蓝色。并且，一个节点与其子节点的颜色必须不同，如果该节点有两个子节点，那么这两个子节点的颜色也必须不同。给定一颗二叉树的二叉树序列，请求出这棵树中**最多和最少**有多少个点能够被染成绿色。", "inputFormat": "输入只有一行一个字符串 $s$，表示二叉树序列。", "outputFormat": "输出只有一行，包含两个数，依次表示最多和最少有多少个点能够被染成绿色。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq |s| \\leq 5 \\times 10^5$，$s$ 中只含字符 `0` `1` `2`。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2006] Three-Color Binary Tree", "background": "", "description": "A binary tree can be represented as a character sequence consisting of $0$, $1$, and $2$ according to the following rules, which we call the \"binary tree sequence $S$\":\n\n$$\nS=\n\\begin{cases}\n0 & \\text{indicates that this node has no child} \\\\\n1S_1 & \\text{indicates that this node has one child, and } S_1 \\text{ is the binary tree sequence of its subtree} \\\\\n2S_1S_2 & \\text{indicates that this node has two children, where } S_1 \\text{ and } S_2 \\text{ are the binary tree sequences of its two subtrees}\n\\end{cases}\n$$\n\nFor example, the binary tree shown in the figure below can be represented by the binary tree sequence $S=\\texttt{21200110}$.\n\n![haha.png](https://i.loli.net/2020/04/27/Ijw8ZEWCKH2rtJG.png)\n\nYour task is to color the nodes of a binary tree. Each node can be colored red, green, or blue. A node must have a different color from each of its children, and if it has two children, then the two children must also have different colors. Given the binary tree sequence of a tree, determine the maximum and minimum number of nodes that can be colored green.", "inputFormat": "The input contains a single line with a string $s$, which represents the binary tree sequence.", "outputFormat": "Output a single line with two numbers, indicating the maximum and then the minimum number of nodes that can be colored green.", "hint": "Constraints\n\nFor all test points, it is guaranteed that $1 \\le |s| \\le 5 \\times 10^5$, and $s$ contains only the characters `0` `1` `2`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2006] 三色二叉树", "background": null, "description": "一棵二叉树可以按照如下规则表示成一个由 $0$、$1$、$2$ 组成的字符序列，我们称之为“二叉树序列 $S$”：\n\n$$S=\n\\begin{cases}\n0& \\text表示该树没有子节点\\\\\n1S_1& 表示该树有一个节点，S_1 为其子树的二叉树序列\\\\\n2S_1S_2& 表示该树有两个子节点，S_1 和 S_2 分别表示其两个子树的二叉树序列\n\\end{cases}$$\n\n例如，下图所表示的二叉树可以用二叉树序列 $S=\\texttt{21200110}$ 来表示。\n\n![haha.png](https://i.loli.net/2020/04/27/Ijw8ZEWCKH2rtJG.png)\n\n你的任务是要对一棵二叉树的节点进行染色。每个节点可以被染成红色、绿色或蓝色。并且，一个节点与其子节点的颜色必须不同，如果该节点有两个子节点，那么这两个子节点的颜色也必须不同。给定一颗二叉树的二叉树序列，请求出这棵树中**最多和最少**有多少个点能够被染成绿色。", "inputFormat": "输入只有一行一个字符串 $s$，表示二叉树序列。", "outputFormat": "输出只有一行，包含两个数，依次表示最多和最少有多少个点能够被染成绿色。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq |s| \\leq 5 \\times 10^5$，$s$ 中只含字符 `0` `1` `2`。", "locale": "zh-CN"}}}
{"pid": "P2586", "type": "P", "difficulty": 6, "samples": [["3 5\n1 1 2\n2 2\n5\n", "The game is going on\n5\n5 1 3 1 4\n4 1 3 0 4\n3 1 3 0 3\n2 1 3 0 2\n1 1 4 0 1\n"]], "limits": {"time": [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2008", "各省省选", "浙江"], "title": "[ZJOI2008] 杀蚂蚁", "background": "", "description": "最近，佳佳迷上了一款好玩的小游戏：antbuster。\n\n游戏规则非常简单：在一张地图上，左上角是蚂蚁窝，右下角是蛋糕，蚂蚁会源源不断地从窝里爬出来，试图把蛋糕搬回蚂蚁窝。而你的任务，就是用原始资金以及杀蚂蚁获得的奖金造防御塔，杀掉这些试图跟你抢蛋糕的蚂蚁~\n\n为了拿到尽可能高的分数，佳佳设计了很多种造塔的方案，但在尝试了其中的一小部分后，佳佳发现，这个游戏实在是太费时间了。为了节省时间，佳佳决定写个程序，对于每一种方案，模拟游戏进程，根据效果来判断方案的优劣。\n\n根据自己在游戏中积累的一些经验，以及上网搜到的一些参数，佳佳猜了蚂蚁爬行的算法，并且假设游戏中的蚂蚁也是按这个规则选择路线：\n\n1. 每一秒钟开始的时候，蚂蚁都在平面中的某个整点上。如果蚂蚁没有扛着蛋糕，它会在该点留下 $2$ 单位的信息素，否则它会留下 $5$ 单位的信息素。然后蚂蚁会在正北、正南、正东、正西四个方向中选择一个爬过去。\n\n2. 选择方向的规则是：首先，爬完一个单位长度后到达的那个点上，不能有其他蚂蚁或是防御塔，并且那个点不能是蚂蚁上一秒所在的点（除非上一个时刻蚂蚁就被卡住，且这个时刻它仍无法动），当然，蚂蚁也不会爬出地图的边界（我们定义这些点为不可达点）。如果此时有多个选择，蚂蚁会选择信息素最多的那个点爬过去。\n\n3. 如果此时仍有多种选择，蚂蚁先面向正东，如果正东不是可选择的某个方向，它会顺时针转 $90^\\degree$，再次判断，如果还不是，再顺时针旋转 $90^\\degree$，直到找到可以去的方向。\n\n4. 如果将每只蚂蚁在洞口出现的时间作为它的活动时间的第 $1$ 秒，那么每当这只蚂蚁的活动时间秒数为 $5$ 的倍数的时候，它先按规则 $1\\sim 3$ 确定一个方向，面对该方向后逆时针转 $90^\\degree$，若它沿当前方向会走到一个不可达点，它会不停地每次逆时针转 $90^\\degree$，直到它面对着一个可达的点，这样定下的方向才是蚂蚁最终要爬去的方向。\n\n5. 如果蚂蚁的四周都是不可达点，那么蚂蚁在这一秒内会选择停留在当前点。下一秒判断移动方向时，它上一秒所在点为其当前停留的点。\n\n6. 你可以认为蚂蚁在选定方向后，瞬间移动到它的目标点，这一秒钟剩下的时间里，它就停留在目标点。\n\n7. 蚂蚁按出生的顺序移动，出生得比较早的蚂蚁先移动。\n\n然后，是一些有关地图的信息：\n\n1. 每一秒，地图所有点上的信息素会损失 $1$ 单位，如果那个点上有信息素的话。\n\n2. 地图上某些地方是炮台。炮台的坐标在输入中给出。\n\n3. 地图的长、宽在输入中给出，对于 $n\\times m$ 的地图，它的左上角坐标为 $(0,0)$，右下角坐标为 $(n,m)$。蚂蚁洞的位置为 $(0,0)$，蛋糕的位置为 $(n,m)$。\n\n4. 你可以把蚂蚁看做一个直径为 $1$ 单位的圆，圆心位于蚂蚁所在的整点。\n\n5. 游戏开始时，地图上没有蚂蚁，每个点上的信息素含量均为 $0$。\n\n一些有关炮塔的信息：\n\n1. 炮塔被放置在地图上的整点处。\n\n2. 为了简单一些，我们认为这些炮塔都是激光塔。激光塔的射速是 $1$ 秒每次，它的攻击伤害为 $d$ 单位每次，攻击范围为 $r$。你可以认为每秒蚂蚁移动完毕后，塔才开始攻击。并且，只有当代表蚂蚁的圆的圆心与塔的直线距离不超过 $r$ 时，塔才算打得到那只蚂蚁。\n\n3. 如果一只蚂蚁扛着蛋糕，那么它会成为 target，也就是说，任何打得到它的塔的炮口都会对准它。如果蛋糕好好地呆在原位，那么每个塔都会挑离它最近的蚂蚁进行攻击，如果有多只蚂蚁，它会选出生较早的一只。如果有蚂蚁扛着蛋糕，但是不在某个塔的攻击范围内，这个塔会选择最近的蚂蚁进行攻击。\n\n4. 激光塔有个比较奇怪的特性：它在选定了打击目标后，只要目标在其射程内，塔到目标蚂蚁圆心的连线上的所有蚂蚁（这里“被打到”的判定变成了表示激光的线段与表示蚂蚁的圆有公共点）都会被打到并损 $d$ 格血，但激光不会穿透它的打击目标打到后面的蚂蚁。\n\n5. 尽管在真实游戏中，塔是可以升级的，但在这里我们认为塔的布局和等级就此定了下来，不再变动。\n\n再介绍一下蚂蚁窝：\n\n1. 如果地图上的蚂蚁不足 $6$ 只，并且洞口（即点 $(0,0)$）没有蚂蚁，那么窝中每秒会爬出一只蚂蚁，直到地图上的蚂蚁数为 $6$ 只。\n\n2. 刚出生的蚂蚁站在洞口。\n\n3. 每只蚂蚁有一个级别，级别决定了蚂蚁的血量，级别为 $k$ 的蚂蚁的血量为 $\\lfloor 4\\times 1.1^k\\rfloor$（$\\lfloor x\\rfloor$ 表示对 $x$ 下取整）。每被塔打一次，蚂蚁的血减少 $d$。注意，血量为 $0$ 的蚂蚁仍能精力充沛地四处乱爬，只有一只蚂蚁的血被打成负数时，它才算挂了。\n\n4. 蚂蚁的级别是这样算的：前 $6$ 只出生的蚂蚁是 $1$ 级，第 $7\\sim 12$ 只是 $2$级，依此类推第 $6k+1\\sim 6k+6$ 的等级是 $k+1(k\\in \\Bbb{N})$。\n\n最后给出关于蛋糕的介绍：\n\n1. 简单起见，你可以认为此时只剩最后一块蛋糕了。如果有蚂蚁走到蛋糕的位置，并且此时蛋糕没有被扛走，那么这只蚂蚁就扛上了蛋糕。蚂蚁被打死后蛋糕回到点 $(n,m)$。\n\n2. 如果一只扛着蛋糕的蚂蚁走到蚂蚁窝的位置，我们就认为蚂蚁成功抢到了蛋糕，游戏结束。这个回合不会对蚂蚁的年龄产生贡献。\n\n3. 蚂蚁扛上蛋糕时，血量会增加 $\\left\\lfloor\\dfrac{x}{2}\\right\\rfloor$（$x$ 表示蚂蚁出生时的血量），但不会超过蚂蚁的血量上限。\n\n整理一下 $1$ 秒钟内发生的事件：\n\n1. $1$ 秒的最初，如果地图上蚂蚁数不足 $6$，一只蚂蚁就会在洞口出生。\n\n2. 接着，蚂蚁们在自己所在点留下一些信息素后，考虑移动。先出生的蚂蚁先移动。\n\n3. 移动完毕后，如果有蚂蚁在蛋糕的位置上并且蛋糕没被拿走，它把蛋糕扛上，血量增加，并在这时被所有塔设成 target。\n\n4. 然后所有塔同时开始攻击。如果攻击结束后那只扛着蛋糕的蚂蚁挂了，蛋糕瞬间归位。扛着蛋糕的蚂蚁死后，蛋糕会在下一秒钟所有蚂蚁移动完之后再出现。下一秒钟出现在 $(n,m)$ 的蚂蚁才会获得蛋糕。\n\n5. 攻击结束后，如果发现扛蛋糕的蚂蚁没死并在窝的位置，就认为蚂蚁抢到了蛋糕，游戏也在此时结束。\n\n6. 最后，地图上所有点的信息素损失 $1$ 单位。所有蚂蚁的年龄加 $1$。漫长的 $1$ 秒到此结束。", "inputFormat": "输入的第一行是两个用空格隔开的正整数，$n,m$，分别表示了地图的长和宽。\n\n第二行是三个用空格隔开的整数，$s,d,r$，依次表示炮塔的个数、单次攻击伤害以及攻击范围。\n\n接下来 $s$ 行，每行两个用空格隔开的整数 $x,y$，描述了一个炮塔的位置。当然，蚂蚁窝的洞口以及蛋糕所在的位置上一定没有炮塔。\n\n最后一行是一个正整数 $t$，表示我们模拟游戏的前 $t$ 秒钟。", "outputFormat": "如果在第 $t$ 秒或之前蚂蚁抢到了蛋糕，输出一行 `Game over after x seconds`，其中 $x$ 为游戏结束的时间，否则输出 `The game is going on`。\n\n如果游戏在 $t$ 秒或之前结束，输出游戏结束时所有蚂蚁的信息，否则输出 $t$ 秒后所有蚂蚁的信息。格式如下：\n\n第一行是一个整数 $s$，表示此时活着的蚂蚁的总数。\n\n接下来 $s$ 行，每行五个整数，依次表示一只蚂蚁的年龄（单位为秒）、等级、当前血量，以及在地图上的位置 $(a,b)$。输出按蚂蚁的年龄递减排序。", "hint": "### 样例说明：\n\n$3\\times 5$ 的地图，有一个单次伤害为 $1$、攻击范围为 $2$ 的激光炮塔，它的位置为 $(2,2)$，模拟游戏的前 $5$ 秒。\n\n$5$ 秒内有 $5$ 只蚂蚁出生，都是向东爬行，其中第 $1\\sim 4$ 只在路过 $(0,2)$ 点时被激光塔射伤了 $1$ 格血。在第 $5$ 秒的时候，最早出生的蚂蚁按移动规则 $1\\sim 3$ 本来该向东移动，但由于规则 $4$ 的作用，它在发现向北和向西移动都会到达不可达点后，最终选择了向南移动。\n\n### 数据范围说明：\n\n对于 $100\\%$ 的数据，满足 $1\\leqslant n,m\\leqslant 8,s\\leqslant 20,t\\leqslant 2\\times 10^5,0\\leqslant d\\leqslant 10^4,0\\leqslant r\\leqslant 15$。（这里的 $s$ 指的是炮塔的总数）。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2008] Kill Ants", "background": "", "description": "Recently, Jiajia got hooked on a fun mini-game: antbuster.\n\nThe rules are simple: on a map, the top-left corner is the ant nest, and the bottom-right corner is the cake. Ants continuously crawl out of the nest, trying to carry the cake back to the nest. Your task is to use the initial funds and the bounty from killing ants to build defense towers to kill those ants that try to grab your cake.\n\nTo get the highest possible score, Jiajia designed many tower layouts. But after trying only a small fraction of them, Jiajia found the game too time-consuming. To save time, Jiajia decided to write a program to simulate each plan and evaluate it based on the results.\n\nBased on experience in the game and some parameters found online, Jiajia guessed the ants’ crawling algorithm and assumes the ants in the game choose their routes according to the following rules:\n\n1. At the start of each second, every ant is on some grid point in the plane. If an ant is not carrying the cake, it leaves $2$ units of pheromone at that point; otherwise, it leaves $5$ units. Then it chooses one direction among north, south, east, and west to crawl to.\n\n2. The direction selection rule is: first, the destination point reached after moving one unit must not be occupied by another ant or a tower, and that point cannot be the ant’s position from the previous second (unless the ant was stuck in the previous tick and still cannot move now). Of course, ants will not crawl outside the map (we define such points as unreachable). If there are multiple choices, the ant will choose the point with the highest pheromone.\n\n3. If there is still a tie, the ant first faces due east. If east is not among the selectable directions, it turns $90^\\degree$ clockwise and checks again; if still not, it continues turning $90^\\degree$ clockwise until it finds a valid direction.\n\n4. If we regard the time when each ant appears at the nest entrance as the first second of its life, then whenever the ant’s age in seconds is a multiple of $5$, it first determines a direction according to rules 1–3, then turns $90^\\degree$ counterclockwise from that facing. If moving along the current direction leads to an unreachable point, it keeps turning $90^\\degree$ counterclockwise each time until it faces a reachable point. The direction determined in this way is the final direction the ant will crawl.\n\n5. If all four neighboring points are unreachable, the ant will choose to stay at its current point for this second. When determining the movement direction next second, its previous position is its current resting point.\n\n6. You may assume that after choosing a direction, the ant instantly moves to its target point and then remains at the target point for the rest of the second.\n\n7. Ants move in their birth order. Earlier-born ants move first.\n\nNext, some information about the map:\n\n1. Each second, the pheromone value on every map point decreases by $1$ unit if it is positive.\n\n2. Some places on the map are towers. Tower coordinates are given in the input.\n\n3. The map’s length and width are given in the input. For an $n \\times m$ map, the top-left corner is $(0,0)$ and the bottom-right corner is $(n,m)$. The ant nest is at $(0,0)$ and the cake is at $(n,m)$.\n\n4. You can consider an ant as a circle of diameter $1$, with its center located at the grid point where the ant is.\n\n5. At the beginning of the game, there are no ants on the map, and the pheromone value at every point is $0$.\n\nSome information about towers:\n\n1. Towers are placed at grid points on the map.\n\n2. For simplicity, we assume all towers are laser towers. A laser tower fires once per second, deals $d$ damage per shot, and has attack range $r$. You may assume that towers only begin attacking after all ants have finished moving in that second. Moreover, a tower can hit an ant only if the distance from the tower to the center of the ant’s circle does not exceed $r$.\n\n3. If an ant is carrying the cake, it becomes the target. That is, any tower that can reach it will aim at it. If the cake remains at its original position, each tower will choose the nearest ant to attack; if there is a tie, it picks the earlier-born one. If there is a cake-carrying ant but it is outside a certain tower’s range, that tower chooses the nearest ant to attack.\n\n4. Laser towers have a peculiar property: once a target is selected, as long as the target is within range, all ants whose circles intersect the line segment from the tower to the target ant’s center (here, being “hit” is determined by whether the laser segment and the ant’s circle have an intersection) will be hit and lose $d$ HP. However, the laser will not penetrate through its target to hit ants behind it.\n\n5. Although towers can be upgraded in the actual game, here we assume the tower layout and levels are fixed and will not change.\n\nNow about the ant nest:\n\n1. If there are fewer than $6$ ants on the map and the nest entrance (i.e., point $(0,0)$) is unoccupied, one ant will crawl out each second until there are $6$ ants on the map.\n\n2. A newly born ant stands at the nest entrance.\n\n3. Each ant has a level, which determines its HP. An ant of level $k$ has HP $\\lfloor 4 \\times 1.1^k \\rfloor$ (where $\\lfloor x \\rfloor$ denotes the floor of $x$). Each time it is hit by a tower, its HP decreases by $d$. Note that an ant with HP equal to $0$ can still move around vigorously; only when an ant’s HP becomes negative is it considered dead.\n\n4. Ant levels are assigned as follows: the first $6$ ants are level $1$, ants $7 \\sim 12$ are level $2$, and so on. Ants numbered $6k+1 \\sim 6k+6$ have level $k+1$ ($k \\in \\Bbb{N}$).\n\nFinally, an introduction to the cake:\n\n1. For simplicity, assume there is only the last piece of cake left. If an ant reaches the cake’s position while the cake is not being carried, that ant picks up the cake. When an ant is killed, the cake returns to $(n,m)$.\n\n2. If an ant carrying the cake reaches the nest location, we consider the ant to have successfully stolen the cake, and the game ends. This tick does not contribute to the ant’s age.\n\n3. When an ant picks up the cake, its HP increases by $\\left\\lfloor \\dfrac{x}{2} \\right\\rfloor$ (where $x$ is the ant’s HP at birth), but does not exceed its maximum HP.\n\nTo sum up, what happens within one second:\n\n1. At the very beginning of the second, if there are fewer than $6$ ants on the map, one ant is born at the nest entrance.\n\n2. Then ants leave pheromones at their current points and decide their moves. Earlier-born ants move first.\n\n3. After movement, if an ant is at the cake’s position and the cake has not been taken, it picks up the cake, gains HP, and is set as the target by all towers at this moment.\n\n4. Then all towers attack simultaneously. If the ant carrying the cake dies after the attack, the cake instantly returns to its place. After the cake-carrying ant dies, the cake will reappear only after all ants have finished moving in the next second. Only ants that appear at $(n,m)$ in the next second can pick up the cake.\n\n5. After the attack, if the cake-carrying ant is alive and at the nest’s position, we consider the cake stolen and the game ends at this moment.\n\n6. Finally, the pheromone value on every map point decreases by $1$ unit. All ants’ ages increase by $1$. The long second ends here.", "inputFormat": "The first line contains two positive integers $n, m$, the map’s length and width, separated by a space.\n\nThe second line contains three integers $s, d, r$, denoting the number of towers, the damage per attack, and the attack range, respectively.\n\nThe next $s$ lines each contain two integers $x, y$, describing the position of a tower. Of course, there are no towers at the nest entrance or at the cake’s position.\n\nThe last line contains a positive integer $t$, indicating that we simulate the first $t$ seconds of the game.", "outputFormat": "If the cake is stolen by second $t$ or earlier, output a line `Game over after x seconds`, where $x$ is the time when the game ends; otherwise, output `The game is going on`.\n\nIf the game ends by second $t$ or earlier, output the information of all ants at the end of the game; otherwise, output the information of all ants after $t$ seconds. The format is as follows:\n\nThe first line is an integer $s$, the total number of ants alive at that time.\n\nThe next $s$ lines each contain five integers, representing an ant’s age (in seconds), level, current HP, and its position $(a,b)$ on the map, in that order. Output should be sorted by age in descending order.", "hint": "Sample explanation:\n\nOn a $3 \\times 5$ map, there is one laser tower with damage $1$ and attack range $2$, located at $(2,2)$. Simulate the first $5$ seconds of the game.\n\nWithin $5$ seconds, $5$ ants are born. They all crawl east. Among them, ants $1 \\sim 4$ are each hit for $1$ HP when passing through $(0,2)$ by the laser tower. In the $5$-th second, the earliest-born ant would have moved east according to movement rules 1–3, but due to rule 4, after finding that moving north or west would lead to unreachable points, it finally chooses to move south.\n\nConstraints:\n\nFor $100\\%$ of the testdata, $1 \\leqslant n,m \\leqslant 8$, $s \\leqslant 20$, $t \\leqslant 2 \\times 10^5$, $0 \\leqslant d \\leqslant 10^4$, $0 \\leqslant r \\leqslant 15$. (Here $s$ denotes the total number of towers.)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2008] 杀蚂蚁", "background": "", "description": "最近，佳佳迷上了一款好玩的小游戏：antbuster。\n\n游戏规则非常简单：在一张地图上，左上角是蚂蚁窝，右下角是蛋糕，蚂蚁会源源不断地从窝里爬出来，试图把蛋糕搬回蚂蚁窝。而你的任务，就是用原始资金以及杀蚂蚁获得的奖金造防御塔，杀掉这些试图跟你抢蛋糕的蚂蚁~\n\n为了拿到尽可能高的分数，佳佳设计了很多种造塔的方案，但在尝试了其中的一小部分后，佳佳发现，这个游戏实在是太费时间了。为了节省时间，佳佳决定写个程序，对于每一种方案，模拟游戏进程，根据效果来判断方案的优劣。\n\n根据自己在游戏中积累的一些经验，以及上网搜到的一些参数，佳佳猜了蚂蚁爬行的算法，并且假设游戏中的蚂蚁也是按这个规则选择路线：\n\n1. 每一秒钟开始的时候，蚂蚁都在平面中的某个整点上。如果蚂蚁没有扛着蛋糕，它会在该点留下 $2$ 单位的信息素，否则它会留下 $5$ 单位的信息素。然后蚂蚁会在正北、正南、正东、正西四个方向中选择一个爬过去。\n\n2. 选择方向的规则是：首先，爬完一个单位长度后到达的那个点上，不能有其他蚂蚁或是防御塔，并且那个点不能是蚂蚁上一秒所在的点（除非上一个时刻蚂蚁就被卡住，且这个时刻它仍无法动），当然，蚂蚁也不会爬出地图的边界（我们定义这些点为不可达点）。如果此时有多个选择，蚂蚁会选择信息素最多的那个点爬过去。\n\n3. 如果此时仍有多种选择，蚂蚁先面向正东，如果正东不是可选择的某个方向，它会顺时针转 $90^\\degree$，再次判断，如果还不是，再顺时针旋转 $90^\\degree$，直到找到可以去的方向。\n\n4. 如果将每只蚂蚁在洞口出现的时间作为它的活动时间的第 $1$ 秒，那么每当这只蚂蚁的活动时间秒数为 $5$ 的倍数的时候，它先按规则 $1\\sim 3$ 确定一个方向，面对该方向后逆时针转 $90^\\degree$，若它沿当前方向会走到一个不可达点，它会不停地每次逆时针转 $90^\\degree$，直到它面对着一个可达的点，这样定下的方向才是蚂蚁最终要爬去的方向。\n\n5. 如果蚂蚁的四周都是不可达点，那么蚂蚁在这一秒内会选择停留在当前点。下一秒判断移动方向时，它上一秒所在点为其当前停留的点。\n\n6. 你可以认为蚂蚁在选定方向后，瞬间移动到它的目标点，这一秒钟剩下的时间里，它就停留在目标点。\n\n7. 蚂蚁按出生的顺序移动，出生得比较早的蚂蚁先移动。\n\n然后，是一些有关地图的信息：\n\n1. 每一秒，地图所有点上的信息素会损失 $1$ 单位，如果那个点上有信息素的话。\n\n2. 地图上某些地方是炮台。炮台的坐标在输入中给出。\n\n3. 地图的长、宽在输入中给出，对于 $n\\times m$ 的地图，它的左上角坐标为 $(0,0)$，右下角坐标为 $(n,m)$。蚂蚁洞的位置为 $(0,0)$，蛋糕的位置为 $(n,m)$。\n\n4. 你可以把蚂蚁看做一个直径为 $1$ 单位的圆，圆心位于蚂蚁所在的整点。\n\n5. 游戏开始时，地图上没有蚂蚁，每个点上的信息素含量均为 $0$。\n\n一些有关炮塔的信息：\n\n1. 炮塔被放置在地图上的整点处。\n\n2. 为了简单一些，我们认为这些炮塔都是激光塔。激光塔的射速是 $1$ 秒每次，它的攻击伤害为 $d$ 单位每次，攻击范围为 $r$。你可以认为每秒蚂蚁移动完毕后，塔才开始攻击。并且，只有当代表蚂蚁的圆的圆心与塔的直线距离不超过 $r$ 时，塔才算打得到那只蚂蚁。\n\n3. 如果一只蚂蚁扛着蛋糕，那么它会成为 target，也就是说，任何打得到它的塔的炮口都会对准它。如果蛋糕好好地呆在原位，那么每个塔都会挑离它最近的蚂蚁进行攻击，如果有多只蚂蚁，它会选出生较早的一只。如果有蚂蚁扛着蛋糕，但是不在某个塔的攻击范围内，这个塔会选择最近的蚂蚁进行攻击。\n\n4. 激光塔有个比较奇怪的特性：它在选定了打击目标后，只要目标在其射程内，塔到目标蚂蚁圆心的连线上的所有蚂蚁（这里“被打到”的判定变成了表示激光的线段与表示蚂蚁的圆有公共点）都会被打到并损 $d$ 格血，但激光不会穿透它的打击目标打到后面的蚂蚁。\n\n5. 尽管在真实游戏中，塔是可以升级的，但在这里我们认为塔的布局和等级就此定了下来，不再变动。\n\n再介绍一下蚂蚁窝：\n\n1. 如果地图上的蚂蚁不足 $6$ 只，并且洞口（即点 $(0,0)$）没有蚂蚁，那么窝中每秒会爬出一只蚂蚁，直到地图上的蚂蚁数为 $6$ 只。\n\n2. 刚出生的蚂蚁站在洞口。\n\n3. 每只蚂蚁有一个级别，级别决定了蚂蚁的血量，级别为 $k$ 的蚂蚁的血量为 $\\lfloor 4\\times 1.1^k\\rfloor$（$\\lfloor x\\rfloor$ 表示对 $x$ 下取整）。每被塔打一次，蚂蚁的血减少 $d$。注意，血量为 $0$ 的蚂蚁仍能精力充沛地四处乱爬，只有一只蚂蚁的血被打成负数时，它才算挂了。\n\n4. 蚂蚁的级别是这样算的：前 $6$ 只出生的蚂蚁是 $1$ 级，第 $7\\sim 12$ 只是 $2$级，依此类推第 $6k+1\\sim 6k+6$ 的等级是 $k+1(k\\in \\Bbb{N})$。\n\n最后给出关于蛋糕的介绍：\n\n1. 简单起见，你可以认为此时只剩最后一块蛋糕了。如果有蚂蚁走到蛋糕的位置，并且此时蛋糕没有被扛走，那么这只蚂蚁就扛上了蛋糕。蚂蚁被打死后蛋糕回到点 $(n,m)$。\n\n2. 如果一只扛着蛋糕的蚂蚁走到蚂蚁窝的位置，我们就认为蚂蚁成功抢到了蛋糕，游戏结束。这个回合不会对蚂蚁的年龄产生贡献。\n\n3. 蚂蚁扛上蛋糕时，血量会增加 $\\left\\lfloor\\dfrac{x}{2}\\right\\rfloor$（$x$ 表示蚂蚁出生时的血量），但不会超过蚂蚁的血量上限。\n\n整理一下 $1$ 秒钟内发生的事件：\n\n1. $1$ 秒的最初，如果地图上蚂蚁数不足 $6$，一只蚂蚁就会在洞口出生。\n\n2. 接着，蚂蚁们在自己所在点留下一些信息素后，考虑移动。先出生的蚂蚁先移动。\n\n3. 移动完毕后，如果有蚂蚁在蛋糕的位置上并且蛋糕没被拿走，它把蛋糕扛上，血量增加，并在这时被所有塔设成 target。\n\n4. 然后所有塔同时开始攻击。如果攻击结束后那只扛着蛋糕的蚂蚁挂了，蛋糕瞬间归位。扛着蛋糕的蚂蚁死后，蛋糕会在下一秒钟所有蚂蚁移动完之后再出现。下一秒钟出现在 $(n,m)$ 的蚂蚁才会获得蛋糕。\n\n5. 攻击结束后，如果发现扛蛋糕的蚂蚁没死并在窝的位置，就认为蚂蚁抢到了蛋糕，游戏也在此时结束。\n\n6. 最后，地图上所有点的信息素损失 $1$ 单位。所有蚂蚁的年龄加 $1$。漫长的 $1$ 秒到此结束。", "inputFormat": "输入的第一行是两个用空格隔开的正整数，$n,m$，分别表示了地图的长和宽。\n\n第二行是三个用空格隔开的整数，$s,d,r$，依次表示炮塔的个数、单次攻击伤害以及攻击范围。\n\n接下来 $s$ 行，每行两个用空格隔开的整数 $x,y$，描述了一个炮塔的位置。当然，蚂蚁窝的洞口以及蛋糕所在的位置上一定没有炮塔。\n\n最后一行是一个正整数 $t$，表示我们模拟游戏的前 $t$ 秒钟。", "outputFormat": "如果在第 $t$ 秒或之前蚂蚁抢到了蛋糕，输出一行 `Game over after x seconds`，其中 $x$ 为游戏结束的时间，否则输出 `The game is going on`。\n\n如果游戏在 $t$ 秒或之前结束，输出游戏结束时所有蚂蚁的信息，否则输出 $t$ 秒后所有蚂蚁的信息。格式如下：\n\n第一行是一个整数 $s$，表示此时活着的蚂蚁的总数。\n\n接下来 $s$ 行，每行五个整数，依次表示一只蚂蚁的年龄（单位为秒）、等级、当前血量，以及在地图上的位置 $(a,b)$。输出按蚂蚁的年龄递减排序。", "hint": "### 样例说明：\n\n$3\\times 5$ 的地图，有一个单次伤害为 $1$、攻击范围为 $2$ 的激光炮塔，它的位置为 $(2,2)$，模拟游戏的前 $5$ 秒。\n\n$5$ 秒内有 $5$ 只蚂蚁出生，都是向东爬行，其中第 $1\\sim 4$ 只在路过 $(0,2)$ 点时被激光塔射伤了 $1$ 格血。在第 $5$ 秒的时候，最早出生的蚂蚁按移动规则 $1\\sim 3$ 本来该向东移动，但由于规则 $4$ 的作用，它在发现向北和向西移动都会到达不可达点后，最终选择了向南移动。\n\n### 数据范围说明：\n\n对于 $100\\%$ 的数据，满足 $1\\leqslant n,m\\leqslant 8,s\\leqslant 20,t\\leqslant 2\\times 10^5,0\\leqslant d\\leqslant 10^4,0\\leqslant r\\leqslant 15$。（这里的 $s$ 指的是炮塔的总数）。", "locale": "zh-CN"}}}
{"pid": "P2587", "type": "P", "difficulty": 4, "samples": [["2\n1\n3\n2\n4\n", "2 0"], ["6\n10000000\n10000000\n10000000\n10000000\n10000000\n10000000\n0\n0\n0\n0\n0\n0\n", "12 12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2008", "各省省选", "浙江"], "title": "[ZJOI2008] 泡泡堂", "background": "", "description": "第 XXXX 届 NOI 期间，为了加强各省选手之间的交流，组委会决定组织一场省际电子竞技大赛，每一个省的代表队由 $n$ 名选手组成，比赛的项目是老少咸宜的网络游戏泡泡堂。每一场比赛前，对阵双方的教练向组委会提交一份参赛选手的名单，决定了选手上场的顺序，一经确定，不得修改。比赛中，双方的一号选手，二号选手……，$n$ 号选手捉对厮杀，共进行 $n$ 场比赛。每胜一场比赛得 $2$ 分，平一场得 $1$ 分，输一场不得分。最终将双方的单场得分相加得出总分，总分高的队伍晋级(总分相同抽签决定)。\n\n作为浙江队的领队，你已经在事先将各省所有选手的泡泡堂水平了解的一清二楚，并将其用一个实力值来衡量。为简化问题，我们假定选手在游戏中完全不受任何外界因素干扰，即实力强的选手一定可以战胜实力弱的选手，而两个实力相同的选手一定会战平。由于完全不知道对手会使用何种策略来确定出场顺序，所以所有的队伍都采取了这样一种策略，就是完全随机决定出场顺序。\n\n当然你不想这样不明不白的进行比赛。你想事先了解一下在最好与最坏的情况下，浙江队最终分别能得到多少分。\n", "inputFormat": "输入文件的第一行为一个整数 $n$，表示每支代表队的人数。\n\n接下来 $n$ 行，每行一个整数，描述了 $n$ 位浙江队的选手的实力值。\n\n接下来 $n$ 行，每行一个整数，描述了你的对手的 $n$ 位选手的实力值。\n\n\n", "outputFormat": "输入文件中包括两个用空格隔开的整数，分别表示浙江队在最好与最坏的情况下分别能得多少分。不要在行末输出多余的空白字符。\n", "hint": "样例说明\n\n1：我们分别称 $4$ 位选手为 $A,B,C,D$ 。则可能出现以下 $4$ 种对战方式，最好情况下可得 $2$ 分，最坏情况下得 $0$ 分。\n\n| | 浙江 | ？？？ | 结果 | 浙江 | ？？？ | 结果 |  浙江 | ？？？ | 结果 | 浙江 | ？？？ | 结果 |\n| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |\n| 一号 | A | C | 负 | A | D | 负 | B | C | 胜 | B | D | 负 |\n| 二号 | B | D | 负 | B | C | 胜 | A | D | 负 | A | C | 负 |\n| 得分 |  |  | 0 |  |  | 2 |  |  | 2 |  |  | 0 |\n\n\n2：对手都是认真学习的好孩子，不会打游戏。无论如何排列出场顺序都无法改变被蹂躏的结果。浙江队总能取得全胜的结果。\n\n$20\\%$ 的数据中，$1\\leq n\\leq 10$；\n\n$40\\%$ 的数据中，$1\\leq n\\leq 100$；\n\n$60\\%$ 的数据中，$1\\leq n\\leq 1000$；\n\n$100\\%$ 的数据中，$1\\leq n\\leq 100000$，且所有选手的实力值在 $0$ 到 $10000000$ 之间。\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2008] Paopaotang", "background": "", "description": "During the XXXX-th NOI, to strengthen exchanges among provincial contestants, the organizers decided to hold an inter-provincial e-sports tournament. Each province’s team consists of $n$ players. The event is the popular online game Paopaotang. Before each match, both coaches submit a lineup that fixes the playing order; once submitted, it cannot be changed. In the match, the No. 1 players, No. 2 players, ..., No. $n$ players face off pairwise, for a total of $n$ games. A win yields $2$ points, a draw $1$ point, and a loss $0$ points. The total score is the sum of the single-game points; the team with the higher total advances (if the totals are equal, the winner is decided by drawing lots).\n\nAs the leader of Team Zhejiang, you have already learned the skill levels of all players from every province and measure each by a strength value. To simplify the problem, we assume players are not affected by any external factors: a stronger player always defeats a weaker player, and two players with equal strength always draw. Since the opponent’s strategy for choosing the order is completely unknown, all teams adopt the strategy of deciding the playing order completely at random.\n\nOf course, you do not want to compete without clarity. You want to know in advance, in the best and worst cases, how many points Team Zhejiang can obtain.", "inputFormat": "The first line contains an integer $n$, the number of players on each team.\n\nThe next $n$ lines each contain one integer, the strength values of the $n$ players on Team Zhejiang.\n\nThe following $n$ lines each contain one integer, the strength values of the opponent’s $n$ players.", "outputFormat": "Output two integers separated by a space, representing the best and the worst possible total points that Team Zhejiang can obtain. Do not output extra spaces at the end of the line.", "hint": "Sample explanation\n\n1: We name the $4$ players $A, B, C, D$. The following $4$ types of matchups may occur. In the best case, Zhejiang can get $2$ points; in the worst case, it gets $0$ points.\n\n| | Zhejiang | Opponent | Result | Zhejiang | Opponent | Result | Zhejiang | Opponent | Result | Zhejiang | Opponent | Result |\n| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |\n| No. 1 | A | C | Loss | A | D | Loss | B | C | Win | B | D | Loss |\n| No. 2 | B | D | Loss | B | C | Win | A | D | Loss | A | C | Loss |\n| Score |  |  | 0 |  |  | 2 |  |  | 2 |  |  | 0 |\n\n2: The opponents are all diligent students who do not play games. No matter how they arrange the order, they cannot change the outcome. Team Zhejiang always achieves a clean sweep.\n\nConstraints\n\n- For $20\\%$ of the testdata, $1 \\leq n \\leq 10$.\n- For $40\\%$ of the testdata, $1 \\leq n \\leq 100$.\n- For $60\\%$ of the testdata, $1 \\leq n \\leq 1000$.\n- For $100\\%$ of the testdata, $1 \\leq n \\leq 100000$, and all players’ strength values are between $0$ and $10000000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2008] 泡泡堂", "background": "", "description": "第 XXXX 届 NOI 期间，为了加强各省选手之间的交流，组委会决定组织一场省际电子竞技大赛，每一个省的代表队由 $n$ 名选手组成，比赛的项目是老少咸宜的网络游戏泡泡堂。每一场比赛前，对阵双方的教练向组委会提交一份参赛选手的名单，决定了选手上场的顺序，一经确定，不得修改。比赛中，双方的一号选手，二号选手……，$n$ 号选手捉对厮杀，共进行 $n$ 场比赛。每胜一场比赛得 $2$ 分，平一场得 $1$ 分，输一场不得分。最终将双方的单场得分相加得出总分，总分高的队伍晋级(总分相同抽签决定)。\n\n作为浙江队的领队，你已经在事先将各省所有选手的泡泡堂水平了解的一清二楚，并将其用一个实力值来衡量。为简化问题，我们假定选手在游戏中完全不受任何外界因素干扰，即实力强的选手一定可以战胜实力弱的选手，而两个实力相同的选手一定会战平。由于完全不知道对手会使用何种策略来确定出场顺序，所以所有的队伍都采取了这样一种策略，就是完全随机决定出场顺序。\n\n当然你不想这样不明不白的进行比赛。你想事先了解一下在最好与最坏的情况下，浙江队最终分别能得到多少分。\n", "inputFormat": "输入文件的第一行为一个整数 $n$，表示每支代表队的人数。\n\n接下来 $n$ 行，每行一个整数，描述了 $n$ 位浙江队的选手的实力值。\n\n接下来 $n$ 行，每行一个整数，描述了你的对手的 $n$ 位选手的实力值。\n\n\n", "outputFormat": "输入文件中包括两个用空格隔开的整数，分别表示浙江队在最好与最坏的情况下分别能得多少分。不要在行末输出多余的空白字符。\n", "hint": "样例说明\n\n1：我们分别称 $4$ 位选手为 $A,B,C,D$ 。则可能出现以下 $4$ 种对战方式，最好情况下可得 $2$ 分，最坏情况下得 $0$ 分。\n\n| | 浙江 | ？？？ | 结果 | 浙江 | ？？？ | 结果 |  浙江 | ？？？ | 结果 | 浙江 | ？？？ | 结果 |\n| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |\n| 一号 | A | C | 负 | A | D | 负 | B | C | 胜 | B | D | 负 |\n| 二号 | B | D | 负 | B | C | 胜 | A | D | 负 | A | C | 负 |\n| 得分 |  |  | 0 |  |  | 2 |  |  | 2 |  |  | 0 |\n\n\n2：对手都是认真学习的好孩子，不会打游戏。无论如何排列出场顺序都无法改变被蹂躏的结果。浙江队总能取得全胜的结果。\n\n$20\\%$ 的数据中，$1\\leq n\\leq 10$；\n\n$40\\%$ 的数据中，$1\\leq n\\leq 100$；\n\n$60\\%$ 的数据中，$1\\leq n\\leq 1000$；\n\n$100\\%$ 的数据中，$1\\leq n\\leq 100000$，且所有选手的实力值在 $0$ 到 $10000000$ 之间。\n", "locale": "zh-CN"}}}
{"pid": "P2588", "type": "P", "difficulty": 6, "samples": [["4 12\r\n3 2\r\n11 8\r\n12 17\r\n1 19\r\n0 0 10 0\r\n10 0 20 0\r\n20 0 20 10\r\n20 10 20 20\r\n20 20 10 20\r\n10 20 0 20\r\n0 20 0 10\r\n0 10 0 0\r\n10 0 10 10\r\n0 10 10 10\r\n20 10 10 10\r\n10 20 10 10\r\n", "2 2 4\r\n2 1 3\r\n2 2 4\r\n2 1 3\r\n"], ["4 16\r\n170 13\r\n24 88\r\n152 49\r\n110 130\r\n60 60 140 60\r\n140 60 140 140\r\n140 140 60 140\r\n60 140 60 60\r\n0 0 200 0\r\n200 0 200 200\r\n200 200 0 200\r\n0 200 0 0\r\n40 40 160 40\r\n160 40 160 160\r\n160 160 40 160\r\n40 160 40 40\r\n20 20 180 20\r\n180 20 180 180\r\n180 180 20 180\r\n20 180 20 20\r\n", "1 2\r\n2 1 3\r\n2 2 4\r\n1 3\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "计算几何", "2008", "各省省选", "浙江"], "title": "[ZJOI2008] Risk", "background": "", "description": "经过连续若干年的推广，Risk这个游戏已经风靡全国，成为大众喜闻乐见的重要娱乐方式。Risk这个游戏可以理解为一种简易的策略游戏，游戏者的目的是占领所有的土地。由于游戏规则的规定，只要两个国家相邻，就认为两个国家有交战的可能性。我们现在希望知道在当前的局面下，哪些国家之间有交战的可能性。注意，我们认为只有当两个国家的国界线有公共边的时候才认为相邻，若两个国家的领土只有公共点，则认为两个国家不相邻。\n\n每一个国家的边界由一系列线段组成，保证这个边界是一个简单多边形，即严格不自交。为了定位每个国家的位置，我们还给出每个国家最庞大的一支军队的位置，保证这个位置一定出现在某一个形内，而不是出现在某条边界上。\n", "inputFormat": "输入文件的第一行中包括两个整数n,m。分别表示地图上的国家数和描述国家的边界的线段的数量。1<=n<=600，1<=m<=4000。接下来n行，每行用一对数描述了某个国家的主力军队的坐标。接下来m行，每行有4个数x1,y1,x2,y2，（x1,y1）-(x2,y2)描述了一条国界线。所有点的坐标都是0-10000之间的整数。\n\n保证输入的所有线段至多只会在线段交点处相交。整张地图上有且仅有一块面积无限的空白区域不属于任何国家。每一条国界线两侧的区域或者隶属于两个不同的国家，或者分隔了一个国家与那块无穷大的空白区域。即保证一条国界线两侧的区域不同时属于同一个国家或是同时都是空白区域。所有封闭区域内部包含且仅包含一支主力军队，表示了该区域的归属。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1707.png) \n\n例如上图中第一行的数据是合法的。而第二行中的数据都是不合法的。左边的那幅图包含线段两侧都是空白区域；中间的图包含线段两侧区域同时属于同一个国家；右边的图中军队被布置在了国界线上，因此非法；此外若最右侧的图中若没有军队也是非法的。保证输入文件提供的数据都是合法的，你的程序不需要进行数据合法性的判定。\n", "outputFormat": "输出文件包括n行，每行第一个数字x表示有x个国家可能与这个国家交战，接着在同一行中升序输出x个整数，表示可能与这个国家交战的国家的编号。国家按输入中给出的顺序从1到n编号。注意数字间严格以一个空格隔开，并且不要在行末输出多余的空白字符。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2008] Risk", "background": "", "description": "After several consecutive years of promotion, the game Risk has become popular nationwide and is now a widely enjoyed form of entertainment. Risk can be understood as a simple strategy game in which the player’s goal is to occupy all territories. According to the rules, any two countries that are adjacent are considered to have a possibility of engaging in war. We now want to determine, under the current situation, which pairs of countries may go to war. Note that we consider two countries adjacent only when their borders share a common edge; if two countries’ territories touch only at a single point, they are considered non-adjacent.\n\nThe boundary of each country is composed of a sequence of line segments and is guaranteed to be a simple polygon, i.e., strictly non-self-intersecting. To locate each country, we also give the position of its largest army, which is guaranteed to lie strictly inside some region rather than on any boundary.", "inputFormat": "The first line contains two integers $n, m$, representing the number of countries on the map and the number of line segments that describe country borders, respectively. $1 \\le n \\le 600$, $1 \\le m \\le 4000$.\n\nThe next $n$ lines each contain a pair of numbers giving the coordinates of a country’s main army.\n\nThe next $m$ lines each contain four numbers $x_1, y_1, x_2, y_2$; the segment $(x_1, y_1)$–$(x_2, y_2)$ describes a border line. All point coordinates are integers between $0$ and $10000$ inclusive.\n\nIt is guaranteed that the input line segments intersect at most at discrete intersection points. There is exactly one unbounded blank region on the entire map that does not belong to any country. For every border line, the regions on its two sides either belong to two different countries, or separate a country from that unbounded blank region. In other words, no border line has the same country on both sides, and no border line has blank regions on both sides. Every bounded region contains exactly one main army inside it, indicating that region’s owner.\n\n ![](https://cdn.luogu.com.cn/upload/pic/1707.png) \n\nFor example, the first row in the figure above is valid. The data in the second row are all invalid: in the left image, both sides of a line segment are blank regions; in the middle image, both sides belong to the same country; in the right image, the army is placed on the border line, which is illegal; moreover, if the rightmost image had no army, that would also be illegal. The input is guaranteed to be valid; your program does not need to verify validity.", "outputFormat": "Output $n$ lines. In each line, the first number $x$ is the count of countries that may go to war with this country. Then, on the same line, output $x$ integers in ascending order, representing the indices of those countries. Countries are indexed $1$ to $n$ in the order they appear in the input. Separate numbers with exactly one space, and do not print extra spaces at the end of a line.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2008] Risk", "background": "", "description": "经过连续若干年的推广，Risk这个游戏已经风靡全国，成为大众喜闻乐见的重要娱乐方式。Risk这个游戏可以理解为一种简易的策略游戏，游戏者的目的是占领所有的土地。由于游戏规则的规定，只要两个国家相邻，就认为两个国家有交战的可能性。我们现在希望知道在当前的局面下，哪些国家之间有交战的可能性。注意，我们认为只有当两个国家的国界线有公共边的时候才认为相邻，若两个国家的领土只有公共点，则认为两个国家不相邻。\n\n每一个国家的边界由一系列线段组成，保证这个边界是一个简单多边形，即严格不自交。为了定位每个国家的位置，我们还给出每个国家最庞大的一支军队的位置，保证这个位置一定出现在某一个形内，而不是出现在某条边界上。\n", "inputFormat": "输入文件的第一行中包括两个整数n,m。分别表示地图上的国家数和描述国家的边界的线段的数量。1<=n<=600，1<=m<=4000。接下来n行，每行用一对数描述了某个国家的主力军队的坐标。接下来m行，每行有4个数x1,y1,x2,y2，（x1,y1）-(x2,y2)描述了一条国界线。所有点的坐标都是0-10000之间的整数。\n\n保证输入的所有线段至多只会在线段交点处相交。整张地图上有且仅有一块面积无限的空白区域不属于任何国家。每一条国界线两侧的区域或者隶属于两个不同的国家，或者分隔了一个国家与那块无穷大的空白区域。即保证一条国界线两侧的区域不同时属于同一个国家或是同时都是空白区域。所有封闭区域内部包含且仅包含一支主力军队，表示了该区域的归属。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1707.png) \n\n例如上图中第一行的数据是合法的。而第二行中的数据都是不合法的。左边的那幅图包含线段两侧都是空白区域；中间的图包含线段两侧区域同时属于同一个国家；右边的图中军队被布置在了国界线上，因此非法；此外若最右侧的图中若没有军队也是非法的。保证输入文件提供的数据都是合法的，你的程序不需要进行数据合法性的判定。\n", "outputFormat": "输出文件包括n行，每行第一个数字x表示有x个国家可能与这个国家交战，接着在同一行中升序输出x个整数，表示可能与这个国家交战的国家的编号。国家按输入中给出的顺序从1到n编号。注意数字间严格以一个空格隔开，并且不要在行末输出多余的空白字符。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2589", "type": "P", "difficulty": 5, "samples": [["3\r\n50 30 80\r\n35 25 70\r\n40 10 90", "55"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2006", "各省省选", "浙江", "枚举", "平面几何"], "title": "[ZJOI2006] 碗的叠放", "background": "", "description": "小H有n个碗需要放进橱柜，她希望将他们叠起来放置。你知道每个碗都是规则的圆柱体，并且都是上宽下窄，你已经测量出了每个碗的两个半径及高，请你帮小H找出一种叠放顺序，使得叠放出来的碗堆的高度尽量小，比如：\n\n![](https://cdn.luogu.com.cn/upload/pic/1706.png)\n", "inputFormat": "第一行一个整数n，表示碗的数目。以下n行，每行三个整数h，r1，r2。分别表示碗高及两个半径。其中r1<r2。\n", "outputFormat": "仅一个数，表示最小的高度。答案四舍五入取整。\n", "hint": "数据范围：100%数据满足n<=9。所有输入的数绝对值不超过1000。\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2006] Stacking Bowls", "background": "", "description": "Xiao H has $n$ bowls to put into a cupboard. She wants to stack them. Each bowl is a right circular frustum (wider at the top and narrower at the bottom). You have measured each bowl’s two radii and height. Please help Xiao H find a stacking order that minimizes the total height of the stack. For example:\n\n![](https://cdn.luogu.com.cn/upload/pic/1706.png)", "inputFormat": "The first line contains an integer $n$, the number of bowls. Each of the next $n$ lines contains three integers $h$, $r_1$, $r_2$, denoting the bowl’s height and its two radii, where $r_1 < r_2$.", "outputFormat": "Output a single number, the minimal height, rounded to the nearest integer.", "hint": "Constraints: 100% of the testdata satisfies $n \\le 9$. The absolute value of every input number does not exceed 1000.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2006] 碗的叠放", "background": "", "description": "小H有n个碗需要放进橱柜，她希望将他们叠起来放置。你知道每个碗都是规则的圆柱体，并且都是上宽下窄，你已经测量出了每个碗的两个半径及高，请你帮小H找出一种叠放顺序，使得叠放出来的碗堆的高度尽量小，比如：\n\n![](https://cdn.luogu.com.cn/upload/pic/1706.png)\n", "inputFormat": "第一行一个整数n，表示碗的数目。以下n行，每行三个整数h，r1，r2。分别表示碗高及两个半径。其中r1<r2。\n", "outputFormat": "仅一个数，表示最小的高度。答案四舍五入取整。\n", "hint": "数据范围：100%数据满足n<=9。所有输入的数绝对值不超过1000。\n", "locale": "zh-CN"}}}
{"pid": "P2590", "type": "P", "difficulty": 5, "samples": [["4\n1 2\n2 3\n4 1\n4 2 1 3\n12\nQMAX 3 4\nQMAX 3 3\nQMAX 3 2\nQMAX 2 3\nQSUM 3 4\nQSUM 2 1\nCHANGE 1 5\nQMAX 3 4\nCHANGE 3 6\nQMAX 3 4\nQMAX 2 4\nQSUM 3 4\n", "4\n1\n2\n2\n10\n6\n5\n6\n5\n16\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "线段树", "各省省选", "浙江", "树链剖分"], "title": "[ZJOI2008] 树的统计", "background": "", "description": "一棵树上有 $n$ 个节点，编号分别为 $1$ 到 $n$，每个节点都有一个权值 $w$。\n\n我们将以下面的形式来要求你对这棵树完成一些操作：\n\nI. `CHANGE u t` : 把结点 $u$ 的权值改为 $t$。\n\nII. `QMAX u v`: 询问从点 $u$ 到点 $v$ 的路径上的节点的最大权值。\n\nIII. `QSUM u v`: 询问从点 $u$ 到点 $v$ 的路径上的节点的权值和。\n\n注意：从点 $u$ 到点 $v$ 的路径上的节点包括 $u$ 和 $v$ 本身。", "inputFormat": "输入文件的第一行为一个整数 $n$，表示节点的个数。\n\n接下来 $n-1$ 行，每行 $2$ 个整数 $a$ 和 $b$，表示节点 $a$ 和节点 $b$ 之间有一条边相连。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数 $w_i$ 表示节点 $i$ 的权值。\n\n接下来 $1$ 行，为一个整数 $q$，表示操作的总数。\n\n接下来 $q$ 行，每行一个操作，以 `CHANGE u t` 或者 `QMAX u v` 或者 `QSUM u v` 的形式给出。\n", "outputFormat": "对于每个 `QMAX` 或者 `QSUM` 的操作，每行输出一个整数表示要求输出的结果。", "hint": "对于 $100 \\%$ 的数据，保证 $1\\le n \\le 3\\times 10^4$，$0\\le q\\le 2\\times 10^5$。\n\n中途操作中保证每个节点的权值 $w$ 在 $-3\\times 10^4$ 到 $3\\times 10^4$ 之间。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2008] Statistics on a Tree", "background": "", "description": "There is a tree with $n$ nodes, numbered from $1$ to $n$, and each node has a weight $w$.\n\nYou are asked to perform the following operations on the tree:\n\nI. `CHANGE u t`: Set the weight of node $u$ to $t$.\n\nII. `QMAX u v`: Query the maximum weight among the nodes on the path from $u$ to $v$.\n\nIII. `QSUM u v`: Query the sum of the weights of the nodes on the path from $u$ to $v$.\n\nNote: The nodes on the path from $u$ to $v$ include $u$ and $v$ themselves.", "inputFormat": "The first line contains an integer $n$, the number of nodes.\n\nThe next $n-1$ lines each contain two integers $a$ and $b$, indicating that there is an edge between node $a$ and node $b$.\n\nThe next line contains $n$ integers, where the $i$-th integer $w_i$ is the weight of node $i$.\n\nThe next line contains an integer $q$, the total number of operations.\n\nThe next $q$ lines each contain one operation, given as `CHANGE u t`, `QMAX u v`, or `QSUM u v`.", "outputFormat": "For each `QMAX` or `QSUM` operation, output one integer on its own line representing the result.", "hint": "Constraints:\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\le n \\le 3\\times 10^4$ and $0 \\le q \\le 2\\times 10^5$.\n\nThroughout the operations, each node’s weight $w$ is guaranteed to be between $-3\\times 10^4$ and $3\\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2008] 树的统计", "background": "", "description": "一棵树上有 $n$ 个节点，编号分别为 $1$ 到 $n$，每个节点都有一个权值 $w$。\n\n我们将以下面的形式来要求你对这棵树完成一些操作：\n\nI. `CHANGE u t` : 把结点 $u$ 的权值改为 $t$。\n\nII. `QMAX u v`: 询问从点 $u$ 到点 $v$ 的路径上的节点的最大权值。\n\nIII. `QSUM u v`: 询问从点 $u$ 到点 $v$ 的路径上的节点的权值和。\n\n注意：从点 $u$ 到点 $v$ 的路径上的节点包括 $u$ 和 $v$ 本身。", "inputFormat": "输入文件的第一行为一个整数 $n$，表示节点的个数。\n\n接下来 $n-1$ 行，每行 $2$ 个整数 $a$ 和 $b$，表示节点 $a$ 和节点 $b$ 之间有一条边相连。\n\n接下来一行 $n$ 个整数，第 $i$ 个整数 $w_i$ 表示节点 $i$ 的权值。\n\n接下来 $1$ 行，为一个整数 $q$，表示操作的总数。\n\n接下来 $q$ 行，每行一个操作，以 `CHANGE u t` 或者 `QMAX u v` 或者 `QSUM u v` 的形式给出。\n", "outputFormat": "对于每个 `QMAX` 或者 `QSUM` 的操作，每行输出一个整数表示要求输出的结果。", "hint": "对于 $100 \\%$ 的数据，保证 $1\\le n \\le 3\\times 10^4$，$0\\le q\\le 2\\times 10^5$。\n\n中途操作中保证每个节点的权值 $w$ 在 $-3\\times 10^4$ 到 $3\\times 10^4$ 之间。", "locale": "zh-CN"}}}
{"pid": "P2591", "type": "P", "difficulty": 5, "samples": [["1 1\r\n", "1\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2009", "各省省选", "浙江"], "title": "[ZJOI2009] 函数", "background": "", "description": "有 $N$ 个连续函数 $f_i(x)$，其中 $1\\le i\\le N$。如果对于任意不相等的 $i,j$ 满足 $1\\le i,j\\le N$，恰好存在一个 $x$ 使得 $f_i(x)=f_j(x)$，并且存在无穷多的 $x$ 使得 $f_i(x)<f_j(x)$，对于任意 $i,j,k$ 满足 $1\\le i < j < k\\le N$，不存在 $x$ 使得 $f_i(x)=f_j(x)=f_k(x)$，则称这 $N$ 个连续函数满足条件。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1708.png) \n\n如上左图就是 $3$ 个满足条件的函数，最左边从下往上依次为 $f_1,f_2,f_3$。右图中红色部分是这整个函数图像的最低层，我们称它为第一层。同理绿色部分称为第二层，蓝色部分称为第三层。注意到，右图中第一层左边一段属于 $f_1$，中间属于 $f_2$，最后属于 $f_3$。而第二层左边属于 $f_2$，接下来一段属于 $f_1$，再接下来一段属于 $f_3$，最后属于 $f_2$。因此，我们称第一层分为了三段，第二层分为了四段。同理第三层只分为了两段。求满足前面条件的 $N$ 个函数，第 $K$ 层最少能由多少段组成。", "inputFormat": "一行两个整数 $N,K$。", "outputFormat": "一行一个整数，表示 $N$ 个函数第 $K$ 层最少能由多少段组成。", "hint": "对于 $100\\%$ 的数据满足 $1\\le K\\le N\\le 100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2009] Functions", "background": "", "description": "There are $N$ continuous functions $f_i(x)$, where $1 \\le i \\le N$. If for any unequal $i, j$ with $1 \\le i, j \\le N$, there exists exactly one $x$ such that $f_i(x) = f_j(x)$, and there exist infinitely many $x$ such that $f_i(x) < f_j(x)$, and for any $i, j, k$ with $1 \\le i < j < k \\le N$, there does not exist $x$ such that $f_i(x) = f_j(x) = f_k(x)$, then these $N$ continuous functions are said to satisfy the condition.\n\n![](https://cdn.luogu.com.cn/upload/pic/1708.png)\n\nAs shown in the left figure, there are $3$ functions that satisfy the condition; on the far left, from bottom to top, they are $f_1, f_2, f_3$. In the right figure, the red part is the lowest layer of the entire graph, which we call the first layer. Similarly, the green part is the second layer, and the blue part is the third layer. Note that, in the right figure, the left segment of the first layer belongs to $f_1$, the middle segment belongs to $f_2$, and the last segment belongs to $f_3$. For the second layer, the left segment belongs to $f_2$, the next segment belongs to $f_1$, the next segment belongs to $f_3$, and the last segment belongs to $f_2$. Therefore, we say the first layer is divided into three segments, and the second layer is divided into four segments. Similarly, the third layer is divided into only two segments. Given $N$ functions that satisfy the conditions above, find the minimum possible number of segments that the $K$-th layer can consist of.", "inputFormat": "One line containing two integers $N$, $K$.", "outputFormat": "One line containing a single integer: the minimum number of segments of the $K$-th layer among the $N$ functions.", "hint": "For $100\\%$ of the testdata, $1 \\le K \\le N \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2009] 函数", "background": "", "description": "有 $N$ 个连续函数 $f_i(x)$，其中 $1\\le i\\le N$。如果对于任意不相等的 $i,j$ 满足 $1\\le i,j\\le N$，恰好存在一个 $x$ 使得 $f_i(x)=f_j(x)$，并且存在无穷多的 $x$ 使得 $f_i(x)<f_j(x)$，对于任意 $i,j,k$ 满足 $1\\le i < j < k\\le N$，不存在 $x$ 使得 $f_i(x)=f_j(x)=f_k(x)$，则称这 $N$ 个连续函数满足条件。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1708.png) \n\n如上左图就是 $3$ 个满足条件的函数，最左边从下往上依次为 $f_1,f_2,f_3$。右图中红色部分是这整个函数图像的最低层，我们称它为第一层。同理绿色部分称为第二层，蓝色部分称为第三层。注意到，右图中第一层左边一段属于 $f_1$，中间属于 $f_2$，最后属于 $f_3$。而第二层左边属于 $f_2$，接下来一段属于 $f_1$，再接下来一段属于 $f_3$，最后属于 $f_2$。因此，我们称第一层分为了三段，第二层分为了四段。同理第三层只分为了两段。求满足前面条件的 $N$ 个函数，第 $K$ 层最少能由多少段组成。", "inputFormat": "一行两个整数 $N,K$。", "outputFormat": "一行一个整数，表示 $N$ 个函数第 $K$ 层最少能由多少段组成。", "hint": "对于 $100\\%$ 的数据满足 $1\\le K\\le N\\le 100$。\n", "locale": "zh-CN"}}}
{"pid": "P2592", "type": "P", "difficulty": 4, "samples": [["1 2 1", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2008", "各省省选", "浙江", "前缀和"], "title": "[ZJOI2008] 生日聚会", "background": null, "description": "今天是 hidadz 小朋友的生日，她邀请了许多朋友来参加她的生日 party。hidadz 带着朋友们来到花园中，打算坐成一排玩游戏。为了游戏不至于无聊，就座的方案应满足如下条件：\n\n对于任意连续的一段，男孩与女孩的数目之差不超过 $k$。\n\n很快，小朋友便找到了一种方案坐了下来开始游戏。hidadz 的好朋友 Susie 发现，这样的就座方案其实是很多的，所以大家很快就找到了一种，那么到底有多少种呢？热爱数学的 hidadz 和她的朋友们开始思考这个问题……\n\n假设参加 party 的人中共有 $n$ 个男孩与 $m$ 个女孩，你是否能解答 Susie 和 hidadz 的疑问呢？由于这个数目可能很多，他们只想知道这个数目除以 $12345678$ 的余数。", "inputFormat": "输入仅包含一行共 $3$ 个整数，分别为男孩数目 $n$，女孩数目$m$，常数 $k$。", "outputFormat": "输出应包含一行，为题中要求的答案。", "hint": "对于 $30\\%$ 的数据，$n,m\\le 20$；\n\n对于 $100\\%$ 的数据，$n,m\\le 150，k \\le 20$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2008] Birthday Party", "background": "", "description": "Today is hidadz’s birthday, and she has invited many friends to her birthday party. hidadz takes her friends to the garden, planning to sit in a row to play a game. To keep the game from being boring, the seating arrangement must satisfy the following condition:\n\nFor any consecutive segment, the absolute difference between the number of boys and the number of girls does not exceed $k$.\n\nSoon, the kids find one such arrangement and start the game. hidadz’s good friend Susie notices that there are actually many such seating arrangements, so since everyone can quickly find one, how many are there in total? The math-loving hidadz and her friends begin to think about this question.\n\nAssume there are $n$ boys and $m$ girls at the party. Can you answer Susie and hidadz’s question? Since this number can be large, they only want the remainder when it is divided by $12345678$.", "inputFormat": "The input contains a single line with $3$ integers: the number of boys $n$, the number of girls $m$, and the constant $k$.", "outputFormat": "Output a single line containing the required answer.", "hint": "For $30\\%$ of the testdata, $n, m \\le 20$.\n\nFor $100\\%$ of the testdata, $n, m \\le 150$, $k \\le 20$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2008] 生日聚会", "background": null, "description": "今天是 hidadz 小朋友的生日，她邀请了许多朋友来参加她的生日 party。hidadz 带着朋友们来到花园中，打算坐成一排玩游戏。为了游戏不至于无聊，就座的方案应满足如下条件：\n\n对于任意连续的一段，男孩与女孩的数目之差不超过 $k$。\n\n很快，小朋友便找到了一种方案坐了下来开始游戏。hidadz 的好朋友 Susie 发现，这样的就座方案其实是很多的，所以大家很快就找到了一种，那么到底有多少种呢？热爱数学的 hidadz 和她的朋友们开始思考这个问题……\n\n假设参加 party 的人中共有 $n$ 个男孩与 $m$ 个女孩，你是否能解答 Susie 和 hidadz 的疑问呢？由于这个数目可能很多，他们只想知道这个数目除以 $12345678$ 的余数。", "inputFormat": "输入仅包含一行共 $3$ 个整数，分别为男孩数目 $n$，女孩数目$m$，常数 $k$。", "outputFormat": "输出应包含一行，为题中要求的答案。", "hint": "对于 $30\\%$ 的数据，$n,m\\le 20$；\n\n对于 $100\\%$ 的数据，$n,m\\le 150，k \\le 20$。", "locale": "zh-CN"}}}
{"pid": "P2593", "type": "P", "difficulty": 5, "samples": [["3\r\n2 4 0 0 0 0 0 …… 0（一共98个0）\r\n2 4 2 0 0 0 0 …… 0（一共97个0）\r\n2 3 2 0 0 0 0 …… 0（一共97个0）", "Yes\r\nYes\r\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2006", "各省省选", "浙江", "哈希 hashing"], "title": "[ZJOI2006] 超级麻将", "background": null, "description": "很多人都知道玩麻将，当然也有人不知道，呵呵，不要紧，我在这里简要地介绍一下麻将规则：\n\n普通麻将有砣、索、万三种类型的牌，每种牌有 $1\\sim9$ 个数字，其中相同的牌每个有四张，例如 `1砣`\\~`9砣`，`1索`\\~`9索`，`1万`\\~`9万` 各有 $4$ 张，所以共 $36\\times 3=108$ 张牌。胡牌时每人有 $14$ 张牌，其中只要某人手里有若干句话（就是同种类型的牌连续三张或同种牌三张），另外再加上一对，即可胡牌。当然如果全是对，叫七小对，也可以胡牌。下图是连三张示例。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1709.png) \n\n要判断某人是否胡牌，显然一个弱智的算法就行了，某中学信息学小组超级麻将迷想了想，决定将普通麻将改造成超级麻将。\n\n所谓超级麻将没有了砣、索、万的区分，每种牌上的数字可以是 $1\\sim100$，而每种数字的牌各有 $100$ 张。另外特别自由的是，玩牌的人手里想拿多少张牌都可以，好刺激哦！\n\n刺激归刺激，但是拿多了怎么胡牌呢？\n\n超级麻将规定只要一个人手里拿的牌是若干句话（三个连续数字的牌各一张组成一句话，三张或者四张同样数字的牌也算一句话），再加上一对相同的牌，就算胡了。\n\n作为信息学竞赛选手的你，麻烦你给这位超级麻将迷编个程序，判断能否胡牌。", "inputFormat": "输入文件第一行一个整数 $N(N\\le 100)$，表示玩了N次超级麻将。\n\n接下来 $N$ 行，每行 $100$ 个数 $a_1 \\dots a_{100}$，描述每次玩牌手中各种牌的数量。$a_i$ 表示数字为i的牌有 $a_i$ 张。$(0\\le a_i\\le 100)$", "outputFormat": "输出 $N$ 行，若胡了则输出 `Yes`，否则输出 `No`，注意区分 `Yes`，`No` 的大小写！", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2006] Super Mahjong", "background": "", "description": "Many people know how to play Mahjong; of course, some do not. Don’t worry, here is a brief introduction to the rules.\n\nIn standard Mahjong, there are three suits: \"Tong\", \"Suo\", and \"Wan\". Each suit has numbers $1\\sim9$, and there are four copies of each identical tile. For example, `1Tong`\\~`9Tong`, `1Suo`\\~`9Suo`, and `1Wan`\\~`9Wan` each have $4$ copies, so there are $36\\times 3=108$ tiles in total. When someone wins, each player has $14$ tiles. A winning hand consists of several melds (either three consecutive tiles of the same suit, or three identical tiles), plus one pair. Of course, if the hand consists entirely of pairs, called “Seven Pairs”, it is also a winning hand. The figure below shows an example of three in sequence.\n\n ![](https://cdn.luogu.com.cn/upload/pic/1709.png) \n\nTo judge whether someone can win, an obviously naive algorithm would do. A Mahjong fanatic from a middle school informatics club thought about it and decided to modify standard Mahjong into Super Mahjong.\n\nIn Super Mahjong, there is no distinction between suits. The number on each tile can be $1\\sim100$, and there are $100$ copies of each number. What’s more, players are free to hold as many tiles as they like. Exciting!\n\nExciting as it is, how do you form a winning hand with many tiles?\n\nSuper Mahjong defines that a hand is winning if the tiles can be partitioned into several melds (one meld can be three consecutive numbers, one tile each; or three or four identical numbers also count as one meld), plus one pair of identical tiles.\n\nAs an informatics contestant, please write a program to determine whether the player can win.", "inputFormat": "The first line contains an integer $N(N\\le 100)$, indicating that Super Mahjong was played $N$ times.\n\nThe next $N$ lines each contain $100$ numbers $a_1 \\dots a_{100}$, describing the counts of each tile number in that round. $a_i$ means there are $a_i$ tiles with number $i$. $(0\\le a_i\\le 100)$", "outputFormat": "Output $N$ lines. Print `Yes` if it is a winning hand; otherwise print `No`. Note the case of `Yes` and `No`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2006] 超级麻将", "background": null, "description": "很多人都知道玩麻将，当然也有人不知道，呵呵，不要紧，我在这里简要地介绍一下麻将规则：\n\n普通麻将有砣、索、万三种类型的牌，每种牌有 $1\\sim9$ 个数字，其中相同的牌每个有四张，例如 `1砣`\\~`9砣`，`1索`\\~`9索`，`1万`\\~`9万` 各有 $4$ 张，所以共 $36\\times 3=108$ 张牌。胡牌时每人有 $14$ 张牌，其中只要某人手里有若干句话（就是同种类型的牌连续三张或同种牌三张），另外再加上一对，即可胡牌。当然如果全是对，叫七小对，也可以胡牌。下图是连三张示例。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1709.png) \n\n要判断某人是否胡牌，显然一个弱智的算法就行了，某中学信息学小组超级麻将迷想了想，决定将普通麻将改造成超级麻将。\n\n所谓超级麻将没有了砣、索、万的区分，每种牌上的数字可以是 $1\\sim100$，而每种数字的牌各有 $100$ 张。另外特别自由的是，玩牌的人手里想拿多少张牌都可以，好刺激哦！\n\n刺激归刺激，但是拿多了怎么胡牌呢？\n\n超级麻将规定只要一个人手里拿的牌是若干句话（三个连续数字的牌各一张组成一句话，三张或者四张同样数字的牌也算一句话），再加上一对相同的牌，就算胡了。\n\n作为信息学竞赛选手的你，麻烦你给这位超级麻将迷编个程序，判断能否胡牌。", "inputFormat": "输入文件第一行一个整数 $N(N\\le 100)$，表示玩了N次超级麻将。\n\n接下来 $N$ 行，每行 $100$ 个数 $a_1 \\dots a_{100}$，描述每次玩牌手中各种牌的数量。$a_i$ 表示数字为i的牌有 $a_i$ 张。$(0\\le a_i\\le 100)$", "outputFormat": "输出 $N$ 行，若胡了则输出 `Yes`，否则输出 `No`，注意区分 `Yes`，`No` 的大小写！", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2594", "type": "P", "difficulty": 6, "samples": [["3\n2 3\nHHH\nHHH\n2 3\nHHH\nTTH\n2 1\nT\nH", "=_=\n-_-\n-_-"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "博弈论", "2009", "各省省选", "浙江", "SG 函数"], "title": "[ZJOI2009] 染色游戏", "background": null, "description": "一共 $n \\times m$ 个硬币，摆成 $n \\times m$ 的长方形。dongdong 和 xixi 玩一个游戏，每次可以选择一个连通块，并把其中的硬币全部翻转，但是需要满足存在一个硬币属于这个连通块并且所有其他硬币都在它的左上方(可以正左方也可以正上方)，并且这个硬币是从反面向上翻成正面向上。dongdong 和 xixi 轮流操作。如果某一方无法操作，那么他(她)就输了。dongdong 先进行第一步操作，假设双方都采用最优策略。问 dongdong 是否有必胜策略。", "inputFormat": "第一行一个数 $T$，表示他们一共玩 $T$ 局游戏。\n\n接下来是 $T$ 组游戏描述。每组游戏第一行两个数 $n,m$。\n\n接下来 $n$ 行每行 $m$ 个字符，第 $i$ 行第 $j$ 个字符如果是 `H` 表示第 $i$ 行第 $j$ 列的硬币是正面向上，否则是反面向上。第 $i$ 行 $j$ 列的左上方是指行不超过 $i$ 并且列不超过 $j$ 的区域。", "outputFormat": "对于每局游戏，输出一行。如果 dongdong 存在必胜策略则输出 `-_-` 否则输出 `=_=`（注意输出的都是半角符号，即三个符号 ASCII 码分别为 45,61,95)。", "hint": "对于 $40\\%$ 的数据，满足 $1 \\le n,m \\le 5$。\n\n对于 $100\\%$ 的数据，满足 $1 \\le n,m \\le 100，1 \\le T \\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2009] Coloring Game", "background": "", "description": "There are $n \\times m$ coins arranged in an $n \\times m$ rectangle. Dongdong and Xixi play a game. In each move, a player may choose a connected component and flip all coins in it, but the move must satisfy: there exists a coin in this component such that all other coins in the component are in its upper-left (including directly to its left or directly above), and this coin is flipped from tails-up to heads-up. Dongdong and Xixi take turns. If a player cannot move, he or she loses. Dongdong moves first. Assuming both play optimally, determine whether Dongdong has a winning strategy.", "inputFormat": "The first line contains a number $T$, the number of games they play.\n\nThen follow $T$ game descriptions. For each game, the first line contains two numbers $n, m$.\n\nThen there are $n$ lines, each with $m$ characters. In the $i$-th line, the $j$-th character is `H` if the coin at row $i$, column $j$ is heads-up; otherwise it is tails-up. The upper-left of cell $(i, j)$ refers to the region with row index not exceeding $i$ and column index not exceeding $j$.", "outputFormat": "For each game, output one line. If Dongdong has a winning strategy, output `-_-`; otherwise, output `=_=`. Note that these are half-width characters, i.e., the three characters have ASCII codes 45, 61, and 95.", "hint": "For $40\\%$ of the testdata, $1 \\le n,m \\le 5$.\n\nFor $100\\%$ of the testdata, $1 \\le n,m \\le 100, 1 \\le T \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2009] 染色游戏", "background": null, "description": "一共 $n \\times m$ 个硬币，摆成 $n \\times m$ 的长方形。dongdong 和 xixi 玩一个游戏，每次可以选择一个连通块，并把其中的硬币全部翻转，但是需要满足存在一个硬币属于这个连通块并且所有其他硬币都在它的左上方(可以正左方也可以正上方)，并且这个硬币是从反面向上翻成正面向上。dongdong 和 xixi 轮流操作。如果某一方无法操作，那么他(她)就输了。dongdong 先进行第一步操作，假设双方都采用最优策略。问 dongdong 是否有必胜策略。", "inputFormat": "第一行一个数 $T$，表示他们一共玩 $T$ 局游戏。\n\n接下来是 $T$ 组游戏描述。每组游戏第一行两个数 $n,m$。\n\n接下来 $n$ 行每行 $m$ 个字符，第 $i$ 行第 $j$ 个字符如果是 `H` 表示第 $i$ 行第 $j$ 列的硬币是正面向上，否则是反面向上。第 $i$ 行 $j$ 列的左上方是指行不超过 $i$ 并且列不超过 $j$ 的区域。", "outputFormat": "对于每局游戏，输出一行。如果 dongdong 存在必胜策略则输出 `-_-` 否则输出 `=_=`（注意输出的都是半角符号，即三个符号 ASCII 码分别为 45,61,95)。", "hint": "对于 $40\\%$ 的数据，满足 $1 \\le n,m \\le 5$。\n\n对于 $100\\%$ 的数据，满足 $1 \\le n,m \\le 100，1 \\le T \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P2595", "type": "P", "difficulty": 7, "samples": [["3 3\n...\n...\n...", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "浙江", "容斥原理", "状压 DP"], "title": "[ZJOI2009] 多米诺骨牌", "background": "", "description": "有一个 $n \\times m$ 的矩形表格，其中有一些位置有障碍。现在要在这个表格内放一些 $1 \\times 2$ 或者 $2 \\times 1$ 的多米诺骨牌，使得任何两个多米诺骨牌没有重叠部分，任何一个骨牌不能放到障碍上。并且满足任何相邻两行之间都有至少一个骨牌横跨，任何相邻两列之间也都至少有一个骨牌横跨。求有多少种不同的放置方法，注意你并不需要放满所有没有障碍的格子。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $n$ 行，每行 $m$ 个字符，表示这个矩形表格。其中字符 `x` 表示这个位置有障碍，字符 `.` 表示没有障碍。", "outputFormat": "一行一个整数，表示不同的放置方法数对 $19\\,901\\,013$ 取模的值。", "hint": "### 样例解释\n\n两种放置方法分别为：\n\n```plain\n112 411\n4.2 4.2\n433 332\n```\n\n注意这里的数字只用于区分骨牌，不同的排列并不代表不同的方案。\n\n### 数据范围\n\n- 对于 $40\\%$ 的数据，满足 $n,m \\leq 8$；\n- 对于 $90\\%$ 的数据，满足 $n,m \\leq 14$。\n- 对于 $100\\%$ 的数据，满足 $1 \\leq n,m \\leq 15$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2009] Dominoes", "background": "", "description": "There is an $n \\times m$ rectangular grid with some cells blocked by obstacles. You need to place some $1 \\times 2$ or $2 \\times 1$ dominoes on this grid so that any two dominoes do not overlap, and no domino covers an obstacle. Moreover, for every pair of adjacent rows, there must be at least one domino crossing them; similarly, for every pair of adjacent columns, there must be at least one domino crossing them. Find the number of different placement methods. Note that you do not need to cover all unobstructed cells.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe next $n$ lines each contain $m$ characters describing the grid. Character `x` means the cell has an obstacle, and character `.` means the cell is empty.", "outputFormat": "Output a single integer: the number of different placements modulo $19\\,901\\,013$.", "hint": "Sample explanation:\n\nTwo valid placements are:\n\n```plain\n112 411\n4.2 4.2\n433 332\n```\n\nNote that the digits are only used to distinguish dominoes; different labelings do not represent different solutions.\n\nConstraints:\n- For $40\\%$ of the testdata, $n, m \\leq 8$.\n- For $90\\%$ of the testdata, $n, m \\leq 14$.\n- For $100\\%$ of the testdata, $1 \\leq n, m \\leq 15$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2009] 多米诺骨牌", "background": "", "description": "有一个 $n \\times m$ 的矩形表格，其中有一些位置有障碍。现在要在这个表格内放一些 $1 \\times 2$ 或者 $2 \\times 1$ 的多米诺骨牌，使得任何两个多米诺骨牌没有重叠部分，任何一个骨牌不能放到障碍上。并且满足任何相邻两行之间都有至少一个骨牌横跨，任何相邻两列之间也都至少有一个骨牌横跨。求有多少种不同的放置方法，注意你并不需要放满所有没有障碍的格子。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $n$ 行，每行 $m$ 个字符，表示这个矩形表格。其中字符 `x` 表示这个位置有障碍，字符 `.` 表示没有障碍。", "outputFormat": "一行一个整数，表示不同的放置方法数对 $19\\,901\\,013$ 取模的值。", "hint": "### 样例解释\n\n两种放置方法分别为：\n\n```plain\n112 411\n4.2 4.2\n433 332\n```\n\n注意这里的数字只用于区分骨牌，不同的排列并不代表不同的方案。\n\n### 数据范围\n\n- 对于 $40\\%$ 的数据，满足 $n,m \\leq 8$；\n- 对于 $90\\%$ 的数据，满足 $n,m \\leq 14$。\n- 对于 $100\\%$ 的数据，满足 $1 \\leq n,m \\leq 15$。", "locale": "zh-CN"}}}
{"pid": "P2596", "type": "P", "difficulty": 6, "samples": [["10 10\n1 3 2 7 5 8 10 4 9 6\nQuery 3\nTop 5\nAsk 6\nBottom 3\nAsk 3\nTop 6\nInsert 4 -1\nQuery 5\nQuery 2\nAsk 2\n", "2\n9\n9\n7\n5\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2006", "各省省选", "平衡树", "浙江"], "title": "[ZJOI2006] 书架", "background": "", "description": "小 T 有一个很大的书柜。这个书柜的构造有些独特，即书柜里的书是从上至下堆放成一列。她用 $1$ 到 $n$ 的正整数给每本书都编了号。\n\n小 T 在看书的时候，每次取出一本书，看完后放回书柜然后再拿下一本。由于这些书太有吸引力了，所以她看完后常常会忘记原来是放在书柜的什么位置。不过小 T 的记忆力是非常好的，所以每次放书的时候至少能够将那本书放在拿出来时的位置附近，比如说她拿的时候这本书上面有 $x$ 本书，那么放回去时这本书上面就只可能有 $x-1$、$x$ 或 $x+1$ 本书。\n\n当然也有特殊情况，比如在看书的时候突然电话响了或者有朋友来访。这时候粗心的小 T 会随手把书放在书柜里所有书的最上面或者最下面，然后转身离开。\n\n久而久之，小 T 的书柜里的书的顺序就会越来越乱，找到特定的编号的书就变得越来越困难。于是她想请你帮她编写一个图书管理程序，处理她看书时的一些操作，以及回答她的两个提问：\n- 编号为 $x$ 的书在书柜的什么位置。\n- 从上到下第 $i$ 本书的编号是多少。\n", "inputFormat": "第一行有两个整数，分别表示书的个数 $n$ 以及命令条数 $m$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示初始时从上向下书第 $i$ 本书的编号 $p_i$。\n\n接下来 $m$ 行，每行表示一个操作。每行初始时有一个字符串  $op$。\n\n- 若 $op$ 为 `Top`，则后有一个整数 $s$，表示把编号为 $s$ 的书放在最上面。\n- 若 $op$ 为 `Bottom`，则后有一个整数 $s$，表示把编号为 $s$ 的书放在最下面。\n- 若 $op$ 为 `Insert`，则后有两个整数 $s, t$，表示若编号为 $s$ 的书上面有 $x$ 本书，则放回这本书时他的上面有 $x + t$ 本书。\n- 若 $op$ 为 `Ask`，则后面有一个整数 $s$，表示询问编号为 $s$ 的书上面有几本书。\n- 若 $op$ 为 `Query`，则后面有一个整数 $s$，询问从上面起第 $s$ 本书的编号。", "outputFormat": "对于每次查询，输出一行一个整数表示答案。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n- $3 \\leq n, m \\leq 8 \\times 10^4$。\n- $p_i$ 是一个 $1 \\sim n$ 的排列。\n- $1 \\leq s \\leq n$，$-1 \\leq t \\leq 1$，$op$ 只可能是输入的五种字符串之一。\n- 当编号为 $s$ 的书上面没有书的时候，不会对它进行 `Insert s -1` 操作。\n- 当编号为 $s$ 的书下面没有书的时候，不会对它进行 `Insert s 1` 操作。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2006] Bookshelf", "background": "", "description": "Xiao T has a very large bookcase. Its structure is a bit special: the books in the bookcase are stacked in a single column from top to bottom. She labels each book with the positive integers from $1$ to $n$.\n\nWhen Xiao T reads, each time she takes out one book, and after finishing it, she puts it back into the bookcase and then takes the next one. Because the books are so attractive, she often forgets the exact position where the book was originally placed. However, Xiao T has a very good memory, so when she puts a book back, she can at least place it near where it was taken from. For example, if when she took the book there were $x$ books above it, then when putting it back, there can only be $x - 1$, $x$, or $x + 1$ books above it.\n\nOf course, there are special cases, such as when the phone rings or a friend visits while she is reading. At these times, the careless Xiao T may casually put the book at the very top or the very bottom of all the books in the bookcase, and then walk away.\n\nOver time, the order of the books in Xiao T’s bookcase becomes more and more chaotic, making it increasingly difficult to find a specific labeled book. So she asks you to write a library management program to process her operations while reading and answer two types of queries:\n- What is the position of the book with ID $x$ in the bookcase.\n- What is the ID of the $i$-th book from top to bottom.", "inputFormat": "The first line contains two integers, representing the number of books $n$ and the number of commands $m$.\n\nThe second line contains $n$ integers. The $i$-th integer $p_i$ is the ID of the $i$-th book from the top at the beginning.\n\nThen there are $m$ lines, each describing an operation. Each line starts with a string $op$.\n\n- If $op$ is `Top`, followed by an integer $s$, move the book with ID $s$ to the very top.\n- If $op$ is `Bottom`, followed by an integer $s$, move the book with ID $s$ to the very bottom.\n- If $op$ is `Insert`, followed by two integers $s, t$, then if there are $x$ books above the book with ID $s$, when putting it back there should be $x + t$ books above it.\n- If $op$ is `Ask`, followed by an integer $s$, ask how many books are above the book with ID $s$.\n- If $op$ is `Query`, followed by an integer $s$, ask for the ID of the $s$-th book from the top.", "outputFormat": "For each query, output a single integer on its own line as the answer.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that:\n- $3 \\leq n, m \\leq 8 \\times 10^4$.\n- $p_i$ is a permutation of $1$ to $n$.\n- $1 \\leq s \\leq n$, $-1 \\leq t \\leq 1$, and $op$ is one of the five strings above.\n- When there is no book above the book with ID $s$, the operation `Insert s -1` will not be performed.\n- When there is no book below the book with ID $s$, the operation `Insert s 1` will not be performed.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2006] 书架", "background": "", "description": "小 T 有一个很大的书柜。这个书柜的构造有些独特，即书柜里的书是从上至下堆放成一列。她用 $1$ 到 $n$ 的正整数给每本书都编了号。\n\n小 T 在看书的时候，每次取出一本书，看完后放回书柜然后再拿下一本。由于这些书太有吸引力了，所以她看完后常常会忘记原来是放在书柜的什么位置。不过小 T 的记忆力是非常好的，所以每次放书的时候至少能够将那本书放在拿出来时的位置附近，比如说她拿的时候这本书上面有 $x$ 本书，那么放回去时这本书上面就只可能有 $x-1$、$x$ 或 $x+1$ 本书。\n\n当然也有特殊情况，比如在看书的时候突然电话响了或者有朋友来访。这时候粗心的小 T 会随手把书放在书柜里所有书的最上面或者最下面，然后转身离开。\n\n久而久之，小 T 的书柜里的书的顺序就会越来越乱，找到特定的编号的书就变得越来越困难。于是她想请你帮她编写一个图书管理程序，处理她看书时的一些操作，以及回答她的两个提问：\n- 编号为 $x$ 的书在书柜的什么位置。\n- 从上到下第 $i$ 本书的编号是多少。\n", "inputFormat": "第一行有两个整数，分别表示书的个数 $n$ 以及命令条数 $m$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示初始时从上向下书第 $i$ 本书的编号 $p_i$。\n\n接下来 $m$ 行，每行表示一个操作。每行初始时有一个字符串  $op$。\n\n- 若 $op$ 为 `Top`，则后有一个整数 $s$，表示把编号为 $s$ 的书放在最上面。\n- 若 $op$ 为 `Bottom`，则后有一个整数 $s$，表示把编号为 $s$ 的书放在最下面。\n- 若 $op$ 为 `Insert`，则后有两个整数 $s, t$，表示若编号为 $s$ 的书上面有 $x$ 本书，则放回这本书时他的上面有 $x + t$ 本书。\n- 若 $op$ 为 `Ask`，则后面有一个整数 $s$，表示询问编号为 $s$ 的书上面有几本书。\n- 若 $op$ 为 `Query`，则后面有一个整数 $s$，询问从上面起第 $s$ 本书的编号。", "outputFormat": "对于每次查询，输出一行一个整数表示答案。", "hint": "### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n- $3 \\leq n, m \\leq 8 \\times 10^4$。\n- $p_i$ 是一个 $1 \\sim n$ 的排列。\n- $1 \\leq s \\leq n$，$-1 \\leq t \\leq 1$，$op$ 只可能是输入的五种字符串之一。\n- 当编号为 $s$ 的书上面没有书的时候，不会对它进行 `Insert s -1` 操作。\n- 当编号为 $s$ 的书下面没有书的时候，不会对它进行 `Insert s 1` 操作。", "locale": "zh-CN"}}}
{"pid": "P2597", "type": "P", "difficulty": 6, "samples": [["5\n0\n1 0\n1 0\n2 3 0\n2 0\n", "4\n1\n0\n0\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "倍增", "各省省选", "浙江", "O2优化", "拓扑排序", "最近公共祖先 LCA"], "title": "[ZJOI2012] 灾难", "background": "阿米巴是小强的好朋友。\n\n阿米巴和小强在草原上捉蚂蚱。小强突然想，如果蚂蚱被他们捉灭绝了，那么吃蚂蚱的小鸟就会饿死，而捕食小鸟的猛禽也会跟着灭绝，从而引发一系列的生态灾难。\n\n学过生物的阿米巴告诉小强，草原是一个极其稳定的生态系统。如果蚂蚱灭绝了，小鸟照样可以吃别的虫子，所以一个物种的灭绝并不一定会引发重大的灾难。", "description": "我们现在从专业一点的角度来看这个问题。我们用一种叫做食物网的有向图来描述生物之间的关系：\n\n- 一个食物网有 $n$ 个点，代表 $n$ 种生物，生物从 $1$ 到 $n$ 编号。\n- 如果生物 $x$ 可以吃生物 $y$，那么从 $y$ 向 $x$ 连一个有向边。\n- 这个图没有环。\n- 图中有一些点没有连出边，这些点代表的生物都是生产者，可以通过光合作用来生存。\n- 而有连出边的点代表的都是消费者，它们必须通过吃其他生物来生存。\n- 如果某个消费者的所有食物都灭绝了，它会跟着灭绝。\n\n我们定义一个生物在食物网中的“灾难值”为，如果它突然灭绝，那么会跟着一起灭绝的生物的种数。\n\n举个例子：在一个草场上，生物之间的关系如下\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oiw4lh97.png)\n\n如果小强和阿米巴把草原上所有的羊都给吓死了，那么狼会因为没有食物而灭绝，而小强和阿米巴可以通过吃牛、牛可以通过吃草来生存下去。所以，羊的灾难值是 $1$。但是，如果草突然灭绝，那么整个草原上的 $5$ 种生物都无法幸免，所以，草的灾难值是 $4$。\n\n给定一个食物网，你要求出每个生物的灾难值。", "inputFormat": "第一行有一个整数，表示食物网的结点个数 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行若干个互不相同的整数，第 $(i + 1)$ 行的整数 $a_{i, j}$ 表示编号为 $i$ 的生物可以吃编号为 $a_{i, j}$ 的生物。每行结尾有一个整数 $0$ 表示本行结束。", "outputFormat": "输出 $n$ 行，每行一个整数，第 $i$ 行输出编号为 $i$ 的生物的灾难值。", "hint": "### 样例 1 解释\n\n样例输入描述了题目描述中举的例子。\n\n### 数据规模与约定\n\n- 对于 $50\\%$ 的数据，保证 $n \\leq 10^4$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 65534$，$1 \\leq a_{i, j} \\leq n$，输入的文件大小不超过 1 MB，且图上不存在环。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2012] Disaster", "background": "Amiba is Xiaoqiang’s good friend.\n\nAmiba and Xiaoqiang are catching grasshoppers on the prairie. Xiaoqiang suddenly thinks that if grasshoppers were caught to extinction, then the birds that eat grasshoppers would starve, and the raptors that prey on those birds would also go extinct, triggering a chain of ecological disasters.\n\nAmiba, who has studied biology, tells Xiaoqiang that the prairie is an extremely stable ecosystem. If grasshoppers go extinct, birds can still eat other insects, so the extinction of one species does not necessarily cause a major disaster.", "description": "Let’s look at this problem from a more professional perspective. We use a directed graph called a food web to describe the relationships between species:\n\n- A food web has $n$ vertices, representing $n$ species, numbered from $1$ to $n$.\n- If species $x$ can eat species $y$, then draw a directed edge from $y$ to $x$.\n- The graph has no cycles.\n- Some vertices have no outgoing edges; these are producers that can survive via photosynthesis.\n- Vertices with outgoing edges are consumers; they must survive by eating other species.\n- If all the foods of a consumer go extinct, it will go extinct as well.\n\nWe define the “disaster value” of a species in the food web as the number of species that would go extinct along with it if it suddenly went extinct.\n\nFor example: on a grassland, the relationships between species are as follows\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oiw4lh97.png)\n\nIf Xiaoqiang and Amiba scare all the sheep to death, then the wolves will go extinct due to lack of food, while Xiaoqiang and Amiba can survive by eating cows, and cows can survive by eating grass. Thus, the disaster value of sheep is $1$. However, if the grass suddenly went extinct, then all $5$ species on the grassland would be affected, so the disaster value of grass is $4$.\n\nGiven a food web, you are required to compute the disaster value for each species.", "inputFormat": "The first line contains an integer representing the number of vertices $n$ in the food web.\n\nFrom the $2$-nd to the $(n + 1)$-st line, each line contains several distinct integers. The $(i + 1)$-st line lists integers $a_{i, j}$ indicating that species $i$ can eat species $a_{i, j}$. Each line ends with an integer $0$ marking the end of that line.", "outputFormat": "Output $n$ lines, one integer per line. On the $i$-th line, output the disaster value of species $i$.", "hint": "### Sample 1 Explanation\n\nThe sample input describes the example in the problem statement.\n\n### Constraints\n\n- For $50\\%$ of the testdata, it is guaranteed that $n \\leq 10^4$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 65534$, $1 \\leq a_{i, j} \\leq n$, the input file size does not exceed $1$ MB, and the graph has no cycles.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2012] 灾难", "background": "阿米巴是小强的好朋友。\n\n阿米巴和小强在草原上捉蚂蚱。小强突然想，如果蚂蚱被他们捉灭绝了，那么吃蚂蚱的小鸟就会饿死，而捕食小鸟的猛禽也会跟着灭绝，从而引发一系列的生态灾难。\n\n学过生物的阿米巴告诉小强，草原是一个极其稳定的生态系统。如果蚂蚱灭绝了，小鸟照样可以吃别的虫子，所以一个物种的灭绝并不一定会引发重大的灾难。", "description": "我们现在从专业一点的角度来看这个问题。我们用一种叫做食物网的有向图来描述生物之间的关系：\n\n- 一个食物网有 $n$ 个点，代表 $n$ 种生物，生物从 $1$ 到 $n$ 编号。\n- 如果生物 $x$ 可以吃生物 $y$，那么从 $y$ 向 $x$ 连一个有向边。\n- 这个图没有环。\n- 图中有一些点没有连出边，这些点代表的生物都是生产者，可以通过光合作用来生存。\n- 而有连出边的点代表的都是消费者，它们必须通过吃其他生物来生存。\n- 如果某个消费者的所有食物都灭绝了，它会跟着灭绝。\n\n我们定义一个生物在食物网中的“灾难值”为，如果它突然灭绝，那么会跟着一起灭绝的生物的种数。\n\n举个例子：在一个草场上，生物之间的关系如下\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/oiw4lh97.png)\n\n如果小强和阿米巴把草原上所有的羊都给吓死了，那么狼会因为没有食物而灭绝，而小强和阿米巴可以通过吃牛、牛可以通过吃草来生存下去。所以，羊的灾难值是 $1$。但是，如果草突然灭绝，那么整个草原上的 $5$ 种生物都无法幸免，所以，草的灾难值是 $4$。\n\n给定一个食物网，你要求出每个生物的灾难值。", "inputFormat": "第一行有一个整数，表示食物网的结点个数 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行若干个互不相同的整数，第 $(i + 1)$ 行的整数 $a_{i, j}$ 表示编号为 $i$ 的生物可以吃编号为 $a_{i, j}$ 的生物。每行结尾有一个整数 $0$ 表示本行结束。", "outputFormat": "输出 $n$ 行，每行一个整数，第 $i$ 行输出编号为 $i$ 的生物的灾难值。", "hint": "### 样例 1 解释\n\n样例输入描述了题目描述中举的例子。\n\n### 数据规模与约定\n\n- 对于 $50\\%$ 的数据，保证 $n \\leq 10^4$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 65534$，$1 \\leq a_{i, j} \\leq n$，输入的文件大小不超过 1 MB，且图上不存在环。", "locale": "zh-CN"}}}
{"pid": "P2598", "type": "P", "difficulty": 5, "samples": [["2 2\r\n2 2 \r\n1 1 ", "2\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2009", "各省省选", "网络流", "浙江", "最小割"], "title": "[ZJOI2009] 狼和羊的故事", "background": "", "description": "“狼爱上羊啊爱的疯狂，谁让他们真爱了一场；狼爱上羊啊并不荒唐，他们说有爱就有方向……”Orez 听到这首歌，心想：狼和羊如此和谐，为什么不尝试羊狼合养呢？说干就干！\n\nOrez 的羊狼圈可以看作一个 $n\\times m$ 的矩阵格子，这个矩阵的边缘已经装上了篱笆。可是 Drake 很快发现狼再怎么也是狼，它们总是对羊垂涎三尺，那首歌只不过是一个动人的传说而已。所以 Orez 决定在羊狼圈中再加入一些篱笆，还是要将羊狼分开来养。\n\n通过仔细观察，Orez 发现狼和羊都有属于自己领地，若狼和羊们不能呆在自己的领地，那它们就会变得非常暴躁，不利于他们的成长。\n\nOrez 想要添加篱笆的尽可能的短。当然这个篱笆首先得保证不能改变狼羊的所属领地，再就是篱笆必须修筑完整，也就是说必须修建在单位格子的边界上并且不能只修建一部分。", "inputFormat": "文件的第一行包含两个整数 $n$ 和 $m$。接下来 $n$ 行每行 $m$ 个整数，$1$ 表示该格子属于狼的领地，$2$ 表示属于羊的领地，$0$ 表示该格子不是任何一只动物的领地。", "outputFormat": "文件中仅包含一个整数 $\\mathit{ans}$，代表篱笆的最短长度。", "hint": "对于 $10\\%$ 的数据，$n, m \\le 3$。  \n对于 $30\\%$ 的数据，$n, m \\le 20$。  \n对于 $100\\%$ 的数据，$1 \\le n, m \\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2009] The Story of the Wolf and the Sheep", "background": "", "description": "“The wolf fell in love with the sheep, madly in love; after all, they truly loved once. The wolf fell in love with the sheep; it isn’t absurd. They say where there is love, there is direction...” Hearing this song, Orez thought: since wolves and sheep are so harmonious, why not try raising them together? So he decided to give it a try.\n\nOrez’s wolf-and-sheep pen can be viewed as an $n\\times m$ grid. Fences have already been installed along the outer boundary of this grid. However, Drake quickly realized that wolves are still wolves—they always covet the sheep—and that song is just a moving legend. So Orez decided to add some more fences inside the pen to keep the wolves and sheep separated.\n\nAfter careful observation, Orez found that both wolves and sheep each have their own territories. If they cannot stay within their own territory, they become very irritable, which is not good for their growth.\n\nOrez wants the added fences to be as short as possible. Of course, these fences must first ensure that the ownership of wolves’ and sheep’s territories does not change; second, the fences must be built completely—specifically, they must lie along the edges of unit cells and cannot be built only partially.", "inputFormat": "The first line contains two integers $n$ and $m$. Then follow $n$ lines, each containing $m$ integers: $1$ indicates that the cell belongs to the wolves’ territory, $2$ indicates that it belongs to the sheep’s territory, and $0$ indicates that the cell belongs to neither animal.", "outputFormat": "Output a single integer $\\mathit{ans}$, representing the shortest total length of the fence.", "hint": "For $10\\%$ of the testdata, $n, m \\le 3$.  \nFor $30\\%$ of the testdata, $n, m \\le 20$.  \nFor $100\\%$ of the testdata, $1 \\le n, m \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2009] 狼和羊的故事", "background": "", "description": "“狼爱上羊啊爱的疯狂，谁让他们真爱了一场；狼爱上羊啊并不荒唐，他们说有爱就有方向……”Orez 听到这首歌，心想：狼和羊如此和谐，为什么不尝试羊狼合养呢？说干就干！\n\nOrez 的羊狼圈可以看作一个 $n\\times m$ 的矩阵格子，这个矩阵的边缘已经装上了篱笆。可是 Drake 很快发现狼再怎么也是狼，它们总是对羊垂涎三尺，那首歌只不过是一个动人的传说而已。所以 Orez 决定在羊狼圈中再加入一些篱笆，还是要将羊狼分开来养。\n\n通过仔细观察，Orez 发现狼和羊都有属于自己领地，若狼和羊们不能呆在自己的领地，那它们就会变得非常暴躁，不利于他们的成长。\n\nOrez 想要添加篱笆的尽可能的短。当然这个篱笆首先得保证不能改变狼羊的所属领地，再就是篱笆必须修筑完整，也就是说必须修建在单位格子的边界上并且不能只修建一部分。", "inputFormat": "文件的第一行包含两个整数 $n$ 和 $m$。接下来 $n$ 行每行 $m$ 个整数，$1$ 表示该格子属于狼的领地，$2$ 表示属于羊的领地，$0$ 表示该格子不是任何一只动物的领地。", "outputFormat": "文件中仅包含一个整数 $\\mathit{ans}$，代表篱笆的最短长度。", "hint": "对于 $10\\%$ 的数据，$n, m \\le 3$。  \n对于 $30\\%$ 的数据，$n, m \\le 20$。  \n对于 $100\\%$ 的数据，$1 \\le n, m \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P2599", "type": "P", "difficulty": 7, "samples": [["1\n4\n3 1 9 4\n", "0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "博弈论", "2009", "各省省选", "浙江"], "title": "[ZJOI2009] 取石子游戏", "background": "", "description": "在研究过 Nim 游戏及各种变种之后，Orez 又发现了一种全新的取石子游戏，这个游戏是这样的：\n\n有 $n$ 堆石子，将这 $n$ 堆石子摆成一排。游戏由两个人进行，两人轮流操作，每次操作者都可以从最左或最右的一堆中取出若干颗石子，可以将那一堆全部取掉，但不能不取，不能操作的人就输了。\n\nOrez 问：对于任意给出一个初始一个局面，是否存在先手必胜策略。", "inputFormat": "文件的第一行为一个整数 $T$，表示有 $T$ 组测试数据。对于每组测试数据：\n\n第一行为一个整数 $n$，表示有 $n$ 堆石子。\n\n第二行为 $n$ 个整数 $a_1, a_2, \\ldots , a_n$，依次表示每堆石子的数目。", "outputFormat": "对于每组测试数据仅输出一个整数 $0$ 或 $1$。其中 $1$ 表示有先手必胜策略，$0$ 表示没有。", "hint": "对于 $30 \\%$ 的数据，$n \\le 5$，$a_i \\le {10}^5$。  \n对于 $100 \\%$ 的数据，$1 \\le T \\le 10$，$1 \\le n \\le 1000$，$1 \\le a_i \\le {10}^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2009] Stone-Taking Game", "background": "", "description": "After studying the Nim game and its variants, Orez discovered a brand-new stone-taking game, defined as follows:\n\nThere are $n$ piles of stones arranged in a row. Two players take turns. On each turn, a player may take any positive number of stones from either the leftmost pile or the rightmost pile; the entire pile may be taken, but taking zero stones is not allowed. The player who cannot move loses.\n\nOrez asks: given any initial position, does there exist a winning strategy for the first player?", "inputFormat": "The first line contains an integer $T$, the number of test cases.  \nFor each test case:\n\n- The first line contains an integer $n$, the number of piles.  \n- The second line contains $n$ integers $a_1, a_2, \\ldots, a_n$, where $a_i$ is the number of stones in the $i$-th pile.", "outputFormat": "For each test case, output a single integer $0$ or $1$. Here, $1$ means there exists a winning strategy for the first player, and $0$ means there is not.", "hint": "- For $30\\%$ of the testdata, $n \\le 5$, $a_i \\le 10^5$.  \n- For $100\\%$ of the testdata, $1 \\le T \\le 10$, $1 \\le n \\le 1000$, $1 \\le a_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2009] 取石子游戏", "background": "", "description": "在研究过 Nim 游戏及各种变种之后，Orez 又发现了一种全新的取石子游戏，这个游戏是这样的：\n\n有 $n$ 堆石子，将这 $n$ 堆石子摆成一排。游戏由两个人进行，两人轮流操作，每次操作者都可以从最左或最右的一堆中取出若干颗石子，可以将那一堆全部取掉，但不能不取，不能操作的人就输了。\n\nOrez 问：对于任意给出一个初始一个局面，是否存在先手必胜策略。", "inputFormat": "文件的第一行为一个整数 $T$，表示有 $T$ 组测试数据。对于每组测试数据：\n\n第一行为一个整数 $n$，表示有 $n$ 堆石子。\n\n第二行为 $n$ 个整数 $a_1, a_2, \\ldots , a_n$，依次表示每堆石子的数目。", "outputFormat": "对于每组测试数据仅输出一个整数 $0$ 或 $1$。其中 $1$ 表示有先手必胜策略，$0$ 表示没有。", "hint": "对于 $30 \\%$ 的数据，$n \\le 5$，$a_i \\le {10}^5$。  \n对于 $100 \\%$ 的数据，$1 \\le T \\le 10$，$1 \\le n \\le 1000$，$1 \\le a_i \\le {10}^9$。", "locale": "zh-CN"}}}
{"pid": "P2600", "type": "P", "difficulty": 6, "samples": [["6\r\n1 2 4 5 6 7\r\n1 2 2 4 2 1\r\n", "1.000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "2008", "各省省选", "浙江", "半平面交"], "title": "[ZJOI2008] 瞭望塔", "background": null, "description": "致力于建设全国示范和谐小村庄的 H 村村长 dadzhi，决定在村中建立一个瞭望塔，以此加强村中的治安。\n\n我们将 H 村抽象为一维的轮廓，如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/1710.png)\n\n我们可以用一条山的上方轮廓折线 $(x_1, y_1),(x_2, y_2),\\cdots,(x_n, y_n)$ 来描述 H 村的形状，这里 $x_1 < x_2 < \\cdots < x_n$。瞭望塔可以建造在 $[x_1, x_n]$ 间的任意位置，但必须满足从瞭望塔的顶端可以看到 H 村的任意位置。显然在不同的位置建造瞭望塔，所需要建造的高度是不同的。为了节省开支，dadzhi 村长希望建造的塔高度尽可能小。\n\n请你写一个程序，帮助 dadzhi 村长计算塔的最小高度。", "inputFormat": "输入第一行包含一个整数 $n$，表示轮廓折线的节点数目。接下来第一行 $n$ 个整数，为 $x_1 \\sim x_n$。第三行 $n$ 个整数，为 $y_1 \\sim y_n$。", "outputFormat": "输出仅包含一个实数，为塔的最小高度，精确到小数点后三位。", "hint": "对于 $60\\%$ 的数据，$n \\le 60$；\n\n对于 $100\\%$ 的数据，$n \\le 300$，输入坐标绝对值不超过 $10^6$。\n\n**请注意实数误差带来的问题。**", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2008] Watchtower", "background": "", "description": "The village head of village H, dadzhi, who is committed to building a nationally recognized harmonious small village, decides to build a watchtower in the village to improve public security.\n\nWe abstract village H as a one-dimensional silhouette, as shown in the figure below.\n\n![](https://cdn.luogu.com.cn/upload/pic/1710.png)\n\nWe can describe the shape of village H by the upper contour polyline of a mountain $(x_1, y_1),(x_2, y_2),\\cdots,(x_n, y_n)$, where $x_1 < x_2 < \\cdots < x_n$. The watchtower can be built at any position within $[x_1, x_n]$, but it must satisfy that from the top of the watchtower one can see every point of village H. Clearly, the required height depends on where the watchtower is built. To save costs, village head dadzhi wants the tower’s height to be as small as possible.\n\nPlease write a program to compute the minimum height of the tower.", "inputFormat": "The first line contains an integer $n$, denoting the number of vertices of the contour polyline. The second line contains $n$ integers, which are $x_1 \\sim x_n$. The third line contains $n$ integers, which are $y_1 \\sim y_n$.", "outputFormat": "Output a single real number, which is the minimum height of the tower, accurate to three digits after the decimal point.", "hint": "For 60% of the testdata, $n \\le 60$.\n\nFor 100% of the testdata, $n \\le 300$, and the absolute values of the input coordinates do not exceed $10^6$.\n\nPlease be careful about floating-point errors.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2008] 瞭望塔", "background": null, "description": "致力于建设全国示范和谐小村庄的 H 村村长 dadzhi，决定在村中建立一个瞭望塔，以此加强村中的治安。\n\n我们将 H 村抽象为一维的轮廓，如下图所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/1710.png)\n\n我们可以用一条山的上方轮廓折线 $(x_1, y_1),(x_2, y_2),\\cdots,(x_n, y_n)$ 来描述 H 村的形状，这里 $x_1 < x_2 < \\cdots < x_n$。瞭望塔可以建造在 $[x_1, x_n]$ 间的任意位置，但必须满足从瞭望塔的顶端可以看到 H 村的任意位置。显然在不同的位置建造瞭望塔，所需要建造的高度是不同的。为了节省开支，dadzhi 村长希望建造的塔高度尽可能小。\n\n请你写一个程序，帮助 dadzhi 村长计算塔的最小高度。", "inputFormat": "输入第一行包含一个整数 $n$，表示轮廓折线的节点数目。接下来第一行 $n$ 个整数，为 $x_1 \\sim x_n$。第三行 $n$ 个整数，为 $y_1 \\sim y_n$。", "outputFormat": "输出仅包含一个实数，为塔的最小高度，精确到小数点后三位。", "hint": "对于 $60\\%$ 的数据，$n \\le 60$；\n\n对于 $100\\%$ 的数据，$n \\le 300$，输入坐标绝对值不超过 $10^6$。\n\n**请注意实数误差带来的问题。**", "locale": "zh-CN"}}}
{"pid": "P2601", "type": "P", "difficulty": 6, "samples": [["5 5\r\n4 2 4 4 4 \r\n3 1 4 4 3 \r\n3 5 3 3 3 \r\n3 1 5 3 3 \r\n4 2 1 2 4 ", "27"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2009", "二分", "各省省选", "浙江", "哈希 hashing", "Manacher 算法"], "title": "[ZJOI2009] 对称的正方形", "background": "", "description": "Orez 很喜欢搜集一些神秘的数据，并经常把它们排成一个矩阵进行研究。最近，Orez 又得到了一些数据，并已经把它们排成了一个 $n$ 行 $m$ 列的矩阵。通过观察，Orez 发现这些数据蕴涵了一个奇特的数，就是矩阵中上下对称且左右对称的正方形子矩阵的个数。Orez 自然很想知道这个数是多少，可是矩阵太大，无法去数。只能请你编个程序来计算出这个数。\n", "inputFormat": "文件的第一行为两个整数 $n$ 和 $m$。接下来 $n$ 行每行包含 $m$ 个正整数，表示 Orez 得到的矩阵。\n", "outputFormat": "文件中仅包含一个整数 $ans$，表示矩阵中有 $ans$ 个上下左右对称的正方形子矩阵。\n", "hint": "- 对于 $30\\%$ 的数据 $1\\le n,m\\le 100$；\n- 对于 $100\\%$ 的数据 $1\\le n,m\\le 1000$，矩阵中的数的大小不超过 $10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2009] Symmetric Square", "background": "", "description": "Orez likes collecting mysterious data and often arranges them into a matrix for study. Recently, Orez obtained some new data and arranged them into an $n$-row, $m$-column matrix. By observation, Orez found a peculiar number: the count of square submatrices that are symmetric both top-to-bottom and left-to-right. Naturally, Orez wants to know this number, but the matrix is too large to count by hand. Please write a program to compute this number.", "inputFormat": "The first line contains two integers $n$ and $m$. The next $n$ lines each contain $m$ positive integers, representing Orez’s matrix.", "outputFormat": "Output a single integer $ans$, the number of square submatrices that are symmetric both top-to-bottom and left-to-right.", "hint": "- For 30% of the testdata, $1 \\le n, m \\le 100$.\n- For 100% of the testdata, $1 \\le n, m \\le 1000$, and the values in the matrix do not exceed $10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2009] 对称的正方形", "background": "", "description": "Orez 很喜欢搜集一些神秘的数据，并经常把它们排成一个矩阵进行研究。最近，Orez 又得到了一些数据，并已经把它们排成了一个 $n$ 行 $m$ 列的矩阵。通过观察，Orez 发现这些数据蕴涵了一个奇特的数，就是矩阵中上下对称且左右对称的正方形子矩阵的个数。Orez 自然很想知道这个数是多少，可是矩阵太大，无法去数。只能请你编个程序来计算出这个数。\n", "inputFormat": "文件的第一行为两个整数 $n$ 和 $m$。接下来 $n$ 行每行包含 $m$ 个正整数，表示 Orez 得到的矩阵。\n", "outputFormat": "文件中仅包含一个整数 $ans$，表示矩阵中有 $ans$ 个上下左右对称的正方形子矩阵。\n", "hint": "- 对于 $30\\%$ 的数据 $1\\le n,m\\le 100$；\n- 对于 $100\\%$ 的数据 $1\\le n,m\\le 1000$，矩阵中的数的大小不超过 $10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P2602", "type": "P", "difficulty": 4, "samples": [["1 99\n", "9 20 20 20 20 20 20 20 20 20\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "2010", "各省省选", "浙江", "深度优先搜索 DFS", "数位 DP"], "title": "[ZJOI2010] 数字计数", "background": null, "description": "给定两个正整数 $a$ 和 $b$，求在 $[a,b]$ 中的所有整数中，每个数码（digit）各出现了多少次。", "inputFormat": "仅包含一行两个整数 $a,b$，含义如上所述。", "outputFormat": "包含一行十个整数，分别表示 $0\\sim 9$ 在 $[a,b]$ 中出现了多少次。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $1\\le a\\le b\\le10^6$；\n- 对于 $100\\%$ 的数据，保证 $1\\le a\\le b\\le 10^{12}$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2010] Digit Counting", "background": "", "description": "Given two positive integers $a$ and $b$, count how many times each digit appears among all integers in $[a,b]$.", "inputFormat": "A single line containing two integers $a,b$, as described above.", "outputFormat": "A single line with ten integers, representing how many times $0\\sim 9$ appear in $[a,b]$.", "hint": "#### Constraints and Notes\n\n- For $30\\%$ of the testdata, it is guaranteed that $1\\le a\\le b\\le10^6$.\n- For $100\\%$ of the testdata, it is guaranteed that $1\\le a\\le b\\le 10^{12}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2010] 数字计数", "background": null, "description": "给定两个正整数 $a$ 和 $b$，求在 $[a,b]$ 中的所有整数中，每个数码（digit）各出现了多少次。", "inputFormat": "仅包含一行两个整数 $a,b$，含义如上所述。", "outputFormat": "包含一行十个整数，分别表示 $0\\sim 9$ 在 $[a,b]$ 中出现了多少次。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $1\\le a\\le b\\le10^6$；\n- 对于 $100\\%$ 的数据，保证 $1\\le a\\le b\\le 10^{12}$。", "locale": "zh-CN"}}}
{"pid": "P2603", "type": "P", "difficulty": 6, "samples": [["3 2\n2 17 0 10 1\n3 0 0 1 0 1 -1\n0 0 1 0 1 1\n", "2\n1\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["2008", "各省省选", "浙江", "向量", "AC 自动机"], "title": "[ZJOI2008] 无序运动", "background": "", "description": "D 博士对物理有着深入的研究，经典物理、天体物理、量子物理都有着以他的名字命名的定理。最近 D 博士着迷于研究粒子运动的无规则性。对圣经深信不疑的他相信，上帝创造的任何事物必然是有序的、有理可循的，而不是无规则的、混沌的。\n\n经过长时间的研究，D 博士找到了很多出现相当频繁的轨迹片断，他把这些轨迹片断储存在一个很大的数据库内。他需要你帮助他写一个程序，对于一个给出的粒子运动轨迹，统计数据库中每个轨迹片断的出现的次数。\n\n为清楚起见，我们定义一个粒子的轨迹为二维平面上的一个点列 $(P_1, P_2, \\dots, P_N)$。点列 $P$ 的一个子列 $[i, j]$ 定义为 $P$ 中一段连续的子序列 $(P_i, P_{i + 1}, \\dots, P_j)$。点列 $P$ 的一个子列 $[u, v]$ 被称为点列 $Q = (Q_1, Q_2, \\dots, Q_{v - u + 1})$ 在 $P$ 中的一次出现，当且仅当 $Q$ 经过有限次的平移、旋转、翻转、放缩之后得到 $Q'$ 满足 $\\forall 1 \\le k \\le u - v + 1$，$ Q'_k = P_{u + k - 1}$。\n\n对点列进行四种操作的解释：\n|操作名称|解释|\n|:-:|:-:|\n|平移|设平移向量为 $(d_x, d_y)$，则任意点 $(x, y)$ 平移后的结果为 $(x + d_x, y + d_y)$|\n|旋转|设旋转角为 $t$，则任意点 $(x, y)$ 旋转后的结果为 $(x \\cos t - y \\sin t, x \\sin t + y \\cos t)$|\n|翻转|任意点 $(x, y)$ 翻转后的结果为 $(x, -y)$\n|放缩|设放缩比例为 $p(p \\ne 0)$，则任意点 $(x, y)$ 放缩后的结果为 $(px, py)$|", "inputFormat": "第一行两个整数 $N, M$，分别描述待处理的粒子运动轨迹的点列大小与数据库内的轨迹片断个数。\n\n接下来 $M$ 行依次给出每个轨迹片断。每行先是一个正整数 $K$，表示该轨迹片断点列的长度。然后 $2K$ 个整数，依次描述点列中的 $K$ 个点的横坐标与纵坐标。\n\n接下来一行 $2N$ 个整数，依次描述待处理的粒子运动轨迹的点列中 $N$ 个点的横坐标与纵坐标。\n\n注：输入中的每条轨迹中任意相邻两点不会相同。", "outputFormat": "应包含 $M$ 行，依次给出每个片段在待处理运动轨迹中的出现次数。", "hint": "记片段总长度为 $L$。\n\n对于 $30\\%$ 的测试数据，满足 $N, M, K \\le 100$，$L \\le 500$;\n\n对于 $50\\%$ 的测试数据，满足 $N, M, K \\le 1000$，$L \\le 5000$;\n\n对于 $100\\%$ 的测试数据，满足 $N, K \\le 2 \\times 10 ^ 5$，$L \\le 2 \\times 10 ^ 6$，保证输入中给出所有点坐标绝对值均不大于 $10 ^ 4$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2008] Unordered Motion", "background": "", "description": "Dr. D has conducted in-depth research in physics, with theorems in classical physics, astrophysics, and quantum physics named after him. Recently, he has been fascinated by the irregularity of particle motion. Firmly believing in the Bible, he is convinced that anything created by God must be orderly and rational, rather than random and chaotic.\n\nAfter long study, Dr. D found many trajectory fragments that appear quite frequently and stored them in a large database. He needs you to write a program that, for a given particle trajectory, counts the number of occurrences of each trajectory fragment from the database.\n\nFor clarity, we define a particle’s trajectory as a sequence of points on a 2D plane, $(P_1, P_2, \\dots, P_N)$. A subarray $[i, j]$ of the point sequence $P$ is defined as a contiguous subsequence in $P$, $(P_i, P_{i + 1}, \\dots, P_j)$. A subarray $[u, v]$ of the point sequence $P$ is called an occurrence of the point sequence $Q = (Q_1, Q_2, \\dots, Q_{v - u + 1})$ in $P$ if and only if, after a finite number of translations, rotations, reflections, and scalings, we obtain $Q'$ such that $\\forall 1 \\le k \\le v - u + 1$, $Q'_k = P_{u + k - 1}$.\n\nExplanations for the four operations on point sequences:\n|Operation|Explanation|\n|:-:|:-:|\n|Translation|Let the translation vector be $(d_x, d_y)$. Then any point $(x, y)$ is mapped to $(x + d_x, y + d_y)$.|\n|Rotation|Let the rotation angle be $t$. Then any point $(x, y)$ is mapped to $(x \\cos t - y \\sin t, x \\sin t + y \\cos t)$.|\n|Reflection|Any point $(x, y)$ is mapped to $(x, -y)$.|\n|Scaling|Let the scaling factor be $p (p \\ne 0)$. Then any point $(x, y)$ is mapped to $(px, py)$.|", "inputFormat": "The first line contains two integers $N, M$, representing the size of the point sequence of the trajectory to be processed and the number of trajectory fragments in the database, respectively.\n\nThe next $M$ lines describe each trajectory fragment in order. Each line starts with a positive integer $K$, the length of the point sequence of that fragment. Then $2K$ integers follow, describing the $K$ points’ $x$- and $y$-coordinates in order.\n\nThe next line contains $2N$ integers, describing the $x$- and $y$-coordinates of the $N$ points in the point sequence of the trajectory to be processed, in order.\n\nNote: In every trajectory in the input, any two adjacent points are different.", "outputFormat": "Output $M$ lines. For each fragment, output the number of its occurrences in the trajectory to be processed, in order.", "hint": "Let the total length of all fragments be $L$.\n\nConstraints:\n- For $30\\%$ of the testdata, $N, M, K \\le 100$, $L \\le 500$.\n- For $50\\%$ of the testdata, $N, M, K \\le 1000$, $L \\le 5000$.\n- For $100\\%$ of the testdata, $N, K \\le 2 \\times 10 ^ 5$, $L \\le 2 \\times 10 ^ 6$, and it is guaranteed that the absolute value of every given point coordinate in the input does not exceed $10 ^ 4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2008] 无序运动", "background": "", "description": "D 博士对物理有着深入的研究，经典物理、天体物理、量子物理都有着以他的名字命名的定理。最近 D 博士着迷于研究粒子运动的无规则性。对圣经深信不疑的他相信，上帝创造的任何事物必然是有序的、有理可循的，而不是无规则的、混沌的。\n\n经过长时间的研究，D 博士找到了很多出现相当频繁的轨迹片断，他把这些轨迹片断储存在一个很大的数据库内。他需要你帮助他写一个程序，对于一个给出的粒子运动轨迹，统计数据库中每个轨迹片断的出现的次数。\n\n为清楚起见，我们定义一个粒子的轨迹为二维平面上的一个点列 $(P_1, P_2, \\dots, P_N)$。点列 $P$ 的一个子列 $[i, j]$ 定义为 $P$ 中一段连续的子序列 $(P_i, P_{i + 1}, \\dots, P_j)$。点列 $P$ 的一个子列 $[u, v]$ 被称为点列 $Q = (Q_1, Q_2, \\dots, Q_{v - u + 1})$ 在 $P$ 中的一次出现，当且仅当 $Q$ 经过有限次的平移、旋转、翻转、放缩之后得到 $Q'$ 满足 $\\forall 1 \\le k \\le u - v + 1$，$ Q'_k = P_{u + k - 1}$。\n\n对点列进行四种操作的解释：\n|操作名称|解释|\n|:-:|:-:|\n|平移|设平移向量为 $(d_x, d_y)$，则任意点 $(x, y)$ 平移后的结果为 $(x + d_x, y + d_y)$|\n|旋转|设旋转角为 $t$，则任意点 $(x, y)$ 旋转后的结果为 $(x \\cos t - y \\sin t, x \\sin t + y \\cos t)$|\n|翻转|任意点 $(x, y)$ 翻转后的结果为 $(x, -y)$\n|放缩|设放缩比例为 $p(p \\ne 0)$，则任意点 $(x, y)$ 放缩后的结果为 $(px, py)$|", "inputFormat": "第一行两个整数 $N, M$，分别描述待处理的粒子运动轨迹的点列大小与数据库内的轨迹片断个数。\n\n接下来 $M$ 行依次给出每个轨迹片断。每行先是一个正整数 $K$，表示该轨迹片断点列的长度。然后 $2K$ 个整数，依次描述点列中的 $K$ 个点的横坐标与纵坐标。\n\n接下来一行 $2N$ 个整数，依次描述待处理的粒子运动轨迹的点列中 $N$ 个点的横坐标与纵坐标。\n\n注：输入中的每条轨迹中任意相邻两点不会相同。", "outputFormat": "应包含 $M$ 行，依次给出每个片段在待处理运动轨迹中的出现次数。", "hint": "记片段总长度为 $L$。\n\n对于 $30\\%$ 的测试数据，满足 $N, M, K \\le 100$，$L \\le 500$;\n\n对于 $50\\%$ 的测试数据，满足 $N, M, K \\le 1000$，$L \\le 5000$;\n\n对于 $100\\%$ 的测试数据，满足 $N, K \\le 2 \\times 10 ^ 5$，$L \\le 2 \\times 10 ^ 6$，保证输入中给出所有点坐标绝对值均不大于 $10 ^ 4$。", "locale": "zh-CN"}}}
{"pid": "P2604", "type": "P", "difficulty": 6, "samples": [["5 8 2\n1 2 5 8\n2 5 9 9\n5 1 6 2\n5 1 1 8\n1 2 8 7\n2 5 4 9\n1 2 1 1\n1 4 2 1", "13 19\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "网络流", "浙江", "图论建模", "费用流"], "title": "[ZJOI2010] 网络扩容", "background": "", "description": "给定一张有向图，每条边都有一个容量 $c$ 和一个扩容费用 $w$。这里扩容费用是指将容量扩大 $1$ 所需的费用。求： \n\n1. 在不扩容的情况下，$1$ 到 $n$ 的最大流；\n\n2. 将 $1$ 到 $n$ 的最大流增加 $k$ 所需的最小扩容费用。", "inputFormat": "第一行包含三个整数 $n,m,k$，表示有向图的点数、边数以及所需要增加的流量。\n\n接下来的 $M$ 行每行包含四个整数 $u,v,c,w$，表示一条从$u$ 到 $v$，容量为 $c$，扩容费用为 $w$ 的边。", "outputFormat": "输出文件一行包含两个整数，分别表示问题 $1$ 和问题 $2$ 的答案。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n\\le 100$。\n- 对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^3$，$1\\le m\\le 5\\times 10^3$，$1\\le k\\le 10$，$1 \\leq u, v \\leq n$，$1\\le c,w\\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2010] Network Expansion", "background": "", "description": "Given a directed graph, each edge has a capacity $c$ and an expansion cost $w$. The expansion cost is the cost required to increase the capacity by $1$. Find:\n1. The maximum flow from $1$ to $n$ without any expansion.\n2. The minimum total expansion cost required to increase the maximum flow from $1$ to $n$ by $k$.", "inputFormat": "The first line contains three integers $n, m, k$, denoting the number of vertices, the number of edges, and the required increase in flow.\n\nThe next $m$ lines each contain four integers $u, v, c, w$, describing a directed edge from $u$ to $v$ with capacity $c$ and expansion cost $w$.", "outputFormat": "Output one line containing two integers, which are the answers to problems $1$ and $2$ respectively.", "hint": "- Constraints\n  - For $30\\%$ of the testdata, it is guaranteed that $n \\le 100$.\n  - For $100\\%$ of the testdata, it is guaranteed that $1 \\le n \\le 10^3$, $1 \\le m \\le 5 \\times 10^3$, $1 \\le k \\le 10$, $1 \\le u, v \\le n$, and $1 \\le c, w \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2010] 网络扩容", "background": "", "description": "给定一张有向图，每条边都有一个容量 $c$ 和一个扩容费用 $w$。这里扩容费用是指将容量扩大 $1$ 所需的费用。求： \n\n1. 在不扩容的情况下，$1$ 到 $n$ 的最大流；\n\n2. 将 $1$ 到 $n$ 的最大流增加 $k$ 所需的最小扩容费用。", "inputFormat": "第一行包含三个整数 $n,m,k$，表示有向图的点数、边数以及所需要增加的流量。\n\n接下来的 $M$ 行每行包含四个整数 $u,v,c,w$，表示一条从$u$ 到 $v$，容量为 $c$，扩容费用为 $w$ 的边。", "outputFormat": "输出文件一行包含两个整数，分别表示问题 $1$ 和问题 $2$ 的答案。", "hint": "#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，保证 $n\\le 100$。\n- 对于 $100\\%$ 的数据，保证 $1\\le n\\le 10^3$，$1\\le m\\le 5\\times 10^3$，$1\\le k\\le 10$，$1 \\leq u, v \\leq n$，$1\\le c,w\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P2605", "type": "P", "difficulty": 6, "samples": [["3 2\n1 2\n2 3 2\n1 1 0\n10 20 30", "4"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2010", "线段树", "各省省选", "浙江"], "title": "[ZJOI2010] 基站选址", "background": null, "description": "有 $N$ 个村庄坐落在一条直线上，第 $i(i>1)$ 个村庄距离第 $1$ 个村庄的距离为 $D_i$。需要在这些村庄中建立不超过 $K$ 个通讯基站，在第 $i$ 个村庄建立基站的费用为 $C_i$。如果在距离第 $i$ 个村庄不超过 $S_i$ 的范围内建立了一个通讯基站，那么就村庄被基站覆盖了。如果第 $i$ 个村庄没有被覆盖，则需要向他们补偿，费用为 $W_i$。现在的问题是，选择基站的位置，使得总费用最小。", "inputFormat": "输入文件的第一行包含两个整数 $N,K$，含义如上所述。\n\n第二行包含 $N-1$ 个整数，分别表示 $D_2,D_3,\\cdots,D_N$，这 $N-1$ 个数是递增的。\n\n第三行包含 $N$ 个整数，表示 $C_1,C_2,\\cdots,C_N$。\n\n第四行包含 $N$ 个整数，表示 $S_1,S_2,\\cdots,S_N$。\n\n第五行包含 $N$ 个整数，表示 $W_1,W_2,\\cdots,W_N$。", "outputFormat": "输出文件中仅包含一个整数，表示最小的总费用。", "hint": "### 数据规模与约定\n\n$30\\%$ 的数据中，$N \\leq 500$；\n\n$100\\%$ 的数据中，$K\\leq N$，$K\\leq 100$，$N\\leq 2\\times 10^4$，$D_i \\leq 10^9$，$C_i\\leq 10^4$，$S_i \\leq10^9$，$W_i \\leq 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2010] Base Station Placement", "background": "", "description": "There are $N$ villages located on a straight line. For village $i$ ($i > 1$), the distance to village $1$ is $D_i$. You need to build at most $K$ communication base stations in these villages. The cost to build a base station at village $i$ is $C_i$. If there is a base station within a distance no more than $S_i$ from village $i$, then village $i$ is considered covered. If village $i$ is not covered, you must compensate it at a cost of $W_i$. Choose the locations of the base stations to minimize the total cost.", "inputFormat": "- The first line contains two integers $N, K$, as described above.\n- The second line contains $N-1$ integers, $D_2, D_3, \\cdots, D_N$, which are in ascending order.\n- The third line contains $N$ integers, $C_1, C_2, \\cdots, C_N$.\n- The fourth line contains $N$ integers, $S_1, S_2, \\cdots, S_N$.\n- The fifth line contains $N$ integers, $W_1, W_2, \\cdots, W_N$.", "outputFormat": "Output a single integer, the minimum total cost.", "hint": "Constraints:\n- For $30\\%$ of the testdata, $N \\leq 500$.\n- For $100\\%$ of the testdata, $K \\leq N$, $K \\leq 100$, $N \\leq 2 \\times 10^4$, $D_i \\leq 10^9$, $C_i \\leq 10^4$, $S_i \\leq 10^9$, $W_i \\leq 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2010] 基站选址", "background": null, "description": "有 $N$ 个村庄坐落在一条直线上，第 $i(i>1)$ 个村庄距离第 $1$ 个村庄的距离为 $D_i$。需要在这些村庄中建立不超过 $K$ 个通讯基站，在第 $i$ 个村庄建立基站的费用为 $C_i$。如果在距离第 $i$ 个村庄不超过 $S_i$ 的范围内建立了一个通讯基站，那么就村庄被基站覆盖了。如果第 $i$ 个村庄没有被覆盖，则需要向他们补偿，费用为 $W_i$。现在的问题是，选择基站的位置，使得总费用最小。", "inputFormat": "输入文件的第一行包含两个整数 $N,K$，含义如上所述。\n\n第二行包含 $N-1$ 个整数，分别表示 $D_2,D_3,\\cdots,D_N$，这 $N-1$ 个数是递增的。\n\n第三行包含 $N$ 个整数，表示 $C_1,C_2,\\cdots,C_N$。\n\n第四行包含 $N$ 个整数，表示 $S_1,S_2,\\cdots,S_N$。\n\n第五行包含 $N$ 个整数，表示 $W_1,W_2,\\cdots,W_N$。", "outputFormat": "输出文件中仅包含一个整数，表示最小的总费用。", "hint": "### 数据规模与约定\n\n$30\\%$ 的数据中，$N \\leq 500$；\n\n$100\\%$ 的数据中，$K\\leq N$，$K\\leq 100$，$N\\leq 2\\times 10^4$，$D_i \\leq 10^9$，$C_i\\leq 10^4$，$S_i \\leq10^9$，$W_i \\leq 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2606", "type": "P", "difficulty": 5, "samples": [["20 23 ", "16\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "数学", "2010", "各省省选", "浙江", "组合数学", "Lucas 定理"], "title": "[ZJOI2010] 排列计数", "background": "", "description": "称一个 $1 \\sim n$ 的排列 $p_1,p_2, \\dots ,p_n$ 是 Magic 的，当且仅当  \n$$\\forall i \\in [2,n],p_i > p_{\\lfloor i/2 \\rfloor}$$\n计算 $1 \\sim n$ 的排列中有多少是 Magic 的，答案可能很大，只能输出模 $m$ 以后的值。", "inputFormat": "一行两个整数 $n,m$，含义如上所述。\n", "outputFormat": "输出文件中仅包含一个整数，表示 $1\\sim n$ 的排列中， Magic 排列的个数模 $m$ 的值。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 10^6$, $1\\le m \\le 10^9$，$m$ 是一个质数。\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2010] Permutation Counting", "background": "", "description": "We call a permutation $p_1, p_2, \\dots, p_n$ of $1 \\sim n$ \"Magic\" if and only if\n$$\\forall i \\in [2,n], \\; p_i > p_{\\lfloor i/2 \\rfloor}.$$\nCount how many permutations of $1 \\sim n$ are \"Magic\". The answer may be large; output the value modulo $m$.", "inputFormat": "One line contains two integers $n, m$, as described above.", "outputFormat": "Output a single integer: the number of \"Magic\" permutations of $1 \\sim n$ modulo $m$.", "hint": "Constraints  \nFor $100\\%$ of the data, $1 \\le n \\le 10^6$, $1 \\le m \\le 10^9$, and $m$ is a prime.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2010] 排列计数", "background": "", "description": "称一个 $1 \\sim n$ 的排列 $p_1,p_2, \\dots ,p_n$ 是 Magic 的，当且仅当  \n$$\\forall i \\in [2,n],p_i > p_{\\lfloor i/2 \\rfloor}$$\n计算 $1 \\sim n$ 的排列中有多少是 Magic 的，答案可能很大，只能输出模 $m$ 以后的值。", "inputFormat": "一行两个整数 $n,m$，含义如上所述。\n", "outputFormat": "输出文件中仅包含一个整数，表示 $1\\sim n$ 的排列中， Magic 排列的个数模 $m$ 的值。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 10^6$, $1\\le m \\le 10^9$，$m$ 是一个质数。\n", "locale": "zh-CN"}}}
{"pid": "P2607", "type": "P", "difficulty": 5, "samples": [["3\n10 2\n20 3\n30 1\n", "30"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "2008", "各省省选", "浙江", "树形 DP", "基环树"], "title": "[ZJOI2008] 骑士", "background": "", "description": "Z 国的骑士团是一个很有势力的组织，帮会中汇聚了来自各地的精英。他们劫富济贫，惩恶扬善，受到社会各界的赞扬。\n\n最近发生了一件可怕的事情，邪恶的 Y 国发动了一场针对 Z 国的侵略战争。战火绵延五百里，在和平环境中安逸了数百年的 Z 国又怎能抵挡的住 Y 国的军队。于是人们把所有的希望都寄托在了骑士团的身上，就像期待有一个真龙天子的降生，带领正义打败邪恶。\n\n骑士团是肯定具有打败邪恶势力的能力的，但是骑士们互相之间往往有一些矛盾。每个骑士都有且仅有一个自己最厌恶的骑士（当然不是他自己），他是绝对不会与自己最厌恶的人一同出征的。\n\n战火绵延，人民生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！国王交给了你一个艰巨的任务，从所有的骑士中选出一个骑士军团，使得军团内没有矛盾的两人（不存在一个骑士与他最痛恨的人一同被选入骑士军团的情况），并且，使得这支骑士军团最具有战斗力。\n\n为了描述战斗力，我们将骑士按照 $1$ 至 $n$ 编号，给每名骑士一个战斗力的估计，一个军团的战斗力为所有骑士的战斗力总和。", "inputFormat": "第一行包含一个整数 $n$，描述骑士团的人数。\n\n接下来 $n$ 行，每行两个整数，按顺序描述每一名骑士的战斗力和他最痛恨的骑士。", "outputFormat": "应输出一行，包含一个整数，表示你所选出的骑士军团的战斗力。", "hint": "#### 数据规模与约定\n\n对于 $30\\%$ 的测试数据，满足 $n \\le 10$；\n\n对于 $60\\%$ 的测试数据，满足 $n \\le 100$；\n\n对于 $80\\%$ 的测试数据，满足 $n \\le 10 ^4$。\n\n对于 $100\\%$ 的测试数据，满足 $1\\le n \\le 10^6$，每名骑士的战斗力都是不大于 $10^6$ 的正整数。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2008] Knights", "background": "", "description": "The knights’ order of country Z is a powerful organization that gathers elites from all over the land. They rob the rich to help the poor and punish evil while promoting good, earning praise from all sectors of society.\n\nRecently, a terrible event occurred: the evil country Y launched an invasion against country Z. War flames stretch for five hundred li. Having enjoyed peace for hundreds of years, country Z could hardly resist the army of country Y. Thus, people pinned all their hopes on the knights’ order, as if awaiting the birth of a true dragon emperor to lead justice to defeat evil.\n\nThe knights’ order certainly has the ability to defeat evil forces, but there are often conflicts among the knights. Each knight has exactly one knight he hates the most (and it is not himself), and he absolutely refuses to go on campaign together with the one he hates the most.\n\nWar is raging, and people are suffering. It is urgent to organize a knights’ army to join the battle. The king assigns you a difficult task: choose a subset of knights to form an army such that no two selected knights are in conflict (i.e., there does not exist a knight who is selected together with the knight he hates the most), and such that this army has the maximum combat power.\n\nTo describe combat power, we number the knights from $1$ to $n$, and assign each knight an estimated combat power. The combat power of an army is the sum of the combat power of all selected knights.", "inputFormat": "The first line contains an integer $n$, the number of knights.\n\nThe next $n$ lines, in order, describe each knight’s combat power and the knight he hates the most. Specifically, for $i = 1, \\dots, n$, line $i$ contains two integers $w_i$ and $h_i$, where $w_i$ is the combat power of knight $i$, and $h_i$ is the index of the knight he hates the most, with $1 \\le h_i \\le n$ and $h_i \\ne i$.", "outputFormat": "Output one line containing a single integer, the maximum combat power of the army you select.", "hint": "Constraints:\n\n- For $30\\%$ of the testdata, $n \\le 10$.\n- For $60\\%$ of the testdata, $n \\le 100$.\n- For $80\\%$ of the testdata, $n \\le 10^4$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 10^6$, and each knight’s combat power is a positive integer not greater than $10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2008] 骑士", "background": "", "description": "Z 国的骑士团是一个很有势力的组织，帮会中汇聚了来自各地的精英。他们劫富济贫，惩恶扬善，受到社会各界的赞扬。\n\n最近发生了一件可怕的事情，邪恶的 Y 国发动了一场针对 Z 国的侵略战争。战火绵延五百里，在和平环境中安逸了数百年的 Z 国又怎能抵挡的住 Y 国的军队。于是人们把所有的希望都寄托在了骑士团的身上，就像期待有一个真龙天子的降生，带领正义打败邪恶。\n\n骑士团是肯定具有打败邪恶势力的能力的，但是骑士们互相之间往往有一些矛盾。每个骑士都有且仅有一个自己最厌恶的骑士（当然不是他自己），他是绝对不会与自己最厌恶的人一同出征的。\n\n战火绵延，人民生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！国王交给了你一个艰巨的任务，从所有的骑士中选出一个骑士军团，使得军团内没有矛盾的两人（不存在一个骑士与他最痛恨的人一同被选入骑士军团的情况），并且，使得这支骑士军团最具有战斗力。\n\n为了描述战斗力，我们将骑士按照 $1$ 至 $n$ 编号，给每名骑士一个战斗力的估计，一个军团的战斗力为所有骑士的战斗力总和。", "inputFormat": "第一行包含一个整数 $n$，描述骑士团的人数。\n\n接下来 $n$ 行，每行两个整数，按顺序描述每一名骑士的战斗力和他最痛恨的骑士。", "outputFormat": "应输出一行，包含一个整数，表示你所选出的骑士军团的战斗力。", "hint": "#### 数据规模与约定\n\n对于 $30\\%$ 的测试数据，满足 $n \\le 10$；\n\n对于 $60\\%$ 的测试数据，满足 $n \\le 100$；\n\n对于 $80\\%$ 的测试数据，满足 $n \\le 10 ^4$。\n\n对于 $100\\%$ 的测试数据，满足 $1\\le n \\le 10^6$，每名骑士的战斗力都是不大于 $10^6$ 的正整数。", "locale": "zh-CN"}}}
{"pid": "P2608", "type": "P", "difficulty": 0, "samples": [["4\r\n\r\n1 2 3\r\n10 20\r\n\r\n3 5 7\r\n10 20\r\n15 16\r\n17 18\r\n\r\n4 3 6\r\n10 12\r\n8 9\r\n16 11\r\n13 20\r\n\r\n4 4 6\r\n7 12\r\n5 3\r\n6 5\r\n1000000 1000000\r\n", "100\r\n162\r\n84\r\n41\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2010", "各省省选", "浙江"], "title": "[ZJOI2010] 任务安排", "background": "", "description": "小 Y 最近遇到了一个棘手的问题。她有两项任务需要完成，其中第一项任务是重复操作 $1$（下文称作 op1）共 $S_1$ 次，第二项任务是重复操作 $2$（下文称作 op2）共 $S_2$ 次。为了完成这些任务，小 Y 雇佣了 $N$ 名工人。其中，第 $i$ 个工人完成 op1 所需时间为 $T_{1,i}$，完成 op2 所需时间为 $T_{2,i}$。每个 op1 和 op2 都只能被一名工人完成，每名工人在任意时刻都只能做一项工作。\n\n所有的工人从第 $0$ 秒开始工作。每当一个工人开始执行一项操作（op1 或 op2），他必须一直执行下去直到完成而不能被打断。我们记第一项任务完成的时间为 $E_1$，第二项任务完成的时间为 $E_2$，你的任务就是安排这些工人的工作，使得 $E_1+E_2$ 最小。", "inputFormat": "输入文件的第一行包含一个整数 $T$，表示输入文件中数据的组数。\n\n每个测试数据的第一行包含三个整数 $N,S_1,S_2$，含义如上文所述。\n\n接下来的 $N$ 行每行包含两个整数 $T_{1,i},T_{2,i}$，分别表示第 $i$ 个工人完成 op1 和 op2 所需的时间。", "outputFormat": "输出文件包含 $T$ 行，每行只有一个整数，表示你找到的 $E_1+E_2$ 的最小值。", "hint": "### 样例说明\n\n第一组数据中，唯一的工人首先执行 $2$ 次 op1，在第 $20$ 秒完成任务一 $(E_1=20)$。然后执行 $2$ 次 op2，在第 $80$ 秒完成任务二 $(E_2=80)$。因此答案为 $20+80=100$。\n\n第二组数据中，工人 $\\#1$ 连续执行 $5$ 次 op1，在第 $50$ 秒完成任务一 $(E_1=50)$，工人 $#2$ 执行 $7$ 次 op2，在第 $112$ 秒完成任务二 $(E_2=112)$。因此答案为 $50+112=162$。\n\n第三组数据和第二组数据类似。\n\n第四组数据中，工人 $\\#2$ 首先连续执行 $6$ 次 op2，在第 $18$ 秒完成任务二 $(E_2=18)$。于此同时，工人 $#3$ 执行 $3$ 次 op1，同样在第 $18$ 秒完成。此时还需要执行一次 op1，因此让工人 $#2$ 去执行最后一次 op1，在第 $23$ 秒完成任务一 $(E_1=23)$ 、因此答案为 $18+23=41$。\n\n\n### 数据范围及约定\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 7$，$1 \\le N \\le 100$，$1 \\le S_1,S_2 \\le 7$，$1 \\le T_{1,i},T_{2,i} \\le 10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2010] Task Arrangement", "background": "", "description": "Xiao Y recently encountered a tricky problem. She has two tasks to complete. The first task is to repeat operation 1 (hereinafter referred to as op1) exactly $S_1$ times, and the second task is to repeat operation 2 (hereinafter referred to as op2) exactly $S_2$ times. To complete these tasks, Xiao Y hired $N$ workers. For the $i$-th worker, the time to complete one op1 is $T_{1,i}$, and the time to complete one op2 is $T_{2,i}$. Each op1 and op2 can only be completed by one worker, and each worker can only perform one job at any moment.\n\nAll workers start working at time $0$. Whenever a worker starts an operation (op1 or op2), they must continue until it finishes and cannot be interrupted. Let the completion time of the first task be $E_1$, and the completion time of the second task be $E_2$. Your goal is to schedule the workers so that $E_1 + E_2$ is minimized.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nFor each test case, the first line contains three integers $N, S_1, S_2$ as described above.\n\nEach of the next $N$ lines contains two integers $T_{1,i}, T_{2,i}$, denoting the time the $i$-th worker needs to complete one op1 and one op2, respectively.", "outputFormat": "Output $T$ lines. Each line contains a single integer, the minimum value of $E_1 + E_2$ you can achieve.", "hint": "### Sample Explanation\n\nIn the first test case, the only worker first performs op1 $2$ times and finishes task 1 at time $20$ ( $E_1 = 20$ ). Then they perform op2 $2$ times and finish task 2 at time $80$ ( $E_2 = 80$ ). Therefore, the answer is $20 + 80 = 100$.\n\nIn the second test case, worker #1 performs op1 $5$ times consecutively and finishes task 1 at time $50$ ( $E_1 = 50$ ). Worker #2 performs op2 $7$ times and finishes task 2 at time $112$ ( $E_2 = 112$ ). Therefore, the answer is $50 + 112 = 162$.\n\nThe third test case is similar to the second test case.\n\nIn the fourth test case, worker #2 first performs op2 $6$ times and finishes task 2 at time $18$ ( $E_2 = 18$ ). Meanwhile, worker #3 performs op1 $3$ times and also finishes at time $18$. At this point, one more op1 is still needed, so worker #2 performs the last op1 and finishes task 1 at time $23$ ( $E_1 = 23$ ). Therefore, the answer is $18 + 23 = 41$.\n\n### Constraints\n\nFor $100\\%$ of the testdata, $1 \\le T \\le 7$, $1 \\le N \\le 100$, $1 \\le S_1, S_2 \\le 7$, and $1 \\le T_{1,i}, T_{2,i} \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2010] 任务安排", "background": "", "description": "小 Y 最近遇到了一个棘手的问题。她有两项任务需要完成，其中第一项任务是重复操作 $1$（下文称作 op1）共 $S_1$ 次，第二项任务是重复操作 $2$（下文称作 op2）共 $S_2$ 次。为了完成这些任务，小 Y 雇佣了 $N$ 名工人。其中，第 $i$ 个工人完成 op1 所需时间为 $T_{1,i}$，完成 op2 所需时间为 $T_{2,i}$。每个 op1 和 op2 都只能被一名工人完成，每名工人在任意时刻都只能做一项工作。\n\n所有的工人从第 $0$ 秒开始工作。每当一个工人开始执行一项操作（op1 或 op2），他必须一直执行下去直到完成而不能被打断。我们记第一项任务完成的时间为 $E_1$，第二项任务完成的时间为 $E_2$，你的任务就是安排这些工人的工作，使得 $E_1+E_2$ 最小。", "inputFormat": "输入文件的第一行包含一个整数 $T$，表示输入文件中数据的组数。\n\n每个测试数据的第一行包含三个整数 $N,S_1,S_2$，含义如上文所述。\n\n接下来的 $N$ 行每行包含两个整数 $T_{1,i},T_{2,i}$，分别表示第 $i$ 个工人完成 op1 和 op2 所需的时间。", "outputFormat": "输出文件包含 $T$ 行，每行只有一个整数，表示你找到的 $E_1+E_2$ 的最小值。", "hint": "### 样例说明\n\n第一组数据中，唯一的工人首先执行 $2$ 次 op1，在第 $20$ 秒完成任务一 $(E_1=20)$。然后执行 $2$ 次 op2，在第 $80$ 秒完成任务二 $(E_2=80)$。因此答案为 $20+80=100$。\n\n第二组数据中，工人 $\\#1$ 连续执行 $5$ 次 op1，在第 $50$ 秒完成任务一 $(E_1=50)$，工人 $#2$ 执行 $7$ 次 op2，在第 $112$ 秒完成任务二 $(E_2=112)$。因此答案为 $50+112=162$。\n\n第三组数据和第二组数据类似。\n\n第四组数据中，工人 $\\#2$ 首先连续执行 $6$ 次 op2，在第 $18$ 秒完成任务二 $(E_2=18)$。于此同时，工人 $#3$ 执行 $3$ 次 op1，同样在第 $18$ 秒完成。此时还需要执行一次 op1，因此让工人 $#2$ 去执行最后一次 op1，在第 $23$ 秒完成任务一 $(E_1=23)$ 、因此答案为 $18+23=41$。\n\n\n### 数据范围及约定\n\n对于 $100\\%$ 的数据，$1 \\le T \\le 7$，$1 \\le N \\le 100$，$1 \\le S_1,S_2 \\le 7$，$1 \\le T_{1,i},T_{2,i} \\le 10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P2609", "type": "P", "difficulty": 5, "samples": [["3\n1\n3\n10\n", "1\n2\n3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "高精度", "2012", "各省省选", "递归", "浙江"], "title": "[ZJOI2012] 数列", "background": "", "description": "小白和小蓝在一起上数学课，下课后老师留了一道作业，求下面这个数列的通项公式：\n\n$$a_0=0,a_1=1,a_{2i}=a_i,a_{2i+1}=a_i+a_{i+1}$$\n\n小白作为一个数学爱好者，很快就计算出了这个数列的通项公式。于是，小白告诉小蓝自己已经做出来了，但为了防止小蓝抄作业，小白并不想把公式公布出来。于是小白为了向小蓝证明自己的确做出来了此题以达到其炫耀的目的，想出了一个绝妙的方法：即让小蓝说一个正整数 $n$，小白则说出 $a_n$ 的值，如果当 $n$ 很大时小白仍能很快的说出正确答案，这就说明小白的确得到了公式。但这个方法有一个很大的漏洞：小蓝自己不会做，没法验证小白的答案是否正确。作为小蓝的好友，你能帮帮小蓝吗？", "inputFormat": "输入文件第一行有且只有一个正整数 $T$，表示测试数据的组数。\n\n接下来 $T$ 行，每行一个整数 $n$。", "outputFormat": "对于每组数据：输出一行一个整数代表 $a_n$。", "hint": "- 对于 $20\\%$ 的数据，$1 \\le n \\le 10^8$。 \n- 对于 $50\\%$ 的数据，$1 \\le n \\le 10^{12}$。\n- 对于 $100\\%$ 的数据，$1 \\le T \\le 20$，$1 \\le n \\le 10^{100}$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2012] Sequence", "background": "", "description": "Xiaobai and Xiaolan are in a math class together. After class, the teacher assigns a homework problem: find the general term of the following sequence:\n\n$$a_0=0,a_1=1,a_{2i}=a_i,a_{2i+1}=a_i+a_{i+1}$$\n\nAs a math enthusiast, Xiaobai quickly figures out the general term of this sequence. Xiaobai tells Xiaolan that he has solved it, but to prevent Xiaolan from copying, he does not want to reveal the formula. To show off while proving that he indeed solved it, Xiaobai comes up with a clever method: Xiaolan says a positive integer $n$, and Xiaobai tells the value of $a_n$. If Xiaobai can still quickly give the correct answer when $n$ is very large, it proves that he really has the formula. However, this method has a big flaw: Xiaolan cannot solve the problem himself, so he cannot verify whether Xiaobai’s answer is correct. As Xiaolan’s friend, can you help him?", "inputFormat": "The first line of input contains exactly one positive integer $T$, the number of test cases.\n\nThe next $T$ lines each contain an integer $n$.", "outputFormat": "For each test case, output a single integer representing $a_n$ on one line.", "hint": "- For 20% of the testdata, $1 \\le n \\le 10^8$.\n- For 50% of the testdata, $1 \\le n \\le 10^{12}$.\n- For 100% of the testdata, $1 \\le T \\le 20$, $1 \\le n \\le 10^{100}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2012] 数列", "background": "", "description": "小白和小蓝在一起上数学课，下课后老师留了一道作业，求下面这个数列的通项公式：\n\n$$a_0=0,a_1=1,a_{2i}=a_i,a_{2i+1}=a_i+a_{i+1}$$\n\n小白作为一个数学爱好者，很快就计算出了这个数列的通项公式。于是，小白告诉小蓝自己已经做出来了，但为了防止小蓝抄作业，小白并不想把公式公布出来。于是小白为了向小蓝证明自己的确做出来了此题以达到其炫耀的目的，想出了一个绝妙的方法：即让小蓝说一个正整数 $n$，小白则说出 $a_n$ 的值，如果当 $n$ 很大时小白仍能很快的说出正确答案，这就说明小白的确得到了公式。但这个方法有一个很大的漏洞：小蓝自己不会做，没法验证小白的答案是否正确。作为小蓝的好友，你能帮帮小蓝吗？", "inputFormat": "输入文件第一行有且只有一个正整数 $T$，表示测试数据的组数。\n\n接下来 $T$ 行，每行一个整数 $n$。", "outputFormat": "对于每组数据：输出一行一个整数代表 $a_n$。", "hint": "- 对于 $20\\%$ 的数据，$1 \\le n \\le 10^8$。 \n- 对于 $50\\%$ 的数据，$1 \\le n \\le 10^{12}$。\n- 对于 $100\\%$ 的数据，$1 \\le T \\le 20$，$1 \\le n \\le 10^{100}$。", "locale": "zh-CN"}}}
{"pid": "P2610", "type": "P", "difficulty": 4, "samples": [["6\r\n1 2 4\r\n2 3 4\r\n1 4 5\r\n1 5 6", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "2012", "各省省选", "浙江", "广度优先搜索 BFS", "树形 DP", "树的直径"], "title": "[ZJOI2012] 旅游", "background": "", "description": "到了难得的暑假，为了庆祝小白在数学考试中取得的优异成绩，小蓝决定带小白出去旅游~~\n\n经过一番抉择，两人决定将 T 国作为他们的目的地。T 国的国土可以用一个凸 $n$ 边形来表示，$n$ 个顶点表示 $n$ 个入境/出境口。T 国包含 $n-2$ 个城市，每个城市都是顶点均为 $n$ 边形顶点的三角形（换而言之，**城市组成了关于 T 国的一个三角剖分**）。**两人的旅游路线可以看做是连接 $n$ 个顶点中不相邻两点的线段**。\n\n![](https://cdn.luogu.com.cn/upload/pic/1409.png) \n\n为了能够买到最好的纪念品，小白希望旅游路线上经过的城市尽量多。作为小蓝的好友，你能帮帮小蓝吗？", "inputFormat": "每个输入文件中仅包含一个测试数据。\n\n第一行包含一个正整数 $n$，$n$ 的含义如题目所述。\n\n接下来有 $n-2$ 行，每行包含三个整数 $p,q,r$，表示该城市三角形的三个顶点的编号（T 国的 $n$ 个顶点按顺时间方向从 $1$ 至 $n$ 编号）。", "outputFormat": "输出文件共包含一行，表示最多经过的城市数目。（**一个城市被当做经过当且仅当其与线路有至少两个公共点**）", "hint": "对于 $20\\%$ 的数据，$n\\le 2000$。\n\n对于 $100\\%$ 的数据，$4\\le n \\le 200000$。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2012] Travel", "background": "", "description": "During the rare summer vacation, to celebrate Xiaobai’s excellent performance in the math exam, Xiaolan decides to take Xiaobai on a trip~~\n\nAfter some deliberation, they choose Country T as their destination. The territory of Country T can be represented by a convex $n$-gon, and the $n$ vertices represent $n$ entry/exit ports. Country T contains $n - 2$ cities, each city being a triangle whose vertices are vertices of the $n$-gon (in other words, the cities form a triangulation of Country T). The travel route of the two can be regarded as a line segment connecting two non-adjacent vertices among the $n$ vertices.\n\n![](https://cdn.luogu.com.cn/upload/pic/1409.png)\n\nTo buy the best souvenirs, Xiaobai hopes the route passes through as many cities as possible. As Xiaolan’s friend, can you help?", "inputFormat": "Each input file contains only one test case.\n\nThe first line contains a positive integer $n$, as described above.\n\nThen there are $n - 2$ lines. Each line contains three integers $p, q, r$, indicating the vertex indices of that city’s triangle (the $n$ vertices of Country T are numbered from $1$ to $n$ in clockwise order).", "outputFormat": "Output a single line: the maximum number of cities that can be passed through. (A city is counted as passed if and only if it shares at least two common points with the route.)", "hint": "For $20\\%$ of the testdata, $n \\le 2000$.\n\nFor $100\\%$ of the testdata, $4 \\le n \\le 200000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2012] 旅游", "background": "", "description": "到了难得的暑假，为了庆祝小白在数学考试中取得的优异成绩，小蓝决定带小白出去旅游~~\n\n经过一番抉择，两人决定将 T 国作为他们的目的地。T 国的国土可以用一个凸 $n$ 边形来表示，$n$ 个顶点表示 $n$ 个入境/出境口。T 国包含 $n-2$ 个城市，每个城市都是顶点均为 $n$ 边形顶点的三角形（换而言之，**城市组成了关于 T 国的一个三角剖分**）。**两人的旅游路线可以看做是连接 $n$ 个顶点中不相邻两点的线段**。\n\n![](https://cdn.luogu.com.cn/upload/pic/1409.png) \n\n为了能够买到最好的纪念品，小白希望旅游路线上经过的城市尽量多。作为小蓝的好友，你能帮帮小蓝吗？", "inputFormat": "每个输入文件中仅包含一个测试数据。\n\n第一行包含一个正整数 $n$，$n$ 的含义如题目所述。\n\n接下来有 $n-2$ 行，每行包含三个整数 $p,q,r$，表示该城市三角形的三个顶点的编号（T 国的 $n$ 个顶点按顺时间方向从 $1$ 至 $n$ 编号）。", "outputFormat": "输出文件共包含一行，表示最多经过的城市数目。（**一个城市被当做经过当且仅当其与线路有至少两个公共点**）", "hint": "对于 $20\\%$ 的数据，$n\\le 2000$。\n\n对于 $100\\%$ 的数据，$4\\le n \\le 200000$。", "locale": "zh-CN"}}}
{"pid": "P2611", "type": "P", "difficulty": 6, "samples": [["5 5 4\n1 2\n2 3\n3 5\n4 1\n", "139"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "各省省选", "平衡树", "浙江", "深度优先搜索 DFS", "栈"], "title": "[ZJOI2012] 小蓝的好友", "background": "终于到达了这次选拔赛的最后一题，想必你已经厌倦了小蓝和小白的故事。\n\n为了回馈各位比赛选手，此题的主角是贯穿这次比赛的关键人物——小蓝的好友。\n\n在帮小蓝确定了旅游路线后，小蓝的好友也不会浪费这个难得的暑假。\n\n与小蓝不同，小蓝的好友并不想将时间花在旅游上，而是盯上了最近发行的即时战略游戏——SangoCraft。\n\n但在前往通关之路的道路上，一个小游戏挡住了小蓝的好友的步伐。", "description": "\n“国家的战争其本质是抢夺资源的战争”是整款游戏的核心理念，这个小游戏也不例外。\n\n简单来说，用户需要在一块 $R\\times C$ 的长方形土地上选出一块子矩形。\n\n而系统随机生成了 $N$ 个资源点，第 $i$ 个资源点的坐标为 $(x_i,y_i)$。\n\n位于用户所选的长方形土地上的资源点越多，给予用户的奖励也越多。\n\n悲剧的是，小蓝的好友虽然拥有着极其优秀的能力，但同时也有着极差的 RP，小蓝的好友所选的区域总是没有一个资源点。\n\n终于有一天，小蓝的好友决定投诉这款游戏的制造厂商，为了搜集证据，小蓝的好友想算出至少包含一个资源点的区域的数量。\n\n具体的说，你需要计算有多少个四元组 $(LB,DB,RB,UB)$ 满足 $1\\le LB\\le RB\\le R,1\\le DB\\le UB\\le C$ ，且存在一个 $i$ 使得 $LB\\le x_i\\le RB,DB\\le y_i\\le UB$ 均成立。\n\n作为小蓝的好友，这自然是你分内之事。", "inputFormat": "第一行三个正整数 $R,C,N$。\n\n接下来有 $N$ 行，每行包含两个整数 $x_i,y_i$，表示第 $i$ 个资源点的坐标。", "outputFormat": "一行一个整数，表示至少包含一个资源点的区域的数量。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，$N\\le 50$。\n- 对于 $40\\%$ 的数据，$N\\le 2\\times 10^3$。\n- 对于 $100\\%$ 的数据，$1\\le R,C\\le 4\\times 10^4$，$1\\le N\\le 10^5$，题目保证资源点的位置两两不同，且位置为随机生成。", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2012] Xiao Lan's Friend", "background": "At last we have reached the final problem of this selection contest; you are probably already tired of the stories of Xiao Lan and Xiao Bai.\n\nTo thank all contestants, the protagonist of this problem is the key figure throughout this contest—Xiao Lan's friend.\n\nAfter helping Xiao Lan determine the travel route, Xiao Lan's friend is not going to waste this rare summer vacation either.\n\nUnlike Xiao Lan, Xiao Lan's friend does not want to spend time traveling, but instead has set their sights on the newly released real-time strategy game—SangoCraft.\n\nHowever, on the road to beating the game, a mini-game blocked Xiao Lan's friend's way.", "description": "“The essence of war between nations is the struggle to seize resources” is the core concept of the entire game, and this mini-game is no exception.\n\nSimply put, the player needs to choose a sub-rectangle on an $R\\times C$ rectangular land.\n\nThe system randomly generates $N$ resource points; the coordinates of the $i$-th resource point are $(x_i,y_i)$.\n\nThe more resource points lie within the player's chosen rectangular land, the greater the reward.\n\nTragically, although Xiao Lan's friend is exceptionally capable, they also have terrible RP, and the region they choose always contains no resource points.\n\nOne day, Xiao Lan's friend finally decided to complain to the game's developer. To collect evidence, they want to count how many regions contain at least one resource point.\n\nSpecifically, you need to compute how many four-tuples $(LB,DB,RB,UB)$ satisfy $1\\le LB\\le RB\\le R,1\\le DB\\le UB\\le C$, and there exists an $i$ such that $LB\\le x_i\\le RB,DB\\le y_i\\le UB$ are both true.\n\nAs Xiao Lan's friend, this is naturally your duty.", "inputFormat": "The first line contains three positive integers $R,C,N$.\n\nThen there are $N$ lines; each line contains two integers $x_i,y_i$, representing the coordinates of the $i$-th resource point.", "outputFormat": "Output a single integer on one line, the number of regions that contain at least one resource point.", "hint": "- Constraints:\n  - For 20% of the testdata, $N\\le 50$.\n  - For 40% of the testdata, $N\\le 2\\times 10^3$.\n  - For 100% of the testdata, $1\\le R,C\\le 4\\times 10^4$, $1\\le N\\le 10^5$; resource point positions are pairwise distinct and are generated randomly.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2012] 小蓝的好友", "background": "终于到达了这次选拔赛的最后一题，想必你已经厌倦了小蓝和小白的故事。\n\n为了回馈各位比赛选手，此题的主角是贯穿这次比赛的关键人物——小蓝的好友。\n\n在帮小蓝确定了旅游路线后，小蓝的好友也不会浪费这个难得的暑假。\n\n与小蓝不同，小蓝的好友并不想将时间花在旅游上，而是盯上了最近发行的即时战略游戏——SangoCraft。\n\n但在前往通关之路的道路上，一个小游戏挡住了小蓝的好友的步伐。", "description": "\n“国家的战争其本质是抢夺资源的战争”是整款游戏的核心理念，这个小游戏也不例外。\n\n简单来说，用户需要在一块 $R\\times C$ 的长方形土地上选出一块子矩形。\n\n而系统随机生成了 $N$ 个资源点，第 $i$ 个资源点的坐标为 $(x_i,y_i)$。\n\n位于用户所选的长方形土地上的资源点越多，给予用户的奖励也越多。\n\n悲剧的是，小蓝的好友虽然拥有着极其优秀的能力，但同时也有着极差的 RP，小蓝的好友所选的区域总是没有一个资源点。\n\n终于有一天，小蓝的好友决定投诉这款游戏的制造厂商，为了搜集证据，小蓝的好友想算出至少包含一个资源点的区域的数量。\n\n具体的说，你需要计算有多少个四元组 $(LB,DB,RB,UB)$ 满足 $1\\le LB\\le RB\\le R,1\\le DB\\le UB\\le C$ ，且存在一个 $i$ 使得 $LB\\le x_i\\le RB,DB\\le y_i\\le UB$ 均成立。\n\n作为小蓝的好友，这自然是你分内之事。", "inputFormat": "第一行三个正整数 $R,C,N$。\n\n接下来有 $N$ 行，每行包含两个整数 $x_i,y_i$，表示第 $i$ 个资源点的坐标。", "outputFormat": "一行一个整数，表示至少包含一个资源点的区域的数量。", "hint": "#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，$N\\le 50$。\n- 对于 $40\\%$ 的数据，$N\\le 2\\times 10^3$。\n- 对于 $100\\%$ 的数据，$1\\le R,C\\le 4\\times 10^4$，$1\\le N\\le 10^5$，题目保证资源点的位置两两不同，且位置为随机生成。", "locale": "zh-CN"}}}
{"pid": "P2612", "type": "P", "difficulty": 7, "samples": [["3 3 3", "0.667"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2012", "各省省选", "浙江", "组合数学"], "title": "[ZJOI2012] 波浪", "background": null, "description": "阿米巴和小强是好朋友。\n\n阿米巴和小强在大海旁边看海水的波涛。小强第一次面对如此汹涌的海潮，他兴奋地叫个不停。而阿米巴则很淡定，他回想起曾经的那些日子，事业的起伏，情感的挫折……总之今天的风浪和曾经经历的那些风雨比起来，简直什么都不算。\n\n于是，这对好朋友不可避免地产生了分歧。为了论证自己的观点，小强建立了一个模型。他海面抽象成一个 $1$ 到 $N$ 的排列 $P_{1\\ldots N}$。定义波动强度等于相邻两项的差的绝对值的和，即：\n\n$$L = | P_2 - P_1 | + | P_3 - P_2 | +\\ldots + | P_N - P_{N-1} |$$\n\n给你一个 $N$ 和 $M$，问：随机一个 $1\\ldots N$ 的排列，它的波动强度不小于 $M$ 的概率有多大？\n\n答案请保留小数点后 $K$ 位输出，四舍五入。", "inputFormat": "第一行包含三个整数 $N, M$ 和 $K$，分别表示排列的长度，波动强度，输出位数。", "outputFormat": "第一行包含一个小数点后 $K$ 位的实数。", "hint": "$N = 3$ 的排列有 $6$ 个：$123, 132, 213, 231, 312, 321$；他们的波动强度分别为 $2, 3, 3, 3, 3, 2$。所以，波动强度不小于 $3$ 的概率是 $\\frac 46$，即 $0.667$。\n\n你也可以通过下面的代码来验证这个概率：\n\n```cpp\nint a[3]={0,1,2},s=0,n=3;\nfor (int i=0;i<1000000;i++){\n  random_shuffle(a,a+n);\n  int t=0;\n  for (int j=0;j<n-1;j++) t+=abs(a[j+1]-a[j]); \n  if (t>=3) s++;\n}\nprintf(\"%.3f\\n\",s/1000000.0);\n```\n### 【数据规模】\n\n对于 $100\\%$ 的数据，$0 \\leq M < 2^{31}$。\n\n**注意：请注意本题不存在一个测试点使得 $N,K$ 均达到最大值。**\n\n| 测试点编号 | $N \\le$ | $K \\leq$|\n|:-:|:-:|:-:|\n| $1 \\sim 3$ | $10$ | $30$ |\n| $4 \\sim 6$ | $100$ | $3$ |\n| $7 \\sim 9$ | $100$ | $8$ |\n| $10$ | $50$ | $30$ |", "locale": "zh-CN", "translations": {"en": {"title": "[ZJOI2012] Waves", "background": "", "description": "Amoeba and Xiaoqiang are good friends.\n\nThey are watching the waves by the sea. It is Xiaoqiang’s first time facing such surging tides, and he keeps shouting with excitement. Amoeba, however, remains calm, recalling the ups and downs of his career and the setbacks in his relationships... In short, compared with the storms he has experienced, today’s waves are nothing.\n\nThus, a disagreement between the two friends is inevitable. To support his view, Xiaoqiang builds a model. He abstracts the sea surface as a permutation $P_{1 \\ldots N}$ of $1$ to $N$. Define the wave intensity as the sum of the absolute differences between adjacent elements, that is:\n$$L = | P_2 - P_1 | + | P_3 - P_2 | + \\ldots + | P_N - P_{N-1} |.$$\n\nGiven $N$ and $M$, what is the probability that a uniformly random permutation of $1 \\ldots N$ has wave intensity at least $M$?\n\nOutput the answer rounded to $K$ digits after the decimal point.", "inputFormat": "The first line contains three integers $N, M$ and $K$, denoting the length of the permutation, the wave intensity threshold, and the number of digits to output, respectively.", "outputFormat": "Output one real number with exactly $K$ digits after the decimal point.", "hint": "For $N = 3$, there are $6$ permutations: $123, 132, 213, 231, 312, 321$; their wave intensities are $2, 3, 3, 3, 3, 2$. Therefore, the probability that the wave intensity is at least $3$ is $\\frac 46$, i.e., $0.667$.\n\nYou can also verify this probability with the following code:\n\n```cpp\nint a[3]={0,1,2},s=0,n=3;\nfor (int i=0;i<1000000;i++){\nrandom_shuffle(a,a+n);\nint t=0;\nfor (int j=0;j<n-1;j++) t+=abs(a[j+1]-a[j]); \nif (t>=3) s++;\n}\nprintf(\"%.3f\\n\",s/1000000.0);\n```\n\nConstraints\n\nFor $100\\%$ of the testdata, $0 \\leq M \\leq 2147483647$.\n\nPlease note that there is no single test point where both $N$ and $K$ reach their maximum values.\n\n| Test set index | $N \\le$ | $K \\le$ |\n|:-:|:-:|:-:|\n| $1 \\sim 3$ | $10$ | $30$ |\n| $4 \\sim 6$ | $100$ | $3$ |\n| $7 \\sim 9$ | $100$ | $8$ |\n| $10$ | $50$ | $30$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[ZJOI2012] 波浪", "background": null, "description": "阿米巴和小强是好朋友。\n\n阿米巴和小强在大海旁边看海水的波涛。小强第一次面对如此汹涌的海潮，他兴奋地叫个不停。而阿米巴则很淡定，他回想起曾经的那些日子，事业的起伏，情感的挫折……总之今天的风浪和曾经经历的那些风雨比起来，简直什么都不算。\n\n于是，这对好朋友不可避免地产生了分歧。为了论证自己的观点，小强建立了一个模型。他海面抽象成一个 $1$ 到 $N$ 的排列 $P_{1\\ldots N}$。定义波动强度等于相邻两项的差的绝对值的和，即：\n\n$$L = | P_2 - P_1 | + | P_3 - P_2 | +\\ldots + | P_N - P_{N-1} |$$\n\n给你一个 $N$ 和 $M$，问：随机一个 $1\\ldots N$ 的排列，它的波动强度不小于 $M$ 的概率有多大？\n\n答案请保留小数点后 $K$ 位输出，四舍五入。", "inputFormat": "第一行包含三个整数 $N, M$ 和 $K$，分别表示排列的长度，波动强度，输出位数。", "outputFormat": "第一行包含一个小数点后 $K$ 位的实数。", "hint": "$N = 3$ 的排列有 $6$ 个：$123, 132, 213, 231, 312, 321$；他们的波动强度分别为 $2, 3, 3, 3, 3, 2$。所以，波动强度不小于 $3$ 的概率是 $\\frac 46$，即 $0.667$。\n\n你也可以通过下面的代码来验证这个概率：\n\n```cpp\nint a[3]={0,1,2},s=0,n=3;\nfor (int i=0;i<1000000;i++){\n  random_shuffle(a,a+n);\n  int t=0;\n  for (int j=0;j<n-1;j++) t+=abs(a[j+1]-a[j]); \n  if (t>=3) s++;\n}\nprintf(\"%.3f\\n\",s/1000000.0);\n```\n### 【数据规模】\n\n对于 $100\\%$ 的数据，$0 \\leq M < 2^{31}$。\n\n**注意：请注意本题不存在一个测试点使得 $N,K$ 均达到最大值。**\n\n| 测试点编号 | $N \\le$ | $K \\leq$|\n|:-:|:-:|:-:|\n| $1 \\sim 3$ | $10$ | $30$ |\n| $4 \\sim 6$ | $100$ | $3$ |\n| $7 \\sim 9$ | $100$ | $8$ |\n| $10$ | $50$ | $30$ |", "locale": "zh-CN"}}}
{"pid": "P2613", "type": "P", "difficulty": 4, "samples": [["233\n666\n", "18595654\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "扩展欧几里德算法", "模板题"], "title": "【模板】有理数取余", "background": "", "description": "给出一个有理数 $c=\\frac{a}{b}$，求 $c \\bmod 19260817$ 的值。\n\n这个值被定义为 $bx\\equiv a\\pmod{19260817}$ 的解。", "inputFormat": "一共两行。\n\n第一行，一个整数 $a$。  \n第二行，一个整数 $b$。  ", "outputFormat": "一个整数，代表求余后的结果。如果无解，输出 `Angry!`。", "hint": "对于所有数据，保证 $0\\leq a \\leq 10^{10001}$，$1 \\leq b \\leq 10^{10001}$，且 $a, b$ 不同时是 $19260817$ 的倍数。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Rational Number Modulo", "background": "", "description": "Given a rational number $c=\\frac{a}{b}$, compute $c \\bmod 19260817$.\n\nThis value is defined as the solution to $bx\\equiv a\\pmod{19260817}$.", "inputFormat": "There are two lines in total.\n\nThe first line contains an integer $a$.  \nThe second line contains an integer $b$.", "outputFormat": "Output a single integer, representing the result after taking modulo. If there is no solution, output `Angry!`.", "hint": "For all testdata, it is guaranteed that $0\\leq a \\leq 10^{10001}$, $1 \\leq b \\leq 10^{10001}$, and $a, b$ are not both multiples of $19260817$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】有理数取余", "background": "", "description": "给出一个有理数 $c=\\frac{a}{b}$，求 $c \\bmod 19260817$ 的值。\n\n这个值被定义为 $bx\\equiv a\\pmod{19260817}$ 的解。", "inputFormat": "一共两行。\n\n第一行，一个整数 $a$。  \n第二行，一个整数 $b$。  ", "outputFormat": "一个整数，代表求余后的结果。如果无解，输出 `Angry!`。", "hint": "对于所有数据，保证 $0\\leq a \\leq 10^{10001}$，$1 \\leq b \\leq 10^{10001}$，且 $a, b$ 不同时是 $19260817$ 的倍数。", "locale": "zh-CN"}}}
{"pid": "P2614", "type": "P", "difficulty": 2, "samples": [["2 60\n3345 5432 1123 322-\n3345 5432 1123 211-", "32\n"], ["5 120\n3(1.(3))55 8(7.(6))65 655(3.(1)) (4.(4))32- \n3(1.(2))35 8(7.(6))65 655(4.(3)) (2.(3))21- \n2.(3)44 6(6.(6))(5.(4))3 3.(5)88 (9.(8)7.(6))5-\n=.(=)(9.(8))7 9.(8)(7.(6))5  8(856543) (2.(3))43- \n=.(=)(9.(8))7 9.(8)(7.(6))5  8(857654) (3.(4))21- ", "40\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "2015", "洛谷原创", "洛谷月赛"], "title": "计算器弹琴", "background": "小 A 发现了一个计算器的另一个隐藏功能——弹琴。\n\n![](bilibili:av2205500)", "description": "在计算器的某个模式里，如果按上一个键，比如说 `1`，就会发出中音 `Do`。\n\n这里给出按键音高表。\n\n```plain\n+ 低音Fa\n< 低音So\n* 低音La\n/ 低音Xi\n1 中音Do\n2 中音Re\n3 中音Mi\n4 中音Fa\n5 中音So\n6 中音La\n7 高音Xi\n8 高音Do\n9 高音Re\n= 高音Mi\n% 高音Fa\nC 高音So\nM 高音La\n```\n现在小 A 搞到了一份乐谱——我们称为计算器谱，一种变形的简谱。\n\n时值（也就是按的时间长度）是这么记录的，例如：\n\n`1` 是四分音符，占 $1$ 拍。\n\n`1-` 是二分音符，占 $2$ 拍。\n\n`1---` 是全音符，占 $4$ 拍。\n\n对于小于四分音符的音符，我们用嵌套括号表示，例如：\n\n`(1(34(56))2)`\n\n`1` 和 `2` 在一层括号中，是八分音符，占 $0.5$ 拍。\n\n`3` 和 `4` 在两层括号中，是 $16$ 分音符，占 $0.25$ 拍。\n\n`5` 和 `6` 在三层括号中，是 $32$ 分音符，占 $\\dfrac{1}{8}$ 拍。\n\n数据中最多只会出现 $32$ 分音符，没有更短的音符了。\n\n括号中不会出现 `-` 这个符号。\n\n在一个音符后面添加一个附点即 `.` 表示这个音符延长1/2倍。\n\n例如，`1-.` 是 $3$ 拍，`1.` 是 $1.5$ 拍，`(3.(45.))` 中 `3` 是 $\\dfrac{3}{4}$ 拍，`4` 是 $\\dfrac{1}{4}$ 拍，`5` 是 $\\dfrac{3}{8}$ 拍。\n\n附点不会连续添加两个或以上。全音符不会有附点。\n\n不考虑其他的乐理符号。\n\n另外，整个乐谱会给出一个整数 $T$，为每分钟的拍数。\n\n为了美观，乐谱可以随便换行、添加空格。输入时可以忽略。\n\n现在小 A 想知道，按完这个谱子，需要多少秒。", "inputFormat": "第一行，两个整数 $n,T$，表示谱子行数以及每分钟的拍数。\n\n接下来 $n$ 行，给出乐谱。", "outputFormat": "一个整数，表示演奏需要花费的时间，单位秒，如果是小数则向下取整到整数。", "hint": "### 样例解释\n\n对于第一组样例，有 $28$ 个四分音符，有 $2$ 个二分音符，总共 $32$ 拍，每分钟 $60$ 拍，则总共需要 $32$ 秒。\n\n### 数据范围\n\n对于 $40\\%$ 的数据，不会出现 `(`、`)`、`.` 字符。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 100,\\ 50 \\le T \\le 200$，每行不超过 $100$ 个字符。", "locale": "zh-CN", "translations": {"en": {"title": "Playing Piano on a Calculator", "background": "Xiao A discovered another hidden feature of a calculator — playing piano.\n\n![](bilibili:av2205500)", "description": "In a certain mode of the calculator, pressing a key, for example `1`, will produce the middle pitch `Do`.\n\nHere is the key-to-pitch table.\n\n```plain\n+ 低音Fa\n< 低音So\n* 低音La\n/ 低音Xi\n1 中音Do\n2 中音Re\n3 中音Mi\n4 中音Fa\n5 中音So\n6 中音La\n7 高音Xi\n8 高音Do\n9 高音Re\n= 高音Mi\n% 高音Fa\nC 高音So\nM 高音La\n```\nNow Xiao A has obtained a piece of sheet music — we call it calculator notation, a variant of numbered musical notation (jianpu).\n\nDurations (i.e., how long you press) are recorded as follows, for example:\n\n`1` is a quarter note, taking $1$ beat.\n\n`1-` is a half note, taking $2$ beats.\n\n`1---` is a whole note, taking $4$ beats.\n\nFor notes shorter than a quarter note, we use nested parentheses, for example:\n\n`(1(34(56))2)`\n\n`1` and `2` are inside one layer of parentheses, so they are eighth notes, taking $0.5$ beat.\n\n`3` and `4` are inside two layers of parentheses, so they are sixteenth notes, taking $0.25$ beat.\n\n`5` and `6` are inside three layers of parentheses, so they are thirty-second notes, taking $\\dfrac{1}{8}$ beat.\n\nAt most thirty-second notes will appear in the testdata; there are no shorter notes.\n\nThe symbol `-` will not appear inside parentheses.\n\nAdding a dot `.` after a note means the note is extended by $1/2$ of its original duration.\n\nFor example, `1-.` is $3$ beats, `1.` is $1.5$ beats, and in `(3.(45.))`, `3` is $\\dfrac{3}{4}$ beat, `4` is $\\dfrac{1}{4}$ beat, and `5` is $\\dfrac{3}{8}$ beat.\n\nThere will not be two or more consecutive dots. A whole note will not be dotted.\n\nIgnore other musical symbols.\n\nIn addition, the entire score provides an integer $T$, the number of beats per minute.\n\nFor readability, the score may contain arbitrary line breaks and spaces. They can be ignored when reading the input.\n\nNow Xiao A wants to know how many seconds it takes to finish playing this score.", "inputFormat": "The first line contains two integers $n, T$, the number of lines of the score and the beats per minute.\n\nThe next $n$ lines contain the score.", "outputFormat": "Output a single integer: the total time in seconds needed to perform the score. If the exact time is fractional, round down to an integer.", "hint": "- Sample Explanation\n\nFor the first sample, there are $28$ quarter notes and $2$ half notes, totaling $32$ beats. With $60$ beats per minute, the total time is $32$ seconds.\n\n- Constraints\n\nFor $40\\%$ of the testdata, the characters `(`, `)`, and `.` do not appear.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 100,\\ 50 \\le T \\le 200$, and each line contains at most $100$ characters.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "计算器弹琴", "background": "小 A 发现了一个计算器的另一个隐藏功能——弹琴。\n\n![](bilibili:av2205500)", "description": "在计算器的某个模式里，如果按上一个键，比如说 `1`，就会发出中音 `Do`。\n\n这里给出按键音高表。\n\n```plain\n+ 低音Fa\n< 低音So\n* 低音La\n/ 低音Xi\n1 中音Do\n2 中音Re\n3 中音Mi\n4 中音Fa\n5 中音So\n6 中音La\n7 高音Xi\n8 高音Do\n9 高音Re\n= 高音Mi\n% 高音Fa\nC 高音So\nM 高音La\n```\n现在小 A 搞到了一份乐谱——我们称为计算器谱，一种变形的简谱。\n\n时值（也就是按的时间长度）是这么记录的，例如：\n\n`1` 是四分音符，占 $1$ 拍。\n\n`1-` 是二分音符，占 $2$ 拍。\n\n`1---` 是全音符，占 $4$ 拍。\n\n对于小于四分音符的音符，我们用嵌套括号表示，例如：\n\n`(1(34(56))2)`\n\n`1` 和 `2` 在一层括号中，是八分音符，占 $0.5$ 拍。\n\n`3` 和 `4` 在两层括号中，是 $16$ 分音符，占 $0.25$ 拍。\n\n`5` 和 `6` 在三层括号中，是 $32$ 分音符，占 $\\dfrac{1}{8}$ 拍。\n\n数据中最多只会出现 $32$ 分音符，没有更短的音符了。\n\n括号中不会出现 `-` 这个符号。\n\n在一个音符后面添加一个附点即 `.` 表示这个音符延长1/2倍。\n\n例如，`1-.` 是 $3$ 拍，`1.` 是 $1.5$ 拍，`(3.(45.))` 中 `3` 是 $\\dfrac{3}{4}$ 拍，`4` 是 $\\dfrac{1}{4}$ 拍，`5` 是 $\\dfrac{3}{8}$ 拍。\n\n附点不会连续添加两个或以上。全音符不会有附点。\n\n不考虑其他的乐理符号。\n\n另外，整个乐谱会给出一个整数 $T$，为每分钟的拍数。\n\n为了美观，乐谱可以随便换行、添加空格。输入时可以忽略。\n\n现在小 A 想知道，按完这个谱子，需要多少秒。", "inputFormat": "第一行，两个整数 $n,T$，表示谱子行数以及每分钟的拍数。\n\n接下来 $n$ 行，给出乐谱。", "outputFormat": "一个整数，表示演奏需要花费的时间，单位秒，如果是小数则向下取整到整数。", "hint": "### 样例解释\n\n对于第一组样例，有 $28$ 个四分音符，有 $2$ 个二分音符，总共 $32$ 拍，每分钟 $60$ 拍，则总共需要 $32$ 秒。\n\n### 数据范围\n\n对于 $40\\%$ 的数据，不会出现 `(`、`)`、`.` 字符。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 100,\\ 50 \\le T \\le 200$，每行不超过 $100$ 个字符。", "locale": "zh-CN"}}}
{"pid": "P2615", "type": "P", "difficulty": 2, "samples": [["3\n", "8 1 6\n3 5 7\n4 9 2"], ["25\n", "327 354 381 408 435 462 489 516 543 570 597 624 1 28 55 82 109 136 163 190 217 244 271 298 325\n353 380 407 434 461 488 515 542 569 596 623 25 27 54 81 108 135 162 189 216 243 270 297 324 326\n379 406 433 460 487 514 541 568 595 622 24 26 53 80 107 134 161 188 215 242 269 296 323 350 352\n405 432 459 486 513 540 567 594 621 23 50 52 79 106 133 160 187 214 241 268 295 322 349 351 378\n431 458 485 512 539 566 593 620 22 49 51 78 105 132 159 186 213 240 267 294 321 348 375 377 404\n457 484 511 538 565 592 619 21 48 75 77 104 131 158 185 212 239 266 293 320 347 374 376 403 430\n483 510 537 564 591 618 20 47 74 76 103 130 157 184 211 238 265 292 319 346 373 400 402 429 456\n509 536 563 590 617 19 46 73 100 102 129 156 183 210 237 264 291 318 345 372 399 401 428 455 482\n535 562 589 616 18 45 72 99 101 128 155 182 209 236 263 290 317 344 371 398 425 427 454 481 508\n561 588 615 17 44 71 98 125 127 154 181 208 235 262 289 316 343 370 397 424 426 453 480 507 534\n587 614 16 43 70 97 124 126 153 180 207 234 261 288 315 342 369 396 423 450 452 479 506 533 560\n613 15 42 69 96 123 150 152 179 206 233 260 287 314 341 368 395 422 449 451 478 505 532 559 586\n14 41 68 95 122 149 151 178 205 232 259 286 313 340 367 394 421 448 475 477 504 531 558 585 612\n40 67 94 121 148 175 177 204 231 258 285 312 339 366 393 420 447 474 476 503 530 557 584 611 13\n66 93 120 147 174 176 203 230 257 284 311 338 365 392 419 446 473 500 502 529 556 583 610 12 39\n92 119 146 173 200 202 229 256 283 310 337 364 391 418 445 472 499 501 528 555 582 609 11 38 65\n118 145 172 199 201 228 255 282 309 336 363 390 417 444 471 498 525 527 554 581 608 10 37 64 91\n144 171 198 225 227 254 281 308 335 362 389 416 443 470 497 524 526 553 580 607 9 36 63 90 117\n170 197 224 226 253 280 307 334 361 388 415 442 469 496 523 550 552 579 606 8 35 62 89 116 143\n196 223 250 252 279 306 333 360 387 414 441 468 495 522 549 551 578 605 7 34 61 88 115 142 169\n222 249 251 278 305 332 359 386 413 440 467 494 521 548 575 577 604 6 33 60 87 114 141 168 195\n248 275 277 304 331 358 385 412 439 466 493 520 547 574 576 603 5 32 59 86 113 140 167 194 221\n274 276 303 330 357 384 411 438 465 492 519 546 573 600 602 4 31 58 85 112 139 166 193 220 247\n300 302 329 356 383 410 437 464 491 518 545 572 599 601 3 30 57 84 111 138 165 192 219 246 273\n301 328 355 382 409 436 463 490 517 544 571 598 625 2 29 56 83 110 137 164 191 218 245 272 299\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2015", "NOIP 提高组", "枚举"], "title": "[NOIP 2015 提高组] 神奇的幻方", "background": "NOIp2015 提高组 Day1T1\n", "description": "幻方是一种很神奇的 $N\\times N$ 矩阵：它由数字 $1,2,3,\\cdots \\cdots ,N \\times N$ 构成，且每行、每列及两条对角线上的数字之和都相同。\n\n当 $N$ 为奇数时，我们可以通过下方法构建一个幻方：\n\n首先将 $1$ 写在第一行的中间。\n\n之后，按如下方式从小到大依次填写每个数 $K \\ (K=2,3,\\cdots,N \\times N)$ ：\n\n1. 若 $(K-1)$ 在第一行但不在最后一列，则将 $K$ 填在最后一行， $(K-1)$ 所在列的右一列；\n2. 若 $(K-1)$ 在最后一列但不在第一行，则将 $K$ 填在第一列， $(K-1)$ 所在行的上一行；\n3. 若 $(K-1)$ 在第一行最后一列，则将 $K$ 填在 $(K-1)$ 的正下方；\n4. 若 $(K-1)$ 既不在第一行，也不在最后一列，如果 $(K-1)$ 的右上方还未填数，则将 $K$ 填在 $(K-1)$ 的右上方，否则将 $K$ 填在 $(K-1)$ 的正下方。\n\n现给定 $N$ ，请按上述方法构造 $N \\times N$ 的幻方。", "inputFormat": "一个正整数 $N$，即幻方的大小。", "outputFormat": "共 $N$ 行，每行 $N$ 个整数，即按上述方法构造出的 $N \\times N$ 的幻方，相邻两个整数之间用单空格隔开。", "hint": "对于 $100\\%$ 的数据，对于全部数据， $1 \\leq N \\leq 39$ 且 $N$ 为奇数。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2015 Senior] The Magical Magic Square", "background": "NOIP 2015 Senior Day 1 T1.", "description": "A magic square is a very special $N \\times N$ matrix: it consists of the numbers $1,2,3,\\cdots,N \\times N$, and the sums of every row, every column, and the two diagonals are all the same.\n\nWhen $N$ is odd, we can construct a magic square by the following method:\n\nFirst, write $1$ in the middle of the first row.\n\nThen fill each number $K$ in increasing order ($K=2,3,\\cdots,N \\times N$) as follows:\n\n1. If $(K-1)$ is in the first row but not in the last column, then place $K$ in the last row, in the column immediately to the right of the column of $(K-1)$.\n2. If $(K-1)$ is in the last column but not in the first row, then place $K$ in the first column, in the row immediately above the row of $(K-1)$.\n3. If $(K-1)$ is in the first row and the last column, then place $K$ directly below $(K-1)$.\n4. If $(K-1)$ is neither in the first row nor in the last column, then if the cell to the upper-right of $(K-1)$ is still empty, place $K$ there; otherwise, place $K$ directly below $(K-1)$.\n\nGiven $N$, construct the $N \\times N$ magic square using the method above.", "inputFormat": "A positive integer $N$, the size of the magic square.", "outputFormat": "Output $N$ lines, each containing $N$ integers. Adjacent integers are separated by a single space. The output is the $N \\times N$ magic square constructed by the method above.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\leq N \\leq 39$ and $N$ is odd.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2015 提高组] 神奇的幻方", "background": "NOIp2015 提高组 Day1T1\n", "description": "幻方是一种很神奇的 $N\\times N$ 矩阵：它由数字 $1,2,3,\\cdots \\cdots ,N \\times N$ 构成，且每行、每列及两条对角线上的数字之和都相同。\n\n当 $N$ 为奇数时，我们可以通过下方法构建一个幻方：\n\n首先将 $1$ 写在第一行的中间。\n\n之后，按如下方式从小到大依次填写每个数 $K \\ (K=2,3,\\cdots,N \\times N)$ ：\n\n1. 若 $(K-1)$ 在第一行但不在最后一列，则将 $K$ 填在最后一行， $(K-1)$ 所在列的右一列；\n2. 若 $(K-1)$ 在最后一列但不在第一行，则将 $K$ 填在第一列， $(K-1)$ 所在行的上一行；\n3. 若 $(K-1)$ 在第一行最后一列，则将 $K$ 填在 $(K-1)$ 的正下方；\n4. 若 $(K-1)$ 既不在第一行，也不在最后一列，如果 $(K-1)$ 的右上方还未填数，则将 $K$ 填在 $(K-1)$ 的右上方，否则将 $K$ 填在 $(K-1)$ 的正下方。\n\n现给定 $N$ ，请按上述方法构造 $N \\times N$ 的幻方。", "inputFormat": "一个正整数 $N$，即幻方的大小。", "outputFormat": "共 $N$ 行，每行 $N$ 个整数，即按上述方法构造出的 $N \\times N$ 的幻方，相邻两个整数之间用单空格隔开。", "hint": "对于 $100\\%$ 的数据，对于全部数据， $1 \\leq N \\leq 39$ 且 $N$ 为奇数。\n\n", "locale": "zh-CN"}}}
{"pid": "P2616", "type": "P", "difficulty": 2, "samples": [["2 5 3\n3 1 2\n4 1 2\n1 1 1", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "2010", "USACO", "排序"], "title": "[USACO10JAN] Buying Feed, II S", "background": null, "description": "FJ 开车来到镇上，他要带 $K$ 吨饲料回家。运送饲料是需要花钱的，如果他的车上有 $X$ 吨饲料，开车 $D$ 公里就需要 $D×X$ 元。FJ 可以从 $N$ 家商店购买饲料，所有商店都在一个坐标轴上，第 $i$ 家店的位置是 $X_i$，饲料的售价为每吨 $C_i$ 元，库存为 $F_i$。\n\n这个镇上有 $N(1 \\le N \\le 100)$ 家商店（编号为 $1 \\sim N$）售卖饲料，所有商店都在一个长度为 $E(1 \\le E \\le 350)$ 的 $X$ 轴上。第 $i$ 个商店位于数轴上 $X_i$ 的位置，最多可以售卖给 FJ $F_i(1 \\le F_i \\le 100)$ 吨饲料，花费为 $C_i(1 \\le C_i \\le 10^6)$ 元每吨。奇妙的是，$X$ 轴上同一个坐标可能不只有一家商店。\n\nFJ 从坐标为 $0$ 的地方出发并且只能向前走，直到到达坐标为 $E$ 的地方，并且需要买到 $K$ 吨饲料。他可以在沿途任意一家商店停下来买饲料。\n\n请你求出 FJ 购买并运输 $K$ 吨饲料的最小花费是多少。", "inputFormat": "- 第一行：三个整数 $K$，$ E $ 和 $ N $，$ 1\\leq K \\leq 100 $，$ 1\\leq E \\leq 350 $，$ 1\\leq N \\leq 100 $；\n- 第二行到第 $ N + 1 $ 行：第 $ i + 1 $ 行有三个整数 $ X_i $，$ F_i $ 和 $ C_i $，$0 < X_i < E $，$1\\leq F_i \\leq 100 $，$1\\leq C_i \\leq 10^6$。", "outputFormat": "一个整数，表示购买并运送饲料的最小花费。", "hint": "在离家较近的两家商店里各购买一吨饲料，则花费路上的钱是 $1+2=3$，花在店里的钱是 $2+2=4$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO10JAN] Buying Feed, II S", "background": null, "description": "Farmer John needs to travel to town to pick up $K (1 \\le K \\le 100)$ pounds of feed. Driving D miles with $K$ pounds of feed in his truck costs $D*K$ cents.\n\nThe county feed lot has $N (1 \\le N \\le 100)$ stores (conveniently numbered $1...N$) that sell feed. Each store is located on a segment of the X axis whose length is $E (1 \\le E \\le 350$). Store $i$ is at location $X_i (0 < X_i < E)$ on the number line and can sell FJ as much as $F_i (1 \\le F_i \\le 100)$ pounds of feed at a cost of $C_i (1 \\le C_i \\le 1,000,000)$ cents per pound. Amazingly, a given point on the $X$ axis might have more than one store.\n\nFJ starts at location $0$ on this number line and can drive only in the positive direction, ultimately arriving at location $E$, with at least $K$ pounds of feed. He can stop at any of the feed stores along the way and buy any amount of feed up to the the store's limit.\n\nWhat is the minimum amount FJ has to pay to buy and transport the $K$ pounds of feed? FJ knows there is a solution.", "inputFormat": null, "outputFormat": null, "hint": "Consider a sample where FJ needs two pounds of feed from three stores (locations: $1$, $3$, and $4$) on a number line whose range is $0...5$:\n\n```plain\n0   1   2   3   4   5 \n+---|---+---|---|---+ \n    1       1   1      Available pounds of feed \n    1       2   2      Cents per pound \n```\n\nIt is best for FJ to buy one pound of feed from both the second and third stores. He must pay two cents to buy each pound of feed for a total cost of $4$. When FJ travels from $3$ to $4$ he is moving $1$ unit of length and he has $1$ pound of feed so he must pay $1*1 = 1$ cents.\n\nWhen FJ travels from $4$ to $5$ he is moving one unit and he has $2$ pounds of feed so he must pay $1*2 = 2$ cents.\n\nThe total cost is $4+1+2 = 7$ cents.", "locale": "en"}, "zh-CN": {"title": "[USACO10JAN] Buying Feed, II S", "background": null, "description": "FJ 开车来到镇上，他要带 $K$ 吨饲料回家。运送饲料是需要花钱的，如果他的车上有 $X$ 吨饲料，开车 $D$ 公里就需要 $D×X$ 元。FJ 可以从 $N$ 家商店购买饲料，所有商店都在一个坐标轴上，第 $i$ 家店的位置是 $X_i$，饲料的售价为每吨 $C_i$ 元，库存为 $F_i$。\n\n这个镇上有 $N(1 \\le N \\le 100)$ 家商店（编号为 $1 \\sim N$）售卖饲料，所有商店都在一个长度为 $E(1 \\le E \\le 350)$ 的 $X$ 轴上。第 $i$ 个商店位于数轴上 $X_i$ 的位置，最多可以售卖给 FJ $F_i(1 \\le F_i \\le 100)$ 吨饲料，花费为 $C_i(1 \\le C_i \\le 10^6)$ 元每吨。奇妙的是，$X$ 轴上同一个坐标可能不只有一家商店。\n\nFJ 从坐标为 $0$ 的地方出发并且只能向前走，直到到达坐标为 $E$ 的地方，并且需要买到 $K$ 吨饲料。他可以在沿途任意一家商店停下来买饲料。\n\n请你求出 FJ 购买并运输 $K$ 吨饲料的最小花费是多少。", "inputFormat": "- 第一行：三个整数 $K$，$ E $ 和 $ N $，$ 1\\leq K \\leq 100 $，$ 1\\leq E \\leq 350 $，$ 1\\leq N \\leq 100 $；\n- 第二行到第 $ N + 1 $ 行：第 $ i + 1 $ 行有三个整数 $ X_i $，$ F_i $ 和 $ C_i $，$0 < X_i < E $，$1\\leq F_i \\leq 100 $，$1\\leq C_i \\leq 10^6$。", "outputFormat": "一个整数，表示购买并运送饲料的最小花费。", "hint": "在离家较近的两家商店里各购买一吨饲料，则花费路上的钱是 $1+2=3$，花在店里的钱是 $2+2=4$。", "locale": "zh-CN"}}}
{"pid": "P2617", "type": "P", "difficulty": 6, "samples": [["5 3\n3 2 1 4 7\nQ 1 4 3\nC 2 6\nQ 2 5 3", "3\n6\n"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000], "memory": [1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576, 1048576]}, "tags": ["莫队", "线段树", "平衡树", "树状数组", "O2优化", "树套树", "可持久化线段树", "分块", "整体二分"], "title": "Dynamic Rankings", "background": null, "description": "给定一个含有 $n$ 个数的序列 $a_1,a_2 \\dots a_n$，需要支持两种操作：  \n\n- `Q l r k` 表示查询下标在区间 $[l,r]$ 中的第 $k$ 小的数；\n- `C x y` 表示将 $a_x$ 改为 $y$。", "inputFormat": "第一行两个正整数 $n,m$，表示序列长度与操作个数。  \n第二行 $n$ 个整数，表示 $a_1,a_2 \\dots a_n$。  \n接下来 $m$ 行，每行表示一个操作，都为上述两种中的一个。", "outputFormat": "对于每一次询问，输出一行一个整数表示答案。", "hint": "**【数据范围】**  \n\n对于 $10\\%$ 的数据，$1\\le n,m \\le 100$；  \n对于 $20\\%$ 的数据，$1\\le n,m \\le 1000$；  \n对于 $50\\%$ 的数据，$1\\le n,m \\le 10^4$；     \n对于 $100\\%$ 的数据，$1\\le n,m \\le 10^5$，$1 \\le l \\le r \\le n$，$1 \\le k \\le r-l+1$，$1\\le x \\le n$，$0 \\le a_i,y \\le 10^9$。\n\n请注意常数优化，但写法正常的整体二分和树套树都可以以大约 $1000\\text{ms}$ 每个点的时间通过。\n\n来源：bzoj1901。\n\n本题数据为洛谷自造数据，使用 [CYaRon](https://github.com/luogu-dev/cyaron) 耗时 $5$ 分钟完成数据制作。", "locale": "zh-CN", "translations": {"en": {"title": "Dynamic Rankings", "background": "", "description": "Given a sequence of $n$ numbers $a_1,a_2 \\dots a_n$, you need to support two operations:\n- `Q l r k` queries the $k$-th smallest number among indices in the interval $[l,r]$.\n- `C x y` sets $a_x$ to $y$.", "inputFormat": "The first line contains two positive integers $n,m$, the sequence length and the number of operations.\nThe second line contains $n$ integers, representing $a_1,a_2 \\dots a_n$.\nThe next $m$ lines each describe an operation, which is one of the two types above.", "outputFormat": "For each query, output one integer on a separate line representing the answer.", "hint": "Constraints:\n- For $10\\%$ of the testdata, $1 \\le n,m \\le 100$.\n- For $20\\%$ of the testdata, $1 \\le n,m \\le 1000$.\n- For $50\\%$ of the testdata, $1 \\le n,m \\le 10^4$.\n- For $100\\%$ of the testdata, $1 \\le n,m \\le 10^5$, $1 \\le l \\le r \\le n$, $1 \\le k \\le r-l+1$, $1 \\le x \\le n$, $0 \\le a_i,y \\le 10^9$.\n\nPay attention to constant-factor optimizations, but straightforward implementations of overall binary search on values (\"整体二分\") and tree-of-trees (\"树套树\") can both pass in about 1000 ms per test point.\n\nSource: bzoj1901.\n\nThis problem uses custom Luogu testdata, generated with [CYaRon](https://github.com/luogu-dev/cyaron) in $5$ minutes.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Dynamic Rankings", "background": null, "description": "给定一个含有 $n$ 个数的序列 $a_1,a_2 \\dots a_n$，需要支持两种操作：  \n\n- `Q l r k` 表示查询下标在区间 $[l,r]$ 中的第 $k$ 小的数；\n- `C x y` 表示将 $a_x$ 改为 $y$。", "inputFormat": "第一行两个正整数 $n,m$，表示序列长度与操作个数。  \n第二行 $n$ 个整数，表示 $a_1,a_2 \\dots a_n$。  \n接下来 $m$ 行，每行表示一个操作，都为上述两种中的一个。", "outputFormat": "对于每一次询问，输出一行一个整数表示答案。", "hint": "**【数据范围】**  \n\n对于 $10\\%$ 的数据，$1\\le n,m \\le 100$；  \n对于 $20\\%$ 的数据，$1\\le n,m \\le 1000$；  \n对于 $50\\%$ 的数据，$1\\le n,m \\le 10^4$；     \n对于 $100\\%$ 的数据，$1\\le n,m \\le 10^5$，$1 \\le l \\le r \\le n$，$1 \\le k \\le r-l+1$，$1\\le x \\le n$，$0 \\le a_i,y \\le 10^9$。\n\n请注意常数优化，但写法正常的整体二分和树套树都可以以大约 $1000\\text{ms}$ 每个点的时间通过。\n\n来源：bzoj1901。\n\n本题数据为洛谷自造数据，使用 [CYaRon](https://github.com/luogu-dev/cyaron) 耗时 $5$ 分钟完成数据制作。", "locale": "zh-CN"}}}
{"pid": "P2618", "type": "P", "difficulty": 3, "samples": [["1\n4", "0\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "数学"], "title": "数字工程", "background": "", "description": "ACM 实验室开启了一个数字工程项目，希望把正整数 $n$ 通过一些特殊方法变成 $1$。\n\n可采用的方法有：\n\n1. 减去 $1$\n2. 除以它的任意一个素因子。 \n\n每操作一次消耗一个单位的能量。\n\n请问把 $n$ 变成 $1$ 最少需要消耗多少能量？\n", "inputFormat": "**本题有多组数据。**\n\n对于每组测试，一行一个整数 $n$。", "outputFormat": "一行一个整数，表示最少消耗的能量。", "hint": "$1 \\le n \\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "Number Engineering", "background": "", "description": "The ACM Laboratory has launched a number engineering project, aiming to transform a positive integer $n$ into $1$ using some special methods.\n\nAvailable methods are:\n1. Subtract $1$.\n2. Divide by any one of its prime factors.\n\nEach operation consumes one unit of energy.\n\nWhat is the minimum energy required to turn $n$ into $1$?", "inputFormat": "This problem contains multiple test cases.\n\nFor each test case, there is one line with an integer $n$.", "outputFormat": "Output one line with a single integer, the minimum energy consumed.", "hint": "Constraints: $1 \\le n \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数字工程", "background": "", "description": "ACM 实验室开启了一个数字工程项目，希望把正整数 $n$ 通过一些特殊方法变成 $1$。\n\n可采用的方法有：\n\n1. 减去 $1$\n2. 除以它的任意一个素因子。 \n\n每操作一次消耗一个单位的能量。\n\n请问把 $n$ 变成 $1$ 最少需要消耗多少能量？\n", "inputFormat": "**本题有多组数据。**\n\n对于每组测试，一行一个整数 $n$。", "outputFormat": "一行一个整数，表示最少消耗的能量。", "hint": "$1 \\le n \\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P2619", "type": "P", "difficulty": 5, "samples": [["2 2 1\n0 1 1 1\n0 1 2 0", "2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["二分", "集训队互测", "凸完全单调性（wqs 二分）", "生成树"], "title": "[国家集训队] Tree I", "background": "", "description": "给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有 $need$ 条白色边的生成树。\n\n题目保证有解。\n", "inputFormat": "第一行 $V,E,need$ 分别表示点数，边数和需要的白色边数。\n\n接下来 $E$ 行，每行 $s,t,c,col$ 表示这边的端点（点从 $0$ 开始标号），边权，颜色（$0$ 白色 $1$ 黑色）。\n", "outputFormat": "一行，表示所求生成树的边权和。\n", "hint": "对于 $5\\%$ 的数据，$V\\leq 10$。\n\n对于另 $15\\%$ 的数据，$V\\leq 15$。\n\n对于 $100\\%$ 的数据，$V\\leq 5\\times10^4,E\\leq 10^5$。\n\n所有数据边权为 $[1,100]$ 中的正整数。\n\n\nBy WJMZBMR\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] Tree I", "background": "", "description": "You are given an undirected, weighted, connected graph. Each edge is colored black or white. Find a minimum-total-weight spanning tree that contains exactly $need$ white edges.\n\nIt is guaranteed that a solution exists.", "inputFormat": "The first line contains $V, E, need$, the numbers of vertices, edges, and the required number of white edges.\n\nThen follow $E$ lines. Each line contains $s, t, c, col$, denoting the endpoints (vertices are numbered from $0$), the edge weight, and the color ($0$ for white, $1$ for black).", "outputFormat": "Output one line: the total weight of the required spanning tree.", "hint": "Constraints:\n\n- For $5\\%$ of the testdata, $V \\le 10$.\n- For another $15\\%$ of the testdata, $V \\le 15$.\n- For $100\\%$ of the testdata, $V \\le 5 \\times 10^4, E \\le 10^5$.\n- All edge weights are positive integers in $[1, 100]$.\n\nBy WJMZBMR.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] Tree I", "background": "", "description": "给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有 $need$ 条白色边的生成树。\n\n题目保证有解。\n", "inputFormat": "第一行 $V,E,need$ 分别表示点数，边数和需要的白色边数。\n\n接下来 $E$ 行，每行 $s,t,c,col$ 表示这边的端点（点从 $0$ 开始标号），边权，颜色（$0$ 白色 $1$ 黑色）。\n", "outputFormat": "一行，表示所求生成树的边权和。\n", "hint": "对于 $5\\%$ 的数据，$V\\leq 10$。\n\n对于另 $15\\%$ 的数据，$V\\leq 15$。\n\n对于 $100\\%$ 的数据，$V\\leq 5\\times10^4,E\\leq 10^5$。\n\n所有数据边权为 $[1,100]$ 中的正整数。\n\n\nBy WJMZBMR\n", "locale": "zh-CN"}}}
{"pid": "P2620", "type": "P", "difficulty": 4, "samples": [["28 3 5\n2 18\n5 13\n12 6\n17 25\n20 15\n50 6 1\n9 45\n0\n", "４\n３\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "图论"], "title": "虫洞", "background": "applepi 想进行宇宙旅行。当然，applepi 知道这是有可能的，因为 applepi 的特殊能力能使他观测到宇宙中的虫洞。所谓虫洞就是一个在三维之外的维度打开的快捷通道，通过虫洞能够从一个地方瞬间移动到另外一个地方。\n", "description": "为了简化问题，我们建立一个一维坐标系，地球的位置为 $0$，而applepi 的目的地的位置是一个正整数 $W$。\n\n在每一个单位时间里，applepi 可以向正方向移动不超过 $S$ 的一个整数。虫洞可以被表示为二元组 $(B, E)$，即如果在某次移动之后 applepi 在位置 $B$，那么 applepi 就会被立刻传送到位置 $E$。\n\n注意，applepi 在移动过程中如果经过位置 $B$，由于applepi 的速度极快是不会被传送的。而且，applepi 不能够向负方向移动，但是虫洞引起的除外。\n\n现在applepi 想请你帮助他计算一下他至少需要多少个单位时间才能够到达目的地。\n", "inputFormat": "输入包含多组测试数据。\n\n每组测试数据的第一行是三个正整数 $W,S,P$，表示目的地位置，移动限制和虫洞的数目。之后 $P$ 行，每行两个整数 $B$ 和 $E$，表示一个虫洞。\n\n输入文件的最后一行是一个整数 $0$，表示输入的结束。\n", "outputFormat": "对于每组测试数据，在单独的一行内输出结果。\n", "hint": "对于 $30\\%$ 的数据，$W≤1000$。\n\n对于 $100\\%$ 的数据，$W≤10^9$，$2≤S≤6$，$1≤P≤40$，没有 $B = 0$ 或者 $B = W$ 的虫洞，输入数据保证目的地可达。\n", "locale": "zh-CN", "translations": {"en": {"title": "Wormholes", "background": "applepi wants to travel through the universe. Of course, applepi knows this is possible because his special ability lets him observe wormholes in the universe. A wormhole is a shortcut opened in a dimension beyond three dimensions, allowing instantaneous movement from one place to another.", "description": "To simplify the problem, we set up a one-dimensional coordinate system, with Earth at position $0$, and applepi’s destination at a positive integer position $W$.\n\nIn each unit time, applepi can move an integer no greater than $S$ toward the positive direction. A wormhole is represented as a pair $(B, E)$, meaning that if after a move applepi is at position $B$, he is immediately transported to position $E$.\n\nNote that if applepi passes through position $B$ during a move, he will not be transported because he moves extremely fast. Also, applepi cannot move in the negative direction, except when caused by a wormhole.\n\nNow applepi asks you to compute the minimum number of unit times needed to reach the destination.", "inputFormat": "The input contains multiple test cases.\n\nFor each test case, the first line contains three positive integers $W, S, P$, representing the destination position, the movement limit, and the number of wormholes. The next $P$ lines each contain two integers $B$ and $E$, representing a wormhole.\n\nThe last line of the input file is an integer $0$, indicating the end of input.", "outputFormat": "For each test case, output the result on a single line.", "hint": "- For $30\\%$ of the testdata, $W \\le 1000$.\n- For $100\\%$ of the testdata, $W \\le 10^9$, $2 \\le S \\le 6$, $1 \\le P \\le 40$, there is no wormhole with $B = 0$ or $B = W$, and the input guarantees the destination is reachable.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "虫洞", "background": "applepi 想进行宇宙旅行。当然，applepi 知道这是有可能的，因为 applepi 的特殊能力能使他观测到宇宙中的虫洞。所谓虫洞就是一个在三维之外的维度打开的快捷通道，通过虫洞能够从一个地方瞬间移动到另外一个地方。\n", "description": "为了简化问题，我们建立一个一维坐标系，地球的位置为 $0$，而applepi 的目的地的位置是一个正整数 $W$。\n\n在每一个单位时间里，applepi 可以向正方向移动不超过 $S$ 的一个整数。虫洞可以被表示为二元组 $(B, E)$，即如果在某次移动之后 applepi 在位置 $B$，那么 applepi 就会被立刻传送到位置 $E$。\n\n注意，applepi 在移动过程中如果经过位置 $B$，由于applepi 的速度极快是不会被传送的。而且，applepi 不能够向负方向移动，但是虫洞引起的除外。\n\n现在applepi 想请你帮助他计算一下他至少需要多少个单位时间才能够到达目的地。\n", "inputFormat": "输入包含多组测试数据。\n\n每组测试数据的第一行是三个正整数 $W,S,P$，表示目的地位置，移动限制和虫洞的数目。之后 $P$ 行，每行两个整数 $B$ 和 $E$，表示一个虫洞。\n\n输入文件的最后一行是一个整数 $0$，表示输入的结束。\n", "outputFormat": "对于每组测试数据，在单独的一行内输出结果。\n", "hint": "对于 $30\\%$ 的数据，$W≤1000$。\n\n对于 $100\\%$ 的数据，$W≤10^9$，$2≤S≤6$，$1≤P≤40$，没有 $B = 0$ 或者 $B = W$ 的虫洞，输入数据保证目的地可达。\n", "locale": "zh-CN"}}}
{"pid": "P2622", "type": "P", "difficulty": 3, "samples": [["3\n2\n1 0 1\n-1 1 0", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "洛谷原创", "最短路", "洛谷月赛", "状压 DP"], "title": "关灯问题 II", "background": "", "description": "现有 $n$ 盏灯，以及 $m$ 个按钮。每个按钮可以同时控制这 $n$ 盏灯——按下了第 $i$ 个按钮，对于所有的灯都有一个效果。按下 $i$ 按钮对于第 $j$ 盏灯，是下面 $3$ 种效果之一：\n\n- 如果 $a_{i,j}$ 为 $1$，那么当这盏灯开了的时候，把它关上，否则不管；\n- 如果 $a_{i,j}$ 为 $-1$，如果这盏灯是关的，那么把它打开，否则也不管；\n- 如果 $a_{i,j}$ 为 $0$，无论这灯是否开，都不管。\n\n现在这些灯都是开的，给出所有开关对所有灯的控制效果，求问最少要按几下按钮才能全部关掉。", "inputFormat": "前两行两个整数，分别是 $n$ 和 $m$。\n\n接下来 $m$ 行，每行 $n$ 个整数，第 $(i+2)$ 行的第 $j$ 个整数为 $a_{i,j}$，表示第 $i$ 个开关对第 $j$ 个灯的效果。", "outputFormat": "一个整数，表示最少的按按钮的次数。如果没有任何办法使其全部关闭，输出 $-1$。", "hint": "### 数据范围及约定\n\n- 存在 $20\\%$ 的数据，输出无解可以得分。\n- 存在 $20\\%$ 的数据，$n \\le 5$。\n- 存在 $20\\%$ 的数据，$m \\le 20$。\n\n上面的数据点可能会重叠。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10, 1 \\le m \\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "Lights Out Problem II", "background": "", "description": "There are $n$ lamps and $m$ buttons. Each button can control all $n$ lamps simultaneously — pressing the $i$-th button affects every lamp. For lamp $j$, pressing button $i$ has one of the following three effects:\n\n- If $a_{i,j} = 1$, then if this lamp is on, turn it off; otherwise do nothing.\n- If $a_{i,j} = -1$, then if this lamp is off, turn it on; otherwise do nothing.\n- If $a_{i,j} = 0$, do nothing regardless of the lamp’s state.\n\nAll lamps are initially on. Given the effects of every button on every lamp, find the minimum number of button presses needed to turn all lamps off.", "inputFormat": "The first line contains the integer $n$.  \nThe second line contains the integer $m$.\n\nThe next $m$ lines each contain $n$ integers. On line $i + 2$, the $j$-th integer is $a_{i,j}$, representing the effect of button $i$ on lamp $j$.", "outputFormat": "Output a single integer — the minimum number of button presses. If it is impossible to turn all lamps off, output $-1$.", "hint": "### Constraints\n\n- For $20\\%$ of the testdata, printing “no solution” can score points.\n- For $20\\%$ of the testdata, $n \\le 5$.\n- For $20\\%$ of the testdata, $m \\le 20$.\n\nThe above test points may overlap.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10$, $1 \\le m \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "关灯问题 II", "background": "", "description": "现有 $n$ 盏灯，以及 $m$ 个按钮。每个按钮可以同时控制这 $n$ 盏灯——按下了第 $i$ 个按钮，对于所有的灯都有一个效果。按下 $i$ 按钮对于第 $j$ 盏灯，是下面 $3$ 种效果之一：\n\n- 如果 $a_{i,j}$ 为 $1$，那么当这盏灯开了的时候，把它关上，否则不管；\n- 如果 $a_{i,j}$ 为 $-1$，如果这盏灯是关的，那么把它打开，否则也不管；\n- 如果 $a_{i,j}$ 为 $0$，无论这灯是否开，都不管。\n\n现在这些灯都是开的，给出所有开关对所有灯的控制效果，求问最少要按几下按钮才能全部关掉。", "inputFormat": "前两行两个整数，分别是 $n$ 和 $m$。\n\n接下来 $m$ 行，每行 $n$ 个整数，第 $(i+2)$ 行的第 $j$ 个整数为 $a_{i,j}$，表示第 $i$ 个开关对第 $j$ 个灯的效果。", "outputFormat": "一个整数，表示最少的按按钮的次数。如果没有任何办法使其全部关闭，输出 $-1$。", "hint": "### 数据范围及约定\n\n- 存在 $20\\%$ 的数据，输出无解可以得分。\n- 存在 $20\\%$ 的数据，$n \\le 5$。\n- 存在 $20\\%$ 的数据，$m \\le 20$。\n\n上面的数据点可能会重叠。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10, 1 \\le m \\le 100$。", "locale": "zh-CN"}}}
{"pid": "P2623", "type": "P", "difficulty": 3, "samples": [["1 0\n1 1 1", "0"], ["4 10\n2 1 2 1\n1 1 2\n3 5 2\n2 200 2 3", "610"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "物品选取", "background": "小X确信所有问题都有个多项式时间算法，为了证明，他决定自己去当一次旅行商，在上路之前，小X需要挑选一些在路上使用的物品，但他只有一个能装体积为 $m$ 的背包。显然，背包问题对小X来说过于简单了，所以他希望你来帮他解决这个问题。", "description": "小X可以选择的物品有 $n$ 样，一共分为甲乙丙三类：\n\n 1．甲类物品的价值随着你分配给他的背包体积变化，它的价值与分配给它的体积满足函数关系式，$v(x) = Ax^2-Bx$，$A$，$B$ 是每个甲类物品的两个参数。注意每个体积的甲类物品只有一个。\n\n 2．乙类物品的价值 $A$ 和体积 $B$ 都是固定的，但是每个乙类物品都有个参数 $C$，表示这个物品可供选择的个数。\n\n 3．丙类物品的价值 $A$ 和体积 $B$ 也是固定的，但是每个丙类物品可供选择的个数都是无限多个。\n\n你最终的任务是确定小X的背包最多能装有多大的价值上路。", "inputFormat": "第一行两个整数 $n$，$m$，表示背包物品的个数和背包的体积；\n\n 接下来 $n$ 行，每行描述一个物品的信息。第一个整数 $x$ ，表示物品的种类：\n\n若 $x$ 为 $1$ 表示甲类物品，接下来两个整数 $A$, $B$，为 $A$ 类物品的两个参数；\n\n若 $x$ 为 $2$ 表示乙类物品，接下来三个整数 $A$，$B$，$C$。$A$ 表示物品的价值，$B$ 表示它的体积，$C$ 表示它的个数；\n\n若 $x$ 为 $3$ 表示丙类物品，接下来两个整数 $A$，$B$。$A$ 表示它的价值，$B$ 表示它的体积。", "outputFormat": "输出文件仅一行为一个整数，表示小X的背包能装的最大价值。", "hint": "对于 $50\\%$ 的数据，只有乙和丙两类物品；\n\n对于 $70\\%$ 的数据，$1 \\le n \\le 100$, $1 \\le m \\le 500$，$0 \\le A,B,C \\le 200$；\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 100$, $1 \\le m \\le 2000$，$0 \\le A,B,C \\le 200$；", "locale": "zh-CN", "translations": {"en": {"title": "Item Selection", "background": "Xiao X believes that every problem has a polynomial-time algorithm. To prove it, he decides to be a traveling salesman once. Before setting off, Xiao X needs to choose some items to use on the road, but he only has a backpack with capacity $m$. Obviously, the knapsack problem is too easy for Xiao X, so he wants you to solve this problem for him.", "description": "Xiao X can choose from $n$ items, divided into three categories: A, B, and C.\n\n1. Type A items have values that change with the volume you allocate to them. Their value follows the function $v(x) = A x^2 - B x$, where $A$ and $B$ are two parameters for each type A item. Note: for type A items, there is only one item for each volume amount.\n\n2. Type B items have fixed value $A$ and volume $B$, and each has a parameter $C$, which is the number of copies available.\n\n3. Type C items also have fixed value $A$ and volume $B$, but the number of copies available is unlimited.\n\nYour task is to determine the maximum total value Xiao X can carry in his backpack.", "inputFormat": "The first line contains two integers $n$ and $m$, the number of items and the backpack capacity.\n\nThen follow $n$ lines, each describing one item. The first integer $x$ indicates the item category:\n\n- If $x = 1$, it is a type A item. The next two integers $A$, $B$ are this item's two parameters.\n- If $x = 2$, it is a type B item. The next three integers $A$, $B$, $C$ denote the item's value, its volume, and the number of copies available, respectively.\n- If $x = 3$, it is a type C item. The next two integers $A$, $B$ denote the item's value and its volume.", "outputFormat": "Output a single line containing one integer: the maximum total value that can be carried in the backpack.", "hint": "- For $50\\%$ of the testdata, only types B and C appear.\n- For $70\\%$ of the testdata, $1 \\le n \\le 100$, $1 \\le m \\le 500$, $0 \\le A, B, C \\le 200$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 100$, $1 \\le m \\le 2000$, $0 \\le A, B, C \\le 200$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "物品选取", "background": "小X确信所有问题都有个多项式时间算法，为了证明，他决定自己去当一次旅行商，在上路之前，小X需要挑选一些在路上使用的物品，但他只有一个能装体积为 $m$ 的背包。显然，背包问题对小X来说过于简单了，所以他希望你来帮他解决这个问题。", "description": "小X可以选择的物品有 $n$ 样，一共分为甲乙丙三类：\n\n 1．甲类物品的价值随着你分配给他的背包体积变化，它的价值与分配给它的体积满足函数关系式，$v(x) = Ax^2-Bx$，$A$，$B$ 是每个甲类物品的两个参数。注意每个体积的甲类物品只有一个。\n\n 2．乙类物品的价值 $A$ 和体积 $B$ 都是固定的，但是每个乙类物品都有个参数 $C$，表示这个物品可供选择的个数。\n\n 3．丙类物品的价值 $A$ 和体积 $B$ 也是固定的，但是每个丙类物品可供选择的个数都是无限多个。\n\n你最终的任务是确定小X的背包最多能装有多大的价值上路。", "inputFormat": "第一行两个整数 $n$，$m$，表示背包物品的个数和背包的体积；\n\n 接下来 $n$ 行，每行描述一个物品的信息。第一个整数 $x$ ，表示物品的种类：\n\n若 $x$ 为 $1$ 表示甲类物品，接下来两个整数 $A$, $B$，为 $A$ 类物品的两个参数；\n\n若 $x$ 为 $2$ 表示乙类物品，接下来三个整数 $A$，$B$，$C$。$A$ 表示物品的价值，$B$ 表示它的体积，$C$ 表示它的个数；\n\n若 $x$ 为 $3$ 表示丙类物品，接下来两个整数 $A$，$B$。$A$ 表示它的价值，$B$ 表示它的体积。", "outputFormat": "输出文件仅一行为一个整数，表示小X的背包能装的最大价值。", "hint": "对于 $50\\%$ 的数据，只有乙和丙两类物品；\n\n对于 $70\\%$ 的数据，$1 \\le n \\le 100$, $1 \\le m \\le 500$，$0 \\le A,B,C \\le 200$；\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 100$, $1 \\le m \\le 2000$，$0 \\le A,B,C \\le 200$；", "locale": "zh-CN"}}}
{"pid": "P2624", "type": "P", "difficulty": 6, "samples": [["3\n1\n-1\n-1", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2008", "各省省选", "湖南"], "title": "[HNOI2008] 明明的烦恼", "background": "原 编译优化 参见P1792", "description": "自从明明学了树的结构，就对奇怪的树产生了兴趣……\n\n给出标号为 $1$ 到 $N$ 的点，以及某些点最终的度数，允许在任意两点间连边，可产生多少棵度数满足要求的树?", "inputFormat": "第一行一个正整数 $N(0< N\\le 1000)$。\n\n接下来 $N$ 行，第 $i+1$ 一个正整数表示第 $i$ 个节点的度数 $D_i$。如果对度数不要求，则输入 `-1`。", "outputFormat": "一行一个正整数，表示不同的满足要求的树的个数，无解则输出 $0$。", "hint": "两棵树分别为 `1-2-3` 与 `1-3-2`。", "locale": "zh-CN", "translations": {"en": {"title": "[HNOI2008] Mingming's Worries", "background": "Original: \"Compilation Optimization\". See P1792.", "description": "Ever since Mingming learned about tree structures, he has become interested in unusual trees.\n\nGiven nodes labeled $1$ to $N$, and the final degrees of some nodes, you may add edges between any pair of nodes. How many trees can be formed whose degrees meet the given requirements?", "inputFormat": "The first line contains a positive integer $N$ ($0 < N \\le 1000$).\n\nThe next $N$ lines: the $(i+1)$-th line contains a positive integer representing the degree $D_i$ of the $i$-th node. If the degree is unconstrained, input `-1`.", "outputFormat": "Output a single positive integer on one line, the number of different trees that satisfy the requirements. If there is no solution, output $0$.", "hint": "The two trees are `1-2-3` and `1-3-2`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[HNOI2008] 明明的烦恼", "background": "原 编译优化 参见P1792", "description": "自从明明学了树的结构，就对奇怪的树产生了兴趣……\n\n给出标号为 $1$ 到 $N$ 的点，以及某些点最终的度数，允许在任意两点间连边，可产生多少棵度数满足要求的树?", "inputFormat": "第一行一个正整数 $N(0< N\\le 1000)$。\n\n接下来 $N$ 行，第 $i+1$ 一个正整数表示第 $i$ 个节点的度数 $D_i$。如果对度数不要求，则输入 `-1`。", "outputFormat": "一行一个正整数，表示不同的满足要求的树的个数，无解则输出 $0$。", "hint": "两棵树分别为 `1-2-3` 与 `1-3-2`。", "locale": "zh-CN"}}}
{"pid": "P2625", "type": "P", "difficulty": 4, "samples": [["3\nforward 100\nbackward 100\nleft 90", "141.421356"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "数学", "贪心", "背包 DP"], "title": "豪华游轮", "background": "", "description": "有一条豪华游轮（其实就是条小木船），这种船可以执行 $4$ 种指令：\n\n`right X`：其中 $X$ 是一个 $1$ 到 $719$ 的整数，这个命令使得船顺时针转动 $X$ 度。\n\n`left X`：其中 $X$ 是一个 $1$ 到 $719$ 的整数，这个命令使得船逆时针转动 $X$ 度。\n\n`forward X`：其中 $X$ 是一个整数（$1$ 到 $1000$），使得船向正前方前进 $X$ 的距离。\n\n`backward X`：其中 $X$ 是一个整数（$1$ 到 $1000$），使得船向正后方前进 $X$ 的距离。\n\n随意的写出了 $n$ 个命令，找出一个种排列命令的方法，使得船最终到达的位置距离起点尽可能的远。\n", "inputFormat": "第一行一个整数 $n (1 \\leq n \\leq 50)$，表示给出的命令数。\n\n接下来 $n$ 行，每行表示一个命令。", "outputFormat": "一个浮点数，能够走的最远的距离，四舍五入到 $6$ 位小数。\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Luxury Cruise Ship", "background": "", "description": "There is a luxury cruise ship (actually just a small wooden boat). This ship can execute $4$ types of commands:\n\n`right X`: where $X$ is an integer from $1$ to $719$. This command rotates the ship clockwise by $X$ degrees.\n\n`left X`: where $X$ is an integer from $1$ to $719$. This command rotates the ship counterclockwise by $X$ degrees.\n\n`forward X`: where $X$ is an integer ($1$ to $1000$). This command moves the ship $X$ units straight ahead along its current heading.\n\n`backward X`: where $X$ is an integer ($1$ to $1000$). This command moves the ship $X$ units straight backward along its current heading.\n\nYou are given $n$ commands written in arbitrary order. Find a way to arrange these commands so that the ship’s final position is as far from the starting point as possible.", "inputFormat": "The first line contains an integer $n (1 \\leq n \\leq 50)$, representing the number of given commands.\n\nThe next $n$ lines each contain one command.", "outputFormat": "Output a floating-point number: the maximum achievable distance, rounded to $6$ decimal places.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "豪华游轮", "background": "", "description": "有一条豪华游轮（其实就是条小木船），这种船可以执行 $4$ 种指令：\n\n`right X`：其中 $X$ 是一个 $1$ 到 $719$ 的整数，这个命令使得船顺时针转动 $X$ 度。\n\n`left X`：其中 $X$ 是一个 $1$ 到 $719$ 的整数，这个命令使得船逆时针转动 $X$ 度。\n\n`forward X`：其中 $X$ 是一个整数（$1$ 到 $1000$），使得船向正前方前进 $X$ 的距离。\n\n`backward X`：其中 $X$ 是一个整数（$1$ 到 $1000$），使得船向正后方前进 $X$ 的距离。\n\n随意的写出了 $n$ 个命令，找出一个种排列命令的方法，使得船最终到达的位置距离起点尽可能的远。\n", "inputFormat": "第一行一个整数 $n (1 \\leq n \\leq 50)$，表示给出的命令数。\n\n接下来 $n$ 行，每行表示一个命令。", "outputFormat": "一个浮点数，能够走的最远的距离，四舍五入到 $6$ 位小数。\n", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2626", "type": "P", "difficulty": 2, "samples": [["5", "5=5"], ["6", "8=2*2*2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "递推", "素数判断,质数,筛法"], "title": "斐波那契数列（升级版）", "background": "大家都知道，斐波那契数列是满足如下性质的一个数列： \n\n- $f(1) = 1$\n- $f(2) = 1$ \n- $f(n) = f(n-1) + f(n-2)$（$n > 2$ 且 $n$ 为整数）。\n", "description": "请你求出第 $n$ 个斐波那契数列的数 $\\bmod\\,2^{31}$ 之后的值，并把它分解质因数。\n", "inputFormat": "输入一个正整数 $n$。", "outputFormat": "把第 $n$ 个斐波那契数列的数分解质因数。\n", "hint": "$n \\le 48$", "locale": "zh-CN", "translations": {"en": {"title": "Fibonacci Sequence (Upgraded Version)", "background": "Everyone knows that the Fibonacci sequence satisfies the following properties:\n- $f(1) = 1$.\n- $f(2) = 1$.\n- $f(n) = f(n-1) + f(n-2)$ (where $n > 2$ and $n$ is an integer).", "description": "Please compute the $n$-th Fibonacci number, take it $\\bmod\\,2^{31}$, and factor the result into prime factors.", "inputFormat": "Input a positive integer $n$.", "outputFormat": "Output the prime factorization of the $n$-th Fibonacci number after applying $\\bmod\\,2^{31}$.", "hint": "$n \\le 48$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "斐波那契数列（升级版）", "background": "大家都知道，斐波那契数列是满足如下性质的一个数列： \n\n- $f(1) = 1$\n- $f(2) = 1$ \n- $f(n) = f(n-1) + f(n-2)$（$n > 2$ 且 $n$ 为整数）。\n", "description": "请你求出第 $n$ 个斐波那契数列的数 $\\bmod\\,2^{31}$ 之后的值，并把它分解质因数。\n", "inputFormat": "输入一个正整数 $n$。", "outputFormat": "把第 $n$ 个斐波那契数列的数分解质因数。\n", "hint": "$n \\le 48$", "locale": "zh-CN"}}}
{"pid": "P2627", "type": "P", "difficulty": 4, "samples": [["5 2\n1\n2\n3\n4\n5\n", "12\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "2011", "线段树", "USACO", "单调队列"], "title": "[USACO11OPEN] Mowing the Lawn G", "background": "", "description": "在一年前赢得了小镇的最佳草坪比赛后，Farmer John 变得很懒，再也没有修剪过草坪。现在，新一轮的最佳草坪比赛又开始了，Farmer John 希望能够再次夺冠。\n\n然而，Farmer John 的草坪非常脏乱，因此，Farmer John 只能够让他的奶牛来完成这项工作。Farmer John 有 $N$（$1\\le N\\le 10^5$）只排成一排的奶牛，编号为 $1\\ldots N$。每只奶牛的效率是不同的，奶牛 $i$ 的效率为 $E_i$（$0\\le E_i\\le 10^9$）。\n\n靠近的奶牛们很熟悉，因此，如果 Farmer John安排超过 $K$（$1\\le K\\le N$）只连续的奶牛，那么，这些奶牛就会罢工去开派对 :)。因此，现在 Farmer John 需要你的帮助，计算 FJ 可以得到的最大效率，并且该方案中没有连续的超过 $K$ 只奶牛。", "inputFormat": "第一行：空格隔开的两个整数 $N$ 和 $K$。\n\n第二到 $N+1$ 行：第 $i+1$ 行有一个整数 $E_i$。", "outputFormat": "第一行：一个值，表示 Farmer John 可以得到的最大的效率值。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO11OPEN] Mowing the Lawn G", "background": "", "description": "After winning the town’s Best Lawn contest a year ago, Farmer John became lazy and hasn’t mowed the lawn since. Now, a new Best Lawn contest is starting, and Farmer John hopes to win again.\n\nHowever, Farmer John’s lawn is a mess, so he can only rely on his cows to do the job. Farmer John has $N$ ($1\\le N\\le 10^5$) cows in a row, numbered $1\\ldots N$. Each cow has a different efficiency; cow $i$ has efficiency $E_i$ ($0\\le E_i\\le 10^9$).\n\nNeighboring cows are very familiar with each other, so if Farmer John schedules more than $K$ ($1\\le K\\le N$) consecutive cows, they will go on strike to throw a party :). Therefore, Farmer John needs your help to compute the maximum total efficiency he can obtain, with no stretch of more than $K$ consecutive cows.", "inputFormat": "The first line contains two integers $N$ and $K$ separated by a space.\n\nThe second to $(N+1)$-th lines: the $(i+1)$-th line contains an integer $E_i$.", "outputFormat": "Output a single value: the maximum total efficiency that Farmer John can obtain.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO11OPEN] Mowing the Lawn G", "background": "", "description": "在一年前赢得了小镇的最佳草坪比赛后，Farmer John 变得很懒，再也没有修剪过草坪。现在，新一轮的最佳草坪比赛又开始了，Farmer John 希望能够再次夺冠。\n\n然而，Farmer John 的草坪非常脏乱，因此，Farmer John 只能够让他的奶牛来完成这项工作。Farmer John 有 $N$（$1\\le N\\le 10^5$）只排成一排的奶牛，编号为 $1\\ldots N$。每只奶牛的效率是不同的，奶牛 $i$ 的效率为 $E_i$（$0\\le E_i\\le 10^9$）。\n\n靠近的奶牛们很熟悉，因此，如果 Farmer John安排超过 $K$（$1\\le K\\le N$）只连续的奶牛，那么，这些奶牛就会罢工去开派对 :)。因此，现在 Farmer John 需要你的帮助，计算 FJ 可以得到的最大效率，并且该方案中没有连续的超过 $K$ 只奶牛。", "inputFormat": "第一行：空格隔开的两个整数 $N$ 和 $K$。\n\n第二到 $N+1$ 行：第 $i+1$ 行有一个整数 $E_i$。", "outputFormat": "第一行：一个值，表示 Farmer John 可以得到的最大的效率值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2628", "type": "P", "difficulty": 2, "samples": [["yhfA>>>fhsdfa***>>>foaoad\r\n3\r\n5 6 6", "20 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "冒险岛", "background": "冒险岛是费老师新开发的一种情景模拟电脑的游戏，通过掷骰子（1~6个数字之间），让一种人物（棋子）在棋纸上从左至右的行走，从而模拟冒险的故事……\n", "description": "棋纸上有一条从左至右的很长的路，整条路是一连串符号组成，表明路的状况，棋子必须在符号组成的路上行走。每掷一下骰子得到的数字，棋子就可以走掷得的数字所对应的步数，比如掷3，就可以走3步。\n\n路上有两种特殊符号可以改变棋子的行走。\n\n一种是“>”符号，一旦棋子走完了掷骰子的步数，最终停留在这个符号上，后面有紧跟着2个以上“>”，那么棋子就可以获得前进奖励，可以沿着“>”一直一步步前进，直到遇到一个不是“>”的符号位置停下来。\n\n还有一种是“\\*”符号，一旦棋子走完了掷骰子的步数，最终停留在这个符号上，后面又紧跟着两个以上“\\*”，就要受到后退惩罚，需要退后k步，这个k步就是从当前“\\*”开始的连续的“\\*”的数量。\n\n每次掷数后，奖励或惩罚至多一次，如果奖励或惩罚后棋子又落在第二种特殊符号上，则不能再受到奖励或惩罚。\n\n如果走的棋子超出棋纸右边界最后一个符号，则停在最后一个符号上；如果超出左边界，则停在第一个符号上。\n\n若干次掷骰子后，请问游戏中的人物（棋子）走到了哪步？离终点还差几步？\n", "inputFormat": "第一行为一个字符串s，字符串中的每个字符表示棋纸的路的状况。\n\n第二行是一个n，表示掷了n次骰子。\n\n第三行是n个整数（1~6的范围），表明掷了n次骰子得到的数字，数字之间有一个空格。\n", "outputFormat": "只有两个数字，表明目前所在符号的序号和离终点符号的步数，数子中间有一个空格。注意输出末尾有换行。\n", "hint": "【样例说明】\n\n在游戏中，第一次掷的是5，则走到第一个>的位置，获得奖励前进至左起第二个f处。第二次掷的是6，则走到\\*的位置，受惩罚退3步，至d处。第三次掷的是6，则走至左起第四个>号处，获奖励前进至f。最终棋子停留的符号是第20个（从左至右的数），离终点符号d（含）相差5步数。\n\n【数据范围】\n\n对于50%的数据，1<=s的长度<=255,0<=n<=1000。\n\n对于100%的数据，256<=s的长度<=1000000,0<=n<=100000。\n", "locale": "zh-CN", "translations": {"en": {"title": "Adventure Island", "background": "Adventure Island is a scenario-simulation computer game newly developed by Teacher Fei. By rolling a die (numbers 1 to 6), a character (the piece) walks from left to right on a board, thereby simulating an adventure story.", "description": "On the board, there is a long road from left to right. The entire road is a sequence of symbols that describe the road’s state, and the piece must walk along this symbolic road. Each time you roll the die and obtain a number, the piece moves exactly that many steps. For example, if you roll a 3, it moves 3 steps.\n\nThere are two special symbols on the road that can change the piece’s movement:\n\n- The “>” symbol: If, after finishing the steps from the die roll, the piece lands on this symbol and there are at least 2 consecutive “>” immediately following it, then the piece receives a forward bonus. It moves forward along the consecutive “>” one step at a time until it reaches a position whose symbol is not “>”, and stops there.\n\n- The “\\*” symbol: If, after finishing the steps from the die roll, the piece lands on this symbol and there are at least 2 consecutive “\\*” immediately following it, then it suffers a backward penalty. It must move back by k steps, where k is the length of the consecutive “\\*” run starting from the current “\\*”.\n\nAfter each roll, at most one bonus or penalty is applied. If, after applying a bonus or penalty, the piece lands on another special symbol, no further bonus or penalty is applied.\n\nIf the piece moves past the right boundary (beyond the last symbol), it stops at the last symbol. If it moves past the left boundary, it stops at the first symbol.\n\nAfter several die rolls, determine which position the piece ends on, and how many steps remain to the end.", "inputFormat": "- The first line is a string s, where each character describes the state of one position on the board.\n- The second line is an integer n, the number of die rolls.\n- The third line contains n integers (each in the range 1 to 6), the numbers obtained from the n rolls, separated by single spaces.", "outputFormat": "Output exactly two numbers: the 1-based index of the current symbol and the number of steps remaining to the last symbol (inclusive). Separate them with a single space. Note: end the output with a newline.", "hint": "[Sample Explanation]\n\nIn the game, the first roll is 5, so the piece moves to the first “>” and gains a forward bonus to the second “f” from the left. The second roll is 6, so it lands on “\\*”, suffers a penalty of 3 steps backward, and moves to “d”. The third roll is 6, so it reaches the fourth “>” from the left and gains a bonus to “f”. The piece finally stops at the 20th symbol (counting from left to right), and is 5 steps away from the last symbol “d” (inclusive).\n\nConstraints\n\n- For 50% of the testdata: 1 <= |s| <= 255, 0 <= n <= 1000.\n- For 100% of the testdata: 256 <= |s| <= 1,000,000, 0 <= n <= 100,000.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "冒险岛", "background": "冒险岛是费老师新开发的一种情景模拟电脑的游戏，通过掷骰子（1~6个数字之间），让一种人物（棋子）在棋纸上从左至右的行走，从而模拟冒险的故事……\n", "description": "棋纸上有一条从左至右的很长的路，整条路是一连串符号组成，表明路的状况，棋子必须在符号组成的路上行走。每掷一下骰子得到的数字，棋子就可以走掷得的数字所对应的步数，比如掷3，就可以走3步。\n\n路上有两种特殊符号可以改变棋子的行走。\n\n一种是“>”符号，一旦棋子走完了掷骰子的步数，最终停留在这个符号上，后面有紧跟着2个以上“>”，那么棋子就可以获得前进奖励，可以沿着“>”一直一步步前进，直到遇到一个不是“>”的符号位置停下来。\n\n还有一种是“\\*”符号，一旦棋子走完了掷骰子的步数，最终停留在这个符号上，后面又紧跟着两个以上“\\*”，就要受到后退惩罚，需要退后k步，这个k步就是从当前“\\*”开始的连续的“\\*”的数量。\n\n每次掷数后，奖励或惩罚至多一次，如果奖励或惩罚后棋子又落在第二种特殊符号上，则不能再受到奖励或惩罚。\n\n如果走的棋子超出棋纸右边界最后一个符号，则停在最后一个符号上；如果超出左边界，则停在第一个符号上。\n\n若干次掷骰子后，请问游戏中的人物（棋子）走到了哪步？离终点还差几步？\n", "inputFormat": "第一行为一个字符串s，字符串中的每个字符表示棋纸的路的状况。\n\n第二行是一个n，表示掷了n次骰子。\n\n第三行是n个整数（1~6的范围），表明掷了n次骰子得到的数字，数字之间有一个空格。\n", "outputFormat": "只有两个数字，表明目前所在符号的序号和离终点符号的步数，数子中间有一个空格。注意输出末尾有换行。\n", "hint": "【样例说明】\n\n在游戏中，第一次掷的是5，则走到第一个>的位置，获得奖励前进至左起第二个f处。第二次掷的是6，则走到\\*的位置，受惩罚退3步，至d处。第三次掷的是6，则走至左起第四个>号处，获奖励前进至f。最终棋子停留的符号是第20个（从左至右的数），离终点符号d（含）相差5步数。\n\n【数据范围】\n\n对于50%的数据，1<=s的长度<=255,0<=n<=1000。\n\n对于100%的数据，256<=s的长度<=1000000,0<=n<=100000。\n", "locale": "zh-CN"}}}
{"pid": "P2629", "type": "P", "difficulty": 3, "samples": [["4\n-3 5 1 2\n", "2\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "线性数据结构", "单调队列", "洛谷原创", "前缀和", "队列", "洛谷月赛"], "title": "好消息，坏消息", "background": null, "description": "Uim 在公司里面当秘书，现在有 $n$ 条消息要告知老板。每条消息有一个好坏度，这会影响老板的心情。告知完一条消息后，老板的心情等于老板之前的心情加上这条消息的好坏度。最开始老板的心情是 $0$，一旦老板心情到了 $0$ 以下就会勃然大怒，炒了 Uim 的鱿鱼。\n\nUim 为了不被炒，提前知道了这些消息（已经按时间的发生顺序进行了排列）的好坏度，希望知道如何才能不让老板发怒。\n\nUim 可以使用一种叫 “倒叙” 的手法，例如有 $n$ 条消息，Uim 可以任取一个整数 $k$（$1 \\leq k \\leq n$），先从 $k$ 事件通报到 $n$ 事件，再从 $1$ 事件通报到 $k-1$ 事件。特别的，当 $k=1$ 时按照原顺序通报。\n\n他希望知道，有多少个这样的 $k$ 可以让老板不发怒。", "inputFormat": "第一行一个整数 $n$（$1 \\le n \\le10^6$），表示有 $n$ 个消息。\n\n第二行 $n$ 个整数，按时间顺序给出第 $i$ 条消息的好坏度 $A_i$（$-10^3\\le A_i \\le 10^3$）。", "outputFormat": "一行一个整数，表示可行的方案个数。", "hint": "**【样例解释】**\n\n通报事件的可行顺序（用编号表示）为 $2\\rightarrow3\\rightarrow4\\rightarrow1$ 或 $3\\rightarrow4\\rightarrow1\\rightarrow2$（分别对应 $k=2$ 和 $k=3$）\n\n通报事件的可行顺序（用好坏度表示）为 $5\\rightarrow1\\rightarrow2\\rightarrow(-3)$ 或 $1\\rightarrow2\\rightarrow(-3)\\rightarrow5$\n\n**【数据范围】**\n\n对于 $25\\%$ 的数据，$n\\le10^3$；  \n对于 $75\\%$ 的数据，$n\\le10^4$；  \n对于 $100\\%$ 的数据，$1 \\le n\\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "Good News, Bad News", "background": "", "description": "Uim works as a secretary at a company. There are $n$ messages to inform the boss. Each message has a \"goodness\" value, which affects the boss’s mood. After a message is delivered, the boss’s mood becomes his previous mood plus this message’s goodness. Initially, the boss’s mood is $0$. Once the boss’s mood falls below $0$, he will fly into a rage and fire Uim.\n\nTo avoid being fired, Uim already knows the goodness values of these messages (which are arranged in chronological order) and wants to know how to prevent the boss from getting angry.\n\nUim can use a technique called \"daoxu\" (\"倒叙\"). For example, given $n$ messages, Uim can choose any integer $k$ ($1 \\leq k \\leq n$), first report events $k$ to $n$, and then report events $1$ to $k-1$. In particular, when $k=1$, the messages are reported in the original order.\n\nHe wants to know how many such values of $k$ can keep the boss from getting angry.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 10^6$), the number of messages.\n\nThe second line contains $n$ integers. In chronological order, the $i$-th message has goodness $A_i$ ($-10^3 \\le A_i \\le 10^3$).", "outputFormat": "One line with a single integer, the number of feasible choices of $k$.", "hint": "Sample Explanation:\n\nFeasible reporting orders (by indices) are $2\\rightarrow3\\rightarrow4\\rightarrow1$ or $3\\rightarrow4\\rightarrow1\\rightarrow2$ (corresponding to $k=2$ and $k=3$, respectively).\n\nFeasible reporting orders (by goodness values) are $5\\rightarrow1\\rightarrow2\\rightarrow(-3)$ or $1\\rightarrow2\\rightarrow(-3)\\rightarrow5$.\n\nConstraints:\n\nFor $25\\%$ of the testdata, $n \\le 10^3$.\nFor $75\\%$ of the testdata, $n \\le 10^4$.\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "好消息，坏消息", "background": null, "description": "Uim 在公司里面当秘书，现在有 $n$ 条消息要告知老板。每条消息有一个好坏度，这会影响老板的心情。告知完一条消息后，老板的心情等于老板之前的心情加上这条消息的好坏度。最开始老板的心情是 $0$，一旦老板心情到了 $0$ 以下就会勃然大怒，炒了 Uim 的鱿鱼。\n\nUim 为了不被炒，提前知道了这些消息（已经按时间的发生顺序进行了排列）的好坏度，希望知道如何才能不让老板发怒。\n\nUim 可以使用一种叫 “倒叙” 的手法，例如有 $n$ 条消息，Uim 可以任取一个整数 $k$（$1 \\leq k \\leq n$），先从 $k$ 事件通报到 $n$ 事件，再从 $1$ 事件通报到 $k-1$ 事件。特别的，当 $k=1$ 时按照原顺序通报。\n\n他希望知道，有多少个这样的 $k$ 可以让老板不发怒。", "inputFormat": "第一行一个整数 $n$（$1 \\le n \\le10^6$），表示有 $n$ 个消息。\n\n第二行 $n$ 个整数，按时间顺序给出第 $i$ 条消息的好坏度 $A_i$（$-10^3\\le A_i \\le 10^3$）。", "outputFormat": "一行一个整数，表示可行的方案个数。", "hint": "**【样例解释】**\n\n通报事件的可行顺序（用编号表示）为 $2\\rightarrow3\\rightarrow4\\rightarrow1$ 或 $3\\rightarrow4\\rightarrow1\\rightarrow2$（分别对应 $k=2$ 和 $k=3$）\n\n通报事件的可行顺序（用好坏度表示）为 $5\\rightarrow1\\rightarrow2\\rightarrow(-3)$ 或 $1\\rightarrow2\\rightarrow(-3)\\rightarrow5$\n\n**【数据范围】**\n\n对于 $25\\%$ 的数据，$n\\le10^3$；  \n对于 $75\\%$ 的数据，$n\\le10^4$；  \n对于 $100\\%$ 的数据，$1 \\le n\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P2630", "type": "P", "difficulty": 3, "samples": [["3 4 5\n6 7 8\n1 2 3\n1 2 3\n6 7 8\n3 4 5", "D"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心"], "title": "图像变换", "background": null, "description": "给定 $3$ 行 $3$ 列的图像各像素点灰度值，给定最终图像，求最短、字典序最小的**非空**操作序列。\n\n其中，可能的操作及对应字符有如下四种：\n\n`A`：顺时针旋转 $90$ 度；\n\n`B`：逆时针旋转 $90$ 度；\n\n`C`：左右翻转；\n\n`D`：上下翻转。", "inputFormat": "一个矩阵，表示初始的图像。\n\n一个矩阵，表示最终的图像。", "outputFormat": "最短、字典序最小的**非空**操作序列，保证长度不超过 $10^8$，不保证有解。\n\n若长度超过 $10^8$ 无解则输出 `Poland cannot into space!!!` 。", "hint": "字符串长度不超过 $10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "Image Transformation", "background": "", "description": "Given the grayscale values of every pixel in a $ 3 \\times 3 $ image and a target image, find the shortest and, among those, lexicographically smallest **non-empty** sequence of operations.\n\nThe possible operations and their corresponding characters are:\n`A`: rotate $ 90 $ degrees clockwise;\n`B`: rotate $ 90 $ degrees counterclockwise;\n`C`: flip left–right;\n`D`: flip up–down.", "inputFormat": "- Three lines, each containing $ 3 $ integers, representing the initial image matrix.\n- Three lines, each containing $ 3 $ integers, representing the target image matrix.", "outputFormat": "Output the shortest, lexicographically smallest **non-empty** operation sequence. If there is no solution, or if the shortest sequence would have length greater than $ 10^8 $, output `Poland cannot into space!!!`.", "hint": "The string length does not exceed $ 10^8 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "图像变换", "background": null, "description": "给定 $3$ 行 $3$ 列的图像各像素点灰度值，给定最终图像，求最短、字典序最小的**非空**操作序列。\n\n其中，可能的操作及对应字符有如下四种：\n\n`A`：顺时针旋转 $90$ 度；\n\n`B`：逆时针旋转 $90$ 度；\n\n`C`：左右翻转；\n\n`D`：上下翻转。", "inputFormat": "一个矩阵，表示初始的图像。\n\n一个矩阵，表示最终的图像。", "outputFormat": "最短、字典序最小的**非空**操作序列，保证长度不超过 $10^8$，不保证有解。\n\n若长度超过 $10^8$ 无解则输出 `Poland cannot into space!!!` 。", "hint": "字符串长度不超过 $10^8$。", "locale": "zh-CN"}}}
{"pid": "P2632", "type": "P", "difficulty": 5, "samples": [["4 4 \n0 0 10 10 \n0 10 10 0 \n0.1 0.3 0.6 0.8 \n0.1 0.3 0.6 0.8", "19.638"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论", "生成树"], "title": "Explorer", "background": "提示：本题数据较水，通过本题不代表程序/做法完全正确。", "description": "给出两条直线，上面分别有 $n,m$ 个点，求这 $n+m$ 个点组成的最小生成树。", "inputFormat": "输入包括 $5$ 行。 \n\n第一行为 $n$ 和 $m$。\n\n第二行为四个整数 $x_a,y_a,x_b,y_b$。\n\n第三行为四个整数 $x_c,y_c,x_d,y_d$。 \n\n第四行为 $n$ 个实数，代表在第一条直线上的 $n$ 个点。对于某个点，用一个实数 $t$ 来表示该点的坐标为 $(t x_a + (1 - t)x_b, t y_a + (1 - t) y_b)$。 \n\n第五行为 $m$ 个实数，代表第二条直线上的 $m$ 个点，表示方法同上。", "outputFormat": "一行一个实数，为其最小生成树长度，四舍五入至三位小数。", "hint": "$1 \\le n,m \\le 100000$，$x_a,y_a,x_b,y_b,x_c,y_c,x_d,y_d$ 的绝对值均小于等于 $10^5$，$0 \\le t \\le 1$。\n\n\n------------\n2024/2/8 添加一组 hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "Explorer", "background": "Hint: The testdata for this problem is relatively weak; passing this problem does not guarantee that your program or approach is entirely correct.", "description": "Given two straight lines with $n, m$ points on them respectively, find the minimum spanning tree formed by these $n + m$ points.", "inputFormat": "The input consists of $5$ lines.\n\n- The first line contains $n$ and $m$.\n- The second line contains four integers $x_a,y_a,x_b,y_b$.\n- The third line contains four integers $x_c,y_c,x_d,y_d$.\n- The fourth line contains $n$ real numbers, representing $n$ points on the first line. For a point, a real number $t$ indicates that the coordinates of the point are $(t x_a + (1 - t) x_b, t y_a + (1 - t) y_b)$.\n- The fifth line contains $m$ real numbers, representing $m$ points on the second line, in the same manner as above.", "outputFormat": "Output a single real number on one line: the length of the minimum spanning tree, rounded to three decimal places.", "hint": "Constraints: $1 \\le n,m \\le 100000$, and the absolute values of $x_a,y_a,x_b,y_b,x_c,y_c,x_d,y_d$ are all less than or equal to $10^5$. $0 \\le t \\le 1$.\n\n2024/2/8: Added one hack testdata.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Explorer", "background": "提示：本题数据较水，通过本题不代表程序/做法完全正确。", "description": "给出两条直线，上面分别有 $n,m$ 个点，求这 $n+m$ 个点组成的最小生成树。", "inputFormat": "输入包括 $5$ 行。 \n\n第一行为 $n$ 和 $m$。\n\n第二行为四个整数 $x_a,y_a,x_b,y_b$。\n\n第三行为四个整数 $x_c,y_c,x_d,y_d$。 \n\n第四行为 $n$ 个实数，代表在第一条直线上的 $n$ 个点。对于某个点，用一个实数 $t$ 来表示该点的坐标为 $(t x_a + (1 - t)x_b, t y_a + (1 - t) y_b)$。 \n\n第五行为 $m$ 个实数，代表第二条直线上的 $m$ 个点，表示方法同上。", "outputFormat": "一行一个实数，为其最小生成树长度，四舍五入至三位小数。", "hint": "$1 \\le n,m \\le 100000$，$x_a,y_a,x_b,y_b,x_c,y_c,x_d,y_d$ 的绝对值均小于等于 $10^5$，$0 \\le t \\le 1$。\n\n\n------------\n2024/2/8 添加一组 hack 数据。", "locale": "zh-CN"}}}
{"pid": "P2633", "type": "P", "difficulty": 6, "samples": [["8 5\n105 2 9 3 8 5 7 7\n1 2\n1 3\n1 4\n3 5\n3 6\n3 7\n4 8\n2 5 1\n0 5 2\n10 5 3\n11 5 4\n110 8 2", "2\n8\n9\n105\n7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "线段树", "最近公共祖先 LCA", "可持久化线段树", "可持久化", "洛谷月赛"], "title": "Count on a tree", "background": "", "description": "给定一棵 $n$ 个节点的树，每个点有一个权值。有 $m$ 个询问，每次给你 $u,v,k$，你需要回答 $u \\text{ xor last}$ 和 $v$ 这两个节点间第 $k$ 小的点权。  \n\n其中 $\\text{last}$ 是上一个询问的答案，定义其初始为 $0$，即第一个询问的 $u$ 是明文。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行有 $n$ 个整数，其中第 $i$ 个整数表示点 $i$ 的权值。\n\n后面 $n-1$ 行每行两个整数 $x,y$，表示点 $x$ 到点 $y$ 有一条边。\n\n最后 $m$ 行每行三个整数 $u,v,k$，表示一组询问。\n", "outputFormat": "$m$ 行，每行一个正整数表示每个询问的答案。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n,m \\le 10^5$，点权在 $[1, 2 ^ {31} - 1]$ 之间。\n\n暴力自重。。。\n\n来源：bzoj2588 Spoj10628.\n\n本题数据为洛谷自造数据，使用 [CYaRon](https://github.com/luogu-dev/cyaron) 耗时 5 分钟完成数据制作。\n", "locale": "zh-CN", "translations": {"en": {"title": "Count on a tree", "background": "", "description": "Given a tree with $n$ nodes, each node has a weight. There are $m$ queries. For each query, you are given $u, v, k$, and you need to answer the $k$-th smallest node weight on the path between $u \\text{ xor last}$ and $v$.\n\nHere, $\\text{last}$ is the answer to the previous query, initially defined as $0$, i.e., in the first query, $u$ is not xored.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe second line contains $n$ integers, where the $i$-th integer denotes the weight of node $i$.\n\nEach of the next $n - 1$ lines contains two integers $x, y$, indicating that there is an edge between node $x$ and node $y$.\n\nEach of the last $m$ lines contains three integers $u, v, k$, representing one query.", "outputFormat": "Output $m$ lines, each containing a positive integer, which is the answer to each query.", "hint": "Constraints:  \nFor $100\\%$ of the testdata, $1 \\le n, m \\le 10^5$, and node weights are in $[1, 2 ^ {31} - 1]$.\n\nPlease refrain from brute force...\n\nSource: bzoj2588 Spoj10628.\n\nThe testdata for this problem is self-made by Luogu, generated using [CYaRon](https://github.com/luogu-dev/cyaron) in 5 minutes.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Count on a tree", "background": "", "description": "给定一棵 $n$ 个节点的树，每个点有一个权值。有 $m$ 个询问，每次给你 $u,v,k$，你需要回答 $u \\text{ xor last}$ 和 $v$ 这两个节点间第 $k$ 小的点权。  \n\n其中 $\\text{last}$ 是上一个询问的答案，定义其初始为 $0$，即第一个询问的 $u$ 是明文。\n", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行有 $n$ 个整数，其中第 $i$ 个整数表示点 $i$ 的权值。\n\n后面 $n-1$ 行每行两个整数 $x,y$，表示点 $x$ 到点 $y$ 有一条边。\n\n最后 $m$ 行每行三个整数 $u,v,k$，表示一组询问。\n", "outputFormat": "$m$ 行，每行一个正整数表示每个询问的答案。\n", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n,m \\le 10^5$，点权在 $[1, 2 ^ {31} - 1]$ 之间。\n\n暴力自重。。。\n\n来源：bzoj2588 Spoj10628.\n\n本题数据为洛谷自造数据，使用 [CYaRon](https://github.com/luogu-dev/cyaron) 耗时 5 分钟完成数据制作。\n", "locale": "zh-CN"}}}
{"pid": "P2634", "type": "P", "difficulty": 4, "samples": [["5\n1 2 1\n1 3 2\n1 4 1\n2 5 3", "13/25"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "点分治", "集训队互测"], "title": "[国家集训队] 聪聪可可", "background": "", "description": "聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。\n\n他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画 $n$ 个“点”，并用 $n-1$ 条“边”把这 $n$ 个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随机选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是 $3$ 的倍数，则判聪聪赢，否则可可赢。\n\n聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。\n", "inputFormat": "输入的第 $1$ 行包含 $1$ 个正整数 $n$。后面 $n-1$ 行，每行 $3$ 个整数 $x,y,w$，表示 $x$ 号点和 $y$ 号点之间有一条边，上面的数是 $w$。\n", "outputFormat": "以即约分数形式输出这个概率（即 `a/b` 的形式，其中 $a$ 和 $b$ 必须互质。如果概率为 $1$，输出 `1/1`）。\n", "hint": "【样例说明】\n\n$13$ 组点对分别是 $(1,1)$，$(2,2)$，$(2,3)$，$(2,5)$，$(3,2)$，$(3,3)$，$(3,4)$，$(3,5)$，$(4,3)$，$(4,4)$，$(5,2)$，$(5,3)$，$(5,5)$。\n\n【数据规模】\n\n对于 $100\\%$ 的数据，$n\\leq 2 \\times 10^4$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] Congcong and Keke", "background": "", "description": "Congcong and Keke are brothers who often fight over trivial things, such as when only one ice pop is left at home and they both want it, or they both want to use the computer (but there is only one). Normally they would resolve it with rock-paper-scissors, but they are bored of that simple game.\n\nTheir father, annoyed by their arguments, invented a new game: he draws $n$ “points” on paper and uses $n - 1$ “edges” to connect them so that the $n$ “points” are connected (this is a tree). Each “edge” has a number on it. Then Congcong and Keke each randomly choose one point (they cannot see the tree when choosing). If the sum of the numbers on all edges along the path between the two chosen points is a multiple of $3$, Congcong wins; otherwise, Keke wins.\n\nCongcong likes thinking about problems. After each game, he carefully studies the tree and wants to know his winning probability for this graph. Please help compute this value to verify Congcong’s answer.", "inputFormat": "The first line contains a positive integer $n$. The next $n - 1$ lines each contain $3$ integers $x, y, w$, indicating there is an edge between node $x$ and node $y$ with number $w$.", "outputFormat": "Output the probability as an irreducible fraction in the form `a/b`, where $a$ and $b$ are coprime. If the probability is $1$, output `1/1`.", "hint": "Sample Explanation:\n\nThere are $13$ ordered pairs: $(1, 1)$, $(2, 2)$, $(2, 3)$, $(2, 5)$, $(3, 2)$, $(3, 3)$, $(3, 4)$, $(3, 5)$, $(4, 3)$, $(4, 4)$, $(5, 2)$, $(5, 3)$, $(5, 5)$.\n\nConstraints:\n\nFor $100\\%$ of the testdata, $n \\leq 2 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] 聪聪可可", "background": "", "description": "聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。\n\n他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画 $n$ 个“点”，并用 $n-1$ 条“边”把这 $n$ 个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随机选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是 $3$ 的倍数，则判聪聪赢，否则可可赢。\n\n聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。\n", "inputFormat": "输入的第 $1$ 行包含 $1$ 个正整数 $n$。后面 $n-1$ 行，每行 $3$ 个整数 $x,y,w$，表示 $x$ 号点和 $y$ 号点之间有一条边，上面的数是 $w$。\n", "outputFormat": "以即约分数形式输出这个概率（即 `a/b` 的形式，其中 $a$ 和 $b$ 必须互质。如果概率为 $1$，输出 `1/1`）。\n", "hint": "【样例说明】\n\n$13$ 组点对分别是 $(1,1)$，$(2,2)$，$(2,3)$，$(2,5)$，$(3,2)$，$(3,3)$，$(3,4)$，$(3,5)$，$(4,3)$，$(4,4)$，$(5,2)$，$(5,3)$，$(5,5)$。\n\n【数据规模】\n\n对于 $100\\%$ 的数据，$n\\leq 2 \\times 10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P2635", "type": "P", "difficulty": 5, "samples": [["1*456??\n111111145678", "matched\n4"], ["1*456\n1111111452", "not matched"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "数学"], "title": "带通配符的字符串匹配", "background": "通配符是一类键盘字符，当我们不知道真正字符或者不想键入完整名字时，常常使用通配符代替一个或多个真正字符。通配符有问号(?)和星号(\\*)等，其中，“?”可以代替一个字符，而“\\*”可以代替零个或多个字符。\n\n现又定义一个通配符“@”，规定在一个字符串中，“@”代替的字符个数是固定的。\n", "description": "用户在使用“@”时，当然希望输入的“@”越少越好。现在给出一个带有“?”“\\*”通配符的字符串和一个原字符串，要求首先判断通配符字符串与原字符串是否匹配，若匹配则求出将原通配符字符串中的“?”“\\*”字符替换为“@”且保证修改后的通配符字符串与原字符串匹配，最少需要多少个通配符“@”。\n", "inputFormat": "输入文件第一行为一个字符串，描述通配符字符串；\n\n第二行也为一个字符串，描述原字符串。\n", "outputFormat": "输出文件第一行为一个字符串，若通配符字符串与原字符串能够匹配则输出“matched”，并在接下来的一行输出一个整数，描述最少需要的通配符“@”的数量；若不匹配则输出“not matched”。\n", "hint": "【样例说明1】\n\n两字符串显然可以匹配，通配符字符串1\\*456??可以替换为1@@@456@，最少需要4个“@”，其中每个“@”代替两个字符，可以证明，此为最优情况。\n\n通配符字符串1\\*456??也可以替换为1@@@@@@456@@，此时每个“@”代替一个字符，需要8个“@”，没有上面的情况优。\n\n\n【样例说明2】\n\n两字符串不可以匹配。\n\n\n【数据范围】\n\n对于100%的数据，字符串的长度均小于3000。\n\n保证原字符串中仅出现字母和数字，通配符字符串中仅出现字母、数字和通配符“?”“\\*”，且保证匹配方式唯一。\n", "locale": "zh-CN", "translations": {"en": {"title": "String Matching with Wildcards", "background": "Wildcards are keyboard characters used to stand in for one or more real characters when we do not know the exact characters or do not want to type the full name. Common wildcards include the question mark (?) and the asterisk (*), where \"?\" stands for exactly one character and \"*\" stands for zero or more characters.\n\nWe further define a wildcard \"@\", with the rule that within a single string, each \"@\" stands for the same fixed number of characters.", "description": "Users naturally want to use as few \"@\" as possible. You are given a wildcard pattern that may contain \"?\" and \"*\" and a target string. First, determine whether the pattern matches the target string. If it matches, replace every \"?\" and \"*\" in the original pattern with \"@\" so that the modified pattern still matches the target string, and find the minimum number of \"@\" required. All \"@\" in the modified pattern must represent the same fixed number of characters.", "inputFormat": "The first line contains a string, the wildcard pattern.\n\nThe second line contains a string, the original target string.", "outputFormat": "Output a single string on the first line: if the pattern matches the target, output \"matched\", and on the next line output an integer giving the minimum number of \"@\" required. If the pattern does not match the target, output \"not matched\".", "hint": "Sample Explanation 1:\nThe two strings clearly match. The wildcard pattern 1*456?? can be replaced by 1@@@456@, requiring 4 \"@\" in total, where each \"@\" replaces two characters. This can be proven optimal.\n\nThe wildcard pattern 1*456?? can also be replaced by 1@@@@@@456@@, where each \"@\" replaces one character, requiring 8 \"@\", which is not better than the previous case.\n\nSample Explanation 2:\nThe two strings do not match.\n\nConstraints:\n- For 100% of the testdata, the length of each string is less than 3000.\n- The original string contains only letters and digits. The wildcard pattern contains only letters, digits, and the wildcards \"?\" and \"*\". The matching, if it exists, is unique.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "带通配符的字符串匹配", "background": "通配符是一类键盘字符，当我们不知道真正字符或者不想键入完整名字时，常常使用通配符代替一个或多个真正字符。通配符有问号(?)和星号(\\*)等，其中，“?”可以代替一个字符，而“\\*”可以代替零个或多个字符。\n\n现又定义一个通配符“@”，规定在一个字符串中，“@”代替的字符个数是固定的。\n", "description": "用户在使用“@”时，当然希望输入的“@”越少越好。现在给出一个带有“?”“\\*”通配符的字符串和一个原字符串，要求首先判断通配符字符串与原字符串是否匹配，若匹配则求出将原通配符字符串中的“?”“\\*”字符替换为“@”且保证修改后的通配符字符串与原字符串匹配，最少需要多少个通配符“@”。\n", "inputFormat": "输入文件第一行为一个字符串，描述通配符字符串；\n\n第二行也为一个字符串，描述原字符串。\n", "outputFormat": "输出文件第一行为一个字符串，若通配符字符串与原字符串能够匹配则输出“matched”，并在接下来的一行输出一个整数，描述最少需要的通配符“@”的数量；若不匹配则输出“not matched”。\n", "hint": "【样例说明1】\n\n两字符串显然可以匹配，通配符字符串1\\*456??可以替换为1@@@456@，最少需要4个“@”，其中每个“@”代替两个字符，可以证明，此为最优情况。\n\n通配符字符串1\\*456??也可以替换为1@@@@@@456@@，此时每个“@”代替一个字符，需要8个“@”，没有上面的情况优。\n\n\n【样例说明2】\n\n两字符串不可以匹配。\n\n\n【数据范围】\n\n对于100%的数据，字符串的长度均小于3000。\n\n保证原字符串中仅出现字母和数字，通配符字符串中仅出现字母、数字和通配符“?”“\\*”，且保证匹配方式唯一。\n", "locale": "zh-CN"}}}
{"pid": "P2636", "type": "P", "difficulty": 3, "samples": [["2\nYSLTRIQXSHTQTR\n1 2\n3", "FULLSPEEDAHEAD"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串"], "title": "密码破解者", "background": "1941 年 12 月 7 日凌晨，珍珠港驻守美军通信员截获了一份日军电报。早上 8 时日军的正式进攻就会展开，为了减少太平洋战场伤亡，你被指派去协助破解密文。情报部门已得知了密文加密的层数和每层加密的方法。由于时间紧急，你只剩 1 秒的时间来破解日军的密文。\n", "description": "据情报得知日军共有 $3$ 种加密方式：\n\n一、栅栏密码：\n\n所谓栅栏密码，就是把要加密的明文分成 $L$ 个一组，然后把每组的第 $1$ 个字连起来，形成一段无规律的话。一般比较常见的是 $2$ 栏的棚栏密码。 \n\n比如明文：`THERE IS A CIPHER`  \n去掉空格后变为：`THEREISACIPHER`  \n两个一组，得到：`TH ER EI SA CI PH ER`  \n先取出第一个字母：`TEESCPE`  \n再取出第二个字母：`HRIAIHR`  \n连在一起就是：`TEESCPEHRIAIHR`  \n\n这样就得到我们需要的密码了。  \n\n但也可能有更多的栏数。\n\n注：若明文长度不能整除栏数，则分组后剩下的单独为一组，如：\n\n`THERE IS A CIPHER`，$3$ 栏加密分组为：`THE REI SAC IPH ER`\n\n先后取出第一二三个字母(最后一组只能取前两个)，加密后为: `TRSIE HEAPR EICH`（去掉空格）。\n\n二、维吉尼亚(Vigenère)密码：\n\n维吉尼亚密码首先应用了“密钥”的思想，其在密码届具有十分重要的意义。\n\n在密码学中，我们称需要加密的信息为明文，用 $M$ 表示；称加密后的信息为密文，用 $C$ 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 $k$。在 Vigenère 密码中，密钥 $k$ 是一个字母串，$k=k_1k_2\\cdots k_n$。当明文 $M=m_1m_2\\cdots m_n$ 时，得到的密文 $C=c_1c_2\\cdots c_n$，其中 $c_i=m_i\\oplus k_i$，运算 $\\oplus$ 的规则如下表所示：\n\nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n\nA -A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n\nB -B C D E F G H I J K L M N O P Q R S T U V W X Y Z A\n\nC -C D E F G H I J K L M N O P Q R S T U V W X Y Z A B\n\nD -D E F G H I J K L M N O P Q R S T U V W X Y Z A B C\n\nE -E F G H I J K L M N O P Q R S T U V W X Y Z A B C D\n\nF -F G H I J K L M N O P Q R S T U V W X Y Z A B C D E\n\nG -G H I J K L M N O P Q R S T U V W X Y Z A B C D E F\n\nH -H I J K L M N O P Q R S T U V W X Y Z A B C D E F G\n\nI -I J K L M N O P Q R S T U V W X Y Z A B C D E F G H\n\nJ -J K L M N O P Q R S T U V W X Y Z A B C D E F G H I\n\nK -K L M N O P Q R S T U V W X Y Z A B C D E F G H I J\n\nL -L M N O P Q R S T U V W X Y Z A B C D E F G H I J K\n\nM -M N O P Q R S T U V W X Y Z A B C D E F G H I J K L\n\nN -N O P Q R S T U V W X Y Z A B C D E F G H I J K L M\n\nO -O P Q R S T U V W X Y Z A B C D E F G H I J K L M N\n\nP -P Q R S T U V W X Y Z A B C D E F G H I J K L M N O\n\nQ -Q R S T U V W X Y Z A B C D E F G H I J K L M N O P\n\nR -R S T U V W X Y Z A B C D E F G H I J K L M N O P Q\n\nS -S T U V W X Y Z A B C D E F G H I J K L M N O P Q R\n\nT -T U V W X Y Z A B C D E F G H I J K L M N O P Q R S\n\nU -U V W X Y Z A B C D E F G H I J K L M N O P Q R S T\n\nV -V W X Y Z A B C D E F G H I J K L M N O P Q R S T U\n\nW -W X Y Z A B C D E F G H I J K L M N O P Q R S T U V\n\nX -X Y Z A B C D E F G H I J K L M N O P Q R S T U V W\n\nY -Y Z A B C D E F G H I J K L M N O P Q R S T U V W X\n\nZ -Z A B C D E F G H I J K L M N O P Q R S T U V W X Y\n\n\nVigenère 加密在操作时需要注意： \n\n当明文 M 的长度大于密钥 k 的长度时，将密钥 k 重复使用。 \n\n例如，明文 M=Helloworld，密钥 k=abc 时，密文 C=Hfnlpyosnd。 \n\n\n三、QWE键盘码：\n\n随着键盘普及，也出现了相应的键盘码。\n\n\n这是一个常见的键盘,在左边字母区有三行字母分别为：\n\nQWERTYUIOP\n\nASDFGHJKL\n\nZXCVBNM\n\n从第一排第一列开始分别用Q替代A，W替代B……M替代Z以此类推。\n\n如 CODING 加密后即为 EGROFU.\n\n这对于现在来说算是简单的加密方法，但对于键盘不普及的二战时期却是一大难题。\n", "inputFormat": "输入第一行为一个正整数N 表示截获的密文共用了N重密码加密。\n\n第二行为一个字符串S表示加密后的密文。\n\n以下3-N+2行共N行每行开头一个正整数K(1<=K<=3)表示对应的加密方式。\n\n给出的加密方式按顺序给出，即给出的第I重加密为实际加密过程的第I重(1<=I<=N)。\n\n若K=1则表示用栅栏密码加密，之后一个正整数L表示加密所用栏数。\n\n若K=2则表示用维吉尼亚码加密，之后一个字符串T表示密钥。\n\n若K=3则表示用QWE键盘码加密。\n", "outputFormat": "共一行。一个字符串，表示破解N重加密后的明文。\n", "hint": "n<=1000\n", "locale": "zh-CN", "translations": {"en": {"title": "Codebreaker", "background": "In the early morning of December 7, 1941, a U.S. Army signalman stationed at Pearl Harbor intercepted a Japanese telegram. The formal attack would begin at 8 a.m. To reduce casualties in the Pacific theater, you have been assigned to help break the ciphertext. The intelligence department already knows the number of encryption layers and the method used in each layer. Due to the urgency, you have only 1 second to crack the Japanese ciphertext.", "description": "According to intelligence, the Japanese use $3$ kinds of encryption methods:\n\n1. Rail Fence Cipher:\n\nThe so‑called rail fence cipher divides the plaintext into groups of $L$ characters, then concatenates the first character of each group, followed by the second character of each group, and so on, forming a seemingly irregular string. The most common case is the $2$‑rail rail fence cipher.\n\nFor example, plaintext: `THERE IS A CIPHER`  \nAfter removing spaces: `THEREISACIPHER`  \nGroup by two: `TH ER EI SA CI PH ER`  \nTake the first character of each group: `TEESCPE`  \nThen the second character of each group: `HRIAIHR`  \nConcatenate them: `TEESCPEHRIAIHR`.\n\nThis yields the ciphertext we need.\n\nThere may also be more rails.\n\nNote: If the plaintext length is not divisible by the number of rails, the leftover characters form a shorter group on their own. For example:\n\nFor `THERE IS A CIPHER`, the $3$‑rail grouping is: `THE REI SAC IPH ER`.\n\nTake the first, second, and third characters in order (the last group only has the first two). The encrypted text is: `TRSIE HEAPR EICH` (remove spaces).\n\n2. Vigenère Cipher:\n\nThe Vigenère cipher first introduced the idea of a “key,” which is of great significance in cryptography.\n\nIn cryptography, the information to be encrypted is called the plaintext, denoted by $M$; the encrypted information is called the ciphertext, denoted by $C$; and the key is a parameter, i.e., the data input to the algorithm that transforms plaintext into ciphertext or ciphertext into plaintext, denoted by $k$. In the Vigenère cipher, the key $k$ is a string of letters, $k = k_1 k_2 \\cdots k_n$. When the plaintext is $M = m_1 m_2 \\cdots m_n$, the resulting ciphertext is $C = c_1 c_2 \\cdots c_n$, where $c_i = m_i \\oplus k_i$. The operation $\\oplus$ follows the table below:\n\nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n\nA -A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n\nB -B C D E F G H I J K L M N O P Q R S T U V W X Y Z A\n\nC -C D E F G H I J K L M N O P Q R S T U V W X Y Z A B\n\nD -D E F G H I J K L M N O P Q R S T U V W X Y Z A B C\n\nE -E F G H I J K L M N O P Q R S T U V W X Y Z A B C D\n\nF -F G H I J K L M N O P Q R S T U V W X Y Z A B C D E\n\nG -G H I J K L M N O P Q R S T U V W X Y Z A B C D E F\n\nH -H I J K L M N O P Q R S T U V W X Y Z A B C D E F G\n\nI -I J K L M N O P Q R S T U V W X Y Z A B C D E F G H\n\nJ -J K L M N O P Q R S T U V W X Y Z A B C D E F G H I\n\nK -K L M N O P Q R S T U V W X Y Z A B C D E F G H I J\n\nL -L M N O P Q R S T U V W X Y Z A B C D E F G H I J K\n\nM -M N O P Q R S T U V W X Y Z A B C D E F G H I J K L\n\nN -N O P Q R S T U V W X Y Z A B C D E F G H I J K L M\n\nO -O P Q R S T U V W X Y Z A B C D E F G H I J K L M N\n\nP -P Q R S T U V W X Y Z A B C D E F G H I J K L M N O\n\nQ -Q R S T U V W X Y Z A B C D E F G H I J K L M N O P\n\nR -R S T U V W X Y Z A B C D E F G H I J K L M N O P Q\n\nS -S T U V W X Y Z A B C D E F G H I J K L M N O P Q R\n\nT -T U V W X Y Z A B C D E F G H I J K L M N O P Q R S\n\nU -U V W X Y Z A B C D E F G H I J K L M N O P Q R S T\n\nV -V W X Y Z A B C D E F G H I J K L M N O P Q R S T U\n\nW -W X Y Z A B C D E F G H I J K L M N O P Q R S T U V\n\nX -X Y Z A B C D E F G H I J K L M N O P Q R S T U V W\n\nY -Y Z A B C D E F G H I J K L M N O P Q R S T U V W X\n\nZ -Z A B C D E F G H I J K L M N O P Q R S T U V W X Y\n\nNotes for operating Vigenère encryption:\n\nWhen the length of plaintext $M$ is greater than the length of key $k$, repeat the key $k$ cyclically.\n\nFor example, plaintext $M = Helloworld$, key $k = abc$, ciphertext $C = Hfnlpyosnd$.\n\n3. QWE Keyboard Code:\n\nWith the popularization of keyboards, corresponding keyboard codes also appeared.\n\nThis is a common keyboard. On the left letter area, there are three rows of letters:\n\nQWERTYUIOP\n\nASDFGHJKL\n\nZXCVBNM\n\nStarting from the first row and the first column, replace A with Q, B with W, …, Z with M, and so on.\n\nFor example, CODING is encrypted as EGROFU.\n\nThis is a simple encryption method today, but during World War II, when keyboards were not widespread, it was a big challenge.", "inputFormat": "- The first line contains a positive integer $N$, the number of encryption layers applied to the intercepted ciphertext.\n- The second line contains a string $S$, the ciphertext after encryption.\n- The next $N$ lines (i.e., lines $3$ to $N+2$) each begin with a positive integer $K$ with $1 \\le K \\le 3$, indicating the encryption method used for that layer.\n- The methods are listed in order: the $I$‑th given method is the actual $I$‑th encryption layer in the process, where $1 \\le I \\le N$.\n- If $K = 1$, the rail fence cipher was used; an integer $L$ follows, the number of rails used for encryption.\n- If $K = 2$, the Vigenère cipher was used; a string $T$ follows, which is the key.\n- If $K = 3$, the QWE keyboard code was used.", "outputFormat": "Output one line: a string representing the plaintext after decrypting all $N$ layers of encryption.", "hint": "$N \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "密码破解者", "background": "1941 年 12 月 7 日凌晨，珍珠港驻守美军通信员截获了一份日军电报。早上 8 时日军的正式进攻就会展开，为了减少太平洋战场伤亡，你被指派去协助破解密文。情报部门已得知了密文加密的层数和每层加密的方法。由于时间紧急，你只剩 1 秒的时间来破解日军的密文。\n", "description": "据情报得知日军共有 $3$ 种加密方式：\n\n一、栅栏密码：\n\n所谓栅栏密码，就是把要加密的明文分成 $L$ 个一组，然后把每组的第 $1$ 个字连起来，形成一段无规律的话。一般比较常见的是 $2$ 栏的棚栏密码。 \n\n比如明文：`THERE IS A CIPHER`  \n去掉空格后变为：`THEREISACIPHER`  \n两个一组，得到：`TH ER EI SA CI PH ER`  \n先取出第一个字母：`TEESCPE`  \n再取出第二个字母：`HRIAIHR`  \n连在一起就是：`TEESCPEHRIAIHR`  \n\n这样就得到我们需要的密码了。  \n\n但也可能有更多的栏数。\n\n注：若明文长度不能整除栏数，则分组后剩下的单独为一组，如：\n\n`THERE IS A CIPHER`，$3$ 栏加密分组为：`THE REI SAC IPH ER`\n\n先后取出第一二三个字母(最后一组只能取前两个)，加密后为: `TRSIE HEAPR EICH`（去掉空格）。\n\n二、维吉尼亚(Vigenère)密码：\n\n维吉尼亚密码首先应用了“密钥”的思想，其在密码届具有十分重要的意义。\n\n在密码学中，我们称需要加密的信息为明文，用 $M$ 表示；称加密后的信息为密文，用 $C$ 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 $k$。在 Vigenère 密码中，密钥 $k$ 是一个字母串，$k=k_1k_2\\cdots k_n$。当明文 $M=m_1m_2\\cdots m_n$ 时，得到的密文 $C=c_1c_2\\cdots c_n$，其中 $c_i=m_i\\oplus k_i$，运算 $\\oplus$ 的规则如下表所示：\n\nA B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n\nA -A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n\nB -B C D E F G H I J K L M N O P Q R S T U V W X Y Z A\n\nC -C D E F G H I J K L M N O P Q R S T U V W X Y Z A B\n\nD -D E F G H I J K L M N O P Q R S T U V W X Y Z A B C\n\nE -E F G H I J K L M N O P Q R S T U V W X Y Z A B C D\n\nF -F G H I J K L M N O P Q R S T U V W X Y Z A B C D E\n\nG -G H I J K L M N O P Q R S T U V W X Y Z A B C D E F\n\nH -H I J K L M N O P Q R S T U V W X Y Z A B C D E F G\n\nI -I J K L M N O P Q R S T U V W X Y Z A B C D E F G H\n\nJ -J K L M N O P Q R S T U V W X Y Z A B C D E F G H I\n\nK -K L M N O P Q R S T U V W X Y Z A B C D E F G H I J\n\nL -L M N O P Q R S T U V W X Y Z A B C D E F G H I J K\n\nM -M N O P Q R S T U V W X Y Z A B C D E F G H I J K L\n\nN -N O P Q R S T U V W X Y Z A B C D E F G H I J K L M\n\nO -O P Q R S T U V W X Y Z A B C D E F G H I J K L M N\n\nP -P Q R S T U V W X Y Z A B C D E F G H I J K L M N O\n\nQ -Q R S T U V W X Y Z A B C D E F G H I J K L M N O P\n\nR -R S T U V W X Y Z A B C D E F G H I J K L M N O P Q\n\nS -S T U V W X Y Z A B C D E F G H I J K L M N O P Q R\n\nT -T U V W X Y Z A B C D E F G H I J K L M N O P Q R S\n\nU -U V W X Y Z A B C D E F G H I J K L M N O P Q R S T\n\nV -V W X Y Z A B C D E F G H I J K L M N O P Q R S T U\n\nW -W X Y Z A B C D E F G H I J K L M N O P Q R S T U V\n\nX -X Y Z A B C D E F G H I J K L M N O P Q R S T U V W\n\nY -Y Z A B C D E F G H I J K L M N O P Q R S T U V W X\n\nZ -Z A B C D E F G H I J K L M N O P Q R S T U V W X Y\n\n\nVigenère 加密在操作时需要注意： \n\n当明文 M 的长度大于密钥 k 的长度时，将密钥 k 重复使用。 \n\n例如，明文 M=Helloworld，密钥 k=abc 时，密文 C=Hfnlpyosnd。 \n\n\n三、QWE键盘码：\n\n随着键盘普及，也出现了相应的键盘码。\n\n\n这是一个常见的键盘,在左边字母区有三行字母分别为：\n\nQWERTYUIOP\n\nASDFGHJKL\n\nZXCVBNM\n\n从第一排第一列开始分别用Q替代A，W替代B……M替代Z以此类推。\n\n如 CODING 加密后即为 EGROFU.\n\n这对于现在来说算是简单的加密方法，但对于键盘不普及的二战时期却是一大难题。\n", "inputFormat": "输入第一行为一个正整数N 表示截获的密文共用了N重密码加密。\n\n第二行为一个字符串S表示加密后的密文。\n\n以下3-N+2行共N行每行开头一个正整数K(1<=K<=3)表示对应的加密方式。\n\n给出的加密方式按顺序给出，即给出的第I重加密为实际加密过程的第I重(1<=I<=N)。\n\n若K=1则表示用栅栏密码加密，之后一个正整数L表示加密所用栏数。\n\n若K=2则表示用维吉尼亚码加密，之后一个字符串T表示密钥。\n\n若K=3则表示用QWE键盘码加密。\n", "outputFormat": "共一行。一个字符串，表示破解N重加密后的明文。\n", "hint": "n<=1000\n", "locale": "zh-CN"}}}
{"pid": "P2637", "type": "P", "difficulty": 1, "samples": [["5 4\n2\n8\n10\n7", "7 21"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "2008", "USACO", "枚举"], "title": "[USACO08NOV] 第一次，第二次，成交！Going Once, Going Twice, Gone! B", "background": null, "description": "因为奶牛们的节食运动给 FJ 余下了一大批干草无法处理，所以他准备要开一个拍卖会去出售他的干草。\n\n他有 $n$ 批干草。他的客户有 $m$ 个，都是和他一样的农夫。第 $i$ 名农夫会告诉 FJ 他会为 FJ 的每批干草付 $p_i$ 的钱。每个农夫都想买（也只想买）FJ 的一批草料。\n\n为了确保农夫们不会互相嫉妒，所以 FJ 决定要以一个固定的价格出售他的草料。每一个出价大于等于 FJ 的要价的农夫将会买到草料。\n\n请你帮助 FJ 找出能让他卖出最多的钱的最低的单批草料的售价。", "inputFormat": "第一行：两个被空格隔开的整数 $n$ 和 $m$。\n\n第二行到第 $m+1$ 行：第 $i+1$ 行只包含一个整数 $p_i$。", "outputFormat": "共一行，包含由空格隔开的两个整数：FJ 能出的每批草料的最低价格，以及他能赚到的最多的钱。", "hint": "### 样例解释\nFJ 有 $5$ 批草料，$4$ 个农夫想要购买。他们出价分别为：每批草料为 $2$，$8$，$10$ 和 $7$。\n\nFJ 应该把价格设定为 $7$，这样会有 $3$ 个农夫会付钱买草料，FJ 自己会挣到 $21$ 的钱。\n\n### 数据规模与约定\n对于 $100\\%$ 的数据，$1\\leq m, n\\leq 1000$，$1\\leq p_i\\leq 1,000,000$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08NOV] Going Once, Going Twice, Gone! B", "background": "", "description": "Because of the cows’ dieting campaign, FJ has a large amount of leftover hay he cannot use, so he plans to hold an auction to sell it.\n\nHe has $n$ batches of hay. He has $m$ customers, all of whom are farmers like him. Farmer $i$ says he will pay $p_i$ for each batch of FJ’s hay. Every farmer wants to buy exactly one batch (and only one).\n\nTo make sure the farmers do not envy each other, FJ decides to sell at a single fixed price. Every farmer whose bid is greater than or equal to FJ’s asking price will buy a batch.\n\nPlease help FJ find the lowest per-batch price that earns him the maximum total revenue.", "inputFormat": "- The first line contains two integers $n$ and $m$ separated by a space.\n- Lines $2$ through $m+1$: line $i+1$ contains a single integer $p_i$.", "outputFormat": "Output one line with two space-separated integers: the lowest per-batch price FJ should set, and the maximum total revenue he can earn.", "hint": "Sample Explanation  \nFJ has $5$ batches of hay, and $4$ farmers want to buy. Their bids per batch are $2$, $8$, $10$, and $7$.  \nFJ should set the price to $7$. Then $3$ farmers will buy, and FJ will earn $21$.\n\nConstraints  \nFor $100\\%$ of the testdata, $1 \\leq m, n \\leq 1000$, $1 \\leq p_i \\leq 1,000,000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO08NOV] 第一次，第二次，成交！Going Once, Going Twice, Gone! B", "background": null, "description": "因为奶牛们的节食运动给 FJ 余下了一大批干草无法处理，所以他准备要开一个拍卖会去出售他的干草。\n\n他有 $n$ 批干草。他的客户有 $m$ 个，都是和他一样的农夫。第 $i$ 名农夫会告诉 FJ 他会为 FJ 的每批干草付 $p_i$ 的钱。每个农夫都想买（也只想买）FJ 的一批草料。\n\n为了确保农夫们不会互相嫉妒，所以 FJ 决定要以一个固定的价格出售他的草料。每一个出价大于等于 FJ 的要价的农夫将会买到草料。\n\n请你帮助 FJ 找出能让他卖出最多的钱的最低的单批草料的售价。", "inputFormat": "第一行：两个被空格隔开的整数 $n$ 和 $m$。\n\n第二行到第 $m+1$ 行：第 $i+1$ 行只包含一个整数 $p_i$。", "outputFormat": "共一行，包含由空格隔开的两个整数：FJ 能出的每批草料的最低价格，以及他能赚到的最多的钱。", "hint": "### 样例解释\nFJ 有 $5$ 批草料，$4$ 个农夫想要购买。他们出价分别为：每批草料为 $2$，$8$，$10$ 和 $7$。\n\nFJ 应该把价格设定为 $7$，这样会有 $3$ 个农夫会付钱买草料，FJ 自己会挣到 $21$ 的钱。\n\n### 数据规模与约定\n对于 $100\\%$ 的数据，$1\\leq m, n\\leq 1000$，$1\\leq p_i\\leq 1,000,000$。", "locale": "zh-CN"}}}
{"pid": "P2638", "type": "P", "difficulty": 4, "samples": [["2 1 1", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "数学"], "title": "安全系统", "background": null, "description": "特斯拉公司的六位密码被轻松破解后，引发了人们对电动车的安全性能的怀疑。李华听闻后，自己设计了一套密码：\n\n- 假设安全系统中有 $n$ 个储存区，每个储存区最多能存储存 $2$ 种种类不同的信号（可以不储存任何信号）。有 $0$ 和 $1$ 这两种信号，其中 $0$ 有 $a$ 个，$1$ 有 $b$ 个，单独一个 $0$ 或 $1$ 算一个信号。现要将这些信号储存在储存区中，$0$ 和 $1$ **可以不用全部储存**，一个储存区可以存放任意多个 $0$ 和任意多个 $1$。一种不同的储存方案经过李华处理后就将是一串不同的密码。\n\n现在给出 $n,a,b$，求可能的不同储存方案的个数。", "inputFormat": "第一行：共 $3$ 个整数，$n,a,b$。", "outputFormat": "第一行：一个整数，表示方案个数。", "hint": "所有 $9$ 种方案如下：\n\n| 储存区 $1$ | 储存区 $2$ |\n| :----------: | :----------: |\n| $\\verb!NULL!$ | $\\verb!NULL!$ |\n| $0$ | $\\verb!NULL!$ |\n| $1$ | $\\verb!NULL!$ |\n| $\\verb!NULL!$ | $0$ |\n| $\\verb!NULL!$ | $1$ |\n| $0,1$ | $\\verb!NULL!$ |\n| $\\verb!NULL!$ | $0,1$ |\n| $1$ | $0$ |\n| $0$ | $1$ |\n\n对于全部数据，$0 \\le a,b \\le 50$，$1 \\le n \\le 50$ 且 $n+a\\le 50$，$n+b\\le 50$。\n\n---\n\n$\\text{upd 2022.10.22}$：新增加一组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "Security System", "background": "", "description": "After Tesla’s six-digit passcode was easily cracked, people began to doubt the security of electric vehicles. Upon hearing this, Li Hua designed his own passcode system:\n\n- Suppose the security system has $n$ storage units. Each storage unit can hold up to 2 different types of signals (it may also hold none). There are two types of signals, $0$ and $1$, with $a$ copies of $0$ and $b$ copies of $1$ available. A single $0$ or $1$ counts as one signal. We need to store these signals in the storage units. The $0$ and $1$ signals do not have to be all stored; a storage unit may contain any number of $0$’s and any number of $1$’s. Every distinct storage plan, after Li Hua’s processing, will correspond to a distinct passcode.\n\nGiven $n,a,b$, find the number of possible distinct storage plans.", "inputFormat": "The first line contains 3 integers, $n,a,b$.", "outputFormat": "The first line contains an integer, the number of plans.", "hint": "All 9 plans are as follows:\n\n| Storage unit $1$ | Storage unit $2$ |\n| :----------: | :----------: |\n| $\\verb!NULL!$ | $\\verb!NULL!$ |\n| $0$ | $\\verb!NULL!$ |\n| $1$ | $\\verb!NULL!$ |\n| $\\verb!NULL!$ | $0$ |\n| $\\verb!NULL!$ | $1$ |\n| $0,1$ | $\\verb!NULL!$ |\n| $\\verb!NULL!$ | $0,1$ |\n| $1$ | $0$ |\n| $0$ | $1$ |\n\nConstraints: For all testdata, $a,b \\le 50$, $n+a \\le 50$, $n+b \\le 50$.\n\n---\n\n$\\text{upd 2022.10.22}$: A new set of Hack testdata was added.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "安全系统", "background": null, "description": "特斯拉公司的六位密码被轻松破解后，引发了人们对电动车的安全性能的怀疑。李华听闻后，自己设计了一套密码：\n\n- 假设安全系统中有 $n$ 个储存区，每个储存区最多能存储存 $2$ 种种类不同的信号（可以不储存任何信号）。有 $0$ 和 $1$ 这两种信号，其中 $0$ 有 $a$ 个，$1$ 有 $b$ 个，单独一个 $0$ 或 $1$ 算一个信号。现要将这些信号储存在储存区中，$0$ 和 $1$ **可以不用全部储存**，一个储存区可以存放任意多个 $0$ 和任意多个 $1$。一种不同的储存方案经过李华处理后就将是一串不同的密码。\n\n现在给出 $n,a,b$，求可能的不同储存方案的个数。", "inputFormat": "第一行：共 $3$ 个整数，$n,a,b$。", "outputFormat": "第一行：一个整数，表示方案个数。", "hint": "所有 $9$ 种方案如下：\n\n| 储存区 $1$ | 储存区 $2$ |\n| :----------: | :----------: |\n| $\\verb!NULL!$ | $\\verb!NULL!$ |\n| $0$ | $\\verb!NULL!$ |\n| $1$ | $\\verb!NULL!$ |\n| $\\verb!NULL!$ | $0$ |\n| $\\verb!NULL!$ | $1$ |\n| $0,1$ | $\\verb!NULL!$ |\n| $\\verb!NULL!$ | $0,1$ |\n| $1$ | $0$ |\n| $0$ | $1$ |\n\n对于全部数据，$0 \\le a,b \\le 50$，$1 \\le n \\le 50$ 且 $n+a\\le 50$，$n+b\\le 50$。\n\n---\n\n$\\text{upd 2022.10.22}$：新增加一组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P2639", "type": "P", "difficulty": 2, "samples": [["56 4\n15\n19\n20\n21", "56"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2009", "USACO", "背包 DP"], "title": "[USACO09OCT] Bessie's Weight Problem G", "background": null, "description": "Bessie 像她的诸多姊妹一样，因为从 Farmer John 的草地吃了太多美味的草而长出了太多的赘肉。所以 FJ 将她置于一个及其严格的节食计划之中。她每天不能吃多过 $H (5 \\le H \\le 45,000)$ 公斤的干草。 Bessie 只能吃一整捆干草；当她开始吃一捆干草的之后就再也停不下来了。她有一个完整的$N (1 \\le N \\le 500)$ 捆可以给她当作晚餐的干草的清单。她自然想要尽量吃到更多的干草。很自然地，每捆干草只能被吃一次（即使在列表中相同的重量可能出现 $2$ 次，但是这表示的是两捆干草，其中每捆干草最多只能被吃掉一次）。 给定一个列表表示每捆干草的重量 $S_i (1 \\le S_i \\le H)$ , 求 Bessie 不超过节食的限制的前提下可以吃掉多少干草（注意一旦她开始吃一捆干草就会把那一捆干草全部吃完）。", "inputFormat": "第一行有两个由空格隔开的整数 $H$ 和 $N$。\n\n第 $2$ 到第 $N+1$ 行，第 $i+1$ 行是一个单独的整数，表示第 $i$ 捆干草的重量 $S_i$。", "outputFormat": "第一行一个单独的整数表示 Bessie 在限制范围内最多可以吃多少公斤的干草。", "hint": "#### 输入说明\n\n有四捆草，重量分别是 $15,19,20$ 和 $21$。Bessie 在 $56$ 公斤的限制范围内想要吃多少就可以吃多少。\n\n\n#### 输出说明\n\nBessie 可以吃 $3$ 捆干草（重量分别为 $15, 20, 21$）。恰好达到她的 $56$ 公斤的限制。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO09OCT] Bessie's Weight Problem G", "background": "", "description": "Like many of her sisters, Bessie has put on too much weight from eating too much delicious grass from Farmer John’s pasture. So Farmer John has put her on a very strict diet. Each day, she may eat no more than $H (5 \\le H \\le 45,000)$ kilograms of hay. Bessie can eat only whole hay bales; once she starts a bale, she cannot stop until she finishes it. She has a complete list of $N (1 \\le N \\le 500)$ bales that can be served to her for dinner. Naturally, she wants to eat as much hay as possible. Of course, each bale can be eaten at most once (even if the same weight appears $2$ times in the list, that refers to two distinct bales, and each bale can be eaten at most once). Given a list of bale weights $S_i (1 \\le S_i \\le H)$, determine the maximum total amount of hay Bessie can eat without exceeding the diet limit (note that once she starts a bale, she must finish that entire bale).", "inputFormat": "The first line contains two space-separated integers $H$ and $N$.\n\nLines $2$ through $N+1$, where line $i+1$ contains a single integer, give the weight $S_i$ of the $i$-th bale.", "outputFormat": "Output a single integer, the maximum total kilograms of hay Bessie can eat without exceeding the limit.", "hint": "#### Input Explanation\n\nThere are four bales with weights $15, 19, 20$, and $21$. Bessie wants to eat as much as she can within the $56$ kilogram limit.\n\n#### Output Explanation\n\nBessie can eat $3$ bales (with weights $15, 20, 21$), reaching exactly her $56$ kilogram limit.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO09OCT] Bessie's Weight Problem G", "background": null, "description": "Bessie 像她的诸多姊妹一样，因为从 Farmer John 的草地吃了太多美味的草而长出了太多的赘肉。所以 FJ 将她置于一个及其严格的节食计划之中。她每天不能吃多过 $H (5 \\le H \\le 45,000)$ 公斤的干草。 Bessie 只能吃一整捆干草；当她开始吃一捆干草的之后就再也停不下来了。她有一个完整的$N (1 \\le N \\le 500)$ 捆可以给她当作晚餐的干草的清单。她自然想要尽量吃到更多的干草。很自然地，每捆干草只能被吃一次（即使在列表中相同的重量可能出现 $2$ 次，但是这表示的是两捆干草，其中每捆干草最多只能被吃掉一次）。 给定一个列表表示每捆干草的重量 $S_i (1 \\le S_i \\le H)$ , 求 Bessie 不超过节食的限制的前提下可以吃掉多少干草（注意一旦她开始吃一捆干草就会把那一捆干草全部吃完）。", "inputFormat": "第一行有两个由空格隔开的整数 $H$ 和 $N$。\n\n第 $2$ 到第 $N+1$ 行，第 $i+1$ 行是一个单独的整数，表示第 $i$ 捆干草的重量 $S_i$。", "outputFormat": "第一行一个单独的整数表示 Bessie 在限制范围内最多可以吃多少公斤的干草。", "hint": "#### 输入说明\n\n有四捆草，重量分别是 $15,19,20$ 和 $21$。Bessie 在 $56$ 公斤的限制范围内想要吃多少就可以吃多少。\n\n\n#### 输出说明\n\nBessie 可以吃 $3$ 捆干草（重量分别为 $15, 20, 21$）。恰好达到她的 $56$ 公斤的限制。", "locale": "zh-CN"}}}
{"pid": "P2640", "type": "P", "difficulty": 2, "samples": [["6924 809", "2 811\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "数学"], "title": "神秘磁石", "background": "在遥远的阿拉德大陆，有一种神秘的磁石，是由魔皇制作出来的，\n", "description": "1. 若给他一个一维坐标系，那么他的磁力一定要在素数坐标的位置上才能发挥的最大（不管位置坐标的大小，只要是素数那么磁力就一样大）。\n2. 若两个磁石相距为 $k$，那么磁石间的破坏力将会达到当前磁力的峰值\n\n显然，两磁石间最大破坏力取决于磁力大小和磁石间距，那么请问给出长度不超过 $n$ 的一维坐标系，有哪几对坐标间磁石破坏力最大。\n", "inputFormat": "两个正整数 $n,k$。\n", "outputFormat": "所有小于等于 $n$ 的素数对。每对素数对输出一行，中间用单个空格隔开。若没有找到任何素数对，输出 `empty`。\n", "hint": "对于 $100\\%$ 的数据，$1\\leq k\\leq n\\leq 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "Mysterious Magnet", "background": "On the distant continent of Arad, there exists a mysterious magnet crafted by the Demon Emperor.", "description": "1. In a one-dimensional coordinate system, its magnetic force reaches its maximum only at positions whose coordinates are prime numbers (regardless of the coordinate’s magnitude, as long as the coordinate is prime, the magnetic force is equally strong).\n2. If two magnets are at distance $k$, their destructive power reaches the peak of the current magnetic force.\n\nClearly, the maximum destructive power between two magnets depends on the magnetic force and the distance between the magnets. Given a one-dimensional coordinate line of length at most $n$, find all pairs of coordinates whose magnets achieve the maximum destructive power, i.e., all pairs of primes at distance $k$ within $[1, n]$.", "inputFormat": "Two positive integers $n, k$.", "outputFormat": "Output all pairs of primes $(p, q)$ such that $q - p = k$ and $q \\leq n$ (equivalently, all pairs $(p, p + k)$ with $p \\geq 2$ and $p + k \\leq n$). Output one pair per line, with a single space between the two numbers. If no prime pair is found, output `empty`.", "hint": "For $100\\%$ of the testdata, $1 \\leq k \\leq n \\leq 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "神秘磁石", "background": "在遥远的阿拉德大陆，有一种神秘的磁石，是由魔皇制作出来的，\n", "description": "1. 若给他一个一维坐标系，那么他的磁力一定要在素数坐标的位置上才能发挥的最大（不管位置坐标的大小，只要是素数那么磁力就一样大）。\n2. 若两个磁石相距为 $k$，那么磁石间的破坏力将会达到当前磁力的峰值\n\n显然，两磁石间最大破坏力取决于磁力大小和磁石间距，那么请问给出长度不超过 $n$ 的一维坐标系，有哪几对坐标间磁石破坏力最大。\n", "inputFormat": "两个正整数 $n,k$。\n", "outputFormat": "所有小于等于 $n$ 的素数对。每对素数对输出一行，中间用单个空格隔开。若没有找到任何素数对，输出 `empty`。\n", "hint": "对于 $100\\%$ 的数据，$1\\leq k\\leq n\\leq 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2642", "type": "P", "difficulty": 3, "samples": [["5\n83 223 -13 1331 -935", "1637"], ["3\n83 223 -13", "70"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "最大双子段和", "background": null, "description": "给定一个长度为 $n$ 的整数序列，要求从中选出两个子段（序列中连续且非空的一段），使得这两个子段中的整数的总和最大，并输出所求的两个子段中的整数的总和。每个子段的最小长度为 $1$，并且两个子段之间至少间隔一个数。", "inputFormat": "第一行是一个整数，表示 $n$。\n\n第二行是 $n$ 个整数，表示整数序列。", "outputFormat": "一个整数，表示所求的两个子段中的整数的总和。", "hint": "对于 $30\\%$ 的数据，有 $N\\le 100$。\n\n对于 $60\\%$ 的数据，有 $N\\le 10^4$。\n\n对于 $100\\%$ 的数据，有 $N\\le 10^6$。\n\n数据保证运算过程中的所有数值均在 64 位有符号整型的表示范围内。", "locale": "zh-CN", "translations": {"en": {"title": "Maximum Sum of Two Non-Adjacent Subarrays", "background": "", "description": "Given an integer sequence of length $n$, select two subarrays (contiguous, non-empty segments of the sequence) such that the total sum of the integers in these two subarrays is maximized, and output that total sum. Each subarray must have a minimum length of $1$, and the two subarrays must be separated by at least one element.", "inputFormat": "The first line contains an integer representing $n$.\nThe second line contains $n$ integers representing the sequence.", "outputFormat": "Output a single integer, the maximum total sum of the integers in the two selected subarrays.", "hint": "Constraints:\n- For $30\\%$ of the testdata, $n \\le 100$.\n- For $60\\%$ of the testdata, $n \\le 10^4$.\n- For $100\\%$ of the testdata, $n \\le 10^6$.\n- All values during the computation are guaranteed to fit within the range of a signed $64$-bit integer.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最大双子段和", "background": null, "description": "给定一个长度为 $n$ 的整数序列，要求从中选出两个子段（序列中连续且非空的一段），使得这两个子段中的整数的总和最大，并输出所求的两个子段中的整数的总和。每个子段的最小长度为 $1$，并且两个子段之间至少间隔一个数。", "inputFormat": "第一行是一个整数，表示 $n$。\n\n第二行是 $n$ 个整数，表示整数序列。", "outputFormat": "一个整数，表示所求的两个子段中的整数的总和。", "hint": "对于 $30\\%$ 的数据，有 $N\\le 100$。\n\n对于 $60\\%$ 的数据，有 $N\\le 10^4$。\n\n对于 $100\\%$ 的数据，有 $N\\le 10^6$。\n\n数据保证运算过程中的所有数值均在 64 位有符号整型的表示范围内。", "locale": "zh-CN"}}}
{"pid": "P2643", "type": "P", "difficulty": 5, "samples": [["C16H18O9+O2=CO2+H2O", "C16H18O9+16O2=16CO2+9H2O"], ["Cu(NO3)2+Fe=Fe(NO3)2+Cu", "Cu(NO3)2+Fe=Fe(NO3)2+Cu"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "矩阵运算", "洛谷原创"], "title": "机房中出了一只大触！", "background": "机房中出了一只大触Kurunie！作为一只大触，它当然喜欢刷题。然而NOIp复赛临近，大触要抽出更多的时间来刷OI题，所以它就把一些简单的题目丢给你啦。\n", "description": "显然，任何题目对于K触来说都是水题，倒是K触怕你不会写，于是给了你最最简单的化学卷子。\n\n原来K触正在准备化学方程式配平大赛，所以卷子全都是配平练习题。\n\nK触给你举了个简单的例子，比如下列物质在氧气中燃烧的化学方程式，要求配平：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1755.png) \n\nK触当然知道这是绿原酸(C16H18O9)（O和0要分清楚哦），它在氧气中燃烧的方程式是：\n\nC16H18O9+O2=CO2+H2O\n\n什么？你说配平？这种简单的事情当然就交给你啦。\n", "inputFormat": "一行一个字符串表示待配平的化学方程式。由一个等号隔开反应物和生成物，物质间用加号分隔。输\n\n\n入的数字均在元素后面，作为下标。\n", "outputFormat": "一行一个字符串表示配平后的化学方程式。不需要加沉淀或气体符号，\n", "hint": "保证输入字符串长度小于等于50，字符串只包含大小写英文字母、数字、小括号、加号、等号。\n\n涉及到的物质均不包含带结晶水。\n\n涉及到的元素最多只有两个字母。\n\n小括号中不会嵌套小括号。\n\n配平后每种物质系数、原字符串中的所有下标均在32位带符号整数范围内。\n", "locale": "zh-CN", "translations": {"en": {"title": "A Big Shot Appeared in the Computer Room!", "background": "A big shot named Kurunie appeared in the computer room! As a big shot, of course they like solving problems. However, with the NOIp second round approaching, the big shot needs to spend more time on OI problems, so they are giving you some simple ones.", "description": "Obviously, any problem is easy for K-chu, but K-chu is worried you might not be able to write it, so they gave you the simplest chemistry worksheet.\n\nIt turns out K-chu is preparing for a chemical equation balancing contest, so the worksheet is full of balancing exercises.\n\nK-chu gave you a simple example. For instance, balance the chemical equation for burning the following substance in oxygen:\n\n![](https://cdn.luogu.com.cn/upload/pic/1755.png)\n\nOf course K-chu knows this is chlorogenic acid (C16H18O9) (be careful to distinguish O and 0). Its combustion equation is:\n\nC16H18O9+O2=CO2+H2O\n\nWhat? You said “balance it”? Such a simple task is naturally left to you.", "inputFormat": "A single line string representing the chemical equation to be balanced. An equals sign separates reactants and products, and substances are separated by plus signs. Digits in the input appear after elements as subscripts.", "outputFormat": "A single line string representing the balanced chemical equation. Do not add precipitate or gas symbols.", "hint": "- The input string length is at most 50, and it contains only uppercase and lowercase English letters, digits, parentheses, plus signs, and an equals sign.\n- The substances involved do not include waters of crystallization.\n- Element symbols have at most two letters.\n- Parentheses are not nested inside parentheses.\n- After balancing, each substance’s coefficient and all subscripts in the original string fit within the 32-bit signed integer range.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "机房中出了一只大触！", "background": "机房中出了一只大触Kurunie！作为一只大触，它当然喜欢刷题。然而NOIp复赛临近，大触要抽出更多的时间来刷OI题，所以它就把一些简单的题目丢给你啦。\n", "description": "显然，任何题目对于K触来说都是水题，倒是K触怕你不会写，于是给了你最最简单的化学卷子。\n\n原来K触正在准备化学方程式配平大赛，所以卷子全都是配平练习题。\n\nK触给你举了个简单的例子，比如下列物质在氧气中燃烧的化学方程式，要求配平：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1755.png) \n\nK触当然知道这是绿原酸(C16H18O9)（O和0要分清楚哦），它在氧气中燃烧的方程式是：\n\nC16H18O9+O2=CO2+H2O\n\n什么？你说配平？这种简单的事情当然就交给你啦。\n", "inputFormat": "一行一个字符串表示待配平的化学方程式。由一个等号隔开反应物和生成物，物质间用加号分隔。输\n\n\n入的数字均在元素后面，作为下标。\n", "outputFormat": "一行一个字符串表示配平后的化学方程式。不需要加沉淀或气体符号，\n", "hint": "保证输入字符串长度小于等于50，字符串只包含大小写英文字母、数字、小括号、加号、等号。\n\n涉及到的物质均不包含带结晶水。\n\n涉及到的元素最多只有两个字母。\n\n小括号中不会嵌套小括号。\n\n配平后每种物质系数、原字符串中的所有下标均在32位带符号整数范围内。\n", "locale": "zh-CN"}}}
{"pid": "P2644", "type": "P", "difficulty": 6, "samples": [["4 5 6\n0 0 0 1 0 0\n2 0 0 2 0 0\n0 0 5 0 0 0\n3 0 0 0 4 0\n0 0 2 0 0 0", "2 2\n1 1"], ["3 3 2\n3 5\n4 2\n0 1", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索"], "title": "白金莲花池", "background": "为了让奶牛们娱乐和锻炼，农夫约翰建造了一个美丽的池塘。这个长方形的池子被分成了 $M$ 行 $N$ 列个方格（$1≤M,N≤30$）。一些格子是坚固得令人惊讶的莲花，还有一些格子是岩石，其余的只是美丽、纯净、湛蓝还可能掩藏着宝藏的水。\n\n贝西正在练习芭蕾舞，她站在一朵莲花上，想跳到另一朵莲花上去，她只能从一朵莲花跳到另一朵莲花上，既不能跳到水里，也不能跳到岩石上。\n\n贝西的舞步很像象棋中的马步：每次总是先横向移动一格，再纵向移动两格，或先纵向移动两格，再横向移动一格。最多时，贝西会有八个移动方向可供选择。\n\n约翰一直在观看贝西的芭蕾练习，发现她有时候不能跳到终点，因为中间缺了一些荷叶。于是他想要添加几朵莲花来帮助贝西完成任务，当然莲花不能种在岩石上。\n", "description": "但是！约翰在种植莲花的时候发现了一件很有趣的事，有些格子是不能直接种植莲花的，原因是……实不相瞒，无法直接种植莲花的格子的泥土中大部分都是货真价实的铂金，正是它们妨碍了莲花的正常生长！而恰好约翰刚刚学到了铂金的开采方法，也有相关的开采工具，而且他还发现开采铂金后的格子就可以正常地种植莲花，不必担心泥土缺失的问题。（由于贝西迫切地想练习，所以约翰不会开采不打算种莲花的铂金格子）\n\n开采铂金很累，就像是种植莲花一样累，它们都会消耗掉约翰 $1$ 点体力（也就是说想把铂金格子变成莲花格子需要 $2$ 点体力），约翰最初有 $P$ 点体力来种植莲花或开采铂金。\n\n请帮助约翰计算至少需要消耗多少体力才能帮助贝西完成任务，这个数字记作 $S$，以及有多少种消耗这些体力的方法能帮助贝西完成任务，这个数字记作 $W_S$；铂金当然是越多越好，请计算在消耗 $S$ 点体力帮助贝西完成任务的同时最多能开采多少铂金，这个数字记作 $G$，以及消耗 $S$ 点体力开采 $G$ 块铂金帮助贝西完成任务的方法数，这个数字记作 $W_G$。\n\n若在 $P$ 点体力内无法帮助到贝西，那么只输出 `-1`。\n\n若在 $S$ 点体力内无法开采铂金，那么第二行只输出 `-1`。", "inputFormat": "第一行：三个用空格分开的整数：$P$，$M$ 和 $N$\n\n第二行到 $M+1$ 行：第 $i+1$ 行有 $N$ 个用空格分开的整数，描述了池塘第 $i$ 行的状态：\n\n$0$ 为水，$1$ 为莲花，$2$ 为岩石，$3$ 为贝西所在的起点，$4$ 为贝西想去的终点，$5$ 为铂金的埋藏地。", "outputFormat": "\n第一行：用空格分隔开 $S$ 和 $W_S$（两个整数，需要最少消耗的体力及方案数；如果无法帮助，输出 `-1`。）\n\n第二行：用空格分隔开 $G$ 和 $W_G$（两个整数，在消耗最少的前提下开采最多的铂金数及方案数，若在 $S$ 点体力内无法开采铂金，第二行输出 `-1`。）\n\n如果第一行是 `-1`，不要输出第二行。\n\n保证输出的数字不会超过 `long long`。", "hint": "约翰可以用开采到的铂金小赚一笔，但如果用多余的体力开采铂金而不往上种莲花的话贝西会很生气！\n", "locale": "zh-CN", "translations": {"en": {"title": "Platinum Lotus Pond", "background": "To entertain and exercise the cows, Farmer John built a beautiful pond. This rectangular pond is divided into $M$ rows and $N$ columns of cells ($1 \\le M, N \\le 30$). Some cells contain surprisingly sturdy lotus, some are rocks, and the rest are beautiful, pure, deep-blue water that might even hide treasure.\n\nBessie is practicing ballet. She stands on a lotus and wants to jump to another lotus. She can only jump from one lotus to another; she cannot land on water or rocks.\n\nBessie’s steps are like a knight in chess: each time she either moves one cell horizontally and then two cells vertically, or two cells vertically and then one cell horizontally. At most, Bessie has eight possible move directions.\n\nJohn has been watching Bessie’s ballet practice and noticed that sometimes she cannot reach the destination because some lotus leaves are missing. So he wants to add some lotus to help Bessie complete the task, and of course, lotus cannot be planted on rocks.", "description": "However! When planting lotus, John discovered something interesting: some cells cannot have lotus planted directly. The reason is… to be honest, the soil in those cells contains a lot of genuine platinum, which hinders lotus growth! Coincidentally, John has just learned how to mine platinum and has the tools for it, and he also found that after mining the platinum, the cell can be planted with lotus normally, without worrying about missing soil. (Because Bessie is eager to practice, John will not mine a platinum cell unless he also intends to plant a lotus there.)\n\nMining platinum is tiring, just like planting lotus. Each action consumes $1$ point of stamina (that is, turning a platinum cell into a lotus cell requires $2$ points of stamina). John initially has $P$ points of stamina to plant lotus or mine platinum.\n\nPlease help John compute the least stamina needed to help Bessie complete the task, denoted by $S$, and the number of ways to spend exactly that stamina to help Bessie, denoted by $W_S$. Since more platinum is better, also compute, among all solutions that spend $S$ stamina and help Bessie, the maximum amount of platinum that can be mined, denoted by $G$, and the number of ways to help Bessie while spending $S$ stamina and mining exactly $G$ pieces of platinum, denoted by $W_G$.\n\nIf it is impossible to help Bessie within $P$ points of stamina, output only `-1`.\n\nIf it is impossible to mine any platinum within $S$ points of stamina, then output only `-1` on the second line.", "inputFormat": "The first line: three integers separated by spaces: $P$, $M$, and $N$.\n\nLines $2$ to $M+1$: the $(i+1)$-th line contains $N$ integers separated by spaces, describing the state of row $i$ of the pond:\n\n$0$ means water, $1$ means lotus, $2$ means rock, $3$ means Bessie’s starting cell, $4$ means Bessie’s destination, and $5$ means a platinum deposit.", "outputFormat": "The first line: two integers separated by a space, $S$ and $W_S$ (the minimum stamina required and the number of methods to achieve it; if it is impossible to help Bessie within $P$ stamina, output `-1`).\n\nThe second line: two integers separated by a space, $G$ and $W_G$ (the maximum amount of platinum mined under the minimum-stamina condition and the number of methods to achieve it; if no platinum can be mined within $S$ stamina, output `-1` on the second line).\n\nIf the first line is `-1`, do not output the second line.\n\nAll output numbers are guaranteed not to exceed `long long`.", "hint": "John might make a small profit by mining the platinum, but if he uses extra stamina to mine platinum without planting lotus on those cells, Bessie will be very angry!\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "白金莲花池", "background": "为了让奶牛们娱乐和锻炼，农夫约翰建造了一个美丽的池塘。这个长方形的池子被分成了 $M$ 行 $N$ 列个方格（$1≤M,N≤30$）。一些格子是坚固得令人惊讶的莲花，还有一些格子是岩石，其余的只是美丽、纯净、湛蓝还可能掩藏着宝藏的水。\n\n贝西正在练习芭蕾舞，她站在一朵莲花上，想跳到另一朵莲花上去，她只能从一朵莲花跳到另一朵莲花上，既不能跳到水里，也不能跳到岩石上。\n\n贝西的舞步很像象棋中的马步：每次总是先横向移动一格，再纵向移动两格，或先纵向移动两格，再横向移动一格。最多时，贝西会有八个移动方向可供选择。\n\n约翰一直在观看贝西的芭蕾练习，发现她有时候不能跳到终点，因为中间缺了一些荷叶。于是他想要添加几朵莲花来帮助贝西完成任务，当然莲花不能种在岩石上。\n", "description": "但是！约翰在种植莲花的时候发现了一件很有趣的事，有些格子是不能直接种植莲花的，原因是……实不相瞒，无法直接种植莲花的格子的泥土中大部分都是货真价实的铂金，正是它们妨碍了莲花的正常生长！而恰好约翰刚刚学到了铂金的开采方法，也有相关的开采工具，而且他还发现开采铂金后的格子就可以正常地种植莲花，不必担心泥土缺失的问题。（由于贝西迫切地想练习，所以约翰不会开采不打算种莲花的铂金格子）\n\n开采铂金很累，就像是种植莲花一样累，它们都会消耗掉约翰 $1$ 点体力（也就是说想把铂金格子变成莲花格子需要 $2$ 点体力），约翰最初有 $P$ 点体力来种植莲花或开采铂金。\n\n请帮助约翰计算至少需要消耗多少体力才能帮助贝西完成任务，这个数字记作 $S$，以及有多少种消耗这些体力的方法能帮助贝西完成任务，这个数字记作 $W_S$；铂金当然是越多越好，请计算在消耗 $S$ 点体力帮助贝西完成任务的同时最多能开采多少铂金，这个数字记作 $G$，以及消耗 $S$ 点体力开采 $G$ 块铂金帮助贝西完成任务的方法数，这个数字记作 $W_G$。\n\n若在 $P$ 点体力内无法帮助到贝西，那么只输出 `-1`。\n\n若在 $S$ 点体力内无法开采铂金，那么第二行只输出 `-1`。", "inputFormat": "第一行：三个用空格分开的整数：$P$，$M$ 和 $N$\n\n第二行到 $M+1$ 行：第 $i+1$ 行有 $N$ 个用空格分开的整数，描述了池塘第 $i$ 行的状态：\n\n$0$ 为水，$1$ 为莲花，$2$ 为岩石，$3$ 为贝西所在的起点，$4$ 为贝西想去的终点，$5$ 为铂金的埋藏地。", "outputFormat": "\n第一行：用空格分隔开 $S$ 和 $W_S$（两个整数，需要最少消耗的体力及方案数；如果无法帮助，输出 `-1`。）\n\n第二行：用空格分隔开 $G$ 和 $W_G$（两个整数，在消耗最少的前提下开采最多的铂金数及方案数，若在 $S$ 点体力内无法开采铂金，第二行输出 `-1`。）\n\n如果第一行是 `-1`，不要输出第二行。\n\n保证输出的数字不会超过 `long long`。", "hint": "约翰可以用开采到的铂金小赚一笔，但如果用多余的体力开采铂金而不往上种莲花的话贝西会很生气！\n", "locale": "zh-CN"}}}
{"pid": "P2645", "type": "P", "difficulty": 2, "samples": [["4 3\n1 7 1 6\n1 7 1", "15 9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "斯诺克", "background": "镇海中学开设了很多校本选修课程，有体育类、音乐类、美术类、无线电测向、航空航海航天模型制作等，力争使每位学生高中毕业后，能学到一门拿得出手的兴趣爱好，为将来的终身发展打下基础。在体育类的校本选修课程中，有一门课程是斯诺克台球。\n\n斯诺克台球比赛中有 $21$ 个球，其中有 $15$ 个红球，$6$ 个彩球（分别是黄、绿、棕、蓝、粉、黑）。甲乙二人轮流打球。红、黄、绿、棕、蓝、粉、黑的球的得分分别是 $1$、$2$、$3$、$4$、$5$、$6$、$7$ 分。最后以得分高者为胜。\n\n简化后的打球规则如下：\n\n1. 如果有红球，第奇数次必须打红球，打过的红球从桌面上拿走。\n\n2. 每打一个红球后，可以任意选一个彩球打，打红球后接着打的彩球不从桌面上拿走。\n\n3. 如果桌面上已经没有红球可打了，那么按照分值从小到大的次序打彩球，这时候每打一个彩球都从桌面上拿走。\n\n\n打球时犯规的判罚如下：\n\n1. 没有打中球，给对方加 $4$ 分。\n\n2. 没有按照打球规则打该打的球，即打中了错误的球时，如果这个错误的球的分值大于 $4$ ，那么给对方加分等于这个球的分值，如果这个错误的球的分值不大于 $4$，那么给对方加 $4$ 分。\n\n打中的错误球不从桌面上拿走。", "description": "小 Ar 和小 Be 记不住斯诺克那么多的规则，所以他们自己发明了一种简单的规则。\n\n本题中的打球规则如下：\n\n* 球的分值和斯诺克一样是 $1\\sim 7$。\n* 小 Ar 会打 $n$ 轮球，小 Be 会打 $m$ 轮球。打中了某个球则自己的分数加上这个球的分值，如果这一轮没打中球则对方加 $4$ 分。被打中的球**不会**被从桌子上拿走。\n\n请统计某局比赛进行到现在为止的比分。", "inputFormat": "输入有两行，第一行有二个整数 $n$ 和 $m$，表示小 Ar 打了 $n$ 个球，小 Be 打了 $m$ 个球。$n$ 和 $m$ 之间以一个空格分隔。**不保证** $n-1 \\le m \\le n$。\n\n第二行，有 $n$ 个以空格分隔的整数，表示小 Ar 的 $n$ 次连续打球情况。\n\n第三行，有 $m$ 个以空格分隔的整数，表示小 Be 的 $m$ 次连续打球情况。\n\n第二行和第三行中：$1$ 至 $7$ 的整数表示打了相应分值的球，$0$ 表示没有打中球。", "outputFormat": "输出仅有一行两个整数，分别表示小 Ar、小 Be 的得分。", "hint": "### 样例解释\n\n小 Ar 依次打了红球、黑球、红球、粉球，小 Ar 得 $15$ 分（$1+7+1+6=15$）。\n\n小 Be 依次打了红球、黑球、红球，小 Be 得 $9$ 分（$1+7+1=9$）。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$0\\le n,m\\le 100,\\ 0\\le a_i,b_i\\le 7$。", "locale": "zh-CN", "translations": {"en": {"title": "Snooker", "background": "Zhenhai High School offers many school-based elective courses, including sports, music, fine arts, radio direction finding, and aviation, nautical, and aerospace model making, striving to ensure that every student can master a presentable hobby by the time they graduate from high school, laying the foundation for lifelong development. Among the sports electives, there is a course on snooker.\n\nIn a snooker match there are $21$ balls, including $15$ red balls and $6$ colored balls (yellow, green, brown, blue, pink, black). Two players take turns. The scores for red, yellow, green, brown, blue, pink, and black balls are $1$, $2$, $3$, $4$, $5$, $6$, and $7$ points, respectively. The player with the higher score at the end wins.\n\nThe simplified playing rules are as follows:\n1. If there are red balls on the table, on odd-numbered turns you must play a red ball; potted red balls are removed from the table.\n2. After potting a red ball, you may choose any colored ball to play; the colored ball potted immediately after a red ball is not removed from the table.\n3. If there are no red balls left on the table, then the colored balls are played in ascending order of their values; at this time, each potted colored ball is removed from the table.\n\nPenalties for fouls are as follows:\n1. If you fail to hit a legal ball, add $4$ points to the opponent’s score.\n2. If you hit a ball other than the required legal ball, then if the wrong ball’s value is greater than $4$, add points equal to that ball’s value to the opponent’s score; otherwise, add $4$ points.\n\nA wrongly potted ball is not removed from the table.", "description": "Xiao Ar and Xiao Be cannot remember so many snooker rules, so they invented a simpler set of rules.\n\nIn this problem, the playing rules are as follows:\n- Ball values are the same as in snooker, i.e., $1\\sim 7$.\n- Xiao Ar will play $n$ turns, and Xiao Be will play $m$ turns. If a ball is potted, the player’s score increases by the ball’s value; if a turn results in a miss, the opponent gains $4$ points. Potted balls are not removed from the table.\n\nCompute the score of the ongoing match up to now.", "inputFormat": "The input has three lines. The first line contains two integers $n$ and $m$, indicating that Xiao Ar played $n$ shots and Xiao Be played $m$ shots. There is a single space between $n$ and $m$. It is not guaranteed that $n-1 \\le m \\le n$.\n\nThe second line contains $n$ space-separated integers, representing Xiao Ar’s $n$ consecutive shots.\n\nThe third line contains $m$ space-separated integers, representing Xiao Be’s $m$ consecutive shots.\n\nIn the second and third lines: integers from $1$ to $7$ indicate the value of the ball potted, and $0$ indicates a miss.", "outputFormat": "Output a single line with two integers, representing the scores of Xiao Ar and Xiao Be, respectively.", "hint": "Sample Explanation:\n- Xiao Ar potted, in order, a red, black, red, and pink ball, scoring $15$ points ($1+7+1+6=15$).\n- Xiao Be potted, in order, a red, black, and red ball, scoring $9$ points ($1+7+1=9$).\n\nConstraints:\nFor $100\\%$ of the testdata, $0\\le n,m\\le 100,\\ 0\\le a_i,b_i\\le 7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "斯诺克", "background": "镇海中学开设了很多校本选修课程，有体育类、音乐类、美术类、无线电测向、航空航海航天模型制作等，力争使每位学生高中毕业后，能学到一门拿得出手的兴趣爱好，为将来的终身发展打下基础。在体育类的校本选修课程中，有一门课程是斯诺克台球。\n\n斯诺克台球比赛中有 $21$ 个球，其中有 $15$ 个红球，$6$ 个彩球（分别是黄、绿、棕、蓝、粉、黑）。甲乙二人轮流打球。红、黄、绿、棕、蓝、粉、黑的球的得分分别是 $1$、$2$、$3$、$4$、$5$、$6$、$7$ 分。最后以得分高者为胜。\n\n简化后的打球规则如下：\n\n1. 如果有红球，第奇数次必须打红球，打过的红球从桌面上拿走。\n\n2. 每打一个红球后，可以任意选一个彩球打，打红球后接着打的彩球不从桌面上拿走。\n\n3. 如果桌面上已经没有红球可打了，那么按照分值从小到大的次序打彩球，这时候每打一个彩球都从桌面上拿走。\n\n\n打球时犯规的判罚如下：\n\n1. 没有打中球，给对方加 $4$ 分。\n\n2. 没有按照打球规则打该打的球，即打中了错误的球时，如果这个错误的球的分值大于 $4$ ，那么给对方加分等于这个球的分值，如果这个错误的球的分值不大于 $4$，那么给对方加 $4$ 分。\n\n打中的错误球不从桌面上拿走。", "description": "小 Ar 和小 Be 记不住斯诺克那么多的规则，所以他们自己发明了一种简单的规则。\n\n本题中的打球规则如下：\n\n* 球的分值和斯诺克一样是 $1\\sim 7$。\n* 小 Ar 会打 $n$ 轮球，小 Be 会打 $m$ 轮球。打中了某个球则自己的分数加上这个球的分值，如果这一轮没打中球则对方加 $4$ 分。被打中的球**不会**被从桌子上拿走。\n\n请统计某局比赛进行到现在为止的比分。", "inputFormat": "输入有两行，第一行有二个整数 $n$ 和 $m$，表示小 Ar 打了 $n$ 个球，小 Be 打了 $m$ 个球。$n$ 和 $m$ 之间以一个空格分隔。**不保证** $n-1 \\le m \\le n$。\n\n第二行，有 $n$ 个以空格分隔的整数，表示小 Ar 的 $n$ 次连续打球情况。\n\n第三行，有 $m$ 个以空格分隔的整数，表示小 Be 的 $m$ 次连续打球情况。\n\n第二行和第三行中：$1$ 至 $7$ 的整数表示打了相应分值的球，$0$ 表示没有打中球。", "outputFormat": "输出仅有一行两个整数，分别表示小 Ar、小 Be 的得分。", "hint": "### 样例解释\n\n小 Ar 依次打了红球、黑球、红球、粉球，小 Ar 得 $15$ 分（$1+7+1+6=15$）。\n\n小 Be 依次打了红球、黑球、红球，小 Be 得 $9$ 分（$1+7+1=9$）。\n\n### 数据范围\n\n对于 $100\\%$ 的数据，$0\\le n,m\\le 100,\\ 0\\le a_i,b_i\\le 7$。", "locale": "zh-CN"}}}
{"pid": "P2646", "type": "P", "difficulty": 2, "samples": [["zlzhy", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "洛谷比赛"], "title": "数数zzy", "background": "", "description": "zzy 自从数学考试连续跪掉之后，上数学课就从来不认真听了（事实上他以前也不认真听）。于是他开始在草稿纸上写写画画，比如写一串奇怪的字符串。然后他决定理♂性♂愉♂悦♂一下：统计这串字符串当中共有多少个为 `zzy` 的子序列，**注意是子序列而非子串**。但是由于他写的字符串实在是太长啦，而且他是个超级大蒟蒻，根本就数不过来。所以他决定请求你这个超级大神犇的帮助。你可以帮帮他吗？", "inputFormat": "一行仅含小写字母的字符串 $s$。", "outputFormat": "一行，一个非负整数，表示输入的字符串中为 `zzy` 的子序列的个数。", "hint": "#### 数据规模与约定\n\n约定 $|s|$ 表示字符串 $s$ 的长度。\n\n- 对于 $70\\%$ 的数据，保证 $|s| \\le 100$。\n- 对于 $100\\%$ 的数据，保证 $1 \\le |s| \\le 10^6$，答案不超过 $2^{63}-1$。", "locale": "zh-CN", "translations": {"en": {"title": "Counting zzy", "background": "", "description": "After failing math exams consecutively, zzy stopped paying attention in math class (in fact, he never really did). He starts doodling on scratch paper, for example writing a strange string. Then he decides to have some fun rationally: count how many subsequences equal to `zzy` appear in this string. Note that it is subsequences rather than substrings. But the string is so long that he cannot possibly count them. So he asks you for help. Can you help him?", "inputFormat": "One line containing a string $s$ consisting of lowercase letters.", "outputFormat": "One line with a non-negative integer: the number of subsequences equal to `zzy` in the input string.", "hint": "Constraints\n\nLet $|s|$ denote the length of string $s$.\n\n- For $70\\%$ of the testdata, it is guaranteed that $|s| \\le 100$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\le |s| \\le 10^6$, and the answer does not exceed $2^{63} - 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数数zzy", "background": "", "description": "zzy 自从数学考试连续跪掉之后，上数学课就从来不认真听了（事实上他以前也不认真听）。于是他开始在草稿纸上写写画画，比如写一串奇怪的字符串。然后他决定理♂性♂愉♂悦♂一下：统计这串字符串当中共有多少个为 `zzy` 的子序列，**注意是子序列而非子串**。但是由于他写的字符串实在是太长啦，而且他是个超级大蒟蒻，根本就数不过来。所以他决定请求你这个超级大神犇的帮助。你可以帮帮他吗？", "inputFormat": "一行仅含小写字母的字符串 $s$。", "outputFormat": "一行，一个非负整数，表示输入的字符串中为 `zzy` 的子序列的个数。", "hint": "#### 数据规模与约定\n\n约定 $|s|$ 表示字符串 $s$ 的长度。\n\n- 对于 $70\\%$ 的数据，保证 $|s| \\le 100$。\n- 对于 $100\\%$ 的数据，保证 $1 \\le |s| \\le 10^6$，答案不超过 $2^{63}-1$。", "locale": "zh-CN"}}}
{"pid": "P2647", "type": "P", "difficulty": 5, "samples": [["2\n5 2\n3 5", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "洛谷原创", "枚举", "洛谷比赛"], "title": "最大收益", "background": "", "description": "现在你面前有 $n$ 个物品，编号分别为 $1,2,3,\\cdots,n$。你可以在这当中任意选择任意多个物品。其中第 $i$ 个物品有两个属性 $W_i$ 和 $R_i$，当你选择了第 $i$ 个物品后，你就可以获得 $W_i$ 的收益；但是，你选择该物品以后选择的所有物品的收益都会减少 $R_i$。现在请你求出，该选择哪些物品，并且该以什么样的顺序选取这些物品，才能使得自己获得的收益最大。\n\n注意，收益的减少是会叠加的。比如，你选择了第 $i$ 个物品，那么你就会获得了 $W_i$ 的收益；然后你又选择了第 $j$ 个物品，你又获得了 $W_j-R_i$ 收益；之后你又选择了第 $k$ 个物品，你又获得了 $W_k-R_i-R_j$ 的收益；那么你获得的收益总和为 $W_i+(W_j-R_i)+(W_k-R_i-R_j)$。", "inputFormat": "第一行一个正整数 $n$，表示物品的个数。\n\n接下来第 $2$ 行到第 $n+1$ 行，每行两个正整数 $W_i$ 和 $R_i$，含义如题目所述。", "outputFormat": "输出仅一行，表示最大的收益。\n", "hint": "### 数据范围及约定\n\n- $20\\%$ 的数据满足：$n \\le 5$，$0 \\le W_i,R_i \\le 1000$；\n- $50\\%$ 的数据满足：$n \\le 15$，$0 \\le W_i,R_i \\le 1000$；\n- $100\\%$ 的数据满足：$n \\le 3000$，$0 \\le W_i,R_i \\le 2\\times 10^5$。\n\n### 样例解释\n\n我们可以选择 $1$ 号物品，获得了 $5$ 点收益；之后我们再选择 $2$ 号物品，获得 $3-2=1$ 点收益。最后总的收益值为 $5+1=6$。", "locale": "zh-CN", "translations": {"en": {"title": "Maximum Profit", "background": "", "description": "You are given $n$ items, numbered $1, 2, 3, \\cdots, n$. You may choose any subset of them in any order. The $i$-th item has two attributes $W_i$ and $R_i$. When you choose the $i$-th item, you immediately gain a profit of $W_i$; however, the profits of all items chosen after this item are reduced by $R_i$. Determine which items to choose and in what order to choose them so that the total profit is maximized.\n\nNote that the reductions are cumulative. For example, if you choose item $i$, you gain $W_i$; then if you choose item $j$, you gain $W_j - R_i$; afterwards, if you choose item $k$, you gain $W_k - R_i - R_j$; hence the total profit is $W_i + (W_j - R_i) + (W_k - R_i - R_j)$.", "inputFormat": "The first line contains a positive integer $n$, the number of items.\n\nLines $2$ through $n+1$ each contain two non-negative integers $W_i$ and $R_i$, as described above.", "outputFormat": "Output a single line with the maximum profit.", "hint": "### Constraints\n\n- 20% of the testdata satisfies $n \\le 5$, $0 \\le W_i, R_i \\le 1000$.\n- 50% of the testdata satisfies $n \\le 15$, $0 \\le W_i, R_i \\le 1000$.\n- 100% of the testdata satisfies $n \\le 3000$, $0 \\le W_i, R_i \\le 2 \\times 10^5$.\n\n### Sample Explanation\n\nWe can choose item $1$ to gain $5$ profit; then choose item $2$ to gain $3 - 2 = 1$ profit. The total profit is $5 + 1 = 6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最大收益", "background": "", "description": "现在你面前有 $n$ 个物品，编号分别为 $1,2,3,\\cdots,n$。你可以在这当中任意选择任意多个物品。其中第 $i$ 个物品有两个属性 $W_i$ 和 $R_i$，当你选择了第 $i$ 个物品后，你就可以获得 $W_i$ 的收益；但是，你选择该物品以后选择的所有物品的收益都会减少 $R_i$。现在请你求出，该选择哪些物品，并且该以什么样的顺序选取这些物品，才能使得自己获得的收益最大。\n\n注意，收益的减少是会叠加的。比如，你选择了第 $i$ 个物品，那么你就会获得了 $W_i$ 的收益；然后你又选择了第 $j$ 个物品，你又获得了 $W_j-R_i$ 收益；之后你又选择了第 $k$ 个物品，你又获得了 $W_k-R_i-R_j$ 的收益；那么你获得的收益总和为 $W_i+(W_j-R_i)+(W_k-R_i-R_j)$。", "inputFormat": "第一行一个正整数 $n$，表示物品的个数。\n\n接下来第 $2$ 行到第 $n+1$ 行，每行两个正整数 $W_i$ 和 $R_i$，含义如题目所述。", "outputFormat": "输出仅一行，表示最大的收益。\n", "hint": "### 数据范围及约定\n\n- $20\\%$ 的数据满足：$n \\le 5$，$0 \\le W_i,R_i \\le 1000$；\n- $50\\%$ 的数据满足：$n \\le 15$，$0 \\le W_i,R_i \\le 1000$；\n- $100\\%$ 的数据满足：$n \\le 3000$，$0 \\le W_i,R_i \\le 2\\times 10^5$。\n\n### 样例解释\n\n我们可以选择 $1$ 号物品，获得了 $5$ 点收益；之后我们再选择 $2$ 号物品，获得 $3-2=1$ 点收益。最后总的收益值为 $5+1=6$。", "locale": "zh-CN"}}}
{"pid": "P2648", "type": "P", "difficulty": 3, "samples": [["100 3 5 2\n1 5\n2 3\n1 4\n5 2 150\n2 5 120", "250"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["枚举", "洛谷比赛"], "title": "赚钱", "background": "改编自某题。", "description": "zzy 现在决定环游中国，顺便赚点钱。zzy 在一个城市最多只能赚 $D$ 元，然后他可以选择退休也就是停止赚钱，或者去其它城市工作。当然，他可以在别处工作一阵子后又回到原来的城市再赚 $D$ 元。这样的往返次数是没有任何限制的。\n\n城市间有 $P$ 条单向路径连接，共有 $C$ 座城市，编号从 $1$ 到 $C$。路径 $i$ 从城市 $A_i$ 到城市 $B_i$，在路径行走上不用任何花费。\n\nzzy 还可以乘飞机从某个城市飞到另一个城市。共有 $F$ 条单向的航线，第 $i$ 条航线是从城市 $J_i$ 飞到另一座城市 $K_i$，费用是 $T_i$ 元。假如 zzy 身上没有现钱，他可以用以后赚的钱来付机票钱。\n\nzzy 可以从任何一个城市出发开始赚钱，并且选择在任何时候、任何城市退休。现在 zzy 想要知道，如果在工作时间上不做限制，那么 zzy 共可以赚多少钱呢？如果赚的钱也不会出现限制，那么就输出 `orz`。", "inputFormat": "第一行，$4$ 个用空格分开的正整数 $D,P,C,F$。\n\n第二行到 $P+1$ 行，第 $i+1$ 行包含 $2$ 个用空格分开的整数 $A_i,B_i$，表示一条从城市 $A_i$ 到城市 $B_i$ 的单向路径。\n\n接下来的 $F$ 行，每行 $3$ 个用空格分开的正整数 $J_i,K_i,T_i$，表示一条从城市 $J_i$ 到城市 $K_i$ 的单向航线，费用为 $T_i$。", "outputFormat": "如果 zzy 赚的钱没有限制，输出 `orz`。如果有限制，那么就输出在给定的规则下 zzy 最多可以赚到的钱数。", "hint": "对于 $100\\%$ 的数据，$1\\le D\\le1000$，$1\\le P\\le200$，$2\\le C\\le300$，$1\\le F\\le400$，$1\\le T_i \\le 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Making Money", "background": "Adapted from another problem.", "description": "zzy now decides to travel around China and make some money along the way. In any single visit to a city, zzy can earn at most $D$ yuan. After that, he may choose to retire (i.e., stop earning) or go to other cities to work. Of course, he can work elsewhere for a while and then return to the original city to earn another $D$ yuan. The number of such round trips is unlimited.\n\nThere are $P$ directed paths between cities, and there are $C$ cities in total, numbered from $1$ to $C$. Path $i$ goes from city $A_i$ to city $B_i$, and traveling along these paths costs nothing.\n\nzzy can also take a flight from one city to another. There are $F$ directed flights; the $i$-th flight goes from city $J_i$ to city $K_i$ with a cost of $T_i$ yuan. If zzy has no cash on hand, he can pay the airfare with money he will earn in the future.\n\nzzy may start earning from any city and may retire at any time and in any city. Now zzy wants to know: if there is no limit on working time, how much money can he earn in total? If the amount he can earn has no limit, output `orz`.", "inputFormat": "The first line contains $4$ space-separated positive integers $D,P,C,F$.\n\nLines $2$ to $P+1$ each contain $2$ space-separated integers $A_i,B_i$, describing a directed path from city $A_i$ to city $B_i$.\n\nThe next $F$ lines each contain $3$ space-separated positive integers $J_i,K_i,T_i$, describing a directed flight from city $J_i$ to city $K_i$ with a cost of $T_i$.", "outputFormat": "If the amount zzy can earn is unbounded, output `orz`. Otherwise, output the maximum amount of money zzy can earn under the given rules.", "hint": "For $100\\%$ of the testdata, $1\\le D\\le 1000$, $1\\le P\\le 200$, $2\\le C\\le 300$, $1\\le F\\le 400$, $1\\le T_i \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "赚钱", "background": "改编自某题。", "description": "zzy 现在决定环游中国，顺便赚点钱。zzy 在一个城市最多只能赚 $D$ 元，然后他可以选择退休也就是停止赚钱，或者去其它城市工作。当然，他可以在别处工作一阵子后又回到原来的城市再赚 $D$ 元。这样的往返次数是没有任何限制的。\n\n城市间有 $P$ 条单向路径连接，共有 $C$ 座城市，编号从 $1$ 到 $C$。路径 $i$ 从城市 $A_i$ 到城市 $B_i$，在路径行走上不用任何花费。\n\nzzy 还可以乘飞机从某个城市飞到另一个城市。共有 $F$ 条单向的航线，第 $i$ 条航线是从城市 $J_i$ 飞到另一座城市 $K_i$，费用是 $T_i$ 元。假如 zzy 身上没有现钱，他可以用以后赚的钱来付机票钱。\n\nzzy 可以从任何一个城市出发开始赚钱，并且选择在任何时候、任何城市退休。现在 zzy 想要知道，如果在工作时间上不做限制，那么 zzy 共可以赚多少钱呢？如果赚的钱也不会出现限制，那么就输出 `orz`。", "inputFormat": "第一行，$4$ 个用空格分开的正整数 $D,P,C,F$。\n\n第二行到 $P+1$ 行，第 $i+1$ 行包含 $2$ 个用空格分开的整数 $A_i,B_i$，表示一条从城市 $A_i$ 到城市 $B_i$ 的单向路径。\n\n接下来的 $F$ 行，每行 $3$ 个用空格分开的正整数 $J_i,K_i,T_i$，表示一条从城市 $J_i$ 到城市 $K_i$ 的单向航线，费用为 $T_i$。", "outputFormat": "如果 zzy 赚的钱没有限制，输出 `orz`。如果有限制，那么就输出在给定的规则下 zzy 最多可以赚到的钱数。", "hint": "对于 $100\\%$ 的数据，$1\\le D\\le1000$，$1\\le P\\le200$，$2\\le C\\le300$，$1\\le F\\le400$，$1\\le T_i \\le 1000$。", "locale": "zh-CN"}}}
{"pid": "P2649", "type": "P", "difficulty": 3, "samples": [["2 5\n1 7 2 10 9", "2"], ["6 11\n62 63 54 66 65 61 57 56 50 53 48", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心"], "title": "游戏预言", "background": "", "description": "John 和朋友们在玩纸牌游戏，他们一共有 $m$ 个人（包括 John）。他们的纸牌比较特殊，一共有 $n \\times m$ 张牌，牌号分别为 $1,2,\\dots,n \\times m$，没有牌号相同的牌。每个人先拿到 $n$ 张牌，然后，每一轮，每个人出一张牌，谁最大则谁赢得这一轮。现在已知 John 手中的 $n$ 张牌，计算他最少能赢得多少轮。", "inputFormat": "第一行为两个整数 $m$ 和 $n$。\n\n第二行有 $n$ 个正整数，表示 John 手中的 $n$ 张牌的数值。", "outputFormat": "仅一个整数，表示 John 最少能赢的次数。", "hint": "对于 $100 \\%$ 的数据，$2 \\le m \\le 20$，$1 \\le n \\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "Game Prediction", "background": "", "description": "John and his friends are playing a card game with $m$ people in total (including John). Their deck is special: there are $n \\times m$ cards numbered $1, 2, \\dots, n \\times m$, with no duplicate numbers. Each person first receives $n$ cards. Then, in each round, everyone plays one card; the highest number wins that round. Now, given the $n$ cards in John's hand, compute the minimum number of rounds he can win.", "inputFormat": "The first line contains two integers $m$ and $n$.\n\nThe second line contains $n$ positive integers, the values of the $n$ cards in John's hand.", "outputFormat": "Output a single integer, the minimum number of rounds John can win.", "hint": "Constraints: For $100\\%$ of the testdata, $2 \\le m \\le 20$, $1 \\le n \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "游戏预言", "background": "", "description": "John 和朋友们在玩纸牌游戏，他们一共有 $m$ 个人（包括 John）。他们的纸牌比较特殊，一共有 $n \\times m$ 张牌，牌号分别为 $1,2,\\dots,n \\times m$，没有牌号相同的牌。每个人先拿到 $n$ 张牌，然后，每一轮，每个人出一张牌，谁最大则谁赢得这一轮。现在已知 John 手中的 $n$ 张牌，计算他最少能赢得多少轮。", "inputFormat": "第一行为两个整数 $m$ 和 $n$。\n\n第二行有 $n$ 个正整数，表示 John 手中的 $n$ 张牌的数值。", "outputFormat": "仅一个整数，表示 John 最少能赢的次数。", "hint": "对于 $100 \\%$ 的数据，$2 \\le m \\le 20$，$1 \\le n \\le 50$。", "locale": "zh-CN"}}}
{"pid": "P2650", "type": "P", "difficulty": 4, "samples": [["3 2\n2 5\n0 10\n5 8\n0 6\n8 2", "3\n2"], ["1 2\n0 10\n9 1\n10 1", "1 \n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["二分"], "title": "弹幕考察", "background": "zeromaker 是个手残，但是他喜欢玩东方 project，ex 什么的最喜欢了", "description": "zeromaker 对弹幕的视野控制有着深刻的研究。 每个弹幕在一段特定的时间内会出现在 zeromaker 的视野内，除此之外的时间都在 zeromaker 看不到的地方。在 zeromaker 看来，视野内的弹幕数量越多，图就越难，因为这意味着 @#￥%。 现在，zeromaker 想要评测这张图的难度，他已经知道了每个弹幕会在什么时候出现在视野内，他想知道，在一段时间内，总共有多少个弹幕出现在他的视野内过。", "inputFormat": "第一行有两个整数 $n$ ， $m$ ,表示一共有 $n$ 个弹幕，而 zeromaker 有 $m$ 个问题。\n\n接下来 $n$ 行，每行两个数 $a$，$b$，表示这个弹幕 $a$ 秒时出现在 zeromaker 的视野内，出现了 $b$ 秒。 接下来 $m$ 行，每行两个整数 $x$ ， $y$ ，表示从 $x$ 秒开始，经过 $y$ 秒，其中有多少个弹幕出现过。\n\n注意：此处的“秒”为**时刻**，弹幕在视野出现过当且仅当视野观测与弹幕出现的时间间隔存在重合，**仅端点重合**（如弹幕在第 $2$ 秒结束的同时观测从第 $2$ 秒开始）**不算在视野出现**。", "outputFormat": "$m$ 行，即对于 zeromaker 提出的每个问题的答案。", "hint": "**样例1说明：**\n\n```text\n       0  1  2  3  4  5  6  7  8  9 10 11 12 13\n弹幕1        |--------------|\n弹幕2  |-----------------------------|\n弹幕3                 |-----------------------|\n视野1  |-----------------|\n视野2                          |-----|\n```\n\n**样例2说明：**\n\n```text\n       0  1  2  3  4  5  6  7  8  9 10 11\n弹幕1  |-----------------------------|\n视野1                             |--|\n视野2                                |--|\n```\n\n- $30\\%$ 的数据：$n,m \\le 10^3$。\n- $100\\%$ 的数据：$1 \\le n,m \\le 10^5$，$0 \\le x,y,a,b \\le 2^{31}-1$。", "locale": "zh-CN", "translations": {"en": {"title": "Danmaku Assessment", "background": "zeromaker is clumsy, but he likes to play Touhou Project; EX and the like are his favorites.", "description": "zeromaker has conducted in-depth research on controlling his field of view for danmaku. Each danmaku appears in zeromaker’s field of view during a specific time interval, and is invisible outside that interval. In zeromaker’s opinion, the more danmaku are within the field of view, the harder the stage becomes, because this means @#￥%. Now, to evaluate the difficulty of a stage, he has already learned when each danmaku appears within his field of view. He wants to know, within a given time period, how many distinct danmaku have ever appeared in his field of view.\n\nNote: Here, “seconds” are treated as time instants. A danmaku is considered to have appeared in the field of view if and only if the observation interval and the danmaku’s appearance interval overlap with positive length; endpoint-only contact (for example, a danmaku ends at second $2$ and the observation starts at second $2$) does not count as appearing.\n\n# Description\n\nThe first line contains two integers $n$, $m$, indicating there are $n$ danmaku in total, and zeromaker has $m$ queries.\n\nThe next $n$ lines each contain two integers $a$, $b$, meaning this danmaku appears in zeromaker’s field of view starting at second $a$ and lasts for $b$ seconds. The following $m$ lines each contain two integers $x$, $y$, meaning starting from second $x$, over $y$ seconds, ask how many danmaku have appeared at any time in that interval.\n\nNote: Here, “seconds” are time instants. A danmaku is considered to have appeared in the field of view if and only if the observation interval and the danmaku’s appearance interval overlap with positive length; endpoint-only contact (e.g., the danmaku ends at second $2$ while the observation starts at second $2$) does not count as appearing.", "inputFormat": "The first line contains two integers $n$, $m$.\n\nThe next $n$ lines each contain two integers $a$, $b$, where the danmaku appears at second $a$ and lasts for $b$ seconds.\n\nThe next $m$ lines each contain two integers $x$, $y$, asking: from second $x$, over $y$ seconds, how many danmaku have ever appeared.", "outputFormat": "Output $m$ lines, where each line is the answer to one of zeromaker’s queries.", "hint": "Sample 1 explanation:\n\n```text\n       0  1  2  3  4  5  6  7  8  9 10 11 12 13\n弹幕1        |--------------|\n弹幕2  |-----------------------------|\n弹幕3                 |-----------------------|\n视野1  |-----------------|\n视野2                          |-----|\n```\n\nSample 2 explanation:\n\n```text\n       0  1  2  3  4  5  6  7  8  9 10 11\n弹幕1  |-----------------------------|\n视野1                             |--|\n视野2                                |--|\n```\n\nConstraints:\n- $30\\%$ of the testdata: $n, m \\le 10^3$.\n- $100\\%$ of the testdata: $1 \\le n, m \\le 10^5$, $0 \\le x, y, a, b \\le 2^{31} - 1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "弹幕考察", "background": "zeromaker 是个手残，但是他喜欢玩东方 project，ex 什么的最喜欢了", "description": "zeromaker 对弹幕的视野控制有着深刻的研究。 每个弹幕在一段特定的时间内会出现在 zeromaker 的视野内，除此之外的时间都在 zeromaker 看不到的地方。在 zeromaker 看来，视野内的弹幕数量越多，图就越难，因为这意味着 @#￥%。 现在，zeromaker 想要评测这张图的难度，他已经知道了每个弹幕会在什么时候出现在视野内，他想知道，在一段时间内，总共有多少个弹幕出现在他的视野内过。", "inputFormat": "第一行有两个整数 $n$ ， $m$ ,表示一共有 $n$ 个弹幕，而 zeromaker 有 $m$ 个问题。\n\n接下来 $n$ 行，每行两个数 $a$，$b$，表示这个弹幕 $a$ 秒时出现在 zeromaker 的视野内，出现了 $b$ 秒。 接下来 $m$ 行，每行两个整数 $x$ ， $y$ ，表示从 $x$ 秒开始，经过 $y$ 秒，其中有多少个弹幕出现过。\n\n注意：此处的“秒”为**时刻**，弹幕在视野出现过当且仅当视野观测与弹幕出现的时间间隔存在重合，**仅端点重合**（如弹幕在第 $2$ 秒结束的同时观测从第 $2$ 秒开始）**不算在视野出现**。", "outputFormat": "$m$ 行，即对于 zeromaker 提出的每个问题的答案。", "hint": "**样例1说明：**\n\n```text\n       0  1  2  3  4  5  6  7  8  9 10 11 12 13\n弹幕1        |--------------|\n弹幕2  |-----------------------------|\n弹幕3                 |-----------------------|\n视野1  |-----------------|\n视野2                          |-----|\n```\n\n**样例2说明：**\n\n```text\n       0  1  2  3  4  5  6  7  8  9 10 11\n弹幕1  |-----------------------------|\n视野1                             |--|\n视野2                                |--|\n```\n\n- $30\\%$ 的数据：$n,m \\le 10^3$。\n- $100\\%$ 的数据：$1 \\le n,m \\le 10^5$，$0 \\le x,y,a,b \\le 2^{31}-1$。", "locale": "zh-CN"}}}
{"pid": "P2651", "type": "P", "difficulty": 2, "samples": [["2\n4\n1 2 1 4\n5\n6 5 7 9 12", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "高精度", "2015", "洛谷原创", "最大公约数 gcd", "进制", "洛谷月赛"], "title": "添加括号III", "background": "", "description": "现在给出一个表达式，形如 $a_{1}/a_{2}/a_{3}/.../a_{n}$。\n\n如果直接计算，就是一个个除过去，比如 $1/2/1/4 = 1/8$。\n\n然而小$\\text{A}$看到一个分数感觉很不舒服，希望通过添加一些括号使其变成一个整数。一种可行的办法是 $(1/2)/(1/4)=2$ 。\n\n现在给出这个表达式，求问是否可以通过添加一些括号改变运算顺序使其成为一个整数。", "inputFormat": "一个测试点中会有多个表达式。\n\n第一行 $t$ ，表示表达式数量。\n\n对于每个表达式，第一行是 $n$，第二行 $n$ 个数，第 $i$ 个数表示 $a_{i}$。", "outputFormat": "输出 $t$ 行。\n\n对于每个表达式，如果可以通过添加括号改变顺序使其变成整数，那么输出 `Yes`，否则输出 `No`。", "hint": "- 对于 $40\\%$ 的数据，$n \\le 16$。\n- 对于 $70\\%$ 的数据，$n \\le 100$。\n- 对于 $100\\%$ 的数据， $2 \\le n \\le 10000$，$1 \\le t \\le 100$，$1 \\le a_{i}\\le 2^{31}-1$。", "locale": "zh-CN", "translations": {"en": {"title": "Add Parentheses III", "background": "", "description": "You are given an expression of the form $a_{1}/a_{2}/a_{3}/.../a_{n}$.\n\nIf you evaluate it directly from left to right, for example, $1/2/1/4 = 1/8$.\n\nHowever, Little A feels uncomfortable seeing a fraction and wants to insert some parentheses to make it an integer. One possible way is $(1/2)/(1/4)=2$.\n\nGiven the expression, determine whether it is possible to change the evaluation order by adding parentheses so that the result becomes an integer.", "inputFormat": "There are multiple expressions in one test file.\n\nThe first line contains $t$, the number of expressions.\n\nFor each expression, the first line contains $n$, and the second line contains $n$ numbers. The $i$-th number denotes $a_{i}$.", "outputFormat": "Output $t$ lines.\n\nFor each expression, if it is possible to change the evaluation order by adding parentheses to make the result an integer, output `Yes`; otherwise, output `No`.", "hint": "- For $40\\%$ of the testdata, $n \\le 16$.\n- For $70\\%$ of the testdata, $n \\le 100$.\n- For $100\\%$ of the testdata, $2 \\le n \\le 10000$, $1 \\le t \\le 100$, $1 \\le a_{i}\\le 2^{31}-1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "添加括号III", "background": "", "description": "现在给出一个表达式，形如 $a_{1}/a_{2}/a_{3}/.../a_{n}$。\n\n如果直接计算，就是一个个除过去，比如 $1/2/1/4 = 1/8$。\n\n然而小$\\text{A}$看到一个分数感觉很不舒服，希望通过添加一些括号使其变成一个整数。一种可行的办法是 $(1/2)/(1/4)=2$ 。\n\n现在给出这个表达式，求问是否可以通过添加一些括号改变运算顺序使其成为一个整数。", "inputFormat": "一个测试点中会有多个表达式。\n\n第一行 $t$ ，表示表达式数量。\n\n对于每个表达式，第一行是 $n$，第二行 $n$ 个数，第 $i$ 个数表示 $a_{i}$。", "outputFormat": "输出 $t$ 行。\n\n对于每个表达式，如果可以通过添加括号改变顺序使其变成整数，那么输出 `Yes`，否则输出 `No`。", "hint": "- 对于 $40\\%$ 的数据，$n \\le 16$。\n- 对于 $70\\%$ 的数据，$n \\le 100$。\n- 对于 $100\\%$ 的数据， $2 \\le n \\le 10000$，$1 \\le t \\le 100$，$1 \\le a_{i}\\le 2^{31}-1$。", "locale": "zh-CN"}}}
{"pid": "P2652", "type": "P", "difficulty": 4, "samples": [["5\n1 1\n1 2\n1 3\n1 4\n1 5", "0"], ["5\n1 9\n1 10\n2 11\n2 12\n2 13", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["离散化"], "title": "同花顺", "background": "所谓同花顺，就是指一些扑克牌，它们花色相同，并且数字连续。\n", "description": "现在我手里有 $n$ 张扑克牌，但它们可能并不能凑成同花顺。我现在想知道，最少更换其中的多少张牌，我能让这 $n$ 张牌都凑成同花顺？", "inputFormat": "第一行一个整数 $n$ ，表示扑克牌的张数。\n\n接下来 $n$ 行，每行两个整数 $a_{i}$ 和 $b_{i}$。其中 $a_{i}$ 表示第 $i$ 张牌的花色，$b_{i}$ 表示第  $i$ 张牌的数字。", "outputFormat": "一行一个整数，表示最少更换多少张牌可以达到目标。\n", "hint": "- 对于 $30\\%$ 的数据，$n \\le 10$；\n- 对于 $60\\%$ 的数据，$n \\le 10^{5}$，$ 1 \\le a_{i} \\le 10^{5}$，$1 \\le b_{i} \\le n$；\n- 对于 $100\\%$ 的数据，$n \\le 10^{5}$，$1 \\le a_{i}, b_{i} \\le 10^{9}$；", "locale": "zh-CN", "translations": {"en": {"title": "Straight Flush", "background": "A straight flush refers to some playing cards whose suits are the same and whose ranks are consecutive.", "description": "Now I have $n$ playing cards, but they may not form a straight flush. I want to know the minimum number of cards I need to replace so that all $n$ cards form a straight flush.", "inputFormat": "The first line contains an integer $n$, indicating the number of playing cards.\n\nThen $n$ lines follow, each containing two integers $a_{i}$ and $b_{i}$. Here, $a_{i}$ denotes the suit of the $i$-th card, and $b_{i}$ denotes the rank of the $i$-th card.", "outputFormat": "Output a single integer on one line, indicating the minimum number of cards that need to be replaced to achieve the goal.", "hint": "- For $30\\%$ of the testdata, $n \\le 10$.\n- For $60\\%$ of the testdata, $n \\le 10^{5}$, $1 \\le a_{i} \\le 10^{5}$, $1 \\le b_{i} \\le n$.\n- For $100\\%$ of the testdata, $n \\le 10^{5}$, $1 \\le a_{i}, b_{i} \\le 10^{9}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "同花顺", "background": "所谓同花顺，就是指一些扑克牌，它们花色相同，并且数字连续。\n", "description": "现在我手里有 $n$ 张扑克牌，但它们可能并不能凑成同花顺。我现在想知道，最少更换其中的多少张牌，我能让这 $n$ 张牌都凑成同花顺？", "inputFormat": "第一行一个整数 $n$ ，表示扑克牌的张数。\n\n接下来 $n$ 行，每行两个整数 $a_{i}$ 和 $b_{i}$。其中 $a_{i}$ 表示第 $i$ 张牌的花色，$b_{i}$ 表示第  $i$ 张牌的数字。", "outputFormat": "一行一个整数，表示最少更换多少张牌可以达到目标。\n", "hint": "- 对于 $30\\%$ 的数据，$n \\le 10$；\n- 对于 $60\\%$ 的数据，$n \\le 10^{5}$，$ 1 \\le a_{i} \\le 10^{5}$，$1 \\le b_{i} \\le n$；\n- 对于 $100\\%$ 的数据，$n \\le 10^{5}$，$1 \\le a_{i}, b_{i} \\le 10^{9}$；", "locale": "zh-CN"}}}
{"pid": "P2654", "type": "P", "difficulty": 5, "samples": [["10 2 3\n1 2 3 4 5 6 7 8 9 10\n1 2\n1 2\n1 2", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2015", "堆", "洛谷原创", "洛谷月赛"], "title": "原核生物培养", "background": "", "description": "W 教授最近正在研究一种原核生物，这种生物的生长方式很奇特，只能通过吃掉同类而生长。两个该种生物相遇，较大质量的会把较小的吃掉（相同的话就看 RP 了），吃掉后较大的生物的质量会变为两只原核生物重量之和，但这个过程会消耗酶，消耗的酶近似为它们重量之和。\n\nW 教授现在有 $n$ 只原核生物，他每次会从培养皿中取重量最小的 $m$ 个生物进行实验，让它们自相残杀。\n\n实验的操作是这样的，教授将这 $m$ 个原核生物按某种重量大小的顺序放在一个环形的管道里，然后给其中相邻两只原核生物酶，如此反复。最后把剩下的那只放回培养皿，接着进行下次实验。W 教授希望经过 $k$ 次实验后耗能最少。输入数据保证，不会出现生物不够的情况。\n", "inputFormat": "第一行有三个整数，分别为 $n$, $m$, $k$。\n\n第二行有 $n$ 个整数，代表最初 $n$ 个生物的重量。\n\n接下来的 $k$ 行，每行 $m$ 个整数，第 $i+2$ 行的第 $j$ 个数代表第 $i$ 次实验的第 $j$ 小的生物放在哪个位置。例如 $m=5$，第三行为，$14235$ 代表最小的生物放在第一个位置，第二小的放第三个 $\\ldots$ 最大的放在第五个位置（和第一个位置相邻）。\n", "outputFormat": "只有一个整数，代表 $k$ 次实验之后最小消耗酶的量。\n", "hint": "对于 $100\\%$ 的数据，$1<n\\leq 1000$, $1\\leq m\\leq 10$, $1\\leq k\\leq 100$。数据保证结果不超过 $2^{31}$。\n\n样例解释：\n\n第一次是用重量为 $1, 2$ 消耗酶 $3$，变为一个重量 $3$。\n\n第二次是用重量为 $3, 3$ 消耗酶 $6$，变为一个重量 $6$。\n\n第三次是用重量为 $4, 5$ 消耗酶 $9$，变为一个重量 $9$。\n\n所以消耗总酶为 $18$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Prokaryote Cultivation", "background": "", "description": "Professor W is studying a kind of prokaryote whose growth is peculiar: it can grow only by devouring its conspecifics. When two such organisms meet, the heavier one eats the lighter one (if they have the same weight, it is decided by “RP”, i.e., luck). After eating, the survivor’s weight becomes the sum of the two weights, and the amount of enzyme consumed is approximately equal to the sum of their weights.\n\nProfessor W currently has $n$ prokaryotes. Each time, he takes the $m$ lightest organisms from the petri dish for an experiment and lets them fight each other.\n\nThe operation is as follows: he places these $m$ organisms around a circular tube in some order according to their weights, then repeatedly chooses a pair of adjacent organisms and supplies enzyme to them; after they merge, the survivor’s weight becomes the sum of the two, and the enzyme consumed equals that sum. Repeat this until only one organism remains. The remaining one is put back into the petri dish, and the next experiment begins. Professor W wants the total enzyme consumption to be minimized after $k$ experiments. The input guarantees that there will never be a shortage of organisms.", "inputFormat": "The first line contains three integers $n$, $m$, $k$.\n\nThe second line contains $n$ integers, the initial weights of the $n$ organisms.\n\nThe next $k$ lines each contain $m$ integers. In the $(i+2)$-th line, the $j$-th number denotes the position where the $j$-th lightest organism in the $i$-th experiment is placed. For example, if $m=5$ and the line is $14235$, it means the smallest organism is placed in position 1, the second smallest in position 4, the third smallest in position 2, the fourth smallest in position 3, and the largest in position 5 (which is adjacent to position 1).", "outputFormat": "Output a single integer, the minimal total amount of enzyme consumed after $k$ experiments.", "hint": "Constraints: For $100\\%$ of the testdata, $1 < n \\leq 1000$, $1 \\leq m \\leq 10$, $1 \\leq k \\leq 100$. It is guaranteed that the result does not exceed $2^{31}$.\n\nSample explanation:\nIn the first experiment, use weights $1, 2$, consuming $3$ enzyme and merging into weight $3$.\nIn the second experiment, use weights $3, 3$, consuming $6$ enzyme and merging into weight $6$.\nIn the third experiment, use weights $4, 5$, consuming $9$ enzyme and merging into weight $9$.\nTherefore, the total enzyme consumption is $18$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "原核生物培养", "background": "", "description": "W 教授最近正在研究一种原核生物，这种生物的生长方式很奇特，只能通过吃掉同类而生长。两个该种生物相遇，较大质量的会把较小的吃掉（相同的话就看 RP 了），吃掉后较大的生物的质量会变为两只原核生物重量之和，但这个过程会消耗酶，消耗的酶近似为它们重量之和。\n\nW 教授现在有 $n$ 只原核生物，他每次会从培养皿中取重量最小的 $m$ 个生物进行实验，让它们自相残杀。\n\n实验的操作是这样的，教授将这 $m$ 个原核生物按某种重量大小的顺序放在一个环形的管道里，然后给其中相邻两只原核生物酶，如此反复。最后把剩下的那只放回培养皿，接着进行下次实验。W 教授希望经过 $k$ 次实验后耗能最少。输入数据保证，不会出现生物不够的情况。\n", "inputFormat": "第一行有三个整数，分别为 $n$, $m$, $k$。\n\n第二行有 $n$ 个整数，代表最初 $n$ 个生物的重量。\n\n接下来的 $k$ 行，每行 $m$ 个整数，第 $i+2$ 行的第 $j$ 个数代表第 $i$ 次实验的第 $j$ 小的生物放在哪个位置。例如 $m=5$，第三行为，$14235$ 代表最小的生物放在第一个位置，第二小的放第三个 $\\ldots$ 最大的放在第五个位置（和第一个位置相邻）。\n", "outputFormat": "只有一个整数，代表 $k$ 次实验之后最小消耗酶的量。\n", "hint": "对于 $100\\%$ 的数据，$1<n\\leq 1000$, $1\\leq m\\leq 10$, $1\\leq k\\leq 100$。数据保证结果不超过 $2^{31}$。\n\n样例解释：\n\n第一次是用重量为 $1, 2$ 消耗酶 $3$，变为一个重量 $3$。\n\n第二次是用重量为 $3, 3$ 消耗酶 $6$，变为一个重量 $6$。\n\n第三次是用重量为 $4, 5$ 消耗酶 $9$，变为一个重量 $9$。\n\n所以消耗总酶为 $18$。\n", "locale": "zh-CN"}}}
{"pid": "P2655", "type": "P", "difficulty": 3, "samples": [["1                             \r\n16 2000 1 1 0 0 0", "2000 1 1 9 6 7"], ["2\r\n32 1970 1 1 0 0 0\r\n32 2015 11 8 8 30 0", "2038 1 19 3 14 7\r\n2083 11 26 11 44 7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "2015", "洛谷原创", "枚举", "洛谷月赛"], "title": "2038 年问题", "background": null, "description": "网络时代，机会与危机共存。“千年虫”解决之后，会不会有新的“虫”出现？回答是肯定的，“2038 年”就是一个新的关卡。\n\n也许大家都已经知道计算机的 $2000$ 年问题是什么概念，但是什么时候又冒出来一个 $2038$ 年问题的呢？\n\n用C语言编制的程序不会碰到 $2000$ 年问题，但是会有 $2038$ 年问题。这是因为，大多数 C 语言程序都使用到一个叫做“标准时间库”的程序库，这个时间库用一个标准的 $4$ 字节也就是 $32$ 位的形式来储存时间信息。\n\n当初设计的时候，这个 $4$ 字节的时间格式把 $1970$ 年 $1$ 月 $1$ 日凌晨 $0$ 时 $0$ 分 $0$ 秒作为时间起点，这时的时间值为 $0$。以后所有的时间都是从这个时间开始一秒一秒累积得来的。\n\n比方说如果时间已经累积到了 $919642718$ 这个数值，就是说这时距离 $1970$ 年 $1$ 月 $1$ 日凌晨 $0$ 时 $0$ 分 $0$ 已经过去了 $919642718$ 秒，换算一下就应该是 $1999$ 年 $2$ 月 $21$ 日星期天 $16$ 时 $18$ 分 $38$ 秒。\n\n这样计算时间的好处在于，把任意两个时间值相减之后，就可以很迅速地得到这两个时间之间相差的秒数，然后你可以利用别的程序把它换算成明白易懂的年月日时分秒的形式。\n\n一个 $4$ 字节也就是 $32$ 位的存储空间的最大值是 $2147483647$，请注意！$2038$ 年问题的关键也就在这里———当时间一秒一秒地跳完 $2147483647$ 那惊心动魄的最后一秒后，它就会转为负数也就是说时间无效。那一刻的准确的时间为 $2038$ 年 $1$ 月 $19$ 日星期二晚上 $03:14:07$，之后所有用到这种“标准时间库”的 C 语言程序都会碰到时间计算上的麻烦。\n\n你要解决的问题是，现有一台计算机，表示时间的变量长度为 $N$ 位。给定一个“时间起点”，求出对于这个“时间起点”时间，最后的有效时间是什么时候。", "inputFormat": "第一行为数据组数 $T$。\n\n第 $2\\sim T+1$ 行，每行 $7$ 个数字描述一组数据，分别为表示时间的变量长度（二进制位数），然后是“时间起点”的年份，月份，日期，小时，分钟，秒数。", "outputFormat": "$T$ 行，对于每组数据，输出 $1$ 行，$6$ 个数字，分别表示最后的有效时间的年份，月份，日期，小时，分钟，秒数。", "hint": "对于 $50\\%$ 的数据 变量的位数 $\\le 16$；\n\n对于所有数据，变量长度 $\\le 32$，数据组数 $\\le1000$，$0\\le$ 年份 $\\le10000$。", "locale": "zh-CN", "translations": {"en": {"title": "The Year 2038 Problem", "background": "", "description": "In the network era, opportunities and crises coexist. After the \"Y2K bug\" was solved, would a new \"bug\" appear? The answer is yes: \"the year 2038\" is a new hurdle.\n\nMaybe everyone already knows what the $2000$ year problem in computers is, but when did the $2038$ year problem emerge?\n\nPrograms written in C will not encounter the $2000$ year problem, but they will have the $2038$ year problem. This is because most C programs use a \"standard time library,\" which stores time information in a standard $4$-byte, that is, $32$-bit, format.\n\nWhen it was designed, this $4$-byte time format took $1970$ year $1$ month $1$ day at $0$ hour $0$ minute $0$ second as the time origin (value $0$). All subsequent times are counted by accumulating seconds from this point.\n\nFor example, if the accumulated value has reached $919642718$, it means that $919642718$ seconds have passed since $1970$ year $1$ month $1$ day at $0$ hour $0$ minute $0$ second. Converted, it should be Sunday, $1999$ year $2$ month $21$ day at $16$ hour $18$ minute $38$ second.\n\nThe advantage of calculating time this way is that by subtracting any two time values, you can quickly get the number of seconds between them, and then use other routines to convert it into a human-readable year-month-day hour-minute-second format.\n\nThe maximum value of a $4$-byte, that is, $32$-bit, storage is $2147483647$. Note! The key to the $2038$ year problem lies here—after time ticks through the heart-stopping final second $2147483647$, it will overflow into a negative number, meaning the time becomes invalid. The exact moment is Tuesday, $2038$ year $1$ month $19$ day at $03:14:07$. After that, all C programs using this \"standard time library\" will run into trouble with time calculations.\n\nYour task: given a computer whose time variable has length $N$ bits and a given \"time origin,\" determine the last valid time with respect to this \"time origin.\"", "inputFormat": "The first line contains the number of test cases $T$.\n\nLines $2$ to $T+1$: each line contains $7$ integers describing one test case: the number of bits of the time variable (in binary), followed by the year, month, day, hour, minute, and second of the \"time origin.\"", "outputFormat": "Output $T$ lines. For each test case, output $1$ line with $6$ integers: the year, month, day, hour, minute, and second of the last valid time.", "hint": "For $50\\%$ of the testdata, the number of bits of the variable $\\le 16$.\n\nFor all testdata, the variable length $\\le 32$, the number of test cases $\\le 1000$, and $0 \\le$ year $\\le 10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "2038 年问题", "background": null, "description": "网络时代，机会与危机共存。“千年虫”解决之后，会不会有新的“虫”出现？回答是肯定的，“2038 年”就是一个新的关卡。\n\n也许大家都已经知道计算机的 $2000$ 年问题是什么概念，但是什么时候又冒出来一个 $2038$ 年问题的呢？\n\n用C语言编制的程序不会碰到 $2000$ 年问题，但是会有 $2038$ 年问题。这是因为，大多数 C 语言程序都使用到一个叫做“标准时间库”的程序库，这个时间库用一个标准的 $4$ 字节也就是 $32$ 位的形式来储存时间信息。\n\n当初设计的时候，这个 $4$ 字节的时间格式把 $1970$ 年 $1$ 月 $1$ 日凌晨 $0$ 时 $0$ 分 $0$ 秒作为时间起点，这时的时间值为 $0$。以后所有的时间都是从这个时间开始一秒一秒累积得来的。\n\n比方说如果时间已经累积到了 $919642718$ 这个数值，就是说这时距离 $1970$ 年 $1$ 月 $1$ 日凌晨 $0$ 时 $0$ 分 $0$ 已经过去了 $919642718$ 秒，换算一下就应该是 $1999$ 年 $2$ 月 $21$ 日星期天 $16$ 时 $18$ 分 $38$ 秒。\n\n这样计算时间的好处在于，把任意两个时间值相减之后，就可以很迅速地得到这两个时间之间相差的秒数，然后你可以利用别的程序把它换算成明白易懂的年月日时分秒的形式。\n\n一个 $4$ 字节也就是 $32$ 位的存储空间的最大值是 $2147483647$，请注意！$2038$ 年问题的关键也就在这里———当时间一秒一秒地跳完 $2147483647$ 那惊心动魄的最后一秒后，它就会转为负数也就是说时间无效。那一刻的准确的时间为 $2038$ 年 $1$ 月 $19$ 日星期二晚上 $03:14:07$，之后所有用到这种“标准时间库”的 C 语言程序都会碰到时间计算上的麻烦。\n\n你要解决的问题是，现有一台计算机，表示时间的变量长度为 $N$ 位。给定一个“时间起点”，求出对于这个“时间起点”时间，最后的有效时间是什么时候。", "inputFormat": "第一行为数据组数 $T$。\n\n第 $2\\sim T+1$ 行，每行 $7$ 个数字描述一组数据，分别为表示时间的变量长度（二进制位数），然后是“时间起点”的年份，月份，日期，小时，分钟，秒数。", "outputFormat": "$T$ 行，对于每组数据，输出 $1$ 行，$6$ 个数字，分别表示最后的有效时间的年份，月份，日期，小时，分钟，秒数。", "hint": "对于 $50\\%$ 的数据 变量的位数 $\\le 16$；\n\n对于所有数据，变量长度 $\\le 32$，数据组数 $\\le1000$，$0\\le$ 年份 $\\le10000$。", "locale": "zh-CN"}}}
{"pid": "P2656", "type": "P", "difficulty": 4, "samples": [["3 3\n1 2 4 0.5\n1 3 7 0.1\n2 3 4 0.6\n1", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2015", "洛谷原创", "强连通分量", "洛谷月赛"], "title": "采蘑菇", "background": "", "description": "小胖和 ZYR 要去 ESQMS 森林采蘑菇。\n\nESQMS 森林间有 $N$ 个小树丛，$M$ 条小径，每条小径都是单向的，连接两个小树丛，上面都有一定数量的蘑菇。小胖和 ZYR 经过某条小径一次，可以采走这条路上所有的蘑菇。由于 ESQMS 森林是一片神奇的沃土，所以一条路上的蘑菇被采过后，又会长出一些新的蘑菇，数量为原来蘑菇的数量乘上这条路的“恢复系数”，再下取整。\n\n比如，一条路上有 $4$ 个蘑菇，这条路的“恢复系数”为 $0.7$，则第一~四次经过这条路径所能采到的蘑菇数量分别为 $4,2,1,0$。\n\n现在，小胖和 ZYR 从 $S$ 号小树丛出发，求他们最多能采到多少蘑菇。\n", "inputFormat": "第一行两个整数，$N$ 和 $M$。\n\n第二行到第 $M+1$ 行，每行四个数，分别表示一条小路的起点，终点，初始蘑菇数，恢复系数。\n\n第 $M+2$ 行，一个整数 $S$。\n", "outputFormat": "一行一个整数，表示最多能采到多少蘑菇，保证答案不超过 $(2^{31}-1)$。\n", "hint": "对于 $30\\%$ 的数据，$N\\le 7$，$M\\le15$\n\n另有 $30\\%$ 的数据，满足所有“恢复系数”为 $0$。\n\n对于 $100\\%$ 的数据，$1\n\\le N\\le 8\\times 10^4$，$1\\le M\\le 2\\times 10^5$，$0\\le\\text{恢复系数}\\le 0.8$ 且最多有一位小数， $1\\le S\\le N$。", "locale": "zh-CN", "translations": {"en": {"title": "Picking Mushrooms", "background": "", "description": "Xiaopang and ZYR are going to the ESQMS forest to pick mushrooms.\n\nIn the ESQMS forest, there are $N$ small thickets and $M$ paths. Each path is directed, connects two thickets, and has some mushrooms on it. When Xiaopang and ZYR traverse a path once, they can collect all the mushrooms on that path. Because the ESQMS forest is a magical fertile land, after the mushrooms on a path are picked, new mushrooms will grow on that path again, with the quantity equal to the original number of mushrooms multiplied by the path’s \"recovery factor\", then rounded down.\n\nFor example, if a path initially has $4$ mushrooms and its \"recovery factor\" is $0.7$, then the numbers of mushrooms that can be collected on the first through fourth traversals are $4, 2, 1, 0$ respectively.\n\nNow, starting from thicket $S$, find the maximum number of mushrooms they can collect.", "inputFormat": "The first line contains two integers, $N$ and $M$.\n\nFrom the second line to the $(M+1)$-th line, each line contains four numbers, representing the start thicket, the end thicket, the initial number of mushrooms, and the recovery factor of a path.\n\nThe $(M+2)$-th line contains an integer $S$.", "outputFormat": "Output one line with a single integer, the maximum number of mushrooms that can be collected. It is guaranteed that the answer does not exceed $(2^{31}-1)$.", "hint": "For $30\\%$ of the testdata, $N\\le 7$, $M\\le15$.\n\nFor another $30\\%$ of the testdata, all \"recovery factors\" are $0$.\n\nFor $100\\%$ of the testdata, $1\\le N\\le 8\\times 10^4$, $1\\le M\\le 2\\times 10^5$, $0\\le\\text{恢复系数}\\le 0.8$ with at most one decimal place, and $1\\le S\\le N$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "采蘑菇", "background": "", "description": "小胖和 ZYR 要去 ESQMS 森林采蘑菇。\n\nESQMS 森林间有 $N$ 个小树丛，$M$ 条小径，每条小径都是单向的，连接两个小树丛，上面都有一定数量的蘑菇。小胖和 ZYR 经过某条小径一次，可以采走这条路上所有的蘑菇。由于 ESQMS 森林是一片神奇的沃土，所以一条路上的蘑菇被采过后，又会长出一些新的蘑菇，数量为原来蘑菇的数量乘上这条路的“恢复系数”，再下取整。\n\n比如，一条路上有 $4$ 个蘑菇，这条路的“恢复系数”为 $0.7$，则第一~四次经过这条路径所能采到的蘑菇数量分别为 $4,2,1,0$。\n\n现在，小胖和 ZYR 从 $S$ 号小树丛出发，求他们最多能采到多少蘑菇。\n", "inputFormat": "第一行两个整数，$N$ 和 $M$。\n\n第二行到第 $M+1$ 行，每行四个数，分别表示一条小路的起点，终点，初始蘑菇数，恢复系数。\n\n第 $M+2$ 行，一个整数 $S$。\n", "outputFormat": "一行一个整数，表示最多能采到多少蘑菇，保证答案不超过 $(2^{31}-1)$。\n", "hint": "对于 $30\\%$ 的数据，$N\\le 7$，$M\\le15$\n\n另有 $30\\%$ 的数据，满足所有“恢复系数”为 $0$。\n\n对于 $100\\%$ 的数据，$1\n\\le N\\le 8\\times 10^4$，$1\\le M\\le 2\\times 10^5$，$0\\le\\text{恢复系数}\\le 0.8$ 且最多有一位小数， $1\\le S\\le N$。", "locale": "zh-CN"}}}
{"pid": "P2657", "type": "P", "difficulty": 3, "samples": [["1 10", "9"], ["25 50\n", "20\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "2009", "四川", "各省省选", "记忆化搜索", "数位 DP"], "title": "[SCOI2009] windy 数", "background": "**本题与 [P13085 [SCOI2009] windy 数（加强版）](https://www.luogu.com.cn/problem/P13085) 的区别在于 $\\bm{a}$ 与 $\\bm{b}$ 的范围。**\n\nwindy 定义了一种 windy 数。", "description": "不含前导零且相邻两个数字之差至少为 $2$ 的正整数被称为 windy 数。windy 想知道，在 $a$ 和 $b$ 之间，包括 $a$ 和 $b$ ，总共有多少个 windy 数？", "inputFormat": "输入只有一行两个整数，分别表示 $a$ 和 $b$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq a \\leq b \\leq 2 \\times 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2009] Windy Numbers", "background": "The difference between this problem and P13085 [SCOI2009] windy 数（加强版） is the ranges of $\\bm{a}$ and $\\bm{b}$.\n\nWindy defined a kind of \"windy number\".", "description": "A positive integer without leading zeros, where the absolute difference between every pair of adjacent digits is at least $2$, is called a windy number. Windy wants to know: between $a$ and $b$, inclusive, how many windy numbers are there?", "inputFormat": "The input contains a single line with two integers, representing $a$ and $b$.", "outputFormat": "Output a single line with one integer, the answer.", "hint": "#### Constraints\n\nFor all test points, it is guaranteed that $1 \\leq a \\leq b \\leq 2 \\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2009] windy 数", "background": "**本题与 [P13085 [SCOI2009] windy 数（加强版）](https://www.luogu.com.cn/problem/P13085) 的区别在于 $\\bm{a}$ 与 $\\bm{b}$ 的范围。**\n\nwindy 定义了一种 windy 数。", "description": "不含前导零且相邻两个数字之差至少为 $2$ 的正整数被称为 windy 数。windy 想知道，在 $a$ 和 $b$ 之间，包括 $a$ 和 $b$ ，总共有多少个 windy 数？", "inputFormat": "输入只有一行两个整数，分别表示 $a$ 和 $b$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq a \\leq b \\leq 2 \\times 10^9$。", "locale": "zh-CN"}}}
{"pid": "P2658", "type": "P", "difficulty": 4, "samples": [["3 5 \n20 21 18 99 5  \n19 22 20 16 26\n18 17 40 60 80\n1 0 0 0 1\n0 0 0 0 0\n0 0 0 0 1", "21"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "二分", "并查集", "洛谷原创", "排序", "广度优先搜索 BFS", "洛谷月赛"], "title": "汽车拉力比赛", "background": null, "description": "博艾市将要举行一场汽车拉力比赛。\n\n赛场凹凸不平，所以被描述为 $N*M$ 的网格来表示海拔高度 $(1 \\leq M,N \\leq 500)$，每个单元格的海拔范围在 $0$ 到 $10^9$ 之间。\n\n其中一些单元格被定义为路标。组织者希望给整个路线指定一个难度系数 $D$，这样参赛选手从任一路标到达别的路标所经过的路径上相邻单元格的海拔高度差不会大于 $D$ 。也就是说这个难度系数 $D$ 指的是保证所有路标相互可达的最小值。任一单元格和其东西南北四个方向上的单元格都是相邻的。", "inputFormat": "第 $1$ 行两个整数 $M$ 和 $N$。第 $2$ 行到第 $M+1$ 行，每行 $N$ 个整数描述海拔高度。第 $2+M$ 行到第 $1+2M$ 行，每行 $N$ 个整数，每个数非 $0$ 即 $1$，$1$ 表示该单元格是一个路标。", "outputFormat": "一个整数，即赛道的难度系数 $D$。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "Car Rally", "background": "", "description": "Bo'ai City is going to hold a car rally.\n\nThe course is uneven, so it is represented by an $M \\times N$ grid of elevations $(1 \\leq M, N \\leq 500)$. The elevation of each cell is between $0$ and $10^9$.\n\nSome cells are designated as checkpoints. The organizers want to assign a difficulty coefficient $D$ to the entire course such that, for any two checkpoints, there exists a path between them where the elevation difference between any pair of adjacent cells on that path does not exceed $D$. In other words, $D$ is the minimum value that ensures all checkpoints are mutually reachable. Each cell is adjacent to the four cells to its north, south, east, and west.", "inputFormat": "The first line contains two integers $M$ and $N$.\n\nLines $2$ through $M+1$: each line contains $N$ integers giving the elevations.\n\nLines $M+2$ through $2M+1$: each line contains $N$ integers, each either $0$ or $1$; $1$ indicates that the cell is a checkpoint.", "outputFormat": "Output a single integer, the difficulty coefficient $D$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "汽车拉力比赛", "background": null, "description": "博艾市将要举行一场汽车拉力比赛。\n\n赛场凹凸不平，所以被描述为 $N*M$ 的网格来表示海拔高度 $(1 \\leq M,N \\leq 500)$，每个单元格的海拔范围在 $0$ 到 $10^9$ 之间。\n\n其中一些单元格被定义为路标。组织者希望给整个路线指定一个难度系数 $D$，这样参赛选手从任一路标到达别的路标所经过的路径上相邻单元格的海拔高度差不会大于 $D$ 。也就是说这个难度系数 $D$ 指的是保证所有路标相互可达的最小值。任一单元格和其东西南北四个方向上的单元格都是相邻的。", "inputFormat": "第 $1$ 行两个整数 $M$ 和 $N$。第 $2$ 行到第 $M+1$ 行，每行 $N$ 个整数描述海拔高度。第 $2+M$ 行到第 $1+2M$ 行，每行 $N$ 个整数，每个数非 $0$ 即 $1$，$1$ 表示该单元格是一个路标。", "outputFormat": "一个整数，即赛道的难度系数 $D$。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2659", "type": "P", "difficulty": 3, "samples": [["3 \r\n1 2 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "二分", "并查集", "洛谷原创", "ST 表", "笛卡尔树", "单调栈"], "title": "美丽的序列", "background": "GD 是一个热衷于寻求美好事物的人。一天他拿到了一个美丽的序列。", "description": "为了研究这个序列的美丽程度，GD 定义了一个序列的“美丽度”和“美丽系数”：\n\n- 对于这个序列的任意一个区间 $[l,r]$，这个区间的“美丽度”就是这个区间的长度与这个区间的最小值的乘积。\n- 而整个序列的“美丽系数”就是它的所有区间的“美丽度”的最大值。\n\n现在 GD 想要你帮忙计算这个序列的“美丽系数”。", "inputFormat": "第一行一个整数 $n$，代表序列中的元素个数。\n\n第二行 $n$ 个整数 $a_i \\sim a_n$，描述这个序列。", "outputFormat": "一行一个整数，代表这个序列的“美丽系数”。", "hint": "### 样例解释\n\n选取区间 $[2,3]$，可以获得最大的“美丽系数”，为 $2 \\times 2=4$。\n\n### 数据范围\n\n- 对于 $20\\%$ 的数据，$n \\le 2 \\times 10^3$；\n- 对于 $60\\%$ 的数据，$n \\le 2 \\times 10^5$；\n- 对于 $100\\%$ 的数据，$1 \\le n \\le 2 \\times 10^6$，$0 \\le a_i \\le 2 \\times 10^6$。\n\n### 提示\n\n你可能需要一个读入优化。", "locale": "zh-CN", "translations": {"en": {"title": "Beautiful Sequence", "background": "GD is someone who loves seeking beautiful things. One day he obtained a beautiful sequence.", "description": "To study how beautiful this sequence is, GD defines the \"beauty\" and the \"beauty coefficient\" of a sequence.\n- For any subarray $[l, r]$ of this sequence, the \"beauty\" of this subarray is the product of its length and the minimum value within it.\n- The \"beauty coefficient\" of the whole sequence is the maximum \"beauty\" among all its subarrays.\n\nNow GD wants you to compute the \"beauty coefficient\" of this sequence.", "inputFormat": "The first line contains an integer $n$, the number of elements in the sequence.\nThe second line contains $n$ integers $a_1, a_2, \\dots, a_n$, describing the sequence.", "outputFormat": "Output a single integer, the \"beauty coefficient\" of the sequence.", "hint": "Sample Explanation:\nChoose the subarray $[2, 3]$ to obtain the maximum \"beauty coefficient\", which is $2 \\times 2 = 4$.\n\nConstraints:\n- For $20\\%$ of the testdata, $n \\le 2 \\times 10^3$.\n- For $60\\%$ of the testdata, $n \\le 2 \\times 10^5$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 2 \\times 10^6$, $0 \\le a_i \\le 2 \\times 10^6$.\n\nHint:\nYou may need fast I/O.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "美丽的序列", "background": "GD 是一个热衷于寻求美好事物的人。一天他拿到了一个美丽的序列。", "description": "为了研究这个序列的美丽程度，GD 定义了一个序列的“美丽度”和“美丽系数”：\n\n- 对于这个序列的任意一个区间 $[l,r]$，这个区间的“美丽度”就是这个区间的长度与这个区间的最小值的乘积。\n- 而整个序列的“美丽系数”就是它的所有区间的“美丽度”的最大值。\n\n现在 GD 想要你帮忙计算这个序列的“美丽系数”。", "inputFormat": "第一行一个整数 $n$，代表序列中的元素个数。\n\n第二行 $n$ 个整数 $a_i \\sim a_n$，描述这个序列。", "outputFormat": "一行一个整数，代表这个序列的“美丽系数”。", "hint": "### 样例解释\n\n选取区间 $[2,3]$，可以获得最大的“美丽系数”，为 $2 \\times 2=4$。\n\n### 数据范围\n\n- 对于 $20\\%$ 的数据，$n \\le 2 \\times 10^3$；\n- 对于 $60\\%$ 的数据，$n \\le 2 \\times 10^5$；\n- 对于 $100\\%$ 的数据，$1 \\le n \\le 2 \\times 10^6$，$0 \\le a_i \\le 2 \\times 10^6$。\n\n### 提示\n\n你可能需要一个读入优化。", "locale": "zh-CN"}}}
{"pid": "P2660", "type": "P", "difficulty": 2, "samples": [["1 10", "40"], ["2 2 ", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "贪心", "递归", "洛谷原创"], "title": "zzc 种田", "background": "可能以后 zzc 就去种田了。\n", "description": "田地是一个巨大的矩形，然而 zzc 每次只能种一个正方形,而每种一个正方形时 zzc 所花的体力值是正方形的周长，种过的田不可以再种，zzc 很懒还要节约体力去泡妹子，想花最少的体力值去种完这块田地，问最小体力值。", "inputFormat": "两个正整数 $x,y$，表示田地的长和宽。", "outputFormat": "输出最小体力值。", "hint": "$1\\le x,y\\le 10^{16}$。", "locale": "zh-CN", "translations": {"en": {"title": "zzc Farming", "background": "Maybe in the future zzc will go farming.", "description": "The field is a huge rectangle. However, zzc can plant only one square at a time, and the stamina cost for planting a square is the square’s perimeter. Areas that have already been planted cannot be planted again. zzc is lazy and wants to save stamina to hang out with girls, so he wants to finish planting the entire field with the least stamina. Find the minimum stamina cost.", "inputFormat": "Two positive integers $x, y$, representing the length and width of the field.", "outputFormat": "Output the minimum stamina cost.", "hint": "Constraints: $1 \\le x, y \\le 10^{16}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "zzc 种田", "background": "可能以后 zzc 就去种田了。\n", "description": "田地是一个巨大的矩形，然而 zzc 每次只能种一个正方形,而每种一个正方形时 zzc 所花的体力值是正方形的周长，种过的田不可以再种，zzc 很懒还要节约体力去泡妹子，想花最少的体力值去种完这块田地，问最小体力值。", "inputFormat": "两个正整数 $x,y$，表示田地的长和宽。", "outputFormat": "输出最小体力值。", "hint": "$1\\le x,y\\le 10^{16}$。", "locale": "zh-CN"}}}
{"pid": "P2661", "type": "P", "difficulty": 3, "samples": [["5\n2 4 2 3 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2015", "并查集", "NOIP 提高组", "强连通分量", "Tarjan"], "title": "[NOIP 2015 提高组] 信息传递", "background": "NOIP2015 Day1T2", "description": "有 $n$ 个同学（编号为 $1$ 到 $n$）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 $i$ 的同学的信息传递对象是编号为 $T_i$ 的同学。\n\n游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息，但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？", "inputFormat": "输入共 $2$ 行。\n\n第一行包含 $1$ 个正整数 $n$，表示 $n$ 个人。\n\n第二行包含 $n$ 个用空格隔开的正整数 $T_1,T_2,\\cdots,T_n$，其中第 $i$ 个整数 $T_i$ 表示编号为 $i$ 的同学的信息传递对象是编号为 $T_i$ 的同学，$T_i\\leq n$ 且 $T_i\\neq i$。", "outputFormat": "共一行一个整数，表示游戏一共可以进行多少轮。", "hint": "**样例 1 解释：**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ca5zl3c.png)\n\n游戏的流程如图所示。当进行完第 $3$ 轮游戏后，$4$ 号玩家会听到 $2$ 号玩家告诉他自己的生日，所以答案为 $3$。当然，第 $3$ 轮游戏后，$2$ 号玩家、 $3$ 号玩家都能从自己的消息来源得知自己的生日，同样符合游戏结束的条件。\n\n- 对于 $30\\%$ 的数据，$n\\le 200$；\n- 对于 $60\\%$ 的数据，$n\\le 2500$；\n- 对于 $100\\%$ 的数据，$n\\le 2\\times 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2015 Senior] Information Transfer", "background": "NOIP 2015 Day 1 T2.", "description": "There are $n$ players (numbered from $1$ to $n$) playing an information transfer game. In this game, each player has a fixed designated recipient. Specifically, the designated recipient of player $i$ is player $T_i$.\n\nAt the start of the game, each player knows only their own birthday. Then in each round, all players simultaneously tell all the birthday information they currently know to their designated recipient (note: someone may receive information from several people, but each person tells information to exactly one person, i.e., their designated recipient). The game ends when someone learns their own birthday from someone else. How many rounds can the game proceed in total?", "inputFormat": "The input consists of $2$ lines.\n\nThe first line contains $1$ positive integer $n$, representing the number of players.\n\nThe second line contains $n$ space-separated positive integers $T_1, T_2, \\cdots, T_n$. Here, the $i$-th integer $T_i$ means that the designated recipient of player $i$ is player $T_i$, with $T_i \\leq n$ and $T_i \\neq i$.", "outputFormat": "Output a single integer on one line, indicating how many rounds the game proceeds in total.", "hint": "Sample 1 explanation:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ca5zl3c.png)\n\nThe process of the game is shown in the figure. After the $3$rd round, player $4$ will hear player $2$ tell him his own birthday, so the answer is $3$. Of course, after the $3$rd round, player $2$ and player $3$ can also learn their own birthdays from their respective sources, which also satisfies the game’s end condition.\n\nConstraints:\n- For $30\\%$ of the testdata, $n \\le 200$.\n- For $60\\%$ of the testdata, $n \\le 2500$.\n- For $100\\%$ of the testdata, $n \\le 2 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2015 提高组] 信息传递", "background": "NOIP2015 Day1T2", "description": "有 $n$ 个同学（编号为 $1$ 到 $n$）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 $i$ 的同学的信息传递对象是编号为 $T_i$ 的同学。\n\n游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息，但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自己的生日时，游戏结束。请问该游戏一共可以进行几轮？", "inputFormat": "输入共 $2$ 行。\n\n第一行包含 $1$ 个正整数 $n$，表示 $n$ 个人。\n\n第二行包含 $n$ 个用空格隔开的正整数 $T_1,T_2,\\cdots,T_n$，其中第 $i$ 个整数 $T_i$ 表示编号为 $i$ 的同学的信息传递对象是编号为 $T_i$ 的同学，$T_i\\leq n$ 且 $T_i\\neq i$。", "outputFormat": "共一行一个整数，表示游戏一共可以进行多少轮。", "hint": "**样例 1 解释：**\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ca5zl3c.png)\n\n游戏的流程如图所示。当进行完第 $3$ 轮游戏后，$4$ 号玩家会听到 $2$ 号玩家告诉他自己的生日，所以答案为 $3$。当然，第 $3$ 轮游戏后，$2$ 号玩家、 $3$ 号玩家都能从自己的消息来源得知自己的生日，同样符合游戏结束的条件。\n\n- 对于 $30\\%$ 的数据，$n\\le 200$；\n- 对于 $60\\%$ 的数据，$n\\le 2500$；\n- 对于 $100\\%$ 的数据，$n\\le 2\\times 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P2662", "type": "P", "difficulty": 5, "samples": [["2 1\n7\n11", "15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2002", "最短路", "WC"], "title": "[WC2002] 牛场围栏", "background": "小 L 通过泥萌的帮助，成功解决了二叉树的修改问题，并因此写了一篇论文，成功保送了叉院（羡慕不？）\n\n勤奋又勤思的他在研究生时期成功转系，考入了北京大学光华管理学院！毕业后，凭着自己积累下的浓厚经济学与计算机学的基础，成功建设了一个现代化奶牛场！", "description": "奶牛们十分聪明，于是在牛场建围栏时打算和小 L 斗智斗勇！小 L 有 $N$ 种可以建造围栏的木料，长度分别是 $l_1,l_2,\\dots,l_N$，每种长度的木料无限。\n\n修建时，他将把所有选中的木料拼接在一起，因此围栏的长度就是他使用的木料长度之和。但是聪明的小 L 很快发现很多长度都是不能由这些木料长度相加得到的，于是决定在必要的时候把这些木料砍掉一部分以后再使用。\n\n不过由于小 L 比较节约，他给自己规定：任何一根木料最多只能削短 $M$ 米。当然，每根木料削去的木料长度不需要都一样。不过由于测量工具太原始，小 L 只能准确的削去整数米的木料，因此，如果他有两种长度分别是 $7$ 和 $11$ 的木料，每根最多只能砍掉 $1$ 米，那么实际上就有 $4$ 种可以使用的木料长度，分别是 $6,7,10,11$。        \n\n因为小 L 相信自己的奶牛举世无双，于是让他们自己设计围栏。奶牛们不愿意自己和同伴在游戏时受到围栏的限制，于是想刁难一下小 L，希望小 L 的木料无论经过怎样的加工，长度之和都不可能得到他们设计的围栏总长度。不过小 L 知道，如果围栏的长度太小，小 L 很快就能发现它是不能修建好的。因此他希望得到你的帮助，找出无法修建的最大围栏长度。\n\n这一定难不倒聪明的你吧！如果你能帮小 L 解决这个问题，也许他会把最后的资产分给你 $\\frac{1}{8}$ 哦！", "inputFormat": "输入的第一行包含两个整数 $N,M$，分别表示木料的种类和每根木料削去的最大值。\n\n以下各行每行一个整数 $l_i\\ (1<l_i<3000)$，表示第 $i$ 根木料的原始长度。", "outputFormat": "输出仅一行，包含一个整数，表示不能修建的最大围栏长度。如果任何长度的围栏都可以修建或者这个最大值不存在，输出 `-1`。", "hint": "对于 $40 \\%$ 的数据，$1<N<10$，$0\\le M<300$。\n\n对于 $100 \\%$ 的数据，$1<N<100$，$0\\le M<3000$。", "locale": "zh-CN", "translations": {"en": {"title": "[WC2002] Cattle Farm Fence", "background": "With the help of “nimeng” (泥萌), Xiao L successfully solved the problem of modifying binary trees. He then wrote a paper and was directly admitted to “Cha Yuan” (叉院). Envious?\n\nDiligent and thoughtful, he later switched fields in graduate school and entered the Guanghua School of Management at Peking University. After graduation, with his strong background in economics and computer science, he built a modern dairy farm.", "description": "The cows are very clever, so when building the fence they decided to compete with Xiao L in wits. Xiao L has $N$ types of lumber available for building fences, with lengths $l_1, l_2, \\dots, l_N$. Each type is available in unlimited quantity.\n\nDuring construction, he will join all selected pieces end to end, so the fence length equals the sum of the lengths of the pieces he uses. However, Xiao L soon realized that many target lengths cannot be obtained by summing these lumber lengths, so he decided that, when necessary, he would cut some lumber shorter before use.\n\nSince Xiao L is thrifty, he set a rule for himself: any single piece may be shortened by at most $M$ meters. The amount cut from each piece does not need to be the same. Due to primitive measuring tools, he can only cut an integer number of meters. Therefore, if he has two types of lumber with lengths $7$ and $11$, and each piece can be cut by at most $1$ meter, then in effect there are $4$ usable lengths: $6, 7, 10, 11$.\n\nBelieving his cows are unrivaled, he let them design the fence themselves. The cows want to avoid being constrained by the fence during play, so they try to make things difficult for Xiao L by choosing a fence length such that, no matter how he processes the lumber, the sum of lengths can never equal their designed total. But Xiao L knows that if the fence length is too small, he can quickly determine it is impossible to build. Thus, he wants your help to find the maximum fence length that cannot be constructed.\n\nSurely this won’t stump you. If you can help Xiao L solve this problem, he might even give you $\\frac{1}{8}$ of his final assets!", "inputFormat": "The first line contains two integers $N, M$, the number of lumber types and the maximum amount each piece can be shortened.\n\nThe next $N$ lines each contain an integer $l_i$ ($1 < l_i < 3000$), the original length of the $i$-th type of lumber.", "outputFormat": "Output a single integer: the maximum fence length that cannot be constructed. If every fence length can be constructed or this maximum does not exist, output `-1`.", "hint": "- For $40\\%$ of the testdata, $1 < N < 10$, $0 \\le M < 300$.\n- For $100\\%$ of the testdata, $1 < N < 100$, $0 \\le M < 3000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2002] 牛场围栏", "background": "小 L 通过泥萌的帮助，成功解决了二叉树的修改问题，并因此写了一篇论文，成功保送了叉院（羡慕不？）\n\n勤奋又勤思的他在研究生时期成功转系，考入了北京大学光华管理学院！毕业后，凭着自己积累下的浓厚经济学与计算机学的基础，成功建设了一个现代化奶牛场！", "description": "奶牛们十分聪明，于是在牛场建围栏时打算和小 L 斗智斗勇！小 L 有 $N$ 种可以建造围栏的木料，长度分别是 $l_1,l_2,\\dots,l_N$，每种长度的木料无限。\n\n修建时，他将把所有选中的木料拼接在一起，因此围栏的长度就是他使用的木料长度之和。但是聪明的小 L 很快发现很多长度都是不能由这些木料长度相加得到的，于是决定在必要的时候把这些木料砍掉一部分以后再使用。\n\n不过由于小 L 比较节约，他给自己规定：任何一根木料最多只能削短 $M$ 米。当然，每根木料削去的木料长度不需要都一样。不过由于测量工具太原始，小 L 只能准确的削去整数米的木料，因此，如果他有两种长度分别是 $7$ 和 $11$ 的木料，每根最多只能砍掉 $1$ 米，那么实际上就有 $4$ 种可以使用的木料长度，分别是 $6,7,10,11$。        \n\n因为小 L 相信自己的奶牛举世无双，于是让他们自己设计围栏。奶牛们不愿意自己和同伴在游戏时受到围栏的限制，于是想刁难一下小 L，希望小 L 的木料无论经过怎样的加工，长度之和都不可能得到他们设计的围栏总长度。不过小 L 知道，如果围栏的长度太小，小 L 很快就能发现它是不能修建好的。因此他希望得到你的帮助，找出无法修建的最大围栏长度。\n\n这一定难不倒聪明的你吧！如果你能帮小 L 解决这个问题，也许他会把最后的资产分给你 $\\frac{1}{8}$ 哦！", "inputFormat": "输入的第一行包含两个整数 $N,M$，分别表示木料的种类和每根木料削去的最大值。\n\n以下各行每行一个整数 $l_i\\ (1<l_i<3000)$，表示第 $i$ 根木料的原始长度。", "outputFormat": "输出仅一行，包含一个整数，表示不能修建的最大围栏长度。如果任何长度的围栏都可以修建或者这个最大值不存在，输出 `-1`。", "hint": "对于 $40 \\%$ 的数据，$1<N<10$，$0\\le M<300$。\n\n对于 $100 \\%$ 的数据，$1<N<100$，$0\\le M<3000$。", "locale": "zh-CN"}}}
{"pid": "P2663", "type": "P", "difficulty": 2, "samples": [["8\n77\n77\n56\n77\n84\n77\n56\n46", "273"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "O2优化"], "title": "越越的组队", "background": null, "description": "班级要组织一场综合能力竞赛，班里共有 $n$ 位学生，将分成两队互相竞争。\n\n老师找到了越越并给了越越一张全班同学综合能力测试的成绩，要求他从全班同学中选出**一半**，并要求这些同学综合能力测试的成绩之和在**不超过班级总分一半**的前提下尽量达到最高。这样分成的两队实力是最平均的。越越堆着满脸的笑容找到了你，你就帮他写一个程序吧。", "inputFormat": "第一行有一个整数，表示班级的学生人数 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i + 1)$ 行的整数 $a_i$ 表示第 $i$ 位同学的成绩。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 样例 1 解释\n\n班级总分为 $550$，总分的一半是 $275$，选择成绩分别为 $56,77,84,56$ 的同学可以达到总分 $273$，是不超过 $275$ 的最大值。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 100$，$0 \\leq a_i \\leq 100$，数据保证 $n$ 均为偶数。", "locale": "zh-CN", "translations": {"en": {"title": "Yueyue's Team Formation", "background": "", "description": "The class is organizing a comprehensive ability competition. There are $n$ students in the class, and they will be divided into two teams to compete against each other.\n\nThe teacher gave Yueyue (pinyin) a list of the comprehensive ability test scores for the whole class and asked him to select exactly half of the students, such that the sum of their test scores is as large as possible without exceeding half of the class's total score. This makes the two teams as balanced as possible. Yueyue, smiling, came to you; please help him write a program.", "inputFormat": "The first line contains an integer representing the number of students $n$.\n\nFrom line $2$ to line $(n + 1)$, each line contains one integer. The integer on line $(i + 1)$, $a_i$, represents the score of the $i$-th student.", "outputFormat": "Output one integer on a single line representing the answer.", "hint": "#### Explanation for Sample 1\n\nThe class total score is $550$, and half of the total is $275$. Choosing students with scores $56,77,84,56$ gives a sum of $273$, which is the maximum that does not exceed $275$.\n\n#### Constraints\n\nFor all test points, it is guaranteed that $1 \\leq n \\leq 100$, $0 \\leq a_i \\leq 100$, and $n$ is even.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "越越的组队", "background": null, "description": "班级要组织一场综合能力竞赛，班里共有 $n$ 位学生，将分成两队互相竞争。\n\n老师找到了越越并给了越越一张全班同学综合能力测试的成绩，要求他从全班同学中选出**一半**，并要求这些同学综合能力测试的成绩之和在**不超过班级总分一半**的前提下尽量达到最高。这样分成的两队实力是最平均的。越越堆着满脸的笑容找到了你，你就帮他写一个程序吧。", "inputFormat": "第一行有一个整数，表示班级的学生人数 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i + 1)$ 行的整数 $a_i$ 表示第 $i$ 位同学的成绩。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 样例 1 解释\n\n班级总分为 $550$，总分的一半是 $275$，选择成绩分别为 $56,77,84,56$ 的同学可以达到总分 $273$，是不超过 $275$ 的最大值。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 100$，$0 \\leq a_i \\leq 100$，数据保证 $n$ 均为偶数。", "locale": "zh-CN"}}}
{"pid": "P2664", "type": "P", "difficulty": 6, "samples": [["5\n1 2 3 2 3\n1 2\n2 3\n2 4\n1 5", "10\n9\n11\n9\n12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["点分治", "洛谷原创", "洛谷比赛"], "title": "树上游戏", "background": "", "description": "lrb 有一棵树，树的每个节点有个颜色。给一个长度为 $n$ 的颜色序列，定义 $s(i,j)$ 为 $i$ 到 $j$ 的颜色数量。以及\n\n$$sum_i=\\sum_{j=1}^n s(i, j)$$\n\n现在他想让你求出所有的 $sum_i$。\n", "inputFormat": "第一行为一个整数 $n$，表示树节点的数量。\n\n\n第二行为 $n$ 个整数，分别表示 $n$ 个节点的颜色 $c_1,c_2\\ldots c_n$。\n\n\n接下来 $n-1$ 行，每行为两个整数 $x,y$，表示 $x$ 和 $y$ 之间有一条边。", "outputFormat": "输出 $n$ 行，第 $i$ 行为 $sum_i$。\n", "hint": "$$sum_1=s(1,1)+s(1,2)+s(1,3)+s(1,4)+s(1,5)=1+2+3+2+2=10$$\n$$sum_2=s(2,1)+s(2,2)+s(2,3)+s(2,4)+s(2,5)=2+1+2+1+3=9$$\n$$sum_3=s(3,1)+s(3,2)+s(3,3)+s(3,4)+s(3,5)=3+2+1+2+3=11$$\n$$sum_4=s(4,1)+s(4,2)+s(4,3)+s(4,4)+s(4,5)=2+1+2+1+3=9$$\n$$sum_5=s(5,1)+s(5,2)+s(5,3)+s(5,4)+s(5,5)=2+3+3+3+1=12$$\n\n\n对于 $40\\%$ 的数据，$n\\leq 2000$。\n\n对于 $100\\%$ 的数据，$1\\leq n,c_i\\leq 10^5$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Game on a Tree", "background": "", "description": "lrb has a tree, and each node has a color. Given a color sequence of length $n$, define $s(i, j)$ as the number of distinct colors on the simple path from node $i$ to node $j$.\n\n$$sum_i=\\sum_{j=1}^n s(i, j)$$\n\nNow he wants you to compute all $sum_i$.\n\nFor $40\\%$ of the testdata, $n \\leq 2000$.\nFor $100\\%$ of the testdata, $1 \\leq n, c_i \\leq 10^5$.", "inputFormat": "The first line contains an integer $n$, the number of nodes in the tree.\n\nThe second line contains $n$ integers, the colors of the $n$ nodes: $c_1, c_2, \\ldots, c_n$.\n\nEach of the next $n-1$ lines contains two integers $x, y$, meaning there is an edge between $x$ and $y$.", "outputFormat": "Output $n$ lines. The $i$-th line should be $sum_i$.", "hint": "$$sum_1=s(1,1)+s(1,2)+s(1,3)+s(1,4)+s(1,5)=1+2+3+2+2=10$$\n$$sum_2=s(2,1)+s(2,2)+s(2,3)+s(2,4)+s(2,5)=2+1+2+1+3=9$$\n$$sum_3=s(3,1)+s(3,2)+s(3,3)+s(3,4)+s(3,5)=3+2+1+2+3=11$$\n$$sum_4=s(4,1)+s(4,2)+s(4,3)+s(4,4)+s(4,5)=2+1+2+1+3=9$$\n$$sum_5=s(5,1)+s(5,2)+s(5,3)+s(5,4)+s(5,5)=2+3+3+3+1=12$$\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "树上游戏", "background": "", "description": "lrb 有一棵树，树的每个节点有个颜色。给一个长度为 $n$ 的颜色序列，定义 $s(i,j)$ 为 $i$ 到 $j$ 的颜色数量。以及\n\n$$sum_i=\\sum_{j=1}^n s(i, j)$$\n\n现在他想让你求出所有的 $sum_i$。\n", "inputFormat": "第一行为一个整数 $n$，表示树节点的数量。\n\n\n第二行为 $n$ 个整数，分别表示 $n$ 个节点的颜色 $c_1,c_2\\ldots c_n$。\n\n\n接下来 $n-1$ 行，每行为两个整数 $x,y$，表示 $x$ 和 $y$ 之间有一条边。", "outputFormat": "输出 $n$ 行，第 $i$ 行为 $sum_i$。\n", "hint": "$$sum_1=s(1,1)+s(1,2)+s(1,3)+s(1,4)+s(1,5)=1+2+3+2+2=10$$\n$$sum_2=s(2,1)+s(2,2)+s(2,3)+s(2,4)+s(2,5)=2+1+2+1+3=9$$\n$$sum_3=s(3,1)+s(3,2)+s(3,3)+s(3,4)+s(3,5)=3+2+1+2+3=11$$\n$$sum_4=s(4,1)+s(4,2)+s(4,3)+s(4,4)+s(4,5)=2+1+2+1+3=9$$\n$$sum_5=s(5,1)+s(5,2)+s(5,3)+s(5,4)+s(5,5)=2+3+3+3+1=12$$\n\n\n对于 $40\\%$ 的数据，$n\\leq 2000$。\n\n对于 $100\\%$ 的数据，$1\\leq n,c_i\\leq 10^5$。\n", "locale": "zh-CN"}}}
{"pid": "P2665", "type": "P", "difficulty": 3, "samples": [["4 \n-1 1 \n-2 0 \n0 0 \n1 1", "4 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2008", "USACO", "枚举"], "title": "[USACO08FEB] Game of Lines S", "background": null, "description": "FJ 最近发明了一个游戏，来考验自命不凡的贝茜。\n\n游戏开始的时候，FJ 会给贝茜一块画着 $N (2 \\le N \\le 200)$ 个不重合的点的木板，其中第 $i$ 个点的横、纵坐标分别为 $X_i$ 和 $Y_i (-1000 \\le X_i \\le 1000, -1000 \\le Y_i \\le 1000)$。\n\n贝茜可以选两个点画一条过它们的直线，当且仅当平面上不存在与画出直线平行的直线。游戏结束时贝茜的得分，就是她画出的直线的总条数。为了在游戏中胜出，贝茜找到了你，希望你帮她计算一下最大可能得分。", "inputFormat": "第 $1$ 行：输入一个正整数：$N$。\n\n第 $2 \\sim N+1$ 行：第 $i+1$ 行用 $2$ 个用空格隔开的整数 $X_i,Y_i$，描述了点 $i$ 的坐标。", "outputFormat": "第 $1$ 行：输出一个整数，表示贝茜的最大得分，即她能画出的互不平行的线段数。", "hint": "样例解释：\n\n贝茜能画出以下 $4$ 种斜率的直线：$-1$，$0$，$\\dfrac{1}{3}$ 以及 $1$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO08FEB] Game of Lines S", "background": null, "description": "Farmer John has challenged Bessie to the following game: FJ has a board with dots marked at N (2 ≤ N ≤ 200) distinct lattice points. Dot i has the integer coordinates Xi and Yi (-1,000 ≤ Xi ≤ 1,000; -1,000 ≤ Yi ≤ 1,000).\n\nBessie can score a point in the game by picking two of the dots and drawing a straight line between them; however, she is not allowed to draw a line if she has already drawn another line that is parallel to that line. Bessie would like to know her chances of winning, so she has asked you to help find the maximum score she can obtain.", "inputFormat": null, "outputFormat": null, "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO08FEB] Game of Lines S", "background": null, "description": "FJ 最近发明了一个游戏，来考验自命不凡的贝茜。\n\n游戏开始的时候，FJ 会给贝茜一块画着 $N (2 \\le N \\le 200)$ 个不重合的点的木板，其中第 $i$ 个点的横、纵坐标分别为 $X_i$ 和 $Y_i (-1000 \\le X_i \\le 1000, -1000 \\le Y_i \\le 1000)$。\n\n贝茜可以选两个点画一条过它们的直线，当且仅当平面上不存在与画出直线平行的直线。游戏结束时贝茜的得分，就是她画出的直线的总条数。为了在游戏中胜出，贝茜找到了你，希望你帮她计算一下最大可能得分。", "inputFormat": "第 $1$ 行：输入一个正整数：$N$。\n\n第 $2 \\sim N+1$ 行：第 $i+1$ 行用 $2$ 个用空格隔开的整数 $X_i,Y_i$，描述了点 $i$ 的坐标。", "outputFormat": "第 $1$ 行：输出一个整数，表示贝茜的最大得分，即她能画出的互不平行的线段数。", "hint": "样例解释：\n\n贝茜能画出以下 $4$ 种斜率的直线：$-1$，$0$，$\\dfrac{1}{3}$ 以及 $1$。", "locale": "zh-CN"}}}
{"pid": "P2666", "type": "P", "difficulty": 2, "samples": [["4", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2007", "USACO", "枚举"], "title": "[USACO07OCT] Bessie's Secret Pasture S", "background": "", "description": "Farmmer John 最近收割了几乎无限多块牧草，将它们堆放在空地上。这些牧草都是正方形的，而且都有非负整数长度的边长（当然有 $0$）。一天它的奶牛 Bessie 发现了这些美味的牧草，于是希望把它们种在自己的秘密牧场上。他总将草皮分割成 $1\\times1$ 的小块，以放入他牧场上的 $N$ 个格子中。\n\nBessie 感兴趣的是，她若选取四块会有多少种不同方法。如果 $N=4$，那么她就有 $5$ 种不同分法：$(1,1,1,1), (2,0,0,0), (0,2,0,0),(0,0,2,0),(0,0,0,2)$，括号内数表示边长。注意这里不讲究顺序，如 $(1,2,3,4)$ 与 $(4,3,2,1)$ 是两种不同方法。\n", "inputFormat": "仅一行，一个整数 $N$ 。\n", "outputFormat": "同样为一行，包含一个整数，为方案总数。\n", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le10000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO07OCT] Bessie's Secret Pasture S", "background": "", "description": "Farmer John recently harvested an almost infinite number of sod patches and stacked them in an open area. These patches are all squares with nonnegative integer side lengths (including $0$). One day his cow Bessie discovered these delicious sod patches and wants to plant them in her secret pasture. She divides the sod into $1\\times1$ unit pieces to place them into the $N$ cells of her pasture.\n\nBessie is interested in how many different ways there are if she chooses four patches. If $N=4$, then she has $5$ different ways: (1,1,1,1), (2,0,0,0), (0,2,0,0), (0,0,2,0), (0,0,0,2); the numbers in parentheses denote side lengths. Note that order matters; for example, (1,2,3,4) and (4,3,2,1) are two different ways.", "inputFormat": "A single line with one integer $N$.", "outputFormat": "A single line containing one integer: the total number of ways.", "hint": "Constraints: For 100% of the testdata, $1\\le N\\le10000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO07OCT] Bessie's Secret Pasture S", "background": "", "description": "Farmmer John 最近收割了几乎无限多块牧草，将它们堆放在空地上。这些牧草都是正方形的，而且都有非负整数长度的边长（当然有 $0$）。一天它的奶牛 Bessie 发现了这些美味的牧草，于是希望把它们种在自己的秘密牧场上。他总将草皮分割成 $1\\times1$ 的小块，以放入他牧场上的 $N$ 个格子中。\n\nBessie 感兴趣的是，她若选取四块会有多少种不同方法。如果 $N=4$，那么她就有 $5$ 种不同分法：$(1,1,1,1), (2,0,0,0), (0,2,0,0),(0,0,2,0),(0,0,0,2)$，括号内数表示边长。注意这里不讲究顺序，如 $(1,2,3,4)$ 与 $(4,3,2,1)$ 是两种不同方法。\n", "inputFormat": "仅一行，一个整数 $N$ 。\n", "outputFormat": "同样为一行，包含一个整数，为方案总数。\n", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le10000$。\n", "locale": "zh-CN"}}}
{"pid": "P2667", "type": "P", "difficulty": 5, "samples": [["5 7\n3 1 4 1 2\nA 1 3 2\nQ 2\nA 1 4 1\nQ 1\nA 1 4 1\nQ 2\nQ 1", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "各省省选", "天津"], "title": "[TJOI2012] 防御", "background": "", "description": "在一个塔防小游戏中，有很多防线。每条防线由一排 $n$ 个独立的防御体 $[1 : n]$ 进行防御。\n\n游戏过程中，会不断有敌人对防线进行攻击，每次攻击会指定防御体 $[l : r]$ 进行攻击力为 $a$ 的攻击。第一防线具有护甲，护甲承受攻击后，对应的防御体所受到的伤害为攻击力，但护甲承受的伤害总量到达一定程度后就会破碎，此时防御体所受的伤害加倍。目前第一防线的力量充足，玩家致力于对后面的防线的建设，不过为确认游戏进度和第一防线的情况，玩家会不时地将鼠标移动到第一防线的某个防御体上，以查看其所受到的伤害。\n", "inputFormat": "第一行，两个整数 $n$ 和 $q$，分别表示防御体个数以及攻击和查询的总数。\n\n第二行，$n$ 个数，表示每个防御体护甲的承受能力 $p_i$ 。\n\n接下来 $q$ 行，每行可能具有如下形式：\n\n`A l r a` 表示对防御体 $l,l+1,\\cdots,r$ 进行攻击力为 $a$ 的攻击；\n\n`Q x` 表示查询防御体 $x$ 目前所受到的伤害，初始时伤害为 $0$ 。\n", "outputFormat": "一行，一个整数，表示所有查询结果之和对 ${10}^9+9$ 取模的余数。\n", "hint": "**【样例解释】**\n\n3/0 1/0 4/0 1/0 2/0\n\n[A 1 3 2]\n\n1/2 2 2/2 1/0 2/0\n\n[Q 2] ! 2\n\n[A 1 4 1]\n\n3 4 1/3 1 2/0\n\n[Q 1] -> 3\n\n[A 1 4 1]\n\n5 6 4 3 2/0\n\n[Q 2] -> 6\n\n[Q 1] -> 5\n\n**【数据范围】**\n\n$30 \\%$ 的数据， $q \\le 10^3$。\n\n$100 \\%$ 的数据，$1 \\le n \\le 10^5$，$1 \\le q \\le 10^5$，$0 \\le p_i \\le 10^6$，$0 \\le a \\le 10^4$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2012] Defense", "background": "", "description": "In a tower defense mini-game, there are many defense lines. Each defense line is defended by a row of $n$ independent defense units $[1 : n]$.\n\nDuring the game, enemies keep attacking the defense line. Each attack specifies defense units $[l : r]$ and applies an attack with attack power $a$. The first defense line has armor. After the armor takes an attack, the corresponding defense unit suffers damage equal to the attack power. However, once the total damage absorbed by the armor reaches a certain limit, it breaks, and from then on the damage the defense unit takes is doubled. The first defense line is currently strong, and the player is focusing on building the later lines. To monitor the game progress and the status of the first defense line, the player occasionally moves the mouse over a defense unit in the first defense line to view the damage it has taken.", "inputFormat": "The first line contains two integers $n$ and $q$, denoting the number of defense units and the total number of attacks and queries.\n\nThe second line contains $n$ numbers, denoting the armor capacity $p_i$ of each defense unit.\n\nThen follow $q$ lines, each in one of the following forms:\n\n`A l r a` means applying an attack with attack power $a$ to defense units $l, l+1, \\cdots, r$;\n\n`Q x` means querying the current damage taken by defense unit $x$, with initial damage being $0$.", "outputFormat": "One line containing one integer: the sum of all query results modulo ${10}^9+9$.", "hint": "【Sample Explanation】\n\n3/0 1/0 4/0 1/0 2/0\n\n[A 1 3 2]\n\n1/2 2 2/2 1/0 2/0\n\n[Q 2] ! 2\n\n[A 1 4 1]\n\n3 4 1/3 1 2/0\n\n[Q 1] -> 3\n\n[A 1 4 1]\n\n5 6 4 3 2/0\n\n[Q 2] -> 6\n\n[Q 1] -> 5\n\n【Constraints】\n\nFor 30% of the testdata, $q \\le 10^3$.\n\nFor 100% of the testdata, $1 \\le n \\le 10^5$, $1 \\le q \\le 10^5$, $0 \\le p_i \\le 10^6$, $0 \\le a \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2012] 防御", "background": "", "description": "在一个塔防小游戏中，有很多防线。每条防线由一排 $n$ 个独立的防御体 $[1 : n]$ 进行防御。\n\n游戏过程中，会不断有敌人对防线进行攻击，每次攻击会指定防御体 $[l : r]$ 进行攻击力为 $a$ 的攻击。第一防线具有护甲，护甲承受攻击后，对应的防御体所受到的伤害为攻击力，但护甲承受的伤害总量到达一定程度后就会破碎，此时防御体所受的伤害加倍。目前第一防线的力量充足，玩家致力于对后面的防线的建设，不过为确认游戏进度和第一防线的情况，玩家会不时地将鼠标移动到第一防线的某个防御体上，以查看其所受到的伤害。\n", "inputFormat": "第一行，两个整数 $n$ 和 $q$，分别表示防御体个数以及攻击和查询的总数。\n\n第二行，$n$ 个数，表示每个防御体护甲的承受能力 $p_i$ 。\n\n接下来 $q$ 行，每行可能具有如下形式：\n\n`A l r a` 表示对防御体 $l,l+1,\\cdots,r$ 进行攻击力为 $a$ 的攻击；\n\n`Q x` 表示查询防御体 $x$ 目前所受到的伤害，初始时伤害为 $0$ 。\n", "outputFormat": "一行，一个整数，表示所有查询结果之和对 ${10}^9+9$ 取模的余数。\n", "hint": "**【样例解释】**\n\n3/0 1/0 4/0 1/0 2/0\n\n[A 1 3 2]\n\n1/2 2 2/2 1/0 2/0\n\n[Q 2] ! 2\n\n[A 1 4 1]\n\n3 4 1/3 1 2/0\n\n[Q 1] -> 3\n\n[A 1 4 1]\n\n5 6 4 3 2/0\n\n[Q 2] -> 6\n\n[Q 1] -> 5\n\n**【数据范围】**\n\n$30 \\%$ 的数据， $q \\le 10^3$。\n\n$100 \\%$ 的数据，$1 \\le n \\le 10^5$，$1 \\le q \\le 10^5$，$0 \\le p_i \\le 10^6$，$0 \\le a \\le 10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P2668", "type": "P", "difficulty": 5, "samples": [["1 8\n7 4\n8 4\n9 1\n10 4\n11 1\n5 1\n1 4\n1 1", "3\n"], ["1 17\n12 3\n4 3\n2 3\n5 4\n10 2\n3 3\n12 2\n0 1\n1 3\n10 1\n6 2\n12 1\n11 3\n5 2\n12 4\n2 2\n7 2\n", "6\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000, 1024000]}, "tags": ["模拟", "搜索", "贪心", "2015", "NOIP 提高组", "深度优先搜索 DFS"], "title": "[NOIP 2015 提高组] 斗地主", "background": "NOIP2015 Day1T3", "description": "牛牛最近迷上了一种叫斗地主的扑克游戏。斗地主是一种使用黑桃、红心、梅花、方片的 $A$ 到 $K$ 加上大小王的共 $54$ 张牌来进行的扑克牌游戏。在斗地主中，牌的大小关系根据牌的数码表示如下：$3<4<5<6<7<8<9<10<J<Q<K<A<2<\\text{小王}<\\text{大王}$，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由 $n$ 张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。\n\n现在，牛牛只想知道，对于自己的若干组手牌，分别最少需要多少次出牌可以将它们打光。请你帮他解决这个问题。\n\n需要注意的是，本题中游戏者每次可以出手的牌型与一般的斗地主相似而略有不同。具体规则如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1827.png) \n\n**本题数据随机，不支持hack，要hack或强力数据请点击[这里](https://www.luogu.org/problem/P2540)**。\n", "inputFormat": "第一行包含用空格隔开的 $2$ 个正整数 $T,n$，表示手牌的组数以及每组手牌的张数。\n\n接下来 $T$ 组数据，每组数据 $n$ 行，每行一个非负整数对 $a_i,b_i$，表示一张牌，其中 $a_i$ 表示牌的数码，$b_i$ 表示牌的花色，中间用空格隔开。特别的，我们用 $1$ 来表示数码 $A$，$11$ 表示数码 $J$，$12$ 表示数码 $Q$，$13$ 表示数码 $K$；黑桃、红心、梅花、方片分别用 $1-4$ 来表示；小王的表示方法为 `0 1`，大王的表示方法为 `0 2`。", "outputFormat": "共 $T$ 行，每行一个整数，表示打光第 $i$ 组手牌的最少次数。", "hint": "**样例 1 说明**\n\n共有 $1$ 组手牌，包含 $8$ 张牌：方片 $7$，方片 $8$，黑桃 $9$，方片 $10$，黑桃 $J$，黑桃 $5$，方片 $A$ 以及黑桃 $A$。可以通过打单顺子（方片 $7$，方片 $8$，黑桃 $9$，方片 $10$，黑桃 $J$），单张牌（黑桃 $5$）以及对子牌（黑桃 $A$以及方片 $A$）在 $3$ 次内打光。\n\n对于不同的测试点， 我们约定手牌组数 $T$ 与张数 $n$ 的规模如下：\n\n| 测试点编号 | $T=$ | $n=$ |\n| :------: | :----: | :----: |\n|  1       |  $100$   |  $2$  |\n|  2       |  $100$   |  $2$  |\n|  3       |  $100$   |  $3$  |\n|  4       |  $100$   |  $3$  |\n|  5       |  $100$   |  $4$  |\n|  6       |  $100$   |  $4$  |\n|  7       |  $100$   |  $10$  |\n|  8       |  $100$   |  $11$  |\n|  9       |  $100$   |  $12$  |\n|  10       |  $100$   |  $13$  |\n|  11       |  $100$   |  $14$  |\n|  12       |  $100$   |  $15$  |\n|  13       |  $10$   |  $16$  |\n|  14       |  $10$   |  $17$  |\n|  15       |  $10$   |  $18$  |\n|  16       |  $10$   |  $19$  |\n|  17       |  $10$   |  $20$  |\n|  18       |  $10$   |  $21$  |\n|  19       |  $10$   |  $22$  |\n|  20       |  $10$   |  $23$  |\n\n数据保证：所有的手牌都是随机生成的。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2015 Senior] Dou Dizhu", "background": "NOIP 2015 Day 1 T3.", "description": "Niuniu has recently become obsessed with a card game called Dou Dizhu. Dou Dizhu is a card game played with a standard deck consisting of spades, hearts, clubs, and diamonds from $A$ to $K$, plus the two jokers, for a total of $54$ cards. In Dou Dizhu, the rank order of the cards is represented by their face values as follows: $3<4<5<6<7<8<9<10<J<Q<K<A<2<\\text{small Joker}<\\text{big Joker}$, and suits do not affect the rank. In each round, a hand consists of $n$ cards. Each turn, a player may play according to the allowed patterns. The first player to play all of their cards wins the game.\n\nNow, Niuniu only wants to know, for several sets of hands, the minimum number of plays required to play out each of them. Please help him solve this problem.\n\nNote that in this problem, the playable patterns per turn are similar to those in standard Dou Dizhu but slightly different. The specific rules are as follows:\n\n ![](https://cdn.luogu.com.cn/upload/pic/1827.png) \n\nThe testdata for this problem is random and hacks are not supported. To hack or use stronger testdata please click [here](https://www.luogu.org/problem/P2540).", "inputFormat": "The first line contains two positive integers $T, n$ separated by a space, representing the number of hand sets and the number of cards in each hand.\n\nThen follow $T$ groups of data. Each group contains $n$ lines, each line containing a pair of nonnegative integers $a_i, b_i$ representing a card, where $a_i$ is the rank and $b_i$ is the suit, separated by a space. Specifically, we use $1$ to represent rank $A$, $11$ to represent rank $J$, $12$ to represent rank $Q$, and $13$ to represent rank $K$; spades, hearts, clubs, and diamonds are represented by $1$–$4$, respectively; the small joker is represented by `0 1`, and the big joker is represented by `0 2`.", "outputFormat": "Output $T$ lines. Each line contains an integer representing the minimum number of plays needed to play out the $i$-th hand set.", "hint": "Sample 1 explanation:\n\nThere is $1$ hand set with $8$ cards: diamond $7$, diamond $8$, spade $9$, diamond $10$, spade $J$, spade $5$, diamond $A$, and spade $A$. You can finish in $3$ plays by playing a straight of singles (diamond $7$, diamond $8$, spade $9$, diamond $10$, spade $J$), a single (spade $5$), and a pair (spade $A$ and diamond $A$).\n\nFor different test points, we define the scales of the number of hand sets $T$ and the number of cards $n$ as follows:\n\n| Test point ID | $T=$ | $n=$ |\n| :------: | :----: | :----: |\n|  1       |  $100$   |  $2$  |\n|  2       |  $100$   |  $2$  |\n|  3       |  $100$   |  $3$  |\n|  4       |  $100$   |  $3$  |\n|  5       |  $100$   |  $4$  |\n|  6       |  $100$   |  $4$  |\n|  7       |  $100$   |  $10$  |\n|  8       |  $100$   |  $11$  |\n|  9       |  $100$   |  $12$  |\n|  10       |  $100$   |  $13$  |\n|  11       |  $100$   |  $14$  |\n|  12       |  $100$   |  $15$  |\n|  13       |  $10$   |  $16$  |\n|  14       |  $10$   |  $17$  |\n|  15       |  $10$   |  $18$  |\n|  16       |  $10$   |  $19$  |\n|  17       |  $10$   |  $20$  |\n|  18       |  $10$   |  $21$  |\n|  19       |  $10$   |  $22$  |\n|  20       |  $10$   |  $23$  |\n\nIt is guaranteed that all hands are randomly generated.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2015 提高组] 斗地主", "background": "NOIP2015 Day1T3", "description": "牛牛最近迷上了一种叫斗地主的扑克游戏。斗地主是一种使用黑桃、红心、梅花、方片的 $A$ 到 $K$ 加上大小王的共 $54$ 张牌来进行的扑克牌游戏。在斗地主中，牌的大小关系根据牌的数码表示如下：$3<4<5<6<7<8<9<10<J<Q<K<A<2<\\text{小王}<\\text{大王}$，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由 $n$ 张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。\n\n现在，牛牛只想知道，对于自己的若干组手牌，分别最少需要多少次出牌可以将它们打光。请你帮他解决这个问题。\n\n需要注意的是，本题中游戏者每次可以出手的牌型与一般的斗地主相似而略有不同。具体规则如下：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1827.png) \n\n**本题数据随机，不支持hack，要hack或强力数据请点击[这里](https://www.luogu.org/problem/P2540)**。\n", "inputFormat": "第一行包含用空格隔开的 $2$ 个正整数 $T,n$，表示手牌的组数以及每组手牌的张数。\n\n接下来 $T$ 组数据，每组数据 $n$ 行，每行一个非负整数对 $a_i,b_i$，表示一张牌，其中 $a_i$ 表示牌的数码，$b_i$ 表示牌的花色，中间用空格隔开。特别的，我们用 $1$ 来表示数码 $A$，$11$ 表示数码 $J$，$12$ 表示数码 $Q$，$13$ 表示数码 $K$；黑桃、红心、梅花、方片分别用 $1-4$ 来表示；小王的表示方法为 `0 1`，大王的表示方法为 `0 2`。", "outputFormat": "共 $T$ 行，每行一个整数，表示打光第 $i$ 组手牌的最少次数。", "hint": "**样例 1 说明**\n\n共有 $1$ 组手牌，包含 $8$ 张牌：方片 $7$，方片 $8$，黑桃 $9$，方片 $10$，黑桃 $J$，黑桃 $5$，方片 $A$ 以及黑桃 $A$。可以通过打单顺子（方片 $7$，方片 $8$，黑桃 $9$，方片 $10$，黑桃 $J$），单张牌（黑桃 $5$）以及对子牌（黑桃 $A$以及方片 $A$）在 $3$ 次内打光。\n\n对于不同的测试点， 我们约定手牌组数 $T$ 与张数 $n$ 的规模如下：\n\n| 测试点编号 | $T=$ | $n=$ |\n| :------: | :----: | :----: |\n|  1       |  $100$   |  $2$  |\n|  2       |  $100$   |  $2$  |\n|  3       |  $100$   |  $3$  |\n|  4       |  $100$   |  $3$  |\n|  5       |  $100$   |  $4$  |\n|  6       |  $100$   |  $4$  |\n|  7       |  $100$   |  $10$  |\n|  8       |  $100$   |  $11$  |\n|  9       |  $100$   |  $12$  |\n|  10       |  $100$   |  $13$  |\n|  11       |  $100$   |  $14$  |\n|  12       |  $100$   |  $15$  |\n|  13       |  $10$   |  $16$  |\n|  14       |  $10$   |  $17$  |\n|  15       |  $10$   |  $18$  |\n|  16       |  $10$   |  $19$  |\n|  17       |  $10$   |  $20$  |\n|  18       |  $10$   |  $21$  |\n|  19       |  $10$   |  $22$  |\n|  20       |  $10$   |  $23$  |\n\n数据保证：所有的手牌都是随机生成的。\n", "locale": "zh-CN"}}}
{"pid": "P2669", "type": "P", "difficulty": 1, "samples": [["6", "14"], ["1000\n", "29820\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "2015", "NOIP 普及组"], "title": "[NOIP 2015 普及组] 金币", "background": "NOIP2015 普及组 T1", "description": "国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天），每天收到两枚金币；之后三天（第四、五、六天），每天收到三枚金币；之后四天（第七、八、九、十天），每天收到四枚金币……；这种工资发放模式会一直这样延续下去：当连续 $n$ 天每天收到 $n$ 枚金币后，骑士会在之后的连续 $n+1$ 天里，每天收到 $n+1$ 枚金币。\n\n请计算在前 $k$ 天里，骑士一共获得了多少金币。", "inputFormat": "一个正整数 $k$，表示发放金币的天数。", "outputFormat": "一个正整数，即骑士收到的金币数。\n", "hint": "**【样例 1 说明】**\n\n骑士第一天收到一枚金币；第二天和第三天，每天收到两枚金币；第四、五、六天，每天收到三枚金币。因此一共收到 $1+2+2+3+3+3=14$ 枚金币。\n\n\n对于 $100\\%$ 的数据，$1\\le k\\le 10^4$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2015 Junior] Gold Coins", "background": "NOIP 2015 Junior T1.", "description": "The king pays his loyal knight in gold coins. On day 1, the knight receives 1 coin; then for the next two days (days 2 and 3), he receives 2 coins per day; then for the next three days (days 4, 5, and 6), he receives 3 coins per day; then for the next four days (days 7, 8, 9, and 10), he receives 4 coins per day; and so on. This payment pattern continues indefinitely: after receiving $n$ coins per day for $n$ consecutive days, the knight will receive $n+1$ coins per day for the next $n+1$ consecutive days.\n\nPlease compute how many coins the knight has received in the first $k$ days.", "inputFormat": "A positive integer $k$, representing the number of days of coin distribution.", "outputFormat": "A positive integer, the number of coins the knight receives.", "hint": "[Sample 1 Explanation]\n\nOn day 1 the knight receives 1 coin; on days 2 and 3, he receives 2 coins per day; on days 4, 5, and 6, he receives 3 coins per day. Therefore the total is $1+2+2+3+3+3=14$ coins.\n\nConstraints: For 100% of the testdata, $1 \\le k \\le 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2015 普及组] 金币", "background": "NOIP2015 普及组 T1", "description": "国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天），每天收到两枚金币；之后三天（第四、五、六天），每天收到三枚金币；之后四天（第七、八、九、十天），每天收到四枚金币……；这种工资发放模式会一直这样延续下去：当连续 $n$ 天每天收到 $n$ 枚金币后，骑士会在之后的连续 $n+1$ 天里，每天收到 $n+1$ 枚金币。\n\n请计算在前 $k$ 天里，骑士一共获得了多少金币。", "inputFormat": "一个正整数 $k$，表示发放金币的天数。", "outputFormat": "一个正整数，即骑士收到的金币数。\n", "hint": "**【样例 1 说明】**\n\n骑士第一天收到一枚金币；第二天和第三天，每天收到两枚金币；第四、五、六天，每天收到三枚金币。因此一共收到 $1+2+2+3+3+3=14$ 枚金币。\n\n\n对于 $100\\%$ 的数据，$1\\le k\\le 10^4$。\n", "locale": "zh-CN"}}}
{"pid": "P2670", "type": "P", "difficulty": 1, "samples": [["3 3\n*??\n???\n?*?\n", "*10\n221\n1*1"], ["2 3\n?*?\n*??", "2*1\n*21"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "搜索", "2015", "NOIP 普及组", "枚举"], "title": "[NOIP 2015 普及组] 扫雷游戏", "background": "NOIP2015 普及组 T2", "description": "扫雷游戏是一款十分经典的单机小游戏。在 $n$ 行 $m$ 列的雷区中有一些格子含有地雷（称之为地雷格），其他格子不含地雷（称之为非地雷格）。玩家翻开一个非地雷格时，该格将会出现一个数字——提示周围格子中有多少个是地雷格。游戏的目标是在不翻出任何地雷格的条件下，找出所有的非地雷格。\n\n现在给出 $n$ 行 $m$ 列的雷区中的地雷分布，要求计算出每个非地雷格周围的地雷格数。\n\n注：一个格子的周围格子包括其上、下、左、右、左上、右上、左下、右下八个方向上与之直接相邻的格子。\n", "inputFormat": "第一行是用一个空格隔开的两个整数 $n$ 和 $m$，分别表示雷区的行数和列数。\n\n接下来 $n$ 行，每行 $m$ 个字符，描述了雷区中的地雷分布情况。字符 $\\texttt{*}$ 表示相应格子是地雷格，字符 $\\texttt{?}$ 表示相应格子是非地雷格。相邻字符之间无分隔符。\n", "outputFormat": "输出文件包含 $n$ 行，每行 $m$ 个字符，描述整个雷区。用 $\\texttt{*}$ 表示地雷格，用周围的地雷个数表示非地雷格。相邻字符之间无分隔符。\n", "hint": "对于 $100\\%$的数据，$1≤n≤100, 1≤m≤100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2015 Junior] Minesweeper", "background": "NOIP 2015 Junior T2.", "description": "Minesweeper is a classic single-player mini game. In an $n$-row by $m$-column minefield, some cells contain mines (called mine cells), and the other cells do not (called non-mine cells). When the player reveals a non-mine cell, the cell shows a number indicating how many of its neighboring cells are mine cells. The goal is to find all non-mine cells without revealing any mine cell.\n\nGiven the distribution of mines in an $n$-row by $m$-column minefield, compute for every non-mine cell the number of neighboring mine cells.\n\nNote: The neighboring cells of a cell include the eight directly adjacent cells in the up, down, left, right, upper-left, upper-right, lower-left, and lower-right directions.", "inputFormat": "The first line contains two integers $n$ and $m$ separated by a space, representing the number of rows and columns of the minefield, respectively.\n\nThen follow $n$ lines, each with $m$ characters, describing the distribution of mines in the minefield. The character $\\texttt{*}$ indicates a mine cell, and the character $\\texttt{?}$ indicates a non-mine cell. There are no delimiters between adjacent characters.", "outputFormat": "The output contains $n$ lines, each with $m$ characters, describing the entire minefield. Use $\\texttt{*}$ for mine cells, and use the number of neighboring mines for non-mine cells. There are no delimiters between adjacent characters.", "hint": "For $100\\%$ of the testdata, $1 \\le n \\le 100$, $1 \\le m \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2015 普及组] 扫雷游戏", "background": "NOIP2015 普及组 T2", "description": "扫雷游戏是一款十分经典的单机小游戏。在 $n$ 行 $m$ 列的雷区中有一些格子含有地雷（称之为地雷格），其他格子不含地雷（称之为非地雷格）。玩家翻开一个非地雷格时，该格将会出现一个数字——提示周围格子中有多少个是地雷格。游戏的目标是在不翻出任何地雷格的条件下，找出所有的非地雷格。\n\n现在给出 $n$ 行 $m$ 列的雷区中的地雷分布，要求计算出每个非地雷格周围的地雷格数。\n\n注：一个格子的周围格子包括其上、下、左、右、左上、右上、左下、右下八个方向上与之直接相邻的格子。\n", "inputFormat": "第一行是用一个空格隔开的两个整数 $n$ 和 $m$，分别表示雷区的行数和列数。\n\n接下来 $n$ 行，每行 $m$ 个字符，描述了雷区中的地雷分布情况。字符 $\\texttt{*}$ 表示相应格子是地雷格，字符 $\\texttt{?}$ 表示相应格子是非地雷格。相邻字符之间无分隔符。\n", "outputFormat": "输出文件包含 $n$ 行，每行 $m$ 个字符，描述整个雷区。用 $\\texttt{*}$ 表示地雷格，用周围的地雷个数表示非地雷格。相邻字符之间无分隔符。\n", "hint": "对于 $100\\%$的数据，$1≤n≤100, 1≤m≤100$。\n", "locale": "zh-CN"}}}
{"pid": "P2671", "type": "P", "difficulty": 4, "samples": [["6 2\n5 5 3 2 2 2\n2 2 1 1 2 1", "82\n"], ["15 4\n5 10 8 2 2 2 9 9 7 7 5 6 4 2 4\n2 2 3 3 4 3 3 2 4 4 4 4 1 1 1", "1388"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2015", "线性数据结构", "NOIP 普及组", "排序", "前缀和"], "title": "[NOIP 2015 普及组] 求和", "background": "NOIP2015 普及组 T3", "description": "一条狭长的纸带被均匀划分出了 $n$ 个格子，格子编号从 $1$ 到 $n$。每个格子上都染了一种颜色 $color_i$ 用 $[1,m]$ 当中的一个整数表示），并且写了一个数字 $number_i$。\n\n| 编号 | 1 | 2 | 3 | 4 | 5 | 6 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| **颜色和数字** | $\\color{blue}{5}$ | $\\color{blue}{5}$ | $\\color{red}{3}$ | $\\color{red}{2}$ | $\\color{blue}{2}$ | $\\color{red}{2}$ |\n\n定义一种特殊的三元组：$(x,y,z)$，其中 $x,y,z$ 都代表纸带上格子的编号，这里的三元组要求满足以下两个条件：\n\n1. $x,y,z$ 都是整数，$x<y<z,y-x=z-y$。\n\n2. $color_x=color_z$。\n\n满足上述条件的三元组的分数规定为 $(x+z) \\times (number_x+number_z)$。整个纸带的分数规定为所有满足条件的三元组的分数的和。这个分数可能会很大，你只要输出整个纸带的分数除以 $10007$ 所得的余数即可。", "inputFormat": "第一行是用一个空格隔开的两个正整数 $n$ 和 $m$，$n$ 表示纸带上格子的个数，$m$ 表示纸带上颜色的种类数。\n\n第二行有 $n$ 用空格隔开的正整数，第 $i$ 个数字表示纸带上编号为 $i$ 格子上面写的数字 $number_i$。\n\n第三行有 $n$ 用空格隔开的正整数，第 $i$ 数字表示纸带上编号为 $i$ 格子染的颜色 $color_i$。", "outputFormat": "一个整数，表示所求的纸带分数除以 $10007$ 所得的余数。", "hint": "**样例 1 解释**\n\n纸带如题目描述中的图所示。\n\n所有满足条件的三元组为：$(1, 3, 5), (4, 5, 6)$。\n\n所以纸带的分数为 $(1 + 5) \\times (5 + 2) + (4 + 6) \\times (2 + 2) = 42 + 40 = 82$。\n\n\n对于第 $1$ 组至第 $2$ 组数据， $1 ≤ n ≤ 100, 1 ≤ m ≤ 5$；\n\n对于第 $3$ 组至第 $4$ 组数据，$1 ≤ n ≤ 3000, 1 ≤ m ≤ 100$；\n\n对于第 $5$ 组至第 $ 6 $ 组数据，$1 ≤ n ≤ 10^5, 1 ≤ m ≤ 10^5$，且不存在出现次数超过 $ 20 $ 的颜色；\n\n对于全部 $10$ 组数据，$1 ≤ n ≤ 10^5, 1 ≤ m ≤ 10^5, 1 ≤ color_i ≤ m,1≤number_i≤10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2015 Junior] Sum", "background": "NOIP 2015 Junior T3.", "description": "A long narrow strip of paper is evenly divided into $n$ cells, numbered from $1$ to $n$. Each cell is colored with a color $color_i$ (represented by an integer from $[1, m]$), and a number $number_i$ is written on it.\n\n| Index | 1 | 2 | 3 | 4 | 5 | 6 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| **Color and number** | $\\color{blue}{5}$ | $\\color{blue}{5}$ | $\\color{red}{3}$ | $\\color{red}{2}$ | $\\color{blue}{2}$ | $\\color{red}{2}$ |\n\nDefine a special triplet $(x, y, z)$, where $x$, $y$, $z$ are indices of cells on the strip, satisfying both of the following conditions:\n\n1. $x$, $y$, $z$ are integers, $x < y < z$, $y - x = z - y$.\n2. $color_x = color_z$.\n\nThe score of such a triplet is defined as $(x+z) \\times (number_x+number_z)$. The score of the entire strip is the sum of the scores of all triplets that satisfy the conditions. This score can be very large; you only need to output the remainder when the total score is divided by $10007$.", "inputFormat": "The first line contains two positive integers $n$ and $m$ separated by a space. $n$ is the number of cells on the strip, and $m$ is the number of colors.\n\nThe second line contains $n$ positive integers separated by spaces; the $i$-th number is the number $number_i$ written on cell $i$.\n\nThe third line contains $n$ positive integers separated by spaces; the $i$-th number is the color $color_i$ of cell $i$.", "outputFormat": "A single integer, the remainder of the total score modulo $10007$.", "hint": "Sample 1 Explanation.\n\nThe strip is as shown in the figure in the problem description.\n\nAll valid triplets are: $(1, 3, 5)$, $(4, 5, 6)$.\n\nTherefore, the total score is $(1 + 5) \\times (5 + 2) + (4 + 6) \\times (2 + 2) = 42 + 40 = 82$.\n\nConstraints:\n- For testdata groups $1$ to $2$, $1 \\le n \\le 100$, $1 \\le m \\le 5$.\n- For testdata groups $3$ to $4$, $1 \\le n \\le 3000$, $1 \\le m \\le 100$.\n- For testdata groups $5$ to $6$, $1 \\le n \\le 10^5$, $1 \\le m \\le 10^5$, and no color appears more than $20$ times.\n- For all $10$ testdata groups, $1 \\le n \\le 10^5$, $1 \\le m \\le 10^5$, $1 \\le color_i \\le m$, $1 \\le number_i \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2015 普及组] 求和", "background": "NOIP2015 普及组 T3", "description": "一条狭长的纸带被均匀划分出了 $n$ 个格子，格子编号从 $1$ 到 $n$。每个格子上都染了一种颜色 $color_i$ 用 $[1,m]$ 当中的一个整数表示），并且写了一个数字 $number_i$。\n\n| 编号 | 1 | 2 | 3 | 4 | 5 | 6 |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| **颜色和数字** | $\\color{blue}{5}$ | $\\color{blue}{5}$ | $\\color{red}{3}$ | $\\color{red}{2}$ | $\\color{blue}{2}$ | $\\color{red}{2}$ |\n\n定义一种特殊的三元组：$(x,y,z)$，其中 $x,y,z$ 都代表纸带上格子的编号，这里的三元组要求满足以下两个条件：\n\n1. $x,y,z$ 都是整数，$x<y<z,y-x=z-y$。\n\n2. $color_x=color_z$。\n\n满足上述条件的三元组的分数规定为 $(x+z) \\times (number_x+number_z)$。整个纸带的分数规定为所有满足条件的三元组的分数的和。这个分数可能会很大，你只要输出整个纸带的分数除以 $10007$ 所得的余数即可。", "inputFormat": "第一行是用一个空格隔开的两个正整数 $n$ 和 $m$，$n$ 表示纸带上格子的个数，$m$ 表示纸带上颜色的种类数。\n\n第二行有 $n$ 用空格隔开的正整数，第 $i$ 个数字表示纸带上编号为 $i$ 格子上面写的数字 $number_i$。\n\n第三行有 $n$ 用空格隔开的正整数，第 $i$ 数字表示纸带上编号为 $i$ 格子染的颜色 $color_i$。", "outputFormat": "一个整数，表示所求的纸带分数除以 $10007$ 所得的余数。", "hint": "**样例 1 解释**\n\n纸带如题目描述中的图所示。\n\n所有满足条件的三元组为：$(1, 3, 5), (4, 5, 6)$。\n\n所以纸带的分数为 $(1 + 5) \\times (5 + 2) + (4 + 6) \\times (2 + 2) = 42 + 40 = 82$。\n\n\n对于第 $1$ 组至第 $2$ 组数据， $1 ≤ n ≤ 100, 1 ≤ m ≤ 5$；\n\n对于第 $3$ 组至第 $4$ 组数据，$1 ≤ n ≤ 3000, 1 ≤ m ≤ 100$；\n\n对于第 $5$ 组至第 $ 6 $ 组数据，$1 ≤ n ≤ 10^5, 1 ≤ m ≤ 10^5$，且不存在出现次数超过 $ 20 $ 的颜色；\n\n对于全部 $10$ 组数据，$1 ≤ n ≤ 10^5, 1 ≤ m ≤ 10^5, 1 ≤ color_i ≤ m,1≤number_i≤10^5$。", "locale": "zh-CN"}}}
{"pid": "P2672", "type": "P", "difficulty": 5, "samples": [["5\n1 2 3 4 5\n1 2 3 4 5", "15\n19\n22\n24\n25"], ["5\n1 2 2 4 5\n5 4 3 4 1", "12\n17\n21\n24\n27"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2015", "线段树", "树状数组", "NOIP 普及组", "优先队列"], "title": "[NOIP 2015 普及组] 推销员", "background": "NOIP2015 普及组 T4", "description": "阿明是一名推销员，他奉命到螺丝街推销他们公司的产品。螺丝街是一条死胡同，出口与入口是同一个，街道的一侧是围墙，另一侧是住户。螺丝街一共有 $N$ 家住户，第 $i$ 家住户到入口的距离为 $S_i$ 米。由于同一栋房子里可以有多家住户，所以可能有多家住户与入口的距离相等。阿明会从入口进入，依次向螺丝街的 $X$ 家住户推销产品，然后再原路走出去。\n\n阿明每走 $1$ 米就会积累 $1$ 点疲劳值，向第 $i$ 家住户推销产品会积累 $A_i$ 点疲劳值。阿明是工作狂，他想知道，对于不同的 $X$，在不走多余的路的前提下，他最多可以积累多少点疲劳值。", "inputFormat": "第一行有一个正整数 $N$，表示螺丝街住户的数量。\n\n接下来的一行有 $N$ 个非负整数，其中第 $i$ 个整数 $S_i$ 表示第 $i$ 家住户到入口的距离。数据保证 $S_1 \\le S_2 \\le \\cdots \\le S_n <10^8$。\n\n接下来的一行有 $N$ 个正整数，其中第 $i$ 个整数 $A_i$ 表示向第 $i$ 户住户推销产品会积累的疲劳值。数据保证 $A_i<1000$。", "outputFormat": "输出 $N$ 行，每行一个正整数，第 $i$ 行整数表示当 $X=i$ 时，阿明最多积累的疲劳值。", "hint": "**输入输出样例 1 说明**\n\n$X=1$：向住户 $5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $5$，总疲劳值为 $15$。\n\n$X=2$：向住户 $4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $4+5$，总疲劳值为 $5+5+4+5=19$。\n\n$X=3$：向住户 $3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值 $3+4+5$，总疲劳值为 $5+5+3+4+5=22$。\n\n$X=4$：向住户 $2,3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值 $2+3+4+5$，总疲劳值 $5+5+2+3+4+5=24$。\n\n$X=5$：向住户 $1,2,3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值 $1+2+3+4+5$，总疲劳值 $5+5+1+2+3+4+5=25$。\n\n\n**输入输出样例 2 说明**\n\n$X=1$：向住户 $4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $4$，总疲劳值 $4+4+4=12$。\n\n$X=2$：向住户 $1,4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $5+4$，总疲劳值 $4+4+5+4=17$。\n\n$X=3$：向住户 $1,2,4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $5+4+4$，总疲劳值 $4+4+5+4+4=21$。\n\n$X=4$：向住户 $1,2,3,4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $5+4+3+4$，总疲劳值 $4+4+5+4+3+4=24$。或者向住户 $1,2,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $5+4+4+1$，总疲劳值 $5+5+5+4+4+1=24$。\n\n$X=5$：向住户 $1,2,3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $5+4+3+4+1$，总疲劳值 $5+5+5+4+3+4+1=27$。\n\n**数据范围**\n\n对于 $20\\%$ 的数据，$1 \\le N \\le20$；  \n对于 $40\\%$ 的数据，$1\\le N \\le 100$；  \n对于 $60\\%$ 的数据，$1 \\le N \\le 1000$；  \n对于 $100\\%$ 的数据，$1 \\le N \\le 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2015 Junior] Salesman", "background": "NOIP 2015 Junior T4.", "description": "A Ming is a salesman. He is assigned to promote his company’s products on Screw Street. Screw Street is a dead-end; the exit and entrance are the same. One side of the street is a wall, and the other side has households. There are $N$ households on Screw Street, and the $i$-th household is $S_i$ meters from the entrance. Because multiple households can live in the same building, several households may be at the same distance from the entrance. A Ming will enter from the entrance, promote products to $X$ households on Screw Street one by one, and then walk back along the same route.\n\nFor every $1$ meter he walks, he accumulates $1$ fatigue point. Promoting to the $i$-th household accumulates $A_i$ fatigue points. A Ming is a workaholic. He wants to know, for different values of $X$, under the premise of not walking any extra distance, what is the maximum total fatigue he can accumulate.", "inputFormat": "The first line contains a positive integer $N$, the number of households on Screw Street.\n\nThe next line contains $N$ non-negative integers; the $i$-th integer $S_i$ is the distance from the $i$-th household to the entrance. It is guaranteed that $S_1 \\le S_2 \\le \\cdots \\le S_n <10^8$.\n\nThe next line contains $N$ positive integers; the $i$-th integer $A_i$ is the fatigue accumulated by promoting to the $i$-th household. It is guaranteed that $A_i<1000$.", "outputFormat": "Output $N$ lines, each with one positive integer. The integer on the $i$-th line denotes the maximum total fatigue when $X=i$.", "hint": "Explanation for Sample 1:\n\n$X=1$: promote to household $5$. The round-trip walking fatigue is $5+5$, the promotion fatigue is $5$, and the total fatigue is $15$.\n\n$X=2$: promote to households $4,5$. The round-trip walking fatigue is $5+5$, the promotion fatigue is $4+5$, and the total fatigue is $5+5+4+5=19$.\n\n$X=3$: promote to households $3,4,5$. The round-trip walking fatigue is $5+5$, the promotion fatigue is $3+4+5$, and the total fatigue is $5+5+3+4+5=22$.\n\n$X=4$: promote to households $2,3,4,5$. The round-trip walking fatigue is $5+5$, the promotion fatigue is $2+3+4+5$, and the total fatigue is $5+5+2+3+4+5=24$.\n\n$X=5$: promote to households $1,2,3,4,5$. The round-trip walking fatigue is $5+5$, the promotion fatigue is $1+2+3+4+5$, and the total fatigue is $5+5+1+2+3+4+5=25$.\n\nExplanation for Sample 2:\n\n$X=1$: promote to household $4$. The round-trip walking fatigue is $4+4$, the promotion fatigue is $4$, and the total fatigue is $4+4+4=12$.\n\n$X=2$: promote to households $1,4$. The round-trip walking fatigue is $4+4$, the promotion fatigue is $5+4$, and the total fatigue is $4+4+5+4=17$.\n\n$X=3$: promote to households $1,2,4$. The round-trip walking fatigue is $4+4$, the promotion fatigue is $5+4+4$, and the total fatigue is $4+4+5+4+4=21$.\n\n$X=4$: promote to households $1,2,3,4$. The round-trip walking fatigue is $4+4$, the promotion fatigue is $5+4+3+4$, and the total fatigue is $4+4+5+4+3+4=24$. Or promote to households $1,2,4,5$. The round-trip walking fatigue is $5+5$, the promotion fatigue is $5+4+4+1$, and the total fatigue is $5+5+5+4+4+1=24$.\n\n$X=5$: promote to households $1,2,3,4,5$. The round-trip walking fatigue is $5+5$, the promotion fatigue is $5+4+3+4+1$, and the total fatigue is $5+5+5+4+3+4+1=27$.\n\nConstraints:\n\nFor $20\\%$ of the testdata, $1 \\le N \\le 20$.\nFor $40\\%$ of the testdata, $1 \\le N \\le 100$.\nFor $60\\%$ of the testdata, $1 \\le N \\le 1000$.\nFor $100\\%$ of the testdata, $1 \\le N \\le 100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2015 普及组] 推销员", "background": "NOIP2015 普及组 T4", "description": "阿明是一名推销员，他奉命到螺丝街推销他们公司的产品。螺丝街是一条死胡同，出口与入口是同一个，街道的一侧是围墙，另一侧是住户。螺丝街一共有 $N$ 家住户，第 $i$ 家住户到入口的距离为 $S_i$ 米。由于同一栋房子里可以有多家住户，所以可能有多家住户与入口的距离相等。阿明会从入口进入，依次向螺丝街的 $X$ 家住户推销产品，然后再原路走出去。\n\n阿明每走 $1$ 米就会积累 $1$ 点疲劳值，向第 $i$ 家住户推销产品会积累 $A_i$ 点疲劳值。阿明是工作狂，他想知道，对于不同的 $X$，在不走多余的路的前提下，他最多可以积累多少点疲劳值。", "inputFormat": "第一行有一个正整数 $N$，表示螺丝街住户的数量。\n\n接下来的一行有 $N$ 个非负整数，其中第 $i$ 个整数 $S_i$ 表示第 $i$ 家住户到入口的距离。数据保证 $S_1 \\le S_2 \\le \\cdots \\le S_n <10^8$。\n\n接下来的一行有 $N$ 个正整数，其中第 $i$ 个整数 $A_i$ 表示向第 $i$ 户住户推销产品会积累的疲劳值。数据保证 $A_i<1000$。", "outputFormat": "输出 $N$ 行，每行一个正整数，第 $i$ 行整数表示当 $X=i$ 时，阿明最多积累的疲劳值。", "hint": "**输入输出样例 1 说明**\n\n$X=1$：向住户 $5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $5$，总疲劳值为 $15$。\n\n$X=2$：向住户 $4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $4+5$，总疲劳值为 $5+5+4+5=19$。\n\n$X=3$：向住户 $3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值 $3+4+5$，总疲劳值为 $5+5+3+4+5=22$。\n\n$X=4$：向住户 $2,3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值 $2+3+4+5$，总疲劳值 $5+5+2+3+4+5=24$。\n\n$X=5$：向住户 $1,2,3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值 $1+2+3+4+5$，总疲劳值 $5+5+1+2+3+4+5=25$。\n\n\n**输入输出样例 2 说明**\n\n$X=1$：向住户 $4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $4$，总疲劳值 $4+4+4=12$。\n\n$X=2$：向住户 $1,4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $5+4$，总疲劳值 $4+4+5+4=17$。\n\n$X=3$：向住户 $1,2,4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $5+4+4$，总疲劳值 $4+4+5+4+4=21$。\n\n$X=4$：向住户 $1,2,3,4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $5+4+3+4$，总疲劳值 $4+4+5+4+3+4=24$。或者向住户 $1,2,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $5+4+4+1$，总疲劳值 $5+5+5+4+4+1=24$。\n\n$X=5$：向住户 $1,2,3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $5+4+3+4+1$，总疲劳值 $5+5+5+4+3+4+1=27$。\n\n**数据范围**\n\n对于 $20\\%$ 的数据，$1 \\le N \\le20$；  \n对于 $40\\%$ 的数据，$1\\le N \\le 100$；  \n对于 $60\\%$ 的数据，$1 \\le N \\le 1000$；  \n对于 $100\\%$ 的数据，$1 \\le N \\le 10^5$。", "locale": "zh-CN"}}}
{"pid": "P2673", "type": "P", "difficulty": 5, "samples": [["11 20", "6179775280"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学"], "title": "《瞿葩的数字游戏》T1-数字王国的门神", "background": "一来到数字王国的大门，我们就看到硕大的两个数字 $8$ 和 $9$ 分别镭射（请不要吐槽这个词……）在两侧大门。于是瞿葩心想，这有什么意义呢？于是他找到了你。", "description": "鬼知道 $89$ 有什么意义啊 TAT，但是瞿葩知道，$89$ 是 Fibonacci 数列的第二个非孪生质数。（还有哦，因为 $89$ 被镭射在了门上……所以之后的故事（题目）中都不会出现 $89$……但是这道题要计算 $89$）\n\n那么看来这个现象与 Fibonacci 数列有关系咯，所以现在瞿葩想知道，Fibonacci 数列的累积和中的第 $M$ 位到第 $N$ 位，累积和就是第 $1$ 项 $\\times 10^K$ 到第 $K$ 项 $\\times10^1$ 的总和，即\n\n$$\\lim _ {K \\to \\infty} \\sum _ {i = 1} ^ K F _ i \\times 10 ^ {K - i}$$\n\n$F _ i$ 表示 Fibonacci 数列的第 $i$ 项，通项公式和递推式如下：\n\n- 通项公式：$\\displaystyle F _ i = \\frac{1}{\\sqrt{5}}\\left[\\left(\\frac{1 + \\sqrt{5}}{2}\\right) ^ i - \\left(\\frac{1 - \\sqrt{5}}{2}\\right) ^ i\\right]$；\n- 递推式：$F _ i = F _ {i - 1} + F _ {i - 2}$。\n\n请你写一个程序帮帮他。\n\n任务：给定 $M, N$，要求输出累积和的第 $M \\sim N$ 位。\n\n一开始的累积和：$1123595505\\cdots$。", "inputFormat": "两个整数 $M, N$。", "outputFormat": "累积和第 $M \\sim N$ 位数字，不省略首尾的 $0$。", "hint": "当然有 $10\\le M\\le N\\le 2 \\times 10 ^ 5$，因为前 $10$ 位瞿葩已经算出来了，知道 $2\\times 10 ^ 5$ 以后的数字位也没什么用是吧 \\\\\\(\\^o\\^\\)\\/ 而且瞿葩只想研究一点点，所以其中 $0<N-M+1\\le2000$。不过正是因为瞿葩最多只要得到 $2000$ 位结果，所以他要求你的程序要在 1s 内出结果。", "locale": "zh-CN", "translations": {"en": {"title": "“Qu Pa's Number Game” T1 - Gatekeeper of the Number Kingdom", "background": "As soon as we arrive at the gate of the Number Kingdom, we see two huge numbers, 8 and 9, “laser-engraved” (please don't nitpick this word...) on the two sides of the gate. Qu Pa wonders what this means, so he comes to you.", "description": "Who knows what 89 means, TAT. But Qu Pa knows that 89 is the second non-twin prime in the Fibonacci sequence. (Also, since 89 is laser-engraved on the gate... 89 will not appear in the later stories (problems)... but in this problem we still need to compute with 89.)\n\nSo it seems this phenomenon is related to the Fibonacci sequence. Now Qu Pa wants to know the digits from position M to position N of the cumulative sum formed from the Fibonacci sequence. The “cumulative sum” is the total from the 1st term times $10^{K}$ to the $K$-th term times $10^{1}$, i.e.,\n\n ![](https://cdn.luogu.com.cn/upload/pic/1733.png)          \n\nPlease write a program to help him.\n\nTask: Given $M$, $N$, output the digits from position $M$ to $N$ of the cumulative sum.\n\nThe beginning of the cumulative sum: 1123595505...", "inputFormat": "Two integers $M$ and $N$.", "outputFormat": "The digits from position $M$ to position $N$ of the cumulative sum, without omitting leading or trailing zeros.", "hint": "Constraints: $10 \\le M \\le N \\le 200000$. Since Qu Pa has already computed the first 10 digits, there is no use in knowing the digits after position 200000, right? Also, $0 < N - M + 1 \\le 2000$. Precisely because Qu Pa needs at most 2000 digits, he requires your program to finish within 1 s.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "《瞿葩的数字游戏》T1-数字王国的门神", "background": "一来到数字王国的大门，我们就看到硕大的两个数字 $8$ 和 $9$ 分别镭射（请不要吐槽这个词……）在两侧大门。于是瞿葩心想，这有什么意义呢？于是他找到了你。", "description": "鬼知道 $89$ 有什么意义啊 TAT，但是瞿葩知道，$89$ 是 Fibonacci 数列的第二个非孪生质数。（还有哦，因为 $89$ 被镭射在了门上……所以之后的故事（题目）中都不会出现 $89$……但是这道题要计算 $89$）\n\n那么看来这个现象与 Fibonacci 数列有关系咯，所以现在瞿葩想知道，Fibonacci 数列的累积和中的第 $M$ 位到第 $N$ 位，累积和就是第 $1$ 项 $\\times 10^K$ 到第 $K$ 项 $\\times10^1$ 的总和，即\n\n$$\\lim _ {K \\to \\infty} \\sum _ {i = 1} ^ K F _ i \\times 10 ^ {K - i}$$\n\n$F _ i$ 表示 Fibonacci 数列的第 $i$ 项，通项公式和递推式如下：\n\n- 通项公式：$\\displaystyle F _ i = \\frac{1}{\\sqrt{5}}\\left[\\left(\\frac{1 + \\sqrt{5}}{2}\\right) ^ i - \\left(\\frac{1 - \\sqrt{5}}{2}\\right) ^ i\\right]$；\n- 递推式：$F _ i = F _ {i - 1} + F _ {i - 2}$。\n\n请你写一个程序帮帮他。\n\n任务：给定 $M, N$，要求输出累积和的第 $M \\sim N$ 位。\n\n一开始的累积和：$1123595505\\cdots$。", "inputFormat": "两个整数 $M, N$。", "outputFormat": "累积和第 $M \\sim N$ 位数字，不省略首尾的 $0$。", "hint": "当然有 $10\\le M\\le N\\le 2 \\times 10 ^ 5$，因为前 $10$ 位瞿葩已经算出来了，知道 $2\\times 10 ^ 5$ 以后的数字位也没什么用是吧 \\\\\\(\\^o\\^\\)\\/ 而且瞿葩只想研究一点点，所以其中 $0<N-M+1\\le2000$。不过正是因为瞿葩最多只要得到 $2000$ 位结果，所以他要求你的程序要在 1s 内出结果。", "locale": "zh-CN"}}}
{"pid": "P2674", "type": "P", "difficulty": 3, "samples": [["2\n36\n1000000\n", "3 4\n4 204\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "数学", "洛谷原创"], "title": "《瞿葩的数字游戏》T2-多边形数", "background": "数字王国里有一类特殊的数，它们叫做多边形数。并且国王 $1$ 规定数字间的联姻只能在同为一种多边形数中进行。（请不要吐槽这个规定……）\n\n瞿葩对这个现象十分好奇，见 $36$ 和 $10$ 这一对情侣在散步，便上前询问 $36$ 它是什么多边形数。可是 $36$ 拍拍脑门，想了想说：“我也不知道啊，你去问问国王吧。”\n\n看来国民们并不知道自己是什么多边形数啊，国王 $1$ 急的发愁。国王 $1$ 只知道多边形数怎么计算，但是多边形数要怎么给国民做解释呢，干脆这样解释吧：可以排成正多边形的整数都是多边形数。当然多边形数可以分为三边（角）形数、四边形数（正方形数）、五边形数、六边形数……\n", "description": "**此题为规律题，请自行寻找规律，以锻炼数学归纳能力！！**\n\n我们拿三角形数做例子：图中的 $1$、$3$、$6$、$10$ 就是三角形数。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1742.png) \n\n任务：求出 $N$ 是哪一种多边形数（假设 $N$ 是 $K$ 边形数），比如我们求出 $36$ 是三边形数和四边形数（貌似叫做三角形数和正方形数呵）。若不是多边形数，输出 Poor + 该数字。若同时是多种多边形数，输出最小的一个和第二小的一个。每个读入文件里有 $ng$ 组数据。\n", "inputFormat": "先是一个数 $ng$，然后 $ng$ 行，每行一个整数。\n", "outputFormat": "$ng$ 行，$N$ 相应的 $K_1$ 和 $K_2$，若不是多边形数，输出 Poor + 该数字。（中间无空格）\n", "hint": "### 数据范围及约定\n\n对于 $20\\%$ 的数据，$1 \\le K_1,K_2 \\le 6$；\n\n对于 $100\\%$ 的数据， $1 \\le N \\le 10^6$，$1 \\le ng \\le 10^2$。\n\n如果同时是多种多边形数，设 $K_1$ 为最小的 $K$，$K_2$ 为次小的 $K$。\n\n国王 $1$：“你可以发现四边形数（正方形数）就是平方数这个规律吗？为方便理解，我给出前几个多边形数表。”（表中可以看出，正六边形不包括正中心的那个点，以此类推）\n\n| 自然数 | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| 三角形数 | $1$ | $3$ | $6$ | $10$ | $15$ | $21$ | $28$ | $36$ |\n| 正方形数 | $1$ | $4$ | $9$ | $16$ | $25$ | $36$ | $49$ | $64$ |\n| 五边形数 | $1$ | $5$ | $12$ | $22$ | $35$ | $51$ | $70$ | $92$ |\n| 六边形数 | $1$ | $6$ | $15$ | $28$ | $45$ | $66$ | $91$ | $120$ |\n", "locale": "zh-CN", "translations": {"en": {"title": "Qupa's Number Game T2 - Polygonal Numbers", "background": "In the Kingdom of Numbers, there is a special class of numbers called polygonal numbers. King $1$ also decreed that marriages between numbers can only happen within the same type of polygonal numbers. (Please don't complain about this rule...)\n\nQupa became very curious about this phenomenon. Seeing the couple $36$ and $10$ taking a walk, Qupa asked $36$ which kind of polygonal number it was. But $36$ patted its head and said, \"I don't know either. Go ask the king.\"\n\nIt seems the citizens do not know which polygonal numbers they are, and King $1$ is worried. King $1$ only knows how to compute polygonal numbers, but how should he explain this to the citizens? He decides to explain it this way: any integer that can be arranged into a regular polygon is a polygonal number. Polygonal numbers include triangular numbers, square numbers, pentagonal numbers, hexagonal numbers, and so on.", "description": "This is a pattern-finding problem. Please discover the pattern yourself to practice mathematical induction!!\n\nLet’s take triangular numbers as an example: the numbers $1$, $3$, $6$, $10$ in the figure are triangular numbers.\n\n![](https://cdn.luogu.com.cn/upload/pic/1742.png)\n\nTask: determine which kinds of polygonal numbers $N$ belongs to (assume $N$ is a $K$-gonal number). For example, we can find that $36$ is both a triangular number and a square number. If it is not a polygonal number, output Poor + that number. If it is multiple types of polygonal numbers at the same time, output the smallest $K$ and the second smallest $K$. Each input file contains $ng$ test cases.", "inputFormat": "First a number $ng$, then $ng$ lines, each containing one integer.", "outputFormat": "Output $ng$ lines. For each $N$, output the corresponding $K_1$ and $K_2$. If $N$ is not a polygonal number, output Poor + that number (no spaces in between).", "hint": "### Constraints and Notes\n\nFor $20\\%$ of the testdata, $1 \\le K_1, K_2 \\le 6$.\n\nFor $100\\%$ of the testdata, $1 \\le N \\le 10^6$, $1 \\le ng \\le 10^2$.\n\nIf $N$ is multiple types of polygonal numbers at the same time, let $K_1$ be the smallest $K$, and $K_2$ be the second smallest $K$.\n\nKing $1$: \"Can you discover the pattern that square numbers are just perfect squares? To make it easier to understand, I’ll provide a table of the first few polygonal numbers.\" (From the table you can see that a regular hexagon does not include the very center point, and similarly for others.)\n\n| Natural numbers | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| Triangular numbers | $1$ | $3$ | $6$ | $10$ | $15$ | $21$ | $28$ | $36$ |\n| Square numbers | $1$ | $4$ | $9$ | $16$ | $25$ | $36$ | $49$ | $64$ |\n| Pentagonal numbers | $1$ | $5$ | $12$ | $22$ | $35$ | $51$ | $70$ | $92$ |\n| Hexagonal numbers | $1$ | $6$ | $15$ | $28$ | $45$ | $66$ | $91$ | $120$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "《瞿葩的数字游戏》T2-多边形数", "background": "数字王国里有一类特殊的数，它们叫做多边形数。并且国王 $1$ 规定数字间的联姻只能在同为一种多边形数中进行。（请不要吐槽这个规定……）\n\n瞿葩对这个现象十分好奇，见 $36$ 和 $10$ 这一对情侣在散步，便上前询问 $36$ 它是什么多边形数。可是 $36$ 拍拍脑门，想了想说：“我也不知道啊，你去问问国王吧。”\n\n看来国民们并不知道自己是什么多边形数啊，国王 $1$ 急的发愁。国王 $1$ 只知道多边形数怎么计算，但是多边形数要怎么给国民做解释呢，干脆这样解释吧：可以排成正多边形的整数都是多边形数。当然多边形数可以分为三边（角）形数、四边形数（正方形数）、五边形数、六边形数……\n", "description": "**此题为规律题，请自行寻找规律，以锻炼数学归纳能力！！**\n\n我们拿三角形数做例子：图中的 $1$、$3$、$6$、$10$ 就是三角形数。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1742.png) \n\n任务：求出 $N$ 是哪一种多边形数（假设 $N$ 是 $K$ 边形数），比如我们求出 $36$ 是三边形数和四边形数（貌似叫做三角形数和正方形数呵）。若不是多边形数，输出 Poor + 该数字。若同时是多种多边形数，输出最小的一个和第二小的一个。每个读入文件里有 $ng$ 组数据。\n", "inputFormat": "先是一个数 $ng$，然后 $ng$ 行，每行一个整数。\n", "outputFormat": "$ng$ 行，$N$ 相应的 $K_1$ 和 $K_2$，若不是多边形数，输出 Poor + 该数字。（中间无空格）\n", "hint": "### 数据范围及约定\n\n对于 $20\\%$ 的数据，$1 \\le K_1,K_2 \\le 6$；\n\n对于 $100\\%$ 的数据， $1 \\le N \\le 10^6$，$1 \\le ng \\le 10^2$。\n\n如果同时是多种多边形数，设 $K_1$ 为最小的 $K$，$K_2$ 为次小的 $K$。\n\n国王 $1$：“你可以发现四边形数（正方形数）就是平方数这个规律吗？为方便理解，我给出前几个多边形数表。”（表中可以看出，正六边形不包括正中心的那个点，以此类推）\n\n| 自然数 | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| 三角形数 | $1$ | $3$ | $6$ | $10$ | $15$ | $21$ | $28$ | $36$ |\n| 正方形数 | $1$ | $4$ | $9$ | $16$ | $25$ | $36$ | $49$ | $64$ |\n| 五边形数 | $1$ | $5$ | $12$ | $22$ | $35$ | $51$ | $70$ | $92$ |\n| 六边形数 | $1$ | $6$ | $15$ | $28$ | $45$ | $66$ | $91$ | $120$ |\n", "locale": "zh-CN"}}}
{"pid": "P2675", "type": "P", "difficulty": 5, "samples": [["4", "24"], ["1125", "700"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "贪心", "洛谷原创", "组合数学", "Lucas 定理"], "title": "《瞿葩的数字游戏》T3-三角圣地", "background": "国王 1 带大家到了数字王国的中心：三角圣地。", "description": "数字王国的中心是由一个倒三角构成。\n\n倒三角一共 $N$ 层，从上往下第 $i$ 层有 $N-i+1$ 个数字。倒三角的第 $1$ 层必须是 $1 \\sim N$ 的全排列之一，即必须使用 $1 \\sim N$ 之间的所有数字且不能重复。从第 $2$ 层开始以后每一层的数字都是由其左上方和右上方两个数字相加得到的。例如，下面是一个合法的倒三角形：\n\n```plain\n1   2   3   4\n  3   5   7\n    8   12\n      20\n```\n\n这个倒三角形的 $N$ 为 $4$，其最后一层的数字为 $20$。\n\n数字王国称最后一层的数字为“基”，请你编程求出“基”的最大值对 $10007$ 取模的结果。", "inputFormat": "一行，一个整数 $N$，表示倒三角的层数。", "outputFormat": "一行一个整数，表示 $N$ 层倒三角“基”的最大值对 $10007$ 取模的结果。", "hint": "### 样例解释\n\n一种可行的方案为：\n\n```plain\n1   3   4   2\n  4   7   6\n    11  13\n      24\n```\n\n可以证明没有比这更好的方法。\n\n### 数据范围\n\n对于 $20\\%$ 的数据，$N \\le 100$。\n\n对于 $50\\%$ 的数据，$N \\le 3000$。\n\n对于 $100\\%$ 的数据，$0 \\le N \\le {10}^6$。", "locale": "zh-CN", "translations": {"en": {"title": "\"Qu Pa's Number Game\" T3 - Triangle Sanctuary", "background": "King 1 leads everyone to the center of the Kingdom of Numbers: the Triangle Sanctuary.", "description": "The center of the Kingdom of Numbers is formed by an inverted triangle.\n\nThe inverted triangle has $N$ layers. The $i$-th layer from top to bottom contains $N - i + 1$ numbers. The first layer must be one of the permutations of $1 \\sim N$, that is, it must use all numbers from $1$ to $N$ without repetition. Starting from the second layer, each number is obtained by adding the two numbers above it to the left and right. For example, the following is a valid inverted triangle:\n\n```plain\n1   2   3   4\n  3   5   7\n    8   12\n      20\n```\n\nThis inverted triangle has $N = 4$, and the last-layer number is $20$.\n\nThe Kingdom of Numbers calls the last-layer number the 'base'. Please write a program to compute the maximum value of the 'base' modulo $10007$.", "inputFormat": "One line containing an integer $N$, representing the number of layers of the inverted triangle.", "outputFormat": "One line containing an integer, which is the maximum possible 'base' for $N$ layers modulo $10007$.", "hint": "- Sample Explanation\n\nOne feasible arrangement is:\n\n```plain\n1   3   4   2\n  4   7   6\n    11  13\n      24\n```\n\nIt can be proved that there is no better method.\n\n- Constraints\n\nFor $20\\%$ of the testdata, $N \\le 100$.\n\nFor $50\\%$ of the testdata, $N \\le 3000$.\n\nFor $100\\%$ of the testdata, $0 \\le N \\le {10}^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "《瞿葩的数字游戏》T3-三角圣地", "background": "国王 1 带大家到了数字王国的中心：三角圣地。", "description": "数字王国的中心是由一个倒三角构成。\n\n倒三角一共 $N$ 层，从上往下第 $i$ 层有 $N-i+1$ 个数字。倒三角的第 $1$ 层必须是 $1 \\sim N$ 的全排列之一，即必须使用 $1 \\sim N$ 之间的所有数字且不能重复。从第 $2$ 层开始以后每一层的数字都是由其左上方和右上方两个数字相加得到的。例如，下面是一个合法的倒三角形：\n\n```plain\n1   2   3   4\n  3   5   7\n    8   12\n      20\n```\n\n这个倒三角形的 $N$ 为 $4$，其最后一层的数字为 $20$。\n\n数字王国称最后一层的数字为“基”，请你编程求出“基”的最大值对 $10007$ 取模的结果。", "inputFormat": "一行，一个整数 $N$，表示倒三角的层数。", "outputFormat": "一行一个整数，表示 $N$ 层倒三角“基”的最大值对 $10007$ 取模的结果。", "hint": "### 样例解释\n\n一种可行的方案为：\n\n```plain\n1   3   4   2\n  4   7   6\n    11  13\n      24\n```\n\n可以证明没有比这更好的方法。\n\n### 数据范围\n\n对于 $20\\%$ 的数据，$N \\le 100$。\n\n对于 $50\\%$ 的数据，$N \\le 3000$。\n\n对于 $100\\%$ 的数据，$0 \\le N \\le {10}^6$。", "locale": "zh-CN"}}}
{"pid": "P2676", "type": "P", "difficulty": 2, "samples": [["6 40\n6\n18\n11\n13\n19\n11", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["贪心", "2007", "USACO", "排序"], "title": "[USACO07DEC] Bookshelf B", "background": null, "description": "Farmer John 最近为奶牛们的图书馆添置了一个巨大的书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。\n\n所有 $N(1 \\le N \\le 20,000)$ 头奶牛都有一个确定的身高 $H_i(1 \\le H_i \\le 10,000)$。设所有奶牛身高的和为 $S$。书架的高度为 $B$，并且保证 $1 \\le B \\le S < 2,000,000,007$。\n\n为了够到比最高的那头奶牛还要高的书架顶，奶牛们不得不像演杂技一般，一头站在另一头的背上，叠成一座“奶牛塔”。当然，这个塔的高度，就是塔中所有奶牛的身高之和。为了往书架顶上放东西，所有奶牛的身高和必须不小于书架的高度。\n\n显然，塔中的奶牛数目越多，整座塔就越不稳定，于是奶牛们希望在能够到书架顶的前提下，让塔中奶牛的数目尽量少。现在，奶牛们找到了你，希望你帮她们计算这个最小的数目。", "inputFormat": "* 第 $1$ 行：2 个用空格隔开的整数：$N$ 和 $B$；\n* 第 $2\\dots N+1$ 行：第 $i+1$ 行是 $1$ 个整数：$H_i$。", "outputFormat": "* 第 $1$ 行：输出 $1$ 个整数，即最少要多少头奶牛叠成塔，才能够到书架顶部。", "hint": "输入说明：\n\n一共有 $6$ 头奶牛，书架的高度为 $40$，奶牛们的身高在 $6\\dots19$ 之间。\n\n\n输出说明：\n\n一种只用 $3$ 头奶牛就达到高度 $40$ 的方法：$18+11+13$。当然还有其他方法，在此不一一列出了。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO07DEC] Bookshelf B", "background": "", "description": "Farmer John recently added a huge bookshelf to the cows' library. Even though it is very large, it was almost instantly filled with all kinds of books. Now, only a little space remains at the very top of the shelf.\n\nAll $N(1 \\le N \\le 20,000)$ cows each have a fixed height $H_i(1 \\le H_i \\le 10,000)$. Let the sum of all cows' heights be $S$. The bookshelf has height $B$, and it is guaranteed that $1 \\le B \\le S < 2,000,000,007$.\n\nTo reach the top of the bookshelf, which is higher than the tallest cow, the cows have to perform an acrobatic act by standing on each other's backs, forming a \"cow tower.\" The height of the tower is the sum of the heights of all cows in it. To place items on the top of the bookshelf, the total height of the cows must be at least the height of the bookshelf.\n\nObviously, the more cows in the tower, the less stable it becomes. Therefore, the cows want to use as few cows as possible while still being able to reach the top of the bookshelf. They ask you to compute this minimum number.", "inputFormat": "- Line $1$: Two integers separated by a space: $N$ and $B$.\n- Lines $2\\dots N+1$: Line $i+1$ contains $1$ integer: $H_i$.", "outputFormat": "- Line $1$: Output $1$ integer — the minimum number of cows needed to stack into a tower to reach the top of the bookshelf.", "hint": "Input description:\n\nThere are $6$ cows, the bookshelf height is $40$, and the cows’ heights are between $6\\dots19$.\n\nOutput description:\n\nOne way to reach height $40$ using only $3$ cows: $18+11+13$. Of course, there are other ways, which are not listed here.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO07DEC] Bookshelf B", "background": null, "description": "Farmer John 最近为奶牛们的图书馆添置了一个巨大的书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。\n\n所有 $N(1 \\le N \\le 20,000)$ 头奶牛都有一个确定的身高 $H_i(1 \\le H_i \\le 10,000)$。设所有奶牛身高的和为 $S$。书架的高度为 $B$，并且保证 $1 \\le B \\le S < 2,000,000,007$。\n\n为了够到比最高的那头奶牛还要高的书架顶，奶牛们不得不像演杂技一般，一头站在另一头的背上，叠成一座“奶牛塔”。当然，这个塔的高度，就是塔中所有奶牛的身高之和。为了往书架顶上放东西，所有奶牛的身高和必须不小于书架的高度。\n\n显然，塔中的奶牛数目越多，整座塔就越不稳定，于是奶牛们希望在能够到书架顶的前提下，让塔中奶牛的数目尽量少。现在，奶牛们找到了你，希望你帮她们计算这个最小的数目。", "inputFormat": "* 第 $1$ 行：2 个用空格隔开的整数：$N$ 和 $B$；\n* 第 $2\\dots N+1$ 行：第 $i+1$ 行是 $1$ 个整数：$H_i$。", "outputFormat": "* 第 $1$ 行：输出 $1$ 个整数，即最少要多少头奶牛叠成塔，才能够到书架顶部。", "hint": "输入说明：\n\n一共有 $6$ 头奶牛，书架的高度为 $40$，奶牛们的身高在 $6\\dots19$ 之间。\n\n\n输出说明：\n\n一种只用 $3$ 头奶牛就达到高度 $40$ 的方法：$18+11+13$。当然还有其他方法，在此不一一列出了。", "locale": "zh-CN"}}}
{"pid": "P2677", "type": "P", "difficulty": 2, "samples": [["5 16\n3\n1\n3\n5\n6", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "2007", "USACO"], "title": "[USACO07DEC] Bookshelf 2 B", "background": null, "description": "Farmer John 最近为奶牛们的图书馆添置了一个巨大的书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。所有 $N(1\\le N\\le20)$ 头奶牛都有一个确定的身高 $H_i(1\\le H_i\\le1,000,000$（好高的奶牛 >_<）$)$。设所有奶牛身高的和为 $S$。书架的高度为 $B$，并且保证 $1\\le B\\le S$。为了够到比最高的那头奶牛还要高的书架顶，奶牛们不得不象演杂技一般，一头站在另一头的背上，叠成一座“奶牛塔”。当然，这个塔的高度，就是塔中所有奶牛的身高之和。为了往书架顶上放东西，所有奶牛的身高和必须不小于书架的高度。塔叠得越高便越不稳定，于是奶牛们希望找到一种方案，使得叠出的塔在高度不小于书架高度的情况下，高度尽可能小。你也可以猜到你的任务了：写一个程序，计算奶牛们叠成的塔在满足要求的情况下，最少要比书架高多少。", "inputFormat": "第 $1$ 行：$2$ 个用空格隔开的整数：$N$ 和 $B$。\n\n第 $2 \\sim N+1$ 行：第 $i+1$ 行是 $1$ 个整数：$H_i$。", "outputFormat": "第 $1$ 行: 输出 $1$ 个非负整数，即奶牛们叠成的塔最少比书架高的高度。", "hint": "输出说明：\n\n我们选用奶牛 $1$、$3$、$4$、$5$ 叠成塔，她们的总高度为 $3+3+5+6=17$。任何方案都无法叠出高度为 $16$ 的塔，于是答案为 $1$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO07DEC] Bookshelf 2 B", "background": "", "description": "Farmer John recently added a huge bookshelf to the cows' library. Although it is very large, it was almost instantly filled with all kinds of books. Now, only a bit of space remains at the top of the shelf. All $N$ cows ($1 \\le N \\le 20$) each have a fixed height $H_i$ ($1 \\le H_i \\le 1{,}000{,}000$) (such tall cows >_<). Let the sum of all cow heights be $S$. The shelf height is $B$, and it is guaranteed that $1 \\le B \\le S$.\n\nTo reach the top of the shelf, which is higher than the tallest cow, the cows have to perform acrobatics: one stands on another's back, forming a “cow tower.” The height of the tower is the sum of the heights of the cows in it. To place items on the top of the shelf, the sum of the heights of the cows in the tower must be at least the shelf height.\n\nThe taller the tower, the more unstable it becomes, so the cows want to find a plan such that, among all towers with height at least $B$, the height is as small as possible. Your task is to write a program to compute, under this requirement, how much taller than the shelf the tower must be, minimized.", "inputFormat": "Line $1$: Two space-separated integers: $N$ and $B$.\n\nLines $2$ to $N+1$: Line $i+1$ contains a single integer $H_i$.", "outputFormat": "Line $1$: Output a non-negative integer, the minimal amount by which the tower’s height exceeds the shelf height.", "hint": "We choose cows $1$, $3$, $4$, and $5$ to form a tower; their total height is $3+3+5+6=17$. No arrangement can form a tower of height $16$, so the answer is $1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO07DEC] Bookshelf 2 B", "background": null, "description": "Farmer John 最近为奶牛们的图书馆添置了一个巨大的书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。所有 $N(1\\le N\\le20)$ 头奶牛都有一个确定的身高 $H_i(1\\le H_i\\le1,000,000$（好高的奶牛 >_<）$)$。设所有奶牛身高的和为 $S$。书架的高度为 $B$，并且保证 $1\\le B\\le S$。为了够到比最高的那头奶牛还要高的书架顶，奶牛们不得不象演杂技一般，一头站在另一头的背上，叠成一座“奶牛塔”。当然，这个塔的高度，就是塔中所有奶牛的身高之和。为了往书架顶上放东西，所有奶牛的身高和必须不小于书架的高度。塔叠得越高便越不稳定，于是奶牛们希望找到一种方案，使得叠出的塔在高度不小于书架高度的情况下，高度尽可能小。你也可以猜到你的任务了：写一个程序，计算奶牛们叠成的塔在满足要求的情况下，最少要比书架高多少。", "inputFormat": "第 $1$ 行：$2$ 个用空格隔开的整数：$N$ 和 $B$。\n\n第 $2 \\sim N+1$ 行：第 $i+1$ 行是 $1$ 个整数：$H_i$。", "outputFormat": "第 $1$ 行: 输出 $1$ 个非负整数，即奶牛们叠成的塔最少比书架高的高度。", "hint": "输出说明：\n\n我们选用奶牛 $1$、$3$、$4$、$5$ 叠成塔，她们的总高度为 $3+3+5+6=17$。任何方案都无法叠出高度为 $16$ 的塔，于是答案为 $1$。", "locale": "zh-CN"}}}
{"pid": "P2678", "type": "P", "difficulty": 3, "samples": [["25 5 2 \n2\n11\n14\n17 \n21", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["贪心", "2015", "二分", "NOIP 提高组"], "title": "[NOIP 2015 提高组] 跳石头", "background": "NOIP2015 Day2T1", "description": "一年一度的“跳石头”比赛又要开始了！\n\n这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。\n\n为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。", "inputFormat": "第一行包含三个整数 $L,N,M$，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 $L \\geq 1$ 且 $N \\geq M \\geq 0$。\n\n接下来 $N$ 行，每行一个整数，第 $i$ 行的整数 $D_i\\,( 0 < D_i < L)$， 表示第 $i$ 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。", "outputFormat": "一个整数，即最短跳跃距离的最大值。", "hint": "### 输入输出样例 1 说明\n\n将与起点距离为 $2$ 和 $14$ 的两个岩石移走后，最短的跳跃距离为 $4$（从与起点距离 $17$ 的岩石跳到距离 $21$ 的岩石，或者从距离 $21$ 的岩石跳到终点）。\n\n### 数据规模与约定\n\n对于 $20\\%$的数据，$0 \\le M \\le N \\le 10$。    \n对于 $50\\%$ 的数据，$0 \\le M \\le N \\le 100$。  \n对于 $100\\%$ 的数据，$0 \\le M \\le N \\le 50000,1 \\le L \n \\le 10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2015 Senior] Jumping Stones", "background": "NOIP 2015 Day 2 T1.", "description": "The annual \"Jumping Stones\" competition is about to begin.\n\nThe competition takes place in a straight river channel where some huge rocks are distributed. The organizing committee has chosen two rocks as the start and the finish. Between the start and the finish, there are $N$ rocks (excluding the start and finish rocks). During the competition, participants start from the start rock and jump to an adjacent rock at each step until they reach the finish.\n\nTo increase the difficulty, the committee plans to remove some rocks so that the minimum jump distance during the competition is as large as possible. Due to budget limits, the committee can remove at most $M$ rocks between the start and the finish (the start and finish rocks cannot be removed).", "inputFormat": "The first line contains three integers $L, N, M$, representing the distance from the start to the finish, the number of rocks between the start and the finish, and the maximum number of rocks the committee may remove, respectively. It is guaranteed that $L \\geq 1$ and $N \\geq M \\geq 0$.\n\nThe next $N$ lines each contain one integer. On the $i$-th line, the integer $D_i\\,(0 < D_i < L)$ denotes the distance from the start to the $i$-th rock. These rocks are given in increasing order of distance from the start, and no two rocks are at the same position.", "outputFormat": "Output a single integer, which is the maximum possible minimum jump distance.", "hint": "### Explanation for Sample Input/Output 1\n\nAfter removing the two rocks at distances $2$ and $14$ from the start, the minimum jump distance becomes $4$ (either when jumping from the rock at distance $17$ to the rock at distance $21$, or from the rock at distance $21$ to the finish).\n\n### Constraints\n\n- For $20\\%$ of the testdata, $0 \\le M \\le N \\le 10$.\n- For $50\\%$ of the testdata, $0 \\le M \\le N \\le 100$.\n- For $100\\%$ of the testdata, $0 \\le M \\le N \\le 50000$, $1 \\le L \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2015 提高组] 跳石头", "background": "NOIP2015 Day2T1", "description": "一年一度的“跳石头”比赛又要开始了！\n\n这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。\n\n为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。", "inputFormat": "第一行包含三个整数 $L,N,M$，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 $L \\geq 1$ 且 $N \\geq M \\geq 0$。\n\n接下来 $N$ 行，每行一个整数，第 $i$ 行的整数 $D_i\\,( 0 < D_i < L)$， 表示第 $i$ 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。", "outputFormat": "一个整数，即最短跳跃距离的最大值。", "hint": "### 输入输出样例 1 说明\n\n将与起点距离为 $2$ 和 $14$ 的两个岩石移走后，最短的跳跃距离为 $4$（从与起点距离 $17$ 的岩石跳到距离 $21$ 的岩石，或者从距离 $21$ 的岩石跳到终点）。\n\n### 数据规模与约定\n\n对于 $20\\%$的数据，$0 \\le M \\le N \\le 10$。    \n对于 $50\\%$ 的数据，$0 \\le M \\le N \\le 100$。  \n对于 $100\\%$ 的数据，$0 \\le M \\le N \\le 50000,1 \\le L \n \\le 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P2679", "type": "P", "difficulty": 4, "samples": [["6 3 1 \naabaab \naab", "2"], ["6 3 2 \naabaab \naab", "7"], ["6 3 3 \naabaab \naab", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "2015", "NOIP 提高组", "O2优化", "枚举"], "title": "[NOIP 2015 提高组] 子串", "background": "NOIP2015 Day2T2", "description": "有两个仅包含小写英文字母的字符串 $A$ 和 $B$。\n\n现在要从字符串 $A$ 中取出 $k$ 个互不重叠的非空子串，然后把这 $k$ 个子串按照其在字符串 $A$ 中出现的顺序依次连接起来得到一个新的字符串。请问有多少种方案可以使得这个新串与字符串 $B$ 相等？\n\n注意：子串取出的位置不同也认为是不同的方案。", "inputFormat": "第一行是三个正整数 $n,m,k$，分别表示字符串 $A$ 的长度，字符串 $B$ 的长度，以及问题描述中所提到的 $k$，每两个整数之间用一个空格隔开。\n\n第二行包含一个长度为 $n$ 的字符串，表示字符串 $A$。\n\n第三行包含一个长度为 $m$ 的字符串，表示字符串 $B$。", "outputFormat": "一个整数，表示所求方案数。\n\n由于答案可能很大，所以这里要求输出答案对 $1000000007(10^9 + 7)$ 取模的结果。", "hint": "**样例解释**\n\n所有合法方案如下：（加下划线的部分表示取出的字串）\n\n样例 $1$：$\\texttt{\\underline{aab}\\,aab,aab\\,\\underline{aab}}$。  \n样例 $2$：$\\texttt{\\underline{a}\\,\\underline{ab}\\,aab,\\underline{a}\\,aba\\,\\underline{ab},a\\,\\underline{a}\\,ba\\,\\underline{ab},aab\\,\\underline{a}\\,\\underline{ab},\\underline{aa}\\,\\underline{b}\\,aab,\\underline{aa}\\,baa\\,\\underline{b},aab\\,\\underline{aa}\\,\\underline{b}}$。  \n样例 $3$：$\\texttt{\\underline{a}\\,\\underline{a}\\,\\underline{b}\\,aab,\\underline{a}\\,\\underline{a}\\,baa\\,\\underline{b},\\underline{a}\\,ab\\,\\underline{a}\\,a\\,\\underline{b},\\underline{a}\\,aba\\,\\underline{a}\\,\\underline{b},a\\,\\underline{a}\\,b\\,\\underline{a}\\,a\\,\\underline{b},a\\,\\underline{a}\\,ba\\,\\underline{a}\\,\\underline{b},aab\\,\\underline{a}\\,\\underline{a}\\,\\underline{b}}$。\n\n**数据范围**\n\n对于第 $1$ 组数据：$1\\le n\\le 500,1\\le m\\le 50,k=1$;  \n对于第 $2$ 组至第 $3$ 组数据：$1\\le n\\le 500,1\\le m\\le 50,k=2$;  \n对于第 $4$ 组至第 $5$ 组数据：$1\\le n\\le 500,1\\le m\\le 50,k=m$;   \n对于第 $1$ 组至第 $7$ 组数据：$\\le n\\le 500,1\\le m\\le 50,1\\le k\\le m$;  \n对于第 $1$ 组至第 $9$ 组数据：$1\\le n\\le 1000,1\\le m\\le 100,1\\le k\\le m$;   \n对于所有 $10$ 组数据：$1\\le n\\le 1000,1\\le m\\le 200,1\\le k\\le m$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2015 Senior] Substring", "background": "NOIP 2015 Day2T2.", "description": "There are two strings $A$ and $B$ consisting only of lowercase English letters.\n\nWe will select $k$ pairwise non-overlapping, non-empty substrings from string $A$, then concatenate these $k$ substrings in the order they appear in $A$ to obtain a new string. How many ways are there to make this new string equal to string $B$?\n\nNote: Different selection positions are considered different ways.", "inputFormat": "The first line contains three positive integers $n, m, k$, representing the length of string $A$, the length of string $B$, and the $k$ mentioned in the problem statement, respectively. Each pair of integers is separated by a single space.\n\nThe second line contains a string of length $n$, which is string $A$.\n\nThe third line contains a string of length $m$, which is string $B$.", "outputFormat": "Output a single integer, the number of required ways.\n\nSince the answer may be large, output the result modulo $1000000007$.", "hint": "**Sample Explanation**\n\nAll valid ways are as follows (the underlined parts indicate the selected substrings):\n\nSample 1: $\\texttt{\\underline{aab}\\,aab,aab\\,\\underline{aab}}$.\n\nSample 2: $\\texttt{\\underline{a}\\,\\underline{ab}\\,aab,\\underline{a}\\,aba\\,\\underline{ab},a\\,\\underline{a}\\,ba\\,\\underline{ab},aab\\,\\underline{a}\\,\\underline{ab},\\underline{aa}\\,\\underline{b}\\,aab,\\underline{aa}\\,baa\\,\\underline{b},aab\\,\\underline{aa}\\,\\underline{b}}$.\n\nSample 3: $\\texttt{\\underline{a}\\,\\underline{a}\\,\\underline{b}\\,aab,\\underline{a}\\,\\underline{a}\\,baa\\,\\underline{b},\\underline{a}\\,ab\\,\\underline{a}\\,a\\,\\underline{b},\\underline{a}\\,aba\\,\\underline{a}\\,\\underline{b},a\\,\\underline{a}\\,b\\,\\underline{a}\\,a\\,\\underline{b},a\\,\\underline{a}\\,ba\\,\\underline{a}\\,\\underline{b},aab\\,\\underline{a}\\,\\underline{a}\\,\\underline{b}}$.\n\n**Constraints**\n\nFor testdata 1: $1 \\le n \\le 500, 1 \\le m \\le 50, k = 1$;\n\nFor testdata 2 to 3: $1 \\le n \\le 500, 1 \\le m \\le 50, k = 2$;\n\nFor testdata 4 to 5: $1 \\le n \\le 500, 1 \\le m \\le 50, k = m$;\n\nFor testdata 1 to 7: $1 \\le n \\le 500, 1 \\le m \\le 50, 1 \\le k \\le m$;\n\nFor testdata 1 to 9: $1 \\le n \\le 1000, 1 \\le m \\le 100, 1 \\le k \\le m$;\n\nFor all 10 testdata sets: $1 \\le n \\le 1000, 1 \\le m \\le 200, 1 \\le k \\le m$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2015 提高组] 子串", "background": "NOIP2015 Day2T2", "description": "有两个仅包含小写英文字母的字符串 $A$ 和 $B$。\n\n现在要从字符串 $A$ 中取出 $k$ 个互不重叠的非空子串，然后把这 $k$ 个子串按照其在字符串 $A$ 中出现的顺序依次连接起来得到一个新的字符串。请问有多少种方案可以使得这个新串与字符串 $B$ 相等？\n\n注意：子串取出的位置不同也认为是不同的方案。", "inputFormat": "第一行是三个正整数 $n,m,k$，分别表示字符串 $A$ 的长度，字符串 $B$ 的长度，以及问题描述中所提到的 $k$，每两个整数之间用一个空格隔开。\n\n第二行包含一个长度为 $n$ 的字符串，表示字符串 $A$。\n\n第三行包含一个长度为 $m$ 的字符串，表示字符串 $B$。", "outputFormat": "一个整数，表示所求方案数。\n\n由于答案可能很大，所以这里要求输出答案对 $1000000007(10^9 + 7)$ 取模的结果。", "hint": "**样例解释**\n\n所有合法方案如下：（加下划线的部分表示取出的字串）\n\n样例 $1$：$\\texttt{\\underline{aab}\\,aab,aab\\,\\underline{aab}}$。  \n样例 $2$：$\\texttt{\\underline{a}\\,\\underline{ab}\\,aab,\\underline{a}\\,aba\\,\\underline{ab},a\\,\\underline{a}\\,ba\\,\\underline{ab},aab\\,\\underline{a}\\,\\underline{ab},\\underline{aa}\\,\\underline{b}\\,aab,\\underline{aa}\\,baa\\,\\underline{b},aab\\,\\underline{aa}\\,\\underline{b}}$。  \n样例 $3$：$\\texttt{\\underline{a}\\,\\underline{a}\\,\\underline{b}\\,aab,\\underline{a}\\,\\underline{a}\\,baa\\,\\underline{b},\\underline{a}\\,ab\\,\\underline{a}\\,a\\,\\underline{b},\\underline{a}\\,aba\\,\\underline{a}\\,\\underline{b},a\\,\\underline{a}\\,b\\,\\underline{a}\\,a\\,\\underline{b},a\\,\\underline{a}\\,ba\\,\\underline{a}\\,\\underline{b},aab\\,\\underline{a}\\,\\underline{a}\\,\\underline{b}}$。\n\n**数据范围**\n\n对于第 $1$ 组数据：$1\\le n\\le 500,1\\le m\\le 50,k=1$;  \n对于第 $2$ 组至第 $3$ 组数据：$1\\le n\\le 500,1\\le m\\le 50,k=2$;  \n对于第 $4$ 组至第 $5$ 组数据：$1\\le n\\le 500,1\\le m\\le 50,k=m$;   \n对于第 $1$ 组至第 $7$ 组数据：$\\le n\\le 500,1\\le m\\le 50,1\\le k\\le m$;  \n对于第 $1$ 组至第 $9$ 组数据：$1\\le n\\le 1000,1\\le m\\le 100,1\\le k\\le m$;   \n对于所有 $10$ 组数据：$1\\le n\\le 1000,1\\le m\\le 200,1\\le k\\le m$。", "locale": "zh-CN"}}}
{"pid": "P2680", "type": "P", "difficulty": 5, "samples": [["6 3 \n1 2 3 \n1 6 4 \n3 1 7 \n4 3 6 \n3 5 5 \n3 6 \n2 5 \n4 5", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["图论", "2015", "二分", "NOIP 提高组", "最近公共祖先 LCA", "树链剖分", "差分"], "title": "[NOIP 2015 提高组] 运输计划", "background": "NOIP2015 Day2T3", "description": "公元 $2044$ 年，人类进入了宇宙纪元。\n\nL 国有 $n$ 个星球，还有 $n-1$ 条双向航道，每条航道建立在两个星球之间，这 $n-1$ 条航道连通了 L 国的所有星球。\n\n小 P 掌管一家物流公司， 该公司有很多个运输计划，每个运输计划形如：有一艘物流飞船需要从 $u_i$ 号星球沿最快的宇航路径飞行到 $v_i$ 号星球去。显然，飞船驶过一条航道是需要时间的，对于航道 $j$，任意飞船驶过它所花费的时间为 $t_j$，并且任意两艘飞船之间不会产生任何干扰。\n\n为了鼓励科技创新， L 国国王同意小 P 的物流公司参与 L 国的航道建设，即允许小 P 把某一条航道改造成虫洞，飞船驶过虫洞不消耗时间。\n\n在虫洞的建设完成前小 P 的物流公司就预接了 $m$ 个运输计划。在虫洞建设完成后，这 $m$ 个运输计划会同时开始，所有飞船一起出发。当这 $m$ 个运输计划都完成时，小 P 的物流公司的阶段性工作就完成了。\n\n如果小 P 可以自由选择将哪一条航道改造成虫洞， 试求出小 P 的物流公司完成阶段性工作所需要的最短时间是多少？", "inputFormat": "第一行包括两个正整数 $n, m$，表示 L 国中星球的数量及小 P 公司预接的运输计划的数量，星球从 $1$ 到 $n$ 编号。\n\n接下来 $n-1$ 行描述航道的建设情况，其中第 $i$ 行包含三个整数 $a_i, b_i$ 和 $t_i$，表示第 $i$ 条双向航道修建在 $a_i$ 与 $b_i$ 两个星球之间，任意飞船驶过它所花费的时间为 $t_i$。  \n\n接下来 $m$ 行描述运输计划的情况，其中第 $j$ 行包含两个正整数 $u_j$ 和 $v_j$，表示第 $j$ 个运输计划是从 $u_j$ 号星球飞往 $v_j$ 号星球。", "outputFormat": "一个整数，表示小 P 的物流公司完成阶段性工作所需要的最短时间。", "hint": "所有测试数据的范围和特点如下表所示\n\n| 测试点编号 | $n = $ | $m = $ | 约定 | \n| :-: | :-: | :-: | :-: |\n| 1 | $100$ | $1$ | |\n| 2 | ^ | $100$ | 第 $i$ 条航道连接 $i$ 号星球与 $i + 1$ 号星球 |\n| 3 | ^ | ^ | |\n| 4 | $2000$ | $1$ | ^ |\n| 5 | $1000$ | $1000$ | 第 $i$ 条航道连接 $i$ 号星球与 $i + 1$ 号星球 | \n| 6 | $2000$ | $2000$ | ^ |\n| 7 | $3000$ | $3000$ | ^ |\n| 8 | $1000$ | $1000$ | |\n| 9 | $2000$ | $2000$ | ^ |\n| 10 | $3000$ | $3000$ | ^ |\n| 11 | $80000$ | $1$ | ^ |\n| 12 | $100000$ | ^ | ^ |\n| 13 | $70000$ | $70000$ | 第 $i$ 条航道连接 $i$ 号星球与 $i + 1$ 号星球 |\n| 14 | $80000$ | $80000$ |^ |\n| 15 | $90000$ | $90000$ | ^ |\n| 16 | $100000$ | $100000$ | ^ |\n| 17 | $80000$ | $80000$ | |\n| 18 | $90000$ | $90000$ | ^ |\n| 19 | $100000$ | $100000$ | ^ |\n| 20 | $300000$ | $300000$ | ^ |\n| 所有数据 | | | $1 \\le a _ i, b _ i, u _ j, v _ j \\le n$，$0 \\le t _ i \\le 1000$ |\n\n**请注意常数因子带来的程序效率上的影响。**", "locale": "zh-CN", "translations": {"en": {"title": "[NOIP 2015 Senior] Transportation Plan", "background": "NOIP 2015 Day 2 T3.", "description": "In the year $2044$, humanity entered the cosmic era.\n\nCountry L has $n$ planets and $n-1$ bidirectional routes. Each route is built between two planets, and these $n-1$ routes connect all the planets in Country L.\n\nXiao P runs a logistics company that has many transportation plans. Each plan is as follows: a cargo spaceship needs to travel from planet $u_i$ to planet $v_i$ along the fastest space route. Obviously, traversing a route takes time. For route $j$, any spaceship takes time $t_j$ to traverse it, and any two spaceships do not interfere with each other.\n\nTo encourage technological innovation, the king of Country L allows Xiao P’s logistics company to participate in route construction, that is, to transform one route into a wormhole. Traversing the wormhole takes no time.\n\nBefore the wormhole is completed, Xiao P’s company has already pre-booked $m$ transportation plans. After the wormhole is completed, these $m$ plans will start simultaneously, and all spaceships depart together. When all $m$ plans are completed, Xiao P’s company finishes this phase of work.\n\nIf Xiao P can freely choose which route to convert into a wormhole, find the minimum time required for the company to complete this phase of work.", "inputFormat": "The first line contains two positive integers $n, m$, representing the number of planets in Country L and the number of transportation plans pre-booked by Xiao P’s company. Planets are numbered from $1$ to $n$.\n\nThe next $n-1$ lines describe the construction of the routes. The $i$-th line contains three integers $a_i, b_i$, and $t_i$, indicating that the $i$-th bidirectional route is built between planets $a_i$ and $b_i$, and any spaceship takes time $t_i$ to traverse it.  \n\nThe next $m$ lines describe the transportation plans. The $j$-th line contains two positive integers $u_j$ and $v_j$, indicating that the $j$-th plan is to travel from planet $u_j$ to planet $v_j$.", "outputFormat": "Output one integer, the minimum time required for Xiao P’s logistics company to complete this phase of work.", "hint": "The Constraints and characteristics of all testdata are shown in the table below.\n\n| Test point ID | $n = $ | $m = $ | Convention | \n| :-: | :-: | :-: | :-: |\n| 1 | $100$ | $1$ | |\n| 2 | ^ | $100$ | The $i$-th route connects planet $i$ and planet $i + 1$. |\n| 3 | ^ | ^ | |\n| 4 | $2000$ | $1$ | ^ |\n| 5 | $1000$ | $1000$ | The $i$-th route connects planet $i$ and planet $i + 1$. | \n| 6 | $2000$ | $2000$ | ^ |\n| 7 | $3000$ | $3000$ | ^ |\n| 8 | $1000$ | $1000$ | |\n| 9 | $2000$ | $2000$ | ^ |\n| 10 | $3000$ | $3000$ | ^ |\n| 11 | $80000$ | $1$ | ^ |\n| 12 | $100000$ | ^ | ^ |\n| 13 | $70000$ | $70000$ | The $i$-th route connects planet $i$ and planet $i + 1$. |\n| 14 | $80000$ | $80000$ | ^ |\n| 15 | $90000$ | $90000$ | ^ |\n| 16 | $100000$ | $100000$ | ^ |\n| 17 | $80000$ | $80000$ | |\n| 18 | $90000$ | $90000$ | ^ |\n| 19 | $100000$ | $100000$ | ^ |\n| 20 | $300000$ | $300000$ | ^ |\n| All testdata | | | $1 \\le a _ i, b _ i, u _ j, v _ j \\le n$，$0 \\le t _ i \\le 1000$ |\n\nPlease pay attention to the impact of constant factors on program efficiency.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOIP 2015 提高组] 运输计划", "background": "NOIP2015 Day2T3", "description": "公元 $2044$ 年，人类进入了宇宙纪元。\n\nL 国有 $n$ 个星球，还有 $n-1$ 条双向航道，每条航道建立在两个星球之间，这 $n-1$ 条航道连通了 L 国的所有星球。\n\n小 P 掌管一家物流公司， 该公司有很多个运输计划，每个运输计划形如：有一艘物流飞船需要从 $u_i$ 号星球沿最快的宇航路径飞行到 $v_i$ 号星球去。显然，飞船驶过一条航道是需要时间的，对于航道 $j$，任意飞船驶过它所花费的时间为 $t_j$，并且任意两艘飞船之间不会产生任何干扰。\n\n为了鼓励科技创新， L 国国王同意小 P 的物流公司参与 L 国的航道建设，即允许小 P 把某一条航道改造成虫洞，飞船驶过虫洞不消耗时间。\n\n在虫洞的建设完成前小 P 的物流公司就预接了 $m$ 个运输计划。在虫洞建设完成后，这 $m$ 个运输计划会同时开始，所有飞船一起出发。当这 $m$ 个运输计划都完成时，小 P 的物流公司的阶段性工作就完成了。\n\n如果小 P 可以自由选择将哪一条航道改造成虫洞， 试求出小 P 的物流公司完成阶段性工作所需要的最短时间是多少？", "inputFormat": "第一行包括两个正整数 $n, m$，表示 L 国中星球的数量及小 P 公司预接的运输计划的数量，星球从 $1$ 到 $n$ 编号。\n\n接下来 $n-1$ 行描述航道的建设情况，其中第 $i$ 行包含三个整数 $a_i, b_i$ 和 $t_i$，表示第 $i$ 条双向航道修建在 $a_i$ 与 $b_i$ 两个星球之间，任意飞船驶过它所花费的时间为 $t_i$。  \n\n接下来 $m$ 行描述运输计划的情况，其中第 $j$ 行包含两个正整数 $u_j$ 和 $v_j$，表示第 $j$ 个运输计划是从 $u_j$ 号星球飞往 $v_j$ 号星球。", "outputFormat": "一个整数，表示小 P 的物流公司完成阶段性工作所需要的最短时间。", "hint": "所有测试数据的范围和特点如下表所示\n\n| 测试点编号 | $n = $ | $m = $ | 约定 | \n| :-: | :-: | :-: | :-: |\n| 1 | $100$ | $1$ | |\n| 2 | ^ | $100$ | 第 $i$ 条航道连接 $i$ 号星球与 $i + 1$ 号星球 |\n| 3 | ^ | ^ | |\n| 4 | $2000$ | $1$ | ^ |\n| 5 | $1000$ | $1000$ | 第 $i$ 条航道连接 $i$ 号星球与 $i + 1$ 号星球 | \n| 6 | $2000$ | $2000$ | ^ |\n| 7 | $3000$ | $3000$ | ^ |\n| 8 | $1000$ | $1000$ | |\n| 9 | $2000$ | $2000$ | ^ |\n| 10 | $3000$ | $3000$ | ^ |\n| 11 | $80000$ | $1$ | ^ |\n| 12 | $100000$ | ^ | ^ |\n| 13 | $70000$ | $70000$ | 第 $i$ 条航道连接 $i$ 号星球与 $i + 1$ 号星球 |\n| 14 | $80000$ | $80000$ |^ |\n| 15 | $90000$ | $90000$ | ^ |\n| 16 | $100000$ | $100000$ | ^ |\n| 17 | $80000$ | $80000$ | |\n| 18 | $90000$ | $90000$ | ^ |\n| 19 | $100000$ | $100000$ | ^ |\n| 20 | $300000$ | $300000$ | ^ |\n| 所有数据 | | | $1 \\le a _ i, b _ i, u _ j, v _ j \\le n$，$0 \\le t _ i \\le 1000$ |\n\n**请注意常数因子带来的程序效率上的影响。**", "locale": "zh-CN"}}}
{"pid": "P2681", "type": "P", "difficulty": 2, "samples": [["5 3\n1 1 2 2 1\n0 1 4\n1 2 3\n0 1 4", "1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "2016", "洛谷原创", "洛谷月赛"], "title": "众数", "background": "Alice 和 Bob 玩游戏。\n\n", "description": "Alice 现在有一个序列 $a_1,a_2,...a_n$。\n\n现在她需要 Bob 支持询问一个区间内的众数,还要支持修改一个位置的 $a_i$。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数，表示 $a_1,...,a_n$。\n\n接下来 $m$ 行，每行三个整数 $flag,x,y$。\n\n如果 $flag=0$，表示询问 $\\big[x,y\\big]$ 区间内的众数，如果有多个输出较小的。\n\n如果 $flag=1$，表示将 $a_x$ 改为 $y$。", "outputFormat": "对于每个 $flag=0$ 的询问，每行输出一个整数表示答案。", "hint": "对于 $100\\%$ 的数据 $n,m \\le 1000$。\n\n对于查询操作满足 $x\\le y$。\n\n任意时刻 $0<a_i\\le 10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "Mode", "background": "Alice and Bob are playing a game.", "description": "Alice has a sequence $a_1,a_2,...a_n$. Now she needs Bob to support querying the mode within a range, and also support modifying a position $a_i$.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe second line contains $n$ integers, representing $a_1,...,a_n$.\n\nThe next $m$ lines each contain three integers $flag, x, y$.\n\nIf $flag=0$, it queries the mode in the range $\\big[x,y\\big]$. If there are multiple, output the smaller one.\n\nIf $flag=1$, it sets $a_x$ to $y$.", "outputFormat": "For each query with $flag=0$, output one integer per line representing the answer.", "hint": "For 100% of the testdata, $n, m \\le 1000$.\n\nFor all query operations, $x \\le y$.\n\nAt any time $0 < a_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "众数", "background": "Alice 和 Bob 玩游戏。\n\n", "description": "Alice 现在有一个序列 $a_1,a_2,...a_n$。\n\n现在她需要 Bob 支持询问一个区间内的众数,还要支持修改一个位置的 $a_i$。", "inputFormat": "第一行两个整数 $n,m$。\n\n第二行 $n$ 个整数，表示 $a_1,...,a_n$。\n\n接下来 $m$ 行，每行三个整数 $flag,x,y$。\n\n如果 $flag=0$，表示询问 $\\big[x,y\\big]$ 区间内的众数，如果有多个输出较小的。\n\n如果 $flag=1$，表示将 $a_x$ 改为 $y$。", "outputFormat": "对于每个 $flag=0$ 的询问，每行输出一个整数表示答案。", "hint": "对于 $100\\%$ 的数据 $n,m \\le 1000$。\n\n对于查询操作满足 $x\\le y$。\n\n任意时刻 $0<a_i\\le 10^9$。", "locale": "zh-CN"}}}
{"pid": "P2682", "type": "P", "difficulty": 7, "samples": [["例：一个使用1*1的土豆田处理单元(下称处理单元)的A+B problem\n输入两个整数a,b,|a|,|b|<=10^9\n输出a+b\n\n1 1\n5\nin\nswap\nin\nadd tmp\nout\n", "解释：\n第一行的1 1表示用的处理单元为1*1\n第二行表示第一个处理单元有5条指令。\n第三行的命令在第一个周期执行，读入了一个数(假定为a) ，此时该单元的状态为key=0,tmp=a\n第四行在第二个周期执行，交换了key和tmp,状态为key=a,tmp=0\n第五行在第三个周期执行，读入了另一个数b，状态为key=a,tmp=b\n第六行在第四个周期执行，给key加上tmp，状态为key=a+b,tmp=b\n第七行在第五个周期执行，输出该单元的key，即输出了a+b"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["提交答案", "Special Judge"], "title": "土豆田", "background": "大宁在他家门口种了一大片土豆田，划分为 $n \\times m$ 的地块。\n\n大宁准备搭建学校的 OJ，为了测试土豆田的性能，大宁找到了你，为他的土豆编写代码。", "description": "大宁的土豆田是以地块为单位的，每个地块里的所有土豆的集合称为一个处理单元，可以储存两个值：key（键值）和 tmp（缓存值），均为 $32$ 位带符号整数，每个单元。可以执行若干命令。大宁会骑着自行车轮流给每个处理单元供电，顺序如图，展示的是一个被分割为 $4\\times 4$ 处理单元的土豆田：\n\n  ![](https://cdn.luogu.com.cn/upload/pic/12313.png) \n\n单元的编号就是供电的顺序，每次按编号顺序从 $1$ 号到 $n\\times m$ 号遍历一遍。\n\n每一次完整的遍历称为一个周期。\n\n只有一块地上的土豆得到供电，它们才会工作，执行命令，所有命令执行完之后大宁会停止供电。\n\n对于每一个处理单元，命令格式如下：\n\n1. `in` 读取一个数，存放到该单元的 $\\text{tmp}$ 中。（如果 $\\text{tmp}$ 中有数，那么覆盖掉，以下的所有存放均如此）\n\n1. `out` 输出当前处理单元的 $\\text{key}$ 值。\n\n1. `swap` 交换该单元的 $\\text{key}$ 和 $\\text{tmp}$。\n\n1. `add X` 给 $\\text{key}$ 值加上 $X$，$X$ 只能是一个常数或者 $\\text{tmp}$，下同。\n\n1. `set X` 把 $\\text{key}$ 值修改为 $X$。\n\n1. `opp` 对 $\\text{key}$ 值取相反数。\n\n1. `rev` 对 $\\text{key}$ 值按位取反。\n\n1. `L/R X` 左/右移 $\\text{key}$ 值 $X$ 位。\n\n1. `get u/d/l/r` 将当前单元上(u)/下(d)/左(l)/右(r)面的单元的 $\\text{key}$ 值并把它复制到本单元的 $\\text{tmp}$，位置规则按照前面的图片所示。\n\n1. `or/and/xor X` 对 $\\text{key}$ 值按位或/与/异或 $X$。\n\n1. `wait` 在本次供电的时间中等待，即什么事情也不做。\n\n1. `if X` 如果此时 X(只能是 $\\text{key}$ 或者 $\\text{tmp}$ )不等于 $0$ 则在下一次供电执行该语句的下一条语句，否则跳过下一条语句，执行下下条(如果存在的话)。\n\n1. `goto Y`  下一次供电从第 $Y$ 号命令开始执行，$Y$ 只能是常数。\n\n1. `end` 强制结束所有的处理单元的命令，无视所有尚未执行的命令。\n\n我们提供了 check.exe,把你的土豆程序 potato.out 和你想测试的输入数据 potato.in 放到与 check.exe 同文件夹下，运行之后可以在 report.txt 中查看你的程序的详细运行情况。\n\n我们还提供了另一个样例土豆程序 example2.out,使用 $2\\times2$ 处理单元的土豆程序，内容为计算一个整数 $a$ 的 $10$ 倍,可以自行解读（该样例并非该计算的最优解，只是为了展示命令）。\n\n下面展示了一个 $1 \\times 3$ 的处理单元，所有单元不一定需要全部使用。\n\n![](https://cdn.luogu.com.cn/upload/pic/12314.png)\n\n你有以下任务需要用编写土豆程序完成：\n\n|编号|输入|输出|数据范围|处理单元大小限制|分数|补充说明|\n| :----------: | :----------: | :----------:| :----------:| :----------:|:----------: | :----------: |\n|$1$|$a\\text{，}b$|$b-a$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le10^9 $|$1 \\times 3$|$7$|无|\n|$2$|$a$|$233\\times a$|$1 \\le\\lvert a\\rvert \\le10^7 $|$2 \\times 2$|$9$|无|\n|$3$|$a$|$\\lvert a \\rvert$|$1 \\le\\lvert a\\rvert \\le10^9 $|$2 \\times 2$|$12$|求 $a$ 的绝对值|\n|$4$|$128$ 个整数 $a_i$|$\\sum^{128}_{i=1}a_i$|$1 \\le\\lvert a\\rvert \\le2 \\times 10^6 $|$4 \\times 2$|$12$|无|\n|$5$|$a\\text{，}b$|$\\lfloor \\frac{a+b}{2}\\rfloor$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le2.1\\times10^9 $|$2 \\times 2$|$13$|无|\n|$6$|$a$|$\\operatorname{popcount}(a)$|$\\lvert a\\rvert\\le10^9 $|$2 \\times 2$|$13$|$\\operatorname{popcount}(a)$表示 $a$ 在二进制表示下 $1$ 的个数|\n|$7$|$a\\text{，}b$|$\\max {(a,b)}$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le10^9 $|$2 \\times 2$|$14$|无|\n|$8$|$n$|$f(n)$|$1 \\le n \\le 42$|$3 \\times 3$|$20$|$f(n)=\\begin{cases}1 & n<2\\\\f(n-1)+f(n-2) & n\\ge 2\\end{cases}$|", "inputFormat": "本题为提交答案题。", "outputFormat": "第一行为 $n$ 和 $m$，表示你用了 $n$ 行 $m$ 列。\n\n接下来$n\\times m$个部分，第 $i$ 个部分的第一行 $t_i$ 表示在第 $i$ 个处理单元中命令的数量(可以为 $0$)，接下来 $t_i$ 行每行描述一个命令，见上文所述。", "hint": "#### 样例#1解释\n\n这个样例实现了 A+B problem。\n\n第一行的 `1 1` 表示用的处理单元为 $1\\times1$。\n\n第二行表示第一个处理单元有 $5$ 条指令。\n\n第三行的命令在第一个周期执行，读入了一个数(假定为 $a$) ，此时该单元的状态为 $\\text{key}= 0 \\text{，}\\text{tmp}= a$。\n\n第四行在第二个周期执行，交换了 $\\text{key}$ 和 $\\text{tmp}$，状态为 $\\text{key}= a \\text{，}\\text{tmp}= 0$。\n\n第五行在第三个周期执行，读入了另一个数 $b$，状态为 $\\text{key}= a \\text{，}\\text{tmp}= b$。\n\n第六行在第四个周期执行，给 $\\text{key}$ 加上 $\\text{tmp}$，状态为 $\\text{key}= a+b \\text{，}\\text{tmp}= b$。\n\n第七行在第五个周期执行，输出该单元的 $\\text{key}$，即输出了 $a+b$。\n\n\n如果你的程序在 $2000$ 个周期内没有运行完毕，或者有语法错误，或者超过处理单元尺寸限制，得 $0$ 分。\n\n如果你的第 $i$ 个任务的程序能得出正确的结果，并且和标准答案运行所需的周期数量相同或比其更少，得会得到该测试点的满分，否则设你的程序运行了 $a$ 个周期，标准答案运行了 $s$ 个周期，你的分数为 $\\lfloor\\text{该测试点分数}\\times(\\frac{s}{a})\\times0.8 \\rfloor$(注意，部分正确显示WA,但是仍然有分数)。\n\n```cpp\nP1=7\nP2=9\nP3=12\nP4=12\nP5=13\nP6=13\nP7=14\nP8=20\n```\n\nPS:如果你构造了什么好玩的土豆程序(可以和本题目中的任务无关)，请到答疑博客下或者私信告诉我，会酌情给予奖励。\n\nCheck 下载见附件。\n\nexample2.out：\n\n```\n2 2 8 in add tmp\nL 3 get r add tmp\nget d add tmp\nout 3 wait get l add tmp\n3 wait get u add tmp\n```", "locale": "zh-CN", "translations": {"en": {"title": "Potato Field", "background": "Daning planted a large potato field divided into $n \\times m$ plots in front of his house.\n\nDaning is setting up the school's OJ. To test the performance of the potato field, he found you to write code for his potatoes.", "description": "Daning’s potato field works at the granularity of plots. The set of all potatoes in a plot is called a processing unit. Each processing unit can store two values: key and tmp, both are 32-bit signed integers. Each unit can execute several commands. Daning will power the processing units one by one by riding his bicycle. The order is shown in the figure below; it shows a potato field split into $4 \\times 4$ processing units:\n\n![](https://cdn.luogu.com.cn/upload/pic/12313.png)\n\nThe unit number is the power-on order. Each time, units are visited in order from No. $1$ to No. $n \\times m$.\n\nEach complete traversal is called one cycle.\n\nOnly when the potatoes in a plot are powered will they work and execute commands. After all commands finish, Daning will stop supplying power.\n\nFor each processing unit, the command formats are as follows:\n\n1. `in` Read a number and store it into this unit’s $\\\\text{tmp}$. (If there is already a number in $\\\\text{tmp}$, it is overwritten; the same applies to all stores below.)\n2. `out` Output the current unit’s $\\\\text{key}$.\n3. `swap` Swap this unit’s $\\\\text{key}$ and $\\\\text{tmp}$.\n4. `add X` Add $X$ to $\\\\text{key}$. $X$ can only be a constant or $\\\\text{tmp}$; same below.\n5. `set X` Set $\\\\text{key}$ to $X$.\n6. `opp` Negate $\\\\text{key}$.\n7. `rev` Bitwise NOT on $\\\\text{key}$.\n8. `L/R X` Left/Right shift $\\\\text{key}$ by $X$ bits.\n9. `get u/d/l/r` Read the $\\\\text{key}$ of the unit above (u) / below (d) / left (l) / right (r) and copy it into this unit’s $\\\\text{tmp}$. Neighbor positions follow the picture above.\n10. `or/and/xor X` Bitwise OR/AND/XOR $\\\\text{key}$ with $X$.\n11. `wait` Wait during this power-on period; i.e., do nothing.\n12. `if X` If $X$ (can only be $\\\\text{key}$ or $\\\\text{tmp}$) is not equal to $0$, then during the next time this unit is powered, execute the next instruction; otherwise skip the next instruction and execute the one after that (if it exists).\n13. `goto Y` During the next time this unit is powered, start execution from instruction No. $Y$. $Y$ must be a constant.\n14. `end` Forcibly end the commands of all processing units, ignoring all remaining unexecuted commands.\n\nWe provide check.exe. Put your potato program potato.out and the input testdata you want to use potato.in in the same folder as check.exe. After running, you can view the detailed running status of your program in report.txt.\n\nWe also provide another sample potato program example2.out, a potato program using $2 \\times 2$ processing units that computes $10$ times an integer $a$. You can read it yourself (this sample is not the optimal solution for that computation; it is only to demonstrate the commands).\n\nBelow is a $1 \\times 3$ processing unit layout. Not all units must be used.\n\n![](https://cdn.luogu.com.cn/upload/pic/12314.png)\n\nYou have the following tasks to complete by writing potato programs:\n\n| ID | Input | Output | Constraints | Processing Unit Size Limit | Score | Additional Notes |\n| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |\n| $1$ | $a, b$ | $b - a$ | $\\\\lvert a \\\\rvert, \\\\lvert b \\\\rvert \\\\le 10^9$ | $1 \\\\times 3$ | $7$ | None |\n| $2$ | $a$ | $233 \\\\times a$ | $1 \\\\le \\\\lvert a \\\\rvert \\\\le 10^7$ | $2 \\\\times 2$ | $9$ | None |\n| $3$ | $a$ | $\\\\lvert a \\\\rvert$ | $1 \\\\le \\\\lvert a \\\\rvert \\\\le 10^9$ | $2 \\\\times 2$ | $12$ | Compute the absolute value of $a$. |\n| $4$ | $128$ integers $a_i$ | $\\\\sum_{i=1}^{128} a_i$ | $1 \\\\le \\\\lvert a_i \\\\rvert \\\\le 2 \\\\times 10^6$ | $4 \\\\times 2$ | $12$ | None |\n| $5$ | $a, b$ | $\\\\left\\\\lfloor \\\\dfrac{a + b}{2} \\\\right\\\\rfloor$ | $\\\\lvert a \\\\rvert, \\\\lvert b \\\\rvert \\\\le 2.1 \\\\times 10^9$ | $2 \\\\times 2$ | $13$ | None |\n| $6$ | $a$ | $\\\\operatorname{popcount}(a)$ | $\\\\lvert a \\\\rvert \\\\le 10^9$ | $2 \\\\times 2$ | $13$ | $\\\\operatorname{popcount}(a)$ denotes the number of $1$s in the binary representation of $a$. |\n| $7$ | $a, b$ | $\\\\max(a, b)$ | $\\\\lvert a \\\\rvert, \\\\lvert b \\\\rvert \\\\le 10^9$ | $2 \\\\times 2$ | $14$ | None |\n| $8$ | $n$ | $f(n)$ | $1 \\\\le n \\\\le 42$ | $3 \\\\times 3$ | $20$ | $f(n) = \\\\begin{cases} 1 & n < 2 \\\\\\\\ f(n-1) + f(n-2) & n \\\\ge 2 \\\\end{cases}$ |", "inputFormat": "This is an output-only problem.", "outputFormat": "The first line contains $n$ and $m$, indicating you used $n$ rows and $m$ columns.\n\nThen there are $n \\\\times m$ sections. In the $i$-th section, the first line contains $t_i$, the number of commands in the $i$-th processing unit (can be $0$). The next $t_i$ lines each describe a command, as described above.", "hint": "#### Explanation of Sample #1\n\nThis sample implements the A+B problem.\n\nThe first line `1 1` indicates the processing unit size is $1 \\\\times 1$.\n\nThe second line indicates there are $5$ instructions in the first processing unit.\n\nThe command on the third line executes in the first cycle and reads a number (assume it is $a$). At this time, the unit’s state is $\\\\text{key} = 0, \\\\text{tmp} = a$.\n\nThe fourth line executes in the second cycle and swaps $\\\\text{key}$ and $\\\\text{tmp}$. The state becomes $\\\\text{key} = a, \\\\text{tmp} = 0$.\n\nThe fifth line executes in the third cycle and reads another number $b$. The state is $\\\\text{key} = a, \\\\text{tmp} = b$.\n\nThe sixth line executes in the fourth cycle and adds $\\\\text{tmp}$ to $\\\\text{key}$. The state is $\\\\text{key} = a + b, \\\\text{tmp} = b$.\n\nThe seventh line executes in the fifth cycle and outputs this unit’s $\\\\text{key}$, i.e., it outputs $a + b$.\n\nIf your program does not finish within $2000$ cycles, or has a syntax error, or exceeds the processing unit size limit, you get $0$ points.\n\nIf your program for task $i$ produces the correct result, and the number of cycles required is the same as or fewer than the standard solution, you get full points for that test point. Otherwise, suppose your program ran for $a$ cycles and the standard solution ran for $s$ cycles. Your score is $\\\\left\\\\lfloor \\\\text{(points for that test point)} \\\\times \\\\left( \\\\dfrac{s}{a} \\\\right) \\\\times 0.8 \\\\right\\\\rfloor$. Note that even if it shows WA for partially correct solutions, you still receive points.\n\n```cpp\nP1=7\nP2=9\nP3=12\nP4=12\nP5=13\nP6=13\nP7=14\nP8=20\n```\n\nPS: If you craft any fun potato programs (they can be unrelated to the tasks in this problem), please reply under the Q&A blog or send me a private message. Rewards will be given at my discretion.\n\nCheck download is available in the attachment.\n\nexample2.out:\n\n```\n2 2 8 in add tmp\nL 3 get r add tmp\nget d add tmp\nout 3 wait get l add tmp\n3 wait get u add tmp\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "土豆田", "background": "大宁在他家门口种了一大片土豆田，划分为 $n \\times m$ 的地块。\n\n大宁准备搭建学校的 OJ，为了测试土豆田的性能，大宁找到了你，为他的土豆编写代码。", "description": "大宁的土豆田是以地块为单位的，每个地块里的所有土豆的集合称为一个处理单元，可以储存两个值：key（键值）和 tmp（缓存值），均为 $32$ 位带符号整数，每个单元。可以执行若干命令。大宁会骑着自行车轮流给每个处理单元供电，顺序如图，展示的是一个被分割为 $4\\times 4$ 处理单元的土豆田：\n\n  ![](https://cdn.luogu.com.cn/upload/pic/12313.png) \n\n单元的编号就是供电的顺序，每次按编号顺序从 $1$ 号到 $n\\times m$ 号遍历一遍。\n\n每一次完整的遍历称为一个周期。\n\n只有一块地上的土豆得到供电，它们才会工作，执行命令，所有命令执行完之后大宁会停止供电。\n\n对于每一个处理单元，命令格式如下：\n\n1. `in` 读取一个数，存放到该单元的 $\\text{tmp}$ 中。（如果 $\\text{tmp}$ 中有数，那么覆盖掉，以下的所有存放均如此）\n\n1. `out` 输出当前处理单元的 $\\text{key}$ 值。\n\n1. `swap` 交换该单元的 $\\text{key}$ 和 $\\text{tmp}$。\n\n1. `add X` 给 $\\text{key}$ 值加上 $X$，$X$ 只能是一个常数或者 $\\text{tmp}$，下同。\n\n1. `set X` 把 $\\text{key}$ 值修改为 $X$。\n\n1. `opp` 对 $\\text{key}$ 值取相反数。\n\n1. `rev` 对 $\\text{key}$ 值按位取反。\n\n1. `L/R X` 左/右移 $\\text{key}$ 值 $X$ 位。\n\n1. `get u/d/l/r` 将当前单元上(u)/下(d)/左(l)/右(r)面的单元的 $\\text{key}$ 值并把它复制到本单元的 $\\text{tmp}$，位置规则按照前面的图片所示。\n\n1. `or/and/xor X` 对 $\\text{key}$ 值按位或/与/异或 $X$。\n\n1. `wait` 在本次供电的时间中等待，即什么事情也不做。\n\n1. `if X` 如果此时 X(只能是 $\\text{key}$ 或者 $\\text{tmp}$ )不等于 $0$ 则在下一次供电执行该语句的下一条语句，否则跳过下一条语句，执行下下条(如果存在的话)。\n\n1. `goto Y`  下一次供电从第 $Y$ 号命令开始执行，$Y$ 只能是常数。\n\n1. `end` 强制结束所有的处理单元的命令，无视所有尚未执行的命令。\n\n我们提供了 check.exe,把你的土豆程序 potato.out 和你想测试的输入数据 potato.in 放到与 check.exe 同文件夹下，运行之后可以在 report.txt 中查看你的程序的详细运行情况。\n\n我们还提供了另一个样例土豆程序 example2.out,使用 $2\\times2$ 处理单元的土豆程序，内容为计算一个整数 $a$ 的 $10$ 倍,可以自行解读（该样例并非该计算的最优解，只是为了展示命令）。\n\n下面展示了一个 $1 \\times 3$ 的处理单元，所有单元不一定需要全部使用。\n\n![](https://cdn.luogu.com.cn/upload/pic/12314.png)\n\n你有以下任务需要用编写土豆程序完成：\n\n|编号|输入|输出|数据范围|处理单元大小限制|分数|补充说明|\n| :----------: | :----------: | :----------:| :----------:| :----------:|:----------: | :----------: |\n|$1$|$a\\text{，}b$|$b-a$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le10^9 $|$1 \\times 3$|$7$|无|\n|$2$|$a$|$233\\times a$|$1 \\le\\lvert a\\rvert \\le10^7 $|$2 \\times 2$|$9$|无|\n|$3$|$a$|$\\lvert a \\rvert$|$1 \\le\\lvert a\\rvert \\le10^9 $|$2 \\times 2$|$12$|求 $a$ 的绝对值|\n|$4$|$128$ 个整数 $a_i$|$\\sum^{128}_{i=1}a_i$|$1 \\le\\lvert a\\rvert \\le2 \\times 10^6 $|$4 \\times 2$|$12$|无|\n|$5$|$a\\text{，}b$|$\\lfloor \\frac{a+b}{2}\\rfloor$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le2.1\\times10^9 $|$2 \\times 2$|$13$|无|\n|$6$|$a$|$\\operatorname{popcount}(a)$|$\\lvert a\\rvert\\le10^9 $|$2 \\times 2$|$13$|$\\operatorname{popcount}(a)$表示 $a$ 在二进制表示下 $1$ 的个数|\n|$7$|$a\\text{，}b$|$\\max {(a,b)}$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le10^9 $|$2 \\times 2$|$14$|无|\n|$8$|$n$|$f(n)$|$1 \\le n \\le 42$|$3 \\times 3$|$20$|$f(n)=\\begin{cases}1 & n<2\\\\f(n-1)+f(n-2) & n\\ge 2\\end{cases}$|", "inputFormat": "本题为提交答案题。", "outputFormat": "第一行为 $n$ 和 $m$，表示你用了 $n$ 行 $m$ 列。\n\n接下来$n\\times m$个部分，第 $i$ 个部分的第一行 $t_i$ 表示在第 $i$ 个处理单元中命令的数量(可以为 $0$)，接下来 $t_i$ 行每行描述一个命令，见上文所述。", "hint": "#### 样例#1解释\n\n这个样例实现了 A+B problem。\n\n第一行的 `1 1` 表示用的处理单元为 $1\\times1$。\n\n第二行表示第一个处理单元有 $5$ 条指令。\n\n第三行的命令在第一个周期执行，读入了一个数(假定为 $a$) ，此时该单元的状态为 $\\text{key}= 0 \\text{，}\\text{tmp}= a$。\n\n第四行在第二个周期执行，交换了 $\\text{key}$ 和 $\\text{tmp}$，状态为 $\\text{key}= a \\text{，}\\text{tmp}= 0$。\n\n第五行在第三个周期执行，读入了另一个数 $b$，状态为 $\\text{key}= a \\text{，}\\text{tmp}= b$。\n\n第六行在第四个周期执行，给 $\\text{key}$ 加上 $\\text{tmp}$，状态为 $\\text{key}= a+b \\text{，}\\text{tmp}= b$。\n\n第七行在第五个周期执行，输出该单元的 $\\text{key}$，即输出了 $a+b$。\n\n\n如果你的程序在 $2000$ 个周期内没有运行完毕，或者有语法错误，或者超过处理单元尺寸限制，得 $0$ 分。\n\n如果你的第 $i$ 个任务的程序能得出正确的结果，并且和标准答案运行所需的周期数量相同或比其更少，得会得到该测试点的满分，否则设你的程序运行了 $a$ 个周期，标准答案运行了 $s$ 个周期，你的分数为 $\\lfloor\\text{该测试点分数}\\times(\\frac{s}{a})\\times0.8 \\rfloor$(注意，部分正确显示WA,但是仍然有分数)。\n\n```cpp\nP1=7\nP2=9\nP3=12\nP4=12\nP5=13\nP6=13\nP7=14\nP8=20\n```\n\nPS:如果你构造了什么好玩的土豆程序(可以和本题目中的任务无关)，请到答疑博客下或者私信告诉我，会酌情给予奖励。\n\nCheck 下载见附件。\n\nexample2.out：\n\n```\n2 2 8 in add tmp\nL 3 get r add tmp\nget d add tmp\nout 3 wait get l add tmp\n3 wait get u add tmp\n```", "locale": "zh-CN"}}}
{"pid": "P2683", "type": "P", "difficulty": 3, "samples": [["3 8 \n1 3 1 10 \n0 2 3 \n1 2 3 20 \n1 1 2 5 \n0 3 2 \n1 1 3 7 \n1 2 1 9 \n0 2 3", "-1\n15\n12"], ["5 16\n1 1 2 343750\n1 1 3 3343\n1 1 4 347392\n1 1 5 5497\n1 2 3 123394\n1 2 4 545492\n1 2 5 458\n1 3 4 343983\n1 3 5 843468\n1 4 5 15934\n0 2 1\n0 4 1\n0 3 2\n0 4 2\n0 4 3\n0 5 3", "5955\n21431\n9298\n16392\n24774\n8840"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "2015", "安徽"], "title": "[AHOI2015 初中组] 小岛", "background": "西伯利亚北部的寒地，坐落着由 $N$ 个小岛组成的岛屿群，我们把这些小岛依次编号为 $1$ 到 $N$。", "description": "起初，岛屿之间没有任何的航线。后来随着交通的发展，逐渐出现了一些连通两座小岛的航线。例如增加一条在 $u$ 号小岛与 $v$ 号小岛之间的航线，这条航线的用时为 $e$。那么沿着这条航线，$u$ 号小岛上的人可以前往 $v$ 号小岛，同样的 $v$ 号小岛上的人也可以前往 $u$ 号小岛，其中沿着这一条航线花费的时间为 $e$。\n\n同时，随着旅游业的发展，越来越多的人前来游玩。那么两个小岛之间的最短路径是多少便成为了饱受关注的话题。", "inputFormat": "输入共 $M+1$ 行。\n\n第一行有两个整数 $N$ 和 $M$，分别表示小岛的数与总操作数。\n\n接下来的 $M$ 行，每行表示一个操作，格式如下：\n\n`0 s t`：表示询问从 $s$ 号小岛到 $t$ 号小岛的最短用时（$1\\le s\\le n,~ 1\\le t\\le n,~ s\\neq t$）。\n\n`1 u v e`：表示新增了一条从 $u$ 号小岛到 $v$ 号小岛，用时为 $e$ 的双向航线（$1\\le u\\le n, ~1\\le v\\le n,~ u ≠ v,~ 1\\le e\\le 10^6$）。", "outputFormat": "输出针对每一次询问，单独输出一行。\n\n对于每一组询问来说，如果不存在可行的道路，则输出 `-1`，否则输出最短用时。", "hint": "对于 $20\\%$ 的数据，$N\\le 5$ 且 $M\\le 30$。\n\n对于 $40\\%$ 的数据，$N\\le 20$ 且 $M\\le 200$。\n\n对于 $60\\%$ 的数据，$N\\le 80$ 且 $M\\le 500$。\n\n对于 $80\\%$ 的数据，$N\\le 100$ 且 $M\\le 2500$。\n\n对于 $100\\%$ 的数据，$N\\le 100$ 且 $M\\le 5000$。", "locale": "zh-CN", "translations": {"en": {"title": "[AHOI2015 Middle School Division] Small Island", "background": "In the frigid lands of northern Siberia lies an archipelago consisting of $N$ small islands, which we number from $1$ to $N$ in order.", "description": "At first, there are no routes between the islands. Later, as transportation develops, routes connecting pairs of islands gradually appear. For example, when a route between island $u$ and island $v$ is added with travel time $e$, people on island $u$ can travel to island $v$, and people on island $v$ can also travel to island $u$, with time $e$ along this route.\n\nMeanwhile, with the growth of tourism, more and more people come to visit. The shortest path between two islands has therefore become a topic of great interest.", "inputFormat": "The input has $M+1$ lines.\n\nThe first line contains two integers $N$ and $M$, representing the number of islands and the total number of operations, respectively.\n\nEach of the next $M$ lines describes one operation, in one of the following formats:\n\n`0 s t`: Query the shortest travel time from island $s$ to island $t$ ($1 \\le s \\le N$, $1 \\le t \\le N$, $s \\ne t$).\n\n`1 u v e`: Add a new bidirectional route between island $u$ and island $v$ with travel time $e$ ($1 \\le u \\le N$, $1 \\le v \\le N$, $u \\ne v$, $1 \\le e \\le 10^6$).", "outputFormat": "For each query, output one line.\n\nFor each query, if no feasible path exists, output `-1`; otherwise, output the shortest travel time.", "hint": "For $20\\%$ of the testdata, $N \\le 5$ and $M \\le 30$.\n\nFor $40\\%$ of the testdata, $N \\le 20$ and $M \\le 200$.\n\nFor $60\\%$ of the testdata, $N \\le 80$ and $M \\le 500$.\n\nFor $80\\%$ of the testdata, $N \\le 100$ and $M \\le 2500$.\n\nFor $100\\%$ of the testdata, $N \\le 100$ and $M \\le 5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[AHOI2015 初中组] 小岛", "background": "西伯利亚北部的寒地，坐落着由 $N$ 个小岛组成的岛屿群，我们把这些小岛依次编号为 $1$ 到 $N$。", "description": "起初，岛屿之间没有任何的航线。后来随着交通的发展，逐渐出现了一些连通两座小岛的航线。例如增加一条在 $u$ 号小岛与 $v$ 号小岛之间的航线，这条航线的用时为 $e$。那么沿着这条航线，$u$ 号小岛上的人可以前往 $v$ 号小岛，同样的 $v$ 号小岛上的人也可以前往 $u$ 号小岛，其中沿着这一条航线花费的时间为 $e$。\n\n同时，随着旅游业的发展，越来越多的人前来游玩。那么两个小岛之间的最短路径是多少便成为了饱受关注的话题。", "inputFormat": "输入共 $M+1$ 行。\n\n第一行有两个整数 $N$ 和 $M$，分别表示小岛的数与总操作数。\n\n接下来的 $M$ 行，每行表示一个操作，格式如下：\n\n`0 s t`：表示询问从 $s$ 号小岛到 $t$ 号小岛的最短用时（$1\\le s\\le n,~ 1\\le t\\le n,~ s\\neq t$）。\n\n`1 u v e`：表示新增了一条从 $u$ 号小岛到 $v$ 号小岛，用时为 $e$ 的双向航线（$1\\le u\\le n, ~1\\le v\\le n,~ u ≠ v,~ 1\\le e\\le 10^6$）。", "outputFormat": "输出针对每一次询问，单独输出一行。\n\n对于每一组询问来说，如果不存在可行的道路，则输出 `-1`，否则输出最短用时。", "hint": "对于 $20\\%$ 的数据，$N\\le 5$ 且 $M\\le 30$。\n\n对于 $40\\%$ 的数据，$N\\le 20$ 且 $M\\le 200$。\n\n对于 $60\\%$ 的数据，$N\\le 80$ 且 $M\\le 500$。\n\n对于 $80\\%$ 的数据，$N\\le 100$ 且 $M\\le 2500$。\n\n对于 $100\\%$ 的数据，$N\\le 100$ 且 $M\\le 5000$。", "locale": "zh-CN"}}}
{"pid": "P2684", "type": "P", "difficulty": 3, "samples": [["3 10\n1 7\n3 6\n8 10\n", "2\n\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "搞清洁", "background": null, "description": "FJ 准备分配它的 $N$ 只奶牛 $(1 \\le N \\le 2.5\\times 10^4)$ 做清洁工作，他把一天分成 $T(1 \\le T \\le 10^6)$ 个时间段，他希望每一个时间段都有奶牛在清洁，但搞清洁的奶牛数越少越好。", "inputFormat": "第一行，两下整数 $N$ 和 $T$。\n\n接下来 $N$ 行，每行两个整数，表示第 $i$ 头奶牛能工作的时间段。", "outputFormat": "使每一个时间段都有奶牛工作的最少奶牛数，如果不可能，则输出 `-1`。", "hint": "样例解释：\n\n有 $3$ 头奶牛，第 $1$ 头能工作的时间段是 $1\\sim7$，即从时间 $1$ 开始工作，时间 $7$ 结束（时间 $7$ 也在工作的），第 $2$ 头是 $3\\sim6$，第 $3$ 头是 $8\\sim10$，则只需要第 $1$ 头和第 $3$ 头奶牛就能使每一个时间都有奶牛工作。", "locale": "zh-CN", "translations": {"en": {"title": "Cleaning Up", "background": "", "description": "FJ plans to assign his $N$ cows $(1 \\le N \\le 2.5\\times 10^4)$ to do cleaning. He divides the day into $T(1 \\le T \\le 10^6)$ time slots. He wants every time slot to have a cow cleaning, while using as few cows as possible.", "inputFormat": "The first line contains two integers $N$ and $T$.\n\nThe next $N$ lines each contain two integers, representing the time interval during which the $i$-th cow can work (inclusive).", "outputFormat": "Output the minimum number of cows needed so that every time slot has a cow working. If it is impossible, output `-1`.", "hint": "Sample explanation:\n\nThere are $3$ cows. The $1$-st can work during $1\\sim7$, that is, starts at time $1$ and ends at time $7$ (time $7$ is also covered). The $2$-nd works during $3\\sim6$, and the $3$-rd during $8\\sim10$. Then only the $1$-st and the $3$-rd cows are needed to ensure every time slot is covered.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "搞清洁", "background": null, "description": "FJ 准备分配它的 $N$ 只奶牛 $(1 \\le N \\le 2.5\\times 10^4)$ 做清洁工作，他把一天分成 $T(1 \\le T \\le 10^6)$ 个时间段，他希望每一个时间段都有奶牛在清洁，但搞清洁的奶牛数越少越好。", "inputFormat": "第一行，两下整数 $N$ 和 $T$。\n\n接下来 $N$ 行，每行两个整数，表示第 $i$ 头奶牛能工作的时间段。", "outputFormat": "使每一个时间段都有奶牛工作的最少奶牛数，如果不可能，则输出 `-1`。", "hint": "样例解释：\n\n有 $3$ 头奶牛，第 $1$ 头能工作的时间段是 $1\\sim7$，即从时间 $1$ 开始工作，时间 $7$ 结束（时间 $7$ 也在工作的），第 $2$ 头是 $3\\sim6$，第 $3$ 头是 $8\\sim10$，则只需要第 $1$ 头和第 $3$ 头奶牛就能使每一个时间都有奶牛工作。", "locale": "zh-CN"}}}
{"pid": "P2685", "type": "P", "difficulty": 6, "samples": [["3 4\n1 2 1\n1 2 2\n2 3 1\n2 3 2", "3 2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2012", "各省省选", "天津"], "title": "[TJOI2012] 桥", "background": "", "description": "有 $n$ 个岛屿，$m$ 座桥，每座桥连通两座岛屿，桥上会有一些敌人，玩家只有消灭了桥上的敌人才能通过，与此同时桥上的敌人会对玩家造成一定伤害。而且会有一个大 Boss 镇守一座桥，以玩家目前的能力，是不可能通过的。而 Boss 是邪恶的， Boss 会镇守某一座使得玩家受到最多的伤害才能从岛屿 $1$ 到达岛屿 $n$（当然玩家会选择伤害最小的路径）。问，Boss 可能镇守的桥有哪些。\n\n注意可以有**重边**和**自环**。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $m$ 行，每行三个整数 $s,t,c$，表示一座连接岛屿 $s$ 和 $t$ 的桥上的敌人会对玩家造成 $c$ 的伤害。\n", "outputFormat": "一行，两个整数 $d,cnt$，$d$ 表示有 Boss 的情况下，玩家至少要受到的伤害，$cnt$ 表示 Boss 可能镇守的桥的数目。\n", "hint": "- $30\\%$ 的数据，$1 ≤ n ≤ 1000$；\n- $100\\%$ 的数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 200000, 1 ≤ c ≤ 10000$；\n- 数据保证玩家可以从岛屿 $1$ 到达岛屿 $n$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[TJOI2012] Bridge", "background": "", "description": "There are $n$ islands and $m$ bridges. Each bridge connects two islands. There are some enemies on every bridge; the player can pass a bridge only after defeating the enemies on it, and doing so inflicts some damage to the player. There is also a big Boss guarding exactly one bridge, which is impassable for the player given their current ability. The Boss is evil and will choose a bridge to guard so that, after blocking that bridge, the minimum possible total damage the player must suffer to travel from island $1$ to island $n$ (of course the player will choose the path with the least damage) is as large as possible. Determine which bridges the Boss might guard.\n\nNote: **multiple edges** and **self-loops** are allowed.", "inputFormat": "The first line contains two integers $n, m$.\n\nThe next $m$ lines each contain three integers $s, t, c$, indicating that the enemies on the bridge connecting islands $s$ and $t$ will inflict $c$ damage on the player.", "outputFormat": "One line with two integers $d, cnt$, where $d$ is the minimum damage the player must suffer in the presence of the Boss, and $cnt$ is the number of bridges that the Boss might guard.", "hint": "- For $30\\%$ of the testdata, $1 \\le n \\le 1000$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 100000$, $1 \\le m \\le 200000$, $1 \\le c \\le 10000$.\n- It is guaranteed that the player can reach island $n$ from island $1$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[TJOI2012] 桥", "background": "", "description": "有 $n$ 个岛屿，$m$ 座桥，每座桥连通两座岛屿，桥上会有一些敌人，玩家只有消灭了桥上的敌人才能通过，与此同时桥上的敌人会对玩家造成一定伤害。而且会有一个大 Boss 镇守一座桥，以玩家目前的能力，是不可能通过的。而 Boss 是邪恶的， Boss 会镇守某一座使得玩家受到最多的伤害才能从岛屿 $1$ 到达岛屿 $n$（当然玩家会选择伤害最小的路径）。问，Boss 可能镇守的桥有哪些。\n\n注意可以有**重边**和**自环**。", "inputFormat": "第一行两个整数 $n,m$。\n\n接下来 $m$ 行，每行三个整数 $s,t,c$，表示一座连接岛屿 $s$ 和 $t$ 的桥上的敌人会对玩家造成 $c$ 的伤害。\n", "outputFormat": "一行，两个整数 $d,cnt$，$d$ 表示有 Boss 的情况下，玩家至少要受到的伤害，$cnt$ 表示 Boss 可能镇守的桥的数目。\n", "hint": "- $30\\%$ 的数据，$1 ≤ n ≤ 1000$；\n- $100\\%$ 的数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 200000, 1 ≤ c ≤ 10000$；\n- 数据保证玩家可以从岛屿 $1$ 到达岛屿 $n$。\n", "locale": "zh-CN"}}}
{"pid": "P2686", "type": "P", "difficulty": 4, "samples": [["6 4 5\n1 3 3 2 2 1\n2 3 1 4 5 2\n", "21\n\n注：样例中，3场，第一场选1，2两题，第二场选3，4两题，第三场选4，5，6三题。\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "线段树", "区间 DP", "前缀和"], "title": "老虎的题目", "background": null, "description": "随着小老虎做题越来越多，现在可做小老师了，小老虎经常帮老师出题供信息学奥赛班的同学测试用。出题确实是一件麻烦事。现在有更麻烦的事了：\n\n小老虎收集到了一大堆的题目，并且按照收集的时间顺序排成一排。每个题目都有自己的题面长度和难度。小老虎想用这些题出好多好多场比赛。但是呢，有要求：\n\n- 同一场比赛的题目，必须是这一排题目中连续的一段，但题目数量不限。\n- 题面长度的总和，不能超过 $H$，也不能低于 $L$。\n- 不允许出现两场比赛，使得其中一场的题目全部在另一场出现过了。（也就是说，不同比赛的题目集合不能出现包含和被包含关系）\n\n题目可以在不同比赛中重复使用。\n\n\n现在，小老虎想知道，在满足以上条件的基础上，所有比赛的难度总和最大是多少？（定义一场比赛的难度为本场比赛出现的所有题目的难度和）", "inputFormat": "第一行是三个整数，$N$、$L$、$H$。\n\n第二行有 $N$ 个整数，第 $i$ 个整数 $a_i$ 代表第 $i$ 题题面的长度。\n\n第三行有 $N$ 个整数，第 $i$ 个整数 $b_i$ 代表第 $i$ 题题目的难度。", "outputFormat": "输出一个整数，所有比赛的最大难度总和。", "hint": "对于 $40\\%$ 的数据，$1 \\le N \\le 100$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 1000$，$0 \\le a_i,b_i \\le {10}^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Tiger's Problem", "background": null, "description": "As Little Tiger solves more and more problems, he can now act as a little teacher and often helps teachers create problems for the informatics olympiad class to use for practice. Making problems is indeed a troublesome task. Now there is an even more troublesome situation:\n\nLittle Tiger has collected a large number of problems and arranged them in a sequence in the order they were collected. Each problem has its own statement length and difficulty. Little Tiger wants to use these problems to create many contests. However, there are requirements:\n\n- The problems in the same contest must form a contiguous segment of this sequence, and the number of problems is unrestricted.\n- The total statement length must not exceed $H$ and must not be less than $L$.\n- It is not allowed to have two contests such that all problems of one contest also appear in the other. (In other words, the problem sets of different contests must not have a containment or be-contained relationship.)\n\nProblems may be reused across different contests.\n\nNow, Little Tiger wants to know, under the above constraints, what is the maximum possible total difficulty over all contests? (Define the difficulty of a contest as the sum of the difficulties of all problems appearing in that contest.)", "inputFormat": "The first line contains three integers $N$, $L$, and $H$.\n\nThe second line contains $N$ integers. The $i$-th integer $a_i$ denotes the statement length of the $i$-th problem.\n\nThe third line contains $N$ integers. The $i$-th integer $b_i$ denotes the difficulty of the $i$-th problem.", "outputFormat": "Output a single integer: the maximum total difficulty over all contests.", "hint": "For $40\\%$ of the testdata, $1 \\le N \\le 100$.\n\nFor $100\\%$ of the testdata, $1 \\le N \\le 1000$, $0 \\le a_i, b_i \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "老虎的题目", "background": null, "description": "随着小老虎做题越来越多，现在可做小老师了，小老虎经常帮老师出题供信息学奥赛班的同学测试用。出题确实是一件麻烦事。现在有更麻烦的事了：\n\n小老虎收集到了一大堆的题目，并且按照收集的时间顺序排成一排。每个题目都有自己的题面长度和难度。小老虎想用这些题出好多好多场比赛。但是呢，有要求：\n\n- 同一场比赛的题目，必须是这一排题目中连续的一段，但题目数量不限。\n- 题面长度的总和，不能超过 $H$，也不能低于 $L$。\n- 不允许出现两场比赛，使得其中一场的题目全部在另一场出现过了。（也就是说，不同比赛的题目集合不能出现包含和被包含关系）\n\n题目可以在不同比赛中重复使用。\n\n\n现在，小老虎想知道，在满足以上条件的基础上，所有比赛的难度总和最大是多少？（定义一场比赛的难度为本场比赛出现的所有题目的难度和）", "inputFormat": "第一行是三个整数，$N$、$L$、$H$。\n\n第二行有 $N$ 个整数，第 $i$ 个整数 $a_i$ 代表第 $i$ 题题面的长度。\n\n第三行有 $N$ 个整数，第 $i$ 个整数 $b_i$ 代表第 $i$ 题题目的难度。", "outputFormat": "输出一个整数，所有比赛的最大难度总和。", "hint": "对于 $40\\%$ 的数据，$1 \\le N \\le 100$。\n\n对于 $100\\%$ 的数据，$1 \\le N \\le 1000$，$0 \\le a_i,b_i \\le {10}^5$。", "locale": "zh-CN"}}}
{"pid": "P2687", "type": "P", "difficulty": 4, "samples": [["12\n68 69 54 64 68 64 70 67\n78 62 98 87", "4 2"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "USACO"], "title": "[USACO4.3] 逢低吸纳 Buy Low, Buy Lower", "background": "本题可以使用 `long double` 通过是刻意的。加强版请到 [P12930](https://www.luogu.com.cn/problem/P12930)。在本题中，$N\\leq 5000$。", "description": "“逢低吸纳”是炒股的一条成功秘诀。如果你想成为一个成功的投资者，就要遵守这条秘诀：“逢低吸纳，越低越买”。\n\n这句话的意思是：每次你购买股票时的股价一定要比你上次购买时的股价低。按照这个规则购买股票的次数越多越好，看看你最多能按这个规则买几次。\n\n给定连续的 $N$ 天中每天的股价。你可以在任何一天购买一次股票，但是购买时的股价一定要比你上次购买时的股价低。写一个程序，求出最多能买几次股票。\n\n以下面这个表为例，某几天的股价是：\n\n|天数    |股价    |\n|:-------|:-------|\n|$1$|$68$|\n|$2$|$69$|\n|$3$|$54$|\n|$4$|$64$|\n|$5$|$68$|\n|$6$|$64$|\n|$7$|$70$|\n|$8$|$67$|\n|$9$|$78$|\n|$10$|$62$|\n|$11$|$98$|\n|$12$|$87$|\n\n\n这个例子中，如果每次买股票时的股价都比上一次买时低，那么最多能买 $4$ 次股票。一种买法如下（可能有其他的买法）：\n\n\n|天数    |股价    |\n|:-------|:-------|\n|$2$|$69$|\n|$5$|$68$|\n|$6$|$64$|\n|$10$|$62$|", "inputFormat": "第 $1$ 行：一个整数 $N$，表示能买股票的天数。\n\n以后多行，输入 $N$ 个正整数（可能分多行），第 $i$ 个正整数表示第 $i$ 天的股价。这些正整数大小不会超过 $2^{31}-1$。", "outputFormat": "一行两个整数，表示按每次买股票时的股价都比上一次买时低的要求最多能够买进股票的天数，和能够买进这些天数的股票的股票购买方案数量。\n\n两个方案不相同当且仅当这两个方案中所购买的股票的价格序列不相同。", "hint": "$1 \\le N \\le 5000$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO4.3] Buy on Dips — Buy Low, Buy Lower", "background": "It is intentional that using `long double` can pass this problem. For a strengthened version, see [P12930](https://www.luogu.com.cn/problem/P12930). In this problem, $N\\leq 5000$.", "description": "“Buy on dips” is a successful tip for stock trading. If you want to be a successful investor, follow this tip: “Buy on dips, the lower the better.”\n\nThis means: every time you buy, the stock price must be lower than the price at your previous purchase. The more times you can buy under this rule, the better. See how many times at most you can buy following this rule.\n\nYou are given the price of the stock for each of $N$ consecutive days. You may buy once on any day, but the price at purchase must be lower than the price at your previous purchase. Write a program to find the maximum number of times you can buy.\n\nFor example, suppose the prices on some days are:\n\n|Day    |Price    |\n|:-------|:-------|\n|$1$|$68$|\n|$2$|$69$|\n|$3$|$54$|\n|$4$|$64$|\n|$5$|$68$|\n|$6$|$64$|\n|$7$|$70$|\n|$8$|$67$|\n|$9$|$78$|\n|$10$|$62$|\n|$11$|$98$|\n|$12$|$87$|\n\nIn this example, if each purchase price is lower than the previous one, you can buy at most $4$ times. One valid way is as follows (there may be others):\n\n\n|Day    |Price    |\n|:-------|:-------|\n|$2$|$69$|\n|$5$|$68$|\n|$6$|$64$|\n|$10$|$62$|", "inputFormat": "The first line: an integer $N$, the number of days on which you can buy.\n\nThen $N$ positive integers (possibly across multiple lines), where the $i$-th integer is the stock price on day $i$. Each integer does not exceed $2^{31}-1$.", "outputFormat": "One line with two integers: the maximum number of days you can buy under the rule that each purchase price is lower than the previous one, and the number of purchase plans that achieve this maximum.\n\nTwo plans are different if and only if the sequences of purchased prices are different.", "hint": "$1 \\le N \\le 5000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO4.3] 逢低吸纳 Buy Low, Buy Lower", "background": "本题可以使用 `long double` 通过是刻意的。加强版请到 [P12930](https://www.luogu.com.cn/problem/P12930)。在本题中，$N\\leq 5000$。", "description": "“逢低吸纳”是炒股的一条成功秘诀。如果你想成为一个成功的投资者，就要遵守这条秘诀：“逢低吸纳，越低越买”。\n\n这句话的意思是：每次你购买股票时的股价一定要比你上次购买时的股价低。按照这个规则购买股票的次数越多越好，看看你最多能按这个规则买几次。\n\n给定连续的 $N$ 天中每天的股价。你可以在任何一天购买一次股票，但是购买时的股价一定要比你上次购买时的股价低。写一个程序，求出最多能买几次股票。\n\n以下面这个表为例，某几天的股价是：\n\n|天数    |股价    |\n|:-------|:-------|\n|$1$|$68$|\n|$2$|$69$|\n|$3$|$54$|\n|$4$|$64$|\n|$5$|$68$|\n|$6$|$64$|\n|$7$|$70$|\n|$8$|$67$|\n|$9$|$78$|\n|$10$|$62$|\n|$11$|$98$|\n|$12$|$87$|\n\n\n这个例子中，如果每次买股票时的股价都比上一次买时低，那么最多能买 $4$ 次股票。一种买法如下（可能有其他的买法）：\n\n\n|天数    |股价    |\n|:-------|:-------|\n|$2$|$69$|\n|$5$|$68$|\n|$6$|$64$|\n|$10$|$62$|", "inputFormat": "第 $1$ 行：一个整数 $N$，表示能买股票的天数。\n\n以后多行，输入 $N$ 个正整数（可能分多行），第 $i$ 个正整数表示第 $i$ 天的股价。这些正整数大小不会超过 $2^{31}-1$。", "outputFormat": "一行两个整数，表示按每次买股票时的股价都比上一次买时低的要求最多能够买进股票的天数，和能够买进这些天数的股票的股票购买方案数量。\n\n两个方案不相同当且仅当这两个方案中所购买的股票的价格序列不相同。", "hint": "$1 \\le N \\le 5000$。", "locale": "zh-CN"}}}
{"pid": "P2688", "type": "P", "difficulty": 6, "samples": [["3\n12 2 2\n1 1\n2 5\n6 8\n5 1 2\n3 1\n1 5\n11 3 0\n2 2\n3 1\n5 1", "2\n-1\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "二分"], "title": "大海战", "background": "一天，GD和MW正在玩一款名叫大海战的游戏。\n", "description": "游戏在一个 $1 \\times n$ 的棋盘上进行。一开始 GD 拥有 $c$ 种战舰，每种战舰的宽度为 $1$，长度为 $c_i$，共有 $t_i$ 个。GD 要将所有这些战舰放置在棋盘上，并且任意两艘战舰间不能重叠（但可以相邻）。\n\n接下来，MW 进行 $q$ 次“攻击”，每次攻击一个 $1 \\times 1$ 的格子，而 MW 将告知他这次攻击是否“打中”了一艘战舰（或者它的某个部分）。\n\n令人疑惑的是，每次 MW 都告诉 GD 说他没有打中任何一艘战舰，而这显然是不现实的。现在 MW 把整个游戏的过程告诉了你，他想知道，最早在他的第几次询问之后，可以断定 GD 一定（至少有一次）说了谎。", "inputFormat": "**本题单测试点内有多组数据**。\n\n第一行一个整数 $t$，表示测试数据的组数。    \n\n每组数据的输入格式如下：\n\n每组数据的第一行有三个整数，分别代表棋盘的长度 $n$ 、战舰的种数 $c$ 和攻击的次数 $q$。\n\n对于每组数据的第 $2$ 到第 $(c + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的两个整数分别代表第 $i$ 种战舰的长度 $c_i$ 和数量 $t_i$。\n\n第 $(c + 2)$ 行有 $q$ 个整数，第 $i$ 个整数 $a_i$ 代表 MW 第 $i$ 次攻击的位置。", "outputFormat": "对于每组数据，输出一个整数 $ans$，表示最早在第 $ans$ 次操作后可以断定 GD 说了谎。特别地，如果一开始就不可能按要求摆上所有的战舰，输出 $0$；如果 $q$ 次询问后都不能判断 GD 是否说了谎，则输出 $-1$。", "hint": "#### 样例输入输出 1 解释\n\n- 对于第一个样例，存在布阵 $\\{1,22,22,0,22,22,22\\}$（$0$ 表示没有放置），使得第一次不会受到攻击；不存在一个布阵使得两次都没有受到攻击。\n- 对于第二个样例，存在布阵 $\\{0,333,0\\}$，使得两次均不会受到攻击。\n- 对于第三个样例，一开始就不可能把所有战舰合法地布置在棋盘上。\n\n---\n\n#### 数据规模与约定\n\n- 对于测试点1，$n \\leq 1000000000$，$c \\leq 100000$，$q=0$；\n- 对于测试点2、3，所有的 $t_i$ 均为 $1$；\n- 对于测试点2-8，$n \\leq 400000$，$c \\leq 100$，$q=1$；\n- 对于测试点9，$n \\leq 100$，$c=1$，$q \\leq 100$；\n- 对于测试点10-14，$n \\leq 200000$，$c=1$，$q \\leq 200000$；\n- 对于测试点15、16，$n \\leq 200$，$c=2$，$q \\leq 200$；\n- 对于测试点17-20，$n \\leq 4000$，$c=2$，$q \\leq 4000$。\n- 对于 $100\\%$ 的数据，$1 \\le t \\le 5,n \\ge 1,c \\ge 1,q \\ge 0,1 \\le q_i \\le n,0 \\le c_i \\le 10^5,0 \\le t_i \\le 10^5$。\n\n---\n\n#### 提示\n\n- 请注意常数因子对程序效率造成的影响。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "Battleship", "background": "One day, GD and MW were playing a game called Battleship.", "description": "The game is played on a $1 \\times n$ board. Initially, GD has $c$ types of ships. Each ship has width $1$, length $c_i$, and there are $t_i$ ships of the $i$-th type. GD must place all these ships on the board so that no two ships overlap (they may be adjacent).\n\nNext, MW makes $q$ “attacks,” each time targeting a $1 \\times 1$ cell, and GD will tell him whether that attack “hit” a ship (or any part of it).\n\nPuzzlingly, GD tells MW every time that he did not hit any ship, which is clearly unrealistic. Now MW reveals the entire gameplay to you. He wants to know the earliest time, after which of his attacks, one can conclude that GD must have lied at least once.", "inputFormat": "There are multiple test cases within a single test file.\n\nThe first line contains an integer $t$, the number of test cases.\n\nFor each test case:\n\n- The first line contains three integers, the board length $n$, the number of ship types $c$, and the number of attacks $q$.\n- The next $c$ lines (lines $2$ to $(c + 1)$) each contain two integers. On line $(i + 1)$, the two integers are the length $c_i$ and the count $t_i$ of the $i$-th type of ship.\n- Line $(c + 2)$ contains $q$ integers. The $i$-th integer $a_i$ is the position targeted by MW’s $i$-th attack.", "outputFormat": "For each test case, output a single integer $ans$, the earliest index such that after the $ans$-th operation you can conclude GD has lied. In particular, if it is impossible from the very beginning to place all ships as required, output $0$. If after all $q$ attacks you still cannot determine whether GD has lied, output $-1$.", "hint": "- Sample Input/Output 1 Explanation:\n  - For the first sample, there exists a layout $\\{1,22,22,0,22,22,22\\}$ ($0$ means empty) such that the first attack misses; no layout can make both attacks miss.\n  - For the second sample, there exists a layout $\\{0,333,0\\}$ such that both attacks miss.\n  - For the third sample, it is impossible to place all ships legally from the start.\n\n- Constraints:\n  - For test point 1, $n \\leq 1000000000$, $c \\leq 100000$, $q = 0$.\n  - For test points 2–3, all $t_i$ are $1$.\n  - For test points 2–8, $n \\leq 400000$, $c \\leq 100$, $q = 1$.\n  - For test point 9, $n \\leq 100$, $c = 1$, $q \\leq 100$.\n  - For test points 10–14, $n \\leq 200000$, $c = 1$, $q \\leq 200000$.\n  - For test points 15–16, $n \\leq 200$, $c = 2$, $q \\leq 200$.\n  - For test points 17–20, $n \\leq 4000$, $c = 2$, $q \\leq 4000$.\n  - For $100\\%$ of the testdata, $1 \\le t \\le 5, n \\ge 1, c \\ge 1, q \\ge 0, 1 \\le a_i \\le n, 0 \\le c_i \\le 10^5, 0 \\le t_i \\le 10^5$.\n\n- Note: Please be mindful of the impact of constant factors on performance.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "大海战", "background": "一天，GD和MW正在玩一款名叫大海战的游戏。\n", "description": "游戏在一个 $1 \\times n$ 的棋盘上进行。一开始 GD 拥有 $c$ 种战舰，每种战舰的宽度为 $1$，长度为 $c_i$，共有 $t_i$ 个。GD 要将所有这些战舰放置在棋盘上，并且任意两艘战舰间不能重叠（但可以相邻）。\n\n接下来，MW 进行 $q$ 次“攻击”，每次攻击一个 $1 \\times 1$ 的格子，而 MW 将告知他这次攻击是否“打中”了一艘战舰（或者它的某个部分）。\n\n令人疑惑的是，每次 MW 都告诉 GD 说他没有打中任何一艘战舰，而这显然是不现实的。现在 MW 把整个游戏的过程告诉了你，他想知道，最早在他的第几次询问之后，可以断定 GD 一定（至少有一次）说了谎。", "inputFormat": "**本题单测试点内有多组数据**。\n\n第一行一个整数 $t$，表示测试数据的组数。    \n\n每组数据的输入格式如下：\n\n每组数据的第一行有三个整数，分别代表棋盘的长度 $n$ 、战舰的种数 $c$ 和攻击的次数 $q$。\n\n对于每组数据的第 $2$ 到第 $(c + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的两个整数分别代表第 $i$ 种战舰的长度 $c_i$ 和数量 $t_i$。\n\n第 $(c + 2)$ 行有 $q$ 个整数，第 $i$ 个整数 $a_i$ 代表 MW 第 $i$ 次攻击的位置。", "outputFormat": "对于每组数据，输出一个整数 $ans$，表示最早在第 $ans$ 次操作后可以断定 GD 说了谎。特别地，如果一开始就不可能按要求摆上所有的战舰，输出 $0$；如果 $q$ 次询问后都不能判断 GD 是否说了谎，则输出 $-1$。", "hint": "#### 样例输入输出 1 解释\n\n- 对于第一个样例，存在布阵 $\\{1,22,22,0,22,22,22\\}$（$0$ 表示没有放置），使得第一次不会受到攻击；不存在一个布阵使得两次都没有受到攻击。\n- 对于第二个样例，存在布阵 $\\{0,333,0\\}$，使得两次均不会受到攻击。\n- 对于第三个样例，一开始就不可能把所有战舰合法地布置在棋盘上。\n\n---\n\n#### 数据规模与约定\n\n- 对于测试点1，$n \\leq 1000000000$，$c \\leq 100000$，$q=0$；\n- 对于测试点2、3，所有的 $t_i$ 均为 $1$；\n- 对于测试点2-8，$n \\leq 400000$，$c \\leq 100$，$q=1$；\n- 对于测试点9，$n \\leq 100$，$c=1$，$q \\leq 100$；\n- 对于测试点10-14，$n \\leq 200000$，$c=1$，$q \\leq 200000$；\n- 对于测试点15、16，$n \\leq 200$，$c=2$，$q \\leq 200$；\n- 对于测试点17-20，$n \\leq 4000$，$c=2$，$q \\leq 4000$。\n- 对于 $100\\%$ 的数据，$1 \\le t \\le 5,n \\ge 1,c \\ge 1,q \\ge 0,1 \\le q_i \\le n,0 \\le c_i \\le 10^5,0 \\le t_i \\le 10^5$。\n\n---\n\n#### 提示\n\n- 请注意常数因子对程序效率造成的影响。\n\n", "locale": "zh-CN"}}}
{"pid": "P2689", "type": "P", "difficulty": 1, "samples": [["1 1\n2 2\n5\nE\nN\nW\nW\nN", "2"], ["1 1\n2 2\n1\nW", "-1"], ["1 1\n2 2\n3\nW\nW\nW", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "搜索", "洛谷原创"], "title": "东南西北", "background": null, "description": "给出起点和终点的坐标，及接下来 $T$ 个时刻的顺风方向（东南西北），每个时刻可以选择顺风偏移 $1$ 个单位或者不移动。求到达终点的**最少移动步数**。\n\n坐标采用平面直角坐标系，$x$ 轴正向为东，$y$ 轴正向为北。\n\n如果无法偏移至终点，输出 $-1$。", "inputFormat": "第一行两个正整数 $x_1,y_1$，表示起点坐标。\n\n第二行两个正整数 $x_2,y_2$，表示终点坐标。\n\n第三行一个整数 $T$，表示 $T$ 个时刻。\n\n第四至第 $T+3$ 行，每行一个字符，表示顺风方向，即东（$\\verb!E!$）南（$\\verb!S!$）西（$\\verb!W!$）北（$\\verb!N!$）的英文单词的首字母。", "outputFormat": "一行一个整数，表示最少移动步数。", "hint": "### 样例解释\n\n- 样例 $1$：向东走一步，向北走一步。\n- 样例 $2,3$：无法到达。\n\n### 数据范围\n\n对于全部数据，$1\\le x_1,y_1,x_2,y_2,T\\le 50$。", "locale": "zh-CN", "translations": {"en": {"title": "East, South, West, North", "background": "", "description": "Given the coordinates of the start and end points, and the wind direction (east, south, west, north) at each of the next $T$ time steps, you may either move $1$ unit with the wind or stay in place at each time step. Find the **minimum number of moves** needed to reach the destination.\n\nThe coordinate system is the Cartesian plane, where the positive $x$-axis points east and the positive $y$-axis points north.\n\nIf it is impossible to reach the destination, output $-1$.", "inputFormat": "The first line contains two positive integers $x_1, y_1$, representing Xiaoming’s current position.\n\nThe second line contains two positive integers $x_2, y_2$, representing the position Xiaoming wants to reach.\n\nThe third line contains an integer $T$, representing $T$ time steps.\n\nFrom line $4$ to line $T+3$, each line contains one character representing the wind direction, i.e., the first letter of the English words for east ($\\verb!E!$), south ($\\verb!S!$), west ($\\verb!W!$), and north ($\\verb!N!$).", "outputFormat": "Output a single integer, the minimum number of moves.", "hint": "Sample Explanation\n\n- Sample $1$: Move one step east, then one step north.\n- Samples $2$ and $3$: Impossible to reach.\n\nConstraints\n\nFor all testdata, $1 \\le T \\le 50$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "东南西北", "background": null, "description": "给出起点和终点的坐标，及接下来 $T$ 个时刻的顺风方向（东南西北），每个时刻可以选择顺风偏移 $1$ 个单位或者不移动。求到达终点的**最少移动步数**。\n\n坐标采用平面直角坐标系，$x$ 轴正向为东，$y$ 轴正向为北。\n\n如果无法偏移至终点，输出 $-1$。", "inputFormat": "第一行两个正整数 $x_1,y_1$，表示起点坐标。\n\n第二行两个正整数 $x_2,y_2$，表示终点坐标。\n\n第三行一个整数 $T$，表示 $T$ 个时刻。\n\n第四至第 $T+3$ 行，每行一个字符，表示顺风方向，即东（$\\verb!E!$）南（$\\verb!S!$）西（$\\verb!W!$）北（$\\verb!N!$）的英文单词的首字母。", "outputFormat": "一行一个整数，表示最少移动步数。", "hint": "### 样例解释\n\n- 样例 $1$：向东走一步，向北走一步。\n- 样例 $2,3$：无法到达。\n\n### 数据范围\n\n对于全部数据，$1\\le x_1,y_1,x_2,y_2,T\\le 50$。", "locale": "zh-CN"}}}
{"pid": "P2690", "type": "P", "difficulty": 3, "samples": [["7 2\n2\n1\n1\n2\n2\n1\n1\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "2004", "USACO", "记忆化搜索"], "title": "[USACO04NOV] Apple Catching G", "background": "", "description": "很少有人知道奶牛爱吃苹果。农夫约翰的农场上有两棵苹果树（编号为 $1$ 和 $2$ ）， 每一棵树上都长满了苹果。奶牛贝茜无法摘下树上的苹果，所以她只能等待苹果 从树上落下。但是，由于苹果掉到地上会摔烂，贝茜必须在半空中接住苹果（没有人爱吃摔烂的苹果）。贝茜吃东西很快，她接到苹果后仅用几秒钟就能吃完。每一分钟，两棵苹果树其中的一棵会掉落一个苹果。贝茜已经过了足够的训练， 只要站在树下就一定能接住这棵树上掉落的苹果。同时，贝茜能够在两棵树之间 快速移动（移动时间远少于 $1$ 分钟），因此当苹果掉落时，她必定站在两棵树其中的一棵下面。此外，奶牛不愿意不停地往返于两棵树之间，因此会错过一些苹果。苹果每分钟掉落一个，共 $T$（$1 \\le T \\le 1000$）分钟，贝茜最多愿意移动 $W$（$1 \\le W \\le 30$） 次。现给出每分钟掉落苹果的树的编号，要求判定贝茜能够接住的最多苹果数。 开始时贝茜在 1 号树下。", "inputFormat": "第一行 $2$ 个数， $T$ 和 $W$。接下来的 $t$ 行，每行一个数，代表在时刻 $t$ 苹果是从 $1$ 号苹果树还是从 $2$ 号苹果树上掉下来的。", "outputFormat": "对于每个测试点，输出一行，一个数，为奶牛最多接到的苹果的数量。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[USACO04NOV] Apple Catching G", "background": "", "description": "Few people know that cows love apples. There are two apple trees on Farmer John's farm (numbered $1$ and $2$), and both are laden with apples. Bessie the cow cannot pick apples from the trees, so she must wait for apples to fall. However, since apples that hit the ground get smashed, Bessie must catch them in midair (nobody likes smashed apples). Bessie eats quickly and can finish an apple within a few seconds after catching it.\n\nEvery minute, exactly one of the two trees drops one apple. Bessie is well trained: as long as she stands under a tree, she is guaranteed to catch any apple that falls from that tree. She can move quickly between the two trees (the moving time is much less than $1$ minute), so when an apple falls, she will definitely be standing under one of the two trees. However, she is unwilling to keep running back and forth between the trees, so she may miss some apples.\n\nApples fall once per minute for $T$ minutes ($1 \\le T \\le 1000$). Bessie is willing to move at most $W$ times ($1 \\le W \\le 30$). Given, for each minute, the index of the tree from which an apple falls, determine the maximum number of apples Bessie can catch. Initially, Bessie is under tree 1.", "inputFormat": "The first line contains 2 integers, $T$ and $W$. The next $T$ lines each contain one integer, indicating whether at that minute the apple falls from tree $1$ or tree $2$.", "outputFormat": "For each test case, output one line with a single integer: the maximum number of apples Bessie can catch.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO04NOV] Apple Catching G", "background": "", "description": "很少有人知道奶牛爱吃苹果。农夫约翰的农场上有两棵苹果树（编号为 $1$ 和 $2$ ）， 每一棵树上都长满了苹果。奶牛贝茜无法摘下树上的苹果，所以她只能等待苹果 从树上落下。但是，由于苹果掉到地上会摔烂，贝茜必须在半空中接住苹果（没有人爱吃摔烂的苹果）。贝茜吃东西很快，她接到苹果后仅用几秒钟就能吃完。每一分钟，两棵苹果树其中的一棵会掉落一个苹果。贝茜已经过了足够的训练， 只要站在树下就一定能接住这棵树上掉落的苹果。同时，贝茜能够在两棵树之间 快速移动（移动时间远少于 $1$ 分钟），因此当苹果掉落时，她必定站在两棵树其中的一棵下面。此外，奶牛不愿意不停地往返于两棵树之间，因此会错过一些苹果。苹果每分钟掉落一个，共 $T$（$1 \\le T \\le 1000$）分钟，贝茜最多愿意移动 $W$（$1 \\le W \\le 30$） 次。现给出每分钟掉落苹果的树的编号，要求判定贝茜能够接住的最多苹果数。 开始时贝茜在 1 号树下。", "inputFormat": "第一行 $2$ 个数， $T$ 和 $W$。接下来的 $t$ 行，每行一个数，代表在时刻 $t$ 苹果是从 $1$ 号苹果树还是从 $2$ 号苹果树上掉下来的。", "outputFormat": "对于每个测试点，输出一行，一个数，为奶牛最多接到的苹果的数量。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2691", "type": "P", "difficulty": 5, "samples": [["6\n10\n2 2\n2 4\n2 6\n3 1\n3 2\n3 4\n3 6\n4 2\n4 4\n4 6\n", "YES"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["图论"], "title": "逃离", "background": "", "description": "**译自 CLRS Problem 26-1 Escape problem**\n\n在一个 $n\\times n$ 的网格中有 $m$ 个起始点 $(x_1, y_1),$ $(x_2, y_2),$ $\\dots,$ $(x_m, y_m)$，试问：能否为这些结点分别找一条到边界的路径，且这 $m$ 条路径互不相交（即任意两条路径上没有一个相同的结点）。\n\n![https://i.loli.net/2018/10/14/5bc2ec2948f8b.png](https://i.loli.net/2018/10/14/5bc2ec2948f8b.png)\n\n黑点表示起始点，其他点用白点表示。找出的路径用加粗的线表示。图 (a) 存在符合条件的 $m$ 条路径，图 (b) 则不存在。\n\n", "inputFormat": "第一行是一个整数，为 $n$ $(1\\le n≤35)$。\n\n第二行还是一个整数，为 $m(1\\le m\\le n^2)$。\n\n以下 $m$ 行，第 $(i+2)$ 行包含两个整数 $x_i$ 和 $y_i$，表示第 $i$ 行第 $j$ 列的点是起始点。保证起始点坐标互不相同。", "outputFormat": "只包括一行。若存在逃脱输出 `YES`，不存在逃脱输出 `NO`。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Escape", "background": "", "description": "Translated from CLRS Problem 26-1: Escape problem.\n\nIn an $n \\times n$ grid, there are $m$ starting points $(x_1, y_1)$, $(x_2, y_2)$, $\\dots$, $(x_m, y_m)$. Determine whether it is possible to find a path for each starting point to the boundary such that these $m$ paths are pairwise disjoint (that is, no two paths share any point).\n\n![https://i.loli.net/2018/10/14/5bc2ec2948f8b.png](https://i.loli.net/2018/10/14/5bc2ec2948f8b.png)\n\nBlack dots indicate starting points, and other points are white. The found paths are shown with bold lines. In figure (a), there exist $m$ valid paths; in figure (b), there do not.", "inputFormat": "The first line contains an integer $n$ ($1 \\le n \\le 35$).\n\nThe second line contains an integer $m$ ($1 \\le m \\le n^2$).\n\nEach of the following $m$ lines, the $(i + 2)$-th line, contains two integers $x_i$ and $y_i$, meaning that the point at row $x_i$, column $y_i$ is a starting point. The starting points are guaranteed to be distinct.", "outputFormat": "Output a single line. If an escape exists, output `YES`; otherwise, output `NO`.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "逃离", "background": "", "description": "**译自 CLRS Problem 26-1 Escape problem**\n\n在一个 $n\\times n$ 的网格中有 $m$ 个起始点 $(x_1, y_1),$ $(x_2, y_2),$ $\\dots,$ $(x_m, y_m)$，试问：能否为这些结点分别找一条到边界的路径，且这 $m$ 条路径互不相交（即任意两条路径上没有一个相同的结点）。\n\n![https://i.loli.net/2018/10/14/5bc2ec2948f8b.png](https://i.loli.net/2018/10/14/5bc2ec2948f8b.png)\n\n黑点表示起始点，其他点用白点表示。找出的路径用加粗的线表示。图 (a) 存在符合条件的 $m$ 条路径，图 (b) 则不存在。\n\n", "inputFormat": "第一行是一个整数，为 $n$ $(1\\le n≤35)$。\n\n第二行还是一个整数，为 $m(1\\le m\\le n^2)$。\n\n以下 $m$ 行，第 $(i+2)$ 行包含两个整数 $x_i$ 和 $y_i$，表示第 $i$ 行第 $j$ 列的点是起始点。保证起始点坐标互不相同。", "outputFormat": "只包括一行。若存在逃脱输出 `YES`，不存在逃脱输出 `NO`。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P2692", "type": "P", "difficulty": 2, "samples": [["4 5 2 2\n1 2\n4 4\n3 4\n4 5", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "覆盖", "background": "WSR 的学校有 $B$ 个男生和 $G$ 个女生都来到一个巨大的操场上扫地。", "description": "操场可以看成是 $N$ 行 $M$ 列的方格矩阵，如下图 (1) 是一个 $4$ 行 $5$ 列的方格矩阵。每个男生负责打扫一些连续的行，每个女生负责打扫一些连续的列。比如有两个男生，第一个男生负责第 $1, 2$ 两行、第二个男生负责第 $4$ 行，如图 (2) 的蓝色。打扫的区域可能重复，比如，又有两个女生，第一个女生负责打扫第 $3, 4$ 两列，第二个女生负责打扫第 $4, 5$ 两列，如图 (3) 的红色。从图 (3) 可以容易看出，有颜色覆盖的方格数为 $18$，即这 $4$ 名学生总共打扫了 $18$ 个方格。\n\n![](https://cdn.luogu.com.cn/upload/pic/1474.png) \n\n老师要 WSR 在学校给出打扫安排的数据后快速计算出这些学生总共打扫了多少方格。", "inputFormat": "第一行 $4$ 个正整数：$N, M, B, G$。其中 $N$ 表示方阵行数，$M$ 表示方阵列数，$B$ 表示男生数，$G$ 表示女生数。\n\n接下来 $B$ 行，每行两个整数 $x, y$。表示相应某个男生负责打扫从第 $x$ 行到第 $y$ 行（共 $y - x + 1$ 行），保证 $1 \\le x \\le y \\le N$。\n\n再接下来 $G$ 行，每行两个整数 $x, y$。表示相应某个女生负责打扫从第 $x$ 列到第 $y$ 列（共 $y - x + 1$ 列），保证 $1 \\le x \\le y \\le M$。", "outputFormat": "一个整数，表示所打扫的面积。（即格子的总数）", "hint": "不会可以自己画图。\n\n### 数据范围与约定\n\n对于 $80\\%$ 的数据，$1 \\le N,M,B,G \\le 10^2$。\n\n对于 $100\\%$ 的数据，$ 1 \\le N,M,B,G \\le 5 \\times 10^3$。", "locale": "zh-CN", "translations": {"en": {"title": "Coverage", "background": "In WSR's school, $B$ boys and $G$ girls have come to a huge playground to sweep the ground.", "description": "The playground can be viewed as an $N$-by-$M$ grid of cells. As shown in Figure (1), this is a $4$-by-$5$ grid. Each boy is responsible for sweeping some consecutive rows, and each girl is responsible for sweeping some consecutive columns. For example, suppose there are two boys: the first boy is responsible for rows $1, 2$, and the second boy is responsible for row $4$, shown in blue in Figure (2). The swept regions may overlap. For instance, suppose there are also two girls: the first girl is responsible for columns $3, 4$, and the second girl is responsible for columns $4, 5$, shown in red in Figure (3). From Figure (3), it is easy to see that the number of colored cells is 18, i.e., these four students have swept a total of 18 cells.\n\n![](https://cdn.luogu.com.cn/upload/pic/1474.png)\n\nThe teacher asks WSR to quickly compute, given the cleaning plan data, how many cells have been swept in total.", "inputFormat": "The first line contains $4$ positive integers: $N, M, B, G$. Here, $N$ is the number of rows, $M$ is the number of columns, $B$ is the number of boys, and $G$ is the number of girls.\n\nThe next $B$ lines each contain two integers $x, y$. Each line indicates that a boy is responsible for rows $x$ through $y$ inclusive (a total of $y - x + 1$ rows), with the guarantee that $1 \\le x \\le y \\le N$.\n\nThen the next $G$ lines each contain two integers $x, y$. Each line indicates that a girl is responsible for columns $x$ through $y$ inclusive (a total of $y - x + 1$ columns), with the guarantee that $1 \\le x \\le y \\le M$.", "outputFormat": "Output a single integer, the swept area (i.e., the total number of cells).", "hint": "If you are not sure, try drawing a diagram yourself.\n\nConstraints:\n- For $80\\%$ of the testdata, $1 \\le N,M,B,G \\le 10^2$.\n- For $100\\%$ of the testdata, $ 1 \\le N,M,B,G \\le 5 \\times 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "覆盖", "background": "WSR 的学校有 $B$ 个男生和 $G$ 个女生都来到一个巨大的操场上扫地。", "description": "操场可以看成是 $N$ 行 $M$ 列的方格矩阵，如下图 (1) 是一个 $4$ 行 $5$ 列的方格矩阵。每个男生负责打扫一些连续的行，每个女生负责打扫一些连续的列。比如有两个男生，第一个男生负责第 $1, 2$ 两行、第二个男生负责第 $4$ 行，如图 (2) 的蓝色。打扫的区域可能重复，比如，又有两个女生，第一个女生负责打扫第 $3, 4$ 两列，第二个女生负责打扫第 $4, 5$ 两列，如图 (3) 的红色。从图 (3) 可以容易看出，有颜色覆盖的方格数为 $18$，即这 $4$ 名学生总共打扫了 $18$ 个方格。\n\n![](https://cdn.luogu.com.cn/upload/pic/1474.png) \n\n老师要 WSR 在学校给出打扫安排的数据后快速计算出这些学生总共打扫了多少方格。", "inputFormat": "第一行 $4$ 个正整数：$N, M, B, G$。其中 $N$ 表示方阵行数，$M$ 表示方阵列数，$B$ 表示男生数，$G$ 表示女生数。\n\n接下来 $B$ 行，每行两个整数 $x, y$。表示相应某个男生负责打扫从第 $x$ 行到第 $y$ 行（共 $y - x + 1$ 行），保证 $1 \\le x \\le y \\le N$。\n\n再接下来 $G$ 行，每行两个整数 $x, y$。表示相应某个女生负责打扫从第 $x$ 列到第 $y$ 列（共 $y - x + 1$ 列），保证 $1 \\le x \\le y \\le M$。", "outputFormat": "一个整数，表示所打扫的面积。（即格子的总数）", "hint": "不会可以自己画图。\n\n### 数据范围与约定\n\n对于 $80\\%$ 的数据，$1 \\le N,M,B,G \\le 10^2$。\n\n对于 $100\\%$ 的数据，$ 1 \\le N,M,B,G \\le 5 \\times 10^3$。", "locale": "zh-CN"}}}
{"pid": "P2693", "type": "P", "difficulty": 2, "samples": [["50\n1 2 3\n5 6 7\n", "249"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "USACO", "枚举"], "title": "[USACO1.3] 号码锁 Combination Lock", "background": "感谢 @[Fond_Dream](https://www.luogu.com.cn/user/321680) 提供五道 USACO 题目的标准题面。", "description": "农夫约翰的奶牛不停地从他的农场中逃出来，导致了很多损害。为了防止它们再逃出来，他买了一只很大的号码锁以防止奶牛们打开牧场的门。\n\n农夫约翰知道他的奶牛很聪明，所以他希望确保它们不会在简单地试了很多不同的号码组合之后就能轻易开锁。锁上有三个转盘，每个上面有数字 $1$ ~ $n$，因为转盘是圆的，所以 $1$ 和 $n$ 是相邻的。有两种能开锁的号码组合，一种是农夫约翰设定的，还有一种“预设”号码组合是锁匠设定的。但是，锁有一定的容错性，所以，在每个转盘上的数字都与一个合法的号码组合中相应的数字相距两个位置以内时，锁也会打开。\n\n比如说，如果农夫约翰的号码组合是 ( $1$ , $2$ , $3$ )，预设号码组合是 ( $4$ , $5$ , $6$ )，在转盘被设定为 ( $1$ , $4$ , $5$)（因为这和农夫约翰的号码组合足够接近）或 ( $2$ , $4$ , $8$ )（因为这和预设号码组合足够接近）时可以打开锁。注意，( $1$ , $5$ , $6$ )并不会打开锁，因为它与任一号码组合都不够接近。\n\n给出农夫约翰的号码组合和预设号码组合，请计算能够开锁的不同的号码组合的数目。号码是有序的，所以 ( $1$ , $2$ , $3$ ) 与 ( $3$ , $2$ , $1$ ) 不同。\n", "inputFormat": "输入的第一行是一个整数 $n$，代表锁上的数字个数。\n\n输入的第二行有三个整数 $x, y, z$，代表农夫约翰的号码组合。\n\n输入的第三行有三个整数 $a, b, c$，代表预设的号码组合。", "outputFormat": "输出一行一个整数代表能够开锁的组合数目。", "hint": "#### 输入输出样例 1 解释\n\n每个转盘的标号是 $1$ ~ $50$。农夫约翰的号码组合是 ( $1$ , $2$ , $3$ )，预设号码组合是 ( $5$ , $6$ , $7$ )。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 100$，$1 \\leq x, y, z, a, b, c \\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO1.3] Combination Lock", "background": "Thanks to @[Fond_Dream](https://www.luogu.com.cn/user/321680) for providing the standard statements for five USACO problems.", "description": "Farmer John’s cows keep escaping from his farm, causing a lot of damage. To prevent them from escaping again, he buys a large combination lock to secure the pasture gate.\n\nFarmer John knows his cows are smart, so he wants to make sure they cannot easily open the lock by simply trying many different number combinations. The lock has three dials, each labeled with the numbers $1$ to $n$. Because the dials are circular, $1$ and $n$ are adjacent. There are two combinations that can open the lock: one set by Farmer John, and another “preset” combination set by the locksmith. However, the lock has some tolerance: if on each dial the chosen number is within two positions (inclusive) of the corresponding number in some valid combination, the lock will also open.\n\nFor example, if Farmer John’s combination is ( $1$ , $2$ , $3$ ) and the preset combination is ( $4$ , $5$ , $6$ ), then the lock will open when the dials are set to ( $1$ , $4$ , $5$ ) (because this is close enough to Farmer John’s combination) or ( $2$ , $4$ , $8$ ) (because this is close enough to the preset combination). Note that ( $1$ , $5$ , $6$ ) will not open the lock because it is not close enough to either combination.\n\nGiven Farmer John’s combination and the preset combination, compute the number of distinct combinations that open the lock. The numbers are ordered, so ( $1$ , $2$ , $3$ ) is different from ( $3$ , $2$ , $1$ ).", "inputFormat": "The first line contains an integer $n$, representing the number of numbers on each dial.\n\nThe second line contains three integers $x, y, z$, representing Farmer John’s combination.\n\nThe third line contains three integers $a, b, c$, representing the preset combination.", "outputFormat": "Output a single integer on one line representing the number of combinations that open the lock.", "hint": "Explanation for Sample 1.\n\nEach dial is labeled $1$ to $50$. Farmer John’s combination is ( $1$ , $2$ , $3$ ), and the preset combination is ( $5$ , $6$ , $7$ ).\n\nConstraints.\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 100$, $1 \\leq x, y, z, a, b, c \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO1.3] 号码锁 Combination Lock", "background": "感谢 @[Fond_Dream](https://www.luogu.com.cn/user/321680) 提供五道 USACO 题目的标准题面。", "description": "农夫约翰的奶牛不停地从他的农场中逃出来，导致了很多损害。为了防止它们再逃出来，他买了一只很大的号码锁以防止奶牛们打开牧场的门。\n\n农夫约翰知道他的奶牛很聪明，所以他希望确保它们不会在简单地试了很多不同的号码组合之后就能轻易开锁。锁上有三个转盘，每个上面有数字 $1$ ~ $n$，因为转盘是圆的，所以 $1$ 和 $n$ 是相邻的。有两种能开锁的号码组合，一种是农夫约翰设定的，还有一种“预设”号码组合是锁匠设定的。但是，锁有一定的容错性，所以，在每个转盘上的数字都与一个合法的号码组合中相应的数字相距两个位置以内时，锁也会打开。\n\n比如说，如果农夫约翰的号码组合是 ( $1$ , $2$ , $3$ )，预设号码组合是 ( $4$ , $5$ , $6$ )，在转盘被设定为 ( $1$ , $4$ , $5$)（因为这和农夫约翰的号码组合足够接近）或 ( $2$ , $4$ , $8$ )（因为这和预设号码组合足够接近）时可以打开锁。注意，( $1$ , $5$ , $6$ )并不会打开锁，因为它与任一号码组合都不够接近。\n\n给出农夫约翰的号码组合和预设号码组合，请计算能够开锁的不同的号码组合的数目。号码是有序的，所以 ( $1$ , $2$ , $3$ ) 与 ( $3$ , $2$ , $1$ ) 不同。\n", "inputFormat": "输入的第一行是一个整数 $n$，代表锁上的数字个数。\n\n输入的第二行有三个整数 $x, y, z$，代表农夫约翰的号码组合。\n\n输入的第三行有三个整数 $a, b, c$，代表预设的号码组合。", "outputFormat": "输出一行一个整数代表能够开锁的组合数目。", "hint": "#### 输入输出样例 1 解释\n\n每个转盘的标号是 $1$ ~ $50$。农夫约翰的号码组合是 ( $1$ , $2$ , $3$ )，预设号码组合是 ( $5$ , $6$ , $7$ )。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 100$，$1 \\leq x, y, z, a, b, c \\leq n$。", "locale": "zh-CN"}}}
{"pid": "P2694", "type": "P", "difficulty": 2, "samples": [["5\n3\n-1 1\n1 3\n0 4\n1\n-3 2\n3\n-1 1\n1 2\n0 4\n3\n0 9\n-1 1\n1 3\n8\n70 141\n-108 299\n52 402\n-70 280\n84 28\n-29 363\n66 427\n-33 232\n", "Abletocatch\nNotabletocatch\nNotabletocatch\nAbletocatch\nNotabletocatch\n"]], "limits": {"time": [869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869, 869], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "USACO"], "title": "接金币", "background": "", "description": "在二维坐标系里，有 $n$ 个金币，编号 $0\\sim n-1$。初始时，第 $i$ 个金币位于 $(x_i,y_i)$。所有的金币每秒向下垂直下降 $1$ 个单位高度。例如有个金币当前坐标是 $(x,y)$，那么 $t$ 秒后金币所在的位置就是$(x,y-t)$。初始时，FJ 在 $(0,0)$ 处，FJ 每秒只能向左右移动 $1$ 个单位距离，当然 FJ 也可以不移动。如果在某个时刻某个金币和 FJ 所在的位置重合，那么 FJ 就能接住这个金币。求 FJ 能否把所有的金币都接住，如果行输出 $\\texttt{Abletocatch}$，否则输出 $\\texttt{Notabletocatch}$。\n", "inputFormat": "本题有 $g$ 组数据。\n\n第一行，一个整数 $g$，表示有 $g$ 组测试数据。\n\n对于每组测试数据，格式如下：\n\n第一行，一个整数 $n$。\n\n接下来有 $n$ 行，第 $i$ 行两个整数表示 $x_i,y_i$。", "outputFormat": "共 $g$ 行，每行输出 $\\texttt{Abletocatch}$ 或 $\\texttt{Notabletocatch}$。\n", "hint": "对于所有数据，$1\\le g\\le5$，$1\\le n\\le50$，$-10^3\\le x_i\\le10^3$，$0\\le y_i\\le10^3$。\n\n> **tips：测试点与样例描述不符，实际上每组数据之间有个换行。**", "locale": "zh-CN", "translations": {"en": {"title": "Catching Coins", "background": "", "description": "In a 2D coordinate system, there are $n$ coins, numbered $0\\sim n-1$. Initially, the $i$-th coin is at $(x_i,y_i)$. All coins fall vertically downward by $1$ unit of height per second. For example, if a coin is currently at $(x,y)$, then after $t$ seconds its position will be $(x,y-t)$. Initially, FJ is at $(0,0)$. FJ can move left or right by $1$ unit per second, and FJ may also stay still. If at some moment a coin’s position coincides with FJ’s position, then FJ can catch that coin. Determine whether FJ can catch all the coins. If yes, output $\\texttt{Abletocatch}$, otherwise output $\\texttt{Notabletocatch}$.", "inputFormat": "This problem has $g$ groups of testdata.\n\nThe first line contains an integer $g$, indicating there are $g$ groups of testdata.\n\nFor each group of testdata, the format is as follows:\n\n- The first line contains an integer $n$.\n- The next $n$ lines each contain two integers, representing $x_i,y_i$ for the $i$-th coin.", "outputFormat": "Output $g$ lines. For each group, output $\\texttt{Abletocatch}$ or $\\texttt{Notabletocatch}$.", "hint": "For all testdata, $1 \\le g \\le 5$, $1 \\le n \\le 50$, $-10^3 \\le x_i \\le 10^3$, $0 \\le y_i \\le 10^3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "接金币", "background": "", "description": "在二维坐标系里，有 $n$ 个金币，编号 $0\\sim n-1$。初始时，第 $i$ 个金币位于 $(x_i,y_i)$。所有的金币每秒向下垂直下降 $1$ 个单位高度。例如有个金币当前坐标是 $(x,y)$，那么 $t$ 秒后金币所在的位置就是$(x,y-t)$。初始时，FJ 在 $(0,0)$ 处，FJ 每秒只能向左右移动 $1$ 个单位距离，当然 FJ 也可以不移动。如果在某个时刻某个金币和 FJ 所在的位置重合，那么 FJ 就能接住这个金币。求 FJ 能否把所有的金币都接住，如果行输出 $\\texttt{Abletocatch}$，否则输出 $\\texttt{Notabletocatch}$。\n", "inputFormat": "本题有 $g$ 组数据。\n\n第一行，一个整数 $g$，表示有 $g$ 组测试数据。\n\n对于每组测试数据，格式如下：\n\n第一行，一个整数 $n$。\n\n接下来有 $n$ 行，第 $i$ 行两个整数表示 $x_i,y_i$。", "outputFormat": "共 $g$ 行，每行输出 $\\texttt{Abletocatch}$ 或 $\\texttt{Notabletocatch}$。\n", "hint": "对于所有数据，$1\\le g\\le5$，$1\\le n\\le50$，$-10^3\\le x_i\\le10^3$，$0\\le y_i\\le10^3$。\n\n> **tips：测试点与样例描述不符，实际上每组数据之间有个换行。**", "locale": "zh-CN"}}}
{"pid": "P2695", "type": "P", "difficulty": 2, "samples": [["2 3\n5 \n4\n7 \n8\n4", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "排序"], "title": "骑士的工作", "background": "你作为一个村的村长，保卫村庄是理所当然的了。今天，村庄里来了一只恶龙，他有 $n$ 个头，恶龙到处杀人放火。你着急了。不过天无绝人之路，现在来了一个骑士团。里面有 $m$ 位成员（往下看）。", "description": "每个人都可以砍掉**至多**一个大小不超过 $z_i$ 的头，需要 $z_i$ 个金币，求最小花费。", "inputFormat": "第一行两个整数 $n$，$m$。\n\n下接 $n$ 行，第 $i$ 个整数 $a_i$，表示第 $i$ 个头的大小。\n\n下接 $m$ 行，每个人可以砍的头大小和需要的金币数 $z_1, \\cdots, z_m$。", "outputFormat": "一个整数，最小花费。如果无解，输出 `you died!`。", "hint": "对于所有数据，$1 \\le n,m \\le 2 \\times 10^4$，$1 \\leq a_i,z_i \\leq 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "The Knight's Job", "background": "As the village chief, it is your duty to defend the village. Today, a dragon has come with $n$ heads, wreaking havoc everywhere. You are anxious. Fortunately, a group of knights has arrived. There are $m$ members in the group.", "description": "Each person can cut off at most one head of size not exceeding $z_i$, and it costs $z_i$ coins. Find the minimum total cost.", "inputFormat": "- The first line contains two integers $n$, $m$.\n- The next $n$ lines each contain one integer, the size of a head.\n- The next $m$ lines each contain one integer $z_i$, the maximum head size the $i$-th person can cut and the number of coins required.", "outputFormat": "Output a single integer, the minimum total cost. If it is impossible, output `you died!`.", "hint": "For all testdata, $1 \\le n, m \\le 2 \\times 10^4$, $1 \\le z_i \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "骑士的工作", "background": "你作为一个村的村长，保卫村庄是理所当然的了。今天，村庄里来了一只恶龙，他有 $n$ 个头，恶龙到处杀人放火。你着急了。不过天无绝人之路，现在来了一个骑士团。里面有 $m$ 位成员（往下看）。", "description": "每个人都可以砍掉**至多**一个大小不超过 $z_i$ 的头，需要 $z_i$ 个金币，求最小花费。", "inputFormat": "第一行两个整数 $n$，$m$。\n\n下接 $n$ 行，第 $i$ 个整数 $a_i$，表示第 $i$ 个头的大小。\n\n下接 $m$ 行，每个人可以砍的头大小和需要的金币数 $z_1, \\cdots, z_m$。", "outputFormat": "一个整数，最小花费。如果无解，输出 `you died!`。", "hint": "对于所有数据，$1 \\le n,m \\le 2 \\times 10^4$，$1 \\leq a_i,z_i \\leq 10^5$。", "locale": "zh-CN"}}}
{"pid": "P2696", "type": "P", "difficulty": 3, "samples": [["10", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["递推", "递归", "数论"], "title": "慈善的约瑟夫", "background": null, "description": "你一定听说过约瑟夫问题吧？即从 $N$ 个人中找出唯一的幸存者。现在老约瑟夫将组织一个皆大欢喜的新游戏，假设 $N$ 个人站成一圈，从第 $1$ 人开始交替的去掉游戏者，但只是暂时去掉，直到最后剩下唯一的幸存者为止。幸存者选出后，所有比幸存者号码高的人每人得到 $1$ 个金币，永久性离开。其余剩下的将重复以上的游戏过程，比幸存者号码大的人每人得到 $1$ 个金币后离开。经过若干轮这样的过程后，一旦人数不再减少，则最后剩下的那些人将得到 $2$ 个金币。请你计算一下老约瑟夫一共要付出多少钱？", "inputFormat": "一行一个正整数 $N$ 表示人数。", "outputFormat": "一行一个正整数表示共需支付的钱数。", "hint": "$1\\le N \\le 10^5$", "locale": "zh-CN", "translations": {"en": {"title": "Charitable Josephus", "background": "", "description": "You have probably heard of the Josephus problem, which finds the unique survivor among $N$ people. Now Old Josephus is organizing a new game that makes everyone happy. Suppose $N$ people stand in a circle. Starting from person 1, players are removed alternately (i.e., every other player), but only temporarily, until only one survivor remains. After the survivor is selected, every person whose number is greater than the survivor's number receives 1 gold coin and leaves permanently. The remaining people then repeat the above process; after selecting a survivor, everyone with a number larger than that survivor's number receives 1 gold coin and leaves. After several such rounds, once the number of people no longer decreases, the remaining people each receive 2 gold coins. Please compute the total amount of money Old Josephus has to pay.", "inputFormat": "A single line containing a positive integer $N$ representing the number of people.", "outputFormat": "A single line containing a positive integer representing the total amount of money to be paid.", "hint": "Constraints: $1\\le N \\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "慈善的约瑟夫", "background": null, "description": "你一定听说过约瑟夫问题吧？即从 $N$ 个人中找出唯一的幸存者。现在老约瑟夫将组织一个皆大欢喜的新游戏，假设 $N$ 个人站成一圈，从第 $1$ 人开始交替的去掉游戏者，但只是暂时去掉，直到最后剩下唯一的幸存者为止。幸存者选出后，所有比幸存者号码高的人每人得到 $1$ 个金币，永久性离开。其余剩下的将重复以上的游戏过程，比幸存者号码大的人每人得到 $1$ 个金币后离开。经过若干轮这样的过程后，一旦人数不再减少，则最后剩下的那些人将得到 $2$ 个金币。请你计算一下老约瑟夫一共要付出多少钱？", "inputFormat": "一行一个正整数 $N$ 表示人数。", "outputFormat": "一行一个正整数表示共需支付的钱数。", "hint": "$1\\le N \\le 10^5$", "locale": "zh-CN"}}}
{"pid": "P2697", "type": "P", "difficulty": 3, "samples": [["GRGGRG", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["洛谷原创", "前缀和"], "title": "宝石串", "background": "", "description": "有一种宝石串，由绿宝石和红宝石串成，仅当绿宝石和红宝石数目相同的时候，宝石串才最为稳定，不易断裂。安安想知道从给定的宝石串中，可以截取一段最长的稳定的宝石串，有多少颗宝石组成。请你帮助他。\n\n绿宝石用 $\\texttt G$ 表示，红宝石用 $\\texttt R$ 表示。\n", "inputFormat": "一行，一个由 $\\texttt G$ 和 $\\texttt R$ 组成的字符串。\n", "outputFormat": "一行一个整数，表示最长的稳定的宝石串有多少颗宝石组成。\n", "hint": "$\\texttt {RGGR}$ 为答案。\n\n宝石数小于等于 $10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Gem String", "background": "", "description": "There is a kind of gem string made of emeralds and rubies. The string is most stable and least likely to break only when the numbers of emeralds and rubies are equal. An An wants to know, from a given gem string, how many gems the longest stable substring contains. Please help him.\n\nEmeralds are denoted by $\\texttt G$, and rubies are denoted by $\\texttt R$.", "inputFormat": "One line, a string consisting of $\\texttt G$ and $\\texttt R$.", "outputFormat": "One line with an integer, the number of gems in the longest stable gem string.", "hint": "$\\texttt {RGGR}$ is the answer.\n\nConstraints: the number of gems is at most $10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "宝石串", "background": "", "description": "有一种宝石串，由绿宝石和红宝石串成，仅当绿宝石和红宝石数目相同的时候，宝石串才最为稳定，不易断裂。安安想知道从给定的宝石串中，可以截取一段最长的稳定的宝石串，有多少颗宝石组成。请你帮助他。\n\n绿宝石用 $\\texttt G$ 表示，红宝石用 $\\texttt R$ 表示。\n", "inputFormat": "一行，一个由 $\\texttt G$ 和 $\\texttt R$ 组成的字符串。\n", "outputFormat": "一行一个整数，表示最长的稳定的宝石串有多少颗宝石组成。\n", "hint": "$\\texttt {RGGR}$ 为答案。\n\n宝石数小于等于 $10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P2698", "type": "P", "difficulty": 4, "samples": [["4 5\n6 3\n2 4\n4 10\n12 15", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2012", "二分", "USACO", "单调队列"], "title": "[USACO12MAR] Flowerpot S", "background": null, "description": "![](https://cdn.luogu.com.cn/upload/pic/9174.png) \n\n老板需要你帮忙浇花。给出 $N$ 滴水的坐标，$(x,y)$ 表示水滴最初的坐标。\n\n每滴水均以每秒 $1$ 个单位长度的速度下落。你需要把花盆放在 $x$ 轴上的某个位置，使得花盆接到第 $1$ 滴水与最后 $1$ 滴水之间的时间差至少为 $D$。\n\n如果水滴落在 $x$ 轴上的位置与花盆的边沿对齐，也认为被接住。\n\n给出 $N$ 滴水的坐标和时间差 $D$ ，请算出最小的花盆宽度 $W$。", "inputFormat": "第一行 $2$ 个整数 $N$ 和 $D$。\n\n接下来 $N$ 行，每行 $2$ 个整数，表示水滴的坐标 $(x,y)$。", "outputFormat": "一行 $1$ 个整数，表示最小的花盆宽度。如果无法构造出满足题意的花盆，则输出 $-1$。", "hint": "**【样例解释】**\n\n有 $4$ 滴水，初始位置分别在 $(6,3)$，$(2,4)$，$(4,10)$，$(12,15)$。水滴至少用 $5$ 秒时间先后落入花盆。花盆的宽度为 $2$ 是必须且足够的，此时把花盆放在 $x=4\\dots6$ 的位置，它可以接到水滴 $1$ 和 $3$ ，之间的时间差为 $10-3=7$，满足条件。\n\n**【数据范围】**\n\n$40\\%$ 的数据：$1 \\le N \\le 1000$ ，$1 \\le D \\le 2000$。\n\n$100\\%$ 的数据：$1 \\le N \\le 10 ^ 5$，$1 \\le D \\le 10 ^ 6$，$0\\le x,y\\le10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO12MAR] Flowerpot S", "background": null, "description": "Farmer John has been having trouble making his plants grow, and needs your help to water them properly.  You are given the locations of N raindrops (1 <= N <= 100,000) in the 2D plane, where y represents vertical height of the drop, and x represents its location over a 1D number line:\n\n ![](https://cdn.luogu.com.cn/upload/pic/9174.png) \n\nEach drop falls downward (towards the x axis) at a rate of 1 unit per second.  You would like to place Farmer John's flowerpot of width W somewhere along the x axis so that the difference in time between the first raindrop to hit the flowerpot and the last raindrop to hit the flowerpot is at least some amount D (so that the flowers in the pot receive plenty of water).  A drop of water that lands just on the edge of the flowerpot counts as hitting the flowerpot. \n\nGiven the value of D and the locations of the N raindrops, please compute the minimum possible value of W.", "inputFormat": null, "outputFormat": null, "hint": null, "locale": "en"}, "zh-CN": {"title": "[USACO12MAR] Flowerpot S", "background": null, "description": "![](https://cdn.luogu.com.cn/upload/pic/9174.png) \n\n老板需要你帮忙浇花。给出 $N$ 滴水的坐标，$(x,y)$ 表示水滴最初的坐标。\n\n每滴水均以每秒 $1$ 个单位长度的速度下落。你需要把花盆放在 $x$ 轴上的某个位置，使得花盆接到第 $1$ 滴水与最后 $1$ 滴水之间的时间差至少为 $D$。\n\n如果水滴落在 $x$ 轴上的位置与花盆的边沿对齐，也认为被接住。\n\n给出 $N$ 滴水的坐标和时间差 $D$ ，请算出最小的花盆宽度 $W$。", "inputFormat": "第一行 $2$ 个整数 $N$ 和 $D$。\n\n接下来 $N$ 行，每行 $2$ 个整数，表示水滴的坐标 $(x,y)$。", "outputFormat": "一行 $1$ 个整数，表示最小的花盆宽度。如果无法构造出满足题意的花盆，则输出 $-1$。", "hint": "**【样例解释】**\n\n有 $4$ 滴水，初始位置分别在 $(6,3)$，$(2,4)$，$(4,10)$，$(12,15)$。水滴至少用 $5$ 秒时间先后落入花盆。花盆的宽度为 $2$ 是必须且足够的，此时把花盆放在 $x=4\\dots6$ 的位置，它可以接到水滴 $1$ 和 $3$ ，之间的时间差为 $10-3=7$，满足条件。\n\n**【数据范围】**\n\n$40\\%$ 的数据：$1 \\le N \\le 1000$ ，$1 \\le D \\le 2000$。\n\n$100\\%$ 的数据：$1 \\le N \\le 10 ^ 5$，$1 \\le D \\le 10 ^ 6$，$0\\le x,y\\le10^6$。", "locale": "zh-CN"}}}
{"pid": "P2699", "type": "P", "difficulty": 3, "samples": [["1 10 2", "1 2 4 8"], ["2 4 5", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "【数学 1】小浩的幂次运算", "background": null, "description": "幂次运算让小浩觉得有些烦，最近他碰到了一些问题。  \n他需要求出所有 $w^i$ 使得 $l \\le w^i \\le r$ ，于是他找到了你。", "inputFormat": "输入为一行，有三个整数 $l,r,w$。", "outputFormat": "输出为一行，输出所有满足条件的数字，用空格分开。  \n如果没有满足条件的数字，则输出 $-1$。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据：$1\\le l\\le r \\le 1 \\times 10^{18}$ , $1\\le w \\le10^9$。", "locale": "zh-CN", "translations": {"en": {"title": "[Mathematics 1] Xiao Hao's Exponentiation", "background": "", "description": "Exponentiation makes Xiao Hao a bit annoyed; recently he encountered some problems.  \nHe needs to find all $w^i$ such that $l \\le w^i \\le r$, so he turned to you.", "inputFormat": "The input consists of one line with three integers $l,r,w$.", "outputFormat": "Output one line with all numbers that satisfy the condition, separated by spaces.  \nIf no number satisfies the condition, output $-1$.", "hint": "Constraints  \nFor $100\\%$ of the testdata: $1\\le l\\le r \\le 1 \\times 10^{18}$ , $1\\le w \\le10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【数学 1】小浩的幂次运算", "background": null, "description": "幂次运算让小浩觉得有些烦，最近他碰到了一些问题。  \n他需要求出所有 $w^i$ 使得 $l \\le w^i \\le r$ ，于是他找到了你。", "inputFormat": "输入为一行，有三个整数 $l,r,w$。", "outputFormat": "输出为一行，输出所有满足条件的数字，用空格分开。  \n如果没有满足条件的数字，则输出 $-1$。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据：$1\\le l\\le r \\le 1 \\times 10^{18}$ , $1\\le w \\le10^9$。", "locale": "zh-CN"}}}
{"pid": "P2700", "type": "P", "difficulty": 4, "samples": [["5 3\n1 2 4\n1 0 4\n1 3 8\n2 1 1\n2 4 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论", "树形数据结构", "并查集", "生成树"], "title": "逐个击破", "background": "三大战役的平津战场上，傅作义集团在以北平、天津为中心，东起唐山西至张家口的铁路线上摆起了一字长蛇阵，并企图在溃败时从海上南逃或向西逃窜。为了就地歼敌不让其逃走，指挥官制定了先切断敌人东西两头退路然后再逐个歼灭敌人的战略方针。秉承伟大军事家的战略思想，作为一个有智慧的军长你，遇到了一个类似的战场局面。", "description": "现在有 $N$ 个城市，其中 $K$ 个被敌方军团占领了，$N$ 个城市间有 $N-1$ 条公路相连，破坏其中某条公路的代价是已知的，现在，告诉你 $K$ 个敌方军团所在的城市，以及所有公路破坏的代价，请你算出花费最少的代价将这 $K$ 个敌方军团互相隔离开，以便第二步逐个击破敌人。", "inputFormat": "第一行包含两个正整数 $N$ 和 $K$。\n\n第二行包含 $K$ 个整数，表示哪些城市被敌军占领。\n\n接下来 $N-1$ 行，每行包含三个正整数 $a,b,c$，表示从 $a$ 城市到 $b$ 城市有一条公路，以及破坏的代价 $c$。城市的编号从 $0$ 开始。", "outputFormat": "输出一行一个整数，表示最少花费的代价。", "hint": "对于 $10\\%$ 的数据，$N\\le 10$。\n\n对于 $100\\%$ 的数据，$2\\le N\\le10^5$，$2\\le K\\le N$，$1\\le c\\le 10^6$。", "locale": "zh-CN", "translations": {"en": {"title": "Eliminate Them One by One", "background": "On the Pingjin battlefield of the three major campaigns, the Fu Zuoyi group deployed a long, thin defensive line centered on Beiping and Tianjin, stretching from Tangshan in the east to Zhangjiakou in the west along the railway. They planned to flee south by sea or retreat westward in case of collapse. To annihilate the enemy in place and prevent their escape, the commander formulated a strategy to first cut off the enemy’s retreat routes at both ends and then eliminate them one by one. Following the strategic thinking of a great military leader, as a wise corps commander, you encounter a similar battlefield situation.", "description": "There are $N$ cities, among which $K$ are occupied by enemy corps. There are $N - 1$ roads connecting the $N$ cities. The cost to destroy any given road is known. You are given the $K$ cities occupied by the enemy and the destruction cost of every road. Please compute the minimum total cost to isolate these $K$ enemy corps from each other, so that in the second step they can be eliminated one by one.", "inputFormat": "- The first line contains two positive integers $N$ and $K$.\n- The second line contains $K$ integers, indicating which cities are occupied by the enemy.\n- The next $N - 1$ lines each contain three positive integers $a, b, c$, indicating there is a road between city $a$ and city $b$, and the cost to destroy it is $c$. City indices start from $0$.", "outputFormat": "Output a single line with one integer, the minimum total cost.", "hint": "Constraints:\n- For $10\\%$ of the testdata, $N \\le 10$.\n- For $100\\%$ of the testdata, $2 \\le N \\le 10^5$, $2 \\le K \\le N$, $1 \\le c \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "逐个击破", "background": "三大战役的平津战场上，傅作义集团在以北平、天津为中心，东起唐山西至张家口的铁路线上摆起了一字长蛇阵，并企图在溃败时从海上南逃或向西逃窜。为了就地歼敌不让其逃走，指挥官制定了先切断敌人东西两头退路然后再逐个歼灭敌人的战略方针。秉承伟大军事家的战略思想，作为一个有智慧的军长你，遇到了一个类似的战场局面。", "description": "现在有 $N$ 个城市，其中 $K$ 个被敌方军团占领了，$N$ 个城市间有 $N-1$ 条公路相连，破坏其中某条公路的代价是已知的，现在，告诉你 $K$ 个敌方军团所在的城市，以及所有公路破坏的代价，请你算出花费最少的代价将这 $K$ 个敌方军团互相隔离开，以便第二步逐个击破敌人。", "inputFormat": "第一行包含两个正整数 $N$ 和 $K$。\n\n第二行包含 $K$ 个整数，表示哪些城市被敌军占领。\n\n接下来 $N-1$ 行，每行包含三个正整数 $a,b,c$，表示从 $a$ 城市到 $b$ 城市有一条公路，以及破坏的代价 $c$。城市的编号从 $0$ 开始。", "outputFormat": "输出一行一个整数，表示最少花费的代价。", "hint": "对于 $10\\%$ 的数据，$N\\le 10$。\n\n对于 $100\\%$ 的数据，$2\\le N\\le10^5$，$2\\le K\\le N$，$1\\le c\\le 10^6$。", "locale": "zh-CN"}}}
{"pid": "P2701", "type": "P", "difficulty": 3, "samples": [["8 3\r\n2 2\r\n2 6\r\n6 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "USACO"], "title": "[USACO5.3] 巨大的牛棚 Big Barn", "background": null, "description": "FJ 有一个大小为 $n\\times n$ 的农场（$1\\le n\\le 1000$），他想要在他的农场上建造一座正方形大牛棚。他的农场中有 $t$ 棵果树（$1\\le t\\le10000$），但他为了不破坏果树，就想找一个空旷无树的地方修建牛棚。你的任务是计算并输出，在他的农场中，不需要砍树却能够修建的最大正方形牛棚的边长。当然，牛棚的边必须和水平轴和垂直轴平行。\n\n考虑下面的农场，`.` 表示没有树的方格，`#` 表示有树的方格。\n```plain\n0 1 2 3 4 5 6 7 8\n1 . . . . . . . .\n2 . # . . . # . .\n3 . . . . . . . .\n4 . . . . . . . .\n5 . . . . . . . .\n6 . . # . . . . .\n7 . . . . . . . .\n8 . . . . . . . .\n```\n最大的牛棚是边长为 $5$ 的，可以建造在农场右下角的两个位置其中一个。", "inputFormat": "第 $1$ 行输入两个正整数 $n$ 和 $t$。\n\n第 $2\\sim t+1$ 行输入两个正整数 $x,y\\ (1\\le x,y\\le n)$。", "outputFormat": "只由一行组成，约翰的牛棚的最大边长。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 5.3", "locale": "zh-CN", "translations": {"en": {"title": "[USACO5.3] Big Barn", "background": "", "description": "Farmer John (FJ) has an $n \\times n$ farm ($1 \\le n \\le 1000$), and he wants to build a square barn on it. There are $t$ fruit trees on his farm ($1 \\le t \\le 10000$). To avoid cutting any trees, he wants to find an open area with no trees to build the barn. Your task is to compute and output the side length of the largest square barn that can be built on his farm without removing any trees. Of course, the sides of the barn must be parallel to the horizontal and vertical axes.\n\nConsider the farm below, where '.' represents an empty cell and '#' represents a cell with a tree.\n```plain\n0 1 2 3 4 5 6 7 8\n1 . . . . . . . .\n2 . # . . . # . .\n3 . . . . . . . .\n4 . . . . . . . .\n5 . . . . . . . .\n6 . . # . . . . .\n7 . . . . . . . .\n8 . . . . . . . .\n```\nThe largest barn has a side length of $5$ and can be placed at one of two positions in the lower-right corner.", "inputFormat": "The first line contains two positive integers $n$ and $t$.\n\nLines $2$ through $t+1$ each contain two positive integers $x, y$ ($1 \\le x, y \\le n$).", "outputFormat": "Output a single line: the maximum side length of John's barn.", "hint": "Problem translation from NOCOW.\n\nUSACO Training Section 5.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO5.3] 巨大的牛棚 Big Barn", "background": null, "description": "FJ 有一个大小为 $n\\times n$ 的农场（$1\\le n\\le 1000$），他想要在他的农场上建造一座正方形大牛棚。他的农场中有 $t$ 棵果树（$1\\le t\\le10000$），但他为了不破坏果树，就想找一个空旷无树的地方修建牛棚。你的任务是计算并输出，在他的农场中，不需要砍树却能够修建的最大正方形牛棚的边长。当然，牛棚的边必须和水平轴和垂直轴平行。\n\n考虑下面的农场，`.` 表示没有树的方格，`#` 表示有树的方格。\n```plain\n0 1 2 3 4 5 6 7 8\n1 . . . . . . . .\n2 . # . . . # . .\n3 . . . . . . . .\n4 . . . . . . . .\n5 . . . . . . . .\n6 . . # . . . . .\n7 . . . . . . . .\n8 . . . . . . . .\n```\n最大的牛棚是边长为 $5$ 的，可以建造在农场右下角的两个位置其中一个。", "inputFormat": "第 $1$ 行输入两个正整数 $n$ 和 $t$。\n\n第 $2\\sim t+1$ 行输入两个正整数 $x,y\\ (1\\le x,y\\le n)$。", "outputFormat": "只由一行组成，约翰的牛棚的最大边长。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 5.3", "locale": "zh-CN"}}}
{"pid": "P2702", "type": "P", "difficulty": 5, "samples": [["1+1=3#", "1+1=2#"], ["1+1=3+5#", "No"], ["11+77=34#", "17+17=34#"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2003", "NOI"], "title": "[NOI2003] 木棒游戏", "background": "**洛谷没有文件输入输出。请从标准输入（`stdin`）读取输入，并输出到标准输出（`stdout`）。**\n\n--------\n这是一个很古老的游戏。用木棒在桌上拼出一个**不成立的等式**，移动且只移动一根木棒使得等式成立。现在轮到你了。", "description": "从文件读入一个式子（该式子肯定是一个不成立的等式）。\n\n如果能移动一根木棒可以使等式成立，则输出新的等式，否则输出 `No`。\n\n### 说明和限制\n1. 式子中的数可能是正数或负数，运算符号只会出现加号和减号，并且有且仅有一个等号，不会出现括号、乘号或除号，也不会有 `++`、`--`、`+-` 或 `-+` 出现。\n2. 式子中不会出现 $8$ 个或 $8$ 个以上的连续数字（数的绝对值小于等于 $9999999$）。\n3. 你只能移动用来构成数字的木棒，不能移动构成运算符（`+`、`-`、`=`）的木棒，所以加号、减号、等号是不会改变的。移动前后，木棒构成的数字必须严格与图 2 中的 $0\\sim9$ 相符。\n4. 从文件读入的式子中的数不会以 $0$ 开头，但允许修改后等式中的数以数字 $0$ 开头。", "inputFormat": "从文件 `game.in` 中读入一行字符串。该串中包括一个以 `#` 字符结尾的式子（ASCII码 35），式子中没有空格或其他分隔符。输入数据严格符合逻辑。字符串的长度小于等于 $1000$。\n\n**注意：`#`字符后面可能会有一些与题目无关的字符。**", "outputFormat": "将输出结果存入文件 `game.out`，输出仅一行。\n\n如果有解，则输出正确的等式，格式与输入的格式相同（以 `#` 结尾，中间不能有分隔符，也不要加入多余字符）。此时输入数据保证解是唯一的。\n\n如果无解，则输出 `No`（`N` 大写，`o` 小写）。", "hint": null, "locale": "zh-CN", "translations": {"en": {"title": "[NOI2003] Matchstick Game", "background": "Luogu does not support file input and output. Please read from standard input (stdin) and write to standard output (stdout).\n\n--------\nThis is a very old game. Using matchsticks, an incorrect equation is arranged on the table. Move, and only move, exactly one matchstick to make the equation correct. Now it is your turn.", "description": "Read an expression from input (the expression is guaranteed to be an incorrect equation).\n\nIf moving exactly one matchstick can make the equation correct, output the new equation; otherwise, output `No`.\n\nNotes and constraints:\n1. Numbers in the expression can be positive or negative. The only operators are plus and minus, and there is exactly one equals sign. There are no parentheses, multiplication, or division, and sequences like `++`, `--`, `+-`, or `-+` will not appear.\n2. There will not be $8$ or more consecutive digits in the expression (the absolute value of any number is at most $9999999$).\n3. You may only move matchsticks that form digits; you cannot move the matchsticks that form the operators (`+`, `-`, `=`), so the plus sign, minus sign, and equals sign never change. Before and after the move, the digit shapes must strictly match the patterns for $0\\sim9$ shown in Figure 2.\n4. Numbers in the input expression will not start with $0$, but numbers in the corrected equation are allowed to start with the digit $0$.", "inputFormat": "Read one line from standard input. The line contains an expression that ends with the `#` character (ASCII code 35). There are no spaces or other separators. The input strictly follows the logical specification. The string length is less than or equal to $1000$.\n\nNote: There may be some characters after the `#` character that are unrelated to the problem.", "outputFormat": "Write exactly one line to standard output.\n\nIf there is a solution, output the corrected equation in the same format as the input (ending with `#`, with no separators and no extra characters). In this case, the input guarantees the solution is unique.\n\nIf there is no solution, output `No` (uppercase `N`, lowercase `o`).", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2003] 木棒游戏", "background": "**洛谷没有文件输入输出。请从标准输入（`stdin`）读取输入，并输出到标准输出（`stdout`）。**\n\n--------\n这是一个很古老的游戏。用木棒在桌上拼出一个**不成立的等式**，移动且只移动一根木棒使得等式成立。现在轮到你了。", "description": "从文件读入一个式子（该式子肯定是一个不成立的等式）。\n\n如果能移动一根木棒可以使等式成立，则输出新的等式，否则输出 `No`。\n\n### 说明和限制\n1. 式子中的数可能是正数或负数，运算符号只会出现加号和减号，并且有且仅有一个等号，不会出现括号、乘号或除号，也不会有 `++`、`--`、`+-` 或 `-+` 出现。\n2. 式子中不会出现 $8$ 个或 $8$ 个以上的连续数字（数的绝对值小于等于 $9999999$）。\n3. 你只能移动用来构成数字的木棒，不能移动构成运算符（`+`、`-`、`=`）的木棒，所以加号、减号、等号是不会改变的。移动前后，木棒构成的数字必须严格与图 2 中的 $0\\sim9$ 相符。\n4. 从文件读入的式子中的数不会以 $0$ 开头，但允许修改后等式中的数以数字 $0$ 开头。", "inputFormat": "从文件 `game.in` 中读入一行字符串。该串中包括一个以 `#` 字符结尾的式子（ASCII码 35），式子中没有空格或其他分隔符。输入数据严格符合逻辑。字符串的长度小于等于 $1000$。\n\n**注意：`#`字符后面可能会有一些与题目无关的字符。**", "outputFormat": "将输出结果存入文件 `game.out`，输出仅一行。\n\n如果有解，则输出正确的等式，格式与输入的格式相同（以 `#` 结尾，中间不能有分隔符，也不要加入多余字符）。此时输入数据保证解是唯一的。\n\n如果无解，则输出 `No`（`N` 大写，`o` 小写）。", "hint": null, "locale": "zh-CN"}}}
{"pid": "P2703", "type": "P", "difficulty": 7, "samples": [["7\n4 4\n3 4\n3 5\n1 3\n2 2\n2 4\n3 3", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2006", "NOI", "枚举"], "title": "[NOI2006] 千年虫", "background": "", "description": "千年虫是远古时代的生物，时隔几千万年，千年虫早已从地球上销声匿迹，人们对其知之甚少。考古生物学家最近开始对其有了兴趣，因为一批珍贵的千年虫化石被发现，这些化石保留了千年虫近乎完整的形态。\n\n理论科学家们根据这些化石归纳出了千年虫的一般形态特征模型，并且据此判定出千年虫就是蜈蚣的祖先！但科学家 J 发现了实际与理论的一些出入，他仔细的研究了上百个千年虫化石，发现其中大部分千年虫的形态都不完全符合理论模型，这到底是什么因素造成的呢？理论科学家 K 敏锐的指出，千年虫的形态保存在化石中很有可能发生各种变化，即便最细微的变化也能导致它不符合模型。\n\n于是，摆在科学家面前的新问题诞生了：判断一个化石中的千年虫与理论模型的差距有多大？具体来说，就是根据一个千年虫化石的形态 $A$，找到 一个符合理论模型的形态 $B$，使得 $B$ 是最有可能在形成化石时变成形态 $A$。理论学家提出的“千年虫形态特征模型”如下（如左图所示）：躯体由头、尾、躯干、足四大部分构成。\n\n![](https://cdn.luogu.com.cn/upload/pic/1876.png)\n\n- 头，尾用一对平行线段表示。称平行于头、尾的方向为 $x$ 方向；垂直于 $x$ 的方向为 $y$ 方向；\n\n- 在头尾之间有两条互不相交的折线段相连，他们与头、尾两条线段一起围成的区域称为躯干，两条折线段都满足以下条件：拐角均为钝角或者平角，且包含奇数条线段，从上往下数的奇数条垂直于 $x$ 方向。\n\n- 每条折线段从上往下数的第偶数条线段的躯干的另一侧长出一条足，即一个上、下底平行于 $x$ 方向的梯形或矩形，且其中远离躯干一侧的边垂直于 $x$ 方向。\n\n注意：足不能退化成三角形（即底边的长度均大于零），躯干两侧足的数目可以不一样。（如上图，左边有 $4$ 条足，右边有 $5$ 条足）\n\n可见，$x$-$y$ 直角坐标系内，躯干和所有足组成的实心区域的边界均平行或垂直于坐标轴。为了方便，我们假设所有这些边界的长度均为正整数。因此可以认为每个千年虫的躯体 都由一些单位方格拼成。每个单位方格都由坐标 $(x,y)$ 唯一确定。设头尾之间的距离为 $n$，则我们可以用 $2\\times n$ 个整数来描述一条千年虫 $B$（如右图）：将 $B$ 沿平行 $x$ 轴方向剖分成 $n$ 条宽度为 $1$ 的横条，每个横条最左边一格的 $x$ 坐标设为 $L_i$，最右一格的的 $x$ 坐标设为 $R_i$。则  $(n,L_1,L_2,\\dots,L_n,R_1,R_2,\\dots,R_n)$ 就确定了一条千年虫。\n\n由于岁月的侵蚀，在实际发现的化石中，千年虫的形状并不满足上面理论模型的规则，一些格子中的躯体已经被某些矿物质溶解腐蚀了。地质、物理、生物学家共同研究得出：\n\n- 腐蚀是以格子为单位的，只能一整格被腐蚀；\n\n- 腐蚀是分步进行的，每一步只有一格被腐蚀；\n\n- 如果去掉一个格子后躯体不连通了，那么这个格子当前不会被腐蚀；\n\n- 如果一个格子的左边邻格和右边邻格都还没被腐蚀，那么这个格子当前不会被腐蚀；\n\n- 与头相邻的格子不能全部被腐蚀，与尾相邻的格子不能全部被腐蚀。\n\n倘若满足上面五条，我们仍然可以用 $(n,L_1,L_2,\\dots,L_n,R_1,R_2,\\dots,R_n)$ 来描述一个化石里头的千年虫的形态。其中 $L_i\\le R_i$。\n\n![](https://cdn.luogu.com.cn/upload/pic/1879.png)\n\n例如下图：\n\n![](https://cdn.luogu.com.cn/upload/pic/1878.png)\n\n现在你的任务是，输入一个化石里的千年虫的描述 $A$，找一个满足理论模型的千年虫的描述 $B$，使得 $B$ 可以通过腐蚀过程得以变为 $A$，且由 $B$ 转化为 $A$ 的代价（须被腐蚀的格子数）最少。输出此最小代价。", "inputFormat": "第一行为一个整数 $n$。\n\n以下 $n$ 行，每行两个整数，其中第 $i$ 行为两个整数 $L'_i$、$R'_i$，用一个空格分开；保证输入数据合法。", "outputFormat": "仅一行，为一个整数，表示最少代价。\n", "hint": "\n【样例说明】\n\n如图：\n\n![](https://cdn.luogu.com.cn/upload/pic/1877.png)\n\n【评分方法】\n\n本题没有部分分，你的程序的输出只有和我们的答案完全一致才能获得满分，否则不得分。\n\n【数据范围】\n\n对于 $30\\%$ 的数据，$n\\le100$，$R_i\\le100$；\n\n对于 $50\\%$ 的数据，$n\\le1000$，$R_i\\le1000$；\n\n对于 $70\\%$ 的数据，$n\\le10 ^ 5$，$R_i\\le 1000$；\n\n对于 $100\\%$ 的数据，$1\\leq n\\le10 ^ 6$，$0\\le L_i\\le R_i\\le10 ^ 6$。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2006] Millennium Bug", "background": "", "description": "The Millennium Bug is an ancient creature that vanished from Earth tens of millions of years ago, and little is known about it. Paleobiologists have recently become interested in it because a set of precious Millennium Bug fossils was discovered, preserving the creature’s shape nearly intact.\n\nTheoretical scientists have generalized a model of the Millennium Bug’s shape from these fossils, and on this basis determined that the Millennium Bug is the ancestor of the centipede. However, Scientist J found discrepancies between the model and reality. After closely studying hundreds of fossils, he discovered that most of them do not completely conform to the theoretical model. What caused this? Theoretical Scientist K pointed out that the shape of a Millennium Bug preserved in a fossil may have undergone various changes during fossilization, and even the slightest change could make it fail to match the model.\n\nThus a new problem arises for the scientists: how far is a fossilized Millennium Bug from the theoretical model? Specifically, given the shape $A$ of a Millennium Bug in a fossil, find a shape $B$ that conforms to the theoretical model such that $B$ is most likely to become $A$ during fossilization.\n\nThe theoretical “Millennium Bug shape model” is as follows (see the left figure): the body consists of four parts — head, tail, trunk, and legs.\n\n![](https://cdn.luogu.com.cn/upload/pic/1876.png)\n\n- The head and the tail are represented by a pair of parallel line segments. The direction parallel to the head and tail is called the $x$ direction; the direction perpendicular to $x$ is the $y$ direction.\n- Between the head and the tail, there are two disjoint polylines connecting them. Together with the head and tail segments, they bound a region called the trunk. Both polylines satisfy all of the following:\n  - Every turn is an obtuse angle or a straight angle.\n  - Each polyline consists of an odd number of segments.\n  - Counting segments from top to bottom, the odd-numbered segments are perpendicular to the $x$ direction.\n- On each polyline, a leg grows from every even-numbered segment (counted from top to bottom) on the side away from the trunk. Each leg is a trapezoid or rectangle whose top and bottom bases are parallel to the $x$ direction, and whose edge farthest from the trunk is perpendicular to the $x$ direction.\n\nNote: A leg must not degenerate into a triangle (i.e., both base lengths are strictly greater than zero). The numbers of legs on the two sides of the trunk may differ. (In the above figure, there are $4$ legs on the left and $5$ on the right.)\n\nIn the $x$-$y$ Cartesian coordinate system, the boundary of the solid region formed by the trunk and all legs is parallel or perpendicular to the coordinate axes. For convenience, we assume all such boundary lengths are positive integers. Therefore, we can regard each Millennium Bug’s body as a shape formed by unit squares. Each unit square is uniquely determined by coordinates $(x, y)$. Let the distance between the head and the tail be $n$. Then we can describe a Millennium Bug $B$ using $2 \\times n$ integers (see the right figure): cut $B$ into $n$ horizontal strips of width $1$ along directions parallel to the $x$ axis. In the $i$-th strip, let the $x$ coordinate of the leftmost cell be $L_i$, and the $x$ coordinate of the rightmost cell be $R_i$. Then $(n, L_1, L_2, \\dots, L_n, R_1, R_2, \\dots, R_n)$ determines a Millennium Bug.\n\nDue to the erosion of time, the shape of the Millennium Bug in actual fossils does not follow the rules of the theoretical model. Some cells of the body have been dissolved and corroded by minerals. Geologists, physicists, and biologists have jointly concluded that:\n\n- Corrosion happens at the granularity of cells; only an entire cell can be corroded.\n- Corrosion proceeds step by step, and at each step only one cell is corroded.\n- If removing a cell would disconnect the body, that cell will not be corroded at that time.\n- If both the left neighbor and the right neighbor of a cell have not been corroded, then that cell will not be corroded at that time.\n- The cells adjacent to the head cannot all be corroded, and the cells adjacent to the tail cannot all be corroded.\n\nIf the above five rules are satisfied, we can still describe the shape of a Millennium Bug in a fossil using $(n, L_1, L_2, \\dots, L_n, R_1, R_2, \\dots, R_n)$. Here $L_i \\le R_i$.\n\n![](https://cdn.luogu.com.cn/upload/pic/1879.png)\n\nFor example, see the following figure:\n\n![](https://cdn.luogu.com.cn/upload/pic/1878.png)\n\nYour task is: given a description $A$ of a Millennium Bug in a fossil, find a description $B$ that satisfies the theoretical model, such that $B$ can become $A$ through the corrosion process, and the cost of transforming $B$ into $A$ (the number of cells that must be corroded) is minimized. Output this minimum cost.", "inputFormat": "The first line contains an integer $n$.\n\nThe following $n$ lines each contain two integers. In line $i$, the two integers are $L'_i$ and $R'_i$, separated by a space. It is guaranteed that the input testdata is valid.", "outputFormat": "Output a single line containing one integer, the minimum cost.", "hint": "Sample explanation:\n\nAs shown in the figure:\n\n![](https://cdn.luogu.com.cn/upload/pic/1877.png)\n\nScoring:\n\nThere is no partial score. Your program receives full score only if its output exactly matches our answer; otherwise you receive no score.\n\nConstraints:\n\n- For 30% of the testdata, $n \\le 100$, $R'_i \\le 100$.\n- For 50% of the testdata, $n \\le 1000$, $R'_i \\le 1000$.\n- For 70% of the testdata, $n \\le 10^5$, $R'_i \\le 1000$.\n- For 100% of the testdata, $1 \\le n \\le 10^6$, $0 \\le L'_i \\le R'_i \\le 10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2006] 千年虫", "background": "", "description": "千年虫是远古时代的生物，时隔几千万年，千年虫早已从地球上销声匿迹，人们对其知之甚少。考古生物学家最近开始对其有了兴趣，因为一批珍贵的千年虫化石被发现，这些化石保留了千年虫近乎完整的形态。\n\n理论科学家们根据这些化石归纳出了千年虫的一般形态特征模型，并且据此判定出千年虫就是蜈蚣的祖先！但科学家 J 发现了实际与理论的一些出入，他仔细的研究了上百个千年虫化石，发现其中大部分千年虫的形态都不完全符合理论模型，这到底是什么因素造成的呢？理论科学家 K 敏锐的指出，千年虫的形态保存在化石中很有可能发生各种变化，即便最细微的变化也能导致它不符合模型。\n\n于是，摆在科学家面前的新问题诞生了：判断一个化石中的千年虫与理论模型的差距有多大？具体来说，就是根据一个千年虫化石的形态 $A$，找到 一个符合理论模型的形态 $B$，使得 $B$ 是最有可能在形成化石时变成形态 $A$。理论学家提出的“千年虫形态特征模型”如下（如左图所示）：躯体由头、尾、躯干、足四大部分构成。\n\n![](https://cdn.luogu.com.cn/upload/pic/1876.png)\n\n- 头，尾用一对平行线段表示。称平行于头、尾的方向为 $x$ 方向；垂直于 $x$ 的方向为 $y$ 方向；\n\n- 在头尾之间有两条互不相交的折线段相连，他们与头、尾两条线段一起围成的区域称为躯干，两条折线段都满足以下条件：拐角均为钝角或者平角，且包含奇数条线段，从上往下数的奇数条垂直于 $x$ 方向。\n\n- 每条折线段从上往下数的第偶数条线段的躯干的另一侧长出一条足，即一个上、下底平行于 $x$ 方向的梯形或矩形，且其中远离躯干一侧的边垂直于 $x$ 方向。\n\n注意：足不能退化成三角形（即底边的长度均大于零），躯干两侧足的数目可以不一样。（如上图，左边有 $4$ 条足，右边有 $5$ 条足）\n\n可见，$x$-$y$ 直角坐标系内，躯干和所有足组成的实心区域的边界均平行或垂直于坐标轴。为了方便，我们假设所有这些边界的长度均为正整数。因此可以认为每个千年虫的躯体 都由一些单位方格拼成。每个单位方格都由坐标 $(x,y)$ 唯一确定。设头尾之间的距离为 $n$，则我们可以用 $2\\times n$ 个整数来描述一条千年虫 $B$（如右图）：将 $B$ 沿平行 $x$ 轴方向剖分成 $n$ 条宽度为 $1$ 的横条，每个横条最左边一格的 $x$ 坐标设为 $L_i$，最右一格的的 $x$ 坐标设为 $R_i$。则  $(n,L_1,L_2,\\dots,L_n,R_1,R_2,\\dots,R_n)$ 就确定了一条千年虫。\n\n由于岁月的侵蚀，在实际发现的化石中，千年虫的形状并不满足上面理论模型的规则，一些格子中的躯体已经被某些矿物质溶解腐蚀了。地质、物理、生物学家共同研究得出：\n\n- 腐蚀是以格子为单位的，只能一整格被腐蚀；\n\n- 腐蚀是分步进行的，每一步只有一格被腐蚀；\n\n- 如果去掉一个格子后躯体不连通了，那么这个格子当前不会被腐蚀；\n\n- 如果一个格子的左边邻格和右边邻格都还没被腐蚀，那么这个格子当前不会被腐蚀；\n\n- 与头相邻的格子不能全部被腐蚀，与尾相邻的格子不能全部被腐蚀。\n\n倘若满足上面五条，我们仍然可以用 $(n,L_1,L_2,\\dots,L_n,R_1,R_2,\\dots,R_n)$ 来描述一个化石里头的千年虫的形态。其中 $L_i\\le R_i$。\n\n![](https://cdn.luogu.com.cn/upload/pic/1879.png)\n\n例如下图：\n\n![](https://cdn.luogu.com.cn/upload/pic/1878.png)\n\n现在你的任务是，输入一个化石里的千年虫的描述 $A$，找一个满足理论模型的千年虫的描述 $B$，使得 $B$ 可以通过腐蚀过程得以变为 $A$，且由 $B$ 转化为 $A$ 的代价（须被腐蚀的格子数）最少。输出此最小代价。", "inputFormat": "第一行为一个整数 $n$。\n\n以下 $n$ 行，每行两个整数，其中第 $i$ 行为两个整数 $L'_i$、$R'_i$，用一个空格分开；保证输入数据合法。", "outputFormat": "仅一行，为一个整数，表示最少代价。\n", "hint": "\n【样例说明】\n\n如图：\n\n![](https://cdn.luogu.com.cn/upload/pic/1877.png)\n\n【评分方法】\n\n本题没有部分分，你的程序的输出只有和我们的答案完全一致才能获得满分，否则不得分。\n\n【数据范围】\n\n对于 $30\\%$ 的数据，$n\\le100$，$R_i\\le100$；\n\n对于 $50\\%$ 的数据，$n\\le1000$，$R_i\\le1000$；\n\n对于 $70\\%$ 的数据，$n\\le10 ^ 5$，$R_i\\le 1000$；\n\n对于 $100\\%$ 的数据，$1\\leq n\\le10 ^ 6$，$0\\le L_i\\le R_i\\le10 ^ 6$。", "locale": "zh-CN"}}}
{"pid": "P2704", "type": "P", "difficulty": 5, "samples": [["5 4\nPHPP\nPPHH\nPPPP\nPHPP\nPHHP", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["2001", "NOI", "进制", "状压 DP"], "title": "[NOI2001] 炮兵阵地", "background": "", "description": "司令部的将军们打算在 $N\\times M$ 的网格地图上部署他们的炮兵部队。\n\n一个 $N\\times M$ 的地图由 $N$ 行 $M$ 列组成，地图的每一格可能是山地（用 $\\texttt{H}$ 表示），也可能是平原（用 $\\texttt{P}$ 表示），如下图。\n\n在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1881.png) \n\n如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。\n\n图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。\n\n现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。\n\n", "inputFormat": "第一行包含两个由空格分割开的正整数，分别表示 $N$ 和 $M$。\n\n接下来的 $N$ 行，每一行含有连续的 $M$ 个字符，按顺序表示地图中每一行的数据。\n", "outputFormat": "一行一个整数，表示最多能摆放的炮兵部队的数量。\n", "hint": "对于 $100\\%$ 的数据，$1 \\leq N\\le 100$，$1 \\leq M\\le 10$，保证字符仅包含 `P` 与 `H`。", "locale": "zh-CN", "translations": {"en": {"title": "[NOI2001] Artillery Positions", "background": "", "description": "The generals at headquarters plan to deploy their artillery units on an $N\\times M$ grid map.\n\nAn $N\\times M$ map consists of $N$ rows and $M$ columns. Each cell may be mountain terrain (denoted by $\\texttt{H}$) or plain terrain (denoted by $\\texttt{P}$), as shown below.\n\nAt most one artillery unit can be placed on each plain cell (artillery cannot be placed on mountains). The attack range of one artillery unit is shown by the black area in the figure:\n\n ![](https://cdn.luogu.com.cn/upload/pic/1881.png) \n\nIf an artillery unit is deployed on the gray plain cell, then the black cells in the figure mark the area it can attack: two cells to the left and right horizontally, and two cells up and down vertically.\n\nAll other white cells in the figure are out of range. As can be seen, the artillery’s attack range is not affected by terrain.\n\nNow the generals are planning how to deploy the artillery units. Under the constraint of preventing friendly fire (ensuring that no two artillery units can attack each other, i.e., no artillery unit lies within the attack range of any other), determine the maximum number of our artillery units that can be placed on the entire map.", "inputFormat": "The first line contains two positive integers separated by a space, representing $N$ and $M$.\n\nThe next $N$ lines each contain exactly $M$ consecutive characters, in order representing each row of the map.", "outputFormat": "Output a single integer on one line, the maximum number of artillery units that can be placed.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\leq N \\le 100$, $1 \\leq M \\le 10$. The characters are guaranteed to contain only `P` and `H`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[NOI2001] 炮兵阵地", "background": "", "description": "司令部的将军们打算在 $N\\times M$ 的网格地图上部署他们的炮兵部队。\n\n一个 $N\\times M$ 的地图由 $N$ 行 $M$ 列组成，地图的每一格可能是山地（用 $\\texttt{H}$ 表示），也可能是平原（用 $\\texttt{P}$ 表示），如下图。\n\n在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：\n\n ![](https://cdn.luogu.com.cn/upload/pic/1881.png) \n\n如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。\n\n图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。\n\n现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。\n\n", "inputFormat": "第一行包含两个由空格分割开的正整数，分别表示 $N$ 和 $M$。\n\n接下来的 $N$ 行，每一行含有连续的 $M$ 个字符，按顺序表示地图中每一行的数据。\n", "outputFormat": "一行一个整数，表示最多能摆放的炮兵部队的数量。\n", "hint": "对于 $100\\%$ 的数据，$1 \\leq N\\le 100$，$1 \\leq M\\le 10$，保证字符仅包含 `P` 与 `H`。", "locale": "zh-CN"}}}
{"pid": "P2705", "type": "P", "difficulty": 1, "samples": [["2 3 100 400 200", "1400"], ["2 3 100 400 300", "1600"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学"], "title": "小球", "background": "", "description": "有 $R$ 个红色盒子和 $B$ 个蓝色盒子，还有 $R$ 个红色小球和 $B$ 个蓝色小球。每个盒子只能装一个小球，每个小球都要放在一个盒子里。\n\n- 如果把一个红色小球放在一个红色盒子里，那么得分是 $C$。\n- 如果把一个蓝色小球放在一个蓝色盒子里，那么得分是 $D$。\n- 如果把一个红色小球放在一个蓝色盒子里，那么得分是 $E$。\n- 如果把一个蓝色小球放在一个红色盒子里，那么得分也是 $E$。\n\n现在给出 $R,B,C,D,E$。应该如何放置这些小球进盒子，才能使得总得分最大？输出最大的总得分。\n", "inputFormat": "输入共一行 $5$ 个整数，分别是 $R,B,C,D,E$。\n", "outputFormat": "一个整数，表示最大总得分。\n", "hint": "### 数据范围\n\n对于全部数据，$1 \\le R \\le 100$，$1 \\le B \\le 100$，$-1000 \\le C,D,E \\le 1000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Balls", "background": "", "description": "There are $R$ red boxes and $B$ blue boxes, and also $R$ red balls and $B$ blue balls. Each box can contain at most one ball, and every ball must be placed in a box.\n\n- If a red ball is placed in a red box, the score is $C$.\n- If a blue ball is placed in a blue box, the score is $D$.\n- If a red ball is placed in a blue box, the score is $E$.\n- If a blue ball is placed in a red box, the score is also $E$.\n\nNow given $R,B,C,D,E$. How should we place the balls into the boxes to maximize the total score? Output the maximum total score.", "inputFormat": "A single line with $5$ integers, which are $R,B,C,D,E$.", "outputFormat": "A single integer, representing the maximum total score.", "hint": "### Constraints\n\nFor all testdata, $1 \\le R \\le 100$, $1 \\le B \\le 100$, $-1000 \\le C,D,E \\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小球", "background": "", "description": "有 $R$ 个红色盒子和 $B$ 个蓝色盒子，还有 $R$ 个红色小球和 $B$ 个蓝色小球。每个盒子只能装一个小球，每个小球都要放在一个盒子里。\n\n- 如果把一个红色小球放在一个红色盒子里，那么得分是 $C$。\n- 如果把一个蓝色小球放在一个蓝色盒子里，那么得分是 $D$。\n- 如果把一个红色小球放在一个蓝色盒子里，那么得分是 $E$。\n- 如果把一个蓝色小球放在一个红色盒子里，那么得分也是 $E$。\n\n现在给出 $R,B,C,D,E$。应该如何放置这些小球进盒子，才能使得总得分最大？输出最大的总得分。\n", "inputFormat": "输入共一行 $5$ 个整数，分别是 $R,B,C,D,E$。\n", "outputFormat": "一个整数，表示最大总得分。\n", "hint": "### 数据范围\n\n对于全部数据，$1 \\le R \\le 100$，$1 \\le B \\le 100$，$-1000 \\le C,D,E \\le 1000$。\n", "locale": "zh-CN"}}}
{"pid": "P2706", "type": "P", "difficulty": 4, "samples": [["3 4\n1 2 3 4\n5 0 6 3\n10 3 4 0", "17\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288]}, "tags": ["枚举", "前缀和", "单调栈"], "title": "巧克力", "background": "王 7 的生日到了，他的弟弟准备送他巧克力。", "description": "有一个被分成 $n\\times m$ 格的巧克力盒，在 $(i,j)$ 的位置上有 $a_{i,j}$ 块巧克力。就在送出它的前一天晚上，有老鼠夜袭巧克力盒，某些位置上被洗劫并且穿了洞。所以，你——王 7 的弟弟王 9，必须从这个满目苍夷的盒子中切割出一个矩形巧克力盒，其中不能有被老鼠洗劫过的格子且使这个盒子里的巧克力尽量多。", "inputFormat": "第一行有两个整数 $n,m$。第 $i+1$ 行的第 $j$ 个数表示 $a_{i,j}$。如果这个数为 $0$，则表示这个位置的格子被洗劫过。", "outputFormat": "输出最大巧克力数。", "hint": "**样例解释**\n\n第三行前三列 `10 3 4` 组成的矩形的巧克力数最大。\n\n**数据范围**\n\n对于全部的数据，$1\\le n,m\\le 300$，$0\\le a_{i,j} \\le 255$。", "locale": "zh-CN", "translations": {"en": {"title": "Chocolate", "background": "Wang 7's birthday has arrived, and his younger brother plans to give him chocolate.", "description": "There is a chocolate box divided into $n \\times m$ cells; at position $(i, j)$ there are $a_{i,j}$ pieces of chocolate. On the night before gifting it, mice raided the box: some cells were looted and now have holes. So you—Wang 7's younger brother, Wang 9—must cut out a rectangular chocolate box from this battered box, such that it contains no looted cells and the total number of chocolates inside is as large as possible.", "inputFormat": "The first line contains two integers $n, m$. In line $i+1$, the $j$-th number denotes $a_{i,j}$. If this number is $0$, it means the cell at that position was looted.", "outputFormat": "Output the maximum number of chocolates.", "hint": "**Example Explanation**\n\nThe first three cells in the third row `10 3 4` form the rectangle with the maximum number of chocolates.\n\n**Constraints**\n\nFor all the testdata, $1 \\le n, m \\le 300$, $0 \\le a_{i,j} \\le 255$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "巧克力", "background": "王 7 的生日到了，他的弟弟准备送他巧克力。", "description": "有一个被分成 $n\\times m$ 格的巧克力盒，在 $(i,j)$ 的位置上有 $a_{i,j}$ 块巧克力。就在送出它的前一天晚上，有老鼠夜袭巧克力盒，某些位置上被洗劫并且穿了洞。所以，你——王 7 的弟弟王 9，必须从这个满目苍夷的盒子中切割出一个矩形巧克力盒，其中不能有被老鼠洗劫过的格子且使这个盒子里的巧克力尽量多。", "inputFormat": "第一行有两个整数 $n,m$。第 $i+1$ 行的第 $j$ 个数表示 $a_{i,j}$。如果这个数为 $0$，则表示这个位置的格子被洗劫过。", "outputFormat": "输出最大巧克力数。", "hint": "**样例解释**\n\n第三行前三列 `10 3 4` 组成的矩形的巧克力数最大。\n\n**数据范围**\n\n对于全部的数据，$1\\le n,m\\le 300$，$0\\le a_{i,j} \\le 255$。", "locale": "zh-CN"}}}
{"pid": "P2707", "type": "P", "difficulty": 5, "samples": [["2 4\n50 2\n40 1", "171"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "堆", "洛谷原创"], "title": "Facer 帮父亲", "background": "Facer 可是一个孝顺的孩纸呦\n", "description": "Facer 的父亲是一名经理，现在总是垂头丧气的。\n\nFacer 问父亲，怎么啦？父亲说，公司出了点问题啊。\n\n公司管理着 $n$ 个风景点，每个风景点都有不少人来参观。\n\n可是现在！人民投诉票价太高了，他不得不调整票价。\n\n具体来说，第 $i$ 个景点如果票价是 $x$，来的人数就是 $\\max( (a_i - b_i\\times x),0 )$。\n\n你需要分配每个景点的门票，使得所有景点的门票总价之和不超过 $k$，求最大的收益。\n", "inputFormat": "第一行两个整数 $n, k$。\n\n接下来 $n$ 行，每行两个整数 $a_i,b_i$。\n", "outputFormat": "一行，表示最大的收益。\n", "hint": "样例解释：\n\n景点 $1$ 票价 $3$，景点 $2$ 票价 $1$。\n\n景点 $1$ 人数：$50 - 3\\times 2 = 44$，收益：$132$。\n\n景点 $2$ 人数：$40 - 1\\times 1 = 39$，收益：$39$。\n\n总收益为 $171$。\n\n\n- 对于 $10\\%$ 的数据，$ 1 \\le n \\le 5 , 1 \\le k \\le 5$；\n- 对于 $30\\%$ 的数据，$ 1 \\le n \\le 100, 1 \\le k \\le 100$；\n- 对于 $60\\%$ 的数据，$ 1 \\le n \\le 2000, 1 \\le k \\le 2000$；\n- 对于 $100\\%$ 的数据，$ 1 \\le n \\le 100000, 1 \\le k \\le 100000,1 \\le a_i , b_i \\le 100000$。\n\n\n鸣谢 zhouyonglong 提供解法。", "locale": "zh-CN", "translations": {"en": {"title": "Facer Helps His Father", "background": "Facer is a very filial child.", "description": "Facer's father is a manager and is now always dejected.\n\nFacer asked his father, what's wrong? His father said, the company has a problem.\n\nThe company manages $n$ scenic spots, each of which has many visitors.\n\nBut now, people complain that the ticket prices are too high, so he has to adjust the prices.\n\nSpecifically, for the $i$-th scenic spot, if the ticket price is $x$, the number of visitors is $\\max( (a_i - b_i\\times x),0 )$.\n\nYou need to assign the ticket price for each scenic spot such that the sum of ticket prices over all scenic spots does not exceed $k$, and find the maximum revenue.", "inputFormat": "The first line contains two integers $n, k$.\n\nThen follow $n$ lines, each containing two integers $a_i, b_i$.", "outputFormat": "One line, indicating the maximum revenue.", "hint": "Sample explanation:\n\nScenic spot $1$ ticket price is $3$, scenic spot $2$ ticket price is $1$.\n\nScenic spot $1$ visitors: $50 - 3\\times 2 = 44$, revenue: $132$.\n\nScenic spot $2$ visitors: $40 - 1\\times 1 = 39$, revenue: $39$.\n\nThe total revenue is $171$.\n\n- For $10\\%$ of the testdata, $1 \\le n \\le 5$, $1 \\le k \\le 5$.\n- For $30\\%$ of the testdata, $1 \\le n \\le 100$, $1 \\le k \\le 100$.\n- For $60\\%$ of the testdata, $1 \\le n \\le 2000$, $1 \\le k \\le 2000$.\n- For $100\\%$ of the testdata, $1 \\le n \\le 100000$, $1 \\le k \\le 100000$, $1 \\le a_i, b_i \\le 100000$.\n\nThanks to zhouyonglong for providing the solution.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "Facer 帮父亲", "background": "Facer 可是一个孝顺的孩纸呦\n", "description": "Facer 的父亲是一名经理，现在总是垂头丧气的。\n\nFacer 问父亲，怎么啦？父亲说，公司出了点问题啊。\n\n公司管理着 $n$ 个风景点，每个风景点都有不少人来参观。\n\n可是现在！人民投诉票价太高了，他不得不调整票价。\n\n具体来说，第 $i$ 个景点如果票价是 $x$，来的人数就是 $\\max( (a_i - b_i\\times x),0 )$。\n\n你需要分配每个景点的门票，使得所有景点的门票总价之和不超过 $k$，求最大的收益。\n", "inputFormat": "第一行两个整数 $n, k$。\n\n接下来 $n$ 行，每行两个整数 $a_i,b_i$。\n", "outputFormat": "一行，表示最大的收益。\n", "hint": "样例解释：\n\n景点 $1$ 票价 $3$，景点 $2$ 票价 $1$。\n\n景点 $1$ 人数：$50 - 3\\times 2 = 44$，收益：$132$。\n\n景点 $2$ 人数：$40 - 1\\times 1 = 39$，收益：$39$。\n\n总收益为 $171$。\n\n\n- 对于 $10\\%$ 的数据，$ 1 \\le n \\le 5 , 1 \\le k \\le 5$；\n- 对于 $30\\%$ 的数据，$ 1 \\le n \\le 100, 1 \\le k \\le 100$；\n- 对于 $60\\%$ 的数据，$ 1 \\le n \\le 2000, 1 \\le k \\le 2000$；\n- 对于 $100\\%$ 的数据，$ 1 \\le n \\le 100000, 1 \\le k \\le 100000,1 \\le a_i , b_i \\le 100000$。\n\n\n鸣谢 zhouyonglong 提供解法。", "locale": "zh-CN"}}}
{"pid": "P2708", "type": "P", "difficulty": 2, "samples": [["10", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["模拟", "字符串", "搜索"], "title": "硬币翻转", "background": "", "description": "有很多个硬币摆在一行，有正面朝上的，也有背面朝上的。正面朝上的用 $1$ 表示，背面朝上的用 $0$ 表示。\n\n现在要求从这行的第一个硬币开始，将**从第一个硬币开始的前若干个硬币**同时翻面，求如果要将所有硬币翻到正面朝上，最少要进行这样的操作多少次？\n", "inputFormat": "一个字符串，由 $0$ 和 $1$ 组成，表示硬币的初始状态。", "outputFormat": "一个整数，表示要翻转的最少次数。\n", "hint": "### 样例解释\n\n- 第 $1$ 次翻转：把第一个硬币翻到反面，字符串为 $00$；\n- 第 $2$ 次翻转：把第一、二个硬币一起翻到正面，字符串为 $11$，翻转完成，输出 $2$。\n\n### 数据范围\n\n记 $n$ 表示硬币的总个数，\n\n- 对于 $20\\%$ 的数据，$1\\le n\\leq10$；\n- 对于 $50\\%$ 的数据，$1\\le n\\leq10^4$；\n- 对于 $100\\%$ 的数据，$1\\le n\\leq10^6$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Coin Flipping", "background": "", "description": "There are many coins placed in a row. Heads-up is represented by $1$, and tails-up is represented by $0$.\n\nStarting from the first coin in the row, in each operation you must flip the first several coins simultaneously, i.e., choose some $k \\ge 1$ and flip the first $k$ coins. What is the minimum number of such operations needed to make all coins heads-up?", "inputFormat": "A string consisting of $0$ and $1$, representing the initial state of the coins.", "outputFormat": "An integer, the minimum number of flips required.", "hint": "### Sample Explanation\n\nFor example, for input 10:\n- The $1$-st flip: flip the first coin to tails; the string becomes 00.\n- The $2$-nd flip: flip the first and second coins together to heads; the string becomes 11. Flipping is complete, so the output is $2$.\n\n### Constraints\n\nLet $n$ be the total number of coins.\n\n- For $20\\%$ of the testdata, $1\\le n\\leq10$.\n- For $50\\%$ of the testdata, $1\\le n\\leq10^4$.\n- For $100\\%$ of the testdata, $1\\le n\\leq10^6$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "硬币翻转", "background": "", "description": "有很多个硬币摆在一行，有正面朝上的，也有背面朝上的。正面朝上的用 $1$ 表示，背面朝上的用 $0$ 表示。\n\n现在要求从这行的第一个硬币开始，将**从第一个硬币开始的前若干个硬币**同时翻面，求如果要将所有硬币翻到正面朝上，最少要进行这样的操作多少次？\n", "inputFormat": "一个字符串，由 $0$ 和 $1$ 组成，表示硬币的初始状态。", "outputFormat": "一个整数，表示要翻转的最少次数。\n", "hint": "### 样例解释\n\n- 第 $1$ 次翻转：把第一个硬币翻到反面，字符串为 $00$；\n- 第 $2$ 次翻转：把第一、二个硬币一起翻到正面，字符串为 $11$，翻转完成，输出 $2$。\n\n### 数据范围\n\n记 $n$ 表示硬币的总个数，\n\n- 对于 $20\\%$ 的数据，$1\\le n\\leq10$；\n- 对于 $50\\%$ 的数据，$1\\le n\\leq10^4$；\n- 对于 $100\\%$ 的数据，$1\\le n\\leq10^6$。\n", "locale": "zh-CN"}}}
{"pid": "P2709", "type": "P", "difficulty": 5, "samples": [["6 4 3\n1 3 2 1 1 3\n1 4\n2 6\n3 5\n5 6", "6\n9\n5\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["莫队", "模板题"], "title": "【模板】莫队 / 小B的询问", "background": "", "description": "小 B 有一个长为 $n$ 的整数序列 $a$，值域为 $[1,k]$。  \n他一共有 $m$ 个询问，每个询问给定一个区间 $[l,r]$，求：  \n$$\\sum\\limits_{i=1}^k c_i^2$$\n\n其中 $c_i$ 表示数字 $i$ 在 $[l,r]$ 中的出现次数。\n\n小 B 请你帮助他回答询问。", "inputFormat": "第一行三个整数 $n,m,k$。\n\n第二行 $n$ 个整数，表示小 B 的序列。\n\n接下来的 $m$ 行，每行两个整数 $l,r$。", "outputFormat": "输出 $m$ 行，每行一个整数，对应一个询问的答案。", "hint": "【数据范围】   \n对于 $100\\%$ 的数据，$1\\le n,m,k \\le 5\\times 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Mo's Algorithm / Xiao B's Queries", "background": "", "description": "Xiao B has an integer sequence $a$ of length $n$, with values in $[1, k]$.\nHe has $m$ queries. For each query, given an interval $[l, r]$, compute:\n$$\\sum\\limits_{i=1}^k c_i^2$$\nwhere $c_i$ denotes the number of occurrences of the number $i$ in $[l, r]$.\n\nPlease help Xiao B answer the queries.", "inputFormat": "The first line contains three integers $n, m, k$.\n\nThe second line contains $n$ integers, representing Xiao B's sequence.\n\nEach of the next $m$ lines contains two integers $l, r$.", "outputFormat": "Output $m$ lines. Each line contains one integer, which is the answer to a query.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n, m, k \\le 5 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】莫队 / 小B的询问", "background": "", "description": "小 B 有一个长为 $n$ 的整数序列 $a$，值域为 $[1,k]$。  \n他一共有 $m$ 个询问，每个询问给定一个区间 $[l,r]$，求：  \n$$\\sum\\limits_{i=1}^k c_i^2$$\n\n其中 $c_i$ 表示数字 $i$ 在 $[l,r]$ 中的出现次数。\n\n小 B 请你帮助他回答询问。", "inputFormat": "第一行三个整数 $n,m,k$。\n\n第二行 $n$ 个整数，表示小 B 的序列。\n\n接下来的 $m$ 行，每行两个整数 $l,r$。", "outputFormat": "输出 $m$ 行，每行一个整数，对应一个询问的答案。", "hint": "【数据范围】   \n对于 $100\\%$ 的数据，$1\\le n,m,k \\le 5\\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2710", "type": "P", "difficulty": 6, "samples": [["9 8\n2 -6 3 5 1 -5 -3 6 3\nGET-SUM 5 4\nMAX-SUM 1 9\nINSERT 8 3 -5 7 2\nDELETE 12 1\nMAKE-SAME 3 3 2\nREVERSE 3 6\nGET 5\nMAX-SUM 1 11", "-1\n10\n-5\n10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["平衡树", "洛谷原创", "洛谷比赛"], "title": "数列", "background": null, "description": "维护一个数列,共 $7$ 种操作:\n\nI. `INSERT x n a1 a2 .. an` 在第 $x$ 个数后插入 $n$ 个数分别为 $a_1\\dots a_n$。\n\nII. `DELETE x n` 删除第 $x$ 个数开始的 $n$ 个数。\n\nIII. `REVERSE x n` 翻转第 $x$ 个数开始的 $n$ 个数的区间。\n\nIV. `MAKE-SAME x n t` 将第 $x$ 个数开始的 $n$ 个数统一改为 $t$。\n\nV. `GET-SUM x n` 输出第 $x$ 个数开始的 $n$ 个数的和。\n\nVI. `GET x` 输出第 $x$ 个数的值。\n\nVII. `MAX-SUM x n` 输出第 $x$ 个数开始的 $n$ 个数的非空最大连续子序列和。", "inputFormat": "第一行为 $N$，$M$，$N$ 表示初始序列中数的个数，$M$ 表示操作的个数。\n\n第二行为 $N$ 个数 $A_1\\dots A_n$，表示初始序列。\n\n第三行到第 $M+2 $行，每行一个操作。", "outputFormat": "输出每个`GET-SUM`，`GET`，`MAX-SUM`操作的结果。", "hint": "共 $20$ 组数据，每组数据随机生成，  \n保证每个时刻数列里的数不超过 $200000$ 个，  \n任何一个输入的数字均在 $-1000\\sim1000$之间，结果不超过 $2^{30}$。\n\n第 $1\\sim2$ 组 $\\quad1\\le N\\le 5$，$1\\le M\\le 10$。\n\n第 $3\\sim4$ 组 $\\quad1\\le N\\le 10$，$1\\le M\\le 20$。\n\n第 $5\\sim6$ 组 $\\quad1\\le N \\le 20$，$1\\le M\\le 50$。\n\n第 $7\\sim8$ 组 $\\quad1\\le N\\le 50$，$1\\le M\\le 100$。\n\n第 $9\\sim10$ 组 $\\quad1\\le N\\le 100$，$1\\le M\\le 500$。\n\n第 $11\\sim12$ 组 $\\quad 1\\le N\\le 1000$，$1\\le M\\le 1000$。\n\n第 $13\\sim14$ 组 $\\quad1\\le N\\le 5000$，$1\\le M\\le 2000$。\n\n第 $15\\sim16$ 组 $\\quad1\\le N\\le 10^4$，$1\\le M\\le 5000$。\n\n第 $17\\sim18$ 组 $\\quad1\\le N\\le 10^5$，$1\\le M\\le 10^4$。\n\n第 $19\\sim20$ 组 $\\quad1\\le N\\le 2\\times 10^5$，$1\\le M\\le 2\\times 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "Sequence", "background": "", "description": "Maintain a sequence with a total of $7$ operations:\n\nI. `INSERT x n a1 a2 .. an` Insert $n$ numbers $a_1 \\dots a_n$ after the $x$-th number.\n\nII. `DELETE x n` Delete $n$ numbers starting from the $x$-th number.\n\nIII. `REVERSE x n` Reverse the interval of $n$ numbers starting from the $x$-th number.\n\nIV. `MAKE-SAME x n t` Set the $n$ numbers starting from the $x$-th number all to $t$.\n\nV. `GET-SUM x n` Output the sum of the $n$ numbers starting from the $x$-th number.\n\nVI. `GET x` Output the value of the $x$-th number.\n\nVII. `MAX-SUM x n` Output the maximum subarray sum within the $n$ numbers starting from the $x$-th number.", "inputFormat": "The first line contains $N$, $M$, where $N$ is the number of elements in the initial sequence, and $M$ is the number of operations.\n\nThe second line contains $N$ numbers $A_1 \\dots A_N$, representing the initial sequence.\n\nFrom the third line to line $M+2$, each line contains one operation.", "outputFormat": "Output the result of each `GET-SUM`, `GET`, and `MAX-SUM` operation.", "hint": "There are $20$ groups of testdata, each randomly generated.  \nIt is guaranteed that at any time the sequence contains at most $200000$ numbers.  \nEvery input integer is in $[-1000, 1000]$, and any result does not exceed $2^{30}$.\n\nGroups 1–2: $1 \\le N \\le 5$, $1 \\le M \\le 10$.\n\nGroups 3–4: $1 \\le N \\le 10$, $1 \\le M \\le 20$.\n\nGroups 5–6: $1 \\le N \\le 20$, $1 \\le M \\le 50$.\n\nGroups 7–8: $1 \\le N \\le 50$, $1 \\le M \\le 100$.\n\nGroups 9–10: $1 \\le N \\le 100$, $1 \\le M \\le 500$.\n\nGroups 11–12: $1 \\le N \\le 1000$, $1 \\le M \\le 1000$.\n\nGroups 13–14: $1 \\le N \\le 5000$, $1 \\le M \\le 2000$.\n\nGroups 15–16: $1 \\le N \\le 10^4$, $1 \\le M \\le 5000$.\n\nGroups 17–18: $1 \\le N \\le 10^5$, $1 \\le M \\le 10^4$.\n\nGroups 19–20: $1 \\le N \\le 2 \\times 10^5$, $1 \\le M \\le 2 \\times 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "数列", "background": null, "description": "维护一个数列,共 $7$ 种操作:\n\nI. `INSERT x n a1 a2 .. an` 在第 $x$ 个数后插入 $n$ 个数分别为 $a_1\\dots a_n$。\n\nII. `DELETE x n` 删除第 $x$ 个数开始的 $n$ 个数。\n\nIII. `REVERSE x n` 翻转第 $x$ 个数开始的 $n$ 个数的区间。\n\nIV. `MAKE-SAME x n t` 将第 $x$ 个数开始的 $n$ 个数统一改为 $t$。\n\nV. `GET-SUM x n` 输出第 $x$ 个数开始的 $n$ 个数的和。\n\nVI. `GET x` 输出第 $x$ 个数的值。\n\nVII. `MAX-SUM x n` 输出第 $x$ 个数开始的 $n$ 个数的非空最大连续子序列和。", "inputFormat": "第一行为 $N$，$M$，$N$ 表示初始序列中数的个数，$M$ 表示操作的个数。\n\n第二行为 $N$ 个数 $A_1\\dots A_n$，表示初始序列。\n\n第三行到第 $M+2 $行，每行一个操作。", "outputFormat": "输出每个`GET-SUM`，`GET`，`MAX-SUM`操作的结果。", "hint": "共 $20$ 组数据，每组数据随机生成，  \n保证每个时刻数列里的数不超过 $200000$ 个，  \n任何一个输入的数字均在 $-1000\\sim1000$之间，结果不超过 $2^{30}$。\n\n第 $1\\sim2$ 组 $\\quad1\\le N\\le 5$，$1\\le M\\le 10$。\n\n第 $3\\sim4$ 组 $\\quad1\\le N\\le 10$，$1\\le M\\le 20$。\n\n第 $5\\sim6$ 组 $\\quad1\\le N \\le 20$，$1\\le M\\le 50$。\n\n第 $7\\sim8$ 组 $\\quad1\\le N\\le 50$，$1\\le M\\le 100$。\n\n第 $9\\sim10$ 组 $\\quad1\\le N\\le 100$，$1\\le M\\le 500$。\n\n第 $11\\sim12$ 组 $\\quad 1\\le N\\le 1000$，$1\\le M\\le 1000$。\n\n第 $13\\sim14$ 组 $\\quad1\\le N\\le 5000$，$1\\le M\\le 2000$。\n\n第 $15\\sim16$ 组 $\\quad1\\le N\\le 10^4$，$1\\le M\\le 5000$。\n\n第 $17\\sim18$ 组 $\\quad1\\le N\\le 10^5$，$1\\le M\\le 10^4$。\n\n第 $19\\sim20$ 组 $\\quad1\\le N\\le 2\\times 10^5$，$1\\le M\\le 2\\times 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2712", "type": "P", "difficulty": 3, "samples": [["5\n1 1 2\n2 1 1\n3 1 7\n4 1 1\n5 0\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["拓扑排序"], "title": "摄像头", "background": null, "description": "食品店里有 $n$ 个摄像头，这种摄像头很笨拙，只能拍摄到固定位置。现有一群胆大妄为的松鼠想要抢劫食品店，为了不让摄像头拍下他们犯罪的证据，他们抢劫前的第一件事就是砸毁这些摄像头。\n\n为了便于砸毁摄像头，松鼠歹徒们把所有摄像头和摄像头能监视到的地方统一编号，一个摄像头能被砸毁的条件是该摄像头所在位置不被其他摄像头监视。\n\n现在你的任务是帮松鼠们计算是否可以砸掉所有摄像头，如不能则输出还没砸掉的摄像头的数量。", "inputFormat": "第 $1$ 行，一个整数 $n$，表示摄像头的个数。\n\n第 $2$ 到 $n+1$ 行是摄像头的信息，包括：摄像头的位置 $x$，以及这个摄像头可以监视到的位置数 $m$，之后 $m$ 个数 $y$ 是此摄像头可以监视到的位置（砸了这些摄像头之后自然这些位置就监视不到了）。", "outputFormat": "若可以砸掉所有摄像头则输出“ $\\texttt{YES}$”，否则输出还没砸掉的摄像头的数量（不带引号）。", "hint": "$1 \\leq n \\leq 100$。\n\n$0 \\leq m \\leq 100$。\n\n$0 \\leq x,y \\leq 500$。", "locale": "zh-CN", "translations": {"en": {"title": "Cameras", "background": "", "description": "There are $n$ cameras in a grocery store. These cameras are clumsy and can only capture fixed positions. A group of bold squirrels wants to rob the store. To avoid being recorded, the first thing they plan to do is to destroy the cameras.\n\nTo make it easier to destroy the cameras, the squirrels assign a unified set of IDs to all cameras and to all positions that any camera can monitor. A camera can be destroyed if and only if the position where it is located is not monitored by any other camera.\n\nYour task is to determine whether it is possible to destroy all cameras. If not, output the number of cameras that remain undestroyed.", "inputFormat": "The first line contains an integer $n$, the number of cameras.\n\nLines $2$ to $n+1$ describe the cameras. Each line contains the camera’s position $x$, the number of positions $m$ it can monitor, followed by $m$ numbers $y$ that are the positions this camera can monitor (once this camera is destroyed, these positions are naturally no longer monitored).", "outputFormat": "If it is possible to destroy all cameras, output $\\texttt{YES}$; otherwise, output the number of cameras that remain undestroyed (without quotes).", "hint": "Constraints\n\n- $1 \\leq n \\leq 100$.\n- $0 \\leq m \\leq 100$.\n- $0 \\leq x, y \\leq 500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "摄像头", "background": null, "description": "食品店里有 $n$ 个摄像头，这种摄像头很笨拙，只能拍摄到固定位置。现有一群胆大妄为的松鼠想要抢劫食品店，为了不让摄像头拍下他们犯罪的证据，他们抢劫前的第一件事就是砸毁这些摄像头。\n\n为了便于砸毁摄像头，松鼠歹徒们把所有摄像头和摄像头能监视到的地方统一编号，一个摄像头能被砸毁的条件是该摄像头所在位置不被其他摄像头监视。\n\n现在你的任务是帮松鼠们计算是否可以砸掉所有摄像头，如不能则输出还没砸掉的摄像头的数量。", "inputFormat": "第 $1$ 行，一个整数 $n$，表示摄像头的个数。\n\n第 $2$ 到 $n+1$ 行是摄像头的信息，包括：摄像头的位置 $x$，以及这个摄像头可以监视到的位置数 $m$，之后 $m$ 个数 $y$ 是此摄像头可以监视到的位置（砸了这些摄像头之后自然这些位置就监视不到了）。", "outputFormat": "若可以砸掉所有摄像头则输出“ $\\texttt{YES}$”，否则输出还没砸掉的摄像头的数量（不带引号）。", "hint": "$1 \\leq n \\leq 100$。\n\n$0 \\leq m \\leq 100$。\n\n$0 \\leq x,y \\leq 500$。", "locale": "zh-CN"}}}
{"pid": "P2713", "type": "P", "difficulty": 5, "samples": [["5\n100 90 66 99 10\n7\nM 1 5\nK 1\nK 1\nM 2 3\nM 3 4\nK 5\nK 4", "10\n100\n0\n66"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}, "tags": ["可并堆", "洛谷比赛"], "title": "罗马游戏", "background": null, "description": "罗马皇帝很喜欢玩杀人游戏。他的军队里面有 $n$ 个士兵，每个士兵都是一个独立的团。最近举行了一次平面几何测试，每个士兵都得到了一个分数。皇帝很喜欢平面几何，他对那些得分很低的士兵嗤之以鼻。\n\n他决定玩这样一个游戏。 它可以发两种命令：\n\n- `M i j` 把 $i$ 所在的团和 $j$ 所在的团合并成一个团。如果 $i,j$ 有一个士兵是死人，那么就忽略该命令。  \n- `K i` 把 $i$ 所在的团里面得分最低的士兵杀死。如果 $i$ 这个士兵已经死了，这条命令就忽略。\n\n皇帝希望他每发布一条 `K i` 命令，下面的将军就把被杀的士兵的分数报上来 \n（如果这条命令被忽略，那么就报  $0$ 分）。 \n\n保证**士兵的分数互不相同**。", "inputFormat": "第一行一个整数  $n$，表示士兵数。  \n\n第二行 $n$ 个整数 $a_1,a_2,\\ldots a_n$，其中 $a_i$ 表示编号为 $i$ 的士兵的分数。\n\n第三行一个整数 $m$。\n\n第   $3+i$ 行描述第 $i$ 条命令。命令为如下两种形式：`M i j` 或 `K i`。", "outputFormat": "如果命令是 `K i`，对应的请输出被杀士兵的分数（如果这个人不存在，就输出  $0$）。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le m\\le 10^5$，$0\\le a_i\\le 10^7$，**注意测试数据中 `M i j` 的 $i,j$ 可能在同一个团中。**", "locale": "zh-CN", "translations": {"en": {"title": "Roman Game", "background": "", "description": "The Roman emperor enjoys a killing game. His army has $n$ soldiers, and each soldier initially forms an independent group. A recent plane geometry test was held, and each soldier received a score. The emperor loves plane geometry and despises soldiers with low scores.\n\nHe decides to play the following game. He can issue two types of commands:\n\n- `M i j` Merge the groups containing $i$ and $j$ into one group. If either $i$ or $j$ is already dead, ignore this command.\n- `K i` Kill the lowest-scoring soldier in the group containing $i$. If soldier $i$ is already dead, ignore this command.\n\nAfter each `K i` command, the general should report the score of the soldier who was killed (if the command is ignored, report $0$).\n\nIt is guaranteed that all soldiers’ scores are pairwise distinct.", "inputFormat": "The first line contains an integer $n$, the number of soldiers.\n\nThe second line contains $n$ integers $a_1, a_2, \\ldots, a_n$, where $a_i$ is the score of the soldier with index $i$.\n\nThe third line contains an integer $m$.\n\nThe $(3 + i)$-th line describes the $i$-th command, which is either `M i j` or `K i`.", "outputFormat": "For each `K i` command, output the score of the killed soldier (if such a person does not exist, output $0$).", "hint": "Constraints:\n- For $100\\%$ of the testdata, $1 \\le n \\le 10^6$, $1 \\le m \\le 10^5$, $0 \\le a_i \\le 10^7$. Note: In the testdata, in the command `M i j`, $i$ and $j$ may already be in the same group.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "罗马游戏", "background": null, "description": "罗马皇帝很喜欢玩杀人游戏。他的军队里面有 $n$ 个士兵，每个士兵都是一个独立的团。最近举行了一次平面几何测试，每个士兵都得到了一个分数。皇帝很喜欢平面几何，他对那些得分很低的士兵嗤之以鼻。\n\n他决定玩这样一个游戏。 它可以发两种命令：\n\n- `M i j` 把 $i$ 所在的团和 $j$ 所在的团合并成一个团。如果 $i,j$ 有一个士兵是死人，那么就忽略该命令。  \n- `K i` 把 $i$ 所在的团里面得分最低的士兵杀死。如果 $i$ 这个士兵已经死了，这条命令就忽略。\n\n皇帝希望他每发布一条 `K i` 命令，下面的将军就把被杀的士兵的分数报上来 \n（如果这条命令被忽略，那么就报  $0$ 分）。 \n\n保证**士兵的分数互不相同**。", "inputFormat": "第一行一个整数  $n$，表示士兵数。  \n\n第二行 $n$ 个整数 $a_1,a_2,\\ldots a_n$，其中 $a_i$ 表示编号为 $i$ 的士兵的分数。\n\n第三行一个整数 $m$。\n\n第   $3+i$ 行描述第 $i$ 条命令。命令为如下两种形式：`M i j` 或 `K i`。", "outputFormat": "如果命令是 `K i`，对应的请输出被杀士兵的分数（如果这个人不存在，就输出  $0$）。", "hint": "对于 $100\\%$ 的数据，$1\\le n\\le 10^6$，$1\\le m\\le 10^5$，$0\\le a_i\\le 10^7$，**注意测试数据中 `M i j` 的 $i,j$ 可能在同一个团中。**", "locale": "zh-CN"}}}
{"pid": "P2714", "type": "P", "difficulty": 6, "samples": [["4\n2 3 4 5\n4\n2 4 6 8\n7\n2 3 4 5 7 6 8  ", "1\n0\n34\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "容斥原理"], "title": "四元组统计", "background": "", "description": "有 $n$ 个正整数 $a _ i$，你要统计有多少个四元组满足 $\\gcd(a _ i, a _ j, a _ k, a _ l) = 1$。\n", "inputFormat": "输入包含多组数据。  \n对于每组数据：第一行一个正整数 $n$，接下来一行 $n$ 个正整数 $a _ i$。\n", "outputFormat": "若干行，每行对应一个输入数据，表示满足要求的四元组的个数。\n", "hint": "对于 $30\\%$ 的数据，$4 ≤ n ≤ 10$，且数据组数不超过 $10$；\n\n对于 $100\\%$ 的数据，$4 ≤ n ≤ 10000$，$1 ≤ a _ i≤ 10000$，且数据组数不超过 $100$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Counting Quadruples", "background": "", "description": "There are $n$ positive integers $a _ i$. You need to count how many quadruples satisfy $\\gcd(a _ i, a _ j, a _ k, a _ l) = 1$.", "inputFormat": "The input contains multiple testdata sets.\nFor each testdata set: the first line contains a positive integer $n$, followed by one line with $n$ positive integers $a _ i$.", "outputFormat": "Several lines, each corresponding to one testdata set, representing the number of quadruples that satisfy the requirement.", "hint": "For $30\\%$ of the testdata, $4 \\le n \\le 10$, and the number of testdata sets does not exceed $10$.\n\nFor $100\\%$ of the testdata, $4 \\le n \\le 10000$, $1 \\le a _ i \\le 10000$, and the number of testdata sets does not exceed $100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "四元组统计", "background": "", "description": "有 $n$ 个正整数 $a _ i$，你要统计有多少个四元组满足 $\\gcd(a _ i, a _ j, a _ k, a _ l) = 1$。\n", "inputFormat": "输入包含多组数据。  \n对于每组数据：第一行一个正整数 $n$，接下来一行 $n$ 个正整数 $a _ i$。\n", "outputFormat": "若干行，每行对应一个输入数据，表示满足要求的四元组的个数。\n", "hint": "对于 $30\\%$ 的数据，$4 ≤ n ≤ 10$，且数据组数不超过 $10$；\n\n对于 $100\\%$ 的数据，$4 ≤ n ≤ 10000$，$1 ≤ a _ i≤ 10000$，且数据组数不超过 $100$。\n", "locale": "zh-CN"}}}
{"pid": "P2715", "type": "P", "difficulty": 3, "samples": [["1+1    =                     ?", "2.00"], ["1-?                     =0", "1.00"], ["2*?=                         6", "3.00"], ["8/5=?", "1.60"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟"], "title": "ccj与zrz之在回家的路上", "background": "zrz走在回家了路上，突然很想上厕所，然后就冲到厕所门口，惊讶的发现门上有个算式。。。\n", "description": "给出一个算式（a\\*b=c或a/b=c或a+b=c或a-b=c）其中a，b，c是三个数字，但是其中有一个是问号，表示未知，请你求出未知的那一个量。\n", "inputFormat": "只有一行，一个算式（a\\*b=c或a/b=c或a+b=c或a-b=c），可能会有多余的空格\n", "outputFormat": "“?”代表的数字，保留2位小数。\n", "hint": "总长度小于200，所有数字和要求的数字均不会超过1000000000，也不会是负数。读入的数不会是小数，但答案有可能是\n", "locale": "zh-CN", "translations": {"en": {"title": "ccj and zrz on the Way Home", "background": "zrz was walking on the way home, suddenly really needed to use the restroom, rushed to the restroom door, and was surprised to find an equation on it.", "description": "Given an expression ($a*b=c$ or $a/b=c$ or $a+b=c$ or $a-b=c$) where $a$, $b$, and $c$ are three numbers, but one of them is a question mark '?', meaning unknown, please find the unknown value.", "inputFormat": "A single line containing an expression ($a*b=c$ or $a/b=c$ or $a+b=c$ or $a-b=c$), which may contain extra spaces.", "outputFormat": "The number represented by '?', formatted to 2 decimal places.", "hint": "The total length is less than 200. All numbers and the required number will not exceed 1000000000, and none are negative. The input numbers are integers (not decimals), but the answer may be a decimal.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "ccj与zrz之在回家的路上", "background": "zrz走在回家了路上，突然很想上厕所，然后就冲到厕所门口，惊讶的发现门上有个算式。。。\n", "description": "给出一个算式（a\\*b=c或a/b=c或a+b=c或a-b=c）其中a，b，c是三个数字，但是其中有一个是问号，表示未知，请你求出未知的那一个量。\n", "inputFormat": "只有一行，一个算式（a\\*b=c或a/b=c或a+b=c或a-b=c），可能会有多余的空格\n", "outputFormat": "“?”代表的数字，保留2位小数。\n", "hint": "总长度小于200，所有数字和要求的数字均不会超过1000000000，也不会是负数。读入的数不会是小数，但答案有可能是\n", "locale": "zh-CN"}}}
{"pid": "P2716", "type": "P", "difficulty": 5, "samples": [["3 5 7\n3 4 2 8 7\n6 5 2 4 6\n3 1 4 0 9", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["洛谷原创", "洛谷比赛"], "title": "和谐的雪花", "background": "没有背景\n", "description": "现在有 $n\\times m$ 个雪花，被放在了一个 $n\\ \\times m$ 的矩阵当中。每个雪花都有一个优美值。一个正方形的和谐度被定义为在这个正方形中雪花的最大优美值和最小优美值的差，和谐度越大这个正方形就越和谐。现在给出这个矩阵和一个非负整数 $k$，zzs 和 zzy 希望你能告诉他，在所有和谐度不小于 $k$ 的正方形中，边长最小的正方形的边长（即找到一个最小的边长 $a$，使得存在一个边长为 $a$ 的正方形它的和谐度不小于 $k$）。如果没有解，输出 $-1$。", "inputFormat": "第一行两个正整数和一个非负整数，$n,m$ 和 $k$。\n\n接下来 $n$ 行，每行 $m$ 个非负整数，表示题目中的矩阵。", "outputFormat": "如果有解，则输出一个正整数，表示答案。如果无解，则是 $-1$。", "hint": "### 数据范围及约定\n\n- 对于 $20\\%$ 的数据，$1 \\le n,m \\le 20$；\n- 对于 $100\\%$ 的数据，$1 \\le n,m \\le 500$；\n- 对于 $100\\%$ 的数据，矩阵中所有数不超过 $100000$。", "locale": "zh-CN", "translations": {"en": {"title": "Harmonious Snowflakes", "background": "No background.", "description": "There are $n\\times m$ snowflakes placed in an $n\\times m$ matrix. Each snowflake has a beauty value. The harmony of a square is defined as the difference between the maximum beauty value and the minimum beauty value in that square. The greater the harmony value, the more harmonious the square is. Given this matrix and a non-negative integer $k$, zzs and zzy want you to tell them the smallest side length among all squares with harmony at least $k$ (that is, find the smallest side length $a$ such that there exists a square of side length $a$ whose harmony is at least $k$). If there is no solution, output $-1$.", "inputFormat": "The first line contains two positive integers and a non-negative integer, $n, m$ and $k$.\nThe next $n$ lines each contain $m$ non-negative integers, representing the matrix.", "outputFormat": "If there is a solution, output a single positive integer representing the answer. If there is no solution, output $-1$.", "hint": "Constraints\n\n- For $20\\%$ of the testdata, $1 \\le n, m \\le 20$.\n- For $100\\%$ of the testdata, $1 \\le n, m \\le 500$.\n- For $100\\%$ of the testdata, all numbers in the matrix do not exceed $100000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "和谐的雪花", "background": "没有背景\n", "description": "现在有 $n\\times m$ 个雪花，被放在了一个 $n\\ \\times m$ 的矩阵当中。每个雪花都有一个优美值。一个正方形的和谐度被定义为在这个正方形中雪花的最大优美值和最小优美值的差，和谐度越大这个正方形就越和谐。现在给出这个矩阵和一个非负整数 $k$，zzs 和 zzy 希望你能告诉他，在所有和谐度不小于 $k$ 的正方形中，边长最小的正方形的边长（即找到一个最小的边长 $a$，使得存在一个边长为 $a$ 的正方形它的和谐度不小于 $k$）。如果没有解，输出 $-1$。", "inputFormat": "第一行两个正整数和一个非负整数，$n,m$ 和 $k$。\n\n接下来 $n$ 行，每行 $m$ 个非负整数，表示题目中的矩阵。", "outputFormat": "如果有解，则输出一个正整数，表示答案。如果无解，则是 $-1$。", "hint": "### 数据范围及约定\n\n- 对于 $20\\%$ 的数据，$1 \\le n,m \\le 20$；\n- 对于 $100\\%$ 的数据，$1 \\le n,m \\le 500$；\n- 对于 $100\\%$ 的数据，矩阵中所有数不超过 $100000$。", "locale": "zh-CN"}}}
{"pid": "P2717", "type": "P", "difficulty": 4, "samples": [["3 2\n1\n2\n3\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["树状数组", "cdq 分治", "洛谷比赛"], "title": "寒假作业", "background": "zzs 和 zzy 正在被寒假作业折磨，然而他们有答案可以抄啊。\n", "description": "他们共有 $n$ 项寒假作业。zzy 给每项寒假作业都定义了一个疲劳值 $a_i$，表示抄这个作业所要花的精力。\n\nzzs 现在想要知道，有多少组连续的寒假作业的疲劳值的平均值不小于 $k$？\n\n简单地说，给定一个长度为 $n$ 的正整数序列 $\\{a_i\\}$，求出有多少个**连续**子序列的平均值不小于 $k$。\n", "inputFormat": "第一行是两个整数，分别表示序列长度 $n$ 和给定的参数 $k$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 样例 1 解释\n\n共有 $6$ 个连续的子序列，分别是 $(1)$、$(2)$、$(3)$、$(1,2)$、$(2,3)$、$(1,2,3)$，平均值分别为 $1$、$2$、$3$、$1.5$、$2.5$、$2$，其中平均值不小于 $2$ 的共有 $4$ 个。\n\n#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $n \\leq 100$。\n- 对于 $50\\%$ 的数据，保证 $n \\leq 5000$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^5$，$1 \\leq a_i,k \\leq 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "Winter Vacation Homework", "background": "zzs and zzy are being tormented by their winter vacation homework, but they have answers they can copy.", "description": "They have $n$ pieces of winter vacation homework. For each piece, zzy defined a fatigue value $a_i$, representing the effort required to copy that assignment.\n\nzzs wants to know how many contiguous groups of assignments have an average fatigue value not less than $k$.\n\nIn short, given a positive integer sequence of length $n$, $\\{a_i\\}$, count the number of **contiguous** subarrays whose average is not less than $k$.", "inputFormat": "The first line contains two integers, the sequence length $n$ and the given parameter $k$.\n\nThe second line contains $n$ integers, where the $i$-th integer is $a_i$.", "outputFormat": "Output one line with a single integer representing the answer.", "hint": "#### Sample 1 Explanation\n\nThere are $6$ contiguous subarrays: $(1)$, $(2)$, $(3)$, $(1,2)$, $(2,3)$, $(1,2,3)$. Their averages are $1$, $2$, $3$, $1.5$, $2.5$, $2$. Among them, there are $4$ whose average is not less than $2$.\n\n#### Constraints\n\n- For $20\\%$ of the testdata, it is guaranteed that $n \\leq 100$.\n- For $50\\%$ of the testdata, it is guaranteed that $n \\leq 5000$.\n- For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 10^5$, $1 \\leq a_i, k \\leq 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "寒假作业", "background": "zzs 和 zzy 正在被寒假作业折磨，然而他们有答案可以抄啊。\n", "description": "他们共有 $n$ 项寒假作业。zzy 给每项寒假作业都定义了一个疲劳值 $a_i$，表示抄这个作业所要花的精力。\n\nzzs 现在想要知道，有多少组连续的寒假作业的疲劳值的平均值不小于 $k$？\n\n简单地说，给定一个长度为 $n$ 的正整数序列 $\\{a_i\\}$，求出有多少个**连续**子序列的平均值不小于 $k$。\n", "inputFormat": "第一行是两个整数，分别表示序列长度 $n$ 和给定的参数 $k$。\n\n第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。", "outputFormat": "输出一行一个整数表示答案。", "hint": "#### 样例 1 解释\n\n共有 $6$ 个连续的子序列，分别是 $(1)$、$(2)$、$(3)$、$(1,2)$、$(2,3)$、$(1,2,3)$，平均值分别为 $1$、$2$、$3$、$1.5$、$2.5$、$2$，其中平均值不小于 $2$ 的共有 $4$ 个。\n\n#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，保证 $n \\leq 100$。\n- 对于 $50\\%$ 的数据，保证 $n \\leq 5000$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^5$，$1 \\leq a_i,k \\leq 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2719", "type": "P", "difficulty": 3, "samples": [["256", "0.9500"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "数学", "概率论"], "title": "搞笑世界杯", "background": "很久很久以后，一次世界杯。", "description": "随着世界杯小组赛的结束，法国、阿根廷等世界强队都纷纷被淘汰，让人心痛不已。于是有人组织了一场搞笑世界杯，将这些被淘汰的强队重新组织起来和世界杯一同比赛。你和你的朋友欣然去购买球票。不过搞笑世界杯的球票出售方式也很特别，它们只准备了两种球票。\n\n- A 类票——免费球票。\n- B 类票——双倍价钱球票。\n\n购买时由工作人员通过掷硬币决定，投到正面的买 A 类票，反面的买 B 类票。主办方总是准备了同样多的 A 类票和 B 类票。你和你的朋友十分幸运的排到了某场精彩比赛的最后两个位置。\n\n这时工作人员开始通过硬币售票。不过更为幸运的是当工作人员到你们面前时他发现已无需再掷硬币了，因为剩下的这两张票全是免费票。\n\n你和你的朋友在欣喜之余，想计算一下排在队尾的两个人同时拿到一种票的概率是多少（包括同时拿 A 类票或 B 类票）假设工作人员准备了 $2n$ 张球票，其中 $n$ 张 A 类票、$n$ 张 B 类票，并且排在队伍中的人每人必须且只能买一张球票（不管掷到的是该买 A 还是该买 B）。", "inputFormat": "输入只有一行一个整数，表示 $2n$。", "outputFormat": "输出只包含一行一个浮点数，为拿到同一种票的概率，精确到小数点后 4 位。", "hint": "## 数据规模与约定\n\n对全部的测试点，保证 $1 \\leq n \\leq 1250$。", "locale": "zh-CN", "translations": {"en": {"title": "Funny World Cup", "background": "A long, long time later, there was a World Cup.", "description": "After the World Cup group stage ended, world powerhouses such as France and Argentina were eliminated, which was heartbreaking. So someone organized a funny World Cup, regrouping these eliminated strong teams to compete alongside the World Cup. You and your friend gladly went to buy tickets. However, the ticket sale method for the funny World Cup was also special: they prepared only two kinds of tickets.\n\n- Type A — free ticket.\n- Type B — double-price ticket.\n\nAt purchase time, a staff member decides by flipping a coin: heads buys a type A ticket, tails buys a type B ticket. The organizer always prepared the same number of type A and type B tickets. You and your friend are lucky enough to be in the last two spots for a spectacular match.\n\nThe staff starts selling tickets via coin toss. But even more fortunately, when the staff reaches you two, he finds there is no need to flip the coin anymore, because the last two remaining tickets are both free.\n\nIn your delight, you want to calculate the probability that the last two people in line receive the same kind of ticket (including both getting type A or both getting type B). Assume the staff prepared $2n$ tickets, consisting of $n$ type A tickets and $n$ type B tickets, and each person in line must and can only buy exactly one ticket (regardless of whether the coin flip indicates buying A or B).", "inputFormat": "The input contains a single integer on one line, denoting $2n$.", "outputFormat": "Output a single floating-point number on one line: the probability that the last two people receive the same kind of ticket, accurate to 4 decimal places.", "hint": "# Constraints\n\nFor all test points, it is guaranteed that $1 \\leq n \\leq 1250$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "搞笑世界杯", "background": "很久很久以后，一次世界杯。", "description": "随着世界杯小组赛的结束，法国、阿根廷等世界强队都纷纷被淘汰，让人心痛不已。于是有人组织了一场搞笑世界杯，将这些被淘汰的强队重新组织起来和世界杯一同比赛。你和你的朋友欣然去购买球票。不过搞笑世界杯的球票出售方式也很特别，它们只准备了两种球票。\n\n- A 类票——免费球票。\n- B 类票——双倍价钱球票。\n\n购买时由工作人员通过掷硬币决定，投到正面的买 A 类票，反面的买 B 类票。主办方总是准备了同样多的 A 类票和 B 类票。你和你的朋友十分幸运的排到了某场精彩比赛的最后两个位置。\n\n这时工作人员开始通过硬币售票。不过更为幸运的是当工作人员到你们面前时他发现已无需再掷硬币了，因为剩下的这两张票全是免费票。\n\n你和你的朋友在欣喜之余，想计算一下排在队尾的两个人同时拿到一种票的概率是多少（包括同时拿 A 类票或 B 类票）假设工作人员准备了 $2n$ 张球票，其中 $n$ 张 A 类票、$n$ 张 B 类票，并且排在队伍中的人每人必须且只能买一张球票（不管掷到的是该买 A 还是该买 B）。", "inputFormat": "输入只有一行一个整数，表示 $2n$。", "outputFormat": "输出只包含一行一个浮点数，为拿到同一种票的概率，精确到小数点后 4 位。", "hint": "## 数据规模与约定\n\n对全部的测试点，保证 $1 \\leq n \\leq 1250$。", "locale": "zh-CN"}}}
{"pid": "P2720", "type": "P", "difficulty": 5, "samples": [["4\n1 2 2\n1 2 3 3\n2\n1\n2", "3\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "小A的礼物", "background": "** 数据已更新（2018-3-2） **", "description": "小 A 去学校参加活动辣，学校会发礼物哦，学校有很多礼物点。\n\n每一个礼物点都有去别的礼物点的道路和各种种类的礼物。\n\n为了防止多次领礼物，这些道路都是单向的道路，并且没有环。\n\n而且对于每条边连接 $a$，$b$ 点，如果删去这条边之后，存在点 $c$ 可以到达 $a$，也能到达 $b$，那么这条边就不会存在于路径中。\n\n并且除了点 $1$ 之外，所有点有且只有一条入边。\n\n小 A 想知道，对于点 $S$ 能到达的所有点（包括本身），有多少种不同的礼物？", "inputFormat": "第一行是礼物点的数量$n$ ($n \\le 100000$)\n\n接下来 1 行 $n-1$ 个数，分别代表点 $2,\\cdots, n$ 的入点\n\n接下来 1 行 $n$ 个数，代表每个节点的礼物编号\n\n接下来一行是 $m$，代表询问数量\n\n接下来 $m$ 行，每行一个节点编号，代表询问的节点编号\n", "outputFormat": "对于每个询问，输出礼物总数\n", "hint": "### 样例解释\n点 $1$ 可以到达点 $(1, 2, 3, 4)$，有三种礼物 $(1,2,3)$。\n\n点 $2$ 可以到达点 $2, 3, 4$，有两种礼物 $2, 3$。\n\n### 数据范围\n\n\n|测试点编号|$n$|$m$|$c_i$（颜色）|\n|:-:|:-:|:-:|:-:|\n|$1$|$\\le 10^2$|$\\le 10^2$|$\\le 10^2$|\n|$2\\sim3$|$\\le 10^3$|$\\le 10^3$|$\\le 10^3$|\n|$4\\sim5$|$\\le 10^4$|$\\le 10^4$|$\\le 20$|\n|$6$|$\\le5\\times 10^4$|$\\le5\\times 10^4$|$\\le5\\times 10^4$|\n|$7\\sim8$|$\\le 10^5$|$\\le5\\times 10^4$|$\\le6\\times 10^4$|", "locale": "zh-CN", "translations": {"en": {"title": "Xiao A's Gift", "background": "**Testdata updated (2018-3-2).**", "description": "Xiao A went to school to attend an event, and the school gives out gifts. The school has many gift points.\n\nEach gift point has outgoing roads to other gift points and a gift type.\n\nTo prevent picking up gifts multiple times, these roads are directed and acyclic.\n\nMoreover, for any edge from $a$ to $b$, if after removing this edge there exists a node $c$ that can reach both $a$ and $b$, then such an edge does not appear in the graph.\n\nIn addition, every node except node $1$ has exactly one incoming edge.\n\nXiao A wants to know, for all nodes reachable from a node $S$ (including $S$ itself), how many distinct gift types are there.", "inputFormat": "- The first line contains the number of gift points $n$ ($n \\le 100000$).\n- The next line contains $n - 1$ integers, representing the parent (in-neighbor) of nodes $2, \\dots, n$ respectively; that is, the $i$-th integer is the parent of node $i + 1$.\n- The next line contains $n$ integers, where the $i$-th integer is the gift ID of node $i$.\n- The next line contains $m$, the number of queries.\n- Each of the next $m$ lines contains one node ID, representing a query node.", "outputFormat": "For each query, output the number of distinct gifts.", "hint": "Sample Explanation:\n- Node $1$ can reach nodes $(1, 2, 3, 4)$, with three gift types $(1, 2, 3)$.\n- Node $2$ can reach nodes $2, 3, 4$, with two gift types $2, 3$.\n\nConstraints:\n\n| Test point ID | $n$ | $m$ | $c_i$ (color) |\n|:-:|:-:|:-:|:-:|\n| $1$ | $\\le 10^2$ | $\\le 10^2$ | $\\le 10^2$ |\n| $2 \\sim 3$ | $\\le 10^3$ | $\\le 10^3$ | $\\le 10^3$ |\n| $4 \\sim 5$ | $\\le 10^4$ | $\\le 10^4$ | $\\le 20$ |\n| $6$ | $\\le 5 \\times 10^4$ | $\\le 5 \\times 10^4$ | $\\le 5 \\times 10^4$ |\n| $7 \\sim 8$ | $\\le 10^5$ | $\\le 5 \\times 10^4$ | $\\le 6 \\times 10^4$ |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小A的礼物", "background": "** 数据已更新（2018-3-2） **", "description": "小 A 去学校参加活动辣，学校会发礼物哦，学校有很多礼物点。\n\n每一个礼物点都有去别的礼物点的道路和各种种类的礼物。\n\n为了防止多次领礼物，这些道路都是单向的道路，并且没有环。\n\n而且对于每条边连接 $a$，$b$ 点，如果删去这条边之后，存在点 $c$ 可以到达 $a$，也能到达 $b$，那么这条边就不会存在于路径中。\n\n并且除了点 $1$ 之外，所有点有且只有一条入边。\n\n小 A 想知道，对于点 $S$ 能到达的所有点（包括本身），有多少种不同的礼物？", "inputFormat": "第一行是礼物点的数量$n$ ($n \\le 100000$)\n\n接下来 1 行 $n-1$ 个数，分别代表点 $2,\\cdots, n$ 的入点\n\n接下来 1 行 $n$ 个数，代表每个节点的礼物编号\n\n接下来一行是 $m$，代表询问数量\n\n接下来 $m$ 行，每行一个节点编号，代表询问的节点编号\n", "outputFormat": "对于每个询问，输出礼物总数\n", "hint": "### 样例解释\n点 $1$ 可以到达点 $(1, 2, 3, 4)$，有三种礼物 $(1,2,3)$。\n\n点 $2$ 可以到达点 $2, 3, 4$，有两种礼物 $2, 3$。\n\n### 数据范围\n\n\n|测试点编号|$n$|$m$|$c_i$（颜色）|\n|:-:|:-:|:-:|:-:|\n|$1$|$\\le 10^2$|$\\le 10^2$|$\\le 10^2$|\n|$2\\sim3$|$\\le 10^3$|$\\le 10^3$|$\\le 10^3$|\n|$4\\sim5$|$\\le 10^4$|$\\le 10^4$|$\\le 20$|\n|$6$|$\\le5\\times 10^4$|$\\le5\\times 10^4$|$\\le5\\times 10^4$|\n|$7\\sim8$|$\\le 10^5$|$\\le5\\times 10^4$|$\\le6\\times 10^4$|", "locale": "zh-CN"}}}
{"pid": "P2721", "type": "P", "difficulty": 3, "samples": [["3\n0101 100 4.5\n0201 30 5\n0402 50 7.8", "101483.84"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "递推", "线性数据结构"], "title": "小 Q 的赚钱计划", "background": "小 Q（郑重其事地）：今年我一定要赚大钱！！！\n", "description": "小 Q 决定在新的一年里赚大钱，小 P 给 TA 推荐了理财。小 Q 在今年初（非闰年）有 $10^5$ 元（好有钱啊），有 $N$ 个理财产品，每个理财产品用三个参数描述：购买时间，投资天数，年利息率。每个时刻小 Q 只能拥有最多一件产品，求一年后最多可以获得多少钱。\n", "inputFormat": "第 $1$ 行，一个整数 $N$。\n\n接下来 $N$ 行，每行为 $3$ 个空格隔开的字符串 $A, B, C$；\n\n- $A$ 表示发行时间，格式为 MMDD；\n- $B$ 是一个整数，为投资天数，范围 $[10,300]$；\n- $C$ 为最多 $2$ 位小数，代表百分之几的年利息，范围 $[3,30]$；\n", "outputFormat": "一个数，为年底最多可以获得的连本带利的资金数目，保留两位有效小数。\n", "hint": "$0 \\le N \\le 10^4$", "locale": "zh-CN", "translations": {"en": {"title": "Xiao Q's Money-Making Plan", "background": "Xiao Q (solemnly): This year I must make big money!!!", "description": "Xiao Q decides to make big money in the new year, and Xiao P recommends financial products. At the beginning of this (non-leap) year, Xiao Q has $10^5$ yuan. There are $N$ financial products, each described by three parameters: release date, investment days, and annual interest rate. At any moment, Xiao Q can hold at most one product. Find the maximum amount of money attainable after one year.", "inputFormat": "The first line contains an integer $N$.\n\nEach of the next $N$ lines contains three space-separated values $A, B, C$:\n- $A$ denotes the release date, in the format MMDD.\n- $B$ is an integer, the number of investment days, in the range $[10,300]$.\n- $C$ has at most $2$ decimal places, representing the annual interest rate in percent, in the range $[3,30]$.", "outputFormat": "A single number: the maximum total funds (principal plus interest) obtainable at the end of the year, rounded to two decimal places.", "hint": "$0 \\le N \\le 10^4$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "小 Q 的赚钱计划", "background": "小 Q（郑重其事地）：今年我一定要赚大钱！！！\n", "description": "小 Q 决定在新的一年里赚大钱，小 P 给 TA 推荐了理财。小 Q 在今年初（非闰年）有 $10^5$ 元（好有钱啊），有 $N$ 个理财产品，每个理财产品用三个参数描述：购买时间，投资天数，年利息率。每个时刻小 Q 只能拥有最多一件产品，求一年后最多可以获得多少钱。\n", "inputFormat": "第 $1$ 行，一个整数 $N$。\n\n接下来 $N$ 行，每行为 $3$ 个空格隔开的字符串 $A, B, C$；\n\n- $A$ 表示发行时间，格式为 MMDD；\n- $B$ 是一个整数，为投资天数，范围 $[10,300]$；\n- $C$ 为最多 $2$ 位小数，代表百分之几的年利息，范围 $[3,30]$；\n", "outputFormat": "一个数，为年底最多可以获得的连本带利的资金数目，保留两位有效小数。\n", "hint": "$0 \\le N \\le 10^4$", "locale": "zh-CN"}}}
{"pid": "P2722", "type": "P", "difficulty": 2, "samples": [["300 4\n100 60\n250 120\n120 100\n35 20", "605"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "USACO", "背包 DP"], "title": "[USACO3.1] 总分 Score Inflation", "background": "选手在我们 USACO 的竞赛中的得分越多我们越高兴。\n\n我们试着设计我们的竞赛以便人们能尽可能的多得分，这需要你的帮助。", "description": "我们可以从几个种类中选取竞赛的题目，这里的一个“种类”是指一个竞赛题目的集合，解决集合中的题目需要相同多的时间并且能得到相同的分数。\n\n你的任务是写一个程序来告诉 USACO 的职员，应该从每一个种类中选取多少题目，使得解决题目的总耗时在竞赛规定的时间里并且总分最大。", "inputFormat": "输入的第一行是用空格隔开的两个整数，分别代表竞赛时间 $m$ 和题目类 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行两个用空格隔开的整数，第 $(i + 1)$ 行的整数 $p_i, t_i$ 分别代表解决第 $i$ 类题得到的分数和需要花费的时间。\n\n既然是某一类题目，那么这一类题目可以重复选择。", "outputFormat": "输出一行一个整数，代表最大的总分。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n, m \\leq 10^4$，$1 \\leq p_i, t_i \\leq 10^4$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO3.1] Score Inflation", "background": "The more points contestants score in our USACO contests, the happier we are. We try to design our contests so that people can score as many points as possible, and we need your help.", "description": "We can choose contest problems from several categories. Here, a \"category\" refers to a set of problems such that solving any problem in the set takes the same amount of time and yields the same score.\n\nYour task is to write a program to tell the USACO staff how many problems to select from each category so that the total time spent solving problems is within the contest time limit and the total score is maximized.", "inputFormat": "The first line contains two integers separated by a space, representing the contest duration $m$ and the number of categories $n$.\n\nLines $2$ through $(n + 1)$ each contain two integers separated by a space. On line $(i + 1)$, the integers $p_i, t_i$ denote the score awarded for a problem in category $i$ and the time required to solve it.\n\nSince problems are grouped by category, you may select problems from the same category repeatedly.", "outputFormat": "Output a single integer, the maximum total score.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\leq n, m \\leq 10^4$, and $1 \\leq p_i, t_i \\leq 10^4$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO3.1] 总分 Score Inflation", "background": "选手在我们 USACO 的竞赛中的得分越多我们越高兴。\n\n我们试着设计我们的竞赛以便人们能尽可能的多得分，这需要你的帮助。", "description": "我们可以从几个种类中选取竞赛的题目，这里的一个“种类”是指一个竞赛题目的集合，解决集合中的题目需要相同多的时间并且能得到相同的分数。\n\n你的任务是写一个程序来告诉 USACO 的职员，应该从每一个种类中选取多少题目，使得解决题目的总耗时在竞赛规定的时间里并且总分最大。", "inputFormat": "输入的第一行是用空格隔开的两个整数，分别代表竞赛时间 $m$ 和题目类 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行两个用空格隔开的整数，第 $(i + 1)$ 行的整数 $p_i, t_i$ 分别代表解决第 $i$ 类题得到的分数和需要花费的时间。\n\n既然是某一类题目，那么这一类题目可以重复选择。", "outputFormat": "输出一行一个整数，代表最大的总分。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n, m \\leq 10^4$，$1 \\leq p_i, t_i \\leq 10^4$。", "locale": "zh-CN"}}}
{"pid": "P2723", "type": "P", "difficulty": 4, "samples": [["4 19\n2 3 5 7", "27"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "数学", "USACO", "平衡树", "堆", "枚举", "排序"], "title": "[USACO3.1] 丑数 Humble Numbers", "background": "", "description": "对于一给定的素数集合 $S = \\{ p_1, p_2, ..., p_k \\}$, 考虑一个正整数集合，该集合中任一元素的质因数全部属于 $S$。这个正整数集合包括，$p_1$、$p_1 \\times p_2$、$p_1 \\times p_1$、$p_1 \\times p_2 \\times p_3$ ...(还有其它)。该集合被称为 $S$ 集合的“丑数集合”。注意：我们认为 $1$不是一个丑数。\n\n你的工作是对于输入的集合 $S$ 去寻找“丑数集合”中的第 $n$ 个“丑数”。保证答案可以用 32 位有符号整数表示。\n\n补充：丑数集合中每个数从小到大排列，每个丑数都是素数集合中的数的乘积，第 $n$ 个“丑数”就是在能由素数集合中的数相乘得来的（包括它本身）第 $n$ 小的数。\n", "inputFormat": "输入的第一行是两个的整数，分别代表集合 $S$ 的大小 $k$ 和给定的参数 $n$。\n\n输入的第二行有 $k$ 互不相同的整数，第 $i$ 个整数代表 $p_i$。", "outputFormat": "输出一行一个整数，代表答案。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n\n- $1 \\leq k \\leq 100$。\n- $1 \\leq n \\leq 10^5$。\n- $2 \\leq p_i < 2^{31}$，且 $p_i$ 一定为质数。\n\n---\n#### 说明\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 3.1\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO3.1] Humble Numbers", "background": "", "description": "Given a set of primes $S = \\{ p_1, p_2, ..., p_k \\}$, consider the set of positive integers whose prime factors all belong to $S$. This set includes $p_1$, $p_1 \\times p_2$, $p_1 \\times p_1$, $p_1 \\times p_2 \\times p_3$ ... (and others). This set is called the \"humble numbers set\" of $S$. Note: We consider $1$ not to be a humble number.\n\nYour task is, given the set $S$, to find the $n$-th humble number in the humble numbers set. It is guaranteed that the answer fits in a 32-bit signed integer.\n\nSupplement: The humble numbers are ordered from small to large. Each humble number is a product of numbers from the prime set. The $n$-th humble number is the $n$-th smallest positive integer that can be formed by multiplying numbers from the prime set (including a prime itself).", "inputFormat": "- The first line contains two integers, which are the size $k$ of the set $S$ and the given parameter $n$.\n- The second line contains $k$ distinct integers, where the $i$-th integer denotes $p_i$.", "outputFormat": "Output a single integer, the answer.", "hint": "- Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that:\n- $1 \\leq k \\leq 100$.\n- $1 \\leq n \\leq 10^5$.\n- $2 \\leq p_i < 2^{31}$, and each $p_i$ is prime.\n\n- Notes\n\nProblem translation from NOCOW.\n\nUSACO Training Section 3.1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO3.1] 丑数 Humble Numbers", "background": "", "description": "对于一给定的素数集合 $S = \\{ p_1, p_2, ..., p_k \\}$, 考虑一个正整数集合，该集合中任一元素的质因数全部属于 $S$。这个正整数集合包括，$p_1$、$p_1 \\times p_2$、$p_1 \\times p_1$、$p_1 \\times p_2 \\times p_3$ ...(还有其它)。该集合被称为 $S$ 集合的“丑数集合”。注意：我们认为 $1$不是一个丑数。\n\n你的工作是对于输入的集合 $S$ 去寻找“丑数集合”中的第 $n$ 个“丑数”。保证答案可以用 32 位有符号整数表示。\n\n补充：丑数集合中每个数从小到大排列，每个丑数都是素数集合中的数的乘积，第 $n$ 个“丑数”就是在能由素数集合中的数相乘得来的（包括它本身）第 $n$ 小的数。\n", "inputFormat": "输入的第一行是两个的整数，分别代表集合 $S$ 的大小 $k$ 和给定的参数 $n$。\n\n输入的第二行有 $k$ 互不相同的整数，第 $i$ 个整数代表 $p_i$。", "outputFormat": "输出一行一个整数，代表答案。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n\n- $1 \\leq k \\leq 100$。\n- $1 \\leq n \\leq 10^5$。\n- $2 \\leq p_i < 2^{31}$，且 $p_i$ 一定为质数。\n\n---\n#### 说明\n\n题目翻译来自 NOCOW。\n\nUSACO Training Section 3.1\n", "locale": "zh-CN"}}}
{"pid": "P2724", "type": "P", "difficulty": 3, "samples": [["2 4 10\n01010010010001000111101100001010011001111000010010011110010000000", "23\n00\n15\n01 10\n12\n100\n11\n11 000 001\n10\n010\n8\n0100\n7\n0010 1001\n6\n111 0000\n5\n011 110 1000\n4\n0001 0011 1100"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["1998", "USACO", "IOI", "枚举", "排序"], "title": "[IOI 1998 / USACO3.1] 联系 Contact", "background": "奶牛们开始对使用射电望远镜扫描外太空产生了兴趣。最近，她们注意到一个来自银河系中心的、非常奇怪的脉冲调制微波信号。她们想知道这些无线电波是否由某种地外生命发出，或者仅仅是普通恒星发射的。", "description": "请帮助奶牛们，编写一个工具来分析她们记录在文件中的数据，以找出真相。她们正在寻找在数据文件中出现次数最多的前 $n$ 个，且长度在 $A$ 到 $B$ 之间（包含 $A$ 和 $B$）的比特序列。\n\n出现的位置可以重叠，每个至少出现一次的序列都应该被计数。", "inputFormat": "第一行，包含三个整数 $A, B, n$，如题目描述。\n\n从第二行开始的若干行，描述字符串 $s$，每行最多 $80$ 个字符（按顺序连接所有行即为完整的字符串）。", "outputFormat": "输出出现频率最高的 $n$ 个序列（按频率从高到低排序）。\n\n对于频率相同的序列，按长度从短到长排序；如果长度也相同，则按二进制数值升序排序。如果不同序列的数量少于 $n$，则输出所有存在的序列。\n\n对于出现的每个频率，首先输出一行，仅包含该频率值，然后输出具有该频率的序列，用空格分隔。每行打印六个序列（除非剩下的不足六个）。", "hint": "#### 样例 1 解释\n\n在样例中，序列 $100$ 出现了 $12$ 次，而序列 $1000$ 出现了 $5$ 次。出现最频繁的序列是 $00$，出现了 $23$ 次。\n\n---\n\n#### 数据规模与约定\n\n对于 $100%$ 的测试数据，保证 $1 \\leq n \\leq 50$，$1 \\leq A \\leq B \\leq 12$，$s$ 只包含字符 `0` 和 `1`，且 $s$ 的长度不超过 $2 \\times 10^5$", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1998 / USACO3.1] Contact", "background": "The cows have become interested in scanning outer space with a radio telescope. Recently, they noticed a very strange pulse-modulated microwave signal coming from the center of the galaxy. They want to know whether the radio waves were sent by some extraterrestrial life, or are merely emitted by ordinary stars.", "description": "Help the cows by writing a tool that analyzes the records they wrote down in a file to find the truth. They are looking for the bit sequences of lengths between $A$ and $B$ (inclusive) that occur the top $n$ most times in the data file.\n\nOccurrences may overlap, and every sequence that appears at least once should be counted.", "inputFormat": "The first line contains three integers $A, B, n$, as defined in the description.\n\nFrom the second line on is the string $s$, with at most $80$ characters per line. Concatenate all lines in order to obtain $s$.", "outputFormat": "Output the $n$ most frequent sequences (in order from highest to lowest frequency). For sequences with the same frequency, order them by length from short to long; if the lengths are the same, order by binary value (ascending). If the number of distinct sequences is less than $n$, output all that exist.\n\nFor each frequency that occurs, first output a line containing only that frequency, then output the sequences with that frequency, separated by spaces. Print six sequences per line (unless fewer remain).", "hint": "#### Explanation for Sample 1\n\nIn the sample, the sequence $100$ appears $12$ times, while the sequence $1000$ appears $5$ times. The most frequent sequence is $00$, which appears $23$ times.\n\n---\n\n#### Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 50$, $1 \\leq A \\leq B \\leq 12$, $s$ contains only the characters `0` and `1`, and the length of $s$ is at most $2 \\times 10^5$.\n\n---\n\nThe problem translation is from NOCOW.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1998 / USACO3.1] 联系 Contact", "background": "奶牛们开始对使用射电望远镜扫描外太空产生了兴趣。最近，她们注意到一个来自银河系中心的、非常奇怪的脉冲调制微波信号。她们想知道这些无线电波是否由某种地外生命发出，或者仅仅是普通恒星发射的。", "description": "请帮助奶牛们，编写一个工具来分析她们记录在文件中的数据，以找出真相。她们正在寻找在数据文件中出现次数最多的前 $n$ 个，且长度在 $A$ 到 $B$ 之间（包含 $A$ 和 $B$）的比特序列。\n\n出现的位置可以重叠，每个至少出现一次的序列都应该被计数。", "inputFormat": "第一行，包含三个整数 $A, B, n$，如题目描述。\n\n从第二行开始的若干行，描述字符串 $s$，每行最多 $80$ 个字符（按顺序连接所有行即为完整的字符串）。", "outputFormat": "输出出现频率最高的 $n$ 个序列（按频率从高到低排序）。\n\n对于频率相同的序列，按长度从短到长排序；如果长度也相同，则按二进制数值升序排序。如果不同序列的数量少于 $n$，则输出所有存在的序列。\n\n对于出现的每个频率，首先输出一行，仅包含该频率值，然后输出具有该频率的序列，用空格分隔。每行打印六个序列（除非剩下的不足六个）。", "hint": "#### 样例 1 解释\n\n在样例中，序列 $100$ 出现了 $12$ 次，而序列 $1000$ 出现了 $5$ 次。出现最频繁的序列是 $00$，出现了 $23$ 次。\n\n---\n\n#### 数据规模与约定\n\n对于 $100%$ 的测试数据，保证 $1 \\leq n \\leq 50$，$1 \\leq A \\leq B \\leq 12$，$s$ 只包含字符 `0` 和 `1`，且 $s$ 的长度不超过 $2 \\times 10^5$", "locale": "zh-CN"}}}
{"pid": "P2725", "type": "P", "difficulty": 3, "samples": [["5 2\n1 3", "13"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "动态规划 DP", "搜索", "贪心", "USACO", "背包 DP"], "title": "[USACO3.1] 邮票 Stamps", "background": "", "description": "给一组 $n$ 枚邮票的面值集合和一个上限 $k$ —— 表示信封上能够贴 $k$ 张邮票。请求出最大的正整数 $m$，满足 $1$ 到 $m$ 的面值都可以用不超过 $k$ 张邮票表示出来。\n\n", "inputFormat": "输入的第一行是两个整数，分别代表邮票上限 $k$ 和邮票面值数 $n$。\n\n自第二行起，除最后一行外，每行有 $15$ 个整数 $a_i$ ，最后一行的整数个数不超过 $15$，共有 $n$ 个整数，第 $i$ 个整数代表第 $i$ 种邮票的面值 $a_i$。", "outputFormat": "输出一行一个整数代表 $m$。若 $m$ 不存在请输出 $0$。", "hint": "#### 样例输入输出 1 解释\n\n有 $1$ 分和 $3$ 分的邮票；你最多可以贴 $5$ 张邮票。很容易贴出 $1$ 到 $5$ 分的邮资（用 $1$ 分邮票贴就行了），接下来的邮资也不难：\n\n\n- $6 = 3 + 3$。\n- $7 = 3 + 3 + 1$。\n- $8 = 3 + 3 + 1 + 1 $。\n- $9 = 3 + 3 + 3 $。\n- $10 = 3 + 3 + 3 + 1 $。\n- $11 = 3 + 3 + 3 + 1 + 1 $。\n- $12 = 3 + 3 + 3 + 3 $。\n- $13 = 3 + 3 + 3 + 3 + 1$。\n\n\n然而，使用 $5$ 枚 $1$ 分或者 $3$ 分的邮票根本不可能贴出 $14$ 分的邮资。因此，答案为 $13$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq k \\leq 200$，$1 \\leq n \\leq 50$，$1 \\leq a_i \\leq 10^4$。\n\n#### 说明\n\n题目翻译来自 NOCOW。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO3.1] Stamps", "background": "", "description": "Given a set of $n$ stamp denominations and an upper bound $k$ — meaning you may affix at most $k$ stamps to an envelope — find the largest positive integer $m$ such that every value from $1$ to $m$ can be represented using no more than $k$ stamps.", "inputFormat": "The first line contains two integers, the stamp limit $k$ and the number of denominations $n$.\n\nStarting from the second line, except for the last line, each line contains $15$ integers $a_i$. The last line contains at most $15$ integers. In total there are $n$ integers; the $i$-th integer is the value $a_i$ of the $i$-th type of stamp.", "outputFormat": "Output one line with a single integer $m$. If $m$ does not exist, output $0$.", "hint": "Sample Input/Output 1 Explanation\n\nThere are denominations $1$ and $3$; you may use at most $5$ stamps. It is easy to form values $1$ through $5$ (just use the $1$-value stamps). The following values are also easy:\n\n- $6 = 3 + 3$.\n- $7 = 3 + 3 + 1$.\n- $8 = 3 + 3 + 1 + 1$.\n- $9 = 3 + 3 + 3$.\n- $10 = 3 + 3 + 3 + 1$.\n- $11 = 3 + 3 + 3 + 1 + 1$.\n- $12 = 3 + 3 + 3 + 3$.\n- $13 = 3 + 3 + 3 + 3 + 1$.\n\nHowever, using $5$ stamps of values $1$ or $3$, it is impossible to form $14$. Therefore, the answer is $13$.\n\nConstraints\n\n- For $100\\%$ of the testdata, $1 \\leq k \\leq 200$, $1 \\leq n \\leq 50$, $1 \\leq a_i \\leq 10^4$.\n\nNote\n\n- The statement is translated from NOCOW.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO3.1] 邮票 Stamps", "background": "", "description": "给一组 $n$ 枚邮票的面值集合和一个上限 $k$ —— 表示信封上能够贴 $k$ 张邮票。请求出最大的正整数 $m$，满足 $1$ 到 $m$ 的面值都可以用不超过 $k$ 张邮票表示出来。\n\n", "inputFormat": "输入的第一行是两个整数，分别代表邮票上限 $k$ 和邮票面值数 $n$。\n\n自第二行起，除最后一行外，每行有 $15$ 个整数 $a_i$ ，最后一行的整数个数不超过 $15$，共有 $n$ 个整数，第 $i$ 个整数代表第 $i$ 种邮票的面值 $a_i$。", "outputFormat": "输出一行一个整数代表 $m$。若 $m$ 不存在请输出 $0$。", "hint": "#### 样例输入输出 1 解释\n\n有 $1$ 分和 $3$ 分的邮票；你最多可以贴 $5$ 张邮票。很容易贴出 $1$ 到 $5$ 分的邮资（用 $1$ 分邮票贴就行了），接下来的邮资也不难：\n\n\n- $6 = 3 + 3$。\n- $7 = 3 + 3 + 1$。\n- $8 = 3 + 3 + 1 + 1 $。\n- $9 = 3 + 3 + 3 $。\n- $10 = 3 + 3 + 3 + 1 $。\n- $11 = 3 + 3 + 3 + 1 + 1 $。\n- $12 = 3 + 3 + 3 + 3 $。\n- $13 = 3 + 3 + 3 + 3 + 1$。\n\n\n然而，使用 $5$ 枚 $1$ 分或者 $3$ 分的邮票根本不可能贴出 $14$ 分的邮资。因此，答案为 $13$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq k \\leq 200$，$1 \\leq n \\leq 50$，$1 \\leq a_i \\leq 10^4$。\n\n#### 说明\n\n题目翻译来自 NOCOW。", "locale": "zh-CN"}}}
{"pid": "P2726", "type": "P", "difficulty": 6, "samples": [["5\n1 2\n1 3\n3 4\n3 5\n5\n7\n6\n5\n4", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2005", "各省省选", "上海", "树形 DP", "树的重心"], "title": "[SHOI2005] 树的双中心", "background": null, "description": "给定一棵树 $T=(V,E)$，其中 $V$ 为节点集合，$E$ 为边集合。\n\n对于 $V$ 中的每个节点 $v$，有一个权值函数 $W(v)$，该函数的值均为正整数。\n\n记 $d(u,v)$ 为节点 $u$ 和 $v$ 之间的距离，表示它们之间唯一的一条路径的边数。若 $u$ 和 $v$ 为同一个节点，则 $d(u,v)=0$。\n\n你的任务是找出两个不同的节点 $x$ 和 $y$，使得以下表达式 $S(x,y)$ 的值最小\n\n$$S(x,y)=\\sum_{v\\in V} (W(v)\\cdot \\min\\{ d(v,x),d(v,y)\\})", "inputFormat": "第一行为 $N\\;(1<N\\le5\\times 10^4)$，表示树的节点数目，树的节点从 $1$ 到 $N$ 编号。\n\n接下来 $N-1$ 行，每行两个整数 $U,V$，表示 $U$ 与 $V$ 之间有一条边。\n\n再接下 $N$ 行，每行一个正整数，其中第i行的正整数表示编号为 $i$ 的节点权值为 $W(i)$。\n\n保证树的深度不超过 $100$。", "outputFormat": "将最小的 $S(x,y)$ 输出，结果保证不超过 $10^9$", "hint": "样例中，选取的两个中心节点分别为 $2$ 和 $3$。", "locale": "zh-CN", "translations": {"en": {"title": "[SHOI2005] Double Center of a Tree", "background": "", "description": "Given a tree $T=(V,E)$, where $V$ is the set of nodes and $E$ is the set of edges.\n\nFor each node $v \\in V$, there is a weight function $W(v)$ whose values are positive integers.\n\nLet $d(u,v)$ be the distance between nodes $u$ and $v$, meaning the number of edges on the unique path between them. If $u$ and $v$ are the same node, then $d(u,v)=0$.\n\nYour task is to find two distinct nodes $x$ and $y$ that minimize the following expression:\n$$\nS(x,y)=\\sum_{v\\in V} (W(v)\\cdot \\min\\{ d(v,x),d(v,y)\\})\n$$", "inputFormat": "- The first line contains $N$ ($1 < N \\le 5\\times 10^4$), the number of nodes in the tree. The nodes are numbered from $1$ to $N$.\n- The next $N-1$ lines each contain two integers $U, V$, indicating there is an edge between $U$ and $V$.\n- Then $N$ more lines follow. Each line contains a positive integer; on the $i$-th of these lines, the integer gives the weight $W(i)$ of node $i$.\n- It is guaranteed that the depth of the tree does not exceed $100$.", "outputFormat": "Output the minimal value of $S(x,y)$. The result is guaranteed not to exceed $10^9$.", "hint": "In the sample, the two chosen centers are nodes $2$ and $3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SHOI2005] 树的双中心", "background": null, "description": "给定一棵树 $T=(V,E)$，其中 $V$ 为节点集合，$E$ 为边集合。\n\n对于 $V$ 中的每个节点 $v$，有一个权值函数 $W(v)$，该函数的值均为正整数。\n\n记 $d(u,v)$ 为节点 $u$ 和 $v$ 之间的距离，表示它们之间唯一的一条路径的边数。若 $u$ 和 $v$ 为同一个节点，则 $d(u,v)=0$。\n\n你的任务是找出两个不同的节点 $x$ 和 $y$，使得以下表达式 $S(x,y)$ 的值最小\n\n$$S(x,y)=\\sum_{v\\in V} (W(v)\\cdot \\min\\{ d(v,x),d(v,y)\\})", "inputFormat": "第一行为 $N\\;(1<N\\le5\\times 10^4)$，表示树的节点数目，树的节点从 $1$ 到 $N$ 编号。\n\n接下来 $N-1$ 行，每行两个整数 $U,V$，表示 $U$ 与 $V$ 之间有一条边。\n\n再接下 $N$ 行，每行一个正整数，其中第i行的正整数表示编号为 $i$ 的节点权值为 $W(i)$。\n\n保证树的深度不超过 $100$。", "outputFormat": "将最小的 $S(x,y)$ 输出，结果保证不超过 $10^9$", "hint": "样例中，选取的两个中心节点分别为 $2$ 和 $3$。", "locale": "zh-CN"}}}
{"pid": "P2727", "type": "P", "difficulty": 5, "samples": [["5 3 19", "10011"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "数学", "二分", "USACO", "数位 DP"], "title": "[USACO3.2] 01串 Stringsobits", "background": "考虑排好序的 $N$（$1 \\leq N \\leq 31$）位二进制数。\n", "description": "他们是排列好的，而且包含所有长度为 $N$ 且这个二进制数中 $1$ 的位数的个数小于等于 $L$（$L \\leq N$）的数。\n\n你的任务是输出满足长度为 $N$，且 $1$ 的个数小于等于 $L$ 的第 $i$ 小的那个二进制数（保证这个数存在）。\n\n例：$100101$ 中，$N=6$，含有 $1$ 的个数为 $3$。", "inputFormat": "一行三个整数 $N,L,i$。", "outputFormat": "输出满足条件的第 $i$ 小的二进制数。\n", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 3.2\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO3.2] 01 String Stringsobits", "background": "Consider sorted $N$-bit binary numbers ($1 \\leq N \\leq 31$).", "description": "They are sorted and include all $N$-bit binary numbers whose number of $1$s is at most $L$ ($L \\leq N$).\n\nYour task is to output the $i$-th smallest $N$-bit binary number that has at most $L$ ones (it is guaranteed to exist).\n\nExample: In $100101$, $N = 6$, and it contains $3$ ones.", "inputFormat": "One line with three integers $N, L, i$.", "outputFormat": "Output the $i$-th smallest binary number that satisfies the conditions.", "hint": "Problem translation from NOCOW.\n\nUSACO Training Section 3.2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO3.2] 01串 Stringsobits", "background": "考虑排好序的 $N$（$1 \\leq N \\leq 31$）位二进制数。\n", "description": "他们是排列好的，而且包含所有长度为 $N$ 且这个二进制数中 $1$ 的位数的个数小于等于 $L$（$L \\leq N$）的数。\n\n你的任务是输出满足长度为 $N$，且 $1$ 的个数小于等于 $L$ 的第 $i$ 小的那个二进制数（保证这个数存在）。\n\n例：$100101$ 中，$N=6$，含有 $1$ 的个数为 $3$。", "inputFormat": "一行三个整数 $N,L,i$。", "outputFormat": "输出满足条件的第 $i$ 小的二进制数。\n", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 3.2\n", "locale": "zh-CN"}}}
{"pid": "P2728", "type": "P", "difficulty": 3, "samples": [["30 1 0 120\n50 1 150 90\n60 1 60 90\n70 1 180 180\n90 1 180 60", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "图论", "USACO"], "title": "[USACO3.2] 纺车的轮子 Spinning Wheels", "background": "一架纺车有五个纺轮（也就是五个同心圆），这五个不透明的轮子边缘上都有一些缺口。这些缺口必须被迅速而准确地排列好。每个轮子都有一个起始标记（在 $0$ 度），这样所有的轮子都可以在统一的已知位置开始转动。轮子按照角度变大的方向旋转（即 $0$ 经过旋转到达 $1$ 的位置），所以从起始位置开始，在一定的时间内，它们依次转过 $1$ 度，$2$ 度等等（虽然这些轮子很可能不会同时转过这些角度）。", "description": "这是一个整数问题。轮子不会转过 $1.5$ 度或 $23.51234123$ 度这样的角度。例如，轮子可能在一秒钟内转过 $20$ 到 $25$ 度甚至 $30$ 到 $40$ 度（如果转得快的话）。\n\n这个问题中的所有角度 $\\theta$ 都限制在 $0 \\le \\theta \\le 359$ 度的范围内。轮子转过 $359$ 度后接下来就是 $0$ 度。每个轮子都有一个确定的旋转速度 $\\omega$，以秒作为单位。$1\\le \\omega\\le 180$。\n\n轮子上的缺口的起始角度和缺口大小（或宽度）各由一个整数表示，都以度为单位。在一个轮子上，两个缺口之间至少有一度的间隔。宽度也包含缺口起始和终止的角度，**即 `0 179` 包括 $[0,179]$ 共计 $180$ 个角度**。\n\n在起始位置，设时间为 $0$，所有的轮子的起始标记排列成一条直线。你的程序必须计算，最早出现每个的轮子上的缺口同其他轮子上的缺口对准（也就是一束光可以通过五个轮子上的五个缺口）情况的时间。这些缺口在任意一个角度对准。", "inputFormat": "输入中的五行对应五个轮子。\n\n第一个数字表示轮子的转动速度 $\\omega$。下一个数字是缺口的数目 $n$。$1 \\le n \\le 5$。接下来的 $n$ 对数字 $(\\theta_i,\\varphi_i)$ 表示每个缺口的起始角度和宽度。", "outputFormat": "只有一行，包括一个整数，表示光能够通过这五个轮子的最早时间。如果无解，输出 `none`。", "hint": "样例解释：\n\n$9$ 秒后，五个缺口分别处于 $[270^\\circ,30^\\circ],[240^\\circ,330^\\circ],[240^\\circ,330^\\circ],[90^\\circ,270^\\circ],[270^\\circ,330^\\circ]$，因此光能够从 $270^\\circ$ 方向打进来。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 3.2。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO3.2] Spinning Wheels", "background": "A spinning wheel has five disks (i.e., five concentric circles), each opaque and with several slots on the rim. These slots must be aligned quickly and precisely. Each wheel has a starting mark at $0$ degrees so that all wheels can start from a common, known position. The wheels rotate in the direction of increasing angles (i.e., the $0$ position moves to where $1$ is), so starting from the initial position, over time they advance by $1$ degree, $2$ degrees, and so on (although they may not advance the same amount at the same time).", "description": "This is an integer problem. The wheels do not rotate by non-integer angles like $1.5$ degrees or $23.51234123$ degrees. For example, a wheel might rotate at $20$ degrees per second, or even $30$–$40$ degrees per second if it is fast.\n\nAll angles $\\theta$ in this problem are restricted to $0 \\le \\theta \\le 359$ degrees. After a wheel rotates through $359$ degrees, the next degree is $0$. Each wheel has a fixed rotational speed $\\omega$ in seconds, with $1\\le \\omega\\le 180$.\n\nThe starting angle of each slot and the slot size (or width) are both integers, measured in degrees. On a single wheel, there is at least one degree between any two slots. The width includes both the starting and ending angles of the slot, i.e., `0 179` covers $[0,179]$, totaling $180$ angles.\n\nAt the starting position (time $0$), all the starting marks on the wheels are aligned along a straight line. Your program must compute the earliest time when a slot on each wheel aligns with slots on all the other wheels (i.e., a beam of light can pass through five slots, one on each of the five wheels), at any angle.", "inputFormat": "There are five lines in the input, one per wheel.\n\nThe first number is the wheel’s rotational speed $\\omega$. The next number is the number of slots $n$, where $1 \\le n \\le 5$. The following $n$ pairs $(\\theta_i,\\varphi_i)$ give the starting angle and width of each slot.", "outputFormat": "Output a single line with one integer, the earliest time when light can pass through all five wheels. If there is no solution, output `none`.", "hint": "Sample explanation:\n\nAfter $9$ seconds, the five sets of slots are $[270^\\circ,30^\\circ]$, $[240^\\circ,330^\\circ]$, $[240^\\circ,330^\\circ]$, $[90^\\circ,270^\\circ]$, $[270^\\circ,330^\\circ]$, so a beam can enter from $270^\\circ$.\n\nTranslation from NOCOW.\n\nUSACO Training Section 3.2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO3.2] 纺车的轮子 Spinning Wheels", "background": "一架纺车有五个纺轮（也就是五个同心圆），这五个不透明的轮子边缘上都有一些缺口。这些缺口必须被迅速而准确地排列好。每个轮子都有一个起始标记（在 $0$ 度），这样所有的轮子都可以在统一的已知位置开始转动。轮子按照角度变大的方向旋转（即 $0$ 经过旋转到达 $1$ 的位置），所以从起始位置开始，在一定的时间内，它们依次转过 $1$ 度，$2$ 度等等（虽然这些轮子很可能不会同时转过这些角度）。", "description": "这是一个整数问题。轮子不会转过 $1.5$ 度或 $23.51234123$ 度这样的角度。例如，轮子可能在一秒钟内转过 $20$ 到 $25$ 度甚至 $30$ 到 $40$ 度（如果转得快的话）。\n\n这个问题中的所有角度 $\\theta$ 都限制在 $0 \\le \\theta \\le 359$ 度的范围内。轮子转过 $359$ 度后接下来就是 $0$ 度。每个轮子都有一个确定的旋转速度 $\\omega$，以秒作为单位。$1\\le \\omega\\le 180$。\n\n轮子上的缺口的起始角度和缺口大小（或宽度）各由一个整数表示，都以度为单位。在一个轮子上，两个缺口之间至少有一度的间隔。宽度也包含缺口起始和终止的角度，**即 `0 179` 包括 $[0,179]$ 共计 $180$ 个角度**。\n\n在起始位置，设时间为 $0$，所有的轮子的起始标记排列成一条直线。你的程序必须计算，最早出现每个的轮子上的缺口同其他轮子上的缺口对准（也就是一束光可以通过五个轮子上的五个缺口）情况的时间。这些缺口在任意一个角度对准。", "inputFormat": "输入中的五行对应五个轮子。\n\n第一个数字表示轮子的转动速度 $\\omega$。下一个数字是缺口的数目 $n$。$1 \\le n \\le 5$。接下来的 $n$ 对数字 $(\\theta_i,\\varphi_i)$ 表示每个缺口的起始角度和宽度。", "outputFormat": "只有一行，包括一个整数，表示光能够通过这五个轮子的最早时间。如果无解，输出 `none`。", "hint": "样例解释：\n\n$9$ 秒后，五个缺口分别处于 $[270^\\circ,30^\\circ],[240^\\circ,330^\\circ],[240^\\circ,330^\\circ],[90^\\circ,270^\\circ],[270^\\circ,330^\\circ]$，因此光能够从 $270^\\circ$ 方向打进来。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 3.2。", "locale": "zh-CN"}}}
{"pid": "P2729", "type": "P", "difficulty": 3, "samples": [["3 4 5\n1 2 3\n3 7 1\n2 1 2 ", "8 1 5 7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "数学", "USACO", "枚举", "剪枝"], "title": "[USACO3.2] 饲料调配 Feed Ratios", "background": "农夫约翰从来只用调配得最好的饲料来喂他的奶牛。饲料用三种原料调配成：大麦，燕麦和小麦。他知道自己的饲料精确的配比，在市场上是买不到这样的饲料的。他只好购买其他三种混合饲料（同样都由三种麦子组成），然后将它们混合，来调配他的完美饲料。", "description": "给出三组整数，每组整数表示一种饲料中大麦、燕麦与小麦的比例，找出用这三种饲料调配 $x:y:z$ 的饲料的方法。\n\n请编写一个程序找出使这三种饲料用量最少的方案，要是不能用这三种饲料调配目标饲料，输出一行一个字符串 `NONE`。“用量最少”意味着三种饲料的用量（整数）的和必须最小。\n\n例如，要求使用 $1:2:3$、$3:7:1$、$2:1:2$ 的饲料调配 $3:4:5$ 的饲料，我们可以通过 $8$ 份第一种饲料、$1$ 份第二种饲料和 $5$ 份第三种饲料调配 $7$ 份目标饲料。这是因为 $8 \\times 1 + 1 \\times 3 + 5 \\times 2 = 21$，$8 \\times 2 + 1 \\times 7 + 5 \\times 1 = 28$，$8 \\times 3 + 1 \\times 1 + 5 \\times 2 = 35$，而 $21:28:35$ 恰好等于 $3:4:5$。", "inputFormat": "第一行，三个整数 $x,y,z$，表示目标饲料中大麦、燕麦与小麦的比为 $x:y:z$。\n\n接下来三行，第 $i$ 行三个整数 $a_i,b_i,c_i$，表示第 $i$ 种饲料中大麦、燕麦与小麦的比为 $a_i:b_i:c_i$。\n\n数据保证输入的所有整数在 $0 \\sim 99$ 之间，且每一行的三个整数不会同为 $0$。", "outputFormat": "如果能够用这三种饲料调配出目标饲料，则输出一行 $4$ 个整数，前三个整数 $m,n,p$ 分别代表三种饲料的份数，第四个整数代表得到目标饲料的份数。如果有多解，输出 $m+n+p$ 最小的一组。如果不能用这三种饲料调配出目标饲料，输出一行一个字符串 `NONE`。数据保证如果有解， $m+n+p$ 最小的解只有一组。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 3.2", "locale": "zh-CN", "translations": {"en": {"title": "[USACO3.2] Feed Ratios", "background": "Farmer John always feeds his cows with the best-mixed feed. The feed is blended from three ingredients: barley, oats, and wheat. He knows the exact ratio of his ideal feed, but such a feed is not available on the market. He has to purchase three other mixed feeds (each also composed of the same three grains) and blend them to produce his perfect feed.", "description": "Given three sets of integers, each set represents the ratio of barley, oats, and wheat in one feed. Find a way to blend these three feeds to obtain a feed with ratio $x:y:z$.\n\nWrite a program to find the solution that minimizes the total amount of the three feeds used. If it is impossible to obtain the target feed from these three feeds, output a single line containing the string `NONE`. “Minimum amount” means the sum of the amounts (integers) of the three feeds must be minimized.\n\nFor example, if we want to use feeds with ratios $1:2:3$, $3:7:1$, and $2:1:2$ to produce a feed with ratio $3:4:5$, we can blend $8$ units of the first feed, $1$ unit of the second feed, and $5$ units of the third feed to obtain $7$ units of the target feed. This is because $8 \\times 1 + 1 \\times 3 + 5 \\times 2 = 21$, $8 \\times 2 + 1 \\times 7 + 5 \\times 1 = 28$, $8 \\times 3 + 1 \\times 1 + 5 \\times 2 = 35$, and $21:28:35$ is exactly equal to $3:4:5$.", "inputFormat": "The first line contains three integers $x, y, z$, indicating that the target feed has barley, oats, and wheat in the ratio $x:y:z$.\n\nThe next three lines, the $i$-th line contains three integers $a_i, b_i, c_i$, indicating that the $i$-th feed has barley, oats, and wheat in the ratio $a_i:b_i:c_i$.\n\nAll integers in the input are between $0$ and $99$ inclusive, and in each line the three integers are not all $0$.", "outputFormat": "If the target feed can be obtained by blending the three feeds, output one line with $4$ integers. The first three integers $m, n, p$ represent the portions of the three feeds, and the fourth integer represents the number of portions of the target feed obtained. If there are multiple solutions, output the one with the smallest $m+n+p$. If the target feed cannot be obtained from the three feeds, output a single line containing the string `NONE`. It is guaranteed that if a solution exists, the solution with the smallest $m+n+p$ is unique.", "hint": "Translation from NOCOW. USACO Training Section 3.2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO3.2] 饲料调配 Feed Ratios", "background": "农夫约翰从来只用调配得最好的饲料来喂他的奶牛。饲料用三种原料调配成：大麦，燕麦和小麦。他知道自己的饲料精确的配比，在市场上是买不到这样的饲料的。他只好购买其他三种混合饲料（同样都由三种麦子组成），然后将它们混合，来调配他的完美饲料。", "description": "给出三组整数，每组整数表示一种饲料中大麦、燕麦与小麦的比例，找出用这三种饲料调配 $x:y:z$ 的饲料的方法。\n\n请编写一个程序找出使这三种饲料用量最少的方案，要是不能用这三种饲料调配目标饲料，输出一行一个字符串 `NONE`。“用量最少”意味着三种饲料的用量（整数）的和必须最小。\n\n例如，要求使用 $1:2:3$、$3:7:1$、$2:1:2$ 的饲料调配 $3:4:5$ 的饲料，我们可以通过 $8$ 份第一种饲料、$1$ 份第二种饲料和 $5$ 份第三种饲料调配 $7$ 份目标饲料。这是因为 $8 \\times 1 + 1 \\times 3 + 5 \\times 2 = 21$，$8 \\times 2 + 1 \\times 7 + 5 \\times 1 = 28$，$8 \\times 3 + 1 \\times 1 + 5 \\times 2 = 35$，而 $21:28:35$ 恰好等于 $3:4:5$。", "inputFormat": "第一行，三个整数 $x,y,z$，表示目标饲料中大麦、燕麦与小麦的比为 $x:y:z$。\n\n接下来三行，第 $i$ 行三个整数 $a_i,b_i,c_i$，表示第 $i$ 种饲料中大麦、燕麦与小麦的比为 $a_i:b_i:c_i$。\n\n数据保证输入的所有整数在 $0 \\sim 99$ 之间，且每一行的三个整数不会同为 $0$。", "outputFormat": "如果能够用这三种饲料调配出目标饲料，则输出一行 $4$ 个整数，前三个整数 $m,n,p$ 分别代表三种饲料的份数，第四个整数代表得到目标饲料的份数。如果有多解，输出 $m+n+p$ 最小的一组。如果不能用这三种饲料调配出目标饲料，输出一行一个字符串 `NONE`。数据保证如果有解， $m+n+p$ 最小的解只有一组。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 3.2", "locale": "zh-CN"}}}
{"pid": "P2730", "type": "P", "difficulty": 4, "samples": [["2 6 8 4 5 7 3 1 ", "7 \nBCABCCB"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO", "IOI", "O2优化", "广度优先搜索 BFS", "康托展开", "1996"], "title": "[IOI 1996 / USACO3.2] 魔板 Magic Squares", "background": "在成功地发明了魔方之后，鲁比克先生发明了它的二维版本，称作魔板。我们知道魔板的每一个方格都有一种颜色。这 $8$ 种颜色用前 $8$ 个正整数来表示。可以用颜色的序列来表示一种魔板状态，规定从魔板的左上角开始，沿顺时针方向依次取出整数，构成一个颜色序列。", "description": "这是一张有 $8$ 个大小相同的格子的魔板：\n| $1$ | $2$ | $3$ | $4$ |\n|:-:|:-:|:-:|:-:|\n| $8$ | $7$ | $6$ | $5$ |\n\n对于上图的魔板状态，我们用序列 $\\{1,2,3,4,5,6,7,8\\}$ 来表示。这是基本状态。\n\n这里提供三种基本操作，分别用大写字母 $\\text A$、$\\text B$、$\\text C$ 来表示（可以通过这些操作改变魔板的状态）。下面是对基本状态进行操作的示范：\n\n$\\text A$：交换上下两行；\n| $8$ | $7$ | $6$ | $5$ |\n|:-:|:-:|:-:|:-:|\n| $1$ | $2$ | $3$ | $4$ |\n\n$\\text B$：将最右边的一列插入最左边；\n| $4$ | $1$ | $2$ | $3$ |\n|:-:|:-:|:-:|:-:|\n| $5$ | $8$ | $7$ | $6$ |\n\n$\\text C$：魔板中央四格作顺时针旋转。\n| $1$ | $7$ | $2$ | $4$ |\n|:-:|:-:|:-:|:-:|\n| $8$ | $6$ | $3$ | $5$ |\n\n对于转换过程中任意一个状态，这三种基本操作都可以使用。\n\n编程计算最短的基本操作序列，完成基本状态到目标状态的转换。", "inputFormat": "只有一行，包括 $8$ 个整数 $a_1,a_2\\dots,a_8\\ (1\\leq a_1,a_2,\\dots,a_8\\leq8)$，用空格分开（中间无换行），表示目标状态。", "outputFormat": "第一行包括一个整数，表示最短操作序列的长度。\n\n第二行开始输出最短的操作序列，用字符串表示，每 $60$ 个字符换一行。如果有多种，输出字典序最小的。", "hint": "题目翻译来自 NOCOW。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1996 / USACO3.2] Magic Squares", "background": "After inventing the Rubik’s Cube, Mr. Rubik created its 2D version, called the magic board. Each cell on the magic board has a color. These $8$ colors are represented by the first $8$ positive integers. A board state can be represented by a sequence of colors: starting from the top-left corner of the board, take the integers in clockwise order to form a color sequence.", "description": "This is a magic board with $8$ squares of equal size:\n| $1$ | $2$ | $3$ | $4$ |\n|:-:|:-:|:-:|:-:|\n| $8$ | $7$ | $6$ | $5$ |\n\nFor the board state shown above, we use the sequence $\\{1,2,3,4,5,6,7,8\\}$ to represent it. This is the initial state.\n\nThere are three basic operations, denoted by the uppercase letters $\\text A$, $\\text B$, and $\\text C$ (you can change the board state using these operations). Below is a demonstration of applying them to the initial state:\n\n$\\text A$: Swap the top and bottom rows.\n| $8$ | $7$ | $6$ | $5$ |\n|:-:|:-:|:-:|:-:|\n| $1$ | $2$ | $3$ | $4$ |\n\n$\\text B$: Move the rightmost column to the leftmost position.\n| $4$ | $1$ | $2$ | $3$ |\n|:-:|:-:|:-:|:-:|\n| $5$ | $8$ | $7$ | $6$ |\n\n$\\text C$: Rotate the four central cells clockwise.\n| $1$ | $7$ | $2$ | $4$ |\n|:-:|:-:|:-:|:-:|\n| $8$ | $6$ | $3$ | $5$ |\n\nAt any state during the transformation, all three basic operations can be applied.\n\nWrite a program to compute the shortest sequence of basic operations that transforms the initial state into the target state.", "inputFormat": "A single line containing $8$ integers $a_1, a_2, \\dots, a_8$ with $1 \\leq a_1, a_2, \\dots, a_8 \\leq 8$, separated by spaces, representing the target state.", "outputFormat": "The first line contains an integer, the length of the shortest operation sequence.\n\nStarting from the second line, output the shortest sequence of operations as a string, wrapping every $60$ characters per line. If there are multiple solutions, output the lexicographically smallest one.", "hint": "Translation source: NOCOW.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1996 / USACO3.2] 魔板 Magic Squares", "background": "在成功地发明了魔方之后，鲁比克先生发明了它的二维版本，称作魔板。我们知道魔板的每一个方格都有一种颜色。这 $8$ 种颜色用前 $8$ 个正整数来表示。可以用颜色的序列来表示一种魔板状态，规定从魔板的左上角开始，沿顺时针方向依次取出整数，构成一个颜色序列。", "description": "这是一张有 $8$ 个大小相同的格子的魔板：\n| $1$ | $2$ | $3$ | $4$ |\n|:-:|:-:|:-:|:-:|\n| $8$ | $7$ | $6$ | $5$ |\n\n对于上图的魔板状态，我们用序列 $\\{1,2,3,4,5,6,7,8\\}$ 来表示。这是基本状态。\n\n这里提供三种基本操作，分别用大写字母 $\\text A$、$\\text B$、$\\text C$ 来表示（可以通过这些操作改变魔板的状态）。下面是对基本状态进行操作的示范：\n\n$\\text A$：交换上下两行；\n| $8$ | $7$ | $6$ | $5$ |\n|:-:|:-:|:-:|:-:|\n| $1$ | $2$ | $3$ | $4$ |\n\n$\\text B$：将最右边的一列插入最左边；\n| $4$ | $1$ | $2$ | $3$ |\n|:-:|:-:|:-:|:-:|\n| $5$ | $8$ | $7$ | $6$ |\n\n$\\text C$：魔板中央四格作顺时针旋转。\n| $1$ | $7$ | $2$ | $4$ |\n|:-:|:-:|:-:|:-:|\n| $8$ | $6$ | $3$ | $5$ |\n\n对于转换过程中任意一个状态，这三种基本操作都可以使用。\n\n编程计算最短的基本操作序列，完成基本状态到目标状态的转换。", "inputFormat": "只有一行，包括 $8$ 个整数 $a_1,a_2\\dots,a_8\\ (1\\leq a_1,a_2,\\dots,a_8\\leq8)$，用空格分开（中间无换行），表示目标状态。", "outputFormat": "第一行包括一个整数，表示最短操作序列的长度。\n\n第二行开始输出最短的操作序列，用字符串表示，每 $60$ 个字符换一行。如果有多种，输出字典序最小的。", "hint": "题目翻译来自 NOCOW。", "locale": "zh-CN"}}}
{"pid": "P2731", "type": "P", "difficulty": 4, "samples": [["9\n1 2\n2 3\n3 4\n4 2\n4 5\n2 5\n5 6\n5 7\n4 6", "1\n2\n3\n4\n2\n5\n4\n6\n5\n7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["搜索", "图论", "USACO", "欧拉回路"], "title": "[USACO3.3] 骑马修栅栏 Riding the Fences", "background": "Farmer John 每年有很多栅栏要修理。他总是骑着马穿过每一个栅栏并修复它破损的地方。", "description": "John 是一个与其他农民一样懒的人。他讨厌骑马，因此从来不两次经过一个栅栏。\n\nJohn 的农场上一共有 $m$ 个栅栏，每一个栅栏连接两个顶点，顶点用 $1$ 到 $500$ 标号（虽然有的农场并没有那么多个顶点）。一个顶点上至少连接 $1$ 个栅栏，没有上限。两顶点间可能有多个栅栏。所有栅栏都是连通的（也就是你可以从任意一个栅栏到达另外的所有栅栏）。John 能从任何一个顶点（即两个栅栏的交点）开始骑马，在任意一个顶点结束。\n\n你需要求出输出骑马的路径（用路上依次经过的顶点号码表示)，使每个栅栏都恰好被经过一次。如果存在多组可行的解，按照如下方式进行输出：如果把输出的路径看成是一个 $500$ 进制的数，那么当存在多组解的情况下，输出 $500$ 进制表示法中最小的一个 （也就是输出第一位较小的，如果还有多组解，输出第二位较小的，以此类推）。\n\n输入数据保证至少有一个解。", "inputFormat": "第一行一个整数 $m$，表示栅栏的数目。\n\n从第二行到第 $(m+1)$ 行，每行两个整数 $u,v$，表示有一条栅栏连接 $u,v$ 两个点。", "outputFormat": "共 $(m+1)$ 行，每行一个整数，依次表示路径经过的顶点号。注意数据可能有多组解，但是只有上面题目要求的那一组解是认为正确的。\n\n数据保证至少有一组可行解。", "hint": "对于 $100\\%$ 的数据，$1 \\leq m \\leq 1024,1 \\leq u,v \\leq 500$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 3.3", "locale": "zh-CN", "translations": {"en": {"title": "[USACO3.3] Riding the Fences", "background": "Farmer John has many fences to repair every year. He always rides his horse along each fence and fixes the broken spots.", "description": "John is as lazy as any other farmer. He hates riding, so he never goes along the same fence twice.\n\nThere are $m$ fences on John’s farm. Each fence connects two vertices, and vertices are labeled from $1$ to $500$ (though a given farm may have fewer vertices). At each vertex at least $1$ fence meets, with no upper bound. There may be multiple fences between the same pair of vertices. The fence graph is connected (i.e., you can reach any fence from any other fence). John may start riding at any vertex (i.e., an intersection point of fences) and finish at any vertex.\n\nYou need to output a riding route (represented by the sequence of vertex labels encountered along the way) such that each fence is traversed exactly once. If multiple valid routes exist, apply the following rule: if you view the output path as a base-$500$ number, then among all possible routes, output the smallest one in base-$500$ representation (that is, minimize the first entry; if still tied, minimize the second entry; and so on).\n\nThe input guarantees that there is at least one solution.", "inputFormat": "The first line contains an integer $m$, the number of fences.\n\nFrom the second line to the $(m+1)$-th line, each line contains two integers $u, v$, indicating there is a fence connecting vertices $u$ and $v$.", "outputFormat": "Output $(m+1)$ lines. Each line contains one integer, the vertex label of the route in order. Note that there may be multiple solutions, but only the one specified above is considered correct.\n\nThe input guarantees that there is at least one valid solution.", "hint": "For $100\\%$ of the testdata, $1 \\leq m \\leq 1024, 1 \\leq u, v \\leq 500$.\n\nProblem translation from NOCOW.\n\nUSACO Training Section 3.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO3.3] 骑马修栅栏 Riding the Fences", "background": "Farmer John 每年有很多栅栏要修理。他总是骑着马穿过每一个栅栏并修复它破损的地方。", "description": "John 是一个与其他农民一样懒的人。他讨厌骑马，因此从来不两次经过一个栅栏。\n\nJohn 的农场上一共有 $m$ 个栅栏，每一个栅栏连接两个顶点，顶点用 $1$ 到 $500$ 标号（虽然有的农场并没有那么多个顶点）。一个顶点上至少连接 $1$ 个栅栏，没有上限。两顶点间可能有多个栅栏。所有栅栏都是连通的（也就是你可以从任意一个栅栏到达另外的所有栅栏）。John 能从任何一个顶点（即两个栅栏的交点）开始骑马，在任意一个顶点结束。\n\n你需要求出输出骑马的路径（用路上依次经过的顶点号码表示)，使每个栅栏都恰好被经过一次。如果存在多组可行的解，按照如下方式进行输出：如果把输出的路径看成是一个 $500$ 进制的数，那么当存在多组解的情况下，输出 $500$ 进制表示法中最小的一个 （也就是输出第一位较小的，如果还有多组解，输出第二位较小的，以此类推）。\n\n输入数据保证至少有一个解。", "inputFormat": "第一行一个整数 $m$，表示栅栏的数目。\n\n从第二行到第 $(m+1)$ 行，每行两个整数 $u,v$，表示有一条栅栏连接 $u,v$ 两个点。", "outputFormat": "共 $(m+1)$ 行，每行一个整数，依次表示路径经过的顶点号。注意数据可能有多组解，但是只有上面题目要求的那一组解是认为正确的。\n\n数据保证至少有一组可行解。", "hint": "对于 $100\\%$ 的数据，$1 \\leq m \\leq 1024,1 \\leq u,v \\leq 500$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 3.3", "locale": "zh-CN"}}}
{"pid": "P2732", "type": "P", "difficulty": 5, "samples": [["2\n1 7 3 5\n2 7 1 8 2 10\n2\n7 3 2\n8 2 5", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "USACO", "背包 DP"], "title": "[USACO3.3] 商店购物 Shopping Offers", "background": "在商店中，每一种商品都有一个价格（用整数表示）。例如,一朵花的价格是 $2$ ，而一个花瓶的价格是 $5$ 。为了吸引更多的顾客，商店举行了促销活动。", "description": "促销活动把一个或多个商品组合起来降价销售，例如：\n\n三朵花的价格是 $5$ 而不是 $6$ ，$2$ 个花瓶和一朵花的价格是 $10$ 而不是 $12$ 。 请编写一个程序，计算顾客购买一定商品的花费，尽量地利用优惠使花费最少。尽管有时候添加其他商品可以获得更少的花费，但是你不能这么做。\n\n对于上面的商品信息，购买三朵花和两个花瓶的最少花费的方案是：以优惠价购买两个花瓶和一朵花（$10$），以原价购买两朵花（$4$）。", "inputFormat": "输入文件包括一些商店提供的优惠信息，接着是购物清单。（最多有 $5$ 种商品）\n\n第一行 优惠方案的种类数（$0\\leq s\\leq99$）。\n\n第 $2$ 行 $\\sim$ 第 $s+1$ 行  每一行都用几个整数来表示一种优惠方式。第一个整数 $n$ （$1\\leq n\\leq5$），表示这种优惠方式由 $n$ 种商品组成。后面 $n$ 对整数 $c$ 和 $k$ 表示 $k$ （$1\\leq k\\leq5$）个编号为 $c$ （$1\\leq c\\leq999$）的商品共同构成这种优惠，最后的整数 $p$ 表示这种优惠的优惠价（$1\\leq p\\leq9,999$）。优惠价总是比原价低。\n\n第 $s+2$ 行 这一行有一个整数 $b$ （$0\\leq b\\leq5$），表示需要购买 $b$ 种不同的商品。\n\n第 $s+3$ 行 $\\sim$ 第 $s+b+2$ 行 这 $b$ 行中的每一行包括三个整数：$c,k,p$ 。 $c$ 表示唯一的商品编号（$1\\leq c\\leq999$），$k$ 表示需要购买的 $c$ 商品的数量（$1\\leq k\\leq5$）。$p$ 表示 $c$ 商品的原价（$1\\leq p\\leq999$）。最多购买 $5\\times5=25$ 个商品。", "outputFormat": "只有一行，输出一个整数：购买这些物品的最低价格。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 3.3", "locale": "zh-CN", "translations": {"en": {"title": "[USACO3.3] Shopping Offers", "background": "In a store, each type of product has a price (an integer). For example, a flower costs $2$, and a vase costs $5$. To attract more customers, the store runs promotions.", "description": "Promotions bundle one or more products and sell them at a discount. For example:\n\nThree flowers cost $5$ instead of $6$, and $2$ vases plus $1$ flower cost $10$ instead of $12$. Write a program to compute the cost for a customer to buy certain products, using the offers to minimize the total cost. Even if adding extra products could lower the total cost, you are not allowed to do that.\n\nFor the products above, the minimum cost to buy three flowers and two vases is: buy the offer of two vases and one flower for $10$, and buy two flowers at the regular price for $4$.", "inputFormat": "The input file contains some offers provided by the store, followed by a shopping list (at most $5$ types of products).\n\nLine $1$: The number of offer types $s$ ($0 \\leq s \\leq 99$).\n\nLines $2$ to $s+1$: Each line describes one offer using several integers. The first integer $n$ ($1 \\leq n \\leq 5$) is the number of different products in this offer. Then there are $n$ pairs of integers $c$ and $k$, meaning $k$ ($1 \\leq k \\leq 5$) units of the product with code $c$ ($1 \\leq c \\leq 999$) are included in this offer. The last integer $p$ is the offer price ($1 \\leq p \\leq 9{,}999$). The offer price is always lower than the regular price.\n\nLine $s+2$: An integer $b$ ($0 \\leq b \\leq 5$), the number of different products to buy.\n\nLines $s+3$ to $s+b+2$: Each of these $b$ lines contains three integers $c, k, p$. Here $c$ is the unique product code ($1 \\leq c \\leq 999$), $k$ is the required quantity of product $c$ ($1 \\leq k \\leq 5$), and $p$ is the regular price of product $c$ ($1 \\leq p \\leq 999$). In total, at most $5 \\times 5 = 25$ items are to be purchased.", "outputFormat": "Output a single line with one integer: the minimum total price to purchase these items.", "hint": "Translation from NOCOW.\n\nUSACO Training Section 3.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO3.3] 商店购物 Shopping Offers", "background": "在商店中，每一种商品都有一个价格（用整数表示）。例如,一朵花的价格是 $2$ ，而一个花瓶的价格是 $5$ 。为了吸引更多的顾客，商店举行了促销活动。", "description": "促销活动把一个或多个商品组合起来降价销售，例如：\n\n三朵花的价格是 $5$ 而不是 $6$ ，$2$ 个花瓶和一朵花的价格是 $10$ 而不是 $12$ 。 请编写一个程序，计算顾客购买一定商品的花费，尽量地利用优惠使花费最少。尽管有时候添加其他商品可以获得更少的花费，但是你不能这么做。\n\n对于上面的商品信息，购买三朵花和两个花瓶的最少花费的方案是：以优惠价购买两个花瓶和一朵花（$10$），以原价购买两朵花（$4$）。", "inputFormat": "输入文件包括一些商店提供的优惠信息，接着是购物清单。（最多有 $5$ 种商品）\n\n第一行 优惠方案的种类数（$0\\leq s\\leq99$）。\n\n第 $2$ 行 $\\sim$ 第 $s+1$ 行  每一行都用几个整数来表示一种优惠方式。第一个整数 $n$ （$1\\leq n\\leq5$），表示这种优惠方式由 $n$ 种商品组成。后面 $n$ 对整数 $c$ 和 $k$ 表示 $k$ （$1\\leq k\\leq5$）个编号为 $c$ （$1\\leq c\\leq999$）的商品共同构成这种优惠，最后的整数 $p$ 表示这种优惠的优惠价（$1\\leq p\\leq9,999$）。优惠价总是比原价低。\n\n第 $s+2$ 行 这一行有一个整数 $b$ （$0\\leq b\\leq5$），表示需要购买 $b$ 种不同的商品。\n\n第 $s+3$ 行 $\\sim$ 第 $s+b+2$ 行 这 $b$ 行中的每一行包括三个整数：$c,k,p$ 。 $c$ 表示唯一的商品编号（$1\\leq c\\leq999$），$k$ 表示需要购买的 $c$ 商品的数量（$1\\leq k\\leq5$）。$p$ 表示 $c$ 商品的原价（$1\\leq p\\leq999$）。最多购买 $5\\times5=25$ 个商品。", "outputFormat": "只有一行，输出一个整数：购买这些物品的最低价格。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 3.3", "locale": "zh-CN"}}}
{"pid": "P2733", "type": "P", "difficulty": 3, "samples": [["6\n101111\n001111\n111111\n001111\n101101\n111001", "2 10\n3 4\n4 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "USACO", "前缀和"], "title": "[USACO3.3] 家的范围 Home on the Range", "background": "FJ 在一片边长是 $N (2 \\le N \\le 250)$ 英里的正方形牧场上放牧他的奶牛（出于某些原因，他的奶牛只在正方形的牧场上吃草）。遗憾的是，他的奶牛已经毁坏一些土地（这些土地都是由 $1$ 平方英里构成的）。", "description": "FJ 需要统计有多少个正方形牧场可以放牧（至少是 $2\\times2$ 的正方形，且此图形中没有一个点是被破坏的，换句话说，所有的点都是 “1”）。\n\n你的任务是在给出的数据中统计有多少个大于等于 $2\\times2$ 的正方形牧场可以放牧。当然，放牧区域可以重叠。", "inputFormat": "第 $1$ 行：$N$，牧区的边长。\n\n第 $2$ 到 $N+1$ 行：$N$ 个没有空格分开的字符。$0$ 表示那一个区段被毁坏了；$1$ 表示完好无损的土地。", "outputFormat": "输出那些存在的正方形的边长和个数，一种一行。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 3.3", "locale": "zh-CN", "translations": {"en": {"title": "{{[USACO3.3] Home on the Range}}", "background": "{{FJ grazes his cows on a square pasture with side length $N (2 \\le N \\le 250)$ miles (for some reason, his cows graze only on square pastures). Unfortunately, his cows have damaged some land (these patches are each $1$ square mile).}}", "description": "{{FJ needs to count how many square pastures can be grazed (at least $2\\times2$ in size, and no cell in this shape is damaged; in other words, all cells are \"1\"). Your task is to count, in the given data, how many grazeable square pastures of size at least $2\\times2$ there are. Of course, grazing regions may overlap.}}", "inputFormat": "{{Line 1: $N$, the side length of the pasture.\nLines 2 to $N+1$: $N$ characters with no spaces. $0$ indicates that cell is damaged; $1$ indicates intact land.}}", "outputFormat": "{{Output the side length and the count of such squares that exist, one size per line, in increasing order of side length.}}", "hint": "{{Translation from NOCOW.\nUSACO Training Section 3.3.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO3.3] 家的范围 Home on the Range", "background": "FJ 在一片边长是 $N (2 \\le N \\le 250)$ 英里的正方形牧场上放牧他的奶牛（出于某些原因，他的奶牛只在正方形的牧场上吃草）。遗憾的是，他的奶牛已经毁坏一些土地（这些土地都是由 $1$ 平方英里构成的）。", "description": "FJ 需要统计有多少个正方形牧场可以放牧（至少是 $2\\times2$ 的正方形，且此图形中没有一个点是被破坏的，换句话说，所有的点都是 “1”）。\n\n你的任务是在给出的数据中统计有多少个大于等于 $2\\times2$ 的正方形牧场可以放牧。当然，放牧区域可以重叠。", "inputFormat": "第 $1$ 行：$N$，牧区的边长。\n\n第 $2$ 到 $N+1$ 行：$N$ 个没有空格分开的字符。$0$ 表示那一个区段被毁坏了；$1$ 表示完好无损的土地。", "outputFormat": "输出那些存在的正方形的边长和个数，一种一行。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 3.3", "locale": "zh-CN"}}}
{"pid": "P2734", "type": "P", "difficulty": 3, "samples": [["6 \n4 7 2 9 5 2", "18 11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "博弈论", "USACO", "IOI", "1996"], "title": "[IOI 1996 / USACO3.3] 游戏 A Game", "background": "有如下一个双人游戏：$N\\ (2 \\leq N \\leq 100)$ 个正整数的序列放在一个游戏平台上，由先手开始，先手和后手轮流从序列的任意一端取一个数，取数后从序列中去掉，并累加到取者的得分中，当数取尽时，游戏结束。以最终得分高者为胜。", "description": "编一个执行最优策略的程序计算最终得分。最优策略就是使玩家在与最好的对手对弈时，能得到的在当前情况下最大的可能的总分的策略。你的程序要始终为两位玩家执行最优策略。", "inputFormat": "第一行：正整数 $N$，表示序列中正整数的个数。\n\n第二行至末尾：用空格分隔的 $N$ 个正整数（大小为 $1\\sim 200$）。", "outputFormat": "只有一行，用空格分隔的两个整数：依次为先手和后手最终的得分。", "hint": "题目翻译来自 NOCOW。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1996 / USACO3.3] A Game", "background": "There is a two-player game as follows: a sequence of $N\\ (2 \\leq N \\leq 100)$ positive integers is placed on a game platform. Starting with the first player, the two players take turns picking one number from either end of the sequence. After picking, the number is removed from the sequence and added to the picker’s score. When all numbers have been taken, the game ends. The player with the higher final score wins.", "description": "Write a program that plays optimally to compute the final scores. An optimal strategy is one that, when facing the best possible opponent, gives the player the maximum total score possible in the current situation. Your program should always apply the optimal strategy for both players.", "inputFormat": "The first line: a positive integer $N$, indicating the number of positive integers in the sequence.\n\nFrom the second line to the end: $N$ space-separated positive integers (each in $1 \\sim 200$).", "outputFormat": "A single line with two integers separated by a space: the final scores of the first player and the second player, in that order.", "hint": "Problem translation sourced from NOCOW.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1996 / USACO3.3] 游戏 A Game", "background": "有如下一个双人游戏：$N\\ (2 \\leq N \\leq 100)$ 个正整数的序列放在一个游戏平台上，由先手开始，先手和后手轮流从序列的任意一端取一个数，取数后从序列中去掉，并累加到取者的得分中，当数取尽时，游戏结束。以最终得分高者为胜。", "description": "编一个执行最优策略的程序计算最终得分。最优策略就是使玩家在与最好的对手对弈时，能得到的在当前情况下最大的可能的总分的策略。你的程序要始终为两位玩家执行最优策略。", "inputFormat": "第一行：正整数 $N$，表示序列中正整数的个数。\n\n第二行至末尾：用空格分隔的 $N$ 个正整数（大小为 $1\\sim 200$）。", "outputFormat": "只有一行，用空格分隔的两个整数：依次为先手和后手最终的得分。", "hint": "题目翻译来自 NOCOW。", "locale": "zh-CN"}}}
{"pid": "P2735", "type": "P", "difficulty": 3, "samples": [["7 5 10", "20"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["计算几何", "USACO"], "title": "[USACO3.4] 网 Electric Fences", "background": null, "description": "在本题中，格点是指横纵坐标皆为整数的点。\n\n为了圈养他的牛，Farmer John 建造了一个三角形的电网。他从原点 $(0,0)$ 牵出一根通电的电线，连接格点 $(n,m)$（$0\\le n<32000,0<m<32000$），再连接格点 $(p,0)$（$p>0$），最后回到原点。\n\n牛可以在不碰到电网的情况下被放到电网内部的每一个格点上（十分瘦的牛）。如果一个格点碰到了电网，牛绝对不可以被放到该格点之上（或许 Farmer John 会有一些收获）。那么有多少头牛可以被放到农夫约翰的电网中去呢？", "inputFormat": "输入文件只有一行，包含三个用空格隔开的整数：$n,m,p$。", "outputFormat": "输出文件只有一行，包含一个整数，代表能被指定的电网包含的牛的数目。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 3.4。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO3.4] Electric Fences", "background": "", "description": "In this problem, a lattice point is a point whose $x$ and $y$ coordinates are both integers.\n\nTo pen his cows, Farmer John builds a triangular electric fence. He runs a live wire from the origin $(0,0)$ to the lattice point $(n,m)$ ($0 \\le n < 32000, 0 < m < 32000$), then to the lattice point $(p,0)$ ($p > 0$), and finally back to the origin.\n\nCows can be placed at every lattice point strictly inside the fence without touching the fence (very skinny cows). If a lattice point touches the fence, a cow absolutely cannot be placed there (perhaps Farmer John would get a little shock). How many cows can be placed inside Farmer John’s electric fence?", "inputFormat": "The input contains a single line with three integers separated by spaces: $n, m, p$.", "outputFormat": "Output a single line containing one integer, the number of cows that can be enclosed by the specified electric fence.", "hint": "Problem translation is from NOCOW. USACO Training Section 3.4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO3.4] 网 Electric Fences", "background": null, "description": "在本题中，格点是指横纵坐标皆为整数的点。\n\n为了圈养他的牛，Farmer John 建造了一个三角形的电网。他从原点 $(0,0)$ 牵出一根通电的电线，连接格点 $(n,m)$（$0\\le n<32000,0<m<32000$），再连接格点 $(p,0)$（$p>0$），最后回到原点。\n\n牛可以在不碰到电网的情况下被放到电网内部的每一个格点上（十分瘦的牛）。如果一个格点碰到了电网，牛绝对不可以被放到该格点之上（或许 Farmer John 会有一些收获）。那么有多少头牛可以被放到农夫约翰的电网中去呢？", "inputFormat": "输入文件只有一行，包含三个用空格隔开的整数：$n,m,p$。", "outputFormat": "输出文件只有一行，包含一个整数，代表能被指定的电网包含的牛的数目。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 3.4。", "locale": "zh-CN"}}}
{"pid": "P2736", "type": "P", "difficulty": 4, "samples": [["4 5 2\n4 3 4 2", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "USACO"], "title": "[USACO3.4] “破锣摇滚”乐队 Raucous Rockers", "background": null, "description": "你刚刚继承了流行的 “破锣摇滚” 乐队录制的尚未发表的 $N$（$1\\le N\\le20$）首歌的版权。你打算从中精选一些歌曲，发行 $M$（$1\\le M\\le20$）张 CD。每一张 CD 最多可以容纳 $T$（$1 \\le T\\le20$）分钟的音乐，一首歌不能分装在两张 CD 中。CD 数量可以用完，也可以不用完。\n\n不巧你是一位古典音乐迷，不懂如何判定这些歌的艺术价值。于是你决定根据以下标准进行选择：\n\n- 歌曲必须按照创作的时间顺序在所有的 CD 盘上出现，即第 $i$ 张盘的最后一首的创作时间要早于第 $i+1$ 张盘的第一首。\n\n- 选中的歌曲数目尽可能地多。", "inputFormat": "第一行：三个整数 $N,T,M$。\n\n第二行：$N$ 个整数，分别表示每首歌的长度，按创作时间顺序排列。", "outputFormat": "一个整数，表示可以装进 $M$ 张 CD 盘的乐曲的最大数目。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 3.4", "locale": "zh-CN", "translations": {"en": {"title": "[USACO3.4] \"Raucous Rockers\"", "background": "", "description": "You have just inherited the rights to $N$ ($1\\le N\\le20$) unreleased songs recorded by the popular \"Raucous Rockers\" band. You plan to select some of them to release on $M$ ($1\\le M\\le20$) CDs. Each CD can hold at most $T$ ($1 \\le T\\le20$) minutes of music, and a song cannot be split across two CDs. You may use fewer than $M$ CDs.\n\nUnfortunately, you are a classical music fan and do not know how to judge their artistic value. So you decide to choose according to the following rules:\n\n- The songs must appear on all CDs in the order they were composed, that is, the last song on disc $i$ must have been composed earlier than the first song on disc $i+1$.\n- The number of selected songs should be as large as possible.", "inputFormat": "The first line: three integers $N, T, M$.\n\nThe second line: $N$ integers, the length of each song, in order of composition.", "outputFormat": "A single integer, the maximum number of songs that can fit on $M$ CDs.", "hint": "Translation comes from NOCOW.\n\nUSACO Training Section 3.4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO3.4] “破锣摇滚”乐队 Raucous Rockers", "background": null, "description": "你刚刚继承了流行的 “破锣摇滚” 乐队录制的尚未发表的 $N$（$1\\le N\\le20$）首歌的版权。你打算从中精选一些歌曲，发行 $M$（$1\\le M\\le20$）张 CD。每一张 CD 最多可以容纳 $T$（$1 \\le T\\le20$）分钟的音乐，一首歌不能分装在两张 CD 中。CD 数量可以用完，也可以不用完。\n\n不巧你是一位古典音乐迷，不懂如何判定这些歌的艺术价值。于是你决定根据以下标准进行选择：\n\n- 歌曲必须按照创作的时间顺序在所有的 CD 盘上出现，即第 $i$ 张盘的最后一首的创作时间要早于第 $i+1$ 张盘的第一首。\n\n- 选中的歌曲数目尽可能地多。", "inputFormat": "第一行：三个整数 $N,T,M$。\n\n第二行：$N$ 个整数，分别表示每首歌的长度，按创作时间顺序排列。", "outputFormat": "一个整数，表示可以装进 $M$ 张 CD 盘的乐曲的最大数目。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 3.4", "locale": "zh-CN"}}}
{"pid": "P2737", "type": "P", "difficulty": 4, "samples": [["3\r\n3\r\n6\r\n10", "17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "USACO"], "title": "[USACO4.1] 麦香牛块 Beef McNuggets", "background": null, "description": "农夫布朗的奶牛们正在进行斗争，因为它们听说麦当劳正在考虑引进一种新产品：麦香牛块。奶牛们正在想尽一切办法让这种可怕的设想泡汤。奶牛们进行斗争的策略之一是“劣质的包装”。“看，”奶牛们说，“如果你只用一次能装 $3$ 块、$6$ 块或者 $10$ 块的三种包装盒包装麦香牛块，你就不可能满足一次只想买 $1$、$2$、$4$、$5$、$7$、$8$、$11$、$14$ 或者 $17$ 块麦香牛块的顾客了。劣质的包装意味着劣质的产品。”\n\n你的任务是帮助这些奶牛。给出包装盒的种类数 $N\\ (1 \\le N \\le 10)$ 和 $N$ 个代表不同种类包装盒容纳麦香牛块个数的正整数 $b_i\\ (1 \\le b_i \\le 256)$，输出顾客不能用上述包装盒（每种盒子数量无限）买到麦香牛块的最大块数。如果所有购买方案都能得到满足或者不存在不能买到块数的上限，则输出 $0$。不能买到的最大块数（如果它存在）不超过 $2\\times 10^9$。", "inputFormat": "第 $1$ 行：包装盒的种类数 $N$。\n\n第 $2$ 行到 $N+1$ 行：每个种类包装盒容纳麦香牛块的个数。", "outputFormat": "输出文件只有一行数字：顾客不能用包装盒买到麦香牛块的最大块数或 $0$（如果所有购买方案都能得到满足或者顾客不能买到的块数没有上限）。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 4.1", "locale": "zh-CN", "translations": {"en": {"title": "[USACO4.1] Beef McNuggets", "background": "", "description": "Farmer Brown’s cows are campaigning because they heard McDonald’s is considering a new product: Beef McNuggets. The cows are trying everything to sink this terrible idea. One of their strategies is “poor packaging.” “Look,” say the cows, “if you package McNuggets using only three box sizes that hold $3$, $6$, or $10$ pieces, then you cannot satisfy customers who want to buy exactly $1$, $2$, $4$, $5$, $7$, $8$, $11$, $14$, or $17$ pieces. Poor packaging means a poor product.”\n\nYour task is to help the cows. Given the number of box types $N\\ (1 \\le N \\le 10)$ and $N$ positive integers $b_i\\ (1 \\le b_i \\le 256)$ representing how many McNuggets each type of box can hold, output the largest number of McNuggets that cannot be bought using these boxes (each box type is available in unlimited quantity). If every purchase request can be satisfied, or if there is no upper bound on the numbers that cannot be bought, output $0$. The largest number that cannot be bought (if it exists) does not exceed $2 \\times 10^9$.", "inputFormat": "Line 1: The number of box types $N$.\n\nLines $2$ to $N+1$: For each type, the number of McNuggets a box of that type can hold.", "outputFormat": "Output a single integer: the largest number of McNuggets that cannot be bought using the given boxes, or $0$ (if every request can be satisfied or if the set of numbers that cannot be bought is unbounded).", "hint": "Problem translation from NOCOW.\n\nUSACO Training Section 4.1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO4.1] 麦香牛块 Beef McNuggets", "background": null, "description": "农夫布朗的奶牛们正在进行斗争，因为它们听说麦当劳正在考虑引进一种新产品：麦香牛块。奶牛们正在想尽一切办法让这种可怕的设想泡汤。奶牛们进行斗争的策略之一是“劣质的包装”。“看，”奶牛们说，“如果你只用一次能装 $3$ 块、$6$ 块或者 $10$ 块的三种包装盒包装麦香牛块，你就不可能满足一次只想买 $1$、$2$、$4$、$5$、$7$、$8$、$11$、$14$ 或者 $17$ 块麦香牛块的顾客了。劣质的包装意味着劣质的产品。”\n\n你的任务是帮助这些奶牛。给出包装盒的种类数 $N\\ (1 \\le N \\le 10)$ 和 $N$ 个代表不同种类包装盒容纳麦香牛块个数的正整数 $b_i\\ (1 \\le b_i \\le 256)$，输出顾客不能用上述包装盒（每种盒子数量无限）买到麦香牛块的最大块数。如果所有购买方案都能得到满足或者不存在不能买到块数的上限，则输出 $0$。不能买到的最大块数（如果它存在）不超过 $2\\times 10^9$。", "inputFormat": "第 $1$ 行：包装盒的种类数 $N$。\n\n第 $2$ 行到 $N+1$ 行：每个种类包装盒容纳麦香牛块的个数。", "outputFormat": "输出文件只有一行数字：顾客不能用包装盒买到麦香牛块的最大块数或 $0$（如果所有购买方案都能得到满足或者顾客不能买到的块数没有上限）。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 4.1", "locale": "zh-CN"}}}
{"pid": "P2738", "type": "P", "difficulty": 5, "samples": [["10\n1 16 2 2\n2 7\n10 6\n2 3 2 2\n1 7\n8 3\n3 3 2 1\n8 2\n4\n4 8 1 3\n3\n9 10 5\n5 8 3 1\n9 10 4\n6\n6 6 1 2 \n5 \n1 10\n7 5 2 2 \n1 2\n8 9\n8 4 2 2\n2 3\n7 9\n9 5 2 3\n7 8\n4 5 10\n10 10 2 3\n1 6\n4 9 5", "12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "图论", "USACO", "优先队列", "队列"], "title": "[USACO4.1] 篱笆回路 Fence Loops", "background": null, "description": "农夫布朗的牧场上的篱笆已经失去控制了。它们分成了 $1\\sim 200$ 英尺长的线段。只有在线段的端点处才能连接两个线段，有时给定的一个端点上会有两个以上的篱笆。结果篱笆形成了一张网分割了布朗的牧场。布朗想将牧场恢复原样，出于这个考虑，他首先得知道牧场上哪一块区域的周长最小。布朗将他的每段篱笆从 $1$ 到 $N$ 进行了标号（$N=$ 线段的总数）。他知道每段篱笆有如下属性：\n\n- 该段篱笆的长度；\n- 该段篱笆的一端所连接的另一段篱笆的标号；\n- 该段篱笆的另一端所连接的另一段篱笆的标号。\n\n幸运的是，没有篱笆连接它自身。对于一组有关篱笆如何分割牧场的数据，写一个程序来计算出所有分割出的区域中最小的周长。\n\n例如，标号 $1\\sim 10$ 的篱笆由下图的形式组成（下面的数字是篱笆的标号）：\n\n\n```plain\n           1\n   +---------------+\n   |\\             /|\n  2| \\7          / |\n   |  \\         /  |\n   +---+       /   |6\n   | 8  \\     /10  |\n  3|     \\9  /     |\n   |      \\ /      |\n   +-------+-------+\n       4       5\n```    \n上图中周长最小的区域是由 $2,7,8$ 号篱笆形成的。", "inputFormat": "第一行一个整数 $N$（$1 \\leq N \\leq 100$）；\n\n第 $2$ 行到第 $3\\times N+1$ 行：每三行为一组，共 $N$ 组信息：\n\n每组信息的第 $1$ 行有 $4$ 个整数：$s$，这段篱笆的标号（$1\\le s\\le N$）；$L_s$，这段篱笆的长度（$1\\le L_s\\le255$）；$N1_s$（$1\\le N1_s\\le 8$）与本段篱笆的一端所相邻的篱笆的数量；$N2_s$（$1\\le N2_s\\le 8$）与本段篱笆的另一端所相邻的篱笆的数量。\n\n每组信息的的第 $2$ 行有 $N1_s$ 个整数，分别描述与本段篱笆的一端所相邻的篱笆的标号。\n\n每组信息的的第 $3$ 行有 $N2_s$ 个整数，分别描述与本段篱笆的另一端所相邻的篱笆的标号。", "outputFormat": "输出的内容为单独的一行，用一个整数来表示最小的周长。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 4.1。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO4.1] Fence Loops", "background": "", "description": "The fences on Farmer Brown's pasture have gotten out of control. They have been divided into segments that are $1\\sim 200$ feet long. Two segments can be connected only at their endpoints, and sometimes more than two fences meet at a given endpoint. As a result, the fences form a network that partitions Brown's pasture. Brown wants to restore the pasture to its original state; to do so, he first needs to know which region has the smallest perimeter. Brown labeled each fence segment from $1$ to $N$ ($N=$ the total number of segments). For each segment, he knows:\n\n- The length of the segment;\n- The labels of the segments connected to one endpoint of this segment;\n- The labels of the segments connected to the other endpoint of this segment.\n\nFortunately, no fence connects to itself. Given data describing how the fences partition the pasture, write a program to compute the smallest perimeter among all regions.\n\nFor example, fences labeled $1\\sim 10$ form the configuration shown below (numbers indicate fence labels):\n\n```plain\n           1\n   +---------------+\n   |\\             /|\n  2| \\7          / |\n   |  \\         /  |\n   +---+       /   |6\n   | 8  \\     /10  |\n  3|     \\9  /     |\n   |      \\ /      |\n   +-------+-------+\n       4       5\n```\nIn the figure above, the region with the smallest perimeter is formed by fences $2, 7, 8$.", "inputFormat": "The first line contains an integer $N$ ($1 \\leq N \\leq 100$).\n\nLines $2$ through $3\\times N+1$ describe $N$ groups, three lines per group:\n\n- The first line of each group has $4$ integers: $s$, the label of this fence segment ($1\\le s\\le N$); $L_s$, the length of this segment ($1\\le L_s\\le255$); $N1_s$, the number of neighboring fences at one endpoint ($1\\le N1_s\\le 8$); and $N2_s$, the number of neighboring fences at the other endpoint ($1\\le N2_s\\le 8$).\n- The second line of each group has $N1_s$ integers: the labels of the fences adjacent at one endpoint.\n- The third line of each group has $N2_s$ integers: the labels of the fences adjacent at the other endpoint.", "outputFormat": "Output a single line containing one integer, the minimum perimeter.", "hint": "This statement is translated from NOCOW.\n\nUSACO Training Section 4.1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO4.1] 篱笆回路 Fence Loops", "background": null, "description": "农夫布朗的牧场上的篱笆已经失去控制了。它们分成了 $1\\sim 200$ 英尺长的线段。只有在线段的端点处才能连接两个线段，有时给定的一个端点上会有两个以上的篱笆。结果篱笆形成了一张网分割了布朗的牧场。布朗想将牧场恢复原样，出于这个考虑，他首先得知道牧场上哪一块区域的周长最小。布朗将他的每段篱笆从 $1$ 到 $N$ 进行了标号（$N=$ 线段的总数）。他知道每段篱笆有如下属性：\n\n- 该段篱笆的长度；\n- 该段篱笆的一端所连接的另一段篱笆的标号；\n- 该段篱笆的另一端所连接的另一段篱笆的标号。\n\n幸运的是，没有篱笆连接它自身。对于一组有关篱笆如何分割牧场的数据，写一个程序来计算出所有分割出的区域中最小的周长。\n\n例如，标号 $1\\sim 10$ 的篱笆由下图的形式组成（下面的数字是篱笆的标号）：\n\n\n```plain\n           1\n   +---------------+\n   |\\             /|\n  2| \\7          / |\n   |  \\         /  |\n   +---+       /   |6\n   | 8  \\     /10  |\n  3|     \\9  /     |\n   |      \\ /      |\n   +-------+-------+\n       4       5\n```    \n上图中周长最小的区域是由 $2,7,8$ 号篱笆形成的。", "inputFormat": "第一行一个整数 $N$（$1 \\leq N \\leq 100$）；\n\n第 $2$ 行到第 $3\\times N+1$ 行：每三行为一组，共 $N$ 组信息：\n\n每组信息的第 $1$ 行有 $4$ 个整数：$s$，这段篱笆的标号（$1\\le s\\le N$）；$L_s$，这段篱笆的长度（$1\\le L_s\\le255$）；$N1_s$（$1\\le N1_s\\le 8$）与本段篱笆的一端所相邻的篱笆的数量；$N2_s$（$1\\le N2_s\\le 8$）与本段篱笆的另一端所相邻的篱笆的数量。\n\n每组信息的的第 $2$ 行有 $N1_s$ 个整数，分别描述与本段篱笆的一端所相邻的篱笆的标号。\n\n每组信息的的第 $3$ 行有 $N2_s$ 个整数，分别描述与本段篱笆的另一端所相邻的篱笆的标号。", "outputFormat": "输出的内容为单独的一行，用一个整数来表示最小的周长。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 4.1。", "locale": "zh-CN"}}}
{"pid": "P2739", "type": "P", "difficulty": 4, "samples": [["3", "3 5 6 4 2 1 3 5 7 6 4 2 3 5 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO", "剪枝"], "title": "[USACO4.4] 棋盘游戏 Shuttle Puzzle", "background": null, "description": "大小为 $3$ 的棋盘游戏里有 $3$ 个白色棋子，$3$ 个黑色棋子，和一个有 $7$ 个格子一线排开的木盒子。$3$ 个白棋子被放在一头，$3$ 个黑棋子被放在另一头，中间的格子空着。\n- 初始状态：`WWW_BBB`（`_` 代表空格）\n- 目标状态：`BBB_WWW`\n\n在这个游戏里有两种移动方法是允许的：\n- 你可以把一个棋子移到与它相邻的空格；\n- 你可以把一个棋子跳过一个(仅一个)与它不同色的棋子到达空格。\n\n大小为 $N$ 的棋盘游戏包括 $N$ 个白棋子，$N$ 个黑棋子，还有有 $2N+1$ 个格子的木盒子。\n\n这里是大小为 $3$ 的棋盘游戏的解，包括初始状态，中间状态和目标状态：\n\n`WWW_BBB` $\\rightarrow$ `WW_WBBB` $\\rightarrow$ `WWBW_BB` $\\rightarrow$ `WWBWB_B` $\\rightarrow$ `WWB_BWB` $\\rightarrow$ `W_BWBWB` $\\rightarrow$ `_WBWBWB` $\\rightarrow$ `BW_WBWB` $\\rightarrow$ `BWBW_WB` $\\rightarrow$ `BWBWBW_` $\\rightarrow$ `BWBWB_W` $\\rightarrow$ `BWB_BWW` $\\rightarrow$ `B_BWBWW` $\\rightarrow$ `BB_WBWW` $\\rightarrow$ `BBBW_WW` $\\rightarrow$ `BBB_WWW`\n\n请编一个程序求解大小为 $N$ 的棋盘游戏（$1 \\le N \\le 12$）。要求用最少的移动步数实现。", "inputFormat": "一个正整数 $N$，表示棋盘游戏的大小。", "outputFormat": "输出用每一步移动的棋子移动前在棋盘的位置（位置从左到右依次为 $1,2,\\dots,2N+1$）表示的序列，每个数字之间以空格分隔，每行 $20$ 个数（最后一行可以少于 $20$ 个数）。\n\n输出的解还应当有最小的字典顺序，即如果有多组移动步数最小的解，输出第一个数最小的解；如果还有多组，输出第二个数最小的解，以此类推。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 4.3", "locale": "zh-CN", "translations": {"en": {"title": "[USACO4.4] Shuttle Puzzle", "background": "", "description": "In the shuttle puzzle of size $3$, there are $3$ white pieces, $3$ black pieces, and a wooden box with $7$ cells arranged in a line. The $3$ white pieces are placed on one end, the $3$ black pieces are placed on the other end, and the middle cell is empty.\n- Initial state: `WWW_BBB` (`_` represents the empty cell)\n- Goal state: `BBB_WWW`\n\nTwo types of moves are allowed in this game:\n- You may move a piece into the adjacent empty cell.\n- You may jump a piece over exactly one adjacent piece of the opposite color into the empty cell.\n\nThe shuttle puzzle of size $N$ has $N$ white pieces, $N$ black pieces, and a wooden box with $2N+1$ cells.\n\nHere is a solution for the size $3$ puzzle, including the initial state, intermediate states, and the goal state:\n\n`WWW_BBB` $\\rightarrow$ `WW_WBBB` $\\rightarrow$ `WWBW_BB` $\\rightarrow$ `WWBWB_B` $\\rightarrow$ `WWB_BWB` $\\rightarrow$ `W_BWBWB` $\\rightarrow$ `_WBWBWB` $\\rightarrow$ `BW_WBWB` $\\rightarrow$ `BWBW_WB` $\\rightarrow$ `BWBWBW_` $\\rightarrow$ `BWBWB_W` $\\rightarrow$ `BWB_BWW` $\\rightarrow$ `B_BWBWW` $\\rightarrow$ `BB_WBWW` $\\rightarrow$ `BBBW_WW` $\\rightarrow$ `BBB_WWW`\n\nWrite a program to solve the shuttle puzzle of size $N$ ($1 \\le N \\le 12$). The number of moves must be minimized.", "inputFormat": "A single integer $N$, the size of the shuttle puzzle.", "outputFormat": "Output the sequence of positions on the board of the piece to be moved before each move (positions are numbered from left to right as $1, 2, \\dots, 2N+1$). Print $20$ numbers per line (the last line may contain fewer than $20$ numbers).\n\nAmong all solutions with the minimum number of moves, the output should be lexicographically smallest, i.e., if there are multiple optimal solutions, choose the one with the smallest first number; if still tied, the smallest second number; and so on.", "hint": "Problem translation from NOCOW.\n\nUSACO Training Section 4.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO4.4] 棋盘游戏 Shuttle Puzzle", "background": null, "description": "大小为 $3$ 的棋盘游戏里有 $3$ 个白色棋子，$3$ 个黑色棋子，和一个有 $7$ 个格子一线排开的木盒子。$3$ 个白棋子被放在一头，$3$ 个黑棋子被放在另一头，中间的格子空着。\n- 初始状态：`WWW_BBB`（`_` 代表空格）\n- 目标状态：`BBB_WWW`\n\n在这个游戏里有两种移动方法是允许的：\n- 你可以把一个棋子移到与它相邻的空格；\n- 你可以把一个棋子跳过一个(仅一个)与它不同色的棋子到达空格。\n\n大小为 $N$ 的棋盘游戏包括 $N$ 个白棋子，$N$ 个黑棋子，还有有 $2N+1$ 个格子的木盒子。\n\n这里是大小为 $3$ 的棋盘游戏的解，包括初始状态，中间状态和目标状态：\n\n`WWW_BBB` $\\rightarrow$ `WW_WBBB` $\\rightarrow$ `WWBW_BB` $\\rightarrow$ `WWBWB_B` $\\rightarrow$ `WWB_BWB` $\\rightarrow$ `W_BWBWB` $\\rightarrow$ `_WBWBWB` $\\rightarrow$ `BW_WBWB` $\\rightarrow$ `BWBW_WB` $\\rightarrow$ `BWBWBW_` $\\rightarrow$ `BWBWB_W` $\\rightarrow$ `BWB_BWW` $\\rightarrow$ `B_BWBWW` $\\rightarrow$ `BB_WBWW` $\\rightarrow$ `BBBW_WW` $\\rightarrow$ `BBB_WWW`\n\n请编一个程序求解大小为 $N$ 的棋盘游戏（$1 \\le N \\le 12$）。要求用最少的移动步数实现。", "inputFormat": "一个正整数 $N$，表示棋盘游戏的大小。", "outputFormat": "输出用每一步移动的棋子移动前在棋盘的位置（位置从左到右依次为 $1,2,\\dots,2N+1$）表示的序列，每个数字之间以空格分隔，每行 $20$ 个数（最后一行可以少于 $20$ 个数）。\n\n输出的解还应当有最小的字典顺序，即如果有多组移动步数最小的解，输出第一个数最小的解；如果还有多组，输出第二个数最小的解，以此类推。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 4.3", "locale": "zh-CN"}}}
{"pid": "P2740", "type": "P", "difficulty": 5, "samples": [["5 4\r\n1 2 40\r\n1 4 20\r\n2 4 20\r\n2 3 30\r\n3 4 10", "50"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["USACO", "网络流"], "title": "[USACO4.2] 草地排水 Drainage Ditches", "background": "在农夫约翰的农场上，每逢下雨，贝茜最喜欢的三叶草地就积聚了一潭水。这意味着草地被水淹没了，并且小草要继续生长还要花相当长一段时间。因此，农夫约翰修建了一套排水系统来使贝茜的草地免除被大水淹没的烦恼（不用担心，雨水会流向附近的一条小溪）。作为一名一流的技师，农夫约翰已经在每条排水沟的一端安上了控制器，这样他可以控制流入排水沟的水流量。", "description": "FJ 知道每一条排水沟每分钟可以流过的水量，和排水系统的准确布局（起点为水潭而终点为小溪的一张网）。需要注意的是，有些时候从一处到另一处不只有一条排水沟。\n\n根据这些信息，计算从水潭排水到小溪的最大流量。对于给出的每条排水沟，雨水只能沿着一个方向流动，注意可能会出现雨水环形流动的情形。", "inputFormat": "第一行：两个用空格分开的整数 $N$（$0 \\le N \\le 200$）和 $M$（$2 \\le M \\le 200$）。$N$ 是 FJ 已经挖好的排水沟的数量，$M$ 是排水沟交叉点的数量。交点 $1$ 是水潭，交点 $M$ 是小溪。\n\n第二行到第 $N + 1$ 行：每行有三个整数 $S_i, E_i, C_i$。$S_i$ 和 $E_i$（$1 \\le S_i, E_i \\le M$）指明排水沟两端的交点，雨水从 $S_i$ 流向 $E_i$。$C_i$（$0 \\le C_i \\le 10^7$）是这条排水沟的最大容量。", "outputFormat": "输出一个整数，即排水的最大流量。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 4.2\n\n**【数据范围】**\n\n对于 $100 \\%$ 的数据，$0 \\le N, M \\le 200$，$0 \\le C_i \\le 10^7$。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO4.2] Drainage Ditches", "background": "On Farmer John's farm, whenever it rains, a pool of water accumulates on Bessie's favorite clover field. This means the field gets flooded, and it takes a long time for the grass to grow again. Therefore, Farmer John built a drainage system to keep Bessie's field from being flooded (do not worry, the rainwater will flow into a nearby creek). As a top-notch technician, Farmer John has installed a controller at one end of every ditch so that he can control the flow entering each ditch.", "description": "FJ knows the amount of water that can flow through each ditch per minute, as well as the exact layout of the drainage system (a network with the pond as the source and the creek as the sink). Note that between two places there may be more than one ditch.\n\nGiven this information, compute the maximum flow from the pond to the creek. For each ditch provided, water can flow in only one direction, and cycles may exist.", "inputFormat": "- The first line contains two space-separated integers $N$ ($0 \\le N \\le 200$) and $M$ ($2 \\le M \\le 200$). $N$ is the number of ditches that FJ has already dug, and $M$ is the number of junctions. Junction $1$ is the pond, and junction $M$ is the creek.\n- The second line to line $N + 1$: each line contains three integers $S_i, E_i, C_i$. $S_i$ and $E_i$ ($1 \\le S_i, E_i \\le M$) specify the two endpoints of a ditch, and water flows from $S_i$ to $E_i$. $C_i$ ($0 \\le C_i \\le 10^7$) is the maximum capacity of that ditch.", "outputFormat": "Output a single integer — the maximum drainage flow.", "hint": "The problem statement is translated from NOCOW.\n\nUSACO Training Section 4.2.\n\nConstraints\n\nFor $100\\%$ of the testdata, $0 \\le N, M \\le 200$, $0 \\le C_i \\le 10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO4.2] 草地排水 Drainage Ditches", "background": "在农夫约翰的农场上，每逢下雨，贝茜最喜欢的三叶草地就积聚了一潭水。这意味着草地被水淹没了，并且小草要继续生长还要花相当长一段时间。因此，农夫约翰修建了一套排水系统来使贝茜的草地免除被大水淹没的烦恼（不用担心，雨水会流向附近的一条小溪）。作为一名一流的技师，农夫约翰已经在每条排水沟的一端安上了控制器，这样他可以控制流入排水沟的水流量。", "description": "FJ 知道每一条排水沟每分钟可以流过的水量，和排水系统的准确布局（起点为水潭而终点为小溪的一张网）。需要注意的是，有些时候从一处到另一处不只有一条排水沟。\n\n根据这些信息，计算从水潭排水到小溪的最大流量。对于给出的每条排水沟，雨水只能沿着一个方向流动，注意可能会出现雨水环形流动的情形。", "inputFormat": "第一行：两个用空格分开的整数 $N$（$0 \\le N \\le 200$）和 $M$（$2 \\le M \\le 200$）。$N$ 是 FJ 已经挖好的排水沟的数量，$M$ 是排水沟交叉点的数量。交点 $1$ 是水潭，交点 $M$ 是小溪。\n\n第二行到第 $N + 1$ 行：每行有三个整数 $S_i, E_i, C_i$。$S_i$ 和 $E_i$（$1 \\le S_i, E_i \\le M$）指明排水沟两端的交点，雨水从 $S_i$ 流向 $E_i$。$C_i$（$0 \\le C_i \\le 10^7$）是这条排水沟的最大容量。", "outputFormat": "输出一个整数，即排水的最大流量。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 4.2\n\n**【数据范围】**\n\n对于 $100 \\%$ 的数据，$0 \\le N, M \\le 200$，$0 \\le C_i \\le 10^7$。", "locale": "zh-CN"}}}
{"pid": "P2741", "type": "P", "difficulty": 5, "samples": [["9 8\n.CCC....\nECBCBB..\nDCBCDB..\nDCCC.B..\nD.B.ABAA\nD.BBBB.A\nDDDDAD.A\nE...AAAA\nEEEEEE..", "EDABC"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["搜索", "USACO", "拓扑排序"], "title": "[USACO4.4] 重叠的图像 Frame Up", "background": null, "description": "看下面的五张 $9 \\times 8$ 的图像：\n\n```plain\n........   ........   ........   ........   .CCC....\nEEEEEE..   ........   ........   ..BBBB..   .C.C....\nE....E..   DDDDDD..   ........   ..B..B..   .C.C....\nE....E..   D....D..   ........   ..B..B..   .CCC....\nE....E..   D....D..   ....AAAA   ..B..B..   ........\nE....E..   D....D..   ....A..A   ..BBBB..   ........\nE....E..   DDDDDD..   ....A..A   ........   ........\nE....E..   ........   ....AAAA   ........   ........\nEEEEEE..   ........   ........   ........   ........\n\n   1          2           3          4          5\n```\n现在，把这些图像按照 $1\\sim 5$ 的编号从下到上重叠，第 $1$ 张在最下面，第 $5$ 张在最顶端。如果一张图像覆盖了另外一张图像，那么底下的图像的一部分就变得不可见了。于是我们得到下面的图像：\n\n```plain\n.CCC....\nECBCBB..\nDCBCDB..\nDCCC.B..\nD.B.ABAA\nD.BBBB.A\nDDDDAD.A\nE...AAAA\nEEEEEE..\n```\n对于这样一张图像，计算构成这张图像的矩形图像从底部到顶端堆叠的顺序。\n\n下面是这道题目的规则：\n\n矩形的边的宽度为 $1$，每条边的长度都不小于 $3$。\n\n矩形的每条边中，至少有一部分是可见的。注意，一个角同时属于两条边。\n\n矩形用大写字母表示，并且每个矩形的表示符号都不相同。", "inputFormat": "第一行，两个用空格分开的整数：图像高 $H$ 和图像宽 $W$（$3 \\le H,W \\le 30$）。\n\n第二行到第 $H+1$ 行，每行 $W$ 个字母：重叠后的图像。", "outputFormat": "按照自底向上的顺序输出字母。如果有不止一种情况，按照字典顺序输出每一种情况，且在两种情况之间输出一个换行。数据保证至少有一组解。\n\n保证解的组数不超过 $10000$。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 4.4", "locale": "zh-CN", "translations": {"en": {"title": "[USACO4.4] Frame Up", "background": "", "description": "Look at the following five $9 \\times 8$ images:\n\n```plain\n........   ........   ........   ........   .CCC....\nEEEEEE..   ........   ........   ..BBBB..   .C.C....\nE....E..   DDDDDD..   ........   ..B..B..   .C.C....\nE....E..   D....D..   ........   ..B..B..   .CCC....\nE....E..   D....D..   ....AAAA   ..B..B..   ........\nE....E..   D....D..   ....A..A   ..BBBB..   ........\nE....E..   DDDDDD..   ....A..A   ........   ........\nE....E..   ........   ....AAAA   ........   ........\nEEEEEE..   ........   ........   ........   ........\n\n   1          2           3          4          5\n```\nNow, stack these images from bottom to top in the order $1\\sim 5$, with image 1 at the bottom and image 5 at the top. If one image covers another, then part of the image underneath becomes invisible. This yields the following image:\n\n```plain\n.CCC....\nECBCBB..\nDCBCDB..\nDCCC.B..\nD.B.ABAA\nD.BBBB.A\nDDDDAD.A\nE...AAAA\nEEEEEE..\n```\nFor such an image, compute the stacking order of the rectangular images from bottom to top.\n\nThe rules are as follows:\n\n- The width of each rectangle border is $1$, and each side has length at least $3$.\n- For each rectangle, at least part of each of its four sides is visible. Note that a corner belongs to two sides.\n- Rectangles are denoted by uppercase letters, and the letter used for each rectangle is unique.", "inputFormat": "The first line contains two integers separated by a space: the image height $H$ and image width $W$ ($3 \\le H,W \\le 30$).\n\nThe next $H$ lines each contain $W$ letters: the final overlapped image.", "outputFormat": "Output the letters in order from bottom to top. If there is more than one valid ordering, output each ordering in lexicographic order, one per line. The testdata guarantees at least one solution. The number of solutions does not exceed $10000$.", "hint": "Translation from NOCOW.\n\nUSACO Training Section 4.4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO4.4] 重叠的图像 Frame Up", "background": null, "description": "看下面的五张 $9 \\times 8$ 的图像：\n\n```plain\n........   ........   ........   ........   .CCC....\nEEEEEE..   ........   ........   ..BBBB..   .C.C....\nE....E..   DDDDDD..   ........   ..B..B..   .C.C....\nE....E..   D....D..   ........   ..B..B..   .CCC....\nE....E..   D....D..   ....AAAA   ..B..B..   ........\nE....E..   D....D..   ....A..A   ..BBBB..   ........\nE....E..   DDDDDD..   ....A..A   ........   ........\nE....E..   ........   ....AAAA   ........   ........\nEEEEEE..   ........   ........   ........   ........\n\n   1          2           3          4          5\n```\n现在，把这些图像按照 $1\\sim 5$ 的编号从下到上重叠，第 $1$ 张在最下面，第 $5$ 张在最顶端。如果一张图像覆盖了另外一张图像，那么底下的图像的一部分就变得不可见了。于是我们得到下面的图像：\n\n```plain\n.CCC....\nECBCBB..\nDCBCDB..\nDCCC.B..\nD.B.ABAA\nD.BBBB.A\nDDDDAD.A\nE...AAAA\nEEEEEE..\n```\n对于这样一张图像，计算构成这张图像的矩形图像从底部到顶端堆叠的顺序。\n\n下面是这道题目的规则：\n\n矩形的边的宽度为 $1$，每条边的长度都不小于 $3$。\n\n矩形的每条边中，至少有一部分是可见的。注意，一个角同时属于两条边。\n\n矩形用大写字母表示，并且每个矩形的表示符号都不相同。", "inputFormat": "第一行，两个用空格分开的整数：图像高 $H$ 和图像宽 $W$（$3 \\le H,W \\le 30$）。\n\n第二行到第 $H+1$ 行，每行 $W$ 个字母：重叠后的图像。", "outputFormat": "按照自底向上的顺序输出字母。如果有不止一种情况，按照字典顺序输出每一种情况，且在两种情况之间输出一个换行。数据保证至少有一组解。\n\n保证解的组数不超过 $10000$。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 4.4", "locale": "zh-CN"}}}
{"pid": "P2742", "type": "P", "difficulty": 5, "samples": [["4\n4 8\n4 12\n5 9.3\n7 8", "12.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["计算几何", "USACO", "分治", "凸包", "模板题"], "title": "【模板】二维凸包 / [USACO5.1] 圈奶牛Fencing the Cows", "background": "upd: 新增一组 hack 数据。", "description": "农夫约翰想要建造一个围栏用来围住他的奶牛，可是他资金匮乏。他建造的围栏必须包括他的奶牛喜欢吃草的所有地点。对于给出的这些地点的坐标，计算最短的能够围住这些点的围栏的长度。", "inputFormat": "输入数据的第一行是一个整数。表示农夫约翰想要围住的放牧点的数目 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行两个实数，第 $(i + 1)$ 行的实数 $x_i, y_i$ 分别代表第 $i$ 个放牧点的横纵坐标。", "outputFormat": "输出输出一行一个四舍五入保留两位小数的实数，代表围栏的长度。\n", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^5$，$-10^6 \\leq x_i, y_i \\leq 10^6$。小数点后最多有 $2$ 位数字。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] 2D Convex Hull / [USACO5.1] Fencing the Cows", "background": "upd: Added a new set of hack testdata.", "description": "Farmer John wants to build a fence to enclose his cows, but his budget is limited. The fence he builds must include all the locations where his cows like to graze. Given the coordinates of these locations, compute the length of the shortest fence that can enclose all these points.", "inputFormat": "The first line contains an integer $n$, the number of grazing sites.\n\nFrom line $2$ to line $(n + 1)$, each line contains two real numbers. The real numbers $x_i, y_i$ on line $(i + 1)$ represent the $x$ and $y$ coordinates of the $i$-th grazing site.", "outputFormat": "Output one real number, rounded to two decimal places, representing the length of the fence.", "hint": "Constraints:\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 10^5$, $-10^6 \\leq x_i, y_i \\leq 10^6$. There are at most $2$ digits after the decimal point.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】二维凸包 / [USACO5.1] 圈奶牛Fencing the Cows", "background": "upd: 新增一组 hack 数据。", "description": "农夫约翰想要建造一个围栏用来围住他的奶牛，可是他资金匮乏。他建造的围栏必须包括他的奶牛喜欢吃草的所有地点。对于给出的这些地点的坐标，计算最短的能够围住这些点的围栏的长度。", "inputFormat": "输入数据的第一行是一个整数。表示农夫约翰想要围住的放牧点的数目 $n$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行两个实数，第 $(i + 1)$ 行的实数 $x_i, y_i$ 分别代表第 $i$ 个放牧点的横纵坐标。", "outputFormat": "输出输出一行一个四舍五入保留两位小数的实数，代表围栏的长度。\n", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^5$，$-10^6 \\leq x_i, y_i \\leq 10^6$。小数点后最多有 $2$ 位数字。", "locale": "zh-CN"}}}
{"pid": "P2743", "type": "P", "difficulty": 5, "samples": [["30\r\n25 27 30 34 39 45 52 60 69 79 69 60 52 45 39 34 30 26 22 18\r\n82 78 74 70 66 67 64 60 65 80", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}, "tags": ["动态规划 DP", "USACO"], "title": "[USACO5.1] 乐曲主题Musical Themes", "background": "", "description": "我们用 $N$（$1 \\le N \\le 5000$）个音符的序列来表示一首乐曲，每个音符都是 $1 \\sim 88$ 范围内的整数，每个数表示钢琴上的一个键。很不幸这种表示旋律的方法忽略了音符的时值，但这项编程任务是关于音高的，与时值无关。\n\n许多作曲家围绕一个重复出现的“主题”来构建乐曲。在我们的乐曲表示法中，“主题”是整个音符序列的一个子串，它需要满足如下条件：\n\n1. 长度至少为 $5$ 个音符。\n2. 在乐曲中重复出现（可能经过转调，见下）。\n3. 重复出现的同一主题不能有公共部分。\n\n“转调”的意思是主题序列中每个音符都被加上或减去了同一个整数值。给定一段乐曲，计算其中最长主题的长度（即音符数）。\n\n本题时限为 $1$ 秒钟！", "inputFormat": "输入文件的第一行包含整数 $N$。\n\n下面的每一行（最后一行可能除外）包含 $20$ 个整数，表示音符序列。\n\n最后一行可能少于 $20$ 个音符。", "outputFormat": "输出文件应只含一个整数，即最长主题的长度。如果乐曲中没有主题，那么输出 `0`。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 5.1\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO5.1] Musical Themes", "background": "", "description": "We represent a piece of music by a sequence of $N$ ($1 \\le N \\le 5000$) notes, each an integer in the range $1 \\sim 88$, where each number denotes a key on the piano. Unfortunately, this way of encoding a melody ignores note durations, but this programming task concerns pitch only and is independent of duration.\n\nMany composers build a piece around a recurring \"theme\". In our representation, a \"theme\" is a substring of the entire note sequence that satisfies the following conditions:\n1. Its length is at least $5$ notes.\n2. It appears repeatedly in the piece (possibly after transposition, see below).\n3. The repeated occurrences of the same theme must be non-overlapping.\n\n\"Transposition\" means that each note in the theme sequence is increased or decreased by the same integer. Given a piece, compute the length (number of notes) of the longest theme.\n\nThe time limit for this problem is $1$ second.", "inputFormat": "The first line of input contains the integer $N$.\n\nEach of the following lines (except possibly the last) contains $20$ integers representing the note sequence.\n\nThe last line may contain fewer than $20$ notes.", "outputFormat": "Output a single integer, the length of the longest theme. If there is no theme, output `0`.", "hint": "The statement is translated from NOCOW.\n\nUSACO Training Section 5.1.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO5.1] 乐曲主题Musical Themes", "background": "", "description": "我们用 $N$（$1 \\le N \\le 5000$）个音符的序列来表示一首乐曲，每个音符都是 $1 \\sim 88$ 范围内的整数，每个数表示钢琴上的一个键。很不幸这种表示旋律的方法忽略了音符的时值，但这项编程任务是关于音高的，与时值无关。\n\n许多作曲家围绕一个重复出现的“主题”来构建乐曲。在我们的乐曲表示法中，“主题”是整个音符序列的一个子串，它需要满足如下条件：\n\n1. 长度至少为 $5$ 个音符。\n2. 在乐曲中重复出现（可能经过转调，见下）。\n3. 重复出现的同一主题不能有公共部分。\n\n“转调”的意思是主题序列中每个音符都被加上或减去了同一个整数值。给定一段乐曲，计算其中最长主题的长度（即音符数）。\n\n本题时限为 $1$ 秒钟！", "inputFormat": "输入文件的第一行包含整数 $N$。\n\n下面的每一行（最后一行可能除外）包含 $20$ 个整数，表示音符序列。\n\n最后一行可能少于 $20$ 个音符。", "outputFormat": "输出文件应只含一个整数，即最长主题的长度。如果乐曲中没有主题，那么输出 `0`。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 5.1\n", "locale": "zh-CN"}}}
{"pid": "P2744", "type": "P", "difficulty": 5, "samples": [["16\r\n3\r\n3\r\n5\r\n7", "2 3 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "搜索", "USACO", "深度优先搜索 DFS"], "title": "[USACO5.3] 量取牛奶Milk Measuring", "background": "", "description": "农夫约翰要量取 $Q$（$1 \\le Q \\le 20,000$）夸脱（译注：即 quarts，容积单位）他的最好的牛奶，并把它装入一个大瓶子中卖出。消费者要多少，他就给多少，从不有任何误差。\n\n农夫约翰总是很节约。他现在在奶牛五金商店购买一些桶，用来从他的巨大的牛奶池中量出 $Q$ 夸脱的牛奶。每个桶的价格一样。你的任务是计算出一个农夫约翰可以购买的最少的桶的集合，使得能够刚好用这些桶量出 $Q$ 夸脱的牛奶。另外，由于农夫约翰必须把这些桶搬回家，对于给出的两个极小桶集合，他会选择“更小的”一个，即：把这两个集合按升序排序，比较第一个桶，选择第一个桶容积较小的一个。如果第一个桶相同，比较第二个桶，也按上面的方法选择。否则继续这样的工作，直到相比较的两个桶不一致为止。例如，集合 $\\{3,5,7,100\\}$ 比集合 $\\{3,6,7,8\\}$ 要好。\n\n为了量出牛奶，农夫约翰可以从牛奶池把桶装满，然后倒进瓶子。他决不把瓶子里的牛奶倒出来或者把桶里的牛奶倒到别处。用一个容积为 $1$ 夸脱的桶，农夫约翰可以只用这个桶量出所有可能的夸脱数。其它的桶的组合没有这么方便。\n\n计算需要购买的最佳桶集，保证所有的测试数据都至少有一个解。", "inputFormat": "第一行一个整数 $Q$。\n\n第二行一个整数 $P\\ (1 \\le  P \\le 100)$，表示商店里桶的数量。\n\n第 $3$ 至第 $P+2$ 行，每行一个整数 $h_i$ 表示第 $i$ 个桶的容积。$(1\\le h_i\\le 10^4)$。\n", "outputFormat": "输出文件只有一行，由空格分开的整数组成：\n\n为了量出想要的夸脱数，需要购买的最少的桶的数量，接着是：\n\n一个排好序的列表（从小到大），表示需要购买的每个桶的容积\n", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 5.3\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO5.3] Milk Measuring", "background": "", "description": "Farmer John wants to measure $Q$ (1 ≤ Q ≤ 20,000) quarts of his finest milk and put it into a large bottle to sell. He always gives exactly what the customer wants, without any error.\n\nFarmer John is very frugal. He is now buying some buckets at the cow hardware store to measure out $Q$ quarts from his huge pool of milk. Each bucket costs the same. Your task is to compute the smallest set of buckets he can buy such that, using only these buckets, he can measure exactly $Q$ quarts. Additionally, because he must carry them home, among two minimal bucket sets, he chooses the “smaller” one: sort both sets in ascending order, compare the first bucket; choose the set whose first bucket has the smaller capacity. If the first bucket is equal, compare the second, and so on, until they differ. For example, the set $\\{3,5,7,100\\}$ is better than the set $\\{3,6,7,8\\}$.\n\nTo measure the milk, Farmer John may fill a bucket from the pool and pour it into the bottle. He never pours milk out of the bottle, nor does he pour a bucket’s milk anywhere else. With a $1$-quart bucket, Farmer John can measure all possible numbers of quarts using only that bucket. Other bucket combinations are not so convenient.\n\nCompute the best set of buckets to purchase. It is guaranteed that all testdata have at least one solution.", "inputFormat": "The first line contains an integer $Q$.\n\nThe second line contains an integer $P$ (1 ≤ P ≤ 100), the number of buckets available in the store.\n\nLines $3$ through $P+2$ each contain an integer $h_i$ representing the capacity of the $i$-th bucket. $(1\\le h_i\\le 10^4)$.", "outputFormat": "Output exactly one line of space-separated integers:\n\nFirst, the minimum number of buckets needed to measure the desired number of quarts, followed by:\n\na sorted list (in increasing order) of the capacities of the buckets to purchase.", "hint": "Translation source: NOCOW.\n\nUSACO Training Section 5.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO5.3] 量取牛奶Milk Measuring", "background": "", "description": "农夫约翰要量取 $Q$（$1 \\le Q \\le 20,000$）夸脱（译注：即 quarts，容积单位）他的最好的牛奶，并把它装入一个大瓶子中卖出。消费者要多少，他就给多少，从不有任何误差。\n\n农夫约翰总是很节约。他现在在奶牛五金商店购买一些桶，用来从他的巨大的牛奶池中量出 $Q$ 夸脱的牛奶。每个桶的价格一样。你的任务是计算出一个农夫约翰可以购买的最少的桶的集合，使得能够刚好用这些桶量出 $Q$ 夸脱的牛奶。另外，由于农夫约翰必须把这些桶搬回家，对于给出的两个极小桶集合，他会选择“更小的”一个，即：把这两个集合按升序排序，比较第一个桶，选择第一个桶容积较小的一个。如果第一个桶相同，比较第二个桶，也按上面的方法选择。否则继续这样的工作，直到相比较的两个桶不一致为止。例如，集合 $\\{3,5,7,100\\}$ 比集合 $\\{3,6,7,8\\}$ 要好。\n\n为了量出牛奶，农夫约翰可以从牛奶池把桶装满，然后倒进瓶子。他决不把瓶子里的牛奶倒出来或者把桶里的牛奶倒到别处。用一个容积为 $1$ 夸脱的桶，农夫约翰可以只用这个桶量出所有可能的夸脱数。其它的桶的组合没有这么方便。\n\n计算需要购买的最佳桶集，保证所有的测试数据都至少有一个解。", "inputFormat": "第一行一个整数 $Q$。\n\n第二行一个整数 $P\\ (1 \\le  P \\le 100)$，表示商店里桶的数量。\n\n第 $3$ 至第 $P+2$ 行，每行一个整数 $h_i$ 表示第 $i$ 个桶的容积。$(1\\le h_i\\le 10^4)$。\n", "outputFormat": "输出文件只有一行，由空格分开的整数组成：\n\n为了量出想要的夸脱数，需要购买的最少的桶的数量，接着是：\n\n一个排好序的列表（从小到大），表示需要购买的每个桶的容积\n", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 5.3\n", "locale": "zh-CN"}}}
{"pid": "P2745", "type": "P", "difficulty": 5, "samples": [["w(a,10,132,20,12)\r\nw(b,8,76,124,15)\r\ns(a)", "49.167"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["USACO"], "title": "[USACO5.3] 窗体面积Window Area", "background": null, "description": "你刚刚接手一项窗体界面工程。窗体界面还算简单，而且幸运的是，你不必显示实际的窗体。有 $5$ 种基本操作：\n- 创建一个新窗体；\n- 将窗体置顶；\n- 将窗体置底；\n- 删除一个窗体；\n- 输出窗体可见部分的百分比（就是，不被其它窗体覆盖的部分）。", "inputFormat": "在输入文件中，操作（不超过 $600$ 个）以如下的格式出现，每行一个。\n\n- 创建一个新窗体：`w(I,x,y,X,Y)`；\n- 将窗体置顶：`t(I)`；\n- 将窗体置底：`b(I)`；\n- 删除一个窗体：`d(I)`；\n- 输出窗体可见部分的百分比：`s(I)`。\n\n`I` 是每个窗体唯一的标识符，标识符可以是大小写字母或单个数字字符。输入文件中没有多余的空格。\n\n$(x,y)$ 和 $(X,Y)$ 是窗体的对角。当你创建一个窗体的时候，它自动被“置顶”。你不能用已经存在的标识符来创建窗体，但是你可以删除一个窗体后再用已删除窗体的标识符来创建窗体。坐标用正整数来表示，并且所有的窗体面积都不为 $0$（即 $x\\ne X$ 且 $y\\ne Y$）。$x$ 坐标和 $y$ 坐标在 $[1,2^{15}-1]$ 的范围内。\n\n当输入文件结束时，停止程序。", "outputFormat": "只对于 `s(I)` 命令进行输出。当然，输入文件可能有许多 `s(I)` 命令（不超过 $500$ 次），所以输出文件应该是一个百分比的序列，每行一个，百分比是窗体可见部分的百分比。百分比应该四舍五入到三位小数（不用输出百分号 `%`）。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 5.3。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO5.3] Window Area", "background": "", "description": "You have just taken over a window system project. The window system is fairly simple, and fortunately, you do not have to display the actual windows. There are $5$ basic operations:\n- Create a new window.\n- Bring a window to the top.\n- Send a window to the bottom.\n- Delete a window.\n- Output the percentage of the window that is visible (i.e., not covered by other windows).", "inputFormat": "In the input file, operations (no more than $600$ of them) appear one per line in the following formats:\n\n- Create a new window: `w(I,x,y,X,Y)`.\n- Bring a window to the top: `t(I)`.\n- Send a window to the bottom: `b(I)`.\n- Delete a window: `d(I)`.\n- Output the percentage of the window that is visible: `s(I)`.\n\n$I$ is the unique identifier of each window. An identifier is a letter (uppercase or lowercase) or a single digit. There are no extra spaces in the input file.\n\n$(x,y)$ and $(X,Y)$ are opposite corners of the window. When you create a window, it is automatically placed on the top. You cannot create a window using an existing identifier, but after deleting a window you may reuse its identifier. Coordinates are positive integers, and every window has nonzero area (i.e., $x \\ne X$ and $y \\ne Y$). The $x$- and $y$-coordinates are in the range $[1,2^{15}-1]$.\n\nStop processing at end of file.", "outputFormat": "Produce output only for the `s(I)` commands. There may be many `s(I)` commands (no more than $500$). Output a sequence of percentages, one per line, each being the percentage of the window that is visible. Percentages must be rounded to three decimal places (do not print the percent sign `%`).", "hint": "Translation from NOCOW.\n\nUSACO Training Section 5.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO5.3] 窗体面积Window Area", "background": null, "description": "你刚刚接手一项窗体界面工程。窗体界面还算简单，而且幸运的是，你不必显示实际的窗体。有 $5$ 种基本操作：\n- 创建一个新窗体；\n- 将窗体置顶；\n- 将窗体置底；\n- 删除一个窗体；\n- 输出窗体可见部分的百分比（就是，不被其它窗体覆盖的部分）。", "inputFormat": "在输入文件中，操作（不超过 $600$ 个）以如下的格式出现，每行一个。\n\n- 创建一个新窗体：`w(I,x,y,X,Y)`；\n- 将窗体置顶：`t(I)`；\n- 将窗体置底：`b(I)`；\n- 删除一个窗体：`d(I)`；\n- 输出窗体可见部分的百分比：`s(I)`。\n\n`I` 是每个窗体唯一的标识符，标识符可以是大小写字母或单个数字字符。输入文件中没有多余的空格。\n\n$(x,y)$ 和 $(X,Y)$ 是窗体的对角。当你创建一个窗体的时候，它自动被“置顶”。你不能用已经存在的标识符来创建窗体，但是你可以删除一个窗体后再用已删除窗体的标识符来创建窗体。坐标用正整数来表示，并且所有的窗体面积都不为 $0$（即 $x\\ne X$ 且 $y\\ne Y$）。$x$ 坐标和 $y$ 坐标在 $[1,2^{15}-1]$ 的范围内。\n\n当输入文件结束时，停止程序。", "outputFormat": "只对于 `s(I)` 命令进行输出。当然，输入文件可能有许多 `s(I)` 命令（不超过 $500$ 次），所以输出文件应该是一个百分比的序列，每行一个，百分比是窗体可见部分的百分比。百分比应该四舍五入到三位小数（不用输出百分号 `%`）。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 5.3。", "locale": "zh-CN"}}}
{"pid": "P2746", "type": "P", "difficulty": 4, "samples": [["5\n2 4 3 0\n4 5 0\n0\n0\n1 0", "1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["USACO", "IOI", "强连通分量", "Tarjan", "1996"], "title": "[IOI 1996 / USACO5.3] 校园网 Network of Schools", "background": null, "description": "有一些学校会向其他学校分享软件，即如果这个学校得到了软件，那么在分享列表中的学校也会得到软件。注意这种关系是单向的，即如果 $a$ 在 $b$ 的列表中，那么 $b$ 不一定在 $a$ 的列表中。\n\n现在，你需要向其中一些学校下发新软件。为了节约下发软件的成本，你需要回答以下两个问题。\n1. 至少需要向几个学校下发新软件，可以使得所有学校均获得新软件。\n2. 定义一次扩展为在某个学校的分享列表中增加一个学校。至少需要进行几次扩展，才可以使得无论对哪个学校**仅下发一次软件**就可以使得所有学校获得新软件。\n\n两个问题相互独立。", "inputFormat": "输入文件的第一行包括一个正整数 $N$，表示学校数目。学校的编号为数字 $1$ 到 $N$。\n\n接下来 $N$ 行，每行都表示一个分享列表，第 $i+1$ 行为学校 $i$ 的分享列表中的学校编号。每个列表用 $0$ 结束，空列表只用一个 $0$ 表示。", "outputFormat": "你的程序应该在输出文件中输出两行。\n\n第一行应该包括一个正整数，表示问题 $1$ 的解。\n\n第二行应该包括一个非负整数，表示问题 $2$ 的解。", "hint": "$2 \\le N \\le 100$。\n\n题目翻译来自 NOCOW。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1996 / USACO5.3] Network of Schools", "background": "", "description": "Some schools share software with other schools; that is, if a school obtains the software, then all schools in its sharing list will also obtain the software. Note that this relation is directed: if $a$ is in $b$'s list, then $b$ is not necessarily in $a$'s list.\n\nNow you need to distribute new software to some of the schools. To minimize the distribution cost, answer the following two questions.\n1. What is the minimum number of schools to which you must distribute the software so that all schools obtain the new software?\n2. Define one expansion as adding one school to the sharing list of some school. What is the minimum number of expansions needed so that, no matter which single school you initially distribute the software to, all schools will obtain the new software?\n\nThe two questions are independent.", "inputFormat": "The first line of input contains a positive integer $N$, the number of schools. The schools are numbered from $1$ to $N$.\n\nEach of the next $N$ lines describes a sharing list. Line $i+1$ lists the school IDs in the sharing list of school $i$. Each list is terminated by a $0$; an empty list is represented by a single $0$.", "outputFormat": "Output two lines.\n\nThe first line should contain a positive integer, the answer to Question 1.\n\nThe second line should contain a non-negative integer, the answer to Question 2.", "hint": "Constraints: $2 \\le N \\le 100$.\n\nThis translation is from NOCOW.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1996 / USACO5.3] 校园网 Network of Schools", "background": null, "description": "有一些学校会向其他学校分享软件，即如果这个学校得到了软件，那么在分享列表中的学校也会得到软件。注意这种关系是单向的，即如果 $a$ 在 $b$ 的列表中，那么 $b$ 不一定在 $a$ 的列表中。\n\n现在，你需要向其中一些学校下发新软件。为了节约下发软件的成本，你需要回答以下两个问题。\n1. 至少需要向几个学校下发新软件，可以使得所有学校均获得新软件。\n2. 定义一次扩展为在某个学校的分享列表中增加一个学校。至少需要进行几次扩展，才可以使得无论对哪个学校**仅下发一次软件**就可以使得所有学校获得新软件。\n\n两个问题相互独立。", "inputFormat": "输入文件的第一行包括一个正整数 $N$，表示学校数目。学校的编号为数字 $1$ 到 $N$。\n\n接下来 $N$ 行，每行都表示一个分享列表，第 $i+1$ 行为学校 $i$ 的分享列表中的学校编号。每个列表用 $0$ 结束，空列表只用一个 $0$ 表示。", "outputFormat": "你的程序应该在输出文件中输出两行。\n\n第一行应该包括一个正整数，表示问题 $1$ 的解。\n\n第二行应该包括一个非负整数，表示问题 $2$ 的解。", "hint": "$2 \\le N \\le 100$。\n\n题目翻译来自 NOCOW。", "locale": "zh-CN"}}}
{"pid": "P2747", "type": "P", "difficulty": 5, "samples": [["8 9\nVancouver\nYellowknife\nEdmonton\nCalgary\nWinnipeg\nToronto\nMontreal\nHalifax\nVancouver Edmonton\nVancouver Calgary\nCalgary Winnipeg\nWinnipeg Toronto\nToronto Halifax\nMontreal Halifax\nEdmonton Montreal\nEdmonton Yellowknife\nEdmonton Calgary", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "搜索", "USACO"], "title": "[USACO5.4] 周游加拿大 Canada Tour", "background": null, "description": "你赢得了一场航空公司举办的比赛，奖品是一张加拿大环游机票。旅行在这家航空公司开放的最西边的城市开始，然后一直自西向东旅行，直到你到达最东边的城市，再由东向西返回，直到你回到开始的城市。除了旅行开始的城市之外，每个城市只能访问一次，因为开始的城市必定要被访问两次（在旅行的开始和结束）。\n\n当然不允许使用其他公司的航线或者用其他的交通工具。\n\n给出这个航空公司开放的城市的列表，和两两城市之间的直达航线列表。找出能够访问尽可能多的城市的路线，这条路线必须满足上述条件，也就是从列表中的第一个城市开始旅行，访问到列表中最后一个城市之后再返回第一个城市。", "inputFormat": "第 $1$ 行：航空公司开放的城市数 $N$ 和将要列出的直达航线的数量 $V$。$N$ 是一个不大于 $100$ 的正整数。$V$ 是任意的正整数。\n\n第 $2\\sim N+1$ 行：每行包括一个航空公司开放的城市名称。城市名称按照自西向东排列。不会出现两个城市在同一条经线上的情况。每个城市的名称都是一个字符串，最多 $15$ 字节，由拉丁字母表上的字母组成；城市名称中没有空格。\n\n第 $N+2\\sim N+2+V-1$ 行：每行包括两个城市名称（由上面列表中的城市名称组成），用一个空格分开。这样就表示两个城市之间的直达双程航线。", "outputFormat": "第 $1$ 行：按照最佳路线访问的不同城市的数量 $M$。如果无法找到路线，输出 `1`。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 5.4", "locale": "zh-CN", "translations": {"en": {"title": "[USACO5.4] Canada Tour", "background": "", "description": "You have won a contest held by an airline, and the prize is a ticket for a tour of Canada. The trip starts at the westernmost city served by this airline, then you keep traveling from west to east until you reach the easternmost city, and then travel from east to west back to the starting city. Except for the starting city, each city may be visited at most once, because the starting city must be visited twice (at the beginning and at the end).\n\nYou are not allowed to use flights of other airlines or any other means of transportation.\n\nGiven the list of cities served by this airline and the list of direct flights between pairs of cities, find a route that visits as many cities as possible while satisfying the above conditions. In other words, you must start from the first city in the list, reach the last city in the list, and then return to the first city.", "inputFormat": "Line $1$: The number of cities served by the airline $N$ and the number of direct flights to be listed $V$. $N$ is a positive integer not greater than $100$. $V$ is any positive integer.\n\nLines $2 \\sim N+1$: Each line contains the name of a city served by the airline. The cities are listed from west to east. No two cities lie on the same meridian. Each city name is a string of at most $15$ bytes, consisting of letters of the Latin alphabet; city names contain no spaces.\n\nLines $N+2 \\sim N+2+V-1$: Each line contains two city names (chosen from the list above), separated by a space, indicating a bidirectional direct flight between the two cities.", "outputFormat": "Line $1$: $M$, the number of distinct cities visited by the optimal route. If no route can be found, output `1`.", "hint": "The problem statement is translated from NOCOW.\nUSACO Training Section 5.4.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO5.4] 周游加拿大 Canada Tour", "background": null, "description": "你赢得了一场航空公司举办的比赛，奖品是一张加拿大环游机票。旅行在这家航空公司开放的最西边的城市开始，然后一直自西向东旅行，直到你到达最东边的城市，再由东向西返回，直到你回到开始的城市。除了旅行开始的城市之外，每个城市只能访问一次，因为开始的城市必定要被访问两次（在旅行的开始和结束）。\n\n当然不允许使用其他公司的航线或者用其他的交通工具。\n\n给出这个航空公司开放的城市的列表，和两两城市之间的直达航线列表。找出能够访问尽可能多的城市的路线，这条路线必须满足上述条件，也就是从列表中的第一个城市开始旅行，访问到列表中最后一个城市之后再返回第一个城市。", "inputFormat": "第 $1$ 行：航空公司开放的城市数 $N$ 和将要列出的直达航线的数量 $V$。$N$ 是一个不大于 $100$ 的正整数。$V$ 是任意的正整数。\n\n第 $2\\sim N+1$ 行：每行包括一个航空公司开放的城市名称。城市名称按照自西向东排列。不会出现两个城市在同一条经线上的情况。每个城市的名称都是一个字符串，最多 $15$ 字节，由拉丁字母表上的字母组成；城市名称中没有空格。\n\n第 $N+2\\sim N+2+V-1$ 行：每行包括两个城市名称（由上面列表中的城市名称组成），用一个空格分开。这样就表示两个城市之间的直达双程航线。", "outputFormat": "第 $1$ 行：按照最佳路线访问的不同城市的数量 $M$。如果无法找到路线，输出 `1`。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 5.4", "locale": "zh-CN"}}}
{"pid": "P2748", "type": "P", "difficulty": 5, "samples": [["4 100 200 1\n1 4\n2 3\n3 2\n4 0", "210"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["数学", "贪心", "2016", "USACO"], "title": "[USACO16OPEN] Landscaping P", "background": "*本题与 [2012 年 3 月月赛银组同名题目](/problem/P3049) 在题意上一致，唯一的差别是数据范围。*", "description": "Farmer John 打算修建一座花园，他需要移动不少泥土。\n\n花园由 $N$ 个花坛组成（$1 \\leq N \\leq 10^5$），其中花坛 $i$ 包含 $A_i$ 单位的泥土。FJ 希望花坛 $i$ 包含 $B_i$ 单位的泥土，保证 $0 \\leq A_i,B_i \\leq 10$。\n\n为了达到这个目标，他可以做这几件事情：\n\n- 购买一单位的泥土，放在指定的花坛中，费用为 $X$。\n- 从任意一个花坛中移走一单位泥土，费用为 $Y$。\n- 从花坛 $i$ 运送一单位泥土到花坛 $j$，费用为 $Z|i-j|$。\n\n请你帮 FJ 计算移动泥土的最小开销。", "inputFormat": "第一行四个整数 $N,X,Y,Z$（$0 \\leq X,Y \\leq 10^8$，$0 \\leq Z \\leq 1000$）。\n\n接下来 $N$ 行，第 $i$ 行两个整数 $A_i,B_i$。", "outputFormat": "输出移动泥土的最小开销。", "hint": "按下面的方案，最小花费为 $210$，可以证明不存在开销更小的方案。\n\n- 移除 $4$ 号花坛的一单位泥土，花费 $200$。\n- 将 $4$ 号花坛的三单位泥土移到 $1$ 号花坛，花费 $3 \\times 3=9$。\n- 将 $3$ 号花坛的一单位泥土移到 $2$ 号花坛，花费 $1 \\times 1=1$。", "locale": "zh-CN", "translations": {"zh-CN": {"title": "[USACO16OPEN] Landscaping P", "background": "*本题与 [2012 年 3 月月赛银组同名题目](/problem/P3049) 在题意上一致，唯一的差别是数据范围。*", "description": "Farmer John 打算修建一座花园，他需要移动不少泥土。\n\n花园由 $N$ 个花坛组成（$1 \\leq N \\leq 10^5$），其中花坛 $i$ 包含 $A_i$ 单位的泥土。FJ 希望花坛 $i$ 包含 $B_i$ 单位的泥土，保证 $0 \\leq A_i,B_i \\leq 10$。\n\n为了达到这个目标，他可以做这几件事情：\n\n- 购买一单位的泥土，放在指定的花坛中，费用为 $X$。\n- 从任意一个花坛中移走一单位泥土，费用为 $Y$。\n- 从花坛 $i$ 运送一单位泥土到花坛 $j$，费用为 $Z|i-j|$。\n\n请你帮 FJ 计算移动泥土的最小开销。", "inputFormat": "第一行四个整数 $N,X,Y,Z$（$0 \\leq X,Y \\leq 10^8$，$0 \\leq Z \\leq 1000$）。\n\n接下来 $N$ 行，第 $i$ 行两个整数 $A_i,B_i$。", "outputFormat": "输出移动泥土的最小开销。", "hint": "按下面的方案，最小花费为 $210$，可以证明不存在开销更小的方案。\n\n- 移除 $4$ 号花坛的一单位泥土，花费 $200$。\n- 将 $4$ 号花坛的三单位泥土移到 $1$ 号花坛，花费 $3 \\times 3=9$。\n- 将 $3$ 号花坛的一单位泥土移到 $2$ 号花坛，花费 $1 \\times 1=1$。", "locale": "zh-CN"}}}
{"pid": "P2749", "type": "P", "difficulty": 4, "samples": [["23\n15\n10001000000000010000000\n01111100011111000101101\n01000000010001000111111\n00000000010101000101111\n00000111010001000000000\n00001001011111000000000\n10000001000000000000000\n00101000000111110010000\n00001000000100010011111\n00000001110101010100010\n00000100110100010000000\n00010001110111110000000\n00100001110000000100000\n00001000100001000100101\n00000001110001000111000", "a000a0000000000b0000000\n0aaaaa000ccccc000d0dd0d\n0a0000000c000c000dddddd\n000000000c0b0c000d0dddd\n00000eee0c000c000000000\n0000e00e0ccccc000000000\nb000000e000000000000000\n00b0f000000ccccc00a0000\n0000f000000c000c00aaaaa\n0000000ddd0c0b0c0a000a0\n00000b00dd0c000c0000000\n000g000ddd0ccccc0000000\n00g0000ddd0000000e00000\n0000b000d0000f000e00e0b\n0000000ddd000f000eee000"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["1998", "USACO", "IOI", "枚举", "广度优先搜索 BFS"], "title": "[IOI 1998 / USACO5.1] 夜空繁星 Starry Night", "background": "高高的星空，簇簇闪耀的群星形态万千。一个星座 **(cluster)** 是一群连通的星组成的非空连通星系，这里的连通是指水平，垂直或者对角相邻的两个星星。一个星座不能是另一个更大星座的一部分，星座可以相似 **(similar)**。如果两个星座有相同的形状，而且包括相同数目的星体，那么不管其方向性如何，就算相似。一般而言，星座可能的方向有八个，如图 $1$ 所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/1970.png)", "description": "夜空可以表示为一份天体图 **(sky map)**，它是一个由字符 `0` 和 `1` 组成的二维矩阵，字符 `1` 表示所在的位置有一颗星；字符 `0` 表示该位置上是空的。\n\n给定一份天体图，用同一个小写英文标识 **(mark)** 相似的所有星座。\n\n相似的星座必须用相同的字母标识，不同的星座表示为不同的字母。标识一个星座，就是将其中各星体对应的字符 `1` 替换为相应的小写字母。", "inputFormat": "文件的前两行分别记录了天体图的宽度 $W$、深度 $H$。而天体图则是由接下来的 $H$ 行表示，每行包括 $W$ 个字符。", "outputFormat": "输出标记了星座后的天体图（与输入文件相似，不同之处在于，标识 **(mark)** 了各个星座）。\n\n对于同一个输入文件，可能会有很多不同的标识，此时，输出字典序最小的标识。", "hint": "### 样例解释\n\n此时的天体图是一个长 $23$ 宽 $15$ 的二维矩阵。\n\n输入对应 **(corresponds to)** 下面这个矩阵的图像。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1971.png) \n\n输出对应 **(corresponds to)** 下面的天空景象。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1972.png) \n\n### 数据范围\n\n- $0\\le$ 星空的长和宽 $\\le100$；\n- $0\\le$ 星座个数 $\\le500$；\n- $0\\le$ 不相似的星座个数 $\\le26$；\n- $1\\le$ 每个星座中星星个数 $\\le160$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1998 / USACO5.1] Starry Night", "background": "High in the night sky, clusters of shining stars form countless shapes. A cluster is a non-empty connected group of stars, where connectivity means two stars are adjacent horizontally, vertically, or diagonally (8-neighbor connectivity). A cluster cannot be part of a larger cluster. Clusters can be similar. If two clusters have the same shape and contain the same number of stars, then regardless of their orientation, they are considered similar. In general, there are eight possible orientations for a cluster, as shown in Figure $1$.\n\n![](https://cdn.luogu.com.cn/upload/pic/1970.png)", "description": "The night sky can be represented as a sky map, which is a 2D matrix of characters `0` and `1`. A character `1` indicates there is a star at that position; a character `0` indicates the position is empty.\n\nGiven a sky map, use the same lowercase English letter to mark all similar clusters.\n\nSimilar clusters must be marked with the same letter, and different clusters must be marked with different letters. To mark a cluster, replace each `1` corresponding to a star in that cluster with the appropriate lowercase letter.", "inputFormat": "The first two lines contain the width $W$ and the height $H$ of the sky map, respectively. The sky map then follows in the next $H$ lines, each containing $W$ characters.", "outputFormat": "Output the sky map after marking the clusters (in the same format as the input, except that clusters are marked).\n\nFor the same input, there may be many valid markings; in that case, output the lexicographically smallest marking.", "hint": "### Sample Explanation\n\nIn this case, the sky map is a 2D matrix with length $23$ and width $15$.\n\nThe input corresponds to the following image of the matrix.\n\n![](https://cdn.luogu.com.cn/upload/pic/1971.png)\n\nThe output corresponds to the following view of the night sky.\n\n![](https://cdn.luogu.com.cn/upload/pic/1972.png)\n\n### Constraints\n\n- $0 \\le$ the length and width of the sky map $\\le 100$.\n- $0 \\le$ the number of clusters $\\le 500$.\n- $0 \\le$ the number of dissimilar clusters $\\le 26$.\n- $1 \\le$ the number of stars in each cluster $\\le 160$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1998 / USACO5.1] 夜空繁星 Starry Night", "background": "高高的星空，簇簇闪耀的群星形态万千。一个星座 **(cluster)** 是一群连通的星组成的非空连通星系，这里的连通是指水平，垂直或者对角相邻的两个星星。一个星座不能是另一个更大星座的一部分，星座可以相似 **(similar)**。如果两个星座有相同的形状，而且包括相同数目的星体，那么不管其方向性如何，就算相似。一般而言，星座可能的方向有八个，如图 $1$ 所示。\n\n![](https://cdn.luogu.com.cn/upload/pic/1970.png)", "description": "夜空可以表示为一份天体图 **(sky map)**，它是一个由字符 `0` 和 `1` 组成的二维矩阵，字符 `1` 表示所在的位置有一颗星；字符 `0` 表示该位置上是空的。\n\n给定一份天体图，用同一个小写英文标识 **(mark)** 相似的所有星座。\n\n相似的星座必须用相同的字母标识，不同的星座表示为不同的字母。标识一个星座，就是将其中各星体对应的字符 `1` 替换为相应的小写字母。", "inputFormat": "文件的前两行分别记录了天体图的宽度 $W$、深度 $H$。而天体图则是由接下来的 $H$ 行表示，每行包括 $W$ 个字符。", "outputFormat": "输出标记了星座后的天体图（与输入文件相似，不同之处在于，标识 **(mark)** 了各个星座）。\n\n对于同一个输入文件，可能会有很多不同的标识，此时，输出字典序最小的标识。", "hint": "### 样例解释\n\n此时的天体图是一个长 $23$ 宽 $15$ 的二维矩阵。\n\n输入对应 **(corresponds to)** 下面这个矩阵的图像。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1971.png) \n\n输出对应 **(corresponds to)** 下面的天空景象。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1972.png) \n\n### 数据范围\n\n- $0\\le$ 星空的长和宽 $\\le100$；\n- $0\\le$ 星座个数 $\\le500$；\n- $0\\le$ 不相似的星座个数 $\\le26$；\n- $1\\le$ 每个星座中星星个数 $\\le160$。", "locale": "zh-CN"}}}
{"pid": "P2750", "type": "P", "difficulty": 6, "samples": [["N\n2", "ABCDEFGHIJKLMNOPQRSUTVWXY"], ["W \nABCDEFGHIJKLMNOPQRSUTVWXY", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2001", "USACO", "IOI", "深度优先搜索 DFS"], "title": "[IOI 2001 / USACO5.5] 贰五语言 Two Five", "background": null, "description": "有一种奇怪的语言叫做“贰五语言”。它的每个单词都由 `A` 至 `Y` 这 $25$ 个字母各一个组成。但是，并不是任何一种排列都是一个合法的贰五语言单词。贰五语言的单词必须满足这样一个条件：把它的 $25$ 个字母排成一个 $5\\times 5$ 的矩阵，它的每一行和每一列都必须是递增的。比如单词 `ACEPTBDHQUFJMRWGKNSXILOVY`，它排成的矩阵如下所示：\n```plain\nACEPT\nBDHQU\nFJMRW\nGKNSX\nILOVY\n```\n\n因为它的每行每列都是递增的，所以它是一个合法的单词。而单词 `YXWVUTSRQPONMLKJIHGFEDCBA` 则显然不合法。由于单词太长存储不便，需要给每一个单词编一个码。编码方法如下：从左到右，再从上到下，可以由一个矩阵的得到一个单词，再把单词按照字典顺序排序。比如，单词 `ABCDEFGHIJKLMNOPQRSTUVWXY` 的编码为 $1$，而单词 `ABCDEFGHIJKLMNOPQRSUTVWXY` 的编码为 $2$。\n\n现在，你需要编一个程序，完成单词与编码间的转换。", "inputFormat": "第一行为一个字母 `N` 或 `W`。`N` 表示把编码转换为单词，`W` 表示把单词转换为编码。\n\n若第一行为 `N`，则第二行为一个整数，表示单词的编码。若第一行为 `W`，则第二行为一个合法的单词。", "outputFormat": "每行一个整数或单词。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 5.5。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2001 / USACO5.5] Two Five", "background": "", "description": "There is a strange language called the “Two Five” language. Each of its words consists of exactly one of each of the 25 letters from `A` to `Y`. However, not every permutation is a valid word in this language. A word is valid if, when its 25 letters are arranged into a $5\\times 5$ matrix, every row and every column is strictly increasing. For example, the word `ACEPTBDHQUFJMRWGKNSXILOVY` forms the following matrix:\n```plain\nACEPT\nBDHQU\nFJMRW\nGKNSX\nILOVY\n```\nSince every row and column is strictly increasing, it is a valid word. The word `YXWVUTSRQPONMLKJIHGFEDCBA` is clearly invalid.\n\nBecause words are too long to store conveniently, we assign a code to each word. The coding method is as follows: read a matrix from left to right and then from top to bottom to obtain a word; then sort the words in lexicographic order. For example, the word `ABCDEFGHIJKLMNOPQRSTUVWXY` has code $1$, and the word `ABCDEFGHIJKLMNOPQRSUTVWXY` has code $2$.\n\nNow you need to write a program to convert between words and their codes.", "inputFormat": "The first line contains a letter `N` or `W`. `N` means converting a code to a word, and `W` means converting a word to a code.\n\nIf the first line is `N`, then the second line contains an integer representing the word’s code. If the first line is `W`, then the second line contains a valid word.", "outputFormat": "Each line contains one integer or word.", "hint": "The statement is translated from NOCOW.\n\nUSACO Training Section 5.5.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2001 / USACO5.5] 贰五语言 Two Five", "background": null, "description": "有一种奇怪的语言叫做“贰五语言”。它的每个单词都由 `A` 至 `Y` 这 $25$ 个字母各一个组成。但是，并不是任何一种排列都是一个合法的贰五语言单词。贰五语言的单词必须满足这样一个条件：把它的 $25$ 个字母排成一个 $5\\times 5$ 的矩阵，它的每一行和每一列都必须是递增的。比如单词 `ACEPTBDHQUFJMRWGKNSXILOVY`，它排成的矩阵如下所示：\n```plain\nACEPT\nBDHQU\nFJMRW\nGKNSX\nILOVY\n```\n\n因为它的每行每列都是递增的，所以它是一个合法的单词。而单词 `YXWVUTSRQPONMLKJIHGFEDCBA` 则显然不合法。由于单词太长存储不便，需要给每一个单词编一个码。编码方法如下：从左到右，再从上到下，可以由一个矩阵的得到一个单词，再把单词按照字典顺序排序。比如，单词 `ABCDEFGHIJKLMNOPQRSTUVWXY` 的编码为 $1$，而单词 `ABCDEFGHIJKLMNOPQRSUTVWXY` 的编码为 $2$。\n\n现在，你需要编一个程序，完成单词与编码间的转换。", "inputFormat": "第一行为一个字母 `N` 或 `W`。`N` 表示把编码转换为单词，`W` 表示把单词转换为编码。\n\n若第一行为 `N`，则第二行为一个整数，表示单词的编码。若第一行为 `W`，则第二行为一个合法的单词。", "outputFormat": "每行一个整数或单词。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 5.5。", "locale": "zh-CN"}}}
{"pid": "P2751", "type": "P", "difficulty": 5, "samples": [["5 2 3\n1 1 3 1 4", "3 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "贪心", "USACO", "IOI", "枚举", "1996"], "title": "[IOI 1996 / USACO4.2] 工序安排 Job Processing", "background": null, "description": "一家工厂的流水线正在生产一种产品，这需要两种操作：操作 $A$ 和操作 $B$。每个操作只有一些机器能够完成。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1968.png) \n\n上图显示了按照下述方式工作的流水线的组织形式。$A$ 型机器从输入库接受工件，对其施加操作 $A$，得到的中间产品存放在缓冲库。$B$ 型机器从缓冲库接受中间产品，对其施加操作 $B$，得到的最终产品存放在输出库。所有的机器平行并且独立地工作，每个库的容量没有限制。每台机器的工作效率可能不同，一台机器完成一次操作需要一定的时间。\n\n给出每台机器完成一次操作的时间，计算完成 $A$ 操作的最晚时间点的最小值，和完成 $B$ 操作的最晚时间点的最小值。\n\n注：\n1. 机器在一次操作中干掉一个工件；", "inputFormat": "第一行：三个用空格分开的整数：$N$，工件数量（$1\\leq N\\leq1000$）；$M_1$，$A$ 型机器的数量（$1\\leq M_1\\leq30$）；$M_2$，$B$ 型机器的数量（$1\\leq M_2\\leq30$）。\n\n第二行：$M_1$ 个整数，表示 $A$ 型机器完成一次操作的时间；接着是 $M_2$ 个整数，$B$ 型机器完成一次操作的时间。（所有 $A$ 型机器与 $B$ 型机器完成一次操作的时间均为 $[1,20]$ 内的整数）", "outputFormat": "只有一行。输出两个整数：完成所有 $A$ 操作的最晚时间点的最小值，和完成所有 $B$ 操作的最晚时间点的最小值（$A$ 操作必须在 $B$ 操作之前完成）。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 4.2", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 1996 / USACO4.2] Job Processing", "background": "", "description": "A factory production line is producing a product that requires two types of operations: operation $A$ and operation $B$. Only some machines can perform each operation.\n\n![](https://cdn.luogu.com.cn/upload/pic/1968.png)\n\nThe figure above shows the organization of a production line operating as described below. $A$-type machines take workpieces from the input buffer, apply operation $A$, and store the resulting intermediate products in the buffer. $B$-type machines take intermediate products from the buffer, apply operation $B$, and store the final products in the output buffer. All machines work in parallel and independently, and each buffer has unlimited capacity. Each machine may have a different efficiency; a machine requires a fixed amount of time to complete one operation.\n\nGiven the processing time of each machine for one operation, compute the minimal total time to finish all $A$ operations, and the minimal total time to finish all $B$ operations.\n\nNote:\n1. In one operation, a machine processes exactly one workpiece.\n2. “Total time” means the latest finishing time (makespan).", "inputFormat": "The first line contains three space-separated integers: $N$, the number of workpieces ($1 \\leq N \\leq 1000$); $M_1$, the number of $A$-type machines ($1 \\leq M_1 \\leq 30$); $M_2$, the number of $B$-type machines ($1 \\leq M_2 \\leq 30$).\n\nThe second line contains $M_1$ integers, the time each $A$-type machine takes to complete one operation; followed by $M_2$ integers, the time each $B$-type machine takes to complete one operation. All operation times for $A$-type and $B$-type machines are integers in $[1, 20]$.", "outputFormat": "Output a single line with two integers: the minimal total time to complete all $A$ operations, and the minimal total time to complete all $B$ operations ($A$ operations must be completed before $B$ operations).", "hint": "Problem translation from NOCOW.\n\nUSACO Training Section 4.2.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 1996 / USACO4.2] 工序安排 Job Processing", "background": null, "description": "一家工厂的流水线正在生产一种产品，这需要两种操作：操作 $A$ 和操作 $B$。每个操作只有一些机器能够完成。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1968.png) \n\n上图显示了按照下述方式工作的流水线的组织形式。$A$ 型机器从输入库接受工件，对其施加操作 $A$，得到的中间产品存放在缓冲库。$B$ 型机器从缓冲库接受中间产品，对其施加操作 $B$，得到的最终产品存放在输出库。所有的机器平行并且独立地工作，每个库的容量没有限制。每台机器的工作效率可能不同，一台机器完成一次操作需要一定的时间。\n\n给出每台机器完成一次操作的时间，计算完成 $A$ 操作的最晚时间点的最小值，和完成 $B$ 操作的最晚时间点的最小值。\n\n注：\n1. 机器在一次操作中干掉一个工件；", "inputFormat": "第一行：三个用空格分开的整数：$N$，工件数量（$1\\leq N\\leq1000$）；$M_1$，$A$ 型机器的数量（$1\\leq M_1\\leq30$）；$M_2$，$B$ 型机器的数量（$1\\leq M_2\\leq30$）。\n\n第二行：$M_1$ 个整数，表示 $A$ 型机器完成一次操作的时间；接着是 $M_2$ 个整数，$B$ 型机器完成一次操作的时间。（所有 $A$ 型机器与 $B$ 型机器完成一次操作的时间均为 $[1,20]$ 内的整数）", "outputFormat": "只有一行。输出两个整数：完成所有 $A$ 操作的最晚时间点的最小值，和完成所有 $B$ 操作的最晚时间点的最小值（$A$ 操作必须在 $B$ 操作之前完成）。", "hint": "题目翻译来自 NOCOW。\n\nUSACO Training Section 4.2", "locale": "zh-CN"}}}
{"pid": "P2752", "type": "P", "difficulty": 3, "samples": [["1 2 -2\n3 -2\n3 -2\n5 4 -2\n6 4 -2\n6 -2\n7 8 -2\n9 -2\n5 9 -2\n-2\n-1", "2 3 6\n1 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["USACO", "枚举", "广度优先搜索 BFS", "Tarjan"], "title": "[USACO4.3] 街道赛跑Street Race", "background": "", "description": "图一表示一次街道赛跑的跑道。可以看出有一些路口（用 $0$ 到 $N$ 的整数标号），和连接这些路口的箭头。路口 $0$ 是跑道的起点，路口 $N$ 是跑道的终点。箭头表示单行道。运动员们可以顺着街道从一个路口移动到另一个路口（只能按照箭头所指的方向）。当运动员处于路口位置时，他可以选择任意一条由这个路口引出的街道。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1967.png) \n\n图一：有 $10$ 个路口的街道\n\n一个良好的跑道具有如下几个特点：\n\n1. 每一个路口都可以由起点到达。\n2. 从任意一个路口都可以到达终点。\n3. 终点不通往任何路口。\n\n运动员不必经过所有的路口来完成比赛。有些路口却是选择任意一条路线都必须到达的（称为“不可避免”的）。在上面的例子中，这些路口是 $0$，$3$，$6$，$9$。对于给出的良好的跑道，你的程序要确定“不可避免”的路口的集合，不包括起点和终点。\n\n假设比赛要分两天进行。为了达到这个目的，原来的跑道必须分为两个跑道，每天使用一个跑道。第一天，起点为路口 $0$，终点为一个“中间路口”；第二天，起点是那个中间路口，而终点为路口 $N$。对于给出的良好的跑道，你的程序要确定“中间路口”的集合。如果良好的跑道 $C$ 可以被路口 $S$ 分成两部分，这两部分都是良好的，并且 $S$ 不同于起点也不同于终点，同时被分割的两个部分满足下列条件：（1）它们之间没有共同的街道（2）$S$ 为它们唯一的公共点，并且 $S$ 作为其中一个的终点和另外一个的起点。那么我们称 $S$ 为“中间路口 ”。在例子中只有路口 $3$ 是中间路口。", "inputFormat": "输入文件包括一个良好的跑道，最多有 $50$ 个路口，$100$ 条单行道。\n\n共有 $N+2$ 行，前面 $N+1$ 行中第 $i$ 行表示以编号为 $i-1$ 的路口作为起点的街道，每个数字表示一个终点。行末用 `-2` 作为结束。最后一行只有一个数字 `-1`。", "outputFormat": "第一行：跑道中“不可避免的路口”的数量，接着是这些路口的序号，序号按照升序排列。\n\n第二行：跑道中“中间路口”的数量，接着是这些路口的序号，序号按照升序排列。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 4.3\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO4.3] Street Race", "background": "", "description": "Figure 1 shows a course for a street race. There are several intersections (labeled by the integers from $0$ to $N$) and arrows that connect these intersections. Intersection $0$ is the start, and intersection $N$ is the finish. The arrows indicate one-way streets. Runners can move from one intersection to another along the streets (only in the direction of the arrows). When a runner is at an intersection, they may choose any outgoing street from that intersection.\n\n ![](https://cdn.luogu.com.cn/upload/pic/1967.png) \n\nFigure 1: A street with $10$ intersections.\n\nA valid course has the following properties:\n1. Every intersection is reachable from the start.\n2. The finish is reachable from any intersection.\n3. The finish has no outgoing streets.\n\nRunners do not have to pass through all intersections to complete the race. However, some intersections must be passed on every possible route (called \"unavoidable\"). In the example above, these intersections are $0$, $3$, $6$, $9$. For a given valid course, your program must determine the set of unavoidable intersections, excluding the start and the finish.\n\nAssume the race is to be held over two days. To achieve this, the original course must be split into two courses, one for each day. On day 1, the start is intersection $0$ and the finish is an \"intermediate intersection\"; on day 2, the start is that intermediate intersection and the finish is intersection $N$. For a given valid course, your program must determine the set of \"splitting points\". If a valid course $C$ can be divided by an intersection $S$ into two parts that are both valid, $S$ is different from both the start and the finish, and the two parts satisfy the following conditions: (1) they share no streets; (2) their only common point is $S$, with $S$ serving as the finish of one and the start of the other; then $S$ is called a \"splitting point\". In the example, only intersection $3$ is a splitting point.", "inputFormat": "The input describes a valid course with at most $50$ intersections and $100$ one-way streets.\n\nThere are $N+2$ lines. In the first $N+1$ lines, line $i$ lists the streets that start from the intersection numbered $i-1$, and each number denotes a destination. Each line ends with `-2`. The last line contains a single number `-1`.", "outputFormat": "The first line: the number of unavoidable intersections, followed by their indices in increasing order.\n\nThe second line: the number of splitting points, followed by their indices in increasing order.", "hint": "Problem translation from NOCOW.\n\nUSACO Training Section 4.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO4.3] 街道赛跑Street Race", "background": "", "description": "图一表示一次街道赛跑的跑道。可以看出有一些路口（用 $0$ 到 $N$ 的整数标号），和连接这些路口的箭头。路口 $0$ 是跑道的起点，路口 $N$ 是跑道的终点。箭头表示单行道。运动员们可以顺着街道从一个路口移动到另一个路口（只能按照箭头所指的方向）。当运动员处于路口位置时，他可以选择任意一条由这个路口引出的街道。\n\n ![](https://cdn.luogu.com.cn/upload/pic/1967.png) \n\n图一：有 $10$ 个路口的街道\n\n一个良好的跑道具有如下几个特点：\n\n1. 每一个路口都可以由起点到达。\n2. 从任意一个路口都可以到达终点。\n3. 终点不通往任何路口。\n\n运动员不必经过所有的路口来完成比赛。有些路口却是选择任意一条路线都必须到达的（称为“不可避免”的）。在上面的例子中，这些路口是 $0$，$3$，$6$，$9$。对于给出的良好的跑道，你的程序要确定“不可避免”的路口的集合，不包括起点和终点。\n\n假设比赛要分两天进行。为了达到这个目的，原来的跑道必须分为两个跑道，每天使用一个跑道。第一天，起点为路口 $0$，终点为一个“中间路口”；第二天，起点是那个中间路口，而终点为路口 $N$。对于给出的良好的跑道，你的程序要确定“中间路口”的集合。如果良好的跑道 $C$ 可以被路口 $S$ 分成两部分，这两部分都是良好的，并且 $S$ 不同于起点也不同于终点，同时被分割的两个部分满足下列条件：（1）它们之间没有共同的街道（2）$S$ 为它们唯一的公共点，并且 $S$ 作为其中一个的终点和另外一个的起点。那么我们称 $S$ 为“中间路口 ”。在例子中只有路口 $3$ 是中间路口。", "inputFormat": "输入文件包括一个良好的跑道，最多有 $50$ 个路口，$100$ 条单行道。\n\n共有 $N+2$ 行，前面 $N+1$ 行中第 $i$ 行表示以编号为 $i-1$ 的路口作为起点的街道，每个数字表示一个终点。行末用 `-2` 作为结束。最后一行只有一个数字 `-1`。", "outputFormat": "第一行：跑道中“不可避免的路口”的数量，接着是这些路口的序号，序号按照升序排列。\n\n第二行：跑道中“中间路口”的数量，接着是这些路口的序号，序号按照升序排列。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 4.3\n", "locale": "zh-CN"}}}
{"pid": "P2753", "type": "P", "difficulty": 5, "samples": [["prmgroa\nprofile\nprogram\nprom\nrag\nram\nrom\n.", "24\nprogram\nprom rag"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["USACO"], "title": "[USACO4.3] 字母游戏 Letter Game", "background": null, "description": "给定 $3 \\sim 7$ 张卡片和不超过 $4 \\times 10^4$ 个合法单词，请用卡片拼出（每张卡片只能用一次）一个或多个（即“词组”）合法单词，使得用到的卡片的价值之和最大，并输出所有方案。\n\n卡片的价值取决于卡片上的字母，其对应关系如下：\n\n```plain\n[Letter]  a b c d e f g h i j k l m n o p q r s t u v w x y z\n[Value]   2 5 4 4 1 6 5 5 1 7 6 3 5 2 3 5 7 2 1 2 4 6 6 7 5 7\n```\n\n![](https://cdn.luogu.com.cn/upload/pic/1969.png)", "inputFormat": "第一行 $3 \\sim 7$ 个小写字母，表示你手上的每张卡片都写着哪个字母。\n\n下面不超过 $4 \\times 10^4+1$ 行，每行 $3 \\sim 7$ 个小写字母表示一个合法单词，以 `.` 作为输入结束标志。\n\n保证所有合法单词不重复且按字典序升序给出。", "outputFormat": "第一行输出一个整数表示最大得分。\n\n下面若干行（按字典序升序排序），每行若干个单词（同样按字典序升序排序），表示每个最优解中拼出的单词或词组。\n\n两个只有单词出现顺序不同的词组应算作同一个词组，此时你应该按字典序升序输出该词组中的每个单词。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 4.3。", "locale": "zh-CN", "translations": {"en": {"title": "[USACO4.3] Letter Game", "background": "", "description": "Given $3 \\sim 7$ cards and at most $4 \\times 10^4$ valid words, use the cards to form one or more valid words (i.e., a \"phrase\"), where each card can be used at most once, so that the sum of the values of the cards used is maximized, and output all optimal solutions.\n\nThe value of a card depends on the letter on it; the correspondence is as follows:\n\n```plain\n[Letter]  a b c d e f g h i j k l m n o p q r s t u v w x y z\n[Value]   2 5 4 4 1 6 5 5 1 7 6 3 5 2 3 5 7 2 1 2 4 6 6 7 5 7\n```\n\n![](https://cdn.luogu.com.cn/upload/pic/1969.png)", "inputFormat": "The first line contains $3 \\sim 7$ lowercase letters, indicating the letters on your cards.\n\nThe next up to $4 \\times 10^4 + 1$ lines each contain $3 \\sim 7$ lowercase letters representing a valid word, with `.` as the end-of-input marker.\n\nAll valid words are guaranteed to be distinct and given in ascending lexicographic order.", "outputFormat": "On the first line, output an integer representing the maximum score.\n\nThen output several lines (sorted in ascending lexicographic order). Each line contains one or more words (also sorted in ascending lexicographic order), representing the word or \"phrase\" formed in each optimal solution.\n\nTwo phrases that differ only in the order of words should be considered the same phrase. In that case, you should output the words within that phrase in ascending lexicographic order.", "hint": "The problem statement translation is from NOCOW.\n\nUSACO Training Section 4.3.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO4.3] 字母游戏 Letter Game", "background": null, "description": "给定 $3 \\sim 7$ 张卡片和不超过 $4 \\times 10^4$ 个合法单词，请用卡片拼出（每张卡片只能用一次）一个或多个（即“词组”）合法单词，使得用到的卡片的价值之和最大，并输出所有方案。\n\n卡片的价值取决于卡片上的字母，其对应关系如下：\n\n```plain\n[Letter]  a b c d e f g h i j k l m n o p q r s t u v w x y z\n[Value]   2 5 4 4 1 6 5 5 1 7 6 3 5 2 3 5 7 2 1 2 4 6 6 7 5 7\n```\n\n![](https://cdn.luogu.com.cn/upload/pic/1969.png)", "inputFormat": "第一行 $3 \\sim 7$ 个小写字母，表示你手上的每张卡片都写着哪个字母。\n\n下面不超过 $4 \\times 10^4+1$ 行，每行 $3 \\sim 7$ 个小写字母表示一个合法单词，以 `.` 作为输入结束标志。\n\n保证所有合法单词不重复且按字典序升序给出。", "outputFormat": "第一行输出一个整数表示最大得分。\n\n下面若干行（按字典序升序排序），每行若干个单词（同样按字典序升序排序），表示每个最优解中拼出的单词或词组。\n\n两个只有单词出现顺序不同的词组应算作同一个词组，此时你应该按字典序升序输出该词组中的每个单词。", "hint": "题目翻译来自NOCOW。\n\nUSACO Training Section 4.3。", "locale": "zh-CN"}}}
{"pid": "P2754", "type": "P", "difficulty": 6, "samples": [["2 2 1\n1 3 0 1 2\n1 3 1 2 -1\n", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["1999", "网络流", "O2优化", "网络流与线性规划 24 题", "CTSC/CTS"], "title": "[CTSC1999] 家园 / 星际转移问题", "background": "", "description": "由于人类对自然资源的消耗，人们意识到大约在 2300 年之后，地球就不能再居住了。于是在月球上建立了新的绿地，以便在需要时移民。令人意想不到的是，2177 年冬由于未知的原因，地球环境发生了连锁崩溃，人类必须在最短的时间内迁往月球。\n\n现有 $n$ 个太空站位于地球与月球之间，且有 $m$ 艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而太空船的容量是有限的，第 $i$ 艘太空船只可容纳  $h_i$ 个人。每艘太空船将周期性地停靠一系列的太空站，例如 $(1,3,4)$ 表示该太空船将周期性地停靠太空站 $134134134\\dots$。每一艘太空船从一个太空站驶往任一太空站耗时均为 $1$。人们只能在太空船停靠太空站(或月球、地球)时上、下船。\n\n初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。", "inputFormat": "输入的第一行是三个用空格隔开的整数，分别代表太空站个数 $n$，太空船个数 $m$ 和地球上的人数 $k$。\n\n第 $2$ 到第 $(m + 1)$ 行，每行给出一艘太空船的信息，第 $(i + 1)$ 行的第一个整数 $h_i$ 代表第 $i$ 艘太空船可容纳的人数。随后有一个整数 $r_i$，代表第 $i$ 艘太空船停靠的站点数。之后有 $r_i$ 个整数，依次代表该太空船停靠站点的编号 $S_{i, j}$，其中太空站自 $1$ 至 $n$ 编号，地球编号为 $0$，月球编号为 $-1$。", "outputFormat": "输出一行一个整数，代表将所有人转移到月球上的最短用时。若无解则输出 $0$。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n\n- $1 \\leq n \\leq 13$。\n- $1 \\leq m \\leq 20$。\n- $1 \\leq k \\leq 50$。\n- $1 \\leq r_i \\leq n + 2$。\n- $-1 \\leq S_{i, j}\\leq n$。", "locale": "zh-CN", "translations": {"en": {"title": "[CTSC1999] Home / Interstellar Transfer Problem", "background": "", "description": "Due to humanity’s consumption of natural resources, people realized that around the year 2300, Earth would no longer be habitable. Therefore, new green zones were established on the Moon to enable migration when needed. Unexpectedly, in the winter of 2177, due to unknown reasons, Earth’s environment suffered a chain collapse, and humanity must migrate to the Moon as quickly as possible.\n\nThere are $n$ space stations located between Earth and the Moon, and there are $m$ public transport spacecraft shuttling back and forth among them. Each space station can hold an unlimited number of people, but each spacecraft has limited capacity: the $i$-th spacecraft can carry $h_i$ people. Each spacecraft periodically stops at a sequence of stations; for example, $(1,3,4)$ means the spacecraft will cyclically stop at stations $134134134\\dots$. It takes time $1$ for a spacecraft to travel from any station to any other station. People can board or disembark only when a spacecraft is docked at a station (or the Moon, or Earth).\n\nInitially, all people are on Earth, and all spacecraft are at their initial stops. Design an algorithm to find a transportation plan that transfers all people to the Moon in the shortest possible time.", "inputFormat": "The first line contains three integers separated by spaces, representing the number of space stations $n$, the number of spacecraft $m$, and the number of people on Earth $k$.\n\nLines $2$ through $(m + 1)$ each describe one spacecraft. On line $(i + 1)$, the first integer $h_i$ is the capacity of the $i$-th spacecraft. Then an integer $r_i$ follows, representing the number of stops of the $i$-th spacecraft. After that are $r_i$ integers, in order, representing the indices of the stops $S_{i, j}$, where the space stations are numbered from $1$ to $n$, Earth is indexed as $0$, and the Moon as $-1$.", "outputFormat": "Output a single integer representing the shortest time needed to transfer all people to the Moon. If there is no solution, output $0$.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that:\n- $1 \\leq n \\leq 13$.\n- $1 \\leq m \\leq 20$.\n- $1 \\leq k \\leq 50$.\n- $1 \\leq r_i \\leq n + 2$.\n- $-1 \\leq S_{i, j} \\leq n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[CTSC1999] 家园 / 星际转移问题", "background": "", "description": "由于人类对自然资源的消耗，人们意识到大约在 2300 年之后，地球就不能再居住了。于是在月球上建立了新的绿地，以便在需要时移民。令人意想不到的是，2177 年冬由于未知的原因，地球环境发生了连锁崩溃，人类必须在最短的时间内迁往月球。\n\n现有 $n$ 个太空站位于地球与月球之间，且有 $m$ 艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而太空船的容量是有限的，第 $i$ 艘太空船只可容纳  $h_i$ 个人。每艘太空船将周期性地停靠一系列的太空站，例如 $(1,3,4)$ 表示该太空船将周期性地停靠太空站 $134134134\\dots$。每一艘太空船从一个太空站驶往任一太空站耗时均为 $1$。人们只能在太空船停靠太空站(或月球、地球)时上、下船。\n\n初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。", "inputFormat": "输入的第一行是三个用空格隔开的整数，分别代表太空站个数 $n$，太空船个数 $m$ 和地球上的人数 $k$。\n\n第 $2$ 到第 $(m + 1)$ 行，每行给出一艘太空船的信息，第 $(i + 1)$ 行的第一个整数 $h_i$ 代表第 $i$ 艘太空船可容纳的人数。随后有一个整数 $r_i$，代表第 $i$ 艘太空船停靠的站点数。之后有 $r_i$ 个整数，依次代表该太空船停靠站点的编号 $S_{i, j}$，其中太空站自 $1$ 至 $n$ 编号，地球编号为 $0$，月球编号为 $-1$。", "outputFormat": "输出一行一个整数，代表将所有人转移到月球上的最短用时。若无解则输出 $0$。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n\n- $1 \\leq n \\leq 13$。\n- $1 \\leq m \\leq 20$。\n- $1 \\leq k \\leq 50$。\n- $1 \\leq r_i \\leq n + 2$。\n- $-1 \\leq S_{i, j}\\leq n$。", "locale": "zh-CN"}}}
{"pid": "P2755", "type": "P", "difficulty": 2, "samples": [["20", "20"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": [], "title": "洗牌问题", "background": "", "description": "有 $ 2n $ 张牌，编号为\n\n$$ 1,2,3 \\dots n,n+1, \\dots 2n$$\n\n这也是最初的牌的顺序。一次洗牌是把序列变为\n\n$$ n+1,1,n+2,2,n+3,3,n+4,4 \\dots 2n,n $$\n\n可以证明，对于任意自然数 $ n $，都可以在经过 $ m $ 次洗牌后第一次重新得到初始的顺序。\n\n现给定 $n$（$n \\le 10^8$），求出 $ m $ 的值。", "inputFormat": "一行，一个正整数 $n$。\n", "outputFormat": "一行，一个正整数 $m$。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 10^8$。", "locale": "zh-CN", "translations": {"en": {"title": "Shuffling Problem", "background": "", "description": "There are $ 2n $ cards, numbered as\n$$ 1,2,3 \\dots n,n+1, \\dots 2n $$\nwhich is also the initial order of the deck. One shuffle transforms the sequence into\n$$ n+1,1,n+2,2,n+3,3,n+4,4 \\dots 2n,n $$. \nIt can be proven that for any natural number $ n $, there exists a smallest positive integer $ m $ such that after performing the shuffle $ m $ times, the deck returns to its initial order for the first time.\n\nGiven $ n $ ($ n \\le 10^8 $), compute this $ m $.", "inputFormat": "One line containing a positive integer $ n $.", "outputFormat": "One line containing a positive integer $ m $.", "hint": "For $ 100\\% $ of the testdata, $ 1 \\le n \\le 10^8 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "洗牌问题", "background": "", "description": "有 $ 2n $ 张牌，编号为\n\n$$ 1,2,3 \\dots n,n+1, \\dots 2n$$\n\n这也是最初的牌的顺序。一次洗牌是把序列变为\n\n$$ n+1,1,n+2,2,n+3,3,n+4,4 \\dots 2n,n $$\n\n可以证明，对于任意自然数 $ n $，都可以在经过 $ m $ 次洗牌后第一次重新得到初始的顺序。\n\n现给定 $n$（$n \\le 10^8$），求出 $ m $ 的值。", "inputFormat": "一行，一个正整数 $n$。\n", "outputFormat": "一行，一个正整数 $m$。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le n \\le 10^8$。", "locale": "zh-CN"}}}
{"pid": "P2756", "type": "P", "difficulty": 4, "samples": [["5 10\n1 7\n1 8\n2 6\n2 9\n2 10\n3 7\n3 8\n4 7\n4 8\n5 10\n-1 -1\n", "4\n1 7\n2 9\n3 8\n5 10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流", "Special Judge", "O2优化", "二分图", "网络流与线性规划 24 题"], "title": "飞行员配对方案问题", "background": "第二次世界大战期间，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的两名飞行员，其中一名是英国飞行员，另一名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。", "description": "一共有 $n$ 个飞行员，其中有 $m$ 个外籍飞行员和 $(n - m)$ 个英国飞行员，**外籍飞行员从 $1$ 到 $m$ 编号**，**英国飞行员从 $m + 1$ 到 $n$ 编号**。 对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。", "inputFormat": "输入的第一行是用空格隔开的两个正整数，分别代表外籍飞行员的个数 $m$ 和飞行员总数 $n$。  \n从第二行起到倒数第二行，每行有两个整数 $u, v$，代表外籍飞行员 $u$ 可以和英国飞行员 $v$ 配合。  \n输入的最后一行保证为 `-1 -1`，代表输入结束。", "outputFormat": "**本题存在 Special Judge**。  \n请输出能派出最多的飞机数量，并给出一种可行的方案。  \n输出的第一行是一个整数，代表一次能派出的最多飞机数量，设这个整数是 $k$。  \n第 $2$ 行到第 $k + 1$ 行，每行输出两个整数 $u, v$，代表在你给出的方案中，外籍飞行员 $u$ 和英国飞行员 $v$ 配合。这 $k$ 行的 $u$ 与 $v$ 应该互不相同。", "hint": "**【数据范围与约定】**\n\n- 对于 $100\\%$ 的数据，保证 $1 \\leq m \\leq n < 100$，$1 \\leq u \\leq m < v \\leq n$。\n\n::anti-ai[同一组配对关系只会给出一次。]\n\n**【提示】**\n\n- 请注意输入的第一行先读入 $m$，再读入 $n$。", "locale": "zh-CN", "translations": {"en": {"title": "Pilot Pairing Problem", "background": "During World War II, the Royal Air Force (RAF) recruited many foreign pilots from occupied countries. Each aircraft dispatched by the RAF must be staffed with two pilots who can cooperate in flight skills and language: one British pilot and one foreign pilot. Among the many pilots, each foreign pilot can work well with several British pilots.", "description": "There are $n$ pilots in total, including $m$ foreign pilots and $(n - m)$ British pilots. Foreign pilots are numbered from $1$ to $m$, and British pilots are numbered from $m + 1$ to $n$. Given the cooperation relations between foreign and British pilots, design an algorithm to find the optimal pairing scheme so that the RAF can dispatch the maximum number of aircraft at once.", "inputFormat": "The first line contains two positive integers separated by a space, representing the number of foreign pilots $m$ and the total number of pilots $n$.  \nFrom the second line to the second-to-last line, each line contains two integers $u, v$, meaning foreign pilot $u$ can cooperate with British pilot $v$.  \nThe last line is guaranteed to be `-1 -1`, indicating the end of input.", "outputFormat": "This problem uses a Special Judge.  \nOutput the maximum number of aircraft that can be dispatched, and provide one feasible pairing scheme.  \nThe first line contains an integer, the maximum number of aircraft that can be dispatched at once; denote this integer by $k$.  \nFrom line $2$ to line $k + 1$, each line contains two integers $u, v$, indicating that in your scheme, foreign pilot $u$ is paired with British pilot $v$. The pairs $(u, v)$ in these $k$ lines must be all distinct.", "hint": "- 【Constraints and Conventions】\n  - For $100\\%$ of the testdata, it is guaranteed that $1 \\leq m \\leq n < 100$, $1 \\leq u \\leq m < v \\leq n$.\n\n::anti-ai[The same pairing relation will be given at most once.]\n\n- 【Hint】\n  - Note that the first line reads $m$ first, then $n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "飞行员配对方案问题", "background": "第二次世界大战期间，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的两名飞行员，其中一名是英国飞行员，另一名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。", "description": "一共有 $n$ 个飞行员，其中有 $m$ 个外籍飞行员和 $(n - m)$ 个英国飞行员，**外籍飞行员从 $1$ 到 $m$ 编号**，**英国飞行员从 $m + 1$ 到 $n$ 编号**。 对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。", "inputFormat": "输入的第一行是用空格隔开的两个正整数，分别代表外籍飞行员的个数 $m$ 和飞行员总数 $n$。  \n从第二行起到倒数第二行，每行有两个整数 $u, v$，代表外籍飞行员 $u$ 可以和英国飞行员 $v$ 配合。  \n输入的最后一行保证为 `-1 -1`，代表输入结束。", "outputFormat": "**本题存在 Special Judge**。  \n请输出能派出最多的飞机数量，并给出一种可行的方案。  \n输出的第一行是一个整数，代表一次能派出的最多飞机数量，设这个整数是 $k$。  \n第 $2$ 行到第 $k + 1$ 行，每行输出两个整数 $u, v$，代表在你给出的方案中，外籍飞行员 $u$ 和英国飞行员 $v$ 配合。这 $k$ 行的 $u$ 与 $v$ 应该互不相同。", "hint": "**【数据范围与约定】**\n\n- 对于 $100\\%$ 的数据，保证 $1 \\leq m \\leq n < 100$，$1 \\leq u \\leq m < v \\leq n$。\n\n::anti-ai[同一组配对关系只会给出一次。]\n\n**【提示】**\n\n- 请注意输入的第一行先读入 $m$，再读入 $n$。", "locale": "zh-CN"}}}
{"pid": "P2757", "type": "P", "difficulty": 6, "samples": [["2\n3\n1 3 2\n3\n3 2 1", "N\nY"]], "limits": {"time": [5000, 5000, 5000, 5000, 5000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["线段树", "集训队互测", "O2优化", "哈希 hashing"], "title": "[国家集训队] 等差子序列", "background": "", "description": "给一个 $1$ 到 $N$ 的排列 $\\{A_i\\}$，询问是否存在\n\n$$1 \\le p_1<p_2<p_3<p_4<p_5<…<p_{Len} \\le N (Len \\ge 3)$$\n\n使得 $Ap_1,Ap_2,Ap_3,\\cdots,Ap_{Len}$ 是一个等差序列。\n", "inputFormat": "输入的第一行包含一个整数 $T$，表示组数。\n\n下接 $T$ 组数据，每组第一行一个整数 $N$，每组第二行为一个 $1$ 到 $N$ 的排列，数字两两之间用空格隔开。\n", "outputFormat": "对于每组数据，如果存在一个等差子序列，则输出一行 Y，否则输出一行 N。\n", "hint": "对于前 $5$ 个测试点的数据，$1 \\leq N \\leq 5\\times 10^5,T \\leq 5$，时限 5s。\n\n对于后 $21$ 个测试点的数据，$1 \\leq N \\leq10000,T\\leq 7$，时限 2s。", "locale": "zh-CN", "translations": {"en": {"title": "[CTT] Arithmetic Subsequence", "background": "", "description": "Given a permutation $\\{A_i\\}$ of $1$ to $N$, determine whether there exist indices\n$$1 \\le p_1 < p_2 < p_3 < p_4 < p_5 < \\cdots < p_{Len} \\le N, \\quad Len \\ge 3,$$\nsuch that $A_{p_1}, A_{p_2}, A_{p_3}, \\cdots, A_{p_{Len}}$ form an arithmetic progression.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nThen follow $T$ test cases. For each test case, the first line contains an integer $N$, and the second line contains a permutation of $1$ to $N$, with numbers separated by single spaces.", "outputFormat": "For each test case, output a single line with Y if there exists an arithmetic subsequence, otherwise output N.", "hint": "For the first $5$ test points, $1 \\leq N \\leq 5 \\times 10^5$, $T \\leq 5$, time limit $5$ s.\n\nFor the remaining $21$ test points, $1 \\leq N \\leq 10000$, $T \\leq 7$, time limit $2$ s.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[国家集训队] 等差子序列", "background": "", "description": "给一个 $1$ 到 $N$ 的排列 $\\{A_i\\}$，询问是否存在\n\n$$1 \\le p_1<p_2<p_3<p_4<p_5<…<p_{Len} \\le N (Len \\ge 3)$$\n\n使得 $Ap_1,Ap_2,Ap_3,\\cdots,Ap_{Len}$ 是一个等差序列。\n", "inputFormat": "输入的第一行包含一个整数 $T$，表示组数。\n\n下接 $T$ 组数据，每组第一行一个整数 $N$，每组第二行为一个 $1$ 到 $N$ 的排列，数字两两之间用空格隔开。\n", "outputFormat": "对于每组数据，如果存在一个等差子序列，则输出一行 Y，否则输出一行 N。\n", "hint": "对于前 $5$ 个测试点的数据，$1 \\leq N \\leq 5\\times 10^5,T \\leq 5$，时限 5s。\n\n对于后 $21$ 个测试点的数据，$1 \\leq N \\leq10000,T\\leq 7$，时限 2s。", "locale": "zh-CN"}}}
{"pid": "P2758", "type": "P", "difficulty": 3, "samples": [["sfdqxbw\ngfdgw\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "动态规划 DP", "数学"], "title": "编辑距离", "background": "", "description": "设 $A$ 和 $B$ 是两个字符串。我们要用最少的字符操作次数，将字符串 $A$ 转换为字符串 $B$。这里所说的字符操作共有三种：\n\n1. 删除一个字符；\n2. 插入一个字符；\n3. 将一个字符改为另一个字符。\n\n$A, B$ 均只包含小写字母。\n", "inputFormat": "第一行为字符串 $A$；第二行为字符串 $B$；字符串 $A, B$ 的长度均小于 $2000$。\n", "outputFormat": "只有一个正整数，为最少字符操作次数。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le |A|, |B| \\le 2000$。", "locale": "zh-CN", "translations": {"en": {"title": "Edit Distance", "background": "", "description": "Let $A$ and $B$ be two strings. We want to transform string $A$ into string $B$ using the minimum number of character operations. There are three types of operations:\n1. Delete one character.\n2. Insert one character.\n3. Replace one character with another.\n\nBoth $A$ and $B$ contain only lowercase letters.", "inputFormat": "The first line contains string $A$. The second line contains string $B$. Both have length at most $2000$.", "outputFormat": "Output a single positive integer, which is the minimum number of character operations.", "hint": "For $100 \\%$ of the testdata, $1 \\le |A|, |B| \\le 2000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "编辑距离", "background": "", "description": "设 $A$ 和 $B$ 是两个字符串。我们要用最少的字符操作次数，将字符串 $A$ 转换为字符串 $B$。这里所说的字符操作共有三种：\n\n1. 删除一个字符；\n2. 插入一个字符；\n3. 将一个字符改为另一个字符。\n\n$A, B$ 均只包含小写字母。\n", "inputFormat": "第一行为字符串 $A$；第二行为字符串 $B$；字符串 $A, B$ 的长度均小于 $2000$。\n", "outputFormat": "只有一个正整数，为最少字符操作次数。\n", "hint": "对于 $100 \\%$ 的数据，$1 \\le |A|, |B| \\le 2000$。", "locale": "zh-CN"}}}
{"pid": "P2759", "type": "P", "difficulty": 3, "samples": [["11", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "二分", "洛谷原创"], "title": "奇怪的函数", "background": "", "description": "使得 $x^x$ 达到或超过 $n$ 位数字的最小正整数 $x$ 是多少？\n", "inputFormat": "一个正整数 $n$。\n", "outputFormat": "使得 $x^x$ 达到 $n$ 位数字的最小正整数 $x$。\n", "hint": "对于全部数据，$1\\le n\\le 2\\times 10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Strange Function", "background": "", "description": "What is the smallest positive integer $x$ such that $x^x$ has at least $n$ digits?", "inputFormat": "A positive integer $n$.", "outputFormat": "Output the smallest positive integer $x$ such that $x^x$ has at least $n$ digits.", "hint": "For all testdata, $1 \\le n \\le 2 \\times 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "奇怪的函数", "background": "", "description": "使得 $x^x$ 达到或超过 $n$ 位数字的最小正整数 $x$ 是多少？\n", "inputFormat": "一个正整数 $n$。\n", "outputFormat": "使得 $x^x$ 达到 $n$ 位数字的最小正整数 $x$。\n", "hint": "对于全部数据，$1\\le n\\le 2\\times 10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P2760", "type": "P", "difficulty": 4, "samples": [["4 4 13 20\n10 0  0  0\n0  0  10 0\n0  0  10 0\n0  0  0  0\n1 0 0 0\n0 0 2 0\n0 0 4 0\n0 0 0 0", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "科技庄园", "background": "", "description": "Life 种了一块田，里面种了有一些桃树。\n\nLife 对 PFT 说：“我给你一定的时间去摘桃，你必须在规定的时间之内回到我面前，否则你摘的桃都要归我吃！”  \n\nPFT 思考了一会，最终答应了！\n\n由于 PFT 的数学不好！它并不知道怎样才能在规定的时间获得最大的价值，  \n\n由于 PFT 不是机器人，所以他的体力并不是无限的，他不想摘很多的桃以至体力为 $0$，而白白把桃给 Life。同时 PFT 每次只能摘一棵桃树，每棵桃树都可以摘 $K$ 次（对于同一棵桃每次摘的桃数相同）。每次摘完后都要返回出发点（PFT 一次拿不了很多）即 Life 的所在地 $(0，0)$ （试验田左上角的桃坐标是 $(1，1)$）。  \n\nPFT 每秒只能移动一个单位，每移动一个单位耗费体力 $1$ （摘取不花费时间和体力，但只限上下左右移动）。", "inputFormat": "第一行：四个数为 $N$，$M$，$TI$，$A$ 分别表示试验田的长和宽，Life 给 PFT 的时间，和 PFT 的体力。  \n\n下面一个 $N$ 行 $M$ 列的矩阵桃田。表示每次每棵桃树上能摘的桃数。   \n\n接下来 $N$ 行 $M$ 列的矩阵，表示每棵桃最多可以采摘的次数 $K$。", "outputFormat": "一个数：PFT 可以获得的最大的桃个数。", "hint": "样例说明：\n\n可以摘到 1 次 $(1，1)$ 和 $1$ 次 $(2，3)$，体力和时间不满足再摘桃了。\n\n范围：  \n\n对于 $30\\%$ 的数据：$10\\le N,M,TI \\le 50$；\n\n对于 $100\\%$ 的数据：$10\\le N,M,TI\\le 100$。\n\n对于 $K$：$10\\le K\\le 100$。\n\n保证结果在 `long int` 范围内。", "locale": "zh-CN", "translations": {"en": {"title": "Tech Manor", "background": "", "description": "Life planted a field with some peach trees.\n\nLife said to PFT: \"I will give you a certain amount of time to pick peaches. You must return to me within the time limit, otherwise all the peaches you picked will be mine to eat!\"\n\nPFT thought for a while and agreed.\n\nBecause PFT is not good at math, he does not know how to obtain the maximum total within the time limit.\n\nPFT is not a robot, so his stamina is limited. He does not want to pick so many peaches that his stamina becomes $0$ and end up giving the peaches to Life for nothing. At the same time:\n- In each trip PFT can pick from exactly one peach tree.\n- Each tree can be picked at most $K$ times, and each pick from the same tree yields the same number of peaches.\n- After each pick he must return to the starting point, i.e., Life's location $(0, 0)$ (the coordinate of the top-left peach in the field is $(1, 1)$).\n\nMovement rules:\n- PFT can only move up, down, left, and right.\n- He moves $1$ unit per second.\n- Moving $1$ unit costs $1$ stamina.\n- Picking costs no time and no stamina.", "inputFormat": "The first line contains four integers $N$, $M$, $TI$, $A$, representing the length and width of the field, the time given by Life, and PFT's stamina.\n\nThen an $N \\times M$ matrix for the field, where each entry is the number of peaches obtained per pick from that tree.\n\nThen another $N \\times M$ matrix, where each entry is the maximum number of times $K$ that tree can be picked.", "outputFormat": "One integer: the maximum number of peaches PFT can obtain.", "hint": "Sample explanation:\n\nYou can pick $1$ time at $(1, 1)$ and $1$ time at $(2, 3)$. Time and stamina do not allow any more picking.\n\nConstraints:\n- For $30\\%$ of the testdata: $10 \\le N, M, TI \\le 50$.\n- For $10\\%$ of the testdata: $10 \\le N, M, TI \\le 100$.\n- For $K$: $10 \\le K \\le 100$.\nThe result is guaranteed to fit in the range of `long int`.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "科技庄园", "background": "", "description": "Life 种了一块田，里面种了有一些桃树。\n\nLife 对 PFT 说：“我给你一定的时间去摘桃，你必须在规定的时间之内回到我面前，否则你摘的桃都要归我吃！”  \n\nPFT 思考了一会，最终答应了！\n\n由于 PFT 的数学不好！它并不知道怎样才能在规定的时间获得最大的价值，  \n\n由于 PFT 不是机器人，所以他的体力并不是无限的，他不想摘很多的桃以至体力为 $0$，而白白把桃给 Life。同时 PFT 每次只能摘一棵桃树，每棵桃树都可以摘 $K$ 次（对于同一棵桃每次摘的桃数相同）。每次摘完后都要返回出发点（PFT 一次拿不了很多）即 Life 的所在地 $(0，0)$ （试验田左上角的桃坐标是 $(1，1)$）。  \n\nPFT 每秒只能移动一个单位，每移动一个单位耗费体力 $1$ （摘取不花费时间和体力，但只限上下左右移动）。", "inputFormat": "第一行：四个数为 $N$，$M$，$TI$，$A$ 分别表示试验田的长和宽，Life 给 PFT 的时间，和 PFT 的体力。  \n\n下面一个 $N$ 行 $M$ 列的矩阵桃田。表示每次每棵桃树上能摘的桃数。   \n\n接下来 $N$ 行 $M$ 列的矩阵，表示每棵桃最多可以采摘的次数 $K$。", "outputFormat": "一个数：PFT 可以获得的最大的桃个数。", "hint": "样例说明：\n\n可以摘到 1 次 $(1，1)$ 和 $1$ 次 $(2，3)$，体力和时间不满足再摘桃了。\n\n范围：  \n\n对于 $30\\%$ 的数据：$10\\le N,M,TI \\le 50$；\n\n对于 $100\\%$ 的数据：$10\\le N,M,TI\\le 100$。\n\n对于 $K$：$10\\le K\\le 100$。\n\n保证结果在 `long int` 范围内。", "locale": "zh-CN"}}}
{"pid": "P2761", "type": "P", "difficulty": 4, "samples": [["3 3\n1 000 00-\n1 00- 0-+\n2 0-- -++\n", "8\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["O2优化", "最短路", "网络流与线性规划 24 题", "状压 DP"], "title": "软件补丁问题", "background": "", "description": "T 公司发现其研制的一个软件中有 $n$ 个错误，随即为该软件发放了 $m$ 个补丁程序。\n\n每一个补丁程序都有其特定的适用环境，某个补丁只有在软件中包含某些错误而同时又不包含另一些错误时才可以使用。一个补丁在排除某些错误的同时，往往会加入另一些错误。\n\n换句话说，对于任意一个补丁 $i$，都有四个与之相应的集合 $B1_i,B2_i,F1_i$ 和 $F2_i$。仅当软件包含 $B1_i$ 中的所有错误，而不包含 $B2_i$ 中的任何错误时，才可以使用补丁 $i$。补丁 $i$ 将修复软件中的某些错误集合 $F1_i$，而同时加入另一些错误 $F2_i$。另外，运行每个补丁都耗费一定的时间。\n\n试设计一个算法，利用 T 公司提供的 $m$ 个补丁程序将原软件修复成一个没有错误的软件，并使修复后的软件耗时最少。对于给定的 $n$ 个错误和 $m$ 个补丁程序，找到总耗时最少的软件修复方案。", "inputFormat": "第一行有两个正整数 $n$ 和 $m$。$n$ 表示错误总数，$m$表示补丁总数。\n\n接下来 $m$ 行给出了 $m$ 个补丁的信息。每行包括一个正整数，表示运行补丁程序 $i$ 所需时间，以及两个长度为 $n$ 的字符串。中间用一个空格符隔开。\n\n第一个字符串中，如果第 $k$ 个字符为 ```+```，则表示第 $k$ 个错误属于 $B1_i$。若为 ```-```，则表示第 $k$ 个错误属于 $B2_i$。若为 ```0```，则第 $k$ 个错误既不属于 $B1_i$ 也不属于 $B2_i$，即软件中是否包含第 $k$ 个错误并不影响补丁 $i$ 的可用性。\n\n第二个字符串中，如果第 $k$ 个字符为 ```-```，则表示第 $k$ 个错误属于 $F1_i$。若为 ```+```，则表示第 $k$ 个错误属于 $F2_i$。若为 ```0```，则第 $k$ 个错误既不属于 $F1_i$ 也不属于 $F2_i$，即软件中是否包含第 $k$ 个错误不会因使用补丁 $i$ 而改变。", "outputFormat": "程序运行结束时，将总耗时数输出。如果问题无解，则输出 `0`。", "hint": "对于 $100\\%$ 的数据：$1\\le n\\le 20$，$1\\le m\\le 100$。", "locale": "zh-CN", "translations": {"en": {"title": "Software Patch Problem", "background": "", "description": "Company T discovered that there are $n$ bugs in one of its software products and then released $m$ patch programs for it.\n\nEach patch has its specific applicable environment: a patch can be used only when the software contains certain bugs and at the same time does not contain some other bugs. While removing some bugs, a patch may also introduce new bugs.\n\nIn other words, for any patch $i$, there are four associated sets $B1_i,B2_i,F1_i$ and $F2_i$. Patch $i$ can be applied only if the software contains all bugs in $B1_i$ and contains none of the bugs in $B2_i$. Patch $i$ will fix the set of bugs $F1_i$, and at the same time introduce the set of bugs $F2_i$. In addition, running each patch takes a certain amount of time.\n\nDesign an algorithm to use the $m$ patch programs provided by Company T to repair the original software into a bug-free state, while minimizing the total time. For the given $n$ bugs and $m$ patches, find a repair plan with the minimum total time.", "inputFormat": "The first line contains two positive integers $n$ and $m$. Here, $n$ is the total number of bugs, and $m$ is the total number of patches.\n\nThe next $m$ lines describe the $m$ patches. Each line contains a positive integer representing the time required to run patch $i$, followed by two strings of length $n$, separated by a space character.\n\nIn the first string, if the $k$-th character is ```+```, then the $k$-th bug belongs to $B1_i$. If it is ```-```, then the $k$-th bug belongs to $B2_i$. If it is ```0```, then the $k$-th bug belongs to neither $B1_i$ nor $B2_i$, i.e., whether the software contains the $k$-th bug does not affect the applicability of patch $i$.\n\nIn the second string, if the $k$-th character is ```-```, then the $k$-th bug belongs to $F1_i$. If it is ```+```, then the $k$-th bug belongs to $F2_i$. If it is ```0```, then the $k$-th bug belongs to neither $F1_i$ nor $F2_i$, i.e., whether the software contains the $k$-th bug will not change after applying patch $i$.", "outputFormat": "Output the minimum total time after the program finishes. If there is no solution, output `0`.", "hint": "Constraints: For $100\\%$ of the testdata: $1 \\le n \\le 20$, $1 \\le m \\le 100$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "软件补丁问题", "background": "", "description": "T 公司发现其研制的一个软件中有 $n$ 个错误，随即为该软件发放了 $m$ 个补丁程序。\n\n每一个补丁程序都有其特定的适用环境，某个补丁只有在软件中包含某些错误而同时又不包含另一些错误时才可以使用。一个补丁在排除某些错误的同时，往往会加入另一些错误。\n\n换句话说，对于任意一个补丁 $i$，都有四个与之相应的集合 $B1_i,B2_i,F1_i$ 和 $F2_i$。仅当软件包含 $B1_i$ 中的所有错误，而不包含 $B2_i$ 中的任何错误时，才可以使用补丁 $i$。补丁 $i$ 将修复软件中的某些错误集合 $F1_i$，而同时加入另一些错误 $F2_i$。另外，运行每个补丁都耗费一定的时间。\n\n试设计一个算法，利用 T 公司提供的 $m$ 个补丁程序将原软件修复成一个没有错误的软件，并使修复后的软件耗时最少。对于给定的 $n$ 个错误和 $m$ 个补丁程序，找到总耗时最少的软件修复方案。", "inputFormat": "第一行有两个正整数 $n$ 和 $m$。$n$ 表示错误总数，$m$表示补丁总数。\n\n接下来 $m$ 行给出了 $m$ 个补丁的信息。每行包括一个正整数，表示运行补丁程序 $i$ 所需时间，以及两个长度为 $n$ 的字符串。中间用一个空格符隔开。\n\n第一个字符串中，如果第 $k$ 个字符为 ```+```，则表示第 $k$ 个错误属于 $B1_i$。若为 ```-```，则表示第 $k$ 个错误属于 $B2_i$。若为 ```0```，则第 $k$ 个错误既不属于 $B1_i$ 也不属于 $B2_i$，即软件中是否包含第 $k$ 个错误并不影响补丁 $i$ 的可用性。\n\n第二个字符串中，如果第 $k$ 个字符为 ```-```，则表示第 $k$ 个错误属于 $F1_i$。若为 ```+```，则表示第 $k$ 个错误属于 $F2_i$。若为 ```0```，则第 $k$ 个错误既不属于 $F1_i$ 也不属于 $F2_i$，即软件中是否包含第 $k$ 个错误不会因使用补丁 $i$ 而改变。", "outputFormat": "程序运行结束时，将总耗时数输出。如果问题无解，则输出 `0`。", "hint": "对于 $100\\%$ 的数据：$1\\le n\\le 20$，$1\\le m\\le 100$。", "locale": "zh-CN"}}}
{"pid": "P2762", "type": "P", "difficulty": 6, "samples": [["2 3\n10 1 2\n25 2 3\n5 6 7", "1 2\n1 2 3\n17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["网络流", "Special Judge", "O2优化", "网络流与线性规划 24 题"], "title": "太空飞行计划问题", "background": null, "description": "W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 $ E = \\{ E_1, E_2, \\cdots, E_m \\} $，和进行这些实验需要使用的全部仪器的集合 $ I = \\{ I_1, I_2, \\cdots, I_n \\} $。实验 $ E_j $ 需要用到的仪器是 $ I $ 的子集 $ R_j \\subseteq I $。\n\n配置仪器 $ I_k $ 的费用为 $ c_k $ 美元。实验 $ E_j $ 的赞助商已同意为该实验结果支付 $ p_j $ 美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。\n\n对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。", "inputFormat": "第 $ 1 $ 行有 $ 2 $ 个正整数 $ m $ 和 $ n $。$ m $ 是实验数，$ n $ 是仪器数。接下来的 $ m $ 行，每行是一个实验的有关数据。第一个数赞助商同意支付该实验的费用；接着是该实验需要用到的若干仪器的编号。最后一行的 $ n $ 个数是配置每个仪器的费用。", "outputFormat": "第 $ 1 $ 行是实验编号，第 $ 2 $ 行是仪器编号，最后一行是净收益。", "hint": "感谢 @FlierKing 提供 spj\n\n$1 \\leq n, m \\leq 50 ，1 \\leq c,p < 2^{31}  $。\n\n这道题数据是在 Windows 生成的，输入数据中所有的换行都是 `\\r\\n` 而不是 `\\n`  \n读入某实验需要用到的仪器编号的时候，可以这么读入。(感谢@zhouyonglong的提供)\n```cpp\nchar tools[10000];\nmemset(tools,0,sizeof tools);\ncin.getline(tools,10000);\nint ulen=0,tool;\nwhile (sscanf(tools+ulen,\"%d\",&tool)==1)//之前已经用scanf读完了赞助商同意支付该实验的费用\n{//tool是该实验所需仪器的其中一个      \n    //这一行，你可以将读进来的编号进行储存、处理，如连边。\n    if (tool==0) \n        ulen++;\n    else {\n        while (tool) {\n            tool/=10;\n            ulen++;\n        }\n    }\n    ulen++;\n}\n```", "locale": "zh-CN", "translations": {"en": {"title": "Space Flight Planning Problem", "background": "", "description": "Professor W is planning a series of space flights for the National Space Center. Each space flight can carry out a series of commercial experiments to earn profit. A set of optional experiments has been determined as $ E = \\{ E_1, E_2, \\cdots, E_m \\} $, and the set of all instruments required to conduct these experiments is $ I = \\{ I_1, I_2, \\cdots, I_n \\} $. The instruments required by experiment $ E_j $ form a subset $ R_j \\subseteq I $.\n\nThe cost to configure instrument $ I_k $ is $ c_k $ dollars. The sponsors of experiment $ E_j $ have agreed to pay $ p_j $ dollars for its results. Professor W’s task is to design an efficient algorithm to determine which experiments to conduct and thus which instruments to configure in a single space flight to maximize the net profit. Here, the net profit is defined as the total income from the experiments minus the total cost of configuring the instruments.\n\nGiven the experiments and instrument configuration information, write a program to find the plan with the maximum net profit.", "inputFormat": "The first line contains $ 2 $ positive integers $ m $ and $ n $. Here, $ m $ is the number of experiments and $ n $ is the number of instruments. The next $ m $ lines each describe one experiment. The first number is the payment the sponsor agrees to pay for that experiment, followed by the indices of the instruments required by that experiment. The last line contains $ n $ numbers, which are the configuration costs of each instrument.", "outputFormat": "The first line contains the indices of the selected experiments. The second line contains the indices of the selected instruments. The last line contains the net profit.", "hint": "Thanks to @FlierKing for providing the SPJ.\n\nConstraints: $ 1 \\leq n, m \\leq 50, 1 \\leq c, p < 2^{31} $.\n\nThe testdata for this problem was generated on Windows. All line breaks in the input are `\\r\\n` instead of `\\n` .\nWhen reading the indices of the instruments required by an experiment, you can read them as follows. (Thanks to @zhouyonglong.)\n```cpp\nchar tools[10000];\nmemset(tools,0,sizeof tools);\ncin.getline(tools,10000);\nint ulen=0,tool;\nwhile (sscanf(tools+ulen,\"%d\",&tool)==1)//之前已经用scanf读完了赞助商同意支付该实验的费用\n{//tool是该实验所需仪器的其中一个      \n    //这一行，你可以将读进来的编号进行储存、处理，如连边。\n    if (tool==0) \n        ulen++;\n    else {\n        while (tool) {\n            tool/=10;\n            ulen++;\n        }\n    }\n    ulen++;\n}\n```\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "太空飞行计划问题", "background": null, "description": "W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 $ E = \\{ E_1, E_2, \\cdots, E_m \\} $，和进行这些实验需要使用的全部仪器的集合 $ I = \\{ I_1, I_2, \\cdots, I_n \\} $。实验 $ E_j $ 需要用到的仪器是 $ I $ 的子集 $ R_j \\subseteq I $。\n\n配置仪器 $ I_k $ 的费用为 $ c_k $ 美元。实验 $ E_j $ 的赞助商已同意为该实验结果支付 $ p_j $ 美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。\n\n对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。", "inputFormat": "第 $ 1 $ 行有 $ 2 $ 个正整数 $ m $ 和 $ n $。$ m $ 是实验数，$ n $ 是仪器数。接下来的 $ m $ 行，每行是一个实验的有关数据。第一个数赞助商同意支付该实验的费用；接着是该实验需要用到的若干仪器的编号。最后一行的 $ n $ 个数是配置每个仪器的费用。", "outputFormat": "第 $ 1 $ 行是实验编号，第 $ 2 $ 行是仪器编号，最后一行是净收益。", "hint": "感谢 @FlierKing 提供 spj\n\n$1 \\leq n, m \\leq 50 ，1 \\leq c,p < 2^{31}  $。\n\n这道题数据是在 Windows 生成的，输入数据中所有的换行都是 `\\r\\n` 而不是 `\\n`  \n读入某实验需要用到的仪器编号的时候，可以这么读入。(感谢@zhouyonglong的提供)\n```cpp\nchar tools[10000];\nmemset(tools,0,sizeof tools);\ncin.getline(tools,10000);\nint ulen=0,tool;\nwhile (sscanf(tools+ulen,\"%d\",&tool)==1)//之前已经用scanf读完了赞助商同意支付该实验的费用\n{//tool是该实验所需仪器的其中一个      \n    //这一行，你可以将读进来的编号进行储存、处理，如连边。\n    if (tool==0) \n        ulen++;\n    else {\n        while (tool) {\n            tool/=10;\n            ulen++;\n        }\n    }\n    ulen++;\n}\n```", "locale": "zh-CN"}}}
{"pid": "P2763", "type": "P", "difficulty": 5, "samples": [["3 15\n3 3 4\n2 1 2\n1 3\n1 3\n1 3\n1 3\n3 1 2 3\n2 2 3\n2 1 3\n1 2\n1 2\n2 1 2\n2 1 3\n2 1 2\n1 1\n3 1 2 3", "1: 1 6 8\n2: 7 9 10\n3: 2 3 4 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["网络流", "Special Judge", "网络流与线性规划 24 题"], "title": "试题库问题", "background": "", "description": "问题描述：\n\n假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。\n\n编程任务：\n\n对于给定的组卷要求，计算满足要求的组卷方案。", "inputFormat": "第一行有两个正整数 $k$ 和 $n$。$k$ 表示题库中试题类型总数，$n$ 表示题库中试题总数。\n\n第二行有 $k$ 个正整数，第 $i$ 个正整数表示要选出的类型 $i$ 的题数。这 $k$ 个数相加就是要选出的总题数 $m$。\n\n接下来的 $n$ 行给出了题库中每个试题的类型信息。每行的第一个正整数 $p$ 表明该题可以属于 $p$ 类，接着的 $p$ 个数是该题所属的类型号。", "outputFormat": "输出共 $k$ 行，第 $i$ 行输出 `i: ` 后接类型 $i$ 的题号。  \n如果有多个满足要求的方案，只要输出一个方案。  \n如果问题无解，则输出`No Solution!`。", "hint": "$2\\leq k \\leq 20$，$k \\leq n \\leq 10^3$。\n\n---\n\n感谢 @PhoenixEclipse 提供 spj\n", "locale": "zh-CN", "translations": {"en": {"title": "Question Bank Problem", "background": "", "description": "Problem description:\nAssume a question bank contains $n$ questions. Each question is labeled with one or more types. We need to select $m$ questions from the bank to form an exam paper, and the paper must include the specified numbers of questions of each type. Design an algorithm that meets this requirement.\n\nProgramming task:\nGiven the selection requirements, compute a selection plan that satisfies them.", "inputFormat": "The first line contains two positive integers $k$ and $n$. Here, $k$ is the total number of types in the question bank, and $n$ is the total number of questions.\n\nThe second line contains $k$ positive integers; the $i$-th integer is the required count of type $i$ questions. The sum of these $k$ numbers is the total number of questions to select, $m$.\n\nEach of the next $n$ lines gives the type information for one question. The first positive integer $p$ indicates that the question belongs to $p$ types, followed by $p$ integers that are the type IDs of the question.", "outputFormat": "Output $k$ lines. On the $i$-th line, print `i: ` followed by the indices of the selected questions of type $i$. If multiple valid solutions exist, output any one of them. If no solution exists, output `No Solution!`.", "hint": "$2 \\leq k \\leq 20$, $k \\leq n \\leq 10^3$.\n\nThanks to @PhoenixEclipse for providing the SPJ.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "试题库问题", "background": "", "description": "问题描述：\n\n假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。\n\n编程任务：\n\n对于给定的组卷要求，计算满足要求的组卷方案。", "inputFormat": "第一行有两个正整数 $k$ 和 $n$。$k$ 表示题库中试题类型总数，$n$ 表示题库中试题总数。\n\n第二行有 $k$ 个正整数，第 $i$ 个正整数表示要选出的类型 $i$ 的题数。这 $k$ 个数相加就是要选出的总题数 $m$。\n\n接下来的 $n$ 行给出了题库中每个试题的类型信息。每行的第一个正整数 $p$ 表明该题可以属于 $p$ 类，接着的 $p$ 个数是该题所属的类型号。", "outputFormat": "输出共 $k$ 行，第 $i$ 行输出 `i: ` 后接类型 $i$ 的题号。  \n如果有多个满足要求的方案，只要输出一个方案。  \n如果问题无解，则输出`No Solution!`。", "hint": "$2\\leq k \\leq 20$，$k \\leq n \\leq 10^3$。\n\n---\n\n感谢 @PhoenixEclipse 提供 spj\n", "locale": "zh-CN"}}}
{"pid": "P2764", "type": "P", "difficulty": 6, "samples": [["11 12\n1 2\n1 3\n1 4\n2 5\n3 6\n4 7\n5 8\n6 9\n7 10\n8 11\n9 11\n10 11", "1 4 7 10 11\n2 5 8\n3 6 9\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["网络流", "Special Judge", "O2优化", "二分图", "上下界网络流", "网络流与线性规划 24 题"], "title": "最小路径覆盖问题", "background": "", "description": "给定有向图 $G=(V,E)$ 。设 $P$ 是 $G$ 的一个简单路（顶点不相交）的集合。如果 $V$ 中每个顶点恰好在 $P$ 的一条路上，则称 $P$ 是 $G$ 的一个路径覆盖。$P$ 中路径可以从 $V$ 的任何一个定点开始，长度也是任意的，特别地，可以为 $0$。$G$ 的最小路径覆盖是 $G$ 所含路径条数最少的路径覆盖。设计一个有效算法求一个 DAG（有向无环图）$G$ 的最小路径覆盖。\n", "inputFormat": "第一行有两个正整数 $n$ 和 $m$。$n$ 是给定 DAG（有向无环图）$G$ 的顶点数，$m$ 是 $G$ 的边数。接下来的 $m$ 行，每行有两个正整数 $i$ 和 $j$ 表示一条有向边 $(i,j)$。", "outputFormat": "从第一行开始，每行输出一条路径。文件的最后一行是最少路径数。\n", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 150$，$1\\leq m\\leq 6000$。\n\n由 @FlierKing 提供 SPJ", "locale": "zh-CN", "translations": {"en": {"title": "Minimum Path Cover Problem", "background": "", "description": "Given a directed graph $G=(V,E)$. Let $P$ be a set of simple paths (vertex-disjoint) in $G$. If every vertex in $V$ appears in exactly one path in $P$, then $P$ is a path cover of $G$. Paths in $P$ can start at any vertex in $V$, and their lengths are arbitrary; in particular, the length can be $0$. The minimum path cover of $G$ is a path cover with the fewest number of paths. Design an efficient algorithm to find a minimum path cover of a DAG (directed acyclic graph) $G$.", "inputFormat": "The first line contains two positive integers $n$ and $m$. Here $n$ is the number of vertices of the given DAG (directed acyclic graph) $G$, and $m$ is the number of edges of $G$. The next $m$ lines each contain two positive integers $i$ and $j$, representing a directed edge $(i, j)$.", "outputFormat": "Starting from the first line, output one path per line. The last line of the file is the minimum number of paths.", "hint": "Constraints: For $100\\%$ of the testdata, $1 \\leq n \\leq 150$, $1 \\leq m \\leq 6000$.\n\nSPJ provided by @FlierKing.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最小路径覆盖问题", "background": "", "description": "给定有向图 $G=(V,E)$ 。设 $P$ 是 $G$ 的一个简单路（顶点不相交）的集合。如果 $V$ 中每个顶点恰好在 $P$ 的一条路上，则称 $P$ 是 $G$ 的一个路径覆盖。$P$ 中路径可以从 $V$ 的任何一个定点开始，长度也是任意的，特别地，可以为 $0$。$G$ 的最小路径覆盖是 $G$ 所含路径条数最少的路径覆盖。设计一个有效算法求一个 DAG（有向无环图）$G$ 的最小路径覆盖。\n", "inputFormat": "第一行有两个正整数 $n$ 和 $m$。$n$ 是给定 DAG（有向无环图）$G$ 的顶点数，$m$ 是 $G$ 的边数。接下来的 $m$ 行，每行有两个正整数 $i$ 和 $j$ 表示一条有向边 $(i,j)$。", "outputFormat": "从第一行开始，每行输出一条路径。文件的最后一行是最少路径数。\n", "hint": "对于 $100\\%$ 的数据，$1\\leq n\\leq 150$，$1\\leq m\\leq 6000$。\n\n由 @FlierKing 提供 SPJ", "locale": "zh-CN"}}}
{"pid": "P2765", "type": "P", "difficulty": 5, "samples": [["4", "11\n1 8\n2 7 9\n3 6 10\n4 5 11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "网络流", "Special Judge", "网络流与线性规划 24 题"], "title": "魔术球问题", "background": "", "description": "假设有 $n$ 根柱子，现要按下述规则在这 $n$ 根柱子中依次放入编号为 $1$，$2$，$3$，...的球“\n\n1. 每次只能在某根柱子的最上面放球。\n\n2. 同一根柱子中，任何 $2$ 个相邻球的编号之和为完全平方数。\n\n试设计一个算法，计算出在 $n$ 根柱子上最多能放多少个球。例如，在 $4$ 根柱子上最多可放 $11$ 个球。\n\n对于给定的 $n$，计算在 $n$ 根柱子上最多能放多少个球。\n", "inputFormat": "只有一行一个整数 $n$，代表柱子数。", "outputFormat": "**本题存在 Special Judge**。\n\n请将 $n$ 根柱子上最多能放的球数以及相应的放置方案输出。\n\n输出的第一行是球数。\n\n接下来的 $n$ 行，每行若干个整数，代表一根柱子上的球的编号，数字间用单个空格隔开。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 55$。", "locale": "zh-CN", "translations": {"en": {"title": "Magic Ball Problem", "background": "", "description": "Assume there are $n$ rods. We insert balls labeled $1$, $2$, $3$, ... into these $n$ rods in order, following the rules below:\n\n1. Each time, you can only place a ball on the top of some rod.\n2. On the same rod, the sum of the labels of any $2$ adjacent balls is a perfect square.\n\nDesign an algorithm to compute the maximum number of balls that can be placed on $n$ rods. For example, with $4$ rods, at most $11$ balls can be placed.\n\nGiven $n$, compute the maximum number of balls that can be placed on $n$ rods.", "inputFormat": "There is only one line containing an integer $n$, representing the number of rods.", "outputFormat": "**This problem has a Special Judge.**\n\nPlease output the maximum number of balls that can be placed on $n$ rods, along with a corresponding placement scheme.\n\nThe first line is the number of balls.\n\nThe next $n$ lines each contain several integers, representing the labels of the balls on one rod, separated by a single space.", "hint": "Constraints\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 55$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "魔术球问题", "background": "", "description": "假设有 $n$ 根柱子，现要按下述规则在这 $n$ 根柱子中依次放入编号为 $1$，$2$，$3$，...的球“\n\n1. 每次只能在某根柱子的最上面放球。\n\n2. 同一根柱子中，任何 $2$ 个相邻球的编号之和为完全平方数。\n\n试设计一个算法，计算出在 $n$ 根柱子上最多能放多少个球。例如，在 $4$ 根柱子上最多可放 $11$ 个球。\n\n对于给定的 $n$，计算在 $n$ 根柱子上最多能放多少个球。\n", "inputFormat": "只有一行一个整数 $n$，代表柱子数。", "outputFormat": "**本题存在 Special Judge**。\n\n请将 $n$ 根柱子上最多能放的球数以及相应的放置方案输出。\n\n输出的第一行是球数。\n\n接下来的 $n$ 行，每行若干个整数，代表一根柱子上的球的编号，数字间用单个空格隔开。", "hint": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 55$。", "locale": "zh-CN"}}}
{"pid": "P2766", "type": "P", "difficulty": 6, "samples": [["4\n3 6 2 5", "2\n2\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "网络流", "O2优化", "网络流与线性规划 24 题"], "title": "最长不下降子序列问题", "background": "", "description": "给定正整数序列 $x_1 \\ldots, x_n$。\n\n1. 计算其最长不下降子序列的长度 $s$。\n2. 如果每个元素只允许使用一次，计算从给定的序列中最多可取出多少个长度为 $s$ 的不下降子序列。\n3. 如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$（其他元素仍然只允许使用一次），则从给定序列中最多可取出多少个**不同的**长度为 $s$ 的不下降子序列。\n\n令 $a_1, a_2, \\ldots, a_s$ 为构造 $S$ 时所使用的下标，$b_1, b_2, \\ldots, b_s$ 为构造 $T$ 时所使用的下标。且 $\\forall i \\in [1,s-1]$，都有 $a_i \\lt a_{i+1}$，$b_i \\lt b_{i+1}$。则 $S$ 和 $T$ **不同**，当且仅当 $\\exists i \\in [1,s]$，使得 $a_i \\neq b_i$。", "inputFormat": "第一行有一个正整数 $n$，表示给定序列的长度。接下来的若干行有 $n$ 个正整数$x_1, ..., x_n$。\n", "outputFormat": "- 第 1 行是最长不下降子序列的长度 $s$。\n- 第 2 行是可取出的长度为 $s$ 的不下降子序列个数。\n- 第 3 行是允许在取出的序列中多次使用 $x_1$ 和 $x_n$ 时可取出的长度为 $s$ 的**不同的**不下降子序列个数。\n", "hint": "$1 \\le n\\le 500$", "locale": "zh-CN", "translations": {"en": {"title": "Longest Non-decreasing Subsequence Problem", "background": "", "description": "Given a sequence of positive integers $x_1 \\ldots, x_n$.\n\n1. Compute the length $s$ of its longest non-decreasing subsequence.\n2. If each element is allowed to be used at most once, compute the maximum number of non-decreasing subsequences of length $s$ that can be extracted from the given sequence.\n3. If, in the extracted subsequences, $x_1$ and $x_n$ are allowed to be used multiple times (all other elements are still allowed to be used at most once), compute the maximum number of **different** non-decreasing subsequences of length $s$ that can be extracted from the given sequence.\n\nLet $a_1, a_2, \\ldots, a_s$ be the indices used to construct $S$, and $b_1, b_2, \\ldots, b_s$ be the indices used to construct $T$. For all $i \\in [1,s-1]$, we have $a_i \\lt a_{i+1}$ and $b_i \\lt b_{i+1}$. Then $S$ and $T$ are **different** if and only if there exists $i \\in [1,s]$ such that $a_i \\neq b_i$.", "inputFormat": "The first line contains a positive integer $n$, which is the length of the given sequence. The following lines contain $n$ positive integers $x_1, ..., x_n$.", "outputFormat": "- The first line is the length $s$ of the longest non-decreasing subsequence.\n- The second line is the maximum number of non-decreasing subsequences of length $s$ that can be extracted.\n- The third line is the maximum number of **different** non-decreasing subsequences of length $s$ that can be extracted when $x_1$ and $x_n$ are allowed to be used multiple times in the extracted subsequences.", "hint": "Constraints: $1 \\le n \\le 500$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "最长不下降子序列问题", "background": "", "description": "给定正整数序列 $x_1 \\ldots, x_n$。\n\n1. 计算其最长不下降子序列的长度 $s$。\n2. 如果每个元素只允许使用一次，计算从给定的序列中最多可取出多少个长度为 $s$ 的不下降子序列。\n3. 如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$（其他元素仍然只允许使用一次），则从给定序列中最多可取出多少个**不同的**长度为 $s$ 的不下降子序列。\n\n令 $a_1, a_2, \\ldots, a_s$ 为构造 $S$ 时所使用的下标，$b_1, b_2, \\ldots, b_s$ 为构造 $T$ 时所使用的下标。且 $\\forall i \\in [1,s-1]$，都有 $a_i \\lt a_{i+1}$，$b_i \\lt b_{i+1}$。则 $S$ 和 $T$ **不同**，当且仅当 $\\exists i \\in [1,s]$，使得 $a_i \\neq b_i$。", "inputFormat": "第一行有一个正整数 $n$，表示给定序列的长度。接下来的若干行有 $n$ 个正整数$x_1, ..., x_n$。\n", "outputFormat": "- 第 1 行是最长不下降子序列的长度 $s$。\n- 第 2 行是可取出的长度为 $s$ 的不下降子序列个数。\n- 第 3 行是允许在取出的序列中多次使用 $x_1$ 和 $x_n$ 时可取出的长度为 $s$ 的**不同的**不下降子序列个数。\n", "hint": "$1 \\le n\\le 500$", "locale": "zh-CN"}}}
{"pid": "P2767", "type": "P", "difficulty": 6, "samples": [["2 2", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["动态规划 DP", "图论", "树形数据结构", "洛谷原创"], "title": "树的数量", "background": "", "description": "求出包含 $n$ 个节点（无标号）的有根 $m$ 叉树的个数，对 $10\\,007$ 取模。\n\n两个有根树相同，当且仅当其根节点相同，且**从左到右**每一棵子树也相同。特别地，两个有根树均为空树，视为两个有根树相同。", "inputFormat": "输入两个整数 $n$，$m$。\n", "outputFormat": "输出包含 $n$ 个节点（无标号）的有根 $m$ 叉树的个数，对 $10\\,007$ 取模后的值。", "hint": "$n,m \\leq 127$", "locale": "zh-CN", "translations": {"en": {"title": "Number of Trees", "background": "", "description": "Compute the number of rooted $m$-ary trees (unlabeled) with $n$ nodes, modulo $10\\,007$.\n\nTwo rooted trees are identical if and only if their roots are identical and, from left to right, each subtree is also identical. In particular, if both rooted trees are empty, they are considered identical.", "inputFormat": "Input two integers $n$, $m$.", "outputFormat": "Output the number of rooted $m$-ary trees (unlabeled) with $n$ nodes, modulo $10\\,007$.", "hint": "Constraints: $n, m \\leq 127$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "树的数量", "background": "", "description": "求出包含 $n$ 个节点（无标号）的有根 $m$ 叉树的个数，对 $10\\,007$ 取模。\n\n两个有根树相同，当且仅当其根节点相同，且**从左到右**每一棵子树也相同。特别地，两个有根树均为空树，视为两个有根树相同。", "inputFormat": "输入两个整数 $n$，$m$。\n", "outputFormat": "输出包含 $n$ 个节点（无标号）的有根 $m$ 叉树的个数，对 $10\\,007$ 取模后的值。", "hint": "$n,m \\leq 127$", "locale": "zh-CN"}}}
{"pid": "P2768", "type": "P", "difficulty": 5, "samples": [["2\n2 1\n3 2", "2\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "2016", "洛谷原创", "矩阵加速", "组合数学", "容斥原理", "洛谷月赛"], "title": "珍珠项链", "background": "小 L 通过泥萌的帮助，成功解决了牛栏的修建问题。奶牛们觉得主人非常厉害，于是再也不敢偷懒，母牛们奋力挤奶，生娃。子子孙孙无穷匮也！小 L 于是成为了一代富豪！\n\n但是一直困扰小 L 的就是单身问题！小 L 经过长久的寻觅，小 L 终于找到了一个心仪的漂亮妹子。于是，小 L 打算在 520 那天给妹子一个惊喜！（虽然小 L 很节约，但是对妹子还是很阔绰的！）\n", "description": "小 L 决定用 $K$ 种珍珠为妹子做一串举世无双的珍珠垂饰。珍珠垂饰是由珍珠连接而成的，其长度可以认为就是珍珠垂饰上珍珠的个数。小 L 现在腰缠万贯，每种珍珠他都拥有 $N$ 颗。根据将珍珠垂饰打开后珍珠不同的排列顺序可以区别不同种类的项链。现在，小 L 好奇自己可以组成多少种长度为 $1$ 至 $N$ 的不同的珍珠垂饰？当然，为显富有，每串珍珠垂饰都要必须由 $K$ 种珍珠连成。 答案取模 $1234567891$。\n\n这一定难不倒聪明的你吧！如果你能帮小 $L$ 解决这个问题，也许他会把最后的资产分给你 $\\frac{1}{4}$  哦！\n", "inputFormat": "输入包含多组数据。第一行是一个整数 $T$，表示测试数据的个数。每组数据占一行，包含两个整数 $N$ 和 $K$，用一个空格隔开。\n", "outputFormat": "每组数据输出仅一行，包含一个整数，表示项链的种类数。\n", "hint": "对于 $40\\%$ 的数据，满足 $1\\leq N\\leq 10^5$,  $0\\leq K\\leq 30$。\n\n对于 $100\\%$ 的数据，满足 $T \\leq 10$，$1\\leq N\\leq 10^9$，$0\\leq K\\leq 30$。\n\n对于 $70\\%\\sim100\\%$ 的数据，时限 $10$ ms。\n", "locale": "zh-CN", "translations": {"en": {"title": "Pearl Necklace", "background": "With everyone’s help, Xiao L successfully solved the cowshed construction problem. The cows think their owner is amazing, so they no longer dare to slack off. The cows work hard to produce milk and have calves. Generations continue endlessly! Xiao L has thus become a wealthy man!\n\nHowever, what still troubles Xiao L is being single! After a long search, he finally found a lovely girl he likes. So, he plans to give her a surprise on 520! (Although Xiao L is frugal, he is still generous to the girl!)", "description": "Xiao L decides to make a unique pearl necklace using $K$ kinds of pearls. A pearl necklace is a sequence of pearls, and its length is the number of pearls in the sequence. Now he is very rich and owns $N$ pearls of each kind. Two necklaces are considered different if, when laid out straight, their pearls are in different linear orders. Xiao L wonders how many different necklaces of lengths from $1$ to $N$ he can make. To show wealth, each necklace must use all $K$ kinds of pearls. Output the answer modulo $1234567891$.\n\nThis should be easy for you! If you can help Xiao L solve this problem, he might give you $1/4$ of his assets!", "inputFormat": "The input contains multiple testdata. The first line is an integer $T$, which is the number of testdata. Each testdata occupies one line and contains two integers $N$ and $K$, separated by a space.", "outputFormat": "For each testdata, output exactly one line containing one integer, which is the number of kinds of necklaces.", "hint": "- 40%: $1 \\le N \\le 100000$, $0 \\le K \\le 30$.\n- 100%: $T \\le 10$, $1 \\le N \\le 10^9$, $0 \\le K \\le 30$.\n- 70\\%–100\\%: time limit $10$ ms.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "珍珠项链", "background": "小 L 通过泥萌的帮助，成功解决了牛栏的修建问题。奶牛们觉得主人非常厉害，于是再也不敢偷懒，母牛们奋力挤奶，生娃。子子孙孙无穷匮也！小 L 于是成为了一代富豪！\n\n但是一直困扰小 L 的就是单身问题！小 L 经过长久的寻觅，小 L 终于找到了一个心仪的漂亮妹子。于是，小 L 打算在 520 那天给妹子一个惊喜！（虽然小 L 很节约，但是对妹子还是很阔绰的！）\n", "description": "小 L 决定用 $K$ 种珍珠为妹子做一串举世无双的珍珠垂饰。珍珠垂饰是由珍珠连接而成的，其长度可以认为就是珍珠垂饰上珍珠的个数。小 L 现在腰缠万贯，每种珍珠他都拥有 $N$ 颗。根据将珍珠垂饰打开后珍珠不同的排列顺序可以区别不同种类的项链。现在，小 L 好奇自己可以组成多少种长度为 $1$ 至 $N$ 的不同的珍珠垂饰？当然，为显富有，每串珍珠垂饰都要必须由 $K$ 种珍珠连成。 答案取模 $1234567891$。\n\n这一定难不倒聪明的你吧！如果你能帮小 $L$ 解决这个问题，也许他会把最后的资产分给你 $\\frac{1}{4}$  哦！\n", "inputFormat": "输入包含多组数据。第一行是一个整数 $T$，表示测试数据的个数。每组数据占一行，包含两个整数 $N$ 和 $K$，用一个空格隔开。\n", "outputFormat": "每组数据输出仅一行，包含一个整数，表示项链的种类数。\n", "hint": "对于 $40\\%$ 的数据，满足 $1\\leq N\\leq 10^5$,  $0\\leq K\\leq 30$。\n\n对于 $100\\%$ 的数据，满足 $T \\leq 10$，$1\\leq N\\leq 10^9$，$0\\leq K\\leq 30$。\n\n对于 $70\\%\\sim100\\%$ 的数据，时限 $10$ ms。\n", "locale": "zh-CN"}}}
{"pid": "P2769", "type": "P", "difficulty": 4, "samples": [["3\n1 4 5\n2\n3 8\n", "6\n"], ["3\n3 1 10\n2\n8 3\n", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP"], "title": "猴子上树", "background": "", "description": "在猴村有一条笔直的山路，这条山路很窄，宽度忽略不计。有 $n$ 只猴子正站在山路上静静地观望今天来参加比赛的各位同学。用一个正整数 $X_i$ 表示第 $i$ 只猴子所站位置，任意两只猴子的所站位置互不相同。在这条山路的 $m$ 个位置上种着一些高大的树木，正整数 $Y_j$ 表示第 $j$ 棵树木所在的位置，任意两棵树的位置互不相同。\n\n正当猴子们聚精会神的欣赏各位高超编程技能 聚精会神的欣赏各位高超编程技能时，一只老虎大摇摆的走了过来。猴子们吓得直冒冷汗，第一反应就是找棵大树爬上去这样能避免被老虎咬死或者吃掉（不考虑老虎上树问题）。\n\n在位置 $a$ 的猴子跑到在位置 $b$ 的大树上，需要消耗能量为 $|a-b|$（即 $a-b$ 的绝对值）。为了尽可能有效利用这些大树避难，每棵上至少要一只猴子。\n请编程计算 $n$ 只猴子全部上树最少需要消耗多少能量？\n", "inputFormat": "输入共 4 行。\n\n第 1 行一个整数 $n$，表示猴子的数量。\n\n第 2 行 $n$ 个整数，第 $i$ 个整数 $X_i$ 表示第 $i$ 只猴子所在的位置。\n\n第 3 行一个整数 $m$，表示大树的数量。\n\n第 4 行 $m$ 个整数，第 $j$ 个整数表示第 $j$ 棵大树所在的位置。\n", "outputFormat": "输出一行，一个整数表示 $n$ 只猴子全部上树最少需要消耗的能量。\n", "hint": "$30%$ 的数据，$1\\le n \\le 500$，$1≤X_i,Y_i≤10^5$。\n\n$100%$ 的数据，$1≤n≤5000$，$1≤m≤n$，$1≤Xi,Yi≤10^9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Monkeys Climb Trees", "background": "", "description": "In Monkey Village, there is a straight mountain path that is very narrow, and its width can be ignored. There are $n$ monkeys standing on the path watching the students who came to compete today. Let a positive integer $X_i$ denote the position of the $i$-th monkey; no two monkeys stand at the same position. There are $m$ tall trees planted at positions along this path. Let a positive integer $Y_j$ denote the position of the $j$-th tree; no two trees occupy the same position.\n\nWhile the monkeys were intently admiring everyone's excellent programming skills, a tiger swaggered over. The monkeys broke into a cold sweat. Their first reaction was to find a tall tree to climb, which would help them avoid being bitten or eaten by the tiger (do not consider the tiger climbing trees).\n\nIf the monkey at position $a$ runs to the tree at position $b$, the energy cost is $|a - b|$. To make the most effective use of these trees for shelter, each tree must have at least one monkey. Please compute the minimum total energy required for all $n$ monkeys to climb onto trees.", "inputFormat": "The input consists of 4 lines.\n\n- Line 1: an integer $n$, the number of monkeys.\n- Line 2: $n$ integers; the $i$-th integer $X_i$ is the position of the $i$-th monkey.\n- Line 3: an integer $m$, the number of trees.\n- Line 4: $m$ integers; the $j$-th integer is the position $Y_j$ of the $j$-th tree.", "outputFormat": "Output one line with a single integer: the minimum total energy required for all $n$ monkeys to climb onto trees.", "hint": "For $30\\%$ of the testdata, $1 \\le n \\le 500$, $1 \\le X_i, Y_i \\le 10^5$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 5000$, $1 \\le m \\le n$, $1 \\le X_i, Y_i \\le 10^9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "猴子上树", "background": "", "description": "在猴村有一条笔直的山路，这条山路很窄，宽度忽略不计。有 $n$ 只猴子正站在山路上静静地观望今天来参加比赛的各位同学。用一个正整数 $X_i$ 表示第 $i$ 只猴子所站位置，任意两只猴子的所站位置互不相同。在这条山路的 $m$ 个位置上种着一些高大的树木，正整数 $Y_j$ 表示第 $j$ 棵树木所在的位置，任意两棵树的位置互不相同。\n\n正当猴子们聚精会神的欣赏各位高超编程技能 聚精会神的欣赏各位高超编程技能时，一只老虎大摇摆的走了过来。猴子们吓得直冒冷汗，第一反应就是找棵大树爬上去这样能避免被老虎咬死或者吃掉（不考虑老虎上树问题）。\n\n在位置 $a$ 的猴子跑到在位置 $b$ 的大树上，需要消耗能量为 $|a-b|$（即 $a-b$ 的绝对值）。为了尽可能有效利用这些大树避难，每棵上至少要一只猴子。\n请编程计算 $n$ 只猴子全部上树最少需要消耗多少能量？\n", "inputFormat": "输入共 4 行。\n\n第 1 行一个整数 $n$，表示猴子的数量。\n\n第 2 行 $n$ 个整数，第 $i$ 个整数 $X_i$ 表示第 $i$ 只猴子所在的位置。\n\n第 3 行一个整数 $m$，表示大树的数量。\n\n第 4 行 $m$ 个整数，第 $j$ 个整数表示第 $j$ 棵大树所在的位置。\n", "outputFormat": "输出一行，一个整数表示 $n$ 只猴子全部上树最少需要消耗的能量。\n", "hint": "$30%$ 的数据，$1\\le n \\le 500$，$1≤X_i,Y_i≤10^5$。\n\n$100%$ 的数据，$1≤n≤5000$，$1≤m≤n$，$1≤Xi,Yi≤10^9$。\n", "locale": "zh-CN"}}}
{"pid": "P2770", "type": "P", "difficulty": 6, "samples": [["8 9\nVancouver\nYellowknife\nEdmonton\nCalgary\nWinnipeg\nToronto\nMontreal\nHalifax\nVancouver Edmonton\nVancouver Calgary\nCalgary Winnipeg\nWinnipeg Toronto\nToronto Halifax\nMontreal Halifax\nEdmonton Montreal\nEdmonton Yellowknife\nEdmonton Calgary", "7\nVancouver\nEdmonton\nMontreal\nHalifax\nToronto\nWinnipeg\nCalgary\nVancouver "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["网络流", "Special Judge", "O2优化", "网络流与线性规划 24 题"], "title": "航空路线问题", "background": "", "description": "给定一张航空图，图中顶点代表城市，边代表两城市间的直通航线，并且不存在任何两个城市在同一条经线上。现要求找出一条满足下述限制条件的且途经城市最多的旅行路线。\n\n1. 从最西端城市出发，单向从西向东途经若干城市到达最东端城市，然后再单向从东向西飞回起点（可途经若干城市）。\n\n2. 除起点城市外，任何城市只能访问一次。\n\n对于给定的航空图，试设计一个算法找出一条满足要求的最佳航空旅行路线。", "inputFormat": "输入的第一行是用空格隔开的两个整数，分别代表航空图的点数 $n$ 和边数 $v$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个字符串，第 $(i + 1)$ 行的字符串代表从西向东第 $i$ 座城市的名字 $s_i$。\n\n第 $(n + 2)$ 到第 $(n + v + 1)$ 行，每行两个字符串 $x, y$，代表城市 $x$ 和城市 $y$ 之间存在一条直通航线。", "outputFormat": "**本题存在 Special Judge**。\n\n请首先判断是否存在满足要求的路线，若存在，请给出一种旅行的方案。\n\n如果存在路线，输出格式为：\n\n- 请在第一行输出一个整数 $m$，代表途径最多的城市数。\n- 在第 $2$ 到第 $(m + 2)$ 行，每行一个字符串，第 $(i + 1)$ 行的字符串代表旅行路线第 $i$ 个经过的城市的名字。请注意第 $1$ 和第 $m$ 个城市必然是出发城市名。\n\n否则请输出一行一个字符串 ``No Solution!``。", "hint": "**数据规模与约定**\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n < 100$，$1 \\leq v \\leq \\frac{n \\times (n - 1)}{2}$，$s_i$ 的长度不超过 $15$，且仅可能包含大小写字母与数字，$x, y$ 一定是输入中给出的城市名，且不会有同一组 $x, y$ 被给出两次。\n", "locale": "zh-CN", "translations": {"en": {"title": "Air Route Problem", "background": "", "description": "Given an airline map in which vertices represent cities and edges represent direct routes between two cities, and no two cities lie on the same meridian. Find a travel route that satisfies the following constraints and visits the maximum number of cities.\n\n1. Start from the westernmost city, fly strictly from west to east through several cities to the easternmost city, then fly strictly from east to west back to the starting city (possibly via several cities).\n\n2. Except for the starting city, any city may be visited at most once.\n\nFor the given airline map, design an algorithm to find an optimal airline travel itinerary that meets the requirements.", "inputFormat": "The first line contains two integers separated by a space, the number of vertices $n$ and the number of edges $v$.\n\nLines $2$ to $n + 1$: each line contains a string. The $(i + 1)$-th line gives the name $s_i$ of the $i$-th city from west to east.\n\nLines $n + 2$ to $n + v + 1$: each line contains two strings $x, y$, indicating that there is a direct route between city $x$ and city $y$.", "outputFormat": "This problem uses Special Judge.\n\nFirst determine whether there exists a route that meets the requirements. If it exists, output one valid itinerary.\n\nIf a route exists, output:\n- On the first line, output an integer $m$, the maximum number of cities visited.\n- Then output $m$ lines, one string per line. The $i$-th line contains the name of the $i$-th city in the itinerary. Note that the $1$-st and the $m$-th cities are necessarily the starting city.\n\nOtherwise, output a single line containing the string ``No Solution!``.", "hint": "Constraints and Notes\n\nFor $100\\%$ of the testdata, it is guaranteed that $1 \\leq n < 100$, $1 \\leq v \\leq \\frac{n \\times (n - 1)}{2}$, the length of $s_i$ does not exceed $15$ and contains only letters and digits, $x, y$ are city names given in the input, and no pair $x, y$ appears more than once.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "航空路线问题", "background": "", "description": "给定一张航空图，图中顶点代表城市，边代表两城市间的直通航线，并且不存在任何两个城市在同一条经线上。现要求找出一条满足下述限制条件的且途经城市最多的旅行路线。\n\n1. 从最西端城市出发，单向从西向东途经若干城市到达最东端城市，然后再单向从东向西飞回起点（可途经若干城市）。\n\n2. 除起点城市外，任何城市只能访问一次。\n\n对于给定的航空图，试设计一个算法找出一条满足要求的最佳航空旅行路线。", "inputFormat": "输入的第一行是用空格隔开的两个整数，分别代表航空图的点数 $n$ 和边数 $v$。\n\n第 $2$ 到第 $(n + 1)$ 行，每行一个字符串，第 $(i + 1)$ 行的字符串代表从西向东第 $i$ 座城市的名字 $s_i$。\n\n第 $(n + 2)$ 到第 $(n + v + 1)$ 行，每行两个字符串 $x, y$，代表城市 $x$ 和城市 $y$ 之间存在一条直通航线。", "outputFormat": "**本题存在 Special Judge**。\n\n请首先判断是否存在满足要求的路线，若存在，请给出一种旅行的方案。\n\n如果存在路线，输出格式为：\n\n- 请在第一行输出一个整数 $m$，代表途径最多的城市数。\n- 在第 $2$ 到第 $(m + 2)$ 行，每行一个字符串，第 $(i + 1)$ 行的字符串代表旅行路线第 $i$ 个经过的城市的名字。请注意第 $1$ 和第 $m$ 个城市必然是出发城市名。\n\n否则请输出一行一个字符串 ``No Solution!``。", "hint": "**数据规模与约定**\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n < 100$，$1 \\leq v \\leq \\frac{n \\times (n - 1)}{2}$，$s_i$ 的长度不超过 $15$，且仅可能包含大小写字母与数字，$x, y$ 一定是输入中给出的城市名，且不会有同一组 $x, y$ 被给出两次。\n", "locale": "zh-CN"}}}
{"pid": "P2771", "type": "P", "difficulty": 3, "samples": [["14\nNNNESWWWSSEEEE", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "字符串", "搜索", "2016", "USACO"], "title": "[USACO16JAN] Build Gates S", "background": "", "description": "FarmerJohn 打算在他农场的一部分，建设一个围栏。但是因为没有认真做事，建造完成后，围栏变成一个很奇怪的形状。\n\n具体来说，FJ 从 $(0,0)$ 出发，走了 $N$ 步，每步移动一单位（向东、向南、向西或向北）。\n\n他走过的每一步，都会留下一段单位长度的围栏。例如，如果他的第一步向北，他建造一单位从 $(0,0)$ 到 $(0,1)$ 的围栏。\n\nFJ 可能重复到达点多次，他也可能重复建造一段围栏多次。如果他的路径穿过一段已经建成的围栏，他的围栏也有可能会有交叉。\n\n不用说，FJ 看到完成的围栏时，一定很沮丧。特别的，他发现一些区域被围栏封闭起来，从而无法到达。FJ 想在围栏上，安装一些门来解决这个问题。\n\n门可以安装在任意一段单位长度（注：必须是之前走过的某一步）的围栏上，从而可以穿越这段围栏的两侧。\n\n请计算 FJ 最少需要安装多少个门，才能保证农场上任意区域到任意区域都可到达。", "inputFormat": "第一行一个整数 $N$。\n\n第二行包含一个长度为 $N$ 的字符串，描述 FJ 的路径。每个字符为 $\\tt N$（北），$\\tt E$（东），$\\tt S$（南），或 $\\tt W$（西）。", "outputFormat": "输出一个整数，表示为了保证农场所有区域的连通性，FJ 最少需要安装多少个门。", "hint": "注意，如果农场初始连通，答案就是 $0$。\n\n### 数据范围\n\n$1\\le n\\le 1000$。\n", "locale": "zh-CN", "translations": {"en": {"title": "[USACO16JAN] Build Gates S", "background": "", "description": "Farmer John (FJ) plans to build a fence on part of his farm. Because he did not work carefully, after construction the fence ends up with a very strange shape.\n\nSpecifically, FJ starts at $(0, 0)$ and walks $N$ steps, each moving one unit (to the east, south, west, or north).\n\nFor each step he takes, he leaves behind a unit-length segment of fence. For example, if his first step is north, he builds a unit of fence from $(0, 0)$ to $(0, 1)$.\n\nFJ may visit the same point multiple times, and he may also build the same fence segment multiple times. If his path crosses a segment that has already been built, the fence may have intersections.\n\nNeedless to say, FJ is dismayed when he sees the finished fence. In particular, he finds that some regions are enclosed by the fence and therefore cannot be reached. FJ wants to install some gates on the fence to fix this problem.\n\nA gate can be installed on any unit-length fence segment (note: it must be one of the steps he previously took), allowing passage through that segment from one side of the fence to the other.\n\nCompute the minimum number of gates FJ needs to install to guarantee that any region on the farm is reachable from any other region.", "inputFormat": "The first line contains an integer $N$.\n\nThe second line contains a string of length $N$ describing FJ’s path. Each character is $\\tt N$ (north), $\\tt E$ (east), $\\tt S$ (south), or $\\tt W$ (west).", "outputFormat": "Output a single integer, the minimum number of gates needed to ensure that all regions of the farm are connected.", "hint": "Note that if the farm is initially connected, the answer is $0$.\nConstraints\n$1\\le n\\le 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[USACO16JAN] Build Gates S", "background": "", "description": "FarmerJohn 打算在他农场的一部分，建设一个围栏。但是因为没有认真做事，建造完成后，围栏变成一个很奇怪的形状。\n\n具体来说，FJ 从 $(0,0)$ 出发，走了 $N$ 步，每步移动一单位（向东、向南、向西或向北）。\n\n他走过的每一步，都会留下一段单位长度的围栏。例如，如果他的第一步向北，他建造一单位从 $(0,0)$ 到 $(0,1)$ 的围栏。\n\nFJ 可能重复到达点多次，他也可能重复建造一段围栏多次。如果他的路径穿过一段已经建成的围栏，他的围栏也有可能会有交叉。\n\n不用说，FJ 看到完成的围栏时，一定很沮丧。特别的，他发现一些区域被围栏封闭起来，从而无法到达。FJ 想在围栏上，安装一些门来解决这个问题。\n\n门可以安装在任意一段单位长度（注：必须是之前走过的某一步）的围栏上，从而可以穿越这段围栏的两侧。\n\n请计算 FJ 最少需要安装多少个门，才能保证农场上任意区域到任意区域都可到达。", "inputFormat": "第一行一个整数 $N$。\n\n第二行包含一个长度为 $N$ 的字符串，描述 FJ 的路径。每个字符为 $\\tt N$（北），$\\tt E$（东），$\\tt S$（南），或 $\\tt W$（西）。", "outputFormat": "输出一个整数，表示为了保证农场所有区域的连通性，FJ 最少需要安装多少个门。", "hint": "注意，如果农场初始连通，答案就是 $0$。\n\n### 数据范围\n\n$1\\le n\\le 1000$。\n", "locale": "zh-CN"}}}
{"pid": "P2772", "type": "P", "difficulty": 3, "samples": [["5 \n1 2 2 2 3 1 2 3 1 4", "(1,4),(2,3),(3,1)"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["模拟", "贪心"], "title": "寻找平面上的极大点", "background": null, "description": "在一个平面上，如果有两个点 $(x,y),(a,b)$，如果说 $(x,y)$ 支配了 $(a,b)$，这是指 $x\\ge a,y\\ge b$。\n\n用图形来看就是 $(a,b)$ 坐落在以 $(x,y)$ 为右上角的一个无限的区域内。\n\n给定 $n$ 个点的集合，一定存在若干个点，它们不会被集合中的任何一点所支配，这些点叫做极大值点。\n\n编程找出所有的极大点，按照 $x$ 坐标由小到大，输出极大点的坐标。", "inputFormat": "输入包括两行，第一行是正整数 $n$ ，表示是点数，第二行包含 $n$ 个点的坐标，坐标值都是整数，输入数据中不存在坐标相同的点。", "outputFormat": "按 $x$ 轴坐标最小到大的顺序输出所有极大点。\n\n输出格式为:$(x1,y1),(x2,y2),\\cdots,(xk,yk)$\n\n注意：输出的每个点之间有 `,` 分隔，最后一个点之后没有 `,`，少输出和多输出都会被判错。", "hint": "对于 $50\\%$ 的数据：$1\\le n\\le100$；$0\\le x,y\\le10^5$；\n\n对于 $100\\%$ 的数据：$1\\le n\\le5\\times10^5$；$0\\le x,y\\le10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "Finding Maximal Points on the Plane", "background": "", "description": "On a plane, for two points $(x,y)$ and $(a,b)$, we say that $(x,y)$ dominates $(a,b)$ if $x\\ge a$ and $y\\ge b$.\n\nGeometrically, this means that $(a,b)$ lies in the unbounded region whose upper-right corner is $(x,y)$.\n\nGiven a set of $n$ points, there exist some points that are not dominated by any other point in the set; these points are called maximal points.\n\nWrite a program to find all maximal points and output their coordinates in increasing order of the $x$-coordinate.", "inputFormat": "The input consists of two lines. The first line is a positive integer $n$, the number of points. The second line contains $n$ points’ coordinates. All coordinates are integers. No two points in the input share the same coordinates.", "outputFormat": "Output all maximal points in increasing order of the $x$-coordinate.\n\nThe output format is: $(x1,y1),(x2,y2),\\cdots,(xk,yk)$.\n\nNote: Each point is separated by `,`, and there is no `,` after the last point. Missing or extra output will be judged incorrect.", "hint": "For $50\\%$ of the testdata: $1\\le n\\le 100$; $0\\le x,y\\le 10^5$.\n\nFor $100\\%$ of the testdata: $1\\le n\\le 5\\times 10^5$; $0\\le x,y\\le 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "寻找平面上的极大点", "background": null, "description": "在一个平面上，如果有两个点 $(x,y),(a,b)$，如果说 $(x,y)$ 支配了 $(a,b)$，这是指 $x\\ge a,y\\ge b$。\n\n用图形来看就是 $(a,b)$ 坐落在以 $(x,y)$ 为右上角的一个无限的区域内。\n\n给定 $n$ 个点的集合，一定存在若干个点，它们不会被集合中的任何一点所支配，这些点叫做极大值点。\n\n编程找出所有的极大点，按照 $x$ 坐标由小到大，输出极大点的坐标。", "inputFormat": "输入包括两行，第一行是正整数 $n$ ，表示是点数，第二行包含 $n$ 个点的坐标，坐标值都是整数，输入数据中不存在坐标相同的点。", "outputFormat": "按 $x$ 轴坐标最小到大的顺序输出所有极大点。\n\n输出格式为:$(x1,y1),(x2,y2),\\cdots,(xk,yk)$\n\n注意：输出的每个点之间有 `,` 分隔，最后一个点之后没有 `,`，少输出和多输出都会被判错。", "hint": "对于 $50\\%$ 的数据：$1\\le n\\le100$；$0\\le x,y\\le10^5$；\n\n对于 $100\\%$ 的数据：$1\\le n\\le5\\times10^5$；$0\\le x,y\\le10^5$。", "locale": "zh-CN"}}}
{"pid": "P2773", "type": "P", "difficulty": 3, "samples": [["10 10 0 0\n3 5 1 1", "0\n7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": [], "title": "漂亮字串", "background": "", "description": "Caima认为O和X是最优美的两个字母，由O、X组成的串是最优美的串。在这些最优美的串中，如果任意只包含X的字串，长度不超过maxX，任意只包含O的子串，长度不超过maxO，且整个串最多有countO个O，countX个X。那么这个就是超级优美无敌串。现在Caima想知道最长的超级优美无敌串有多长，希望你告诉他。\n", "inputFormat": "输入包含多行，至文件结束为止；\n\n每行四个数，依次是CountO、CountX、maxO、maxX.\n\nCountO、CountX、maxO、maxX均大于等于0小于等于1000000\n", "outputFormat": "每组数据输出一行，一个数表示最长的超级优美无敌串的长度\n", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "Beautiful String", "background": "", "description": "Caima believes that O and X are the two most beautiful letters, and a string composed of O and X is the most beautiful string. Among these strings, if any substring that consists only of X has length at most maxX, any substring that consists only of O has length at most maxO, and the entire string contains at most countO letters O and at most countX letters X, then it is a \"super beautiful unbeatable\" string. Now Caima wants to know the length of the longest such string. Please tell him.", "inputFormat": "The input contains multiple lines, until EOF.  \nEach line has four numbers, in order: countO, countX, maxO, maxX.  \nAll of countO, countX, maxO, maxX are integers in the range [0, 1000000].", "outputFormat": "For each dataset, output one line with a single number, which is the length of the longest \"super beautiful unbeatable\" string.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "漂亮字串", "background": "", "description": "Caima认为O和X是最优美的两个字母，由O、X组成的串是最优美的串。在这些最优美的串中，如果任意只包含X的字串，长度不超过maxX，任意只包含O的子串，长度不超过maxO，且整个串最多有countO个O，countX个X。那么这个就是超级优美无敌串。现在Caima想知道最长的超级优美无敌串有多长，希望你告诉他。\n", "inputFormat": "输入包含多行，至文件结束为止；\n\n每行四个数，依次是CountO、CountX、maxO、maxX.\n\nCountO、CountX、maxO、maxX均大于等于0小于等于1000000\n", "outputFormat": "每组数据输出一行，一个数表示最长的超级优美无敌串的长度\n", "hint": "", "locale": "zh-CN"}}}
