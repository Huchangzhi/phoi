{"pid": "P5852", "type": "P", "difficulty": 5, "samples": [["5 18\n1 2\n1 3\n3 4\n3 5\n1 4 1\n2 1\n2 2\n2 3\n2 4\n2 5\n1 5 1\n2 1\n2 2\n2 3\n2 4\n2 5\n1 1 1\n2 1\n2 2\n2 3\n2 4\n2 5\n", "1\n0\n1\n1\n0\n2\n0\n2\n1\n1\n5\n1\n3\n1\n1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["树形数据结构", "2019", "USACO", "树状数组"], "title": "[USACO19DEC] Bessie's Snow Cow P", "background": null, "description": "农场下雪啦！Bessie 和往年开冬一样在堆雪牛。她之前是个写实派，总是想把她的雪牛堆得和个真牛一样。但今年不一样，受到来自东方的神秘力量的影响，她想来点抽象艺术，因此她想堆成一棵树的样子。这棵树由 $N$ 个雪球，$N-1$ 根树枝构成，每根树枝连接两个雪球，并且每两个雪球之间路径唯一。\n\nBessie 要给她的雪牛来点细节。因此她给其中一个雪球加了个鼻子，来表示这是他那抽象的牛的头，并且把它称作雪球 $1$。为了让雪牛更好看，她还要给某些雪球来点不同的颜色。于是，她用旧牛奶桶装满了颜料泼到雪牛上。这些颜料分别被编号为 $1,2,\\dots 10^5$，且每种颜色都无限量供应。\n\n当 Bessie 把一桶颜料泼到一个雪球上时，这个雪球子树上的所有雪球也会被染色（我们称雪球 $y$ 在雪球 $x$ 的子树里当且仅当雪球 $x$ 处在雪球 $y$ 到雪球 $1$ 的路径上）。Bessie 有着精确的泼颜料技术，因此在泼完一种颜料后，一个雪球上之前被染过的所有颜色依然清晰可见。例如，一个雪球之前显现出来颜色 $\\left[ 1,2,3 \\right]$，然后 Bessie 把装有 $4$ 号颜色的牛奶桶泼上去，那么这个雪球将显现出来颜色 $\\left[ 1,2,3,4 \\right]$。 在泼了几桶颜料以后，Bessie 可能想要了解她的雪牛有多五彩斑斓。令雪球 $x$ 的『颜色丰富度』为这个雪球被染上的不同颜色总数 ，当 Bessie 想了解雪球 $x$ 的相关信息时，你应该回答她雪球 $x$ 的子树中所有的雪球的颜色丰富度之和。\n\n救救孩子吧！", "inputFormat": "第一行，$N$ 和询问数 $Q$。\n\n接下来 $N-1$ 行每行两个用空格隔开的数 $a$ 和 $b$，表示雪球 $a$ 和 $b$ 中间有一根树枝相连。\n\n最后 $Q$ 行每行一个请求，格式及对应含义如下：\n\n - `1 x c`（修改）：表示 Bessie 把一桶装有颜色 $c$ 的颜料泼到雪球 $x$ ，使得其子树上所有雪球被染色。\n - `2 x`（询问）：询问雪球 $x$ 的子树的颜色丰富度之和。", "outputFormat": "对于每个询问，输出所询问子树的颜色丰富度之和。**为了防止溢出，你需要使用 64 位整数。**", "hint": "#### 样例解释\n执行完第一个修改后雪球 $4$ 被染上了颜色 $1$。\n\n执行完第二个修改后雪球 $4$ 和雪球 $5$ 被染上了颜色 $2$。\n\n执行完第三个修改后所有雪球都被染上了颜色 $1$。\n#### 数据范围\n对于测试点 $2,3$，$1\\le N\\le 10^2,1\\le Q\\le 2\\times 10^2$；\n\n对于测试点 $4-6$，$1\\le N\\le 10^3,1\\le Q\\le 2\\times 10^3$；\n\n对于 $100\\%$ 的数据，$1\\le N,\\ Q,\\ c \\le 10^5, 1\\le a,\\ b,\\ x \\le N$。\n\nUSACO 2019 December 铂金组T2", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19DEC] Bessie's Snow Cow P", "background": null, "description": "Snow has arrived on the farm, and as she does at the beginning of every winter,\nBessie is building a snow-cow! Most of the time, Bessie strives to make her\nsculpture look as much like a real cow as possible.  However, feeling\nartistically inspired, this year she decides to pursue a more abstract route and\nbuild a sculpture in the shape of a tree, consisting of $N$ snowballs\n$(1\\le N\\le 10^5)$ connected by  $N-1$ branches, each connecting a pair of\nsnowballs such that there is a  unique path between every pair of snowballs. \n\nBessie has added a nose to one of the snowballs, so it represents the head of\nthe abstract snow cow.  She designates it as snowball number 1.  To add more\nvisual interest, she plans to dye some of the snowballs different colors in an\nartistic fashion by filling old milk pails with colored dye and splashing them\nonto the sculpture.  Colors are identified by integers in the range\n$1 \\ldots 10^5$, and  Bessie has an unlimited supply of buckets filled with dyes\nof every possible color.\n\nWhen Bessie splashes a snowball with a bucket of dye, all the snowballs in its \nsubtree are also splashed with the same dye (snowball $y$ is in the subtree of\nsnowball $x$ if $x$ lies on the path from $y$ to the head snowball). By\nsplashing each color with great care, Bessie makes sure that all colors a \nsnowball has been splashed with will remain visible. For example, if a snowball\nhad colors $[1,2,3]$ and Bessie splashes it with color $4$, the snowball will\nthen have colors $[1,2,3,4]$. \n\nAfter splashing the snowballs some number of times, Bessie may also want to know\nhow colorful a part of her snow-cow is.  The \"colorfulness\" of a snowball $x$ is\nequal to the number of distinct colors $c$ such that snowball $x$ is colored\n$c$. If Bessie asks you about snowball $x$, you should reply with the sum of the\ncolorfulness values of all snowballs in the subtree of $x.$\n\nPlease help Bessie find the colorfulness of her snow-cow at certain points in\ntime.", "inputFormat": "The first line contains $N$ and the number of queries $Q$.\n\nThe next $N-1$ lines each contain two space-separated numbers $a$ and $b$, indicating that there is a branch connecting snowballs $a$ and $b$.\n\nThe last $Q$ lines each contain a request, with the format and corresponding meanings as follows:\n\n- `1 x c` (Modification): Indicates that Bessie pours a bucket of paint of color $c$ onto snowball $x$, dyeing all snowballs in its subtree.\n- `2 x` (Query): Queries the sum of colorfulness in the subtree of snowball $x$.", "outputFormat": "For each query, output the sum of colorfulness in the queried subtree. **To prevent overflow, you must use 64-bit integers.**", "hint": "After the first query of type $1$, snowball $4$ is dyed with color $1$.\n\nAfter the second query of type $1$, snowballs $4$ and $5$ are dyed with color $1$.\n\nAfter the third query of type $1$, all snowballs are dyed with color $1$.", "locale": "en"}, "zh-CN": {"title": "[USACO19DEC] Bessie's Snow Cow P", "background": null, "description": "农场下雪啦！Bessie 和往年开冬一样在堆雪牛。她之前是个写实派，总是想把她的雪牛堆得和个真牛一样。但今年不一样，受到来自东方的神秘力量的影响，她想来点抽象艺术，因此她想堆成一棵树的样子。这棵树由 $N$ 个雪球，$N-1$ 根树枝构成，每根树枝连接两个雪球，并且每两个雪球之间路径唯一。\n\nBessie 要给她的雪牛来点细节。因此她给其中一个雪球加了个鼻子，来表示这是他那抽象的牛的头，并且把它称作雪球 $1$。为了让雪牛更好看，她还要给某些雪球来点不同的颜色。于是，她用旧牛奶桶装满了颜料泼到雪牛上。这些颜料分别被编号为 $1,2,\\dots 10^5$，且每种颜色都无限量供应。\n\n当 Bessie 把一桶颜料泼到一个雪球上时，这个雪球子树上的所有雪球也会被染色（我们称雪球 $y$ 在雪球 $x$ 的子树里当且仅当雪球 $x$ 处在雪球 $y$ 到雪球 $1$ 的路径上）。Bessie 有着精确的泼颜料技术，因此在泼完一种颜料后，一个雪球上之前被染过的所有颜色依然清晰可见。例如，一个雪球之前显现出来颜色 $\\left[ 1,2,3 \\right]$，然后 Bessie 把装有 $4$ 号颜色的牛奶桶泼上去，那么这个雪球将显现出来颜色 $\\left[ 1,2,3,4 \\right]$。 在泼了几桶颜料以后，Bessie 可能想要了解她的雪牛有多五彩斑斓。令雪球 $x$ 的『颜色丰富度』为这个雪球被染上的不同颜色总数 ，当 Bessie 想了解雪球 $x$ 的相关信息时，你应该回答她雪球 $x$ 的子树中所有的雪球的颜色丰富度之和。\n\n救救孩子吧！", "inputFormat": "第一行，$N$ 和询问数 $Q$。\n\n接下来 $N-1$ 行每行两个用空格隔开的数 $a$ 和 $b$，表示雪球 $a$ 和 $b$ 中间有一根树枝相连。\n\n最后 $Q$ 行每行一个请求，格式及对应含义如下：\n\n - `1 x c`（修改）：表示 Bessie 把一桶装有颜色 $c$ 的颜料泼到雪球 $x$ ，使得其子树上所有雪球被染色。\n - `2 x`（询问）：询问雪球 $x$ 的子树的颜色丰富度之和。", "outputFormat": "对于每个询问，输出所询问子树的颜色丰富度之和。**为了防止溢出，你需要使用 64 位整数。**", "hint": "#### 样例解释\n执行完第一个修改后雪球 $4$ 被染上了颜色 $1$。\n\n执行完第二个修改后雪球 $4$ 和雪球 $5$ 被染上了颜色 $2$。\n\n执行完第三个修改后所有雪球都被染上了颜色 $1$。\n#### 数据范围\n对于测试点 $2,3$，$1\\le N\\le 10^2,1\\le Q\\le 2\\times 10^2$；\n\n对于测试点 $4-6$，$1\\le N\\le 10^3,1\\le Q\\le 2\\times 10^3$；\n\n对于 $100\\%$ 的数据，$1\\le N,\\ Q,\\ c \\le 10^5, 1\\le a,\\ b,\\ x \\le N$。\n\nUSACO 2019 December 铂金组T2", "locale": "zh-CN"}}}
{"pid": "P5853", "type": "P", "difficulty": 7, "samples": [["3 0 192603497\n", "1 2 3\n"], ["3 1 144408983\n", "3 4 4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2019", "USACO", "组合数学", "生成函数"], "title": "[USACO19DEC] Tree Depth P", "background": null, "description": "为了迎接新年，Farmer John 决定给他的奶牛们一个节日二叉搜索树！\n\n为了生成这个二叉搜索树，Farmer John 从一个 $1 \\dots N$ 的排列 $a= \\{1,2, \\dots ,N\\}$ 开始，然后以参数 $l$ 和 $r$ 开始运行如下的伪代码：\n```\ngenerate(l,r):\n  if l > r, return empty subtree;\n  x = argmin_{l <= i <= r} a_i; // index of min a_i in {a_l,...,a_r}\n  return a BST with x as the root, \n    generate(l,x-1) as the left subtree,\n    generate(x+1,r) as the right subtree;\n```\n例如，排列 $\\{ 3,2,5,1,4 \\}$ 将产生如下的二叉搜索树：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gw6ursc0.png)\n\n令 $d_i(a)$ 表示节点 $i$ 在用排列 $a$ 生成的二叉搜索树中的深度。深度定义为这个节点到根节点的路径上的点数。在上述例子中，$d_4(a)=1,d_2(a)=d_5(a)=2,d_1(a)=d_3(a)=3$。\n\n$a$ 中的逆序对数等于满足 $1 \\le i<j \\le N$ 且 $a_i>a_j$ 的数对 $(i,j)$ 的个数。奶牛们知道 Farmer John 用来生成二叉搜索树的排列 $a$ 中恰好有 $K$ 个逆序对。对于所有满足条件的 $a$，请计算对于每个 $1 \\le i \\le N$，$\\sum_a d_i(a)$ 对 $M$ 取模后的结果。", "inputFormat": "输入只有一行，包含三个整数 $N,K,M$。", "outputFormat": "输出一行 $N$ 个整数，第 $i$ 个整数表示 $\\sum_a d_i(a) \\bmod M$。两个整数之间用一个空格隔开。", "hint": "#### 样例解释 1\n\n对于这个样例，唯一满足条件的排列为 $a=\\{1,2,3\\}$。\n\n#### 样例解释 2\n\n对于这个样例，满足条件的两个排列分别为 $a=\\{1,3,2\\}$ 和 $a=\\{2,1,3\\}$。\n\n#### 数据范围\n\n对于全部数据，$1\\le N\\le 300$，$0\\le K\\le \\frac{N(N-1)}{2}$，保证 $M$ 是一个 $\\left[ 10^8,10^9+9 \\right]$ 范围中的质数。\n\n对于测试点 $3,4$，满足 $N \\le 8$；\n\n对于测试点 $5-7$，满足 $N \\le 20$；\n\n对于测试点 $8-10$，满足 $N \\le 50$。\n\nUSACO 2019 December 铂金组T3", "locale": "zh-CN", "translations": {"en": {"title": "[USACO19DEC] Tree Depth P", "background": null, "description": "For the new year, Farmer John decided to give his cows a festive binary search tree\n(BST)! \n\nTo generate the BST, FJ starts with a permutation $a=\\{a_1,a_2,\\ldots,a_N\\}$\nof the integers $1\\ldots N$, where $N\\le 300$.  He then runs the following\npseudocode with arguments $1$ and $N.$\n\n```\ngenerate(l,r):\n  if l > r, return empty subtree;\n  x = argmin_{l <= i <= r} a_i; // index of min a_i in {a_l,...,a_r}\n  return a BST with x as the root, \n    generate(l,x-1) as the left subtree,\n    generate(x+1,r) as the right subtree;\n```\nFor example, the permutation $\\{3,2,5,1,4\\}$ generates the following BST:\n\n```\n    4\n   / \\\n  2   5\n / \\ \n1   3\n```\nLet $d_i(a)$ denote the depth of node $i$ in the tree corresponding to $a,$ \nmeaning the number of nodes on the path from $a_i$ to the root. In the above\nexample, $d_4(a)=1, d_2(a)=d_5(a)=2,$ and $d_1(a)=d_3(a)=3.$\n\nThe number of inversions of $a$ is equal to the number of pairs of integers\n$(i,j)$ such that $1\\le i<j\\le N$ and $a_i>a_j.$ The cows know that the $a$ that\nFJ will use to generate the BST has exactly $K$ inversions\n$(0\\le K\\le \\frac{N(N-1)}{2})$.  Over all $a$ satisfying this condition, compute\nthe remainder when $\\sum_ad_i(a)$ is divided by $M$ for each $1\\le i\\le N.$", "inputFormat": "The only line of input consists of three space-separated integers $N,K$,and $M$, followed by a new line. $M$ will be a prime number in the range $[10^8,10^9+9]$.", "outputFormat": "Print $N$ space-separated integers denoting $\\sum_a d_i(a) (\\bmod M)$ for each $1\\leq i\\leq N$", "hint": "### Sample Explanation\nFor the first example,the only permutation is $a=\\{1,2,3\\}$.\n\nFor the second example,the two permutations are $a=\\{1,3,2\\}$ and $a=\\{2,1,3\\}$.\n\n### Data range\nTest cases $3-4$ satisfy $N\\leq 8$.  \nTest cases $5-7$ satisfy $N\\leq 20$.  \nTest cases $8-10$ satisfy $N\\leq 50$.", "locale": "en"}, "zh-CN": {"title": "[USACO19DEC] Tree Depth P", "background": null, "description": "为了迎接新年，Farmer John 决定给他的奶牛们一个节日二叉搜索树！\n\n为了生成这个二叉搜索树，Farmer John 从一个 $1 \\dots N$ 的排列 $a= \\{1,2, \\dots ,N\\}$ 开始，然后以参数 $l$ 和 $r$ 开始运行如下的伪代码：\n```\ngenerate(l,r):\n  if l > r, return empty subtree;\n  x = argmin_{l <= i <= r} a_i; // index of min a_i in {a_l,...,a_r}\n  return a BST with x as the root, \n    generate(l,x-1) as the left subtree,\n    generate(x+1,r) as the right subtree;\n```\n例如，排列 $\\{ 3,2,5,1,4 \\}$ 将产生如下的二叉搜索树：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gw6ursc0.png)\n\n令 $d_i(a)$ 表示节点 $i$ 在用排列 $a$ 生成的二叉搜索树中的深度。深度定义为这个节点到根节点的路径上的点数。在上述例子中，$d_4(a)=1,d_2(a)=d_5(a)=2,d_1(a)=d_3(a)=3$。\n\n$a$ 中的逆序对数等于满足 $1 \\le i<j \\le N$ 且 $a_i>a_j$ 的数对 $(i,j)$ 的个数。奶牛们知道 Farmer John 用来生成二叉搜索树的排列 $a$ 中恰好有 $K$ 个逆序对。对于所有满足条件的 $a$，请计算对于每个 $1 \\le i \\le N$，$\\sum_a d_i(a)$ 对 $M$ 取模后的结果。", "inputFormat": "输入只有一行，包含三个整数 $N,K,M$。", "outputFormat": "输出一行 $N$ 个整数，第 $i$ 个整数表示 $\\sum_a d_i(a) \\bmod M$。两个整数之间用一个空格隔开。", "hint": "#### 样例解释 1\n\n对于这个样例，唯一满足条件的排列为 $a=\\{1,2,3\\}$。\n\n#### 样例解释 2\n\n对于这个样例，满足条件的两个排列分别为 $a=\\{1,3,2\\}$ 和 $a=\\{2,1,3\\}$。\n\n#### 数据范围\n\n对于全部数据，$1\\le N\\le 300$，$0\\le K\\le \\frac{N(N-1)}{2}$，保证 $M$ 是一个 $\\left[ 10^8,10^9+9 \\right]$ 范围中的质数。\n\n对于测试点 $3,4$，满足 $N \\le 8$；\n\n对于测试点 $5-7$，满足 $N \\le 20$；\n\n对于测试点 $8-10$，满足 $N \\le 50$。\n\nUSACO 2019 December 铂金组T3", "locale": "zh-CN"}}}
{"pid": "P5854", "type": "P", "difficulty": 4, "samples": [["5\n4 1 3 2 5\n", "19 21\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["O2优化", "笛卡尔树", "模板题"], "title": "【模板】笛卡尔树", "background": "本题部分写法可能触发 GCC15.1 在 O2 下的编译器 bug。建议 C++ 用户以 C++14（GCC9）提交代码。", "description": "给定一个 $1 \\sim n$ 的排列 $p$，构建其笛卡尔树。\n\n即构建一棵二叉树，满足：\n\n1. 每个节点的编号满足二叉搜索树的性质。\n2. 节点 $i$ 的权值为 $p_i$，每个节点的权值满足小根堆的性质。", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个排列 $p_{1 \\dots n}$。", "outputFormat": "设 $l_i,r_i$ 分别表示节点 $i$ 的左右儿子的编号（若不存在则为 $0$）。\n\n一行两个整数，分别表示 $\\operatorname{xor}_{i = 1}^n i \\times (l_i + 1)$ 和 $\\operatorname{xor}_{i = 1}^n i \\times (r_i + 1)$。", "hint": "【样例解释】\n\n| $i$ | $l_i$ | $r_i$ |\n| :-: | :-: | :-: |\n| $1$ | $0$ | $0$ |\n| $2$ | $1$ | $4$ |\n| $3$ | $0$ | $0$ |\n| $4$ | $3$ | $5$ |\n| $5$ | $0$ | $0$ |\n\n【数据范围】\n\n对于 $30\\%$ 的数据，$n \\le 10^3$。\n\n对于 $60\\%$ 的数据，$n \\le 10^5$。\n\n对于 $80\\%$ 的数据，$n \\le 10^6$。\n\n对于 $90\\%$ 的数据，$n \\le 5 \\times 10^6$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^7$。", "locale": "zh-CN", "translations": {"en": {"title": "[Template] Cartesian Tree.", "background": "Some implementations of this problem may trigger a compiler bug in GCC 15.1 under O2. C++ users are advised to submit with C++14 (GCC9).", "description": "Given a permutation $p$ of $1 \\sim n$, build its Cartesian tree.\n\nThat is, build a binary tree that satisfies:\n\n1. The index of each node satisfies the property of a binary search tree.\n2. The weight of node $i$ is $p_i$, and the weights satisfy the min-heap property.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains a permutation $p_{1 \\dots n}$.", "outputFormat": "Let $l_i, r_i$ denote the indices of the left and right children of node $i$ (use $0$ if it does not exist).\n\nOutput one line with two integers: $\\operatorname{xor}_{i = 1}^n i \\times (l_i + 1)$ and $\\operatorname{xor}_{i = 1}^n i \\times (r_i + 1)$.", "hint": "[Sample Explanation]\n\n| $i$ | $l_i$ | $r_i$ |\n| :-: | :-: | :-: |\n| $1$ | $0$ | $0$ |\n| $2$ | $1$ | $4$ |\n| $3$ | $0$ | $0$ |\n| $4$ | $3$ | $5$ |\n| $5$ | $0$ | $0$ |\n\n[Constraints]\n\nFor $30\\%$ of the testdata, $n \\le 10^3$.\n\nFor $60\\%$ of the testdata, $n \\le 10^5$.\n\nFor $80\\%$ of the testdata, $n \\le 10^6$.\n\nFor $90\\%$ of the testdata, $n \\le 5 \\times 10^6$.\n\nFor $100\\%$ of the testdata, $1 \\le n \\le 10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "【模板】笛卡尔树", "background": "本题部分写法可能触发 GCC15.1 在 O2 下的编译器 bug。建议 C++ 用户以 C++14（GCC9）提交代码。", "description": "给定一个 $1 \\sim n$ 的排列 $p$，构建其笛卡尔树。\n\n即构建一棵二叉树，满足：\n\n1. 每个节点的编号满足二叉搜索树的性质。\n2. 节点 $i$ 的权值为 $p_i$，每个节点的权值满足小根堆的性质。", "inputFormat": "第一行一个整数 $n$。\n\n第二行一个排列 $p_{1 \\dots n}$。", "outputFormat": "设 $l_i,r_i$ 分别表示节点 $i$ 的左右儿子的编号（若不存在则为 $0$）。\n\n一行两个整数，分别表示 $\\operatorname{xor}_{i = 1}^n i \\times (l_i + 1)$ 和 $\\operatorname{xor}_{i = 1}^n i \\times (r_i + 1)$。", "hint": "【样例解释】\n\n| $i$ | $l_i$ | $r_i$ |\n| :-: | :-: | :-: |\n| $1$ | $0$ | $0$ |\n| $2$ | $1$ | $4$ |\n| $3$ | $0$ | $0$ |\n| $4$ | $3$ | $5$ |\n| $5$ | $0$ | $0$ |\n\n【数据范围】\n\n对于 $30\\%$ 的数据，$n \\le 10^3$。\n\n对于 $60\\%$ 的数据，$n \\le 10^5$。\n\n对于 $80\\%$ 的数据，$n \\le 10^6$。\n\n对于 $90\\%$ 的数据，$n \\le 5 \\times 10^6$。\n\n对于 $100\\%$ 的数据，$1 \\le n \\le 10^7$。", "locale": "zh-CN"}}}
{"pid": "P5855", "type": "P", "difficulty": 2, "samples": [["3 2\n094\n2 01\n3 149\n2 45\n145\n345\n", "11"], ["2 1\n12\n2 12\n2 34\n13\n", "-1"], ["6 10\n907887\n9 295064731\n6 796350\n9 295378410\n5 48520\n9 745208361\n7 8079632\n111664\n422880\n521471\n433649\n037388\n091076\n235569\n979229\n268527\n690028\n", "153085"], ["18 10\n869813962161100526\n7 1762348\n8 13948756\n6 542169\n8 78314952\n6 432601\n9 697130845\n8 16358709\n8 95204367\n8 24079563\n6 145602\n7 6231549\n6 157096\n8 62534170\n5 82390\n7 5396702\n8 20536491\n7 1438692\n5 59261\n396440170984129947\n891187409797339137\n626815840963841542\n192230179244843846\n148170753474901744\n142718603216393332\n486224779191226121\n819116507635433912\n879948053659796486\n875405657525125039\n", "1468282385203195"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "枚举"], "title": "「SWTR-3」Password", "background": "小 $\\mathrm{A}$ 在茂密的森林里找到了一个宝箱。\n\n宝箱设有密码锁，但小 $\\mathrm{A}$ 不知道密码。", "description": "宝箱的密码由 $n$ 位数字组成，如果将它们连在一起写，就可以看作是一个长度为 $n$ 的字符串。\n\n小 $\\mathrm{A}$ 想通过猜的方式试出密码。对于每一位数字，都会有一个集合 $s_i$，表示小 $\\mathrm{A}$ 第 $i$ 位的尝试范围。\n\n同时，小 $\\mathrm{A}$ 已经试过了 $k$ 个密码组合 $d_1,d_2,\\dots,d_k$，**这些密码不一定符合上文中的“尝试范围”**。\n\n小 $\\mathrm{A}$ 想知道他最多还需要尝试多少次才可以试出宝箱的密码，如果永远试不出输出 $\\mathrm{-1}$。", "inputFormat": "第一行，两个整数 $n,k$。\n\n第二行，一个长度为 $n$ 的字符串 $a$，表示宝箱的密码。\n\n接下来 $n$ 行，每行以一个整数 $v_i$ 开头，表示 $s_i$ 的大小，接下来一个长度为 $v_i$ 的字符串 $s_i$，保证 $s_i$ 各位数字互不相同。\n\n接下来 $k$ 行，每行一个**互不相同**的长度为 $n$ 的字符串 $d_i$，表示小 $\\mathrm{A}$ 已经试过了哪些密码组合。", "outputFormat": "输出小 $\\mathrm{A}$ 最多还需要尝试多少次可以试出宝箱的密码，如果永远试不出，输出 $-1$。", "hint": "---\n\n### 样例说明\n\n- 在样例 $1$ 中，小 $\\mathrm{A}$ 可能试的密码组合有：`014,015,044,045,094,095,114,115,144,145,194,195` 共 $12$ 个数，其中包含密码，但因为 `145` 已经试过，所以小 $\\mathrm{A}$ 最多还需尝试 $11$ 次。\n\n- 在样例 $2$ 中，小 $\\mathrm{A}$ 可能试的密码组合有：`13,14,23,24`，共 $4$ 个数，其中没有密码，所以小 $\\mathrm{A}$ 永远试不出密码。\n\n---\n\n### 数据范围与约定\n\n**本题使用捆绑测试。**\n\nSubtask 编号 | $n\\leq$ | 特殊性质 | 分数\n:-: | :-: | :-: | :-:\n$1$ | $18$ | 答案为 $-1$ | $7$\n$2$ | $1$ | 无 | $13$\n$3$ | $6$ | 无 | $24$\n$4$ | $18$ | $k=0$ | $21$\n$5$ | $18$ | 无 | $35$\n\n对于 $100\\%$ 的数据，有 $1\\leq n\\leq 18$，$0\\leq k \\leq\\min(10^n-1,10^4)$。\n\n保证 $d_i$ 不为密码。\n\n---\n\n对于所有测试点，时间限制 $1\\mathrm{s}$，空间限制 $128\\mathrm{MB}$。", "locale": "zh-CN", "translations": {"en": {"title": "\"SWTR-3\" Password", "background": "Little $\\mathrm{A}$ found a treasure chest in a dense forest.\n\nThe chest has a combination lock, but little $\\mathrm{A}$ does not know the password.", "description": "The password of the chest consists of $n$ digits. If you write them together, it can be seen as a string of length $n$.\n\nLittle $\\mathrm{A}$ wants to guess the password. For each digit position, there is a set $s_i$, representing the range of digits little $\\mathrm{A}$ will try for the $i$-th position.\n\nAlso, little $\\mathrm{A}$ has already tried $k$ password strings $d_1,d_2,\\dots,d_k$. **These passwords do not necessarily satisfy the above “try ranges”.**\n\nLittle $\\mathrm{A}$ wants to know the maximum number of additional attempts he may still need to crack the chest’s password. If he can never crack it, output $\\mathrm{-1}$.", "inputFormat": "The first line contains two integers $n,k$.\n\nThe second line contains a string $a$ of length $n$, representing the chest’s password.\n\nIn the next $n$ lines, each line starts with an integer $v_i$, indicating the size of $s_i$, followed by a string $s_i$ of length $v_i$. It is guaranteed that all digits in $s_i$ are distinct.\n\nIn the next $k$ lines, each line contains a **distinct** string $d_i$ of length $n$, indicating the password strings that little $\\mathrm{A}$ has already tried.", "outputFormat": "Output the maximum number of additional attempts little $\\mathrm{A}$ may still need to crack the chest’s password. If he can never crack it, output $-1$.", "hint": "---\n\n### Sample Explanation\n\n- In sample $1$, the possible password strings little $\\mathrm{A}$ may try are: `014,015,044,045,094,095,114,115,144,145,194,195`, a total of $12$ strings. This set contains the real password, but since `145` has already been tried, little $\\mathrm{A}$ may need at most $11$ more attempts.\n\n- In sample $2$, the possible password strings little $\\mathrm{A}$ may try are: `13,14,23,24`, a total of $4$ strings. None of them is the real password, so little $\\mathrm{A}$ can never crack the password.\n\n---\n\n### Constraints and Notes\n\n**This problem uses bundled testdata.**\n\nSubtask ID | $n\\leq$ | Special Property | Score\n:-: | :-: | :-: | :-:\n$1$ | $18$ | The answer is $-1$ | $7$\n$2$ | $1$ | None | $13$\n$3$ | $6$ | None | $24$\n$4$ | $18$ | $k=0$ | $21$\n$5$ | $18$ | None | $35$\n\nFor $100\\%$ of the data, $1\\leq n\\leq 18$ and $0\\leq k \\leq\\min(10^n-1,10^4)$.\n\nIt is guaranteed that $d_i$ is not the password.\n\n---\n\nFor all test points, the time limit is $1\\mathrm{s}$ and the memory limit is $128\\mathrm{MB}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「SWTR-3」Password", "background": "小 $\\mathrm{A}$ 在茂密的森林里找到了一个宝箱。\n\n宝箱设有密码锁，但小 $\\mathrm{A}$ 不知道密码。", "description": "宝箱的密码由 $n$ 位数字组成，如果将它们连在一起写，就可以看作是一个长度为 $n$ 的字符串。\n\n小 $\\mathrm{A}$ 想通过猜的方式试出密码。对于每一位数字，都会有一个集合 $s_i$，表示小 $\\mathrm{A}$ 第 $i$ 位的尝试范围。\n\n同时，小 $\\mathrm{A}$ 已经试过了 $k$ 个密码组合 $d_1,d_2,\\dots,d_k$，**这些密码不一定符合上文中的“尝试范围”**。\n\n小 $\\mathrm{A}$ 想知道他最多还需要尝试多少次才可以试出宝箱的密码，如果永远试不出输出 $\\mathrm{-1}$。", "inputFormat": "第一行，两个整数 $n,k$。\n\n第二行，一个长度为 $n$ 的字符串 $a$，表示宝箱的密码。\n\n接下来 $n$ 行，每行以一个整数 $v_i$ 开头，表示 $s_i$ 的大小，接下来一个长度为 $v_i$ 的字符串 $s_i$，保证 $s_i$ 各位数字互不相同。\n\n接下来 $k$ 行，每行一个**互不相同**的长度为 $n$ 的字符串 $d_i$，表示小 $\\mathrm{A}$ 已经试过了哪些密码组合。", "outputFormat": "输出小 $\\mathrm{A}$ 最多还需要尝试多少次可以试出宝箱的密码，如果永远试不出，输出 $-1$。", "hint": "---\n\n### 样例说明\n\n- 在样例 $1$ 中，小 $\\mathrm{A}$ 可能试的密码组合有：`014,015,044,045,094,095,114,115,144,145,194,195` 共 $12$ 个数，其中包含密码，但因为 `145` 已经试过，所以小 $\\mathrm{A}$ 最多还需尝试 $11$ 次。\n\n- 在样例 $2$ 中，小 $\\mathrm{A}$ 可能试的密码组合有：`13,14,23,24`，共 $4$ 个数，其中没有密码，所以小 $\\mathrm{A}$ 永远试不出密码。\n\n---\n\n### 数据范围与约定\n\n**本题使用捆绑测试。**\n\nSubtask 编号 | $n\\leq$ | 特殊性质 | 分数\n:-: | :-: | :-: | :-:\n$1$ | $18$ | 答案为 $-1$ | $7$\n$2$ | $1$ | 无 | $13$\n$3$ | $6$ | 无 | $24$\n$4$ | $18$ | $k=0$ | $21$\n$5$ | $18$ | 无 | $35$\n\n对于 $100\\%$ 的数据，有 $1\\leq n\\leq 18$，$0\\leq k \\leq\\min(10^n-1,10^4)$。\n\n保证 $d_i$ 不为密码。\n\n---\n\n对于所有测试点，时间限制 $1\\mathrm{s}$，空间限制 $128\\mathrm{MB}$。", "locale": "zh-CN"}}}
{"pid": "P5856", "type": "P", "difficulty": 5, "samples": [["5\n12 30 48 36 18\n", "4"], ["10\n72 81 27 90 45 45 27 99 45 18\n", "6"], ["4\n1 2 4 8", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["数学", "O2优化", "状压 DP"], "title": "「SWTR-3」Game", "background": "小 E 在玩一个数字游戏。", "description": "小 E 有 $n$ 个正整数 $a_1,a_2,\\dots,a_n$。他可以进行以下操作任意次：\n\n选择一个数 $q$，和一个集合 $S=\\{d_1,d_2,\\dots,d_m\\}$，使得 $a_{d_1},a_{d_2},\\dots,a_{d_m}$ 能被 $q$ 整除，并将 $a_{d_1},a_{d_2},\\dots,a_{d_m}$ 除以 $q$。\n\n- $q$ 要满足可以写成 $p^z$ 的形式，其中 $p$ 为质数，$z$ 为正整数。\n\n求最少需要进行多少次操作才能将这些数变为相等的数。", "inputFormat": "第一行，一个整数 $n$。\n\n第二行，$n$ 个整数 $a_1,a_2,\\dots,a_n$。", "outputFormat": "输出一个整数表示答案。", "hint": "#### 「样例 1 说明」\n\n一开始的序列为 12 30 48 36 18。  \n选择 $S=\\{4,5\\},p=3$，操作后变为 12 30 48 12 6。  \n选择 $S=\\{1,3,4\\},p=2$，操作后变为 6 30 24 6 6。  \n选择 $S=\\{2\\},p=5$，操作后变为 6 6 24 6 6。  \n选择 $S=\\{3\\},p=2^2=4$，操作后变为 6 6 6 6 6。  \n共 4 次操作，方法不唯一。\n\n#### 「数据范围与约定」\n\n**本题使用捆绑测试。**\n\nSubtask 编号 | $n\\leq$ | $a_i\\leq$ | 特殊性质 | 得分\n:-: | :-: | :-: | :-: | :-:\n$1$ | $8$ | $50$ | $a_i$ 中有一个数为 $1$ | $13$\n$2$ | $10$ | $100$ | 无 | $17$\n$3$ | $10^3$ | $10^4$ | 无 | $29$\n$4$ | $10^5$ | $10^6$ | 无 | $41$\n\n对于 $100\\%$ 的数据，有 $1\\leq n\\leq 10^5$，$1\\leq a_i\\leq 10^6$。\n\n对于所有测试点，时间限制 1s，空间限制 128MB。\n\n#### 「来源」\n\n[Sweet Round 03 B](https://www.luogu.com.cn/contest/24755)。  \nidea & solution：ET2006 & Alex_Wei。", "locale": "zh-CN", "translations": {"en": {"title": "\"SWTR-3\" Game", "background": "Little E is playing a number game.", "description": "Little E has $n$ positive integers $a_1,a_2,\\dots,a_n$. He can perform the following operation any number of times:\n\nChoose a number $q$ and a set $S=\\{d_1,d_2,\\dots,d_m\\}$ such that $a_{d_1},a_{d_2},\\dots,a_{d_m}$ are divisible by $q$, and divide $a_{d_1},a_{d_2},\\dots,a_{d_m}$ by $q$.\n\n- $q$ must be in the form $p^z$, where $p$ is a prime number and $z$ is a positive integer.\n\nFind the minimum number of operations needed to make all these numbers equal.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n$ integers $a_1,a_2,\\dots,a_n$.", "outputFormat": "Output one integer representing the answer.", "hint": "#### \"Sample 1 Explanation\"\n\nThe initial sequence is 12 30 48 36 18.  \nChoose $S=\\{4,5\\},p=3$, after the operation it becomes 12 30 48 12 6.  \nChoose $S=\\{1,3,4\\},p=2$, after the operation it becomes 6 30 24 6 6.  \nChoose $S=\\{2\\},p=5$, after the operation it becomes 6 6 24 6 6.  \nChoose $S=\\{3\\},p=2^2=4$, after the operation it becomes 6 6 6 6 6.  \nA total of 4 operations are used, and the method is not unique.\n\n#### \"Constraints and Notes\"\n\n**This problem uses bundled testdata.**\n\nSubtask ID | $n\\leq$ | $a_i\\leq$ | Special Property | Score\n:-: | :-: | :-: | :-: | :-:\n$1$ | $8$ | $50$ | There is a number equal to $1$ among $a_i$ | $13$\n$2$ | $10$ | $100$ | None | $17$\n$3$ | $10^3$ | $10^4$ | None | $29$\n$4$ | $10^5$ | $10^6$ | None | $41$\n\nFor $100\\%$ of the data, $1\\leq n\\leq 10^5$ and $1\\leq a_i\\leq 10^6$.\n\nFor all test points, the time limit is 1s and the memory limit is 128MB.\n\n#### \"Source\"\n\n[Sweet Round 03 B](https://www.luogu.com.cn/contest/24755)。  \nidea & solution: ET2006 & Alex_Wei。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「SWTR-3」Game", "background": "小 E 在玩一个数字游戏。", "description": "小 E 有 $n$ 个正整数 $a_1,a_2,\\dots,a_n$。他可以进行以下操作任意次：\n\n选择一个数 $q$，和一个集合 $S=\\{d_1,d_2,\\dots,d_m\\}$，使得 $a_{d_1},a_{d_2},\\dots,a_{d_m}$ 能被 $q$ 整除，并将 $a_{d_1},a_{d_2},\\dots,a_{d_m}$ 除以 $q$。\n\n- $q$ 要满足可以写成 $p^z$ 的形式，其中 $p$ 为质数，$z$ 为正整数。\n\n求最少需要进行多少次操作才能将这些数变为相等的数。", "inputFormat": "第一行，一个整数 $n$。\n\n第二行，$n$ 个整数 $a_1,a_2,\\dots,a_n$。", "outputFormat": "输出一个整数表示答案。", "hint": "#### 「样例 1 说明」\n\n一开始的序列为 12 30 48 36 18。  \n选择 $S=\\{4,5\\},p=3$，操作后变为 12 30 48 12 6。  \n选择 $S=\\{1,3,4\\},p=2$，操作后变为 6 30 24 6 6。  \n选择 $S=\\{2\\},p=5$，操作后变为 6 6 24 6 6。  \n选择 $S=\\{3\\},p=2^2=4$，操作后变为 6 6 6 6 6。  \n共 4 次操作，方法不唯一。\n\n#### 「数据范围与约定」\n\n**本题使用捆绑测试。**\n\nSubtask 编号 | $n\\leq$ | $a_i\\leq$ | 特殊性质 | 得分\n:-: | :-: | :-: | :-: | :-:\n$1$ | $8$ | $50$ | $a_i$ 中有一个数为 $1$ | $13$\n$2$ | $10$ | $100$ | 无 | $17$\n$3$ | $10^3$ | $10^4$ | 无 | $29$\n$4$ | $10^5$ | $10^6$ | 无 | $41$\n\n对于 $100\\%$ 的数据，有 $1\\leq n\\leq 10^5$，$1\\leq a_i\\leq 10^6$。\n\n对于所有测试点，时间限制 1s，空间限制 128MB。\n\n#### 「来源」\n\n[Sweet Round 03 B](https://www.luogu.com.cn/contest/24755)。  \nidea & solution：ET2006 & Alex_Wei。", "locale": "zh-CN"}}}
{"pid": "P5857", "type": "P", "difficulty": 6, "samples": [["11\n1 1 3\n4 3 5\n2 3 1\n123 231 132\n1 1017 12345\n1017 1567 1\n1710 1017 999\n1987 1789 375168429\n101777 171077 99999\n123321 200000 321123\n2 2 1", "1\n32\n6\n198296574\n832895500\n1593639\n928595966\n438358858\n366897935\n745426660\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}, "tags": ["数学", "O2优化"], "title": "「SWTR-3」Matrix", "background": "", "description": "小 E 有一个 $n \\times m$ 的魔法矩阵，每个格子有激活和未激活两个状态。一开始，格子都是未激活的。\n\n小 E 有一个魔法棒，可以使用 $k$ 次魔法。每次使用魔法时小 $\\mathrm{E}$ 需选择一个魔法格子 $(x,y)$ 并改变第 $x$ 行和第 $y$ 列的所有魔法格子的状态。**$(x,y)$ 的状态会被改变两次。**\n\n现在小 E 想知道，使用 $k$ 次魔法之后可以得到多少个不同的魔法矩阵。\n\n- 两个魔法矩阵不同，当且仅当两个魔法矩阵中有一个对应格子的状态不同。\n\n由于答案很大，请对 $998244353$ 取模。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行，一个整数 $T$，测试数据的组数。\n\n每一组测试数据由一行三个整数 $n,m,k$ 组成——矩阵的长，矩阵的宽，使用魔法的次数。", "outputFormat": "对于每组测试数据，输出单独的一行整数，表示使用 $k$ 次魔法之后可以得到多少个不同的魔法矩阵。", "hint": "#### 「样例说明」\n\n- 对于第 1 组测试数据：无论如何使用魔法棒，最多只会有 1 种不同的魔法矩阵。 \n- 对于第 3 组测试数据：任选一个格子使用 1 次魔法棒都能得到一个不同的魔法矩阵，共 $2\\times 3=6$ 种不同的魔法矩阵。\n\n---\n\n### 数据范围与约定\n\n测试点编号 | $n\\leq$ | $m\\leq$ | $k\\leq$\n:-: | :-: | :-: | :-:\n$1$ | $1$ | $1$ | $10^9$\n$2$ | $4$ | $4$ | $4$\n$3-5$ | $200$ | $200$ | $200$\n$6-7$ | $1$ | $1000$ | $10^5$\n$8$ | $1000$ | $1000$ | $1$\n$9-12$ | $1000$ | $1000$ | $10^5$\n$13-20$ | $2\\times 10^5$ | $2\\times 10^5$ | $10^9$\n\n对于 $100\\%$ 的数据，$1 \\leq T \\leq 64$，$\\ 1 \\leq n,m \\leq 2\\times 10^5$，$\\ 1 \\leq k \\leq 10^9$。\n\n对于所有测试点，时间限制 1s，空间限制 32MB。\n\n#### 「来源」\n\n[Sweet Round 03 C](https://www.luogu.com.cn/contest/24755)。  \nidea & solution：ET2006。", "locale": "zh-CN", "translations": {"en": {"title": "\"SWTR-3\" Matrix", "background": "", "description": "Little E has an $n \\times m$ magic matrix. Each cell has two states: activated and not activated. At the beginning, all cells are not activated.\n\nLittle E has a magic wand and can use magic $k$ times. Each time magic is used, Little E needs to choose a magic cell $(x,y)$ and toggle the state of all magic cells in row $x$ and column $y$. **The state of $(x,y)$ will be toggled twice.**\n\nNow Little E wants to know how many different magic matrices can be obtained after using magic $k$ times.\n\n- Two magic matrices are different if and only if there exists at least one corresponding cell whose state is different in the two matrices.\n\nSince the answer may be very large, output it modulo $998244353$.", "inputFormat": "**This problem contains multiple test cases.**\n\nThe first line contains an integer $T$, the number of test cases.\n\nEach test case consists of one line with three integers $n,m,k$ — the height of the matrix, the width of the matrix, and the number of times magic is used.", "outputFormat": "For each test case, output a single line with one integer, representing how many different magic matrices can be obtained after using magic $k$ times.", "hint": "#### \"Sample Explanation\"\n\n- For the $1$st test case: no matter how the magic wand is used, at most $1$ different magic matrix can be obtained.\n- For the $3$rd test case: using the magic wand once on any cell can produce a different magic matrix, for a total of $2 \\times 3 = 6$ different magic matrices.\n\n---\n\n### Constraints and Notes\n\nTest point ID | $n \\leq$ | $m \\leq$ | $k \\leq$\n:-: | :-: | :-: | :-:\n$1$ | $1$ | $1$ | $10^9$\n$2$ | $4$ | $4$ | $4$\n$3-5$ | $200$ | $200$ | $200$\n$6-7$ | $1$ | $1000$ | $10^5$\n$8$ | $1000$ | $1000$ | $1$\n$9-12$ | $1000$ | $1000$ | $10^5$\n$13-20$ | $2 \\times 10^5$ | $2 \\times 10^5$ | $10^9$\n\nFor $100\\%$ of the testdata, $1 \\leq T \\leq 64$, $1 \\leq n,m \\leq 2 \\times 10^5$, $1 \\leq k \\leq 10^9$.\n\nFor all test points, the time limit is $1$s and the memory limit is $32$MB.\n\n#### \"Source\"\n\n[Sweet Round 03 C](https://www.luogu.com.cn/contest/24755)。  \nIdea & solution: ET2006。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「SWTR-3」Matrix", "background": "", "description": "小 E 有一个 $n \\times m$ 的魔法矩阵，每个格子有激活和未激活两个状态。一开始，格子都是未激活的。\n\n小 E 有一个魔法棒，可以使用 $k$ 次魔法。每次使用魔法时小 $\\mathrm{E}$ 需选择一个魔法格子 $(x,y)$ 并改变第 $x$ 行和第 $y$ 列的所有魔法格子的状态。**$(x,y)$ 的状态会被改变两次。**\n\n现在小 E 想知道，使用 $k$ 次魔法之后可以得到多少个不同的魔法矩阵。\n\n- 两个魔法矩阵不同，当且仅当两个魔法矩阵中有一个对应格子的状态不同。\n\n由于答案很大，请对 $998244353$ 取模。", "inputFormat": "**本题包含多组测试数据。**\n\n第一行，一个整数 $T$，测试数据的组数。\n\n每一组测试数据由一行三个整数 $n,m,k$ 组成——矩阵的长，矩阵的宽，使用魔法的次数。", "outputFormat": "对于每组测试数据，输出单独的一行整数，表示使用 $k$ 次魔法之后可以得到多少个不同的魔法矩阵。", "hint": "#### 「样例说明」\n\n- 对于第 1 组测试数据：无论如何使用魔法棒，最多只会有 1 种不同的魔法矩阵。 \n- 对于第 3 组测试数据：任选一个格子使用 1 次魔法棒都能得到一个不同的魔法矩阵，共 $2\\times 3=6$ 种不同的魔法矩阵。\n\n---\n\n### 数据范围与约定\n\n测试点编号 | $n\\leq$ | $m\\leq$ | $k\\leq$\n:-: | :-: | :-: | :-:\n$1$ | $1$ | $1$ | $10^9$\n$2$ | $4$ | $4$ | $4$\n$3-5$ | $200$ | $200$ | $200$\n$6-7$ | $1$ | $1000$ | $10^5$\n$8$ | $1000$ | $1000$ | $1$\n$9-12$ | $1000$ | $1000$ | $10^5$\n$13-20$ | $2\\times 10^5$ | $2\\times 10^5$ | $10^9$\n\n对于 $100\\%$ 的数据，$1 \\leq T \\leq 64$，$\\ 1 \\leq n,m \\leq 2\\times 10^5$，$\\ 1 \\leq k \\leq 10^9$。\n\n对于所有测试点，时间限制 1s，空间限制 32MB。\n\n#### 「来源」\n\n[Sweet Round 03 C](https://www.luogu.com.cn/contest/24755)。  \nidea & solution：ET2006。", "locale": "zh-CN"}}}
{"pid": "P5858", "type": "P", "difficulty": 4, "samples": [["5 3 3\n1 3 2 4 5\n", "40"], ["5 3 3\n1 -3 -2 4 5\n", "21"], ["7 4 2\n-5 3 -1 -4 7 -6 5\n", "17"], ["5 3 1\n-1 -3 -2 -4 -5\n", "-15"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "单调队列", "O2优化"], "title": "「SWTR-3」Golden Sword", "background": "小 E 不幸在一场战斗中失去了他的金宝剑。", "description": "制造一把金宝剑需要 $n$ 种原料，编号为 $1$ 到 $n$，编号为 $i$ 的原料的坚固值为 $a_i$。\n\n炼金是很讲究放入原料的顺序的，因此小 E 必须**按照 $1$ 到 $n$ 的顺序**依次将这些原料放入炼金锅。\n\n但是，炼金锅的容量非常有限，它**最多只能容纳 $w$ 个原料**。\n\n所幸的是，**每放入一个原料之前**，小 E 可以从中取出一些原料，数量不能超过 $s$ 个。\n\n- 我们定义第 $i$ 种原料的耐久度为：放入第 $i$ 种原料时锅内的原料总数（包括正在放入的原料） $\\times\\ a_i$，则宝剑的耐久度为**所有原料**的耐久度之和。\n\n小 E 当然想让他的宝剑的耐久度尽可能得大，这样他就可以带着它进行更多的战斗，请求出耐久度的最大值。\n\n注：这里的“放入第 $i$ 种原料时锅内的原料总数**包括正在放入锅中的原料**，详细信息请见样例。", "inputFormat": "第一行，三个整数 $n,w,s$。\n\n第二行，$n$ 个整数 $a_1,a_2,\\dots,a_n$。", "outputFormat": "一行一个整数，表示耐久度的最大值。", "hint": "#### 「样例说明」\n\n- **对于样例 1**，一种可行的**最优**方案为：\n首先放进原料 1，此时锅内有 $1$ 种原料，耐久度为 $1\\times a_1=1\\times 1=1$。  \n再放进原料 2，此时锅内有 $2$ 种原料，耐久度为 $2\\times a_2=2\\times 3=6$。  \n再放进原料 3，此时锅内有 $3$ 种原料，耐久度为 $3\\times a_3=3\\times 2=6$。  \n取出原料 1，再放进原料 4，此时锅内有 $3$ 种原料，耐久度为 $3\\times a_4=3\\times 4=12$。  \n取出原料 4，再放进原料 5，此时锅内有 $3$ 种原料，耐久度为 $3\\times a_5=3\\times 5=15$。  \n最终答案为 $1+6+6+12+15=40$。  \n- **对于样例 2**，一种可行的**最优**方案为：  \n放进原料 1，耐久度为 $1\\times 1=1$。  \n取出原料 1，放进原料 2，耐久度为 $1\\times (-3)=-3$。  \n放进原料 3，耐久度为 $2\\times (-2)=-4$。  \n放进原料 4，耐久度为 $3\\times 4=12$。  \n取出原料 2，放进原料 5，耐久度为 $3\\times 5=15$。  \n最终答案为 $1+(-3)+(-4)+12+15=21$。  \n- **对于样例 3**，一种可行的**最优**方案为：  \n  $a_1+2a_2+2a_3+3a_4+4a_5+3a_6+4a_7=17$。 \n- **对于样例 4**，一种可行的**最优**方案为：  \n$a_1+a_2+a_3+a_4+a_5=-15$。\n\n#### 「数据范围与约定」\n\n**本题使用捆绑测试。**\n\n- Subtask #1（15 points）：$n\\leq 10$。\n- Subtask #2（5 points）：$n\\leq 100$，$a_i\\geq0$。\n- Subtask #3（15 points）：$n\\leq 300$。\n- Subtask #4（15 points）：$s=w=n$。\n- Subtask #5（5 points）：$a_i\\geq 0$。\n- Subtask #6（10 points）：$n\\leq 2\\times 10^3$。\n- Subtask #7（10 points）：$s=1$。\n- Subtask #8（25 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\leq s \\leq w \\leq n \\leq 5\\times 10^3$，$|a_i| \\leq 10^9$。对于 Subtask $i$ 有 $|a_i|\\leq 10^{i+1}$。\n\n#### 「帮助/说明」\n\n本题下发大样例，具体输入输出见 [**Big Sample**](https://pan.baidu.com/s/1erVDllDlvNlEShxh3U42gA) 中的 gold01-08.in/gold01-08.out。提取码：757d。  \n**文件名与 Subtask 编号一一对应。**\n\n#### 「来源」\n\n[Sweet Round 03 D](https://www.luogu.com.cn/contest/24755)。  \nidea & solution：ET2006。", "locale": "zh-CN", "translations": {"en": {"title": "\"SWTR-3\" Golden Sword", "background": "Little E unfortunately lost his golden sword in a battle.", "description": "To make a golden sword, $n$ kinds of materials are needed, numbered from $1$ to $n$. The sturdiness value of material $i$ is $a_i$.\n\nAlchemy pays great attention to the order of adding materials, so Little E must add these materials into the alchemy pot **in the order from $1$ to $n$**, one by one.\n\nHowever, the pot has a very limited capacity: it can hold **at most $w$ materials**.\n\nFortunately, **before adding each material**, Little E may take out some materials from the pot, but the number taken out cannot exceed $s$.\n\n- We define the durability of material $i$ as: (the total number of materials in the pot when adding material $i$, **including the material being added**) $\\times\\ a_i$. Then, the sword's durability is the sum of the durabilities of **all materials**.\n\nLittle E of course wants his sword's durability to be as large as possible, so that he can take it into more battles. Please output the maximum possible durability.\n\nNote: Here, “the total number of materials in the pot when adding material $i$” **includes the material currently being put into the pot**. For details, see the samples.", "inputFormat": "The first line contains three integers $n,w,s$.\n\nThe second line contains $n$ integers $a_1,a_2,\\dots,a_n$.", "outputFormat": "Output one integer in one line, representing the maximum durability.", "hint": "#### \"Sample Explanation\"\n\n- **For Sample 1**, one feasible **optimal** plan is:\nFirst put in material 1. Now there is $1$ material in the pot, and the durability is $1\\times a_1=1\\times 1=1$.  \nThen put in material 2. Now there are $2$ materials in the pot, and the durability is $2\\times a_2=2\\times 3=6$.  \nThen put in material 3. Now there are $3$ materials in the pot, and the durability is $3\\times a_3=3\\times 2=6$.  \nTake out material 1, then put in material 4. Now there are $3$ materials in the pot, and the durability is $3\\times a_4=3\\times 4=12$.  \nTake out material 4, then put in material 5. Now there are $3$ materials in the pot, and the durability is $3\\times a_5=3\\times 5=15$.  \nThe final answer is $1+6+6+12+15=40$.  \n- **For Sample 2**, one feasible **optimal** plan is:  \nPut in material 1, and the durability is $1\\times 1=1$.  \nTake out material 1, put in material 2, and the durability is $1\\times (-3)=-3$.  \nPut in material 3, and the durability is $2\\times (-2)=-4$.  \nPut in material 4, and the durability is $3\\times 4=12$.  \nTake out material 2, put in material 5, and the durability is $3\\times 5=15$.  \nThe final answer is $1+(-3)+(-4)+12+15=21$.  \n- **For Sample 3**, one feasible **optimal** plan is:  \n  $a_1+2a_2+2a_3+3a_4+4a_5+3a_6+4a_7=17$. \n- **For Sample 4**, one feasible **optimal** plan is:  \n$a_1+a_2+a_3+a_4+a_5=-15$.\n\n#### \"Constraints and Notes\"\n\n**This problem uses bundled testdata.**\n\n- Subtask #1 (15 points): $n\\leq 10$.\n- Subtask #2 (5 points): $n\\leq 100$, $a_i\\geq0$.\n- Subtask #3 (15 points): $n\\leq 300$.\n- Subtask #4 (15 points): $s=w=n$.\n- Subtask #5 (5 points): $a_i\\geq 0$.\n- Subtask #6 (10 points): $n\\leq 2\\times 10^3$.\n- Subtask #7 (10 points): $s=1$.\n- Subtask #8 (25 points): no special restrictions.\n\nFor $100\\%$ of the data, $1 \\leq s \\leq w \\leq n \\leq 5\\times 10^3$, $|a_i| \\leq 10^9$. For Subtask $i$, $|a_i|\\leq 10^{i+1}$.\n\n#### \"Help / Notes\"\n\nThis problem provides large samples. For the exact input and output, see gold01-08.in / gold01-08.out in [**Big Sample**](https://pan.baidu.com/s/1erVDllDlvNlEShxh3U42gA). Extraction code: 757d.  \n**The filenames correspond one-to-one with the Subtask numbers.**\n\n#### \"Source\"\n\n[Sweet Round 03 D](https://www.luogu.com.cn/contest/24755).  \nIdea & solution: ET2006.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「SWTR-3」Golden Sword", "background": "小 E 不幸在一场战斗中失去了他的金宝剑。", "description": "制造一把金宝剑需要 $n$ 种原料，编号为 $1$ 到 $n$，编号为 $i$ 的原料的坚固值为 $a_i$。\n\n炼金是很讲究放入原料的顺序的，因此小 E 必须**按照 $1$ 到 $n$ 的顺序**依次将这些原料放入炼金锅。\n\n但是，炼金锅的容量非常有限，它**最多只能容纳 $w$ 个原料**。\n\n所幸的是，**每放入一个原料之前**，小 E 可以从中取出一些原料，数量不能超过 $s$ 个。\n\n- 我们定义第 $i$ 种原料的耐久度为：放入第 $i$ 种原料时锅内的原料总数（包括正在放入的原料） $\\times\\ a_i$，则宝剑的耐久度为**所有原料**的耐久度之和。\n\n小 E 当然想让他的宝剑的耐久度尽可能得大，这样他就可以带着它进行更多的战斗，请求出耐久度的最大值。\n\n注：这里的“放入第 $i$ 种原料时锅内的原料总数**包括正在放入锅中的原料**，详细信息请见样例。", "inputFormat": "第一行，三个整数 $n,w,s$。\n\n第二行，$n$ 个整数 $a_1,a_2,\\dots,a_n$。", "outputFormat": "一行一个整数，表示耐久度的最大值。", "hint": "#### 「样例说明」\n\n- **对于样例 1**，一种可行的**最优**方案为：\n首先放进原料 1，此时锅内有 $1$ 种原料，耐久度为 $1\\times a_1=1\\times 1=1$。  \n再放进原料 2，此时锅内有 $2$ 种原料，耐久度为 $2\\times a_2=2\\times 3=6$。  \n再放进原料 3，此时锅内有 $3$ 种原料，耐久度为 $3\\times a_3=3\\times 2=6$。  \n取出原料 1，再放进原料 4，此时锅内有 $3$ 种原料，耐久度为 $3\\times a_4=3\\times 4=12$。  \n取出原料 4，再放进原料 5，此时锅内有 $3$ 种原料，耐久度为 $3\\times a_5=3\\times 5=15$。  \n最终答案为 $1+6+6+12+15=40$。  \n- **对于样例 2**，一种可行的**最优**方案为：  \n放进原料 1，耐久度为 $1\\times 1=1$。  \n取出原料 1，放进原料 2，耐久度为 $1\\times (-3)=-3$。  \n放进原料 3，耐久度为 $2\\times (-2)=-4$。  \n放进原料 4，耐久度为 $3\\times 4=12$。  \n取出原料 2，放进原料 5，耐久度为 $3\\times 5=15$。  \n最终答案为 $1+(-3)+(-4)+12+15=21$。  \n- **对于样例 3**，一种可行的**最优**方案为：  \n  $a_1+2a_2+2a_3+3a_4+4a_5+3a_6+4a_7=17$。 \n- **对于样例 4**，一种可行的**最优**方案为：  \n$a_1+a_2+a_3+a_4+a_5=-15$。\n\n#### 「数据范围与约定」\n\n**本题使用捆绑测试。**\n\n- Subtask #1（15 points）：$n\\leq 10$。\n- Subtask #2（5 points）：$n\\leq 100$，$a_i\\geq0$。\n- Subtask #3（15 points）：$n\\leq 300$。\n- Subtask #4（15 points）：$s=w=n$。\n- Subtask #5（5 points）：$a_i\\geq 0$。\n- Subtask #6（10 points）：$n\\leq 2\\times 10^3$。\n- Subtask #7（10 points）：$s=1$。\n- Subtask #8（25 points）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1 \\leq s \\leq w \\leq n \\leq 5\\times 10^3$，$|a_i| \\leq 10^9$。对于 Subtask $i$ 有 $|a_i|\\leq 10^{i+1}$。\n\n#### 「帮助/说明」\n\n本题下发大样例，具体输入输出见 [**Big Sample**](https://pan.baidu.com/s/1erVDllDlvNlEShxh3U42gA) 中的 gold01-08.in/gold01-08.out。提取码：757d。  \n**文件名与 Subtask 编号一一对应。**\n\n#### 「来源」\n\n[Sweet Round 03 D](https://www.luogu.com.cn/contest/24755)。  \nidea & solution：ET2006。", "locale": "zh-CN"}}}
{"pid": "P5859", "type": "P", "difficulty": 5, "samples": [["11\n1 -1 2 2 -1 7\n1 2 2 -1 0 10\n1 2 1 1 -1 17\n3 5 4\n3 -99999 0\n3 -3 6\n3 1 -1\n4 2\n2 1\n4 2\n4 1\n", "7\n10\n17\n17\n17\n10\noops!"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["计算几何", "线段树", "O2优化"], "title": "「SWTR-3」Plane Mirrors", "background": "小 $\\mathrm{A}$ 在学物理。\n\n老师在讲“平面镜成像”这个物理现象。\n\n但老师讲课太无聊，所以他就睡着了。", "description": "小 $\\mathrm{A}$ 梦见自己站在了一个平台上，在他的周围有一些平面镜，我们假定他的位置为 $(0,0)$。\n\n他发现，每个平面镜都有一个初始不透明度，记做 $v_i$。\n\n下文中，我们定义：\n\n- 一个射线的“不透明度”为：该射线穿过的所有平面镜的初始不透明度之和。\n\n- 一个平面镜的“视觉不透明度”为：所有**从 $(0,0)$ 发出**且**经过该平面镜**的射线的不透明度最大值。\n\n小 $\\mathrm{A}$ 突然发现自己能够控制这些平面镜，于是就有了下面这道题目。\n\n小 $\\mathrm{A}$ 需要你完成以下操作：\n\n`1 x1 y1 x2 y2 v`：变出一个两端分别在 $(x_1,y_1),(x_2,y_2)$，初始不透明度为 $v$ 的平面镜。\n\n`2 d`：摧毁第 $d$ 个变出来的平面镜，保证未被摧毁。\n\n`3 x y`：设 $\\mathrm{A=(0,0),B=(x,y)}$，询问射线 $\\mathrm{AB}$ 的不透明度。\n\n`4 d`：询问第 $d$ 个平面镜的视觉不透明度，如已被摧毁则输出 `oops!`。", "inputFormat": "第一行，一个整数 $n$，表示操作次数。\n\n接下来 $n$ 行，第 $i$ 行先是一个整数 $opt$，然后：\n\n- 如果 $opt=1$，五个整数 $x_1,y_1,x_2,y_2,v$。\n\n- 如果 $opt=3$，两个整数 $x,y$。\n\n- 否则一个整数 $d$。", "outputFormat": "对于每一个 $3,4$ 询问，输出一行答案。", "hint": "---\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f7i3u2l6.png)\n\n如图，蓝色代表射线，红色代表平面镜。\n\n对于第 $1$ 次询问：可以看出射线只穿过了平面镜 $1$，答案为 $7$。\n\n对于第 $2$ 次询问：可以看出射线只穿过了平面镜 $2$，答案为 $10$。\n\n对于第 $3$ 次询问：可以看出射线穿过了平面镜 $1,2$，答案为 $7+10=17$。\n\n对于第 $4$ 次询问，可以看出射线穿过了平面镜 $3$，答案为 $17$。\n\n对于第 $5$ 次询问，可以看出穿过平面镜 $2$ 的不透明度最大的射线为 $(0,0)(2,2)$（射线不唯一），穿过了平面镜 $1,2$，答案为 $7+10=17$。\n\n对于第 $6$ 次询问，可以看出穿过平面镜 $2$ 的不透明度最大的射线为 $(0,0)(2,2)$（射线不唯一），穿过了平面镜 $2$，答案为 $10$。\n\n对于第 $7$ 次询问，因为平面镜 $1$ 已被摧毁，所以输出 `oops!`。\n\n---\n\n### 数据范围与约定\n\n测试点编号|$n\\leq$|特殊性质\n:-:|:-:|:-:\n$1-4$|$1000$|$x,y$ 绝对值小于 $10^3$ 且**没有 $4$ 询问**\n$5-8$|$2\\times 10^5$|所有 $y$ 相等\n$9-12$|$2\\times 10^5$|$x\\ge 0$\n$13-20$|$2\\times 10^5$|无\n\n对于 $100\\%$ 的数据，有 $1\\leq n\\leq 2\\times 10^5$，$1\\leq v\\leq 10^3$ 且 $0\\leq |x|,|y|\\leq 10^5$。\n\n保证平面镜的总数不会超过 $10^5$。\n\n保证所有平面镜不会穿过 $(0,0)$，但**不保证**平面镜会退化成一个点。\n\n保证所有 $3$ 询问 $(x,y)\\neq(0,0)$。\n\n---\n\n对于所有测试点，时间限制 $2\\mathrm{s}$，空间限制 $128\\mathrm{MB}$。", "locale": "zh-CN", "translations": {"en": {"title": "\"SWTR-3\" Plane Mirrors", "background": "Student $\\mathrm{A}$ is studying physics.\n\nThe teacher is explaining the physical phenomenon of “plane mirror imaging”.\n\nBut the lecture is too boring, so he falls asleep.", "description": "Student $\\mathrm{A}$ dreams that he is standing on a platform. Around him there are some plane mirrors, and we assume his position is $(0,0)$.\n\nHe finds that each plane mirror has an initial opacity, denoted by $v_i$.\n\nIn what follows, we define:\n\n- The “opacity” of a ray as: the sum of the initial opacities of all plane mirrors that the ray passes through.\n\n- The “visual opacity” of a plane mirror as: the maximum opacity among all rays that **originate from $(0,0)$** and **pass through that plane mirror**.\n\nStudent $\\mathrm{A}$ suddenly discovers that he can control these plane mirrors, so the following problem arises.\n\nStudent $\\mathrm{A}$ needs you to perform the following operations:\n\n`1 x1 y1 x2 y2 v`: Create a plane mirror whose two endpoints are at $(x_1,y_1),(x_2,y_2)$, with initial opacity $v$.\n\n`2 d`: Destroy the $d$-th created plane mirror. It is guaranteed that it has not been destroyed.\n\n`3 x y`: Let $\\mathrm{A=(0,0),B=(x,y)}$. Query the opacity of the ray $\\mathrm{AB}$.\n\n`4 d`: Query the visual opacity of the $d$-th plane mirror. If it has been destroyed, output `oops!`.", "inputFormat": "The first line contains an integer $n$, denoting the number of operations.\n\nThe next $n$ lines: the $i$-th line starts with an integer $opt$, and then:\n\n- If $opt=1$, five integers $x_1,y_1,x_2,y_2,v$.\n\n- If $opt=3$, two integers $x,y$.\n\n- Otherwise, one integer $d$.", "outputFormat": "For each query of type $3$ or $4$, output one line with the answer.", "hint": "---\n\n### Sample Explanation\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f7i3u2l6.png)\n\nAs shown in the figure, blue represents rays and red represents plane mirrors.\n\nFor the 1st query: we can see the ray only passes through plane mirror $1$, so the answer is $7$.\n\nFor the 2nd query: we can see the ray only passes through plane mirror $2$, so the answer is $10$.\n\nFor the 3rd query: we can see the ray passes through plane mirrors $1,2$, so the answer is $7+10=17$.\n\nFor the 4th query: we can see the ray passes through plane mirror $3$, so the answer is $17$.\n\nFor the 5th query: we can see that among rays passing through plane mirror $2$, the ray with the maximum opacity is $(0,0)(2,2)$ (the ray is not unique). It passes through plane mirrors $1,2$, so the answer is $7+10=17$.\n\nFor the 6th query: we can see that among rays passing through plane mirror $2$, the ray with the maximum opacity is $(0,0)(2,2)$ (the ray is not unique). It passes through plane mirror $2$, so the answer is $10$.\n\nFor the 7th query: since plane mirror $1$ has been destroyed, output `oops!`.\n\n---\n\n### Constraints and Notes\n\nTest point ID|$n\\leq$|Special property\n:-:|:-:|:-:\n$1-4$|$1000$|$|x|,|y|$ are less than $10^3$ and there are **no type $4$ queries**\n$5-8$|$2\\times 10^5$|all $y$ are equal\n$9-12$|$2\\times 10^5$|$x\\ge 0$\n$13-20$|$2\\times 10^5$|none\n\nFor $100\\%$ of the testdata, $1\\leq n\\leq 2\\times 10^5$, $1\\leq v\\leq 10^3$, and $0\\leq |x|,|y|\\leq 10^5$.\n\nIt is guaranteed that the total number of plane mirrors will not exceed $10^5$.\n\nIt is guaranteed that no plane mirror passes through $(0,0)$, but it is **not guaranteed** that a plane mirror will not degenerate into a point.\n\nIt is guaranteed that for all type $3$ queries, $(x,y)\\neq(0,0)$.\n\n---\n\nFor all test points, the time limit is $2\\mathrm{s}$ and the memory limit is $128\\mathrm{MB}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「SWTR-3」Plane Mirrors", "background": "小 $\\mathrm{A}$ 在学物理。\n\n老师在讲“平面镜成像”这个物理现象。\n\n但老师讲课太无聊，所以他就睡着了。", "description": "小 $\\mathrm{A}$ 梦见自己站在了一个平台上，在他的周围有一些平面镜，我们假定他的位置为 $(0,0)$。\n\n他发现，每个平面镜都有一个初始不透明度，记做 $v_i$。\n\n下文中，我们定义：\n\n- 一个射线的“不透明度”为：该射线穿过的所有平面镜的初始不透明度之和。\n\n- 一个平面镜的“视觉不透明度”为：所有**从 $(0,0)$ 发出**且**经过该平面镜**的射线的不透明度最大值。\n\n小 $\\mathrm{A}$ 突然发现自己能够控制这些平面镜，于是就有了下面这道题目。\n\n小 $\\mathrm{A}$ 需要你完成以下操作：\n\n`1 x1 y1 x2 y2 v`：变出一个两端分别在 $(x_1,y_1),(x_2,y_2)$，初始不透明度为 $v$ 的平面镜。\n\n`2 d`：摧毁第 $d$ 个变出来的平面镜，保证未被摧毁。\n\n`3 x y`：设 $\\mathrm{A=(0,0),B=(x,y)}$，询问射线 $\\mathrm{AB}$ 的不透明度。\n\n`4 d`：询问第 $d$ 个平面镜的视觉不透明度，如已被摧毁则输出 `oops!`。", "inputFormat": "第一行，一个整数 $n$，表示操作次数。\n\n接下来 $n$ 行，第 $i$ 行先是一个整数 $opt$，然后：\n\n- 如果 $opt=1$，五个整数 $x_1,y_1,x_2,y_2,v$。\n\n- 如果 $opt=3$，两个整数 $x,y$。\n\n- 否则一个整数 $d$。", "outputFormat": "对于每一个 $3,4$ 询问，输出一行答案。", "hint": "---\n\n### 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/f7i3u2l6.png)\n\n如图，蓝色代表射线，红色代表平面镜。\n\n对于第 $1$ 次询问：可以看出射线只穿过了平面镜 $1$，答案为 $7$。\n\n对于第 $2$ 次询问：可以看出射线只穿过了平面镜 $2$，答案为 $10$。\n\n对于第 $3$ 次询问：可以看出射线穿过了平面镜 $1,2$，答案为 $7+10=17$。\n\n对于第 $4$ 次询问，可以看出射线穿过了平面镜 $3$，答案为 $17$。\n\n对于第 $5$ 次询问，可以看出穿过平面镜 $2$ 的不透明度最大的射线为 $(0,0)(2,2)$（射线不唯一），穿过了平面镜 $1,2$，答案为 $7+10=17$。\n\n对于第 $6$ 次询问，可以看出穿过平面镜 $2$ 的不透明度最大的射线为 $(0,0)(2,2)$（射线不唯一），穿过了平面镜 $2$，答案为 $10$。\n\n对于第 $7$ 次询问，因为平面镜 $1$ 已被摧毁，所以输出 `oops!`。\n\n---\n\n### 数据范围与约定\n\n测试点编号|$n\\leq$|特殊性质\n:-:|:-:|:-:\n$1-4$|$1000$|$x,y$ 绝对值小于 $10^3$ 且**没有 $4$ 询问**\n$5-8$|$2\\times 10^5$|所有 $y$ 相等\n$9-12$|$2\\times 10^5$|$x\\ge 0$\n$13-20$|$2\\times 10^5$|无\n\n对于 $100\\%$ 的数据，有 $1\\leq n\\leq 2\\times 10^5$，$1\\leq v\\leq 10^3$ 且 $0\\leq |x|,|y|\\leq 10^5$。\n\n保证平面镜的总数不会超过 $10^5$。\n\n保证所有平面镜不会穿过 $(0,0)$，但**不保证**平面镜会退化成一个点。\n\n保证所有 $3$ 询问 $(x,y)\\neq(0,0)$。\n\n---\n\n对于所有测试点，时间限制 $2\\mathrm{s}$，空间限制 $128\\mathrm{MB}$。", "locale": "zh-CN"}}}
{"pid": "P5860", "type": "P", "difficulty": 7, "samples": [["3\n1 1 1\n", "3"], ["5\n1 2 1 3 1\n", "8"], ["8\n1 2 1 2 4 1 3 1\n", "44"], ["50\n8 1 10 2 2 1 2 1 1 2 5 1 11 6 13 13 10 4 1 13 11 2 2 11 13 10 1 1 4 3 4 2 15 2 2 1 1 2 1 7 14 2 2 4 13 2 7 5 6 10 ", "176873472"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 3000, 3000, 3000, 3000, 3000, 3000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["数学", "O2优化", "生成函数"], "title": "「SWTR-3」Counting Trees", "background": "一个风和日丽的早晨，小 $\\mathrm{S}$ 带着他的好朋友小 $\\mathrm{A}$ 在小树林里面数树。\n\n看着满树林的树，小 $\\mathrm{S}$ 灵感一闪，想到了一道题目。\n\n---\n\n$$\\mathrm{Suddenly,\\ Little\\ S\\ thought\\ of\\ a\\ supercalifragilisticexpialidocious\\ problem.}$$\n\n$$\\mathrm{He\\ wanted\\ Little\\ A\\ to\\ answer\\ it.}$$", "description": "现在有 $n$ 个点，每个点有一个权值 $v_i$。\n\n小 $\\mathrm{S}$ 想要小 $\\mathrm{A}$ 从中选一些点组成一个集合，设集合 $S=\\{d_1,d_2,\\dots,d_m\\}(1\\leq m\\leq n)$。\n\n当然，小 $\\mathrm{A}$ 还需要保证这些点能形成一颗树，且 $d_i$ 的度数为 $v_{d_i}(i\\in[1,m])$。\n\n- 节点的度数：与它相邻的节点的个数。\n\n小 $\\mathrm{S}$ 想问小 $\\mathrm{A}$ 有多少种满足条件的方案。\n\n小 $\\mathrm{A}$ 深知自己肯定不会这道题目，所以他就拿来问你了。\n\n由于方案数可能很大，所以请对 $998244353$ 取模。", "inputFormat": "第一行，一个整数 $n$。\n\n第二行，$n$ 个整数 $v_1,v_2,\\dots,v_n$", "outputFormat": "一行一个整数，表示方案数。", "hint": "---\n\n### 样例说明\n\n- 对于样例 $1$，在三个节点中任选两个即可，答案为 $C^{2}_{3}=3$。\n\n- 对于样例 $2$，如图，共有 $8$ 种选择节点的方法。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g0suqsi0.png)\n\n---\n\n### 数据范围与约定\n\n**本题使用捆绑测试。**\n\n| Subtask 编号 | $n\\leq$ | 特殊性质 | 得分 |\n| :-: | :-: | :-: | :-: |\n| $1$ | $20$ | 无 | $11$ |\n| $2$ | $50$ | 无 | $12$ |\n| $3$ | $300$ | 无 | $10$ |\n| $4$ | $2500$ | 无 | $17$ |\n| $5$ | $4\\times 10^4$ | 无 | $6$ |\n| $6$ | $3\\times 10^5$ | $v_i\\leq 3$ | $8$ |\n| $7$ | $3\\times 10^5$ | 数据随机 | $7$ |\n| $8$ | $5\\times 10^5$ | 无 | $29$ |\n\n对于 $100\\%$ 的数据，$2 \\leq n \\leq 5 \\times 10^5$，$\\ 1 \\leq v_i \\leq n$。\n\n---\n\n$\\mathrm{Subtask\\ 7}$ 中“数据随机”指：对于所有 $v_i$，$\\frac{1}{3}$ 的概率为 1，$\\frac{2}{3}$ 的概率为 $[2,n]$ 中等概率选择一个数。\n\n---\n\n对于前 $4$ 个 $\\mathrm{Subtask}$，时间限制 $1\\mathrm{s}$。\n\n对于第 $5$ 个 $\\mathrm{Subtask}$，时间限制 $3\\mathrm{s}$。\n\n对于后 $3$ 个 $\\mathrm{Subtask}$，时间限制 $6\\mathrm{s}$。\n\n对于所有测试点，空间限制 $256\\mathrm{MB}$。", "locale": "zh-CN", "translations": {"en": {"title": "“SWTR-3” Counting Trees", "background": "On a sunny morning, Little $\\mathrm{S}$ took his good friend Little $\\mathrm{A}$ to count trees in a small forest.\n\nLooking at the forest full of trees, Little $\\mathrm{S}$ suddenly got an idea and came up with a problem.\n\n---\n\n$$\\mathrm{Suddenly,\\ Little\\ S\\ thought\\ of\\ a\\ supercalifragilisticexpialidocious\\ problem.}$$\n\n$$\\mathrm{He\\ wanted\\ Little\\ A\\ to\\ answer\\ it.}$$", "description": "There are $n$ vertices, and each vertex has a weight $v_i$.\n\nLittle $\\mathrm{S}$ wants Little $\\mathrm{A}$ to choose some vertices to form a set. Let the set be $S=\\{d_1,d_2,\\dots,d_m\\}(1\\leq m\\leq n)$.\n\nOf course, Little $\\mathrm{A}$ also needs to ensure that these vertices can form a tree, and the degree of $d_i$ is $v_{d_i}(i\\in[1,m])$.\n\n- Degree of a vertex: the number of vertices adjacent to it.\n\nLittle $\\mathrm{S}$ asks Little $\\mathrm{A}$ how many ways there are that satisfy the conditions.\n\nLittle $\\mathrm{A}$ knows he definitely cannot solve this problem, so he asks you for help.\n\nSince the number of ways may be very large, output it modulo $998244353$.", "inputFormat": "The first line contains an integer $n$.\n\nThe second line contains $n$ integers $v_1,v_2,\\dots,v_n$.", "outputFormat": "Output one integer in one line, representing the number of valid ways.", "hint": "---\n\n### Sample Explanation\n\n- For sample $1$, it is enough to choose any two vertices among the three vertices. The answer is $C^{2}_{3}=3$.\n\n- For sample $2$, as shown in the figure, there are $8$ ways to choose vertices.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g0suqsi0.png)\n\n---\n\n### Constraints and Notes\n\n**This problem uses bundled testdata.**\n\n| Subtask ID | $n\\leq$ | Special Property | Score |\n| :-: | :-: | :-: | :-: |\n| $1$ | $20$ | None | $11$ |\n| $2$ | $50$ | None | $12$ |\n| $3$ | $300$ | None | $10$ |\n| $4$ | $2500$ | None | $17$ |\n| $5$ | $4\\times 10^4$ | None | $6$ |\n| $6$ | $3\\times 10^5$ | $v_i\\leq 3$ | $8$ |\n| $7$ | $3\\times 10^5$ | Random testdata | $7$ |\n| $8$ | $5\\times 10^5$ | None | $29$ |\n\nFor $100\\%$ of the testdata, $2 \\leq n \\leq 5 \\times 10^5$ and $\\ 1 \\leq v_i \\leq n$.\n\n---\n\nIn $\\mathrm{Subtask\\ 7}$, “random testdata” means: for every $v_i$, it equals $1$ with probability $\\frac{1}{3}$, and with probability $\\frac{2}{3}$ it is chosen uniformly at random from $[2,n]$.\n\n---\n\nFor the first $4$ $\\mathrm{Subtask}$s, the time limit is $1\\mathrm{s}$.\n\nFor the $5$th $\\mathrm{Subtask}$, the time limit is $3\\mathrm{s}$.\n\nFor the last $3$ $\\mathrm{Subtask}$s, the time limit is $6\\mathrm{s}$.\n\nFor all test points, the memory limit is $256\\mathrm{MB}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "「SWTR-3」Counting Trees", "background": "一个风和日丽的早晨，小 $\\mathrm{S}$ 带着他的好朋友小 $\\mathrm{A}$ 在小树林里面数树。\n\n看着满树林的树，小 $\\mathrm{S}$ 灵感一闪，想到了一道题目。\n\n---\n\n$$\\mathrm{Suddenly,\\ Little\\ S\\ thought\\ of\\ a\\ supercalifragilisticexpialidocious\\ problem.}$$\n\n$$\\mathrm{He\\ wanted\\ Little\\ A\\ to\\ answer\\ it.}$$", "description": "现在有 $n$ 个点，每个点有一个权值 $v_i$。\n\n小 $\\mathrm{S}$ 想要小 $\\mathrm{A}$ 从中选一些点组成一个集合，设集合 $S=\\{d_1,d_2,\\dots,d_m\\}(1\\leq m\\leq n)$。\n\n当然，小 $\\mathrm{A}$ 还需要保证这些点能形成一颗树，且 $d_i$ 的度数为 $v_{d_i}(i\\in[1,m])$。\n\n- 节点的度数：与它相邻的节点的个数。\n\n小 $\\mathrm{S}$ 想问小 $\\mathrm{A}$ 有多少种满足条件的方案。\n\n小 $\\mathrm{A}$ 深知自己肯定不会这道题目，所以他就拿来问你了。\n\n由于方案数可能很大，所以请对 $998244353$ 取模。", "inputFormat": "第一行，一个整数 $n$。\n\n第二行，$n$ 个整数 $v_1,v_2,\\dots,v_n$", "outputFormat": "一行一个整数，表示方案数。", "hint": "---\n\n### 样例说明\n\n- 对于样例 $1$，在三个节点中任选两个即可，答案为 $C^{2}_{3}=3$。\n\n- 对于样例 $2$，如图，共有 $8$ 种选择节点的方法。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/g0suqsi0.png)\n\n---\n\n### 数据范围与约定\n\n**本题使用捆绑测试。**\n\n| Subtask 编号 | $n\\leq$ | 特殊性质 | 得分 |\n| :-: | :-: | :-: | :-: |\n| $1$ | $20$ | 无 | $11$ |\n| $2$ | $50$ | 无 | $12$ |\n| $3$ | $300$ | 无 | $10$ |\n| $4$ | $2500$ | 无 | $17$ |\n| $5$ | $4\\times 10^4$ | 无 | $6$ |\n| $6$ | $3\\times 10^5$ | $v_i\\leq 3$ | $8$ |\n| $7$ | $3\\times 10^5$ | 数据随机 | $7$ |\n| $8$ | $5\\times 10^5$ | 无 | $29$ |\n\n对于 $100\\%$ 的数据，$2 \\leq n \\leq 5 \\times 10^5$，$\\ 1 \\leq v_i \\leq n$。\n\n---\n\n$\\mathrm{Subtask\\ 7}$ 中“数据随机”指：对于所有 $v_i$，$\\frac{1}{3}$ 的概率为 1，$\\frac{2}{3}$ 的概率为 $[2,n]$ 中等概率选择一个数。\n\n---\n\n对于前 $4$ 个 $\\mathrm{Subtask}$，时间限制 $1\\mathrm{s}$。\n\n对于第 $5$ 个 $\\mathrm{Subtask}$，时间限制 $3\\mathrm{s}$。\n\n对于后 $3$ 个 $\\mathrm{Subtask}$，时间限制 $6\\mathrm{s}$。\n\n对于所有测试点，空间限制 $256\\mathrm{MB}$。", "locale": "zh-CN"}}}
{"pid": "P5861", "type": "P", "difficulty": 7, "samples": [["4\n2 4\n1 2\n2 3\n2 3\n2\n2 1 3\n2 1 1\n", "1\n0\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["2015", "IOI"], "title": "[IOI 2015] teams", "background": "", "description": "班里有 $N$ 个学生,他们的编号为从 $0$ 到 $N-1$。每天，老师都有一些项目需要学生去完成。每个项目都需要由一组学生在一天内完成。项目的难度可能不同。对于每个项目，老师知道应该选择由多少学生组成的小组去完成。\n\n不同的学生对小组的规模有不同的喜好。更准确地说, 对学生 $i$ 而言, 他只愿意在小组规模介于 $A[i]$ 和 $B[i]$ 之间（含 $A[i]$ 和 $B[i]$）的小组工作。每一天，一个学生最多只能被分配到一个小组工作。有些学生可能未被分配到任何小组中。每个小组只负责一个项目。\n\n老师已选择好接下来 $Q$ 天中每一天的项目。对于每一天, 现需要判断是否有一种分配学生的方案，使得每个项目都有一个小组负责。", "inputFormat": "- 第 $1$ 行有一个正整数 $N$，表示班内学生的数量；\n- 第 $2$ 到 $N+1$ 行有两个 $A[i]$，$B[i]$；\n- 第 $N+2$ 行有一个正整数 $Q$；\n- 第 $N+3$ 到 $N+Q+2$ 行，包含一个正整数 $M$，表示当天要完成的项目数， 后有一个长度为 $M$ 的序列 $K$。$K[i]$ （$1\\le i\\le M$） 表示项目 $i$ 所需的小组规模。", "outputFormat": "共 $Q$ 行，对于每一个问题, 你的程序必须输出是否存在一种小组分配的方案，可以完成当天的所有项目。若可以完成分组去完成当天所有的项目，输出 `1`, 否则，应输出 `0`。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 5 \\times 10^5$，$1\\le Q\\le 2 \\times 10^5$， $\\sum M \\leq 2\\times 10^5$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2015] teams", "background": "", "description": "There are $N$ students in the class, numbered from $0$ to $N-1$. Every day, the teacher has some projects that need to be completed by students. Each project must be completed within one day by a team of students. The projects may have different difficulty levels. For each project, the teacher knows how many students should be chosen to form a team to complete it.\n\nDifferent students have different preferences for team size. More precisely, for student $i$, they are only willing to work in a team whose size is between $A[i]$ and $B[i]$ (including $A[i]$ and $B[i]$). Each day, a student can be assigned to at most one team. Some students may not be assigned to any team. Each team is responsible for exactly one project.\n\nThe teacher has already selected the projects for each of the next $Q$ days. For each day, you need to determine whether there exists an assignment of students such that every project has a team responsible for it.", "inputFormat": "- Line $1$ contains a positive integer $N$, the number of students in the class.\n- Lines $2$ to $N+1$ each contain two integers $A[i]$, $B[i]$.\n- Line $N+2$ contains a positive integer $Q$.\n- Lines $N+3$ to $N+Q+2$ each contain a positive integer $M$, the number of projects to be completed that day, followed by a sequence $K$ of length $M$. $K[i]$ ($1 \\le i \\le M$) denotes the required team size for project $i$.", "outputFormat": "Output $Q$ lines. For each query, your program must output whether there exists a team assignment plan that can complete all projects of that day. If it is possible to form teams to complete all projects for that day, output `1`; otherwise, output `0`.", "hint": "For $100\\%$ of the testdata, $1 \\le N \\le 5 \\times 10^5$, $1 \\le Q \\le 2 \\times 10^5$, $\\sum M \\leq 2 \\times 10^5$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2015] teams", "background": "", "description": "班里有 $N$ 个学生,他们的编号为从 $0$ 到 $N-1$。每天，老师都有一些项目需要学生去完成。每个项目都需要由一组学生在一天内完成。项目的难度可能不同。对于每个项目，老师知道应该选择由多少学生组成的小组去完成。\n\n不同的学生对小组的规模有不同的喜好。更准确地说, 对学生 $i$ 而言, 他只愿意在小组规模介于 $A[i]$ 和 $B[i]$ 之间（含 $A[i]$ 和 $B[i]$）的小组工作。每一天，一个学生最多只能被分配到一个小组工作。有些学生可能未被分配到任何小组中。每个小组只负责一个项目。\n\n老师已选择好接下来 $Q$ 天中每一天的项目。对于每一天, 现需要判断是否有一种分配学生的方案，使得每个项目都有一个小组负责。", "inputFormat": "- 第 $1$ 行有一个正整数 $N$，表示班内学生的数量；\n- 第 $2$ 到 $N+1$ 行有两个 $A[i]$，$B[i]$；\n- 第 $N+2$ 行有一个正整数 $Q$；\n- 第 $N+3$ 到 $N+Q+2$ 行，包含一个正整数 $M$，表示当天要完成的项目数， 后有一个长度为 $M$ 的序列 $K$。$K[i]$ （$1\\le i\\le M$） 表示项目 $i$ 所需的小组规模。", "outputFormat": "共 $Q$ 行，对于每一个问题, 你的程序必须输出是否存在一种小组分配的方案，可以完成当天的所有项目。若可以完成分组去完成当天所有的项目，输出 `1`, 否则，应输出 `0`。", "hint": "对于 $100\\%$ 的数据，$1\\le N\\le 5 \\times 10^5$，$1\\le Q\\le 2 \\times 10^5$， $\\sum M \\leq 2\\times 10^5$。", "locale": "zh-CN"}}}
{"pid": "P5862", "type": "P", "difficulty": 6, "samples": [["5\n4 3 2 1 0\n6\n0 1\n1 2\n2 3\n3 4\n0 1\n1 2\n", "3\n0 4\n1 3\n3 4"], ["5\n3 0 4 2 1\n5\n1 1\n4 0\n2 3\n1 4\n0 4\n", "3\n1 4\n4 2\n2 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["2015", "IOI", "Special Judge"], "title": "[IOI 2015] sorting", "background": "", "description": "Aizhan 有一个由 $N$ 个互不相同的整数组成的序列 $S[0],S[1],\\cdots,S[N-1]$，其中 $S[i]$ 取值范围是 $[0,N-1]$。Aizhan 试图通过交换某些元素对的方法将这个序列按照升序排序。Aizhan 的朋友 Ermek 也想交换某些元素对， Ermek 的交换未必有助于 Aizhan 的排序。\n\nErmek 和 Aizhan 打算通过若干轮次来修改这个序列。在每一轮，Ermek 首先做一次交换，然后 Aizhan 做另一次交换。更确切地说，做交换的人选择两个有效的下标并交换这两个下标的元素。请注意这两个下标可能相同。如果它们相等，则对这个元素自身做交换，并不改变这个序列。\n\nAizhan 知道 Ermek 并不关心对序列 \n$S$ 排序的事情。Aizhan还知道 Ermek 将会选择哪些下标。Ermek 打算参加 $M$ 轮交换，将这些轮次从 $0$ 到 $M-1$ 编号。对于 $0$ 到 $M-1$ 之间的每个 $i$，Ermek 在第 $i$ 轮将选择下标 $X[i]$ 和 $Y[i]$ 的元素进行交换。\n\nAizhan 要对序列 $S$ 按升序进行排序。在每一轮之前，如果 Aizhan 看到当前的序列已经按升序排列，她将结束这个排序过程。给定初始序列 $S$ 以及 Ermek 要选择的下标，请你找出一个交换的序列，使得 Aizhan 能完成对序列 $S$ 的排序。此外，在有些子任务中，你还要找出尽可能短的交换序列来完成排序任务。题目保证通过 $M$ 或更少的轮次能够将序列 $S$ 排好序。\n\n请注意如果 Aizhan 发现在 Ermek 的交换之后，序列 $S$ 已经排好序，则 Aizhan 可以选择交换两个相同下标（例如 $0$ 和 $0$）的元素。这样，序列 $S$ 在这一轮次之后也完成排序，于是也达到了 Aizhan 的目标。另外，如果初始序列 $S$ 就已经排好序，那么所需的最少排序轮数就是 $0$。", "inputFormat": "- 第 $1$ 行有一个正整数 $N$，表示序列 $S$ 的长度；\n- 第 $2$ 行有 $N$ 个正整数，分别为 $S[0],\\cdots,S[N-1]$，即初始序列 $S$；\n- 第 $3$ 行有一个正整数 $M$，表示 Ermek 打算做交换的次数；\n- 第 $4$ 到 $M+3$ 行，有两个正整数 $X[i]$，$Y[i]$，表示对于 $0\\le i\\le M-1$, 在第 $i$ 轮 Ermek 打算交换下标为 $X[i]$ 和 $Y[i]$ 的数组。", "outputFormat": "- 第 $1$ 行 : 交换的长度 $R$；\n- 第 $2+i$（$0\\le i < R$）行：$P[i]$，$Q[i]$。\n\n注：$P$，$Q$分别为两个整数数组。利用这两个数组报告 Aizhan 完成对序列 $S$ 排序的一种可能的交换序列，假设这个交换序列的长度为 $R$，对于 $0$ 到 $R-1$ 之间的每个 $i$，Aizhan 在轮次 $i$ 选择的下标将被存入 $P[i]$ 和 $Q[i]$。 你可以假设数组 $P$ 和 $Q$ 均已分别被分配了 \n$M$ 个元素。", "hint": "对于 $100\\%$ 的数据，$1 \\le N\\le 2 \\times 10^5$，$1 \\le M \\le 6 \\times 10^5$。要求 $R$ 取最小值。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2015] sorting", "background": "", "description": "Aizhan has a sequence $S[0],S[1],\\cdots,S[N-1]$ consisting of $N$ distinct integers, where $S[i]$ is in the range $[0,N-1]$. Aizhan tries to sort this sequence in increasing order by swapping some pairs of elements. Aizhan’s friend Ermek also wants to swap some pairs of elements, and Ermek’s swaps may not help Aizhan sort the sequence.\n\nErmek and Aizhan plan to modify this sequence through several rounds. In each round, Ermek makes one swap first, and then Aizhan makes another swap. More precisely, the person who performs a swap chooses two valid indices and swaps the elements at those indices. Note that the two indices may be the same. If they are equal, it is a swap of an element with itself and does not change the sequence.\n\nAizhan knows that Ermek does not care about sorting the sequence $S$. She also knows which indices Ermek will choose. Ermek plans to take part in $M$ rounds of swaps, numbered from $0$ to $M-1$. For each $i$ between $0$ and $M-1$, in round $i$, Ermek will swap the elements at indices $X[i]$ and $Y[i]$.\n\nAizhan wants to sort the sequence $S$ in increasing order. Before each round, if Aizhan sees that the current sequence is already sorted in increasing order, she will stop the sorting process. Given the initial sequence $S$ and the indices Ermek will choose, you need to find a sequence of swaps so that Aizhan can finish sorting $S$. In addition, in some subtasks, you also need to find a swap sequence that is as short as possible. The problem guarantees that $S$ can be sorted in $M$ or fewer rounds.\n\nNote that if Aizhan finds that after Ermek’s swap, the sequence $S$ is already sorted, then Aizhan may choose to swap two identical indices (for example $0$ and $0$). This way, $S$ is still sorted after this round, and Aizhan’s goal is achieved. Also, if the initial sequence $S$ is already sorted, then the minimum number of sorting rounds needed is $0$.", "inputFormat": "- Line $1$ contains a positive integer $N$, the length of the sequence $S$.\n- Line $2$ contains $N$ positive integers $S[0],\\cdots,S[N-1]$, the initial sequence $S$.\n- Line $3$ contains a positive integer $M$, the number of swaps Ermek plans to perform.\n- Lines $4$ to $M+3$ each contain two positive integers $X[i]$, $Y[i]$, meaning that for $0\\le i\\le M-1$, in round $i$, Ermek plans to swap the elements at indices $X[i]$ and $Y[i]$.", "outputFormat": "- Line $1$: the length of the swap sequence $R$.\n- Line $2+i$ ($0\\le i < R$): $P[i]$, $Q[i]$.\n\nNote: $P$ and $Q$ are two integer arrays. Use these two arrays to report one possible swap sequence with which Aizhan can finish sorting $S$. Suppose the length of this swap sequence is $R$. For each $i$ from $0$ to $R-1$, the indices Aizhan chooses in round $i$ will be stored in $P[i]$ and $Q[i]$. You may assume that arrays $P$ and $Q$ have each been allocated $M$ elements.", "hint": "For $100\\%$ of the testdata, $1 \\le N\\le 2 \\times 10^5$, $1 \\le M \\le 6 \\times 10^5$. It is required that $R$ be minimized.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2015] sorting", "background": "", "description": "Aizhan 有一个由 $N$ 个互不相同的整数组成的序列 $S[0],S[1],\\cdots,S[N-1]$，其中 $S[i]$ 取值范围是 $[0,N-1]$。Aizhan 试图通过交换某些元素对的方法将这个序列按照升序排序。Aizhan 的朋友 Ermek 也想交换某些元素对， Ermek 的交换未必有助于 Aizhan 的排序。\n\nErmek 和 Aizhan 打算通过若干轮次来修改这个序列。在每一轮，Ermek 首先做一次交换，然后 Aizhan 做另一次交换。更确切地说，做交换的人选择两个有效的下标并交换这两个下标的元素。请注意这两个下标可能相同。如果它们相等，则对这个元素自身做交换，并不改变这个序列。\n\nAizhan 知道 Ermek 并不关心对序列 \n$S$ 排序的事情。Aizhan还知道 Ermek 将会选择哪些下标。Ermek 打算参加 $M$ 轮交换，将这些轮次从 $0$ 到 $M-1$ 编号。对于 $0$ 到 $M-1$ 之间的每个 $i$，Ermek 在第 $i$ 轮将选择下标 $X[i]$ 和 $Y[i]$ 的元素进行交换。\n\nAizhan 要对序列 $S$ 按升序进行排序。在每一轮之前，如果 Aizhan 看到当前的序列已经按升序排列，她将结束这个排序过程。给定初始序列 $S$ 以及 Ermek 要选择的下标，请你找出一个交换的序列，使得 Aizhan 能完成对序列 $S$ 的排序。此外，在有些子任务中，你还要找出尽可能短的交换序列来完成排序任务。题目保证通过 $M$ 或更少的轮次能够将序列 $S$ 排好序。\n\n请注意如果 Aizhan 发现在 Ermek 的交换之后，序列 $S$ 已经排好序，则 Aizhan 可以选择交换两个相同下标（例如 $0$ 和 $0$）的元素。这样，序列 $S$ 在这一轮次之后也完成排序，于是也达到了 Aizhan 的目标。另外，如果初始序列 $S$ 就已经排好序，那么所需的最少排序轮数就是 $0$。", "inputFormat": "- 第 $1$ 行有一个正整数 $N$，表示序列 $S$ 的长度；\n- 第 $2$ 行有 $N$ 个正整数，分别为 $S[0],\\cdots,S[N-1]$，即初始序列 $S$；\n- 第 $3$ 行有一个正整数 $M$，表示 Ermek 打算做交换的次数；\n- 第 $4$ 到 $M+3$ 行，有两个正整数 $X[i]$，$Y[i]$，表示对于 $0\\le i\\le M-1$, 在第 $i$ 轮 Ermek 打算交换下标为 $X[i]$ 和 $Y[i]$ 的数组。", "outputFormat": "- 第 $1$ 行 : 交换的长度 $R$；\n- 第 $2+i$（$0\\le i < R$）行：$P[i]$，$Q[i]$。\n\n注：$P$，$Q$分别为两个整数数组。利用这两个数组报告 Aizhan 完成对序列 $S$ 排序的一种可能的交换序列，假设这个交换序列的长度为 $R$，对于 $0$ 到 $R-1$ 之间的每个 $i$，Aizhan 在轮次 $i$ 选择的下标将被存入 $P[i]$ 和 $Q[i]$。 你可以假设数组 $P$ 和 $Q$ 均已分别被分配了 \n$M$ 个元素。", "hint": "对于 $100\\%$ 的数据，$1 \\le N\\le 2 \\times 10^5$，$1 \\le M \\le 6 \\times 10^5$。要求 $R$ 取最小值。", "locale": "zh-CN"}}}
{"pid": "P5863", "type": "P", "difficulty": 5, "samples": [["156", "4"], ["9524", "4"], ["42657", "6"], ["5735832847451", "28"]], "limits": {"time": [300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "枚举", "ICPC", "分类讨论", "SEERC"], "title": "[SEERC 2018] Numbers", "background": "", "description": "一个回文数是一个正着写和倒着写得到的数字相等的整数。例如，数字 $142241$ 和数字 $102201$ 都是回文数，但数字 $1023401$ 和 $10510$ 不是。你想将一个数字 $n$ 分解成两个回文数之和的形式，请计算分解成上述形式的方案数。", "inputFormat": "仅一行包含一个整数 $n \\ (1 \\leq n \\leq 10^{18})$。", "outputFormat": "输出一个整数，代表将 $n$ 分解为两个回文数之和的方案数。", "hint": "第一个样例中，有下列分解方法：$(5, 151), (55, 101), (101, 55), (151, 5)$。\n\n第二个样例中，有下列分解方法：$(515, 9009), (636, 8888), (8888, 636), (9009, 515)$。\n\n第三个样例中，有下列分解方法：$(33, 42624), (333, 42324), (4884, 37773), (37773, 4884), (42324, 333), (42624, 33)$。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Numbers", "background": "", "description": "A palindromic number is an integer that reads the same when written normally and when written in reverse. For example, the numbers $142241$ and $102201$ are palindromic, but the numbers $1023401$ and $10510$ are not. You want to decompose a number $n$ into a sum of two palindromic numbers. Please compute the number of ways to decompose it in this form.", "inputFormat": "Only one line contains an integer $n \\ (1 \\leq n \\leq 10^{18})$.", "outputFormat": "Output an integer representing the number of ways to decompose $n$ as the sum of two palindromic numbers.", "hint": "In the first sample, the decompositions are: $(5, 151), (55, 101), (101, 55), (151, 5)$.\n\nIn the second sample, the decompositions are: $(515, 9009), (636, 8888), (8888, 636), (9009, 515)$.\n\nIn the third sample, the decompositions are: $(33, 42624), (333, 42324), (4884, 37773), (37773, 4884), (42324, 333), (42624, 33)$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Numbers", "background": "", "description": "一个回文数是一个正着写和倒着写得到的数字相等的整数。例如，数字 $142241$ 和数字 $102201$ 都是回文数，但数字 $1023401$ 和 $10510$ 不是。你想将一个数字 $n$ 分解成两个回文数之和的形式，请计算分解成上述形式的方案数。", "inputFormat": "仅一行包含一个整数 $n \\ (1 \\leq n \\leq 10^{18})$。", "outputFormat": "输出一个整数，代表将 $n$ 分解为两个回文数之和的方案数。", "hint": "第一个样例中，有下列分解方法：$(5, 151), (55, 101), (101, 55), (151, 5)$。\n\n第二个样例中，有下列分解方法：$(515, 9009), (636, 8888), (8888, 636), (9009, 515)$。\n\n第三个样例中，有下列分解方法：$(33, 42624), (333, 42324), (4884, 37773), (37773, 4884), (42324, 333), (42624, 33)$。", "locale": "zh-CN"}}}
{"pid": "P5864", "type": "P", "difficulty": 4, "samples": [["15000 15000 15000 2", "0"], ["5000 10000 15000 3", "6"], ["15000 15000 15000 3", "1"], ["15000 15000 15000 4", "4"], ["15000 15000 15000 5", "5"], ["15000 15000 15000 6", "14"]], "limits": {"time": [200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "ICPC", "SEERC"], "title": "[SEERC 2018] Broken Watch", "background": "", "description": "一架 UFO 坠毁在地球上。外星人船长幸免于难，但他的手表没能逃过这一劫。\n\n外星人的手表和人类的手表非常相似：手表有一个直径为 $\\text{30 mm}$ 的表盘，有三个表针，长度分别为 $A, B$ 和 $C \\ (1000 \\leq A, B, C \\leq 15000)$ 微米。然而，外星人有不同的时间单位：$1$ 分钟里有 $N \\ (2 \\leq N < 2^{32})$ 秒。因此，表盘的边缘上有 $N$ 个刻度而不是 $60$ 个。\n\n手表的玻璃面板已经摔碎，表针也松了：它们可以独立地自由旋转。让三个表针分别指向任意刻度，以表针的尖端的顶点可以构成一个三角形（表针不共线的前提下）。\n\n在救援来之前外星人闲着没事干，就思考起了这样一个问题：按上述方法构成的三角形中，有多少个三角形包含了表盘的中心（答案记为 $M$）。（表盘中心在三角形的某一边上的三角形也要统计。）", "inputFormat": "仅一行包含整数 $A, B, C$ 和 $N$，四个数字之间用一个半角空格隔开。", "outputFormat": "输出 $M \\bmod 2^{64}$ 的值。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Broken Watch", "background": "", "description": "A UFO crashed on Earth. The alien captain survived, but his watch did not.\n\nThe alien watch is very similar to a human watch: it has a dial with a diameter of $\\text{30 mm}$, and three hands with lengths $A$, $B$, and $C$ $(1000 \\leq A, B, C \\leq 15000)$ micrometers. However, aliens use different time units: one minute has $N$ seconds $(2 \\leq N < 2^{32})$. Therefore, there are $N$ tick marks on the rim of the dial instead of $60$.\n\nThe glass panel of the watch is broken, and the hands are loose: they can rotate freely and independently. Let the three hands point to any tick marks. Then the tips of the three hands can form a triangle (assuming the three hands are not collinear).\n\nBefore rescue arrives, the alien has nothing to do and thinks about the following problem: among all triangles formed in the way described above, how many triangles contain the center of the dial (denote the answer by $M$)? (Triangles where the center lies on one side of the triangle should also be counted.)", "inputFormat": "A single line contains integers $A$, $B$, $C$, and $N$, separated by one space.", "outputFormat": "Output the value of $M \\bmod 2^{64}$.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Broken Watch", "background": "", "description": "一架 UFO 坠毁在地球上。外星人船长幸免于难，但他的手表没能逃过这一劫。\n\n外星人的手表和人类的手表非常相似：手表有一个直径为 $\\text{30 mm}$ 的表盘，有三个表针，长度分别为 $A, B$ 和 $C \\ (1000 \\leq A, B, C \\leq 15000)$ 微米。然而，外星人有不同的时间单位：$1$ 分钟里有 $N \\ (2 \\leq N < 2^{32})$ 秒。因此，表盘的边缘上有 $N$ 个刻度而不是 $60$ 个。\n\n手表的玻璃面板已经摔碎，表针也松了：它们可以独立地自由旋转。让三个表针分别指向任意刻度，以表针的尖端的顶点可以构成一个三角形（表针不共线的前提下）。\n\n在救援来之前外星人闲着没事干，就思考起了这样一个问题：按上述方法构成的三角形中，有多少个三角形包含了表盘的中心（答案记为 $M$）。（表盘中心在三角形的某一边上的三角形也要统计。）", "inputFormat": "仅一行包含整数 $A, B, C$ 和 $N$，四个数字之间用一个半角空格隔开。", "outputFormat": "输出 $M \\bmod 2^{64}$ 的值。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5865", "type": "P", "difficulty": 3, "samples": [["6 3\n1 1 0 1 1 1\n1 2\n1 3\n1 4\n3 5\n3 6", "2"], ["9 4\n1 0 1 0 1 0 0 1 1\n1 2\n2 4\n2 3\n4 5\n1 6\n6 7\n6 8\n7 9", "5"]], "limits": {"time": [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "枚举", "ICPC", "SEERC"], "title": "[SEERC 2018] Tree", "background": "", "description": "给定一棵 $n$ 个点的树，点的编号从 $1$ 到 $n$。每个点有黑色或白色的颜色。选出恰好 $m$ 个黑点，使得黑点两两之间的距离的最大值最小。输出这个最小的最大值。", "inputFormat": "第一行包含两个整数 $n$ 和 $m \\ (1 \\leq m \\leq n \\leq 100)$，代表树的点数和要选出的黑点数量。\n\n第二行包含 $n$ 个整数 $p_1, p_2, \\dots, p_n \\ (0 \\leq p_i \\leq 1)$。如果 $p_i=1$ 则点 $i$ 是黑色的，否则是白色的。数据保证黑点有不少于 $m$ 个。\n\n接下来 $n-1$ 行每行包含两个整数 $v_i$ 和 $u_i \\ (1 \\leq v_i, u_i, \\leq n)$，代表树上有一条连接点 $v_i$ 和 $u_i$ 的边。数据保证这些边构成一棵树。", "outputFormat": "输出一个整数，代表答案。", "hint": "第一个样例中，唯一的选法是选点 $1, 2$ 和 $4$，距离的最大值为 $2$。\n\n第二个样例中，可行的一种选法是选点 $1, 3, 8$ 和 $9$，最大的距离是点 $3$ 和 $9$ 的距离。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Tree", "background": "", "description": "You are given a tree with $n$ vertices, numbered from $1$ to $n$. Each vertex is colored either black or white. Select exactly $m$ black vertices so that the maximum distance among all pairs of selected black vertices is minimized. Output this minimal possible maximum distance.", "inputFormat": "The first line contains two integers $n$ and $m \\ (1 \\leq m \\leq n \\leq 100)$, representing the number of vertices in the tree and the number of black vertices to be selected.\n\nThe second line contains $n$ integers $p_1, p_2, \\dots, p_n \\ (0 \\leq p_i \\leq 1)$. If $p_i = 1$, then vertex $i$ is black; otherwise it is white. The testdata guarantees that there are at least $m$ black vertices.\n\nThe next $n - 1$ lines each contain two integers $v_i$ and $u_i \\ (1 \\leq v_i, u_i \\leq n)$, indicating that there is an edge between vertices $v_i$ and $u_i$ in the tree. The testdata guarantees that these edges form a tree.", "outputFormat": "Output one integer, which is the answer.", "hint": "In the first sample, the only possible choice is to select vertices $1$, $2$, and $4$, and the maximum distance is $2$.\n\nIn the second sample, one feasible choice is to select vertices $1$, $3$, $8$, and $9$. The maximum distance is the distance between vertices $3$ and $9$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Tree", "background": "", "description": "给定一棵 $n$ 个点的树，点的编号从 $1$ 到 $n$。每个点有黑色或白色的颜色。选出恰好 $m$ 个黑点，使得黑点两两之间的距离的最大值最小。输出这个最小的最大值。", "inputFormat": "第一行包含两个整数 $n$ 和 $m \\ (1 \\leq m \\leq n \\leq 100)$，代表树的点数和要选出的黑点数量。\n\n第二行包含 $n$ 个整数 $p_1, p_2, \\dots, p_n \\ (0 \\leq p_i \\leq 1)$。如果 $p_i=1$ 则点 $i$ 是黑色的，否则是白色的。数据保证黑点有不少于 $m$ 个。\n\n接下来 $n-1$ 行每行包含两个整数 $v_i$ 和 $u_i \\ (1 \\leq v_i, u_i, \\leq n)$，代表树上有一条连接点 $v_i$ 和 $u_i$ 的边。数据保证这些边构成一棵树。", "outputFormat": "输出一个整数，代表答案。", "hint": "第一个样例中，唯一的选法是选点 $1, 2$ 和 $4$，距离的最大值为 $2$。\n\n第二个样例中，可行的一种选法是选点 $1, 3, 8$ 和 $9$，最大的距离是点 $3$ 和 $9$ 的距离。", "locale": "zh-CN"}}}
{"pid": "P5866", "type": "P", "difficulty": 4, "samples": [["2\n5 2 4\n1 2 2\n2 3 2\n1 4 2\n4 5 2\n7 2 0\n1 2 1\n1 3 5\n2 4 10\n2 5 1\n5 6 10\n5 7 5", "12\n33"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "树形 DP", "ICPC", "SEERC"], "title": "[SEERC 2018] Space Station", "background": "", "description": "Jones 实现了他的梦想：他加入了国际空间站（ISS）的一次任务。他接受了他的第一个任务：检查空间站上的电子设备的工作状况。\n\nISS 被分为 $N$ 个模块，模块从 $1$ 到 $N$ 编号。Jones 发现，为了提高效率，空间站的设计使任意两个模块之间仅存在一条简单路径。在一次太阳耀斑活动中，连接两个模块的双向通道很容易受到辐射影响。检查一条通道 $i$ 的状况必须花费 $C_i$ 的时间。Jones 需要找到一条从模块 $1$ 出发，经过每条通道至少一次，再回到模块 $1$ 的最快路径。\n\n除了从模块之间的通道中通过之外，Jones 还可以穿上宇航服，跳出空间站，从外面直接从某一模块移动到任意模块上，但是这种方法只能进行最多 $M$ 次。Jones 假设进行一次需要花费固定的时间 $K$。", "inputFormat": "第一行包含一个整数 $T$，代表测试组数。\n\n每个测试组中，第一行包含三个整数 $N, M, K \\ (1 \\leq N, M \\leq 1000)$，接下来 $N-1$ 行每一行包含三个整数 $A, B, C \\ (1 \\leq A \\leq B \\leq N; 0 \\leq C,K \\leq 10^6)$，代表在模块 $A$ 和 $B$ 之间有一条通道，检查它需要花费 $C$ 时间。", "outputFormat": "对于每一组测试数据，输出一行答案。", "hint": "", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Space Station", "background": "", "description": "Jones has achieved his dream: he joined a mission to the International Space Station (ISS). He received his first task: to check whether the electronic equipment on the space station is working properly.\n\nThe ISS is divided into $N$ modules, numbered from $1$ to $N$. Jones found that, to improve efficiency, the station was designed so that between any two modules there exists exactly one simple path. During a solar flare event, the bidirectional corridor connecting two modules can easily be affected by radiation. Checking the condition of a corridor $i$ requires $C_i$ time. Jones needs to find the fastest route that starts from module $1$, passes through every corridor at least once, and returns to module $1$.\n\nBesides moving through the corridors between modules, Jones can also put on a spacesuit, leave the station, and move directly from one module to any other module from the outside, but he can do this at most $M$ times. Jones assumes each such move takes a fixed time $K$.", "inputFormat": "The first line contains an integer $T$, which denotes the number of test cases.\n\nFor each test case, the first line contains three integers $N, M, K \\ (1 \\leq N, M \\leq 1000)$. The next $N-1$ lines each contain three integers $A, B, C \\ (1 \\leq A \\leq B \\leq N; 0 \\leq C,K \\leq 10^6)$, meaning there is a corridor between modules $A$ and $B$, and checking it takes $C$ time.", "outputFormat": "For each testdata, output one line containing the answer.", "hint": "\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Space Station", "background": "", "description": "Jones 实现了他的梦想：他加入了国际空间站（ISS）的一次任务。他接受了他的第一个任务：检查空间站上的电子设备的工作状况。\n\nISS 被分为 $N$ 个模块，模块从 $1$ 到 $N$ 编号。Jones 发现，为了提高效率，空间站的设计使任意两个模块之间仅存在一条简单路径。在一次太阳耀斑活动中，连接两个模块的双向通道很容易受到辐射影响。检查一条通道 $i$ 的状况必须花费 $C_i$ 的时间。Jones 需要找到一条从模块 $1$ 出发，经过每条通道至少一次，再回到模块 $1$ 的最快路径。\n\n除了从模块之间的通道中通过之外，Jones 还可以穿上宇航服，跳出空间站，从外面直接从某一模块移动到任意模块上，但是这种方法只能进行最多 $M$ 次。Jones 假设进行一次需要花费固定的时间 $K$。", "inputFormat": "第一行包含一个整数 $T$，代表测试组数。\n\n每个测试组中，第一行包含三个整数 $N, M, K \\ (1 \\leq N, M \\leq 1000)$，接下来 $N-1$ 行每一行包含三个整数 $A, B, C \\ (1 \\leq A \\leq B \\leq N; 0 \\leq C,K \\leq 10^6)$，代表在模块 $A$ 和 $B$ 之间有一条通道，检查它需要花费 $C$ 时间。", "outputFormat": "对于每一组测试数据，输出一行答案。", "hint": "", "locale": "zh-CN"}}}
{"pid": "P5867", "type": "P", "difficulty": 4, "samples": [["8 4 4\n7 2\n3 3\n4 5\n5 1\n2 2\n1 4\n8 4\n9 4\n6 1 4 9", "2\n2\n3\n2"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "二分", "前缀和", "ICPC", "SEERC"], "title": "[SEERC 2018] Fishermen", "background": "", "description": "大海可以看成平面直角坐标系下的第一象限。海里有 $n$ 条鱼，每个鱼有一个二维坐标。一个点上可能有多条鱼。\n\n海边有 $m$ 个渔夫，每个渔夫有一个 $x$ 坐标，而他们的 $y$ 坐标都是 $0$。\n\n每个渔夫都有一根长为 $l$ 的钓竿，因此，他能钓到与他距离不超过 $l$ 的鱼。一个 $x$ 坐标为 $x$ 的渔夫和一条坐标为 $(a,b)$ 的鱼之间的距离为 $|a-x|+b$。\n\n分别计算出对于每个渔夫，他可以钓到多少条鱼。", "inputFormat": "第一行包含三个整数 $n, m$ 和 $l \\ (1 \\leq n,m \\leq 2 \\cdot 10^5, 1 \\leq l \\leq 10^9)$，代表鱼的数量、渔夫的数量和钓鱼竿的长度。\n\n接下来 $n$ 行每行包含两个整数 $x_i$ 和 $y_i \\ (1 \\leq x_i, y_i \\leq 10^9)$，代表每条鱼的坐标。\n\n接下来一行包含 $m$ 个整数 $a_i \\ (1 \\leq a_i \\leq 10^9)$，代表每个渔夫的 $x$ 坐标。", "outputFormat": "对于每个渔夫，输出一行答案。", "hint": "图片展示了上面的样例中第三个渔夫可以钓到鱼的区域。\n\n![样例图](https://cdn.luogu.com.cn/upload/image_hosting/cbfqtjw7.png)\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Fishermen", "background": "", "description": "The sea can be considered as the first quadrant of the Cartesian coordinate system. There are $n$ fish in the sea, and each fish has a two-dimensional coordinate. There may be multiple fish at the same point.\n\nThere are $m$ fishermen on the shore. Each fisherman has an $x$ coordinate, and their $y$ coordinate is always $0$.\n\nEach fisherman has a fishing rod of length $l$, so he can catch fish whose distance to him is at most $l$. The distance between a fisherman with $x$ coordinate $x$ and a fish at coordinate $(a,b)$ is $|a-x|+b$.\n\nFor each fisherman, compute how many fish he can catch.", "inputFormat": "The first line contains three integers $n, m$ and $l \\ (1 \\leq n,m \\leq 2 \\cdot 10^5, 1 \\leq l \\leq 10^9)$, representing the number of fish, the number of fishermen, and the length of the fishing rod.\n\nThe next $n$ lines each contain two integers $x_i$ and $y_i \\ (1 \\leq x_i, y_i \\leq 10^9)$, representing the coordinates of each fish.\n\nThe next line contains $m$ integers $a_i \\ (1 \\leq a_i \\leq 10^9)$, representing the $x$ coordinate of each fisherman.", "outputFormat": "For each fisherman, output one line with the answer.", "hint": "The picture shows the region where the third fisherman in the sample above can catch fish.\n\n![sample image](https://cdn.luogu.com.cn/upload/image_hosting/cbfqtjw7.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Fishermen", "background": "", "description": "大海可以看成平面直角坐标系下的第一象限。海里有 $n$ 条鱼，每个鱼有一个二维坐标。一个点上可能有多条鱼。\n\n海边有 $m$ 个渔夫，每个渔夫有一个 $x$ 坐标，而他们的 $y$ 坐标都是 $0$。\n\n每个渔夫都有一根长为 $l$ 的钓竿，因此，他能钓到与他距离不超过 $l$ 的鱼。一个 $x$ 坐标为 $x$ 的渔夫和一条坐标为 $(a,b)$ 的鱼之间的距离为 $|a-x|+b$。\n\n分别计算出对于每个渔夫，他可以钓到多少条鱼。", "inputFormat": "第一行包含三个整数 $n, m$ 和 $l \\ (1 \\leq n,m \\leq 2 \\cdot 10^5, 1 \\leq l \\leq 10^9)$，代表鱼的数量、渔夫的数量和钓鱼竿的长度。\n\n接下来 $n$ 行每行包含两个整数 $x_i$ 和 $y_i \\ (1 \\leq x_i, y_i \\leq 10^9)$，代表每条鱼的坐标。\n\n接下来一行包含 $m$ 个整数 $a_i \\ (1 \\leq a_i \\leq 10^9)$，代表每个渔夫的 $x$ 坐标。", "outputFormat": "对于每个渔夫，输出一行答案。", "hint": "图片展示了上面的样例中第三个渔夫可以钓到鱼的区域。\n\n![样例图](https://cdn.luogu.com.cn/upload/image_hosting/cbfqtjw7.png)\n\n", "locale": "zh-CN"}}}
{"pid": "P5868", "type": "P", "difficulty": 6, "samples": [["5\n1 5 5 3 4\n1 1 4 4 4", "3\nm 1 2\nM 4 5\nm 3 5"], ["5\n1 2 3 4 4\n2 2 2 2 5", "-1"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "Special Judge", "ICPC", "SEERC"], "title": "[SEERC 2018] Min Max Convert", "background": "", "description": "$A$ 是一个有 $N$ 个元素的数列。你可以对这个数列进行以下两种操作：\n\n1. 选出一个下标的区间 $[a, b] \\ (1 \\leq a \\leq b \\leq N)$，设数列中在这个下标区间中的元素的最大值为 $x$，将这个下标区间中的所有元素替换为 $x$。\n2. 选出一个下标的区间 $[a, b] \\ (1 \\leq a \\leq b \\leq N)$，设数列中在这个下标区间中的元素的最小值为 $x$，将这个下标区间中的所有元素替换为 $x$。\n\n计算出一组操作方案，使数列 $A$ 变为另一个给定的数列 $B$（也有 $N$ 个元素）。方案中操作的数列必须小于等于 $2N$。", "inputFormat": "第一行包含一个整数 $N$。\n\n第二行包含一个有 $N$ 个元素的数列 $A$。\n\n第三行包含另一个有 $N$ 个元素的数列 $B$。", "outputFormat": "如果无解，输出 $-1$。否则在第一行输出一个整数 $x$，代表将数列 $A$ 变为 $B$ 所需的最小操作数量。接下来 $x$ 行每行包含一个字符（代表操作的类型，`m ` 代表使用了最小值的操作，`M` 代表使用了最大值的操作）和一个区间 $(a,b)$，描述了所需的每次操作信息。如果有多解，任意输出一组即可。", "hint": "- $1 \\leq N \\leq 100, 000$\n- 数列 $A$ 和 $B$ 中的元素都是区间 $[1, N]$ 中的整数", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Min Max Convert", "background": "", "description": "$A$ is an array with $N$ elements. You can perform the following two operations on this array:\n\n1. Choose an index interval $[a, b] \\ (1 \\leq a \\leq b \\leq N)$. Let the maximum value among the elements in this interval be $x$, and replace all elements in this interval with $x$.\n2. Choose an index interval $[a, b] \\ (1 \\leq a \\leq b \\leq N)$. Let the minimum value among the elements in this interval be $x$, and replace all elements in this interval with $x$.\n\nCompute a sequence of operations that transforms array $A$ into another given array $B$ (also with $N$ elements). The number of operations in the sequence must be less than or equal to $2N$.", "inputFormat": "The first line contains an integer $N$.\n\nThe second line contains an array $A$ with $N$ elements.\n\nThe third line contains another array $B$ with $N$ elements.", "outputFormat": "If there is no solution, output $-1$. Otherwise, output an integer $x$ in the first line, representing the minimum number of operations needed to transform array $A$ into $B$. In the next $x$ lines, each line contains one character (representing the type of operation, `m ` means the minimum-value operation is used, and `M` means the maximum-value operation is used) and an interval $(a,b)$, describing each operation. If there are multiple solutions, output any one of them.", "hint": "- $1 \\leq N \\leq 100, 000$.\n- All elements in arrays $A$ and $B$ are integers in the interval $[1, N]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Min Max Convert", "background": "", "description": "$A$ 是一个有 $N$ 个元素的数列。你可以对这个数列进行以下两种操作：\n\n1. 选出一个下标的区间 $[a, b] \\ (1 \\leq a \\leq b \\leq N)$，设数列中在这个下标区间中的元素的最大值为 $x$，将这个下标区间中的所有元素替换为 $x$。\n2. 选出一个下标的区间 $[a, b] \\ (1 \\leq a \\leq b \\leq N)$，设数列中在这个下标区间中的元素的最小值为 $x$，将这个下标区间中的所有元素替换为 $x$。\n\n计算出一组操作方案，使数列 $A$ 变为另一个给定的数列 $B$（也有 $N$ 个元素）。方案中操作的数列必须小于等于 $2N$。", "inputFormat": "第一行包含一个整数 $N$。\n\n第二行包含一个有 $N$ 个元素的数列 $A$。\n\n第三行包含另一个有 $N$ 个元素的数列 $B$。", "outputFormat": "如果无解，输出 $-1$。否则在第一行输出一个整数 $x$，代表将数列 $A$ 变为 $B$ 所需的最小操作数量。接下来 $x$ 行每行包含一个字符（代表操作的类型，`m ` 代表使用了最小值的操作，`M` 代表使用了最大值的操作）和一个区间 $(a,b)$，描述了所需的每次操作信息。如果有多解，任意输出一组即可。", "hint": "- $1 \\leq N \\leq 100, 000$\n- 数列 $A$ 和 $B$ 中的元素都是区间 $[1, N]$ 中的整数", "locale": "zh-CN"}}}
{"pid": "P5869", "type": "P", "difficulty": 5, "samples": [["2 7\n1 3\n0 2\n1 1\n1 4\n0 4\n0 3\n1 1", "13\n17\n21\n17\n21\n17\n13"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "线段树", "ICPC", "SEERC"], "title": "[SEERC 2018] Matrix Queries", "background": "", "description": "给定一个 $2^n \\times 2^n$ 的矩阵，最开始每个格子都是白色的。格子的颜色可以是白色或黑色。定义一个矩阵的*价值*为：\n\n1. 如果矩阵是单色的，则它的价值为 $1$ 金币；\n2. 否则，将矩阵分割成 $4$ 个大小相等的子矩阵，矩阵的价值为子矩阵的价值之和加 $1$ 金币。\n\n给定 $q$ 个询问，每个询问给定一个行/列的编号 $x$，你需要改变这一行/列中每个格子的颜色（黑色变为白色，白色变为黑色），然后计算出改变之后的新矩阵的*价值*。", "inputFormat": "第一行包含两个整数 $n$ 和 $q \\ (0 \\leq n \\leq 20, 1 \\leq q \\leq 10^6)$，代表矩阵的大小为 $2^n \\times 2^n$ 以及有 $q$ 个询问。\n\n接下来 $q$ 行每行包含两个整数 $t$ 和 $x \\ (0 \\leq t \\leq 1, 1 \\leq x \\leq 2^n)$。如果 $t=0$，则改变第 $x$ 行的颜色；否则，改变第 $x$ 列的颜色。", "outputFormat": "对于每个询问，输出一行答案。", "hint": "样例中，每个询问后的矩阵如下图所示：\n\n![样例图](https://cdn.luogu.com.cn/upload/image_hosting/1cyezquq.png)", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Matrix Queries", "background": "", "description": "Given a $2^n \\times 2^n$ matrix, initially every cell is white. Each cell can be either white or black. Define the *value* of a matrix as follows:\n\n1. If the matrix is monochromatic, then its value is $1$ coin.\n2. Otherwise, split the matrix into $4$ equal-sized submatrices. The value of the matrix is the sum of the values of the submatrices plus $1$ coin.\n\nYou are given $q$ queries. Each query provides a row/column index $x$. You need to flip the color of every cell in that row/column (black becomes white, white becomes black), and then compute the *value* of the new matrix after the change.", "inputFormat": "The first line contains two integers $n$ and $q \\ (0 \\leq n \\leq 20, 1 \\leq q \\leq 10^6)$, meaning the matrix size is $2^n \\times 2^n$ and there are $q$ queries.\n\nThe next $q$ lines each contain two integers $t$ and $x \\ (0 \\leq t \\leq 1, 1 \\leq x \\leq 2^n)$. If $t=0$, flip the colors of row $x$; otherwise, flip the colors of column $x$.", "outputFormat": "For each query, output one line with the answer.", "hint": "In the sample, the matrix after each query is shown in the figure below:\n\n![Sample Figure](https://cdn.luogu.com.cn/upload/image_hosting/1cyezquq.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Matrix Queries", "background": "", "description": "给定一个 $2^n \\times 2^n$ 的矩阵，最开始每个格子都是白色的。格子的颜色可以是白色或黑色。定义一个矩阵的*价值*为：\n\n1. 如果矩阵是单色的，则它的价值为 $1$ 金币；\n2. 否则，将矩阵分割成 $4$ 个大小相等的子矩阵，矩阵的价值为子矩阵的价值之和加 $1$ 金币。\n\n给定 $q$ 个询问，每个询问给定一个行/列的编号 $x$，你需要改变这一行/列中每个格子的颜色（黑色变为白色，白色变为黑色），然后计算出改变之后的新矩阵的*价值*。", "inputFormat": "第一行包含两个整数 $n$ 和 $q \\ (0 \\leq n \\leq 20, 1 \\leq q \\leq 10^6)$，代表矩阵的大小为 $2^n \\times 2^n$ 以及有 $q$ 个询问。\n\n接下来 $q$ 行每行包含两个整数 $t$ 和 $x \\ (0 \\leq t \\leq 1, 1 \\leq x \\leq 2^n)$。如果 $t=0$，则改变第 $x$ 行的颜色；否则，改变第 $x$ 列的颜色。", "outputFormat": "对于每个询问，输出一行答案。", "hint": "样例中，每个询问后的矩阵如下图所示：\n\n![样例图](https://cdn.luogu.com.cn/upload/image_hosting/1cyezquq.png)", "locale": "zh-CN"}}}
{"pid": "P5870", "type": "P", "difficulty": 4, "samples": [["2\n3 3\n1 2\n2 3\n3 1\n4 4\n1 2\n2 3\n3 4\n1 4", "1\n2\n2\n1 4"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "Special Judge", "随机化", "ICPC", "SEERC"], "title": "[SEERC 2018] Modern Djinn", "background": "", "description": "你不是一个 leader，你是一个 president。幸运的是，你有一只精灵，能够实现你的愿望。你的其中一个愿望就是假装你的社会中有 democracy。\n\n社会很简单。社会里有 $N$ 个人，编号从 $1$ 到 $N$，一些人“开心”而另一些很平常（“不开心”）。人类这种生物非常奇妙，人们只在别人不开心时才感到开心。人们共有 $M$ 个愿望，编号从 $1$ 到 $M$，$X \\rightarrow Y$代表 $X$ 想要 $Y$ 不开心。一个人 $X$ 是开心的当且仅当他的至少一个愿望得到满足。\n\nDemocracy 也没那么复杂。有些人说为了实现 democracy，你需要至少一半的人是开心的（或一半的愿望得到满足），但这不全是事实。我刚才说过，你是一个好的 president，而不是一个好的 leader。你可以通过媒体来定义 democracy。因此，在所有的 $M$ 个愿望中，你决定实现至少 $\\lfloor M/4 \\rfloor +1$ 个愿望。\n\n剩下的事情就是选出你想实现的愿望，然后精灵会处理好一切。", "inputFormat": "输入包含多组测试数据。第一行包含一个整数 $T$，代表测试数据的组数。接下来的输入中会按顺序给出每组测试数据。\n\n在每组测试数据中，第一行包含两个正整数 $N$ 和 $M$，代表社会中人的数量和愿望的数量。接下来 $M$ 行每行包含两个整数 $X, Y$，描述了一个愿望：$X$ 希望 $Y$ 不开心。", "outputFormat": "对于每组测试数据，第一行输出一个整数 $K$，代表实现的愿望的数量，第二行输出 $K$ 个整数，代表实现的愿望编号，输出的顺序不做限制。", "hint": "**【数据范围与限制】**\n\n- $1 \\leq T \\leq 10, 000$\n- $2 \\leq N \\leq 100,000$\n- $1 \\leq M \\leq 200,000$\n- 不存在 $X$ 希望 $X$ 不开心这样的愿望。\n- 可能存在多个相同的 $X$ 希望 $Y$ 不开心的愿望。\n- 每组数据保证解一定存在。\n- 输出任何正确的解都可以。\n\n**【样例解释】**\n\n第一组测试数据中，我们可以实现最多 $1$ 个愿望，输出任意一个愿望都是可行的。\n\n第二组测试数据中，另外一个可行的解是实现愿望 $1, 3$ 和 $4$，最少需要实现 $2$ 个愿望。\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Modern Djinn", "background": "", "description": "You are not a leader; you are a president. Luckily, you have a djinn that can grant your wishes. One of your wishes is to pretend that your society has democracy.\n\nThe society is simple. There are $N$ people in the society, numbered from $1$ to $N$. Some people are “happy”, while others are ordinary (“unhappy”). Humans are very strange: people feel happy only when others are unhappy. There are $M$ wishes in total, numbered from $1$ to $M$. $X \\rightarrow Y$ means that $X$ wants $Y$ to be unhappy. A person $X$ is happy if and only if at least one of their wishes is fulfilled.\n\nDemocracy is not that complicated either. Some say that to achieve democracy, you need at least half of the people to be happy (or half of the wishes to be fulfilled), but that is not entirely true. As I said, you are a good president, not a good leader. You can define democracy through the media. Therefore, among all $M$ wishes, you decide to fulfill at least $\\lfloor M/4 \\rfloor + 1$ wishes.\n\nThe remaining task is to choose which wishes you want to fulfill, and then the djinn will take care of everything.", "inputFormat": "The input contains multiple test cases. The first line contains an integer $T$, the number of test cases. The following lines give the test cases in order.\n\nFor each test case, the first line contains two positive integers $N$ and $M$, representing the number of people in the society and the number of wishes. The next $M$ lines each contain two integers $X, Y$, describing a wish: $X$ wants $Y$ to be unhappy.", "outputFormat": "For each test case, output an integer $K$ on the first line, the number of wishes to be fulfilled. Output $K$ integers on the second line, the indices of the fulfilled wishes. The order does not matter.", "hint": "**Constraints**\n\n- $1 \\leq T \\leq 10,000$\n- $2 \\leq N \\leq 100,000$\n- $1 \\leq M \\leq 200,000$\n- There is no wish where $X$ wants $X$ to be unhappy.\n- There may be multiple identical wishes where $X$ wants $Y$ to be unhappy.\n- For each test case, a solution is guaranteed to exist.\n- Any correct solution is accepted.\n\n**Sample Explanation**\n\nIn the first test case, we can fulfill at most $1$ wish; outputting any wish is valid.\n\nIn the second test case, another valid solution is to fulfill wishes $1$, $3$, and $4$. At least $2$ wishes must be fulfilled.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Modern Djinn", "background": "", "description": "你不是一个 leader，你是一个 president。幸运的是，你有一只精灵，能够实现你的愿望。你的其中一个愿望就是假装你的社会中有 democracy。\n\n社会很简单。社会里有 $N$ 个人，编号从 $1$ 到 $N$，一些人“开心”而另一些很平常（“不开心”）。人类这种生物非常奇妙，人们只在别人不开心时才感到开心。人们共有 $M$ 个愿望，编号从 $1$ 到 $M$，$X \\rightarrow Y$代表 $X$ 想要 $Y$ 不开心。一个人 $X$ 是开心的当且仅当他的至少一个愿望得到满足。\n\nDemocracy 也没那么复杂。有些人说为了实现 democracy，你需要至少一半的人是开心的（或一半的愿望得到满足），但这不全是事实。我刚才说过，你是一个好的 president，而不是一个好的 leader。你可以通过媒体来定义 democracy。因此，在所有的 $M$ 个愿望中，你决定实现至少 $\\lfloor M/4 \\rfloor +1$ 个愿望。\n\n剩下的事情就是选出你想实现的愿望，然后精灵会处理好一切。", "inputFormat": "输入包含多组测试数据。第一行包含一个整数 $T$，代表测试数据的组数。接下来的输入中会按顺序给出每组测试数据。\n\n在每组测试数据中，第一行包含两个正整数 $N$ 和 $M$，代表社会中人的数量和愿望的数量。接下来 $M$ 行每行包含两个整数 $X, Y$，描述了一个愿望：$X$ 希望 $Y$ 不开心。", "outputFormat": "对于每组测试数据，第一行输出一个整数 $K$，代表实现的愿望的数量，第二行输出 $K$ 个整数，代表实现的愿望编号，输出的顺序不做限制。", "hint": "**【数据范围与限制】**\n\n- $1 \\leq T \\leq 10, 000$\n- $2 \\leq N \\leq 100,000$\n- $1 \\leq M \\leq 200,000$\n- 不存在 $X$ 希望 $X$ 不开心这样的愿望。\n- 可能存在多个相同的 $X$ 希望 $Y$ 不开心的愿望。\n- 每组数据保证解一定存在。\n- 输出任何正确的解都可以。\n\n**【样例解释】**\n\n第一组测试数据中，我们可以实现最多 $1$ 个愿望，输出任意一个愿望都是可行的。\n\n第二组测试数据中，另外一个可行的解是实现愿望 $1, 3$ 和 $4$，最少需要实现 $2$ 个愿望。\n\n", "locale": "zh-CN"}}}
{"pid": "P5871", "type": "P", "difficulty": 4, "samples": [["4 2\n2 3\n2 4", "2"], ["5 7\n2 5\n1 5\n3 5\n2 3\n4 1\n4 3\n4 2", "3"], ["7 7\n5 6\n2 3\n6 7\n2 7\n3 1\n7 5\n7 4", "6"], ["5 6\n1 3\n4 5\n1 4\n2 3\n1 2\n1 5", "5"]], "limits": {"time": [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2018", "ICPC", "SEERC"], "title": "[SEERC 2018] Inversion", "background": "", "description": "定义一个长为 $n$ 的*排列*为一个序列 $p_1, p_2, \\dots, p_n$，其中 $[1, n]$ 范围内的整数都恰好在这个序列中出现一次。定义排列中的一个*逆序对*为一对整数 $(i, j)$，其中 $i, j \\in [1,n]$，且满足 $i<j, p_i>p_j$。\n\n定义一个*逆序对图*为一个有 $n$ 个点的图，图中存在一条 $(i, j)$ 的边当且仅当 $(i,j)$ 是一个逆序对。\n\n定义一个图中的*独立集*为一个图中点的集合，满足集合中的点两两之间没有边相连。定义一个图中的*支配集*为一个图中点的集合，满足不在这个集合中的点都与集合中的某个点有边相连。定义一个图中的*独立支配集*为一个图中点的集合，这个集合既是独立集又是支配集。\n\n给定某一个长为 $n$ 的排列的逆序对图，请计算出这个图中独立支配集的数量。\n\n数据保证答案不会超过 $10^{18}$。", "inputFormat": "第一行包含两个整数 $n$ 和 $m \\ (1 \\leq n \\leq 100, 0 \\leq m \\leq \\frac{n \\times (n-1)}{2})$，代表图中的点数和边数。\n\n接下来 $m$ 行每行包含两个整数 $u_i$ 和 $v_i \\ (1 \\leq u_i, v_i \\leq n)$，代表图中点 $u_i$ 和 $v_i$ 之间有一条边相连。\n\n数据保证图一定对应某一个排列。", "outputFormat": "输出图中独立支配集的数量。\n\n数据保证答案不会超过 $10^{18}$。", "hint": "第一个样例中，图对应排列 $[1,4,2,3]$，独立支配集有 $(1,3,4)$ 和 $(1,2)$。\n\n第二个样例中，图对应排列 $[3,5,4,1,2]$，独立支配集有 $(1,2),(1,3),(4,5)$。\n\n第三个样例中，图对应排列 $[2,4,1,5,7,6,3]$。\n\n第四个样例中，图对应排列 $[5,2,1,4,3]$。", "locale": "zh-CN", "translations": {"en": {"title": "[SEERC 2018] Inversion", "background": "", "description": "A *permutation* of length $n$ is defined as a sequence $p_1, p_2, \\dots, p_n$, where every integer in the range $[1, n]$ appears in this sequence exactly once. An *inversion pair* in a permutation is defined as a pair of integers $(i, j)$, where $i, j \\in [1,n]$, and it satisfies $i<j, p_i>p_j$.\n\nAn *inversion graph* is defined as a graph with $n$ vertices, where an edge $(i, j)$ exists if and only if $(i,j)$ is an inversion pair.\n\nAn *independent set* in a graph is a set of vertices such that no two vertices in the set are connected by an edge. A *dominating set* in a graph is a set of vertices such that every vertex not in the set is adjacent to some vertex in the set. An *independent dominating set* in a graph is a set of vertices that is both an independent set and a dominating set.\n\nGiven the inversion graph of a permutation of length $n$, compute the number of independent dominating sets in this graph.\n\nIt is guaranteed that the answer will not exceed $10^{18}$.", "inputFormat": "The first line contains two integers $n$ and $m \\ (1 \\leq n \\leq 100, 0 \\leq m \\leq \\frac{n \\times (n-1)}{2})$, representing the number of vertices and the number of edges in the graph.\n\nThe next $m$ lines each contain two integers $u_i$ and $v_i \\ (1 \\leq u_i, v_i \\leq n)$, indicating that there is an edge between vertices $u_i$ and $v_i$.\n\nIt is guaranteed that the graph corresponds to some permutation.", "outputFormat": "Output the number of independent dominating sets in the graph.\n\nIt is guaranteed that the answer will not exceed $10^{18}$.", "hint": "In the first sample, the graph corresponds to the permutation $[1,4,2,3]$, and the independent dominating sets are $(1,3,4)$ and $(1,2)$.\n\nIn the second sample, the graph corresponds to the permutation $[3,5,4,1,2]$, and the independent dominating sets are $(1,2)$, $(1,3)$, and $(4,5)$.\n\nIn the third sample, the graph corresponds to the permutation $[2,4,1,5,7,6,3]$.\n\nIn the fourth sample, the graph corresponds to the permutation $[5,2,1,4,3]$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SEERC 2018] Inversion", "background": "", "description": "定义一个长为 $n$ 的*排列*为一个序列 $p_1, p_2, \\dots, p_n$，其中 $[1, n]$ 范围内的整数都恰好在这个序列中出现一次。定义排列中的一个*逆序对*为一对整数 $(i, j)$，其中 $i, j \\in [1,n]$，且满足 $i<j, p_i>p_j$。\n\n定义一个*逆序对图*为一个有 $n$ 个点的图，图中存在一条 $(i, j)$ 的边当且仅当 $(i,j)$ 是一个逆序对。\n\n定义一个图中的*独立集*为一个图中点的集合，满足集合中的点两两之间没有边相连。定义一个图中的*支配集*为一个图中点的集合，满足不在这个集合中的点都与集合中的某个点有边相连。定义一个图中的*独立支配集*为一个图中点的集合，这个集合既是独立集又是支配集。\n\n给定某一个长为 $n$ 的排列的逆序对图，请计算出这个图中独立支配集的数量。\n\n数据保证答案不会超过 $10^{18}$。", "inputFormat": "第一行包含两个整数 $n$ 和 $m \\ (1 \\leq n \\leq 100, 0 \\leq m \\leq \\frac{n \\times (n-1)}{2})$，代表图中的点数和边数。\n\n接下来 $m$ 行每行包含两个整数 $u_i$ 和 $v_i \\ (1 \\leq u_i, v_i \\leq n)$，代表图中点 $u_i$ 和 $v_i$ 之间有一条边相连。\n\n数据保证图一定对应某一个排列。", "outputFormat": "输出图中独立支配集的数量。\n\n数据保证答案不会超过 $10^{18}$。", "hint": "第一个样例中，图对应排列 $[1,4,2,3]$，独立支配集有 $(1,3,4)$ 和 $(1,2)$。\n\n第二个样例中，图对应排列 $[3,5,4,1,2]$，独立支配集有 $(1,2),(1,3),(4,5)$。\n\n第三个样例中，图对应排列 $[2,4,1,5,7,6,3]$。\n\n第四个样例中，图对应排列 $[5,2,1,4,3]$。", "locale": "zh-CN"}}}
