{"pid": "P4138", "type": "P", "difficulty": 4, "samples": [["5\n0 4\n2 -2\n1 -1\n0 1\n0 3", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["动态规划 DP", "贪心", "2014", "剪枝", "背包 DP", "JOISC/JOIST（日本）"], "title": "[JOISC 2014] 挂饰 / Straps", "background": null, "description": "JOI 君有 $N$ 个装在手机上的挂饰，编号为 $1,2,\\cdots,N$。JOI 君可以将其中的一些装在手机上。\n\nJOI 君的挂饰有一些与众不同——其中的一些挂饰附有可以挂其他挂件的挂钩。每个挂件要么直接挂在手机上，要么挂在其他挂件的挂钩上。直接挂在手机上的挂件最多有 $1$ 个。\n\n此外，每个挂件有一个安装时会获得的喜悦值，用一个整数来表示。如果 JOI 君很讨厌某个挂饰，那么这个挂饰的喜悦值就是一个负数。\n\nJOI 君想要最大化所有挂饰的喜悦值之和。注意不必要将所有的挂钩都挂上挂饰，而且一个都不挂也是可以的。", "inputFormat": "第一行一个整数 $N$，代表挂饰的个数。\n\n接下来 $N$ 行，第 $i$ 行 $(1\\le i\\le N)$ 有两个空格分隔的整数 $A_i$ 和 $B_i$，表示挂饰 $i$ 有 $A_i$ 个挂钩，安装后会获得 $B_i$ 的喜悦值。", "outputFormat": "输出一行一个整数，表示手机上连接的挂饰总和的最大值。", "hint": "$1\\leq N\\leq 2000$。\n\n$0\\leq A_i\\leq N(1\\leq i\\leq N)$。\n\n$-10^6\\leq B_i\\leq 10^6(1\\leq i\\leq N)$。", "locale": "zh-CN", "translations": {"en": {"title": "[JOISC 2014] Straps", "background": "", "description": "JOI-kun has $N$ ornaments, numbered $1, 2, \\cdots, N$. He can attach some of them to his phone.\nSome ornaments are special—they have hooks that can hold other ornaments. Each ornament is either attached directly to the phone or to a hook of another ornament. At most one ornament can be attached directly to the phone.\nEach ornament has an integer joy value gained when it is installed. If JOI-kun dislikes an ornament, its joy value is negative.\nJOI-kun wants to maximize the sum of the joy values of all ornaments connected to the phone. It is not necessary to use all hooks, and attaching none is also allowed.", "inputFormat": "The first line contains an integer $N$, the number of ornaments.\nThe next $N$ lines, the $i$-th line ($1 \\le i \\le N$), contain two space-separated integers $A_i$ and $B_i$, meaning ornament $i$ has $A_i$ hooks and yields joy $B_i$ when installed.", "outputFormat": "Output a single integer, the maximum total joy value of the ornaments connected to the phone.", "hint": "- $1 \\leq N \\leq 2000$.\n- $0 \\leq A_i \\leq N$ ($1 \\leq i \\leq N$).\n- $-10^6 \\leq B_i \\leq 10^6$ ($1 \\leq i \\leq N$).\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[JOISC 2014] 挂饰 / Straps", "background": null, "description": "JOI 君有 $N$ 个装在手机上的挂饰，编号为 $1,2,\\cdots,N$。JOI 君可以将其中的一些装在手机上。\n\nJOI 君的挂饰有一些与众不同——其中的一些挂饰附有可以挂其他挂件的挂钩。每个挂件要么直接挂在手机上，要么挂在其他挂件的挂钩上。直接挂在手机上的挂件最多有 $1$ 个。\n\n此外，每个挂件有一个安装时会获得的喜悦值，用一个整数来表示。如果 JOI 君很讨厌某个挂饰，那么这个挂饰的喜悦值就是一个负数。\n\nJOI 君想要最大化所有挂饰的喜悦值之和。注意不必要将所有的挂钩都挂上挂饰，而且一个都不挂也是可以的。", "inputFormat": "第一行一个整数 $N$，代表挂饰的个数。\n\n接下来 $N$ 行，第 $i$ 行 $(1\\le i\\le N)$ 有两个空格分隔的整数 $A_i$ 和 $B_i$，表示挂饰 $i$ 有 $A_i$ 个挂钩，安装后会获得 $B_i$ 的喜悦值。", "outputFormat": "输出一行一个整数，表示手机上连接的挂饰总和的最大值。", "hint": "$1\\leq N\\leq 2000$。\n\n$0\\leq A_i\\leq N(1\\leq i\\leq N)$。\n\n$-10^6\\leq B_i\\leq 10^6(1\\leq i\\leq N)$。", "locale": "zh-CN"}}}
{"pid": "P4139", "type": "P", "difficulty": 5, "samples": [["3\n2\n3\n6", "0\n1\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "递归", "数论", "欧拉函数"], "title": "上帝与集合的正确用法", "background": null, "description": "根据一些书上的记载，上帝的一次失败的创世经历是这样的：\n\n第一天，上帝创造了一个世界的基本元素，称做元。\n\n第二天，上帝创造了一个新的元素，称作 $\\alpha$ 。 $\\alpha$ 被定义为元构成的集合。容易发现，一共有两种不同的 $\\alpha$ 。\n\n第三天，上帝又创造了一个新的元素，称作 $\\beta$ 。 $\\beta$ 被定义为 $\\alpha$ 构成的集合。容易发现，一共有四种不同的 $\\beta$。\n\n第四天，上帝创造了新的元素 $\\gamma$，$\\gamma$ 被定义为 $\\beta$ 的集合。显然，一共会有 $16$ 种不同的 $\\gamma$。\n\n如果按照这样下去，上帝创造的第五种元素将会有 $65536$ 种，第六种元素将会有 $2^{65536}$种。这将会是一个天文数字。\n\n然而，上帝并没有预料到元素种类数的增长是如此的迅速。他想要让世界的元素丰富起来，因此，日复一日，年复一年，他重复地创造着新的元素……\n\n然而不久，当上帝创造出最后一种元素 $\\theta$ 时，他发现这世界的元素实在是太多了，以致于世界的容量不足，无法承受。因此在这一天，上帝毁灭了世界。\n\n至今，上帝仍记得那次失败的创世经历，现在他想问问你，他最后一次创造的元素 $\\theta$ 一共有多少种？\n\n上帝觉得这个数字可能过于巨大而无法表示出来，因此你只需要回答这个数对 $p$ 取模后的值即可。\n\n你可以认为上帝从 $\\alpha$ 到 $\\theta$ 一共创造了 $10^9$ 次元素，或 $10^{18}$ 次，或者干脆 $\\infty$ 次。\n\n一句话题意：\n\n定义 $a_0=1,a_n=2^{a_{n-1}}$，可以证明 $b_n=a_n\\bmod p$ 在某一项后都是同一个值，求这个值。", "inputFormat": "第一行一个整数 $T$，表示数据个数。\n\n接下来 $T$ 行，每行一个正整数 $p$，代表你需要取模的值。", "outputFormat": "$T$ 行，每行一个正整数，为答案对 $p$ 取模后的值。", "hint": "对于 $100\\%$ 的数据，$T\\le 10^3$，$p\\le10^7$。", "locale": "zh-CN", "translations": {"en": {"title": "God and the Correct Use of Sets", "background": "", "description": "According to some books, one of God’s failed attempts at creation went like this:\n\nOn the first day, God created a basic element of the world, called \"yuan\" (pinyin).\n\nOn the second day, God created a new element, called $\\alpha$. $\\alpha$ is defined as a set composed of \"yuan\". It is easy to see that there are exactly two distinct $\\alpha$.\n\nOn the third day, God created another new element, called $\\beta$. $\\beta$ is defined as a set composed of $\\alpha$. It is easy to see that there are four distinct $\\beta$.\n\nOn the fourth day, God created a new element, $\\gamma$. $\\gamma$ is defined as a set of $\\beta$. Clearly, there are $16$ distinct $\\gamma$.\n\nIf this continues, the fifth kind of element will have $65536$ types, and the sixth kind will have $2^{65536}$ types. This will be an astronomical number.\n\nHowever, God did not anticipate how fast the number of element types would grow. He wanted to enrich the world’s elements, so day after day, year after year, he kept creating new elements…\n\nNot long after, when God created the last kind of element $\\theta$, he found that there were so many elements that the world’s capacity was insufficient to bear them. So that day, God destroyed the world.\n\nTo this day, God still remembers that failed act of creation. Now he wants to ask you: how many distinct elements of type $\\theta$ are there?\n\nGod thinks this number may be too huge to represent, so you only need to report it modulo $p$.\n\nYou may assume that from $\\alpha$ to $\\theta$, God created elements for $10^9$ steps, or $10^{18}$ steps, or simply $\\infty$ steps.\n\nIn short:\n\nDefine $a_0=1,a_n=2^{a_{n-1}}$. It can be proved that $b_n=a_n\\bmod p$ becomes constant after some index; find that value.", "inputFormat": "The first line contains an integer $T$, the number of test cases.\n\nEach of the next $T$ lines contains one positive integer $p$, the modulus.", "outputFormat": "Output $T$ lines, each containing one positive integer, which is the answer modulo $p$.", "hint": "For $100\\%$ of the testdata, $T\\le 10^3$, $p\\le 10^7$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "上帝与集合的正确用法", "background": null, "description": "根据一些书上的记载，上帝的一次失败的创世经历是这样的：\n\n第一天，上帝创造了一个世界的基本元素，称做元。\n\n第二天，上帝创造了一个新的元素，称作 $\\alpha$ 。 $\\alpha$ 被定义为元构成的集合。容易发现，一共有两种不同的 $\\alpha$ 。\n\n第三天，上帝又创造了一个新的元素，称作 $\\beta$ 。 $\\beta$ 被定义为 $\\alpha$ 构成的集合。容易发现，一共有四种不同的 $\\beta$。\n\n第四天，上帝创造了新的元素 $\\gamma$，$\\gamma$ 被定义为 $\\beta$ 的集合。显然，一共会有 $16$ 种不同的 $\\gamma$。\n\n如果按照这样下去，上帝创造的第五种元素将会有 $65536$ 种，第六种元素将会有 $2^{65536}$种。这将会是一个天文数字。\n\n然而，上帝并没有预料到元素种类数的增长是如此的迅速。他想要让世界的元素丰富起来，因此，日复一日，年复一年，他重复地创造着新的元素……\n\n然而不久，当上帝创造出最后一种元素 $\\theta$ 时，他发现这世界的元素实在是太多了，以致于世界的容量不足，无法承受。因此在这一天，上帝毁灭了世界。\n\n至今，上帝仍记得那次失败的创世经历，现在他想问问你，他最后一次创造的元素 $\\theta$ 一共有多少种？\n\n上帝觉得这个数字可能过于巨大而无法表示出来，因此你只需要回答这个数对 $p$ 取模后的值即可。\n\n你可以认为上帝从 $\\alpha$ 到 $\\theta$ 一共创造了 $10^9$ 次元素，或 $10^{18}$ 次，或者干脆 $\\infty$ 次。\n\n一句话题意：\n\n定义 $a_0=1,a_n=2^{a_{n-1}}$，可以证明 $b_n=a_n\\bmod p$ 在某一项后都是同一个值，求这个值。", "inputFormat": "第一行一个整数 $T$，表示数据个数。\n\n接下来 $T$ 行，每行一个正整数 $p$，代表你需要取模的值。", "outputFormat": "$T$ 行，每行一个正整数，为答案对 $p$ 取模后的值。", "hint": "对于 $100\\%$ 的数据，$T\\le 10^3$，$p\\le10^7$。", "locale": "zh-CN"}}}
{"pid": "P4140", "type": "P", "difficulty": 5, "samples": [["6\n0 1 3\n1 1 5\n0 1 3\n1 1 7\n0 1 3\n0 2 3", "18\n24\n36\n6\n\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["数学", "2014", "线段树", "树状数组", "素数判断,质数,筛法", "逆元", "CTT（清华集训/北大集训）"], "title": "[清华集训 2014] 奇数国", "background": null, "description": "在一片美丽的大陆上有 $100\\,000$ 个国家，记为 $1$ 到 $100\\,000$。这里经济发达，有数不尽的账房，并且每个国家有一个银行。\n\n某大公司的领袖在这 $100\\,000$ 个银行开户时都存了 $3$ 大洋，他惜财如命，因此会不时地派小弟 GFS 清点一些银行的存款或者让 GFS 改变某个银行的存款。\n\n该村子在财产上的求和运算等同于我们的乘法运算，也就是说领袖开户时的存款总和为 $3^{100000}$。这里发行的软妹面额是最小的 $60$ 个素数（$p_1=2,p_2=3,\\ldots, p_{60}=281$），任何人的财产都只能由这 $60$ 个基本面额表示，即设某个人的财产为 $fortune$（正整数），则 $fortune=p_1^{k_1} \\times p_2^{k_2} \\times \\ldots p_{60}^{k_{60}}$。\n\n领袖习惯将一段编号连续的银行里的存款拿到一个账房去清点，为了避免 GFS 串通账房叛变，所以他不会每次都选择同一个账房。GFS 跟随领袖多年已经摸清了门路,知道领袖选择账房的方式。如果领袖选择清点编号在 $[a,b]$ 内的银行财产，他会先对 $[a,b]$ 的财产求和（记为 $product$），然后在编号属于 $[1,product]$ 的账房中选择一个去清点存款，检验自己计算是否正确同时也检验账房与 GFS 是否有勾结。GFS 发现如果某个账房的编号 $number$ 与 $product$ 相冲，领袖绝对不会选择这个账房。\n\n怎样才算与 $product$ 不相冲呢？若存在整数 $x,y$ 使得 $number \\times x+product \\times y=1$，那么我们称 $number$ 与 $product$ 不相冲，即该账房有可能被领袖相中。当领袖又赚大钱了的时候，他会在某个银行改变存款，这样一来相同区间的银行在不同的时候算出来的 $product$ 可能是不一样的，而且领袖不会在某个银行的存款总数超过 $10^6$。\n\n现在 GFS 预先知道了领袖的清点存款与变动存款的计划，想请你告诉他，每次清点存款时领袖有多少个账房可以供他选择，当然这个值可能非常大，GFS 只想知道对 $19\\,961\\,993$ 取模后的答案。", "inputFormat": "第一行一个整数 $x$ 表示领袖清点和变动存款的总次数。\n\n接下来 $x$ 行，每行 $3$ 个整数 $a_i,b_i,c_i$。$a_i$ 为 $0$ 时表示该条记录是清点计划，领袖会清点 $b_i$ 到 $c_i$ 的银行存款，你需要对该条记录计算出 GFS 想要的答案。$a_i$ 为 $1$ 时表示该条记录是存款变动，你要把银行 $b_i$ 的存款改为 $c_i$，不需要对该记录进行计算。", "outputFormat": "对于每个询问，输出一行一个整数表示答案。", "hint": "### 样例解释\n\n- 初始化每个国家存款都为 $3$；\n- $1$ 到 $3$ 的 $product$ 为 $27$，$[1,27]$ 与 $27$ 不相冲的有 $18$ 个数；\n- $1$ 的存款变为 $5$；\n- $1$ 到 $3$ 的 $product$ 为 $45$，$[1,45]$ 与 $45$ 不相冲的有 $24$ 个数；\n- $1$ 的存款变为 $7$；\n- $1$ 到 $3$ 的 $product$ 为 $63$，$[1,63]$ 与 $63$ 不相冲的有 $36$个数；\n- $2$ 到 $3$ 的 $product$ 为 $9$，$[1,9]$ 与 $9$ 不相冲的有 $6$ 个数。\n\n### 数据范围\n\n所有数据均满足：$x \\geq 1$，$c_i -b_i \\geq 0$。\n\n| 子任务编号 | 分值 |    $x \\leq$     | $c_i - b_i \\leq$ | 特殊性质 |\n| :--------: | :--: | :-------------: | :--------------: | :------: |\n|    $1$     | $20$ |     $10^4$      |      $100$       |    有    |\n|    $2$     | $30$ | $5 \\times 10^4$ |      $10^4$      |    无    |\n|    $3$     | $50$ |     $10^5$      |      $10^5$      |    无    |\n\n特殊性质指：所有 $product \\leq 10^{18}$。", "locale": "zh-CN", "translations": {"en": {"title": "[Tsinghua Training Camp 2014] Odd Country", "background": "", "description": "On a beautiful continent there are $100\\,000$ countries, numbered from $1$ to $100\\,000$. The economy is prosperous, there are countless accounting offices, and each country has one bank.\n\nWhen a big company's leader opened accounts in these $100\\,000$ banks, he deposited $3$ coins in each. He is very stingy, so he will from time to time send his lackey GFS to tally deposits in some banks or ask GFS to change the deposit of a certain bank.\n\nIn this land, the summation operation on wealth corresponds to our multiplication. That is, the total deposit when the leader opened accounts is $3^{100000}$. The banknote denominations issued here are the smallest $60$ primes ($p_1=2, p_2=3, \\ldots, p_{60}=281$). Anyone’s wealth can only be represented using these $60$ basic denominations. Suppose a person’s wealth is $fortune$ (a positive integer), then $fortune = p_1^{k_1} \\times p_2^{k_2} \\times \\ldots p_{60}^{k_{60}}$.\n\nThe leader tends to take deposits from a consecutive range of banks to one accounting office to tally. To avoid GFS colluding with an accounting office, he will not choose the same accounting office every time. After following the leader for many years, GFS has figured out the rule: if the leader chooses to tally the wealth of banks numbered in $[a,b]$, he will first “sum” (i.e., multiply) the wealth over $[a,b]$ (denoted as $product$), and then pick an accounting office whose number is in $[1, product]$ to tally the deposits, both to verify his own computation and to check whether the accounting office and GFS are colluding. GFS noticed that if an accounting office’s number $number$ is in conflict with $product$, the leader will never choose that office.\n\nWhat does it mean to be not in conflict with $product$? If there exist integers $x, y$ such that $number \\times x + product \\times y = 1$, then we say $number$ is not in conflict with $product$, i.e., that accounting office may be chosen by the leader. When the leader makes a lot more money, he will change the deposit in some bank; thus the $product$ computed for the same interval at different times may differ. Moreover, the leader will not let the deposit in any single bank exceed $10^6$.\n\nNow that GFS knows in advance the leader’s plan for tallying and changing deposits, he wants you to tell him, for each tally, how many accounting offices the leader can choose from. Since this number can be very large, GFS only wants the answer modulo $19\\,961\\,993$.", "inputFormat": "The first line contains an integer $x$ denoting the total number of tally and update operations.\n\nThen follow $x$ lines, each with $3$ integers $a_i, b_i, c_i$. If $a_i = 0$, this record is a tally plan: the leader will tally deposits of banks from $b_i$ to $c_i$, and you need to compute the answer GFS wants for this record. If $a_i = 1$, this record is an update: you should change the deposit of bank $b_i$ to $c_i$, and you do not need to output anything for this record.", "outputFormat": "For each query, output a single integer per line denoting the answer.", "hint": "### Sample Explanation\n\n- Initially, each country’s deposit is $3$.\n- The $product$ for $1$ to $3$ is $27$. In $[1,27]$, there are $18$ numbers not in conflict with $27$.\n- The deposit of $1$ becomes $5$.\n- The $product$ for $1$ to $3$ is $45$. In $[1,45]$, there are $24$ numbers not in conflict with $45$.\n- The deposit of $1$ becomes $7$.\n- The $product$ for $1$ to $3$ is $63$. In $[1,63]$, there are $36$ numbers not in conflict with $63$.\n- The $product$ for $2$ to $3$ is $9$. In $[1,9]$, there are $6$ numbers not in conflict with $9$.\n\n### Constraints\n\nAll testdata satisfy: $x \\geq 1$, $c_i - b_i \\geq 0$.\n\n| Subtask ID | Score |    $x \\leq$     | $c_i - b_i \\leq$ | Special Property |\n| :--------: | :---: | :-------------: | :--------------: | :--------------: |\n|    $1$     |  $20$ |     $10^4$      |       $100$      |       Yes        |\n|    $2$     |  $30$ | $5 \\times 10^4$ |      $10^4$      |        No        |\n|    $3$     |  $50$ |     $10^5$      |      $10^5$      |        No        |\n\nSpecial property means: all $product \\leq 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[清华集训 2014] 奇数国", "background": null, "description": "在一片美丽的大陆上有 $100\\,000$ 个国家，记为 $1$ 到 $100\\,000$。这里经济发达，有数不尽的账房，并且每个国家有一个银行。\n\n某大公司的领袖在这 $100\\,000$ 个银行开户时都存了 $3$ 大洋，他惜财如命，因此会不时地派小弟 GFS 清点一些银行的存款或者让 GFS 改变某个银行的存款。\n\n该村子在财产上的求和运算等同于我们的乘法运算，也就是说领袖开户时的存款总和为 $3^{100000}$。这里发行的软妹面额是最小的 $60$ 个素数（$p_1=2,p_2=3,\\ldots, p_{60}=281$），任何人的财产都只能由这 $60$ 个基本面额表示，即设某个人的财产为 $fortune$（正整数），则 $fortune=p_1^{k_1} \\times p_2^{k_2} \\times \\ldots p_{60}^{k_{60}}$。\n\n领袖习惯将一段编号连续的银行里的存款拿到一个账房去清点，为了避免 GFS 串通账房叛变，所以他不会每次都选择同一个账房。GFS 跟随领袖多年已经摸清了门路,知道领袖选择账房的方式。如果领袖选择清点编号在 $[a,b]$ 内的银行财产，他会先对 $[a,b]$ 的财产求和（记为 $product$），然后在编号属于 $[1,product]$ 的账房中选择一个去清点存款，检验自己计算是否正确同时也检验账房与 GFS 是否有勾结。GFS 发现如果某个账房的编号 $number$ 与 $product$ 相冲，领袖绝对不会选择这个账房。\n\n怎样才算与 $product$ 不相冲呢？若存在整数 $x,y$ 使得 $number \\times x+product \\times y=1$，那么我们称 $number$ 与 $product$ 不相冲，即该账房有可能被领袖相中。当领袖又赚大钱了的时候，他会在某个银行改变存款，这样一来相同区间的银行在不同的时候算出来的 $product$ 可能是不一样的，而且领袖不会在某个银行的存款总数超过 $10^6$。\n\n现在 GFS 预先知道了领袖的清点存款与变动存款的计划，想请你告诉他，每次清点存款时领袖有多少个账房可以供他选择，当然这个值可能非常大，GFS 只想知道对 $19\\,961\\,993$ 取模后的答案。", "inputFormat": "第一行一个整数 $x$ 表示领袖清点和变动存款的总次数。\n\n接下来 $x$ 行，每行 $3$ 个整数 $a_i,b_i,c_i$。$a_i$ 为 $0$ 时表示该条记录是清点计划，领袖会清点 $b_i$ 到 $c_i$ 的银行存款，你需要对该条记录计算出 GFS 想要的答案。$a_i$ 为 $1$ 时表示该条记录是存款变动，你要把银行 $b_i$ 的存款改为 $c_i$，不需要对该记录进行计算。", "outputFormat": "对于每个询问，输出一行一个整数表示答案。", "hint": "### 样例解释\n\n- 初始化每个国家存款都为 $3$；\n- $1$ 到 $3$ 的 $product$ 为 $27$，$[1,27]$ 与 $27$ 不相冲的有 $18$ 个数；\n- $1$ 的存款变为 $5$；\n- $1$ 到 $3$ 的 $product$ 为 $45$，$[1,45]$ 与 $45$ 不相冲的有 $24$ 个数；\n- $1$ 的存款变为 $7$；\n- $1$ 到 $3$ 的 $product$ 为 $63$，$[1,63]$ 与 $63$ 不相冲的有 $36$个数；\n- $2$ 到 $3$ 的 $product$ 为 $9$，$[1,9]$ 与 $9$ 不相冲的有 $6$ 个数。\n\n### 数据范围\n\n所有数据均满足：$x \\geq 1$，$c_i -b_i \\geq 0$。\n\n| 子任务编号 | 分值 |    $x \\leq$     | $c_i - b_i \\leq$ | 特殊性质 |\n| :--------: | :--: | :-------------: | :--------------: | :------: |\n|    $1$     | $20$ |     $10^4$      |      $100$       |    有    |\n|    $2$     | $30$ | $5 \\times 10^4$ |      $10^4$      |    无    |\n|    $3$     | $50$ |     $10^5$      |      $10^5$      |    无    |\n\n特殊性质指：所有 $product \\leq 10^{18}$。", "locale": "zh-CN"}}}
{"pid": "P4141", "type": "P", "difficulty": 3, "samples": [["3 2\n1 1 2", "11\n11\n21"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["动态规划 DP", "递推", "枚举", "分治", "背包 DP"], "title": "消失之物", "background": "", "description": "ftiasch 有 $n$ 个物品, 体积分别是 $w_1,w_2,\\dots,w_n$。由于她的疏忽，第 $i$ 个物品丢失了。   \n\n“要使用剩下的 $n-1$ 物品装满容积为 $x$ 的背包，有几种方法呢？”——这是经典的问题了。  \n\n她把答案记为 $\\text{cnt}(i,x)$ ，想要得到所有$i \\in [1,n]$, $x \\in [1,m]$ 的 $\\text{cnt}(i,x)$ 表格。\n\n![](https://cdn.luogu.com.cn/upload/pic/13426.png)", "inputFormat": "第一行两个整数 $n,m$，表示物品的数量和最大的容积。\n第二行 $n$ 个整数 $w_1,w_2,\\dots,w_n$，表示每个物品的体积。", "outputFormat": "输出一个 $n \\times m$ 的矩阵，表示 $\\text{cnt}(i,x)$ 的**末位数字**。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n,m \\le 2000$，且 $1\\le w_i\\le 2000$。\n\n【样例解释】  \n如果物品 3 丢失的话，只有一种方法装满容量是 2 的背包，即选择物品 1 和物品 2。\n\n---\n\n$\\text{upd 2023.8.11}$：新增加五组 Hack 数据。", "locale": "zh-CN", "translations": {"en": {"title": "The Missing Item", "background": "", "description": "ftiasch has $n$ items with volumes $w_1,w_2,\\dots,w_n$. Due to her negligence, the $i$-th item is missing.\n\n“How many ways are there to exactly fill a knapsack of capacity $x$ using the remaining $n-1$ items?” — this is a classic problem.\n\nShe records the answer as $\\text{cnt}(i,x)$ and wants the table of $\\text{cnt}(i,x)$ for all $i \\in [1,n]$ and $x \\in [1,m]$.\n\n![](https://cdn.luogu.com.cn/upload/pic/13426.png)", "inputFormat": "The first line contains two integers $n,m$, the number of items and the maximum capacity.  \nThe second line contains $n$ integers $w_1,w_2,\\dots,w_n$, the volume of each item.", "outputFormat": "Output an $n \\times m$ matrix, giving the last digit of $\\text{cnt}(i,x)$.", "hint": "Constraints  \nFor $100\\%$ of the testdata, $1 \\le n,m \\le 2000$, and $1 \\le w_i \\le 2000$.\n\nSample explanation  \nIf item $3$ is missing, there is exactly one way to fill capacity $2$, namely choosing items $1$ and $2$.\n\n—  \n$\\text{upd 2023.8.11}$: Added five new hack test sets.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "消失之物", "background": "", "description": "ftiasch 有 $n$ 个物品, 体积分别是 $w_1,w_2,\\dots,w_n$。由于她的疏忽，第 $i$ 个物品丢失了。   \n\n“要使用剩下的 $n-1$ 物品装满容积为 $x$ 的背包，有几种方法呢？”——这是经典的问题了。  \n\n她把答案记为 $\\text{cnt}(i,x)$ ，想要得到所有$i \\in [1,n]$, $x \\in [1,m]$ 的 $\\text{cnt}(i,x)$ 表格。\n\n![](https://cdn.luogu.com.cn/upload/pic/13426.png)", "inputFormat": "第一行两个整数 $n,m$，表示物品的数量和最大的容积。\n第二行 $n$ 个整数 $w_1,w_2,\\dots,w_n$，表示每个物品的体积。", "outputFormat": "输出一个 $n \\times m$ 的矩阵，表示 $\\text{cnt}(i,x)$ 的**末位数字**。", "hint": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n,m \\le 2000$，且 $1\\le w_i\\le 2000$。\n\n【样例解释】  \n如果物品 3 丢失的话，只有一种方法装满容量是 2 的背包，即选择物品 1 和物品 2。\n\n---\n\n$\\text{upd 2023.8.11}$：新增加五组 Hack 数据。", "locale": "zh-CN"}}}
{"pid": "P4142", "type": "P", "difficulty": 6, "samples": [["3 3 1\n0 1 0\n2 0 1\n0 1 0\n1 3", "3"], ["3 3 4\n0 2 0\n0 0 4\n0 3 0\n1 3\n2 1\n2 2\n3 1", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["图论建模", "构造"], "title": "洞穴遇险", "background": "**ZRQ**在洞穴中准备采集矿物的时候遇险了！洞穴**要塌了**！\n\n题目来源：[zhoutb2333](https://www.luogu.org/space/show?uid=31564)\n", "description": "整个洞穴是一个$N*N$的方格图，每个格子形如$(X,Y),1 \\le X,Y \\le N$。其中$X$表示从上到下的行数，$Y$表示从左到右的列数。$(1,1)$在左上角,$(1,N)$在右上角，$(N,1)$在左下角，$(N,N)$在右下角。\n\n\n满足$X+Y$为奇数格子的有一个不稳定度$V_{X,Y},X+Y$为偶数的格子的不稳定度为$0$。\n\n\n**ZRQ**现在手里恰巧有$M$个可以支撑洞穴的柱子，柱子的力量可以认为是无穷大。\n\n\n只要支撑住了一个格子那么这个格子的不稳定度将降为$0$。\n\n\n每个柱子是$L$型的，它除了要占据当前的格子外，还需要占据两个相邻的格子（这三个格子形成$L$型,可以选择任意方向放置，一共有$4$个方向）。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/13049.png) \n\n**柱子占据相邻的格子不会降低其不稳定度（换句话说就是柱子只有在拐角处有力量）**。\n\n\n有些格子的顶已经塌下来了，无法在其位置放置柱子了，这些格子也不能被占据了。这样已经塌了的格子有$K$个（他们的不稳定度都为$0$,**即使$X+Y$为奇数，塌下来的格子的不稳定度也会为$0$**）。\n\n\n**ZRQ**想问你，在放置一些柱子后 ，最小的不稳定度之和为多少（可以不将$M$个柱子都放完）。\n", "inputFormat": "第一行三个整数$N,M,K$\n\n\n接下来$N$行每行$N$个整数，表示每个格子的不稳定度，**保证$X+Y$为偶数的格子和已经塌下的格子的不稳定度为$0$**。\n\n\n接下来$K$行每行$2$个整数$X,Y$，表示已经塌下的格子的坐标。\n", "outputFormat": "一行一个整数，表示最小的不稳定度的和。\n", "hint": "共$10$个测试点，每个点$10$分，计$100$分。\n\n\n对于测试点$1$~$3$，有$1 \\le N \\le 6$\n\n\n对于测试点$4$~$7$，有$1 \\le N \\le 11$\n\n\n对于测试点$8$~$10$，有$1 \\le N \\le 50$\n\n\n对于所有测试点，$0 \\le M \\le \\frac{N^2}{3}, 0 \\le K \\le N^2, 0 \\le V_{X,Y} \\le 10^6$\n\n\n**样例#1解释：**\n\n显然无法让任意两个不稳定的格子都被拐角覆盖，于是将$(2,1)$用拐角覆盖住即可。这样剩余的不稳定度为$V_{1,2}+V_{2,3}+V_{3,2}=1+1+1=3$。\n\n**样例#2解释：**\n\n一个都放不下，这样剩余的不稳定度为$V_{1,2}+V_{2,3}+V_{3,2}=2+4+3=9$。\n", "locale": "zh-CN", "translations": {"en": {"title": "{{Cave Emergency}}", "background": "{{When ZRQ was about to collect minerals in the cave, an accident happened. The cave is about to collapse!\n\nProblem source: [zhoutb2333](https://www.luogu.org/space/show?uid=31564).}}", "description": "{{The entire cave is an $N*N$ grid. Each cell is denoted as $(X, Y)$, where $1 \\le X, Y \\le N$. Here $X$ is the row index from top to bottom, and $Y$ is the column index from left to right. $(1,1)$ is the top-left corner, $(1,N)$ is the top-right corner, $(N,1)$ is the bottom-left corner, and $(N,N)$ is the bottom-right corner.\n\nCells with $X+Y$ odd have an instability $V_{X,Y}$, while cells with $X+Y$ even have instability $0$.\n\nZRQ happens to have $M$ pillars that can support the cave. The strength of each pillar can be regarded as infinite.\n\nAs long as a cell is supported, its instability becomes $0$.\n\nEach pillar is L-shaped: in addition to occupying its current cell (the corner), it must also occupy two adjacent cells so that the three cells form an L shape. You can place it in any of the $4$ orientations.\n\n![](https://cdn.luogu.com.cn/upload/pic/13049.png)\n\nOccupying adjacent cells with a pillar does not reduce their instability (in other words, a pillar only has force at its corner cell).\n\nSome cells have already collapsed, so you cannot place a pillar there, and these cells cannot be occupied either. There are $K$ such cells. Their instability is $0$ (even if $X+Y$ is odd, a collapsed cell’s instability is still $0$).\n\nZRQ asks: after placing some pillars (you do not have to use all $M$ pillars), what is the minimum possible sum of instabilities?}}", "inputFormat": "{{The first line contains three integers $N, M, K$.\n\nThe next $N$ lines each contain $N$ integers, representing the instability of each cell. It is guaranteed that cells with $X+Y$ even and collapsed cells have instability $0$.\n\nThe next $K$ lines each contain two integers $X, Y$, denoting the coordinates of the collapsed cells.}}", "outputFormat": "{{Output a single integer: the minimum possible sum of instabilities.}}", "hint": "{{There are $10$ test points, each worth $10$ points, for a total of $100$ points.\n\nConstraints:\n- For test points $1$–$3$: $1 \\le N \\le 6$.\n- For test points $4$–$7$: $1 \\le N \\le 11$.\n- For test points $8$–$10$: $1 \\le N \\le 50$.\n- For all test points: $0 \\le M \\le \\frac{N^2}{3}$, $0 \\le K \\le N^2$, $0 \\le V_{X,Y} \\le 10^6$.\n\nSample #1 explanation:\nIt is clearly impossible to have any two unstable cells both covered by a pillar’s corner. Therefore, just cover $(2,1)$ with a pillar’s corner. The remaining instability is $V_{1,2}+V_{2,3}+V_{3,2}=1+1+1=3$.\n\nSample #2 explanation:\nNone can be placed. The remaining instability is $V_{1,2}+V_{2,3}+V_{3,2}=2+4+3=9$.}}\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "洞穴遇险", "background": "**ZRQ**在洞穴中准备采集矿物的时候遇险了！洞穴**要塌了**！\n\n题目来源：[zhoutb2333](https://www.luogu.org/space/show?uid=31564)\n", "description": "整个洞穴是一个$N*N$的方格图，每个格子形如$(X,Y),1 \\le X,Y \\le N$。其中$X$表示从上到下的行数，$Y$表示从左到右的列数。$(1,1)$在左上角,$(1,N)$在右上角，$(N,1)$在左下角，$(N,N)$在右下角。\n\n\n满足$X+Y$为奇数格子的有一个不稳定度$V_{X,Y},X+Y$为偶数的格子的不稳定度为$0$。\n\n\n**ZRQ**现在手里恰巧有$M$个可以支撑洞穴的柱子，柱子的力量可以认为是无穷大。\n\n\n只要支撑住了一个格子那么这个格子的不稳定度将降为$0$。\n\n\n每个柱子是$L$型的，它除了要占据当前的格子外，还需要占据两个相邻的格子（这三个格子形成$L$型,可以选择任意方向放置，一共有$4$个方向）。\n\n\n\n ![](https://cdn.luogu.com.cn/upload/pic/13049.png) \n\n**柱子占据相邻的格子不会降低其不稳定度（换句话说就是柱子只有在拐角处有力量）**。\n\n\n有些格子的顶已经塌下来了，无法在其位置放置柱子了，这些格子也不能被占据了。这样已经塌了的格子有$K$个（他们的不稳定度都为$0$,**即使$X+Y$为奇数，塌下来的格子的不稳定度也会为$0$**）。\n\n\n**ZRQ**想问你，在放置一些柱子后 ，最小的不稳定度之和为多少（可以不将$M$个柱子都放完）。\n", "inputFormat": "第一行三个整数$N,M,K$\n\n\n接下来$N$行每行$N$个整数，表示每个格子的不稳定度，**保证$X+Y$为偶数的格子和已经塌下的格子的不稳定度为$0$**。\n\n\n接下来$K$行每行$2$个整数$X,Y$，表示已经塌下的格子的坐标。\n", "outputFormat": "一行一个整数，表示最小的不稳定度的和。\n", "hint": "共$10$个测试点，每个点$10$分，计$100$分。\n\n\n对于测试点$1$~$3$，有$1 \\le N \\le 6$\n\n\n对于测试点$4$~$7$，有$1 \\le N \\le 11$\n\n\n对于测试点$8$~$10$，有$1 \\le N \\le 50$\n\n\n对于所有测试点，$0 \\le M \\le \\frac{N^2}{3}, 0 \\le K \\le N^2, 0 \\le V_{X,Y} \\le 10^6$\n\n\n**样例#1解释：**\n\n显然无法让任意两个不稳定的格子都被拐角覆盖，于是将$(2,1)$用拐角覆盖住即可。这样剩余的不稳定度为$V_{1,2}+V_{2,3}+V_{3,2}=1+1+1=3$。\n\n**样例#2解释：**\n\n一个都放不下，这样剩余的不稳定度为$V_{1,2}+V_{2,3}+V_{3,2}=2+4+3=9$。\n", "locale": "zh-CN"}}}
{"pid": "P4143", "type": "P", "difficulty": 7, "samples": [["abcd\n10 0 1 1", "3\n1 1\n3 4\n4 4"], ["aaaa\n1 1 1 1", "0"], ["aaa\n1 1 1", "2\n1 2\n2 3"], ["aaa\n1 1 2", "1\n1 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["字符串", "线段树", "ST 表", "后缀数组 SA"], "title": "采集矿石", "background": "**ZRQ** 成功从坍塌的洞穴中逃了出来。终于，他看到了要研究的矿石。他想挑一些带回去完成任务。\n\n题目来源：[Zhang\\_RQ](https://www.luogu.org/space/show?uid=31565)~~哦对了 ZRQ 就他，嗯~~\n", "description": "**ZRQ** 发现这里有 $N$ 块排成一排的矿石。\n\n他用一个小写字母来表示每块矿石，他还发现每块矿石有一个重要度 $V_i$。\n\n**ZRQ** 想采集一段连续的矿石回研究所。\n\n他非常严格，被采集的一段矿石必须满足**小写字母的字典序降序排名等于这段矿石的重要度和。**\n\n**这里多个出现在不同位置的本质相同串的字典序排名相同。**\n\n比如说字母串为 `aa`，那么第一个 `a` 的排名和第二个 `a` 的排名相同，都是 `2`（第 `1` 是 `aa`）。\n\n**ZRQ** 问你，在原串中有哪些不同的子串可以被采集？\n\n**这里子串不同定义为出现位置不同，也就是说本质相同的子串出现在不同位置都要计算一次（当然重要度和等于排名是前提）。**\n\n比如共有 $4$ 块矿石，小写字母串为 `abcd`，重要度各为 `10 0 1 1`。\n\n我们把所有的子串按照字典序从大到小排名：`1:d 2:cd 3:c 4:bcd 5:bc 6:b 7:abcd 8:abc 9:ab 10:a`。\n\n那么串 `d` 的排名为 $1$（第一大），重要度和为 $1$，可以被采集。\n\n串 `cd` 的排名为 $2$，重要度和为 $2$，可以被采集。\n\n串 `a` 的排名为 $10$，重要度和为 $10$，可以被采集。\n\n其他串则不满足这个条件，故有三个串可以被采集。\n", "inputFormat": "第一行一个长度为 $N$ 由小写字母组成的字符串，每个字符代表一个矿石。\n\n\n第二行 $N$ 个整数，表示 $V_i$。\n", "outputFormat": "一行一个整数，表示能被采集的子串个数 $S$。\n\n\n接下来 $S$ 行每行两个整数 $L,R$，分别表示每个可采集子串的左端点与右端点，按照左端点升序为第一关键字，右端点升序为第二关键字排序。\n", "hint": "共 $10$ 个测试点，每个点 $10$ 分，计 $100$ 分。\n\n![pcg6nP.png](https://s1.ax1x.com/2018/01/19/pcg6nP.png)\n\n对于所有测试点，有 $N\\leq 10^5$，$0 \\le V_i \\le 1000$。保证每个点可被采集的子串不超过 $10^5$ 个。\n\n\n**样例#1解释**放在题面里了。\n\n**样例#2解释：**\n\n每个子串都不满足条件。\n\n串 `a` 的排名是 $4$，重要度和都是 $1$。\n\n串 `aa` 的排名是 $3$，重要度和都是 $2$。\n\n串 `aaa` 的排名是 $2$，重要度和都是 $3$。\n\n串 `aaaa` 的排名是 $1$，重要度和都是 $4$。\n\n**样例 #3解释：**\n\n串 `a` 的排名是 $3$，重要度和都是 $1$。\n\n串 `aa` 的排名是 $2$，重要度和都是 $2$，共有两个串`aa`，位置分别为 $1$~$2$ 和 $2$~$3$。\n\n串 `aaa` 的排名是 $1$，重要度和都是 $3$。\n\n**样例 #4解释：**\n\n可以发现，串 $2$~$3$（第二个 `aa`）不满足条件了。它的排名还是 $2$ 不变，但是重要度和为 $3$。\n", "locale": "zh-CN", "translations": {"en": {"title": "Collecting Ores", "background": "ZRQ successfully escaped from the collapsed cave. At last, he saw the ores he needed to study. He wants to pick some to take back and complete the task.\n\nProblem source: [Zhang_RQ](https://www.luogu.org/space/show?uid=31565)~~Oh right, it is ZRQ, yeah~~.", "description": "ZRQ finds that there are $N$ ores arranged in a line.\n\nHe uses a lowercase letter to represent each ore, and he also finds that each ore has an importance value $V_i$.\n\nZRQ wants to collect a consecutive segment of ores and bring them back to the lab.\n\nHe is very strict: the collected segment must satisfy that the lexicographic rank in descending order of this substring among all substrings equals the sum of importance values of this segment.\n\nHere, multiple occurrences of substrings that are identical in content but appear at different positions share the same lexicographic rank.\n\nFor example, if the letter string is `aa`, then the rank of the first `a` and the second `a` is the same, both are `2` (the `1` is `aa`).\n\nZRQ asks you: which substrings in the original string can be collected?\n\nHere, substrings are considered different if their positions of occurrence are different, that is, identical substrings appearing at different positions are all counted separately (of course, only if the sum of importance equals the rank).\n\nFor example, there are $4$ ores, the lowercase letter string is `abcd`, and the importance values are `10 0 1 1`.\n\nWe rank all substrings in descending lexicographic order: `1:d 2:cd 3:c 4:bcd 5:bc 6:b 7:abcd 8:abc 9:ab 10:a`.\n\nThen the rank of `d` is $1$ (the largest), and its importance sum is $1$, so it can be collected.\n\nThe rank of `cd` is $2$, and its importance sum is $2$, so it can be collected.\n\nThe rank of `a` is $10$, and its importance sum is $10$, so it can be collected.\n\nOther substrings do not satisfy this condition, so there are three substrings that can be collected.", "inputFormat": "The first line contains a string of length $N$ consisting of lowercase letters, where each character represents an ore.\n\nThe second line contains $N$ integers, representing $V_i$.", "outputFormat": "The first line contains a single integer, the number $S$ of substrings that can be collected.\n\nThen output $S$ lines, each with two integers $L,R$, representing the left and right endpoints of each collectable substring, sorted by increasing left endpoint as the primary key and increasing right endpoint as the secondary key.", "hint": "There are $10$ testpoints, each worth $10$ points, totaling $100$ points.\n\n![pcg6nP.png](https://s1.ax1x.com/2018/01/19/pcg6nP.png)\n\nFor all testpoints, $N \\leq 10^5$, $0 \\le V_i \\le 1000$. It is guaranteed that the number of substrings that can be collected for each test is at most $10^5$.\n\nExplanation for Sample #1 is included in the statement.\n\nExplanation for Sample #2:\n\nNo substring satisfies the condition.\n\nThe rank of `a` is $4$, and the importance sums are all $1$.\n\nThe rank of `aa` is $3$, and the importance sums are all $2$.\n\nThe rank of `aaa` is $2$, and the importance sums are all $3$.\n\nThe rank of `aaaa` is $1$, and the importance sums are all $4$.\n\nExplanation for Sample #3:\n\nThe rank of `a` is $3$, and the importance sums are all $1$.\n\nThe rank of `aa` is $2$, and the importance sums are all $2$. There are two substrings `aa`, at positions $1$~$2$ and $2$~$3$.\n\nThe rank of `aaa` is $1$, and the importance sums are all $3$.\n\nExplanation for Sample #4:\n\nWe can see that the substring $2$~$3$ (the second `aa`) no longer satisfies the condition. Its rank is still $2$, but the importance sum is $3$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "采集矿石", "background": "**ZRQ** 成功从坍塌的洞穴中逃了出来。终于，他看到了要研究的矿石。他想挑一些带回去完成任务。\n\n题目来源：[Zhang\\_RQ](https://www.luogu.org/space/show?uid=31565)~~哦对了 ZRQ 就他，嗯~~\n", "description": "**ZRQ** 发现这里有 $N$ 块排成一排的矿石。\n\n他用一个小写字母来表示每块矿石，他还发现每块矿石有一个重要度 $V_i$。\n\n**ZRQ** 想采集一段连续的矿石回研究所。\n\n他非常严格，被采集的一段矿石必须满足**小写字母的字典序降序排名等于这段矿石的重要度和。**\n\n**这里多个出现在不同位置的本质相同串的字典序排名相同。**\n\n比如说字母串为 `aa`，那么第一个 `a` 的排名和第二个 `a` 的排名相同，都是 `2`（第 `1` 是 `aa`）。\n\n**ZRQ** 问你，在原串中有哪些不同的子串可以被采集？\n\n**这里子串不同定义为出现位置不同，也就是说本质相同的子串出现在不同位置都要计算一次（当然重要度和等于排名是前提）。**\n\n比如共有 $4$ 块矿石，小写字母串为 `abcd`，重要度各为 `10 0 1 1`。\n\n我们把所有的子串按照字典序从大到小排名：`1:d 2:cd 3:c 4:bcd 5:bc 6:b 7:abcd 8:abc 9:ab 10:a`。\n\n那么串 `d` 的排名为 $1$（第一大），重要度和为 $1$，可以被采集。\n\n串 `cd` 的排名为 $2$，重要度和为 $2$，可以被采集。\n\n串 `a` 的排名为 $10$，重要度和为 $10$，可以被采集。\n\n其他串则不满足这个条件，故有三个串可以被采集。\n", "inputFormat": "第一行一个长度为 $N$ 由小写字母组成的字符串，每个字符代表一个矿石。\n\n\n第二行 $N$ 个整数，表示 $V_i$。\n", "outputFormat": "一行一个整数，表示能被采集的子串个数 $S$。\n\n\n接下来 $S$ 行每行两个整数 $L,R$，分别表示每个可采集子串的左端点与右端点，按照左端点升序为第一关键字，右端点升序为第二关键字排序。\n", "hint": "共 $10$ 个测试点，每个点 $10$ 分，计 $100$ 分。\n\n![pcg6nP.png](https://s1.ax1x.com/2018/01/19/pcg6nP.png)\n\n对于所有测试点，有 $N\\leq 10^5$，$0 \\le V_i \\le 1000$。保证每个点可被采集的子串不超过 $10^5$ 个。\n\n\n**样例#1解释**放在题面里了。\n\n**样例#2解释：**\n\n每个子串都不满足条件。\n\n串 `a` 的排名是 $4$，重要度和都是 $1$。\n\n串 `aa` 的排名是 $3$，重要度和都是 $2$。\n\n串 `aaa` 的排名是 $2$，重要度和都是 $3$。\n\n串 `aaaa` 的排名是 $1$，重要度和都是 $4$。\n\n**样例 #3解释：**\n\n串 `a` 的排名是 $3$，重要度和都是 $1$。\n\n串 `aa` 的排名是 $2$，重要度和都是 $2$，共有两个串`aa`，位置分别为 $1$~$2$ 和 $2$~$3$。\n\n串 `aaa` 的排名是 $1$，重要度和都是 $3$。\n\n**样例 #4解释：**\n\n可以发现，串 $2$~$3$（第二个 `aa`）不满足条件了。它的排名还是 $2$ 不变，但是重要度和为 $3$。\n", "locale": "zh-CN"}}}
{"pid": "P4144", "type": "P", "difficulty": 3, "samples": [["10 1 10000000\n7 9 9 4 0 0 8 8 4 7", "251"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["贪心", "二分", "进制", "位运算"], "title": "大河的序列", "background": "“唯有龙虎相伴 最是脉脉深情”\n\n\n题目来源：[KingSann](https://www.luogu.org/space/show?uid=47111)\n", "description": "大河有一些袜子，但经常十分散乱的堆放着。\n\n\n有一天龙儿忍不住了，于是将袜子放到了一个序列上（称作袜子序列）。\n\n\n每个袜子都有一个$dirty$值，定义袜子序列的$dirty$值为 $ \\max  \\left( (dirty_{l} \\ bitand \\ dirty_{l+1} \\ bitand \\ \\cdots \\ bitand \\ dirty_{r}) + (dirty_{l} \\ bitor \\ dirty_{l+1} \\ bitor \\ \\cdots \\ bitor \\ dirty_{r}) \\right) $ ，其中 $ dirty_{i} $ 表示 第 $ i $ 只袜子 的 $ dirty $ 值，$bitand$表示按位与（C++中是`&`），$bitor$表示按位或（C++中是`|`）。\n\n\n简而言之，就是找一段连续子序列，使得所有数字的按位与加上按位或最大。\n\n\n如果这个袜子序列的$dirty$值达到了某个**阈**值，那么龙儿会讨厌大河的。\n\n\n大河当然不希望这样了，于是她想知道这个袜子序列的$dirty$值是多少。\n", "inputFormat": "第一行三个整数 $ n,b,p $ ，分别表示数列长度和输出相关的东西\n\n\n第二行有 $ n $ 个整数，表示这个数列的初始数值\n", "outputFormat": "设答案为 $ x $ ，你需要输出 $ (x+233)^{b} \\,\\, \\text{mod} \\,\\,p $\n", "hint": "$ 1 \\le n, p \\le 10^{5} $\n\n\n$ 0 \\le b, ditry_{i} \\le 10^{7} $\n\n\n对于测试点 $ 1 $ 和测试点 $ 2 $ 的数据，保证 $ 1 \\le n \\le 100 $\n", "locale": "zh-CN", "translations": {"en": {"title": "Dahe's Sequence", "background": "\"Only when dragon and tiger accompany each other is the deepest affection.\"\n\nProblem source: [KingSann](https://www.luogu.org/space/show?uid=47111).", "description": "Dahe has some socks, but they are often piled up messily.\n\nOne day, Long'er couldn’t stand it anymore, so she placed the socks onto a sequence (called the sock sequence).\n\nEach sock has a $dirty$ value. Define the $dirty$ value of the sock sequence as $ \\max  \\left( (dirty_{l} \\ bitand \\ dirty_{l+1} \\ bitand \\ \\cdots \\ bitand \\ dirty_{r}) + (dirty_{l} \\ bitor \\ dirty_{l+1} \\ bitor \\ \\cdots \\ bitor \\ dirty_{r}) \\right) $, where $ dirty_{i} $ denotes the $dirty$ value of the $i$-th sock; $bitand$ means bitwise AND (in C++ it is `&`), and $bitor$ means bitwise OR (in C++ it is `|`).\n\nIn short, find a contiguous subsequence that maximizes the sum of the bitwise AND and the bitwise OR of all numbers in it.\n\nIf the $dirty$ value of this sock sequence reaches a certain **threshold**, then Long'er will dislike Dahe.\n\nOf course, Dahe doesn’t want that, so she wants to know the $dirty$ value of this sock sequence.", "inputFormat": "The first line contains three integers $ n, b, p $, representing the length of the sequence and output-related parameters.\n\nThe second line contains $ n $ integers, the initial values of the sequence.", "outputFormat": "Let the answer be $ x $. You need to output $ (x+233)^{b} \\,\\, \\text{mod} \\,\\,p $.", "hint": "$ 1 \\le n, p \\le 10^{5} $.\n\n$ 0 \\le b, dirty_{i} \\le 10^{7} $.\n\nFor the testdata of test points $ 1 $ and $ 2 $, it is guaranteed that $ 1 \\le n \\le 100 $.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "大河的序列", "background": "“唯有龙虎相伴 最是脉脉深情”\n\n\n题目来源：[KingSann](https://www.luogu.org/space/show?uid=47111)\n", "description": "大河有一些袜子，但经常十分散乱的堆放着。\n\n\n有一天龙儿忍不住了，于是将袜子放到了一个序列上（称作袜子序列）。\n\n\n每个袜子都有一个$dirty$值，定义袜子序列的$dirty$值为 $ \\max  \\left( (dirty_{l} \\ bitand \\ dirty_{l+1} \\ bitand \\ \\cdots \\ bitand \\ dirty_{r}) + (dirty_{l} \\ bitor \\ dirty_{l+1} \\ bitor \\ \\cdots \\ bitor \\ dirty_{r}) \\right) $ ，其中 $ dirty_{i} $ 表示 第 $ i $ 只袜子 的 $ dirty $ 值，$bitand$表示按位与（C++中是`&`），$bitor$表示按位或（C++中是`|`）。\n\n\n简而言之，就是找一段连续子序列，使得所有数字的按位与加上按位或最大。\n\n\n如果这个袜子序列的$dirty$值达到了某个**阈**值，那么龙儿会讨厌大河的。\n\n\n大河当然不希望这样了，于是她想知道这个袜子序列的$dirty$值是多少。\n", "inputFormat": "第一行三个整数 $ n,b,p $ ，分别表示数列长度和输出相关的东西\n\n\n第二行有 $ n $ 个整数，表示这个数列的初始数值\n", "outputFormat": "设答案为 $ x $ ，你需要输出 $ (x+233)^{b} \\,\\, \\text{mod} \\,\\,p $\n", "hint": "$ 1 \\le n, p \\le 10^{5} $\n\n\n$ 0 \\le b, ditry_{i} \\le 10^{7} $\n\n\n对于测试点 $ 1 $ 和测试点 $ 2 $ 的数据，保证 $ 1 \\le n \\le 100 $\n", "locale": "zh-CN"}}}
{"pid": "P4145", "type": "P", "difficulty": 5, "samples": [["10\n1 2 3 4 5 6 7 8 9 10\n5\n0 1 10\n1 1 10\n1 1 5\n0 5 8\n1 4 8", "19\n7\n6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["线段树", "并查集", "树状数组", "颜色段均摊（珂朵莉树 ODT）", "枚举", "分块"], "title": "上帝造题的七分钟 2 / 花神游历各国", "background": "XLk 觉得《上帝造题的七分钟》不太过瘾，于是有了第二部。", "description": "“第一分钟，X 说，要有数列，于是便给定了一个正整数数列。\n\n第二分钟，L 说，要能修改，于是便有了对一段数中每个数都开平方（下取整）的操作。\n\n第三分钟，k 说，要能查询，于是便有了求一段数的和的操作。\n\n第四分钟，彩虹喵说，要是 NOIP 难度，于是便有了数据范围。\n\n第五分钟，诗人说，要有韵律，于是便有了时间限制和内存限制。\n\n第六分钟，和雪说，要省点事，于是便有了保证运算过程中及最终结果均不超过 $64$ 位有符号整数类型的表示范围的限制。\n\n第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”\n\n——《上帝造题的七分钟·第二部》\n\n所以这个神圣的任务就交给你了。", "inputFormat": "第一行一个整数 $n$，代表数列中数的个数。\n\n第二行 $n$ 个正整数，表示初始状态下数列中的数。\n\n第三行一个整数 $m$，表示有 $m$ 次操作。\n\n接下来 $m$ 行每行三个整数 `k l r`。\n\n- $k=0$ 表示给 $[l,r]$ 中的每个数开平方（下取整）。\n\n- $k=1$ 表示询问 $[l,r]$ 中各个数的和。\n\n**数据中有可能 $l>r$，所以遇到这种情况请交换 $l$ 和 $r$。**", "outputFormat": "对于询问操作，每行输出一个回答。", "hint": "对于 $30\\%$ 的数据，$1\\le n,m\\le 10^3$，数列中的数不超过 $32767$。\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 10^5$，$1\\le l,r\\le n$，数列中的数大于 $0$，且不超过 $10^{12}$。", "locale": "zh-CN", "translations": {"en": {"title": "Seven Minutes to Make a Problem 2 / The Flower God's Travels Across Countries", "background": "XLk felt that \"Seven Minutes to Make a Problem\" was not exciting enough, so there is a second part.", "description": "\"The first minute, X said, let there be a sequence, so a sequence of positive integers was given.\n\nThe second minute, L said, it should be modifiable, so there was an operation that takes the floor of the square root of every number in a segment.\n\nThe third minute, k said, it should be queryable, so there was an operation to find the sum of a segment.\n\nThe fourth minute, Caihong Miao said, make it NOIP difficulty, so there were constraints.\n\nThe fifth minute, the poet said, let there be rhythm, so there were time and memory limits.\n\nThe sixth minute, He Xue said, save some trouble, so it was guaranteed that during computation and in the final result, all values fit within the representable range of a $64$-bit signed integer type.\n\nThe seventh minute, this problem was finally created, but the problem setters no longer wanted to write the program for it.\"\n\n— \"Seven Minutes to Make a Problem · Part II\"\n\nSo this sacred task is handed to you.", "inputFormat": "The first line contains an integer $n$, the number of elements in the sequence.\n\nThe second line contains $n$ positive integers, the initial sequence.\n\nThe third line contains an integer $m$, the number of operations.\n\nEach of the next $m$ lines contains three integers `k l r`.\n\n- $k=0$ means replace every number in $[l,r]$ with the floor of its square root.\n- $k=1$ means query the sum of the numbers in $[l,r]$.\n\nIt is possible in the testdata that $l>r$, so when this happens please swap $l$ and $r$.", "outputFormat": "For each query operation, output one answer per line.", "hint": "Constraints:\n- For 30% of the testdata, $1\\le n,m\\le 10^3$, and the numbers in the sequence do not exceed $32767$.\n- For 100% of the testdata, $1\\le n,m\\le 10^5$, $1\\le l,r\\le n$, the numbers in the sequence are greater than $0$ and do not exceed $10^{12}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "上帝造题的七分钟 2 / 花神游历各国", "background": "XLk 觉得《上帝造题的七分钟》不太过瘾，于是有了第二部。", "description": "“第一分钟，X 说，要有数列，于是便给定了一个正整数数列。\n\n第二分钟，L 说，要能修改，于是便有了对一段数中每个数都开平方（下取整）的操作。\n\n第三分钟，k 说，要能查询，于是便有了求一段数的和的操作。\n\n第四分钟，彩虹喵说，要是 NOIP 难度，于是便有了数据范围。\n\n第五分钟，诗人说，要有韵律，于是便有了时间限制和内存限制。\n\n第六分钟，和雪说，要省点事，于是便有了保证运算过程中及最终结果均不超过 $64$ 位有符号整数类型的表示范围的限制。\n\n第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”\n\n——《上帝造题的七分钟·第二部》\n\n所以这个神圣的任务就交给你了。", "inputFormat": "第一行一个整数 $n$，代表数列中数的个数。\n\n第二行 $n$ 个正整数，表示初始状态下数列中的数。\n\n第三行一个整数 $m$，表示有 $m$ 次操作。\n\n接下来 $m$ 行每行三个整数 `k l r`。\n\n- $k=0$ 表示给 $[l,r]$ 中的每个数开平方（下取整）。\n\n- $k=1$ 表示询问 $[l,r]$ 中各个数的和。\n\n**数据中有可能 $l>r$，所以遇到这种情况请交换 $l$ 和 $r$。**", "outputFormat": "对于询问操作，每行输出一个回答。", "hint": "对于 $30\\%$ 的数据，$1\\le n,m\\le 10^3$，数列中的数不超过 $32767$。\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 10^5$，$1\\le l,r\\le n$，数列中的数大于 $0$，且不超过 $10^{12}$。", "locale": "zh-CN"}}}
{"pid": "P4146", "type": "P", "difficulty": 5, "samples": [["4 4\n1 1 3 2\n1 2 4 -1\n2 1 3\n3 2 4", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["模拟", "平衡树"], "title": "序列终结者", "background": "网上有许多题，就是给定一个序列，要你支持几种操作：A、B、C、D。一看另一道题，又是一个序列要支持几种操作：D、C、B、A。尤其是我们这里的某人，出模拟试题，居然还出了一道这样的，真是没技术含量……\n\n这样我也出一道题，我出这一道的目的是为了让大家以后做这种题目有一个“库”可以依靠，没有什么其他的意思。\n\n这道题目就叫序列终结者吧。\n", "description": "给定一个长度为 $N$ 的序列，每个序列的元素是一个整数（废话）。要支持以下三种操作：\n\n1. 将 $[L,R]$ 这个区间内的所有数加上 $V$。\n2. 将 $[L,R]$ 这个区间翻转，比如`1 2 3 4`变成`4 3 2 1`。\n3. 求 $[L,R]$ 这个区间中的最大值。\n\n最开始所有元素都是 $0$。\n", "inputFormat": "第一行两个整数 $N，M$。$M$ 为操作个数。\n\n以下 $M$ 行，每行最多四个整数，依次为 $K，L，R，V$。$K$ 表示是第几种操作，如果不是第 $1$ 种操作则 $K$ 后面只有两个数。\n", "outputFormat": "对于每个第 $3$ 种操作，给出正确的回答。\n\n", "hint": "$1\\le N \\le 50000$，$1\\le M \\le 100000$，$|V| \\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Sequence Terminator", "background": "There are many problems online where, given a sequence, you need to support several operations: A, B, C, D. Then you see another problem: again a sequence with operations to support: D, C, B, A. Especially someone here, when making a mock exam, even made one like this. Honestly, there is not much technical content in that...\n\nSo I will also make one. My goal is to let everyone have a “library” to rely on when solving such problems in the future, nothing else.\n\nLet’s call this problem Sequence Terminator.", "description": "Given a sequence of length $N$, each element is an integer (trivial). You need to support the following three operations:\n\n1. Add $V$ to every number in the interval $[L,R]$.\n2. Reverse the interval $[L,R]$, for example, `1 2 3 4` becomes `4 3 2 1`.\n3. Query the maximum value in the interval $[L,R]$.\n\nInitially, all elements are $0$.", "inputFormat": "The first line contains two integers $N，M$. $M$ is the number of operations.\n\nThe next $M$ lines each contain up to four integers, in order: $K，L，R，V$. $K$ indicates the operation type. If it is not the $1$st operation, then only two numbers follow $K$.", "outputFormat": "For each operation of type $3$, output the correct answer.", "hint": "$1\\le N \\le 50000$，$1\\le M \\le 100000$，$|V| \\leq 1000$。\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "序列终结者", "background": "网上有许多题，就是给定一个序列，要你支持几种操作：A、B、C、D。一看另一道题，又是一个序列要支持几种操作：D、C、B、A。尤其是我们这里的某人，出模拟试题，居然还出了一道这样的，真是没技术含量……\n\n这样我也出一道题，我出这一道的目的是为了让大家以后做这种题目有一个“库”可以依靠，没有什么其他的意思。\n\n这道题目就叫序列终结者吧。\n", "description": "给定一个长度为 $N$ 的序列，每个序列的元素是一个整数（废话）。要支持以下三种操作：\n\n1. 将 $[L,R]$ 这个区间内的所有数加上 $V$。\n2. 将 $[L,R]$ 这个区间翻转，比如`1 2 3 4`变成`4 3 2 1`。\n3. 求 $[L,R]$ 这个区间中的最大值。\n\n最开始所有元素都是 $0$。\n", "inputFormat": "第一行两个整数 $N，M$。$M$ 为操作个数。\n\n以下 $M$ 行，每行最多四个整数，依次为 $K，L，R，V$。$K$ 表示是第几种操作，如果不是第 $1$ 种操作则 $K$ 后面只有两个数。\n", "outputFormat": "对于每个第 $3$ 种操作，给出正确的回答。\n\n", "hint": "$1\\le N \\le 50000$，$1\\le M \\le 100000$，$|V| \\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P4147", "type": "P", "difficulty": 4, "samples": [["5 6 \nR F F F F F \nF F F F F F \nR R R F F F \nF F F F F F \nF F F F F F", "45"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["动态规划 DP", "枚举", "单调栈"], "title": "玉蟾宫", "background": "有一天，小猫 rainbow 和 freda 来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。", "description": "这片土地被分成 $N\\times M$ 个格子，每个格子里写着 `R` 或者 `F`，R 代表这块土地被赐予了 rainbow，F 代表这块土地被赐予了 freda。\n\n现在 freda 要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着 `F` 并且面积最大。\n\n但是 rainbow 和 freda 的 OI 水平都弱爆了，找不出这块土地，而蓝兔也想看 freda 卖萌（她显然是不会编程的……），所以它们决定，如果你找到的最大的土地面积为 $S$，它们每人给你 $S$ 两银子。", "inputFormat": "第一行两个整数 $N$，$M$，表示矩形土地有 $N$ 行 $M$ 列。\n\n接下来 $N$ 行，每行 $M$ 个用空格隔开的字符 `F` 或 `R`，描述了矩形土地。", "outputFormat": "输出一个整数，表示你能得到多少银子，即 $3\\times S$ 的值。", "hint": "对于 $50\\%$ 的数据，$1 \\leq N, M \\leq 200$。  \n对于 $100\\%$ 的数据，$1 \\leq N, M \\leq 1000$。", "locale": "zh-CN", "translations": {"en": {"title": "Yuchan Palace", "background": "One day, the kittens rainbow and freda came to Yuchan Palace on Tianmen Mountain in Zhangjiajie, Western Hunan. The palace master, Blue Rabbit (Lan Tu), warmly entertained them and granted them a piece of land.", "description": "This piece of land is divided into $N\\times M$ cells. Each cell contains `R` or `F`. `R` means the cell is granted to rainbow, and `F` means it is granted to freda.\n\nNow freda wants to act cute here... She wants to find a rectangular piece of land that is all `F`, with the largest possible area.\n\nBut rainbow and freda are very weak at OI, and Blue Rabbit also wants to watch freda act cute (she obviously cannot program), so they decide that if the largest area you find is $S$, each of them will give you $S$ taels of silver.", "inputFormat": "The first line contains two integers $N$ and $M$, meaning the rectangular land has $N$ rows and $M$ columns.\n\nThe next $N$ lines each contain $M$ characters separated by spaces, each being `F` or `R`, describing the land.", "outputFormat": "Output a single integer, the amount of silver you can get, i.e., the value of $3\\times S$.", "hint": "Constraints:\n- For $50\\%$ of the testdata, $1 \\leq N, M \\leq 200$.\n- For $100\\%$ of the testdata, $1 \\leq N, M \\leq 1000$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "玉蟾宫", "background": "有一天，小猫 rainbow 和 freda 来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。", "description": "这片土地被分成 $N\\times M$ 个格子，每个格子里写着 `R` 或者 `F`，R 代表这块土地被赐予了 rainbow，F 代表这块土地被赐予了 freda。\n\n现在 freda 要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着 `F` 并且面积最大。\n\n但是 rainbow 和 freda 的 OI 水平都弱爆了，找不出这块土地，而蓝兔也想看 freda 卖萌（她显然是不会编程的……），所以它们决定，如果你找到的最大的土地面积为 $S$，它们每人给你 $S$ 两银子。", "inputFormat": "第一行两个整数 $N$，$M$，表示矩形土地有 $N$ 行 $M$ 列。\n\n接下来 $N$ 行，每行 $M$ 个用空格隔开的字符 `F` 或 `R`，描述了矩形土地。", "outputFormat": "输出一个整数，表示你能得到多少银子，即 $3\\times S$ 的值。", "hint": "对于 $50\\%$ 的数据，$1 \\leq N, M \\leq 200$。  \n对于 $100\\%$ 的数据，$1 \\leq N, M \\leq 1000$。", "locale": "zh-CN"}}}
{"pid": "P4148", "type": "P", "difficulty": 6, "samples": [["4\n1 2 3 3\n2 1 1 3 3\n1 1 1 1\n2 1 1 0 7\n3", "3\n5"]], "limits": {"time": [8000, 8000, 8000, 8000, 8000], "memory": [20480, 20480, 20480, 20480, 20480]}, "tags": ["递归", "K-D Tree"], "title": "简单题", "background": "", "description": "你有一个$N \\times N$的棋盘，每个格子内有一个整数，初始时的时候全部为 $0$，现在需要维护两种操作：\n\n- `1 x y A`    $1\\le x,y\\le N$，$A$ 是正整数。将格子`x`,`y`里的数字加上 $A$。\n- `2 x1 y1 x2 y2`    $1 \\le x_1 \\le x_2 \\le N$，$1 \\le y_1\\le y_2 \\le N$。输出 $x_1, y_1, x_2, y_2$ 这个矩形内的数字和\n- `3`    无 终止程序\n", "inputFormat": "输入文件第一行一个正整数 $N$。\n\n接下来每行一个操作。每条命令除第一个数字之外，均要异或上一次输出的答案 `last_ans`，初始时 `last_ans` $=0$。\n", "outputFormat": "对于每个 $2$ 操作，输出一个对应的答案。\n", "hint": "$1\\leq N\\leq 5\\times 10^5$，操作数不超过 $2\\times 10^5$ 个，内存限制 $20\\texttt{MB}$，保证答案在 int 范围内并且解码之后数据仍合法。\n", "locale": "zh-CN", "translations": {"en": {"title": "Simple Problem", "background": "", "description": "You have an $N \\times N$ board with an integer in each cell, all initially $0$. You need to support three types of operations:\n\n- `1 x y A`    $1\\le x,y\\le N$, and $A$ is a positive integer. Add $A$ to the number in cell `x`, `y`.\n- `2 x1 y1 x2 y2`    $1 \\le x_1 \\le x_2 \\le N$, $1 \\le y_1\\le y_2 \\le N$. Output the sum of numbers inside the rectangle $x_1, y_1, x_2, y_2$.\n- `3`    None. Terminate the program.", "inputFormat": "The first line contains a positive integer $N$.\n\nEach of the following lines contains one operation. For every command, all numbers after the first one must be XORed with the previous output answer `last_ans`. Initially, `last_ans` $= 0$.", "outputFormat": "For each operation of type $2$, output the corresponding answer.", "hint": "Constraints: $1\\leq N\\leq 5\\times 10^5$, the number of operations does not exceed $2\\times 10^5$, memory limit $20\\texttt{MB}$. It is guaranteed that answers fit in the range of int and that after decoding the testdata remains valid.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "简单题", "background": "", "description": "你有一个$N \\times N$的棋盘，每个格子内有一个整数，初始时的时候全部为 $0$，现在需要维护两种操作：\n\n- `1 x y A`    $1\\le x,y\\le N$，$A$ 是正整数。将格子`x`,`y`里的数字加上 $A$。\n- `2 x1 y1 x2 y2`    $1 \\le x_1 \\le x_2 \\le N$，$1 \\le y_1\\le y_2 \\le N$。输出 $x_1, y_1, x_2, y_2$ 这个矩形内的数字和\n- `3`    无 终止程序\n", "inputFormat": "输入文件第一行一个正整数 $N$。\n\n接下来每行一个操作。每条命令除第一个数字之外，均要异或上一次输出的答案 `last_ans`，初始时 `last_ans` $=0$。\n", "outputFormat": "对于每个 $2$ 操作，输出一个对应的答案。\n", "hint": "$1\\leq N\\leq 5\\times 10^5$，操作数不超过 $2\\times 10^5$ 个，内存限制 $20\\texttt{MB}$，保证答案在 int 范围内并且解码之后数据仍合法。\n", "locale": "zh-CN"}}}
{"pid": "P4149", "type": "P", "difficulty": 5, "samples": [["4 3\n0 1 1\n1 2 2\n1 3 4", "2"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}, "tags": ["2011", "点分治", "递归", "树上启发式合并", "IOI", "O2优化", "分治"], "title": "[IOI 2011] Race", "background": "", "description": "给一棵树，每条边有权。求一条简单路径，权值和等于 $k$，且边的数量最小。", "inputFormat": "第一行包含两个整数 $n,k$，表示树的大小与要求找到的路径的边权和。\n\n接下来 $n-1$ 行，每行三个整数 $u_i,v_i,w_i$，代表有一条连接 $u_i$ 与 $v_i$，边权为 $w_i$ 的无向边。\n\n**注意：点从 $0$ 开始编号**。", "outputFormat": "输出一个整数，表示最小边数量。\n\n如果不存在这样的路径，输出 $-1$。", "hint": "对于 $100\\%$ 的数据，保证 $1\\leq n\\leq 2\\times10^5$，$0\\leq k,w_i\\leq 10^6$，$0\\leq u_i,v_i<n$。", "locale": "zh-CN", "translations": {"en": {"title": "[IOI 2011] Race", "background": "", "description": "Given a tree with a weight on each edge, find a simple path whose total weight equals $k$, with the minimum possible number of edges.", "inputFormat": "The first line contains two integers $n, k$, representing the number of vertices in the tree and the target path sum.\n\nEach of the next $n-1$ lines contains three integers $u_i, v_i, w_i$, representing an undirected edge between $u_i$ and $v_i$ with weight $w_i$.\n\n**Note: vertices are numbered starting from $0$.**", "outputFormat": "Output a single integer, the minimal number of edges.\n\nIf no such path exists, output $-1$.", "hint": "For $100\\%$ of the testdata, it is guaranteed that $1 \\leq n \\leq 2 \\times 10^5$, $0 \\leq k, w_i \\leq 10^6$, $0 \\leq u_i, v_i < n$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[IOI 2011] Race", "background": "", "description": "给一棵树，每条边有权。求一条简单路径，权值和等于 $k$，且边的数量最小。", "inputFormat": "第一行包含两个整数 $n,k$，表示树的大小与要求找到的路径的边权和。\n\n接下来 $n-1$ 行，每行三个整数 $u_i,v_i,w_i$，代表有一条连接 $u_i$ 与 $v_i$，边权为 $w_i$ 的无向边。\n\n**注意：点从 $0$ 开始编号**。", "outputFormat": "输出一个整数，表示最小边数量。\n\n如果不存在这样的路径，输出 $-1$。", "hint": "对于 $100\\%$ 的数据，保证 $1\\leq n\\leq 2\\times10^5$，$0\\leq k,w_i\\leq 10^6$，$0\\leq u_i,v_i<n$。", "locale": "zh-CN"}}}
{"pid": "P4150", "type": "P", "difficulty": 7, "samples": [["5\n0 0 1 0 0\n0 1 0 1 0\n0 2 0 1 0\n0 1 1 1 0\n0 0 0 0 0\n1 1 1 1 1\n5\n2 1 2 1 4\n1 1 1 10000\n2 1 2 1 4\n1 2 3 10000\n2 1 2 3 3", "0\n1\n2"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2009", "线段树", "O2优化", "WC"], "title": "[WC2009] 最短路问题", "background": "", "description": "【问题描述】\n\n一个 $6 * n$ 的方格，初始每个格子有一个非负权值。有如下两种操作形式：\n\n○改变一个格子的权值（改变以后仍然非负）；\n\n○求两个格子之间的最短路的权值。\n\n【注解与任务】\n\n任意格子 $P$ 的坐标$(x_P, y_P)$满足 $1 \\leq x_P \\leq 6$， $1 \\leq y_P \\leq n$。格子 $P$ 和 $Q$ 的曼哈顿距离定义为$|x_P - x_Q| + |y_P - y_Q|$。一个有序方格序列$(p_1, p_2, ..., p_n)$，若满足任意 $p_i$ 和 $p_i + 1$ 的曼哈顿距离为 $1$，则称该序列为一条从 $p_1$ 到 $p_n$ 的路径，其权值为$d(p1) + d(p2) + $...$ + d(p_n)$，其中 $d(P)$ 表示格子 $P$ 的权值。两个格子 $P$ 和 $Q$ 之间的最短路定义为从 $P$ 到 $Q$ 权值最小的路径。\n", "inputFormat": "第一行一个整数 $n$。接下来 $6$ 行，每行 $n$ 个整数，第 $i + 1$ 行第 $j$ 个整数表示初始格子$(i, j)$的权值。接下来是一个整数 $Q$， 后面的 $Q$ 行，每行描述一个操作。\n\n输入的操作有以下两种形式：\n\n操作 $1$： \"$1\\ x\\ y\\ c$\"(不含双引号)。表示将格子$(x, y)$的权值改成 $c$ ($1 \\leq x \\leq 6$, $1 \\leq y \\leq n$, $0 \\leq c \\leq 10000$) 。\n\n操作 $2$： \"$2\\ x_1\\ y_1\\ x_2\\ y_2$\"(不含双引号)。表示询问格子$(x_1, y_1)$和格子$(x_2, y_2)$之间的最短路的权值。（$1 \\leq x_1, x_2 \\leq 6$, $1 \\leq y_1, y_2 \\leq n$）\n", "outputFormat": "对于每个操作 $2$，按照它在输入中出现的顺序，依次输出一行一个整数表示\n\n求得的最短路权值。\n", "hint": "|数据编号|$n$|$Q$|数据编号|$n$|$Q$|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|$1$|$10$|$20$|$6$|$10^4$|$3\\times 10^4$|\n|$2$|$100$|$200$|$7$|$3.5\\times 10^4$|$3\\times 10^4$|\n|$3$|$10^3$|$2\\times 10^3$|$8$|$5\\times 10^4$|$5\\times 10^4$|\n|$4$|$10^4$|$10^4$|$9$|$10^5$|$6\\times 10^4$|\n|$5$|$10^4$|$10^4$|$10$|$10^5$|$10^5$|\n\n**2024/08/20: 增加 3 组 hack 数据**", "locale": "zh-CN", "translations": {"en": {"title": "[WC2009] Shortest Path Problem", "background": "", "description": "A $6 \\times n$ grid is given, where each cell initially has a non-negative weight. There are two types of operations:\n\n- Change the weight of a cell (the new weight is still non-negative).\n- Query the weight of the shortest path between two cells.\n\nNotes and task:\n\nFor any cell $P$, its coordinates $(x_P, y_P)$ satisfy $1 \\leq x_P \\leq 6$, $1 \\leq y_P \\leq n$. The Manhattan distance between cells $P$ and $Q$ is defined as $|x_P - x_Q| + |y_P - y_Q|$. An ordered sequence of cells $(p_1, p_2, \\ldots, p_k)$ is called a path from $p_1$ to $p_k$ if the Manhattan distance between any $p_i$ and $p_{i+1}$ is $1$. Its weight is $d(p_1) + d(p_2) + \\cdots + d(p_k)$, where $d(P)$ is the weight of cell $P$. The shortest path between two cells $P$ and $Q$ is a path from $P$ to $Q$ with the minimum total weight.", "inputFormat": "The first line contains an integer $n$. The next $6$ lines each contain $n$ integers; on the $(i+1)$-th line, the $j$-th integer is the initial weight of cell $(i, j)$. Then an integer $Q$ follows, and the next $Q$ lines each describe an operation.\n\nThere are two types of operations:\n\nType $1$: \"1 x y c\" (without double quotes). Set the weight of cell $(x, y)$ to $c$ ($1 \\leq x \\leq 6$, $1 \\leq y \\leq n$, $0 \\leq c \\leq 10000$).\n\nType $2$: \"2 x_1 y_1 x_2 y_2\" (without double quotes). Query the weight of the shortest path between cell $(x_1, y_1)$ and cell $(x_2, y_2)$ ($1 \\leq x_1, x_2 \\leq 6$, $1 \\leq y_1, y_2 \\leq n$).", "outputFormat": "For each type $2$ operation, in the order they appear, output one line with one integer: the weight of the shortest path.", "hint": "| Testdata ID | $n$ | $Q$ | Testdata ID | $n$ | $Q$ |\n|:-:|:-:|:-:|:-:|:-:|:-:|\n| $1$ | $10$ | $20$ | $6$ | $10^4$ | $3\\times 10^4$ |\n| $2$ | $100$ | $200$ | $7$ | $3.5\\times 10^4$ | $3\\times 10^4$ |\n| $3$ | $10^3$ | $2\\times 10^3$ | $8$ | $5\\times 10^4$ | $5\\times 10^4$ |\n| $4$ | $10^4$ | $10^4$ | $9$ | $10^5$ | $6\\times 10^4$ |\n| $5$ | $10^4$ | $10^4$ | $10$ | $10^5$ | $10^5$ |\n\n**2024/08/20: Added 3 sets of hack testdata.**\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2009] 最短路问题", "background": "", "description": "【问题描述】\n\n一个 $6 * n$ 的方格，初始每个格子有一个非负权值。有如下两种操作形式：\n\n○改变一个格子的权值（改变以后仍然非负）；\n\n○求两个格子之间的最短路的权值。\n\n【注解与任务】\n\n任意格子 $P$ 的坐标$(x_P, y_P)$满足 $1 \\leq x_P \\leq 6$， $1 \\leq y_P \\leq n$。格子 $P$ 和 $Q$ 的曼哈顿距离定义为$|x_P - x_Q| + |y_P - y_Q|$。一个有序方格序列$(p_1, p_2, ..., p_n)$，若满足任意 $p_i$ 和 $p_i + 1$ 的曼哈顿距离为 $1$，则称该序列为一条从 $p_1$ 到 $p_n$ 的路径，其权值为$d(p1) + d(p2) + $...$ + d(p_n)$，其中 $d(P)$ 表示格子 $P$ 的权值。两个格子 $P$ 和 $Q$ 之间的最短路定义为从 $P$ 到 $Q$ 权值最小的路径。\n", "inputFormat": "第一行一个整数 $n$。接下来 $6$ 行，每行 $n$ 个整数，第 $i + 1$ 行第 $j$ 个整数表示初始格子$(i, j)$的权值。接下来是一个整数 $Q$， 后面的 $Q$ 行，每行描述一个操作。\n\n输入的操作有以下两种形式：\n\n操作 $1$： \"$1\\ x\\ y\\ c$\"(不含双引号)。表示将格子$(x, y)$的权值改成 $c$ ($1 \\leq x \\leq 6$, $1 \\leq y \\leq n$, $0 \\leq c \\leq 10000$) 。\n\n操作 $2$： \"$2\\ x_1\\ y_1\\ x_2\\ y_2$\"(不含双引号)。表示询问格子$(x_1, y_1)$和格子$(x_2, y_2)$之间的最短路的权值。（$1 \\leq x_1, x_2 \\leq 6$, $1 \\leq y_1, y_2 \\leq n$）\n", "outputFormat": "对于每个操作 $2$，按照它在输入中出现的顺序，依次输出一行一个整数表示\n\n求得的最短路权值。\n", "hint": "|数据编号|$n$|$Q$|数据编号|$n$|$Q$|\n|:-:|:-:|:-:|:-:|:-:|:-:|\n|$1$|$10$|$20$|$6$|$10^4$|$3\\times 10^4$|\n|$2$|$100$|$200$|$7$|$3.5\\times 10^4$|$3\\times 10^4$|\n|$3$|$10^3$|$2\\times 10^3$|$8$|$5\\times 10^4$|$5\\times 10^4$|\n|$4$|$10^4$|$10^4$|$9$|$10^5$|$6\\times 10^4$|\n|$5$|$10^4$|$10^4$|$10$|$10^5$|$10^5$|\n\n**2024/08/20: 增加 3 组 hack 数据**", "locale": "zh-CN"}}}
{"pid": "P4151", "type": "P", "difficulty": 6, "samples": [["5 7\n1 2 2\n1 3 2\n2 4 1\n2 5 1\n4 5 3\n5 3 4\n4 3 2", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["图论", "贪心", "2011", "枚举", "深度优先搜索 DFS", "线性基", "向量", "WC"], "title": "[WC2011] 最大XOR和路径", "background": "", "description": "XOR（异或）是一种二元逻辑运算，其运算结果当且仅当两个输入的布尔值不相等时才为真，否则为假。 XOR 运算的真值表如下（$1$ 表示真， $0$ 表示假）：\n\n| 输入 | 输入 | 输出 |\n| :----------: | :----------: | :----------: |\n| A | B | A XOR B |\n| 0 | 0 | 0 |\n| 0 | 1 | 1 |\n| 1 | 0 | 1 |\n| 1 | 1 | 0 |\n\n\n而两个非负整数的 XOR 是指将它们表示成二进制数，再在对应的二进制位进行 XOR 运算。\n\n譬如 $12$ XOR $9$ 的计算过程如下：\n\n$$\n12=(1100)_2\\ \\ \\ 9=(1001)_2\\\\\n\\begin{matrix}\n&1\\ 1\\ 0\\ 0\\\\\n\\text{XOR}&1\\ 0\\ 0\\ 1\\\\\n\\hline\n&0\\ 1\\ 0\\ 1\\\\\n\\end{matrix}\\\\\n(0101)_2=5\n$$\n\n故 $12$ XOR $9 = 5$。\n\n容易验证， XOR 运算满足交换律与结合律，故计算若干个数的 XOR 时，不同的计算顺序不会对运算结果造成影响。从而，可以定义 $K$ 个非负整数 $A_1$，$A_2$，……，$A_{K-1}$，$A_K$的 XOR 和为\n\n$A_1$ XOR $A_2$ XOR …… XOR $A_{K-1}$ XOR $A_K$\n\n考虑一个边权为非负整数的无向连通图，节点编号为 $1$ 到 $N$，试求出一条从 $1$ 号节点到 $N$ 号节点的路径，使得路径上经过的边的权值的 XOR 和最大。\n\n路径可以重复经过某些点或边，当一条边在路径中出现了多次时，其权值在计算 XOR 和时也要被计算相应多的次数，具体见样例。\n", "inputFormat": "输入文件 xor.in 的第一行包含两个整数 $N$ 和 $M$， 表示该无向图中点的数目与边的数目。\n\n接下来 $M$ 行描述 $M$ 条边，每行三个整数 $S_i$， $T_i$ ， $D_i$， 表示 $S_i$ 与 $T_i$ 之间存在一条权值为 $D_i$ 的无向边。\n\n图中可能有重边或自环。\n", "outputFormat": "输出文件 xor.out 仅包含一个整数，表示最大的 XOR 和（十进制结果）。\n", "hint": "【样例说明】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p6bf4fgf.png)\n\n如图，路径$1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 3 \\rightarrow 5 \\rightarrow 2 \\rightarrow 4 \\rightarrow 5$对应的XOR和为\n\n$2$ XOR $1$ XOR $2$ XOR $4$ XOR $1$ XOR $1$ XOR $3 = 6$\n\n当然，一条边数更少的路径$1 \\rightarrow 3 \\rightarrow 5$对应的XOR和也是$2$ XOR $4 = 6$。\n\n【数据规模】\n\n对于 $20 \\%$ 的数据，$N \\leq 100$， $M \\leq 1000$，$D_i \\leq 10^{4}$；\n\n对于 $50 \\%$ 的数据，$N \\leq 1000$， $M \\leq 10000$，$D_i \\leq 10^{18}$；\n\n对于 $70 \\%$ 的数据，$N \\leq 5000$， $M \\leq 50000$，$D_i \\leq 10^{18}$；\n\n对于 $100 \\%$ 的数据，$N \\leq 50000$， $M \\leq 100000$，$D_i \\leq 10^{18}$。\n\n\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2011] Maximum XOR Sum Path", "background": "", "description": "XOR (exclusive OR) is a binary logical operation whose result is true if and only if the two input Boolean values are different; otherwise it is false. The truth table of the XOR operation is as follows ($1$ means true, $0$ means false):\n\n| Input | Input | Output |\n| :----------: | :----------: | :----------: |\n| A | B | A XOR B |\n| 0 | 0 | 0 |\n| 0 | 1 | 1 |\n| 1 | 0 | 1 |\n| 1 | 1 | 0 |\n\nThe XOR of two non-negative integers means writing them in binary and applying XOR on the corresponding bits.\n\nFor example, the computation of $12$ XOR $9$ is as follows:\n\n$$\n12=(1100)_2\\ \\ \\ 9=(1001)_2\\\\\n\\begin{matrix}\n&1\\ 1\\ 0\\ 0\\\\\n\\text{XOR}&1\\ 0\\ 0\\ 1\\\\\n\\hline\n&0\\ 1\\ 0\\ 1\\\\\n\\end{matrix}\\\\\n(0101)_2=5\n$$\n\nTherefore, $12$ XOR $9 = 5$.\n\nIt is easy to verify that XOR is commutative and associative, so the order does not affect the result when XOR-ing multiple numbers. Thus, we define the XOR sum of $K$ non-negative integers $A_1$, $A_2$, …, $A_{K-1}$, $A_K$ as\n\n$A_1$ XOR $A_2$ XOR … XOR $A_{K-1}$ XOR $A_K$.\n\nConsider an undirected connected graph with non-negative integer edge weights, with nodes numbered from $1$ to $N$. Find a path from node $1$ to node $N$ such that the XOR sum of the edge weights along the path is maximized.\n\nA path may visit some vertices or edges multiple times. When an edge appears multiple times in the path, its weight is counted the corresponding number of times in the XOR sum. See the sample for details.", "inputFormat": "The first line contains two integers $N$ and $M$, the number of nodes and edges in the undirected graph.\n\nThe next $M$ lines each describe an edge, with three integers $S_i$, $T_i$, $D_i$, indicating there is an undirected edge between $S_i$ and $T_i$ with weight $D_i$.\n\nMultiple edges and self-loops may exist.", "outputFormat": "Output a single integer, the maximum XOR sum (in decimal).", "hint": "[Sample Explanation]\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p6bf4fgf.png)\n\nAs shown, the path $1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 3 \\rightarrow 5 \\rightarrow 2 \\rightarrow 4 \\rightarrow 5$ has XOR sum\n\n$2$ XOR $1$ XOR $2$ XOR $4$ XOR $1$ XOR $1$ XOR $3 = 6$.\n\nOf course, a shorter path $1 \\rightarrow 3 \\rightarrow 5$ also has XOR sum $2$ XOR $4 = 6$.\n\nConstraints\n\n- For 20% of the testdata, $N \\leq 100$, $M \\leq 1000$, $D_i \\leq 10^{4}$.\n- For 50% of the testdata, $N \\leq 1000$, $M \\leq 10000$, $D_i \\leq 10^{18}$.\n- For 70% of the testdata, $N \\leq 5000$, $M \\leq 50000$, $D_i \\leq 10^{18}$.\n- For 100% of the testdata, $N \\leq 50000$, $M \\leq 100000$, $D_i \\leq 10^{18}$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2011] 最大XOR和路径", "background": "", "description": "XOR（异或）是一种二元逻辑运算，其运算结果当且仅当两个输入的布尔值不相等时才为真，否则为假。 XOR 运算的真值表如下（$1$ 表示真， $0$ 表示假）：\n\n| 输入 | 输入 | 输出 |\n| :----------: | :----------: | :----------: |\n| A | B | A XOR B |\n| 0 | 0 | 0 |\n| 0 | 1 | 1 |\n| 1 | 0 | 1 |\n| 1 | 1 | 0 |\n\n\n而两个非负整数的 XOR 是指将它们表示成二进制数，再在对应的二进制位进行 XOR 运算。\n\n譬如 $12$ XOR $9$ 的计算过程如下：\n\n$$\n12=(1100)_2\\ \\ \\ 9=(1001)_2\\\\\n\\begin{matrix}\n&1\\ 1\\ 0\\ 0\\\\\n\\text{XOR}&1\\ 0\\ 0\\ 1\\\\\n\\hline\n&0\\ 1\\ 0\\ 1\\\\\n\\end{matrix}\\\\\n(0101)_2=5\n$$\n\n故 $12$ XOR $9 = 5$。\n\n容易验证， XOR 运算满足交换律与结合律，故计算若干个数的 XOR 时，不同的计算顺序不会对运算结果造成影响。从而，可以定义 $K$ 个非负整数 $A_1$，$A_2$，……，$A_{K-1}$，$A_K$的 XOR 和为\n\n$A_1$ XOR $A_2$ XOR …… XOR $A_{K-1}$ XOR $A_K$\n\n考虑一个边权为非负整数的无向连通图，节点编号为 $1$ 到 $N$，试求出一条从 $1$ 号节点到 $N$ 号节点的路径，使得路径上经过的边的权值的 XOR 和最大。\n\n路径可以重复经过某些点或边，当一条边在路径中出现了多次时，其权值在计算 XOR 和时也要被计算相应多的次数，具体见样例。\n", "inputFormat": "输入文件 xor.in 的第一行包含两个整数 $N$ 和 $M$， 表示该无向图中点的数目与边的数目。\n\n接下来 $M$ 行描述 $M$ 条边，每行三个整数 $S_i$， $T_i$ ， $D_i$， 表示 $S_i$ 与 $T_i$ 之间存在一条权值为 $D_i$ 的无向边。\n\n图中可能有重边或自环。\n", "outputFormat": "输出文件 xor.out 仅包含一个整数，表示最大的 XOR 和（十进制结果）。\n", "hint": "【样例说明】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/p6bf4fgf.png)\n\n如图，路径$1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 3 \\rightarrow 5 \\rightarrow 2 \\rightarrow 4 \\rightarrow 5$对应的XOR和为\n\n$2$ XOR $1$ XOR $2$ XOR $4$ XOR $1$ XOR $1$ XOR $3 = 6$\n\n当然，一条边数更少的路径$1 \\rightarrow 3 \\rightarrow 5$对应的XOR和也是$2$ XOR $4 = 6$。\n\n【数据规模】\n\n对于 $20 \\%$ 的数据，$N \\leq 100$， $M \\leq 1000$，$D_i \\leq 10^{4}$；\n\n对于 $50 \\%$ 的数据，$N \\leq 1000$， $M \\leq 10000$，$D_i \\leq 10^{18}$；\n\n对于 $70 \\%$ 的数据，$N \\leq 5000$， $M \\leq 50000$，$D_i \\leq 10^{18}$；\n\n对于 $100 \\%$ 的数据，$N \\leq 50000$， $M \\leq 100000$，$D_i \\leq 10^{18}$。\n\n\n", "locale": "zh-CN"}}}
{"pid": "P4152", "type": "P", "difficulty": 6, "samples": [["3\n2 3\n3 4\n3 3\n3 4 4\n4 4\n5 9 7 8", "2\n4\n846"], ["1\n11 20\n97665 99289 91440 92389 93960 94623 96582 93975 98359 93492 90331\n", "3278"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}, "tags": ["数学", "2014", "莫比乌斯反演", "组合数学", "WC"], "title": "[WC2014] 时空穿梭", "background": "", "description": "小X驾驶着他的飞船准备穿梭过一个 $n$ 维空间，这个空间里每个点的坐标可以用 $n$ 个实数来表示，即 $(x_1, x_2, ... , x_n)$ 。\n\n为了穿过这个空间，小 X 需要在这个空间中选取 $c$ $(c \\geq 2)$ 个点作为飞船停留的地方，而这些点需要满足以下三个条件：\n\n$1$. 每个点的每一维坐标均为正整数，且第 $i$ 维坐标不超过 $m_i$ 。\n\n$2$. 第 $i + 1$ $(1 \\leq i < c)$ 个点的第 $j$ $(1 \\leq j \\leq n)$ 维坐标必须严格大于第 $i$ 个点的第 $j$ 维坐标。\n\n$3$. 存在一条直线经过所选的所有点。在这个 $n$ 维空间里，一条直线可以用 $2n$个实数 $p_1$, $p_2$, … , $p_n$, $v_1$, $v_2$, … , $v_n$ 表示。 直线经过点 $(x_1, x_2, ... , x_n)$ ，当且仅当存在实数 $t$，使得对 $i = 1$ … $n$ 均满足 $x_i$ = $p_i + tv_i$。\n\n小 X 还没有确定他的最终方案，请你帮他计算一下一共有多少种不同的方案满足他的要求。由于答案可能会很大，你只需要输出答案 mod $10 007$ 后的值。\n", "inputFormat": "输入文件 space.in 的第一行包含一个正整数 $T$ ，表示有 $T$ 组数据需要求解。\n\n每组数据包含两行，第一行包含两个正整数 $n$, $c$ $(c \\geq 2)$ ，分别表示空间的维数和需要选择的暂停点个数。\n\n第二行包含 $n$ 个正整数，依次表示 $m_1$, $m_2$, … , $m_n$。\n", "outputFormat": "输出文件 space.out 包含 $T$ 行，每行包含一个非负整数，依次对应每组数据\n\n的答案。\n", "hint": "【样例$1$说明】\n\n样例数据第一组共有两种可行方案：一种是选择 $(1,1)$ , $(2,2)$ , $(3,3)$ ，另一种是选择 $(1,2)$ , $(2,3)$ , $(3,4)$ 。\n\n【数据规模】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/84c5gmzc.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2014] Spacetime Shuttle", "background": "", "description": "Xiao X is piloting his spaceship to traverse an $n$-dimensional space, where each point is represented by $n$ real numbers, i.e., $(x_1, x_2, \\dots, x_n)$.\n\nTo pass through this space, Xiao X needs to choose $c$ ($c \\geq 2$) points in this space as stopping places for the spaceship, and these points must satisfy the following three conditions:\n\n1. Every coordinate of each point is a positive integer, and the $i$-th coordinate does not exceed $m_i$.\n2. For $1 \\leq i < c$ and $1 \\leq j \\leq n$, the $j$-th coordinate of the $(i+1)$-th point must be strictly greater than the $j$-th coordinate of the $i$-th point.\n3. There exists a straight line passing through all the chosen points. In this $n$-dimensional space, a straight line can be represented by $2n$ real numbers $p_1$, $p_2$, … , $p_n$, $v_1$, $v_2$, … , $v_n$. A line passes through a point $(x_1, x_2, \\dots, x_n)$ if and only if there exists a real number $t$ such that for $i = 1 \\dots n$ it holds that $x_i$ = $p_i + tv_i$.\n\nXiao X has not finalized his plan yet. Please help him compute how many different schemes satisfy his requirements. Since the answer may be very large, you only need to output the value of the answer mod $10 007$.", "inputFormat": "The first line contains a positive integer $T$, the number of test cases.\n\nFor each test case, there are two lines:\n- The first line contains two positive integers $n$, $c$ ($c \\geq 2$), denoting the dimension of the space and the number of stopping points to select.\n- The second line contains $n$ positive integers, which are $m_1$, $m_2$, … , $m_n$.", "outputFormat": "Output $T$ lines. Each line contains a non-negative integer, which is the answer for the corresponding test case.", "hint": "[Sample 1 Explanation]\n\nThere are two feasible schemes in the first sample: one is to choose $(1,1)$, $(2,2)$, $(3,3)$; the other is to choose $(1,2)$, $(2,3)$, $(3,4)$.\n\nConstraints\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/84c5gmzc.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2014] 时空穿梭", "background": "", "description": "小X驾驶着他的飞船准备穿梭过一个 $n$ 维空间，这个空间里每个点的坐标可以用 $n$ 个实数来表示，即 $(x_1, x_2, ... , x_n)$ 。\n\n为了穿过这个空间，小 X 需要在这个空间中选取 $c$ $(c \\geq 2)$ 个点作为飞船停留的地方，而这些点需要满足以下三个条件：\n\n$1$. 每个点的每一维坐标均为正整数，且第 $i$ 维坐标不超过 $m_i$ 。\n\n$2$. 第 $i + 1$ $(1 \\leq i < c)$ 个点的第 $j$ $(1 \\leq j \\leq n)$ 维坐标必须严格大于第 $i$ 个点的第 $j$ 维坐标。\n\n$3$. 存在一条直线经过所选的所有点。在这个 $n$ 维空间里，一条直线可以用 $2n$个实数 $p_1$, $p_2$, … , $p_n$, $v_1$, $v_2$, … , $v_n$ 表示。 直线经过点 $(x_1, x_2, ... , x_n)$ ，当且仅当存在实数 $t$，使得对 $i = 1$ … $n$ 均满足 $x_i$ = $p_i + tv_i$。\n\n小 X 还没有确定他的最终方案，请你帮他计算一下一共有多少种不同的方案满足他的要求。由于答案可能会很大，你只需要输出答案 mod $10 007$ 后的值。\n", "inputFormat": "输入文件 space.in 的第一行包含一个正整数 $T$ ，表示有 $T$ 组数据需要求解。\n\n每组数据包含两行，第一行包含两个正整数 $n$, $c$ $(c \\geq 2)$ ，分别表示空间的维数和需要选择的暂停点个数。\n\n第二行包含 $n$ 个正整数，依次表示 $m_1$, $m_2$, … , $m_n$。\n", "outputFormat": "输出文件 space.out 包含 $T$ 行，每行包含一个非负整数，依次对应每组数据\n\n的答案。\n", "hint": "【样例$1$说明】\n\n样例数据第一组共有两种可行方案：一种是选择 $(1,1)$ , $(2,2)$ , $(3,3)$ ，另一种是选择 $(1,2)$ , $(2,3)$ , $(3,4)$ 。\n\n【数据规模】\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/84c5gmzc.png)\n", "locale": "zh-CN"}}}
{"pid": "P4153", "type": "P", "difficulty": 7, "samples": [["3 3 1 3 100\n1 2 3\n2 3 4\n1 3 5\n", "8\n9\n12\n-1\n"], ["5 8 1 5 10\n1 2 45176\n1 3 41088\n1 4 32001\n2 5 48931\n3 5 39291\n4 5 28970\n2 3 48131\n4 2 49795\n", "116468\n117192\n118265\n120223\n145438\n147235\n149193\n157556\n158280\n161311\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}, "tags": ["搜索", "2015", "O2优化", "优先队列", "最小割", "WC"], "title": "[WC2015] k 小割", "background": "", "description": "给出一个有向带权网络 $G = (V, E)$，权值函数 $w: E \\rightarrow \\mathbb{Z^{*}}$（即任意边 $e$ 的权值 $w(e)$ 均为正整数），和点 $s, t \\in V$，使得在 $G' = (V, E - S)$ 上不存在 $s$ 到 $t$ 的路径。\n\n\n设 $\\mathfrak{S}$ 是所有满足条件的边集 $S$ 的全集，按 $w(S)$ 从小到大输出 $\\mathfrak{S}$ 中前 $k$ 小的边集的边权和。其中 $w(S) = \\sum_{e \\in S} w(e)$。\n", "inputFormat": "第一行包含 $5$ 个正整数 $n, m, s, t, k$，其中 $s, t, k$ 意义如上，$n, m$ 分别表示 $\\lvert V \\rvert, \\lvert E \\rvert$（即点数和边数）。规定图中的节点用 $1$ 到 $n$ 的整数表示。保证 $s \\neq t$。\n\n\n接下来 $m$ 行，每行 $3$ 个整数 $x, y, z$，表示一条边权为 $z$ 的从 $x$ 到 $y$ 的边。可能有重边但保证没有自环。\n", "outputFormat": "如果 $\\lvert \\mathfrak{S} \\rvert < k$，先输出 $\\lvert \\mathfrak{S} \\rvert$ 行，每行包含一个整数，表示前 $\\lvert \\mathfrak{S} \\rvert$ 个 $w(S)$；再输出一行一个整数 $-1$。\n\n\n如果 $\\lvert \\mathfrak{S} \\rvert \\geq k$，则输出 $k$ 行，表示前 $k$ 个 $w(S)$。\n\n\n两种情况均需按照 $w(S)$ 从小到大输出。\n", "hint": "| 测试点编号 | $n \\le$ | $m$ | $k \\le$ | 约束 |\n|:-:|:-:|:-:|:-:|:-:|\n| $1 \\sim 2$ | $10$ | $\\le 20$ | ${10}^6$ | 边权不超过 $65536$ |\n| $3 \\sim 6$ | $50$ | $\\le 100$ | $100$ | 边权不超过 $65536$ |\n| $7 \\sim 10$ | $3000$ | $= 2 n - 4$ | $5 \\times {10}^5$ | $s$ 有边连向所有非 $t$ 节点，所有非 $s$ 结点有边连向 $t$，边权不超过 $2^{31} - 1$ |\n| $11 \\sim 14$ | $1.5 \\times {10}^5$ | $= 2 n - 4$ | $5 \\times {10}^5$ | $s$ 有边连向所有非 $t$ 节点，所有非 $s$ 结点有边连向 $t$，边权不超过 $2^{31} - 1$ |\n| $15 \\sim 20$ | $50$ | $\\le 1500$ | $100$ | 边权不超过 $65536$ |", "locale": "zh-CN", "translations": {"en": {"title": "[WC2015] k-Min Cut", "background": "", "description": "Given a directed weighted network $G = (V, E)$, a weight function $w: E \\rightarrow \\mathbb{Z^{*}}$ (i.e., for any edge $e$, the weight $w(e)$ is a positive integer), and vertices $s, t \\in V$. Consider any edge set $S \\subseteq E$, and let $G' = (V, E - S)$. If there is no path from $s$ to $t$ in $G'$, then $S$ is valid.\n\nLet $\\mathfrak{S}$ be the set of all such edge sets $S$. Output the sums of edge weights of the smallest $k$ sets in $\\mathfrak{S}$ by nondecreasing $w(S)$, where $w(S) = \\sum_{e \\in S} w(e)$.", "inputFormat": "The first line contains $5$ positive integers $n, m, s, t, k$, where $s, t, k$ are as above, and $n, m$ denote $\\lvert V \\rvert, \\lvert E \\rvert$ (the numbers of vertices and edges). Vertices are labeled from $1$ to $n$. It is guaranteed that $s \\neq t$.\n\nThe next $m$ lines each contain $3$ integers $x, y, z$, representing a directed edge from $x$ to $y$ with weight $z$. Multiple edges may exist, but there are no self-loops.", "outputFormat": "If $\\lvert \\mathfrak{S} \\rvert < k$, first output $\\lvert \\mathfrak{S} \\rvert$ lines, each containing one integer, which are the first $\\lvert \\mathfrak{S} \\rvert$ values of $w(S)$. Then output one more line with a single integer $-1$.\n\nIf $\\lvert \\mathfrak{S} \\rvert \\geq k$, output $k$ lines, which are the first $k$ values of $w(S)$.\n\nIn both cases, the outputs must be in nondecreasing order of $w(S)$.", "hint": "| Test Point ID | $n \\le$ | $m$ | $k \\le$ | Constraints |\n|:-:|:-:|:-:|:-:|:-:|\n| $1 \\sim 2$ | $10$ | $\\le 20$ | ${10}^6$ | Edge weights do not exceed $65536$. |\n| $3 \\sim 6$ | $50$ | $\\le 100$ | $100$ | Edge weights do not exceed $65536$. |\n| $7 \\sim 10$ | $3000$ | $= 2 n - 4$ | $5 \\times {10}^5$ | $s$ has edges to all vertices other than $t$; every vertex other than $s$ has an edge to $t$; edge weights do not exceed $2^{31} - 1$. |\n| $11 \\sim 14$ | $1.5 \\times {10}^5$ | $= 2 n - 4$ | $5 \\times {10}^5$ | $s$ has edges to all vertices other than $t$; every vertex other than $s$ has an edge to $t$; edge weights do not exceed $2^{31} - 1$. |\n| $15 \\sim 20$ | $50$ | $\\le 1500$ | $100$ | Edge weights do not exceed $65536$. |\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2015] k 小割", "background": "", "description": "给出一个有向带权网络 $G = (V, E)$，权值函数 $w: E \\rightarrow \\mathbb{Z^{*}}$（即任意边 $e$ 的权值 $w(e)$ 均为正整数），和点 $s, t \\in V$，使得在 $G' = (V, E - S)$ 上不存在 $s$ 到 $t$ 的路径。\n\n\n设 $\\mathfrak{S}$ 是所有满足条件的边集 $S$ 的全集，按 $w(S)$ 从小到大输出 $\\mathfrak{S}$ 中前 $k$ 小的边集的边权和。其中 $w(S) = \\sum_{e \\in S} w(e)$。\n", "inputFormat": "第一行包含 $5$ 个正整数 $n, m, s, t, k$，其中 $s, t, k$ 意义如上，$n, m$ 分别表示 $\\lvert V \\rvert, \\lvert E \\rvert$（即点数和边数）。规定图中的节点用 $1$ 到 $n$ 的整数表示。保证 $s \\neq t$。\n\n\n接下来 $m$ 行，每行 $3$ 个整数 $x, y, z$，表示一条边权为 $z$ 的从 $x$ 到 $y$ 的边。可能有重边但保证没有自环。\n", "outputFormat": "如果 $\\lvert \\mathfrak{S} \\rvert < k$，先输出 $\\lvert \\mathfrak{S} \\rvert$ 行，每行包含一个整数，表示前 $\\lvert \\mathfrak{S} \\rvert$ 个 $w(S)$；再输出一行一个整数 $-1$。\n\n\n如果 $\\lvert \\mathfrak{S} \\rvert \\geq k$，则输出 $k$ 行，表示前 $k$ 个 $w(S)$。\n\n\n两种情况均需按照 $w(S)$ 从小到大输出。\n", "hint": "| 测试点编号 | $n \\le$ | $m$ | $k \\le$ | 约束 |\n|:-:|:-:|:-:|:-:|:-:|\n| $1 \\sim 2$ | $10$ | $\\le 20$ | ${10}^6$ | 边权不超过 $65536$ |\n| $3 \\sim 6$ | $50$ | $\\le 100$ | $100$ | 边权不超过 $65536$ |\n| $7 \\sim 10$ | $3000$ | $= 2 n - 4$ | $5 \\times {10}^5$ | $s$ 有边连向所有非 $t$ 节点，所有非 $s$ 结点有边连向 $t$，边权不超过 $2^{31} - 1$ |\n| $11 \\sim 14$ | $1.5 \\times {10}^5$ | $= 2 n - 4$ | $5 \\times {10}^5$ | $s$ 有边连向所有非 $t$ 节点，所有非 $s$ 结点有边连向 $t$，边权不超过 $2^{31} - 1$ |\n| $15 \\sim 20$ | $50$ | $\\le 1500$ | $100$ | 边权不超过 $65536$ |", "locale": "zh-CN"}}}
{"pid": "P4154", "type": "P", "difficulty": 7, "samples": [["3 2 4 1\n0 1 2 2 2", "001\n010\n1110"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2015", "Special Judge", "WC"], "title": "[WC2015] 混淆与破解", "background": "", "description": "小强和阿米巴是好朋友。\n\n\n阿米巴研发出了一套相当高端的图片识别系统，并把它写成了一个手机app。这个识别系统具备特殊的识别能力，比如说，它能够识别一张图片里是否有萌萌的小狗。\n\n\n这个app由两个模块组成，特征提取模块和分类模块。每当小强拍摄一张图片，特征提取模块就从中提取出一个长度为 $n$ 的 01 串并存储起来。当小强希望进行识别的时候，分类模块就会根据提取出的 01 串进行分类（即，输出一个 $0$ 或者 $1$ 的答案）。\n\n\n为了保护分类算法，阿米巴的这个 app 是经过加密处理的。经过对阿米巴的死缠烂打，小强弄明白了这个分类算法的工作原理。\n\n\n分类模块会从输入的这个 $n$ 位 01 串中恢复出 $m$ 位的“有效信息”。每个“有效信息” 都是经过某些输入变量的异或。之后，分类模块会利用这些 “有效信息” 进行运算来得到真正的结果。为了进一步加密，阿米巴还会加入 “噪声”。所谓 “噪声”，是指这个分类模块会故意按一定的比例将结果反转。小强拿到的可能是经过了反转的结果。\n\n\n举个例子，分类模块的算法步骤可能是这样的：\n\n```cpp\nfunction f(x[]):\n    z[0] = x[0] xor x[4] xor x[7]\n    z[1] = x[12] xor x[2]\n    z[2] = x[0] xor x[1] xor x[2] xor x[3]\n    result = h(z[])\n    return result xor g(x[])\n```\n其中 x[] 是一个 01 串，x[i] 表示其中的第 $i$ 位，即一个 $0$ 或 $1$ 的函数。\n\n\ng(x[]) 是某个在大多数情况下返回 $0$，偶尔返回 $1$ 的函数。$h$ 是某个关于 z[] 的函数，其返回值为 $0$ 或 $1$。\n\n\nz[0], z[1], z[2] 就是 “有效信息”。\n\n\n为了让小强无法从app中看出算法，这个算法被进行了混淆。为了方便起见，我们把混淆之后的算法叫做“混淆版算法”。混淆版算法的代码共有 $Q$ 行，它的每一行都是这个样子：\n\n```cpp\ny[u] = (not (y[v] and y[s])) xor y[d] xor y[e]\n```\n其中 y[] 是一个长度为 $L$ 的 01 数组；xor 表示异或，and 表示与，not 表示非。$u, v, s, d, e$ 是这一行的参数。初始的时候，y[0]～y[n - 1] 里面放置了 x[0]～x[n - 1] 这 $n$ 个输入位，其他地方都是 $0$。执行完这 $Q$ 行代码之后，y[0] 这个位就是输出。\n\n\n对于阿米巴的这种以损失性能为代价进行加密的行径，小强感到很愤怒。于是，小强打算从混淆版算法中破解出阿米巴的分类算法。为了方便起见，我们把破解得到的算法叫做“破解版算法”。小强希望你能够帮他破解出：\n\n\n如何提取有效信息。这个可以表述为 $m$ 个 $\\{0, 1, \\dots, n - 1\\}$ 的子集，每个子集对应了一个有效信息是从哪几个输入位异或得到的；\n\n把这 $m$ 位有效信息映射到分类结果上的函数 $h$。该函数用一个长度为 $2^m$，每一位均为 $0$ 或 $1$ 的查找表表示；这 $2^m$ 位分别对应了 $m$ 位有效信息每一种可能的情况。\n\n当然，这种破解算法是不唯一的，即，可能会有多种有效信息提取方法和查找表的组合。你只需要给出其中的一种即可。\n\n\n阿米巴保证，引入的噪声比例不超过 $p$。即，你需要求出的破解版算法，和混淆版算法至少在 $2^n(1 - p)$ 个不同输入上得到的结果是一样的；并且阿米巴保证这样的算法是存在的。\n\n\n同时，阿米巴也保证，这 $m$ 个有效信息都是必须的，即，$h$ 无法化简为少于 $m$ 个输入的函数。\n", "inputFormat": "第一行包含 $4$ 个整数 $n, m, L, Q$。\n\n\n接下来 $Q$ 行，每行包含 $5$ 个整数 $u, v, s, d, e$，表示每行的参数。\n", "outputFormat": "先输出 $m$ 行，每行包含 $1$ 个 $n$ 位 01 串，表示每个有效信息是由哪些输入位异或得到的。其中 $1$ 表示包含该输入位，$0$ 表示不包含。\n\n\n接下来输出一行一个长度为 $2^m$ 的 01 串，表示 $h$ 函数的查找表。查找表中的项按字典序进行排列。即，先排第一个有效信息是 $0$ 的，再排第一个有效信息是 $1$ 的。排第一个有效信息是 $0$ 的项的时候，先排第二个有效信息是 $0$ 的，再排第二个有效信息是 $1$ 的，以此类推。\n", "hint": "【样例解释】\n\n样例输入等价于如下代码\n\n```cpp\ny[] = 0000\ninput x[0..n-1]\ny[0..n-1] = x[0..n-1]\ny[0] = (not (y[1] and y[2])) xor y[2] xor y[2]\noutput y[0]\n```\n其中 x[0..n-1] 表示 01 串 $x$ 的第 $0$ 位到第 $n - 1$ 位。\n\n\n在这段代码中，每一种输入对应的输出如下：\n\n```cpp\ninput    000    001    010    011    100    101    110    111\noutput    1    1    1    0    1    1    1    0\n```\n样例输出是一种破解方案，等价于如下代码：\n\n```cpp\ninput x[0..n-1]\nz[0] = x[2]\nz[1] = x[1]\noutput h(z[])\n```\n$h$ 函数的输入和输出有如下对应关系：\n\n```cpp\nz[]        00    01    10    11\nh(z[])    1    1    1    0\n```\n可以发现，对于每一种输入，破解版算法和混淆版算法的输出是相同的。\n\n\n\n【限制与约定】\n\n\n对于 10% 的数据，$m = 1$，$p = 0$；\n\n对于另外 30% 的数据，$m = 1$；\n\n对于另外 20% 的数据，$m = 2$；\n\n对于另外 20% 的数据，$m = 3$；\n\n对于另外 20% 的数据，$m = 4$。\n\n对于所有的数据，$1 \\leq n \\leq 64$，$1 \\leq L \\leq 256$，$1 \\leq Q \\leq 1024$，$0 \\leq p \\leq 0.01$，$0 \\leq u, v, s, d, e < L$（注意，输入中并没有把 $p$ 的值给你）。\n\n\n【提示】\n\n使用位运算一次在多个输入上求出函数值可以极大的加速你的程序。\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2015] Obfuscation and Cracking", "background": "", "description": "Xiaoqiang and Amiba are good friends.\n\nAmiba developed a fairly advanced image recognition system and released it as a mobile app. This recognition system has special capabilities; for example, it can recognize whether there is a cute puppy in a picture.\n\nThe app consists of two modules: a feature extraction module and a classification module. Every time Xiaoqiang takes a photo, the feature extraction module extracts a length-$n$ binary string and stores it. When Xiaoqiang wants a recognition result, the classification module classifies based on the extracted binary string (i.e., outputs either $0$ or $1$).\n\nTo protect the classification algorithm, Amiba encrypted the app. After much pestering, Xiaoqiang figured out how the classification algorithm works.\n\nThe classification module recovers $m$ bits of “effective information” from the $n$-bit input binary string. Each “effective information” bit is the XOR of some input variables. Then, the classification module uses these “effective information” bits to compute the final result. To further obfuscate, Amiba also adds “noise”, meaning the module intentionally flips the result with a certain probability. The result Xiaoqiang gets may be flipped.\n\nFor example, the steps of the classification module could be:\n\n```cpp\nfunction f(x[]):\n    z[0] = x[0] xor x[4] xor x[7]\n    z[1] = x[12] xor x[2]\n    z[2] = x[0] xor x[1] xor x[2] xor x[3]\n    result = h(z[])\n    return result xor g(x[])\n```\nHere x[] is a binary string, and x[i] denotes its $i$-th bit, i.e., either $0$ or $1$.\n\ng(x[]) is a function that returns $0$ in most cases and occasionally returns $1$. $h$ is some function of z[] whose return value is $0$ or $1$.\n\nz[0], z[1], z[2] are the “effective information”.\n\nTo prevent Xiaoqiang from seeing the algorithm directly in the app, the algorithm was obfuscated. For convenience, we call the obfuscated algorithm the “obfuscated version”. The obfuscated version has $Q$ lines of code, each of the form:\n\n```cpp\ny[u] = (not (y[v] and y[s])) xor y[d] xor y[e]\n```\nHere y[] is a length-$L$ binary array; xor means XOR, and means AND, and not means NOT. $u, v, s, d, e$ are the parameters on that line. Initially, y[0] through y[n - 1] hold x[0] through x[n - 1], and all other positions are $0$. After executing these $Q$ lines, y[0] is the output.\n\nAngered by Amiba’s practice of trading performance for encryption, Xiaoqiang decides to recover the classification algorithm from the obfuscated version. For convenience, we call the recovered algorithm the “cracked version”. Xiaoqiang hopes you can help him recover:\n\n- How to extract the effective information. This can be represented as $m$ subsets of $\\{0, 1, \\dots, n - 1\\}$, where each subset indicates which input bits are XORed to produce one effective information bit.\n- The function $h$ mapping these $m$ effective information bits to the classification result. This function is represented by a lookup table of length $2^m$ whose entries are $0$ or $1$. These $2^m$ entries correspond to all possible values of the $m$ effective information bits.\n\nOf course, the recovered algorithm is not unique; multiple combinations of effective information extraction and lookup tables may work. You only need to provide one.\n\nAmiba guarantees that the noise rate is at most $p$. That is, your cracked version and the obfuscated version must agree on at least $2^n (1 - p)$ different inputs, and Amiba guarantees such an algorithm exists.\n\nAmiba also guarantees that all $m$ effective information bits are necessary, i.e., $h$ cannot be simplified to a function of fewer than $m$ inputs.", "inputFormat": "The first line contains 4 integers $n, m, L, Q$.\n\nThen follow $Q$ lines, each containing 5 integers $u, v, s, d, e$, giving the parameters of each line.", "outputFormat": "First output $m$ lines, each containing an $n$-bit binary string that indicates which input bits are XORed to produce each effective information bit. A 1 means the input bit is included; a 0 means it is not included.\n\nThen output one line containing a binary string of length $2^m$ representing the lookup table of the function $h$. The entries are listed in lexicographic order: first list entries where the first effective information bit is $0$, then where it is $1$. While listing entries where the first effective information bit is $0$, first list those where the second effective information bit is $0$, then where it is $1$, and so on.", "hint": "[Sample explanation]\n\nThe sample input is equivalent to the following code:\n\n```cpp\ny[] = 0000\ninput x[0..n-1]\ny[0..n-1] = x[0..n-1]\ny[0] = (not (y[1] and y[2])) xor y[2] xor y[2]\noutput y[0]\n```\nHere x[0..n-1] denotes bits $0$ through $n - 1$ of the binary string $x$.\n\nIn this code, the output for each input is:\n\n```cpp\ninput    000    001    010    011    100    101    110    111\noutput   1      1      1      0      1      1      1      0\n```\nA sample cracked solution is equivalent to:\n\n```cpp\ninput x[0..n-1]\nz[0] = x[2]\nz[1] = x[1]\noutput h(z[])\n```\nThe inputs and outputs of the function $h$ are:\n\n```cpp\nz[]       00    01    10    11\nh(z[])    1     1     1     0\n```\nYou can verify that for every input, the cracked version and the obfuscated version produce the same output.\n\nConstraints\n\n- For 10% of the testdata, $m = 1$, $p = 0$.\n- For another 30% of the testdata, $m = 1$.\n- For another 20% of the testdata, $m = 2$.\n- For another 20% of the testdata, $m = 3$.\n- For another 20% of the testdata, $m = 4$.\n- For all testdata, $1 \\leq n \\leq 64$, $1 \\leq L \\leq 256$, $1 \\leq Q \\leq 1024$, $0 \\leq p \\leq 0.01$, and $0 \\leq u, v, s, d, e < L$ (note that the value of $p$ is not provided in the input).\n\nTip\n\nUsing bitwise operations to evaluate the function on many inputs at once can greatly speed up your program.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2015] 混淆与破解", "background": "", "description": "小强和阿米巴是好朋友。\n\n\n阿米巴研发出了一套相当高端的图片识别系统，并把它写成了一个手机app。这个识别系统具备特殊的识别能力，比如说，它能够识别一张图片里是否有萌萌的小狗。\n\n\n这个app由两个模块组成，特征提取模块和分类模块。每当小强拍摄一张图片，特征提取模块就从中提取出一个长度为 $n$ 的 01 串并存储起来。当小强希望进行识别的时候，分类模块就会根据提取出的 01 串进行分类（即，输出一个 $0$ 或者 $1$ 的答案）。\n\n\n为了保护分类算法，阿米巴的这个 app 是经过加密处理的。经过对阿米巴的死缠烂打，小强弄明白了这个分类算法的工作原理。\n\n\n分类模块会从输入的这个 $n$ 位 01 串中恢复出 $m$ 位的“有效信息”。每个“有效信息” 都是经过某些输入变量的异或。之后，分类模块会利用这些 “有效信息” 进行运算来得到真正的结果。为了进一步加密，阿米巴还会加入 “噪声”。所谓 “噪声”，是指这个分类模块会故意按一定的比例将结果反转。小强拿到的可能是经过了反转的结果。\n\n\n举个例子，分类模块的算法步骤可能是这样的：\n\n```cpp\nfunction f(x[]):\n    z[0] = x[0] xor x[4] xor x[7]\n    z[1] = x[12] xor x[2]\n    z[2] = x[0] xor x[1] xor x[2] xor x[3]\n    result = h(z[])\n    return result xor g(x[])\n```\n其中 x[] 是一个 01 串，x[i] 表示其中的第 $i$ 位，即一个 $0$ 或 $1$ 的函数。\n\n\ng(x[]) 是某个在大多数情况下返回 $0$，偶尔返回 $1$ 的函数。$h$ 是某个关于 z[] 的函数，其返回值为 $0$ 或 $1$。\n\n\nz[0], z[1], z[2] 就是 “有效信息”。\n\n\n为了让小强无法从app中看出算法，这个算法被进行了混淆。为了方便起见，我们把混淆之后的算法叫做“混淆版算法”。混淆版算法的代码共有 $Q$ 行，它的每一行都是这个样子：\n\n```cpp\ny[u] = (not (y[v] and y[s])) xor y[d] xor y[e]\n```\n其中 y[] 是一个长度为 $L$ 的 01 数组；xor 表示异或，and 表示与，not 表示非。$u, v, s, d, e$ 是这一行的参数。初始的时候，y[0]～y[n - 1] 里面放置了 x[0]～x[n - 1] 这 $n$ 个输入位，其他地方都是 $0$。执行完这 $Q$ 行代码之后，y[0] 这个位就是输出。\n\n\n对于阿米巴的这种以损失性能为代价进行加密的行径，小强感到很愤怒。于是，小强打算从混淆版算法中破解出阿米巴的分类算法。为了方便起见，我们把破解得到的算法叫做“破解版算法”。小强希望你能够帮他破解出：\n\n\n如何提取有效信息。这个可以表述为 $m$ 个 $\\{0, 1, \\dots, n - 1\\}$ 的子集，每个子集对应了一个有效信息是从哪几个输入位异或得到的；\n\n把这 $m$ 位有效信息映射到分类结果上的函数 $h$。该函数用一个长度为 $2^m$，每一位均为 $0$ 或 $1$ 的查找表表示；这 $2^m$ 位分别对应了 $m$ 位有效信息每一种可能的情况。\n\n当然，这种破解算法是不唯一的，即，可能会有多种有效信息提取方法和查找表的组合。你只需要给出其中的一种即可。\n\n\n阿米巴保证，引入的噪声比例不超过 $p$。即，你需要求出的破解版算法，和混淆版算法至少在 $2^n(1 - p)$ 个不同输入上得到的结果是一样的；并且阿米巴保证这样的算法是存在的。\n\n\n同时，阿米巴也保证，这 $m$ 个有效信息都是必须的，即，$h$ 无法化简为少于 $m$ 个输入的函数。\n", "inputFormat": "第一行包含 $4$ 个整数 $n, m, L, Q$。\n\n\n接下来 $Q$ 行，每行包含 $5$ 个整数 $u, v, s, d, e$，表示每行的参数。\n", "outputFormat": "先输出 $m$ 行，每行包含 $1$ 个 $n$ 位 01 串，表示每个有效信息是由哪些输入位异或得到的。其中 $1$ 表示包含该输入位，$0$ 表示不包含。\n\n\n接下来输出一行一个长度为 $2^m$ 的 01 串，表示 $h$ 函数的查找表。查找表中的项按字典序进行排列。即，先排第一个有效信息是 $0$ 的，再排第一个有效信息是 $1$ 的。排第一个有效信息是 $0$ 的项的时候，先排第二个有效信息是 $0$ 的，再排第二个有效信息是 $1$ 的，以此类推。\n", "hint": "【样例解释】\n\n样例输入等价于如下代码\n\n```cpp\ny[] = 0000\ninput x[0..n-1]\ny[0..n-1] = x[0..n-1]\ny[0] = (not (y[1] and y[2])) xor y[2] xor y[2]\noutput y[0]\n```\n其中 x[0..n-1] 表示 01 串 $x$ 的第 $0$ 位到第 $n - 1$ 位。\n\n\n在这段代码中，每一种输入对应的输出如下：\n\n```cpp\ninput    000    001    010    011    100    101    110    111\noutput    1    1    1    0    1    1    1    0\n```\n样例输出是一种破解方案，等价于如下代码：\n\n```cpp\ninput x[0..n-1]\nz[0] = x[2]\nz[1] = x[1]\noutput h(z[])\n```\n$h$ 函数的输入和输出有如下对应关系：\n\n```cpp\nz[]        00    01    10    11\nh(z[])    1    1    1    0\n```\n可以发现，对于每一种输入，破解版算法和混淆版算法的输出是相同的。\n\n\n\n【限制与约定】\n\n\n对于 10% 的数据，$m = 1$，$p = 0$；\n\n对于另外 30% 的数据，$m = 1$；\n\n对于另外 20% 的数据，$m = 2$；\n\n对于另外 20% 的数据，$m = 3$；\n\n对于另外 20% 的数据，$m = 4$。\n\n对于所有的数据，$1 \\leq n \\leq 64$，$1 \\leq L \\leq 256$，$1 \\leq Q \\leq 1024$，$0 \\leq p \\leq 0.01$，$0 \\leq u, v, s, d, e < L$（注意，输入中并没有把 $p$ 的值给你）。\n\n\n【提示】\n\n使用位运算一次在多个输入上求出函数值可以极大的加速你的程序。\n", "locale": "zh-CN"}}}
{"pid": "P4155", "type": "P", "difficulty": 5, "samples": [["4 8\n2 5\n4 7\n6 1\n7 3", "3 3 4 3"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}, "tags": ["贪心", "2015", "四川", "倍增", "二分", "各省省选", "排序"], "title": "[SCOI2015] 国旗计划", "background": null, "description": "A 国正在开展一项伟大的计划 —— 国旗计划。这项计划的内容是边防战士手举国旗环绕边境线奔袭一圈。这项计划需要多名边防战士以接力的形式共同完成，为此，国土安全局已经挑选了 $N$ 名优秀的边防战士作为这项计划的候选人。\n\n\nA 国幅员辽阔，边境线上设有 $M$ 个边防站，顺时针编号 $1$ 至 $M$。每名边防战士常驻两个边防站，并且善于在这两个边防站之间长途奔袭，我们称这两个边防站之间的路程是这个边防战士的奔袭区间。$N$ 名边防战士都是精心挑选的，身体素质极佳，所以每名边防战士的奔袭区间都不会被其他边防战士的奔袭区间所包含。\n\n\n现在，国土安全局局长希望知道，至少需要多少名边防战士，才能使得他们的奔袭区间覆盖全部的边境线，从而顺利地完成国旗计划。不仅如此，安全局局长还希望知道更详细的信息：对于每一名边防战士，在他必须参加国旗计划的前提下，至少需要多少名边防战士才能覆盖全部边境线，从而顺利地完成国旗计划。", "inputFormat": "第一行，包含两个正整数 $N,M$，分别表示边防战士数量和边防站数量。\n\n\n随后 $N$ 行，每行包含两个正整数。其中第 $i$ 行包含的两个正整数 $C_i$、$D_i$ 分别表示 $i$ 号边防战士常驻的两个边防站编号，$C_i$ 号边防站沿顺时针方向至 $D_i$ 号边防站为他的奔袭区间。数据保证整个边境线都是可被覆盖的。", "outputFormat": "输出数据仅 $1$ 行，需要包含 $N$ 个正整数。其中，第 $j$ 个正整数表示 $j$ 号边防战士必须参加的前提下至少需要多少名边防战士才能顺利地完成国旗计划。", "hint": "$N\\leq 2×10^5,M<10^9,1\\leq C_i,D_i\\leq M$。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2015] National Flag Plan", "background": "", "description": "Country A is carrying out a great plan — the National Flag Plan. In this plan, border guards will run a full loop along the border line in relay while holding the national flag. This requires multiple border guards working together in relay. The National Security Agency has selected $N$ outstanding border guards as candidates.\n\nCountry A is vast, and there are $M$ border posts on the border line, numbered $1$ to $M$ clockwise. Each border guard is based at two border posts and is skilled at long-distance running between these two posts. We call the path between these two posts the guard’s running interval. The $N$ guards are carefully selected and in excellent physical condition, so no guard’s running interval is contained within another guard’s running interval.\n\nThe director of the National Security Agency wants to know the minimum number of border guards whose running intervals can cover the entire border line to successfully complete the National Flag Plan. Moreover, for each border guard, under the condition that he must participate, the director also wants to know the minimum number of border guards required to cover the entire border line.", "inputFormat": "The first line contains two positive integers $N, M$, the number of border guards and the number of border posts.\n\nThen follow $N$ lines, each containing two positive integers. On the $i$-th line, the two integers $C_i, D_i$ denote the indices of the two border posts where guard $i$ is based. The running interval of guard $i$ is from post $C_i$ to post $D_i$ in the clockwise direction. It is guaranteed that the entire border line can be covered.", "outputFormat": "Output a single line containing $N$ positive integers. The $j$-th integer denotes, under the condition that guard $j$ must participate, the minimum number of border guards required to successfully complete the National Flag Plan.", "hint": "Constraints: $N \\leq 2 \\times 10^5, M < 10^9, 1 \\leq C_i, D_i \\leq M$.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2015] 国旗计划", "background": null, "description": "A 国正在开展一项伟大的计划 —— 国旗计划。这项计划的内容是边防战士手举国旗环绕边境线奔袭一圈。这项计划需要多名边防战士以接力的形式共同完成，为此，国土安全局已经挑选了 $N$ 名优秀的边防战士作为这项计划的候选人。\n\n\nA 国幅员辽阔，边境线上设有 $M$ 个边防站，顺时针编号 $1$ 至 $M$。每名边防战士常驻两个边防站，并且善于在这两个边防站之间长途奔袭，我们称这两个边防站之间的路程是这个边防战士的奔袭区间。$N$ 名边防战士都是精心挑选的，身体素质极佳，所以每名边防战士的奔袭区间都不会被其他边防战士的奔袭区间所包含。\n\n\n现在，国土安全局局长希望知道，至少需要多少名边防战士，才能使得他们的奔袭区间覆盖全部的边境线，从而顺利地完成国旗计划。不仅如此，安全局局长还希望知道更详细的信息：对于每一名边防战士，在他必须参加国旗计划的前提下，至少需要多少名边防战士才能覆盖全部边境线，从而顺利地完成国旗计划。", "inputFormat": "第一行，包含两个正整数 $N,M$，分别表示边防战士数量和边防站数量。\n\n\n随后 $N$ 行，每行包含两个正整数。其中第 $i$ 行包含的两个正整数 $C_i$、$D_i$ 分别表示 $i$ 号边防战士常驻的两个边防站编号，$C_i$ 号边防站沿顺时针方向至 $D_i$ 号边防站为他的奔袭区间。数据保证整个边境线都是可被覆盖的。", "outputFormat": "输出数据仅 $1$ 行，需要包含 $N$ 个正整数。其中，第 $j$ 个正整数表示 $j$ 号边防战士必须参加的前提下至少需要多少名边防战士才能顺利地完成国旗计划。", "hint": "$N\\leq 2×10^5,M<10^9,1\\leq C_i,D_i\\leq M$。", "locale": "zh-CN"}}}
{"pid": "P4156", "type": "P", "difficulty": 7, "samples": [["1\n4 11\nbbab", "5"], ["2\n44 1000\nbaaaaaabaabbaaabbbbabbbaaabbbababaaabaaabaaa\n41 1000\nabaabbabaaabaabbbbbbbbbbbababbbbaaabaabbb", "195\n24"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}, "tags": ["2016", "单调队列", "数论", "图论建模", "最短路", "KMP 算法", "WC"], "title": "[WC2016] 论战捆竹竿", "background": "", "description": "是一个美好的下午，小 W 和小 C 在竹林里切磋捆竹竿的技艺。\n\n竹林里有无数根完全一样的短竹子，每一根竹子由 $n$ 节组成。\n\n这些竹子比较特别，每一节都被染上了颜色。可能的颜色一共 $26$ 种，分别用小写英文字母 $\\underline{a}$ 到 $\\underline{z}$ 表示。也就是说，如果把竹子的底端到顶端的颜色按顺序写出来可以排成一个由小写英文字母组成的字符串。\n\n小 W 和小 C 都是捆竹竿的高手，他们知道怎样才能把零散的短竹子捆成一整根长竹竿。 初始时你拿着一根短竹子作为当前的竹竿。 每次你可以选择一根短竹子，短竹子底端若干节（可以是 $0$ 节）与竹竿的最上面若干节对应地一节一节捆起来，而短竹子前面剩下的节伸出去，这样就得到了一根更长的竹竿。注意，竹子的底端是靠近根部的那一端，不可以颠倒。\n\n小 W 对竹竿的审美要求很高， 他捆竹竿时有一个癖好： 如果两根竹子的某两节被捆在了一起，那么它们的颜色必须相同。\n\n我们假设一根短竹子从底端到顶端每节的颜色为 $\\underline{aba}$。\n\n那么两根竹子可以首尾捆在一起，可以得到一根颜色为 $\\underline{abaaba}$ 的竹竿；也可以将第一根顶端的一节 $\\underline{a}$ 与第二根底端的一节 $\\underline{a}$ 捆在一起，得到一根颜色为$\\underline{ababa}$ 的竹竿； 还可以直接将每一节都对应起来，捆成一根颜色为 $\\underline{aba}$ 的竹竿。\n\n假设我们在颜色为 $\\underline{ababa}$ 的竹竿顶端再捆一根竹子，则可以捆成 $\\underline{ababaaba}$，$\\underline{abababa}$ 和 $\\underline{ababa}$ 三种不同的情况。\n\n但是小 C 在这个问题上有不同的看法，他认为小 W 捆不出很多种长度不同的竹竿。小 W 非常不服，于是他找到了你——现在请你求出在竹竿长度不超过 $w$ 的情况下， 小 W 可以捆出多少种长度不同的竹竿。 其中， 竹竿的长度指从底端到顶端的竹子的节的个数。\n\n注意：如果 $w < n$，则没有合法的长度，此时答案为 $0$。\n", "inputFormat": "输入文件 jie.in 第一行包含 $1$ 个整数 $t$，为数据组数。\n\n每组数据的第一行包含 $2$ 个正整数 $n$ 和 $w$， 表示短竹子的长度和竹竿的长度上限。\n\n每组数据的第二行包含一个长度为 $n$ 的字符串，该字符串仅由小写英文字母构成，表示短竹子从底端到顶端每节的颜色。\n", "outputFormat": "输出文件为 jie.out。\n\n输出共 $T$ 行，每行包含一个整数表示捆成竹竿的不同长度种数。\n", "hint": "【样例解释$1$】\n\n可以捆成长度不超过 $11$ 的竹竿有 $6$ 种不同的情况：\n\n```\nbbab\nbbabbab\nbbabbbab\nbbabbabbab\nbbabbabbbab\nbbabbbabbab\n```\n\n后两种竹竿长度相同，因此不同长度的竹竿共有 $5$ 种。长度分别为： $4$， $7$，$8$， $10$， $11$。\n\n【数据规模和约定】\n\n对于所有的测试数据，保证所有的字符串均由小写字母构成。\n\n各测试点满足以下约定：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d4nlqw86.png)\n", "locale": "zh-CN", "translations": {"en": {"title": "[WC2016] On Bundling Bamboo Poles", "background": "", "description": "It is a beautiful afternoon. Little W and Little C are practicing the skill of bundling bamboo poles in a bamboo grove.\n\nThere are infinitely many identical short bamboos in the grove. Each short bamboo consists of $n$ segments.\n\nThese bamboos are special: every segment is dyed a color. There are 26 possible colors, represented by lowercase letters $\\underline{a}$ to $\\underline{z}$. In other words, if you write down the colors from the bottom end to the top end of a bamboo, you get a string of lowercase letters.\n\nLittle W and Little C are masters at bundling bamboos. They know how to bind scattered short bamboos into one long bamboo pole. Initially, you hold one short bamboo as the current pole. Each time, you may choose one short bamboo and bind some number of its bottom segments (possibly $0$) one by one to the top segments of the current pole. The remaining segments in front protrude, producing a longer pole. Note that the bottom end is the end near the root; you cannot flip a bamboo.\n\nLittle W has high aesthetic standards. He has a habit when bundling: if two segments of two bamboos are bound together, then their colors must be the same.\n\nSuppose a short bamboo’s colors from bottom to top are $\\underline{aba}$.\n\nThen two bamboos can be bundled end-to-end to obtain a pole with colors $\\underline{abaaba}$; you can also bind the top segment $\\underline{a}$ of the first bamboo to the bottom segment $\\underline{a}$ of the second bamboo to obtain $\\underline{ababa}$; you can also align every segment and bind them all, forming a pole with colors $\\underline{aba}$.\n\nIf we bundle another short bamboo on top of the pole with colors $\\underline{ababa}$, we can obtain three different outcomes: $\\underline{ababaaba}$, $\\underline{abababa}$, and $\\underline{ababa}$.\n\nHowever, Little C disagrees. He believes Little W cannot produce many different lengths of bamboo poles. Little W is not convinced and asks you for help—please compute, under the constraint that the pole length does not exceed $w$, how many distinct lengths of bamboo poles Little W can produce. Here, the length of a pole is the number of segments from the bottom end to the top end.\n\nNote: If $w < n$, then there is no valid length. In this case, the answer is $0$.", "inputFormat": "The input file is jie.in. The first line contains one integer $T$, the number of test cases.\n\nFor each test case, the first line contains two positive integers $n$ and $w$, representing the length of a short bamboo and the upper bound on the pole length.\n\nThe second line contains a string of length $n$ consisting only of lowercase letters, representing the colors of the short bamboo from the bottom end to the top end.", "outputFormat": "The output file is jie.out.\n\nOutput $T$ lines. Each line contains one integer, the number of distinct lengths obtainable by bundling.", "hint": "[Sample Explanation 1]\n\nThere are 6 different configurations of poles with length not exceeding $11$:\n\n```\nbbab\nbbabbab\nbbabbbab\nbbabbabbab\nbbabbabbbab\nbbabbbabbab\n```\n\nThe last two poles have the same length, so there are 5 distinct lengths. The lengths are: $4$, $7$, $8$, $10$, $11$.\n\nConstraints\n\nFor all testdata, all strings consist of lowercase letters.\n\nEach test point satisfies the following agreement:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d4nlqw86.png)\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[WC2016] 论战捆竹竿", "background": "", "description": "是一个美好的下午，小 W 和小 C 在竹林里切磋捆竹竿的技艺。\n\n竹林里有无数根完全一样的短竹子，每一根竹子由 $n$ 节组成。\n\n这些竹子比较特别，每一节都被染上了颜色。可能的颜色一共 $26$ 种，分别用小写英文字母 $\\underline{a}$ 到 $\\underline{z}$ 表示。也就是说，如果把竹子的底端到顶端的颜色按顺序写出来可以排成一个由小写英文字母组成的字符串。\n\n小 W 和小 C 都是捆竹竿的高手，他们知道怎样才能把零散的短竹子捆成一整根长竹竿。 初始时你拿着一根短竹子作为当前的竹竿。 每次你可以选择一根短竹子，短竹子底端若干节（可以是 $0$ 节）与竹竿的最上面若干节对应地一节一节捆起来，而短竹子前面剩下的节伸出去，这样就得到了一根更长的竹竿。注意，竹子的底端是靠近根部的那一端，不可以颠倒。\n\n小 W 对竹竿的审美要求很高， 他捆竹竿时有一个癖好： 如果两根竹子的某两节被捆在了一起，那么它们的颜色必须相同。\n\n我们假设一根短竹子从底端到顶端每节的颜色为 $\\underline{aba}$。\n\n那么两根竹子可以首尾捆在一起，可以得到一根颜色为 $\\underline{abaaba}$ 的竹竿；也可以将第一根顶端的一节 $\\underline{a}$ 与第二根底端的一节 $\\underline{a}$ 捆在一起，得到一根颜色为$\\underline{ababa}$ 的竹竿； 还可以直接将每一节都对应起来，捆成一根颜色为 $\\underline{aba}$ 的竹竿。\n\n假设我们在颜色为 $\\underline{ababa}$ 的竹竿顶端再捆一根竹子，则可以捆成 $\\underline{ababaaba}$，$\\underline{abababa}$ 和 $\\underline{ababa}$ 三种不同的情况。\n\n但是小 C 在这个问题上有不同的看法，他认为小 W 捆不出很多种长度不同的竹竿。小 W 非常不服，于是他找到了你——现在请你求出在竹竿长度不超过 $w$ 的情况下， 小 W 可以捆出多少种长度不同的竹竿。 其中， 竹竿的长度指从底端到顶端的竹子的节的个数。\n\n注意：如果 $w < n$，则没有合法的长度，此时答案为 $0$。\n", "inputFormat": "输入文件 jie.in 第一行包含 $1$ 个整数 $t$，为数据组数。\n\n每组数据的第一行包含 $2$ 个正整数 $n$ 和 $w$， 表示短竹子的长度和竹竿的长度上限。\n\n每组数据的第二行包含一个长度为 $n$ 的字符串，该字符串仅由小写英文字母构成，表示短竹子从底端到顶端每节的颜色。\n", "outputFormat": "输出文件为 jie.out。\n\n输出共 $T$ 行，每行包含一个整数表示捆成竹竿的不同长度种数。\n", "hint": "【样例解释$1$】\n\n可以捆成长度不超过 $11$ 的竹竿有 $6$ 种不同的情况：\n\n```\nbbab\nbbabbab\nbbabbbab\nbbabbabbab\nbbabbabbbab\nbbabbbabbab\n```\n\n后两种竹竿长度相同，因此不同长度的竹竿共有 $5$ 种。长度分别为： $4$， $7$，$8$， $10$， $11$。\n\n【数据规模和约定】\n\n对于所有的测试数据，保证所有的字符串均由小写字母构成。\n\n各测试点满足以下约定：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d4nlqw86.png)\n", "locale": "zh-CN"}}}
{"pid": "P4157", "type": "P", "difficulty": 5, "samples": [["13", "3\n108\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}, "tags": ["高精度", "2006", "四川", "各省省选", "枚举", "快速傅里叶变换 FFT"], "title": "[SCOI2006] 整数划分", "background": "", "description": "从文件中读入一个正整数 $n$（$10 \\le n \\le 31000$）。要求将 $n$ 写成若干个正整数之和，并且使这些正整数的乘积最大。\n\n例如，$n=13$，则当 $n$ 表示为 $4+3+3+3$（或 $2+2+3+3+3$）时，乘积 $=108$ 为最大。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "第 $1$ 行输出一个整数，为最大乘积的位数。\n\n第 $2$ 行输出最大乘积的前 $100$ 位，如果不足 $100$ 位，则按实际位数输出最大乘积。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$10 \\le n \\le 31000$，同时保证最大乘积的位数不超过 $5000$ 位。", "locale": "zh-CN", "translations": {"en": {"title": "[SCOI2006] Integer Partition", "background": "", "description": "Read a positive integer $n$ from the file ($10 \\le n \\le 31000$). You need to write $n$ as a sum of several positive integers, and make the product of these integers as large as possible.\n\nFor example, when $n=13$, if $n$ is written as $4+3+3+3$ (or $2+2+3+3+3$), the product $=108$ is maximal.", "inputFormat": "One line with a positive integer $n$.", "outputFormat": "Line 1: output an integer, the number of digits of the maximum product.\n\nLine 2: output the first 100 digits of the maximum product. If it has fewer than 100 digits, output the maximum product with its actual number of digits.", "hint": "Constraints\n\nFor all testdata, $10 \\le n \\le 31000$, and it is guaranteed that the number of digits of the maximum product does not exceed 5000 digits.\n\nTranslated by ChatGPT 5", "locale": "en"}, "zh-CN": {"title": "[SCOI2006] 整数划分", "background": "", "description": "从文件中读入一个正整数 $n$（$10 \\le n \\le 31000$）。要求将 $n$ 写成若干个正整数之和，并且使这些正整数的乘积最大。\n\n例如，$n=13$，则当 $n$ 表示为 $4+3+3+3$（或 $2+2+3+3+3$）时，乘积 $=108$ 为最大。", "inputFormat": "一行一个正整数 $n$。", "outputFormat": "第 $1$ 行输出一个整数，为最大乘积的位数。\n\n第 $2$ 行输出最大乘积的前 $100$ 位，如果不足 $100$ 位，则按实际位数输出最大乘积。\n", "hint": "### 数据范围及约定\n\n对于全部数据，$10 \\le n \\le 31000$，同时保证最大乘积的位数不超过 $5000$ 位。", "locale": "zh-CN"}}}
